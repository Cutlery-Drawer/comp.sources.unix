Subject:  v08i014:  A Micro-Emacs variant that resembles GNU Emacs
Newsgroups: mod.sources
Approved: mirror!rs

Submitted by: Bob Larson <seismo!usc-oberon!blarson>
Mod.sources: Volume 8, Issue 14
Archive-name: micrognu/Part07


#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	tty/amiga/ttykbd.c
#	tty/amiga/ttymouse.c
#	sys/amiga/Makefile.LATTICE
#	sys/amiga/Makefile.MANX
#	sys/amiga/amiga.doc
#	sys/amiga/fileio.c
#	sys/amiga/sleep.c
#	sys/amiga/spawn.c
#	sys/amiga/sysdef.h
#	sys/amiga/varargs.h
# This archive created: Sat Nov 15 15:34:45 1986
export PATH; PATH=/bin:$PATH
if test -f 'tty/amiga/ttykbd.c'
then
	echo shar: will not over-write existing file "'tty/amiga/ttykbd.c'"
else
cat << \SHAR_EOF > 'tty/amiga/ttykbd.c'
/*
 * Name:	MicroEMACS
 * 		Amiga virtual terminal keyboard, default console keymap.
 * Version:	Gnu v30
 * Last edit:	25-Oct-86
 * Created:	19-Apr-86 ...!ihnp4!seismo!ut-sally!ut-ngp!mic
 *		This goes with the Intuition terminal driver,
 *		and implements Mike Meyer's hot mouse.
 */
#include	<exec/types.h>
#include	<intuition/intuition.h>
#undef	TRUE
#undef	FALSE
#include	"def.h"

#define	ESC	0x1B			/* Escape, arrows et al.	*/
#define	CSI	0x9B			/* Amiga CSI			*/

#ifdef	MOUSE
/* Stuff for the hot mouse.  Since right now the mouse
 * keys get bound into a wierd place, a lot of the
 * jiggery-pokery up here is to make it possible
 * to shift their location in the keymap without too
 * much fuss.  Sorry for the horrid macro names...
 */

/* key code w/o mini qualifiers */
#define	WMOUSE	((KEY)(KCTRL | KMETA | 'a'))
#define SMOUSE	((KEY)(KCTRL | KMETA | 'i'))
#define	EMOUSE	((KEY)(KCTRL | KMETA | 'q'))

/* mini qualifiers */
#define	SHFT	1
#define ALT	2
#define CTRL	4

/* macros to create qualified key codes */

#define	S(k)	(k + SHFT)
#define	A(k)	(k + ALT)
#define	C(k)	(k + CTRL)
#define	AS(k)	(k + SHFT + ALT)
#define	CS(k)	(k + CTRL + SHFT)
#define	CA(k)	(k + CTRL + ALT)
#define	CAS(k)	(k + SHFT + ALT + CTRL)
#endif /* ifdef MOUSE */

#ifdef	XKEYS
/*
 * The function keys on the Amiga send back
 * escape sequences of the form <ESC>[code~, where code
 * is a one or two-character code for the key.  To make
 * it easier to decode, we place the internal key values
 * for these codes in this table.
 */

short	consolemap[] = {
	KF1,		KF2,		KF3,		KF4,
	KF5,		KF6,		KF7,		KF8,
	KF9,		KF10,		KSF1,		KSF2,
	KSF3,		KSF4,		KSF5,		KSF6,
	KSF7,		KSF8,		KSF9,		KSF10
};
#define	NFUNCKEYS ((sizeof consolemap)/(sizeof consolemap[0]))
#endif

/*
 * Names for the keys with basic keycode
 * between KFIRST and KLAST (inclusive). This is used by
 * the key name routine in "kbd.c".  KFIRST is KRANDOM,
 * which we don't bind anything useful to.  "The Menu" is
 * special; we implement menus as another function key,
 * but there isn't really any "MENU" key on the keyboard.
 * There is no shifted value for the help key.  Mouse clicks
 * have been moved to a hitherto unused part of the keymap.
 */
#ifdef	DO_MENU
#define MENUNAME "The Menu"
#else
#define MENUNAME NULL
#endif

char	*keystrings[] = {
#ifdef	XKEYS
	NULL,		"F1",		"F2",		"F3",
	"F4",		"F5",		"F6",		"F7",
	"F8",		"F9",		"F10",		"Shift-F1",
	"Shift-F2",	"Shift-F3",	"Shift-F4",	"Shift-F5",
	"Shift-F6",	"Shift-F7",	"Shift-F8",	"Shift-F9",
	"Shift-F10",	"Up",		"Shift-Up",	"Down",
	"Shift-Down",	"Left",		"Shift-Left",	"Right",
	"Shift-Right",	"Help",		MENUNAME,	NULL
#else
	NULL,		NULL,		NULL,		NULL,
	NULL,		NULL,		NULL,		NULL,
	NULL,		NULL,		NULL,		NULL,
	NULL,		NULL,		NULL,		NULL,
	NULL,		NULL,		NULL,		NULL,
	NULL,		NULL,		NULL,		NULL,
	NULL,		NULL,		NULL,		NULL,
	NULL,		NULL,		MENUNAME,	NULL
#endif
};

/*
 * Read in a key, doing the low level mapping
 * of ASCII code to 11 bit code. This level deals with
 * mapping the special keys into their spots in the C1
 * control area. The C0 controls go right through, and
 * get remapped by "getkey".  Returning function keys
 * with KMETA set distinguishes these keys from codes
 * generated by ALT-ing a control key (which I want
 * to have mapped in the usual way).
 */

getkbd()
{
	register int	c;
#ifdef	XKEYS
	register int	n;
#endif
loop:
	c = ttgetc();
	if (c == CSI) {
		c = ttgetc();
#ifdef	MOUSE
		if (c == 'P') {			/* mouse sequence	*/
			ttgetc();		/* discard '~'		*/
			return (KCTRL | getmouse());	/* create key code	*/
		}
#endif

#ifdef	DO_MENU
		if (c == 'M') {			/* (fake) menu key	*/
			ttgetc();		/* discard '~'		*/
			return (KCTRL | KMENU);
		}
#endif

#ifdef	XKEYS
		if (c == '?') {			/* HELP key		*/
			ttgetc();		/* discard '~'		*/
			return (KCTRL | KHELP);
		}
		/* Arrow keys */
		if (c == 'A')
			return (KCTRL | KUP);
		if (c == 'B')
			return (KCTRL | KDOWN);
		if (c == 'C')
			return (KCTRL | KRIGHT);
		if (c == 'D')
			return (KCTRL | KLEFT);
		if (c == 'T')
			return (KCTRL | KSUP);
		if (c == 'S')
			return (KCTRL | KSDOWN);
		/* Shifted left, right arrow */
		if (c == ' ') {
			c = ttgetc();
			if (c == 'A' || c == '@')
				return (KCTRL | ((c == 'A') ?
					(KSLEFT) : (KSRIGHT)));
			goto loop;		/* try again, sucker */
		}

		/* Function keys	*/
		if (c >= '0' && c <= '9') {
			n = 0;
			do {
				n = 10*n + c - '0';
				c = ttgetc();
			} while (c>='0' && c<='9');
			if (c == '~' && n < NFUNCKEYS) {
				c = consolemap[n];
				if (c != KRANDOM)
					return (KCTRL | c);
				goto loop;
			}
			else 
				goto loop;	/* Try again */
		}
#endif
		goto loop;		/* Try again */
	}
	return (c);
}

#ifdef	MOUSE
/*
 * A hack for the hot mouse -- peek ahead at the
 * next mouse event and construct an internal key
 * code.  Might as well use those extra binding slots...
 */

getmouse()
{
	USHORT		row, col, qual;
	int ttmouse();
	register int	code = 0;
	register struct WINDOW *wp;

	ttmouse(FALSE, &row, &col, &qual);	/* look at mouse */

	/* was the click in a window ???	*/
	for (wp = wheadp; wp != NULL; wp = wp->w_wndp)
		if ((row >= wp->w_toprow) &&
		    (row <= (wp->w_toprow + wp->w_ntrows)))
			break ;

	/* figure out what area the click was in			*/
	if (wp == NULL)			/* not found; assume echo line	*/
		code = EMOUSE;
	else if (row == (wp->w_toprow + wp->w_ntrows))	/* status line	*/
		code = SMOUSE;
	else
		code = WMOUSE;	/* click in a window		*/

	/* figure out 'mini' qualifiers -- ADD them, because 'a' isn't	*/
	/* divisible by 2...  This took me 2 hours to realize...       	*/
	if (qual & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT))
		code += SHFT;
	if (qual & (IEQUALIFIER_LALT | IEQUALIFIER_RALT))
		code += ALT;
	if (qual & IEQUALIFIER_CONTROL)
		code += CTRL;

	return (code);
}
#endif

/*
 * Terminal specific keymap initialization.
 *
 * Bind all of the assigned graphics in the
 * Amiga alternate character set to self-insert.
 *
 * #ifdef XKEYS, attach the special keys to the appropriate
 * built-in functions.
 *
 * #ifdef DO_MENU, bind the fake KMENU code to amigamenu()
 * to do menu selection as transparently as possible.
 *
 * #ifdef MOUSE, bind the hot mouse keys to the
 * functions. In the case of window and mode line
 * selections, call special functions
 * special functions that select the appropriate
 * object (i.e. character, window) before performing
 * the task.
 *
 * As is the case of all the keymap routines, errors
 * result in panic.
 */

extern	int	togglewindow();		/* Defined by "ttyio.c"		*/

#ifdef	DO_MENU
extern	int	amigamenu();		/* Defined by "ttymenu.c" 	*/
#endif

#ifdef	CHANGE_FONT
extern	int	setfont();		/* Defined by "ttyio.c"		*/
#endif

#ifdef	MOUSE
extern	int	amigamouse();		/* Defined by "ttymouse.c"	*/
extern	int	mreposition();		/* Functions which select the	*/ 
extern	int	mdelfword();		/* window the click was in,	*/
extern	int	mkillline();		/* then call another one	*/
extern	int	mforwdel();		/* Defined in "ttymouse.c"	*/
extern	int	mdelwhite();
extern	int	mkillregion();
extern	int	myank();
extern	int	mforwpage();
extern	int	mbackpage();
extern	int	msplitwind();
extern	int	mdelwind();
extern	int	mgotobob();
extern	int	mgotoeob();
extern	int	menlargewind();
extern	int	mshrinkwind();
#endif

#ifdef	CHANGE_COLOR
	/* functions to mess with the mode line rendition, window colors*/
extern	int	ttmode();		/* Defined by "tty.c"		*/
extern	int	tttext();		/*  ""				*/
extern	int	textforeground();	/*  ""				*/
extern	int	textbackground();	/*  ""				*/
extern	int	modeforeground();	/*  ""				*/
extern	int	modebackground();	/*  ""				*/
#endif

ttykeymapinit()
{
	register SYMBOL	*sp;
	register int	i;

	/* Intuition window manipulation 	*/

#ifndef	MEYN
	keydup((KEY)KMETA|KCTRL|'L',	"redraw-display");
#endif
 	keyadd((KEY)-1,	togglewindow,	"toggle-window-hack");

	/*
	 * Bind all positions that correspond
	 * to characters in the Amiga alternate
	 * character set to "ins-self". These characters may
	 * be used just like any other character.  Of course,
	 * if DO_METAKEY is defined in kbd.c, the alternate character
	 * set will get mapped to META-ed keys...
	 */

	if ((sp=symlookup("self-insert-command")) == NULL)
		panic("ttykeymapinit: can't find self-insert-command");
	for (i=0xA0; i<0xFF; ++i) {
		if (binding[i] != NULL)
			panic("ttykeymapinit: key already bound");
		binding[i] = sp;
	}

#ifdef	DO_MENU
	/* "Menu" key, if compiled in	*/
	keyadd((KEY)KMENU,	amigamenu,	"amiga-menu");
#endif

#ifdef	CHANGE_FONT
	keyadd((KEY)-1,	setfont,	"set-font");
#endif

#ifdef	CHANGE_COLOR
	/* Functions to allow you to change colors	*/
	keyadd((KEY)-1, ttmode,		"set-mode-rendition");
	keyadd((KEY)-1,	tttext,		"set-text-rendition");
	keyadd((KEY)-1,	textforeground,	"set-text-foreground");
	keyadd((KEY)-1,	textbackground,	"set-text-background");
	keyadd((KEY)-1, modeforeground, "set-mode-foreground");
	keyadd((KEY)-1,	modebackground,	"set-mode-background");
#endif

#ifdef	XKEYS
	/* Arrow keys	*/
	keydup((KEY)KUP,	"previous-line");
	keydup((KEY)KDOWN,	"next-line");

	keydup((KEY)KSUP,	"backward-paragraph");
	keydup((KEY)KSDOWN,	"forward-paragraph");	

	keydup((KEY)KRIGHT,	"forward-char");
	keydup((KEY)KLEFT,	"backward-char");

	keydup((KEY)KSRIGHT,	"forward-word");
	keydup((KEY)KSLEFT,	"backward-word");

	/* Function keys 	*/
	keydup((KEY)KHELP,	"describe-key-briefly");

	keydup((KEY)KF1,	"find-file");
	keydup((KEY)KSF1,	"find-file-other-window");

	keydup((KEY)KF2,	"save-buffer");
	keydup((KEY)KSF2,	"write-file");

	keydup((KEY)KF3,	"scroll-up");
	keydup((KEY)KSF3,	"scroll-down");

	keydup((KEY)KF4,	"next-window");
	keydup((KEY)KSF4,	"previous-window");

	keydup((KEY)KF5,	"enlarge-window");
	keydup((KEY)KSF5,	"shrink-window");

	keydup((KEY)KF6,	"fill-paragraph");
	keydup((KEY)KSF6,	"query-replace");

	keydup((KEY)KF7,	"split-window-vertically");
	keydup((KEY)KSF7,	"delete-other-windows");

	keydup((KEY)KF8,	"global-set-key");
	keydup((KEY)KSF8,	"global-unset-key");

	keydup((KEY)KF9,	"start-kbd-macro");
	keydup((KEY)KSF9,	"end-kbd-macro");

	keydup((KEY)KF10,	"call-last-kbd-macro");
	keydup((KEY)KSF10,	"save-buffers-kill-emacs");
#endif

#ifdef	MOUSE
	/* Mouse clicks in a window do editing functions on the	*/
	/* window.						*/

	keyadd(WMOUSE,		amigamouse,	"amiga-mouse");
	keyadd(S(WMOUSE),	mreposition,	"mouse-recenter");
	keyadd(A(WMOUSE),	mdelfword,	"mouse-kill-word");
	keyadd(AS(WMOUSE),	mkillline,	"mouse-kill-line");
	keyadd(C(WMOUSE),	mforwdel,	"mouse-delete-char");
	keyadd(CS(WMOUSE),	mdelwhite,	"mouse-just-one-space");
	keyadd(CA(WMOUSE),	mkillregion,	"mouse-kill-region");
	keyadd(CAS(WMOUSE),	myank,		"mouse-yank");

	/* Mouse clicks in the status line select that window and	*/
	/* then perform a command on that window or buffer.		*/
	/* Use keyadd() because they haven't been bound before		*/

	keyadd(SMOUSE,	   mforwpage,	"mouse-scroll-up");
	keyadd(S(SMOUSE),  mbackpage,	"mouse-scroll-down");
	keyadd(A(SMOUSE),  msplitwind,	"mouse-split-window-vertically");
	keyadd(AS(SMOUSE), mdelwind,	"mouse-delete-window");
	keyadd(C(SMOUSE),  mgotobob,	"mouse-beginning-of-buffer");
	keyadd(CS(SMOUSE), mgotoeob,	"mouse-end-of-buffer");
	keyadd(CA(SMOUSE), menlargewind,"mouse-enlarge-window");
	keyadd(CAS(SMOUSE),mshrinkwind,	"mouse-shrink-window");

	/* mouse clicks in echo line do global things		*/

#ifdef	MEYN
	keydup(EMOUSE,		"save-buffer");
#else
	keydup(EMOUSE,		"switch-to-buffer");
#endif
	keydup(S(EMOUSE),	"kill-buffer");
	keydup(A(EMOUSE),	"describe-key-briefly");
	keydup(AS(EMOUSE),	"describe-bindings");
	keydup(C(EMOUSE),	"suspend-emacs");
	keydup(CS(EMOUSE),	"save-buffers-kill-emacs");
	keydup(CA(EMOUSE),	"list-buffers");
	keydup(CAS(EMOUSE),	"toggle-window-hack");
#endif
}
SHAR_EOF
fi # end of overwriting check
if test -f 'tty/amiga/ttymouse.c'
then
	echo shar: will not over-write existing file "'tty/amiga/ttymouse.c'"
else
cat << \SHAR_EOF > 'tty/amiga/ttymouse.c'
/*
 * Name:	MicroEmacs
 *		Commodore Amiga mouse handling (no longer simple!)
 * Version:	Gnu v30
 * Last edit:	02-Aug-86  ...!ihnp4!seismo!ut-sally!ut-ngp!mic
 */

#include <exec/types.h>
#include <intuition/intuition.h>
#undef	TRUE
#undef	FALSE
#include "def.h"

extern	int	ttmouse();		/* Defined by "ttyio.c"		*/
extern	int	forwline();		/* Defined by "line.c"		*/
extern	int	forwchar();		/* Defined by "basic.c"		*/
extern	int	setmark();		/* Defined by "random.c"	*/

/* stuff for go-to-window-and-do-it functions */
extern	int	reposition();
extern	int	delfword();
extern	int	killline();
extern	int	forwdel();
extern	int	delwhite();
extern	int	killregion();
extern	int	yank();
extern	int	forwpage();
extern	int	backpage();
extern	int	splitwind();
extern	int	delwind();
extern	int	gotobob();
extern	int	gotoeob();
extern	int	enlargewind();
extern	int	shrinkwind();

/*
 * Handle the mouse click that's been passed
 * by ttgetc() and position dot where the
 * user pointed at.  If this is the same position
 * where the user pointed the last time, set the mark,
 * whether or not this is a true double-click.
 * This isn't a true double-click, but it does
 * most of what we want.
 */

static USHORT	oldrow = HUGE, oldcol = HUGE;	/* last mouse click	*/
static USHORT	newrow, newcol;			/* next mouse click	*/

amigamouse(f, n, k)
{
	if (!dottomouse())			/* sets newrow, newcol	*/
		return (FALSE);
	if ((newrow == oldrow) && (newcol == oldcol))
		setmark(FALSE, 0, KRANDOM);	/* double-click		*/
	oldrow = newrow;		    	/* save state		*/
	oldcol = newcol;
	return (TRUE);
}

/*
 * Recenter on selected line
 */
mreposition(f, n, k)
{
	if (!dottomouse())
		return (FALSE);
	return (reposition(f, n, k));
}

/*
 * Delete word after selected char
 */
mdelfword(f, n, k)
{
	if (!dottomouse())
		return (FALSE);
	return (delfword(f, n, k));
}

/*
 * Move to selection, kill line
 */
mkillline(f, n, k)
{
	if (!dottomouse())
		return (FALSE);
	return (killline(f, n, k));
}

/*
 * Move to selection, kill line
 */
mforwdel(f, n, k)
{
	if (!dottomouse())
		return (FALSE);
	return (forwdel(f, n, k));
}

/*
 * Move to selection, kill line
 */
mdelwhite(f, n, k)
{
	if (!dottomouse())
		return (FALSE);
	return (delwhite(f, n, k));
}

/*
 * Move to selection, kill region.
 * This makes it easy to mark a
 * region with a double-click, then
 * hold down some shift keys to
 * delete the region.
 */
mkillregion(f, n, k)
{
	if (!dottomouse())
		return (FALSE);
	return (killregion(f, n, k));
}

/*
 * Move to selection, yank kill buffer
 */
myank(f, n, k)
{
	if (!dottomouse())
		return (FALSE);
	return (yank(f, n, k));
}

/*
 * Select window pointed to by mouse, then scroll down
 */

mforwpage(f, n, k)
{
	if (!dottomouse())
		return (FALSE);
	return (forwpage(f, n, k));
}

/*
 * Select buffer, scroll page down
 */
mbackpage(f, n, k)
{
	if (!dottomouse())
		return (FALSE);
	return (backpage(f, n, k));
}

/*
 * Select the window, split it.
 */
msplitwind(f, n, k)
{
	if (!dottomouse())
		return (FALSE);
	return (splitwind(f, n, k));
}

/*
 * Select the buffer, delete it.
 */
mdelwind(f, n, k)
{
	if (!dottomouse())
		return (FALSE);
	return (delwind(f, n, k));
}

/*
 * Select window, goto beginning of buffer
 */
mgotobob(f, n, k)
{
	if (!dottomouse())
		return (FALSE);
	return (gotobob(f, n, k));
}

/*
 * Select window, go to end of buffer
 */
mgotoeob(f, n, k)
{
	if (!dottomouse())
		return (FALSE);
	return (gotoeob(f, n, k));
}

/*
 * Select window, enlarge it.
 */
menlargewind(f, n, k)
{
	if (!dottomouse())
		return (FALSE);
	return (enlargewind(f, n, k));
}
	
/*
 * Select window, shrink it.
 */
mshrinkwind(f, n, k)
{
	if (!dottomouse())
		return (FALSE);
	return (shrinkwind(f, n, k));
}

/*
 * Utility routine to move dot to where
 * the user clicked.  If in mode line,
 * chooses that buffer as the one
 * to work on.
 */

static dottomouse()
{
	register WINDOW *wp;
	register int	dot;
	register int	c;
	register int	col;
	int		qualifier;

	/* figure out new screen position of dot, throw away mouse evt */
	if (!ttmouse(TRUE, &newrow, &newcol, &qualifier))
		return (FALSE);			/* out of synch!	*/

	/* find out which window was clicked in				*/
	for (wp = wheadp; wp != NULL; wp = wp->w_wndp)
		if ((newrow >= wp->w_toprow) && 
			(newrow <= (wp->w_toprow + wp->w_ntrows)))
			break;

	if (wp == NULL)				/* echo line		*/
		return (ABORT);
	else if (newrow == wp->w_toprow + wp->w_ntrows) {/* mode line */
		curwp = wp;			/* just change buffer	 */
		curbp = wp->w_bufp;
	} else {
		/* move to selected window, move dot to top left	*/
		curwp = wp;
		curbp = wp->w_bufp;
		curwp->w_dotp = wp->w_linep;
		curwp->w_doto = 0;

		/* go forward the correct # of lines 		*/
		forwline(FALSE, newrow - curwp->w_toprow, KRANDOM);
	
		/* go forward the correct # of characters	*/
		/* need to count them out because of tabs	*/
		col = dot = 0;
		while ((col < newcol) && (dot < llength(curwp->w_dotp))) {
			c = lgetc(curwp->w_dotp, dot++);
			if (c == '\t')
				col |= 0x07;
			else if (ISCTRL(c) != FALSE)
				++col;
			++col;
		}
#ifdef		MEYN
		if (col > newcol) dot--;	/* back up to tab/ctrl char */
#endif
		forwchar(FALSE, dot, KRANDOM);
	}
	return (TRUE);
}
SHAR_EOF
fi # end of overwriting check
if test -f 'sys/amiga/Makefile.LATTICE'
then
	echo shar: will not over-write existing file "'sys/amiga/Makefile.LATTICE'"
else
cat << \SHAR_EOF > 'sys/amiga/Makefile.LATTICE'
#
# Makefile for Amiga MicroGNUmacs, using lattice and PD make.
#
#	This Makefile should be executed in the main Emacs directory.
#
# Conditional compilation possibilities:
#
#	V11		-- must be defined for the editor to either run on
#			   or compile on a version 1.1 amigados system
#
#	STARTUP		-- if defined, code for using a startup file
#			   is included.  This is handy for folks who
#			   won't be able to hack the editor to their
#			   taste.
#
#	MENU		-- if defined, Intuition menu selection is
#			   enabled.  This uses a good bit of space,
#			   both on disk and in memory.  If you #define
#			   this, the XOBJ macro must contain $(MENUOBJ).
#
#	BROWSER		-- BROWSER uses the Amiga menu to
#			   present a MENU of files. Selecting a directory
#			   entry (ends with a /) makes the contents if that
#			   directory the next menu (deleting any menus that
#			   used to follow it); selecting a plain file does a
#			   "find-file" on that file name. Really has to be
#			   seen to be understood. XOBJ must contain
#			   $(MENUOBJ) for this to work.
#
#	MOUSE		-- if defined, the Amiga mouse is active.
#			   If you #define this, XOBJ must contain $(MOUSEOBJ)
#
#	XKEYS		-- if defined, the editor understands the Amiga
#			   function keys.
#
#	DO_METAKEY	-- if defined, characters with high bit set (i.e.
#			   most ALT-ed characters in the usa0 keymap)
#			   are translated into internal META keys
#
#	CHANGE_COLOR	-- if defined, adds commands to manipulate
#			   the rendition of the mode line and the
#			   foreground and background color of the
#			   text window and mode line.  The names match
#			   the regular expression
#			   set-{text,mode}-{foreground,background}
#
#	MODE_RENDITION	-- the these values indicate the way to render
#	TEXT_RENDITION	   characters in the text area and mode line.
#			   TEXT_RENDITION is mainly there for completeness.
#			   Possible values are:
#				0 -- plain text
#				1 -- boldface
#				3 -- italic
#				4 -- underscore
#				7 -- reverse-video (default if not defined)
#
#	TEXT_FG		-- specifies which system color (0-7) to use
#	TEXT_BG		   when drawing the text and mode line.  If they
#	MODE_FG		   aren't between 0 and 7, or if a combination
#	MODE_BG		   comes out badly, it's *YOUR* fault.  If
#			   CHANGE_COLOR is defined, you get to change these
#			   values on the fly.  Naturally, making both
#			   FG and BG the same results in an unusable display...
#
#	TOGGLE_ZOOMS	-- the function toggle-menu-hack switches between
#			   a bordered, sizeable window and a borderless
#			   window.  By default, the borderless window
#			   retains the size of the sizeable window.
#			   If TOGGLE_ZOOMS is #defined, however, the
#			   borderless window always takes up the whole
#			   screen.
#
############################################################################
CC =		cc
#DEBUGFLAG =	-g
TTYDIR =	tty/amiga
SYSDIR =	sys/amiga
MENUOBJ =	ttymenu.o menustack.o
MOUSEOBJ =	ttymouse.o

INCS = def.h $(TTYDIR)/ttydef.h $(SYSDIR)/sysdef.h

# The whole enchilada (~60K with Manx small model)
PREFS = -DSTARTUP -DBROWSER -DMENU -DMOUSE -DCHANGE_COLOR -DXKEYS -DDO_METAKEY 
XOBJ  = $(MENUOBJ) $(MOUSEOBJ)

# Burrito style, with just the Browser...
#PREFS = -DSTARTUP  -DBROWSER -DMOUSE -DCHANGE_COLOR -DXKEYS -DDO_METAKEY
#XOBJ  = $(MOUSEOBJ) $(MENUOBJ)

# Burrito style, with just the menu...
#PREFS = -DSTARTUP  -DMENU -DMOUSE -DCHANGE_COLOR -DXKEYS -DDO_METAKEY
#XOBJ  = $(MOUSEOBJ) $(MENUOBJ)

# Mike's favorite version
#PREFS = -DMOUSE -DBROWSER -DMODE_RENDITION=0 -DMODE_FG=2 -DTOGGLE_ZOOMS -DDO_METAKEY -DGOSREC -DMEYN
#XOBJ = $(MOUSEOBJ) $(MENUOBJ)

# Absolutely bare-bones editor (~49K with Manx small model)
#PREFS = -DDO_METAKEY
#XOBJ  =

CFLAGS =	-O -I$(TTYDIR) -I$(SYSDIR) $(DEBUGFLAG) $(PREFS)

EXEFILE =	mg
COM1	= basic.o buffer.o cinfo.o display.o echo.o extend.o file.o kbd.o
COM2	= line.o main.o match.o random.o region.o search.o symbol.o version.o
COM3	= window.o paragraph.o prefix.o word.o
TTYOBJ	= console.o tty.o ttyio.o ttykbd.o
SYSOBJ	= fileio.o sleep.o spawn.o
OBJ	= comlib1.o comlib2.o comlib3.o ttylib.o syslib.o $(XOBJ)

$(EXEFILE) :	$(OBJ)
		$(CC) -o $(EXEFILE) $(OBJ)

comlib1.o :	$(COM1)
		join $(COM1) as comlib1.o

comlib2.o :	$(COM2)
		join $(COM2) as comlib2.o

comlib3.o :	$(COM3)
		join $(COM3) as comlib3.o

ttylib.o :	$(TTYOBJ)
		join $(TTYOBJ) as ttylib.o

syslib.o :	$(SYSOBJ)
		join $(SYSOBJ) as syslib.o

basic.o :	basic.c $(INCS)
		$(CC) -c $(CFLAGS) basic.c

buffer.o :	buffer.c $(INCS)
		$(CC) -c $(CFLAGS) buffer.c

cinfo.o :	cinfo.c $(INCS)
		$(CC) -c $(CFLAGS) cinfo.c

display.o :	display.c $(INCS)
		$(CC) -c $(CFLAGS) display.c

echo.o :	echo.c $(INCS)
		$(CC) -c $(CFLAGS) echo.c

extend.o :	extend.c $(INCS)
		$(CC) -c $(CFLAGS) extend.c

file.o :	file.c $(INCS)
		$(CC) -c $(CFLAGS) file.c

kbd.o :		kbd.c $(INCS)
		$(CC) -c $(CFLAGS) kbd.c

line.o :	line.c $(INCS)
		$(CC) -c $(CFLAGS) line.c

match.o :	match.c $(INCS)
		$(CC) -c $(CFLAGS) match.c

prefix.o :	prefix.c $(INCS)
		$(CC) -c $(CFLAGS) prefix.c

paragraph.o :	paragraph.c $(INCS)
		$(CC) -c $(CFLAGS) paragraph.c

main.o :	main.c $(INCS)
		$(CC) -c $(CFLAGS) main.c

random.o :	random.c $(INCS)
		$(CC) -c $(CFLAGS) random.c

region.o :	region.c $(INCS)
		$(CC) -c $(CFLAGS) region.c

search.o :	search.c $(INCS)
		$(CC) -c $(CFLAGS) search.c

symbol.o :	symbol.c $(INCS)
		$(CC) -c $(CFLAGS) symbol.c

version.o :	version.c $(INCS)
		$(CC) -c $(CFLAGS) version.c

window.o :	window.c $(INCS)
		$(CC) -c $(CFLAGS) window.c

word.o :	word.c $(INCS)
		$(CC) -c $(CFLAGS) word.c

console.o :	$(TTYDIR)/console.c $(INCS)
		$(CC) -c $(CFLAGS) $(TTYDIR)/console.c

menustack.o :	$(TTYDIR)/menustack.c $(INCS)
		$(CC) -c $(CFLAGS) $(TTYDIR)/menustack.c

tty.o :		$(TTYDIR)/tty.c $(INCS)
		$(CC) -c $(CFLAGS) $(TTYDIR)/tty.c

ttyio.o :	$(TTYDIR)/ttyio.c $(INCS)
		$(CC) -c $(CFLAGS) $(TTYDIR)/ttyio.c

ttykbd.o :	$(TTYDIR)/ttykbd.c $(INCS)
		$(CC) -c $(CFLAGS) $(TTYDIR)/ttykbd.c


ttymouse.o :	$(TTYDIR)/ttymouse.c $(INCS)
		$(CC) -c $(CFLAGS) $(TTYDIR)/ttymouse.c

ttymenu.o :	$(TTYDIR)/ttymenu.c $(INCS)
		$(CC) -c $(CFLAGS) $(TTYDIR)/ttymenu.c
abort.o :	$(SYSDIR)/abort.c $(INCS)
		$(CC) -c $(CFLAGS) $(SYSDIR)/abort.c

fileio.o :	$(SYSDIR)/fileio.c $(INCS)
		$(CC) -c $(CFLAGS) $(SYSDIR)/fileio.c

sleep.o :	$(SYSDIR)/sleep.c $(INCS)
		$(CC) -c $(CFLAGS) $(SYSDIR)/sleep.c

spawn.o :	$(SYSDIR)/spawn.c $(INCS)
		$(CC) -c $(CFLAGS) $(SYSDIR)/spawn.c
SHAR_EOF
fi # end of overwriting check
if test -f 'sys/amiga/Makefile.MANX'
then
	echo shar: will not over-write existing file "'sys/amiga/Makefile.MANX'"
else
cat << \SHAR_EOF > 'sys/amiga/Makefile.MANX'
#
# Makefile for Amiga MicroGNUmacs, using Manx small model.
#
#	This Makefile should be executed in the main Emacs directory.
#
# System-dependent conditional compilation possibilities:
#
#	V11		-- must be defined for the editor to either run on
#			   or compile on a version 1.1 AmigaDOS system.
#			   It mainly wards against bugs in the 1.1 ROM
#			   Kernel.
#
#	STARTUP		-- if defined, code for using a startup file
#			   is included.  This is handy for folks who
#			   won't be able to hack the editor to their
#			   taste.
#
#	MENU		-- if defined, Intuition menu selection is
#			   enabled.  If you #define this, the XOBJ macro
#			   must contain $(MENUOBJ).
#
#	BROWSER		-- BROWSER uses the Amiga menu to present a MENU of
#			   files. Selecting a directory entry (ends with a /)
#			   makes the contents if that directory the next menu
#			   (deleting any menus that used to follow it);
#			   selecting a plain file does a "find-file" on that
#			   file name. Really has to be seen to be understood.
#			   XOBJ must contain $(MENUOBJ) for this to link.
#
#	MOUSE		-- if defined, the Amiga mouse is active.
#			   If you #define this, XOBJ must contain $(MOUSEOBJ)
#
#	TOGGLE_ZOOMS	-- the function toggle-menu-hack switches between
#			   a bordered, sizeable window and a borderless
#			   window.  By default, the borderless window
#			   retains the size of the sizeable window.
#			   If TOGGLE_ZOOMS is #defined, however, the
#			   borderless window always takes up the whole
#			   screen.
#
#	XKEYS		-- if defined, the editor understands the Amiga
#			   function keys.
#
#	DO_METAKEY	-- if defined, characters with high bit set (i.e.
#			   most ALT-ed characters in the usa0 keymap)
#			   are translated into internal META keys
#
#	CHANGE_COLOR	-- if defined, adds commands to manipulate
#			   the rendition of the mode line and the
#			   foreground and background color of the
#			   text window and mode line.  The names match
#			   the regular expression
#			   set-{text,mode}-{foreground,background}
#	CHANGE_FONT	-- if defined, adds "set-font", which prompts
#			   for a font name and size, then tries to reopen
#			   the Emacs window using the new font.
#
#
#	MODE_RENDITION	-- the these values indicate the way to render
#	TEXT_RENDITION	   characters in the text area and mode line.
#			   TEXT_RENDITION is mainly there for completeness.
#			   Possible values are:
#				0 -- plain text
#				1 -- boldface
#				3 -- italic
#				4 -- underscore
#				7 -- reverse-video (default if not defined)
#
#	TEXT_FG		-- specifies which system color (0-7) to use
#	TEXT_BG		   when drawing the text and mode line.  If they
#	MODE_FG		   aren't between 0 and 7, or if a combination
#	MODE_BG		   comes out badly, it's *YOUR* fault.  If
#			   CHANGE_COLOR is defined, you get to change these
#			   values on the fly.  Naturally, making both
#			   FG and BG the same results in an unusable display...
#
############################################################################
SYS	= amiga
S	= sys/amiga
TTY	= amiga
T	= tty/amiga
LIBS	= -lc

#
# PREFS contains the defines used to select compile-time options.
# XOBJ is used to denote any extra object files needed for these
# options.  MENUOBJ MOUSEOBJ denote the extra object files needed
# for the menu, mouse and Browser.

MOUSEOBJ = ttymouse.o
MENUOBJ  = ttymenu.o menustack.o

# The big burrito, with the Browser *and* the editing MENU.  Tough
# on space, but boy is it neat...
PREFS = -DSTARTUP  -DBROWSER -DMENU -DMOUSE -DCHANGE_FONT \
	-DCHANGE_COLOR -DXKEYS -DDO_METAKEY
XOBJ  = $(MOUSEOBJ) $(MENUOBJ)

# Burrito style, with just the Browser...
#PREFS = -DSTARTUP  -DBROWSER -DMOUSE -DCHANGE_COLOR -DXKEYS -DDO_METAKEY
#XOBJ  = $(MOUSEOBJ) $(MENUOBJ)

# Burrito style, with just the menu...
#PREFS = -DSTARTUP  -DMENU -DMOUSE -DCHANGE_COLOR -DXKEYS -DDO_METAKEY
#XOBJ  = $(MOUSEOBJ) $(MENUOBJ)

# Mike's favorite version
#PREFS = -DMOUSE -DBROWSER -DMODE_RENDITION=0 -DMODE_FG=2 -DDO_METAKEY -DGOSREC -DV11 -DMEYN
#XOBJ = $(MOUSEOBJ) $(MENUOBJ)

# Mic's favorite version
#PREFS = -DSTARTUP -DBROWSER -DMENU -DMOUSE -DXKEYS -DDO_METAKEY
#XOBJ  = $(MOUSEOBJ) $(MENUOBJ)

# Absolutely bare-bones, default editor (~49K with Manx small model)
#PREFS = -DDO_METAKEY
#XOBJ  =
	
CFLAGS	= -I$(T) -I$(S) $(PREFS) -DMANX

OBJ   =	basic.o buffer.o cinfo.o display.o echo.o extend.o file.o kbd.o \
	line.o main.o match.o random.o region.o search.o symbol.o version.o \
	window.o paragraph.o prefix.o word.o \
	fileio.o spawn.o sleep.o\
	ttyio.o tty.o ttykbd.o console.o $(XOBJ)
#
# OSRCS = system-dependent modules, SRCS = denotes system-independent ones
#
OSRCS = $(S)/fileio.c $(S)/spawn.c $(S)/sleep.c \
	$(T)/ttyio.c $(T)/tty.c $(T)/ttykbd.c $(T)/console.c \
	$(T)/ttymenu.c $(T)/menustack.c $(T)/ttymouse.c

SRCS  =	basic.c buffer.c cinfo.c display.c echo.c extend.c file.c kbd.c \
	line.c main.c match.c random.c region.c search.c symbol.c version.c \
	window.c word.c paragraph.c prefix.c
#
# Include files
#
OINCS =	$(T)/ttydef.h $(S)/sysdef.h
INCS  =	def.h

#
# The editor
#
mg:		$(OBJ)
		copy df0:lib/c.lib ram:
		set CLIB=ram:
		ln -o mg $(OBJ) $(LIBS)
		delete ram:c.lib

$(OBJ):		$(INCS) $(OINCS)

fileio.o:	$(S)/fileio.c
		cc $(CFLAGS) -o fileio.o $(S)/fileio.c

spawn.o:	$(S)/spawn.c
		cc $(CFLAGS) -o spawn.o $(S)/spawn.c

sleep.o:	$(S)/sleep.c
		cc $(CFLAGS) -o sleep.o $(S)/sleep.c

tty.o:		$(T)/tty.c
		cc $(CFLAGS) -o tty.o $(T)/tty.c

ttyio.o:	$(T)/ttyio.c
		cc $(CFLAGS) -o ttyio.o $(T)/ttyio.c

ttykbd.o:	$(T)/ttykbd.c
		cc $(CFLAGS) -o ttykbd.o $(T)/ttykbd.c

ttymenu.o:	$(T)/ttymenu.c
		cc $(CFLAGS) -o ttymenu.o $(T)/ttymenu.c

ttymouse.o:	$(T)/ttymouse.c
		cc $(CFLAGS) -o ttymouse.o $(T)/ttymouse.c

menustack.o:	$(T)/menustack.c
		cc $(CFLAGS) -o menustack.o $(T)/menustack.c

console.o:	$(T)/console.c
		cc $(CFLAGS) -o console.o $(T)/console.c
SHAR_EOF
fi # end of overwriting check
if test -f 'sys/amiga/amiga.doc'
then
	echo shar: will not over-write existing file "'sys/amiga/amiga.doc'"
else
cat << \SHAR_EOF > 'sys/amiga/amiga.doc'

                        Amiga MicroGNUmacs Notes
                        ------------------------

   This file purports to document the Amiga-specific features of
MicroGNUmacs. Except where otherwise noted, "MicroEmacs", "Emacs", "MG",
"MicroGNU", and "MicroGNUmacs" all refer to the Amiga version of the
GNU-compatible MicroEmacs text editor. MicroEmacs was created by Dave
Conroy. This version has been GNUified by Mike Meyer, and the
Intuition terminal driver enhanced and (hopefully) improved by Mic
Kaczmarczik.

   It is assumed that you already know about the point and the mark,
buffers, windows, extended commands, and the various areas on the
screen that all versions of MicroEmacs maintain. If you don't, see the
MicroEmacs documentation (what there is of it) for more information.

                              OPTIONS
                              -------

   (This section is for people who have their own C compiler. If you
don't have a C compiler, you will hopefully have a version that has
*everything* compiled into it...)

   There are a bewildering variety of extra goodies available as
compile-time options when you construct an Amiga MicroEmacs. If you
select none of them, you save on disk space, but lose out on some
features and versatility.

   The Makefile provides documentation on these options and what to do
to make them work, but here is a quick overview:

   STARTUP -- You can configure MicroEmacs so that it will look for a
startup file in either the current directory or the AmigaDOS s:
(startup) directory. An example startup file is included in the
distribution, and also see the STARTUP section below.

   MENU -- If this option is used, MicroEmacs puts an Intuition menu
bar with major editing commands at the top of the screen, just like a
"real" Amiga program. (See the section on the MENU for more info).

   BROWSER -- This has got to be seen to be appreciated. The Browser
program turns the menu bar into a way to select files on a disk. First
you select a disk, then a directory on the disk, then a file or
subdirectory on the disk, and so on, all in the menu.

   MOUSE -- This option turns on the Amiga Hot Mouse (and it's all due
to Mike Meyer!). You can click on a character and move point to that
spot, and that's just the beginning. (See the MOUSE section for more.)

   XKEYS -- This option turns on support for all the extra Amiga
function keys. This enables the HELP key, which runs the function
"describe-key-briefly". Arrow keys work -- shift-arrow keys apply to
words and paragraphs. (See the KEYBOARD section.)

   DO_METAKEY -- Characters with the high bit set (i.e. codes > 0x80)
are transformed into 'META' characters. If you're using 1.2, you will
need to issue the command setmap usa0 to get the same console keymap
as the one used by 1.1. If you don't have the usa0 keymap, this option
may or may not be too helpful. If you *do* have DO_METAKEY set, you
can still use the CTRL-Q command to insert ALT-ed characters.

   CHANGE_FONT -- This allows you to set the font used by the Amiga
console device driver when it draws characters in the Emacs window.
For instance, this lets you use a slightly taller font for editing
when using interlace mode under 1.2.  MG cannot handle proportionally
spaced fonts, but will allow you to use them (with rather confusing
results) if you really want to.

   MODE_RENDITION, {TEXT,MODE}_{FG,BG} -- These are #defines that
determine the default rendition of the mode line and the foreground
and background colors of the text. See the COLOR section for more
info.

   CHANGE_COLOR -- If you want to be able to mess around with the
foreground and background colors of the text window, this option
allows you to do that. You can also specify the way the status line is
rendered (plain, boldface, italics, or reverse video).

                              THE MOUSE
                              ---------

(This section originated from Mike Meyer, the inventor of the Hot
Mouse. It has been edited to be consistent with the current state of
the Hot Mouse.)

   The Amiga Mouse in hot mode can invoke no less than 24 different
functions!!!  They are treated as keys by the rest of MicroEmacs, even
though you click the mouse and hold down qualifier keys to get them.

   Mouse keys come in three groups of eight, the groups being Mouse
keys, Mode-Mouse keys, and Echo-Mouse keys. Inside each group, which
of the eight keys you get is determined by the combination of Shift,
CTRL and ALT keys you are holding down when the mouse button is
pressed. So yes, there really is a C-M-Shift-Mode-Mouse button*.
Note that the Meta (M-) prefix *MUST* be the ALT key. Prefixing it
with ESC will *not* work.  Sorry, life's a beach.

[* Technical note *]

   Sadly, in order to keep the basic MicroEmacs editor code the same
for all systems (it runs on everything from DEC-20's to CP/M
machines), the Mouse keys do not have names like C-M-Shift-Mode-Mouse.
They end up having names like ESC C-a when you use the
describe-key-briefly command. This may be changed in a later version.

[* Practical note *]
   Because of the above restriction (I'm working on it, I'm working on
it!) you sometimes get burned when you absent-mindedly click the mouse
during a dialogue (e.g. I-search or switch-buffer). I have not found a
good way to avoid this problem and preserve the main editor, so I'm
leaving this unresolved until the next round of improvements.

   Mouse keys are generally bound to functions that affect the text in
the selected buffer. If the Intuition mouse pointer is located inside
an Emacs text window (i.e. an area where text is being edited), then a
Mouse key is sent to the editor when you click the mouse. The buffer
associated wth the window the pointer is in is made current, the point
is set as close as possible to the pointer (the character under the
pointer, if possible), then the command bound to that mouse button is
executed.

   If the mouse pointer is in the mode line - the line that is in a
different typeface (usually backlit, maybe black instead of white) --
when the mouse button is clicked, a Mode-Mouse key is sent to the
editor. The buffer that the selected status line is associated with is
made the current buffer, the point is set to the value of point for
that window, then whatever command is bound to that button is
executed. Most of the Mode-Mouse keys invoke functions that act on the
entire window or buffer.

   Clicking the mouse button when the mouse pointer is in the echo
line - the line at the bottom of the screen where prompts and message
appear - results in an Echo-Mouse key. Whatever command is bound to
that button will be executed.  Since the echo line is not part of
a buffer or a window, all the functions bound to Echo-Mouse keys
affect the state of the editor as a whole.
   
   The default bindings for the hot mouse (as distributed) are:

 Qualifiers  |			Area clicked
             |
C  A  Shift  |	Text window		Mode line	Echo line
-------------+---------------------------------------------------------
	     |	dot to mouse		forward page	switch to other buffer 
      X	     |	recenter		backward page	kill buffer
   X	     |	delete word		split window	describe key
   X  X	     |	kill line		delete window	describe bindings
X	     |	delete char		goto bob	suspend emacs
X     X	     |	delete whitespace	goto eob	quit
X  X	     |	kill region		enlarge window	list buffers
X  X  X	     |	yank			shrink window	toggle Intuition window

   To help keep straight what the various keys do, notice that the
Status and Echo groups come in pairs; the shifted version of a key is
in some sense the opposite of the unshifted version. There is no
opposite for display buffers, so that key is bound to
toggle-window-hack, which toggles Emacs' Intuition window between
bordered and borderless.

   Like any Emacs key, you are perfectly free to rebind the 24 mouse
buttons to do whatever you wish, although currently you can't rebind
them in a startup file.

			   THE KEYBOARD
			   ------------

   There is a shortcut for many of the Meta commands (usually
indicated by the ESC character): hold down the ALT key at the same
time you type what usually comes after the ESC.

   (Historically, this is why keys that are typed with ESC in front of
them are called META keys; on the terminals at MIT where Emacs was
originally written, there was a META key on the keyboard that did what
the ALT key does. However, not many terminals outside of MIT have the
META key at all, so the ESC key was nominated as a way to tell the
system that the next character should be converted into a META key
before it is interpreted.)

   If you are running under the 1.2 Workbench, you may need to issue
the command "setmap usa0" to make things work right (the default
console keymap changed between 1.1 and 1.2).

   MicroEmacs also recognizes all the standard Amiga function keys.
For quick help on a key, type the HELP key and then the key you want
help on. The following commands are bound to the Amiga function keys:

	Key			Function
	----------------------------------
	Help			describe-key-briefly

	Left			backward-char
	Shift-Left		backward-word
	Right			forward-char
	Shift-Right		forward-word

	Up			previous-line
	Shift-Up		backward-paragraph

	Down			next-line
	Shift-Down		forward-paragraph

	F1			find-file
	Shift-F1		find-file-other-window
	F2			save-buffer
	Shift-F2		write-file
	F3			scroll-up (page down)
	Shift-F3		scroll-down (page up)
	F4			next-window
	Shift-F4		previous-window
	F5			enlarge-window
	Shift-F5		shrink-window
	F6			fill-paragraph
	Shift-F6		query-replace
	F7			split-window-vertically
	Shift-F7		delete-other-windows
	F8			global-set-key
	Shift-F8		global-unset-key
	F9			start-kbd-macro
	Shift-F9		end-kbd-macro
	F10			call-last-kbd-macro
	Shift-F10		save-buffers-kill-emacs

			     THE MENU
			     --------
   If the menu option is compiled into the program, you can also use
the Intuition menu, just like a "real" Amiga program. The menu names
are relatively self-explanitory, as are the names inside each menu. If
you want to learn what the command key is for a menu function, type
"<ESC>-x describe-bindings<RET>" and page through till you find a
function with a similar name. A future release of the Amiga driver
will probably allow you to directly find out what command keys are
bound to a particular function, but you'll just have to bear with us
for a while.

			    THE BROWSER
			    -----------

   The Browser is the next best (or even better, for some purposes)
thing to a file requester. In essence, it puts the directory tree up
in the menu bar, where you can visit files simply by selecting their
names from the menu bar. Try it, you'll like it.  If the MENU option
is also compiled in, the editing menus are all submenus of the first,
"Edit" menu, and the Browser uses the rest of the menu bar.

			   WINDOW OPTIONS 
			   --------------

   As a service to those of us who want a full-size, 80-column editing
window, Amiga MicroEmacs allows you to make its window borderless. If
you like, you can take over the full Workbench screen (48 rows, 80
columns in interlace mode under 1.2). Borderless windows can be
"visually confusing", to say the least, so it's probably best to
either to 1) take over the whole screen or 2) put the Emacs window at
the bottom of the screen.

   When Amiga MicroEmacs starts up, its initial window is borderless,
and 640x200 pixels in dimension. To change to a resizeable window,
issue the command "M-x toggle-window-hack" or select the "Toggle
Window" item from the menu (if it is compiled into the program).
MicroEmacs will create a new, resizeable, bordered window, which you
can then set to whatever size you wish using the sizing gadget in the
bottom left corner of the window.

   To go back to a borderless window, issue the "Toggle Window"
command again. MicroEmacs will remember the current size of the
resizeable window, and create a borderless window with the same
dimensions and position. Since under Workbench 1.2 you can use a
640x400 window, this lets you take up the *entire screen* -- 48 rows
by 80 columns!


		       CHANGING THE WINDOW'S FONT
		       --------------------------

   There may be times when you'd like to use another font on the screen,
either to make the text easier to read, or for some special effect, like
editing something on a TV projection system.  MG lets you change the
font that is used to draw characters in the window, using the command
M-x set-font.

   You can use the universal argument to set the desired text font size,
for example saying C-u 12 M-x set-font, then typing "opal" when it
prompts you for the name of the font.  If you give an argument that is
<= 0, MG resets the window's font to the system default (set by
Preferences).  If you don't give an argument, MG prompts you for the
desired font size.

   Changing the window's font to one that is designed to be
proportionally spaced does not work very well, because Emacs expects the
all characters on the screen to be the same width, which is of course
not the case with proportional fonts.  MG lets you use proportional
fonts, but it asks you to make sure first. 


			    TEXT RENDITION
			    --------------

   If you really want to, you can change the "soft style" the console
device uses to draw characters in the text area and the mode line.
The possible values for these styles are:

	0	plain
	1	boldface
	3	italic
	4	underline
	7	inverse

   About the only useful values are the ones for plain, boldface or
italics. The default value for text is 0 (plain, of course), while the
default for the mode line is 7 (inverse video). These can be changed
by the appropriate #definitions of MODE_RENDITION and TEXT_RENDITION.

   The commands to change the rendition values are:

	set-text-rendition
		Set text area rendition
	set-mode-rendition
		Set mode line rendition (this is by far the more useful)

				COLOR
				-----

   You can set the colors the console device uses to draw the text you
are editing. (This does not mean that you can specify *any* color;
your choices are limited to the colors being used by Intuition to
maintain the Workbench screen.) The commands that control this
behavior are:

	set-text-foreground
		Sets the color used to draw the characters you
		see in the text area (distinct from the mode
		line area for each window).  Accepts a number from
		0 to 7.  The value initially used is 1.  You can
		get a reverse video screen by selecting 0 for this
		value and 1 for the background color

	set-text-background
		Sets the color used the draw the background behind
		characters in the text area.  Accepts the same values
		as set-text-foreground-color.  The initial value
		is 0.

	set-mode-foreground
		Sets the foreground color used by the mode line.  If you
		set this to 0 and the background color to 1, you can get
		a reverse video mode line even when you select italics for
		the mode line rendition (see RENDITION)

	set-mode-background
		Sets the background color for the mode line.  You should
		get the idea by now.
		

			   THE STARTUP FILE
			   ----------------

   If the STARTUP option has been compiled into your editor, you can
use a file of startup commands that rebind (most of the) keys and
otherwise set up the editor as you see fit.

   The startup file must have the name ".mg", and can either be
located in the current directory, or the "s:" system startup
directory. If the file is there, MicroEmacs opens the file and
attempts to interpret the commands therein.

   The basic idea is that you are issuing M-X commands; the first line
in the example startup file below would be interpreted as "M-x
bsmap-mode". Spaces are necessary to separate the parts of the
command, but the quotation marks are there mainly for effect. If you
happen to use GNU Emacs on a larger system, the startup file routines
can also read your ".emacs" file, as long as the functions you call in
the ".emacs" file are available in MicroGNUEmacs.

The escape conventions for startup files are:

	\^	next character is a control character
	\e	next character is an escape (meta) character
	\n	newline
	\t	tab
	\r	carriage return
	\\	backslash character

	A '\' followed by anything else means "quote this character
	as-is".

   Here, then, is the example startup file:

---------------------------------CUT HERE---------------------------------
bsmap-mode
auto-fill-mode
global-set-key "\^l" redraw-display
global-set-key "\e\^h" forward-kill-word
global-set-key "\^h" delete-char
global-set-key "\^x\^v" find-file
global-set-key "\eg" goto-line
set-mode-rendition 3
set-mode-foreground 0
set-mode-background 1
---------------------------------CUT HERE-------------------------------------

				FUNCTION LIST
				-------------

   For completeness, here is a list of all Amiga MicroEmacs functions
that are specific to the Amiga. See the file "functions" for the others.

amiga-menu
	The entry point for using Emacs's Intuition menu.  This function
	figures out which menu selection was used, then calls the
	appropriate function by name (not hard-coded key value)
amiga-mouse
	Set dot to where the mouse is pointing.  Two clicks in the same
	spot set the mark too.
mouse-*
	Functions that first either 1) move point to where the mouse
	points to or 2) select the buffer associated with the mode line
	the mouse clicked in, then call the function indicated by the
	rest of the name.  These functions are all "bound" to mouse
	clicks, because the input machinery converts them into internal
	Emacs "keys".
set-font
	Set the font used to draw characters inside the Emacs window.
	A positive argument is used for the size of the font, while
	a nonpositive argument requests that the font be set to the
	system default font.  Menu items are not affected by this command.
set-mode-rendition
set-text-rendition
	Set the way your text (or the mode line) is rendered.  Choose
	from 0 (plain), 1 (bold), 3 (italic), 4 (underline), or
	7 (reverse video). 0, 1, and 3 are about the only really useful
	ones for text; 7 is the default for the mode line.
set-text-foreground
set-text-background
set-mode-foreground
set-mode-background
	Set the system color used to draw the characters in the text area
	and mode line.  Accepts a value between 0 and 7; the default for
	the background is 0, the default for the text is 1.
toggle-window-hack
	Switch your window between resizable and borderless. Lets you
	take over the whole screen (80 columns! 48 lines in interlace!)
SHAR_EOF
fi # end of overwriting check
if test -f 'sys/amiga/fileio.c'
then
	echo shar: will not over-write existing file "'sys/amiga/fileio.c'"
else
cat << \SHAR_EOF > 'sys/amiga/fileio.c'
/*
 * Name:	MicroEMACS
 * Version:	Gnu v30
 *		Commodore Amiga file I/O.
 * Last edit:	30-Sep-86 ...ihnp4!seismo!ut-sally!ut-ngp!mic
 * Created:	23-Jul-86 ...ihnp4!seismo!ut-sally!ut-ngp!mic
 *		(from sys/bsd/fileio.c)
 *
 * Read and write ASCII files. All
 * of the low level file I/O knowledge is here.
 * Pretty much vanilla standard I/O.
 */
#include	"def.h"
/* With Uttice, make sure you use -Idf0:include/lattice/ to	*/
/* put the Lattice files in the right spot.			*/
#include	<fcntl.h>

static	FILE	*ffp;

/*
 * Open a file for reading.
 */
ffropen(fn)
char	*fn;
{
	if ((ffp=fopen(fn, "r")) == NULL)
		return (FIOFNF);
	return (FIOSUC);
}

/*
 * Open a file for writing.
 * Return TRUE if all is well, and
 * FALSE on error (cannot create).
 */
ffwopen(fn)
char	*fn;
{
	if ((ffp=fopen(fn, "w")) == NULL) {
		ewprintf("Cannot open file for writing");
		return (FIOERR);
	}
	return (FIOSUC);
}

/*
 * Close a file.
 * Should look at the status.
 */
ffclose()
{
	fclose(ffp);
	return (FIOSUC);
}

/*
 * Write a line to the already
 * opened file. The "buf" points to the
 * buffer, and the "nbuf" is its length, less
 * the free newline. Return the status.
 * Check only at the newline.
 */
ffputline(buf, nbuf)
register char	buf[];
{
	register int	i;

	for (i=0; i<nbuf; ++i)
		putc(buf[i]&0xFF, ffp);
	putc('\n', ffp);
	if (ferror(ffp) != FALSE) {
		ewprintf("Write I/O error");
		return (FIOERR);
	}
	return (FIOSUC);
}

/*
 * Read a line from a file, and store the bytes
 * in the supplied buffer. Stop on end of file or end of
 * line. Don't get upset by files that don't have an end of
 * line on the last line; this seem to be common on CP/M-86 and
 * MS-DOS (the suspected culprit is VAX/VMS kermit, but this
 * has not been confirmed. If this is sufficiently researched
 * it may be possible to pull this kludge). Delete any CR
 * followed by an LF.
 */
ffgetline(buf, nbuf)
register char	buf[];
{
	register int	c;
	register int	i;

	i = 0;
	for (;;) {
		c = getc(ffp);
		if (c == '\r') {		/* Delete any non-stray	*/
			c = getc(ffp);		/* carriage returns.	*/
			if (c != '\n') {
				if (i >= nbuf-1) {
					ewprintf("File has long line");
					return (FIOERR);
				}
				buf[i++] = '\r';
			}
		}
		if (c==EOF || c=='\n')		/* End of line.		*/
			break;
		if (i >= nbuf-1) {
			ewprintf("File has long line");
			return (FIOERR);
		}
		buf[i++] = c;
	}
	if (c == EOF) {				/* End of file.		*/
		if (ferror(ffp) != FALSE) {
			ewprintf("File read error");
			return (FIOERR);
		}
		if (i == 0)			/* Don't get upset if	*/
			return (FIOEOF);	/* no newline at EOF.	*/
	}
	buf[i] = 0;
	return (FIOSUC);
}

#ifdef	BACKUP
/*
 * Make a file name for a backup copy.
 */
fbackupfile(fname)
char	*fname;
{
	strcat(fname,"~");
	return (TRUE);
}
#endif	BACKUP

#ifdef	STARTUP
/*
 * Return name of user's startup file.  On Amiga, make it
 * s:.mg
 */

static char startname[] = ".mg";
static char altstartname[] = "s:.mg";

char *startupfile()
{
	FILE *f, *fopen();
	if (f = fopen(startname,"r")) {		/* first try	*/
		fclose(f);
		return(startname);
	}
	if (f = fopen(altstartname,"r")) {	/* second try	*/
		fclose(f);
		return (altstartname);
	}
	return (NULL);
}
#endif	STARTUP

/*
 * The string "fn" is a file name.
 * Perform any required case adjustments.
 * On the Amiga file names are dual case,
 * so we leave everything alone.
 */
adjustcase(fn)
register char	*fn;
{
	return (TRUE);
}
SHAR_EOF
fi # end of overwriting check
if test -f 'sys/amiga/sleep.c'
then
	echo shar: will not over-write existing file "'sys/amiga/sleep.c'"
else
cat << \SHAR_EOF > 'sys/amiga/sleep.c'
/*
 * Name:	MicroEmacs
 *		AmigaDOS sleep function
 * Version:	31
 * Last Edit:	18-Apr-86
 * Created:	18-Apr-86 ...!ihnp4!seismo!ut-sally!ut-ngp!mic
 */

/* There are really 60 ticks/second, but I don't want to wait that 	*/
/* long when matching parentheses... */
#define	TICKS	45
extern	long Delay();

sleep(n)
int n;
{
	if (n > 0)
		Delay((long) n * TICKS);
}
SHAR_EOF
fi # end of overwriting check
if test -f 'sys/amiga/spawn.c'
then
	echo shar: will not over-write existing file "'sys/amiga/spawn.c'"
else
cat << \SHAR_EOF > 'sys/amiga/spawn.c'
/*
 * Name:	MicroEMACS
 *		Spawn an AmigaDOS subprocess
 * Version:	Gnu30
 * Last edit:	17-Aug-1986
 * By:		...!ihnp4!seismo!ut-sally!ut-ngp!mic
 */

#include <libraries/dos.h>
#include <libraries/dosextens.h>
#undef TRUE
#undef FALSE
#include "def.h"		/* AFTER system files to avoid redef's */

/*
 * Create a subjob with a copy of the command intrepreter in it.
 * This is really a way to get a new copy of the CLI, because
 * we don't wait around for the new process to quit.  Note the use
 * of a file handle to nil: to avoid the "endcli" message going out
 * to Emacs's standard output.
 */

spawncli(f, n, k)
{
	struct FileHandle *nil, *Open();
	
	ewprintf("[Starting new CLI]");
	nil = Open("NIL:", MODE_NEWFILE);
	if (nil == (struct FileHandle *) 0) { /* highly unlikely */
		ewprintf("Can't create nil file handle");
		return (FALSE);
	}
	Execute("NEWCLI \"CON:0/0/640/200/MicroEmacs Subprocess\"",nil,nil);
	Close(nil);
	return (TRUE);
}


SHAR_EOF
fi # end of overwriting check
if test -f 'sys/amiga/sysdef.h'
then
	echo shar: will not over-write existing file "'sys/amiga/sysdef.h'"
else
cat << \SHAR_EOF > 'sys/amiga/sysdef.h'
/*
 * Name:	MicroEMACS
 *		Commodore Amiga system header file.
 * Version:	Gnu v30
 */

#ifdef MANX
#define	PCC	0			/* "[]" works.			*/
#else
#define	PCC	1			/* "[]" does not work.		*/
#endif

#define	VARARGS
#define	KBLOCK	4096			/* Kill grow.			*/
#define	GOOD	0			/* Good exit status.		*/

/*
 * Macros used by the buffer name making code.
 * Start at the end of the file name, scan to the left
 * until BDC1 (or BDC2, if defined) is reached. The buffer
 * name starts just to the right of that location, and
 * stops at end of string (or at the next BDC3 character,
 * if defined). BDC2 and BDC3 are mainly for VMS.
 */
#define	BDC1	':'			/* Buffer names.		*/
#define	BDC2	'/'

/*
 * Typedefs for internal key type and how big a region can be.
 */

typedef	short	KEY;	/* 16-bit ints		*/
typedef	long	RSIZE;	/* size of a region	*/

#define	bcopy(src,dest,len) movmem(src,dest,len)
SHAR_EOF
fi # end of overwriting check
if test -f 'sys/amiga/varargs.h'
then
	echo shar: will not over-write existing file "'sys/amiga/varargs.h'"
else
cat << \SHAR_EOF > 'sys/amiga/varargs.h'
/*
 * Varargs, for use on AmigaDOS with the Lattice C compiler,
 *	or (maybe?) the Manx compiler with 32-bit ints.
 *	Blatantly lifted from 4.2BSD.
 */

typedef char		*va_list;
#define va_dcl		int va_alist;
#define va_start(pv)	pv = (char *) &va_alist
#define va_end(pv)	/* Naught to do... */
#define va_arg(pv, t)	((t *) (pv += sizeof(t)))[-1]
SHAR_EOF
fi # end of overwriting check
#	End of shell archive
exit 0

