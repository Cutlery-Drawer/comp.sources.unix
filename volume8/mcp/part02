Subject:  v08i042:  Account creation/manipulation program, Part02/08
Newsgroups: mod.sources
Approved: mirror!rs

Submitted by: Kyle Jones <xanth!kyle>
Mod.sources: Volume 8, Issue 42
Archive-name: mcp/Part02

This is mcp, an account creation/manipulation program.

#! /bin/sh
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
# If all goes well, you will see the message "End of archive 2 (of 8)."
# Contents:  help/load-file.n help/range.n help/remove-alias.n
#   help/remove-class.n help/remove-cryos.n help/remove-from-alias.n
#   help/remove-from-class.n help/remove-from-group.n
#   help/remove-from-sig.n help/remove-group.n help/remove-range.n
#   help/remove-sig.n help/remove-user.n help/remove-vig.n
#   help/save-and-exit.n help/save-changes.n help/shell-escape.n
#   help/sig.n help/uid.n help/unbind-class.n help/unbind-group.n
#   help/unbind-sig.n help/update-alias.n help/update-class.n
#   help/update-group.n help/update-range.n help/update-sig.n
#   help/update-user.n help/vig.n help/what-is.n man/Copyright
#   man/Makefile man/accounts.n man/classes.n man/mcp.n man/ranges.n
#   man/shells.n src/alias.h
# Wrapped by rs@mirror on Fri Feb  6 15:55:48 1987
PATH=/bin:/usr/bin:/usr/ucb; export PATH
echo shar: extracting "'help/load-file.n'" '(2434 characters)'
if test -f 'help/load-file.n' ; then 
  echo shar: will not over-write existing file "'help/load-file.n'"
else
sed 's/^X//' >help/load-file.n <<'@//E*O*F help/load-file.n//'
X.ce
X.ul
Xload-file [ file-name ... ]
X.sp
X.ul
Xload-file
Xallows a large number of user accounts to be created by loading the
Xnecessary information from a file.  If
X.ul
Xfile-name
Xarguments are provided, mcp will use these names as the names of the files
Xthat it expects the user information to be in.  Otherwise mcp
Xwill prompt you for the file names using Tenex-style file name
Xcompletion.
X.sp
XThe load file must be in a particular format in order for mcp
Xto be able to use its contents.  The format is given below.
X.sp
XThe first character of the first line should be either
Xan 'n' or an 'i'.
XAn 'n' signifies the
X.ul
X"name first format"
Xwhile a 'i' indicates that the
X.ul
X"ID first format"
Xwill be used.  These will become explained in a moment.
X.sp
XThe second line should contain a space separated list of the groups
Xthe added users should be in.  The gid of the first group in the list
Xwill serve as the base gid for all the users added from this load file
Xso there must be at least one group listed.
X.sp
XThe third line should contain a space separated list of classes that the new
Xusers should be put into.  This line must be present but it may be empty
Xto indicate that the user shouldn't be placed into any classes.
X.sp
XThe fourth line should contain a space separated list of sigs that the new
Xusers should be put into.  This line must be present but it may be empty
Xto indicate that the user shouldn't be placed into any sigs.
X.sp
XThe fifth line should contain the full pathname of the shell that the new
Xusers should use.  This line must be present but it may be left empty
Xto indicate that the default shell should be used.
X.sp
XSuccessive lines should contain the real name and ID of users to be added.
Xif using the 'n' format the real name should be first; the 'i' format
Xrequires that the ID be first.  The ID and real name may be separated
Xby any whitespace characters except newline.  The lines are parsed
Xinto an argv-type array.  In format 'n' argv[argc-1] will be taken as
Xthe ID and
Xargv[0] and the rest of the args exempting the ID are taken to be parts of
Xthe real name.  In format 'i', argv[0] is taken as the ID and the rest of
Xthe args are used as parts of the real name.
X.sp
XMcp will emit vile vituperatives if you obviously have the file format wrong
Xand will refuse to do the load.
X.sp
XRemember that these added users, just like any others, are not really added
Xuntil a save-changes or a save-and-exit is done.
@//E*O*F help/load-file.n//
if test 2434 -ne "`wc -c <'help/load-file.n'`"; then
    echo shar: error transmitting "'help/load-file.n'" '(should have been 2434 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/range.n'" '(828 characters)'
if test -f 'help/range.n' ; then 
  echo shar: will not over-write existing file "'help/range.n'"
else
sed 's/^X//' >help/range.n <<'@//E*O*F help/range.n//'
X.in 3
X.ti 0
X.ul
Xrange
X\- is an mcp abstraction.  A
X.ul
Xrange
Xis simply an list contiguous uids.  Each
X.ul
Xrange
Xhas the following attributes:
X.nf
X.sp
X.in +1
X\(bu   Name
X\(bu   First uid
X\(bu   Last uid
X\(bu   Mode (\fI"shared"\fR or \fI"exclusive"\fR)
X.in -1
X.sp
X.fi
XThe
Xname corresponds to the name of an existing group.  New users that
Xare created with a base gid that maps to the name of a group that has
Xa corresponding
X.ul
Xrange
Xwill have its uid chosen from that range of uids.  If there are no unused
Xuids in the assigned
X.ul
Xrange
Xthen a uid will be used from a range that has a
X.ul
X"shared"
Xmode.  If still no free uid can be found then mcp will search for a free uid
Xin the holes that no
X.ul
Xrange
Xcovers.  If no unused uid can be found at this point, mcp will give
Xup and cry out against you and your lousy planning.
@//E*O*F help/range.n//
if test 828 -ne "`wc -c <'help/range.n'`"; then
    echo shar: error transmitting "'help/range.n'" '(should have been 828 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/remove-alias.n'" '(243 characters)'
if test -f 'help/remove-alias.n' ; then 
  echo shar: will not over-write existing file "'help/remove-alias.n'"
else
sed 's/^X//' >help/remove-alias.n <<'@//E*O*F help/remove-alias.n//'
X.ce
X.ul
Xremove-alias <name>
X.sp
X.ul
Xremove-alias
Xremoves a particular alias.  Logically enough, any users that are members
Xof the alias are quietly removed from the alias before the alias itself is
Xremoved, as are all references to the alias.
@//E*O*F help/remove-alias.n//
if test 243 -ne "`wc -c <'help/remove-alias.n'`"; then
    echo shar: error transmitting "'help/remove-alias.n'" '(should have been 243 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/remove-class.n'" '(243 characters)'
if test -f 'help/remove-class.n' ; then 
  echo shar: will not over-write existing file "'help/remove-class.n'"
else
sed 's/^X//' >help/remove-class.n <<'@//E*O*F help/remove-class.n//'
X.ce
X.ul
Xremove-class <name>
X.sp
X.ul
Xremove-class
Xremoves a particular class.  Logically enough, any users that are members
Xof the class are quietly removed from the class before the class itself is
Xremoved, as are all references to the class.
@//E*O*F help/remove-class.n//
if test 243 -ne "`wc -c <'help/remove-class.n'`"; then
    echo shar: error transmitting "'help/remove-class.n'" '(should have been 243 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/remove-cryos.n'" '(404 characters)'
if test -f 'help/remove-cryos.n' ; then 
  echo shar: will not over-write existing file "'help/remove-cryos.n'"
else
sed 's/^X//' >help/remove-cryos.n <<'@//E*O*F help/remove-cryos.n//'
X.ce
X.ul
Xremove-cryos
X.sp
X.ul
Xremove-cryos
Xremoves all users that are frozen.
X#ifdef DOFILES
XAll the user home directories are set to be removed at the next
X\fIsave-changes\fR or \fIsave-and-exit\fR.  Typically you will want to archive
Xthe frozen accounts before doing a
X.ul
Xremove-cryos.
X#endif
X.sp
XRemember that no actual changes are made until a \fIsave-changes\fR or
X\fIsave-and-exit\fR is performed.
@//E*O*F help/remove-cryos.n//
if test 404 -ne "`wc -c <'help/remove-cryos.n'`"; then
    echo shar: error transmitting "'help/remove-cryos.n'" '(should have been 404 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/remove-from-alias.n'" '(182 characters)'
if test -f 'help/remove-from-alias.n' ; then 
  echo shar: will not over-write existing file "'help/remove-from-alias.n'"
else
sed 's/^X//' >help/remove-from-alias.n <<'@//E*O*F help/remove-from-alias.n//'
X.ce
X.ul
Xremove-from-alias <alias name>
X.sp
X.ul
Xremove-from-alias
Xallows you to remove users from a particular alias.  You will be prompted
Xfor a list of user names, space separated.
@//E*O*F help/remove-from-alias.n//
if test 182 -ne "`wc -c <'help/remove-from-alias.n'`"; then
    echo shar: error transmitting "'help/remove-from-alias.n'" '(should have been 182 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/remove-from-class.n'" '(302 characters)'
if test -f 'help/remove-from-class.n' ; then 
  echo shar: will not over-write existing file "'help/remove-from-class.n'"
else
sed 's/^X//' >help/remove-from-class.n <<'@//E*O*F help/remove-from-class.n//'
X.ce
X.ul
Xremove-from-class <class name>
X.sp
X.ul
Xremove-from-class
Xallows you to remove users from a particular class.
XThis does not mean that the users lose their accounts, it just means
Xthat these users are no longer in the said class.   You will be prompted
Xfor a list of user names, space separated.
@//E*O*F help/remove-from-class.n//
if test 302 -ne "`wc -c <'help/remove-from-class.n'`"; then
    echo shar: error transmitting "'help/remove-from-class.n'" '(should have been 302 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/remove-from-group.n'" '(406 characters)'
if test -f 'help/remove-from-group.n' ; then 
  echo shar: will not over-write existing file "'help/remove-from-group.n'"
else
sed 's/^X//' >help/remove-from-group.n <<'@//E*O*F help/remove-from-group.n//'
X.ce
X.ul
Xremove-from-group <group name>
X.sp
X.ul
Xremove-from-group
Xallows you to remove users from a particular group.
XThis applies only to users that are members of the group via the /etc/group
Xaccess list, NOT users that have a base gid that maps to the gid of the
XYou will be prompted for a list of user names, space separated.
X.ul
X<group name>.
XTo change a the base gid of a user, use \fIupdate-user\fR.
@//E*O*F help/remove-from-group.n//
if test 406 -ne "`wc -c <'help/remove-from-group.n'`"; then
    echo shar: error transmitting "'help/remove-from-group.n'" '(should have been 406 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/remove-from-sig.n'" '(292 characters)'
if test -f 'help/remove-from-sig.n' ; then 
  echo shar: will not over-write existing file "'help/remove-from-sig.n'"
else
sed 's/^X//' >help/remove-from-sig.n <<'@//E*O*F help/remove-from-sig.n//'
X.ce
X.ul
Xremove-from-sig <sig name>
X.sp
X.ul
Xremove-from-sig
Xallows you to remove users from a particular sig.
XThis does not mean that the users lose their accounts, it just means
Xthat these users are no longer in the said sig.   You will be prompted
Xfor a list of user names, space separated.
@//E*O*F help/remove-from-sig.n//
if test 292 -ne "`wc -c <'help/remove-from-sig.n'`"; then
    echo shar: error transmitting "'help/remove-from-sig.n'" '(should have been 292 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/remove-group.n'" '(559 characters)'
if test -f 'help/remove-group.n' ; then 
  echo shar: will not over-write existing file "'help/remove-group.n'"
else
sed 's/^X//' >help/remove-group.n <<'@//E*O*F help/remove-group.n//'
X.ce
X.ul
Xremove-group <name>
X.sp
X.ul
Xremove-group
Xdeletes a group.  All users who are members of the group via the access list
Xin GRPFILE will no longer have the privileges associated with this group.
XHowever users having the base gid that corresponds to the gid of this group
Xwill still have that base gid.  This may be construed as a bug but I could
Xnot think of a consistent way of handling this except by demanding that the
Xgroup be empty before it is removed.
X.sp
XNo actual changes are made until a \fIsave-changes\fR or \fIsave-and-exit\fR
Xis performed.
@//E*O*F help/remove-group.n//
if test 559 -ne "`wc -c <'help/remove-group.n'`"; then
    echo shar: error transmitting "'help/remove-group.n'" '(should have been 559 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/remove-range.n'" '(202 characters)'
if test -f 'help/remove-range.n' ; then 
  echo shar: will not over-write existing file "'help/remove-range.n'"
else
sed 's/^X//' >help/remove-range.n <<'@//E*O*F help/remove-range.n//'
X.ce
X.ul
Xremove-range <name>
X.sp
X.ul
Xremove-range
Xtells mcp that the uid range that is now associated with a certain group
Xshould not be used any longer.  This does not affect existing users
Xin any way.
@//E*O*F help/remove-range.n//
if test 202 -ne "`wc -c <'help/remove-range.n'`"; then
    echo shar: error transmitting "'help/remove-range.n'" '(should have been 202 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/remove-sig.n'" '(229 characters)'
if test -f 'help/remove-sig.n' ; then 
  echo shar: will not over-write existing file "'help/remove-sig.n'"
else
sed 's/^X//' >help/remove-sig.n <<'@//E*O*F help/remove-sig.n//'
X.ce
X.ul
Xremove-sig <name>
X.sp
X.ul
Xremove-sig
Xremoves a particular sig.  Logically enough, any users that are members of
Xthe sig are quietly removed from the sig before the sig itself is removed,
Xas are all references to the sig.
@//E*O*F help/remove-sig.n//
if test 229 -ne "`wc -c <'help/remove-sig.n'`"; then
    echo shar: error transmitting "'help/remove-sig.n'" '(should have been 229 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/remove-user.n'" '(278 characters)'
if test -f 'help/remove-user.n' ; then 
  echo shar: will not over-write existing file "'help/remove-user.n'"
else
sed 's/^X//' >help/remove-user.n <<'@//E*O*F help/remove-user.n//'
X.ce
X.ul
Xremove-user <name>
X.sp
X.ul
Xremove-user
Xdeletes a user's account.
X#ifdef DOFILES
XYou are asked if you want the home directory of the user removed as well.
X#endif
X.sp
XRemember that no actual changes are made until a \fIsave-changes\fR
Xor \fIsave-and-exit\fR is performed.
@//E*O*F help/remove-user.n//
if test 278 -ne "`wc -c <'help/remove-user.n'`"; then
    echo shar: error transmitting "'help/remove-user.n'" '(should have been 278 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/remove-vig.n'" '(190 characters)'
if test -f 'help/remove-vig.n' ; then 
  echo shar: will not over-write existing file "'help/remove-vig.n'"
else
sed 's/^X//' >help/remove-vig.n <<'@//E*O*F help/remove-vig.n//'
X.ce
X.ul
Xremove-vig <name>
X.sp
X.ul
Xremove-vig
Xtells mcp that a particular group is no longer
Xa \fIV\fRery \fII\fRmportant \fIG\fRroup.  Use \fIwhat-is vig\fR
Xto see what being a vig entails.
@//E*O*F help/remove-vig.n//
if test 190 -ne "`wc -c <'help/remove-vig.n'`"; then
    echo shar: error transmitting "'help/remove-vig.n'" '(should have been 190 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/save-and-exit.n'" '(157 characters)'
if test -f 'help/save-and-exit.n' ; then 
  echo shar: will not over-write existing file "'help/save-and-exit.n'"
else
sed 's/^X//' >help/save-and-exit.n <<'@//E*O*F help/save-and-exit.n//'
X.ce
X.ul
Xsave-and-exit
X.sp
X.ul
Xsave-and-exit
Xdoes a save-changes and an exit-mcp, in that order.  See the help pages for
Xthese commands for more information.
@//E*O*F help/save-and-exit.n//
if test 157 -ne "`wc -c <'help/save-and-exit.n'`"; then
    echo shar: error transmitting "'help/save-and-exit.n'" '(should have been 157 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/save-changes.n'" '(1250 characters)'
if test -f 'help/save-changes.n' ; then 
  echo shar: will not over-write existing file "'help/save-changes.n'"
else
sed 's/^X//' >help/save-changes.n <<'@//E*O*F help/save-changes.n//'
X.ce
X.ul
Xsave-changes
X.sp
X.ul
Xsave-changes
Xcauses all changes that have made to be written
Xout to the accounting files.
XAll checkpoint files will deleted as the real accounting
Xfiles are written.
X#ifdef DOFILES
XAlso any other filesystem work such as creating, removing,
Xand renaming user directories is done at this time.
XAn important thing to remember is that mcp creates home directories
Xwith group ownership corresponding to the base gid of user ONLY if
Xthat gid maps to a vig; otherwise the gid of the directory is set to 0.
X# ifdef sun
X.sp
XClient machines will by necessity use remote commands to accomplish this
Xsince user directories are usually in a filesystem mounted on a directory on
Xthe fileserver.
X# endif
XIf errors occur, mcp will put the particular change back  on
Xthe job queue to be tried again on the next
X.ul
Xsave-changes.
XThus if things go wronmg during a \fIsave-and-exit\fR
Xyou will be notified and asked to confirm that you wish to leave while there
Xare still outstanding changes.
X# ifdef sun
X.sp
X(Note: Errors on remote commands are difficult to detect since no exit
Xstatus is returned.  However if the command generate error messages, these
Xwill be passed to you.  Mcp will behave as if the command succeeded.)
X# endif
X#endif
@//E*O*F help/save-changes.n//
if test 1250 -ne "`wc -c <'help/save-changes.n'`"; then
    echo shar: error transmitting "'help/save-changes.n'" '(should have been 1250 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/shell-escape.n'" '(387 characters)'
if test -f 'help/shell-escape.n' ; then 
  echo shar: will not over-write existing file "'help/shell-escape.n'"
else
sed 's/^X//' >help/shell-escape.n <<'@//E*O*F help/shell-escape.n//'
X.ce
X.ul
Xshell-escape [ command [ arg ... ] ]
X.sp
X.ul
Xshell-escape
Xwithout any arguments forks an interactive subshell.  The shell is taken
Xfrom the your SHELL environmental variable, and in lieu of that a default
Xshell (typically /bin/sh) is
Xused.  If arguments are present mcp executes this command in place of the
Xshell.
X.sp
XUpon command or subshell exit, you will be returned to mcp.
@//E*O*F help/shell-escape.n//
if test 387 -ne "`wc -c <'help/shell-escape.n'`"; then
    echo shar: error transmitting "'help/shell-escape.n'" '(should have been 387 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/sig.n'" '(401 characters)'
if test -f 'help/sig.n' ; then 
  echo shar: will not over-write existing file "'help/sig.n'"
else
sed 's/^X//' >help/sig.n <<'@//E*O*F help/sig.n//'
X.in 3
X.ti 0
X.ul
Xsig
X\- an mcp abstraction with the following attributes:
X.nf
X.sp
X.in +1
X\(bu   Name
X\(bu   Expiration date (optional)
X\(bu   Description
X.in -1
X.sp
X.fi
XSigs are created using
X.ul
Xadd-sig
Xand users may be subsequently added to them via
X.ul
Xadd-to-sig.
XSigs are not automatically deleted when they expire.  However the
Xsystem administrator can use
X.ul
Xmcp -c
Xto report any expired sigs.
@//E*O*F help/sig.n//
if test 401 -ne "`wc -c <'help/sig.n'`"; then
    echo shar: error transmitting "'help/sig.n'" '(should have been 401 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/uid.n'" '(252 characters)'
if test -f 'help/uid.n' ; then 
  echo shar: will not over-write existing file "'help/uid.n'"
else
sed 's/^X//' >help/uid.n <<'@//E*O*F help/uid.n//'
X.in 3
X.ti 0
X.ul
Xuid
X\- is the standard UNIX numerical user id that uniquely identifies
Xeach user.  Since file ownerships are recognized by uid, a change in
Xa user uid entails changing the ownership of all the files of that user
Xto reflect the new uid.
@//E*O*F help/uid.n//
if test 252 -ne "`wc -c <'help/uid.n'`"; then
    echo shar: error transmitting "'help/uid.n'" '(should have been 252 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/unbind-class.n'" '(358 characters)'
if test -f 'help/unbind-class.n' ; then 
  echo shar: will not over-write existing file "'help/unbind-class.n'"
else
sed 's/^X//' >help/unbind-class.n <<'@//E*O*F help/unbind-class.n//'
X.ce
X.ul
Xunbind-class <class name>
X.sp
X.ul
Xunbind-class
Xunbinds an existing class from one or more aliases.  This means that all
Xusers whose alias memberships depend solely on the class being bound to these
Xaliases are removed from the aliases.  Subseqeunt changes in class
Xmembership will be no longer be reflected in the addresses contained in the
Xaliases.
@//E*O*F help/unbind-class.n//
if test 358 -ne "`wc -c <'help/unbind-class.n'`"; then
    echo shar: error transmitting "'help/unbind-class.n'" '(should have been 358 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/unbind-group.n'" '(358 characters)'
if test -f 'help/unbind-group.n' ; then 
  echo shar: will not over-write existing file "'help/unbind-group.n'"
else
sed 's/^X//' >help/unbind-group.n <<'@//E*O*F help/unbind-group.n//'
X.ce
X.ul
Xunbind-group <group name>
X.sp
X.ul
Xunbind-group
Xunbinds an existing group from one or more aliases.  This means that all
Xusers whose alias memberships depend solely on the group being bound to these
Xaliases are removed from the aliases.  Subseqeunt changes in group
Xmembership will be no longer be reflected in the addresses contained in the
Xaliases.
@//E*O*F help/unbind-group.n//
if test 358 -ne "`wc -c <'help/unbind-group.n'`"; then
    echo shar: error transmitting "'help/unbind-group.n'" '(should have been 358 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/unbind-sig.n'" '(346 characters)'
if test -f 'help/unbind-sig.n' ; then 
  echo shar: will not over-write existing file "'help/unbind-sig.n'"
else
sed 's/^X//' >help/unbind-sig.n <<'@//E*O*F help/unbind-sig.n//'
X.ce
X.ul
Xunbind-sig <sig name>
X.sp
X.ul
Xunbind-sig
Xunbinds an existing sig from one or more aliases.  This means that all
Xusers whose alias memberships depend solely on the sig being bound to these
Xaliases are removed from the aliases.  Subseqeunt changes in sig
Xmembership will be no longer be reflected in the addresses contained in the
Xaliases.
@//E*O*F help/unbind-sig.n//
if test 346 -ne "`wc -c <'help/unbind-sig.n'`"; then
    echo shar: error transmitting "'help/unbind-sig.n'" '(should have been 346 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/update-alias.n'" '(161 characters)'
if test -f 'help/update-alias.n' ; then 
  echo shar: will not over-write existing file "'help/update-alias.n'"
else
sed 's/^X//' >help/update-alias.n <<'@//E*O*F help/update-alias.n//'
X.ce
X.ul
Xupdate-alias <name>
X.sp
X.ul
Xupdate-alias
Xallows you the change the name of a particular alias.
XBindings and addressees are changed with other commmands.
@//E*O*F help/update-alias.n//
if test 161 -ne "`wc -c <'help/update-alias.n'`"; then
    echo shar: error transmitting "'help/update-alias.n'" '(should have been 161 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/update-class.n'" '(214 characters)'
if test -f 'help/update-class.n' ; then 
  echo shar: will not over-write existing file "'help/update-class.n'"
else
sed 's/^X//' >help/update-class.n <<'@//E*O*F help/update-class.n//'
X.ce
X.ul
Xupdate-class <name>
X.sp
X.ul
Xupdate-class
Xallows you the change the attributes of a particular class.
XYou will queried whether you wish to change each attribute.
XDefault answers, if any, appear in brackets.
@//E*O*F help/update-class.n//
if test 214 -ne "`wc -c <'help/update-class.n'`"; then
    echo shar: error transmitting "'help/update-class.n'" '(should have been 214 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/update-group.n'" '(214 characters)'
if test -f 'help/update-group.n' ; then 
  echo shar: will not over-write existing file "'help/update-group.n'"
else
sed 's/^X//' >help/update-group.n <<'@//E*O*F help/update-group.n//'
X.ce
X.ul
Xupdate-group <name>
X.sp
X.ul
Xupdate-group
Xallows you the change the attributes of a particular group.
XYou will queried whether you wish to change each attribute.
XDefault answers, if any, appear in brackets.
@//E*O*F help/update-group.n//
if test 214 -ne "`wc -c <'help/update-group.n'`"; then
    echo shar: error transmitting "'help/update-group.n'" '(should have been 214 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/update-range.n'" '(164 characters)'
if test -f 'help/update-range.n' ; then 
  echo shar: will not over-write existing file "'help/update-range.n'"
else
sed 's/^X//' >help/update-range.n <<'@//E*O*F help/update-range.n//'
X.ce
X.ul
Xupdate-range <name>
X.sp
X.ul
Xupdate-range
Xallow you to change the limits and/or mode of a particular uid range.
XDefault answers, if any, appear in brackets.
@//E*O*F help/update-range.n//
if test 164 -ne "`wc -c <'help/update-range.n'`"; then
    echo shar: error transmitting "'help/update-range.n'" '(should have been 164 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/update-sig.n'" '(208 characters)'
if test -f 'help/update-sig.n' ; then 
  echo shar: will not over-write existing file "'help/update-sig.n'"
else
sed 's/^X//' >help/update-sig.n <<'@//E*O*F help/update-sig.n//'
X.ce
X.ul
Xupdate-sig <name>
X.sp
X.ul
Xupdate-sig
Xallows you the change the attributes of a particular sig.
XYou will queried whether you wish to change each attribute.
XDefault answers, if any, appear in brackets.
@//E*O*F help/update-sig.n//
if test 208 -ne "`wc -c <'help/update-sig.n'`"; then
    echo shar: error transmitting "'help/update-sig.n'" '(should have been 208 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/update-user.n'" '(700 characters)'
if test -f 'help/update-user.n' ; then 
  echo shar: will not over-write existing file "'help/update-user.n'"
else
sed 's/^X//' >help/update-user.n <<'@//E*O*F help/update-user.n//'
X.ce
X.ul
Xupdate-user <name>
X.sp
X.ul
Xupdate-user
Xallows you to change these attributes of a particular user:
X.nf
X.sp
X.in +1
X\(bu   Login name
X\(bu   Real name
X\(bu   Uid
X\(bu   Gid
X\(bu   Password
X\(bu   Id
X\(bu   Home directory
X\(bu   Shell
X.in -1
X.sp
X.fi
XMcp will ask you in turn what you want each of these attriutes to be.
XDefault responses, if any, appear in brackets.
X#ifdef DOFILES
XNote: If you change a user uid, mcp will use find(1) and chown(8) to change
Xthe ownerships of the user's files to the new uid.  Since this usually takes
Xmore than a few seconds, mcp spawns these processes in the background (at
Xlow priority).  So don't expect the file ownerships to be changed
Ximmediately.
X#endif
@//E*O*F help/update-user.n//
if test 700 -ne "`wc -c <'help/update-user.n'`"; then
    echo shar: error transmitting "'help/update-user.n'" '(should have been 700 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/vig.n'" '(326 characters)'
if test -f 'help/vig.n' ; then 
  echo shar: will not over-write existing file "'help/vig.n'"
else
sed 's/^X//' >help/vig.n <<'@//E*O*F help/vig.n//'
X.in 3
X.ti 0
X.ul
Xvig
X\- an acronym for \fIV\fRery \fII\fRmportant \fIG\fRroup.
X.ul
XVigs
Xare just attributes of existings groups.  Members of such groups
Xare treated specially;
X.ul
Xvig
Xmembers are never considered deadbeats or inactives.  Also
Xthe freeze-user command will request confirmation before freezing
Xa
X.ul
Xvig
Xmember.
@//E*O*F help/vig.n//
if test 326 -ne "`wc -c <'help/vig.n'`"; then
    echo shar: error transmitting "'help/vig.n'" '(should have been 326 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'help/what-is.n'" '(233 characters)'
if test -f 'help/what-is.n' ; then 
  echo shar: will not over-write existing file "'help/what-is.n'"
else
sed 's/^X//' >help/what-is.n <<'@//E*O*F help/what-is.n//'
X.ce
X.ul
Xwhat-is <term>
X.sp
X.ul
Xwhat-is
Xgives the definition of
X.ul
X<term>.
XDefinitions are provided for various bits of jargon used by system gurus
Xwhen dealing with accounts.  To see the list of defined terms, type
X\fIwhat-is ?\fR.
@//E*O*F help/what-is.n//
if test 233 -ne "`wc -c <'help/what-is.n'`"; then
    echo shar: error transmitting "'help/what-is.n'" '(should have been 233 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'man/Copyright'" '(385 characters)'
if test -f 'man/Copyright' ; then 
  echo shar: will not over-write existing file "'man/Copyright'"
else
sed 's/^X//' >man/Copyright <<'@//E*O*F man/Copyright//'
X(c) 1986 by Kyle E. Jones
X
XAll sources and documentation of this mcp distribution are
Xincluded in this copyright, but permission is granted to
Xcopy and redistribute any part of this distribution, provided
Xthat this notice is a conspicuous part of the redistribution,
Xand that no part of this distribution is sold.
X
XThis software is distributed 'as is', without warranties of any kind.
@//E*O*F man/Copyright//
if test 385 -ne "`wc -c <'man/Copyright'`"; then
    echo shar: error transmitting "'man/Copyright'" '(should have been 385 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'man/Makefile'" '(1104 characters)'
if test -f 'man/Makefile' ; then 
  echo shar: will not over-write existing file "'man/Makefile'"
else
sed 's/^X//' >man/Makefile <<'@//E*O*F man/Makefile//'
X# Change this if your C preprocessor is elsewhere
XCPP	= /lib/cpp
X
X# what section the mcp manual should go under
XMCPSECTION	= n
X# what section the file format manuals should go under
XFILESECTION	= 5
X
XPAGES	= accounts.t classes.t ranges.t shells.t sigs.t vigs.t
XMATTES	= accounts.n classes.n ranges.n shells.n sigs.n vigs.n
X
Xall:	$(PAGES) mcp.t
X
X$(PAGES):	Defs
X
XDefs:	../src/sysdep.h
X	sed -e 's/"//g' -e "s/[	 ][ 	]*/ /g" ../src/sysdep.h > Defs
X
Xmcp.t:	mcp.n
X	tbl mcp.n > mcp.t
X
Xinstall:	all
X	@echo Installing manual pages...
X	@cp mcp.t /usr/man/man$(MCPSECTION)/mcp.$(MCPSECTION)
X	@cp accounts.t /usr/man/man$(FILESECTION)/accounts.$(FILESECTION)
X	@cp classes.t /usr/man/man$(FILESECTION)/classes.$(FILESECTION)
X	@cp ranges.t /usr/man/man$(FILESECTION)/ranges.$(FILESECTION)
X	@cp shells.t /usr/man/man$(FILESECTION)/shells.$(FILESECTION)
X	@cp sigs.t /usr/man/man$(FILESECTION)/sigs.$(FILESECTION)
X	@cp vigs.t /usr/man/man$(FILESECTION)/vigs.$(FILESECTION)
X
Xclean:
X	@echo Removing cpp output and other flotsam...
X	@rm -f $(PAGES) Defs mcp.t
X
X.n.t:	; cat Defs $< | $(CPP) -P | cat -s > $@
X
X.SUFFIXES:	.n .t
@//E*O*F man/Makefile//
if test 1104 -ne "`wc -c <'man/Makefile'`"; then
    echo shar: error transmitting "'man/Makefile'" '(should have been 1104 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'man/accounts.n'" '(1099 characters)'
if test -f 'man/accounts.n' ; then 
  echo shar: will not over-write existing file "'man/accounts.n'"
else
sed 's/^X//' >man/accounts.n <<'@//E*O*F man/accounts.n//'
X.TH ACCOUNTS 5
X.SH NAME
Xaccounts \- mcp accounts file
X.SH DESCRIPTION
X.I Accounts
Xis a data file used by the
X.I mcp(l)
Xprogram to store user specific information.
XIn some places information in
X.I accounts
Xoverlaps information in
X.B /etc/passwd.
XThis is done for clarity.
X.PP
X.I Accounts
Xcontains for each user the following information:
X.sp
Xlogin name
X.br
Xreal name
X.br
Xunique ID string (e.g. Social Security Number)
X.br
Xnumerical user ID (corresponds to
X.B /etc/passwd)
X.br
Xnumerical group ID (corresponds to
X.B /etc/passwd)
X.br
Xlist of groups
X.br
Xlist of classes
X.br
Xlist of sigs (Special Interest Groups)
X.br
Xlist of aliases
X.PP
XInformation is stored one line per user.
XFields are separated by colons and list members are comma separated.
XAll fields must be present, however the list fields may be empty.
X.SH SEE ALSO
X.I mcp(l), passwd(5)
X.SH BUGS
XProbably should have used
X.I dbx(3X)
Xbut at present it lacks the flexibility of stdio (i.e. multiple databases
Xopen simultaneously).  This has been remedied in 4.3BSD by the
X.I ndbm(3X)
Xfaciclities but using these would not be backward compatible.
@//E*O*F man/accounts.n//
if test 1099 -ne "`wc -c <'man/accounts.n'`"; then
    echo shar: error transmitting "'man/accounts.n'" '(should have been 1099 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'man/classes.n'" '(597 characters)'
if test -f 'man/classes.n' ; then 
  echo shar: will not over-write existing file "'man/classes.n'"
else
sed 's/^X//' >man/classes.n <<'@//E*O*F man/classes.n//'
X.TH CLASSES 5
X.SH NAME
Xclasses \- mcp classes
X.SH SYNOPSIS
XCSFILE
X.SH DESCRIPTION
X.I Classes
Xcontains the names and descriptions of all the 
X.I mcp(l)
Xclasses.
XThe format for the file is
X.sp
Xname<sp>description length<sp>expiration time<nl>
X.br
Xdescription...
X.sp
XThe description length is the number of characters in the description
Xwhich beigns immedaitely after the name line.
XThe expiration date is given in the number of seconds since Jan. 1, 1970.
XUnless this file is munged by some calamity, it need never be edited manually
Xas
X.I mcp
Xhandles all modification of it.
X.SH SEE ALSO
X.I mcp(l)
@//E*O*F man/classes.n//
if test 597 -ne "`wc -c <'man/classes.n'`"; then
    echo shar: error transmitting "'man/classes.n'" '(should have been 597 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'man/mcp.n'" '(18435 characters)'
if test -f 'man/mcp.n' ; then 
  echo shar: will not over-write existing file "'man/mcp.n'"
else
sed 's/^X//' >man/mcp.n <<'@//E*O*F man/mcp.n//'
X.pi /usr/bin/col
X.TH MCP ODU
X.SH NAME
Xmcp \- autoMated acCounts Program
X.SH SYNOPSIS
X/etc/mcp [ options ]
X.SH DESCRIPTION
X\fIMcp\fR is a program designed to organize and simplify the creation,
Xmodification and removal of user accounts.  Complete support for the locking
Xand modification of \fB/etc/passwd\fR and \fB/etc/group\fR is provided; thus
X\fImcp\fR can (and should) be used in preference to \fIvipw(8)\fR.
X\fIMcp\fR may also be configured to handle updating the \fIsendmail(8)\fR
Xaliases database as well as creating/removing user home directories and mail.
X.SH OVERVIEW
X\fIMcp\fR should be considered an account \fIeditor\fR.  Like most
Xeditors, \fImcp\fR copies all the files to be edited into buffers, and then
Xedits the buffers rather than the actual files.  However one of \fImcp\fR's
Xfunctions is to take away the tedium of editing sensitive files like
X\fB/etc/passwd\fR with a normal text editor.
X.sp
XSo instead of forcing the user to graphically edit the various account data
Xfiles, \fImcp\fR interprets the data and allows the user to change the data
Xin terms of logical units such as users, groups, classes, aliases, etc.
XSuch logical units can be manipulated interactively using simple commands;
Xno changes are made to the actual data files until specifically requested
Xvia a \fBsave-changes\fR or \fBsave-and-exit\fR command.  You can see what
Xchanges \fImcp\fR will make beforehand by using the \fBdescribe-changes\fR
Xcommand.
X.sp
XIn order to affect changes, \fImcp\fR must be invoked as the super-user.
XWhen \fImcp\fR is invoked by a non-privileged user, none of the commands
Xwhich would cause change are available.  The latter is useful when you want
Xto peruse the account files without altering them.
X.SH INTERACTION
XWhen \fImcp\fR is invoked without arguments it will start an interactive
Xsession.  Various startup messages are printed, followed by the command
Xprompt.  The prompt is ``(   )'' for normal users, ``(mcp)'' for the
Xsuper-user.  \fIMcp\fR then loops, accepting and executing various commands
Xfrom the keyboard, until a \fBexit-mcp\fR or \fBsave-and-exit\fR is
Xencountered.  Don't be disturbed if the startup messages disappear too
Xfast to be read; \fImcp\fR displays them only as reassurance that all is well
Xduring its sometimes lengthy startup phase.
X.sp
X\fIMcp\fR commands are meant to be descriptive and easy to understand.
XUnfortunately this makes them long and cumbersome to type.  To ease typing,
X\fImcp\fR offers Tenex-style name and command completion, which condenses most
Xcommands to no more than three keystrokes.
X.sp
XBecause of the Tenex input editor
Xsome characters are treated specially.
X.TP 8
X.B ?
X\fIMcp\fR displays the current completion list.  This is a good way to figure
Xout what sort of thing \fImcp\fR is asking for, if it's not immediately apparent.
X.TP
X.B <ESC>
XCauses \fImcp\fR to try to complete the word preceding the cursor using the
Xcurrent completion list.
X.TP
X.B <TAB>
XSame as
X.B <ESC>
Xabove.
X.TP
X.B <BS>
XDelete the character preceding the cursor.
X.TP
X.B <DEL>
XSame as
X.B <BS>
Xabove.
X.TP
X.B ^W
XWord delete.  Deletes the word preceding the cursor.
X.TP
X.B ^U, ^X
XLine kill.  Deletes everything on the current line.
X.TP
X.B ^T
XTransposes (swaps) the two characters immediately preceding the cursor.
X.TP
X.B ^R
XRedraws the current line.
X.PP
XAt \fImcp\fR's command prompt (either ``(   )'' or ``(mcp)'') a few other keys
Xhave meanings.
X.TP 8
X.B <SPC>
XActivates word completion \fIiff\fR this is the first word on the line.  The
Xfirst word restriction is needed to insure that you are permitted to use
Xspaces for other purposes (like delimiting words that
X\fIaren't\fR in the the completion list!)
X.TP
X.B ^P
XGoes back one command in the history list.
XRepeated
X.B ^P's
Xgo back further in the history.
X\fIMcp\fR keeps a history list of commands similar to that of
X.I csh(1).
XHowever this is a bare-bones facility: none of the fancy
X.I csh
Xsubstitutions are supported.
X.TP
X.B ^N
XGoes forward one command in the history list.  Using
X.B ^P
Xand
X.B ^N
Xyou may freely traverse the history list; upon finding the command
Xyou want, press
X.B <cr>
Xand the command will be passed to \fImcp\fR to be executed, just as if you
Xhad re-typed it manually.  The history list will contain at most the last 40
Xcommands.
X.PP
XOther than the special keys, \fImcp\fR resolutely ignores control
Xcharacters.  Also \fImcp\fR disallows colons since these will corrupt
X\fB/etc/passwd\fR.
X.sp
XDocumentation of all \fImcp\fR commands and terminology is available from
Xwithin the program via the \fBdescribe-command\fR and what-is commands.
X\fBDescribe-command\fR describes any \fImcp\fR command, and what-is gives an
Xexplanation of \fImcp\fR terminology (jargon).
X.SH ADDING USERS
XAccount creation is the primary function of \fImcp\fR.  There are only two
Xcommands that create accounts: \fBadd-user\fR and \fBload-file\fR.
X.sp
X\fBAdd-user\fR takes a single optional argument which, if present, should be
Xlogin name of the new user.  If no login name is specified, \fImcp\fR will
Xgenerate one using a predetermined set of rules.  (These rules may be viewed
Xwith \fBdescribe-command add-user\fR.)
X.sp
X\fIMcp\fR will ask you various questions about the new user.  Most of these
Xquestions will have default answers that you can agree with by typing
Xreturn, or override by typing a response of your own.  If you specify the
Xword ``generate'' when \fImcp\fR asks for a password for the new user,
X\fImcp\fR will generate a random password for the user and display it.
X.sp
XA typical \fBadd-user\fR sequence might look like this:
X.sp
X.nf
X\fB(mcp) add-user
XReal Name: \fIAngus George Michaels\fB
Xlogin name is "agm"
XId: \fI229983397\fB
XPassword [229983397]: \fIgenerate\fB
Xpassword is "GC558h"
XGroup [student]: \fIfaculty\fB
XUid [63]: 
XShell [/bin/csh]: 
XHome [/usr1/fac/agm]: 
Xadded
X(mcp) \fR
X.fi
X.sp
X\fIMcp\fR output is shown in \fBbold face\fR while user responses are shown in
X\fIitalics\fR.
X.sp
XNote that \fImcp\fR supplied correct default home, shell, and uid
Xinformation so the user only needed to press return.  The \fBId\fR entry
Xshould be something that uniquely identifies the user.  The idea behind this
Xis that if the user already has an account, \fImcp\fR will be able to detect
Xit and warn the system administrator.  For non-human accounts the special Id
X``exception'' is permitted.  The default password would have been the
X\fBId\fR entry if the user had not overridden this with the
X\fBgenerate\fR command.
X.sp
X\fBLoad-file\fR allows you to add a number of accounts directly from a
Xfile.  The file must begin with short header that consists of a series of
Xlines that dictate what groups, classes, and sigs the new users will be put
Xinto, what shell they will use, etc.  The precise format for these files is
Xgiven in the help page for \fBload-file\fR.
X.SH REMOVING USERS
XAccounts are deleted with the \fBremove-cryos\fR, and \fBremove-user\fR commands.
X.sp
X\fBRemove-user\fR takes one argument which should be the login name of the
Xuser to be deleted.  All references to this user are removed.  Depending on
Xhow the program was configured, \fImcp\fR may also ask whether the user's
Xhome directory should be removed, and also make a note to remove the user's
Xmail, and secretmail.
X.sp
X\fBRemove-cryos\fR removes users that are ``frozen''.  Freezing is explained below.
X.SH FREEZING USERS
XTypically when the time comes to delete accounts, it is desired to archive
Xthe victim users' files to tape before deleting them.  The \fBfreeze-user\fR
Xcommand changes a user's shell to /usr/misc/freeze, which is usually a
Xscript that outputs a explanatory message and exits.  This keeps the user
Xout of the account while it is (presumably) being archived.  This also can
Xserve as a simple way to warn a user that his account has been deemed
Xexpendable and give a grace period for (heh) appeal.
X.sp
XThe \fBfreeze-inactives\fR command takes an argument \fIn\fR which should be
Xnumber of days inactivity.  Users that have been inactive (haven't logged
Xin) for \fIn\fR days are frozen with this command.  \fIVig\fR (\fIV\fRery
X\fII\fRmportant \fIG\fRroup) members are never considered inactive and are
Xtherefore exempt from being victims of this command.  Vigs are described
Xin the next section.
X.sp
X\fBFreeze-deadbeats\fR freezes users that are not members of any \fIclass\fR,
X\fIsig\fR, or vig.  Classes and sigs are described two sections hence.
X.SH GROUPS
XManipulation of standard UNIX groups (see \fIgroup(5)\fR) is supported.
XGroups are added with \fBadd-group\fR and removed with \fBremove-group\fR.
XExisting users may be added and removed from groups via the
X\fBadd-to-group\fR and \fBremove-from-group\fR commands.
X.sp
XIn addition, groups can be marked as \fIvigs\fR.  Users with base group IDs
Xthat correspond to a vig are exempt from being considered as inactives or
Xdeadbeats.  System accounts such as \fBuucp\fR, and \fBnews\fR should made
Xmembers of a vig to prevent accidental freezing via \fBfreeze-deadbeats.
X.SH OTHER USER GROUPINGS
XBesides the standard UNIX groups, \fImcp\fR supports two other group
Xabstractions:  classes and sigs (\fIS\fRpecial \fII\fRnterest
X\fIG\fRroups).  Classes and sigs are identical in attributes, which are
Xname, expiration date and description.  \fIMcp\fR was developed on a machine used
Xto support both college courses and research groups; thus the purely
Xtechnical distinction between classes and sigs.
X.sp
XClasses and sigs are added with \fBadd-class\fR and \fBadd-sig\fR and
Xremoved with \fBremove-class\fR and \fBremove-sig\fR.  Existing users are
Xadded to classes and sigs via the \fBadd-to-class\fR and \fBadd-to-sig\fR
Xcommands and removed from the same with the \fBremove-from-class\fR and
X\fBremove-from-sig\fR commands.
X.sp
XClasses and sigs may have an optional expiration date.  Nothing spectacular
Xhappens when this date passes; it is just a convenient way to remind the
Xsystem administrator when the accounts associated with a particular project
Xmay be removed.  \fIMcp\fR will report expired classes and sigs (among other
Xthings) when invoked with the \fB-c\fR flag.
X.sp
XThe usual scenario here at ODU is: the system administrator uses \fImcp
X-c\fR to see which classes and sigs have expired and removes them.  He then
Xissues a \fBfreeze-deadbeats\fR to freeze those users whose accounts need no
Xlonger exist, due to the vanished classes and sigs.  A grace period of about
Xa week is given and then the frozen accounts are archived to tape and
Xremoved.
X.SH UID RANGES
XSome sites bundle users that are in the same base group into set ranges of
Xuids to allow rapid scanning of the password file.  Although \fImcp\fR is
Xdesigned to minimize human contact with \fB/etc/passwd\fR, uid ranges are
Xsupported.
X.sp
X\fBAdd-range\fR takes as an argument the name of a group to which a uid range
Xshould be assigned.  \fIMcp\fR will prompt you for the bounds of the range and
Xwhether the range is to be \fIshared\fR or \fIexclusive\fR.  If the range is
Xexclusive, only new users with base group IDs correspoding to the range will
Xbe given uids in that range.  If the range is shared, new users may be given
Xa uid in that range without being members of the corresponding group.  Thus
Xshared ranges automatically are fodder for new users with base groups that
Xdo not correspond to a range.
X.sp
XOnce a range has been assigned to a group, new users with base group IDs
Xthat correspond this group have their uids chosen from the corresponding
Xrange.  If there are no available uids left in the range, \fImcp\fR will
Xsearch though the shared ranges for a free uid.  If still none are found,
X\fImcp\fR will search the uids not covered by any range.  If \fImcp\fR still
Xcannot find a uid, you probably have BIG problems.  Think about it.
X.sp
X.SH MAINTAINING SENDMAIL ALIASES
XOptionally, \fImcp\fR can be configured to manage the sendmail aliases database
X(see \fIaliases(5)\fR).  Aliases are added and deleted with the \fBadd-alias\fR
Xand \fBremove-alias\fR commands.  Addresses can be added and removed from existing
Xaliases via the \fBadd-to-alias\fR and \fBremove-from-alias\fR commands.
X.sp
XAs an aid to managing mailing lists, \fImcp\fR supports \fIbinding\fR
Xclasses, sigs, and groups to aliases.  Once a class, sig or group is bound
Xto an alias any members of the class, sig or group are immediately a member
Xof the alias.  If the class, sig or group is subsequently unbound from the
Xalias (or removed) its members are removed from the alias unless they have
Xanother reason to be in it.  Being a member of another class, sig or group
Xthat is bound to the same alias suffices, as does having been a member of
Xthe alias before the class, sig or group was bound.  An example will clarify
Xthis.
X.nf
X.sp
X\fB(mcp) \fIdescribe-class sp200\fB
XClass: sp200
XInstructor: Rich Little
X.sp
XPublic Speaking, lecture, 3 hours, 3 credits.
X.sp
X.TS
X;
Xl3 l21 l .
Xreagan	Ronald Reagan	128
Xbresh_l	Leonid Breshnev	183
Xbeebl_z	Zaphod Beeblebrox	184
Xkhan	Genghis Khan	185
Xkirk	James T. Kirk	186
X.TE
X.sp
X5 members.
X(mcp) \fIdescribe-alias leaders\fB
XName: leaders
X        - Addressees -
Xreagan   
X1 addressee
X(mcp) \fIbind-class sp200\fB
XTo-Aliases: leaders
X1 bound
X(mcp) \fIdescribe-alias leaders\fB
XName: leaders
XBound to class  : sp200 
X        - Addressees -
Xbeebl_z   bresh_l   khan      kirk      reagan    
X5 addressees
X(mcp) \fIunbind-class sp200\fB
XFrom-Aliases: \fIleaders\fB
X1 unbound
X(mcp) \fIdescribe-alias leaders\fB
XName: leaders
X        - Addressees -
Xreagan   
X1 addressee
X(mcp) \fR
X.fi
X.sp
XNote that the user ``reagan'' remained in the alias ``leaders'' regardless
Xof the bindings because his membership was not dependent on that binding.
X.SH OPTIONS
X\fIMcp\fR has very few command line options:
X.TP 4
X.B -B
XWhen invoked with \fB-B\fR, \fImcp\fR will create or rebuild account
Xdata files that are missing or disturbed.  This should be used
Xwhenever \fImcp\fR is 
Xre-configured and \fImust\fR be used when \fImcp\fR is first installed.
X\fIMcp\fR keeps /etc/passwd sorted by uid for efficiency, and if this order is
Xdisturbed (e.g. by someone using \fIvipw\fR) \fImcp\fR will complain.  If
Xthis happens you can use \fImcp -B\fR to reorder /etc/passwd.
X.TP
X.B -c
XGoop and glop checker.  Some checks are done only if \fImcp\fR is invoked as
Xthe super-user.  Reports the existence of:
X.sp 0.5
X.in +3
X.ti -3
X\(bu  references to nonexistent
Xclasses, sigs, and users
X.br
X.ti -3
X\(bu  empty aliases
X.br
X.ti -3
X\(bu  empty classes and sigs
X.br
X.ti -3
X\(bu  expired classes and sigs
X.br
X.ti -3
X\(bu  nonexistent home directories and shells (super-user only)
X.br
X.ti -3
X\(bu  home directories owned by wrong user (super-user only)
X.br
X.ti -3
X\(bu  references to gids that have no corresponding group
X.br
X.ti -3
X\(bu  super-user and vig login names with no password
X.TP
X.B -l
X\fIMcp\fR lists each group, sig, and class and the number of members
Xin each.  The expiration dates are displayed for classes and sigs.
X.TP
X.B -s
X\fIMcp\fR will print a brief summary of the accounting information: the
Xnumber of users, groups, classes, sigs and aliases.
X.TP
X.B -v
XPrints the current \fImcp\fR version and patchlevel.
X.SH MISCELLANEOUS
XSome important things to remember when interacting with \fImcp\fR:
X.TP 3
X\(bu
XChanges are made to the accounting files ONLY when a \fBsave-changes\fR or
X\fBsave-and-exit\fR is executed.  If you have made some ghastly error and just
Xwant to abort the \fImcp\fR session, use \fBexit-mcp\fR; you will be asked
Xif you really want to exit without saving.  If you want to see what
X\fImcp\fR will do when \fBsave-changes\fR is invoked, use
X\fBdescribe-changes\fR.
X.TP
X\(bu
X\fIMcp\fR backs up each account data file (e.g. \fB/etc/passwd.bak\fR) before
Xoverwriting it.  This is only done once per \fImcp\fR session, thus the
Xbackup will represent the file before the session began, regardless of how
Xmany saves were done.
X.TP
X\(bu
X\fIMcp\fR can be configured to checkpoint all account data files (e.g.
X\fB/etc/passwd.mcp\fR) that have changed periodically during a session.
XAlso a checkpoint can be forced with the \fBcheckpoint-changes\fR command.
X.TP
X\(bu
XAt any point within a command, if \fImcp\fR is prompting you for input, you can
Xtype the interrrupt character to abort the command, without the command
Xtaking effect.
X.TP
X\(bu
X\fIMcp\fR expects lists of things to be separated by spaces, NOT commas.
XSince \fImcp\fR must handle sendmail's aliases file, words surrounded by double
Xquotes ``"'' are considered to be a single argument.  \fINote that the quotes
Xare considered part of the word, not just a delimiter.\fR
X.TP
X\(bu
XDefault responses to \fImcp\fR requests, if any, are shown in brackets
X``[]''.  If you just type return when a default response is provided, the
Xdefault response is assumed.
X.TP
X\(bu
XWhen \fImcp\fR is prompting you for information, if you are in doubt
Xabout what you are being asked, type a ? and \fImcp\fR will print the
Xcompletion list for this query, if there is one.
X.TP
X\(bu
X\fIMcp\fR tries to output only useful information to standard output.
XKeyboard input is taken through standard input but the keystrokes are echoed
Xto /dev/tty as are '?' completion list requests (see below).  What this
Xmeans is that you can re-direct \fImcp\fR's output into a file to create neat
Xclass rolls.  Just:
X.sp
X.ul
X% mcp > roll
X.sp
X\fRUse \fBdescribe-class\fR to get the roll and then \fBexit-mcp\fR
Xand you will
Xhave the class description devoid of cursor motion sequences and other
Xgarbage you would get had you used \fIscript(1)\fR.
X.SH CAVEATS
X\fIMcp\fR discards all comments in the sendmail aliases file.
X.sp
XMake sure ALL your system and daemon accounts (human or otherwise) are vig
Xmembers, lest you unwittingly freeze and later remove them.
X.SH ENVIRONMENT
X.TS
X;
Xl1 l .
XPAGER	\- pager to use instead of the default
XVISUAL	\- visual editor to use instead of the default
XEDITOR	\- for dumb terminals, editor to use instead of the default
XTERM	\- terminal type
XSHELL	\- shell to use on shell-escapes instead of the default
X.TE
X.SH SEE ALSO
X.I accounts(5), adduser(8), classes(5), group(5), passwd(5), ranges(5),
X.I shells(l), sigs(5), vigs(5), vipw(8)
X.SH BUGS
XPerhaps \fB/etc/termcap\fR should be searched to make \fImcp\fR work on odd
Xterminals.
X.sp
X\fIMcp\fR should allow the user to specify a series of productions
Xto create default user names and home directory names, instead of inflicting
XODU conventions upon all.
X.SH AUTHOR
XKyle Jones, ODU Computer Science, Norfolk, VA
X.br
X.in +4
X(with many, many helpful suggestions from Tad Guy)
@//E*O*F man/mcp.n//
if test 18435 -ne "`wc -c <'man/mcp.n'`"; then
    echo shar: error transmitting "'man/mcp.n'" '(should have been 18435 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'man/ranges.n'" '(1012 characters)'
if test -f 'man/ranges.n' ; then 
  echo shar: will not over-write existing file "'man/ranges.n'"
else
sed 's/^X//' >man/ranges.n <<'@//E*O*F man/ranges.n//'
X.TH RANGES 5
X.SH NAME
Xranges \- mcp numerical user ID ranges file
X.SH SYNOPSIS
XRANGEFILE
X.SH DESCRIPTION
X.I Ranges
Xcontain the default user ID (uid) ranges that
X.I mcp(l)
Xwill use when creating accounts either in
X.B add-user
Xor
X.B load-file.
XThese ranges are indexed by group.  The file format is:
X.sp
Xgroup-name <sep> from <sep> to <sep> mode <nl>
X.sp
X.I <sep>
Xis 1 or more
Xwhitespace characters (exempting newline).
X.PP
X.I Group-name
Xis the name of the
Xgroup (in
X.B /etc/group).
X.PP
X.I From
Xand
X.I to
Xare integers which give the uid range,
X.I from \- to
Xinclusive.
XUids are searched
X.I from
Xto
X.I to,
Xso the direction of uid searches may be reversed by making
X.I from > to.
X.PP
X.I Mode
Xis either
X.I shared
Xor
X.I exclusive.
XIf the mode is
X.I shared
Xwhen another group runs out of uids or a uid is needed for a user in a group
Xwhich has no assigned range, uids in
X.I shared
Xranges may be used.  If the mode is
X.I exclusive
Xonly users in that particular group
Xmay use uids from that range.
X.SH SEE ALSO
X.I mcp(l)
@//E*O*F man/ranges.n//
if test 1012 -ne "`wc -c <'man/ranges.n'`"; then
    echo shar: error transmitting "'man/ranges.n'" '(should have been 1012 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'man/shells.n'" '(653 characters)'
if test -f 'man/shells.n' ; then 
  echo shar: will not over-write existing file "'man/shells.n'"
else
sed 's/^X//' >man/shells.n <<'@//E*O*F man/shells.n//'
X.TH SHELLS ODU
X.SH NAME
Xshells \- mcp list of command interpreters
X.SH SYNOPSIS
XSHELLFILE
X.SH DESCRIPTION
X.I Shells
Xcontains a list of the available shells on this system, one per line.
XComments are delimited by `#' and newline.
XThis list will be read by the
X.I mcp(l)
Xprogram on startup and used to build a completion list during the provess
Xof adding users.  The shells should be listed as full pathnames, e.g.
X.I csh(1)
Xwould be listed as
X.B /bin/csh.
X.PP
XThe first shell given in the file is special because it is
Xconsidered to be the
X.B default shell
Xby
X.I mcp
Xand will be used whenever the user opts not to specify a shell.
X.SH SEE ALSO
X.I mcp(l)
@//E*O*F man/shells.n//
if test 653 -ne "`wc -c <'man/shells.n'`"; then
    echo shar: error transmitting "'man/shells.n'" '(should have been 653 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'src/alias.h'" '(173 characters)'
if test -f 'src/alias.h' ; then 
  echo shar: will not over-write existing file "'src/alias.h'"
else
sed 's/^X//' >src/alias.h <<'@//E*O*F src/alias.h//'
Xstruct	alias {
X	char		*al_name;
X	struct list	al_addresses;
X	struct list	al_groups;
X	struct list	al_classes;
X	struct list	al_sigs;
X};
X
Xstruct	alias *getalent(), *getalnam();
@//E*O*F src/alias.h//
if test 173 -ne "`wc -c <'src/alias.h'`"; then
    echo shar: error transmitting "'src/alias.h'" '(should have been 173 characters)'
fi
fi # end of overwriting check
echo shar: "End of archive 2 (of 8)."
cp /dev/null ark2isdone
DONE=true
for I in 1 2 3 4 5 6 7 8; do
    if test -! f ark${I}isdone; then
        echo "You still need to run archive ${I}."
        DONE=false
    fi
done
case $DONE in
    true)
        echo "You have run all 8 archives."
        echo 'See the README file'
        ;;
esac
##  End of shell archive.
exit 0
