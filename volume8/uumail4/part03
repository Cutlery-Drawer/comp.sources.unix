Subject:  v08i035:  Uumail release 4.2, Part03/04
Newsgroups: mod.sources
Approved: mirror!rs

Submitted by: sob@soma.BCM.TMC.EDU (Stan Barber)
Mod.sources: Volume 8, Issue 35
Archive-name: uumail4/Part03

[  IMPORTANT NOTE:  This version superceeds the recent net.sources posting
   because it also inclues the Patch#1.  An earlier version of Uumail
   was next in the backlog, hence this "rapid" posting.  --r$  ]

#! /bin/sh

# Make a new directory for the uumail sources, cd to it, 
# and run kits 1 thru 4 through sh. 
# When all 4 kits have been run, read README.

echo "This is uumail kit 3 (of 4).  If kit 3 is complete, the line"
echo '"'"End of kit 3 (of 4)"'" will echo at the end.'
echo ""
export PATH || (echo "You didn't use sh, you clunch." ; kill $$)
echo Extracting alias.c
cat >alias.c <<'!STUFFY!FUNK!'
#include "uuconf.h"
#ifndef lint
static char rcsid[] = "$Header: alias.c,v 4.0 86/11/17 16:02:00 sob Exp $";
#endif
/***************************************************************************
This work in its current form is Copyright 1986 Stan Barber
with the exception of opath, gethostname and the original getpath which
as far as I know are in the Public Domain. This software may be distributed
freely as long as no profit is made from such distribution and this notice
is reproducted in whole.
***************************************************************************
This software is provided on an "as is" basis with no guarantee of 
usefulness or correctness of operation for any purpose, intended or
otherwise. The author is in no way liable for this software's performance
or any damage it may cause to any data of any kind anywhere.
***************************************************************************/
/* These routines based in part on the aliasing facility of MH Version 1.7 */
/* $Log:	alias.c,v $
 * Revision 4.0  86/11/17  16:02:00  sob
 * Release version 4.0 -- uumail
 * 
 * Revision 3.3  86/10/21  15:06:12  sob
 * Added lint #indef to make lint happier
 * 
 * Revision 3.2  86/07/11  17:57:42  sob
 * renamed parse to aliasparse to avoid name conflict with resolve
 * 
 * Revision 3.1  86/05/13  12:36:47  sob
 * Added the ability to escape sensitive characters per suggestion
 * of tp@ndm20.UUCP.
 * 
 * Revision 3.0  86/03/14  12:04:41  sob
 * Release of 3/15/86 --- 3rd Release
 * 
 * Revision 1.10  86/03/14  11:57:13  sob
 * updated copyright
 * 
 * Revision 1.9  86/03/11  11:28:40  sob
 * Added Copyright Notice
 * 
 * Revision 1.8  86/03/03  17:16:39  sob
 * Added fixes provided by desint!geoff.
 * Stan
 * 
 * Revision 1.7  86/02/26  03:07:20  sob
 * This forward method seems to work. It is a bit awkward, but it does seem
 * to work. We will freeze the release here.
 * 
 * Revision 1.6  86/02/24  12:46:31  sob
 * Fixed some problems with .forward. Still not completely correct, but better.
 * Stan
 * 
 * Revision 1.5  86/02/23  23:48:50  sob
 * This version contains the first attempt to make .forwards work.
 * Stan
 * 
 * Revision 1.4  86/02/23  23:01:12  sob
 * This version will correctly make note of programs that can have output
 * of uumail directly piped into (in place of mail or uux).
 * 
 * Revision 1.3  86/02/18  01:56:12  sob
 * MH aliasing facility has been installed. Now comes time to test.
 * Stan
 * 
 * Revision 1.2  86/02/17  18:42:47  sob
 * First update to add linked list of addresses. Real aliasing to be
 * added next.
 * 
 * Revision 1.1  86/02/10  16:54:12  sob
 * Initial revision
 * 
 *
 */
#ifdef NOALIAS
char *
alias()
{
	return;
}
#else
EXTERN struct mailname addrlist;
#define GROUP "/etc/group"
char *termptr;


/* Conditional free -- perform a free call if the address passed
 * is in free storage;  else NOP
 */


cndfree(addr)
char *addr;
{
	extern char end;

	if(addr >= &end) free(addr);
}

uleq(c1, c2)
register char *c1, *c2;
{
	register int c;

	while(c = *c1++)
		if((c|040) != (*c2|040))
			return(0);
		else
			c2++;
	return(*c2 == 0);
}
/* modifications to allow quoting of characters that usually indicate
 * address delimiters provided by tp@ndm20.UUCP
 */
char *aliasparse(ptr, buf)
register char *ptr;
char *buf;
{
	register char *cp;

	cp = buf;
	while(isspace(*ptr) || *ptr == ',' || *ptr == ':')
		ptr++;
	while(isalnum(*ptr) || *ptr == '/' || *ptr == '-' || *ptr == '.' || *ptr == '!' || *ptr == '@' || *ptr == '%' || *ptr == '\\') {
		if(*ptr == '\\') ptr++;
		if(*ptr != '\0') *cp++ = *ptr++;
	}
	if(cp == buf) {
		switch(*ptr) {
		case '<':
		case '|':
		case '=':
			*cp++ = *ptr++;
		}
	}
	*cp = 0;
	if(cp == buf)
		return 0;
	termptr = ptr;
	return buf;
}
char *
advance(ptr)
	register char *ptr;
{
	return(termptr);
}

alias()
{
	register char *cp, *pp;
	register struct mailname *lp;
	char line[256], pbuf[64];
	FILE *a;

	if((a = fopen(AliasFile, "r")) == NULL)
		return;
	while(fgets(line, sizeof line, a)) {
		if(line[0] == ';' || line[0] == '\n')   /* Comment Line */
			continue;
		if((pp = aliasparse(line, pbuf)) == NULL) {
	    oops:       fprintf(stderr, "Bad alias file %s\n", AliasFile);
			fprintf(stderr, "Line: %s", line);
			exit(EX_OSFILE);
		}
		for(lp = &addrlist; lp->m_next; lp = lp->m_next) {
			if(aleq(lp->m_next->m_name, pp)) {
				remove(lp);
				if(!(cp = advance(line)) ||
				   !(pp = aliasparse(cp, pbuf)))
					goto oops;
				switch(*pp) {
				case '<':       /* From file */
					cp = advance(cp);
					if((pp = aliasparse(cp, pbuf)) == NULL)
						goto oops;
					addfile(pp);
					break;
				case '=':       /* UNIX group */
					cp = advance(cp);
					if((pp = aliasparse(cp, pbuf)) == NULL)
						goto oops;
					addgroup(pp);
					break;
			       case '|':	/* pipe through a program */
					cp = advance(cp);
					if ((pp=aliasparse(cp,pbuf)) == NULL)
						goto oops;
					addprgm(pp);
					break;
				default:        /* Simple list */
					for(;;) {
						insert(pp);
						if(!(cp = advance(line)) ||
						   !(pp = aliasparse(cp, pbuf)))
							break;
					}
				}
				break;
			}
		}
	}
}





addfile(file)
	char *file;
{
	register char *cp, *pp;
	char line[128], pbuf[64];
	FILE *f;
#ifdef DEBUG
	if (Debug >3) printf("addfile(%s)\n", file);          
#endif
	if((f = fopen(file, "r")) == NULL) {
		fprintf(stderr, "Can't open ");
		perror(file);
		exit(EX_OSFILE);
	}
	while(fgets(line, sizeof line, f)) {
		cp = line;
		while(pp = aliasparse(cp, pbuf)) {
			insert(pp);
			cp = advance(cp);
		}
	}
	fclose(f);
}

addgroup(group)
	char *group;
{
	register char *cp, *pp;
	int found = 0;
	char line[128], pbuf[64], *rindex();
	FILE *f;
#ifdef DEBUG
	if(Debug>3)printf("addgroup(%s)\n", group);        
#endif
	if((f = fopen(GROUP, "r")) == NULL) {
		fprintf(stderr, "Can't open ");
		perror(GROUP);
		exit(EX_OSFILE);
	}
	while(fgets(line, sizeof line, f)) {
		pp = aliasparse(line, pbuf);
		if(strcmp(pp, group) == 0) {
			cp = rindex(line, ':');
			while(pp = aliasparse(cp, pbuf)) {
				insert(pp);
				cp = advance(cp);
			}
			found++;
		}
	}
	if(!found) {
		fprintf(stderr, "Group: %s non-existent\n", group);
		exit(EX_DATAERR);
	}
	fclose(f);
}

addprgm(name)
char *name;
{
	register struct mailname *mp;
	char * getcpy();
	for(mp = &addrlist; mp->m_next; mp = mp->m_next)
		if(uleq(name, mp->m_next->m_name))
			return;         /* Don't insert existing name! */
	mp->m_next = (struct mailname *) malloc(sizeof *mp->m_next);
	mp = mp->m_next;
	mp->m_next = 0;
	mp->m_name = getcpy(name);
	mp->m_pipe = 1;
}	
remove(mp)              /* Remove NEXT from argument node! */
	register struct mailname *mp;
{
	register struct mailname *rp;

	rp = mp->m_next;
	mp->m_next = rp->m_next;
	cndfree(rp->m_name);
	cndfree(rp);
}
insert(name)
	char *name;
{
	register struct mailname *mp;
	char *getcpy();
#ifdef DEBUG
	if(Debug>3)  printf("insert(%s)\n", name);   
#endif
	for(mp = &addrlist; mp->m_next; mp = mp->m_next)
		if(uleq(name, mp->m_next->m_name))
			return;         /* Don't insert existing name! */
	mp->m_next = (struct mailname *) malloc(sizeof *mp->m_next);
	mp = mp->m_next;
	mp->m_next = 0;
	mp->m_pipe=0;
	mp->m_name = getcpy(name);
}

aleq(string, aliasent)
	register char *string, *aliasent;
{
	register int c;

	while(c = *string++)
		if(*aliasent == '*')
			return 1;
		else if((c|040) != (*aliasent|040))
			return(0);
		else
			aliasent++;
	return(*aliasent == 0 | *aliasent == '*');
}

forward()
{

	FILE * fp;
	struct passwd * pwd;
	struct mailname *lp;
	char forwardfile[BUFSIZ];
	extern struct passwd * getpwnam ();

	for (lp = addrlist.m_next;lp;lp=lp->m_next){
	if (index(lp->m_name,'!')) continue; /* not local */
	if (index(lp->m_name,'@')) continue; /* ditto */
	if (index(lp->m_name,'%')) continue; /* ditto */
	if (index(lp->m_name,'/')) continue; /* filename */
	if ((pwd = getpwnam(lp->m_name)) == NULL) continue;
	sprintf(forwardfile,"%s/.forward",pwd->pw_dir);
	if((fp=fopen(forwardfile,"r")) != NULL){
			strcpy(lp->m_name,"");
			addfile(forwardfile);
		fclose(fp);
		}
	}
}
#endif


/* add names to the address list */


add(name, list)
char *name;
struct mailname *list;
{
	register struct mailname *mp;
	char *getcpy();

	for(mp = list; mp->m_next; mp = mp->m_next)
		;
	mp->m_next = (struct mailname *) malloc(sizeof *mp->m_next);
	mp = mp->m_next;
	mp->m_next = 0;
	mp->m_pipe = 0;
	mp->m_name = getcpy(name);
}

char *getcpy(str)
{
	register char *cp;

	cp = (char *) malloc(strlen(str) + 1);
	strcpy(cp, str);
	return(cp);
}







!STUFFY!FUNK!
echo Extracting uux.c
cat >uux.c <<'!STUFFY!FUNK!'
/*
 * a "fake" uux to replace the realone to allow uumail to intercept
 * mail at sites that mail not be able to recompile their mailers
 * Called via "uux - system!rmail user" from, normally, /bin/mail.
***************************************************************************
This work in its current form is Copyright 1986 Stan Barber
with the exception of opath, gethostname and the original getpath which
as far as I know are in the Public Domain. This software may be distributed
freely as long as no profit is made from such distribution and this notice
is reproducted in whole.
***************************************************************************
This software is provided on an "as is" basis with no guarantee of 
usefulness or correctness of operation for any purpose, intended or
otherwise. The author is in no way liable for this software's performance
or any damage it may cause to any data of any kind anywhere.
***************************************************************************
 * $Log:	uux.c,v $
 * Revision 4.0  86/11/17  16:02:42  sob
 * Release version 4.0 -- uumail
 * 
 * Revision 3.0  86/03/14  12:05:06  sob
 * Release of 3/15/86 --- 3rd Release
 * 
 * Revision 1.6  86/03/14  11:57:51  sob
 * 
 * 
 * Revision 1.5  86/03/11  11:29:17  sob
 * Added Copyright Notice
 * 
 * Revision 1.4  86/02/17  18:07:48  sob
 * Moved REALUUX and UUMAIL definitions to the makefile
 * 
 * Revision 1.3  86/02/17  17:58:15  sob
 * Small syntax problem
 * 
 * Revision 1.2  86/02/17  17:55:45  sob
 * Corrected to remove parens from destbuf.
 * 
 * Revision 1.1  86/02/17  17:45:10  sob
 * Initial revision
 * 
 *
 */

#define _DEFINE

#include "uuconf.h"
static char rcsid[] = "$Header: uux.c,v 4.0 86/11/17 16:02:42 sob Exp $";

extern FILE *popen();
extern char *index();
extern struct passwd *getpwnam();

char sysbuf[BUFSIZ];
char destbuf[BUFSIZ];

main(argc, argv)
int argc;
char **argv;
{
	char *command;
	struct passwd *pwd;
	char cmd[BUFSIZ];
	char *system = sysbuf;
	char **psystem = &system;
	FILE *netf;
	int c;

	if ((argc != 4) || strcmp("-", argv[1]))  /* look for form 
							of uux command */
		realuux(argv);	

	strcpy(sysbuf, argv[2]);	/* save destination system */

	if ((command = index(sysbuf, '!')) == NULL)
		realuux(argv); 	
	*command++ = 0;
	if (strcmp("rmail", command))	/* look for rmail in command */
		realuux(argv);		

	mystrcpy(destbuf, argv[3]);      /*save destination path */
					/* but get rid of parens */
	/* become UUCP */
	setpwent();
	pwd = getpwnam("uucp");
	if (pwd == NULL) {
		fprintf(stderr, "Can't suid to \"uucp\" in %s\n", REALUUX);
		exit(1);	/* sigh */
	}
	endpwent();
	setuid(pwd->pw_uid);

	/* send the mail to uumail */
	sprintf(cmd, "uumail %s!%s", UUMAIL, sysbuf,destbuf);
	if ((netf = popen(cmd, "w")) == NULL)
		exit(EX_TEMPFAIL);	/* failure */

	/* send the actual mail */
	while ((c = getchar()) != EOF)
		putc(c, netf);
	fflush(netf);
	exit (pclose(netf)?1:0);	/* causes mail to do the right thing */
}

realuux(argv)
char **argv;
{
	int pid, sts;

	/* running suid root.  become us again */
	setuid(getuid());

        if ((pid = fork()) == -1) {
                fprintf(stderr, "uux: can't create proc for %s\n",REALUUX);
                exit(1);
        }
        if (pid) {
                while (wait(&sts) != pid) {
                        if (wait(&sts)==-1)
                                exit(1);
                }
                exit(sts?1:0);
        }
	execv(REALUUX, argv);
	fprintf(stderr, "uux: can't exec %s\n",REALUUX);
	exit (1);
}

/* remove parens for t and put what's left in s */
mystrcpy(s,t)
char * s, *t;
{
	int x;
	while (x = *t++){
		if ((x == '(') || (x == ')'))
			continue;
		*s++ = x;
	}
	
	*s = x;
}
!STUFFY!FUNK!
echo Extracting rmail.c
cat >rmail.c <<'!STUFFY!FUNK!'
#ifndef lint
static char rcsid[]="$Header: rmail.c,v 4.0 86/11/17 16:02:32 sob Exp $";

#endif

/*
**  RMAIL -- UUCP mail server.
**
**	This program reads the >From ... remote from ... lines that
**	UUCP is so fond of and turns them into something reasonable.
**	It calls uumail giving it a -f option built from these
**	lines.
***************************************************************************
This work in its current form is Copyright 1986 Stan Barber
with the exception of opath, gethostname and the original getpath which
as far as I know are in the Public Domain. This software may be distributed
freely as long as no profit is made from such distribution and this notice
is reproducted in whole.
***************************************************************************
This software is provided on an "as is" basis with no guarantee of 
usefulness or correctness of operation for any purpose, intended or
otherwise. The author is in no way liable for this software's performance
or any damage it may cause to any data of any kind anywhere.
***************************************************************************
*/

#define _DEFINE

#include "uuconf.h"
extern FILE *popen();
extern char *index();
extern char *rindex();

main(argc, argv)
	char **argv;
{
	FILE *out;	/* output to mail handler */
	char lbuf[512];	/* one line of the message */
	char from[512];	/* accumulated path of sender */
	char ufrom[64];	/* user on remote system */
	char sys[64];	/* a system in path */
	char junk[512];	/* scratchpad */
	char cmd[2000];
	register char *cp;
	register char *uf;	/* ptr into ufrom */
	int i;

# ifdef DEBUG
	if (argc > 1 && strcmp(argv[1], "-T") == 0)
	{
		Debug = TRUE;
		argc--;
		argv++;
	}
# endif DEBUG

	if (argc < 2)
	{
		fprintf(stderr, "Usage: rmail user ...\n");
		exit(EX_USAGE);
	}

	(void) strcpy(from, "");
	(void) strcpy(ufrom, "/dev/null");
	uf = NULL;

	for (;;)
	{
		(void) fgets(lbuf, sizeof lbuf, stdin);
		if (strncmp(lbuf, "From ", 5) != 0 && strncmp(lbuf, ">From ", 6) != 0)
			break;
		(void) sscanf(lbuf, "%s %s", junk, ufrom);
		cp = lbuf;
		uf = ufrom;
		for (;;)
		{
			cp = index(cp+1, 'r');
			if (cp == NULL)
			{
				register char *p = rindex(uf, '!');

				if (p != NULL)
				{
					*p = '\0';
					if (uf != NULL) 
						(void) strcpy(sys, uf);
					else
						gethostname(sys,32);
					uf = p + 1;
					break;
				}
				cp = "remote from somewhere";
			}
#ifdef DEBUG
			if (Debug)
				printf("cp='%s'\n", cp);
#endif
			if (strncmp(cp, "remote from ", 12)==0)
				break;
		}
		if (cp != NULL)
			(void) sscanf(cp, "remote from %s", sys);
		(void) strcat(from, sys);
		(void) strcat(from, "!");
#ifdef DEBUG
		if (Debug)
			printf("ufrom='%s', sys='%s', from now '%s'\n", uf, sys, from);
#endif
	}
	if (uf != NULL)
		(void) strcat(from, uf);

/*	(void) sprintf(cmd, "exec %s -oMrUUCP -em -f%s", MAILER, from);*/
	if (from[0] == '\0')
		(void) sprintf(cmd, "exec %s", MAILER);
	else
		(void) sprintf(cmd, "exec %s -f%s", MAILER, from);
	while (*++argv != NULL)
	{
		(void) strcat(cmd, " '");
		if (**argv == '(')
			(void) strncat(cmd, *argv + 1, strlen(*argv) - 2);
		else
			(void) strcat(cmd, *argv);
		(void) strcat(cmd, "'");
	}
#ifdef DEBUG
	if (Debug)
		printf("cmd='%s'\n", cmd);
#endif
	out = popen(cmd, "w");
	fputs(lbuf, out);
	while (fgets(lbuf, sizeof lbuf, stdin))
		fputs(lbuf, out);
	i = pclose(out);
	if ((i & 0377) != 0)
	{
		fprintf(stderr, "pclose: status 0%o\n", i);
		exit(EX_OSERR);
	}

	exit((i >> 8) & 0377);
}
!STUFFY!FUNK!
echo Extracting uumail.8.SH
cat >uumail.8.SH <<'!STUFFY!FUNK!'
case $CONFIG in
   '') . config.sh ;;
esac
$echo "Extracting uumail.8 (with variable substitutions)"
cat > uumail.8 <<!GROK!THIS!
.RL "Baylor College of Medicine"
.TH UUMAIL 8
.fi
.ad b
.SH NAME
uumail \- rewrite address & route mail using uucpmap database 
.br
uupath \- print the uucp path to a host
.SH SYNOPSIS
.B uumail [ \fIoptions\fR ] \fIaddress\fR
.br
.B uupath \fIhostname\fR
.SH DESCRIPTION
.B Uumail
is designed to be used as a mail delivery program to correctly
route mail over uucp connections.
.SS Standard Options
.IP "-f\fIaddress\fR" 16
The
.I -f
option sets the address of the sender of the mail. If this flag 
is not used, the sender will be established by usings environmental variables
(like 
.B LOGNAME
and
.B USER
) or using getlogin(3).
.IP "-om" 16
The
.I -om
option causes the mail to also be sent to the sender of the message.
.IP "-oc" 16
The 
.I  -oc
option causes
.B uucico 
to be started immediately after queuing the mail.
The default just queues the mail.
.IP "-N" 16
The -N option stops the use of
.B uuname
to determine neighboring hosts. Only the information in the database
will be used for routing information.
.IP "-h" 16
The -h option causes no From_ line to be added to the beginning of file.
This is useful when uumail is being used as a mailer for sendmail(8).
.SS Compile-time Configurable Options
!GROK!THIS!
if test X$debug = Xdefine
then
cat >>uumail.8 <<!ADD!THIS!
.IP "-d[1-6]" 16
The
.I -d 
option turns on the limited debugging facility built into the
mailer.  In debug mode, the mailer does not actually mail anything, but
tells you what it would do if it did do it. The level of debugging can
be set by following the 
.I -d
flag with a number between 1 and 6.
!ADD!THIS!
fi
cat >>uumail.8 <<!EVEN!MORE!
.IP "-g[A-Z]" 16
If your 
.B uux(1)
supports grading of transactions, the
.I -g 
option can be used to set the
grade of this mail. A grade of \fIC\fR is used by default.
!EVEN!MORE!
if test X$noalias = X
then
cat >>uumail.8 <<!ADD!ALIAS!
.IP "-n" 16
The
.I -n
option will prohibit the use of infomation provided by the system alias
file. Information in users'
.I .forward
files will still be utilized if present.
!ADD!ALIAS!
fi
cat >>uumail.8<<!MORE!STUFF!

.SS Arguments
.IP \fIhost!user\fR 16
where host is a system node name on the network and user is the login
name of the addressee.
.IP \fIuser@host.domain\fR
same as above with the addition of a domain specifier like
.B .ARPA, .GOV, .COM, .EDU
etc.
.SH FILES
!MORE!STUFF!
if test Xnoalias = X
then
cat >> uumail.8<<!ADD!MORE!ALIAS!
.IP "$aliases" 20'
System-wide alias file
.IP ".forward" 20
Individual user's mail forwarding file
!ADD!MORE!ALIAS!
fi
cat >>uumail.8 <<!OK!HERE!
.IP "$database{.pag|.dir}" 20
Path file produced by pathalias.
!OK!HERE!
if test X$log = Xdefine
then
cat >>uumail.8<<!ADD!MORE!LOG!
.IP "$logfile" 20
Log of uumail activity.
!ADD!MORE!LOG!
fi
cat >>uumail.8 <<!THE!END!
.SH "SEE ALSO"
pathalias(1), address(1), mh(1), sendmail(8), uux(1), uuname(1)
.br
.B RFC 822 "Standard for the Format of ARPA Internet Text Messages"
.br
.B RFC 976 "UUCP Mail Interchange Format Standard"

.SH AUTHORS
.br
Stan Barber, Baylor College of Medicine
.br
Getpath routine by John Donnelly, University of Illinois
.br
Gethostname routine by Peter Honeyman, Princeton
.br
Resolve routine written by the UUCP project
.br
Aliasing scheme borrowed from the MH mail handling system
!THE!END!

!STUFFY!FUNK!
echo Extracting address.1.SH
cat >address.1.SH <<'!STUFFY!FUNK!'
case $CONFIG in
   '') . config.sh ;;
esac
$echo "Extracting address.1 (with variable substitutions)"
$rm -f address.1
cat >address.1<<!GROK!THIS!
.RL "Baylor College of Medicine"
.TH ADDRESS 1
.SH NAME
address - display the path generated by \fBuumail\fR for an
RFC822/RFC976-format address.
.SH SYNOPSIS
address rfc-address [ ... ]
.SH DESCRIPTION
This program allows you to check the UUCP mail routing path that will
be generated by the UUCP mailer \fBuumail\fR if you specify an
RFC822/RFC976-format address \fBrfc-address\fR in the ``To:'' field of the mail header.
For each RFC-style address on the command line, \fBaddress\fR echoes the
address to the standard output, followed by a colon, followed by
the UUCP address that will be used to send the message to that address.

.SH "ADDRESS FORMAT"
Briefly, the RFC822/RFC976-format address is of the form
.nf
.sp 1
	<localaddress>@<hostname>.<domain>
.sp 1
.fi
where <hostname> is the name of the system you are sending the message
to, <domain> is a modifier for <hostname> identifying the network in
which the address is to be interpreted (EDU, COM, GOV, ORG, NET, etc.);
and <localaddress> is an address string to be interpreted on the host
machine.

On our system, the presently
valid <domains>s are EDU, COM, GOV, ORG, NET, UUCP, and ARPA.
Omitting
the <domain> causes the network to default to UUCP.  The <hostname>
should be the name of a remote machine to which the message is
directed; see \fI$database\fR for a list of all
known UUCP hostnames.  It is \fInot\fR necessary to specify a UUCP pathname
when using this format; the pathname is automatically determined for you
and substituted into the address before mailing.  The selected pathname
is determined using the \fBpathalias\fR database, and is supposed
to be optimal, taking into consideration information provided by
each site about how often they send mail out, etc.

.SH EXAMPLES
.HP 5
joe
.br
The message is sent to the user ``joe'' on the local system.
.HP 5
joe@ucbvax
.br
The message is sent to joe on the UUCP system named ``ucbvax''; this
address is automatically translated to a proper (and ostensibly
optimal) UUCP path.
.HP 5
joe@ucbvax.UUCP
.br
Same as joe@ucbvax
.HP 5
joe@ucbvax.ARPA
.br
The message is addressed to joe at ucbvax, using the ARPA network.
The message will be routed to the ARPAnet via a UUCP-ARPAnet gateway.
.HP 5
ucbvax!multics.mit.edu!joe
.br
The message is sent to ucbvax, who then uses the address
joe@multics.mit.edu to send the message on to multics.mit.edu via the
ARPAnet.  Since ucbvax is on the arpanet, this address will work correctly
(as long as there is someone named joe on the MIT multics machine).
.HP 5
ucbvax!multics.mit.edu!vanderbilt.mailnet!joe
.br
The message is sent via UUCP to ucbvax, who then sends the message
to multics.mit.edu via the arpanet; multics.mit.edu then sends the message
to joe@vanderbilt via MAILNET.  Since the above machines each have access
to the networks named in the address, this address will work correctly.
.SH FILES
$database - Pathalias database
.SH "SEE ALSO"
uupath(1), uumail(8), pathalias(1)
.br
.B RFC 822 "Standard for the Format of ARPA Internet Text Messages"
.br
.B RFC 976 "UUCP Mail Interchange Format Standard"
.SH AUTHOR
Stan Barber, Baylor College of Medicine
!GROK!THIS!

!STUFFY!FUNK!
echo Extracting deadletter.c
cat >deadletter.c <<'!STUFFY!FUNK!'
#ifndef lint
static char rcsid[] = "$Header: deadletter.c,v 4.0 86/11/17 16:02:11 sob Exp $";
#endif
/**************************************************************************
This work in its current form is Copyright 1986 Stan Barber
with the exception of resolve, gethostname and the original getpath which
as far as I know are in the Public Domain. This software may be distributed
freely as long as no profit is made from such distribution and this notice
is reproducted in whole.
***************************************************************************
This software is provided on an "as is" basis with no guarantee of 
usefulness or correctness of operation for any purpose, intended or
otherwise. The author is in no way liable for this software's performance
or any damage it may cause to any data of any kind anywhere.
***************************************************************************/
/* attempt to return dead letter */
/* $Log:	deadletter.c,v $
 * Revision 4.0  86/11/17  16:02:11  sob
 * Release version 4.0 -- uumail
 * 
 * Revision 1.2  86/10/21  15:32:50  sob
 * Added RETURNMAIL
 * 
 * Revision 1.1  86/09/04  17:53:44  sob
 * Initial revision
 * 
 *
 */
#include "uuconf.h"
EXTERN char progname[];
char letter[] = "/usr/tmp/.rlXXXXXX";

deadletter(retlet, here,reason,host)
FILE *retlet;
char * host;
int here,reason;
{

	int i;
	long iop;
	struct tm *bp, *localtime();
	FILE * letf;
	char * date, *asctime();

	if(getlogin() != NULL) syserr("Letter failed....returned to sender\n");
#ifdef RETURNMAIL
    /*
     * make a place to create the return letter
     */
	mktemp(letter);
	unlink(letter);
	if((letf = fopen(letter, "w")) == NULL){
		fprintf(stderr, "%s : can't open %s for writing\n", progname,letter);
		exit(EX_CANTCREAT);
	}
	/*
	 * Format time
	 */
	time(&iop);
	bp = localtime(&iop);
	date = asctime(bp);
	/* build the return header */
	fprintf(letf,"From %s!%s %.16s %.4s remote from %s\n",
		Myname,MAILERDAEMON, date, date+20, Myname);
	fprintf(letf,"From: %s@%s (UUMAIL ROUTER)\nTo: %s\n",MAILERDAEMON,Myname,from);
	fprintf(letf,"Subject: Failed Mail\nMessage-Id: <%d.%d.%s@%s>\n\n",
		getpid(),time(0),MAILERDAEMON,Myname);
#else
	letf = stderr;
#endif

 	fprintf(letf,"Your mail failed to reach its destination because:\n");
	switch(reason){
		case EX_NOHOST:
			fprintf(letf,"The path (%s) cannot be resolved.\n",host);
			break;
		case EX_OSERR:
			fprintf(letf,"An Operating System error occurred while processing your\nmail. Please resend.\n");
			break;
		default:
			fprintf(letf,"An unknown error (code = %d) occured.\n",reason);
			break;
		}
#ifdef RETURNMAIL
		fprintf(letf,"Your returned mail follows:\n");
		fprintf(letf,"-------------------------------------------\n");
		while (fgets(lbuf, sizeof lbuf, retlet))
			{
				fprintf(letf,"\t");
				fputs(lbuf, letf);
			}


			     /* return the mail */

		fclose(letf);
		sprintf(lbuf,"%s %s < %s",MAILER,from,letter);
#ifdef DEBUG
		if (Debug)
			fprintf(stderr,"Command is %s\n",lbuf);
		else
		{
#endif
			system(lbuf);
			unlink(letter);
#ifdef DEBUG
		}
#endif
#endif
}

!STUFFY!FUNK!
echo Extracting Makefile.SH
cat >Makefile.SH <<'!STUFFY!FUNK!'
case $CONFIG in
    '') . config.sh ;;
esac
echo "Extracting Makefile (with variable substitutions)"
cat >Makefile <<!GROK!THIS!
####################################################################
# makefile for uumail & uupath
# program to integrate with pathalias created uucpmap databases
# programs originally developed by Jeff Donnelly
# updated to use pathalias database by Stan Barber
# $Header: Makefile.SH,v 1.2 86/12/15 13:27:53 sob Exp $
#***************************************************************************
# This work in its current form is Copyright 1986 Stan Barber
# with the exception of resolve, gethostname and the original getpath which
# as far as I know are in the Public Domain. This software may be distributed
# freely as long as no profit is made from such distribution and this notice
# is reproducted in whole.
# ***************************************************************************
# 
###############################################################
.SUFFIXES: .c,v .h,v

CC= $cc

CP= $cp

RM= $rm

LIBS= $libdbm $ndirlib

BINDIR=$bindir

UUCPDIR=$lib

MANDIR=$mansrc

UUMAIL=$(UUCPDIR)/uumail

REALUUX=/usr/bin/uux

CFLAGS=-O -DUUMAIL='"$(UUMAIL)"' -DREALUUX='"$(REALUUX)"'
!GROK!THIS!
cat >> Makefile <<'!NO!SUBS!'
SHELL=/bin/sh

.c,v.c:
	co -q $*.c

.h,v.h:
	co -q $*.h

all: uumail rmail address uux

cobj=getpath.o resolve.o

uobj= uumail.o gethostnam.o alias.o deadletter.o $(cobj)

robj= rmail.o gethostnam.o

aobj= address.o $(cobj)

obj= $(aobj) $(uobj) $(robj)

uumail: $(uobj)
	$(CC) $(CFLAGS) $(uobj) -o uumail $(LIBS)

address:$(aobj)
	$(CC) $(CFLAGS) $(aobj) -o address $(LIBS)

rmail: $(robj)
	$(CC) $(CFLAGS) $(robj) -o rmail $(LIBS)

install: uumail address palias
	$(CP) address $(BINDIR)
	$(CP) uumail $(UUCPDIR)
	$(CP) uumail.8 $(MANDIR)/man8
	$(CP) address.1 $(MANDIR)/man1
	ln $(MANDIR)/man8/uumail.8 $(MANDIR)/man1/uupath.1
	if [ ! -r $(UUCPDIR)/palias ]; then cp palias $(UUCPDIR); fi
	@echo "To install rmail in place of the current rmail, type"
	@echo "make mailer"
	@echo "To intercept uux commands, you need to be sure"
	@echo "that you correctly specified REALUUX in makefile"
	@echo "Then type make fakeuux"
	ln $(UUCPDIR)/uumail $(BINDIR)/uupath

mailer: rmail
	make install
	$(RM) -rf /bin/rmail
	$(CP) rmail /bin/rmail
	
fakeuux: uux
	make install
	$(CP) /usr/bin/uux $(REALUUX)
	$(CP) uux /usr/bin/uux
	chmod 6755 /usr/bin/uux

lint:
	lint $(CFLAGS) getpath.c uumail.c gethostnam.c resolve.c alias.c

clean: 
	$(RM) -f *.o uumail address rmail uux

doc: uumail.8 address.1
	nroff -man uumail.8 >uumail.cat; nroff -man address.1 >address.cat


# AUTOMATICALLY GENERATED MAKE DEPENDENCIES--PUT NOTHING BELOW THIS LINE
$(obj):
	@ echo "You haven't done a "'"make depend" yet!'; exit 1
!NO!SUBS!
$eunicefix Makefile
!STUFFY!FUNK!
echo Extracting Alias.Design
cat >Alias.Design <<'!STUFFY!FUNK!'
This is the format for the Alias file used in uumail. It is derived from
the Rand Mail Handler system (MH).
Stan Barber 05/13/86
***************************************************************************
This work in its current form is Copyright 1986 Stan Barber
with the exception of resolve, gethostname and the original getpath which
as far as I know are in the Public Domain. This software may be distributed
freely as long as no profit is made from such distribution and this notice
is reproducted in whole.
***************************************************************************

The Alias file for mail delivery is the file

	/usr/lib/uucp/Aliases

Each line of the alias file has the format:

match : alias

Where:

	alias       :=  simple-list
		    |   "<" alias-file
		    |   "=" UNIX-group
		    |   "|" program-name

	simple-list :=  simple-name
		    |   simple-list, simple-name

Alias-file and program-name are fully qualified UNIX file names.
UNIX-group is a group name from /etc/group.  A simple-name is a 
local user login name, including only alphanumerics, `.' and `-'. 
Throughout this file case is ignored, except for alias-file and
program-name.

In match, a trailing * on a name will match anything. (See example
below.)

The procedure for mail aliasing is:

1) Build a list of all addresses from the message to be
   delivered, eliminating duplicates.

2) For each line in the alias file, compare "match" against all
   of the existing addresses.  If a match, remove the matched
   name from the address list, and add each new alias name to the
   address list if it is not already on the list.

3) If output from uumail is to be sent to some other program, the pipe
   ("|") alias will cause output to be directly sent to that program instead
   of via mail.

Since the alias file is read line by line, forward references
work, but backward references are not recognized, thus, there is
no recursion.

E.g.:

Borden: bruce
Bruce: bsb
Wharman: mike
ASRL: bsb, mike, obrien, giarla
UNIX-committee: < /usr/people/unix-committee
System: = sys
rnews: | /usr/lib/news/recnews
   ...

In the "unix-committee" example, the file "/usr/people/unix-
committee" contains one simple-name, or a list of comma separated
simple-names.  A new-line will be treated as a blank in this
file, s.a.

	foo, fie,
	fum, fiddle

In the "system" case, the names from the group "sys" will be used
as the expanded name list.

Additional note: If you need to use one of the "special" characters
in an address (e.g. %@\|) then you can escape it with a blackslash
(like you would do in csh).
[This modification provided by tp@ndm20.UUCP.]

Originally by
Bruce Borden    October 1979
!STUFFY!FUNK!
echo Extracting makedepend.SH
cat >makedepend.SH <<'!STUFFY!FUNK!'
case $CONFIG in
    '') . config.sh ;;
esac
echo "Extracting makedepend (with variable substitutions)"
$spitshell >makedepend <<!GROK!THIS!
$startsh
# $Header: makedepend.SH,v 4.3.1.2 85/05/13 15:53:42 lwall Exp $
#
# $Log:	makedepend.SH,v $
# Revision 4.3.1.2  85/05/13  15:53:42  lwall
# Made cpp look in /usr/local/include too.
# 
# Revision 4.3.1.1  85/05/10  11:35:10  lwall
# Branch for patches.
# 
# Revision 4.3  85/05/01  11:42:26  lwall
# Baseline for release with 4.3bsd.
# 

export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)

$cat /dev/null >.deptmp
$rm -f X*.c
for file in *.c; do
    filebase=\`basename \$file .c\`
    $echo "Finding dependencies for \$filebase.o."
    $sed -n <\$file >X\$file \\
	-e "/^\${filebase}_init(/q" \\
	-e '/^#/{' \\
	-e 's|/\*.*$||' \\
	-e p \\
	-e '}'
    $cpp -I/usr/local/include X\$file | $sed  \\
	-e '/^# *[0-9]/!d' \\
	-e 's/^.*"\(.*\)".*\$/'\$filebase'.o: \1/' \\
	-e 's|: \./|: |' \\
	-e 's|: X|: |' | \\
	$uniq | $sort | $uniq >> .deptmp
done

for file in *.SH; do
    $echo \`basename \$file .SH\`: \$file config.sh \; /bin/sh \$file >> .deptmp
done

$sed <Makefile >Makefile.new -e '1,/^# AUTOMATICALLY/!d'

if $test -s .deptmp; then
    echo "Updating Makefile..."
    echo "# If this runs make out of memory, delete /usr/include lines." >>Makefile.new
    $cat .deptmp >>Makefile.new
else
    $echo "You don't seem to have a proper C preprocessor.  Using grep instead."
    $egrep '^#include ' *.c *.h >.deptmp
    echo "Updating Makefile..."
    <.deptmp $sed -n 's|c:#include "\(.*\)".*\$\$|o: \1|p' >> Makefile.new
    <.deptmp $sed -n 's|c:#include <\(.*\)>.*\$\$|o: /usr/include/\1|p' >> Makefile.new
    <.deptmp $sed -n 's|h:#include "\(.*\)".*\$\$|h: \1|p' >> Makefile.new
    <.deptmp $sed -n 's|h:#include <\(.*\)>.*\$\$|h: /usr/include/\1|p' >> Makefile.new
fi
$mv Makefile Makefile.old
$mv Makefile.new Makefile
$echo "# WARNING: Put nothing here or make depend will gobble it up!" >> Makefile
rm .deptmp X*.c

!GROK!THIS!
$eunicefix makedepend
chmod 755 makedepend
!STUFFY!FUNK!
echo Extracting ndir.c
cat >ndir.c <<'!STUFFY!FUNK!'
/* $Header: ndir.c,v 4.0 86/11/17 16:02:25 sob Exp $
 *
 * $Log:	ndir.c,v $
 * Revision 4.0  86/11/17  16:02:25  sob
 * Release version 4.0 -- uumail
 * 
 * Revision 1.1  86/10/21  15:00:28  sob
 * Initial revision
 * 
 * 
 */

#include "uuconf.h"
#include "ndir.h"

#ifdef USENDIR
/*
 * support for Berkeley directory reading routine on a V7 file system
 */

/*
 * open a directory.
 */
DIR *
opendir(name)
char *name;
{
	register DIR *dirp;
	register int fd;
	char * malloc();

	if ((fd = open(name, 0)) == -1)
		return NULL;
	if ((dirp = (DIR *)malloc(sizeof(DIR))) == NULL) {
		close (fd);
		return NULL;
	}
	dirp->dd_fd = fd;
	dirp->dd_loc = 0;
	return dirp;
}

/*
 * read an old style directory entry and present it as a new one
 */
#ifndef pyr
#define	ODIRSIZ	14

struct	olddirect {
	ino_t	od_ino;
	char	od_name[ODIRSIZ];
};
#else	an Pyramid in the ATT universe
#define	ODIRSIZ	248

struct	olddirect {
	long	od_ino;
	short	od_fill1, od_fill2;
	char	od_name[ODIRSIZ];
};
#endif

/*
 * get next entry in a directory.
 */
struct direct *
readdir(dirp)
register DIR *dirp;
{
	register struct olddirect *dp;
	static struct direct dir;

	for (;;) {
		if (dirp->dd_loc == 0) {
			dirp->dd_size = read(dirp->dd_fd, dirp->dd_buf,
			    DIRBLKSIZ);
			if (dirp->dd_size <= 0)
				return NULL;
		}
		if (dirp->dd_loc >= dirp->dd_size) {
			dirp->dd_loc = 0;
			continue;
		}
		dp = (struct olddirect *)(dirp->dd_buf + dirp->dd_loc);
		dirp->dd_loc += sizeof(struct olddirect);
		if (dp->od_ino == 0)
			continue;
		dir.d_ino = dp->od_ino;
		strncpy(dir.d_name, dp->od_name, ODIRSIZ);
		dir.d_name[ODIRSIZ] = '\0'; /* insure null termination */
		dir.d_namlen = strlen(dir.d_name);
		dir.d_reclen = DIRSIZ(&dir);
		return (&dir);
	}
}

/*
 * close a directory.
 */
void
closedir(dirp)
register DIR *dirp;
{
	close(dirp->dd_fd);
	dirp->dd_fd = -1;
	dirp->dd_loc = 0;
	free(dirp);
}
#endif USENDIR
!STUFFY!FUNK!
echo Extracting address.c
cat >address.c <<'!STUFFY!FUNK!'
/*
 * address - run opath to see what a translated RFC822 address will come
 * out as.
 *
 * By E. Roskos 1/16/85
 * $Log:	address.c,v $
 * Revision 4.0  86/11/17  16:01:45  sob
 * Release version 4.0 -- uumail
 * 
 * Revision 3.3  86/10/01  15:48:13  sob
 * removed references to now-defunct CONFIGFILE
 * 
 * Revision 3.2  86/07/11  17:57:29  sob
 * Checkpoint in adaptation for resolve
 * 
 * Revision 3.1  86/06/10  16:47:56  sob
 * uswitch per complaint.
 * Stan
 * 
 * Revision 3.0  86/03/14  12:04:19  sob
 * Release of 3/15/86 --- 3rd Release
 * 
 * Revision 1.4  85/12/26  15:47:45  sob
 * Added modifications suggested by terry%owl@rand-unix.ARPA
 * 
 * Revision 1.3  85/11/24  14:50:01  sob
 * Added corrections provided by regina!mark
 * 
 * Revision 1.2  85/09/16  18:31:53  sob
 * Added DEBUG flag
 * 
 * Revision 1.1  85/09/16  17:50:24  sob
 * Initial revision
 * 
 */
#define _DEFINE
#include "uuconf.h"

static char rcsid[] = "$Header: address.c,v 4.0 86/11/17 16:01:45 sob Exp $";

EXTERN char *paths;
char *opath(), *oupath();
int Debug;

main(argc,argv)
int argc;
char **argv;
{
char *p;
char user[BUFSIZ];
char domain[BUFSIZ];
paths = DATABASE;
handle = ALL;
	if (argc < 2)
	{
		fprintf(stderr,"usage: %s rfcaddress [...]\n",
			argv[0]);
		exit(1);
	}

	while (--argc)
	{
		p = *++argv;
		if (*p=='-')
		{
			switch(*++p)
			{
			case 'd': Debug++;
			          continue;
			default:  printf("unknown switch: %c\n",*p);
				  continue;
			}
		}
	        resolve(p, user, domain);
		printf("%s: ",p);

        	if(domain[0] == '\0')
                	printf("%s\n", user);
	        else if(user[0] == '\0')
        	        printf("%s\n", domain);
	        else
        	        printf("%s!%s\n", user, domain);
	}

	exit(0);
}
!STUFFY!FUNK!
echo Extracting SYNOPSIS.txt
cat >SYNOPSIS.txt <<'!STUFFY!FUNK!'
I am happy to announe the release of uumail version 4.0, the pathalias
mailer. uumail is not a user-agent. It is intended to be used as a 
"back-end" to take the mail from user-agents and correctly route it
to its destination. Other examples of similiar programs include
sendmail, delivermail, and MMDF.

Features of uumail include:
	o RFC 976 Compliant (UUCP Mail Interface Format Standard)
	o uses pathalias(1) generated database in either text or dbm(3) format
	o MH-style aliasing support
	o sendmail-like .forward processing
	o can pipe mail output into other programs (e.g. uurec)
	o can be used under SYSTEM III, SYSTEM V or BSD
	o rn-like Configuration program for easy installation
	o returns undeliverable mail
	o usable as a mailer with sendmail(8)
	o does not require unix sources to install
	o dynamically determines uucp neighbors without modification
              of the pathalias database
        o functions as uupath(1) to return paths from pathalias(1) database
        o logging of traffic supported
        o supports 4.3 BSD UUCP graded transactions

No other programs are required to use uumail. Pathalias(1) is useful for
generating a full database, but a full database is not required to make
uumail useful.

Bug reports are welcome.

Stan Barber <sob@soma.bcm.tmc.edu>
({cuae2,seismo,rice}!soma!sob)
Cellular Neurophysiology Laboratory
Department of Neurology
Baylor Collge of Medicine
Houston, Texas 77030



!STUFFY!FUNK!
echo Extracting gethostnam.c
cat >gethostnam.c <<'!STUFFY!FUNK!'
#ifndef lint
static char	sccsid[] = "@(#)gethostnam.c	6.1 (down!honey) 85/01/21";
static char	rcsid[] = "$Header: gethostnam.c,v 6.5 86/10/07 15:14:09 sob Exp $";
#endif lint

#ifndef GETHOSTNAME
#include "uuconf.h"
#ifdef DOUNAME
#include <sys/utsname.h>
#endif

void
gethostname(name, len)
char	*name;
{
	FILE	*whoami, *fopen(), *popen();
	char	*ptr, *index();
#if defined(DOUNAME) && !defined(SYSTEMNAME)
	struct utsname utsn;
#endif

	*name = '\0';
#ifndef SYSTEMNAME
#ifdef DOUNAME
	if (uname(&utsn) != -1)
	{
		strcpy(name,utsn.nodename);
		len = strlen(name);
	  	return;
	}
#endif
#endif

#ifdef SYSTEMNAME
	/* try /usr/lib/uucp/SYSTEMNAME */
	if ((whoami = fopen("/usr/lib/uucp/SYSTEMNAME", "r")) != 0) {
		(void) fgets(name, len, whoami);
		(void) fclose(whoami);
		if ((ptr = index(name, '\n')) != 0)
			*ptr = '\0';
	}
	if (*name)
		return;
#endif
	/* try /usr/include/whoami.h */
	if ((whoami = fopen("/usr/include/whoami.h", "r")) != 0) {
		while (!feof(whoami)) {
			char	buf[100];

			if (fgets(buf, 100, whoami) == 0)
				break;
			if (sscanf(buf, "#define sysname \"%[^\"]\"", name))
				break;
		}
		(void) fclose(whoami);
		if (*name)
			return;
	}

	/* ask uucp */
	if ((whoami = popen("uuname -l", "r")) != 0) {
		(void) fgets(name, len, whoami);
		(void) pclose(whoami);
		if ((ptr = index(name, '\n')) != 0)
			*ptr = '\0';
	}
	if (*name)
		return;
	
	/* failure */
	return;
}
#endif GETHOSTNAME

!STUFFY!FUNK!
echo Extracting Sendmail
cat >Sendmail <<'!STUFFY!FUNK!'
***************************************************************************
This work in its current form is Copyright 1986 Stan Barber
with the exception of resolve, gethostname and the original getpath which
as far as I know are in the Public Domain. This software may be distributed
freely as long as no profit is made from such distribution and this notice
is reproducted in whole.
***************************************************************************

You probably don't want uumail to alias things, so be sure you answer that
question correctly when running Configure. You may not want uumail to
deal with internet addresses (although it really doen't matter) as well.

Then edit the mailer definition for uucp in /usr/lib/sendmail.cf
and change the P=/usr/bin/uux to be P=[where uumail is] (e.g.
/usr/lib/uucp/uumail).
Change the A= to A=uumail -h -f$g $h!$u

This will replace the uux execution with uumail. If you do this exactly, 
you will only need the pathalias generated database to be present for
uumail to work correctly.

There are more things you can do to make sendmail be smarter about
using uumail, but in general, this is not necessary since uumail
will return informative messges to sendmail ( and the user) if 
there is a failure.

If you would like to share your problems or ideas on interfacing
sendmail and uumail, I would appreciate hearing them.

Thanks.
Stan Barber
17 November 1986


!STUFFY!FUNK!
echo Extracting ndir.h
cat >ndir.h <<'!STUFFY!FUNK!'
/* $Header: ndir.h,v 4.3 85/05/01 11:43:00 lwall Exp $
 *
 * $Log:	ndir.h,v $
 * Revision 4.3  85/05/01  11:43:00  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

#ifdef LIBNDIR
#   include <ndir.h>
#else
#   ifndef USENDIR
#	include <sys/dir.h>
#   else

#ifndef DEV_BSIZE
#define	DEV_BSIZE	512
#endif
#define DIRBLKSIZ	DEV_BSIZE
#define	MAXNAMLEN	255

struct	direct {
	long	d_ino;			/* inode number of entry */
	short	d_reclen;		/* length of this record */
	short	d_namlen;		/* length of string in d_name */
	char	d_name[MAXNAMLEN + 1];	/* name must be no longer than this */
};

/*
 * The DIRSIZ macro gives the minimum record length which will hold
 * the directory entry.  This requires the amount of space in struct direct
 * without the d_name field, plus enough space for the name with a terminating
 * null byte (dp->d_namlen+1), rounded up to a 4 byte boundary.
 */
#undef DIRSIZ
#define DIRSIZ(dp) \
    ((sizeof (struct direct) - (MAXNAMLEN+1)) + (((dp)->d_namlen+1 + 3) &~ 3))

/*
 * Definitions for library routines operating on directories.
 */
typedef struct _dirdesc {
	int	dd_fd;
	long	dd_loc;
	long	dd_size;
	char	dd_buf[DIRBLKSIZ];
} DIR;
#ifndef NULL
#define NULL 0
#endif
extern	DIR *opendir();
extern	struct direct *readdir();
extern	long telldir();
extern	void seekdir();
#define rewinddir(dirp)	seekdir((dirp), (long)0)
extern	void closedir();

#   endif
#endif
!STUFFY!FUNK!
echo Extracting kitlists.c
cat >kitlists.c <<'!STUFFY!FUNK!'
/* $Header: kitlists.c,v 4.0 86/11/17 16:02:20 sob Exp $
 *
 * $Log:	kitlists.c,v $
 * Revision 4.0  86/11/17  16:02:20  sob
 * Release version 4.0 -- uumail
 * 
 * Revision 1.1  86/10/20  15:05:30  sob
 * Initial revision
 * 
 * Revision 4.3  85/05/01  11:42:08  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

#include <stdio.h>

#define MAXKIT 100
#define MAXKITSIZE 50000
#define KITOVERHEAD 700
#define FILEOVERHEAD 80
#define Nullch	(char *)0
long tot[MAXKIT];
FILE *outfp[MAXKIT];	/* of course, not this many file descriptors */

main(argc,argv)
int argc;
char **argv;
{
    FILE *inp, *popen();
    char buf[1024], filnam[128];
    char *index();
    register char *s;
    register int i, newtot;
    
    sprintf(buf,"\
ls -l `awk '{print $1}' <%s'` | awk '{print $9 \" \" $5}' | sort +1nr\
", argc > 1 ? argv[1] : "MANIFEST.new");
    inp = popen(buf,"r");

    while (fgets(buf,1024,inp) != Nullch) {
	s = index(buf,' ');
	*s++ = '\0';
	for (i=1;
	  (newtot = tot[i] + atol(s) + FILEOVERHEAD) > MAXKITSIZE-KITOVERHEAD;
	  i++) 
	    ;
	if (!tot[i]) {
	    sprintf(filnam,"kit%d.list",i);
	    outfp[i] = fopen(filnam,"w");
	}
	tot[i] = newtot;
	printf("Adding %s to kit %d giving %d bytes\n",buf,i,newtot);
	fprintf(outfp[i],"%s\n",buf);
    }
}
!STUFFY!FUNK!
echo Extracting palias
cat >palias <<'!STUFFY!FUNK!'
.RDCF.SDC	rice!cbosgd!sdcrdcf!%s
.arpa	seismo!%s
.att	rice!cbosgd!%s
.att.com	rice!cbosgd!%s
.au	seismo!munnari!%s
.bcm.tmc.edu	soma!%s
.bellcore.com	rice!cbosgd!wb2!bellcore!%s
.bitnet	seismo!tardis!talcott!%s
.ca	rice!sun!ubc-vision!%s
.canada	rice!sun!ubc-vision!%s
.ccur.uucp	rice!cbosgd!codas!peora!%s
.cdn	rice!sun!ubc-vision!%s
.com	seismo!%s
.csnet	seismo!harvard!%s
.dec	rice!sun!decwrl!%s
.dec.com	rice!sun!decwrl!%s
.dms.oz	seismo!munnari!%s
.dmt.oz	seismo!munnari!%s
.edu	seismo!%s
.gb	seismo!mcvax!ukc!%s
.gov	seismo!%s
.il	seismo!mcvax!huji!humus!%s
.israel	seismo!mcvax!huji!humus!%s
.jp	seismo!kddlab!%s
.jpn	seismo!kddlab!%s
.junet	seismo!kddlab!%s
.korea	seismo!kaist!%s
.kr	seismo!kaist!%s
.mailnet	seismo!harvard!%s
.net	seismo!%s
.org	seismo!%s
.oz	seismo!munnari!%s
.oz.au	seismo!munnari!%s
.rice.edu	rice!%s
.sandiego.ncr.uucp	sdcsvax!ncr-sd!%s
.su.oz	seismo!munnari!%s
.toronto.cdn	rice!cbosgd!utcs!%s
.toronto.csnet	rice!cbosgd!utcs!%s
.trl.oz	seismo!munnari!%s
.uk	seismo!mcvax!ukc!%s
.uq.oz	seismo!munnari!%s
.us	seismo!%s
.uucp	rice!cbosgd!%s
!STUFFY!FUNK!
echo Extracting Binary.Only
cat >Binary.Only <<'!STUFFY!FUNK!'
Unfortunately, you may not be able to alter your mail programs to utilize
the features of uumail. 

However, I am providing a method for you to try experimentally. Please
let me know if it works successfully for you.

Mail usually works like this----

mail --->Is it local? -->Yes-->put in mail box
		|
		No
		|
		--> uux --> uucp to destination machine

What I am providing is a program that you put in place of uux to 
call uumail to route the mail for you. Then the map becomes---

mail --->Is it local? -->Yes-->put in mail box
		|
		No
		|
		--> fakeuux --> Is it rmail? --> No --> realuux -->uucp
					|
					Yes
					|
					--> uumail --> realuux --> uucp


Basically, you put the old uux in another place and put this fake uux in
the original location. To try this feature, edit makefile and change the
definition of REALUUX to match the place you will put your ORIGINAL uux
program. Then type
make fakeuux

Good luck and let me know if it works.
Stan Barber
17 November 1986
!STUFFY!FUNK!
echo Extracting makekit
cat >makekit <<'!STUFFY!FUNK!'
#!/bin/sh
# $Header: makekit,v 4.3 85/05/01 11:42:38 lwall Exp $
#
# $Log:	makekit,v $
# Revision 4.3  85/05/01  11:42:38  lwall
# Baseline for release with 4.3bsd.
# 

numkits=$#
for kitlist in $*; do
    kit=`basename $kitlist .list`
    kitnum=`expr "$kit" : 'kit\([0-9][0-9]*\)'`
    echo "*** Making $kit ***"
    kitleader "$kit" "$kitnum" "$numkits"
    for file in `/bin/cat $kitlist`; do
	echo $file
	echo "echo Extracting $file" >> $kit
	if egrep '^\.$' $file; then
	    echo "sed >$file <<'!STUFFY!FUNK!' -e 's/X//'" >> $kit
	    sed <$file >>$kit -e 's/^/X/'
	else
	    echo "cat >$file <<'!STUFFY!FUNK!'" >> $kit
	    /bin/cat $file >> $kit
	fi
	echo "!STUFFY!FUNK!" >> $kit
    done
    kittrailer "$kit" "$kitnum" "$numkits"
done
!STUFFY!FUNK!
echo Extracting manimake
cat >manimake <<'!STUFFY!FUNK!'
#!/bin/sh
# $Header: manimake,v 4.3 85/05/01 11:42:46 lwall Exp $
#
# $Log:	manimake,v $
# Revision 4.3  85/05/01  11:42:46  lwall
# Baseline for release with 4.3bsd.
# 

: make MANIFEST and MANIFEST.new say the same thing
if test -f MANIFEST.new; then
    cat <<'EOH' > MANIFEST
After all the uumail kits are run you should have the following files:

Filename	Kit Description
--------	--- -----------
EOH
    sort MANIFEST.new >.mani
    grep . kit*.list | sed 's/^kit\(.*\)\.list:\$*\(.*\)$/\2 |\1|/' | \
	sort | \
	join -a1 - .mani | \
	awk -F'|' '{printf "%-16s%2s %s\n",$1,$2,$3}' | \
	unexpand >> MANIFEST
    rm .mani
else
    echo "You don't have a MANIFEST.new file.  Run manifake."
fi
!STUFFY!FUNK!
echo Extracting patchlevel.h
cat >patchlevel.h <<'!STUFFY!FUNK!'
#define PATCHLEVEL 1
static char * Version[] = "uumail 4.2 02/02/87";
!STUFFY!FUNK!
echo ""
echo "End of kit 3 (of 4)"
cat /dev/null >kit3isdone
config=true
for iskit in 1           	2           	3           	4           	; do
    if test -f kit${iskit}isdone; then
	echo "You have run kit ${iskit}."
    else
	echo "You still need to run kit ${iskit}."
	config=false
    fi
done
case $config in
    true)
	echo "You have run all your kits.  Please read README and then type Configure."
	chmod 755 Configure
	;;
esac
: I do not append .signature, but someone might mail this.
exit

