Subject:  v08i075:  Convert IBM DCA documents to troff input
Newsgroups: mod.sources
Approved: mirror!rs

Submitted by: cca!harvard!harvisr!sob
Mod.sources: Volume 8, Issue 75
Archive-name: dca2troff

[  I don't have any DCA documents, and would just as soon keep it
   that way... --r$  ]

#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#     README Makefile dca2troff.1 dca2troff.h ebtab.h dca2troff.c
#     do_accent.c do_mbd1.c do_mbd2.c do_mbd4.c do_mbd8.c do_mbd9.c
#     do_multi.c do_sce4.c do_sfe1.c do_sfe2.c do_sfe3.c do_sfe4.c
#     do_sfe5.c do_sfe6.c do_sfe8.c do_sfe9.c do_single.c do_spchar.c
#     do_text.c externs.c getopt.c misc.c outachar.c opts
export PATH; PATH=/bin:$PATH
echo shar: extracting "'README'" '(1160 characters)'
if test -f 'README'
then
	echo shar: will not over-write existing file "'README'"
else
sed 's/^	X//' << \SHAR_EOF > 'README'
	XThis program is mostly the result of a hard weekend's work.  Some
	Xpeople came to me with something that needed to be printed in time for
	Xthe 350th celebration of Harvard. This was on a friday and the printer's
	Xdeadline was tuesday. So this program is targeted to the requirements
	Xof this specific text.
	X
	XNote also that I am a manager and instructor ( those that can't do -
	Xteach ) and not a programmer so this is weak C and has only been tested
	Xunder 4.3BSD but should be portable.
	X
	XA DCA input document will be turned into useful troff but most page
	Xsetups will be lost.  All "required carrier returns", centering
	Xforced page ends etc will be reflected in the troff output, but margins
	Xand the like will not be. 
	X
	XUnderlineing is turned into italic, and font changes try to do the right
	Xthing. Troff comment lines are insterted for many "interesting" DCA
	Xcommands.
	X
	XThe file "opts" is what I would do if I had the time.
	X
	XYou may want to do some local mods in the files do_spchar.c and 
	Xdo_accent.c, they are set up for our imagen fonts.
	X
	Xplease send me any bugs/fixes/updates
	X
	XScott Bradner
	XHarvard University
	Xsob@harvard.{uucp,csnet,arpa,bitnet,harvard.edu}
SHAR_EOF
if test 1160 -ne "`wc -c < 'README'`"
then
	echo shar: error transmitting "'README'" '(should have been 1160 characters)'
fi
chmod +x 'README'
fi # end of overwriting check
echo shar: extracting "'Makefile'" '(441 characters)'
if test -f 'Makefile'
then
	echo shar: will not over-write existing file "'Makefile'"
else
sed 's/^	X//' << \SHAR_EOF > 'Makefile'
	XCFLAGS = -g
	X
	XOBJS = dca2troff.o do_sfe1.o do_sfe2.o do_sfe3.o do_sfe4.o do_sfe5.o \
	X	do_sfe6.o do_sfe8.o do_sfe9.o do_text.o do_single.o \
	X	do_multi.o do_mbd1.o do_mbd2.o do_mbd4.o do_mbd8.o do_mbd9.o \
	X	misc.o externs.o outachar.o do_accent.o do_spchar.o
	X
	Xdca2troff:	${OBJS}
	X	${CC} -o dca2troff ${OBJS}
	X
	X${OBJS}: dca2troff.h
	X
	Xdo_text.o: ebtab.h
	X
	Xclean:
	X	/bin/rm -f ${OBJS} dca2troff
	X
	Xinstall: dca2troff
	X	install -s dca2troff /usr/local/bin
SHAR_EOF
if test 441 -ne "`wc -c < 'Makefile'`"
then
	echo shar: error transmitting "'Makefile'" '(should have been 441 characters)'
fi
chmod +x 'Makefile'
fi # end of overwriting check
echo shar: extracting "'dca2troff.1'" '(1048 characters)'
if test -f 'dca2troff.1'
then
	echo shar: will not over-write existing file "'dca2troff.1'"
else
sed 's/^	X//' << \SHAR_EOF > 'dca2troff.1'
	X.TH NAME SECTION local
	X.SH NAME
	Xdca2troff  \- convert Document Content Architecture documents to troff
	X.SH SYNOPSIS
	X.B dca2troff < file
	X.SH DESCRIPTION
	X.B dca2troff
	Xreads IBM Document Content Architecture (
	X.B DCA
	X) documents in Revisable-Form
	XText (
	X.B RFT
	X) format.
	XOnly a few of the many
	X.B RFT
	Xcommands (
	X.I Structured Text, Multibyte and One-Byte
	X) are implemented.  The program does parse the commands and
	Xwill print out warnings for any unknown commands.  Troff form
	Xcomments are insterted in the output text stream for some of the
	Xuseful commands like font change requests.
	X.SH FILES
	X.SH SEE ALSO
	XIBM document - Document Content Architecture: Revisable-Form
	XText Reference ( part # SC23-0758-0 ).
	X.SH DIAGNOSTICS
	X.SH BUGS
	XThe version of the RFT manual I used was the first edition ( june 1983 ).
	XI found at least two very common commands that Display Write 3 uses are
	Xnot in the manual,
	X.I dca2troff
	Xnow ignores them.
	X.br
	XBiggest bug: DCA-RFT files are in EBCDIC.
	X.SH AUTHOR
	XScott Bradner ( sob@harvard.{arpa,csnet,uucp,bitnet,harvard.edu}
SHAR_EOF
if test 1048 -ne "`wc -c < 'dca2troff.1'`"
then
	echo shar: error transmitting "'dca2troff.1'" '(should have been 1048 characters)'
fi
chmod +x 'dca2troff.1'
fi # end of overwriting check
echo shar: extracting "'dca2troff.h'" '(1214 characters)'
if test -f 'dca2troff.h'
then
	echo shar: will not over-write existing file "'dca2troff.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'dca2troff.h'
	X#include <stdio.h>
	X
	Xextern int in_fcr;		/* if CRE and in_fcr, then required return */
	Xextern int in_it;		/* in an indent tab */
	X
	Xextern int sf_length;		/* length of structured field */
	Xextern int sf_class;		/* class of structured field */
	Xextern int sf_type;		/* type of structured field */
	Xextern int sf_format;		/* format of structured field */
	X
	Xextern int mb_class;		/* class of a multi byte command */
	Xextern int mb_count;		/* size of a multi byte command */
	Xextern int mb_type;		/* type of a multi byte command */
	X
	Xextern int blpt;		/* pointer into output buffer */
	Xextern char bufline[];		/* output buffer */
	X
	Xextern int sf_incnt;		/* how many chars have we read in this sf */
	X
	Xextern char ctemp;		/* some temp regs */
	Xextern char dtemp;		/* some temp regs */
	Xextern char etemp;		/* some temp regs */
	Xextern char ftemp;		/* some temp regs */
	Xextern char gtemp;		/* some temp regs */
	Xextern char htemp;		/* some temp regs */
	X
	Xextern int itemp;		/* some temp regs */
	Xextern int jtemp;		/* some temp regs */
	Xextern int ktemp;		/* some temp regs */
	Xextern int ltemp;		/* some temp regs */
	Xextern int mtemp;		/* some temp regs */
	Xextern int ntemp;		/* some temp regs */
	X
	Xextern char tline[];		/* a temp buffer */
SHAR_EOF
if test 1214 -ne "`wc -c < 'dca2troff.h'`"
then
	echo shar: error transmitting "'dca2troff.h'" '(should have been 1214 characters)'
fi
chmod +x 'dca2troff.h'
fi # end of overwriting check
echo shar: extracting "'ebtab.h'" '(8517 characters)'
if test -f 'ebtab.h'
then
	echo shar: will not over-write existing file "'ebtab.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'ebtab.h'
	X/* table of EBCDIC characters				*
	X * 1st entry is character use type			*
	X *	0	forget it				*
	X *	1	simple translate to string		*
	X *	2	single byte control			*
	X *	3	"csp" for multibyte control		*
	X *	4	accented character			*
	X *	5	troff special character			*
	X *	6	non-troff special character		*
	X *							*
	X * 2nd entry is a string, use depends on type		*
	X *      1	string to output			*
	X *	2	unused					*
	X *	3	unused					*
	X *	4	accent <SPACE> character		*
	X *	5	string to output			*
	X *	6	if string then output			*
	X *		if no string ( NULL ) then special	*
	X *		character local processing required	*
	X *							*/
	X
	Xstruct echar {
	X	int type;
	X	char *arg;
	X} ebaray[] = {
	X		0, "",		/* 0x00 - NULL */
	X		0, "",		/* 0x01 - xx*/
	X		0, "",		/* 0x02 - xx*/
	X		0, "",		/* 0x03 - xx*/
	X		0, "",		/* 0x04 - xx*/
	X		2, "\t",	/* 0x05 - horizontal tab */
	X		2, "\n.br\n",	/* 0x06 - required carrier return */
	X		0, "",		/* 0x07 - xx*/
	X		0, "",		/* 0x08 - xx*/
	X		2, "\u",	/* 0x09 - superscript */
	X		0, "",		/* 0x0a - xx*/
	X		0, "",		/* 0x0b - xx*/
	X		2, "\n",	/* 0x0c - page end */
	X		2, "\n",	/* 0x0d - zero index carrier return */
	X		0, "",		/* 0x0e - xx*/
	X		0, "",		/* 0x0f - xx*/
	X		0, "",		/* 0x10 - xx*/
	X		0, "",		/* 0x11 - xx*/
	X		0, "",		/* 0x12 - xx*/
	X		0, "",		/* 0x13 - xx*/
	X		0, "",		/* 0x14 - xx*/
	X		2, "\n",	/* 0x15 - carrier return*/
	X		2, "\b",	/* 0x16 - backspace */
	X		0, "",		/* 0x17 - xx*/
	X		0, "",		/* 0x18 - xx*/
	X		0, "",		/* 0x19 - xx*/
	X		2, "",		/* 0x1a - unit backspace */
	X		0, "",		/* 0x1b - xx*/
	X		0, "",		/* 0x1c - xx*/
	X		0, "",		/* 0x1d - xx*/
	X		0, "",		/* 0x1e - xx*/
	X		0, "",		/* 0x1f - xx*/
	X		0, "",		/* 0x20 - xx*/
	X		0, "",		/* 0x21 - xx*/
	X		0, "",		/* 0x22 - xx*/
	X		2, "",		/* 0x23 - word underscore */
	X		0, "",		/* 0x24 - xx*/
	X		2, "",		/* 0x25 - index */
	X		0, "",		/* 0x26 - xx*/
	X		0, "",		/* 0x27 - xx*/
	X		0, "",		/* 0x28 - xx*/
	X		0, "",		/* 0x29 - xx*/
	X		0, "",		/* 0x2a - xx*/
	X		3, "",		/* 0x2b - CSP */
	X		0, "",		/* 0x2c - xx*/
	X		0, "",		/* 0x2d - xx*/
	X		0, "",		/* 0x2e - xx*/
	X		0, "",		/* 0x2f - xx*/
	X		0, "",		/* 0x30 - xx*/
	X		0, "",		/* 0x31 - xx*/
	X		0, "",		/* 0x32 - xx*/
	X		2, "",		/* 0x33 - index return */
	X		0, "",		/* 0x34 - xx*/
	X		0, "",		/* 0x35 - xx*/
	X		2, "\\h'-\\w'1'u'",	/* 0x36 - numeric backspace */
	X		0, "",		/* 0x37 - xx*/
	X		2, "\d",	/* 0x38 - subscript */
	X		2, "",		/* 0x39 - indent tab */
	X		2, "\n.bp\n",	/* 0x3a - required page end */
	X		0, "",		/* 0x3b - xx*/
	X		0, "",		/* 0x3c - xx*/
	X		0, "",		/* 0x3d - xx*/
	X		0, "",		/* 0x3e - xx*/
	X		2, "",		/* 0x3f - substitute */
	X		2, " ",		/* 0x40 - space */
	X		2, " ",		/* 0x41 - required space */
	X		4, "^ a",	/* 0x42 - a circumflex */
	X		4, ".. a",	/* 0x43 - a diaeresis */
	X		4, "' a",	/* 0x44 - a grave */
	X		4, "` a",	/* 0x45 - a acute */
	X		4, "~ a",	/* 0x46 - a tilde */
	X		4, "de a",	/* 0x47 - a angstrom */
	X		4, "cd c",	/* 0x48 - c cedilla */
	X		4, "~ n",	/* 0x49 - n telde */
	X		1, "[",		/* 0x4a - [ */
	X		1, ".",		/* 0x4b - . */
	X		1, "<",		/* 0x4c - < */
	X		1, "(",		/* 0x4d - ( */
	X		1, "+",		/* 0x4e - + */
	X		1, "!",		/* 0x4f - ! */
	X		1, "&",		/* 0x50 - & */
	X		4, "` e",	/* 0x51 - e acute */
	X		4, "^ e",	/* 0x52 - e circumflex */
	X		4, ".. e",	/* 0x53 - e diaeresis */
	X		4, "' e",	/* 0x54 - e grave */
	X		4, "` i",	/* 0x55 - i acute */
	X		4, "^ i",	/* 0x56 - i circumflex */
	X		4, ".. i",	/* 0x57 - i diaeresis */
	X		4, "' i",	/* 0x58 - i grave */
	X		6, "\\(ss",	/* 0x59 - german sharp s */
	X		1, "]",		/* 0x5a - ] */
	X		1, "$",		/* 0x5b - $ */
	X		1, "*",		/* 0x5c - * */
	X		1, ")",		/* 0x5d - ) */
	X		1, ";",		/* 0x5e - ; */
	X		1, "^",		/* 0x5f - ^ */
	X		2, "-",		/* 0x60 - required - */
	X		1, "/",		/* 0x61 - / */
	X		4, "^ A",	/* 0x62 - A circumflex */
	X		4, ".. A",	/* 0x63 - A diaeresis */
	X		4, "' A",	/* 0x64 - A grave */
	X		4, "` A",	/* 0x65 - A acute */
	X		4, "~ A",	/* 0x66 - A tilde */
	X		4, "de A",	/* 0x67 - A angstrom */
	X		4, "cd C",	/* 0x68 - C cedilla */
	X		4, "~ N",	/* 0x69 - N tilde */
	X		1, "|",		/* 0x6a - | */
	X		1, ",",		/* 0x6b - , */
	X		1, "%",		/* 0x6c - % */
	X		1, "_",		/* 0x6d - _ */
	X		1, ">",		/* 0x6e - > */
	X		1, "?",		/* 0x6f - ? */
	X		6, "\\(O/",	/* 0x70 - O slash */
	X		4, "' E",	/* 0x71 - E acute */
	X		4, "^ E",	/* 0x72 - E circumflex */
	X		4, ".. E",	/* 0x73 - E diaresis */
	X		4, "` E",	/* 0x74 - E grave */
	X		4, "' I",	/* 0x75 - I acute */
	X		4, "^ I",	/* 0x76 - I circumflex */
	X		4, ".. I",	/* 0x77 - I diaresis */
	X		4, "` I",	/* 0x78 - I grave */
	X		5, "\(ag",	/* 0x79 - grave */
	X		1, ":",		/* 0x7a - : */
	X		1, "#",		/* 0x7b - # */
	X		1, "@",		/* 0x7c - @ */
	X		1, "\'",	/* 0x7d - ' */
	X		1, "=",		/* 0x7e - = */
	X		1, "\"", 	/* 0x7f - " */
	X		1, "/",		/* 0x80 - / */
	X		1, "a",		/* 0x81 - a */
	X		1, "b",		/* 0x82 - b */
	X		1, "c",		/* 0x83 - c */
	X		1, "d",		/* 0x84 - d */
	X		1, "e",		/* 0x85 - e */
	X		1, "f",		/* 0x86 - f */
	X		1, "g",		/* 0x87 - g */
	X		1, "h",		/* 0x88 - h */
	X		1, "i",		/* 0x89 - i */
	X		6, "",		/* 0x8a - European open quote */
	X		6, "",		/* 0x8b - European close quote */
	X		6, "",		/* 0x8c - d stroke */
	X		4, "` y",	/* 0x8d - y acute */
	X		6, "",		/* 0x8e - small letter thorn */
	X		5, "\\(+-",	/* 0x8f - +- */
	X		5, "\\(de",	/* 0x90 - degree */
	X		1, "j",		/* 0x91 - j */
	X		1, "k",		/* 0x92 - k */
	X		1, "l",		/* 0x93 - l */
	X		1, "m",		/* 0x94 - m */
	X		1, "n",		/* 0x95 - n */
	X		1, "o",		/* 0x96 - o */
	X		1, "p",		/* 0x97 - p */
	X		1, "q",		/* 0x98 - q */
	X		1, "r",		/* 0x99 - r */
	X		4, "_ a",	/* 0x9a - a underscore */
	X		4, "_ o",	/* 0x9b - o underscore */
	X		5, "\\(ae",	/* 0x9c - ae ligature */
	X		4, "\\(cd",	/* 0x9d - Cedilla */
	X		5, "\\(AE",	/* 0x9e - AE ligature */
	X		6, "",		/* 0x9f - international currency symbol */
	X		6, "",		/* 0xa0 - Micro */
	X		1, "~",		/* 0xa1 - ~ */
	X		1, "s",		/* 0xa2 - s */
	X		1, "t",		/* 0xa3 - t */
	X		1, "u",		/* 0xa4 - u */
	X		1, "v",		/* 0xa5 - v */
	X		1, "w",		/* 0xa6 - w */
	X		1, "x",		/* 0xa7 - x */
	X		1, "y",		/* 0xa8 - y */
	X		1, "z",		/* 0xa9 - z */
	X		6, "\\(!!",	/* 0xaa - inverted ! */
	X		6, "\\(??",	/* 0xab - inverted ? */
	X		6, "",		/* 0xac - D stroke */
	X		4, "` Y",	/* 0xad - Y acute */
	X		6, "",		/* 0xae - Capital Thorn */
	X		5, "\\(co",	/* 0xaf - copyright */
	X		5, "\\(ct",	/* 0xb0 - cent sign */
	X		6, "",		/* 0xb1 - Pound sign */
	X		6, "",		/* 0xb2 - Yen */
	X		6, "",		/* 0xb3 - Peseta */
	X		6, "",		/* 0xb4 - Floren, Guilder */
	X		5, "\\(sc",	/* 0xb5 - section sign */
	X		6, "\\(pa",	/* 0xb6 - paragraph sign */
	X		5, "\\(14",	/* 0xb7 - one fourth */
	X		5, "\\(12",	/* 0xb8 - one half */
	X		5, "\\(34",	/* 0xb9 - three fourths*/
	X		5, "\\(no",	/* 0xba - logical not */
	X		5, "\\(or",	/* 0xbb - logical or */
	X		6, "\\(mc",	/* 0xbc - overbar */
	X		6, "\\(..",	/* 0xbd - diaeresis */
	X		5, "\\(aa",	/* 0xbe - acute */
	X		6, "",		/* 0xbf - double underscore */
	X		1, "{",		/* 0xc0 - { */
	X		1, "A",		/* 0xc1 - A */
	X		1, "B",		/* 0xc2 - B */
	X		1, "C",		/* 0xc3 - C */
	X		1, "D",		/* 0xc4 - D */
	X		1, "E",		/* 0xc5 - E */
	X		1, "F",		/* 0xc6 - F */
	X		1, "G",		/* 0xc7 - G */
	X		1, "H",		/* 0xc8 - H */
	X		1, "I",		/* 0xc9 - I */
	X		2, "\\%",	/* 0xca - syllable hyphen */
	X		4, "^ o",	/* 0xcb - o circumflex */
	X		4, ".. o",	/* 0xcc - o diaresis */
	X		4, "' o",	/* 0xcd - o grave */
	X		4, "` o",	/* 0xce - o acute */
	X		4, "~ o",	/* 0xcf - o tilde */
	X		1, "}",		/* 0xd0 - } */
	X		1, "J",		/* 0xd1 - J */
	X		1, "K",		/* 0xd2 - K */
	X		1, "L",		/* 0xd3 - L */
	X		1, "M",		/* 0xd4 - M */
	X		1, "N",		/* 0xd5 - N */
	X		1, "O",		/* 0xd6 - O */
	X		1, "P",		/* 0xd7 - P */
	X		1, "Q",		/* 0xd8 - Q */
	X		1, "R",		/* 0xd9 - R */
	X		6, "\\(ui",	/* 0xda - dotless i */
	X		4, "^ u",	/* 0xdb - u circumflex */
	X		4, ".. u",	/* 0xdc - u diaresis */
	X		4, "' u",	/* 0xdd - u grave */
	X		4, "` u",	/* 0xde - u acute */
	X		4, ".. y",	/* 0xdf - y diaresis */
	X		1, "\\",	/* 0xe0 - \ */
	X		2, "\\h'\\w'1'u'",	/* 0xe1 - numeric space */
	X		1, "S",		/* 0xe2 - S */
	X		1, "T",		/* 0xe3 - T */
	X		1, "U",		/* 0xe4 - U */
	X		1, "V",		/* 0xe5 - V */
	X		1, "W",		/* 0xe6 - W */
	X		1, "X",		/* 0xe7 - X */
	X		1, "Y",		/* 0xe8 - Y */
	X		1, "Z",		/* 0xe9 - Z */
	X		6, "\\u\\s-22\\s+2\\d",	/* 0xea - superscript 2 */
	X		4, "^ O",	/* 0xeb - O circumflex */
	X		4, ".. O",	/* 0xec - O diaresis */
	X		4, "' O",	/* 0xed - O grave */
	X		4, "` O",	/* 0xee - O acute */
	X		4, "~ O",	/* 0xef - O tilde */
	X		1, "0",		/* 0xf0 - 0 */
	X		1, "1",		/* 0xf1 - 1 */
	X		1, "2",		/* 0xf2 - 2 */
	X		1, "3",		/* 0xf3 - 3 */
	X		1, "4",		/* 0xf4 - 4 */
	X		1, "5",		/* 0xf5 - 5 */
	X		1, "6",		/* 0xf6 - 6 */
	X		1, "7",		/* 0xf7 - 7 */
	X		1, "8",		/* 0xf8 - 8 */
	X		1, "9",		/* 0xf9 - 9 */
	X		6, "\\u\\s-23\\s+2\\d",	/* 0xfa - superscript 3 */
	X		4, "^ U",	/* 0xfb - U circumflex */
	X		4, ".. U",	/* 0xfc - U diaresis */
	X		4, "' U",	/* 0xfd - U grave */
	X		4, "` U",	/* 0xfe - U acute */
	X		6, "",		/* 0xff - "Eight Ones" */
	X};
SHAR_EOF
if test 8517 -ne "`wc -c < 'ebtab.h'`"
then
	echo shar: error transmitting "'ebtab.h'" '(should have been 8517 characters)'
fi
chmod +x 'ebtab.h'
fi # end of overwriting check
echo shar: extracting "'dca2troff.c'" '(785 characters)'
if test -f 'dca2troff.c'
then
	echo shar: will not over-write existing file "'dca2troff.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'dca2troff.c'
	X#include "dca2troff.h"
	X
	X
	X/* dca is a series of structured fields */
	X
	Xmain()
	X{
	X    for (;;)
	X	{				/* do a structured field */
	X	sf_incnt = 0;			/* init the character count */
	X	sf_length = get1num(); 		/* positive - includes length bytes */
	X	sf_class = get1ch();		/* get the paramaters for the field */
	X	sf_type = get1ch();
	X	sf_format = get1ch();
	X
	X	switch (sf_class)		/* what class of sf? */
	X	    {
	X	    case 0xe1:
	X		do_sfe1();
	X		break;
	X	    case 0xe2:
	X		do_sfe2();
	X		break;
	X	    case 0xe3:
	X		do_sfe3();
	X		break;
	X	    case 0xe4:
	X		do_sfe4();
	X		break;
	X	    case 0xe5:
	X		do_sfe5();
	X		break;
	X	    case 0xe6:
	X		do_sfe6();
	X		break;
	X	    case 0xe8:
	X		do_sfe8();
	X		break;
	X	    case 0xe9:
	X		do_sfe9();
	X		break;
	X	    default:
	X		fprintf(stderr, "Unknown SF class (%02x)\n", sf_class); 
	X	    }
	X	}
	X}
SHAR_EOF
if test 785 -ne "`wc -c < 'dca2troff.c'`"
then
	echo shar: error transmitting "'dca2troff.c'" '(should have been 785 characters)'
fi
chmod +x 'dca2troff.c'
fi # end of overwriting check
echo shar: extracting "'do_accent.c'" '(1627 characters)'
if test -f 'do_accent.c'
then
	echo shar: will not over-write existing file "'do_accent.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'do_accent.c'
	X/* do an accented char */
	X
	X/* input is a string with the accent to print then a space then the  */
	X/*	character to accent */
	X
	X#include "dca2troff.h"
	X#include <ctype.h>
	X
	Xstruct acc {
	X	char *generic;
	X	char *output;
	X} lacc[] = {		/* lower case accents */
	X	"`",	"\\(ga",		/* grave */
	X	"'",	"\\(aa",		/* acute */
	X	"^",	"^",			/* circumflex */
	X	"~",	"~",			/* tilde */
	X	"..",	"\\(..",		/* diaresis */
	X	"de",	"\\(de",		/* angstrom */
	X	"cd",	"\\(cd",		/* cedilla */
	X	"",	""
	X};
	Xstruct acc uacc[] = {	/* upper case accents */
	X	"`",	"\\f(Sr\\(ga\\fP",	/* grave */
	X	"'",	"\\f(Sr\\(aa\\fP",	/* acute */
	X	"^",	"\\f(Sr^\\fP",		/* circumflex */
	X	"~",	"\\f(Sr~\\fP",		/* tilde */
	X	"..",	"\\f(Sr\\(..\\fP",	/* diaresis */
	X	"de",	"\\f(Sr\\(de\\fP",	/* angstrom */
	X	"cd",	"\\(cd",		/* cedilla */
	X	"",	""
	X};
	X#include "dca2troff.h"
	Xdo_accent(str)
	Xchar *str;
	X{
	X	char accent[10];
	X	char character;
	X	int i;
	X
	X	sscanf(str, "%s %c", accent, &character);
	X
	X	if ( islower(character) )	/* lower case character no problem */
	X		{
	X		i = checkacc(lacc, accent);
	X		if ( i == -1 )
	X			{
	X			fprintf(stderr, "unknown accent %s\n", accent);
	X			return(0);
	X			}
	X		sprintf(tline, "\\o'%s%c'", lacc[i], character);
	X		}
	X	else
	X		{
	X		i = checkacc(uacc, accent);
	X		if ( i == -1 )
	X			{
	X			fprintf(stderr, "unknown accent %s\n", accent);
	X			return(0);
	X			}
	X		sprintf(tline, "\\u\\z%s\\d%c", uacc[i], character);
	X		}
	X	outstr(tline);
	X}
	X
	X/* search for accent string in struct */
	X/* return index if ok, else -1 */
	Xcheckacc(str, s)
	Xchar *str[];
	Xchar *s;
	X{
	X	int i;
	X	for(i=0;;i++)
	X		{
	X		if((strcmp(str[i], "\0") == 0 ))
	X			return(-1);
	X		if((strcmp(str[i], s) == 0 ))
	X			return(i);
	X		}
	X}
SHAR_EOF
if test 1627 -ne "`wc -c < 'do_accent.c'`"
then
	echo shar: error transmitting "'do_accent.c'" '(should have been 1627 characters)'
fi
chmod +x 'do_accent.c'
fi # end of overwriting check
echo shar: extracting "'do_mbd1.c'" '(3462 characters)'
if test -f 'do_mbd1.c'
then
	echo shar: will not over-write existing file "'do_mbd1.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'do_mbd1.c'
	X#include "dca2troff.h"
	X
	Xstruct fnts {
	X	int gfid;		/* GFID i.e. font number */
	X	char *dfnt;		/* use this troff font for now */
	X	char *fntname;		/* font name */
	X} fnttab[] = {
	X	1,	"1",	"Advocate",
	X	2,	"1",	"Delegate",
	X	3,	"1",	"OCR-B",
	X	4,	"1",	"Polygo Pica",
	X	5,	"1",	"Orator",
	X	6,	"2",	"Light Italic 10",
	X	7,	"1",	"OCR-M",
	X	8,	"1",	"Scribe 10",
	X	9,	"1",	"Large Pica",
	X	10,	"1",	"Cyrillic 22",
	X	11,	"1",	"Courier 10",
	X	12,	"1",	"Prestige Pica",
	X	13,	"1",	"Artisan 10",
	X	14,	"1",	"Manifold",
	X	15,	"1",	"Bookface Academic",
	X	16,	"1",	"Latin 10 High Speed",
	X	17,	"1",	"1403 OCR",
	X	18,	"2",	"Courier Italic 10",
	X	19,	"1",	"OCR-A",
	X	20,	"1",	"PICA",
	X	21,	"1",	"Katakana Light",
	X	22,	"1",	"Printing & Publishing 12 Number 3",
	X	23,	"2",	"Light Italic 10 Mod",
	X	24,	"1",	"Presentor",
	X	80,	"1",	"Scribe",
	X	81,	"1",	"Artisan 12",
	X	82,	"1",	"Auto Elite",
	X	83,	"1",	"Elite",
	X	84,	"1",	"Script",
	X	85,	"1",	"Courier 12",
	X	86,	"1",	"Prestige Elite",
	X	87,	"1",	"Letter Gothic",
	X	88,	"1",	"High Speed Latin 12",
	X	89,	"1",	"Large Elite",
	X	90,	"1",	"Dual Gothic",
	X	91,	"2",	"Light Italic 12",
	X	92,	"2",	"Courier 12 Italic",
	X	93,	"1",	"Polygo Elite",
	X	94,	"1",	"Diplomat",
	X	95,	"1",	"Adjutant",
	X	96,	"1",	"Olde World",
	X	97,	"2",	"Light Italic 12 Mod",
	X	155,	"2",	"Boldface Italic",
	X	156,	"1",	"Thesis",
	X	157,	"1",	"Title",
	X	158,	"1",	"Modern",
	X	159,	"1",	"Boldface",
	X	160,	"1",	"Essay",
	X	161,	"1",	"Arcadia",
	X	162,	"2",	"Essay Italic",
	X	163,	"3",	"Essay Bold",
	X	165,	"1",	"High Speed Latin PSM",
	X	221,	"1",	"Prestige 15",
	X	222,	"1",	"Gothic 15",
	X	223,	"1",	"Courier 15",
	X	224,	"1",	"Rotated Data 1 15",
	X	225,	"1",	"Scribe 15",
	X	0,	"",	""
	X};
	X
	X/* multi byte class d1 */
	Xdo_mbd1()
	X{
	X/* the "???????" entries were found in some dw3 files but are not
	X	documented */
	X
	X    switch (mb_type)
	X	{
	X	case 0x8a:			/* ???????? */
	X	case 0x8e:			/* ???????? */
	X	    do_flush(mb_count);
	X	    return;
	X	case 0x01:			/* SCG   - Set GCGID thru GCID */
	X	    itemp = get1num();			/* get GCID1 */
	X	    jtemp = get1num();			/* get GCID2 */
	X	    mb_count = mb_count -4;
	X	    sprintf(tline, "\\\" graphic character set request: GCID1=%d, GCID2=%d\n", itemp, jtemp);
	X	    do_flush(mb_count);
	X	    return;
	X	case 0x05:			/* SFG   - Set CFID thru GFID */
	X	    itemp = get1num();			/* get GFID */
	X	    jtemp = get1num();			/* get font width */
	X	    ctemp = get1ch();			/* get font attribute */
	X	    mb_count = mb_count - 5;
	X	    for(ltemp=0;fnttab[ltemp].gfid != itemp; ltemp++)
	X		{
	X		if(fnttab[ltemp].gfid == 0)
	X		    {
	X	    	    sprintf(tline, "\\\" font request: GFID=%d, width=%d, ",itemp, jtemp);
	X		    }
	X		}
	X	    if(fnttab[ltemp].gfid == itemp)
	X		    {
	X	    	    sprintf(tline, "\\\" font request: font='%s', width=%d, ",fnttab[ltemp].fntname, jtemp);
	X		    }
	X	    outstr(tline);
	X	    if(ctemp == 1)
	X		outstr("monospace\n");
	X	    else
	X		outstr("proportionally spaced\n");
	X	    if(fnttab[ltemp].gfid == itemp)
	X		    {
	X		    sprintf(tline, "\\f%s", fnttab[ltemp].dfnt);
	X	    	    outstr(tline);
	X		    }
	X	    do_flush(mb_count);
	X	    return;
	X	case 0x15:			/* IEG   - Insert Escaped Graphic */
	X	    if(mb_count >= 3)
	X		{
	X		itemp = get1num();		/* get code page */
	X		ctemp = get1ch();		/* get character code */
	X		mb_count = mb_count - 3;
	X		sprintf(tline, "\\\" special character request: code page=%d, character code=x%02x\n", itemp, ctemp);
	X		outstr(tline);
	X		}
	X	    do_flush(mb_count);
	X	    return;
	X	default:
	X	    fprintf(stderr, "unknown mb d1 type (%02x)\n", mb_type);
	X	    do_flush(mb_count);
	X	    return;
	X	}
	X}
SHAR_EOF
if test 3462 -ne "`wc -c < 'do_mbd1.c'`"
then
	echo shar: error transmitting "'do_mbd1.c'" '(should have been 3462 characters)'
fi
chmod +x 'do_mbd1.c'
fi # end of overwriting check
echo shar: extracting "'do_mbd2.c'" '(375 characters)'
if test -f 'do_mbd2.c'
then
	echo shar: will not over-write existing file "'do_mbd2.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'do_mbd2.c'
	X
	X#include "dca2troff.h"
	X
	X/* multi byte class d2 */
	Xdo_mbd2()
	X{
	X    switch (mb_type)
	X	{
	X	case 0x01:			/* STAB  - Set Tabs */
	X	case 0x0b:			/* RLM   - Release Left Margin */
	X	case 0x35:			/* SVA   - Set Visual Attributes */
	X	    do_flush(mb_count);
	X	    return;
	X	default:
	X	    fprintf(stderr, "unknown mb d2 type (%02x)\n", mb_type);
	X	    do_flush(mb_count);
	X	    return;
	X	}
	X}
SHAR_EOF
if test 375 -ne "`wc -c < 'do_mbd2.c'`"
then
	echo shar: error transmitting "'do_mbd2.c'" '(should have been 375 characters)'
fi
chmod +x 'do_mbd2.c'
fi # end of overwriting check
echo shar: extracting "'do_mbd4.c'" '(2019 characters)'
if test -f 'do_mbd4.c'
then
	echo shar: will not over-write existing file "'do_mbd4.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'do_mbd4.c'
	X
	X#include "dca2troff.h"
	X
	X/* multi byte class d4 */
	Xdo_mbd4()
	X{
	X    switch (mb_type)
	X	{
	X	case 0x02:			/* BLFC  - Begin Line Fmt. Change */
	X	case 0x04:			/* RMLF  - Return to Mstr. Line Fmt. */
	X	case 0x05:			/* SLP   - Set Line Parameters */
	X	case 0x06:			/* ELFC  - End Line Fmt. Change */
	X	case 0x13:			/* ATL   - Return To Master Font */
	X	case 0x47:			/* PPIN  - Print Page Image Number */
	X	case 0x63:			/* PTUN  - Print Text Unit Name */
	X	case 0x72:			/* BOS   - Begin Overstrike */
	X	case 0x76:			/* EOS   - End Overstrike */
	X	case 0x7a:			/* BLM   - Begin Linguistic Mark */
	X	case 0x7e:			/* ELM   - End Linguistic Mark */
	X	    do_flush(mb_count);
	X	    return;
	X	case 0x0a:			/* BUS   - Begin Underscore */
	X	    outstr("\\fI");
	X	    do_flush(mb_count);
	X	    return;
	X	case 0x0b:			/* ATF   - Align Text Field */
	X	    itemp = get1ch();			/* get alignment type */
	X	    --mb_count;
	X	    jtemp = 0;
	X	    if(mb_count >= 2)
	X		{
	X		jtemp = get1num();		/* get alignment pos */
	X		--mb_count;
	X		--mb_count;
	X		}
	X	    if(itemp == 3)			/* center request */
	X		outstr("\n.ce\n");
	X	    do_flush(mb_count);
	X	    return;
	X	case 0x0e:			/* EUS   - End Underscore */
	X	    outstr("\\fR");
	X	    do_flush(mb_count);
	X	    return;
	X	case 0x0f:			/* ATL   - Align Text Line */
	X	    itemp = get1ch();			/* get alignment type */
	X	    --mb_count;
	X	    if(itemp == 1)			/* center */
	X		outstr("\n.ce\n");
	X	    if(itemp == 2)			/* right */
	X		;
	X	    do_flush(mb_count);
	X	    return;
	X	case 0x62:			/* BK    - Begin Keep */
	X	    outstr("\\\" Begin Keep\n");
	X	    do_flush(mb_count);
	X	    return;
	X	case 0x66:			/* EK    - End Keep */
	X	    outstr("\\\" End Keep\n");
	X	    do_flush(mb_count);
	X	    return;
	X	case 0x90:			/* DPS   - Display Prompt and Stop */
	X	    ctemp = get1ch();			/* get prompt */
	X	    sprintf(tline, "\\\" DPS found - keyboard data request, prompt=x%02x\n", ctemp);
	X	    outstr(tline);
	X	    do_flush(mb_count);
	X	    return;
	X	default:
	X	    fprintf(stderr, "unknown mb d4 type (%02x)\n", mb_type);
	X	    do_flush(mb_count);
	X	    return;
	X	}
	X}
SHAR_EOF
if test 2019 -ne "`wc -c < 'do_mbd4.c'`"
then
	echo shar: error transmitting "'do_mbd4.c'" '(should have been 2019 characters)'
fi
chmod +x 'do_mbd4.c'
fi # end of overwriting check
echo shar: extracting "'do_mbd8.c'" '(939 characters)'
if test -f 'do_mbd8.c'
then
	echo shar: will not over-write existing file "'do_mbd8.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'do_mbd8.c'
	X
	X#include "dca2troff.h"
	X
	X/* multi byte class d8 */
	Xdo_mbd8()
	X{
	X    switch (mb_type)
	X	{
	X	case 0x82:			/* SSCA  - Set Spelling Check Attrib. */
	X	case 0x94:			/* CWB   - Conditional Word Break */
	X	case 0x95:			/* NPD   - Note Partition Delimiter */
	X	case 0x96:			/* LOP   - Locate Process Output */
	X	    do_flush(mb_count);
	X	    return;
	X	case 0x62:			/* BCL   - Begin Column Layout */
	X	    outstr("\\\" Begin Column Layout request\n");
	X	    do_flush(mb_count);
	X	    return;
	X	case 0x66:			/* ECL   - End Column Layout */
	X	    outstr("\\\" End Column Layout request\n");
	X	    do_flush(mb_count);
	X	    return;
	X	case 0x6a:			/* BFT   - Begin Formatted Text */
	X	    outstr("\n.nf\n");
	X	    do_flush(mb_count);
	X	    return;
	X	case 0x6e:			/* EFT   - End Formatted Text */
	X	    outstr("\n.fi\n");
	X	    do_flush(mb_count);
	X	    return;
	X	default:
	X	    fprintf(stderr, "unknown mb d8 type (%02x)\n", mb_type);
	X	    do_flush(mb_count);
	X	    return;
	X	}
	X}
SHAR_EOF
if test 939 -ne "`wc -c < 'do_mbd8.c'`"
then
	echo shar: error transmitting "'do_mbd8.c'" '(should have been 939 characters)'
fi
chmod +x 'do_mbd8.c'
fi # end of overwriting check
echo shar: extracting "'do_mbd9.c'" '(603 characters)'
if test -f 'do_mbd9.c'
then
	echo shar: will not over-write existing file "'do_mbd9.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'do_mbd9.c'
	X
	X#include "dca2troff.h"
	X
	X/* multi byte class d9 */
	Xdo_mbd9()
	X{
	X    switch (mb_type)
	X	{
	X	case 0x6a:			/* AO   - Auto-Outline */
	X	case 0x82:			/* INS  - Insert */
	X	case 0x85:			/* NR   - Note Reference */
	X	case 0x86:			/* NTR  - Note Text Reference */
	X	    do_flush(mb_count);
	X	    return;
	X	case 0x81:			/* IU   - Include Unit */
	X	    fprintf(stderr, " This document has a request to include another document\n");
	X	    outstr("\\\" Include request");
	X	    do_flush(mb_count);
	X	    return;
	X	default:
	X	    fprintf(stderr, "unknown mb d9 type (%02x)\n", mb_type);
	X	    do_flush(mb_count);
	X	    return;
	X	}
	X}
	X
SHAR_EOF
if test 603 -ne "`wc -c < 'do_mbd9.c'`"
then
	echo shar: error transmitting "'do_mbd9.c'" '(should have been 603 characters)'
fi
chmod +x 'do_mbd9.c'
fi # end of overwriting check
echo shar: extracting "'do_multi.c'" '(552 characters)'
if test -f 'do_multi.c'
then
	echo shar: will not over-write existing file "'do_multi.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'do_multi.c'
	X#include "dca2troff.h"
	X
	Xdo_multi()
	X{
	X    char c;
	X
	X    mb_class = get1ch();
	X    mb_count = get1ch();
	X    mb_type = get1ch();
	X
	X    mb_count &= 0377;		/* count is a 1 byte value */
	X    mb_count = mb_count - 2;		/* count includes count and type */
	X
	X    switch (mb_class)
	X	{
	X	case 0xd1:
	X		do_mbd1();
	X		return;
	X	case 0xd2:
	X		do_mbd2();
	X		return;
	X	case 0xd4:
	X		do_mbd4();
	X		return;
	X	case 0xd8:
	X		do_mbd8();
	X		return;
	X	case 0xd9:
	X		do_mbd9();
	X		return;
	X	default:
	X		fprintf(stderr, "unknown mb_class ( %02x )\n", mb_class);
	X		do_flush(mb_count);
	X		return;
	X	}
	X}
SHAR_EOF
if test 552 -ne "`wc -c < 'do_multi.c'`"
then
	echo shar: error transmitting "'do_multi.c'" '(should have been 552 characters)'
fi
chmod +x 'do_multi.c'
fi # end of overwriting check
echo shar: extracting "'do_sce4.c'" '(206 characters)'
if test -f 'do_sce4.c'
then
	echo shar: will not over-write existing file "'do_sce4.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'do_sce4.c'
	X#include "dca2troff.h"
	X/* structured field class e4 */
	Xdo_sfe4()
	X{
	X    switch(sf_type)
	X	{
	X	case 0x02:			/* PM   - Print Medium */
	X	case 0x03:			/* OM   - Operator Message */
	X	default:
	X	    flush_sf();
	X	}
	X}
SHAR_EOF
if test 206 -ne "`wc -c < 'do_sce4.c'`"
then
	echo shar: error transmitting "'do_sce4.c'" '(should have been 206 characters)'
fi
chmod +x 'do_sce4.c'
fi # end of overwriting check
echo shar: extracting "'do_sfe1.c'" '(362 characters)'
if test -f 'do_sfe1.c'
then
	echo shar: will not over-write existing file "'do_sfe1.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'do_sfe1.c'
	X#include "dca2troff.h"
	X
	X/* structured field class e1 */
	Xdo_sfe1()
	X{
	X    switch(sf_type)
	X	{
	X	case 0x03:			/* FUP  - Format Unit Prefix */
	X	case 0x04:			/* TUP  - Text Unit Prefix */
	X	case 0x06:			/* EUP  - End Unit Prefix */
	X	    flush_sf();
	X	    return;
	X	default:
	X	    fprintf(stderr, "unknown sf e1 type (x%02x)\n", sf_type);
	X	    flush_sf();
	X	    return;
	X	}
	X}
SHAR_EOF
if test 362 -ne "`wc -c < 'do_sfe1.c'`"
then
	echo shar: error transmitting "'do_sfe1.c'" '(should have been 362 characters)'
fi
chmod +x 'do_sfe1.c'
fi # end of overwriting check
echo shar: extracting "'do_sfe2.c'" '(782 characters)'
if test -f 'do_sfe2.c'
then
	echo shar: will not over-write existing file "'do_sfe2.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'do_sfe2.c'
	Xstruct lang {
	X	int splangn;
	X	char *splang;
	X} spellchk[] = {
	X	0,	"No spellcheck",
	X	1,	"American English",
	X	2,	"UK English",
	X	3,	"German",
	X	4,	"Dutch",
	X	5,	"National French",
	X	6,	"Canadian French",
	X	7,	"Italian",
	X	8,	"Spanish",
	X	9,	"Swedish",
	X	10,	"Finnish",
	X	11,	"Danish",
	X	12,	"Norwegian",
	X	0xffff,	"Use current language"
	X};
	X
	X#include "dca2troff.h"
	X/* structured field class e2 */
	Xdo_sfe2()
	X{
	X    switch(sf_type)
	X	{
	X	case 0x01:			/* PMF  - Primary Master Format */
	X	case 0x02:			/* AMF  - Alternate Master Format */
	X	case 0x04:			/* TUFC - Text Unit Format Change */
	X	    flush_sf();
	X	    return;
	X	case 0x05:			/* DP   - Document Parameters */
	X	    flush_sf();
	X	    return;
	X	default:
	X	    fprintf(stderr, "unknown sf e2 type (x%02x)\n", sf_type);
	X	    flush_sf();
	X	    return;
	X	}
	X}
SHAR_EOF
if test 782 -ne "`wc -c < 'do_sfe2.c'`"
then
	echo shar: error transmitting "'do_sfe2.c'" '(should have been 782 characters)'
fi
chmod +x 'do_sfe2.c'
fi # end of overwriting check
echo shar: extracting "'do_sfe3.c'" '(385 characters)'
if test -f 'do_sfe3.c'
then
	echo shar: will not over-write existing file "'do_sfe3.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'do_sfe3.c'
	X#include "dca2troff.h"
	X/* structured field class e3 */
	Xdo_sfe3()
	X{
	X    switch(sf_type)
	X	{
	X	case 0x01:			/* EPM  - Estab Primary Master Fmt */
	X	case 0x02:			/* EAM  - Estab Alternate Master Fmt */
	X	case 0x03:			/* RTMF - Return to Master Format */
	X	    flush_sf();
	X	    return;
	X	default:
	X	    fprintf(stderr, "unknown sf e3 type (x%02x)\n", sf_type);
	X	    flush_sf();
	X	    return;
	X	}
	X}
SHAR_EOF
if test 385 -ne "`wc -c < 'do_sfe3.c'`"
then
	echo shar: error transmitting "'do_sfe3.c'" '(should have been 385 characters)'
fi
chmod +x 'do_sfe3.c'
fi # end of overwriting check
echo shar: extracting "'do_sfe4.c'" '(314 characters)'
if test -f 'do_sfe4.c'
then
	echo shar: will not over-write existing file "'do_sfe4.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'do_sfe4.c'
	X
	X#include "dca2troff.h"
	X
	X/* structured field class e4 */
	Xdo_sfe4()
	X{
	X    switch(sf_type)
	X	{
	X	case 0x02:			/* PM   - Print Medium */
	X	case 0x03:			/* OM   - Operator Message */
	X	    flush_sf();
	X	    return;
	X	default:
	X	    fprintf(stderr, "unknown sf e4 type (x%02x)\n", sf_type);
	X	    flush_sf();
	X	    return;
	X	}
	X}
SHAR_EOF
if test 314 -ne "`wc -c < 'do_sfe4.c'`"
then
	echo shar: error transmitting "'do_sfe4.c'" '(should have been 314 characters)'
fi
chmod +x 'do_sfe4.c'
fi # end of overwriting check
echo shar: extracting "'do_sfe5.c'" '(430 characters)'
if test -f 'do_sfe5.c'
then
	echo shar: will not over-write existing file "'do_sfe5.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'do_sfe5.c'
	X#include "dca2troff.h"
	X/* structured field class e5 */
	Xdo_sfe5()
	X{
	X    switch(sf_type)
	X	{
	X	case 0x01:			/* MPB  - Bottom Margin Text Param */
	X	case 0x04:			/* MPT  - Top Margin Text Parameters */
	X	case 0x07:			/* PIP  - Page Image Parametrs */
	X	case 0x08:			/* PIN  - Page Image Numbering */
	X	    flush_sf();
	X	    return;
	X	default:
	X	    fprintf(stderr, "unknown sf e5 type (x%02x)\n", sf_type);
	X	    flush_sf();
	X	    return;
	X	}
	X}
SHAR_EOF
if test 430 -ne "`wc -c < 'do_sfe5.c'`"
then
	echo shar: error transmitting "'do_sfe5.c'" '(should have been 430 characters)'
fi
chmod +x 'do_sfe5.c'
fi # end of overwriting check
echo shar: extracting "'do_sfe6.c'" '(352 characters)'
if test -f 'do_sfe6.c'
then
	echo shar: will not over-write existing file "'do_sfe6.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'do_sfe6.c'
	X#include "dca2troff.h"
	X/* structured field class e6 */
	Xdo_sfe6()
	X{
	X    switch(sf_type)
	X	{
	X	case 0x01:			/* LP  - Line Parameters */
	X	case 0x02:			/* TP  - Tab Parameters */
	X	case 0x03:			/* LN  - Line Numbering */
	X	    flush_sf();
	X	    return;
	X	default:
	X	    fprintf(stderr, "unknown sf e6 type (x%02x)\n", sf_type);
	X	    flush_sf();
	X	    return;
	X	}
	X}
SHAR_EOF
if test 352 -ne "`wc -c < 'do_sfe6.c'`"
then
	echo shar: error transmitting "'do_sfe6.c'" '(should have been 352 characters)'
fi
chmod +x 'do_sfe6.c'
fi # end of overwriting check
echo shar: extracting "'do_sfe8.c'" '(626 characters)'
if test -f 'do_sfe8.c'
then
	echo shar: will not over-write existing file "'do_sfe8.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'do_sfe8.c'
	X#include "dca2troff.h"
	X/* structured field class e8 */
	Xdo_sfe8()
	X{
	X    switch(sf_type)
	X	{				/* Margin Text */
	X	case 0x01:			/* MTTA - Top Margin - All Pages */
	X	case 0x02:			/* MTTO - Top Margin - Odd Pages */
	X	case 0x03:			/* MTTE - Top Margin - Even Pages */
	X	case 0x04:			/* MTBA - Bottom Margin - All Pages */
	X	case 0x05:			/* MTBO - Bottom Margin - Odd Pages */
	X	case 0x06:			/* MTBE - Bottom Margin - Even Pages */
	X	    flush_sf();
	X	    return;
	X	case 0x07:			/* BT   - Body Text */
	X	    do_text();
	X	    return;
	X	default:
	X	    fprintf(stderr, "unknown sf e8 type (x%02x)\n", sf_type);
	X	    flush_sf();
	X	    return;
	X	}
	X}
SHAR_EOF
if test 626 -ne "`wc -c < 'do_sfe8.c'`"
then
	echo shar: error transmitting "'do_sfe8.c'" '(should have been 626 characters)'
fi
chmod +x 'do_sfe8.c'
fi # end of overwriting check
echo shar: extracting "'do_sfe9.c'" '(487 characters)'
if test -f 'do_sfe9.c'
then
	echo shar: will not over-write existing file "'do_sfe9.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'do_sfe9.c'
	X#include "dca2troff.h"
	X/* structured field class e9 */
	Xdo_sfe9()
	X{
	X    switch(sf_type)
	X	{
	X	case 0x01:			/* PFA  - Punct. Format. Arithmetic */
	X	case 0x02:			/* PFC  - Punct. Format. Character */
	X	case 0x03:			/* NFP  - Note Format Paramerers */
	X	case 0x04:			/* AOP  - Auto-Outline Parameters */
	X	case 0x05:			/* PFP  - Page Formating Paramerers */
	X	    flush_sf();
	X	    return;
	X	default:
	X	    fprintf(stderr, "unknown sf e9 type (x%02x)\n", sf_type);
	X	    flush_sf();
	X	    return;
	X	}
	X}
SHAR_EOF
if test 487 -ne "`wc -c < 'do_sfe9.c'`"
then
	echo shar: error transmitting "'do_sfe9.c'" '(should have been 487 characters)'
fi
chmod +x 'do_sfe9.c'
fi # end of overwriting check
echo shar: extracting "'do_single.c'" '(2069 characters)'
if test -f 'do_single.c'
then
	echo shar: will not over-write existing file "'do_single.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'do_single.c'
	X#include "dca2troff.h"
	X
	X/* single byte control character */
	Xdo_single(c)
	Xint c;
	X{
	X    switch (c)
	X	{
	X	case 0x05:			/* "HT"		tab */
	X		in_fcr = 1;
	X		outstr("\t");
	X		return;
	X	case 0x33:			/* "IRT"	index return */
	X	case 0x06:			/* "RCR"	required carrier ret */
	X		outstr("\n.br\n");
	X		if(in_it != 0)
	X			outstr(".in 0\n");
	X		in_it == 0;			/* reset in_it */
	X		return;
	X	case 0x09:			/* "SPS"	superscript */
	X		outstr("\\u");			/* up half a line */
	X		return;
	X	case 0x0c:			/* "PE"		page end */
	X		outstr("\n");
	X		return;
	X	case 0x0d:			/* "ZICR"	zero index carrier
	X							return */
	X		return;				/* go to pos 0 on current
	X						line */
	X	case 0x15:			/* "CRE"	carrier return */
	X		if ( in_fcr == 1)
	X			outstr("\n.br\n");		/* forced cr */
	X		else
	X			outstr("\n");			/* just an eol */
	X		in_fcr = 0;				/* reset in_fcr */
	X		return;
	X	case 0x16:			/* "BS"		backspace */
	X		outstr("\b");
	X		return;
	X	case 0x1a:			/* "UBS"	unit backspace */
	X		outstr("\b");
	X		return;
	X	case 0x23:			/* "WUS"	word underscore */
	X						/* back to last word break */
	X		printf("\\fI");			/* start the underscore */
	X		outachar('\177');		/* flush last word */
	X		printf("\\fR");			/* back to roman */
	X		return;
	X	case 0x25:			/* "INX"	index */
	X		return;				/* line feed? */
	X	case 0x36:			/* "NBS"	numeric backspace */
	X		outstr("\\h'-\\w'1'u'");
	X		return;
	X	case 0x38:			/* "SBS"	subscript */
	X		outstr("\\d");			/* down half a line */
	X		return;
	X	case 0x39:			/* "IT"		indent tab */
	X		in_fcr = 1;
	X		in_it = 1;
	X		outstr("\n'in+.5i\n");		/* move indent plus a stop */
	X		return;
	X	case 0x3a:			/* "RPE"	required page end */
	X		outstr("\n.bp\n");
	X		return;
	X	case 0x3f:			/* "SUB"	substitute */
	X		outstr("_");			/* inserted in place of err */
	X		return;
	X	case 0x40:			/* "SP"		space */
	X	case 0x41:
	X		outstr(" ");		/* "RSP"	required space */
	X		return;
	X	case 0x60:			/* "HYP"	required hyphen */
	X		outstr("-");
	X		return;
	X	case 0xca:			/* "SHY"	syllable hyphen */
	X		return;
	X	case 0xe1:			/* "NSP"	numeric space */
	X		outstr("\\h'\\w'1'u'");
	X		return;
	X	default:
	X		fprintf(stderr, "unknown single char code (x%02x)\n", c);
	X		exit(1);;
	X	}
	X}
SHAR_EOF
if test 2069 -ne "`wc -c < 'do_single.c'`"
then
	echo shar: error transmitting "'do_single.c'" '(should have been 2069 characters)'
fi
chmod +x 'do_single.c'
fi # end of overwriting check
echo shar: extracting "'do_spchar.c'" '(1543 characters)'
if test -f 'do_spchar.c'
then
	echo shar: will not over-write existing file "'do_spchar.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'do_spchar.c'
	X
	X/* special characters, not normally in troff */
	X/* should be read in from a file for each device/font */
	X/* we will output the 3rd field in the struct as a troff comment line */
	X/* if the 2nd field is null */
	X
	Xstruct spc {
	X	int spcode;			/* dca code for character */
	X	char *spstr;			/* titroff code for char on imagen */
	X	char *explan;			/* what is the char ? */
	X} spchar[] = {
	X		0x59, "\\(ss",		"german sharp s",
	X		0x70, "\\(O/",		"O slash",
	X		0x8a, "",		"European open quote",
	X		0x8b, "",		"European close quote",
	X		0x8c, "",		"d stroke",
	X		0x8e, "",		"small letter thorn",
	X		0x9f, "",		"international currency sym",
	X		0xa0, "",		"Micro",
	X		0xaa, "\\(!!",		"inverted !",
	X		0xab, "\\(??",		"inverted ?",
	X		0xac, "",		"D stroke",
	X		0xae, "",		"Capital Thorn",
	X		0xb1, "",		"Pound sign",
	X		0xb2, "",		"Yen",
	X		0xb3, "",		"Peseta",
	X		0xb4, "",		"Floren, Guilder",
	X		0xb6, "\\(pa",		"paragraph sign",
	X		0xbc, "\\(mc",		"overbar",
	X		0xbd, "\\(..",		"diaeresis",
	X		0xbf, "",		"double underscore",
	X		0xda, "\\(ui",		"dotless i",
	X		0xea, "\\u\\s-22\\s+2\\d",	"superscript 2",
	X		0xfa, "\\u\\s-23\\s+2\\d",	"superscript 3",
	X		0xff, "",		"Eight Ones",
	X		0x00, "",		""
	X};
	X
	X#include "dca2troff.h"
	X
	Xdo_spchar(ch)
	Xchar ch;
	X{
	X	int i;
	X	for(i=0; spchar[i].spcode != ch; i++)
	X		{
	X		if (spchar[i].spcode == 0)
	X			{
	X			fprintf(stderr, "error: unknown special char 0X%02x\n", ch);
	X			return(0);
	X			}
	X		}
	X	if(strcmp(spchar[i].spstr, "") == 0)
	X		{
	X		sprintf(tline, "\\\" %s\n", spchar[i].explan);
	X		outstr(tline);
	X		}
	X	else
	X		outstr(spchar[i].spstr);
	X	return(0);
	X}
SHAR_EOF
if test 1543 -ne "`wc -c < 'do_spchar.c'`"
then
	echo shar: error transmitting "'do_spchar.c'" '(should have been 1543 characters)'
fi
chmod +x 'do_spchar.c'
fi # end of overwriting check
echo shar: extracting "'do_text.c'" '(701 characters)'
if test -f 'do_text.c'
then
	echo shar: will not over-write existing file "'do_text.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'do_text.c'
	X#include "dca2troff.h"
	X#include "ebtab.h"
	X
	X/* text block */
	Xdo_text()
	X{
	X    int c;
	X    for ( ;; )
	X	{
	X	if ( sf_incnt >= sf_length )
	X		return;
	X	c = get1ch();
	X	c &= 0377;
	X	switch (ebaray[c].type)
	X	    {
	X	    case 0:		/* forget it */
	X		break;
	X	    case 1:		/* simple character string */
	X		outstr(ebaray[c].arg);
	X		break;
	X	    case 2:		/* single character control */
	X		do_single(c);
	X		break;
	X	    case 3:		/* multibyte control */
	X		do_multi();
	X		break;
	X	    case 4:		/* accented character */
	X		do_accent(ebaray[c].arg);
	X		break;
	X	    case 5:		/* troff special character */
	X		outstr(ebaray[c].arg);
	X		break;
	X	    case 6:		/* non-troff special character */
	X		do_spchar(ebaray[c].arg);
	X		break;
	X	
	X	    }
	X	}
	X}
SHAR_EOF
if test 701 -ne "`wc -c < 'do_text.c'`"
then
	echo shar: error transmitting "'do_text.c'" '(should have been 701 characters)'
fi
chmod +x 'do_text.c'
fi # end of overwriting check
echo shar: extracting "'externs.c'" '(1064 characters)'
if test -f 'externs.c'
then
	echo shar: will not over-write existing file "'externs.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'externs.c'
	X
	Xint in_fcr = 0;		/* if CRE and in_fcr, then required return */
	Xint in_it = 0;		/* in an indent tab */
	X
	Xint sf_length = 0;	/* length of structured field */
	Xint sf_class = 0;	/* class of structured field */
	Xint sf_type = 0;	/* type of structured field */
	Xint sf_format = 0;	/* format of structured field */
	X
	Xint mb_class = 0;	/* class of a multi byte command */
	Xint mb_count = 0;	/* size of a multi byte command */
	Xint mb_type = 0;	/* type of a multi byte command */
	X
	Xint blpt = 0;		/* pointer to output buffer */
	Xchar bufline[255];	 /* output buffer */
	X
	Xint sf_incnt = 0;	/* how many characters have we read in this sf */
	X
	Xchar ctemp;		/* some temp regs */
	Xchar dtemp;		/* some temp regs */
	Xchar etemp;		/* some temp regs */
	Xchar ftemp;		/* some temp regs */
	Xchar gtemp;		/* some temp regs */
	Xchar htemp;		/* some temp regs */
	X
	Xint itemp;		/* some temp regs */
	Xint jtemp;		/* some temp regs */
	Xint ktemp;		/* some temp regs */
	Xint ltemp;		/* some temp regs */
	Xint mtemp;		/* some temp regs */
	Xint ntemp;		/* some temp regs */
	X
	Xchar tline[255];	/* a temp buffer */
SHAR_EOF
if test 1064 -ne "`wc -c < 'externs.c'`"
then
	echo shar: error transmitting "'externs.c'" '(should have been 1064 characters)'
fi
chmod +x 'externs.c'
fi # end of overwriting check
echo shar: extracting "'getopt.c'" '(1437 characters)'
if test -f 'getopt.c'
then
	echo shar: will not over-write existing file "'getopt.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'getopt.c'
	X/* got this off net.sources */
	X#include <stdio.h>
	X
	X/*
	X * get option letter from argument vector
	X */
	Xint	opterr = 1,		/* useless, never set or used */
	X	optind = 1,		/* index into parent argv vector */
	X	optopt;			/* character checked for validity */
	Xchar	*optarg;		/* argument associated with option */
	X
	X#define BADCH	(int)'?'
	X#define EMSG	""
	X#define tell(s)	fputs(*nargv,stderr);fputs(s,stderr); \
	X		fputc(optopt,stderr);fputc('\n',stderr);return(BADCH);
	X
	Xgetopt(nargc,nargv,ostr)
	Xint	nargc;
	Xchar	**nargv,
	X	*ostr;
	X{
	X	static char	*place = EMSG;	/* option letter processing */
	X	register char	*oli;		/* option letter list index */
	X	char	*index();
	X
	X	if(!*place) {			/* update scanning pointer */
	X		if(optind >= nargc || *(place = nargv[optind]) != '-' || !*++place) return(EOF);
	X		if (*place == '-') {	/* found "--" */
	X			++optind;
	X			return(EOF);
	X		}
	X	}				/* option letter okay? */
	X	if ((optopt = (int)*place++) == (int)':' || !(oli = index(ostr,optopt))) {
	X		if(!*place) ++optind;
	X		tell(": illegal option -- ");
	X	}
	X	if (*++oli != ':') {		/* don't need argument */
	X		optarg = NULL;
	X		if (!*place) ++optind;
	X	}
	X	else {				/* need an argument */
	X		if (*place) optarg = place;	/* no white space */
	X		else if (nargc <= ++optind) {	/* no arg */
	X			place = EMSG;
	X			tell(": option requires an argument -- ");
	X		}
	X	 	else optarg = nargv[optind];	/* white space */
	X		place = EMSG;
	X		++optind;
	X	}
	X	return(optopt);			/* dump back option letter */
	X}
SHAR_EOF
if test 1437 -ne "`wc -c < 'getopt.c'`"
then
	echo shar: error transmitting "'getopt.c'" '(should have been 1437 characters)'
fi
chmod +x 'getopt.c'
fi # end of overwriting check
echo shar: extracting "'misc.c'" '(575 characters)'
if test -f 'misc.c'
then
	echo shar: will not over-write existing file "'misc.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'misc.c'
	X#include "dca2troff.h"
	X
	X
	Xdo_flush(count)
	Xint count;
	X{
	X    char c;
	X    if ( count == 0 )
	X	return;
	X    while ( count > 0 )
	X	{
	X	c = get1ch();
	X	--count;
	X	}
	X}
	X
	X/* flush a structured field */
	Xflush_sf()
	X{
	X	do_flush(sf_length - sf_incnt);
	X}
	X
	X/* get a char from stdin, increment the sf count */
	Xget1ch()
	X{
	X	++sf_incnt;
	X	return (getchar());
	X}
	X
	X/* get a 2 byte number from the input */
	Xget1num()
	X{
	X	int c, num;
	X	c = get1ch();		/* get 1st byte of length */
	X	if ( c == EOF )
	X		exit(0);	/* all done */
	X	c &= 0377;
	X	num = c << 8;
	X	c = get1ch();
	X	c &= 0377;
	X	num = num + c;
	X	return(num);
	X}
SHAR_EOF
if test 575 -ne "`wc -c < 'misc.c'`"
then
	echo shar: error transmitting "'misc.c'" '(should have been 575 characters)'
fi
chmod +x 'misc.c'
fi # end of overwriting check
echo shar: extracting "'outachar.c'" '(818 characters)'
if test -f 'outachar.c'
then
	echo shar: will not over-write existing file "'outachar.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'outachar.c'
	X#include "dca2troff.h"
	X
	X/* output a char to a buffer */
	X/*  so that the "underline previous word" will work */
	X/*  buffer flushed on seeing white space */
	X
	Xoutachar(c)
	Xchar c;
	X{
	X	int ic;
	X	ic = c;
	X	ic &= 0177;
	X	switch(ic)
	X	    {
	X	    case ' ':
	X	    case '\n':
	X	    case '\t':			/* flush buffer and new character */
	X		printf("%s", bufline);
	X		blpt = 0;
	X		bufline[blpt] = NULL;
	X		printf("%c", c);
	X		return;
	X	    case '\177':		/* flush buffer but don't dump char */
	X		printf("%s", bufline);
	X		blpt = 0;
	X		bufline[blpt] = NULL;
	X		return;
	X	    case NULL:
	X		return;			/* jic */
	X	    default:			/* store the character */
	X		bufline[blpt++] = c;
	X		bufline[blpt] = NULL;
	X		return;
	X	    }
	X}
	X
	Xoutstr(c)
	Xchar *c;
	X{
	X	char ic;
	X	if ( *c == NULL )
	X	    return;
	X	for (; *c != NULL; *c++)
	X	    {
	X	    ic = *c;
	X	    outachar(ic);
	X	    }
	X}
SHAR_EOF
if test 818 -ne "`wc -c < 'outachar.c'`"
then
	echo shar: error transmitting "'outachar.c'" '(should have been 818 characters)'
fi
chmod +x 'outachar.c'
fi # end of overwriting check
echo shar: extracting "'opts'" '(499 characters)'
if test -f 'opts'
then
	echo shar: will not over-write existing file "'opts'"
else
sed 's/^	X//' << \SHAR_EOF > 'opts'
	Xdca2troff [ -mm -me -ms -man ] [ -ff fontmap_file ] [ -af accent_file ] [ -d# ] [ infile ... ] 
	X
	X-mm, -me, -ms, -man
	X look for file /usr/local/lib/dca2.xx ( where xx is the macro pkg )
	X in there are function to macro name mappings
	X
	Xformat of fontmap_file
	X
	Xibm# <TAB> troff_font_name
	X
	Xformat of accent_file
	X
	Xhex code <TAB> troff_string to use
	X
	Xdebug levels: hex character
	X
	Xbit 0	- list font changes
	Xbit 1	- list sf commands
	Xbit 2	- list mb commands
	Xbit 3	- list single byte commands
	X
	Xadd page setups
SHAR_EOF
if test 499 -ne "`wc -c < 'opts'`"
then
	echo shar: error transmitting "'opts'" '(should have been 499 characters)'
fi
chmod +x 'opts'
fi # end of overwriting check
#	End of shell archive
exit 0
