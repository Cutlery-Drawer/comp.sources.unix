Subject:  v08i039:  UNaXcess Conferencing, version 1.00.02, Part03/04
Newsgroups: mod.sources
Approved: mirror!rs

Submitted by: abic!cwruecmp!allbery%ncoast.UUCP
Mod.sources: Volume 8, Issue 39
Archive-name: unaxcess2/Part03

#--------------------------------CUT HERE-------------------------------------
#! /bin/sh
#
# This is a shell archive.  Save this into a file, edit it
# and delete all lines above this comment.  Then give this
# file to sh by executing the command "sh file".  The files
# will be extracted into the current directory owned by
# you with default permissions.
#
# The files contained herein are:
#
# -rw-rw-rw-   1 allbery  System     17681 Feb  3 21:33 user.c
# -rw-rw-rw-   1 allbery  System      1424 Feb  3 21:34 user.h
# -rw-rw-rw-   1 allbery  System      1802 Feb  3 21:34 uwho.c
# -rw-rw-rw-   1 allbery  System      2501 Feb  3 21:45 Makefile
# -rw-rw-rw-   1 allbery  System     12568 Feb  3 21:28 install.sh
# -rw-r--r--   1 allbery  System      1184 Feb  3 21:30 reinstall.sh
# -rw-rw-rw-   1 allbery  System      1294 Nov 22 19:37 adminmenu.help
# -rw-rw-rw-   1 allbery  System      1082 Sep  7 22:15 mainmenu.help
# -rw-rw-rw-   1 allbery  System      1827 Sep  7 21:37 msgbase.help
# -rw-rw-rw-   1 allbery  System      1121 Sep  7 20:14 readcmds.help
#
echo 'x - user.c'
sed 's/^X//' << '________This_Is_The_END________' > user.c
X/*
X *	@(#)user.c	1.2 (TDI) 2/3/87
X *	@(#)Copyright (C) 1984, 85, 86, 87 by Brandon S. Allbery.
X *	@(#)This file is part of UNaXcess version 1.0.2.
X *
X *	Permission is hereby granted to copy and distribute this program
X *	freely.  Permission is NOT given to modify this program or distribute
X *	it at cost, except for charging a reasonable media/copying fee.
X */
X
X#ifndef lint
Xstatic char _FileID_[] = "@(#)user.c	1.2 (TDI) 2/3/87";
Xstatic char _UAID_[]   = "@(#)UNaXcess version 1.0.2";
X#endif lint
X
X#include "ua.h"
X
Xstruct user user;
Xstruct _himsg *hicnts;
X
Xgetuser(name, buf)
Xchar *name;
Xstruct user *buf; {
X	FILE *bfd;
X	char line[1024], lcuname[33], *p, *q;
X	int ncolon;
X
X	if ((bfd = fopen(PASSWD, "r")) == NULL) {
X		log("Error %d opening %s", errno, PASSWD);
X		panic("passwd");
X	}
X	for (p = name, q = lcuname; *p != '\0' && p - name <= 32; p++, q++)
X		*q = ToLower(*p);
X	*q = '\0';
X	while (fgets(line, sizeof line, bfd) != NULL)
X		if (strncmp(line, lcuname, strlen(lcuname)) == 0 && line[strlen(lcuname)] == ':') {
X			fclose(bfd);
X			buf->u_name[0] = '\0';
X			buf->u_pass[0] = '\0';
X			buf->u_access = A_NONE;
X			buf->u_login[0] = '\0';
X			buf->u_llen = 32;
X			buf->u_nbull = 0;
X			strcpy(buf->u_lconf, "general");
X			buf->u_lines = 16;
X			ncolon = 0;
X			for (p = line; *p != '\0'; p++)
X				if (*p == ':')
X					ncolon++;
X			if (ncolon < 5) {
X				log("Bad userfile entry for %s", lcuname);
X				return 0;
X			}
X			for (p = line, q = buf->u_name; *p != ':'; p++, q++)
X				*q = *p;
X			*q = '\0';
X			for (p++, q = buf->u_pass; *p != ':'; p++, q++)
X				*q = *p;
X			*q = '\0';
X			for (p++, q = lcuname; *p != ':'; p++, q++)
X				*q = *p;
X			*q = '\0';
X			buf->u_access = atoi(lcuname);
X			for (p++, q = buf->u_login; *p != ':'; p++, q++)
X				*q = *p;
X			*q = '\0';
X			for (p++, q = lcuname; *p != ':'; p++, q++)
X				*q = *p;
X			*q = '\0';
X			buf->u_llen = atoi(lcuname);
X			for (p++, q = lcuname; *p != ':'; p++, q++)
X				*q = *p;
X			*q = '\0';
X			buf->u_nbull = atoi(lcuname);
X			if (ncolon >= 6) {
X				for (p++, q = buf->u_lconf; *p != '\n' && *p != ':'; p++, q++)
X					*q = *p;
X				*q = '\0';
X			}
X			if (ncolon >= 7) {
X				for (p++, q = lcuname; *p != '\n'; p++, q++)
X					*q = *p;
X				*q = '\0';
X				buf->u_lines = atoi(lcuname);
X			}
X			return 1;
X		}
X	fclose(bfd);
X	return 0;
X}
X
Xputuser(name, ubuf)
Xchar *name;
Xstruct user *ubuf; {
X	FILE *fd, *tfd;
X	char line[1024], *tempfile = mktemp("/tmp/UptXXXXXX"), lcname[33], *p, *q;
X	static char lockfile[] = "userfil.lock";
X	short flag;
X
X	if (s_cmp(user.u_name, "guest") == 0)
X		return;
X	CRIT();
X	mklock(lockfile);
X	if ((fd = fopen(PASSWD, "r")) == NULL) {
X		log("Error %d opening %s", errno, PASSWD);
X		panic("passwd");
X	}
X	if ((tfd = fopen(tempfile, "w")) == NULL) {
X		log("Error %d opening %s", errno, tempfile);
X		panic("tmp");
X	}
X	flag = 0;
X	for (p = name, q = lcname; *p != '\0' && p - name < 33; p++, q++)
X		*q = ToLower(*p);
X	*q = 0;
X	while (fgets(line, sizeof line, fd) != NULL)
X		if (strncmp(line, lcname, strlen(lcname)) == 0 && line[strlen(lcname)] == ':') {
X			if (ubuf != (struct user *) 0)	/* not deleting */
X				fprintf(tfd, "%s:%s:%d:%s:%d:%d:%s:%d\n", ubuf->u_name, ubuf->u_pass, ubuf->u_access, ubuf->u_login, ubuf->u_llen, ubuf->u_nbull, ubuf->u_lconf, ubuf->u_lines);
X			flag++;
X		}
X		else
X			fputs(line, tfd);
X	if (!flag && ubuf != (struct user *) 0)
X		fprintf(tfd, "%s:%s:%d:%s:%d:%d:%s:%d\n", ubuf->u_name, ubuf->u_pass, ubuf->u_access, ubuf->u_login, ubuf->u_llen, ubuf->u_nbull, ubuf->u_lconf, ubuf->u_lines);
X	fclose(fd);
X	fclose(tfd);
X	unlink(PASSWD);
X	if (copylink(tempfile, PASSWD) < 0) {
X		log("Error %d copylinking %s to %s", errno, tempfile, PASSWD);
X		panic("copylink");
X	}
X	unlink(tempfile);
X	rmlock(lockfile);
X	NOCRIT();
X}
X
Xwritehigh(hilist)
Xstruct _himsg *hilist; {
X	FILE *hp, *f;
X	static char line[1024], hirec[1024];	/* 68000's have limited frames */
X	char *tmpf = mktemp("/tmp/RcXXXXXX");
X	char *eofflag;
X	static char lockfile[] = "newmsgs.lock";
X	struct _himsg *hptr;
X
X	if (s_cmp(user.u_name, "guest") == 0)
X		return;	/* don't write GUEST hirecs! */
X	CRIT();
X	if ((f = fopen(tmpf, "w")) == NULL) {
X		log("Error %d opening %s", errno, tmpf);
X		panic("tmp");
X	}
X	if ((hp = fopen(NEWMSGS, "r")) == NULL) {
X		log("Error %d opening %s", errno, NEWMSGS);
X		fclose(f);
X		unlink(tmpf);
X		panic("userind");
X	}
X	mklock(lockfile);
X	sprintf(line, "%s:", user.u_name);
X	while ((eofflag = fgets(hirec, sizeof hirec, hp)) != NULL) {
X		if (strncmp(hirec, line, strlen(line)) == 0)
X			break;
X		fputs(hirec, f);
X	}
X	if (eofflag != NULL)
X		while ((eofflag = fgets(hirec, sizeof hirec, hp)) != NULL)
X			if (hirec[0] != '\t' && hirec[0] != ' ')
X	   			break;
X	fputs(line, f);
X	putc('\n', f);
X	for (hptr = hilist; hptr != NULL; hptr = hptr->hi_next)
X		fprintf(f, "\t%s%c %d\n", hptr->hi_conf, (hptr->hi_uns == HI_UNSUB? '!': ':'), hptr->hi_num);
X	if (eofflag != NULL && hirec[0] != '\t' && hirec[0] != ' ')
X		fputs(hirec, f);
X	if (eofflag != NULL)
X		while (fgets(hirec, sizeof hirec, hp) != NULL)
X			fputs(hirec, f);
X	fclose(f);
X	fclose(hp);
X	unlink(NEWMSGS);
X	if (copylink(tmpf, NEWMSGS) < 0) {
X		log("Error %d copylinking %s to %s", errno, tmpf, NEWMSGS);
X		panic("copylink");
X	}
X	unlink(tmpf);
X	rmlock(lockfile);
X	NOCRIT();
X}
X
Xstruct _himsg *readhigh(foruser)
Xstruct user *foruser; {
X	static char hirec[1024];
X	char uidx[40], *p, *q;
X	FILE *f;
X	struct _himsg *workp, *initp;
X
X	strcpy(uidx, foruser->u_name);
X	strcat(uidx, ":");
X	if ((f = fopen(NEWMSGS, "r")) == NULL)
X		return NULL;
X	while (fgets(hirec, sizeof hirec, f) != NULL)
X		if (strncmp(hirec, uidx, strlen(uidx)) == 0)
X			break;
X	if (feof(f)) {
X		fclose(f);
X		return NULL;
X	}
X	workp = NULL;
X	initp = NULL;
X	while (fgets(hirec, sizeof hirec, f) != NULL && (hirec[0] == ' ' || hirec[0] == '\t')) {
X		hirec[strlen(hirec) - 1] = '\0';
X		for (p = hirec; *p == ' ' || *p == '\t'; p++)
X			;
X		for (q = uidx; *p != ' ' && *p != '\t' && *p != '\0' && *p != ':' && *p != '!'; p++)
X			*q++ = *p;
X		*q = '\0';
X		while (*p == ' ' || *p == '\t')
X			p++;
X		if (*p == '!') {	/* unsubscribed... */
X			if ((workp = (struct _himsg *) calloc((unsigned) 1, sizeof (struct _himsg))) == NULL) {
X				log("Error %d allocating _himsg for %s", errno, uidx);
X				panic("alloc");
X			}
X			strcpy(workp->hi_conf, uidx);
X			workp->hi_num = atoi(++p);
X			workp->hi_next = initp;
X			workp->hi_uns = HI_UNSUB;
X			initp = workp;
X			continue;
X		}
X		if (*p != ':') {
X			log("Invalid format of userind record: ``%s''", hirec);
X			writes("Your index is garbled; some conference\nhigh-message counts may be lost.");
X			break;
X		}
X		if ((workp = (struct _himsg *) calloc((unsigned) 1, sizeof (struct _himsg))) == NULL) {
X			log("Error %d allocating _himsg for %s", errno, uidx);
X			panic("alloc");
X		}
X		strcpy(workp->hi_conf, uidx);
X		workp->hi_num = atoi(++p);
X		workp->hi_next = initp;
X		workp->hi_uns = HI_SUBSCR;
X		initp = workp;
X	}
X	fclose(f);
X	return initp;
X}
X
Xnewuser() {
X	struct user nubuf, junk;
X	char line[256], addr[256], cityst[256], phone[256], uname[256], ckpass[256];
X	char *p;
X	FILE *newp;
X
X	dolog();
X	log("Entered newuser module.");
X	cat(NEWUSER);
X	writef("\nDo you still want to become a user? N\b");
X	line[0] = readc();
X	log("Become user? %c", line[0]);
X	if (line[0] != 'Y') {
X		writes("OK.  Goodbye, then.\n\n");
X		nolog();
X		cleanup();
X	}
X
XAgain:
X	do {
X		writef("What name would you like to use on this system?  It should not be\nmore than 32 letters long: ");
X		reads(line);
X		log("Name: %s", line);
X		if (line[0] == '\0' || line[0] == ' ') {
X			line[0] = '?';
X			p = line;
X			continue;
X		}
X		for (p = line; *p != '\0'; p++)
X			if (*p == ':') {
X				writes("Sorry, no colons allowed; they cause nasty surprises.");
X				log("Illegal colon in name");
X				break;
X			}
X	} while (*p != NULL);
X	if (getuser(nubuf.u_name, &junk)) {
X		writes("Sorry, but that name's already in use.  Please choose another.");
X		goto Again;
X	}
X	strncpy(nubuf.u_name, line, 32);
X	nubuf.u_name[32] = '\0';
X	writef("Please enter your street address: ");
X	reads(addr);
X	writef("Please enter your city and state: ");
X	reads(cityst);
X	writef("Please enter your home phone number: ");
X	reads(phone);
X	line[0] = '\0';
X	xecho();
X	do {
X		if (line[0] != 0)
X			writes("You made a typing error, or it's too short or too long.");
X		writef("Please enter a password of three to eight characters.\nIt will not be displayed: ");
X		reads(line);
X		log("Pass: %s", line);
X		writef("Please re-enter it, just to make sure: ");
X		reads(ckpass);
X		log("Ckpass: %s", ckpass);
X	} while (strlen(line) < 3 || strlen(line) > 8 || strcmp(line, ckpass) != 0);
X	doecho();
X	strcpy(nubuf.u_pass, line);
X	do {
X		writef("How many characters per line are on your terminal?  Please enter a number from 32 to 132, or <ENTER> for 80: ");
X		reads(line);
X		log("Line: %s", line);
X		if (line[0] == '\0')
X			nubuf.u_llen = 80;
X		else
X			nubuf.u_llen = atoi(line);
X	} while (nubuf.u_llen < 32 || nubuf.u_llen > 132);
X	do {
X		writef("How many lines are on your terminal?  Please enter a number from 0 to 66, or <ENTER> for 24: ");
X		reads(line);
X		log("Line: %s", line);
X		if (line[0] == '\0')
X			nubuf.u_lines = 24;
X		else
X			nubuf.u_lines = atoi(line);
X	} while (nubuf.u_lines < 0 || nubuf.u_lines > 66);
X	writef("If you are a regular (shell) user of this system, please enter your login name.  The sysop will verify it and grant you SYSTEM-level access.  If you are not a regular user, just press RETURN (ENTER).\n\nWhat is your Unix(R) login name on this sy

stem? ");
X	reads(uname);
X	writef("\nName:\t\t%s\nAddress:\t%s\nCity/State:\t%s\nPhone:\t\t%s\nPass:\t\t%s\nLine:\t\t%d\nScreen:\t\t%d\nLogname:\t%s\n\nIs this correct? N\b", nubuf.u_name, addr, cityst, phone, nubuf.u_pass, nubuf.u_llen, nubuf.u_lines, uname);
X	line[0] = readc();
X	log("Okay? %c", line[0]);
X	if (line[0] != 'Y')
X		goto Again;
X	writes("Encrypting password, please wait...");
X	strcpy(nubuf.u_pass, crypt(nubuf.u_pass, nubuf.u_pass) + 2);
X	strcpy(nubuf.u_login, user.u_login);/* default login name ( guest ?) */
X	nubuf.u_access = parms.ua_vaxs;
X	nubuf.u_nbull = 0;			/* no bulletins read yet */
X	strcpy(nubuf.u_lconf, "general");
X	writes("Recording user information...");
X	for (p = nubuf.u_name; *p != '\0'; p++)
X		*p = ToLower(*p);
X	putuser(nubuf.u_name, &nubuf);
X	CRIT();
X	mklock("newuser.lock");
X	if ((newp = fopen("newuser.log", "a")) == (FILE *) 0) {
X		log("Error %d opening newuser.log", errno);
X		panic("newlog");
X	}
X	fprintf(newp, "%s:%s:%s:%s:%s\n", nubuf.u_name, addr, cityst, phone, uname);
X	fclose(newp);
X	rmlock("newuser.lock");
X	NOCRIT();
X	user = nubuf;
X	nolog();
X}
X
Xuserlist() {
X	FILE *bfd, *wfd;
X	char line[1024], *p, *q, dbuf[20];
X	short ncolon;
X	struct user buf;
X
X	if ((bfd = fopen(PASSWD, "r")) == NULL) {
X		log("Error %d opening %s", errno, PASSWD);
X		panic("passwd");
X	}
X	if (user.u_access == A_WITNESS)
X		wfd = fopen("newuser.log", "r");
X	else
X		wfd = (FILE *) 0;
X	writes("\nList of UNaXcess users:\n");
X	while (fgets(line, 1024, bfd) != NULL) {
X		buf.u_name[0] = '\0';
X		buf.u_pass[0] = '\0';
X		buf.u_access = 0;
X		buf.u_login[0] = '\0';
X		buf.u_llen = 0;
X		buf.u_nbull = 0;
X		buf.u_lconf[0] = '\0';
X		ncolon = 0;
X		for (p = line; *p != '\0'; p++)
X			if (*p == ':')
X				ncolon++;
X		if (ncolon < 5) {
X			log("Bad usefile entry %.*s", strlen(line) - 1, line);
X			continue;
X		}
X		for (p = line, q = buf.u_name; *p != ':'; p++, q++)
X			*q = *p;
X		*q = '\0';
X		for (p++, q = buf.u_pass; *p != ':'; p++, q++)
X			*q = *p;
X		*q = '\0';
X		for (p++, q = dbuf; *p != ':'; p++, q++)
X			*q = *p;
X		*q = '\0';
X		buf.u_access = atoi(dbuf);
X		for (p++, q = buf.u_login; *p != ':'; p++, q++)
X			*q = *p;
X		*q = '\0';
X		for (p++, q = dbuf; *p != ':'; p++, q++)
X			*q = *p;
X		*q = '\0';
X		buf.u_llen = atoi(dbuf);
X		for (p++, q = dbuf; *p != ':'; p++, q++)
X			*q = *p;
X		*q = '\0';
X		buf.u_nbull = atoi(dbuf);
X		if (ncolon >= 6) {
X			for (p++, q = buf.u_lconf; *p != '\n'; p++, q++)
X				*q = *p;
X			*q = '\0';
X		}
X		if (buf.u_access == A_NONE || buf.u_access == A_MKUSER)
X			continue;
X		writef("%-32.32s  %s\n", upstr(buf.u_name), ua_acl(buf.u_access));
X		if (wfd != (FILE *) 0) {
X			rewind(wfd);
X			do {
X				if (fgets(line, sizeof line, wfd) == (char *) 0) {
X					buf.u_name[0] = '\0';
X					break;
X				}
X			} while (strncmp(line, buf.u_name, strlen(buf.u_name)) != 0 || line[strlen(buf.u_name)] != ':');
X			if (buf.u_name[0] == '\0')
X				continue;
X			p = &line[strlen(buf.u_name) + 1];
X			for (q = p; *q != ':'; q++)
X				;
X			*q++ = '\0';
X			writef("\t%s\n", p);
X			p = q;
X			for (q = p; *q != ':'; q++)
X				;
X			*q++ = '\0';
X			writef("\t%s\n", p);
X			p = q;
X			for (q = p; *q != ':'; q++)
X				;
X			*q++ = '\0';
X			writef("\tPhone: %s\n\n", p);
X		}
X	}
X	fclose(bfd);
X	return 1;
X}
X
Xchar *ua_acl(acl) {
X	switch (acl) {
X	case A_NONE:
X		return "Denied access";
X	case A_GUEST:
X		return "Guest";
X	case A_USER:
X		return "Messages";
X	case A_FILES:
X		return "File UDL";
X	case A_SYSTEM:
X		return "System";
X	case A_WITNESS:
X		return "Fairwitness";
X	case A_MKUSER:
X		return "New User";
X	default:
X		log("Invalid access level %d in userfile", acl);
X		return "???";
X	}
X}
X
Xvalidate() {
X	FILE *bfd, *wfd, *vfd;
X	struct user buf;
X	char line[1024], dbuf[20];
X	short ncolon;
X	char *p, *q, *vfile;
X	char ch;
X
X	if (user.u_access != A_WITNESS) {
X		log("Non-Witness attempted to validate users.");
X		writes("You aren't authorized to validate users.\n");
X		return 1;
X	}
X	if ((bfd = fopen(PASSWD, "r")) == NULL) {
X		log("Error %d opening %s", errno, PASSWD);
X		panic("passwd");
X	}
X	if ((wfd = fopen("newuser.log", "r")) == (FILE *) 0) {
X		log("Error %d opening newuser.log", errno);
X		panic("nuserlog");
X	}
X	vfile = mktemp("/tmp/uaVXXXXXX");
X	if ((vfd = fopen(vfile, "w")) == (FILE *) 0) {
X		log("Error %d opening %s", errno, vfile);
X		panic("valtemp");
X	}
X	while (fgets(line, sizeof line, bfd) != NULL) {	/* OOPS!  2/3/87 ++bsa */
X		buf.u_name[0] = '\0';
X		buf.u_pass[0] = '\0';
X		buf.u_access = 0;
X		buf.u_login[0] = '\0';
X		buf.u_llen = 0;
X		buf.u_nbull = 0;
X		buf.u_lconf[0] = '\0';
X		ncolon = 0;
X		for (p = line; *p != '\0'; p++)
X			if (*p == ':')
X				ncolon++;
X		if (ncolon < 5) {
X			log("Bad userfile entry %.*s", strlen(line) - 1, line);
X			continue;
X		}
X		for (p = line, q = buf.u_name; *p != ':'; p++, q++)
X			*q = *p;
X		*q = '\0';
X		for (p++, q = buf.u_pass; *p != ':'; p++, q++)
X			*q = *p;
X		*q = '\0';
X		for (p++, q = dbuf; *p != ':'; p++, q++)
X			*q = *p;
X		*q = '\0';
X		buf.u_access = atoi(dbuf);
X		for (p++, q = buf.u_login; *p != ':'; p++, q++)
X			*q = *p;
X		*q = '\0';
X		for (p++, q = dbuf; *p != ':'; p++, q++)
X			*q = *p;
X		*q = '\0';
X		buf.u_llen = atoi(dbuf);
X		for (p++, q = dbuf; *p != ':'; p++, q++)
X			*q = *p;
X		*q = '\0';
X		buf.u_nbull = atoi(dbuf);
X		if (ncolon >= 6) {
X			for (p++, q = buf.u_lconf; *p != '\n'; p++, q++)
X				*q = *p;
X			*q = '\0';
X		}
X		if (buf.u_access != parms.ua_vaxs)
X			continue;
X		rewind(wfd);
X		do {
X			if (fgets(line, sizeof line, wfd) == (char *) 0) {
X				buf.u_name[0] = '\0';
X				break;
X			}
X		} while (strncmp(line, buf.u_name, strlen(buf.u_name)) != 0 || line[strlen(buf.u_name)] != ':');
X		if (buf.u_name[0] == '\0')
X			continue;
X		writef("\n%-32.32s  %s\n", upstr(buf.u_name), ua_acl(buf.u_access));
X		writef("\tUNIX(R) name: `%s'\n\n", buf.u_login);
X		p = &line[strlen(buf.u_name) + 1];
X		for (q = p; *q != ':'; q++)
X			;
X		*q++ = '\0';
X		writef("\t%s\n", p);
X		p = q;
X		for (q = p; *q != ':'; q++)
X			;
X		*q++ = '\0';
X		writef("\t%s\n", p);
X		p = q;
X		for (q = p; *q != ':'; q++)
X			;
X		*q++ = '\0';
X		writef("\tPhone: %s\n", p);
X		log("Validating %s", buf.u_name);
X
Xvcmdloop:
X		writef("\nValidate, Kill, Deny access, Hold, Shell, Quit? ");
X		ch = readc();
X		log("V/K/D/H/S/Q? %c", ch);
X		switch (ch) {
X		case 'V':
X			writef("Validate for: Guest, Messages, Files, System, Witness? ");
X			ch = readc();
X			log("Access? %c", ch);
X			switch (ch) {
X			case 'G':
X				buf.u_access = A_GUEST;
X				break;
X			case 'M':
X				buf.u_access = A_USER;
X				break;
X			case 'F':
X				buf.u_access = A_FILES;
X				break;
X			case 'S':
X				buf.u_access = A_SYSTEM;
X				break;
X			case 'W':
X				buf.u_access = A_WITNESS;
X				break;
X			default:
X				writes("Unknown access level -- command aborted.");
X				goto vcmdloop;
X			}
X			fprintf(vfd, "%s:%d\n", buf.u_name, buf.u_access);
X			break;
X		case 'K':
X			writef("Kill user? N\b");
X			if (readc() != 'Y')
X				goto vcmdloop;
X			log("User killed.");
X			fprintf(vfd, "%s:-1\n", buf.u_name);
X			break;
X		case 'D':
X			log("Access set to A_NONE.");
X			buf.u_access = A_NONE;
X			fprintf(vfd, "%s:%d\n", buf.u_name, A_NONE);
X			break;
X		case 'H':
X			log("User held.");
X			break;
X		case 'S':
X			shell();
X			goto vcmdloop;
X		case 'Q':
X			fclose(bfd);
X			fclose(wfd);
X			fclose(vfd);
X			vinstall(vfile);
X			unlink(vfile);
X			return 1;
X		default:
X			writes("Please enter one of V, K, D, H, S, or Q.");
X			goto vcmdloop;
X		}
X	}
X	if (ferror(bfd))
X		log("Error %d on userfile\n", errno);
X	fclose(bfd);
X	fclose(wfd);
X	fclose(vfd);
X	vinstall(vfile);
X	unlink(vfile);
X	return 1;
X}
X
Xvinstall(vfile)
Xchar *vfile; {
X	FILE *vfd;
X	struct user vuser;
X	char vline[1024], vuname[33];
X	int vaccess;
X	
X	writec('\n');
X	if ((vfd = fopen(vfile, "r")) == (FILE *) 0) {
X		log("Error %d opening %s", errno, vfile);
X		writes("Can't open validation file.");
X		return;
X	}
X	while (fgets(vline, sizeof vline, vfd) != (char *) 0) {
X		sscanf(vline, "%[^:]:%d", vuname, &vaccess);
X		if (!getuser(vuname, &vuser)) {
X			writef("Lost user: %s\n", upstr(vuname));
X			continue;
X		}
X		if (vaccess == -1) {
X			putuser(vuname, (struct user *) 0);
X			writef("Killed user %s...\n", upstr(vuname));
X			continue;
X		}
X		vuser.u_access = vaccess;
X		putuser(vuname, &vuser);
X		if (vaccess == A_NONE)
X			writef("Denied access to user %s...\n", upstr(vuname));
X		else
X			writef("Validated user %s for %s access...\n", upstr(vuname), ua_acl(vaccess));
X	}
X	fclose(vfd);
X}
________This_Is_The_END________
echo 'x - user.h'
sed 's/^X//' << '________This_Is_The_END________' > user.h
X/*
X *	@(#)user.h	1.1 (TDI) 2/3/87
X *	@(#)Copyright (C) 1984, 85, 86, 87 by Brandon S. Allbery.
X *	@(#)This file is part of UNaXcess version 1.0.2.
X *
X *	Permission is hereby granted to copy and distribute this program
X *	freely.  Permission is NOT given to modify this program or distribute
X *	it at cost, except for charging a reasonable media/copying fee.
X */
X
Xstruct user {
X	char u_name[33];		/* user name */
X	char u_pass[12];		/* password */
X	short u_access;			/* can killmsg() or shell() ? */
X	char u_login[9];		/* Intended for system login name */
X	short u_llen;			/* line length, or default u_access */
X	short u_nbull;			/* highest numbered bulletin read */
X	char u_lconf[33];		/* login conference (dft = general) */
X	short u_lines;			/* lines per screen */
X};					/* current user */
X
Xextern struct user user;
X
X/* access modes, in u_access */
X
X#define A_NONE		0		/* invalidated login */
X#define A_GUEST		1		/* read-only access */
X#define A_USER		2		/* standard access */
X#define A_FILES		3		/* can udl() */
X#define A_SYSTEM	4		/* can system() */
X#define A_WITNESS	5		/* Fairwitness */
X#define A_MKUSER	6		/* Special: user creator */
X
Xstruct _himsg {
X	char hi_conf[33];		/* conference this record refers to */
X	char hi_uns;			/* unsubscribed to this conference */
X	short hi_num;			/* high message in this conference */
X	struct _himsg *hi_next;
X};
X
Xextern struct _himsg *hicnts;
X
X#define HI_SUBSCR	0
X#define HI_UNSUB	1
________This_Is_The_END________
echo 'x - uwho.c'
sed 's/^X//' << '________This_Is_The_END________' > uwho.c
X/*
X *	@(#)uwho.c	1.1 (TDI) 2/3/87
X *	@(#)Copyright (C) 1984, 85, 86, 87 by Brandon S. Allbery.
X *	@(#)This file is part of UNaXcess version 1.0.2.
X *
X *	Permission is hereby granted to copy and distribute this program
X *	freely.  Permission is NOT given to modify this program or distribute
X *	it at cost, except for charging a reasonable media/copying fee.
X */
X
X#ifndef lint
Xstatic char _FileID_[] = "@(#)uwho.c	1.1 (TDI) 2/3/87";
Xstatic char _UAID_[]   = "@(#)UNaXcess version 1.0.2";
X#endif lint
X
X#include <stdio.h>
X#include <pwd.h>
X#include <sys/types.h>
X#include <utmp.h>
X
X#ifndef NOAUTOPATH
Xstruct passwd *getpwuid();
X#endif  NOAUTOPATH
X
X#define TTYLIST "/etc/utmp"
X
Xmain(argc, argv)
Xchar **argv; {
X	int cnt, flg, users;
X	struct utmp user;
X	char tty[16];
X
X	if ((users = open(TTYLIST, 0)) < 0) {
X		fprintf(stderr, "%s: can't open %s\n", argv[0], TTYLIST);
X		exit(1);
X	}
X	flg = 0;
X	while (read(users, &user, sizeof user) > 0) {
X#ifdef SYS5
X		if (user.ut_type != USER_PROCESS)
X			continue;
X#else  SYS5
X		if (user.ut_name[0] == '\0')
X			continue;
X#endif SYS5
X		sprintf(tty, "/dev/%.*s", sizeof user.ut_line, user.ut_line);
X		if (argc < 2)
X			showme(&tty[5]);
X		else
X			for (cnt = 1; argv[cnt] != NULL; cnt++)
X				if (strcmp(&tty[5], argv[cnt]) == 0) {
X					showme(&tty[5]);
X					break;
X				}
X	}
X	exit(0);
X}
X
Xshowme(ttyf)
Xchar *ttyf;
X{
X	FILE *fp;
X	char line[1024];
X#ifndef NOAUTOPATH
X	static char home[1024] = "";
X#endif NOAUTOPATH
X
X#ifdef NOAUTOPATH
X	sprintf(line, "%s/%s", NOAUTOPATH, ttyf);
X#else
X	if (home[0] == '\0')
X		strcpy(home, getpwuid(geteuid())->pw_dir);
X	sprintf(line, "%s/%s", home, ttyf);
X#endif NOAUTOPATH
X	if ((fp = fopen(line, "r")) == NULL)	/* not in use on this tty */
X		return;
X	fgets(line, 1024, fp);
X	printf("%s: %s", ttyf, line);		/* line already has newline */
X	fclose(fp);
X}
________This_Is_The_END________
echo 'x - Makefile'
sed 's/^X//' << '________This_Is_The_END________' > Makefile
X#
X# Makefile for UNaXcess Conferencing, version 1.00.02
X#
X
XSHELL = /bin/sh
X# make on sys3 is not very nice when it comes to standard shell interfaces...
X
X# ``make SYSTEM=(SYS3|SYS5|V7|BSD|XENIX|XENIX3|XENIX5) all''
X# Use V7     for V7, XENIX 2.x, and BSD pre-4.2 (+ bastardizations of same)
X#     BSD    for BSD 4.2 and 4.3
X#     SYS3   for real AT&T System III
X#     SYS5   for real AT&T System V revisions 1 and 2
X#     XENIX3 for Xenix v3.x, Unisoft System III, and other bastardized V7's
X#     XENIX5 for Xenix V5.x and other bastardized V7's with System V libraries
X#            (If Xenix 5.x has /etc/inittab, then I messed up; use SYS5.)
X# You're on your own if it's a really odd combo.
X# Pyramid 90x:  use either universe.  SYS5 is best tested; BSD has bigger
X# conference names and many performance pluses (extra-fast conference
X# creation; I don't know if the 4.2 directory stuff is implemented in kernel
X# or not, so I don't know if you gain -- but libndir is SLOW!).
X
XCFLAGS = -D$(SYSTEM) -O
XLINT = 
X# the above line should be modified on systems other than USG Unix(R), as
X# USG Unix(R) defaults to the major checks.  Don't bother with -p, as UNaXcess
X# is definitely not designed to work anywhere other than Unix(R).
X
XOBJS = ua.o message.o conference.o date.o bulletin.o system.o user.o dir.o \
X       fileudl.o io.o
XSRC  = ua.c message.c conference.c date.c bulletin.c system.c user.c dir.c \
X       fileudl.c io.c
XHDR  = ua.h user.h system.h dir.h
XUTIL = install.sh mkconf.c udate.c uwho.c
XSRCS = $(SRC) $(UTIL)
X
Xall: system ua uwho udate mkconf mvmsg guide
Xlint: system lintcheck
X
Xinstall: all
X	-sh install.sh
X
Xua: $(OBJS)
X	$(CC) -o ua $(OBJS)
X
Xudate: udate.o date.o
X	cc -O -o udate udate.o date.o
X
X$(OBJS): $(HDR)
X
Xclean:
X	rm -f ua uwho udate upost mkconf umotd *.o tags core ua.shar* mvmsg unaxcess.tar
X
Xtags: $(SRC) $(HDR)
X	ctags $(SRC) $(HDR)
X
Xshar:
X	mkshar -v -s 65000 -h ua.shar README *.[chl] Makefile *.sh *.help *.man
X
Xtar:
X	tar cvf unaxcess.tar README *.[chl] Makefile *.sh *.help *.man
X
Xedall: %edall
X	for file in *.[chl] Makefile *.sh; do\
X		sh %edall $$file;\
X	done
X
Xsystem:
X	expr	"$(SYSTEM)" = V7 \| \
X		"$(SYSTEM)" = SYS3 \| \
X		"$(SYSTEM)" = SYS5 \| \
X		"$(SYSTEM)" = BSD \| \
X		"$(SYSTEM)" = XENIX \| \
X		"$(SYSTEM)" = XENIX3 \| \
X		"$(SYSTEM)" = XENIX5
X
Xlintcheck:
X	lint $(LINT) -D$(SYSTEM) $(SRC)
X
Xguide: guide.man
X	nroff -man guide.man > guide
X
Xuwho: uwho.o
X	$(CC) -o uwho uwho.o
X
Xmkconf: mkconf.o
X	$(CC) -o mkconf mkconf.o
X
Xmvmsg: mvmsg.o
X	$(CC) -o mvmsg mvmsg.o
________This_Is_The_END________
echo 'x - install.sh'
sed 's/^X//' << '________This_Is_The_END________' > install.sh
X:
X: install.sh
X: install UNaXcess 1.00.02
X: Brandon S. Allbery
X: This script is not copyrighted
X:
X
XPATH=:/bin:/usr/bin:/usr/ucb:/etc:/usr/plx
Xcat - << --EOF--
X
X		    UNaXcess 1.00.02 Installation Script
X		    ------------------------------------
X
X	This script requires that (1) you have NOAUTOPATH defined, or
X	(2) you be running as root.  If you are not running as root,
X	the "mkconf" program cannot be installed.
X
X	(On BSD systems, root permissions are required only if the
X	UNaXcess owner does not exist.  Note that if you are not running
X	as root, you will receive spurious error messages from chown.
X	You may ignore these messages.)
X
X--EOF--
Xgrep NOAUTOPATH Makefile > /dev/null 2>&1
Xcase "$?" in
X1)      autopath=y
X	;;
X0)      autopath=n
X	UAHOME="`grep NOAUTOPATH Makefile | sed -n 's/.*[       ]-DAUTOPATH=[^-A-Za-z\/.]*\([-A-Za-z\/.][-A-Za-z\/.]*\).*$/\1/p'`"
X	if test ! -w "$UAHOME"; then
X		echo "No write permission in $UAHOME.  Installation aborted."
X		exit 1
X	fi
X	UAOWNER=${LOGNAME-${USER?'Who are you?'}}
X	;;
X2)      echo "Please re-run install.sh from the installation directory."
X	exit 1
X	;;
X*)      echo "Your grep does funny things.  You'll have to install UNaXcess by hand."
X	exit 1
X	;;
Xesac
Xcase $autopath in
Xy)      if test ! -f /vmunix -a ! -w /etc/passwd; then
X		echo "Root permissions are required.  Installation aborted."
X		exit 1
X	fi
X	echo "Please enter the username of the owner of this UNaXcess system."
X	echo "(Press RETURN to abort installation.)"
X	read UAOWNER
X	case "$UAOWNER" in
X	"")     echo "Installation aborted."
X		exit 1
X		;;
X	esac
X	if grep "^$UAOWNER:" /etc/passwd >/dev/null 2>&1; then
X		echo "User $UAOWNER already exists.  Do you want to use it (Y/N)?"
X		read yesno
X		case "$yesno" in
X		y*|Y*)  ;;
X		*)      echo "Installation aborted."
X			exit 1
X			;;
X		esac
X	else
X		if test -f /vmunix -a ! -w /etc/passwd; then
X			echo "Please create the user and re-run install.sh.  Installation aborted."
X			exit 1
X		fi
X		echo "Create $UAOWNER (Y/N)?"
X		read yesno
X		case "$yesno" in
X		y*|Y*)  ;;
X		*)      echo "Installation aborted."
X			exit 1
X			;;
X		esac
X		UAUID=`sed 's/^[^:]*:[^:]*:\([^:]*\):.*$/\1/' < /etc/passwd | sort -n | tail -1`
X		UAUID=`expr $UAUID + 1`
X		echo "The BBS directory will be /usr/$UAOWNER.  Press RETURN to accept, or"
X		echo "enter a directory name."
X		read home
X		case "$home" in
X		"")     home=/usr/$UAOWNER
X			;;
X		esac
X		if test -r $home; then
X			echo "$home exists.  Please choose a different directory.  Installation aborted."
X			exit 1
X		fi
X		echo "$UAOWNER::$UAUID:1:UNaXcess Control Login:$home:" >> /etc/passwd
X		mkdir $home
X		chown $UAOWNER $home
X		echo "Please give $UAOWNER a password.  DON'T LEAVE IT UNPROTECTED!!!"
X		passwd $UAOWNER
X	fi
X	echo ""
X	UAHOME="`sed -n '/^'$UAOWNER':/s=^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\):.*\$=\1=p' < /etc/passwd`"
X	;;
Xn)      ;;
Xesac
Xecho "UNaXcess will be installed in $UAHOME.  Is this okay (Y/N)?"
Xread yesno
Xcase "$yesno" in
Xy*|Y*)  ;;
X*)      echo "Please check /etc/passwd for $UAOWNER's home directory, and fix it."
X	echo "Then type 'sh install.sh' to try installation again."
X	exit 1
X	;;
Xesac
X#chmod 711 $UAHOME || echo "Please inspect the permissions on $UAHOME; they should be -rwx--x--x."
Xif test ! -d $UAHOME/msgdir; then
Xecho "Creating $UAHOME/msgdir..."
X	rm -f $UAHOME/msgdir
X	mkdir $UAHOME/msgdir
X	chown $UAOWNER $UAHOME/msgdir
Xfi
Xif test ! -d $UAHOME/motd; then
X	echo "Creating $UAHOME/motd..."
X	rm -f $UAHOME/motd
X	mkdir $UAHOME/motd
X	chown $UAOWNER $UAHOME/motd
Xfi
Xif test ! -d $UAHOME/library; then
X	echo "Creating $UAHOME/library..."
X	rm -f $UAHOME/library
X	mkdir $UAHOME/library
X	chown $UAOWNER $UAHOME/library
Xfi
Xif test ! -d $UAHOME/uploads; then
X	echo "Creating $UAHOME/uploads..."
X	rm -f $UAHOME/uploads
X	mkdir $UAHOME/uploads
X	chown $UAOWNER $UAHOME/uploads
Xfi
Xecho "Creating $UAHOME/Logfile..."
Xrm -f $UAHOME/Logfile
Xchown $UAOWNER $UAHOME/Logfile > $UAHOME/Logfile
Xif test ! -f $UAHOME/userind; then
X	echo "Creating $UAHOME/userind..."
X	rm -rf $OAHOME/userind
X	chown $UAOWNER $UAHOME/userind > $UAHOME/userind
Xfi
Xif test ! -d $UAHOME/lock; then
X	echo "Creating $UAHOME/lock..."
X	rm -f $UAHOME/lock
X	mkdir $UAHOME/lock
X	chown $UAOWNER $UAHOME/lock
Xfi
Xif test ! -d $UAHOME/members; then
X	echo "Creating $UAHOME/members..."
X	rm -f $UAHOME/members
X	mkdir $UAHOME/members
X	chown $UAOWNER $UAHOME/members
Xfi
Xif test ! -d $UAHOME/msgdir/general; then
X	echo "Creating conference general..."
X	rm -f $UAHOME/msgdir/general
X	mkdir $UAHOME/msgdir/general
X	chown $UAOWNER $UAHOME/msgdir/general
X	echo 1 > $UAHOME/msgdir/general/himsg
X	chown $UAOWNER $UAHOME/msgdir/general/himsg
X	cat << --general/1-- > $UAHOME/msgdir/general/1
XDate: `./udate`
XFrom: SYSOP
XTo: All
XSubject: This BBS
X
XWelcome to UNaXcess V1.00.02 -- a computer bulletin board system designed for the UNIX(R) operating system.  You're using the ONLY BBS which is designed to USE Unix's unique features to their fullest potential.
X
XThis conference is the general-purpose conference.  Use it for discussions that don't fit in any of the existing conferences.  But if it's liable to be large, consider making a new conference for it.
X
XThe basic UNaXcess commands are:
X
XM - Enter the Message Base menu.
XG - Exit UNaXcess.
XF - Enter the File UDL Section.  UNaXcess is capable of file uploading and downloading with ASCII, Xmodem and Kermit (not all may be available on all systems).
X? - Help.  Press it once for one-line descriptions, press it again for the help file.
X
XPress BREAK or CONTROL C to stop a command.
XPress CONTROL-\ (CONTROL plus backslash) for a fast logout.
X
XThe UNaXcess User's Guide is available in the File UDL Area for those who have File UDL access.
X
X--SYSOP
X--general/1--
Xfi
Xif test ! -d $UAHOME/msgdir/guest; then
X        echo "Creating conference guest..."
X        rm -rf $UAHOME/msgdir/guest
X        mkdir $UAHOME/msgdir/guest
X        chown $UAOWNER $UAHOME/msgdir/guest
X        echo 1 > $UAHOME/msgdir/guest/himsg
X        chown $UAOWNER $UAHOME/msgdir/guest/himsg
X        cat << --guest/1-- > $UAHOME/msgdir/guest/1
XDate: `./udate`
XFrom: SYSOP
XTo: All
XSubject: This conference
X
XThis conference is for any and all users of UNaXcess.  ANYONE may post messages to the guest conference at any time.
X
X--SYSOP
X--guest/1--
Xfi
Xecho "The programs will be placed in /usr/bin.  Press RETURN to accept, or enter"
Xecho "a different directory."
Xread BIN
Xcase "$BIN" in
X"")	BIN=/usr/bin
X	;;
X*)	;;
Xesac
Xif test ! -d $BIN; then
X	echo "$BIN does not exist.  Please create it.  Installation stopped."
X	exit 1
Xfi
Xecho "The UNaXcess program will be called ua.  Press RETURN to accept, or enter"
Xecho "a different name."
Xread ua
Xcase "$ua" in
X"")	ua="ua"
Xesac
Xecho "The user lister will be called uwho.  Press ENTER to accept, or enter a"
Xecho "different name."
Xread uwho
Xcase "$uwho" in
X"")	uwho="uwho"
Xesac
Xecho "Creating $BIN/$ua..."
Xcp ua $BIN/$ua
Xchown $UAOWNER $BIN/$ua
Xchmod 711 $BIN/$ua
Xcase $autopath in
Xy)	chmod 4711 $BIN/$ua
X	;;
Xesac
Xecho "Creating $BIN/$uwho..."
Xcp uwho $BIN/$uwho
Xchmod 711 $BIN/$uwho
Xcase $autopath in
Xy)      chown $UAOWNER $BIN/$uwho
X	chmod 4711 $BIN/$uwho
X	if test ! -f /vmunix; then
X		echo "Creating $UAHOME/mkconf..."
X		cp mkconf $UAHOME/mkconf
X		chown root $UAHOME/mkconf
X		chmod 4711 $UAHOME/mkconf
X	fi
X	;;
Xesac
Xecho "The conference maintenance utility will be called mvmsg.  Press RETURN to"
Xecho "accept, or enter a different name."
Xread mvmsg
Xcase "$mvmsg" in
X"")     mvmsg="mvmsg"
X	;;
Xesac
Xecho "Creating $BIN/$mvmsg..."
Xcp mvmsg $BIN/$mvmsg
Xcase $autopath in
Xy)	chown $UAOWNER $BIN/$mvmsg
X	chmod 4700 $BIN/$mvmsg
X	;;
Xesac
Xcat - << --CONF--
X
XYou will be asked a series of configuration questions.  If you have not read
Xthe UNaXcess Installation Manual, please do so before answering them.  You
Xmay hit DEL (or CONTROL-C or etc.) to exit this script if you need to.
X
X--CONF--
Xecho "Do you want to allow READ-ONLY conferences (Y)?"
Xread yesno
Xcase "$yesno" in
Xn*|N*)	readonly=NO
X	;;
X*)      readonly=YES
X	;;
Xesac
Xecho "Do you want to allow restricted conferences (N)?"
Xread yesno
Xcase "$yesno" in
Xy*|Y*)	xrated=YES
X	;;
X*)      xrated=NO
Xesac
Xecho "The default shell for the C command will be /bin/sh.  Press RETURN to accept,"
Xecho "or enter an alternative shell."
Xread shell
Xcase "$shell" in
X"")     shell=/bin/sh
X	;;
Xesac
Xif test ! -f "$shell"; then
X	echo "The shell $shell does not exist.  Installation stopped."
X	exit 1
Xfi
Xecho "Do you want UNaXcess to check the user's environment for a preferred"
Xecho "shell (Y)?"
Xread env
Xcase "$env" in
XN*|n*)  env=NO
X	;;
X*)      env=YES
X	;;
Xesac
Xecho "Enter the UNIX login names of all logins which will run UNaXcess as the"
Xecho "login shell.  Press RETURN if there will be none."
Xread bbsuser
Xwhile :; do
X	echo "Enter the time limit for UNaXcess users, in minutes; 0 for no limit (30):"
X	read tlimit
X	case "$tlimit" in
X	"")     tlimit=30
X	esac
X	check="`echo \"$tlimit\" | sed 's/[0-9]//gp'`"
X	if test -n "$check" -o $tlimit -gt 32000; then
X		echo "Please enter a number between 0 and 32000."
X	else
X		break
X	fi
Xdone
Xecho "The SYSOP's UNaXcess login name will be SYSOP.  Press RETURN to accept, or"
Xecho "enter a different name."
Xread sysop
Xcase "$sysop" in
X"")     sysop="sysop"
X	;;
Xesac
Xsysop="`echo \"$sysop\" | sed 's/://g
X			       s/^\(................................\).*$/\1/'`"
Xecho "Do you want to allow private messages (Y)?"
Xread private
Xcase "$private" in
XN*|n*)  private=NO
X	;;
X*)      private=YES
X	;;
Xesac
Xecho "Do you want to enable logging (N)?"
Xread logging
Xcase "$logging" in
XY*|y*)  logging=YES
X	;;
X*)      logging=NO
X	;;
Xesac
Xwhile :; do
X	echo "How many tries should a user get to log in -- 0 means no limit (3)?"
X	read logtries
X	case "$logtries" in
X	"")     logtries=3
X	esac
X	check="`echo \"$logtries\" | sed 's/[0-9]//gp'`"
X	if test -n "$check" -o "$logtries" -gt 32000; then
X		echo "Please enter a number between 0 and 32000."
X	else
X		break
X	fi
Xdone
Xecho ""
Xecho "Creating $UAHOME/ua-config..."
Xcat << --CONFIG-- > $UAHOME/ua-config
Xreadonly	$readonly
Xrestricted	$xrated
Xshell		$shell
Xread-env	$env
Xbbs-user	$bbsuser
Xtime-limit      $tlimit
Xsysop		"$sysop"
Xprivate-msgs    $private
Xlogging		$logging
Xbanner		""
Xlogin-msg	""
Xlogin-tries	$logtries
Xvalidation-level	1
X--CONFIG--
Xchown $UAOWNER $UAHOME/ua-config
Xchmod 644 $UAHOME/ua-config
Xecho ""
Xecho "You can edit the config file yourself to change these and other options."
Xecho "Read the UNaXcess Administration manual for details."
Xecho ""
Xif test ! -f $UAHOME/userfile; then
X	echo "Creating $UAHOME/userfile..."
X	rm -rf $UAHOME/userfile
X	cat << --USERFILE-- > $UAHOME/userfile
X$sysop::5::80:0:general:24
Xnew::6::2:0::0
Xguest::1::40:0:guest:16
X--USERFILE--
X	chown $UAOWNER $UAHOME/userfile
X	chmod 644 $UAHOME/userfile
Xfi
Xecho ""
Xif test ! -r $UAHOME/directory; then
X	rm -rf $UAHOME/directory
X	today="at-install"	# OOPS! 2 lines deleted, this line changed
X				# 2/3/87 ++bsa
X	echo "Creating $UAHOME/directory..."
X	cat << --LIBCATLG-- > $UAHOME/directory
XGENERAL file branch; $today by $sysop: General up/downloading
XGENERAL file GUIDE.UA; $today by $sysop: The UNaXcess User's Guide
X--LIBCATLG--
X	chown $UAOWNER $UAHOME/directory
X	chmod 644 $UAHOME/directory
Xfi
Xif test ! -f $UAHOME/upload-log; then
X	rm -rf $UAHOME/upload-log
X	echo "Creating $UAHOME/upload-log..."
X	cp /dev/null $UAHOME/upload-log
X	chown $UAOWNER $UAHOME/upload-log
X	chmod 644 $UAHOME/upload-log
Xfi
Xif test ! -d $UAHOME/library/general; then
X	echo "Creating File UDL branch general..."
X	rm -f $UAHOME/library/general
X	mkdir $UAHOME/library/general
X	cp guide $UAHOME/library/general/guide.ua
Xfi
Xif test ! -f $UAHOME/NewMessage; then
X	echo ""
X	echo "Creating the new-user bulletin.  See the UNaXcess Administrator's Manual"
X	echo "in order to change it."
X	echo ""
X	echo "Creating $UAHOME/NewMessage..."
Xcat << --NEWMESSAGE-- > $UAHOME/NewMessage
X
XWelcome to UNaXcess 1.00.02, Copyright (C) 1984-1987 by Brandon S. Allbery.  This UNaXcess was installed `./udate`.
X
XYou are requested to register with your full name, and give your full address and phone number.
X
X--NEWMESSAGE--
X	chown $UAOWNER $UAHOME/NewMessage
X	chmod 644 $UAHOME/NewMessage
Xfi
Xif test ! -f $UAHOME/motd/himotd; then
X	echo "Creating $UAHOME/motd/himotd..."
X	echo 0 > $UAHOME/motd/himotd
X	chown $UAOWNER $UAHOME/motd/himotd
X	chmod 644 $UAHOME/motd/himotd
Xfi
Xif test -d $UAHOME/help; then
X	rm -rf $UAHOME/help
Xfi
Xecho "Creating $UAHOME/help..."
Xmkdir $UAHOME/help
Xcp mainmenu.help $UAHOME/help/mainmenu
Xcp msgbase.help $UAHOME/help/msgbase
Xcp adminmenu.help $UAHOME/help/adminmenu
Xcp readcmds.help $UAHOME/help/readcmds
Xecho ""
Xecho "UNaXcess Conferencing 1.00.02 Installation complete."
Xexit 0
________This_Is_The_END________
echo 'x - reinstall.sh'
sed 's/^X//' << '________This_Is_The_END________' > reinstall.sh
X: reinstall script
X: used to upgrade V1.00.00 to 1.00.01 or later
Xcd "$1" || {
X	echo "usage: sh reinstall.sh bbs-directory" >&2
X	exit 1
X}
Xtest -w ua-config || {
X	echo "reinstall.sh: wrong directory or wrong user; must be able to write config files" >&2
X	exit 1
X}
Xbbsdir="`grep '^bbs-directory[ 	]' ua-config | sed 's/^bbs-directory[ 	][ 	]*\"*\([^\"][^\"]*\).*$/\1/`"
Xcase "$bbsdir" in
X"")	bbsdir="$1"
X	;;
Xesac
Xed - ua-config << \EOF:ua_config
Xg/^x-rated[ 	]/s//restricted	/
X$a
Xvalidation-level	1
X.
Xw
Xq
XEOF:ua-config
Xcd "$bbsdir" || {
X	echo "reinstall.sh: the BBS directory specified by ua-config is bad"
X	exit 1
X}
Xed - userfile << \EOF:userfile
Xg/^\([^:][^:]*:[^:][^:]*:0*5\):[0-9][0-9]*:\([0-9][0-9]*:[^:][^:]*\):.*$/s//\1:40:\2:16/
Xw
Xq
XEOF:userfile
Xcat << EOF:message
XThe system new-user validation level has been set to Guest (1); you may change
Xit by editing the "validation-level" parameter in the ua-config file.  (See the
XUNaXcess Administration Guide for more information.)
X
XAll new-user logins have been set to 16 lines of 40 characters.  These may be
Xchanged via the Alter command of UNaXcess; again, see the UNaXcess Adminis-
Xtration Guide for details.
XEOF:message
Xexit 0
________This_Is_The_END________
echo 'x - adminmenu.help'
sed 's/^X//' << '________This_Is_The_END________' > adminmenu.help
XUNaXcess Administration Commands
X--------------------------------
X
XA - Alter or examine a user.  For non-Fairwitnesses, you can only look at yourself.  FWs can look at any user.  It's most commomly used by FWs to validate users, and by other users to look at their access level, change their password or terminal informat

ion (lines/screen, line length).
X
XB - Enter a bulletin.  Only Fairwitnesses (and the Sysop) can do this.
X
XC - Command access.  This command, for users of System access and higher, runs a shell.  Type CONTROL-D to return to UNaXcess.
X
XE - Edit conference restrictions.  Only Fairwitnesses may use this command; in addition, only the Sysop or a Fairwitness who is a member of a restricted conference may change the restrictions on the conference.  Only the Sysop may restrict or un-restrict

 a conference.
X
XG - Goodbye.  If executed from the "read loop" via the Xecute command -- the prompt displayed after a message -- you will be returned to the read loop.  Otherwise, you will be asked if you really want to log out, and if so you will be logged out.
X
XV - Validate new users.  Only Fairwitnesses (and the Sysop) may use this command.
X
XW - Who's been on.  This shows the userlog, including names and access levels. Fairwitnesses can see addresses and phone numbers as well.
________This_Is_The_END________
echo 'x - mainmenu.help'
sed 's/^X//' << '________This_Is_The_END________' > mainmenu.help
XUNaXcess Main Menu Commands
X---------------------------
X
XA - The Administration Menu.  Type ? from the administration menu for help.  Some commands (notable the Alter command), are of use to all UNaXcess users.
X
XB - Redisplay the latest UNaXcess bulletins.
X
XC - Command access.  This command, for users of System access and higher, runs a shell.  Type CONTROL-D to return to UNaXcess.
X
XF - File UDL area (upload/download).  Users who have less than File UDL access may look at the available files for downloading, including downloading the file lists.  File UDL access or greater is required for uploading or downloading.
X
XG - Goodbye.  If executed from the "read loop" via the Xecute command -- the prompt displayed after a message -- you will be returned to the read loop.  Otherwise, you will be asked if you really want to log out, and if so you will be logged out.
X
XM - The Message Base Menu.  Type ? from the message base menu for help.
X
XW - Who's been on.  This shows the userlog, including names and access levels. Fairwitnesses can see addresses and phone numbers as well.
________This_Is_The_END________
echo 'x - msgbase.help'
sed 's/^X//' << '________This_Is_The_END________' > msgbase.help
XUNaXcess Message Base Commands
X------------------------------
X
XD - Set your default conference, otherwise known as your login conference.  When you log in to UNaXcess, you will be placed in this conference; for new users, it is set to "general".
X
XE - Enter a message.  You are prompted for the recipient, the subject, and the destination conference (the default is the current conference).  On some systems you may be asked whether it is a private message.
X
XG - Goodbye.  This command logs you out.
X
XI - Index of conferences.  For each conference, you are informed of the number of messages in the conference, the number you have read, whether you are subscribed or not, and whether it is restricted or not.
X
XJ - Join a different conference.  If you are not subscribed to the conference (see the U command), you will be asked if you want to resubscribe.  You can also create a new conference by attempting to join it; you will be asked if you really intend to cre

ate a new conference.
X
XK - Kill a message in the current conference.  You are prompted for the message to kill.
X
XN - Read all new messages.  This command visits every conference in order and reads the new messages in each; after each message you may continue, skip to the next conference, kill the current message, reply to it, enter a new message, unsubscribe from i

ts conference, or enter the Main Menu temporarily.  (Whew!)
X
XR - Read menu (new messages, scan, read, quick scan).  See the help file for this menu for details.
X
XU - Unsubscribe from a conference.  If you unsubscribe from a conference, its messages will not be shown to you by the N command.  You can resubscribe by joining the conference (J command).  If you unsubscribe from the current conference, it will take ef

fect after you log out or join another conference.
X
XX - Return to the Main Menu.
________This_Is_The_END________
echo 'x - readcmds.help'
sed 's/^X//' << '________This_Is_The_END________' > readcmds.help
XUNaXcess Read Commands
X----------------------
X
XG - Goodbye.  This command logs you out.
X
XN - Read all new messages.  This command visits every conference in order and reads the new messages in each; after each message you may continue, skip to the next conference, kill the current message, reply to it, enter a new message, unsubscribe from i

ts conference, or enter the Main Menu temporarily.  (Whew!)
X
XQ - Quick Scan.  Only subjects of messages are shown.  See the S command for more details.
X
XR - Read messages in the current conference.  You will be asked if you wish to read Forward, Backward, an Individual message, or New messages.  The Forward and Backward options ask for lower and upper limits.  Messages will be displayed, and you will rec

eive the "read loop" prompt (see the N command) after each message.
X
XS - Scan messages in the current conference.  This displays the headers (from, to, subject) of the messages.  You may read Forward, Backward, an Individual message, or New messages.  If you choose Forward or Backward, you will be asked the lower and uppe

r limits.
X
XX - Return to the Message Base Menu.
________This_Is_The_END________
exit 0
--
++Brandon (Resident Elf @ ncoast.UUCP)
 ____   ______________
/    \ / __   __   __ \   Brandon S. Allbery	    <backbone>!ncoast!allbery
 ___  | /__> /  \ /  \    aXcess Co., Consulting    ncoast!allbery@Case.CSNET
/   \ | |    `--, `--,    6615 Center St. #A1-105 	   (...@relay.CS.NET)
|     | \__/ \__/ \__/    Mentor, OH 44060-4101     
\____/ \______________/   +1 216 781 6201


