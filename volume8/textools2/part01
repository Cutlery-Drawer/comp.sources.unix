Subject:  v08i061:  A collection of tools for TeX users, Part01/02
Newsgroups: mod.sources
Approved: mirror!rs

Submitted by: Kamal Al-Yahya <kamal@hanauma.STANFORD.EDU>
Mod.sources: Volume 8, Issue 61
Archive-name: tektools2/Part01

#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	DeTeX.c
#	Eqn.c
#	Expand.c
#	Match.c
#	README
#	TEX
#	TEX.1
#	detex.1
#	detex1.c
#	detex2.c
#	inc_file
#	inc_file2.tex
#	makefile
#	makefile.msc
#	makefile.par
#	setups.h
#	subs.c
#	testfile
#	texeqn.1
#	texeqn1.c
#	texeqn2.c
#	texexpand.1
#	texexpand1.c
#	texexpand2.c
#	texmatch.1
#	texmatch1.c
#	texmatch2.c
#	texspell
#	texspell.1
# This archive created: Thu Feb 12 10:14:11 1987
export PATH; PATH=/bin:$PATH
if test -f 'DeTeX.c'
then
	echo shar: will not over-write existing file "'DeTeX.c'"
else
cat << \SHAR_EOF > 'DeTeX.c'
/* COPYRIGHT (C) 1987  Kamal Al-Yahya */
#include   "setups.h"
DeTeX(buffer,out_file)			/* stripping TEX commands */

char *buffer;
FILE *out_file;
{
int c,cc;
char w[MAXWORD];

while ((c = *buffer++) != NULL)
	{
	switch (c)
		{
/* detect TeX commands (backslash) */
		case '\\':
			c=' ' ;		/* "erase" the backslash */
			putc(c,out_file);
			cc = *buffer++;
			if (cc == '\n')			putc(cc,out_file);
			else if (cc == '[')		buffer += display(buffer);
			else if (cc == '(')		buffer += formula(buffer);
			else if (cc == '$' || cc == '%')
				break;
/* check for LaTeX \begin{equation}, \begin{eqnarray}, and \begin{displaymath} */
			else
				{
				buffer--;
				buffer += get_buf_word(buffer,w);
				if (strcmp(w,"begin") == 0)
					{
					buffer++;
					buffer += get_buf_word(buffer,w);
					if (strcmp(w,"equation") == 0 ||
						strcmp(w,"eqnarray") == 0 ||
						strcmp(w,"displaymath") == 0)
						buffer += begin_to_end(buffer,w);
					}
				}
			break;

		case '$':
			buffer += dollar(buffer,out_file);
			break;
		case '%':
			buffer += comment(buffer);
			break;
/* erase these character */
		case '{':
			c=' ';
		case '}':
			c=' ';
		case '_':
			c=' ';
		case '^':
			c=' ';
		case '&':
			c=' ';
		case '#':
			c=' ';
/* default is doing nothing: pass the character to the output */
		default:
			putc(c,out_file);
			break;
		}
	}
}
SHAR_EOF
fi # end of overwriting check
if test -f 'Eqn.c'
then
	echo shar: will not over-write existing file "'Eqn.c'"
else
cat << \SHAR_EOF > 'Eqn.c'
/* COPYRIGHT (C) 1987  Kamal Al-Yahya */
#include    "setups.h"
Eqn(buffer,out_file)			/* srips TEX equations */

FILE *out_file;
char *buffer;
{
int c,d;
int i;
char w[MAXLINE], ww[MAXWORD];
while ((c = *buffer++) != NULL)
	{
	if(c == '%')
		{
		while ((c = *buffer++) != NULL)
			if (c == '\n') break;
		}
	else if(c == '$')
		{
		if ((d = *buffer++) == '$')
			{
			putc(c,out_file);	putc(d,out_file);
			while ((c = *buffer++) != NULL)
				{
				if(c != '$')   putc(c,out_file);
				else
					{
					buffer++;
					fprintf(out_file,"$$ \n");
					break;
					}
				}
			}
		}
/* check for LaTeX \begin{equation}, \begin{eqnarray}, and \begin{displaymath} */
	else if(c == '\\')
		{
		c = *buffer++;
		if (c == '[')
			{
			putc('\\',out_file); putc(c,out_file);
			while((c = *buffer++) != NULL)
				{
				if(c == '\\')
					{
					c = *buffer++;
					fprintf(out_file,"\\%c",c);
					if (c == ']')
						{
						putc('\n',out_file);
						break;
						}
					}
				else
					putc(c,out_file);
				}
			continue;
			}
		buffer--;
		buffer += get_buf_word(buffer,w);
		if (strcmp(w,"begin") == 0)
			{
			buffer++;
			i = get_buf_word(buffer,w);
			buffer += i;
			if (strcmp(w,"equation") == 0 || strcmp(w,"eqnarray")
				== 0 || strcmp(w,"displaymath") == 0)
				{
				fprintf(out_file,"\\begin{%s}",w);
				buffer++;
				while ((c = *buffer++) != NULL)
					{
					putc(c,out_file);
					if (c == '\\')
						{
						i = get_buf_word(buffer,ww);
						buffer += i;
						fprintf(out_file,"%s",ww);
						if (strcmp(ww,"end") == 0)
							{
							buffer++;
							i = get_buf_word(buffer,ww);
							buffer += i;
							fprintf(out_file,
								"{%s}\n",ww);
							buffer++;
							if (strcmp(ww,"equation")
							    == 0 ||
							    strcmp(ww,"eqnarray")
							    == 0 ||
							    strcmp(ww,"displaymath")
							    == 0)
								break;
							}
						}
					}
				}
			}
		else if (strcmp(w,"def") == 0)
			{
			i = def(buffer,w);
			buffer += i;
			fprintf(out_file,"\\def%s\n",w);
			}
		else if (strcmp(w,"newcommand") == 0)
			{
			i = command(buffer,w);
			buffer += i;
			fprintf(out_file,"\\newcommand%s\n",w);
			}
		}
	}
}
SHAR_EOF
fi # end of overwriting check
if test -f 'Expand.c'
then
	echo shar: will not over-write existing file "'Expand.c'"
else
cat << \SHAR_EOF > 'Expand.c'
/* COPYRIGHT (C) 1987 Kamal Al-Yahya */

#include    "setups.h"
unsigned int len=0;		/* length of document */

Expand(fp,buf)	/* expand TeX and LaTeX's \input and \include */

FILE *fp;
char *buf;
{
char *buf2;
FILE *fpp;
int c;
int c1=' ';				/* previous character */
char w[MAXWORD];
int i,j;
extern wflag;

if (((buf2 = (char *)malloc(MAXLEN*sizeof(char))) == (char *)NULL))
	{
    	fprintf(stderr,"Expand: Cannot malloc() internal buffer space\n\
Need an arrays of %d characters\n",MAXLEN);
	exit(-1);
	}

while ((c = getc(fp)) != EOF)
	{
	if (++len >= MAXLEN)
		{
		fprintf(stderr,"Document is too large\n");
		exit(-1);
		}
	if (c == '%' || c1 == '%')
		{
		*buf++ = c;
		while ((c =getc(fp)) != EOF)
			{
			if (++len >= MAXLEN)
				{
				fprintf(stderr,"Sorry: document is too large\n");
				exit(-1);
				}
			*buf++=c;
			if (c == '\n')		break;
			}
		c1=c;
		continue;
		}
	if (c != '\\')
		*buf++ = c;
	else			/* detect TeX commands (backslash) */
		{
		/* see if \input or \include is the control sequence */
		i=0;
		c1=c;		/* update last character */
		while ((c = getc(fp)) != EOF && i < MAXWORD)
			{
			if (++len >= MAXLEN)
				{
				fprintf(stderr,"Document is too large\n");
				exit(-1);
				}
			if (c == ' ' || c=='\n' || c=='$' || c=='#' || c=='%'
			    || c=='{' || c=='(' || c==')' || c == '\\')
				break;
			w[i++] = (char)c;
			}
		if (strncmp(w,"input",5) == 0 || (strncmp(w,"include",7) == 0
		    && strcmp(w,"includeonly") !=0))
			{
/* if it is \input or \include , get the file name */
			i=0;
			while ((c=getc(fp)) != EOF && i < MAXWORD)
				{
				if (c == ' ' || c == '\n'
				    || c == '\t' || c == '}' || c == '%')
					break;
				w[i++] = (char)c;
				}
			w[i] = NULL;
			fpp=fopen(w, "r"); /* open the new file */
			if( fpp == NULL )
				{
/* if file is not found, try file.tex  */
				strcat(w,".tex");
				fpp=fopen(w, "r");
				if( fpp == NULL )
					{
					fprintf(stderr,
					"TeXExpand: Cannot open %s\n",w);
					buf2[0] = NULL;
					}
				else
					{
					if (wflag != 1)
						{
						fprintf(stderr,"%s:\n",w);
						Match(fpp);
						fprintf(stderr,"\n");
						fseek(fpp,0,0);
						}
					Expand(fpp,buf2);
					fclose(fpp);
					}
				}
			else
				{
				if (wflag != 1)
					{
					fprintf(stderr,"%s:\n",w);
					Match(fpp);
					fprintf(stderr,"\n");
					fseek(fpp,0,0);
					}
				Expand(fpp,buf2);
				fclose(fpp);
				}
			strcat(buf,buf2);
			buf += strlen(buf2);
			w[0] = NULL;
			}
		else
/* if the control sequence is not \input or \include write it out */
			{
/* if it is \def, \newcommand, or \newenvironment, write the full command */
			if (strncmp(w,"def",3) == 0)
				{
				i = def_file(fp,&j,0);
				fseek(fp,-i,1);
				strcat(buf,"\\def\\");
				buf += 5;
				for (j=0; j < i; j++)
					*buf++=getc(fp);
				}
			else if (strncmp(w,"newcommand",10) == 0)
				{
				i = comm_file(fp,&j,0);
				fseek(fp,-i,1);
				strcat(buf,"\\newcommand{");
				buf += 12;
				for (j=0; j < i; j++)
					*buf++=getc(fp);
				}
			else if (strncmp(w,"newenvironment",14)==0)
				{
				i = getenv_file(fp,&j,0);
				fseek(fp,-i,1);
				strcat(buf,"\\newenvironment{");
				buf += 16;
				for (j=0; j < i; j++)
					*buf++=getc(fp);
				}
			else
				{
				*buf++='\\';
				for (j=0; j < i; j++)
					*buf++ = w[j];
				*buf++ = c;
				}
			}
		}
	c1 = c;				/* update last character */
	}
*buf = NULL;				/* terminate it with a null */
}
SHAR_EOF
fi # end of overwriting check
if test -f 'Match.c'
then
	echo shar: will not over-write existing file "'Match.c'"
else
cat << \SHAR_EOF > 'Match.c'
/* COPYRIGHT (C) 1987 Kamal Al-Yahya */
#define IN_TM
#include   "setups.h"

Match(fp)			/* check matching */
FILE *fp;
{

int line=1;			/* line counter */
int ld=0;			/* single left dollar signs */
int rd=0;			/* single right dollar signs */
int ldd=0;			/* left double dollar signs */
int rdd=0;			/* right double dollar signs */
int disp=0;			/* \[  \] */
int disp_line=1;		/* line number of \[ */
int form=0;			/* \(  \) */
int lform=1;			/* line number of \( */
int lp=0;			/* left parenthesis */
int rp=0;			/* right parenthesis */
int lb=0;			/* left brackets */
int rb=0;			/* right brackets */
int lbr=0;			/* left braces */
int rbr=0;			/* right braces */
int c=' ';			/* current character */
int c1=' ';			/* previous character */
int lbrl=0;			/* line number of left braces */
int lbl=0;			/* line number of left bracket */
int lpl=0;			/* line number of left parenthesis */
int ldl=1;			/* line number of left single dollar sign */
int lddl=1;			/* line number of left double dollar sign */
int warn=0;			/* warning status */
int env_count = 0;		/* environment counter */
int i=0, j=0;
char w[MAXWORD];
char *p;
int cc;
extern char *malloc();

while ((c =getc(fp)) != EOF)
	{
	if (ldd == 1 && ld == 1 && c != '$')
		{
		fprintf(stderr,"line %d: a double dollar sign is closed by a single dollar sign\n",line);
		ld=0.;	ldd=0.;			/* reset dollar signs */
/* Give warning about unclosed openings */
		if ((lbr-rbr) > 0)
	fprintf(stderr,"line %d: %d unclosed braces in equation\n",lddl,lbr-rbr);
		if ((lb-rb) > 0)
	fprintf(stderr,"line %d: %d unclosed brackets in equation\n",lddl,lb-rb);
		if ((lp-rp) > 0)
	fprintf(stderr,"line %d: %d unclosed parentheses in equation\n",lddl,lp-rp);
/* clear registers */
		lp=0; lb=0; lbr=0;
		rp=0; rb=0; rbr=0;
		lpl=0; lbrl=0; lbl=0;
		}
	switch(c)
		{
		case '\n':
			line++;		/* increment line counter */
/* check to see if a single dollar sign is not closed at the same line */
			if (ld == 1 && warn == 0)
				{
				fprintf(stderr,"line %d: single dollar sign is not closed on the same line\n",line-1);
				warn=1;		/* warning has been given */
				}
			break;
		case '%':		/* ignore commented text */
			while ((c =getc(fp)) != EOF)
				if (c == '\n')	{line++;	break;}
			break;
		case '{':
			if (lbrl == 0)	lbrl=line;
			lbr++;
			break;
		case '}':
			rbr++;
			if (rbr > lbr)
				{
				fprintf(stderr,"line %d: unmatched brace\n",line);
				rbr--;		/* reset counter */
				}
			if (lbr == rbr)	lbrl=0;
			break;
		case '[':
			if (lbl == 0)	lbl=line;
			lb++;
			break;
		case ']':
			rb++;
			if (rb > lb)
				{
			     fprintf(stderr,"line %d: unmatched bracket\n",line);
				rb--;		/* reset counter */
				}
			if (lb == rb)	lbl=0;
			break;
		case '(':
			if (lpl == 0)	lpl=line;
			lp++;
			break;
		case ')':
			rp++;
			if (rp > lp)
			    {
			   fprintf(stderr,"line %d: unmatched parenthesis\n",line);
			    rp--;		/* reset counter */
			    }
			if (lp == rp)	lpl=0;
			break;
		case '$':
			if (c1 == '$')		/* double dollar sign */
				{
				if (ld == 0)
					{
					fprintf(stderr,"line %d: single dollar sign is closed by a duble dollar sign\n",line);
					c=' ';		/* reset the dollar sign */
					break;
					}
				if (ldd == 1)
					{
					rdd=1; /* right double dollar sign */
/* Give warning about unclosed openings */
					if ((lbr-rbr) > 0)
	fprintf(stderr,"line %d: %d unclosed braces in equation\n",lddl,lbr-rbr);
					if ((lb-rb) > 0)
	fprintf(stderr,"line %d: %d unclosed brackets in equation\n",lddl,lb-rb);
					if ((lp-rp) > 0)
	fprintf(stderr,"line %d: %d unclosed parentheses in equation\n",lddl,lp-rp);
/* clear registers */
					lp=0; lb=0; lbr=0;
					rp=0; rb=0; rbr=0;
					lpl=0; lbrl=0; lbl=0;
					}
				else
					{
					ldd=1;	/* left double dollar sign */
					lddl=line;	/* line number */
/* Give warning about unclosed openings */
					if ((lbr-rbr) > 0)
	fprintf(stderr,"line %d: %d unclosed braces before equation, first opened at line %d\n",lddl,lbr-rbr,lbrl);
					if ((lb-rb) > 0)
	fprintf(stderr,"line %d: %d unclosed brackets before equation, first opened at line %d\n",lddl,lb-rb,lbl);
					if ((lp-rp) > 0)
	fprintf(stderr,"line %d: %d unclosed parentheses before equation, first opened at line %d\n",lddl,lp-rp,lpl);
/* clear registers */
					lp=0; lb=0; lbr=0;
					rp=0; rb=0; rbr=0;
					lpl=0; lbrl=0; lbl=0;
					}
				}
			if (ld == 1)	rd=1;	/* right dollar sign */
			else
				{
				ld=1; 	/* left dollar sign */
				ldl=line;	/* line number */
				warn=0;	/* no warning has been given */
				}
			break;
		case '\\':
/* check for \begin{...} and \end{...} */
			i = get_file_word(fp,w,&line,&cc);
			if (i == 0 && cc == '[')
				{
				if (disp == 1)
	fprintf(stderr,"line %d: displayed equation starts, previous one at line %d not closed\n",line,disp_line);
				disp=1; 	/* left   \] */
				disp_line=line;
/* Give warning about unclosed openings */
				if ((lbr-rbr) > 0)
	fprintf(stderr,"line %d: %d unclosed braces before equation\n",line,lbr-rbr);
				if ((lb-rb) > 0)
	fprintf(stderr,"line %d: %d unclosed brackets before equation\n",line,lb-rb);
				if ((lp-rp) > 0)
	fprintf(stderr,"line %d: %d unclosed parentheses before equation\n",line,lp-rp);
/* clear registers */
				lp=0; lb=0; lbr=0;
				rp=0; rb=0; rbr=0;
				lpl=0; lbrl=0; lbl=0;
				}
			else if (i == 0 && cc == ']')
				{
				if (disp == 0)
	fprintf(stderr,"line %d: displayed equation ends but no beginning\n",line);
				disp=0;		/* right \] */
/* Give warning about unclosed openings */
				if ((lbr-rbr) > 0)
	fprintf(stderr,"line %d: %d unclosed braces in equation\n",line,lbr-rbr);
				if ((lb-rb) > 0)
	fprintf(stderr,"line %d: %d unclosed brackets in equation\n",line,lb-rb);
				if ((lp-rp) > 0)
	fprintf(stderr,"line %d: %d unclosed parentheses in equation\n",line,lp-rp);
/* clear registers */
				lp=0; lb=0; lbr=0;
				rp=0; rb=0; rbr=0;
				lpl=0; lbrl=0; lbl=0;
				}
			else if (i == 0 && cc == '(')
				{
				if (form == 1)
	fprintf(stderr,"line %d: formula starts but previous one not closed\n",line);
				form=1;			/* left \( */
				lform=line;		/* line of \( */
				}
			else if (i == 0 && cc == ')')
				{
				if (form == 0)
	fprintf(stderr,"line %d: formula ends but no beginning\n",line);
				form=0;			/* right \) */
				}
			else if (strcmp(w,"begin") == 0)
				{
				(void) get_file_word(fp,w,&line,&cc);
				if ((j=is_new_env(w,env_count)) < 0)
					{
					j = env_count;
					env[j].env_beg = 0;
					env[j].env_end = 0;
					p = (char *) malloc((unsigned)(i*sizeof(char)));
					strcpy(p,w);
					env[env_count++].env_name = p;
					}
				env[j].beg_line = line;
				env[j].env_beg++;
/* Give warning about unclosed openings before these environments */
				if (strcmp(env[j].env_name,"equation") == 0 ||
				    strcmp(env[j].env_name,"eqnarray") == 0 ||
				    strcmp(env[j].env_name,"eqnarray*") == 0 ||
				    strcmp(env[j].env_name,"displaymath") == 0)
					{
					if ((lbr-rbr) > 0)
	fprintf(stderr,"line %d: %d unclosed braces before environment ``%s'', first opened at line %d\n",line,lbr-rbr,env[j].env_name,lbrl);
					if ((lb-rb) > 0)
	fprintf(stderr,"line %d: %d unclosed brackets before environment ``%s'', first opened at line %d\n",line,lb-rb,env[j].env_name,lbl);
					if ((lp-rp) > 0)
	fprintf(stderr,"line %d: %d unclosed parentheses before environment ``%s'', first opened at line %d\n",line,lp-rp,env[j].env_name,lpl);
/* clear registers */
					lp=0; lb=0; lbr=0;
					rp=0; rb=0; rbr=0;
					lpl=0; lbrl=0; lbl=0;
					}
				}
			else if (strcmp(w,"end") == 0)
				{
				(void) get_file_word(fp,w,&line,&cc);
				if ((j=is_new_env(w,env_count)) < 0)
	fprintf(stderr,"line %d: unmatched end for environment ``%s''\n",line,w);
				else
				{
				env[j].env_end++;
				if (env[j].env_end > env[j].env_beg)
					{
	fprintf(stderr,"line %d: unmatched end for environment ``%s''\n",line,
		env[j].env_name);
					env[j].env_end--;	/* reset */
					}
/* Give warning about unclosed openings in these environments */
				if (strcmp(env[j].env_name,"equation") == 0 ||
				    strcmp(env[j].env_name,"eqnarray") == 0 ||
				    strcmp(env[j].env_name,"eqnarray*") == 0 ||
				    strcmp(env[j].env_name,"displaymath") == 0)
					{
					if ((lbr-rbr) > 0)
	fprintf(stderr,"line %d: %d unclosed braces in environment ``%s''\n",
line,lbr-rbr,env[j].env_name);
					if ((lb-rb) > 0)
	fprintf(stderr,"line %d: %d unclosed brackets in environment ``%s''\n",
line,lb-rb,env[j].env_name);
					if ((lp-rp) > 0)
	fprintf(stderr,"line %d: %d unclosed parentheses in environment ``%s''\n",
line,lp-rp,env[j].env_name);
/* clear registers */
					lp=0; lb=0; lbr=0;
					rp=0; rb=0; rbr=0;
					lpl=0; lbrl=0; lbl=0;
					}
				}
				}
			else if (strcmp(w,"def") == 0)
				(void) def_file(fp,&line,1);
			else if (strcmp(w,"newcommand") == 0)
				(void) comm_file(fp,&line,1);
			else if (strcmp(w,"newenvironment") == 0)
				(void) getenv_file(fp,&line,1);
			else if (i > 0)		fseek(fp,-1,1);
			break;
		default:
			break;
		}
	c1=c;					/* update previous character */
	if (ld == 1 && rd == 1)
		{ld=0.;		rd=0.;}		/* matched dollar signs */
	if (ldd == 1 && rdd == 1)
		{ldd=0.;	rdd=0.;}	/* matched double dollar signs */
	}
if ((lbr-rbr) > 0)
	fprintf(stderr,"file ends: %d unclosed left braces, first opened at line %d \n",lbr-rbr,lbrl);
if ((lb-rb) > 0)
	fprintf(stderr,"file ends: %d unclosed left brackets, first opened at line %d\n",lb-rb,lbl);
if ((lp-rp) > 0)
	fprintf(stderr,"file ends: %d unclosed left parentheses, first opened at line %d\n",lp-rp,lpl);
if (ld == 1)
	fprintf(stderr,"file ends: single dollar sign opened at line %d unclosed\n",ldl);
if (ldd == 1)
	fprintf(stderr,"file ends: double dollar sign opened at line %d unclosed\n",lddl);
if (disp == 1)
	fprintf(stderr,"file ends: displayed equation opened at line %d unclosed\n",disp_line);
if (form == 1)
	fprintf(stderr,"file ends: formula opened at line %d unclosed\n",lform);
for (i=0; i<env_count; i++)
	if (env[i].env_beg > env[i].env_end)
	fprintf(stderr,"file ends: enviornment ``%s'' begun at line %d not ended\n",env[i].env_name,env[i].beg_line);
}
SHAR_EOF
fi # end of overwriting check
if test -f 'README'
then
	echo shar: will not over-write existing file "'README'"
else
cat << \SHAR_EOF > 'README'
TeXTools	Version	1.0
Date:		1/25/87

Copyright (C) 1987  by Kamal Al-Yahya

This directory contains some filters that were developed at the
Stanford Exploration Project (SEP), Geophysics Department, by Kamal Al-Yahya.
Copying them to any other machine is permitted without prior permission
provided that copyright messages are kept, no profit is made by copying
the files, and modifications are clearly documented and noted in the
edit history below.

--------------------------------------------------------------------------
EDIT HISTORY:

--------------------------------------------------------------------------

Acknowledgment:
Many users at the SEP gave valuable feedbacks that improved the programs.

The main programs have names that end with either 1 or 2 (e.g. detex1.c,
detex2.c). Those ending with 2 are used in makefile.par and can
be used only by those who have getpar(). This enables them to use
in=  and out=  for input and output files specifications in addition
to what can be done in files ending with 1.

The maximum number of characters in a document is set by MAXLEN
(in setups.h) to be 65535. If the limit of unsigned integers in
your machine is lower than this, change this number accordingly.

To install:
 - modify MAXLEN in setups.h if necessary.
 - choose either makefile or makefile.par (as explained above).
 - type 'make'.
 - test the programs on the testfile provided.
 - move the executables to a common path (like /usr/local/bin).
 - type 'make clean'.

The following files should be in this directory:

README		this file
setups.h	an include file used by all programs.
testfile	a file that demonstrates how these programs work
inc_file	an include file that is opened by testfile
inc_file2.tex	another include file
makefile	what else but a makefile
makefile.par	a makefile that assumes you have access to getpar()
detex1.c	strips TeX's commands from the document
detex2.c	same as detex1.c but assumes you have access to getpar()
texeqn1.c	picks displayed equations from a document
texeqn2.c	same as texeqn1.c but assumes you have access to getpar()
texexpand1.c	expands the document by opening \input and \include files
texexpand2.c	same as texexpand1.c but assumes you have access to getpar()
texmatch1.c	checks for matching braces, brackets, parentheses, and dollar signs
texmatch2.c	same as texmatch1.c but assumes you have access to getpar()
DeTeX.c		subroutine to strip TeX's commands from the document
Eqn.c		subroutine to extracts equations
Expand.c	subroutine to expand the document
Match.c		subroutine that checks the matching
subs.c		subroutines used by the programs
TEX		a shell that can be used to run all TeX processing
texspell	shell that runs spell on TeX documnets
detex.1		manual page for detex
texeqn.1	manual page for texeqn
texexpand.1	manual page for texexpand
texmatch.1	manual page for texmatch
texspell.1	manual page for texspell
TEX.1		manual page for TEX


Feedbacks are welcome. E-mail: try any of these

		kamal@hanauma.stanford.edu
		kamal%hanauma@score.stanford.edu
SHAR_EOF
fi # end of overwriting check
if test -f 'TEX'
then
	echo shar: will not over-write existing file "'TEX'"
else
cat << \SHAR_EOF > 'TEX'
#! /bin/csh -f
#
# Usage: TEX [-flags ...] filename
#
# The various flags are described below, but only one filename should
# be given; stdin is not used. File types are indicated by the filename
# suffix. Input files may have one of the following suffixes:
#	.tex -- a file with tex commands, equations.
#	.dvi -- device independent format.
#	.ver -- output of verser1 (for the varian or AED)
#	.imp -- output of dvi-imagen (or dviimp)
# Anything else is assumed to be in .tex format.
# If TEX sees a .dvi, .ver, or .imp suffix, it will skip ahead to the right
# point in the processing sequence. Specifically,
#	texeqn	accepts .tex, outputs .tex
#	tex	accepts .tex, outputs .dvi and .log
#	latex	accepts .tex, outputs .dvi and .log
#	verser1	accepts .dvi, outputs .ver (for the varian or AED, not on hanuma).
#	lpr	accepts .ver, outputs raster
#	ipr	accepts	.imp, outputs raster
#
# Flags:
# -latex uses LaTeX.
# -log	 saves a log file from the tex run in filename.log.
# -d	 quits once the .dvi file has been made.
# -x	 makes two passes on the (latex) input, so cross-references
#	 are resolved.
# -v	 output device is the varian (imagen is the default)
# -q	 quits once the .imp file has been made if the imagen is the target printer
#	 or after the .ver file	(i.e. after verser1 stage) if the AED or the varian
#	 is the target printer.
# -eqn	 strips out the equations with texeqn and typeset them.
#
# Authors: Kamal Al-Yahya, Jeff Thorson, and Chuck Sword, Stanfor University
#
umask 0
onintr removal
set name=() host=()
set destdir = /usr/local
set tmp = TEX$$
set device = imagen
set st = 0
unset latex x d q eqn log

if ($#argv == 0) then
	echo "usage: TEX [-latex] [-eqn] [-log] [-d] [-q] [-x] filename"
	exit(-1)
endif

while ($#argv > 0 && !($?inf))
	switch ($argv[1])
		case -latex:
			set latex
			breaksw

		case -x:
			set x
			breaksw

		case -q:
			set q
			breaksw

		case -d:
			set d
			breaksw

		case -v:
			set device = varian
			breaksw

		case -eqn:
			set eqn
			breaksw

		case -log:
			set log
			breaksw

		case -*:
			echo unknown flag $argv[1], ignored
			breaksw
                default:
			set inf = $argv[1]
			if !(-e $inf) then

#  filename not found, try with .tex ending

				if !(-e $inf.tex) then 
					echo $0 'cannot find file' $inf.
					exit(-1)
				else
					set inf = ($inf.tex)
				endif
			endif
			breaksw
		endsw
	shift argv
end

set name = $inf:t
set sname = $name:r
set name = $cwd/$name
set suffix = $name:e

if ($suffix == dvi) then
	echo TEX: starting with .dvi file
	set name = $name:r
	set dvifile = $inf
	goto dvi
endif

if ($suffix == ver) then
	echo TEX: starting with .ver file
	set name = $name:r
	set verfile = $inf
	goto ver
endif

if ($suffix == imp) then
	echo TEX: starting with .imp file
	set name = $name:r
	set impfile = $inf
	goto imp
endif

if ($suffix == tex || $suffix == eqn) then
	set name = $name:r
endif

echo "\batchmode" > $tmp.tex

if ($?eqn) then
	$destdir/texeqn < $inf >> $tmp.tex
else
	cat $inf >> $tmp.tex
endif

echo "\bye" >> $tmp.tex

# Choose tex or latex

if ($?latex) then
	if (-e $name.aux) then
		cp $name.aux $tmp.aux
	endif
	$destdir/latex $tmp:t
	if ($status != 0) then
		goto oops
	else
		if (-e $tmp.aux) then
			cp $tmp.aux $name.aux
		endif
	endif

	if ($?x) then
		echo "Starting second pass"
		$destdir/latex $tmp
		if ($status != 0) then
			goto oops
		endif
		if (-e $tmp.aux) then
			cp $tmp.aux $name.aux
		endif
	endif

else	$destdir/tex $tmp
	if ($status != 0) then
oops:
		echo TEX could not process your file.
		echo Error messages are in $name.log
		mv -f $tmp.log $name.log
		set st = -1
		goto removal
	endif
endif

if ($?log) then
	mv -f $tmp.log $name.log
	if (-e $tmp.aux) then
		mv -f $tmp.aux $name.aux
	endif
endif

set dvifile = $tmp.dvi

if ($?d) then
	mv -f $dvifile $name.dvi
	goto removal
endif

dvi:

if($device == imagen) then
	$destdir/dvi-imagen -s $dvifile > $tmp.imp
	if ($?q) then
		mv -f $tmp.imp $name.imp
		goto removal
	endif
	set impfile = $tmp.imp
imp:
	(echo -n \@document\(owner \"$user\", site \"$host\", spooldate \
	\"`date`\", language \"imPress\", jobheader off, \
	jamresistance on\) ; cat $impfile ) | $destdir/ipr
	goto removal
endif

if($device == varian) then
	$destdir/verser1 < $dvifile > $tmp.ver
	if ($status != 0) then
		echo TEX bombed out on verser1.
		set st = -1
		goto removal
	endif
	set verfile = $tmp.ver

	if ($?q) then
		mv -f $verfile $name.ver
		goto removal
	endif
ver:
	lpr -d -s -Pvarian $tmp.ver
endif

removal:
/bin/rm -f $tmp.tex $tmp.log $tmp.dvi $tmp.ver $tmp.imp $tmp.aux
exit($st)
SHAR_EOF
chmod +x 'TEX'
fi # end of overwriting check
if test -f 'TEX.1'
then
	echo shar: will not over-write existing file "'TEX.1'"
else
cat << \SHAR_EOF > 'TEX.1'
.TH TEX 1 2/2/84
.UC 4
.SH NAME
TEX \- 
.I TeX
and
.I LaTeX
typesetter and printer.
.SH SYNOPSIS
.B TEX
[
options
]
.I  filename
.SH DESCRIPTION
.I TEX
processes a file 
and sends it to a printer. The default is the Imagen; other devices 
can be used if available at the site.
.PP
The input to
.I TEX
does not have to be the raw manuscript.
.I TEX
can be given a
.I .dvi
file (which results from using the
.B -d
option),
or
.I .imp
and
.I .ver
files (which result from using the
.B -q
option), and it will proceed from and end at the appropriate stage.
.br
The file name does not have to end with
.I
tex.
.sp 2
OPTIONS :
.br
.TP
.B \-latex
uses LaTeX.  See the LaTeX manual.
.TP
.B \-x
makes two passes on the
.I LaTeX
input to resolve cross-references.
.TP
.B \-eqn
uses
.B
texeqn
to extract the equations.
.TP
.B \-log
saves messages from the
.B tex
run in 
.I filename
.B .log
and saves messages from LaTeX run in 
.I filename
.B .aux
.TP
.B \-d
quits once the
.I dvi
file is produced without producing a hardcopy.
.TP
.B \-q
(for quiescent) intermediate output is not spooled 
to the printing device.
.TP
.B \-v
output device is the varian (default is the imagen).
.fi
.SH SEE ALSO
tex(1), texeqn(1), texmatch(1), detex(1)
.SH FILES
file.aux			the auxiliary file used by LaTeX for labeling figures.
.br
The default is to remove the following files at the end of the run:
.br
TE????.dvi		the device independent file.
.br
TE????.log		the log file.
.br
TE????.imp		the impress file; can be printed by
.B ipr
file.
.SH BUGS
Only one file can be processed at a time.
.br
Drivers flags are not incorporated. Add the ones you need.
.SH AUTHOR
Kamal Al-Yahya
.br
Jeff Thorson
.br
Chuck Sword
SHAR_EOF
fi # end of overwriting check
if test -f 'detex.1'
then
	echo shar: will not over-write existing file "'detex.1'"
else
cat << \SHAR_EOF > 'detex.1'
.TH detex 1 2/27/86
.UC 4
.SH NAME
detex \- a filter to strip TeX and LaTeX's commands from a file.
.SH SYNOPSIS
.B detex [-iw]
.I file1 [file2 ......]
.br
or
.B detex [-iw]
.I < file
.br
.SH DESCRIPTION
TeX and LaTeX have control characters that
.B spell
and other
.I troff
-dependent
processors (like diction) do not recognize.
.I Detex
works as a preprocessor by
filtering those control characters. The output can then be piped to the next
process. The output can be saved by redirecting the standard output.
.I Detex
does not break the document into individual words. It merely
.I erases
the control sequences.
.br
In-line or displayed equation are not  passed to the output. Also,
the character '%' is recognized as a comment indicator and the commented
text is not passed to the output.
.br
.I Detex
recognizes and opens files called by TeX's and LaTeX's \\input
and \\include commands. The
.B -i
flag makes
.I detex
ignore these commands.
The file name has to be correct relative to the current working directory.
If it cannot open the file nor file_name.tex, it will give a non-fatal
error message and proceed.
.br
Warning is given if suspected unmatching is detected. Use the
.B -w
flag to suppress these warnings.
.SH DIAGNOSTICS
Nesting of \\input and \\include is allowed but the number of opened files
must not exceed the system's limit on the number of simultaneously opened
files (normally < 20).
.br
Displayed material is regarded as mathematical equations and is ignored.
.br
White spaces withing LaTeX's \\begin{...} or \\end{...} are not allowed for.
.SH SEE ALSO
texexpand(1), texeqn(1), texmatch(1).
.SH AUTHOR
Kamal Al-Yahya, Stanford University
SHAR_EOF
fi # end of overwriting check
if test -f 'detex1.c'
then
	echo shar: will not over-write existing file "'detex1.c'"
else
cat << \SHAR_EOF > 'detex1.c'
/* COPYRIGHT (C) 1987 Kamal Al-Yahya */
/* detex: strips TeX's and LaTeX's commands */

char *documentation[] = {
" SYNTAX",
"        detex [-i] file1 [file2 .....]",
"     or detex [-i]  < file1 [file2 ....]",
"",
"See the manual page for more details.",
"",
"        Flag:",
"             -i:     ignores TeX's and LaTeX's \input and \include commands",
"             -w:     matching is not checked",
"",
};

/* Author: Kamal Al-Yahya, Stanford University,		11/1/83 */
/* Last modified:					1/25/87 */

int	doclength = { sizeof documentation/sizeof documentation[0] };

#include        "setups.h"

#ifdef tops20
#define TEMPFILE "texXXXXXX"
#else
#define TEMPFILE "/tmp/texXXXXXX"
#endif

#ifdef MSC
#else
struct sgttyb ttystat;
#endif

extern char *mktemp();
char scratch_file[MAXWORD];

int wflag;
int xargc;
char **xargv;

main(argc,argv)
int argc; 
char *argv[];
{
char *buf;
FILE *temp,*scr;
register char *cptr;
int piped_in;
int iflag,i;

if (((buf = (char *)malloc(MAXLEN*sizeof(char))) == (char *)NULL))
	{
    	fprintf(stderr,"detex: Cannot malloc() internal buffer space\n\
Need an array of %d characters\n",MAXLEN);
	exit(-1);
	}

/* If no arguments, and not in a pipeline, self document */
#ifdef MSC	/* MS-DOS cannot distinguish piped input from no input */
piped_in = (argc == 1);
#else
piped_in = ioctl ((fileno (stdin)), TIOCGETP, &ttystat);
#endif

if (argc == 1 && !piped_in)
	{
	for( i=0; i<doclength; i++)
		printf("%s\n",documentation[i]);
	exit (0);
	}

/* process option flags */
xargc = argc;
xargv = argv;
for (xargc--,xargv++; xargc; xargc--,xargv++)
	{
	cptr = *xargv; 
	if( *cptr=='-' )
		{
		while( *(++cptr))
			{
			switch( *cptr )
				{
				case 'i':
					iflag=1;
					break;
				case 'w':
					wflag=1;
					break;
				default:
			     		fprintf(stderr,
						"detex: unknown flag -%c\n",*cptr);
					break;
				}
			}
		}
	}

/* first process pipe input */
if(piped_in)
	{
/* need to buffer; can't seek in pipes */
/* make a temporary and volatile file in /tmp */
	strcpy(scratch_file,TEMPFILE);
	mktemp(scratch_file);
	if ((scr=fopen(scratch_file,"w")) == (FILE *)NULL)
		{
		fprintf(stderr,
			"detex: Cannot open scratch file [%s]\n",scratch_file);
		exit(-1);
		}
	scrbuf(stdin,scr);
	fclose(scr);
	scr=fopen(scratch_file,"r");
	unlink(scratch_file);
	if (wflag != 1)
		{
		fprintf(stderr,"Checking matching...\n");
		Match(scr);
		fseek(scr,0,0);
		}
/* either expand or buffer */
	if (iflag != 1)
		{ Expand(scr,buf);	fclose(scr); }
	else
		{ tmpbuf(scr,buf);	fclose(scr); }
	if (wflag != 1)
		fprintf(stderr,"Checking matching done\n\n");
	DeTeX(buf,stdout);
	fclose(scr);
	}

/* then process input line for arguments and assume they are input files */
xargc = argc;
xargv = argv;
for (xargc--,xargv++; xargc; xargc--,xargv++)
	{
	cptr = *xargv; 
	if( *cptr=='-' ) continue;		/* this is a flag */
	if((temp=fopen(cptr,"r")) != (FILE *)NULL)
		{
		if (wflag != 1)
			{
			fprintf(stderr,"Checking matching...\n");
			fprintf(stderr,"%s:\n",cptr);
			Match(temp);
			fprintf(stderr,"\n");
			fseek(temp,0,0);
			}
/* either expand or buffer */
		if (iflag != 1)
			{ Expand(temp,buf);	fclose(temp); }
		else
			{ tmpbuf(temp,buf);	fclose(temp); }
		if (wflag != 1)
			fprintf(stderr,"Checking matching done\n\n");
		DeTeX(buf,stdout);
		fclose(temp);
		}
	else
		fprintf(stderr,"detex: Cannot open %s\n",cptr);
	}

}
SHAR_EOF
fi # end of overwriting check
if test -f 'detex2.c'
then
	echo shar: will not over-write existing file "'detex2.c'"
else
cat << \SHAR_EOF > 'detex2.c'
/* COPYRIGHT (C) 1987 Kamal Al-Yahya */
/* detex: strips TeX's and LaTeX's commands */


char *documentation[] = {
" SYNTAX",
"        detex [-iw] [parameters] [inputfiles]",
"",
"        flags:",
"              -i   ignores TeX's and LaTeX's \input and \include commands",
"              -w   does not check matching",
"",
"        parameters:",
"              in=filename       filename is the input file",
"                                (Default: in=stdin)",
"",
"              out=filename      filename is the output file",
"                                (Default: out=stdout)",
""
};

/* Author: Kamal Al-Yahya, Stanford University,		11/1/83 */
/* Last modified:					1/25/87 */

int	doclength = { sizeof documentation/sizeof documentation[0] };

#include        "setups.h"

#ifdef tops20
#define TEMPFILE "texXXXXXX"
#else
#define TEMPFILE "/tmp/texXXXXXX"
#endif

char string[MAXWORD], filename[MAXWORD], scratch_file[MAXWORD];
FILE *out_file;
extern char *mktemp();

#ifdef MSC
#else
struct sgttyb ttystat;
#endif

int wflag;
int xargc;
char **xargv;

main(argc,argv)
int argc; 
char *argv[];
{
char *buf;
FILE *temp,*scr;
register char *cptr;
int piped_in;
int iflag,i;

if (((buf = (char *)malloc(MAXLEN*sizeof(char))) == (char *)NULL))
	{
    	fprintf(stderr,"detex: Cannot malloc() internal buffer space\n\
Need an array of %d characters\n",MAXLEN);
	exit(-1);
	}

/* If no arguments, and not in a pipeline, self document */
#ifdef MSC	/* MS-DOS cannot distinguish piped input from no input */
piped_in = (argc == 1);
#else
piped_in = ioctl ((fileno (stdin)), TIOCGETP, &ttystat);
#endif
if (argc == 1 && !piped_in)
	{
	for( i=0; i<doclength; i++)
		printf("%s\n",documentation[i]);
	exit (0);
	}

out_file = stdout;		/* default output */

/* process option flags */
xargc = argc;
xargv = argv;
for (xargc--,xargv++; xargc; xargc--,xargv++)
	{
	cptr = *xargv; 
	if( *cptr=='-' )
		{
		while( *(++cptr))
			{
			switch( *cptr )
				{
				case 'i':
					iflag=1;
					break;
				case 'w':
					wflag=1;
					break;
				default:
			     		fprintf(stderr,
						"detex: unknown flag -%c\n",*cptr);
					break;
				}
			}
		}
	}

/* process getpar parameters */
xargc = argc;
xargv = argv;

if(getpar_("out","s",string))
	{
	sscanf(string,"%s",filename);
	if((temp=fopen(filename,"w")) == NULL)
		fprintf(stderr,"detex: Cannot open output file %s\n",filename);
	else
		out_file = temp;
	}

/* first process pipe input */
if(piped_in)
	{
/* need to buffer; can't seek in pipes */
/* make a temporary and volatile file in /tmp */
	strcpy(scratch_file,TEMPFILE);
	mktemp(scratch_file);
	if ((scr=fopen(scratch_file,"w")) == (FILE *)NULL)
		{
		fprintf(stderr,
	        "detex: Cannot open scratch file [%s]\n",scratch_file);
		exit(-1);
		}
	scrbuf(stdin,scr);
	fclose(scr);
	scr=fopen(scratch_file,"r");
	unlink(scratch_file);
	if (wflag != 1)
		{
		fprintf(stderr,"Checking matching...\n");
		Match(scr);
		fseek(scr,0,0);
		}
/* either expand or buffer */
	if (iflag != 1)
		{ Expand(scr,buf);	fclose(scr); }
	else
		{ tmpbuf(scr,buf);	fclose(scr); }
	if (wflag != 1)
		fprintf(stderr,"Checking matching done\n\n");
	DeTeX(buf,out_file);
	fclose(scr);
	}

/* next process in=inputfiles */
if(getpar_("in","s",string))
	{
	sscanf(string,"%s",filename);
	if((temp=fopen(filename,"r")) != NULL)
		{
		if (wflag != 1)
			{
			fprintf(stderr,"Checking matching...\n");
			fprintf(stderr,"%s:\n",filename);
			Match(temp);
			fprintf(stderr,"\n");
			fseek(temp,0,0);
			}
/* either expand or buffer */
		if (iflag != 1)
			{ Expand(temp,buf);	fclose(temp); }
		else
			{ tmpbuf(temp,buf);	fclose(temp); }
		if (wflag != 1)
			fprintf(stderr,"Checking matching done\n\n");
		DeTeX(buf,out_file);
		fclose(temp);
		}
	else
		fprintf(stderr,"detex: Cannot open %s\n",filename);
	}

/* then process input line for arguments and assume they are input files */
xargc = argc;
xargv = argv;

for (xargc--,xargv++; xargc; xargc--,xargv++)
	{
	cptr = *xargv; 
	if( *cptr=='-' ) continue; /* this is a flag */
	while (*cptr)
		{
		if (*cptr == '=')  break; /* this is for getpar */
		cptr++;
		}       
	if (*cptr)  continue;
	cptr = *xargv;
	if((temp=fopen(cptr,"r")) != (FILE *)NULL)
		{
		if (wflag != 1)
			{
			fprintf(stderr,"Checking matching...\n");
			fprintf(stderr,"%s:\n",cptr);
			Match(temp);
			fprintf(stderr,"\n");
			fseek(temp,0,0);
			}
/* either expand or buffer */
		if (iflag != 1)
			{ Expand(temp,buf);	fclose(temp); }
		else
			{ tmpbuf(temp,buf);	fclose(temp); }
		if (wflag != 1)
			fprintf(stderr,"Checking matching done\n\n");
		DeTeX(buf,out_file);
		fclose(temp);
		}
	else
		fprintf(stderr,"detex: Cannot open %s\n",cptr);
	}

}
SHAR_EOF
fi # end of overwriting check
if test -f 'inc_file'
then
	echo shar: will not over-write existing file "'inc_file'"
else
cat << \SHAR_EOF > 'inc_file'
This is an included file.
when texexpand is run on testfile, this file should be inserted.
(unmatching in inc_file))
END OF INSERTED FILE.
SHAR_EOF
fi # end of overwriting check
if test -f 'inc_file2.tex'
then
	echo shar: will not over-write existing file "'inc_file2.tex'"
else
cat << \SHAR_EOF > 'inc_file2.tex'
This is another included file
SHAR_EOF
fi # end of overwriting check
if test -f 'makefile'
then
	echo shar: will not over-write existing file "'makefile'"
else
cat << \SHAR_EOF > 'makefile'
CFLAGS = -O
LINTFLAGS = -abchnpux
CSUBS = Expand.c Match.c subs.c
OSUBS = Expand.o Match.o subs.o
B =

default: all

all: texexpand detex texeqn texmatch

texexpand: texexpand1.o $(OSUBS)
	cc $(CFLAGS) -o $(B)texexpand texexpand1.o $(OSUBS)

detex: detex1.o DeTeX.o $(OSUBS)
	cc $(CFLAGS) -o $(B)detex detex1.o DeTeX.o $(OSUBS)

texeqn: texeqn1.o Eqn.o $(OSUBS)
	cc $(CFLAGS) -o $(B)texeqn texeqn1.o Eqn.o $(OSUBS)

texmatch: texmatch1.o $(OSUBS)
	cc $(CFLAGS) -o $(B)texmatch texmatch1.o $(OSUBS)

lint:
	lint $(LINTFLAGS) texexpand1.c $(CSUBS) > texexpand.lnt
	lint $(LINTFLAGS) detex1.c DeTeX.c $(CSUBS) > detex.lnt
	lint $(LINTFLAGS) texeqn1.c Eqn.c $(CSUBS) > texeqn.lnt
	lint $(LINTFLAGS) texmatch1.c $(CSUBS) > texmatch.lnt
	
clean:
	/bin/rm -f *.o texexpand detex texeqn texmatch core *junk*
SHAR_EOF
fi # end of overwriting check
if test -f 'makefile.msc'
then
	echo shar: will not over-write existing file "'makefile.msc'"
else
cat << \SHAR_EOF > 'makefile.msc'
#-----------------------------------------------------------------------
# Makefile for textools
# Make targets:
#	(none)	same as all
#	all	produces all executables
#	lint	run lint on sources
#	clean	remove object files
#	share	make ../textools.sh for mailing
#

CFLAGS = -O
LINTFLAGS = -abchnpux
CSUBS = Expand.c Match.c subs.c
OSUBS = Expand.o Match.o subs.o
B =

default: all

all: texexpand detex texeqn texmatch

texexpand: texexpand1.o $(OSUBS)
	cc $(CFLAGS) -o $(B)texexpand texexpand1.o $(OSUBS)

detex: detex1.o DeTeX.o $(OSUBS)
	cc $(CFLAGS) -o $(B)detex detex1.o DeTeX.o $(OSUBS)

texeqn: texeqn1.o Eqn.o $(OSUBS)
	cc $(CFLAGS) -o $(B)texeqn texeqn1.o Eqn.o $(OSUBS)

texmatch: texmatch1.o $(OSUBS)
	cc $(CFLAGS) -o $(B)texmatch texmatch1.o $(OSUBS)

share:
	make clean
	makescript ../textools.sh *

lint:
	lint $(LINTFLAGS) texexpand1.c $(CSUBS) > texexpand.lnt
	lint $(LINTFLAGS) detex1.c DeTeX.c $(CSUBS) > detex.lnt
	lint $(LINTFLAGS) texeqn1.c Eqn.c $(CSUBS) > texeqn.lnt
	lint $(LINTFLAGS) texmatch1.c $(CSUBS) > texmatch.lnt
	
clean:
	\rm -f *.o core *junk* lint.lst
SHAR_EOF
fi # end of overwriting check
if test -f 'makefile.par'
then
	echo shar: will not over-write existing file "'makefile.par'"
else
cat << \SHAR_EOF > 'makefile.par'
# Use this makefile if you have access to getpar(). You then
# need to link with the library that provides it (e.g. -lsep below).
# If you don't use the other makefile (./makefiile).

CFLAGS = -O
LINTFLAGS = -abchnpux
CSUBS = Expand.c Match.c subs.c
OSUBS = Expand.o Match.o subs.o
B =

default: all

all: texexpand detex texeqn texmatch

texexpand: texexpand2.o $(OSUBS)
	cc $(CFLAGS) -o $(B)texexpand texexpand2.o $(OSUBS) -lsep

detex: detex2.o DeTeX.o $(OSUBS)
	cc $(CFLAGS) -o $(B)detex detex2.o DeTeX.o $(OSUBS) -lsep

texeqn: texeqn2.o Eqn.o $(OSUBS)
	cc $(CFLAGS) -o $(B)texeqn texeqn2.o Eqn.o $(OSUBS) -lsep

texmatch: texmatch2.o $(OSUBS)
	cc $(CFLAGS) -o $(B)texmatch texmatch2.o $(OSUBS) -lsep

lint:
	lint $(LINTFLAGS) texexpand2.c $(CSUBS) > texexpand.lnt
	lint $(LINTFLAGS) detex2.c DeTeX.c $(CSUBS) > detex.lnt
	lint $(LINTFLAGS) texeqn2.c Eqn.c $(CSUBS) > texeqn.lnt
	lint $(LINTFLAGS) texmatch2.c $(CSUBS) > texmatch.lnt
	
clean:
	/bin/rm -f *.o core *junk* lint.lst
SHAR_EOF
fi # end of overwriting check
if test -f 'setups.h'
then
	echo shar: will not over-write existing file "'setups.h'"
else
cat << \SHAR_EOF > 'setups.h'
/* setup file */

#include        <stdio.h>
#ifdef MSC
#include        <string.h>
#include	<stdlib.h>	/* for type declarations */
#include	<io.h>		/* for type declarations */
#else
#include        <strings.h>
#include        <sys/ioctl.h>
#include        <sgtty.h>
#endif

#define MAXLEN	65535		/* maximum number of chars in a document */
#define     MAXWORD	100	/* maximum word length */
#define     MAXLINE	250	/* maximum line length */
#define     MAXENV	50	/* maximum number of environments */

extern char *malloc();

#ifdef IN_TM		/* can only declare globals once */
#else
extern
#endif
struct environment {
	char *env_name;		/* name of environment */
	int env_beg;		/* counter for \begin{environment} */
	int env_end;		/* counter for \end{environment} */
	int beg_line;		/* line number for \beging{environment} */
	} env[MAXENV];

#ifdef ANSI
int	begin_to_end(char*,char*);
int	command(char*,char*);
int	comm_file(FILE*,int*);
int	comment(char*);
int	def(char*,char*);
int	def_file(FILE*,int*);
int	display(char*);
int	dollar(char*,FILE*);
int	formula(char*);
int	get_buf_word(char*,char*);
int	getenv_file(FILE*,int*);
int	get_file_word(FILE*,char*,int*,int*);
int	is_new_env(char*,int);
int	one_dollar(char*);
void	scrbuf(FILE*,FILE*);
void	tmpbuf(FILE*,char*);
int	two_dollars(char*,FILE*);
#else
int	begin_to_end();
int	command();
int	comm_file();
int	comment();
int	def();
int	def_file();
int	display();
int	dollar();
int	formula();
int	get_buf_word();
int	getenv_file();
int	get_file_word();
int	is_new_env();
int	one_dollar();
void	scrbuf();
void	tmpbuf();
int	two_dollars();
#endif
SHAR_EOF
fi # end of overwriting check
##############################   CONNECT HERE   #############################

