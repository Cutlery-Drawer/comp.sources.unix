Subject:  v08i097:  Including PostScript/Macintosh figures in TeX documents, Part02/03
Newsgroups: mod.sources
Approved: mirror!rs

Submitted by: trevor@grasp.cis.upenn.edu (Trevor Darrell)
Mod.sources: Volume 8, Issue 97
Archive-name: psfig-tex/Part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
# If all goes well, you will see the message "End of archive 2 (of 3)."
# Contents:  doc/figs/mac.pro doc/figs/pathtext.ps doc/figs/piechart.ps
#   doc/figs/trianglev.ps doc/figs/zip.ps man/psfigtex.l
#   man/psfigtex.out src/README src/figtex.pro
PATH=/bin:/usr/bin:/usr/ucb; export PATH
echo shar: extracting "'doc/figs/mac.pro'" '(25623 characters)'
if test -f 'doc/figs/mac.pro' ; then 
  echo shar: will not over-write existing file "'doc/figs/mac.pro'"
else
sed 's/^X//' >doc/figs/mac.pro <<'@//E*O*F doc/figs/mac.pro//'
X%!
X% Modified slightly by Ned Batchelder, University of Pennsylvania [Ned].
X%
X% Modified slightly for Textset.  Changes are marked with "jjs".
X%    Jim Sterken
X%    September 20, 1985
X%
X% ------------
X%
X%		 Macintosh LaserWriter header file.
X%
X% This is a file of PostScript definitions that can be affixed to the
X% front of the PostScript files generated by Macintosh applications in order
X% that they can be printed on a LaserWriter that has not been initialized
X% with the "LaserPrep" package. This situation will arise if you are
X% trying to share a LaserWriter between Macintosh users and non-Macintosh
X% users.
X%
X% Macintosh applications do not normally generate straight PostScript.
X% They generate a file in PostScript format, but the contents of the file
X% is a series of calls on functions that are not part of the PostScript
X% language. This file defines those functions.
X%
X% This is not the official Apple header file. It is neither endorsed nor
X% condemned by Apple. I suspect that it probably started out its life
X% as a bootleg copy of a version of the Apple header file. It has been
X% slightly modified by me and perhaps heavily modified by various other
X% people. I have substantially augmented the comments so that they explain
X% what I think the code is doing.
X%
X%	Brian Reid	Reid@SU-Glacier.ARPA
X%	Stanford	{decwrl,hplabs,bellcore}!glacier!reid
X%
X% WARNING: There is no guarantee that Apple will stick to this particular
X% set of definitions. This header file works with the application software
X% that came with my LaserWriter; I make no promises that it will work with
X% the software on anybody else's LaserWriter.
X%
X% To convert this file back into a downloaded file instead of a header
X% file, uncomment all of the lines beginning with %-%
X 
X%-%0000000			% Server loop exit password
X%-%serverdict begin exitserver
X%-%  systemdict /statusdict known
X%-%  {statusdict begin 9 0 3 setsccinteractive /waittimeout 300 def end}
X%-% if
X/md 200 dict def		% define a working dictionary
Xmd begin			% start using it
X/av 13 def			% define apple version
X/mtx matrix currentmatrix def	% save current transformation
X/s30 30 string def
X/s1 ( ) def
X/pys 1 def
X/pxs 1 def
X/pyt 760 def
X/pxt 29.52 def
X/por true def
X/xl {translate} def
X/fp {pnsh 0 ne pnsv 0 ne and} def
X 
X% Define QuickDraw operators as an array of procedures.
X% They are {frame, paint, erase, invert, fill}
X% For some reason "invert" is a no-op.
X 
X/vrb [
X{fp
X {gsave 1 setlinewidth pnsh pnsv scale stroke grestore}
X if newpath}
X{eofill}
X{eofill}
X{newpath}
X{eofill}
X{initclip eoclip newpath}
X{newpath}	% [Ned] Some figures were painting an all black page.
X{}
X{}
X{}
X] def
X 
X% convenience function for backwards def
X/xdf {exch def} def
X 
X% get current halftone screen parameters
Xcurrentscreen
X	/spf xdf		% spot function
X	/rot xdf		% rotation
X	/freq xdf		% spatial frequency
X 
X% "apply" function to execute appropriate numbered operator from /vrb.
X/doop {vrb exch get exec} def
X 
X% compute page position from portrait/landscape flag, translation, scale,
X%	and resolution.
X%  call: P/L-flag xtransl ytransl scale*100 xbits/inch ybits/inch psu
X% typical call: F 580 760 100 72 72 psu for life-size screen-resolution
X% image.
X%
X/psu
X  {2 index .72 mul exch div /pys xdf	% pixel y scale
X  div .72 mul /pxs xdf			% pixel x scale
X /pyt xdf				% pixel y translation
X /pxt xdf				% pixel x translation
X /por xdf				% portrait flag (T=portrait)
X} def
X 
X% argument is page y size; use this to determine legal, letter, or note
X% and to set up appropriate scale factors and translation/reflection
X% for portrait or landscape.
X 
X/txpose{
X    dup 1680 eq
X    %
X    % I've disabled this because it was blanking the page (jjs)
X    %
X    % userdict /note known
X    %   {{legal}{note}ifelse}
X    %   {pop}
X    % ifelse
X    dup 1212 eq {54 32.4 xl} if
X    1321 eq {8.64 -.6 xl} if
X    pxs pys scale pxt pyt xl 
X    por not {270 rotate} if
X    1 -1 scale
X} def
X 
X% Compute oblique shear value for font if flag true
X/obl {{0.212557 mul}{pop 0} ifelse} def
X 
X%  set font from dictionary: make a font, set it to current, leave on stack
X%  call: "found-font size oblique-flag dictionary sfd"
X/sfd {
X   [ps 0 ps 6 -1 roll obl ps neg 0 0] makefont
X   dup setfont
X} def
X/fnt {findfont sfd} def
X 
X% bit test-- "number mask-word bt" returns boolean and unchanged number
X% thus, "4095 512 bt" returns "true 4095" -- the argument is a mask
X% and not a bit number.
X 
X/bt {1 index and 0 ne exch} def
X 
X% load style array with unpacked true/false flags from style word
X% flags are Bold, Italic, Underline, Outline, Shadow (I don't know
X% what the 6th one is supposed to be).
X/sa 6 array def
X/fs {
X    1 bt     2 bt    4 bt    8 bt   16 bt
X   sa astore pop
X} def
X 
X/matrix1 matrix def
X/matrix2 matrix def
X/gf{
X  currentfont
X} def
X 
X% set translation center from 2 double-precision integers giving x,y
X/tc{
X   32768 div add		% compute y location
X   3 1 roll
X   32768 div add		% compute x location
X   2t astore pop		% save 'em
X} def
X 
X/3a [0 0 0] def
X/2t 2 array def
X 
X% store transformation params: "justify flip rotation tp"
X% (left/center/right/full, none/yflip,xflip, degrees)
X/tp{
X   3a astore pop
X} def
X/ee {} def
X 
X% move PostScript current position to QuickDraw current position,
X% and get scaling and rotation right (this is in preparation for
X% outputting text
X/tt {
X   gsave
X     currentpoint 2 copy
X     2t aload pop qa 2 copy xl
X     3a aload pop exch dup 0 eq
X     {pop}
X     {1 eq {-1 1}
X	   {1 -1}ifelse scale}
X     ifelse
X     rotate
X     pop neg exch neg exch xl
X     moveto
X} def
X 
X/te {				% text-end: undo effects of prior "tt"
X   currentpoint currentfont
X   grestore setfont moveto	% but leave font and currentpoint set
X} def
X 
X/tb {
X   /tg currentgray def
X   3 -1 roll 3 eq
X   {1 setgray} if
X   /ml 0 def /al 0 def
X} def
X 
X/am {
X   ml add /ml xdf
X} def
X 
X/aa {
X   [currentgray /setgray cvx] cvx
X   exch dup wi pop dup al add /al xdf exch
X} def
X 
X% scale by rational value (quotient) in x and y. Set "scaleflag" to
X% record that we have done this.
X 
X/th {
X   3 -1 roll div
X   3 1 roll exch div
X% not sure of "transform" in next line (BKR)
X   2 copy matrix1 transform scale
X   pop scale
X   /scaleflag true def
X} def
X 
X% undo a "th" scaling and return to default coordinate system
X/tu {
X   1 1 matrix1 itransform scale
X   /scaleflag false def
X} def
X 
X/ts {
X   1 1 matrix1 transform scale
X   /scaleflag true def
X} def
X 
X% record point size (of fonts)
X/fz{/ps xdf} def
X 
X% execute a procedure but leave it on the stack
X/fx{dup exec} def
X 
X/st{show pop pop} def
X 
X% text munger. This does the dirty work for the edit string procedure
X% (following) by iterating over a polymorphic array and doing the right
X% thing with what it finds there.
X/tm {
X      {dup type dup /integertype eq exch /realtype eq or
X	 {dup ml mul}
X	 {dup type /stringtype eq
X	    {rs}
X	    {dup type /dicttype eq
X	       {setfont}
X	       {dup type /arraytype eq
X		  {exec}
X		  {pop}
X		  ifelse
X	       } ifelse
X	    } ifelse
X	 } ifelse
X      } forall
X   } def
X 
X% edit string. Takes a font, a text mode, a justification mode, and an
X% array of text and font changes for that text, and does it.
X/es {
X   3 -1 roll dup sa 5 get dup type /nulltype eq
X   {pop4 pop}
X   {sa 1 get
X      {/ml ml .2 ps mul sub def} if
X      ne {fs}
X	 {pop}
X      ifelse exch
X      dup 1 eq			% justification mode 1 is left-justify
X      {pop
X	 al ml gt
X	 {/tv {ll} /ml ml al dup 0 ne
X	    {div}{pop} ifelse
X	 def}
X	 {/tv {st} /ml 1 def}
X	 ifelse def tm
X      }
X      {dup 3 eq 		% justification mode 3 is right-justify
X      {pop
X      al ml gt
X      {/tv {ll} /ml ml al dup 0 ne
X	{div}{pop} ifelse
X	def}
X      {ml al sub 0 rmoveto
X	/tv {st} /ml 1 def}
X      ifelse def
X	 tm}
X      {2 eq			% justification mode 3 is centered
X      {al ml gt
X	 { /tv {ll} /ml ml al dup
X	   0 ne
X	   {div}{pop}
X	   ifelse def}
X	 {ml al sub 2 div 0 rmoveto
X	   /tv {st} /ml 1 def}
X	   ifelse def
X	 tm}
X      { 			% otherwise it is just "justified"
X	/tv {ll} def
X	/ml ml al dup 0 ne
X	  {div}{pop}
X	  ifelse def
X	 tm}
X       ifelse}
X     ifelse}
X   ifelse}
X   ifelse
X   tg setgray
X}def
X 
X/pop4 {pop pop pop pop} def
X% --------------------------------------------------------------------
X%			 QuickDraw Procedures
X%
X% moveto. If a scale factor is in effect, then honor it.
X/gm {
X  scaleflag {matrix1 itransform} if
X  moveto
X} def
X 
X%local y move
X% call: "x y localy ly"
X/ly {
X   exch pop
X   currentpoint exch pop
X   sub 0 exch rmoveto
X} def
X 
X% print n copies of page  (ensures full speed for multiple copies)
X/page {
X   1 add /#copies xdf showpage
X} def
X 
X/sk {
X   systemdict /statusdict known
X} def
X 
X% set job name
X/jn {
X   sk {statusdict /jobname 3 -1 roll put}
X      {pop}
X   ifelse
X} def
X 
X% set pen size: h v pen
X/pen {
X   /pnsv xdf
X   /pnsh xdf
X   pnsh setlinewidth
X} def
X 
X% draw line
X% (uses current pen location, pen size and graylevel)
X% This emulates the ugly QuickDraw pen on the LaserWriter but
X% preserves the same endpoint and linewidth anomalies that some applications
X% rely on. (Bletch).
X/dlin {
X   currentpoint newpath moveto
X   lineto currentpoint stroke
X   grestore moveto
X} def
X 
X/lin {
X   currentpoint /pnlv xdf /pnlh xdf
X   gsave newpath /@y xdf /@x xdf fp
X   {pnlh @x lt
X      {pnlv @y ge
X	 {pnlh pnlv moveto @x @y lineto
X	  pnsh 0 rlineto
X	  0 pnsv rlineto
X	  pnlh pnsh add pnlv pnsv add lineto
X	  pnsh neg 0 rlineto}
X	 {pnlh pnlv moveto
X	  pnsh 0 rlineto
X	  @x pnsh add @y lineto
X	  0 pnsv rlineto
X	  pnsh neg 0 rlineto
X	  pnlh pnlv pnsv add lineto}
X	 ifelse}
X      {pnlv @y gt
X	 {@x @y moveto pnsh 0 rlineto
X	  pnlh pnsh add pnlv lineto
X	  0 pnsv rlineto
X	  pnsh neg 0 rlineto
X	  @x @y pnsv add lineto}
X	 {pnlh pnlv moveto pnsh 0 rlineto
X	  0 pnsv rlineto
X	  @x pnsh add @y pnsv add lineto
X	  pnsh neg 0 rlineto
X	  0 pnsv neg rlineto}
X	 ifelse}
X      ifelse
X      closepath fill}
X   if @x @y grestore moveto
X} def
X 
X/dl {
X   gsave
X   0 setlinewidth 0 setgray
X} def
X 
X% Arc: top left bottom right startangle stopangle verb flag
X% flag true means to exclude the center of curvature in the arc
X/barc {
X   /@f xdf   /@op xdf	/@e xdf   /@s xdf
X   /@r xdf   /@b xdf	/@l xdf   /@t xdf
X   gsave
X   @r @l add 2 div @b @t add 2 div xl 0 0 moveto
X   @r @l sub @b @t sub mtx currentmatrix pop scale
X   @f {newpath} if
X   0 0 0.5 @s @e arc
X   mtx setmatrix @op doop
X   grestore
X} def
X/doarc {dup 0 eq barc} def
X 
X% oval:  top left bottom right verb
X/doval {0 exch 360 exch true barc} def
X 
X% rectangle:  top left bottom right verb
X/dorect {
X   /@op xdf currentpoint 6 2 roll
X   newpath 4 copy
X   4 2 roll exch moveto
X   6 -1 roll lineto
X   lineto lineto closepath
X   @op doop moveto
X} def
X 
X/mup {dup pnsh 2 div le exch pnsv 2 div le or} def
X 
X% roundrect:  top left bottom right ovalwidth ovalheight operation
X% Warning: ovalwidth is assumed equal to ovalheight.
X/dorrect {
X   /@op xdf	2. div /@h xdf	   2. div /@w xdf
X   /@r xdf	/@b xdf 	   /@l xdf /@t xdf
X   @t @b eq @l @r eq @w mup or or
X   {@t @l @b @r @op dorect}
X   {@r @l sub 2. div dup @w lt
X      {/@w xdf}{pop}
X      ifelse
X      @b @t sub 2. div dup @w lt
X      {/@w xdf}{pop}
X      ifelse
X      @op 0 eq
X      {/@w @w pnsh 2 div sub def}
X      if		   %this helps solve overlap gap for wide line widths
X      currentpoint
X      newpath
X      @r @l add 2. div @t moveto
X      @r @t @r @b @w arcto pop4
X      @r @b @l @b @w arcto pop4
X      @l @b @l @t @w arcto pop4
X      @l @t @r @t @w arcto pop4
X      closepath @op doop
X      moveto
X   }ifelse
X} def
X 
X% Polygon utility procedures
X/pr {
X   gsave newpath /pl
X      {moveto
X       /pl {lineto} def
X      }def
X} def
X 
X/pl {lineto} def
X 
X/ep {
X   dup 0 eq
X    {
X     {moveto}{lin}{}{}
X     pathforall %nothing but movetos and linetos should be called
X     pop grestore
X    }
X    {
X     doop grestore
X    }
X    ifelse
X} def
X 
X/bs 8 string def
X/bd {/bs xdf} def
X 
X 
X 
X% These following procedures are used in defining QuickDraw patterns.
X% (Pattern definition goes into halftone screen of PostScript)
X 
X% procedure to find black bits in QuickDraw pattern (pattern in hex string bs)
X/bit {bs exch get exch 7 sub bitshift 1 and} def
X/bix {1 add 4 mul cvi} def
X/pp{exch bix exch bix bit}def
X/grlevel {64. div setgray} def
X 
X 
X% procedure to set a pattern: ratio hexstring
X% ratio is the total number of white bits in the QuickDraw pattern represented in hexstring
X 
X/setpat {
X   /bs xdf
X   9.375 0 {pp} setscreen
X   grlevel
X} def
X 
X/setgry {
X   freq rot {spf} setscreen
X   grlevel
X} def
X 
X% standard copybits routine:
X% arguments: xscale yscale xloc yloc rowbytes xwidth ywidth fsmooth bitmode
X% This procedure is the basis for all QuickDraw bit operations.
X% xscale and yscale tell how much to scale the bit image in 72nds of an inch
X% xloc and yloc are the location of the top left corner of the bitmap
X% rowbytes is the total number of bytes in each scanline of hex data in the
X% image.
X%    Note that rowbytes must be even.
X% xwidth and ywidth are the actual number of bits in the x and y coordinates
X% of the image. fsmooth is a flag to tell whether or not to use bit
X% smoothing.  Bit smoothing is a
X% proprietary algorithm that provides smoothing of the data around a 5 by 5
X% local area of each data pixel.
X% bitmode can be any of the QuickDraw source transfer modes excluding srcXor
X% and notSrcXor.
X%    Note that this is the only QuickDraw procedure that can implement
X% more than the simple srcCopy transfer mode.
X 
X/x4 {2 bitshift} def
X/d4 {-2 bitshift} def
X/xf {.96 mul exch 2 sub .96 mul exch} def
X/dobits
X{
X   /bmode xdf
X   save 9 1 roll
X% 2 sub fixes dxsrc offset number required for bitsmoothing, but applies
X% to both
X 
X%Bit Smooth mode
X   {
X   x4 /@dy xdf 2 sub x4 /@dx xdf /@idx xdf
X   .96 mul exch 3 index 2 sub @dx div 7.68 mul dup 6 1 roll sub exch xl 0 0 moveto xf
X   0 4 -1 roll 2 index 4 index 1.759 add 10 dorect clip newpath 0 0 moveto scale
X   bmode 0 eq bmode 4 eq or{1 setgray 1 @dy div 1 @dx div 1 1 2 dorect}if
X   bmode 3 eq bmode 7 eq or{1}{0}ifelse setgray
X   @idx 5 bitshift @dy bmode 0 eq bmode 1 eq bmode 3 eq or or [@dx 0 0 @dy 0 0]
X     {(%stdin)(r) file @dy d4 4 add @idx mul string readhexstring pop
X     dup length @idx x4 sub 4 bitshift string
X     dup 3 1 roll @dx 8 add d4 smooth} imagemask
X   }
X%Non Bit Smooth mode
X   {
X   /@dy xdf 2 sub /@dx xdf /@idx xdf
X   /@xs @idx string def
X   /@f (%stdin)(r) file def
X   /@p{@f @xs readhexstring pop}def
X   .96 mul xl 0 0 moveto xf scale
X   0 0 1 1 10 dorect clip newpath 0 0 moveto
X   bmode 0 eq bmode 4 eq or{1 setgray .25 @dy div .25 @dx div 1 1 2 dorect}if
X   bmode 3 eq bmode 7 eq or{1}{0}ifelse setgray
X   @p @p
X   @idx 3 bitshift @dy bmode 0 eq bmode 1 eq bmode 3 eq or or [@dx 0 0 @dy 0 0]
X   {@p} imagemask
X   @p @p pop4
X   }ifelse
Xrestore
X} def
X 
X 
X% Making Mac compatible Fonts
X 
X 
X/mfont 14 dict def
X/wd 14 dict def
X/mdef {mfont wcheck not{/mfont 14 dict def}if mfont begin xdf end} def
X/dc {transform round .5 sub exch round .5 sub exch itransform} def
X 
X 
X% Copy a font dictionary: fontdictionary
X% copies a font dictionary into tmp so it may be used to define a new font
X 
X% tmp must be set before cf is called
X/cf{{1 index /FID ne {tmp 3 1 roll put}{pop pop}ifelse}forall}def
X 
X 
X% Procedures used in defining a bit map font
X 
X/mv{tmp /Encoding macvec put}def
X/bf{
Xmfont begin
X/FontType 3 def
X/FontMatrix [1 0 0 1 0 0] def
X/FontBBox [0 0 1 1] def
X/Encoding macvec def
X/BuildChar
X  {
X  wd begin
X    /cr xdf
X    /fd xdf
X    fd /low get cr get 2 get -1 ne
X    {
X    fd begin
X      low cr get aload pop
X      sd
X      low cr 1 add get 0 get
X      sh
X      sw
X    end
X    /sw xdf
X    /sh xdf
X    sw div /clocn xdf
X    dup 0 ne {0 exch sh div neg dc xl}{pop}ifelse
X    exch sw div /coff xdf
X    exch sw div /cloc xdf
X    /bitw clocn cloc sub def
X    sw sh div 1 scale
X    sw div 0 coff 0 bitw coff add 1 setcachedevice
X    coff cloc sub 0 dc xl
X    cloc .5 sw div add 0 dc newpath moveto
X    bitw 0 ne
X      {0 1 rlineto bitw .5 sw div sub 0 rlineto 0 -1 rlineto
X	closepath clip
X      sw sh false [sw 0 0 sh neg 0 sh]{fd /hm get}imagemask}if
X    } if
X  end
X  } def
Xend
Xmfont definefont pop
X} def
X 
X 
X% stringwidth procedure which does not allow a show to occur: (string)
X 
X/wi{save exch /show{pop}def
Xstringwidth 3 -1 roll restore}def
X 
X/aps {0 get 124 eq}def
X/apn {s30 cvs aps} def
X 
X 
X%set style in a PostScript name: AppleFontName
X% e.g.
X% /|----name sos /|---Oname
X% /|----name sis /|-I--name
X 
X/xc{s30 cvs dup}def
X/xp{put cvn}def
X/scs{xc 3 67 put dup 0 95 xp}def
X/sos{xc 3 79 xp}def
X/sbs{xc 1 66 xp}def
X/sis{xc 2 73 xp}def
X/sob{xc 2 79 xp}def
X/sss{xc 4 83 xp}def
X 
X/dd{exch 1 index add 3 1 roll add exch} def
X/smc{moveto dup show} def
X/kwn{dup FontDirectory exch known{findfont exch pop}}def
X/fb{/ps ps 1 add def}def
X/mb
X{dup sbs kwn
X   {
X   exch{pop}{bbc}{} mm
X   }ifelse
Xsfd
X}def
X/mo
X{dup sos kwn
X   {
X   exch{pop}{boc}{} mm
X   }ifelse
Xsfd
X}def
X/ms
X{dup sss kwn
X   {
X   exch{pop}{bsc}{} mm
X   }ifelse
Xsfd
X}def
X 
X/ao
X{dup sos kwn
X   {
X   exch dup ac pop
X   {scs findfont /df2 xdf}{aoc}{} mm
X   }ifelse
Xsfd
X}def
X 
X/as
X{dup sss kwn
X   {
X   exch dup ac pop
X   {scs findfont /df2 xdf}{asc}{} mm
X   }ifelse
Xsfd
X}def
X 
X/ac
X   {
X   dup scs kwn
X      {exch /ofd exch findfont def
X      /tmp ofd maxlength 1 add dict def
X      ofd cf mv
X      tmp /PaintType 1 put
X      tmp definefont}ifelse
X   }def
X 
X/mm{
X/mfont 10 dict def
Xmfont begin
X/FontMatrix [1 0 0 1 0 0] def
X/FontType 3 def
X/Encoding macvec def
X/df 4 index findfont def
X/FontBBox [0 0 1 1] def
X/xda xdf
X/mbc xdf
X/BuildChar { wd begin
X  /cr xdf
X  /fd xdf
X  /cs s1 dup 0 cr put def
X  fd /mbc get exec
X  end
X} def
Xexec
Xend
Xmfont definefont} def
X/bbc
X{
X  /da .03 def
X  fd /df get setfont
X  gsave
X    cs wi exch da add exch %%%% (used to be "exchd", a bug)
X  grestore
X  setcharwidth
X  cs 0 0 smc
X    da 0 smc
X    da da smc
X     0 da moveto show
X} def
X 
X/boc
X{
X  /da 1 ps div def
X  fd /df get setfont
X  gsave
X    cs wi
X    exch da add exch
X  grestore
X  setcharwidth
X  cs 0 0 smc
X    da 0 smc
X    da da smc
X     0 da smc
X  1 setgray
X     da 2. div dup moveto show
X} def
X 
X/bsc
X{
X  /da 1 ps div def
X  /ds .05 def %da dup .03 lt {pop .03}if def
X  /da2 da 2. div def
X  fd /df get setfont
X  gsave
X    cs wi
X    exch ds add da2 add exch
X  grestore
X  setcharwidth
X  cs ds da2 add .01 add 0 smc
X      0 ds da2 sub xl
X      0  0 smc
X     da  0 smc
X     da da smc
X      0 da smc
X  1 setgray
X      da 2. div dup moveto show
X} def
X/aoc
X{
X  fd /df get setfont
X  gsave
X    cs wi
X  grestore
X  setcharwidth
X  1 setgray
X  cs 0 0 smc
X  fd /df2 get setfont
X  0 setgray
X  0 0 moveto show
X}def
X/asc
X{
X  /da .05 def
X  fd /df get setfont
X  gsave
X    cs wi
X    exch da add exch
X  grestore
X  setcharwidth
X  cs da .01 add 0 smc
X      0 da xl
X  1 setgray
X      0 0 smc
X  0 setgray
X  fd /df2 get setfont
X      0 0 moveto show
X}def
X 
X/T true def
X/F false def
X 
X 
X% More Polygon stuff used in polygon comment
X 
X/6a 6 array def
X/2a 2 array def
X/5a 5 array def
X%subtract points, first from second (reverse order):  pt0 pt1 qs newpt
X/qs{3 -1 roll sub exch 3 -1 roll sub exch}def
X/qa{3 -1 roll add exch 3 -1 roll add exch}def
X%multiply point: pt factor qm newpt
X/qm{3 -1 roll 1 index mul 3 1 roll mul}def
X/qn{6a exch get mul}def
X/qA .166667 def /qB .833333 def /qC .5 def
X/qx{
X   6a astore pop
X   qA 0 qn qB 2 qn add	qA 1 qn qB 3 qn add
X   qB 2 qn qA 4 qn add	qB 3 qn qA 5 qn add
X   qC 2 qn qC 4 qn add	qC 3 qn qC 5 qn add
X}def
X/qp{6 copy 12 -2 roll pop pop}def
X/qc{qp qx curveto}def
X/qi{{4 copy 2a astore aload pop qa .5 qm newpath moveto}{2 copy 6 -2 roll 2 qm qs 4 2 roll}ifelse}def
X/qq{{qc 2a aload pop qx curveto}{4 copy qs qa qx curveto}ifelse}def
X 
X%start polygon comment
X/pt{gsave currentpoint newpath moveto}def
X 
X%fill smoothed poly
X/qf{gsave eofill grestore}def
X/tr{currentgray currentscreen bs 5a astore pop /fillflag 1 def}def
X/bc{/fillflag 0 def}def
X 
X%polyverb ec
X/ec{currentpoint 3 -1 roll
X   1 and 0 ne
X   {currentgray currentscreen bs 5a aload pop bd setscreen setgray 0 doop bd setscreen setgray}
X   {newpath}ifelse
X   moveto
X}def
X 
X/bp {
X   currentpoint newpath 2 copy moveto
X   currentgray currentscreen bs 5a astore pop
X} def
X 
X/eu{
X   fillflag 0 ne
X   {
X   gsave currentgray currentscreen bs
X   5a aload pop bd setscreen setgray
X   4 ep
X   bd setscreen setgray
X   }if
X   fp{0 ep}{grestore newpath}ifelse
X}def
X 
X 
X% Line Layout stuff used by string merging algorithm
X 
X% counts spaces in string:   (...) sm (...) n
X% returns string and number of spaces in string
X 
X/sm
X{
Xdup 0 exch
X{32 eq{1 add}if}forall
X}
Xdef
X 
X 
X% layout a string to length specified by desiredlength:  printerlength desiredlength (...) ll
X% printerlength is length of string in printer space
X 
X/ll
X{
X3 1 roll exch dup .0001 lt 1 index -.0001 gt and
X{pop pop pop}
X{sub dup 0 eq
X   {
X   pop show
X   }
X   {
X   1 index sm dup 0 eq 3 index 0 le or
X      {
X      pop length div
X      0 3 -1 roll ashow
X      }
X      {
X% This piece does 10 percent stretching in characters and 90 percent in spaces
X      10 mul exch length add div
X      dup 10 mul 0 32 4 -1 roll 0 6 -1 roll awidthshow
X% This piece does straight stretching in spaces only
X%      exch pop div
X%      0 32 4 -1 roll widthshow
X      }ifelse
X   }ifelse
X}ifelse
X}def
X 
X 
X%set font to symbol and show the string: (...) ss
X 
X/ss
X{  /pft currentfont def sa aload pop pop /|----2Symbol 4 1 roll
X   {pop{as}}
X   {{{ao}}{{fnt}}ifelse}ifelse
X   exch pop exec exch pop
X}def
X/pf{pft dup setfont}def
X 
X 
X% regular show does underline if ulf is true:
X% arguments: printerlength desiredlength string rs
X 
X/rs
X{
X   sa 2 get
X   {
X   gsave
X   1 index 0
X   currentfont
X   dup /FontInfo known
X      {
X      /FontInfo get
X      dup /UnderlinePosition known
X	 {
X	 dup /UnderlinePosition get 1000 div ps mul
X	 }
X	 {
X	 ps 10 div neg	%15 makes line closer to text
X	 }ifelse
X      exch
X      dup /UnderlineThickness known
X	 {
X	 /UnderlineThickness get 1000 div ps mul
X	 }
X	 {
X	 pop
X	 ps 15 div  %20 makes slightly narrower line
X	 }ifelse
X      }
X      {
X      pop
X      ps 10 div neg   %15 makes line closer to text
X      ps 15 div       %20 makes slightly narrower line
X      }ifelse
X   setlinewidth
X   0 setgray
X   currentpoint 3 -1 roll sub moveto
X   sa 4 get{gsave currentlinewidth 2. div dup rmoveto currentpoint xl 2 copy rlineto
X   stroke grestore}if
X   sa 3 get sa 4 get or 3 1 roll 2 index{gsave 1 setgray 2 copy rlineto stroke grestore}if
X   rlineto{strokepath 0 setlinewidth}if stroke
X   grestore
X   }if
X   tv
X}
Xdef
X 
X 
X%  More Font building stuff, specifically the Apple Encoding Vector
X 
X% Font encoding vector for PostScript fonts to match Mac
X/macvec 256 array def
Xmacvec 0
X/Times-Roman findfont /Encoding get
X0 128 getinterval putinterval macvec 39 /quotesingle put
X /dotlessi /grave /circumflex /tilde /cedilla /registerserif
X /copyrightserif /trademarkserif
Xmacvec 0 8 getinterval astore pop
X /Adieresis /Aring /Ccedilla /Eacute /Ntilde /Odieresis /Udieresis /aacute
X /agrave /acircumflex /adieresis /atilde /aring /ccedilla /eacute /egrave
X /ecircumflex /edieresis /iacute /igrave /icircumflex /idieresis /ntilde
X /oacute  /ograve /ocircumflex /odieresis /otilde /uacute /ugrave
X /ucircumflex /udieresis
X /dagger /ring /cent /sterling /section /bullet /paragraph /germandbls
X /registersans /copyrightsans /trademarksans /acute /dieresis /notequal
X /AE /Oslash
X /infinity /plusminus /lessequal /greaterequal /yen /mu /partialdiff
X /summation
X /product /pi /integral /ordfeminine /ordmasculine /Omega /ae /oslash
X /questiondown /exclamdown /logicalnot /radical /florin /approxequal /Delta
X /guillemotleft  /guillemotright /ellipsis /space /Agrave /Atilde /Otilde
X /OE /oe /endash /emdash /quotedblleft /quotedblright /quoteleft
X /quoteright /divide /lozenge /ydieresis /Ydieresis /fraction /currency
X /guilsinglleft /guilsinglright /fi /fl /daggerdbl /periodcentered
X /quotesinglbase /quotedblbase /perthousand /Acircumflex /Ecircumflex /Aacute
X /Edieresis /Egrave /Iacute /Icircumflex /Idieresis /Igrave /Oacute
X /Ocircumflex /apple /Ograve /Uacute /Ucircumflex /Ugrave /dotlessi
X /asciicircum /asciitilde /macron /breve /dotaccent /ring /cedilla
X /hungarumlaut /ogonek /caron
Xmacvec 128 128 getinterval astore pop
X 
X% now redefine all fonts using the MAC Encoding (except in Symbol) to make
X% them be Apple compatible.
X 
XFontDirectory
X{exch dup s30 cvs /@s xdf @s aps
X   {pop pop}
X   {exch dup length dict /tmp xdf
X      cf
X      /Symbol ne {mv} if
X      /@i false def /@o false def /@b false def
X      mark @s (Italic) search {/@i true def} if (Oblique) search {/@o true def} if
X      (Bold) search {/@b true def} if (Roman) search pop (-) search pop /@s xdf cleartomark
X      @s cvn dup /Symbol eq{pop 50}{/Courier eq{51}{49}ifelse}ifelse
X      s30 0 @s length 6 add getinterval dup 6 @s putinterval dup 0 (|-----) putinterval
X      @b {dup 1 66 put} if @i @o or {dup 2 73 put} if % @o {dup 2 79 put} if
X      dup 5 4 -1 roll put
X      cvn tmp definefont pop
X   }ifelse
X}forall
X 
X 
X%Make any other special fonts here, i.e. Seattle
X 
X/_--C-2Symbol /Symbol findfont /tmp 1 index maxlength 1 add dict def cf tmp /PaintType 1 put tmp definefont
X/|----4Seattle /Helvetica findfont dup length 1 add dict /tmp xdf cf mv
X/mxv [/zero /one /two /three /four /five /six /seven /eight /nine /comma /period /dollar /numbersign
X/percent /plus /hyphen /E /parenleft /parenright /space] def
Xtmp /Metrics 21 dict dup begin mxv{600 def}forall end put
Xtmp begin /FontBBox FontBBox [0 0 0 0] astore def end
Xtmp definefont pop
X 
X 
X% open document, open page and close page procedures
X% close document doesn't do anything currently
X 
X% txpose takes the vertical page size as a parameter
X/od{txpose 10 fz 0 fs F /|----3Courier fnt pop}def
X/op{/scaleflag false def /pm save def}def
X/cp{pm restore}def
X 
Xend
X 
X%
X% Add a pop to clean up the stack.  A dictionary is left behind... (jjs)
X%
Xpop
X
@//E*O*F doc/figs/mac.pro//
if test 25623 -ne "`wc -c <'doc/figs/mac.pro'`"; then
    echo shar: error transmitting "'doc/figs/mac.pro'" '(should have been 25623 characters)'
fi
chmod +x 'doc/figs/mac.pro'
fi # end of overwriting check
echo shar: extracting "'doc/figs/pathtext.ps'" '(8455 characters)'
if test -f 'doc/figs/pathtext.ps' ; then 
  echo shar: will not over-write existing file "'doc/figs/pathtext.ps'"
else
sed 's/^X//' >doc/figs/pathtext.ps <<'@//E*O*F doc/figs/pathtext.ps//'
X%!
X%%BoundingBox: 146 359 356 554
X% Cookbook Example Program from First Printing, Revised 7 Jan 1985
X% Program: Placing Text Along an Arbitrary Path     Number: 17
X%-----------------------------------------------------------------------------
X%
X/pathtextdict 26 dict def                   % Local storage for the procedure
X					    % ``pathtext.''
X							   
X/pathtext                                   % ``pathtext'' will place a string
X  { pathtextdict begin                      % of text along any path. It takes
X    /offset exch def                        % a string and starting offset
X    /str exch def                           % distance from the beginning of
X					    % the path as its arguments. Note
X					    % that ``pathtext'' assumes that a
X					    % path has already been defined
X					    % and after it places the text
X					    % along the path, it clears the
X					    % current path like the ``stroke''
X					    % and ``fill'' operators; it also
X					    % assumes that a font has been
X					    % set. ``pathtext'' begins placing
X					    % the characters along the current
X					    % path, starting at the offset
X					    % distance and continuing until
X					    % either the path length is
X					    % exhausted or the entire string
X					    % has been printed, whichever
X					    % occurs first. The results will
X					    % be more effective when a small
X					    % point size font is used with
X					    % sharp curves in the path.
X								       
X    /pathdist 0 def                         % Initialize the distance we have
X					    % travelled along the path.
X    /setdist offset def                     % Initialize the distance we have
X					    % covered by setting characters.
X    /charcount 0 def                        % Initialize the character count.
X    gsave
X      flattenpath                           % Reduce the path to a series of
X					    % straight line segments. The
X					    % characters will be placed along
X					    % the line segments in the
X					    % ``linetoproc.''
X      {movetoproc} {linetoproc}             % The basic strategy is to process
X	{curvetoproc} {closepathproc}       % the segments of the path,
X	pathforall                          % keeping a running total of the
X					    % distance we have travelled so
X					    % far (pathdist). We also keep
X					    % track of the distance taken up
X					    % by the characters that have been
X					    % set so far (setdist). When the
X					    % distance we have travelled along
X					    % the path is greater than the
X					    % distance taken up by the set
X					    % characters, we are ready to set
X					    % the next character (if there are
X					    % any left to be set). This
X					    % process continues until we have
X					    % exhausted the full length of the
X					    % path.
X    grestore
X    newpath                                 % Clear the current path.
X    end
X  } def
X       
Xpathtextdict begin
X/movetoproc                                 % ``movetoproc'' is executed when
X  { /newy exch def /newx exch def           % a moveto component has been
X					    % encountered in the pathforall
X					    % operation.
X    /firstx newx def /firsty newy def       % Remember the ``first point'' in
X					    % the path so that when we get a
X					    % ``closepath'' component we can
X					    % properly handle the text.
X    /ovr 0 def
X    newx newy transform
X    /cpy exch def /cpx exch def             % Explicitly keep track of the
X					    % current position in device
X					    % space.
X  } def
X       
X/linetoproc                                 % ``linetoproc'' is executed when
X					    % a lineto component has been
X					    % encountered in the pathforall
X					    % operation.
X  { /oldx newx def /oldy newy def           % Update the old point.
X    /newy exch def /newx exch def           % Get the new point.
X    /dx newx oldx sub def
X    /dy newy oldy sub def
X    /dist dx dup mul dy dup mul add         % Calculate the distance between
X					    % the old and the new point.
X      sqrt def
X    /dsx dx dist div ovr mul def            % dsx and dsy are used to update
X    /dsy dy dist div ovr mul def            % the current position to be just
X					    % beyond the width of the previous
X					    % character.
X    oldx dsx add oldy dsy add transform
X    /cpy exch def /cpx exch def             % Update the current position.
X    /pathdist pathdist dist add def         % Increment the distance we have
X					    % travelled along the path.
X    { setdist pathdist le                   % Keep setting characters along
X					    % this path segment until we have
X					    % exhausted its length.
X	{ charcount str length lt           % As long as there are still
X	    {setchar} {exit} ifelse }       % characters left in the string,
X					    % set them.
X	{ /ovr setdist pathdist sub def     % Keep track of how much we have
X	  exit }                            % overshot the path segment by
X	ifelse                              % setting the previous character.
X					    % This enables us to position the
X					    % origin of the following
X					    % characters properly on the path.
X    } loop
X  } def
X       
X/curvetoproc                                % ``curvetoproc'' is executed when
X  { (ERROR: No curveto's after flattenpath!)% a curveto component has been
X    print                                   % encountered in the pathforall
X  } def                                     % operation. It prints an error
X					    % message since there shouldn't be
X					    % any curveto's in a path after
X					    % the flattenpath operator has
X					    % been executed.
X							    
X/closepathproc                              % ``closepathproc'' is executed
X  { firstx firsty linetoproc                % when a closepath component has
X    firstx firsty movetoproc                % been encountered in the
X  } def                                     % pathforall operation. It
X					    % simulates the action of the
X					    % operator ``closepath'' by
X					    % executing ``linetoproc'' with
X					    % the coordinates of the most
X					    % recent ``moveto'' and then
X					    % executing ``movetoproc'' to the
X					    % same point.
X							 
X/setchar                                    % ``setchar'' sets the next
X  { /char str charcount 1 getinterval def   % character in the string along
X					    % the path and then updates the
X					    % amount of path we have
X					    % exhausted.
X    /charcount charcount 1 add def          % Increment the character count.
X    /charwidth char stringwidth pop def     % Find the width of the character.
X    gsave
X      cpx cpy itransform translate          % Translate to the current
X					    % position in user space.
X      dy dx atan rotate                     % Rotate the x-axis to coincide
X					    % with the current segment.
X      0 0 moveto char show
X      currentpoint transform
X      /cpy exch def /cpx exch def           % Update the current position
X    grestore                                % before we restore ourselves to
X					    % the untransformed state.
X    /setdist setdist charwidth add def      % Increment the distance we have
X  } def                                     % covered by setting characters.
Xend
X
X
X   
X/Helvetica findfont 11.5 scalefont setfont  % Set up the font we wish to use.
X									     
Xnewpath                                     % Define the path along which we
X					    % wish to place the text.
X  200 500 50 0 270 arc
X  200 80 add 500 50 270 180 arc
X			       
X(If my film makes one more person feel\
X miserable I'll feel I've done my job.\
X -- WOODY ALLEN) 40 pathtext                % Print the string along the path
X					    % at an offset of 40 points.
X									
Xnewpath                                     % Draw an outline shape suggestive
X					    % of a movie camera.
X  165 360 moveto 315 360 lineto             % Draw the box part.
X  315 430 lineto 165 430 lineto
X  closepath
X  315 390 moveto 355 375 lineto             % Draw the lens part.
X  355 415 lineto 315 400 lineto
X1.5 setlinewidth stroke
X		       
X					    % A PROBLEM FOR THE READER: This
X					    % algorithm places characters
X					    % along the path according to the
X					    % origin of each character.
X					    % Rewrite the algorithm so that
X					    % the characters are placed
X					    % according to the center of their
X					    % width. This will yield better
X					    % results around sharp curves and
X					    % when larger point sizes are
X					    % used.
Xshowpage
@//E*O*F doc/figs/pathtext.ps//
if test 8455 -ne "`wc -c <'doc/figs/pathtext.ps'`"; then
    echo shar: error transmitting "'doc/figs/pathtext.ps'" '(should have been 8455 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'doc/figs/piechart.ps'" '(7247 characters)'
if test -f 'doc/figs/piechart.ps' ; then 
  echo shar: will not over-write existing file "'doc/figs/piechart.ps'"
else
sed 's/^X//' >doc/figs/piechart.ps <<'@//E*O*F doc/figs/piechart.ps//'
X%!
X%%BoundingBox: 126 246 486 546
X% Cookbook Example Program from First Printing, Revised 7 Jan 1985
X% Program: Drawing a Pie Chart     Number: 18
X%-----------------------------------------------------------------------------
X%
X/PieDict 24 dict def                        % Local storage for
X					    % ``DrawPieChart'' and its related
X					    % procedures.
XPieDict begin
X  /DrawSlice                                % DrawSlice draws an outlined and
X    { /grayshade exch def                   % filled-in pie slice. It takes
X      /endangle exch def                    % four operands: the label for
X      /startangle exch def                  % this particular pie slice, the
X      /thelabel exch def                    % starting angle for the slice,
X					    % the ending angle for the slice
X					    % and the shade of gray the slice
X					    % should be.
X							
X      newpath                               % Create a path which will draw a
X					    % pie slice.
X	0 0 moveto
X	0 0 radius startangle endangle arc
X      closepath
X	       
X      1.415 setmiterlimit                   % This guarantees that when we
X					    % outline the pie slices with a
X					    % stroke that we will not get a
X					    % spike on the interior angles.
X      gsave grayshade setgray fill grestore % Fill the pie slice path with the
X      stroke                                % appropriate gray color. By using
X					    % gsave and grestore we don't lose
X					    % the current path. Since
X					    % PostScript paints color onto the
X					    % page, it is very important that
X					    % we fill the pie slice first and
X					    % then outline it with a stroke.
X      gsave                                 % Draw the tick mark and place the
X					    % label:
X	startangle endangle add 2 div       % Find the center of the pie slice
X	  rotate                            % and rotate so that the x-axis
X					    % coincides with this center.
X	radius 0 translate                  % Translate the origin out to the
X					    % circumference.
X	newpath
X	  0 0 moveto labelps .8 mul 0 lineto% Draw the tick-mark.
X	stroke
X	labelps 0 translate                 % Move the origin out a little
X					    % beyond the circumference.
X	0 0 transform                       % Next we wish to place the label
X      grestore                              % at the current origin. If we
X      itransform                            % simply draw the text on the page
X      /y exch def /x exch def               % now, it would come out rotated.
X      x y moveto                            % Since this is not desired we
X					    % avoid it by returning to the
X					    % previous unrotated coordinate
X					    % system. Before returning,
X					    % though, we would like to
X      x 0 lt                                % remember the position of the
X	{ thelabel stringwidth pop neg      % current origin on the printed
X	    0 rmoveto                       % page. We will accomplish this by
X	} if                                % using the transform and
X					    % itransform operators. Performing
X					    % a transform on the origin pushes
X					    % the coordinates of the origin in
X					    % device space onto the operand
X					    % stack. Performing a grestore
X					    % returns us to the previous
X					    % unrotated coordinate system.
X					    % Next we perform an itransform on
X					    % the two device coordinates left
X					    % on the stack to determine where
X					    % we are in the current coordinate
X					    % system.
X      y 0 lt { 0 labelps neg rmoveto } if   % Make some adjustments so that
X      thelabel show                         % the label text won't collide
X    } def                                   % with the pie slice.
X  /findgray                                 % Procedure findgray calculates
X    { /i exch def /n exch def               % the gray value for a slice. It
X      i 2 mod 0 eq                          % takes two arguments: the total
X	{ i 2 div n 2 div round add n div } % number of slices and the current
X	{ i 1 add 2 div n div }             % slice number (Given that there
X	ifelse                              % are n pie slices, the slices are
X    } def                                   % ``numbered'' from 1 to n). The
Xend                                         % gray values for the pie slices
X					    % range evenly from white to black
X					    % (i.e. - the values provided to
X					    % setgray range from (n/n, n-1/n,
X					    % ..., 1/n)). Since we don't want
X					    % similar values of gray next to
X					    % each other, findgray
X					    % ``shuffles'' the possible
X					    % combinations of gray.
X								   
X/DrawPieChart                               % DrawPieChart takes seven
X  { PieDict begin                           % arguments: the title of the pie
X      /radius exch def                      % chart, the point size to print
X      /ycenter exch def /xcenter exch def   % the title in, the point size to
X      /PieArray exch def                    % print the labels for each slice
X      /labelps exch def /titleps exch def   % in, a special array (described
X      /title exch def                       % below where DrawPieChart is
X					    % called), the (x,y) center of the
X					    % pie chart and the radius of the
X					    % pie chart.
X							
X      gsave
X	xcenter ycenter translate           % Translate the coordinate system
X					    % origin to center of pie chart.
X	/Helvetica findfont titleps         % Print the title of the pie chart
X	  scalefont setfont                 % in Helvetica.
X	title stringwidth pop 2 div neg     % Center the title below the pie
X					    % chart.
X	  radius neg titleps 3 mul sub
X	  moveto title show
X	/Helvetica findfont labelps         % Print the individual pie slice
X	  scalefont setfont                 % labels in Helvetica
X	/numslices PieArray length def
X	/slicecnt 0 def
X	/curangle 0 def                     % A ``loop'' variable that keeps
X					    % track of the angle of arc to
X					    % begin each pie slice at.
X	PieArray                            % Repeat the following for each
X					    % element in the PieArray.
X	  { /slicearray exch def
X	    slicearray aload pop            % Push the label and percentage
X					    % onto the stack.
X	    /percent exch def
X	    /label exch def
X	    /perangle percent 360 mul def   % Convert the percentage into
X					    % degrees of angle.
X	    /slicecnt slicecnt 1 add def
X	    label curangle
X	      curangle perangle add
X	      numslices slicecnt findgray
X	      DrawSlice
X	    /curangle curangle perangle add % Update the current starting
X					    % angle.
X	      def
X	  } forall
X      grestore
X    end
X  } def
X       
X() 18 9
X  [ [(Blueberry) .12 ]                      % The pie array is an array of
X    [(Cherry) .30 ]                         % arrays. Each array in the pie
X    [(Apple) .26 ]                          % array contains a string denoting
X    [(Boston Cream) .16 ]                   % the label to be printed next to
X    [(Other) .04 ]                          % the pie slice followed by a real
X    [(Vanilla Cream) .12 ]                  % number indicating the percentage
X  ] 306 396 100 DrawPieChart                % of the pie represented by this
X					    % particular slice.
Xshowpage
X
@//E*O*F doc/figs/piechart.ps//
if test 7247 -ne "`wc -c <'doc/figs/piechart.ps'`"; then
    echo shar: error transmitting "'doc/figs/piechart.ps'" '(should have been 7247 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'doc/figs/trianglev.ps'" '(262 characters)'
if test -f 'doc/figs/trianglev.ps' ; then 
  echo shar: will not over-write existing file "'doc/figs/trianglev.ps'"
else
sed 's/^X//' >doc/figs/trianglev.ps <<'@//E*O*F doc/figs/trianglev.ps//'
X%!
X%%BoundingBox: 20 20 160 160
Xnewpath
X50 50 moveto
X150 50 lineto
X100 150 lineto
Xclosepath stroke
X/Times-Roman findfont 10 scalefont setfont
X45 55 moveto (a) show 
X155 55 moveto (b) show 
X95 155 moveto (c) show 
X60 35 moveto 
X(The Triangle ABC) show 
Xshowpage
X
@//E*O*F doc/figs/trianglev.ps//
if test 262 -ne "`wc -c <'doc/figs/trianglev.ps'`"; then
    echo shar: error transmitting "'doc/figs/trianglev.ps'" '(should have been 262 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'doc/figs/zip.ps'" '(239 characters)'
if test -f 'doc/figs/zip.ps' ; then 
  echo shar: will not over-write existing file "'doc/figs/zip.ps'"
else
sed 's/^X//' >doc/figs/zip.ps <<'@//E*O*F doc/figs/zip.ps//'
X%!
X%%BoundingBox: 301.0 392.44 360.02 437.4
X/Times-Italic findfont 30 scalefont setfont
X
X/printZip {
X	0 0 moveto
X	(Zip) show
X} def
X320 400 translate 
X
X.95 -.05 0 {
X	setgray
X	printZip
X	-1 .5 translate 
X} for
X
X1 setgray printZip
X
X
Xshowpage
X
@//E*O*F doc/figs/zip.ps//
if test 239 -ne "`wc -c <'doc/figs/zip.ps'`"; then
    echo shar: error transmitting "'doc/figs/zip.ps'" '(should have been 239 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'man/psfigtex.l'" '(2767 characters)'
if test -f 'man/psfigtex.l' ; then 
  echo shar: will not over-write existing file "'man/psfigtex.l'"
else
sed 's/^X//' >man/psfigtex.l <<'@//E*O*F man/psfigtex.l//'
X.TH PSFIGTEX LOCAL
X.SH NAME
XpsfigTeX \- PostScript figures in TeX
X.SH SYNTAX
X\\input
X.B psfig
X.SH DESCRIPTION
X.I psfigTeX
Xis a package that allows easy inclusion of arbitrary PostScript code
Xinto a TeX document.
XFigures are automatically scaled and translated, and the correct amount
Xof space is reserved so nothing conflicts with other text on the page.
XThe 
X.I dvips
Xpostprocessor must be used to create the final PostScript output.
X.PP
X.SH USAGE
XTo include a postscript file, invoke the psfig macro ``\\psfig{figure=fig.ps}'',
Xwhere ``fig.ps'' is the name of a PostScript file. 
XOptions may be specified in the form ``\\psfig{figure=fig.ps,opt=val,opt=val...}'';
Xrecognized options include height, width, prolog, and postlog. If a 
Xheight but not a width is given or vice-versa, the figure will
Xbe scaled equally in both dimensions; if niether is given, the figure's
X``natural'' size will be used.
X.PP
XFor 
X.I psfig
Xto properly scale and move a figure, it must be able to tell what 
Xit's natural size and position on the page are. This is usually specified by
Xthe bounding box comment in the PostScript file. Unfortunately, some 
Xapplications (including MacDraw) do not provide this information. 
XIf your figure doesn't have a bounding box comment (a line starting with
X%%BoundingBox:), it cannot be used by psfigtex. The bbfig utility can
Xcalculate the bounding box of a file (so can a ruler). See the bbfig(l)
Xmanual page for information on the correct format of the comment. Usually
Xthe bounding box comment is the second line of the file.
X.SH "MACINTOSH FIGURES"
XMacintosh figures require a prolog file to be downloaded containing 
XPostScript procedure definitions. Use the option
X``prolog=/usr/lib/ps/mac.pro'' to achieve this. See the psfigtex paper for
Xmore detailed information, especially if there are many mac figures.
X.SH "DRAFT MODE"
X.PP
XIf a figure is very expensive to print (say a 100K image) it can be set in
Xdraft mode, printing just the name of the file. The macro \\psdraft switches
Xinto draft mode and \\psfull returns to full mode. Use of draft mode is
Xhighly encouraged.
X.SH "BUGS"
X.LP
XThe ``\\psfig{...}'' command must be entirely on one input line, and no
Xextra spaces may appear in the option list.
X.LP
XWhen a ``\\psfig'' command is used alone in a centering enviornment, it must
Xbe preceded by a hard space ``\\\ ''. This may be a LaTeX bug.
X.LP
XOn very large documents, the laserwriter has been known to run out of memory
Xand only print a portion of the document. Use the printer memorysize command
Xto dvips to limit the amount of memory dvips thinks it can use.
X.SH AUTHOR
XTrevor Darrell
X.SH "SEE ALSO"
XTeX(1), dvips(1), LaTeX(1)
X.br
XDVILASER user's manual
X.br
XT. Darrell,
X.ul
XIncorporating PostScript and Macintosh figures in TeX
X.br
X
@//E*O*F man/psfigtex.l//
if test 2767 -ne "`wc -c <'man/psfigtex.l'`"; then
    echo shar: error transmitting "'man/psfigtex.l'" '(should have been 2767 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'man/psfigtex.out'" '(3240 characters)'
if test -f 'man/psfigtex.out' ; then 
  echo shar: will not over-write existing file "'man/psfigtex.out'"
else
sed 's/^X//' >man/psfigtex.out <<'@//E*O*F man/psfigtex.out//'
X
X
X
X                                                  psfigtex(local)
X
X
X
XNAME
X     psfigTeX - PostScript figures in TeX
X
XSYNTAX
X     \input psfig
X
XDESCRIPTION
X     _p_s_f_i_g_T_e_X is a package that allows easy inclusion of arbi-
X     trary PostScript code into a TeX document.  Figures are
X     automatically scaled and translated, and the correct amount
X     of space is reserved so nothing conflicts with other text on
X     the page.  The _d_v_i_p_s postprocessor must be used to create
X     the final PostScript output.
X
XUSAGE
X     To include a postscript file, invoke the psfig macro
X     ``\psfig{figure=fig.ps}'', where ``fig.ps'' is the name of a
X     PostScript file. Options may be specified in the form
X     ``\psfig{figure=fig.ps,opt=val,opt=val...}''; recognized
X     options include height, width, prolog, and postlog. If a
X     height but not a width is given or vice-versa, the figure
X     will be scaled equally in both dimensions; if niether is
X     given, the figure's ``natural'' size will be used.
X
X     For _p_s_f_i_g to properly scale and move a figure, it must be
X     able to tell what it's natural size and position on the page
X     are. This is usually specified by the bounding box comment
X     in the PostScript file. Unfortunately, some applications
X     (including MacDraw) do not provide this information. If your
X     figure doesn't have a bounding box comment (a line starting
X     with %%BoundingBox:), it cannot be used by psfigtex. The
X     bbfig utility can calculate the bounding box of a file (so
X     can a ruler). See the bbfig(l) manual page for information
X     on the correct format of the comment. Usually the bounding
X     box comment is the second line of the file.
X
XMACINTOSH FIGURES
X     Macintosh figures require a prolog file to be downloaded
X     containing PostScript procedure definitions. Use the option
X     ``prolog=/usr/lib/ps/mac.pro'' to achieve this. See the
X     psfigtex paper for more detailed information, especially if
X     there are many mac figures.
X
XDRAFT MODE
X     If a figure is very expensive to print (say a 100K image) it
X     can be set in draft mode, printing just the name of the
X     file. The macro \psdraft switches into draft mode and
X     \psfull returns to full mode. Use of draft mode is highly
X     encouraged.
X
XBUGS
X
X
X
X
X                                                                1
X
X
X
X
X
X
Xpsfigtex(local)
X
X
X
X     The ``\psfig{...}'' command must be entirely on one input
X     line, and no extra spaces may appear in the option list.
X
X     When a ``\psfig'' command is used alone in a centering
X     enviornment, it must be preceded by a hard space ``\ ''.
X     This may be a LaTeX bug.
X
X     On very large documents, the laserwriter has been known to
X     run out of memory and only print a portion of the document.
X     Use the printer memorysize command to dvips to limit the
X     amount of memory dvips thinks it can use.
X
XAUTHOR
X     Trevor Darrell
X
XSEE ALSO
X     TeX(1), dvips(1), LaTeX(1)
X     DVILASER user's manual
X     T. Darrell, _I_n_c_o_r_p_o_r_a_t_i_n_g _P_o_s_t_S_c_r_i_p_t _a_n_d _M_a_c_i_n_t_o_s_h _f_i_g_u_r_e_s
X     _i_n _T_e_X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X2
X
X
X
@//E*O*F man/psfigtex.out//
echo shar: 65 control characters may be missing from "'man/psfigtex.out'"
if test 3240 -ne "`wc -c <'man/psfigtex.out'`"; then
    echo shar: error transmitting "'man/psfigtex.out'" '(should have been 3240 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'src/README'" '(459 characters)'
if test -f 'src/README' ; then 
  echo shar: will not over-write existing file "'src/README'"
else
sed 's/^X//' >src/README <<'@//E*O*F src/README//'
Xpsfig.tex :
X	the tex macros that are the backbone of psfig/tex.
X	they should be included at the beginning of any
X	document that intends to use psfig/tex
X
Xfigtex.pro :
X	the postscript support for psfig.tex. Here at upenn,
X	we have inserted this into the dvips prolog, so it
X	need not be included explicitly. If it is not included
X	in the dvips prolog, it must be included with a 
X	\psfiginit after \input{psfig}, and page-reversing
X	will cause complications.
X
@//E*O*F src/README//
if test 459 -ne "`wc -c <'src/README'`"; then
    echo shar: error transmitting "'src/README'" '(should have been 459 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'src/figtex.pro'" '(1743 characters)'
if test -f 'src/figtex.pro' ; then 
  echo shar: will not over-write existing file "'src/figtex.pro'"
else
sed 's/^X//' >src/figtex.pro <<'@//E*O*F src/figtex.pro//'
X%!
X% All software, documentation, and related files in this distribution of
X% psfig/tex are Copyright (c) 1987 Trevor J. Darrell
X%
X% Permission is granted for use and non-profit distribution of psfig/tex 
X% providing that this notice be clearly maintained, but the right to
X% distribute any portion of psfig/tex for profit or as part of any commercial
X% product is specifically reserved for the author.
X%
X%
X% psfigTeX PostScript Prolog
X% $Header: figtex.pro,v 1.3 87/01/19 00:56:36 trevor Exp $
X%
X/TeXscale { 65536 div } def
X
X/startTexFig {
X% usage :  x y bb-llx bb-lly bb-urx bb-ury startFig
X	/SavedState save def
X	userdict maxlength dict begin
X	currentpoint transform
X	initgraphics
X	itransform moveto
X
X	/ury exch TeXscale def
X	/urx exch TeXscale def
X	/lly exch TeXscale def
X	/llx exch TeXscale def
X	/y exch TeXscale def
X	/x exch TeXscale def
X	
X	currentpoint /cy exch def /cx exch def
X
X	/sx x urx llx sub div def 	% scaling for x
X	/sy y ury lly sub div def	% scaling for y
X
X	sx sy scale			% scale by (sx,sy)
X
X	cx sx div llx sub
X	cy sy div ury sub translate
X	
X	/DefFigCTM matrix currentmatrix def
X	/initmatrix {
X		DefFigCTM setmatrix
X	} def
X	/defaultmatrix {
X		DefFigCTM exch copy
X	} def
X	/exval {
X		load dup
X		dup xcheck exch
X		type /arraytype eq and {
X			aload pop
X		} if
X	} def
X	/initgraphics [
X		/initgraphics exval
X		DefFigCTM /setmatrix exval
X	] cvx def
X
X	/showpage {
X		initgraphics
X	} def
X
X} def
X% Args are llx lly urx ury (in figure coordinates)
X/clipFig {
X	currentpoint 6 2 roll
X	newpath 4 copy
X	4 2 roll moveto
X	6 -1 roll exch lineto
X	exch lineto
X	exch lineto
X	closepath clip
X	moveto
X} def
X% doclip, if called, will always be just after a `startfig'
X/doclip { llx lly urx ury clipFig } def
X/endTexFig {
X	end SavedState restore
X} def
@//E*O*F src/figtex.pro//
if test 1743 -ne "`wc -c <'src/figtex.pro'`"; then
    echo shar: error transmitting "'src/figtex.pro'" '(should have been 1743 characters)'
fi
fi # end of overwriting check
echo shar: "End of archive 2 (of 3)."
cp /dev/null ark2isdone
DONE=true
for I in 1 2 3; do
    if test -! f ark${I}isdone; then
        echo "You still need to run archive ${I}."
        DONE=false
    fi
done
case $DONE in
    true)
        echo "You have run all 3 archives."
        echo 'See the README'
        ;;
esac
##  End of shell archive.
exit 0
