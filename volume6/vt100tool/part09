Subject: v06i068:  VT100TOOL for Sun's (vt100tool), Part09/10
Newsgroups: mod.sources
Approved: rs@mirror.UUCP

Submitted by: linus!ell (Ed Lafferty)
Mod.sources: Volume 6, Issue 68
Archive-name: vt100tool/Part09

[  I generally dislike posting anything other than source code.  In this
   case, however, I'm making an exception because (a) there's no other
   way to do it; and (b) there is apparently a lot of demand for this
   program.  So, I took the object and data files in the fontdir and
   libdir directories and uuencode'd them.  The decode.sh script in the
   toplevel directory will uudecode them and remove the uu.xxx files;
   it lists the files by name, so you can check if you're missing
   something.  This comment will appear at the beginning of each of the
   postings of this program.  --r$  ]


#!/bin/sh
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
# Wrapped by rs@mirror.UUCP on Thu Jul 17 00:22:14 EDT 1986
# Contents:  src/ttyvt100.c src/vt100keys.c MANIFEST
 
echo x - src/ttyvt100.c
sed 's/^XX//' > "src/ttyvt100.c" <<'@//E*O*F src/ttyvt100.c//'
XX#ifndef lint
XXstatic	char sccsid[] = "@(#)ttyvt100.c 1.16 86/06/25 Copyr 1985 MITRE Corp.";
XX#endif

XX/*
XX * Copyright (c) 1985 by MITRE Corporation
XX */

XX#include <stdio.h>
XX#include <pixrect/pixrect_hs.h>
XX#include <sunwindow/window_hs.h>
XX#include <signal.h>
XX#include <ctype.h>

XX#include <sys/ioctl.h>
XX#include <sun/fbio.h>
XX#include <sundev/kbio.h>
XX#include <sundev/kbd.h>

XX#undef DEBUG
XXint debug =  0;			/* to enable any debugging you must */
XXint debug2 = 0;			/* Define DEBUG and set one of the */
XXint debug1 = 0;			/* debug flags                     */
XXint debug4 = 0;
XXint debug3 = 0;
XXint debug5 = 0;
XXint debug6 = 0;
XXint debug7 = 0;
XXint debug8 = 0;
XX#include <sunwindow/cms_grays.h>
XX#include "ttysw_impl.h"
XX#include "ttyvt100.h"
XX#include "charimage.h"
XX#include "charscreen.h"
XX#define vanillaChar(c)	((c >= ' ') && (c <= '~'))
XXchar ansiCharBuf[CHAR_BUF_LEN];
XXextern struct pixwin *csr_pixwin;/* This is the ttysw windowfd */
XXextern struct pixfont *pixfont;		/* This is what csr_init uses ???? */
XXextern int chrwidth;
XXextern int right,top,bottom,left;
XXextern pstring(),bold(),nobold();
XXextern void init_kbd();


XX/* Logical state of window and program switches */
XXint  graf_norm, bold_norm;
XXint curscol = 0;	/* cursor column */
XXint cursrow = 0;	/* cursor row */
XXint state = ALPHA;	/* ALPHA,VT52, ESCBRKT, ESCBRKTQM, etc, */
XXint state1 = 0;			/* holds EATCHARS flag at last column */
XXint vl = 0;			/* accumulate vt52 first arg */
XXint ac = 0;	/* accumulates last arg in ESCBRKT sequences. 0-->1. */
XXint ac0 = 0;			/* ditto, but next to last arg.  0 ==> 1 */
XXint acinit = 0;			/* initial value of ac (with 0 left alone) */
XXint acinit0 = 0;			/*  ditto for first Pn */
XXint acm[10];    		/* array of parameters */
XXint ac_num = 0;			/* number of parms this time */
XXint scroll_top = 0;		/* definition of top of scrolling region */
XXint scroll_bottom = 23;		/* bottom of scrolling region */
XXint fillfunc = 0;		/* 1 -> boldf */
XXint underscore;         	/* 1 -> underscore */
XXint report = 0;			/* 1-7 if host asks for something */

XX/* dimensions of VT100 window */
XXint vtop = 0;			/* top row of vt100 window  */
XXint vbottom = 23;		/* bottom row of vt100 window */
XXint vleft = 0;			/* left column of vt100 window  */
XXint vright = 79;		/* right column of regular vt100 window */
XXint tabArray[MAX_SCREEN_WIDTH]; /* array for setting tabs */

XX/* VT100 mode variables */
XXint origin_mode = 0;		/* 0 == reset (screen upper left corner) */
XX                                /* 1 == set (upper -left within margins) */
XXint newline = 0;		/* also used by ttysw_main */
XXint local = 0;			/* 1 = local, 0 = online */
XXint cursor;			/* 0 -> NOCURSOR, 1 -> UNDERCURSOR, */
XX				/* 2 -> BLOCKCURSOR */
XXint curs_key = 0;		/*  ANSI cursor key mode [ or O*/
XXchar answer_message[31];	/* holds the answerback message */
XXint repeat = 0;			/* not implemented */
XXint interlace = 0;		/* not implemented */
XXint vt52mode = 0;		/* emulate a vt52 display */
XXint appl_key_ansi = 0;		/* ANSI application keypad mode */
XXint wrap = 0;			/* wrap at margin mode */
XXint big_screen = 0;		/* 132 col mode */
XXint smooth_scroll = 0;		/* not implemented */

XXint rev_screen = 0;		/* reverse initial setup BOW or WOB */
XXint alt_keypad_52 = 0;		/* vt52 keypad mode */
XXint half_chrwidth = 5;	/* for 132 col mode */
XXint full_chrwidth = 8;	/* for 80 col mode */
XXint twice_chrwidth = 16;	/* for 40 col modes */
XXint twelve_tenths_chrwidth = 10; /* for 66 col mode */
XXint  g0,g1;		/* to keep character set modes */
XXint  activeCharset = G0;	/* graf or asc */
XXint graph_52 = 0;	/* graphics vt52 mode flag */
XXchar charStr[2] = "c";		/* for writing a single character in vright */
XXchar *charNext;
XXchar *charBufMax;
XXint curscolStart;

XX/* we will keep a font designator for each character  */
XX/* so the repair routine will work. Also, need it for rewrite() */
XX 
XX/*
XX * Interpret a string of characters of length <len>.  Stash and restore
XX * the cursor indicator.
XX *
XX * Note that characters with the high bit set will not be recognized.
XX * This is good, for it reserves them for ASCII-8 X3.64 implementation.
XX * It just means all sources of chars which might come here must mask
XX * parity if necessary.
XX *
XX */
XXansiinit()
XX{
XX	int i;
XX	underscore = 0;
XX	curscol = vleft;
XX	cursrow = vtop;
XX/*	setupfullgraycolormap(); */
XX	for (i = 0; i < MAX_SCREEN_WIDTH; i++) tabArray[i] = 0;
XX	for (i = 0; i < MAX_SCREEN_WIDTH; i = i + 8)  tabArray[i]=1;

XX	g0 = ASC;
XX	g1 = GRAPH;
XX#ifdef DEBUG
XX	if (debug) printf( "to imageinit...\n");
XX#endif DEBUG
XX	imageinit();
XX	init_kbd();
XX	set_font(5);
XX	return(1);
XX}


XX/* compatibility kludge */
XXgfxstring(addr, len)
XX	char *addr;
XX	int len;
XX{
XX	extern struct ttysubwindow *_ttysw;
XX	if(len ==1 && *addr == '\014') /* map a ^L into vt100 clear */
XX	  {
XX	    addr = "\033[2J";
XX	    len = 4;
XX	  }
XX	ttysw_output(_ttysw, addr, len);
XX}

XXttysw_output(ttysw, addr, len0)
XX	struct ttysubwindow *ttysw;
XX	register char *addr;
XX	int len0;
XX{
XX	register char c;
XX	int i;
XX	register int len;
XX	char buffer[30];	/* put string to send back to host here */
XX	char string[30];
XX	removeCursor();
XX	for (len = len0; !ttysw->ttysw_frozen && len > 0; len--) {

XX				/* this is the main loop */
XX	c = *addr++;		/* Fetch next char from string */
XX				/*  and bump pointer */
XX	switch(state){

XX	case ALPHA:

XX		ac = 0;
XX		acinit = 0;
XX		acinit0 = 0;
XX		ac0 = 0;
XX		ac_num = 0;
XX		for (i=0; i<9; i++,acm[i]=0); /* clear parm array */

XX		switch (c) {	/* Do control characters first */
XX           		case '\000' :   break; /* null character */
XX			case '\005' :   answerback();		break;
XX			case CTRL(G):	blinkscreen();		break;
XX			case CTRL(H):	pos(curscol-1,cursrow);
XX#ifdef DEBUG
XX					if(debug)printf("backspace\n");
XX#endif DEBUG
XX					break;
XX			case CTRL(I):	
XX					for (i = curscol+1; i <= vright; i++){
XX					  if (tabArray[i])
XX					    {
XX					      pos(i,cursrow);
XX					      break;
XX					    }
XX					}
XX					if(i >= vright)
XX					  pos(vright, cursrow); 
XX					break;
XX				
XX			case CTRL(J):	/* linefeed */
XX			case CTRL(K):   /* VT interpret as LF */
XX			case CTRL(L):   /* FF   "        " "  */ 
XX					Index();
XX					break;

XX			case CTRL(M):	
XX					if(newline)
XX					  {
XX					    pos( 0,cursrow);
XX					    Index();
XX					  }
XX					else pos( 0, cursrow);
XX					break;
XX			case CTRL(N):   G1_select();
XX					break;
XX			case CTRL(O):   G0_select();
XX					break;
XX			case '\033':	state = ESCAPE;
XX					break;

XX		        			
XX			default:   /* c is likely a real alpha character */
XX					if (c < 32) break; /* guess not! */
XX					if(curscol > vright) /* means we have written into last column */
XX					  {
XX					    switch (wrap)
XX					      {
XX					      case 1:
XX						curscol = 0;
XX						pos(curscol,cursrow);
XX						Index();
XX						break;
XX					      case 0:                   /* eat the character */
XX						charStr[0] = c;
XX						writePartialLine(charStr,vright);
XX						reflections[cursrow][vright] =  marks[cursrow] + (fillfunc<<8);
XX						goto loopback;
XX					      }
XX					  }
XX					    
XX					    /* and now handle the normal case "curscol not vright" */
XX					curscolStart = curscol;	/* initialize for loop */
XX					charNext = &ansiCharBuf[0];
XX					*charNext = c; /* put character into output stream */
XX					charNext++;	   /* and bump stream pointer */
XX					marks[cursrow] |= BUSY;
XX					reflections[cursrow][curscol] =  marks[cursrow] + (fillfunc<<8);
XX					curscol++;   /* and bump column  */
XX					*charNext = '\0';
XX					writePartialLine(&ansiCharBuf[0], curscolStart); /* and write to screen  */
XX					break;		      
XX				      }
XX		break;

XX	case ESCAPELPRN:
XX		switch (c){
XX		case 'A': g0 = UK;
XX			  grafon();
XX			  if(activeCharset == G0) set_font(5);
XX			  break;
XX			  
XX		case '1':
XX		case '2':

XX		case 'B': g0 = ASC;
XX			  grafon();
XX			  if(activeCharset == G0) set_font(5);
XX			  break;
XX		case '0': g0 = GRAPH;
XX			  grafon();
XX			  if(activeCharset == G0) set_font(5);
XX			  break;
XX		default:  break;
XX			}
XX		state = ALPHA;
XX		break;
XX       case ESCAPERPRN:
XX		switch (c){
XX		case 'A': g1 = UK;
XX			  grafon();
XX			  if(activeCharset == G1) set_font(5);
XX			  break;
XX		case '1':
XX		case '2':
XX		case 'B': g1 = ASC;
XX			  grafon();
XX			  if(activeCharset == G1) set_font(5);
XX			  break;
XX		case '0': g1 = GRAPH;
XX			  grafon();
XX			  if(activeCharset == G1) set_font(5);
XX			  break;
XX		default:  break;
XX			}
XX		state = ALPHA;
XX		break;
XX        case ESCAPESHARP:
XX		switch (c){
XX		case '8': Escreen();
XX			  break;
XX		case '3': mark_top(cursrow);
XX			  break;
XX			  
XX		case '4': mark_bottom(cursrow);
XX			  break;
XX		case '5': clear_width(cursrow);
XX			  break;
XX		case '6': mark_wide(cursrow);
XX			  break;
XX		default:  break;
XX			}
XX		state = ALPHA;
XX		break;
XX				    

XX	case ESCBRKT:		/* esc[   accumulate parms */
XX	case ESCBRKTQM:		/* same logic for esc[? */
XX		if ('0' <= c && c <= '9') {
XX		   ac = ((char)ac)*10 + c - '0'; /* char for inline muls */
XX		   break;
XX		} else if (c == ';') {
XX			
XX			acm[ac_num] = ac;
XX			ac_num++;
XX			ac0 = ac; ac = 0;	/* for compat up */
XX			break;
XX		} else {
XX		  if(c != '?'){
XX		    acinit = ac;		/* got a alpha */
XX		    acinit0 = ac0;              /* default both Pns */
XX		    acm[ac_num] = ac;
XX		    ac_num++;
XX		    if(ac0 == 0 && ac != 0 && ac_num == 1)
XX		      {
XX			ac0 = ac; /* if only one then it isthe first */
XX			ac = 0;
XX		      }
XX		    if(ac0 == 0) ac0 = 1; /* default is 1 not 0 */
XX		    if(ac ==0) ac = 1;
XX#ifdef DEBUG
XX	if(debug) printf("acs %d %d %d %d\n",acinit,ac0,ac,ac_num);
XX#endif DEBUG
XX		  }
XX   if (state == ESCBRKT){
XX#ifdef DEBUG
XX   		if(debug) printf("in CSI %c sequence\n",c);
XX#endif DEBUG
XX	    switch ( c ) {
XX			case 'A':	pos(curscol,cursrow-ac0); 	break;
XX			case 'B':	pos(curscol,cursrow+ac0); 	break;
XX			case 'C':	pos(curscol+ac0,cursrow); 	break;
XX			case 'D':	pos(curscol-ac0,cursrow); 	break;
XX			case 'f':
XX			case 'H':	abs_pos(ac-1,ac0-1);
XX					break;
XX			case 'J':
XX			 switch(acinit){
XX			 	case 0:	cleol(cursrow);
XX					del_lines(cursrow+1,vbottom);
XX					clearMarks(cursrow+1,vbottom);
XX					set_font(5);
XX					break;
XX				case 1: del_char(vleft,curscol, cursrow);
XX					del_lines(vtop,cursrow-1);
XX					clearMarks(vtop,cursrow-1);
XX					set_font(5);
XX					break;
XX				case 2:
XX 				        del_lines(vtop,vbottom);
XX					clearMarks(vtop,vbottom);
XX					set_font(5);
XX					break;
XX				}
XX				break;
XX			case 'K':
XX			     switch(acinit){
XX			     	case 0:
XX				   cleol(cursrow);
XX				   break;
XX				case 1:
XX				   del_char( vleft, curscol,cursrow);
XX				   break;
XX				case 2:
XX				   del_char(vleft,curscol,cursrow);
XX				   cleol(cursrow);
XX				   break;
XX			       }
XX					break;
XX		      case '?': state = ESCBRKTQM;
XX					break;
XX/* for now just bold and nobold */
XX		      case 'm': /* attributes on/off */
XX				if(ac_num == 0)
XX				  {
XX				    acm[0] = acinit;
XX				    ac_num++;
XX				  }
XX				for( i = 0; i < ac_num; i++)
XX				  {
XX				    switch(acm[i]){
XX				    case 0:   All_off();
XX					      break;
XX				    case 1:   Bold_on();
XX					      break;
XX				    case 4:   Under_on();
XX					      break;
XX				    case 5:   Blink_on();
XX					      break;
XX				    case 7:   Reverse_on();
XX					      break;
XX					    }
XX				  }
XX#ifdef DEBUG				
XXif(debug4) printf("attributes %d %d %d %d %d\n", acm[0],acm[1],acm[2],acm[3],acm[4]);					
XX#endif DEBUG
XX				break;
XX/* reports coming up */						
XX			case 'c':	/*report what are you? */
XX					ttysw_input(_ttysw,"\033[?1;0c",7);
XX					break;
XX/* tabs  clear */
XX			case 'g':	if(acinit == 0 ) {
XX					  tabArray[curscol] = 0;
XX					  break;}
XX					if(acinit == 3){
XX                                        for(i = 0; i<= MAX_SCREEN_WIDTH-1;i++)
XX					    tabArray[i] = 0;}
XX					  break;
XX/* line feed mode set */
XX			case 'h':	if(acinit == 20) newline = 1;
XX									break;
XX/* line feed node reset */
XX			case 'l':	if(acinit == 20) newline = 0;
XX									break;
XX/* status requests from host */
XX                        case 'n':	if(acinit == 5)
XX			                 ttysw_input(_ttysw,"\033[0n",4);
XX				
XX                                	if(acinit == 6)
XX					  {
XX			    sprintf(string,"\033[%u;%uR",cursrow+1,curscol+1);
XX			    ttysw_input(_ttysw,string,strlen(string));
XX			  }
XX									break;
XX/* define scroll region for indexing */
XX			case 'r':	set_scroll_region(); break;
XX/* report terminal parameters */
XX			case 'x':	if(acinit == 0)
XX			  ttysw_input(_ttysw,"\033[2;1;1;112;112;1;0x",20);
XX					if(acinit == 1)
XX			  ttysw_input(_ttysw,"\033[3;1;1;112;112;1;0x", 20);		  
XX					break;
XX			case 'q':	/* led business - ignore */	break;

XX			}	/* end of ESCBRKT switch */
XX              if(state == ESCBRKT)  state = ALPHA;
XX		ac = 0;
XX		ac0 = 0;
XX		acinit = 0;
XX		acinit0 = 0;
XX		break;
XX		}		/* not  ESCBRKT must be [? */
XX	       	
XXif(state == ESCBRKTQM){		/* must be esc[? */
XX#ifdef DEBUG
XX			if(debug)printf("esc-[? %c\n",c);
XX#endif DEBUG
XX		switch (c){
XX		    case 'h':
XX			switch(acinit){
XX			    case 1:	curs_key = 1; break;
XX			    case 3:	big_screen = 1;
XX					vright = 131;
XX					del_lines(vtop,vbottom);
XX					clearMarks(vtop,vbottom);
XX					ac_num = 0;
XX					scroll_top = vtop;
XX					scroll_bottom = vbottom;
XX					pos(0,0);
XX					set_font(5);
XX					break;
XX			    case 4:	smooth_scroll=1;
XX					break;
XX					
XX			    case 5:	if(rev_screen==0){
XX			                rev_screen = 1;
XX					pblack_background();
XX				      }
XX					break;
XX			    case 6:	origin_mode=1;	
XX			    		pos(vleft,scroll_top);
XX					break;
XX			    case 7:	wrap = 1;	break;
XX			    case 8:	repeat = 1;	break;
XX			    case 9:	interlace=1;	break;
XX			    default: break;
XX			    }
XX			state = ALPHA;
XX			    break;
XX		    case 'l':
XX		        switch(acinit){
XX			    case 1:	curs_key = 0;	break;
XX                            case 2:     vt52mode = 1;
XX					wrap = 1;
XX					scroll_top = vtop;
XX					scroll_bottom = vbottom;
XX					break;
XX			    case 3:	big_screen=0;
XX					vright = 79;
XX					clearMarks(vtop,vbottom);
XX					del_lines(vtop,vbottom);
XX					ac_num = 0;
XX					scroll_top = vtop;
XX					scroll_bottom = vbottom;
XX					pos(0,0);
XX					set_font(5);
XX					break;
XX			    case 4:	smooth_scroll=0;
XX					break;
XX			    case 5:	if(rev_screen==1){
XX			                 rev_screen = 0;
XX				 	pwhite_background();
XX				       }
XX					break;
XX			    case 6:	origin_mode=0;	
XX			    		pos(vleft,vtop);
XX					break;
XX			    case 7:	wrap = 0;	break;
XX			    case 8:	repeat = 0;	break;
XX			    case 9:	interlace = 0;	break;
XX			    default:	break;
XX				      }
XX			state = ALPHA;
XX			break;
XX	            default: 	/* esc[? something unknown? */		    
XX			state = ALPHA;
XX			    break;
XX		    }		/* end of esc[? switch */
XX			state = ALPHA;
XX	    }			/* end of esc[? conditional */
XX      }				/* ends esc[ and esc[? section */
XX		ac = 0;
XX		ac0 = 0;
XX		acinit = 0;
XX		acinit0 = 0;

XX	    state = ALPHA;	/* following the ansi sequence, return to */
XX		break;		/* out of state switch */


XX	      case ESC52Y:	/* gather next 2 chars */
XX		if(vl) {
XX		  pos( c - '\040',vl - '\040');
XX#ifdef DEBUG
XX		  if(debug1)printf("vt52 position %d %d\n",vl-'\40',c-'\40');
XX#endif DEBUG
XX		  vl = 0;
XX		  state = ALPHA;
XX		  break;
XX		}
XX		else {
XX		  vl = c;
XX		  break;
XX		}
XX		break;

XX	      case ESCAPE:	
XX#ifdef DEBUG
XX			if(debug)printf("escape-%c\n",c);
XX#endif DEBUG
XX		if(vt52mode) {
XX		             scroll_top = vtop;
XX			     scroll_bottom = vbottom;
XX		  switch (c) {
XX		  case 'A':  pos(curscol,--cursrow); break;
XX                  case 'B':  pos(curscol,++cursrow); break;
XX		  case 'C':  pos(++curscol,cursrow); break;
XX		  case 'D':  pos(--curscol,cursrow); break;
XX                  case 'F':  graph_52 = 1;           break;
XX		  case 'G':  graph_52 = 0;           break;
XX		  case 'H':  pos(0,0);               break;
XX		  case 'I':  Rindex();               break;
XX                  case 'J':  cleol(cursrow);
XX			     del_lines(cursrow+1,vbottom);
XX			     break;
XX                  case 'K':  cleol(cursrow);
XX			     break;
XX		  case 'Y':  state = ESC52Y;
XX			     vl = 0;
XX			     break;
XX                  case 'Z':  ttysw_input(_ttysw,"\033/Z",3);
XX			     break;
XX                  case '<':  vt52mode = 0;
XX			     break;
XX                  case '>':  alt_keypad_52 = 0;
XX			     break;
XX                  case '=':  alt_keypad_52 = 1;
XX  			     break;
XX                  case '1':  graph_52 = 1;
XX			     break;
XX                  case '2':  graph_52 = 0;
XX			     break;
XX			   }
XX		  if (state == ESCAPE) state = ALPHA;
XX		  break;
XX		}
XX		else

XX		switch (c) { 
XX			/* detect esc left bracket */
XX			case '[':	
XX					state = ESCBRKT;
XX					break;

XX			case 'D':       Index();		break;
XX			case 'E':	pos(0,cursrow);
XX					Index();
XX								break;
XX			case 'H':	tabArray[curscol] = 1;
XX#ifdef DEBUG
XX				if(debug)printf("tab set at %d\n",curscol);
XX#endif DEBUG
XX								break;
XX			case 'M':	Rindex();		break;
XX			case 'Z':       ttysw_input(_ttysw,"\033[?1;0c",7);
XX					break;
XX			case '7':	Save_cursor();		break;
XX			case '8':	Restore_cursor();	break;
XX			case '(': 	/* G0 char set designator */
XX				state = ESCAPELPRN;
XX				    break;

XX			case ')':  /* G1 char set designator */
XX				    state = ESCAPERPRN;	
XX				    break;
XX				    
XX			case '#':  /*  large char controls */
XX			         state = ESCAPESHARP;
XX					break;

XX			case '1':	/* set graphics option */
XX					break;
XX					
XX			
XX			case '2':	/* graphics off */
XX					break;
XX					
XX			case '=':	appl_key_ansi = 1;
XX					break;
XX					
XX			case '>':	appl_key_ansi = 0;
XX					break;
XX					
XX			case 'c':	/* reset power up */
XX					reset();
XX					break;
XX					
XX					

XX	/* By default, ignore the character after the ESC */
XX			default:	state = ALPHA;
XX					break;
XX		}		/* end plain escape sequence */
XX		ac = 0;
XX		ac0 = 0;
XX		acinit = 0;
XX		acinit0 = 0;
XX		if(state == ESCAPE) state = ALPHA;
XX		break;
XX		  
XX	      default:		/* for state switch */
XX				/* don't think we ever get here */
XX			state = ALPHA;
XX			cursor = BLOCKCURSOR;
XX			break;
XX	      }			/* end of state switch */
XX      loopback: continue;

XX      }				/* end of while loop */
XX	    			/* get next character from input */
XX/* Finished all input. If we have been asked for a  report return */
XX/* appropriate message as function value (hope not much has followed) */
XX/* EndOuterLoop: */
XX	drawCursor( cursrow, curscol );
XX	return(len0);

XX}


XXpos(col, row)
XX	int col, row;
XX{
XX  int orow;
XX	if (col <= vleft)
XX		col = vleft;
XX	if (col >= vright)
XX		col = vright;
XX			/* mimic vt100 scrolling region anomaly */
XX	if (row <= scroll_top && cursrow >=  scroll_top)
XX		row = scroll_top;
XX	if (row >=scroll_bottom && cursrow <=  scroll_bottom)
XX		row = scroll_bottom;
XX	orow = cursrow;
XX#ifdef DEBUG
XX  if(row < 0) trap();
XX  if(debug7) if (col == 0) printf("POS %d: %s\n",row, image[row]);
XX#endif
XX  if(row < 0)row = 0;

XX	cursrow = row;
XX	curscol = col;
XX	vpos(row, col); 	/* assume 0,0 upper left for SunW */
XX	check_marks(row,orow);
XX}




XXset_scroll_region()
XX{
XX#ifdef DEBUG
XXif(debug3) printf("entering set_scroll_region %d %d %d\n", acinit, ac, ac0);
XX#endif DEBUG
XXif (ac_num == 0 || ac_num == 1 ||(ac_num == 2 && ac == ac0 && ac == 1)) {
XX  
XX/* default :: reset to whole screen */
XX	scroll_top = vtop;
XX	scroll_bottom = vbottom;
XX	pos(0,0);
XX	return; 
XX	 }
XXelse				/* set scroll region from pars */
XXif(ac > ac0) {
XX	scroll_top = ac0-1;	/* scroll region start */
XX	scroll_bottom = ac-1;	/*  "       "    end */
XX	pos( 0,origin_mode?scroll_top:0);
XX	}
XX#ifdef DEBUG
XXif (debug3) printf("scroll region %d  %d", scroll_top, scroll_bottom);
XX#endif DEBUG
XX}

XXIndex()
XX{

XX/* if not at bottom of region, then just move down one line */
XX#ifdef DEBUG
XX    if(debug)printf("Index called %d %d\n",curscol,cursrow);
XX#endif DEBUG
XX    if (cursrow != scroll_bottom) {
XX    	pos(curscol,cursrow+1);
XX	return;
XX	}
XX    if (cursrow == scroll_bottom) {
XX      scroll_up();
XX      shiftMarksUp();
XX      check_marks(cursrow,cursrow-1);
XX    }
XX}

XXRindex()
XX{
XX#ifdef DEBUG
XX    if(debug)printf("Rindex called %d %d\n",curscol,cursrow);
XX#endif DEBUG
XX/* if not at top of scroll region, then just move up a line */
XX    if (cursrow !=  scroll_top) {
XX    	pos(curscol,cursrow-1);
XX	return;
XX	}
XX    if (cursrow == scroll_top) {
XX      scroll_down();
XX      shiftMarksDown();
XX      check_marks(cursrow,cursrow+1);
XX    }

XX}

XX/* Scroll up one line at the cursor position -- happens on LF at
XXbottom of the screen or when ESC-E or D commands step at bottom 
XXmargin -- also linefeed at bottom margin if margins set */
XXscroll_up()
XX{
XX  int otop = top;
XX  int obottom = bottom;
XX  top = scroll_top;
XX  bottom = scroll_bottom;
XX  scroll1up(top,bottom);
XX  top = otop;
XX  bottom = obottom;

XX}

XXscroll_down()			/* Same as up except that we have to  */
XX{				/* get rid of lines off bottom of screen */
XX  int otop = top;
XX  int obottom = bottom;
XX  top = scroll_top;
XX  bottom = scroll_bottom;
XX  scroll1dn(top, bottom);
XX  top = otop;
XX  bottom = obottom;

XX}

XXint ocursrow, ocurscol, obold, ocharset,og0,og1;
XX    
XXSave_cursor()
XX{
XX    ocursrow = cursrow;
XX    ocurscol = curscol;
XX    obold = fillfunc;
XX    ocharset = activeCharset;
XX    og0 = g0;
XX    og1 = g1;
XX    
XX}

XXRestore_cursor()
XX{
XX    cursrow = ocursrow;
XX    curscol = ocurscol;
XX    fillfunc = obold;
XX    if(fillfunc & BOLD) Bold_on();
XX    if(fillfunc & UNDER) Under_on();
XX    if(fillfunc & REVERSE)  Reverse_on();
XX    activeCharset = ocharset;
XX    grafon();
XX    g0 = og0;
XX    g1 = og1;
XX    set_font(5);
XX    
XX}

XXchar * estring = "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE";


XXEscreen()
XX{
XX    int i = 0;
XX    newline = 0;
XX    origin_mode = 0;
XX    wrap = 1;
XX    curscol = 0;
XX    cursrow = 0;
XX    scroll_top = 0;
XX    scroll_bottom = 23;
XX    del_lines(vtop,vbottom);
XX    clearMarks(vtop,vbottom);
XX    estring[vright+1] = '\0';
XX    while (i <= vbottom){
XX          pos(0,i);
XX	  writePartialLine(estring,0);
XX	  i++;
XX      }
XX    estring[vright+1] = 'E';
XX    pos(0,0);
XX  }
XX  


XXanswerback()
XX{
XX  ttysw_input(_ttysw,answer_message,strlen(answer_message));
XX}


XXreset()
XX{
XX  newline = 0;
XX  wrap = 1;
XX  origin_mode = 0;
XX  big_screen = 0;
XX  curscol = 0;
XX  cursrow = 0;
XX  fillfunc = 0;
XX  scroll_top = 0;
XX  scroll_bottom = 23;
XX  del_lines(vtop,vbottom);
XX  clearMarks(vtop,vbottom);
XX  vt52mode = 0;
XX  set_font(5);
XX  pos(curscol,cursrow);
XX}
XXchar* blanks = "                                                                                                                                       ";
XXdel_lines(from,to)
XXint from,to;
XX{
XX  int i, inverse;
XX  int savec = curscol;
XX  int savel = cursrow;
XX#ifdef DEBUG
XX  if(debug) printf("deleting from %d to %d\n",from, to);
XX#endif DEBUG
XX  inverse = fillfunc & REVERSE;
XX  nobold();
XX  blanks[vright+1] = '\0';
XX  for(i= from; i<=to; i++)
XX    {
XX     pos(0,i);
XX/*     writePartialLine(blanks,0); */
XX     vsetlinelength(image[i],0);
XX   }
XX  pclearscreen(from, to+1);
XX  blanks[vright +1] = ' ';
XX  if(inverse) bold();
XX  pos(savec,savel);
XX}

XXchar buf[MAX_SCREEN_WIDTH];	    


XX/* Writes blanks into line and keeps cursor at original position */

XXdel_char(from,to,row)
XXint from,to,row;
XX{
XX  int savec,savel,inverse;
XX  register i = to - from +1;
XX  savec = curscol;
XX  savel = cursrow;
XX  nobold();
XX  cursrow = row;
XX  blanks[i] = '\0';
XX  writePartialLine(blanks, from);
XX  blanks[i] = ' ';
XX  if(fillfunc & REVERSE) bold(); /* restore reverse if set */
XX  pos(savec,savel);		
XX}

XXcleol(row)
XXint row;
XX{
XX  int i;
XX  del_char(curscol, vright, row);
XX  vsetlinelength(image[row],curscol);

XX}


XX      

XX/*special routine for vt100 abs cursor position  */

XXabs_pos(col,row)
XXint row, col;
XX{
XX  int srow;
XX  int orow;
XX  orow = cursrow;
XX  if (origin_mode){
XX    srow = row + scroll_top;
XX    if(srow > scroll_bottom) srow = scroll_bottom;
XX  }
XX  else srow = row;
XX  curscol = col;
XX  cursrow = srow;

XX#ifdef DEBUG
XX  if(cursrow < 0 ) trap();
XX  if(debug)printf("moving to col %d, row %d \n",col,srow);
XX#endif DEBUG
XX  vpos(srow,col);
XX  check_marks(cursrow,orow);
XX}

XXtrap(){}
XX  
XXpwhite_background()
XX{
XX/*  pw_blackonwhite(csr_pixwin, 0,1); */
XX  pw_writebackground(csr_pixwin, 0 , 0,
XX		     winwidthp, winheightp, PIX_NOT(PIX_DST)); 


XX      }

XXpblack_background()
XX{
XX/*  pw_whiteonblack(csr_pixwin,0,1); */
XX  pw_writebackground(csr_pixwin, 0, 0,
XX		     winwidthp, winheightp, PIX_NOT(PIX_DST));
XX}

XXmark_top(row)			/* top of double height row */
XXint row;
XX{
XX  int i;
XX  marks[row] &= ~ BOTTOM_F;
XX  marks[row] |= TOP_F|WIDE_F;
XX  for (i = 0; i <= 131; i++){
XX    reflections[row][i] &= ~ BOTTOM_F;
XX    reflections[row][i] |= TOP_F|WIDE_F ;
XX  }
XX  if(length(image[row]) > big_screen ? 66 : 40)
XX    vsetlinelength(image[row],big_screen ? 66 : 40);
XX  rewrite(row);
XX}


XXmark_bottom(row)		/* bottom of double height row */
XXint row;
XX{
XX  int i;
XX  marks[row] &= ~ TOP_F;
XX  marks[row] |= BOTTOM_F|WIDE_F;
XX  for (i = 0; i <= 131; i++)
XX    {
XX      reflections[row][i] &= ~TOP_F;
XX      reflections[row][i] |= BOTTOM_F|WIDE_F;
XX    }
XX  if(length(image[row]) > big_screen ? 66 : 40)
XX    vsetlinelength(image[row],big_screen ? 66 : 40);
XX  rewrite(row);
XX}


XXclear_width(row)		/* set row to non-widte ype */
XXint row;
XX{
XX  int i;
XX  marks[row] &= ~(WIDE_F|TOP_F|BOTTOM_F);
XX  for (i = 0; i <= 131; i++)
XX    {
XX      reflections[row][i] &= ~(WIDE_F|TOP_F|BOTTOM_F);
XX    }
XX  
XX  rewrite(row);		
XX}


XXmark_wide(row)		/* double width -single height row */
XXint row;
XX{
XX  int i;
XX  marks[row] &= ~(BOTTOM_F|TOP_F);
XX  marks[row] |= WIDE_F;
XX  for (i = 0; i <= 131; i++)
XX    {
XX      reflections[row][i] &= ~(BOTTOM_F|TOP_F);
XX      reflections[row][i] |= WIDE_F;
XX    }
XX  if(length(image[row]) > big_screen ? 66 : 40)
XX    vsetlinelength(image[row],big_screen ? 66 : 40);
XX  rewrite(row);
XX}


XXG0_select()
XX{
XX#ifdef DEBUG
XX  if(debug4) printf("selecting G0 font which is %d\n",G0);
XX#endif
XX  activeCharset = G0;
XX  set_font(5);
XX  return;
XX}

XXG1_select()
XX{
XX#ifdef DEBUG
XX  if(debug4) printf("selecting G1 font which is %d\n", G1);
XX#endif
XX  activeCharset = G1;
XX  set_font(5);
XX  return;
XX}









XXshiftMarksUp()			/* LF or Index has dropped top line */
XX{
XX  int i,j;			
XX  for(i = scroll_top; i < scroll_bottom; i++)
XX    {
XX      marks[i] = marks[i+1];
XX      for (j = 0; j < 132; j++) reflections[i][j] = reflections[i+1][j];
XX    }
XX  marks[scroll_bottom] = big_screen ? NARROW_F : NORMAL_F;/* New line is 80 or 132 cols */
XX  for (j = 0 ; j < 132; j++) reflections[scroll_bottom][j] = marks[scroll_bottom];
XX}
XX	
XXshiftMarksDown()	/* scroll down has removed bottom line */
XX{	
XX  int i,j;
XX  for ( i = scroll_bottom; i > scroll_top; i--)
XX    {
XX      marks[i] = marks[i-1];
XX      for ( j = 0; j < 132; j++) reflections[i][j] = reflections[i-1][j];
XX    }
XX  marks[scroll_top] = big_screen ? NARROW_F : NORMAL_F;
XX  for(j = 0; j < 132; j++) reflections[scroll_top][j] = marks[scroll_top];
XX}

XXclearMarks(from,to)
XXint from,to;
XX{
XX  int i,j;
XX  for(i = from; i <= to ; i++)
XX    {
XX      marks[i] =big_screen ? NARROW_F : NORMAL_F;
XX      for (j = 0; j< 132; j++) reflections[i][j] = marks[i];
XX    }

XX}

XX  
XXAll_off()			/* turn off all attributes */
XX{
XX#ifdef DEBUG
XX  if(debug4) printf("All_off entered\n");
XX#endif
XX  fillfunc = 0;
XX  underscore = 0;
XX  nobold();
XX  set_font(5);
XX}

XXBold_on()
XX{
XX#ifdef DEBUG
XX  if(debug4) printf("Bold_on entered\n");
XX#endif
XX  fillfunc |= BOLD;  
XX  set_font(5);

XX}

XXReverse_on()
XX{
XX#ifdef DEBUG
XX  if(debug4) printf("Reverse_on entered\n");
XX#endif
XX  fillfunc |= REVERSE;
XX  bold();
XX}
XXBlink_on()			/* can't figure out how to do this */
XX{
XX  fillfunc |= BLINK;
XX}

XXUnder_on()
XX{
XX  underscore = 1;
XX  fillfunc |= UNDER;
XX}


XXscroll1up(tp,bm)
XXint tp,bm;
XX{
XX  int i;
XX  char *line;
XX  swapregions ( tp , tp + 1, bm - tp);
XX  line = image[bm];
XX  for(i = 0; i <= right; i++) line[i] = ' ';
XX  vsetlinelength(image[bm],0);
XX/*  pcopyscreen(tp+1,tp,bm-tp);  */
XX  pw_copy(csr_pixwin, col_to_x(vleft), row_to_y(tp), winwidthp,
XX	  row_to_y(bm -tp), PIX_SRC,
XX	  csr_pixwin, col_to_x(vleft), row_to_y(tp + 1));
XX  pclearline(left,right, bm);
XX  
XX}
XXscroll1dn(tp,bm)
XXint tp,bm;
XX{
XX  int i,k;
XX  char *line;
XX  swapnregions(bm, bm - 1,bm - tp);
XX  line = image[tp];
XX  for(i = 0; i <= right; i++) line[i] = ' ';
XX  vsetlinelength(image[tp],0);
XX/*  pcopyscreen(tp, tp+1, bm-tp);*/
XX  pw_copy(csr_pixwin, col_to_x(vleft), row_to_y(tp+1), winwidthp,
XX	  row_to_y(bm -tp), PIX_SRC,
XX	  csr_pixwin, col_to_x(vleft), row_to_y(tp));
XX  
XX  pclearline(left,right,tp);
XX}



XXswapnregions(a, b, n)		/* move block down */
XX	int a, b, n;
XX{
XX	while (n--)
XX		swap(a--, b--);
XX}

XXint
XXsetupfullgraycolormap()

XX{


XX	register u_char	red[CMS_GRAYSSIZE], green[CMS_GRAYSSIZE],
XX	    blue[CMS_GRAYSSIZE]; 
XX	register i;

XX	/*
XX	 * Initialize to gray cms.
XX	 */
XX/*	pw_setcmsname(csr_pixwin, CMS_GRAYS); */
XX	cms_grayssetup(red,green,blue);
XX	pw_putcolormap(csr_pixwin, 0, CMS_GRAYSSIZE, red, green, blue);
XX	return(CMS_GRAYSSIZE);
XX}


@//E*O*F src/ttyvt100.c//
chmod u=r,g=r,o=r src/ttyvt100.c
 
echo x - src/vt100keys.c
sed 's/^XX//' > "src/vt100keys.c" <<'@//E*O*F src/vt100keys.c//'
XX#ifndef lint
XXstatic	char sccsid[] = "@(#)vt100keys.c 1.6 86/04/11 Copyr 1985 MITRE Corp";
XX#endif

XX/*
XX * Copyright (c) 1985 by MITRE Corporation
XX */

XX#include <stdio.h>
XX#include <pixrect/pixrect_hs.h>
XX#include <sunwindow/window_hs.h>
XX#include <signal.h>
XX#include <ctype.h>

XX#include <sys/ioctl.h>
XX#include <sun/fbio.h>
XX#include <sundev/kbio.h>
XX#include <sundev/kbd.h>
XX#include "ttyvt100.h"
XX#include "charimage.h"
XX#include "charscreen.h"
XXextern int vt52mode, curs_key,alt_keypad_52,appl_key_ansi;
XX/* This routine takes function keys and converts to vt100 key-strings */
XX/* These depend on the mode settings: */
XX/* CURSOR KEYS: */
XX/* vt52_mode */
XX/* ANSI mode && curs_key mode */
XX/* ANSI mode && not curs_key mode */
XX/* AUXILIARY KEYPAD: */
XX/* vt52mode && numeric */
XX/* vt52mode && application */
XX/* ANSI && numeric */
XX/* ANSI && application */
XX/********************************* */
XXextern int newline;

XXchar *
XXtranslate_key(code)
XXint code;
XX{
XX  int flag = 0;
XX  int flagc = 0;
XX  /*  Now set up from mode flags: */
XX  flagc = vt52mode;		/* that's a 1 0r 0 */

XX#ifdef DEBUG
XXif(debug2)printf("entered translate with %d\n",code);
XX#endif DEBUG

XX  if(!vt52mode)  flagc = 2 + curs_key; /* makes it 2 or 3 */
XX  if(vt52mode && alt_keypad_52) flag = APPL5;
XX  if(vt52mode && !alt_keypad_52)flag = NUMER5;
XX  if(!vt52mode && appl_key_ansi) flag = APPLA;
XX  if(!vt52mode && !appl_key_ansi) flag = NUMERA;
XX  switch(code){
XX    /* Left panel except L1 which */
XX    /* is the hardware abort control (when combined with "a")*/
XX  case   KEY_LEFT(2):       
XX  case   KEY_LEFT(3):       
XX  case   KEY_LEFT(4):       
XX  case   KEY_LEFT(5):       
XX  case   KEY_LEFT(6):       
XX  case   KEY_LEFT(7): 
XX  case   KEY_LEFT(8):
XX  case   KEY_LEFT(9):
XX  case   KEY_LEFT(10): return("");

XX    /* right panel but not the cursor keys yet */
XX    /* we will use all 15 as keypad PF1--15*/

XX  case   KEY_RIGHT(1): /* PF1 */
XX		  switch(flag){
XX		  case NUMER5: return("\033P");
XX		  case NUMERA: return("\033OP");
XX		  case APPL5:  return("\033P");
XX		  case APPLA:  return("\033OP");
XX		  default:  break;
XX			  }
XX		  return("");
XX  case   KEY_RIGHT(2): /* PF2 */
XX		  switch(flag){
XX		  case NUMER5: return("\033Q");
XX		  case NUMERA: return("\033OQ");
XX		  case APPL5:  return("\033Q");
XX		  case APPLA:  return("\033OQ");
XX		  default:  break;
XX			  }
XX		  return("");
XX  case   KEY_RIGHT(3): /* PF3 */
XX		  switch(flag){
XX		  case NUMER5: return("\033R");
XX		  case NUMERA: return("\033OR");
XX		  case APPL5:  return("\033R");
XX		  case APPLA:  return("\033OR");
XX		  default:  break;
XX			  }
XX		  return("");
XX  case   KEY_RIGHT(4): /*  7  */
XX		  switch(flag){
XX		  case NUMER5: return("7");
XX		  case NUMERA: return("7");
XX		  case APPL5:  return("\033?w");
XX		  case APPLA:  return("\033Ow");
XX		  default:  break;
XX			  }
XX		  return("");
XX  case   KEY_RIGHT(5): /*  8  */
XX		  switch(flag){
XX		  case NUMER5: return("8");
XX		  case NUMERA: return("8");
XX		  case APPL5:  return("\033?x");
XX		  case APPLA:  return("\033Ox");
XX		  default:  break;
XX			  }
XX		  return("");
XX  case   KEY_RIGHT(6): /*  9  */
XX                  switch(flag){
XX		  case NUMER5: return("9");
XX		  case NUMERA: return("9");
XX		  case APPL5:  return("\033?y");
XX		  case APPLA:  return("\033Oy");
XX		  default:  break;
XX			  }
XX		  return("");

XX  case   KEY_RIGHT(7): /*  4  */
XX		  switch(flag){
XX		  case NUMER5: return("4");
XX		  case NUMERA: return("4");
XX		  case APPL5:  return("\033?t");
XX		  case APPLA:  return("\033Ot");
XX		  default:  break;
XX			  }
XX		  return("");

XX  case   KEY_RIGHT(8): /*  5  */
XX		  switch(flag){
XX		  case NUMER5: return("5");
XX		  case NUMERA: return("5");
XX		  case APPL5:  return("\033?u");
XX		  case APPLA:  return("\033Ou");
XX		  default:  break;
XX			  }
XX		  return("");


XX  case   KEY_RIGHT(9): /*  6  */
XX		  switch(flag){
XX		  case NUMER5: return("6");
XX		  case NUMERA: return("6");
XX		  case APPL5:  return("\033?v");
XX		  case APPLA:  return("\033Ov");
XX		  default:  break;
XX			  }
XX		  return("");

XX  case   KEY_RIGHT(10): /* 1  */
XX		  switch(flag){
XX		  case NUMER5: return("1");
XX		  case NUMERA: return("1");
XX		  case APPL5:  return("\033?q");
XX		  case APPLA:  return("\033Oq");
XX		  default:  break;
XX			  }
XX		  return("");

XX  case   KEY_RIGHT(11): /* 2  */
XX		  switch(flag){
XX		  case NUMER5: return("2");
XX		  case NUMERA: return("2");
XX		  case APPL5:  return("\033?r");
XX		  case APPLA:  return("\033Or");
XX		  default:  break;
XX			  }
XX		  return("");

XX  case   KEY_RIGHT(12): /* 3  */
XX		  switch(flag){
XX		  case NUMER5: return("3");
XX		  case NUMERA: return("3");
XX		  case APPL5:  return("\033?s");
XX		  case APPLA:  return("\033Os");
XX		  default:  break;
XX			  }
XX		  return("");

XX  case   KEY_RIGHT(13): /* 0  */
XX		  switch(flag){
XX		  case NUMER5: return("0");
XX		  case NUMERA: return("0");
XX		  case APPL5:  return("\033?p");
XX		  case APPLA:  return("\033Op");
XX		  default:  break;
XX			  }
XX		  return("");

XX  case   KEY_RIGHT(14): /* .  */
XX		  switch(flag){
XX		  case NUMER5: return(".");
XX		  case NUMERA: return(".");
XX		  case APPL5:  return("\033?n");
XX		  case APPLA:  return("\033On");
XX		  default:  break;
XX			  }
XX		  return("");


XX  case   KEY_RIGHT(15): /*ENTER*/
XX		  switch(flag){
XX		  case NUMERA:  
XX		  case NUMER5: if(newline)
XX		                  return("\r\n");
XX			       else return("\r");
XX		  case APPL5:  return("\033?M");
XX		  case APPLA:  return("\033OM");
XX		  default:  break;
XX			  }
XX		  return("");

XX    /* Top panel */
XX  case   KEY_TOP(1):      return("");
XX  case   KEY_TOP(2):      return("");
XX  case   KEY_TOP(3): /*  UP   */ 
XX		  switch(flagc){
XX		  case 1: return("\033A");
XX		  case 2: return("\033[A");
XX		  case 3:  return("\033OA");
XX		  default:  break;
XX			  }
XX		  return("");

XX  case   KEY_TOP(4): /* DOWN  */
XX		  switch(flagc){
XX		  case 1: return("\033B");
XX		  case 2: return("\033[B");
XX		  case 3:  return("\033OB");
XX		  default:  break;
XX			  }
XX		  return("");

XX  case   KEY_TOP(5): /* LEFT  */
XX		  switch(flagc){
XX		  case 1: return("\033D");
XX		  case 2: return("\033[D");
XX		  case 3:  return("\033OD");
XX		  default:  break;
XX			  }
XX		  return("");

XX  case   KEY_TOP(6): /* RIGHT */
XX		  switch(flagc){
XX		  case 1: return("\033C");
XX		  case 2: return("\033[C");
XX		  case 3:  return("\033OC");
XX		  default:  break;
XX			  }
XX		  return("");

XX  case   KEY_TOP(7): /* PF4   */
XX		  switch(flag){
XX		  case NUMER5: return("\033S");
XX		  case NUMERA: return("\033OS");
XX		  case APPL5:  return("\033S");
XX		  case APPLA:  return("\033OS");
XX		  default:  break;
XX			  }
XX		  return("");

XX  case   KEY_TOP(8): /*-(dash)*/
XX		  switch(flag){
XX		  case NUMER5: return("-");
XX		  case NUMERA: return("-");
XX		  case APPL5:  return("\033?m");
XX		  case APPLA:  return("\033Om");
XX		  default:  break;
XX			  }
XX		  return("");

XX  case   KEY_TOP(9): /*,comma */
XX		  switch(flag){
XX		  case NUMER5: return(",");
XX		  case NUMERA: return(",");
XX		  case APPL5:  return("\033?l");
XX		  case APPLA:  return("\033Ol");
XX		  default:  break;
XX			  }
XX		  return("");
XX    default: return("");
XX	      }
XX}



XX/* This code puts the keyboard into a form that we can use all */
XX/*  the keys as PF-keys as a vt100; i.e. disables the arrow notion */
XX/*  on the keypad. Keys will transmit standard SUN-2 keyboard codes.*/

XX#define		MAX_keydefs	(sizeof (k_board)/sizeof (*k_board))
XXint     fbdes,
XX        kb;



XXstruct fbtype   fb;
XXstruct key_id_num {
XX	char *name;
XX	int id_num;
XX	} k_board [] = {
XX	{"'", 87},
XX	{",", 107},
XX	{"-", 40},
XX	{".", 108},
XX	{"/", 109},
XX	{"0", 39},
XX	{"1", 30},
XX	{"2", 31},
XX	{"3", 32},
XX	{"4", 33},
XX	{"5", 34},
XX	{"6", 35},
XX	{"7", 36},
XX	{"8", 37},
XX	{"9", 38},
XX	{";", 86},
XX	{"=", 41},
XX	{"break", 19},
XX	{"bs", 43},
XX	{"del", 66},
XX	{"esc", 29},
XX	{"l1", 1},
XX	{"l10", 97},
XX	{"l2", 3},
XX	{"l3", 25},
XX	{"l4", 26},
XX	{"l5", 49},
XX	{"l6", 51},
XX	{"l7", 72},
XX	{"l8", 73},
XX	{"l9", 95},
XX	{"lf", 111},
XX	{"r1", 21},
XX	{"r10", 91},
XX	{"r11", 92},
XX	{"r12", 93},
XX	{"r13", 112},
XX	{"r14", 113},
XX	{"r15", 114},
XX	{"r2", 22},
XX	{"r3", 23},
XX	{"r4", 45},
XX	{"r5", 46},
XX	{"r6", 47},
XX	{"r7", 68},
XX	{"r8", 69},
XX	{"r9", 70},
XX	{"ret", 89},
XX	{"f1", 5},
XX	{"f2", 6},
XX	{"f3", 8},
XX	{"f4", 10},
XX	{"f5", 12},
XX	{"f6", 14},
XX	{"f7", 16},
XX	{"f8", 17},
XX	{"f9", 18},
XX	{"tab", 53},
XX	{"[", 64},
XX	{"\\", 88},
XX	{"]", 65},
XX	{"`", 42},
XX	{"a", 77},
XX	{"b", 104},
XX	{"c", 102},
XX	{"d", 79},
XX	{"e", 56},
XX	{"f", 80},
XX	{"g", 81},
XX	{"h", 82},
XX	{"i", 61},
XX	{"j", 83},
XX	{"k", 84},
XX	{"l", 85},
XX	{"m", 106},
XX	{"n", 105},
XX	{"o", 62},
XX	{"p", 63},
XX	{"q", 54},
XX	{"r", 57},
XX	{"s", 78},
XX	{"t", 58},
XX	{"u", 60},
XX	{"v", 103},
XX	{"w", 55},
XX	{"x", 101},
XX	{"y", 59},
XX	{"z", 100}
XX};
XX/* rf8,10,12,and 14 are the culprits. when the kbd is initialized */
XX/* they transmit an escape code instead of the standard sun-2 position*/
XXvoid
XXinit_kbd()
XX{
XX		prep_kbd ();	/* prepare keyboard */
XX		set_key("r8",RF(8));
XX		set_key("r10",RF(10));
XX		set_key("r12",RF(12));
XX		set_key("r14",RF(14));

XX}

XXint prep_kbd()
XX{
XX    if ((fbdes = open ("/dev/fb", 2)) < 0) {
XX	fprintf (stderr, "%s: couldn't open framebuffer\n", "ttyvt100");
XX	exit (2);
XX    }

XX    if (ioctl (fbdes, FBIOGTYPE, &fb) < 0) {
XX	fprintf (stderr, "%s: couldn't get the fb struct\n", "ttyvt100");
XX	exit (2);
XX    }

XX    if (fb.fb_type != FBTYPE_SUN2BW) {
XX	fprintf (stderr, "Sorry, I only do Sun2s\n", "ttyvt100");
XX	exit (2);
XX    }

XX    if ((kb = open ("/dev/kbd", 2)) < 0) {
XX	fprintf (stderr, "%s: couldn't open keyboard\n", "ttyvt100");
XX	exit (2);
XX    }
XX    return;
XX}

XXint set_key(key, keydef)
XXchar *key;
XXint keydef;
XX{
XX    int     found_key = FALSE,
XX            i;

XX    struct kiockey  this_key;
XX    struct kiockey *pk = &this_key;


XX    switch (*key) {
XX	case 'C': 
XX	    pk -> kio_tablemask = CTRLMASK;
XX	    key++;
XX	    break;
XX	case 'S': 
XX	    pk -> kio_tablemask = SHIFTMASK;
XX	    key++;
XX	    break;
XX	default: 
XX	    pk -> kio_tablemask = 0;
XX	    break;
XX    }


XX    for (i = 0; i < MAX_keydefs; i++) {
XX	if (strncmp (key, k_board[i].name, 3) == 0) {
XX	    found_key = TRUE;
XX	    break;
XX	}
XX    }

XX    if (!found_key) {
XX	fprintf (stderr, "%s: couldn't find `%s' key\n", "ttyvt100", key);
XX	exit (2);
XX    }

XX    pk -> kio_station = k_board[i].id_num;

XX/*    pk -> kio_tablemask = 0; */


XX		    pk -> kio_entry = keydef;
XX		
XX 
XX/* define key */

XX    if (ioctl (kb, KIOCSETKEY, pk) < 0) {
XX	fprintf (stderr, "%s: couldn't define the `%s' key\n", "ttyvt100", key);
XX	exit (2);
XX    }
XX    return;
XX}
XX/* end of the keyboard stuff. only do this on entering. whew! */


@//E*O*F src/vt100keys.c//
chmod u=r,g=r,o=r src/vt100keys.c
 
echo x - MANIFEST
sed 's/^XX//' > "MANIFEST" <<'@//E*O*F MANIFEST//'
XXINSTALL                      1
XXMANIFEST                     1
XXMANIFEST                     9
XXdecode.sh                    1
XXfontdir                      1
XXfontdir/uu.gacha.b.8         1
XXfontdir/uu.gacha.bg.8        1
XXfontdir/uu.gacha.g.8         1
XXfontdir/uu.gacha.r.8         1
XXfontdir/uu.testfont.sh       1
XXfontdir/uu.thin.b.5          1
XXfontdir/uu.thin.b.6          1
XXfontdir/uu.thin.bg.5         2
XXfontdir/uu.thin.bg.6         2
XXfontdir/uu.thin.g.5          2
XXfontdir/uu.thin.g.6          2
XXfontdir/uu.thin.r.5          2
XXfontdir/uu.thin.r.6          2
XXfontdir/uu.thinbot.b.10      2
XXfontdir/uu.thinbot.bg.10     3
XXfontdir/uu.thinbot.g.10      3
XXfontdir/uu.thinbot.r.10      3
XXfontdir/uu.thintop.b.10      3
XXfontdir/uu.thintop.bg.10     3
XXfontdir/uu.thintop.g.10      3
XXfontdir/uu.thintop.r.10      4
XXfontdir/uu.thinwide.b.10     4
XXfontdir/uu.thinwide.bg.10     4
XXfontdir/uu.thinwide.g.10     4
XXfontdir/uu.thinwide.r.10     4
XXfontdir/uu.wide.b.16         4
XXfontdir/uu.wide.bg.16        5
XXfontdir/uu.wide.g.16         5
XXfontdir/uu.wide.r.16         5
XXfontdir/uu.widebot.b.16      5
XXfontdir/uu.widebot.bg.16     5
XXfontdir/uu.widebot.g.16      5
XXfontdir/uu.widebot.r.16      6
XXfontdir/uu.widetop.b.16      6
XXfontdir/uu.widetop.bg.16     6
XXfontdir/uu.widetop.g.16      6
XXfontdir/uu.widetop.r.16      6
XXlibdir                       1
XXlibdir/makefile              1
XXlibdir/uu.cim_change.o       6
XXlibdir/uu.cim_size.o         2
XXlibdir/uu.csr_change.o       7
XXlibdir/uu.csr_init.o         7
XXlibdir/uu.ttysw_main.o       7
XXlibdir/uu.ttyvt100.o         8
XXlibdir/uu.vt100fonts.o       7
XXlibdir/uu.vt100keys.o        8
XXmakefile                     1
XXsrc                          3
XXsrc/README                   6
XXsrc/ttyvt100.c               9
XXsrc/ttyvt100.h               8
XXsrc/vt100fonts.c             8
XXsrc/vt100keys.c              9
XXvconfig.h                    8
XXvshelltool.icon              6
XXvt100tool.1                  8
XXvt100tool.c                  10
@//E*O*F MANIFEST//
chmod u=rw,g=rw,o=rw MANIFEST
 
echo Inspecting for damage in transit...
temp=/tmp/sharin$$; dtemp=/tmp/sharout$$
trap "rm -f $temp $dtemp; exit" 0 1 2 3 15
cat > $temp <<\!!!
    1215    3746   27979 ttyvt100.c
     491    1239   10210 vt100keys.c
      63     126    1955 MANIFEST
    1769    5111   40144 total
!!!
wc  src/ttyvt100.c src/vt100keys.c MANIFEST | sed 's=[^ ]*/==' | diff -b $temp - >$dtemp
if test -s $dtemp
then echo "Ouch [diff of wc output]:" ; cat $dtemp
else echo "No problems found."
fi
exit 0
