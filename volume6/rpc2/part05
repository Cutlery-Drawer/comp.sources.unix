Subject:  v06i093:  Sun RPC Source (rpc2), Part05/11
Newsgroups: mod.sources
Approved: rs@mirror.UUCP

Submitted by: cca!SUN.COM!marks (Mark Stein)
Mod.sources: Volume 6, Issue 93
Archive-name: rpc2/Part05

[  I have done nothing other than verify that the files unpack ok.  --r$  ]

Sun RPC source (part 5 of 11).  This software package contains code
and documentation for Revision 3.0 of the Sun Remote Procedure Call
library.  In addition, a beta version of the XDR/RPC protocol compiler
is included.  Comments about this latest release may be mailed to
sun!rpc or rpc@sun.com.

Sun RPC is a product of Sun Microsystems, Inc. and is provided for
unrestricted use provided that this legend is included on all tape
media and as a part of the software program in whole or part.  Users
may copy or modify Sun RPC without charge, but are not authorized to
license or distribute it to anyone else except as part of a product or
program developed by the user.

- - - - - - - - - C U T - H E R E - - - - - - - - - - - - - - - - - -
#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create:
#	rpc/rpclib/auth.h
#	rpc/rpclib/auth_unix.h
#	rpc/rpclib/clnt.h
#	rpc/rpclib/pmap_clnt.h
#	rpc/rpclib/pmap_prot.h
#	rpc/rpclib/rpc.h
#	rpc/rpclib/rpc_msg.h
#	rpc/rpclib/svc.h
#	rpc/rpclib/svc_auth.h
#	rpc/rpclib/types.h
#	rpc/rpclib/xdr.h
# This archive created: Mon Jul 14 16:55:13 1986
export PATH; PATH=/bin:/usr/bin:$PATH
for d in rpc rpc/doc rpc/rpclib rpc/tools rpc/toys rpc/rpclib/profiled rpc/rpcgen rpc/rpcgen/test
do
	if test ! -d $d
	then
		echo "shar: Making directory $d"
		mkdir $d
		chmod 755 $d
	fi
done
echo shar: "extracting 'rpc/rpclib/auth.h'" '(4399 characters)'
if test -f 'rpc/rpclib/auth.h'
then
	echo shar: "will not over-write existing file 'rpc/rpclib/auth.h'"
else
sed 's/^X//' << \SHAR_EOF > 'rpc/rpclib/auth.h'
X/*
X * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
X * unrestricted use provided that this legend is included on all tape
X * media and as a part of the software program in whole or part.  Users
X * may copy or modify Sun RPC without charge, but are not authorized
X * to license or distribute it to anyone else except as part of a product or
X * program developed by the user.
X * 
X * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
X * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
X * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
X * 
X * Sun RPC is provided with no support and without any obligation on the
X * part of Sun Microsystems, Inc. to assist in its use, correction,
X * modification or enhancement.
X * 
X * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
X * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
X * OR ANY PART THEREOF.
X * 
X * In no event will Sun Microsystems, Inc. be liable for any lost revenue
X * or profits or other special, indirect and consequential damages, even if
X * Sun has been advised of the possibility of such damages.
X * 
X * Sun Microsystems, Inc.
X * 2550 Garcia Avenue
X * Mountain View, California  94043
X */
X/*      @(#)auth.h 1.1 86/02/03 SMI      */
X
X/*
X * auth.h, Authentication interface.
X *
X * Copyright (C) 1984, Sun Microsystems, Inc.
X *
X * The data structures are completely opaque to the client.  The client
X * is required to pass a AUTH * to routines that create rpc
X * "sessions".
X */
X
X
X#define MAX_AUTH_BYTES	400
X
X
X/*
X * Status returned from authentication check
X */
Xenum auth_stat {
X	AUTH_OK=0,
X	/*
X	 * failed at remote end
X	 */
X	AUTH_BADCRED=1,			/* bogus credentials (seal broken) */
X	AUTH_REJECTEDCRED=2,		/* client should begin new session */
X	AUTH_BADVERF=3,			/* bogus verifier (seal broken) */
X	AUTH_REJECTEDVERF=4,		/* verifier expired or was replayed */
X	AUTH_TOOWEAK=5,			/* rejected due to security reasons */
X	/*
X	 * failed locally
X	*/
X	AUTH_INVALIDRESP=6,		/* bogus response verifier */
X	AUTH_FAILED=7			/* some unknown reason */
X};
X
X
Xunion des_block {
X	struct {
X		u_long high;
X		u_long low;
X	} key;
X	char c[8];
X};
X
X
X/*
X * Authentication info.  Opaque to client.
X */
Xstruct opaque_auth {
X	enum_t	oa_flavor;		/* flavor of auth */
X	caddr_t	oa_base;		/* address of more auth stuff */
X	u_int	oa_length;		/* not to exceed MAX_AUTH_BYTES */
X};
X
X
X/*
X * Auth handle, interface to client side authenticators.
X */
Xtypedef struct {
X	struct	opaque_auth	ah_cred;
X	struct	opaque_auth	ah_verf;
X	union	des_block	ah_key;
X	struct auth_ops {
X		void	(*ah_nextverf)();
X		int	(*ah_marshal)();	/* nextverf & serialize */
X		int	(*ah_validate)();	/* validate varifier */
X		int	(*ah_refresh)();	/* refresh credentials */
X		void	(*ah_destroy)();	/* destroy this structure */
X	} *ah_ops;
X	caddr_t ah_private;
X} AUTH;
X
X
X/*
X * Authentication ops.
X * The ops and the auth handle provide the interface to the authenticators.
X *
X * AUTH	*auth;
X * XDR	*xdrs;
X * struct opaque_auth verf;
X */
X#define AUTH_NEXTVERF(auth)		\
X		((*((auth)->ah_ops->ah_nextverf))(auth))
X#define auth_nextverf(auth)		\
X		((*((auth)->ah_ops->ah_nextverf))(auth))
X
X#define AUTH_MARSHALL(auth, xdrs)	\
X		((*((auth)->ah_ops->ah_marshal))(auth, xdrs))
X#define auth_marshall(auth, xdrs)	\
X		((*((auth)->ah_ops->ah_marshal))(auth, xdrs))
X
X#define AUTH_VALIDATE(auth, verfp)	\
X		((*((auth)->ah_ops->ah_validate))((auth), verfp))
X#define auth_validate(auth, verfp)	\
X		((*((auth)->ah_ops->ah_validate))((auth), verfp))
X
X#define AUTH_REFRESH(auth)		\
X		((*((auth)->ah_ops->ah_refresh))(auth))
X#define auth_refresh(auth)		\
X		((*((auth)->ah_ops->ah_refresh))(auth))
X
X#define AUTH_DESTROY(auth)		\
X		((*((auth)->ah_ops->ah_destroy))(auth))
X#define auth_destroy(auth)		\
X		((*((auth)->ah_ops->ah_destroy))(auth))
X
X
Xextern struct opaque_auth _null_auth;
X
X
X/*
X * These are the various implementations of client side authenticators.
X */
X
X/*
X * Unix style authentication
X * AUTH *authunix_create(machname, uid, gid, len, aup_gids)
X *	char *machname;
X *	int uid;
X *	int gid;
X *	int len;
X *	int *aup_gids;
X */
Xextern AUTH *authunix_create();
Xextern AUTH *authunix_create_default();	/* takes no parameters */
Xextern AUTH *authnone_create();		/* takes no parameters */
X
X#define	AUTH_NULL	0
X#define	AUTH_UNIX	1		/* unix style (uid, gids) */
X#define	AUTH_SHORT	2		/* short hand unix style */
SHAR_EOF
if test 4399 -ne "`wc -c < 'rpc/rpclib/auth.h'`"
then
	echo shar: "error transmitting 'rpc/rpclib/auth.h'" '(should have been 4399 characters)'
fi
chmod 444 'rpc/rpclib/auth.h'
fi
echo shar: "extracting 'rpc/rpclib/auth_unix.h'" '(2343 characters)'
if test -f 'rpc/rpclib/auth_unix.h'
then
	echo shar: "will not over-write existing file 'rpc/rpclib/auth_unix.h'"
else
sed 's/^X//' << \SHAR_EOF > 'rpc/rpclib/auth_unix.h'
X/*
X * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
X * unrestricted use provided that this legend is included on all tape
X * media and as a part of the software program in whole or part.  Users
X * may copy or modify Sun RPC without charge, but are not authorized
X * to license or distribute it to anyone else except as part of a product or
X * program developed by the user.
X * 
X * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
X * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
X * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
X * 
X * Sun RPC is provided with no support and without any obligation on the
X * part of Sun Microsystems, Inc. to assist in its use, correction,
X * modification or enhancement.
X * 
X * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
X * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
X * OR ANY PART THEREOF.
X * 
X * In no event will Sun Microsystems, Inc. be liable for any lost revenue
X * or profits or other special, indirect and consequential damages, even if
X * Sun has been advised of the possibility of such damages.
X * 
X * Sun Microsystems, Inc.
X * 2550 Garcia Avenue
X * Mountain View, California  94043
X */
X/*      @(#)auth_unix.h 1.1 86/02/03 SMI      */
X
X/*
X * auth_unix.h, Protocol for UNIX style authentication parameters for RPC
X *
X * Copyright (C) 1984, Sun Microsystems, Inc.
X */
X
X/*
X * The system is very weak.  The client uses no encryption for  it
X * credentials and only sends null verifiers.  The server sends backs
X * null verifiers or optionally a verifier that suggests a new short hand
X * for the credentials.
X */
X
X/* The machine name is part of a credential; it may not exceed 255 bytes */
X#define MAX_MACHINE_NAME 255
X
X/* gids compose part of a credential; there may not be more than 10 of them */
X#define NGRPS 8
X
X/*
X * Unix style credentials.
X */
Xstruct authunix_parms {
X	u_long	 aup_time;
X	char	*aup_machname;
X	int	 aup_uid;
X	int	 aup_gid;
X	u_int	 aup_len;
X	int	*aup_gids;
X};
X
Xextern bool_t xdr_authunix_parms();
X
X/* 
X * If a response verifier has flavor AUTH_SHORT, 
X * then the body of the response verifier encapsulates the following structure;
X * again it is serialized in the obvious fashion.
X */
Xstruct short_hand_verf {
X	struct opaque_auth new_cred;
X};
SHAR_EOF
if test 2343 -ne "`wc -c < 'rpc/rpclib/auth_unix.h'`"
then
	echo shar: "error transmitting 'rpc/rpclib/auth_unix.h'" '(should have been 2343 characters)'
fi
chmod 444 'rpc/rpclib/auth_unix.h'
fi
echo shar: "extracting 'rpc/rpclib/clnt.h'" '(6991 characters)'
if test -f 'rpc/rpclib/clnt.h'
then
	echo shar: "will not over-write existing file 'rpc/rpclib/clnt.h'"
else
sed 's/^X//' << \SHAR_EOF > 'rpc/rpclib/clnt.h'
X/*
X * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
X * unrestricted use provided that this legend is included on all tape
X * media and as a part of the software program in whole or part.  Users
X * may copy or modify Sun RPC without charge, but are not authorized
X * to license or distribute it to anyone else except as part of a product or
X * program developed by the user.
X * 
X * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
X * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
X * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
X * 
X * Sun RPC is provided with no support and without any obligation on the
X * part of Sun Microsystems, Inc. to assist in its use, correction,
X * modification or enhancement.
X * 
X * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
X * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
X * OR ANY PART THEREOF.
X * 
X * In no event will Sun Microsystems, Inc. be liable for any lost revenue
X * or profits or other special, indirect and consequential damages, even if
X * Sun has been advised of the possibility of such damages.
X * 
X * Sun Microsystems, Inc.
X * 2550 Garcia Avenue
X * Mountain View, California  94043
X */
X/*	@(#)clnt.h 1.1 86/02/03 SMI      */
X
X/*
X * clnt.h - Client side remote procedure call interface.
X *
X * Copyright (C) 1984, Sun Microsystems, Inc.
X */
X
X/*
X * Rpc calls return an enum clnt_stat.  This should be looked at more,
X * since each implementation is required to live with this (implementation
X * independent) list of errors.
X */
Xenum clnt_stat {
X	RPC_SUCCESS=0,			/* call succeeded */
X	/*
X	 * local errors
X	 */
X	RPC_CANTENCODEARGS=1,		/* can't encode arguments */
X	RPC_CANTDECODERES=2,		/* can't decode results */
X	RPC_CANTSEND=3,			/* failure in sending call */
X	RPC_CANTRECV=4,			/* failure in receiving result */
X	RPC_TIMEDOUT=5,			/* call timed out */
X	/*
X	 * remote errors
X	 */
X	RPC_VERSMISMATCH=6,		/* rpc versions not compatible */
X	RPC_AUTHERROR=7,		/* authentication error */
X	RPC_PROGUNAVAIL=8,		/* program not available */
X	RPC_PROGVERSMISMATCH=9,		/* program version mismatched */
X	RPC_PROCUNAVAIL=10,		/* procedure unavailable */
X	RPC_CANTDECODEARGS=11,		/* decode arguments error */
X	RPC_SYSTEMERROR=12,		/* generic "other problem" */
X
X	/*
X	 * callrpc errors
X	 */
X	RPC_UNKNOWNHOST=13,		/* unknown host name */
X
X	/*
X	 * _ create errors
X	 */
X	RPC_PMAPFAILURE=14,		/* the pmapper failed in its call */
X	RPC_PROGNOTREGISTERED=15,	/* remote program is not registered */
X	/*
X	 * unspecified error
X	 */
X	RPC_FAILED=16
X};
X
X
X/*
X * Error info.
X */
Xstruct rpc_err {
X	enum clnt_stat re_status;
X	union {
X		int RE_errno;		/* realated system error */
X		enum auth_stat RE_why;	/* why the auth error occurred */
X		struct {
X			u_long low;	/* lowest verion supported */
X			u_long high;	/* highest verion supported */
X		} RE_vers;
X		struct {		/* maybe meaningful if RPC_FAILED */
X			long s1;
X			long s2;
X		} RE_lb;		/* life boot & debugging only */
X	} ru;
X#define	re_errno	ru.RE_errno
X#define	re_why		ru.RE_why
X#define	re_vers		ru.RE_vers
X#define	re_lb		ru.RE_lb
X};
X
X
X/*
X * Client rpc handle.
X * Created by individual implementations, see e.g. rpc_udp.c.
X * Client is responsible for initializing auth, see e.g. auth_none.c.
X */
Xtypedef struct {
X	AUTH	*cl_auth;			/* authenticator */
X	struct clnt_ops {
X		enum clnt_stat	(*cl_call)();	/* call remote procedure */
X		void		(*cl_abort)();	/* abort a call */
X		void		(*cl_geterr)();	/* get specific error code */
X		bool_t		(*cl_freeres)(); /* frees results */
X		void		(*cl_destroy)();/* destroy this structure */
X	} *cl_ops;
X	caddr_t			cl_private;	/* private stuff */
X} CLIENT;
X
X
X/*
X * client side rpc interface ops
X *
X * Parameter types are:
X *
X */
X
X/*
X * enum clnt_stat
X * CLNT_CALL(rh, proc, xargs, argsp, xres, resp, timeout)
X * 	CLIENT *rh;
X *	u_long proc;
X *	xdrproc_t xargs;
X *	caddr_t argsp;
X *	xdrproc_t xres;
X *	caddr_t resp;
X *	struct timeval timeout;
X */
X#define	CLNT_CALL(rh, proc, xargs, argsp, xres, resp, secs)	\
X	((*(rh)->cl_ops->cl_call)(rh, proc, xargs, argsp, xres, resp, secs))
X#define	clnt_call(rh, proc, xargs, argsp, xres, resp, secs)	\
X	((*(rh)->cl_ops->cl_call)(rh, proc, xargs, argsp, xres, resp, secs))
X
X/*
X * void
X * CLNT_ABORT(rh);
X * 	CLIENT *rh;
X */
X#define	CLNT_ABORT(rh)	((*(rh)->cl_ops->cl_abort)(rh))
X#define	clnt_abort(rh)	((*(rh)->cl_ops->cl_abort)(rh))
X
X/*
X * struct rpc_err
X * CLNT_GETERR(rh);
X * 	CLIENT *rh;
X */
X#define	CLNT_GETERR(rh,errp)	((*(rh)->cl_ops->cl_geterr)(rh, errp))
X#define	clnt_geterr(rh,errp)	((*(rh)->cl_ops->cl_geterr)(rh, errp))
X
X
X/*
X * bool_t
X * CLNT_FREERES(rh, xres, resp);
X * 	CLIENT *rh;
X *	xdrproc_t xres;
X *	caddr_t resp;
X */
X#define	CLNT_FREERES(rh,xres,resp) ((*(rh)->cl_ops->cl_freeres)(rh,xres,resp))
X#define	clnt_freeres(rh,xres,resp) ((*(rh)->cl_ops->cl_freeres)(rh,xres,resp))
X
X/*
X * void
X * CLNT_DESTROY(rh);
X * 	CLIENT *rh;
X */
X#define	CLNT_DESTROY(rh)	((*(rh)->cl_ops->cl_destroy)(rh))
X#define	clnt_destroy(rh)	((*(rh)->cl_ops->cl_destroy)(rh))
X
X
X/*
X * RPCTEST is a test program which is accessable on every rpc
X * transport/port.  It is used for testing, performance evaluation,
X * and network administration.
X */
X
X#define RPCTEST_PROGRAM		((u_long)1)
X#define RPCTEST_VERSION		((u_long)1)
X#define RPCTEST_NULL_PROC	((u_long)2)
X#define RPCTEST_NULL_BATCH_PROC	((u_long)3)
X
X/*
X * By convention, procedure 0 takes null arguments and returns them
X */
X
X#define NULLPROC ((u_long)0)
X
X/*
X * Below are the client handle creation routines for the various
X * implementations of client side rpc.  They can return NULL if a 
X * creation failure occurs.
X */
X
X/*
X * Memory based rpc (for speed check and testing)
X * CLIENT *
X * clntraw_create(prog, vers)
X *	u_long prog;
X *	u_long vers;
X */
Xextern CLIENT *clntraw_create();
X
X/*
X * TCP based rpc
X * CLIENT *
X * clnttcp_create(raddr, prog, vers, sockp, sendsz, recvsz)
X *	struct sockaddr_in *raddr;
X *	u_long prog;
X *	u_long version;
X *	register int *sockp;
X *	u_int sendsz;
X *	u_int recvsz;
X */
Xextern CLIENT *clnttcp_create();
X
X/*
X * UDP based rpc.
X * CLIENT *
X * clntudp_create(raddr, program, version, wait, sockp)
X *	struct sockaddr_in *raddr;
X *	u_long program;
X *	u_long version;
X *	struct timeval wait;
X *	int *sockp;
X *
X * Same as above, but you specify max packet sizes.
X * CLIENT *
X * clntudp_bufcreate(raddr, program, version, wait, sockp, sendsz, recvsz)
X *	struct sockaddr_in *raddr;
X *	u_long program;
X *	u_long version;
X *	struct timeval wait;
X *	int *sockp;
X *	u_int sendsz;
X *	u_int recvsz;
X */
Xextern CLIENT *clntudp_create();
Xextern CLIENT *clntudp_bufcreate();
X
X/* 
X * If a creation fails, the following allows the user to figure out why.
X */
Xstruct rpc_createerr {
X	enum clnt_stat cf_stat;
X	struct rpc_err cf_error; /* useful when cf_stat == RPC_PMAPFAILURE */
X};
X
Xextern struct rpc_createerr rpc_createerr;
X
X
X#define UDPMSGSIZE	8800	/* rpc imposed limit on udp msg size */
X#define RPCSMALLMSGSIZE	400	/* a more reasonable packet size */
SHAR_EOF
if test 6991 -ne "`wc -c < 'rpc/rpclib/clnt.h'`"
then
	echo shar: "error transmitting 'rpc/rpclib/clnt.h'" '(should have been 6991 characters)'
fi
chmod 444 'rpc/rpclib/clnt.h'
fi
echo shar: "extracting 'rpc/rpclib/pmap_clnt.h'" '(2481 characters)'
if test -f 'rpc/rpclib/pmap_clnt.h'
then
	echo shar: "will not over-write existing file 'rpc/rpclib/pmap_clnt.h'"
else
sed 's/^X//' << \SHAR_EOF > 'rpc/rpclib/pmap_clnt.h'
X/*
X * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
X * unrestricted use provided that this legend is included on all tape
X * media and as a part of the software program in whole or part.  Users
X * may copy or modify Sun RPC without charge, but are not authorized
X * to license or distribute it to anyone else except as part of a product or
X * program developed by the user.
X * 
X * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
X * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
X * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
X * 
X * Sun RPC is provided with no support and without any obligation on the
X * part of Sun Microsystems, Inc. to assist in its use, correction,
X * modification or enhancement.
X * 
X * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
X * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
X * OR ANY PART THEREOF.
X * 
X * In no event will Sun Microsystems, Inc. be liable for any lost revenue
X * or profits or other special, indirect and consequential damages, even if
X * Sun has been advised of the possibility of such damages.
X * 
X * Sun Microsystems, Inc.
X * 2550 Garcia Avenue
X * Mountain View, California  94043
X */
X/*	@(#)pmap_clnt.h 1.1 86/02/03 SMI	*/
X
X/*
X * portmap_clnt.h
X * Supplies C routines to get to portmap services.
X *
X * Copyright (C) 1984, Sun Microsystems, Inc.
X */
X
X/*
X * Usage:
X *	success = pmap_set(program, version, protocol, port);
X *	success = pmap_unset(program, version);
X *	port = pmap_getport(address, program, version, protocol);
X *	head = pmap_getmaps(address);
X *	clnt_stat = pmap_rmtcall(address, program, version, procedure,
X *		xdrargs, argsp, xdrres, resp, tout, port_ptr)
X *		(works for udp only.) 
X * 	clnt_stat = clnt_broadcast(program, version, procedure,
X *		xdrargs, argsp,	xdrres, resp, eachresult)
X *		(like pmap_rmtcall, except the call is broadcasted to all
X *		locally connected nets.  For each valid response received,
X *		the procedure eachresult is called.  Its form is:
X *	done = eachresult(resp, raddr)
X *		bool_t done;
X *		caddr_t resp;
X *		struct sockaddr_in raddr;
X *		where resp points to the results of the call and raddr is the
X *		address if the responder to the broadcast.
X */
X
Xextern bool_t		pmap_set();
Xextern bool_t		pmap_unset();
Xextern u_short		pmap_getport();
Xextern struct pmaplist	*pmap_getmaps();
Xenum clnt_stat		pmap_rmtcall();
Xenum clnt_stat		clnt_broadcast();
SHAR_EOF
if test 2481 -ne "`wc -c < 'rpc/rpclib/pmap_clnt.h'`"
then
	echo shar: "error transmitting 'rpc/rpclib/pmap_clnt.h'" '(should have been 2481 characters)'
fi
chmod 444 'rpc/rpclib/pmap_clnt.h'
fi
echo shar: "extracting 'rpc/rpclib/pmap_prot.h'" '(3302 characters)'
if test -f 'rpc/rpclib/pmap_prot.h'
then
	echo shar: "will not over-write existing file 'rpc/rpclib/pmap_prot.h'"
else
sed 's/^X//' << \SHAR_EOF > 'rpc/rpclib/pmap_prot.h'
X/*
X * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
X * unrestricted use provided that this legend is included on all tape
X * media and as a part of the software program in whole or part.  Users
X * may copy or modify Sun RPC without charge, but are not authorized
X * to license or distribute it to anyone else except as part of a product or
X * program developed by the user.
X * 
X * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
X * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
X * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
X * 
X * Sun RPC is provided with no support and without any obligation on the
X * part of Sun Microsystems, Inc. to assist in its use, correction,
X * modification or enhancement.
X * 
X * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
X * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
X * OR ANY PART THEREOF.
X * 
X * In no event will Sun Microsystems, Inc. be liable for any lost revenue
X * or profits or other special, indirect and consequential damages, even if
X * Sun has been advised of the possibility of such damages.
X * 
X * Sun Microsystems, Inc.
X * 2550 Garcia Avenue
X * Mountain View, California  94043
X */
X/*	@(#)pmap_prot.h 1.1 86/02/03 SMI	*/
X
X/*
X * pmap_prot.h
X * Protocol for the local binder service, or pmap.
X *
X * Copyright (C) 1984, Sun Microsystems, Inc.
X *
X * The following procedures are supported by the protocol:
X *
X * PMAPPROC_NULL() returns ()
X * 	takes nothing, returns nothing
X *
X * PMAPPROC_SET(struct pmap) returns (bool_t)
X * 	TRUE is success, FALSE is failure.  Registers the tuple
X *	[prog, vers, prot, port].
X *
X * PMAPPROC_UNSET(struct pmap) returns (bool_t)
X *	TRUE is success, FALSE is failure.  Un-registers pair
X *	[prog, vers].  prot and port are ignored.
X *
X * PMAPPROC_GETPORT(struct pmap) returns (long unsigned).
X *	0 is failure.  Otherwise returns the port number where the pair
X *	[prog, vers] is registered.  It may lie!
X *
X * PMAPPROC_DUMP() RETURNS (struct pmaplist *)
X *
X * PMAPPROC_CALLIT(unsigned, unsigned, unsigned, string<>)
X * 	RETURNS (port, string<>);
X * usage: encapsulatedresults = PMAPPROC_CALLIT(prog, vers, proc, encapsulatedargs);
X * 	Calls the procedure on the local machine.  If it is not registered,
X *	this procedure is quite; ie it does not return error information!!!
X *	This procedure only is supported on rpc/udp and calls via
X *	rpc/udp.  This routine only passes null authentication parameters.
X *	This file has no interface to xdr routines for PMAPPROC_CALLIT.
X *
X * The service supports remote procedure calls on udp/ip or tcp/ip socket 111.
X */
X
X#define PMAPPORT		((u_short)111)
X#define PMAPPROG		((u_long)100000)
X#define PMAPVERS		((u_long)2)
X#define PMAPVERS_PROTO		((u_long)2)
X#define PMAPVERS_ORIG		((u_long)1)
X#define PMAPPROC_NULL		((u_long)0)
X#define PMAPPROC_SET		((u_long)1)
X#define PMAPPROC_UNSET		((u_long)2)
X#define PMAPPROC_GETPORT	((u_long)3)
X#define PMAPPROC_DUMP		((u_long)4)
X#define PMAPPROC_CALLIT		((u_long)5)
X
Xstruct pmap {
X	long unsigned pm_prog;
X	long unsigned pm_vers;
X	long unsigned pm_prot;
X	long unsigned pm_port;
X};
X
Xextern bool_t xdr_pmap();
X
Xstruct pmaplist {
X	struct pmap	pml_map;
X	struct pmaplist *pml_next;
X};
X
Xextern bool_t xdr_pmaplist();
SHAR_EOF
if test 3302 -ne "`wc -c < 'rpc/rpclib/pmap_prot.h'`"
then
	echo shar: "error transmitting 'rpc/rpclib/pmap_prot.h'" '(should have been 3302 characters)'
fi
chmod 444 'rpc/rpclib/pmap_prot.h'
fi
echo shar: "extracting 'rpc/rpclib/rpc.h'" '(2153 characters)'
if test -f 'rpc/rpclib/rpc.h'
then
	echo shar: "will not over-write existing file 'rpc/rpclib/rpc.h'"
else
sed 's/^X//' << \SHAR_EOF > 'rpc/rpclib/rpc.h'
X/*
X * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
X * unrestricted use provided that this legend is included on all tape
X * media and as a part of the software program in whole or part.  Users
X * may copy or modify Sun RPC without charge, but are not authorized
X * to license or distribute it to anyone else except as part of a product or
X * program developed by the user.
X * 
X * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
X * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
X * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
X * 
X * Sun RPC is provided with no support and without any obligation on the
X * part of Sun Microsystems, Inc. to assist in its use, correction,
X * modification or enhancement.
X * 
X * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
X * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
X * OR ANY PART THEREOF.
X * 
X * In no event will Sun Microsystems, Inc. be liable for any lost revenue
X * or profits or other special, indirect and consequential damages, even if
X * Sun has been advised of the possibility of such damages.
X * 
X * Sun Microsystems, Inc.
X * 2550 Garcia Avenue
X * Mountain View, California  94043
X */
X/*	@(#)rpc.h 1.1 86/02/03 SMI	*/
X
X/*
X * rpc.h, Just includes the billions of rpc header files necessary to 
X * do remote procedure calling.
X *
X * Copyright (C) 1984, Sun Microsystems, Inc.
X */
X
X#include <rpc/types.h>		/* some typedefs */
X#include <netinet/in.h>
X
X/* external data representation interfaces */
X#include <rpc/xdr.h>		/* generic (de)serializer */
X
X/* Client side only authentication */
X#include <rpc/auth.h>		/* generic authenticator (client side) */
X
X/* Client side (mostly) remote procedure call */
X#include <rpc/clnt.h>		/* generic rpc stuff */
X
X/* semi-private protocol headers */
X#include <rpc/rpc_msg.h>	/* protocol for rpc messages */
X#include <rpc/auth_unix.h>	/* protocol for unix style cred */
X
X/* Server side only remote procedure callee */
X#include <rpc/svc.h>		/* service manager and multiplexer */
X#include <rpc/svc_auth.h>	/* service side authenticator */
SHAR_EOF
if test 2153 -ne "`wc -c < 'rpc/rpclib/rpc.h'`"
then
	echo shar: "error transmitting 'rpc/rpclib/rpc.h'" '(should have been 2153 characters)'
fi
chmod 444 'rpc/rpclib/rpc.h'
fi
echo shar: "extracting 'rpc/rpclib/rpc_msg.h'" '(4134 characters)'
if test -f 'rpc/rpclib/rpc_msg.h'
then
	echo shar: "will not over-write existing file 'rpc/rpclib/rpc_msg.h'"
else
sed 's/^X//' << \SHAR_EOF > 'rpc/rpclib/rpc_msg.h'
X/*
X * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
X * unrestricted use provided that this legend is included on all tape
X * media and as a part of the software program in whole or part.  Users
X * may copy or modify Sun RPC without charge, but are not authorized
X * to license or distribute it to anyone else except as part of a product or
X * program developed by the user.
X * 
X * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
X * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
X * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
X * 
X * Sun RPC is provided with no support and without any obligation on the
X * part of Sun Microsystems, Inc. to assist in its use, correction,
X * modification or enhancement.
X * 
X * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
X * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
X * OR ANY PART THEREOF.
X * 
X * In no event will Sun Microsystems, Inc. be liable for any lost revenue
X * or profits or other special, indirect and consequential damages, even if
X * Sun has been advised of the possibility of such damages.
X * 
X * Sun Microsystems, Inc.
X * 2550 Garcia Avenue
X * Mountain View, California  94043
X */
X/*      @(#)rpc_msg.h 1.1 86/02/03 SMI      */
X
X/*
X * rpc_msg.h
X * rpc message definition
X *
X * Copyright (C) 1984, Sun Microsystems, Inc.
X */
X
X#define RPC_MSG_VERSION		((u_long) 2)
X#define RPC_SERVICE_PORT	((u_short) 2048)
X
X/*
X * Bottom up definition of an rpc message.
X * NOTE: call and reply use the same overall stuct but
X * different parts of unions within it.
X */
X
Xenum msg_type {
X	CALL=0,
X	REPLY=1
X};
X
Xenum reply_stat {
X	MSG_ACCEPTED=0,
X	MSG_DENIED=1
X};
X
Xenum accept_stat {
X	SUCCESS=0,
X	PROG_UNAVAIL=1,
X	PROG_MISMATCH=2,
X	PROC_UNAVAIL=3,
X	GARBAGE_ARGS=4,
X	SYSTEM_ERR=5
X};
X
Xenum reject_stat {
X	RPC_MISMATCH=0,
X	AUTH_ERROR=1
X};
X
X/*
X * Reply part of an rpc exchange
X */
X
X/*
X * Reply to an rpc request that was accepted by the server.
X * Note: there could be an error even though the request was
X * accepted.
X */
Xstruct accepted_reply {
X	struct opaque_auth	ar_verf;
X	enum accept_stat	ar_stat;
X	union {
X		struct {
X			u_long	low;
X			u_long	high;
X		} AR_versions;
X		struct {
X			caddr_t	where;
X			xdrproc_t proc;
X		} AR_results;
X		/* and many other null cases */
X	} ru;
X#define	ar_results	ru.AR_results
X#define	ar_vers		ru.AR_versions
X};
X
X/*
X * Reply to an rpc request that was rejected by the server.
X */
Xstruct rejected_reply {
X	enum reject_stat rj_stat;
X	union {
X		struct {
X			u_long low;
X			u_long high;
X		} RJ_versions;
X		enum auth_stat RJ_why;  /* why authentication did not work */
X	} ru;
X#define	rj_vers	ru.RJ_versions
X#define	rj_why	ru.RJ_why
X};
X
X/*
X * Body of a reply to an rpc request.
X */
Xstruct reply_body {
X	enum reply_stat rp_stat;
X	union {
X		struct accepted_reply RP_ar;
X		struct rejected_reply RP_dr;
X	} ru;
X#define	rp_acpt	ru.RP_ar
X#define	rp_rjct	ru.RP_dr
X};
X
X/*
X * Body of an rpc request call.
X */
Xstruct call_body {
X	u_long cb_rpcvers;	/* must be equal to two */
X	u_long cb_prog;
X	u_long cb_vers;
X	u_long cb_proc;
X	struct opaque_auth cb_cred;
X	struct opaque_auth cb_verf; /* protocol specific - provided by client */
X};
X
X/*
X * The rpc message
X */
Xstruct rpc_msg {
X	u_long			rm_xid;
X	enum msg_type		rm_direction;
X	union {
X		struct call_body RM_cmb;
X		struct reply_body RM_rmb;
X	} ru;
X#define	rm_call		ru.RM_cmb
X#define	rm_reply	ru.RM_rmb
X};
X#define	acpted_rply	ru.RM_rmb.ru.RP_ar
X#define	rjcted_rply	ru.RM_rmb.ru.RP_dr
X
X
X/*
X * XDR routine to handle a rpc message.
X * xdr_callmsg(xdrs, cmsg)
X * 	XDR *xdrs;
X * 	struct rpc_msg *cmsg;
X */
Xextern bool_t	xdr_callmsg();
X
X/*
X * XDR routine to pre-serialize the static part of a rpc message.
X * xdr_callhdr(xdrs, cmsg)
X * 	XDR *xdrs;
X * 	struct rpc_msg *cmsg;
X */
Xextern bool_t	xdr_callhdr();
X
X/*
X * XDR routine to handle a rpc reply.
X * xdr_replymsg(xdrs, rmsg)
X * 	XDR *xdrs;
X * 	struct rpc_msg *rmsg;
X */
Xextern bool_t	xdr_replymsg();
X
X/*
X * Fills in the error part of a reply message.
X * _seterr_reply(msg, error)
X * 	struct rpc_msg *msg;
X * 	struct rpc_err *error;
X */
Xextern void	_seterr_reply();
SHAR_EOF
if test 4134 -ne "`wc -c < 'rpc/rpclib/rpc_msg.h'`"
then
	echo shar: "error transmitting 'rpc/rpclib/rpc_msg.h'" '(should have been 4134 characters)'
fi
chmod 444 'rpc/rpclib/rpc_msg.h'
fi
echo shar: "extracting 'rpc/rpclib/svc.h'" '(8333 characters)'
if test -f 'rpc/rpclib/svc.h'
then
	echo shar: "will not over-write existing file 'rpc/rpclib/svc.h'"
else
sed 's/^X//' << \SHAR_EOF > 'rpc/rpclib/svc.h'
X/*
X * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
X * unrestricted use provided that this legend is included on all tape
X * media and as a part of the software program in whole or part.  Users
X * may copy or modify Sun RPC without charge, but are not authorized
X * to license or distribute it to anyone else except as part of a product or
X * program developed by the user.
X * 
X * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
X * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
X * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
X * 
X * Sun RPC is provided with no support and without any obligation on the
X * part of Sun Microsystems, Inc. to assist in its use, correction,
X * modification or enhancement.
X * 
X * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
X * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
X * OR ANY PART THEREOF.
X * 
X * In no event will Sun Microsystems, Inc. be liable for any lost revenue
X * or profits or other special, indirect and consequential damages, even if
X * Sun has been advised of the possibility of such damages.
X * 
X * Sun Microsystems, Inc.
X * 2550 Garcia Avenue
X * Mountain View, California  94043
X */
X/*      @(#)svc.h 1.1 86/02/03 SMI      *
X
X/*
X * svc.h, Server-side remote procedure call interface.
X *
X * Copyright (C) 1984, Sun Microsystems, Inc.
X */
X
X/*
X * This interface must manage two items concerning remote procedure calling:
X *
X * 1) An arbitrary number of transport connections upon which rpc requests
X * are received.  The two most notable transports are TCP and UDP;  they are
X * created and registered by routines in svc_tcp.c and svc_udp.c, respectively;
X * they in turn call xprt_register and xprt_unregister.
X *
X * 2) An arbitrary number of locally registered services.  Services are
X * described by the following four data: program number, version number,
X * "service dispatch" function, a transport handle, and a boolean that
X * indicates whether or not the exported program should be registered with a
X * local binder service;  if true the program's number and version and the
X * port number from the transport handle are registered with the binder.
X * These data are registered with the rpc svc system via svc_register.
X *
X * A service's dispatch function is called whenever an rpc request comes in
X * on a transport.  The request's program and version numbers must match
X * those of the registered service.  The dispatch function is passed two
X * parameters, struct svc_req * and SVCXPRT *, defined below.
X */
X
Xenum xprt_stat {
X	XPRT_DIED,
X	XPRT_MOREREQS,
X	XPRT_IDLE
X};
X
X/*
X * Server side transport handle
X */
Xtypedef struct {
X	int		xp_sock;
X	u_short		xp_port;	 /* associated port number */
X	struct xp_ops {
X	    bool_t	(*xp_recv)();	 /* receive incomming requests */
X	    enum xprt_stat (*xp_stat)(); /* get transport status */
X	    bool_t	(*xp_getargs)(); /* get arguments */
X	    bool_t	(*xp_reply)();	 /* send reply */
X	    bool_t	(*xp_freeargs)();/* free mem allocated for args */
X	    void	(*xp_destroy)(); /* destroy this struct */
X	} *xp_ops;
X	int		xp_addrlen;	 /* length of remote address */
X	struct sockaddr_in xp_raddr;	 /* remote address */
X	struct opaque_auth xp_verf;	 /* raw response verifier */
X	caddr_t		xp_p1;		 /* private */
X	caddr_t		xp_p2;		 /* private */
X} SVCXPRT;
X
X/*
X *  Approved way of getting address of caller
X */
X#define svc_getcaller(x) (&(x)->xp_raddr)
X
X/*
X * Operations defined on an SVCXPRT handle
X *
X * SVCXPRT		*xprt;
X * struct rpc_msg	*msg;
X * xdrproc_t		 xargs;
X * caddr_t		 argsp;
X */
X#define SVC_RECV(xprt, msg)				\
X	(*(xprt)->xp_ops->xp_recv)((xprt), (msg))
X#define svc_recv(xprt, msg)				\
X	(*(xprt)->xp_ops->xp_recv)((xprt), (msg))
X
X#define SVC_STAT(xprt)					\
X	(*(xprt)->xp_ops->xp_stat)(xprt)
X#define svc_stat(xprt)					\
X	(*(xprt)->xp_ops->xp_stat)(xprt)
X
X#define SVC_GETARGS(xprt, xargs, argsp)			\
X	(*(xprt)->xp_ops->xp_getargs)((xprt), (xargs), (argsp))
X#define svc_getargs(xprt, xargs, argsp)			\
X	(*(xprt)->xp_ops->xp_getargs)((xprt), (xargs), (argsp))
X
X#define SVC_REPLY(xprt, msg)				\
X	(*(xprt)->xp_ops->xp_reply) ((xprt), (msg))
X#define svc_reply(xprt, msg)				\
X	(*(xprt)->xp_ops->xp_reply) ((xprt), (msg))
X
X#define SVC_FREEARGS(xprt, xargs, argsp)		\
X	(*(xprt)->xp_ops->xp_freeargs)((xprt), (xargs), (argsp))
X#define svc_freeargs(xprt, xargs, argsp)		\
X	(*(xprt)->xp_ops->xp_freeargs)((xprt), (xargs), (argsp))
X
X#define SVC_DESTROY(xprt)				\
X	(*(xprt)->xp_ops->xp_destroy)(xprt)
X#define svc_destroy(xprt)				\
X	(*(xprt)->xp_ops->xp_destroy)(xprt)
X
X
X/*
X * Service request
X */
Xstruct svc_req {
X	u_long		rq_prog;	/* service program number */
X	u_long		rq_vers;	/* service protocol version */
X	u_long		rq_proc;	/* the desired procedure */
X	struct opaque_auth rq_cred;	/* raw creds from the wire */
X	caddr_t		rq_clntcred;	/* read only cooked cred */
X	SVCXPRT	*rq_xprt;		/* associated transport */
X};
X
X
X/*
X * Service registration
X *
X * svc_register(xprt, prog, vers, dispatch, protocol)
X *	SVCXPRT *xprt;
X *	u_long prog;
X *	u_long vers;
X *	void (*dispatch)();
X *	int protocol;  /* like TCP or UDP, zero means do not register 
X */
Xextern bool_t	svc_register();
X
X/*
X * Service un-registration
X *
X * svc_unregister(prog, vers)
X *	u_long prog;
X *	u_long vers;
X */
Xextern void	svc_unregister();
X
X/*
X * Transport registration.
X *
X * xprt_register(xprt)
X *	SVCXPRT *xprt;
X */
Xextern void	xprt_register();
X
X/*
X * Transport un-register
X *
X * xprt_unregister(xprt)
X *	SVCXPRT *xprt;
X */
Xextern void	xprt_unregister();
X
X
X/*
X * When the service routine is called, it must first check to see if it
X * knows about the procedure;  if not, it should call svcerr_noproc
X * and return.  If so, it should deserialize its arguments via 
X * SVC_GETARGS (defined above).  If the deserialization does not work,
X * svcerr_decode should be called followed by a return.  Successful
X * decoding of the arguments should be followed the execution of the
X * procedure's code and a call to svc_sendreply.
X *
X * Also, if the service refuses to execute the procedure due to too-
X * weak authentication parameters, svcerr_weakauth should be called.
X * Note: do not confuse access-control failure with weak authentication!
X *
X * NB: In pure implementations of rpc, the caller always waits for a reply
X * msg.  This message is sent when svc_sendreply is called.  
X * Therefore pure service implementations should always call
X * svc_sendreply even if the function logically returns void;  use
X * xdr.h - xdr_void for the xdr routine.  HOWEVER, tcp based rpc allows
X * for the abuse of pure rpc via batched calling or pipelining.  In the
X * case of a batched call, svc_sendreply should NOT be called since
X * this would send a return message, which is what batching tries to avoid.
X * It is the service/protocol writer's responsibility to know which calls are
X * batched and which are not.  Warning: responding to batch calls may
X * deadlock the caller and server processes!
X */
X
Xextern bool_t  svc_sendreply();
Xextern void	svcerr_decode();
Xextern void	svcerr_weakauth();
Xextern void	svcerr_noproc();
X
X/*
X * Lowest level dispatching -OR- who owns this process anyway.
X * Somebody has to wait for incoming requests and then call the correct
X * service routine.  The routine svc_run does infinite waiting; i.e.,
X * svc_run never returns.
X * Since another (co-existant) package may wish to selectively wait for
X * incoming calls or other events outside of the rpc architecture, the
X * routine svc_getreq is provided.  It must be passed readfds, the
X * "in-place" results of a select system call (see select, section 2).
X */
X
X/* dynamic; must be inspected before each call to select */
Xextern int svc_fds;
X
X/*
X * a small program implemented by the svc_rpc implementation itself;
X * also see clnt.h for protocol numbers.
X */
Xextern void rpctest_service();
X
Xextern void	svc_getreq();
Xextern void	svc_run(); 	 /* never returns */
X
X/*
X * Socket to use on svcxxx_create call to get default socket
X */
X#define	RPC_ANYSOCK	-1
X
X/*
X * These are the existing service side transport implementations
X */
X
X/*
X * Memory based rpc for testing and timing.
X */
Xextern SVCXPRT *svcraw_create();
X
X/*
X * Udp based rpc.
X */
Xextern SVCXPRT *svcudp_create();
Xextern SVCXPRT *svcudp_bufcreate();
X
X/*
X * Tcp based rpc.
X */
Xextern SVCXPRT *svctcp_create();
X
SHAR_EOF
if test 8333 -ne "`wc -c < 'rpc/rpclib/svc.h'`"
then
	echo shar: "error transmitting 'rpc/rpclib/svc.h'" '(should have been 8333 characters)'
fi
chmod 444 'rpc/rpclib/svc.h'
fi
echo shar: "extracting 'rpc/rpclib/svc_auth.h'" '(1503 characters)'
if test -f 'rpc/rpclib/svc_auth.h'
then
	echo shar: "will not over-write existing file 'rpc/rpclib/svc_auth.h'"
else
sed 's/^X//' << \SHAR_EOF > 'rpc/rpclib/svc_auth.h'
X/*
X * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
X * unrestricted use provided that this legend is included on all tape
X * media and as a part of the software program in whole or part.  Users
X * may copy or modify Sun RPC without charge, but are not authorized
X * to license or distribute it to anyone else except as part of a product or
X * program developed by the user.
X * 
X * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
X * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
X * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
X * 
X * Sun RPC is provided with no support and without any obligation on the
X * part of Sun Microsystems, Inc. to assist in its use, correction,
X * modification or enhancement.
X * 
X * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
X * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
X * OR ANY PART THEREOF.
X * 
X * In no event will Sun Microsystems, Inc. be liable for any lost revenue
X * or profits or other special, indirect and consequential damages, even if
X * Sun has been advised of the possibility of such damages.
X * 
X * Sun Microsystems, Inc.
X * 2550 Garcia Avenue
X * Mountain View, California  94043
X */
X/*      @(#)svc_auth.h 1.1 86/02/03 SMI      */
X
X/*
X * svc_auth.h, Service side of rpc authentication.
X * 
X * Copyright (C) 1984, Sun Microsystems, Inc.
X */
X
X
X/*
X * Server side authenticator
X */
Xextern enum auth_stat _authenticate();
SHAR_EOF
if test 1503 -ne "`wc -c < 'rpc/rpclib/svc_auth.h'`"
then
	echo shar: "error transmitting 'rpc/rpclib/svc_auth.h'" '(should have been 1503 characters)'
fi
chmod 444 'rpc/rpclib/svc_auth.h'
fi
echo shar: "extracting 'rpc/rpclib/types.h'" '(1590 characters)'
if test -f 'rpc/rpclib/types.h'
then
	echo shar: "will not over-write existing file 'rpc/rpclib/types.h'"
else
sed 's/^X//' << \SHAR_EOF > 'rpc/rpclib/types.h'
X/*
X * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
X * unrestricted use provided that this legend is included on all tape
X * media and as a part of the software program in whole or part.  Users
X * may copy or modify Sun RPC without charge, but are not authorized
X * to license or distribute it to anyone else except as part of a product or
X * program developed by the user.
X * 
X * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
X * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
X * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
X * 
X * Sun RPC is provided with no support and without any obligation on the
X * part of Sun Microsystems, Inc. to assist in its use, correction,
X * modification or enhancement.
X * 
X * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
X * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
X * OR ANY PART THEREOF.
X * 
X * In no event will Sun Microsystems, Inc. be liable for any lost revenue
X * or profits or other special, indirect and consequential damages, even if
X * Sun has been advised of the possibility of such damages.
X * 
X * Sun Microsystems, Inc.
X * 2550 Garcia Avenue
X * Mountain View, California  94043
X */
X/*      @(#)types.h 1.1 86/02/03 SMI      */
X
X/*
X * Rpc additions to <sys/types.h>
X */
X
X#define	bool_t	int
X#define	enum_t	int
X#define	FALSE	(0)
X#define	TRUE	(1)
X#define __dontcare__	-1
X
X#define mem_alloc(bsize)	malloc(bsize)
X#define mem_free(ptr, bsize)	free(ptr)
X#ifndef major		/* ouch! */
X#include <sys/types.h>
X#endif
SHAR_EOF
if test 1590 -ne "`wc -c < 'rpc/rpclib/types.h'`"
then
	echo shar: "error transmitting 'rpc/rpclib/types.h'" '(should have been 1590 characters)'
fi
chmod 444 'rpc/rpclib/types.h'
fi
echo shar: "extracting 'rpc/rpclib/xdr.h'" '(8866 characters)'
if test -f 'rpc/rpclib/xdr.h'
then
	echo shar: "will not over-write existing file 'rpc/rpclib/xdr.h'"
else
sed 's/^X//' << \SHAR_EOF > 'rpc/rpclib/xdr.h'
X/*
X * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
X * unrestricted use provided that this legend is included on all tape
X * media and as a part of the software program in whole or part.  Users
X * may copy or modify Sun RPC without charge, but are not authorized
X * to license or distribute it to anyone else except as part of a product or
X * program developed by the user.
X * 
X * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
X * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
X * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
X * 
X * Sun RPC is provided with no support and without any obligation on the
X * part of Sun Microsystems, Inc. to assist in its use, correction,
X * modification or enhancement.
X * 
X * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
X * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
X * OR ANY PART THEREOF.
X * 
X * In no event will Sun Microsystems, Inc. be liable for any lost revenue
X * or profits or other special, indirect and consequential damages, even if
X * Sun has been advised of the possibility of such damages.
X * 
X * Sun Microsystems, Inc.
X * 2550 Garcia Avenue
X * Mountain View, California  94043
X */
X/*      @(#)xdr.h 1.1 86/02/03 SMI      */
X
X/*
X * xdr.h, External Data Representation Serialization Routines.
X *
X * Copyright (C) 1984, Sun Microsystems, Inc.
X */
X
X/*
X * XDR provides a conventional way for converting between C data
X * types and an external bit-string representation.  Library supplied
X * routines provide for the conversion on built-in C data types.  These
X * routines and utility routines defined here are used to help implement
X * a type encode/decode routine for each user-defined type.
X *
X * Each data type provides a single procedure which takes two arguments:
X *
X *	bool_t
X *	xdrproc(xdrs, argresp)
X *		XDR *xdrs;
X *		<type> *argresp;
X *
X * xdrs is an instance of a XDR handle, to which or from which the data
X * type is to be converted.  argresp is a pointer to the structure to be
X * converted.  The XDR handle contains an operation field which indicates
X * which of the operations (ENCODE, DECODE * or FREE) is to be performed.
X *
X * XDR_DECODE may allocate space if the pointer argresp is null.  This
X * data can be freed with the XDR_FREE operation.
X *
X * We write only one procedure per data type to make it easy
X * to keep the encode and decode procedures for a data type consistent.
X * In many cases the same code performs all operations on a user defined type,
X * because all the hard work is done in the component type routines.
X * decode as a series of calls on the nested data types.
X */
X
X/*
X * Xdr operations.  XDR_ENCODE causes the type to be encoded into the
X * stream.  XDR_DECODE causes the type to be extracted from the stream.
X * XDR_FREE can be used to release the space allocated by an XDR_DECODE
X * request.
X */
Xenum xdr_op {
X	XDR_ENCODE=0,
X	XDR_DECODE=1,
X	XDR_FREE=2
X};
X
X/*
X * This is the number of bytes per unit of external data.
X */
X#define BYTES_PER_XDR_UNIT	(4)
X
X/*
X * A xdrproc_t exists for each data type which is to be encoded or decoded.
X *
X * The second argument to the xdrproc_t is a pointer to an opaque pointer.
X * The opaque pointer generally points to a structure of the data type
X * to be decoded.  If this pointer is 0, then the type routines should
X * allocate dynamic storage of the appropriate size and return it.
X * bool_t	(*xdrproc_t)(XDR *, caddr_t *);
X */
Xtypedef	bool_t (*xdrproc_t)();
X
X/*
X * The XDR handle.
X * Contains operation which is being applied to the stream,
X * an operations vector for the paticular implementation (e.g. see xdr_mem.c),
X * and two private fields for the use of the particular impelementation.
X */
Xtypedef struct {
X	enum xdr_op	x_op;		/* operation; fast additional param */
X	struct xdr_ops {
X		bool_t	(*x_getlong)();	/* get a long from underlying stream */
X		bool_t	(*x_putlong)();	/* put a long to " */
X		bool_t	(*x_getbytes)();/* get some bytes from " */
X		bool_t	(*x_putbytes)();/* put some bytes to " */
X		u_int	(*x_getpostn)();/* returns bytes off from beginning */
X		bool_t  (*x_setpostn)();/* lets you reposition the stream */
X		long *	(*x_inline)();	/* buf quick ptr to buffered data */
X		void	(*x_destroy)();	/* free privates of this xdr_stream */
X	} *x_ops;
X	caddr_t 	x_public;	/* users' data */
X	caddr_t		x_private;	/* pointer to private data */
X	caddr_t 	x_base;		/* private used for position info */
X	int		x_handy;	/* extra private word */
X} XDR;
X
X/*
X * Operations defined on a XDR handle
X *
X * XDR		*xdrs;
X * long		*longp;
X * caddr_t	 addr;
X * u_int	 len;
X * u_int	 pos;
X */
X#define XDR_GETLONG(xdrs, longp)			\
X	(*(xdrs)->x_ops->x_getlong)(xdrs, longp)
X#define xdr_getlong(xdrs, longp)			\
X	(*(xdrs)->x_ops->x_getlong)(xdrs, longp)
X
X#define XDR_PUTLONG(xdrs, longp)			\
X	(*(xdrs)->x_ops->x_putlong)(xdrs, longp)
X#define xdr_putlong(xdrs, longp)			\
X	(*(xdrs)->x_ops->x_putlong)(xdrs, longp)
X
X#define XDR_GETBYTES(xdrs, addr, len)			\
X	(*(xdrs)->x_ops->x_getbytes)(xdrs, addr, len)
X#define xdr_getbytes(xdrs, addr, len)			\
X	(*(xdrs)->x_ops->x_getbytes)(xdrs, addr, len)
X
X#define XDR_PUTBYTES(xdrs, addr, len)			\
X	(*(xdrs)->x_ops->x_putbytes)(xdrs, addr, len)
X#define xdr_putbytes(xdrs, addr, len)			\
X	(*(xdrs)->x_ops->x_putbytes)(xdrs, addr, len)
X
X#define XDR_GETPOS(xdrs)				\
X	(*(xdrs)->x_ops->x_getpostn)(xdrs)
X#define xdr_getpos(xdrs)				\
X	(*(xdrs)->x_ops->x_getpostn)(xdrs)
X
X#define XDR_SETPOS(xdrs, pos)				\
X	(*(xdrs)->x_ops->x_setpostn)(xdrs, pos)
X#define xdr_setpos(xdrs, pos)				\
X	(*(xdrs)->x_ops->x_setpostn)(xdrs, pos)
X
X#define	XDR_INLINE(xdrs, len)				\
X	(*(xdrs)->x_ops->x_inline)(xdrs, len)
X#define	xdr_inline(xdrs, len)				\
X	(*(xdrs)->x_ops->x_inline)(xdrs, len)
X
X#define	XDR_DESTROY(xdrs)				\
X	if ((xdrs)->x_ops->x_destroy) 			\
X		(*(xdrs)->x_ops->x_destroy)(xdrs)
X#define	xdr_destroy(xdrs)				\
X	if ((xdrs)->x_ops->x_destroy) 			\
X		(*(xdrs)->x_ops->x_destroy)(xdrs)
X
X/*
X * Support struct for discriminated unions.
X * You create an array of xdrdiscrim structures, terminated with
X * a entry with a null procedure pointer.  The xdr_union routine gets
X * the discriminant value and then searches the array of structures
X * for a matching value.  If a match is found the associated xdr routine
X * is called to handle that part of the union.  If there is
X * no match, then a default routine may be called.
X * If there is no match and no default routine it is an error.
X */
X#define NULL_xdrproc_t ((xdrproc_t)0)
Xstruct xdr_discrim {
X	int	value;
X	xdrproc_t proc;
X};
X
X/*
X * In-line routines for fast encode/decode of primitve data types.
X * Caveat emptor: these use single memory cycles to get the
X * data from the underlying buffer, and will fail to operate
X * properly if the data is not aligned.  The standard way to use these
X * is to say:
X *	if ((buf = XDR_INLINE(xdrs, count)) == NULL)
X *		return (FALSE);
X *	<<< macro calls >>>
X * where ``count'' is the number of bytes of data occupied
X * by the primitive data types.
X *
X * N.B. and frozen for all time: each data type here uses 4 bytes
X * of external representation.
X */
X#define IXDR_GET_LONG(buf)		ntohl(*buf++)
X#define IXDR_PUT_LONG(buf, v)		(*buf++ = htonl(v))
X
X#define IXDR_GET_BOOL(buf)		((bool_t)IXDR_GET_LONG(buf))
X#define IXDR_GET_ENUM(buf, t)		((t)IXDR_GET_LONG(buf))
X#define IXDR_GET_U_LONG(buf)		((u_long)IXDR_GET_LONG(buf))
X#define IXDR_GET_SHORT(buf)		((short)IXDR_GET_LONG(buf))
X#define IXDR_GET_U_SHORT(buf)		((u_short)IXDR_GET_LONG(buf))
X
X#define IXDR_PUT_BOOL(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
X#define IXDR_PUT_ENUM(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
X#define IXDR_PUT_U_LONG(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
X#define IXDR_PUT_SHORT(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
X#define IXDR_PUT_U_SHORT(buf, v)	IXDR_PUT_LONG((buf), ((long)(v)))
X
X/*
X * These are the "generic" xdr routines.
X */
Xextern bool_t	xdr_void();
Xextern bool_t	xdr_int();
Xextern bool_t	xdr_u_int();
Xextern bool_t	xdr_long();
Xextern bool_t	xdr_u_long();
Xextern bool_t	xdr_short();
Xextern bool_t	xdr_u_short();
Xextern bool_t	xdr_bool();
Xextern bool_t	xdr_enum();
Xextern bool_t	xdr_array();
Xextern bool_t	xdr_bytes();
Xextern bool_t	xdr_opaque();
Xextern bool_t	xdr_string();
Xextern bool_t	xdr_union();
Xextern bool_t	xdr_float();
Xextern bool_t	xdr_double();
Xextern bool_t	xdr_reference();
Xextern bool_t	xdr_wrapstring();
X
X/*
X * These are the public routines for the various implementations of
X * xdr streams.
X */
Xextern void   xdrmem_create();		/* XDR using memory buffers */
Xextern void   xdrstdio_create();	/* XDR using stdio library */
Xextern void   xdrrec_create();		/* XDR pseudo records for tcp */
Xextern bool_t xdrrec_endofrecord();	/* make end of xdr record */
Xextern bool_t xdrrec_skiprecord();	/* move to begining of next record */
Xextern bool_t xdrrec_eof();		/* true iff no more input */
SHAR_EOF
if test 8866 -ne "`wc -c < 'rpc/rpclib/xdr.h'`"
then
	echo shar: "error transmitting 'rpc/rpclib/xdr.h'" '(should have been 8866 characters)'
fi
chmod 444 'rpc/rpclib/xdr.h'
fi
exit 0
#	End of shell archive
