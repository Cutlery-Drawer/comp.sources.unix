Subject: v06i078:  MicroEmacs, Version 3.7 (uEmacs3.7), Part08/12
Newsgroups: mod.sources
Approved: rs@mirror.UUCP

Submitted by: ihnp4!pur-ee!pur-phy!duncan!lawrence
Mod.sources: Volume 6, Issue 78
Archive-name: uEmacs3.7/Part08

[  This is the latest revision of one of two programs named "MicroEmacs";
   when discussing these on the net, or in contacting the authors, make
   sure to mention the version number -- in this case 3.7 -- as that is
   the easiest way to distinguish between them.  Daniel will be posting
   uuencoded executables in net.micro.pc and net.micro.amiga; the file
   'readme' contains information on how to also get these from him
   directly.   --r$ ]

echo extracting - main1.c
sed 's/^X//' > main1.c << 'FRIDAY_NIGHT'
X/*
X * This program is in public domain; written by Dave G. Conroy.
X * This file contains the main driving routine, and some keyboard processing
X * code, for the MicroEMACS screen editor.
X *
X * REVISION HISTORY:
X *
X * 1.0  Steve Wilhite, 30-Nov-85
X *      - Removed the old LK201 and VT100 logic. Added code to support the
X *        DEC Rainbow keyboard (which is a LK201 layout) using the the Level
X *        1 Console In ROM INT. See "rainbow.h" for the function key defs
X *      Steve Wilhite, 1-Dec-85
X *      - massive cleanup on code in display.c and search.c
X *
X * 2.0  George Jones, 12-Dec-85
X *      - Ported to Amiga.
X *
X * 3.0  Daniel Lawrence, 29-Dec-85
X *      - rebound keys/added new fast buffered I/O for AMIGA
X *	- added META- repeat commands
X *	- added reposition default to center screen (yeah!)
X *	- changed exit with modified buffers message
X *	- made filesave tell us what it is doing
X *	- changed search string entry to terminate with <ESC>
X *	  so we can use <NL> in search/replace strings
X *	- updated version number in mode line to 3.0
X *	12-Jan-86
X *	- Added code to reconize the Search/replace functions
X *	- Added code to perform search/replace & query functions
X *	14-Jan-86
X *	- moved search logic to separate function in search.c
X *	- added replace and query replace functions
X *	- separated out control key expansions to be used by others in search.c
X *	15-Jan-86
X *	- changed "visiting" to finding
X *	- changed yes/no responces to not need return
X *	- cleaned up various messages
X *	16-jan-86
X *	- fixed spurious spawn message in MSDOS
X *	- added ^X-S synonime to save command
X *	- moved escape to shell to ^X-C
X *	21-jan-86
X *	- added code to suspend shell under BSD
X *	22-jan-86
X *	- added function key support (SPEC) under MSDOS
X *	- Abort now prints [Aborted] on message line
X *	23-jan-86
X *	- Added modes and commends to set/unset them
X *	24-jan-86
X *	- Added Goto Line command
X *	- added Rename Buffer command
X *	28-jan-86
X *	- added goto begining and end of paragraph commands (META-P/META-N)
X *	- re-wrote kdelete to use realloc. gained MUCH speed here when
X *	  doing large wipes both on UNIX and MSDOS. Changed kill buffer
X *	  allocation block size from 256 bytes to 1 k
X *	29-jan-86
X *	- moved extern function declarations to efunc.h
X *	- made name[] name binding table
X *	30-jan-86
X *	- fixed Previous/Next paragraph command not to wrap around EOF
X *	- added Fill Paragraph command (META-Q)
X *	4-feb-86
X *	- added code to properly display long lines, scrolling them right
X *	  to left
X *	5-feb-85
X *	- rewrote code to right/left scroll...much better
X *	- added shifted arror keys on IBMPC
X *	6-feb-85
X *	- add option to allow forword-word to jump to begining of
X *	  next word instead of end of current one. This is different from
X *	  other emacs' but can be configured off in estruct.h
X *	- added VIEW mode to allow a buffer to be read only
X *	   (-v switch on command line will activate this)
X *	- changed quick exit to write out ALL changed buffers!!!
X *	  MAKE SURE YOU KNOW THIS WHEN META-Zing
X *	10-feb-86
X *	- added handling of lines longer than allowed on file read in
X *	  (they wrap on additional lines)
X *	- made having space clear the message line and NOT insert itself
X *	  a configuration option in ed.h
X *	11-feb-86
X *	- added Describe-command and Help commands.
X *	13-feb-86
X *	- added View file command (^X ^V) and finished HELP command
X *	14-feb-86
X *	- added option to let main loop skip update if type ahead commands
X *	   are queued up
X *	16-feb-86
X *	- added Insert File command
X *	17-feb-86
X *	- added scroll next window up/down commands
X *	18-feb-86
X *	- added CMODE indentation
X *	- re-arranged header files to standerdize extern and global
X *	  definitions
X *	- changed version number to 3.2
X *	- added numeric arguments to search, reverse search and
X *	  search and replace
X *	24-feb-86
X *	- added Bind To Key function (^C for now) to allow the user
X *	  to change his command keys
X *	- added Unbind key function (M-^C for now)
X *	- added execute named command to execute unbound commands (M-X)
X *	- added describe bindings command (not bound)
X *	- changed version number to 3.3
X *	25-feb-86
X *	- scrapped CERROR mode (too many compilers)
X *	- added EXACT mode for case sensitive searchers
X *	26-feb-86
X *	- added command completion on execute named command and
X *	  all routined grabbing a command name
X *	- adding execute-command-line command and its support functions
X *	  (in preporation for sourcing files)
X *	- added Execute Buffer command
X *	27-feb-86
X *	- added execute(source) file command and added code to automatically
X *	  execute emacs.rc (or .emacsrc on UNIX) before initial read in
X *	- changed version number to 3.4
X *	4-mar-86
X *	- changed word delete to be consistant with word move (it gets
X *	  rid of the inter word space now) This is configurable with the
X *	  NFWORD symbol in estruct.h
X *	- added B_ACTIVE entry to the buffer table. Let emacs read multiple
X *	  file names from the command line and only read them in as needed
X *	5-mar-85
X *	- rewrote command line parser to get rid of my patchy code
X *	- changed version number to 3.5
X *	1-apr-86
X *	- added support for Aztec C 3.20e under MSDOS
X *	- fixed bug in mlwrite on ADM3's and thier ilk under V7
X *	- added insertion of pounds in column one under CMODE
X *	- changed version number to 3.6
X *	3-apr-86
X *	- added next-buffer command (^X-X)
X *	5-apr-86
X *	- added kill paragraph command (M-^W)
X *	- changed fill-paragraph to leave 2 spaces after a period at the
X *	  end of a word.
X *	- added OVERWRITE mode
X *	7-apr-86
X *	- fixed overwrite mode to handle tabs
X *	8-apr-86
X *	- added add/delete global mode (<ESC>M & <ESC> ^M) commands
X *	9-apr-86
X *	- added insert space command
X *	- moved bindings around		^C	insert space
X *					M-K	bind-to-key
X *					INSERT	insert space
X *					DELETE	forwdel
X *	- added hunt forward and hunt reverse commands
X *	10-apr-86
X *	- fixed bug in DOBUF with non-terminated command string
X *	15-apr-86
X *	- fixed tab expansion bug in DISPLAY which hung the AMIGA
X *	  (send in by Dawn Banks)
X *	- fixed curcol problen if forwline/backline during keyboard
X *	  macro execution (sent in by Ernst Christen)
X *	- added AMIGA function/cursor key support
X *	- fixed nonterminating <NL> replacement bug
X *	- fixed word wrapping problems
X *	16-apr-86
X *	- updated documentation and froze development for 3.6 net release
X *	23-apr-86	version 3.6a
X *	- added forground and background colors. Setable with the
X *	  add mode commands for the moment
X *	24-apr-86
X *	- added command to pipe CLI output to a buffer
X *	25-apr-86
X *	- added Dana Hoggat's code to replace lattice's sick system()
X *	  function, now we no longer care what the switchar is.
X *	- cleaned up the positioning on several of the spawing commands
X *	26-apr-86
X *	- added a output flush in vttidy(). Unix really appreciates this.
X *	- added filter-buffer (^X#) command to send a buffer through
X *	  a dos filter
X *	- made automatic CMODE on .c and .h file compilation dependant
X *	  in estruct.h
X *	1-may-86
X *	- optimized some code in update(). It certainly need a lot more.
X *	- added AZTEC profiling capabilities. These are conditional on
X *	  the APROF symbol in estruct.h
X *	2-may-86
X *	- added (u)ndo command in query-replace. undoes last repalce.
X *	6-may-86
X *	- re-orginized and wrote the update() function in display.c
X *	  now my color hacks are in the right places and the code can be
X *	  understood.
X *	[Released version 3.6f for BETA test sites]
X *	8-may-86
X *	- fixed bug in new display routine to wrap cursor on extended
X *	  lines at the right time
X *	- modified the buffer-position command to give reasonable info
X *	9-may-86
X *	- improved the word wrap algorithm as not to discard non-space
X *	  delimiters. The backscan now looks for white space rather than
X *	  !inword().
X *	[Released version 3.6g to Krannert]
X *	10-may-86
X *	- Added IBMPC.C an IBM-PC specific display driver. This makes paging
X *	  4-6 times faster. Also made some conditional changes to DISPLAY.C
X *	  to eliminate the pscreen[] if using the PC driver.
X *	[changed version number to 3.6i]
X *	12-may-86
X *	- added delete-window (^X 0) command to dispose of a single window
X *	- fixed problem with multiple prefixes from a command line which
X *	  was reported by John Gamble
X *	14-may-86
X *	- Added AZTEC support for the IBMPC display driver. Had to
X *	  readjust some includes and defines for this.
X *	- fixed bug in delete-window.
X *	- fixed some bizarre behavior with the cursor after coming back
X *	  from spawn calls.
X *	[changed version number to 3.7 Freezing development for net release]
X *	15-may-86
X *	- (that didn't last long...) Added execute-macro-(1 thru 20) commands
X *	  to execute macro buffers (named "[Macro nn]")
X *	- changed BFTEMP to BFINVS and cleaned up treatment of invisable
X *	  buffers.
X *	16-may-86
X *	- added store-macro (unbound) to store any executed command lines to
X *	  macro buffer.
X *	- added clear-message-line (unbound) command to do just that
X *	- added resize-window command to change a window's size to the
X *	  specified argument
X *	- improved help's logic not to re-read the file if it was already
X *	  in a buffer
X *	- added MAGIC mode to all structures and command tables, but the
X *	  regular expression code that John Gamble is writting is not ready.
X *	18-may-86
X *	- added interactive prompt requests in command line execution. IE
X *	  while executing a macro, a parameter starting with an at sign (@)
X *	  causes emacs to prompt with the rest of the parameter and return
X *	  the resulting input as the value of the parameter.
X *	- added arguments to split-current-window to force the cursor into
X *	  the upper or lower window.
X *	20-may-86
X *	- added support for the Microsoft C compiler as per the changes
X *	  send in by Oliver Sharp
X *	- made some upgrades and fixes for VMS sent in by Guy Streeter
X *	21-may-86
X *	- fixed an AZTEC bug in ttgetc by clearing the upper byte
X *	- fixed buf in CMODE with #preprocesser input (bug fix submitted by
X *	  Willis of unknown path)
X *	- added support of alternative startup file ( @<filename> ) in
X *	  the command line
X *	- added ^Q quoting in interactive input (mlreplyt()).
X *	- added re-binding of meta-prefix and ctlx-prefix
X *	22-may-86
X *	- reorginize getkey routines to make more sense and let prefix
X *	  binding work properly.
X *	23-may-86
X *	- checked new code on BSD4.2 made a few fixes
X *	- added optional fence matching while in CMODE
X *	- added goto and search command line arguments by Mike Spitzer
X *	26-may-86
X *	- added parameter fetching from buffers
X *	27-may-86
X *	- fixed some HP150 bugs......
X *	31-may-86
X *	- Added Wang PC keyboard support from modifications by
X *	  Sid Shapiro @ Wang Institute
X *	- Fixed some reverse video bugs with code submitted by Peter Chubb
X *	- Fixed bug in nextbuffer reported by Dave Forslund
X *	- added system V support (USG) from Linwood Varney
X *	2-jun-86
X *	- changed defines to just define one unix define (for example,
X *	  just define BSD for Unix BSD 4.2)
X *	- Added Incremental search functions written by D. R. Banks
X *	  in file ISEARCH.C
X *	- added insert-string (unbound) command to help the macro
X *	  language out.
X *	- added unmark-buffer (M-~) command to turn off the current buffers
X *	  change flag
X *	- fixed nxtarg to truncate strings longer than asked for max length
X *	4-jun-86
X *	- added special characters in command line tokens. Tidle (~) is
X *	  the special leadin character for "nrtb".
X *	- Fixed bad ifdef in aztec code so it could look at HOME dir
X *	  for startup, help, and emacs.rc files
X *	6-jun-86
X *	- make delete word commands clear the kill buffer if not after another
X *	  kill command
X *	11-jun-86
X *	- made ~@ in string arguments pass as char(192) to nxtarg() so one can
X *	  quote @ at the begining of string arguments
X *	- changed buffer size vars in listbuffers() to long (for big files)
X *	- re-wrote buffer-position command to be much faster
X *	12-jun-86
X *	- added count-words (M-^C) command to count the words/chars and
X *	  lines in a region
X *	- changed regions so they could be larger than 65535 (short ->
X *	  long in the REGION structure)
X *	- changed ldelete() and all callers to use a long size. The kill
X *	  buffer will still have a problem >65535 that can not be solved
X *	  until I restructure it.
X *	- grouped paragraph commands and word count together under symbol
X *	  WORDPRO to allow them to be conditionally made (or not)
X *	13-jun-86
X *	- re-wrote kill buffer routines again. Now they support an unlimited
X *	  size kill buffer, and are (in theory) faster.
X *	- changed delete-next-word (M-D) to not eat the newline after a word,
X *	  instead it checks and eats a newline at the cursor.
X *	17-jun-85
X *	- added numeric argument to next/previous-window to access the nth
X *	  window from the top/bottom
X *	- added support for the data General 10 MSDOS machine
X *	- added save-window (unbound) and restore-window (unbound) commands
X *	  for the use of the menu script. Save-window remembers which window
X *	  is current, and restore-window returns the cursor to that window.
X *	20-jun-86
X *	- fixed a bug with the fence matching locking up near the begining
X *	of a buffer
X *	- added argument to update to selectivaly force a complete update
X *	- added update-screen (unbound) command so macros can force a
X *	  screen update
X *	21-jun-86
X *	- rearranged token() and nxtarg() calls so that command names and
X *	  repeat counts could also be prompted and fetched from buffers
X *	- added write-message (unbound) command to write out a message
X *	  on the message line (for macros)
X *	- changed ifdef's so that color modes are reconized as legal in
X *	  b/w version, and simply do nothing (allowing us to use the same
X *	  script files)
X */
X
X#include        <stdio.h>
X
X/* make global definitions not external */
X#define	maindef
X
X#include        "estruct.h"	/* global structures and defines */
X#include	"efunc.h"	/* function declarations and name table	*/
X#include	"edef.h"	/* global definitions */
X#include	"ebind.h"	/* default key bindings */
X
X#if     VMS
X#include        <ssdef.h>
X#define GOOD    (SS$_NORMAL)
X#endif
X
X#ifndef GOOD
X#define GOOD    0
X#endif
X
X#if	APROF	/* Declarations needed for AZTEC C profiling */
Xint _Corg();	/* first address of program */
Xint _Cend();	/* last address of program */
X
Xshort monbuf[NBUCK];	/* buffer for gather info */
X#endif
X
Xmain(argc, argv)
Xchar    *argv[];
X{
X        register int    c;
X        register int    f;
X        register int    n;
X        register int    mflag;
X	register BUFFER *bp;
X	register int	ffile;		/* first file flag */
X	register int	carg;		/* current arg to scan */
X	register int	startf;		/* startup executed flag */
X	int basec;			/* c stripped of meta character */
X	int viewflag;			/* are we starting in view mode? */
X        int gotoflag;                   /* do we need to goto a line at start? */
X        int gline;                      /* if so, what line? */
X        int searchflag;                 /* Do we need to search at start? */
X        char bname[NBUFN];		/* buffer name of file to read */
X
X#if	APROF
X	/* if we are doing AZTEC C profiling, start it up */
X	/*_intr_sp(18);	 set clock interupt for 60/second */
X	monitor(_Corg, _Cend, monbuf, NBUCK, 0);
X#endif
X
X	/* initialize the editor and process the command line arguments */
X        strcpy(bname, "main");	/* default buffer name */
X        vtinit();		/* Displays.            */
X        edinit(bname);		/* Buffers, windows.    */
X	viewflag = FALSE;	/* view mode defaults off in command line */
X	gotoflag = FALSE;	/* set to off to begin with */
X	searchflag = FALSE;	/* set to off to begin with */
X	ffile = TRUE;		/* no file to edit yet */
X	startf = FALSE;		/* startup file not executed yet */
X#if	COLOR
X	curwp->w_fcolor = gfcolor;		/* and set colors	*/
X	curwp->w_bcolor = gbcolor;
X#endif
X	
X	/* scan through the command line and get the files to edit */
X	for (carg = 1; carg < argc; ++carg) {
X		/* if its a switch, process it */
X		if (argv[carg][0] == '-') {
X			switch (argv[carg][1]) {
X				case 'v':	/* -v for View File */
X				case 'V':
X					viewflag = TRUE;
X					break;
X				case 'e':	/* -e for Edit file */
X				case 'E':
X					viewflag = FALSE;
X					break;
X				case 's':	/* -s for initial search string */
X				case 'S':
X					searchflag = TRUE;
X					strcpy(pat,&argv[carg][2]);
X					break;
X				case 'g':	/* -g for initial goto */
X				case 'G':	
X					gotoflag = TRUE;
X					gline = atoi(&argv[carg][2]);
X					break;
X				default:	/* unknown switch */
X					/* ignore this for now */
X					break;
X			}
X		} else 	/* check for a macro file */
X			if (argv[carg][0]== '@') {
X
X			if (startup(&argv[carg][1]) == TRUE)
X				startf = TRUE;	/* don't execute emacs.rc */
X
X		} else {	/* process a file name */
X			/* if we haven't run emacs.rc, do it now */
X			if (startf == FALSE) {
X				startup("");
X				startf = TRUE;
X			}
X
X			/* set up a buffer for this file */
X	                makename(bname, argv[carg]);
X
X			/* if this is the first file, read it in */
X			if (ffile) {
X				bp = curbp;
X				makename(bname, argv[carg]);
X				strcpy(bp->b_bname, bname);
X				strcpy(bp->b_fname, argv[carg]);
X				if (readin(argv[carg], (viewflag==FALSE))
X								== ABORT) {
X					strcpy(bp->b_bname, "main");
X					strcpy(bp->b_fname, "");
X				}
X				bp->b_dotp = bp->b_linep;
X				bp->b_doto = 0;
X				ffile = FALSE;
X			} else {
X				/* set this to inactive */
X				bp = bfind(bname, TRUE, 0);
X				strcpy(bp->b_fname, argv[carg]);
X				bp->b_active = FALSE;
X			}
X
X			/* set the view mode appropriatly */
X			if (viewflag)
X				bp->b_mode |= MDVIEW;
X		}
X	}
X
X	/* if invoked with nothing, run the startup file here */
X	if (startf == FALSE) {
X		startup("");
X		startf = TRUE;
X	}
X 
X        /* Deal with startup gotos and searches */
X 
X        if (gotoflag && searchflag) {
X        	update(FALSE);
X		mlwrite("[Can not search and goto at the same time!]");
X	}
X        else if (gotoflag) {
X                if (gotoline(NULL,gline) == FALSE) {
X                	update(FALSE);
X			mlwrite("[Bogus goto argument]");
X		}
X        } else if (searchflag) {
X                if (forscan(&pat[0], 2) == FALSE) {
X                	update(FALSE);
X			mlwrite("Not found.");
X		}
X        }
X
X	/* setup to process commands */
X        lastflag = 0;                           /* Fake last flags.     */
X	curbp->b_mode |= gmode;			/* and set default modes*/
X	curwp->w_flag |= WFMODE;		/* and force an update	*/
X#if	COLOR
X	curwp->w_fcolor = gfcolor;		/* and set colors	*/
X	curwp->w_bcolor = gbcolor;
X#endif
X
Xloop:
X        update(FALSE);                          /* Fix up the screen    */
X        c = getcmd();
X        if (mpresf != FALSE) {
X                mlerase();
X                update(FALSE);
X#if	CLRMSG
X                if (c == ' ')                   /* ITS EMACS does this  */
X                        goto loop;
X#endif
X        }
X        f = FALSE;
X        n = 1;
X
X	/* do META-# processing if needed */
X
X	basec = c & ~META;		/* strip meta char off if there */
X	if ((c & META) && ((basec >= '0' && basec <= '9') || basec == '-')) {
X		f = TRUE;		/* there is a # arg */
X		n = 0;			/* start with a zero default */
X		mflag = 1;		/* current minus flag */
X		c = basec;		/* strip the META */
X		while ((c >= '0' && c <= '9') || (c == '-')) {
X			if (c == '-') {
X				/* already hit a minus or digit? */
X				if ((mflag == -1) || (n != 0))
X					break;
X				mflag = -1;
X			} else {
X				n = n * 10 + (c - '0');
X			}
X			if ((n == 0) && (mflag == -1))	/* lonely - */
X				mlwrite("Arg:");
X			else
X				mlwrite("Arg: %d",n * mflag);
X
X			c = getcmd();	/* get the next key */
X		}
X		n = n * mflag;	/* figure in the sign */
X	}
X
X	/* do ^U repeat argument processing */
X
X        if (c == (CTRL|'U')) {                  /* ^U, start argument   */
X                f = TRUE;
X                n = 4;                          /* with argument of 4 */
X                mflag = 0;                      /* that can be discarded. */
X                mlwrite("Arg: 4");
X                while ((c=getcmd()) >='0' && c<='9' || c==(CTRL|'U') || c=='-'){
X                        if (c == (CTRL|'U'))
X                                n = n*4;
X                        /*
X                         * If dash, and start of argument string, set arg.
X                         * to -1.  Otherwise, insert it.
X                         */
X                        else if (c == '-') {
X                                if (mflag)
X                                        break;
X                                n = 0;
X                                mflag = -1;
X                        }
X                        /*
X                         * If first digit entered, replace previous argument
X                         * with digit and set sign.  Otherwise, append to arg.
X                         */
X                        else {
X                                if (!mflag) {
X                                        n = 0;
X                                        mflag = 1;
X                                }
X                                n = 10*n + c - '0';
X                        }
X                        mlwrite("Arg: %d", (mflag >=0) ? n : (n ? -n : -1));
X                }
X                /*
X                 * Make arguments preceded by a minus sign negative and change
X                 * the special argument "^U -" to an effective "^U -1".
X                 */
X                if (mflag == -1) {
X                        if (n == 0)
X                                n++;
X                        n = -n;
X                }
X        }
X
X        if (kbdmip != NULL) {                   /* Save macro strokes.  */
X                if (c!=(CTLX|')') && kbdmip>&kbdm[NKBDM-6]) {
X                        ctrlg(FALSE, 0);
X                        goto loop;
X                }
X                if (f != FALSE) {
X                        *kbdmip++ = (CTRL|'U');
X                        *kbdmip++ = n;
X                }
X                *kbdmip++ = c;
X        }
X        execute(c, f, n);                       /* Do it.               */
X        goto loop;
X}
X
X/*
X * Initialize all of the buffers and windows. The buffer name is passed down
X * as an argument, because the main routine may have been told to read in a
X * file by default, and we want the buffer name to be right.
X */
Xedinit(bname)
Xchar    bname[];
X{
X        register BUFFER *bp;
X        register WINDOW *wp;
X	char *malloc();
X
X        bp = bfind(bname, TRUE, 0);             /* First buffer         */
X        blistp = bfind("[List]", TRUE, BFINVS); /* Buffer list buffer   */
X        wp = (WINDOW *) malloc(sizeof(WINDOW)); /* First window         */
X        if (bp==NULL || wp==NULL || blistp==NULL)
X                exit(1);
X        curbp  = bp;                            /* Make this current    */
X        wheadp = wp;
X        curwp  = wp;
X        wp->w_wndp  = NULL;                     /* Initialize window    */
X        wp->w_bufp  = bp;
X        bp->b_nwnd  = 1;                        /* Displayed.           */
X        wp->w_linep = bp->b_linep;
X        wp->w_dotp  = bp->b_linep;
X        wp->w_doto  = 0;
X        wp->w_markp = NULL;
X        wp->w_marko = 0;
X        wp->w_toprow = 0;
X#if	COLOR
X	/* initalize colors to global defaults */
X	wp->w_fcolor = gfcolor;
X	wp->w_bcolor = gbcolor;
X#endif
X        wp->w_ntrows = term.t_nrow-1;           /* "-1" for mode line.  */
X        wp->w_force = 0;
X        wp->w_flag  = WFMODE|WFHARD;            /* Full.                */
X}
X
X/*
X * This is the general command execution routine. It handles the fake binding
X * of all the keys to "self-insert". It also clears out the "thisflag" word,
X * and arranges to move it to the "lastflag", so that the next command can
X * look at it. Return the status of command.
X */
Xexecute(c, f, n)
X{
X        register KEYTAB *ktp;
X        register int    status;
X
X        ktp = &keytab[0];                       /* Look in key table.   */
X        while (ktp->k_fp != NULL) {
X                if (ktp->k_code == c) {
X                        thisflag = 0;
X                        status   = (*ktp->k_fp)(f, n);
X                        lastflag = thisflag;
X                        return (status);
X                }
X                ++ktp;
X        }
X
X        /*
X         * If a space was typed, fill column is defined, the argument is non-
X         * negative, wrap mode is enabled, and we are now past fill column,
X	 * and we are not read-only, perform word wrap.
X         */
X        if (c == ' ' && (curwp->w_bufp->b_mode & MDWRAP) && fillcol > 0 &&
X	    n >= 0 && getccol(FALSE) > fillcol &&
X	    (curwp->w_bufp->b_mode & MDVIEW) == FALSE)
X                wrapword();
X
X        if ((c>=0x20 && c<=0x7E)                /* Self inserting.      */
X        ||  (c>=0xA0 && c<=0xFE)) {
X                if (n <= 0) {                   /* Fenceposts.          */
X                        lastflag = 0;
X                        return (n<0 ? FALSE : TRUE);
X                }
X                thisflag = 0;                   /* For the future.      */
X
X		/* if we are in overwrite mode, not at eol,
X		   and next char is not a tab or we are at a tab stop,
X		   delete a char forword			*/
X		if (curwp->w_bufp->b_mode & MDOVER &&
X		    curwp->w_doto < curwp->w_dotp->l_used &&
X			(lgetc(curwp->w_dotp, curwp->w_doto) != '\t' ||
X			 (curwp->w_doto) % 8 == 7))
X				ldelete(1L, FALSE);
X
X		/* do the appropriate insertion */
X		if (c == '}' && (curbp->b_mode & MDCMOD) != 0)
X	        	status = insbrace(n, c);
X	        else if (c == '#' && (curbp->b_mode & MDCMOD) != 0)
X	        	status = inspound();
X	        else
X	                status = linsert(n, c);
X
X#if	CFENCE
X		/* check for CMODE fence matching */
X		if ((c == '}' || c == ')') && (curbp->b_mode & MDCMOD) != 0)
X			fmatch(c);
X#endif
X
X                lastflag = thisflag;
X                return (status);
X        }
X	(*term.t_beep)();
X	mlwrite("[Key not bound]");		/* complain		*/
X        lastflag = 0;                           /* Fake last flags.     */
X        return (FALSE);
X}
X
X/*
X * Fancy quit command, as implemented by Norm. If the any buffer has
X * changed do a write on that buffer and exit emacs, otherwise simply exit.
X */
Xquickexit(f, n)
X{
X	register BUFFER *bp;	/* scanning pointer to buffers */
X
X	bp = bheadp;
X	while (bp != NULL) {
X	        if ((bp->b_flag&BFCHG) != 0	/* Changed.             */
X        	&& (bp->b_flag&BFINVS) == 0) {	/* Real.                */
X			curbp = bp;		/* make that buffer cur	*/
X			mlwrite("[Saving %s]",bp->b_fname);
X                	filesave(f, n);
X		}
X	bp = bp->b_bufp;			/* on to the next buffer */
X	}
X        quit(f, n);                             /* conditionally quit   */
X}
X
X/*
X * Quit command. If an argument, always quit. Otherwise confirm if a buffer
X * has been changed and not written out. Normally bound to "C-X C-C".
X */
Xquit(f, n)
X{
X        register int    s;
X
X        if (f != FALSE                          /* Argument forces it.  */
X        || anycb() == FALSE                     /* All buffers clean.   */
X						/* User says it's OK.   */
X        || (s=mlyesno("Modified buffers exist. Leave anyway")) == TRUE) {
X#if	FILOCK
X		if (lockrel() != TRUE) {
X			(*term.t_putchar)('\n');
X			(*term.t_putchar)('\r');
X			(*term.t_close)();
X			exit(1);
X		}
X#endif
X                vttidy();
X#if	APROF
X		/* if doing AZTEC C profiling, close up and write it out */
X		monitor(0,0,0,0,0);
X#endif
X                exit(GOOD);
X        }
X	mlwrite("");
X        return (s);
X}
X
X/*
X * Begin a keyboard macro.
X * Error if not at the top level in keyboard processing. Set up variables and
X * return.
X */
Xctlxlp(f, n)
X{
X        if (kbdmip!=NULL || kbdmop!=NULL) {
X                mlwrite("Not now");
X                return (FALSE);
X        }
X        mlwrite("[Start macro]");
X        kbdmip = &kbdm[0];
X        return (TRUE);
X}
X
X/*
X * End keyboard macro. Check for the same limit conditions as the above
X * routine. Set up the variables and return to the caller.
X */
Xctlxrp(f, n)
X{
X        if (kbdmip == NULL) {
X                mlwrite("Not now");
X                return (FALSE);
X        }
X        mlwrite("[End macro]");
X        kbdmip = NULL;
X        return (TRUE);
X}
X
X/*
X * Execute a macro.
X * The command argument is the number of times to loop. Quit as soon as a
X * command gets an error. Return TRUE if all ok, else FALSE.
X */
Xctlxe(f, n)
X{
X        register int    c;
X        register int    af;
X        register int    an;
X        register int    s;
X
X        if (kbdmip!=NULL || kbdmop!=NULL) {
X                mlwrite("Not now");
X                return (FALSE);
X        }
X        if (n <= 0)
X                return (TRUE);
X        do {
X                kbdmop = &kbdm[0];
X                do {
X                        af = FALSE;
X                        an = 1;
X                        if ((c = *kbdmop++) == (CTRL|'U')) {
X                                af = TRUE;
X                                an = *kbdmop++;
X                                c  = *kbdmop++;
X                        }
X                        s = TRUE;
X                } while (c!=(CTLX|')') && (s=execute(c, af, an))==TRUE);
X                kbdmop = NULL;
X        } while (s==TRUE && --n);
X        return (s);
X}
X
X/*
X * Abort.
X * Beep the beeper. Kill off any keyboard macro, etc., that is in progress.
X * Sometimes called as a routine, to do general aborting of stuff.
X */
Xctrlg(f, n)
X{
X        (*term.t_beep)();
X        if (kbdmip != NULL) {
X                kbdm[0] = (CTLX|')');
X                kbdmip  = NULL;
X        }
X	mlwrite("[Aborted]");
X        return (ABORT);
X}
X
X/* tell the user that this command is illegal while we are in
X   VIEW (read-only) mode				*/
X
Xrdonly()
X
X{
X	(*term.t_beep)();
X	mlwrite("[Key illegal in VIEW mode]");
X	return(FALSE);
X}
X
Xmeta()	/* dummy function for binding to meta prefix */
X{
X}
X
Xcex()	/* dummy function for binding to control-x prefix */
X{
X}
X
X
FRIDAY_NIGHT
echo extracting - menu.cmd
sed 's/^X//' > menu.cmd << 'FRIDAY_NIGHT'
X;	MENU.CMD:	Menu learning system for MicroEMACS 3.7
X;
X;			This file is executed to activate MicroEMACS's
X;			menu interface code
X
X;	setup windows for use
X
X	add-global-mode "blue"
X	1 split-current-window
X	5 resize-window
X	add-mode "red"
X	view-file "menu1"
X	name-buffer "menu window"
X	change-file-name ""
X	add-mode "view"
X	next-window
X
X;	Load menu routines as needed
X
X;	Activate Main Menu
X
X1	store-macro
X	save-window
X	1 next-window
X	begining-of-file
X	search-forward "<<01"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key execute-macro-3	FN;
X	bind-to-key execute-macro-4	FN<
X	bind-to-key execute-macro-5	FN=
X	bind-to-key execute-macro-6	FN>
X	bind-to-key execute-macro-7	FN?
X	bind-to-key execute-macro-8	FN@
X	bind-to-key execute-macro-9	FNA
X	bind-to-key execute-macro-2	FNB
X	bind-to-key execute-macro-10	FNC
X	bind-to-key exit-emacs		FND
X	clear-message-line
X[end]
X
X;	and bring that menu up
X
X	execute-macro-1
X	write-message "         [loading MENU system]"
X
X;	set up the editor control menu
X
X2	store-macro
X	save-window
X	1 next-window
X	begining-of-file
X	search-forward "<<02"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key execute-macro-11	FN;
X	bind-to-key execute-macro-12	FN<
X	bind-to-key execute-macro-13	FN=
X	bind-to-key execute-macro-14	FN>
X	bind-to-key execute-macro-15	FN?
X	bind-to-key execute-macro-16	FN@
X	bind-to-key execute-macro-17	FNA
X	bind-to-key execute-macro-18	FNB
X	bind-to-key execute-macro-19	FNC
X	bind-to-key execute-macro-1	FND
X	clear-message-line
X[end]
X
X;	Activate word case/screen control Menu
X
X3	store-macro
X	save-window
X	1 next-window
X	begining-of-file
X	search-forward "<<03"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key case-word-upper	FN;
X	bind-to-key case-region-upper	FN<
X	bind-to-key case-word-lower	FN=
X	bind-to-key case-region-lower	FN>
X	bind-to-key case-word-capitalize FN?
X	unbind-key FN@
X	bind-to-key clear-and-redraw	FNA
X	bind-to-key set-mark		FNB
X	bind-to-key redraw-display	FNC
X	bind-to-key execute-macro-1	FND
X	clear-message-line
X[end]
X
X;	Activate paging/scrolling Menu
X
X4	store-macro
X	save-window
X	1 next-window
X	begining-of-file
X	search-forward "<<08"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key previous-page	FN;
X	bind-to-key next-page		FN<
X	bind-to-key move-window-down	FN=
X	bind-to-key move-window-up	FN>
X	bind-to-key scroll-next-up	FN?
X	unbind-key 			FN@
X	bind-to-key scroll-next-down	FNA
X	unbind-key 			FNB
X	bind-to-key exchange-point-and-mark FNC
X	bind-to-key execute-macro-1	FND
X	clear-message-line
X[end]
X
X;	Activate cut & paste Menu
X
X5	store-macro
X	save-window
X	1 next-window
X	begining-of-file
X	search-forward "<<04"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key set-mark		FN;
X	unbind-key FN<
X	bind-to-key kill-region		FN=
X	unbind-key FN>
X	bind-to-key copy-region		FN?
X	unbind-key FN@
X	bind-to-key yank		FNA
X	unbind-key FNB
X	unbind-key FNC
X	bind-to-key execute-macro-1	FND
X	clear-message-line
X[end]
X
X;	Activate Search & replace Menu
X
X6	store-macro
X	save-window
X	1 next-window
X	begining-of-file
X	search-forward "<<09"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key search-forward	FN;
X	bind-to-key search-reverse	FN<
X	bind-to-key hunt-forward	FN=
X	bind-to-key hunt-backward	FN>
X	bind-to-key incremental-search	FN?
X	bind-to-key reverse-incremental-search FN@
X	bind-to-key replace-string	FNA
X	bind-to-key query-replace-string FNB
X	unbind-key FNC
X	bind-to-key execute-macro-1	FND
X	clear-message-line
X[end]
X
X;	Activate Deletion Menu
X
X7	store-macro
X	save-window
X	1 next-window
X	begining-of-file
X	search-forward "<<05"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key delete-previous-character FN;
X	unbind-key FN<
X	bind-to-key delete-next-character FN=
X	unbind-key FN>
X	bind-to-key kill-to-end-of-line	FN?
X	unbind-key FN@
X	bind-to-key delete-blank-lines	FNA
X	unbind-key FNB
X	unbind-key FNC
X	bind-to-key execute-macro-1	FND
X	clear-message-line
X[end]
X
X;	Activate Word procesing Menu
X
X8	store-macro
X	save-window
X	1 next-window
X	begining-of-file
X	search-forward "<<10"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key previous-word	FN;
X	bind-to-key next-word		FN<
X	bind-to-key previous-paragraph	FN=
X	bind-to-key next-paragraph	FN>
X	bind-to-key fill-paragraph	FN?
X	bind-to-key kill-paragraph	FN@
X	bind-to-key delete-previous-word FNA
X	bind-to-key delete-next-word	FNB
X	bind-to-key count-words		FNC
X	bind-to-key execute-macro-1	FND
X	clear-message-line
X[end]
X
X;	Activate Insertion Menu
X
X9	store-macro
X	save-window
X	1 next-window
X	begining-of-file
X	search-forward "<<06"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key open-line		FN;
X	bind-to-key insert-string	FN<
X	bind-to-key handle-tab		FN=
X	bind-to-key quote-character	FN>
X	bind-to-key insert-space	FN?
X	bind-to-key transpose-characters FN@
X	bind-to-key newline-and-indent	FNA
X	unbind-key FNB
X	bind-to-key newline		FNC
X	bind-to-key execute-macro-1	FND
X	clear-message-line
X[end]
X
X;	Activate Cursor movement Menu
X
X10	store-macro
X	save-window
X	1 next-window
X	begining-of-file
X	search-forward "<<07"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key begining-of-file	FN;
X	bind-to-key previous-line	FN<
X	bind-to-key backward-character	FN=
X	bind-to-key forward-character	FN>
X	bind-to-key end-of-file		FN?
X	bind-to-key next-line		FN@
X	bind-to-key begining-of-line	FNA
X	bind-to-key end-of-line		FNB
X	bind-to-key execute-macro-21	FNC
X	bind-to-key execute-macro-1	FND
X	clear-message-line
X[end]
X
X21	store-macro
X	"@Line number to go to: " goto-line
X[end]
X
X;	Activate Buffer Menu
X
X11	store-macro
X	save-window
X	1 next-window
X	begining-of-file
X	search-forward "<<11"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key buffer-position	FN;
X	bind-to-key unmark-buffer	FN<
X	bind-to-key delete-buffer	FN=
X	bind-to-key next-buffer		FN>
X	bind-to-key list-buffers	FN?
X	bind-to-key execute-macro-22	FN@
X	bind-to-key name-buffer		FNA
X	unbind-key FNB
X	bind-to-key select-buffer	FNC
X	bind-to-key execute-macro-2	FND
X	clear-message-line
X[end]
X
X22	store-macro
X	filter-buffer "@Name of DOS filter: "
X[end]
X;	Macro Menu
X
X12	store-macro
X	save-window
X	1 next-window
X	begining-of-file
X	search-forward "<<11"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key begin-macro		FN;
X	unbind-key FN<
X	bind-to-key end-macro		FN=
X	unbind-key FN>
X	bind-to-key execute-macro	FN?
X	unbind-key FN@
X	unbind-key FNA
X	unbind-key FNB
X	unbind-key FNC
X	bind-to-key execute-macro-2	FND
X	clear-message-line
X[end]
X
X;	Color change Menu
X
X13	store-macro
X	save-window
X	1 next-window
X	begining-of-file
X	search-forward "<<12"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key execute-macro-23	FN;
X	unbind-key FN<
X	bind-to-key execute-macro-24	FN=
X	unbind-key FN>
X	bind-to-key execute-macro-25	FN?
X	unbind-key FN@
X	bind-to-key execute-macro-26	FNA
X	unbind-key FNB
X	unbind-key FNC
X	bind-to-key execute-macro-2	FND
X	clear-message-line
X[end]
X
X;	Set forground color
X
X23	store-macro
X	save-window
X	1 next-window
X	select-buffer "[color]"
X	begining-of-file
X	insert-string "@Color to change to: "
X	newline
X	begining-of-file
X	case-word-upper
X	begining-of-file
X	unmark-buffer
X	select-buffer "menu window"
X	1 redraw-display
X	restore-window
X	add-mode "#[color]"
X	delete-buffer "[color]"
X[end]
X
X;	Set background color
X
X24	store-macro
X	save-window
X	1 next-window
X	select-buffer "[color]"
X	begining-of-file
X	insert-string "@Color to change to: "
X	newline
X	begining-of-file
X	case-word-lower
X	begining-of-file
X	unmark-buffer
X	select-buffer "menu window"
X	1 redraw-display
X	restore-window
X	add-mode "#[color]"
X	delete-buffer "[color]"
X[end]
X
X;	Set global forground color
X
X25	store-macro
X	save-window
X	1 next-window
X	select-buffer "[color]"
X	begining-of-file
X	insert-string "@Color to change to: "
X	newline
X	begining-of-file
X	case-word-upper
X	begining-of-file
X	unmark-buffer
X	select-buffer "menu window"
X	1 redraw-display
X	restore-window
X	add-global-mode "#[color]"
X	delete-buffer "[color]"
X[end]
X
X;	Set global background color
X
X26	store-macro
X	save-window
X	1 next-window
X	select-buffer "[color]"
X	begining-of-file
X	insert-string "@Color to change to: "
X	newline
X	begining-of-file
X	case-word-lower
X	begining-of-file
X	unmark-buffer
X	select-buffer "menu window"
X	1 redraw-display
X	restore-window
X	add-global-mode "#[color]"
X	delete-buffer "[color]"
X[end]
X
X;	set Mode Menu
X
X14	store-macro
X	save-window
X	1 next-window
X	begining-of-file
X	search-forward "<<17"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key add-mode		FN;
X	bind-to-key add-global-mode	FN<
X	bind-to-key delete-mode		FN=
X	bind-to-key delete-global-mode	FN>
X	unbind-key FN?
X	bind-to-key execute-macro-27	FN@
X	unbind-key FNA
X	unbind-key FNB
X	bind-to-key select-buffer	FNC
X	bind-to-key execute-macro-2	FND
X	clear-message-line
X[end]
X
X27	store-macro
X	"@Column to fill to: " set-fill-column
X[end]
X
X;	DOS command Menu
X
X15	store-macro
X	save-window
X	1 next-window
X	begining-of-file
X	search-forward "<<13"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key shell-command	FN;
X	unbind-key FN<
X	bind-to-key pipe-command	FN=
X	unbind-key FN>
X	bind-to-key i-shell		FN?
X	unbind-key FN@
X	bind-to-key quick-exit		FNA
X	unbind-key FNB
X	bind-to-key exit-emacs		FNC
X	bind-to-key execute-macro-2	FND
X	clear-message-line
X[end]
X
X;	Script Menu
X
X16	store-macro
X	save-window
X	1 next-window
X	begining-of-file
X	search-forward "<<18"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key execute-file	FN;
X	bind-to-key execute-command-line FN<
X	bind-to-key execute-buffer	FN=
X	bind-to-key execute-named-command FN>
X	unbind-key FN?
X	unbind-key FN@
X	unbind-key FNA
X	unbind-key FNB
X	unbind-key FNC
X	bind-to-key execute-macro-2	FND
X	clear-message-line
X[end]
X
X;	File access Menu
X
X17	store-macro
X	save-window
X	1 next-window
X	begining-of-file
X	search-forward "<<14"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key find-file		FN;
X	bind-to-key save-file		FN<
X	bind-to-key view-file		FN=
X	bind-to-key write-file		FN>
X	bind-to-key read-file		FN?
X	bind-to-key change-file-name	FN@
X	bind-to-key insert-file		FNA
X	unbind-key FNB
X	unbind-key FNC
X	bind-to-key execute-macro-2	FND
X	clear-message-line
X[end]
X
X;	Window Menu
X
X18	store-macro
X	save-window
X	1 next-window
X	begining-of-file
X	search-forward "<<19"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key split-current-window FN;
X	bind-to-key delete-other-windows FN<
X	bind-to-key resize-window	FN=
X	bind-to-key delete-window	FN>
X	bind-to-key shrink-window	FN?
X	bind-to-key grow-window		FN@
X	bind-to-key next-window		FNA
X	bind-to-key previous-window	FNB
X	unbind-key FNC
X	bind-to-key execute-macro-2	FND
X	clear-message-line
X[end]
X
X;	key binding Menu
X
X19	store-macro
X	save-window
X	1 next-window
X	begining-of-file
X	search-forward "<<15"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key bind-to-key		FN;
X	unbind-key FN<
X	bind-to-key unbind-key		FN=
X	unbind-key FN>
X	bind-to-key describe-key	FN?
X	unbind-key FN@
X	bind-to-key describe-bindings	FNA
X	unbind-key FNB
X	unbind-key FNC
X	bind-to-key execute-macro-2	FND
X	clear-message-line
X[end]
X
X	clear-message-line
FRIDAY_NIGHT
echo es.8 completed!
: That's all folks!

