Subject: v06i037:  Elm mail system (elm), Part12/14
Newsgroups: mod.sources
Approved: rs@mirror.UUCP

Submitted by: Dave Taylor <pyramid!hplabs!hpldat!taylor>
Mod.sources: Volume 6, Issue 37
Archive-name: elm/Part12

# Continuation of Shell Archive, created by hpldat!taylor

# This is part 12

# To unpack the enclosed files, please use this file as input to the
# Bourne (sh) shell.  This can be most easily done by the command;
#     sh < thisfilename


if [ ! -d src ]
then
  echo creating directory src
  mkdir src
fi

# ---------- file src/screen3270.q ----------

filename="src/screen3270.q"

if [ -f $filename ]
then
  echo File \"$filename\" already exists\!  Skipping...
  filename=/dev/null		# throw it away
else
  echo extracting file src/screen3270.q...
fi

sed 's/^X//' << 'END-OF-FILE' > $filename
XFrom hpccc!mcgregor@hplabs.ARPA Thu Jun  5 11:41:49 1986
XReceived: from hplabs.ARPA by hpldat ; Thu, 5 Jun 86 11:41:32 pdt
XMessage-Id: <8606051841.AA16872@hpldat>
XReceived: by hplabs.ARPA ; Thu, 5 Jun 86 11:38:07 pdt
XTo: hplabs!taylor@hplabs.ARPA
XDate: Thu, 5 Jun 86 11:36:39 PDT
XFrom: hpccc!mcgregor@hplabs.ARPA (Scott McGregor)
XSubject: revised screen3270.q
XTelephone: (415) 857-5875
XPostal-Address: Hewlett-Packard, PO Box 10301, Mail stop 20CH, Palo Alto CA 943X03-0890
XX-Mailer: ELM [version 1.0]
X
X
X/*
X * screen3270.q
X *
X *   Created for ELM, 5/86 to work (hopefully) on UTS systems with 3270
X *   type terminals, by Scott L. McGregor, HP Corporate Computing Center.
X *
X */
X
X#include "headers.h"
X#  include <sys/utsname.h>
X#  include <sys/tubio.h>
X
X#  include <errno.h>
X
X
X#  define  TTYIN		0		/* standard input */
X#include <stdio.h>
X#define MAXKEYS 101
X#define OFF 0
X#define UNKNOWN 0
X#define ON 1
X#define FALSE 0
X#define TRUE 1
X
Xchar *error_name();
X
Xextern int _line, _col;
X
X 
Xpfinitialize()
X{
X	char cp[80];
X	
X	dprint0(9,"pfinitialize()\n");
X	pfinit();
X	/*
X	 * load the system defined pfkeys
X	 */
X	pfload("/usr/local/etc/.elmpfrc");
X	/*
X	 * load the user's keys if any
X	 */
X	strcat(cp,home);
X	strcat(cp,"/.elmpfrc");
X	pfload(cp);
X	pfprint();
X}
X
X/*
X * note, inputs are limited to 80 characters! Any larger amount
X * will be truncated without notice!
X */
X
X
X/*
X * pfinit() initializes _pftable
X */
Xpfinit()
X{
X	int i,j;
X	
X	dprint0(9,"pfinit()\n");
X	for (i=0;i<MAXKEYS;i++) {
X		for (j=0;j<80;j++) {
X			_pftable[i][j]='\0';
X		}
X	}
X	return(0);
X}
X
X
X/*
X * pfset(key) sets _pftable entries.
X */
Xpfset(key,return_string)
Xint key;
Xchar *return_string;
X{
X	int i;
X
X	dprint2(9,"pfset(%d,%s)\n",key,return_string);
X	for (i=0;i<=80;i++) {
X		if (i <= strlen(return_string))
X			_pftable[key][i] = return_string[i];
X		else _pftable[key][i] = '\0';
X	}
X	dprint2(9,"pfset: %d %s\n",key,_pftable[key]);
X       
X	return(0);
X}
X
X/*
X *  pfload(name) reads file "name" and parses the
X *  key definitions in it into a table used by the
X *  pfreturn.
X */
Xpfload(name)
Xchar *name;
X{
X	FILE *pfdefs;
X	int i,j,k;
X	int key = 0;
X	char defn[80];
X	char newdefn[80];
X
X	dprint1(9,"pfload(%s)\n",name);
X	if ((pfdefs = fopen(name,"r")) == NULL){
X		dprint2(2,"%s pfrc open failed, %s \n",name,
X			error_name(errno));
X		return(0);
X	 }
X
X	 /*
X	  * This program reads .elmpfrc files which it currently
X	  * expects to be in the form:
X	  * 
X	  * <pfkeynumber> <whitespace> <pfkeyvalue> [<whitespace> <comment>]
X	  * 
X	  * Pfkeynumber is an integer 1-24.  Whitespace can be one
X	  * or more blanks or tabs.  Pfkeyvalue is any string NOT
X	  * containing whitespace (however, \b for blank, \t for tab
X	  * and \n for newline can be used instead to indicate that
X	  * the indicated whitespace character is part of a command.
X	  * Note that the EnTER key will NOT be treated as a newline
X	  * command, so defining a newline key is a good idea!
X	  * Anything else appearing on the line after the pfkey is ignored
X	  * and so can be used as a comment.
X	  *
X	  * This may not be the best form for a file used by
X	  * humans to set parms, and if someone comes up with a
X	  * better one and a parser to read it, then this can be
X	  * replaced.
X	  *
X	  */
X	 
X	dprint1(1,"%s pfrc opened\n",name);
X	k = 0;
X	while ( fscanf(pfdefs,"%d%s",&key,defn) != EOF ) {
X		dprint2(9,"pfkey definition 1: %d %s\n",key,defn);
X		if ((key < 0) || (key > MAXKEYS)) {
X			dprint2(9,"pfkey defn failed: key=%d MAXKEYS=%d\n",key,MAXKEYS);
X			k++;
X		} else {
X			dprint2(9,"pfkey definition 2: %d %s\n",key,defn);
X			for (i=0,j=0;i<strlen(defn);i++) {
X				if (defn[i]=='\\') {
X					if (defn[i+1]=='n') {
X						newdefn[j++]='\n'; i++;
X					}
X					if (defn[i+1]=='t') {
X						newdefn[j++]='\t'; i++;
X					}
X					if (defn[i+1]=='0') {
X						newdefn[j++]='\0'; i++;
X					}
X					if (defn[i+1]=='1') {
X						newdefn[j++]='\001'; i++;
X					}
X					if (defn[i+1]=='b') {
X						newdefn[j++]=' '; i++;
X					}
X				}
X				 else {
X					newdefn[j++]=defn[i];
X				}
X			}
X			dprint2(9,"pfkey new definition: %d %s\n",key,newdefn);
X			pfset(key,newdefn);
X		}
X	}
X	dprint1(9,"pfkey definition table:  %s\n",_pftable);
X	return(k);
X}
X
X
X/*
X * pfreturn(key) returns the stored string for that pfkey.
X */
Xpfreturn(key,string)
Xint key;
Xchar string[];
X{
X	int i;
X	
X	dprint2(9,"pfreturn(%d,%s)\n",key,string);
X	for (i=0;i<80;i++) {
X		string[i] = _pftable[key][i];
X	}
X	dprint1(9,"pfreturn string=%s\n",string);
X	return;
X}
X
X
X/*
X * pfprint() prints all pfkey definitions
X */
Xpfprint()
X
X{
X	int i;
X	char string[80];
X
X	for (i=0;i<MAXKEYS;i++) {
X		if (strlen(_pftable[i]) != 0)
X		dprint2(9,"%d pf table entry=%s\n",i+1,_pftable[i]);
X	}
X}
X
X/*
X * rowcol2offset(row,col) takes the row and column numbers and
X * returns the offset into the array.
X * row and column are assumed to vary from 0 to LINES-1, and COLUMNS-1
X * respectively.
X */
Xrowcol2offset(row,col)
Xint row, col;
X{
X	dprint2(9,"rowcol2offset(%d,%d)\n",row,col);
X	
X	if ((row <= LINES) && (row >= 0)) {
X		if ((col <= COLUMNS) && (col >=0)) {
X			return(row*COLUMNS+col);
X		}
X		else return(0);
X	}
X	else return(0);
X}
X
X/*
X * offset2row(offset) takes the offset returnes the row.
X * row is assumed to vary from 0 to LINES-1.
X */
Xoffset2row(offset)
Xint offset;
X{
X	int i;
X	
X	dprint1(9,"offset2row(%d)\n",offset);
X	i =  (int) (offset / COLUMNS);
X	dprint1(9,"offset2row returns= %d)\n",i);
X	return(i);
X}
X
X/*
X * offset2col(offset) takes the offset returnes the col.
X * col is assumed to vary from 0 to COLUMNS-1.
X */
Xoffset2col(offset)
Xint offset;
X{
X	int i;
X	
X	dprint1(9,"offset2col(%d)\n",offset);
X	i =  (int) (offset % COLUMNS);
X	dprint1(9,"offset2col returns= %d)\n",i);
X	return(i);
X}
X
X/*
X * Row(row) takes the row in 0 <= row < LINES and returns
X * row in 0 < row <= LINES.
X */
XRow(row)
Xint row;
X{
X	dprint1(9,"Row(%d)\n",row);
X	return(row+1);
X}
X
X/*
X * Col(Col) takes the col in 0 <= col < COLUMNS and returns
X * col in 0 < col <= COLUMNS.
X */
XCol(col)
Xint col;
X{
X	dprint1(9,"Col(%d)\n",col);
X	return(col+1);
X}
X
X
Xgethostname(hostname,size) /* get name of current host */
Xint size;
Xchar *hostname;
X{
X	/** Return the name of the current host machine.  UTS only **/
X
X	/** This routine compliments of Scott McGregor at the HP
X	    Corporate Computing Center **/
X     
X	int uname();
X	struct utsname name;
X
X        dprint2(9,"gethostname(%s,%d)\n",hostname,size);
X	(void) uname(&name);
X	(void) strncpy(hostname,name.nodename,size-1);
X	if (strlen(name.nodename) > SLEN)
X	  hostname[size] = '\0';
X}
X
Xint
Xisa3270()
X{
X	/** Returns TRUE and sets LINES and COLUMNS to the correct values
X	    for an Amdahl (IBM) tube screen, or returns FALSE if on a normal
X	    terminal (of course, next to a 3270, ANYTHING is normal!!) **/
X
X	struct tubiocb tubecb;
X	
X	dprint0(9,"isa3270()\n");
X	if (ioctl(TTYIN, TUBGETMOD, &tubecb) == -1){
X	  return(FALSE);	/* not a tube! */
X	}
X	LINES   = tubecb.line_cnt - 2;
X	COLUMNS = tubecb.col_cnt;
X	if (!check_only && !mail_only) {
X		isatube = TRUE;
X		return(TRUE);
X	}
X	 else {
X		 isatube = FALSE;
X		 return(FALSE);
X	}
X}
X
X/*
X * ReadCh3270() reads a character from the 3270.
X */
Xint ReadCh3270()
X{
X        /** read a character from the display! **/
X
X	register int x;
X	char tempstr[80];
X        char ch;
X	
X	dprint0(9,"ReadCh3270()\n");
X	if ((_input_buf_ptr > COLUMNS) ||
X        (_input_buffer[_input_buf_ptr] == '\0')) {
X		WriteScreen3270();
X		for (x=0; x < COLUMNS; x++) _input_buffer[x] = '\0';
X		panel (noerase, read) {
X			#@ LINES+1,1# #INC,_input_buffer,COLUMNS#
X		}
X		dprint1(9,"ReadCh3270 _input_buffer=%s\n",_input_buffer);
X		x=strlen(_input_buffer);
X		pfreturn(qskp,tempstr);
X		if (!strcmp(tempstr,"\001")) {
X			if (strlen(_input_buffer) == 1) {
X				tempstr[0]='\0';
X			}
X			 else {
X				tempstr[0]='\n';
X				tempstr[1]='\0';
X			}
X		}
X		dprint1(9,"ReadCh3270 pfkey=%s\n",tempstr);
X		strcat(_input_buffer,tempstr);
X		dprint1(9,"ReadCh3270 _input_buffer+pfkey=%s\n",_input_buffer);
X		ch = _input_buffer[0];
X		dprint1(9,"ReadCh3270 returns(%c)\n",ch);
X		_input_buf_ptr = 1;
X		return(ch);
X	}
X	 else {
X		 ch = _input_buffer[_input_buf_ptr];
X		 dprint1(9,"ReadCh3270 returns(%c)\n",ch);
X		 _input_buf_ptr = _input_buf_ptr + 1;
X		 return(ch);
X	}
X}
X
X
X/*
X * WriteScreen3270() Loads a screen to the buffer.
X *
X */
XWriteScreen3270()
X{
X	register int x;
X	int currcol;
X	int currrow;
X	int i;
X	int state = OFF;
X	int prevrow = 1;
X	int prevcol = 1;
X	int prevptr = 0;
X	int clear_state = ON;
X	char tempstr[80];
X	char copy_screen[66*132];
X	
X	dprint0(9,"WriteScreen3270()\n");
X	prevrow = 1;
X	prevcol = 1;
X	prevptr = 0;
X	state = OFF;
X	for (x=0; x < LINES*COLUMNS; x++){
X		if ((_internal_screen[x] == '\016')
X		&& (state == OFF)) {
X			currrow = (x / COLUMNS ) + 1;
X			currcol = (x % COLUMNS ) + 1 ;
X			i = x - prevptr - 1;
X			strncpy(copy_screen, (char *) (_internal_screen+(prevptr)),i);
X			panel(erase=clear_state,write,noread) {
X				#@ prevrow, prevcol # #ON,copy_screen,i #
X			}
X			clear_state = OFF;
X			state = ON;
X		     /* prevrow = currrow; */
X		     /* prevcol = currcol; */
X			prevrow = currrow + 1;
X			prevcol = 0;
X			prevptr = x+1;
X		}
X		else if ((_internal_screen[x] == '\017')
X		&& (state == ON)) {
X			currrow = (x / COLUMNS ) + 1;
X			currcol = (x % COLUMNS ) + 1;
X			i = x - prevptr - 1;
X			strncpy(copy_screen, (char *) (_internal_screen+(prevptr)),i);
X			panel(erase = clear_state,write,noread) {
X				#@ prevrow,prevcol # #OH,copy_screen,i #
X			}
X			clear_state = OFF;
X			state = OFF;
X		     /* prevrow = currrow; */
X		     /* prevcol = currcol; */
X			prevrow = currrow + 1;
X			prevcol = 0;
X		}
X	       else if (_internal_screen[x] < ' ') {
X			_internal_screen[x] = ' ';
X			prevptr = x + 1;
X	       }
X	}
X	/* write remainder of buffer */
X	if (state == OFF) {
X		currrow = (LINES) + 1 ;
X		currcol = (COLUMNS ) + 1;
X		i = x - prevptr  ;
X		strncpy(copy_screen, (char *) (_internal_screen+(prevptr)),i);
X		panel(erase=clear_state,write,noread) {
X			#@ prevrow,prevcol # #ON,copy_screen,i #
X		}
X	}
X	else {
X		currrow = (LINES ) + 1 ;
X		currcol = (COLUMNS ) + 1 ;
X		i = x - prevptr ;
X		strncpy(copy_screen, (char *) (_internal_screen+(prevptr)),i);
X		panel(erase=clear_state,write,noread) {
X			#@ prevrow,prevcol # #OH,copy_screen,i #
X		}
X	}
X}
X
X
X/*
X * Clear3270
X */
XClear3270()
X{
X	int  i,j;
X	
X	dprint0(9,"Clear3270()\n");
X	j = rowcol2offset(LINES,COLUMNS);
X	for (i = 0; i < j; i++) {
X		_internal_screen[i] = ' ';
X	}
X	return(0);
X}
X
X/*
X *  WriteChar3270(row,col) writes a character at the row and column.
X */
XWriteChar3270(row,col,ch)
Xint row, col;
Xchar ch;
X{
X	dprint3(9,"WriteChar3270(%d,%d,%c)\n",row,col,ch);
X	_internal_screen[rowcol2offset(row,col)] = ch;
X}
X
X/*
X *  WriteLine3270(row,col) writes a line at the row and column.
X */
XWriteLine3270(row,col,line)
Xint row, col;
Xchar *line;
X{
X	int i, j, k;
X	dprint3(9,"WriteLine3270(%d,%d,%s)\n",row,col,line);
X        _line = row;
X	_col = col;
X	k = strlen(line);
X	i=rowcol2offset(row,col);
X	for (j=0; j<k; i++, j++) {
X		if ((line[j] >= ' ')   ||
X		   (line[j] == '\016') ||
X		   (line[j] == '\017'))
X		_internal_screen[i] = line[j];
X		else _internal_screen[i] = ' ';
X	}
X   /*   _line = offset2row(i-1);  calling program updates location */
X   /*   _col  = offset2col(i-1); */
X	
X}
X
X
X/*
X * ClearEOLN3270() clears the remainder of the current line on a 3270.
X */
XClearEOLN3270()
X{
X	int i,j ;
X	
X	dprint0(9,"ClearEOLN3270()\n");
X	j = rowcol2offset(_line,COLUMNS);
X	for (i=rowcol2offset(_line,_col); i < j; i++) {
X		_internal_screen[i] = ' ';
X	}
X}
X
X/*
X * ClearEOS3270() clears the remainder of the current screen on a 3270.
X */
XClearEOS3270()
X{
X	int i,j;
X	
X	dprint0(9,"ClearEOS3270()\n");
X	j = rowcol2offset(LINES,COLUMNS);
X        for (i = rowcol2offset(_line,_col); i < j; i++) {
X		_internal_screen[i] = ' ';
X	}
X}
X
END-OF-FILE

if [ "$filename" != "/dev/null" ]
then
  size=`wc -c < $filename`

  if [ $size != 11592 ]
  then
    echo $filename changed - should be 11592 bytes, not $size bytes
  fi

  chmod 666 $filename
fi

# ---------- file src/UTS.DIFFS ----------

filename="src/UTS.DIFFS"

if [ -f $filename ]
then
  echo File \"$filename\" already exists\!  Skipping...
  filename=/dev/null		# throw it away
else
  echo extracting file src/UTS.DIFFS...
fi

sed 's/^X//' << 'END-OF-FILE' > $filename
XFrom hpccc!mcgregor@hplabs.ARPA Wed Jun  4 17:16:32 1986
XReceived: from hplabs.ARPA by hpldat ; Wed, 4 Jun 86 17:16:16 pdt
XMessage-Id: <8606050016.AA16171@hpldat>
XReceived: by hplabs.ARPA ; Wed, 4 Jun 86 17:11:46 pdt
XDate: Wed, 4 Jun 86 17:09:05 pdt
XFrom: Scott McGregor <hpccc!mcgregor@hplabs.ARPA>
XTo: taylor@hplabs
X
X
X
XJun  4 14:05 1986  /ccc/mcgregor/elm2/src only and /ccc/mcgregor/elm/src only PXage 1
X
X
X./a.out					    ./curses.q
X./addr_utils.o
X./alias.o
X./aliasdb.o
X./aliaslib.o
X./args.o
X./bounceback.o
X./calendar.o
X./ckhpdesk.c
X./ckhpdesk.o
X./connect_to.o
X./curses.c
X./curses.o
X./curses.q1
X./date.o
X./delete.o
X./domains.o
X./edit.o
X./elm.o
X./encode.o
X./errno.o
X./file.o
X./file_utils.o
X./fileio.o
X./hdrconfg.o
X./help.o
X./initialize.o
X./input_utils.o
X./leavembox.o
X./mailmsg1.o
X./mailmsg2.o
X./mailtime.o
X./mkhdrs.o
X./ned.tmpa28250
X./newmbox.o
X./notesfile.o
X./opt_utils.o
X./options.o
X./output_utils.o
X./pattern.o
X./quit.o
X./read_rc.o
X./remail.o
X./reply.o
X./return_addr.o
X./savecopy.o
X./screen.o
X./screen3270.o
X./screen3270.q
X./showmsg.o
X./signals.o
X./softkeys.o
X./sort.o
X./strings.o
X./syscall.o
X./utils.o
X
X
X
X
X
X
X
XJun  4 14:05 1986  /ccc/mcgregor/elm2/src only and /ccc/mcgregor/elm/src only PXage 2
X
X
X./validname.o
X./
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
XJun  4 14:05 1986  Comparison of /ccc/mcgregor/elm2/src /ccc/mcgregor/elm/src PXage 1
X
X
Xdirectory	.
Xsame     	./.emacs_106
Xsame     	./INDEX
Xsame     	./Makefile
Xsame     	./addr_utils.c
Xdifferent	./alias.c
Xsame     	./aliasdb.c
Xdifferent	./aliaslib.c
Xsame     	./args.c
Xsame     	./bounceback.c
Xsame     	./calendar.c
Xsame     	./connect_to.c
Xsame     	./curses.IBM
Xsame     	./curses.msg3.3
Xsame     	./curses.q_
Xsame     	./date.c
Xsame     	./delete.c
Xsame     	./domains.c
Xsame     	./edit.c
Xdifferent	./elm.c
Xsame     	./encode.c
Xsame     	./errno.c
Xsame     	./file.c
Xsame     	./file_utils.c
Xsame     	./fileio.c
Xsame     	./hdrconfg.c
Xsame     	./help.c
Xsame     	./initialize.c
Xsame     	./initialize.uts
Xsame     	./input_utils.c
Xsame     	./leavembox.c
Xsame     	./mailmsg1.c
Xsame     	./mailmsg2.c
Xsame     	./mailtime.c
Xsame     	./mkhdrs.c
Xsame     	./ned.erra27313
Xsame     	./ned.erra27590
Xsame     	./newmbox.c
Xsame     	./notesfile.c
Xsame     	./opt_utils.c
Xsame     	./opt_utils.c_
Xsame     	./options.c
Xsame     	./output_utils.c
Xsame     	./pattern.c
Xsame     	./quit.c
Xsame     	./read_rc.c
Xsame     	./read_rcc
Xsame     	./remail.c
Xsame     	./reply.c
Xsame     	./return_addr.c
Xsame     	./savecopy.c
Xdifferent	./screen.c
Xsame     	./showmsg.c
Xsame     	./signals.c
Xsame     	./softkeys.c
Xsame     	./sort.c
X
X
X
X
X
X
X
XJun  4 14:05 1986  Comparison of /ccc/mcgregor/elm2/src /ccc/mcgregor/elm/src PXage 2
X
X
Xsame     	./strings.c
Xdifferent	./syscall.c
Xsame     	./utils.c
Xsame     	./validname.c
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
XJun  4 14:05 1986  diff of ./alias.c in /ccc/mcgregor/elm2/src and /ccc/mcgregoXr/elm/src Page 1
X
X
X14a15,16
X> extern char ReadCh();
X> extern int Raw();
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
XJun  4 14:05 1986  diff of ./aliaslib.c in /ccc/mcgregor/elm2/src and /ccc/mcgrXegor/elm/src Page 1
X
X
X9d8
X< #include <pwd.h>
X59,63c58,62
X< 	 if (getpwnam(name)==NULL) {
X< 		 dprint3(8,"get_alias_address(%s,%d,%d)\n",name,mailing,depth);
X< 		 strcpy( buffer, ckhpdesk(name));
X< 		 dprint1(8,"get_alias_address:  returns (%s)\n",buffer);
X< 		 return( (char *) buffer);
X---
X> 	 for (i=0;i<strlen(name);i++) {
X> 		
X> 	 }
X> 	 if () {
X> 		 return( (char *) ckhpdesk(name));
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
XJun  4 14:06 1986  diff of ./elm.c in /ccc/mcgregor/elm2/src and /ccc/mcgregor/Xelm/src Page 1
X
X
X26a27,30
X> 	     debug = 9;
X> 	printf("Main program begins\n"); fflush(stdout);
X> 	debugfile = fopen("/ccc/mcgregor/ELM:debug.info","w")
X> 	dprint0(1, "Main program begins\n");
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
XJun  4 14:06 1986  diff of ./screen.c in /ccc/mcgregor/elm2/src and /ccc/mcgregXor/elm/src Page 1
X
X
X137,139d136
X< #ifdef UTS
X< 	if (isatube) WriteScreen3270();
X< #endif UTS
X260,261c257,258
X< 	  dprint2(9,"start_highlight=%o, end_highlight=%o\n",
X< 	      start_highlight[0],end_highlight[0]);
X---
X> 	  dprint2(9,"start_highlight=%o, end_highlight=%o,
X> 	      start_highlight,end_highlight);
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
XJun  4 14:06 1986  diff of ./syscall.c in /ccc/mcgregor/elm2/src and /ccc/mcgreXgor/elm/src Page 1
X
X
X1c1,2
X< /**			syscall.c		**/
X---
X> #include <qsdefs.h>
X> #line 1 "syscall.q"
X3,4d3
X< /** These routines are used for user-level system calls, including the
X<     '!' command and the '|' commands...
X6,7d4
X<     (C) Copyright 1986 Dave Taylor
X< **/
X8a6,10
X>
X>
X>
X>
X>
X18,20d19
X< 	/** spawn a subshell with either the specified command
X< 	    returns non-zero if screen rewrite needed
X< 	**/
X21a21,23
X>
X> 	
X>
X54,56c56
X< 	/** execute 'string', setting uid to userid... **/
X< 	/** if shell-type is "SH" /bin/sh is used regardless of the
X< 	    users shell setting.  Otherwise, "USER_SHELL" is sent **/
X---
X> 	
X57a58,59
X> 	
X>
X64c66
X<         if (isatube) qsclose();
X---
X>         if (isatube) qclose();
X67c69
X< #ifdef NO-VM		/* machine without virtual memory! */
X---
X> #ifdef NO-VM		
X72,73c74,75
X< 	  setuid(userid);	/* back to the normal user! */
X< 	  setgid(groupid);	/* and group id		    */
X---
X> 	  setuid(userid);	
X> 	  setgid(groupid);	
X100c102
X< 	/** pipe the tagged messages to the specified sequence.. **/
X---
X> 	
X105c107
X< 	message_list[0] = '\0';	/* NULL string to start... */
X---
X> 	message_list[0] = '\0';	
X
X
X
X
X
X
X
XJun  4 14:06 1986  diff of ./syscall.c in /ccc/mcgregor/elm2/src and /ccc/mcgreXgor/elm/src Page 2
X
X
X107c109
X< 	oldstat = header_table[current-1].status;	/* saved...      */
X---
X> 	oldstat = header_table[current-1].status;	
X117c119
X< 	header_table[current-1].status = oldstat;	/* ..and restored! */
X---
X> 	header_table[current-1].status = oldstat;	
X155,156d156
X< 	/** Print current message or tagged messages using 'printout'
X< 	    variable.  Error message iff printout not defined! **/
X157a158,159
X> 	
X>
X167c169
X< 	message_list[0] = '\0';	/* reset to null... */
X---
X> 	message_list[0] = '\0';	
X169,170c171,172
X< 	oldstat = header_table[current-1].status;	/* old one */
X< 	header_table[current-1].status |= TAGGED;	/* tag it  */
X---
X> 	oldstat = header_table[current-1].status;	
X> 	header_table[current-1].status |= TAGGED;	
X179c181
X< 	header_table[current-1].status = oldstat;	/* restored */
X---
X> 	header_table[current-1].status = oldstat;	
X205c207
X< 	unlink(filename);	/* remove da temp file! */
X---
X> 	unlink(filename);	
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
END-OF-FILE

if [ "$filename" != "/dev/null" ]
then
  size=`wc -c < $filename`

  if [ $size != 6628 ]
  then
    echo $filename changed - should be 6628 bytes, not $size bytes
  fi

  chmod 666 $filename
fi

# ---------- file src/getopt.c ----------

filename="src/getopt.c"

if [ -f $filename ]
then
  echo File \"$filename\" already exists\!  Skipping...
  filename=/dev/null		# throw it away
else
  echo extracting file src/getopt.c...
fi

cat << 'END-OF-FILE' > $filename
/**			getopt.c			**/

/** starting argument parsing routine... 

    (C) Copyright 1986 Dave Taylor
**/

#ifndef NULL
# define NULL		0
#endif

#define DONE		0
#define ERROR		-1

char *optional_arg;			/* optional argument as we go */
int   opt_index;			/* argnum + 1 when we leave   */

/***********************
   Typical usage of this routine is exemplified by;

	register int c;

	while ((c = get_options(argc, argv, "ad:f:")) > 0) {
	   switch (c) {
	     case 'a' : arrow_cursor++;		break;
	     case 'd' : debug = atoi(optional_arg);	break;
	     case 'f' : strcpy(infile, optional_arg); 
	                mbox_specified = 2;  break;
	    }
	 }

	 if (c == ERROR) {
	   printf("Usage: %s [a] [-d level] [-f file] <names>\n\n", argv[0]);
	   exit(1);
	}

***********************/

int  _indx = 1, _argnum = 1;

int
get_options(argc, argv, options)
int argc;
char *argv[], *options;
{
	/** Returns the character argument next, and optionally instantiates 
	    "argument" to the argument associated with the particular option 
	**/
	
	char        *word, *strchr();

	if (_argnum > argc) {	/* quick check first - no arguments! */
	  opt_index = argc;
	  return(DONE);
	}

	if (argv[_argnum] == NULL && _indx > 1) {    /* Sun compatability */
	  _argnum++;
	  _indx = 1;		/* zeroeth char is '-' */
	}
	else if (_indx >= strlen(argv[_argnum]) && _indx > 1) {
	  _argnum++;
	  _indx = 1;		/* zeroeth char is '-' */
	}

	if (_argnum > argc) {
	  opt_index = _argnum; /* no more args */
	  return(DONE);
	}

	if (_argnum == argc) {
	  opt_index = _argnum;
	  return(DONE);
	}

	if (argv[_argnum][0] != '-') {
	  opt_index = _argnum;
	  return(DONE);
	}

        word = strchr(options, argv[_argnum][_indx++]);

	if (strlen(word) == 0) 
	  return(ERROR);
	
	if (word[1] == ':') {

	  /** Two possibilities - either tailing end of this argument or the 
	      next argument in the list **/

	  if (_indx < strlen(argv[_argnum])) { /* first possibility */
	    optional_arg = (char *) (argv[_argnum] + _indx);
	    _argnum++;
	    _indx = 1;
	  }
	  else {				/* second choice     */
	    if (++_argnum >= argc) 
	      return(ERROR);			/* no argument!!     */

	    optional_arg = (char *) argv[_argnum++];
	    _indx = 1;
	  }
	}

	return((int) word[0]);
}
END-OF-FILE

if [ "$filename" != "/dev/null" ]
then
  size=`wc -c < $filename`

  if [ $size != 2253 ]
  then
    echo $filename changed - should be 2253 bytes, not $size bytes
  fi

  chmod 644 $filename
fi

if [ ! -d test ]
then
  echo creating directory test
  mkdir test
fi

# ---------- file test/test.mail ----------

filename="test/test.mail"

if [ -f $filename ]
then
  echo File \"$filename\" already exists\!  Skipping...
  filename=/dev/null		# throw it away
else
  echo extracting file test/test.mail...
fi

sed 's/^X//' << 'END-OF-FILE' > $filename
XFrom root Wed Oct 30 14:03:36 1985
X>From srmmail Wed Oct 30 14:10:08 1985  remote from veeger
X>From hplabs Wed Oct 30 14:00:16 1985 remote from hpcnof
X>From hpl-opus!poulton  Wed Oct 30 02:06:16 1985 remote from hplabs
XDate: Wed, 30 Oct 85 01:55:05 pst
XFrom: <hplabs!hpl-opus!poulton>
XReceived: by HP-VENUS id AA26352; Wed, 30 Oct 85 01:55:05 pst
XMessage-Id: <8510300955.AA26352@HP-VENUS>
XTo: hpcnou!dat
XSubject: Re: announce(1)
X
XThe announce I got was shar'd July 8.   NLEN was not defined in that
Xsource, just used.  LONG_SLEN is not defined in the newmail(1)
Xthat you sent me.  What system are you running on?
XMy s500 doesn't have these def's.
X
X	-> Monday, January 3rd: Call your mother
X
XAs to announce --> newmail: why the switch?
XSeems like both are useful, in different situations.
X
XKen Poulton
XHPL
X
X
X
X
XFrom root Wed Oct 30 14:03:39 1985
X>From srmmail Wed Oct 30 14:10:12 1985  remote from veeger
X>From hplabs Wed Oct 30 13:59:53 1985 remote from hpcnof
X>From fowler  Wed Oct 30 12:57:11 1985 remote from hplabs
XDate: Wed, 30 Oct 85 12:57:11 pst
XFrom: Greg Fowler <hplabs!fowler>
XReceived: by HP-VENUS id AA12562; Wed, 30 Oct 85 12:57:11 pst
XMessage-Id: <8510302057.AA12562@HP-VENUS>
XTo: mail-men@rochester
XSubject: Re: Summary of Network Mail Headers
XReferences: <36700044@hpcnof.UUCP>
XPriority: Most Urgent
X
XI believe your introduction referred to the uucp network.  usenet is the networXk news
Xsoftware mechanism and isn't a "network".
X
X	- > February 19, 1986
X	-
X	-    A longer test of the system
X	-
X
X	Greg
X
X
X
XFrom root Wed Oct 30 14:13:23 1985
X>From srmmail Wed Oct 30 14:20:08 1985  remote from veeger
X>From root Wed Oct 30 14:01:57 1985 remote from hpcnof
XTo: DCC@hplabs
XSubject: Log of backup tape #1
X
X 
XFull Backup starting at Wed Oct 30 12:45:14 MST 1985
X 
X
X
Xbacking up directories: 
X	./users/fh ./users/rmd ./users/vince ./users/roberts ./users/row ./users/dt ./Xlost+found ./users/lost+found ./users/scb ./users/kevin ./users/du
X
X
X
X
X
XFrom root Wed Oct 30 15:33:24 1985
X>From srmmail Wed Oct 30 15:40:26 1985  remote from veeger
X>From root Wed Oct 30 15:37:17 1985 remote from hpcnof
XTo: root, uucp, taylor@hplabs.ARPA
XSubject: Log of backup tape #2
X
Xbacking up directories: 
X	./users/fh ./users/rmd ./users/vince ./users/roberts ./users/row ./users/dt ./Xlost+found ./users/lost+found ./users/scb ./users/kevin ./users/du
X
X
X
X
Xbacking up directories: 
X	./users/sbh ./users/ges ./users/cpb ./users/amy ./net ./users/root ./users/balXza ./dev ./users/remple ./users/jr ./users/mwr ./users/larryf
X
X
X
X
X
XFrom root Sun Dec  8 22:50:18 1985
X>From srmmail Mon Dec  9 00:50:05 1985 remote from veeger
X>From root Mon Dec  9 00:41:15 1985 remote from hpcnof
X>From JLarson.pa@Xerox.ARPA  Sun Dec  8 20:45:55 1985 remote from hplabs
XDate: 8 Dec 85 20:36:36 PST (Sunday)
XFrom: hplabs!JLarson.pa@Xerox.ARPA
XSubject: How's it going, anyway?
XTo: hpcnou!dat@HPLABS.ARPA (Dave Taylor)
XCc: JLarson.pa@Xerox.ARPA
X
XHow are things with you?  Could you send me that paper we were talking
Xabout?  
X
X	Thanks
X
XJohn Larson
XXerox Palo Alto Research Center
X3333 Coyote Hill Road
XPalo Alto, Ca  94304
X
X
X
X
XFrom root Wed Aug  7 19:58:30 1985
X>From uucp Wed Aug  7 19:55:12 1985  remote from veeger
X>From hplabs Wed Aug  7 19:48:10 1985 remote from hpcnof
X>From RICHER@SUMEX-AIM  Wed Aug  7 09:23:12 1985 remote from hplabs
XReceived: by HP-VENUS id AA18269; Wed, 7 Aug 85 09:11:48 pdt
XDate: Tue 6 Aug 85 09:12:37-PDT
XFrom: Mark Richer <hplabs!RICHER@SUMEX-AIM>
XReceived: by HP-VENUS via CSNET; 7 Aug 1985 09:11:37-PDT (Wed)
XReceived: from sumex-aim.arpa by csnet-relay.arpa id a015812; 6 Aug 85 12:14 EDXT
XTo: hpcnof!veeger!hpcnou!dat%hplabs.csnet@CSNET-RELAY
XVia:  CSNet; 7 Aug 85 9:11-PDT
XSubject: Re: AI in Education mailing list...
XCc: RICHER@SUMEX-AIM
XIn-Reply-To: <8508030243.AA27641@HP-VENUS>
XMessage-Id: <12132987812.61.RICHER@SUMEX-AIM.ARPA>
X
XI added you to aied.  This message may be of interest to you:
X
XArtificial Intelligence in Education Meeting at IJCAI 85
X---------- ------------ -- --------- ------- -- ----- --
X
XPlace: Math Sciences Auditorium (a.k.a. Math 4000A), UCLA campus
XTime: 6:30 pm, Tuesday, Aug. 20, 1985  (length: 1 - 1 1/4 hr)
X
XAgenda:
X	I have two speakers scheduled to make presentations that
Xshould stimulate questions and discussions:
X
X	(1) Short Announcements
X
X	(2) Jeff Bonar, Research Scientist, Learning Research and
X	Development Center (LRDC), University of Pittsburgh
X
X	--- on-going ICAI research projects at LRDC
X	--- dissemination of ICAI technology in the form of software
X	tools, workshops, written materials, and video tapes.
X
X	(3) Gary Fine, Product Engineering Manager, INTELLICORP,
X	formerly with a company producing CAI products, also graduate
X	work in ICAI  
X
X	--- bridging the gap between current ICAI technology and the
X	real world
X
X[IJCAI-85, the 9th International Joint Conference on Artificial
XIntelligence is being held at UCLA Campus, August 18-23, 1985.  This
Xconference is co-sponsered by the American Association for Artificial
XIntelligence (AAAI) this year, and I have been told by their office
Xthat only walk-in registration is available at this time.  For more
Xinformation, contact AAAI:  AAAI-OFFICE@SUMEX-AIM.ARPA
X			    AAAI, 445 Burgess Drive, Menlo Park, CA 94025
X			    or call (415) 328-3123]
X
XDirect questions on the AI in ED meeting (only) to Mark Richer,
XRICHER@SUMEX-AIM.ARPA
X-------
X
X
X
X
XFrom root Tue Sep 24 09:53:24 1985
X>From HPMAIL-gateway Tue Sep 24  9:46:47 1985  remote from veeger
X>From Simon_CINTZ_/_HPD600/TR  Tue Sep 24  9:46:47 1985  remote from hpmail
XDate:   Tue, 24 Sep 85  9:14:00 MDT
XFrom:   Simon_CINTZ_/_HPD600/TR  (Simon Cintz)
XSubject: ITF
XFrom:   Simon_CINTZ_/_HPD600/TR  (Simon Cintz)
XTo:     Dave_TAYLOR_/_HPF100/00
X
XDave -
X
XJust as one programming language doesn't suit the needs of
Xall programmers, one authoring facility will probably not
Xsuit the needs of all HP entities that require CBT -- at least
Xnot in the near future.  Of course, this is my personal opinion
Xand if I'm wrong, it won't be the first time.
X
XGood luck.
X
X
X                                           - Simon
X
XFrom root Mon Oct 21 10:43:37 1985
X>From srmmail Mon Oct 21 10:30:16 1985  remote from veeger
X>From root Mon Oct 21 10:28:58 1985 remote from hpcnof
X>From DLS.MDC%office-X.arpa@CSNET-RELAY  Mon Oct 21 01:57:05 1985 remote from hXplabs
XReceived: by HP-VENUS id AA17376; Mon, 21 Oct 85 01:57:05 pdt
XDate: 21 Oct 85 01:02 EDT
XFrom: Duane Stone / McDonnell Douglas / CSC-ASD <hplabs!DLS.MDC%office-1.arpa@CXSNET-RELAY>
XReceived: by HP-VENUS via CSNET; 21 Oct 1985 01:57:01-PDT (Mon)
XReceived: from office-1.arpa by CSNET-RELAY.ARPA id a019220; 21 Oct 85 1:18 EDTX
XTo: Dave Taylor <hpcnou!dat%hplabs.csnet@CSNET-RELAY>
XVia:  CSNet; 21 Oct 85 1:56-PDT
XSubject: Re: More Mail Headers...
XMessage-Id: <MDC-DLS-7W9CS@OFFICE-1>
XComment: Dave -- this is the body of the message I previously 'sent' to you viaX
X
Xa Journal.
X
XI might suggest re-wording the para on Author -- my associates might object to X
X'strange' -- something like:
X
X   This is used to credit the original author, or to give credit on article 
X   excerpts (from Newspapers, magazines, books, etc).
X
XOne field which I forgot is:
X
X   Length:  This is computed when the message is sent and gives the recipients X
X   an estimate of the number of pages in the document.
X
X   Example:
X
X      Length: 6 pages [estimate]
X
XAccess:
X
X   Used to declare whether a Journal item should be Public or Private (to thoseX
X   that are on the distribution list or Extended Access list)
X
X   Example:
X
X      Access: Unrestricted
X
XAcknowledge-Delivery:
X
X   Used to request the system mailer send back a message when it has 
X   successfully delivered the item.
X
X   Example:
X
X      Acknowledge-Delivery: Requested
X
XAcknowledge-Receipt:
X
X   Used to to ask the recipient to acknowledge receipt of the message.
X
X   Example:
X
X   Acknowledge-Receipt: Requested
X
XAddendum-To:
X
X   A pointer to a previously submitted Journal item.
X
X   Example:
X
X      Addendum-To: <ASD,1234,>
X
XDelivery-Timing:
X
X   Used by the sender to indicate when the message should be submitted to the 
X   mailer.
X
X      Examples:
X
X         Rush:       -   immediate
X
X         Soon:       -   as soon as possible
X
X         Defer:      -   overnight
X
X         Start-Delivery: DATE TIME
X
X         Stop-Delivery:  DATE TIME (if not yet delivered)
X
XDisposition-Code:
X
X   Used by the system to group Journal items into one of several classes for 
X   eventual archive to tape and as an indicator of how long the archive tapes 
X   should be retained.
X
X   Example:
X
X      Disposition-Code: Temporary (2 years)
X
XExtended-access:
X
X   Used with private Journal items to allow access by other than those on the 
X   distribution list.
X
X   Example:
X
X      Extended-access: ASD.MDC
X
XLocation:
X
X   Used to submit the message to the Journal.  The adressees receive a short 
X   citation with other header fields and a "Location:" field pointing to a fileX
X   in an electronic library.
X
X   Example:
X
X      Location: <MDC,1234,>
X
XPart-Of:
X
X   A pointer to a previously submitted Journal item.
X
X   Example:
X
X      Part-Of: <MDC,1234,>
X
XRoute-To:
X
X   Used to send a message "in-turn" to addressees in the "To:" field -- as 
X   opposed to the broadcast method of delivery where everyone gets the message X
X   "simultaneously".  Any addresses in the "Cc:" field receive a copy of the 
X   message each time it is passed from one adressee to the next in the "To:" 
X   field.
X
X   Example:
X
X      Routed-to: {addresses in To field}
X
XSigned:
X
X   Created when the user employs the Sign command; used to electronically sign X
X   a message.  It affixes a signature-block to a message.  A "Verify Signature"X
X   command is available to recipients that lets them find out if anyone has 
X   changed the body of the message since the message was signed.
X
X   Example:
X
X          SIGNED
X      
X      Duane L. Stone
X      App. Dev. Mgr.
X
XSupersedes:
X
X   A pointer to a previously submitted Journal item.
X
X   Example:
X
X      Supersedes: <MDC,1234,>
X
X
X--- last line of the file --
END-OF-FILE

if [ "$filename" != "/dev/null" ]
then
  size=`wc -c < $filename`

  if [ $size != 9977 ]
  then
    echo $filename changed - should be 9977 bytes, not $size bytes
  fi

  chmod 644 $filename
fi

# ---------- file test/test.notes ----------

filename="test/test.notes"

if [ -f $filename ]
then
  echo File \"$filename\" already exists\!  Skipping...
  filename=/dev/null		# throw it away
else
  echo extracting file test/test.notes...
fi

cat << 'END-OF-FILE' > $filename
/***** hpfloat:net.micro.68K / barrett /  2:39 pm  Dec 16, 1985*/
Does anyone here at this site know anything about hang-gliding? 

I am thinking of learning to hang-glide, but am afraid of heights.  I
do fly light planes and love the hairiest roller coaster rides available
however.  My main question is "is there a way to learn to hang-glide 
gradually?"  I have seen some films of people learning on big sand dunes
an such before leaping off of cliffs with the things.  

Dave Barrett
hpfcla!barrett
/* ---------- */
/***** hpcnof:fsd.rec / hpfcla!ajs /  5:57 pm  Dec 16, 1985*/
> Does anyone here at this site know anything about hang-gliding? 

Yeah.  Don't waste your time, don't waste your money, don't risk your life.

> I am thinking of learning to hang-glide, but am afraid of heights.

I wasn't, but it still got me a broken arm.

> My main question is "is there a way to learn to hang-glide gradually?"

Probably not (yet).  Five years ago, simulators were in practice non-
existent.  We got twenty seconds hanging in a triangular control bar
with a person pushing.  Next stop, rocky slopes, real gliders, and cheap
walkie-talkies.

You'd be amazed how easy it is to injure yourself.  It's the nature of
the hobby.  People with plenty of experience die doing it every day,
due to circumstances often beyond their control.  There are better ways
to get thrills.

Alan
/* ---------- */
/***** hpcnof:fsd.rec / hpfcms!mpm /  8:58 pm  Dec 16, 1985*/

>You'd be amazed how easy it is to injure yourself.  It's the nature of
>the hobby.  People with plenty of experience die doing it every day,
>due to circumstances often beyond their control.  There are better ways
>to get thrills.
>Alan

     I haven't done any hang-gliding myself, but I would like to try it
some day.  (I have a moderate fear of heights; it depends on the altitude
and the apparent stability of my "perch".)

     I read (or heard) that MOST hang-gliding accidents fall into two
categories:

     1) novices attempt something beyond their experience (like jumping
	off a tall building after one lesson on a gently sloped hill),

     2) experts attempt VERY dramatic stuff (like jumping off El
	Capitan in unpredictable thermal up- and down- drafts).

     Please note:  Alan Silverstein doesn't fall in EITHER category.  I
took some sport parachuting lessons a few years ago.  It turned out to be
quite safe GIVEN ADEQUATE TRAINING as I had at the time.  I suspect the
same would hold true for hang-gliding (or rapelling, or ice climbing, or
...).  The best way to find out if you can overcome your fears is by con-
fronting them in a safe and supportive environment.

     My recommendation:  check out any "school" before you sign up.  Ask
about their safety record, the terrain where they offer lessons, amount of
"ground school" training before first "flight", etc.  Above all, make sure
that you TRUST any prospective teacher.  Even if you have no logical reason
to distrust someone, don't try something like this unless you trust them.
(This is where your rational mind needs to work with your intuition.)
Otherwise you could easily get hurt.

     This is likely to be unknown territory for you, so be prepared and
you will likely have a more enjoyable (and safe) experience.  Of course,
there is ALWAYS the chance for an accident.

	-- Mike "no I wasn't crazy at the time; I WANTED to do it" McCarthy
	   hpfcla!mpm
/* ---------- */
/***** hpcnof:fsd.rec / dat / 12:12 pm  Dec 19, 1985*/
>> Does anyone here at this site know anything about hang-gliding? 
>Yeah.  Don't waste your time, don't waste your money, don't risk your life.

	Strong stuff!  I think you're out on a limb this time, Alan.
I've known lots of people who've hang-glided and never gotten hurt.
(and we're talking the La Jolla cliffs in San Diego!!) (they also
think it's the best 'high' in the world (and they've tried some
pretty strange things to compare!))

>> I am thinking of learning to hang-glide, but am afraid of heights.
>I wasn't, but it still got me a broken arm.

	Fine.  So I broke my arm a long time ago jumping off a bunk
bed.  Does this mean that bunk beds are too dangerous and that I 
shouldn't ever sleep in one???

	The point is that anything you do is dangerous and that the
way to minimize the danger is to take things gradually and only 
progress when you feel comfortable with your current level of learning.
At the same time realize that even sitting in a chair in a warm room
could be dangerous, so don't be so foolishly optimistic to think that
you cannot get seriously hurt hang-gliding.

	On the other hand - if you want to go for it - GO FOR IT!!!

			-- Dave "Cheap Thrills, Inc." Taylor
/* ---------- */
/***** hpcnof:fsd.rec / hpfcmp!rjn / 11:33 pm  Dec 16, 1985*/
re: hang gliding

I am a licensed [so what] pilot in powered  aircraft and  sailplanes.  I was
taking  hang  gliding  (HG)  instruction  four years ago (prior to moving to
Colorado).  I gave it up when I moved here.  My impressions:

* If your  introduction  to piloting flying machines is via HG, you will not
  have enough  understanding of aerodynamics to safely operate your craft in
  calm or steady-wind conditions.

* HGs which are controlled by weight  shifting do not have adequate  control
  authority   for   normal   conditions,   unless   you  have  lots  of  the
  aforementioned  understanding and fly only in ideal  conditions.  HGs with
  3-axis control offer a little more margin.

* HGs are typically operated close to the ground.  No HG designs have enough
  control  authority  to handle  gusty  conditions.  You can  safely  land a
  parachute in conditions  which are dangerous for HG  operation.  Flying in
  gusty  conditions  is the most  popular  way to crash a HG.  If you  think
  jumping is dangerous, don't take up HG.  (I used to room with a jumpmaster
  and have made one jump myself.  I think jumping is safer.)

* HGs operated at higher altitudes (away from ground  reference) suffer from
  lack of  instrumentation.  It is easy to enter a spiral dive, spin or deep
  stall (luff the sail on Rogallo machines)  without  instruments or lots of
  experience.  Spiral dives usually  overstress  the airframe; the resulting
  collection of parts crashes.

If you  insist on K-Mart  aviating,  I suggest a 2-place  ultra-light  (with
parachute), a good instructor and a calm day.  At least the ground is level.
Bring earplugs.

Bob Niland  TN-226-4014   HP-UX: hpfcla!rjn    DESK: rjn (hpfcla) /HP4000/UX
/* ---------- */
/***** hpcnof:fsd.rec / hpfloat!jim /  9:10 am  Dec 17, 1985*/
Try flying across the waves on a windsurfer!  I once met a guy from
Denver who said he had tried them all--hang gliding, sky diving.  Windsurfing
offered just as much thrill with almost no risk.

The crash landings are rather painless.  I've gotten 5 feet of air right
here in Colorado.

		"Jumping Jim" Tear

/* ---------- */
/***** hpcnof:fsd.rec / hpfcmt!ron /  7:56 am  Dec 17, 1985*/


I also am a "regular" aircraft (and sailplane) pilot.

I have not tried hang gliding however I have a fairly close friend who 
was into it before he totally demolished his craft. He was only bruised
by the impact but came away considerably more careful about his sports.

Besides the previously mentioned drawbacks I would like to mention the 
following:

A perfect landing consists of

   (a) Correct airspeed
   (b) Level wings ( tolerance to prevent wingtip dragging)
   (c) Correct yaw alignment   (within tolerance of landing gear)
   (d) Correct pitch
   (e) Correct rate of descent  (within tolerance of landing gear)
   (f) Correct altitude
   (g) Correct groundspeed (within tolerance of landing gear) 

Consider that the landing gear on an HG is your legs and gear collapse
is fairly common due to the low maximum speed for the gear and the 
airspeed being right in that range at touchdown.
Consider also that even calm air has some "breezes" going. 
Add to the "breezes" the fact that your control authority relative to the
velocity of the breezes is poor and you can wind up with all the ingredients
for a face plant.

Now to moderate the above, the idea of simple flight appeals greatly to
me. Unfortunately my personal risk-taking threshold is below the minimum
risk for this sport.  
I agree with Bob, try ultra-lights if you MUST . At least they have wheels.


Ron Miller


"Show me a country where the newspapers are filled with good news
and I'll show you a country where the jails are filled with good people."
					-<I forgot>

Service Engineering  (Hardware Support)
Hewlett-Packard Co.
Ft. Collins Systems Div. Home of the HP 9000 Series 200,300 & 500
Ft. Collins Colorado
303-226-3800

at: {ihnp4}hpfcla!ron
/* ---------- */
/***** hpcnof:fsd.rec / hpfcla!ajs /  6:36 pm  Dec 19, 1985*/
> Strong stuff!  I think you're out on a limb this time, Alan.
> I've known lots of people who've hang-glided and never gotten hurt.

Yes, but, --

> Fine.  So I broke my arm a long time ago jumping off a bunk
> bed.  Does this mean that bunk beds are too dangerous and that I 
> shouldn't ever sleep in one???

I'll be more explicit (and just as strong).  Let's say sleeping is a
zero (epsilon?) on the risk scale, and flying in a commercial aircraft
is 1, and driving a car, oh, I'd guess about a 4, and parachuting maybe
a 6, and SCUBA diving must be maybe a 7 or 8 then, comparable (?) with
climbing Fourteeners.  Based on my experience with it, I'd rank hang
gliding at around a 12 or 15.  Don't risk your life.

One thing I discovered is that being under a "kite" feels very different
from how you might guess while watching someone fly.  Not nearly as
comfortable (until airborne); very exposed.  Some people are naturals at
it; some (like me) are not.  If you are the former, and you are lucky,
and it appeals to you, you'll go do it anyway, no matter what I or Dave
say about it; good luck to you.

But, if you are the latter, you'll likely injure yourself seriously
trying to learn, because there isn't much margin for error outside a
simulator.  Look, I was gung-ho, being trained by a "professional"
training school, determined to overcome inexperience, ignored warnings
from concerned friends, was certain I could do it safely, paid close
attention to instructions, studied the subject intensely, and when I
crashed, I'd been in the air about five seconds, was about ten feet off
the ground, and was amazed that I'd actually broken anything.  A very
sobering experience.

On the way to the hospital, the trainer doing the driving informed me
that someone was seriously injured in their classes about once a month.

Gee, Dave, I guess I must be "out on a limb", incapable of giving advice
on the subject, because I survived the crash.  :-)

Alan
/* ---------- */
/***** hpcnof:fsd.rec / hpfcde!anny /  2:28 pm  Dec 31, 1985*/
WARNING:  Severe Base Note  D  r   i    f      t

<. . . and driving a car, oh, I'd guess about a 4, and parachuting maybe
<a 6, and SCUBA diving must be maybe a 7 or 8 then, . . .

Come on Alan!  SCUBA diving more dangerous than parachuting?  Maybe if your
parachuting off a jump tower versus SCUBA diving alone on the Great Barrier
Reef at night carring shark bait making wounded fish sounds. . . ;-)

After all, the FIRST time you parachute, you have to jump out of a PLANE! (/.\)
In the SKY!  You can SCUBA dive in a pool or a shallow lake or inlet.
If something goes wrong in the water, your buddy's there to help.  If 
something goes wrong in the sky, so long . . .

Just defending what I consider to be a fun and safe sport!

Anny (low altitude (4' or less) sports for me!) Randel
/* ---------- */
/***** hpcnof:fsd.rec / hpfcla!ajs /  9:27 am  Jan  2, 1986*/
> Come on Alan!  SCUBA diving more dangerous than parachuting?

Forgive me, I was just guessing, to make a point.  I don't know the
actual statistics, but you're probably right -- if you measure accidents
per hour.  On the other hand, if you measure accidents per jump or dive,
it wouldn't surprise me if the rates were similar.  Lotsa people go
diving without enough training, but skydiving requires decent training
and the accident rate is surprisingly low.

Alan "pick your poison" Silverstein
/* ---------- */
/***** hpcnof:fsd.rec / hpfcdc!donn /  9:32 am  Jan  3, 1986*/
The problem with SCUBA diving is the fact that "fly by nites" can
afford to get into the business.  A reputable dive shop will not
let you rent a tank unless you have a NAUI card (or ==) (and they'll hold
it while you have the tanks).  However there are always some who
will not do this, and some clown tries diving without essentially
any training ("Gee, I can swim, so I can dive.") and gets into
trouble.  It's much tougher to be a "fly by night" (or anytime)
when you need an airplane and a pilot's license.  Actually, the
accident rate for people with any significant training *and* who
are doing something more-or-less reasonable is not bad.  (Diving
below 150ft (or maybe less) is like starting a jump at 50000 feet:
it might work, but good luck unless you know what you're doing. 
The problem is that there isn't much reason to start at 50000 feet,
but there's a lot of interesting and valuable stuff below 150.)

I like to dive (tropical saltwater only, so I don't do it much),
and since one of the graduation exercises is diving while someone
is *trying* to make you screw up (albeit in a pool where there's
someone to fish you out), you learn to handle problems.  If you're
gutsy, try the NAUI *instructors* class: the graduation from that
is a open-water dive with known defective equipment!

Donn
/* ---------- */
END-OF-FILE

if [ "$filename" != "/dev/null" ]
then
  size=`wc -c < $filename`

  if [ $size != 13582 ]
  then
    echo $filename changed - should be 13582 bytes, not $size bytes
  fi

  chmod 644 $filename
fi

# ---------- file test/test.empty ----------

filename="test/test.empty"

if [ -f $filename ]
then
  echo File \"$filename\" already exists\!  Skipping...
  filename=/dev/null		# throw it away
else
  echo extracting file test/test.empty...
fi

cat << 'END-OF-FILE' > $filename
END-OF-FILE

if [ "$filename" != "/dev/null" ]
then
  size=`wc -c < $filename`

  if [ $size != 0 ]
  then
    echo $filename changed - should be 0 bytes, not $size bytes
  fi

  chmod 644 $filename
fi

if [ ! -d utils ]
then
  echo creating directory utils
  mkdir utils
fi

# ---------- file utils/answer.c ----------

filename="utils/answer.c"

if [ -f $filename ]
then
  echo File \"$filename\" already exists\!  Skipping...
  filename=/dev/null		# throw it away
else
  echo extracting file utils/answer.c...
fi

cat << 'END-OF-FILE' > $filename
/**			answer.c			**/

/** This program is a phone message transcription system, and
    is designed for secretaries and the like, to allow them to
    painlessly generate electronic mail instead of paper forms.

    Note: this program ONLY uses the local alias file, and does not
	  even read in the system alias file at all.

    (C) Copyright 1986, Dave Taylor

**/

#include <stdio.h>
#include <fcntl.h>
#include <ctype.h>

#include "defs.h"			/* ELM system definitions      */

#define  ELM		"elm"		/* where the elm program lives */

static char ident[] = { WHAT_STRING };

struct alias_rec user_hash_table  [MAX_UALIASES];

int user_data;		/* fileno of user data file   */

char *expand_group(), *get_alias_address(), *get_token();

main()
{
	FILE *fd;
	char *address, buffer[LONG_STRING], tempfile[SLEN];
	char  name[SLEN], user_name[SLEN];
	int   msgnum = 0, eof;
	
	read_alias_files();

	while (1) {
	  if (msgnum > 9999) msgnum = 0;
	
	  printf("\n-------------------------------------------------------------------------------\n");

prompt:   printf("\nMessage to: ");
	  gets(user_name, SLEN);
	  if (user_name == NULL)
	    goto prompt;
	  
	  if ((strcmp(user_name,"quit") == 0) ||
	      (strcmp(user_name,"exit") == 0) ||
	      (strcmp(user_name,"done") == 0) ||
	      (strcmp(user_name,"bye")  == 0))
	     exit(0);

	  if (translate(user_name, name) == 0)
	    goto prompt;

	  address = get_alias_address(name, 1, 0);

	  if (address == NULL || strlen(address) == 0) {
	    printf("Sorry, could not find '%s' [%s] in list!\n", user_name, 
		   name);
	    goto prompt;
	  }

	  sprintf(tempfile, "%s%d", temp_file, msgnum++);

	  if ((fd = fopen(tempfile,"w")) == NULL)
	    exit(printf("** Fatal Error: could not open %s to write\n",
		 tempfile));


	  printf("\nEnter message for %s ending with a blank line.\n\n", 
		 user_name);

	  fprintf(fd,"\n\n");

	  do {
	   printf("> ");
	   if (! (eof = (gets(buffer, SLEN) == NULL))) 
	     fprintf(fd, "%s\n", buffer);
	  } while (! eof && strlen(buffer) > 0);
	
	  fclose(fd);
 
	  sprintf(buffer, "(%s -s \"While You Were Out\" %s < %s ; %s %s) &", 
	          ELM, address, tempfile, remove, tempfile);

	  system(buffer);
	}
}

int
translate(fullname, name)
char *fullname, *name;
{
	/** translate fullname into name..
	       'first last'  translated to first_initial - underline - last
	       'initial last' translated to initial - underline - last
	    Return 0 if error.
	**/
	register int i, lastname = 0;

	for (i=0; i < strlen(fullname); i++) {

	  if (isupper(fullname[i]))
	     fullname[i] = fullname[i] - 'A' + 'a';

	  if (fullname[i] == ' ') 
	    if (lastname) {
	      printf(
	      "** Can't have more than 'FirstName LastName' as address!\n");
	      return(0);
	    }
	    else
	      lastname = i+1;
	
	}

	if (lastname) 
	  sprintf(name, "%c_%s", fullname[0], (char *) fullname + lastname);
	else
	  strcpy(name, fullname);

	return(1);
}

	    
read_alias_files()
{
	/** read the user alias file **/

	char fname[SLEN];
	int  hash;

	sprintf(fname,  "%s/.alias_hash", getenv("HOME")); 

	if ((hash = open(fname, O_RDONLY)) == -1) 
	  exit(printf("** Fatal Error: Could not open %s!\n", fname));

	read(hash, user_hash_table, sizeof user_hash_table);
	close(hash);

	sprintf(fname,  "%s/.alias_data", getenv("HOME")); 

	if ((user_data = open(fname, O_RDONLY)) == -1) 
	  return;
}

char *get_alias_address(name, mailing, depth)
char *name;
int   mailing, depth;
{
	/** return the line from either datafile that corresponds 
	    to the specified name.  If 'mailing' specified, then
	    fully expand group names.  Returns NULL if not found.
	    Depth is the nesting depth, and varies according to the
	    nesting level of the routine.  **/

	static char buffer[VERY_LONG_STRING];
	int    loc;

	if ((loc = find(name, user_hash_table, MAX_UALIASES)) >= 0) {
	  lseek(user_data, user_hash_table[loc].byte, 0L);
	  get_line(user_data, buffer, LONG_STRING);
	  if (buffer[0] == '!' && mailing)
	    return( (char *) expand_group(buffer, depth));
	  else
	    return( (char *) buffer);
	}
	
	return( (char *) NULL);
}

char *expand_group(members, depth)
char *members;
int   depth;
{
	/** given a group of names separated by commas, this routine
	    will return a string that is the full addresses of each
	    member separated by spaces.  Depth is the current recursion
	    depth of the expansion (for the 'get_token' routine) **/

	char   buffer[VERY_LONG_STRING];
	char   buf[LONG_STRING], *word, *address, *bufptr;

	strcpy(buf, members); 	/* parameter safety! */
	buffer[0] = '\0';	/* nothing in yet!   */
	bufptr = (char *) buf;	/* grab the address  */
	depth++;		/* one more deeply into stack */

	while ((word = (char *) get_token(bufptr, "!, ", depth)) != NULL) {
	  if ((address = (char *) get_alias_address(word, 1, depth)) == NULL) {
	    fprintf(stderr, "Alias %s not found for group expansion!", word);
	    return( (char *) NULL);
	  }
	  else if (strcmp(buffer,address) != 0) {
	    sprintf(buffer,"%s %s", buffer, address);
	  }

	  bufptr = NULL;
	}

	return( (char *) buffer);
}

int
find(word, table, size)
char *word;
struct alias_rec table[];
int size;
{
	/** find word and return loc, or -1 **/
	register int loc;
	
	if (strlen(word) > 20)
	  exit(printf("Bad alias name: %s.  Too long.\n", word));

	loc = hash_it(word, size);

	while (strcmp(word, table[loc].name) != 0) {
	  if (table[loc].name[0] == '\0') 
	    return(-1);
	  loc = (loc + 1) % size; 
	}

	return(loc);
}

int
hash_it(string, table_size)
char *string;
int   table_size;
{
	/** compute the hash function of the string, returning
	    it (mod table_size) **/

	register int i, sum = 0;
	
	for (i=0; string[i] != '\0'; i++)
	  sum += (int) string[i];

	return(sum % table_size);
}

get_line(fd, buffer)
int fd;
char *buffer;
{
	/* read from file fd.  End read upon reading either 
	   EOF or '\n' character (this is where it differs 
	   from a straight 'read' command!) */

	register int i= 0;
	char     ch;

	while (read(fd, &ch, 1) > 0)
	  if (ch == '\n' || ch == '\r') {
	    buffer[i] = 0;
	    return;
	  }
	  else
	    buffer[i++] = ch;
}

print_long(buffer, init_len)
char *buffer;
int   init_len;
{
	/** print buffer out, 80 characters (or less) per line, for
	    as many lines as needed.  If 'init_len' is specified, 
	    it is the length that the first line can be.
	**/

	register int i, loc=0, space, length; 

	/* In general, go to 80 characters beyond current character
	   being processed, and then work backwards until space found! */

	length = init_len;

	do {
	  if (strlen(buffer) > loc + length) {
	    space = loc + length;
	    while (buffer[space] != ' ' && space > loc + 50) space--;
	    for (i=loc;i <= space;i++)
	      putchar(buffer[i]);
	    putchar('\n');
	    loc = space;
	  }
	  else {
	    for (i=loc;i < strlen(buffer);i++)
	      putchar(buffer[i]);
	    putchar('\n');
	    loc = strlen(buffer);
	  }
	  length = 80;
	} while (loc < strlen(buffer));
}

/****
     The following is a newly chopped version of the 'strtok' routine
  that can work in a recursive way (up to 20 levels of recursion) by
  changing the character buffer to an array of character buffers....
****/

#define MAX_RECURSION		20		/* up to 20 deep recursion */

#undef  NULL
#define NULL			(char *) 0	/* for this routine only   */

extern int strspn();
extern char *strpbrk();

char *get_token(string, sepset, depth)
char *string, *sepset;
int  depth;
{

	/** string is the string pointer to break up, sepstr are the
	    list of characters that can break the line up and depth
	    is the current nesting/recursion depth of the call **/

	register char	*p, *q, *r;
	static char	*savept[MAX_RECURSION];

	/** is there space on the recursion stack? **/

	if (depth >= MAX_RECURSION) {
	 fprintf(stderr,"Error: Get_token calls nested greated than %d deep!\n",
			MAX_RECURSION);
	 exit(1);
	}

	/* set up the pointer for the first or subsequent call */
	p = (string == NULL)? savept[depth]: string;

	if(p == 0)		/* return if no tokens remaining */
		return(NULL);

	q = p + strspn(p, sepset);	/* skip leading separators */

	if (*q == '\0')		/* return if no tokens remaining */
		return(NULL);

	if ((r = strpbrk(q, sepset)) == NULL)	/* move past token */
		savept[depth] = 0;	/* indicate this is last token */
	else {
		*r = '\0';
		savept[depth] = ++r;
	}
	return(q);
}
END-OF-FILE

if [ "$filename" != "/dev/null" ]
then
  size=`wc -c < $filename`

  if [ $size != 8370 ]
  then
    echo $filename changed - should be 8370 bytes, not $size bytes
  fi

  chmod 666 $filename
fi

echo end of this archive file....
exit 0

