Subject:  v18i019:  GNU Grep 1.2->1.3 patch kit
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: mike@thor.acc.stolaf.edu (Mike Haertel)
Posting-number: Volume 18, Issue 19
Archive-name: gnugrep1.3.pch


The diffs I sent you earlier today had a small bug in them, they
did not update the version reference in the README.  Enclosed are
the correct diffs, sorry for the inconvenience.

	Mike

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  cvt1.2to1.3
# Wrapped by rsalz@fig.bbn.com on Mon Mar 13 18:23:34 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'cvt1.2to1.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cvt1.2to1.3'\"
else
echo shar: Extracting \"'cvt1.2to1.3'\" \(46818 characters\)
sed "s/^X//" >'cvt1.2to1.3' <<'END_OF_FILE'
Xdiff -rcN grep-1.2/Makefile grep-1.3/Makefile
X*** grep-1.2/Makefile	Thu Oct 13 22:11:28 1988
X--- grep-1.3/Makefile	Tue Feb 28 23:37:13 1989
X***************
X*** 5,27 ****
X  # Add -DUSG for System V.
X  CFLAGS = -O
X  
X  # You may add getopt.o if your C library lacks getopt(); note that
X  # 4.3BSD getopt() is said to be somewhat broken.
X  # Add alloca.o if your machine does not support alloca().
X! OBJS = grep.o dfa.o regex.o
X  
X  all: regress
X  
X! regress: grep
X  	cd tests; sh regress.sh
X  
X! grep: $(OBJS)
X! 	$(CC) $(CFLAGS) -o grep $(OBJS)
X! 	rm -f egrep
X! 	ln grep egrep
X  
X  clean:
X! 	rm -f grep egrep *.o core tests/core tests/tmp.script
X  
X! dfa.o grep.o: dfa.h
X! grep.o regex.o: regex.h
X--- 5,40 ----
X  # Add -DUSG for System V.
X  CFLAGS = -O
X  
X+ #
X  # You may add getopt.o if your C library lacks getopt(); note that
X  # 4.3BSD getopt() is said to be somewhat broken.
X+ #
X  # Add alloca.o if your machine does not support alloca().
X! #
X! OBJS = dfa.o regex.o
X! GOBJ = grep.o
X! EOBJ = egrep.o
X  
X+ # Space provided for machine dependent libraries.
X+ LIBS =
X+ 
X  all: regress
X  
X! regress: egrep grep
X  	cd tests; sh regress.sh
X  
X! egrep: $(OBJS) $(EOBJ)
X! 	$(CC) $(CFLAGS) -o egrep $(OBJS) $(EOBJ) $(LIBS)
X! 
X! egrep.o: grep.c
X! 	$(CC) $(CFLAGS) -DEGREP -c grep.c
X! 	mv grep.o egrep.o
X! 
X! grep: $(OBJS) $(GOBJ)
X! 	$(CC) $(CFLAGS) -o grep $(OBJS) $(GOBJ) $(LIBS)
X  
X  clean:
X! 	rm -f grep egrep *.o core tests/core tests/tmp.script tests/khadafy.out
X  
X! dfa.o egrep.o grep.o: dfa.h
X! egrep.o grep.o regex.o: regex.h
Xdiff -rcN grep-1.2/README grep-1.3/README
X*** grep-1.2/README	Tue Dec 13 11:04:21 1988
X--- grep-1.3/README	Wed Mar  1 21:43:59 1989
X***************
X*** 1,4 ****
X! This README documents GNU e?grep version 1.2.
X  
X  Changes needed to the makefile under various perversions of Unix are
X  described therein.
X--- 1,4 ----
X! This README documents GNU e?grep version 1.3.
X  
X  Changes needed to the makefile under various perversions of Unix are
X  described therein.
Xdiff -rcN grep-1.2/README.sunos4 grep-1.3/README.sunos4
X*** grep-1.2/README.sunos4	Wed Dec 31 18:00:00 1969
X--- grep-1.3/README.sunos4	Tue Feb 28 22:35:10 1989
X***************
X*** 0 ****
X--- 1,96 ----
X+ Date:    Fri, 24 Feb 89 15:36:40 -0600
X+ To:      mike@wheaties.ai.mit.edu
X+ From:    Dave Cohrs <dave@cs.wisc.edu>
X+ Subject: bug + fix in gnu grep 1.2 (from prep.ai.mit.edu)
X+ 
X+ I tried installing the GNU grep 1.2 on a Sun4 running 4.0.1 and
X+ "Spencer test #36" failed.  After some experimenting, I found and
X+ fixed the bug.  Well, actually, the bug in the the C compiler, but
X+ I managed a workaround.
X+ 
X+ Description:
X+ 
X+ The Sun4 4.0.1 C compiler with -O doesn't generate the correct for
X+ statements of the form
X+ 	if("string")
X+ 		x;
X+ 	else
X+ 		y;
X+ To be exact, "y;" gets executed, while "x;" should.  This causes the
X+ #define FETCH() to fail for test #36.
X+ 
X+ Fix:
X+ 
X+ In an #ifdef sparc in dfa.c, I made two versions of FETCH, FETCH0() and
X+ the regular FETCH().  The former takes only one argument, the latter
X+ expects its 2nd argument to contain a non-nil string.  This removes
X+ the need to test the constant strings, and the compiler bug isn't
X+ exercised.  I then changed the one instance of FETCH() with a nil
X+ second argument to be FETCH0() instead.
X+ 
X+ dave cohrs
X+ 
X+ ===================================================================
X+ RCS file: RCS/dfa.c,v
X+ retrieving revision 1.1
X+ diff -c -r1.1 dfa.c
X+ *** /tmp/,RCSt1a05930	Fri Feb 24 15:32:33 1989
X+ --- dfa.c	Fri Feb 24 15:23:34 1989
X+ ***************
X+ *** 285,293 ****
X+ --- 285,315 ----
X+   				   is turned off). */
X+   
X+   /* Note that characters become unsigned here. */
X+ + #ifdef sparc
X+ + /*
X+ +  * Sun4 4.0.1 C compiler can't compare constant strings correctly.
X+ +  * e.g. if("test") { x; } else { y; }
X+ +  * the compiler will not generate code to execute { x; }, but
X+ +  * executes { y; } instead.
X+ +  */
X+ + #define FETCH0(c)   		      \
X+ +   {			   	      \
X+ +     if (! lexleft)	   	      \
X+ +       return _END;	   	      \
X+ +     (c) = (unsigned char) *lexptr++;  \
X+ +     --lexleft;		   	      \
X+ +   }
X+   #define FETCH(c, eoferr)   	      \
X+     {			   	      \
X+       if (! lexleft)	   	      \
X+ +       regerror(eoferr);  	      \
X+ +     (c) = (unsigned char) *lexptr++;  \
X+ +     --lexleft;		   	      \
X+ +   }
X+ + #else
X+ + #define FETCH(c, eoferr)   	      \
X+ +   {			   	      \
X+ +     if (! lexleft)	   	      \
X+         if (eoferr)	   	      \
X+   	regerror(eoferr);  	      \
X+         else		   	      \
X+ ***************
X+ *** 295,300 ****
X+ --- 317,323 ----
X+       (c) = (unsigned char) *lexptr++;  \
X+       --lexleft;		   	      \
X+     }
X+ + #endif sparc
X+   
X+   static _token
X+   lex()
X+ ***************
X+ *** 303,309 ****
X+ --- 326,336 ----
X+     int invert;
X+     _charset cset;
X+   
X+ + #ifdef sparc
X+ +   FETCH0(c);
X+ + #else
X+     FETCH(c, (char *) 0);
X+ + #endif sparc
X+     switch (c)
X+       {
X+       case '^':
Xdiff -rcN grep-1.2/dfa.c grep-1.3/dfa.c
X*** grep-1.2/dfa.c	Thu Oct 13 22:11:29 1988
X--- grep-1.3/dfa.c	Tue Feb 28 18:46:35 1989
X***************
X*** 105,110 ****
X--- 105,112 ----
X  You are forbidden to forbid anyone else to use, share and improve
X  what you give them.   Help stamp out software-hoarding!  */
X  
X+ #include <stdio.h>
X+ #include <assert.h>
X  #include <ctype.h>
X  #include "dfa.h"
X  
X***************
X*** 135,140 ****
X--- 137,143 ----
X  {
X    ptr_t r = malloc(n);
X  
X+   assert(n != 0);
X    if (r)
X      return r;
X    else
X***************
X*** 148,153 ****
X--- 151,157 ----
X  {
X    ptr_t r = realloc(p, n);
X  
X+   assert(n != 0);
X    if (r)
X      return r;
X    else
X***************
X*** 1122,1128 ****
X        {
X  	copy(&r->follows[i], &merged);
X  	epsclosure(&merged, r);
X! 	REALLOC(r->follows[i].elems, _position, merged.nelem);
X  	copy(&merged, &r->follows[i]);
X        }
X  
X--- 1126,1133 ----
X        {
X  	copy(&r->follows[i], &merged);
X  	epsclosure(&merged, r);
X! 	if (r->follows[i].nelem < merged.nelem)
X! 	  REALLOC(r->follows[i].elems, _position, merged.nelem);
X  	copy(&merged, &r->follows[i]);
X        }
X  
X***************
X*** 1719,1742 ****
X  Having found the postfix representation of the regular expression,
X  try to find a long sequence of characters that must appear in any line
X  containing the r.e.
X! Finding a "longest" sequence is beyond the scope of this bagatelle;
X! we take the easy way out and hope for the best.
X  
X! We do a bottom-up calculation of several (possibly zero-length) sequences
X! of characters that must appear in matches of r.e.'s represented by trees
X! rooted at the nodes of the postfix representation:
X  	sequences that must appear at the left of the match ("left")
X  	sequences that must appear at the right of the match ("right")
X! 	sequences that must appear somewhere in the match ("in")
X  	sequences that must constitute the match ("is")
X! When we get to the root of the tree, we use its calculated "in" sequence
X! as our answer.  The sequence we find is returned in r->must (where "r" is
X! the single argument passed to "regmust"); the length of the sequence is
X! returned in r->mustn.
X  
X  The sequences calculated for the various types of node (in pseudo ANSI c)
X  are shown below.  "p" is the operand of unary operators (and the left-hand
X! operand of binary operators); "q" is the right-hand operand of binary operators.
X  "ZERO" means "a zero-length sequence" below.
X  
X  Type	left		right		is		in
X--- 1724,1749 ----
X  Having found the postfix representation of the regular expression,
X  try to find a long sequence of characters that must appear in any line
X  containing the r.e.
X! Finding a "longest" sequence is beyond the scope here;
X! we take an easy way out and hope for the best.
X! (Take "(ab|a)b"--please.)
X  
X! We do a bottom-up calculation of sequences of characters that must appear
X! in matches of r.e.'s represented by trees rooted at the nodes of the postfix
X! representation:
X  	sequences that must appear at the left of the match ("left")
X  	sequences that must appear at the right of the match ("right")
X! 	lists of sequences that must appear somewhere in the match ("in")
X  	sequences that must constitute the match ("is")
X! When we get to the root of the tree, we use one of the longest of its
X! calculated "in" sequences as our answer.  The sequence we find is returned in
X! r->must (where "r" is the single argument passed to "regmust");
X! the length of the sequence is returned in r->mustn.
X  
X  The sequences calculated for the various types of node (in pseudo ANSI c)
X  are shown below.  "p" is the operand of unary operators (and the left-hand
X! operand of binary operators); "q" is the right-hand operand of binary operators
X! .
X  "ZERO" means "a zero-length sequence" below.
X  
X  Type	left		right		is		in
X***************
X*** 1749,1865 ****
X  
X  QMARK	ZERO		ZERO		ZERO		ZERO
X  
X! PLUS	p->left		p->right	ZERO		ZERO
X  
X! CAT	(p->is==ZERO)?	(q->is==ZERO)?	(p->is!=ZERO &&	longest of
X! 	p->left :	q->right :	q->is!=ZERO) ?	p->in, q->in, or
X  	p->is##q->left	p->right##q->is	p->is##q->is :	p->right##q->left
X  					ZERO
X  
X! OR	longest common	longest common	(do p->is and	(do p->in and
X! 	leading		trailing	q->is have same	q->in have same
X! 	(sub)sequence	(sub)sequence	length and	length and
X! 	of p->left	of p->right	content) ?	content) ?
X! 	and q->left	and q->right	p->is : NULL	p->in : NULL
X  
X  If there's anything else we recognize in the tree, all four sequences get set
X  to zero-length sequences.  If there's something we don't recognize in the tree,
X  we just return a zero-length sequence.
X  
X! After the above calculations are performed, three additional steps are taken:
X  
X! 1.	If there's a non-zero-length "is" sequence, it replaces the
X! 	"left", "right", and "in" sequences.
X! 2.	If the "left" sequence is longer than the "in" sequence, it replaces
X! 	the "in" sequence.
X! 3.	If the "right" sequence is longer than the "in" sequence, it replaces
X! 	the "in" sequence.
X! 
X! Possibilities:
X! 1.	Find the longest common (sub)sequence of p->in and q->in when doing
X! 	an OR node's "in" sequence?  Possibly effective, as in
X! 		egrep 'pepsi|epsilon'
X! 	but is it cheap and easy enough?
X! 2.	In replacing "in" sequences with "left" and "right" sequences, how
X! 	should ties be broken?
X! 3.	Switch to allocated memory, rather than relying on a defined MUST_MAX?
X  */
X  
X! #define TRUE	1
X! #define FALSE	0
X  
X! typedef struct {
X! 	int	n;
X! 	char	p[MUST_MAX];
X! } counted;
X  
X! #define initcounted(cp)	((cp)->n = 0)
X! 
X! static void
X! cntcpy(top, fromp)
X! counted *	top;
X! counted *	fromp;
X! {
X! 	register char *	fp;
X! 	register char *	tp;
X! 	register int	n;
X! 
X! 	fp = fromp->p;
X! 	tp = top->p;
X! 	n = fromp->n;
X! 	top->n = n;
X! 	while (n-- > 0)
X! 		*tp++ = *fp++;
X! }
X! 
X! static void
X! cntcat(top, fromp)
X! counted *	top;
X! counted *	fromp;
X! {
X! 	register char *	fp;
X! 	register char *	tp;
X! 	register int	n;
X! 
X! 	fp = fromp->p;
X! 	tp = top->p + top->n;
X! 	n = fromp->n;
X! 	top->n += n;
X! 	while (n-- > 0)
X! 		*tp++ = *fp++;
X! }
X! 
X! static int
X! cntsame(acp, bcp)
X! counted *	acp;
X! counted *	bcp;
X  {
X  	register int	i;
X  
X! 	if (acp->n != bcp->n)
X! 		return FALSE;
X! 	for (i = 0; i < acp->n; ++i)
X! 		if (acp->p[i] != bcp->p[i])
X! 			return FALSE;
X! 	return TRUE;
X  }
X  
X  
X  typedef struct {
X! 	counted	left;
X! 	counted	right;
X! 	counted	in;
X! 	counted	is;
X  } must;
X  
X  static void
X! initmust(mp)
X! must *	mp;
X  {
X! 	initcounted(&mp->left);
X! 	initcounted(&mp->right);
X! 	initcounted(&mp->in);
X! 	initcounted(&mp->is);
X  }
X  
X  static void
X--- 1756,2022 ----
X  
X  QMARK	ZERO		ZERO		ZERO		ZERO
X  
X! PLUS	p->left		p->right	ZERO		p->in
X  
X! CAT	(p->is==ZERO)?	(q->is==ZERO)?	(p->is!=ZERO &&	p->in plus
X! 	p->left :	q->right :	q->is!=ZERO) ?	q->in plus
X  	p->is##q->left	p->right##q->is	p->is##q->is :	p->right##q->left
X  					ZERO
X  
X! OR	longest common	longest common	(do p->is and	substrings common to
X! 	leading		trailing	q->is have same	p->in and q->in
X! 	(sub)sequence	(sub)sequence	length and	
X! 	of p->left	of p->right	content) ?	
X! 	and q->left	and q->right	p->is : NULL	
X  
X  If there's anything else we recognize in the tree, all four sequences get set
X  to zero-length sequences.  If there's something we don't recognize in the tree,
X  we just return a zero-length sequence.
X  
X! Break ties in favor of infrequent letters (choosing 'zzz' in preference to
X! 'aaa')?
X  
X! And. . .is it here or someplace that we might ponder "optimizations" such as
X! 	egrep 'psi|epsilon'	->	egrep 'psi'
X! 	egrep 'pepsi|epsilon'	->	egrep 'epsi'
X! 					(Yes, we now find "epsi" as a "string
X! 					that must occur", but we might also
X! 					simplify the *entire* r.e. being sought
X! )
X! 	grep '[c]'		->	grep 'c'
X! 	grep '(ab|a)b'		->	grep 'ab'
X! 	grep 'ab*'		->	grep 'a'
X! 	grep 'a*b'		->	grep 'b'
X! There are several issues:
X! 	Is optimization easy (enough)?
X! 
X! 	Does optimization actually accomplish anything,
X! 	or is the automaton you get from "psi|epsilon" (for example)
X! 	the same as the one you get from "psi" (for example)?
X! 
X! 	Are optimizable r.e.'s likely to be used in real-life situations
X! 	(something like 'ab*' is probably unlikely; something like is
X! 	'psi|epsilon' is likelier)?
X  */
X  
X! static char *
X! icatalloc(old, new)
X! char *	old;
X! char *	new;
X! {
X! 	register char *	result;
X! 	register int	oldsize, newsize;
X! 
X! 	newsize = (new == NULL) ? 0 : strlen(new);
X! 	if (old == NULL)
X! 		oldsize = 0;
X! 	else if (newsize == 0)
X! 		return old;
X! 	else	oldsize = strlen(old);
X! 	if (old == NULL)
X! 		result = (char *) malloc(newsize + 1);
X! 	else	result = (char *) realloc((void *) old, oldsize + newsize + 1);
X! 	if (result != NULL && new != NULL)
X! 		(void) strcpy(result + oldsize, new);
X! 	return result;
X! }
X! 
X! static char *
X! icpyalloc(string)
X! const char *	string;
X! {
X! 	return icatalloc((char *) NULL, string);
X! }
X! 
X! static char *
X! istrstr(lookin, lookfor)
X! char *		lookin;
X! register char *	lookfor;
X! {
X! 	register char *	cp;
X! 	register int	len;
X  
X! 	len = strlen(lookfor);
X! 	for (cp = lookin; *cp != '\0'; ++cp)
X! 		if (strncmp(cp, lookfor, len) == 0)
X! 			return cp;
X! 	return NULL;
X! }
X! 
X! static void
X! ifree(cp)
X! char *	cp;
X! {
X! 	if (cp != NULL)
X! 		free(cp);
X! }
X! 
X! static void
X! freelist(cpp)
X! register char **	cpp;
X! {
X! 	register int	i;
X! 
X! 	if (cpp == NULL)
X! 		return;
X! 	for (i = 0; cpp[i] != NULL; ++i) {
X! 		free(cpp[i]);
X! 		cpp[i] = NULL;
X! 	}
X! }
X! 
X! static char **
X! enlist(cpp, new, len)
X! register char **	cpp;
X! register char *		new;
X! {
X! 	register int	i, j;
X! 
X! 	if (cpp == NULL)
X! 		return NULL;
X! 	if ((new = icpyalloc(new)) == NULL) {
X! 		freelist(cpp);
X! 		return NULL;
X! 	}
X! 	new[len] = '\0';
X! 	/*
X! 	** Is there already something in the list that's new (or longer)?
X! 	*/
X! 	for (i = 0; cpp[i] != NULL; ++i)
X! 		if (istrstr(cpp[i], new) != NULL) {
X! 			free(new);
X! 			return cpp;
X! 		}
X! 	/*
X! 	** Eliminate any obsoleted strings.
X! 	*/
X! 	j = 0;
X! 	while (cpp[j] != NULL)
X! 		if (istrstr(new, cpp[j]) == NULL)
X! 			++j;
X! 		else {
X! 			free(cpp[j]);
X! 			if (--i == j)
X! 				break;
X! 			cpp[j] = cpp[i];
X! 		}
X! 	/*
X! 	** Add the new string.
X! 	*/
X! 	cpp = (char **) realloc((char *) cpp, (i + 2) * sizeof *cpp);
X! 	if (cpp == NULL)
X! 		return NULL;
X! 	cpp[i] = new;
X! 	cpp[i + 1] = NULL;
X! 	return cpp;
X! }
X! 
X! /*
X! ** Given pointers to two strings,
X! ** return a pointer to an allocated list of their distinct common substrings.
X! ** Return NULL if something seems wild.
X! */
X  
X! static char **
X! comsubs(left, right)
X! char *	left;
X! char *	right;
X! {
X! 	register char **	cpp;
X! 	register char *		lcp;
X! 	register char *		rcp;
X! 	register int		i, len;
X! 
X! 	if (left == NULL || right == NULL)
X! 		return NULL;
X! 	cpp = (char **) malloc(sizeof *cpp);
X! 	if (cpp == NULL)
X! 		return NULL;
X! 	cpp[0] = NULL;
X! 	for (lcp = left; *lcp != '\0'; ++lcp) {
X! 		len = 0;
X! 		rcp = strchr(right, *lcp);
X! 		while (rcp != NULL) {
X! 			for (i = 1; lcp[i] != '\0' && lcp[i] == rcp[i]; ++i)
X! 				;
X! 			if (i > len)
X! 				len = i;
X! 			rcp = strchr(rcp + 1, *lcp);
X! 		}
X! 		if (len == 0)
X! 			continue;
X! 		if ((cpp = enlist(cpp, lcp, len)) == NULL)
X! 			break;
X! 	}
X! 	return cpp;
X! }
X! 
X! static char **
X! addlists(old, new)
X! char **	old;
X! char **	new;
X  {
X  	register int	i;
X  
X! 	if (old == NULL || new == NULL)
X! 		return NULL;
X! 	for (i = 0; new[i] != NULL; ++i) {
X! 		old = enlist(old, new[i], strlen(new[i]));
X! 		if (old == NULL)
X! 			break;
X! 	}
X! 	return old;
X  }
X  
X+ /*
X+ ** Given two lists of substrings,
X+ ** return a new list giving substrings common to both.
X+ */
X+ 
X+ static char **
X+ inboth(left, right)
X+ char **	left;
X+ char **	right;
X+ {
X+ 	register char **	both;
X+ 	register char **	temp;
X+ 	register int		lnum, rnum;
X+ 
X+ 	if (left == NULL || right == NULL)
X+ 		return NULL;
X+ 	both = (char **) malloc(sizeof *both);
X+ 	if (both == NULL)
X+ 		return NULL;
X+ 	both[0] = NULL;
X+ 	for (lnum = 0; left[lnum] != NULL; ++lnum) {
X+ 		for (rnum = 0; right[rnum] != NULL; ++rnum) {
X+ 			temp = comsubs(left[lnum], right[rnum]);
X+ 			if (temp == NULL) {
X+ 				freelist(both);
X+ 				return NULL;
X+ 			}
X+ 			both = addlists(both, temp);
X+ 			freelist(temp);
X+ 			if (both == NULL)
X+ 				return NULL;
X+ 		}
X+ 	}
X+ 	return both;
X+ }
X  
X  typedef struct {
X! 	char **	in;
X! 	char *	left;
X! 	char *	right;
X! 	char *	is;
X  } must;
X  
X  static void
X! resetmust(mp)
X! register must *	mp;
X  {
X! 	mp->left[0] = mp->right[0] = mp->is[0] = '\0';
X! 	freelist(mp->in);
X  }
X  
X  static void
X***************
X*** 1866,1884 ****
X  regmust(r)
X  register struct regexp *	r;
X  {
X! 	must			musts[MUST_MAX];
X  	register must *		mp;
X! 	counted			result;
X  	register int		ri;
X  	register int		i;
X  	register _token		t;
X  
X  	reg->mustn = 0;
X  	reg->must[0] = '\0';
X! 	if (reg->tindex > MUST_MAX)
X  		return;
X  	mp = musts;
X! 	initcounted(&result);
X  	for (ri = 0; ri < reg->tindex; ++ri) {
X  		switch (t = reg->tokens[ri]) {
X  		case _ALLBEGLINE:
X--- 2023,2056 ----
X  regmust(r)
X  register struct regexp *	r;
X  {
X! 	register must *		musts;
X  	register must *		mp;
X! 	register char *		result;
X  	register int		ri;
X  	register int		i;
X  	register _token		t;
X+ 	static must		must0;
X  
X  	reg->mustn = 0;
X  	reg->must[0] = '\0';
X! 	musts = (must *) malloc((reg->tindex + 1) * sizeof *musts);
X! 	if (musts == NULL)
X  		return;
X  	mp = musts;
X! 	for (i = 0; i <= reg->tindex; ++i)
X! 		mp[i] = must0;
X! 	for (i = 0; i <= reg->tindex; ++i) {
X! 		mp[i].in = (char **) malloc(sizeof *mp[i].in);
X! 		mp[i].left = malloc(2);
X! 		mp[i].right = malloc(2);
X! 		mp[i].is = malloc(2);
X! 		if (mp[i].in == NULL || mp[i].left == NULL ||
X! 			mp[i].right == NULL || mp[i].is == NULL)
X! 				goto done;
X! 		mp[i].left[0] = mp[i].right[0] = mp[i].is[0] = '\0';
X! 		mp[i].in[0] = NULL;
X! 	}
X! 	result = "";
X  	for (ri = 0; ri < reg->tindex; ++ri) {
X  		switch (t = reg->tokens[ri]) {
X  		case _ALLBEGLINE:
X***************
X*** 1894,1900 ****
X  		case _LIMWORD:
X  		case _NOTLIMWORD:
X  		case _BACKREF:
X! 			initmust(mp);
X  			break;
X  		case _STAR:
X  		case _QMARK:
X--- 2066,2072 ----
X  		case _LIMWORD:
X  		case _NOTLIMWORD:
X  		case _BACKREF:
X! 			resetmust(mp);
X  			break;
X  		case _STAR:
X  		case _QMARK:
X***************
X*** 1901,1945 ****
X  			if (mp <= musts)
X  				goto done;	/* "cannot happen" */
X  			--mp;
X! 			initmust(mp);
X  			break;
X  		case _OR:
X  			if (mp < &musts[2])
X  				goto done;	/* "cannot happen" */
X  			{
X! 				register must *	lmp;
X! 				register must *	rmp;
X! 				register int	j, n;
X  
X  				rmp = --mp;
X  				lmp = --mp;
X  				/* Guaranteed to be.  Unlikely, but. . . */
X! 				if (!cntsame(&lmp->is, &rmp->is))
X! 					initcounted(&lmp->is);
X  				/* Left side--easy */
X! 				n = lmp->left.n;
X! 				if (n > rmp->left.n)
X! 					n = rmp->left.n;
X! 				for (i = 0; i < n; ++i)
X! 					if (lmp->left.p[i] != rmp->left.p[i])
X! 						break;
X! 				lmp->left.n = i;
X  				/* Right side */
X! 				n = lmp->right.n;
X! 				if (n > rmp->right.n)
X! 					n = rmp->right.n;
X  				for (i = 0; i < n; ++i)
X! 					if (lmp->right.p[lmp->right.n-i-1] !=
X! 					    rmp->right.p[rmp->right.n-i-1])
X  						break;
X  				for (j = 0; j < i; ++j)
X! 					lmp->right.p[j] =
X! 						lmp->right.p[(lmp->right.n -
X! 							i) + j];
X! 				lmp->right.n = i;
X! 				/* Includes.  Unlikely, but. . . */
X! 				if (!cntsame(&lmp->in, &rmp->in))
X! 					initcounted(&lmp->in);
X  			}
X  			break;
X  		case _PLUS:
X--- 2073,2120 ----
X  			if (mp <= musts)
X  				goto done;	/* "cannot happen" */
X  			--mp;
X! 			resetmust(mp);
X  			break;
X  		case _OR:
X  			if (mp < &musts[2])
X  				goto done;	/* "cannot happen" */
X  			{
X! 				register char **	new;
X! 				register must *		lmp;
X! 				register must *		rmp;
X! 				register int		j, ln, rn, n;
X  
X  				rmp = --mp;
X  				lmp = --mp;
X  				/* Guaranteed to be.  Unlikely, but. . . */
X! 				if (strcmp(lmp->is, rmp->is) != 0)
X! 					lmp->is[0] = '\0';
X  				/* Left side--easy */
X! 				i = 0;
X! 				while (lmp->left[i] != '\0' &&
X! 					lmp->left[i] == rmp->left[i])
X! 						++i;
X! 				lmp->left[i] = '\0';
X  				/* Right side */
X! 				ln = strlen(lmp->right);
X! 				rn = strlen(rmp->right);
X! 				n = ln;
X! 				if (n > rn)
X! 					n = rn;
X  				for (i = 0; i < n; ++i)
X! 					if (lmp->right[ln - i - 1] !=
X! 					    rmp->right[rn - i - 1])
X  						break;
X  				for (j = 0; j < i; ++j)
X! 					lmp->right[j] =
X! 						lmp->right[(ln - i) + j];
X! 				lmp->right[j] = '\0';
X! 				new = inboth(lmp->in, rmp->in);
X! 				if (new == NULL)
X! 					goto done;
X! 				freelist(lmp->in);
X! 				free((char *) lmp->in);
X! 				lmp->in = new;
X  			}
X  			break;
X  		case _PLUS:
X***************
X*** 1946,2001 ****
X  			if (mp <= musts)
X  				goto done;	/* "cannot happen" */
X  			--mp;
X! 			initcounted(&mp->is);
X  			break;
X  		case _END:
X  			if (mp != &musts[1])
X  				goto done;	/* "cannot happen" */
X! 			result = musts[0].in;
X  			goto done;
X  		case _CAT:
X  			if (mp < &musts[2])
X  				goto done;	/* "cannot happen" */
X  			{
X! 				must *	lmp;
X! 				must *	rmp;
X! 				must	new;
X! 				must *	nmp;
X! 				int	a, b, c;
X  
X  				rmp = --mp;
X  				lmp = --mp;
X! 				nmp = &new;
X! 				initmust(nmp);
X  				/* Left-hand */
X! 				cntcat(&nmp->left, &lmp->left);
X! 				if (lmp->is.n != 0)
X! 					cntcat(&nmp->left, &rmp->left);
X  				/* Right-hand */
X! 				if (rmp->is.n != 0)
X! 					cntcat(&nmp->right, &lmp->right);
X! 				cntcat(&nmp->right, &rmp->right);
X  				/* Guaranteed to be */
X! 				if (lmp->is.n != 0 && rmp->is.n != 0) {
X! 					cntcat(&nmp->is, &lmp->is);
X! 					cntcat(&nmp->is, &rmp->is);
X  				}
X- 				/* Interior */
X- 				a = lmp->in.n;
X- 				b = rmp->in.n;
X- 				c = lmp->right.n + rmp->left.n;
X- 				if (a == 0 && b == 0 && c == 0) {
X- 					/* nothing */
X- 					;
X- 				} else if (c > a && c > b) {
X- 					cntcat(&nmp->in, &lmp->right);
X- 					cntcat(&nmp->in, &rmp->left);
X- 				} else if (a > b) {
X- 					cntcat(&nmp->in, &lmp->in);
X- 				} else {
X- 					cntcat(&nmp->in, &rmp->in);
X- 				}
X- 				*mp = new;
X  			}
X  			break;
X  		default:
X--- 2121,2187 ----
X  			if (mp <= musts)
X  				goto done;	/* "cannot happen" */
X  			--mp;
X! 			mp->is[0] = '\0';
X  			break;
X  		case _END:
X  			if (mp != &musts[1])
X  				goto done;	/* "cannot happen" */
X! 			for (i = 0; musts[0].in[i] != NULL; ++i)
X! 				if (strlen(musts[0].in[i]) > strlen(result))
X! 					result = musts[0].in[i];
X  			goto done;
X  		case _CAT:
X  			if (mp < &musts[2])
X  				goto done;	/* "cannot happen" */
X  			{
X! 				register must *	lmp;
X! 				register must *	rmp;
X  
X  				rmp = --mp;
X  				lmp = --mp;
X! 				/*
X! 				** In.  Everything in left, plus everything in
X! 				** right, plus catenation of
X! 				** left's right and right's left.
X! 				*/
X! 				lmp->in = addlists(lmp->in, rmp->in);
X! 				if (lmp->in == NULL)
X! 					goto done;
X! 				if (lmp->right[0] != '\0' &&
X! 					rmp->left[0] != '\0') {
X! 						register char *	tp;
X! 
X! 						tp = icpyalloc(lmp->right);
X! 						if (tp == NULL)
X! 							goto done;
X! 						tp = icatalloc(tp, rmp->left);
X! 						if (tp == NULL)
X! 							goto done;
X! 						lmp->in = enlist(lmp->in, tp,
X! 							strlen(tp));
X! 						free(tp);
X! 						if (lmp->in == NULL)
X! 							goto done;
X! 				}
X  				/* Left-hand */
X! 				if (lmp->is[0] != '\0') {
X! 					lmp->left = icatalloc(lmp->left,
X! 						rmp->left);
X! 					if (lmp->left == NULL)
X! 						goto done;
X! 				}
X  				/* Right-hand */
X! 				if (rmp->is[0] == '\0')
X! 					lmp->right[0] = '\0';
X! 				lmp->right = icatalloc(lmp->right, rmp->right);
X! 				if (lmp->right == NULL)
X! 					goto done;
X  				/* Guaranteed to be */
X! 				if (lmp->is[0] != '\0' && rmp->is[0] != '\0') {
X! 					lmp->is = icatalloc(lmp->is, rmp->is);
X! 					if (lmp->is == NULL)
X! 						goto done;
X  				}
X  			}
X  			break;
X  		default:
X***************
X*** 2002,2036 ****
X  			if (t < _END) {
X  				/* "cannot happen" */
X  				goto done;
X  			} else if (t >= _SET) {
X  				/* easy enough */
X! 				initmust(mp);
X  			} else {
X  				/* plain character */
X! 				mp->left.p[0] = mp->right.p[0] =
X! 					mp->in.p[0] = mp->is.p[0] = t;
X! 				mp->left.n = mp->right.n =
X! 					mp->in.n = mp->is.n = 1;
X! 				break;
X  			}
X  			break;
X  		}
X- 		/*
X- 		** "Additional steps"
X- 		*/
X- 		if (mp->is.n > 0) {
X- 			cntcpy(&mp->left, &mp->is);
X- 			cntcpy(&mp->right, &mp->is);
X- 			cntcpy(&mp->in, &mp->is);
X- 		}
X- 		if (mp->left.n > mp->in.n)
X- 			cntcpy(&mp->in, &mp->left);
X- 		if (mp->right.n > mp->in.n)
X- 			cntcpy(&mp->in, &mp->right);
X  		++mp;
X  	}
X  done:
X! 	reg->mustn = result.n;
X! 	for (i = 0; i < result.n; ++i)
X! 		reg->must[i] = result.p[i];
X  }
X--- 2188,2223 ----
X  			if (t < _END) {
X  				/* "cannot happen" */
X  				goto done;
X+ 			} else if (t == '\0') {
X+ 				/* not on *my* shift */
X+ 				goto done;
X  			} else if (t >= _SET) {
X  				/* easy enough */
X! 				resetmust(mp);
X  			} else {
X  				/* plain character */
X! 				resetmust(mp);
X! 				mp->is[0] = mp->left[0] = mp->right[0] = t;
X! 				mp->is[1] = mp->left[1] = mp->right[1] = '\0';
X! 				mp->in = enlist(mp->in, mp->is, 1);
X! 				if (mp->in == NULL)
X! 					goto done;
X  			}
X  			break;
X  		}
X  		++mp;
X  	}
X  done:
X! 	(void) strncpy(reg->must, result, MUST_MAX - 1);
X! 	reg->must[MUST_MAX - 1] = '\0';
X! 	reg->mustn = strlen(reg->must);
X! 	mp = musts;
X! 	for (i = 0; i <= reg->tindex; ++i) {
X! 		freelist(mp[i].in);
X! 		ifree((char *) mp[i].in);
X! 		ifree(mp[i].left);
X! 		ifree(mp[i].right);
X! 		ifree(mp[i].is);
X! 	}
X! 	free((char *) mp);
X  }
Xdiff -rcN grep-1.2/dfa.h grep-1.3/dfa.h
X*** grep-1.2/dfa.h	Thu Oct 13 22:11:29 1988
X--- grep-1.3/dfa.h	Tue Feb 28 21:53:15 1989
X***************
X*** 103,108 ****
X--- 103,117 ----
X  You are forbidden to forbid anyone else to use, share and improve
X  what you give them.   Help stamp out software-hoarding!  */
X  
X+ 
X+ #ifdef USG
X+ #include <string.h>
X+ extern char *index();
X+ #else
X+ #include <strings.h>
X+ extern char *strchr(), *strrchr(), *memcpy();
X+ #endif
X+ 
X  #ifdef __STDC__
X  
X  /* Missing include files for GNU C. */
X***************
X*** 113,124 ****
X  extern void *realloc(void *, size_t);
X  extern void free(void *);
X  
X- #ifndef USG
X- extern char *strchr(), *strrchr(), *memcpy();
X- #else
X- extern char *index();
X- #endif
X- 
X  extern char *bcopy(), *bzero();
X  
X  #ifdef SOMEDAY
X--- 122,127 ----
X***************
X*** 136,147 ****
X  extern char *calloc(), *malloc(), *realloc();
X  extern void free();
X  
X- #ifndef USG
X- extern char *strchr(), *strrchr(), *memcpy();
X- #else
X- extern char *index();
X- #endif
X- 
X  extern char *bcopy(), *bzero();
X  
X  #define ISALNUM(c) (isascii(c) && isalnum(c))
X--- 139,144 ----
X***************
X*** 380,387 ****
X     a constraint. */
X  typedef struct
X  {
X!   unsigned index:24,		/* Index into the parse array. */
X! 	   constraint:8;	/* Constraint for matching this position. */
X  } _position;
X  
X  /* Sets of positions are stored as arrays. */
X--- 377,384 ----
X     a constraint. */
X  typedef struct
X  {
X!   unsigned index;		/* Index into the parse array. */
X!   unsigned constraint;		/* Constraint for matching this position. */
X  } _position;
X  
X  /* Sets of positions are stored as arrays. */
X***************
X*** 398,407 ****
X  {
X    int hash;			/* Hash of the positions of this state. */
X    _position_set elems;		/* Positions this state could match. */
X!   unsigned newline:1,		/* True if previous state matched newline. */
X! 	   letter:1,		/* True if previous state matched a letter. */
X! 	   backref:1,		/* True if this state matches a \<digit>. */
X! 	   constraint:8;	/* Constraint for this state to accept. */
X    int first_end;		/* Token value of the first _END in elems. */
X  } _dfa_state;
X  
X--- 395,404 ----
X  {
X    int hash;			/* Hash of the positions of this state. */
X    _position_set elems;		/* Positions this state could match. */
X!   char newline;			/* True if previous state matched newline. */
X!   char letter;			/* True if previous state matched a letter. */
X!   char backref;			/* True if this state matches a \<digit>. */
X!   unsigned char constraint;	/* Constraint for this state to accept. */
X    int first_end;		/* Token value of the first _END in elems. */
X  } _dfa_state;
X  
Xdiff -rcN grep-1.2/getopt.c grep-1.3/getopt.c
X*** grep-1.2/getopt.c	Sun Dec 11 10:37:36 1988
X--- grep-1.3/getopt.c	Tue Feb 28 17:44:55 1989
X***************
X*** 406,412 ****
X  		if (opterr != 0)
X  		  fprintf (stderr, "%s: no argument for `-%c' option\n",
X  			   argv[0], c);
X! 		optarg = 0;
X  	      }
X  	    else
X  	      /* We already incremented `optind' once;
X--- 406,412 ----
X  		if (opterr != 0)
X  		  fprintf (stderr, "%s: no argument for `-%c' option\n",
X  			   argv[0], c);
X! 		c = '?';
X  	      }
X  	    else
X  	      /* We already incremented `optind' once;
Xdiff -rcN grep-1.2/grep.c grep-1.3/grep.c
X*** grep-1.2/grep.c	Tue Dec 13 10:54:54 1988
X--- grep-1.3/grep.c	Tue Feb 28 23:05:53 1989
X***************
X*** 368,376 ****
X  	  /* If a potential backreference is indicated, try it out with
X  	     a backtracking matcher to make sure the line is a match. */
X  	  if (try_backref && re_search(&regex, matching_line,
X! 				       next_line - matching_line,
X  				       0,
X! 				       next_line - matching_line,
X  				       NULL) < 0)
X  	    {
X  	      resume = next_line;
X--- 368,376 ----
X  	  /* If a potential backreference is indicated, try it out with
X  	     a backtracking matcher to make sure the line is a match. */
X  	  if (try_backref && re_search(&regex, matching_line,
X! 				       next_line - matching_line - 1,
X  				       0,
X! 				       next_line - matching_line - 1,
X  				       NULL) < 0)
X  	    {
X  	      resume = next_line;
X***************
X*** 542,548 ****
X    exit(ERROR);
X  }
X  
X! static char version[] = "GNU e?grep, version 1.2";
X  
X  main(argc, argv)
X       int argc;
X--- 542,548 ----
X    exit(ERROR);
X  }
X  
X! static char version[] = "GNU e?grep, version 1.3";
X  
X  main(argc, argv)
X       int argc;
X***************
X*** 679,695 ****
X  	break;
X        }
X  
X!   /* Set the syntax depending on arg 0 and whether to ignore case. */
X!   if (*prog == 'e')
X!     {
X!       regsyntax(RE_SYNTAX_EGREP, ignore_case);
X!       re_set_syntax(RE_SYNTAX_EGREP);
X!     }
X!   else
X!     {
X!       regsyntax(RE_SYNTAX_GREP, ignore_case);
X!       re_set_syntax(RE_SYNTAX_GREP);
X!     }
X  
X    /* Compile the regexp according to all the options. */
X    if (regexp_file)
X--- 679,692 ----
X  	break;
X        }
X  
X!   /* Set the syntax depending on whether we are EGREP or not. */
X! #ifdef EGREP
X!   regsyntax(RE_SYNTAX_EGREP, ignore_case);
X!   re_set_syntax(RE_SYNTAX_EGREP);
X! #else
X!   regsyntax(RE_SYNTAX_GREP, ignore_case);
X!   re_set_syntax(RE_SYNTAX_GREP);
X! #endif
X  
X    /* Compile the regexp according to all the options. */
X    if (regexp_file)
X***************
X*** 712,717 ****
X--- 709,715 ----
X  	  if (i == len)
X  	    the_regexp = realloc(the_regexp, len *= 2);
X  	}
X+       fclose(fp);
X        /* Nuke the concluding newline so we won't match the empty string. */
X        if (i > 0 && the_regexp[i - 1] == '\n')
X  	--i;
Xdiff -rcN grep-1.2/grep.man grep-1.3/grep.man
X*** grep-1.2/grep.man	Tue Dec 13 11:46:46 1988
X--- grep-1.3/grep.man	Tue Feb 28 21:42:46 1989
X***************
X*** 6,21 ****
X  .B grep
X  [
X  .B \-CVbchilnsvwx
X! ]
X! [
X! .B \-\c
X! .I num
X! ]
X! [
X  .B \-AB
X  .I num
X! ]
X! [ [
X  .B \-e
X  ]
X  .I expr
X--- 6,17 ----
X  .B grep
X  [
X  .B \-CVbchilnsvwx
X! ] [
X! .BI \- num
X! ] [
X  .B \-AB
X  .I num
X! ] [ [
X  .B \-e
X  ]
X  .I expr
X***************
X*** 254,260 ****
X  the aforementioned BMG search for a large class of regexps.
X  .PP
X  Richard Stallman wrote the backtracking regexp matcher that is
X! used for \\fIdigit\fP backreferences, as well as the getopt that
X  is provided for 4.2BSD sites.  The backtracking matcher was
X  originally written for GNU Emacs.
X  .PP
X--- 250,256 ----
X  the aforementioned BMG search for a large class of regexps.
X  .PP
X  Richard Stallman wrote the backtracking regexp matcher that is
X! used for \\\fIdigit\fP backreferences, as well as the getopt that
X  is provided for 4.2BSD sites.  The backtracking matcher was
X  originally written for GNU Emacs.
X  .PP
Xdiff -rcN grep-1.2/regex.c grep-1.3/regex.c
X*** grep-1.2/regex.c	Sun Oct 16 14:55:19 1988
X--- grep-1.3/regex.c	Tue Feb 28 17:44:59 1989
X***************
X*** 1,106 ****
X! /* Extended regular expression matching and search.
X!    Copyright (C) 1985 Free Software Foundation, Inc.
X  
X! 		       NO WARRANTY
X  
X-   BECAUSE THIS PROGRAM IS LICENSED FREE OF CHARGE, WE PROVIDE ABSOLUTELY
X- NO WARRANTY, TO THE EXTENT PERMITTED BY APPLICABLE STATE LAW.  EXCEPT
X- WHEN OTHERWISE STATED IN WRITING, FREE SOFTWARE FOUNDATION, INC,
X- RICHARD M. STALLMAN AND/OR OTHER PARTIES PROVIDE THIS PROGRAM "AS IS"
X- WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
X- BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
X- FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY
X- AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE
X- DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
X- CORRECTION.
X  
X!  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW WILL RICHARD M.
X! STALLMAN, THE FREE SOFTWARE FOUNDATION, INC., AND/OR ANY OTHER PARTY
X! WHO MAY MODIFY AND REDISTRIBUTE THIS PROGRAM AS PERMITTED BELOW, BE
X! LIABLE TO YOU FOR DAMAGES, INCLUDING ANY LOST PROFITS, LOST MONIES, OR
X! OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
X! USE OR INABILITY TO USE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR
X! DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD PARTIES OR
X! A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS) THIS
X! PROGRAM, EVEN IF YOU HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH
X! DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.
X! 
X! 		GENERAL PUBLIC LICENSE TO COPY
X! 
X!   1. You may copy and distribute verbatim copies of this source file
X! as you receive it, in any medium, provided that you conspicuously and
X! appropriately publish on each copy a valid copyright notice "Copyright
X! (C) 1985 Free Software Foundation, Inc."; and include following the
X! copyright notice a verbatim copy of the above disclaimer of warranty
X! and of this License.  You may charge a distribution fee for the
X! physical act of transferring a copy.
X! 
X!   2. You may modify your copy or copies of this source file or
X! any portion of it, and copy and distribute such modifications under
X! the terms of Paragraph 1 above, provided that you also do the following:
X! 
X!     a) cause the modified files to carry prominent notices stating
X!     that you changed the files and the date of any change; and
X! 
X!     b) cause the whole of any work that you distribute or publish,
X!     that in whole or in part contains or is a derivative of this
X!     program or any part thereof, to be licensed at no charge to all
X!     third parties on terms identical to those contained in this
X!     License Agreement (except that you may choose to grant more extensive
X!     warranty protection to some or all third parties, at your option).
X! 
X!     c) You may charge a distribution fee for the physical act of
X!     transferring a copy, and you may at your option offer warranty
X!     protection in exchange for a fee.
X! 
X! Mere aggregation of another unrelated program with this program (or its
X! derivative) on a volume of a storage or distribution medium does not bring
X! the other program under the scope of these terms.
X! 
X!   3. You may copy and distribute this program (or a portion or derivative
X! of it, under Paragraph 2) in object code or executable form under the terms
X! of Paragraphs 1 and 2 above provided that you also do one of the following:
X! 
X!     a) accompany it with the complete corresponding machine-readable
X!     source code, which must be distributed under the terms of
X!     Paragraphs 1 and 2 above; or,
X! 
X!     b) accompany it with a written offer, valid for at least three
X!     years, to give any third party free (except for a nominal
X!     shipping charge) a complete machine-readable copy of the
X!     corresponding source code, to be distributed under the terms of
X!     Paragraphs 1 and 2 above; or,
X! 
X!     c) accompany it with the information you received as to where the
X!     corresponding source code may be obtained.  (This alternative is
X!     allowed only for noncommercial distribution and only if you
X!     received the program in object code or executable form alone.)
X! 
X! For an executable file, complete source code means all the source code for
X! all modules it contains; but, as a special exception, it need not include
X! source code for modules which are standard libraries that accompany the
X! operating system on which the executable file runs.
X! 
X!   4. You may not copy, sublicense, distribute or transfer this program
X! except as expressly provided under this License Agreement.  Any attempt
X! otherwise to copy, sublicense, distribute or transfer this program is void and
X! your rights to use the program under this License agreement shall be
X! automatically terminated.  However, parties who have received computer
X! software programs from you with this License Agreement will not have
X! their licenses terminated so long as such parties remain in full compliance.
X! 
X!   5. If you wish to incorporate parts of this program into other free
X! programs whose distribution conditions are different, write to the Free
X! Software Foundation at 675 Mass Ave, Cambridge, MA 02139.  We have not yet
X! worked out a simple rule that can be stated here, but we will often permit
X! this.  We will be guided by the two goals of preserving the free status of
X! all derivatives of our free software and of promoting the sharing and reuse of
X! software.
X! 
X! 
X! In other words, you are welcome to use, share and improve this program.
X! You are forbidden to forbid anyone else to use, share and improve
X! what you give them.   Help stamp out software-hoarding!  */
X  
X  
X  /* To test, compile with -Dtest.
X--- 1,24 ----
X! /* Extended regular expression matching and search library.
X!    Copyright (C) 1985, 1989 Free Software Foundation, Inc.
X  
X!    This program is free software; you can redistribute it and/or modify
X!    it under the terms of the GNU General Public License as published by
X!    the Free Software Foundation; either version 1, or (at your option)
X!    any later version.
X! 
X!    This program is distributed in the hope that it will be useful,
X!    but WITHOUT ANY WARRANTY; without even the implied warranty of
X!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X!    GNU General Public License for more details.
X! 
X!    You should have received a copy of the GNU General Public License
X!    along with this program; if not, write to the Free Software
X!    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X  
X  
X!    In other words, you are welcome to use, share and improve this program.
X!    You are forbidden to forbid anyone else to use, share and improve
X!    what you give them.   Help stamp out software-hoarding!  */
X  
X  
X  /* To test, compile with -Dtest.
Xdiff -rcN grep-1.2/regex.h grep-1.3/regex.h
X*** grep-1.2/regex.h	Sat Aug 13 13:15:10 1988
X--- grep-1.3/regex.h	Tue Feb 28 17:44:59 1989
X***************
X*** 1,106 ****
X  /* Definitions for data structures callers pass the regex library.
X!    Copyright (C) 1985 Free Software Foundation, Inc.
X  
X! 		       NO WARRANTY
X  
X-   BECAUSE THIS PROGRAM IS LICENSED FREE OF CHARGE, WE PROVIDE ABSOLUTELY
X- NO WARRANTY, TO THE EXTENT PERMITTED BY APPLICABLE STATE LAW.  EXCEPT
X- WHEN OTHERWISE STATED IN WRITING, FREE SOFTWARE FOUNDATION, INC,
X- RICHARD M. STALLMAN AND/OR OTHER PARTIES PROVIDE THIS PROGRAM "AS IS"
X- WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
X- BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
X- FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY
X- AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE
X- DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
X- CORRECTION.
X  
X!  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW WILL RICHARD M.
X! STALLMAN, THE FREE SOFTWARE FOUNDATION, INC., AND/OR ANY OTHER PARTY
X! WHO MAY MODIFY AND REDISTRIBUTE THIS PROGRAM AS PERMITTED BELOW, BE
X! LIABLE TO YOU FOR DAMAGES, INCLUDING ANY LOST PROFITS, LOST MONIES, OR
X! OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
X! USE OR INABILITY TO USE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR
X! DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD PARTIES OR
X! A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS) THIS
X! PROGRAM, EVEN IF YOU HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH
X! DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.
X! 
X! 		GENERAL PUBLIC LICENSE TO COPY
X! 
X!   1. You may copy and distribute verbatim copies of this source file
X! as you receive it, in any medium, provided that you conspicuously and
X! appropriately publish on each copy a valid copyright notice "Copyright
X! (C) 1985 Free Software Foundation, Inc."; and include following the
X! copyright notice a verbatim copy of the above disclaimer of warranty
X! and of this License.  You may charge a distribution fee for the
X! physical act of transferring a copy.
X! 
X!   2. You may modify your copy or copies of this source file or
X! any portion of it, and copy and distribute such modifications under
X! the terms of Paragraph 1 above, provided that you also do the following:
X! 
X!     a) cause the modified files to carry prominent notices stating
X!     that you changed the files and the date of any change; and
X! 
X!     b) cause the whole of any work that you distribute or publish,
X!     that in whole or in part contains or is a derivative of this
X!     program or any part thereof, to be licensed at no charge to all
X!     third parties on terms identical to those contained in this
X!     License Agreement (except that you may choose to grant more extensive
X!     warranty protection to some or all third parties, at your option).
X! 
X!     c) You may charge a distribution fee for the physical act of
X!     transferring a copy, and you may at your option offer warranty
X!     protection in exchange for a fee.
X! 
X! Mere aggregation of another unrelated program with this program (or its
X! derivative) on a volume of a storage or distribution medium does not bring
X! the other program under the scope of these terms.
X! 
X!   3. You may copy and distribute this program (or a portion or derivative
X! of it, under Paragraph 2) in object code or executable form under the terms
X! of Paragraphs 1 and 2 above provided that you also do one of the following:
X! 
X!     a) accompany it with the complete corresponding machine-readable
X!     source code, which must be distributed under the terms of
X!     Paragraphs 1 and 2 above; or,
X! 
X!     b) accompany it with a written offer, valid for at least three
X!     years, to give any third party free (except for a nominal
X!     shipping charge) a complete machine-readable copy of the
X!     corresponding source code, to be distributed under the terms of
X!     Paragraphs 1 and 2 above; or,
X! 
X!     c) accompany it with the information you received as to where the
X!     corresponding source code may be obtained.  (This alternative is
X!     allowed only for noncommercial distribution and only if you
X!     received the program in object code or executable form alone.)
X! 
X! For an executable file, complete source code means all the source code for
X! all modules it contains; but, as a special exception, it need not include
X! source code for modules which are standard libraries that accompany the
X! operating system on which the executable file runs.
X! 
X!   4. You may not copy, sublicense, distribute or transfer this program
X! except as expressly provided under this License Agreement.  Any attempt
X! otherwise to copy, sublicense, distribute or transfer this program is void and
X! your rights to use the program under this License agreement shall be
X! automatically terminated.  However, parties who have received computer
X! software programs from you with this License Agreement will not have
X! their licenses terminated so long as such parties remain in full compliance.
X! 
X!   5. If you wish to incorporate parts of this program into other free
X! programs whose distribution conditions are different, write to the Free
X! Software Foundation at 675 Mass Ave, Cambridge, MA 02139.  We have not yet
X! worked out a simple rule that can be stated here, but we will often permit
X! this.  We will be guided by the two goals of preserving the free status of
X! all derivatives of our free software and of promoting the sharing and reuse of
X! software.
X! 
X! 
X! In other words, you are welcome to use, share and improve this program.
X! You are forbidden to forbid anyone else to use, share and improve
X! what you give them.   Help stamp out software-hoarding!  */
X  
X  
X  /* Define number of parens for which we record the beginnings and ends.
X--- 1,24 ----
X  /* Definitions for data structures callers pass the regex library.
X!    Copyright (C) 1985, 1989 Free Software Foundation, Inc.
X  
X!    This program is free software; you can redistribute it and/or modify
X!    it under the terms of the GNU General Public License as published by
X!    the Free Software Foundation; either version 1, or (at your option)
X!    any later version.
X! 
X!    This program is distributed in the hope that it will be useful,
X!    but WITHOUT ANY WARRANTY; without even the implied warranty of
X!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X!    GNU General Public License for more details.
X! 
X!    You should have received a copy of the GNU General Public License
X!    along with this program; if not, write to the Free Software
X!    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X  
X  
X!    In other words, you are welcome to use, share and improve this program.
X!    You are forbidden to forbid anyone else to use, share and improve
X!    what you give them.   Help stamp out software-hoarding!  */
X  
X  
X  /* Define number of parens for which we record the beginnings and ends.
X
END_OF_FILE
if test 46818 -ne `wc -c <'cvt1.2to1.3'`; then
    echo shar: \"'cvt1.2to1.3'\" unpacked with wrong size!
fi
# end of 'cvt1.2to1.3'
fi
echo shar: End of shell archive.
exit 0
