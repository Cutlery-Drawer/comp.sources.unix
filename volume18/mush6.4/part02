Subject:  v18i024:  Mail user's shell version 6.4, Part02/19
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Dan Heller <island!argv@sun.com>
Posting-number: Volume 18, Issue 24
Archive-name: mush6.4/part02



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 19)."
# Contents:  Gnurc Mailrc README-6.0 bindings.h config.h-dist
#   edit_menu.c hdr_panel.c lock.c mail.icon.1 mail.icon.2
#   makefile.bsd makefile.sun makefile.sys.v makefile.xenix strings.h
# Wrapped by rsalz@papaya.bbn.com on Mon Mar 13 19:25:07 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Gnurc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Gnurc'\"
else
echo shar: Extracting \"'Gnurc'\" \(3198 characters\)
sed "s/^X//" >'Gnurc' <<'END_OF_FILE'
X# .mushrc to simulate Gnu emacs (NOT Rmail!) for curses mode
X# -- Bart Schaefer (schaefer@cse.ogc.edu)
X#---------------------------------------------------------------------------
X# Shortcomings:
X#  In compose mode, can't use C-h, C-r, C-w, DEL, etc.
X#  Ought to delete most of the default bindings.  If you want remove the
X#   default bindings, you can:
X#	Run "mush -noinit" and do a "saveopts";
X#	Edit the saved file and change every "bind" to an "unbind";
X#	Remove all other extranous commands;
X#	Include the resulting list at the TOP of this file.
X#---------------------------------------------------------------------------
X#
Xset no_reverse
X#
X# TTY setup -- you may want to customize this, because the old interrupt
X#  character and so on might not be reset correctly when mush exits.
X#
Xcmd ntty 'stty intr ^G dsusp undef stop undef start undef lnext undef'
Xcmd rtty 'stty intr ^C dsusp ^Y stop ^S start ^Q lnext ^V'
Xcmd exit 'rtty; \exit'
Xcmd xit exit
Xcmd x exit
Xcmd quit 'update; exit'
Xcmd q quit
Xcmd curses 'ntty; \curses; rtty'
X#
X# Curses mode bindings
X#
X# Exiting -- try to make sure tty gets reset
Xbind-macro '\CX\CC' '[line-mode]exit\n'
Xbind-macro x [no-op]
Xbind-macro X [no-op]
Xbind-macro q [no-op]
Xbind-macro Q [no-op]
X# Files (folders)
Xbind '\CX\CF' folder
Xbind '\CX\CS' update
Xbind-macro '\CXi' '[line-mode]merge '
Xbind '\CX\CV' folder
Xbind-macro '\CX\CW' '[save-list]*\n'
X# Help
Xbind '\CX\CH' help	# Can't use just C-h, it's a prefix of the others
Xbind-macro '\CHa' '[bind]_\n\n\CH'	# List all curses commands
Xbind-macro '\CHc' '[line-mode]bind '	# Show one binding
Xbind-macro '\CHf' '[line-mode]? '	# Explain line-mode function
X# Error Recovery -- very primitive, sorry
Xbind '\CXu' undelete-list
Xbind '\C_' undelete-list
X# Searching -- sorry, can't be incremental
X#  also can't repeat with same key
Xbind '\CS' search-next
Xbind '\CR' search-back
X# Motion (the important part)
Xbind '\CB' back-msg
Xbind '\Eb' back-msg
Xbind '\CP' back-msg
Xbind '\CF' next-msg
Xbind '\Ef' next-msg
Xbind '\CN' next-msg
Xbind '\Ea' back-msg
Xbind '\Ee' next-msg
Xbind '\E[' top-page
Xbind '\E]' bottom-page
Xbind '\CX[' screen-back
Xbind '\CX]' screen-next
Xbind '\E<' first-msg
Xbind '\E>' last-msg
Xbind '\CV' screen-next
Xbind '\Ev' screen-back
X# Killing/deleting ("forward", i.e. at cursor, only)
Xbind '\CD' delete
Xbind '\Ed' delete
Xbind '\CK' delete
Xbind '\Ek' delete
Xbind-macro '\CW' '[line-mode]delete [getstr] | set kill\n[no-op]'
Xbind-macro '\CY' '[undelete-list]$kill\n'
X# Marking -- somewhat limited because can't use C-SPC (C-@)
Xbind-macro '\CX\CX' '[line-mode].|set mark\n[no-op]'
Xbind-macro '\Eh' '[line-mode]h|set mark\n[no-op]'
Xbind-macro '\CXCP' '[line-mode]h|set mark\n[no-op]'
Xbind-macro '\CXh' '[line-mode]*|set mark\n[no-op]'
X# Buffers -- treated same as folders
Xbind '\CXb' folder
Xbind-macro '\CX\CB' '[folder]?\n\CH'	# List folders and back out
Xbind-macro '\CXk' '[delete-list]*\n'
X# Shells
Xbind-macro '\E!'\
X	'[line-mode]rtty\n[shell-escape][getline][line-mode]ntty\n'
Xbind-macro '\Ex!' '[line-mode]rtty;sh\n[line-mode]ntty\n'
X# Macros
X#  Sorry, no appending to macros, and end with <RETURN> not `C-x )'
Xbind '\CX(' bind-macro
X#
X# Lastly, actually reset the tty
X#
Xif iscurses
X    ntty
Xendif
END_OF_FILE
if test 3198 -ne `wc -c <'Gnurc'`; then
    echo shar: \"'Gnurc'\" unpacked with wrong size!
fi
# end of 'Gnurc'
fi
if test -f 'Mailrc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Mailrc'\"
else
echo shar: Extracting \"'Mailrc'\" \(1447 characters\)
sed "s/^X//" >'Mailrc' <<'END_OF_FILE'
X# .mushrc to cause Mush to emulate UCB Mail
X# -- Bart Schaefer (schaefer@cse.ogc.edu)
X#----------------------------------------------------------------------------
X# Shortcomings:
X#  Mush does not support the "noisy phone line" flags of Mail
X#   (-i command line option or "set ignore" to ignore RUBOUT characters)
X#  Mush will never remove a system mailbox (no "unset keep" equivalent)
X#  See comments below on (lack of) command prefix recognition
X#----------------------------------------------------------------------------
X#
X# Set up prompting, headers
X#
Xset prompt='& '
Xset mil_time date_received
Xset hdr_format='%8.80a %D %M %-2N %5T  %l/%c "%.29s"'
X#
X# Set up mailing/replying miscellaneous
X#
Xset indent_str = "	"
Xset reply_to_hdr auto_route
X#
X# Set up command interface
X#  Note that a full emulation is difficult, because Mush does not support
X#  command prefix recognition (e.g., Mail interprets "Rep" as "Reply").
X#
X# Don't barf if history doesn't work, but still do cmd expansion
X#
Xset nonobang
X#
X# This stuff is fine, but really needs prefix recognition.
X#
Xcmd Reply replysender
Xcmd R replysender
Xcmd chdir cd
Xcmd chd cd
Xcmd + next
Xcmd ch cd
Xcmd c copy
Xcmd file folder
Xcmd fi folder
Xcmd hold preserve
Xcmd ho hold
Xcmd reply replyall
Xcmd r replyall
Xcmd retain "set show_hdrs='\!*'"	# Not quite right, but ...
Xcmd se set
Xcmd shell sh
Xcmd so source
Xcmd un undelete
Xcmd unread 'flags \!* U'	# "unread" is undocumented in Mail
Xcmd uns unset
END_OF_FILE
if test 1447 -ne `wc -c <'Mailrc'`; then
    echo shar: \"'Mailrc'\" unpacked with wrong size!
fi
# end of 'Mailrc'
fi
if test -f 'README-6.0' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README-6.0'\"
else
echo shar: Extracting \"'README-6.0'\" \(16733 characters\)
sed "s/^X//" >'README-6.0' <<'END_OF_FILE'
XThis is the README for release 6.0 of mush.  Note that the original README
Xhas changed as well, so it should be read again.  It contains important
Xinformation for installing mush on your system.
X
XWith this distribution, there is a file called Mailrc which can be
Xused as the "default" mailrc (see config.h-dist).  This file will set
Xvariables and command line aliases to make mush look as much like ucb Mail
Xas it possibly can.
X
XNew makefile && compiler flags:
X    System V machines that aren't XENIX should use the makefile.sys.v makefile.
X    The old makefile.sys.v has been removed. System-V machines
X    that aren't xenix may note -DUSG in the makefile.  USG is defined in
X    curses.h but is required to be in the makefile if compiling without the
X    curses libraries.  It should be in the makefile anyway so you never have
X    to worry about it. Xenix machines should use makefile.x286 or makefile.x386
X    USG should probably be defined on your xenix system unless you are running
X    a _very_ old version of xenix.  I don't know how old it would be, but
X    try compiling mush with USG first -- if that fails, then undefine it.
X
X    Some systems have regcmp/regex as their regular expression matching
X    routines while others have re_comp/re_exec -- If you have regcmp,
X    then you must have -DREGCMP in the makefile you're using. If you have
X    both sets of routines, take a pick.  Note that some systems do not
X    have either set of routines in the default libraries.  You must find
X    the library to use and add it to the list of libraries to use.  If this
X    is the case, your link will fail with the errors that regex and re_comp
X    are undefined functions.  Read your man page for regex(3) to find where
X    to locate those libraries.
X
X    Machines that use mail transfer agents that *do not* use a colon-less
X    "From " line as a message separator should #define in config.h the string
X    MSG_SEPARATOR.  Since this string is usually control characters, you
X    need to specify actual ascii values for those characters.  Users of MMDF,
X    for example, may use "\001\001\001\001" since some mmdf versions use four
X    control-A's to separate messages.  This message separator assumes that
X    there is a carriage return at the end of the string.  Systems that use
X    sendmail need not concern themselves with this define.
X
X    Some mailers (not RFC822 compatible, like execmail and older binmail's)
X    do not accept commas between addresses on outgoing mail.  Such mailers
X    also tend not to add the From: field and Date: field, which are headers
X    required to be compatible with RFC822.  This does not apply to BSD systems
X    or systems which run sendmail.  If this applies to your system, you
X    should define OLD_MAILER in config.h as "#define OLD_MAILER" or in the
X    makefile in addition to the CFLAGS definition: -DOLD_MAILER.  This does not
X    affect the user interface at all; mush will still enforce commas between
X    addresses.  However, addresses given on the command line to the mailer
X    will have commas stripped out if OLD_MAIL is defined in the makefile or
X    config.h.
X
XSystem V:
X    New functions:
X	lock_file() /* returns -1 if can't lock */
X	close_lock() /* unlocks and calls fclose */
X    These functions also support BSD, xenix and sys-v.  These are provided
X    as locking mechanisms for all systems -- ifdef's decide how to lock.
X
X    Support for termio functionality.  Macros in mush.h have been modified
X    to provide for echo/cbreak modes to depending on the compiler flags:
X    CURSES and SYSV/BSD/USG.  There are 6 different possible cases here.
X
X    Problem with xenix/sys-v getting the "name" from a "From:" field since
X    char pointer and char arrays are different sizes.  (hdrs.c, compose_hdr())
X
X    sendmail mail now forks off and returns you to a mush prompt so you
X    don't have to wait for the mail to be delivered.  This is true for
X    both xenix and sys-v.
X
X    terminfo is now supported.
X
XCommand line arguments:
X    -u [user]
X    /usr/spool/mail/user is used as the current folder. If "user" isn't
X    specified, /usr/spool/mail/root is used.
X
X    -T timeout implies -t (for toolmode), so -t is not required if -T is given.
X
X    If -r (readonly) flag is given on the command line or to the folder/update
X    commands, the folder (or spoolfile) is opened readonly and the mail is
X    *not* copied into a temporary buffer.  This speeds up IO dramatically in
X    systems with slow IO or disk drives (typically, xenix/sys-v).
X
X    -H implies -r, so -r is not necessary.  If mush is started just to read
X    the headers of your mail, then forcing read only improves performance.
X
X    a folder as well as an address can be given on the command line. Thus,
X    % mush -f foldername address-list
X    will first interactively mail to the address-list and upon return read
X    in the folder "foldername".
X
XMisc:
X    There is now an internal pager which is used if the user has no
X    "pager" variable set and no environment PAGER variable.  This pager
X    is very simple and understands <space> for next $crt lines, \n does
X    just the next line, ^D does the next half $crt lines, and q,Q quits.
X    The user can "set pager" (to null, effectively) or to the string "internal"
X    to always get the internal pager.  The DEF_PAGER macro in config.h can
X    be set to "internal" also. (do_pager() misc.c)
X
X    Mush now understands 'well-formed' addresses.  A well-formed address
X    consists of tokens of the form:
X
X    $path
X    $path (Name or comment here)
X    Name or comment <$path>
X    "Name or comment" $path
X
X    See the man page for Extensive examples and rules for what formats
X    are legal, but may not be supported.
X
X    To: lines which are too long from incoming mail are truncated. Previously,
X    a segmentation fault would result -- replies to messages containing long
X    To: lines will attempt to chop off the list between addresses.
X
X    Add right justification in hdr_format format string field similar
X    to printf style formatting.  Example:
X    set hdr_format = '%-25n %7d (%l) "%s"'
X    will produce a header format such that the name of the author is
X    right justified 25 positions, 7 chars of the date is printed, the
X    number of lines in the message and the subject surrounded by quotes.
X    Also subwidths are allowed using the same dot notation as provided by
X    printf.  (hdrs.c)
X
X    The '%S' switch for message status has been removed and the status of
X    a message is always at the beginning of the message header line
X    by default along with the msg number and the '>' if it's the current msg.
X    There is a new status flag for replied to messages.  If a message has
X    been replied to, then a 'r' is placed in the header string just after
X    the first status flag.. Thus, the header:
X      4 >*r Dan Heller <island!argv@sun.com> ....
X    means that message 4 is the current message, it has been deleted,
X    and has been replied to...
X
X    In the hdr_format string, the date of a message can be printed
X    using the same formatting characters as the prompt uses.  %T is
X    the time, etc... Note that %d still prints the whole date, but
X    the new formatting characters allow parts of the date to be printed.
X
X    New option for mail:
X    mail -s [subject]
X    With no subject specified, -s forces a prompt for the subject
X    header even if the variable "ask" is not set.  If a subject is
X    specified, then the subject is set to that string explicitly.
X    This allows the reply command to change the subject or to prompt
X    to change the subject.
X
X    Saveopts now warns if file already exists; you must confirm overwrite.
X
X    Control characters typed are now understood and can be entered into
X    letters etc... To enter a special control character such as your backspace
X    character or kill line character use the backslash.  In the toolmode,
X    use your literal next character (^V in most cases).
X
X    "varargs" now used in print.c to provide support for machine that
X    do not stack arguments compatible with vax/68000/etc... These machines
X    are Pyramids, Sun4's and more... (print.c)
X
X    The temporary file used to type in messages is now _closed_ before
X    invoking an editor.  This is for gnuemacs users or users of other
X    editors which insist on no other references to that file be open.
X
X    Using job control (^Z/fg) which in the headers portion of a message
X    (e.g. "To: ") would cause mush to be confused about what state the program
X    is in and would inadvertently show a prompt (user's $prompt) even
X    tho it was executing the right code (prompting for the To: line). This
X    has been fixed so that the prompt isn't given, but the To: line will
X    not be reprompted.
X
X    Mailing to users from the command line and ^C-ing while in the To: or
X    Subject: prompt would just report an interrupt and not abort the message;
X    it now exits.(hdrs.c, set_header())
X
X    If the user's home dir isn't writable, or permissions changed during
X    runtime, mush changes to ALTERNATE_HOME and tries again rather than just
X    returning an error message.  If the alternate home also fails, an error
X    is printed and the function aborted.
X	(main.c, mail.c, start_file())
X
X    When updating a folder, ignored headers are now copied back regardless
X    of the variable, "alwaysignore". This is necessary because the user may
X    ignore headers that are required to be read when reading in a folder.
X	(msgs.c, copy_msg())
X
X    pick has a new option to pick from an arbitrary header.
X    pick -h return-path ucbvax
X    searches for the string "ucbvax" in the Return-Path: header of all
X    messages.
X
XNew Variables:
X    autosign2
X    Use an alternate signature for specific users.  Format for string:
X    set autosign2 = "address, address, ... : <signature>"
X    where "address" is a legal address (or alias) and signature is that
X    described by "autosign".  the colon separates the list from the signature.
X    If the colon is missing or if the list is null, the signature is used
X    and no checks are made against the recipient list.  Otherwise, each
X    address on the recipient list of outgoing mail must also exist in
X    the autosign2 list.  Otherwise, the signature in autosign is used.
X    If autosign is not set, the autosigning isn't done unless ~S is used.
X
X    show_hdrs (String)
X    Set to a list (space and/or comma separated) of headers which are to
X    be the only headers displayed when viewing a message.  This disables
X    the headers suppressed by the ignore command. Example:
X	set show_hdrs = "from date subject to cc"
X    will only display the headers,
X	From: Date: Subject: To: Cc:
X    in their entirety.
X
X    mil_time -- if set, 24 hour military time format is used in message
X    dates or if the time is used in the prompt. Otherwise, 12-hour with
X    an added "am/pm" is displayed.
X
X    The variable "no_expand" prevents expansion of mush addresses in
X    outgoing mail.  The To: line will read the same as it was typed --
X    this hides the complete list of addresses of everyone on the list.
X
X    A new variable called "wrap" has been added.  When the last message is
X    deleted, the next "current" message is usually the next undeleted message.
X    If wrap is not set, then the current message remains at the end of the
X    list of messages.  Similarly, if "next" ('n', CR) is specified, wrapping
X    to the beginning of the list only happens if the variable is set.
X
X    The variable fixaddr has been removed and the variable auto_route has
X    been modified to route uucp mail thru the host of the author of the
X    message being replied to as well as removing redundant hostnames such as:
X    host1!host2!host1!user -> host1!user
X
X    "cdpath" added.  This is like csh's but note you can't use ()'s to
X    set the path -- use quotes: (").  When the cd command is issued,
X    if there is no cdpath set, then the directory mentioned is cd'ed to.
X    If there is a cdpath and the pathname given is not a full pathname,
X    then each element in the cdpath is searched for the directory specified.
X    Recommend putting "." first in cdpath if one is used.
X
X    "sendmail" -- if set, this program is used instead of the default Mail
X    Transfer Agent defined as MAIL_DELIVERY in config.h ... If used, the
X    default flags -i and -m are not passed along to the MTA, so any flags
X    which are necessary for the MTA should be included in the sendmail
X    variable's string value.
X
X    pre_indent_str, post_indent_str (string)
X    These strings have the same properties as "hdr_format". The
X    pre_indent_str string will precede the body of text interpolated into
X    the message buffer and the post_indent_str will succeed the text. See
X    the man page for extensive details.
X
X    in_reply_to (string)
X    set to a string interpreted the same as "hdr_format" -- when replying
X    to mail, an additionally outgoing message header In-Reply-To: is added.
X    See man page for more extensive details.
X
X    "ask" is a boolean which is for compatibility with ucb-Mail. If set,
X    you will be prompted for a subject.  otherwise, no subject prompting
X    is done.
X
XCurses:
X    In curses mode, line-mode-escape commands which contain pipes,
X    :pick -s pattern | save folder
X    would segmentation fault on the command that follows such commands.
X    The next command to execute thinks that piping is on causing a segmentation
X    fault trying to reference the non-existent message list.  This was fixed by
X    resetting the DO_PIPE/IS_PIPE flags to off in the cmd_line() routine.
X	(misc.c, cmd_line())
X
X    Quitting now goes to the bottom of the screen rather than moving
X    down one line [as well as other quit-related update bugs]
X	(curses.c, case C_QUIT:)
X
X    Updating (^U) now redraws the screen right if you weren't on the
X    first "screenful" of messages. (curses.c, case C_UPDATE)
X
X    's' (save) command wasn't saving to mbox on no input (CR).  It tried
X    to save to "" which maps to "." which is a directory.  (curses.c)
X
X    The bug causing the GOTO command to infinite loop if there were 0
X    or 1 messages in the folder if invoked by selecting a digit key has
X    been fixed.  The manual entry for how the goto command works has a
X    more detailed description and gives an example for effective usage.
X    Due to its versatility, there can be some screen updating problems
X    if the user specifies a message list which contains a command that
X    produces any "stdout" type output.  Normally, this shouldn't happen,
X    because most commands which are used to "search for messages" will
X    not output anything if they are being "piped".  If the user wishes
X    to specify a command that produces output (like echo) then the screen
X    will not be updated correctly (use ^L to redraw).  See the updated
X    man page entry for details on the above.
X
X    The bind command doesn't require the use of \Cc to represent control
X    characters anymore.  The old interface is still supported -- in fact
X    control characters that are typed are converted to this ascii format
X    for purposes of displaying current bindings and to allow .mushrc files
X    to specify bindings in ascii format.  However, control characters may
X    be typed as is.  The spacebar may be bound to a command if it is given
X    in the .mushrc file or on a Mush command line.  See the manual.
X
XTool mode:
X    Trying to start tool in icon mode sometimes aborts with segmentation
X    fault.  This is caused by the window size being 0 and the message
X    trying to be written to the empty window.  The routine which tries to
X    output each line of the message to the window is recursive. If the line
X    wraps because of the window's width being less than the length of the
X    line, Addstr() finds the position in the line which wraps and calls
X    itself recursively passing the remainder of the string.  The size of
X    0 means that Addstr is calling itself at the the beginning of the string
X    all the time.  The fix is in copy_msg where it checks to see if the
X    window is large enough to attempt printing the message (msgs.c, copy_msg())
X
X    When changing folders, if there are no messages in the new folder,
X    the last read message was still displayed leaving the user somewhat
X    confused.  If there are no messages, the window is cleared. (folders.c)
X
X    To be consistent with the other two interfaces, both delete and
X    backspace will backspace if in type-in mode. (rite.c)
X
X    When returning from using the editor, the window displaying the letter
X    being composed would contain what the letter looked like before the editor
X    was invoked.  This has been fixed by printing out the last part of the
X    letter up to the size of the window available.
END_OF_FILE
if test 16733 -ne `wc -c <'README-6.0'`; then
    echo shar: \"'README-6.0'\" unpacked with wrong size!
fi
# end of 'README-6.0'
fi
if test -f 'bindings.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bindings.h'\"
else
echo shar: Extracting \"'bindings.h'\" \(2947 characters\)
sed "s/^X//" >'bindings.h' <<'END_OF_FILE'
X/* bindings.h  -- command bindings */
X
X#define MAX_BIND_LEN 20   /* max length a string can be to bind to a command */
X#define MAX_MACRO_LEN 256 /* max length of a macro bound to a command */
X
X/* to see if a key sequence matches, prefixes or misses a set binding */
X#define NO_MATCH	0
X#define MATCH		1
X#define A_PREFIX_B	2
X#define B_PREFIX_A	3
X
X/*
X * Constants to define curses mode functions.
X */
X#ifdef NULL_MAP
X#undef NULL_MAP
X#endif /* NULL_MAP */
X#define NULL_MAP	(struct cmd_map *)0
X
X#define C_ERROR		(-1L)
X#define C_NULL		0L
X#define C_GOTO_MSG	1L
X#define C_WRITE_LIST	2L
X#define C_WRITE_MSG	3L
X#define C_SAVE_LIST	4L
X#define C_SAVE_MSG	5L
X#define C_COPY_LIST	6L
X#define C_COPY_MSG	7L
X#define C_DELETE_LIST	8L
X#define C_DELETE_MSG	9L
X#define C_UNDEL_LIST	10L
X#define C_UNDEL_MSG	11L
X#define C_REDRAW	12L
X#define C_REVERSE	13L
X#define C_NEXT_MSG	14L
X#define C_PREV_MSG	15L
X#define C_FIRST_MSG	16L
X#define C_LAST_MSG	17L
X#define C_TOP_PAGE	18L
X#define C_BOTTOM_PAGE	19L
X#define C_NEXT_SCREEN	20L
X#define C_PREV_SCREEN	21L
X#define C_SOURCE	22L
X#define C_SAVEOPTS	23L
X#define C_NEXT_SEARCH	24L
X#define C_PREV_SEARCH	25L
X#define C_CONT_SEARCH	26L
X#define C_PRESERVE	27L
X#define C_REV_SORT	28L
X#define C_SORT		29L
X#define C_QUIT_HARD	30L
X#define C_QUIT		31L
X#define C_EXIT_HARD	32L
X#define C_EXIT		33L
X#define C_UPDATE	34L
X#define C_FOLDER	35L
X#define C_SHELL_ESC	36L
X#define C_CURSES_ESC	37L
X#define C_PRINT_MSG	38L
X#define C_CHDIR		39L
X#define C_VAR_SET	40L
X#define C_IGNORE	41L
X#define C_ALIAS		42L
X#define C_OWN_HDR	43L
X#define C_VERSION	44L
X#define C_MAIL_FLAGS	45L
X#define C_MAIL		46L
X#define C_REPLY_ALL	47L
X#define C_REPLY_SENDER	48L
X#define C_DISPLAY_NEXT	49L
X#define C_DISPLAY_MSG	50L
X#define C_TOP_MSG	51L
X#define C_BIND_MACRO	52L
X#define C_BIND		53L
X#define C_UNBIND	54L
X#define C_MAP_BANG	55L
X#define C_MAP		56L
X#define C_MACRO		57L
X#define C_HELP		58L/* THIS MUST BE THE LAST ITEM */
X
Xstruct cmd_map {
X    /* long so glob_flags can be saved in mac_stack */
X    long m_cmd;   /* the command this is mapped to  */
X    char *m_str;  /* the string user types (cbreak) */
X    char *x_str;  /* the string executed if a macro */
X    struct cmd_map *m_next;
X};
X
X#ifdef CURSES
X
X/*
X * Pointers to the current active command or macro and to the map list.
X *  This ought to be handled by having getcmd() return struct cmd_map *,
X *  but curses_command() depends too heavily on getcmd() returning int.
X */
Xextern struct cmd_map *active_cmd, *cmd_map;
X
X#endif /* CURSES */
X
X/* This must be OUTSIDE the #ifdef CURSES -- needed in other modes */
Xextern struct cmd_map *mac_hide;
X
X/*
X * Special bracketing recognized within an executing
X *  macro as surrounding a curses function name
X */
X#define MAC_LONG_CMD	'['
X#define MAC_LONG_END	']'
X#define MAC_GET_STR	"getstr"
X#define MAC_GET_LINE	"getline"
X#define MAX_LONG_CMD	32
X
X/*
X * External declarations for map and map! purposes
X */
Xextern char *c_macro();
Xextern struct cmd_map *line_map, *bang_map;
END_OF_FILE
if test 2947 -ne `wc -c <'bindings.h'`; then
    echo shar: \"'bindings.h'\" unpacked with wrong size!
fi
# end of 'bindings.h'
fi
if test -f 'config.h-dist' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config.h-dist'\"
else
echo shar: Extracting \"'config.h-dist'\" \(3190 characters\)
sed "s/^X//" >'config.h-dist' <<'END_OF_FILE'
X/* config.h 1.1	(c) copyright 1986 (Dan Heller) */
X
X#define MAILRC		".mushrc"
X#define ALTERNATE_RC	".mailrc"
X#define DEFAULT_RC	"/usr/lib/Mail.rc"
X#define COMMAND_HELP	"/usr/lib/cmd_help"
X#ifdef SUNTOOL
X#    define TOOL_HELP	"/usr/lib/tool_help"
X#endif /* SUNTOOL */
X#define ALTERNATE_HOME	"/tmp"       /* Path must be read/write to EVERYONE */
X#define EDFILE  	".edXXXXXX"  /* file/pathname added to user's "home" */
X
X/* mail delivery system */
X#ifdef MMDF
X#define MAIL_DELIVERY	"exec MMDFBIN/submit -mlnr"
X#define VERBOSE_ARG	"W"
X#else /* MMDF */
X#define MAIL_DELIVERY	"/usr/lib/sendmail -i"
X#define VERBOSE_ARG	"-v"    /* undef if none exists */
X#define METOO_ARG	"-m"    /* man sendmail for more info. */
X#endif /* MMDF */
X
X/* Headers that will NOT be included when forwarding mail */
X#define IGNORE_ON_FWD	"status"
X
X#define	MAXMSGS		1000	/* maximum number of messages we can read */
X#define HDRSIZ BUFSIZ	/* This should not be < BUFSIZ! (but can be >) */
X
X#define VPRINTF		/* If your system supports the vprintf() functions,
X			 * True for sys-v and later sun versions (3.0+ ?).
X			 */
X
X/* If your mail transfer agent uses something *besides* "From " to separate
X * adjacent messages in a folder, define MSG_SEPARATOR to be this string.
X * If that string is 4 ^A's, then the string would be "\001\001\001\001"
X * If you don't know what this means, leave it alone.
X */
X/* #define MSG_SEPARATOR "From " */
X#ifdef MMDF
X#ifndef OLD_MAILER
X#define OLD_MAILER
X#endif /* OLD_MAILER */
X/*
X * These values should be identical (respectively) to the contents of
X * delim1 and delim2 in MMDFSRC/conf/yoursite/conf.c (sans newline).
X */
X#define MSG_SEPARATOR	"\001\001\001\001\n"
X#define END_MSG_SEP	"\001\001\001\001\n"
X/*
X * You only need to define LCKDFLDIR if you have MMDF configured to use a
X * locking module which accesses the global MMDF variable "lckdfldir".
X * Most of you WILL NOT need this, since you probably use one of the more
X * sophisticated locking modules provided with MMDF.
X */
X/* #define LCKDFLDIR	"/usr/spool/mmdf/lockfiles" */
X
X/*
X * IMPORTANT NOTE: If you are trying to use mush with MMDF, you need to
X * remove most of the LOCFUN declarations in the MMDF locking module which
X * is in use at your site and recompile the MMDF library.  The only function
X * which need not appear in the new libmmdf.a is lk_name().
X */
X#endif /* MMDF */
X
X#define LS_COMMAND	"ls"
X#define FORTUNE		"/usr/games/fortune"
X#define LPR		"lpr"
X#define SIGNATURE	".signature"
X#ifdef HOMEMAIL
X#define MAILFILE	"Mailbox"	/* or whatever */
X#else /* HOMEMAIL */
X#define MAILDIR		"/usr/spool/mail"
X#endif /* HOMEMAIL */
X
X/* default settings for some variable strings */
X#define DEF_PROMPT	"Msg %m of %t: "
X#define DEF_PAGER	"more" /* set to "internal" to use internal pager */
X#define DEF_SHELL	"csh"
X#define DEF_EDITOR	"vi"
X#define DEF_FOLDER	"~/Mail"        /* default Mail folder */
X#define DEF_MBOX	"~/mbox"	/* default mbox */
X#define DEF_INDENT_STR	"> "		/* indent included mail */
X#define DEF_PRINTER	"lp"
X#define DEF_ESCAPE	"~"
X#define DEF_HDR_FMT	"%25f %7d (%l/%c) \"%s\"" /* default hdr_format */
X#define DEF_CURSES_HELP	\
X    "display save mail reply next-msg back-msg screen-next screen-back"
END_OF_FILE
if test 3190 -ne `wc -c <'config.h-dist'`; then
    echo shar: \"'config.h-dist'\" unpacked with wrong size!
fi
# end of 'config.h-dist'
fi
if test -f 'edit_menu.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'edit_menu.c'\"
else
echo shar: Extracting \"'edit_menu.c'\" \(3334 characters\)
sed "s/^X//" >'edit_menu.c' <<'END_OF_FILE'
X/* @(#)edit_menu.c	(c) copyright	10/18/86 (Dan Heller) */
X
X/* edit_menu.c
X * 
X * Routine which handles the menu you get when in the msg_win while editing
X * a letter.  This is just a fancy front end for ~ commands (nyuk, nyuk).
X */
X#include "mush.h"
X
X#define EDIT_IT     	(char *)'e'
X#define PAGE     	(char *)'p'
X#define INC 	 	(char *)'i'
X#define INC_HDR		(char *)'H'
X#define FWD_MSG		(char *)'f'
X#define TO_LIST		(char *)'t'
X#define SUBJECT		(char *)'s'
X#define CC_LIST		(char *)'c'
X#define BC_LIST		(char *)'b'
X#define ALL_HDR		(char *)'h'
X#define SIGN_IT		(char *)'S'
X#define NO_SIGN		(char *)'n'
X#define FORT		(char *)'F'
X#define NO_FORT		(char *)'N'
X#define ERASE   	(char *)'E'
X#define SEND	   	(char *)'X'
X#define ABORT   	(char *)'q'
X#define MENU_HELP	(char *)'?'
X
Xstatic struct menuitem edit_items[] = {
X    { MENU_IMAGESTRING,  "Enter Editor",	EDIT_IT  },
X    { MENU_IMAGESTRING,  "Send Letter",		SEND     },
X    { MENU_IMAGESTRING,  "Abort Letter",	ABORT    },
X    { MENU_IMAGESTRING,  "Review Letter",	PAGE     },
X    { MENU_IMAGESTRING,  "Include Message",	INC      },
X    { MENU_IMAGESTRING,  "Inc. msg w/hdr",	INC_HDR  },
X    { MENU_IMAGESTRING,  "Forward message",	FWD_MSG  },
X    { MENU_IMAGESTRING,  "Change To line",	TO_LIST  },
X    { MENU_IMAGESTRING,  "Change Subject",	SUBJECT  },
X    { MENU_IMAGESTRING,  "Change Cc list",	CC_LIST  },
X    { MENU_IMAGESTRING,  "Change Bcc list",	BC_LIST  },
X    { MENU_IMAGESTRING,  "Change All hdrs",	ALL_HDR  },
X    { MENU_IMAGESTRING,  "Add .signature",	SIGN_IT  },
X    { MENU_IMAGESTRING,  "No .signature",	NO_SIGN  },
X    { MENU_IMAGESTRING,  "Add a fortune",	FORT     },
X    { MENU_IMAGESTRING,  "No fortune",		NO_FORT  },
X    { MENU_IMAGESTRING,  "Erase Message",	ERASE    },
X    { MENU_IMAGESTRING,  "Help",		MENU_HELP  }
X};
X
Xstatic struct menu menu = {
X    MENU_IMAGESTRING, "Editing options",
X    sizeof (edit_items) / sizeof (struct menuitem), edit_items,
X    (struct menu *)NULL,
X    NULL
X};
X
Xedit_menu(event, fd)
Xstruct inputevent *event;
X{
X    static char buf[5];
X    struct menuitem *m_item;
X    register char *action, *p = buf+1;
X    struct menu *menu_ptr = &menu;
X
X    if (!(m_item = menu_display(&menu_ptr, event, fd)) || get_hdr_field) {
X	if (get_hdr_field)
X	    print("Finish the message header first.");
X	return;
X    }
X    action = m_item->mi_data;
X    if (txt.x > 5)
X	add_to_letter(rite('\n'));  /* flush line for him */
X
X    if (!msg_cnt && (action == INC || action == INC_HDR || action == FWD_MSG)) {
X	print("No messages to include");
X	return;
X    }
X    buf[0] = *escape;
X    switch(action) {
X	case EDIT_IT  : (void) strcpy(p, "v");
X	when PAGE     : (void) strcpy(p, "p");
X	when INC      : (void) strcpy(p, "i");
X	when INC_HDR  : (void) strcpy(p, "H");
X	when ALL_HDR  : (void) strcpy(p, "h");
X	when SUBJECT  : (void) strcpy(p, "s");
X	when TO_LIST  : (void) strcpy(p, "t");
X	when CC_LIST  : (void) strcpy(p, "c");
X	when BC_LIST  : (void) strcpy(p, "b");
X	when FWD_MSG  : (void) strcpy(p, "f");
X	when SIGN_IT  : (void) strcpy(p, "S");
X	when NO_SIGN  : (void) strcpy(p, "S!");
X	when FORT     : (void) strcpy(p, "F");
X	when NO_FORT  : (void) strcpy(p, "F!");
X	when ERASE    : (void) strcpy(p, "E");
X	when ABORT    : (void) strcpy(p, "q");
X	when SEND     : finish_up_letter(); return;
X	otherwise     : (void) strcpy(p, "?");
X    }
X    add_to_letter(buf);
X}
END_OF_FILE
if test 3334 -ne `wc -c <'edit_menu.c'`; then
    echo shar: \"'edit_menu.c'\" unpacked with wrong size!
fi
# end of 'edit_menu.c'
fi
if test -f 'hdr_panel.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hdr_panel.c'\"
else
echo shar: Extracting \"'hdr_panel.c'\" \(4107 characters\)
sed "s/^X//" >'hdr_panel.c' <<'END_OF_FILE'
X/* @(#)hdr_panel.c	(c) copyright	10/18/86 (Dan Heller) */
X
X#include "mush.h"
X
Xmake_hdr_panel(choice_args, button_args)
Xchar **choice_args, **button_args;
X{
X    hdr_panel_sw = panel_create(tool,
X	PANEL_HEIGHT, 30,
X	0);
X    hdr_panel = (Panel)hdr_panel_sw->ts_data;
X
X    msg_num_item = panel_create_item(hdr_panel, PANEL_TEXT,
X	PANEL_ATTRIBUTE_LIST,		choice_args,
X	PANEL_ITEM_X,			4,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_STRING,		"Range:",
X	PANEL_MENU_CHOICE_STRINGS, 	"Help", 0,
X	PANEL_VALUE_DISPLAY_LENGTH, 	10,
X	PANEL_VALUE_STORED_LENGTH, 	80,
X	PANEL_LABEL_FONT, 		fonts[DEFAULT],
X	PANEL_NOTIFY_STRING, 		"\n\r",
X	PANEL_NOTIFY_PROC, 		msg_num_done,
X	0);
X
X    sub_hdr_item[0] = panel_create_item(hdr_panel, PANEL_CHOICE,
X	PANEL_ATTRIBUTE_LIST, 		choice_args,
X	PANEL_ITEM_X,			149,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_IMAGE,    		&mouse_left,
X	PANEL_CHOICE_STRINGS, 		"Help", 0,
X	PANEL_NOTIFY_PROC,    		read_mail,
X	0);
X    sub_hdr_item[1] = panel_create_item(hdr_panel, PANEL_CHOICE,
X	PANEL_ATTRIBUTE_LIST, 		choice_args,
X	PANEL_ITEM_X,			174,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_STRING,   		"Read ",
X	PANEL_MENU_TITLE_IMAGE, 	&mouse_left,
X	PANEL_CHOICE_STRINGS,		"Help", 0,
X	PANEL_NOTIFY_PROC,    		read_mail,
X	0);
X    sub_hdr_item[2] = panel_create_item(hdr_panel, PANEL_CHOICE,
X	PANEL_ATTRIBUTE_LIST, 		choice_args,
X	PANEL_ITEM_X,			223,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_IMAGE,    		&mouse_middle,
X	PANEL_CHOICE_STRINGS, 		"Help", 0,
X	PANEL_NOTIFY_PROC,    		delete_mail,
X	0);
X    sub_hdr_item[3] = panel_create_item(hdr_panel, PANEL_CHOICE,
X	PANEL_ATTRIBUTE_LIST, 		choice_args,
X	PANEL_ITEM_X,			248,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_STRING,   		"Delete ",
X	PANEL_MENU_TITLE_IMAGE, 	&mouse_middle,
X	PANEL_CHOICE_STRINGS, 		"Help", 0,
X	PANEL_NOTIFY_PROC,    		delete_mail,
X	0);
X    sub_hdr_item[4] = panel_create_item(hdr_panel, PANEL_CHOICE,
X	PANEL_ATTRIBUTE_LIST, 		choice_args,
X	PANEL_ITEM_X,			313,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_IMAGE,    		&mouse_right,
X	PANEL_CHOICE_STRINGS, 		"Help", 0,
X	PANEL_NOTIFY_PROC,    		read_mail,
X	0);
X    sub_hdr_item[5] = panel_create_item(hdr_panel, PANEL_CHOICE,
X	PANEL_ATTRIBUTE_LIST, 		choice_args,
X	PANEL_ITEM_X,			338,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_STRING,   		"Menu ",
X	PANEL_MENU_TITLE_IMAGE,	    	&mouse_right,
X	PANEL_CHOICE_STRINGS, 		"Help", 0,
X	PANEL_NOTIFY_PROC,    		read_mail,
X	0);
X
X    hdr_display = panel_create_item(hdr_panel, PANEL_CHOICE,
X	PANEL_ATTRIBUTE_LIST, 		choice_args,
X	PANEL_ITEM_X,			387,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_IMAGE,
X	    panel_button_image(hdr_panel, "Display", 7, fonts[DEFAULT]),
X	PANEL_MENU_TITLE_STRING, 	"Header Display Formats",
X	PANEL_CHOICE_STRINGS, 		"Show Deleted Messages",
X					"Don't Show Deleted Messages",
X					"Current Header in Bold Text",
X					"Current Header in Reverse Text",
X					"Help",
X					0,
X	PANEL_NOTIFY_PROC, 		display_hdrs,
X	0);
X
X    ignore_item = panel_create_item(hdr_panel, PANEL_CHOICE,
X	PANEL_ATTRIBUTE_LIST, choice_args,
X	PANEL_ITEM_X,			464,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_IMAGE,
X	    panel_button_image(hdr_panel, "Headers", 7, fonts[DEFAULT]),
X	PANEL_MENU_TITLE_STRING, 	"Ignored Headers",
X	PANEL_CHOICE_STRINGS, 		"Current Settings",
X					"Add Values",
X					"Delete Values",
X					"Help",
X					0,
X	PANEL_NOTIFY_PROC, 		p_set_opts,
X	0);
X
X    next_scr = panel_create_item(hdr_panel, PANEL_CHOICE,
X	PANEL_ATTRIBUTE_LIST, 		choice_args,
X	PANEL_ITEM_X,			541,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_IMAGE,
X	    panel_button_image(hdr_panel, "Next", 4, fonts[DEFAULT]),
X	PANEL_MENU_TITLE_STRING, 	"Display Message Headers",
X	PANEL_CHOICE_STRINGS, 		"Show Next screenful",
X					"Show Previous screenful",
X					0,
X	PANEL_SHOW_ITEM, 		FALSE,
X	PANEL_NOTIFY_PROC,		do_hdr,
X	0);
X
X    prev_scr = panel_create_item(hdr_panel, PANEL_CHOICE,
X	PANEL_ATTRIBUTE_LIST, 		choice_args,
X	PANEL_ITEM_X,			594,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_IMAGE,
X	    panel_button_image(hdr_panel, "Prev", 4, fonts[DEFAULT]),
X	PANEL_MENU_TITLE_STRING, 	"Display Message Headers",
X	PANEL_CHOICE_STRINGS, 		"Show Previous screenful",
X					"Show Next screenful",
X					0,
X	PANEL_SHOW_ITEM, 		FALSE,
X	PANEL_NOTIFY_PROC, 		do_hdr,
X	0);
X}
END_OF_FILE
if test 4107 -ne `wc -c <'hdr_panel.c'`; then
    echo shar: \"'hdr_panel.c'\" unpacked with wrong size!
fi
# end of 'hdr_panel.c'
fi
if test -f 'lock.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lock.c'\"
else
echo shar: Extracting \"'lock.c'\" \(3517 characters\)
sed "s/^X//" >'lock.c' <<'END_OF_FILE'
X/*
X * lock.c -- deal with file locking on various architectures and UNIXs.
X * dot_lock() creates a file with the same name as the parameter passed
X * with the appendage ".lock" -- this is to be compatible with certain
X * systems that don't use flock or lockf or whatever they have available
X * that they don't use.
X */
X
X#ifdef USG
X#include <unistd.h>
X#endif /* USG */
X#include "mush.h"
X#if defined(SYSV) && !defined(USG)
X#include <sys/locking.h>
X#endif /* SYSV && !USG */
X
Xextern int sgid;
X#ifdef BSD
Xextern int rgid;
X#endif /* BSD */
X
X#ifdef DOT_LOCK
Xdot_lock(filename)
Xchar *filename;
X{
X    char buf[MAXPATHLEN];
X    int lockfd, cnt = 0;
X    SIGRET (*oldint)(), (*oldquit)();
X
X#ifdef BSD
X    setregid(rgid, sgid);
X#else
X    setgid(sgid);
X#endif /* BSD */
X#ifdef M_XENIX
X    if (strcmp(spoolfile, mailfile) == 0)
X	(void) sprintf(buf, "/tmp/%.10s.mlk", login);
X    else
X#endif /* M_XENIX */
X    (void) sprintf(buf, "%s.lock", filename);
X    on_intr();
X    while ((lockfd = open(buf, O_CREAT|O_WRONLY|O_EXCL, 0600)) == -1) {
X	if (errno != EEXIST) {
X	    error("unable to lock %s", filename);
X	    break;
X	}
X	if (cnt++ == 0)
X	    print("%s already locked, waiting", filename);
X	else
X	    print_more(".");
X	sleep(1);
X	if (ison(glob_flags, WAS_INTR)) {
X	    print_more("\nAborted.\n");
X	    break;
X	}
X    }
X    off_intr();
X    if (lockfd != -1) {
X	if (cnt)
X	    print("done.\n");
X	(void) close(lockfd);
X    }
X#ifdef BSD
X    setregid(sgid, rgid);
X#else
X    setgid(getgid());
X#endif /* BSD */
X    return lockfd == -1? -1 : 0;
X}
X#endif /* DOT_LOCK */
X
Xlock_file(filename, fp)
Xchar *filename;
XFILE *fp;
X{
X#ifdef MMDF
X    if (Access(filename, W_OK) || lk_lock(filename, NULL, NULL, 0))
X	return -1;
X#else /* MMDF */
X    int fd = fileno(fp);
X
X    if (debug && do_set(set_options, "deadlock")) {
X	un_set(&set_options, "deadlock");
X	return -1;
X    }
X#ifdef SYSV
X#ifndef USG
X    (void) locking(fd, LK_LOCK, 0); /* old xenix (sys III) */
X#else
X    /* if unable to lock, tell them */
X    if (Access(filename, W_OK) || lockf(fd, F_LOCK, 0L)) /* system-v */
X	return -1;
X#endif /* USG */
X#else
X#ifdef BSD
X    {
X	int cnt = 0;
X	SIGRET (*oldint)(), (*oldquit)();
X	on_intr();
X	while (isoff(glob_flags, WAS_INTR) && flock(fd, LOCK_EX | LOCK_NB)) {
X	    if (errno == EWOULDBLOCK)
X		if (!cnt)
X		    print("waiting to lock \"%s\"", filename);
X		else
X		    cnt++, print(".");
X	    else {
X		error("Unable to lock %s", filename);
X		off_intr();
X		return -1;
X	    }
X	    sleep(1);
X	}
X	if (cnt)
X	    print("\n");
X	off_intr();
X	if (ison(glob_flags, WAS_INTR))
X	    return -1;
X    }
X#else /* BSD */
X    if (ison(glob_flags, WARNING))
X	print("There is no supported file locking function!\n");
X#endif /* BSD */
X#endif /* SYSV */
X#endif /* MMDF */
X    return 0;
X}
X
Xvoid
Xclose_lock(filename, fp)
Xchar *filename;
XFILE *fp;
X#ifdef MMDF
X{
X    (void) lk_unlock(filename, NULL, NULL);
X    fclose(fp);
X}
X#endif /* MMDF */
X{
X#ifdef DOT_LOCK
X    char buf[MAXPATHLEN];
X#ifdef BSD
X    setregid(rgid, sgid);
X#else
X    setgid(sgid);
X#endif /* BSD */
X#ifdef M_XENIX
X    if (strcmp(spoolfile, mailfile) == 0)
X	(void) unlink(sprintf(buf, "/tmp/%.10s.mlk", login));
X    else
X#endif /* M_XENIX */
X    (void) unlink(sprintf(buf, "%s.lock", filename));
X#ifdef BSD
X    setregid(sgid, rgid);
X#else
X    setgid(getgid());
X#endif /* BSD */
X#endif /* DOT_LOCK */
X
X#ifdef BSD
X    flock(fileno(fp), LOCK_UN);
X#endif /* BSD */
X#ifdef SYSV
X#ifndef USG
X    locking(fileno(fp), LK_UNLCK, 0);
X#else
X    lockf(fileno(fp), F_ULOCK, 0L);
X#endif /* USG */
X#endif /* SYSV */
X    fclose(fp);
X}
END_OF_FILE
if test 3517 -ne `wc -c <'lock.c'`; then
    echo shar: \"'lock.c'\" unpacked with wrong size!
fi
# end of 'lock.c'
fi
if test -f 'mail.icon.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mail.icon.1'\"
else
echo shar: Extracting \"'mail.icon.1'\" \(1933 characters\)
sed "s/^X//" >'mail.icon.1' <<'END_OF_FILE'
X/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
X */
X	0xFFFF,0xFFFF,0xFFFF,0xFFFF,0x8000,0x0000,0x0000,0x0001,
X	0x8000,0x0000,0x0000,0x0001,0x8000,0x0000,0x0000,0x0001,
X	0x8000,0x0000,0x0000,0x0001,0x8000,0x0000,0x0000,0x0001,
X	0x8000,0x0000,0x0000,0x0001,0x8000,0x0000,0x0000,0x0001,
X	0x8000,0x0000,0x0000,0x0001,0x8000,0x1FFF,0xFFFF,0xFE01,
X	0x8000,0xFE00,0x0000,0x0181,0x8007,0x01C0,0x0000,0x0061,
X	0x8018,0x0030,0x0000,0x0011,0x8020,0x7008,0x0000,0x0011,
X	0x80C1,0xFC06,0x0000,0x0009,0x8101,0xFC01,0x0000,0x0009,
X	0x8103,0xFE01,0x0000,0x0005,0x8203,0xFE00,0x8000,0x0005,
X	0x8403,0xFE00,0x4000,0x0005,0x8401,0xFC00,0x4000,0x0005,
X	0x8801,0xFC00,0x2000,0x0005,0x8800,0x7000,0x2000,0x0005,
X	0x8800,0x0000,0x3000,0x0005,0x9000,0x0000,0x1000,0x0005,
X	0x9000,0x0000,0x1000,0x0005,0x93FF,0xFFFF,0x9000,0x0025,
X	0xA200,0x0000,0x9000,0x00E5,0xA200,0x0000,0x9000,0x03A5,
X	0xA200,0x0000,0x9000,0x0625,0xA3FF,0xFFFF,0x9000,0x1C25,
X	0xA000,0x0000,0x1000,0x3425,0xA000,0x0000,0x1000,0xC425,
X	0xA000,0x0000,0x1003,0x8425,0xA000,0x0000,0x1006,0x0425,
X	0xA000,0x0000,0x101C,0x0425,0xA000,0x0000,0x11F0,0x0425,
X	0xA000,0x0000,0x13E0,0x0445,0xA000,0x0000,0x13E0,0x0585,
X	0xA000,0x0000,0x13E0,0x0605,0xA000,0x0000,0x11C0,0x0405,
X	0xA000,0x0000,0x1000,0x000D,0xA000,0x0000,0x1000,0x0011,
X	0xA000,0x0000,0x1000,0x0021,0xA000,0x0000,0x1000,0x00C1,
X	0xA000,0x0000,0x1000,0x0101,0xA000,0x0000,0x1000,0x0601,
X	0xA000,0x0000,0x1000,0x0801,0xA000,0x0000,0x1000,0x3801,
X	0xA000,0x0000,0x1000,0x4801,0xA000,0x0000,0x1000,0x8801,
X	0xA000,0x0000,0x1003,0x0801,0xA000,0x0000,0x1004,0x0801,
X	0xA000,0x0000,0x101C,0x0801,0xA000,0x0000,0x1024,0x0801,
X	0xA000,0x0000,0x1044,0x0801,0xA000,0x0000,0x1184,0x0801,
X	0xA000,0x0000,0x1204,0x0801,0xA000,0x0000,0x1404,0x0801,
X	0xBFFF,0xFFFF,0xF804,0x0801,0x8000,0x0000,0x0004,0x0801,
X	0x8000,0x0000,0x0004,0x0801,0x8000,0x0000,0x0004,0x0801,
X	0x8000,0x0000,0x0004,0x0801,0xFFFF,0xFFFF,0xFFFF,0xFFFF
END_OF_FILE
if test 1933 -ne `wc -c <'mail.icon.1'`; then
    echo shar: \"'mail.icon.1'\" unpacked with wrong size!
fi
# end of 'mail.icon.1'
fi
if test -f 'mail.icon.2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mail.icon.2'\"
else
echo shar: Extracting \"'mail.icon.2'\" \(1933 characters\)
sed "s/^X//" >'mail.icon.2' <<'END_OF_FILE'
X/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
X */
X	0xFFFF,0xFFFF,0xFFFF,0xFFFF,0x8000,0x0000,0x0000,0x0001,
X	0x8000,0x0000,0x0000,0x0001,0x8000,0x0000,0x00E0,0x0001,
X	0x8000,0x0000,0x00DE,0x0001,0x8000,0x0000,0x00C1,0xE001,
X	0x8000,0x0000,0x00C0,0x1801,0x8000,0x0000,0x00C0,0x0801,
X	0x8000,0x0000,0x00C0,0x0801,0x8000,0x1FFF,0xFFC0,0x0E01,
X	0x8000,0xFE00,0x00C0,0x0981,0x8007,0x01C0,0x00C0,0x0861,
X	0x8018,0x0030,0x00C0,0x0811,0x8020,0x7008,0x00C0,0x0811,
X	0x80C1,0xFC06,0x00C0,0x1809,0x8101,0xBC01,0x00C0,0x6009,
X	0x8103,0x1E01,0x00C1,0x8005,0x8202,0x0E00,0x80C6,0x0005,
X	0x8404,0x0400,0x40D8,0x0005,0x8408,0x0200,0x40E0,0x0005,
X	0x8810,0x0100,0x20C0,0x0005,0x8820,0x6080,0x20C0,0x0005,
X	0x8840,0x4040,0x30C0,0x0005,0x9081,0x3020,0x10C0,0x0005,
X	0x9041,0x9C10,0x10C0,0x0005,0x93E0,0x8A0F,0x90C0,0x0005,
X	0xA210,0x6404,0x90C0,0x0005,0xA208,0x3002,0x90C0,0x0005,
X	0xA204,0x1401,0x90C0,0x0005,0xA3FF,0xFFFF,0x90C0,0x0005,
X	0xA000,0x0000,0x10C0,0x0005,0xA000,0x0000,0x10C0,0x0005,
X	0xA000,0x0000,0x10C0,0x0005,0xA000,0x0000,0x10C0,0x0005,
X	0xA000,0x0000,0x10C0,0x0005,0xA000,0x0000,0x11C0,0x0005,
X	0xA000,0x0000,0x13E0,0x0005,0xA000,0x0000,0x13E0,0x0005,
X	0xA000,0x0000,0x13E0,0x0005,0xA000,0x0000,0x11C0,0x0005,
X	0xA000,0x0000,0x1000,0x000D,0xA000,0x0000,0x1000,0x0011,
X	0xA000,0x0000,0x1000,0x0021,0xA000,0x0000,0x1000,0x00C1,
X	0xA000,0x0000,0x1000,0x0101,0xA000,0x0000,0x1000,0x0601,
X	0xA000,0x0000,0x1000,0x0801,0xA000,0x0000,0x1000,0x3001,
X	0xA000,0x0000,0x1000,0x4001,0xA000,0x0000,0x1000,0x8001,
X	0xA000,0x0000,0x1003,0x8001,0xA000,0x0000,0x1004,0x8001,
X	0xA000,0x0000,0x1018,0x8001,0xA000,0x0000,0x1020,0x8001,
X	0xA000,0x0000,0x1060,0x8001,0xA000,0x0000,0x1180,0x8001,
X	0xA000,0x0000,0x1280,0x8001,0xA000,0x0000,0x1480,0x8001,
X	0xBFFF,0xFFFF,0xFC80,0x8001,0x8000,0x0000,0x0080,0x8001,
X	0x8000,0x0000,0x0080,0x8001,0x8000,0x0000,0x0080,0x8001,
X	0x8000,0x0000,0x0080,0x8001,0xFFFF,0xFFFF,0xFFFF,0xFFFF
END_OF_FILE
if test 1933 -ne `wc -c <'mail.icon.2'`; then
    echo shar: \"'mail.icon.2'\" unpacked with wrong size!
fi
# end of 'mail.icon.2'
fi
if test -f 'makefile.bsd' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.bsd'\"
else
echo shar: Extracting \"'makefile.bsd'\" \(1341 characters\)
sed "s/^X//" >'makefile.bsd' <<'END_OF_FILE'
X# makefile.bsd	(c) copyright 1986	(Dan Heller)
X# sunOS-4.0 users should add -DSIGRET=void to the CFLAGS line below.
X#
XHDRS= mush.h config.h-dist strings.h bindings.h options.h
X
XSRCS= main.c init.c misc.c mail.c hdrs.c execute.c commands.c print.c dates.c \
X      signals.c setopts.c msgs.c pick.c sort.c expr.c folders.c \
X      loop.c help.c viewopts.c curses.c curs_io.c bind.c file.c strings.c \
X      lock.c macros.c options.c addrs.c
XOBJS= main.o init.o misc.o mail.o hdrs.o execute.o commands.o print.o file.o \
X      signals.o setopts.o msgs.o pick.o sort.o expr.o strings.o \
X      folders.o dates.o loop.o help.o viewopts.o curses.o curs_io.o bind.o \
X      lock.o macros.o options.o addrs.o
X
XHELP_FILES= README README-6.0 README-6.1 README-6.2 README-6.3 README-6.4 \
X	mush.1 Mailrc Gnurc cmd_help sample.mushrc advanced.mushrc
X
XMAKES= makefile.bsd makefile.xenix makefile.sys.v
X
XCFLAGS= -O -DCURSES -DBSD
XLDFLAGS= -s
XLINTFLAGS= -bxah -Dlint -DCURSES -DBSD
XLIBES= -lcurses -ltermlib
X
Xmush: $(OBJS)
X	@echo loading...
X	@cc $(LDFLAGS) $(OBJS) $(LIBES) -o mush
X
Xtape:
X	@tar cv $(MAKES) $(HDRS) $(SRCS) $(HELP_FILES)
X
Xtar:
X	@tar fcv MUSH $(MAKES) $(HDRS) $(SRCS) $(HELP_FILES)
X
Xtarmail:
X	tar fcv - $(MAKES) $(HDRS) $(SRCS) $(HELP_FILES) | \
X	compress | btoa > mush.tarmail
X
Xlint:
X	lint $(LINTFLAGS) $(SRCS)
X
Xclean:
X	rm -f *.o core mush
END_OF_FILE
if test 1341 -ne `wc -c <'makefile.bsd'`; then
    echo shar: \"'makefile.bsd'\" unpacked with wrong size!
fi
# end of 'makefile.bsd'
fi
if test -f 'makefile.sun' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.sun'\"
else
echo shar: Extracting \"'makefile.sun'\" \(1569 characters\)
sed "s/^X//" >'makefile.sun' <<'END_OF_FILE'
X# makefile.sun	(c) copyright 1986	(Dan Heller)
X# sunOS-4.0 users should add -DSIGRET=void to the CFLAGS line below.
X#
XHDRS= mush.h config.h-dist strings.h bindings.h options.h
X
XSRCS= main.c init.c misc.c mail.c hdrs.c execute.c commands.c rite.c \
X      select.c doproc.c print.c signals.c addrs.c setopts.c msgs.c \
X      hdr_procs.c tool.c hdr_panel.c main_panel.c help.c viewopts.c sort.c \
X      pick.c fkeys.c expr.c folders.c dates.c loop.c edit_menu.c \
X      curses.c curs_io.c bind.c file.c strings.c lock.c macros.c options.c
X
XOBJS= main.o init.o misc.o mail.o hdrs.o execute.o commands.o rite.o \
X      select.o doproc.o print.o signals.o addrs.o setopts.o msgs.o \
X      hdr_procs.o tool.o hdr_panel.o main_panel.o help.o viewopts.o sort.o \
X      pick.o fkeys.o expr.o folders.o dates.o loop.o edit_menu.o \
X      curses.o curs_io.o bind.o file.o strings.o lock.o macros.o options.o
X
XIMAGES= mail.icon.1 mail.icon.2 check.pr cycle.pr envelope.pr glasses.pr \
X	write.pr up.arrow.pr dn.arrow.pr coffee.cup.pr
X
XHELP_FILES= README README-6.0 README-6.1 README-6.2 README-6.3 README-6.4 \
X	mush.1 Mailrc Gnurc sample.mushrc advanced.mushrc cmd_help tool_help
X
XMAKES= makefile.sun makefile.bsd makefile.sys.v makefile.xenix
X
XCFLAGS= -O -DSUNTOOL -DCURSES -DBSD
XLDFLAGS= -s
XLIBES= -lcurses -ltermlib -lsuntool -lsunwindow -lpixrect
XLINTFLAGS= -bxah -Dlint
X
Xmush: $(OBJS)
X	@echo loading...
X	@cc $(LDFLAGS) $(OBJS) $(LIBES) -o mush
X
Xtar:
X	@tar fcv MUSH $(HELP_FILES) $(MAKES) $(IMAGES) $(HDRS) $(SRCS)
X
Xlint:
X	make -f makefile.bsd lint
X
Xclean:
X	rm -f *.o core mush
END_OF_FILE
if test 1569 -ne `wc -c <'makefile.sun'`; then
    echo shar: \"'makefile.sun'\" unpacked with wrong size!
fi
# end of 'makefile.sun'
fi
if test -f 'makefile.sys.v' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.sys.v'\"
else
echo shar: Extracting \"'makefile.sys.v'\" \(1342 characters\)
sed "s/^X//" >'makefile.sys.v' <<'END_OF_FILE'
X# Mush makefile for system V.  Note: SIGRET should return void for normal
X# sys-v, but Att PC users should *not* have it defined.  See the README!!
X#
XHDRS1= mush.h config.h
XHDRS2= strings.h options.h
XHDRS3= bindings.h
XSRCS1= commands.c dates.c execute.c expr.c folders.c \
X	hdrs.c init.c loop.c mail.c main.c misc.c msgs.c pick.c \
X	print.c setopts.c signals.c sort.c viewopts.c options.c lock.c
XSRCS2= bind.c curs_io.c curses.c help.c file.c strings.c macros.c addrs.c
X
XOBJS1= commands.o dates.o execute.o expr.o folders.o \
X	hdrs.o init.o loop.o mail.o main.o misc.o msgs.o pick.o \
X	print.o setopts.o signals.o sort.o viewopts.o options.o lock.o
XOBJS2= bind.o curs_io.o curses.o help.o file.o strings.o macros.o addrs.o
X
XHELP_FILES= README README-6.0 README-6.1 README-6.2 README-6.3 README-6.4 \
X	mush.1 Mailrc Gnurc cmd_help sample.mushrc advanced.mushrc
XMAKES= makefile.sys.v makefile.xenix makefile.bsd
X
X# Sun OS systems who wish to compile with sys-v options:
X# CC= /usr/5bin/cc
X# CFLAGS= 	-O -DSYSV -DCURSES -DUSG
X# LIBS= -L/usr/5lib -lcurses
XCFLAGS= 	-O -DSYSV -DCURSES -DREGCMP -DUSG -DSIGRET=void
XLDFLAGS= 	-s
XLIBS= 		-lcurses -lPW
XPROG=		mush
X
X$(PROG): $(OBJS1) $(OBJS2)
X	@echo loading...
X	@$(CC) $(LDFLAGS) $(OBJS1) $(OBJS2) -o $(PROG) $(LIBS)
X
X$(OBJS1): $(HDRS1) $(HDRS2)
X$(OBJS2): $(HDRS1) $(HDRS2) $(HDRS3)
Xhelp.o: strings.h
END_OF_FILE
if test 1342 -ne `wc -c <'makefile.sys.v'`; then
    echo shar: \"'makefile.sys.v'\" unpacked with wrong size!
fi
# end of 'makefile.sys.v'
fi
if test -f 'makefile.xenix' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.xenix'\"
else
echo shar: Extracting \"'makefile.xenix'\" \(2123 characters\)
sed "s/^X//" >'makefile.xenix' <<'END_OF_FILE'
X#
X# makefile for Xenix machines.  See "MODEL" below for your xenix type.
X# some .c files may require the -LARGE compiler flag.  Examples below.
X# This makefile assumes an 80386 machine.  If you have an 80286, see
X# notes below.  This makefile was built for SCO/microsoft xenix --if you
X# are running some other kind of xenix, you might need to change the
X# CFLAGS and LDFLAGS options.
X#
XHDRS= mush.h config.h-dist strings.h bindings.h options.h
XSRCS1= main.c init.c misc.c execute.c
XSRCS2= signals.c msgs.c pick.c viewopts.c
XSRCS3= sort.c expr.c folders.c dates.c help.c
XSRCS4= loop.c bind.c options.c
XSRCS5= commands.c setopts.c hdrs.c
XSRCS6= mail.c print.c
XSRCS7= curses.c curs_io.c
XSRCS8= file.c strings.c
XSRCS9= lock.c macros.c addrs.c
XOBJS= main.o init.o misc.o mail.o hdrs.o execute.o commands.o print.o file.o \
X      signals.o setopts.o msgs.o pick.o sort.o expr.o strings.o \
X      folders.o dates.o loop.o help.o viewopts.o bind.o curses.o curs_io.o \
X      lock.o macros.o options.o addrs.o
XHELP_FILES= README README-6.0 README-6.1 README-6.2 README-6.3 README-6.4 \
X	mush.1 Mailrc Gnurc cmd_help sample.mushrc advanced.mushrc
XMAKES= makefile.sys.v makefile.xenix makefile.bsd
X
X# Memory model.  Use -M3e for 80386 machines.
X# Use -Mle for 80286 machines.
XMODEL= -M3e
X
X#
X# 80286 xenix may use this LDFLAGS define:
X#LDFLAGS= -X -lx -Mle -F 4000
XLDFLAGS= -X -lx -M3
X
XCFLAGS= $(MODEL) -O -DSYSV -DCURSES -DREGCMP -DUSG 
XLIBES= -lcurses -ltermlib
X
Xmush: $(OBJS)
X	@echo loading...
X	@cc $(LDFLAGS) $(OBJS) $(LIBES) -o mush
X
X# For 80286 machines, use these two lines...
X# misc.o:	misc.c
X# 	cc $(CFLAGS) -LARGE -c misc.c
X
Xbind.o:	bind.c
X	cc $(CFLAGS) -LARGE -c bind.c
X
Xshar:
X	shar ${HELP_FILES} ${MAKES} ${HDRS}>hdr.shr
X	shar ${SRCS1} > src1.shr
X	shar ${SRCS2} > src2.shr
X	shar ${SRCS3} > src3.shr
X	shar ${SRCS4} > src4.shr
X	shar ${SRCS5} > src5.shr
X	shar ${SRCS6} > src6.shr
X	shar ${SRCS7} > src7.shr
X	shar ${SRCS8} > src8.shr
X	shar ${SRCS9} > src9.shr
X
Xtar:
X	tar fcv MUSH ${MAKES} ${HDRS} ${HELP_FILES} ${SRCS1} \
X	${SRCS2} ${SRCS3} ${SRCS4} ${SRCS5} ${SRCS6} ${SRCS7} \
X	${SRCS8} ${SRCS9}
X
Xclean:
X	rm -f *.o core mush
END_OF_FILE
if test 2123 -ne `wc -c <'makefile.xenix'`; then
    echo shar: \"'makefile.xenix'\" unpacked with wrong size!
fi
# end of 'makefile.xenix'
fi
if test -f 'strings.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'strings.h'\"
else
echo shar: Extracting \"'strings.h'\" \(1421 characters\)
sed "s/^X//" >'strings.h' <<'END_OF_FILE'
X/* @(#)strings.h	(c) copyright 9/3/86 (Dan Heller) */
X
X/*
X * If you *know* your sprintf() returns char*, you can remove the follow
X * define.  Careful, "new" 4.3BSD's sprintf returns int.  See README
X */
X#define sprintf Sprintf
X#ifdef SYSV
X#define	index	strchr
X#define	rindex	strrchr
X#endif /* SYSV */
X
X/* External function definitions for routines described in string(3).  */
Xextern char
X    *strcat(), *strncat(), *strcpy(), *strncpy(),
X    *index(), *rindex(), *getenv();
Xextern int
X    strcmp(), strncmp(), strlen();
X
Xextern char
X    *Sprintf(),		/* See comments above function in strings.c */
X    *argv_to_string(),	/* convert a vector of strings into one string */
X    *any(), 		/* return first char in str2 that exists in str1 */
X    *ctrl_strcpy(),	/* string copy converting control chars to ascii */
X    *itoa(),		/* return a string representation of a number */
X    *lcase_strcpy(),	/* just like strcpy, but convert all chars to lower */
X    *m_xlate(),		/* translate string from ascii to ctrl-char format */
X    *my_atoi(), 	/* do an atoi, but return the last char parsed */
X    *no_newln(),	/* remove newline and extra whitespace - return end */
X    *savestr();		/* strcpy arg into malloc-ed memory; return address */
X
Xextern void
X    free_vec(),		/* free a malloc'ed argv */
X    print_argv(),	/* prints an argv as one string */
X    putstring(),	/* put a string */
X    xfree();		/* free malloc'ed pointers */
END_OF_FILE
if test 1421 -ne `wc -c <'strings.h'`; then
    echo shar: \"'strings.h'\" unpacked with wrong size!
fi
# end of 'strings.h'
fi
echo shar: End of archive 2 \(of 19\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 19 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
