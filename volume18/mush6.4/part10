Subject:  v18i032:  Mail user's shell version 6.4, Part10/19
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Dan Heller <island!argv@sun.com>
Posting-number: Volume 18, Issue 32
Archive-name: mush6.4/part10



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 10 (of 19)."
# Contents:  mush.h tool_help
# Wrapped by rsalz@papaya.bbn.com on Mon Mar 13 19:25:16 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'mush.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mush.h'\"
else
echo shar: Extracting \"'mush.h'\" \(23119 characters\)
sed "s/^X//" >'mush.h' <<'END_OF_FILE'
X/* @(#)mush.h	(c) copyright 1986 (Dan Heller) */
X
X#define VERSION "Mail User's Shell (6.4 2/14/89)"
X
X#include "config.h"
X
X#ifdef CURSES
X
X#ifdef USG
X#    define _USG
X#    undef USG
X#endif /* USG */
X#ifdef SYSV
X#    define _SYSV
X#    undef SYSV
X#endif /* SYSV */
X#include <curses.h>
X#if !defined(USG) && defined(_USG)
X#    define USG
X#endif /* USG */
X#if !defined(SYSV) && defined(_SYSV)
X#    define SYSV
X#endif /* SYSV */
X
X#else /* CURSES */
X#include <stdio.h>
X#if defined(SYSV) && defined(USG)
X#include <termio.h>
X#endif /* SYSV && USG */
X#endif /* CURSES */
X
X#include <ctype.h>
X#include <errno.h>
X#include <setjmp.h>
X#include "strings.h"
X
X#ifdef SUNTOOL
X#    include <suntool/tool_hs.h>
X#else  /* SUNTOOL */
X#    include <sys/types.h>
X#    include <signal.h>
X#    ifndef SYSV
X#        include <sys/time.h>
X#	 include <sys/ioctl.h>   /* for ltchars */
X#    else
X#        include <time.h>
X#        include <fcntl.h>
X#    endif /* SYSV */
X#endif /* SUNTOOL */
X
X#include <sys/stat.h>
X#include <sys/file.h>
X
X#ifdef SUNTOOL
X#    include <suntool/gfxsw.h>
X#    include <suntool/panel.h>
X#    include <suntool/ttysw.h>
X#    include <suntool/ttytlsw.h>
X#    include <suntool/menu.h>
X#    include <suntool/icon_load.h>
X#endif /* SUNTOOL */
X
X/* if no maximum number of files can be found, we'll use getdtablesize() */
X#ifdef _NFILE
X#    define MAXFILES _NFILE
X#else
X#ifdef NOFILE
X#    define MAXFILES NOFILE
X#endif /* NOFILE */
X#endif /* _NFILE */
X
X#ifndef MAXPATHLEN
X#define MAXPATHLEN BUFSIZ
X#endif /* MAXPATHLEN */
X
X#ifdef CTRL
X#undef CTRL
X#endif /* CTRL */
X#define CTRL(c)		('c' & 037)
X
X#define ESC 		'\033'
X
X#define NO_STRING	""
X#ifdef  NULL
X#undef  NULL
X#endif /* NULL */
X#define NULL		(char *)0
X#define NULL_FILE	(FILE *)0
X#define DUBL_NULL	(char **)0
X#define TRPL_NULL	(char ***)0
X#ifdef putchar
X#undef putchar
X#endif /* putchar */
X#define putchar(c)	fputc(c, stdout), fflush(stdout)
X#define bell() 		fputc('\007', stderr), fflush(stderr)
X
X/* For error recovery purposes, send keyboard generated signals to a special
X * routine (interrupt) to set a global flag (WAS_INTR) and return to the
X * calling routine which is responsible for checking the flag.  For both
X * on_intr() and off_intr() macros, initialize WAS_INTR to false.
X */
X#define on_intr() \
X    turnoff(glob_flags, WAS_INTR), oldint = signal(SIGINT, intrpt), \
X    oldquit = signal(SIGQUIT, intrpt)
X
X#define off_intr() \
X    turnoff(glob_flags, WAS_INTR), (void) signal(SIGINT, oldint), \
X    (void) signal(SIGQUIT, oldquit)
X
X/* Don't flush input when setting echo or cbreak modes (allow typeahead) */
X#ifdef TIOCSETN
X#ifdef stty
X#undef stty
X#endif /* stty */
X#define stty(fd, sgttybuf)	(ioctl(fd, TIOCSETN, sgttybuf))
X#endif /* TIOCSETN */
X
X/* for system-V machines that run termio */
X#if defined(SYSV) && defined(USG)
Xunsigned char vmin, vtime;
X#define sg_erase  c_cc[2]
X#define sg_flags  c_lflag
X#define sg_kill   c_cc[3]
X#define sg_ospeed c_cflag
X#define gtty(fd, SGTTYbuf)	ioctl(fd, TCGETA, SGTTYbuf)
X#undef stty
X#define stty(fd, SGTTYbuf)	ioctl(fd, TCSETAW, SGTTYbuf)
X#define echon()    (_tty.sg_flags |= (ECHO|ECHOE),    stty(0, &_tty))
X#define echoff()   (_tty.sg_flags &= ~ECHO,   stty(0, &_tty))
X#define cbrkon()   \
X	(_tty.sg_flags &= ~ICANON, _tty.c_cc[VMIN] = 1, stty(0, &_tty))
X#define cbrkoff()  \
X	(_tty.sg_flags |= ICANON, _tty.c_cc[VMIN] = vmin, \
X	_tty.c_cc[VTIME] = vtime, stty(0, &_tty))
X#define savetty()  \
X	(void) gtty(0, &_tty), vtime = _tty.c_cc[VTIME], vmin = _tty.c_cc[VMIN]
X#define cbreak()   cbrkon()
X#define nocbreak() cbrkoff()
X
X/* If curses isn't defined, declare our 'tty' and macros for echo/cbreak */
X#ifndef CURSES
Xtypedef struct termio SGTTY;
X#define echom()    echon()
X#define noechom()  echoff()
X#define crmode()   cbrkon()
X#define nocrmode() cbrkoff()
X
X#else /* CURSES */
X/* If curses is defined, use the echo/cbreak commands in library only
X * if curses is running.  If curses isn't running, use macros above.
X */
X#define echom()    ((iscurses) ? echo(): echon())
X#define noechom()  ((iscurses) ? noecho(): echoff())
X#define crmode()   ((iscurses) ? cbreak() : cbrkon())
X#define nocrmode() ((iscurses) ? nocbreak() : cbrkoff())
X#endif /* CURSES */
X#endif /* SYSV && USG */
X
X#if !defined(USG)
X#ifndef CURSES
X/* if curses is not defined, simulate the same tty based macros */
Xtypedef struct sgttyb SGTTY;
X/* Do real ioctl calls to set the tty modes */
X#define crmode()   (_tty.sg_flags |= CBREAK,  stty(0, &_tty))
X#define nocrmode() (_tty.sg_flags &= ~CBREAK, stty(0, &_tty))
X#define echom()    (_tty.sg_flags |= ECHO,    stty(0, &_tty))
X#define noechom()  (_tty.sg_flags &= ~ECHO,   stty(0, &_tty))
X#define savetty()  (void) gtty(0, &_tty)
X#else /* CURSES */
X#define echom()    echo()
X#define noechom()  noecho()
X#endif /* ~CURSES */
X#endif /* ~USG */
X
X/* With all that out of the way, we can now declare our tty type */
XSGTTY _tty;
X
Xextern char
X    del_line,		/* tty delete line character */
X    del_word,		/* tty delete word character */
X    del_char,		/* backspace */
X    reprint_line,	/* usually ^R */
X    eofc,		/* usually ^D */
X    lit_next;		/* usually ^V */
X
X/* These macros now turn on/off echo/cbreak independent of the UNIX running */
X#define echo_on()	\
X    if (_tty.sg_flags && isoff(glob_flags, ECHO_FLAG)) nocrmode(), echom()
X#define echo_off()	\
X    if (_tty.sg_flags && isoff(glob_flags, ECHO_FLAG)) crmode(), noechom()
X
X#define strdup(dst, src) (xfree (dst), dst = savestr(src))
X#define Debug		if (debug) printf
X
X#ifdef SYSV
X#ifndef L_SET
X#define L_SET	0
X#endif /* L_SET */
X#ifndef F_OK
X#define F_OK	000
X#define R_OK	004
X#define W_OK	002
X#define E_OK	001
X#endif /* F_OK */
Xtypedef	unsigned long	u_long;
X#define vfork   fork
X#ifndef SIGCHLD
X#define SIGCHLD SIGCLD
X#endif /* SIGCHLD */
X#endif /* SYSV */
X
X#if !defined(SUNTOOL) && !defined(CURSES)
X
X#define TRUE		  1
X#define FALSE		  0
X#define print		  printf
X#define wprint		  printf
X#define print_more	  printf
X
X#endif /* SUNTOOL && !CURSES */
X
X#ifndef max
X#define max(a,b) (((a) > (b)) ? (a) : (b))
X#define min(a,b) (((a) < (b)) ? (a) : (b))
X#endif /* max */
X
X#if defined(CURSES) && !defined(SUNTOOL)
X#define wprint printf
X#endif /* !SUNTOOL && CURSES */
X
X#if defined(CURSES) || defined(SUNTOOL)
X#define print_more	  turnon(glob_flags, CONT_PRNT), print
Xvoid print();		/* printf to window or curses or tty accordingly */
X#endif /* CURSES || SUNTOOL */
X
X#ifdef  SUNTOOL
X
X#define NO_ITEM		  (Panel_item)0
X#define NO_EVENT	  (struct inputevent *)0
X#define TIME_OUT	  60           /* sleep 60 secs between mailchecks */
X#define PIX_XOR		  PIX_SRC ^ PIX_DST
X#define ID 		  event.ie_code
X#define l_width(font)	  fonts[font]->pf_defaultsize.x /* width of letter */
X#define l_height(font)	  fonts[font]->pf_defaultsize.y /* height of letter */
X#define Clrtoeol(w,x,y,f) pw_text(w, x, y, PIX_SRC, fonts[f], blank)
X#define type_cursor(op)   pw_char(msg_win, txt.x,txt.y, op, fonts[curfont],'_')
X
X#define highlight(win,x,y,font,s) \
X    pw_text(win,x,y, PIX_SRC, fonts[font],s), \
X    pw_text(win,x+1,y, \
X	(ison(glob_flags, REV_VIDEO))? PIX_NOT(PIX_SRC): PIX_SRC|PIX_DST, \
X	fonts[font],s)
X
X/* Fonts */
X#define FONTDIR		  "/usr/lib/fonts/fixedwidthfonts"
X#define DEFAULT		  0
X#define SMALL	 	  1
X#define LARGE 		  2
X#define MAX_FONTS	  3
X
X#endif /* SUNTOOL */
X
X/* bits and pieces */
X#define turnon(flg,val)   ((flg) |= ((u_long)1 << ((u_long)(val)-1L)))
X#define turnoff(flg,val)  ((flg) &= ~((u_long)1 << ((u_long)(val)-1L)))
X#define ison(flg,val)     ((u_long)(flg) & ((u_long)1 << ((u_long)(val)-1L)))
X#define isoff(flg,val)    (!ison((flg), (val)))
X#define set_replied(n)	  \
X	if (isoff(msg[n].m_flags, REPLIED)) \
X	    turnon(glob_flags, DO_UPDATE), turnon(msg[n].m_flags, REPLIED)
X#define set_isread(n)	  \
X	if (ison(msg[n].m_flags, UNREAD)) \
X	    turnon(glob_flags, DO_UPDATE), turnoff(msg[n].m_flags, UNREAD)
X
X#define in_pipe() (ison(glob_flags, DO_PIPE) || ison(glob_flags, IS_PIPE))
X#define in_macro() (ison(glob_flags, LINE_MACRO) || ison(glob_flags, IN_MACRO))
X#define line_macro(s) (turnon(glob_flags, LINE_MACRO), mac_push(s))
X#define curs_macro(s) (turnon(glob_flags, IN_MACRO), mac_push(s))
X#define Ungetstr(s) (turnon(glob_flags, QUOTE_MACRO), mac_push(s))
X
X/* msg lists represented by bits (8 should be replaced by sizeof(char) */
X#define clear_msg_list(list)  	(void) (bzero(list, (msg_cnt+7)/8))
X#define msg_bit(list, n)	((list[(n) / 8] >> ((n) % 8)) & 1)
X#define set_msg_bit(list, n)	(list[(n) / 8] |= (1 << ((n) % 8)))
X#define unset_msg_bit(list, n)  (list[(n) / 8] &= ~(1 << ((n) % 8)))
X#define bput(S1, S2, Len, op)   				\
X		{ 						\
X		    register char *s1 = S1, *s2 = S2; 		\
X		    register int len = Len; 			\
X		    while(len--) 				\
X			*s2++ op *s1++; 			\
X		}
X#define bitput(m1,m2,len,op)	bput(m1, m2, (((len)+7)/8), op)
X
X/* convenience and/or readability */
X#define when		  break;case
X#define otherwise	  break;default
X#define lower(c)	  (isupper(c)? tolower(c): c)
X#define Lower(c)	  (c = lower(c))
X#define upper(c)	  (islower(c)? toupper(c): c)
X#define Upper(c)	  (c = upper(c))
X#define skipspaces(n)     for(p += (n); *p == ' ' || *p == '\t'; ++p)
X#define skipdigits(n)     for(p += (n); isdigit(*p); ++p)
X#define ismsgnum(c)       (isdigit(c)||c=='.'||c=='^'||c=='$'||c=='*')
X#define skipmsglist(n)\
X    for(p += (n); ismsgnum(*p) || index(" \t,-{`}", *p); ++p)\
X	if (*p != '`' || !p[1]) {;} else do ++p; while (*p && *p != '`')
X
X#define NO_FLG		0
X
X/* various flags */
Xu_long   glob_flags;	/* global boolean flags thruout the whole program */
X#define DO_UPDATE   1	/* check for changes to avoid unnecessary copyback */
X#define REV_VIDEO   2	/* reverse video for curses or toolmode */
X#define CONT_PRNT   3	/* continue to print (maybe a printf) without a '\n' */
X#define DO_SHELL    4	/* run a shell even if no mail? (true if tool) */
X#define DO_PIPE     5	/* true if commands are piping to another command */
X#define IS_PIPE     6	/* true if commands' "input" is piped from another */
X#define IGN_SIGS    7	/* true if catch() should not longjmp */
X#define IGN_BANG    8	/* ignore ! as a history reference (see source()) */
X#define ECHO_FLAG   9	/* if true, echo|cbreak is ON, echo typing (-e) */
X#define IS_GETTING 10	/* true if we're getting input for a letter */
X#define PRE_CURSES 11	/* true if curses will be run, but hasn't started yet */
X#define READ_ONLY  12	/* -r passed to folder() (or main) setting read only */
X#define REDIRECT   13	/* true if stdin is being redirected */
X#define WAS_INTR   14	/* catch interrupts, set this flag (signals.c) */
X#define WARNING    15   /* if set, various warning messages may be printed */
X#define NEW_MAIL   17   /* new mail has arrived; user is busy or in icon mode */
X#define CNTD_CMD   18   /* curses.c -- "...continue..." prompt in curses */
X#define IS_SENDING 19   /* was started to send mail, not to be run as a shell */
X#define MIL_TIME   20	/* if $mil_time is set, use 24hr military time fmt */
X#define DATE_RECV  21   /* if $date_received, show date received on msgs */
X#define IN_MACRO   22	/* input is currently being read from a macro */
X#define LINE_MACRO 23	/* escape to line mode from curses mode in progress */
X#define QUOTE_MACRO 24  /* protect current macro from recursive expansion */
X
X#define VERBOSE		1       /* verbose flag for sendmail */
X#define INCLUDE		2       /* include msg in response */
X#define INCLUDE_H	3	/* include msg with header */
X#define EDIT		4	/* enter editor by default on mailing */
X#define SIGN		5	/* auto-include ~/.signature in mail */
X#define DO_FORTUNE	6	/* add a fortune at end of msgs */
X
X/* msg flags */
X#define NO_HEADER	7	/* don't print header of message (top, write) */
X#define DELETE		8
X#define OLD	        9
X#define UNREAD		10
X#define UPDATE_STATUS	11	/* change status of msg when copyback */
X#define NO_PAGE		12	/* don't page this message */
X#define INDENT		13	/* indent included msg with string */
X#define NO_IGNORE	14	/* don't ignore headers */
X#define PRESERVE	15      /* preserve in mailbox unless deleted */
X#define M_TOP		15	/* just print the top of msg (same as pre) */
X#define FORWARD		16	/* Forward messages into the message buffer */
X#define REPLIED		17	/* Messages that have been replied to */
X#define NEW_SUBJECT	18	/* new subject regardless of $ask (mail -s) */
X#define SAVED		19	/* when message has been saved */
X#ifdef MSG_SEPARATOR
X#define NO_SEPARATOR	20	/* don't include message separator lines */
X#endif /* MSG_SEPARATOR */
X
X#define	MAXMSGS_BITS	MAXMSGS/sizeof(char)	/* number of bits for bitmap */
X
Xstruct msg {
X    u_long m_flags;
X    long   m_offset;	/* offset in tempfile of msg */
X    long   m_size;	/* number of bytes in msg */
X    int    m_lines;	/* number of lines in msg */
X    char   *m_date_recv;/* Date user received msg (see dates.c for fmt) */
X    char   *m_date_sent;/* Date author sent msg (see dates.c for fmt) */
X} msg[MAXMSGS];
X
Xstruct options {
X    char *option;
X    char *value;
X    struct options *next;
X} *set_options, *aliases, *ignore_hdr, *functions, *fkeys, *own_hdrs;
X#ifdef CURSES
Xstruct options *bindings;
X#endif /* CURSES */
X
Xstruct cmd {
X    char *command;
X    int (*func)();
X};
Xextern struct cmd ucb_cmds[];
Xextern struct cmd cmds[], hidden_cmds[];
X#ifdef SUNTOOL
Xextern struct cmd fkey_cmds[];
X#endif /* SUNTOOL */
X
XFILE
X    *tmpf,		/* temporary holding place for all mail */
X    *mask_fopen(),	/* open a file with umask 077 (permissions 600) */
X    *open_file(),	/* open a file or program for write/append */
X    *popen();		/* this should be in stdio.h */
X
Xextern char
X    *sys_errlist[],    /* system's list of global error messages */
X#ifdef SUNTOOL
X    *font_files[], 	/* the names of the files fonts are kept in */
X    *alt_fonts[], 	/* fonts to use if first ones don't work */
X#endif /* SUNTOOL */
X    **environ;		/* user's environment variables */
X
Xextern int errno;	/* global system error number */
Xjmp_buf jmpbuf;		/* longjmp to jmpbuf on sigs (not in tool) */
X
Xchar
X    debug,		/* debug causes various print statements in code */
X    tempfile[MAXPATHLEN],	/* path to filename of temporary file */
X    msg_list[MAXMSGS_BITS],	/* MAXMSGS bits of boolean storage */
X    **alternates,	/* alternates list --see alts() */
X    *cmd_help,		/* filename of location for "command -?" commands. */
X    *login,		/* login name of user */
X    *mailfile,		/* path to filename of current mailfile */
X    **ourname,		/* the name and aliases of the current host */
X    **known_hosts,	/* the names of all hosts connected via uucp */
X    *prompt,		/* the prompt string -- may have %d */
X    *escape,		/* the "tilde escape" when inputting text to letter */
X    *hdrs_only,		/* true if -H flag was given --set to args */
X    *hdr_format,	/* set to the header format string; referenced a lot */
X    *spoolfile,		/* MAILDIR/$USER in a string -- this is used a lot */
X    *msg_get(),		/* find start of message and return From_ line */
X    *do_range(),	/* parse a string converting to a "range" of numbers */
X    *getpath(),		/* static char returning path (expanding ~, +, %, #) */
X    *do_set(),		/* set/unset an option, alias, ignored-hdr */
X    *reverse(),		/* reverse a string */
X    *prog_name,
X
X    /* from loop.c */
X    **make_command(),	/* build a command vector (argv) */
X    **mk_argv(),	/* given a string, make a vector */
X    *variable_stuff(),	/* return information about variables */
X    *check_internal(),	/* test or evaluate internal variables */
X
X    /* from dates.c */
X    *Time(),		/* returns string expression of time (takes args) */
X    *date_to_ctime(),	/* convert a date into ctime() format */
X    *date_to_string(),	/* returns a string described by parse_date() */
X    *msg_date(),	/* return a string of the date of a message */
X    *parse_date(),	/* parse an ascii date, and return message-id str */
X    *rfc_date(),	/* create a date string compliant to RFC822 */
X
X    /* from hdrs.c */
X    *cc_to(),     	/* when responding, return str which is the cc-list */
X    *compose_hdr(),	/* returns a formatted line describing passed msg # */
X    *header_field(),    /* the line in msg described by arg (message header) */
X    *reply_to(),	/* who do we reply to when responding */
X    *subject_to(),      /* when responding, return str which is the subject */
X
X    /* addrs.c */
X    *alias_to_address(),/* convert a name[list] to "real" names */
X    *bang_form(),	/* construct a !-style form of an address */
X    *get_name_n_addr(), /* get name and addr from a well-formed address */
X    *set_header(), 	/* [interactive] proc to set/display to/subject/cc */
X    *wrap_addrs();	/* insert newlines in between headers */
X
Xint
X    last_msg_cnt,	/* when checking for new mail, save the last msg_cnt */
X    msg_cnt,		/* total number of messages */
X    crt,		/* min number of lines msg contains to invoke pager */
X    current_msg,	/* the current message we're dealing with */
X    exec_pid,		/* pid of a command that has been "exec"ed */
X    hist_no,		/* command's history number */
X    iscurses,		/* if we're running curses */
X    istool,		/* argv[0] == "xxxxtool", ranges from 0 to 2 */
X    n_array[128],	/* array of message numbers in the header window */
X    screen,		/* number of headers window can handle */
X    wrapcolumn,		/* compose mode line wrap, measured from left */
X
X    quit(), do_alias(), respond(), cd(), sh(), stop(),
X    folder(), folders(), merge_folders(), do_undigest(),
X    save_msg(), delete(), do_mail(), lpr(), alts(), set(), do_hdrs(),
X    save_opts(), preserve(), sort(), readmsg(), edit_msg(), eval_cmd(),
X    do_pick(), print_help(), question_mark(), do_from(), my_stty(),
X    do_version(), disp_hist(), source(), do_echo(), ls(), pipe_msg(),
X    nopenfiles(), Setenv(), Unsetenv(), Printenv(), msg_flags(), toggle_debug();
X
X#ifndef SIGRET
X#define SIGRET int
X#endif /* SIGRET */
XSIGRET
X#ifdef SUNTOOL
X    sigtermcatcher(), sigwinchcatcher(),
X#endif /* SUNTOOL */
X    rm_edfile(), stop_start(), bus_n_seg(), sigchldcatcher(), catch(), intrpt();
X
Xlong
X    still_more,		/* there is still more message to display */
X    spool_size,		/* size of spool mail regardless of current folder */
X    last_size,		/* the last size of the mailfile since last check */
X    time();		/* satisfy lint */
X
Xvoid
X    error(), getmail(), mail_status(), close_lock(),
X    file_to_fp(), init(), display_msg(), cleanup(), fs_error();
X    /* printf(), fclose(), fflush(), fputs(), fputc() */
X#ifdef TIOCGLTC
Xstruct ltchars ltchars;			/* tty character settings */
X#endif /* TIOCGLTC */
X#ifdef BSD /* (TIOCGETC) */
Xstruct tchars  tchars;			/* more tty character settings */
X#endif /* BSD (TIOCGETC) */
X
X#ifdef CURSES
X
X#define STANDOUT(y,x,s) standout(), mvaddstr(y,x,s), standend()
X#define redraw()	clearok(curscr, TRUE), wrefresh(curscr)
X
Xint
X    curses_init();	/* interpret commands via the curses interface */
X#endif /* CURSES */
X
Xint
X    mac_push(),		/* set up a string as a macro */
X    bind_it();		/* bind strings to functions or macros */
X
Xvoid
X    mac_flush();	/* Abandon macro processing (on error) */
X
X#ifdef SUNTOOL
Xvoid
X    lock_cursors(), unlock_cursors(), scroll_win(),
X    set_fkeys(), set_key(), toggle_opt(), help_opt();
X
Xchar
X    *rite(),		/* rite a char to msg_win: return string if c == '\n' */
X    *find_key(),	/* pass x,y coords to find which function key assoc. */
X    *key_set_to(),	/* pass fkey string, return string describing func */
X    *panel_get(),      	/* returns what has been typed in a panel item */
X    *tool_help,		/* help for tool-related things (sometimes, overlap) */
X    blank[128];		/* use to clear to end of line */
X
Xint
X    time_out,		/* time out interval to wait for new mail */
X    rootfd,		/* the root window's fd */
X    parentfd,		/* the parent's window fd */
X    getting_opts,	/* true if getting/setting opts from msg_win */
X    curfont,		/* the current font to use for mail message window */
X    total_fonts,	/* total number of fonts available */
X    get_hdr_field,	/* bitmask of header fields to be gotten */
X
X    msg_io(), msgwin_handlesigwinch(), hdr_io(), hdrwin_handlesigwinch(),
X    do_compose(), do_edit(), read_mail(), delete_mail(), respond_mail(),
X    do_hdr(), display_hdrs(), print_sigwinch(), p_set_opts(),
X    tool_mgmt(), do_help(), text_done(), msg_num_done(), do_lpr(),
X    toolquit(), change_font(), do_clear(), do_update(), do_sort(),
X    file_dir(), do_file_dir(), do_send(), abort_mail(), check_new_mail(),
X    fkey_cmd(), fkey_settings();
X
Xstruct tool *tool;      /* main tool structure */
Xstruct toolsw
X    *panel_sw,		/* main panel subwindow */
X    *hdr_sw, 		/* subwindow for message headers */
X    *hdr_panel_sw,	/* panel for headers */
X    *tty_sw, 		/* subwindow which forks a shell (usually editor) */
X    *print_sw, 		/* subwindow for print statements */
X    *msg_sw; 		/* main subwindow to display messages and more */
X
Xstruct pixwin
X    *msg_win,		/* main pixwin for message display and more */
X    *hdr_win,		/* pixwin for message headers */
X    *print_win;		/* pixwin for printing messages ( print() ) */
X
Xstruct pr_pos txt;   			/* current position of text written */
Xstruct rect msg_rect, hdr_rect;         /* sizes of the main and hdr rects */
Xstruct pixfont *fonts[MAX_FONTS];	/* array of fonts */
X
XPanel
X    main_panel,		/* the main panel dealing with generic items */
X    hdr_panel;		/* panel which contains message header specific items */
X
XPanel_item
X    abort_item,		/* abort mail in progress */
X    alias_item,		/* set/view/change current mail aliases */
X    cd_item,		/* changes file_item to cd (for cd-ing) */
X    comp_item,		/* compose a letter */
X    delete_item,	/* delete/undelete messages */
X    edit_item,		/* edit a message */
X    font_item,		/* choose which font to use */
X    folder_item,	/* change folders */
X    file_item, 		/* text item for files or directories (folder/cd) */
X    hdr_display,	/* format message headers are displayed */
X    help_item,		/* choose this to get various help */
X    ignore_item,	/* set/view/change message headers to be ignored */
X    input_item,		/* text item to get values for set/unsetting values */
X    msg_num_item,	/* text item to explicitly state which message to read */
X    next_scr,		/* display the next screenful of message headers */
X    option_item,	/* set/view/unset mail options */
X    prev_scr,		/* display the previous screen of messages */
X    print_item,		/* send current message to the printer */
X    quit_item,		/* quit tool/close to icon */
X    read_item,		/* read the current message */
X    respond_item,	/* respond to messages */
X    save_item,		/* saves messages; uses text item input_item */
X    send_item,		/* when composing letter, this will send it off */
X    sort_item,		/* sort routine... */
X    sub_hdr_item[6],	/* display items that just sit there and give help */
X    update_item;	/* commit changes to folder */
X
Xstruct itimerval mail_timer;	/* frequency to check for new mail */
X
X			/* mouse symbols and data */
X/* left, middle and right mouse pixrects */
Xstruct cursor
X    l_cursor, m_cursor, r_cursor, coffee, read_cursor, write_cursor,
X    main_cursor, checkmark;
X
Xstruct pixrect *msg_pix; /* pixrect holding text of a message */
Xextern struct pixrect mouse_left, mouse_middle, mouse_right;
Xextern struct pixrect dn_arrow, up_arrow, cycle, shade_50;
X
Xextern struct icon mail_icon;
X#endif /* SUNTOOL */
END_OF_FILE
if test 23119 -ne `wc -c <'mush.h'`; then
    echo shar: \"'mush.h'\" unpacked with wrong size!
fi
# end of 'mush.h'
fi
if test -f 'tool_help' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tool_help'\"
else
echo shar: Extracting \"'tool_help'\" \(23733 characters\)
sed "s/^X//" >'tool_help' <<'END_OF_FILE'
X@(#)tool_help	(c) copyright 10/18/86 (Dan Heller)
X
X%general%
X
X      IF ALL ELSE FAILS, READ THE DIRECTIONS!
X
XThis famous  quote applies here more  than ever. If
Xyou are unfamiliar with this mailtool, get yourself
Xacquainted with it by choosing  HELP options in all
Xmenu items. If you get frustrated or confused about
Xhow to use or run a command, or if you want to know
Xhow something  works or get to know quick shortcuts
Xin achieving tasks, it is  advisable to look at the
XHelp option available with the item.
X
XSince there  are many different  options to some of
Xthe commands in  mailtool, explanation  of  options
Xfor the commands can be found by choosing the RIGHT
Xmouse button over an item. This will display a menu
Xof options for the command. One of the menu options
Xwill almost always be a Help option.
X
XGive yourself a head start, try selecting this same
Xitem with the RIGHT mouse button.  When you do, you
Xwill given some more help topics to choose from.
X%%
X
X%help%
XHelp was designed for users to get  help from anywhere on  the mailtool
Xwindow.  The RIGHT mouse button may be selected on virtually every -
X on any of the windows on the entire tool and  a menu will appear.
XThe last item in almost  every menu  is a "help" item.  You will get an
Xappropriate help message describing what you can do at the position you
Xare in on the mailtool window.
X
XIf a help  message isn't much help, it may be more helpful to reference
Xa different help item which  describes in more detail  what you want to
Xknow.  For example, reading the help for  "folder" will help you better
Xunderstand  the method in  which mail messages are stored than it would
Xif you had read the help message for "save" first.
X%%
X
X%mouse%
XThe mouse is an image (cursor) which moves across the screen. Its
Xposition indicates which window is to receive input when you type
Xor click a mouse button.
X
XThe mouse may take upon  different images which  indicate various
Xthings. When the image looks like a "coffee cup",  Mushtool is in
Xthe process of doing something,  like sending mail, or reading in
Xnew mail.  In this event, you should wait till the cursor returns
Xto its normal state before attempting to do anything else. Go get
Xsome coffee.
X
XWhen the mouse looks like a pair of glasses, you are reading mail
Xand when it looks like a pencil, you  are editing a letter.  When
Xin the  Header Window, the cursor will look like the mouse device
Xthat you hold  with the buttons  flashing on and off.  This is to
Xremind  you that you  can use each button  to do different tasks.
X
XIn one window, the Main Panel Window, the cursor image looks like
Xan envelope.  Placing the cursor over "Panel Items" and selecting
Xthe LEFT button will do that command.  Selecting the RIGHT  mouse
Xbutton will give a menu of options to choose from. In most cases,
XHelp is  available and the end of each menu list to help you with
Xthe proper use of Panel Items.
X
XWhen you are asked a yes or no question, choosing either the LEFT
Xor RIGHT mouse buttons is the same as typing "y" or "n".
X%%
X
X%respond%
XThis item responds to mail in 4 ways.
XIn all cases, at least one recipient of your message will be the
Xsender of the message you are responding to. If a subject was in
Xthe author's letter, then it will be used as your subject.
X
XThe first and most used method of response is to the author of the
Xmessage only.  Selecting this item with the LEFT mouse button will
Xuse this method for responding to mail.
X
XIf you want to include a copy of the author's message, then choose
Xthe menu item which  says to include the message.  If you wish for
Xall the recipients of the message to receive a copy of your reply,
Xthen choosing the third item will include them.
X
XThe fourth menu item will mail to the author and everyone listed on
Xthe To and Cc lines of the message, and include the message you are
Xresponding to in your text.
X
XIn such cases where you include the message you are responding to,
Xthe included message will be indented by "> " to identify it from
Xyour message. If you would like to have a string other than the
Xdefault used, then set the appropriate option to whatever you would
Xprefer by selecting the "Opts" item, moving the mouse on top of the
Xstring, "indent-str", selecting the LEFT mouse button and typing the
Xdesired string.
X%%
X
X%menu_respond%
XWhen you respond to a message using the menu item, you respond to the author
Xof the message only. Since there are  more ways to respond to a message, you
Xmay want to choose the  Main Panel Window's Reply item. This item also gives
Xfar more extensive help than described here.
X%%
X
X%menu_delete%
XThis menu may delete or undelete
Xwhichever  message you happen to
Xhave the cursor sitting on.  For
Xdeleting messages  only, you can
Xsimply  select the  MIDDLE mouse
Xbutton  over the message  header
Xyou would like deleted.
X
XFor extensive information on -
X or undeletion of messages
Xtry the the  Main Panel Window's
Xitem for Delete.
X%%
X
X%delete%
XYou may  delete or undelete  messages with this item.
XWhen using the LEFT mouse button, you will delete the
Xcurrent message (HIGHLIGHTED in the headers' window).
XOtherwise, you may select the menu item for undelete.
X
XYou may  delete or undelete a  "range" of messages by
Xtyping the range in the Header Window.
X
XFor help on valid  message ranges, select the menu in
Xthe area  marked "range" in the  Header Panel Window.
X%%
X
X%folder%
XThis item changes your "folder" -- which is  a place to keep all your
Xindividual messages. Usually, if you are a heavy mail user, you would
Xorganize your mail in such a way in which related mail would be saved
Xtogether in one folder.   You create folders simply by saving mail to
Xa filename.  Additional mail can  be saved to those files in the same
Xway.  To manipulate messages in folders,  you "change folders" to the
Xfolder you wish to access using the folder item.   Since it may occur
Xthat you switch  back and forth  between two folders, you may use the
Xprevious  folder menu item which updates changes  made to the current
Xfolder and  changes your  folder to the one previous to  the current.
X
XYou may also select  the exact name of the  folder you wish to access
Xby selecting  the left  mouse button on the "folder"  item and TYPING
Xthe exact  name of the folder  you wish to access.  The "pathname" to
Xthe folder may start with a tilde (~) indicating your home directory.
XOr, it may  contain a plus sign before the  name indicating your Mail
Xdirectory (+reports, for example).  Alternatively, you  can type  '%'
Xto access your system Mailbox, the place where all your mail is first
Xdelivered.  And finally, you can type '#' to indicate  the previously
Xaccessed folder.  See the help for "chdir" for more information.
X%%
X
X%chdir%
XThis is used to just change working directories.
XYour  working directory contains files and other
Xdirectories.  Files can be "mail folders"  which
Xcontain mail  messages.  You can change to other
Xdirectories using some of the following methods:
X
XYou can select from the menu, HOME or Mail, which
Xare your home and default mail directories. Or,
Xselect the left mouse button and TYPE in the name
Xof the directory you would like to change to.
X
XTyped names may have the following syntax:
X
X~[/subpath]   will change to your home directory and
X              a path below that, if specified. Also,
X              you can specify other users: ~username
X+[subpath]    This is your default Mail directory.
X%%
X
X%save%
XYou may save messages in  two ways. The most commonly used method is to
Xsave messages to  your mailbox folder  ("mbox") in your home directory.
XIf you use mail very frequently and save large amounts of mail, you can
Xsave messages to other folders for better organization.
X
XUsually, when messages are saved, mushtool  marks them for deletion for
Xthe next update.  If you don't want to have saved messages deleted, you
Xmust undelete them or set the variable "keepsave" in the options screen.
X
XThere is a text item  in the Main Panel Window which allows you to type
Xthe  name of the file to save a message.  Select the  LEFT mouse button
Xover the "Save" item, and type the filename and hit return. If there is
Xno filename specified, then messages are saved to your mbox file.
X
XYou can specify a range, or group of messages to save by typing a range
Xin the  Header Panel Window.  If there is a  message list in that panel
Xitem, then the range of messages specified there will be saved. If not,
Xthe current message will be saved.
X
XFor additional information, see the help option for Folders.
X%%
X
X%quit%
XThere are various ways in which you may be finished with mailtool.
XThe most commonly used method  is to simply "close" the tool to an
Xiconic form. This means that you haven't really quit, but you have
Xmerely put it on "hold" till later.  It will become an icon on the
Xside or corner of the screen and appear to sit and do nothing.  To
Xclose the tool to icon form, there are two methods which have will
Xhave two different effects.
X
XThe first method is to select  this panel item with the left mouse
Xbutton.  This  will update your current  folder (deleting messages
Xmarked for deletion) and close the tool.  The second method  is to
Xuse the tool manager around the perimeter of the window and select
X"close".  This will close the tool without updating your mailfile.
X
XWhenever the mailtool is  in the "closed"  state, it  periodically
Xchecks your mail and updates your folder with the  new mail. While
Xmailtool is in iconic form, it will display the number of messages
Xyou have in the current folder.
X
XThere are two equally similar methods of exiting  mailtool, rather
Xthan just closing to an icon:  you may select the second menu item
Xin the menu given by this panel item or you may use the tool mana-
X "quit" item.
X
XUsing the tool manager's quit will exit the tool without updating
Xyour folder whereas the panel item's menu selection will have the
Xmailtool prompt you whether to update the current folder or not.
X%%
X
X%help_menu_help_msg%
XSelecting an item within this menu will
Xgive you help on that item. If you want
Xto execute the action, choose the other
Xmenu by placing the mouse over the menu
XBEHIND this menu, continue to keep your
XRIGHT mouse button depressed and select
Xthe LEFT mouse button  over the menu on
Xthe bottom and select that action.
X%%
X
X%msg_menu%
XWhen given menu in the Header Window, you will have a choice
Xof actions to take.  The message may not be the current one,
Xit may be  any message that  appears in  the Headers Window.
XThe "title" of the menu  will indicate which message you are
Xreferring to.
X
XAt this point, you can select actions to take. You can Read,
XDelete, Undelete, Save, Reply to, or Print messages. Most of
Xthese are self explanatory, but if you need help with one of
Xthese, place the  mouse over the menu BEHIND the given menu,
Xcontinue to have the RIGHT mouse button depressed and select
Xthe LEFT mouse button over the Help Menu.
X
XThis action toggles the menus such  that you can change back
Xand forth between these menus. The menu you are on will tell
Xwhich action to take on that message.  In  either case,  you
Xplace the mouse over the action to take, and,  if you are on
Xthe help menu, help will be given regarding that  particular
Xaction. If not in  the help menu,  then that specific action
Xwill actually be taken.
X%%
X
X%edit%
XChoosing this item with the LEFT mouse button in
Xthe Main Panel Window or in the Menu item will
Xallow you to access a full-screen editor. The
Xeditor which you will use is indicated when you
Xselect the "opts" item in the Main Panel Window.
X
XWhile you are typing a letter, you can specify
Xexplicitly which editor to use by typing (on a
Xline by itself) "~v editor". Type "~?" on a line
Xby itself while typing to see a list of valid
X"~commands".
X
XUpon exiting the editor, you can continue typing
Xand even reenter the editor if you like in the
Xsame manner.
X%%
X
X%update%
XThis item will update the current folder you are using.
XChanges are updated to the folder; that is, deleted mail
Xis removed and all other mail is copied back to the folder
Xunless otherwise specified. See the help in "folder" for
Xmore information on folders.
X
XIf new mail has arrived, it will incorporate it. Otherwise,
Xnew mail is incorporated every two minutes or so, if some
Xcomes in.
X%%
X
X%headers%
XThe message headers are displayed in their own separate window.
XThe "current" message is usually displayed in either BOLD or
XREVERSE text. This "highlighted" message is the one which is
Xdisplayed at the bottom, larger window. In the message window,
Xeach message is displayed in the following format:
Xthe message number is displayed first; if it is the "current"
Xmessage, then there is a '>' sign.
XThe next character is the 'status' character:
X    'N' -- New (and unread)
X    'U' -- not new, but still Unread
X    '*' -- delete messages (set show_deleted)
X    'P' -- preserve in spoolfile.
X    'O' -- Old message which has also been Read.
XIf there is just a space (no character), the message is new, but
Xyou've already read it. You should explicitly save or delete these.
X
XFollowing that is the Author of the message and/or all or part of
Xhis network address and login name.  Following that is the number
Xof lines the message is. In quotes is all or part of the "Subject"
X(if one was specified).
X
XTo read a message, select either the READ item in the main panel
Xsubwindow or move the mouse over the message header you want to read
Xand press the LEFT mouse button. Or, the MIDDLE mouse button will
Xdelete that message. Choosing the RIGHT mouse button will give you
Xa menu of things to do then. Included in the menu, is a help item
Xwhich describes the selections in the menu.
X%%
X
X%preserve%
XUsually, after you read mail and you "update" or quit  mailtool, unread
Xmessages are copied back into your system mailbox, deleted messages are
Xremoved, and messages which have been read but not deleted are saved in
Xyour "mbox" file.  Specifying "hold" prevents this from ever happening,
Xbut you can mark specific messages to be held in your system mailbox by
Xpreserving them.
X%%
X
X%compose%
XWhen you start to compose a letter for mailing,
Xyou will be prompted  for the login name(s), of
Xwhom  you want to mail, the (optional)  subject
Xof the message, and an  optional list of carbon
Xcopy recipients.  This is an additional list of
Xlogin names  who will be  mailed copies of your
Xmessage.
X
XAfter that, anything you type will be added to
Xyour  message.  If you select the  RIGHT mouse
Xbutton in the window in  which you are type to
Xget a menu of  things to do.  You may enter an
Xeditor if your message needs to be modified in
Xmore detail.
X
XWhen you're through with your message, you can
Xsend it by typing (on a line by itself) "." or
X^D.  Or, you can select  the Send item  in the
XMain Panel Window  and your mail will be sent.
XYou cannot send mail while still in an editor;
Xyou must exit the editor first.
X
XIf you have the option "autoedit" set, you are
Xautomatically put into an editor when you want
Xto compose or  whenever you reply to a letter.
XIn this case, whenever  you're through editing
Xthe letter, you will be put back into the main
Xediting mode  where you terminate and send the
Xletter using any of the above methods.
X%%
X
X%next%
XYou can page through all your messages by selecting  "Next" after reading
Xeach message. The same effect is gotten when you select the "Delete" item
Xwhen the option,  "autoprint" is set to be true  (see "opts") except that
Xthe current message is deleted before the next one is displayed. Deleting
Xmail which is  not important  helps the  efficiency of mailtool and reduces
Xunnecessary use of system resources.
X
XIn the Header Window, you will notice the cursor looks like the mouse you
Xuse.  The blinking buttons on the mouse image remind you that you can use
Xany of the  three buttons  at any  time.  When you  move the mouse over a
Xmessage and choose a button, the message under the  mouse is going to be
Xthe one affected.  Choosing left button will read the message, the middle
Xbutton will delete it, and the right button will give you a menu.
X%%
X
X%aliases%
XAliases are used as a method of mailing to users with long addresses using
Xshort names. For example, if you wanted to mail to
X    argv@spam.istc.sri.com
Xbut didn't want to type that all the time, then you could make an alias by
Xselecting the alias menu item that specifies "adding alias" and then TYPE:
X    Dan argv@spam.istc.sri.com
XIf you want to mail to a list of people and do so frequently enough to want
Xan alias name for the whole list, then  you would type something like this:
X    project-group fred mary bob@foo-bar herb sly@baz.bitnet
X
XTo mail to an "alias" you would compose a letter and address the letter:
X
XTo: Dan
XSubject: Alias example
XCc: project-group
X(rest of letter)
X%%
X
X%alts%
X"Alternates" are alternate names for YOU.  In messages you
Xreceive, your account will appear on the "To" or "Cc" list.
XWhen you REPLY to those messages, mailtool will construct
Xa message header for your letter which will contain the To
Xand Cc lists of recipients from the original message. You
Xwould probably want your name taken off the list so you do
Xnot mail yourself a copy of your own message. If you have
Xother account names or accounts on other machines, you can
Xlet mailtool know what those mail addresses are so they can
Xbe removed from the lists as well.
X
XNote, that if YOU add your name MANUALLY (type it yourself)
Xto either of the lists, it will not be removed.
X
XYou can set such a list in your .mailrc file in your home
Xdirectory by adding the line:
X
Xalts hostname1 hostname2 ...
X
XIf you prefer to not have your name removed from lists when
Xresponding to mail, set the option "metoo" and this prevents
Xthe need for alternates and your name will never be removed.
X%%
X
X%opts%
XTo set or unset options and their values, move the mouse over
Xthe option of your choice and select the LEFT button to toggle
Xtrue/false values. If an option requires a string value, you
Xmust type the value, so select the LEFT button to reference
Xthe option, and then type away.  Use a Carriage Return to enter
Xthe final value for the option.
X
XYou may select the RIGHT mouse button anywhere in the window
Xto give a menu which consists of saving options permanently,
Xreading in previous settings (from ~/.mailrc), and other things.
X%%
X
X%ignore%
XWhen reading mail, the message "headers" may clutter up the
Xwindow with information you are not interested in.  For
Xexample, you may not be interested in the "Received" or
X"Message-Id" field of the mail message. You would find that
Xin time, it will become annoying to see these uninteresting
Xmessage headers.
X
XYou can specify which message headers should not be shown,
Xthus shortening the appearance of the length of the message.
X
XTypical settings:
X    Received
X    Message-Id
X    Status
X%%
X
X%printer%
XThis item will send the current message, or the message specified on the
Xmenu header, to the printer. The printer used is given by the "printer"
Xoption (see opts in Main Panel Window). To specify a different printer,
Xchange the printer option by selecting the item "Opts" in the Main Panel
XWindow, moving the mouse over the Printer option, selecting the LEFT
Xmouse button and typing the name of the printer which you'd like to use.
X
XBe sure to set this option before printing because the DEFAULT option may
Xnot be what you want.
X
XYou can print messages that are NOT the current message by moving the
Xmouse into the Header Window and selecting the RIGHT mouse button on top
Xof the message you want to print and selecting the PRINT menu option.
X%%
X
X%windows%
X"Windows" are the boxes which contain items, text, or graphic
Ximages.  There are two "panel" windows. A panel window is one
Xwhich contains items,  which are the little boxes  with words
Xthat you can place the mouse over and click the left or mouse
Xbutton.
X
XEach  window has a separate  function for different purposes.
XStarting at the top of the main "tool" (contains all windows)
Xwe have the "header panel." Everything in this panel pertains
Xto the message headers, only.  The panel in the middle of the
Xtool is the "mail panel" which is more general and applies to
Xjust about everything. For a description of each of the items
Xwithin any panel, select the  "Help"  option  from  the  menu
Xyou get by selecting the RIGHT mouse button.
X%%
X
X%options%
XMove the cursor over the option you wish to change.
XThe LEFT mouse button turns toggles values off and on.
XThe MIDDLE mouse button displays the meaning of a
Xvariable. If the option needs typed input, use the LEFT
Xmouse button.  Sometimes value can be both toggle and
Xstring values so you may have to click the left button
Xmore than once to type.  When entering text values, you
Xmust use RETURN, so the value you typed will be associated
Xwith the option specified. Unsetting the option will -
Xassociate the a string value with that option.
X
XOnce values are disassociated with options, they can
Xonly be retrieved by either reentering their values or
Xby selecting the "restore options" item in the menu.
XDoing so will read in the last copy of the saved options
Xfrom your .mailrc file.
X
XSelecting the Save option in the menu will save the
Xcurrent settings in ~/.mailrc.  Selecting the quit
Xoption in the menu does NOT imply that values are
Xsaved permanently; changed values will remain through-
Xout the rest of the mail session.  To save options more
Xpermanently, select the save menu item.
X%%
X
X%function keys%
XSelecting the panel item "Opts" with the MENU button will give you
Xa choice of the type of options you can set. If you choose the one
Xthat says "function keys", then you can edit the commands that the
Xfunction keys on the keyboard may execute.  Once in this mode, you
Xwill find more extensive help.
X%%
X
X%fkeys%
XUsually the LAST function key in each set (top, left,
Xand right set of keys) will display the current settings
Xof all they keys.  The command which does this is 
X`key_settings X' where X is L, R, or T (left right top)
Xreferencing the associated function keys.  To set a function
Xkey to a specific command or set of commands, place the mouse
Xover the icon image of the key on the screen and click the
Xleft mouse button.  Type a command from the list of commands
Xat the bottom of the window and enter RETURN.
X
XMany commands take arguments or flags, so be sure to enter
Xthem here if you want those options. Clicking the middle button
Xwill display the current value for that key.  If you want to
Xset a key for multiple commands, separate the commands with
Xsemicolons:
X
XL9:  update ; close
X
XThis example would update your mailbox (committing changes)
Xand close the tool to an icon.
X%%
X
X%message range%
XYou can specify a large group of messages using a combination of special
Xsymbols in addition to numbers.  For example, if you wish to save all of
Xthe messages, then you can use `*' to represent them all. If you were to
Xtype the  "star" and select the Save  menu option for "save range", then
Xyou would save ALL the messages you have (including deleted ones).
X
XIf you would like to save messages 4 through 9, then you would specify:
X4-9
XIf you want to specify the messages between 2 and 32 except for messages
X6, 8 and message 12-14, you would type:
X2-32 {6,8,12-14}
XCommas or spaces can be used to separate numbers.
X
XNote that you cannot specify negated messages without first specifying
Xnormal messages; e.g. {2-5} 1-11   doesn't make sense.
X%%
X
X%sort%
XSorting messages can   be accomplished by  selecting one  of the
Xmenu items in this panel item.  By default (using the LEFT mouse
Xbutton),  sorting is  done by  message status.  New messages are
Xfirst, followed  by unread messages,  old/read messages, replied
Xto  messages,  and  finally deleted messages.  You may also sort
Xmessages by author, date, or subject by selecting the menu item.
X%%
END_OF_FILE
if test 23733 -ne `wc -c <'tool_help'`; then
    echo shar: \"'tool_help'\" unpacked with wrong size!
fi
# end of 'tool_help'
fi
echo shar: End of archive 10 \(of 19\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 19 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
