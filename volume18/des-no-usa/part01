Path: bbn.com!bbn!apple!bloom-beacon!tut.cis.ohio-state.edu!ucbvax!decwrl!sun!pitstop!sundc!seismo!uunet!munnari!alo@kampi.hut.fi
From: alo@kampi.hut.fi (Antti Louko)
Newsgroups: comp.sources.unix
Subject: v18i007:  DES routines and program - free of US controls, Part01/02
Message-ID: <2704@munnari.oz>
Date: 10 Mar 89 08:08:41 GMT
Sender: kre@munnari.oz
Lines: 1945
Approved: kre@munnari.oz.au

Submitted by: alo@kampi.hut.fi (Antti Louko)
Posting-number: Volume 18, Issue 7
Archive-name: des-no-usa/Part01

Moderator's note:

This is a posting of DES routines suitable for use with MIT's kerberos.
It was created in Finland, and is being posted from Australia, and so
is entirely free of US export controls.  I don't usually make
comp.sources.unix postings that originate outside Australia, but there
is no European sub-moderator (yet?) and this is rather a special case.

Where possible I will be taking special care to make sure that as much
of the net as is possible receives this posting without it having passed
through the US on the way.  Unfortunately there is no way I can make
that true for everyone.

The following note is from the original author (Antti Louko) ...

    Here is my DES-package.  I hope that the lack of documentation
    doesn't prevent posting this package in comp.sources.unix.  I have
    tried to implement library functions to match those of
    kerberos-des-package.  So kerberos manual pages give some hints what
    the library functions do.

    As I have said earlier, at least the library functions should be
    compiled with gcc, if one wants the best performance.  If it is needed
    I (or somebody else with gcc) can provide assembler- or .o- files for
    VAX- and SUN3- architecures.  These files should be checksummed of
    course to prevent any tampering. :-)

	    Antti Louko (alo@kampi.hut.fi)

Since that was written I have received an updated version that does include
a man page for the library routines.

I have added Makefiles for standard make (those in the original were
for GNU make only).  Note, these are very primitive Makefiles, if you
change anything, "make clean" and recompile from scratch.

I also added some "#ifdef BSD" lines to give this a reasonable chance of
compiling in a sys V environment (at the expense of giving up the -t (timing)
option to des-certify, and of leaving echo enabled when requesting passwords).
I am sure that if someone was to provide Sys V versions of the code that ends
up missing and mail it to Antti, that a patch will be forthcoming.

I suggest that if you're located in the US you don't attempt to modify
these routines, their purity may be lost if tainted by contributions
from such a restrictive country.

Notes: you need "getopt(3)" for the programs to link, if your system
lacks it, you can get it from a comp.sources.unix archive near you.

If you remove the .h files from lib that "make clean" tells you you
can remove, you will need Larry Wall's "perl" program to replace them.
Also available in a comp.sources.unix archive near you.

You should define BIG_ENDIAN if you are on a big endian host.  See
lib/des-private.h (I added the definitions for sparc and interdata,
no guarantees that the routines work on those hosts).

There are 2 files in the 'prog' directory that I uuencoded (now F1.uu
and F2.uu), I have no idea what they are useful for, if anything, however
should you need them, they will need to be uudecoded (to give F1 and F2).

: -------------------------------- cut here ---------------------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 2)."
# Contents:  README VERSION COPYRIGHT GNUmakefile Makefile Makerules
#   sun.ed man man/des.1 man/libdes.3 prog prog/Makerules
#   prog/des-certify.c prog/des.c prog/testdata prog/.gdbinit
#   prog/GNUmakefile prog/Makefile prog/F1.uu prog/F2.uu tables
#   tables/IP tables/IP-1 tables/E tables/S tables/GNUmakefile
#   tables/REMOVABLE tables/fp.make tables/P tables/mk-ip
#   tables/ip.make tables/eight.make tables/Makerules
#   tables/spe-table.make tables/ksched.dontmake
#   tables/shift4.dontmake lib MANIFEST
# Wrapped by kre@munnari on Fri Mar 10 18:29:39 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(546 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X-*- text -*-
XThis is a DES program package made by Antti Louko (alo@santra.hut.fi)
X
XCopyright 1989 Antti Louko. All Rights Reserved.
X
XCOPYRIGHT FILE TELLS WHAT YOU ARE ALLOWED TO DO WITH THIS SOFTWARE
X
XThis program should compile just fine on VAX with BSD 4.3. On SUNS,
Xyou should edit Makerules to include -msoft-float option if you don't
Xhave FPU. For other machines you should typedef des_u_long to be an
Xunsigned 32-bit integer type. If processor needs aligned multi-byte
Xaccesses, you may have to modify copy* -macros in des-private.h file.
END_OF_FILE
if test 546 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'VERSION' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'VERSION'\"
else
echo shar: Extracting \"'VERSION'\" \(33 characters\)
sed "s/^X//" >'VERSION' <<'END_OF_FILE'
XVersion:	1.0
XDate:		March 9 1989
END_OF_FILE
if test 33 -ne `wc -c <'VERSION'`; then
    echo shar: \"'VERSION'\" unpacked with wrong size!
fi
# end of 'VERSION'
fi
if test -f 'COPYRIGHT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'COPYRIGHT'\"
else
echo shar: Extracting \"'COPYRIGHT'\" \(518 characters\)
sed "s/^X//" >'COPYRIGHT' <<'END_OF_FILE'
X-*- text -*-
XCopyright 1989 Antti Louko. All Rights Reserved.
X
XThis is a DES implementation written by Antti Louko
X(alo@kampi.hut.fi). It is based on DES description found in D.E.R.
XDenning's book Cryptography and Data Security.  At this time you may
Xuse this program for non-commercial use. If you modify the program,
Xyou must add a comment in the modified file indicating who modified
Xit. For commercial purposes please contact me.
X
XIf you find bugs or otherwise modify this program, please send
Xchanges back to me.
END_OF_FILE
if test 518 -ne `wc -c <'COPYRIGHT'`; then
    echo shar: \"'COPYRIGHT'\" unpacked with wrong size!
fi
# end of 'COPYRIGHT'
fi
if test -f 'GNUmakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'GNUmakefile'\"
else
echo shar: Extracting \"'GNUmakefile'\" \(84 characters\)
sed "s/^X//" >'GNUmakefile' <<'END_OF_FILE'
X# This make file is for GNU make
X
XSUBDIRS=	tables lib prog
X
Xinclude Makerules
X
Xall:
END_OF_FILE
if test 84 -ne `wc -c <'GNUmakefile'`; then
    echo shar: \"'GNUmakefile'\" unpacked with wrong size!
fi
# end of 'GNUmakefile'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(258 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#
X# Kludged standard make Makefile (adapted from GNU make version).  kre
X#
XCFLAGS=	-O #SUN -msoft-float
XPRINT=		enscript
XMAKE=		make
X
XSUBDIRS=	tables lib prog
X
Xall clean print:
X	for i in $(SUBDIRS); do (cd $$i; $(MAKE) $@); done
X
X$(SUBDIRS):
X	cd $@; $(MAKE)
END_OF_FILE
if test 258 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'Makerules' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makerules'\"
else
echo shar: Extracting \"'Makerules'\" \(560 characters\)
sed "s/^X//" >'Makerules' <<'END_OF_FILE'
XCC:=		gcc
XCFLAGS:=	-O #SUN -msoft-float
XPRINT:=		enscript
X
XMAINTOPS:=	all clean print s-files
X.PHONY:		$(MAINTOPS)
X
Xifdef PRINTFILES
Xprint:
X	$(PRINT) $(PRINTFILES)
Xendif
X
Xifdef LMAINTOPS
X$(LMAINTOPS):	%:	%-local
X
X.PHONY:		$(addsuffix -local,$(LMAINTOPS))
Xendif
X
Xifneq ($(origin SUBDIRS),file)
XSUBDIRS:=
Xendif
X
Xifdef SUBDIRS
X$(MAINTOPS):
X	for i in $(SUBDIRS); do $(MAKE) -C $$i $@; done
Xelse
X$(MAINTOPS):
Xendif
X
Xifdef SUBDIRS
X$(SUBDIRS):
X	$(MAKE) -C $@
Xendif
X
Xifneq ($(origin S_FILES),file)
XS_FILES:=
Xendif
X
Xs-files:	$(S_FILES)
X
X%.s:	%.c
X	$(CC) -S $(CFLAGS) $^
END_OF_FILE
if test 560 -ne `wc -c <'Makerules'`; then
    echo shar: \"'Makerules'\" unpacked with wrong size!
fi
# end of 'Makerules'
fi
if test -f 'sun.ed' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sun.ed'\"
else
echo shar: Extracting \"'sun.ed'\" \(92 characters\)
sed "s/^X//" >'sun.ed' <<'END_OF_FILE'
X#! /bin/sh
Xed Makerules << EOF
Xg/#SUN/s///g
Xw
Xq
XEOF
Xed Makefile << EOF
Xg/#SUN/s///g
Xw
Xq
XEOF
END_OF_FILE
if test 92 -ne `wc -c <'sun.ed'`; then
    echo shar: \"'sun.ed'\" unpacked with wrong size!
fi
# end of 'sun.ed'
fi
if test ! -d 'man' ; then
    echo shar: Creating directory \"'man'\"
    mkdir 'man'
fi
if test -f 'man/des.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/des.1'\"
else
echo shar: Extracting \"'man/des.1'\" \(2158 characters\)
sed "s/^X//" >'man/des.1' <<'END_OF_FILE'
X.TH DES 1 "March 9, 1989"
X.GN 2
X.SH NAME
Xdes \- encrypt and decrypt using DES algorithm
X.SH SYNOPSIS
X.B des
X[
X.B -k
X.I keystring
X] [
X.B -e
X] [
X.B -d
X] [
X.B -x
X] [
X.B -X
X] [
X.B -c
X.I count
X] [
X.B -p
X] [
X.I inputfile
X[
X.I outputfile
X] ]
X.SH DESCRIPTION
X.I Des
Xreads
X.I inputfile
Xand writes the en/decrypted data to
X.I outputfile\c
X\&.
XIf file name is not given in command line, des uses standard input or output.
XThe
X.I keystring
Xis transformed by a one-way funtion into a 8-byte key,
Xwhich is then used by the algorithm. If no
X.I keystring
Xis given on command line,
Xdes asks one with getpass(3).
X.PP
XDes encrypts when given
X.B -e
Xflag and decrypts with
X.B -d\c
X\&.
XWith
X.B -x
Xflag des encrypts normally, but it doesn't produce any encrypted
Xoutput, instead it prints 8-byte cryptographic checksum of input data.
XThe checksum is printed to standard error file.
XThis checksum can be used to verify whether the input data has been modified.
XIt is computationally hard to change the input data in such a way that
Xthe checksum wouldn't change.
X.B -X
Xis similar to
X.B -x
Xbut it prints the input data to output file unchanged.
XUsing this feature you can for example produce a compressed tar archive
Xand its checksum
Xat the same time with command:
X.PP
X(tar cf - dir | des -X | compress > dir.tar.Z) >& dir.cksum
X.PP
XWith
X.B -c
Xdes makes encryption
X.I count
Xtimes for each 8kbyte block.
XThis possibly makes the encrypted data harder to break.
X.PP
XBy default, des encrypts the data using cipher block chaining (CBC) mode.
XWith
X.B -p
Xflag, des uses
XPCBC mode, which makes it possible to detect if the data have been tampered
Xafter encryption.
X.SH FILES
X/dev/tty is used to read a keystring by getpass(3)
X.SH AUTHOR
XAntti Louko (alo@kampi.hut.fi), Helsinki University of Technology
XComputing Centre
X.SH BUGS
XThis program is at most as strong as DES algorithm itself.
XSo, we urge the user to use this program only after he has assured
Xhimself that DES is strong enough AND he has read the source code of this
Xprogram and its libraries AND he has compiled the program himself with a
Xtroyan-free compiler. I DON'T GUARANTEE THAT THIS PROGRAM IS A DECENT
XENCRYPTION PROGRAM.
END_OF_FILE
if test 2158 -ne `wc -c <'man/des.1'`; then
    echo shar: \"'man/des.1'\" unpacked with wrong size!
fi
# end of 'man/des.1'
fi
if test -f 'man/libdes.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/libdes.3'\"
else
echo shar: Extracting \"'man/libdes.3'\" \(2347 characters\)
sed "s/^X//" >'man/libdes.3' <<'END_OF_FILE'
X.TH LIBDES 3 "March 9, 1989"
X.GN 2
X.SH NAME
Xdes_set_key, des_ecb_encrypt, des_cbc_encrypt, des_pcbc_encrypt, string_to_key
X.SH SYNOPSIS
X.nf
X.nj
X.B #include <des.h>
X.PP
X.B des_set_key(key,schedule)
X.B C_Block	*key;
X.B Key_schedule	*schedule;
X.PP
X.B des_ecb_encrypt(input,output,schedule,mode)
X.B C_Block	*input;
X.B C_Block	*output;
X.B Key_schedule	*schedule;
X.B int		mode;
X.PP
X.B des_cbc_encrypt(input,output,length,schedule,ivec,mode)
X.B C_Block	*input;
X.B C_Block	*output;
X.B int		length;
X.B Key_schedule	*schedule;
X.B C_Block	*ivec;
X.B int		mode;
X.PP
X.B des_pcbc_encrypt(input,output,length,schedule,ivec,mode)
X.B C_Block	*input;
X.B C_Block	*output;
X.B int		length;
X.B Key_schedule	*schedule;
X.B C_Block	*ivec;
X.B int		mode;
X.PP
X.B string_to_key(asckey,key)
X.B char	*asckey;
X.B C_Block	*key;
X.PP
X.fi
X.SH DESCRIPTION
XThese library functions implement DES-algorithm with different
Xvariations. Type
X.I C_Block
Xis a data type containing eight bytes of
Xinformation. The least significant bit of the first byte of
X.I C_Block
Xis bit number 1 as specified in DES standard.
X.I C_Block
Xis defined as follows:
X.PP
X.nf
X.nj
X.B	typedef unsigned char	des_u_char;
X.B	typedef struct {
X.B 	  des_u_char	data[8];
X.B	} C_Block;
X.fi
X.PP
XA key schedule must be computed before encryption routines can be used.
XThis is done with function
X.I des_set_key,
Xwhich computes
X.B schedule
Xfrom
X.I key.
X.I Des_ecb_encrypt
Xencrypts one block of data at
X.I *input
Xto
X.I *output
Xusing
X.I schedule.
XIf mode is
X.I DES_ENCRYPT,
Xthe data is encrypted; if mode is
X.I DES_DECRYPT,
Xthe data is decrypted. If initial permutation or/and
Xfinal permutation is not wanted, mode can be ored (|) with
X.I DES_NOIPERM
Xor/and
X.I DES_NOFPERM.
X.PP
X.I Des_cbc_encrypt
Xencrypts length bytes of data at
X.I *input
Xto
X.I *output
Xin cipher block chaining mode. Initial vector is at
X.I *ivec.
X.I *ivec
Xis also updated to contain the final vector.
X.PP
X.I Des_pcbc_encrypt
Xuses a modified cipher block chaining. This mode can
Xbe used to detect if encrypted data have been tampered. In pcbc mode
Xchanging ciphertext data affects all the following decrypted cleartext
Xdata.
X.PP
X.I String_to_key
Xfunction converts ascii string
X.I asckey
Xinto a DES key
X.I *key
Xusing one way function which is based on DES algorithm.
X
X.SH AUTHOR
XAntti Louko (alo@kampi.hut.fi), Helsinki University of Technology
XComputing Centre
END_OF_FILE
if test 2347 -ne `wc -c <'man/libdes.3'`; then
    echo shar: \"'man/libdes.3'\" unpacked with wrong size!
fi
# end of 'man/libdes.3'
fi
if test ! -d 'prog' ; then
    echo shar: Creating directory \"'prog'\"
    mkdir 'prog'
fi
if test -f 'prog/Makerules' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prog/Makerules'\"
else
echo shar: Extracting \"'prog/Makerules'\" \(560 characters\)
sed "s/^X//" >'prog/Makerules' <<'END_OF_FILE'
XCC:=		gcc
XCFLAGS:=	-O #SUN -msoft-float
XPRINT:=		enscript
X
XMAINTOPS:=	all clean print s-files
X.PHONY:		$(MAINTOPS)
X
Xifdef PRINTFILES
Xprint:
X	$(PRINT) $(PRINTFILES)
Xendif
X
Xifdef LMAINTOPS
X$(LMAINTOPS):	%:	%-local
X
X.PHONY:		$(addsuffix -local,$(LMAINTOPS))
Xendif
X
Xifneq ($(origin SUBDIRS),file)
XSUBDIRS:=
Xendif
X
Xifdef SUBDIRS
X$(MAINTOPS):
X	for i in $(SUBDIRS); do $(MAKE) -C $$i $@; done
Xelse
X$(MAINTOPS):
Xendif
X
Xifdef SUBDIRS
X$(SUBDIRS):
X	$(MAKE) -C $@
Xendif
X
Xifneq ($(origin S_FILES),file)
XS_FILES:=
Xendif
X
Xs-files:	$(S_FILES)
X
X%.s:	%.c
X	$(CC) -S $(CFLAGS) $^
END_OF_FILE
if test 560 -ne `wc -c <'prog/Makerules'`; then
    echo shar: \"'prog/Makerules'\" unpacked with wrong size!
fi
# end of 'prog/Makerules'
fi
if test -f 'prog/des-certify.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prog/des-certify.c'\"
else
echo shar: Extracting \"'prog/des-certify.c'\" \(4460 characters\)
sed "s/^X//" >'prog/des-certify.c' <<'END_OF_FILE'
X#include "des.h"
X#ifdef BSD
X#include <sys/time.h>
X#include <sys/resource.h>
X#endif
X#include <stdio.h>
X
Xstatic des_u_char rev8bits[] = {
X#include "eight.h"
X};
X
Xint	gflag;
Xint	vflag;
Xint	tflag;
Xint	count = 1;
X
Xextern char	*optarg;
Xextern int	optind;
X
Xmain(argc,argv,envp)
X
Xint argc;
Xchar **argv;
Xchar **envp;
X
X{
X  char	s[100];
X  char	s_k[30];
X  char	s_p[30];
X  char	s_c[30];
X  C_Block	b_key;
X  C_Block	b_plain;
X  C_Block	b_cipher;
X  char	s_c1[30];
X  char	s_p1[30];
X  char	s_p2[30];
X  C_Block	b_cipher1;
X  C_Block	b_plain1;
X  C_Block	b_plain2;
X  C_Block	b_t;
X  Key_schedule	sched;
X  int	err;
X  int	c;
X  int	e_c,e_p1,e_p2;
X  int	i;
X  
X  while ((c = getopt(argc,argv,"vn:tg")) != EOF) {
X    switch (c) {
X    case 'v':
X      vflag++;
X      break;
X    case 'n':
X      count = atoi(optarg);
X      break;
X    case 't':
X      tflag++;
X      break;
X    case 'g':
X      gflag++;
X      break;
X    default:
X      break;
X    }
X  }
X  if (gflag) {
X    tflag = 0;
X    count = 1;
X  }
X  while(fgets(s,sizeof(s),stdin)) {
X    e_c = e_p1 = e_p2 = err = 0;
X    if (sscanf(s,"%s %s %s",s_k,s_p,s_c) != 3)
X      break;
X    s_to_b(s_k,&b_key);
X    s_to_b(s_p,&b_plain);
X    s_to_b(s_c,&b_cipher);
X    des_set_key(&b_key,&sched);
X    if (tflag)
X      timing(0,count);
X    des_ecb_encrypt(&b_plain,&b_cipher1,&sched,DES_ENCRYPT);
X    des_ecb_encrypt(&b_cipher1,&b_plain2,&sched,DES_DECRYPT);
X    des_ecb_encrypt(&b_cipher,&b_plain1,&sched,DES_DECRYPT);
X    for(i = 3; i < count; i++)
X      des_ecb_encrypt(&b_plain,&b_t,&sched,DES_ENCRYPT);
X    if (tflag)
X      timing(1,count);
X    b_to_s(&b_key,s_k);
X    b_to_s(&b_plain,s_p);
X    b_to_s(&b_cipher,s_c);
X    b_to_s(&b_cipher1,s_c1);
X    b_to_s(&b_plain1,s_p1);
X    b_to_s(&b_plain2,s_p2);
X    if (b_cmp(&b_cipher,&b_cipher1)) {
X      err++;
X      e_c++;
X    }
X    if (b_cmp(&b_plain,&b_plain1)) {
X      err++;
X      e_p1++;
X    }
X    if (b_cmp(&b_plain,&b_plain2)) {
X      err++;
X      e_p2++;
X    }
X    if (gflag) {
X      printf("%s %s %s\n",s_k,s_p,s_c1);
X    } else {
X      printf("%-2s Key: %s  Pla: %s  Cip: %s",err ? "" : "OK",s_k,s_p,s_c);
X      if (vflag) {
X	printf("\n");
X	if (e_c)
X	  printf("%49sCip: %s\n","",s_c1);
X	if (e_p1)
X	  printf("%26sPl1: %s\n","",s_p1);
X	if (e_p2)
X	  printf("%26sPl2: %s\n","",s_p2);
X      } else {
X	if (e_c) printf(" c");
X	if (e_p1) printf(" p1");
X	if (e_p2) printf(" p2");
X	printf("\n");
X      }
X      if (tflag)
X	timing(2,count);
X    }
X  }
X  if (tflag)
X    timing(3,count);
X  return 0;
X}
X
Xb_cmp(b1,b2)
X
XC_Block	*b1;
XC_Block	*b2;
X
X{
X  int	i;
X
X  for(i = 0; i < 8; i++) {
X    if (b1->data[i] != b2->data[i])
X      return 1;
X  }
X  return 0;
X}
X
Xb_to_s(b,s)
X
Xchar	*s;
XC_Block	*b;
X
X{
X  int	i;
X  for(i = 0; i < 8; i++) {
X    sprintf(&s[i*2],"%02x",rev8bits[b->data[i]]);
X  }
X}
X
Xs_to_b(s,b)
X
Xchar	*s;
XC_Block	*b;
X
X{
X  int	i;
X  int	j;
X  int	c;
X  int	cc;
X
X  for(i = 0; i < 8; i++) {
X    cc = 0;
X    for(j = 0; j < 2; j++) {
X      c = s[i*2+j] & 0xff;
X      if (c >= '0' && c <= '9')
X	c -= '0';
X      else if (c >= 'A' && c <= 'F')
X	c -= ('A'-10);
X      else if (c >= 'a' && c <= 'f')
X	c -= ('a'-10);
X      else
X	return 1;
X      cc = (cc << 4) + c;
X    }
X    b->data[i] = rev8bits[cc];
X  }
X  return 0;
X}
X
Xdouble
Xs_to_speed(s,count)
X
Xdouble	s;
Xint	count;
X
X{
X  return (8.0/1024.0)*(double)count/s;
X}
X
Xtiming(x,count)
X
Xint	x;
Xint	count;
X
X{
X#ifdef BSD
X  static struct rusage	r[2];
X  int		s,us;
X  double	kbps;
X  double	ss;
X  static int	n;
X  static double	total;
X  static double	mint;
X  static double	maxt;
X  static int	cannot;
X
X  switch (x) {
X  case 0:
X  case 1:
X    getrusage(RUSAGE_SELF,&r[x]);
X    cannot = 0;
X    break;
X  case 2:
X    s = r[1].ru_utime.tv_sec - r[0].ru_utime.tv_sec;
X    us = r[1].ru_utime.tv_usec - r[0].ru_utime.tv_usec;
X    if (us < 0) {
X      s--;
X      us += 1000000;
X    }
X    ss = (double)s+(double)us/1000000.0;
X    printf("%6d encryptions, utime: %8.2f   ",count,ss);
X    if (ss > 0.01) {
X      printf("%8.3f kbytes/s.",s_to_speed(ss,count));
X    } else {
X      printf("cannot calculate performance");
X      cannot = 1;
X    }
X    printf("\n");
X    if (n == 0) {
X      mint = maxt = ss;
X    } else {
X      if (ss < mint)
X	mint = ss;
X      if (ss > maxt)
X	maxt = ss;
X    }
X    total += ss;
X    n++;
X    break;
X  case 3:
X    if (n > 1 && !cannot) {
X      printf("Average speed: %8.3f kbytes/s\n",s_to_speed(total/n,count));
X      printf("Maximum speed: %8.3f kbytes/s\n",s_to_speed(mint,count));
X      printf("Minimum speed: %8.3f kbytes/s\n",s_to_speed(maxt,count));
X    }
X  }
X#endif
X}
END_OF_FILE
if test 4460 -ne `wc -c <'prog/des-certify.c'`; then
    echo shar: \"'prog/des-certify.c'\" unpacked with wrong size!
fi
# end of 'prog/des-certify.c'
fi
if test -f 'prog/des.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prog/des.c'\"
else
echo shar: Extracting \"'prog/des.c'\" \(3787 characters\)
sed "s/^X//" >'prog/des.c' <<'END_OF_FILE'
X/* Copyright 1989 Antti Louko. All Rights Reserved.
X
X/* This program encrypts and decrypts files with des algorithm. It can
X   be used in three different modes: ecb, cbc or pcbc modes. -p selects
X   pcbc mode, the default is cbc mode.
X
X   Command syntax is: des [-e] [-d] [-h] [-k key] [-p] [infile [outfile]]
X
X   des encrypts with -e flag and decrypt with -d flag.
X
X */
X
X#include "des.h"
X# include <stdio.h>
X
X#define myfopen fopen
X
X#define BUFSIZE	8192
X
X#define MODE_ECB 1
X#define MODE_CBC 2
X#define MODE_PCBC 3
X
Xextern int	optind;
Xextern char	*optarg;
X
Xint	eflag;
Xint	dflag;
Xint	hflag;
Xint	bflag;
Xint	xflag;
Xint	Xflag;
Xint	c_count;
Xint	cbc = MODE_CBC;
Xint	do_output;
X
Xint	corr;
X
Xchar	*getpass();
X
Xstatic char	*Xkey = "A-very-long-checksumkey";
X
Xmain(argc,argv,envp)
X
Xint argc;
Xchar **argv;
Xchar **envp;
X
X{
X  char	*iname,*oname;
X  FILE	*fin,*fout;
X  int	c;
X  char	*key = 0;
X  Key_schedule	Key;
X  int		mode;
X  C_Block	bkey;
X  int	ok;
X  int	n;
X  int	n2;
X  char	buf[BUFSIZE+8];
X  int	b;
X  int	cnt;
X  int	dmode;
X  C_Block	ivec;
X
X  ivec = des_zero_block;
X  fin = stdin;
X  fout = stdout;
X  while ((c = getopt(argc,argv,"hedpxXk:c:")) != EOF) {
X    switch (c) {
X    case 'h':
X      hflag++;
X      break;
X    case 'e':
X      eflag++;
X      do_output++;
X      break;
X    case 'd':
X      dflag++;
X      do_output++;
X      break;
X    case 'k':
X      key = optarg;
X      break;
X    case 'c':
X      c_count = atoi(optarg);
X      break;
X    case 'x':
X      xflag++;
X      break;
X    case 'X':
X      Xflag++;
X      xflag++;
X      break;
X    case 'p':
X      cbc = MODE_PCBC;
X      break;
X    }
X  }
X  if (eflag + dflag + xflag!= 1) {
X    fprintf(stderr,"Only one from -x, -X, -e and -d\n");
X    exit(1);
X  }
X  if (dflag)
X    mode = DES_DECRYPT;
X  else
X    mode = DES_ENCRYPT;
X  if (xflag) {
X    eflag = 1;
X    cbc = MODE_PCBC;
X    bflag = 0;
X  }
X  argv += optind;
X  if (*argv) fin = myfopen(*argv++,"r");
X  if (!fin) fprintf(stderr,"Cannot open input file\n");
X  if (*argv) fout = myfopen(*argv++,"w");
X  if (!fout) fprintf(stderr,"Cannot open output file\n");
X  if (!key && xflag)
X    key = Xkey;
X  if (!key) {
X    if (!(key = alo_read_password((hflag ?
X				   "Enter hex key: " :
X				   "Enter keyword: ")
X				  ,1)))
X      exit(1);
X  }
X  if (hflag) {
X    if (des_hex_to_key(key,&bkey) == -1) {
X      fprintf(stderr,"Invalid hex key\n");
X      exit(1);
X    }
X  } else {
X    string_to_key(key,&bkey);
X  }
X  des_set_key(&bkey,&Key);
X  for(ok = 1; ok ;) {
X    int	nread;
X    if ((n = nread = fread(buf,1,BUFSIZE,fin)) < BUFSIZE) {
X      ok = 0;
X      b = n%8;
X      if (!dflag) {
X	n2 = ((n+8)&(~7)) - 1;
X	buf[n2] = b;
X	while (n < n2)
X	  buf[n++] = 0;
X	n = n2+1;
X      } else {
X	if (b != 0)
X	  corr++;
X      }
X    }
X    if (Xflag) {
X      if ((n2 = fwrite(buf,1,nread,fout)) < nread) {
X	fprintf(stderr,"Cannot write %d bytes; wrote %d bytes\n",nread,n2);
X      }
X    }
X    cnt = (n+7)/8;
X    c = c_count ? c_count : 1;
X    for(; c > 0; c--) {
X      switch (cbc) {
X      case MODE_CBC:
X	des_cbc_encrypt(buf,buf,cnt*8,&Key,&ivec,mode);
X	break;
X      case MODE_PCBC:
X	des_pcbc_encrypt(buf,buf,cnt*8,&Key,&ivec,mode);
X	break;
X      }
X    }
X    if (dflag) {
X      if (ok) {
X	c = getc(fin);
X	if (c == EOF) {
X	  ok = 0;
X	} else {
X	  ungetc(c,fin);
X	}
X      }
X      if (!ok) {
X	b = buf[n-1];
X	if (b > 7 || b < 0) {
X	  corr++;
X	  b = 7;
X	} else
X	  n -= 8-b;
X      }
X    }
X    if (do_output) {
X      if ((n2 = fwrite(buf,1,n,fout)) != n) {
X	fprintf(stderr,"Cannot write %d bytes; wrote %d bytes\n",n,n2);
X	exit(1);
X      }
X    }
X  }
X  if (corr) {
X    fprintf(stderr,"Encrypted file is corrupted\n");
X    exit(1);
X  }
X  if (xflag) {
X    print_h(stderr,&ivec);
X    fprintf(stderr,"\n");
X  }
X  return 0;
X}
X
Xprint_h(f,x)
X
XFILE		*f;
XC_Block		*x;
X
X{
X  int	i;
X
X  for(i = 0; i < 8; i++)
X    fprintf(f,"%02x",x->data[i]);
X}
END_OF_FILE
if test 3787 -ne `wc -c <'prog/des.c'`; then
    echo shar: \"'prog/des.c'\" unpacked with wrong size!
fi
# end of 'prog/des.c'
fi
if test -f 'prog/testdata' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prog/testdata'\"
else
echo shar: Extracting \"'prog/testdata'\" \(612 characters\)
sed "s/^X//" >'prog/testdata' <<'END_OF_FILE'
X0000000000000000 0000000000000000 8ca64de9c1b123a7
X0101010101010101 0000000000000000 8ca64de9c1b123a7
Xffffffffffffffff ffffffffffffffff 7359b2163e4edc58
Xfefefefefefefefe ffffffffffffffff 7359b2163e4edc58
Xfefefefefefefefe 9823873621837678 173c550deced7865
X1111111111111111 1111111111111111 f40379ab9e0ec533
X2222222222222222 2222222222222222 0f8adffb11dc2784
X6234868327468237 8334675273657623 5b78ee694f5cd9d5
X5fe7273a321ddcdf 1968e7fe541e071f 6ba7427b542ca74e
Xaa11a725d984543f 3ad3dd6743e42cd9 514d7e3d7443c5a8
X3d9ab7008771215d c4476015ae6ddb83 c7e46d079e41ec22
Xd69cc9c8a7a632fa 28f99bdab349a0a3 19bb4e040ee87609
END_OF_FILE
if test 612 -ne `wc -c <'prog/testdata'`; then
    echo shar: \"'prog/testdata'\" unpacked with wrong size!
fi
# end of 'prog/testdata'
fi
if test -f 'prog/.gdbinit' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prog/.gdbinit'\"
else
echo shar: Extracting \"'prog/.gdbinit'\" \(11 characters\)
sed "s/^X//" >'prog/.gdbinit' <<'END_OF_FILE'
Xdir ../lib
END_OF_FILE
if test 11 -ne `wc -c <'prog/.gdbinit'`; then
    echo shar: \"'prog/.gdbinit'\" unpacked with wrong size!
fi
# end of 'prog/.gdbinit'
fi
if test -f 'prog/GNUmakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prog/GNUmakefile'\"
else
echo shar: Extracting \"'prog/GNUmakefile'\" \(383 characters\)
sed "s/^X//" >'prog/GNUmakefile' <<'END_OF_FILE'
XLMAINTOPS:=	all clean
XPROGS:=		des-certify des
XSOURCES:=	$(addsuffix .c,$(PROGS))
XOBJS:=	$(addsuffix .o,$(PROGS))
XLOADLIBES:=	../lib/libdes.a
XPRINTFILES:=	$(SOURCES)
X
X.PHONY:	all clean test
X
Xall-local:	$(PROGS) $(OBJS)
X
Xinclude Makerules
X
XCFLAGS:=	$(CFLAGS) -I../lib
X
Xclean-local:
X	rm -f $(PROGS) $(OBJS)
X
X$(PROGS):	$(LOADLIBES)
X
Xtest:
X	head -1 testdata | ./des-certify -n1024 -t -v
END_OF_FILE
if test 383 -ne `wc -c <'prog/GNUmakefile'`; then
    echo shar: \"'prog/GNUmakefile'\" unpacked with wrong size!
fi
# end of 'prog/GNUmakefile'
fi
if test -f 'prog/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prog/Makefile'\"
else
echo shar: Extracting \"'prog/Makefile'\" \(568 characters\)
sed "s/^X//" >'prog/Makefile' <<'END_OF_FILE'
X#
X# kludged standard make Makefile - derivedfrom GNU makefile ... kre
X#
XCFLAGS=		-DBSD -c -O -I../lib -Dconst= #SUN -msoft-float
XPROGS=		des-certify des
XSOURCES=	des-certify.c des.c
XOBJS=		des-certify.o des.o
XLOADLIBES=	../lib/libdes.a
XPRINT=		enscript
XPRINTFILES=	$(SOURCES)
X
Xall:	$(PROGS)
X
Xdes:	des.o $(LOADLIBES)
X	$(CC) -o des des.o $(LOADLIBES)
X
Xdes-certify: des-certify.o $(LOADLIBES)
X	$(CC) -o des-certify des-certify.o $(LOADLIBES)
X
Xclean:
X	rm -f $(PROGS) $(OBJS)
X
Xtest: des-certify
X	sed 1q testdata | ./des-certify -n1024 -t -v
X
Xprint:
X	$(PRINT) $(PRINTFILES)
END_OF_FILE
if test 568 -ne `wc -c <'prog/Makefile'`; then
    echo shar: \"'prog/Makefile'\" unpacked with wrong size!
fi
# end of 'prog/Makefile'
fi
if test -f 'prog/F1.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prog/F1.uu'\"
else
echo shar: Extracting \"'prog/F1.uu'\" \(5435 characters\)
sed "s/^X//" >'prog/F1.uu' <<'END_OF_FILE'
Xbegin 644 F1
XM47M2Z&.$JE[B>4)NIOH<_,1:`7,@!80'12BT\*F'*7#10&!I-ZE2J5MF.J(Y
XMI!ZFM52KC[KG\ENM)X.TG`8C4Q\,1BS;,41%FZ`NM!_O8OF[]A;1)HX@;]*?
XM]C;"%VULA?%*JEU1S4''W,E=0=@IW=+."Q<4Z]:V=I3MG']&?;K\#21YG=WB
XMLU4[8PGJ)>'AL/:Z3F1TKYE9T7)BMVN,Z+5[@]17;0K2W">&[A3A'@J#6(9@
XMQE=U[/"B\2!:LZ.S63^B?EO>.N**RA:JFFUL$AJ!\6D'@='BX/4!X-/=R'+]
XMI'"`=?YT@DG:2=J?TY$>:S@+A#=-OXNQVS*9GBHE?&30UJ\]C+C[021,*,PW
XM[@&7Q(]TU>V-GZ^;16<"?`%^-K\R?P9/C&]J09Q1)49?<51!15MQ.-9$JI%*
XMGUSQ]0);#[MQRM:7G2VQS$@Z_:":-JA$-TY?XCTR5>SP11F*C>1&A6><[#!<
XMKF)Z_0E,`G?*YC;"6UE<`%P5?PCUIP6<#,OBN`6I8>RL!S11@->C68M`@=R(
XM8VK.2@Y&8ZQ:"BU+D"43$-PB$_9AZY;GS*,K>V@^NP[MQ^\U4KD&JC%&5'!!
XMCXMH?=,@")R'(M/@$<K<4T@+I/UO))(,5X"*VU5S&[:OP<3M5""7/+D'2,RS
XMI=DEU[/E9_EN)Q!,]_66^9PW`D=*+A-DL%;X<W#V$OZ*)99`NQU*PE>W^3V3
XM:Z+AT>\HCU[\U?AN:;MJR&A[AG*RW$<*K!5I'X%,XP3_S).Y8N71'&GY7=`'
XMAK8[TM-[..:0O.!\ZG]6)@]9Y7Z_4-AECFCN1=>YZKP:96*3#9O8<1(K9(;[
XMPB/;`97195Z6/@+<5M`[^1#86<IU84M1I@0D)N]5=#EAG#]##K*B6KH-ZN;6
XMN]\"W`XRB80,X=K'PX#%S-7"Z"^>72YD3O]B\[>345R^ND?,('89;M5]T*,D
XM4M*_LF8BB"Y<=P4'Z&D,[/^_%KXV*7H"J<*\?C<XK*F`2XWNAD6[B3VO%^A'
XMB\H#_D&S]T7;G*?#N"D&"'`GU59TR_9_%U)E4&C4W7-`(`PTE.4[>B'R*[L*
XMNB6784[834RN'P'/966#;9)VH)I:%A7M.=(OP10=W$U/:;O![HHUGA`&6@]"
XMH-T&)Y!.6"?'9'2V)]3AZ*(#?5UH^V/1[/((1?5=%5BUHK-LC2WX8Q9`S>SY
XM1<NIM6H!RP/M8AM4-R6CHM_I0FN4[Y;\LN$D6V+3UQAKUMU,^3+G;@VO[0Z.
XM;V.Z(#H53JZW-\!V\+=!F`I9'OWM2"(R;#/+_U-D[=]-9,E3ALF/]G1K$3RS
XMZV9V*0A4CK+K5&$*GK9IP"=K-3</I9(<-U_YS^G-/"`6C_]RWFVP_=T8.&(B
XMMG:'U(U1IEG??MP63/1?*)TJ-7["H?IVBJ3.*TT\_<+,_W?C'\RI%[M*`1=X
XMM/&O!-F;UE&B6FNY`%R>8I="TO4L0CM7>/E4VW(!%97P=E-`V)\O6.7_$8\]
XM&;:Y9MR!#&J%QF@E7,K)09=DTJ;.!5]-7XO*]&M8-S-/!RC,#%*=$?`I5O^1
XMNUGR*"\/HO,96EV,04,0@77`4X^U/GN(@]>'<T/_T#>4>%%CI$FW=B)2M1X<
XMO:7;3<%A;8;VQ5F^S\O_/4,9))WQ^&\;'$:L3JVE^=56:IRMJ;4E+`-)3U_Y
XM.L)KF1;-F`MC`Q^R`3MGSR+G(1;=T2QI/"1PQ8_3'*X)=GZD3BJ#QP#U$%I_
XM_ZUP79RH'`JUKUY;<C&:IDXI9G>5,KV.D-"V20<[4>KF/OZXM:S%_^>C*SZ,
XMS]T?^*;2**<'U-6!0Q.P$XB_-)%XFDM:WM%Q*,?.AJV/$VAZKUQ:)@0=YUL"
XMYMD!&U$9"`GU4,<MN]C<JY,,<@7PI%%8(;Y%3#E)Q*#6RX8.[,Y'6,G2ZQ>T
XMU.KN+:Z$NFX<K*B)F61,P="*GF>;ANT6Y3W*)S-W8AC&>ZQ-U?3@BXDII)\@
XM!T/>"$.TY`/IV74]#?R=HR^7F9]>X;1"P'[TCC<R#M32]GKB>U:C#&'POB4V
XMP17YJ)5?%A&BZV/NTX4[5"27X>#T:F9W,&Q+9_+(F[0)\`D8MA.$GV7X,A`P
XM0B^>'^_R=/V[6#_I.F/'^\%H,RBNS->,<6)-P>$_7KEWJQ&/%Q.(ZVB\YE/W
XMBLM]JR`&BU36[S#I-5>+E5:B"JXB4AI0%LJK[D@@D(S]T=P>]!*:10@S>^.>
XMJP".AUS9?.^8\,XR@%/_10(Y`^8`^GW(;6U*%<X+]G8_PTPR!^[RCP"<$U_E
XM,J<4;_@#TZI=M%C4\XHV('0QP-`'1T4I/$T/TUO$@4.A'#C,#744ANL%,-?<
XM)X0PHD]&HM^/SD.,F\F`5N0"\?TOLR2EP,B\M36,VM6!U?0KJ$5,7HPDL!>'
XM6BW*U[@E>NV3V"F'IN8(A&F/6Q$%*J8Z:T(9S)>_%K/[T!+^7GU1,$_*Y:B+
XM<M^=GT%`2Q2(7<^[$[C!4#=+CG*)$C:*U(98;,EU3-@(+^\"'42>]/U%\ZT0
XM0T]?CBA;^I:9Y!`]A5)$-`VK:ZS_*2+J*R7=!@$L$$T/^X:V+17AKP\LTPJ-
XMZC30>)C4YJ#B_RC<==%&'0*P5MD6=PO>=C61X_-F:<NK0GE[E50#9%AYY]B`
XM*AUZN\9VS'=>Z(_L2$/ND2*;D;OD+AU,`%Y\^GR8C45%^JIW#0U49@TR_\B?
XMXQ]./\C^<9ZGPK4,WTC9SUJR^2]W756^<^+,[[9*2'V#."[S(2R]OE[R1G)8
XM$ODJB6W*W,6:.`"G(=9--AC+E66)SE/`V'#NT"BCV)!>;;6"UHDR2.*6P5^3
XM?2--9_Z&H);[V8':D8K6MBA)#<`UC?6""EM?^#0Z5($/EM2,2BWUZO_<_ZM^
XM6=Y9YE__STVW%KDY=W!B_)\3AC?)(>Q$WVQ.CKB:(7[-J'@-B,Y]B6U)R/_%
XM+PXSS=)#6J0;#?LI"/.*L?Q>5,;"=ON]U/&J5`>*/1?CO@X&0I+Y9E$@Y43K
XMB6-]G[6XD:GPGQV[K0\T8F;WUQ]J_?5SH62*,U;S#FS%SD`Y1R&_[(;F+TI^
XM'1E\?0UTQW4A<Q31SA^C`NJ+OO!Q43=`7Q(@H7B6+55<YAW"G7E^(WF^CQA<
XM<US)3.W"3]UTS%1'%^3J5/@][MQ%$S*UDX$%=/]9(;"V`#X9.`X_\P\80H;X
XMGH2UOU5M1IE9%YDA6*Z`;WJ\RA?<:H5CP_(@`Z=B31\^CN>'Q).SNCE+8D0/
XM],J_(W;;+R(<A]A4.2:@\%;MH=11P^S0\GV[P4D_3S+0?LDS?]?RM(F--?='
XM?I=%+%I6#VB?#E2$63.M[N99F$K>^M(VK]R'4R2FRZRBY>\5_+?TJMA_=L^,
XM!?EY/T:`7^![S>*T>IB-GR!S8![RO/GT&V08/D.('L]P_J@>+CU^8NQ##0&H
XM#7R\7$PT^"5X@\]BNXI1KM=$Q&/YM&U`BH$6?`M^"_(U%^5A,$<LQ8J&I^#U
XMXR0T`89UYW,4(=JA$.SP=3/?Q1\4GT>`)GD2G;^/_EH6S="[<3F.\Y]A7_TW
XM*CP*=))#A"9ZFGV[OFUVO8[#IY,E+X(T:B/NXQ+@K$9K'%GB&W\U-2P`$M'M
XM0+IKK=>N3X1JPJ@:F):RK_RBX:M\C_!U84>/&;3=D`@X^=5%5Q[+^F+O+J7F
XMKKHZ$$E$-YQI5=+(NM/1^Y`@3%6V*3QRSK)?U>3;3OH#/-V`SOQS-+JV;WSA
XMA(LB!I:4J`CIPC_0KD$@MG<5?<X==0ST^64$OJ%N_I8V?*-$F!K1!"I(.7Z0
XM^)U`(E;>)4Z*>"^-BOY][_7,.!@^V7:J$MTFIC$7X/*@GN=%*]8BRPV@R@5<
XM-ON[BB_P)>^;\E?#[[?6[SZF)79:5D7(05PKW7E?ABDG(!U+C1>A_[M054;H
XM=,Z@$_)!&S7$B6JRPJ2,0\=TTG,[-8PC8D8YLFQ`G]@R)BJ!<$,,^JK?-`^7
XMY[K`-\GR_<M*N#Y%E8=E=:"][*OJ6Z42A'!IUY,*71*@O8R50A'7\8N9^'D9
XM)1K,#(F*0-;4MT"ZJ@K+I_1BO:+#F7(01:D@8!P1D!KW:*K^Z59QY%B"A"C6
XM%BP#--D)N22AX%$'$[Y.S1V]=O2P#(BU%/B<R]_9^"@6&@17V&@U;NQD,;52
XMJ]EB'-_<`O2EW)"\S,GUQ:77>$(8@?.[IB%[B7D@?BHV#^,,@451>*>]+/#8
XM)2>-$&FVS9/395'EU?`9JX:8R]O#/?5@)>8`L!+:0+4+<RGY/FH7U..VG4;C
XM3\XGRK`9W2Q/64*N68EO%Y>FNX_+-"I<<UN&?&%]>OXMLO-W-?6;6JLF$OH1
XM`2)!Y+FMUX(;9M[RH*4%H10/WV%"H@JN,7=\@GKK>,WA<C50!7?AAG4'C"'R
XM'>H*EVZ(E>PRV.XEFLC\;24,:94*>:RH6W,>M@7O0/?B!"-,XVL<+`_0P-])
XMK8],F&4_28KHLSK[G-R<UMAJ"*VK_]Y_$A/B,NH"HXFHL#LW?=9*PN&-:Y%:
XM-_:AR5H#$!O$3O':5HI"*[^E9GUP#ASP:NAEI`M-))*GN;>/MKCG$P#8*SHV
XM":#UO,2A*3WTB#!M];:$'(=W[-@)I.?^Y#EIWX<PT_.U7G.<+?S??*$"T#).
XM/:S<A26`O'R2/55<P"5'AGY^AAN6@=A+E<3KNC\^>DTR(F1&'W3J4`<!C2F]
XM?/8OKC&]6RDN_<I:7(ES[=?5.0MX7@X(C;V(_ZC`FJ7_V#],S-<=L5.=_<,G
XM6.?FS=[KJM5^C,UY1B`Q@L'3B/Q,@/-4'F-R#0K*D/<,\O,UI1K<7*$O>?^3
XM4VG[!%03VD&67HI+/D6O$.P4.D-EAG#6X5S@CP&#VL\#(7+27EZI#[7G(\.:
XM76Y6P@R(5?`E![59=9N!V$FN&UG'F2WB]L%[+@KZIP?S2K-Y9_/(`I-'X_AP
XMKEO!F5X67G('3Y&7/_#(+E.5_U)X8G$F(UW<"L3_B(!N96+L#YQ!3DA(\>*=
XMZ^],*JNP/6/M`GU0W_70H/`U6<^?,J+].2L,O\_J!'&2^GH4K?UZA3J`#M2$
XM`5Z;RH4*,&)A43V^W"45YH>+SNW>*$I5FN'<KA]I_9A1LYS#\K))JD@G.^25
XM)54;O9/2!%&>Z7M%(F_`L*3.&'GQCMEZ5F2G,W,"G,-M)\A!F_FQ17<`ACG,
XM6H+D#!G')T."MNAZ;?`O+#A^1:'R8%:3F;=EU7RDE_;:DJ9?R^:APG(^)\#'
X-(N4Q%/ZJ3<H;&8DX%_`O
X`
Xend
END_OF_FILE
if test 5435 -ne `wc -c <'prog/F1.uu'`; then
    echo shar: \"'prog/F1.uu'\" unpacked with wrong size!
fi
# end of 'prog/F1.uu'
fi
if test -f 'prog/F2.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prog/F2.uu'\"
else
echo shar: Extracting \"'prog/F2.uu'\" \(5753 characters\)
sed "s/^X//" >'prog/F2.uu' <<'END_OF_FILE'
Xbegin 644 F2
XMI\_XC8WG-:401R`BLD6G?O`W<;\LG@IR`9/`Z`U<>[-WC*D>'."<4,*P/QL>
XM"EZK\''E`#,)#?'$Q?(>1)9J#+E,(B67C8*O?E:]]7OA>0OP+)TA?KQL@JNL
XMF0+8GJ36D3WS&C6W516JS9#]E(!QD@X^7/O9H4?"2L'#8C$=?^\"8Z+$.:S,
XM!PE_]7&X-5FH=%+.U//`14`E>2!GYW;;R>/BGDE`C<99W!L78`P6?4>\Q51O
XM4S^#?X(-_UVL92[`N\1MPW#OR24BVXTC$;#\D6`CL64-99B3;;8XDZKO",OG
XMS.3"(D,=RF2'N;IPAM=A<SQ#V`1J6?P6I@+-ZHQ#-N2"BTM&UW3X$?G2O1]L
XM9+5&V%PSFFOXNWNPE)%4L)=4SC:.,1,R!Y<+`ASEC#_[)I><N)PO.9:KJ#<T
XM\4M3\A$`=J/RKN3"2TP*#5)Q4X2NNL_;\RO;F[3MNE8S()$]A:I07/E#]O-6
XMZ0/LT9SWK1?AMR-'/JI<,U"K7KI="<P2<9GA^JUS$E\6!/XWKRB%D&>TYQQ"
XM0_YJ[D0R%.7TLQ'G.#D!)[ONH9#`DL@\U<#1OVU4-`YZ]^(:-P**7[HL,U3V
XMM`T408-7#Y8"X8"WOEDWK%035\!0)0,Z0H%4UK!;;C$@M@%U!?CV'O*<9390
XM*T5..%Z^GR*QF!!+.MJ5'7^6!'>"(*$YH9;C#7WDE$]"XF$Y$ADRK@<KN=3J
XMDI5$C&4/0G,[Z)]]%OU`OU56K7%JR^R_(6:N8AFT24OGVZZR^?,A3`P-'=*Z
XMG"T[*%4:+EH;L1J+2[$V_'JW8\Q<`'.UMA1L+KF'T<9J6@#\61[7RYPI>*6Q
XMB<NO%?9DD'I5_)<R0'X73AUH1Q,.DY-MXC/X.-EJ/C7&ZDO-`'HXVCY<4S!"
XM>XQ%*W3J%=8O,61'7TT(6D,YD8IG:ZA$N$KW&.2\(#='(2#>-Y2D]?-$Y&*K
XM+$[.31?M?O:JP1-K2XZML+R3:`CYO?V"3\SFU-+_YV]Q-V#N%IU11@O[4L(G
XM2VQ!08VV.L8T,ZSX^:I3(R*\-(EVUO+'+[%@"O@2K]K:]56EEIF"]_S4`D6Z
XMES?VYA&'E#,\RH?DRE$,!@DDV'^\?#KN@GSHFHL%TC6M6:6;!)8G/57_4)P;
XMZZO?Q8#6F^QJ&8`G^">XO(V%"I!5F)%_47@;YG#35U#>$63X"&/\G/Y"C"S#
XM.+"EB'F]@^C%;5T-S`^^,Z$XW$.1Q&%#/MYSJ2:;7,G:MF9=T;*&Y[K^C7;+
XMZ^/IYCUNO/0#V$N^X1C*6YR':D^[=FR0LR*C]/G.ZRE+TW;O>`8$X%*7NV?2
XM7:)KKRC!E+(YB[);\A60,G6?!&Q3[[5\`5,*6Q&!?-+B7V&/BNN%.=<UC*0[
XM6C+<;B_>KDMLC0[=3\X3CANFD3QN8"IXD#(O%I1L^)IL,Y^O'6<OR_E[9$VN
XMLWU<\8P.6]D1W]7HJ*T(EKQEDH'>>!)>14=T\L-Y[D0T49SKOU.E);+N:I+#
XM5IE=!:KV=7E/4K].\DD,(7#_4GU9U_@ERJC"7QX+CD2R6GH]PL:Z("&P@\4=
XMKPP45Q<;Z!+;SA*Q]:YJYR&D$WHB7=VBR/?)^8E@3V%3W(`7SS)7BRT##ZUR
XMG;6(:M%#_E-1$Z=(^7"IU+[3KU:['UE1M&E1E2`1^H#O99'*DWB(</A:9D]F
XM[F%>E3,]:N/$Z&6V>6Y$C*_@!$`VU+ZS('AAFDUI;$\4C=)85:F`(<TR?H?D
XM0U+4[,2-G`A]`Y:)?<DB4)JP/(MU6RH9-,MQY??(<E;*L\ZYN*FB`^QRE^7-
XM4<#W0EX:WB3QA^@YB7J.[6#&C+*!WUM*/F!`6+S#!BM*#8O)+ETEX:LY:;GN
XM\.UW0.FH<^#_X,@]_M+TKYCJ.A??2;7C2\>G)=I2FV@!;",,M4)CI8L%C%)!
XME%EP<IVX8WZ8M81T=TKW\%9>!2ZM*#^GM5R[<%I7F2`D<RW&H55(45%E2B\W
XM\A21#;F`8!SB@54V7#;HO+Y?2<\WOVO_^M0G@%*=++5Q779//7MIY`=T*MO#
XMK=;5L8Z!<P"SXP.7,9Z9AKMI_>:Q80U++5!?\[ZOVTN3-`LAN2N\'V99;^H)
XMRN\PP6TAFUR5\A82(V?[<-Q.UZ=_0+68IIPB'RZR.)E^-?S=L4`I]P>U66L"
XM;KA/V43W[UQ+"^>K[%^Z=4*F*1,H4(=!*9V?V2<6_,5[02UJ$^OC8J$S2$2U
XMD.\9+F#C)!K_IJ$202[8S#X_?,&P%M%?&<R#4OSI;..XEX+=LJZ;9K*:YJT3
XMR*PI1/S1='+L""TS<XSXB@ALH\Z@W?Y&OH\5C8)<P(AY5!"(U&D<IV*ZM2S_
XMI]8#B/+G-J%W#:T`LOQM-%;Z%&/??VO:'0V2GL/XAT4MM4(>00I)PIO3L4V,
XM#QG`^E<02'D!]M-]>V=O=O><].G4([\PQ-E22CH(1KT++OG]G5)824$>%0'1
XMX0Q4=`C&E1$_5T=@TOK^XZMU7U.#5KP/(L>C:VJ,MG-'6MBB*OW$+]JP6K'W
XM'Q_[Q?$S:[M81CJ*YPF:!KL^(T0@2R'`]?E!OA.D>:1<"/RK'[X5TY2DD6%M
XM)[Y6"A?=P_-V0=K%8)Z_-2I/K%Z@1,1&:^%;9RXUC(4M1#)FGBKL+,2QK"AU
XM<Q272G2M(%!"?2B`^5:6:U19<>HO.-G77RM^'[=\W5ZG&K,67&6#PBTTY2@6
XM(M_X8EYK\G[>F&W8B8O6MB0721A.PQ+3IZJEP,?V<N=E&+A[USKOJ`Y;JD",
XMT9FI9-NE_'TD/@1GA(*HN`:HO+^O4#I^W<SZK"\L5X9+;%<@@<W/5W8I.N$H
XM%W+X4X\UB*)[!1EQ@0W23OO>KQT37COQ%_$!A(6HMKHV`U3P`EB\D4C60XGB
XMK%5(_>T[:47Q[%>K.QPMW-Y_YY9#@38<T1BJ1$[UT2MH3,*:='3:!V"KKC"-
XMY:Y,KO07PYR/0Z@E[2TE&@1A1V?I_$FMHY1^>^ZZ3_:0*F<[.N*RN<AII::&
XM\0_H#X&GEC$\1S3/B9[442:M$/<5V)FMV3?X9[BD(M:8O;CNKH?6?<@QGRX7
XM6A54X2T5O2[6?8G=+'B6"-`C2]VBW8V%>?6WF$'R%']YXEW!U/BI9K'R_2Q?
XM.;@=F`X;$*(S#A5NBWT;]1*^_N01^#*]"BZV))&H<:A@3,FU-?;)O)EEV,4H
XM`@1EXWXWP>]Q1"WQ_U7OQ9X]DG46'<]2:3<"6E3=*4G,N:QPL+"4^H&Y#O1T
XM+50%;Q/X;4'C^+?J%.Z:WZ%CV`=DQ3(@:'9CQDA@UM*>"O%+W)\E`TJQNB`&
XMK@EVE0._CWAK3F9G@,RMQB\6GPEYDX3!@CK'U(E'86Z<-Y^Y>`X'R_Z_4\":
XMCJ;XNT114`+$"')?.W(6._PY<,$<PFQZ7^`)"XLC\)C7^[BJ6X1Z(>;1,*"4
XM:K`"J/L:)C+[M9?5XZ@1<:9+LZ4I11"H@$X8/&MP"JYCJSD>),D/^)ND$YZ5
XMF.E)1:.M<X_+=38E]($YL&2?HT.H3)!B"@ELY]\,CY`5==%K/$Y[3)NEF8O&
XM$*HZ%13*^R@J/H15]NT3+GE*]580D3B@M2Y973_^)"_;YJ2R'P!Q;=J*W8&.
XM@`@X`CA`QHY!KT=FP],@+(G=YDHJZ_7.DJ;;C;WS5`,LFOE-'$)2U2-5[07A
XM=X%YHK5)I6*EDG1AOV*:VI@:R[LM]V4NBBI3C7]!^OJB`[A96Y-7!G#V&6UY
XM'P.^)V)!.O[Q7V/><4$TD8X7C,=:-*2`D3(R+/(AP1=VIV00RR)+WIG/HAKN
XMD:5D=JFU]&.X6TA5!!2E,Y\:^D1]CX.&!&'*/(\ON(?N26$NNR%-65L:C^VW
XMR0P,AK?<O29JC8^SBDMX?\*'=B_<W?):VG`%1;=X0J4.W:W5O&Z]!4M!>+,^
XM_UGW#7]SN6."_VH<7B=LT%E1H(QXR,5"TY_NN_PDH.X#=LT7AM7;D*%01F?W
XM:AEBWLJ;4,H`R7AEA\E1.NF!+Z<#K5R-3)M96&&"E=7VS@1+G;YG_>H.][S#
XM^)1)GS-A""H"F<AL#`<;;UA&MZU?1`Q)0UE<[\=[^)_"N,D1VV2T4YN92?I:
XM"C>=;M*>.KLX1-ODY.+(1<)OYD8$A0I6`84_Y83[\#V#X%P_MOY,&7@MD9>Y
XM2?DMS$%[6,]H'H*:Q"2G6ILAG(IX03.HP^$-+0:3%WBZ(@3QPF_4^7=6<)MA
XM521YPP6OI.,V@B`M%V.>B!.0_L+)'1_5&QPM,AT@1O&:J<[ZZ=</N^LA?<8C
XM\86Y$"SN,)S2@0GY5!X`Q9LJB:JPJ8/^IU3G9(.K54*;]RE)@R,HQ!F[K(;@
XMZAZ4Q#1S!H+P>/IV)2&Q!0KRF@FR>P%N2FM9?D&[!@!X57"=:52EX1(8\9@!
XM*`W6EJW,:ZED/+^I4OSD&!`R7C:55#I.O=%_DF?+?%I`8J71FPEY94M^-%<7
XM*^#7^KV-W,Q&O&I^RZKT@?R>+@J5A&-@C0K1">XI=C9P(`%;=2PJ=-Q?QU1U
XM9S4S\NQ>O'A'OIX3N=X.EJ^+TC!27K"1,N6@_(QI=,]ZR2*WTJ6&,[`HBR->
XM!<B8[`18!P?1]K!PM/0X-M(!5-I-V4Z&MM(8D`A_;Q/:7SC^/S>]MKJ.XEBV
XMU=2Y+=UOLU!DI+O@0R7/`&T3[#R[NT3H:<261'3/07`=`_U-DB#!S+0+3M"\
XM6UP[GN_8*,T-MCF2+T7GK32H$SH7.?L,K'#YU^@-2/X/H+*.!5D3;4!X(OS!
XMT'D4#68M\X^U,3LB_UDH:-=Y9)<70IP+1.XFX$FI],!M>]/_S'ES)$F=3&E#
XMAA<JXVU-A;F>3W\&70/$K.C?`.:L[JY4Y'10+?A1E]UX/M3%O<=+GK5GDT?4
XM3J"7_:#"@T`XU-\@>ET5_E?S!A??=?-[A3]OOV6&!55$/=9/CEC)6%.H;2'5
XMZ`P:P6LQWI^9?9TI#7>TW1D$JW_H2E[&HZ)(9!YM>=JD&"Q$R@#\&IJK`12U
XMYG11'8T#"C/WN-QV$,W()F#8.?K.YKNS:EZ^\NZ7HT`/(S^'#/?:1H*'GVNB
XMLE_,(F)OCHRPWTJ-RMWAP*9&EZMM#,#[W9I\4>F:@([1H?H8]0@G"2\[O`'Y
XM<C3!_!MXH4OW=@"T1X)D`^;\]YZUE:>#YI&9T28NR$Z(2GY4",`>V*AO#RX5
XM::F_!+4Y9UI?OE,#B@NHU8M(Y2)U*",LIPO<#EP)G_^\6ZKI'S,6I*KM9WU_
XM<NK)*UH?/0TA5!=8&+:=]L#>V-GP2*I_9BZ16X'`VLH;6Y??HEL0G29&D,'V
XM5&MGCK8^;R5U(M,F7=LO5XV8K[ZP+@C>4BO+&HN<O+0W,KBN()U@[H?Y%]^M
XMLNL.G5OA#NV[V??KP!Q3$;.8*ALU6#B)E!6GK(3>(JW3MKYG"FT)"DR=96/Y
XMOWBE"C*/XI*@$->\T7S2_[)X!K^10\^L8.6)PQ&O/P3YP"'.%.):H0:#PJ/F
XM+'I"]A9@1]AGK7+U(!Y>\864WK?W?_61*WTMXLVU*Q*^2*V`(,&R/T6:8)2?
X4G+.!M./9(@L7$^=GQ;(O9T92E][W
X`
Xend
END_OF_FILE
if test 5753 -ne `wc -c <'prog/F2.uu'`; then
    echo shar: \"'prog/F2.uu'\" unpacked with wrong size!
fi
# end of 'prog/F2.uu'
fi
if test ! -d 'tables' ; then
    echo shar: Creating directory \"'tables'\"
    mkdir 'tables'
fi
if test -f 'tables/IP' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tables/IP'\"
else
echo shar: Extracting \"'tables/IP'\" \(392 characters\)
sed "s/^X//" >'tables/IP' <<'END_OF_FILE'
X    58    50    42    34    26    18    10     2
X    60    52    44    36    28    20    12     4
X    62    54    46    38    30    22    14     6
X    64    56    48    40    32    24    16     8
X    57    49    41    33    25    17     9     1
X    59    51    43    35    27    19    11     3
X    61    53    45    37    29    21    13     5
X    63    55    47    39    31    23    15     7
END_OF_FILE
if test 392 -ne `wc -c <'tables/IP'`; then
    echo shar: \"'tables/IP'\" unpacked with wrong size!
fi
# end of 'tables/IP'
fi
if test -f 'tables/IP-1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tables/IP-1'\"
else
echo shar: Extracting \"'tables/IP-1'\" \(392 characters\)
sed "s/^X//" >'tables/IP-1' <<'END_OF_FILE'
X    40     8    48    16    56    24    64    32
X    39     7    47    15    55    23    63    31
X    38     6    46    14    54    22    62    30
X    37     5    45    13    53    21    61    29
X    36     4    44    12    52    20    60    28
X    35     3    43    11    51    19    59    27
X    34     2    42    10    50    18    58    26
X    33     1    41     9    49    17    57    25
END_OF_FILE
if test 392 -ne `wc -c <'tables/IP-1'`; then
    echo shar: \"'tables/IP-1'\" unpacked with wrong size!
fi
# end of 'tables/IP-1'
fi
if test -f 'tables/E' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tables/E'\"
else
echo shar: Extracting \"'tables/E'\" \(296 characters\)
sed "s/^X//" >'tables/E' <<'END_OF_FILE'
X    32     1     2     3     4     5
X     4     5     6     7     8     9
X     8     9    10    11    12    13
X    12    13    14    15    16    17
X    16    17    18    19    20    21
X    20    21    22    23    24    25
X    24    25    26    27    28    29
X    28    29    30    31    32     1
END_OF_FILE
if test 296 -ne `wc -c <'tables/E'`; then
    echo shar: \"'tables/E'\" unpacked with wrong size!
fi
# end of 'tables/E'
fi
if test -f 'tables/S' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tables/S'\"
else
echo shar: Extracting \"'tables/S'\" \(1536 characters\)
sed "s/^X//" >'tables/S' <<'END_OF_FILE'
X14  4 13  1  2 15 11  8  3 10  6 12  5  9  0  7
X 0 15  7  4 14  2 13  1 10  6 12 11  9  5  3  8
X 4  1 14  8 13  6  2 11 15 12  9  7  3 10  5  0
X15 12  8  2  4  9  1  7  5 11  3 14 10  0  6 13
X15  1  8 14  6 11  3  4  9  7  2 13 12  0  5 10
X 3 13  4  7 15  2  8 14 12  0  1 10  6  9 11  5
X 0 14  7 11 10  4 13  1  5  8 12  6  9  3  2 15
X13  8 10  1  3 15  4  2 11  6  7 12  0  5 14  9
X10  0  9 14  6  3 15  5  1 13 12  7 11  4  2  8
X13  7  0  9  3  4  6 10  2  8  5 14 12 11 15  1
X13  6  4  9  8 15  3  0 11  1  2 12  5 10 14  7
X 1 10 13  0  6  9  8  7  4 15 14  3 11  5  2 12
X 7 13 14  3  0  6  9 10  1  2  8  5 11 12  4 15
X13  8 11  5  6 15  0  3  4  7  2 12  1 10 14  9
X10  6  9  0 12 11  7 13 15  1  3 14  5  2  8  4
X 3 15  0  6 10  1 13  8  9  4  5 11 12  7  2 14
X 2 12  4  1  7 10 11  6  8  5  3 15 13  0 14  9
X14 11  2 12  4  7 13  1  5  0 15 10  3  9  8  6
X 4  2  1 11 10 13  7  8 15  9 12  5  6  3  0 14
X11  8 12  7  1 14  2 13  6 15  0  9 10  4  5  3
X12  1 10 15  9  2  6  8  0 13  3  4 14  7  5 11
X10 15  4  2  7 12  9  5  6  1 13 14  0 11  3  8
X 9 14 15  5  2  8 12  3  7  0  4 10  1 13 11  6
X 4  3  2 12  9  5 15 10 11 14  1  7  6  0  8 13
X 4 11  2 14 15  0  8 13  3 12  9  7  5 10  6  1
X13  0 11  7  4  9  1 10 14  3  5 12  2 15  8  6
X 1  4 11 13 12  3  7 14 10 15  6  8  0  5  9  2
X 6 11 13  8  1  4 10  7  9  5  0 15 14  2  3 12
X13  2  8  4  6 15 11  1 10  9  3 14  5  0 12  7
X 1 15 13  8 10  3  7  4 12  5  6 11  0 14  9  2
X 7 11  4  1  9 12 14  2  0  6 10 13 15  3  5  8
X 2  1 14  7  4 10  8 13 15 12  9  0  3  5  6 11
END_OF_FILE
if test 1536 -ne `wc -c <'tables/S'`; then
    echo shar: \"'tables/S'\" unpacked with wrong size!
fi
# end of 'tables/S'
fi
if test -f 'tables/GNUmakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tables/GNUmakefile'\"
else
echo shar: Extracting \"'tables/GNUmakefile'\" \(323 characters\)
sed "s/^X//" >'tables/GNUmakefile' <<'END_OF_FILE'
XLMAINTOPS=	all clean
XRPAR=)
XLPAR=(
XSOURCES=	$(wildcard *.make)
XHS=	$(addprefix ../lib/,$(addsuffix .h,$(basename $(SOURCES))))
XPRINTFILES:=	mk-ip $(SOURCES)
X
Xall-local:	$(HS)
X.PHONY:	all-local
X
Xinclude Makerules
X
Xclean-local:
X	echo "These files can be removed: $(HS)"
X	echo $(HS) > REMOVABLE
X
X../lib/%.h:	%.make
X	./$^ > $@
END_OF_FILE
if test 323 -ne `wc -c <'tables/GNUmakefile'`; then
    echo shar: \"'tables/GNUmakefile'\" unpacked with wrong size!
fi
# end of 'tables/GNUmakefile'
fi
if test -f 'tables/REMOVABLE' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tables/REMOVABLE'\"
else
echo shar: Extracting \"'tables/REMOVABLE'\" \(58 characters\)
sed "s/^X//" >'tables/REMOVABLE' <<'END_OF_FILE'
X../lib/spe-table.h ../lib/eight.h ../lib/ip.h ../lib/fp.h
END_OF_FILE
if test 58 -ne `wc -c <'tables/REMOVABLE'`; then
    echo shar: \"'tables/REMOVABLE'\" unpacked with wrong size!
fi
# end of 'tables/REMOVABLE'
fi
if test -f 'tables/fp.make' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tables/fp.make'\"
else
echo shar: Extracting \"'tables/fp.make'\" \(26 characters\)
sed "s/^X//" >'tables/fp.make' <<'END_OF_FILE'
X#! /bin/sh
X./mk-ip < IP-1
END_OF_FILE
if test 26 -ne `wc -c <'tables/fp.make'`; then
    echo shar: \"'tables/fp.make'\" unpacked with wrong size!
fi
chmod +x 'tables/fp.make'
# end of 'tables/fp.make'
fi
if test -f 'tables/P' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tables/P'\"
else
echo shar: Extracting \"'tables/P'\" \(264 characters\)
sed "s/^X//" >'tables/P' <<'END_OF_FILE'
X      16       7      20      21
X      29      12      28      17
X       1      15      23      26
X       5      18      31      10
X       2       8      24      14
X      32      27       3       9
X      19      13      30       6
X      22      11       4      25
END_OF_FILE
if test 264 -ne `wc -c <'tables/P'`; then
    echo shar: \"'tables/P'\" unpacked with wrong size!
fi
# end of 'tables/P'
fi
if test -f 'tables/mk-ip' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tables/mk-ip'\"
else
echo shar: Extracting \"'tables/mk-ip'\" \(494 characters\)
sed "s/^X//" >'tables/mk-ip' <<'END_OF_FILE'
X#!/usr/bin/perl
X
X# This makes inline-code for initial and final permutations.
X
X$i = 0;
Xwhile (<>) {
X    @a = split(" ",$_);
X    while ($x = shift(@a)) {
X	$T[$i] = $x - 1;
X	$i++;
X    }
X}
X
Xfor($i = 0; $i < 64; $i++) {
X    $ibit = $T[$i];
X    $Iname = ($ibit >= 32) ? "R" : "L";
X    $Oname = ($i >= 32) ? "R_result" : "L_result";
X    printf "if (%s & 0x%08x) %s |= 0x%08x;\n"
X      ,$Iname,1<<($ibit%32),$Oname,1<<($i%32);
X}
X
X# Local variables:
X# mode: c
X# tab-width: 8
X# c-indent-level: 4
X# end:
END_OF_FILE
if test 494 -ne `wc -c <'tables/mk-ip'`; then
    echo shar: \"'tables/mk-ip'\" unpacked with wrong size!
fi
chmod +x 'tables/mk-ip'
# end of 'tables/mk-ip'
fi
if test -f 'tables/ip.make' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tables/ip.make'\"
else
echo shar: Extracting \"'tables/ip.make'\" \(24 characters\)
sed "s/^X//" >'tables/ip.make' <<'END_OF_FILE'
X#! /bin/sh
X./mk-ip < IP
END_OF_FILE
if test 24 -ne `wc -c <'tables/ip.make'`; then
    echo shar: \"'tables/ip.make'\" unpacked with wrong size!
fi
chmod +x 'tables/ip.make'
# end of 'tables/ip.make'
fi
if test -f 'tables/eight.make' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tables/eight.make'\"
else
echo shar: Extracting \"'tables/eight.make'\" \(318 characters\)
sed "s/^X//" >'tables/eight.make' <<'END_OF_FILE'
X#!/usr/bin/perl
X
X# This makes a $nb-bit bit-reverse-table
X
X$nb = 8;
X$upper = (1 << $nb);
X
Xfor($i = 0; $i < $upper; $i++) {
X    $k = 0;
X    for($j = 0; $j < $nb; $j++) {
X	$k |= (($i >> $j) & 01) << ($nb - 1 - $j);
X    }
X    printf "%04o,\n",$k;
X}
X
X# Local variables:
X# mode: c
X# tab-width: 8
X# c-indent-level: 4
X# end:
END_OF_FILE
if test 318 -ne `wc -c <'tables/eight.make'`; then
    echo shar: \"'tables/eight.make'\" unpacked with wrong size!
fi
chmod +x 'tables/eight.make'
# end of 'tables/eight.make'
fi
if test -f 'tables/Makerules' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tables/Makerules'\"
else
echo shar: Extracting \"'tables/Makerules'\" \(560 characters\)
sed "s/^X//" >'tables/Makerules' <<'END_OF_FILE'
XCC:=		gcc
XCFLAGS:=	-O #SUN -msoft-float
XPRINT:=		enscript
X
XMAINTOPS:=	all clean print s-files
X.PHONY:		$(MAINTOPS)
X
Xifdef PRINTFILES
Xprint:
X	$(PRINT) $(PRINTFILES)
Xendif
X
Xifdef LMAINTOPS
X$(LMAINTOPS):	%:	%-local
X
X.PHONY:		$(addsuffix -local,$(LMAINTOPS))
Xendif
X
Xifneq ($(origin SUBDIRS),file)
XSUBDIRS:=
Xendif
X
Xifdef SUBDIRS
X$(MAINTOPS):
X	for i in $(SUBDIRS); do $(MAKE) -C $$i $@; done
Xelse
X$(MAINTOPS):
Xendif
X
Xifdef SUBDIRS
X$(SUBDIRS):
X	$(MAKE) -C $@
Xendif
X
Xifneq ($(origin S_FILES),file)
XS_FILES:=
Xendif
X
Xs-files:	$(S_FILES)
X
X%.s:	%.c
X	$(CC) -S $(CFLAGS) $^
END_OF_FILE
if test 560 -ne `wc -c <'tables/Makerules'`; then
    echo shar: \"'tables/Makerules'\" unpacked with wrong size!
fi
# end of 'tables/Makerules'
fi
if test -f 'tables/spe-table.make' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tables/spe-table.make'\"
else
echo shar: Extracting \"'tables/spe-table.make'\" \(1678 characters\)
sed "s/^X//" >'tables/spe-table.make' <<'END_OF_FILE'
X#!/usr/bin/perl
X# This makes combined S-box --> P-permutation --> E-permutation tables
X# for each six-bit input data for each S-box.
X#$| = 1;
Xfor($i = 0; $i < 16; $i++) {
X    $reverse4[$i] = ((($i & 0x08) >> 3) |
X		    (($i & 0x04) >> 1) |
X		    (($i & 0x02) << 1) |
X		    (($i & 0x01) << 3));
X}
X
X$j = 0;
Xdie "Cannot open S" until open(f,"S");
Xwhile (<f>) {
X    @a = split(" ",$_);
X    for($i = 0; $i < 16; $i++) {
X	$x = shift(@a);
X	$S[$j] = $x;
X	$j++;
X    }
X}
X
X$j = 0;
Xdie "Cannot open P" until open(f,"P");
Xwhile (<f>) {
X    @a = split(" ",$_);
X    for($i = 0; $i < 4; $i++) {
X	$x = shift(@a);
X	$P[$j] = $x;
X	$j++;
X    }
X}
X
X$j = 0;
Xdie "Cannot open E" until open(f,"E");
Xwhile (<f>) {
X    @a = split(" ",$_);
X    for($i = 0; $i < 6; $i++) {
X	$x = shift(@a);
X	$E[$j] = $x;
X	$j++;
X    }
X}
X
X$L[1024] = 0;
Xfor($snum = 0; $snum < 8; $snum++) {
X    for($i3 = 0; $i3 < 64; $i3++) {
X	$i2 = ((($i3 & 0x01) << 5) |
X	       (($i3 & 0x02) << 2) |
X	       (($i3 & 0x04)     ) |
X	       (($i3 & 0x08) >> 2) |
X	       (($i3 & 0x10) >> 4) |
X	       (($i3 & 0x20) >> 1));
X	$i2 = $S[64 * $snum + $i2];
X	$i2 = $reverse4[$i2];
X	for($i = 0; $i < 48; $i++) {
X	    $i4  = $P[$E[$i]-1]-1;
X	    if (int($i4/4) == $snum && (($i2 >> ($i4 % 4)) & 01)) {
X		$L[$snum * 128 + int($i / 24)*64 + $i3] |= (1 << ($i % 24));
X		$aa = $L[$snum * 128 + int($i / 24)*64 + $i3];
X	    }
X	}
X    }
X    $i0 = $snum*128; $i1 = $i0+128;
X    for($i = $i0; $i < $i1; $i++) {
X	$x = $L[$i];
X	$x = ((($x & 000000077)     ) |
X	      (($x & 000007700) << 2) |
X	      (($x & 000770000) << 4) |
X	      (($x & 077000000) << 6));
X	printf "0x%08x,\n",$x;
X    }
X}
X
X# Local variables:
X# mode: c
X# tab-width: 8
X# c-indent-level: 4
X# end:
END_OF_FILE
if test 1678 -ne `wc -c <'tables/spe-table.make'`; then
    echo shar: \"'tables/spe-table.make'\" unpacked with wrong size!
fi
chmod +x 'tables/spe-table.make'
# end of 'tables/spe-table.make'
fi
if test -f 'tables/ksched.dontmake' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tables/ksched.dontmake'\"
else
echo shar: Extracting \"'tables/ksched.dontmake'\" \(1056 characters\)
sed "s/^X//" >'tables/ksched.dontmake' <<'END_OF_FILE'
X#!/usr/bin/perl
X$| = 1;
X
X@PC1 = (
X	57,49,41,33,25,17, 9,
X	1,58,50,42,34,26,18,
X	10, 2,59,51,43,35,27,
X	19,11, 3,60,52,44,36,
X	63,55,47,39,31,23,15,
X	7,62,54,46,38,30,22,
X	14, 6,61,53,45,37,29,
X	21,13, 5,28,20,12, 4);
X
X@PC2 = (
X	14,17,11,24, 1, 5,
X	3,28,15, 6,21,10,
X	23,19,12, 4,26, 8,
X	16, 7,27,20,13, 2,
X	41,52,31,37,47,55,
X	30,40,51,45,33,48,
X	44,49,39,56,34,53,
X	46,42,50,36,29,32);
X
X@LS = (1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1);
Xfor($a = 0, $i = 0; $i < 16; $i++) {
X    $a += $LS[$i];
X    $LS[$i] = $a;
X}
X
Xfor($i = 0; $i < 16; $i++) {
X    printf "A0 = A1 = 0;\n";
X    for($j = 0; $j < 48; $j++) {
X	$m = $PC2[$j] - 1;
X	$side = int($m / 28);
X	$col = $m % 28;
X	$aside = int($j / 24);
X	$abit = $j % 24;
X	$abit = int($abit/6)*8 + ($abit%6);
X	$col = ($col + $LS[$i] + 28) % 28;
X	$kbit = $PC1[$col + $side*28] - 1;
X	$side = int($kbit/32);
X	$col = $kbit%32;
X	printf "if (I%d & 0x%08x) A%d |= 0x%08x;\n",$side,(1 << $col)
X	  ,$aside,1 << $abit;
X    }
X    printf "*kp++ = A0; *kp++ = A1;\n";
X}
X
X# Local variables:
X# mode: c
X# tab-width: 8
X# c-indent-level: 4
X# end:
END_OF_FILE
if test 1056 -ne `wc -c <'tables/ksched.dontmake'`; then
    echo shar: \"'tables/ksched.dontmake'\" unpacked with wrong size!
fi
chmod +x 'tables/ksched.dontmake'
# end of 'tables/ksched.dontmake'
fi
if test -f 'tables/shift4.dontmake' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tables/shift4.dontmake'\"
else
echo shar: Extracting \"'tables/shift4.dontmake'\" \(192 characters\)
sed "s/^X//" >'tables/shift4.dontmake' <<'END_OF_FILE'
X#!/usr/bin/perl
X
Xfor($i = 0; $i < 64; $i++) {
X    $x = ($i >> 1) & 0x0f;
X    printf "MAC(0x%02x,0x%02x),\n",$x,$x<<4;
X}
X
X# Local variables:
X# mode: c
X# tab-width: 8
X# c-indent-level: 4
X# end:
END_OF_FILE
if test 192 -ne `wc -c <'tables/shift4.dontmake'`; then
    echo shar: \"'tables/shift4.dontmake'\" unpacked with wrong size!
fi
chmod +x 'tables/shift4.dontmake'
# end of 'tables/shift4.dontmake'
fi
if test ! -d 'lib' ; then
    echo shar: Creating directory \"'lib'\"
    mkdir 'lib'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(2098 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X README                     1	
X VERSION                    1	
X COPYRIGHT                  1	
X GNUmakefile                1	
X Makefile                   1	
X Makerules                  1	
X sun.ed                     1	
X man                        1	
X man/des.1                  1	
X man/libdes.3               1	
X prog                       1	
X prog/Makerules             1	
X prog/des-certify.c         1	
X prog/des.c                 1	
X prog/testdata              1	
X prog/.gdbinit              1	
X prog/GNUmakefile           1	
X prog/Makefile              1	
X prog/F1.uu                 1	
X prog/F2.uu                 1	
X tables                     1	
X tables/IP                  1	
X tables/IP-1                1	
X tables/E                   1	
X tables/S                   1	
X tables/GNUmakefile         1	
X tables/REMOVABLE           1	
X tables/fp.make             1	
X tables/P                   1	
X tables/mk-ip               1	
X tables/ip.make             1	
X tables/eight.make          1	
X tables/Makerules           1	
X tables/spe-table.make      1	
X tables/ksched.dontmake     1	
X tables/shift4.dontmake     1	
X tables/Makefile            2	
X lib                        1	
X lib/spe-table.h            2	
X lib/eight.h                2	
X lib/ip.h                   2	
X lib/ksched.c               2	
X lib/des.h                  2	
X lib/fp.h                   2	
X lib/des-private.h          2	
X lib/des-data.c             2	
X lib/Makerules              2	
X lib/des-expand.c           2	
X lib/des-fun.c              2	
X lib/des-perms.c            2	
X lib/ecb-encrypt.c          2	
X lib/GNUmakefile            2	
X lib/cbc-encrypt.c          2	
X lib/cbc-cksum.c            2	
X lib/des-reverse.c          2	
X lib/pcbc-encrypt.c         2	
X lib/string-to-key.c        2	
X lib/des-hash.c             2	
X lib/alo-getpass.c          2	
X lib/alo-getline.c          2	
X lib/read-passwd.c          2	
X lib/des-hex.c              2	
X lib/Makefile               2	
X MANIFEST                   1	This shipping list
END_OF_FILE
if test 2098 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
echo shar: End of archive 1 \(of 2\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
