Subject:  v18i088:  Elm mail system, release 2.2, Part09/24
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: dsinc!syd@uunet.UU.NET (Syd Weinstein)
Posting-number: Volume 18, Issue 88
Archive-name: elm2.2/part09

#!/bin/sh
# this is part 9 of a multipart archive
# do not concatenate these parts, unpack them in order with /bin/sh
# file filter/rules.c continued
#
CurArch=9
if test ! -r s2_seq_.tmp
then echo "Please unpack part 1 first!"
     exit 1; fi
( read Scheck
  if test "$Scheck" != $CurArch
  then echo "Please unpack part $Scheck next!"
       exit 1;
  else exit 0; fi
) < s2_seq_.tmp || exit 1
echo "x - Continuing file filter/rules.c"
sed 's/^X//' << 'SHAR_EOF' >> filter/rules.c
X	  case LEAVE      : return("Leave"); 
X	  case EXEC       : return("Execute");
X	  default         : return("?action?");
X	}
X}
X
Xint
Xcompare(line, relop, arg)
Xint line, relop;
Xchar *arg;
X{
X	/** Given the actual number of lines in the message, the relop
X	    relation, and the number of lines in the rule, as a string (!),
X   	    return TRUE or FALSE according to which is correct.
X	**/
X
X	int rule_lines;
X
X	rule_lines = atoi(arg);
X
X	switch (relop) {
X	  case LE: return(line <= rule_lines);
X	  case LT: return(line <  rule_lines);
X	  case GE: return(line >= rule_lines);
X	  case GT: return(line >  rule_lines);
X	  case NE: return(line != rule_lines);
X	  case EQ: return(line == rule_lines);
X	}
X	return(-1);
X}
X
Xchar *listrule(rule)
Xchar *rule;
X{
X	/** simply translates all underscores into spaces again on the
X	    way past... **/
X
X	static char buffer[SLEN];
X	register int i;
X
X	for (i=0; i < strlen(rule); i++)
X	  buffer[i] = (rule[i] == '_' ? ' ' : rule[i]);
X	buffer[i] = '\0';
X
X	return( (char *) buffer);
X}
SHAR_EOF
echo "File filter/rules.c is complete"
chmod 0444 filter/rules.c || echo "restore of filter/rules.c fails"
echo "x - extracting filter/summarize.c (Text)"
sed 's/^X//' << 'SHAR_EOF' > filter/summarize.c &&
X
Xstatic char rcsid[] ="@(#)$Id: summarize.c,v 2.4 89/03/25 21:45:19 syd Exp $";
X
X/*******************************************************************************
X *  The Elm Mail System  -  $Revision: 2.4 $   $State: Exp $
X *
X * 			Copyright (c) 1986, 1987 Dave Taylor
X * 			Copyright (c) 1988, 1989 USENET Community Trust
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Syd Weinstein - elm@dsinc.UUCP
X *			dsinc!elm
X *
X *******************************************************************************
X * $Log:	summarize.c,v $
X * Revision 2.4  89/03/25  21:45:19  syd
X * Initial 2.2 Release checkin
X * 
X *
X ******************************************************************************/
X
X/** This routine is called from the filter program (or can be called
X    directly with the correct arguments) and summarizes the users filterlog
X    file.  To be honest, there are two sorts of summaries that are
X    available - either the '.filterlog' file can be output (filter -S) 
X    or a summary by rule and times acted upon can be output (filter -s).
X    Either way, this program will delete the two associated files each
X    time ($HOME/.filterlog and $HOME/.filtersum) *if* the -c option is
X    used to the program (e.g. clear_logs is set to TRUE).
X
X**/
X
X#include <stdio.h>
X
X#include "defs.h"
X
X#include "filter.h"
X
Xshow_summary()
X{
X	/* Summarize usage of the program... */
X
X	FILE   *fd;				/* for output to temp file! */
X	char filename[SLEN],			/* name of the temp file    */
X	     buffer[SLEN];			/* input buffer space       */
X	int  erroneous_rules = 0,
X	     default_rules   = 0,
X	     messages_filtered = 0,		/* how many have we touched? */
X	     rule,
X	     applied[MAXRULES];
X
X	sprintf(filename, "%s/%s", home, filtersum);
X
X	if ((fd = fopen(filename, "r")) == NULL) {
X	  if (outfd != NULL)
X	    fprintf(outfd,"filter (%s): Can't open filtersum file %s!\n",
X
X		    username, filename);
X	  if (outfd != NULL) fclose(outfd);
X	  exit(1);
X	}
X
X	for (rule=0;rule < MAXRULES; rule++)
X	  applied[rule] = 0;			/* initialize it all! */
X
X	/** Next we need to read it all in, incrementing by which rule
X	    was used.  The format is simple - each line represents a 
X	    single application of a rule, or '-1' if the default action
X	    was taken.  Simple stuff, eh?  But oftentimes the best.  
X	**/
X
X	while (fgets(buffer, SLEN, fd) != NULL) {
X	  if ((rule = atoi(buffer)) > total_rules || rule < -1) {
X	    if (outfd != NULL)
X	      fprintf(outfd,
X      "filter (%s): Warning - rule #%d is invalid data for short summary!!\n",
X	            username, rule);
X	    erroneous_rules++;
X	  }
X	  else if (rule == -1)
X	    default_rules++;
X	  else
X	    applied[rule]++;
X	  messages_filtered++;
X	}
X	
X	fclose(fd);
X
X	/** now let's summarize the data... **/
X
X	if (outfd == NULL) return;		/* no reason to go further */
X
X	fprintf(outfd, 
X		"\n\t\t\tA Summary of Filter Activity\n");
X	fprintf(outfd, 
X		  "\t\t\t----------------------------\n\n");
X
X	fprintf(outfd,"A total of %d message%s %s filtered:\n\n",
X		messages_filtered, plural(messages_filtered),
X		messages_filtered > 1 ? "were" : "was");
X
X	if (erroneous_rules)
X	  fprintf(outfd, 
X	          "[Warning: %d erroneous rule%s logged and ignored!]\n\n",
X		   erroneous_rules, erroneous_rules > 1? "s were" : " was");
X	
X	if (default_rules) {
X	   fprintf(outfd,
X "The default rule of putting mail into your mailbox\n");
X	   fprintf(outfd, "\tapplied %d time%s (%d%%)\n\n",
X		   default_rules, plural(default_rules),
X		   (default_rules*100+(messages_filtered>>1))/messages_filtered
X	  	  );
X	}
X
X	 /** and now for each rule we used... **/
X
X	 for (rule = 0; rule < total_rules; rule++) {
X	   if (applied[rule]) {
X	      fprintf(outfd, "Rule #%d: ", rule+1);
X	      switch (rules[rule].action) {
X		  case LEAVE:	    fprintf(outfd, "(leave mail in mailbox)");
X				    break;
X		  case DELETE_MSG:  fprintf(outfd, "(delete message)");
X				    break;
X		  case SAVE  :      fprintf(outfd, "(save in \"%s\")",
X					    rules[rule].argument2);		break;
X		  case SAVECC:      fprintf(outfd, 
X					    "(left in mailbox and saved in \"%s\")",
X					    rules[rule].argument2);		break;
X		  case FORWARD:     fprintf(outfd, "(forwarded to \"%s\")",
X					    rules[rule].argument2);		break;
X		  case EXEC  :      fprintf(outfd, "(given to command \"%s\")",
X					    rules[rule].argument2);		break;
X	     }
X	     fprintf(outfd, "\n\tapplied %d time%s (%d%%)\n\n", 
X		     applied[rule], plural(applied[rule]),
X	            (applied[rule]*100+(messages_filtered>>1))/messages_filtered
X		    );
X	  }
X	}
X
X	if (long_summary) {
X
X	  /* next, after a ^L, include the actual log file... */
X
X	  sprintf(filename, "%s/%s", home, filterlog);
X
X	  if ((fd = fopen(filename, "r")) == NULL) {
X	    fprintf(outfd,"filter (%s): Can't open filterlog file %s!\n",
X		      username, filename);
X	  }
X	  else {
X	    fprintf(outfd, "\n\n\n%c\n\nExplicit log of each action;\n\n", 
X		    (char) 12);
X	    while (fgets(buffer, SLEN, fd) != NULL)
X	      fprintf(outfd, "%s", buffer);
X	    fprintf(outfd, "\n-----\n");
X	    fclose(fd);
X	  }
X	}
X
X	/* now remove the log files, please! */
X
X	if (clear_logs) {
X	  sprintf(filename, "%s/%s", home, filterlog);
X	  unlink(filename);
X	  sprintf(filename, "%s/%s", home, filtersum);
X	  unlink(filename);
X	}
X
X	return;
X}
SHAR_EOF
chmod 0444 filter/summarize.c || echo "restore of filter/summarize.c fails"
echo "x - extracting filter/utils.c (Text)"
sed 's/^X//' << 'SHAR_EOF' > filter/utils.c &&
X
Xstatic char rcsid[] ="@(#)$Id: utils.c,v 2.5 89/03/25 21:45:20 syd Exp $";
X
X/*******************************************************************************
X *  The Elm Mail System  -  $Revision: 2.5 $   $State: Exp $
X *
X * 			Copyright (c) 1986, 1987 Dave Taylor
X * 			Copyright (c) 1988, 1989 USENET Community Trust
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Syd Weinstein - elm@dsinc.UUCP
X *			dsinc!elm
X *
X *******************************************************************************
X * $Log:	utils.c,v $
X * Revision 2.5  89/03/25  21:45:20  syd
X * Initial 2.2 Release checkin
X * 
X *
X ******************************************************************************/
X
X/** Utility routines for the filter program...
X
X**/
X
X#include <stdio.h>
X#include <pwd.h>
X#include <ctype.h>
X#include <fcntl.h>
X
X#include "defs.h"
X#include "filter.h"
X
Xleave(reason)
Xchar *reason;
X{
X	if (outfd != NULL)
X	  fprintf(outfd,"filter (%s): LEAVE %s\n", username, reason);
X	if (outfd != NULL) fclose(outfd);
X	exit(1);
X}
X
Xlog(what)
Xint what;
X{
X	/** make an entry in the log files for the specified entry **/
X
X	FILE *fd;
X	char filename[SLEN];
X
X	if (! show_only) {
X	  sprintf(filename, "%s/%s", home, filtersum);	/* log action once! */
X	  if ((fd = fopen(filename, "a")) == NULL) {
X	    if (outfd != NULL)
X	      fprintf(outfd, "filter (%s): Couldn't open log file %s\n", 
X		    filename);
X	    fd = stdout;
X	  }
X	  fprintf(fd, "%d\n", rule_choosen);
X	  fclose(fd);
X	}
X
X	sprintf(filename, "%s/%s", home, filterlog);
X
X	if (show_only)
X	  fd = stdout;
X	else if ((fd = fopen(filename, "a")) == NULL) {
X	  if (outfd != NULL)
X	    fprintf(outfd, "filter (%s): Couldn't open log file %s\n", 
X		  filename);
X	  fd = stdout;
X	}
X	
X	setvbuf(fd, NULL, _IOFBF, BUFSIZ);
X
X	if (strlen(from) + strlen(subject) > 60)
X	  fprintf(fd, "\nMail from %s\n\tabout %s\n", from, subject);
X	else
X	  fprintf(fd, "\nMail from %s about %s\n", from, subject);
X
X	if (rule_choosen != -1)
X	  if (rules[rule_choosen].condition->matchwhat == TO)
X	    fprintf(fd, "\t(addressed to %s)\n", to);
X
X	switch (what) {
X	  case DELETE_MSG : fprintf(fd, "\tDELETED");			break;
X	  case SAVE       : fprintf(fd, "\tSAVED in file \"%s\"", 
X				rules[rule_choosen].argument2);		break;
X	  case SAVECC     : fprintf(fd,"\tSAVED in file \"%s\" AND PUT in mailbox", 
X				rules[rule_choosen].argument2);  	break;
X	  case FORWARD    : fprintf(fd, "\tFORWARDED to \"%s\"", 
X				rules[rule_choosen].argument2);		break;
X	  case EXEC       : fprintf(fd, "\tEXECUTED \"%s\"",
X				rules[rule_choosen].argument2);		break;
X	  case LEAVE      : fprintf(fd, "\tPUT in mailbox");		break;
X	}
X
X	if (rule_choosen != -1)
X	  fprintf(fd, " by rule #%d\n", rule_choosen+1);
X	else
X	  fprintf(fd, ": the default action\n");
X
X	fflush(fd);
X	fclose(fd);
X}
X
Xint
Xcontains(string, pattern)
Xchar *string, *pattern;
X{
X	/** Returns TRUE iff pattern occurs IN IT'S ENTIRETY in buffer. **/ 
X
X	register int i = 0, j = 0;
X
X	while (string[i] != '\0') {
X	  while (tolower(string[i++]) == tolower(pattern[j++])) 
X	    if (pattern[j] == '\0') 
X	      return(TRUE);
X	  i = i - j + 1;
X	  j = 0;
X	}
X	return(FALSE);
X}
X
Xchar *itoa(i, two_digit)
Xint i, two_digit;
X{	
X	/** return 'i' as a null-terminated string.  If two-digit use that
X	    size field explicitly!  **/
X
X	static char value[10];
X	
X	if (two_digit)
X	  sprintf(value, "%02d", i);
X	else
X	  sprintf(value, "%d", i);
X
X	return( (char *) value);
X}
X
Xlowercase(string)
Xchar *string;
X{
X	/** translate string into all lower case **/
X
X	register int i;
X
X	for (i=0; i < strlen(string); i++)
X	  if (isupper(string[i]))
X	    string[i] = tolower(string[i]);
X}
SHAR_EOF
chmod 0444 filter/utils.c || echo "restore of filter/utils.c fails"
echo "x - extracting hdrs/curses.h (Text)"
sed 's/^X//' << 'SHAR_EOF' > hdrs/curses.h &&
X
X/* $Id: curses.h,v 2.4 89/03/25 21:45:22 syd Exp $ */
X
X/*******************************************************************************
X *  The Elm Mail System  -  $Revision: 2.4 $   $State: Exp $
X *
X * 			Copyright (c) 1986, 1987 Dave Taylor
X * 			Copyright (c) 1988, 1989 USENET Community Trust
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Syd Weinstein, Elm Coordinator
X *	elm@dsinc.UUCP			dsinc!elm
X *
X *******************************************************************************
X * $Log:	curses.h,v $
X * Revision 2.4  89/03/25  21:45:22  syd
X * Initial 2.2 Release checkin
X * 
X *
X ******************************************************************************/
X
X     /*** Include file for seperate compilation.  ***/
X
X#define OFF		0
X#define ON 		1
X
Xint  InitScreen(),      /* This must be called before anything else!! */
X
X     ClearScreen(), 	 CleartoEOLN(),
X
X     MoveCursor(),
X     CursorUp(),         CursorDown(), 
X     CursorLeft(),       CursorRight(), 
X
X     StartBold(),        EndBold(), 
X     StartUnderline(),   EndUnderline(), 
X     StartHalfbright(),  EndHalfbright(),
X     StartInverse(),     EndInverse(),
X	
X     transmit_functions(),
X
X     Raw(),              RawState(),
X     ReadCh();
X
Xchar *return_value_of();
SHAR_EOF
chmod 0444 hdrs/curses.h || echo "restore of hdrs/curses.h fails"
echo "x - extracting hdrs/defs.h (Text)"
sed 's/^X//' << 'SHAR_EOF' > hdrs/defs.h &&
X
X/* $Id: defs.h,v 2.16 89/03/25 21:45:23 syd Exp $ */
X
X/*******************************************************************************
X *  The Elm Mail System  -  $Revision: 2.16 $   $State: Exp $
X *
X * 			Copyright (c) 1986, 1987 Dave Taylor
X * 			Copyright (c) 1988, 1989 USENET Community Trust
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Syd Weinstein, Elm Coordinator
X *	elm@dsinc.UUCP			dsinc!elm
X *
X *******************************************************************************
X * $Log:	defs.h,v $
X * Revision 2.16  89/03/25  21:45:23  syd
X * Initial 2.2 Release checkin
X * 
X *
X ******************************************************************************/
X
X/**  define file for ELM mail system.  **/
X
X
X#include "../config.h"
X#include "sysdefs.h"	/* system/configurable defines */
X
X
X# define VERSION 		"2.2"	/* Version number... */
X
X# define WHAT_STRING	\
X	"@(#) Version 2.2, USENET supported version, March 1989"
X
X#define KLICK		25
X
X#define SLEN		256	    /* long for ensuring no overwrites... */
X#define SHORT		5	    /* super short strings!		  */
X#define NLEN		48	    /* name length for aliases            */
X#define WLEN		20
X#define STRING		128	/* reasonable string length for most..      */
X#define LONG_STRING	512	/* even longer string for group expansion   */
X#define VERY_LONG_STRING 2560	/* huge string for group alias expansion    */
X#define MAX_LINE_LEN	5120	/* even bigger string for "filter" prog..   */
X
X#define BREAK		'\0'  		/* default interrupt    */
X#define BACKSPACE	'\b'     	/* backspace character  */
X#define TAB		'\t'            /* tab character        */
X#define RETURN		'\r'     	/* carriage return char */
X#define LINE_FEED	'\n'     	/* line feed character  */
X#define FORMFEED	'\f'     	/* form feed (^L) char  */
X#define COMMA		','		/* comma character      */
X#define SPACE		' '		/* space character      */
X#define DOT		'.'		/* period/dot character */
X#define BANG		'!'		/* exclaimation mark!   */
X#define AT_SIGN		'@'		/* at-sign character    */
X#define PERCENT		'%'		/* percent sign char.   */
X#define COLON		':'		/* the colon ..		*/
X#define BACKQUOTE	'`'		/* backquote character  */
X#define TILDE_ESCAPE	'~'		/* escape character~    */
X#define ESCAPE		'\033'		/* the escape		*/
X
X#define NO_OP_COMMAND	'\0'		/* no-op for timeouts   */
X
X#define STANDARD_INPUT  0		/* file number of stdin */
X
X#ifndef TRUE
X#define TRUE		1
X#define FALSE		0
X#endif
X
X#define NO		0
X#define YES		1
X#define MAYBE		2		/* a definite define, eh?  */
X#define FORM		3		/*      <nevermind>        */
X#define PREFORMATTED	4		/* forwarded form...       */
X
X#define PAD		0		/* for printing name of    */
X#define FULL		1		/*   the sort we're using  */
X
X#define OUTGOING	0		/* defines for lock file   */
X#define INCOMING	1		/* creation..see lock()    */
X
X#define SH		0		/* defines for system_call */
X#define USER_SHELL	1		/* to work correctly!      */
X
X#define EXECUTE_ACCESS	01		/* These five are 	   */
X#define WRITE_ACCESS	02		/*    for the calls	   */
X#define READ_ACCESS	04		/*       to access()       */
X#define ACCESS_EXISTS	00		/*           <etc>         */
X#define EDIT_ACCESS	06		/*  (this is r+w access)   */
X
X#define BIG_NUM		999999		/* big number!             */
X#define BIGGER_NUM	9999999 	/* bigger number!          */
X
X#define START_ENCODE	"[encode]"
X#define END_ENCODE	"[clear]"
X
X#define DONT_SAVE	"[no save]"
X#define DONT_SAVE2	"[nosave]"
X
X#define alias_file	".aliases"
X#define group_file	".groups"
X#define system_file	".systems"
X
X#define default_folders		"Mail"
X#define default_recvdmail	"=received"
X#define default_sentmail	"=sent"
X
X/** some defines for the 'userlevel' variable... **/
X
X#define RANK_AMATEUR	0
X#define AMATEUR		1
X#define OKAY_AT_IT	2
X#define GOOD_AT_IT	3
X#define EXPERT		4
X#define SUPER_AT_IT	5
X
X/** some defines for the "status" field of the header record **/
X
X#define ACTION		1		/* bit masks, of course */
X#define CONFIDENTIAL	2
X#define DELETED		4
X#define EXPIRED		8
X#define FORM_LETTER	16
X#define NEW		32
X#define PRIVATE		64
X#define TAGGED		128
X#define URGENT		256
X#define VISIBLE		512
X#define UNREAD		1024
X#define STATUS_CHANGED	2048
X
X#define UNDELETE	0		/* purely for ^U function... */
X
X/** values for headers exit_disposition field */
X#define UNSET	0
X#define KEEP	1
X#define	STORE	2
X#define DELETE	3
X
X/** some months... **/
X
X#define JANUARY		0			/* months of the year */
X#define FEBRUARY	1
X#define MARCH		2
X#define APRIL		3
X#define MAY		4
X#define JUNE		5
X#define JULY		6
X#define AUGUST		7
X#define SEPTEMBER	8
X#define OCTOBER		9
X#define NOVEMBER	10
X#define DECEMBER	11
X
X#define equal(s,w)	(strcmp(s,w) == 0)
X#define min(a,b)	a < b? a : b
X#define ctrl(c)	        c - 'A' + 1	/* control character mapping */
X#define plural(n)	n == 1 ? "" : "s"
X#define lastch(s)	s[strlen(s)-1]
X
X/* find tab stops preceding or following a given column position 'a', where
X * the column position starts counting from 1, NOT 0!
X * The external integer "tabspacing" must be declared to use this. */
X#define prev_tab(a)	(((((a-1)/tabspacing))*tabspacing)+1)
X#define next_tab(a)	(((((a-1)/tabspacing)+1)*tabspacing)+1)
X
X#define movement_command(c)	(c == 'j' || c == 'k' || c == ' ' || 	      \
X				 c == BACKSPACE || c == ESCAPE || c == '*' || \
X				 c == '-' || c == '+' || c == '=' ||          \
X				 c == '#' || c == '@' || c == 'x' || 	      \
X				 c == 'a' || c == 'q')
X
X#define no_ret(s)	{ register int xyz; /* varname is for lint */	      \
X		          for (xyz=strlen(s)-1; xyz >= 0 && 		      \
X				(s[xyz] == '\r' || s[xyz] == '\n'); )	      \
X			     s[xyz--] = '\0';                                 \
X			}
X			  
X#define first_word(s,w) (strncmp(s,w, strlen(w)) == 0)
X#define ClearLine(n)	MoveCursor(n,0); CleartoEOLN()
X#define whitespace(c)	(c == ' ' || c == '\t')
X#define ok_char(c)	(isalnum(c) || c == '-' || c == '_')
X#define quote(c)	(c == '"' || c == '\'') 
X#define onoff(n)	(n == 0 ? "OFF" : "ON")
X
X/** The next function is so certain commands can be processed from the showmsg
X    routine without rewriting the main menu in between... **/
X
X#define special(c)	(c == 'j' || c == 'k')
X
X/** and a couple for dealing with status flags... **/
X
X#define ison(n,mask)	(n & mask)
X#define isoff(n,mask)	(!ison(n, mask))
X
X#define setit(n,mask)		n |= mask
X#define clearit(n, mask)	n &= ~mask
X
X/** a few for the usage of function keys... **/
X
X#define f1	1
X#define f2	2
X#define f3	3
X#define f4	4
X#define f5	5
X#define f6	6
X#define f7	7
X#define f8	8
X
X#define MAIN	0
X#define ALIAS   1
X#define YESNO	2
X#define CHANGE  3
X#define READ	4
X
X#define MAIN_HELP    0
X#define OPTIONS_HELP 1
X#define ALIAS_HELP   2
X#define PAGER_HELP   3
X
X/** types of folders **/
X#define NO_NAME		0		/* variable contains no file name */
X#define NON_SPOOL	1		/* mailfile not in mailhome */
X#define SPOOL		2		/* mailfile in mailhome */
X
X/* the following is true if the current mailfile is the user's spool file*/
X#define USERS_SPOOL	(strcmp(cur_folder, defaultfile) == 0)
X
X/** some possible sort styles... **/
X
X#define REVERSE		-		/* for reverse sorting           */
X#define SENT_DATE	1		/* the date message was sent     */
X#define RECEIVED_DATE	2		/* the date message was received */
X#define SENDER		3		/* the name/address of sender    */
X#define SIZE		4		/* the # of lines of the message */
X#define SUBJECT		5		/* the subject of the message    */
X#define STATUS		6		/* the status (deleted, etc)     */
X#define MAILBOX_ORDER	7		/* the order it is in the file   */
X
X/* some stuff for our own malloc call - pmalloc */
X
X#define PMALLOC_THRESHOLD	256	/* if greater, then just use malloc */
X#define PMALLOC_BUFFER_SIZE    2048	/* internal [memory] buffer size... */
X
X/** the following macro is as suggested by Larry McVoy.  Thanks! **/
X
X# ifdef DEBUG
X#  define   dprint(n,x)		{ 				\
X				   if (debug >= n)  {		\
X				     fprintf x ; 		\
X				     fflush(debugfile);         \
X				   }				\
X				}
X# else
X#  define   dprint(n,x)
X# endif
X
X/* some random structs... */
X
Xstruct date_rec {
X	int  month;		/** this record stores a **/
X	int  day;		/**   specific date and  **/
X	int  year;		/**     time...		 **/
X	int  hour;
X	int  minute;
X       };
X
Xstruct header_rec {
X	int  lines;		/** # of lines in the message  **/
X	int  status;		/** Urgent, Deleted, Expired?  **/
X	int  index_number;	/** relative loc in file...    **/
X	int  encrypted;		/** whether msg has encryption **/
X	int  exit_disposition;	/** whether to keep, store, delete **/
X	int  status_chgd;	/** whether became read or old, etc. **/
X	long offset;		/** offset in bytes of message **/
X	struct date_rec received; /** when elm received here   **/
X	char from[STRING];	/** who sent the message?      **/
X	char to[STRING];	/** who it was sent to	       **/
X	char messageid[STRING];	/** the Message-ID: value      **/
X	char dayname[8];	/**  when the                  **/
X	char month[10];		/**        message             **/
X	char day[3];		/**          was 	       **/
X	char year[5];		/**            sent            **/
X	char time[NLEN];	/**              to you!       **/
X	char subject[STRING];   /** The subject of the mail    **/
X	char mailx_status[WLEN];/** mailx status flags (RO...) **/
X       };
X
Xstruct alias_rec {
X	char   name[NLEN];	/* alias name 			     */
X	long   byte;		/* offset into data file for address */
X       };
X
Xstruct lsys_rec {
X	char   name[NLEN];	/* name of machine connected to      */
X	struct lsys_rec *next;	/* linked list pointer to next       */
X       };
X
Xstruct addr_rec {
X	 char   address[NLEN];	/* machine!user you get mail as      */
X	 struct addr_rec *next;	/* linked list pointer to next       */
X	};
X
X#ifdef SHORTNAMES	/* map long names to shorter ones */
X# include <shortname.h>
X#endif
X
X/** Let's make sure that we're not going to have any annoying problems with 
X    int pointer sizes versus char pointer sizes by guaranteeing that every-
X    thing vital is predefined... (Thanks go to Detlev Droege for this one)
X**/
X
X#ifdef STRINGS
X#  include <strings.h>
X#else
X#  include <string.h>
X#endif
X
Xchar *argv_zero();
Xchar *bounce_off_remote();
Xchar *ctime();
Xchar *error_description();
Xchar *error_name();
Xchar *error_number();
Xchar *expand_address();
Xchar *expand_domain();
Xchar *expand_group();
Xchar *expand_logname();
Xchar *expand_system();
Xchar *find_path_to();
Xchar *format_long();
Xchar *get_alias_address();
Xchar *get_arpa_date();
Xchar *get_ctime_date();
Xchar *get_date();
Xchar *get_token();
Xchar *getenv();
Xchar *getlogin();
Xchar *level_name();
Xchar *match_and_expand_domain();
Xchar *shift_lower();
Xchar *strip_commas();
Xchar *strip_parens();
Xchar *strpbrk();
Xchar *strtok();
Xchar *tail_of_string();
Xchar *tgetstr();
Xchar *pmalloc();
X
Xlong lseek();
Xlong times();
Xlong ulimit();
SHAR_EOF
chmod 0444 hdrs/defs.h || echo "restore of hdrs/defs.h fails"
echo "x - extracting hdrs/elm.h (Text)"
sed 's/^X//' << 'SHAR_EOF' > hdrs/elm.h &&
X
X/* $Id: elm.h,v 2.21 89/03/25 21:45:26 syd Exp $ */
X
X/*******************************************************************************
X *  The Elm Mail System  -  $Revision: 2.21 $   $State: Exp $
X *
X * 			Copyright (c) 1986, 1987 Dave Taylor
X * 			Copyright (c) 1988, 1989 USENET Community Trust
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Syd Weinstein, Elm Coordinator
X *	elm@dsinc.UUCP			dsinc!elm
X *
X *******************************************************************************
X * $Log:	elm.h,v $
X * Revision 2.21  89/03/25  21:45:26  syd
X * Initial 2.2 Release checkin
X * 
X *
X ******************************************************************************/
X
X/**  Main header file for ELM mail system.  **/
X
X
X#include <stdio.h>
X#include <fcntl.h>
X
X#include "../hdrs/curses.h"
X#include "../hdrs/defs.h"
X
X/******** static character string containing the version number  *******/
X
Xstatic char ident[] = { WHAT_STRING };
X
X/******** and another string for the copyright notice            ********/
X
Xstatic char copyright[] = { 
X		"@(#)          (C) Copyright 1986, 1987, Dave Taylor\n@(#)          (C) Copyright 1988, The Usenet Community Trust\n" };
X
X/******** global variables accessable by all pieces of the program *******/
X
Xint check_size = 0;		/* don't start mailer if no mail */
Xint current = 0;		/* current message number  */
Xint header_page = 0;     	/* current header page     */
Xint last_header_page = -1;     	/* last header page        */
Xint message_count = 0;		/* max message number      */
Xint headers_per_page;		/* number of headers/page  */
Xint sendmail_verbose = 0;       /* Extended mail debugging */
Xchar cur_folder[SLEN] = {0};	/* name of current folder */
Xchar cur_tempfolder[SLEN] = {0}; /* name of temp folder open for a mailbox */
Xchar defaultfile[SLEN] = {0};	/* name of default folder */
Xchar hostname[SLEN] = {0};	/* name of machine we're on*/
Xchar hostdomain[SLEN] = {0};	/* name of domain we're in */
Xchar username[SLEN] = {0};	/* return address name!    */
Xchar full_username[SLEN] = {0};	/* Full username - gecos   */
Xchar home[SLEN] = {0};		/* home directory of user  */
Xchar folders[SLEN] = {0};	/* folder home directory   */
Xchar raw_folders[SLEN] = {0};	/* unexpanded folder home directory   */
Xchar recvd_mail[SLEN] = {0};	/* folder for storing received mail	*/
Xchar raw_recvdmail[SLEN] = {0};	/* unexpanded recvd_mail name */
Xchar editor[SLEN] = {0};	/* editor for outgoing mail*/
Xchar raw_editor[SLEN] = {0};	/* unexpanded editor for outgoing mail*/
Xchar alternative_editor[SLEN] = {0};	/* alternative editor...   */
Xchar printout[SLEN] = {0};	/* how to print messages   */
Xchar raw_printout[SLEN] = {0};	/* unexpanded how to print messages   */
Xchar sent_mail[SLEN] = {0};	/* name of file to save copies to */
Xchar raw_sentmail[SLEN] = {0};	/* unexpanded name of file to save to */
Xchar calendar_file[SLEN] = {0};	/* name of file for clndr  */
Xchar raw_calendar_file[SLEN] = {0};	/* unexpanded name of file for clndr  */
Xchar prefixchars[SLEN] = "> ";	/* prefix char(s) for msgs */
Xchar shell[SLEN] = {0};		/* current system shell    */
Xchar raw_shell[SLEN] = {0};	/* unexpanded current system shell    */
Xchar pager[SLEN] = {0};		/* what pager to use       */
Xchar raw_pager[SLEN] = {0};	/* unexpanded what pager to use       */
Xchar batch_subject[SLEN] = {0};	/* subject buffer for batchmail */
Xchar local_signature[SLEN] = {0};	/* local msg signature file     */
Xchar raw_local_signature[SLEN] = {0};	/* unexpanded local msg signature file     */
Xchar remote_signature[SLEN] = {0};	/* remote msg signature file    */
Xchar raw_remote_signature[SLEN] = {0};/* unexpanded remote msg signature file    */
Xchar version_buff[SLEN] = {0};	/* version buffer */
X
Xchar backspace,			/* the current backspace char */
X     escape_char = TILDE_ESCAPE,/* '~' or something else..    */
X     kill_line;			/* the current kill-line char */
X
Xchar up[SHORT], down[SHORT],	/* cursor control seq's    */
X     left[SHORT], right[SHORT];
Xint  cursor_control = FALSE;	/* cursor control avail?   */
X
Xchar start_highlight[SHORT],
X     end_highlight[SHORT];	/* stand out mode...       */
X
Xint  has_highlighting = FALSE;	/* highlighting available? */
X
Xchar *weedlist[MAX_IN_WEEDLIST];
Xint  weedcount;
X
Xint allow_forms = NO;		/* flag: are AT&T Mail forms okay?  */
Xint mini_menu = 1;		/* flag: menu specified?	    */
Xint prompt_after_pager = 1;	/* flag: prompt after pager exits   */
Xint folder_type = 0;		/* flag: type of folder		    */
Xint auto_copy = 0;		/* flag: automatically copy source? */
Xint filter = 1;			/* flag: weed out header lines?	    */
Xint resolve_mode = 1;		/* flag: delete saved mail?	    */
Xint auto_cc = 0;		/* flag: mail copy to user?	    */
Xint noheader = 1;		/* flag: copy + header to file?     */
Xint title_messages = 1;		/* flag: title message display?     */
Xint forwarding = 0;		/* flag: are we forwarding the msg? */
Xint hp_terminal = 0;		/* flag: are we on HP term?	    */
Xint hp_softkeys = 0;		/* flag: are there softkeys?        */
Xint save_by_name = 1;		/* flag: save mail by login name?   */
Xint mail_only = 0;		/* flag: send mail then leave?      */
Xint check_only = 0;		/* flag: check aliases then leave?  */
Xint batch_only = 0;		/* flag: send without prompting?    */
Xint move_when_paged = 0;	/* flag: move when '+' or '-' used? */
Xint point_to_new = 1;		/* flag: start pointing at new msg? */
Xint bounceback = 0;		/* flag: bounce copy off remote?    */
Xint always_keep = 1;		/* flag: always keep unread msgs?   */
Xint always_store = 0;		/* flag: always store read msgs?    */
Xint always_del = 0;		/* flag: always delete marked msgs? */
Xint arrow_cursor = 0;		/* flag: use "->" cursor regardless?*/
Xint debug = 0; 			/* flag: default is no debug!       */
Xint read_in_aliases = 0;	/* flag: have we read in aliases??  */
Xint warnings = 1;		/* flag: output connection warnings?*/
Xint user_level = 0;		/* flag: how good is the user?      */
Xint selected = 0;		/* flag: used for select stuff      */
Xint names_only = 1;		/* flag: display user names only?   */
Xint question_me = 1;		/* flag: ask questions as we leave? */
Xint keep_empty_files = 0;	/* flag: leave empty folder files? */
Xint clear_pages = 0;		/* flag: act like "page" (more -c)? */
Xint prompt_for_cc = 1;		/* flag: ask user for "cc:" value?  */
X
Xint sortby = REVERSE SENT_DATE;	/* how to sort incoming mail...     */
X
Xlong timeout = 600L;		/* timeout (secs) on main prompt    */
X
X/** set up some default values for a 'typical' terminal *snicker* **/
X
Xint LINES=23;			/** lines per screen      **/
Xint COLUMNS=80;			/** columns per page      **/
X
Xlong size_of_pathfd;		/** size of pathfile, 0 if none **/
X
XFILE *mailfile;			/* current folder	    */
XFILE *debugfile;		/* file for debug output    */
XFILE *pathfd;			/* path alias file          */
XFILE *domainfd;			/* domain file		    */
X
Xlong mailfile_size;		/* size of current mailfile */
X
Xint   max_headers;		/* number of headers allocated */
X
Xstruct header_rec **headers;    /* array of header structure pointers */
X
Xstruct alias_rec user_hash_table[MAX_UALIASES];
Xstruct alias_rec system_hash_table[MAX_SALIASES];
X
Xstruct lsys_rec *talk_to_sys;   /* what machines do we talk to? */
X
Xstruct addr_rec *alternative_addresses;	/* how else do we get mail? */
X
Xint system_files = 0;		/* do we have system aliases? */
Xint user_files = 0;		/* do we have user aliases?   */
X
Xint system_data;		/* fileno of system data file */
Xint user_data;			/* fileno of user data file   */
X
Xint userid;			/* uid for current user	      */
Xint groupid;			/* groupid for current user   */
SHAR_EOF
chmod 0444 hdrs/elm.h || echo "restore of hdrs/elm.h fails"
echo "x - extracting hdrs/filter.h (Text)"
sed 's/^X//' << 'SHAR_EOF' > hdrs/filter.h &&
X
X/* $Id: filter.h,v 2.4 89/03/25 21:45:30 syd Exp $ */
X
X/*******************************************************************************
X *  The Elm Mail System  -  $Revision: 2.4 $   $State: Exp $
X *
X * 			Copyright (c) 1986, 1987 Dave Taylor
X * 			Copyright (c) 1988, 1989 USENET Community Trust
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Syd Weinstein, Elm Coordinator
X *	elm@dsinc.UUCP			dsinc!elm
X *
X *******************************************************************************
X * $Log:	filter.h,v $
X * Revision 2.4  89/03/25  21:45:30  syd
X * Initial 2.2 Release checkin
X * 
X *
X ******************************************************************************/
X
X/** Headers for the filter program.
X
X**/
X
X#ifdef   BSD
X# undef  tolower
X#endif
X
X/** define a few handy macros for later use... **/
X
X#define  the_same(a,b)	(strncmp(a,b,strlen(b)) == 0)
X
X#define relationname(x)  (x == 1?"<=":x==2?"<":x==3?">=":x==4?">":x==5?"!=":"=")
X
X#define quoteit(x)	 (x == LINES? "" : "\"")
X
X#define remove_return(s)	{ if (s[strlen(s)-1] == '\n') \
X				    s[strlen(s)-1] = '\0';    \
X			   	}
X
X/** some of the files we'll be using, where they are, and so on... **/
X
X#define  filter_temp	"/tmp/filter"
X#define  filterfile	".filter-rules"
X#define  filterlog	".filterlog"
X#define  filtersum	".filtersum"
X
X#define  EMERGENCY_MAILBOX	"EMERGENCY_MBOX"
X#define  EMERG_MBOX		"MBOX.EMERGENCY"
X
X/** and now the hardwired constraint of the program.. **/
X
X#define  MAXRULES	25		/* can't have more den dis, boss! */
X
X/** some random defines for mnemonic stuff in the program... **/
X
X#ifdef SUBJECT
X# undef SUBJECT
X#endif
X
X#define  TO		1
X#define  FROM		2
X#define  LINES		3
X#define  SUBJECT	4
X#define  CONTAINS	5
X#define  ALWAYS		6
X
X#define  DELETE_MSG 	7
X#define  SAVE		8
X#define  SAVECC		9
X#define  FORWARD	10
X#define  LEAVE		11
X#define  EXEC		12
X
X#define  FAILED_SAVE	20
X
X/** Some conditionals... **/
X
X#define LE		1
X#define LT		2
X#define GE		3
X#define GT		4
X#define NE		5
X#define EQ		6
X
X/** A funky way to open a file using open() to avoid file locking hassles **/
X
X#define  FOLDERMODE	O_WRONLY | O_APPEND | O_CREAT | O_SYNCIO
X
X/** cheap but easy way to have two files share the same #include file **/
X
X#ifdef MAIN_ROUTINE
X
Xchar home[SLEN],				/* the users home directory */
X     hostname[SLEN],			/* the machine name...      */
X     username[SLEN];			/* the users login name...  */
X
Xchar to[VERY_LONG_STRING], 
X     from[LONG_STRING], 
X     subject[LONG_STRING];		/* from current message     */
X
XFILE *outfd;
Xchar outfname[SLEN];
X
Xint  total_rules = 0,				/* how many rules to check  */
X     show_only = FALSE,				/* just for show?           */
X     long_summary = FALSE,			/* what sorta summary??     */
X     verbose   = FALSE,				/* spit out lots of stuff   */
X     lines     = 0,				/* lines in message..       */
X     clear_logs = FALSE,			/* clear files after sum?   */
X     already_been_forwarded = FALSE,		/* has this been filtered?  */
X     log_actions_only = FALSE,			/* log actions | everything */
X     printing_rules = FALSE,			/* are we just using '-r'?  */
X     rule_choosen;				/* which one we choose      */
X
X#else
X
Xextern char home[SLEN],				/* the users home directory */
X            hostname[SLEN],			/* the machine name...      */
X            username[SLEN];			/* the users login name...  */
X
Xextern char to[VERY_LONG_STRING], 
X            from[LONG_STRING], 
X            subject[LONG_STRING];		/* from current message     */
X
Xextern FILE *outfd;
Xextern char outfname[SLEN];
X
Xextern int total_rules,				/* how many rules to check  */
X           show_only,				/* just for show?           */
X           long_summary,			/* what sorta summary??     */
X           verbose,				/* spit out lots of stuff   */
X           lines,				/* lines in message..       */
X           clear_logs,			        /* clear files after sum?   */
X	   already_been_forwarded,		/* has this been filtered?  */
X           log_actions_only,			/* log actions | everything */
X           printing_rules,			/* are we just using '-r'?  */
X           rule_choosen;			/* which one we choose      */
X#endif
X
X/** and our ruleset record structure... **/
X
Xstruct condition_rec {
X	int     matchwhat;			/* type of 'if' clause      */
X	int     relation;			/* type of match (eq, etc)  */
X	char    argument1[SLEN];		/* match against this       */
X	struct  condition_rec  *next;		/* next condition...	    */
X      };
X
Xextern struct ruleset_record {
X	char  	printable[SLEN];		/* straight from file...    */
X	struct  condition_rec  *condition;
X	int     action;				/* what action to take      */
X	char    argument2[SLEN];		/* argument for action      */
X      };
X
X#ifdef MAIN_ROUTINE
X  struct ruleset_record rules[MAXRULES];
X#else
X  extern struct ruleset_record rules[MAXRULES];
X#endif
X
X/** finally let's keep LINT happy with the return values of all these pups! ***/
X
Xunsigned short getuid();
X
Xunsigned long sleep();
X
Xchar *malloc(), *strcpy(), *strcat(), *itoa();
X
Xvoid	exit();
X
X#ifdef BSD
X	
X  FILE *popen();
X
X#ifdef MAIN_ROUTINE
X  char  _vbuf[5*BUFSIZ];              /* space for file buffering */
X#else
X  extern char  _vbuf[5*BUFSIZ];		/* space for file buffering */
X#endif
X
X#ifndef _IOFBF
X# define _IOFBF		0		/* doesn't matter - ignored */
X#endif
X
X# define setvbuf(fd,a,b,c)	setbuffer(fd, _vbuf, 5*BUFSIZ)
X
X#endif
SHAR_EOF
chmod 0444 hdrs/filter.h || echo "restore of hdrs/filter.h fails"
echo "x - extracting hdrs/headers.h (Text)"
sed 's/^X//' << 'SHAR_EOF' > hdrs/headers.h &&
X
X/* $Id: headers.h,v 2.18 89/03/25 21:45:31 syd Exp $ */
X
X/*******************************************************************************
X *  The Elm Mail System  -  $Revision: 2.18 $   $State: Exp $
X *
X * 			Copyright (c) 1986, 1987 Dave Taylor
X * 			Copyright (c) 1988, 1989 USENET Community Trust
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Syd Weinstein, Elm Coordinator
X *	elm@dsinc.UUCP			dsinc!elm
X *
X *******************************************************************************
X * $Log:	headers.h,v $
X * Revision 2.18  89/03/25  21:45:31  syd
X * Initial 2.2 Release checkin
X * 
X *
X ******************************************************************************/
X
X/**  This is the header file for ELM mail system.  **/
X
X
X#include <stdio.h>
X#include <fcntl.h>
X
X#include "curses.h"
X#include "defs.h"
X
X#ifndef       clearerr
X#define       clearerr(p)     (void)((p)->_flag &= ~(_IOERR|_IOEOF))
X#endif
X
X/******** global variables accessable by all pieces of the program *******/
X
Xextern int check_size;		/* don't start mailer if no mail */
Xextern int current;		/* current message number  */
Xextern int header_page;         /* current header page     */
Xextern int last_header_page;    /* last header page        */
Xextern int message_count;	/* max message number      */
Xextern int headers_per_page;	/* number of headers/page  */
Xextern int sendmail_verbose;    /* Allow extended debugging on sendmail */
Xextern char cur_folder[SLEN];	/* name of current folder */
Xextern char cur_tempfolder[SLEN]; /* name of temp folder open for a mailbox */
Xextern char defaultfile[SLEN];	/* name of default folder */
Xextern char hostname[SLEN];	/* name of machine we're on*/
Xextern char hostdomain[SLEN];	/* name of domain we're in */
Xextern char username[SLEN];	/* return address name!    */
Xextern char full_username[SLEN];/* Full username - gecos   */
Xextern char home[SLEN];		/* home directory of user  */
Xextern char folders[SLEN];	/* folder home directory   */
Xextern char raw_folders[SLEN];	/* unexpanded folder home directory   */
Xextern char recvd_mail[SLEN];	/* folder for storing received mail	*/
Xextern char raw_recvdmail[SLEN];/* unexpanded recvd_mail name */
Xextern char editor[SLEN];	/* default editor for mail */
Xextern char raw_editor[SLEN];	/* unexpanded default editor for mail */
Xextern char alternative_editor[SLEN];/* the 'other' editor */
Xextern char printout[SLEN];	/* how to print messages   */
Xextern char raw_printout[SLEN];	/* unexpanded how to print messages   */
Xextern char sent_mail[SLEN];	/* name of file to save copies to */
Xextern char raw_sentmail[SLEN];	/* unexpanded name of file to save to */
Xextern char calendar_file[SLEN];/* name of file for clndr  */
Xextern char raw_calendar_file[SLEN];/* unexpanded name of file for clndr  */
Xextern char prefixchars[SLEN];	/* prefix char(s) for msgs */
Xextern char shell[SLEN];	/* default system shell    */
Xextern char raw_shell[SLEN];	/* unexpanded default system shell    */
Xextern char pager[SLEN];	/* what pager to use...    */
Xextern char raw_pager[SLEN];	/* unexpanded what pager to use...    */
Xextern char batch_subject[SLEN];/* subject buffer for batchmail */
Xextern char local_signature[SLEN];/* local msg signature file   */
Xextern char raw_local_signature[SLEN];/* unexpanded local msg signature file */
Xextern char remote_signature[SLEN];/* remote msg signature file */
Xextern char raw_remote_signature[SLEN];/* unexpanded remote msg signature file*/
X
Xextern char backspace,		/* the current backspace char  */
X	    escape_char,	/* '~' or something else...    */
X	    kill_line;		/* the current kill_line char  */
X
Xextern char up[SHORT], 
X	    down[SHORT],
X	    left[SHORT],
X	    right[SHORT];	/* cursor control seq's    */
Xextern int  cursor_control;	/* cursor control avail?   */
X
Xextern char start_highlight[SHORT],
X	    end_highlight[SHORT];  /* standout mode... */
X
Xextern int  has_highlighting;	/* highlighting available? */
X
X/** the following two are for arbitrary weedout lists.. **/
X
Xextern char *weedlist[MAX_IN_WEEDLIST];
Xextern int  weedcount;		/* how many headers to check?        */
X
Xextern int  allow_forms;	/* flag: are AT&T Mail forms okay?    */
Xextern int  prompt_after_pager;	/* flag: prompt after pager exits     */
Xextern int  mini_menu;		/* flag: display menu?     	      */
Xextern int  folder_type;	/* flag: type of folder		      */
Xextern int  auto_copy;		/* flag: auto copy source into reply? */
Xextern int  filter;		/* flag: weed out header lines?	      */
Xextern int  resolve_mode;	/* flag: resolve before moving mode?  */
Xextern int  auto_cc;		/* flag: mail copy to yourself?       */
Xextern int  noheader;		/* flag: copy + header to file?       */
Xextern int  title_messages;	/* flag: title message display?       */
Xextern int  forwarding;		/* flag: are we forwarding the msg?   */
Xextern int  hp_terminal;	/* flag: are we on an hp terminal?    */
Xextern int  hp_softkeys;	/* flag: are there softkeys?          */
Xextern int  save_by_name;  	/* flag: save mail by login name?     */
Xextern int  mail_only;		/* flag: send mail then leave?        */
Xextern int  check_only;		/* flag: check aliases and leave?     */
Xextern int  batch_only;		/* flag: send without prompting?      */
Xextern int  move_when_paged;	/* flag: move when '+' or '-' used?   */
Xextern int  point_to_new;	/* flag: start pointing at new msgs?  */
Xextern int  bounceback;		/* flag: bounce copy off remote?      */
Xextern int  always_keep;	/* flag: always keep unread msgs?     */
Xextern int  always_store;	/* flag: always store read mail?      */
Xextern int  always_del;		/* flag: always delete marked msgs?   */
Xextern int  arrow_cursor;	/* flag: use "->" regardless?	      */
Xextern int  debug;		/* flag: debugging mode on?           */
Xextern int  read_in_aliases;	/* flag: have we read in aliases yet? */
Xextern int  warnings;		/* flag: output connection warnings?  */
Xextern int  user_level;		/* flag: how knowledgable is user?    */
Xextern int  selected;		/* flag: used for select stuff        */
Xextern int  names_only;		/* flag: display names but no addrs?  */
Xextern int  question_me;	/* flag: ask questions as we leave?   */
Xextern int  keep_empty_files;	/* flag: keep empty files??	      */
Xextern int  clear_pages;	/* flag: clear screen w/ builtin pgr? */
Xextern int  prompt_for_cc;	/* flag: prompt user for 'cc' value?  */
X
Xextern int  sortby;		/* how to sort folders	      */
X
Xextern long timeout;		/* seconds for main level timeout     */
X
Xextern int LINES;		/** lines per screen    **/
Xextern int COLUMNS;		/** columns per line    **/
X
Xextern long size_of_pathfd;	/** size of pathfile, 0 if none **/
X
Xextern FILE *mailfile;		/* current folder 	    */
Xextern FILE *debugfile;		/* file for debut output    */
Xextern FILE *pathfd;		/* path alias file          */
Xextern FILE *domainfd;		/* domains file 	    */
X
Xextern long mailfile_size;	/* size of current mailfile */
X
Xextern int  max_headers;	/* number of headers currently allocated */
X
Xextern struct header_rec **headers; /* array of header structure pointers */
X
Xextern struct alias_rec user_hash_table  [MAX_UALIASES];
Xextern struct alias_rec system_hash_table[MAX_SALIASES];
X
Xextern struct lsys_rec *talk_to_sys;	/* who do we talk to? */
X
Xextern struct addr_rec *alternative_addresses;	/* how else do we get mail? */
X
Xextern int system_files;	/* do we have system aliases? */
Xextern int user_files;		/* do we have user aliases?   */
X
Xextern int system_data;		/* fileno of system data file */
Xextern int user_data;		/* fileno of user data file   */
X
Xextern int userid;		/* uid for current user	      */
Xextern int groupid;		/* groupid for current user   */
SHAR_EOF
chmod 0444 hdrs/headers.h || echo "restore of hdrs/headers.h fails"
echo "x - extracting hdrs/patchlevel.h (Text)"
sed 's/^X//' << 'SHAR_EOF' > hdrs/patchlevel.h &&
X#define PATCHLEVEL 0
SHAR_EOF
chmod 0666 hdrs/patchlevel.h || echo "restore of hdrs/patchlevel.h fails"
echo "x - extracting hdrs/save_opts.h (Text)"
sed 's/^X//' << 'SHAR_EOF' > hdrs/save_opts.h &&
X
X/* @(#)$Id: save_opts.h,v 2.9 89/03/25 21:45:33 syd Exp $ */
X
X/*******************************************************************************
X *  The Elm Mail System  -  $Revision: 2.9 $   $State: Exp $
X *
X * 			Copyright (c) 1986, 1987 Dave Taylor
X * 			Copyright (c) 1988, 1989 USENET Community Trust
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Syd Weinstein, Elm Coordinator
X *	elm@dsinc.UUCP			dsinc!elm
X *
X *******************************************************************************
X * $Log:	save_opts.h,v $
X * Revision 2.9  89/03/25  21:45:33  syd
X * Initial 2.2 Release checkin
X * 
X *
X ******************************************************************************/
X
X/** Some crazy includes for the save-opts part of the Elm program!
X
X**/
X
X#define ALTERNATIVES		0
X#define ALWAYSDELETE		1
X#define ALWAYSKEEP		2
X#define ALWAYSSTORE		3
X#define ARROW			4
X#define ASK			5
X#define ASKCC			6
X#define AUTOCOPY		7
X#define BOUNCEBACK		8
X#define CALENDAR		9
X#define COPY			10
X#define EDITOR			11
X#define ESCAPECHAR		12
X#define FORMS			13
X#define FULLNAME		14
X#define KEEPEMPTY		15
X#define KEYPAD			16
X#define LOCALSIGNATURE		17
X#define MAILDIR			18
X#define MENU			19
X#define MOVEPAGE		20
X#define NAMES			21
X#define NOHEADER		22
X#define PAGER			23
X#define POINTNEW		24
X#define PREFIX			25
X#define PRINT			26
X#define PROMPTAFTER		27
X#define RECEIVEDMAIL		28
X#define REMOTESIGNATURE		29
X#define RESOLVE			30
X#define SAVENAME		31
X#define SENTMAIL		32
X#define SHELL			33
X#define SIGNATURE		34
X#define SOFTKEYS		35
X#define SORTBY			36
X#define TIMEOUT			37
X#define TITLES			38
X#define USERLEVEL		39
X#define WARNINGS		40
X#define WEED			41
X#define WEEDOUT			42
X
X#define NUMBER_OF_SAVEABLE_OPTIONS	WEEDOUT+1
X
Xstruct save_info_recs { 
X	char 	name[NLEN]; 	/* name of instruction */
X	long 	offset;		/* offset into elmrc-info file */
X	} save_info[NUMBER_OF_SAVEABLE_OPTIONS] = 
X{
X { "alternatives", -1L }, 
X { "alwaysdelete", -1L }, 	
X { "alwayskeep", -1L },
X { "alwaysstore", -1L },
X { "arrow", -1L},         
X { "ask", -1L },
X { "askcc", -1L },
X { "autocopy", -1L },      	
X { "bounceback", -1L },
X { "calendar", -1L }, 	  
X { "copy", -1L },          	
X { "editor", -1L },
X { "escape", -1L }, 	  
X { "forms", -1L },         	
X { "fullname", -1L },
X { "keepempty", -1L }, 	  
X { "keypad", -1L }, 	  
X { "localsignature", -1L },	
X { "maildir", -1L }, 	  
X { "menu", -1L }, 		
X { "movepage", -1L }, 
X { "names", -1L },        
X { "noheader", -1L }, 		
X { "pager", -1L }, 
X { "pointnew", -1L},      
X { "prefix", -1L },       	
X { "print", -1L }, 
X { "promptafter", -1L }, 
X { "receivedmail", -1L }, 
X { "remotesignature",-1L},
X { "resolve", -1L },       	
X { "savename", -1L },     
X { "sentmail", -1L }, 
X { "shell", -1L },         	
X { "signature", -1L },
X { "softkeys", -1L },	  
X { "sortby", -1L }, 		
X { "timeout", -1L },
X { "titles", -1L },       
X { "userlevel", -1L }, 	
X { "warnings", -1L },
X { "weed", -1L },         
X { "weedout", -1L },		
X};
SHAR_EOF
chmod 0444 hdrs/save_opts.h || echo "restore of hdrs/save_opts.h fails"
echo "x - extracting hdrs/shortname.1 (Text)"
sed 's/^X//' << 'SHAR_EOF' > hdrs/shortname.1 &&
XNOTE: This file is obsolete and is not being kept uptodate.  It is provided
Xfor reference only.
X
XSyd Weinstein
XElm Coordinator
X
XFrom sun!convex!ndmce!jlsoft!marquez@hplabs.HP.COM  Tue Mar 24 14:55:53 1987
XReceived: from hplabsc (hplabsc.hpl.hp.com) by hpldat ; Tue, 24 Mar 87 14:55:53 pst
XReturn-Path: <sun!convex!ndmce!jlsoft!marquez@hplabs.HP.COM>
XReceived: from hplabs.HP.COM by hplabsc ; Tue, 24 Mar 87 14:54:57 pst
XReceived: from Sun.COM by hplabs.HP.COM with TCP ; Tue, 24 Mar 87 14:52:11 pst
XReceived: from sun.Sun.COM by Sun.COM (3.2/SMI-3.2)
X	id AA01637; Tue, 24 Mar 87 14:46:13 PST
XReceived: by sun.Sun.COM (3.2/SMI-3.2)
X	id AA00003; Tue, 24 Mar 87 14:50:23 PST
XFrom: sun!convex!ndmce!jlsoft!marquez@hplabs.HP.COM
XMessage-Id: <8703242250.AA00003@sun.Sun.COM>
SHAR_EOF
echo "End of part 9"
echo "File hdrs/shortname.1 is continued in part 10"
echo "10" > s2_seq_.tmp
exit 0

