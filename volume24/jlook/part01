Subject:  v24i046:  Journal lookup-program with database, Part01/05
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: 5fe74f07 625780c5 c3b0f34e 95b7c93b

Submitted-by: Dave Davey <daved@physiol.su.oz.au>
Posting-number: Volume 24, Issue 46
Archive-name: jlook/part01

[  The database is one of the most interesting parts of this submission. --r$ ]  

jlook is a tool to assist with Journal name handling in bibliographic
applications.  It supplements refer and other utilities.  Using a library
of official full titles and abbreviations used by Chemical Abstracts,
Index Medicus and the World List of Scientific Periodicals, jlook can
interconvert these forms, or generate one of them from reasonable
abbreviations.  The library may contain recognised variants of titles, or
local preferred abbreviations.

Used with journal names as command arguments, jlook returns the full title
(or abbreviation selected by a switch).

Used as a filter, jlook converts input lines starting with %J to the
corresponding full title or selected abbreviation.  Titles which cannot
be recognised are passed through unchanged, but diagnostic output
may be obtained.

jlook uses a simple index file to speed searches.  The program starts
marginally faster if the index file exists and is up-to-date, but will
generate the index itself otherwise.

The available library gives fair coverage of the biomedical literature
(about 2000 journals). It compiles and runs on (at least) Version 7 and
BSD 4.3 systems.

#!/bin/sh
# shar:	Shell Archiver  (v1.22)
# This is part 1 of a multipart archive                                    
# do not concatenate these parts, unpack them in order with /bin/sh        
#
#	Run the following text with /bin/sh to create:
#	  README
#	  jlook.1l
#	  jlook.c
#	  jindex.c
#	  jsubs.c
#	  jlook.h
#	  Makefile
#	  tst_alt
#	  tst_chem_good
#	  tst_full_good
#	  tst_input
#	  jlist
#
if test -r s2_seq_.tmp
then echo "Must unpack archives in sequence!"
     next=`cat s2_seq_.tmp`; echo "Please unpack part $next next"
     exit 1; fi
echo "x - extracting README (Text)"
sed 's/^X//' << 'SHAR_EOF' > README &&
Xjlook README
X$Header: /src/local/cmd/jlook/README,v 1.1 90/02/04 12:45:45 daved Rel $
X
Xjlook is a tool to assist with Journal name handling in bibliographic
Xapplications.  It supplements refer and other utilities.  Using a library
Xof official full titles and abbreviations used by Chemical Abstracts,
XIndex Medicus and the World List of Scientific Periodicals, jlook can
Xinterconvert these forms, or generate one of them from reasonable
Xabbreviations.  The library may contain recognised variants of titles, or
Xlocal preferred abbreviations.
X
XUsed with journal names as command arguments, jlook returns the full title
X(or abbreviation selected by a switch).
X
XUsed as a filter, jlook converts input lines starting with %J to the
Xcorresponding full title or selected abbreviation.  Titles which cannot
Xbe recognised are passed through unchanged, but diagnostic output
Xmay be obtained.
X
Xjlook uses a simple index file to speed searches.  The program starts
Xmarginally faster if the index file exists and is up-to-date, but will
Xgenerate the index itself otherwise.
X
XThe available library gives fair coverage of the biomedical literature
X(about 2000 journals). It compiles and runs on (at least) Version 7 and
XBSD 4.3 systems.
X
XThe distribution includes:
X	README		this one!
X	Makefile	
X	jlook.h
X	jlook.c
X	jindex.c
X	jsubs.c
X	jlook.1l	manual troff source
X	jlist		the journal library file
X	tst_chem_good	a test file
X	tst_full_good	"   "   "
X	tst_input	"   "   "
X	tst_alt		"   "   "
X
XCompilation:
X	edit Makefile to reflect whether your system supports re_comp and
X		re_exec regular expression functions, or recmp and regex.
X	make all
X
XCheck integrity:
X	make check
X		should do some checks without errors except that there
X		may be a complaint about no index file
X
XInstallation:
X	edit Makefile if you do not wish jlook to go in /usr/bin or the
X		library and index program to go in /usr/lib/refer
X	make library
X		to install the journal library file and create its index
X	make install
X		to install the binaries.
X
XManual:
X	put jlook.1l in the right place (sorry, the makefile does not do it)
SHAR_EOF
chmod 0440 README || echo "restore of README fails"
set `wc -c README`;Sum=$1
if test "$Sum" != "2078"
then echo original size 2078, current size $Sum;fi
echo "x - extracting jlook.1l (Text)"
sed 's/^X//' << 'SHAR_EOF' > jlook.1l &&
X.TH jlook 1 LOCAL
X.de iD
X$Header: /src/local/cmd/jlook/jlook.1l,v 1.1 90/02/03 17:21:35 daved Exp $
Xphysiol.su.oz.au
X..
X.SH NAME
Xjlook - lookup/replace journal titles or abbreviations from a standard list
X.SH SYNOPSIS
X.B jlook
X[\ \-a\ additional_library\ ]
X[\ \-C\ ]
X[\ \-d\ ]
X[\ \-e\ ]
X[ \-E\ ]
X[\ \-l\ library\ ]
X[\ \-m\fR[\fImacro\fR]\ ]
X[\ \-n\ ]
X[\ \-p\ ]
X[\ \-s\fR[\fImax_chars\fR]\ ]
X[\ \-t\ ]
X[\ \-u\fIX\fP\ ]
X[\ \-x\fR[\fItag_string\fR]\ ]
X["title"\ [\ "title2"\ ...\ ]]
X[\ -f\ file(s)\ ]
X.br
X.B jindex
X[ \-l library ]
X.SH DESCRIPTION
X.I Jlook
Xif given a Journal title or sensible abbreviation looks for an entry
Xin the journal library and prints the result on standard output.
XNormally
Xthe full title is output, but one of a number of standard abbreviations
Xdescribed below can be selected, or the
X.B \-A
Xswitch (described in more detail below)
Xcan be used to obtain all the forms for the item.
XNormally the
Xinput must match the contents of the library in a moderately complete
Xmanner.
XThe
X.B \-t
Xswitch removes the restriction of completeness, and can be helpful in
Xtrying to discover the complete title of a journal, e.g. if you know
Xthe first few words but not the rest.
X.P
XUsed as a filter or given input files
Xfollowing the
X.B \-f
Xswitch, any lines beginning with "%J " (see pubindex, refer or indexbib) are
Xtaken to contain journal titles and are looked up in the same way.
XThe line contents are replaced by the standard form in the library, if
Xfound.
XAny journal line that is not so replaced, and
Xall other lines, are passed through unchanged.
XA different leading string
Xcan be selected with the
X.B \-m
Xswitch.
XThis switch causes the leading string to be changed from "%J " to
X".ds [J " and thus enables
X.I jlook
Xto be used as a filter for refer(1) output.
XOther strings can be used by
Xplacing them immediately after the -m switch (e.g. -m"#j " would cause
Xlines beginning with "#j " to be processed).
X.P
XNormally, full titles are output, but an abbreviation can be selected with
Xthe
X.B \-u\fIX\fP
Xswitch, where
X.I X
Xmust be a single upper case letter code for the abbreviations supported
Xby the library.  As distributed,
X.I X
Xcan be one of:
X.TP
X.B C
Xfor
X.I "Chemical Abstracts"
X.TP
X.B I
Xfor
X.I "Index Medicus"
Xor
X.TP
X.B W
Xfor
X.I "World List of Scientific Periodicals",
X.PP
XThe selected abbreviation can be modified:
Xfull-stops in the abbreviations can be eliminated with the
X.B \-p
Xswitch; and unpaddable blanks will be substituted
Xfor spaces within the title if the
X.B \-s\fI[max_chars]\fP
Xswitch is used.
XIn the latter case, a maximum of
X.I max_chars
Xcharacters will be output without interpreting a space as a space (default 10).
XAll forms of output can be converted to upper-case only though use of the
X.B \-C
Xswitch.
X.P
XJournal abbreviations (or names) which cannot be found in the library can
Xbe identified with the 
X.B \-e
Xswitch, which causes problem "%J" lines to be written to standard error, or
Xthe
X.B \-x
Xswitch which causes them to be added to the output stream as lines labelled
Xwith "%X " (or ".\\"X " if the -m switch has been used) or with the string
Ximmediately following the -x.
XIf the
X.B \-E
Xswitch is used instead of -e, a message "no errors found" will also be generated
Xif appropriate.
XIf only the errors are desired, the
X.B \-n
Xswitch will suppress normal output.
X.P
XThe
X.B \-l \fIlib_file\fP
Xswitch enables a journal library file named by the argument
Xwhich follows it
X.I (lib_file)
Xto be used instead of /usr/lib/refer/jlist.
XThe file will be sought first in the working directory, then in
X/usr/lib/refer.
XIn order to use an alternative library file efficiently,
Xthe library index should first be created with
Xthe command "/usr/lib/refer/jindex -l library_file".
X.P
XThe
X.B \-a
Xswitch provides for
Xan additional library given by the next argument also to be searched
Xfor items not found in the standard library.
X.P
XThe
X.B \-d
Xswitch is for debugging purposes.
XMore than one -d switch causes even more
Xverbose output.
X.P
XSearching of the library is linear but a simple index of entry points for
Xeach letter of the alphabet speeds the process slightly.
XBecause of the
Xsubstantial variation in abbreviation formats,  a more sophisticated
Xindex is difficult to formulate.
XThe index must be rebuilt if the
Xlibrary is modified.
XAn out of date index will cause
X.I jlook
Xto construct one internally which slows its startup.
X.P
XThe lookup process is much faster if the input journal names
Xare already in the form of a standard
Xabbreviation.
XThus it is worth putting files in a regularly used database
Xthrough
X.I jlook
Xonce to
Xstandardise them.
XThis can be done with something like:
X.ti 3c
Xjlook -uC -f file > NEW  && cp NEW file && rm -f NEW
X.SH LIBRARY FILES
XThe default library file begins with comments on its format.
XIt is
Xpossible to create files with support for different abbreviation systems.
XEach system must have a key letter in the "Keys: " line at the start
Xof the file.
XSuch letters can be chosen from the upper case alphabet with the exception
Xof the reserved letters E,F,V, and U.
XThe description which follows applies to the distributed
Xlibrary (Keys CIW).
X.P
XThe entries in the library file
Xconsist of a series of lines for each journal, separated by a
Xblank line.
X(For any one journal argument,
Xthe complete entry can be displayed using the
X.B \-A
Xswitch.)
XThe lines are tagged with the following leading letters,
Xseparated from the entry by white space:
X.in 2c
X.nf
XF	The full title of the Journal
XC	The Chemical Abstracts abbreviation
XI	The Index Medicus abbreviation
XW	The World List abbreviation
XV	A variant to be accepted (e.g. local abbreviation)
XU	Undefined input
XE	Exceptional entry - apparently out of alphabetic order
XS	Sort string
X*	A regular expression for back matching
X.fi
X.in
XThe F,C,I and W lines must appear once and only 
Xonce per entry, but can be combined where appropriate.
XE lines
Xreplace F lines where an accepted abbreviation does not start
Xwith the same letter as the full title (e.g. anglicized abbreviations of
Xforeign titles).
XAn E entry must appear
Xalphabetically under the first letter of that abbreviation.
XIt must
Xalso appear under the first letter of the full title.
XE and F lines
Xare mutually exclusive.
XThere can be any number of V lines.
XFor particularly troublesome entries, for example where an abbreviation
Xdoes not correspond to the leading portion of the full word (e.g.
XZbl. for Zentralblatt), a regular expression may be included in the
Xentry, labelled with an '*'.
XSuch expressions will be used in an attempt
Xto match against the input if all else fails.
XU lines replace F lines
Xwhere a particular form is regarded as a known error, the most
Xcommon instance being where a journal name is equivocal unless
Xa city of publication is included.
XAn S line is treated only as a comment by
X.I jlook,
Xbut may be present to assist automatic sorting of the libary;
Xits contents will be used for the sort instead of the full title.
X.P
XThe library must be kept in alphabetic
Xorder as far as the first letter of the full title of each entry.
XEntries starting with numbers are grouped together with names starting
Xwith 'Z'.
X.SH FILES
X/usr/bin/jlook
X.br
X/usr/lib/refer/jlist - the default library
X.br
X/usr/lib/refer/jlist.index - default offset index to speed searches
X.br
X/usr/lib/refer/jindex - a program to build the index
X.SH DIAGNOSTICS
X"Index predates ...."
Xmeans the index is out of date; this is a warning only and,
Xin the case of the default library,
Xshould be drawn to the attention of the system supervisor.
X.br
XIf an entry is not found, the program exits with a (non-zero) error status.
XIn addition, if the
X.B \-x
Xswitch is used, the offending journal
Xlines will be copied into the output, labelled in accord
Xwith the -m and -x switches, in order
Xthat they can be identified.
X.SH SEE ALSO
Xreflist.1l
X.SH BUGS
XThe program depends upon the database.
X.P
XThe distributed database contains diacritical marks
Xof the form \\*\(aa, \\*\(ga \\*: and \\*;,
Xwhich
Xrequire troff definitions such as those provided in the ms(7) and mm(7)
Xmacro
Xpackages or some further substitution or elimination if troff is not being
Xused.
X.P
XExpansion of abbreviated journal titles is not foolproof.
XAbbreviated forms
Xshould be indicated by the use of full stops.
XNon-trivial words should have
Xthe first letter capitalized.
XFor example: "J. Physiol." is a "good"
Xabbreviation for "Journal of Physiology" whereas "J physiol" is not.
X.P
XAn additional library used with the
X.B \-a
Xswitch must have the same Keys as the primary library.
X.P
XThe
X.I "World List"
Xentries are inconsistent.  A major feature of the original
X.I List
Xwas the use of lower case for the first letter of adjectives in
Xtitles (except for the first word of a title), a feature that appears
Xto appeal to some editors who insist on its use.
XUnfortunately, the
X.I List
Xwas not reprinted in full after 1969, and only supplements were issued
Xuntil 1980, after which the
X.I List
Xwas disbanded.  
XThe supplements list all titles in
X.I "upper case only".
XThese have been converted to mixed case following the original rules.
X(Upper case output can be obtained with the
X.B \-C
Xswitch.)
X.SH AUTHOR
X.nf
XD.F. Davey,
XDepartment of Physiology,
XUniversity of Sydney.
X.sp
Xdaved@physiol.su.oz
SHAR_EOF
chmod 0440 jlook.1l || echo "restore of jlook.1l fails"
set `wc -c jlook.1l`;Sum=$1
if test "$Sum" != "9207"
then echo original size 9207, current size $Sum;fi
echo "x - extracting jlook.c (Text)"
sed 's/^X//' << 'SHAR_EOF' > jlook.c &&
X/* jlook.c
X *
X *	Copyright D.F. Davey, University of Sydney
X *
X *	Permission is granted for the distribution of this software
X *	for non-profit purposes and provided this notice remains intact
X *
X *	daved@physiol.su.oz.au
X *
X *	The debugging switch can be used in two ways. Multiple -d's are
X *	additive.  -dN where N is an integer selects particular debugging
X *	diagnostics:
X *	10	re comparisons with variants
X *	11	library file seeks
X */
X
X#ifndef lint
Xstatic char rcsid[] =
X"$Header: /src/local/cmd/jlook/jlook.c,v 1.3 90/12/22 19:18:40 daved Exp $";
Xstatic char node[] = "physiol.su.oz.au";
X#endif /* lint */
X
X#include <stdio.h>
X#include "jlook.h"
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <ctype.h>
X#ifdef REGEXP
X#include <regexp.h>
X#endif /* REGEXP */
X
XFILE	* infp,
X	* outfp,	/* stdout or /dev/null */
X	* altfp;	/* additional jlist file */
Xchar	* xstr,
X	* leadin,	/* initially %J, reset if refer macros input */
X	* altfname;
Xint	errflg,
X	not_found,
X	nodots,
X	caps,
X	maxwid,		/* maximum length title with unpaddable blanks */
X	eflag,
X	mflag,
X	tflag,
X	xflag,
X	Eflag,
X	Allflag,
X	fflag,
X	altfile,
X	badcount;
Xlong	altstart;
X
X#ifdef COMPAT
XWarnCompat(c)
X	char c;
X{
X	fprintf
X	(	stderr,
X		"%s: Warning: switch -%c is obsolete. Use -u%c instead.\n",
X		progname,
X		c,
X		toupper(c)
X	);
X}
X#endif /* COMPAT */
X
X
Xmain(argc,argv)
X	int argc; char **argv;
X{
X	register int	i;
X	struct stat	sbuf;
X	long		mtime,
X			time();
X	char		*listfile,
X			*standard(),
X			*format();
X
X	leadin = "%J ";
X	listfile = LISTFILE;
X	if((progname = strrchr(argv[0],'/')) != NULL)
X		progname++;
X	else progname = argv[0];
X
X	output = full;
X	outfp = stdout;
X
X	while(--argc)
X	{
X		if(**++argv == '-')
X		  switch(*++*argv)
X		  {
X			case 'A':
X				Allflag++;
X				break;
X			case 'a':
X				altfile++;
X				argc--;
X				altfname = *++argv;
X				if((altfp = fopen(altfname,"r"))== NULL)
X					fatal("cannot open: %s\n",*argv);
X				break;
X#ifdef COMPAT
X			case 'c':
X				useab = 'C';
X				WarnCompat(**argv);
X				break;
X#endif /* COMPAT */
X			case 'C':
X				caps++;
X				break;
X			case 'd':
X				if(*++*argv)
X					debug = atoi(*argv);
X				else
X					debug++;
X				break;
X			case 'E':
X				Eflag++;
X			case 'e':
X				eflag++;
X				break;
X			case 'f':
X				fflag++;
X				break;
X#ifdef COMPAT
X			case 'i':
X				useab = 'I';
X				WarnCompat(**argv);
X				break;
X#endif /* COMPAT */
X			case 'l':
X				listfile = *++argv;
X				argc--;
X				break;
X			case 'm':	/* macros (from refer) */
X				mflag++;
X				if(*++*argv != '\0')
X					leadin = *argv;
X				else
X					leadin = ".ds [J ";
X				break;
X			case 'n':
X				if((outfp = fopen("/dev/null","w")) == NULL)
X					fatal("cannot open","/dev/null");
X				break;
X			case 'p':
X				nodots++;
X				break;
X			case 's':
X				if(*++*argv)
X					maxwid = atoi(*argv);
X				else
X					maxwid = 10;
X				break;
X			case 't':
X				tflag++;
X				break;
X			case 'u':
X				if((useab = *++*argv) == '\0')
X					fatal("no key following -u\n");
X				if(islower(useab))
X					useab=toupper(useab);
X				break;
X#ifdef COMPAT
X			case 'w':
X				useab = 'W';
X				WarnCompat(**argv);
X				break;
X#endif /* COMPAT */
X			case 'X':
X				xflag++;
X			case 'x':
X				xflag++;
X				if(*++*argv != '\0')
X					xstr = *argv;
X				break;
X			default:
X				fatal("unrecognized switch: %s\n", *argv);
X		  }
X		else
X			break;
X	}
X	if(!xstr)
X	{
X		if(mflag)
X			xstr = ".\\\"X ";
X		else
X			xstr = "%X ";
X	}
X
X	listopen(listfile);	/* sets lfp - may prepend path */
X	if(stat(listfile,&sbuf))
X		fatal("cannot stat: %s",listfile);
X	mtime = sbuf.st_mtime;
X	while(time((long *)0) - mtime < 10)
X	{
X		/* don't fail if a large library caught being rewritten */
X		sleep(10);
X		if(stat(listfile,&sbuf))
X			fatal("cannot stat: %s\n",listfile);
X		mtime = sbuf.st_mtime;
X	}
X	(void) strcpy(indfile,listfile);
X	(void) strcat(indfile,".index");
X	if(debug)
X		fprintf(stderr,"list file = %s\nindex file = %s\n",
X			listfile,indfile);
X	
X	/*
X	** now get the index if it exists and is up-to-date and is readable
X	*/
X	if(stat(indfile,&sbuf))
X	{
X		warn("no index for %s, making internal index\n", listfile);
X		l_index();
X	}
X	else if(sbuf.st_mtime < mtime)
X	{
X		warn("index predates %s, making internal index\n", listfile);
X		l_index();
X	}
X	else if((indfp = fopen(indfile,"r")) ==  NULL)
X	{
X		warn("cannot open %s, making internal index\n", indfile);
X		l_index();
X	}
X	else readindex();
X
X	/*
X	** if an alternate file was specified, make sure the keys match
X	*/
X	if(altfile)
X	{
X		get_keys(altfp,1);
X		altstart = ftell(altfp);
X	}
X	if(strchr(keys,useab) == NULL)
X		fatal("abbreviation key %c not in library\n", useab);
X
X	/*
X	** now do the work - either names in args, or files
X	*/
X	if(argc && !fflag)
X	{
X		char * item;
X		while(argc--)
X		{
X			/* argv already points to "next" arg */
X			if
X			(
X				!(
X					(**argv >= 'A' && **argv <= 'Z')
X					||	/* for number proceeedings */
X					(**argv >= '1' && **argv <= '9')
X				)
X			)
X				fatal
X				(
X					"%s capital or number: %s\n",
X					"non file argument must start with",
X					*argv
X				);
X			not_found = 0;
X			item = standard(*argv++);
X			if(not_found == 0)
X			{
X				if(equivocal)
X					errflg = 1;
X				if(caps || nodots)
X					printf("%s\n",
X						format(item,nodots,caps,0));
X				else
X					printf("%s\n",item);
X				if(Allflag)
X				{
X					for(i = 0; i<nkeys; i++)
X						printf
X						(
X							"%c %s\n",
X							keys[i],
X							&abbrev[np[keys[i] -
X								'A']-1][0]
X						);
X					for(i = 0; i < nvariant; i++)
X						printf("V %s\n",&variant[i][0]);
X					for(i = 0; i < ngrep; i++)
X						printf("* %s\n",&grep[i][0]);
X				}
X			}
X			else if(Eflag)
X				printf("%s: no match found\n", *(argv-1));
X		}
X		exit(errflg);
X	}
X	if(argc) /* && flag */
X	{
X		while(argc--)
X		{
X			if((infp = fopen(*argv++,"r")) == NULL)
X				fatal("cannot open: %s\n", *--argv);
X			process();
X			if(fclose(infp) == EOF)
X				fatal("cannot fclose: %s\n", *argv);
X		}
X		uexit(errflg);
X	}
X	/* else do standard input */
X	infp = stdin;
X	process();
X	uexit(errflg);
X}
X
Xuexit(n)
X	int n;
X{
X	if(!n && Eflag)
X		warn("no errors found\n");
X	exit(n);
X}
Xprocess()
X{
X	char	linebuf[BUFSIZ],
X		* format(),
X		* standard(),
X		* fixcase();
X
X	while(fgets(linebuf,sizeof linebuf,infp) != NULL)
X	{
X		if(strlen(linebuf) >= sizeof linebuf -1)
X			warn("input line too long: %s\n",linebuf);
X		not_found=0;
X		linebuf[strlen(linebuf)-1] = '\0';
X		if(strncmp(linebuf,leadin,strlen(leadin)) == 0)
X		{
X			fprintf
X			(
X				outfp,
X				"%s%s\n",
X				leadin,
X				(nodots || maxwid || caps) ?
X				   format
X				   (
X					standard(&linebuf[strlen(leadin)]),
X					nodots,
X					caps,
X					maxwid
X				   )
X				   : standard(&linebuf[strlen(leadin)])
X			);
X			if(equivocal)
X				errflg = 1;
X			if
X			(
X				(xflag && (not_found || equivocal))
X				||
X				xflag > 1
X			)
X				fprintf
X				(
X					outfp,
X					"%s%s\n",
X					xstr,
X					&linebuf[strlen(leadin)]
X				);
X			if((not_found || equivocal) && eflag)
X				fprintf
X				(
X					stderr,
X					"%%J %s\n",
X					&linebuf[strlen(leadin)]
X				);
X		}
X		else
X			fprintf(outfp,"%s\n",linebuf);
X	}
X}
Xstatic char * standard(s)
X	char *s;
X{
X	char		* regcmp(),
X			*make_re(),
X			* re,
X			*re_text,
X			*sre,
X			*sought;
X	static char	lastin[BUFSIZ];
X	static int	last_status;
X	int		i,
X			this_letter,
X			alt_done = 0,
X			fixed = 0;
X	FILE		*searchfile;
X	long		startpoint,
X			endpoint;
X
X	/*
X	** this little trick can vastly speed up processing of input
X	** containing sequential journal names which are identical
X	** - such as with lists of contents of a particular journal issue
X	*/
X	if(strcmp(s,lastin) == 0)
X	{
X		if(last_status)
X			return(s);
X		return(output);
X	}
X	else
X	{
X		(void) strncpy(lastin,s,sizeof lastin);
X		last_status = 0;
X	}
X
X	if(*s >= '0' && *s <= '9')
X		this_letter = 25;	/* 'Z' for numbered proceedings */
X	else
X	{
X		if(*s < 'A' || *s > 'Z')
X			goto no_no;
X		this_letter = *s-'A';
X	}
X	searchfile = lfp;
X	startpoint = letterseek[this_letter];
X	if(this_letter < 25)
X		endpoint = letterseek[this_letter+1];
X
Xdo_alt:
X	sought = s;
Xtrylower:
X	if(fseek(searchfile,startpoint,0) < 0)
X		fatal("seek failed\n");
X	if(debug == 11)
X		fprintf(stderr,"seek took us to %ld\n",ftell(searchfile));
X	while (get_listing(searchfile))
X	{
X		if(debug>2 && debug < 10)
X		{
X			fprintf(stderr,"comparing <%s> and:\n\tF<%s>\n",sought,
X			full);
X			for(i = 0; i<nkeys; i++)
X				fprintf
X				(
X					stderr,
X					"\t%c<%s>\n",keys[i],
X					&abbrev[np[keys[i] - 'A']-1][0]
X				);
X		}
X		/*  full title? */
X		if ( strcmp(sought,full) == 0)
X		{
X			if(debug > 2 && debug < 10)
X				fprintf(stderr,"returning %s\n",output);
X			return(output);
X		}
X		/*  standard abbreviation or full title? */
X		for(i=0; i<nabbrev; i++)
X		{
X			if(debug > 2 && debug < 10)
X				fprintf (stderr,
X				"comparing <%s> and <%s>\n",
X				sought,&abbrev[i][0]);
X			if ( strcmp(sought,&abbrev[i][0]) == 0)
X				return(output);
X		}
X		/* listed variant - i.e. locally accepted */
X		for(i = 0; i< nvariant; i++)
X		{
X			if(debug>2 && debug < 10)
X				fprintf(stderr,"comparing <%s> against <%s>\n",
X					sought,&variant[i][0]);
X			if(strcmp(sought,&variant[i][0]) == 0)
X				return(output);
X		}
X		if(this_letter < 25 && position >= endpoint)
X			break;
X	}
X
X	/* getting here means the input was not in the jlist file */
X	/* so can an re match get it against the full title ? */
X
X	/* start again in the jlist */
X	if(fseek(searchfile,startpoint,0) < 0)
X		fatal("seek failed\n");
X	if(!alt_done)
X		re = regcmp("^",re_text=make_re(sought),0);
X	while (get_listing(searchfile))
X	{
X		if(debug>1 && debug < 10)
X		{
X			fprintf (stderr,
X			"comparing re <%s> and: <%s>\n",
X			re_text,full);
X		}
X		if(regex(re,full,0))
X		{
X			free(re);
X			return(output);
X		}
X		if(this_letter < 25 && position >= endpoint)
X			break;
X	}
X	/* getting here means the input was not a full title in the jlist */
X	/* so can we match against an abbreviation? */
X	if(debug)
X		fprintf(stderr,"match against full titles failed\n");
X	/* start again in the jlist */
X	if(fseek(searchfile,startpoint,0) < 0)
X		fatal("seek failed\n");
X	while (get_listing(searchfile))
X	{
X		if(debug>1 && debug < 10)
X		{
X			fprintf (stderr,
X			"comparing re <%s> and: <%s>\n",
X			re_text,full);
X		}
X		for(i = 0; i< nabbrev; i++)
X		{
X			if(debug>2 && debug < 10)
X				fprintf(stderr,"comparing re against <%s>\n",
X					&abbrev[i][0]);
X			if(regex(re,&abbrev[i][0],0))
X			{
X				free(re);
X				return(output);
X			}
X		}
X		for(i = 0; i< nvariant; i++)
X		{
X			if(debug>2 || debug == 10)
X				fprintf(stderr,"comparing <%s> against <%s>\n",
X					re, &variant[i][0]);
X			if(regex(re,&variant[i][0],0))
X			{
X				free(re);
X				return(output);
X			}
X		}
X			/* if there is a grep string - try it */
X		for(i = 0; i< ngrep; i++)
X		{
X			sre = regcmp("^",&grep[i][0],0);
X			if(debug>2 && debug < 10)
X				fprintf(stderr,"trying grep string %s\n",
X					&grep[i][0]);
X			if(regex(sre,sought,0))
X			{
X				free(re);
X				free(sre);
X				return(output);
X			}
X			free(sre);
X#if	defined(RE_EXEC) || defined(REGEXP)
X			/* a nasty compatibility problem: re_comp keeps
X				its own copy of the re, so we can't reuse it */
X			free(re);
X			re = regcmp("^",re_text,0);
X#endif /* defined(RE_EXEC || defined(REGEXP) */
X		}
X		if(this_letter < 25 && position >= endpoint)
X			break;
X	}
X	/*
X	** if we have still failed by the time we get here, one possibility
X	** is that the input is all upper case, such as produced by some
X	** bibliographic software.  This will not match the data base.
X	** so...
X	*/
X	if(!fixed && allupper(s))
X	{
X		register char * tmp;
X		tmp = fixcase(s);
X		if(debug)
X			fprintf(stderr, "trying fixed case <%s>\n",
X					tmp);
X		sought = tmp;
X		fixed++;
X		goto trylower;
X	}
X	fixed = 0;
X	/* failed on this search file - if we have an alternate file
X		and have not done it yet, now is the time */
X	if(altfile && alt_done++ == 0)
X	{
X		if(debug)
X			fprintf(stderr,"using alternate file %s\n",altfname);
X		startpoint = altstart;
X		endpoint = 10000000L;
X		searchfile = altfp;
X		goto do_alt;
X	}
X	free(re);
Xno_no:
X	not_found = errflg = 1;	/* errflg is never reset */
X	if(badcount++ == 10)
X		(void) nice(6);	/* this person isn't trying ? */
X	last_status = 1;	/* in case we are asked again */
X	return(s); 		/* what we were given - failed! */
X}
Xchar * make_re(in)
X	char *in;
X{
X	static char	* dotstr = "[-a-z.,'`\"\\*:; ]*"; /* '`"\o and \*:
X								for diacrits */
X	static char	* enddot = "[a-z.]*";
X	static char	* colonstr = "[-:;., ]*";
X	static char	* closestr = "[]a-z). ]*";	/* ) or ] */
X	static char	* seriesstr = "[[Series cton]*"; /* Series or Section */
X		/* diacrits:  this is a mess because we want to accept
X			a number of input styles:
X			   tpr:	<diacrit> slosh 'o' letter
X			   macro packages: letter slosh '*' ['`:;]
X			   troff: slosh o delim letter diacrit letter ? will it?
X		 */
X	static char	*diacrits = "[\"'`^\\\\o*:;]*";
X	static char	buf[RE_MAX];
X	int		enddone = 0;
X	register char	*tmp,
X			*out,
X			*start;
X
X	out = buf;
X	start = in;
X
X		/* convert to a useful re */
X	while(*in)
X	    switch(*in)
X	{
X		case '.':	/* an abbreviation */
X			if(*(in +1) == '\0')
X			{
X				tmp = enddot;
X				enddone++;
X			}
X			else
X				tmp = dotstr;
X			while(*tmp)
X				*out++ = *tmp++;
X			if(*++in == ' ')
X				in++;
X			break;
X		case ' ': /* shouldn't get space after dot cause of above */
X			while(*(in+1) == ' ')
X				in++;	/* absorb multiple spaces */
X			if(*(in +1) == '\0')
X			{
X				in++;
X				break;
X			}
X			tmp=dotstr;
X			while(*tmp)
X				*out++ = *tmp++;
X			in++;
X			break;
X		case ',':	/* could be there, but maybe not */
X			*out++ = *in++;
X			*out++ = '*';
X			break;
X		case '-':	/* treat like ':' but strip any leading space
X				   and use any case of following letter (below) 
X			         */
X			if (*(out-1) == ' ')
X				out--;
X		case ';':	/* typo? */
X		case ':':	/* tricky - might be there, with or without
X					following space, or as a '-' instead */
X			tmp = colonstr;
X			while(*tmp)
X				*out++ = *tmp++;
X			if(*in == '-')
X			{
X				in++;
X				if(isalpha(*in))
X				{
X					*out++ = '[';
X					if(isupper(*in))
X						*out++ = tolower(*in);
X					else
X						*out++ = toupper(*in);
X					*out++ = *in++;
X					*out++ = ']';
X				}
X				else if(*in == ' ')
X					in++;
X				break;
X			}
X			else if(*++in == ' ')
X				in++;
X			break;
X		case ']':
X		case ')':	/* might be there, might not, also might
X					have a preceeding '.' missing */
X			if(*(out-1) == '.' || *(out -1) == ' ')
X				out--;
X			tmp = closestr;
X			while(*tmp)
X				*out++ = *tmp++;
X			in++;
X			break;
X		case '(':	/* might be there, might not */
X#ifndef RE_COMP
X			*out++ = '\\';
X#endif /* RE_COMP */
X			*out++ = *in++;
X			*out++ = '*';
X			break;
X		case 'A':
X		case 'B':
X		case 'C':
X			if
X			(
X			    !(
X				*(in+1) == '\0'		/* trailing letter */
X				||
X				(			/* letter dot */
X					*(in+1) == '.'
X					&&
X					*(in+2) == '\0'
X				)
X			     )
X			)
X				goto regular;
X			tmp = seriesstr;
X			while(*tmp)
X				*out++ = *tmp++;
X			*out++ = *in++;
X			*out++ = '.';
X			*out++ = '*';
X			if(*in != '\0')
X				in++;	/* that letter dot case */
X			break;
X
X			/* diacrits */
X		case '\'':			/* something like "l'Acad" */
X			*out++ = '*';		/* the preceeding letter */
X			if (*(in+1) == 's')	/* quite possible the ' is */
X			{			/* an error		   */
X				*out++ = *in++;
X				*out++ = '*';
X				break;
X			}
X		case '"':
X		case '^':
X		case '`':
X			if(*(in+1) != '\\' || *(in+2) != 'o')	/* tpr */
X			{
X				*out++ = *in++;
X				*out++ = '*';
X				break;
X			}
X			tmp = diacrits;
X			while(*tmp)
X				*out++ = *tmp++;
X			in += 3; /* skip current char plus \o */
X			break;
X			/* things that might need to be sloshed */
X		case '\\':
X			if(*(in+1) == '*')	/* macro type diacit */
X			{
X				in++;		/* ignore slosh */
X				in++;		/* ignore asterisk */
X				in++;		/* ignore the diacrit */
X				tmp = diacrits;
X				while(*tmp)
X					*out++ = *tmp++;
X				break;
X			}
X			else if (*(in+1) == ' ')/* unpaddable space */
X			{
X				in++;		/* ignore slosh */
X				break;
X			}
X		case '*':
X		case '[':
X		/* case ']': */
X			*out++ = '\\';
X			*out++ = *in++;
X			break;
X		default:
X			/*
X			** special case of 2/3 letter words which may/may
X			** not be capitalized
X			*/
X			if
X			(
X				in > start
X				&&
X				*(in-1) == ' '
X				&&
X				isupper(*in)
X				&&
X				*(in+1)
X				&&
X				(
X					*(in+2) == ' '
X					||
X					(
X						*(in+2)
X						&&
X						*(in+3) == ' '
X					)
X				)
X			)
X			{
X				*out++ = '[';
X				*out++ = tolower(*in);
X				*out++ = *in++;
X				*out++ = ']';
X				break;
X			}
Xregular:
X			*out++ = *in++;
X			break;
X	}
X	while(*(out-1) == ' ' || *(out-1) == '\t') /* clobber trailing white */
X		out--;
X	if(!enddone)	/* might have something left of end of last word */
X	{
X		tmp = enddot;
X		while(*tmp)
X			*out++ = *tmp++;
X	}
X	if(!tflag)
X		*out++ = '$';
X	if(out >= buf + RE_MAX)
X		fatal("re buffer size exceeded: %s\n",buf);
X	*out = '\0';
X	if(debug)
X		fprintf(stderr,"re: %s\n",buf);
X	return(buf);
X}
Xchar *
Xformat(s,nodots,caps,maxwid)
X	char *s;
X	int nodots,caps,maxwid;
X{
X	/*
X	**	eliminate fullstops in abbreviations
X	**	place sloshes before spaces
X	**	convert to uppercase only
X	*/
X
X	register	count = 0;
X	register	char	*lp;
X	static		char	lbuf[256];
X
X	lp = lbuf;
X	while(*s)
X	{
X		if(nodots && *s == '.')
X		{
X			s++;
X			continue;
X		}
X		if(caps && islower(*s))
X			*s = toupper(*s);
X		if(maxwid && *s == ' ')
X		{
X			if(count > maxwid)
X			{
X				*lp++ = *s++;
X				count = 0;
X				continue;
X			}
X			*lp++ = '\\';
X		}
X		*lp++ = *s++;
X		count++;
X	}
X	*lp = '\0';
X	return(lbuf);
X}
X
X#if	defined(REGEXP) && defined(RE_EXEC)
X#	include "use only one of REGEXP or RE_EXEC"
X#endif	/* defined(REGEXP) && defined(RE_EXEC) */
X
X#ifdef REGEXP
X	/*  these functions are not an attempt at complete duplication of
X	 *  the version 7 ones, but will do the job for the calls above
X	 */
Xstatic	char	re_incore[RE_MAX];
Xint		re_errflag;
Xstatic	regexp	*regprog;
Xregex(re,str,n)
X	char * re, * str;
X	int n;
X{
X	int	retval;
X
X	if(strcmp(re,re_incore))
X	{
X		if (re_errflag++ == 0)
X			warn("regex problem: was <%s>; request <%s>\n",
X				re_incore,re);
X		return(0);	/* i.e. no match */
X	}
X
X	if(n || re == NULL)
X		fatal("internal error: regex given invalid argument\n");
X	if (debug > 2 && debug < 10)
X		fprintf(stderr,"regexec <%s> <%s>",re,str);
X	if((retval = regexec(regprog,str)) == -1)
X	{
X		warn("regexec internal error: %s\n",str);
X		return(0);
X	}
X	if (debug > 2 && debug < 10)
X		fprintf(stderr," returned %d\n",retval);
X	return(retval);
X}
Xchar *
Xregcmp(s1,s2,n)
X	char * s1,*s2;
X	int n;
X{
X	char	* bufp;
X	char	* malloc(),
X		* re_comp();
X
X#ifdef lint
X	if(0)
X		regerror("keep lint smiling\n");
X#endif /* lint */
X
X	re_errflag = 0;
X	if(n)
X		fatal("internal error: regcmp given invalid argument");
X	if((bufp = malloc((unsigned)strlen(s1)+strlen(s2)+1)) == NULL)
X		fatal("malloc failed in regcmp\n");
X	(void) strcpy(bufp,s1);
X	(void) strcat(bufp,s2);
X	(void) strcpy(re_incore,bufp);			/* keep a record */
X	if(regprog)
X		free((char *)regprog);
X	if((regprog = regcomp(bufp)) == NULL)
X	{
X		/*
X		** if we get this error, try to recover with a string
X		** that should always compile and never match so we must
X		** pass the input through
X		*/
X		(void) strcpy(bufp,"UN_JOURNAL_ERROR_STOPPER");
X		regprog = regcomp(bufp); /* should always compile */
X	}
X	return(bufp);
X}
X/*
X** prevent fatal errors
X*/
Xvoid
Xregerror(s)
X	char *s;
X{
X	warn("%s\n",s);
X}
X#endif /* REGEXP */
X#ifdef RE_EXEC
X	/*  these functions are not an attempt at complete duplication of
X	 *  the version 7 ones, but will do the job for the calls above
X	 */
Xstatic	char	re_incore[RE_MAX];
Xint		re_errflag;
Xregex(re,str,n)
X	char * re, * str;
X	int n;
X{
X	int retval;
X
X	if(strcmp(re,re_incore))
X	{
X		if (re_errflag++ == 0)
X			warn("regex problem: was <%s>; request <%s>\n",
X				re_incore,re);
X		return(0);	/* i.e. no match */
X	}
X
X	if(n || re == NULL)
X		fatal("internal error: regex given invalid argument\n");
X	if (debug > 2 && debug < 10)
X		fprintf(stderr,"re_exec <%s> <%s>",re,str);
X	if((retval = re_exec(str)) == -1)
X	{
X		warn("re_exec internal error: %s\n",str);
X		return(0);
X	}
X	if (debug > 2 && debug < 10)
X		fprintf(stderr," returned %d\n",retval);
X	return(retval);
X}
Xchar *
Xregcmp(s1,s2,n)
X	char * s1,*s2;
X	int n;
X{
X	char	* bufp;
X	char	* malloc(),
X		* re_comp(),
X		* errmes;
X
X	re_errflag = 0;
X	if(n)
X		fatal("internal error: regcmp given invalid argument");
X	if((bufp = malloc((unsigned)strlen(s1)+strlen(s2)+1)) == NULL)
X		fatal("malloc failed in regcmp\n");
X	(void) strcpy(bufp,s1);
X	(void) strcat(bufp,s2);
X	(void) strcpy(re_incore,bufp);			/* keep a record */
X	if((errmes = re_comp(bufp)) != 0)
X	{
X		warn("re_comp error: %s: %s\n", errmes, bufp);
X		/*
X		** if we get this error, try to recover with a string
X		** that should always compile and never match so we must
X		** pass the input through
X		*/
X		(void) strcpy(bufp,"UN_JOURNAL_ERROR_STOPPER");
X		(void) re_comp(bufp); /* should always compile */
X	}
X	return(bufp);
X}
X#endif /* RE_EXEC */
X
X/* VARARGS1 */
Xwarn(fmt,a1,a2,a3,a4,a5,a6,a7,a8,a9)
X	char	* fmt;
X	long	a1,a2,a3,a4,a5,a6,a7,a8,a9;
X{
X	fprintf(stderr,"%s: ", progname);
X	fprintf(stderr, fmt, a1,a2,a3,a4,a5,a6,a7,a8,a9);
X}
X
Xallupper(p)
X	char *p;
X{
X	for( ; *p != '\0'; p++)
X		if(*p >= 'a' && *p <= 'z')
X			return (0);
X	return(1);
X}
X
Xchar * fixcase(p)
X	char *p;
X{
X	register int	lastwasup;
X	register char	* out;
X	static   char	outline[BUFSIZ];
X
X	for(out=outline, lastwasup=0; *p != '\0'; p++, out++)
X	{
X		if (*p >= 'A' && *p <= 'Z')
X		{
X			if(lastwasup)
X				*out = *p - 'A' + 'a';
X			else
X			{
X				lastwasup = 1;
X				*out = *p;
X			}
X		}
X		else
X		{
X			lastwasup = 0;
X			*out = *p;
X		}
X	}
X	*out = '\0';
X	return(outline);
X}
SHAR_EOF
chmod 0440 jlook.c || echo "restore of jlook.c fails"
set `wc -c jlook.c`;Sum=$1
if test "$Sum" != "21161"
then echo original size 21161, current size $Sum;fi
echo "x - extracting jindex.c (Text)"
sed 's/^X//' << 'SHAR_EOF' > jindex.c &&
X/* jindex.c
X *
X *	Copyright D.F. Davey, University of Sydney
X *
X *	Permission is granted for the distribution of this software
X *	for non-profit purposes and provided this notice remains intact
X *
X *	daved@physiol.su.oz.au
X */
X
X#ifndef lint
Xstatic char rcsid[] =
X"$Header: /src/local/cmd/jlook/RCS/jindex.c,v 1.1 90/02/04 14:35:14 daved Rel $";
Xstatic char node[] = "physiol.su.oz.au";
X#endif /* lint */
X
X#include <stdio.h>
X#include "jlook.h"
X
Xmain(argc,argv)
X	int argc; char **argv;
X{
X	char * listfile = LISTFILE;
X
X	if((progname = strrchr(argv[0],'/')) != NULL)
X		progname++;
X	else progname = argv[0];
X
X	while(--argc)
X	{
X		if(**++argv == '-')
X		  switch(*++*argv)
X		  {
X			case 'd':
X				if(*++*argv)
X					debug = atoi(*argv);
X				else
X					debug++;
X				break;
X			case 'l':
X				listfile = *++argv;
X				argc--;
X				break;
X			default:
X				fatal("unrecognized switch: %s\n",*argv);
X		  }
X		else
X			break;
X	}
X
X	listopen(listfile);	/* sets lfp - may prepend path */
X	(void) strcpy(indfile,listfile);
X	if((indfp = fopen(strcat(indfile,".index"),"w")) == NULL)
X		fatal("cannot open: %s\n", indfile);
X	indexing++;
X	l_index();
X	outindex();
X	if(debug)
X	{
X		if(fclose(indfp) == EOF)
X			fatal("cannot fclose: %s\n", indfile);
X		if((indfp = fopen(indfile,"r")) == NULL)
X			fatal("cannot open: %s\n", indfile);
X		readindex();
X	}
X	exit(0);
X}
X
Xoutindex()
X{
X	register int i;
X
X	fprintf(indfp,"%s\n",keys);
X	if(debug)
X		fprintf(stderr,"%s\n",keys);
X	for(i = 0; i<26; i++)
X	{
X		fprintf(indfp,"%ld\n",letterseek[i]);
X		if(debug)
X			fprintf(stderr,"writing %ld for %d (%c)\n",
X				letterseek[i],i,(char) 'A' + i);
X	}
X}
SHAR_EOF
chmod 0440 jindex.c || echo "restore of jindex.c fails"
set `wc -c jindex.c`;Sum=$1
if test "$Sum" != "1597"
then echo original size 1597, current size $Sum;fi
echo "x - extracting jsubs.c (Text)"
sed 's/^X//' << 'SHAR_EOF' > jsubs.c &&
X/* jsubs.c
X *
X *	Copyright D.F. Davey, University of Sydney
X *
X *	Permission is granted for the distribution of this software
X *	for non-profit purposes and provided this notice remains intact
X *
X *	daved@physiol.su.oz.au
X */
X
X#ifndef lint
Xstatic char jsubs_id[] =
X"$Header: /src/local/cmd/jlook/jsubs.c,v 1.2 90/06/06 17:55:10 daved Exp Locker: daved $";
X#endif /* lint */
X
X#include	<stdio.h>
X
X#ifdef VERSION_7
X#include	<param.h>
X#else /* VERSION_7 */
X#include	<sys/param.h>
X#endif /* VERSION_7 */
X
X#include	"jlook.h"
X
X#ifndef	MAXPATHLEN
X#define MAXPATHLEN 128
X#endif
X
Xget_keys(f,checkonly)
X	FILE	*f;
X	int	checkonly;
X{
X	register char c;
X	char	buf[20];
X	int	naltkeys = 0;
X
X	getlabel(buf,f);
X	if(strcmp(buf,KEYS) != 0)
X		fatal("fails to start with keys: %s (line %d)\n", buf,line_num);
X	while ((c = getc(f)) != '\n')
X	{
X		switch(c)
X		{
X			case ' ':
X			case '\t':
X				continue;
X			case ACCEPT:
X			case EXCEPTION:
X			case UNDEFINED:
X			case GREP:
X			case SORT:
X			case FULLTAG:
X				fatal("reserved key letter: %c\n", c);
X			default:
X				if(c < 'A' || c > 'Z')
X					fatal("key not capital letter: %c\n",c);
X				if(checkonly)
X				{
X					if(strchr(keys,c) == NULL)
X						fatal
X						(
X							"%s %c %s (%s)\n",
X							"alternate file key",
X							c,
X							"not in library keys",
X							keys
X						);
X					naltkeys++;
X				}
X				else
X				{
X					if(strchr(keys,c) != NULL)
X						fatal("duplicated key: %c\n",c);
X					keys[nkeys++] = c;
X				}
X		}
X	}
X	line_num++;
X	if(checkonly && naltkeys != nkeys)
X		fatal
X		(
X			"%s (%d) and alternate file (%d) keys\n",
X			"different number of library",
X			nkeys,
X			naltkeys
X		);
X	if(debug == 1)
X	{
X		if(checkonly)
X			fprintf(stderr,"check only: ");
X		fprintf(stderr,"Keys: %s\n",keys);
X	}
X}
X	
Xget_listing(f)
X	FILE *f;
X{
X	register char * tag, *first;
X	int	nfirst;
X	char	buf[20];
X	nfirst = 0;
X	first = '\0';
X	out_of_order = ngrep =  nvariant = nabbrev = equivocal = 0;
X	full[0] = '\0';
X
X	tag = keys;
X	while(*tag)
X		np[*tag++ - 'A'] = 0;
X	for(;;)
X	{
X		tag = buf;
X		getlabel(tag,f);
X
X		if(debug >= 2 && debug < 10)
X			fprintf(stderr,"reading label <%s> in list file\n",buf);
X
X		switch(*tag)
X		{
X			case '\0':
X				if(debug > 3 && debug < 10)
X					fprintf(stderr,"getlabel return(0)\n");
X				return(0);
X			case '\n':
X				if(debug > 2 && debug < 10)
X					fprintf(stderr,"nvariant = %d\n",
X							nvariant);
X				if(debug > 3 && debug < 10)
X					fprintf(stderr,"getlabel return(1)\n");
X				if(useab)
X					output = &abbrev[np[useab-'A']-1][0];
X				position = ftell(f);
X				return(1);
X			case FULLTAG:
X				if(full[0])
X					fatal
X					(
X						"F duplicated: %s at line %d\n",
X						full,
X						line_num
X					);
X				getline(first = full,f);
X				break;
X			case ACCEPT:
X				getline(&variant[nvariant++][0],f);
X				break;
X			case GREP:
X				getline(&grep[ngrep++][0],f);
X				break;
X			case EXCEPTION:
X				getline(first = full,f);
X				out_of_order++;
X				break;
X			case UNDEFINED:
X				getline(first = full,f);
X				equivocal++;
X				break;
X			default:
X				if(strchr(keys,*tag) == NULL)
X					fatal
X					(
X						"bad tag: %s at line %d\n",
X						buf,
X						line_num
X					);
X				if(indexing && np[*tag-'A'])
X					fatal
X					(
X						"%c duplicate: %s at line %d\n",
X						*tag,
X						full,
X						line_num
X					);
X				np[*tag-'A'] = nabbrev + 1;
X				first = &abbrev[nfirst=nabbrev++][0];
X				getline(first,f);
X				break;
X		}
X		if(*(tag+1) && !first)
X			fatal("inappropriate tag list: %s\n", buf);
X		while(*++tag)
X		{
X			if(debug > 1 && debug < 10)
X				fprintf(stderr,"for %s, additional tag %c\n",
X						first,*tag);
X			if(strchr(keys,*tag) == NULL)
X				fatal("inappropriate tag list: %s\n",buf);
X			if(indexing && np[*tag-'A'])
X				fatal("%c entry duplicated: %s\n",*tag,buf);
X			if(nabbrev)
X				np[*tag - 'A'] = nfirst+1;
X			else
X			{
X				np[*tag - 'A'] = nabbrev + 1;
X				(void)strcpy(&abbrev[nfirst=nabbrev++][0],full);
X			}
X		}
X		if(nabbrev >= NABBR)
X			fatal
X			(
X				"too many abbreviation fields: %s at line %d\n",
X				full,
X				line_num
X			);
X		if(nvariant >= NVARIANT)
X			fatal
X			(
X				"too many V fields: %s at line %d\n",
X				full,
X				line_num
X			);
X	}
X}
Xgetline(s,locfp)
X	char *s;
X	FILE *locfp;
X{
X	register char	*p;
X	char		*start;
X	start = p = s;
Xcont:
X	while((*p = getc(locfp)) == ' ' || *p == '\t')
X		;	/* ignore leading white space */
X	p++;
X	while((*p = getc(locfp)) != '\n')
X		p++;
X	line_num++;
X	if(*(p-1) == '\\')
X	{
X		*(p-1) = ' ';
X		if(*(p-2) == ' ')
X			p--;
X		goto cont;
X	}
X	if(p - start > JMAX)
X		fatal("name too long: %s at line %d\n", full, line_num);
X	*p = '\0';
X}
Xgetlabel(s,locfp)
X	char *s;
X	FILE *locfp;
X{
X	register	char c,
X			lastc;
X	register int	count = 0;
X
X	while((c = getc(locfp)) != EOF)
X	{
X		if(count++ == 0 && (c == '#' || c == SORT))
X		{
Xmore:
X			while((c = getc(locfp)) != '\n')
X				lastc = c;
X			count = 0;
X			line_num++;
X			if(lastc == '\\')
X				goto more;
X			continue;
X		}
X		if(c == ' ' || c == '\t')
X			break;
X		*s++ = c;
X		if(c == '\n')
X		{
X			line_num++;
X			break; /* but return it as tag for end of item */
X		}
X	}
X	*s = '\0';
X}
X
X/* VARARGS1 */
Xfatal(fmt,a1,a2,a3,a4,a5,a6,a7,a8,a9)
X	char	* fmt;
X	long	a1,a2,a3,a4,a5,a6,a7,a8,a9;
X{
X	fprintf(stderr,"%s: ", progname);
X	fprintf(stderr, fmt, a1,a2,a3,a4,a5,a6,a7,a8,a9);
X	exit(1);
X}
Xl_index()
X{
X	int	letter = 0,
X		i;
X	char	which = 'A';
X	long	lastposition;
X	long	ftell();
X
X	get_keys(lfp,0);
X	lastposition = letterseek[0] = ftell(lfp);
X	if(debug && debug < 10)
X		fprintf(stderr,"offset for %c = %ld\n",
X			which, lastposition);
X
X	while (get_listing(lfp))
X	{
X		if(full[0] == 0)
X		{
X			char * have = 0;
X			for(i=0; i<nkeys; i++)
X				if(np[keys[i]-'A'])
X				{
X					have = &abbrev[np[keys[i]-'A']-1][0];
X					break;
X				}
X			if(!have)
X			{
X				if(nvariant)
X					have = &variant[0][0];
X				else if(ngrep)
X					have = &grep[0][0];
X				fatal
X				(
X					"no full title: %s at line %d\n",
X					have,
X					line_num
X				);
X				exit(1);
X			}
X		}
X		for(i=0; i<nkeys; i++)
X			if(!np[keys[i] - 'A'])
X			{
X				fatal
X				(
X					"no %c abbreviation: %s at line %d\n",
X					keys[i],
X					full,
X					line_num
X				);
X				exit(1);
X			}
X		if(debug > 1 && debug < 10)
X		{
X			fprintf (stderr, "got:\n");
X			for(i=0; i<nkeys; i++)
X				fprintf(stderr,"\t%c<%s>\n",keys[i],
X					&abbrev[np[keys[i]-'A']-1][0]);
X
X		}
X		if(out_of_order)
X		{
X			if(debug>1 && debug < 10)
X				fprintf(stderr,"out_of_order entry: %s\n",full);
X		}
X		else if(full[0] < (char) which)
X		{
X			if(full[0] < 'A')
X				fprintf
X				(
X					stderr,
X					"%s %c (\\0%o)\n",
X					"illegal start to journal title:",
X					full[0],
X					full[0]
X				);
X			if(debug && debug < 10)
X			fprintf
X			(
X				stderr,
X				"expecting entry to start with %c not %c\n",
X				which,
X				full[0]
X			);
X			fatal("out of order: %s\n",full);
X			exit(1);
X		}
X		else while(full[0] >= (char) which + 1)
X		{
X			letterseek[++letter] = lastposition;
X			which++;
X			if(debug && debug < 10)
X				fprintf(stderr,"offset for %c = %ld\n",
X					which, position);
X		}
X		lastposition = position;
X	}
X}
Xreadindex()
X{
X	register int i = 0;
X
X	if(fgets(keys, sizeof keys, indfp) == NULL)
X	{
X		fatal("cannot read Keys line\n");
X		exit(1);
X	}
X	if(debug)
X		fprintf(stderr,"Keys: %s\n",keys);
X	for(i=0; i<strlen(keys); i++)
X	{
X		if(keys[i] == '\n')
X		{
X			keys[i] = '\0';
X			break;
X		}
X		if(keys[i] < 'A' || keys [i] > 'Z')
X		{
X			fatal("illegal key in index: %c\n", keys[i]);
X			exit(1);
X		}
X	}
X	nkeys = strlen(keys);
X
X	for(i = 0; i<26; i++)
X	{
X		if(fscanf(indfp,"%ld\n",&letterseek[i]) != 1)
X		{
X			fatal("index file format error\n");
X			exit(1);
X		}
X		if(debug>1 && debug < 10)
X			fprintf(stderr,"read %ld for %d (%c)\n",
X				letterseek[i],i,(char) 'A' + i);
X	}
X}
Xlistopen(name)
X	char *name;
X{
X	static char	pathname[MAXPATHLEN];
X
X	if((lfp = fopen(name,"r")) == NULL)
X	{
X		(void) strcpy(pathname,LISTDIR);
X		if((lfp = fopen(strcat(pathname,name),"r")) == NULL)
X		{
X			fatal("cannot open: %s\n",name);
X			exit(1);
X		}
X		name = pathname;
X	}
X}
SHAR_EOF
chmod 0640 jsubs.c || echo "restore of jsubs.c fails"
set `wc -c jsubs.c`;Sum=$1
if test "$Sum" != "7825"
then echo original size 7825, current size $Sum;fi
echo "x - extracting jlook.h (Text)"
sed 's/^X//' << 'SHAR_EOF' > jlook.h &&
X/* jlook.h
X *
X *	Copyright D.F. Davey, University of Sydney
X *
X *	Permission is granted for the distribution of this software
X *	for non-profit purposes and provided this notice remains intact
X *
X *	daved@physiol.su.oz.au
X */
X
X#ifndef lint
Xstatic char header_id[] =
X"$Header: /src/local/cmd/jlook/jlook.h,v 1.1 90/02/03 17:33:00 daved Rel $";
X#endif /* lint */
X
X#ifdef	RINDEX
X#	define	strrchr rindex
X#	include <strings.h>
X#else	RINDEX
X#	include <string.h>
X#endif	RINDEX
X
X
X#define LISTFILE	"/usr/lib/refer/jlist"
X#define LISTDIR		"/usr/lib/refer/"	/* addition place to look */
X#define EXCEPTION	'E'
X#define UNDEFINED	'U'	/* cases where title sans city is eqivocal */
X#define GREP		'*'
X#define CHEMTAG		'C'
X#define INDMEDTAG	'I'
X#define WORLDTAG	'W'
X#define FULLTAG		'F'
X#define ACCEPT		'V'
X#define	SORT		'S'
X#define	JMAX		160
X#define RE_MAX		512	/* jsubs tests this is not exceeded */
X#define NVARIANT	20	/* hope we don't need more */
X#define NABBR		5	/* should only ever get 3 */
X#define NGREP		5	/* probably really only need one */
X#define KEYS		"Keys:"
X
Xint	debug,
X	equivocal,		/* set for case UNDEFINED */
X	out_of_order;		/* set for case EXCEPTION */
XFILE	*fopen(),
X	*lfp,
X	*indfp;			/* index file */
Xchar	*progname,
X	indfile[128];		/* index file (listfile.index) */
X
X	/* global storage for items read from the Jlist file */
Xchar	full[JMAX],
X	grep[NGREP][JMAX],
X	abbrev[NABBR][JMAX],
X	keys[NABBR],
X	variant[NVARIANT][JMAX],
X	useab;			/* selected output abbreviation key */
Xint	np[26]; 		/* index to abbrev for key letter */
Xint	nkeys;
Xint	nabbrev;
Xint	ngrep;
Xint	nvariant;
Xint	indexing;	/* flag set if jindex is running */
Xlong	line_num;	/* for debugging */
Xchar	* output;
X
X	/* global storage for index */
Xlong	letterseek[26];
Xlong	position;	/* where we are in jlist after reading an item */
SHAR_EOF
chmod 0440 jlook.h || echo "restore of jlook.h fails"
set `wc -c jlook.h`;Sum=$1
if test "$Sum" != "1795"
then echo original size 1795, current size $Sum;fi
echo "x - extracting Makefile (Text)"
sed 's/^X//' << 'SHAR_EOF' > Makefile &&
X# jlook Makefile
X#
X# $Header: /src/local/cmd/jlook/Makefile,v 1.1 90/02/04 14:34:10 daved Rel $
X
XBINDIR=/usr/local
XLIBDIR=/usr/lib/refer
X
X# CFLAGS
X# ======
X# if regcomp and regexp are available (such as on 4.3Tahoe), use
X# CFLAGS=-DREGEXP
X# for 4.3BSD or any system with re_comp and re_exec rather than recmp and regex
X# CFLAGS=-DRE_EXEC
X# 
X# for 4.2BSD and earlier BSD systems that use rindex() rather than strrchr()
X# 	include -DRINDEX
X# 
X# for Version 7 systems having params.h in /usr/include and not in
X#	/usr/include/sys, include -DVERSION_7
X
X# to support earlier versions with hard-wired support for Chem. Abstracts,
X# 	Index Medicus and World List switches (-c, -i, -w) instead of
X#	-u switch include -DCOMPAT
X
XCFLAGS=-DREGEXP -O
X
Xall: jlook jindex
X
Xinstall: $(BINDIR)/jlook $(LIBDIR)/jindex
X
Xlibrary: $(LIBDIR)/jindex $(LIBDIR)/jlist
X
Xcheck: jlook tst_input tst_full_good tst_chem_good
X	./jlook -E -l ./jlist -f tst_input> tst_output
X	cmp tst_output tst_full_good
X	./jlook -E -l ./jlist -f -uC tst_input> tst_output
X	cmp tst_chem_good tst_output
X	./jlook -E -l ./tst_alt -f -uX tst_input > tst_output
X	cmp tst_chem_good tst_output
X	rm -f tst_output
X
X$(BINDIR)/jlook: jlook
X	cp jlook $(BINDIR)
X	chmod 711 $(BINDIR)/jlook
X
X$(LIBDIR)/jindex: jindex
X	cp jindex $(LIBDIR)
X	chmod 711 $(LIBDIR)/jindex
X
X$(LIBDIR)/jlist: jlist
X	cp jlist $(LIBDIR)
X	chmod 444 $(LIBDIR)/jlist
X	$(LIBDIR)/jindex
X	chmod 444 $(LIBDIR)/jlist.index
X
Xjindex: jindex.o jsubs.o
X	$(CC) -o jindex jindex.o jsubs.o
X
Xjlook: jlook.o jsubs.o
X	$(CC) -o jlook jlook.o jsubs.o
X
Xjsubs.o: jsubs.c jlook.h
X	$(CC) $(CFLAGS) -c jsubs.c
X
Xjlook.o: jlook.c jlook.h
X	$(CC) $(CFLAGS) -c jlook.c
X
Xjlook.lint: jlook.c jlook.h jsubs.c
X	lint $(CFLAGS) jlook.c jsubs.c > jlook.lint
X
Xjindex.lint: jindex.c jlook.h jsubs.c
X	lint $(CFLAGS) jindex.c jsubs.c > jindex.lint
X
Xclean:
X	rm -f a.out *.o *.lint ERRORS MADE INSTALL *.index
X
Xclobber: clean
X	rm -f jlook jindex
X
SHAR_EOF
chmod 0400 Makefile || echo "restore of Makefile fails"
set `wc -c Makefile`;Sum=$1
if test "$Sum" != "1915"
then echo original size 1915, current size $Sum;fi
echo "x - extracting tst_alt (Text)"
sed 's/^X//' << 'SHAR_EOF' > tst_alt &&
X# This file tests the use of abbreviation keys other that XYZ
XKeys: XYZ
XE Nippon Acta Something
XXYZ Nippon Acta
XV Acta Something
X
XF American Journal of Physiology
XXYZ Amer. J. Physiol.
XV AJP
XV Amer J Physiol
X* Ajp
X* AJp
X
XF	Journal of Anatomy
XXYZ	J. Anat.
X
XF Journal of Physiology
XX J. Physiol. (London)
XY J. Physiol. (Lond.)
XZ J. Physiol.
XV J Physiol
X
XF Medical Research Reviews
XXYZ Med. Res. Rev.
X
XUXYZ Medicina (WHICH ONE?)
XV Medicina
X
XUXYZ Medicina (Buenos Aires)
XV Medicina
X
XF	Pflu\*:gers Archiv European Journal of Physiology
XXYZ	Pflu\*:gers Arch.
XV	Pflugers Archiv
XV	Pflugers Arch.
XV	Pflugers Archiv European Journal of Physiology
X
XF Physiological Reviews
XXYZ Physiol. Rev.
X
X# out of order entry
XE Journal of Physiology
XX J. Physiol. (London)
XY J. Physiol. (Lond.)
XZ J. Physiol.
XV Physiol. J.
X
XFXYZ Tekniques
XV Tekniques
X
XF Zoologiska Bidrag fran Uppsala
XX Zool. Bidr. Uppsala
XY Zool. Bidr. Ups.
XZ Zool. Bidrag Uppsala
XV Zoologiska Bidrag fran Uppsala
X
XF	Zentralblatt fu\*:r Veterina\*:rmedizin Reihe A
XX	Zentralbl. Veterina\*:rmed. Reihe A
XY	Zentralbl. Veterina\*:rmed. [A]
XZ	Zbl. Vet.-Med. Rheihe A
XV	Zentralblatt fur Veterinarmedizin Rheihe A
XV	Zentralblatt fur Veterinar Medizin Rheihe A
XV	Zentralblatt fur Veterinarmedizin Reihe A
XV	Zentralblatt fur Veterinar Medizin Reihe A
XV	Zentralblatt fur Vet Med A
X*	Z[entralb f\\"ur.]*Vet[erina. ]*[Mm]*ed[izin. Rhe]* A\.*$
X
XF	Zentralblatt fu\*:r Veterina\*:rmedizin Reihe C
XX	Zentralbl. Veterina\*:rmed. Reihe C
XY	Zentralbl. Veterina\*:rmed. [C]
XZ	Zbl. Vet.-Med. Rheihe C
XV	Zentralblatt fur Veterinarmedizin Rheihe C
XV	Zentralblatt fur Veterinar Medizin Rheihe C
XV	Zentralblatt fur Veterinarmedizin Reihe C
XV	Zentralblatt fur Veterinar Medizin Reihe C
XV	Zentralblatt fur Vet Med C
X*	Z[entralb f\\"ur.]*Vet[erina. ]*[Mm]*ed[izin. Rhe]* C\.*$
X
SHAR_EOF
chmod 0440 tst_alt || echo "restore of tst_alt fails"
set `wc -c tst_alt`;Sum=$1
if test "$Sum" != "1795"
then echo original size 1795, current size $Sum;fi
echo "x - extracting tst_chem_good (Text)"
sed 's/^X//' << 'SHAR_EOF' > tst_chem_good &&
X# some shoddy input
X%J J. Physiol. (London)
X%J J. Anat.
X%J Pflu\*:gers Arch.
X%J Zentralbl. Veterina\*:rmed. Reihe A
SHAR_EOF
chmod 0440 tst_chem_good || echo "restore of tst_chem_good fails"
set `wc -c tst_chem_good`;Sum=$1
if test "$Sum" != "116"
then echo original size 116, current size $Sum;fi
echo "x - extracting tst_full_good (Text)"
sed 's/^X//' << 'SHAR_EOF' > tst_full_good &&
X# some shoddy input
X%J Journal of Physiology
X%J Journal of Anatomy
X%J Pflu\*:gers Archiv European Journal of Physiology
X%J Zentralblatt fu\*:r Veterina\*:rmedizin Reihe A
SHAR_EOF
chmod 0440 tst_full_good || echo "restore of tst_full_good fails"
set `wc -c tst_full_good`;Sum=$1
if test "$Sum" != "171"
then echo original size 171, current size $Sum;fi
echo "x - extracting tst_input (Text)"
sed 's/^X//' << 'SHAR_EOF' > tst_input &&
X# some shoddy input
X%J J.Physio.
X%J J. Anatom.
X%J Pflugers Arch. Eu. J. Phys.
X%J Zbl. Vet. Med. A
SHAR_EOF
chmod 0440 tst_input || echo "restore of tst_input fails"
set `wc -c tst_input`;Sum=$1
if test "$Sum" != "98"
then echo original size 98, current size $Sum;fi
echo "x - extracting jlist (Text)"
sed 's/^X//' << 'SHAR_EOF' > jlist &&
X# jlook library file
X# $Header: /src/local/cmd/jlook/jlist,v 1.18 90/11/07 11:11:44 daved Exp $
X#
X# $Log:	jlist,v $
X# Revision 1.18  90/11/07  11:11:44  daved
X# various Scimate variants
X# 
X# Revision 1.17  90/08/10  18:37:09  daved
X# Several new journals, minor corrections, new variants
X# 
X# Revision 1.16  90/07/27  08:54:55  daved
X# new journals:  Edinburgh Med. J.;  J. Psychol. Neurol.; Zentralb. Neuroch.
X# 
X# Revision 1.15  90/07/23  18:23:02  daved
X# Added Diabetes Research
X# 
X# Revision 1.14  90/06/09  07:48:11  daved
X# serveral new surgical journals
X# 
X# Revision 1.13  90/06/06  17:10:02  daved
X# Added more current contents variants
X# 
X# Revision 1.12  90/06/06  16:26:36  daved
X# numerous additions
X# 
X# Revision 1.10  90/04/06  22:13:40  daved
X# About 10 new journals added
X# 
X# Revision 1.9  90/04/06  21:52:09  daved
X# Numerous variants for Current Contents
X# 
X# Revision 1.8  90/03/21  17:59:09  daved
X# New Journal of Biomechanical Engineering variant
X# 
X# Revision 1.7  90/03/17  17:34:51  daved
X# New variants for "Fol. Pharm. Jap." and "IMA Journal..."
X# 
X# Revision 1.6  90/03/14  15:31:32  daved
X# Added "Scientist"; removed all "Et" variants after fixing jlook
X# 
X# Revision 1.5  90/02/27  12:27:54  daved
X# New "Applied Radiation and Isotopes Variant"
X# 
X# Revision 1.4  90/02/15  12:33:43  daved
X# More Et variants; Cancer Cells variant
X# 
X# Revision 1.3  90/02/08  18:45:08  daved
X# Added some misspelled "Ophthalmology"s
X# 
X# Revision 1.2  90/02/07  12:08:34  daved
X# CC variant 'Et' for Acta Histochem Cytochem
X# 
X#
X#	File format
X#	===========
X#	The nature of each line is determined by its leading letter(s):
X#	# any comment
X#	F the Full title for output purposes
X#	E Exceptional full title when out of alphabetic order
X#	U Undefined because of lack of city
X#	V any Variant of title desired for an exact match
X#	* a regular expression which may be a match for odd forms of input
X#	S a sort string if different to F (treated as comment by jlook)
X#	any other upper case letter in the Keys: line, e.g.
X#		C - Chemical Abstracts abbreviation
X#		I - Index Medicus abbreviation
X#		W - World List abbreviation
X#	The first non-comment line must be Keys: XXXX where XXXX is list
X#		of key letters used to define supported abbreviations
X#		e.g. CIW in the distributed system.  Key letters may not
X#		be any of the predefined keys (FEUV).
X#
X#	Elements F and defined key letters may be combined if identical,
X#	thus a journal whose full title, and chem abstracts "abbreviation"
X#	are identical could have an FC line.
X#
X#	Elements F,E and U are mutually exclusive.
X#	Elements V and * can only be used alone.
X#
X#	Note that the key letter(s) are separated from the title text
X#	by one tab character (and nothing but).  Non-comment lines may
X#	be continued if the line terminates with a '\'.
X#
X# The order of journal entries within the file is important only in first letter
X# of full title fields (starting F). All such entries within
X# one letter of alphabet must be together for the index file to work.
X# Potentially equivocal matches should have the preferential match first in the
X# file, which should be assured with an appropriate S field if sort on the F
X# fields will not achieve this. Blank lines can only occur to separate journals.
X# Titles starting with numbers should be given E entries at the end of the
X# file - i.e. these are treated as if they started with 'Z'
X#
X# *** As soon as this file is written after editing, run jindex to rebuild
X# the index and check for errors.
X#
X# Next line defines the abbreviations supported in this file:
XKeys: CIW
X# IW guessed
XF	ACP, Applied Cardiopulmonary Pathophysiology
XCIW	ACP, Appl. Cardiopulm. Pathophysiol.
XV	Acp-Applied Cardiopulmonary Pathophysiology
X
X#
XF	AIChE Journal
XCIW	AIChE J.
X
XFC	AIDS (London)
XIW	Aids
X
X# formerly AIDS Research
XF	AIDS Research and Human Retroviruses
XCI	AIDS Res. Hum. Retroviruses
XW	Aids Res. Hum. Retroviruses
XV	Aids Research and Human Retroviruses
X
XF	AJR American Journal of Roentgenology
XCI	AJR Am. J. Roentgenol.
XW	AJR Amer. J. Roentgenol.
XV	AJR
X
X# formed by union of Acta Pathologica, Microbiologica, et Immunologica
X# Scandinavica, Parts A, B and C
XF	APMIS. Acta Pathologica, Microbiologica et Immunologica Scandinavica
XCIW	APMIS
XV	Apmis
X
X# CW guessed
XF	APMIS. Supplementum
XCIW	APMIS Suppl.
XV	Acta Pathologica, Microbiologica, et Immunologica \
X		Scandinavica. Supplementum
X
XF	AT&T Bell Laboratories Technical Journal
XCIW	AT&T Bell Laboratories Technical J.
X
X# formerly ATLA Abstracts, Alternatives to Laboratory Animals
X# W is guess, based on former title W abbrev, which excluded 2nd segment
XF	ATLA, Alternatives to Laboratory Animals
XCI	ATLA, Altern. Lab. Anim.
XW	ATLA
XV	Atla-Alternatives to Laboratory Animals
X
XF	Abhandlungen der Mathematisch-Physischen Klasse der Sa\*:chsischen\
X		Akademie der Wissenschaften
XCI	Abh. Math.-Phys. Kl. Sa\*:chs. Akad. Wiss.
XW	Abh. Math.-Phys. Kl. Sa\*:chsischen Akad. Wiss.
XV	Abhandlungen der Mathematisch-Physischen Klasse der Sachsischen\
X		Akademie der Wissenschaften
X
XF	Abhandlungen der Sa\*:chsischen Akademie der Wissenschaften zu\
X		Leipzig Mathematisch-Naturwissenschaftliche Klasse
XCI	Abh. Sa\*:chs. Akad. Wiss. Leipzig Math. Naturwiss. Kl.
XW	Abh. Sa\*:chsischen Akad. Wiss. Leipzig Math. Naturwiss. Kl.
XV	Abhandlungen der Sachsischen Akademie der Wissenschaften zu\
X		Leipzig Mathematisch-Naturwissenschaftliche Klasse
X
XF	Accounts of Chemical Research
XCI	Acc. Chem. Res.
XW	Acc. chem. Res.
X
XF	Acta Anaesthesiologica Scandinavica
XCI	Acta Anaesthesiol. Scand.
XW	Acta anaesth. scand.
XV	Acta anaesthesiologica scandinavica
X
XF	Acta Anaesthesiologica Scandinavica, Supplementum
XC	Acta Anaesthesiol. Scand., Suppl.
XI	Acta Anaesthesiol. Scand. [Suppl.]
XW	Acta anaesthesiol. scand., suppl.
XV	Acta Anaesthesiologica Scandinavica. Supplementum
XV	Acta anaesthesiologica scandinavica, supplementum
X
XF	Acta Anatomica
XC	Acta Anat.
XI	Acta Anat. (Basel)
XW	Acta anat. (Basel)
XV	Acta Anatomica Basel
XV	Acta anatomica
X
X#	out of order entry to allow for anglicised form
XE	Kaibogaku Zasshi Acta Anatomica Nipponica
XS	Acta Anatomica Nipponica
XCI	Acta Anat. Nippon.
XW	Acta anat. Nipponica
X
XF	Acta Biochimica Polonica
XCI	Acta Biochim. Pol.
XW	Acta biochim. Polonica
X
XF	Acta Biochimica et Biophysica Academiae Scientiarum Hungaricae
XCI	Acta Biochim. Biophys. Acad. Sci. Hung.
XW	Acta biochim. biophys. Acad. sci. Hung.
XV	Acta Biochemica et Biophysica Academiae Scientiarum Hungaricae
X
X# formerly Acta Biochim. Biophys. Acad. Sci. Hung.
X# changed v21/1986
X# W guessed
XF	Acta Biochimica et Biophysica Hungarica
XCIW	Acta Biochim. Biophys. Hung.
X
XF	Acta Biologica Academia Scientiarum Hungaricae
XCI	Acta Biol. Acad. Sci. Hung.
XW	Acta Biologica Acad. sci. hung.
SHAR_EOF
echo "End of part 1"
echo "File jlist is continued in part 2"
echo "2" > s2_seq_.tmp
exit 0

exit 0 # Just in case...
