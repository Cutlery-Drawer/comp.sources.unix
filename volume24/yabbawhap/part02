Subject:  v24i074:  Public-domain replacement for compress programs, Part02/04
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: df136ca4 06cd26cb fe48633b d7ce4fbe

Submitted-by: Dan Bernstein <brnstnd@nyu.edu>
Posting-number: Volume 24, Issue 74
Archive-name: yabbawhap/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  checkconf.c percent.h unyabba.c ycoding.uu yw.c
# Wrapped by rsalz@litchi.bbn.com on Wed Mar 20 17:09:22 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 4)."'
if test -f 'checkconf.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'checkconf.c'\"
else
  echo shar: Extracting \"'checkconf.c'\" \(8576 characters\)
  sed "s/^X//" >'checkconf.c' <<'END_OF_FILE'
X/* Placed into the public domain by Daniel J. Bernstein. */
X
X#include <stdio.h>
X
Xextern long atol();
X
Xstatic char introspiel[] = "\
Xcheckconf is a tool to help you configure yabba and whap for your system.\n\
XIt lets you quickly experiment with options to see what effect they\n\
Xwill have on program size and to make sure that they are appropriate\n\
Xfor your system.\n\
X\n\
XYou can give checkconf any of the following options: -DPTRS, -UPTRS,\n\
X-DBZERO, -UBZERO, -DMEMZERO, -UMEMZERO, -DZEROFILLED, -UZEROFILLED,\n\
X-DTYPE=short, -DTYPE=int, -DHASHTYPE=short, -DHASHTYPE=int,\n\
X-DHASHTYPE=TYPE, -DBITBUFSIZE=%%d, -DRESETNUM=%%d, -DRESETFUZZ=%%d,\n\
X-DNODEMAX=%%d, -DNODENUM=NODEMAX, -DNODENUM=%%d, -DMOD=%%d. Here %%d means\n\
Xany number. These options override CCOPTS in the Makefile. The Makefile\n\
Xcontains more detailed information on each option.\n\
X\n\
Xcheckconf -H shows this help screen.\n\
X\n\
XBe sure to remake checkconf if you change the Makefile.\n\
X";
X
X#ifndef BITBUFSIZE
X#define BITBUFSIZE 1000
X#endif
X#ifndef RESETNUM
X#define RESETNUM 8192
X#endif
X#ifndef RESETFUZZ
X#define RESETFUZZ 30
X#endif
X#ifndef NODEMAX
X#define NODEMAX 65533
X#endif
X#ifndef TYPE
X#define TYPE short
X#endif
X#ifndef MOD
X#define MOD 65536
X#endif
X
Xunsigned long bitbufsize = BITBUFSIZE;
Xunsigned long resetnum = RESETNUM;
Xlong resetfuzz = RESETFUZZ;
Xunsigned long nodemax = NODEMAX;
X#ifndef NODENUM
X#define NODENUM NODEMAX
Xunsigned long nodenum = 0;
X#else
Xunsigned long nodenum = NODENUM;
X#endif
Xunsigned long mod = MOD;
X#ifdef PTRS
Xchar ptrs = 'D';
X#else
Xchar ptrs = 'U';
X#endif
X#ifdef BZERO
Xchar cbzero = 'D';
X#else
Xchar cbzero = 'U';
X#endif
X#ifdef MEMZERO
Xchar cmemzero = 'D';
X#else
Xchar cmemzero = 'U';
X#endif
X#ifdef ZEROFILLED
Xchar zerofilled = 'D';
X#else
Xchar zerofilled = 'U';
X#endif
X
Xstatic int h[100];
X
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X{
X int sshort = sizeof(short);
X int sint = sizeof(int);
X int slong = sizeof(long);
X int sptr = sizeof(char *);
X int st = sizeof(unsigned TYPE);
X#ifndef HASHTYPE
X#define HASHTYPE TYPE
X int shasht = 0;
X#else
X int shasht = sizeof(HASHTYPE);
X#endif
X char *foo = 0;
X int i;
X int flag0;
X char c;
X int flagfill;
X
X while (*++argv)
X  {
X   if (!strcmp(*argv,"-DPTRS")) ptrs = 'D';
X   else if (!strcmp(*argv,"-UPTRS")) ptrs = 'U';
X   else if (!strcmp(*argv,"-DBZERO")) cbzero = 'D';
X   else if (!strcmp(*argv,"-UBZERO")) cbzero = 'U';
X   else if (!strcmp(*argv,"-DMEMZERO")) cmemzero = 'D';
X   else if (!strcmp(*argv,"-UMEMZERO")) cmemzero = 'U';
X   else if (!strcmp(*argv,"-DZEROFILLED")) zerofilled = 'D';
X   else if (!strcmp(*argv,"-UZEROFILLED")) zerofilled = 'U';
X   else if (!strcmp(*argv,"-DTYPE=short")) st = sshort;
X   else if (!strcmp(*argv,"-DTYPE=int")) st = sint;
X   else if (!strcmp(*argv,"-DHASHTYPE=short")) shasht = sshort;
X   else if (!strcmp(*argv,"-DHASHTYPE=int")) shasht = sint;
X   else if (!strcmp(*argv,"-DHASHTYPE=TYPE")) shasht = 0;
X   else if (!strncmp(*argv,"-DBITBUFSIZE=",13)) bitbufsize = atol(*argv + 13);
X   else if (!strncmp(*argv,"-DRESETNUM=",11)) resetnum = atol(*argv + 11);
X   else if (!strncmp(*argv,"-DRESETFUZZ=",12)) resetfuzz = atol(*argv + 12);
X   else if (!strncmp(*argv,"-DNODEMAX=",10)) nodemax = atol(*argv + 10);
X   else if (!strcmp(*argv,"-DNODENUM=NODEMAX")) nodenum = 0;
X   else if (!strncmp(*argv,"-DNODENUM=",10)) nodenum = atol(*argv + 10);
X   else if (!strncmp(*argv,"-DMOD=",6)) mod = atol(*argv + 6);
X   else if (!strcmp(*argv,"-H"))
X    {
X     fprintf(stderr,introspiel);
X     exit(1);
X    }
X   else
X    {
X     fprintf(stderr,
X	     "checkconf: fatal: argument %s unrecognized. checkconf -H for help.\n"
X	     ,*argv);
X     exit(1);
X    }
X  }
X
X if (shasht == 0)
X   shasht = st;
X if (nodenum == 0)
X   nodenum = nodemax;
X
X flagfill = 1;
X for (i = 0;i < sizeof(h) / sizeof(h[0]);i++)
X   if (h[i])
X     flagfill = 0;
X
X printf("\n");
X printf("Sizes:  short %d  int %d  long %d  pointer %d\n",sshort,sint,slong,sptr);
X printf("Internal representation of the NULL pointer:  ");
X flag0 = 1;
X for (i = 0;i < sptr;i++)
X  {
X   c = ((char *) (&foo))[i];
X   printf("%d ",c);
X   if (c)
X     flag0 = 0;
X  }
X if (flag0)
X   printf("(all zeros)\n");
X else
X   printf("(not all zeros)\n");
X printf("\n");
X
X printf("major config: -%cPTRS  -DBITBUFSIZE=%ld  -DNODEMAX=%ld  -DMOD=%ld\n"
X	,ptrs,bitbufsize,nodemax,mod
X	);
X printf("type config: TYPE size %ld  HASHTYPE size %ld\n"
X	,st
X	,shasht
X	);
X printf("minor config: -DRESETNUM=%ld  -DRESETFUZZ=%ld  -DNODENUM=%ld\n"
X	,resetnum,resetfuzz,nodenum
X	);
X printf("system config: -%cBZERO  %s-%cMEMZERO%s  -%cZEROFILLED\n"
X	,cbzero
X	,(cbzero == 'U' ? "" : "(")
X	,cmemzero
X	,(cbzero == 'U' ? "" : ", not relevant with -DBZERO)")
X	,zerofilled
X	);
X
X/* printf("\n"); */
X printf("Array use:\n");
X if (ptrs == 'D')
X   printf("  whap:   total %ld  huptrie data %ld hash %ld  bitbuf %ld\n"
X	  ,2 * sptr * (nodemax + 1) + mod * sptr + (bitbufsize + 1) * 2 * st
X	  ,2 * sptr * (nodemax + 1)
X	  ,mod * sptr
X	  ,(bitbufsize + 1) * 2 * st
X	  );
X else
X   printf("  whap:   total %ld  huptrie data %ld %ld hash %ld  bitbuf %ld\n"
X	  ,2 * st * (nodemax + 1) + mod * st + (bitbufsize + 1) * 2 * st
X	  ,st * (nodemax + 1)
X	  ,st * (nodemax + 1)
X	  ,mod * st
X	  ,(bitbufsize + 1) * 2 * st
X	  );
X printf("  unwhap: total %ld  outarray %ld  outpos %ld\n"
X	,nodemax + st * nodemax
X	,nodemax
X	,st * nodemax
X	);
X
X if (ptrs == 'D')
X   printf("  yabba:    tot %ld  ht d %ld %ld %ld h %ld  bb %ld\n"
X	  ,2 * sptr * (nodemax + 1) + sptr * (nodemax + 1) + shasht * (nodemax + 2) + mod * sptr + (bitbufsize + 1) * 2 * st
X	  ,2 * sptr * (nodemax + 1)
X	  ,sptr * (nodemax + 1)
X	  ,shasht * (nodemax + 2)
X	  ,mod * sptr
X	  ,(bitbufsize + 1) * 2 * st
X	  );
X else
X   printf("  yabba:    tot %ld  ht d %ld %ld %ld %ld h %ld  bb %ld\n"
X	  ,st * (nodemax + 1) + st * (nodemax + 1) + st * (nodemax + 1) + shasht * (nodemax + 2) + mod * st + (bitbufsize + 1) * 2 * st
X	  ,st * (nodemax + 1)
X	  ,st * (nodemax + 1)
X	  ,st * (nodemax + 1)
X	  ,shasht * (nodemax + 2)
X	  ,mod * st
X	  ,(bitbufsize + 1) * 2 * st
X	  );
X
X if (ptrs == 'D')
X   printf("  unyabba:  tot %ld  ht d %ld %ld %ld %ld h %ld\n"
X	  ,2 * sptr * (nodemax + 1) + sptr * (nodemax + 1) + shasht * (nodemax + 2) + (nodemax + 1) + mod * sptr
X	  ,2 * sptr * (nodemax + 1)
X	  ,sptr * (nodemax + 1)
X	  ,shasht * (nodemax + 2)
X	  ,(nodemax + 1)
X	  ,mod * sptr
X	  );
X else
X   printf("  unyabba:  tot %ld  ht d %ld %ld %ld %ld %ld h %ld\n"
X	  ,st * (nodemax + 1) + st * (nodemax + 1) + st * (nodemax + 1) + shasht * (nodemax + 2) + (nodemax + 1) + mod * st
X	  ,st * (nodemax + 1)
X	  ,st * (nodemax + 1)
X	  ,st * (nodemax + 1)
X	  ,shasht * (nodemax + 2)
X	  ,(nodemax + 1)
X	  ,mod * st
X	  );
X
X#define MAX(foo) ((unsigned long) ((unsigned foo) (-1))) /*XXX*/
X
X printf("\n");
X printf("Validity checks:\n");
X if (mod & (mod - 1))
X printf("MOD is a power of 2: FAILED!\n");
X if ((nodenum < 512) || (nodenum > nodemax))
X printf("NODENUM (default c-size) is between 512 and NODEMAX: FAILED!\n");
X if ( ( (st == sshort) ? MAX(short)
X     : ( (st == sint) ? MAX(int) : MAX(TYPE) ) ) < nodemax + 2 )
X printf("NODEMAX (maximum c-size) + 2 fits into TYPE: FAILED!\n");
X if ( ( (shasht == sshort) ? MAX(short)
X     : ( (shasht == sint) ? MAX(int) : MAX(HASHTYPE) ) ) < mod - 1 )
X printf("MOD - 1 fits into HASHTYPE: FAILED!\n");
X if (MAX(int) < bitbufsize + 3)
X printf("BITBUFSIZE + 3 fits into int: FAILED!\n");
X if (ptrs == 'U')
X if (!flag0)
X if ((cbzero == 'D') || (cmemzero == 'D') || (zerofilled == 'D'))
X printf("Under -DPTRS, if NULL isn't 0, must -UBZERO -UMEMZERO -UZEROFILLED: FAILED!\n");
X
X printf("\n");
X printf("Range sanity checks:\n");
X if (mod < 512) printf("MOD should be at least 512\n");
X if (bitbufsize < 128) printf("BITBUFSIZE should be at least 128\n");
X if (nodemax < 1024) printf("NODEMAX should be at least 1024\n");
X if (resetnum < 3 * bitbufsize)
X   printf("RESETNUM should probably be at least BITBUFSIZE * 3\n");
X if (((long)resetfuzz < -(long)(bitbufsize / 10))
X   ||(resetfuzz > bitbufsize / 10))
X   printf("RESETFUZZ should probably be at most BITBUFSIZE/10 in absolute value\n");
X if (st > sint)
X   printf("TYPE should probably fit into an int\n");
X if (shasht > sint)
X   printf("HASHTYPE should probably fit into an int\n");
X
X printf("\n");
X printf("System requirements:\n");
X if (cbzero == 'D')
X   printf("bzero() must be available\n");
X else if (cmemzero == 'D')
X   printf("memset() must be available\n");
X if (zerofilled == 'D')
X  {
X   printf("static arrays must be filled with null bytes upon entry to main()\n");
X   if (!flagfill)
X     printf("  wait! that doesn't seem to be true here...\n");
X  }
X
X printf("\n");
X exit(0);
X}
END_OF_FILE
  if test 8576 -ne `wc -c <'checkconf.c'`; then
    echo shar: \"'checkconf.c'\" unpacked with wrong size!
  fi
  # end of 'checkconf.c'
fi
if test -f 'percent.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'percent.h'\"
else
  echo shar: Extracting \"'percent.h'\" \(970 characters\)
  sed "s/^X//" >'percent.h' <<'END_OF_FILE'
X/* Placed into the public domain by Daniel J. Bernstein. */
X
X/* This is one of those functions that everyone needs occasionally */
X/* but nobody wants to write: computing what percentage x/y is, where */
X/* x and y are unsigned longs. Sure, you can do it in floating point, */
X/* but would you bet your sister on the accuracy of the result? Sure, */
X/* you can just compute ((100 * x) + (y/2)) / y, but what are you */
X/* going to do about overflow? percent() is the answer. Unless I've */
X/* flubbed something, percent() will never overflow, will always */
X/* return a properly rounded value, and will never take too long. */
X
X#ifndef PERCENT_H
X#define PERCENT_H
X
Xlong percent();
X
X/* long percent(a,b,limit) unsigned long a; unsigned long b; long limit; */
X/* returns the correctly rounded value of 100a/b */
X/* returns 100 if b is 0 */
X/* returns limit if the result is limit or larger */
X/* limit must be at least 100 */
X/* note that halves are rounded up */
X
X#endif
END_OF_FILE
  if test 970 -ne `wc -c <'percent.h'`; then
    echo shar: \"'percent.h'\" unpacked with wrong size!
  fi
  # end of 'percent.h'
fi
if test -f 'unyabba.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'unyabba.c'\"
else
  echo shar: Extracting \"'unyabba.c'\" \(7310 characters\)
  sed "s/^X//" >'unyabba.c' <<'END_OF_FILE'
X/* Placed into the public domain by Daniel J. Bernstein. */
X
X/* Want to make yourself popular? Figure out a fast Y decoding method.  */
X
X#include <stdio.h>
Xextern long atol();
Xextern int getopt();
Xextern char *optarg;
Xextern int optind;
X#include "bitout.h"
X#include "percent.h"
X#include "texts.h"
X#include "huptrie.h"
X
Xstatic char progname[] = "unyabba";
Xstatic char progged[] = "UnY'ed";
X
Xint twom1[9] = { 0,1,3,7,15,31,63,127,255 } ;
X
X#define ALPHABET 256
X
X#ifndef NODEMAX
X#define NODEMAX (65533)
X#endif
X#ifndef NODENUM
X#define NODENUM NODEMAX
X#endif
X#ifndef MOD
X#define MOD (65536)
X#endif
X
XSTATICDECLARE(n,p,h,NODEMAX,MOD - 1)
Xnode s[NODEMAX + 1];
Xhash geth[NODEMAX + 2]; /* aargh */
Xchar gc[NODEMAX + 1];
X
X#define NUMOF(no) node2pos(n,no,NODEMAX)
X
X#define CHECKMAXBITS \
X((max == nextbits) && ((bits++), \
X  (nextbits = pos2ipos(n,2 * ipos2pos(n,nextbits,NODEMAX),NODEMAX))))
X
X#define ADD(hash,oldnode,node,ch) \
X( (void) ( ADDMAX(n,p,h,max,oldnode,hash,node), \
X(gc[node2ipos(n,node,NODEMAX)] = ch), \
X(geth[node2ipos(n,node,NODEMAX)] = hash), CHECKMAXBITS ) )
X
X#define SUB(ip1,ip2) (ip1 - ip2) /* XXXX: This breaks encapsulation! Ungood. */
X
Xstatic unsigned long savein = 0;
Xstatic unsigned long saveout = 0;
Xstatic int flagverbose = 1;
Xstatic int flagrandom = 0;
X
Xvoid goaheadandbeverbose()
X{
X long per = percent(savein,saveout,10000L);
X
X if (per == 10000L) /* absolutely ridiculous */
X   fprintf(stderr,"In: %ld chars  Out: %ld chars  %s from: >9999%%\n",
X           savein,saveout,progged);
X else
X   fprintf(stderr,"In: %ld chars  Out: %ld chars  %s from: %ld%%\n",
X	   savein,saveout,progged,per);
X}
X
Xvoid fatalinfo(x,ss)
Xint x;
Xchar **ss;
X{
X if (flagverbose) while (*ss)
X  {
X   fprintf(stderr,*(ss++),NODENUM);
X   putc('\n',stderr);
X  }
X (void) exit(x);
X}
X
X#define PUTERR { if (flagverbose) fprintf(stderr,"%s: fatal: output error\n",progname); \
Xsavein += in; saveout += out; \
Xif (flagverbose >= 2) goaheadandbeverbose(); (void) exit(2); }
X
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X{
X register pos i;
X register node matchnode;
X register hash matchhash;
X register node dosnode;
X register node oldnode;
X register ipos max;
X register ipos nextbits;
X register bitnum bits;
X register bitword curw = 0;
X register bitnum curbb = 0;
X register int ch;
X register ipos min;
X register unsigned long in = 0;
X register unsigned long out = 0;
X register node curnode;
X register int firstch;
X pos smax;
X
X min = pos2ipos(n,NODENUM - 1,NODEMAX);
X
X  {
X   int opt;
X   bitword i;
X
X   while ((opt = getopt(argc,argv,"m:vqQrRACHUVW")) != EOF)
X     switch(opt)
X      {
X       case '?': fatalinfo(1,unsqusage);
X       case 'm': i = atol(optarg);
X		 if ((i < 512) || (i > NODEMAX))
X		  {
X		   if (flagverbose) fprintf(stderr,
X		      "%s: fatal: mem size out of range: must be between 512 and %ld\n",
X		      progname,(long) NODEMAX);
X		   (void) exit(1);
X		  }
X		 min = pos2ipos(n,i - 1,NODEMAX);
X		 break;
X       case 'v': flagverbose = 2; break;
X       case 'q': flagverbose = 0; break;
X       case 'Q': flagverbose = 1; break;
X       case 'r': flagrandom = 1; break;
X       case 'R': flagrandom = 0; break;
X       case 'A': fatalinfo(1,unsqauthor); break;
X       case 'C': fatalinfo(1,unsqcopyright); break;
X       case 'H': fatalinfo(1,unsqhelp); break;
X       case 'U': fatalinfo(1,unsqusage); break;
X       case 'V': fatalinfo(1,unsqversion); break;
X       case 'W': fatalinfo(1,unsqwarranty); break;
X      }
X   argv += optind;
X   argc -= optind;
X  }
X
X if (!flagrandom)
X  {
X   bitword i = 0;
X   int r;
X
X   if ((getchar() != 25)
X     ||(getchar() != 1)
X     ||(getchar() != 2)
X     ||(getchar() != 2)
X     ||(getchar() != 1)
X     ||((r = getchar()) == EOF))
X    {
X     if (flagverbose) fprintf(stderr,"%s: fatal: input not in right format\n",progname);
X     (void) exit(3);
X    }
X   in += 6;
X   while (r)
X    {
X     if (((ch = getchar()) == EOF) || (ch < 48) || (ch > 57))
X      {
X       if (flagverbose) fprintf(stderr,"%s: fatal: input not in right format\n",progname);
X       (void) exit(3);
X      }
X     ++in; /* XXX: check for overflow */
X     i = i * 10 + (ch - 48);
X     --r;
X    }
X   if (i != ipos2pos(n,min,NODEMAX) + 1)
X    {
X     if (flagverbose) fprintf(stderr,"%s: fatal: input has -m %ld, I have -m %ld\n"
X	     ,progname,(long) i,(long) ipos2pos(n,min,NODEMAX) + 1);
X     (void) exit(4);
X    }
X  }
X
X FIRSTHASH(h,MOD - 1)
X
Xrestart:
X
X STATICINIT(n,p,h,max,smax,NODEMAX,MOD - 1)
X
X nextbits = pos2ipos(n,ALPHABET,NODEMAX);
X bits = 8;
X
X geth[node2ipos(n,topnode(n,NODEMAX),NODEMAX)] = tophash(h,MOD - 1);
X
X for (ch = 0;ch < ALPHABET;++ch)
X  {
X   ADD(hc(tophash(h,MOD - 1),ch,MOD - 1),topnode(n,NODEMAX),curnode,ch);
X   s[node2ipos(n,curnode,NODEMAX)] = topnode(n,NODEMAX);
X  }
X WASTEMAX(n,p,h,max,smax,curnode); CHECKMAXBITS;
X /* leaving space for the clear code, ALPHABET */
X
X matchnode = topnode(n,NODEMAX);
X matchhash = tophash(h,MOD - 1);
X
X for (;;)
X  {
X   /* assumes bits >= 8 */
X   while (curbb + 8 < bits) /* could be an if, when bits is < 16 */
X     if ((ch = getchar()) != EOF)
X      {
X       curw += ch << curbb;
X       curbb += 8;
X       ++in; /* XXX: check for overflow */
X      }
X     else
X      {
X       savein += in; saveout += out;
X       if (flagverbose >= 2)
X	 goaheadandbeverbose();
X       (void) exit(0);
X      }
X   if ((ch = getchar()) == EOF)
X    {
X     savein += in; saveout += out;
X     if (flagverbose >= 2)
X       goaheadandbeverbose();
X     (void) exit(0);
X    }
X   i = curw + ((ch & twom1[bits - curbb]) << curbb);
X   curw = ch >> (bits - curbb);
X   curbb = 8 - (bits - curbb);
X   ++in; /* XXX: check for overflow */
X
X   /* XXX: flagpedantic to control whether we make this test? */
X   if (i > ipos2pos(n,max,NODEMAX))
X     if (flagrandom)
X       i -= ipos2pos(n,max,NODEMAX) + 1;
X     else
X      {
X       if (flagverbose) fprintf(stderr,"%s: fatal: input corrupt at byte %ld\n",progname,in);
X       (void) exit(5);
X      }
X
X   if (i == ALPHABET) /* clear */
X    {
X     savein += in;
X     saveout += out;
X     /* XXX: test for overflow? */
X     in = 0;
X     out = 0;
X     CLEARHASH(h,MOD - 1)
X     goto restart;
X    }
X   curnode = pos2node(n,i,NODEMAX);
X
X   while (curnode != topnode(n,NODEMAX))
X    {
X     ch = gc[node2ipos(n,curnode,NODEMAX)];
X     curnode = s[node2ipos(n,curnode,NODEMAX)];
X#ifdef BRAINDAMAGED
X     if (((char) ch) == (char) 255)
X       putchar((char) ch);
X     else
X#endif
X     if (putchar((char) ch) == EOF)
X       PUTERR
X     ++out; /* XXX: check for overflow */
X
X#define MATCHADD { if (matchnode == topnode(n,NODEMAX)) firstch = ch; \
Xif (dosnode) { ADD(matchhash,matchnode,oldnode,firstch); \
Xs[node2ipos(n,dosnode,NODEMAX)] = oldnode; dosnode = oldnode; } \
Xelse ADD(matchhash,matchnode,dosnode,firstch); \
Xmatchnode = s[node2ipos(n,matchnode,NODEMAX)]; \
Xfirstch = gc[node2ipos(n,matchnode,NODEMAX)]; \
Xmatchhash = geth[node2ipos(n,matchnode,NODEMAX)]; \
X}
X
X/* XXXX: get rid of first if (max != min) ? */
X/* XXX: is DOWNI too slow? */
X#define MATCHDOWN if (max != min) { dosnode = 0; \
Xdo { matchhash = hc(matchhash,ch,MOD - 1); \
XDOWNI(n,p,h,matchnode,matchhash,oldnode,{break;},MATCHADD) } while(max!=min);\
Xif (matchnode == topnode(n,NODEMAX)) firstch = ch; \
Xif (dosnode) s[node2ipos(n,dosnode,NODEMAX)] = oldnode; \
Xmatchnode = oldnode; }
X/* XXX: Should unroll the loop a bit. */
X     MATCHDOWN
X
X    }
X
X#ifdef notdef
X/*XXX: -d code */
X#endif
X
X  }
X}
END_OF_FILE
  if test 7310 -ne `wc -c <'unyabba.c'`; then
    echo shar: \"'unyabba.c'\" unpacked with wrong size!
  fi
  # end of 'unyabba.c'
fi
if test -f 'ycoding.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ycoding.uu'\"
else
  echo shar: Extracting \"'ycoding.uu'\" \(22480 characters\)
  sed "s/^X//" >'ycoding.uu' <<'END_OF_FILE'
Xbegin 600 ycoding.Y
XM&0$"`@$$.3DY.5E`C'E#)HV;,PH4$`GC)DT9-B"4N``AI(P<-W/HE#&8<,@;
XM.'GDI#F#A@Z(&#ERQ)@8A`U$DB;IS)E99HY%.V7(N%`H)XP9E#3$L`#1)(R<
XM,6A2YFBJDN50!530I,F9)F<8$&2,(IT(-@S*-F48CJ5S(N><.G#@O.E)!@2=
XM-R#$E`%1Q\W.,&3"B&%3IFD;L9@I&SS#0H&8-R1)/^Z)><Z<I@P1GRGCQF*8
XMF'E`W)'SYJ!+-\7)E+&39FZ:Y#G-(&^3&(UC-ZG!0RVC(,R8,6FDN\'9HD4+
XMN8.+OX]O/IR:$J,.E`(D\,#RDBM#/-EJFZ@(W4!XPPSCH&I(N804P`^_%E*:
XM*(GZD".CCC&N2^Y&'IG0X@J!"!HM(2/2P`.WL]B`0Z[&4`KB-A3I"&,-Q]#*
XM2+4S@E01*#G"F\O,--=T"P20,"(220<5``.,@I)<$JH\3C@!!")R1&O#%A1K
XM8<.Z^(,CT.Z^ZQ/0G!0CJ[XR>I/C/ESG4,",-V)ZXXXY=$@(!!!@F&B*.^5`
XM28SBCDU6T+ND`BR/-E"#:,67MMT3LC3BJ,.Q;\6U:*A[?P23SO%`@/<@GE""
XM8R<SPD0:8T('JB\,@PXSJ-:)4)!BKO'D:.IJK;N6^5ZP>R;C.[JC)CM(E,JZ
XM&JB&Z.NX)/-V"J^L@C(R:-7D7$A!9AG>PI-UGW_#`R6)*;9XC+.02A3JL).(
XM&8097"(#,3BVYU9P55F%E68,)BB/F4=M(BO9R5+6,IC)C`;Z^A/4H/8L\/3L
XM6:&36E/F@+]&$:HQ9S!(3N[`EZF,(7TUF(@4R@"'NZ!$AWUR8TI$=AV(%*HL
XM96@#'.A0'!2DP05E<(%K`@F1/$)-!MS9&AOFD(*N&"$U#,-#&!B)F2:&H3@<
XM*TO/>N(@,8Q!.F8P21K4L`8VM,$\<(A#N>A0!SO<`0]YT$.<$+/+XAAR7<2L
XMUJ#R8!DQ4":@!#VHX=XP$2+TR5]>#*.9.#D:S`A$+D9)$KGFJ(`@3,0)\0I<
XMT(A&E[D\C$UW*(-O"#4GBI8E"7[A3AJZR=*7RK1M_]R!G.CIL[G.)5'=4Y04
XM#QD&?2TFJV>)WS_1<K_]`1!6YZ06U/+`KAT"D8A'G%I7@"I4>"X3H0M=*$3-
XM.5&YF&6D)D7I8>LZ4Z2Q`3:L?<MX%(!4ID)UJE?5JMC.B=XP-)&TIT6,95Y;
XM6]T"%V\[:<.ADJ>GB5QAI5@S2`C_]CICN>$W&\SD>1?9R#S02V:%VMO>:$WK
XM&D_%RGO[C5#+W%N9`72^],WOWHHSZ]8"W&P@1C"#(TQA#?].;^V.-[Z;3>LM
XM']PR>6,,S'&.=5H+E.E;%JC5&=-UL[O=\'@/?.!+1?3&7][TO#]][*6.MUK_
XM'O/8CS_H\[[RN[[*4(`$J+^D.[J[F\`-7,"`(L'$R[_2.[P"),(FG$+RPQLM
XM3,#]@[Z"JL-!5$0HQ$*X$T//.RA7[,5B7,6#(L$23+X"1"VU>\=]'$B%#$F(
XMO!?,4[NHS,J4M$F?-,J1A"BGO$JK3(@K"`N5,JVK\111";,T&TTR>8,&@8,&
XM"1P[$(X0RIB&F0ID4P#(D`[+BDW>.K&R2!HC&0.>V).>`"'<J4X6432*H:D[
XM"`NIN`TO:@\P6C"MPB)XN8.F*(O`,`.FB0_0X9:=,$W57$X5H0F#$`Y\4@[]
XM7!<%6I8ZTB=M68P%==`"S0D*Q5`-'8O+$:G#H!(KP1(9\8H\4)91)0[ER51.
XM?;3V7+/U8*G"V*I%I8_J&(ZFH",8H*?%X(,@X`,0Z!$_:I?T%"&^B->+PXP6
XM^+A$`=1S\I`RH2.!)5@F$0P@<=9ENK-8HB5;PJ6>038#_=;_<#LN0XLL*S\&
XMM+OK6TS3^-`0+;`PP+-BK2D9H`%\Z2,_0MT9$)X;$)X<8!\_D@$<8!_4C0'3
XMC8$70C%'45<(C:>>V8G`8(/M,K?%H[?R3!15;=58=1(I657I(.`N08*@&DG3
XM:E(HM=(M_5(Q_5.R8)&L.H'5V2+."1PLN9OF+=`?0#%C<M*=V*PD7>$7AE;[
XM=+5\B2%_"9@$2ICMI)[KR1B.\1@.`J$1<IE]:9-"\;+"0S5'^M,UFHP]Z5P]
XM=5@W2$XZ\"]D>IINGK6!D(/N)0S="!2-_5B13=DSE9D?"8+!\`WYZ1CP"IYZ
XMSN=^)NB%AFC_PHRXPB(?<BNX"FJ,*;PL;NF7ENF:)N)F;>3T:9_WD9_Z^3)J
XM1:`Z5>_G08EC9N9H9J%JWFCUIE8AMFW=]NT!!U:`E@RA.*-Z?J,XXM,]\J-.
XM8QC=$!8S:`'!1HE(FJ1*\G,\'Z52.B558B58TMJN!=OCZ6OE'&/'*-W35=W6
XMC5W:O5W=[5W@'5Z%J*B,XBB0JCB-`VJ;BI8@^"NHR?<+.3!B>C`%`&V_(C*2
XM-S55"Z^@&A^SP&KSK).P?K++JIJXX:)_.C''0-WE+G:[P`O"<A0$=W#0EAK.
XM*I,P*'H4::W.BI^U;W%(!GN;Q>@("J\&;PKLK^REO;8W]_!>WQM\)2;Q^1'(
XMU^CDE.<3)J4O];T^VG=>Q,#QXUO/+P)^,T=F`..?_5L,8@#0D"9$DSS*@HOX
XM56@`.=0!DQ`XW!5[8'2MIF\8.^W!>]3>M+DV3P/6``_3M6OR3:T9-Z>KZ.@-
XM%`!06(`,L`$I@","G*@&=SZB92B)-P`E^D2`0WANXDY$`0*E).*`I,@4S1=%
XMS(ACD23F@*2X$LT7381=[P<HD@$6X+N2(D>ZC.L'W.D-%1`&5`!(K`RO,08X
XM1J;8&[4CN%,O<H\Y.L=)F!(Z&U0`'K9+;WP!,?`%@J)9G`$R`"6FH^^(CMJC
XM[4*#3@;*9,@-&2`1I()<'UIQ-B)&US@#9@!*)$4K\KT`#][5%0O*:Z0!)7([
XMHB^\R.X`8UE,C#.@!J#$C40J[4M4PX>2237VEQEP$MLEM+POY#)=@D3^,@.0
XM(KO\E_-&ZUV'"$5,V$!-H`.^"JO0CL-@432"7=`NG61TY<)>.!6*%_O;A-A+
XMQODX([?DH)R5ZW+X+*\1.]/`(.3(9GMLA1/_63;.I@4OBYGR+UF*#90W9F@'
XM]V#W:U,SP3CIAJFEG)(&3Z`/UB$Y')+?$*EVB;AI#,()-E`V?U9%)Y^Q*`Z3
XMK8WZ3^=D$8H#&U`70W!R$C$\>"MTAJ,8I49CB$F'LS>IFI;VS'GWL[#4`=P6
XM.MZ9#KTS<F"4'D`V8`O_PE&84<KIH?X&!6!/W^=_>@.789'D,7CQ!M9`<9(C
XMKR1L\#-VF`:X%MJ,HKQC@?&(T>*A%H-PZEY22SG%0@#F38(4;L@#MO`';*9&
XMH59Z!F'X%E$#@&&P-=:9K!@?'6(&YJA<"'LJQFB)PZMXKV39A5?W"K9@'(N2
XM"?Q!/A`'!7`&D(-0(1VX(\1(A_!0KO@KB6!C6S7A^;/E=D2#X++;##9!)RQ1
XM)WI,$,68>J\9XWF>DQ+[&GX&;1!C<.`]4))6)^MNW:YCFF.U:QF-5_%-)NV#
XM*F!1@T\0,8E:G![DC;((PDF-1HI*\1(0W^KX5B:QEKF+!!%E?E.9*+2(%B5H
XMIQ7E46H`8^`+4/8)^%,A-C/IC7:-`;SKO<ZLX[$N<@#JNKH70G^E)T3B;@V8
XM`G@":1:#R`7=0&'O22V=+*F7IFE7-0`;4$(,@%V=:UXH`&IW[;;=MQ-WY0[=
XML3MX1[QNQL)26\]).ADHM5%R4^X`Q@'VM]RY+C\R(MD'[-J4[*/JWDOV,;MF
XM`.`E5TK3A[XT)W4=@`*]TH!EX%?UNJI;=:MN#5``@;CJLER6VX@=,<O5O,M*
XM>9C;26L+[=4K<2T79$QE#/-K-&Z`'\G$7:$)%(;H6J@PRT!@KX(!;"2-F*(T
XM+Q>>X;:#!"KHA",Q1'%'O9H3JBKGP5M8"Z`&E)X@3G'6-94^R8MK_\*O79K"
XM=R\L*XC&ICRHARH.N!7>E@784`=XE:@R56:9D70OD\([)`?&T`@_ER!'*H4[
XM-+XN-EX,-0`&E(#\"FG+A._2S?;4K>2P'D92]``NV8!-\`[3DUZ'%KK#.ZZB
XM!Z8-((FI,#N@:E%.R8A!'`/HAB"<INAU8*\LSPX;!^.409FALW+.D`$Q,^;#
XMH+#:0%SM$1Q#\_9BJ'`&F,0SWJQGP<=BAW-"':2#7PW2C;F*V@4ARTWOIE`)
XM`[;0B;!7@["DV>I02#'0(3F<@$'[QV"8+$D26/.&3>>0_#_\Z=I*)T&4FRH(
XM(6@>4`,9*`Z2H5=9D"^,^"0NN/++WJ)8&S;].HY%=$\N#!+#-/3IVI`:H"S3
XM@AM&(2,T!0#644$J8[L0><`X\88V,5#&`%3MV,I:IDIK@EJ9@9_;%MF*(F9[
XM!MK@-G+VS^X*SF$OJ^X-K+QLB2:.RH[N6R2J.B`&5A:$]F(M3XRQ+*BKMV@<
XMJ++8*`!>;)%=51Q\P]Y4EHWL9K/NV?V]]VUFM:+.59_DB%_[+U0%^((*OHI/
XM-'$BAEDLAQ?#&P<&RVH<ESQN/5>.F."`&2V<BC3!M"G)K"#:JDID$PLS]95%
XM:`I-,V\D?/1R8)X01@M[3=V%6E$W:EK+5O#`VK,,LT$'Y'(PX"&&>1D=QY/\
XM#,<KTY#P@%I3.!4K(J;7='#->_5*AR@C;$Q61&R+/395A>:6UZZB,C22-7RZ
XM>;?651L)8FHBCV2^(`9)S7+.[\DAK(M[_2HX@PB/()0=_Z5I1O=7`-CC5K82
XM2OB5]S7,PX.X:+$+'ZH%AXT=4V7!E6>_+,?"U[UHI*$N>L*Z$+C+<[=G4%LJ
XMXVYJB&:O>)-O/E#?L/Y(LKS]Y,1DA=4)2$_I30)=U^M]?9%4AP@/%&0OL4BC
XM0-E#J(ZD>:V1`SUG9[4UOR-Y+2V7&P*BV"5L("L7022OGP5"PD\<8.3'\M@L
XM'VH;G5[HR%.L1#]](JLN%(#8)MLNXDA]F<;@4V5V&B"J!9V*6O&!,=&%0N(S
XMS6$;X8[OG6!\WWY/P*K@&*=SBY`@HE4^"*@")/_D,^]8S1-J=9.7J8@%R45\
XM*0B"E)%+>E''W+$")4?@%LRV?R=LB`&,,Q;!_$O_5K$P0@$`8/*^$P`QL,<.
XME5#&H`OD6JM1BD/($5(J+:TWR#1X%1HM56@LD#RT0/7[&M(@WFO;,O!F%E`A
XM(WC1_@6RS*=(#EJ`D6_^P_"&O&^E+L/+`#3N1'4XS*:F2K#X8K5,+%,'(N`,
XMK+^2CKFHHK*^%*WA\@T"P/CM=`";?CHAA;O+NW(#S*!&:&!X!+0F"2"KW!5!
XM82*CJTX$#,8K&%NB,5(,%:N%.@:F(8)J,60,94/&XRJ$"T&%(R`K7"HLJ!,$
XM]CR940;J@AI.M$//?IJ'1";(0D!2-!:,X@:3,N3FP1UO<^@<Z`-50JV1H!B<
XM=0JJ(R."!!;AO"D+EIOXIOY1<<Z;.:'0@B.&`M5N;>":6JL'K6U!)ORY<4[-
XMT*ZZM\%`&)SR%`^38GLX^!B+)2&EZPF@`JE@67@E."@4D?U9`\R#.P!P`(7R
XM#)*+#0AS&+(W*'X(%,C$4<N.L2`8QJ$`&C,:9$&ST,BKM4XV)>U_@NYNA9;F
XM%H+N8#O:H6UL"@R,\21O1`,$@[`Q1["J8B$U8*B"@=#&M7%O/##"ABL`HN"F
XM:(53@2RCYUH`*F%64`"V@!R@"Q#9+L":HL&A,XR)-Z*6NU*@AZQ&C<H8@A:S
XMP9'(5?`R&:`&P)>"06YJIF(1[`)ZL#BPJF(9XJ9I"1MA(,61<70(=$.C`-#Z
XM&P='(;+62@[J.,!`_8,(:(D@2GRI(#'(>6XU$Q12JMI!C7P7[H`YXRYX(EX%
XMC9"4:*;2Q;0%3>0S(JW>(#@!YDBACFQF-$T(!`[L?J-2O#5.S`SPIS`(Z4!K
XM6/D2`J8E30LFRT?#T!/TZ`X#2&I;_!:S@\O%[-D@/2D?:$J,,LXR)V<GFYI^
XM`X#LT3,/G@K'@EP1*I`*'4@L:/]$-6$0,F@LW##$K$&@*6:U`#`+#-4D%HW`
XMCFR$Q,*B<:T"??I'`')JX@P0F3TO4>G4M#-<XASL56+#E``&H'8""QN@!J@!
XMIC!`!=`HKF`<R:"5%*`$S.Q/<@LC+`),$G'063#*6"Q[82IHJE+KJK(R83RG
XM+UVLY88+?Z&YL".0.L+K#*`;8"!=SX@,%TRX"S`-:\,8`\E@#9C?JC?N;:6[
XM#-X`MHUWI!6@KIP!FRH0CCN#+4S4@4X%D^HA*#@I0`P0=`@;*D`,$'0`.`=.
XM!2'@7`,TLH^,)(MB<D=,\GM!$&8Z-$J-`OM,+!\#,8CW@K*51:JBJ:2;P'"E
XM2]V&.0!%QJ(E0(`M``?H`E(&DJS3%!J%0;^/,0@XUX!`(3HA"?R^H4!(R",4
XM%P0KTWP#99P#XXG0S[R^(=.5W+R.!3Q@K,)0C+H!LZ#K([&#23`O&P\&SKY2
XMJ,@J1HJ6L7`XW&;`D0*,W.$RS0HKQ7/*%+G,[^>2HNY)BP`[J#8/-EF(EW"<
XM`,Z!\\%+;Z@R9/"WW`1'"GM*C0(XV;8M02.0"I`9,<QD2(82M`A%%NL)+997
XMKXOI&#!-ME(0FFYJ-[5.48A.2`*_[Y!@`J2`*H#0&J4*%+1*I2,J-$D^L$FA
XM#X@#9O!($_[:`SKCSB">])H91WGIU$*"9E&S9!W&0QT*0+G3UA8QQLY0ZRP+
XMHZ":G*(>3(!SX%3*+LWGCK"4;BI+S)*S=,-:1@I02`%?\!_-<#?('0N,,L"?
XMHAU4A>W@E4CQ"D8QLVKY4`HH%),B"#C7`+>,D1PI9L0$3Y19RA`4(@5">=)`
XM`"B@T'KNWL7K:X[!55B%?]*.\2G3*'@2(N`64K=/T(OR)1L#A848FF-P%;5P
XM+R!1K,'.C\ZX,_RSAX&F*NQJAX!O)S@#XCB28.%SFY3(0$LCB!Z&`A`FJT`4
XMFK\#4ZO\#(""`\6[BAH\LX-L(?L271P%0+M2P@`56`S9:K;FA$ML\QH'C[0]
XM9N@*'8*^+JQ`<0_LC$".R`)4C*^F)2SXA;(T6$LX@"BK-JUMLNED%+;V("SX
XMA3(Q[N\##`K^AY+.J-C0Q$6Y9_C)*]>V1`'+%`X@2O?@:M/:F(8SP%N+J@*'
XM/*$X0/NV*L$2A</T_(2X;BHXL%2WNT$CB!YH%2MO)^`<%*L)2XOAW0`#<B5&
XM2QE(LNTE-X@6,K&5IUV@).FO(V`-^_FZL`CEP41=Y@0:``9H"E`78V\JD`%&
XMB6]%]:KE$HDN\T'R$(ZJAP`HP*_T%!K`CS#VI@(;`+QI8[BP""5PA-$0@\GF
XM6/BQ`C@%("PP"5H`Z6"4PM=R@VC!GSD$O47]"AZ4Y+ZWI0W<-`2]Q2).!H!=
XMC#V_"77Y5JPVK4WUJN5:GJ/J(0`*#C9)0Q3D#22#9`V3!,WT##=2;<(>G1_+
XMLE3#SZ(3?VSR\R.S-(#GB'(/!H,FI3H`)3V#>&&:&AAC&UB%(C"C:BVC0#>(
XM%C(Q<?!(FPO(DX=F(/L?2CK6@66+$[C#.X%M2Q1ZKIE1DQPD\+#WC`R(3K(&
XM7W*\PB<M`LZ@(3@C^<RYJ0SPL8(%HT`WB!8.06^QB.L9@<;E<J44#J*,*P,M
XM4&%0A^VLI*/')H/*8D_3V=:>!H=5DS3&`\H`92%78C3)ALZX,Q"#QD!A(8;F
XM&%REK9JKB(`+AB^48"Z8MBR1J&(T28=@>)O<\L(S0*5[<?B_F%&VM/".Q6;Q
XME%P7$:IAZ%ID*H8B%.$05`1%R3PB(T")1,$[1@'($_8(0P*BRR-E1SLF5YM2
XM!$*993'($_:(I8UMBQHD%_%$CXOBNHJS;ZN8<?R9THFW,53>`O&NO%F<7IR9
XM#[R3H'XMY\SA@*W`!<OB"Q1E,H;SI@8T'TP#S.`@$",R!OI!6;I2:`)!:[?)
XMWH2?T]%;D`[83%-&AG._/BZ'313L4"@7/4QJJII"J:!,N,2%R(1(@WJ:];H5
XMJ(GADMVNPAX!O&D"J#84(0B``M2RN:H)N`)4.OA!PC,D.X3O(2&0VLJ[/"9Z
XM4TYV@E$JW&QG;A3BP%P$#F7,;@.,+`YBP.<PM+']ND/Q$$R$^+B#6FXSB`F6
XM!(LL?NRG+CL0``_P"W24"V$TG`E3J7T"U@(C@T4M$"I`UQ2`X`4&0%WP`+_`
XMOP#[3"PP\C]@%R$M]0!=LS!A`!A`!_`C+C_)+`E(P=J#-(U-<"PP-:OJO%P,
XM`C:D#(4IR!"RA2RT"@QQ@SF@X3HD\@"#34C((Q27S"ID)!D_#!'C.6RGED1\
XM3HT2Y^I$G<O9L"$@CF#H&)*"\#DUBG%:H7:H9X)KR`F:@*QR33&V!#QI*-;8
XMAXJ-9&.;B^%BILIC(9HU5`ZU"S!".%"`JZ$2++<^/Q9AF8(6Z\JS!>681MHN
XMGNCH*#S6KIUH[K@]V*Z-"/%@/]HN,FGW($%,$.V(&9E$NA#H0S."1BZ13>3N
XMH"^>$3>D#"E%-*.GQ/_X/"(1J(0J<3\<D\C$,E$`BH`J)C!X&/@$<F64$?``
XM`[\2I@PJ3`95P9HH#IH`*R&+&'S"N\IN(A`"ZC:FP7N@#\:(T.94B"^&.8VJ
XM8F08+(K+0"P8#[*,`T6&P^>&R=KK]O*]AB^GP$J`M2C"OX!<^1?J.5^N0VG!
XM&D9Y`BCSS`ZRA4SN(001P460CY0#EK1NRE<YV3X41X%-H"R8LHD,!"P!RT.F
XMI?0:\#@^3Z[O8K_>KZ8@&$NF9KO:KDJ8"(0`(0CMVZKZL:FIBL(#U`JPS\32
XM:LPQ``[/8Z6D.,;F(&`"H0)T[7)A`^ZM?FQJ2@[\"[#/Q'KU@C&4H-T1&"Y!
XMJI"N@@*$JJ*JP&H"XL(FP$H8I0;.J;'@2_BBNX;/2L`L3`O7\E:S_Z3,4S'O
XM>@C@`'BR&OQS5+1O9=HB?FRAB<!G#!J;Q3NA/G##9L:>4IY3&IH&>^N44J7<
XMLC01AI(T9C[Q#.<):G(%/C`,^!4@O522.QD%38M=0JBPJB28_N__"P"#P35`
XM:<DC6B,%H*>4YY2&IL'>(B$K+`#-:)ALN#D7\FUT#U"$GO)?\V)6R"`20#,:
XM)ANT;ZNZ$VX:7D(C&P\PB);1.'QQ7@D+PF:()]>&&=%>B00)R]%P&B.D,$F3
XM(1E*V]:`I8UM&PU4.A3QQ2F!\@(\``_``\2$.0$/P`/P`#P`#\`#\``\H"E(
XM45Q+E"!@#"K^G"8&SPB>U)N-P"88(^XG/``/P`/P`#P`#Q@G+HL4)0OD%L85
XM(HN8(%?^A3\RH9(T8I2C:G2H)7`A1Z$)R"H1@IW`9$B&@B2V;6ECVVPI%`%G
XMF5ZV`R'JN>Q5/`.&:W@[YK#*&0$%(`(N&)HFTB1;?JQ,LI,,)9NV($O9^QUJ
XM-[4N?!"JBBJ*SQ,<8@HIR8:;2R_!B&"K5>NAP!=)13D9^HR^H?&Y9"D3148E
XM&;(>E[:_2H28J5:[R4PXB#((P)R@":#:8KN\4J4`RDBJI.R86U4:`X6%&)IC
XM<)6V*DJ#`E0Z^$'"8Q9(*3`S,&3Q#I3%$#),"H>NGX"R&=-,0?*.0\L8F@`K
XM07*Y>1X"?JS<,F(NA-^@S504U+8U8&ECVT8#E8Z+T`@4EU],&+L:*L%RZPUD
XM,9@I:1&?V_+."8A&+9PSO9?P!=]L$Y$&Y42D(/66AH^NP,IB<(?&HMRBHO+-
XM%0H%@,96AR4J/H@-ZA44<0IP#U`$*J!M(2J8*6G1;$D0K@Q^(9Q+,W+*3^JQ
XM^PW4&27*HTL,H@8J0$?9L=PT08$*>,H>`C/`=]"AG@FN(2<(`J``M0P#>Y`$
XM/&DHUMB'BHUD8YN+X6*FRF,AFC54#K4+,(*)II&VBR<Z.@J/M6LGFCMN#[9K
XM(T(\V(^VBTS:/4@0$T0[DHY4D5HC.@(!5H`$8XFZ*`LLR^!WF$2Z$.CC0VHY
XM:`T/"018`1*,)>JB++`&BM\!&KE$-I&[@TWB0H@D^N(9<4/*D%+D0[I$'!(M
XMQ/_X/"(1J(0J<3\<D\C$,@'H;@?'(`B``JR,&!%5=,W81(Y/)YL1,;'%*>@J
XMNH"^+BS8`@%`F*P"4=!19L+^SS\Y%)@^^:Q#]'(8`E]2@CQ;U@4X<[E*H,X)
XM$+`$G#(!A+``TOH+IJ:JJ<',*\',R^_1(!.:`/VN3#`9?,NY14NC]\9#J[!'
XM*%X"`KV0K@()N!:U<)@P&=:#A$!JBQ^:0U1JG_`C\3F)"T6X';9'"V%E,65@
XMJNG0.QP/G0*J+7YH#E&I?<*/Q.<D+L'B=M@>+825Q91YM"2MP,L['`]?`BC`
XMRG"I3BE5:F0LLXR=Z1!%N!VV1PMA93%E'BU)"ZDTO+S#\3!A:ZT,OH0ONHL.
XM-$-)3T9!-]^`ZP/JT_)2&U$P7'NM0H?%T"B,SPXN\4"EZV*./$Y0M1@69+@A
XMQH\L=J9#%.%VV!X%*I;%E'D.J<-103QL#@(\!"\P>!A`P5&P+`@(6"^S@7'S
XM(H3!J2!@NZ6&H%CHM3I2I@@JX0:87:(3DL#O"P>!&@$3,3!E0$:;IJ>D!E$I
XM0<6/+':`&M\!2DM\;@<_#6>)_%2*9X*W7!(2@H!@+8L=EH:Z8>5I%RC)E*Z-
XM0:7VG0#.X+%Y()ZMZYDC8LZ;DL>62KJVDV+'\:-8/$)M;G%J$SV4%HS]41-I
XMG,9`84G*`,3L4+`@$V/&5I$*L/("00H0`Z0/W+!306P#(V"Z!2A=A"5CG`/C
XMB=#/KA<4Y@R(XV(=S2]L<P%4`+'M#G`!5`"Q#8QP`50`L0V,(%O0%@%)(X@>
XM%+=U01PR'S5#=2NT.+OJC<_`41/GTHR1R#VXC\PB(0FU:`JD(_9"01B2"(JF
XMX%)J.10$-HD+Z2]"$I$MHMA,Z+%[+"9\)NJ&V(:FR0,NA>'J,YDRWCP)*DY,
XM4?*$/6)I8]OJ+7[JGTJF2$/5,)*86.*5$DZ=$1*E`$!+LL`D0X-;ZB-43J9#
XM%*$Q4%@L'!G+.CAB[LT_2$XT+6(4#T51"_-$P]-0V7@XN+'01IYH)"$"-9'&
XM40%VM:\)BU!8F*90YI)"IDA#.<7&4`&^1">B*3`M:JU-T$)DAT;#U'!$.2<`
XME`(E*)@4+<6*L"DP+5X]1HK/'`U3PQ&%HEE.2C/3,-G@%H*QF6S<8H>`&EIE
XM,;!@O)BFX(0Q$A<VLR5!&!9,F0VAF-3#8IEA09*KLYJ=`VOPBAV6AKJAE&D3
XMSXE73XJHLYZ7B:`)\'PD%]"$=>AU8IGI$$4PJ;P&!V%Z`_P&H6KE#X3S:!I>
XMR':8"J<TU`UGB?Q4"@%O,]FY9@+(H-@#AI*O0"%/<",<")@"JI(`:1RS)4&P
XM^]H%2I+^>C7V(5OCV4AI_"F`*C546V0&9H*98":8"6:"F6`FQ(1;@R9B#(23
XM9H*98":8"6:"F1`3L*.LP^H03IH)9H*98":8"69"3,@ZO"&4IO!@)I@)9H*9
XM8":8"3$AI8$^:**K0SAI)I@)9H*98";$A%L#\&`_A)-F@IE@)I@)9D),8#F\
XMH;AC>^B@;`UF@IE@)I@)9D),R#J$$UQ#."$5;HUF@IE@)I@)9D),2&G0HUI#
XMZ;"*;`WAI)E@)I@)9D),R#6^@"_@"_@"-J1E(K+QACJH7(.98":8"69"3&`Y
XMA).]X04``;@`O8$+^`*^@`V),1!.@A-20==H)I@)9H*9$!.R#N'D[1!.\):W
XM@\O@`KZ`+^`+V)!``"[@"W@!V`]:0SAI)I@)9D),2&F8B5J#F<@ZO"'M@0OX
XM`KZ`%X#]J#68"6:"F1`3=@UF@FX13E*:H8,FVC6:"6:"F1`36`[AQ"VZ.H03
XM+D,X63I8$:LH'Q).F@EF0DS(.H239F(?$DZ:B67"&V(,O"&!@/W`-9@)9D),
XM2&F8B<@H'V(F"HYFHN`03IH-]B/7:":8"3$!UV`!LL*L,"O$%9H)P$,XX3*$
XM$[PE\&`_=`WAI)D0$U@.X:29N!?``#]0.&DF@I-F@N7PAK(.;RBE>4Q8CC%`
XM3,@ZA)-F(C(Z:9@)OT,XP3J$$Y1FZ'A(XHXQ0$Q(:9@)]"C78":4CF9"Z1!.
XME@ZE`PN!1E`:,6$?NC68"6:",1!.FHG@I)E8)B*;[:&#@DQF#3&!Y1!.F@DQ
XM`0^`2*`1QD`X:2;P`(@$&DEIF`D\`"*!1HZ.,0`/@$B@D:MC#,`#()*(9`S`
XM`P!#:(Y0^::V%T#+FG38\JE_*C546UJ`)V)R!,BFKZ6KV`%JBLDP$.JB*\T6
XM%E/^.6'8FJ8.16&`O@;\)Y99#:.,4D(.^"M01#KS>TEY6#P9DTY,40A`GH&O
XM68?,E@2!8Y2@IL,#934T9;"NA\`,&`K"1/;.GDH/5H>944W<L%@':FL\X!J5
XM$YJ*;AR".,::I8>0%2D9!:`B4%A0F-"`L&0:D((Q`A9#MIHML>5L"0>;"?M(
XM.+F/B"+W`$7X'$LA!FA4Y!9BF0U!I6LFF(G][_\+`)&-FJO*X/C\(!BJSI0H
XM445',DV4$Z.,@TL=HALWBYR'F;@-F@D%0;%K@VJ_E8(Y*-=VA:[@Q0P<Q(0>
XM:C)H_OJI?RJ9JAO5"^$D\!!.N`SA!&\)/(Y!H4)#D%#<@V;",A`3F@G+0$P0
XM3L0`,<$R$!/$`#'A6U$3Y<2;J\I(,.RI-L`TX/3F1H`AK"._A+%*;N/``YZT
XMQ&>.2?5V,?'-)V"K_DF7$9K,-*&,4F)X0PD"@L[BK$P7?P5(3S@8TT@"\:`-
XM4.EBF:$RM)$.+`U'#61D*1&5GG),,5N@+!`FJT`4F@(5H*=D+O2X*.[.8Z7<
XMLC2Q6E$!<BC+(=-,-?F:G>`,B.-4N?9Q\X-]MC,.30),I:P%E4Z)P?LB"A5`
XM;+L#7``50&P#(UP`%4!L`R/(%K1%0-((!B#X)UYP`52`>$&24`'B!2$2!>`@
XM![S?8>B;&WP5_D_E*2UB`G_N%M*G_JG4<"J@&^V8%\T-6`-T!3=@#>!GU@"T
XM8`V0.E0M%.9(5#%`&SP`!F)]Z$;9,H^9;(8%FJI=H"1'`VG(17,#UH`P0$Q(
XM#M:`,$!,<`/6@#!`3%@#P@`Q(0P0$_``]B,J<0/6@#!`3'`#UH`P0$Q8`\(`
XM,2$,$!/P`/;#UG`#UH`P0$Q8`\(`,2$,$!/P`/9CUU@#P@`Q(0P0$_``]F,?
XM.@O$!#R`_=B']@8\X)\$`MV`-2`,$!/,E@2!@QSPC*\RP0U8`\(`,0%`0PT?
XM!A/E(2#JQ+7_K)1:`\(`,<$-$A/F!#S`50Q;D@VZ<0:$)+&V:5+/!`*?.5H*
XM1=B\?I2+DAE#`J(7G0M@U"HZ&I@"JO+%A+'/L#0L(<.69(-NE!2-+0&O*8"Z
XMDBM^*S$+`R`*1H(_"`,@"D8B#(`H&`G^(`R0AJRA2W`;<C:*#?`D9=J')B:5
XMZ2OA2K82F0$\V$K`@ZH$/"`V9(9WB-AXAXJ-=TAO@`-DAI7HUYHU?JVB0V;8
XME\*`K"0,R$HF)I7I*\DU&A-C0RN)%KH2\,`JV2GNA7>H*F$DJA)&@MB``V2&
XME8B1,#T8"=/CUY(9WJ&]X==ZA^Z%7PL.8#]NC8MJ;X`#9(:5Z-?2-7XMF6%?
XM^K74CE]K^9B85*:S0/F82B:FND`KB19P#8ABI[@7WB&NA)'H2A@)JX21D!E6
XMHL1LZ$C,A@Y&@B;:EQB),,#G8"3"`,?$UOBUEH^)264Z"\`2HJ,Q,3:(#H@"
XM/&@V(`KPP"O9*>Z%=X@K821P#8B"D9`95B*(@I$H."`*1J+@2,QHHG>H*F$D
XM+BH5@9'@#YZ18>/7>H>N/#A`9EB)?JU?2V_XM7XM]N/6X`],CU\+2ML8^C2<
XM)?)3*9X)WG))\&!6/+-NGEP:>,O/CT7P*SN&7>U*"0CB1&OQ;OBF.@YEXL[`
XM9#B9\Y`]!(9@G/Z&I_PM["=@9IB)<`H/#(?$J0O2&ZHGJ9%JK)JSYPG"@K1%
XMWH=;<-+*&C"Q+G@9LS<V$?ZY,GH(6?%.I#/N#-8F/[R?V@#_HE%L@G@4/8*[
XM47/>G#E'S_%S]BA$`@^0"\ZOH*`K*(4`-*.ATEP/X$F((&QX)B065@\F4^G6
XM+%`.9I0>K#NI@(@0,/$&J.O%`1G#156K6!#&*LWU`)YL)FG&I5`+!&=&PR/B
XMDUL-)2J+ZBE[",R`MP"*.+U<+>^1>7-Q:+3[H<I;XQ`$0F^-DQY*JHY!HXLS
XM.[GFC]G$&]:X<8MF)*GZN4W&/&0/IX(I@+]Y96896)-D$68BG`M'#M@!"@\J
XM8.KY*\`#JH<-PDJHGK)A"C@GJ("VY86L\M8X\(J\>C\>F92#9B@2@[[0QDL$
XM`LM$L&$*V!./"/%O#/@KU+I,<5/TY`J/*4!D2@'VQ".B8U#LG`TJH&.8`OP+
XM.J-JZ2GS@!LP3XD6J`"RIL7\3.J",E%F#!NF@/R*"K@-5(LV`+V!"\R&_H;`
XM>1*+CNC$'YO\,)P4P+\85Z"&Z/$^O)^<M.[F):"^P`,>A5P995`X3$_)*Q/3
XM1#DQH^DAZLHR`L19<]Z<[6JPK`]=,&+HTBMVWBM)I]+A-`H//`=A.756G3.'
XMZ_KDI@"125E"$4P&OJ`K0`)&+K7"K^P8+!@O1AKB9)86BL7^DS)1`"*`!6@#
XME"7""MV+:H;$6D%D0HF,IV*G\:JV1`B3KQP#O2B*RW`SC"C*FI?@9;NE)I67
XM\7Q49PZHS%""X@]#&VUQM=E*_`O!H#+X+5$`(H`%:`.4)<(*W7L)4(G%Y),[
XM%",T<F5\V"Y8!)RBM:$NL@L@D+M1<]Z<.4?/\7/V*$0"#Y`+SJ^@@%;18N*M
XM,#+(-!F2(6VARB,ECPB4LJ6LHGY#9^64XC94NDM0+?10%#64I4QD&$]$WM'#
XM*`PH%H_P7Q08W0!S@EV(!&T:M<+QHUBJ*+3/:.,=/8S"@&*)S-H8"P;>`B.#
XM3),A&9K?U*OJ!*5L*1^.S-#)R0_OIWQKGT#[G#)>BS#(WK8?*(W$:ZT,OH0O
XMNHL:`@*]D#-IK0P^(DN72^7P.36*6AGFN(7X;8Z1_"@;Y([RVM6^IE)&:D,1
XMFH#<3I=+Y4`;:F68LZJ"`"C@G,@"AH)22#B(,@H^(DN7R^=\A=MA>ZP/ACEN
XM(7Z;8R0_QZ`)H-I0A"``"C`-3@6@9M'!';;'^F"8LZJD-A0A"Y@(H+'588F*
XM#V(#AJR/5./RN4$H@6L.)9>'H03*"YPY(L:/?/7PN9Z@*9!<:L'U)Y4#;6:<
XM$B@O<.:(&#^RV`%J2@2FJX0$^H*:10=WV!Y#!P3.>HS;G,.@IC1+S98R?*N6
XM&H>ZPR6*.C!._@(]XJ\(&Y"VI@W?,F[<@WO.EUMT<(?M,728<2+-8@$>M/V6
XM,O9.U,()2+VEX:/;#LX#BNJ]4Z&"`/B@@7R=)(WO@3,P#SRXFBT@X.\\-MAG
XMT<$=ML?087@$;6:<#"\A"`BT*RRK'P/(3*J'H&.@$I2`ID!RJ5PD.1EGFJP=
XMIKB0@CR1</0X0>4<$V:&/J,/,S@(%LZM"N!DV_A,JNR#8;@0A:8@(,`RR3MW
XM4!Y<';C-;W/<U&,*,H1,=&APJ,*L$,VQ9[X7G``PU!,:!'(%^)(=E\O#("!X
XMM[8`&:`+,!,&2X`'%C.SI)3\3+"@)=(HM*HI"`*@`+5L:(N%XI@IRK0(#'X"
XM%BTZ(0F,D[%@N62K/*C``%QKWQB);T48ZC8ON]]@ZJNIWBU1T'J\`^L&!0!G
XM!`SUA`:!7)$#U(JA\;ED%?@*@^)#X0\*S)RNAP0BMX`9H`MX,P4A0R@S`ABU
XMBKEI%US;^,R>8(UK+(X[`V4*.">H@%@L"[#(:!I39GO45-[``J,F4/P*`XJE
XMBJH!@XP5<:4CJ6`Z&LV:=`RF@*)GI`@+3`+PH3"@6%S*;R5LH`*Z@LSH0[FH
XMTBA%3F=3*Z9-;+/>&O=FE(!S#4"H?(8T2E$HI!2`Z.2W@"A+E#,,O$*P,+\R
XMH;K#[D0X'67'<M,>B"IOC5NO9HH(,G`8#_PIVB%;3*.N'Z3-8@`XV;8#!@EX
XM&%>'[@5\`:_N*35*%.RF`H>*("9H`:X`OD`S:P&&@$SS5ZF"4H/DQ#9P#P3+
XM`*[`J`E\%<_L($N_<``8@`;``7*`/S`/^"U/!0+0@QOFQ"%3!IQ!HX0LRR)1
XM\2O].^UQH-OG"H\O($.2_+Z`#,FIB@&^@`S)J9(!OH`OX`OX`GJ#-^`+(``]
XMN"_@"_@"K(TYX`OX`KZ`H4H-B`&^@"_@"QBJU``9X`OXM>BY&.`+^+7H.1G@
XM"U``M(`88)1((V@`&"`'<,)R`!J`!E`)C+`:('@YCFX`'`##9+G6!QK@!J@!
XMQ!W?Y08`,6<&$%/=B0%L`!@`!E@)(B0:0`E3"F``'``'B`$4`"W@7*(!;``<
XM(`:XPFJ`&R`+R\'6KQH`'[H!;@`;(`=@N8('!)(&$'<PS!H@!\"'@A<8@`;@
XM7=8O'*`&D`%PH@,2!K@!CB.3226P`10`+2`&L`&^@"^`!@`Q=Y<O`$Z2`6``
XM!/(+."!A@!N@!L@!OH`OX`:X`6Z`&^`&^`*^@"_@@+0!:(`;X`OXNV2`&$`&
XMB`&^@"\@>($!:``<X`N(`787$#,'^`*^@`,2!K@!;H`OX`NXEV(`&R`&^`*>
XML2O@"_@"O@`:X,*D`6"`+P!.L@%N@!Q@!O@"9`#?!0>P`62`+^`+P`$PS!S`
XM!O@"OH`OX`O``6J7'.`+B`%L`!P`Q)0!OH`O8/V276:`+^#"S`%,(AO@"_@"
XM9`#9A0;(`;Z`+V!3D@$VI2^`IX`"1@FEX`:``1!(+"P'N`$P3-KE!I`!8("J
XM"P3``6B`&@`'&"6"!Q@@!S@@A0>5P`8`,6>&+(S:6;]H@!J`!CB.3*(<P`IC
XM'W(`&B`&*,2"`"B`Y5(*8(`;X`9P7;(P&(`&L,%L@!A`=KF(;H`<@`8PQO2&
XMX.4&L`%&"94`!L#-1@GU"P>@=F(`&0!.D@%"(QF@=%F_U@<:P`8PF7@**&`&
XM^`*^`!H`!L!=8H`O8$22`6*`&P`'^`)D@-TE![@!<(`OX`O``6"`"],&^`*^
XM@"_@"\`!<``9(`;X`F(`&^`&P`%R`!O@"_@"UB\<X(#\`F*`]:MVL0&^@"]`
XM!BA=@I<OX`N`DT8D&.`+4`"R@%&BA;`!<``<``FS`>"D&<!VV5V,L0OS7L`!
XM8``<(`8XCG27&*`&L%UD@!C`)(H!CJ/U"P>H`7B7X"4&N`%P@-#()%J_<*(L
XM#`8PF12`+(#E:B%@`!S@!G#"9``8P`:0`4:)`Q+$O`$8I1O`!I!=JJ[@(0:0
XM`62`WP4'P,UR@.-H_<(!:@#>)08X("^OBT@&*%UJ@%$B";,!C#$%(`N8`;Z`
XM+^`+H`%@`!H`@?P"?!<;``=8O[X`&:!VP0%J@!C@"_@";@`;P`;(`6J`+^`+
XM^`*"%QH@!H@!OH`8P`;``7:7&^`+^`+6+QR@!L@!OH`8('@9D6:`+^`+D`%*
XM%Q'S"_@"1J0;`$[Z`ER->^'7HN=F@"_@UZ+G:(`OX->BYVJ`+^#7HN=L@"_@
XM"_@"OH`O(%?Y`KX``.4,&`.^@"\`0$DIOH`O`$`Y`^"`+^`+6-HP@B]``=`"
XM8H!10GA`EFR`XZ@8@P%8`KW!!K`!;H"+2`:0`>"DT(@1LP%D@"E,>/B[#D@O
XM*0?``8XC&:!VF<*4`AO@[RK$M(!S20:0`6(`&R`T8L1R@!K@.&+$:@`<X"+Z
XMNVR`'*#JNA=L@!'I!CB.5(+@)32276*`&(#EH@ID`!B`0IH!<@`;``8HQ+2`
XM&,`&^`*^`!E`!H@!;(`9X`OX`KX`&R`'J`%N@"_@"_@"0$P<``;X`KZ`O\L&
XMR`%J@"_@"_@";``90`:(`6J`+^`+4`F"EQG@"_@"9)?@!0?X`KX`E4`&@`%R
XM@"_@"\C"2A<8X`MXQJZ`+^`+^`)D@.`E!Z@!OH`OX`NP`6R`'.`&^`*^@"_`
XM!H@!;(`<X`OX`F(`&P`'6`F^@"_@"P`Q+TP9X`OX`F(`&R`'N`%L@"_@"Y`!
XM9``90`:8`;Z`+R`&P,UR@!K@"_@"9)<;@`:0`;X`G@(*&"6$!QF@=@F-&+$:
XM(`>HNNX%&R!X8;FH@AO@!NB+;@`:``:P`7"BOPL'L`$8)=E%)<")8H`;(`>P
XM`48)+.P&P`%B`)X""F"YA`<8``>P`2@D1JP&R`&JKGO!!@A>6*Z4P`:X`7``
XMENM>L`%P@$V)0HH!;``;@"4('F27&(#E2@EJ@/6+4?)=:(`8H!`+`J"`&>`+
XM^`)D`!@`![@!8(`OX`OX`D#,',`&^`*^@"_`!@A>;H`OX`N(`6R`&P`'N`&^
XM@"_@"[`!;H`<``>``;Z`+R`&L`%L@!Q`!O@"O@`9H'2I`6*`+^`+B`%J@/4K
XM!_@"OH#=!09`(+\`!2`+&"6"AQC`!H`!*"1&C`:@`4(C1@P&4,*H`AK@[](;
XMC+$<H`88)?PN'"`'.(YD%QL`!CB.5`(:8$*B`6``&H`&H`$4@"R`Y0H>8`!D
XMJ>JZ%VP`&H`&"(T8,1A`"4L);``;X`8XCA@Q&R`&B`&.HQC@!H`!;(#02`:X
XMEP[(F<$&L`%B`)8K"<,P;0`%(`N8`;Z`+^`+D`%@`&3)!O@"OH`OP`:@`6@`
XM&N`+^`*^`!L`!MB4OH`O(`:P`6R`&P`'^`*^@"\`Q#29;H`OX`N(`6X`&,`&
XMH`&^@"]`!D"68@`9X`OX`F(`&\`&B`%N@"_@"\!=?!<8X`M("+2`&&"4<*Q6
XM%:@K!A@E,K%(I]*Y\](,>\NA-!IH`!@@!R`Q`Y44P#2`#4(GG:U@$0-B`+2F
XM"9CXG`(K`39X`]DT(4L.4"OF`!"B#)`R`109BY8``;8`&L!Y?+H&N!G'WG(H
XMC0;?!0:``6``U&5E00$LO1+.9*!BA`,CI2F)`7`S&``&@`$<'V,'XA$2@P`H
XM8)0H"X(`*`"`R^(<'8"3;7LR,P89X,*$`6``TP`VT,CV@X*E#9`!+DP8``;X
XM*X(`*(#ETJ[HEH`308LR,P804\2<`?R+(``*@%VT*[HEX%P#C#HI,V/P76``
XM&``&Z&0"@K)`MG,,@@`H`)&$#<BN@Z(K"`A@1I*NA.LV+SMSK(I"#9XJ/V).
XML#:8,04`"\`"L``/Q5%X"-2HD>2-"`E`$[_O4)%1'(W""8`(K:S"'L$&R!22
XM`QX+-E@2YBHF0(F)8OJ_;BHA"`C6LIB1+H`'9T1\$'I0RJQ*6VJK(<D,E$-0
XM$1RC.@3'HGL!7[*NQ:TYI*D@RFW3V[SL,H1E$`FXK"R-/S#BPANHA!L`!V@!
XM,H(\@/+[[)XT$`"$J;$^!G81TB(E2#04X;*$#-H#@'*0DFP<O\A/I2`=EDL0
XM("``SQ"9"X:FX?]B1MER"VQ*1A(%HV<(!J$JFHKU(MK6.#?N'Z.P=@)?H5V(
XM)]&``BL02J6(/]9AN^37:,8TBGP,*?X*%2UPA-$V2IK1'O-7)!NG$#`[$J2I
XM"P96,1&J&!0Q(.BY9L;)Q@Q##`0#XXO%6Q>"JD^2:@1J%AW<87L,'89'T&;&
XMZ>%$'P>!782T_@)^[!_C7L"7DG`Q"`A2*E`A+S@P3`95P9KX#QZK5>65"`*@
XM`%9-TN@LO!7Y[)6`)[LU[D659/8V$WI,"YP99X=^RD@#02S`###LR]JXA2Y&
XMS0+EW*^)``FXK"P-BVS.>X-(`O$@9=L>WBU6,#XDR1P#D\&W',/0L)(.95#,
XM[@RTJLL;N-P@JH6RN?Q"/\+O6MP>`@)1<")@`OB"JXEZ`1@%QH[`L"+\F(K)
XM<$_[L1*49H>.T%NL.^QNNVL?<X,MH>)B$_Z*EG%NT?[>2(O@6^CM+CL!ZML3
XM]QP#)."RLC34LJ-%/V/)')V`P,[",DN]""485*.Z%_"E)&3*Q+WV``FXK"P-
XMM<R?#/M@-,1@LE$9\,PG!S'[5O*M)3+0LC.D@U)%48"Z`H*'@U1``BXK2X.+
XML2P2%1E%<GD82KT!BTUP++H7\&49B]+8-H'15#D#T*IU(3!DTX0L1>%%B]%B
XM.U^G[G$#H"HE8+W*"7!'B\ZJDC24Q6;101`LVBUTJS=`JV#'K$*-W`Y>"4L#
XM=U,6"*PKCYZ;`_X**2!$@0H0`U`F)K`T3`.KRLY0PZP#PA*-$K(L"\QP,PP(
XM,!@V"`1``BP"#04ED`@H`HN@4]@(;LH'Z1"4M":T"F%.L*H"@S-@J7@#N13^
XM)6,8NJ++T`_2D%,:"Y)`Y8/2\"J^JFWA)O^7)N`*"`*@@(#@C0@):D'.ZK-*
XM""*K.V&;BL68`%3C(6@*M``JIBD0--@`J6!H4PEN@-E%"Z!B'#)4XR$@T`8"
XM1&'M43'@)Z2/$UP=!$98KF>@$DB)?HSAFP!IG,Z.57/6J#4JP4P8TT@"\>"H
XM8@E_AMFNML/M4JJE#2,P+[^F51`^?-#<@TX/,%@#:H@W0GY@IN@'NLY,B#)*
XMGL,@@)-Q?+'SRW'B$#_$-04%,+;P25,";/*G@`*M+6.(3D@"X^2QT@)"P0FK
XMSJ0,P,S`$49KWS`"\`4EV`)B`.<1!-@":@#G$038`FX`YQ$$V`)B@!B@"_`=
XM2"$VX&$@#)*3?TS`E*"HA!&,)/#[3`.!$9:[[9"^R05]7-JP(!<A9KP;\0+S
XM\FMRU\JH]>H^;*>BH'M.GW/&6I3'`D40-,X`2\-;N*;0GOK`5YD=!@)$8=N+
XMM"`"*F$$(PG\/DY,)<`!:`#30,=RT]C"J0U%:`*N@*&ME,#<KIF?<D[0`JB8
XMRR5CHPIN`-YE"[`!N@""KUSQ-)U`+6`$(PG\/@^E!9,6*0,PK4`)'?"Y+8\E
XM)$TJ0<Z2#/@K8J$>ZB$`"/T5IT"_(WX&`^0`#TC_/,M!3[T*36ZA*8)*."1V
XM@E'J:^H85)6RX9KYI-P#%$$+H&+,A"CC6R#).DVA41CT^X1&Y``H0*MBL:M+
XM6[&XV`3Z"T6$`6*`"]./F!-@@!C@PD1=OA4U44YL&&%&R1"S@`%B@`N3YUI_
XM'C]0<K)!"T;#U'!$@3(<S6W3VPPW&TR=P,X`"H@G@^:4BD]^!YX""J@HMJE8
XM[%10,):HBY)$&.8J,Q<!OYK6?)7982!`%`X#4X9?4!T>I!PP!\`!>!<4X`=0
XMEE"$G`&;*A!\E8%,+!@($(7#P)2)A=`H(<O,P@KRA80@((@I$DS][R^X$U`$
XMJXI:@BA`QP:!7#'NQ(*!`%$X#`("O;"*(@*X*(#&)+H*5@(8X*_P&=*HY4?M
XM6GG^.P*/(V@?1RF)A;`4!3L&W-&B@X+FC\,'=[3H"JVIZ3#8`B[,+F"E2RMB
XM`@4@"U2JG*KRL?>;ENZ-+@;83!P0%1G%K^3X*L#I\::@$J0`88Y6$!T;!'(E
XM?/`.&HDZSG!H)`Z#4R$@P&"&N0HQ>AQ2QI3K3M@Z&V2V0*-%J0Z.*KTK,#@#
XMEHK#8`N(`62`+N"R.!6H!")`"%#+AKD_2]":;&9$]V`P,/A(@L;"=X#2[!D,
XM,,!*"+*`NV!$^2?N@A$%K;@C3*SC@&(1%,ZQ@B]1B`^D2R@+"\`"L("$8`N(
XM`;J`>Z$BB`F:@BN`+]#,FH(A(-,,+3$_'"]I\EI4`AP@!U@>98`NX%ZH""Z"
XM/,(@X"L,B@_EH@)09"Q:XBI8"6"`%B`KB`&6QQF@"[@7*H*+((\P"!#''[+D
XM2IJ\EJR@7]D":(`NX%ZH""Z"/,(@:")`B#)`R@109"Q:XBK(`7"`'&!YK`&Z
XM@'NA"6A1'@L40=`X`RP-T7+S4P^2)J]%)<`!;H#ET0;H`NZ%:^:GG!.T`"H&
XM:M,";@#>I<&!'UM*-@[3O`IR@!N`!]L";H`NX%[@%U2'+1'S@_&<JJL@!\`!
XM>+`M``?H`NX%W-&B2R96/M&2,0.J9"Q:XBK(`7"`0HQY[`+N!=RQ42N`2(+H
XMY+>DT#`TMNHJ6`GZE2W@PNP";L=&K0`B":*3WY)"P]#8JJM@)>A7MH`8(`;H
XM`@*-%J4Z.*I$R\UO%7RJK@*M8'F,`62`+B#0:%&J@Z.J`"()HI/?DD+#T-BJ
X&JT`K4```
X`
Xend
END_OF_FILE
  if test 22480 -ne `wc -c <'ycoding.uu'`; then
    echo shar: \"'ycoding.uu'\" unpacked with wrong size!
  fi
  # end of 'ycoding.uu'
fi
if test -f 'yw.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'yw.c'\"
else
  echo shar: Extracting \"'yw.c'\" \(11121 characters\)
  sed "s/^X//" >'yw.c' <<'END_OF_FILE'
X/* Placed into the public domain by Daniel J. Bernstein. */
X
X/* This is the source for BOTH coding methods! Y and AP are both here. */
X/* Keep this in mind when hacking the source. */
X
X#ifdef WHAP
Xstatic char whapwarning[] = "\
XWARNING! If you use AP coding except for instruction and amusement,\n\
Xyou may be infringing upon a patent.\n\
X";
X#endif
X
X#include <stdio.h>
Xextern long atol();
Xextern int getopt();
Xextern char *optarg;
Xextern int optind;
X#include "bitout.h"
X#include "percent.h"
X#include "texts.h"
X#include "huptrie.h"
X
X#ifdef WHAP
Xstatic char progname[] = "whap";
Xstatic char progged[] = "Whapped";
X#else
Xstatic char progname[] = "yabba";
Xstatic char progged[] = "Y'ed";
X#endif
X
X#define ALPHABET 256 /* do not change this! */
X
X#ifndef RESETNUM
X#define RESETNUM 8192
X#endif
X#ifndef RESETFUZZ
X#define RESETFUZZ 30 /* XXX: any suggestions? */
X#endif
Xstatic long resetnum = RESETNUM;
Xstatic long resetfuzz = RESETFUZZ; /* when in doubt, pass the buck */
X
X#ifndef NODEMAX
X#define NODEMAX (65533) /* up to 65533---could be 65534 for whap */
X#endif
X#ifndef NODENUM
X#define NODENUM NODEMAX
X#endif
X
X#ifndef MOD
X#define MOD (65536)
X#endif
X
XSTATICDECLARE(n,p,h,NODEMAX,MOD - 1)
X#ifndef WHAP
Xnode s[NODEMAX + 1];
Xhash geth[NODEMAX + 2]; /* XXX: only because of this is 65533 the default */
X#endif
X
X#define NUMOF(no) node2pos(n,no,NODEMAX)
X
X#define CHECKMAXBITS \
X((max == nextbits) && ((bits++), \
X  (nextbits = pos2ipos(n,2 * ipos2pos(n,nextbits,NODEMAX),NODEMAX))))
X
X#ifndef WHAP
X#define ADD(hash,oldnode,node) \
X( (void) ( ADDMAX(n,p,h,max,oldnode,hash,node), \
X  (geth[node2ipos(n,node,NODEMAX)] = hash), CHECKMAXBITS ) )
X#else
X#define ADD(hash,oldnode,node) \
X( (void) ( ADDMAX(n,p,h,max,oldnode,hash,node), CHECKMAXBITS ) )
X#endif
X
X#define SUB(ip1,ip2) (ip1 - ip2) /* XXXX: This breaks encapsulation! Ungood. */
X
Xstatic unsigned long savein = 0;
Xstatic unsigned long saveout = 0;
Xstatic int flagverbose = 1;
X
Xvoid goaheadandbeverbose()
X{
X long per;
X      
X per = percent(saveout,savein,10000L);
X if (per == 10000L) /* absolutely ridiculous */
X   if (flagverbose == 2)
X     fprintf(stderr,"In: %ld chars  Out: %ld chars  %s to: >9999%%\n",
X     savein,saveout,progged);
X   else
X     fprintf(stderr,"In: %ld chars  Out: %ld chars  %s by: <-9899%%\n",
X     savein,saveout,progged);
X else
X   if (flagverbose == 2)
X     fprintf(stderr,"In: %ld chars  Out: %ld chars  %s to: %ld%%\n",
X     savein,saveout,progged,per);
X   else
X     fprintf(stderr,"In: %ld chars  Out: %ld chars  %s by: %ld%%\n",
X     savein,saveout,progged,100 - per);
X}
X
Xint y[55];
Xint j;
Xint k;
X
X#define RANDOMBIT ( ( !j ? (j = 54) : --j ), \
X( !k ? (k = 54) : --k ), ( y[k] ^= y[j] ) )
X
Xvoid initrandom()
X{
X int i;
X
X#ifdef RANDINIT
X srand(RANDINIT);
X#else
X srand(1);
X#endif
X for (i = 0;i < 54;i++)
X   y[i] = ((rand()) + (rand() >> 13) + (rand() % 71)) % 2;
X y[54] = 1;
X j = 24;
X k = 0;
X for (i = 0;i < 100;i++)
X   (void) RANDOMBIT;
X}
X
Xvoid fatalinfo(x,ss)
Xint x;
Xchar **ss;
X{
X if (flagverbose) while (*ss)
X  {
X   fprintf(stderr,*(ss++),NODENUM);
X   putc('\n',stderr);
X  }
X (void) exit(x);
X}
X
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X{
X register node oldnode;
X register hash oldhash;
X register node curnode;
X register hash curhash;
X#ifndef WHAP
X register node matchnode;
X register hash matchhash;
X register node dosnode;
X register node safenode;
X#else
X register node lastnode;
X register hash lasthash;
X register node midnode;
X register hash midhash;
X#endif
X register int ch;
X register bitnum curbits;
X#ifdef WHAP
X register node firstmidnode;
X register node newnode;
X#endif
X register ipos max;
X register ipos nextbits;
X register bitnum bits;
X register ipos min;
X register long numin = 0;
X register long nextreset;
X register int flagrandom = 0;
X ipos curmax;
X ipos curnextbits;
X long eff;
X pos smax;
X
X#define PUTERR { \
Xif (flagverbose) fprintf(stderr,"%s: fatal: output error\n",progname); \
Xsavein += numin; saveout += bit_numout; /*XXX*/ \
Xif (flagverbose >= 2) goaheadandbeverbose(); (void) exit(2); }
X
X
X min = pos2ipos(n,NODENUM - 1,NODEMAX);
X
X  {
X   int opt;
X   bitword i;
X
X   while ((opt = getopt(argc,argv,"m:v^qQrz:Z:RACHUVW")) != EOF)
X     switch(opt)
X      {
X       case '?': fatalinfo(1,squsage);
X       case 'm': i = atol(optarg);
X		 if ((i < 512) || (i > NODEMAX))
X		  {
X		   if (flagverbose) fprintf(stderr,
X		      "%s: fatal: mem size out of range: must be between 512 and %ld\n",
X		      progname,(long) NODEMAX);
X		   (void) exit(1);
X		  }
X		 min = pos2ipos(n,i - 1,NODEMAX);
X		 break;
X       case 'v': flagverbose = 2; break;
X       case '^': flagverbose = 3; break;
X       case 'q': flagverbose = 0; break;
X       case 'Q': flagverbose = 1; break;
X       case 'r': flagrandom = 1; break;
X       case 'R': flagrandom = 0; break;
X       case 'z': resetnum = atol(optarg);
X		 if (resetnum < 512) resetnum = 512;
X		 break;
X       case 'Z': resetfuzz = atol(optarg); break;
X       case 'A': fatalinfo(1,sqauthor);
X       case 'C': fatalinfo(1,sqcopyright);
X       case 'H': fatalinfo(1,sqhelp);
X       case 'U': fatalinfo(1,squsage);
X       case 'V': fatalinfo(1,sqversion);
X       case 'W': fatalinfo(1,sqwarranty);
X      }
X   argv += optind;
X   argc -= optind;
X  }
X
X#ifdef WHAP
X if (flagverbose)
X   fprintf(stderr,whapwarning);
X#endif
X
X if (flagrandom)
X   initrandom();
X else
X  {
X   pos i = ipos2pos(n,min,NODEMAX) + 1;
X   bitword q = 1;
X   char r = 1;
X
X   while (q <= i / 10)
X    {
X     q *= 10;
X     ++r; /* this could overflow! :-) */
X    }
X#ifndef WHAP
X   putchar(25); putchar(1); putchar(2); putchar(2); putchar(1);
X#else
X   putchar(23); putchar(8); putchar(1); putchar(16);
X#endif
X   putchar(r);
X#ifndef WHAP
X   saveout += 6;
X#else
X   saveout += 5;
X#endif
X   while (q)
X    {
X     putchar(48 + (i / q));
X     ++saveout;
X     i -= (i / q) * q;
X     q /= 10;
X    }
X  }
X
X FIRSTHASH(h,MOD - 1)
X
X
Xrestart:
X
X STATICINIT(n,p,h,max,smax,NODEMAX,MOD - 1)
X
X nextbits = pos2ipos(n,ALPHABET,NODEMAX);
X bits = 8;
X nextreset = 0;
X eff = 0;
X
X#ifndef WHAP
X geth[node2ipos(n,topnode(n,NODEMAX),NODEMAX)] = tophash(h,MOD - 1);
X#endif
X
X for (ch = 0;ch < ALPHABET;++ch)
X  {
X   curhash = tophash(h,MOD - 1);
X   curhash = hc(curhash,ch,MOD - 1);
X   ADD(curhash,topnode(n,NODEMAX),curnode);
X#ifndef WHAP
X   s[node2ipos(n,curnode,NODEMAX)] = topnode(n,NODEMAX);
X#endif
X  }
X WASTEMAX(n,p,h,max,smax,curnode); CHECKMAXBITS;
X /* leaving space for the clear code, ALPHABET */
X
X#ifndef WHAP
X safenode = ipos2node(n,max,NODEMAX);
X#endif
X
X oldnode = topnode(n,NODEMAX);
X oldhash = tophash(h,MOD - 1);
X
X#ifndef WHAP
X matchnode = topnode(n,NODEMAX);
X matchhash = tophash(h,MOD - 1);
X#else
X lastnode = topnode(n,NODEMAX);
X lasthash = tophash(h,MOD - 1);
X#endif
X
X#ifdef WHAP
X midhash = lasthash;
X firstmidnode = 0; /* still in tree */
X#endif
X
X curbits = bits;
X curmax = max;
X curnextbits = nextbits;
X
X for (;;)
X  {
X   ch = getchar();
X   if (ch == EOF)
X    {
X     if (flagrandom)
X      {
X       int b;
X
X       if (oldnode != topnode(n,NODEMAX))
X	 if (bits_out((NUMOF(oldnode) + 1 < SUB(curmax,curnextbits)) &&
X	              RANDOMBIT ?
X	              (NUMOF(oldnode) + ipos2pos(n,curmax,NODEMAX) + 1) :
X		      (NUMOF(oldnode))
X		      ,bits) == EOF)
X	   PUTERR
X       b = RANDOMBIT; b = b + b;
X       b += RANDOMBIT; b = b + b; b += RANDOMBIT; b = b + b;
X       b += RANDOMBIT; b = b + b; b += RANDOMBIT; b = b + b;
X       b += RANDOMBIT; b = b + b; b += RANDOMBIT; b = b + b;
X       b += RANDOMBIT;
X       if (bit_fillflush(b) == EOF)
X	 PUTERR
X      }
X     else
X      {
X       if (oldnode != topnode(n,NODEMAX))
X         if (bits_out(NUMOF(oldnode),bits) == EOF)
X	   PUTERR
X       if (bit_flushbuf() == EOF)
X	 PUTERR
X      }
X     savein += numin;
X     saveout += bit_numout;
X     /* XXX: test for overflow? */
X     if (flagverbose >= 2)
X       goaheadandbeverbose();
X     (void) exit(0);
X    }
X   numin++;
X   for (;;)
X    {
X     /* We use some tricks to avoid any need for backtracking. */
X
X#ifndef WHAP
X#define MATCHADD { if (dosnode) { ADD(matchhash,matchnode,oldnode); \
Xs[node2ipos(n,dosnode,NODEMAX)] = oldnode; dosnode = oldnode; } \
Xelse ADD(matchhash,matchnode,dosnode); \
Xmatchnode = s[node2ipos(n,matchnode,NODEMAX)]; \
Xmatchhash = geth[node2ipos(n,matchnode,NODEMAX)]; \
X}
X
X/* XXXX: get rid of first if (max != min) ? */
X/* XXXX: is the inner DOWNI too slow? */
X#define MATCHDOWN if (max != min) { dosnode = 0; \
Xdo { matchhash = hc(matchhash,ch,MOD - 1); \
XDOWNI(n,p,h,matchnode,matchhash,oldnode,{break;},MATCHADD) } while(max != min); \
Xif (dosnode) s[node2ipos(n,dosnode,NODEMAX)] = oldnode; \
Xmatchnode = oldnode; }
X/* XXX: Should unroll the loop a bit. */
X
X#define SAFEMATCHDOWN { if (curnode > safenode) /*XXX: AARGH!*/ \
X{ MATCHDOWN break; } }
X#endif
X
X#ifdef WHAP
X#define MIDDOWNF lastnode = firstmidnode; \
XWASTEMAX(n,p,h,max,smax,firstmidnode); CHECKMAXBITS; firstmidnode = 0;
X
X#define MIDADDF ADD(midhash,0,midnode); firstmidnode = midnode;
X
X#define MIDADDM newnode = midnode; ADD(midhash,newnode,midnode);
X
X#define MIDDOWN if (max != min) { midhash = hc(midhash,ch,MOD - 1); \
Xif (!firstmidnode) { \
XDOWN(n,p,h,lastnode,midhash,firstmidnode,MIDDOWNF,MIDADDF) \
X} else { MIDADDM } }
X
X#define SAFEMATCHDOWN { MIDDOWN break; }
X#endif
X
X     curhash = hc(oldhash,ch,MOD - 1);
X     DOWN(n,p,h,oldnode,curhash,curnode,SAFEMATCHDOWN,{;})
X
X/* Sheer hell for your optimizer. [grin] */
X
X     if (flagrandom)
X      {
X       if (bits_out((NUMOF(oldnode) + 1 < SUB(curmax,curnextbits)) &&
X		    RANDOMBIT ?
X                    (NUMOF(oldnode) + ipos2pos(n,curmax,NODEMAX) + 1):
X		    (NUMOF(oldnode))
X	            ,curbits) == EOF)
X	 PUTERR
X       curmax = max;
X       curnextbits = nextbits;
X      }
X     else if (bits_out(NUMOF(oldnode),curbits) == EOF)
X       PUTERR
X
X     curbits = bits;
X
X#ifdef WHAP
X     if (firstmidnode)
X       setparent(p,firstmidnode,lastnode);
X     /* hence adding entire tree from neutral down onto lastnode */
X#endif
X
X     if (max == min)
X      {
X       if (numin >= nextreset)
X	{
X	 nextreset = numin + resetnum;
X	 /* XXX: this isn't accurate, we don't know how many bits... */
X	 if ((eff * ((bit_numout + 2 * bit_bufsize) / 16)) < numin + resetfuzz)
X	   eff = numin / ((bit_numout + 2 * bit_bufsize) / 16);
X	 else
X	  {
X	   savein += numin;
X	   saveout += bit_numout;
X	   /* XXX: test for overflow? */
X	   numin = 0;
X	   bit_numout = 0;
X
X	   if (flagrandom)
X	    { /*XXX*/
X	     if (bits_out((ALPHABET + 1 < SUB(max,nextbits)) && RANDOMBIT ?
X			  (ALPHABET + ipos2pos(n,max,NODEMAX) + 1) :
X			  ALPHABET,bits) == EOF)
X	       PUTERR
X	    }
X	   else
X	     if (bits_out(ALPHABET,bits) == EOF)
X	       PUTERR
X
X           CLEARHASH(h,MOD - 1)
X
X	   (void) ungetc(ch,stdin);
X	   --savein;
X	   /* XXX: Shouldn't have this goto at all. */
X	   goto restart;
X	  }
X	}
X      }
X     else
X      {
X#ifndef WHAP
X       safenode = ipos2node(n,max,NODEMAX);
X       /* if max is min, s's past the old safenode might be out of dict */
X       /* so changing safenode here wouldn't be safe */
X#else
X       lastnode = oldnode;
X       lasthash = oldhash;
X
X       midhash = lasthash;
X
X       firstmidnode = 0;
X#endif
X      }
X     oldnode = topnode(n,NODEMAX);
X     oldhash = tophash(h,MOD - 1);
X    }
X   oldnode = curnode;
X   oldhash = curhash;
X  }
X}
END_OF_FILE
  if test 11121 -ne `wc -c <'yw.c'`; then
    echo shar: \"'yw.c'\" unpacked with wrong size!
  fi
  # end of 'yw.c'
fi
echo shar: End of archive 2 \(of 4\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
