Subject:  v24i056:  Library for Purdue University Computing Center tools, Part02/02
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: 6a410d43 45c1ef42 fc0d9542 6c60aeb0

Submitted-by: Kevin Braunsdorf <ksb@cc.purdue.edu>
Posting-number: Volume 24, Issue 56
Archive-name: pucc-lib/part02

#!/bin/sh
# This is part 02 of pucc-1a
# ============= maketd/main.c ==============
if test ! -d 'maketd'; then
    echo 'x - creating directory maketd'
    mkdir 'maketd'
fi
if test -f 'maketd/main.c' -a X"$1" != X"-c"; then
	echo 'x - skipping maketd/main.c (File already exists)'
else
echo 'x - extracting maketd/main.c (Text)'
sed 's/^X//' << 'Purdue' > 'maketd/main.c' &&
/*
X * machine generated cmd line parser
X */
#include "machine.h"
X
#include <stdio.h>
#include "getopt.h"
X
char
X	RCSId[] = "$Id: main.c,v 4.8 90/07/02 15:10:43 ksb Exp $",
X	*progname = RCSId,
X	uline[] = " [-4CabcdfhlnrvVx] [-D define] [-I includedir] [-L lib.a] [-U undefine] [-j extender] [-m makefile] [-o dir] [-s suffix] [-t target] [files]",
X	*help[] = {
X		"4            use m4 to generate dependencies",
X		"C            cancel all cpp flags",
X		"D define     specify defines, as in /lib/cpp",
#if 0
X		"E            set no explicit rule",
X		"F cmd        provide a shell command to generate depends",
#endif
X		"I includedir specify include directory, as in /lib/cpp",
X		"L lib.a      specify a library to contain targets",
X		"U undefine   specify undefines, as in /lib/cpp",
X		"V            show which version of maketd is running",
X		"a            do all dependencies, including /usr/include",
X		"b            generate binary, rather than object related dependencies",
X		"c            use cpp to generate dependencies",
X		"d            dependencies to stdout, rather than Makefile",
#if 0
X		"e rule       force an explicit rule",
#endif
X		"f            force header/trailer (use with -d)",
X		"h            print this help message",
X		"j extender   supply a new extender for old makefile",
X		"l            targets live in current Makefiles directory, turn off -n",
X		"m makefile   specify makefile for update",
X		"n            targets live in their source directory",
X		"o dir        prepend DIR to target: DIR/a.o: foo.h",
X		"r            replace dependencies for targets",
X		"s suffix     change suffix target's suffix: a.suffix: foo.h",
X		"t target     change target's basename: target.o: foo.h",
X		"v            print extra verbose (debug) output to stderr",
X		"x            don't abbreviate includes",
X		"files        C source files to process for depends",
X		(char *)0
X	};
int
X	alldep = 0,
X	use_stdout = 0,
X	force_head = 0;
char
X	*explicit = (char *)0,
X	*exten = (char *)0,
X	*inlib = (char *)0,
X	*makename = (char *)0;
int
X	replace = 0,
X	verbose = 0,
X	shortincl = 1;
X
/*
X * a usage function
X */
int
usage(curopt)
int curopt;
{
X	register char **ppch;
X
X	fprintf(stderr, "%s: usage%s\n", progname, uline);
X	if ('h' != curopt)
X		return;
X	for (ppch = help; (char *)0 != *ppch; ++ppch)
X		printf("%s\n", *ppch);
}
X
/*
X * parser
X */
int
main(argc, argv)
int argc;
char **argv;
{
X	static char sbOpt[] = "4CD:EF:L:I:U:abcde:fhj:lm:no:rs:t:vVx";
X	register int curopt;
X	extern char *strrchr();
X
X	progname = strrchr(argv[0], '/');
X	if ((char *)0 == progname)
X		progname = argv[0];
X	else
X		++progname;
X
X	DoInit();
X	for (;;) {
X		if (EOF != (curopt = getopt(argc, argv, sbOpt))) {
X			/* fallthrough */;
X		} else if (EOF != getarg(argc, argv)) {
X			FileArgs(optarg);
X			continue;
X		} else {
X			break;
X		}
X		switch (curopt) {
X		case BADARG:
X			fprintf(stderr, "%s: option %c needs an argument\n", progname, optopt);
X			exit(1);
X			break;
X		case '4':
X			SetPP(1);
X			break;
X		case 'C':
X			SetCPPFlags(curopt, (char *)0);
X			break;
X		case 'D':
X			SetCPPFlags(curopt, optarg);
X			break;
X		case 'E':
X			explicit = (char *)0;
X			break;
X		case 'F':
X			UserFilter(optarg);
X			break;
X		case 'I':
X			SetCPPFlags(curopt, optarg);
X			break;
X		case 'L':
X			inlib = '\000' == optarg[0] ? (char *)0 : optarg;
X			break;
X		case 'U':
X			SetCPPFlags(curopt, optarg);
X			break;
X		case 'a':
X			alldep = 1;
X			break;
X		case 'b':
X			SetSuffix(curopt, (char *)0);
X			break;
X		case 'c':
X			SetPP(0);
X			break;
X		case 'd':
X			use_stdout = 1;
X			break;
X		case 'e':
X			explicit = '\000' == optarg[0] ? (char *)0 : optarg;
X			break;
X		case 'f':
X			force_head = 1;
X			break;
X		case BADCH:
X		case 'h':
X			usage(curopt);
X			exit(curopt != 'h');
X			break;
X		case 'j':
X			exten = optarg;
X			break;
X		case 'l':
X			SetLocalO(0);
X			break;
X		case 'm':
X			makename = optarg;
X			break;
X		case 'n':
X			SetLocalO(1);
X			break;
X		case 'o':
X			SetObjPath(optarg);
X			break;
X		case 'r':
X			replace = 1;
X			break;
X		case 's':
X			SetSuffix(curopt, optarg);
X			break;
X		case 't':
X			SetTargetName(optarg);
X			break;
X		case 'v':
X			verbose = 1;
X			break;
X		case 'V':
X			printf("%s: %s\n", progname, RCSId);
X			exit(0);
X		case 'x':
X			shortincl = 0;
X			break;
X		}
X	}
X	MakeTD();
X
X	exit(0);
}
Purdue
chmod 0444 maketd/main.c ||
echo 'restore of maketd/main.c failed'
Wc_c="`wc -c < 'maketd/main.c'`"
test 4235 -eq "$Wc_c" ||
	echo 'maketd/main.c: original size 4235, current size' "$Wc_c"
fi
# ============= maketd/M4.patch ==============
if test -f 'maketd/M4.patch' -a X"$1" != X"-c"; then
	echo 'x - skipping maketd/M4.patch (File already exists)'
else
echo 'x - extracting maketd/M4.patch (Text)'
sed 's/^X//' << 'Purdue' > 'maketd/M4.patch' &&
*** /tmp/,RCSt1021406	Fri Dec 18 14:39:34 1987
--- m4.c	Tue Jun 30 01:03:10 1987
***************
*** 11,17
X   */
X  
X  #ifndef lint
! static char rcsid[] = "$Header: /usr/src/dynix/src/usr.bin/m4/RCS/m4.c,v 2.0.1.1 87/01/05 00:28:14 root Dist $";
X  #endif
X  
X  #include <stdio.h>
X
--- 11,17 -----
X   */
X  
X  #ifndef lint
! static char rcsid[] = "$Header: /usr/src/dynix/src/usr.bin/m4/RCS/m4.c,v 2.0.1.2 87/06/30 01:02:32 doc Exp $";
X  #endif
X  
X  #include <stdio.h>
***************
*** 49,54
X  
X  #define	putbak(c)	*ip++ = c;
X  #define	getchr()	(ip>cur_ip?*--ip: getc(infile[infptr]))
X  #define	putchr(c)	if (cp==NULL) {if (curfile)putc(c,curfile);} else *op++ = c
X  char	type[] = {
X  	0,	0,	0,	0,	0,	0,	0,	0,
X
--- 49,57 -----
X  
X  #define	putbak(c)	*ip++ = c;
X  #define	getchr()	(ip>cur_ip?*--ip: getc(infile[infptr]))
+ #ifdef MAKETD
+ #define	putchr(c)	if (NULL==cp) {if (0 == makedepend && curfile)putc(c,curfile);} else *op++ = c
+ #else  MAKETD
X  #define	putchr(c)	if (cp==NULL) {if (curfile)putc(c,curfile);} else *op++ = c
X  #endif MAKETD
X  
***************
*** 50,55
X  #define	putbak(c)	*ip++ = c;
X  #define	getchr()	(ip>cur_ip?*--ip: getc(infile[infptr]))
X  #define	putchr(c)	if (cp==NULL) {if (curfile)putc(c,curfile);} else *op++ = c
X  char	type[] = {
X  	0,	0,	0,	0,	0,	0,	0,	0,
X  	0,	0,	0,	0,	0,	0,	0,	0,
X
--- 53,60 -----
X  #define	putchr(c)	if (NULL==cp) {if (0 == makedepend && curfile)putc(c,curfile);} else *op++ = c
X  #else  MAKETD
X  #define	putchr(c)	if (cp==NULL) {if (curfile)putc(c,curfile);} else *op++ = c
+ #endif MAKETD
+ 
X  char	type[] = {
X  	0,	0,	0,	0,	0,	0,	0,	0,
X  	0,	0,	0,	0,	0,	0,	0,	0,
***************
*** 130,135
X  FILE	*curfile = { stdout };
X  FILE	*infile[10] = { stdin };
X  int	infptr	= 0;
X  
X  main(argc, argv)
X  char **argv;
X
--- 135,156 -----
X  FILE	*curfile = { stdout };
X  FILE	*infile[10] = { stdin };
X  int	infptr	= 0;
+ #ifdef MAKETD
+ #include <sys/param.h>
+ int	makedepend = 0;
+ char	curfilename[MAXPATHLEN + 1];
+ newputc(x,c)
+ char x;
+ FILE *c;
+ {
+ 	if (0 == makedepend)
+ 		putc(x,c);
+ }
+ #undef putc
+ #define putc(x, c)	newputc(x, c)
+ #undef putchar
+ #define putchar(x)	newputc(x, stdin)
+ #endif MAKETD
X  
X  main(argc, argv)
X  char **argv;
***************
*** 219,224
X  #ifdef gcos
X  	tempname = "m4.tempa";
X  #endif
X  	if (argc>1)
X  		putbak(0);
X  	for (;;) {
X
--- 240,252 -----
X  #ifdef gcos
X  	tempname = "m4.tempa";
X  #endif
+ #ifdef MAKETD
+ 	if (0 == strcmp("-M", argv[1])) {
+ 		argc--;
+ 		argv++;
+ 		makedepend++;
+ 	}
+ #endif MAKETD
X  	if (argc>1)
X  		putbak(0);
X  	for (;;) {
***************
*** 243,248
X  			else if ((infile[infptr]=fopen(argv[0], READ))==ERROR) {
X  				fprintf(stderr, "m4: file not found: %s\n", argv[0]);
X  				delexit();
X  			}
X  			continue;
X  		}
X
--- 271,281 -----
X  			else if ((infile[infptr]=fopen(argv[0], READ))==ERROR) {
X  				fprintf(stderr, "m4: file not found: %s\n", argv[0]);
X  				delexit();
+ 			} 
+ #ifdef MAKETD
+ 			else if (0 != makedepend) {
+ 				strcpy(curfilename, argv[0]);
+ 				printf("%s: %s\n", curfilename, curfilename);
X  			}
X  #endif MAKETD
X  				
***************
*** 244,249
X  				fprintf(stderr, "m4: file not found: %s\n", argv[0]);
X  				delexit();
X  			}
X  			continue;
X  		}
X  		if (type[t]==ALPH) {
X
--- 277,284 -----
X  				strcpy(curfilename, argv[0]);
X  				printf("%s: %s\n", curfilename, curfilename);
X  			}
+ #endif MAKETD
+ 				
X  			continue;
X  		}
X  		if (type[t]==ALPH) {
***************
*** 671,676
X  doincl(ap, c, noisy)
X  char **ap;
X  {
X  	if (c > 0 && strlen(ap[1]) > 0) {
X  		infptr++;
X  		ip_stk[infptr] = cur_ip = ip;
X
--- 706,716 -----
X  doincl(ap, c, noisy)
X  char **ap;
X  {
+ #ifdef MAKETD
+ 	if (0 != makedepend) {
+ 		printf("%s: %s\n",curfilename, ap[1]);
+ 	}
+ #endif MAKETD
X  	if (c > 0 && strlen(ap[1]) > 0) {
X  		infptr++;
X  		ip_stk[infptr] = cur_ip = ip;
Purdue
chmod 0444 maketd/M4.patch ||
echo 'restore of maketd/M4.patch failed'
Wc_c="`wc -c < 'maketd/M4.patch'`"
test 3826 -eq "$Wc_c" ||
	echo 'maketd/M4.patch: original size 3826, current size' "$Wc_c"
fi
# ============= libopt/Makefile ==============
if test ! -d 'libopt'; then
    echo 'x - creating directory libopt'
    mkdir 'libopt'
fi
if test -f 'libopt/Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping libopt/Makefile (File already exists)'
else
echo 'x - extracting libopt/Makefile (Text)'
sed 's/^X//' << 'Purdue' > 'libopt/Makefile' &&
# Makefile for libopt.a		(Kevin Braunsdorf Feb 1987)
#
# for 
#2.9 bsd
# DEFS= -DBSD2.9
# LDFLAGS= -i
X
LIB=	${DESTDIR}/usr/local/lib
INCL=	${DESTDIR}/usr/include/local
NAME=libopt.a
X
I=/usr/include
S=/usr/include/sys
P=
X
INCLUDE=
DEBUG=	-O
DEFS=
#DEFS=	-D"strchr=index"
CFLAGS=	${DEBUG} ${DEFS} ${INCLUDE}
LDFLAGS=
X
HDR=	getopt.h
SRC=	getopt.c getarg.c rescan.c envopt.c
OBJ=	getopt.o getarg.o rescan.o envopt.o
MAN=	libopt.3l
SOURCE=	Makefile README ${MAN} ${SRC} ${HDR}
X
all: ${NAME} getopt.h
X
${NAME}:$P ${OBJ}
X	ar rc ${NAME} ${OBJ}
X
clean: FRC
X	rm -f Makefile.bak ${NAME} *.o errs a.out core lint.out
X
deinstall: ${MAN}
X	install -D ${LIB}/${NAME}
X	mkcat -R ${MAN}
X
depend: ${HDR} ${SRC} FRC
X	maketd -a ${CDEFS} ${INCLUDE} ${SRC}
X
install: all FRC
X	install -cl -m 644 ${NAME} ${LIB}/${NAME}
X	install -c -m 644  getopt.h ${INCL}/getopt.h
X
lint: ${SRC} ${HDR}
X	lint -h ${SRC}
X
mkcat: ${MAN}
X	mkcat ${MAN}
X
print: source FRC
X	lpr -J"getopt library" ${SOURCE}
X
source: ${SOURCE}
X	
spotless: clean
X	rcsclean ${SOURCE}
X
tags: ${HDR} ${SRC}
X	ctags -at ${HDR} ${SRC}
X
${SOURCE}:
X	co -q $@
X
FRC:
X
# DO NOT DELETE THIS LINE - make depend DEPENDS ON IT
X
getopt.o: $I/stdio.h getopt.c getopt.h
X
getarg.o: $I/stdio.h getarg.c getopt.h
X
rescan.o: $I/stdio.h getopt.h rescan.c
X
envopt.o: $I/stdio.h envopt.c getopt.h
X
# *** Do not add anything here - It will go away. ***
Purdue
chmod 0644 libopt/Makefile ||
echo 'restore of libopt/Makefile failed'
Wc_c="`wc -c < 'libopt/Makefile'`"
test 1360 -eq "$Wc_c" ||
	echo 'libopt/Makefile: original size 1360, current size' "$Wc_c"
fi
# ============= libopt/README ==============
if test -f 'libopt/README' -a X"$1" != X"-c"; then
	echo 'x - skipping libopt/README (File already exists)'
else
echo 'x - extracting libopt/README (Text)'
sed 's/^X//' << 'Purdue' > 'libopt/README' &&
This package allows all out PUCC local command to read their name
(in upper case) as a list of additional options to parse.  We have
found this works out quite well in general.  You do have to watch
out for Sun's make and for scripts getting the user's values.
X
Life is like that.
X
X
If you install the header file in /usr/include/local and the library
in some lib dir that ld searches by deafult you should be set.  You
will have to change the L= macro in all the Makefiles.
X
If you don't wanna install it just type
X	make
X
and the other tools will use ../libopt as the L= dir and the source for
the library.
X
kayessbee
Purdue
chmod 0644 libopt/README ||
echo 'restore of libopt/README failed'
Wc_c="`wc -c < 'libopt/README'`"
test 619 -eq "$Wc_c" ||
	echo 'libopt/README: original size 619, current size' "$Wc_c"
fi
# ============= libopt/getopt.c ==============
if test -f 'libopt/getopt.c' -a X"$1" != X"-c"; then
	echo 'x - skipping libopt/getopt.c (File already exists)'
else
echo 'x - extracting libopt/getopt.c (Text)'
sed 's/^X//' << 'Purdue' > 'libopt/getopt.c' &&
/* @(#)getopt.c
X * based on Keith Bostic's getopt in comp.sources.unix volume1
X */
X
#ifdef pdp11
#include <sys/types.h>
#endif
#include <stdio.h>
X
#include "getopt.h"
X
/*
X * get option letter from argument vector
X */
int
X	optind = 1,		/* index into parent argv vector	*/
X	optsil = 1,		/* be silent on errors			*/
X	optopt,			/* character checked for validity	*/
X	_eargc;			/* scan before args line		*/
char	*optarg,		/* argument associated with option	*/
X	**_eargv =		/* scan before args line		*/
X		(char **)0;
X
static void
tell(a,s)
char *a, *s;
{
X	fputs(a,stderr);
X	fputs(s,stderr);
X	fputc(optopt,stderr);
X	fputc('\n',stderr);
}
X
int
getopt(nargc, nargv, ostr)
int nargc;
char **nargv, *ostr;
{
X	extern char	*strchr();
X	register char	*oli;		/* option letter list index	*/
X	static char	EMSG[] = "";	/* just a null place		*/
X	static char	*place = EMSG;	/* option letter processing	*/
X
X	if ((char **)0 != _eargv) {
X		if (optind < _eargc) {
X			nargv = _eargv;
X			nargc = _eargc;
X		} else {
X			_eargv = (char **)0;
X			optind = 1;
X		}
X	}
X	if ('\000' == *place) {		/* update scanning pointer */
X		if (optind >= nargc || nargv[optind][0] != '-')
X			return EOF;
X		place = nargv[optind];
X		if ('\000' == *++place)	/* "-" (stdin)		*/
X			return EOF;
X		if (*place == '-') {	/* found "--"		*/
X			++optind;
X			return EOF;
X		}
X	}				/* option letter okay? */
X	if ((optopt = (int)*place++) == (int)':' || !(oli = strchr(ostr,optopt))) {
X		if(!*place) ++optind;
X		if (! optsil) tell(*nargv, ": illegal option -- ");
X		return(BADCH);
X	}
X	if (*++oli != ':') {		/* don't need argument */
X		optarg = NULL;
X		if (!*place)
X			++optind;
X	} else {				/* need an argument */
X		if (*place) {			/* no white space */
X			optarg = place;
X		} else if (nargc <= ++optind) {	/* no arg */
X			place = EMSG;
X			if (! optsil) tell(*nargv, ": option requires an argument -- ");
X			return(BADARG);
X		} else {
X			optarg = nargv[optind];	/* white space */
X		}
X		place = EMSG;
X		++optind;
X	}
X	return optopt;			/* dump back option letter */
}
Purdue
chmod 0444 libopt/getopt.c ||
echo 'restore of libopt/getopt.c failed'
Wc_c="`wc -c < 'libopt/getopt.c'`"
test 1999 -eq "$Wc_c" ||
	echo 'libopt/getopt.c: original size 1999, current size' "$Wc_c"
fi
# ============= libsrtunq/Makefile ==============
if test ! -d 'libsrtunq'; then
    echo 'x - creating directory libsrtunq'
    mkdir 'libsrtunq'
fi
if test -f 'libsrtunq/Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping libsrtunq/Makefile (File already exists)'
else
echo 'x - extracting libsrtunq/Makefile (Text)'
sed 's/^X//' << 'Purdue' > 'libsrtunq/Makefile' &&
# Copyright 1990 Purdue Research Foundation, West Lafayette, Indiana
# 47907.  All rights reserved.
#
# Written by Jeff Smith, jsmith@cc.purdue.edu, purdue!jsmith
#
# This software is not subject to any license of the American Telephone
# and Telegraph Company or the Regents of the University of California.
#
# Permission is granted to anyone to use this software for any purpose on
# any computer system, and to alter it and redistribute it freely, subject
# to the following restrictions:
#
# 1. Neither the authors nor Purdue University are responsible for any
#    consequences of the use of this software.
#
# 2. The origin of this software must not be misrepresented, either by
#    explicit claim or by omission.  Credit to the authors and Purdue
#    University must appear in documentation and sources.
#
# 3. Altered versions must be plainly marked as such, and must not be
#    misrepresented as being the original software.
#
# 4. This notice may not be removed or altered.
#
# Makefile for libsrtunq.a, DO NOT assume explode(1L)
#
# $Id: Makefile,v 2.4 90/11/29 08:00:34 ksb Exp $
#
X
DEST= ${DESTDIR}/usr/local/lib
HEADER= ${DESTDIR}/usr/include/local
NAME=libsrtunq.a
X
I=/usr/include
S=/usr/include/sys
P=
X
# for 2.9 bsd
# LDFLAGS= -i
# CDEFS= -DBSD2.9
LDFLAGS=
INCLUDE= 
CDEFS=
DEBUG= -O
CFLAGS= ${DEBUG} ${CDEFS} ${INCLUDE}
X
HDR=	srtunq.h
SRC=	srtapply.c srtdel.c srtdtree.c srtfree.c srtgets.c srtgti.c srtin.c \
X	srtinit.c srtmem.c
DEP=	${SRC}
OBJ=	srtapply.o srtdel.o srtdtree.o srtfree.o srtgets.o srtgti.o srtin.o \
X	srtinit.o srtmem.o
MAN=	libsrtunq.3l
SOURCE=	Makefile README ${HDR} ${SRC}
X
all:$P srtunq.h ${NAME}
X
${NAME}:$P ${OBJ}
X	ar rc ${NAME} ${OBJ}
X
clean: FRC
X	rm -f Makefile.bak *.o ${GEN} ${NAME} a.out core errs lint.out
X
deinstall: ${MAN}
X	install -D ${DEST}/${NAME}
X	mkcat -R ${MAN}
X
depend: ${HDR} ${SRC} ${GEN} FRC
X	maketd -a ${CDEFS} ${INCLUDE} ${DEP}
X
install: all FRC
X	install -cl -m 644 ${NAME} ${DEST}/${NAME}
X	install -cm 644 srtunq.h ${HEADER}/srtunq.h
X
lint: ${HDR} ${SRC} ${GEN} FRC
X	lint -h ${CDEFS} ${INCLUDE} ${DEP}
X
mkcat: ${MAN}
X	mkcat ${MAN}
X
source: ${SOURCE}
X	
spotless: clean
X	rcsclean ${SOURCE}
X
tags: ${HDR} ${SRC} ${GEN}
X	ctags -at ${HDR} ${SRC} ${GEN}
X
${HDR} ${SRC}:
X	co -q $@
X
FRC:
X
# DO NOT DELETE THIS LINE - maketd DEPENDS ON IT
X
srtapply.o: $I/stdio.h $S/types.h srtapply.c srtunq.h
X
srtdtree.o: $I/stdio.h $S/types.h srtdtree.c srtunq.h
X
srtfree.o: $I/stdio.h $S/types.h srtfree.c srtunq.h
X
srtgets.o: $I/stdio.h $S/types.h srtgets.c srtunq.h
X
srtgti.o: $I/stdio.h $S/types.h srtgti.c srtunq.h
X
srtin.o: $I/errno.h $I/stdio.h $S/types.h srtin.c srtunq.h
X
srtinit.o: $I/stdio.h $S/types.h srtinit.c srtunq.h
X
srtmem.o: $I/errno.h $I/stdio.h $S/types.h srtmem.c srtunq.h
X
# *** Do not add anything here - It will go away. ***
Purdue
chmod 0644 libsrtunq/Makefile ||
echo 'restore of libsrtunq/Makefile failed'
Wc_c="`wc -c < 'libsrtunq/Makefile'`"
test 2793 -eq "$Wc_c" ||
	echo 'libsrtunq/Makefile: original size 2793, current size' "$Wc_c"
fi
# ============= libsrtunq/srtdel.c ==============
if test -f 'libsrtunq/srtdel.c' -a X"$1" != X"-c"; then
	echo 'x - skipping libsrtunq/srtdel.c (File already exists)'
else
echo 'x - extracting libsrtunq/srtdel.c (Text)'
sed 's/^X//' << 'Purdue' > 'libsrtunq/srtdel.c' &&
/* Sorting function that inserts strings one at a time into memory.
X * Strings are null terminated.
X * Only uniq strings are stored (no count is kept of how many)
X * Any memory used is freed on init (or re-init).
X *
X * Author: Kevin Braunsdorf, PUCC, 1990
X *
X * $Log:	srtdel.c,v $
X * Revision 2.0  90/06/11  22:23:49  ksb
X * mkcat needed it
X * 
X */
X
#include <stdio.h>		/* for NULL				*/
#include <sys/types.h>		/* for void, in V7			*/
#include "srtunq.h"		/* for srtunq structs & functions	*/
X
#include <errno.h>
extern int errno, strcmp();
extern char *malloc(), *strcpy();
X
/*
X * srtdel - delete string in the sorted & unique list.
X * returns one if found, else 0
X */
int
srtdel(ent, str, compar)
SRTTABLE *ent;
char *str;
int (*compar)();
{
X	register int i;			/* string compare result	*/
X	register SRTENTRY *s, *p, *os;	/* temp				*/
X	register SRTENTRY **pps;	/* where			*/
X
X	pps = & ent->srt_top;
X	os = NULL;
X	while (NULL != (s = *pps)) {
X		if (0 == (i = (*compar)(str, s->srt_str)))
X			break;
X		os = s;
X		pps = (i > 0) ? & s->srt_more : & s->srt_less;
X	}
X
X	if (NULL == s)
X		return 0;
X
X	if (s == ent->srt_next) {	/* if we are the cur, mode cur	*/
X		p = s;
X		if (p->srt_more != NULL) {
X			p = p->srt_more;	/* go one more */
X			while (p->srt_less != NULL)/* then all the way less */
X				p = p->srt_less;
X		} else {
X			while (p != ent->srt_top && p->srt_prev->srt_more == p)
X				p = p->srt_prev;
X			p = (p == ent->srt_top) ? NULL : p->srt_prev;
X		}
X		ent->srt_next = p;
X	}
X
X	p = s->srt_more;
X	s = s->srt_less;
X
X	if (os != (*pps)->srt_prev)	/*ZZZ*/
X		abort();
X
X	free(*pps);
X	for (;;) {
X		if (NULL == s) {		/* just one kid		*/
X			*pps = p;
X			if (NULL == p)
X				break;
X			p->srt_prev = os;
X			break;
X		}
X		if (NULL == p) {
X			*pps = s;
X			s->srt_prev = os;
X			break;
X		}
X
X		if (NULL == p->srt_less) {	/* hand off the middle	*/
X			p->srt_prev = os;
X			*pps = p;
X			p->srt_less = s;
X			s->srt_prev = p;
X			break;
X		}
X		if (NULL == s->srt_more) {
X			*pps = s;
X			s->srt_prev = os;
X			s->srt_more = p;
X			p->srt_prev = s;
X			break;
X		}
X
X		if (NULL == s->srt_less) {	/* rotate into middle	*/
X			*pps = s->srt_more;
X			s->srt_more->srt_prev = os;
X			s->srt_more = (*pps)->srt_less;
X			s->srt_more->srt_prev = s;
X			(*pps)->srt_less = s;
X			s->srt_prev = *pps;
X			pps = & (*pps)->srt_more;
X			s = *pps;
X			continue;
X		}
X		*pps = p->srt_less;
X		p->srt_less->srt_prev = os;
X		p->srt_less = (*pps)->srt_more;
X		p->srt_less->srt_prev = p;
X		(*pps)->srt_more = p;
X		p->srt_prev = *pps;
X		pps = & (*pps)->srt_less;
X		p = *pps;
X	}
X	return 1;
}
Purdue
chmod 0444 libsrtunq/srtdel.c ||
echo 'restore of libsrtunq/srtdel.c failed'
Wc_c="`wc -c < 'libsrtunq/srtdel.c'`"
test 2530 -eq "$Wc_c" ||
	echo 'libsrtunq/srtdel.c: original size 2530, current size' "$Wc_c"
fi
# ============= maketd/Makefile ==============
if test -f 'maketd/Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping maketd/Makefile (File already exists)'
else
echo 'x - extracting maketd/Makefile (Text)'
sed 's/^X//' << 'Purdue' > 'maketd/Makefile' &&
# Makefile for maketd
#		Kevin Braunsdorf	Purdue University Computing Center
BIN=	${DESTDIR}/usr/local/bin
PROG=	maketd
X
#Compile time options have been moved to machine.h
X
# We might need the old style script to make our first depends!
# Use either of these lines, upper might be faster if your cc has -M
# (the second line goes to great trouble to get a `#' sign, some
# makes are very broken!)
#OLDCODE= ${CC} ${CFLAGS} -M $$file |sed -e 's/^.*\.o *: *//'
OLDCODE= ${CC} ${CFLAGS} -E $$file |\
X	 sed -n -e `echo '/^@/p' |tr "@" "\043"` |\
X	 sed -e 's/^.[ 0-9]*"\(.*\)" *$$/\1/' -e '/\/usr\/include/d'
X
L=../libsrtunq
O=../libopt
#L=/usr/include/local
I=/usr/include
S=/usr/include/sys
P=
X
#INCLUDE= -I$L
INCLUDE= -I$L -I$O
DEBUG=	-O
CDEFS=
CFLAGS=	${DEBUG} ${CDEFS} ${INCLUDE}
X
HDR=	abrv.h errors.h maketd.h main.h machine.h
SRC=	abrv.c errors.c maketd.c main.c
GEN=
DEP=	${SRC}
OBJ=	main.o abrv.o errors.o maketd.o
MAN=	maketd.1l
SOURCE=	Makefile README GCC.awk M4.patch ${MAN} ${HDR} ${SRC}
X
all: ${PROG}
X
${PROG}:$P ${OBJ}
#	${CC} -o $@ ${DEBUG} ${OBJ} -lopt -lsrtunq
#	${CC} -o $@ ${DEBUG} ${OBJ} -L /usr/local/lib -lopt -lsrtunq
X	${CC} -o $@ ${DEBUG} ${OBJ} ../libopt/libopt.a ../libsrtunq/libsrtunq.a
X
clean: FRC
X	rm -f Makefile.bak ${PROG} ${GEN} *.o a.out core errs lint.errs tags
X
# we use the old sloppy code for booting our depends
depend: ${HDR} ${SRC} ${GEN} FRC
X	mv Makefile Makefile.bak
X	sed '/^# DO NOT DELETE THIS LINE/,$$d' <Makefile.bak >Makefile
X	echo '# DO NOT DELETE THIS LINE - maketd DEPENDS ON IT' >>Makefile
X	echo '' >>Makefile
X	for file in ${DEP}; do \
X	    o=`echo $$file |sed 's/c$$/o/'` ;\
X	    ${OLDCODE} |sort -u |\
X	    awk 'BEGIN { rec = "'$${o}'" ": " ; } \
X		{ if (length(rec $$1) > 76) \
X		{ print rec, "\\" ; rec = "  " $$1 } \
X		else { rec = rec " " $$1 } } \
X		END { print rec, "\n" } ' >>Makefile ;\
X	done
X	echo '# *** Do not add anything here - It will go away. ***' >>Makefile
X
depend2: ${HDR} ${SRC} ${GEN} FRC all
X	./${PROG} -d ${INCLUDE} ${DEP}
X
install: all FRC
X	install -c -s ${PROG} ${BIN}/${PROG}
X
lint: ${HDR} ${SRC} ${GEN} FRC
X	lint -h ${CDEFS} ${INCLUDE} ${DEP}
X
mkcat: ${MAN}
X	mkcat ${MAN}
X
print: source FRC
X	lpr -p -Pstaff -J"Maketd Source" ${SOURCE}
X
shar: source FRC
X	shar ${SOURCE}
X
source: ${SOURCE}
X
spotless: clean
X	rcsclean ${SOURCE}
X
tags: ${SRC} ${HDR} ${GEN}
X	ctags -t ${SRC} ${HDR} ${GEN}
X
${SOURCE}:
X	co -q $@
X
FRC:
X
# DO NOT DELETE THIS LINE - maketd DEPENDS ON IT
X
abrv.o:  ./abrv.h ./errors.h ./machine.h ./main.h ./maketd.h abrv.c 
X
errors.o:  ./errors.h ./machine.h ./main.h ./maketd.h errors.c 
X
maketd.o:  ./abrv.h ./errors.h ./machine.h ./main.h ./maketd.h maketd.c 
X
main.o:  ./machine.h main.c 
X
# *** Do not add anything here - It will go away. ***
Purdue
chmod 0644 maketd/Makefile ||
echo 'restore of maketd/Makefile failed'
Wc_c="`wc -c < 'maketd/Makefile'`"
test 2731 -eq "$Wc_c" ||
	echo 'maketd/Makefile: original size 2731, current size' "$Wc_c"
fi
# ============= maketd/errors.c ==============
if test -f 'maketd/errors.c' -a X"$1" != X"-c"; then
	echo 'x - skipping maketd/errors.c (File already exists)'
else
echo 'x - extracting maketd/errors.c (Text)'
sed 's/^X//' << 'Purdue' > 'maketd/errors.c' &&
/*
X * this file should handle all the error recovery
X */
#include "machine.h"
X
#include <stdio.h>
#include <sys/types.h>
#include <sys/signal.h>
X
#include "maketd.h"
#include "main.h"
#include "errors.h"
X
/* RestoreFiles
X * This routine is called whenever there is a fatal error or signal. It
X * will attempt to restore the origional makefile from the backup if the
X * file has been backed up. It leaves the backup file sitting around
X * either way.
X */
void
RestoreFiles()
{
X	static char sbNoFiles[] = "%s: No files to save\n";
X
X	if (FALSE == backedup) {
X		fprintf(stderr, sbNoFiles, progname);
X		exit(3);
X	} else {
X		fprintf(stderr, "%s: Restoring %s from %s\n", progname, makename, pchBackup);
X		(void)unlink(makename);
X		if (0 != link(pchBackup, makename)) {
X			fprintf(stderr, "%s: error linking %s to ", progname, pchBackup);
X			perror(makename);
X		} else {
X			(void)unlink(pchBackup);
X		}
X		fprintf(stderr, sbNoFiles, progname);
X		exit(4);
X	}
}
X
void
OutOfMemory()
{
X	fprintf(stderr, "%s: out of memory\n", progname);
X	RestoreFiles();
}
X
/*
X * any signal calls us to clean up (with its name as our argument)
X */
int
sigtrap(pch)
char *pch;
{
X	fprintf(stderr, "%s: SIG%s received\n", progname, pch);
X	RestoreFiles();
}
X
int
errhup()
{
X	sigtrap("HUP");
}
X
int
errint()
{
X	sigtrap("INT");
}
X
int
errill()
{
X	sigtrap("ILL");
}
X
int
errtrap()
{
X	sigtrap("TRAP");
}
X
int
erriot()
{
X	sigtrap("IOT");
}
X
int
erremt()
{
X	sigtrap("EMT");
}
X
int
errfpe()
{
X	sigtrap("FPE");
}
X
int
errbus()
{
X	sigtrap("BUS");
}
X
int
errsegv()
{
X	sigtrap("SEGV");
}
X
int
errsys()
{
X	sigtrap("SYS");
}
X
int
errpipe()
{
X	sigtrap("PIPE");
}
X
int
erralrm()
{
X	sigtrap("ALRM");
}
X
int
errterm()
{
X	sigtrap("TERM");
}
X
/*
X * Stock 2.9BSD has all the below, but not as many as 4.2BSD: Want
X * SIGQUIT to drop core. Not worrying about:	SIGXCPU, SIGXFSZ,
X * SIGVTALRM, SIGPROF cannot be caught: SIGKILL, SIGSTOP Leaving
X * alone: SIGURG, SIGTSTP, SIGCONT, SIGCHLD, SIGTTIN, SIGTTOU, SIGIO 
X */
void
init_sigs()
{
X	signal(SIGHUP, errhup);
X	signal(SIGINT, errint);
X	signal(SIGILL, errill);
X	signal(SIGTRAP, errtrap);
X	signal(SIGIOT, erriot);
X	signal(SIGEMT, erremt);
X	signal(SIGFPE, errfpe);
#if !defined(DEBUG)
X	signal(SIGBUS, errbus);
X	signal(SIGSEGV, errsegv);
#endif /* !DEBUG */
X	signal(SIGSYS, errsys);
X	signal(SIGPIPE, errpipe);
X	signal(SIGALRM, erralrm);
X	signal(SIGTERM, errterm);
}
Purdue
chmod 0444 maketd/errors.c ||
echo 'restore of maketd/errors.c failed'
Wc_c="`wc -c < 'maketd/errors.c'`"
test 2359 -eq "$Wc_c" ||
	echo 'maketd/errors.c: original size 2359, current size' "$Wc_c"
fi
# ============= libsrtunq/srtapply.c ==============
if test -f 'libsrtunq/srtapply.c' -a X"$1" != X"-c"; then
	echo 'x - skipping libsrtunq/srtapply.c (File already exists)'
else
echo 'x - extracting libsrtunq/srtapply.c (Text)'
sed 's/^X//' << 'Purdue' > 'libsrtunq/srtapply.c' &&
/* Sorting function that inserts strings one at a time into memory.
X * Strings are null terminated.
X * Only uniq strings are stored (no count is kept of how many)
X * Any memory used is freed on init (or re-init).
X *
X * Author: Steve Uitti, PUCC, 1985
X *
X * $Log:	srtapply.c,v $
X * Revision 2.0  90/06/01  14:30:07  ksb
X * net release June 90
X * 
X * Revision 1.1  90/04/13  16:09:57  ksb
X * Initial revision
X * 
X * Revision 1.1  87/12/09  11:11:28  ksb
X * Initial revision
X * 
X * Revision 1.3  87/12/07  15:58:29  ksb
X * typedef names and a mainline test driver
X * 
X * Revision 1.2  87/11/12  14:39:33  ksb
X * set ENOMEM in srtin
X * 
X * Revision 1.1  87/11/11  15:54:26  ksb
X * Initial revision
X */
X
#include <stdio.h>		/* for NULL				*/
#include <sys/types.h>		/* for void, in V7			*/
#include "srtunq.h"		/* for srtunq structs & functions	*/
X
/*
X * apply given function to each string until one returns non-zero
X * return first non-zero (and stop), or 0 for "no match"
X */
int
srtapply(ent, fnc)
SRTTABLE *ent;
int (*fnc)();
{
X	register SRTENTRY *s, *top;
X
X	if (0 == (top = s = ent->srt_top)) {
X		return 0;
X	}
X	while (s->srt_less != NULL) {
X		s = s->srt_less;
X	}
X
X	for (;;) {
X		register int i;
X		if (0 != (i = (*fnc)(s->srt_str))) {
X			return i;
X		}
X		if (s->srt_more != NULL) {
X			s = s->srt_more;
X			while (s->srt_less != NULL)
X				s = s->srt_less;
X			continue;
X		}
X		for (;;) {
X			register SRTENTRY *q;
X			if (s == top)
X				return 0;
X			q = s;
X			s = s->srt_prev;
X			if (q == s->srt_less)
X				break;
X		}
X	}
}
X
Purdue
chmod 0444 libsrtunq/srtapply.c ||
echo 'restore of libsrtunq/srtapply.c failed'
Wc_c="`wc -c < 'libsrtunq/srtapply.c'`"
test 1514 -eq "$Wc_c" ||
	echo 'libsrtunq/srtapply.c: original size 1514, current size' "$Wc_c"
fi
# ============= libsrtunq/srtgets.c ==============
if test -f 'libsrtunq/srtgets.c' -a X"$1" != X"-c"; then
	echo 'x - skipping libsrtunq/srtgets.c (File already exists)'
else
echo 'x - extracting libsrtunq/srtgets.c (Text)'
sed 's/^X//' << 'Purdue' > 'libsrtunq/srtgets.c' &&
/* Sorting function that inserts strings one at a time into memory.
X * Strings are null terminated.
X * Only uniq strings are stored (no count is kept of how many)
X * Any memory used is freed on init (or re-init).
X *
X * Author: Steve Uitti, PUCC, 1985
X *
X * $Log:	srtgets.c,v $
X * Revision 2.0  90/06/01  14:30:10  ksb
X * net release June 90
X * 
X * Revision 1.1  90/04/13  16:10:05  ksb
X * Initial revision
X * 
X * Revision 1.1  87/12/09  11:12:24  ksb
X * Initial revision
X * 
X * Revision 1.3  87/12/07  15:58:29  ksb
X * typedef names and a mainline test driver
X * 
X * Revision 1.2  87/11/12  14:39:33  ksb
X * set ENOMEM in srtin
X * 
X * Revision 1.1  87/11/11  15:54:26  ksb
X * Initial revision
X */
X
#include <stdio.h>		/* for NULL				*/
#include <sys/types.h>		/* for void, in V7			*/
#include "srtunq.h"		/* for srtunq structs & functions	*/
X
/*
X * srtgets - get next string from sorted list, NULL if none more.
X */
char *
srtgets(ent)
SRTTABLE *ent;
{
X	register SRTENTRY *s;	/* tmp		*/
X	register char *p;	/* ret val		*/
X
X	if ((s = ent->srt_next) == NULL)
X		return NULL;
X
X	p = s->srt_str;
X	if (s->srt_more != NULL) {
X		s = s->srt_more;	/* go one more */
X		while (s->srt_less != NULL)/* then all the way less */
X			s = s->srt_less;
X		ent->srt_next = s;
X		return p;
X	}
X	while (s != ent->srt_top && s->srt_prev->srt_more == s)
X		s = s->srt_prev;	/* back down any more's */
X	s = (s == ent->srt_top) ? NULL : s->srt_prev;
X	ent->srt_next = s;
X
X	return p;
}
X
Purdue
chmod 0444 libsrtunq/srtgets.c ||
echo 'restore of libsrtunq/srtgets.c failed'
Wc_c="`wc -c < 'libsrtunq/srtgets.c'`"
test 1452 -eq "$Wc_c" ||
	echo 'libsrtunq/srtgets.c: original size 1452, current size' "$Wc_c"
fi
# ============= libsrtunq/srtin.c ==============
if test -f 'libsrtunq/srtin.c' -a X"$1" != X"-c"; then
	echo 'x - skipping libsrtunq/srtin.c (File already exists)'
else
echo 'x - extracting libsrtunq/srtin.c (Text)'
sed 's/^X//' << 'Purdue' > 'libsrtunq/srtin.c' &&
/* Sorting function that inserts strings one at a time into memory.
X * Strings are null terminated.
X * Only uniq strings are stored (no count is kept of how many)
X * Any memory used is freed on init (or re-init).
X *
X * Author: Steve Uitti, PUCC, 1985
X *
X * $Log:	srtin.c,v $
X * Revision 2.0  90/06/01  14:30:11  ksb
X * net release June 90
X * 
X * Revision 1.1  90/04/13  16:10:09  ksb
X * Initial revision
X * 
X * Revision 1.1  87/12/09  11:12:39  ksb
X * Initial revision
X * 
X * Revision 1.3  87/12/07  15:58:29  ksb
X * typedef names and a mainline test driver
X * 
X * Revision 1.2  87/11/12  14:39:33  ksb
X * set ENOMEM in srtin
X * 
X * Revision 1.1  87/11/11  15:54:26  ksb
X * Initial revision
X */
X
#include <stdio.h>		/* for NULL				*/
#include <sys/types.h>		/* for void, in V7			*/
#include "srtunq.h"		/* for srtunq structs & functions	*/
X
#include <errno.h>
extern int errno, strcmp();
extern char *malloc(), *strcpy();
X
/*
X * srtin - insert string in the sorted & unique list.
X * returns the string, else (char *)0 and sets errno
X */
char *
srtin(ent, str, compar)
SRTTABLE *ent;
char *str;
int (*compar)();
{
X	register char *p;		/* temp string pointer		*/
X	register int i;			/* string compare result	*/
X	register SRTENTRY *s, *os;	/* temp				*/
X	register SRTENTRY **pps;	/* where			*/
X
X	pps = & ent->srt_top;
X	os = NULL;
X	while (NULL != (s = *pps)) {
X		if (0 == (i = (*compar)(str, s->srt_str)))
X			return s->srt_str;
X		os = s;
X		pps = (i > 0) ? & s->srt_more : & s->srt_less;
X	}
X	if (NULL == (p = malloc((unsigned) (strlen(str) + sizeof(SRTENTRY))))) {
X		errno = ENOMEM;
X		return (char *)0;
X	}
X	s = (SRTENTRY *) p;
X
X	*pps = s;
X	s->srt_prev = os;
X	s->srt_less = s->srt_more = NULL;
X
X	return strcpy(s->srt_str, str);
}
X
Purdue
chmod 0444 libsrtunq/srtin.c ||
echo 'restore of libsrtunq/srtin.c failed'
Wc_c="`wc -c < 'libsrtunq/srtin.c'`"
test 1723 -eq "$Wc_c" ||
	echo 'libsrtunq/srtin.c: original size 1723, current size' "$Wc_c"
fi
# ============= libsrtunq/srtdtree.c ==============
if test -f 'libsrtunq/srtdtree.c' -a X"$1" != X"-c"; then
	echo 'x - skipping libsrtunq/srtdtree.c (File already exists)'
else
echo 'x - extracting libsrtunq/srtdtree.c (Text)'
sed 's/^X//' << 'Purdue' > 'libsrtunq/srtdtree.c' &&
/* Sorting function that inserts strings one at a time into memory.
X * Strings are null terminated.
X * Only uniq strings are stored (no count is kept of how many)
X * Any memory used is freed on init (or re-init).
X *
X * Author: Steve Uitti, PUCC, 1985
X *
X * $Log:	srtdtree.c,v $
X * Revision 2.0  90/06/01  14:30:08  ksb
X * net release June 90
X * 
X * Revision 1.1  90/04/13  16:10:02  ksb
X * Initial revision
X * 
X * Revision 1.1  87/12/09  11:11:46  ksb
X * Initial revision
X * 
X * Revision 1.3  87/12/07  15:58:29  ksb
X * typedef names and a mainline test driver
X * 
X * Revision 1.2  87/11/12  14:39:33  ksb
X * set ENOMEM in srtin
X * 
X * Revision 1.1  87/11/11  15:54:26  ksb
X * Initial revision
X */
X
#include <stdio.h>		/* for NULL				*/
#include <sys/types.h>		/* for void, in V7			*/
#include "srtunq.h"		/* for srtunq structs & functions	*/
X
/* srtdtree - recursive tree delete
X * frees all less & more entries pointed to by the srt struct
X */
void
srtdtree(srt)
register SRTENTRY *srt;
{
X	if (srt->srt_less != NULL) {
X		srtdtree(srt->srt_less);
X		free((char *) srt->srt_less);
X		srt->srt_less = NULL;
X	}
X	if (srt->srt_more != NULL) {
X		srtdtree(srt->srt_more);
X		free((char *) srt->srt_more);
X		srt->srt_more = NULL;
X	}
}
X
Purdue
chmod 0444 libsrtunq/srtdtree.c ||
echo 'restore of libsrtunq/srtdtree.c failed'
Wc_c="`wc -c < 'libsrtunq/srtdtree.c'`"
test 1226 -eq "$Wc_c" ||
	echo 'libsrtunq/srtdtree.c: original size 1226, current size' "$Wc_c"
fi
# ============= libsrtunq/srtmem.c ==============
if test -f 'libsrtunq/srtmem.c' -a X"$1" != X"-c"; then
	echo 'x - skipping libsrtunq/srtmem.c (File already exists)'
else
echo 'x - extracting libsrtunq/srtmem.c (Text)'
sed 's/^X//' << 'Purdue' > 'libsrtunq/srtmem.c' &&
/* Sorting function that inserts strings one at a time into memory.
X * Strings are null terminated.
X * Only uniq strings are stored (no count is kept of how many)
X * Any memory used is freed on init (or re-init).
X *
X * Author: Steve Uitti, PUCC, 1985  (+ ksb 1990)
X *
X * $Log:	srtmem.c,v $
X * Revision 2.0  90/06/01  14:30:13  ksb
X * net release June 90
X * 
X * Revision 1.1  90/04/13  16:24:03  ksb
X * Initial revision
X * 
X */
X
#include <stdio.h>		/* for NULL				*/
#include <sys/types.h>		/* for void, in V7			*/
#include "srtunq.h"		/* for srtunq structs & functions	*/
X
#include <errno.h>
extern int errno, strcmp();
extern char *malloc(), *strcpy();
X
/*
X * srtmem - is a string in the sorted & unique list.
X * returns the string, else (char *)0
X */
char *
srtmem(ent, str, compar)
SRTTABLE *ent;
char *str;
int (*compar)();
{
X	register char *p;		/* temp string pointer		*/
X	register int i;			/* string compare result	*/
X	register SRTENTRY *s, *os;	/* temp				*/
X	register SRTENTRY **pps;	/* where			*/
X
X	pps = & ent->srt_top;
X	os = NULL;
X	while (NULL != (s = *pps)) {
X		if (0 == (i = (*compar)(str, s->srt_str)))
X			return s->srt_str;
X		os = s;
X		pps = (i > 0) ? & s->srt_more : & s->srt_less;
X	}
X	errno = ENOENT;
X	return (char *)0;
}
X
Purdue
chmod 0444 libsrtunq/srtmem.c ||
echo 'restore of libsrtunq/srtmem.c failed'
Wc_c="`wc -c < 'libsrtunq/srtmem.c'`"
test 1240 -eq "$Wc_c" ||
	echo 'libsrtunq/srtmem.c: original size 1240, current size' "$Wc_c"
fi
# ============= maketd/machine.h ==============
if test -f 'maketd/machine.h' -a X"$1" != X"-c"; then
	echo 'x - skipping maketd/machine.h (File already exists)'
else
echo 'x - extracting maketd/machine.h (Text)'
sed 's/^X//' << 'Purdue' > 'maketd/machine.h' &&
/*
X * the macros below are used to port maketd to variaous hosts
X * fill in the ones you know.
X */
X
/* your system may define one of these by default
X * (if not set one)
X */
/* pdp11 	compile for a BSD2_9 or greater pdp11 OS		*/
/*#define pdp11						/**/
X
/* SYSV		compile for system V					*/
/*#define SYSV						/**/
X
/* bsd		compile for system V					*/
#define bsd						/**/
X
X
/* DEBUG	include more debug code for -v option			*/
#undef DEBUG						/**/
/*#define DEBUG						/**/
X
X
/* CPP_M	C preprocessor has a -M					*/
#define CPP_M						/**/
/* CPP		location of C preprocessor
X * (default "/lib/cpp ")
X */
X
/* M4_M		m4 has a -M, this is currently the only way to use m4	*/
#define M4_M
/* M4		location of m4 macro preprocessor
X * (default "/usr/bin/m4 ")
X */
X
/* INCLD	place where <file.h> files are rooted
X * (default "/usr/include")
X */
X
/* DEL_BACKUP 	delete "Makefile.bak" after each run of maketd		*/
/*#define DEL_BACKUP					/**/
X
/* here we deduce some things about the system from the info above
X * (some of these may need special cases for your strange systems)
X */
X
/* DUP2		this UNIX has Berk dup2 syscall				*/
#if defined(bsd)
#define DUP2
#endif
X
#if defined(bsd)
#define	strrchr	rindex
#define	strchr	index
#endif
X
#if !defined(bsd)
#define vfork	fork
#endif
Purdue
chmod 0644 maketd/machine.h ||
echo 'restore of maketd/machine.h failed'
Wc_c="`wc -c < 'maketd/machine.h'`"
test 1278 -eq "$Wc_c" ||
	echo 'maketd/machine.h: original size 1278, current size' "$Wc_c"
fi
# ============= libopt/getopt.h ==============
if test -f 'libopt/getopt.h' -a X"$1" != X"-c"; then
	echo 'x - skipping libopt/getopt.h (File already exists)'
else
echo 'x - extracting libopt/getopt.h (Text)'
sed 's/^X//' << 'Purdue' > 'libopt/getopt.h' &&
/*
X * get option letters from argument vector
X * then get arguemnts from vector
X * legale options passed with ':' indicating where an optarg can be
X *
X *	-- example usage --
X *
X *	static char sbOpts[] = "vnD:A:";
X *	register int curopt;
X *	register char *pch;
X *	extern char *getenv();
X *	
X *	if ((char *)0 != (pch = getenv("TESTIT")))
X *		envopt(pch);
X *
X *	optsil = 1;
X *	while (EOF != (curopt = getopt(argc, argv, sbOpts))) {
X *		switch (curopt) {
X *		case 'v': ....
X *		case 'D':
X *			addbag(optarg);
X *			break;
X *		case BADARG:
X *			fprintf(stderr, "`%c' is need an argument\n", optopt);
X *			exit(2);
X *		case BADCH:
X *			fprintf(stderr, "`%c' is not an option\n", optopt);
X *			exit(1);
X *		}
X *	}
X *	...
X *	while (EOF != getarg(argc, argv)) {
X *		f(optarg);
X *	}
X *	-- see mkcmd(1L) --
X */
extern int
X	optopt,			/* character checked for validity	*/
X	optind,			/* gross, old kludge			*/
X	optsil;			/* 1 == be silent, 0 = print errors	*/
extern char
X	*optarg;		/* argument associated with option	*/
X
#define BADCH	('?')
#define BADOPT	BADCH
#define BADARG	('*')
extern int getopt(), getarg(), rescan(), envopt();
#define rescan()	optind = 1
Purdue
chmod 0444 libopt/getopt.h ||
echo 'restore of libopt/getopt.h failed'
Wc_c="`wc -c < 'libopt/getopt.h'`"
test 1148 -eq "$Wc_c" ||
	echo 'libopt/getopt.h: original size 1148, current size' "$Wc_c"
fi
# ============= libsrtunq/srtfree.c ==============
if test -f 'libsrtunq/srtfree.c' -a X"$1" != X"-c"; then
	echo 'x - skipping libsrtunq/srtfree.c (File already exists)'
else
echo 'x - extracting libsrtunq/srtfree.c (Text)'
sed 's/^X//' << 'Purdue' > 'libsrtunq/srtfree.c' &&
/* Sorting function that inserts strings one at a time into memory.
X * Strings are null terminated.
X * Only uniq strings are stored (no count is kept of how many)
X * Any memory used is freed on init (or re-init).
X *
X * Author: Steve Uitti, PUCC, 1985
X *
X * $Log:	srtfree.c,v $
X * Revision 2.0  90/06/01  14:30:09  ksb
X * net release June 90
X * 
X * Revision 1.1  90/04/13  16:10:04  ksb
X * Initial revision
X * 
X * Revision 1.1  87/12/09  11:12:02  ksb
X * Initial revision
X * 
X * Revision 1.3  87/12/07  15:58:29  ksb
X * typedef names and a mainline test driver
X * 
X * Revision 1.2  87/11/12  14:39:33  ksb
X * set ENOMEM in srtin
X * 
X * Revision 1.1  87/11/11  15:54:26  ksb
X * Initial revision
X */
X
#include <stdio.h>		/* for NULL				*/
#include <sys/types.h>		/* for void, in V7			*/
#include "srtunq.h"		/* for srtunq structs & functions	*/
X
/*
X * srtfree - delete all the data, init the tag
X * is the structure empty?
X */
void
srtfree(ent)
SRTTABLE *ent;
{
X	if (ent->srt_top != NULL) {
X		srtdtree(ent->srt_top);
X		free((char *) ent->srt_top);
X		srtinit(ent);
X	}
}
X
Purdue
chmod 0444 libsrtunq/srtfree.c ||
echo 'restore of libsrtunq/srtfree.c failed'
Wc_c="`wc -c < 'libsrtunq/srtfree.c'`"
test 1067 -eq "$Wc_c" ||
	echo 'libsrtunq/srtfree.c: original size 1067, current size' "$Wc_c"
fi
# ============= libsrtunq/srtgti.c ==============
if test -f 'libsrtunq/srtgti.c' -a X"$1" != X"-c"; then
	echo 'x - skipping libsrtunq/srtgti.c (File already exists)'
else
echo 'x - extracting libsrtunq/srtgti.c (Text)'
sed 's/^X//' << 'Purdue' > 'libsrtunq/srtgti.c' &&
/* Sorting function that inserts strings one at a time into memory.
X * Strings are null terminated.
X * Only uniq strings are stored (no count is kept of how many)
X * Any memory used is freed on init (or re-init).
X *
X * Author: Steve Uitti, PUCC, 1985
X *
X * $Log:	srtgti.c,v $
X * Revision 2.0  90/06/01  14:30:10  ksb
X * net release June 90
X * 
X * Revision 1.1  90/04/13  16:10:07  ksb
X * Initial revision
X * 
X * Revision 1.1  87/12/09  11:12:34  ksb
X * Initial revision
X * 
X * Revision 1.3  87/12/07  15:58:29  ksb
X * typedef names and a mainline test driver
X * 
X * Revision 1.2  87/11/12  14:39:33  ksb
X * set ENOMEM in srtin
X * 
X * Revision 1.1  87/11/11  15:54:26  ksb
X * Initial revision
X */
X
#include <stdio.h>		/* for NULL				*/
#include <sys/types.h>		/* for void, in V7			*/
#include "srtunq.h"		/* for srtunq structs & functions	*/
X
/*
X * srtgti - init get string function
X */
void
srtgti(ent)
SRTTABLE *ent;
{
X	register SRTENTRY *pSE;
X
X	if (NULL != (pSE = ent->srt_top)) {
X		while (pSE->srt_less != NULL)
X			pSE = pSE->srt_less;
X	}
X	ent->srt_next = pSE;
}
X
Purdue
chmod 0444 libsrtunq/srtgti.c ||
echo 'restore of libsrtunq/srtgti.c failed'
Wc_c="`wc -c < 'libsrtunq/srtgti.c'`"
test 1067 -eq "$Wc_c" ||
	echo 'libsrtunq/srtgti.c: original size 1067, current size' "$Wc_c"
fi
# ============= libsrtunq/srtinit.c ==============
if test -f 'libsrtunq/srtinit.c' -a X"$1" != X"-c"; then
	echo 'x - skipping libsrtunq/srtinit.c (File already exists)'
else
echo 'x - extracting libsrtunq/srtinit.c (Text)'
sed 's/^X//' << 'Purdue' > 'libsrtunq/srtinit.c' &&
/* Sorting function that inserts strings one at a time into memory.
X * Strings are null terminated.
X * Only uniq strings are stored (no count is kept of how many)
X * Any memory used is freed on init (or re-init).
X *
X * Author: Steve Uitti, PUCC, 1985
X *
X * $Log:	srtinit.c,v $
X * Revision 2.0  90/06/01  14:30:12  ksb
X * net release June 90
X * 
X * Revision 1.1  90/04/13  16:10:11  ksb
X * Initial revision
X * 
X * Revision 1.1  87/12/09  11:12:50  ksb
X * Initial revision
X * 
X * Revision 1.3  87/12/07  15:58:29  ksb
X * typedef names and a mainline test driver
X * 
X * Revision 1.2  87/11/12  14:39:33  ksb
X * set ENOMEM in srtin
X * 
X * Revision 1.1  87/11/11  15:54:26  ksb
X * Initial revision
X */
X
#include <stdio.h>		/* for NULL				*/
#include <sys/types.h>		/* for void, in V7			*/
#include "srtunq.h"		/* for srtunq structs & functions	*/
X
/* srtinit - init the database tags
X * erase any knowledge, extractions at the begining
X */
void
srtinit(ent)
SRTTABLE *ent;
{
X	ent->srt_top = ent->srt_next = NULL;
}
X
Purdue
chmod 0444 libsrtunq/srtinit.c ||
echo 'restore of libsrtunq/srtinit.c failed'
Wc_c="`wc -c < 'libsrtunq/srtinit.c'`"
test 1011 -eq "$Wc_c" ||
	echo 'libsrtunq/srtinit.c: original size 1011, current size' "$Wc_c"
fi
# ============= maketd/maketd.h ==============
if test -f 'maketd/maketd.h' -a X"$1" != X"-c"; then
	echo 'x - skipping maketd/maketd.h (File already exists)'
else
echo 'x - extracting maketd/maketd.h (Text)'
sed 's/^X//' << 'Purdue' > 'maketd/maketd.h' &&
/*
X * here is the real brains of maketd
X *
X * a DependInfo node contains all the info we need to generate depends
X * for a target.
X */
#define FALSE	(0)
#define TRUE	(1)
#define BUFSIZE	256
#define MAXCOL	78
X
typedef struct DInode {
X	int
X		localo,		/* 0 == local o, 1 == non-local o	*/
X		binarydep;	/* 0 == not binary, 1 == binary		*/
X	char
X		*filename,	/* The filename to process (optarg)	*/
X		*inlib,		/* The library in which we live		*/
X		*cppflags,	/* The CPP flags for this file (-CDIU)	*/
X		*destdir,	/* The destination directory (-o)	*/
X		*suffix,	/* The suffix for the dest file (-s)	*/
X		*explicit,	/* the explicit rule to use, if any	*/
X		*basename,	/* The basename for the dest file (-t)	*/
X		*preprocessor;	/* The preprocessor to use (-c, -4, -f)	*/
X	struct DInode
X		*next;		/* The next structure in the linked list*/
} DependInfo;
X
extern int strlen();
extern char *malloc(), *strcpy();
#define	STRSAVE(Mpch)	strcpy(malloc((unsigned)strlen(Mpch)+1),Mpch)
X
extern char
X	*pchBackup;	/* the backup file name				*/
extern FILE
X	*makefp;	/* file pointer to the dest makefile		*/
extern int
X	backedup;	/* is the backup file is done			*/
Purdue
chmod 0444 maketd/maketd.h ||
echo 'restore of maketd/maketd.h failed'
Wc_c="`wc -c < 'maketd/maketd.h'`"
test 1144 -eq "$Wc_c" ||
	echo 'maketd/maketd.h: original size 1144, current size' "$Wc_c"
fi
# ============= libsrtunq/srtunq.h ==============
if test -f 'libsrtunq/srtunq.h' -a X"$1" != X"-c"; then
	echo 'x - skipping libsrtunq/srtunq.h (File already exists)'
else
echo 'x - extracting libsrtunq/srtunq.h (Text)'
sed 's/^X//' << 'Purdue' > 'libsrtunq/srtunq.h' &&
/* include file for memory resident unique sorting routines. */
X
/* database entry */
typedef struct srtbl {
X	struct srtbl *srt_prev;		/* parent			*/
X	struct srtbl *srt_less;		/* something < srt_str		*/
X	struct srtbl *srt_more;		/* something > srt_str		*/
X	char srt_str[1];		/* dynamic: 1 for null at EOS	*/
} SRTENTRY;
X
/* database tag */
typedef struct srtent {
X	SRTENTRY *srt_top;		/* root of the tree		*/
X	SRTENTRY *srt_next;		/* pointer for srtget		*/
} SRTTABLE;
X
void
X	srtinit(),			/* init for srtin		*/
X	srtfree(),			/* free a database		*/
X	srtdtree(),			/* recursive delete of subtree	*/
X	srtgti();			/* init for srtgets		*/
char
X	*srtin(),			/* insert string - return err	*/
X	*srtmem(),			/* string is a member of tree	*/
X	*srtgets();			/* get next string		*/
int
X	srtdel();			/* delete from a unique list	*/
Purdue
chmod 0444 libsrtunq/srtunq.h ||
echo 'restore of libsrtunq/srtunq.h failed'
Wc_c="`wc -c < 'libsrtunq/srtunq.h'`"
test 819 -eq "$Wc_c" ||
	echo 'libsrtunq/srtunq.h: original size 819, current size' "$Wc_c"
fi
# ============= maketd/abrv.h ==============
if test -f 'maketd/abrv.h' -a X"$1" != X"-c"; then
	echo 'x - skipping maketd/abrv.h (File already exists)'
else
echo 'x - extracting maketd/abrv.h (Text)'
sed 's/^X//' << 'Purdue' > 'maketd/abrv.h' &&
/*
X * abbreviation fucntions, maintain a unique list of strings that are
X * compressed
X * 
X * include srtunq.h first
X */
X
#define MXABR 26		/* upper case chars used		*/
extern char *abrvtbl[];		/* translation table strings		*/
extern int abrvlen[];		/* string lengths (for speed)		*/
extern struct srtent abrv;	/* include file abrevs			*/
X
extern int lngsrt();		/* compare function for abrevs		*/
extern char *hincl();		/* optimizer for include paths		*/
extern void srchincl();		/* find [A-Z] makefile defines		*/
extern void abrvsetup();	/* create abrvs, write them		*/
extern int findabr();		/* find longest abrv			*/
Purdue
chmod 0444 maketd/abrv.h ||
echo 'restore of maketd/abrv.h failed'
Wc_c="`wc -c < 'maketd/abrv.h'`"
test 621 -eq "$Wc_c" ||
	echo 'maketd/abrv.h: original size 621, current size' "$Wc_c"
fi
# ============= libopt/getarg.c ==============
if test -f 'libopt/getarg.c' -a X"$1" != X"-c"; then
	echo 'x - skipping libopt/getarg.c (File already exists)'
else
echo 'x - extracting libopt/getarg.c (Text)'
sed 's/^X//' << 'Purdue' > 'libopt/getarg.c' &&
/*
X * aux function to return arguments
X */
#include <stdio.h>
#include "getopt.h"
X
extern int _eargc;
extern char **_eargv;
X
/*
X * return each non-option argument one at a time, EOF for end of list
X */
int
getarg(nargc, nargv)
int nargc;
char **nargv;
{
X	if ((char **)0 != _eargv) {
X		if (optind < _eargc) {
X			nargv = _eargv;
X			nargc = _eargc;
X		} else {
X			_eargv = (char **)0;
X			optind = 1;
X		}
X	}
X	if (nargc <= optind) {
X		optarg = (char *) 0;
X		return EOF;
X	} else {
X		optarg = nargv[optind++];
X		return 0;
X	}
}
Purdue
chmod 0444 libopt/getarg.c ||
echo 'restore of libopt/getarg.c failed'
Wc_c="`wc -c < 'libopt/getarg.c'`"
test 519 -eq "$Wc_c" ||
	echo 'libopt/getarg.c: original size 519, current size' "$Wc_c"
fi
# ============= libsrtunq/README ==============
if test -f 'libsrtunq/README' -a X"$1" != X"-c"; then
	echo 'x - skipping libsrtunq/README (File already exists)'
else
echo 'x - extracting libsrtunq/README (Text)'
sed 's/^X//' << 'Purdue' > 'libsrtunq/README' &&
# $Id: README,v 1.1 90/11/29 07:57:03 ksb Exp $
X
These routines are used in a few PUCC tools to implement a `list of strings'
that we can add values to on the fly.  After accumulating the strings we
traverse the list (in some order) to do a final output.  Maketd(1L) is a prime
example of a fair use of these.
X
No one said they had to be beautiful.  They just work.
X
Stephen Uitti write these a long time ago, Kevin Braunsdorf added `delete'
when it was needed for another project in 1990.
Purdue
chmod 0444 libsrtunq/README ||
echo 'restore of libsrtunq/README failed'
Wc_c="`wc -c < 'libsrtunq/README'`"
test 490 -eq "$Wc_c" ||
	echo 'libsrtunq/README: original size 490, current size' "$Wc_c"
fi
# ============= maketd/GCC.awk ==============
if test -f 'maketd/GCC.awk' -a X"$1" != X"-c"; then
	echo 'x - skipping maketd/GCC.awk (File already exists)'
else
echo 'x - extracting maketd/GCC.awk (Binary)'
sed 's/^X//' << 'Purdue' | uudecode &&
begin 600 maketd/GCC.awk
M(R$O=7-R+V)I;B]N87=K"B,@5&AI<R!F:6QE(&UA>2!B92!U<V5D('=I=&@@
M5C@@87=K('1O(&9I;'1E<B!G8V,M8W!P(&]U='!U="!I;G1O"B,@<V]M971H
M:6YG(&UA:V5T9"!W:6QL('5S92X@(%1H92!L:6YE(&)E;&]W('-H;W5L9"!B
M92!P=70@:6X@=&AE"B,@<')E<')O8V5S<V]R<R!A<G)A>2!I;B!S;&]T(#`N
M"B,@(B]U<W(O=6YS=7`O;&EB+V=C8R]G8V,M8W!P("U-("5)("5&('PO=7-R
M+W5N<W5P+V)I;B]V.&%W:R`M9B`O=7-R+VQO8V%L+VQI8B]'0T,N87=K("TB
M"B,@*&EN('-O;64@<&QA8V5S(%8X(&%W:R!I<R!N87=K*0I"14=)3B!["@D@
M1E,@/2`B6R!<=%Q<7%Q=*B(["@D@:&5A9"`]("(B.PI]"@I["@D@<R`](#$[
M"GT*"B\Z+R!["@D@:&5A9"`]("0Q("0R.PH)(',@/2`S.PI]"@I["@EF;W(@
M*&L@/2!S.R!K(#P@3D8[(&LK*RD*"0EI9B`H)&L@(7X@(EY;(%QT72HD(BD*
5"0D)<')I;G0@:&5A9"P@)&L["GT*
`
end
Purdue
chmod 0444 maketd/GCC.awk ||
echo 'restore of maketd/GCC.awk failed'
Wc_c="`wc -c < 'maketd/GCC.awk'`"
test 471 -eq "$Wc_c" ||
	echo 'maketd/GCC.awk: original size 471, current size' "$Wc_c"
fi
# ============= maketd/errors.h ==============
if test -f 'maketd/errors.h' -a X"$1" != X"-c"; then
	echo 'x - skipping maketd/errors.h (File already exists)'
else
echo 'x - extracting maketd/errors.h (Text)'
sed 's/^X//' << 'Purdue' > 'maketd/errors.h' &&
/*
X * this file should handle all of our errors
X * it restores the original file and prints error messages
X * if problems are found backing out
X */
extern void
X	init_sigs(),		/* set up to handle signals to restore	*/
X	RestoreFiles(),		/* clean up files on errors		*/
X	OutOfMemory();		/* ran out of memory			*/
Purdue
chmod 0444 maketd/errors.h ||
echo 'restore of maketd/errors.h failed'
Wc_c="`wc -c < 'maketd/errors.h'`"
test 310 -eq "$Wc_c" ||
	echo 'maketd/errors.h: original size 310, current size' "$Wc_c"
fi
# ============= libopt/rescan.c ==============
if test -f 'libopt/rescan.c' -a X"$1" != X"-c"; then
	echo 'x - skipping libopt/rescan.c (File already exists)'
else
echo 'x - extracting libopt/rescan.c (Text)'
sed 's/^X//' << 'Purdue' > 'libopt/rescan.c' &&
/*
X * aux function to rescan arguemnts
X */
#include <stdio.h>
#include "getopt.h"
X
#undef rescan
X
/*
X * this function resets optind (a variable the user should not touch)
X * so the user can scan the arguments another time
X */
int
rescan()
{
X	optind = 1;
}
Purdue
chmod 0444 libopt/rescan.c ||
echo 'restore of libopt/rescan.c failed'
Wc_c="`wc -c < 'libopt/rescan.c'`"
test 256 -eq "$Wc_c" ||
	echo 'libopt/rescan.c: original size 256, current size' "$Wc_c"
fi
# ============= maketd/README ==============
if test -f 'maketd/README' -a X"$1" != X"-c"; then
	echo 'x - skipping maketd/README (File already exists)'
else
echo 'x - extracting maketd/README (Text)'
sed 's/^X//' << 'Purdue' > 'maketd/README' &&
Maketd is kinda like mkmf, it is older (here at PUCC) and we
still use it quite a bit.  The compressed output makes it neat,
and the options are nice.
X
So give it a try.
X
kayessbee,
--
Kevin Braunsdorf, ksb@cc.purdue.edu, pur-ee!ksb, purdue!ksb
Purdue
chmod 0444 maketd/README ||
echo 'restore of maketd/README failed'
Wc_c="`wc -c < 'maketd/README'`"
test 245 -eq "$Wc_c" ||
	echo 'maketd/README: original size 245, current size' "$Wc_c"
fi
# ============= maketd/main.h ==============
if test -f 'maketd/main.h' -a X"$1" != X"-c"; then
	echo 'x - skipping maketd/main.h (File already exists)'
else
echo 'x - extracting maketd/main.h (Text)'
sed 's/^X//' << 'Purdue' > 'maketd/main.h' &&
/*
X * parse options
X */
X
extern char *progname, uline[], *help[];
extern int main(), usage();
extern int alldep, use_stdout, force_head, replace, verbose, shortincl;
extern char *explicit, *exten, *inlib, *makename;
Purdue
chmod 0444 maketd/main.h ||
echo 'restore of maketd/main.h failed'
Wc_c="`wc -c < 'maketd/main.h'`"
test 216 -eq "$Wc_c" ||
	echo 'maketd/main.h: original size 216, current size' "$Wc_c"
fi
exit 0
