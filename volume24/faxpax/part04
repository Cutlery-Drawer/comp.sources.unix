Subject:  v24i042:  Email fax-sending package, Part04/05
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: aa7f3a8f 27b96e5b 6309bc88 b104f594

Submitted-by: klaus u schallhorn <cnix!klaus>
Posting-number: Volume 24, Issue 42
Archive-name: faxpax/part04

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  Readme faxhost/faxfonts/diykit.h
#   faxhost/faxfonts/hires.uue faxhost/faxfonts/lores.uue
#   faxhost/fntwrite.c faxhost/pbmtog3.c faxhost/sierracmd.h
#   sample.fax.list
# Wrapped by rsalz@litchi.bbn.com on Wed Mar 13 14:08:03 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 4 (of 5)."'
if test -f 'Readme' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Readme'\"
else
  echo shar: Extracting \"'Readme'\" \(6969 characters\)
  sed "s/^X//" >'Readme' <<'END_OF_FILE'
XThis  is   faxpak   [Copyright   (C)   1991   klaus   schallhorn,
Xklaus@cnix.uucp]
X
Xfaxpak currently runs on Suns only - not because it uses any spe-
Xcial  SunOs features, but because I don't have access to anything
Xelse. I developed faxpak mainly on a 4/60, then  moved  it  to  a
X3/60 that does all our spooling.
X
XApart from [temporary] hardware and  typeface  restrictions  [see
Xbelow]  faxpak is quite flexible. It allows faxes to be sent from
Xany networked machine. It allows aliases and distribution  lists.
XEntries  in  such  lists needing a special "for the attention of"
Xstring are forked out as separate jobs.  If you have more than  1
Xfax  modem,  faxpak  automatically  shares the load between these
Xmodems. This includes splitting of batches to distribution  lists
Xinto several queues.
X
Xfaxpak enforces permissions. You can set faxpak up to send  local
Xfaxes  any  time, long distance ones and international ones to be
Xsent at cheap rates only. You can enforce the sending of faxes to
Xany  given  phone  number at fixed times. And you can permit some
Xusers to override these time restrictions.
X
Xfaxpak was created when the post office  increased  our  contract
Xpostage rates to an almost insane level. We therefore decided [as
Xa small publishing house] to  deliver  our  newsletter  by  other
Xmeans.  We  now  deliver  by mail(1) to subscribers' mailboxes at
Xvarious online and video text systems, we allow direct modem con-
Xnection to mbox [our 3/60] and we fax our newsletter.
X
Xfaxpak is used for oneoff faxes [and only if I can't email],  and
Xhas  been  used  three  times  [we  publish every other week] for
Xbatches of ~150 faxes @ five pages each to our  subscriber  list.
XBatches of this size take a good two nights to send out, although
Xthe pure transmission time is just under 12 hours  [the  rest  is
Xengaged  phone lines, repeats because transmission errors, logins
Xsneaking in on the faxmodems, etc].
X
Xfaxpak currently supports touchbase's 2496 fax modem  and  others
Xthat  use  or emulate the sierra type fax chipset, such as zoom's
Xmx 2400s. Early december I found someone willing  and  supposedly
Xable  to ship a beta class2 modem. Unfortunately it seems to have
Xbeen sent by bicycle.  It's supposed to be here "real soon now".
X
XFor this reason faxpak does [not yet] support other  modems,  nor
Xdoes it allow incoming faxes.
X
XBecause of the peculiarities of the modems we use  faxpak  is  by
Xfar   not   what  I  wanted.  It  now  works,  but  incorporating
Xpostscript, TeX or other files has been delayed.
X
XPorting  faxpak  to  other  platforms  should  be  easy.  Writing
Xwiring.c  was  supposed  to  be  easy  as well. Provided you have
Xhardware flow control, it will be easy, however. I have not  been
Xable  to  use XON/XOFF flow ctl under SunOs, although initial and
Xparallel development under msdos showed xonoff to work  there.  I
Xdon't  know  why it doesn't under SunOs. There's some interesting
Xreference to a change to STREAMS and xon/xoff flow ctl  in  SunOs
X4.1  in  the  user  manual for a CoALM Sbus card I just received.
XI've done printer drivers and a terminal emulator using xonoff in
Xthe  past  and  using SunOs, though, so I assume the modem has to
Xtake a large part of any blame.
X
XJust to show you how "strange" the sierra type modems  are,  con-
Xsider  incoming faxes: you have to check [for each incoming byte]
Xwhether carrier is high or low in order  to  distinguish  whether
Xthe  byte  received  is  fax data or some command or confirmation
Xfrom the modem.
X
XSimilar problems were encountered with sending faxes.  You  first
Xtalk  to  the  fax modem @ 2400 baud, change to 19200, then dial,
Xand wait either for an XON [if using xonoff] or  for  CTS  to  go
Xhigh,  before  you  [in the case of xon/xoff enable flow ctl and]
Xstart squirting data. Between pages you turn  off  flow  control,
Xonly to re-enable it for the next page. Weird.
X
XYou could, of course, write a special  device  driver  to  handle
Xthis  [but  then you could have hardware dependencies in any pro-
Xgram], or you could take a black box approach, as  some  vendors'
Xtech  reps  seemed  to  slip: using a pc type mother board with a
Xlarge buffer and a fax card built on top.
X
XIf you look at wiring.c you'll find that I  left  some  stubs  in
Xthere  for using xonoff. Please don't tell me "xonoff flow ctl is
Xeasy, it's done in such and such a way" unless you get it to work
Xwith a sierra type modem. I found that the modem dropped the line
Xwhen I was using xonoff, or that the  remote  fax  machine  timed
Xout. Both not very useful.
X
X
XAs far as I know touchbase's 2496 does not yet come officially as
Xa  sierra type modem, although I bought their programmer's kit in
XNov '90.  This kit [about $100 on top of the  modem  price],  for
Xwhich  you have to sign a non disclosure agreement, consists of a
X[ccitt implementing] t.30 prom, a document virtually identical to
Xthe    "writefax.man"   document   posted   by   Nick   Pemberton
X[nick@aimed.uucp] in message 8658@aimed.uucp on Dec  8th  '90  in
Xalt.fax  and  other groups and a reprint of the t.4 file compres-
Xsion specs. Nick told me that he  downloaded  the  document  from
XZoom's  bulletin  board.  I enclose Nick's answer, in case you're
Xinterested in that bbs.
X
XI decided to base faxpak on the publicly available  document.   I
Xhave  ignored  as  non existent features offered by the touchbase
X2496 but not mentioned in the public document. If I  ever  wanted
Xto be tied down, I wouldn't use a modem.
X
XApart from that, zooms fax modem is supposed to be selling at $99
X[Direct  Micro,  1-800-288-2887  or  614-771-8771],  which is, as
Xmathemagical minded fellow administraters will observe,  somewhat
Xless  than  the price for the touchbase upgrade alone. JDR Micro-
Xdevices sells a 4800 baud fax modem for about $120. You're  bound
Xto find quite a few more by investing in a copy of Byte.
X
XThe difficulties in getting faxpak to work reliably are the  rea-
Xson  why  faxpak's  output  is limited. Being more concerned with
Xgetting output at all the next stage  obviously  is  getting  the
Xoutput  nicer.  faxpak  currently supports only its default fonts
X[they're enclosed compressed && uuencoded], and hp laserjet  type
Xfonts  [max  30 points], which are scaled to size on the fly [and
Xthey're not pretty at low resolution].
X
XOver the next few weeks I plan to improve on this, and I plan  to
Xclean  up spool.fax.c, which has become somewhat incomprehensible
Xby the last minute addition of the "ftao" string feature  [origi-
Xnally  I  assumed  someone  claiming fax receive capability would
Xhave his own fax machine].
X
Xfaxpak includes source, FaxConfig [which builds char  set  depen-
Xdent   font  sets  for  high  and  low  resolution,  faxconfig.h,
Xfax.config, Makefile, and fax.1].
X
XBecause cnix was down for 6 days I'm going to finish this off  by
Xjust  adding  a  file Howto.Install.  fax.8 pages will be done at
Xsome time in the future - but then, a lot of things will be.
X
XEnjoy.
X
Xklaus
END_OF_FILE
  if test 6969 -ne `wc -c <'Readme'`; then
    echo shar: \"'Readme'\" unpacked with wrong size!
  fi
  # end of 'Readme'
fi
if test -f 'faxhost/faxfonts/diykit.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'faxhost/faxfonts/diykit.h'\"
else
  echo shar: Extracting \"'faxhost/faxfonts/diykit.h'\" \(9104 characters\)
  sed "s/^X//" >'faxhost/faxfonts/diykit.h' <<'END_OF_FILE'
X/*
X	diykit.h
X
X	defines names to the bitmaps in diykit.data and
X	where to find a bitmap in data file
X*/
X
X#define	fpc             159	/* f as in ibmpc */
X#define	ptpc            160	/* Pt as in ibmpc */
X#define	invexcl         161	/* inverted ! */
X#define	cent            162	/* cent sign */
X#define	pound           163	/* pound sign */
X#define	currency        164	/* currency sign */
X#define	yen             165	/* yen sign */
X#define	brokenbar       166	/* broken bar */
X#define	paragraph       167	/* paragraph sign */
X#define	diaeresis       168	/* diaeresis */
X#define	copyrite        169	/* copyright sign */
X#define	femordind       170	/* fem. ordinal ind., a_ */
X#define	angledleft      171	/* << */
X#define	not             172	/* not sign, */
X#define	softhyphen      173	/* soft hyphen, same as dash */
X#define	tm              174	/* registered trade mark */
X#define	macron          175	/* macron, high - */
X#define	degree          176	/* degree sign */
X#define	plusminus       177	/* +- */
X#define	sup2            178	/* superscript 2 */
X#define	sup3            179	/* superscript 3 */
X#define	accacute        180	/* accent acute' */
X#define	micro           181	/* micro sign */
X#define	pilcrow         182	/* pilcrow, us paragraph */
X#define	middot          183	/* middle dot, */
X#define	cidilla         184	/* cidilla, */
X#define	sup1            185	/* superscript 1 */
X#define	mascordind      186	/* masc. ordinal ind., a_ */
X#define	angledrite      187	/* >> */
X#define	quarter         188	/* 1/4 */
X#define	half            189	/* 1/2 */
X#define	threequarts     190	/* 3/4 */
X#define	invqu           191	/* inverted ? */
X#define	Agr             192	/* A` */
X#define	Aac             193	/* A' */
X#define	Acirc           194	/* A^ */
X#define	Atilde          195	/* A~ */
X#define	Aumlaut         196	/* A umlaut */
X#define	Aring           197	/* A with ring above */
X#define	AE              198	/* AE */
X#define	Ccidilla        199	/* C cidilla */
X#define	Egr             200	/* E` */
X#define	Eac             201	/* E' */
X#define	Ecirc           202	/* E^ */
X#define	Eumlaut         203	/* E umlaut */
X#define	Igr             204	/* I` */
X#define	Iac             205	/* I' */
X#define	Icirc           206	/* I^ */
X#define	Iumlaut         207	/* I umlaut */
X#define	Eth             208	/* -D */
X#define	Ntilde          209	/* N~ */
X#define	Ogr             210	/* O` */
X#define	Oac             211	/* O' */
X#define	Ocirc           212	/* O^ */
X#define	Otilde          213	/* O~ */
X#define	Oumlaut         214	/* O umlaut */
X#define	multipl         215	/* multiplication */
X#define	Ooblique        216	/* O/ */
X#define	Ugr             217	/* U` */
X#define	Uac             218	/* U' */
X#define	Ucirc           219	/* U^ */
X#define	Uumlaut         220	/* U umlaut */
X#define	Yac             221	/* Y' */
X#define	Thorn           222	/* cap. icelandic thorn */
X#define	germss          223	/* small german letter sharp 's' */
X#define	agr             224	/* a` */
X#define	aac             225	/* a' */
X#define	acirc           226	/* a^ */
X#define	atidle          227	/* a~ */
X#define	aumlaut         228	/* a umlaut */
X#define	adot            229	/* a dot */
X#define	ae              230	/* ae */
X#define	ccidilla        231	/* c cidilla */
X#define	egr             232	/* e` */
X#define	eac             233	/* e' */
X#define	ecirc           234	/* e^ */
X#define	eumlaut         235	/* e umlaut */
X#define	igr             236	/* i` */
X#define	iac             237	/* i' */
X#define	icirc           238	/* i^ */
X#define	iumlaut         239	/* i umlaut */
X#define	eth             240	/* small icelandic eth */
X#define	ntilde          241	/* n~ */
X#define	ogr             242	/* o` */
X#define	oac             243	/* o' */
X#define	ocirc           244	/* o^ */
X#define	otilde          245	/* o~ */
X#define	oumlaut         246	/* o umlaut */
X#define	div             247	/* division sign */
X#define	ooblique        248	/* o/ */
X#define	ugr             249	/* u` */
X#define	uac             250	/* u' */
X#define	ucirc           251	/* u^ */
X#define	uumlaut         252	/* u umlaut */
X#define	yac             253	/* y' */
X#define	thorn           254	/* thorn */
X#define	yumlaut         255	/* y umlaut */
X
X
X/* sorted [by name] struct for bsearch, probably not the most efficient
X   way to do him, but then, how often are we going to need this.
X*/
X
Xstruct	DIY
X{
X	char	*charname;
X	int	chardef;
X} diy[] =
X{
X	"AE",           AE,             	/* AE */
X	"Aac",          Aac,            	/* A' */
X	"Acirc",        Acirc,          	/* A^ */
X	"Agr",          Agr,            	/* A` */
X	"Aring",        Aring,          	/* A with ring above */
X	"Atilde",       Atilde,         	/* A~ */
X	"Aumlaut",      Aumlaut,        	/* A umlaut */
X	"Ccidilla",     Ccidilla,       	/* C cidilla */
X	"Eac",          Eac,            	/* E' */
X	"Ecirc",        Ecirc,          	/* E^ */
X	"Egr",          Egr,            	/* E` */
X	"Eth",          Eth,            	/* -D */
X	"Eumlaut",      Eumlaut,        	/* E umlaut */
X	"Iac",          Iac,            	/* I' */
X	"Icirc",        Icirc,          	/* I^ */
X	"Igr",          Igr,            	/* I` */
X	"Iumlaut",      Iumlaut,        	/* I umlaut */
X	"Ntilde",       Ntilde,         	/* N~ */
X	"Oac",          Oac,            	/* O' */
X	"Ocirc",        Ocirc,          	/* O^ */
X	"Ogr",          Ogr,            	/* O` */
X	"Ooblique",     Ooblique,       	/* O/ */
X	"Otilde",       Otilde,         	/* O~ */
X	"Oumlaut",      Oumlaut,        	/* O umlaut */
X	"Thorn",        Thorn,          	/* cap. icelandic thorn */
X	"Uac",          Uac,            	/* U' */
X	"Ucirc",        Ucirc,          	/* U^ */
X	"Ugr",          Ugr,            	/* U` */
X	"Uumlaut",      Uumlaut,        	/* U umlaut */
X	"Yac",          Yac,            	/* Y' */
X	"aac",          aac,            	/* a' */
X	"accacute",     accacute,       	/* accent acute' */
X	"acirc",        acirc,          	/* a^ */
X	"adot",         adot,           	/* a dot */
X	"ae",           ae,             	/* ae */
X	"agr",          agr,            	/* a` */
X	"angledleft",   angledleft,     	/* << */
X	"angledrite",   angledrite,     	/* >> */
X	"atidle",       atidle,         	/* a~ */
X	"aumlaut",      aumlaut,        	/* a umlaut */
X	"brokenbar",    brokenbar,      	/* broken bar */
X	"ccidilla",     ccidilla,       	/* c cidilla */
X	"cent",         cent,           	/* cent sign */
X	"cidilla",      cidilla,        	/* cidilla, */
X	"copyrite",     copyrite,       	/* copyright sign */
X	"currency",     currency,       	/* currency sign */
X	"degree",       degree,         	/* degree sign */
X	"diaeresis",    diaeresis,      	/* diaeresis */
X	"div",          div,            	/* division sign */
X	"eac",          eac,            	/* e' */
X	"ecirc",        ecirc,          	/* e^ */
X	"egr",          egr,            	/* e` */
X	"eth",          eth,            	/* small icelandic eth */
X	"eumlaut",      eumlaut,        	/* e umlaut */
X	"femordind",    femordind,      	/* fem. ordinal ind., a_ */
X	"fpc",          fpc,            	/* f as in ibmpc */
X	"germss",       germss,         	/* small german letter sharp 's' */
X	"half",         half,           	/* 1/2 */
X	"iac",          iac,            	/* i' */
X	"icirc",        icirc,          	/* i^ */
X	"igr",          igr,            	/* i` */
X	"invexcl",      invexcl,        	/* inverted ! */
X	"invqu",        invqu,          	/* inverted ? */
X	"iumlaut",      iumlaut,        	/* i umlaut */
X	"macron",       macron,         	/* macron, high - */
X	"mascordind",   mascordind,     	/* masc. ordinal ind., a_ */
X	"micro",        micro,          	/* micro sign */
X	"middot",       middot,         	/* middle dot, */
X	"multipl",      multipl,        	/* multiplication */
X	"not",          not,            	/* not sign, */
X	"ntilde",       ntilde,         	/* n~ */
X	"oac",          oac,            	/* o' */
X	"ocirc",        ocirc,          	/* o^ */
X	"ogr",          ogr,            	/* o` */
X	"ooblique",     ooblique,       	/* o/ */
X	"otilde",       otilde,         	/* o~ */
X	"oumlaut",      oumlaut,        	/* o umlaut */
X	"paragraph",    paragraph,      	/* paragraph sign */
X	"pilcrow",      pilcrow,        	/* pilcrow, us paragraph */
X	"plusminus",    plusminus,      	/* +- */
X	"pound",        pound,          	/* pound sign */
X	"ptpc",         ptpc,           	/* Pt as in ibmpc */
X	"quarter",      quarter,        	/* 1/4 */
X	"softhyphen",   softhyphen,     	/* soft hyphen, same as dash */
X	"sup1",         sup1,           	/* superscript 1 */
X	"sup2",         sup2,           	/* superscript 2 */
X	"sup3",         sup3,           	/* superscript 3 */
X	"thorn",        thorn,          	/* thorn */
X	"threequarts",  threequarts,    	/* 3/4 */
X	"tm",           tm,             	/* registered trade mark */
X	"uac",          uac,            	/* u' */
X	"ucirc",        ucirc,          	/* u^ */
X	"ugr",          ugr,            	/* u` */
X	"uumlaut",      uumlaut,        	/* u umlaut */
X	"yac",          yac,            	/* y' */
X	"yen",          yen,            	/* yen sign */
X	"yumlaut",      yumlaut	        	/* y umlaut */
X};
X
X#define	MAX_DEF	sizeof(diy)/(sizeof(struct DIY))
END_OF_FILE
  if test 9104 -ne `wc -c <'faxhost/faxfonts/diykit.h'`; then
    echo shar: \"'faxhost/faxfonts/diykit.h'\" unpacked with wrong size!
  fi
  # end of 'faxhost/faxfonts/diykit.h'
fi
if test -f 'faxhost/faxfonts/hires.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'faxhost/faxfonts/hires.uue'\"
else
  echo shar: Extracting \"'faxhost/faxfonts/hires.uue'\" \(6635 characters\)
  sed "s/^X//" >'faxhost/faxfonts/hires.uue' <<'END_OF_FILE'
Xbegin 640 hires.data.Z
XM'YV09O @@0%CQ@P "!,J7 A@0,.'#B-"G"@Q  "+"B5*9(B0X P:'$,"P "#
XM) XX)TFJ+,F2) 00+T7*7.BQQDR&S  P"X")YP 8/S_P$VH 3%$&P)#^@;<T
XM R"G!P^: 3 UI$<;-Y$B_0#N!SPVV, R&\N,#3"S/H!Q;0"/ 3Y&S."2+1L6
XMFU>N6H$I]'A#(8( # 9X.#!XAH,9'L+P4QP&4^,9!6%X #.9 3;+ ?AE'F"&
XMLX%AGQD,$XW!3&D8/%"/! #!(XZ;"CT ^ %@#J PMW.' !0#$&W9/ #P 6 .
XM@#$ P\ D#P8L&* QSX'Y@,,!QMZ".6 G' "(N_?NX+];Q*@=-D$:ULL#T LL
XM "#W&A\: #"_/OW[]N,[=.]^_?KS,:B7WT/\O6>@?^PAJ&![!A8HD7WGR7!3
XM@1E@4F$#L&!X #@;_L"/AQMNB"&&%598H'KG':1>0@6VV*"!'GKHXHP'<G0>
XM2"OF&%( [27HXXD)G6>3CNI]@(^12.)#Y'E8$>DD0]]]9Q4,-/2%(@#6@0& 
XME@D" L"+$@D @)CV,0" F1BL-B4-KY5W # /@,,!'"2U! 8#=^:)YYYZMD32
XMG'&^N69VY7T B*$T)OJBBTDF.64-Z6D7YP?P\( ##AC L2<(9G(  !X!P#, 
XM, < @B:6#,# P!_\L(H2&)'2!$,- 9;WP%#\6'HI '    Y\W>$S@))FIFH 
XM# 9H2MVE/.!!:9R/2JA>IP $-QP[ 3 S ",',.   QPP@ ,#FM[YAS_GGGOF
XMNL4^JJ)V/^ 3+PP(T!L" ", XU6\.*3F:;NI!HP#!_$:^0 \&SZ*HW9OQCDG
XM!I>2A$!O<P"SU%)XX( '20*+"RX&'N!P\,$# ,$0034,J=T9AKSA#![\P,$'
XM&*^]UFNOX/C*(X_?'0" SPX $+2GGC[:I*3@4'II2RU=&B^_.)2DYYW4X<%#
XML\_F;..L5DJJ%C@G$00&!F/K634?/[#S04[%CDTG02=Q]8!>6]?0YI,9402;
XM?B*A3"C>V^E]$]\/WD>0#;$"OE#.X'R7'WB^1C[3X;4JOA!77"F$N=8Y'BZM
XMY0H%';24['TGNGDPV/#NWJ2"XX"F)6$@>[U8;FD[>T B1..4-BP,VP'P/(#/
XMN*J&8<P8YA@C 3$2,".#\\R8P(P999'#QAGZS*")R!QX(#SPO*L,FX/ C%K4
XM^4;=J>KZJ2:)*:;448>/#_/S?C1L?X"S%-,!M[0O//QCGZK^@ \"7HQSLK)!
XMUWZ'C >@@P,;BYI*0(  "FKI@@@ 0P;W!(/J<(!9S@H> J]C@[OASV+@@ $<
XM"!) 8R'KA<?J7ZHX8$"FZ(]N)TO=W_#7*GX(L'^P L,/NI+"(/YP@#UD%:NF
XM=(/$S42)/I3A^H(XQ"'"P(BULXYUAL-%X?0-!C>H'&P>@(P/H*-9EZ(3'#*8
XMP2V!  QO] $8Y,A!E8#0C&1DXN=@@P</]/&(,HQ1% &IJCX:TH^RV=H-5G>3
XM_Q%.;X]TR/_^QT3?W>0 _,!D%C>I14YB:84K9"$,3L*#I,')2XH4WTWP  ]6
XM7O&5P( !,'K3FX/TY0?Z @8.P)9"4&;LEQ L6@YO<+^;^ $ Q^RD,CVIS'HY
XMDUX&+* TF;C F\QO?O&#8+.V:34V>),-U*/>&9@QSC$PPISQ\$ ZK^D#)IKP
XM)GSP0#S'-2X>,,">-F! /F?  '[&@!'_A $S! H#-A34:E;C P<4RL0=7A).
XM<D*)!*7&IXI.+54K@1@.LC:EJ*GG8O"0G4@9@ &2BI12E$J32E>STF.Z%)E?
XMQ($8'^HPB=K)HC@- R-@@ T89 PU,# 8-@#0 *+^K"%PV^--\K>_B?9/)?][
XM):Q$J1(\,,"J>'! 5CO*R)D\@!@?8 <.^(":/"'@9K-)&CP^!0 < ($!;P4'
XM ^2*#P[DZAGX.,1:MX8#2SZQA^8TYQ (,=@HA>>PAHV38L$!+;ZJ<B:')*04
XM)\N^<7$ 9")#V B#-,IBSH0// !MTR F.Y9X4%5Y<@ 85/NFUI*J?)#C:S5G
XM,@]OU%:GN&6$3N? #-[.@0F_O0$:A.L#/!37CQ#,*$LZ^LZ99/-2EYK3G!S@
XM.@Z]UK74I:YT)6HU?OC!NQUUZ&=]P <?#&Q@'_S@ZUX7HL:5CT$N&EGPYCNE
XM'#A1)E $ @_T"P0\  %G.NM1J4KE  ,4F ,&X($!TN6/?_##P?6=*4<6>[H*
XM"^W"%LXPAC>LX<42) =*G<D%-[G2TU7D0(PC\6K:M;4<=)4ABXU<BF<LXQK3
XM^,8VEK&'89 #OS)D/ T!3W8W"[H6/[;(3_J'DO]QG1QX5B9 CO*B7E3D#\_V
XM21_0%SA   ,N ^]@=9+J%>D !CK\@!L?8$1]FRL3/+!UI2O%'#P^.-*2VID 
XM=OY8R'8 CQT0&4L\%N^3-G0P.I.$F1Z[;,@.!CX;Q8 @*UKK6I<)@X-12H5B
XM$S,0Q R&%<+C [QX0' <#0,)#YJQ<Y9=(#_DP]J5E ,<^-Y>3_;H$,MD !SB
XM$ PA,!]#&<H^P,:/L.>#2UQ:Y=$O=M*D )@:'L *#G 88I:#9J9E0W=.'C,8
XM !_M8Y&XV<UP7HV<D8LID9K[W"(%+6B//2OU["XA YZRH@KD*%(_628C'O%V
XM&I>S?-O.W_G&$P?*A@'&D@H0I0:C>K[-TH:K9&S <,H& & H#P!CX!D5*3\8
XML'%VLUDD'Z X)$<>R8D\34FD%K23HOG/E@/TY2Z/.2/VX0V:'_O1108ITY3+
XM\Y+@@P<_O[FIG=2PB-:IYRKY$QP"A4.:Q" &MG;2',!Q!WB$[+)YQ@ !((!G
XMDNH9!QN 1P; T5*8ECH&R2;2 [!A)!P $ Y&C/LK5>CV#\#B <OD!P!\^/1N
XM$^GD# A\X-E%>(#-)I<W/[*RU<H2!+S&4X&"!PAP (+JB(L#+\#'"6;M]!C<
XM.R0EWUS)!X  T@\ $Z</50#^?/8K.PD/L-\8NF=/6CQP !\/X$2W;OYQ(B$T
XM-4EG"9\,  SBB^<B?7NZRHDT#T\T/PP,@/X,$#%]&V##^AZP>EO,2D$0'%L&
XM]W42(JVZ/O2-RGRK7=8'SRM,I\M@Z$2*9SSS['4,'.M8 P!#_G<&#-S@9@P 
XMT!?MY"FE)@-1]W>L-GD@@#,\ PA 0P >0 #V9$]0]'UI%Q*_TCCAH3?V<3H#
XMHA_@L7J2TQ%0YW<<,7H/ 7HD-Q'?IW@AX3.EPA\^HB CAE8C-H,]PB,#YGZ?
XMQQ$&  (_N "@((0(  Q%B&2.5@/+AU9*@@_9\H2$$ !1*&]4Z"*T! @S@(6 
XM,'$3=SJEACCJX0<8((8S@ %E& ,8@(9E6(8_X =MN',[AP<:((>'=&PV '\L
XM,F4[4H5\Z")V>( WL5):!#S PP'88(A7&!4 $"[A$C(A<P/P (GZ%B2>=X$,
XM\67XX &P5G\DM1I_  B?:"9!8Q\_( !_8 !GX AGX Q^ %H?]X4FR!! 0 "S
XM>'+=5T&X>(NW>'*S.(LHXGDNR!'E55[FUC_D15[GIR^L1B/MU5YVV(-0@EC2
XM:%C4.(V'98>NEQ&M\SH8A0&7]0  \ !/$4O@T&DTTT'A\@ ,<  ]L59T(E+J
XM!0<;,BI[X7F]QQ$XI25(F'PVL'P3QG@J,08,< 9P80S(8 2((  )B0A"P) '
XMR0Q&4$X[I1(<Y6A-1"19EF7_]@&@P)%2A5*<=W*_&$;[V!#VAUH8,$N\ 0@I
XMB2?XER:3$P,W (CP(B]*$FXP:3FEMD@E66\Z*9.QN!!%=W0$29 020PF0 PB
XMH)2$8 2'8 C$8 S$8 ;>I#X:59&T=@/!*!/_T&#^4)+'1DR#\U[H8W[O!9:4
XM> /9R!'SYAO+R(<*(4@WL9/WB!"$!@ZXJ"6_ EM  P&I(E]5)I/^B!!S RVE
XMDX%9I!)+9UV!Z5$W<4&KMWK@"(XLAI98$@,R560\P &;*7B>^9F>Z0 <()H?
XMX ZE*8A9A)DTN2+_PP-PX)JP21T=1$CI]8J8:8DKTC.O)25X4VI]99GC@WRD
XMLQ[?X9M;^3,.V(<O$F.@XYO0B)REDA?Q)A&%V72-N99/(DMD8RP8, "!P0 &
XM4%)2(TMSB9D?5S, @ #IF9X8@ #MB0..YP-H()\ @ SU&0"(@)\#P _[N9[J
XMJ2.^.9AM-:#JZ4QX@ #\D ",D  $P <-:B9N!@\!( P3&@!^$ "CUCDQ8%\W
XMT4ZT80 ( *(/@ 'L& 2H8*)C@ 1_@ 0^P ]VY9\P"J ;BH<_IH<*X24&PAU 
XMLXBS^3[>B ,>L)B"XF@@IA!F,A_[X25Z 0;DDXSH5Q2JI5K]XSZU%TS\T*+M
XM1*2,E"7K 1_WT:3O]:2K-:93>B3#4Z6V=Z57>FP]IA!@6A0$  )@BFNXAC[K
XM!3OM8Z8^:GMIBJ5L*CYB<@ @(*@%  H%0#=SRF]V2J;K0Z68PJ=VY:=$>F]E
XMJ8^)6J?I<Z=EVG9H&JEK2J35U!W%ESZCXB).JJB9"@?<V*AZVJEJFJ6TE@-U
XM*93_< #_P #!@*NZFJO,P #,@ '\ *P8\*O,\ /!8*PP$ S)B@?_P*QY\ _/
XMRJ8"FA&(< #(D%P3A0&WF&]LU"<>=$<B5*I><D$P 'ZQDB9'2B & D6$1$5$
XM)&:3!445:"/@-U-<HJ.$QZZ4Y:Y69$3QFD0]9!7@)RV!>E0-  @'FY(IJ:]'
XMQ*]%]$K_*J]Z1Z\%8:1)<;%(H1 ,*T4."Z\_)+%+1+&^DZY)ZA]"! ]>@8(H
XM.$DHRWE[ 7ZJQ"5>.A]FXD@KJ+*ST;*41+&>)1'1"0QD8[,X^T@LZQ4"JW )
XMD1=Y$9<M.[0K6+0N&R3@-ZL:BT(LQ#&J\@\&H+4PU+4.L#[5P0/1=$!'JW(/
XM  %GFP PH+9QX YM2T_W%+?YM$_]Q  N1U #95!L\'N0*K XEQ#H>A\EVSHU
XMM30/EX\XU30#(Z36*;5/MQ!ZV8 [6I@19;@4=5&8BU$E :Z-=3+OMT<6P1T"
XM  C$AR<DL5AS8KG;F;D7I;A8(T)^NSIG>[8;  .URW^+Q4TWQ;H5I;B7PIR>
XM&P.^0WS$6WQ-5W0/(T'4P;L7]5S]$D*=2Q/O=YPAX9GA&9X_\1.1F3.XDX'9
XMBRSV5U*"Y[?/F45WF;IXP%,\!0:,P+ZY)9 "*08,(+\V@ 'U:RFORQ6=]+(R
XM::2">Q%*NB7#Z .25< "XW@(H&B9E3#TBIF0VZ7=<1]F,L &;,#P"9\*S&BL
XM]WX[Y#C&RR<43%DB_$,7G, _JL$""WX*4:E%H1 A7,$B#+>PMFB:E<(S53I"
XM=F$#S'ZU>:?ME8PT(E^ 2:\&&!)_  !'7*!(S!0A58QV=ED<D"0XV7 O]5(I
XMC)L*06AS%C$"9!(P $  A+7W]T*&$ /,$ /<P _X$#,I')3M H, W!\)D65#
XMQ&5<9FGP$#:<1@=P0 ]GEF8I?)P% L>5B1!TG$)=5FF?EL>A%'=\;&9HIF9$
XM_)QP?+ )"[1-=\@$X66+K,=Q1P-P ,F 3,38"0 >  2GK % H,H;T+B';,>*
XMK#2-+%6@+,J2[+DR0+5)B[$7JSE:ID)WW,FS'$2U_,>W++TRH'(%>[ (  C-
XM?+ ^PQ"O# ?!+,N91LRA;,P""QE%%C(_P =G8 YC8 P!8 @!X @_@"[\$ >Y
XM,<YS8 [D=37;3*,KHL6&1FFH8EF8A<(X*F/E.@.K61$]\F]9C&KW'#""U$E/
XM+&O;C,4XS!WV4="%5F[LD]"N1E*QA@^-YKD?,2$]DG_Y-\82O<6EA="LIM"7
XMQ0,,3:\S0+T)P<+Z:)<&3=$F[2$HS9DKS='/^3C<H2 )(8[BV);T9J8^*;TS
XM4,H(XCCWH1! K9Q#W2@HQ]&SZL&EFR=9G)Q";2!0;23;/*V[K+29+')1AGQC
XM;1%0*[#H(1,0  0*>TKBV,H;D$*])  XP(X/P V^B@%\0%JRL[A9,Z0R4:XT
XM0,\.  2%K0! @-@+  R+K;%,/$J0C70[]W-!1Z\TL)H\'<#'"U$/0Q"275J 
XMPIB6[=#$"1X1#6^<_39PF'$=Q+AH'914G116C=HU=72K'3NMS71H?9R"2J@@
XM4 "_#0X%@$#(J]J?K72Z;=GE^]+&6[Q9G-JVC73(+=J>6R5%=GP6 9(@"62\
XM&=@RP"9.TBXJ=0!W%U)JI+[8$ .8H-YK"#*2L9AS@YI:]-T"*M \0M )$7NR
XM1WLB]3[!A'N<\ #M][*0,B$&0LCKHA#ZS=_FYM^V!^ ',.!22RN#8]H?/-L(
XML> ,?F[_G7L"+K UL)I&BKD*'GL;WM<0T^$!+N$=(0,U0-JP!=%+G1#RYP'T
XM9V=C#-),VB/^]QP < 8 ,(!8XN)!J1#!$1QQ9J:T)\4.%^1./I<N[M((,<8B
X63>/R9.->5W\YKG\[SB,]#H!WX.2> A#!
X 
Xend
END_OF_FILE
  if test 6635 -ne `wc -c <'faxhost/faxfonts/hires.uue'`; then
    echo shar: \"'faxhost/faxfonts/hires.uue'\" unpacked with wrong size!
  fi
  # end of 'faxhost/faxfonts/hires.uue'
fi
if test -f 'faxhost/faxfonts/lores.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'faxhost/faxfonts/lores.uue'\"
else
  echo shar: Extracting \"'faxhost/faxfonts/lores.uue'\" \(4403 characters\)
  sed "s/^X//" >'faxhost/faxfonts/lores.uue' <<'END_OF_FILE'
Xbegin 640 lores.data.Z
XM'YV09O P@0%CQ@P "!,B' " H<.&$ ,D?*B0X P:"A5B@($#SL:/,"" R$@2
XM@,4:)1$R"X!I (P/_ R 80#L#[P,@ Z:R6C1!DF:/^"QP<:,&1M@/\ UP,>H
XMJ%%L06DBM'@#(8,!'@[,\!"&7QA,,V!XF(DM +\!9@P,8S ,@QD8/ !L+(B#
XMI \ 8P $ 10&T @ =_F , -F&)A@P,8 \P%G:L$<*0< DDP9D,24) G2@($9
XM6(#)$ T $$T:(L// (!ICI%2]&G+@%++!I;Z\V>&HC7+(/DY Z8&L Z ^\%/
XM.'#?J$MJ/HC9-NS/Q)T[KPB#!D;,V!$&H,T]N6:4V4E^P#<>NV:?X;-7IDZC
XM:DK.8&3#9BA@-  &<GE6KUOR 3@.<," P4P$,C"3@ #ZQQYD)7WPW(/2 3)>
XM>0D15 -G#<*# PYX,  #?O@<  P')C'P!S]\\.=8#:PUR \/=<%#&3[WP6  
XM' S J&"%,-2P6TKXQ<7. (PXP  .)OKSAS_W-<EC#<R1] ,^," P B!3PD"B
XMAT=R,)YPU-5P'4G^<8 '#AC, (A->&QT) ,<8/  / $ L2)X)+WA#![\@%%7
XM8^!L)]D! #@  (EAHB>>AC@(*&"6 QK( !]\? !/F.Z1"0P/\( 1*1P\_,#.
XM?1YU] $X8:JH'D0D4?0D@^&YJM!#N)D$@PT8IH<0.)*Y%ANJ^MG0HJZG(E0L
XM9@39\*.NADJ6FF2&9G9KE!D- (P#'F'@(0#Q>18; -/Q:,.8&3V #Y)CF&.,
XM!,S(P(P9[+!QABXX/& N=3;@F=%MP,@D$Y<OG8L!'!S@<Y>XBF9DDZ,>8A 4
XMPQ_^@8]-^&::T0'(F"D@" C$!T;''G+  QX[.F:#J@K] 0X< ;IIX\M<2JPR
XMOK JS,^'.(.1% Q@X&PB/R=2=T.N-OO,\\X]FP0 'TOK=\.PY2+# SX>?0P&
XM"&#X<" &(S^ CM#+9H2'!T8S0%S98X\M-+4*!46K:7 '%930Y"IT #]*<Z:W
XM20$2A ,X']#&XPWZ*H0'/#S# $P,@-R )3!_PP#'F7C$-7C""OF1]^9Z(U"E
XMS#0.;K%"!A-<>>5LL&$&,V<P,P8C\7A@L- H)\2'!TCRP( -#,S 0 R,P, ,
XM#&Q4S@>BCMU0LT+^C2Q@@04*N&')MC::DDT89,] ]I9BD)_WFFM.'0Y0,P^.
XM\Y$6& 8S,9Q9+XT- '" WV&G# Y'.#N,>,\$8= A'M%R# [8EI /L ,'?)A)
XM8XJ%!R P !P,>-$S+L4C'-0M(2=ZW1 (49D. L(_U/-;X1(RMK*5#0<(X$"]
XM@"5 S-F.!]++GI8^! 8'@$%$(G)6!4>7D'EX(PR, .(<F#$')MP #3Y(&TC&
XM5SN$5&Y# '( .'!XK?],C@>4&M_R;.<#''! A=@2CK6<,Z<Y42<'1$L9/X# 
XM R#@ 0"! L8! .$  _#  $OZ!]YXE(/R < _A@IDH08IR$(.TC\$R4']$A(?
XMSGBO6>#ZE=*\AQ\^$E!!J,HD'#>IR4["$9$PR,$%)0(M%NJ*CR,\94G^\0_'
XMY,"%V@%7),,5GD3R,"5) 0$,YM2HGH&!#C_@QAF;"( WUL5[EHJ3MC!  &UY
XM  ,[H* KMYB2 \ C3GMS)@ZL69$8$ 0SE]*;I237,R D#@;P^  ON@D#/Z9D
XM3M@T&Y4.Q8%[5<B;BT2(< Q@(PA\P#ZE*<T/!#<5;Q(P):>"2\^28BA> H@!
XMXVEG=5+R1N\A\YIHRIY&L\<'RQ6T1RD)UQPCY!P*?126"/'80E"ETI8:" /@
XM>(!JO'G+8GY/+AX!Q@8 X0%P? 0#_*CD1XGYS[<9%2)38B<U2R(QX#F5$4_=
XMAS>ZZ4U=+0PD6,6'1TT2@Z[J2D0 <M1/=VG*=L8@GR6YPS6U!X%F,@!W&X '
XM^+@:@X,VB$IP\.6 .)).6"CM9EV]("[QP8#"-@D_^!DH55.9(>G]$1X@P "2
XM7A"Z@L8 I6\[E5$1, !,!$":=*TI2?#0IHUFSXOX>  GJ$K,T<)0A@8R # D
XM<YE[QF"I))F')\+0.T38 !L>@(>!$#"2>\H@C9CQ0(=L! 9K84N%7NRF#-Q9
XMDMMI:WO\'  8MM.7,P @+NV4 5JEQ \0U(57="2 [H)F7+L& +T/$8VA7&,:
XMRP KO(*%FZSTRRKC,G:DW)%-?!K3K=K(\5OA1:D!0+  4"" H*=L9PV6UQA\
XM!& EA"#I@QBGI@T,LIVX2HD?TH2!&)#X!WX0JX#PH &UW5-8O(&-0C0<H6XJ
XM*SO>@X$U.8 -#A_JK3BX0:=>;-<#X,,#V]L>!OYP+?O\P0!G<(8?F/;B_ *!
XM %/BF):)BX I7?D]EV4L'WR@/1CX@ _6B@YLA .F%V-V,G#VH)R_55 ;\% X
XM#9,3 '( #A"<B0$/\*Q<,< !'=_WLL245'Q4^>*ECA,#9V $,HR!" $@0@C,
XM,$+K!&2I;@X-.X'CU@= P;-. R"IRHG!TU1Y "^"@W$<F&+MVGF#\28DJ1;5
XM%:WMBM#*9H?6^?7/AB*=:6((X1"&((8Q4L=IT-*:L0CY!Y,87= ;N-!:_FHN
XMA'6MZII&2,WA(DYF5%T[_Q 7CG/TD!G30^LM*FBVJ'(4]<P3 ^N19+LQ=1*C
XMVTD^7?&  X4->, =X"5WY)BK.+!UV^#! U 1S&@J[.8 =36HV=(96?7.KRI)
XM&1N+\WN$(X70!TU);QRX,-T'9HA,5<EOT9;D;P[ P0 8$/._C7M#"JD+ @" 
XM  P@  <^0 , D!$ 1 P ;SO'. ZVJ',((  ?"6 $'T 4 &$$0'Q@1J.41H. 
XM0 <!%7]  @>0SO.RI[J/(94Q0M9\*(Y@0'8BZJ8B$>(K;O$+VS4\T'C0A(>Q
XM'ZR@.8C2=N4826OAW88>VKO__"[WZ_!+)G<'ATRPE7B!]9T??^=J#L!S ! 4
XMP//>,KSD\UYYOC/^GJ]42+8C/WD<!<STF)>[>_ ^QLG N_6E7WSL44_, _R#
XM <$ /@.8 50,,.,'P8!!,/#PCSRT$O5+Q9C&,, QCX%,2UT+5&QZ=EP,X8=0
XMGSF1T71VOY[%#&A[G,IQ6_29= - _  C?^+.SU[UP^!'A&H (#!0DYO%'VD^
XM<R+U9Q+'Q1PT(17OYW\Y X#TEWX$.%'VX2Q((2/\]39RXVS'A2<6)QIN4X%Q
XM P]S4R''A1X,@7(=>%0/<8$5<5SN<8""<X(>R! J*((<<3WWXR;_P$\ZB#,<
XM(#-E=5PU\P 0D  P$ ?ND#N[TSN_$SS#4SPC@SP$6%5- G[ T#QX\#R*)BG2
XMLT(KZ%6[8BV$8H58"#T-,ST_>%8+ 0BR92!BF#Y9N(4A-%W,(80;  /;T89D
XMN#5FV(77(5NRA1!XF(5ZR(4B& /0=A\,8  8X!+O51N\8B/7U86P1%8C@P/8
XM  9!Q ACP !BL#M<@P,)58CN47? ,&8F!#!'DD*$J'[UEA ;N#0^<(H^@T(J
XM%(>WE89K" :FB(HGI(IQ>%QT!P8R@1"[*(NI6(L_.%VN""VPZ$5@! =BY"V?
XM4488*%XI4W;8HSV$-AZY-E=8IWXR4&3_L2$-@TXSQ$_&$ /,P ^^=G\R<$'?
XM%TD(D4N[I"&)\TO!M((R,$+MIV_TR$OW"$S")((R<'( H'_\-X]]5H^]Q#,"
XMJ8\\Y % H % L $ON)  Z4L/29")!@P(^(_VJ)'Y2) U0R@(  @G22@*J4L9
XMZ9 CJ7YAH2MG-@;&$ "&L"1]09-GMH(S0%TDL6,;,4E QDV_<G\SL$BG01N+
XM-B>PE25R44_M&(X']8J .&@?XI2$9D\P.4JS)8P8PI1N@I50R9.,E6U5V93S
XME)51.0,N1(J *'*?,2%K>4M4^4=P*2'DL9:UTRL>N6@A%R%RR9-+Y8+&(DL2
XM<9BG!H(8N!D* 0% P'\/  @;<#^\@@,.P W^PSWP$'<\\8Y^Y ! H ! L ""
XMLS"-@E4"HE4K2 .+Y);R,R(M(U8;$8<T,)6]DA!@%9MC19L7Q)<&HD^PJ6(R
XM1)L@YWF>!RRY*9RS^8,TH&#](CC)B57+N9HN-RN6 0"68BD<EQGOV%I6(1<[
XM%B ]!A9O1U8'=W\TL$5)R2U.5%JFA5JJM8(7$F.$(E2D95JG53#Q*8(LTBIJ
XMV)?MB9_9HY^KQ9]HI6@!BI_P6:#J!R4E49?655@8D%V#UUW?18!BDA)Q@4SX
X7L%'<F!^9QY]E^3+$^$P22J'<!0C>%1<E
X 
Xend
END_OF_FILE
  if test 4403 -ne `wc -c <'faxhost/faxfonts/lores.uue'`; then
    echo shar: \"'faxhost/faxfonts/lores.uue'\" unpacked with wrong size!
  fi
  # end of 'faxhost/faxfonts/lores.uue'
fi
if test -f 'faxhost/fntwrite.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'faxhost/fntwrite.c'\"
else
  echo shar: Extracting \"'faxhost/fntwrite.c'\" \(11391 characters\)
  sed "s/^X//" >'faxhost/fntwrite.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <malloc.h>
X#include <ctype.h>
X
X#include "../faxconfig.h"
X
X/*
X	fntwrite.c
X
X	very preliminary kit to do text -> pbm.
X
X	currently uses some stuff I ripped off [my own] chartpak.
X	knows about hpljet fonts, uses diy font to construct bitmap,
X	doesn't know anything about faxing, however.
X
X	first released version 0.99 [desperado version]
X	cleaned up Dec 18nd, '90
X	Copyright (C) 1990, klaus schallhorn, klaus@cnix.uucp
X
X	Permission to use, copy, modify, and distribute this software 
X	and its documentation for any purpose and without fee is hereby 
X	granted, provided that the above copyright notice appear in 
X	all copies and that both that copyright notice and this permission 
X	notice appear in supporting documentation. 
X
X	This software is provided "as is" without express or implied warranty.
X*/
X
X#ifndef	MAX_HITE
X#define	MAX_HITE	3600	/* 12 in @ 300 dpi */
X#endif
X
Xextern	FILE *outfp;
X
X#define	ESC		'\033'
X#define	setpix(y,x)	(block[y][x>>3] |= bit[x&7])
X
Xstatic	unsigned char *block[MAX_HITE];
Xstatic	int cols, lines, max_ln, max_col, xmax_used, ymax_used, font_hite, 
X	spacelen, tablen, curX, curY;
Xint	font_type, bm_len;
X
Xstatic	int x204[2700], y196[MAX_HITE], y97[MAX_HITE], *yptr;
Xextern	int fax_mode;
X
Xextern	char *PGM;
X
Xstatic	unsigned char bit[] =
X{
X	0x80,
X	0x40,
X	0x20,
X	0x10,
X	0x08,
X	0x04,
X	0x02,
X	0x01
X};
X
Xstruct	fd	/* hp laserjet font header, fonts <= 30 pts/ old laserjet plus */
X{		/* I don't have enough data on how fonts > 30 pts are done. */
X		/* 4.2.91: have now, will add this later */
X	unsigned char	null, one;
X	unsigned char	two;
X	unsigned char	fon_type;
X	unsigned char	four, five;
X	unsigned char	msb_base, base_line;
X	unsigned char	eigth, cell_width;
X	unsigned char	msb_cell_hite, cell_hite;
X	unsigned char	orient;
X	unsigned char	spacing;
X	unsigned char	symbol, set;
X	unsigned char	msb_pitch, pitch;
X	unsigned char	msb_hite, hite;
X	unsigned char	tw, twone;
X	unsigned char	twtwo;
X	unsigned char	style;
X	unsigned char	stroke;
X	unsigned char	type_face;
X} fdata;
X
Xstruct	cd	/* char header for same */
X{
X	unsigned char 	null,
X			one,
X			two,
X			three,
X			orient,
X			five;
X	unsigned char	msb_l_offset, l_offset;
X	unsigned char	msb_t_offset, t_offset;
X	unsigned char	msb_width, width;
X	unsigned char	msb_hite, hite;
X	unsigned char	msb_delta, delta;
X} cdata;
X
Xstruct	FNT_BITMAP	/* one for each char */
X{
X	short len, hite, clen, toffs, loffs;
X	unsigned char **CH;
X	short *SH;
X} font[256];
X
Xint	(*prt_func)();	/* function to copy a character bitmap */
Xint	prt_bmchr(), prt_hpchr();
X
Xfont_init(name)
Xchar *name;
X{
X	FILE *hp;
X	int i, *Yptr;
X	char tmp[4];
X
X	struct FNT_BITMAP *cf;
X	double x, dpi;
X
X	for (i=0; i<256; i++)	/* just to be safe */
X	{
X		cf = &font[i];
X		cf->CH = (unsigned char **)NULL;
X		cf->SH = (short *)NULL;
X		cf->len = cf->hite = cf->clen = cf->toffs = 0;
X	}
X
X	if ((hp = fopen(name, "r")) == NULL)
X	{
X		fprintf(stderr,"%s: can't open %s font\n",PGM,name);
X		return(ERROR);
X	}
X
X	if (fread(tmp, sizeof(char), 3, hp) != 3)
X	{
X		fprintf(stderr,"%s: can't read fontfile %s\n",PGM,name);
X		return(ERROR);
X	}
X	if (!strncmp(tmp, "fxL", 3))
X	{
X		font_type = COARSE;
X		bm_len = 16;
X		prt_func = prt_bmchr;
X		i = rd_bmfont(hp);
X	}
X	else if (!strncmp(tmp, "fxH", 3))
X	{
X		font_type = FINE;
X		prt_func = prt_bmchr;
X		bm_len = 32;
X		i = rd_bmfont(hp);
X	}
X	else if (!strncmp(tmp, "\033)s", 3))
X	{
X		font_type = HP;
X		prt_func = prt_hpchr;
X		i = rd_hpfont(hp);
X	}
X	else
X	{
X		fprintf(stderr,"%s: header doesn't look like a font: %02x%02x%02x\n",
X			tmp[0],tmp[1],tmp[2]);
X		return(ERROR);
X	}
X
X	if (i)
X		return(ERROR);
X
X	fclose(hp);
X
X	if (font_type == HP)
X	{
X		for (i=1; i<2700; i++)
X		{
X			x = (double)i * 204.15;
X			x /= 300.0;
X			x204[i] = (int)x;
X		}
X		if (fax_mode == 1)
X		{
X			Yptr = yptr = y97;
X			dpi = 97.79;
X		}
X		else	
X		{
X			Yptr = yptr = y196;
X			dpi = 195.58;
X		}
X		for (i=1; i<MAX_HITE; i++)
X		{
X			x = (double)i * dpi;
X			x /= 300.0;
X			*Yptr++ = (int)x;
X		}
X	}
X	return(0);
X}
X
Xmk_bm(x,y)
Xint x,y;
X{
X	int i;
X
X	if (x%32)			/* set to 32bit/4byte boundary */
X		x = x+32-(x%32);
X	x /= 8;
X
X	for (i=0; i<y; i++)
X	{
X		if ((block[i] = (unsigned char *)calloc(x,sizeof(unsigned char))) == NULL)
X		{
X			fprintf(stderr,"%s: not enough memory\n",PGM);
X			return(ERROR);
X		}
X	}
X
X	for (; i<MAX_HITE; i++)
X		block[i] = NULL;
X
X	cols = x;
X	lines = y;
X	max_ln = lines-1;
X	max_col = (cols*8)-1;
X	return(0);
X}
X
Xend_bm()
X{
X	int i, j;
X	extern char tname[];
X
X	ymax_used = min(ymax_used+4, MAX_HITE);
X
X	if (fprintf(outfp,"P4\n%d\n%d\n",(xmax_used*8),ymax_used) == EOF)
X	{
X		fprintf(stderr,"%s: can't init pbmfile %s\n",PGM,tname);
X		return(ERROR);
X	}
X	for (i=0; i<ymax_used; i++)
X	{
X		if ((j = fwrite(block[i], 1, xmax_used, outfp)) != xmax_used)
X		{
X			fprintf(stderr,"%s: premature EOF after %d bytes of %d, line %d of %d\n",
X				PGM,j,xmax_used,i,ymax_used);
X			return(ERROR);
X		}
X		(void)memset(block[i], '\0', xmax_used);
X	}
X	return(0);
X}
X
Xrd_hpfont(hp)
XFILE *hp;
X{
X	struct FNT_BITMAP *cf;
X	int cur_char, c, i, j, len, hite;
X	char nbuf[80];
X
X	i = 0;
X	while (isdigit(c = getc(hp)))
X		nbuf[i++] = c;
X	nbuf[i] = '\0';
X	i = atoi(nbuf);
X	if (c != 'W')
X	{
X		fprintf(stderr,"%s: font garbled (W) ?\n",PGM);
X		return(ERROR);
X	}
X	if (fread(&fdata, 26, 1, hp) != 1)
X	{
X		fprintf(stderr,"%s: font garbled (fread fdata) ?\n",PGM);
X		return(ERROR);
X	}
X
X	for (j=26; j<i; j++)
X		c = getc(hp);
X	spacelen = ((fdata.msb_pitch * 256) + fdata.pitch) / 4;
X
X/* loop through font until eof */
X
X	for (cur_char = 32; cur_char<256; )
X	{
X		if ((c = getc(hp)) != ESC)
X		{
X				/* some fonts have strange garbage at the beginning */
X				/* find a possible sync */
X			if (cur_char == ' ')
X			{
X				while ((c = getc(hp)) != EOF)
X					if (c == ESC)
X						break;
X				if (c == EOF)
X					break;
X				continue;
X			}
X			break;
X		}
X		if ((c = getc(hp)) != '*')
X		{
X			fprintf(stderr,"%s: no '*' at char %d\n",PGM,cur_char);
X			return(ERROR);
X		}
X		if ((c = getc(hp)) != 'c')
X		{
X			fprintf(stderr,"%s: no 'c' at char %d\n",PGM,cur_char);
X			return(ERROR);
X		}
X
X		i=0;
X		while (isdigit(c = getc(hp)))
X			nbuf[i++] = c;
X		nbuf[i] = '\0';
X		i = atoi(nbuf);
X		if (c != 'E' || i < cur_char)
X		{
X			fprintf(stderr,"%s: no E at char %d [%d]\n",PGM,cur_char,i);
X			return(ERROR);
X		}
X		cur_char = i;
X		cf = &font[cur_char];
X		if ((c = getc(hp)) != ESC)
X		{
X			fprintf(stderr,"%s: no ESC for char descr %d\n",PGM,cur_char);
X			return(ERROR);
X		}
X		if ((c = getc(hp)) != '(')
X		{
X			fprintf(stderr,"%s: no '(' at char %d\n",PGM,cur_char);
X			return(ERROR);
X		}
X		if ((c = getc(hp)) != 's')
X		{
X			fprintf(stderr,"%s: no 's' at char %d\n",PGM,cur_char);
X			return(ERROR);
X		}
X
X		i=0;
X		while (isdigit(c = getc(hp)))
X			nbuf[i++] = c;
X		nbuf[i] = '\0';
X		i = atoi(nbuf);
X		if (c != 'W')
X		{
X			fprintf(stderr,"%s: no W after char descr width at char %d\n",PGM,cur_char);
X			return(ERROR);
X		}
X		if (fread(&cdata, 16, 1, hp) != 1)
X		{
X			fprintf(stderr,"%s: font garbled (fread cdata) at char %d\n",PGM,cur_char);
X			return(ERROR);
X		}
X
X		len = (cdata.msb_width * 256) + cdata.width;
X		if (len%8)
X			len = len/8 + 1;
X		else len /= 8;
X		cf->len = len;
X
X		hite = (cdata.msb_hite * 256) + cdata.hite;
X		cf->hite = hite;
X		if (cf->hite > 128)
X		{
X			fprintf(stderr,"%s: wrong fonthite char %03d, hite %d\n",
X				PGM,cur_char,cf->hite);
X			return(ERROR);
X		}
X
X		cf->clen = 
X			((cdata.msb_delta * 256) + cdata.delta) / 4;
X
X		cf->toffs = 
X			(cdata.msb_t_offset * 256) + cdata.t_offset;
X
X		cf->loffs = 
X			(cdata.msb_l_offset * 256) + cdata.l_offset;
X
X		if ((cf->CH = (unsigned char **)malloc(hite * sizeof(unsigned char *))) == (unsigned char **)NULL)
X		{
X			fprintf(stderr,"%s: not enough memory for bitmap array char %d\n",
X				PGM,cur_char);
X			return(ERROR);
X		}
X
X		for (i=0; i<hite; i++)
X		{
X			if ((cf->CH[i] = (unsigned char *)malloc(len)) == NULL)
X			{
X				fprintf(stderr,"%s: not enough memory for bitmap at char %d\n",
X					PGM,cur_char);
X				return(ERROR);
X			}
X			if (fread(cf->CH[i], len, 1, hp) != 1)
X			{
X				fprintf(stderr,"%s: can't fread char bitmap at char %d, hite %d\n",
X					PGM,cur_char,i);
X				return(ERROR);
X			}
X		}
X	}
X	font_hite = fnthite();
X	tablen = 8*spacelen;
X	return(0);
X}
Xrd_bmfont(fp)
XFILE *fp;
X{
X	int i, lastc;
X	struct FNT_BITMAP *cf;
X	short cur_char;
X
X	for (cur_char=0;;)
X	{
X		lastc = cur_char;
X		if ((i = fread(&cur_char, sizeof(short), 1, fp)) != 1)
X		{
X			if (cur_char > 0x7e && (!i))
X				break;
X			fprintf(stderr,"%s: read error in font\n",PGM);
X			return(ERROR);
X		}
X		if (cur_char <= 0x20 || cur_char > 0xff)
X		{
X			fprintf(stderr,"%s: illegal curchar value %04x after char %3d\n",
X				PGM,cur_char,lastc);
X			return(ERROR);
X		}
X		cf = &font[cur_char];
X
X		if ((cf->SH = (short *)malloc(bm_len * sizeof(short))) == (short *)NULL)
X		{
X			fprintf(stderr,"%s: not enough memory for bitmap array char %d\n",
X				PGM,cur_char);
X			return(ERROR);
X		}
X
X		if (fread(cf->SH, sizeof(short), bm_len, fp) != bm_len)
X		{
X			fprintf(stderr,"%s: can't fread char bitmap at char %d\n",
X				PGM,cur_char);
X			return(ERROR);
X		}
X		cf->len = 16;
X		cf->hite = bm_len;
X	}
X	font_hite = bm_len;
X	spacelen = 16;
X	tablen = 96;
X	return(0);
X}
Xfnthite()
X{
X	int i;
X	struct FNT_BITMAP *cf;
X	int miny, maxy, cury;
X
X	miny = 30000;	/* let's be generous */
X	maxy = 0;
X
X	for (i=33; i<256; i++)
X	{
X		cf = &font[i];
X		if (cf->len)
X		{
X			cury = 1000 - cf->toffs;
X			if (cury < miny)
X				miny = cury;
X			if (cury+cf->hite > maxy)
X				maxy = cury+cf->hite;
X		}
X	}
X	return(maxy-miny);
X}
X
Xprintstr(s,y)
Xunsigned char *s;
Xint y;
X{
X	int done;
X
X	if (y >= lines)
X		return;
X
X	if (font_type == HP)
X		curX = 6*spacelen;
X	else curX = 120;
X
X	curY = y;
X
X	done = 0;
X	while (*s)
X	{
X		if (*s == '\n')
X			break;
X		else if (*s == ' ')
X		{
X			curX += spacelen;
X			++s;
X		}
X		else if (*s == '\t')
X		{
X			int i, tab;
X			tab = 8-(done%8);
X			for (i=0; i<tab; i++)
X				curX += spacelen;
X			++s;
X			done += tab-1;	/* that 1 is added below anyway */
X		}
X		else if ((*prt_func)(*s++))
X			break;
X
X		++done;
X	}
X	xmax_used = 216;	/* 1728/8 */
X}
X
Xprt_hpchr(c)
Xunsigned char c;
X{
X	struct FNT_BITMAP *cf;
X	int i, j, k, curx, cury, localy;
X
X/* 
X   now, we're thinking in terms of 300 dpi, but we're actually
X   drawing at the fax resolution [either 97.79 or 195.58 dots per vertical inch],
X   which makes real sense at 3.85 or 7.7 dots per vert. mm [if not to me,
X   to someone, I hope].
X   the horizontal resolution is 204.15 dots per inch, or 8.04 dots per mm
X
X*/
X	cf = &font[c];
X	if (!cf->len)
X		return(0);
X
X	if (curX + cf->clen + cf->loffs >= max_col)
X		return(ERROR);
X
X	cury = curY - cf->toffs;
X	if (cury < 0)
X		return(ERROR);
X
X	if ((cury+cf->hite) >= lines)
X		return(ERROR);
X
X	curX += cf->loffs;
X	for (i=0; i<cf->hite; i++)
X	{
X		curx = curX;
X		localy = yptr[cury+i];
X
X		for (j=0; j<cf->len; j++)
X			for (k=0; k<8; k++,curx++)
X				if (cf->CH[i][j] & bit[k])
X					setpix(localy, x204[curx]);
X	}
X	curX += cf->clen;
X	ymax_used = yptr[cury + cf->hite];
X	return(0);
X}
Xprt_bmchr(c)
Xunsigned char c;
X{
X	struct FNT_BITMAP *cf;
X	int i, cury;
X	short *s, *d;
X
X/*
X	since we're drawing on 16 bit boundaries [ever so coincidental]
X	we just mush two bytes of font data over into the bitmap
X	without even looking at the pixels
X*/
X	cf = &font[c];
X	if (!cf->len)
X		return(0);
X
X	if (curX + bm_len >= max_col)
X		return(ERROR);
X
X	if ((curY < 0) || ((curY+bm_len) >= lines))
X		return(ERROR);
X
X	s = cf->SH;
X	cury = curY;
X	for (i=0; i<bm_len; i++, cury++)
X	{
X		d = (short *)&block[cury][curX>>3];
X		*d = *s++;
X	}
X	curX += cf->len;
X	ymax_used = cury;
X	return(0);
X}
END_OF_FILE
  if test 11391 -ne `wc -c <'faxhost/fntwrite.c'`; then
    echo shar: \"'faxhost/fntwrite.c'\" unpacked with wrong size!
  fi
  # end of 'faxhost/fntwrite.c'
fi
if test -f 'faxhost/pbmtog3.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'faxhost/pbmtog3.c'\"
else
  echo shar: Extracting \"'faxhost/pbmtog3.c'\" \(4990 characters\)
  sed "s/^X//" >'faxhost/pbmtog3.c' <<'END_OF_FILE'
X/* pbmtog3.c - read a portable bitmap and produce a Group 3 FAX file
X**
X** Copyright (C) 1989 by Paul Haeberli <paul@manray.sgi.com>.
X**
X** Permission to use, copy, modify, and distribute this software and its
X** documentation for any purpose and without fee is hereby granted, provided
X** that the above copyright notice appear in all copies and that both that
X** copyright notice and this permission notice appear in supporting
X** documentation.  This software is provided "as is" without express or
X** implied warranty.
X**
X** Added kludges so that sierra type fax modems work w/o getting themselves
X** into a knot: eol must appear on a byte boundary, same goes for eop
X** [although sometimes faxes can be sent with non aligned eols/eops,
X** aligning them, however, makes that "sometimes" into an "always"].
X** Page width must be 1728 pels, no more, no less, with sierra.
X** Made these kludges optional "-sierra", because I don't see the point
X** of penalising software for smarter class two modems, where all the messing
X** is done in hardware.
X** I include a copy of this mutilated pbmtog3.c with faxpak's fst version.
X** 26. jan 91, klaus schallhorn.
X*/
X
X#include <stdio.h>
X#include "pbm.h"
X#include "g3.h"
X#ifdef SYSV
X#include <string.h>
X#else /*SYSV*/
X#include <strings.h>
X#endif /*SYSV*/
X
X#define max(a,b) ((a) > (b) ? (a) : (b))
X
Xint reversebits, sierra;
X
Xmain( argc, argv )
Xint argc;
Xchar *argv[];
X    {
X    FILE *ifd;
X    bit *bitrow;
X    int argn, rows, cols, format, row, col, Cols, i;
X    char *usage = " [-reversebits] [pbmfile]";
X
X    pm_progname = argv[0];
X
X    argn = 1;
X    reversebits = sierra = 0;
X
X    if ( argn < argc  && argv[argn][0] == '-' )
X	{
X	if ( strncmp(argv[argn],"-reversebits",max(strlen(argv[argn]),2)) == 0 )
X	    reversebits = 1;
X	else if ( strncmp(argv[argn],"-sierra",max(strlen(argv[argn]),2)) == 0 )
X	    sierra = TRUE;
X	else pm_usage( usage );
X	argn++;
X	}
X	
X    if ( argn == argc )
X	ifd = stdin;
X    else
X	{
X	ifd = pm_openr( argv[argn] );
X	argn++;
X	}
X    
X    if ( argn != argc )
X	pm_usage( usage );
X
X    pbm_readpbminit( ifd, &cols, &rows, &format );
X    if (sierra)
X	Cols = max(1728, cols); /* sierra insists on at least 1728 pels */
X    else Cols = cols;
X    bitrow = pbm_allocrow( Cols );
X
X    /* Write out four extra rows to get things stabilized. */
X    for ( col = 0; col < Cols; col++ )
X	bitrow[col] = PBM_WHITE;
X
X    tofax( bitrow, Cols );
X    tofax( bitrow, Cols );
X    tofax( bitrow, Cols );
X    tofax( bitrow, Cols );
X
X    /* Write out bitmap. */
X    putinit();
X    for ( row = 0; row < rows; row++ )
X	{
X	pbm_readpbmrow( ifd, bitrow, cols, format );
X	for ( i=cols; i<Cols; i++)
X	    bitrow[i] = PBM_WHITE;	/* pad bitmap if < 1728 */
X	tofax( bitrow, Cols );
X	}
X
X    /* And finish off. */
X    if (!sierra)
X    {
X	for( i = 0; i < 6; i++ )
X	    puteol( );
X        flushbits( );
X    }
X    else puteop();	/* the terrible hack to guarantee multipage faxes */
X
X    pm_close( ifd );
X
X    exit( 0 );
X    }
X
Xtofax(bitrow,n)
Xbit *bitrow;
Xint n;
X{
X    int c = 0;
X
X    while(n>0) { 
X	c = 0;
X	while(*bitrow == PBM_WHITE && n>0) {
X	    bitrow++;
X	    c++;
X	    n--;
X	}
X	putwhitespan(c);
X	c = 0;
X	if(n==0)
X	    break;
X	while(*bitrow == PBM_BLACK && n>0) {
X	    bitrow++;
X	    c++;
X	    n--;
X	}
X	putblackspan(c);
X    }
X    puteol();
X}
X
Xputwhitespan(c)
Xint c;
X{
X    int tpos;
X    tableentry *te;
X
X    if(c>=64) {
X	tpos = (c/64)-1;
X	te = mwtable+tpos;
X	c -= te->count;
X	putcode(te);
X    }
X    tpos = c;
X    te = twtable+tpos;
X    putcode(te);
X}
X
Xputblackspan(c)
Xint c;
X{
X    int tpos;
X    tableentry *te;
X
X    if(c>=64) {
X	tpos = (c/64)-1;
X	te = mbtable+tpos;
X	c -= te->count;
X	putcode(te);
X    }
X    tpos = c;
X    te = tbtable+tpos;
X    putcode(te);
X}
X
Xputcode(te)
Xtableentry *te;
X{
X    unsigned int mask;
X    int code;
X
X    mask = 1<<(te->length-1);
X    code = te->code;
X    while(mask) {
X 	if(code&mask)
X	    putbit(1);
X	else
X	    putbit(0);
X	mask >>= 1;
X    }
X
X}
X
Xputeol()
X{
X    int i;
X
X    if (sierra)		/* eol must be byte aligned ........ .......X */
X    {
X	flushbits();	/* fflush pels, then add 11 zeros + 1 on bit */
X	putchar(0);	/* make that at least 11 zero bits */
X	putchar(reversebits?0x80:0x01);
X    }
X    else
X    {
X	for(i=0; i<11; i++)
X	    putbit(0);
X	putbit(1);
X    }
X}
Xputeop()
X{
X    int i;
X
X    for (i=0; i<5; i++)	/* this is grossly overdoing the ccitt specs! */
X    {			/* but it makes sure multipage sierra faxes work */
X	putchar(0);
X	putchar(reversebits?0x08:0x10);
X	putchar(reversebits?0x80:0x01);
X    }
X    putchar(0);
X}
X
Xint shdata;
Xint shbit = 0x80;
X
Xputinit()
X{
X    shdata = 0;
X    shbit = reversebits ? 0x01 : 0x80;
X}
X
Xint putbit(d)
Xint d;
X{
X    if(d) 
X	shdata = shdata|shbit;
X    if ( reversebits )
X	shbit = shbit<<1;
X    else
X	shbit = shbit>>1;
X    if((shbit&0xff) == 0) {
X	putchar(shdata);
X	shdata = 0;
X	shbit = reversebits ? 0x01 : 0x80;
X    }
X}
X
Xflushbits( )
X{
X    if ( ( reversebits && shbit != 0x01 ) ||
X	 ( ! reversebits && shbit != 0x80 ) ) {
X	putchar(shdata);
X	shdata = 0;
X	shbit = reversebits ? 0x01 : 0x80;
X    }
X}
END_OF_FILE
  if test 4990 -ne `wc -c <'faxhost/pbmtog3.c'`; then
    echo shar: \"'faxhost/pbmtog3.c'\" unpacked with wrong size!
  fi
  # end of 'faxhost/pbmtog3.c'
fi
if test -f 'faxhost/sierracmd.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'faxhost/sierracmd.h'\"
else
  echo shar: Extracting \"'faxhost/sierracmd.h'\" \(4730 characters\)
  sed "s/^X//" >'faxhost/sierracmd.h' <<'END_OF_FILE'
X/*
X	sierracmd.h
X
X	additional mess for sierra type modem
X
X	Various tables for fast lookup.
X	first released version 0.99a [desperado version]
X	cleaned up Feb 21st '91.
X
X	Copyright (C) 1991, klaus schallhorn, klaus@cnix.uucp
X
X	Permission to use, copy, modify, and distribute this software 
X	and its documentation for any purpose and without fee is hereby 
X	granted, provided that the above copyright notice appear in 
X	all copies and that both that copyright notice and this permission 
X	notice appear in supporting documentation. 
X
X	This software is provided "as is" without express or implied warranty.
X*/
X
X
Xstatic	unsigned char eol_pat[] =	/* eop pattern, reversed */
X{
X	0x00,
X	0x10,
X	0x00,
X	0x01,
X	0x10,
X	0x00,
X	0x01,
X	0x10,
X	0x00,
X	0x01
X};
Xunsigned char faxbyte[]=	/* have to reverse every shitty byte */
X{
X	0x00,	0x80,	0x40,	0xc0,	0x20,	0xa0,	0x60,	0xe0,
X	0x10,	0x90,	0x50,	0xd0,	0x30,	0xb0,	0x70,	0xf0,
X	0x08,	0x88,	0x48,	0xc8,	0x28,	0xa8,	0x68,	0xe8,
X	0x18,	0x98,	0x58,	0xd8,	0x38,	0xb8,	0x78,	0xf8,
X	0x04,	0x84,	0x44,	0xc4,	0x24,	0xa4,	0x64,	0xe4,
X	0x14,	0x94,	0x54,	0xd4,	0x34,	0xb4,	0x74,	0xf4,
X	0x0c,	0x8c,	0x4c,	0xcc,	0x2c,	0xac,	0x6c,	0xec,
X	0x1c,	0x9c,	0x5c,	0xdc,	0x3c,	0xbc,	0x7c,	0xfc,
X	0x02,	0x82,	0x42,	0xc2,	0x22,	0xa2,	0x62,	0xe2,
X	0x12,	0x92,	0x52,	0xd2,	0x32,	0xb2,	0x72,	0xf2,
X	0x0a,	0x8a,	0x4a,	0xca,	0x2a,	0xaa,	0x6a,	0xea,
X	0x1a,	0x9a,	0x5a,	0xda,	0x3a,	0xba,	0x7a,	0xfa,
X	0x06,	0x86,	0x46,	0xc6,	0x26,	0xa6,	0x66,	0xe6,
X	0x16,	0x96,	0x56,	0xd6,	0x36,	0xb6,	0x76,	0xf6,
X	0x0e,	0x8e,	0x4e,	0xce,	0x2e,	0xae,	0x6e,	0xee,
X	0x1e,	0x9e,	0x5e,	0xde,	0x3e,	0xbe,	0x7e,	0xfe,
X	0x01,	0x81,	0x41,	0xc1,	0x21,	0xa1,	0x61,	0xe1,
X	0x11,	0x91,	0x51,	0xd1,	0x31,	0xb1,	0x71,	0xf1,
X	0x09,	0x89,	0x49,	0xc9,	0x29,	0xa9,	0x69,	0xe9,
X	0x19,	0x99,	0x59,	0xd9,	0x39,	0xb9,	0x79,	0xf9,
X	0x05,	0x85,	0x45,	0xc5,	0x25,	0xa5,	0x65,	0xe5,
X	0x15,	0x95,	0x55,	0xd5,	0x35,	0xb5,	0x75,	0xf5,
X	0x0d,	0x8d,	0x4d,	0xcd,	0x2d,	0xad,	0x6d,	0xed,
X	0x1d,	0x9d,	0x5d,	0xdd,	0x3d,	0xbd,	0x7d,	0xfd,
X	0x03,	0x83,	0x43,	0xc3,	0x23,	0xa3,	0x63,	0xe3,
X	0x13,	0x93,	0x53,	0xd3,	0x33,	0xb3,	0x73,	0xf3,
X	0x0b,	0x8b,	0x4b,	0xcb,	0x2b,	0xab,	0x6b,	0xeb,
X	0x1b,	0x9b,	0x5b,	0xdb,	0x3b,	0xbb,	0x7b,	0xfb,
X	0x07,	0x87,	0x47,	0xc7,	0x27,	0xa7,	0x67,	0xe7,
X	0x17,	0x97,	0x57,	0xd7,	0x37,	0xb7,	0x77,	0xf7,
X	0x0f,	0x8f,	0x4f,	0xcf,	0x2f,	0xaf,	0x6f,	0xef,
X	0x1f,	0x9f,	0x5f,	0xdf,	0x3f,	0xbf,	0x7f,	0xff
X};
X
X			/* faxes are compressed to reduce tx time */
X			/* then they're expanded, to increase tx time */
Xstatic	int not_so_fast[] =
X{
X	20, 40, 10, 10, 5, 40, 20, 0
X};			/* at least to allow for rx hardware catch up */
X			/* as in carriage return [think typewriter] */
X
X
X			/* possible answers from sierra type gizzmo */
Xstruct	SIERRA_CMDSET	/* not all of them are used */
X{
X	char	*txtstring,
X		retcode;
X} sierra_cmds[]=
X{
X/* 0*/	"OK",			'0',	/* sort of a wild card */
X/* 1*/	"ANSWER TONE",		'a',	/* Answer tone detected */
X/* 2*/	"CONFIRM TO RX",	'g',	/* confirmation to receive */
X/* 3*/	"CONNECT 2400",		'w',	/* connection established @ 2400 baud */
X/* 4*/	"CONNECT 4800",		'x',	/* @ 4800 */
X/* 5*/	"CONNECT 7200",		'y',	/* @ 7200 */
X/* 6*/	"CONNECT 9600",		'z',	/* @ 9600 */
X/* 7*/	"CRP",			'c',	/* come again? */
X/* 8*/	"REMOTE CAPABILITIES",	'b',	/* capabilities claimed */
X/* 9*/	"DCN",			'd',	/* hangup */
X/*10*/	"CAN'T TRAIN",		'f',	/* cant train this one to do what I want */
X/*11*/	"INVALID FRME",		'i',	/* invalid frame */
X/*12*/	"MSG CONFMD",		'm',	/* roger */
X/*13*/	"RETRAIN",		'h',	/* !roger */
X/*14*/	"RTRN OK",		'j',	/* seems to have sunk in now */
X/*15*/	"BUSY",			'7',	/* someone's sitting on the line */
X/*16*/	"NO CARRIER",		'3',	/* someone chopped the line */
X/*17*/	"CRC ERR IN FRAME",	'e',	/* no point in pursuing this */
X/*18*/	"*UNKNOWN*",		'\0'	/* god knows what happened */
X};
X
X#define	OK		0	/* index into the lot above */
X#define	ANSWER_TONE	1
X#define	CONFIRM_TO_RX	2
X#define	CONNECT24	3
X#define	CONNECT48	4
X#define	CONNECT72	5
X#define	CONNECT96	6
X#define	CRP		7
X#define	WHAT_I_CAN	8
X#define	DCN		9
X#define	CANNOT_TRAIN	10
X#define	INVALID_FRM	11
X#define	MSG_CONFMD	12
X#define	RETRAIN		13
X#define	RTRN_OK		14
X#define	BUSY		15
X#define	NO_CARRIER	16
X#define	CRC_IN_FRAME	17
X#define	UNKNOWN		18
X#define	LAST_SIERRA_ANS	18
X
X#define	CONNECT_MIN	3
X#define	CONNECT_24	(sierra_cmds[3].retcode)
X#define	CONNECT_48	(sierra_cmds[4].retcode)
X#define	CONNECT_72	(sierra_cmds[5].retcode)
X#define	CONNECT_96	(sierra_cmds[6].retcode)
X#define	CONNECT_MAX	7
X
X#ifdef	USE_IXON
X#define	FLOW_CTL	4
X#define	XON_CHAR	0x11
X#define	XOFF_CHAR	0x13
X#else
X#define	FLOW_CTL	3
X#endif
X
X#define	MARKER		0x7e
X
Xstatic	int line_minlen;
X
Xstatic	unsigned char zeros[256];
Xint	have_dis, have_cfr, have_connect;
Xstatic	unsigned char last1, cur;
Xstatic	int eols, eof;
END_OF_FILE
  if test 4730 -ne `wc -c <'faxhost/sierracmd.h'`; then
    echo shar: \"'faxhost/sierracmd.h'\" unpacked with wrong size!
  fi
  # end of 'faxhost/sierracmd.h'
fi
if test -f 'sample.fax.list' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sample.fax.list'\"
else
  echo shar: Extracting \"'sample.fax.list'\" \(275 characters\)
  sed "s/^X//" >'sample.fax.list' <<'END_OF_FILE'
X# sample fax mailing list
X# phone no   ftao, starts with a colon		opt. comment	
X#------------------------------------------------------------
X12345678   :for the attention of fred bloggs    # comment
X9274356						# no ftao
X87340875   :z. Hd. Herrn Meier			# needs it on time
END_OF_FILE
  if test 275 -ne `wc -c <'sample.fax.list'`; then
    echo shar: \"'sample.fax.list'\" unpacked with wrong size!
  fi
  # end of 'sample.fax.list'
fi
echo shar: End of archive 4 \(of 5\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
