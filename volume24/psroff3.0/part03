Subject:  v24i098:  psroff, Troff to PostScript filter, Part03/19
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: Chris Lewis <clewis@ferret.ocunix.on.ca>
Posting-number: Volume 24, Issue 98
Archive-name: psroff3.o/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  TROUBLE pk.c tests/ltest.m
# Wrapped by clewis@ecicrl on Fri Apr  5 20:55:58 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 3 (of 19)."'
if test -f 'TROUBLE' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'TROUBLE'\"
else
  echo shar: Extracting \"'TROUBLE'\" \(22353 characters\)
  sed "s/^X//" >'TROUBLE' <<'END_OF_FILE'
X		Psroff 3.0 Trouble Shooting.... 2.11 91/04/02
X
X(psroff 1.0 users can use this to a certain extent.  This is relatively
Xunchanged from Psroff 2.0 except for the ditroff input capability)
X
XThese are some pointers to possible solutions to problems with psroff.
XAfter correcting a problem, you usually need to do:
X
X	make all
X	su root
X	make install
X	make installwidths
X
XThis is assuming that you got clean compiles (you should be able
Xto fix your own compile problems).
X
XUnless specified, the remarks in this file pertain to CAT troff input,
Xnot ditroff input.
X
XIMPORTANT NOTE: MANY configuration difficulties can be detected
Xby "make check".  If you do encounter a problem, I suggest that
Xyou run "make check" first and correct any "ERROR"'s it reports
Xthat apply to the configuration (driver/printer) you wish to use.
XIf you encounter problems you cannot solve and wish to ask me for
Xhelp, I will want you to send me a copy of "make check"'s output....
X
XDefinitions:
X	- LIBDIR - default /usr/lib/troff2 (config option in Makefile)
X	  LJ drivers pick up font files from LIBDIR/lib/lj.
X	- FONTDIR - by default "/usr/lib/font" (config option in Makefile).
X	  Must be /usr/lib/font unless you have a '-F' troff, see
X	  "width option" below.
X	- "width tables".  psroff's install generates CAT compatible width
X	  tables and installs them into $FONTDIR/<widthname>/ft*, where
X	  "widthname" is a token denoting the "set" of widths.  Postscript
X	  printers (or ditroff driving postscript) use ps.  These are
X	  the only widths I distribute directly.  The Makefile will
X	  install widths into widthname "lj" if you have laserjet fonts
X	  installed in the right place.
X
X	  With ditroff input, these width tables are only useful for
X	  the optimizer.
X
X	- "width option", most troff's support a way of telling it where
X	  to look for the width tables.  Some support -T<widthname> (Xenix
X	  f'r instance).  Others (Sun, Ultrix, most BSD's) specifically,
X	  need "-F<directory>/<widthname>/ftXX".  Check your
X	  man pages for troff.  This is should be specified by "trofftype"
X	  in lib/psroff.lib.S.  If you have a "-T" version of troff,
X	  FONTDIR *must* be /usr/lib/font.  If your troff supports neither
X	  -T or -F (some real old versions of Xenix, V7 perchance), you
X	  will have to install the width tables in FONTDIR directly and
X	  specify trofftype as "".  Which will also mean that you can
X	  only support one set of width tables.  (Unless you make binary
X	  patches to your troff)
X
X	  In ditroff input, the trofftype is forced to be -T$width.
X
X	- "psroff debug" - rerun the psroff command, additionally specifying
X	  "-F" in the command line.  This permit's troff's stderr to be
X	  seen.  Correct any problems that it tells you about.  (eg:
X	  "width option").  If you see lines of the form:
X		M<string>
X	  These are back-end directives and they're supposed to be
X	  there during psroff debug - ignore them.
X	- HEADERSIZE: most troff's need an a.out.h header on the front
X	  of the width table files.  HEADERSIZE (defs.h) allows you to
X	  specify an arbitrary number of bytes on the front of the table
X	  in the width file.  Check /usr/lib/font/ftR (should be part
X	  of your original troff installation.  Is ftR 224 bytes long?
X	  If so, HEADERSIZE should be zero.  If not (eg: Ultrix,
X	  BSD's, some older Xenix, V7), you will have to specify
X	  HEADERSIZE.  SunOS, VAX/Ultrix wants 32.  (should be the size
X	  of an a.out header structure - od -c may give you some hints).
X	  Another way to tell is to run "file" on /usr/lib/font/ftR.
X	  Does it say "data"?  Then it probably needs HEADERSIZE 0.
X	  If it says "ascii" something, you're probably RISC/Ultrix, and you
X	  need ASCIIWIDTHS set.  If it says "executable" or "object" of some
X	  kind, you will have to set HEADERSIZE.
X
X	  RISC/Ultrix uses an ASCII format width table.  You can
X	  tell this if the following command:
X		echo ".fp 1 R" | troff -t > /dev/null
X	  says something about non-ascii /usr/lib/font/ftR.  If
X	  it does, define ASCIIWIDTHS.
X
X	  If you're still having problems, use the "dumpft" trick
X	  shown below for Apollos.
X
X	  HEADERSIZE can be left as 0 for use with ditroff input.
X	  (Eg: it only matters for CAT troff)
X
XNOTE for PSROFF 1.0 users:
X
X    psroff 1.0 does not have a psroff.lib file, so changes (eg:
X    width option specifications) have to be made directly to
X    the psroff.sh shell script.  Further, in the library, many of
X    the files names are reversed - eg: lj.lib in release 2.0 is lib.lj
X    in 1.0.
X
XMost initial problems are due to width table installation/specification -
Xthis varies from system to system and is *very* confusing.  I'm sorry about
Xthat, but there's no other way.  As a simple guide: if the /usr/lib/font/ftR
Xfile in your original troff installation is not 224 bytes long, you *will*
Xhave to set HEADERSIZE to something other than 0.
X
XAfter successful installation/testing, most problems are due to troff
Xerrors that you don't get to see.
X
XTwo notes on HEADERSIZE/ASCIIWID/etc.:
X    1) Some versions of troff will accept the -T option, but ignore
X       it.  Eg: Apollo and SunOS.  If the widths don't seem right, try the -F
X       option.  make check will usually tell you -F in this case.
X    2) If /usr/lib/font/ftR is substantially larger than 224 bytes,
X       ie, over 500 or 600, you probably have special headers.
X       Eg: Apollos.  What you should do is type the following:
X	    cd utils
X	    ./dumpft -gv < /usr/lib/font/ftR | grep Guess
X       Which will output a series of lines which contains both
X       a HEADERSIZE guess, plus an error count.  The errorcount
X       will have a minimum value, ideally zero.  Set
X       the HEADERSIZE to the guess with the minimum error
X       count and rebuild retry everything.  I won't attempt
X       to supply these numbers for each of these systems because
X       the number changes from release to release in some systems.
X
XBuild/Execute gross failures:
X
XShell scripts die horrible deaths:
X
X    Particularly with error messages from "test".  Does your "test"
X    support -x?  If not, make sure that you've got SHELL and STARTSHELL
X    set properly in the Makefile (The shell scripts assume V7 and/or USG
X    versions of the Bourne Shell.  Older BSD and some BSD derivitives
X    (aka Ultrix) need a USG compatible shell - look for "sh5" somewhere
X    on your system).  ksh, bash and ash *should* work (untested).
X    Theoretically, all of the shell scripts should work even without -x,
X    but I've not really been able to test everything.
X
XThe makefile doesn't work:
X
X    This *assumes* System V compatible MAKE.  If the makefile blows
X    (syntax errors in particular), search your system for a System V
X    compatible version of make.  Ultrix: /usr/bin/s5make.  Gnumake should
X    work fine.  Most Suns need a change here too.  You will probably
X    have to:
X	MAKE=<system 5 make> export MAKE
X	<system 5 make>
X    to build everything.
X
XPsroff seems to work, but nothing prints:
X
X    "Seems to work" meaning that the output file is > 15K or so
X    in Postscript, or >1K with HP Laserjets when printing the test
X    (make test).  A lot of these problems can be traced down to
X    print spooler definition problems.  Some things to examine in
X    your spooler filters (/etc/printcap in Suns, Ultrix, other BSD
X    derivitives, or the /usr/spool/lp/interface files in System V lp
X    spoolers):
X	- If running Laserjet, make sure that 8-bit is set (stty cs8
X	  in System V).  *Some* extremely old systems (some V7's,
X	  some very old BSD's) aren't capable of supporting serial 8-bit.
X	  You might want to consider asking on comp.unix.questions or
X	  comp.unix.wizards about how to turn this on on non-System V's
X	  if you continue to have problems.  (I believe Chris Torek has
X	  a workaround for setting 8 bit on old BSDs)
X	- If running laserjets, make sure that opost (SV) is off - you
X	  do *not* want the tty driver expanding tabs, cr's etc.
X	  Similar things apply with BSD derivitives.
X	- Make sure that echo is *off*.  If it's on, postscript
X	  printing will die and say something about <something> (often
X	  "user@site") is an undefined command if you're looking at the
X	  diagnostics coming back up the serial line from the printer.
X	  Make sure that there isn't an "echo" in the stty of lp
X	  filters, or /etc/printcap.  It's probably safer to make
X	  it explicit by adding "-echo" in the appropriate place.
X	  This, for example, is a fragment of an /etc/printcap:
X
X	    ps|HP LaserJet III with PostScript cartridge:\
X		lp=/dev/ttyb:br#9600:\
X		ms=clocal,-parity,cs8,-cstopb,-echo:\
X		sh:sf:sd=/usr/spool/ps:tr=\f:lf=/usr/adm/lpd-errs:
X
XOperational problems:
X
XNEW INSTALL: No output, or output truncated (possibly after some really
Xwild garble in the output):
X
X    Troff is probably exploding.  Run psroff debug - check in particular:
X    for troff error messages about bad -T or -F options ("trofftype" see
X    width tables and width option above) or not being able to find the
X    width tables (did they really install?).  If troff is core-dumping,
X    it's probably a HEADERSIZE (above) problem, but it's possibly a
X    problem with the width of a specific character (Xenix doesn't
X    like zero (or sometimes really narrow) characters - try
X    tests/dumpft < <width table file> > /tmp/FOO and look for errors
X    and really narrow (0 or 1 unit) characters.  Particularly \(ul/_/\(ru).
X
X    Other possibilities: bad output settings (ptr and lparg), bad
X    troff input.
X
XNEW INSTALL: make test generates several blank pages plus bits of
Xtext on Laserjets:
X
X    Chances are your HP Laserjet clone doesn't support incremental
X    downloading.  Try undefining INCR and rebuilding.
X
XNEW INSTALL: the "6" is missing in the test page on the "16 point italic"
Xand "16 point bold":
X
X    This is because you've not installed or properly configured more fonts
X    than came with psroff, and psroff can't find a font close enough
X    in size, and is letting the printer guess - and has selected a font
X    that it had previously incrementally downloaded.
X
X    Get more fonts and make sure that lj.fonts is up-to-date with
X    the font set you have.
X
XBoth NEW and OLD INSTALLS: truncated or possibly completely missing
X    printjobs in Postscript.  Probably the printer has seen a syntax
X    error or some such.  If you start up a "cat" from the device
X    the printer is connected to, you can see the printer's error
X    messages.
X
XWORKING INSTALL (eg: it's worked fine before): same symptoms as previous.
X
X    Troff is probably exploding, but probably not due to width tables.
X    Run psroff debug.  Check for and correct troff error messages (eg:
X    line too long) in your document.  This could even be troff not being
X    able to find a file you specified to psroff.
X
XCharacter widths wildly and inconsistently off:
X
X    Probably HEADERSIZE.
X
XCharacter widths annoyingly, inconsistently, but not wildly off:
X
X    Remotely HEADERSIZE, more probably -T/-F trofftype omitted/wrong,
X    or the width tables are simply wrong for the specific font or printer
X    (you may want to experiment with the "width" option in lib/psroff.lib.S).
X    Use "ps" for postscript printers and some others.
X
XCharacter widths uniformly off with ditroff:
X
X    - "-R" wrong or omitted in psroff.lib.S t2arg.  Check DESC file
X      for proper value (default 300) and that the gfnttab log doesn't
X      complain about a missing resolution during width table build.
X    - DESC file has wrong resolution (default is 300).  Try adjusting.
X      The ps widths use 720 (in DESC file)
X    - width option.
X
XCharacter widths uniformly off with non-ditroff:
X
X    - wrong width tables - try using the right ones: check width option.
X    - scaling bug in pk2ditwid/dit2catwid/gfnttab: contact me.
X
XA very few characters have bad widths:
X
X    - manually adjust the widths/width<widthname>/* files and
X      cd utils; make widths; su root; make installwidths.
X
Xoutput wacko during a table (output possibly truncated):
X
X    run psroff debug - probably line too long (table too wide).
X
Xoutput looks pretty good, but wierd things happen in spots:
X
X    are you using ditroff features that CAT troff doesn't support?
X    Eg: \S, \H, some "odd" permutations of \f, .ft, .fp?   Font
X    numbers > 4 (in CAT troff)?  CAT Troff (and hence psroff) doesn't
X    support them.  In ditroff-input mode, however, this can't happen.
X
XLooks good, but every second line has overstrikes at the end, the alternate
Xlines are indented:
X
X    ".po" + ".ll" setting too high (CAT troff imposes 7.54" limit on total).
X    Reduce ".po" and compensate with "-O" option to psroff.  I've had
X    some rumors of *some* kinds of Xenix troff having a shorter maximum
X    width.
X
XRight shifted when compared to ditroff/nroff/cat troff with packages
Xother than psroff:
X
X    See -O option and macro adapter description for psroff.
X
XUtter garbage output:
X
X    Are you specifying the right driver?
X
XMM ".MT" macro doesn't appear to work properly:
X
X    If you use a special directive (".sR" or ".fp" as modified by
X    the adapter macros) before ".MT", .MT will get buggered up.
X    Sorry, no workaround (though most requests other than ".fp"
X    can be issued by psroff -P options).  This isn't really a bug -
X    a limitation of CAT troff's ability to pass additional directives
X    to the backend without interfering with the typesetter state.
X    Maybe one of these days I'll get around to figuring out a better
X    mechanism.
X
XPage headers wrong or present on the first page when they shouldn't be:
X
X    See previous (replace ".MT" with page header macros in discussion).
X
Xline lengths a bit different from nroff/ditroff/other non-psroff CAT troff:
X
X    See macro adapter discussion in psroff/troff2ps man pages.
X
X".sR" doesn't appear to work at all:
X
X    Run psroff debug - do you see lines of the form "M<sR macro argument>"?
X    If not, you probably didn't get the macro adapters properly initialized.
X    psroff as distributed has adapters for MS, MM and MAN.  If you're
X    using different ones, or invoking the macros by /usr/lib/tmac paths,
X    or using no macros at all, the adapters and .sR definition won't be
X    picked up.  You will have to hand-craft your own macro adapter using
X    common.pre and common.post, using one of the example tmac's.
X    (all in adapters/* in distribution or LIBDIR/adapters after install)
X
X    The .sR kludge isn't necessary for ditroff.
X
X".sR" causes breaks/font loads don't happen at the right time:
X
X    It has to unfortunately.  If you want to load fonts (.fp) during a line,
X    *don't*.  Issue the ".fp"'s where it's safe to have a break.  Ditto
X    other ".sR" directives.  There's no restrictions on changing to
X    an *already loaded* font (eg: .ft directives).  The psroff -P option
X    may help (not .fp's, sorry...).  Applies only to CAT troff input.
X
XSome things appear really wierd (eg: strings of character repeats
Xin page number on MM headers):
X
X    Your CAT troff may not support \g (pure V7 troffs f'r instance).
X    Experiment.  You may have to bugger around with the macros to
X    remove dependence on \g.  (which is supposed to return a code
X    denoting the output format of a number register, and is usually
X    used to determine whether a number register has ever been set)
X
XME macros don't seem to work:
X
X    A friend noted:
X
X    In order to make them useable, I had to modify them somewhat.  The
X    problem was with the following syntax:
X
X	.if t \
X	\{
X	.	zz
X	.\}
X
X    Our (Xenix) troff required the following instead:
X
X	.if t \{\
X	.	zz
X	.\}
X
X    This was required for all occurances of "\{".  It seems "\{" MUST
X    terminate a line, and MUST be followed by a "\<NEWLINE>".  Even a ".\{"
X    didn't help any.
X
XEverything okay, but some characters missing (or wrong) on output:
X(ditroff drivers may complain about characters not found)
X
X    Chances are that your printer or set of fonts doesn't support
X    that character.  Postscript driving should be perfect.  Some
X    ditroff drivers don't have character sets that are a superset
X    of CAT troff.  There are a few minor problems with LJ character
X    sets.  psdit, xproof, xtroff are missing a few CAT characters.
X    You may be able to resolve these by adding translation overrides
X    to the appropriate *.fonts file (see jt.fonts for examples).
X    Some ditroff's have different meanings for the same character
X    spec.  ("@" in some ditroff drivers is a different character)
X
XMy ditroff driver dies with errors about lines starting with "#":
X
X    define NOCHATTER.
X
XMy postscript printer server gets upset:
X
X    define NOCHATTER
X
XI get postscript printer errors on last page, or last page missing:
X
X    Have you got a DEC LN03 or some other printer that doesn't
X    like trailing control-D's?  Define "NOCONTROLD" in defs.h
X
XDitroff driver doesn't work/gives errors:
X
X    check, recheck, and check again for ditroff backend config
X    (lparg/ptr in psroff.lib.S).  Try "psroff -t" and then
X    hand feeding the stdout to your backend manually.  Experiment
X    with "-d" setting in t2arg in psroff.lib.S.  If related
X    to specific characters, maybe adding translation overrides
X    in the appropriate *.fonts file will help
X
XDitroff input (-N) doesn't work/gives errors:
X
X    Particularly remarks about not knowing about specific characters.
X    That's because the psroff tables don't match ditroff's.
X    Make sure that the extension section of the appropriate
X    *.fonts file is in agreement with your ditroff width tables.
X    cd widths; make extensions to rebuild these tables to tack
X    onto the end of the appropriate *.fonts file.
X
XLaserjet printers get confused and loses settings (eg: copy count etc)
X
X    Be aware of the fact that lj.lib has a RESET command.  If you
X    have some sort of spooler that's emitting commands to the printer
X    outside of the control of psroff (eg: copy count set before
X    psroff output), you may have to change it.
X
XLaserjet: wrong font selection (particularly when the result is
X10 point Courier), troff2ps compaining that it can't find a font
Xfile:
X
X    - lj.fonts incorrect.
X    - Don't have any good font files - buy some good ROMAN8's for
X      Roman, Italic and Bold, or use TeX fonts and "make buildljfonts".
X
XLaserjet: sizes of characters are wrong, some characters missing, wrong
X    font selected.
X
X    - Get some decent fonts.  If you don't have the right size (within
X      a few points) or font available, psroff will get the printer
X      to select a font.  Which will usually look wrong.  Further, if
X      the printer selects a font that has been incrementally downloaded,
X      some characters may be missing on the output.  If you've not
X      gotten any additional fonts, "make test" will show an example
X      of this problem, in that the line supposedly 16 point will
X      be the wrong size and some characters will be missing (italic
X      and bold "6")
X
XLaserjet: lousey/wrong/missing characters (non-S font):
X
X    - You got crummy fonts.  Go buy or steal some good ROMAN8's in Roman,
X      Italic and Bold at CAT troff's supported point sizes.
X      TeX's PK fonts will work, but non-alphanumeric characters will
X      often be wrong (particularly box drawing and backslash).
X    - Get a HP or Adobe Postscript cartridge.  (The Pacific Page does work
X      fine, except for reports that at least some of them use slightly
X      different fonts, and the widths will be off).
X
XMy laserjet stalls, gives "too complex" messages, doesn't switch fonts
Xsometimes:
X
X    - Some HPLJ clones don't support incremental downloading.  undefine
X      INCR and try again.  Plain laserjets (the old ones) don't support
X      font downloading at all.  Sigh...
X    - Ran out of memory - (INCR on): simplify document to use less fonts
X      or reduce MDLF.
X    - Ran out of memory - (INCR and PARTIAL off): turn on PARTIAL
X    - Too many fonts previously loaded - adjust PRELOAD.
X    - double check MDLF.
X
XManual pages look great except the page footers are at the top of the
Xnext page.  MM and MS work fine.
X
X    - You're IBM AIX right?  Sigh....  The man macros in AIX explicitly
X      set page length to something other than 11 inches.  Supply
X      "-rM1" to psroff, and the macros will select 11 inches.  Or,
X      you could insert a ".nr M 1" the beginning of adapters/tmac.an.
X
XSQTroff ditroff backend sometimes barfs on psroff ditroff output:
X
X    It do do that don't it?  SQTroff ditroff format is apparently
X    slightly different.  Then again, if you got SQTroff, why you have
X    psroff?
X
Xxproof sometimes dies with "too many font" messages:
X
X    - AT&T's fault.  (Each symbol character is a separate font, xproof
X      is configured for a maximum of 50 or so fonts... duh...)
X
XThe Bell Symbol (\(bs) isn't:
X
X    It ain't supposed to be.
X
XPsroff is wonderful:
X
X    Of course.  Didn't I say it would be? ;-)
X
XTEST SHEET INTERPRETATION:
X
X    If you see problems after running the test sheet, here are a few
X    suggestions:
X
X	- Laserjet output: *badly* splattered, most characters unrecognizeable
X	  and probably more than one or two pages: If you're not using a Hewlett
X	  Packard Laserjet, try undefining INCR and rebuilding.  Some clones won't
X	  handle incremental downloading.  Other possibilities: if you are
X	  printing via serial line, make sure that the serial line is 8 bit raw
X	  (eg: cs8 and -opost on System V, or CBREAK mode in BSD)
X	  Check /etc/printcap or /usr/spool/lp/interface/*.
X	- Character spacing objectionably off in the text portions - some
X	  versions of troff, such as SunOS, do not support trofftype "-T$width",
X	  but they don't complain about it.  Try the -F variant.
X	  If you're manually invoking troff (ala "troff.... | troff2ps"),
X	  you probably aren't picking up the common.pre macro adapter that
X	  tells troff to reload its fonts from psroff's versions rather than
X	  their own built-ins.  Another symptom I've seen is floating point
X	  exceptions or the long horizontal lines in the table consisting
X	  of one _ character around the middle of the line.
X	- Postscript doesn't print - probably you have echo set on your
X	  serial line.  Turn it *off*.  Alternately, maybe your printer
X	  doesn't want to see control-D's - see the discussion in
X	  troff2ps(n)
X	- Laserjet: the "6" is missing in the test page on the "16 point italic"
X	  and "16 point bold".  You don't have enough fonts, or they're not
X	  configured properly.
END_OF_FILE
  if test 22353 -ne `wc -c <'TROUBLE'`; then
    echo shar: \"'TROUBLE'\" unpacked with wrong size!
  fi
  # end of 'TROUBLE'
fi
if test -f 'pk.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pk.c'\"
else
  echo shar: Extracting \"'pk.c'\" \(21627 characters\)
  sed "s/^X//" >'pk.c' <<'END_OF_FILE'
X/*
X	Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991 Chris Lewis
X		All Rights Reserved
X
X    See the LICENSE file for a full description of restrictions under which
X    this software is provided.
X
X    Function: PK and SFP font reading and emission functions
X */
X
X#include "defs.h"
X
X#ifdef	PK
X
X#ifndef lint
Xstatic char SCCSid[] = "@(#)pk.c 2.3 Copyright 91/02/20 09:02:17 Chris Lewis";
X#endif
X
X#define	DRAW
X#define	OUTRES	300
X
X#include "pk.h"
X
X#if	defined(PARTIAL)
X#include "pkc.h"
Xstruct needmaps *needmaps = (struct needmaps *) NULL;
X#endif
X
Xextern char *progname;
X
Xstatic FILE *fin;
Xstatic char *filename;	/* name of *current* font being read */
Xextern char *malloc();
X
Xstatic long flag_byte;
Xstatic repeatcount;
Xstatic dyn_f;
X
Xstatic readraster();
X
Xstatic long
Xget1int() { return(getc(fin)); }
X
Xstatic long
Xget2int() {
X    register long c;
X    c = get1int();
X    c = (c<<8) | (0xff & get1int());
X    return(c);
X}
X
Xstatic long
Xget4int() {
X    register long c;
X    c = get2int();
X    c = (c << 16) | (0xffff & get2int());
X    return(c);
X}
X
Xstatic long
Xget3int() {
X    register long c;
X    c = get2int();
X    c = (c << 8) | (0xff & get1int());
X    return(c);
X}
X
X#ifdef VFPRINTF
X#include <varargs.h>
X/* VARARGS */
Xpkmsg(va_alist)
Xva_dcl
X{
X	va_list args;
X	char *fmt;
X
X	va_start(args);
X	fmt = (char *) va_arg(args, char *);
X	VFPRINTF(stderr, fmt, args);
X	va_end(args);
X}
X#else
X/* VARARGS1 ARGSUSED */
Xpkmsg(fmt, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
Xchar	*fmt;
Xint	a1, a2, a3, a4, a5, a6, a7, a8, a9, a10; {
X	char buf[BUFSIZ];
X	sprintf(buf, fmt, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
X	fprintf(stderr, buf);
X}
X#endif
X
Xstatic
Xskipspecials() {
X    register int i,c;
X    do {
X	flag_byte = getc(fin);
X	if (flag_byte >= 240) {
X	    i = 0;
X	    switch(flag_byte) {
X		case PK_xxx4:
X		    i = (i << 8) + getc(fin);
X		case PK_xxx3:
X		    i = (i << 8) + getc(fin);
X		case PK_xxx2:
X		    i = (i << 8) + getc(fin);
X		case PK_xxx1:
X		    i = (i << 8) + getc(fin);
X		    DBP((D_PK, "PK_xxx%d: ", flag_byte - PK_xxx1 + 1));
X		    while(i--) {
X			c = getc(fin);
X			DBP((D_PK, "%c", c));
X		    }
X		    DBP((D_PK, "\n"));
X		    break;
X		case PK_yyy:
X		    i = get4int();
X		    DBP((D_PK, "Num special: %d\n", i));
X		    break;
X		case PK_post:
X		    DBP((D_PK, "Postamble\n"));
X		    break;
X		case PK_no_op:
X		    DBP((D_PK, "No-op\n"));
X		    break;
X		default:
X		    pkmsg("PK file %s: Unexpected %ld\n", filename,
X			flag_byte);
X		    exit(1);
X	    }
X	}
X    } while (flag_byte >= 240 && flag_byte != PK_post);
X}
X
Xstatic
Xreadschar(p)
Xstruct pkc *p; {
X    p->pkc_pl = get1int() + ((p->pkc_flag&0x3) << 8);
X    p->pkc_char = get1int();
X    p->pkc_tfm = get3int();
X    p->pkc_dx = get1int() * pow2(16);
X    p->pkc_dy = 0;
X    p->pkc_width = get1int();
X    p->pkc_height = get1int();
X    p->pkc_x_off = get1int();
X    p->pkc_y_off = get1int();
X    if (p->pkc_x_off > 127)
X	p->pkc_x_off -= 256;
X    if (p->pkc_y_off > 127)
X	p->pkc_y_off -= 256;
X    p->pkc_rlen = p->pkc_pl - 8;
X    readraster(p);
X}
X
Xstatic
Xreadeschar(p)
Xstruct pkc *p; {
X    p->pkc_pl = get2int() + ((p->pkc_flag&0x3) << 16);
X    p->pkc_char = get1int();
X    p->pkc_tfm = get3int();
X    p->pkc_dx = get2int() * pow2(16);
X    p->pkc_dy = 0;
X    p->pkc_width = get2int();
X    p->pkc_height = get2int();
X    p->pkc_x_off = get2int();
X    p->pkc_y_off = get2int();
X    if (p->pkc_x_off > 32767)
X	p->pkc_x_off -= 65536;
X    if (p->pkc_y_off > 32767)
X	p->pkc_y_off -= 65536;
X    p->pkc_rlen = p->pkc_pl - 13;
X    readraster(p);
X}
X
Xstatic
Xreadlchar(p)
Xstruct pkc *p; {
X    p->pkc_pl = get4int();
X    p->pkc_char = get4int();
X    p->pkc_tfm = get4int();
X    p->pkc_dx = get4int();
X    p->pkc_dy = get4int();
X    p->pkc_width = get4int();
X    p->pkc_height = get4int();
X    p->pkc_x_off = get4int();
X    p->pkc_y_off = get4int();
X    p->pkc_rlen = p->pkc_pl - 28;
X    readraster(p);
X}
X
Xstatic
Xreadraster(p)
Xstruct pkc *p; {
X    p->pkc_pkr = (int8 *) mustmalloc((int) p->pkc_rlen, filename);
X    fread((char *) p->pkc_pkr, 1, (int) p->pkc_rlen, fin);
X}
X
X/*	Read a character sequence from a PK file */
Xstatic struct pkc *
Xrpkc() {
X    register struct pkc *p = (struct pkc *) mustmalloc(sizeof(struct pkc),
X	filename);
X
X    p->pkc_pkr = NULL;
X    p->pkc_sfpr = NULL;
X    p->pkc_flag = flag_byte;
X    p->pkc_dyn_f = p->pkc_flag >> 4;
X    flag_byte &= 0x7;
X
X    if (flag_byte == 7)
X	readlchar(p);
X    else if (flag_byte > 3)
X	readeschar(p);
X    else
X	readschar(p);
X    return(p);
X}
X
X#ifdef	SFP
X/*	Read a character sequence from an SFP */
Xstatic struct pkc *
Xrsfpc() {
X    register struct pkc *p;
X    int len;
X
X    if ((len = getc(fin)) == EOF || len != '\033') {
X	/* HP fonts when loaded often have trailing nulls due to DOS
X	   file padding.  Screech on non-null */
X	if (len && len != EOF)
X	    fprintf(stderr,
X	    "%s: WARNING: trailing garbage in %s, offset %ld, char 0x%02x\n",
X		progname, filename, ftell(fin), len);
X	flag_byte = PK_post;
X	return((struct pkc *) NULL);
X    }
X
X    p = (struct pkc *) mustmalloc(sizeof(struct pkc), filename);
X    p->pkc_pkr = NULL;
X    p->pkc_sfpr = NULL;
X    p->pkc_flag = 0;
X    p->pkc_dyn_f = 0;
X
X    if (fscanf(fin, "*c%ldE", &(p->pkc_char)) != 1) {
X	pkmsg("SFP file: %s, bad/missing SET CHAR CODE, offset: %ld\n",
X	    filename, ftell(fin));
X	exit(1);
X    }
X
X    if (fscanf(fin, "\033(s%dW", &len) != 1 || len < 16) {
X	pkmsg("SFP file: %s, bad/missing/tooshort CHAR DOWNLOAD sequence\n",
X	    filename);
X	exit(1);
X    }
X
X    get4int();	/* skip some garbage */
X    get2int();	/* skip more garbage (actually, orientation & dummy */
X
X    p->pkc_x_off = get2int();
X    if (p->pkc_x_off > 32767)
X	p->pkc_x_off -= 65536;
X    p->pkc_x_off = -p->pkc_x_off;
X    p->pkc_y_off = get2int();
X    if (p->pkc_y_off > 32767)
X	p->pkc_y_off -= 65536;
X    p->pkc_width = get2int();
X    p->pkc_height = get2int();
X    p->pkc_dx = get2int() * pow2(16) / 4;
X
X    p->pkc_sfpr = (struct ras *) mustmalloc(sizeof(struct ras), filename);
X
X    p->pkc_sfpr->ras_height = p->pkc_height;
X    p->pkc_sfpr->ras_width = p->pkc_width;
X    p->pkc_sfpr->ras_bline = (p->pkc_width + 7) / 8;
X    p->pkc_sfpr->ras_bytes = p->pkc_sfpr->ras_height * p->pkc_sfpr->ras_bline;
X    if (p->pkc_sfpr->ras_bytes) {
X	p->pkc_sfpr->ras_raster = (int8 *) mustmalloc((int)
X	    p->pkc_sfpr->ras_bytes, filename);
X
X	fread((char *) p->pkc_sfpr->ras_raster, (int) p->pkc_sfpr->ras_bytes,
X	    1, fin);
X    } else {
X	free((char *) p->pkc_sfpr);
X	p->pkc_sfpr = NULL;
X    }
X
X    return(p);
X}
X#endif
X
Xstatic struct pkc *
Xreadchar(p)
Xstruct pkp *p; {
X    if (p->pkp_flags&PK_PK)
X	return(rpkc());
X#ifdef	SFP
X    else if (p->pkp_flags&PK_SFP)
X	return(rsfpc());
X#endif
X    else
X	return((struct pkc *) NULL);
X}
X
Xstatic int
Xpkccomp(a, b)
Xstruct pkc **a, **b; {
X    if ((*a)->pkc_char < (*b)->pkc_char)
X	return(-1);
X    else
X	return(1);
X    /* can't be equal! */
X}
X
Xstatic
Xrastbit(x,y,r)
Xregister int x, y;
Xregister struct ras *r; {
X    register int bi = y * r->ras_bline + (x >> 3);
X
X    /* You don't really want to uncomment this.... ;-) */
X    /*	printf("x,y,bi: %d,%d,%d\n", x, y, bi);*/
X    return(r->ras_raster[bi] & (0x80 >> (x&7)));
X}
X
Xstatic int8 *rptr;
Xstatic long bitweight;
X
Xgetnyb() {
X    register int8 b;
X    if (!bitweight) {
X	bitweight = 8;
X	rptr++;
X    }
X    b = *rptr;
X    bitweight -= 4;
X#ifdef	VDEBUG
X    DBP((D_PK, "getnyb byte: %x\n", b));
X    DBP((D_PK, "getnyb: %x\n", (b >> bitweight) & 0xf));
X#endif
X    return((b >> bitweight)&0xf);
X}
X
X#ifdef	NEVER
Xgetbit() {
X    register int8 b;
X    if (!bitweight) {
X	bitweight = 8;
X	rptr++;
X    }
X    b = *rptr;
X    bitweight--;
X    return((b>>bitweight)&1);
X}
X#endif
X
X/*	Dumps an ASCII version of the SFP raster r, to line n.
X	Normally only for debugging, but is also used from pktype
X */
X
Xdumpr(r, n)
Xstruct ras *r;
Xint n; {
X    int x, y;
X    if (!diagFile)
X	return;
X    fprintf(diagFile, "\n");
X    for (y = 0; y < n; y++) {
X	fprintf(diagFile, "%3d  ", y);
X	for (x = 0; x < r->ras_width; x++) {
X	    if (rastbit(x, y, r))
X		putc('*', diagFile);
X	    else
X		putc(' ', diagFile);
X	}
X	putc('\n', diagFile);
X    }
X}
X
Xstatic long
Xpkpack(pc,r)
Xregister struct pkc *pc;
Xregister struct ras *r; {
X    long i, j;
X    long pkpackret;
X    i = getnyb();
X    if (i == 0) {
X	do {
X	    j = getnyb();
X	    i++;
X	} while(!j);
X	while(i--)
X	    j = (j << 4) + getnyb();
X	pkpackret = (j - 15 + (13 - dyn_f) * 16 + dyn_f);
X    } else if (i <= dyn_f)
X	pkpackret = (i);
X    else if (i < 14)
X	pkpackret = ((i - dyn_f - 1)*16 + getnyb() + dyn_f + 1);
X    else {
X	if (repeatcount) {
X	    pkmsg("Second repeat count for this row!\n");
X	    exit(1);
X	}
X	if (i == 14)
X	    repeatcount = pkpack(pc,r);
X	else
X	    repeatcount = 1;
X	/*sendout(1, repeatcount, pc, r);*/
X	pkpackret = (pkpack(pc,r));
X    }
X    if (pkpackret < 1) {
X	pkmsg("pkpack returned < 1! (%s)", filename);
X	exit(1);
X    }
X    return(pkpackret);
X}
X
Xstatic
Xgetpbits(pc, r)
Xregister struct pkc *pc;
Xregister struct ras *r; {
X    register int h_bit		= pc->pkc_width,
X		 count,
X		 turnon;
X    turnon = pc->pkc_flag&0x8;
X    dyn_f = pc->pkc_dyn_f;
X    repeatcount = 0;
X    r->ras_xcur = r->ras_ycur = 0;
X    while(r->ras_ycur < pc->pkc_height) {
X	count = pkpack(pc,r);
X	while(count > 0) {
X	    if (count >= h_bit) {
X		count -= h_bit;
X		while(h_bit--) {
X		    if (turnon)
X			r->ras_raster[r->ras_ycur*r->ras_bline + (r->ras_xcur>>3)]
X			    |= (0x80 >> (r->ras_xcur&7));
X		    r->ras_xcur++;
X		}
X		r->ras_ycur++;
X		r->ras_xcur = 0;
X		while(repeatcount --) {
X#ifdef	VDEBUG
X		    DBP((D_PK, "Copy line %d to %d\n", r->ras_ycur,
X			r->ras_ycur-1));
X#endif
X		    memcpy((char*)&(r->ras_raster[r->ras_ycur * r->ras_bline]),
X			   (char*)&(r->ras_raster[(r->ras_ycur - 1) *
X			       r->ras_bline]),
X			   (int) r->ras_bline);
X		    r->ras_ycur++;
X		}
X		repeatcount = 0;
X		h_bit = pc->pkc_width;
X	    } else {
X		h_bit -= count;
X		while(count--) {
X		    if (turnon)
X			r->ras_raster[r->ras_ycur*r->ras_bline +
X			    (r->ras_xcur>>3)] |= (0x80 >> (r->ras_xcur&7));
X		    r->ras_xcur++;
X		}
X		count = 0;
X	    }
X	}
X	turnon = !turnon;
X    }
X    if (r->ras_ycur != pc->pkc_height ||
X	h_bit != pc->pkc_width)
X	pkmsg("Bad bit somehow (%s)\n", filename);
X}
X
Xstatic
Xgetrbits(pc, r)
Xregister struct pkc *pc;
Xregister struct ras *r; {
X    register int x, y;
X    register int bit = 0;
X    for (y = 0; y < pc->pkc_height; y++) {
X	for (x = 0; x < pc->pkc_width; x++) {
X	    if (pc->pkc_pkr[bit >> 3] & (0x80 >> (bit&7)))
X		r->ras_raster[y*r->ras_bline + (x>>3)] |= (0x80 >> (x&7));
X	    bit++;
X	}
X    }
X}
X
X/*	Convert a PK raster to an unpacked SFP version.
X	(If there's already an SFP version, it's returned instead)
X */
Xstruct ras *
Xpkrast(pc)
Xstruct pkc *pc; {
X    register struct ras *r;
X    if (pc->pkc_sfpr)
X	return(pc->pkc_sfpr);
X    if (!pc->pkc_rlen)
X	return(NULL);
X
X    pc->pkc_sfpr = r = (struct ras *) mustmalloc(sizeof(struct ras),
X	filename);
X
X    r->ras_height = pc->pkc_height;
X    r->ras_width = pc->pkc_width;
X    r->ras_bline = (pc->pkc_width + 7) / 8;
X    r->ras_bytes = r->ras_height * r->ras_bline;
X    r->ras_raster = (int8 *) mustmalloc((int) r->ras_bytes, filename);
X
X    /* initialize bit unpackers */
X    rptr = pc->pkc_pkr;
X    bitweight = 8;
X
X    /* calculate bits here...*/
X    if (pc->pkc_dyn_f == 14)
X	getrbits(pc, r);
X    else
X	getpbits(pc, r);
X    return(r);
X}
X
X/*	Read a PK font file header */
Xstatic struct pkp *
Xpk_rpk(p)
Xregister struct pkp *p; {
X    register int i,c;
X
X    if (getc(fin) != 89) {
X	pkmsg("PK file %s: Wrong version of packed file!\n", filename);
X	exit(1);
X    }
X    i = getc(fin);
X    if (i > 0) {
X	DBP((D_PK, "PKVersion: "));
X	while (i--) {
X	    c = getc(fin);
X	    DBP((D_PK, "%c", c));
X	}
X	DBP((D_PK, "\n"));
X    }
X    p->pkp_bmax = 0;
X    p->pkp_dmax = 0;
X    p->pkp_wmax = 0;
X    p->pkp_xomax = 0;
X    p->pkp_ds = get4int();
X    p->pkp_cs = get4int();
X    p->pkp_hppp = get4int();
X    p->pkp_vppp = get4int();
X
X    if (p->pkp_hppp != p->pkp_vppp)
X	pkmsg("PK file %s: Warning aspect ratio not 1:1\n", filename);
X    p->pkp_res = (double) p->pkp_hppp * POINT / pow2(16) + .5;
X    p->pkp_npts = ((double) p->pkp_ds / pow2(20)) *
X	((double) p->pkp_res / OUTRES) + .5;
X    p->pkp_chars = (struct pkc *) NULL;
X    p->pkp_last = (struct pkc *) NULL;
X    p->pkp_num = 0;
X    p->pkp_list = (struct pkc **) NULL;
X
X    /*	Try to guess symset, style, stroke weight and typeface
X	These aren't particularly important, but it assists the LJ
X	if it's trying to select one of these via characteristic.
X	This will only work if the file name reflects the Troff name,
X	according to the following conventions:
X
X	filename: {<path>/}troffname.pointsize.[pk|sfp]
X
X	All ROMAN8 encodings unless MATH8.
X	All 0 strokeweight, unless Bold.
X	All upright, unless Italic
X	All Roman typeface, unless otherwise specified
X
X		R	: Normal Roman
X		I	: Italic
X		B	: Bold
X		S	: MATH8 Symbol
X		X	: Bold italic
X		.X	: <typeface> Bold italic
X		.I	: <typeface> Italic
X		.B	: <typeface> Bold
X		.R	: <typeface> Normal
X		H or H.	: Helvetica typeface
X		C or C.	: Courier typeface
X			  typefaces should be extended.
X     */
X
X    {
X	register char *fp;
X	register int char1, char2, italic, bold, bolditalic, onechar;
X
X	fp = strrchr(filename, '/');
X	if (!fp)
X	    fp = filename;
X	else
X	    fp++;
X
X	/* Default settings */
X	p->pkp_symset = (8 << 5) - 64 + 'U';	/* ROMAN 8 */
X	p->pkp_style = 0;	/* upright */
X	p->pkp_sw = 0;		/* stroke 0 */
X	p->pkp_typeface = 5;	/* typeface Roman */
X
X	char1 = *fp++;
X	onechar = (*fp == '.');
X
X	if (char1 == 'S' && onechar)
X	    p->pkp_symset = (8 << 5) - 64 + 'M';	/* MATH 8 */
X	else {
X
X	    char2 = *fp;
X
X	    italic = ((onechar && char1 == 'I') || char2 == 'I');
X	    bold = ((onechar && char1 == 'B') || char2 == 'B');
X	    bolditalic = ((onechar && char1 == 'X') || char2 == 'X');
X
X	    if (bold || bolditalic)
X		p->pkp_sw = 3;
X
X	    if (italic || bolditalic)
X		p->pkp_style = 1;
X
X	    /* This should be extended, but I don't have a good feeling
X	       for troff typeface -> HPLJ nomenclature */
X	    switch(char1) {
X		case 'H':
X		    p->pkp_typeface = 4;	/* Helvetica */
X		    break;
X		case 'C':
X		    p->pkp_typeface = 3;	/* Courier */
X		    break;
X		/* more? */
X	    }
X	}
X    }
X
X    return(p);
X}
X
X#ifdef	SFP
X
X/*	Read an SFP header and convert it into the PK internal structure.
X */
Xstatic struct pkp *
Xpk_rsfp(p)
Xregister struct pkp *p; {
X    register int c;
X    int len;
X
X    if (fscanf(fin, ")s%dW", &len) != 1) {
X	pkmsg("SFP file %s: Bad CREATE FONT sequence\n", filename);
X	exit(1);
X    }
X
X    if (len < 26) {
X	pkmsg("SFP file %s: CREATE FONT sequence too short (%d)\n",
X	    filename, len);
X	exit(1);
X    }
X
X    get2int();	/* 26 */
X    get1int();	/* 0 */
X    get1int();	/* 0 or 1 - forced 1 anyways */
X    get2int();	/* dummy */
X
X    p->pkp_bmax = get2int();	/* baseline */
X    p->pkp_wmax = get2int();	/* cell width */
X    p->pkp_dmax = get2int() - p->pkp_bmax;	/* cell height */
X
X    get1int();	/* 0 port, 1 land - forced 0 */
X    get1int();	/* fixed/proportional - forced proportional */
X
X    p->pkp_symset = get2int();
X
X    get2int();		/* pitch - we calculate this from height */
X    c = get2int();	/* retrieved *height* */
X    p->pkp_npts = c * POINT / (OUTRES*4) + .5;
X
X    get2int();	/* dummy */
X    get1int();	/* dummy */
X
X    p->pkp_style = get1int();
X    p->pkp_sw = get1int();
X    p->pkp_typeface = get1int();
X
X    p->pkp_xomax = 0;
X
X    /* These are simulated so that the PK handlers can figure the font out */
X    p->pkp_ds = p->pkp_npts * pow2(20);
X    p->pkp_cs = 0;
X    p->pkp_hppp = OUTRES * pow2(16) / POINT;
X    p->pkp_vppp = OUTRES * pow2(16) / POINT;
X    p->pkp_res = (double) p->pkp_hppp * POINT / pow2(16) + .5;
X
X    p->pkp_chars = (struct pkc *) NULL;
X    p->pkp_last = (struct pkc *) NULL;
X    p->pkp_num = 0;
X    p->pkp_list = (struct pkc **) NULL;
X
X
X    len -= 26;
X    while(len--)
X	getc(fin);
X    return(p);
X}
X#endif
X
Xstatic struct pkp *
Xreadhead() {
X    register struct pkp *p = (struct pkp *) mustmalloc(sizeof(struct pkp),
X	filename);
X    switch(getc(fin)) {
X	case PK_pre:
X	    p->pkp_flags |= PK_PK;
X	    return(pk_rpk(p));
X#ifdef	SFP
X	case 0x1b:
X	    p->pkp_flags |= PK_SFP;
X	    flag_byte = 0;
X	    return(pk_rsfp(p));
X#endif
X	default:
X	    fprintf(stderr, "PK file: %s don't know what it is!\n",
X		filename);
X	    exit(1);
X    }
X    /*NOTREACHED*/
X}
X
Xpk_destroy(p)
Xregister struct pkp *p; {
X    register struct pkc *pc, *opc;
X    for (pc = p->pkp_chars; pc;) {
X	if (pc->pkc_pkr)
X	    free((char *) pc->pkc_pkr);
X
X	if (pc->pkc_sfpr) {
X	    free((char *) pc->pkc_sfpr->ras_raster);
X	    free((char *) pc->pkc_sfpr);
X	}
X
X	opc = pc;
X	pc = opc->pkc_next;
X	free((char *) opc);
X    }
X    if (p->pkp_list)
X	free((char *) p->pkp_list);
X    free((char *) p);
X}
X
Xstruct pkp *
Xpk_read(file, fontcode)
Xchar *file; int fontcode; {
X    register struct pkp *p;
X    extern FILE *popen();
X    register struct pkc *pc, **pcp;
X#ifdef	COMPRESS
X    int compressed = 0;
X#endif
X    fin = (FILE *) NULL;
X    if (access(filename = file, 4) == 0)
X	fin = fopen(filename, "r");
X#ifdef	COMPRESS
X    else {
X	char buf[1024];
X	strcpy(buf, file);
X	strcat(buf, ".Z");
X	if (access(buf, 4) == 0) {
X	    sprintf(buf, "%s %s.Z", COMPRESS, file);
X	    fin = popen(buf, "r");
X	    compressed = 1;
X	}
X    }
X#endif
X    if (!fin) {
X	pkmsg("Cannot open PK/SFP file %s\n", file);
X	exit(1);
X    }
X    p = readhead();
X    if (p->pkp_flags&PK_PK)
X	skipspecials();
X
X    while ((flag_byte != PK_post) && (pc = readchar(p))) {
X	DBP((D_VERB, "type: %s: %d\n", p->pkp_flags&PK_PK? "PK": "SFP",
X	    pc->pkc_char));
X#ifdef	PARTIAL
X	if (!needchar(fontcode, pc->pkc_char)) {
X	    DBP((D_FONT|D_PK, "Dropping char %02x from load\n", pc->pkc_char));
X
X	    if (pc->pkc_pkr) {
X		free((char *) pc->pkc_pkr);
X		pc->pkc_pkr = (int8 *) NULL;
X	    }
X
X	    if (pc->pkc_sfpr) {
X		free((char *) pc->pkc_sfpr->ras_raster);
X		free((char *) pc->pkc_sfpr);
X		pc->pkc_sfpr = (struct ras *) NULL;
X	    }
X
X	    free((char *) pc);
X	    if (p->pkp_flags&PK_PK)
X		skipspecials();
X	    continue;
X	}
X#endif
X	DBP((D_FONT|D_PK, "Loading char %02x\n", pc->pkc_char));
X	p->pkp_num++;
X	pc->pkc_next = (struct pkc *) NULL;
X	if (!p->pkp_chars)
X	    p->pkp_chars = pc;
X	if (p->pkp_last)
X	    p->pkp_last->pkc_next = pc;
X	p->pkp_last = pc;
X	if (p->pkp_flags&PK_PK) {
X	    p->pkp_bmax = max(p->pkp_bmax, pc->pkc_y_off);
X	    p->pkp_dmax = max(p->pkp_dmax, pc->pkc_height - pc->pkc_y_off);
X	    p->pkp_wmax = max(p->pkp_wmax, pc->pkc_width - pc->pkc_x_off);
X	}
X	p->pkp_xomax = min(p->pkp_xomax, pc->pkc_x_off);
X	if (pc->pkc_char == 'a') {
X	    p->pkp_kh = pc->pkc_y_off;
X	    p->pkp_kl = pc->pkc_y_off - pc->pkc_height;
X	}
X	if (p->pkp_flags&PK_PK)
X	    skipspecials();
X    }
X    DBP((D_FONT|D_PK, "End of font\n"));
X#ifdef	COMPRESS
X    if (compressed) {
X	if (pclose(fin)) {
X	    pkmsg("Decompression of %s failed\n", file);
X	    exit(1);
X	}
X    } else
X#endif
X	fclose(fin);
X    pcp = p->pkp_list = (struct pkc **)
X	mustmalloc((int) (p->pkp_num * sizeof(struct pkc *)), filename);
X    for (pc = p->pkp_chars; pc; pc = pc->pkc_next)
X	*pcp++ = pc;
X    qsort(p->pkp_list, (unsigned) p->pkp_num, sizeof(struct pkc *), pkccomp);
X    return(p);
X}
X
X/*	Emit routines */
X
X/*	Emit a font descriptor in SFP format */
Xepk_desc(p, sfp)
Xregister struct pkp *p;
XFILE *sfp; {
X
X    fprintf(sfp, "\033)s26W");
X    fputshort(26, sfp);
X    fputc(0, sfp);
X    fputc(1, sfp);	/* font type 1 (33-127 && 160-255 printable) */
X    fputshort(0, sfp);
X    fputshort(p->pkp_bmax, sfp);	/* baseline position */
X    fputshort(p->pkp_wmax, sfp);	/* cell width */
X    fputshort(p->pkp_bmax + p->pkp_dmax, sfp);	/* cell height */
X    fputc(0, sfp);	/* portrait */
X    fputc(1, sfp);	/* proportional */
X
X    fputshort((long) p->pkp_symset, sfp);
X
X    fputshort((long) (OUTRES * p->pkp_npts * 4) / 120, sfp);
X    fputshort((long) (p->pkp_npts * (OUTRES / POINT) * 4), sfp);
X    fputshort(0, sfp);
X    fputc(0, sfp);
X    fputc(p->pkp_style, sfp);
X    fputc(p->pkp_sw, sfp);
X    fputc(p->pkp_typeface, sfp);
X
X}
X
Xfputshort(val, f)
XFILE *f;
Xlong val; {
X    fputc(((int) val >> 8) & 0xff, f);
X    fputc((int) val & 0xff, f);
X}
X
X
X/*	Emit a character descriptor in SFP format.
X	Notes: if this is a PK font, the PK raster is converted
X	to SFP format and dumpped.  If the font was originally
X	SFP format, it's dumpped directly.  In either event, epkc_desc
X	deletes the SFP raster *and* the PK raster (if the character
X	has one), meaning that once this routine has emitted a character,
X	you can't emit it again!  Which is why pkc's pkflush completely
X	destroys the font.  Why?  Well, SFP's can get rather large, and
X	it seems reasonable to get rid of them as quickly as possible.
X
X	Returns number of bytes emitted.
X */
Xepkc_desc(pc, sfp)
Xregister struct pkc *pc;
Xregister FILE *sfp; {
X    register struct ras *r;
X
X    if (!pc->pkc_pkr && !pc->pkc_sfpr) {
X	fprintf(stderr, "%s: already downloaded %02x\n", pc->pkc_char);
X	return(0);
X    }
X
X    /* Emit SET CHARACTER sequence */
X    fprintf(sfp, "\033*c%dE", pc->pkc_char);
X
X    /* Emit DOWNLOAD CHARACTER sequence */
X    fprintf(sfp, "\033(s%dW", 16 + ((pc->pkc_width + 7) / 8) *
X    pc->pkc_height);
X    fputc(4, sfp);
X    fputc(0, sfp);
X    fputc(14, sfp);
X    fputc(1, sfp);
X    fputc(0, sfp);		/* portrait */
X    fputc(0, sfp);
X    fputshort(-pc->pkc_x_off, sfp);
X    fputshort(pc->pkc_y_off, sfp);
X    fputshort(pc->pkc_width, sfp);
X    fputshort(pc->pkc_height, sfp);
X    fputshort(pc->pkc_dx * 4 / pow2(16), sfp);
X    r = pkrast(pc);
X
X    if (pc->pkc_pkr)
X	free((char *) pc->pkc_pkr);
X    pc->pkc_pkr = (int8 *) NULL;
X
X    if (r) {
X#ifdef	VDEBUG
X	dumpr(r, r->ras_ycur);
X#endif
X	fwrite((char *) r->ras_raster, 1, (int) ((pc->pkc_width + 7) / 8) *
X	    (int) pc->pkc_height, sfp);
X	free((char *) r->ras_raster);
X	free((char *) r);
X    }
X    pc->pkc_sfpr = (struct ras *) NULL;
X    return(((pc->pkc_width + 7) / 8) * pc->pkc_height);
X}
X#endif
END_OF_FILE
  if test 21627 -ne `wc -c <'pk.c'`; then
    echo shar: \"'pk.c'\" unpacked with wrong size!
  fi
  # end of 'pk.c'
fi
if test -f 'tests/ltest.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tests/ltest.m'\"
else
  echo shar: Extracting \"'tests/ltest.m'\" \(8283 characters\)
  sed "s/^X//" >'tests/ltest.m' <<'END_OF_FILE'
X.\"Document revision 2.2 90/08/10
X.nr Ej 1
X.TL
Xtroff2ps testing script.
X.AU "Chris Lewis"
X.AS 1 10
XEver since the dawn of time, people have been dreaming of being
Xable to use "troff" on devices other than Wang Cat Phototypesetters.
XThis is a test document of one such thingie.
X.AE
X.MT 4 1
X.SP 2i
X.H 1 "Line Test"
X.P
XThis line should be exactly 5 inches long:
X.DS
X\l'5i\&\(ru'
X.DE
X.H 2 "Extended font test"
X.P
XExtended font test:
X.eX I
XThis is a standard display - this should be
XCourier, fixed width.
X.eE
X.H 2 "Simple paragraphs"
X.P
XThis is some more of the testing.  Can't you tell?
XTesting, testing, testing testing.
XThis book is a practical guide to the \fBUNIX\fP system and all users
Xfrom the novice to the expert should find it useful.
XMany examples are used throughout the text to illustrate techniques that make
Xthe system attractive to use.  By giving examples of the interactions
Xbetween commands, the user is able to take full advantage of the power of the
X\fBUNIX\fP system.
X.P
XThis is some more of the testing.  Can't you tell?
XTesting, testing, testing testing.
XThis book is a practical guide to the \fBUNIX\fP system and all users
Xfrom the novice to the expert should find it useful.
XMany examples are used throughout the text to illustrate techniques that make
Xthe system attractive to use.  By giving examples of the interactions
Xbetween commands, the user is able to take full advantage of the power of the
X\fBUNIX\fP system.
X.H 1 "Lists"
X.P
XBullet list:
X.BL
X.LI
X\(<- that was a bullet.
X.LI
XThis is 2
X.LI
XDashlist:
X.DL
X.LI
XDash
X.LI
XDasher
X.LE
X.LE
X.H 2 "Ligature test"
X.P
XLigature test: fido, flu, duffle, duffin
X.P
Xnroff doesn't like double quotes too much.
X"X" should look reasonable.
XMore 'test` `test'\*F
X.FS
XThis here's a footnote - slightly smaller pitch.
X.FE
XThis is more of the paragraph.
X.SK
X.H 1 "Different Fonts"
X.P
XThis is normal\f3Bold\fP\f2italic\fPnormal.
XThis is normal \f3Bold\fP \f2italic\fP normal.
X.S 36 38
X.P
X\(bs
X.S
X.S 14 26
X.P
Xthat was the logo at 36 point.  This sentence is 14 point.
X.S
X.P
XThe Logo will be printed whether or not you have raster fonts.
XThe original logo is a stylized "cX".
XIf you don't have the vfonts installed, the rest of the line will be
Xnormal characters with big spacing.
XIf the fonts are installed, you will see 75DPI big print.
X.P
XThis is some more of bigger stuff:
X.S 22
XTesting
X.I Testing
X.B Testing
X.S
X.SP
X.S 6
X6 Point
X.br
X.S 7
X7 Point
X.br
X.S 8
X8 Point
X.br
X.S 9
X9 Point
X.br
X.S 10
X10 Point
X.br
X.S 11
X11 Point
X.br
X.S 12
X12 Point
X.br
X.S 14
X14 Point
X.br
X.S 16
X16 Point
X.br
X.S 18
X18 Point
X.br
X.S 20
X20 Point
X.br
X.S 22
X22 Point
X.br
X.S 24
X24 Point
X.br
X.S 28
X28 Point
X.br
X.S 36
X36 Point
X.br
X.S 10
X.P
XNow, lets have some phun with phonts:
X.br
X.fp 1 H
X.fp 2 HO
X.fp 3 HB
X.ft 1
XThis should be Helvetica.
X\f2Helvetica Oblique\fP, \f3Helvetica Bold\fP.
X.br
X.fp 1 BR
X.fp 2 BO
X.fp 3 BB
X.ft 1
X.P
XThis should be Bookman.
X\f2Bookman Oblique\fP, \f3Bookman Bold\fP.
X.br
X.fp 1 R
X.fp 2 I
X.fp 3 B
X.H 3 "Testing 3"
Xhello 3
X.H 4 "Testing 4"
Xhello 4
X.H 5 "Testing 5"
Xhello 5
X.H 6 "Testing 6"
Xhello 6
X.H 7 "Testing 7"
Xhello 7
X.H 1 "Some Equations"
X.S 16
XEquations:
X.S
X.DS
X.EQ
Xleft [ x sup 2 + y sup 2 over alpha right ] ~=~ 1
X.EN
X.DE
X.br
X.DS
X.EQ
Xx dot = f(t) bar
X.EN
X.DE
X.DS
X.EQ
Xlim from {n -> inf} sum from 0 to n x sub i
X.EN
X.DE
X.DS
X.EQ
Xt ~=~ 2 pi int sub 0 sup 1
Xsin ( sqrt { x sup 2 + a sup 2 } ) dx
X.EN
X.DE
X.\".P
X.\"This is a test of piling (though, this isn't eqn):
X.\".DS I
X.\"\b'\(lt\(lk\(lb'\b'\(lc\(lf x \b'\(rc\(rf\b'\(rt\(rk\(rb'
X.\".DE
X.H 2 "More Equations"
X.DS
X.EQ
XG(z)~mark =~ e sup { ln ~ G(z) }
X~=~ exp left (
Xsum from k>=1 { S sub k z sup k } over k right )
X~=~ prod from k>=1 e sup { S sub k z sup k / k }
X.EN
X.DE
X.DS
X.EQ
Xlineup = left ( 1 + S sub 1 z +
X{ S sub 1 sup 2 z sup 2 } over 2! + ... right )
Xleft ( 1 + { S sub 2 z sup 2 } over 2
X+ { S sub 2 sup 2 z sup 4 } over { 2 sup 2 cdot 2! }
X+ ... right ) ...
X.EN
X.DE
X.DS
X.EQ
Xlineup = sum from m>=0 left (
Xsum from
Xpile { k sub 1 ,k sub 2 ,..., k sub m >= 0
Xabove
Xk sub 1 +2k sub 2 + ... + mk sub m = m }
X{ S sub 1 sup { k sub 1 } } over { 1 sup k sub 1 k sub 1 ! } ~
X{ S sub 2 sup { k sub 2 } } over { 2 sup k sub 2 k sub 2 ! } ~
X{ S sub m sup { k sub m } } over { m sup k sub m k sub m ! }
Xright ) z sup m
X.EN
X.DE
X.H 2 "Hanging Caps"
X.fp 1 PR
X.fp 3 PB
X.ta 1i
X.in +0.6i
X.ll -0.3i
X.ti -0.3i
X\v'1'\s36P\s0\v'-1'ater
X.de Xx
X'in -0.6i
X..
X.wh \n(nlu+1.5v Xx
Xnoster qui est
Xin caelis scanctificetur nomen tuum; adveniat regnum tuum;
Xfiat voluntus tua, sicut in caelo, et in terra ...
XAmen.
XToo bad I can't read Latin so I don't know what that line meant.
XBut it should be a good example of INITIAL hanging caps.
X(AND Palatino...)
X.fp 1 R
X.fp 3 B
X.H 1 "tbl output"
X.DS
X.TS
Xallbox doublebox;
Xc c c
Xl l l.
XCommand	Reference Section	Action
X
Xcc	CP	Compiles C programs
Xcp	C	Copies files
Xdisk cp	C	Copies archive media
Xlc	C	Lists files
Xlogin	M	Access to the system
Xtroff	CT	Typesets text
X.TE
X.DE
X.DS
X.TS
Xbox;
Xc s s
Xc | c | c
Xl | l | n.
XMajor New York Bridges
X=
XBridge	Designer	Length
X_
XBrooklyn	JA Roebling	1595
XManhattan	G Lindenthal	1470
XWilliamsburg	LL Buck	1600
X_
XQueensborough	Palmer &	1182
X	  Hornbostel
X_
X		1380
XTriborough	OH Ammann	_
X		383
X_
XBronx Whitestone	OH Ammann	2300
XThrogs Neck	OH Ammann	1800
X_
XGeorge Washington	OH Ammann	3500
X.TE
X.DE
X.DS
X.TS
Xbox;
XcfB s s s.
XComposition of Foods
X_
X.T&
Xc | c s s
Xc | c s s.
XFood	Percent by Weight
X\^	_
X\^	Protein	Fat	Carbo-
X\^	\^	\^	hydrate
X_
X.T&
Xl | n | n | n.
XApples	.4	.5	13.0
XHalibut	18.4	5.2	...
XLima beans	7.5	.8	22.o
XMilk	3.3	4.0	5.0
XMushrooms	3.5	.4	6.0
XRye bread	9.0	.6	52.7
X.TE
X.DE
X.H 1 "A Test of Two Column Output"
X.2C
X.P
XThe IBM salesman and the IBM system analyst went to spend
Xa weekend in the forest, hunting bear.
XThey hired a log cabin, and when they got there, took
Xtheir backpacks off and put them inside.
XAt which point the salesman said to the systems analyst:
X"You unpack while I go and find us a bear."
XThe analyst finished unpacking and then went and sat
Xoutside to await events. He did not have to wait too long.
XSoon he could hear noises in the forest. The noises got
Xnearer - and suddenly there was the salesman, running
Xacross the clearing toward the cabin, pursued by one of the
Xlargest and most ferocious Brown Bears the analyst had
Xever seen.
X"Open the door! shouted the salesman.
XThe analyst opened the door.
XThe salesman ran to the door, suddenly stopped, and
Xstepped aside.
XThe Bear carried by its momentum, continued though the
Xdoor and disappeared inside.
XThe salesman promptly shut the door on it, turned, looked
Xat the analyst, and said:
X"Ok, you skin that one while I go rustle us up another."
X.P
XThe IBM salesman and the IBM system analyst went to spend
Xa weekend in the forest, hunting bear.
XThey hired a log cabin, and when they got there, took
Xtheir backpacks off and put them inside.
XAt which point the salesman said to the systems analyst:
X"You unpack while I go and find us a bear."
XThe analyst finished unpacking and then went and sat
Xoutside to await events. He did not have to wait too long.
XSoon he could hear noises in the forest. The noises got
Xnearer - and suddenly there was the salesman, running
Xacross the clearing toward the cabin, pursued by one of the
Xlargest and most ferocious Brown Bears the analyst had
Xever seen.
X"Open the door! shouted the salesman.
XThe analyst opened the door.
XThe salesman ran to the door, suddenly stopped, and
Xstepped aside.
XThe Bear carried by its momentum, continued though the
Xdoor and disappeared inside.
XThe salesman promptly shut the door on it, turned, looked
Xat the analyst, and said:
X"Ok, you skin that one while I go rustle us up another."
X.P
XThe IBM salesman and the IBM system analyst went to spend
Xa weekend in the forest, hunting bear.
XThey hired a log cabin, and when they got there, took
Xtheir backpacks off and put them inside.
XAt which point the salesman said to the systems analyst:
X"You unpack while I go and find us a bear."
XThe analyst finished unpacking and then went and sat
Xoutside to await events. He did not have to wait too long.
XSoon he could hear noises in the forest. The noises got
Xnearer - and suddenly there was the salesman, running
Xacross the clearing toward the cabin, pursued by one of the
Xlargest and most ferocious Brown Bears the analyst had
Xever seen.
X"Open the door! shouted the salesman.
X.1C
X.CS
X.TC
END_OF_FILE
  if test 8283 -ne `wc -c <'tests/ltest.m'`; then
    echo shar: \"'tests/ltest.m'\" unpacked with wrong size!
  fi
  chmod +x 'tests/ltest.m'
  # end of 'tests/ltest.m'
fi
echo shar: End of archive 3 \(of 19\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 19 archives.
    echo "Read the README to get started with psroff installation"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
