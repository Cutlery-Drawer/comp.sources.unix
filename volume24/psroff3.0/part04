Subject:  v24i099:  psroff, Troff to PostScript filter, Part04/19
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: Chris Lewis <clewis@ferret.ocunix.on.ca>
Posting-number: Volume 24, Issue 99
Archive-name: psroff3.o/part04

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  dit.c ps.c utils/maps/cmtrf.ROMAN8 utils/psdtwd.S
# Wrapped by clewis@ecicrl on Fri Apr  5 20:55:58 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 4 (of 19)."'
if test -f 'dit.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dit.c'\"
else
  echo shar: Extracting \"'dit.c'\" \(11773 characters\)
  sed "s/^X//" >'dit.c' <<'END_OF_FILE'
X/*
X	Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991 Chris Lewis
X		All Rights Reserved
X
X    See the LICENSE file for a full description of restrictions under which
X    this software is provided.
X
X    Function:		ditroff frontend.
X */
X
X#include "defs.h"
X
X#ifndef	lint
Xstatic char SCCSid[] =
X    "@(#)dit.c: 91/03/26 Copyright 91/03/26 00:13:12 Chris Lewis";
X#endif
X
Xextern struct cattab tabN[], tabS[], *extidx;
Xextern struct troff2befont *extchar;
X
X/*	Translation of single character characters to cattab
X	entries and, hence, emittable strings via the backends.
X */
Xstruct cattab **dittab;
X
X/*	\(xx characters */
Xstruct cattab **spctab, **ts;
X
Xstruct cattab *ditsearch(str)
Xchar *str; {
X    /* should do binary search */
X    register int l, mid, h, k;
X    l = 0;
X    h = extcount - 1;
X#ifdef	NEVER
X    for (ts = spctab; *ts; ts++)
X	if (strcmp((*ts)->ch_name, str) == 0)
X	    return(*ts);
X#endif
X    while(l <= h) {
X	mid = (l + h) >> 1;
X	k = strcmp(str, spctab[mid]->ch_name);
X	if (k == 0)
X	    return(spctab[mid]);
X	else if (k < 0)
X	    h = mid - 1;
X	else
X	    l = mid + 1;
X    }
X    return((struct cattab *) NULL);
X}
X
Xcatcmp(a, b)
Xstruct cattab **a, **b; {
X    return(strcmp((*a)->ch_name, (*b)->ch_name));
X}
X
Xaddtab(table)
Xstruct cattab *table; {
X    register struct cattab *p;
X    extern char *realloc();
X
X    for (p = table; p->ch_name != NOC; p++) {
X	DBP((D_CAT, "Addtab: %s\n", p->ch_name));
X	if (p->ch_desc != NOC && p->ch_catidx != NTC)
X	    if (strlen(p->ch_name) == 1)
X		dittab[p->ch_name[0]] = p;
X	    else {
X		DBP((D_CAT, "AddtabS: %s %d\n", p->ch_name, extcount));
X		if (extcount > 0 && !(extcount%EXTCHUNK)) {
X		    spctab = (struct cattab **) realloc(spctab,
X			sizeof(struct cattab *) * (extcount + EXTCHUNK + 1));
X		    clrarray(&spctab[extcount], sizeof(struct cattab *) *
X			(EXTCHUNK+1));
X		}
X		spctab[extcount++] = p;
X	    }
X    }
X}
X
Xfixtab() {
X    register int i;
X    extern char *malloc();
X
X    dittab = (struct cattab **) mustmalloc(sizeof(struct cattab *) * 256,
X	"dittab");
X
X    spctab = (struct cattab **) mustmalloc(sizeof(struct cattab *) *
X	(EXTCHUNK+1), "spctab");
X
X    extcount = 0;
X
X    addtab(tabN);
X    addtab(tabS);
X    addtab(extidx);
X
X    /*	Magic */
X    dittab['-'] = &tabN[31];
X    dittab['_'] = &tabS[31];
X
X    DBP((D_CAT, "End addtab: %d characters\n", extcount));
X
X    spctab[extcount] = NULL;
X
X    DBP((D_CAT, "After NULL\n"));
X
X    if (debug&D_CAT) {
X
X	for (ts = spctab; *ts; ts++)
X	    DBP((D_CAT, "%s -> %08x (%d)\n", (*ts)->ch_name, *ts,
X		(*ts)->ch_catidx));
X
X    }
X
X    qsort(spctab, extcount, sizeof (struct cattab *), catcmp);
X
X    DBP((D_CAT, "After qsort\n"));
X
X#ifdef DEBUG
X    if (debug&D_CAT) {
X
X	for (ts = spctab; *ts; ts++)
X	    DBP((D_CAT, "%s -> %08x (%d)\n", (*ts)->ch_name, *ts,
X		(*ts)->ch_catidx));
X
X	for (i = 0; i < 256; i++)
X	    if (dittab[i])
X		DBP((D_CAT, "%d:%02x:%c: %d/%d\n", i, i, i, dittab[i]->ch_set,
X		dittab[i]->ch_catidx));
X    }
X#endif
X}
X
X#ifdef	DIT
Xint indtres;
X
Xint points, font, ch, i;
Xint xpos, ypos;
X
Xdit() {
X    register int cmd, nc, i, j;
X    register struct cattab *p;
X    register struct cattab *last = (struct cattab *) NULL;
X    char special[512];
X    fixtab();
X    DBP((D_CAT, "Finished fixtab\n"));
X    while(1) {
X	switch(cmd = skipwhite()) {
X	    case EOF:
X		goto finish;
X	    case 's':
X		points = getnum();
X		DBP((D_CAT, "Pointsize %d\n", points));
X		break;
X	    case 'f':
X		font = getnum();
X		if (font < 0 || font >= INTFONTS) {
X		    fprintf(stderr,
X			"%s: font number %d too high - make INTFONTS bigger\n",
X			progname, font);
X		    font = 1;
X		} else if (font == 0)
X		    /* font 0 stuff - because I map font n to n-1 internally */
X		    font = INTFONTS - 1;
X		else
X		    font--;
X		DBP((D_CAT, "Font %d\n", font));
X		break;
X	    case '0':
X	    case '1':
X	    case '2':
X	    case '3':
X	    case '4':
X	    case '5':
X	    case '6':
X	    case '7':
X	    case '8':
X	    case '9':
X		xpos += (cmd - '0') * 10 + (getchar() - '0');
X		/*fallthru*/
X	    case 'c':
X		p = dittab[ch = (getchar()&0xff)];
X		if (!p) {
X		    char seq[2];
X
X		    if (ch == ' ')
X			break;
X		    fprintf(stderr,
X			"%s: don't know this character: 0x%02x(%c)\n",
X			progname, ch, ch);
X		    seq[0] = ch;
X		    seq[1] = '\0';
X		    ditemit(xpos, ypos, font, points, 0, seq);
X		    break;
X		}
X		if (p->ch_wididx == NTC) /* extended character */
X		    ditemit(xpos, ypos,
X			p->ch_set == N ? -font-1: -symidx-1,
X			points, p->ch_catidx,
X			extchars[p->ch_catidx].t2b_charseq);
X		else
X		    ditemit(xpos, ypos,
X			p->ch_set == N ? font: symidx,
X			points, p->ch_catidx, (char *) NULL);
X		break;
X
X	    case 'u':		/* groff kern this sequence command */
X		j = getnum();
X		/* kern ignored for the moment - have to read the width
X		   table */
X		/* fallthru */
X	    case 't':		/* groff sequence */
X		{ char ubuf[100];
X		    /* should really read the width tables and
X		       do each character individually, but for the
X		       moment, this should work reasonably well */
X#ifdef	OPT
X		    canonflush();
X#endif
X		    while((ch = getchar()) != EOF && isspace(ch));
X		    if (ch == EOF)
X			break;
X		    ubuf[i++] = ch;
X		    while((ch = getchar()) != EOF && !isspace(ch))
X			ubuf[i++] = ch;
X		    p = dittab[ubuf[0]&0xff];
X		    if (!p)
X			ditemit(xpos, ypos, font, points, 0, ubuf);
X		    else if (p->ch_wididx == NTC)
X			ditemit(xpos, ypos,
X			    p->ch_set == N ? -font-1: -symidx-1,
X			    points, 0, ubuf);
X		    else
X			ditemit(xpos, ypos, p->ch_set == N ? font: symidx,
X			    points, 0, ubuf);
X		}
X	    case 'C':
X		i = 0;
X		while((ch = getchar()) != EOF && !isspace(ch))
X		    special[i++] = ch;
X		special[i] = '\0';
X		if (last && strcmp(last->ch_name, special) == 0)
X		    p = last;
X		else {
X		    p = ditsearch(special);
X		    last = p;
X		}
X		if (!p) {
X		    fprintf(stderr,
X			"%s: don't know this character: %s\n", progname,
X			special);
X		} else {
X		    if (p->ch_wididx == NTC) /* extended character */
X			ditemit(xpos, ypos,
X			    p->ch_set == N ? -font-1 : -symidx-1,
X			    points, p->ch_catidx,
X			    extchars[p->ch_catidx].t2b_charseq);
X		    else
X			ditemit(xpos, ypos,
X			    p->ch_set == N ? font : symidx,
X			    points, p->ch_catidx, (char *) NULL);
X		    DBP((D_CAT, "Special %s\n", special));
X		}
X		break;
X	    case 'x':
X		{
X		    char cmd[20], a1[20], a2[20], a3[20];
X		    int cnt;
X		    i = 0;
X#ifdef	OPT
X		    canonflush();
X#endif
X		    /* synchronize special X & Y to current position
X		       (ie: so psfig will work */
X		    specXPos = (int) ((long) xpos * TROFFRESOLUTION / indtres);
X		    specYPos = (int) ((long) ypos * TROFFRESOLUTION / indtres);
X
X		    while((ch = getchar()) != EOF && isspace(ch));
X		    special[i++] = ch;
X		    while((ch = getchar()) != EOF && ch != '\n')
X			special[i++] = ch;
X		    special[i] = '\0';
X		    DBP((D_CAT, "Command %s\n", special));
X		    i = sscanf(special, "%s %s %s %s", cmd, a1, a2, a3);
X		    if (i <= 0) {
X			fprintf(stderr, "%s: bad x command: %s\n",
X			    progname, special);
X			exit(1);
X		    }
X		    switch(cmd[0]) {
X			case 'p':
X			case 'H':
X			case 'S':
X			    break;
X			case 'f':	/* font load */
X			    if (i != 3) {
X				fprintf(stderr, "%s: bad font command: %s\n",
X				progname, special);
X				exit(1);
X			    }
X			    sprintf(special, "F%s%s", a1, a2);
X			    DBP((D_CAT, "FONT %s %s\n", a1, a2));
X			    dospecial(special);
X			    break;
X			case 'r':	/* specify resolution */
X			    if (i != 4) {
X				fprintf(stderr, "%s: bad res command: %s\n",
X				progname, special);
X				exit(1);
X			    }
X			    indtres = atoi(a1);
X			    if (indtres <= 0) {
X				if (i != 4) {
X				    fprintf(stderr,
X					"%s: ridiculous res value: %s\n",
X					progname, special);
X				    exit(1);
X				}
X			    }
X			    DBP((D_CAT, "RES %d\n", indtres));
X			    break;
X			case 'i':
X			    DBP((D_CAT, "INIT\n"));
X			    if (be->beprolog)
X				(*be->beprolog)();
X			    resetState();
X			    break;
X			case 't':
X			    DBP((D_CAT, "TRAILER\n"));
X			    break;
X			case 's':
X			    DBP((D_CAT, "STOP\n"));
X			    return;
X			case 'T':
X			    if (i != 2) {
X				fprintf(stderr, "%s: bad x T command: %s\n",
X				    progname, special);
X				exit(1);
X			    }
X			    device = mustmalloc(strlen(a1) + 1, "device");
X			    strcpy(device, a1);
X			    DBP((D_CAT, "TYPE %s\n", a1));
X			    break;
X			case 'X':
X			    switch(a1[0]) {
X				case 'f':
X				    a1[0] = 'I';
X				    break;
X				case 'p':
X				    a1[0] = 'P';
X				    break;
X			    }
X			    dospecial(a1);
X			    break;
X
X			default:
X			    fprintf(stderr, "%s: unknown special: %s\n",
X				progname, special);
X		    }
X		}
X		break;
X	    case 'H':
X		xpos = getnum();
X		DBP((D_CAT, "Hor: %d\n", xpos));
X		break;
X	    case 'h':
X		xpos += getnum();
X		DBP((D_CAT, "Hor (inc): %d\n", xpos));
X		break;
X	    case 'V':
X#ifdef	OPT
X		canonflush();
X#endif
X		ypos = getnum();
X		DBP((D_CAT, "Ver: %d\n", ypos));
X		break;
X	    case 'v':
X#ifdef	OPT
X		canonflush();
X#endif
X		ypos += getnum();
X		DBP((D_CAT, "Ver (inc): %d\n", ypos));
X		break;
X		break;
X	    case 'p':
X		ch = getnum();
X		DBP((D_CAT, "Page %d\n", ch));
X		if (be->bepage)
X		    (*be->bepage)();
X		break;
X	    case 'n':	/* end of line */
X		ch = getnum();
X		ch = skipwhite();
X		ungetc(ch, stdin);
X		ch = getnum();
X		break;
X	    case 'i':	/* stipple? BERK */
X		ch = getnum();
X		break;
X	    case 'P':	/* split end? BERK */
X		break;
X	    case 'w':
X#ifdef	OPT
X		canonflush();
X#endif
X		break;
X	    case '#':
X	    case 'D':
X	    case '!':
X#ifdef	OPT
X		canonflush();
X#endif
X		i = 1;
X		special[0] = cmd;
X		while((ch = getchar()) != EOF && isspace(ch));
X		special[i++] = ch;
X		while((ch = getchar()) != EOF && ch != '\n')
X		    special[i++] = ch;
X		special[i] = '\0';
X		DBP((D_CAT, "#/D/! %s\n", special));
X
X		switch(cmd) {
X		    case '#':
X			break;
X		    case '!':
X			special[0] = 'P';
X			dospecial(xpos * TROFFRESOLUTION / indtres,
X					 ypos * TROFFRESOLUTION / indtres,
X					 special);
X			break;
X		    case 'D': {
X			short values[100];
X			int opcode, ct, newx, newy;
X
X			if (!(opcode = drawparse(&ct, values, &special[1])))
X			    break;
X			if (!strchr("lcCeEa~tfpP", opcode)) {
X			    fprintf(stderr, "%s: unknown draw code %s\n",
X				progname, special);
X			    break;
X			}
X			newx = xpos;
X			newy = ypos;
X			if (opcode == 'e' || opcode == 'E')
X			    newx += values[0];
X			else if (opcode != 't' && opcode != 'f') {
X			    for (i = 0; i < ct/2; i++) {
X				newx += values[i*2];
X				newy += values[i*2+1];
X			    }
X			    if (i*2 < ct)
X				newx += values[i*2];
X			}
X			if (opcode != 't' && opcode != 'f')
X			    for (i = 0; i < ct; i++)
X				values[i] = values[i] * TROFFRESOLUTION /
X							indtres;
X
XDBP((D_CAT, "Draw: xpos,ypos,opcode,ct,special = %d,%d,%d,%d,%s\n",
X    xpos, ypos, opcode, ct, special));
X
X			if (be->bedraw)
X			    (be->bedraw)(xpos * TROFFRESOLUTION / indtres,
X					 ypos * TROFFRESOLUTION / indtres,
X					 opcode, ct, values, special);
X			xpos = newx;
X			ypos = newy;
X		    }
X		}
X		break;
X	}
X    }
X    finish: ;
X}
X
Xskipwhite() {
X    int c;
X    while((c = getchar()) != EOF && isspace(c));
X    return(c);
X}
X
Xgetnum() {
X    register int ret = 0;
X    int c;
X    while((c = getchar()) != EOF && isdigit(c))
X	ret = ret * 10 + (c - '0');
X    ungetc(c, stdin);
X    DBP((D_CAT, "Getnum: %d\n", ret));
X    return(ret);
X}
X
Xditemit(x, y, font, points, troffChar, sequence)
Xint x, y;
Xint font, points, troffChar;
Xregister char *sequence; {
X    DBP((D_CAT, "x,y: %d/%d -> ", x, y));
X    x = (int) ((long) x * TROFFRESOLUTION / indtres);
X    y = (int) ((long) y * TROFFRESOLUTION / indtres);
X    DBP((D_CAT, "%d/%d (font,points,ch = %d,%d,%d)\n", x, y, font, points,
X	troffChar));
X#ifdef OPT
X    if (sequence) {
X	canonflush();
X	if (be->beputchar)
X	    (*be->beputchar)(x, y, font, points, troffChar, sequence);
X    } else
X	canoninsert(x, y, font, points, troffChar);
X#else
X    if (be->beputchar)
X	(*be->beputchar)(x, y, font, points, troffChar, sequence);
X#endif
X}
X#endif
END_OF_FILE
  if test 11773 -ne `wc -c <'dit.c'`; then
    echo shar: \"'dit.c'\" unpacked with wrong size!
  fi
  # end of 'dit.c'
fi
if test -f 'ps.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ps.c'\"
else
  echo shar: Extracting \"'ps.c'\" \(19969 characters\)
  sed "s/^X//" >'ps.c' <<'END_OF_FILE'
X/*
X	Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991 Chris Lewis
X		All Rights Reserved
X
X    See the LICENSE file for a full description of restrictions under which
X    this software is provided.
X
X    Function:		PostScript driver
X */
X
X#include "defs.h"
X
X#ifdef	PS
X#include "ps.h"
X
X#ifndef	lint
Xstatic char SCCSid[] =
X    "@(#)ps.c: 2.12 Copyright 91/03/25 23:20:43 Chris Lewis";
X#endif
X
X/*	ps.c will generate some additional "print" commands to cause
X	the printer to "print" back who did the job, and how long it
X	took.  define NOCHATTER if you don't want this.
X */
Xstatic long charCount;
X
X#ifdef	FORM
Xstatic char Overlay[100] = {""};
X#endif
X
X#define	USED	01
X
Xstruct troff2befont psStdFont[108] = {
X
X/*	Note on X-shift, Y-shift and point scale factor:
X	The first two are shifts in the baseline position of the
X	character, and the third is a multiplier of the point size.
X	If they are zero, nothing happens.  If they are non-zero,
X	they are first multiplied by .01, then (in the case of the
X	shifts), multiplied by the current points to get a shift
X	value in TROFF2PS[XY] coordinates.  In the case of point scale
X	factor, it is multiplied by <currentpointsize> * .01 and becomes
X	the pointsize of the sequence to be emitted.
X */
X/*          +-------------------------------- Troff character number
X	    |
X            |    +--------------------------- N: standard fonts
X            |    |                            S: symbol font
X            |    |                            D: draw macro
X            |    |                            n: new font
X            |    |
X            |    |  +------------------------ X-shift
X            |    |  |                         Note: positive is right.
X            |    |  |
X            |    |  |  +--------------------- Y-shift
X            |    |  |  |                      Note: positive is up.
X            |    |  |  |
X            |    |  |  |  +------------------ Point scale factor
X            |    |  |  |  |
X            |    |  |  |  |   +-------------- Sequence
X            |    |  |  |  |   |
X            v    v  v  v  v   v */
X	/*  0*/	{N, 0, 0, 0, "h"},
X	/*  1*/	{N, 0, 0, 0, "t"},
X	/*  2*/	{N, 0, 0, 0, "n"},
X	/*  3*/	{N, 0, 0, 0, "m"},
X	/*  4*/	{N, 0, 0, 0, "l"},
X	/*  5*/	{N, 0, 0, 0, "i"},
X	/*  6*/	{N, 0, 0, 0, "z"},
X	/*  7*/	{N, 0, 0, 0, "s"},
X	/*  8*/	{N, 0, 0, 0, "d"},
X	/*  9*/	{N, 0, 0, 0, "b"},
X	/* 10*/	{N, 0, 0, 0, "x"},
X	/* 11*/	{N, 0, 0, 0, "f"},
X	/* 12*/	{N, 0, 0, 0, "j"},
X	/* 13*/	{N, 0, 0, 0, "u"},
X	/* 14*/	{N, 0, 0, 0, "k"},
X	/* 15*/	{N, 0, 0, 0, NOC},
X	/* 16*/	{N, 0, 0, 0, "p"},
X	/* 17*/	{D, 0, 0, 0, "do34em"},
X	/* 18*/	{N, 0, 0, 0, ";"},
X	/* 19*/	{N, 0, 0, 0, NOC},
X	/* 20*/	{N, 0, 0, 0, "a"},
X	/* 21*/	{N, 0, 0, 0, "_"},
X	/* 22*/	{N, 0, 0, 0, "c"},
X	/* 23*/	{N, 0, 0, 0, "`"},
X	/* 24*/	{N, 0, 0, 0, "e"},
X	/* 25*/	{N, 0, 0, 0, "'"},
X	/* 26*/	{N, 0, 0, 0, "o"},
X	/* 27*/	{D, 0, 0, 0, "do14"},
X	/* 28*/	{N, 0, 0, 0, "r"},
X	/* 29*/	{D, 0, 0, 0, "do12"},
X	/* 30*/	{N, 0, 0, 0, "v"},
X	/* 31*/	{N, 0, 0, 0, "-"},
X	/* 32*/	{N, 0, 0, 0, "w"},
X	/* 33*/	{N, 0, 0, 0, "q"},
X	/* 34*/	{N, 0, 0, 0, "/"},
X	/* 35*/	{N, 0, 0, 0, "."},
X	/* 36*/	{N, 0, 0, 0, "g"},
X	/* 37*/	{D, 0, 0, 0, "do34"},
X	/* 38*/	{N, 0, 0, 0, ","},
X	/* 39*/	{N, 0, 0, 0, "&"},
X	/* 40*/	{N, 0, 0, 0, "y"},
X	/* 41*/	{N, 0, 0, 0, NOC},
X	/* 42*/	{N, 0, 0, 0, "%"},
X	/* 43*/	{N, 0, 0, 0, NOC},
X	/* 44*/	{N, 0, 0, 0, "Q"},
X	/* 45*/	{N, 0, 0, 0, "T"},
X	/* 46*/	{N, 0, 0, 0, "O"},
X	/* 47*/	{N, 0, 0, 0, "H"},
X	/* 48*/	{N, 0, 0, 0, "N"},
X	/* 49*/	{N, 0, 0, 0, "M"},
X	/* 50*/	{N, 0, 0, 0, "L"},
X	/* 51*/	{N, 0, 0, 0, "R"},
X	/* 52*/	{N, 0, 0, 0, "G"},
X	/* 53*/	{N, 0, 0, 0, "I"},
X	/* 54*/	{N, 0, 0, 0, "P"},
X	/* 55*/	{N, 0, 0, 0, "C"},
X	/* 56*/	{N, 0, 0, 0, "V"},
X	/* 57*/	{N, 0, 0, 0, "E"},
X	/* 58*/	{N, 0, 0, 0, "Z"},
X	/* 59*/	{N, 0, 0, 0, "D"},
X	/* 60*/	{N, 0, 0, 0, "B"},
X	/* 61*/	{N, 0, 0, 0, "S"},
X	/* 62*/	{N, 0, 0, 0, "Y"},
X	/* 63*/	{N, 0, 0, 0, "F"},
X	/* 64*/	{N, 0, 0, 0, "X"},
X	/* 65*/	{N, 0, 0, 0, "A"},
X	/* 66*/	{N, 0, 0, 0, "W"},
X	/* 67*/	{N, 0, 0, 0, "J"},
X	/* 68*/	{N, 0, 0, 0, "U"},
X	/* 69*/	{N, 0, 0, 0, "K"},
X	/* 70*/	{N, 0, 0, 0, "0"},
X	/* 71*/	{N, 0, 0, 0, "1"},
X	/* 72*/	{N, 0, 0, 0, "2"},
X	/* 73*/	{N, 0, 0, 0, "3"},
X	/* 74*/	{N, 0, 0, 0, "4"},
X	/* 75*/	{N, 0, 0, 0, "5"},
X	/* 76*/	{N, 0, 0, 0, "6"},
X	/* 77*/	{N, 0, 0, 0, "7"},
X	/* 78*/	{N, 0, 0, 0, "8"},
X	/* 79*/	{N, 0, 0, 0, "9"},
X	/* 80*/	{N, 0, 0, 0, "*"},
X	/* 81*/	{N, 0, 0, 0, "\261"},
X	/* 82*/	{N, 0, 0, 0, "\256"},
X	/* 83*/	{N, 0, 0, 0, "\257"},
X	/* 84*/	{D, 0, 0, 0, "doff"},
X	/* 85*/	{N, 0, 0, 0, "\242"},
X	/* 86*/	{D, 0, 0, 0, "doFl"},
X	/* 87*/	{D, 0, 0, 0, "doFi"},
X	/* 88*/	{N, 0, 0, 0, "("},
X	/* 89*/	{N, 0, 0, 0, ")"},
X	/* 90*/	{N, 0, 0, 0, "["},
X	/* 91*/	{N, 0, 0, 0, "]"},
X	/* 92*/	{S, 0, 0, 0, "\260"},
X	/* 93*/	{N, 0, 0, 0, "\262"},
X	/* 94*/	{N, 0, 0, 0, "="},
X	/* 95*/	{S, 0, 0, 0, "\322"},
X	/* 96*/	{N, 0, 0, 0, ":"},
X	/* 97*/	{N, 0, 0, 0, "+"},
X	/* 98*/	{N, 0, 0, 0, NOC},
X	/* 99*/	{N, 0, 0, 0, "!"},
X	/*100*/	{N, 0, 0, 0, "\267"},
X	/*101*/	{N, 0, 0, 0, "?"},
X	/*102*/	{S, 0, 0, 0, "\242"},
X	/*103*/	{N, -60, 0, 0, "|"},
X	/*104*/	{N, 0, 0, 0, NOC},
X	/*105*/	{S, 0, 0, 0, "\323"},
X	/*106*/	{D, 0, 0, 0, "dosq"},
X	/*107*/	{N, 0, 0, 0, "$"},
X    };
X
Xstruct troff2befont psSymFont[] = {
X/*          +-------------------------------- Troff character number
X	    |
X            |    +--------------------------- N: standard fonts
X            |    |                            S: symbol font
X            |    |                            D: draw macro
X            |    |                            n: new font
X            |    |
X            |    |  +------------------------ X-shift (scaled by point)
X            |    |  |                         Note: positive is right.
X            |    |  |
X            |    |  |  +--------------------- Y-shift (scaled by point)
X            |    |  |  |                      Note: positive is up.
X            |    |  |  |
X            |    |  |  |  +------------------ Point scale factor
X            |    |  |  |  |
X            |    |  |  |  |   +-------------- Sequence
X            |    |  |  |  |   |
X            v    v  v  v  v   v */
X	/*  0*/	{S, 0, 0, 0, "\171"},
X	/*  1*/	{S, 0, 0, 0, "\161"},
X	/*  2*/	{S, 0, 0, 0, "\156"},
X	/*  3*/	{S, 0, 0, 0, "\155"},
X	/*  4*/	{S, 0, 0, 0, "\154"},
X	/*  5*/	{S, 0, 0, 0, "\151"},
X	/*  6*/	{S, 0, 0, 0, "\172"},
X	/*  7*/	{S, 0, 0, 0, "\163"},
X	/*  8*/	{S, 0, 0, 0, "\144"},
X	/*  9*/	{S, 0, 0, 0, "\142"},
X	/* 10*/	{S, 0, 0, 0, "\170"},
X	/* 11*/	{S, 0, 0, 0, "\150"},
X	/* 12*/	{S, 0, 0, 0, "\146"},
X	/* 13*/	{S, 0, 0, 0, "\165"},
X	/* 14*/	{S, 0, 0, 0, "\153"},
X	/* 15*/	{S, 0, 0, 0, NOC},
X	/* 16*/	{S, 0, 0, 0, "\160"},
X	/* 17*/	{N, 0, 0, 0, "@"},
X	/* 18*/	{S, 0, 0, 0, "\257"},
X	/* 19*/	{S, 0, 0, 0, NOC},
X	/* 20*/	{S, 0, 0, 0, "\141"},
X	/* 21*/	{S, 0, 0, 0, "\174"},
X	/* 22*/	{S, 0, 0, 0, "\143"},
X	/* 23*/	{N, 0, 0, 0, "\042"},
X	/* 24*/	{S, 0, 0, 0, "\145"},
X	/* 25*/	{S, 0, 0, 0, "\075"},
X	/* 26*/	{S, 0, 0, 0, "\157"},
X	/* 27*/	{S, 0, 0, 0, "\254"},
X	/* 28*/	{S, 0, 0, 0, "\162"},
X	/* 29*/	{S, 0, 0, 0, "\255"},
X	/* 30*/	{S, 0, 0, 0, "\164"},
X	/* 31*/	{4, 0, 0, 0, "O"},
X	/* 32*/	{N, 0, 0, 0, "\134"},
X	/* 33*/	{S, 0, 0, 0, "\131"},
X	/* 34*/	{D, 0, 0, 0, "BellSymbol"},
X	/* 35*/	{S, 0, 0, 0, "\245"},
X	/* 36*/	{S, 0, 0, 0, "\147"},
X	/* 37*/	{S, 0, 0, 0, "\312"},
X	/* 38*/	{S, 0, 0, 0, "\265"},
X	/* 39*/	{S, 0, 0, 0, "\336"},
X	/* 40*/	{S, 0, 0, 0, "\167"},
X	/* 41*/	{S, 0, 0, 0, NOC},
X	/* 42*/	{S, 0, 0, 0, "\321"},
X	/* 43*/	{S, 0, 0, 0, NOC},
X	/* 44*/	{S, 0, 0, 0, "\106"},
X	/* 45*/	{S, 0, 0, 0, "\121"},
X	/* 46*/	{S, 0, 0, 0, "\127"},
X	/* 47*/	{S, 0, 0, 0, "\310"},
X	/* 48*/	{4, 0, 0, 0, "M"},
X	/* 49*/	{S, 0, 0, 0, "\126"},
X	/* 50*/	{S, 0, 0, 0, "\114"},
X	/* 51*/	{S, 0, 0, 0, "\055"},
X	/* 52*/	{S, 0, 0, 0, "\107"},
X	/* 53*/	{S, 0, 0, 0, "\362"},
X	/* 54*/	{S, 0, 0, 0, "\120"},
X	/* 55*/	{S, 0, 0, 0, "\314"},
X	/* 56*/	{S, 0, 0, 0, "\311"},
X	/* 57*/	{N, 0, 0, 0, "\176"},
X	/* 58*/	{S, 0, 0, 0, "\266"},
X	/* 59*/	{S, 0, 0, 0, "\104"},
X	/* 60*/	{S, 0, 0, 0, "\326"},
X	/* 61*/	{S, 0, 0, 0, "\123"},
X	/* 62*/	{S, 0, 0, 0, "\273"},
X	/* 63*/	{S, 0, 0, 0, "\076"},
X	/* 64*/	{S, 0, 0, 0, "\130"},
X	/* 65*/	{S, 0, 0, 0, "\074"},
X	/* 66*/	{S, 0, 0, 0, "\244"},
X	/* 67*/	{S, 0, 0, 0, "\307"},
X	/* 68*/	{S, 0, 0, 0, "\125"},
X	/* 69*/	{S, 0, 0, 0, "\330"},
X	/* 70*/	{4, 0, 0, 0, "J"},
X	/* 71*/	{4, 0, 0, 0, "B"},
X	/* 72*/	{4, 0, 0, 0, "A"},
X	/* 73*/	{4, 0, 0, 0, "C"},
X	/* 74*/	{4, 0, 0, 0, "D"},
X	/* 75*/	{4, 0, 0, 0, "E"},
X	/* 76*/	{4, 0, 0, 0, "F"},
X	/* 77*/	{4, 0, 0, 0, "G"},
X	/* 78*/	{4, 0, 0, 0, "K"},
X	/* 79*/	{4, 0, 0, 0, "I"},
X	/* 80*/	{4, 0, 0, 0, "H"},
X	/* 81*/	{S, 0, 0, 0, "\264"},
X	/* 82*/	{S, 0, 0, 0, "\270"},
X	/* 83*/	{S, 0, 0, 0, "\261"},
X	/* 84*/	{S, 0, 0, 0, "\243"},
X	/* 85*/	{S, 0, 0, 0, "\263"},
X	/* 86*/	{S, 0, 0, 0, "\272"},
X	/* 87*/	{S, 0, 0, 0, "\271"},
X	/* 88*/	{S, 0, 0, 0, "\173"},
X	/* 89*/	{S, 0, 0, 0, "\175"},
X	/* 90*/	{N, 0, 0, 0, "\302"},
X	/* 91*/	{N, 0, 0, 0, "\301"},
X	/* 92*/	{N, 0, 0, 0, "\303"},
X	/* 93*/	{N, 0, 0, 0, "\043"},
X	/* 94*/	{S, 0, 0, 0, "\334"},
X	/* 95*/	{S, 0, 0, 0, "\316"},
X	/* 96*/	{N, 0, 0, 0, "\304"},
X	/* 97*/	{S, 0, 0, 0, "\306"},
X	/* 98*/	{S, 0, 0, 0, NOC},
X	/* 99*/	{N, 0, 0, 0, "\263"},
X	/*100*/	{4, 0, 0, 0, "L"},
X	/*101*/	{S, 0, 0, 0, "\052"},
X	/*102*/	{S, 0, 0, 0, "\315"},
X	/*103*/	{4, 0, 0, 0, "N"},
X	/*104*/	{S, 0, 0, 0, NOC},
X	/*105*/	{S, 0, 0, 0, "\053"},
X	/*106*/	{S, 0, 0, 0, "\256"},
X	/*107*/	{N, 0, 0, 0, "\247"},
X};
X
XpsPage() {
X    if (!currentPage)
X	return;
X    printf("hits misses\n");
X    printf("PageSave restore\n");
X    printf("/misses exch def /hits exch def\n");
X    printf("ShowPage\n");
X    pagePending = 1;
X}
X
Xstatic
XdoPageStart() {
X    currentPage++;
X    printf("%%%%Page: ? %d\n", currentPage);
X#ifdef	FORM
X    printf("/Form { %s } def\n",
X	Overlay[0] == '+' ? (Overlay[0] = '\0', Overlay+1) : Overlay);
X#endif
X    printf("/PageSave save def\n");
X    pagePending = 0;
X    printf("StartPage\n");
X}
X
XpsSetFont(font, points)
Xint font, points; {
X    if (lastPoints != points || font != lastFont) {
X	struct fonttable *fp = &fonttable[font];
X	if (fp->fontSeq && *fp->fontSeq && !(fp->flags&USED)) {
X	    char buffer[512];
X	    int n;
X	    FILE *f = fopen(fp->fontSeq, "r");
X	    if (!f) {
X		fprintf(stderr, "%s: cannot open fontfile %s\n",
X		    progname, fp->fontSeq);
X	    } else {
X		DBP((D_BEND,"Downloading %s\n", fp->fontSeq));
X		while((n = fread(buffer, 1, sizeof(buffer), f)) > 0) {
X		    fwrite(buffer, 1, n, stdout);
X		}
X		fclose(f);
X	    }
X	}
X
X	fp->flags |= USED;
X#ifdef	FONTMACRO
X	printf("/%s %d SetFont\n", fp->fontName, points);
X#else
X	printf("/%s dup /curFont exch def findfont\n",
X	    fp->fontName);
X	printf("%d dup /curPoints exch def scalefont setfont\n", points);
X#endif
X	lastPoints = points;
X	lastFont = font;
X    }
X}
X
XpsChar(x, y, font, points, troffChar, sequence)
Xint x, y;
Xint font, points, troffChar;
Xregister char *sequence; {
X    register int nx = TROFF2PSX(x), ny = TROFF2PSY(y);
X    register struct troff2befont *rp;
X
X    if (pagePending) {
X	resetState();
X	doPageStart();
X    }
X
X    charCount++;
X
X    DBP((D_BEND,"BEFORE (troffChar,x,y,font,points) = (%d,%d,%d,%d,%d)\n",
X	troffChar, x, y, font, points));
X    if (font < 0) {
X	font = -font-1;
X	rp = &extchars[troffChar];
X    } else if (font == symidx)
X	rp = &be->besymfont[troffChar];
X    else
X	rp = &be->bestdfont[troffChar];
X
X    switch(rp->t2b_font) {
X	/* Only fonts with "N" are subject to font translation */
X	case N:
X	    if (font == symidx)
X		font = 0;	/* Special chars are Courier */
X	    else {
X		DBP((D_BEND,"psSetChar %d->%s (%s)\n", font,
X		    xlatetable[font]->troffName,
X		    xlatetable[font]->fontName));
X		font = xlatetable[font] - fonttable;
X	    }
X	    break;
X	case S:
X	    font = 3;
X	    break;
X	case D:
X	    break;
X	default:
X	    /* Typically used when the R and S fonts don't have the
X	       character desired, so select the font via the index
X	       in the fonts.?? file */
X	    font = rp->t2b_font;
X	    break;
X    }
X
X    skipfontset:
X
X    if (!sequence)
X	sequence = rp->t2b_charseq;
X
X    if (!sequence) {
X	fprintf(stderr, "No coding for %d\n", troffChar);
X	return;
X    }
X
X    /*	We're committed now - the "if" statements avoid floating
X	arithmetic on slow machines */
X
X    if (rp->t2b_scale) points *= (.01 * rp->t2b_scale);
X    if (rp->t2b_xc) nx += points * (.01 * rp->t2b_xc);
X    if (rp->t2b_yc) ny += points * (.01 * rp->t2b_yc);
X
X    psSetFont(font, points);
X
X    DBP((D_BEND,"AFTER (sequence,x,y,font,points) = (%s,%d,%d,%d,%d)\n",
X	sequence, nx, ny, font, points));
X
X    if (rp->t2b_font == D) {
X	emitnums(nx);
X	emitnums(ny);
X	putnl(sequence);
X    } else {
X	emitnum(nx);
X	if (lastYPos != ny) {
X	    putchar(' ');
X	    emitnum(ny);
X	}
X	putchar('(');
X	while(*sequence) {
X	    if ((*sequence)&0x80)
X		printf("\\%03o", (*sequence++)&0xff);
X	    else if (*sequence == '(' || *sequence == ')' ||
X		*sequence == '\\')
X		printf("\\%c", *sequence++);
X	    else
X		putchar(*sequence++);
X	}
X	putchar(')');
X	if (lastYPos != ny) {
X	    lastYPos = ny;
X	    putchar('Y');
X	} else
X	    putchar('X');
X	putchar('\n');
X    }
X}
X
X/*	Specialized emit routine:
X	outputs number divided by PSSCALEFACTOR, rounded to the first
X	decimal place without using floats/double
X */
Xemitnums(val)
Xregister int val; {
X    emitnum(val);
X    putchar(' ');
X}
Xemitnum(val)
Xregister int val; {
X    register int neg;
X    if (val < 0) {
X	neg = 1;
X	val = -val;
X    } else {
X	neg = 0;
X    }
X    if (neg)
X	putchar('-');
X    printf("%d", val / PSSCALEFACTOR);
X    val = ((val % PSSCALEFACTOR) * 10 /*+ (PSSCALEFACTOR / 2)*/) /
X	PSSCALEFACTOR;
X    if (val)
X	printf(".%d", val);
X}
Xputnl(s)
Xchar *s; {
X    fputs(s, stdout);
X    putchar('\n');
X}
X
Xextern char nodename[];
X
XpsProlog() {
X    extern char *ctime();
X    extern char *strchr();
X#ifdef	DIT
X    extern int indtres;
X#endif
X    char buffer[30];
X    FILE *library;
X    long curtime;
X
X    currentPage = 0;
X    pagePending = 1;
X
X    library = libopen(printer, "lib");
X
X    time(&curtime);
X    strcpy(buffer, ctime(&curtime));
X    *strchr(buffer, '\n') = '\0';
X    getnodename();
X
X    printf("%%!PS-Adobe-1.0\n");
X    printf("%%%%Title: (stdin)\n");
X    printf("%%%%Creator: %s %s\n", progname, shortversion);
X    printf("%%%%PsroffVersion: %s\n", version);
X    printf("%%%%CreationDate: %s\n", buffer);
X    printf("%%%%For: %s\n", username);
X    printf("%%%%Pages: (atend)\n");
X    printf("%%%%DocumentFonts: (atend)\n");
X    printf("%%%%EndComments\n");
X    printf("/GlobalSave save def\n");
X    printf("/hits 0 def /misses 0 def\n");
X    /* special backends (eg: psfig) need this */
X    printf("/resolution %d def\n",
X#ifdef	DIT
X	ditroff? indtres:
X#endif
X	TROFFRESOLUTION);
X#ifndef	NOCHATTER
X    /* compatibility with behandler.ps */
X    printf("statusdict /jobname (%s@%s %s %s %s) def\n",
X	username, nodename, buffer, progname, shortversion);
X    printf("(%s@%s %s %s %s\\n) print\n", username, nodename, buffer,
X	progname, shortversion);
X    printf("flush\n");
X#endif
X    printf("usertime /btime exch def\n");
X    psXlate(library);
X    doprologs();
X    printf("%%%%EndProlog\n");
X    fclose(library);
X}
X
XpsEpilog() {
X    int i;
X    if (!currentPage)
X	return;
X    printf("%%%%Trailer\n");
X    if (metrics)
X	printf("%d metrics\n", charCount);
X#ifndef	NOCHATTER
X    printf("(Execution time (seconds): ) print\n");
X    printf("usertime btime sub 0.001 mul (          ) cvs print\n");
X    printf("(; Pages: %d) print\n", currentPage);
X    printf("(\\n) print\n");
X    printf("flush\n");
X#endif
X    /* If in display postscript */
X    printf("DPS? { (^D to exit\\n) print } if\n");
X    printf("GlobalSave restore\n");
X    printf("%%%%DocumentFonts:");
X    for (i = 0; i < MAXFONTS; i++)
X	if (fonttable[i].flags&USED)
X	    printf(" %s", fonttable[i].fontName);
X    printf("\n");
X    printf("%%%%Pages: %d\n", currentPage);
X#ifndef	NOCONTROLD
X    fputs(pstrailer, stdout);
X#endif
X}
X
XpsXlate(library)
XFILE *library; {
X    char buf[512];
X    while (fgets(buf, sizeof(buf), library))
X	if (0 == strncmp(buf, "%%%", 3))
X	    interp(&buf[3], psXlate, "ps");
X	else
X	    /* some backends don't like extra %! - eg: PageView */
X	    if (0 == strncmp(buf, "%!", 2)) {
X		buf[1] = '%';
X		fputs(&buf[1], stdout);
X	    } else
X		fputs(buf, stdout);
X}
X
XpsOverlay(overlay)
Xchar *overlay; {
X#ifdef	FORM
X    strcpy(Overlay, overlay);
X    printf("%%%%%%Form set: %s\n", Overlay);
X#endif
X}
X
X#ifdef	INSPECIAL
X
Xstatic
Xrequire(need, have, cmd, string)
Xint need, have;
Xchar *cmd, *string; {
X    if (need != have) {
X	fprintf(stderr, "%s: need %d argument%s to draw a %s (%s)\n",
X	    progname, need, need == 1? "": "s", cmd, string);
X	return(1);
X    } else
X	return(0);
X}
X
X/*	Do ditroff drawing command in s from origX,origY.
X	If opcode 0 just moveto
X */
XpsDraw(origX, origY, opcode, ctindex, numbers, saves)
Xint origX, origY;
Xint opcode;
Xchar *saves;
Xint ctindex;
Xshort *numbers; {
X
X    int i, fill = 0;
X    static float curfill = 0;
X    int curthick = 1;
X
X    /* map absolute beginning position. */
X    origX = TROFF2PSX(origX);
X    origY = TROFF2PSY(origY);
X
X    switch (opcode) {
X	case 'f':
X	    if (ctindex == 2)
X		ctindex = 1;
X	    if (!require(1, ctindex, "set fill", saves))
X		curfill = (double) numbers[0] / 1000;
X	    return;
X	case 't':
X	    if (ctindex == 2)
X		ctindex = 1;
X	    if (!require(1, ctindex, "set thick", saves))
X		curthick = numbers[0];
X	    return;
X    }
X    if (opcode)
X	putnl("newpath");
X    emitnums(origX);
X    emitnums(origY);
X    putnl("moveto");
X    if (!opcode)
X	return;
X
X    DBP((D_CAT, "psDraw: (%d,%d): %s\n", origX, origY, saves));
X
X    switch (opcode) {
X	case 'C':
X	    if (ctindex == 2)
X		ctindex = 1;
X	case 'E':
X	case 'P':
X	    fill = 1;
X	    if (opcode != 'P')
X		break;
X	case 'l':
X	case 'a':
X	case 'p':
X	case '~':
X	    for (i = 1; i < ctindex; i += 2)
X		numbers[i] = -numbers[i];
X    }
X    switch(opcode) {
X	case 'l':
X	    if (require(2, ctindex, "line", saves))
X		return;
X	    DBP((D_CAT, "drawline: %d, %d\n", numbers[0], numbers[1]));
X	    emitnums((int) numbers[0]);
X	    emitnums((int) numbers[1]);
X	    putnl("rlineto");
X	    break;
X	case 'a':
X	    if (require(4, ctindex, "arc", saves))
X		return;
X	    for (i = 0; i < 4; i++) {
X		emitnums(numbers[i]);
X	    }
X	    putnl("Arc");
X	    break;
X	case 'C':
X	case 'c':
X	    if (require(1, ctindex, "circle", saves))
X		return;
X	    numbers[1] = numbers[0];
X	    ctindex++;
X	case 'E':
X	case 'e':
X	    if (require(2, ctindex, "ellipse", saves))
X		return;
X	    DBP((D_CAT, "drawellipse: %d, %d\n", numbers[0], numbers[1]));
X	    emitnums((int) numbers[0]);
X	    emitnums((int) numbers[1]);
X	    putnl("Ellipse");
X	    break;
X	case 'P':
X	case 'p':
X	    if (ctindex&1) {
X		fprintf(stderr, "%s: even number of points for polygon: %s\n",
X		    progname, saves);
X		break;
X	    }
X	    for (i = 0; i < ctindex; i += 2) {
X		emitnums((int) numbers[i]);
X		emitnums((int) numbers[i+1]);
X		putnl("rlineto");
X	    }
X	    putnl(" closepath");
X	    break;
X	case '~':
X	    if (ctindex < 4) {
X		fprintf(stderr, "%s: too few points to spline: %s\n",
X		    progname, saves);
X		break;
X	    }
X	    emitnums(numbers[0]/2);
X	    emitnums(numbers[1]/2);
X	    putnl("rlineto");
X	    /* NUM/DEN should be between 0 and 1; the closer it is to 1
X		the tighter the curve will be to the guiding lines; 2/3
X		is the standard value */
X#define	NUM	2
X#define	DEN	3
X	    for (i = 0; i < ctindex - 2; i += 2) {
X		emitnums((numbers[i]*NUM)/(2*DEN));
X		emitnums((numbers[i + 1]*NUM)/(2*DEN));
X		emitnums(numbers[i]/2 + (numbers[i + 2]*(DEN - NUM))/(2*DEN));
X		emitnums(numbers[i + 1]/2 + (numbers[i + 3]*(DEN - NUM))/(2*DEN));
X		emitnums((numbers[i] - numbers[i]/2) + numbers[i + 2]/2);
X		emitnums((numbers[i + 1] - numbers[i + 1]/2) + numbers[i + 3]/2);
X		putnl("rcurveto");
X	    }
X	    emitnums(numbers[ctindex - 2] - numbers[ctindex - 2]/2);
X	    emitnums(numbers[ctindex - 1] - numbers[ctindex - 1]/2);
X	    putnl("rlineto");
X	    break;
X	default:
X	    fprintf(stderr, "%s: invalid draw code %c (%s)\n", progname, opcode,
X		saves);
X	    break;
X    }
X    if (fill)
X	printf("%.3f dofill\n", curfill);
X    else
X	printf("%d dost\n", curthick);
X}
X#endif
X#endif /* PS */
END_OF_FILE
  if test 19969 -ne `wc -c <'ps.c'`; then
    echo shar: \"'ps.c'\" unpacked with wrong size!
  fi
  # end of 'ps.c'
fi
if test -f 'utils/maps/cmtrf.ROMAN8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/maps/cmtrf.ROMAN8'\"
else
  echo shar: Extracting \"'utils/maps/cmtrf.ROMAN8'\" \(93 characters\)
  sed "s/^X//" >'utils/maps/cmtrf.ROMAN8' <<'END_OF_FILE'
X#2.1 90/07/18
X0x3C	0x3C	<
X0x3E	0x3E	>
X0x10	0x7C	br
X0x0E	0x5F	ul/ru
X{
X}
X\
X0x13	0xfc	solid box
END_OF_FILE
  if test 93 -ne `wc -c <'utils/maps/cmtrf.ROMAN8'`; then
    echo shar: \"'utils/maps/cmtrf.ROMAN8'\" unpacked with wrong size!
  fi
  # end of 'utils/maps/cmtrf.ROMAN8'
fi
if test -f 'utils/psdtwd.S' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/psdtwd.S'\"
else
  echo shar: Extracting \"'utils/psdtwd.S'\" \(20065 characters\)
  sed "s/^X//" >'utils/psdtwd.S' <<'END_OF_FILE'
X%%STARTSHELL%%
X#	Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991 Chris Lewis
X#		All Rights Reserved
X#
X#    See the LICENSE file for a full description of the restrictions
X#    under which this software is provided.
X#
X#	Most of this program was written by Michael Rourke (see below)
X#	to generate ditroff width tables from Postscript.  The original
X#	name (as distributed in tpscript) was genftable.  It has been
X#	extended to support more fonts than the original, plus attempt
X#	to handle non-builtin fonts.  This shell script's output should
X#	be sent to your postscript printer, and the printer will send
X#	back up the serial link a series of shars containing the
X#	width tables.
X#
X#	The program goes through all existing characters in the font
X#	to print width information in ditroff format.  The name of each
X#	character's drawing routine is used to look up how to print the
X#	width information.  There are three tables: the standard-encoding,
X#	symbol-encoding and ascii-map.  The first two are dictionaries,
X#	the third is an array.  If the font you've asked for is "Symbol",
X#	the symbol-encoding dictionary is used, otherwise standard-encoding.
X#	If the drawing routine isn't in the selected dictionary, the
X#	character code is used to look up in ascii-map for a new name.
X#	The new name is then searched for in standard-encoding to print the
X#	width information.
X#
X#	This latter kludge is necessary for fonts that don't use the
X#	standard naming conventions, and will work sanely only for characters
X#	32 (space) thru 126 (tilde).
X#
X#	usage: psdtwd <arguments>
X#
X#	if there are no arguments, pstdwd will generate widths for
X#	all of the fonts that are listed at the end of this shell
X#	script.  Arguments are usually repeated quoted
X#	strings of the form:
X#		/psname /intname /catname fontinfo
X#	Where psname is the Postscript name of the font.  intname is
X#	a shortened name (which psroff doesn't care about, but ditroff
X#	does apparently), catname is the one or two character name that
X#	cat will know it by (and will be the name of the resultant shar),
X#	and fontinfo is itself.
X#	If the argument is a readable filename instead, it is inserted.
X#	For example:
X#	./psdtwd hwfont "/HaeberliWriting /HaeberliW /HW fontinfo" \
X#		"/Times-Roman /Roman /R fontinfo"
X#	will insert file hwfont (usually containing the definition of the
X#	subsequent argument), and generate the widths in a file HW of
X#	the HaeberliWriting font, plus the widths for the "Times-Roman"
X#	font in R.
Xif [ $# = 0 ]
Xthen
X    all=1
Xelse
X    while [ $# != 0 ]
X    do
X	if [ -r $1 ]
X	then
X	    files="$files $1"
X	else
X	    lines="$lines $1"
X	fi
X	shift
X    done
Xfi
Xcat <<'END'
X%!
X% psdtwd -    Postcript program to produce font tables for ditroff.
X%	      Tables are output on the standard output file - which
X%	      needs to be captured by the host computer.
X%
X%	      Note the routine "commondefs" which outputs local
X%	      defined (hand built) characters.
X%
X% Michael Rourke, University of N.S.W., Australia
X% (included in troff2: 2.5 91/03/19)
X/SAVEOBJ save def
X
X/t 30 string def
X
X(Starting psdtwd.ps `date`\n) print
Xflush
X
X/ps
X% string ->
X{
X	print
X} def
X
X/pr
X% any -->
X{
X	t cvs ps
X} def
X
X/prsp
X{
X	(\t) ps
X} def
X
X/prnl
X{
X	(\n) ps
X} def
X
X/pro
X% int -->
X{
X	dup 0 eq
X	{ pr }
X	{ dup 8 idiv pro 8 mod pr }
X	ifelse
X} def
X
X/charsize
X% string --> bot top
X{
X	gsave
X	newpath 0 0 moveto false charpath flattenpath pathbbox
X	exch pop 3 -1 roll pop
X	grestore
X} def
X
X/strwidth
X% string --> width
X{
X	stringwidth pop round cvi
X} def
X
X/prsize
X% string -->
X{
X	dup strwidth pr prsp
X	dup charsize
X	top gt { 2 } { 0 } ifelse
X	exch bot lt { 1 or } if
X	pr prsp
X	0 get pro
X} def
X
X/fontinfo
X% fontname troffinternal troffname
X{
X	(\ncat <<"!" > ) ps dup pr prnl
X	(# ) ps 2 index pr prnl
X	(# resolution 720, unitwidth 10) ps prnl
X	(name ) ps pr prnl
X	(internalname ) ps pr prnl
X	dup findfont 100 scalefont setfont
X	/fixedwidth false def
X	/Symbol eq
X	{
X		/actions symbol-encoding def
X		(special\n) ps
X	}
X	{
X		/actions standard-encoding def
X		currentfont /FontInfo get /isFixedPitch get
X		{
X			(# fixed width\n) ps
X			/fixedwidth true def
X		}
X		{
X			(ligatures fi fl ff ffi ffl 0\n) ps
X		}
X		ifelse
X	}
X	ifelse
X	% use "o" to get top and bottom on a normal char
X	(o) charsize /top exch def /bot exch def
X	% some non ascending chars slightly higher than "o"
X	% and some lower so adjust slightly
X	/top top 2 add def
X	/bot bot 4 sub def
X	/encoding currentfont /Encoding get def
X	/s 1 string def
X	0 1 255
X	{
X		dup /id exch def
X		s 0 2 index put
X		encoding exch get dup /.notdef ne
X		{
X			s 1 index actions exch
X			% actions charfuncname
X			2 copy known
X			{
X				get
X				% charname charstr /type
X				exec
X				flush
X			}
X			{
X				% actions charfuncname
X				pop
X				ascii-map id get
X				2 copy known
X				{
X					get
X					% charname charstr /type
X					exec
X					flush
X				}
X				{
X					% charname charstr
X					pop
X					pop
X				}
X				ifelse
X			}
X			ifelse
X		}
X		{
X			pop
X		}
X		ifelse
X	} for
X	actions standard-encoding eq { commondefs } if
X	(!\n) ps flush
X} def
X
X/commondefs
X{
X	/fracsize (0) strwidth (\244) strwidth add def		% \244 = '/'
X	/Fisize (f) strwidth (\256) strwidth add 5 sub def	% \256 = 'fi'
X	/ffsize (f) strwidth 2 mul 5 sub def
X	/fl { flush } def
X	fixedwidth not
X	{
X		(ff) ps prsp ffsize pr (\t2\t0100\tff ligature - faked\n) ps fl
X		(Fi) ps prsp Fisize pr (\t2\t0100\tffi ligature - faked\n) ps fl
X		(Fl) ps prsp Fisize pr (\t2\t0100\tffl ligature - faked\n) ps fl
X	} if
X	(12) ps prsp fracsize pr (\t2\t0100\t1/2 - faked\n) ps fl
X	(13) ps prsp fracsize pr (\t2\t0100\t1/3 - faked\n) ps fl
X	(14) ps prsp fracsize pr (\t2\t0100\t1/4 - faked\n) ps fl
X	(18) ps prsp fracsize pr (\t2\t0100\t1/8 - faked\n) ps fl
X	(23) ps prsp fracsize pr (\t2\t0100\t2/3 - faked\n) ps fl
X	(34) ps prsp fracsize pr (\t2\t0100\t3/4 - faked\n) ps fl
X	(38) ps prsp fracsize pr (\t2\t0100\t3/8 - faked\n) ps fl
X	(58) ps prsp fracsize pr (\t2\t0100\t5/8 - faked\n) ps fl
X	(78) ps prsp fracsize pr (\t2\t0100\t7/8 - faked\n) ps fl
X	(sq\t100\t3\t0100\tsquare box - faked\n) ps fl
X} def
X
X/space
X% charname charstr -->
X{
X	(spacewidth ) ps
X	strwidth pr pop prnl
X	(charset\n) ps
X} def
X
X/norm
X% charname charstr -->
X{
X	dup pr prsp prsize pop prnl
X} def
X
X/normdup
X% charname charstr dupname -->
X{
X	3 1 roll norm
X	pr prsp (") ps prnl
X} def
X
X/gnorm
X% charname charstr -->
X{
X	(*) ps norm
X} def
X
X/map
X% charname charstr mapname -->
X{
X	pr prsp prsize prsp pr prnl
X} def
X
X/mapdup
X% charname charstr mapname dupname -->
X{
X	4 1 roll map
X	pr prsp (") ps prnl
X} def
X
X/mapdupdup
X% charname charstr mapname dupname dupname -->
X{
X	5 1 roll mapdup
X	pr prsp (") ps prnl
X} def
X
X/cmap
X% charname charstr mapname -->
X{
X	fixedwidth { 3 { pop } repeat } { map } ifelse
X} def
X
X/ascii-map 256 array def
X0 1 255 {ascii-map exch /exclam put} for
X
Xascii-map 32 /space put
Xascii-map 33 /exclam put
Xascii-map 34 /quotedbl put
Xascii-map 35 /numbersign put
Xascii-map 36 /dollar put
Xascii-map 37 /percent put
Xascii-map 38 /ampersand put
Xascii-map 39 /quoteright put
Xascii-map 40 /parenleft put
Xascii-map 41 /parenright put
Xascii-map 42 /asterisk put
Xascii-map 43 /plus put
Xascii-map 44 /comma put
Xascii-map 45 /hyphen put
Xascii-map 46 /period put
Xascii-map 47 /slash put
Xascii-map 48 /zero put
Xascii-map 49 /one put
Xascii-map 50 /two put
Xascii-map 51 /three put
Xascii-map 52 /four put
Xascii-map 53 /five put
Xascii-map 54 /six put
Xascii-map 55 /seven put
Xascii-map 56 /eight put
Xascii-map 57 /nine put
Xascii-map 58 /colon put
Xascii-map 59 /semicolon put
Xascii-map 60 /less put
Xascii-map 61 /equal put
Xascii-map 62 /greater put
Xascii-map 63 /question put
Xascii-map 64 /at put
Xascii-map 65 /A put
Xascii-map 66 /B put
Xascii-map 67 /C put
Xascii-map 68 /D put
Xascii-map 69 /E put
Xascii-map 70 /F put
Xascii-map 71 /G put
Xascii-map 72 /H put
Xascii-map 73 /I put
Xascii-map 74 /J put
Xascii-map 75 /K put
Xascii-map 76 /L put
Xascii-map 77 /M put
Xascii-map 78 /N put
Xascii-map 79 /O put
Xascii-map 80 /P put
Xascii-map 81 /Q put
Xascii-map 82 /R put
Xascii-map 83 /S put
Xascii-map 84 /T put
Xascii-map 85 /U put
Xascii-map 86 /V put
Xascii-map 87 /W put
Xascii-map 88 /X put
Xascii-map 89 /Y put
Xascii-map 90 /Z put
Xascii-map 91 /bracketleft put
Xascii-map 92 /backslash put
Xascii-map 93 /bracketright put
Xascii-map 94 /asciicircum put
Xascii-map 95 /underscore put
Xascii-map 96 /quoteleft put
Xascii-map 97 /a put
Xascii-map 98 /b put
Xascii-map 99 /c put
Xascii-map 100 /d put
Xascii-map 101 /e put
Xascii-map 102 /f put
Xascii-map 103 /g put
Xascii-map 104 /h put
Xascii-map 105 /i put
Xascii-map 106 /j put
Xascii-map 107 /k put
Xascii-map 108 /l put
Xascii-map 109 /m put
Xascii-map 110 /n put
Xascii-map 111 /o put
Xascii-map 112 /p put
Xascii-map 113 /q put
Xascii-map 114 /r put
Xascii-map 115 /s put
Xascii-map 116 /t put
Xascii-map 117 /u put
Xascii-map 118 /v put
Xascii-map 119 /w put
Xascii-map 120 /x put
Xascii-map 121 /y put
Xascii-map 122 /z put
Xascii-map 123 /braceleft put
Xascii-map 124 /bar put
Xascii-map 125 /braceright put
Xascii-map 126 /asciitilde put
X
X/standard-encoding 149 dict def
Xstandard-encoding begin
X	/space		{ space }		def
X	/exclam		{ norm }		def
X	/quotedbl	{ norm }		def
X	/numbersign	{ norm }		def
X	/dollar		{ norm }		def
X	/percent	{ norm }		def
X	/ampersand	{ norm }		def
X	/quoteright	{ norm }		def
X	/parenleft	{ norm }		def
X	/parenright	{ norm }		def
X	/asterisk	{ norm }		def
X	/plus		{ norm }		def
X	/comma		{ norm }		def
X	/hyphen		{ (hy) normdup }	def
X	/period		{ norm }		def
X	/slash		{ (sl) normdup }	def
X	/zero		{ norm }		def
X	/one		{ norm }		def
X	/two		{ norm }		def
X	/three		{ norm }		def
X	/four		{ norm }		def
X	/five		{ norm }		def
X	/six		{ norm }		def
X	/seven		{ norm }		def
X	/eight		{ norm }		def
X	/nine		{ norm }		def
X	/colon		{ norm }		def
X	/semicolon	{ norm }		def
X	/less		{ norm }		def
X	/equal		{ norm }		def
X	/greater	{ norm }		def
X	/question	{ norm }		def
X	/at		{ norm }		def
X	/A		{ norm }		def
X	/B		{ norm }		def
X	/C		{ norm }		def
X	/D		{ norm }		def
X	/E		{ norm }		def
X	/F		{ norm }		def
X	/G		{ norm }		def
X	/H		{ norm }		def
X	/I		{ norm }		def
X	/J		{ norm }		def
X	/K		{ norm }		def
X	/L		{ norm }		def
X	/M		{ norm }		def
X	/N		{ norm }		def
X	/O		{ norm }		def
X	/P		{ norm }		def
X	/Q		{ norm }		def
X	/R		{ norm }		def
X	/S		{ norm }		def
X	/T		{ norm }		def
X	/U		{ norm }		def
X	/V		{ norm }		def
X	/W		{ norm }		def
X	/X		{ norm }		def
X	/Y		{ norm }		def
X	/Z		{ norm }		def
X	/bracketleft	{ norm }		def
X	/backslash	{ norm }		def
X	/bracketright	{ norm }		def
X	/asciicircum	{ (a^) map }		def
X	/underscore	{ (ru) normdup }	def
X	/quoteleft	{ norm }		def
X	/a		{ norm }		def
X	/b		{ norm }		def
X	/c		{ norm }		def
X	/d		{ norm }		def
X	/e		{ norm }		def
X	/f		{ norm }		def
X	/g		{ norm }		def
X	/h		{ norm }		def
X	/i		{ norm }		def
X	/j		{ norm }		def
X	/k		{ norm }		def
X	/l		{ norm }		def
X	/m		{ norm }		def
X	/n		{ norm }		def
X	/o		{ norm }		def
X	/p		{ norm }		def
X	/q		{ norm }		def
X	/r		{ norm }		def
X	/s		{ norm }		def
X	/t		{ norm }		def
X	/u		{ norm }		def
X	/v		{ norm }		def
X	/w		{ norm }		def
X	/x		{ norm }		def
X	/y		{ norm }		def
X	/z		{ norm }		def
X	/braceleft	{ norm }		def
X	/bar		{ norm }		def
X	/braceright	{ norm }		def
X	/asciitilde	{ (a~) map }		def
X	/exclamdown	{ (I!) map }		def
X	/cent		{ (ct) map }		def
X	/sterling	{ (po) map }		def
X	/fraction	{ }			def
X	/yen		{ ($J) map }		def
X	/florin		{ }			def
X	/section	{ (sc) map }		def
X	/currency	{ }			def
X	/quotesingle	{ (fm) (n') mapdup }	def
X	/quotedblleft	{ (lq) map }		def
X	/guillemotleft	{ (d<) map }		def
X	/guilsinglleft	{ (l<) map }		def
X	/guilsinglright	{ (r>) map }		def
X	/fi		{ (fi) cmap }		def
X	/fl		{ (fl) cmap }		def
X	/endash		{ (\\-) map }		def
X	/dagger		{ (dg) map }		def
X	/daggerdbl	{ (dd) map }		def
X	/periodcentered	{ }			def
X	/paragraph	{ (pp) map }		def
X	/bullet		{ (bu) map }		def
X	/quotesinglbase	{ } 			def
X	/quotedblbase	{ }			def
X	/quotedblright	{ (rq) map }		def
X	/guillemotright	{ (d>) map }		def
X	/ellipsis	{ }			def
X	/perthousand	{ (pm) cmap }		def
X	/questiondown	{ (I?) map }		def
X	/grave		{ (ga) (\\`) mapdup }	def
X	/acute		{ (aa) (\\') mapdup }	def
X	/circumflex	{ (^) map }		def
X	/tilde		{ (~) map }		def
X	/macron		{ (ma) map }		def
X	/breve		{ (be) map }		def
X	/dotaccent	{ (dt) map }		def
X	/dieresis	{ (..) (um) mapdup }	def
X	/ring		{ (ri) map }		def
X	/cedilla	{ (cd) map }		def
X	/hungarumlaut	{ ('') map }		def
X	/ogonek		{ (og) map }		def
X	/caron		{ (hc) map }		def
X	/emdash		{ (em) map }		def
X	/AE		{ (AE) cmap }		def
X	/ordfeminine	{ }			def
X	/Lslash		{ (PL) map }		def
X	/Oslash		{ (O/) map }		def
X	/OE		{ (OE) cmap }		def
X	/ordmasculine	{ }			def
X	/ae		{ (ae) cmap }		def
X	/dotlessi	{ (ui) map }		def
X	/lslash		{ (Pl) map }		def
X	/oslash		{ (o/) map }		def
X	/oe		{ (oe) cmap }		def
X	/germandbls	{ (ss) map }		def
Xend
X
X/symbol-encoding 189 dict def
Xsymbol-encoding begin
X	/space		{ space }		def
X	/exclam		{ norm }		def
X	/universal	{ (fa) map }		def
X	/numbersign	{ norm }		def
X	/existential	{ (te) map }		def
X	/percent	{ norm }		def
X	/ampersand	{ norm }		def
X	/suchthat	{ (cm) map }		def
X	/parenleft	{ norm }		def
X	/parenright	{ norm }		def
X	/asteriskmath	{ (**) map }		def
X	/plus		{ (pl) map }		def
X	/comma		{ norm }		def
X	/minus		{ (mi) normdup }	def
X	/period		{ norm }		def
X	/slash		{ (sl) map }		def
X	/zero		{ norm }		def
X	/one		{ norm }		def
X	/two		{ norm }		def
X	/three		{ norm }		def
X	/four		{ norm }		def
X	/five		{ norm }		def
X	/six		{ norm }		def
X	/seven		{ norm }		def
X	/eight		{ norm }		def
X	/nine		{ norm }		def
X	/colon		{ norm }		def
X	/semicolon	{ norm }		def
X	/less		{ norm }		def
X	/equal		{ (eq) normdup }	def
X	/greater	{ norm }		def
X	/question	{ norm }		def
X	/congruent	{ (=~) map }		def
X	/Alpha		{ gnorm }		def
X	/Beta		{ gnorm }		def
X	/Chi		{ (*X) map }		def
X	/Delta		{ gnorm }		def
X	/Epsilon	{ gnorm }		def
X	/Phi		{ gnorm }		def
X	/Gamma		{ gnorm }		def
X	/Eta		{ (*Y) map }		def
X	/Iota		{ gnorm }		def
X	/theta1		{ }			def
X	/Kappa		{ gnorm }		def
X	/Lambda		{ gnorm }		def
X	/Mu		{ gnorm }		def
X	/Nu		{ gnorm }		def
X	/Omicron	{ gnorm }		def
X	/Pi		{ gnorm }		def
X	/Theta		{ (*H) map }		def
X	/Rho		{ gnorm }		def
X	/Sigma		{ gnorm }		def
X	/Tau		{ gnorm }		def
X	/Upsilon	{ gnorm }		def
X	/sigma1		{ (ts) map }		def
X	/Omega		{ (*W) map }		def
X	/Xi		{ (*C) map }		def
X	/Psi		{ (*Q) map }		def
X	/Zeta		{ gnorm }		def
X	/bracketleft	{ norm }		def
X	/therefore	{ (tf) map }		def
X	/bracketright	{ norm }		def
X	/perpendicular	{ (bt) map }		def
X	/underscore	{ (ul) map }		def
X	/radicalex	{ }			def
X	/alpha		{ gnorm }		def
X	/beta		{ gnorm }		def
X	/chi		{ (*x) map }		def
X	/delta		{ gnorm }		def
X	/epsilon	{ gnorm }		def
X	/phi		{ gnorm }		def
X	/gamma		{ gnorm }		def
X	/eta		{ (*y) map }		def
X	/iota		{ gnorm }		def
X	/phi1		{ }			def
X	/kappa		{ gnorm }		def
X	/lambda		{ gnorm }		def
X	/mu		{ gnorm }		def
X	/nu		{ gnorm }		def
X	/omicron	{ gnorm }		def
X	/pi		{ gnorm }		def
X	/theta		{ (*h) map }		def
X	/rho		{ gnorm }		def
X	/sigma		{ gnorm }		def
X	/tau		{ gnorm }		def
X	/upsilon	{ gnorm }		def
X	/omega1		{ }			def
X	/omega		{ (*w) map }		def
X	/xi		{ (*c) map }		def
X	/psi		{ (*q) map }		def
X	/zeta		{ gnorm }		def
X	/braceleft	{ norm }		def
X	/bar		{ (or) normdup }	def
X	/braceright	{ norm }		def
X	/similar	{ (ap) map }		def
X	/Upsilon1	{ }			def
X	/minute		{ (mt) map }		def
X	/lessequal	{ (<=) map }		def
X	/fraction	{ (/) map }		def
X	/infinity	{ (if) map }		def
X	/florin		{ }			def
X	/club		{ (Cc) map }		def
X	/diamond	{ (Cd) map }		def
X	/heart		{ (Ch) map }		def
X	/spade		{ (Cs) map }		def
X	/arrowboth	{ (<>) map }		def
X	/arrowleft	{ (<-) map }		def
X	/arrowup	{ (ua) map }		def
X	/arrowright	{ (->) map }		def
X	/arrowdown	{ (da) map }		def
X	/degree		{ (de) map }		def
X	/plusminus	{ (+-) map }		def
X	/second		{ (sd) map }		def
X	/greaterequal	{ (>=) map }		def
X	/multiply	{ (mu) map }		def
X	/proportional	{ (pt) map }		def
X	/partialdiff	{ (pd) map }		def
X	/bullet		{ }			def
X	/divide		{ (di) map }		def
X	/notequal	{ (!=) map }		def
X	/equivalence	{ (==) map }		def
X	/approxequal	{ (~=) map }		def
X	/ellipsis	{ }			def
X	/arrowvertex	{ }			def
X	/arrowhorizex	{ }			def
X	/carriagereturn	{ (cr) map }		def
X	/aleph		{ (al) map }		def
X	/Ifraktur	{ }			def
X	/Rfraktur	{ }			def
X	/weierstrass	{ }			def
X	/circlemultiply	{ (ax) map }		def
X	/circleplus	{ (a+) map }		def
X	/emptyset	{ (es) map }		def
X	/intersection	{ (ca) map }		def
X	/union		{ (cu) map }		def
X	/propersuperset	{ (sp) map }		def
X	/reflexsuperset	{ (ip) map }		def
X	/notsubset	{ (!s) map }		def
X	/propersubset	{ (sb) map }		def
X	/reflexsubset	{ (ib) map }		def
X	/element	{ (mo) map }		def
X	/notelement	{ (!m) (nm) mapdup }	def
X	/angle		{ (ag) map }		def
X	/gradient	{ (gr) map }		def
X	/registerserif	{ }			def
X	/copyrightserif	{ }			def
X	/trademarkserif	{ }			def
X	/product	{ }			def
X	/radical	{ (sr) map }		def
X	/dotmath	{ (m.) map }		def
X	/logicalnot	{ (no) map }		def
X	/logicaland	{ (an) (la) mapdup }	def
X	/logicalor	{ (lo) map }		def
X	/arrowdblboth	{ (io) map }		def
X	/arrowdblleft	{ (<:) (lh) mapdup }	def
X	/arrowdblup	{ (u=) map }		def
X	/arrowdblright	{ (:>) (rh) (im) mapdupdup } def
X	/arrowdbldown	{ (d=) map }		def
X	/lozenge	{ (dm) map }		def
X	/angleleft	{ (L<) map }		def
X	/registersans	{ (rg) map }		def
X	/copyrightsans	{ (co) map }		def
X	/trademarksans	{ (tm) map }		def
X	/summation	{ }			def
X	/parenlefttp	{ }			def
X	/parenleftex	{ }			def
X	/parenleftbt	{ }			def
X	/bracketlefttp	{ }			def
X	/bracketleftex	{ }			def
X	/bracketleftbt	{ }			def
X	/bracelefttp	{ }			def
X	/braceleftmid	{ }			def
X	/braceleftbt	{ }			def
X	/braceex	{ }			def
X	/apple		{ (AL) map }		def
X	/angleright	{ (R>) map }		def
X	/integral	{ (is) map }		def
X	/integraltp	{ }			def
X	/integralex	{ }			def
X	/integralbt	{ }			def
X	/parenrighttp	{ }			def
X	/parenrightex	{ }			def
X	/parenrightbt	{ }			def
X	/bracketrighttp	{ }			def
X	/bracketrightex	{ }			def
X	/bracketrightbt	{ }			def
X	/bracerighttp	{ }			def
X	/bracerightmid	{ }			def
X	/bracerightbt	{ }			def
Xend
XEND
Xif [ -n "$all" ]
Xthen
Xcat <<'END'
X	/AvantGarde-Demi                /AvantAB     /AB fontinfo
X	/AvantGarde-DemiOblique         /AvantAI     /AI fontinfo
X	/AvantGarde-Book                /AvantAR     /AR fontinfo
X	/AvantGarde-BookOblique         /AvantAX     /AX fontinfo
X	/Times-Bold                     /Bold        /B  fontinfo
X	/Bookman-Demi                   /BookB       /BB fontinfo
X	/Times-BoldItalic               /BoldI       /BI fontinfo
X	/Bookman-LightItalic            /BookI       /BO fontinfo
X	/Bookman-Light                  /BookR       /BR fontinfo
X	/Bookman-DemiItalic             /BookBI      /BX fontinfo
X	/Courier                        /Courier     /C  fontinfo
X	/Courier-Bold                   /CourierB    /CB fontinfo
X	/Courier-Oblique                /CourierO    /CO fontinfo
X	/Courier-BoldOblique            /CourierBO   /CX fontinfo
X	/Helvetica                      /Helvetica   /H  fontinfo
X	/Helvetica-Bold                 /HelvB       /HB fontinfo
X	/Helvetica-Oblique              /HelvO       /HO fontinfo
X	/Helvetica-BoldOblique          /HelvBO      /HX fontinfo
X	/Helvetica-Narrow-Bold          /HelvNarHb   /Hb fontinfo
X	/Helvetica-Narrow-Oblique       /HelvNarHo   /Hi fontinfo
X	/Helvetica-Narrow               /HelvNarHn   /Hr fontinfo
X	/Helvetica-Narrow-BoldOblique   /HelvNarHx   /Hx fontinfo
X	/Times-Italic                   /Italic      /I  fontinfo
X	/NewCenturySchlbk-Bold          /NewCB       /NB fontinfo
X	/NewCenturySchlbk-Italic        /NewCI       /NI fontinfo
X	/NewCenturySchlbk-Roman         /NewCR       /NR fontinfo
X	/NewCenturySchlbk-BoldItalic    /NewCX       /NX fontinfo
X	/Palatino-Bold                  /PalatPB     /PB fontinfo
X	/Palatino-Italic                /PalatPI     /PI fontinfo
X	/Palatino-Roman                 /PalatPR     /PR fontinfo
X	/Palatino-BoldItalic            /PalatPX     /PX fontinfo
X	/Times-Roman                    /Roman       /R  fontinfo
X	/Symbol                         /Symbol      /S  fontinfo
X	/BracketF                       /BracketF    /S2 fontinfo
X	/ZapfChancery-MediumItalic      /ZapfC       /ZC fontinfo
X	%	Neither of the next two are likely to work.
X	/HaeberliWriting                /HaeberliW   /HW fontinfo
X	/ZapfDingbats                   /ZapfD       /ZD fontinfo
XEND
Xelse
X    if [ -n "$files" ]
X    then
X	cat $files
X    fi
X    if [ -n "$lines" ]
X    then
X	echo $lines
X    fi
Xfi
Xecho "SAVEOBJ restore"
Xecho "\004\c"
END_OF_FILE
  if test 20065 -ne `wc -c <'utils/psdtwd.S'`; then
    echo shar: \"'utils/psdtwd.S'\" unpacked with wrong size!
  fi
  # end of 'utils/psdtwd.S'
fi
echo shar: End of archive 4 \(of 19\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 19 archives.
    echo "Read the README to get started with psroff installation"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
