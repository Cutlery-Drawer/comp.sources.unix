Subject:  v24i104:  psroff, Troff to PostScript filter, Part09/19
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: Chris Lewis <latour!ecicrl!clewis@uunet.uu.net>
Posting-number: Volume 24, Issue 104
Archive-name: psroff3.o/part09

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  MISC defs.h man/psroff.1.S utils/calcfonts.S
#   widths/dit2catwid.c
# Wrapped by clewis@ecicrl on Fri Apr  5 20:56:00 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 9 (of 19)."'
if test -f 'MISC' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MISC'\"
else
  echo shar: Extracting \"'MISC'\" \(10084 characters\)
  sed "s/^X//" >'MISC' <<'END_OF_FILE'
X		Miscellaneous Tuning/Customization
X			2.9 91/03/26
X
X    - Postscript spooling:  Theoretically speaking, it is better
X      to have psxlate in your Postscript printer spooler interface
X      than as a pipeline in psroff.  For System V, you might want
X      to insert psxlate as the filter (instead of the more-usual
X      cat) in the interface file when you're passing postscript through
X      to the printer.  On lpr-type spoolers, make psxlate the filter
X      program in /etc/printcap.  Then you'll be able to use psxlate's
X      processing on all of your postscript output.
X
X      Notes: psxlate does NOTHING to files without a "%!PS-Adobe-"
X      header.  In other words, psxlate doesn't do anything to files
X      that don't conform to the Document Structuring Conventions.
X      Eventually psxlate will probably permit you to do n-up (but
X      not page flipping) on any file that has a "%!" at the front,
X      and do automatic ASCII to Postscript conversions on files that
X      don't have "%!", further, page flipping and n-up *will* work.
X
X    - psfig: If you have psfig, copy the psfig Postscript prolog
X      to LIBDIR/lib/psfig.ps, and insert the following line at
X      the end of ps.lib:
X	%%%include psfig
X      (psfig.ps is a subset of the psdit prolog fragment given in the
X      "patch" subdirectory in the psfig release - the README tells
X      you which part)
X
X      Psfig works perfectly with ditroff, and should work reasonably
X      well with CAT troff.  Note: most ditroff's have a bug where
X      the horizontal position is not emitted before a \X'...'
X      sequence.  This is seen by diagrams that aren't quite where
X      they should be horizontally - often at the left margin when
X      they should really be centered.  This can be rectified if
X      you have source with a patch for ditroff that comes bundled with
X      psfig.  If you do not have ditroff source, the psfig option "-fts"
X      (not mentioned in the man page for psfig) will compensate for the
X      problem, at the expense of losing the ability to use the \(ts character.
X      The -fts option is ALWAYS required with CAT troff.  See "catconv"
X      below.
X
X      (Note: In the psfig document under the "doc" directory in the
X      psfig release, page 10 contains a MACWrite generated figure.
X      Near the end of page 10 there is a bit of postscript that
X      most postscript printers don't like (a findfont) - print aborts
X      at this point are NOT the fault of psroff, but a fault in the
X      postscript that psfig has included).
X
X    - catconv: catconv converts ditroff-only-isms into something handled
X      by psroff.  In order for you to use this, you have to have a copy
X      of perl installed on your machine.  This isn't completely
X      integrated into psroff, so here are a few things to consider:
X	- the catconv script's startup (the #!/usr/bin/perl stuff)
X	  may have to be changed to reflect your perl install configuration.
X	- If you specify "v=1" in the psrofflib entry, psroff will
X	  arrange to invoke catconv properly, so that you don't have
X	  to manually invoke catconv - the "cdps" entry has an example.
X      If you are using CAT troff, if you cannot use catconv, you will
X      not be able to use psfig, \X'...' commands, \D'....' commands
X      (PIC) or the extended character set.
X
X    - HPLJ tuning:
X	bestmatch: in lj.c's bestmatch function there is are arrays
X	    "bigtry" and "smalltry".  These arrays provide a scan
X	    sequence finding a font size "close" to a requested font
X	    size that lj.fonts indicates isn't present.  If there
X	    are holes in your fonts, you may want to experiment with
X	    these arrays.
X	tbl box corners: depending on where you got your fonts from,
X	    you may have to slightly adjust the box drawing characters
X	    to match up at the corners of tbl boxes.  To do this,
X	    append to lj.fonts:
X
X		normal
X		ru N _ 0 -200
X		symbol
X		br N | -220 0
X
X	    The two numbers are the X and Y shifts of the corresponding
X	    characters, where the numbers are scaled by (.01 * pointsize)
X	    to get a shift in 1/720'ds.  Adjust these (carefully examine
X	    tbl output to decide whether you want to move ru or br).
X
X	    The distributed defaults (which are shown here) are suitable
X	    for HP Times-Roman font floppies.
X
X	- performance: you can preload commonly used fonts into your
X	  laserjet and thereby greatly reduce transmission time.
X	  Consult the manual page for pk2sfp about the -P, -i, -S and -p
X	  options (don't forget to mark the pointsizes you've downloaded
X	  as "b" in the lj.fonts file).
X
X	- ditroff tuning: Many of the ditroff converters have slightly
X	  different correspondences between what character is in what
X	  font.  You may want to modify the *.fonts file that you're
X	  using to make sure that every character you want is being
X	  printed correctly.  As an example, with tpscript "@" and
X	  "^" aren't S font characters - they're in the normal fonts,
X	  but the dt.c table says they're "symbol".  To tune for
X	  tpscript:
X
X	    - modify psrofflib to have "-ptp" option to troff2ps (t2arg).
X	    - copy dt.fonts to tp.fonts (in LIBDIR/lib).
X	    - append to tp.fonts the following font override sequence:
X
X		symbol
X		^	N
X		@	N
X
X	  psdit and xtroff appear to require the same things to be done
X	  for "^" and "@" (psdit prints nothing without these, and xtroff
X	  prints some other characters instead).
X
X	  Jetroff requires similar things, and jt.fonts has a more
X	  extensive example of this.  Font overrides are documented
X	  more completely next:
X
X	- If you want to play around with character mappings.....
X	  Eg: adding accents for your own language (ie: German)
X	  The most important thing to remember is that you cannot extend
X	  the CAT's character sets without modifying troff - unlike ditroff
X	  where you can add them by changing the makedev files.  This
X	  is how you do overrides (see troff2ps(1) for more details):
X
X	    - Put in a map override in the appropriate *.fonts file that
X	      emits the character you want in place of a character you
X	      don't need in the appropriate *.fonts file.  Eg: for
X	      "germandbls" in ditroff, emit "ss" instead of "ct" for
X	      the cent character.  Your override (in dt.fonts) would
X	      look like:
X
X		ct N ss
X
X	      The complete override format is:
X
X		<troffchar> N|S|n <sequence> <x adjust> <y adjust> <scale>
X
X	      x adjust, y adjust, scale default to 0, 0 and 100 respectively.
X	      x and y adjust are multiplied by .01, then the pointsize
X	      and of the output driver to give the shift factor in
X	      1/resolution units.  Scale allows you to change the size
X	      of that one character (eg: you think bullet is too small), but
X	      it isn't recommended too much (it may not work reasonably
X	      on non-postscript drivers).  Again, scale is prescaled by
X	      .01 first, so 100 is 1-1.
X
X	      <sequence> defaults to <troffchar>.  N means normal mapping
X	      (eg: for fonts other than S with no cross font jumping),
X	      S means symbol font, and "n" means specific font (usually >3 -
X	      eg: special bracket fonts).
X
X	    - Modify the width table for the character you're replacing
X	      to have the width for the character you're emitting.
X	      Eg: for germandbls in ditroff, replace the "ct" entry's
X	      width in widths/widthps/R with the width for "ss".  This
X	      latter step is not necessary with laserjets because the
X	      build procedure builds a new width table using the
X	      remapping.
X
X	  With ditroff input (or the use of the "C" special directives - see
X	  troff2ps(1)), you can extend the character set as much as you want.
X	  You find the entry in the appropriate width files and add in the
X	  width entries for your character, and then add them to the
X	  "extensions" section of the ??.fonts file.  See ps.fonts for
X	  an example.  At present there's no way of getting the width
X	  information into CAT troff, but with ditroff everything works well.
X	  By adding the entry into the width file, the widths/Makefile
X	  will generate a complete set of extension characters in
X	  width??/??.ext, which can be appended onto the *.fonts file.
X
X    - Adding fonts after installation:
X	- New Laserjet fonts should be installed in the $LJF directory.
X	- Non-laserjet fonts should have their ditroff width table placed
X	  in the proper widths/width?? directory.
X	- Ensure that the appropriate lib/*.fonts file contains the fonts
X	  you're adding.
X	- at the top level, type:
X	    make register
X	- then
X	    su root
X	    make installwidths
X
X    - Display Postscript: My display postscript came with the source for
X      a utility called "dpsexec", which is a simple Postscript previewer
X      front end.  The source on a IBM RS/6000 was in:
X	/usr/lpp/DPS/examples/dpsexec/dpsexec.c
X      For best results, you may want to apply the following patch
X      to it (it redefines the initial window to be big enough
X      to contain a standard page, as well as adding a "!" escape to
X      shell in the interrupt handler):
X
X=========== DPSEXEC.C PATCH START ==============
X*** dpsexec.c.orig	Sat Mar  9 02:00:45 1991
X--- dpsexec.c	Mon Mar 11 23:27:32 1991
X***************
X*** 65,72 ****
X  #include <DPS/XDPSlib.h>
X  #include <DPS/dpsXclient.h>
X
X! #define W_HEIGHT	512
X! #define W_WIDTH		512
X
X  static int quitFlag = 0;
X  static unsigned long int enable, next, disable;
X--- 65,72 ----
X  #include <DPS/XDPSlib.h>
X  #include <DPS/dpsXclient.h>
X
X! #define W_HEIGHT	(11*72)
X! #define W_WIDTH		(9*72)
X
X  static int quitFlag = 0;
X  static unsigned long int enable, next, disable;
X***************
X*** 195,200 ****
X--- 195,201 ----
X      printf("\tq\tquit\n");
X      printf("\ti\tinterrupt\n");
X      printf("\tk\tkill\n");
X+     printf("\t!\tshell\n");
X      printf("Command: ");
X      c = getchar(); getchar(); /* eat the newline */
X      switch (c)
X***************
X*** 215,220 ****
X--- 216,224 ----
X          case 'k':
X              command = 6;
X              break;
X+ 	case '!':
X+ 	    system("/bin/sh");
X+ 	    break;
X  	default:;
X          }
X
X=========== DPSEXEC.C PATCH END ======================
END_OF_FILE
  if test 10084 -ne `wc -c <'MISC'`; then
    echo shar: \"'MISC'\" unpacked with wrong size!
  fi
  # end of 'MISC'
fi
if test -f 'defs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'defs.h'\"
else
  echo shar: Extracting \"'defs.h'\" \(11537 characters\)
  sed "s/^X//" >'defs.h' <<'END_OF_FILE'
X/*
X	Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991 Chris Lewis
X		All Rights Reserved
X
X    See the LICENSE file for a full description of restrictions under which
X    this software is provided.
X
X	Function:	Main header file - contains some customization
X */
X
X/*	Official Release and Patch level:	*/
X#define	T2VERSION	"@(#)PSROFF Copyright 91/03/25 Chris Lewis - R3 PL0"
X
X/*	Configuration parameters:
X */
X
X#undef	BSD		/* Define if you are a V7 or BSD machine */
X			/* strchr vs. index etc.... */
X
X#define	ATT		/* Define if you are some sort of SIII or SV system */
X
X#undef	BCOPY		/* Define if you don't have memcpy and friends - eg:
X			   oldish BSD systems */
X
X#undef  BCOPYLIB	/* Define if BCOPY is defined and you have */
X			/* a bcopy in your library */
X
X/*	The name of a routine that can be called thusly:
X	VFPRINTF(stream, format, ap)
X	FILE *stream;
X	char *format;
X	va_list ap;
X    (eg: you have varargs.h and you have a routine functionally compatible
X    with System V vfprintf.  I think BSD has one too)
X
X    undef if you don't got, and maybe my fakeout will work.
X */
X
X#define VFPRINTF	vfprintf
X
X/* If you have the stand-alone pk2sfp distribution, do not touch
X   anything from here on */
X
X/*	Font width file configuration:
X
X	- If HEADERSIZE defined, use that many bytes as a prefix to the
X	  compiled font width table.  HEADERSIZE 0 is the correct definition
X	  for Xenix and most System V [o]troffs.  HEADERSIZE=32 works for Ultrix
X	  (except RISC, see below).  HEADERSIZE=32 works properly for most Suns.
X	- If COFF is defined instead, use a COFF header on the beginning of
X	  the file.  I personally know of no machine that supports these, tho,
X	  there's unconfirmed rumours that Apollo systems might.
X	- If neither are defined, use a BSD/V7 style a.out.h header, this
X	  is appropriate for V7 and BSD troffs
X	- If you are running RISC/Ultrix (Mips box? from DEC) define
X	  ASCIIWIDTHS, and the rest of this stuff will be ignored - Mips
X	  apparently changed their width table format to an ASCII form,
X	  and DEC picked it up.  In this case IGNORE any messages about
X	  HEADERSIZE from "make check".
X
X    The headers I write will have something in them if HEADERSIZE > 0
X    and there's a font file from your original troff distribution in
X    /usr/lib/font/ftR (the header and trailer will be copied over).
X
X */
X
X#define	HEADERSIZE 0	/* size of header in bytes */
X#undef	COFF		/* systems using COFF headers - See TROUBLE file
X			   about Apollos */
X#undef	ASCIIWIDTHS	/* For RISC/Ultrix */
X
X/* What do your CAT codes look like?
X
X   If BSDHACK defined, the code to magnify the next lead by 64 replaces the
X   codes to set the tilt (tilt used only on 8-font CATs, which most CAT troff
X   programs don't support).
X
X   Both FONT8 and BSDHACK code are *untested*.  FONT8 probably does *not*
X   work.
X */
X
X#undef	BSDHACK		/* Has magnify lead opcode - untested */
X#undef	FONT8		/* 8 Font device - untested */
X#define FONT4		/* Normal 4 font device */
X
X			/* define a command for decompressing an argument
X			   file to stdout - allows you to compress SFP's.
X			   undef if you don't got.  The -d option may be
X			   undocumented, but means decompress.  "-dc"
X			   is equivalent to zcat.  -dc appears to be
X			   in most versions of compress (eg: v3 & v4) */
X#define	COMPRESS	"/usr/lbin/compress -dc"
X
X/*	Some postscript printers don't accept control-D as job termination
X	(DEC scriptwriters for instance, or LAN-connected printers).  In that
X	case, define this macro.  Alternately, if you have a proper printer
X	manager that does this sort of stuff, define it too.
X	If your printer will take "stop", specify "-S" in psrofflib's
X	t2arg, and leave this undefined.
X */
X#undef	NOCONTROLD
X
X/*	define if you don't want your Postscript printer talking to you */
X#undef	NOCHATTER
X
X/*	The only advantage to commenting-out one of these is to make the
X	binary executable of troff2?? smaller.
X */
X
X/*	Basic drivers: */
X#define	PS	/* Postscript */
X#define	LJ	/* Laserjet - utils programs will not build with this undef'd */
X#define	DT	/* ditroff */
X#define	DIT	/* ditroff *front-end* */
X
X/*	Laserjet driver config: */
X#define	PK	/* enable PK font downloading (needs LJ) */
X
X#define	SFP	/* enable SFP incremental font downloading (needs PK).
X		   You can still use SFP's without this turned on, but
X		   you won't get incremental downloading */
X
X#define	PARTIAL	/* partial (not incremental) font downloading */
X
X#define	INCR	/* enable incremental font downloading (needs PARTIAL) */
X
X#define	MDLF	16	/* Max # downloaded fonts permitted by your laserjet
X			   per *page*.  16 is correct for HPLJ+ and most II's.
X			   IIP's are 32 I think.  Some newer ones have higher
X			   restrictions (don't put this too high even if
X			   your printer supports it, you may run out of
X			   memory) */
X
X#define	PRELOAD	0	/* set to number of LJ fonts permanently
X			   downloaded to printer.  The backend will
X			   make sure that you don't go over the number
X			   of fonts permitted by the printer */
X
X#define	DEBUG		/* Do you want the debugger in?  If you encounter
X			   problems and you want help from me, you'll have
X			   to have this turned on */
X
X#define	OPT		/* CAT code reorder and optimizer */
X
X#define	DEFPL  11	/* Default page length (11 inches).
X			   DO NOT change unless you absolutely HAVE to.
X			   You should only need to change this if you
X			   desire your printer to use something different
X			   as default.  If so, you'll HAVE to change
X			   your macro package to agree on the default - RT
X			   owners take note! (the man macros are wrong) */
X
X#define	DEFOFF 0.5	/* Default page offset.  DO NOT change unless you
X			   absolutely HAVE to.  You should only need this
X			   if: your vendor has buggered your macros to
X			   have a different default .po offset (Xenix),
X			   and you aren't using the macro adapter
X			   libraries that come with psroff (eg: you're
X			   using troff2ps directly).  See README/TROUBLE/
X			   psroff(1) (-O vs. -rO options) */
X
X#define	DEFYOFF   0	/* Default page vertical offset.  See README/TROUBLE/
X			   psroff(1) -Y options too */
X
X#define	INSPECIAL	/* enables ditroff graphics capability */
X
X#define	NSP	256	/* number of \(xx characters. */
X
X#define	NODECMD	"uuname -l" /* command to print on stdout the node name
X			   of your machine.  Use hostname on BSD-derived
X			   systems that don't have UUCP.  You can always
X			   use "echo <nodename>" if necessary */
X
X/*	Edit no more .... */
X
X#define	MAXDLFONTS (MDLF - PRELOAD)	/* # fonts troff2ps can download */
X
X/*	configuration verification */
X
X#if	defined(BSDHACK) && defined(FONT8)
X#include	"BSDHACK and FONT8 cannot be defined at the same time"
X#endif
X#if	defined(FONT4) && defined(FONT8)
X#include	"FONT4 and FONT8 cannot be defined at the same time"
X#endif
X
X#if	!defined(LJ) && defined(PK)
X#include	"Pointless to define PK without LJ"
X#endif
X
X#if	!defined(PK) && (defined(INCR) || defined(PARTIAL))
X#include	"Pointless to define INCR or PARTIAL without PK"
X#endif
X
X#if	defined(INCR) && !defined(PARTIAL)
X#include	"Don't support INCR without PARTIAL"
X#endif
X
X#if	defined(SFP) && !defined(PK)
X#include	"Can't define SFP without PK"
X#endif
X
X#include <stdio.h>
X#include <ctype.h>
X
X#ifdef BSD
X#include <strings.h>
X#define	strchr	index
X#define	strrchr	rindex
X#else
X#include <string.h>
X#endif
X
X#ifdef	BCOPY
X#define	memcpy(to, from, len)	bcopy(from, to, len)
X#define	clrarray(array, len)	bzero(array, len)
X#else
X#define	clrarray(array, len)	memset(array, '\0', len)
X#endif
X
X#define	ESC	0x80
X#define	FLASH	0x00
X#define	CONTROL	0x40
X#define	LEAD	0x60
X#define	SIZE	0x50
X
X#define	DOWN	0
X#define	UP	1
X#define	LOWER	2
X#define	UPPER	3
X#define	FORWARD	4
X#define	BACKWARD 5
X
X#define	TROFFRESOLUTION	432
X
X#define	SPECIAL		/* define if you want to support special directives */
X#define	FORM		/* define if you want the forms facility */
X
XFILE	*diagFile;
X
X#ifdef DEBUG
X#define	DBP(x)	if (diagFile) dprintf x
Xextern dprintf();
X#else
X#define	DBP(x)
X#endif
X
Xtypedef int(*FUNC)();
X
X#define	FNULL	(FUNC) NULL
X
Xstruct	troff2befont {
X	short	t2b_font;	/* font (troff nomenclature) S=don't change */
X	short	t2b_xc;		/* X-shift */
X	short	t2b_yc;		/* Y-shift */
X	short	t2b_scale;	/* point size scale adjust */
X	char 	*t2b_charseq;	/* character sequence - may include PS */
X};
X
Xstruct cattab {
X    char *ch_name;
X    char ch_set;
X    unsigned char ch_catidx;
X    unsigned char ch_wididx;
X    unsigned char ch_info;	/* used by some auxiliary programs */
X    char *ch_desc;
X};
X
Xstruct backend {
X    char	*bename;
X    FUNC	beprolog,
X		beepilog,
X		beputchar,
X		bepage,
X		befontsel,	/* special function F */
X		beoverlay,	/* special function O */
X		bepassthru,	/* special function P */
X		bexlat,		/* Xlate function */
X		bedraw;		/* Ditroff draw emulation routine */
X    struct troff2befont
X		*bestdfont,	/* standard font translate table */
X		*besymfont;	/* symbol font translate table */
X};
X
X#define	MAXFONTS	50
X
Xstruct fonttable {
X    char *tab[4];
X    long flags;
X#ifdef	INCR
X    struct downmaps *map;
X#endif
X#ifdef	OPT
X    char *widthtable;
X#endif
X};
X
X/*	Symbolic names for tab entries in fonttable	*/
X#define	troffName	tab[0]	/* troff name */
X#define	fontName	tab[1]	/* back-end name (if used) */
X#define	fontSeq		tab[2]	/* sequence to emit to shift to it
X				   lj builtin's mostly */
X
X/*	fontFlags is 16 characters that reflect the state of the font
X	at a particular pointsize - mainly for lj */
X
X/*	Use of flags:
X	s:	unloaded SFP
X	S:	loaded SFP
X	p:	unloaded PK
X	P:	loaded PK
X	n:	non-existant
X	b:	builtin.
X */
X#define	fontFlags	tab[3]
X
Xextern int symidx;		/* index of symbol font */
X
X#define	INTFONTS	10	/* maximum number of builtin fonts */
X
Xextern struct fonttable fonttable[MAXFONTS+1];
Xextern struct fonttable *xlatetable[INTFONTS];
X#define	EXTCHUNK	10
Xextern struct troff2befont *extchars;
Xextern struct cattab **spctab, **dittab;
Xextern struct cattab *extidx;
Xextern int extcount;
Xextern char *pstrailer;
X
Xstruct backend *be;
X#define	BNULL	(struct backend *) NULL
X
Xextern char *skipblanks();
X
X/*	Common Back-end definitions */
X
X#define	N	(unsigned char) (0xff)	/* Use standard font */
X#define	S	(unsigned char) (0xfe)	/* Use symbol font */
X#define	D	(unsigned char) (0xfd)	/* Draw macro exists - use string directly */
X#define	NTC	(unsigned char) (0xfc)	/* No font/Special flag */
X
X#define	NOC	NULL
X
Xextern int currentPage;
Xextern int pageoffset;
Xextern int pageyoffset;
Xextern int pagelength;
Xextern int pagePending;
X
X#ifdef	OPT
Xextern char *widthtables;
Xextern char *widthptr;
Xextern int optimize;
X#endif
X
Xextern int lastFont, lastPoints;
Xextern int lastYPos, lastXPos, specXPos, specYPos;
Xextern char *progname, *printer, *device;
Xextern char **prologs;
X
Xint metrics;
X#ifdef	DIT
Xint ditroff;
X#endif
X
XFILE *libopen();
X
X/*	Encoding format for generating width tables from font files */
X/*	Used by pk2ditwid and friends */
Xstruct enctab {
X    char *e_name;
X    char *e_seq;
X    char e_wid;
X};
X
X/*	Points in an inch */
X#define	POINT	72.27
X
X#define	min(a,b)	((a) < (b) ? (a) : (b))
X#define	max(a,b)	((a) > (b) ? (a) : (b))
X
X/* debug flags */
X#define	D_CAT	1	/* show cat interpretation machinery */
X#define	D_SPEC	2	/* show special directives */
X#define	D_CHAR	4	/* optimizer machinery */
X#define	D_FONT	8	/* font handling */
X#define	D_BEND	0x10	/* backend */
X#define	D_PK	0x20	/* PK font handling */
X#define	D_VERB	0x40	/* very verbose */
X#define	D_FLSH	0x80	/* flush after each fprintf */
X
Xextern int debug;
X
Xextern char username[];
X
Xextern char *mustmalloc();
X
Xextern char *version, *shortversion;
X
X#define	MAXPAGE	2000
X#ifdef	ALONE
X#undef	PARTIAL
X#undef	INCR
X#endif
END_OF_FILE
  if test 11537 -ne `wc -c <'defs.h'`; then
    echo shar: \"'defs.h'\" unpacked with wrong size!
  fi
  # end of 'defs.h'
fi
if test -f 'man/psroff.1.S' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/psroff.1.S'\"
else
  echo shar: Extracting \"'man/psroff.1.S'\" \(9407 characters\)
  sed "s/^X//" >'man/psroff.1.S' <<'END_OF_FILE'
X.\"Copyright 1988 by Chris Lewis 2.7 91/03/26
X.TH PSROFF %%MANEXT%% "Psroff %%T2VERSION%%"
X.SH NAME
Xpsroff,ljroff,xxroff,catconv \- troff to PostScript or other printers
X.SH SYNOPSIS
X.IB xx roff
X.BI "[\-T" xx "]"
X.BI "[\-d" ptr "]"
X.BI "[\-rL" length "]"
X.BI "[\-P" prologs "]"
X.BI "[\-D" deb "]"
X[\-X] [\-M] [\-F]
X.BI "[\-R" nn "]"
X.BI "[\-O" off "]"
X.BI "[\-Y" off "]"
X.BI [ troffopts ]
Xfiles ...
X.sp
X.I "troff filters"
X|
X.B %%LIBDIR%%/catconv
X| psroff ...
X.SH DESCRIPTION
X.I Psroff
Xis functionally equivalent for
X.I troff
Xfor printing on PostScript or HP Laserjet printers or via ditroff back-ends.
X.I Troffopts
Xcan be any of the normal
X.I troff
Xarguments, in particular \-m directives for specifying macro package.
XNote that the semantics of "\-t" are changed - it means send the Postscript
X(or HP Laserjet) output to stdout rather than the printer.
X.PP
XMost of the options you shouldn't need to use, except for
X.IR troffopts ,
Xand are for special (non-default)
Xbehaviours:
X.PP
XThe ``\-X'' option does a ``set \-x'' for debugging the
X.I psroff
Xshell script.
XThe ``\-Dopts'' option passes the ``\-Dopts'' debugging option through to
X.IR troff2ps .
XThe ``\-M'' option turns on printer metrics (if supported by the driver).
XThe ``\-P'' options can be specified as many times as you want and are
Xpassed through as special directives to the backend before the output
Xpages start (see
X.IR troff2ps (%%MANEXT%%)).
XThe ``\-dptr'' option supplies ``ptr'' as the physical printer destination.
X(analogous to ``\-d'' in UNIX System V lp).
XThe ``\-Rnn'' option is passed to
X.I troff2ps
Xand will set the resolution of
Xthe generated output (ditroff output only).
XThe ``\-F'' option runs troff without
X.RI troff2 xx
Xso that you can see troff's error messages.
X.PP
XNote that \-m directives are parsed by
X.I psroff
Xitself, not
X.IR troff ,
Xand
Xmust be invoked *after* \-T if \-T is used.
X.PP
X.I Psroff
Xcan be made to generate several different printer output formats.
XIf the environment variable PSROFF is set, it is used.
XOtherwise, it looks at the characters
Xprior to "roff" in the name it was invoked by.
XThus, you can link "psroff" to "ljroff" - invocation of the latter will
Xgenerate LaserJet codes.
XAdditionally, you can override this by specifying
Xthe
X.RI \-T xx
Xoption, where
X.I xx
Xwill select which printer codes to generate.
X.PP
XAs shipped, the
X.I psroff
X.RI \-T xx
Xunderstands ``ps'' (postscript), ``tp'' (ditroff\(->tpscript also postscript),
X``jt'' (ditroff\(->jetroff (HP PCL)),
X``lj'' (HP PCL),
Xand
X``dt'' (Ditroff output, no printer).
XHowever, this list may be different at your site - see
Xthe
X.I %%LIBDIR%%/lib/psrofflib
Xfile.
X.PP
X.I Psroff
Xinvokes
X.I troff
Xto do the document formatting, then sends the output
Xto
X.I troff2ps
Xto do the generation of the correct printer codes.
X.PP
XSince
X.I troff2ps
Xrequires that it knows the page length, the "\-rL" option should be
Xused (see the documentation for MM and
X.I troff2ps
Xfor more details).
X.PP
XThe "\-O" option allows you to specify a physical offset from the
Xleft margin of the page.
XNormal troff prohibits the total page offset plus line length from
Xbeing greater than 7.54 inches, which means that it would be impossible
Xto centre a 7.54 inch line on 8.5 inch wide paper.
XThe default \-O is .5 inch (specified as .5i), which allows you to
Xcentre a 7.5 inch line with a zero troff offset (.po directive).
XThe .5 inch default was originally a hardcoded offset in
X.IR troff2ps .
XThe macro adapters have been tuned to centre the default line length
Xin a 8.5 inch page.
XThe value for the "\-O" option can take any form allowed by the "\-rL"
Xoption in
X.IR troffps .
XThis is not implemented as "\-rO", because troff itself isn't supposed
Xto know about it.
XThe real line offset on a sheet of paper is the sum of the \-O and
Xtroff page offset (.po directive).
X.PP
XThe "\-Y" option allows you to specify a vertical page offset,
Xsimilar to "\-O" for horizontal.
X.SH "DITROFF EMULATION"
XWhen used with CAT troff,
X.I psroff
Xemulates a number of ditroff functions.
XSuch as ``.sy''.
XHowever, some of these extensions need a bit more help.
XIn order to use the CAT troff emulation of extended ditroff characters,
Xdrawing commands, or use with psfig (\eX'...') directives, you have to use
X``catconv''.
X.PP
X.I Catconv
Xis a Perl script that converts certain ditroff constructs into special
Xrequests that CAT troff can be kludged into understanding, or at least,
Xpassing it off to
X.I troff2ps
Xto interpret.
X.I Catconv
Xis a pure filter, and should be used thusly:
X.RS
X.nf
Xfilters | catconv | psroff
X.fi
X.RE
XAny troff input containing ``\eD'' or ``\eX'' or the extended character
Xset (``\e(xx'') must be passed through catconv, otherwise, they won't work.
X.PP
XPsroff and troff2ps support the following drawing codes:
X.RS
X.nf
X.ta 1.5i
X\eD'l dx dy'	Draw line from here to here+(dx,dy)
X\eD'c d'	Draw circle of diameter d, left side here
X\eD'C d'	Ditto, filled
X\eD'e x y'	Draw ellipse, diameter (x,y)
X\eD'E x y'	Ditto, filled
X\eD'a dx1 dy1 dx2 dy2'	Arc counterclockwise, start here.
X	centre is dx1,dy1, end is dx2,dy2
X\eD'~ x y x y ...'	Spline to x,y then to x,y ...
X\eD'p x y x y ...'	Polygon to x,y, then x,y ... then to origin
X\eD'P x y x y ...'	Ditto
X\eD't x'	Set line thickness to x pixels
X\eD'f d'	Set fill to d (0..1000, 0 is black)
X.fi
X.RE
X.PP
X``Standard'' DWB ditroff does not implement C, E, p, P, t or f.
XBerkeley ditroff (including RS/6000 troff) and groff implement the whole
Xlist.
XDWB 3.1 might implement the whole list.
X.SH MACROS
XIncluded with the
X.I psroff
Xpackage is a set of macros called
X.IR tmac.t2 .
XThis is a set of extensions to and definitions for MM that we find useful.
X.PP
X.I psroff
Xcomes with a series of macro adapters designed to make it work
Xwith the least amount of grief with various macro packages.
XIn order for this to work, whenever you specify the
X.BI \-m macro
Xoption,
X.I psroff
Xattempts to find a set of adapters for the specified macro package.
XThe search path is as follows:
X.BI %%LIBDIR%%/adapters/mac. type /tmac. macro ,
X.BI %%LIBDIR%%/adapters/tmac. macro ,
X.BI %%T2DIR%%/tmac. macro ,
Xand finally
X.BI %%RTMACDIR%%/tmac. macro .
XWhere
X.I type
Xis the printer type (eg: ``ps'') and
X.I macro
Xis the macros you requested (eg: ``m'' for a request of ``\-mm'').
XOnly the first
X.BR tmac. macro
Xfile found is used.
X.PP
XThe first two directories contain files with the following
Xform:
X.RS
X.nf
X\&.so %%LIBDIR%%/adapters/common.pre
Xmacro specific prolog customization if necessary
X\&.so <real macro package>
Xmacro specific epilog customization if necessary
X\&.so %%LIBDIR%%/adapters/common.post
X.fi
X.RE
X.PP
XThe intent is for
X.BI adapters/mac. type /tmac. macro
Xfiles to be adapters where the modifications have to be based on
Xprinter type,
Xand
X.BI adapters/tmac. macro
Xwhere the modifications are independent of the printer type.
X.PP
X.IR Psroff,
Xas shipped comes with only printer independent adapters which have
Xthe following customizations in
X.BR common.pre :
Xturn off ligatures,
Xreload R, I, B, S font width tables,
Xdefine ``.sR'' macro,
Xand redefine ``.fp" directive to call both the built-in troff function ``.fp''
Xand ``.sR''.
X.B common.post
Xmerely contains a disabling of ligatures (again).
XThe macro-specific customization (as present) is simply the removal of
Xcut marks.
X.SH FILES
X.if t .ta 2.5i
X.if n .ta 3.5i
X%%LIBDIR%%	Troff2ps library directory
X.br
X%%LIBDIR%%/adapters/mac.*	printer specific macro adapter directories
X.br
X%%LIBDIR%%/adapters/tmac.*	non-printer-specific macro adapters
X.br
X%%T2DIR%%/tmac.*	Psroff-originated macros
X.br
X%%LIBDIR%%/lib/psroff.lib	shell script configuration
X.br
X%%LIBDIR%%/lib/*	configuration files and default inclusions.
Xetc.
X.PP
XNote that
X.BR psroff and troff2ps
Xwill search in the current directory first for library files, and then ./lib,
Xand then %%LIBDIR%%/lib.
X.SH "BUGS and FEATURES"
XOld-fashioned CAT troff doesn't have a mechanism for passing arbitrary
Xcommands to the CAT - eg: overlays, and physical font mounting etc.
XIn order to support these things, a macro ".sR" was invented that
Xpasses special directives to the back end by means of a magic pseudo
XCAT code 'M', followed by an ASCII string containing the directive.
XUnfortunately, the only way to get that to the back end from troff
Xthat I have found so far is to embed the 'M<string>' in a ``.tm'' troff
Xdirective.
XThe ``.tm'' puts it's string to stderr, so psroff has been modified to
Xmerge the stdout (CAT codes using \-t option to troff) and stderr (.tm
Xdirectives) together.
X.PP
XUnfortunately, this means that you don't get to see troff-generated
Xerrors except possibly as "illegal flash" errors from
X.IR troff2ps ,
Xor varying
Xdegrees of extreme garbage on the printer.
XIf you encounter mangled output, try running
Xpsroff, with the ``\-F'' option.
XThen you will see troff's stderr.
X.PP
XThe troff primitive ".tm" is renamed to ".tM" when using one of the
Xsupplied macro adapters.
X".tm" is now a macro which calls ".tM" with the appropriate arguments
Xto pass the string straight through the stderr of
X.IR troff2ps .
XHence, traditional index macro handling and macro package errors will
Xbe visible on the stderr of psroff.
X.PP
XAnother idiosyncrasy with MM is that if any ".sR" command is invoked
Xbefore use of the ".MT" macro, the ".MT" macro will not work correctly.
X(this includes ".fp"!).
XThis is why the
X.B \-P
Xoption was invented.
X.SH "SEE ALSO"
Xtroff(1), troff2ps(%%MANEXT%%), mm(7?), cat(5).
X.SH AUTHOR
XWritten by Chris Lewis
END_OF_FILE
  if test 9407 -ne `wc -c <'man/psroff.1.S'`; then
    echo shar: \"'man/psroff.1.S'\" unpacked with wrong size!
  fi
  # end of 'man/psroff.1.S'
fi
if test -f 'utils/calcfonts.S' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/calcfonts.S'\"
else
  echo shar: Extracting \"'utils/calcfonts.S'\" \(10193 characters\)
  sed "s/^X//" >'utils/calcfonts.S' <<'END_OF_FILE'
X#!/usr/bin/perl
Xeval "exec /usr/bin/perl -S $0 $*"
X	if $running_under_some_shell;
X#	Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991 Chris Lewis
X#		All Rights Reserved
X#
X#    See the LICENSE file for a full description of the restrictions
X#    under which this software is provided.
X#
X#Copyright 1991/02/20 Chris Lewis 2.2
X
X#	Set to path of sfp2pk if you have it, otherwise NULL.
X$sfp2pk	= '';
X#	Threshold for acceptable point sizes (default 10%).
X$thresh = 1.1;
X#	Place to build new fonts
X$newfonts = "/tmp/newfonts";
X#	You might also want to adjust the "do gen"'s at the end.
X
X#	Don't touch from here on.
X$basedir = `pwd`;
Xchop($basedir);
X@pointlist = (6, 7, 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 28, 36);
X$verbose = 0;
X$dirlist = '';
X#	If non-null, each font matching this pattern not needed to
X#	build a particular size will be DELETED.
X$discardpat = "";
X
X$oldname = '';
X
Xsub discard {
X    local($file) = $_[0];
X    if ($discard && $file =~ $discardpat) {
X	unlink($file);
X	printf DISCARD ("deleted %s\n", $file);
X    }
X}
X
Xsub gen {
X    local($outf, $engname, $escape, $outtype) = ($_[0], $_[1], $_[2], $_[3]);
X    if ($sfontonly && $outf ne 'S') {
X	return;
X    }
X    @namelist = @_;
X    shift(namelist);
X    shift(namelist);
X    shift(namelist);
X    shift(namelist);
X    unlink("$outf.build");
X    foreach $pointsize (@pointlist) {
X	$found[$pointsize] = 0;
X	$missing = '';
X	$cmdline = "$basedir/pk2sfp -m \\\n";
X	$usedfonts = '';
X	$looklist = '';
X	for ($i = 0; $i <= $#namelist; $i++) {
X	    ($rnamelist, $map) = split(/\//, $namelist[$i]);
X	    $best = '';
X	    $bestratio = 1000;
X	    $tmplist = '';
X
X	    @alternates = split(/,/, $rnamelist);
X	    foreach $rname (@alternates) {
X		$ratio = $ratios{$rname, $pointsize};
X		if (!$ratio) {
X		    $looked = "$rname(notfound)";
X		} else {
X		    ($np, $size) = split(/ /, $table{$rname, $pointsize});
X		    #$looked = sprintf("$rname$np.$size(%.2f)", $ratio);
X		    $looked = sprintf("%s(%.2f)", $path{$rname, $pointsize},
X			$ratio);
X		    if ($ratio && $ratio <= $bestratio) {
X			$best = $rname;
X			$bestratio = $ratio;
X			$bestentry = $looked;
X		    }
X		}
X		$looklist .= "$looked\n";
X		$tmplist .= "$looked ";
X	    }
X	    if ($best && $bestratio <= $thresh) {
X		$usedfonts .= "$bestentry\n";
X		$tdir = $path{$best, $pointsize};
X		if (!$map) {
X		    $map = $best;
X		    if (! -r "$md/$map.$outtype") {
X			$map = $alternates[0];
X		    }
X		}
X		if (! -r "$md/$map.$outtype") {
X		    $missing .= sprintf("Map file $map (for entry %s)\n",
X			$namelist[$i]);
X		}
X		$cmdline .= "\t$md/$map.$outtype $tdir\\\n";
X	    } else {
X		$missing .= "($tmplist) ";
X	    }
X	}
X	if ($missing) {
X	    chop($missing);
X	    printf STDERR ("Missing $missing, won't generate $outf at $pointsize\n");
X	    printf STDERR ("Acceptable ones: $usedfonts\n");
X	} else {
X	    $cmdline .= "\t\t> t";
X	    $found[$pointsize] = 1;
X	    chop($usedfonts);
X	    printf STDERR ("Generating $outf at $pointsize using $usedfonts\n");
X	    if (system($cmdline)) {
X		printf STDERR ("failed ($!) $cmdline\n");
X		exit(1);
X	    }
X	    if (system("$basedir/pk2sfp t > $newfonts/$outf.$pointsize.sfp")) {
X		printf STDERR ("pk2sfp sort to build $outf.$pointsize.sfp failed\n");
X		exit(1);
X	    }
X	    unlink('t');
X	    if ($sfp2pk) {
X		if (system("$sfp2pk < $newfonts/$outf.$pointsize.sfp " .
X		    "> $newfonts/$outf.$pointsize.pk")) {
X		    printf STDERR ("sfp2pk < $outf.$pointsize.sfp failed\n");
X		    exit(1);
X		}
X		unlink("$newfonts/$outf.$pointsize.sfp");
X	    }
X	    close(GEN);
X	}
X    }
X    open(TABLE, ">>lj.fonts.new");
X# The second field can be truncated, but none of the others.
X#HI Helvetica-Italic \033(8U\033(s1p1s-3b04T nnnnpnnnnnnnnnn
X#HB Helvetica-Bold   \033(8U\033(s1p0s03b04T nnnnnnnnnnnnnnn
X    printf TABLE ("%-2s %-16.16s %-23s ", $outf, $engname, $escape);
X    foreach $pointsize (@pointlist) {
X	if ($found[$pointsize]) {
X	    if ($sfp2pk) {
X		printf TABLE 'p';
X	    } else {
X		printf TABLE 's';
X	    }
X	} else {
X	    printf TABLE 'n';
X	}
X    }
X    printf TABLE "\n";
X    close(TABLE);
X}
Xsub findcomplete {
X    foreach $name (sort keys(listofnames)) {
X	$complete{$name} = 0;
X	foreach $p (@pointlist) {
X	    if ($ratios{$name, $p} <= $thresh) {
X		$complete{$name}++;
X		next;
X	    }
X	}
X    }
X    foreach $name (sort keys(listofnames)) {
X	printf STDERR ("I have %d reasonable sizes of %s\n", $complete{$name},
X	    $name);
X    }
X}
X
X
Xsub dumplist {
X    foreach $name (sort keys(listofnames)) {
X	foreach $p (@pointlist) {
X	    ($rp, $rs) = split(/ /, $table{$name, $p});
X	    printf STDERR ("%-8s %4d %4d %4d %4.4g%% %s\n",
X		$name, $p, $rp, $rs, (1 - $ratios{$name,$p}) * 100,
X		$path{$name, $p});
X	}
X    }
X}
X
Xwhile($arg = shift(@ARGV)) {
X    if ($arg eq '-v') {
X	$verbose = 1;
X    } elsif ($arg =~ /-S/) {
X	$sfontonly = 1;
X    } elsif ($arg =~ /^-D(.*)/) {
X	$basedir = $1;
X    } elsif ($arg =~ /^-s(.*)/) {
X	$sfp2pk = $1;
X    } elsif ($arg =~ /^-f(.*)/) {
X	$newfonts = $1;
X    } elsif ($arg !~ /^-/) {
X	if (-d $arg) {
X	    $dirlist = "$dirlist $arg";
X	} else {
X	    printf STDERR ("No directory %s, skipping\n", $arg);
X	}
X    } else {
X	printf STDERR ("calcfonts: bad option %s\n", $arg);
X	exit(1);
X    }
X}
X
Xif ($sfp2pk && ! -x $sfp2pk) {
X    printf STDERR
X	("sfp2pk ($sfp2pk) not found - will generate SFP's not PK's\n");
X    $sfp2pk = '';
X}
X
Xif (!$dirlist) {
X    printf STDERR ("No directories to search - aborting\n");
X    exit(0);
X}
X
X$md = "$basedir/maps";
X$dirlist = "$basedir/fonts $dirlist";
X
Xunlink("$basedir/lj.fonts.new");
Xunlink("discard");
Xopen(DISCARD, ">discard");
X
X$cmdline =
X    "find $dirlist -type f '(' -name '*pk' -o -name '*.sfp' ')' -print";
Xprintf STDERR ("Commandline: $cmdline\n");
Xopen(INLIST, "$cmdline|") || die "Cannot start $cmdline\n";
X
Xwhile(<INLIST>) {
X    chop;
X    #/([a-z]+)([0-9]+)\s*:\s*(.*)/;
X    $path = $_;
X    if (/^\S+\/([a-z]+)([0-9]+)\.([0-9]+)pk/) {
X	$name = $1;
X	$points = $2;
X	$size = $3;
X    } elsif (/^\S+\/[a-z]+([0-9]+)\/([a-z]+)([0-9]+)\.pk/) {
X	$size = $1;
X	$name = $2;
X	$points = $3;
X    } elsif (/^\S+\/([a-z]+)([0-9]+)\.pk/) {
X	$size = 300;
X	$name = $1;
X	$points = $2;
X    } elsif (/^\S+\/([a-z]+)([0-9]+)\.sfp/) {
X	$size = 300;
X	$name = $1;
X	$points = $2;
X    } else {
X	printf STDERR ("Skipping %s\n", $path);
X	do discard($path);
X	next;
X    }
X    $listofnames{$name} = 1;
X    $actpoints = $points * $size / 300;
X#printf("path: $path, name: $name, points: $points");
X#printf(" size: $size, actpoints: $actpoints\n");
X    $foundany = 0;
X    foreach $needpoint (@pointlist) {
X	$ratio = $actpoints / $needpoint;
X	if ($ratio < 1) {
X	    $ratio = 1 / $ratio;
X	}
X#printf("ratio: (to get %d) %.2f\n", $needpoint, $ratio);
X	if ($ratios{$name, $needpoint} eq '') {
X	    $ratios{$name, $needpoint} = 100;
X	}
X
X	if ($ratio <= $ratios{$name, $needpoint}) {
X	    $ratios{$name, $needpoint} = $ratio;
X	    $table{$name, $needpoint} = "$points $size";
X	    $refcnt{$path}++;
X	    if ($path{$name, $needpoint}) {
X		$opath = $path{$name, $needpoint};
X		$refcnt{$opath}--;
X		if ($refcnt{$opath} == 0) {
X		    printf DISCARD "%s\n", $opath;
X		    do discard($opath);
X		}
X	    }
X	    $path{$name, $needpoint} = $path;
X	    $foundany++;
X	}
X    }
X    if (!$foundany) {
X	do discard($path);
X	printf DISCARD "%s\n", $path;
X    }
X}
X
Xif ($verbose) {
X    do findcomplete();
X    do dumplist();
X}
X
X#	Example of do gen call:
X# do gen(
X#	'R',		Cat Troff name
X#	'Times-Roman',	English name (useful only in debugging)
X#	'\033(8U\033(s1p0s00b05T', Escape to emit if not present or builtin
X#	'ROMAN8',	map suffix to use.
X#	'cmr,jmr',	a font entry
X#	'cmsy,jmsy',	a font entry
X#	'cmti,jmti',	a font entry
X#	'cmtrf,jmtrf');	a font entry
X#
X# There can be any number of font entries, and it is of the following
X# generalized form:
X#
X#	<font>,<font>,<font>..../<map prefix>
X#
X#	Where: the list of fonts is a comma-separated list of
X#	PK/SFP font name prefixes of fonts that would be acceptable
X#	for merging with the other font entries to build the CAT font.
X#	A font with that prefix closest to each desired point size will
X#	be the one selected.  In case of ties, the later one wins in the
X#	list.  The map prefix (along with the suffix) is used to select
X#	which merge control file to use.  See pk2sfp and utils/maps.
X#	If omitted, the map prefix will default to the font prefix that
X#	it used if present.  If not present, it will default to the first
X#	font prefix.
X#	See LASERFONTS if you want more information on what the heck this
X#	junk is doing.
X
Xdo gen('R', 'Times-Roman', '\033(8U\033(s1p0s00b05T', 'ROMAN8',
X    'cmr,jmr', 'cmsy,jmsy', 'cmti,jmti', 'cmtrf,jmtrf');
X
Xdo gen('I', 'Times-Italic', '\033(8U\033(s1p1s-3b05T', 'ROMAN8',
X    'cmsl,jmsl/cmr', 'cmsy,jmsy', 'cmti,jmti', 'cmtrf,jmtrf');
X
Xdo gen('B', 'Times-Bold', '\033(8U\033(s1p0s03b05T', 'ROMAN8',
X    'cmbx,jmbx/cmr', 'cmsy,jmsy', 'cmti,jmti', 'cmtrf,jmtrf');
X
X#	Shipped with psroff (as PK's):
Xdo gen('S', 'Symbol', '\033(8M\033(s1p0s00b05T', 'MATH8',
X    'cmr,jmr', 'cmsy,jmsy', 'cmmi,jmmi', 'cmtrf,jmtrf');
X
Xdo gen('C', 'Courier', '\033(8U\033(s0p0s00b03T', 'ROMAN8',
X    'cmtt,cmvtt,jmtt/cmtt', 'cmsy,jmsy', 'cmti,jmti', 'cmtrf,jmtrf');
X
Xdo gen('CI', 'Courier-Italic', '\033(8U\033(s1p1s-3b03T', 'ROMAN8',
X    'cmit,cmsltt,jmit,jmsltt/cmtt', 'cmsy,jmsy', 'cmti,jmti', 'cmtrf,jmtrf');
X
Xdo gen('H', 'Helvetica', '\033(8U\033(s1p0s00b04T', 'ROMAN8',
X    'cmss,lcmss,jmss/cmr', 'cmsy,jmsy', 'cmti,jmti', 'cmtrf,jmtrf');
X
Xdo gen('HI', 'Helvetica-Italic', '\033(8U\033(s1p1s-3b04T', 'ROMAN8',
X    'cmssi,lcmssi,jmssi/cmr', 'cmsy,jmsy', 'cmti,jmti', 'cmtrf,jmtrf');
X
Xdo gen('HB', 'Helvetica-Bold', '\033(8U\033(s1p0s03b04T', 'ROMAN8',
X    'cmssb,lcmssb,jmssbx/cmr', 'cmsy,jmsy', 'cmti,jmti', 'cmtrf,jmtrf');
X
Xdo gen('E', 'English', '\033(8U\033(s1p0s00b05T', 'ROMAN8',
X    'eufm/alnum', 'cmr', 'cmsy,jmsy', 'cmti,jmti', 'cmtrf,jmtrf');
X
Xdo gen('EB', 'English-Bold', '\033(8U\033(s1p0s00b05T', 'ROMAN8',
X    'eufb/alnum', 'cmr', 'cmsy,jmsy', 'cmti,jmti', 'cmtrf,jmtrf');
X
X#"CI", "Courier-Italic", "\033(8U\033(s0p1s-3b03T", "ROMAN8",
X#"CB", "Courier-Bold", "\033(8U\033(s0p0s03b03T", "ROMAN8",
X#"L", "LinePrinter", "\033(8U\033(s0p0s00b00T", "ROMAN8",
X#"LI", "LinePrinter-Ital", "\033(8U\033(s0p1s-3b00T", "ROMAN8",
X#"LB", "LinePrinter-Bold", "\033(8U\033(s0p0s03b00T", "ROMAN8",
END_OF_FILE
  if test 10193 -ne `wc -c <'utils/calcfonts.S'`; then
    echo shar: \"'utils/calcfonts.S'\" unpacked with wrong size!
  fi
  # end of 'utils/calcfonts.S'
fi
if test -f 'widths/dit2catwid.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'widths/dit2catwid.c'\"
else
  echo shar: Extracting \"'widths/dit2catwid.c'\" \(10841 characters\)
  sed "s/^X//" >'widths/dit2catwid.c' <<'END_OF_FILE'
X/*
X	Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991 Chris Lewis
X		All Rights Reserved
X
X    See the LICENSE file for a full description of restrictions under which
X    this software is provided.
X
X    Function: 	converts ditroff tables to CAT troff.
X */
X
X#ifndef	lint
Xstatic char SCCSID[] =
X    "@(#)dit2catwid.c 2.7 Copyright 91/02/20 09:33:05 Chris Lewis";
X#endif
X
X#include <stdio.h>
X#include "../defs.h"
X#include <ctype.h>
X
X#ifndef	ASCIIWIDTHS
X
X#ifndef	FONTDIR
X#define	FONTDIR	"/usr/lib/font"
X#endif
X
X#ifndef	HEADERSIZE
X#	ifdef COFF
X#		include <aouthdr.h>
X#		include <filehdr.h>
X#		include <scnhdr.h>
X#		include <ldfcn.h>
X#		include <reloc.h>
X#		define H1 (sizeof (struct filehdr) + sizeof (struct aouthdr))
X#		define H2 (sizeof (struct scnhdr) + sizeof (struct reloc))
X#		define HEADERSIZE (H1 + H2)
X#	else
X#		include <a.out.h>
X#		define HEADERSIZE (sizeof (struct exec))
X#	endif
X#endif
X
X#endif
X
Xint res = 300;
Xint unitwid = 10;
Xint symfont = 0;
Xint verbose = 0;
Xint genc = 0;
Xint headersize = -1;
Xint ext = 0;
XFILE *extensions;
X
X#define	TROFFUWID	6
X
X#ifdef	DEBUG
X#undef	DEBUG
X#endif
X
XFILE *mustopen();
Xchar *mustmalloc();
X
Xextern struct cattab tabN[], tabS[];
X
Xchar *progname;
X
Xmain(argc, argv)
Xint argc; char **argv; {
X    extern char *optarg;
X    extern int optind;
X    char *p;
X    int c;
X
X    FILE *in1, *in2, *out;
X    char *fin1, *fin2, *fout;
X
X    progname = argv[0];
X
X    while ((c = getopt(argc, argv, "evsr:u:chH:")) != EOF)
X	switch(c) {
X	    case 'h':
X#ifdef	ASCIIWIDTHS
X		printf("ascii\n");
X#else
X		printf("%d\n", HEADERSIZE);
X#endif
X		exit(0);
X		break;
X	    case 'H':
X		headersize = atoi(optarg);
X		break;
X	    case 's':
X		symfont = 1;
X		break;
X	    case 'r':
X		res = atoi(optarg);
X		break;
X	    case 'u':
X		unitwid = atoi(optarg);
X		break;
X	    case 'e':
X		ext = 1;
X		break;
X	    case 'v':
X		verbose = 1;
X		break;
X	    case 'c':
X		genc = 1;
X		break;
X	    default:
X		usage();
X	}
X    if (optind != argc - 3) {
X	usage();
X    }
X    in1 = mustopen(fin1 = argv[optind], "r");
X    in2 = mustopen(fin2 = argv[optind+1], "r");
X    out = mustopen(fout = argv[optind+2], "w");
X
X    process(in1, fin1);
X    if (ext) {
X	p = mustmalloc(strlen(argv[optind+2]+15), "extension file");
X	strcpy(p, argv[optind+2]);
X	strcat(p, ".ext");
X	extensions = mustopen(p, "w");
X    }
X    process(in2, fin2);
X    if (ext)
X	fclose(extensions);
X
X    sort(tabS);
X    sort(tabN);
X
X    if (genc) {
X	if (symfont)
X	    genccode(tabS, out, fout, "Symbol character set");
X	else
X	    genccode(tabN, out, fout, "Normal character set");
X    } else {
X	if (symfont)
X	    output(tabS, out, fout, "Symbol character set");
X	else
X	    output(tabN, out, fout, "Normal character set");
X    }
X    fclose(in1);
X    fclose(in2);
X    fclose(out);
X    exit(0);
X}
X
Xgenccode(symset, f, file, type)
XFILE *f;
Xstruct cattab *symset;
Xchar *type, *file; {
X    int i, j;
X
X    fprintf(f, "/* %s */\n", type);
X    fprintf(f, "char ftXX[224] = {\n");
X
X    for (i = 0, j = 0; i < 224; i++) {
X	/* skip to next valid CAT char */
X	while(symset[j].ch_name && !symset[j].ch_name[0])
X	    j++;
X
X	/* not the right position yet */
X	if (!symset[j].ch_name || i < symset[j].ch_wididx) {
X	    gencline(f, i, 0, NULL);
X	    continue;
X	}
X
X	if (symset[j].ch_wididx != i) {
X	    fprintf(stderr, "GFNTTAB: index mismatch: (%d/%d)\n",
X		i, j);
X	    exit(1);
X	}
X
X	if (!(symset[j].ch_info&0x3f)) {
X	    printf("INFO: No width for %s (index %d, file %s)\n",
X		symset[j].ch_name, symset[j].ch_wididx, file);
X	    gencline(f, i, symset[0].ch_info, symset[j].ch_name);
X	} else
X	    gencline(f, i, symset[j].ch_info, symset[j].ch_name);
X	j++;
X    }
X
X    fprintf(f, "};\n");
X    dumpset(symset, "After C Dump");
X
X    if (symset[j].ch_name) {
X	fprintf(stderr, "GFNTTAB: table error (too long: %d left: %s)\n",
X	    j, symset[j].ch_name);
X	exit(1);
X    }
X}
X
Xgencline(file, index, width, name)
XFILE *file; int index, width; char *name; {
X    int w = width&077;
X    int k = width&0300;
X    fprintf(file, "\t%2d", w);
X    if (k)
X	fprintf(file, "+0%03o", k);
X    if (index != 223)
X	fprintf(file, ",");
X    if (name && *name) {
X	if (!k)
X	    fprintf(file, "\t");
X	fprintf(file, "\t/* %s */\n", name);
X    } else
X	fprintf(file, "\n");
X}
X
Xoutput(symset, f, file, type)
XFILE *f;
Xstruct cattab *symset;
Xchar *type, *file; {
X    int i, j;
X
X#ifdef	ASCIIWIDTHS
X#define	EMITWID(v,f)	fprintf(f, "%d\n", v)
X#else
X#define	EMITWID(v,f)	fputc(v, f)
X
X    FILE *of = (FILE *) NULL;
X    /* If headersize != 0 AND there's a FONTDIR/ftR, output
X       the first headersize bytes of it, then the new width table,
X       then the trailing bytes of FONTDIR/ftR.  If there's
X       no FONTDIR/ftR, we just prepend headersize 0's.
X       The reason for this is that some troff's insist on valid
X       headers.
X    */
X
X    if (headersize == -1)
X	headersize = HEADERSIZE;
X
X    if (headersize != 0) {
X	char buf[128];
X	sprintf(buf, "%s/%s", FONTDIR, "ftR");
X	if (of = fopen(buf, "r")) {
X	    for (i = 0; i < headersize; i++)
X		fputc(fgetc(of), f);
X	    for (i = 0; i < 224; i++)
X		fgetc(of);
X	    if (feof(of)) {
X		fclose(of);
X		of = (FILE *) NULL;
X	    }
X	} else {
X	    for (i = 0; i < headersize; i++)
X		fputc('\0', f);
X	}
X    }
X#endif
X
X    for (i = 0, j = 0; i < 224; i++) {
X
X	/* skip to next valid CAT char */
X	while(symset[j].ch_name && !symset[j].ch_name[0])
X	    j++;
X
X	/* not the right position yet */
X	if (!symset[j].ch_name || i < symset[j].ch_wididx) {
X	    EMITWID('\0', f);
X	    continue;
X	}
X
X	if (symset[j].ch_wididx != i) {
X	    fprintf(stderr, "GFNTTAB: index mismatch: (%d/%d)\n",
X		i, j);
X	    exit(1);
X	}
X
X	if (!(symset[j].ch_info&0x3f)) {
X	    printf("INFO: No width for %s (index %d, file %s)\n",
X		symset[j].ch_name, symset[j].ch_wididx, file);
X	    EMITWID(symset[0].ch_info, f);
X	} else
X	    EMITWID(symset[j].ch_info, f);
X	j++;
X    }
X
X#ifndef	ASCIIWIDTHS
X    if (of) {
X	while((i = fgetc(of)) != EOF)
X	    fputc(i, f);
X	fclose(of);
X    }
X#endif
X
X    dumpset(symset, "After CAT dump");
X
X    if (symset[j].ch_name) {
X	fprintf(stderr, "GFNTTAB: table error (too long: %d left: %s)\n",
X	    j, symset[j].ch_name);
X	exit(1);
X    }
X}
X
Xdumpset(symset, str)
Xstruct cattab *symset;
Xchar *str; {
X    int i, j;
X    if (verbose) {
X	printf("\n%s:\n", str);
X	for (i = 0; symset[i].ch_name; i++) {
X	    if (strlen(symset[i].ch_name) == 0)
X		continue;
X	    printf(" %4d", symset[i].ch_wididx);
X	    printf("	%d+%03o,",
X		symset[i].ch_info & 077, symset[i].ch_info & 0300);
X	    if (symset[i].ch_name)
X		printf ("	/* \"%s\" */\n", symset[i].ch_name);
X	    else
X		printf ("\n");
X	}
X    }
X}
X
Xusage() {
X    fprintf(stderr, "usage: %s [-rres] [-uunitwid] normfont symfont output\n",
X	progname);
X    exit(1);
X}
X
Xchar *
Xmustmalloc(n)
Xregister int n; {
X    register char *p;
X    extern char *malloc();
X    p = malloc(n);
X    if (!p) {
X	fprintf(stderr, "%s: cannot alloc %d bytes\n", progname, n);
X	exit(1);
X    } else
X	return(p);
X}
X
XFILE *
Xmustopen(f, mode)
Xchar *f, *mode; {
X    FILE *desc;
X    if ((desc = fopen(f, mode)) == NULL) {
X	fprintf(stderr, "%s: cannot open file %s mode %s\n", progname, f, mode);
X	exit(1);
X    } else
X	return(desc);
X}
X
Xchar *gettoken();
X
Xprocess(f, filename)
XFILE *f;
Xchar *filename; {
X    char *sv;
X    char buffer[512];
X    char *tok;
X    int commentsok = 1;
X    int widval, oldwidval;
X    int eval, oldeval;
X    while(fgets(buffer, sizeof(buffer), f) && buffer[0] == '#');
X
X    if (feof(f))	/* NULL file */
X	return;
X
X    do {
X	tok = gettoken(buffer, NULL);
X
X	if (!tok)
X	    continue;
X	if (0 == strcmp(tok, "charset"))
X	    break;
X
X	if (0 == strcmp(tok, "spacewidth")) {
X	    if (!(tok = gettoken(buffer, 1))) {
X		fprintf(stderr, "%s: bad spacewidth line in %s\n",
X		    progname, filename);
X		exit(1);
X	    }
X	    widval = atoi(tok);
X	    widval = ((double) TROFFUWID * TROFFRESOLUTION * widval /
X		(unitwid * res)) + .5;
X	    update(tabS, " ", widval);
X	    update(tabN, " ", widval);
X	    update(tabS, "\\|", widval / 2);
X	    update(tabN, "\\|", widval / 2);
X	    update(tabS, "\\^", widval / 4);
X	    update(tabN, "\\^", widval / 4);
X	}
X    } while(fgets(buffer, sizeof(buffer), f));
X
X    if (strcmp(tok, "charset")) {
X	fprintf(stderr, "%s: %s bad format - no charset line\n", progname,
X	    filename);
X	exit(1);
X    }
X    while(fgets(buffer, sizeof(buffer), f)) {
X	char str[3];
X	if (commentsok && buffer[0] == '#')
X	    continue;
X	if (strlen(buffer) > 1 && buffer[0] == '#' && !isspace(buffer[1]))
X	    continue;
X	commentsok = 0;
X#ifdef	DEBUG
X	printf("buffer: %s\n", buffer);
X#endif
X	tok = gettoken(buffer, NULL);
X	if (!tok)
X	    continue;
X	if (strlen(tok) > 2) {
X	    fprintf(stderr, "%s: %s bad format on line %s\n",
X		progname, filename, buffer);
X	    exit(1);
X	}
X	strcpy(str, tok);
X	tok = gettoken(buffer, 1);
X	if (!tok) {
X	    fprintf(stderr, "%s: %s bad format on line %s\n",
X		progname, filename, buffer);
X	    exit(1);
X	}
X	if (tok[0] == '#' && !isspace(tok[1]))
X	    continue;
X#ifdef	DEBUG
X	printf("token: %s\n", tok);
X#endif
X	if (0 == strcmp(tok, "\"")) {
X	    widval = oldwidval;
X	    eval = oldeval;
X	} else {
X	    widval = ((double) TROFFUWID * TROFFRESOLUTION * atoi(tok) /
X		(unitwid * res)) + .5;
X	    widval = max(widval, 1);
X	    tok = gettoken(buffer, 1);
X	    if (!tok) {
X		fprintf(stderr, "%s: %s bad format on line %s\n",
X		    progname, filename, buffer);
X		exit(1);
X	    }
X	    widval |= (atoi(tok) << 6);
X	    tok = gettoken(buffer, 1);
X	    if (!tok) {
X		if (verbose)
X		    fprintf(stderr, "%s: %s missing emit code on line %s\n",
X			progname, filename, buffer);
X	    } else
X		sscanf(tok, "%o", &eval);
X	}
X	if (0 == (update(tabS, str, widval) + update(tabN, str, widval))) {
X	    if (extensions)
X		fprintf(extensions, "%s\t%s\t%04o\n", str,
X		    symfont? "S": "N", eval);
X	}
X	oldeval = eval;
X	oldwidval = widval;
X    }
X}
X
Xupdate(table, str, val)
Xstruct cattab *table;
Xchar *str;
Xint val; {
X    int i;
X    int done = 0;
X
X#ifdef	DEBUG
X    printf("Inserting char %s, (%03o)\n", str, val);
X#endif
X
X    for (i = 0; table[i].ch_name; i++)
X	if (str && 0 == strcmp(table[i].ch_name, str)) {
X	    if (verbose && table[i].ch_info && table[i].ch_info != val)
X		fprintf(stderr, "Duplicate nonequal width entry (%s/%s:%x/%x)\n",
X		    table[i].ch_name, str, table[i].ch_info, val);
X	    table[i].ch_info = val;
X	    done = 1;
X	}
X    return(done);
X}
X
Xchar *
Xgettoken(buf, ptr)
Xchar *buf, *ptr; {
X    static char *saveptr;
X    static char savebuf[512];
X    char *bp = savebuf;
X    if (!ptr)
X	saveptr = buf;
X    while(*saveptr && isspace(*saveptr)) saveptr++;
X    if (*saveptr)
X	while(*saveptr && !isspace(*saveptr))
X	    *bp++ = *saveptr++;
X    *bp = '\0';
X    if (savebuf[0])
X	return(savebuf);
X    else
X	return((char *) NULL);
X}
X
Xtabcmp(a, b)
Xstruct cattab *a, *b; {
X    return(a->ch_wididx - b->ch_wididx);
X}
X
Xsort(table)
Xstruct cattab *table; {
X    register int i;
X
X    for (i = 0; table[i].ch_name; i++);
X
X    qsort(table, i, sizeof(struct cattab), tabcmp);
X
X    dumpset(table, "After Sort");
X}
END_OF_FILE
  if test 10841 -ne `wc -c <'widths/dit2catwid.c'`; then
    echo shar: \"'widths/dit2catwid.c'\" unpacked with wrong size!
  fi
  # end of 'widths/dit2catwid.c'
fi
echo shar: End of archive 9 \(of 19\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 19 archives.
    echo "Read the README to get started with psroff installation"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
