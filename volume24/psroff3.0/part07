Subject:  v24i102:  psroff, Troff to PostScript filter, Part07/19
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: Chris Lewis <clewis@ferret.ocunix.on.ca>
Posting-number: Volume 24, Issue 102
Archive-name: psroff3.o/part07

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  Makefile fonts.lj/S.22.pk.UU utils.c utils/psxlate.c
# Wrapped by clewis@ecicrl on Fri Apr  5 20:55:59 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 7 (of 19)."'
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
  echo shar: Extracting \"'Makefile'\" \(13261 characters\)
  sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#	Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991 Chris Lewis
X#		All Rights Reserved
X#
X#    See the LICENSE file for a full description of the restrictions
X#    under which this software is provided.
X#
X#	This makefile requires System V compatible "make".  *Not* V7
X#	vanilla BSD or Ultrix or Sun.  Most modern systems will have
X#	a copy of the SV one somewhere (eg: .../s5bin/make).
X#
X#    Function: Upper level makefile; configuration options.
X#
X#
X#ident  "@(#)Makefile: 2.16 Copyright 91/04/02 17:02:22 Chris Lewis"
X
X#	Use s5make on Ultrix!
XMAKE	= make
X
X#	Only uncomment the following braindamage if your MAKE doesn't
X#	understand "include".
X#MAKE	= sed -e '/include/r ../makeincl' -e '/include/d' Makefile | make -f - $(MAKEFLAGS)
X
X#	Set to where you want the user-interfaces to go.  /usr/lbin
X#	is also common.  /usr/bin if you don't have a specific place
X#	for non-standard programs.
XBINDIR	= /usr/local/bin
X
X#	Testing type (default postscript (ps)):
X#	Use lj for laserjet.
XTTYPE	= ps
X
X#	Libraries for Troff2 internals, created if it doesn't exist.
X#	This *must* be a directory all by itself with no other stuff
X#	in it.  This should be suitable for everybody except networked
X#	systems where you may want to put this on a common area (one
X#	per platform type (eg: Sun 3 vs. Sun 4)
XLIBDIR	= /usr/lib/troff2
X
X#	Directory for Laserjet fonts.  Don't change this unless you
X#	really have to.
XLJF	= $(LIBDIR)/lib/lj
X
X#	nroff/troff macro directory for tmac.t2.  Change this only
X#	if you insist on keeping /usr/lib/tmac "virginal".
XT2DIR	= /usr/lib/tmac
X
X#	Where your real macros are - leave this alone unless your UNIX
X#	is really wierd.
XRTMACDIR = /usr/lib/tmac
X
X#	upper level man directory, with subdirectories man1, man2 etc.
X#	Could be /usr/man/mann, /usr/man/manl, /usr/man/man1, /usr/man/l_man/man1
XMANDIR	= /usr/man/mann
X#	Desired extension for man page.  Often the last letter of MANDIR.
X#	or 1L, or simply 1.
XMANEXT	= n
X
X#	Change this at your peril - your troff *must* support -F!
X#	(font width files (ft??) are placed under FONTDIR/<width>/ft??)
X#	(see lib/psrofflib.S).  Will NOT clash with anything already there.
XFONTDIR	= /usr/lib/font
X
X#	Set this to -lc_s if you have 386/ix style shared libraries and you
X#	wish to use them.  Don't know about any other system's shared libraries.
XLIBFLAGS =
X
X#	Bourne shell.  *All* Bourne shells with the exception of extremely
X#	braindamaged ones (such as Ultrix or vanilla BSD) will work fine.
X#	Ultrix/Dynix may need the ... s5bin/sh one.  Korn or bash
X#	*should* work just fine, but I've never tested 'em.
X#
X#	This is also here for make, but if you have SHELL defined in your
X#	*own* environment, you can't trust this to work anyways.
X#
XSHELL	=	/bin/sh
X
X#	Try "make testbug"  If make stops, uncomment IGNORESH and
X#	try "make testbug" again.  If it still stops, complain to your
X#	vendor - your shell is BADLY broken.
X#IGNORESH = set +e ;
X
X#	How to ensure that shell scripts use the *right* shell.
X#	"#! /bin/sh" may work for you (BSDish).  ": /bin/sh" may work
X#	for you (Xenix or System V).
X#
X#	Frankly, none of this crap is necessary on a sane O/S.
X#	(Even Xenix gets this right for crying out loud!  But *noooo*
X#	Not Ultrix or Sun or Dynix BSD universe....)
X#
X#	": /usr/bin/sh5" works for Ultrix.  "#! /bin/sh" for pure BSD.
X#	Do not use $(SHELL) in this line because if your environment has
X#	SHELL defined, it may *override* the above SHELL definition.
X#
X#	System V/Xenix usually:
XSTARTSHELL = : /bin/sh
X#	#! something (tr wierdness is to get "#" into it)
XSTARTSHELL = `echo 'X! /bin/sh' | tr X '\043'`
X
X#	Whether you need "cc -c"'d font width tables for troff.
X#	Don't set this non-null unless nothing else works.
X#	I know of no machine needing it.  See TROUBLE file.
XCOMPILE	=
X
X#	Compile flags needed to compile things on your machine.
X#	Usually just -O.  May need gcc stuff.
X#
XCCFLAGS = -O
X
X#	If you're using gcc or something else, change this:
XCC	= cc
X
X#	Do not comment any of the following out.  If you aren't going
X#	to use TeX PK fonts with HP Laserjet output, just NEVER execute
X#	makebuildljfonts.
X#
X#	If you have Rick Richardson's sfp2pk, set it's full path here:
X#	Only of interest for LJ/buildfonts.  If you don't have sfp2pk,
X#	leave this alone, the code won't try to run it.
XSFP2PK	= /usr4/public/bin/sfp2pk
X#	If you have TeX fonts onboard, list the directories that
X#	contain them.  Only of interest for LJ/buildfonts.
X#	You can always set this to "/", it'll just take a long time, but
X#	it will find ALL PK's on your system.
XPKFONTS	= /usr/lib/font/devjet /usr5/texfonts/fonts
X#	Where you want to build fonts, set this to the name of the
X#	directory where you want to make them.  Caution: this could be
X#	enormous...  (5000+ blocks)
XNEWFONTS = /tmp/newfonts
X#	If you are going to be working with ditroff, set this to the
X#	path to the makedev (DWB) or mkfont (PD via comp.sources.unix) program.
X#	If this doesn't point at an executable program, nothing will happen.
X#	A make install in the widths directory will go through the psrofflib
X#	file, looking for each configuration requiring ditroff, and install
X#	the needed widths in the proper directory.  This will NOT overwrite
X#	files not created by this process.
XMAKEDEV	= /u/clewis/src/mkfont/mkfont
X
X#	Dinna touch from here on
X
X.SUFFIXES: .S .S~
X
X.S~:
X	@rm -f $@
X	$(GET) -p $(GFLAGS) $< | ./sedscript > $@
X	@chmod 444 $@
X
X.S~.S:
X	@rm -f $@
X	$(GET) -p $(GFLAGS) $< > $@
X	@chmod 444 $@
X
X.S:
X	rm -f $@
X	./sedscript < $@.S > $@
X	@chmod 444 $@
X
X#	Main stuff:
X
XMAIN	= troff2.o opt.o utils.o t2conf.o cattab.o debug.o
X
X#	Drivers:
X
XBACKENDS = lj.o pk.o pkc.o ps.o dt.o dit.o
X
XDEFINES	= '-DLIBDIR="$(LIBDIR)/lib"' '-DFONTDIR="$(FONTDIR)"'\
X	'-DLJF="$(LJF)"' $(CCFLAGS)
X
X#	Creation of sedscript for parameterization.
X
XSEDSCRIPT =	"sed -e 's;%%LIBDIR%%;$(LIBDIR);g' \
X		     -e 's;%%LJF%%;$(LJF);g' \
X		     -e 's;%%STARTSHELL%%;'\"$(STARTSHELL)\"';g' \
X		     -e 's;%%COMPILE%%;$(COMPILE);g' \
X		     -e 's;%%FONTDIR%%;$(FONTDIR);g' \
X		     -e 's;%%MANDIR%%;$(MANDIR);g' \
X		     -e 's;%%MANEXT%%;$(MANEXT);g' \
X		     -e 's;%%CCFLAGS%%;$(CCFLAGS);' \
X		     -e 's;%%CC%%;$(CC);' \
X		     -e 's;%%LIBFLAGS%%;$(LIBFLAGS);' \
X		     -e 's;%%SFP2PK%%;$(SFP2PK);' \
X		     -e 's;%%PKFONTS%%;$(PKFONTS);' \
X		     -e 's;%%NEWFONTS%%;$(NEWFONTS);' \
X		     -e 's;%%T2DIR%%;$(T2DIR);' \
X		     -e 's;%%MAKEDEV%%;$(MAKEDEV);' \
X		     -e 's^%%IGNORESH%%^$(IGNORESH)^' \
X		     -e 's;%%RTMACDIR%%;$(RTMACDIR);g'"
X
XCFLAGS	= $(DEFINES)
X
Xall:	troff2ps subst.done makeincl psroff README TROUBLE LASERFONTS \
X	MISC DITROFF INSTALL LICENSE LJIII submakes
X
Xsubst.done:	sedscript
X	rm -f psroff makeincl
X	touch subst.done
X
Xsubmakes:
X	cd adapters ; $(MAKE) all
X	cd lib ; $(MAKE) all
X	cd man ; $(MAKE) all
X	cd utils ; $(MAKE) all
X	cd widths ; $(MAKE) all
X	cd tests ; $(MAKE) all
X
Xpsroff:	psroff.S sedscript
X	@echo "Extracting $@ with variable substitutions"
X	@rm -f $(@) ; ./sedscript < $@.S > T ; chmod 555 T ; mv T $@
X
Xmakeincl:	makeincl.S sedscript
X	@echo "Extracting $@ with variable substitutions"
X	@rm -f $(@) ; ./sedscript < $@.S > T ; chmod 555 T ; mv T $@
X
Xaudit:	audit.S sedscript
X	@echo "Extracting $@ with variable substitutions"
X	@rm -f $(@) ; ./sedscript < $@.S > T ; chmod 555 T ; mv T $@
X
Xunpackljfonts:
X	@ $(IGNORESH) find . -name '*.UU' -print | \
X	while read i ; \
X	do \
X	    ft=`echo $$i | sed -e 's/.UU//'` ; \
X	    if [ -s $$ft ] ; \
X	    then \
X		echo "Removing $$i" ; \
X		rm -f $$i ; \
X	    else \
X		rm -f $$ft ; \
X		echo "uudecoding $$i -> $$ft" ; \
X		uudecode < $$i ; \
X		if [ ! -s $$ft ] ; \
X		then \
X		    echo "Whoops - uudecode failed on $$i - bad path?" ; \
X		    exit 1 ; \
X		else \
X		    rm $$i ; \
X		fi ; \
X	    fi ; \
X	done
X
Xbuildljfonts:	unpackljfonts
X	make troff2ps makeincl
X	cd lib ; make lj.fonts lj.lib
X	cd utils ; make buildfonts
X
Xinstallljfonts:
X	test -d $(LIBDIR) || mkdir $(LIBDIR)
X	test -d $(LIBDIR)/lib || mkdir $(LIBDIR)/lib
X	test -d $(LIBDIR)/lib/lj || mkdir $(LIBDIR)/lib/lj
X	$(IGNORESH) files=`echo fonts.lj/*.pk` ; \
X	if [ "$$files" != 'fonts.lj/*.pk' ] ; \
X	then \
X	    cp fonts.lj/*.pk $(LJF) ; \
X	    chmod 644 $(LJF)/* ; \
X	fi
X	$(IGNORESH) files=`echo fonts.lj/*.sfp` ; \
X	if [ "$$files" != 'fonts.lj/*.sfp' ] ; \
X	then \
X	    cp fonts.lj/*.sfp $(LJF) ; \
X	    chmod 644 $(LJF)/* ; \
X	fi
X	@echo "don't panic if the next line dies"
X	$(IGNORESH) test -z "$(PKFONTS)" -o ! -d "$(NEWFONTS)" \
X	    || cp $(NEWFONTS)/* $(LJF)
X
Xregister:
X	make troff2ps makeincl
X	cd lib ; make lj.fonts lj.lib
X	cd widths ; make ljwidths widths
X	@echo "Now su to root and type 'make installwidths'"
X
Xinstallwidths:	makeincl
X	cd widths; $(MAKE) installwidths
X
Xinstall:	makeincl
X	test -d $(BINDIR) || mkdir $(BINDIR)
X	test -d $(MANDIR) || echo "No MANDIR directory.  Have you got MANDIR right?"
X	test -d $(LIBDIR) || mkdir $(LIBDIR)
X	test -d $(LIBDIR)/adapters || mkdir $(LIBDIR)/adapters
X	test -d $(LIBDIR)/lib || mkdir $(LIBDIR)/lib
X	test -d $(RTMACDIR) || mkdir $(RTMACDIR)
X	test -d $(FONTDIR) || mkdir $(FONTDIR)
X	rm -f $(BINDIR)/psroff.old
X	-cp $(BINDIR)/psroff $(BINDIR)/psroff.old
X	cp psroff $(BINDIR)/psroff
X	rm -f $(LIBDIR)/troff2ps.old
X	-cp $(LIBDIR)/troff2ps $(LIBDIR)/troff2ps.old
X	cp troff2ps $(LIBDIR)/troff2ps
X	chmod 755 $(LIBDIR)/troff2ps $(BINDIR)/psroff
X	cd lib ; $(MAKE) install
X	cd adapters ; $(MAKE) install
X	cd man ; $(MAKE) install
X	cd utils ; $(MAKE) install
X	cd widths; $(MAKE) install
X
Xtroff2ps:	$(MAIN) $(BACKENDS)
X	$(CC) $(CFLAGS) -o troff2ps $(MAIN) $(BACKENDS) $(LIBFLAGS)
X
X#	The following is commented out because make has a bug in that
X#	even if you don't want to make lint, it insists on making
X#	the .c's from the SCCS files.  Dumb stupid....
X#lint:	$(MAIN:.o=.c) $(BACKENDS:.o=.c)
X#	lint -p $(CFLAGS) $(MAIN:.o=.c) $(BACKENDS:.o=.c) > output.lint
X
X#	Drivers include dependencies - add to this list if you're adding
X#	drivers.
Xdit.o:	defs.h
Xt2conf.o:	defs.h ps.h lj.h dt.h
Xps.o:	defs.h ps.h
Xdt.o:	defs.h dt.h
Xlj.o:	defs.h lj.h pkc.h pk.h
X
Xpk.o:	defs.h pk.h pkc.h
Xpkc.o:	defs.h pk.h pkc.h
Xcattab.o:	defs.h pk.h
Xdebug.o:	defs.h pk.h
X
Xtroff2.o utils.o opt.o: defs.h
X
Xsedscript:	Makefile defs.h
X	rm -f sedscript
X	echo $(SEDSCRIPT) \
X	    `sed -n -e  \
X	    '/T2VERSION/s/^.*\(R[0-9]* PL.*\)".*/-e "s;%%T2VERSION%%;\1;"/p' \
X	    defs.h` > T
X	chmod 755 T
X	mv T sedscript
X
X
Xclean:	makeincl
X	rm -f core *.o troff2ps psroff diagnostics audit
X	rm -fr mon.out output.lint TEST* DITTEST AUDITP AUDITP.c
X	rm -fr FONTS
X	cd adapters ; $(MAKE) clean
X	cd man ; $(MAKE) clean
X	cd utils ; $(MAKE) clean
X	cd lib ; $(MAKE) clean
X	cd widths ; $(MAKE) clean
X	cd tests ; $(MAKE) clean
X	rm -f sedscript makeincl subst.done */subst.done
X
X#	Yes, this is a little wierd, but in this way I can figure
X#	out what you are...
XTEST:	Makefile defs.h tests/testtab.m tests/exttab.m makeincl
X	cd lib ; make
X	rm -f TEST1 TEST2
X	PATH=.:$(LIBDIR):$$PATH \
X		troff2ps -V | sed -e 's/^.*- \(.*\)/.ds 2v "\1/' > TEST1
X	echo ".ds pt \"($(TTYPE))" >> TEST1
X	echo ".ds 2d \"`date`" >> TEST1
X	echo ".sp" > TEST2
X	echo ".ps 10" >> TEST2
X	echo ".vs 12p" >> TEST2
X	echo ".ad 1" >> TEST2
X	echo "DEFS.H DEFINITIONS:" >> TEST2
X	sed -n -e '/Edit no more/q' \
X		-e '/T2VERSION/d' \
X		-e '/LIBDIR/d' \
X		-e 's/[ 	]*\/\*.*//' \
X		-e '/^.define[ 	]*\([^ 	]*\)[ 	]*\(.*\)$$/s//define \1=\2;/' \
X		-e 's/=;/;/' \
X		-e 's/^define //p' \
X		-e '/^.undef[ 	]*\([^ 	]*\).*/s//!\1;/p' \
X		defs.h >> TEST2
X	#echo ".br" >> TEST2
X	echo "MAKEFILE DEFINITIONS:" >> TEST2
X	echo "LIBDIR = $(LIBDIR);" >> TEST2
X	echo "LJF = $(LJF);" >> TEST2
X	echo "STARTSHELL = $(STARTSHELL); " >> TEST2
X	echo "SHELL = $(SHELL); " >> TEST2
X	echo "COMPILE = $(COMPILE);" >> TEST2
X	echo "FONTDIR = $(FONTDIR);" >> TEST2
X	echo "MANDIR = $(MANDIR);" >> TEST2
X	echo "CCFLAGS = $(CCFLAGS);" >> TEST2
X	echo "CC = $(CC);" >> TEST2
X	echo "LIBFLAGS = $(LIBFLAGS);" >> TEST2
X	echo "RTMACDIR = $(RTMACDIR);" >> TEST2
X	echo "PKFONTS = $(PKFONTS);" >> TEST2
X	echo "NEWFONTS = $(NEWFONTS);" >> TEST2
X	echo "IGNORESH = $(IGNORESH);" >> TEST2
X	echo "SFP2PK = $(SFP2PK)." >> TEST2
X	echo "TTYPE = $(TTYPE)." >> TEST2
X	@echo "Don't worry if the uname/grep fails"
X	-grep '^trofftype' lib/psrofflib >> TEST2
X	echo "Uname results:" >> TEST2
X	-uname -a >> TEST2
X	cat TEST1 tests/testtab.m TEST2 > TEST
X	rm -f TEST1 TEST2
X
Xtest:	TEST
X	tbl TEST | PATH=:.:$(LIBDIR):$$PATH psroff -T$(TTYPE) $(TFLAGS)
X
XDITTEST:	TEST
X	echo ".bp" >> TEST2
X	echo ".sp |.3i" >> TEST2
X	cat TEST TEST2 tests/exttab.m > DITTEST
X
Xdittest:	DITTEST
X	eqn DITTEST | tbl | PATH=:.:$(LIBDIR):$$PATH psroff -T$(TTYPE) $(TFLAGS)
X
Xcheck:	audit sedscript makeincl
X	cd lib ; $(MAKE)
X	./audit
X
Xcheckinstall:	audit sedscript makeincl
X	cd lib ; $(MAKE)
X	./audit install
X
X#	This is how I build a release - don't even try running this...!
Xbuildrelease:	clean unpackljfonts
X	$(IGNORESH) t=`find . -name 'p.*' -print`; \
X	if [ -n "$$t" ] ; \
X	then \
X	    echo "files still out: $$t" ; \
X	    exit 1 ; \
X	fi
X	make buildfinal
X
Xbuildfinal:
X	make clean
X	t/cleantree
X	t/mkmanifest
X	t/mkkits
X	t/cleantree
X
X#	Impossible file, we hope....
XWF	= /cowsnovskibumsteinpastafazoola/bdkdkdk
Xtestbug:
X	@ $(IGNORESH) if [ -r $(WF) ] ; \
X	then \
X	    echo "Bizarre - are you sure you have $(WF)?" ; \
X	else \
X	    echo "IGNORESH set correctly" ; \
X	fi
X
Xfixperms:
X	find $(LIBDIR) -type f -exec chmod +r '{}' ';'
X	find $(LIBDIR) $(FONTDIR) -type d -exec chmod +rx '{}' ';'
END_OF_FILE
  if test 13261 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
  fi
  # end of 'Makefile'
fi
if test -f 'fonts.lj/S.22.pk.UU' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fonts.lj/S.22.pk.UU'\"
else
  echo shar: Extracting \"'fonts.lj/S.22.pk.UU'\" \(13015 characters\)
  sed "s/^X//" >'fonts.lj/S.22.pk.UU' <<'END_OF_FILE'
Xtable
X !"#$%&'()*+,-./0123456789:;<=>?
X@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_
Xbegin 644 fonts.lj/S.22.pk
XM]UD``7``````````!":N``0FKI"_(0```$9"6_I#U2U?3373337333733373
XM]--=---=---=---=---=/TTUTTTUTTTUTTTUT_3373337333733373]--=--
XM-=-+(;9;$K9+!;1:]K1*\26R6N$ULDK21;)*P76P6T6P2V6N6V6N2W6M6X6L
XM2Y6K6Z]:I+M:E;Q:A+U:=;Y:9+]:5;]:5,%:-<%:-,-:),-:%<-:%,597%64
XMQU=<=73(5ER55,I47+]33,4ES5%,Z@S_C0?2;27434.^L,$D````>&$H]2;$
XMO?O1QMC%S,O2R\?/SL[%TLK`F,+6QZPWN:Q<2L=IC#P\*<M8;'P[C.1UR\*7
XMT45<W"=]-$3/PE?40UT<$WUD)-/!%]="/5Q]DQ36Q=J-?#W&V<'=;:P-UMO`
XMW&W,#;;=P-IMW!V6W,/7C:Q=9!/9Q]4R37<<'30DUG/!T5--1UPL]$33=\+-
XM54T7G"RU=,Z+P\=H7+G"P\.);'K$Q:FWPZQ];"B<#*TL7.SL_'R]++S,78QM
XM&]^\0)`\)0```%M)/?4SNAVWUYU:'3XJ/1I='BH].AU9UWVQ`#H-T0H1W0`Z
XM`=M]>=6AT^*CT:71XJ/3H=6==]L;H+"A)@```%](*/4FPKVIO%T\&LG.PXS<
XMK%?/R*PI7$Q)Q'P,'"C%;$P,!\9<?`I\=,JX;(3,MFR4S;1LE,^R;*30L5RS
XMTL3*33PLM-/!S#U<#,/6O,/7K,/8K+/8O*/8P,D]C!R$UL+)/5Q,@]51O'33
XM8KQSTF2\9-!FO&3.:+Q4S'K`Q$RGP,#$7&C"P<-<.<3$P&JLC'C,RL:<G.Q+
XMQ=/!PJVJL),J````7S0WZS`3`0,5WKW,':<7V'-]9U?4=WTGE]![;0;!;.;#
XM;,;$?*?%?(?'?&?)?$?+?"?-?`?/>GT7A]-V?5='UW)]G"V\#=K?@!%@$8WZ
XMW<#;PMER?7='U79]-X?1>GSWP'S7PGRWQ'R7QGQWR'Q7RGQ&S&PVSFP6T&M]
XM!Y?2=WU'5]9S?8<7VL'<O>43`0,0D`XM````7T(%\A<=80C!UA"@4#P```!!
XM,C#Y+M,])L^,V<R<R<R<R<R<R<R<NLNLNLNLN<R<R<R<R<R<R<R<WXT)T)T)
XMT)T)T)T)T)T*SZSZSZT)T)T)T)T)T)T)T)T(T6TS$*!0/0```$$R,/DN$]-M
XM&-"="="="="="="="="L^L^L^M"="="="="="="="=#XS9S)S)S)S)S)S)S)
XMRZRZRZRZRYS)S)S)S)S)S)S)S8SVTCTPN"Q#````.C)`_3_B`4F\BKC,>XSF
XMJ,]:^-!*XHT3KCC2*N2-,NV9C>G;P-/BT,J0;D0```!-1$+\0;<M?TU?;3^-
XM'Z#/\AG-\CG+\EG)\GG'\IG%\J&</RHYP?*EF_\J>;WRJ9N_*KFY\JV;?RKY
XMM?*QFS\K.;'RM9K_*WFM\KF:ORNYJ?*]FG\K^:7RP9H_+#FA\L69\L>7_47]
XM8_V!VK"22````$@]0OM`S;`2Q]QY?8?!?4?%?1;);.?+?+?-?)?/?'?1?%?3
XM?#]]5\%]=[C7BGV7F-F(?;=_C;A>*-V#^=V2C?@H8L\F@?EBSR;&YFTVQN)B
XMSR:?&-^"^=V3XHW87XVX=]MXC9B7V7J->+?7?!]]5\-]-\5]%\=\]\E\U\M\
XMM\YLEM%\5]1\%]AY?<QP$KS0H(Y+````0#E"_4'`XCVN)=CB?6XIU+#3\AC2
XM(IT?(XT"2<_R6,XUG-\GC,-YRRB<LIC*.9R2J<DK",@["<<K&<<K*,8[*<4K
XM.<4K2,0[2<,K6</RMHPBMYP?*XC`*YF_\KJ+XKN;WRO(O"O9N_*^BZ*_FY\L
XM"+@L&;?RPHMCPIM3PXM$PXLVP:L*OK%N*VMKP*`O3@```#XU0/P_'EV"/2,?
XM/47DUB`!\.,L0K?ER+?C+$(`(EY"UE_4,2U"(](RY=@0R!A0````13Y`_3\*
XMUZWZT^`JC?C3S;Q^+=K=H(U2````0SA`^S\=HOVSG#LTG'E*R(2<EUG)9:R5
XM:<I'G)1ZR3B<DYG)*:R"J<@K"<<ZK'*PG'*QG&*QK%*RG5G5^=6=7YU9U?G5
XMG5C5?779\]HMHMHMHMHMHL<K8L@OM2R2M"R3LRRBLRRRLBS"L2S#L"S3HLU)
XM+.22S5@LUG+-=BS84LR5+(LTV3VBVSVBL%!3````(2(T_2G(K(Q<-H;`3#*T
XMT3TCTCTCTCTCTCTDTCTO31Y4TO71]M!]!\^<ZLV\R\S`R\'+P<O`S+S+S:SH
XMT'T/;171XDT4TCRR1,R<]<.@750```!(/4'[0(C"BSL;ZQL+2ZM)M[>V>YM;
XMA;NSNDO+&[-IFPF6)+**>R0CM(A[0Q.V>&MEN'9KA+EF6Y2Z56N4NF1;HKU4
XM748FU>)276L-CCK8G:[&C9K7L<WBP[2PAE4```!#.$#[/\'BTM?``1H!/G@!
XM'"VLK3D8&<YUA7RG>'?&>8E\-ZBGP7N+>WP(P'E\&,%WC!C!A?C"C"@YPHPI
XM*,.,.!YYPXPY&,.,."G"C"D_C"C"A8P8P8=\&,%Y?`C`>WN+?!>HI\-YB7QG
XM>'?*=85\Z1@9T\K:P@$>>`$Z`1P-?BTL$*!O5P```$@]0/L_M>+#S;'7K9YH
XMP(MXMKBVBUHXM8M(>+2+.)XHLXLHL.L8LHL8LGLHL7L^*+&+"+1[&+![6+"*
XMBV]["*>X>HE[IJB7NGF(>\>(AKYHAVP':&;"=85L5S@VR;W,N-.QV.>-FM>Q
XMS>+#M+"B6````$,Z0?Q`R\#>R->8G2?$?.?(?+?*?);.;&?0?#?2?!C2C`?4
XM>WUGF-:'G6EHV(7YV)2-J#Z)VI.-J$^=B5XHV(?XUHE]9ZC4BWU'P6U&PGTG
XMP_;2;%;0;']=!<E<Y<M,Y,Q<Q<WTS$P2P$RDP$P3RCP2$L`\H\`B+!+*+!(O
XM+!/(/!(CP2R"P3,L$L@L$D/`/&/`-.+&QL9?Q<;%;%Q\0[BR60```&50/O8[
XM"$$#(_`P4"Y_`LF@'$JP&ENP&%P:`83"L!9<.@%5Q+`47%L!)<>@$DR+`07)
XMK?7+K>3,O<7-K<3.O:7/O871K832O673K574O475O277K238O079K/7;K.3<
XMO,7=K,3>O*7?O(4!&LA`$KQE`3K%4!2\10%;PE`7K"0!B\!0&:M0&ZI`'+A0
XM':A`'K90'[10(:1`(K)0(Z%0),0"7"`G_``IH"OX`M8"]-JPJUH````Q+T/]
XM0<R-C"T\;0:'S4P6RSQ5R2R%QRREQ2RUQ2S%PURUPFREP8R5P8R6P(REP'RU
XMP5S&P3S6Y=ULJ+;'PH;$=T=L-<$E?!7$)'P%QB-[7'(WI<DB>5RB%Y7,F%S9
XM=LV6;.AGSH9L^%?/=FT'5]!U]\]U?0=7T&9\]V?/9VT&;WSV?WSFELUJ;-6_
XM;,7!7+7";)7$7(7&7&7(7#;*7`?,:'S\;2P]><Z0AUP```!?0E/R/M0]-M",
XMZ@RZ+*HLJBRJ+*HLJARZ'*HLJBRJ+*HLJBRJ'+H<JBRJ+*HLJBRJ+*H<NARJ
XM+*HLJBRJ+*HLSYSZ+.HLZBSJ+.HL^ASZ'/HLZBSJ+.HLZBSZ'/H<^BSJ+.HL
XMZBSJ+/H<^ASZ+.HLZBSJ+.HL^@T(TFU#`#Z-80C!UA"0AEX```!?0E/R/A/4
XM;2C0H,^BSJ+.HLZBSJ+/H<^ASZ+.HLZBSJ+.HL^ASZ'/HLZBSJ+.HLZBSZ'/
XMH<^BSJ+.HLZBSJ+\^<RBRJ+*HLJBRJ+*H<NARJ+*HLJBRJ+*HLJARZ'*HLJB
XMRJ+*HLJBRJ'+H<JBRJ+*HLJBRJ++H,Z-!M,P!"76$(P=8=@*7P```"XN!0#K
XM#H"PBF$````[,RO]*<E]W!V&9-5:337`307#3"*EQ%P2E<9<`H;&6RAL=J*%
XMR&HG;)62=LIH)GRF@F;+9R9\MG)GRV8F?,9B;WS&4F]\UD)WS6,H?-8BELYB
XM*'SF$I]\Z*?.>WSFP>-LYL)<U\)<LQ615<DR6"9,<T6"=,1&5BE,%)1BI7:T
XM0\##PIQ(R%>@QF(````T,E3]0<A\VQR59<5+!,,[-,$K5,`K9;XKA+TKE;LK
XMI;HKM?N2NV^X*\:W*];[8KUK8KY;<KUK<KU;<KUK<KU;@KQ;@KQ;DK"26Z*;
XM6\*2=KPJM;LK"32Z*]2Y*]6W\K];;ROVM/+`:T\L![+B+!>R+!:RXRP7L3P'
XMLBP7LBP6LRP'LO/`:S._:T2^:S(2O6M"$KQK4B*[6V(BNEMB0KA;<D*W6X)2
XMM5N28[%;HH1VO"JROBL8P2U.,M3C+4XRU.(M4=:@;&,````P+SW^*;-\NPNR
XMJSNBFUN"FWMRBYM2AWBT)ULELR=;1;(G.X.Q)SN3L28[L[`F*]*B8[TJ)O*_
XM*";RP"<LHF+*\E++XB0LPC+.(BSN(A+/XDT.(]#B/1XBT?/1+1XST.,]#C/0
XMXCT?*Y"PBV0````I)D/]0<UM&\U6/+2BR4P"QTPBQ4PRQ$Q2PTU?35XUU6U'
XMTXTXTITITITJT:TIS\#,PLI4C(5HQ5E\1;;#7!;!;"7`;#7`7%2VQ4IL9*;'
XM.6R#CWR#?B?)-N-\DW;)-_?)-_?(.6R"KVQSIL8[;&+!7%/!7%+#7#+%3"/&
XM3`/(2CRE8\W`T7R`P$!E````)1XJ_"C6K4T='2T(V&V6VFVFVFVFVGVFVGVF
XMVGVFVGVMMMQ-Q>1]KC;<7<]MSUW?7=7=33.%Q+5UT='6BK!U9@```"@G5/Q`
XMS.8MDBG/P<Q9+*,<#)1)R3USUSUSUSUSUSUSU_/7/7/737/737/7/737/7]-
XM;TUSU^)-;C36]=;C37Y%UFUEUFU7U7U)TZTL#0PL[$S,7,Q<S$SL+0P-*=2-
XM5M;C76]-<\LJ3,*3SC5-"M-L0+!G9P```"XI/?TI=<1\"+P))3E&1R9'*D4G
XM5#M4)U,\!B*&(L)2*&$L-2*(Q%\2E\51*6Q8E\6/EL9K;&;CIL9JXVQFKC;&
XM:N-L9JXVQFKC;&:FQFP%QFP3QVUVUN-M;C;6XVUN)M==D\'`EF@````K)4/]
XM0=M0$9W44]M'/9.4UTI-5+343$TUQ=%=!=!=%=!=%K72:FTFI=-I;3:5U&^&
XMU&]VU69]5F;6;U?5=6UG1]9T?696UG3B?6<^(!1'UG/B?6='UF7VUG1]9E]]
XM5U?59FU7;VU6?VU&AM-I;36FTFM=)<71;%T5T%T%T5T$TTQ-1+752DUDE-@X
XM/;-4W:`07;#`.VD````A%ROZ*;/674]M/C;3XVT^)M/C;3XFT^)M/VU&T1XA
XM;1C]$A;0(ET2)=`C7"1;)5HG2#DV2ZT7P,!\:@```#4L*_LIPP&UUET6TYT&
XMTJQM$QC&T#*,;"2,:R9L:R@]%I/=:#WF<M]G(!!F(!%E(!)C,!)C,!-A,!6P
XM%-3=8\VFB=AK?7;0;5;2;4]M-M-M-K'C-M1J(FU5HC]M1J(VU5DC;662-M98
XM)&UT@D;71R1ME$-EVI@]U8"P@6L````V+$+[0,!MJ-M]MMI]IMKWVFVO?:;:
XM]]IMKWVFVO?:;:]]IMKWVFVO?:;:]]KVVO?8C7(7U3%]0S;3-'T35]`W;/1W
XMS4A\Q*;+2WR4P'R$PFQUPGQ5PWQ%Q6PUQGP5QWP%R6MLEY;*>&S&=LUU;.='
XMSV-]!Q?1<6TV%=5A/76@9VP````X,#W]*;4]%;@[EK=;AK=K;C:W:VXVMVMN
XM-K=K;C:W:VXVMVMN)K=K=K=I'C=K=I+B9[9I)WM7@GBTB">;(B5RB;$C5RBJ
XM)48H859'1"ECL9BF5[-;!L[C;.XVSN-L[B;/71/1L&QM````+BLJ^RF7RS3!
XMRE+"R6/!R6XI;):FR&KVR6KVR&KVR&MLA<!L=K;(7`;';`;&;!;&7!]L9<)L
XM5<-L1<-L1<1L1,5L-,9L),9L),=L%,AL!,EK3):TRFE<MH3-9ES69,]D3185
XMTZU)UTV@L'UN````*"94_D#+YBV,'+Q,B)+%<<#%99Q'TFTWTGTO?2]]+B?2
XMXWU&U/?4;5;54[R,?(>3Q\;&0[QSUCUCUCUCUCUDUCUCUO35XDU>)-;B75]M
XM5].-.=*]#`S\+-P\W$S,3,Q,W"SL'0O1G4?4;476]-5,@[3).4S$5,Z])L'`
XM9F\````L)RO]*=AP$-#;9DV%I=5<727270737%U5IM59;6:%UV=M=F;99'V'
XM1ME_-]E^(GVGXQ?:<FVG)]IR?:8WV7-]ED?8=6V&;VUV=M9I766EU5Q=-=%-
XM)=--!=5*785EV]`!!]BP;G`````T,"K^*+V*VXW'W6W66BDL=,`I+&3`*BQB
XMPBHL4L,I/$/".2Q2PRHL0L0J+$+#.3U3D]4J/4\Z/4.4T_.DTO2DTCM-%+31
XM2ET.)+7/6USTP%SO7`;,;`;,7!;+]L)LI<-LGVPWR%Q5RCQSP[!Z<0```#`J
XM/?TISVU;T55<Y)3,2ERDP$R4P5QTPFQ4Q%Q%Q%PUQ6P6Q6P5QFP&QFP%QV^V
XMQGXJ;'?CEL=Y]L=Z;':VQGKVQVOVQFML9L!\5<%\1<)\-L&,-<)A+!7#8BM,
XM5B*5Q60U;&9;R&=LMM?C;7XVU^-M?B;87:/:L&QR````-#`J_2C(S\;3P]7!
XMU\#7P(>,Q[;+;";);$7(;%;&;&;&7(7%7)7$;);#7*;";*;"7+;!;+;!;+7!
XMXVRVP.)LML'VRFPFREP_;)7%7(7&7'7'7'3)3&3*7$3,3#3.3!302ETE9=;`
XMVGTPL$9S````*"LJ_BB].M:-=]AMAEP"RTP3RDPCRBQ"RBQ#R3Q#R2Q3R"QC
XMR"Q3W//;XDVN--I=KTVN)=GB79]MGUV>)MAMI=L\\,!U=````#(L*_TII=LZ
XMC96#0]=V)DU84G74A"A=5S*6U6,I;64BIM92*EV$$J;802IM@Q*VV#'RIMD\
XM;://;:+/;;+&VBSVVRQMHL]MLL]MHM!=HM!MHM#VV2T6V"T_77+4;5+674+7
XM73+971+;6SW6=`$-`!6-8+"T=0```#<N5/M`U1`0XRW^,M_C+?XRW^,M_RW)
XMU<30<B1<Q6)ER%@H3&62E,-:*TP5LK6UP"P$I<$L!87!+"5FP2PE9<(L)57#
XM+"5&PBPV-<,L-B;#+#8EQ"PV\6PRQ,#\0L-A]L,L1A;#+#8EQ"PV+UPRPV-<
XM,L-47#+"55PBPF5L$L)77!+!6%P2P%I,`L!;6RM<%+*EPTHI7%2"A<A6)ES&
XM,C;0Q-6=SB+?XRW^,M_C+?XBU+"@=@```#HR/?TIAMZ]05-&TB0G;0)2=\\D
XM*7S24I?,+&;++'?)+);(+*]\8LQL4LU\,LY\(M!L$M%[+2>BU&HM1X+5=RUV
XM8MAE+9]S+;8BW)W8W_8!#W`0;??>G<(7VR-MKR1]@F;7)VUBA]0I?3*VTO+`
XM?0+";/+#?-+$?,+&;++'?)+(?)+)?'+*?&+,>18LUY)"SV@D+19B0M-D)AU*
XMWG?`RW<````\-E3]0`&Q`G\@)N,@)N,@)N,@)N,@)N,M]=4M$ZC4+06#0],L
XM=B9-(KA2==`LA"A=`M!S*6PM%C*6PM)2*FLM-2*EPM1!*FPM1!*FPM0Q*VLM
XM4Q\J;"U3QM`M4\]L+6+/;0+6+&PM8L]M`M8L;0+5+&T"UBSVT"U2T&T"U"T6
XMPM4M%=`M0M)=`M,M-=`M(M1K+3+4:RTBUELM$M=;+0+962P]M8*SW5<I,!!6
XM)T`2@250%M0!R@(B`FXR`FXR`FXR`FXR`G$!4+"&>````#DU*_\I`4/`'86R
XMUGDM:(+7B"V'<MIF+;9BW%4MU5+>3B0M\T(!`T+*'),RRCR"3B+)3((^(LE,
XM@D\LD\@D/(3'-#R#R"4\@\<U/(/')CQTQC8\=,4W/&7%-TQ&Q#A,-\-(7!04
XMP%I:84IK=G)F?`QSQL+%7$Q,-L/&P8P<BKO*?#;'8`UY````%P1;]T,2$/T2
XM$,`_>@```"H=6_I#VUUUV5VDVEVEVTV_7:[>7:]=M-M=I=I-I=E===]=U=U-
XMU=Q=Q-SUW.WEW/7<3<7<7=3=7=7?4,@_>P```"H=6_I#7?7=7=3=7<7<3<]=
XMSMY=SUW$W%W%W4W5W5WUUUV5VDVEVEVTV_7:[>7:]=M-M=I=I-I=E===L+!E
XM?````%](+_4LPH`4*\(!`YQ]TXR=PWS-HUS]DUT=9$J,'50XPKU$*,6]%2?(
XMK/4FRZS6)LVLMB7/K(<ET;Q8)-2\*#35P8I$UM%3V<]3VLQSW,F#W<>3`0PL
XM`@$X`%`P*A"\$"H0D!Q]````7T@O]2P=P0GAW`!$C<$)X=P`1(W!">'<$,!O
XM?@```"H?6_M#$M_TWEWO3>7>XDWEWO3>7>]-Y=[TWEWO3>7>XDWEWO3>7>]-
XMY=[TWEWN)-Y=[TWEWO3>7>]-Y=[TWEWN)-Y=[TWEWO3>7>]-Y=[B3>7>]-Y=
XM[TWEWO3>7>]-Y=[B3>7>]-Y?WDWR$)"O?P```%M)0/4]I*"OH*^FJ::JJZ.K
XMIJZAKJ.Q>QH:"*%:&*"8I).:2'>H@8J'9JNCJV5JVAK61:^:]3:P>P8O6Q>Q
XM46LELJ'[-;.@M#M*#DU:'3;Q734FT6-=%4]L]E;-9_;+:6R6H6QVHGQ7HWPW
XMI7P7IWOWJ7O7JXN8K8MXKXM8L9L9M(KXMXK8N9J9O(IXOYHYP9H9Q(F,>'C*
XM=7S7-\]C;186T_H=6=?WV?7;.Y"P.*$```!!)T[S/,<M@]==7WTYT;S\',Q<
XMEA46QV)2;$<U-\"$5(B&5H.G5\:5G"M;K!7!3@'L5=<\8'`YH@```'AA(?4E
XMQ"UDU5U4U5U5U4U5U5U5U6U&U'TX!M4PRQU<^`T'T6TFTETUTUU$U%TUU$U%
XMU$UBB[`XHP```$$G3O,\QCU^`>7%3!7!JUO"E9QG5Z.&5HB$5(P'-3?$8E)L
XM=A46R<7,P<^]&=/WU5USV2Q@<#ND````>&$A]26++6347434737434737372
XM;2;1?0@,_5(&D=@]5H#3?4;4;5757575357575357536+$"P<:8````N*2[^
XM+A+:78?6G4K3P-%"C/1(S46,Q'C*28R$N,9,"<1,*,-,2,%,:+3(B4R8A,N&
XM3-A$SX)-"!]-*]"!3/@DS81,N&3)B$R(E,:+3$C!3"C#3`G$2XQDF,A'C*18
XMS$2,U"C/P-&M.=1]9=DMH+!QJ````"XI+OXNVBV5UGU)TZT<#/@DS81,R%3*
XMATR(E,:+3$G`3#C"3!C$2XQDF,A(C)1HRT2,U"C/08T+_208T$*,]$C-1HRT
XMB,E)C(2XQDP8Q$PXPDQ)P$QHM,B)3*ATS(5,V$3/@DT<#3K4G6?87:(0V`JP
XM````+BX%`$4.@*`VM0```%,\-O4T$]DQ[)77L-5O%=52;38VT61\]UC+AXR8
XMFL.K"QO;&SM+.TML^YR[[%Q+_,M;L*`VM@```%,\-O4TN[7,O\3%OLNYS[:T
XML[2SL;VQL*PZF,F'C+A7SW1M%C;38O7546U;#LG743V3$*!@MP```%,V/_(T
XMP+^\Q;G'M\FURK2SR[#/K0G1C2?3?3?4;4;4]M1M5=5M7UU6U?75;5XEUMH0
XMK!XEUFUO76;6]=9M9=9M;VUFUFU7U7U7U8U)TZTK'1L\_*N,FYQ[S$P+\9!<
XMN@```%]"/_(TL+VMPJK$J,:FQZ6CR:',H,V<Z,]]!]!]%M%M'VT6TETFTO72
XM;2]=)M+J!=-M/UTVT_73;373;3]M-M-M)])])]*-&="@SZ'/I,S'J<:JQ*S"
XML;P0D%R[````7T(_\C0;RQPJS$JL:IQ\RDSZ'/H-"=&-)])])])M-M/VTVTU
XMTVT_73;3]=-NH--=)OTETFTO72;272;1]M%M%M%]!]!\^,Z<V@S*')HZ7'IL
XM:HQ*K"K;VP"09;X```!?0E/R/K&\K<*JQ*C&IL>EI,F@S*#-G.C/C/?0?1;1
XM;1]M%M)=)M)=)M+B72;2Z5TVT^)=-M-=-M-=-M/VTVTVTGTGTHT8T9T*#0H<
XMZDS,>IQJK$K<&QO``^K435+6/5/4$)!DOP```%]"4_(^&\L<&MQ*K&J<?,I,
XMZAT*#0G1C1C2?2?2;3;3]M-M-=-M-=-M/B73;ITUTFXM)=)M)=)M)=)M'VT6
XMT6T7T'SXSXSIS:#,H,FDI<>FQJC$JL*MO`!`+4/5/6+534.0$L@```!3/!GU
XM'QT!!Z'1ZHS5SC&P.\P```!!*BOU*L2M'$S,C)RL;.P]#!TKU)_6?87BVCXM
XMP0`5[B'</BVEV'_6G4O2P=##SL;*R<C,Q-&L0(#&S0```'AA4/4]KYC2HLFJ
XMPK"]M+F8EIBUE:"5L9.HDZV2KI*JD;*1J)"VD*60NI"BB^B@C`B>C"B<?&>:
XM?(>8?*>6?,>5;.:4;0:2]M)I!M1H765VUF9=A5;89/7:4VVF+B7<46W)+I#>
XMDMQN(5W%)MIC]=I4;895V%9M9G766&U&D/;2:2;0:4;.:5?,>6?*>8?(>:?&
XM><C"B>C`B@B^BBD+J0I9"VD*B1LI&JDJZ2K9.HD[&5H)6UF):8N;2]L,*JR:
XM+2F*\+`VS@```#8D4/4]Q$TVT>>-'D;3XTU2QVDI8[4EL<,B($HB+#&U);-I
XM*6QN--/C;1[+C1[!;3Y4Q+!;SP```#8D4/4]Q$TVT>:-'C;3XDQFDI8[4EL<
XM,B($HB+#&F)J-I*6QN)-/C;1YHT6TT`H33;1YHT>)M/B3(&TP!27)Y'!0D!J
XM0DP1ER>4*TLL?B33XFT>:-%M-,2P;=4````X+5#U/=5MFM;`U&-=)E7156T&
XM2.+.9)S72<UEG-9GS7=<[B?:;:XWV?C9XGV>.-E]GDC8G8XXV)V.2-E]GCC9
XMXGV?C9XWVFVN)\U8?,=VS)9LR5?,^5;-E5SH5L]F705ETE-M3`UJV6U0P,C8
XM````02Q)]D(!0P&_4!E@&5W*1=G9U]K6B)U7Q]1M)])M.-!M.K;4NFT\GVU%
XM)G;48V9M1497U%1T?39'1]-5<WTV9R]]-7<GTF=R?26'&-)8T]%HT_T5G3T&
XMG3T%K3QJT_Q;T[:]/[7-.FS3I=#3EM#3^5T=.&T=.%TH%X72<G=M)R=UTW*&
XM72@H5M*#=5TW1T;3='1=1U9%U&9R;3=G)=1W8EU&G--JO4:ZTVT(TVTGTFU'
XMQ]68C6VM?9V52MQ0&6`9]0&S`4"A%-D```!425/[/\2PW[C8OM/"S[&;',FV
XMG*>\?'?`?$;$;";&;`;(:^7,6\7.6Z706X726W342V746T766R786Q3:2P7:
XM6DW$E=Q83>1UWE9,&+Q&2^.#N45;P[(K=42\.U&W1$NSMQMD-;H[D;522Z2Y
XM&V0DN4MUM4)+E+9K5!6X2W:UFY2W:VBX6W:VBX6X2WC[A,^.>W7/FV7.7Q2W
XM3.0DMUS4);9<Q3]+=+P;1$6W2Z&T54MTNAM$9+A+@;5&6X.X&T5TN3MAM4A;
XMD[0;592Z.Q*V2ENT<K=;!+Z+E+%=A;)=9;1=1;9-1+==);A=!;I<Y;Q<Q;YL
XMAL!L9L)L1L1\!\=[Q\J;:<RQFQS\+3OMBXW[#$!0$=H````S*"K[*1@!UN>W
XMK6&`$(@,X````$H86^!""Q[7E<@-X0```$H86^!$X$.M$..@.N(```!*&UO@
XM0KQ+IKE[B+>+>+>+>+>+>+>+>;:;>+>;:;>+>;>+?YMOFV^;:K;YMN*K:;;D
XMJVFV[9JVP$/C````2AQ=\D35[=KBU*U/K4K5G5G5K4K4K4G5G5G4G5G4G3K5
XMC77:C7K8G8G7G8G7G7G7K6K6K6G7G6K6^M;BK6[=H*@XY````$H;6^!$[9JW
XMFWY*MYM^*K?YMZM_FX^;CYN(N)N(N)N)N(N)N)N(N8N8N8N8N8N8N8N7NFO$
XMR`WP````2AE;[T(.W@0]*H`,\0```$H96^]$ENUPNZ@X\@```$H<6_)"2]:[
XM>ZBZFYFYFYFYFYFYFYBZBYFYFYBYFY^;GYN?FXJX^;BKCYN/JXFXY*N)N.V:
XMR$/S````2AM=X$3MVM7BK5^M6M6=6M6M6=:=:=:=>=:=>=>->M=]E==]2M.-
XM2=.=2=.=2=2=2=2M.M2=2M/ZT^*M/MVM0*`Z]````$H<6_)$M^V:MYM^2K>;
XM?ZM_FWJW^;>K?YM_FW^;>;B+B;>;B+B+B;>;>;>;>;>;>;>+E[IKM+W8"_4`
XM``!*"EW@1``Z0!@)]@```%Q;`@`9U'!E^P```'AA-?4OG$U&TUTVTFTUTVTF
XMTFTUTVTFTFTKV2P8_"CL.,Q8M]"`SX'.@<V#RX3*A<B'RH7,A\Z%SX30@]&!
XMTH'2@--]/%CL./PI#!DKV5;4;4;474;4;4;474;4;474;42QV`O\````,R@J
XM^RD`:2!P9?T```!X837U+[%-1M1=1M1M1=1M1M1M1=1M1M1I6]DL&0PH_#CL
XM73?3@-*!TH'1@]"$SX7.A\R%RH?(A<J$RX/-@<Z!SX#0>+Q8S#CL*/P9*]TF
XMTFTFTUTVTFTFTUTVTFTUTVU$G)`=_@```%](2_5#N3VDVNMEN-P0GAW+GK-;
X(C<$)X=P0]?8F
X`
Xend
END_OF_FILE
  if test 13015 -ne `wc -c <'fonts.lj/S.22.pk.UU'`; then
    echo shar: \"'fonts.lj/S.22.pk.UU'\" unpacked with wrong size!
  fi
  # end of 'fonts.lj/S.22.pk.UU'
fi
if test -f 'utils.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils.c'\"
else
  echo shar: Extracting \"'utils.c'\" \(12801 characters\)
  sed "s/^X//" >'utils.c' <<'END_OF_FILE'
X/*
X	Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991 Chris Lewis
X		All Rights Reserved
X
X    See the LICENSE file for a full description of restrictions under which
X    this software is provided.
X
X    Function:		Utility functions (font loads, prologs etc.)
X */
X
X#include "defs.h"
X
X#ifndef	lint
Xstatic char SCCSid[] =
X    "@(#)utils.c: 2.14 Copyright 91/04/05 01:21:20 Chris Lewis";
X#endif
X
X#ifndef	HEADERSIZE
X#	ifdef COFF
X#		include <aouthdr.h>
X#		include <filehdr.h>
X#		include <scnhdr.h>
X#		include <ldfcn.h>
X#		include <reloc.h>
X#		define H1 (sizeof (struct filehdr) + sizeof (struct aouthdr))
X#		define H2 (sizeof (struct scnhdr) + sizeof (struct reloc))
X#		define HEADERSIZE (H1 + H2)
X#	else
X#		include <a.out.h>
X#		define HEADERSIZE (sizeof (struct exec))
X#	endif
X#endif
X
Xextern struct cattab tabN[], tabS[];
X
Xint lastFont, lastPoints;
Xint lastYPos, lastXPos;
X
Xint symidx = 3;		/* Default on otroff, otroff doesn't necessarily
X			   emit loads either */
X
Xint extcount = 0;
Xstruct troff2befont *extchars;
Xstruct cattab *extidx;
X
Xextern char *malloc();
X
Xchar *skipblanks(p)
Xregister char *p; {
X    while (*p && isspace(*p)) p++;
X    return(p);
X}
X
Xchar *gettok(p, bp)
Xregister char *p, *bp; {
X    p = skipblanks(p);
X    while(*p && !isspace(*p)) *bp++ = *p++;
X    *bp = '\0';
X    return(p);
X}
X
Xinterp(buf, xlator, suf)
Xchar *buf, *suf; FUNC xlator; {
X    register char *p;
X    char token[512];
X    p = gettok(buf, token);
X    if (0 == strcmp(token, "include") || 0 == strcmp(token, "binclude")) {
X	int binary;
X	FILE *inc;
X	binary = (token[0] == 'b') ? 1: 0;
X	p = gettok(p, token);
X	DBP((D_SPEC, "Trying to include %s\n", token));
X	if (!(inc = fopen(token, "r"))) {
X	    strcat(token, ".");
X	    strcat(token, suf);
X	    DBP((D_SPEC, "Trying to include %s\n", token));
X	    if (!(inc = fopen(token, "r"))) {
X		char nbuf[512];
X		if (token[0] != '/') {
X		    sprintf(nbuf, "%s/%s", LIBDIR, token);
X		    DBP((D_SPEC, "Trying to include %s\n", nbuf));
X		    inc = fopen(nbuf, "r");
X		}
X	    }
X	}
X	if (!inc) {
X	    fprintf(stderr, "%s: cannot open file %s\n", progname, token);
X	    exit(1);
X	} else {
X	    DBP((D_SPEC, "Successfull include\n"));
X	    if (binary || !xlator)
X		while ((binary = fread(token, 1, sizeof(token), inc)) > 0)
X		    fwrite(token, 1, binary, stdout);
X	    else
X		(*xlator)(inc);
X	    fclose(inc);
X	}
X    }
X
X    else {
X	fprintf(stderr, "%s: unknown directive: %s\n", progname, token);
X	exit(1);
X    }
X}
X
Xchar nodename[25];
Xgetnodename() {
X    FILE *popen();
X    FILE *uuname;
X    if ((uuname = popen(NODECMD, "r")) == NULL)
X	strcpy(nodename, "<noname>");
X    else {
X	fscanf(uuname, "%s", nodename);
X	if (pclose(uuname))
X	    strcpy(nodename, "<noname>");
X    }
X}
X
Xstruct fonttable fonttable[MAXFONTS+1];
Xstruct fonttable *xlatetable[INTFONTS];
X
X#define	READFONT	0
X#define	READNORM	1
X#define	READSYMB	2
X#define	READEXT		3
X
Xloadfont(normfont, symfont)
Xstruct troff2befont *normfont, *symfont; {
X
X    char buffer[BUFSIZ];
X    char *buf[6];
X    int tableindex;
X    int state, i, count;
X    register char *first;
X    extern int atoi();
X    struct cattab *tab;
X    struct troff2befont *otab;
X    int done;
X
X    FILE *fontfile;
X
X    for (i = 0; i < 6; i++)
X	buf[i] = mustmalloc(64, "loadfont");
X
X    for (tableindex = 0; tableindex < INTFONTS; tableindex++) {
X	xlatetable[tableindex] = &fonttable[tableindex];
X    }
X
X    fontfile = libopen(printer, "fonts");
X
X    tableindex = 0;
X
X    state = READFONT;
X
X    while(fgets(buffer, sizeof(buffer), fontfile)) {
X
X	first = buffer;
X
X	for(;*first && isspace(*first); first++);
X
X	if (!*first || *first == '#')
X	    continue;
X
X	switch(count = sscanf(first, "%s%s%s%s%s%s",
X	    buf[0], buf[1], buf[2], buf[3], buf[4], buf[5])) {
X	    case 1: buf[1][0] = '\0';
X	    case 2: buf[2][0] = '\0';
X	    case 3: buf[3][0] = '\0';
X	    case 4: buf[4][0] = '\0';
X	    case 5: buf[5][0] = '\0';
X	    case 6:
X		if        (strcmp(buf[0], "normal") == 0) {
X		    state = READNORM;
X		    break;
X		} else if (strcmp(buf[0], "symbol") == 0) {
X		    state = READSYMB;
X		    break;
X		} else if (strcmp(buf[0], "extensions") == 0) {
X		    state = READEXT;
X		    break;
X		}
X		switch(state) {
X		    case READFONT:
X			if (tableindex == MAXFONTS) {
X			    fprintf(stderr, "%s: Too many fonts for %s!\n",
X				progname, printer);
X			    exit(1);
X			}
X			for(i = 0; i < 4; i++) {
X			    first = mustmalloc(strlen(buf[i])+1,
X				"fonttable");
X			    strcpy(first, buf[i]);
X			    fonttable[tableindex].tab[i] = first;
X			}
X#ifdef	OPT
X			fonttable[tableindex].widthtable = (char *) NULL;
X#endif
X			tableindex++;
X			break;
X		    case READNORM: case READSYMB: case READEXT:
X			done = 0;
X			if (count <= 1) {
X			    fprintf(stderr, "%s: bad %s.fonts line: %s\n",
X				progname, printer, buffer);
X			    exit(1);
X			}
X
X			if (state == READEXT) {
X			    if (!(extcount % EXTCHUNK)) {
X				if (!extchars) {
X				    extchars = (struct troff2befont *)
X					mustmalloc(EXTCHUNK *
X					sizeof(struct troff2befont), "extchars");
X				    extidx = (struct cattab *)
X					mustmalloc((1 + EXTCHUNK) *
X					sizeof(struct cattab), "extidx");
X				} else {
X				    extchars = (struct troff2befont *)
X					realloc((char *) extchars,
X					    (extcount + EXTCHUNK + 1) *
X					    sizeof(struct troff2befont));
X				    extidx = (struct cattab *)
X					realloc((char *) extidx,
X					    (extcount + EXTCHUNK + 1) *
X					    sizeof(struct cattab));
X				    clrarray(&extchars[extcount],
X					EXTCHUNK * sizeof(struct troff2befont));
X				    clrarray(&extidx[extcount],
X					EXTCHUNK * sizeof(struct cattab));
X				}
X			    }
X
X			    extidx[extcount].ch_name = mustmalloc(strlen(buf[0])
X				+ 1, "extend");
X			    strcpy(extidx[extcount].ch_name, buf[0]);
X
X			    extidx[extcount].ch_catidx = extcount;
X			    addchar(&extchars[extcount], buf, count, buffer);
X			    extidx[extcount].ch_set = extchars[extcount].t2b_font;
X			    extidx[extcount].ch_wididx = NTC;
X			    extidx[extcount].ch_desc = "Ext";
X
X			    extcount++;
X			    extidx[extcount].ch_name = NOC;
X			    done = 1;
X			} else {
X			    if (state == READNORM) {
X				tab = tabN;
X				otab = normfont;
X			    } else {
X				tab = tabS;
X				otab = symfont;
X			    }
X
X			    for (i = 0; tab[i].ch_name; i++) {
X				if (strcmp(tab[i].ch_name, buf[0]) == 0) {
X				    addchar(&otab[i], buf, count, buffer);
X				    done = 1;
X				    break;
X				}
X			    }
X			}
X			if (!done) {
X			    fprintf(stderr, "%s: couldn't apply %s.fonts: %s\n",
X				progname, printer, buffer);
X			    exit(1);
X			}
X		}
X	}
X    }
X    fclose(fontfile);
X#ifdef	OPT
X    loadwidth(xlatetable[0]);
X    loadwidth(xlatetable[1]);
X    loadwidth(xlatetable[2]);
X    loadwidth(xlatetable[3]);
X#endif
X    for (i = 0; i < 6; i++)
X	free(buf[i]);
X}
X
Xaddchar(p, fontentry, count, buffer)
Xregister struct troff2befont *p;
Xchar *fontentry[];
Xchar *buffer;
Xint count; {
X    register char *first;
X    switch(fontentry[1][0]) {
X	case 'N':
X	    p->t2b_font = N; break;
X	case 'S':
X	    p->t2b_font = S; break;
X	case 'D':
X	    p->t2b_font = D; break;
X	case '0':
X	case '1':
X	case '2':
X	case '3':
X	case '4':
X	case '5':
X	case '6':
X	case '7':
X	case '8':
X	case '9':
X	    p->t2b_font = atoi(fontentry[1]);
X	    break;
X	default:
X	    fprintf(stderr, "%s: bad font in %s\n",
X		progname, buffer);
X	    exit(1);
X    }
X    switch(count) {
X	case 6:
X	    p->t2b_scale = atoi(fontentry[5]);
X	case 5:
X	    p->t2b_yc = atoi(fontentry[4]);
X	case 4:
X	    p->t2b_xc = atoi(fontentry[3]);
X	case 3:
X	    octdecode(fontentry[2]);
X	    first = mustmalloc(strlen(fontentry[2]) + 1,
X		"fonttable");
X	    strcpy(first, fontentry[2]);
X	    p->t2b_charseq = first;
X    }
X}
X
X/*	Translate any octal escapes *inplace* */
Xoctdecode(str)
Xregister char *str; {
X    register char *from, *to;
X    int tmp, i;
X    from = to = str;
X    while(*from) {
X	if (*from != '\\')
X	    *to++ = *from++;
X	else {
X	    tmp = 0;
X	    from++;
X	    i = 3;
X	    while(i-- > 0 && *from && *from >= '0' && *from <= '7')
X		tmp = (tmp << 3) + *from++ - '0';
X	    *to++ = tmp&0xff;
X	}
X    }
X    *to++ = '\0';
X}
X
X
Xdumpsequence(sequence)
Xregister char *sequence; {
X    printf("\t");
X    for(;*sequence;sequence++)
X	if (isascii(*sequence) && isprint(*sequence))
X	    printf("%c", *sequence);
X	else
X	    printf("\\%03o", (*sequence)&0xff);
X}
X
Xdumpline(name, tp)
Xregister char *name;
Xregister struct troff2befont *tp; {
X    if (name != NOC) {
X	printf("%s\t", name);
X	switch(tp->t2b_font) {
X	    case N: printf("N"); break;
X	    case S: printf("S"); break;
X	    case D: printf("D"); break;
X	    default: printf("%d", tp->t2b_font); break;
X	}
X	dumpsequence(tp->t2b_charseq);
X	printf("\t%d\t%d\t%d", tp->t2b_xc, tp->t2b_yc, tp->t2b_scale);
X	printf("\n");
X    }
X}
X
Xdumplist(namelist, tp)
Xregister struct cattab *namelist;
Xregister struct troff2befont *tp; {
X    register int i;
X    for (i = 0; namelist[i].ch_name && namelist[i].ch_catidx != NTC;
X	i++, tp++) {
X	if (strlen(namelist[i].ch_name) == 0)
X	    continue;
X	if (strcmp(namelist[i].ch_name, "hy") == 0)
X	    dumpline("-", tp);
X	dumpline(namelist[i].ch_name, tp);
X    }
X}
X
Xdumptables(bep)
Xstruct backend *bep; {
X    if (!bep) {
X	fprintf(stderr, "%s: no backend selected for table dump\n", progname);
X	exit(1);
X    }
X    printf("normal\n");
X    dumplist(tabN, bep->bestdfont);
X    printf("symbol\n");
X    dumplist(tabS, bep->besymfont);
X    if (extchars) {
X	printf("extensions\n");
X	dumplist(extidx, extchars);
X    }
X}
X
XFontSel(from, to)
Xchar from, *to; {
X#ifdef	DEBUG
X    register int i;
X#endif
X    register struct fonttable *p;
X    int intfont;
X    DBP((D_SPEC, "FontSel: %c -> %s\n", from, to));
X    if (from < (ditroff? '0' : '1') || from > '9') {
X	fprintf(stderr, "Bad arguments to FontSel: %c %s\n", from, to);
X	return;
X    }
X    intfont = from - '1';
X    if (intfont < 0)
X	intfont = INTFONTS - 1;
X    if (strcmp(to, "S") == 0) {
X	symidx = intfont;
X	DBP((D_CAT, "Special font is: %d\n", symidx));
X    }
X
X    for (p = fonttable; p->troffName; p++)
X	if (strcmp(p->troffName, to) == 0) {
X	    xlatetable[intfont] = p;
X	    break;
X	}
X    if (!p->troffName) {
X	fprintf(stderr, "Could not translate font %c (%s)\n", from, to);
X    }
X#ifdef	OPT
X    if (p->troffName && !p->widthtable)
X	loadwidth(p);
X#endif
X
X#ifdef	DEBUG
X    for (i = 0; i < INTFONTS; i++)
X	if (xlatetable[i])
X	    DBP((D_SPEC, "Font %d->%s\n", i+1, xlatetable[i]->fontName));
X#endif
X}
X
XFILE *libopen(pref, suf)
Xregister char *pref, *suf; {
X
X    register char *buffer = mustmalloc(strlen(LIBDIR) + 50, "libopen");
X    register FILE *library;
X
X    sprintf(buffer, "%s.%s", pref, suf);
X    if ((library = fopen(buffer, "r")) == NULL) {
X	sprintf(buffer, "lib/%s.%s", pref, suf);
X	if ((library = fopen(buffer, "r")) == NULL) {
X	    sprintf(buffer, "%s/%s.%s", LIBDIR, pref, suf);
X	    if ((library = fopen(buffer, "r")) == NULL) {
X		fprintf(stderr, "Cannot find %s.%s in . or lib or %s\n", pref, suf,
X		    LIBDIR);
X		exit(1);
X	    }
X	}
X    }
X    free(buffer);
X    return(library);
X}
X
XresetState() {
X    lastFont = -1;
X    lastPoints = -1;
X    lastYPos = -1;
X    lastXPos = -1;
X}
X
Xdoprologs() {
X    if (!prologs)
X	return;
X    while(*prologs)
X	dospecial(*prologs++);
X}
X
X#ifdef	OPT
Xloadwidth(p)
Xstruct fonttable *p; {
X    FILE *f;
X    int c;
X    if ((int) p->widthtable == 1)
X	return;
X    p->widthtable = mustmalloc(224, "widthtable");
X    strcpy(widthptr, "ft");
X    strcat(widthptr, p->troffName);
X    DBP((D_SPEC, "Attempting to read font file %s\n", widthtables));
X    if (f = fopen(widthtables, "r")) {
X	for (c = 0; c < HEADERSIZE; c++) getc(f);
X#ifdef	ASCIIWIDTHS
X	if (widread(p->widthtable, f)) {
X#else
X	if (224 != fread(p->widthtable, 1, 224, f)) {
X#endif
X	    fprintf(stderr, "%s: badly formed width table %s\n",
X		progname, widthtables);
X	    free(p->widthtable);
X	    p->widthtable = (char *) 1;
X	    DBP((D_SPEC, "Load of %s failed\n", widthtables));
X	} else {
X	    for (c = 0; c < 224; c++)
X		p->widthtable[c] &= 0x3f;
X	    DBP((D_SPEC, "Load of %s succeeded\n", widthtables));
X	}
X    } else {
X	DBP((D_SPEC, "Failed to open widthtable %s\n", widthtables));
X	free(p->widthtable);
X	p->widthtable = (char *) 1;
X    }
X}
X
X#ifdef	ASCIIWIDTHS
Xwidread(widths, f)
Xchar *widths;
XFILE *f; {
X    int v, i;
X    for (i = 0; i < 224; i++)
X	if (fscanf(f, "%d", &v) != 1)
X	    return(1);
X	else
X	    widths[i] = v;
X    return(0);
X}
X#endif
X
X#endif
X
X#ifdef	NULLCHECK
Xmab() {
X    fprintf(stderr, "KABOOM\n");
X    abort();
X}
X#endif
X
Xdrawparse(ct, values, str)
Xint *ct;
Xshort *values;
Xchar *str; {
X    int opcode, neg, temp;
X
X    *ct = 0;
X    while(*str && isspace(*str)) str++;
X    opcode = *str;
X    neg = 1;
X    for (;*str;str++) {
X	if (isspace(*str))
X	    continue;
X	else if (*str == '\\')
X	    str += 3;
X	else if (*str == '-')
X	    neg = -1;
X	else if (!isdigit(*str))
X	    continue;
X	else {
X	    temp = *str - '0';
X	    while(isdigit(*(str+1)))
X		temp = temp * 10 + (*++str - '0');
X	    values[(*ct)++] = neg * temp;
X	    neg = 1;
X	}
X    }
X    return(opcode);
X}
END_OF_FILE
  if test 12801 -ne `wc -c <'utils.c'`; then
    echo shar: \"'utils.c'\" unpacked with wrong size!
  fi
  # end of 'utils.c'
fi
if test -f 'utils/psxlate.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/psxlate.c'\"
else
  echo shar: Extracting \"'utils/psxlate.c'\" \(12922 characters\)
  sed "s/^X//" >'utils/psxlate.c' <<'END_OF_FILE'
X/*
X	Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991 Chris Lewis
X		All Rights Reserved
X
X    See the LICENSE file for a full description of restrictions under which
X    this software is provided.
X
X    Function:		Generic Postscript filter (page reversal etc.)
X */
X
X/* If you wish to add new shuffle algorithms, you will have to:
X	- update the getopt for the new option letter (see /OPTION/)
X	  by adding the new option letter to the getopt string.
X	- update the argument parsing to recognize the new option
X	  (/OPTIONPARSE/) by adding a case clause.
X	- update the "transform" routine to call your shuffle function,
X	  selected upon the option letter.
X	- add a new transform routine (see the "o_" functions for
X	  samples)
X   If you write one, please let me know and I'll reintegrate it
X   into the original.  Please note: I will assume that any contributions
X   are public domain.
X */
X#ifndef	lint
Xstatic char SCCSid[] =
X    "@(#)psxlate.c: 2.11 Copyright 91/03/26 00:13:16 Chris Lewis";
X#endif
X
X#ifdef	ALONE
X#include <stdio.h>
X#include <ctype.h>
X#else
X#include "defs.h"
X#endif
X
Xint	xlate = 0;
Xextern int	italic = 0;
Xint	needd = 0;
X#define	BUFFERSIZE	512
X
Xint	half = 0;	/*	Controls emitter, 0: whole file, 1: first half,
X				2: second half */
X
X/* define if you want to page flip %! documents (eg: some TeX out stuff)
X   not recommended....
X */
X#undef	TRYPERBANG
X
Xstruct range {
X    int start;
X    int end;
X} ranges[100];
X
Xint ri;
X
Xstruct pagedesc {
X    unsigned long start;
X    unsigned long end;
X} pageidx[MAXPAGE], prolog, epilog;
X
Xstruct pagedesc blankpage = {-1, -1};
X
Xchar shuffle[100];
X
Xchar tmp[] = {"/tmp/psxXXXXXX"};
X
Xint pagecnt = 0;
Xchar *progname;
Xint debug, verbose;
Xchar *mygets();
X
X#ifndef	LIBDIR
X#define	LIBDIR	"/usr/lib/troff2"
X#endif
X
Xchar	cmdbuffer[BUFFERSIZE];	/* for psnup stuff */
Xint	psnupok = 0, psnupwanted = 0;
Xint	reversed = 0, pages = 2, startspot = 0;
X
Xchar *magicstr;
X
XFILE *tempfile;
X
Xmain(argc, argv)
Xint argc; char **argv; {
X    extern int optind;
X    extern char *optarg;
X    char *buffer;
X    int c;
X    char *si = shuffle;
X    long offset, oldoffset;
X
X    progname = argv[0];
X
X
X    while ((c = getopt(argc, argv, "i2drbcvBEn:p:s:")) != EOF)	/* OPTION */
X	switch(c) {
X	    /* OPTIONPARSE */
X	    case '2':
X	    case 'r':
X	    case 'b':
X	    case 'c':
X		*si++ = c;
X		if (c == 'r')
X		    reversed = 1;
X		break;
X	    case 'i':
X		italic = 1;
X		break;
X	    case 'p':
X		psnupwanted = 1;
X		pages = atoi(optarg);
X		if (pages != 2 && pages != 4 && pages != 8 && pages != 16) {
X		    fprintf(stderr, "%s: -p must be 2, 4, 8 or 16\n",
X			progname);
X		    exit(1);
X		}
X		break;
X	    case 's':
X		psnupwanted = 1;
X		startspot = atoi(optarg);
X		break;
X	    case 'E': half++;
X	    case 'B': half++;
X		break;
X	    case 'd': debug = 1; break;
X	    case 'v': verbose = 1; break;
X	    case 'n':
X		readranges(optarg);
X		break;
X	    default:
X		usage();
X		exit(1);
X	}
X
X    if (psnupwanted) {
X	psnupok = 1;
X	if (startspot < 0 || startspot >= pages) {
X	    fprintf(stderr, "%s: -s (%d) must be 0..%d (-p%d - 1)\n",
X		progname, startspot, pages - 1, pages);
X	    psnupok = 0;
X	}
X	sprintf(cmdbuffer, "%s/nup.pro", LIBDIR);
X	if (access(cmdbuffer, 4) != 0) {
X	    fprintf(stderr, "%s: can't do n-up (no nup.pro at %s)\n",
X		progname, cmdbuffer);
X	    psnupok = 0;
X	}
X	sprintf(cmdbuffer, "%s/nup.epi", LIBDIR);
X	if (access(cmdbuffer, 4) != 0) {
X	    fprintf(stderr, "%s: can't do n-up (no nup.epi at %s)\n",
X		progname, cmdbuffer);
X	    psnupok = 0;
X	}
X	if (!psnupok)
X	    exit(1);
X    }
X
X    if (debug) {
X	fprintf(stderr, "startspot: %d\n", startspot);
X	fprintf(stderr, "pages: %d\n", pages);
X	fprintf(stderr, "reversed: %d\n", reversed);
X	fprintf(stderr, "psnupwanted: %d\n", psnupwanted);
X	fprintf(stderr, "xlate: %s\n", shuffle);
X	for (c = 0; c < ri; c++)
X	    fprintf(stderr, "RANGE %d: %d-%d\n", c, ranges[c].start, ranges[c].end);
X    }
X
X    mktemp(tmp);
X    tempfile =  fopen(tmp, "w");
X    if (!tempfile) {
X	fprintf(stderr, "%s: couldn't open temp file %s\n",
X	    progname, tmp);
X	exit(1);
X    }
X    if (buffer = mygets(stdin, tempfile, &offset)) {
X	if (strncmp(buffer, "%!PS-Adobe-", 11) == 0) {
X	    if (verbose || debug)
X		fprintf(stderr, "DEBUG: conformant Postscript file %s\n", buffer);
X
X	    scan(stdin, tempfile, buffer);
X	    stripbyrange();
X	    transform();
X	    emit(tmp);
X	} else if (strncmp(buffer, "%!", 2) == 0) {
X	    if (verbose || debug)
X		fprintf(stderr, "DEBUG: nonconformant Postscript file %s\n", buffer);
X	    fputs(buffer, stdout);
X	    while ((c = fread(buffer, 1, sizeof(buffer), stdin)) > 0)
X		fwrite(buffer, 1, c, stdout);
X	} else {
X	    if (verbose || debug)
X		fprintf(stderr, "DEBUG: non-Postscript file %s\n", buffer);
X	    asc2ps(buffer);
X	    stripbyrange();
X	    transform();
X	    emit(tmp);
X	}
X    }
X    cleanup();
X    exit(0);
X}
X
X/*	States: */
X#define	PROLOG	0
X#define	PAGES	1
X#define	EPILOG	2
X
X/*	What we've just seen */
X#define	S_NONE	0
X#define	S_EOF	1
X#define	S_PAGE	2
X#define	S_EPI	3
X
Xscan(in, out, buffer)
XFILE *in;
XFILE *out;
Xchar *buffer; {
X    extern char *malloc();
X    long offset;
X    int state = PROLOG;
X    int seen;
X
X    magicstr = malloc(strlen(buffer) + 1);
X    strcpy(magicstr, buffer);
X
X    while(1) {
X	buffer = mygets(in, out, &offset);
X
X	if (!prolog.start)
X	    prolog.start = offset;
X
X	if (!buffer)
X	    seen = S_EOF;
X	else if (buffer[0] == '%') {
X	    if (strncmp(buffer, "%%Page:", 7) == 0)
X		seen = S_PAGE;
X	    else if (strncmp(buffer, "%%Trailer", 9) == 0)
X		seen = S_EPI;
X	    else
X		seen = S_NONE;
X	} else
X	    seen = S_NONE;
X	switch(seen) {
X	    case S_NONE:
X		continue;
X	    case S_EOF:
X		switch(state) {
X		    case PROLOG:
X			prolog.end = offset - 1;
X			break;
X		    case PAGES:
X			pageidx[pagecnt].end = offset - 1;
X			pagecnt++;
X			break;
X		    case EPILOG:
X			epilog.end = offset - 1;
X			break;
X		}
X		fclose(out);
X		if (psnupwanted)
X		    append(pages);
X		return;
X	    case S_PAGE:
X		switch(state) {
X		    case PROLOG:
X			prolog.end = offset - 1;
X			state = PAGES;
X			pagecnt = 0;
X			if (psnupwanted)
X			    while(startspot) {
X				pageidx[pagecnt++].start = -1;
X				startspot--;
X			}
X			break;
X		    case PAGES:
X			pageidx[pagecnt].end = offset - 1;
X			pagecnt++;
X			break;
X		}
X		pageidx[pagecnt].start = offset;
X		break;
X	    case S_EPI:
X		switch(state) {
X		    case PROLOG:
X			prolog.end = offset - 1;
X			break;
X		    case PAGES:
X			pageidx[pagecnt].end = offset - 1;
X			pagecnt++;
X			break;
X		}
X		epilog.start = offset;
X		state = EPILOG;
X		break;
X	}
X    }
X}
X
Xcleanup() {
X    if (!debug)
X	unlink(tmp);
X}
X
Xemit(fname)
Xchar *fname; {
X    register int i, start, end;
X    FILE *file;
X    if ((file = fopen(fname, "r")) == NULL) {
X	fprintf(stderr, "Panic %s\n", fname);
X	exit(1);
X    }
X
X    if (magicstr)
X	fputs(magicstr, stdout);
X
X    if (psnupwanted) {
X	sprintf(cmdbuffer, "%s/nup.pro", LIBDIR);
X	emitnup(cmdbuffer, 1);
X    }
X
X    emitsect(file, &prolog);
X
X    start = 0;
X    end = pagecnt - 1;
X
X    if (half == 1)
X	end = end / 2;
X    else if (half == 2)
X	start = end / 2 + 1;
X
X    for (i = start; i <= end; i++)
X	emitsect(file, &pageidx[i]);
X
X    emitsect(file, &epilog);
X
X    if (psnupwanted) {
X	sprintf(cmdbuffer, "%s/nup.epi", LIBDIR);
X	emitnup(cmdbuffer, 0);
X    }
X
X    if (needd)
X	putchar('\004');
X}
X
Xemitsect(file, sect)
XFILE *file;
Xstruct pagedesc *sect; {
X    long start, end, cnt;
X
X    if (sect->start == 0 && sect->end == 0)
X	return;
X
X    if (sect->start == -1) {
X	printf("%%%%Page: ? x\n");
X	printf("showpage\n");
X	return;
X    }
X
X    start = sect->start;
X    end = sect->end;
X    cnt = end - start + 1;
X
X    if (debug)
X	fprintf(stderr, "Emitting a section: %d/%d(%d)\n", start, end, cnt);
X
X    fseek(file, start, 0);
X    while(cnt--)
X	putchar(getc(file));
X}
X
Xusage() {
X    fprintf(stderr,
X	"Usage: %s [-b2rc*] [-pn] [-sn] [-B|-E] [-n...] < file > file\n",
X	progname);
X}
X
Xdumppg() {
X    register int i;
X    if (!debug)
X	return;
X    fprintf(stderr, "Prolog: %d %d\n", prolog.start, prolog.end);
X    for (i = 0; i < pagecnt; i++)
X	fprintf(stderr, "%d: %d %d\n", i, pageidx[i].start, pageidx[i].end);
X    fprintf(stderr, "Epilog: %d %d\n", epilog.start, epilog.end);
X}
X
X
Xtransform() {
X    register char *p = shuffle;
X    dumppg();
X    while(*p) {
X	switch(*p++) {
X	    case '2':
X		o_duplex();
X		break;
X	    case 'r':
X		o_reverse();
X		break;
X	    case 'b':
X		o_book();
X		break;
X	    case 'p':
X		o_dupswap();
X		break;
X	}
X    }
X    dumppg();
X}
X
X/*	Make the number of pages a multiple of n,
X	by appending blank pages
X */
Xappend(n)
Xint n; {
X    while(pagecnt % n)
X	pageidx[pagecnt++] = blankpage;
X}
X
X/*	1 2 3 4 5 6 7 8 -> 1 3 5 7 ... 2 4 6 8 */
Xo_duplex() {
X    register int i, mid;
X    struct pagedesc t;
X    struct pagedesc *p;
X
X    append(2);
X
X    p = (struct pagedesc *) malloc(sizeof(struct pagedesc) * pagecnt);
X
X    mid = pagecnt / 2;
X
X    for (i = 0; i < mid; i++) {
X	p[i] = pageidx[i * 2];
X	p[i+mid] = pageidx[i * 2 + 1];
X    }
X
X    memcpy(pageidx, p, sizeof(struct pagedesc) * pagecnt);
X    free(p);
X}
X
Xo_dupswap() {
X    register int i, j;
X    struct pagedesc t;
X
X    append(2);
X
X    i = 0;
X    j = pagecnt - 1;
X
X    while(i < j) {
X	t = pageidx[i];
X	pageidx[i] = pageidx[j - 1];
X	pageidx[j - 1] = t;
X	t = pageidx[i+1];
X	pageidx[i+1] = pageidx[j];
X	pageidx[j] = t;
X	i+=2;
X	j-=2;
X    }
X}
X
Xo_reverse() {
X    register int i, j;
X    struct pagedesc t;
X
X    i = 0;
X    j = pagecnt - 1;
X
X    while(i < j) {
X	t = pageidx[i];
X	pageidx[i] = pageidx[j];
X	pageidx[j] = t;
X	i++;j--;
X    }
X}
X
Xo_book() {
X    struct pagedesc *p;
X    int i, mid, end;
X    /*  1 2 3 4 5 6 7 8 ... n -> n 1 n-2 3 n-4 5        2 n-1 4 n-3 ... */
X
X    append(4);
X
X    p = (struct pagedesc *) malloc(sizeof(struct pagedesc) * pagecnt);
X    mid = pagecnt / 2;
X    for (i = 0, end = pagecnt - 1; i < mid; i += 2, end -= 2) {
X	p[i] = pageidx[end];
X	p[i+1] = pageidx[i];
X    }
X    for (i = mid, end = pagecnt - 1; i < pagecnt; i += 2, end -= 2) {
X	p[i] = pageidx[i - mid + 1];
X	p[i+1] = pageidx[end-1];
X    }
X    memcpy(pageidx, p, sizeof(struct pagedesc) * pagecnt);
X    free(p);
X
X}
X
X/*	Read one line of file in, writing as we go to out,
X	storing the file offset of the beginning of the file
X	thru *count;
X */
X#define	CHUNK	512
Xchar *mygets(in, out, count)
XFILE *in, *out; long *count; {
X    static char *buffer = NULL;
X    static long buflimit;
X    static long curcount = 0;
X
X    register char *p;
X    register long curlength;
X    register int ch;
X    extern char *realloc();
X
X    if (count != (long *) NULL)
X	*count = curcount;
X
X    if (buffer == NULL) {
X	buffer = malloc(4096);
X	buflimit = 4096;
X    }
X
X    p = buffer;
X    while((ch = getc(in)) != EOF) {
X	putc(ch, out);
X	curcount++;
X	if (p - buffer > buflimit-3) {
X	    buflimit += CHUNK;
X	    buffer = realloc(buffer, buflimit);
X	}
X	*p++ = ch;
X	if (ch == '\n')
X	    break;
X    }
X
X    *p = '\0';
X
X    if (p == buffer)	/* EOF */
X	return(NULL);
X    else if (buffer[0] == '\004' && !buffer[1]) {
X	needd = 1;
X	return(NULL);
X    } else
X	return(buffer);
X}
X
Xrangecmp(a, b)
Xstruct range *a, *b; {
X    if (a->start < b->start)
X	return(-1);
X    else if (a->start > b->start)
X	return(1);
X    else
X	return(0);
X}
X
Xreadranges(s)
Xchar *s; {
X    extern char *getrange();
X    register int i;
X
X    while(s && *s)
X	s = getrange(s);
X
X    /*	Internally, pages are 0 origin */
X    for (i = 0; i < ri; i++) {
X	ranges[i].start--;
X	ranges[i].end--;
X    }
X
X    qsort(ranges, ri, sizeof(struct range), rangecmp);
X}
X
Xchar *
Xgetrange(s)
Xchar *s; {
X    register char *p = s;
X    int tmp = 0;
X    ranges[ri].end = -1;
X    while (isdigit(*s))
X	tmp = 10 * tmp + (*s++ - '0');
X    if (tmp <= 0) {
X	fprintf(stderr, "%s: bad number %s\n", progname, p);
X	exit(1);
X    }
X    ranges[ri].end = ranges[ri].start = tmp;
X    if (*s == '-') {
X	s++;
X	p = s;
X	tmp = 0;
X	while(isdigit(*s))
X	    tmp = 10 * tmp + (*s++ - '0');
X	if (tmp <= 0) {
X	    fprintf(stderr, "%s: bad number %s\n", progname, p);
X	    exit(1);
X	}
X	ranges[ri].end = tmp;
X    }
X    if (*s == ',')
X	s++;
X    ri++;
X    return(s);
X}
X
Xstripbyrange() {
X    int i, j, prevcnt = pagecnt;
X
X    if (ri == 0)
X	return;
X
X    for (i = 0; i < pagecnt; i++) {
X	for (j = 0; j < ri; j++)
X	    if (i >= ranges[j].start && i <= ranges[j].end)
X		break;
X	if (j == ri)
X	    pageidx[i].start = 0;
X    }
X
X    if (debug)
X	for (i = 0; i < pagecnt; i++)
X	    fprintf(stderr, "SCAN: %d: %d/%d\n", i, pageidx[i].start,
X		pageidx[i].end);
X
X    for (i = 0, j = 0, prevcnt = pagecnt; i < prevcnt; i++)
X	if (pageidx[i].start != 0)
X	    pageidx[j++] = pageidx[i];
X	else
X	    pagecnt--;
X
X    if (debug)
X	fprintf(stderr, "%d pages deleted\n", prevcnt - pagecnt);
X}
X
Xemitnup(file, flag)
Xchar *file;
Xint flag; {
X    FILE *f;
X
X    if ((f = fopen(file, "r")) == NULL) {
X	fprintf(stderr, "%s: WOT? %s!  It was there before!\n",
X	    progname, file);
X	exit(1);
X    }
X    if (flag) {
X	printf("/@#@Pages@#@ %d def\n", pages);
X	printf("/@#@Start@#@ %d def\n", startspot);
X	printf("/@#@Rev@#@ %s def\n", reversed? "true" : "false");
X    }
X
X    while(fgets(cmdbuffer, sizeof(cmdbuffer), f))
X	fputs(cmdbuffer, stdout);
X
X    fclose(f);
X}
END_OF_FILE
  if test 12922 -ne `wc -c <'utils/psxlate.c'`; then
    echo shar: \"'utils/psxlate.c'\" unpacked with wrong size!
  fi
  # end of 'utils/psxlate.c'
fi
echo shar: End of archive 7 \(of 19\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 19 archives.
    echo "Read the README to get started with psroff installation"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
