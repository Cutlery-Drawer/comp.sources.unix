Subject:  v24i096:  psroff, Troff to PostScript filter, Part01/19
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: Chris Lewis <clewis@ferret.ocunix.on.ca>
Posting-number: Volume 24, Issue 96
Archive-name: psroff3.o/part01

Submitted-by: Chris Lewis <clewis@ferret.ocunix.on.ca>
Archive-name: psroff3.0/Part01

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  README MANIFEST adapters fonts.lj lib man tests utils
#   utils/dodps.S utils/fonts utils/hpinterp.c utils/maps widths
#   widths/widthjt widths/widthlj widths/widthlj3 widths/widthlj3u
#   widths/widthps
# Wrapped by clewis@ecicrl on Fri Apr  5 20:55:57 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 19)."'
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(20840 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
X		PSROFF RELEASE 3.0 README 2.17 91/04/02
X
X			Feb 19, 1991
X			Chris Lewis
X
XPlease see the end of this file for my contact information.  If you have
Xproblems installing/using this software, please contact me - I REALLY MEAN
Xit - that's why I include my phone number.
X
XPlease read this document before configuring.  If you have difficulties,
Xread the TROUBLE file.  See the INSTALL file for explicit installation
Xinstructions.  See the LICENSE file for the copyright restrictions on
Xthis software.
X
XNote that the name "psroff" clashes with a program contained in Adobe
XTranscript and has caused endless confusion on the net.  To prevent
Xconfusion, please refer to this package on the net as "Chris's psroff",
Xor "non-Adobe psroff", or "psroff (not Transcript)" so that people will
Xknow what you're talking about.  This software was unfortunately named
Xpsroff accidentally, long before I knew that there was a thing called
Xpsroff in Transcript.  Adobe is aware of the situation, but provided that
Xeverybody is clear about which one they mean, there won't be a problem.
X
XNormal UNIX troff only prints its output on WANG C/A/T Phototypesetters.
XThis package contains a generic interface between standard troff and
Xother types of printers.  The package has a driver for PostScript printers
X(Eg: Apple Laserwriters), a driver for HP LaserJet and DeskJet family
Xprinters (including incremental downloading of PK or SFP format fonts),
Xand Ditroff output options (tpscript driving Postscript printers,
Xjetroff driving HP Laserjets, xtroff driving X.11, xproof driving DMD
Xterminals, psdit), Sun PageView driving X windows, Display Postscript on
XNeXT, DEC Windows and IBM RS/6000.
X
XIn fact, this package can be used to, in effect, upgrade CAT troff
Xto be ditroff.  There are limitations (listed near the end), but you get
Xwhat you pay for.
X
XNot only that, but this release supports ditroff *input*
Xtoo.  Therefore, if you have any kind of troff, this will work for
Xyou.
X
XApplicability/additional requirements:
X    - You must have a troff - ALL versions of troff work with this
X      software (CAT troff, ditroff, and groff).
X    - Printers:
X	- If you have a laserjet, you should be able to use this
X	  package directly.  Alternately, you can cause psroff
X	  to generate ditroff and drive jetroff with it.
X	  If you're going to drive the printer directly, you'll
X	  need additional fonts.
X	- I believe the above comments also hold true for DeskJet
X	  printers.
X	- If you have a postscript printer use postscript output.
X	  Or, generate ditroff and use tpscript.  Mine's better,
X	  so there! ;-)
X	- If you have ditroff drivers (eg: dit2dvi etc.) you can
X	  configure psroff to drive them.
X	- If you have a HPLJ III, this release comes with width
X	  tables for the built-in fonts.
X    - If you're intending to use ditroff *input*, you should ensure
X      that you have makedev, or the PD makedev clone "mkfont" from
X      comp.sources.unix in 1988.  There was a bug in mkfont which
X      bites on some machines, if your ditroff doesn't like the
X      width tables mkfont generates, contact me, I have a teensy patch
X      for it.
X    - psxlate has support for n-up printing in Postscript.  For this
X      you will also need the psnup distribution from comp.sources.misc
X      (volume 16).
X
XBeware of the use of any ditroff-only-isms when you're using
XCAT troff with psroff.  However, when used with ditroff, psroff
Xshould be fully functional.
X
XThis is a formal release.  There are probably rough edges however,
Xparticularly with fine-tuning width tables for specific printers and
Xsome of the more esoteric ditroff configurations.  Further, there
Xis some testing code for emulating ditroff drawing commands when
Xused with CAT troff (see catconv).
X
XI encourage people to experiment with psroff (particularly the configuration
Xfiles) and PLEASE PLEASE PLEASE send me your changes so that I can
Xencorporate them into new releases and updates.
X
XThis package is currently in production at our site and has been so for
Xover three years (in various stages of development).  By all
Xappearances, this software is also in serious production in 100's
Xof sites throughout the world.  The first version of psroff
X(version 1.0) was posted in comp.sources.unix in October 1989.
XPsroff release 2.0 was posted to alt.sources in November 1990.
XAn extremely primitive program called "lcat" was the original precursor,
Xit was posted to mod.sources in 1984 (which is why the copyrights go
Xso far back).
X
XPlease note: I have discontinued the mailing list, because nothing
Xever went out on it.
X
XPatches are shipped out through comp.sources.bugs and alt.sources.
XA current list of FTP and UUCP access sites can be obtained by
Xsending me mail.
X
XCredits:
X
XThe MANY people who've helped me get psroff working on a wider range
Xof platforms and printers than I would have thought possible.  Elegant
XCommunications for letting me do this, Ron Florence for assistance far
Xbeyond the call of duty in getting Laserjet driving to work,
XRick Richardson of PC Research, Liam Quin of SoftQuad, Mark Moraes at
XU of Toronto, Dave Cahlander at Amdahl, Henry McGilton (and Pageview
Xsupport) at Sun, Ronald Khoo at ibmpcug.uk, N K Krishnan for supplying
Xthe HP LJIII widths in TFM format, and Adobe for not getting too upset
Xabout the (accidental) name clash.
X
XRemarks:
X
X    - This was originally developed with a relatively old (eg: Lisa Xenix)
X      CAT troff, and may be slightly incompatible with the latest versions of
X      CAT troff.  See BSDHACK and FONT8/FONT4 in defs.h, however, I've yet
X      to see a version of troff that needs either BSDHACK or FONT8.
X
X    - This supports some of the newer drawing commands available in
X      groff and later versions of ditroff (eg: RS/6000)
X
X    - The PostScript driver is fully complete.  It uses the
X      built-in fonts on the AppleLaser.  A few characters not in
X      these fonts are faked by the invocation of drawing routines
X      defined in the file "ps.lib" (which is the definitions of things
X      needed by the driver).  Or the bracket font (also in ps.lib).
X      Eg: 1/2, 1/4, 3/4, circle, bell system logo and box are
X      constructed by PostScript subroutines and/or the bracket font.
X      The Bell System logo isn't really - try this:
X
X	    \s36\(bs\s0
X
X      The first person to correctly identify what it is (without reading
X      ps.lib) gets a pat on the back ;-)
X
X      Two characters that don't exactly map properly are left and right
X      hand.  I use double arrows instead.  This seems to be a relatively
X      common convention.
X
X      There are some facilities for downloading postscript fonts (see
X      HW in ps.fonts)
X
X    - The ditroff driver is fully complete and should work flawlessly
X      provided that you use the proper width tables and you get the
X      troff font:character -> ditroff font:character translations
X      right.  You will probably want to take the ditroff width tables
X      that come with your ditroff backend and run them through
X      gfnttab (discussed later).
X
X    - The ditroff *input* handler is quite new, and hasn't been
X      tested all that extensively.  Preliminary results seem to
X      suggest that it does work, but documentation is scanty,
X      and there's not much in the way of automated install or
X      configuration checking for real ditroff.  See the DITROFF
X      file for additional information.
X
X    - Fonts:
X	- postscript driving - psroff uses what's on the printer - the
X	  configuration (ps.fonts) supplied corresponds to a subset
X	  of the AppleLaserwriter PLUS.  This should be satisfactory
X	  with all modern postscript printers (the original Laserwriter
X	  apparently is missing some of the fonts).  You may have
X	  problems with Helvetica Narrow fonts on printers like LN03's.
X
X	  There are ways of building new fonts and downloading them.
X	  See pk2ps and the HW definitions in ps.fonts.
X
X	- ditroff driving - psroff uses whatever comes with the ditroff->
X	  printer converter.  Eg: with xtroff, psroff would use the
X	  font files that come with X windows.  With jetroff, psroff
X	  would use the font files that come with jetroff, etc.
X	  If you're driving a postscript printer via a ditroff backend,
X	  chances are that you're using fonts on the printer (eg: tpscript)
X	  and the "ps" widths will be satisfactory or can be manually
X	  tweaked slightly.
X
X	- HPLJ: to support downloading, you must obtain a set of font
X	  files that are sufficient for the sort of stuff you are doing.
X	  psroff has been designed to work with MATH8 encoded fonts
X	  (for the CAT S font), and ROMAN8 encoded fonts for all others
X	  (eg: R, I, B etc.).  Minimally, you should obtain from Hewlett
X	  Packard (or other sources) Roman, RomanItalic, and RomanBold
X	  all in ROMAN8 encodings, in the following point sizes:
X
X	     6 7 8 9 10 11 12 14 16 18 20 22 24 28 36
X
X	  From most sources these will be in HP "SFP" format.  I've
X	  included with psroff a set of PK (TeX) format font files
X	  for the S font in all of the sizes listed above.  These
X	  "S" fonts are designed to be as close to HP MATH8 as possible.
X
X	  Font sources:
X	    - PC Research's Jetroff font distribution (comp.sources.unix &
X	      uunet).  Free (actually shareware).  Will give you 4 or 5 complete
X	      sets of fonts at all useful sizes.  See INSTALL and LASERFONTS.
X	      Probably good enough to use with the optimizer.
X	    - TeX PK fonts: will generate 6 or more complete sets of fonts,
X	      at all useful sizes, but some of the fonts will be slightly
X	      off in size.  Not good with the optimizer unless you can fire
X	      up metafont.
X	    - HP Soft fonts: HP font floppies are a good source of very
X	      nice looking fonts.
X	    - New HP product: there is a new package from HP which has a "street
X	      cost" of about $40 which includes several scalable typefaces and
X	      a PC program to generate them as SFP's at any size you want.
X	      THIS is the way to go.  Note that the Laserjet III personality
X	      for psroff uses Latin-1 and Math-8 and several other fonts to
X	      get a complete troff set, as opposed to Roman-8 and a fake
X	      Math-8 for laserjet + and laserjet II.  If you get the scalable
X	      typefaces from HP to use on your pre LJIII's, start with the
X	      lj3.fonts file (has the encodings and font selections)
X
X	      See the LJIII file for more information on how the LJIII
X	      variant works, and some pointers on how to upgrade your pre-LJIII
X	      printers to work as well.
X
X	  Psroff supports both PK and SFP format font files.
X	  Normal PK font files (eg: that come with TeX) do not have
X	  anything close to the same encoding as HP.  The S PKs I supply
X	  are specially reordered (actually a merge of four PKs) to
X	  reflect MATH8 encoding.  You can also use TeX PK fonts
X	  directly (after a name change to reflect psroff's file
X	  naming conventions) for the non-S fonts.  cmr, cmit, and
X	  cmb can be used for Roman, Italic and Bold respectively.
X	  *BEWARE*, there are a *lot* of characters missing or
X	  out-and-out wrong in Knuth's standard PK files (relative
X	  to ROMAN8 ordering).  Particularly box-drawing characters.
X	  I've included a couple R, I and B PK files that can be used
X	  to have a bit of fun until you have better font files.
X	  pk2sfp gives a method of merging PK files - see testmerge
X	  entry in utils/Makefile.  R.10.pk, I.10.pk and B.10.pk
X	  in the lj.fonts directory were created this way.
X
X	  From Hewlett Packard, SFP's usually come on DOS diskettes
X	  that can be "cat"'ed to the printer.  These are what you want.
X	  Just remember to do BINARY copies from the floppies...
X
X	  I got this mail message from Ronald Florence about HPLJ fonts:
X
X		> May 14, 1990 (or thereabouts)
X
X		> I just received a notice in the mail from HP, announcing
X		> that they are about to discontinue the following soft
X		> fonts:
X
X		> 	TmsRmn/Helv	Roman 8		(33412AD)
X		> 	TmsRmn/Helv	Roman 8		(33412AF)
X		> 	TmsRmn/Helv	Ascii		(33412AE)
X
X		> Together, the first two sets provide Times Roman and
X		> Helvetica SFP fonts, including bold and italics, from
X		> 6 to 30 points.  They can be ordered from HP Direct
X		> (800/538-8787).
X
X	  These are the fonts that Ronald has been using and they work
X	  quite well.  Other soft fonts will probably work, but you
X	  may have to tweak the translation tables.
X
X	  So, order yours today...  (No, neither of us are in the
X	  employ of HP).  You may also be able to get good SFP's
X	  from the font archive at Waterloo.
X
X	  Alternately, if you have TeX fonts, the file LASERFONTS
X	  describes how to make fonts compatible with psroff.
X
X	  Software is supplied (utils and widths directories) to
X	  extract width information from PK and SFP font files and
X	  is built into the makefiles.
X
X    - The width tables supplied (widths/widthps) are in ditroff
X      makedev-input-format (ASCII ditroff width tables).  I've
X      specified them in ditroff format because it's easier to manipulate
X      than CAT troff ft?? or ft??.c files.  dit2catwid/gfnttab convert
X      these width files into ft?? files.  Further, if you're going to
X      use a ditroff backend (tpscript, xtroff etc.) you'll probably
X      need to feed them through the "makedev" utility so that the backend
X      can understand the width tables.  I do not supply a makedev, but
X      one has been posted in comp.sources.unix in 1988, and is available
X      from archive sites such as uunet, it was written by Duane Hesser,
X      dhh@teltone.com) is included with jetroff.  pk2ditwid takes PK and
X      SFP files and produces widthtables compatible with gfnttab (but not
X      necessarily with makedev).
X
X      If you have ditroff, you will HAVE to run the widths through
X      makedev/mkfont.
X
X    - Width tables: Postscript:
X      (<printercommand> is how you sent output to your
X      postscript printer.  You might use "lp -dlaserwriter".)
X      These are in the utils subdirectory:
X
X	showfont: If you type:
X			    showfont <fontname> | <printercommand>
X		  (eg: showfont Times-Roman) this will dump the entire
X		  Postscript Times-Roman font (plus some constructions
X		  that troff2ps uses) in a table.  Each character is
X		  in a box, along with several numbers.  The number
X		  in the center at the bottom of the box is the width
X		  in CAT scaling (size of 6 point character in 1/432's).
X		  The ditroff width tables are the size of a 10 point
X		  character, by default in 1/300's, but can be changed
X		  by a resolution directive in a DESC file (eg: widthps
X		  is in 1/720's).
X
X	dit2catwid.c: takes ditroff like font tables and converts them
X		  to CAT codes suitable for (at least) Xenix troff.
X		  (some attempt has been made to make it work for
X		  systems that need a.out.h headers on their width
X		  tables).  See the gfnttab script to see how it's
X		  used.
X
X	gfnttab:  Used to run dit2catwid to compile the width tables
X		  and place them in /usr/lib/font/<printer>/ft??.
X		  see lib/psrofflib.S
X
X	psdtwid:  fire it off to your Postscript printer, and it
X		  will send back a shar file containing ditroff
X		  style char tables.  (Neat - thanks Michael!)
X
X		  usage:
X			psdtwid | <printercommand>
X
X	widths/widthps/*:   width tables for postscript and ditroff driving
X		  postscript.  (Most from tpscript (thanks Michael), but
X		  some generated here with psdtwid)
X	widths/width*/*:   other width tables.
X
X    - Width tables: ditroff backends: (eg: jetroff, xtroff, psdit etc.)
X      [It is suggested that you specify the "ps" widths first for testing,
X      and then use the following instructions when fine tuning the widths to
X      get them precisely right]
X	- install the backends *first*.
X	- Find the DESC/R/S/I etc. files that come with the backend, or
X	  are generated by installing the backend (eg: jetroff's makefont
X	  stuff).
X	- Copy these files to the appropriate widths/width<xx> subdirectory.
X	  Notes:
X		- I've used "jt" for jetroff, the jt.fonts file is already
X		  at least partially set up.
X		- "ps" is for ditroff->postscript (tpscript) and direct
X		  postscript driving and these width files are supplied.
X		  And would probably work with other ditroff->postscript
X		  converters except for possible character mapping changes
X		  (see jt.fonts).
X	- Make in the widths directory will build the ft* files that you
X	  need, and make install will install them in the proper places.
X	  (normally /usr/lib/font/<xx>/ft*).  These are also done by
X	  top level make invocations.
X	- Some ditroff backends (jetroff f'r instance) need to be able
X	  to read the "makedev compiled" font files.  For which you need
X	  makedev or mkfont (see above).
X
X    - Width tables: HPLJ.  See the installation instructions.
X
X    - There is some code to allow the sending of arbitrary commands to
X      the driver - the ".sR" macro.  This works well unless you're using
X      the ".MT" macro in MM.  sR directives before the ".MT" will
X      confuse MM.  See the manual page for psroff.1 for details on
X      .sR.  Further, ".tm" has been redefined to make use of the
X      .sR facility.
X
X    - psroff has 8-font troff support, but:
X
X	    a) it's never been tested.
X	    b) I'm no longer convinced that the cat.5 man page is
X	       correct on how the decoding works.
X
X    - psroff has BSDHACK support (one of the tilt opcodes being
X      replaced by an opcode to multiply the next vertical motion
X      by 64), but this has not been tested.  I never heard of it
X      before til I saw it in Froyen's troff2lj source.  This cannot
X      be defined at the same time as 8-font support.  Frankly, I
X      can't understand why they bothered - so you save a few opcodes
X      here and there - vcat output is enormous!
X
X    - ".S" files are the source files and are converted to a filename
X      without the suffix by a sedscript that contains the configuration.
X      Whenever you touch the top-level makefile, the sedscript is changed
X      and all of the ".S" files are rebuilt.  If you make a makefile change
X      (eg: configuration), do a "make makefiles" before using submakes.
X      (though, if you simply say make, this will be done for you).  Only
X      change .S files...
X
XSee the MANIFEST for a file-by-file description of the files.
X
XSee the INSTALL file for detailed installation instructions.
X
XFuture directions:
X
XThey are two-fold: replacing the ".tm/.sR" mechanism for communication
Xwith the backend.  There is a new method, using a FSA to recognize
Xa special sequence of bell symbols (see catconv).  I haven't converted
Xover to it, because under some not-yet-understood situations, it
Xdoesn't work.  Hence, psfig and drawing commands occasionally misbehave.
XOnce this is reliable, all special commands (eg: the .fp fakeouts) will
Xbe converted over to the FSA mechanism.
X
XYou may have noticed a compile flag called "OPT" which is defined in
Xthe distributed version of defs.h.  If enabled (via -Z/W), this enables the
Xoptimizer.  It works well with Postscript output, but not with laserjet
Xunless the fonts you use are VERY good.  It's disabled by default.  The
Xoptimizer does two things: it emits as many characters as it can as one
Xprint directive, rather than one CAT code per print.  On postscript and
XHPLJ's this is a BIG win (printer execution speeds 3 or more times faster),
Xbut it won't work with ditroff.  The optimizer requires access to the CAT
Xtroff width tables (even when used with ditroff), and if troff2ps can't find
Xthem, it simply doesn't optimize.
X
XPsroff limitations:
X    - With the use of catconv and CAT troff, psroff supports:
X	- all drawing commands (including the newer \D'fn' (set fill),
X	  \D'tn' (line thickness), \D'p x y x y x y ...' (draw polygon),
X	  and filled versions of \D'c...', \D'e...', \D'p...' (by capitalizing
X	  the letter)).  Drawing commands are NOT supported in HPPCL.
X	  (I think I have polygons right, but I don't know whether I got fill
X	  parameters correct - "n" is 0...1000, where 0 is all black, and 1000
X	  is all white).
X	- psfig.
X    - catconv/CAT Troff and psroff do not support:
X	- \s(nn, \S, \H, \f(xx
X    - Ditroff:
X	- psroff doesn't support character slant (\S) or height (\H).
X	- Psroff only supports CAT troff sizes in HPPCL (some mechanism to relax
X	  this for HPLJIII's is easy to implement).  All sizes are available in
X	  Postscript and ditroff.
X	- psroff doesn't implement "w" (word breaks in ditroff output).
X	- psroff doesn't support "stipple" (I have NO idea what this is -
X	  apparently a Berkeleyism.)
X
XCONTACT INFO (note that I've moved):
X
X    Chris Lewis
X    Elegant Communications Inc.
X    Box 13215, Kanata PO
X    Kanata, Ontario, K2K 1X4
X    Voice Phone: Canada (613) 832-0541
X    Userid's for e-mail contact:
X	Psroff enquiries/help: psroff-request
X	Non-psroff mail only: clewis
X    UUCP routing: uunet!mitel!cunews!latour!ecicrl!<userid>
X    Possible internet routing: <userid>@ferret.ocunix.on.ca
X    Alternate: <user>@eci386.uucp
END_OF_FILE
  if test 20840 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
  echo shar: Extracting \"'MANIFEST'\" \(9573 characters\)
  sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X----------------------------------------------------------
X README                     1	READ ME FIRST!
X MANIFEST                   1	This shipping list
X DITROFF                   15	Ditroff input information
X INSTALL                    8	Installation guide
X LASERFONTS                12	How to build Laserjet fonts from PK's.
X LICENSE                   18	License information
X LJIII                     15	Laserjet III specifics/ LJII improvements
X MISC                       9	Misc. tuning and configuration
X Makefile                   7	Main Makefile
X TROUBLE                    3	psroff problem trouble-shooting guide
X adapters                   1	macro adapter library directory
X adapters/Makefile         19	Makefile for macro adapter libraries.
X adapters/cmn.dit.S        19	ditroff pre-include (.sR etc.)
X adapters/cmn.post.S       10	common post-include-real-macros code
X adapters/cmn.pre.S        19	common pre-include-real-macros code (.sR etc.)
X adapters/tmac.an.S        19	man macro adapter
X adapters/tmac.e.S         19	ME macro adapters
X adapters/tmac.m.S         19	MM macro adapters
X adapters/tmac.s.S         19	MS macro adapters
X adapters/tmac.t2.S        18	A MM macro extension
X audit.S                    8	Configuration auditor
X cattab.c                  10	CAT code/width table index tables
X debug.c                   18	debug print routine (used everywhere)
X defs.h                     9	main definitions.
X dit.c                      4	ditroff frontend
X dt.c                       6	Ditroff driver
X dt.h                      19	Ditroff driver header
X fonts.lj                   1	LJ fonts directory
X fonts.lj/B.10.pk.UU        2	starter set PK font
X fonts.lj/H.10.pk.UU       15	starter set PK font
X fonts.lj/HI.10.pk.UU      13	starter set PK font
X fonts.lj/I.10.pk.UU       13	starter set PK font
X fonts.lj/R.10.pk.UU       14	starter set PK font
X fonts.lj/S.10.pk.UU       14	MATH8 encoded S font PK file
X fonts.lj/S.11.pk.UU       12	MATH8 encoded S font PK file
X fonts.lj/S.12.pk.UU       13	MATH8 encoded S font PK file
X fonts.lj/S.14.pk.UU       12	MATH8 encoded S font PK file
X fonts.lj/S.16.pk.UU        6	MATH8 encoded S font PK file
X fonts.lj/S.18.pk.UU       10	MATH8 encoded S font PK file
X fonts.lj/S.20.pk.UU        8	MATH8 encoded S font PK file
X fonts.lj/S.22.pk.UU        7	MATH8 encoded S font PK file
X fonts.lj/S.24.pk.UU        6	MATH8 encoded S font PK file
X fonts.lj/S.28.pk.UU        5	MATH8 encoded S font PK file
X fonts.lj/S.36.pk.UU        2	MATH8 encoded S font PK file
X fonts.lj/S.6.pk.UU        10	MATH8 encoded S font PK file
X fonts.lj/S.7.pk.UU        15	MATH8 encoded S font PK file
X fonts.lj/S.8.pk.UU        15	MATH8 encoded S font PK file
X fonts.lj/S.9.pk.UU        15	MATH8 encoded S font PK file
X lib                        1	library file directory
X lib/Makefile              19	Library makefile
X lib/confid.ps             18	confidential overlay example
X lib/dj.fonts              19	Deskjet font table
X lib/dj.lib                19	Deskjet prolog
X lib/dt.fonts              19	Ditroff font table
X lib/jt.fonts              19	Jetroff font table
X lib/lethead.ps            18	letterhead overlay example
X lib/lj.fonts               8	Laserjet font table
X lib/lj.lib                18	Laserjet prolog
X lib/lj3.fonts             16	Laserjet III font table
X lib/lj3.lib               18	Laserjet III prolog
X lib/lj3u.fonts            16	Laserjet III font table (Univers primary)
X lib/ps.fonts              18	postscript font table
X lib/ps.lib                 8	postscript prolog
X lib/psrofflib.S           11	psroff shells script configuration table
X lj.c                       2	Laserjet driver
X lj.h                      19	Laserjet driver header file.
X makeincl.S                18	include file for makes
X man                        1	man directory
X man/Makefile              19	Makefile for man pages
X man/asc2ps.1.S            17	ASCII to Postscript converter
X man/cat.5.S               12	Describes CAT codes
X man/dumpft.1.S            15	dumpft manual page.
X man/hpinterp.1.S          13	dumpft manual page.
X man/pk2sfp.1.S             6	pk2sfp/pk2ditwid/pktype man page
X man/psroff.1.S             9	psroff man page
X man/psxlate.1.S           13	manual page for psxlate.
X man/troff2ps.1.S           5	troff2 man page
X opt.c                     14	optimizer
X pk.c                       3	PK/SFP font handler
X pk.h                      18	PK/SFP font handler headers
X pkc.c                     14	PK/SFP cache handler
X pkc.h                     18	PK/SFP cache handler header
X ps.c                       4	Postscript driver
X ps.h                      18	Postscript driver header
X psroff.S                  14	psroff shell script
X t2conf.c                  18	troff2ps driver table
X tests                      1	test files directory
X tests/Makefile            19	Makefile for tests
X tests/chartab.m           15	a test file
X tests/exttab.m            18	test addenda for ditroff input
X tests/ltest.m              3	a test file
X tests/testtab.m           15	short exhaustive test file
X troff2.c                   5	troff2 mainline
X utils                      1	utility program directory
X utils.c                    7	utility functions for troff2
X utils/Makefile            13	utility program makefile
X utils/asc2ps.c            10	Converts ASCII to Postscript
X utils/calcfonts.S          9	perl TeX -> SFP builder
X utils/catconv.S           15	Converts ditroff input to CAT troff input
X utils/dodps.S              1	Kludge to paginate dpsexec (Display Postscript)
X utils/dumpft.c            12	generates interesting stuff
X utils/fonts                1	a couple of interesting PK's
X utils/fonts/README        19	Attribution.
X utils/fonts/cmbx10.pk.UU  12	Useful PK's
X utils/fonts/cmmi10.pk.UU  11	"
X utils/fonts/cmr10.pk.UU   12	"
X utils/fonts/cmsl10.pk.UU  11	"
X utils/fonts/cmss10.pk.UU  13	"
X utils/fonts/cmssi10.pk.UU 11	"
X utils/fonts/cmsy10.pk.UU  10	"
X utils/fonts/cmti10.pk.UU  10	"
X utils/fonts/cmtt10.pk.UU  14	"
X utils/hpinterp.c           1	dumps HPLJ codes in human readable format
X utils/lj2ps.S             19	stupid HPLJ to Postscript converter for testing
X utils/maps                 1	PK->SFP merge maps
X utils/maps/S.cmtrf        19	Extracts cmtrf from S fonts.
X utils/maps/alnum.ROMAN8   19	"
X utils/maps/cmmi.MATH8     19	translate tables for mapping PK's into SFP's
X utils/maps/cmr.MATH8      19	"
X utils/maps/cmr.ROMAN8     19	"
X utils/maps/cmss.ROMAN8    19	"
X utils/maps/cmsy.MATH8     19	"
X utils/maps/cmsy.ROMAN8    19	"
X utils/maps/cmti.MATH8     19	"
X utils/maps/cmti.ROMAN8    19	"
X utils/maps/cmtrf.MATH8    16	"
X utils/maps/cmtrf.ROMAN8    4	"
X utils/maps/cmtt.ROMAN8    19	"
X utils/mkenctab.S          18	converts troff2ps -z into encoding tables
X utils/pk2ditwid.c         14	extracts ditroff format width from PK/SFP fonts
X utils/pk2ps.c             13	PK/SFP dump on Postscript printer
X utils/pk2sfp.c            11	turns PK's/SFP's into SFP's.
X utils/pktype.c            14	human readable dump of PK's and SFP's.
X utils/psdtwd.S             4	uploader of Postscript printer widths
X utils/psxlate.c            7	postscript page flipper
X utils/showfont.S          15	prints sexy postscript font tables
X widths                     1	width files and handlers directory
X widths/Makefile           11	Makefile for width tables
X widths/dit2catwid.c        9	turns ditroff width tables into CAT ones.
X widths/genext.S            5	extracts extended character set for CAT
X widths/gfnttab.S          14	runs dit2catwid/installs width tables
X widths/installdit.S       18	install ditroff widths
X widths/widthjt             1	LJ width tables directory (empty)
X widths/widthlj             1	LJ width tables directory (empty)
X widths/widthlj3            1	LJIII widths
X widths/widthlj3/B         18	"
X widths/widthlj3/DESC      18	HPLJ III width tables
X widths/widthlj3/I         18	"
X widths/widthlj3/R         18	"
X widths/widthlj3/S         18	"
X widths/widthlj3/S2        19	"
X widths/widthlj3/X         18	"
X widths/widthlj3u           1	LJIII widths/Univers base
X widths/widthlj3u/B        18	"
X widths/widthlj3u/DESC     18	HPLJ III Univers width tables
X widths/widthlj3u/I        18	"
X widths/widthlj3u/R        18	"
X widths/widthlj3u/S        18	"
X widths/widthlj3u/X        18	"
X widths/widthps             1	PS width tables directory
X widths/widthps/AB         17	Postscript width files
X widths/widthps/AI         17	"
X widths/widthps/AR         17	"
X widths/widthps/AX         17	"
X widths/widthps/B          16	"
X widths/widthps/BB         16	"
X widths/widthps/BI         16	"
X widths/widthps/BO         16	"
X widths/widthps/BR         16	"
X widths/widthps/BX         16	"
X widths/widthps/C          17	"
X widths/widthps/CB         16	"
X widths/widthps/CO         16	"
X widths/widthps/CX         16	"
X widths/widthps/DESC       18	"
X widths/widthps/H          16	"
X widths/widthps/HB         16	"
X widths/widthps/HO         16	"
X widths/widthps/HX         15	"
X widths/widthps/Hb         17	"
X widths/widthps/Hi         17	"
X widths/widthps/Hr         17	"
X widths/widthps/Hx         17	"
X widths/widthps/I          16	"
X widths/widthps/NB         17	"
X widths/widthps/NI         17	"
X widths/widthps/NR         17	"
X widths/widthps/NX         17	"
X widths/widthps/PB         17	"
X widths/widthps/PI         17	"
X widths/widthps/PR         17	"
X widths/widthps/PX         17	"
X widths/widthps/R          16	"
X widths/widthps/S          16	"
X widths/widthps/S2         11	"
X widths/widthps/ZC         17	"
X widths/widthps/ZD         18	"
END_OF_FILE
  if test 9573 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
  fi
  # end of 'MANIFEST'
fi
if test ! -d 'adapters' ; then
    echo shar: Creating directory \"'adapters'\"
    mkdir 'adapters'
fi
if test ! -d 'fonts.lj' ; then
    echo shar: Creating directory \"'fonts.lj'\"
    mkdir 'fonts.lj'
fi
if test ! -d 'lib' ; then
    echo shar: Creating directory \"'lib'\"
    mkdir 'lib'
fi
if test ! -d 'man' ; then
    echo shar: Creating directory \"'man'\"
    mkdir 'man'
fi
if test ! -d 'tests' ; then
    echo shar: Creating directory \"'tests'\"
    mkdir 'tests'
fi
if test ! -d 'utils' ; then
    echo shar: Creating directory \"'utils'\"
    mkdir 'utils'
fi
if test -f 'utils/dodps.S' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/dodps.S'\"
else
  echo shar: Extracting \"'utils/dodps.S'\" \(352 characters\)
  sed "s/^X//" >'utils/dodps.S' <<'END_OF_FILE'
X%%STARTSHELL%%
X# 2.3 91/03/25
Xtrap "rm -f /tmp/cmd$$ \$delete; exit 0" 0 1 2 15
Xif [ "$1" = "-d" ]
Xthen
X    delete=$2
X    shift
Xfi
Xif [ $# != 1 ]
Xthen
X    echo "$0: Missing file argument" >&2
X    exit 1
Xfi
Xcase $1 in
X    /*) file=$1
X	;;
X    *) file=`pwd`/$1
X	;;
Xesac
Xecho "($file) run" |
X    cat -u - /dev/tty | /usr/local/bin/dpsexec
Xrm -f /tmp/cmd$$
END_OF_FILE
  if test 352 -ne `wc -c <'utils/dodps.S'`; then
    echo shar: \"'utils/dodps.S'\" unpacked with wrong size!
  fi
  # end of 'utils/dodps.S'
fi
if test ! -d 'utils/fonts' ; then
    echo shar: Creating directory \"'utils/fonts'\"
    mkdir 'utils/fonts'
fi
if test -f 'utils/hpinterp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/hpinterp.c'\"
else
  echo shar: Extracting \"'utils/hpinterp.c'\" \(18443 characters\)
  sed "s/^X//" >'utils/hpinterp.c' <<'END_OF_FILE'
X/*
X	Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991 Chris Lewis
X		All Rights Reserved
X
X    See the LICENSE file for a full description of restrictions under which
X    this software is provided.
X
X    Function:		interprets HPLJ sequences.
X */
X
X#ifndef	lint
Xstatic char SCCSID[] =
X    "@(#)hpinterp.c 2.4 Copyright 91/03/13 22:44:30 Chris Lewis";
X#endif
X
X/*	To install:
X
X	hpinterp needs to know byte order in shorts.  At run time it
X	will attempt to figure it out.  If you get an abort, or if the
X	results are idiotic:
X
X	    If you are little-endian (eg: 386/pdp-11/vax), define SMALLEND.
X	    If you are big-endian (eg: pyramid/68000), undef BIGEND.
X
X	cc -o hpinterp hpinterp.c
X
X	Decide on a directory where you're going to run hpinterp and
X	create a directory called "FONTS" (or change the defines for
X	BINFILE and DESCFILE to have a better path).
X
X	usage:
X
X	    hpinterp < hpljescapefile > /tmp/output
X
X	/tmp/output will contain an englishy *very* verbose listing
X	of all of the escape sequences except for the contents of
X	font header/download/transfer/raster sequences.
X
X	Each font downloaded is caught into a file FONTS/f<fontnumber>
X	and a bit of english is saved in FONTS/f<fontnumber>.desc.
X	Including some character maps (range restricted by firstchar and
X	lastchar).  You can turn off the verbose output listing by setting
X	verbose to 0.  setting "debug" to 1 (if verbose is 1 too), prints
X	ESC<string> sequences as well as the english.
X
X	(One of these days I'll get it to do all of this stuff by command
X	line options....)
X */
X#include <stdio.h>
X#include <ctype.h>
X#undef	BIGEND
X#undef SMALLEND
X#define	dbprintf(x)	if (verbose) printf x
X#define	ESCAPE	0x1b
X
X#define	uchar	unsigned char
Xint firstchar = 0;
Xint lastchar = 0xff;
X
Xtypedef int(*FUNC)();
X
Xint lastschar;
Xint lastfontid;
X
Xdouble curX = 0, curY = 0;
Xint emitting = 0;
X
XFILE *out = (FILE *) NULL;
XFILE *txtout = (FILE *) NULL;
Xint count = 0;
Xint verbose = 0;
Xint debug = 0;
Xint genps = 0;
Xint chars = 0;
Xint characteristic = 1;
Xint ps_symset = 0;
X
Xshort canon();
X
Xreadhex(len)
Xint len; {
X    while(len--) GETCHAR();
X}
X
XGETCHAR() {
X    int c;
X    c = getchar();
X#ifdef	DEBUG
X    if (isprint(c))
X	printf("GETCHAR: %c\n", c);
X    else
X	printf("GETCHAR: %02x\n", c);
X#endif
X    return(c);
X}
X
X#define	TRANSFER	1
X#define	TRANSPARENT	2
X#define	FONTHEADER	3
X#define	DOWNLOAD	4
Xstruct fontdesc {
X    short f1;
X    uchar f2;
X    uchar fd_type;
X    short f3;
X    short fd_base;
X    short fd_cellwidth;
X    short fd_cellheight;
X    uchar fd_orientation;
X    uchar fd_fixedprop;
X    short fd_symset;
X    short fd_pitch;
X    short fd_height;
X    short f4;
X    uchar f5;
X    uchar fd_style;
X    uchar fd_weight;
X    uchar fd_typeface;
X};
X
Xstruct download {
X    uchar f1;
X    uchar f2;
X    uchar f3;
X    uchar f4;
X    uchar dl_orientation;
X    short dl_leftoffset;
X    short dl_topoffset;
X    short dl_charwidth;
X    short dl_charheight;
X    short dl_deltax;
X    uchar  dl_data[1];
X};
X
Xchar	*fchcont[] = {
X    "Delete all fonts",
X    "Delete all temporary fonts",
X    "Delete last font ID specified",
X    "Delete last font ID and char code",
X    "Make Temp font",
X    "Make Perm font",
X    "Copy/Assign",
X    NULL};
Xchar *spcont[] = {
X    "Fixed",
X    "Proportional",
X    NULL};
Xchar *stcont[] = {
X    "Upright",
X    "Italic",
X    NULL};
Xchar *tfcont[] = {
X    "Line Printer",
X    "Pica",
X    "Elite",
X    "Courier",
X    "Helvetica",
X    "Times Roman",
X    "Gothic",
X    "Script",
X    "Prestige Elite",
X    "Caslon",
X    "Orator",
X    NULL};
Xchar *sgcont[] = {
X    "Left-most position",
X    "Current Cursor",
X    NULL};
Xchar *pscont[] = {
X    "Disable",
X    "Enable",
X    NULL};
X
X
Xint	movex(),movey(), papinctrl(), movedx(), movedy();
Xint	spset(), psset(), styset(), strset(), tfset();
X
Xstruct intlist {
X    char *code;
X    char *name;
X    char **parmnames;
X    FUNC exec;
X} intlist[] = {
X    {"&lO",	"Orientation"},
X    {"(sP",	"Spacing", spcont, spset},
X    {"(sH",	"Pitch"},
X    {"(sV",	"Point Size", NULL, psset},
X    {"(sS",	"Style", stcont, styset},
X    {"(sB",	"Stroke", NULL, strset},
X    {"(sT",	"Typeface", tfcont, tfset},
X    {"&lP",	"Page Length"},
X    {"&lE",	"Top Margin"},
X    {"&lF",	"Text Length"},
X    {"&aL",	"Left Margin"},
X    {"&aM",	"Right Margin"},
X    {"&lC",	"Motion Index"},
X    {"&lD",	"Lines/Inch"},
X    {"*tR",	"Resolution"},
X    {"*rA",	"Start Graphics", sgcont},
X    {"*bW",	"Transfer"},
X    {"*rB",	"End Graphics"},
X    {"&aR",	"Move to Row"},
X    {"&aC",	"Move to Column"},
X    {"&aH",	"Move to Column (Decipoints)", NULL, movex},
X    {"&aV",	"Move to Row (Decipoints)", NULL, movey},
X    {"&dD",	"Underline on"},
X    {"&d@",	"Underline off"},
X    {"&pX",	"Transparent Print"},
X    {"&lL",	"Perf Skip", pscont},
X    {"&kH",	"HMI"},
X    {"&kS",	"Font Pitch"},
X    {"&kG",	"Line Termination"},
X    {"&sC",	"Line Wrap"},
X    {"&lX",	"Number of Copies"},
X    {"&lH",	"Paper Input Control", NULL, papinctrl},
X    {"*pX",	"Horizontal cursor (dots)", NULL, movedx},
X    {"*pY",	"Vertical cursor (dots)", NULL, movedy},
X    {"*cD",	"Font ID"},
X    {"*cE",	"Character Code"},
X    {"*cF",	"Font/Char control", fchcont},
X    {")sW",	"Create Font Header"},
X    {"(sW",	"Download Character"},
X    {"&fY",	"Macro ID"},
X    {"&fX",	"Macro control"},
X    {"&fS",	"Push/Pop"},
X    {"*cA",	"Horizontal Rule/Pattern Size"},
X    {"*cH",	"Horizontal Rule/Pattern Size"},
X    {"*cB",	"Vertical Rule/Pattern Size"},
X    {"*cV",	"Vertical Rule/Pattern Size"},
X    {"*cP",	"Print Rule/Pattern"},
X    {"*cG",	"Grey scale/pattern id"},
X    {"&lT",	"Job offset control"},
X    {NULL,NULL}
X};
X
Xunion {
X    struct fontdesc b_fd;
X    struct download b_dl;
X    char b_buffer[2048];
X} buffer;
X
Xinterp(prefix, anchor, number, suffix)
Xchar prefix, anchor, suffix;
Xdouble number; {
X    int multi;
X    register int i;
X    char lookup[4];
X
X    if (debug)
X	dbprintf(("ESC%c%c%g%c\n", prefix, anchor, number, suffix));
X
X    if (islower(suffix))
X	suffix = toupper(suffix);
X
X    sprintf(lookup, "%c%c%c", prefix, anchor, suffix);
X    for (i = 0; intlist[i].code; i++) {
X	if (0 == strcmp(intlist[i].code, lookup)) {
X	    dbprintf(("%s:", intlist[i].name));
X	    if (intlist[i].parmnames) {
X		int j;
X		for (j = 0; j < number; j++) {
X		    if (!intlist[i].parmnames[j])
X			break;
X		}
X		if (intlist[i].parmnames[j]) {
X		    dbprintf((" %s\n", intlist[i].parmnames[j]));
X		} else {
X		    dbprintf((" %d\n", (int) number));
X		}
X	    } else {
X		dbprintf ((" %g\n", number));
X	    }
X	    if (intlist[i].exec)
X		(*intlist[i].exec)(number);
X	    break;
X	}
X    }
X
X    multi = 0;
X    /* For parsing variable length ones */
X    switch(prefix) {
X	case '*':
X	    if (anchor == 'b' && suffix == 'W')
X		multi = TRANSFER;
X	    break;
X	case '&':
X	    if (anchor == 'p' && suffix == 'X')
X		multi = TRANSPARENT;
X	    break;
X	case ')':
X	    if (anchor == 's' && suffix == 'W')
X		multi = FONTHEADER;
X	    break;
X	case '(':
X	    if (anchor == 's' && suffix == 'W')
X		multi = DOWNLOAD;
X	    break;
X    }
X    if (prefix == '*' && anchor == 'c' && suffix == 'E') {
X	lastschar = number;
X    }
X    if (prefix == '*' && anchor == 'c' && suffix == 'D') {
X	lastfontid = number;
X    }
X    if (multi)
X	readdesc(multi, (int) number);
X}
X
X#ifdef	SMALLEND
X#define	smallend	1
X#endif
X#ifdef	BIGEND
X#define	smallend	0
X#endif
X
X#if	!defined(SMALLEND) && !defined(BIGEND)
Xunion	t {
X    char a[2];
X    short b;
X};
Xint	smallend;
X#endif
X
Xshort
Xcanon(v)
Xshort v; {
X    if (smallend) {
X	return(((v & 0xff) << 8) | ((v&0xff00) >> 8));
X    } else
X	return(v);
X}
X
X#define	BINFILE		"FONTS/f%d"
X#define	DESCFILE	"FONTS/f%d.desc"
X
Xreaddesc(type, bytecount)
Xint type; int bytecount; {
X    int points;
X    char *typeface;
X    char *style;
X    char filename[1000];
X    switch(type) {
X	default:
X	    readhex(bytecount);
X	    break;
X	case DOWNLOAD:
X	    fread((char *) &buffer, 1, bytecount, stdin);
X	    sprintf(filename, BINFILE, lastfontid);
X	    if (out) fclose(out);
X	    if ((out = fopen(filename, "a")) == NULL) {
X		fprintf(stderr, "Can't open %s\n", filename);
X		out = NULL;
X	    }
X	    sprintf(filename, DESCFILE, lastfontid);
X	    if (txtout) fclose(txtout);
X	    if ((txtout = fopen(filename, "a")) == NULL) {
X		fprintf(stderr, "Can't open %s\n", filename);
X		txtout = NULL;
X	    }
X	    if (lastschar >= firstchar && lastschar <= lastchar) {
X		if (txtout) {
X		    fprintf(txtout, "Character: %c\n", lastschar);
X		    fprintf(txtout, "  orientation: %d\n",
X			buffer.b_dl.dl_orientation);
X		    fprintf(txtout, "  leftoffset: %d\n",
X			canon(buffer.b_dl.dl_leftoffset));
X		    fprintf(txtout, "  topoffset: %d\n",
X			canon(buffer.b_dl.dl_topoffset));
X		    fprintf(txtout, "  charwidth: %d\n",
X			canon(buffer.b_dl.dl_charwidth));
X		    fprintf(txtout, "  charheight: %d\n",
X			canon(buffer.b_dl.dl_charheight));
X		    fprintf(txtout, "  deltax: %d\n",
X			canon(buffer.b_dl.dl_deltax));
X		    if (chars)
X			plotchars(txtout, &buffer.b_dl);
X		}
X	    }
X	    if (out) {
X		fprintf(out, "\033*c%dE", lastschar);
X		fprintf(out, "\033(s%dW", bytecount);
X		fwrite((char *) &buffer, 1, bytecount, out);
X	    }
X	    break;
X
X	case FONTHEADER:
X	    if (txtout) fclose(txtout);
X	    if (out) fclose(out);
X
X	    fread((char *) &buffer, 1, bytecount, stdin);
X	    points = (double) canon(buffer.b_fd.fd_height) * 72 / 4 / 300 + .5;
X	    switch(buffer.b_fd.fd_typeface) {
X		case 0: typeface = "Line Printer"; break;
X		case 1: typeface = "Pica"; break;
X		case 2: typeface = "Elite"; break;
X		case 3: typeface = "Courier"; break;
X		case 4: typeface = "Helvetica"; break;
X		case 5: typeface = "Times-Roman"; break;
X		case 6: typeface = "Gothic"; break;
X		case 7: typeface = "Script"; break;
X		case 8: typeface = "Prestige"; break;
X		case 9: typeface = "Caslon"; break;
X		case 10: typeface = "Orator"; break;
X		default: typeface = "               ";
X		    sprintf(typeface, "T%d", buffer.b_fd.fd_typeface);
X		    break;
X	    }
X	    switch(buffer.b_fd.fd_style) {
X		case 0:
X		    style = "Upright";
X		    break;
X		case 1:
X		    style = "Italic";
X		    break;
X	    }
X	    sprintf(filename, BINFILE, lastfontid);
X	    if ((out = fopen(filename, "w")) == NULL) {
X		fprintf(stderr, "Can't open %s\n", filename);
X		out = NULL;
X	    }
X	    sprintf(filename, DESCFILE, lastfontid);
X	    if ((txtout = fopen(filename, "w")) == NULL) {
X		fprintf(stderr, "Can't open %s\n", filename);
X		txtout = NULL;
X	    }
X	    /*fprintf(out, "\033*c%dD", lastfontid);*/
X	    fprintf(out, "\033)s%dW", bytecount);
X	    fwrite((char *) &buffer, 1, bytecount, out);
X	    if (txtout) {
X		fprintf(txtout, "Height: %d\n", canon(buffer.b_fd.fd_height));
X		fprintf(txtout, "  Points (rounded): %d\n", points);
X		fprintf(txtout, "  Points (floating): %.2f\n",
X		    (double) canon(buffer.b_fd.fd_height) * 72 / 4 / 300);
X		fprintf(txtout, "Pitch: %d\n", canon(buffer.b_fd.fd_pitch));
X		fprintf(txtout, "  Pitch (chars/inch): %d\n",
X		    4 * 300 / canon(buffer.b_fd.fd_pitch));
X		if (buffer.b_fd.fd_fixedprop)
X		    fprintf(txtout, "Proportional width font\n");
X		else
X		    fprintf(txtout, "Fixed width font\n");
X		fprintf(txtout, "Stroke weight: %d\n", buffer.b_fd.fd_weight);
X		fprintf(txtout, "Style: %d; (%s)\n", buffer.b_fd.fd_style,
X		    style);
X		fprintf(txtout, "Typeface: %d; (%s)\n", buffer.b_fd.fd_typeface,
X		    typeface);
X		fprintf(txtout, "Symset: %04x; (%d%c)\n",
X		    canon(buffer.b_fd.fd_symset),
X		    canon(buffer.b_fd.fd_symset) >> 5,
X		    (canon(buffer.b_fd.fd_symset) & 0x1f) + 'A' - 1);
X
X		fprintf(txtout, "Type: %x\n", buffer.b_fd.fd_type);
X		fprintf(txtout, "Base: %d\n", canon(buffer.b_fd.fd_base));
X		fprintf(txtout, "Cellwidth: %d\n", canon(buffer.b_fd.fd_cellwidth));
X		fprintf(txtout, "Cellheight: %d\n", canon(buffer.b_fd.fd_cellheight));
X		fprintf(txtout, "Orientation: %d\n", buffer.b_fd.fd_orientation);
X		fprintf(txtout, "Height: %d\n", canon(buffer.b_fd.fd_height));
X	    }
X    }
X}
X
Xplotchars(f, dl)
Xstruct download *dl;
XFILE *f; {
X    short x, y, bx, by, bytes, byteindex, bitindex, bit;
X    bytes = (canon(dl->dl_charwidth) + 7) / 8;
X    for (y = 0; y < canon(dl->dl_charheight); y++) {
X	fprintf(f, "        ");
X	for (x = 0; x < (canon(dl->dl_charwidth) + canon(dl->dl_leftoffset));
X		x++) {
X	    bx = x - canon(dl->dl_leftoffset);
X	    by = y;
X	    if (bx >= 0) {
X		byteindex = bytes * by + bx / 8;
X		bitindex = (7 - (bx % 8));
X		if (dl->dl_data[byteindex] & (1 << bitindex))
X		    bit = 'X';
X		else
X		    bit = ' ';
X	    } else
X		bit = ' ';
X	    if (x == 0 && y == canon(dl->dl_topoffset))
X		bit = '+';
X	    if (bit == ' ' && y == canon(dl->dl_topoffset))
X		bit = '=';
X	    fputc(bit, f);
X	}
X	fputc('\n',f);
X    }
X}
X
X
X/*	We've got ESC<prefix><anchor>
X *	read number/suffix pairs
X */
Xmultisequence(prefix, anchor)
Xchar prefix, anchor; {
X    int c, neg, seendot;
X    double v;
X    while(1) {
X	v = 0;
X	seendot = 0;
X	neg = 1;
X	while(isdigit(c = GETCHAR()) || (c == '.') || (c == '-') || (c == '+')) {
X	    if (c == '+') {
X		continue;
X	    }
X	    if (c == '.') {
X		seendot = 10;
X		continue;
X	    }
X	    if (c == '-') {
X		neg *= -1;
X		continue;
X	    }
X	    if (seendot) {
X		v += (double) (c - '0') / seendot;
X		seendot *= 10;
X	    } else
X		v = v * 10 + c - '0';
X	}
X	v *= neg;
X	interp(prefix, anchor, v, c);
X	if (!islower(c))
X	    break;
X    }
X}
X
Xprinthex(buf, n)
Xchar *buf; int n; {
X    int i;
X    dbprintf(("SEQ:"));
X    for (i = 0; i < n; i++) {
X	if (isprint(buf[i]))
X	    putchar(buf[i]);
X	else {
X	    dbprintf(("\\%02x", buf[i]));
X	}
X    }
X    dbprintf(("\n"));
X}
X
Xshort pts[] = {6, 7, 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 28, 36, 4, 4};
Xreadescape() {
X    int c, v, v1, v2, v3;
X    c = GETCHAR();
X    switch(c) {
X	case '9':
X	    dbprintf(("Clear Margins\n"));
X	    return;
X	case '=':
X	    dbprintf(("Half linefeed\n"));
X	    return;
X	case 'E':
X	    dbprintf(("Reset\n"));
X	    return;
X	case 'z':
X	    dbprintf(("Self test\n"));
X	    return;
X	case 'Y':
X	    dbprintf(("Display functions on\n"));
X	    return;
X	case 'Z':
X	    dbprintf(("Display functions off\n"));
X	    return;
X	case ')':
X	    c = GETCHAR();
X	    if (isdigit(c)) {
X		v = 0;
X		while(isdigit(c)) {
X		    v = v * 10 + c - '0';
X		    c = GETCHAR();
X		}
X		switch(c) {
X		    case 'X':
X			dbprintf(("Secondary font %d\n", v));
X			break;
X		    case '@':
X			dbprintf(("Secondary font value %d\n", v));
X			break;
X		    default:
X			dbprintf(("HUH ESC)%d%c\n", v, c));
X		}
X		return;
X	    }
X	    multisequence(')', c);
X	    return;
X	case '(':
X	    c = GETCHAR();
X	    if (isdigit(c)) {
X		v = 0;
X		while(isdigit(c)) {
X		    v = v * 10 + c - '0';
X		    c = GETCHAR();
X		}
X		switch(c) {
X		    case 'X':
X			dbprintf(("Primary font %d\n", v));
X			if (genps) {
X			    endemit();
X			    characteristic = 0;
X			    printf("/f%d findfont %d scalefont setfont\n",
X				v, pts[v&0xf]);
X			}
X			break;
X		    case '@':
X			dbprintf(("Primary font value %d\n", v));
X			break;
X		    default:
X			dbprintf(("Symbol set: %d%c\n", v, c));
X			ps_symset = c;
X		}
X		return;
X	    }
X	    multisequence('(', c);
X	    return;
X	case '&':
X	    c = GETCHAR();
X	    multisequence('&', c);
X	    return;
X	case '*':
X	    c = GETCHAR();
X	    multisequence('*', c);
X	    return;
X	default:
X	    dbprintf(("Huh? %02x\n", c));
X	    return;
X    }
X}
X
Xmain(argc, argv)
Xint argc; char **argv; {
X    int c;
X    extern char *optarg;
X
X#if	!defined(BIGEND) && !defined(SMALLEND)
X    union t ta;
X    ta.a[0] = 0x01;
X    ta.a[1] = 0x02;
X    smallend = ((ta.b&0xff) == 0x01);
X#endif
X    while((c = getopt(argc, argv, "dpv")) != EOF)
X	switch(c) {
X	    case 'p':
X		genps++;
X		break;
X	    case 'v':
X		verbose++;
X		break;
X	    case 'd':
X		debug++;
X		break;
X	    case '?':
X		fprintf(stderr, "usage: hpinterp [-d][-p][-v]< file");
X		exit(1);
X	}
X
X
X    if (genps) {
X	printf("/M { moveto } def\n");
X	printf("/S { show } def\n");
X    }
X    while((c = GETCHAR()) != EOF) {
X	if (c == ESCAPE) {
X	    readescape();
X	} else {
X	    if (isprint(c)) {
X		dbprintf(("Char: %c\n", c));
X	    } else {
X		dbprintf(("Char: 0x%02x\n", c));
X	    }
X	    emitchar(c);
X	}
X    }
X    if (out) fclose(out);
X    if (txtout) fclose(txtout);
X    endemit();
X}
X
Xmovex(num)
Xdouble num; {
X    curX = num;
X    endemit();
X}
X
Xmovey(num)
Xdouble num; {
X    curY = num;
X    endemit();
X}
X
Xmovedx(num)
Xdouble num; {
X    curX = num * 720 / 300;
X    endemit();
X}
X
Xmovedy(num)
Xdouble num; {
X    curY = num * 720 / 300;
X    endemit();
X}
X
Xemitchar(c)
Xint c; {
X    if (!genps)
X	return;
X
X    if (characteristic)
X	selchar();
X
X    if (!emitting)
X	printf("%g %g M(", curX/10, (72 * 11) - (curY/10));
X
X    emitting = 1;
X
X    switch(c) {
X	case '(': case ')': case '\\':
X	    printf("\\%c", c);
X	    break;
X	default:
X	    if (c > ' ' && c < 0x7e)
X		printf("%c", c);
X	    else
X		printf("\\%03o", c&0xff);
X	    break;
X    }
X}
X
Xendemit() {
X    if (emitting)
X	printf(")S\n");
X    emitting = 0;
X}
X
Xpapinctrl(num)
Xdouble num; {
X    int n = num;
X    if (num == 0) {
X	endemit();
X	if (genps)
X	    printf("showpage\n");
X    }
X}
X
Xint ps_pointsize = 10;
Xint ps_style = 1;
Xint ps_stroke = 0;
Xint ps_tface = 5;
Xint ps_spacing = 0;
X
Xspset(num)
Xdouble num; {
X    ps_spacing = num;
X    characteristic = 1;
X    endemit();
X}
Xpsset(num)
Xdouble num; {
X    characteristic = 1;
X    ps_pointsize = num;
X    endemit();
X}
Xstyset(num)
Xdouble num; {
X    characteristic = 1;
X    ps_style = num;
X    endemit();
X}
Xstrset(num)
Xdouble num; {
X    characteristic = 1;
X    ps_stroke = num;
X    endemit();
X}
Xtfset(num)
Xdouble num; {
X    characteristic = 1;
X    ps_tface = num;
X    endemit();
X}
X
X#define	TMS	"Times-Roman", "Times-Italic", "Times-Bold", "Times-BoldItalic"
X#define COUR	"Courier", "Courier-Oblique", "Courier-Bold",\
X    "Courier-BoldOblique"
X#define HELV	"Helvetica", "Helvetica-Oblique", "Helvetica-Bold",\
X    "Helvetica-BoldOblique"
X
X#define	LAST	7
X
Xchar *fonts[LAST][4] = {{COUR}, {COUR}, {COUR}, {COUR}, {HELV}, {TMS},
X    {COUR}};
X
Xselchar() {
X    int idx = 0;
X    char **font;
X    char *p;
X#ifdef	NEVER
X    printf("ps_pointsize: %d\n", ps_pointsize);
X    printf("ps_style: %d\n", ps_style);
X    printf("ps_stroke: %d\n", ps_stroke);
X    printf("ps_symset: %d\n", ps_symset);
X    printf("ps_tface: %d\n", ps_tface);
X    printf("ps_spacing: %d\n", ps_spacing);
X#endif
X    if (ps_tface == 4101)	/* CG Roman on LJ III */
X	ps_tface = 5;
X    if (ps_tface == 4148)	/* CG Univers (Helvetica like) Roman on LJ III */
X	ps_tface = 4;
X    if (ps_tface >= LAST || ps_tface < 0)
X	ps_tface = 3;
X    idx = 0;
X    if (ps_stroke > 0)
X	idx = 2;
X    if (ps_style != 0)
X	idx++;
X    if (ps_symset == 'M')
X	p = "Symbol";
X    else
X	p = fonts[ps_tface][idx];
X    printf("/%s findfont %d scalefont setfont\n", p, ps_pointsize);
X    characteristic = 0;
X}
END_OF_FILE
  if test 18443 -ne `wc -c <'utils/hpinterp.c'`; then
    echo shar: \"'utils/hpinterp.c'\" unpacked with wrong size!
  fi
  # end of 'utils/hpinterp.c'
fi
if test ! -d 'utils/maps' ; then
    echo shar: Creating directory \"'utils/maps'\"
    mkdir 'utils/maps'
fi
if test ! -d 'widths' ; then
    echo shar: Creating directory \"'widths'\"
    mkdir 'widths'
fi
if test ! -d 'widths/widthjt' ; then
    echo shar: Creating directory \"'widths/widthjt'\"
    mkdir 'widths/widthjt'
fi
if test ! -d 'widths/widthlj' ; then
    echo shar: Creating directory \"'widths/widthlj'\"
    mkdir 'widths/widthlj'
fi
if test ! -d 'widths/widthlj3' ; then
    echo shar: Creating directory \"'widths/widthlj3'\"
    mkdir 'widths/widthlj3'
fi
if test ! -d 'widths/widthlj3u' ; then
    echo shar: Creating directory \"'widths/widthlj3u'\"
    mkdir 'widths/widthlj3u'
fi
if test ! -d 'widths/widthps' ; then
    echo shar: Creating directory \"'widths/widthps'\"
    mkdir 'widths/widthps'
fi
echo shar: End of archive 1 \(of 19\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 19 archives.
    echo "Read the README to get started with psroff installation"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
