Subject:  v24i109:  psroff, Troff to PostScript filter, Part14/19
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: Chris Lewis <clewis@ferret.ocunix.on.ca>
Posting-number: Volume 24, Issue 109
Archive-name: psroff3.o/part14

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  fonts.lj/R.10.pk.UU fonts.lj/S.10.pk.UU opt.c pkc.c
#   psroff.S utils/fonts/cmtt10.pk.UU utils/pk2ditwid.c utils/pktype.c
#   widths/gfnttab.S
# Wrapped by clewis@ecicrl on Fri Apr  5 20:56:03 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 14 (of 19)."'
if test -f 'fonts.lj/R.10.pk.UU' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fonts.lj/R.10.pk.UU'\"
else
  echo shar: Extracting \"'fonts.lj/R.10.pk.UU'\" \(6323 characters\)
  sed "s/^X//" >'fonts.lj/R.10.pk.UU' <<'END_OF_FILE'
Xtable
X !"#$%&'()*+,-./0123456789:;<=>?
X@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_
Xbegin 644 fonts.lj/R.10.pk
XM]UD``*``````````!":N``0FKM@.J0```!4&!_L<\S0S0U)1X`ZH````%08'
XM]QP<<\YS"`#@#[,````?"`?U'3Q"@8&!0CS`$2$````,!![\'1(=_L$MDA@2
XM$.`<(@```!4-#/\<8&>'OC[0T("$!"`B`A`1`1`1`0"P/",````C'B7^',+B
XM)RQC8\;B)RQC8\;C)RQC8XT!TN*B<L8V/&XR<JTAT(-CQN(G+&-CQN(G+&-C
XMQN(G+"#01B0````5$"'^'H\<:",2)204$R45$A86-A1?839A0A-1=$&&$9B9
XMB9BA%9$SD4,244?T%545-Q42%A42%A04%1,6(Q(9;?%PP&\E````(QXA_AY$
XMTR<C'1-B4K-C8X1B<2MC@9)S@8-S@7.#@7*3@6.3@6*C@5.R<5/#85+1)14]
XM(C%3U$8F34-2,=(U)1T24V'#4G&S4X&B8X&38X&2<X&#<X%S@X%RDX%CHG%C
XMLV%BT"46/1(Q<M-$P$XF````(!L?_AV#VB(=CR0=;C-!UO,QUS(=@Q':2)8[
XM23PJ/!H1.QD2.AD4.!DD.!CR8V&#<T&3=#&3@R&CE*2CH1.4@3*!(W%"4D-"
XM=85`X!`G````#`4,_!QGOM"$(A$1`-`C*````!`**OT>D8&!@8)_)_)_)S?B
XM)^LXXB@X\I\I\I*1H:&AV",I````$`HJ_AX:&AH9*?*?*?*#CB*.L^)R<W\G
XM\G\G*!@8&!G0(BH````5$!+^'GXR@5)1%#(T(R(C:*]*AC(B,D,C014E&.,G
XMT`\K````(!L<_A?>PL`X[-+`X`XL````#`0,_`-O]Q$1(DC("2T````."P(`
XM"=G@"BX````,!`3\`V_VT"XO````%1`I_AX!#RT_TM/2T]\M/?+3WRT]\M/2
XMT]\M/?+3WRT]\M/2T]\M/?(!`-`D,````!40'?X;9*)"<F)?*",X,O*B'L.C
XM\2HB.#/R@E)B<D*64-`2,0```!4-'/P;8J-V4C.N`7.53=`O,@```!40'/X;
XM59)288,QHC&C%(EY^#$Y/$_#SSP\/2TM+2TH%"D3*A,:$](!`0$1T#`S````
XM%1`=_AM6@E)O&#-&0D<R1D,V3//2TM*F`1(!'S`0/?03B>)X@R&308-24I90
XMP"XT````%1(<_QO/+2/1]-`1/"$\$CL3.B,Z%#D5."4X%C<7-B<V&#49-"DT
XMU>:SN]`N-0```!40'?X;(H)+6FB.40$1-7$A0F$18E)S09/3WB02F.*%LR&4
XM(9-!<V)#E6#0-S8````5$!W^&X2B0G)A8F-"9#)T,H(_/2TS53(4)#$6(T@B
XM2#$Z(>0Z/Q*C$Y(R@S*"4F)R0J50P"<W````%1$=_AL1T]/QTB'!+QP3&QTO
XM'2'2+2'2\M$]'RT>,]#E31*0T#0X````%1`=_AMEDD)Q@5&20:(N(J(CDB1R
XM15%7$GBGF&(V0E8BA"*6M>/"$K$BH4*"4U&64-`W.0```!40'?X;9*)"<F)2
XM@C.",I,?.B'D.C$J,3A"*$,F$30D$C53/]+3,H(T<C1B0W%A<F)"I7"P#SH`
XM```,!!+\$1(8$MXA@2&P%3L````,!!K\$1(8$MXA@3XS'R$A(3#`$;@````,
XM!![\%!(8$MGL(=\2$,`0/0```"`;#/X/'<'>#+WAW!#0(;D````4#QW^%&+/
XM3"!;\=XQTM'2PL.SL\XCAY,2H3)R9T#0'S\````4#QW^'$=B8S&3$Y?B@\+#
XMLL+"T=+>406BSTPGP%)`````(!L=_ARGU2<M$K*QTAD=07'6%1A8%!8T%Q,6
XM-A<2%B@T$A4X-!$6*34N13DU)BDU$14X-1$6*#02%C9$$Q8T$B,4&%1&'>'>
XM'>+22"ELI\`R00```!\<'?\<T.(MSB3:XA%-CB$TUN(534\732)UT1E-'1T"
XME<\;2RM:\=!)+05TQ4E\R#%"````'1@<_AO5I(2$HW2D9+-N-+14LV2D9)1T
XM=8TI24=*1DM%3#7D3$]$M%2D9)0]9<`Z0P```!X9'OX<MG&#8D)RHB)3T$0]
XM(S/3,SU"(]4O%-81/77GV3UQ\4UA(]8?,]05/2%ST!HK'#<M-W#(,T0````@
XM&QS^&]702$M*24PX]-`W31-DT47TTC7G323T32-4T45-$V301DT#=,.$LY23
XM?5G8-T4````<&!S^&P&&2D9,)O319-)?0!`51A<5XD8=12V]12WB1AU&&!1`
XM$1XD0!`5]-)4PF2D(!@@V"A&````&Q8<_AL!=4E%2R7TP53"]$T41A8>)$8;
XM12N[12OC1AOF0!1=V<!!1P```"$<'OX<MG&S8D*BHB*#T$<](V/3-CU"4]4D
XM]-84/7$^5-M,T]-4/41/3313TT;STD<]%(/!$Z*A,K-B4=%KR!-(````'QH<
XM_AO"SK1*2-6.Q*1,+,@,20````\,'/\;SMQ$3-`:2@```!40'?\;/87.`41#
XM5#XE1#1$46-Q0Y6`R$9+````(!P<_AO&E4Q(3"I,&TL<2AT$D=%('21QTT8=
XM1%'51#U$-=-"$4TT(23201--)531]'302$Q(6TE+]*2DM)2UA+8\6\@=3```
XM`!H5'/X;T,73[234XDP?1+)$L52B5)-4=1UQR#U-````)B$<_AN=*?1=)8XA
XM%-`12/$DL22.(321-(XA1'%$CB%4452.(60Q9(\701=(XAA(2!DI1S@I1)4E
XMP,A&3@```!\:'/X;B91;-UP8$4L8\22A@321@36!@42!CQ5'&!9&&/%T48&$
XM08&%,8&4,8\:0A@;01CQQ8\=!('1.!TB<]$DG!3`.T\````@&Q[^'*?5-3T3
XMD[.SD]`W/2-4TD0]0S]-1"/6,>=-9!/6,O340SU#1-)%/2-ST#D[.SD]$U/5
XM>L@B4````!P7'/X;U*2#A)1DI%2S7D2T1+-4I%249(.-"NM-++#`4%$````@
XM&R7^'*?5-3T3D[.SD]`W/2-4TD0]0S]-1"/6,>=-9!/6,O340SU#1&-D4U$Q
XM4W,Q43.3(6$3LQ%DT40W&I<=0G'5)2U3,_U8UVV4,,@X4@```!\<'?X;T]-'
XM3024M*2DLZXTM)2SI*2DE+1TT,TT9-%(/02$SE24OTE&%$HV%$I$$<<T'94@
XMP#A3````%Q(>_AQ644-2(C*1$B.C(L(3PAXCT!%-%=%=":N,BZG07171323B
XMT5_0(3LB(1H3(B8D%77`(%0````>&QS_&QW".$<R*4@B\:21$J2BXK2A[3Q-
XMEM/34,@?50```!\:'?X;Q91,-^UDT!D\&DL;.AT"H=$H'3-"UEK(-58````?
XM'!W_&[F#711DTB=-(870*?30&^)+'0])'16!TO1QTU4M3T4=;B0QV/01V6VO
XM3<XBT,A(5P```"LH'?\;M;6#6UI%3$PGXDM;&4I:&O21))&T@22!ST<41QQ6
XM%$<=#B119%'2XD,80QU$(841U?01I!'66EU^),38XBT2L,!$6````!\<'/\;
XM&TIFA:2BT$DM!8'21QTU4M1%'60QUU$MA!':3;7;3;]=D237$UUA1-4573)E
XMTAA-$97"I,'$HL5UISILR#)9````'QX<`!O)E%T4A-(:70*TT!Q;'16ATDD=
XM-8'41QU54M9%'80QV5(=I!';;<ZDV<G`.%H````9%!S^&QUA65$[0O*T,;1!
XMI4&D493332327232]-)-)=))'U2A1+$UHC2Q-,$TLB2S%94=8;@,6P````P'
XM*?P>Q.V%PK@,70````P'*0`>PNV%Q.`/7@```!4*!?L;#`2"$0*`0.`08```
XM``P%#/T<"(B$0A"WWF#`*F$````5$A+^$3>B4W139&-B<]+SMX0S8V-3<U*#
XM3B.#,1)T,2)1(Q%&0R#(*6(````7$QW_'&T^D],S6#$D)T<F.24Y-#HDY3HS
XM.B0Y-#DE1R8B%2<45M`?8P```!(.$OX15G)"4D0R5"-B,KY3PL.1(I$R<5)"
XM=4#`*60````7$QW^'*;3Z3E2-R41-B=%*30Y-"HSY3HT*C0Y-2DV)T<D(3A3
XM8-`A90```!(/$O\198)"8F)"@B.#$J6@%N/2TZ$BH3*!4E*%0,`89@````T/
XM'0`<A9(R8S121$-27E.+CM(YI,`V9P```!42'/\2T3=#$B0D,R,T,Q0F)^,V
XM-R8H-#DD*1)+'3+4+3J-!=$RHR+%XM$A+",J)38XA<@;:````!<4'?\<;4Z3
XMU#-9,A0W,18G1S;L.#.2D)`1:0````P)'?\<,F]&+99NI3.0@!AJ````#0LE
XM`QR"CT@ME^FH,25T(4,R)"14R#!K````%A,=_QQM/I/3-(0V1C8H-ADU&C0;
XM,QPR.S%+0CHS230Y-$@U.#8W-D8V4I*`R`QL````#`D=_QQF[=,YV!]M````
XM)"$2_Q%C9FDR%3,5-S$7(A<G2$@V[#DY,Y.3D-@7;@```!<4$O\18UDR%#<Q
XM%B='-NPX,Y*0T")O````%1(2_Q%FHT-R@E*B,Z,BPAY3PQ+"(Z,RHE*"<T.F
XM8-@G<````!<3&O\18U@Q)"=')CDE.30Z).4Z/S.30Y)4<F,14G,EGF/9H-`I
XM<0```!83&OX19%%R0B)B<1)2A$\Y,^4Z-"HT.34H1B=')"$X4S`2YCV0V!5R
XM````$`T2_Q%B-3$2)/0D,T).LWHPT")S````$`T2_Q$V(3)3(8(?*1$X$5F&
XMEHEI2D^5@1(14B$V,-`9=````!`,&O\97C&O*3A&M.@YY#44)10S%T+8%G4`
XM```7%!+_$65F[#@V-T<G1S0A.5-@R"!V````%A,2_Q&%8D@U\Y%_-QGB-1OS
XM,<02T/,1TN(]09#(.7<````>&Q+_$8*"<D9&-3<W)3<W%C81)Q?S41-1@T$R
XM49\S$S,:,A4C&_,14Q'$<A'0\W/1*2TAD8#`+'@````6%1(`$1@X5&.$8J-A
XMPT'1,ATC$M--4]5--=,2/1%#P5.R8Z&#=&4X2<@L>0```!83&O\1A6)(-?.1
XM?S<9XC4;\S'$$M#S$=+B/4\=3QI$&D,;0BPB+130T"AZ````$@X2_Q$=$V,B
XM<R%S,60Q8T%3I*.CI%%#83-Q)&(C<2.!(V,=$,@)]@```!44`0`+U^`/K```
XM`!4.!/T;'`3\)#\@..`.JP```!4,!/P<8&\/\/8&T!#^````(!L<_AK>PL`X
XMZM+`.,!4T@```"`;'/X7I]4G+1*RL=(9'4%QU!$5'4$Q0=,4$QTQ82'2%Q$=
XM(9+1&BT!LOP<*QT"H=$I'2$1<=(2%ATQ,4'3%!,=05$1U!<=09'2&RLM$G+5
XM>L`??@```"`;"?X.5=,3C2$KT!%%2UA86T5!'0LATH,=-5#`3/L````J)1S^
XM%]HJ+82$UDA-<Y/72$UDA-9(37.3UTA-9(362$USD]=(36](3:2$VCD]I(3:
XM2$VDA-HY/:2$VDA-I(3:.3VDA-I(3:*BR$S]````*B4<_A<J+:2$VDA-HY/:
XM2$VDA-I(3:.3VDA-I(3:2$VCD]I(3:](362$USD]=(362$UDA-<Y/72$UDA-
XM9(37.3UTA-9(38*BVM`[O0```!(+)?T<-5)!,U$B9?5F$3DI.2HI-R(D,R,D
XM,34AXC4Q)3$T(R,T(B<Y*BDY*3$6;U5B(5,Q0E4PF`E?````%14#`/?5B`E\
XM````#`(I^Q[9&`K\````&105_A0/(,`K/````"`9&/T5V3UTUDUDUDUDUDUD
XMUDUDUDUO3:3:3:3:3:3:3:3:3:3:3:/(*SX````@&1C]%3VDVDVDVDVDVDVD
XMVDVDVDVO3636363636363636363637/9R"Q<````%1`I_A[RTN(M+B+2XBTN
XM(M+RTN(M+B+2XBTO+2XBTN(M+B+2XBTBTA#0&WL````5#BG]'J2#H[*^P[*S
XMDX33T\+.P\+#P]38&WT````5#BG]'DT]/"SL/"P\/4@Z.ROL.RLY.$K`-[L`
XM```@&1W\'-1=8D'3-AT3<=$I'#D<-SLW/#@=#SV.(]6]3C/8XSU'H5FA0D6!
X,45=#43,XA'6`]?;V
X`
Xend
END_OF_FILE
  if test 6323 -ne `wc -c <'fonts.lj/R.10.pk.UU'`; then
    echo shar: \"'fonts.lj/R.10.pk.UU'\" unpacked with wrong size!
  fi
  # end of 'fonts.lj/R.10.pk.UU'
fi
if test -f 'fonts.lj/S.10.pk.UU' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fonts.lj/S.10.pk.UU'\"
else
  echo shar: Extracting \"'fonts.lj/S.10.pk.UU'\" \(5603 characters\)
  sed "s/^X//" >'fonts.lj/S.10.pk.UU' <<'END_OF_FILE'
Xtable
X !"#$%&'()*+,-./0123456789:;<=>?
X@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_
Xbegin 644 fonts.lj/S.10.pk
XM]UD``*``````````!":N``0FKL!#(0```"`?*?X>`1$!`OWRW_+?XBW_+?\M
XM_RW_+?\M\M`M$L/1*TT"L2/"H3.RTSHM/SDM7S<M?S4MGB,RV_,2W?3?\M7`
XM1B0````J)1+^$5;2:9M#)R58*!491BH3&T0=`2'$(M`1'1,2TB_233+]--(M
XM(A/1$1T"),$AT!1+$QHF2148*%4G(TN9;290P!8E````(!P6_A3$VO;:0*<"
XML*=-KVVDP-`S)@```"`;$OX15=0YE$)4<G&#4G&C,H&S$H'&CQU)\0$$@=:!
XMPA.!LC-RDE-Q@G1B-)95U-@M*@```"`3%/H3(!%=,3LS.34W-S4Y,SLQ/5`1
XM\P$5TQ.S,Y-3<W-3DS.S$]4!$J@)+0```"`9`OT*U\`K/````"`9&/T5V3UT
XMUDUDUDUDUDUDUDUDUDUO3:3:3:3:3:3:3:3:3:3:3:/(*ST````@&1C]%3VD
XMVDVDVDVDVDVDVDVDVDVO3636363636363636363637/9R!M#````&A4<_AO7
XM5(14HE]+%4LN)$P>TT347-"`P$1$````(QX=_AS1\M[TW&VQ%-H279$TV!1=
XM<536%EU1=-0873&4TAI=$;30'%P=!+'16ATDD=-8'41QU58=9%\=A#WQ`O#`
XM1D@````@&Q[^'*?5-3T3D[.SD]`W/2-4TD0]0S]-1"/6,4UH,;$XXCT#@QL3
XMC]9!/6,O340SU#1-)%/2-ST#D[.SD]$U/5>@P#%+````'1H=_QS.(MKB38;7
XM\136$EU?$TU"-=/Q5-(E71XA=-#B&4OB&TD=!(+$=*8Y7)@:3@```!P7'/X;
XMW..K'?\:,8XJ6/&C$";C&KW`R`]0````'QH<_AO=[<1*1,+`R$%2````'AD<
XM_AO;)-%272,UTB1-,472)%TA5-(571%EV$V%V$V?39+:':':'2%QTQ8=06'3
XM)1U"0=0D'4,QTU+:';'0'E,````/#Q;_$8=B4D+"PM'?+.(]/%MJ>FM-\\+1
XMLV#`*%0````@&QW^'#6U6(<Z:2)35$(2<S-SDR."DR*1LA/8;87:[339;4T6
XMP#I5````'AD<_AMM'2;7XDU9T3)!.C1#-S5$-39%,T9%0>5'1D%&14,V134U
XM1#<T0SHR03T9UN)-=M+14,`R5P```"`;'/X;?1U&V>)+5T9?)&147F141'-4
XM1']$0TDT0SLS0DPR0CT3%]5]GB39;4T6P#Q8````'AD=_AR7TD5+.3@]`U30
XM1#TC--)"/4,>1-1!/4,O320STC7ST#<[.?*R45*24O89%A$5)R42XH>!R#59
XM````(QX=_AL"\=\_/9%?/7%_/5&?/3&_/1'0\\'2\Z'4\X'6\V'8-!V4,=HR
XM';01W/3>\M'00EH````6%!_^':720K&!D9*"DF2"9(-BHN(!0H8S8U$C4H$3
XM0I$3,K0CLS+#(\,CLR\\,CPC.S,[)/.B8I*"<J)"U;"@,%P````@&2+]&;PK
XMI+A+A+A+A+A+A+A+A+A+A+D[Q+Q+Q+Q+Q+Q+Q+Q+Q+Q+Q+P@A->H+UX````@
XM&2+]&2O$O$O$O$O$O$O$O$O$O$O$O#N4N$N$N$N$N$N$N$N$N$N$NB";UY@)
XM7P```!45`P#WU<`P80```!L6$OX1A-,D+#8F$S<U$C@T$RDT$O.4(2\[,1,[
XM1.([-BI&*"$S$R4D(A97,\!(8@```!<7)?\<TETR0M$7+!@K&3D:.!LX&C@;
XM.!LI&C@5B104*Q5Z&RCQPH\<-N(<-QLW*S<K*!$9*1$8*1,D.A5<\=CC'8\=
XMD,`M8P```!44&_\15*$WD2EQ*V$B<E$BD4$QH4'2\2'3XA$=3RU>(=7B+4XR
XMU/+5&M`R9````!(/'?X<E9)!<6%BSB+3Q,3$M9(48S-34S-C,H(O."'SD2."
XM+S@3-R0G%287)!E7T!AE````$0T2_A%V4Y*BHZ*CJ3Y#ORPL)"94P#9F````
XM$A$E_QR^(=-J)!D221TATATBT2TATBT?+2'2XBT3T?+2XCTCT4T6R+?&T4T?
XM/1*B,=`VP"YG````%1(;_A$C93$C(D(A,A%C$3-T-'0S@_0X/C,X,^,X,S@U
XM*#TO/1XST?/2)L`Y:````!,0'?X<E+(BDD)R4F)B4V)2<D-S,H/R.",H,O.#
XM+1'B.#(X(S<S*#,G-/)R4F)B4H)"@C&TH-`8:0````\*$OX14GXC;C-N(V-_
XM-4]1(C)$0-`L:@```!@3$OX14H-39D-1)$-!0D-!LS'#$M0!"I-3CS8VXC<T
XM$3<S$3DC$BI"P#-K````&!,=_AQ4U#U//333XCU.(]--/STTTSTDT6PB.R,Z
XM)$@F-S8V-S4X0SHR.S$\02T#P"IL````&14;_Q%RDGXC@VXS@VXS@VXC@S$T
XM9#$E0B(A,Q533SU.,]3SU2U@T"=M````%1,2_A$6HN)#D_,Y-#@U."4X-3<V
XM-R<V)S8H-2DS.C(K;4`1P#1N````$A$E`!R^(=-H1!<R1ST#T.4](A:308(6
XM<=(M$M(=+RT>(](]%=![BXQM!='RH4'$4-`D;P```!01$OX1A:)"<V)3@D*2
XM,J(O.FXJ,?.3(X-"@E)R<D.E@,`J<````!@5$OX134/5+5(E%!@6%!<7$RT?
XM%"T/)"T!4L\D.S0[)3KS8Y)R<,`Q<0```!43&_\1M-`S*B8H)R<W)R@_4X/B
XM0X-3@E.#4X)C<G12<Q%"@R2O/2XSTO/3+4#`)W(````8%1+^$7T6TDTT1$DG
XM.#@G\Y)N(Y-CDG.#<X*#<J)BPD+170#`'W,````2$Q+^$4TCTRTR)2H6*1<=
XM4=3B+3XBT^(](]0LT"=T````%A,2_A$SL3$C@Q$S@Q$SD_0Z'T.QXC.Q3SH5
XM*A8X%S<9-1QGP#]U````&10E_AS2'5XQU>,=7QTVPR$B@S%#4E%20F%3(V%B
XM\3877W%F87;V%C(F%3,E%34D%"@R$CMM/C'5XQT`P$%V````&A8:_Q$TT1(3
XM.Q,32A@Y&3@:1APU'0-!T4,=(R'3,1U$UO/53573$CTA,]$4/0%4OQ<Z&$@:
XM-!(<,A(=%##`2'<````;%R7^'-3QV.,=CC'8&S@6$Q(V%3$3-A4Q$S47/T-1
XM@4-A@4-1D>(S88%#48%347%C46%S45&205&S(3+1?6'8XQV.(='`,'@````:
XM%Q(`$4'3%/'3/R'5(1UQ$:&1$9*2^B@1&2@A&2@2*"<B)D8CUT@95S=U5'"(
XM"7D````,`BG['MG0&WH````5#BG]'J2#H[*^P[*SDX33T\+.P\+#P]38&WL`
XM```5#BG]'DT]/"SL/"P\/4@Z.ROL.RLY.$K`(7P````@&Q/^$E73$XTA*]`1
XM14M86%M%01T+(=*#'34-`"D8#7T````@&Q3^$U3;5-M4R"Q^````%1`I_A[R
XMTN(M+B+2XBTN(M+RTN(M+B+2XBTO+2XBTN(M+B+2XBTBTA#`1G\````@'!_^
XM'56%B4E34R-3,W9S(I22$Y25XK*TXMM=D_$MDB/7,SU34M4F/3-ST3D\.SH]
XM`X/2-CU#0]8R/8(BV6VDW/+0P!NA````%0XE_1QQSRM)$2$7$B(4(R,A%24>
XMWV)@@!JB````*B4._A"D&L\:P:P:P3T:@:H:H:KQJA?0&Z,````5#B7]'&X!
XMXF%241(R,D$B(7$2$92_+1:0&J0````J)`[]$&&X\;@;@;@;?>(;H;H;KQNA
XML\@JI@```!42%/\3+331;"([(TDE1R=%*30J0O+&I"*30G125'(TDB.VQ-$M
XM,,`JJ````!42%/\3TRT4QK,BE#)T4E1R0Y(DIOPB2B0Y)4<G12E#*S(L;133
XM()@)L````!45`P`?U<@:M0```!P7&OX8[5+674,2U"(](S/0-5=8T-!XP!JV
XM````'!<:_AB'T-"%=5/0,STC(M0A/47M76+`*K<````<%1K]%IQ]%4TSU#U#
XMU2U3U2U3U?+6`?_6/6+6/6+6/6/6/636T9S`*;H````@&1K]%ITWU537/8/8
XM/9+9/9+9/9Y2VCVBVCVBVCVCVCVDVM6=,,@INP```"`9&OT6TYU=I-H]H]H]
XMHMH]HMH^7:+9/9+9/9+9/8/8/71=5].0P"R^````(!DB_1F=-]54USV#V#V2
XMV3V2V3V>0MH]HMH]HMH]H]H]I-K5G3"C_;#(++\````@&2+]&=.=7:3:/:/:
XM/:+:/:+:/DVBV3V2V3V2V3V#V#UT75?3"K_;$*@,R````!P7"_X.T^BZ(,`5
XMS````!40$/X15HI</]$04_'1/%J&4+!6S0```"HE)_X=PWS\'*5UQDP4PSQ3
XMP3QSL\DY/+-SS38L\E//-"T2,]$R\M,A/37FU5TS\2TR(]$S+1)#SS4L\F/-
XM-SRSD\D[/'/!/%/#3!3&5URL'/?#T!O.````$@TF_AQAOE.^(7,A(QT3(2-_
XM&^`2.^46P"7/````$@TE_AQAOC._%Q04$=WB8;XSL=P;XSOB%MT104%_&^,[
XM%L`KU0```!$1)_X=P]`B&R,J(CHC&N0M'D/1+1YCT2T>0]'D*A,J,BHC*Q(M
XM`\#0/-@````5$"/^'[\I02<D-B4U\F0S5BXB8B(34R;B4C9#-N)"1C-&XC)6
XM(U8B8_$B)B)E,_1B4U)C0G(4GRO`:=D````J)2?^'=&=W0V4E-5-!-(]0]`M
XM@K+:*2W"?RWB7R`0(RT8DB+"8X(BLF2"$K)TE*."I*+83ED]@A*2UR(I.A@B
XM*BH8(RHH&"0K)2DE+%HF+>)RW"DMHK+8+0/4/2303524V=#=G1"X#=H````9
XM%!7^%-[L3$W@F`O@````)0PI\!W7ZY>8#.$````E#"GP'^N5?2#`&>(````E
XM#2GP';*4A(2$A(6$CTA82.)7[<6`T!OC````)0XK^1^>U864E85UA6:#MK6E
XMM:6DI:[5R!CD````)0TI\!_MQ9XEE)6?2DE92DI*2DL@F`SP````)0TI^!W7
XMZYA0D`OQ````)0TI^!^.N=S(&?(````E#BGY'2Q+2TM+2TM*6DI:2N):2NVU
XMV!OS````)0TK\!_M65E)65E:6EHX5E975UA(5^U8P!KT````)0XI^1^>VUE)
XMXEE)64E924E)24E)2BS8"O4````E!2OP'PV0N`GV````*BD!``O=L"G[````
XM*B48_A7!\M;RUBUBUL^=%CU3TTTTUTUSV"V#U]&<^RV"V/+8\LH8"OP````9
XM%!7^%`\@L"G]````*B48_A7*\MCRV"V"O/G1V#USV$UTTTU#U2U3?1G/UBUB
X<UO+6\L'0$/X````@&QS^&M["P#CJTL`X]?;V]CUS
X`
Xend
END_OF_FILE
  if test 5603 -ne `wc -c <'fonts.lj/S.10.pk.UU'`; then
    echo shar: \"'fonts.lj/S.10.pk.UU'\" unpacked with wrong size!
  fi
  # end of 'fonts.lj/S.10.pk.UU'
fi
if test -f 'opt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'opt.c'\"
else
  echo shar: Extracting \"'opt.c'\" \(6281 characters\)
  sed "s/^X//" >'opt.c' <<'END_OF_FILE'
X/*
X	Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991 Chris Lewis
X		All Rights Reserved
X
X    See the LICENSE file for a full description of restrictions under which
X    this software is provided.
X
X    Function:		Optimizer module
X */
X
X#include "defs.h"
X
Xint specXPos, specYPos;
Xextern struct cattab tabN[], tabS[];
X
X#ifdef	OPT
X#ifndef	lint
Xstatic char SCCSid[] =
X    "@(#)opt.c: 2.4 Copyright 91/02/20 09:02:37 Chris Lewis";
X#endif
X
Xstruct insbuf {
X    char font, points, nc;
X    short xpos, ypos;
X};
X
X#define	INSBUFSIZ	200
X#define	OPTSIZ	100
Xstruct insbuf insbuf[INSBUFSIZ];
Xstatic struct insbuf *insptr = insbuf;
Xstatic int insypos = -1;
X
Xcanoninsert(xpos, ypos, font, points, nc)
Xregister int xpos, ypos;
Xregister int font, points, nc; {
X    DBP((D_CAT, "canoninsert: %d %d %d %d %d\n", xpos, ypos, font, points,
X	nc));
X
X    if (insypos != ypos || (insptr - insbuf >= INSBUFSIZ - 2)) {
X	canonflush();
X	insypos = ypos;
X    }
X    insptr->font = font;
X    insptr->points = points;
X    insptr->nc = nc;
X    insptr->xpos = xpos;
X    insptr++;
X}
X
X#ifdef	SORT
Xint xsortorder;
X
Xxsort(a, b)
Xregister struct insbuf *a, *b; {
X    int ret;
X    if (a->xpos < b->xpos)
X	ret = -1;
X    else if (a->xpos > b->xpos)
X	ret = 1;
X    else
X	ret = 0;
X    return(xsortorder * ret);
X}
X#endif
X
Xcanonflush() {
X    register struct insbuf *ip;
X    insptr--;
X    DBP((D_CAT, "canonflush: start: %d chars\n", insptr - insbuf + 1));
X
X    if (insptr < insbuf) {
X	insptr = insbuf;
X	return;
X    }
X
X    if (insptr->xpos < insbuf[0].xpos) {
X	DBP((D_CAT, "canonflush: BACK (%d chars)\n", insptr - insbuf + 1));
X#ifdef	SORT
X	xsortorder = -1;
X	insdump(insbuf, insptr);
X	qsort(insbuf, insptr - insbuf + 1, sizeof(struct insbuf), xsort);
X	insdump(insbuf, insptr);
X#endif
X	for(ip = insptr;ip >= insbuf; ip--)
X	    canonchar(ip->xpos, insypos, ip->font, ip->points, ip->nc);
X    } else {
X	DBP((D_CAT, "canonflush: FORW (%d chars)\n", insptr - insbuf + 1));
X#ifdef	SORT
X	xsortorder = 1;
Xinsdump(insbuf, insptr);
X	qsort(insbuf, insptr - insbuf + 1, sizeof(struct insbuf), xsort);
Xinsdump(insbuf, insptr);
X#endif
X	for(ip = insbuf;ip <= insptr; ip++)
X	    canonchar(ip->xpos, insypos, ip->font, ip->points, ip->nc);
X    }
X    insptr = insbuf;
X    optflush();
X}
X
Xcanonchar(xpos, ypos, font, points, nc)
Xregister int xpos, ypos;
Xregister int font, points, nc; {
X    static struct insbuf lastchar;
X    static short lastypos;
X    static sstate = 0;
X    static char sbuf[512];
X    register char *p;
X#ifdef	INSPECIAL
X    /* Inline special directives, not supported yet */
X    switch(sstate) {
X	case 0:
X	    if (font == symidx && nc == 34) {
X		sstate = 1;
X		lastchar.xpos = specXPos = xpos;
X		lastchar.font = font;
X		lastchar.points = points;
X		lastchar.nc = nc;
X		lastypos = specYPos = ypos;
X		optflush();
X		return;
X	    }
X	    break;
X	case 1:
X	    if (font == symidx && nc == 34) {
X		if (xpos == lastchar.xpos && ypos == lastypos) {
X		    sstate++;
X		    sbuf[0] = '\0';
X		    return;
X		} else {
X		    lastchar.xpos = xpos;
X		    lastypos = ypos;
X		    /* stay in this state */
X		}
X	    } else
X		sstate = 0;
X
X	    if (be->beputchar)
X		(*be->beputchar)(lastchar.xpos, lastypos, lastchar.font,
X		    lastchar.points, lastchar.nc, (char *) NULL);
X	    break;
X	case 2:
X	    if (nc == 34 && font == symidx) {
X		DBP((D_CAT, "Special inline sequence: %s\n", sbuf));
X		dospecial(sbuf);
X		sstate = 0;
X		return;
X	    }
X	    if (strlen(sbuf) > sizeof(sbuf) - 1) {
X		fprintf(stderr,
X		    "%s: unterminated/too long \\(bs\\(bstr\\(bs\n",
X		    progname);
X		sstate = 0;
X		return;
X	    }
X	    if (font == symidx)
X		p = tabS[nc].ch_name;
X	    else
X		p = tabN[nc].ch_name;
X	    if (strlen(p) >= 2) {
X		if (strcmp(p, "hy") == 0 ||
X		    strcmp(p, "mi") == 0 ||
X		    strcmp(p, "\\-") == 0)
X		    p = "-";
X		else if (strcmp(p, "ff") == 0 ||
X			 strcmp(p, "fi") == 0 ||
X			 strcmp(p, "fl") == 0)
X		    ;
X		else if (strcmp(p, "Fi") == 0)
X		    p = "ffi";
X		else if (strcmp(p, "Fl") == 0)
X		    p = "ffl";
X		else
X		    p = " ";
X	    }
X	    strcat(sbuf, p);
X	    return;
X    }
X#endif
X    optinsert(xpos, ypos, font, points, nc);
X}
X
Xint optxpos, optypos;
Xint optfont, optpoints, optnc, origxpos;
Xchar optbuffer[OPTSIZ];
Xchar *optp = optbuffer;
X
Xoptflush() {
X
X    if (!optimize)
X	return;
X
X    if (optbuffer[0] && be->beputchar)
X	(*be->beputchar)(origxpos, optypos, optfont, optpoints, optnc,
X	    optbuffer);
X    optbuffer[0] = '\0';
X    optp = optbuffer;
X}
X
Xoptinsert(xpos, ypos, font, points, nc)
Xint font, points, nc;
Xint xpos, ypos; {
X    struct troff2befont *bp;
X    static char *wp;
X    extern struct cattab tabN[], tabS[];
X    struct cattab *ct;
X    register char *from;
X    int cantcache;
X
X    if (!optimize) {
X	if (be->beputchar)
X	    (*be->beputchar)(xpos, ypos, font, points, nc, (char *) NULL);
X	return;
X    }
X
X    DBP((D_CHAR, "OLD: x,y,f,p,c = %d,%d,%d,%d,%d\n",
X	optxpos, optypos, optfont, optpoints, optnc));
X    DBP((D_CHAR, "NEW: x,y,f,p,c = %d,%d,%d,%d,%d\n",
X	xpos, ypos, font, points, nc));
X
X    /* the 10 is to ensure that there's enough room for moderately
X       long multiple-character sequences */
X
X    if (ypos != optypos || optfont != font || optpoints != points ||
X	wp != xlatetable[font]->widthtable ||
X	optp > optbuffer + OPTSIZ - 10)
X	optflush();
X
X    wp = xlatetable[font]->widthtable;
X
X    if (font == symidx) {
X	bp = &be->besymfont[nc];
X	ct = &tabS[nc];
X    } else {
X	bp = &be->bestdfont[nc];
X	ct = &tabN[nc];
X    }
X
X    cantcache = !wp || (int) wp == 1 || (font == symidx ? bp->t2b_font != S:
X			     bp->t2b_font != N);
X
X    if (bp->t2b_xc || bp->t2b_yc || bp->t2b_scale || cantcache)
X	optflush();
X
X    if (optxpos != xpos)	/* handle spaces one day... */
X	optflush();
X
X    if (!optbuffer[0]) {
X	optypos = ypos;
X	optxpos = xpos;
X	origxpos = xpos;
X	optfont = font;
X	optnc = nc;
X	optpoints = points;
X    }
X
X    if (cantcache) {
X	if (be->beputchar)
X	    (*be->beputchar)(xpos, ypos, font, points, nc, (char *) NULL);
X	return;
X    }
X
X    optxpos += ((wp[ct->ch_wididx]) * points + 3) / 6;
X    DBP((D_CAT, "optxpos: %d\n", optxpos));
X
X    for (from = bp->t2b_charseq; *from;)
X	*optp++ = *from++;
X    *optp = '\0';
X}
X#endif
X
X#ifdef	SORT
Xinsdump(b, p)
Xregister struct insbuf *b, *p; {
X    if (!(debug&D_VERB))
X	return;
X    DBP((D_VERB, "insdump:\n"));
X    for(; b <= p; b++)
X	DBP((D_VERB, "%d %d\n", b->xpos, b->nc));
X}
X#endif
END_OF_FILE
  if test 6281 -ne `wc -c <'opt.c'`; then
    echo shar: \"'opt.c'\" unpacked with wrong size!
  fi
  # end of 'opt.c'
fi
if test -f 'pkc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pkc.c'\"
else
  echo shar: Extracting \"'pkc.c'\" \(5715 characters\)
  sed "s/^X//" >'pkc.c' <<'END_OF_FILE'
X/*
X	Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991 Chris Lewis
X		All Rights Reserved
X
X    See the LICENSE file for a full description of restrictions under which
X    this software is provided.
X
X    Function:		PK Cache - handles incremental downloading for
X			laserjets
X
X*/
X
X#include "defs.h"
X
X#if	defined(PARTIAL) || defined(INCR)
X
X#ifndef	lint
Xstatic char SCCSid[] =
X    "@(#)pkc.c: 2.2 Copyright 91/02/20 09:06:57 Chris Lewis";
X#endif
X
X#include "pk.h"
X
X#include "pkc.h"
X
Xextern int fontCount;
X
X/*	Does the font *need* this character? */
Xextern struct needmaps *needmaps;
X
Xneedchar(font, ch)
Xregister int font;
Xregister long ch; {
X    register struct needmaps *nbp;
X
X    ch &= 0xff;
X
X    if (ch <= ' ' || (ch > 0x7f && ch <= (0x80 + ' ')))
X	return(0);
X    ch -= ' ';
X    if (ch >= 0x80 - ' ')
X	ch -= ' ';
X
X    if (font >= 0 && font <= 2)	/* redirections to NORM fonts */
X	font = N;
X    else if (font == 3)		/* redirections to SYMBOL font */
X	font = S;
X
X    for (nbp = needmaps; nbp; nbp = nbp->next)
X	if (nbp->fontnum == font) {
X	    return(nbp->NMAP(ch / ELEN) & (1 << (ch % ELEN)));
X	}
X    return(0);
X}
X
X
Xaddneedchar(font, ch)
Xregister int font, ch; {
X    register struct needmaps *nbp, *onbp = (struct needmaps *) NULL;
X    ch &= 0xff;
X
X    if (ch <= ' ' || (ch > 0x7f && ch <= (0x80 + ' ')))
X	return;
X    ch -= ' ';
X    if (ch >= 0x80 - ' ')
X	ch -= ' ';
X
X    if (font >= 0 && font <= 2)	/* redirections to NORM fonts */
X	font = N;
X    else if (font == 3)		/* redirections to SYMBOL font */
X	font = S;
X
X    for (onbp = (struct needmaps *) NULL, nbp = needmaps;
X	nbp; onbp = nbp, nbp = nbp->next)
X
X	if (nbp->fontnum == font)
X	    break;
X
X    if (!nbp) {
X	nbp = (struct needmaps *) mustmalloc(sizeof(struct needmaps),
X	    "needmaps");
X	nbp->fontnum = font;
X	if (!onbp)
X	    needmaps = nbp;
X	else
X	    onbp->next = nbp;
X    }
X    if (ch == -1)
X	return;
X    nbp->NMAP(ch / ELEN) |= (1 << (ch % ELEN));
X}
X
X#endif
X
X#ifdef	INCR
Xdownchar(font, ch, pointidx)
Xint font, ch, pointidx; {
X    ch &= 0xff;
X    if (ch <= ' ' || (ch > 0x7f && ch <= (0x80 + ' ')))
X	return(0);
X    ch -= ' ';
X    if (ch >= 0x80 - ' ')
X	ch -= ' ';
X    return(fonttable[font].map->DMAP(ch / ELEN, pointidx) &
X	(1 << (ch % ELEN)));
X}
X
Xsetdown(font, ch, pointidx)
Xint font, ch, pointidx; {
X    ch &= 0xff;
X    if (ch <= ' ' || (ch > 0x7f && ch <= (0x80 + ' ')))
X	return;
X    ch -= ' ';
X    if (ch >= 0x80 - ' ')
X	ch -= ' ';
X    fonttable[font].map->DMAP(ch / ELEN, pointidx) |= (1 << (ch % ELEN));
X    fonttable[font].map->lastpage[pointidx] = currentPage;
X}
X#endif
X
X#if	defined(DEBUG) && defined(PARTIAL)
Xdumppartmaps() {
X    register struct needmaps *nbp;
X    register int c;
X    fprintf(diagFile,"MASKLEN: %d, ELEN: %d\n", MASKLEN, ELEN);
X    for (nbp = needmaps; nbp; nbp = nbp->next) {
X	fprintf(diagFile,"Font: %02x, needmap:", nbp->fontnum);
X	for (c = 0; c < MASKLEN; c++)
X	    fprintf(diagFile," %08x", nbp->NMAP(c));
X	fprintf(diagFile,"\n");
X    }
X}
X
X#ifdef	INCR
Xdumpincrmaps() {
X    static char ptsizes[] =
X	 {6, 7, 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 28, 36};
X    register struct downmaps *dbp;
X    register int c, p, fn;
X    fprintf(diagFile,"MASKLEN: %d, ELEN: %d\n", MASKLEN, ELEN);
X    for (fn = 0; fonttable[fn].troffName; fn++) {
X	dbp = fonttable[fn].map;
X	if (!dbp)
X	    continue;
X	fprintf(diagFile,"Font: %02x, troffname: %s, downloadedmaps:\n",
X	    fn, fonttable[fn].troffName);
X	for (p = 0; p < NPTSIZE; p++) {
X	    if (!dbp->nm[p])
X		continue;
X	    fprintf(diagFile,"f%02d p%02d:%02d lp%d %s:", fn, p,
X		ptsizes[p], dbp->lastpage[p], dbp->pkfont[p] ? "load": "unlo");
X	    for (c = 0; c < MASKLEN; c++)
X		fprintf(diagFile," %08x", dbp->DMAP(c,p));
X	    fprintf(diagFile,"\n");
X	}
X    }
X}
X#endif
X
Xdumpmaps(which)
Xint which; {
X    DBP((D_FONT,"dumpmaps: %d\n", which));
X    if (diagFile && (debug&D_FONT)) {
X	switch(which) {
X	    case 0: dumppartmaps(); break;
X#ifdef	INCR
X	    case 1: dumpincrmaps(); break;
X#endif
X	}
X    }
X}
X
X#endif
X
X#ifdef	INCR
X/*	Go find "oldest" font and delete it, both internally *and*
X	on the printer.  It cannot already be in use on this page.
X */
Xpkflush(needfont, needpoint)
Xint needfont, needpoint; {
X    register int oldestpage = 32767, p;
X    int bestpoints, bestfont;
X    register struct downmaps *dbp;
X    int font;
X
X    DBP((D_FONT, "Flushing font - avoid font %d, ps: %d\n",
X	needfont, needpoint));
X
X    for (font = 0; fonttable[font].troffName; font++) {
X
X	if (!(dbp = fonttable[font].map))
X	    continue;
X
X	for (p = 0; p < NPTSIZE; p++) {
X	    if (!dbp->pkfont[p] || (font == needfont && needpoint == p))
X		continue;
X
X	    /* if font in use, and less than oldest page */
X	    DBP((D_FONT, "Checking font %d, point: %d, lastpage: %d\n",
X		font, p, dbp->lastpage[p]));
X
X	    if (dbp->lastpage[p] && dbp->lastpage[p] < oldestpage) {
X		oldestpage = dbp->lastpage[p];
X		bestpoints = p;
X		bestfont = font;
X	    }
X	}
X    }
X
X    /* oh-oh! */
X    if (oldestpage >= currentPage) {
X
X	fprintf(stderr, "Too many fonts on page %d, SIMPLIFY!\n", currentPage);
X
X    } else {
X	dbp = fonttable[bestfont].map;
X
X	DBP((D_FONT, "Dismembering font %d, pointidx: %d, p: %x\n", bestfont,
X	    bestpoints, dbp->pkfont[bestpoints]));
X
X	/* Clobber PK */
X	pk_destroy(dbp->pkfont[bestpoints]);
X
X	/* Clobber PK pointer */
X	dbp->pkfont[bestpoints] = (struct pkp *) NULL;
X
X	/* clear downloaded arrays */
X	clrarray((char*) &dbp->DMAP(0,bestpoints), MASKLEN * sizeof(ETYP));
X
X	/* reset lastpage */
X	dbp->lastpage[bestpoints] = 0;
X
X	/* tell backend that this font isn't downloaded anymore */
X	fonttable[bestfont].fontFlags[bestpoints] =
X	    tolower(fonttable[bestfont].fontFlags[bestpoints]);
X
X	fontCount--;
X	/* Select and nuke downloaded font */
X	printf("\033*c%dd2F", (bestfont << 4) + bestpoints);
X    }
X}
X#endif
END_OF_FILE
  if test 5715 -ne `wc -c <'pkc.c'`; then
    echo shar: \"'pkc.c'\" unpacked with wrong size!
  fi
  # end of 'pkc.c'
fi
if test -f 'psroff.S' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'psroff.S'\"
else
  echo shar: Extracting \"'psroff.S'\" \(5952 characters\)
  sed "s/^X//" >'psroff.S' <<'END_OF_FILE'
X%%STARTSHELL%%
X#	Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991 Chris Lewis
X#		All Rights Reserved
X#
X#    See the LICENSE file for a full description of the restrictions
X#    under which this software is provided.
X#
X#	Specs:		troff2ps driver
X#
X#ident  "@(#)psroff.sh: 2.15 Copyright 91/03/26 00:13:16 Chris Lewis"
X
XLIBDIR="%%LIBDIR%%"
XFONTDIR="%%FONTDIR%%"
X
Xterm=false
Xfail=false
Xif [ -n "$PSROFF" ]
Xthen
X    type=$PSROFF
Xelse
X    type=`basename $0 | sed -n -e 's;^\([^/]*\)roff$;\1;p'`
X    if [ -z "$type" ]
X    then
X	echo "psroff: Can't intuit psroff type from $0" >&2
X	echo "or set PSROFF environment variable" >&2
X	exit 1
X    fi
Xfi
Xcopies=1
Xfor i in $*
Xdo
X    case $i in
X	-F)
X	    fail=true
X	    ;;
X	-X)
X	    set -x
X	    debug=1
X	    ;;
X	-V)
X	    version=1
X	    ;;
X	-t)
X	    term=true
X	    ;;
X	-T*)
X	    type=`echo $i | sed -e 's/-T//'`
X	    ;;
X	-d*)
X	    sptr=`echo $i | sed -e 's/-d//'`
X	    ;;
X	-n*)
X	    copies=`echo $i | sed -e 's/-n//'`
X	    ;;
X	-D* | -M | -R* | -O* | -P* | -Z)
X	    extraargs="$extraargs $i"
X	    ;;
X	-m* | -c*)
X	    macros="$macros `echo $i | sed -e 's/-[cm]//'`"
X	    ;;
X	-)
X	    files="$files $i"
X	    ;;
X	-rL*)
X	    eval `echo $i | sed -e 's/-rL\(..*\)\(.\)$/length=\1 prec=\2/'`
X	    if [ -z "$length" -o -z "$prec" ]
X	    then
X		echo "$0: Bad length definition ($i) - must have value and scale" \
X		    >&2
X		exit 1
X	    fi
X	    extraargs="$extraargs -l$length$prec"
X	    args="$args $i"
X	    ;;
X	-*)
X	    args="$args $i"
X	    ;;
X	*)
X	    files="$files $i"
X	    if [ ! -r $i ]
X	    then
X		echo "$0: cannot open $i" >&2
X		exit 1
X	    fi
X	    ;;
X    esac
Xdone
X
Xif [ -z "$files" ]
Xthen
X    files="-"
Xfi
X
X#	Find some pieces:
Xif [ -f troff2ps ]
Xthen
X    t2=./troff2ps
Xelse
X    t2=$LIBDIR/troff2ps
Xfi
Xif [ -n "$version" ]
Xthen
X    exec $t2 -V
Xfi
X
Xif [ -r psrofflib ]
Xthen
X    psrofflib=psrofflib
Xelif [ -r lib/psrofflib ]
Xthen
X    psrofflib=lib/psrofflib
Xelse
X    if [ -r $LIBDIR/lib/psrofflib ]
X    then
X	psrofflib=$LIBDIR/lib/psrofflib
X    fi
Xfi
X
Xif [ -z "$psrofflib" ]
Xthen
X    echo "$0: Can't find psrofflib in ., lib, or $LIBDIR/lib" >&2
X    exit 1
Xfi
X
XF=''
X#	If your system has no awk (or a busted one), you may have to
X#	comment out the "line=`awk ... $psrofflib" lines, and uncomment
X#	the sed script.  If you do, you won't be able to continue
X#	psrofflib lines, so you'll have to "join" the entries in psrofflib
X#	(remembering to delete the name fields in the continuation lines).
Xline=`awk '
X    $1 ~ /^#/ {next}
X    $0 ~ /^troff/ { print $0 }
X    $1 == "'$type'" {
X	seen=1
X	print "F='T'" substr($0, length($1) + 1)
X	next
X    }
X    { if (seen) exit(0) }
X' $psrofflib`
X#line=`sed -n -e '/^troff/p' \
X#	     -e "/^$type[ 	]/{
X#		 s/^$type[ 	]*\(.*\)$/F='T' \1/p
X#		 q
X#		}" $psrofflib`
X
Xif [ -z "$line" ]
Xthen
X    echo "$0: Can't find a line for '$type' in $psrofflib" >&2
X    exit 1
Xelse
X    eval "$line"
X    if [ -z "$F" ]
X    then
X	echo "$0: Can't find a line for '$type' in $psrofflib" >&2
X	exit 1
X    fi
Xfi
X
X#	If -N in t2arg, then this is ditroff.
Xif [ -n "`echo "$t2arg" | sed -n -e '/-N/p'`" ]
Xthen
X    otroff=
X    widtharg="-T$width"
Xelse
X    otroff=-t
Xfi
X
X#	Try to find troff
Xif [ -z "$troff" ]
Xthen
X    #	Use path instead
X    troff=troff
Xelse
X    if [ ! -f $troff ]
X    then
X	echo "$0: $troff: not executable" >&2
X	exit 1
X    fi
Xfi
X
X#	Sanity checking for width tables
Xif [ -n "$otroff" ]
Xthen
X    if [ -z "$trofftype" ]
X    then
X	widtharg=''
X    else
X	if [ ! -d $FONTDIR/$width ]
X	then
X	    echo "$0: Warning: widths not installed" >&2
Xcat >&2 <<!
XCAT Troff width tables have not been installed in $FONTDIR/$width/ft\*.
XEither you've not installed psroff yet, or your 'width' setting in psrofflib
Xis incorrect.  Continuing anyways, using the default CAT troff widths found
Xin $FONTDIR/ft\*, but the character spacing may be somewhat strange.
XYou should investigate your configuration (see the README and TROUBLE files).
X!
X	    widtharg=''
X	else
X	    widtharg=`eval echo $trofftype`
X	fi
X    fi
Xelse
X    if [ ! -d $FONTDIR/dev$width ]
X    then
X	echo "$0: Ditroff widths not installed!  Aborting" >&2
X	exit 1
X    fi
Xfi
X
Xif [ -z "$t2arg" ]
Xthen
X    echo "$0: t2arg isn't set for $type" >&2
X    exit 1
Xfi
X
Xt2arg="$t2arg $extraargs"
X
X#	command line -d option overrides ptr in psrofflib.
Xif [ -n "$sptr" ]
Xthen
X    ptr=$sptr
Xfi
X
Xif [ -n "$debug" ]
Xthen
X    (
X    echo "troff=$troff"
X    echo "trofftype=$trofftype"
X    echo "width=$width"
X    echo "t2arg=$t2arg"
X    echo "lparg=$lparg"
X    echo "widtharg=$widtharg"
X    echo "ptr=$ptr"
X    echo "files=$files"
X    echo "args=$args"
X    echo "otroff=$otroff"
X    echo "$troff $otroff $widtharg $args $files"
X    ) >&2
Xfi
X
X#	Handle macro business
Xml=''
Xfor i in $macros
Xdo
X    if [ -z "$otroff" ]
X    then
X	ml="$ml -m$i"
X    else
X	mac="$LIBDIR/adapters/mac.$type/tmac.$i"
X	if [ ! -r $mac ]
X	then
X	    mac="$LIBDIR/adapters/tmac.$i"
X	fi
X	if [ ! -r $mac ]
X	then
X	    mac="%%T2DIR%%/tmac.$i"
X	fi
X	if [ ! -r $mac ]
X	then
X	    mac="%%RTMACDIR%%/tmac.$i"
X	fi
X	if [ ! -r $mac ]
X	then
X	    echo "$0: Couldn't find tmac.$i anywhere!" >&2
X	    exit 1
X	fi
X	ml="$ml $mac"
X    fi
Xdone
X
Xif [ -z "$ml" -a -n "$otroff" -a -r $LIBDIR/adapters/cmn.pre ]
Xthen
X    ml=$LIBDIR/adapters/cmn.pre
Xfi
X
Xif [ -z "$otroff" -a -r $LIBDIR/adapters/cmn.dit ]
Xthen
X    ml="$ml $LIBDIR/adapters/cmn.dit"
Xfi
X
X#	Okay, let's DO it!
X
Xif $fail
Xthen
X    $troff $otroff $widtharg $args $ml $files > /dev/null
X    rc=$?
Xelif $term
Xthen
X    if [ -n "$otroff" ]
X    then
X	( $troff $otroff $widtharg $args $ml $files 2>&1 ) | $t2 $t2arg
X	rc=$?
X    else
X	$troff $widtharg $args $ml $files | $t2 $t2arg
X	rc=$?
X    fi
Xelse
X    if [ -n "$otroff" ]
X    then
X	if [ -n "$v" ]
X	then
X	    eval "( cat $files | %%LIBDIR%%/catconv |
X		$troff $otroff $widtharg $args $ml - 2>&1 ) | $t2 $t2arg $lparg"
X	    rc=$?
X	else
X	    eval "( $troff $otroff $widtharg $args $ml $files 2>&1 ) |
X		$t2 $t2arg $lparg"
X	fi
X	rc=$?
X    else
X	eval "$troff $widtharg $args $ml $files 2>&1 | $t2 $t2arg $lparg"
X	rc=$?
X    fi
Xfi
Xexit $rc
END_OF_FILE
  if test 5952 -ne `wc -c <'psroff.S'`; then
    echo shar: \"'psroff.S'\" unpacked with wrong size!
  fi
  # end of 'psroff.S'
fi
if test -f 'utils/fonts/cmtt10.pk.UU' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/fonts/cmtt10.pk.UU'\"
else
  echo shar: Extracting \"'utils/fonts/cmtt10.pk.UU'\" \(6254 characters\)
  sed "s/^X//" >'utils/fonts/cmtt10.pk.UU' <<'END_OF_FILE'
Xtable
X !"#$%&'()*+,-./0123456789:;<=>?
X@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_
Xbegin 644 utils/fonts/cmtt10.pk
XM]UD11T9T;U!+(#$N,B!O=71P=70`H```W^H\>``$)JX`!":NT"9!"&9B%A,9
XM_QB#`1]0$/(2WB,3PC*^0S.?-3C[?6XC<T<W&#@7-Q#`+$((9F(6$AG_&!Q=
XM)-)39%-T3B.#0W1#<UT%_&-54X-#A.,SDS.$,W0M,=,]!-`G0PAF8A81&?X8
XM=3)<335%)'04A!23$Z?>8P$$`0.C\4DR1T-41;>:5<`G1`AF8A83&0`8'&TE
XMTF-D8W13A$\Y-#E.<SH_,Y-#A$-T4V4](])<8+`@10AF8A83&?\8'%'&+%3C
XM.33SQ/-3CBN/-3@\3D.C'9'&V!Q&"&9B%A,9_Q@#OC,Z/S,!+S4XXKCS4XY3
XMV:J9H-`O1PAF8A82&?X893)[745%1&0T=#2#,Y,D`0XS`1-W$VQW%),SDS]'
XM1$9$5%77N%(RT!U("&9B%A,9_Q@7-QD9%S=.8W-N+6Z#<T<W&1D7-Q"H#4D(
XM9F(6#QG]&-+K=C;2P!=*"&9B%A`9_1A::UJ^TC0G,T8S136UJ&?0-DL(9F(6
XM%!D`&!='&3@71T-T8V1S8X-3DT23-*,DLR/#%;FZI2.D0Y-3GS8X\W-S@T=6
XM&3@75A#8$TP(9F(6$QG_&.*L[3`2.Q3C.@/@V"I-"&9B%A,9_QAGWU<C$5$3
XM3D,2,A-#$Q,33C,B$B-#)2-/,S,TY#DRXG5PT#5."&9B%A,9_Q@61Q@I%S=#
XM$5-N(Q)#;S$S-O,B,VXC(R-O,R(V\S,3;B-"$V-1$T<U.25'1##0&D\(9F(6
XM$1G^&#M=,!$D=!27[;?Y04="`1/5L]`E4`AF8A82&?\8'%`10!%394.#0X3B
XM,Y,SA#.#0V5-7&J.8]>IIZ#`)U$(9F(6$1_^&#M=`](D=!27[+93-D0W1!04
XM1RTCT%O1/131/131\Q#0*U((9F(6%!G_&!J=C9-4@V1^,W-S9'-4BYJKDU.>
XM,V.#8S%/-C(Q=6&48G9"P"I3"&9B%A$9_AA6,DT"TB1E%(0?.C$]%-%-"+FI
XMM]%-%/T6^WF70=(M$R-UT!14"&9B%A,9_Q@0/>-34^`0@]F;F5#`&E4(9F(6
XM%1D`&!=7&3D75T[2.3?S<Y-3J[G16,@E5@AF8A83&?\8==(])7(Y->,W-^,U
XM.24JXS,[(RSB,3T"$M'UTCC8,%<(9F(6$QG_&&?5UVXA.S,K).(Y-#,S-/,E
XM(T,B$B->4B(2(F(A,2)B$C(2?T-(-33`-%@(9F(6$QG_&!<V-R<W-F-$@T.C
XM)*,CPQ/&T5T4TSTDTET&T#$[03OS,Y\U-S<T<W&#@7-QR"!9"&9B%A,9_QAU
XMTCTE?S-S?S4YXC,[\Q/0]=+G/1>YMV#0)EH(9F(6$1G^&!`WHQ.4$X0C@]3$
XMT]3$T]3$T]3$<S.#)(,4DQ.@.,`D80AF8A83$OX1.)Q]!D5')TT_.I?%931(
XM-/.31'1%55U2DF154,`L8@AF8A84&0`8%M!]%M3C/4,UDQE]%E551T7SE.-#
XMHT.41(-4=%54;18QB2-&T!YC"&9B%A`2_1%G>TPT5"1R,\3.,]33DQ2#)50\
XM6H9`P"QD"&9B%A09_QBFT'T6U.,Z0SB!-M%D551T3TDTXSHT231(14955&;4
XM21=5-A#`'F4(9F(6$!+]$669:T14)',CEJ`I_1.3%(,D9#Q:AD#`&V8(9F(6
XM$1G_&+6HB70D<T*/.-(?TXZSG0/2/0+`,6<(9F(6$QS_$64T72/3-#0B-%1N
XM(W-D5'0TBXJ#%:\]2XT%TR24%+?BT'M!5U/2:Z=@P"-H"&9B%A49`!@6T7TF
XMU>,]4S2S&)T(5$CT8XZ#<UDW&R@9-Q#0%6D(9F(6$!K]&7+?32!*XIWK-P(1
XM`1#`&6H(9F(6#2/^&:*O2B`KXJ[5HQ)C%$0;.5=`P"YK"&9B%A09`!@6T'T6
XMU.,]3B,J4U2#1),THR2S%,C)M12D-)-3DV.#9$A-0H&$<*@.;`AF8A81&?X8
XMXJL^MS?8R!YM"&9B%A42`!%2-#2Q8]9%)2-$-#-.DT-#+W)2PT-`P!QN"&9B
XM%A42`!$6-'<8;3A42/1CCH-S63<;*!DW$-`?;PAF8A81$OX19:E[5%0T=".3
XM'D.WE!.3)'0T5%MYI6#`*W`(9F(6%!L`$18U5QE-1E551T7SE.-#HT.41(-4
XM=%54;18QB#-*Y3T9JZF@P"UQ"&9B%A0;_A%5,WD3;15494942$1)-.,Z-$DT
XM2$5&551FT7D3E3/4Y3T9JZD0R!ER"&9B%A,2_Q&$88+4&E=19M!='TTN8[XM
XM%=`><PAF8A8/$OT11Q(\+11D'S@Q3(F8FX^7B&`4'2(V0,`>=`AF8A81%_\6
XM8M'C.M(?TVYCT3<6\V-35%1$:GFE0,`;=0AF8A85$@`1%D9'-U9&CI-S@V2$
XM18TVTV4V$-`?=@AF8A83$O\1%S<8.!<W0W-D5'XC4YXS,[XC$]]0$3C((W<(
XM9F(6$Q+_$8/4'4..,CDT,S,U\B4B8B(2(FXS$A(3?B0T0,`J>`AF8A83$O\1
XM%S<G*"<W5#.C)+,3QM%=(])-)=`Q.S)*,SDU-7-Q@I%S<=`P>0AF8A83&_\1
XM%S<9*!<W0W-S8W\U.30Y\S._,CLR+?(3`0XD`1XC`1.D(Z04J,;4T-`@>@AF
XM8A82$O\1(!+Q`3$Y0CA#-TU-3%Q<34U(,DDQ2@.PJ!(`"&9B%A,9_QC>XS.C
XMZS,[+BJ0P"4!"&9B%A(9_AAST?70(2SS$[(RKB,SCC-3;B-S3B.3))03LQXM
XM0=`?`@AF8A81&?X8.UTP$21T%)?DMN0U-N2WE!1T(!$]6S#`(P,(9F(6$QG_
XM&(/2]='R$M#B,3PC*^0S.>,U-^,W-'-Q@X%S<;`;!`AF8A83&?\8+$+\4O.S
XM`U-3CBN#4P6O/!W1QL`7!0AF8A83&?\8'4'6'43M4W-'-QD9%S<0H"8&"&9B
XM%A$9_A@=<3H_(Y,S@S2S.T\[3B.R\[([)+(X/R.3$Z,<8;7`'`<(9F(6$1G^
XM&#-31C8C$Q,3'S,A(V0T/M)SOBE`P"(("&9B%A$9_AA.*;XSQXM-(D(R0>(T
XM-#%",D+22X?.,[XI0-`D"0AF8A81&?X83BF_."0T9#1S,TY!,S,S,C(T03%%
XMMYI=XSOBE-`E"@AF8A83&?\8=<F;=%14=$.3/E.S/B.37S<WXC4T\R,S*_.!
XM='#0)#`(9F(6$1G^&&6I>V0T4W,T="\Y,><[>4\3DR1T-%14-&MYI6#0%C$(
XM9F(6#AG\&'*_.DE6A98R.^TVPM'!T"@R"&9B%A$9_AA6FE`0-%84A!28^C\!
XM`]33U,3$Q,2UM,3$<R2#$",0$L`I,PAF8A81&?X85IM-$T921T)(/1/0]+5Y
XMB)G132/13]%Z>8DQ5E+13(9@T"<T"&9B%A,9_QB5UM(3PQ._,CHS.4,Y-#A$
XM-T4W-C9&-4<U`[Y+/.*QP"0U"&9B%A$9_A@N+03F/1,6?%T$1D,I/131,2MZ
XM>8A!5E+16I9@T"XV"&9B%A$9_AB%J6Q%1#54-&0D@C/4U"=#&R`1)70?27M_
XMHQ.C%(04=#153&FE8-@;-PAF8A81&OX9,!`#B4$X33T]33WSWB/>,]YCD-`I
XM.`AF8A81&?X85XM=-544E^*S$Y,E54N'BU14,Y,4E^*WE!.3)54]6X=0T"XY
XM"&9B%A$9_AAEJ6Q%5#1T%),3HQ\Z>W^4%'4@$2L31S/4TS*$)',T9#1%3&FE
XM@,`V)`AF8A81(/X<@M'B/'BUT243)!0S-^)#.#-")".)J:FHDR2#..(S1D,X
XM,S04(Q4]!;AM#STB<,`Y)@AF8A83&?\88])L>T(ZXC,Z,S%C,C)C,4)D8S=3
XM.$0W139C-G,V,C(U,W8T9O-4,R,V(RU#<F5&,]`>/PAF8A8/&?T81VL]%'CX
XM,2A)65E96DOC/"!++/3"<-`?#PAF8A8/&?T/8L],($LM.TOSOTI)6DI((?.(
XM=!T[9T"P$!`(9F(6$!+]$1XIP>LWTQPPP!01"&9B%@T;_A$^*NU:,28Q1$&S
XME73`,QD(9F(6$QG_&(:Z?15&13@U-T4V4F*"<F5B=S56-D8W13@U.$Y$.30S
XM(T0R04)BD7)T9$3`*1H(9F(6$Q+_$35#6"8]0D)B,R1$/X-3BTTBU!4CA$./
XM-41S8MDH)D5C,-`K&PAF8A83$O\11%-F)D@7)"8C(T4W1$9C1N)M]C=$1#$T
XM4S%"<C*!=&-E13/0.1P(9F(6$1_^%P$1`1\_T].%$VIK5$4T5B-3$Q-C)E,V
XM1#9#1C1&,U,3$U,G1#5$6VIXCSWSWS`1$!'`,!T(9F(6$QG_&%T4TET?8Q,S
XM5!,S4R,SXE,CHS.N(SA3,Y^IHS\S0S/R-3,Q4]0;%3K`*AX(9F(6$QG_&#T_
XM'5%$0W5#;V0V9&XC<VXC>!XC<VXC9#=4,Q1$,_'5/3#0+A\(9F(6$2'^'+XC
XMTWM=,!$D1Q13%V,FXU,VXT-&XS-6\C9Q-4%E0@$3U;;B,!$<D!`A"&9B%@09
XM]Q@2'2$J@A@2$)`0#@AF8A8$&?</$A@2J"'2$A"P&R,(9F(6$QG_&&Y30TQ1
XMVN)30XXS0UVAQ4Y30V#`.R4(9F(6$R#_'".B-8,G<R=C,Q-C/B,34T]T-E0X
XM-3TN(]+STN(](],U-S56-'XD-3$_,V,3(W<CA4*3(.`4)PAF8A8'#?D8&'CX
XM\.'#CQQYYX8`T"(H"&9B%@LA^AR#=%5C=&1D<W1^(W1^8X2.(X2#A(2$@X6$
XM@]@B*0AF8A8+(?P<.$A8.$A(2#A(XCA.:#=.)S='-T9&1S951SC`'RH(9F(6
XM$1+^%7XS@S,S%2,E'22X]XM-(5(R43,S..,WH`XK"&9B%A$3_A5^<WV.=S?@
XM$BP(9F(6!POY!#CY^_/AQYY]\8#`#"X(9F(6!07X!!,=(3'0)2\(9F(6$2#^
XM'`$2\!`_T]\]\]\]\]\]\]\]\]\]\]\]\]\P$"`1L!`Z"&9B%@42^!$3'#$]
XMXQPQ,:`7.PAF8A8&&/D1(RXE(]@RXE)#,D(Q44,C@`\]"&9B%A$+_A$98:G<
XMJ1EAP#!`"&9B%A(9_AB%N7Q5134W-#@D.A,T*3-'-$?D,V8T2#-#(S0D)#A$
XM-E4T=61-%JIDN`Q;"&9B%@P@^!S;[-G8N`Q="&9B%@P@_QS8[-G;X!1@"&9B
XM%@<-^!L,///''CAPX>/CPP#8#1((9F(6"`7[&#549%4PX`T3"&9B%@@%^!@'
XM'W[XX,@.%`AF8A8-!?P6-Y'6-Y%@L`P5"&9B%@\$_1@2G5*RN`L6"&9B%@\#
XM_1;2'"#0#1<(9F(6!P7Y&!49.140P!(8"&9B%@L+^@)2@X1V9N*#'7)ST!%>
XM"&9B%@T&_!ABE6DF&E01D1#`$'X(9F(6#07\&#-"-AV!8R0SX`Y_"&9B%@L$
XM^QE@W!^#L&"H"2T(9F(6$0/^#=C`&0P(9F(6$1G^&'[2-S0T@C*Q,6.WF7M=
XM`](GP!D+"&9B%A$9_AB"T3T%MYE[-A,;(RA#0^TG-]`B/`AF8A81%?X6`1+4
XMMJ6EM:6UI::TUM4!!=4!!=4!!=;4`1+8(CX(9F(6$17^%B`136U0$%U0$%U0
XM$%UM2VI:6UI;6EIK32`1J`E?"&9B%A$#_O[8R"A<"&9B%A$@_APM+STO/2\]
XM+STO/2\]+STO/2\]+STO/2\]+STO/2\](G@)?`AF8A8#(/<<V-`=>PAF8A81
XM(/X<MIAZ=-Z#U(B/BH`00!#H,!!-J8M@V!U]"&9B%A$@_AQKB:U`$.@P$$`0
XMBOB(A-Z#U'IXEK#8$"((9F(6#0O\&#=^97]S$G(0T`X-"&9B%@4,^!DA,Q7H
XM$Q#8#"`(9F(6$1#^">TM`F#P#VED96YT:69I97(@0TU45/`@8V]D:6YG<V-H
XM96UE(%1E6"!T>7!E=W)I=&5R('1E>'3P#&9O;G1F86-E8GET9?0`Z@``]?;V
X!]FUE
X`
Xend
END_OF_FILE
  if test 6254 -ne `wc -c <'utils/fonts/cmtt10.pk.UU'`; then
    echo shar: \"'utils/fonts/cmtt10.pk.UU'\" unpacked with wrong size!
  fi
  # end of 'utils/fonts/cmtt10.pk.UU'
fi
if test -f 'utils/pk2ditwid.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/pk2ditwid.c'\"
else
  echo shar: Extracting \"'utils/pk2ditwid.c'\" \(5768 characters\)
  sed "s/^X//" >'utils/pk2ditwid.c' <<'END_OF_FILE'
X/*
X	Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991 Chris Lewis
X		All Rights Reserved
X
X    See the LICENSE file for a full description of restrictions under which
X    this software is provided.
X
X    Function:		Generates ditroff width tables from PK's
X */
X
X#ifndef	lint
Xstatic char SCCSID[] =
X    "@(#)pk2ditwid.c 2.3 Copyright 91/02/20 09:09:45 Chris Lewis";
X#endif
X
X#include "defs.h"
X#include "pk.h"
X
X/*	Dummied out for pk.c */
Xneedchar(a, b)
Xint a, b; {
X    return(1);
X}
X
Xextern struct cattab tabN[], tabS[];
Xextern struct enctab encNormal[], encSymbol[];
X
Xint silent = 0;
Xint symbol = 0;
Xint allflag = 0;
X
XFILE *fout = NULL;
Xchar *progname;
X
X#define	UNITWIDTH	10
X
Xmain(argc, argv)
Xint argc;
Xchar **argv; {
X    char buf[512];
X    extern int optind;
X    extern char *optarg;
X    int c;
X    register int i;
X    struct enctab *et;
X
X    progname = argv[0];
X    while((c = getopt(argc, argv, "AD:sS")) != EOF) {
X	switch(c) {
X	    case 's':
X		silent = 1;
X		break;
X	    case 'A':
X		allflag = 1;
X		silent = 1;	/* Doesn't use ditroff encoding anyways */
X		break;
X	    case 'S':
X		symbol = 1;
X		break;
X	    case 'D':
X#ifdef	DEBUG
X		setdebug(optarg, "pk2dw.diag");
X		break;
X#else
X		fprintf(stderr, "%s: DEBUG disabled - recompile\n",
X		    progname);
X		exit(1);
X#endif
X	    default:
X		fprintf(stderr, "usage: pk2sfp [-D<debugoptions>] [-sS] file\n");
X		exit(1);
X	}
X    }
X
X    if (!silent) {
X	if (!symbol) {
X	    for (i = 0; encNormal[i].e_name; i++) {
X		if (!encNormal[i].e_seq)
X		    printf("Can't use %s in Normal font\n",
X			encNormal[i].e_name);
X#ifdef	NEVER
X		else if (strlen(encNormal[i].e_seq) != 1)
X		    printf("Multi-char sequence (Normal fonts): %s\n",
X			encNormal[i].e_name);
X#endif
X	    }
X	} else {
X	    for (i = 0; encSymbol[i].e_name; i++) {
X		if (!encSymbol[i].e_seq)
X		    printf("Can't use %s in Symbol font\n",
X			encSymbol[i].e_name);
X#ifdef	NEVER
X		else if (strlen(encSymbol[i].e_seq) != 1)
X		    printf("Multi-char sequence (Symbol fonts): %s\n",
X			encSymbol[i].e_name);
X#endif
X	    }
X	}
X    }
X
X
X    for(;argv[optind];optind++) {
X	register struct pkp *pk;
X	register struct pkc *pc;
X	register char *p;
X
X	p = strrchr(argv[optind], '/');
X	if (p)
X	    strcpy(buf, p+1);
X	else
X	    strcpy(buf, argv[optind]);
X
X	if (p = strchr(buf, '.'))
X	    *p = '\0';
X	else
X	    strcat(buf, ".WID");
X
X	if (!(fout = fopen(buf, "w"))) {
X	    fprintf(stderr, "%s: cannot open %s\n", progname, buf);
X	    exit(1);
X	}
X
X	if (allflag) {
X	    fprintf(fout,
X		"Width: width of character at %d points at %dDPI\n",
X		UNITWIDTH, OUTRES);
X	    fprintf(fout,
X		"Kern: 2 for ascenders, 1 for descenders or'd together\n");
X	    fprintf(fout, "Code: Hexidecimal code\n");
X	    fprintf(fout, "Code\tWidth\tKern\n");
X	} else {
X	    fprintf(fout, "# %s\n", buf);
X	    fprintf(fout, "# Generated by pk2ditwid\n");
X	    fprintf(fout, "spacewidth 22\n");
X	    fprintf(fout, "charset\n");
X	}
X
X	/* Read the PK file in-core */
X	pk = pk_read(argv[optind]);
X	if (allflag) {
X	    for (pc = pk->pkp_chars; pc; pc = pc->pkc_next) {
X				/* get # pixels */
X		long widval = ((double) pc->pkc_dx / pow2(16)) *
X				/* normalize by actual resolution */
X			      ((double) OUTRES / pk->pkp_res) *
X				/* normalize to UNITWIDTH points */
X			      ((double) UNITWIDTH * pow2(20) / pk->pkp_ds) +
X				/* round ... */
X			      0.5;
X		int kern = ((pk->pkp_kh < pc->pkc_y_off) << 1) |
X			   (pk->pkp_kl - 2 > pc->pkc_y_off - pc->pkc_height);
X			   /* the "-2" is a fudge for teensy descenders */
X		fprintf(fout, "%02x\t%d\t%d\n", pc->pkc_char, widval, kern);
X	    }
X	    fclose(fout);
X	    pk_destroy(pk);
X	    continue;
X	}
X
X
X	/* Emit each character */
X	for (pc = pk->pkp_chars; pc; pc = pc->pkc_next) {
X	    if (pc->pkc_char <= 0x20)
X		continue;
X	    if (symbol)
X		et = encSymbol;
X	    else
X		et = encNormal;
X	    scanet(pk, pc, et);
X	}
X
X	for (et = (symbol ? encSymbol: encNormal); et->e_name; et++) {
X	    if (et->e_seq && !et->e_wid) {
X		if (!silent)
X		    printf("Didn't find width for %s\n", et->e_name);
X	    } else {
X		register char *pp;
X		fprintf(fout, "%s\t%ld\t%d\t",
X		    et->e_name, et->e_wid & 0x3f, (et->e_wid>>6)&0x3);
X		for (pp = et->e_seq; *pp; pp++)
X		    fprintf(fout, "\\%03o", (*pp)&0xff);
X		fprintf(fout, "\n");
X	    }
X	}
X
X	/* Clobber in-core PK */
X	pk_destroy(pk);
X	fclose(fout);
X
X    }
X    exit(0);
X}
X
Xscanet(p, pc, et)
Xregister struct pkp *p;
Xregister struct pkc *pc;
Xregister struct enctab *et; {
X    register char *pp;
X    int found = 0;
X    for (; et->e_name; et++) {
X	if (!et->e_seq)
X	    continue;
X	for (pp = et->e_seq; *pp; pp++) {
X	    if (((*pp)&0xff) == pc->pkc_char) {
X				/* get # pixels */
X		long widval = ((double) pc->pkc_dx / pow2(16)) *
X				/* normalize by actual resolution */
X			      ((double) OUTRES / p->pkp_res) *
X				/* normalize to UNITWIDTH points */
X			      ((double) UNITWIDTH * pow2(20) / p->pkp_ds) +
X				/* round ... */
X			      0.5;
X		int kern = ((p->pkp_kh < pc->pkc_y_off) << 1) |
X			   (p->pkp_kl - 2 > pc->pkc_y_off - pc->pkc_height);
X			   /* the "-2" is a fudge for teensy descenders */
X		found = 1;
X
X		/*printf("%s %s %03o\n", et->e_name, et->e_seq, pc->pkc_char);*/
X		if (et->e_wid) {	/* already seen */
X		    int oldwid, oldkern;
X		    oldwid = et->e_wid&0x3f;
X		    oldkern = (et->e_wid>>6)&3;
X		    kern |= oldkern;		/* this is correct */
X		    /* This can be fooled.... */
X		    if (*(pp+1) == 0x08 ||
X			(pp > et->e_seq && *(pp-1) == 0x08))
X			/* preceded or succeeded by BACKSPACE */
X			widval = max(widval, oldwid);
X		    else
X			widval += oldwid;
X		    if (widval > 0x3f) {	/* oh-oh! */
X			printf("Multi-sequence too wide! (%s)\n",
X			    et->e_name);
X			widval = 0x3f;
X		    }
X		}
X		et->e_wid = (widval | (kern << 6));
X	    }
X	}
X    }
X    if (!found && !silent)
X	printf("Character \\%03o in font not used by troff\n",
X	    pc->pkc_char);
X}
END_OF_FILE
  if test 5768 -ne `wc -c <'utils/pk2ditwid.c'`; then
    echo shar: \"'utils/pk2ditwid.c'\" unpacked with wrong size!
  fi
  # end of 'utils/pk2ditwid.c'
fi
if test -f 'utils/pktype.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/pktype.c'\"
else
  echo shar: Extracting \"'utils/pktype.c'\" \(5744 characters\)
  sed "s/^X//" >'utils/pktype.c' <<'END_OF_FILE'
X/*
X	Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991 Chris Lewis
X		All Rights Reserved
X
X    See the LICENSE file for a full description of restrictions under which
X    this software is provided.
X
X    Function:		prints header info from PK's and SFP's
X */
X
X#ifndef	lint
Xstatic char SCCSID[] =
X    "@(#)pk2sfp.c 2.3 Copyright 91/02/20 09:10:06 Chris Lewis";
X#endif
X#include "defs.h"
X#include "pk.h"
X
Xint firstchar = 0, lastchar = 0xff;
Xint verbose = 0;
Xchar *progname;
Xextern char *mustmalloc();
Xlong pks_malloc;
X
X/*	Dummied out for pk.c */
Xneedchar(a, b)
Xint a, b; {
X    return(1);
X}
X
Xmain(argc, argv)
Xint argc;
Xchar **argv; {
X    int c;
X    extern int optind, getopt();
X    extern char *optarg;
X    register struct pkp *p;
X    struct pkp *pk_read();
X
X    progname = argv[0];
X    while((c = getopt(argc, argv, "D:vf:l:")) != EOF)
X	switch(c) {
X	    case 'D':
X#ifdef	DEBUG
X		setdebug(optarg, "diagnostics");
X		break;
X#else
X		fprintf(stderr, "%s: debug not supported recompile with DEBUG\n",
X		    progname);
X		exit(1);
X#endif
X	    case 'v':
X		verbose = 1;
X		break;
X	    case 'f':
X		firstchar = *optarg;
X		break;
X	    case 'l':
X		lastchar = *optarg;
X		break;
X	    default:
X		fprintf(stderr, "Usage: %s [-f<ch>] [-l<ch>] pk_files\n", progname);
X		exit(1);
X	}
X#ifdef	DEBUG2
X    {
X	struct pkc p;
X	static int8 raster[] = {
X	    0xd9, 0xe2, 0x97, 0x2b, 0x1e, 0x22,
X	    0x93, 0x24, 0xe3, 0x97, 0x4e, 0x22,
X	    0x93, 0x2c, 0x5e, 0x22, 0x97, 0xd9};
X
X	struct ras *r;
X
X	p.pkc_flag = 0x88;
X	p.pkc_dyn_f = 8;
X	p.pkc_pl = 0x1a;
X	p.pkc_char = 4;
X	p.pkc_tfm = 0x09c61c;
X	p.pkc_dx = 0x19;
X	p.pkc_dy = 0;
X	p.pkc_x_off = 0xFE;
X	p.pkc_y_off = 0;
X	p.pkc_height = 0x1d;
X	p.pkc_width = 0x14;
X	p.pkc_pkr = raster;
X	p.pkc_rlen = sizeof(raster);
X	r = pkrast(&p);
X	dumpr(r, p.pkc_height);
X    }
X#endif
X    for (; optind < argc; optind++) {
X	char *filebuf = mustmalloc(strlen(argv[optind]) + 10);
X	register char *cp;
X
X	cp = strrchr(argv[optind], '/');
X
X	if (cp)
X	    strcpy(filebuf, cp+1);
X	else
X	    strcpy(filebuf, argv[optind]);
X
X	strcat(filebuf, ".D");
X
X	if (diagFile)
X	    fclose(diagFile);
X
X	if (!(diagFile = fopen(filebuf, "w"))) {
X	    fprintf(stderr, "%s: cannot open filebuf\n");
X	    exit(1);
X	}
X	p = pk_read(argv[optind]);
X	pk_dump(p, argv[optind]);
X	pk_destroy(p);
X	free(filebuf);
X    }
X    exit(0);
X}
X
Xpk_dump(p, file)
Xstruct pkp *p;
Xchar *file; {
X    struct pkc *pc;
X
X    fprintf(diagFile, "**********************************************\n");
X    fprintf(diagFile, "File %s:\n", file);
X    fprintf(diagFile, "  Font file type: %s\n",
X	p->pkp_flags&1 ? "PK" : "SFP");
X    fprintf(diagFile, "  Number of characters: %d\n", p->pkp_num);
X    fprintf(diagFile, "  Approximately %d bytes used\n", pks_malloc);
X    fprintf(diagFile, "  Design size: %ld, Native point size: %ld\n",
X	p->pkp_ds, p->pkp_ds / pow2(20));
X    fprintf(diagFile, "  Pointsize normalized to %d DPI: %ld\n",
X	OUTRES, p->pkp_npts);
X    fprintf(diagFile, "  Checksum: %ld\n", p->pkp_cs);
X    fprintf(diagFile, "  hppp: %ld, vppp: %ld\n", p->pkp_hppp, p->pkp_vppp);
X    fprintf(diagFile, "  hor. pixels/point: %f, ver. pixels/point: %f\n",
X	(double) p->pkp_hppp / pow2(16), (double) p->pkp_vppp / pow2(16));
X    fprintf(diagFile,
X	"  Hor. font resolution: %ld, Ver. font resolution: %ld\n",
X	p->pkp_res, (long) ((p->pkp_vppp * POINT / pow2(16)) + .5));
X    fprintf(diagFile,
X	"  Max y offset: %ld, Max descender: %ld, ", p->pkp_bmax, p->pkp_dmax);
X    fprintf(diagFile, "Max width: %ld, Max X offset: %ld\n",
X	p->pkp_wmax, p->pkp_xomax);
X    fprintf(diagFile,
X	"  Kern high: %ld, Kern low: %ld\n", p->pkp_kh, p->pkp_kl);
X    fprintf(diagFile,
X	"  SFP Info: symset: %d%c, style: %d, stroke: %d, typeface: %d\n",
X	(p->pkp_symset & 0x01e0) >> 5, (p->pkp_symset & 0x1f) + '@',
X	p->pkp_style, p->pkp_sw, p->pkp_typeface);
X
X    for (pc = p->pkp_chars; pc; pc = pc->pkc_next) {
X	register int i;
X	if (pc->pkc_char < firstchar || pc->pkc_char > lastchar)
X	    continue;
X	fprintf(diagFile, "\nCharacter: %lx (%c), (0%03o), Packet length: %d\n",
X	    pc->pkc_char, (char) (isprint(pc->pkc_char) ? pc->pkc_char : '?'),
X	    pc->pkc_char, pc->pkc_pl);
X	fprintf(diagFile, "  Flag byte: %d\n", pc->pkc_flag);
X	fprintf(diagFile, "  Dynamic packing variable: %d\n", pc->pkc_dyn_f);
X	fprintf(diagFile, "  TFM width: %d, dx: %d, delta x: %d", pc->pkc_tfm,
X	    pc->pkc_dx, pc->pkc_dx * 4 / pow2(16));
X	if (pc->pkc_dy)
X	    fprintf(diagFile, " dy: %d\n", pc->pkc_dy);
X	else
X	    putc('\n', diagFile);
X	fprintf(diagFile,
X	    "  Height: %d, Width: %d, X-offset: %d, Y-offset: %d\n",
X	    pc->pkc_height, pc->pkc_width, pc->pkc_x_off, pc->pkc_y_off);
X	if (pc->pkc_rlen) {
X	    fprintf(diagFile,
X		"  Raster length: %d, width in pixels: %ld\n", pc->pkc_rlen,
X		pc->pkc_dx / pow2(16));
X	    fprintf(diagFile, "  ");
X	    for (i = 0; i < 32; i++)
X		if (i >= pc->pkc_rlen)
X		    break;
X		else
X		    fprintf(diagFile, "%02x", 0xff & pc->pkc_pkr[i]);
X	    putc('\n', diagFile);
X	}
X
X	if (pc->pkc_sfpr)
X	    fprintf(diagFile, "  SFP length: %d\n", pc->pkc_sfpr->ras_bytes);
X	if (p->pkp_flags&PK_PK) {
X	    if (pc->pkc_dyn_f == 14)
X		fprintf(diagFile, "  Bit map character, ");
X	    else
X		fprintf(diagFile, "  Packed character, ");
X	    switch(pc->pkc_flag & 0x7) {
X		case 7:
X		    fprintf(diagFile, "Long form\n");
X		    break;
X		case 4: case 5: case 6:
X		    fprintf(diagFile, "Extended short form\n");
X		    break;
X		default:
X		    fprintf(diagFile, "Short form\n");
X	    }
X	}
X	if (verbose)
X	    rasterdump(pc);
X    }
X}
X
Xrasterdump(pc)
Xstruct pkc *pc; {
X    struct ras *r;
X    register int x, y;
X    extern struct ras *pkrast();
X    r = pkrast(pc);
X    if (r) {
X	fprintf(diagFile, "Character image:\n");
X	dumpr(r, r->ras_height);
X	free(r->ras_raster);
X	free(r);
X    } else
X	fprintf(diagFile, "NULL character image\n");
X}
END_OF_FILE
  if test 5744 -ne `wc -c <'utils/pktype.c'`; then
    echo shar: \"'utils/pktype.c'\" unpacked with wrong size!
  fi
  # end of 'utils/pktype.c'
fi
if test -f 'widths/gfnttab.S' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'widths/gfnttab.S'\"
else
  echo shar: Extracting \"'widths/gfnttab.S'\" \(3139 characters\)
  sed "s/^X//" >'widths/gfnttab.S' <<'END_OF_FILE'
X%%STARTSHELL%%
X#	Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991 Chris Lewis
X#		All Rights Reserved
X#
X#    See the LICENSE file for a full description of the restrictions
X#    under which this software is provided.
X#
X#@(#)gfnttab.sh 2.7 91/04/02
X#	Set this to something non-null in the Makefile if you need
X#	a.out.h/COFF headers on your width files, and the COFF/HEADERSIZE
X#	defines cause dit2catwid to generate width tables that
X#	troff screams about.
Xcompile=%%COMPILE%%
Xif [ "$1" = "-e" ]
Xthen
X    ext=-e
X    shift
Xfi
Xrc=1
Xdir=$1
Xinstall=$2
Xcurdir=`pwd`
Xfontdir=%%FONTDIR%%
Xtrap "echo GFNTTAB failed ; rm -f /tmp/S ; exit \$rc" 0 1 2 3 15
Xif [ -z "$dir" ]
Xthen
X    echo "Missing font directory argument"
X    exit
Xfi
Xecho "GFNTTAB: Processing font directory $dir"
Xif [ -n "$install" ]
Xthen
X    ffile=$curdir/$install.fonts.new
Xelse
X    ffile=`basename $dir | sed -e 's/^width\(.*\)$/\1/'`
X    ffile=$curdir/$ffile.fonts.new
Xfi
Xrm -f $ffile
Xif [ ! -d $dir ]
Xthen
X    echo "No $dir directory"
X    exit
Xfi
Xcd $dir
Xrm -f /tmp/S
Xif [ ! -r R ]
Xthen
X    echo "Creating Dummy R font width table"
X    touch R
Xfi
Xif [ -r S ]
Xthen
X    cp S /tmp/S
X    chmod 644 /tmp/S
X    for i in S1 S2 S3 S4 S5 S6 S7 S8 S9 ST SI
X    do
X	if [ -r $i ]
X	then
X	    sed -e '1,/charset/d' $i >> /tmp/S
X	fi
X    done
Xelse
X    echo "WARNING: no symbol font!"
X    > /tmp/S
Xfi
XDESC=DESC
Xif [ -r $DESC ]
Xthen
X    res=`sed -n -e 's/^[ 	]*res[ 	][ 	]*\([0-9][0-9]*\).*/\1/p' $DESC`
X    if [ -z "$res" ]
X    then
X	echo "WARNING: no 'res' command in DESC - assuming 300"
X	res="-r 300"
X    else
X	res="-r $res"
X    fi
X    unit=`sed -n -e 's/^[ 	]*unitwidth[ 	][ 	]*\([0-9][0-9]*\).*/\1/p' $DESC`
X    if [ -n "$unit" ]
X    then
X	res="$res -u $unit"
X    else
X	echo "WARNING: no 'unitwidth' command in DESC - assuming 10"
X	res="$res -u 10"
X    fi
Xelse
X    echo "WARNING: no DESC file in $dir - assuming 'res 300 unitwidth 10'"
X    res="-r 300 -u 10"
Xfi
Xecho "Using $res parameters"
Xfor i in [A-Z]*
Xdo
X    case $i in
X	??) ;;
X	?) ;;
X	*) continue ;;
X    esac
X    trc=0
X    case $i in
X	S[0-n] | ST | SI )
X	    ;;
X	*)
X	    Cline=`sed -e '1q' $i | sed -e 's/^#[ 	]*//'`
X	    echo "$i	$Cline" >> $ffile
X	    ;;
X    esac
X    case $i in
X	S)
X	    args="-s R /tmp/S"
X	    ;;
X	SU)
X	    args="-s R $i"
X	    ;;
X	S[0-9] | SI | ST )
X	    continue
X	    ;;
X	*)
X	    args="/tmp/S $i"
X	    ;;
X    esac
X    echo "GFNTTAB: processing font $i ($Cline)"
X    if [ -n "$compile" ]
X    then
X	$curdir/dit2catwid $ext $res -c $args ft${i}.c
X	if [ $? != 0 ]
X	then
X	    trc=1
X	else
X	    cc -c ft${i}.c
X	    trc=$?
X	    mv ft${i}.o ft${i}
X	fi
X    else
X	$curdir/dit2catwid $ext $res $args ft${i}
X	trc=$?
X    fi
X    chmod 644 ft${i} > /dev/null 2>&1
X    if [ $trc != 0 ]
X    then
X	rc=2
X    fi
Xdone
Xrm -f /tmp/S
Xif [ $rc -gt 1 ]
Xthen
X    exit
Xfi
Xif [ -s "$ffile" ]
Xthen
X    ed - $ffile <<\!
X0a
XDUM
XDUM
XDUM
XDUM
X.
Xg/^R	/m0
Xg/^I	/m1
Xg/^B	/m2
Xg/^S	/m3
X4a
XS2	BracketFont
X.
Xg/^DUM/d
Xw
Xq
X!
Xfi
Xif [ $? != 0 ]
Xthen
X    exit
Xfi
Xif [ -n "$install" ]
Xthen
X    if [ ! -d $fontdir/$install ]
X    then
X	mkdir $fontdir/$install
X    fi
X    mv ft* $fontdir/$install
X    if [ $? != 0 ]
X    then
X	exit
X    fi
Xfi
Xtrap '' 0
Xrc=0
Xexit 0
END_OF_FILE
  if test 3139 -ne `wc -c <'widths/gfnttab.S'`; then
    echo shar: \"'widths/gfnttab.S'\" unpacked with wrong size!
  fi
  # end of 'widths/gfnttab.S'
fi
echo shar: End of archive 14 \(of 19\).
cp /dev/null ark14isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 19 archives.
    echo "Read the README to get started with psroff installation"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
