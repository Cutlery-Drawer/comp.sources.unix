Subject:  v24i080:  SystemVr4/386 SLIP driver and utilities, Part03/04
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: b6968f4d c4954b41 b3910112 a385008b

Submitted-by: sudji@indo.intel.com (Sudji Husodo)
Posting-number: Volume 24, Issue 80
Archive-name: sysVr4386slip/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  dialslip/mkslipuser.c dialslip/slip.c dialslip/slip.h
#   man/man1/dslipuser.1 man/man1/mkslipuser.1 man/man1/slattach.1
#   man/man1/sldetach.1 man/man1/slip.1 man/man7/slip.7
#   utils/slattach.c utils/slhangupd.c
# Wrapped by rsalz@litchi.bbn.com on Fri Mar 22 11:57:12 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 3 (of 4)."'
if test -f 'dialslip/mkslipuser.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dialslip/mkslipuser.c'\"
else
  echo shar: Extracting \"'dialslip/mkslipuser.c'\" \(3115 characters\)
  sed "s/^X//" >'dialslip/mkslipuser.c' <<'END_OF_FILE'
X
X/*
X * mkslipuser.c
X *
X * Creates a blank user file based on a description of the network
X * configuration.  Initializes the dialup slip system.
X *
X * Copyright 1987 by University of California, Davis
X *
X * Greg Whitehead 10-1-87
X * Computing Services
X * University of California, Davis
X */
X
X/*
X * This program creates the dialup slip USER_FL based on information supplied
X * either on the command line or in a configuration file. The configuration
X * file consists of a number of one-line entries; one for each simultaneous
X * login that is allowed. The number of simultaneous logins must, of course,
X * be less than or equal to the number of interfaces available. Each one-line
X * entry contains an internet address (a.b.c.d or hostname format) for the
X * server side of the slip line. They may all be the same, or they may be
X * different, depending on how you prefer to administer your network. The
X * configuration file may also contain comments (lines starting with a #). In
X * the case where all of the server side addresses are the same, command line
X * arguments may be used instead of the configuration file. The first argument
X * is the number of simultaneous logins to allow, and the second argument is
X * the address of the server side of the point-point link.
X *
X * Modified by Geoff Arnold, Sun Microsystems 10-21-87:
X *
X * Allow a hostname instead of a dotted internet address.
X *
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include <sys/types.h>
X#include <sys/file.h>
X#include <string.h>
X#include <netinet/in.h>
X#include <netdb.h>
X#include <arpa/inet.h>
X#include "slip.h"
X
X#ifdef USG
X#  include <sys/fcntl.h>
X#endif
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X{
X    FILE *cfd;
X    char cline[80];
X    int ufd;
X    struct sl_urec urec;
X    int x;
X
X
X    /*
X     * Open CONFIG_FL if the neccessary arguments aren't available on the
X     * command line. If the file isn't there either then give usage.
X     *
X     */
X    if (argc<3 && (cfd=fopen(CONFIG_FL,"r"))==NULL) {
X	    fprintf(stderr,"usage: %s [count address]  (reads \"%s\" on default)",argv[0],CONFIG_FL);
X	    exit(1);
X	}
X
X
X    /*
X     * Open USER_FL.
X     *
X     */
X    if ((ufd=open(USER_FL,O_WRONLY|O_CREAT|O_TRUNC,0644))<0) {
X	perror(USER_FL);
X	exit(1);
X    }
X
X
X    /*
X     * create USER_FL.
X     *
X     */
X    urec.sl_uid = -1;
X
X    if (argc<3) {
X	while (fgets(cline,80,cfd)!=NULL)
X	    if (*cline!='#')
X		if (write_urec(ufd,urec,cline)<0) {
X		    fclose(cfd);
X		    exit(1);
X		}
X        fclose(cfd);
X    }
X
X    else {
X	for (x=0;x<atoi(argv[1]);x++) 
X	    if (write_urec(ufd,urec,argv[2])<0)
X		exit(1);
X    }
X
X    close(ufd);
X}
X
X
Xwrite_urec(ufd,urec,addr)
Xint ufd;
Xstruct sl_urec urec;
Xchar *addr;
X{
X    struct hostent *h;
X    char *c;
X
X    if (c = strchr(addr, '\n'))			/* zap the newline */
X	*c = '\0';
X
X    if ((h = gethostbyname(addr)) == NULL)
X	urec.sl_saddr.s_addr=inet_addr(addr);
X    else
X	urec.sl_saddr.s_addr = *((int *) h->h_addr); /* internet only */
X
X    if (write(ufd,&urec,sizeof(urec))!=sizeof(urec)){
X	fprintf(stderr,"%s: write failed\n",USER_FL);
X	close(ufd);
X	return(-1);
X        /* NOTREACHED */
X    }
X
X    return(0);
X}
END_OF_FILE
  if test 3115 -ne `wc -c <'dialslip/mkslipuser.c'`; then
    echo shar: \"'dialslip/mkslipuser.c'\" unpacked with wrong size!
  fi
  # end of 'dialslip/mkslipuser.c'
fi
if test -f 'dialslip/slip.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dialslip/slip.c'\"
else
  echo shar: Extracting \"'dialslip/slip.c'\" \(11967 characters\)
  sed "s/^X//" >'dialslip/slip.c' <<'END_OF_FILE'
X
X/*
X * slip.c
X *
X * Dialup slip line allocator.
X *
X * Copyright 1987 by University of California, Davis
X *
X * Greg Whitehead 10-1-87
X * Computing Services
X * University of California, Davis
X */
X
X/*
X * This program provides a means to obtain a slip line on a dialup tty.
X * It reads the file USER_FL to determine if an interface is available,
X * and to make sure that no internet address logs in more than once.
X * It updates the file with each login/disconnect in order to maintain
X * a record of which addresses are attached to which interfaces.
X *
X * In order to "ifconfig" and "slattach", slip must run setuid to root.
X *
X * Extensively modified by
X *
X *	Geoff Arnold
X *	Sun Microsystems Inc.
X *	10-28-87
X *
X * Modifications include:
X *
X * - allowing hostnames instead of dotted addresses (see also "mkslipuser")
X * - writing a line describing the configuration assigned by "sunslip"
X *   to stdout; a corresponding PC program can parse this and use the
X *   addressing information to check/update its local state
X * - for Sun systems, replacing the calls to slattach/ifconfig with the
X *   equivalent ioctls
X *
X * Lightly modified by:
X *    Sudji Husodo      2-8-91
X *
X * Modifications:
X *  - ported to Unix System V/386 Release 4.0. (actually done by Alan Batie).
X *  - modified to log slip activities to /var/slip/slip.log if the file exists.
X *  - changed the call to "system" to fork and exec, so we don't have to setuid
X *    slattach and ifconfig to root.
X */
X
X#ifdef sun
X#define YELLOW_PAGES	1 /* assumes SLIP server is a YP server too */
X#endif sun
X
X#include <stdio.h>
X#include <signal.h>
X#include <ctype.h>
X#include <sgtty.h>
X#include <time.h>
X#include <sys/types.h>
X#include <sys/file.h>
X#include <sys/socket.h>
X#include <net/if.h>
X#include <netdb.h>
X#include <sys/stat.h>
X#include <netinet/in.h>
X#include <arpa/inet.h>
X#include "slip.h"
X
X#ifdef USG
X#  include <unistd.h>
X#  include <sys/fcntl.h>
X#endif
X
Xchar *ttyname();
Xchar *getlogin();
X
Xvoid bye();			/* SIGHUP handler to remove USER_FL entry */
X
X
Xint ufd = -1;			/* global info on USER_FL entry */
Xstruct sl_urec urec;
Xint urec_i = -1;
X
Xchar *tty, *name;
X
X#ifdef sun
Xstruct ifreq ifr;
X#endif sun
X
Xchar string [128];
Xchar if_str [8];
Xchar source[32];
Xchar remote[32];
Xchar pidstr[16];
Xint  log = 1;
Xint  fd_log;
Xtime_t	clock_val;
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X{
X    int uid;
X
X    FILE *hfd;
X    char host_line[80], host_name[80], host_addr[80];
X    struct in_addr addr;
X    struct hostent *h, *hh;
X    struct sl_urec urec_tmp;
X    char sys_str[160];
X    struct sgttyb sgtty;
X    int disc = DISC;
X    int unit;
X    int x;
X#ifdef sun
X    int sockfd;
X#endif sun
X
X#ifdef sun
Xfprintf(stderr,"SUNSLIP\n");
X#endif sun
X
X    /*
X     * if we can not open nor append the log file, turn log off
X     */
X    if ((fd_log = open (LOG_FL, O_RDWR | O_APPEND)) < 0)
X	log = 0;
X    else {
X	clock_val = time(0);
X        sprintf (string, "%s started by %s at %s", argv[0], getlogin(), ctime(&clock_val));
X        write (fd_log, string, strlen(string));
X    }
X
X    /*
X     * Mask all signals except SIGSTOP, SIGKILL, and SIGHUP.
X     *
X     */
X     sigsetmask(~sigmask(SIGHUP));
X     signal(SIGHUP,SIG_DFL);
X
X
X    /*
X     * Must have a tty to attach to.
X     *
X     */
X    if ((tty=ttyname(0))==NULL) {
X	fail("Bad login port", NULL);
X	/* NOTREACHED */
X    }
X
X
X    /*
X     * Need uid to put in USER_FL.
X     * (checking it is paranoid, but complete)
X     *
X     */
X    if ((uid=getuid())<0) {
X	fail("Bad uid", NULL);
X	/* NOTREACHED */
X    }
X
X
X    /*
X     * Must have a login name to look up.
X     *
X     */
X    if ((name=getlogin())==NULL) {
X	fail("Bad login name", NULL);
X	/* NOTREACHED */
X    }
X
X    /*
X     * Open HOST_FL.
X     *
X     */
X    if ((hfd=fopen(HOST_FL,"r"))==NULL) {
X	fail("Can't open list of valid user-host mappings", NULL);
X	/* NOTREACHED */
X    }
X
X
X    /*
X     * look up login name in host file.
X     *
X     */
X    for (;;) {    
X	if (fgets(host_line,80,hfd)==NULL) {
X	    fail("User %s is not authorized to connect to SLIP", name);
X		/* NOTREACHED */
X	}
X        if (*host_line!='#' &&
X	    sscanf(host_line,"%s %s",host_addr,host_name)==2) {
X
X	    if (strncmp(name,host_name,8)==0) {
X		break;
X	    }
X	}
X    }
X    fclose(hfd);
X
X
X    /*
X     * Build internet addr from HOST_FL entry.
X     *
X     */
X    if((h = gethostbyname(host_addr)) != NULL)
X        addr.s_addr = *((int *)h->h_addr);
X    else if ((addr.s_addr=inet_addr(host_addr))<0) {
X	fail("Invalid address %s in hosts file", host_addr);
X	/* NOTREACHED */
X    }
X
X    /*
X     * Open USER_FL and get an exclusive lock on it.
X     *
X     */
X    if ((ufd=open(USER_FL,O_RDWR))<0) {
X	fail("Can't open SLIP user file", NULL);
X	/* NOTREACHED */
X    }
X#ifdef USG
X    /*  This is a blocking lock; don't waste time...  */
X    if (lockf(ufd,F_LOCK,0L)<0) {
X	close(ufd);
X	fail("Unable to lock SLIP user file", NULL);
X	/* NOTREACHED */
X    }
X#else
X    if (flock(ufd,LOCK_EX)<0) {
X	close(ufd);
X	fail("Unable to lock SLIP user file", NULL);
X	/* NOTREACHED */
X    }
X#endif
X
X
X    /*
X     * Make sure that this internet address isn't already logged in,
X     * and look for a free interface
X     *
X     */
X    for (x=0;read(ufd,&urec_tmp,sizeof(urec_tmp))==sizeof(urec_tmp);x++)
X	if (urec_tmp.sl_uid<0) {
X	    if (urec_i<0) {
X		urec_i=x;
X		bcopy(&urec_tmp,&urec,sizeof(urec));
X	    }
X	}
X	else if (urec_tmp.sl_haddr.s_addr==addr.s_addr) {
X	    unlock_fail("Host %s is already attached",inet_ntoa(addr));
X	/* NOTREACHED */
X	}
X
X
X    /*
X     * If there is a free interface then take it.
X     *
X     */
X    if (urec_i<0) {
X	unlock_fail("All lines are busy. Try again later.");
X	/* NOTREACHED */
X    }
X
X    h = gethostbyaddr(&addr, 4, AF_INET);
X    printf("Attaching %s (%s)", h->h_name, inet_ntoa(addr));
X    hh = gethostbyaddr(&urec.sl_saddr, 4, AF_INET);
X#ifdef YELLOW_PAGES
X    getdomainname(host_line, 79);
X    printf(" to domain %s via %s (%s)\n",
X        host_line, hh->h_name, inet_ntoa(urec.sl_saddr));
X#else
X    printf(" to network via %s (%s)\n",
X        hh->h_name, inet_ntoa(urec.sl_saddr));
X#endif
X
X    if (ioctl(0, TIOCGETP, &sgtty) < 0) {
X	perror("ioctl TIOCGETP");
X	unlock_close(1);
X    }
X    sgtty.sg_flags = RAW | ANYP;
X    if (ioctl(0, TIOCSETP, &sgtty) < 0) {
X	perror("ioctl TIOCSETP");
X	unlock_close(1);
X    }
X#ifndef USG
X    if (ioctl(0, TIOCSETD, &disc) < 0) {
X	perror("ioctl TIOCSETD");
X	unlock_close(1);
X    }
X#endif
X
X
X    /*
X     * Retreive the SL unit number.
X     *
X     */
X#ifndef sun
X#  ifdef USG
X    unit = urec_i;
X#  else
X    if (ioctl(0,TIOCGETU,&unit)<0) {
X	perror("ioctl TIOCGETU");
X	unlock_close(1);
X    }
X#  endif
X#else sun
X    if (ioctl(0,TIOCGETD,&unit)<0) {
X	perror("ioctl TIOCGETD");
X	unlock_close(1);
X    }
X#endif sun
X
X    /*
X     * Build and write USER_FL entry.
X     *
X     */
X    urec.sl_unit = unit;
X    urec.sl_haddr.s_addr = addr.s_addr;
X    urec.sl_uid = uid;
X    if (lseek(ufd,urec_i*sizeof(urec),L_SET)<0) {
X	sprintf(string,"%s: can't seek\n",USER_FL);
X	fprintf(stderr,string);
X	if (log)
X	    write (fd_log, string, strlen(string));
X	unlock_close(1);
X    }
X    signal(SIGHUP,bye);
X    if (write(ufd,&urec,sizeof(urec))!=sizeof(urec)) {
X	sprintf(string,"%s: can't write\n",USER_FL);
X	fprintf(stderr,string);
X	if (log)
X	    write (fd_log, string, strlen(string));
X	clean_user(1);
X    }
X
X    /*
X     * Through with critical code. Unlock USER_FL.
X     */
X#ifdef USG
X    lseek(ufd,0L,SEEK_SET);
X    if (lockf(ufd,F_ULOCK,0L)<0) {
X#else
X    if (flock(ufd,LOCK_UN)<0) {
X#endif
X	sprintf(string,"%s: unlock failed\n", USER_FL);
X	fprintf(stderr,string);
X	if (log)
X	    write (fd_log, string, strlen(string));
X	clean_user(1);
X    }
X
X#ifndef sun
X#  ifdef USG
X    /*
X     * slattach the line.
X     */
X    itoa (getpid(), pidstr);
X    sprintf(sys_str,"%s - %s%u %s", SLATTACH, IF_NAME, urec.sl_unit, pidstr);
X    sprintf(if_str,"%s%u", IF_NAME, urec.sl_unit);
X
X    if (log) {
X        sprintf (string, "   %s: executing %s\n", name, sys_str);
X        write (fd_log, string, strlen(string));
X    }
X
X    if (fork ())
X        /* wait for child to finish */
X        wait (0);
X    else {
X        /* execl doesn't return unless there's an error */
X        execl (SLATTACH, SLATTACH, "-", if_str, pidstr, 0);
X        printf("execl (%s): failed\n", sys_str);
X        clean_user(1);
X    }
X
X#  endif
X    /*
X     * ifconfig the slip line up.
X     */
X    sprintf(sys_str,"%s %s%u inet %s ",
X	IFCONFIG,IF_NAME,urec.sl_unit,inet_ntoa(urec.sl_saddr));
X    strcat(sys_str,inet_ntoa(urec.sl_haddr));
X    strcat(sys_str,IFARGS);
X
X    {
X	FILE *xyzzy;
X	xyzzy = fopen("/tmp/slip.log", "w");
X	fputs(sys_str, xyzzy);
X	fputc('\n', xyzzy);
X	fclose(xyzzy);
X    }
X
X    if (log) {
X	sprintf (string, "   %s: executing %s\n", name, sys_str);
X	write (fd_log, string, strlen(string));
X    }
X
X    if (fork ())
X        /* wait for child to finish */
X        wait (0);
X    else {
X        /* execl doesn't return unless there's an error */
X        strcpy(source,inet_ntoa(urec.sl_saddr));
X        strcpy(remote,inet_ntoa(urec.sl_haddr));
X        execl (IFCONFIG, IFCONFIG, if_str, "inet", source, remote, "up", 0);
X        printf ("execl (%s): failed\n", sys_str);
X        clean_user(1);
X    }
X#else sun
X    /*
X     * Now instead of calling ifconfig (which in the Sun 3
X     * version doesn't grok all of the 4.3BSD weirdness) we
X     * revert to the old SIOCIFDSTADDR/SIOCSIFADDR stuff
X     */
X    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
X    if(sockfd < 0) {
X        perror("sunslip: socket");
X        clean_user(1);
X    }
X    sprintf(ifr.ifr_name, "sl%d", unit);
X    fprintf(stderr, "sl%d\n", unit);
X    getaddr(&urec.sl_haddr, (struct sockaddr_in *)&ifr.ifr_dstaddr);
X    if(ioctl(sockfd, SIOCSIFDSTADDR, (caddr_t)&ifr) < 0) {
X        perror("ioctl SIOCSIFDSTADDR");
X        clean_user(1);
X    }
X    getaddr(&urec.sl_saddr, (struct sockaddr_in *)&ifr.ifr_addr);
X    if(ioctl(sockfd, SIOCSIFADDR, (caddr_t)&ifr) < 0) {
X        perror("ioctl SIOCSIFADDR");
X        clean_user(1);
X    }
X#endif sun
X
X    if (log) {
X	sprintf (string, "   %s: waiting for hangup\n",name);
X	write (fd_log, string, strlen(string));
X    }
X
X    /*
X     * Wait until carrier drops.
X     * clean_usr() will be called.
X     *
X     */
X
X    for(;;) {
X        printf("pause returns %d\n", pause());
X    }
X}
X
X
Xunlock_close(status)
Xint status;
X{
X    /*
X     * Unlock and close USER_FL, and exit with "status".
X     *
X     */ 
X
X#ifdef USG
X    lseek(ufd,0L,SEEK_SET);
X    lockf(ufd,F_ULOCK,0L);
X#else
X    flock(ufd,LOCK_UN);
X#endif
X    close(ufd);
X    exit(status);
X}
X
X
Xunlock_fail(s1, s2)
Xchar *s1;
Xchar *s2;
X{
X    /*
X     * Unlock and close USER_FL, and fail
X     *
X     */ 
X
X#ifdef USG
X    lseek(ufd,0L,SEEK_SET);
X    lockf(ufd,F_ULOCK,0L);
X#else
X    flock(ufd,LOCK_UN);
X#endif
X    close(ufd);
X    fail(s1, s2);
X}
X
X
Xfail(s1, s2)
Xchar *s1;
Xchar *s2;
X{
X	fputs("\nConnection failure: ", stderr);
X	fprintf(stderr, s1, s2);
X	fputs("\n\n", stderr);
X
X	if (log) {
X	    sprintf (string,"Connection failure: %s %s\n", s1, s2);
X	    write (fd_log, string, strlen(string));
X	}
X
X	exit(1);
X}
X
X
Xclean_user(status)
Xint status;
X{
X    /*
X     * mark line free in USER_FL, unlock and close USER_FL, and
X     * exit with "status".
X     *
X     */ 
X
X    urec.sl_uid = -1;
X    if (lseek(ufd,urec_i*sizeof(urec),L_SET)<0 || write(ufd,&urec,sizeof(urec))!=sizeof(urec))
X	status = -1;
X    unlock_close(status);
X}
X
X
Xvoid bye(int sig)
X{
X    /*
X     * Handle SIGHUP.
X     * Mark line free in USER_FL and exit with status 0.
X     *
X     */
X
Xprintf("signal %d\n", sig);
X
X    if (log) {
X        clock_val = time(0);
X        sprintf (string, "   %s: caught signal %d, exiting ... %s", name, sig, ctime (&clock_val));
X	write (fd_log, string, strlen(string));
X    }
X    clean_user(0);
X}
X
X
X#ifdef sun
Xgetaddr(s, sin)
Xstruct in_addr *s;
Xstruct sockaddr_in *sin;
X{
X	sin->sin_family = AF_INET;
X	sin->sin_addr = *s;
X}
X#endif sun
X
X
X
Xitoa (int n, char s[])
X{
X	int i, j;
X	int c = 0;
X
X	do {
X		s[c++] = n % 10 + '0';
X	} while ((n/=10) > 0);
X	s[c] = '\0';
X
X	for (i=0, j=c-1; i<j; i++, j--) {
X		c = s[i];
X		s[i] = s[j];
X		s[j] = c;
X	}
X}
END_OF_FILE
  if test 11967 -ne `wc -c <'dialslip/slip.c'`; then
    echo shar: \"'dialslip/slip.c'\" unpacked with wrong size!
  fi
  # end of 'dialslip/slip.c'
fi
if test -f 'dialslip/slip.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dialslip/slip.h'\"
else
  echo shar: Extracting \"'dialslip/slip.h'\" \(763 characters\)
  sed "s/^X//" >'dialslip/slip.h' <<'END_OF_FILE'
X/*
X * slip.h
X *
X * Definitions for the dialup slip system.
X *
X * Copyright 1987 by University of California, Davis
X *
X * Greg Whitehead 10-1-87
X * Computing Services
X * University of California, Davis
X */
X
X#define USER_FL		"/etc/slip.user"
X#define HOST_FL		"/etc/slip.hosts"
X#define CONFIG_FL	"/etc/slip.config"
X#define LOG_FL		"/var/slip/slip.log"
X
X#define SLATTACH	"/usr/sbin/slattach"
X#define IFCONFIG	"/usr/sbin/ifconfig"
X#define IFARGS		" up"
X
X#define DISC		SLIPDISC
X#define IF_NAME		"sl"
X
X
Xstruct sl_urec {
X    int sl_uid;			/* uid of logged in host (-1 if free) */
X    int sl_unit;		/* unit number for this login */
X    struct in_addr sl_haddr;	/* internet address of logged in host */
X    struct in_addr sl_saddr;	/* internet address of server side */
X};
END_OF_FILE
  if test 763 -ne `wc -c <'dialslip/slip.h'`; then
    echo shar: \"'dialslip/slip.h'\" unpacked with wrong size!
  fi
  # end of 'dialslip/slip.h'
fi
if test -f 'man/man1/dslipuser.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/man1/dslipuser.1'\"
else
  echo shar: Extracting \"'man/man1/dslipuser.1'\" \(3069 characters\)
  sed "s/^X//" >'man/man1/dslipuser.1' <<'END_OF_FILE'
X.TH slip 1 "TCP/IP"
X.SH NAME
Xslip, mkslipuser, dslipuser \- dialup SLIP utilities
X.SH SYNOPSIS
X.nf
X\fB/usr/sbin/slip\fP
X\fB/usr/sbin/mkslipuser\fP [ #_of_logins  host_address ]
X\fB/usr/sbin/dslipuser\fP
X.fi
X.SH DESCRIPTION
X.PP
XThe \fBslip\fP program sets up a SLIP protocol over a dialup line.
XThe SLIP protocol is obtained by logging into a host and executing
Xthe \fBslip\fP program.
XBecause \fBslip\fP must execute \fIslattach\fP and \fIifconfig\fP, it must run
Xsetuid to root. 
X.PP
XSlip uses two files to control access; a host table (\fI/etc/slip.hosts\fP)
Xthat maps login IDs to internet addresses, and a user file
X(\fI/etc/slip.user\fP) that keeps track of users logged in over \fBslip\fP.
XThe host table file must be created by hand and has the following format:
X.PP
X.nf
X.CW
X#  Lines starting with "#" are ignored.
X#  The first field is the IP address to be assigned the remote host that
X#  is logging in.  The second field is the login ID which is used to find
X#  the appropriate IP address.
X#
X# <IP address> <login ID>
X192.9.2.1       rkl
X192.9.2.2       sjg
X.fi
X.fP
X.PP
XIf the file \fI/var/slip/slip.log\fP exists, \fBslip\fP will append log entries
Xthat show when users invoked \fBslip\fP and when they disconnected.
X.PP
XThe \fBmkslipuser\fP program is used to create a blank user file.
XYou may want to envoke \fBmkslipuser\fP from the \fI/etc/init.d/inetinit\fP
Xrc file to insure a sane system after reboot.
X\fBMkslipuser\fP uses information supplied either on the command line or from
Xthe configuration file \fI/etc/slip.config\fP.
XThe configuration file consists of a number of one-line entries; one for each
Xsimultaneous login that is allowed.
XThe number of simultaneous logins must, of course, be less than or equal to
Xthe number of SLIP interfaces available.
XEach entry contains an internet address (specified by hostname or dot notation
Xformat) for the server side of a SLIP line.
XThe entries may all be the same or unique depending on how you prefer to
Xadminister your network.
XThe configuration file may also contain comments which are lines starting with
Xa "#".
XHere is an example:
X.PP
X.nf
X.CW
X#  Lines that start with "#" are ignored.
X#  This example allows 4 simultaneous SLIP logins all using the same server
X#  side IP address.
X#
X#  <address of server side of point to point link>
Xaslan.acme.com
Xaslan.acme.com
Xaslan.acme.com
Xaslan.acme.com
X.fi
X.fP
X.PP
XIn the case where all of the server side addresses are the same, command line
Xarguments may be used instead of a configuration file. The first argument
Xis the number of simultaneous logins to allow, and the second argument is
Xthe address of the server side of the point-point link.
X.PP
XThe \fBdslipuser\fP program displays the contents of the user file which
Xidentifies who is logged in and what internet addresses they are using.
X.SH SEE ALSO
X.nf
Xifconfig(1M), slattach(1M), slhangupd(1M), slip(7)
X.fi
X.SH FILES
X.nf
X/etc/slip.hosts
X/etc/slip.user
X/etc/slip.config
X/var/slip/slip.log
X.fi
X.SH ORIGINAL AUTHOR
X.nf
XGreg Whitehead 10-02-87
XComputing Services
XUniversity of California, Davis
X.fi
END_OF_FILE
  if test 3069 -ne `wc -c <'man/man1/dslipuser.1'`; then
    echo shar: \"'man/man1/dslipuser.1'\" unpacked with wrong size!
  fi
  # end of 'man/man1/dslipuser.1'
fi
if test -f 'man/man1/mkslipuser.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/man1/mkslipuser.1'\"
else
  echo shar: Extracting \"'man/man1/mkslipuser.1'\" \(3069 characters\)
  sed "s/^X//" >'man/man1/mkslipuser.1' <<'END_OF_FILE'
X.TH slip 1 "TCP/IP"
X.SH NAME
Xslip, mkslipuser, dslipuser \- dialup SLIP utilities
X.SH SYNOPSIS
X.nf
X\fB/usr/sbin/slip\fP
X\fB/usr/sbin/mkslipuser\fP [ #_of_logins  host_address ]
X\fB/usr/sbin/dslipuser\fP
X.fi
X.SH DESCRIPTION
X.PP
XThe \fBslip\fP program sets up a SLIP protocol over a dialup line.
XThe SLIP protocol is obtained by logging into a host and executing
Xthe \fBslip\fP program.
XBecause \fBslip\fP must execute \fIslattach\fP and \fIifconfig\fP, it must run
Xsetuid to root. 
X.PP
XSlip uses two files to control access; a host table (\fI/etc/slip.hosts\fP)
Xthat maps login IDs to internet addresses, and a user file
X(\fI/etc/slip.user\fP) that keeps track of users logged in over \fBslip\fP.
XThe host table file must be created by hand and has the following format:
X.PP
X.nf
X.CW
X#  Lines starting with "#" are ignored.
X#  The first field is the IP address to be assigned the remote host that
X#  is logging in.  The second field is the login ID which is used to find
X#  the appropriate IP address.
X#
X# <IP address> <login ID>
X192.9.2.1       rkl
X192.9.2.2       sjg
X.fi
X.fP
X.PP
XIf the file \fI/var/slip/slip.log\fP exists, \fBslip\fP will append log entries
Xthat show when users invoked \fBslip\fP and when they disconnected.
X.PP
XThe \fBmkslipuser\fP program is used to create a blank user file.
XYou may want to envoke \fBmkslipuser\fP from the \fI/etc/init.d/inetinit\fP
Xrc file to insure a sane system after reboot.
X\fBMkslipuser\fP uses information supplied either on the command line or from
Xthe configuration file \fI/etc/slip.config\fP.
XThe configuration file consists of a number of one-line entries; one for each
Xsimultaneous login that is allowed.
XThe number of simultaneous logins must, of course, be less than or equal to
Xthe number of SLIP interfaces available.
XEach entry contains an internet address (specified by hostname or dot notation
Xformat) for the server side of a SLIP line.
XThe entries may all be the same or unique depending on how you prefer to
Xadminister your network.
XThe configuration file may also contain comments which are lines starting with
Xa "#".
XHere is an example:
X.PP
X.nf
X.CW
X#  Lines that start with "#" are ignored.
X#  This example allows 4 simultaneous SLIP logins all using the same server
X#  side IP address.
X#
X#  <address of server side of point to point link>
Xaslan.acme.com
Xaslan.acme.com
Xaslan.acme.com
Xaslan.acme.com
X.fi
X.fP
X.PP
XIn the case where all of the server side addresses are the same, command line
Xarguments may be used instead of a configuration file. The first argument
Xis the number of simultaneous logins to allow, and the second argument is
Xthe address of the server side of the point-point link.
X.PP
XThe \fBdslipuser\fP program displays the contents of the user file which
Xidentifies who is logged in and what internet addresses they are using.
X.SH SEE ALSO
X.nf
Xifconfig(1M), slattach(1M), slhangupd(1M), slip(7)
X.fi
X.SH FILES
X.nf
X/etc/slip.hosts
X/etc/slip.user
X/etc/slip.config
X/var/slip/slip.log
X.fi
X.SH ORIGINAL AUTHOR
X.nf
XGreg Whitehead 10-02-87
XComputing Services
XUniversity of California, Davis
X.fi
END_OF_FILE
  if test 3069 -ne `wc -c <'man/man1/mkslipuser.1'`; then
    echo shar: \"'man/man1/mkslipuser.1'\" unpacked with wrong size!
  fi
  # end of 'man/man1/mkslipuser.1'
fi
if test -f 'man/man1/slattach.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/man1/slattach.1'\"
else
  echo shar: Extracting \"'man/man1/slattach.1'\" \(3089 characters\)
  sed "s/^X//" >'man/man1/slattach.1' <<'END_OF_FILE'
X.\"
X.\"             Copyright 1991, Intel Corporation
X.\"                   All rights reserved.
X.\"
X.\" Permission to use, copy, modify, and distribute this software and
X.\" its documentation for any purpose and without fee is hereby granted,
X.\" provided that the above copyright notice appear in all copies and
X.\" that both the copyright notice appear in all copies and that both
X.\" the copyright notice and this permission notice appear in
X.\" supporting documentation, and that the name of Intel Corporation
X.\" not be used in advertising or publicity pertaining to distribution
X.\" of the software without specific, written prior permission.
X.\" 
X.\" COMPANY AND/OR INTEL DISCLAIM ALL WARRANTIES WITH REGARD TO
X.\" THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
X.\" MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO
X.\" EVENT SHALL COMPANY NOR INTEL BE LIABLE FOR ANY SPECIAL,
X.\" INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X.\" RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
X.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTUOUS ACTION,
X.\" ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
X.\" OF THIS SOFTWARE.
X.\" 
X.TH slattach 1M "TCP/IP"
X.SH NAME
Xslattach, sldetach \- assigns and removes serial lines as a SLIP interface
X.SH SYNOPSIS
X.nf
X\fB/usr/sbin/slattach\fP [\fB-i\fP] node_name interface_name
X\fB/usr/sbin/slattach -d\fP [\fB-i\fP] device_name interface_name [ baudrate ]
X\fB/usr/sbin/slattach -\fP interface_name [ process_id ]
X
X\fB/usr/sbin/sldetach\fP interface_name
X.fi
X.SH DESCRIPTION
X.PP
X\fBSlattach\fP is used to assign a serial line as a network interface
Xusing the \fISLIP\fP (Serial Link Internet Protocol) driver.
X.PP
XWhen invoked with \fInode_name\fP and \fIinterface_name\fP, \fBslattach\fP
Xuses BNU (Basic Networking Utilities) to establish an outgoing serial line
Xconnection.
XRefer to the \fIAdvanced System Administration Guide\fP for complete
Xinformation on set up and administration of BNU.
X.PP
XThe \fB-i\fP option causes \fBslattach\fP to ignore SIGHUP.
XBy default \fBslattach\fP exits gracefully whenever a SIGHUP is caught and
Xprocessed by the \fIslhangupd\fP daemon.
X.PP
XThe \fB-d\fP option causes \fBslattach\fP to directly open the specified
X\fIdevice_name\fP without the use of BNU.
XIn this case the \fIbaudrate\fP parameter is used to set the speed of the
Xconnection.
XThe default baudrate is 9600.
X.PP
XThe \fB-\fP option causes stdin to be used as the device to be attached to the
X\fISLIP\fP driver.
XThis option is used to convert a remote login line to a SLIP connection.
XIn this case, SIGHUP can not be ignored.
XThe optional argument \fIprocess_id\fP, if specified, causes \fBslattach\fP to
Xsend a SIGHUP to the specified process ID when it receives the SIGHUP signal.
X.PP
X\fBSldetach\fP is used to decommission a serial line that was used for a SLIP
Xconnection.
X.SH EXAMPLES
X.nf
Xslattach venus sl0
Xslattach -d -i /dev/tty00 sl0 19200
X
Xsldetach sl0
X.fi
X.SH SEE ALSO
X.nf
Xslhangupd(1M), slip(1), asy(7), ip(7), slip(7)
X\fIAdvanced System Administration Guide\fP.
X.fi
X.SH AUTHOR
XSudji Husodo
END_OF_FILE
  if test 3089 -ne `wc -c <'man/man1/slattach.1'`; then
    echo shar: \"'man/man1/slattach.1'\" unpacked with wrong size!
  fi
  # end of 'man/man1/slattach.1'
fi
if test -f 'man/man1/sldetach.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/man1/sldetach.1'\"
else
  echo shar: Extracting \"'man/man1/sldetach.1'\" \(3089 characters\)
  sed "s/^X//" >'man/man1/sldetach.1' <<'END_OF_FILE'
X.\"
X.\"             Copyright 1991, Intel Corporation
X.\"                   All rights reserved.
X.\"
X.\" Permission to use, copy, modify, and distribute this software and
X.\" its documentation for any purpose and without fee is hereby granted,
X.\" provided that the above copyright notice appear in all copies and
X.\" that both the copyright notice appear in all copies and that both
X.\" the copyright notice and this permission notice appear in
X.\" supporting documentation, and that the name of Intel Corporation
X.\" not be used in advertising or publicity pertaining to distribution
X.\" of the software without specific, written prior permission.
X.\" 
X.\" COMPANY AND/OR INTEL DISCLAIM ALL WARRANTIES WITH REGARD TO
X.\" THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
X.\" MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO
X.\" EVENT SHALL COMPANY NOR INTEL BE LIABLE FOR ANY SPECIAL,
X.\" INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X.\" RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
X.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTUOUS ACTION,
X.\" ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
X.\" OF THIS SOFTWARE.
X.\" 
X.TH slattach 1M "TCP/IP"
X.SH NAME
Xslattach, sldetach \- assigns and removes serial lines as a SLIP interface
X.SH SYNOPSIS
X.nf
X\fB/usr/sbin/slattach\fP [\fB-i\fP] node_name interface_name
X\fB/usr/sbin/slattach -d\fP [\fB-i\fP] device_name interface_name [ baudrate ]
X\fB/usr/sbin/slattach -\fP interface_name [ process_id ]
X
X\fB/usr/sbin/sldetach\fP interface_name
X.fi
X.SH DESCRIPTION
X.PP
X\fBSlattach\fP is used to assign a serial line as a network interface
Xusing the \fISLIP\fP (Serial Link Internet Protocol) driver.
X.PP
XWhen invoked with \fInode_name\fP and \fIinterface_name\fP, \fBslattach\fP
Xuses BNU (Basic Networking Utilities) to establish an outgoing serial line
Xconnection.
XRefer to the \fIAdvanced System Administration Guide\fP for complete
Xinformation on set up and administration of BNU.
X.PP
XThe \fB-i\fP option causes \fBslattach\fP to ignore SIGHUP.
XBy default \fBslattach\fP exits gracefully whenever a SIGHUP is caught and
Xprocessed by the \fIslhangupd\fP daemon.
X.PP
XThe \fB-d\fP option causes \fBslattach\fP to directly open the specified
X\fIdevice_name\fP without the use of BNU.
XIn this case the \fIbaudrate\fP parameter is used to set the speed of the
Xconnection.
XThe default baudrate is 9600.
X.PP
XThe \fB-\fP option causes stdin to be used as the device to be attached to the
X\fISLIP\fP driver.
XThis option is used to convert a remote login line to a SLIP connection.
XIn this case, SIGHUP can not be ignored.
XThe optional argument \fIprocess_id\fP, if specified, causes \fBslattach\fP to
Xsend a SIGHUP to the specified process ID when it receives the SIGHUP signal.
X.PP
X\fBSldetach\fP is used to decommission a serial line that was used for a SLIP
Xconnection.
X.SH EXAMPLES
X.nf
Xslattach venus sl0
Xslattach -d -i /dev/tty00 sl0 19200
X
Xsldetach sl0
X.fi
X.SH SEE ALSO
X.nf
Xslhangupd(1M), slip(1), asy(7), ip(7), slip(7)
X\fIAdvanced System Administration Guide\fP.
X.fi
X.SH AUTHOR
XSudji Husodo
END_OF_FILE
  if test 3089 -ne `wc -c <'man/man1/sldetach.1'`; then
    echo shar: \"'man/man1/sldetach.1'\" unpacked with wrong size!
  fi
  # end of 'man/man1/sldetach.1'
fi
if test -f 'man/man1/slip.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/man1/slip.1'\"
else
  echo shar: Extracting \"'man/man1/slip.1'\" \(3069 characters\)
  sed "s/^X//" >'man/man1/slip.1' <<'END_OF_FILE'
X.TH slip 1 "TCP/IP"
X.SH NAME
Xslip, mkslipuser, dslipuser \- dialup SLIP utilities
X.SH SYNOPSIS
X.nf
X\fB/usr/sbin/slip\fP
X\fB/usr/sbin/mkslipuser\fP [ #_of_logins  host_address ]
X\fB/usr/sbin/dslipuser\fP
X.fi
X.SH DESCRIPTION
X.PP
XThe \fBslip\fP program sets up a SLIP protocol over a dialup line.
XThe SLIP protocol is obtained by logging into a host and executing
Xthe \fBslip\fP program.
XBecause \fBslip\fP must execute \fIslattach\fP and \fIifconfig\fP, it must run
Xsetuid to root. 
X.PP
XSlip uses two files to control access; a host table (\fI/etc/slip.hosts\fP)
Xthat maps login IDs to internet addresses, and a user file
X(\fI/etc/slip.user\fP) that keeps track of users logged in over \fBslip\fP.
XThe host table file must be created by hand and has the following format:
X.PP
X.nf
X.CW
X#  Lines starting with "#" are ignored.
X#  The first field is the IP address to be assigned the remote host that
X#  is logging in.  The second field is the login ID which is used to find
X#  the appropriate IP address.
X#
X# <IP address> <login ID>
X192.9.2.1       rkl
X192.9.2.2       sjg
X.fi
X.fP
X.PP
XIf the file \fI/var/slip/slip.log\fP exists, \fBslip\fP will append log entries
Xthat show when users invoked \fBslip\fP and when they disconnected.
X.PP
XThe \fBmkslipuser\fP program is used to create a blank user file.
XYou may want to envoke \fBmkslipuser\fP from the \fI/etc/init.d/inetinit\fP
Xrc file to insure a sane system after reboot.
X\fBMkslipuser\fP uses information supplied either on the command line or from
Xthe configuration file \fI/etc/slip.config\fP.
XThe configuration file consists of a number of one-line entries; one for each
Xsimultaneous login that is allowed.
XThe number of simultaneous logins must, of course, be less than or equal to
Xthe number of SLIP interfaces available.
XEach entry contains an internet address (specified by hostname or dot notation
Xformat) for the server side of a SLIP line.
XThe entries may all be the same or unique depending on how you prefer to
Xadminister your network.
XThe configuration file may also contain comments which are lines starting with
Xa "#".
XHere is an example:
X.PP
X.nf
X.CW
X#  Lines that start with "#" are ignored.
X#  This example allows 4 simultaneous SLIP logins all using the same server
X#  side IP address.
X#
X#  <address of server side of point to point link>
Xaslan.acme.com
Xaslan.acme.com
Xaslan.acme.com
Xaslan.acme.com
X.fi
X.fP
X.PP
XIn the case where all of the server side addresses are the same, command line
Xarguments may be used instead of a configuration file. The first argument
Xis the number of simultaneous logins to allow, and the second argument is
Xthe address of the server side of the point-point link.
X.PP
XThe \fBdslipuser\fP program displays the contents of the user file which
Xidentifies who is logged in and what internet addresses they are using.
X.SH SEE ALSO
X.nf
Xifconfig(1M), slattach(1M), slhangupd(1M), slip(7)
X.fi
X.SH FILES
X.nf
X/etc/slip.hosts
X/etc/slip.user
X/etc/slip.config
X/var/slip/slip.log
X.fi
X.SH ORIGINAL AUTHOR
X.nf
XGreg Whitehead 10-02-87
XComputing Services
XUniversity of California, Davis
X.fi
END_OF_FILE
  if test 3069 -ne `wc -c <'man/man1/slip.1'`; then
    echo shar: \"'man/man1/slip.1'\" unpacked with wrong size!
  fi
  # end of 'man/man1/slip.1'
fi
if test -f 'man/man7/slip.7' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/man7/slip.7'\"
else
  echo shar: Extracting \"'man/man7/slip.7'\" \(3431 characters\)
  sed "s/^X//" >'man/man7/slip.7' <<'END_OF_FILE'
X.\"
X.\"             Copyright 1991, Intel Corporation
X.\"                   All rights reserved.
X.\"
X.\" Permission to use, copy, modify, and distribute this software and
X.\" its documentation for any purpose and without fee is hereby granted,
X.\" provided that the above copyright notice appear in all copies and
X.\" that both the copyright notice appear in all copies and that both
X.\" the copyright notice and this permission notice appear in
X.\" supporting documentation, and that the name of Intel Corporation
X.\" not be used in advertising or publicity pertaining to distribution
X.\" of the software without specific, written prior permission.
X.\" 
X.\" COMPANY AND/OR INTEL DISCLAIM ALL WARRANTIES WITH REGARD TO
X.\" THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
X.\" MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO
X.\" EVENT SHALL COMPANY NOR INTEL BE LIABLE FOR ANY SPECIAL,
X.\" INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X.\" RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
X.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
X.\" ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
X.\" OF THIS SOFTWARE.
X.\" 
X.TH SLIP 7  "Network Drivers"
X.SH NAME
XSLIP \- Serial Link Internet Protocol
X.SH SYNOPSIS
X.nf
X.ft B
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/stream.h>
X#include <net/if.h>
X#include <sys/slip.h>
X
Xs = open ("/dev/slip", O_RDWR);
X.ft R
X.fi
X.SH DESCRIPTION
X.PP
X\fBSLIP\fP is a multiplexing STREAMS driver that implements the
Xpacket framing protocol specified in RFC1055.
X.PP
XThe \fBSLIP\fP driver is usually linked below the \fIip\fP driver and above the
X\fIasy\fP (serial) driver.
XThe \fIslattach\fP command constructs the required \fIip\fP to \fBSLIP\fP to
X\fIasy\fP STREAMS stack so that serial lines can be used as a network interfaces.
X.PP
XMultiple serial devices can be linked below the \fBSLIP\fP driver.
XThe maximum number of serial devices the \fBSLIP\fP driver can have is
Xcontrolled by the configuration parameter \fBSLIP_NUM\fP in the file
X\fI/etc/conf/pack.d/slip/space.c\fP.
XNote that the slip hangup daemon (\fIslhangupd\fP), if used, takes one entry
Xof \fBSLIP's\fP driver data structure, and should be considered before setting
X\fBSLIP_NUM\fP.
X.PP
X\fII_STR ioctl commands:\fP
X.PP
XThe I_STR ioctl commands are provided to add the capability of passing
XM_HANGUP signal received by the \fBSLIP\fP driver to the process that builds the
XSLIP protocol stack.
XThis is necessary because the TCP/IP protocol stack may disregard M_HANGUP
Xmessages.
X.PP
XThe I_STR ioctl commands codes below are defined in <\fIsys/slip.h\fP>.
X.TP 20
X.B REG_SLHUP
XA process that sends this ioctl will be notified of M_HANGUP messages sent
Xby any of the lower ttys associated with the \fBSLIP\fP driver.
XThe notification is done by sending an M_DATA messages containing the process
XID of the program that linked the effected tty to the \fBSLIP\fP driver.
XThis ioctl is generally sent by SLIP hangup daemon \fIslhangupd\fP.
XOnly one process can be registered to receive M_HANGUP notifications at any
Xone time.
X.TP 20
X.B UNREG_SLHUP
XThis ioctl unregisters a process from receiving M_HANGUP notifications.
XSince only one process can be registered to receive M_HANGUP notifications,
Xit is important that a process unregister before it exits.
X.SH SEE ALSO
Xslattach(1M), sldetach(1M), slhangupd(1M), asy(7), ip(7)
X.SH FILES
X/dev/slip
X.SH AUTHOR
XSudji Husodo
END_OF_FILE
  if test 3431 -ne `wc -c <'man/man7/slip.7'`; then
    echo shar: \"'man/man7/slip.7'\" unpacked with wrong size!
  fi
  # end of 'man/man7/slip.7'
fi
if test -f 'utils/slattach.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/slattach.c'\"
else
  echo shar: Extracting \"'utils/slattach.c'\" \(9007 characters\)
  sed "s/^X//" >'utils/slattach.c' <<'END_OF_FILE'
X/*
X *            Copyright 1991, Intel Corporation
X *                  All rights reserved.
X *
X * Permission to use, copy, modify, and distribute this software and
X * its documentation for any purpose and without fee is hereby granted,
X * provided that the above copyright notice appear in all copies and
X * that both the copyright notice appear in all copies and that both
X * the copyright notice and this permission notice appear in
X * supporting documentation, and that the name of Intel Corporation
X * not be used in advertising or publicity pertaining to distribution
X * of the software without specific, written prior premission.
X * 
X * COMPANY AND/OR INTEL DISCLAIM ALL WARRANTIES WITH REGARD TO
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
X * MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO
X * EVENT SHALL COMPANY NOR INTEL BE LIABLE FOR ANY SPECIAL,
X * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
X * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
X * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
X * OF THIS SOFTWARE.
X */
X
X/*
X * Name:
X *		slattach
X *
X * Synopsis:
X *		slattach [-i] nodename interface_name
X *		slattach -d [-i] devname interface_name [ baudrate ]
X *		slattach -  interface_name process_id
X *
X * Description:
X *		Slattach is used to assign a serial line to a network interface
X *		using the Internet Protocol.
X *
X *		Slattach defaults to use BNU (Basic Networking Utilities) to
X *		establish an outgoing serial line connection. Look at Advanced
X *		System Administration Section 7-15. The -d option causes slattach
X *		to directly open the specified device name, without using BNU, to be
X *		linked to the slip driver. In this case the baudrate parameter is
X *		used to set the speed of the connection; the default speed is 9600.
X *
X *		The - options specifies that stdin is the device to be attached to
X *		the slip driver.
X *
X *		If the slip hangup daemon (slhangupd) is run, slattach by default
X *		is set to receive hangup signal (SIGHUP) sent by the slip driver
X *		through slhangupd. The -i option ignores any hangup signal.
X *
X * Example:
X *		slattach [-i] venus sl0
X *		slattach -d [-i] /dev/tty00 sl0 19200
X *		slattach - sl0
X *
X * Author:
X *		Sudji Husodo	1/31/91
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <fcntl.h>
X#include <stropts.h>
X#include <termio.h>
X#include <signal.h>
X
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/sockio.h>
X#include <sys/stream.h>
X#include <net/if.h>
X#include <sys/slip.h>
X/*
X#include <dial.h>
X*/
X
X/*
X * Unix V.4.0.3 doesn't include dial.h in /usr/include directory,
X * so define typedef CALL.
X */
X
Xtypedef struct {
X	struct	termio *attr;	/* ptr to termio attribute struct */
X	int		baud;			/* unused */
X	int		speed;			/* less than 0 for any speed */
X	char	*line;			/* device name for out-going line */
X	char	*telno;			/* ptr to tel-no/system name string */
X	int		modem;			/* unused */
X	char	*device;		/* unused */
X	int		dev_len;		/* unused */
X} CALL;
X
Xchar	*program;
Xchar	*ipname = "/dev/ip";
Xchar	*slipname = "/dev/slip";
Xchar	devname[16], ifname[16];
Xint		fd_link, fd_ip, fd_slip;
Xunsigned char fd_dev;
Xint		ppid = 0;
X
XCALL	ds;
Xstruct	termio	tio;
Xvoid	slsignal (int);
X
Xmain (int argc, char *argv[])
X{
X	int		iflag = 0;					/* ignore hangup signal flag */
X	int		dflag = 0;
X	extern	char *optarg;
X	extern	int  optind;
X	int		ac;
X	char	**av;
X
X	int		speed;
X	pid_t	pid;
X	struct	strioctl iocb;
X	struct	ifreq	ifr;
X
X#ifdef DEBUG
X	extern int Debug;
X	Debug = 9;
X#endif
X
X	program = argv[0];
X
X	/*
X	 * If first argument is '-' only, we're using stdin as the device
X	 */
X
X 	if (argv[1][0] == '-' && argv[1][1] == '\0') {
X		if (strlen(argv[2]) < 1)				/* check for usage */
X			usage ();
X	}
X
X	/*
X	 * otherwise check for options using getopt
X	 */
X
X	else {
X		while ((speed = getopt (argc, argv, "id")) != EOF)
X			switch (speed) {
X				case 'i':	iflag++;	break;
X				case 'd':	dflag++;	break;
X				case '?':	usage ();
X			}
X
X		ac = argc - optind + 1;					/* set ac, argument count */
X		av = &argv [optind];					/* and av, arguments */
X
X		if (ac < 3)								/* check legal usage */
X			usage ();
X	}
X
X	/*
X	 * daemonize the process if it is not a DEBUG version
X	 */
X
X#ifndef DEBUG
X	setpgrp ();
X
X	switch (fork()) {
X	case 0:
X		break;
X	case -1:
X		perror ("fork failed");
X		exit (2);
X	default:
X 		if (argv[1][0] == '-' && argv[1][1] == '\0')
X			sleep (3);
X		else
X			wait (0);
X		exit (0);
X	}
X#endif
X
X	/*
X	 * If first argument is '-' only, we're using stdin as the device
X 	 */
X
X 	if (argv[1][0] == '-' && argv[1][1] == '\0') {
X		fd_dev = fileno (stdin);				/* device is stdin */
X 		strcpy (ifname, argv[2]);				/* remember ifname */
X 		ppid = atoi (argv[3]);
X
X		ioctl (fd_dev, I_POP, "ldterm");		/* ignore ioctl error */
X		ioctl (fd_dev, I_POP, "ttcompat");
X
X		if (ioctl (fd_dev, TCGETA, &tio) < 0)
X			slerror ("%s: ioctl TCGETA failed", argv[0]);
X
X		tio.c_cflag |= CS8 | CREAD;
X
X		if (ioctl (fd_dev, TCSETA, &tio) < 0)
X			slerror ("%s: ioctl TCSANOW failed", argv[0]);
X	}
X
X	/*
X	 * We are using BNU (default) through dial(3C)
X	 */
X
X	else if (!dflag) {
X		strcpy (devname, av[0]);				/* get nodename and ifname */
X		strcpy (ifname, av[1]);
X
X		/*
X		 * get device file descriptor through BNU's dial call.
X		 * get and set device attributes. pop ldterm and ttcompat.
X		 */
X
X		ds.attr  = 0;
X		ds.speed = -1;
X		ds.line  = "";
X		ds.telno = devname;
X
X		if ((fd_dev = dial (ds)) < 0)
X			slerror ("%s: dial failed", argv[0]);
X
X		if (ioctl (fd_dev, TCGETA, &tio) < 0)
X			slerror ("%s: ioctl TCGETA failed", argv[0]);
X
X		tio.c_iflag = BRKINT | IGNPAR;
X		tio.c_cflag = (tio.c_cflag & 0x0f) | CS8 | CREAD;
X
X		if (ioctl (fd_dev, TCSETA, &tio) < 0)
X			slerror ("%s: ioctl TCSANOW failed", argv[0]);
X
X		ioctl (fd_dev, I_POP, "ldterm");		/* ignore ioctl error */
X		ioctl (fd_dev, I_POP, "ttcompat");
X	}
X
X	/*
X	 * we are not using BNU. The next argument is the serial device name.
X	 */
X
X	else {
X		if (*av[0] == '/') {					/* if device path is absolute */
X			strcpy (devname, av[0]);			/* copy device as it is */
X		}
X		else {									/* device path is relative */
X			strcpy (devname, "/dev/");			/* add "/dev/" to devname */
X			strcat (devname, av[0]);
X		}
X		strcpy (ifname, av[1]);					/* the next two argument is */
X		speed = atoi (av[2]);					/* ifname and baud (optional) */
X
X		/*
X		 * open device directly. pop ldterm and ttcompat.
X		 * get and set device attributes.
X		 */
X
X		if ((fd_dev = open (devname, O_RDWR)) < 0)
X			slerror ("%s: open %s failed", argv[0], devname);
X
X		ioctl (fd_dev, I_POP, "ldterm");		/* ignore ioctl error */
X		ioctl (fd_dev, I_POP, "ttcompat");
X
X		if (ioctl (fd_dev, TCGETA, &tio) < 0)
X			slerror ("%s: ioctl TCGETA failed", argv[0]);
X
X		tio.c_iflag = BRKINT | IGNPAR;			/* sig break, no parity */
X		tio.c_cflag = CS8 | CREAD;				/* 8 bits, enable rcver */
X
X		switch (speed) {
X			case 1200:	tio.c_cflag |= B1200;		break;
X			case 1800:	tio.c_cflag |= B1800;		break;
X			case 2400:	tio.c_cflag |= B2400;		break;
X			case 4800:	tio.c_cflag |= B4800;		break;
X			case 19200: tio.c_cflag |= B19200;		break;
X			case 38400:	tio.c_cflag |= B38400;		break;
X			default:	tio.c_cflag |= B9600;		break;
X		}
X
X		if (ioctl (fd_dev, TCSETA, &tio) < 0)
X			slerror ("%s: ioctl TCSANOW failed", argv[0]);
X	}
X
X	/*
X	 * the default is to catch SIGHUP, but if iflag is set ignore SIGHUP.
X	 */
X
X	if (!iflag)
X		signal (SIGHUP, slsignal);
X	else
X		sigignore (SIGHUP);
X
X	/*
X	 * link slip to device, open ip, link ip with fd_dev
X	 */
X
X	if ((fd_slip = open (slipname, O_RDWR)) < 0)
X		slerror ("%s: open %s failed", argv[0], slipname);
X
X	if ((fd_ip = open (ipname, O_RDWR)) < 0)
X		slerror ("%s: open %s failed", argv[0], ipname);
X
X	if (ioctl (fd_slip, I_LINK, fd_dev) < 0)
X		slerror ("%s: ioctl I_LINK %s failed", argv[0], slipname);
X
X	if ((fd_link = ioctl (fd_ip, I_LINK, fd_slip)) < 0)
X		slerror ("%s: ioctl I_LINK %s failed", argv[0], ipname);
X
X	/*
X	 * send a SIOCSIFNAME (set interface name) ioctl down the stream
X	 * referenced by fd_ip for the link associated with link identier
X	 * fd_link specifying the name ifname
X	 */
X
X	strcpy (ifr.ifr_name,ifname);
X	ifr.ifr_metric = fd_link;
X
X	iocb.ic_cmd = SIOCSIFNAME;
X	iocb.ic_timout = 15;
X	iocb.ic_len = sizeof (ifr);
X	iocb.ic_dp = (char *) &ifr;
X
X	if (ioctl (fd_ip, I_STR, &iocb) < 0)
X		slerror ("%s: ioctl SIOCSIFNAME (set interface name) failed", argv[0]);
X
X	kill (getppid(), SIGINT);					/* interrupt signal parent */
X	pause ();									/* wait forever */
X}
X
X/*
X * slsignal
X */
X
Xvoid slsignal (int x)
X{
X	fprintf (stderr,"%s: %s got a SIGHUP, ... exiting ...\n",program,ifname);
X	if (ppid)
X		kill (ppid, SIGHUP);
X	exit (0);
X}
X
X/*
X * slerror ()
X */
X
Xslerror (s1, s2, s3)
Xchar *s1, *s2, *s3;
X{
X	fprintf (stderr,s1,s2,s3);
X	fprintf (stderr,"\n");
X	exit (1);
X}
X
X/*
X * usage ()
X */
X
Xusage ()
X{
X	printf ("\nUsage: %s [-i] system_name interface_name\n",program);
X	printf (  "OR:    %s -d [-i] device_name interface_name\n",program);
X	printf (  "OR:    %s - interface_name [process_id]\n",program);
X	exit (1);
X}
END_OF_FILE
  if test 9007 -ne `wc -c <'utils/slattach.c'`; then
    echo shar: \"'utils/slattach.c'\" unpacked with wrong size!
  fi
  # end of 'utils/slattach.c'
fi
if test -f 'utils/slhangupd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/slhangupd.c'\"
else
  echo shar: Extracting \"'utils/slhangupd.c'\" \(3760 characters\)
  sed "s/^X//" >'utils/slhangupd.c' <<'END_OF_FILE'
X/*
X *            Copyright 1991, Intel Corporation
X *                  All rights reserved.
X *
X * Permission to use, copy, modify, and distribute this software and
X * its documentation for any purpose and without fee is hereby granted,
X * provided that the above copyright notice appear in all copies and
X * that both the copyright notice appear in all copies and that both
X * the copyright notice and this permission notice appear in
X * supporting documentation, and that the name of Intel Corporation
X * not be used in advertising or publicity pertaining to distribution
X * of the software without specific, written prior premission.
X * 
X * COMPANY AND/OR INTEL DISCLAIM ALL WARRANTIES WITH REGARD TO
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
X * MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO
X * EVENT SHALL COMPANY NOR INTEL BE LIABLE FOR ANY SPECIAL,
X * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
X * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
X * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
X * OF THIS SOFTWARE.
X */
X
X/*
X * Name:
X *		slhangup
X *
X * Synopsis:
X *		slhangup
X *
X * Description:
X *		Slhangup is used to receive M_HANGUP messages sent by the slip driver.
X *		This utility and extensions to the slip driver is necessary because
X *		tcp and ip throws away messages that they don't understand, such as,
X *		M_HANGUP.
X *
X * Example:
X *		slhangup
X *
X * Author:
X *		Sudji Husodo	1/31/91
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <stdio.h>
X#include <fcntl.h>
X#include <stropts.h>
X#include <termio.h>
X#include <signal.h>
X
X#include <sys/stream.h>
X#include <sys/socket.h>
X#include <sys/sockio.h>
X#include <net/if.h>
X#include <sys/slip.h>
X
Xvoid	unregister (int);
Xstruct	strioctl iocb;
Xchar	*slipname = "/dev/slip";
Xchar	*program;
Xint		fd_slip;
X
Xmain (int argc, char *argv[])
X{
X	struct	strbuf	ctlbuf;
X	pid_t	pid_sl;
X	int		flags = 0;
X
X	/*
X	 * daemonize
X	 */
X	program = argv[0];
X	setpgrp ();
X
X	switch (fork()) {
X	case 0:		break;
X	case -1:	perror ("fork failed");		exit (2);
X	default:	exit (0);
X	}
X
X	/*
X	 * open the slip driver
X	 */
X
X	if ((fd_slip = open (slipname, O_RDWR)) < 0)
X		slerror ("%s: open %s failed", argv[0], slipname);
X
X	iocb.ic_cmd = REG_SLHUP;
X	iocb.ic_timout = 0;
X	iocb.ic_len = 0;
X	iocb.ic_dp = "";
X
X	/*
X	 * register the process, so the slip driver knows that there is
X	 * hangup daemon waiting to receive M_HANGUP messages.
X	 */
X
X	if (ioctl (fd_slip, I_STR, &iocb) < 0)
X		slerror ("%s: can't register slip's hangup daemon", argv[0]);
X
X	signal (SIGINT, unregister);
X	signal (SIGQUIT, unregister);
X	signal (SIGTERM, unregister);
X
X	/*
X	 * wait for any message sent by slip, if getmsg completes succesfully,
X	 * send a hangup signal to the slattach process id received in the
X	 * message.
X	 */ 
X
X	ctlbuf.maxlen = sizeof (pid_t);
X	ctlbuf.len = 0;
X	ctlbuf.buf = (char *) &pid_sl;
X
X	while (1) {
X		if (getmsg (fd_slip, &ctlbuf, NULL, &flags) < 0) {
X			fprintf (stderr, "\n%s: getmsg returns an error\n", program); 
X			continue;
X		}
X		fprintf (stderr, "\n%s: got M_HANGUP from slip, sending SIGUP to pid %d ...\n", program, pid_sl);
X
X		if (kill (pid_sl, SIGHUP) < 0) {
X			fprintf (stderr,"%s: can't send SIGHUP to pid %d\n",program,pid_sl);
X			continue;
X		}
X		sleep (1);
X	}
X}
X
X/*
X * slerror ()
X */
X
Xslerror (s1, s2, s3)
Xchar *s1, *s2, *s3;
X{
X	fprintf (stderr,s1,s2,s3);
X	fprintf (stderr,"\n");
X	exit (1);
X}
X
X/*
X * unregister - unregister if the slip hangup daemon is terminated.
X */
X
Xvoid unregister (int x)
X{
X	fprintf (stderr, "\n%s: killed ...\n", program);
X	iocb.ic_cmd = UNREG_SLHUP;
X	if (ioctl (fd_slip, I_STR, &iocb) < 0)
X		slerror ("%s: can't unregister slip's hangup daemon", program);
X	exit (0);
X}
END_OF_FILE
  if test 3760 -ne `wc -c <'utils/slhangupd.c'`; then
    echo shar: \"'utils/slhangupd.c'\" unpacked with wrong size!
  fi
  # end of 'utils/slhangupd.c'
fi
echo shar: End of archive 3 \(of 4\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
