Subject:  v24i016:  GNU Diff, version 1.15, Part01/08
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: 757b9767 fc5b0ddd 339090ba 548b3d5c

Submitted-by: Paul Eggert <eggert@twinsun.com>
Posting-number: Volume 24, Issue 16
Archive-name: gnudiff1.15/part01

This is GNU DIFF 1.15.  As well as many minor improvements, this version has
the following new features:

	-u (+unified) option for new unified diff format
	-L (+file-label) option
	-a and -m options for diff3
	Most output styles can represent incomplete input lines.
	`Text' is defined by ISO 8859.
	diff3 exit status 0 means success, 1 means overlaps, 2 means trouble.

Please see the README file for more information.
Please report bugs to bug-gnu-utils@prep.ai.mit.edu.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 8)."
# Contents:  MANIFEST Makefile README alloca.c diagmeet.note dir.c ed.c
#   getopt.h getopt1.c ifdef.c limits.h normal.c version.c
# Wrapped by eggert@ata on Mon Jan  7 11:25:28 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(5997 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XThis directory contains the GNU DIFF and DIFF3 utilities, version 1.15.
XSee file COPYING for copying conditions.  To compile and install on
Xsystem V, you must edit the makefile according to comments therein.
X
XReport bugs to bug-gnu-utils@prep.ai.mit.edu
X
XVersion 1.15 has the following new features; please see below for details.
X
X   -L (+file-label) option
X   -u (+unified) option
X   -a and -m options for diff3
X   Most output styles can represent incomplete input lines.
X   `Text' is defined by ISO 8859.
X   diff3 exit status 0 means success, 1 means overlaps, 2 means trouble.
X
X 
XThis version of diff provides all the features of BSD's diff.
XIt has these additional features:
X
X   An input file may end in a non-newline character.  If so, its last
X   line is called an incomplete line and is distinguished on output
X   from a full line.  In the default, -c, and -u output styles, an
X   incomplete output line is followed by a diagnostic line that starts
X   with \.  With -n, an incomplete line is output without a trailing
X   newline.  Other output styles (-D, -e, -f) cannot represent an
X   incomplete line, so they pretend that there was a newline, and -e and -f
X   also print an error message.  For example, suppose F and G are one-byte
X   files that contain just ``f'' and ``g'', respectively.
X
X   Then ``diff F G'' outputs
X
X	1c1
X	< f
X	\ No newline at end of file
X	---
X	> g
X	\ No newline at end of file
X
X   (The exact diagnostic message may differ, e.g. for non-English locales.)
X   ``diff -n F G'' outputs the following without a trailing newline:
X
X	d1 1
X	a1 1
X	g
X
X   ``diff -e F G'' sends two diagnostics to stderr and the following to stdout:
X
X	1c
X	g
X	.
X
X   A file is considered to be text if its first characters are all in the
X   ISO 8859 character set; BSD's diff uses Ascii.
X
X   GNU DIFF has the following additional options:
X
X   -a	Always treat files as text and compare them line-by-line,
X	even if they do not appear to be text.
X
X   -B	ignore changes that just insert or delete blank lines.
X
X   -C #
X	request -c format and specify number of context lines.
X
X   -F regexp
X	in context format, for each unit of differences, show some of
X	the last preceding line that matches the specified regexp.
X
X   -H	use heuristics to speed handling of large files that
X	have numerous scattered small changes.  The algorithm becomes
X        asymptotically linear for such files!
X	
X   -I regexp
X	ignore changes that just insert or delete lines that
X	match the specified regexp.
X
X   -L label
X	Use the specified label in file header lines output by the -c option.
X	This option may be given zero, one, or two times,
X	to affect neither label, just the first file's label, or both labels.
X	A file's default label is its name, a tab, and its modification date.
X
X   -N	in directory comparison, if a file is found in only one directory,
X	treat it as present but empty in the other directory.
X
X   -p	equivalent to -c -F'^[_a-zA-Z]'.  This is useful for C code
X	because it shows which function each change is in.
X
X   -T	print a tab rather than a space before the text of a line
X	in normal or context format.  This causes the alignment
X	of tabs in the line to look normal.
X
X   -u[#]
X	produce unified style output with # context lines (default 3).
X	This style is like -c, but it is more compact because context
X	lines are printed only once.  Lines from just the first file
X	are marked '-'; lines from just the second file are marked '+'.
X
XThis version of diff3 has all of BSD diff3's features, with the following
Xadditional features.
X
X   An input file may end in a non-newline character.  With the -m option,
X   an incomplete last line stays incomplete.  Other output styles treat
X   incomplete lines like diff.
X
X   The file name '-' denotes the standard input.  It can appear at most once.
X
X   diff3 has the following additional options:
X
X   -a	Always treat files as text and compare them line-by-line,
X	even if they do not appear to be text.
X
X   -i	Include 'w' and 'q' commands at the end of the output, to write out
X	the changed file, thus emulating system V behavior.  One of the edit
X	script options -e, -E, -x, -X, -3 must also be specified.
X
X   -m	Apply the edit script to the first file and send the result to
X	standard output.  Unlike piping diff3's output to ed(1), this works
X	even for binary files and incomplete lines.  -E is assumed if no edit
X	script option is specified.  This option is incompatible with -i.
X
X   -L label
X	Use the specified label for lines output by the -E and -X options,
X	one of which must also be specified.  This option may be given zero,
X	one, or two times; the first label marks <<<<<<< lines and the second
X	marks >>>>>>> lines.  The default labels are the names of the first and
X	third files on the command line.  Thus ``diff3 -L X -L Z -E A B C''
X	acts like ``diff3 -E A B C'', except that the output looks like it
X	came from files named X and Z rather than from files named A and C.
X
X    Exit status 0 means success, 1 means overlaps were found and -E or -X was
X    specified, and 2 means trouble.
X
X
X
XGNU DIFF was written by Mike Haertel, David Hayes, Richard Stallman
Xand Len Tower.  The basic algorithm is described in: "An O(ND)
XDifference Algorithm and its Variations", Eugene Myers, Algorithmica
XVol. 1 No. 2, 1986, p 251.
X
XMany bugs were fixed by Paul Eggert.  The unified diff idea and format
Xare from Wayne Davison.
X
XSuggested projects for improving GNU DIFF:
X
X* Handle very large files by not keeping the entire text in core.
X
XOne way to do this is to scan the files sequentally to compute hash
Xcodes of the lines and put the lines in equivalence classes based only
Xon hash code.  Then compare the files normally.  This will produce
Xsome false matches.
X
XThen scan the two files sequentially again, checking each match to see
Xwhether it is real.  When a match is not real, mark both the
X"matching" lines as changed.  Then build an edit script as usual.
X
XThe output routines would have to be changed to scan the files
Xsequentially looking for the text to print.
END_OF_FILE
if test 5997 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1734 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X COPYING                    2	copying permissions (GNU General Public License)
X ChangeLog                  4	log of recent changes
X MANIFEST                   1	This shipping list
X Makefile                   1	makefile for GNU DIFF
X README                     1	Read me first.
X alloca.c                   1	Gwyn's (mostly) portable public-domain alloca()
X analyze.c                  5	Analyze file differences for GNU DIFF.
X context.c                  2	context-format output routines for GNU DIFF
X diagmeet.note              1	an internals note on how diff diagonals meet
X diff.c                     3	GNU DIFF main routine
X diff.h                     2	shared definitions for GNU DIFF
X diff3.c                    8	three-way file comparison program (diff3)
X dir.c                      1	Read, sort and compare two directories.
X ed.c                       1	output routines for ed-script format
X getopt.c                   3	getopt for GNU
X getopt.h                   1	declarations for getopt
X getopt1.c                  1	(long) getopt for GNU
X ifdef.c                    1	#ifdef-format output routines for GNU DIFF
X io.c                       4	file I/O for GNU DIFF
X limits.h                   1	implementation limits
X normal.c                   1	normal-format output routines for GNU DIFF
X regex.c1                   7	regular expression matching and search (part 1)
X regex.c2                   6	regular expression matching and search (part 2)
X regex.h                    2	definitions for regex data structures
X util.c                     3	support routines for GNU DIFF
X version.c                  1	version number of GNU DIFF
END_OF_FILE
if test 1734 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(3536 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Makefile for GNU DIFF
X# Copyright (C) 1988, 1989 Free Software Foundation, Inc.
X
X# This file is part of GNU DIFF.
X
X# GNU DIFF is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation; either version 1, or (at your option)
X# any later version.
X# 
X# GNU DIFF is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X# 
X# You should have received a copy of the GNU General Public License
X# along with GNU DIFF; see the file COPYING.  If not, write to
X# the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X
X# You can compile this with ordinary cc as well,
X# but gcc makes it faster.
X# Also, gcc supports -O and -g together.
XCC=gcc -O
XCFLAGS = -g
XINSTALL = install
X
X# On system V, enable these three lines:
X# CFLAGS = -g -DUSG
X# LIBS = -lPW
X# INSTALL = cp
X# (If you compile with GCC, you don't need to define LIBS.)
X# And, depending on the names and contents of your header files,
X# add either -DHAVE_NDIR or -DHAVE_DIRECT or both to CFLAGS.
X# Add -DHAVE_NDIR to CFLAGS if your system used ndir.h instead of dirent.h
X# Add -DHAVE_DIRECT to CFLAGS if your system uses 'struct direct' instead of
X# 'struct dirent' (this is the case at least with one add-on ndir library).
X
X# Use these definitions for XENIX:
X# There are rumors of bugs in various Xenix's dirent.h and -ldir.  As
X# a result, we suggest using HAVE_NDIR and not using -ldir.
X# CFLAGS = -O -DUSG -DXENIX -DHAVE_NDIR -DHAVE_DIRECT -DNDIR_IN_SYS
X# LIBS = -lx -lPW
X# INSTALL = cp
X
X# Some System V machines do not come with libPW.  If this is true, use
X# the GNU alloca by switching the comment on the following lines.
XALLOCA = 
X# ALLOCA = $(archpfx)/alloca.o
X
Xbindir=/usr/local/bin
Xprefix=
X
X# All source files
Xsrcs=diff.c analyze.c io.c context.c ed.c normal.c ifdef.c util.c dir.c \
X	version.c diff.h regex.c regex.h limits.h diff3.c \
X	getopt.c getopt1.c getopt.h alloca.c
X# Object files for diff only.
Xobjs=$(archpfx)diff.o $(archpfx)analyze.o $(archpfx)io.o $(archpfx)context.o \
X     $(archpfx)ed.o $(archpfx)normal.o $(archpfx)util.o $(archpfx)dir.o \
X     $(archpfx)regex.o $(archpfx)ifdef.o $(archpfx)version.o \
X     $(archpfx)getopt.o $(archpfx)getopt1.o
Xtapefiles = $(srcs) README diagmeet.note Makefile COPYING ChangeLog
X
Xall: $(archpfx)diff $(archpfx)diff3
X
X$(archpfx)diff3: $(archpfx)diff3.o
X	$(CC) -o $(archpfx)diff3 $(CFLAGS) $(LDFLAGS) $(archpfx)diff3.o $(LIBS)
X
X$(archpfx)diff: $(objs)
X	$(CC) -o $(archpfx)diff $(CFLAGS) $(LDFLAGS) $(objs) $(LIBS)
X
X$(objs): diff.h
X
X$(archpfx)context.o $(archpfx)diff.o: regex.h
X
X$(archpfx)diff3.o: diff3.c
X	$(CC) -c $(CFLAGS) -DDIFF_PROGRAM=\"$(bindir)/diff\" diff3.c \
X $(OUTPUT_OPTION)
X
Xclean:
X	rm -f *.o $(archpfx)diff $(archpfx)diff3 diff.tar diff.tar.Z
X
Xinstall: install-diff install-diff3
X
Xinstall-diff: $(prefix)$(bindir)/diff
X
X$(prefix)$(bindir)/diff: $(archpfx)diff
X	$(INSTALL) $(archpfx)diff $(prefix)$(bindir)/diff
X
Xinstall-diff3: $(prefix)$(bindir)/diff3
X
X$(prefix)$(bindir)/diff3: $(archpfx)diff3
X	$(INSTALL) $(archpfx)diff3 $(prefix)$(bindir)/diff3
X
Xdiff.tar: $(tapefiles)
X	mkdir tmp
X	mkdir tmp/diff
X	-ln $(tapefiles) tmp/diff
X	for file in $(tapefiles); do \
X		if [ ! -r tmp/diff/$$file ]; then cp $$file tmp/diff; fi \
X	done
X	cd tmp; tar cf ../diff.tar diff
X	rm -rf tmp
X
Xdiff.tar.Z: diff.tar
X	compress < diff.tar > diff.tar.Z
END_OF_FILE
if test 3536 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'alloca.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'alloca.c'\"
else
echo shar: Extracting \"'alloca.c'\" \(5214 characters\)
sed "s/^X//" >'alloca.c' <<'END_OF_FILE'
X/*
X	alloca -- (mostly) portable public-domain implementation -- D A Gwyn
X
X	last edit:	86/05/30	rms
X	   include config.h, since on VMS it renames some symbols.
X	   Use xmalloc instead of malloc.
X
X	This implementation of the PWB library alloca() function,
X	which is used to allocate space off the run-time stack so
X	that it is automatically reclaimed upon procedure exit, 
X	was inspired by discussions with J. Q. Johnson of Cornell.
X
X	It should work under any C implementation that uses an
X	actual procedure stack (as opposed to a linked list of
X	frames).  There are some preprocessor constants that can
X	be defined when compiling for your specific system, for
X	improved efficiency; however, the defaults should be okay.
X
X	The general concept of this implementation is to keep
X	track of all alloca()-allocated blocks, and reclaim any
X	that are found to be deeper in the stack than the current
X	invocation.  This heuristic does not reclaim storage as
X	soon as it becomes invalid, but it will do so eventually.
X
X	As a special case, alloca(0) reclaims storage without
X	allocating any.  It is a good idea to use alloca(0) in
X	your main control loop, etc. to force garbage collection.
X*/
X#ifndef lint
Xstatic char	SCCSid[] = "@(#)alloca.c	1.1";	/* for the "what" utility */
X#endif
X
X#ifdef emacs
X#include "config.h"
X#ifdef static
X/* actually, only want this if static is defined as ""
X   -- this is for usg, in which emacs must undefine static
X   in order to make unexec workable
X   */
X#ifndef STACK_DIRECTION
Xyou
Xlose
X-- must know STACK_DIRECTION at compile-time
X#endif /* STACK_DIRECTION undefined */
X#endif static
X#endif emacs
X
X#ifdef X3J11
Xtypedef void	*pointer;		/* generic pointer type */
X#else
Xtypedef char	*pointer;		/* generic pointer type */
X#endif
X
X#define	NULL	0			/* null pointer constant */
X
Xextern void	free();
Xextern pointer	xmalloc();
X
X/*
X	Define STACK_DIRECTION if you know the direction of stack
X	growth for your system; otherwise it will be automatically
X	deduced at run-time.
X
X	STACK_DIRECTION > 0 => grows toward higher addresses
X	STACK_DIRECTION < 0 => grows toward lower addresses
X	STACK_DIRECTION = 0 => direction of growth unknown
X*/
X
X#ifndef STACK_DIRECTION
X#define	STACK_DIRECTION	0		/* direction unknown */
X#endif
X
X#if STACK_DIRECTION != 0
X
X#define	STACK_DIR	STACK_DIRECTION	/* known at compile-time */
X
X#else	/* STACK_DIRECTION == 0; need run-time code */
X
Xstatic int	stack_dir;		/* 1 or -1 once known */
X#define	STACK_DIR	stack_dir
X
Xstatic void
Xfind_stack_direction (/* void */)
X{
X  static char	*addr = NULL;	/* address of first
X				   `dummy', once known */
X  auto char	dummy;		/* to get stack address */
X
X  if (addr == NULL)
X    {				/* initial entry */
X      addr = &dummy;
X
X      find_stack_direction ();	/* recurse once */
X    }
X  else				/* second entry */
X    if (&dummy > addr)
X      stack_dir = 1;		/* stack grew upward */
X    else
X      stack_dir = -1;		/* stack grew downward */
X}
X
X#endif	/* STACK_DIRECTION == 0 */
X
X/*
X	An "alloca header" is used to:
X	(a) chain together all alloca()ed blocks;
X	(b) keep track of stack depth.
X
X	It is very important that sizeof(header) agree with malloc()
X	alignment chunk size.  The following default should work okay.
X*/
X
X#ifndef	ALIGN_SIZE
X#define	ALIGN_SIZE	sizeof(double)
X#endif
X
Xtypedef union hdr
X{
X  char	align[ALIGN_SIZE];	/* to force sizeof(header) */
X  struct
X    {
X      union hdr *next;		/* for chaining headers */
X      char *deep;		/* for stack depth measure */
X    } h;
X} header;
X
X/*
X	alloca( size ) returns a pointer to at least `size' bytes of
X	storage which will be automatically reclaimed upon exit from
X	the procedure that called alloca().  Originally, this space
X	was supposed to be taken from the current stack frame of the
X	caller, but that method cannot be made to work for some
X	implementations of C, for example under Gould's UTX/32.
X*/
X
Xstatic header *last_alloca_header = NULL; /* -> last alloca header */
X
Xpointer
Xalloca (size)			/* returns pointer to storage */
X     unsigned	size;		/* # bytes to allocate */
X{
X  auto char	probe;		/* probes stack depth: */
X  register char	*depth = &probe;
X
X#if STACK_DIRECTION == 0
X  if (STACK_DIR == 0)		/* unknown growth direction */
X    find_stack_direction ();
X#endif
X
X				/* Reclaim garbage, defined as all alloca()ed storage that
X				   was allocated from deeper in the stack than currently. */
X
X  {
X    register header	*hp;	/* traverses linked list */
X
X    for (hp = last_alloca_header; hp != NULL;)
X      if (STACK_DIR > 0 && hp->h.deep > depth
X	  || STACK_DIR < 0 && hp->h.deep < depth)
X	{
X	  register header	*np = hp->h.next;
X
X	  free ((pointer) hp);	/* collect garbage */
X
X	  hp = np;		/* -> next header */
X	}
X      else
X	break;			/* rest are not deeper */
X
X    last_alloca_header = hp;	/* -> last valid storage */
X  }
X
X  if (size == 0)
X    return NULL;		/* no allocation required */
X
X  /* Allocate combined header + user data storage. */
X
X  {
X    register pointer	new = xmalloc (sizeof (header) + size);
X    /* address of header */
X
X    ((header *)new)->h.next = last_alloca_header;
X    ((header *)new)->h.deep = depth;
X
X    last_alloca_header = (header *)new;
X
X    /* User storage begins just after header. */
X
X    return (pointer)((char *)new + sizeof(header));
X  }
X}
X
END_OF_FILE
if test 5214 -ne `wc -c <'alloca.c'`; then
    echo shar: \"'alloca.c'\" unpacked with wrong size!
fi
# end of 'alloca.c'
fi
if test -f 'diagmeet.note' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'diagmeet.note'\"
else
echo shar: Extracting \"'diagmeet.note'\" \(1069 characters\)
sed "s/^X//" >'diagmeet.note' <<'END_OF_FILE'
XHere is a comparison matrix which shows a case in which
Xit is possible for the forward and backward scan in `diag'
Xto meet along a nonzero length of diagonal simultaneous
X(so that bdiag[d] and fdiag[d] are not equal)
Xeven though there is no snake on that diagonal at the meeting point.
X
X
X     85   1   1   1  159  1   1   17
X        1   2   3   4
X60
X    1   2
X1
X    2  	    2   3   4
X71
X    3       3  	4   5
X85
X    4  	3   4	5
X17
X    5  	4   5
X1
X    6       4  	5   6
X183
X    7       5   6   7
X10
X    8  	    6  	7
X1
X    9           6   7  	8
X12
X                7   8   9  10
X13
X       10       8   9  10
X14
X           10   9  10
X17
X       10      10
X1
X   10   9  10
X1
X	8      10      10      10
X183
X    8   7	9       9      	9
X10
X    7   6	8   9   8      	8
X1
X    6   5    		7       7
X1
X            5          	6      	6
X1
X	       	5      	5      	5
X50
X	    5   4      	4      	4
X1
X	            4   3	3
X85
X	    5   4   3   2       2
X1
X	                    2   1
X17
X	    5   4   3   2   1       1
X1
X		                1   0
X     85   1   1   1  159  1   1  17
X
X
X
X
X
X
X
X
X
END_OF_FILE
if test 1069 -ne `wc -c <'diagmeet.note'`; then
    echo shar: \"'diagmeet.note'\" unpacked with wrong size!
fi
# end of 'diagmeet.note'
fi
if test -f 'dir.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dir.c'\"
else
echo shar: Extracting \"'dir.c'\" \(5765 characters\)
sed "s/^X//" >'dir.c' <<'END_OF_FILE'
X/* Read, sort and compare two directories.  Used for GNU DIFF.
X   Copyright (C) 1988, 1989 Free Software Foundation, Inc.
X
XThis file is part of GNU DIFF.
X
XGNU DIFF is free software; you can redistribute it and/or modify
Xit under the terms of the GNU General Public License as published by
Xthe Free Software Foundation; either version 1, or (at your option)
Xany later version.
X
XGNU DIFF is distributed in the hope that it will be useful,
Xbut WITHOUT ANY WARRANTY; without even the implied warranty of
XMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
XGNU General Public License for more details.
X
XYou should have received a copy of the GNU General Public License
Xalong with GNU DIFF; see the file COPYING.  If not, write to
Xthe Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
X
X#include "diff.h"
X
Xstatic int compare_names ();
X
X/* Read the directory named DIRNAME and return a sorted vector
X   of filenames for its contents.  NONEX nonzero means this directory is
X   known to be nonexistent, so return zero files.  */
X
Xstruct dirdata
X{
X  int length;			/* # elements in `files' */
X  char **files;			/* Sorted names of files in the dir */
X};
X
Xstatic struct dirdata
Xdir_sort (dirname, nonex)
X     char *dirname;
X     int nonex;
X{
X  register DIR *reading;
X  register struct direct *next;
X  struct dirdata dirdata;
X
X  /* Address of block containing the files that are described.  */
X  char **files;
X
X  /* Length of block that `files' points to, measured in files.  */
X  int nfiles;
X
X  /* Index of first unused in `files'.  */
X  int files_index;
X
X  if (nonex)
X    {
X      dirdata.length = 0;
X      dirdata.files = 0;
X      return dirdata;
X    }
X
X  /* Open the directory and check for errors.  */
X  reading = opendir (dirname);
X  if (!reading)
X    {
X      perror_with_name (dirname);
X      dirdata.length = -1;
X      return dirdata;
X    }
X
X  /* Initialize the table of filenames.  */
X
X  nfiles = 100;
X  files = (char **) xmalloc (nfiles * sizeof (char *));
X  files_index = 0;
X
X  /* Read the directory entries, and insert the subfiles
X     into the `files' table.  */
X
X  while (next = readdir (reading))
X    {
X      /* Ignore the files `.' and `..' */
X      if (next->d_name[0] == '.'
X	  && (next->d_name[1] == 0
X	      || (next->d_name[1] == '.'
X		  && next->d_name[2] == 0)))
X	continue;
X
X      if (files_index == nfiles)
X	{
X	  nfiles *= 2;
X	  files
X	    = (char **) xrealloc (files, sizeof (char *) * nfiles);
X	}
X      files[files_index++] = concat (next->d_name, "", "");
X    }
X
X  closedir (reading);
X
X  /* Sort the table.  */
X  qsort (files, files_index, sizeof (char *), compare_names);
X
X  /* Return a description of location and length of the table.  */
X  dirdata.files = files;
X  dirdata.length = files_index;
X
X  return dirdata;
X}
X
X/* Sort the files now in the table.  */
X
Xstatic int
Xcompare_names (file1, file2)
X     char **file1, **file2;
X{
X  return strcmp (*file1, *file2);
X}
X
X/* Compare the contents of two directories named NAME1 and NAME2.
X   This is a top-level routine; it does everything necessary for diff
X   on two directories.
X
X   NONEX1 nonzero says directory NAME1 doesn't exist, but pretend it is
X   empty.  Likewise NONEX2.
X
X   HANDLE_FILE is a caller-provided subroutine called to handle each file.
X   It gets five operands: dir and name (rel to original working dir) of file
X   in dir 1, dir and name pathname of file in dir 2, and the recursion depth.
X
X   For a file that appears in only one of the dirs, one of the name-args
X   to HANDLE_FILE is zero.
X
X   DEPTH is the current depth in recursion.
X
X   Returns the maximum of all the values returned by HANDLE_FILE,
X   or 2 if trouble is encountered in opening files.  */
X
Xint
Xdiff_dirs (name1, name2, handle_file, depth, nonex1, nonex2)
X     char *name1, *name2;
X     int (*handle_file) ();
X     int nonex1, nonex2;
X{
X  struct dirdata data1, data2;
X  register int i1, i2;
X  int val = 0;
X  int v1;
X
X  /* Get sorted contents of both dirs.  */
X  data1 = dir_sort (name1, nonex1);
X  data2 = dir_sort (name2, nonex2);
X  if (data1.length == -1 || data2.length == -1)
X    {
X      if (data1.length >= 0)
X	free (data1.files);
X      if (data2.length >= 0)
X	free (data2.files);
X      return 2;
X    }
X
X  i1 = 0;
X  i2 = 0;
X
X  /* If -Sname was specified, and this is the topmost level of comparison,
X     ignore all file names less than the specified starting name.  */
X
X  if (dir_start_file && depth == 0)
X    {
X      while (i1 < data1.length && strcmp (data1.files[i1], dir_start_file) < 0)
X	i1++;
X      while (i2 < data2.length && strcmp (data2.files[i2], dir_start_file) < 0)
X	i2++;
X    }
X
X  /* Loop while files remain in one or both dirs.  */
X  while (i1 < data1.length || i2 < data2.length)
X    {
X      int nameorder;
X
X      /* Compare next name in dir 1 with next name in dir 2.
X	 At the end of a dir,
X	 pretend the "next name" in that dir is very large.  */
X
X      if (i1 == data1.length)
X	nameorder = 1;
X      else if (i2 == data2.length)
X	nameorder = -1;
X      else
X	nameorder = strcmp (data1.files[i1], data2.files[i2]);
X
X      if (nameorder == 0)
X	{
X	  /* We have found a file (or subdir) in common between both dirs.
X	     Compare the two files.  */
X	  v1 = (*handle_file) (name1, data1.files[i1], name2, data2.files[i2],
X			       depth + 1);
X	  i1++, i2++;
X	}
X      if (nameorder < 0)
X	{
X	  /* Next filename in dir 1 is less; that is a file in dir 1 only.  */
X	  v1 = (*handle_file) (name1, data1.files[i1], name2, 0, depth + 1);
X	  i1++;
X	}
X      if (nameorder > 0)
X	{
X	  /* Next filename in dir 2 is less; that is a file in dir 2 only.  */
X	  v1 = (*handle_file) (name1, 0, name2, data2.files[i2], depth + 1);
X	  i2++;
X	}
X      if (v1 > val)
X	val = v1;
X    }
X  if (data1.files)
X    free (data1.files);
X  if (data2.files)
X    free (data2.files);
X
X  return val;
X}
END_OF_FILE
if test 5765 -ne `wc -c <'dir.c'`; then
    echo shar: \"'dir.c'\" unpacked with wrong size!
fi
# end of 'dir.c'
fi
if test -f 'ed.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ed.c'\"
else
echo shar: Extracting \"'ed.c'\" \(5254 characters\)
sed "s/^X//" >'ed.c' <<'END_OF_FILE'
X/* Output routines for ed-script format.
X   Copyright (C) 1988, 1989 Free Software Foundation, Inc.
X
XThis file is part of GNU DIFF.
X
XGNU DIFF is free software; you can redistribute it and/or modify
Xit under the terms of the GNU General Public License as published by
Xthe Free Software Foundation; either version 1, or (at your option)
Xany later version.
X
XGNU DIFF is distributed in the hope that it will be useful,
Xbut WITHOUT ANY WARRANTY; without even the implied warranty of
XMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
XGNU General Public License for more details.
X
XYou should have received a copy of the GNU General Public License
Xalong with GNU DIFF; see the file COPYING.  If not, write to
Xthe Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
X
X#include "diff.h"
X
Xstatic void print_rcs_hunk ();
Xstatic void print_ed_hunk ();
Xstatic void pr_forward_ed_hunk ();
Xvoid translate_range ();
Xstruct change *find_change ();
Xstruct change *find_reverse_change ();
X
X/* Print our script as ed commands.  */
X
Xvoid
Xprint_ed_script (script)
X    struct change *script;
X{
X  print_script (script, find_reverse_change, print_ed_hunk);
X}
X
X/* Print a hunk of an ed diff */
X
Xstatic void
Xprint_ed_hunk (hunk)
X     struct change *hunk; 
X{
X  int f0, l0, f1, l1;
X  int deletes, inserts;
X
X#if 0
X  hunk = flip_script (hunk);
X#endif
X#ifdef DEBUG
X  debug_script (hunk);
X#endif
X
X  /* Determine range of line numbers involved in each file.  */
X  analyze_hunk (hunk, &f0, &l0, &f1, &l1, &deletes, &inserts);
X  if (!deletes && !inserts)
X    return;
X
X  /* Print out the line number header for this hunk */
X  print_number_range (',', &files[0], f0, l0);
X  fprintf (outfile, "%c\n", change_letter (inserts, deletes));
X
X  /* Print new/changed lines from second file, if needed */
X  if (inserts)
X    {
X      int i;
X      int inserting = 1;
X      for (i = f1; i <= l1; i++)
X	{
X	  /* Resume the insert, if we stopped.  */
X	  if (! inserting)
X	    fprintf (outfile, "%da\n",
X		     i - f1 + translate_line_number (&files[0], f0) - 1);
X	  inserting = 1;
X
X	  /* If the file's line is just a dot, it would confuse `ed'.
X	     So output it with a double dot, and set the flag LEADING_DOT
X	     so that we will output another ed-command later
X	     to change the double dot into a single dot.  */
X
X	  if (files[1].linbuf[i].text[0] == '.'
X	      && files[1].linbuf[i].text[1] == '\n')
X	    {
X	      fprintf (outfile, "..\n");
X	      fprintf (outfile, ".\n");
X	      /* Now change that double dot to the desired single dot.  */
X	      fprintf (outfile, "%ds/^\\.\\././\n",
X		       i - f1 + translate_line_number (&files[0], f0));
X	      inserting = 0;
X	    }
X	  else
X	    /* Line is not `.', so output it unmodified.  */
X	    print_1_line ("", &files[1].linbuf[i]);
X	}
X
X      /* End insert mode, if we are still in it.  */
X      if (inserting)
X	fprintf (outfile, ".\n");
X    }
X}
X
X/* Print change script in the style of ed commands,
X   but print the changes in the order they appear in the input files,
X   which means that the commands are not truly useful with ed.  */
X
Xvoid
Xpr_forward_ed_script (script)
X     struct change *script;
X{
X  print_script (script, find_change, pr_forward_ed_hunk);
X}
X
Xstatic void
Xpr_forward_ed_hunk (hunk)
X     struct change *hunk;
X{
X  int i;
X  int f0, l0, f1, l1;
X  int deletes, inserts;
X
X  /* Determine range of line numbers involved in each file.  */
X  analyze_hunk (hunk, &f0, &l0, &f1, &l1, &deletes, &inserts);
X  if (!deletes && !inserts)
X    return;
X
X  fprintf (outfile, "%c", change_letter (inserts, deletes));
X  print_number_range (' ', files, f0, l0);
X  fprintf (outfile, "\n");
X
X  /* If deletion only, print just the number range.  */
X
X  if (!inserts)
X    return;
X
X  /* For insertion (with or without deletion), print the number range
X     and the lines from file 2.  */
X
X  for (i = f1; i <= l1; i++)
X    print_1_line ("", &files[1].linbuf[i]);
X
X  fprintf (outfile, ".\n");
X}
X
X/* Print in a format somewhat like ed commands
X   except that each insert command states the number of lines it inserts.
X   This format is used for RCS.  */
X
Xvoid
Xprint_rcs_script (script)
X     struct change *script;
X{
X  print_script (script, find_change, print_rcs_hunk);
X}
X
X/* Print a hunk of an RCS diff */
X
Xstatic void
Xprint_rcs_hunk (hunk)
X     struct change *hunk;
X{
X  int i;
X  int f0, l0, f1, l1;
X  int deletes, inserts;
X  int tf0, tl0, tf1, tl1;
X
X  /* Determine range of line numbers involved in each file.  */
X  analyze_hunk (hunk, &f0, &l0, &f1, &l1, &deletes, &inserts);
X  if (!deletes && !inserts)
X    return;
X
X  translate_range (&files[0], f0, l0, &tf0, &tl0);
X
X  if (deletes)
X    {
X      fprintf (outfile, "d");
X      /* For deletion, print just the starting line number from file 0
X	 and the number of lines deleted.  */
X      fprintf (outfile, "%d %d\n",
X	       tf0,
X	       (tl0 >= tf0 ? tl0 - tf0 + 1 : 1));	     
X    }
X
X  if (inserts)
X    {
X      fprintf (outfile, "a");
X
X      /* Take last-line-number from file 0 and # lines from file 1.  */
X      translate_range (&files[1], f1, l1, &tf1, &tl1);
X      fprintf (outfile, "%d %d\n",
X	       tl0,
X	       (tl1 >= tf1 ? tl1 - tf1 + 1 : 1));	     
X
X      /* Print the inserted lines.  */
X      for (i = f1; i <= l1; i++)
X	print_1_line ("", &files[1].linbuf[i]);
X    }
X}
END_OF_FILE
if test 5254 -ne `wc -c <'ed.c'`; then
    echo shar: \"'ed.c'\" unpacked with wrong size!
fi
# end of 'ed.c'
fi
if test -f 'getopt.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getopt.h'\"
else
echo shar: Extracting \"'getopt.h'\" \(3554 characters\)
sed "s/^X//" >'getopt.h' <<'END_OF_FILE'
X/* declarations for getopt
X   Copyright (C) 1989, 1990 Free Software Foundation, Inc.
X
X   This program is free software; you can redistribute it and/or modify
X   it under the terms of the GNU General Public License as published by
X   the Free Software Foundation; either version 1, or (at your option)
X   any later version.
X
X   This program is distributed in the hope that it will be useful,
X   but WITHOUT ANY WARRANTY; without even the implied warranty of
X   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X   GNU General Public License for more details.
X
X   You should have received a copy of the GNU General Public License
X   along with this program; if not, write to the Free Software
X   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
X
X/* For communication from `getopt' to the caller.
X   When `getopt' finds an option that takes an argument,
X   the argument value is returned here.
X   Also, when `ordering' is RETURN_IN_ORDER,
X   each non-option ARGV-element is returned here.  */
X
Xextern char *optarg;
X
X/* Index in ARGV of the next element to be scanned.
X   This is used for communication to and from the caller
X   and for communication between successive calls to `getopt'.
X
X   On entry to `getopt', zero means this is the first call; initialize.
X
X   When `getopt' returns EOF, this is the index of the first of the
X   non-option elements that the caller should itself scan.
X
X   Otherwise, `optind' communicates from one call to the next
X   how much of ARGV has been scanned so far.  */
X
Xextern int optind;
X
X/* Callers store zero here to inhibit the error message `getopt' prints
X   for unrecognized options.  */
X
Xextern int opterr;
X
X/* Describe the long-named options requested by the application.
X   _GETOPT_LONG_OPTIONS is a vector of `struct option' terminated by an
X   element containing a name which is zero.
X
X   The field `has_arg' is:
X   0 if the option does not take an argument,
X   1 if the option requires an argument,
X   2 if the option takes an optional argument.
X
X   If the field `flag' is nonzero, it points to a variable that is set
X   to the value given in the field `val' when the option is found, but
X   left unchanged if the option is not found.
X
X   To have a long-named option do something other than set an `int' to
X   a compiled-in constant, such as set a value from `optarg', set the
X   option's `flag' field to zero and its `val' field to a nonzero
X   value (the equivalent single-letter option character, if there is
X   one).  For long options that have a zero `flag' field, `getopt'
X   returns the contents of the `val' field.  */
X
Xstruct option
X{
X  char *name;
X  int has_arg;
X  int *flag;
X  int val;
X};
X
X#ifdef __STDC__
Xextern const struct option *_getopt_long_options;
X#else
Xextern struct option *_getopt_long_options;
X#endif
X
X/* If nonzero, '-' can introduce long-named options.
X   Set by getopt_long_only.  */
X
Xextern int _getopt_long_only;
X
X/* The index in GETOPT_LONG_OPTIONS of the long-named option found.
X   Only valid when a long-named option has been found by the most
X   recent call to `getopt'.  */
X
Xextern int option_index;
X
X#ifdef __STDC__
Xint getopt (int argc, char **argv, const char *shortopts);
Xint getopt_long (int argc, char **argv, const char *shortopts,
X		 const struct option *longopts, int *longind);
Xint getopt_long_only (int argc, char **argv, const char *shortopts,
X		      const struct option *longopts, int *longind);
Xvoid envopt(int *pargc, char ***pargv, char *optstr);
X#else
Xint getopt ();
Xint getopt_long ();
Xint getopt_long_only ();
Xvoid envopt();
X#endif
END_OF_FILE
if test 3554 -ne `wc -c <'getopt.h'`; then
    echo shar: \"'getopt.h'\" unpacked with wrong size!
fi
# end of 'getopt.h'
fi
if test -f 'getopt1.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getopt1.c'\"
else
echo shar: Extracting \"'getopt1.c'\" \(3388 characters\)
sed "s/^X//" >'getopt1.c' <<'END_OF_FILE'
X/* Getopt for GNU.
X   Copyright (C) 1987, 1989 Free Software Foundation, Inc.
X
X   This program is free software; you can redistribute it and/or modify
X   it under the terms of the GNU General Public License as published by
X   the Free Software Foundation; either version 1, or (at your option)
X   any later version.
X
X   This program is distributed in the hope that it will be useful,
X   but WITHOUT ANY WARRANTY; without even the implied warranty of
X   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X   GNU General Public License for more details.
X
X   You should have received a copy of the GNU General Public License
X   along with this program; if not, write to the Free Software
X   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
X
X#include "getopt.h"
X
X#ifdef __STDC__
X#define CONST const
X#else
X#define CONST
X#endif
X
X#if !defined (NULL)
X#define NULL 0
X#endif
X
Xint
Xgetopt_long (argc, argv, options, long_options, opt_index)
X     int argc;
X     char **argv;
X     CONST char *options;
X     CONST struct option *long_options;
X     int *opt_index;
X{
X  int val;
X
X  _getopt_long_options = long_options;
X  val = getopt (argc, argv, options);
X  if (val == 0 && opt_index != NULL)
X    *opt_index = option_index;
X  return val;
X}
X
X/* Like getopt_long, but '-' as well as '+' can indicate a long option.
X   If an option that starts with '-' doesn't match a long option,
X   but does match a short option, it is parsed as a short option
X   instead. */
X
Xint 
Xgetopt_long_only (argc, argv, options, long_options, opt_index)
X     int argc;
X     char **argv;
X     CONST char *options;
X     CONST struct option *long_options;
X     int *opt_index;
X{
X  int val;
X
X  _getopt_long_options = long_options;
X  _getopt_long_only = 1;
X  val = getopt (argc, argv, options);
X  if (val == 0 && opt_index != NULL)
X    *opt_index = option_index;
X  return val;
X}
X
X
X#ifdef TEST
X
X#include <stdio.h>
X
Xint
Xmain (argc, argv)
X     int argc;
X     char **argv;
X{
X  int c;
X  int digit_optind = 0;
X
X  while (1)
X    {
X      int this_option_optind = optind ? optind : 1;
X      char *name = '\0';
X      int option_index = 0;
X      static struct option long_options[] =
X      {
X	{"add", 1, 0, 0},
X	{"append", 0, 0, 0},
X	{"delete", 1, 0, 0},
X	{"verbose", 0, 0, 0},
X	{"create", 0, 0, 0},
X	{"file", 1, 0, 0},
X	{0, 0, 0, 0}
X      };
X
X      c = getopt_long (argc, argv, "abc:d:0123456789",
X		       long_options, &option_index);
X      if (c == EOF)
X	break;
X
X      switch (c)
X	{
X	case 0:
X	  printf ("option %s", (long_options[option_index]).name);
X	  if (optarg)
X	    printf (" with arg %s", optarg);
X	  printf ("\n");
X	  break;
X
X	case '0':
X	case '1':
X	case '2':
X	case '3':
X	case '4':
X	case '5':
X	case '6':
X	case '7':
X	case '8':
X	case '9':
X	  if (digit_optind != 0 && digit_optind != this_option_optind)
X	    printf ("digits occur in two different argv-elements.\n");
X	  digit_optind = this_option_optind;
X	  printf ("option %c\n", c);
X	  break;
X
X	case 'a':
X	  printf ("option a\n");
X	  break;
X
X	case 'b':
X	  printf ("option b\n");
X	  break;
X
X	case 'c':
X	  printf ("option c with value `%s'\n", optarg);
X	  break;
X
X	case '?':
X	  break;
X
X	default:
X	  printf ("?? getopt returned character code 0%o ??\n", c);
X	}
X    }
X
X  if (optind < argc)
X    {
X      printf ("non-option ARGV-elements: ");
X      while (optind < argc)
X	printf ("%s ", argv[optind++]);
X      printf ("\n");
X    }
X
X  exit (0);
X}
X
X#endif /* TEST */
END_OF_FILE
if test 3388 -ne `wc -c <'getopt1.c'`; then
    echo shar: \"'getopt1.c'\" unpacked with wrong size!
fi
# end of 'getopt1.c'
fi
if test -f 'ifdef.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ifdef.c'\"
else
echo shar: Extracting \"'ifdef.c'\" \(2564 characters\)
sed "s/^X//" >'ifdef.c' <<'END_OF_FILE'
X/* #ifdef-format output routines for GNU DIFF.
X   Copyright (C) 1989 Free Software Foundation, Inc.
X
XThis file is part of GNU DIFF.
X
XGNU DIFF is distributed in the hope that it will be useful,
Xbut WITHOUT ANY WARRANTY.  No author or distributor
Xaccepts responsibility to anyone for the consequences of using it
Xor for whether it serves any particular purpose or works at all,
Xunless he says so in writing.  Refer to the GNU DIFF General Public
XLicense for full details.
X
XEveryone is granted permission to copy, modify and redistribute
XGNU DIFF, but only under the conditions described in the
XGNU DIFF General Public License.   A copy of this license is
Xsupposed to have been given to you along with GNU DIFF so you
Xcan know your rights and responsibilities.  It should be in a
Xfile named COPYING.  Among other things, the copyright notice
Xand this notice must be preserved on all copies.  */
X
X
X#include "diff.h"
X
Xstatic void print_ifdef_hunk ();
Xstruct change *find_change ();
X
Xstatic int next_line;
X
X/* Print the edit-script SCRIPT as a merged #ifdef file.  */
X
Xvoid
Xprint_ifdef_script (script)
X     struct change *script;
X{
X  next_line = 0;
X  print_script (script, find_change, print_ifdef_hunk);
X  while (next_line < files[0].buffered_lines)
X    print_1_line ("", &files[0].linbuf[next_line++]);
X}
X
X/* Print a hunk of an ifdef diff.
X   This is a contiguous portion of a complete edit script,
X   describing changes in consecutive lines.  */
X
Xstatic void
Xprint_ifdef_hunk (hunk)
X     struct change *hunk;
X{
X  int first0, last0, first1, last1, deletes, inserts;
X  register int i;
X
X  /* Determine range of line numbers involved in each file.  */
X  analyze_hunk (hunk, &first0, &last0, &first1, &last1, &deletes, &inserts);
X  if (!deletes && !inserts)
X    return;
X
X  /* Print out lines up to this change.  */
X  while (next_line < first0)
X    print_1_line ("", &files[0].linbuf[next_line++]);
X
X  /* Print out stuff deleted from first file.  */
X  if (deletes)
X    {
X      fprintf (outfile, "#ifndef %s\n", ifdef_string);
X      for (i = first0; i <= last0; i++)
X	print_1_line ("", &files[0].linbuf[i]);
X      next_line = i;
X    }
X
X  /* Print out stuff inserted from second file.  */
X  if (inserts)
X    {
X      if (deletes)
X	fprintf (outfile, "#else /* %s */\n", ifdef_string);
X      else
X	fprintf (outfile, "#ifdef %s\n", ifdef_string);
X      for (i = first1; i <= last1; i++)
X	print_1_line ("", &files[1].linbuf[i]);
X    }
X
X  if (inserts)
X    fprintf (outfile, "#endif /* %s */\n", ifdef_string);
X  else
X    fprintf (outfile, "#endif /* not %s */\n", ifdef_string);
X}
END_OF_FILE
if test 2564 -ne `wc -c <'ifdef.c'`; then
    echo shar: \"'ifdef.c'\" unpacked with wrong size!
fi
# end of 'ifdef.c'
fi
if test -f 'limits.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'limits.h'\"
else
echo shar: Extracting \"'limits.h'\" \(1170 characters\)
sed "s/^X//" >'limits.h' <<'END_OF_FILE'
X/* Number of bits in a `char'.  */
X#define CHAR_BIT 8
X
X/* No multibyte characters supported yet.  */
X#define MB_LEN_MAX 1
X
X/* Minimum and maximum values a `signed char' can hold.  */
X#define SCHAR_MIN (-128)
X#define SCHAR_MAX 127
X
X/* Maximum value an `unsigned char' can hold.  (Minimum is 0).  */
X#define UCHAR_MAX 255U
X
X/* Minimum and maximum values a `char' can hold.  */
X#ifdef __CHAR_UNSIGNED__
X#define CHAR_MIN 0
X#define CHAR_MAX 255U
X#else
X#define CHAR_MIN (-128)
X#define CHAR_MAX 127
X#endif
X
X/* Minimum and maximum values a `signed short int' can hold.  */
X#define SHRT_MIN (-32768)
X#define SHRT_MAX 32767
X
X/* Maximum value an `unsigned short int' can hold.  (Minimum is 0).  */
X#define USHRT_MAX 65535U
X
X/* Minimum and maximum values a `signed int' can hold.  */
X#define INT_MIN (-INT_MAX-1)
X#define INT_MAX 2147483647
X
X/* Maximum value an `unsigned int' can hold.  (Minimum is 0).  */
X#define UINT_MAX 4294967295U
X
X/* Minimum and maximum values a `signed long int' can hold.
X   (Same as `int').  */
X#define LONG_MIN (-LONG_MAX-1)
X#define LONG_MAX 2147483647
X
X/* Maximum value an `unsigned long int' can hold.  (Minimum is 0).  */
X#define ULONG_MAX 4294967295U
END_OF_FILE
if test 1170 -ne `wc -c <'limits.h'`; then
    echo shar: \"'limits.h'\" unpacked with wrong size!
fi
# end of 'limits.h'
fi
if test -f 'normal.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'normal.c'\"
else
echo shar: Extracting \"'normal.c'\" \(2210 characters\)
sed "s/^X//" >'normal.c' <<'END_OF_FILE'
X/* Normal-format output routines for GNU DIFF.
X   Copyright (C) 1988, 1989 Free Software Foundation, Inc.
X
XThis file is part of GNU DIFF.
X
XGNU DIFF is free software; you can redistribute it and/or modify
Xit under the terms of the GNU General Public License as published by
Xthe Free Software Foundation; either version 1, or (at your option)
Xany later version.
X
XGNU DIFF is distributed in the hope that it will be useful,
Xbut WITHOUT ANY WARRANTY; without even the implied warranty of
XMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
XGNU General Public License for more details.
X
XYou should have received a copy of the GNU General Public License
Xalong with GNU DIFF; see the file COPYING.  If not, write to
Xthe Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
X
X
X#include "diff.h"
X
Xvoid print_normal_hunk ();
Xvoid print_number_range ();
Xstruct change *find_change ();
X
X/* Print the edit-script SCRIPT as a normal diff.
X   INF points to an array of descriptions of the two files.  */
X
Xvoid
Xprint_normal_script (script)
X     struct change *script;
X{
X  print_script (script, find_change, print_normal_hunk);
X}
X
X/* Print a hunk of a normal diff.
X   This is a contiguous portion of a complete edit script,
X   describing changes in consecutive lines.  */
X
Xvoid
Xprint_normal_hunk (hunk)
X     struct change *hunk;
X{
X  int first0, last0, first1, last1, deletes, inserts;
X  register int i;
X
X  /* Determine range of line numbers involved in each file.  */
X  analyze_hunk (hunk, &first0, &last0, &first1, &last1, &deletes, &inserts);
X  if (!deletes && !inserts)
X    return;
X
X  /* Print out the line number header for this hunk */
X  print_number_range (',', &files[0], first0, last0);
X  fprintf (outfile, "%c", change_letter (inserts, deletes));
X  print_number_range (',', &files[1], first1, last1);
X  fprintf (outfile, "\n");
X
X  /* Print the lines that the first file has.  */
X  if (deletes)
X    for (i = first0; i <= last0; i++)
X      print_1_line ("<", &files[0].linbuf[i]);
X
X  if (inserts && deletes)
X    fprintf (outfile, "---\n");
X
X  /* Print the lines that the second file has.  */
X  if (inserts)
X    for (i = first1; i <= last1; i++)
X      print_1_line (">", &files[1].linbuf[i]);
X}
END_OF_FILE
if test 2210 -ne `wc -c <'normal.c'`; then
    echo shar: \"'normal.c'\" unpacked with wrong size!
fi
# end of 'normal.c'
fi
if test -f 'version.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'version.c'\"
else
echo shar: Extracting \"'version.c'\" \(67 characters\)
sed "s/^X//" >'version.c' <<'END_OF_FILE'
X/* Version number of GNU diff.  */
X
Xchar *version_string = "1.15";
END_OF_FILE
if test 67 -ne `wc -c <'version.c'`; then
    echo shar: \"'version.c'\" unpacked with wrong size!
fi
# end of 'version.c'
fi
echo shar: End of archive 1 \(of 8\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
