Subject:  v24i011:  RCS source control system, Part11/12
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: 81d70358 332833e3 6de9a4de 150fc7c3

Submitted-by: Adam Hammer <hammer@cs.purdue.edu>
Posting-number: Volume 24, Issue 11
Archive-name: rcs/part11

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  man/merge.1 man/rcs.1 man/rcsclean.1 man/rcsdiff.1
#   man/rcsfile.5 man/rcsmerge.1 rcs.ms.02 src/conf.heg src/ident.c
#   src/merge.sh src/rcsfreeze.sh src/rcsmap.c
# Wrapped by rsalz@litchi.bbn.com on Thu Feb 21 14:37:11 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 11 (of 12)."'
if test -f 'man/merge.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/merge.1'\"
else
  echo shar: Extracting \"'man/merge.1'\" \(1637 characters\)
  sed "s/^X//" >'man/merge.1' <<'END_OF_FILE'
X.de Id
X.ds Rv \\$3
X.ds Dt \\$4
X..
X.Id $Id: merge.1,v 5.1 1990/08/29 07:12:59 eggert Exp $
X.TH MERGE 1 \*(Dt GNU
X.SH NAME
Xmerge \- three-way file merge
X.SH SYNOPSIS
X.B merge
X[
X.B \-L
X.I label1
X[
X.B \-L
X.I label3
X] ] [
X.B \-p
X] [
X.B \-q
X]
X.I "file1 file2 file3"
X.SH DESCRIPTION
X.B merge
Xincorporates all changes that lead from
X.I file2
Xto
X.I file3
Xinto
X.IR file1 .
XThe result goes to standard output if
X.B \-p
Xis present, into
X.I file1
Xotherwise.
X.B merge
Xis useful for combining separate changes to an original.  Suppose
X.I file2
Xis the original, and both
X.I file1
Xand
X.I file3
Xare modifications of
X.IR file2 .
XThen
X.B merge
Xcombines both changes.
X.PP
XAn overlap occurs if both
X.I file1
Xand
X.I file3
Xhave changes in a common segment of lines.
X.B merge
Xoutputs a message if overlaps occurred,
Xand includes both alternatives
Xin the result.  The alternatives are delimited as follows:
X.LP
X.RS
X.nf
X.BI <<<<<<< " file1"
X.I "lines in file1"
X.B "======="
X.I "lines in file3"
X.BI >>>>>>> " file3"
X.RE
X.fi
X.LP
XIf there are overlaps, the user should edit the result and delete one of the
Xalternatives.
XIf the
X.BI \-L "\ label1"
Xand
X.BI \-L "\ label3"
Xoptions are given, the labels are output in place of the names
X.I file1
Xand
X.I file3
Xin overlap reports.
XAny overlap message is suppressed if the
X.B \-q
Xoption is given.
X.SH DIAGNOSTICS
XExit status is 0 for no overlaps, 1 for some overlaps, 2 for trouble.
X.SH IDENTIFICATION
XAuthor: Walter F. Tichy.
X.br
XRevision Number: \*(Rv; Release Date: \*(Dt.
X.br
XCopyright \(co 1982, 1988, 1989 by Walter F. Tichy.
X.br
XCopyright \(co 1990 by Paul Eggert.
X.SH SEE ALSO
Xdiff3(1), diff(1), rcsmerge(1), co(1).
END_OF_FILE
  if test 1637 -ne `wc -c <'man/merge.1'`; then
    echo shar: \"'man/merge.1'\" unpacked with wrong size!
  fi
  # end of 'man/merge.1'
fi
if test -f 'man/rcs.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/rcs.1'\"
else
  echo shar: Extracting \"'man/rcs.1'\" \(7061 characters\)
  sed "s/^X//" >'man/rcs.1' <<'END_OF_FILE'
X.de Id
X.ds Rv \\$3
X.ds Dt \\$4
X..
X.Id $Id: rcs.1,v 5.3 1990/12/04 05:18:34 eggert Exp $
X.ds r \s-1RCS\s0
X.if n .ds - \%--
X.if t .ds - \(em
X.TH RCS 1 \*(Dt GNU
X.SH NAME
Xrcs \- change RCS file attributes
X.SH SYNOPSIS
X.B rcs
X.RI [ " options " ] " file " .\|.\|.
X.SH DESCRIPTION
X.B rcs
Xcreates new \*r files or changes attributes of existing ones.
XAn \*r file contains multiple revisions of text,
Xan access list, a change log,
Xdescriptive text,
Xand some control attributes.
XFor
X.B rcs
Xto work, the caller's login name must be on the access list,
Xexcept if the access list is empty, the caller is the owner of the file
Xor the superuser, or
Xthe
X.B \-i
Xoption is present.
X.PP
XFile names ending in
X.B ,v
Xdenote \*r files; all others denote working files.
XIf a working file is given,
X.B rcs
Xtries to find the corresponding \*r file first in an \*r subdirectory
Xand then in the working file's directory,
Xas explained in
X.BR co (1).
X.SH OPTIONS
X.TP
X.B \-i
XCreate and initialize a new \*r file, but do not deposit any revision.
XIf the \*r file has no path prefix, try to place it
Xfirst into the subdirectory
X.BR ./RCS ,
Xand then into the current directory.
XIf the \*r file
Xalready exists, print an error message.
X.TP
X.BI \-a "logins"
XAppend the login names appearing in the comma-separated list
X.I logins
Xto the access list of the \*r file.
X.TP
X.BI \-A "oldfile"
XAppend the access list of
X.I oldfile
Xto the access list of the \*r file.
X.TP
X.BR \-e [\f2logins\fP]
XErase the login names appearing in the comma-separated list
X.I logins
Xfrom the access list of the \*r file.
XIf
X.I logins
Xis omitted, erase the entire access list.
X.TP
X.BR \-b [\f2rev\fP]
XSet the default branch to
X.IR rev .
XIf
X.I rev
Xis omitted, the default
Xbranch is reset to the (dynamically) highest branch on the trunk.
X.TP
X.BI \-c string
Xsets the comment leader to
X.IR string .
XThe comment leader
Xis printed before every log message line generated by the keyword
X.B $\&Log$
Xduring checkout (see
X.BR co (1)).
XThis is useful for programming
Xlanguages without multi-line comments.
XAn initial
X.B ci ,
Xor an
X.B "rcs\ \-i"
Xwithout
X.BR \-c ,
Xguesses the comment leader from the suffix of the working file.
X.TP
X.BI \-k subst
XSet the default keyword substitution to
X.IR subst .
XThe effect of keyword substitution is described in
X.BR co (1).
XGiving an explicit
X.B \-k
Xoption to
X.BR co ,
X.BR rcsdiff ,
Xand
X.B rcsmerge
Xoverrides this default.
XBeware
X.BR "rcs\ \-kv",
Xbecause
X.B \-kv
Xis incompatible with
X.BR "co\ \-l".
XUse
X.B "rcs\ \-kkv"
Xto restore the normal default keyword substitution.
X.TP
X.BR \-l [\f2rev\fP]
XLock the revision with number
X.IR rev .
XIf a branch is given, lock the latest revision on that branch.
XIf
X.I rev
Xis omitted, lock the latest revision on the default branch.
XLocking prevents overlapping changes.
XA lock is removed with
X.B ci
Xor
X.B "rcs\ \-u"
X(see below).
X.TP
X.BR \-u [\f2rev\fP]
XUnlock the revision with number
X.IR rev .
XIf a branch is given, unlock the latest revision on that branch.
XIf
X.I rev
Xis omitted, remove the latest lock held by the caller.
XNormally, only the locker of a revision may unlock it.
XSomebody else unlocking a revision breaks the lock.
XThis causes a mail message to be sent to the original locker.
XThe message contains a commentary solicited from the breaker.
XThe commentary is terminated by end-of-file or by a line containing
X.BR \&. "\ by"
Xitself.
X.TP
X.B \-L
XSet locking to
X.IR strict .
XStrict locking means that the owner
Xof an \*r file is not exempt from locking for checkin.
XThis option should be used for files that are shared.
X.TP
X.B \-U
XSet locking to non-strict.  Non-strict locking means that the owner of
Xa file need not lock a revision for checkin.
XThis option should
X.I not
Xbe used for files that are shared.
XWhether default locking is strict is determined by your system administrator,
Xbut it is normally strict.
X.TP
X.B \-n\f2name\fP\f1[\fP:\f2rev\fP\f1]\fP
XAssociate the symbolic name
X.I name
Xwith the branch or
Xrevision
X.IR rev .
XPrint an error message if
X.I name
Xis already associated with
Xanother number.
XIf
X.I rev
Xis omitted, the symbolic name is deleted.
X.TP
X.B \-N\f2name\fP\f1[\fP:\f2rev\fP\f1]\fP
XAct like
X.BR \-n ,
Xexcept override any previous assignment of
X.IR name .
X.TP
X.BI \-o range
Xdeletes (\*(lqoutdates\*(rq) the revisions given by
X.IR range .
XA range consisting of a single revision number means that revision.
XA range consisting of a branch number means the latest revision on that
Xbranch.
XA range of the form
X.IB rev1 \- rev2
Xmeans
Xrevisions
X.I rev1
Xto
X.I rev2
Xon the same branch,
X.BI \- rev
Xmeans from the beginning of the branch containing
X.I rev
Xup to and including
X.IR rev ,
Xand
X.IB rev \-
Xmeans
Xfrom revision
X.I rev
Xto the end of the branch containing
X.IR rev .
XNone of the outdated revisions may have branches or locks.
X.TP
X.B \-q
XRun quietly; do not print diagnostics.
X.TP
X.B \-I
XRun interactively, even if the standard input is not a terminal.
X.TP
X.B \-s\f2state\fP\f1[\fP:\f2rev\fP\f1]\fP
XSet the state attribute of the revision
X.I rev
Xto
X.I state .
XIf
X.I rev
Xis a branch number, assume the latest revision on that branch.
XIf
X.I rev
Xis omitted, assume the latest revision on the default branch.
XAny identifier is acceptable for
X.IR state .
XA useful set of states
Xis
X.B Exp
X(for experimental),
X.B Stab
X(for stable), and
X.B Rel
X(for
Xreleased).
XBy default,
X.BR ci (1)
Xsets the state of a revision to
X.BR Exp .
X.TP
X.BR \-t [\f2file\fP]
XWrite descriptive text from the contents of the named
X.I file
Xinto the \*r file, deleting the existing text.
XThe
X.IR file
Xname may not begin with
X.BR \- .
XIf
X.I file
Xis omitted, obtain the text from standard input,
Xterminated by end-of-file or by a line containing
X.BR \&. "\ by"
Xitself.
XPrompt for the text if interaction is possible; see
X.BR \-I .
XWith
X.BR \-i ,
Xdescriptive text is obtained
Xeven if
X.B \-t
Xis not given.
X.TP
X.BI \-t\- string
XWrite descriptive text from the
X.I string
Xinto the \*r file, deleting the existing text.
X.TP
X.BI \-V n
XEmulate \*r version
X.IR n .
XSee
X.BR co (1)
Xfor details.
X.SH COMPATIBILITY
XThe
X.BI \-b rev
Xoption generates an \*r file that cannot be parsed by \*r version 3 or earlier.
X.PP
XThe
X.BI \-k subst
Xoptions (except
X.BR \-kkv )
Xgenerate an \*r file that cannot be parsed by \*r version 4 or earlier.
X.PP
XUse
X.BI "rcs \-V" n
Xto make an \*r file acceptable to \*r version
X.I n
Xby discarding information that would confuse version
X.IR n .
X.SH DIAGNOSTICS
XThe \*r file name and the revisions outdated are written to
Xthe diagnostic output.
XThe exit status is zero if and only if all operations were successful.
X.SH FILES
X.B rcs
Xaccesses files much as
X.BR ci (1)
Xdoes,
Xexcept that it does not need to access the working file or its directory.
X.SH IDENTIFICATION
XAuthor: Walter F. Tichy.
X.br
XRevision Number: \*(Rv; Release Date: \*(Dt.
X.br
XCopyright \(co 1982, 1988, 1989 by Walter F. Tichy.
X.br
XCopyright \(co 1990 by Paul Eggert.
X.SH "SEE ALSO"
Xco(1), ci(1), ident(1), rcsdiff(1), rcsintro(1), rcsmerge(1), rlog(1),
Xrcsfile(5)
X.br
XWalter F. Tichy,
X\*r\*-A System for Version Control,
X.I "Software\*-Practice & Experience"
X.BR 15 ,
X7 (July 1985), 637-654.
END_OF_FILE
  if test 7061 -ne `wc -c <'man/rcs.1'`; then
    echo shar: \"'man/rcs.1'\" unpacked with wrong size!
  fi
  # end of 'man/rcs.1'
fi
if test -f 'man/rcsclean.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/rcsclean.1'\"
else
  echo shar: Extracting \"'man/rcsclean.1'\" \(2172 characters\)
  sed "s/^X//" >'man/rcsclean.1' <<'END_OF_FILE'
X.de Id
X.ds Rv \\$3
X.ds Dt \\$4
X..
X.Id $Id: rcsclean.1,v 1.4 1990/11/02 19:33:11 hammer Exp $
X.ds r \s-1RCS\s0
X.if n .ds - \%--
X.if t .ds - \(em
X.TH RCSCLEAN 1 \*(Dt GNU
X.SH NAME
Xrcsclean \- clean up working files
X.SH SYNOPSIS
X.B rcsclean
X.RI [ "rcsdiff options" ]
X.RI [ file "\ .\|.\|.\ ]"
X.SH DESCRIPTION
X.B rcsclean
Xremoves working files that were checked out and never modified.
XFor each file given, 
X.B rcsclean
Xcompares the working file and a revision in the corresponding
X\*r file. If it finds no difference, it removes the working file, and,
Xif the revision was locked, unlocks the revision.
X.PP
XIf no
X.I file
Xis given, all working files in the current directory are cleaned.
XAny other options are passed along to
X.B rcsdiff
Xfor the comparison.
X.PP
X.B rcsclean
Xis useful for
X.B clean
Xtargets in Makefiles.
XSee also
X.BR rcsdiff (1),
Xwhich prints out the differences,
Xand
X.BR ci (1),
Xwhich
Xnormally asks whether to check in a file
Xif it was not changed.
X.SH EXAMPLES
X.LP
X.RS
X.ft 3
Xrcsclean  *.c  *.h
X.ft
X.RE
X.LP
Xremoves all working files ending in
X.B .c
Xor
X.B .h
Xthat were not changed
Xsince their checkout.
X.RS
X.ft 3
Xrcsclean
X.ft
X.RE
X.LP
Xremoves all working files in the current directory
Xthat were not changed since their checkout.
X.SH DIAGNOSTICS
XThe exit status is 0 if there were no differences in any file under \*r control,
X1 if there were differences, and 2 if there were errors.
X.SH IDENTIFICATION
XAuthor: Walter F. Tichy.
X.br
XRevision Number: \*(Rv; Release Date: \*(Dt.
X.br
XCopyright \(co 1982, 1988, 1989 by Walter F. Tichy.
X.br
XCopyright \(co 1990 by Paul Eggert.
X.SH "SEE ALSO"
Xci(1), co(1), ident(1), rcs(1), rcsdiff(1), rcsintro(1), rcsmerge(1), rlog(1),
Xrcsfile(5)
X.br
XWalter F. Tichy,
X\*r\*-A System for Version Control,
X.I "Software\*-Practice & Experience"
X.BR 15 ,
X7 (July 1985), 637-654.
X.SH BUGS
XRCS file names may not be given as arguments.
X.PP
XAny diagnostics generated by
X.B rcsdiff
Xwhen comparing files are discarded.
X.PP
XIf the latest revision is already unlocked,
Xand you have a lock on an earlier revision,
Xthe earlier revision is unlocked.
X.PP
X.B rcsclean
Xis just an optional example shell script, and should not be taken too seriously.
END_OF_FILE
  if test 2172 -ne `wc -c <'man/rcsclean.1'`; then
    echo shar: \"'man/rcsclean.1'\" unpacked with wrong size!
  fi
  # end of 'man/rcsclean.1'
fi
if test -f 'man/rcsdiff.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/rcsdiff.1'\"
else
  echo shar: Extracting \"'man/rcsdiff.1'\" \(2785 characters\)
  sed "s/^X//" >'man/rcsdiff.1' <<'END_OF_FILE'
X.de Id
X.ds Rv \\$3
X.ds Dt \\$4
X..
X.Id $Id: rcsdiff.1,v 5.2 1990/09/26 15:54:04 hammer Exp $
X.ds r \s-1RCS\s0
X.if n .ds - \%--
X.if t .ds - \(em
X.TH RCSDIFF 1 \*(Dt GNU
X.SH NAME
Xrcsdiff \- compare RCS revisions
X.SH SYNOPSIS
X.B rcsdiff
X[
X.BI \-k subst
X] [
X.B \-q
X] [
X.BI \-r rev1
X[
X.BI \-r rev2
X] ] [
X.BI \-V n
X] [
X.I "diff options"
X]
X.I "file .\|.\|."
X.SH DESCRIPTION
X.B rcsdiff
Xruns
X.BR diff (1)
Xto compare two revisions of each \*r file given.
XA file name ending in
X.B ,v
Xis an \*r file name, otherwise a
Xworking file name.
X.B rcsdiff
Xderives the working file name from the \*r
Xfile name and vice versa, as explained in
X.BR co (1).
XPairs consisting
Xof both an \*r and a working file name may also be specified.
X.PP
XThe option
X.B \-q
Xsuppresses diagnostic output.
XZero, one, or two revisions may be specified with
X.BR \-r .
XThe option
X.BI \-k subst
Xaffects keyword substitution when extracting
Xrevisions, as described in
X.BR co (1);
Xfor example,
X.B "\-kk\ \-r1.1\ \-r1.2"
Xignores differences in keyword values when comparing revisions
X.B 1.1
Xand
X.BR 1.2 .
XTo avoid excess output from locker name substitution,
X.B \-kkvl
Xis assumed if (1) at most one revision option is given,
X(2) no
X.B \-k
Xoption is given, (3)
X.B \-kkv
Xis the default keyword substitution, and
X(4) the working file's mode would be produced by
X.BR "co\ \-l".
XSee
X.BR co (1)
Xfor details
Xabout
X.BR \-V .
XOtherwise, all options of
X.BR diff (1)
Xthat apply to regular files are accepted, with the same meaning as for
X.BR diff .
X.PP
XIf both
X.I rev1
Xand
X.I rev2
Xare omitted,
X.B rcsdiff
Xcompares the latest revision on the
Xdefault branch (by default the trunk)
Xwith the contents of the corresponding working file.  This is useful
Xfor determining what you changed since the last checkin.
X.PP
XIf
X.I rev1
Xis given, but
X.I rev2
Xis omitted,
X.B rcsdiff
Xcompares revision
X.I rev1
Xof the \*r file with
Xthe contents of the corresponding working file.
X.PP
XIf both
X.I rev1
Xand
X.I rev2
Xare given,
X.B rcsdiff
Xcompares revisions
X.I rev1
Xand
X.I rev2
Xof the \*r file.
X.PP
XBoth
X.I rev1
Xand
X.I rev2
Xmay be given numerically or symbolically.
X.SH EXAMPLE
XThe command
X.LP
X.B "        rcsdiff  f.c"
X.LP
Xcompares the latest revision on the default branch of the \*r file
X.B RCS/f.c,v
Xto the contents of the working file
X.BR f.c .
X.SH DIAGNOSTICS
XExit status is 0 for no differences during any comparison,
X1 for some differences, 2 for trouble.
X.SH IDENTIFICATION
XAuthor: Walter F. Tichy.
X.br
XRevision Number: \*(Rv; Release Date: \*(Dt.
X.br
XCopyright \(co 1982, 1988, 1989 by Walter F. Tichy.
X.br
XCopyright \(co 1990 by Paul Eggert.
X.SH "SEE ALSO"
Xci(1), co(1), diff(1), ident(1), rcs(1), rcsintro(1), rcsmerge(1), rlog(1)
X.br
XWalter F. Tichy,
X\*r\*-A System for Version Control,
X.I "Software\*-Practice & Experience"
X.BR 15 ,
X7 (July 1985), 637-654.
END_OF_FILE
  if test 2785 -ne `wc -c <'man/rcsdiff.1'`; then
    echo shar: \"'man/rcsdiff.1'\" unpacked with wrong size!
  fi
  # end of 'man/rcsdiff.1'
fi
if test -f 'man/rcsfile.5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/rcsfile.5'\"
else
  echo shar: Extracting \"'man/rcsfile.5'\" \(6200 characters\)
  sed "s/^X//" >'man/rcsfile.5' <<'END_OF_FILE'
X.de Id
X.ds Rv \\$3
X.ds Dt \\$4
X..
X.Id $Id: rcsfile.5,v 5.0 1990/08/22 09:09:36 eggert Exp $
X.ds r \s-1RCS\s0
X.if n .ds - \%--
X.if t .ds - \(em
X.TH RCSFILE 5 \*(Dt GNU
X.SH NAME
Xrcsfile \- format of RCS file
X.SH DESCRIPTION
XAn \*r file's
Xcontents are described by the grammar
Xbelow.  The text is free format: space, backspace, tab, newline, vertical
Xtab, form feed, and carriage return (collectively,
X.IR "white space")
Xhave no significance except in strings.
XStrings are enclosed by
X.BR @ .
XIf a string contains a
X.BR @ ,
Xit must be doubled;
Xotherwise, strings may contain arbitrary binary data.
X.PP
XThe meta syntax uses the following conventions: `|' (bar) separates
Xalternatives; `{' and `}' enclose optional phrases; `{' and `}*' enclose
Xphrases that may be repeated zero or more times;
X`{' and '}+' enclose phrases that must appear at least once and may be
Xrepeated;
XTerminal symbols are in
X.BR boldface ;
Xnonterminal symbols are in
X.IR italics .
X.LP
X.nr x \w'\f3branches\fP'
X.nr y \w'{ \f3comment\fP'
X.if \nx<\ny .nr x \ny
X.nr y \w'\f3{ branch\fP'
X.if \nx<\ny .nr x \ny
X.ta \w'\f2deltatext\fP  'u +\w'::=  'u +\nxu+\w'  'u
X.fc ~
X.nf
X\f2rcstext\fP	::=	\f2admin\fP {\f2delta\fP}* \f2desc\fP {\f2deltatext\fP}*
X.LP
X\f2admin\fP	::=	\f3head\fP	{\f2num\fP}\f3;\fP
X		{ \f3branch\fP	{\f2num\fP}\f3;\fP }
X		\f3access\fP	{\f2id\fP}*\f3;\fP
X		\f3symbols\fP	{\f2id\fP \f3:\fP \f2num\fP}*\f3;\fP
X		\f3locks\fP	{\f2id\fP \f3:\fP \f2num\fP}*\f3;\fP  {\f3strict  ;\fP}
X		{ \f3comment\fP	{\f2string\fP}\f3;\fP }
X		{ \f3expand\fP	{\f2string\fP}\f3;\fP }
X		{ \f2newphrase\fP }*
X.LP
X\f2delta\fP	::=	\f2num\fP
X		\f3date\fP	\f2num\fP\f3;\fP
X		\f3author\fP	\f2id\fP\f3;\fP
X		\f3state\fP	{\f2id\fP}\f3;\fP
X		\f3branches\fP	{\f2num\fP}*\f3;\fP
X		\f3next\fP	{\f2num\fP}\f3;\fP
X		{ \f2newphrase\fP }*
X.LP
X\f2desc\fP	::=	\f3desc\fP	\f2string\fP
X.LP
X\f2deltatext\fP	::=	\f2num\fP
X		\f3log\fP	\f2string\fP
X		{ \f2newphrase\fP }*
X		\f3text\fP	\f2string\fP
X.LP
X\f2num\fP	::=	{\f2digit\fP{\f3.\fP}}+
X.LP
X\f2digit\fP	::=	\f30\fP | \f31\fP | .\|.\|. | \f39\fP
X.LP
X\f2id\fP	::=	\f2letter\fP{\f2idchar\fP}*
X.LP
X\f2letter\fP	::=	any letter
X.LP
X\f2idchar\fP	::=	any visible graphic character except \f2special\fP
X.LP
X\f2special\fP	::=	\f3$\fP | \f3,\fP | \f3.\fP | \f3:\fP | \f3;\fP | \f3@\fP
X.LP
X\f2string\fP	::=	\f3@\fP{any character, with \f3@\fP doubled}*\f3@\fP
X.LP
X\f2newphrase\fP	::=	\f2id\fP \f2word\fP* \f3;\fP
X.LP
X\f2word\fP	::=	\f2id\fP | \f2num\fP | \f2string\fP | \f3:\fP
X.fi
X.PP
XIdentifiers are case sensitive.  Keywords are in lower case only.
XThe sets of keywords and identifiers may overlap.
XIn most environments RCS uses the ISO 8859/1 encoding:
Xletters are octal codes 101\-132, 141\-172, 300\-326, 330\-366 and 370-377,
Xvisible graphic characters are codes 041\-176 and 240\-377,
Xand white space characters are codes 010\-015 and 040.
X.PP
XThe
X.I newphrase
Xproductions in the grammar are reserved for future extensions
Xto the format of \*r files.
XNo
X.I newphrase
Xwill begin with any keyword already in use.
X.PP
XThe
X.I delta
Xnodes form a tree.  All nodes whose numbers
Xconsist of a single pair
X(e.g., 2.3, 2.1, 1.3, etc.)
Xare on the trunk, and are linked through the
X.B next
Xfield in order of decreasing numbers.
XThe
X.B head
Xfield in the
X.I admin
Xnode points to the head of that sequence (i.e., contains
Xthe highest pair).
XThe
X.B branch
Xnode in the admin node indicates the default
Xbranch (or revision) for most \*r operations.
XIf empty, the default
Xbranch is the highest branch on the trunk.
X.PP
XAll
X.I delta
Xnodes whose numbers consist of
X.RI 2 n
Xfields
X.RI ( n \(\fP=2)
X(e.g., 3.1.1.1, 2.1.2.2, etc.)
Xare linked as follows.
XAll nodes whose first
X.RI 2 n \-1
Xnumber fields are identical are linked through the
X.B next
Xfield in order of increasing numbers.
XFor each such sequence,
Xthe
X.I delta
Xnode whose number is identical to the first
X.RI 2 n \-2
Xnumber fields of the deltas on that sequence is called the branchpoint.
XThe
X.B branches
Xfield of a node contains a list of the
Xnumbers of the first nodes of all sequences for which it is a branchpoint.
XThis list is ordered in increasing numbers.
X.LP
X.nf
X.vs 12
X.ne 38
XExample:
X.if t .in +0.5i
X.cs 1 20
X.eo
X
X                           Head
X                             |
X                             |
X                             v                        / \
X                         ---------                   /   \
X   / \          / \      |       |      / \         /     \
X  /   \        /   \     |  2.1  |     /   \       /       \
X /     \      /     \    |       |    /     \     /         \
X/1.2.1.3\    /1.3.1.1\   |       |   /1.2.2.2\   /1.2.2.1.1.1\
X---------    ---------   ---------   ---------   -------------
X    ^            ^           |           ^             ^
X    |            |           |           |             |
X    |            |           v           |             |
X   / \           |       ---------      / \            |
X  /   \          |       \  1.3  /     /   \           |
X /     \         ---------\     /     /     \-----------
X/1.2.1.1\                  \   /     /1.2.2.1\
X---------                   \ /      ---------
X    ^                        |           ^
X    |                        |           |
X    |                        v           |
X    |                    ---------       |
X    |                    \  1.2  /       |
X    ----------------------\     /---------
X                           \   /
X                            \ /
X                             |
X                             |
X                             v
X                         ---------
X                         \  1.1  /
X                          \     /
X                           \   /
X                            \ /
X
X.ec
X.if t .in
X.cs 1
X.ce
XFig. 1: A revision tree
X.vs
X.fi
X.PP
X.SH IDENTIFICATION
X.de VL
X\\$2
X..
XAuthor: Walter F. Tichy,
XPurdue University, West Lafayette, IN, 47907.
X.br
XRevision Number: \*(Rv; Release Date: \*(Dt.
X.br
XCopyright \(co 1982, 1988, 1989 by Walter F. Tichy.
X.br
XCopyright \(co 1990 by Paul Eggert.
X.SH SEE ALSO
Xci(1), co(1), ident(1), rcs(1), rcsdiff(1), rcsmerge(1), rlog(1),
X.br
XWalter F. Tichy,
X\*r\*-A System for Version Control,
X.I "Software\*-Practice & Experience"
X.BR 15 ,
X7 (July 1985), 637-654.
END_OF_FILE
  if test 6200 -ne `wc -c <'man/rcsfile.5'`; then
    echo shar: \"'man/rcsfile.5'\" unpacked with wrong size!
  fi
  # end of 'man/rcsfile.5'
fi
if test -f 'man/rcsmerge.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/rcsmerge.1'\"
else
  echo shar: Extracting \"'man/rcsmerge.1'\" \(3141 characters\)
  sed "s/^X//" >'man/rcsmerge.1' <<'END_OF_FILE'
X.de Id
X.ds Rv \\$3
X.ds Dt \\$4
X..
X.Id $Id: rcsmerge.1,v 5.1 1990/08/29 07:13:01 eggert Exp $
X.ds r \s-1RCS\s0
X.if n .ds - \%--
X.if t .ds - \(em
X.TH RCSMERGE 1 \*(Dt GNU
X.SH NAME
Xrcsmerge \- merge RCS revisions
X.SH SYNOPSIS
X.B rcsmerge
X.RI [ options ] " file"
X.SH DESCRIPTION
X.B rcsmerge
Xincorporates the changes between two revisions
Xof an \*r file into the corresponding working file.
X.PP
XA file name ending in
X.B ,v
Xis an \*r file name, otherwise a
Xworking file name.
X.B rcsmerge
Xderives the working file name from the \*r
Xfile name and vice versa, as explained in
X.BR co (1).
XA pair consisting
Xof both an \*r and a working file name may also be specified.
X.PP
XAt least one revision must be specified with one of the options
Xdescribed below, usually
X.BR \-r .
XAt most two revisions may be specified.
XIf only one revision is specified, the latest
Xis omitted, the latest
Xrevision on the default branch (normally the highest branch on the trunk)
Xis assumed for the second revision.
XRevisions may be specified numerically or symbolically.
X.PP
X.B rcsmerge
Xprints a warning if there are overlaps, and delimits
Xthe overlapping regions as explained in
X.BR "co\ \-j".
XThe command is useful for incorporating changes into a checked-out revision.
X.SH OPTIONS
X.TP
X.BI \-k subst
XUse
X.I subst
Xstyle keyword substitution.
XSee
X.BR co (1)
Xfor details.
XFor example,
X.B "\-kk\ \-r1.1\ \-r1.2"
Xignores differences in keyword values when merging the changes from
X.B 1.1
Xto
X.BR 1.2 .
X.TP
X.BR \-p [\f2rev\fP]
XSend the result to standard output instead of overwriting the working file.
X.TP
X.BR \-q [\f2rev\fP]
XRun quietly; do not print diagnostics.
X.TP
X.BR \-r [\f2rev\fP]
XMerge with respect to revision
X.IR rev .
X.TP
X.BI \-V n
XEmulate \*r version
X.IR n .
XSee
X.BR co (1)
Xfor details.
X.SH EXAMPLES
XSuppose you have released revision 2.8 of
X.BR f.c .
XAssume
Xfurthermore that after you complete an unreleased revision 3.4, you receive
Xupdates to release 2.8 from someone else.
XTo combine the updates to 2.8 and your changes between 2.8 and 3.4,
Xput the updates to 2.8 into file f.c and execute
X.LP
X.B "    rcsmerge  \-p  \-r2.8  \-r3.4  f.c  >f.merged.c"
X.PP
XThen examine
X.BR f.merged.c .
XAlternatively, if you want to save the updates to 2.8 in the \*r file,
Xcheck them in as revision 2.8.1.1 and execute
X.BR "co \-j":
X.LP
X.B "    ci  \-r2.8.1.1  f.c"
X.br
X.B "    co  \-r3.4  \-j2.8:2.8.1.1  f.c"
X.PP
XAs another example, the following command undoes the changes
Xbetween revision 2.4 and 2.8 in your currently checked out revision
Xin
X.BR f.c .
X.LP
X.B "    rcsmerge  \-r2.8  \-r2.4  f.c"
X.PP
XNote the order of the arguments, and that
X.B f.c
Xwill be
Xoverwritten.
X.SH DIAGNOSTICS
XExit status is 0 for no overlaps, 1 for some overlaps, 2 for trouble.
X.SH IDENTIFICATION
XAuthor: Walter F. Tichy.
X.br
XRevision Number: \*(Rv; Release Date: \*(Dt.
X.br
XCopyright \(co 1982, 1988, 1989 by Walter F. Tichy.
X.br
XCopyright \(co 1990 by Paul Eggert.
X.SH "SEE ALSO"
Xci(1), co(1), ident(1), merge(1), rcs(1), rcsdiff(1), rcsintro(1), rlog(1),
Xrcsfile(5)
X.br
XWalter F. Tichy,
X\*r\*-A System for Version Control,
X.I "Software\*-Practice & Experience"
X.BR 15 ,
X7 (July 1985), 637-654.
END_OF_FILE
  if test 3141 -ne `wc -c <'man/rcsmerge.1'`; then
    echo shar: \"'man/rcsmerge.1'\" unpacked with wrong size!
  fi
  # end of 'man/rcsmerge.1'
fi
if test -f 'rcs.ms.02' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rcs.ms.02'\"
else
  echo shar: Extracting \"'rcs.ms.02'\" \(7103 characters\)
  sed "s/^X//" >'rcs.ms.02' <<'END_OF_FILE'
Xif that option is missing, it derives the number from the
Xlock held by the user; if there is no lock and locking is not strict,
X\fIci\fR increments the number of the latest revision on the trunk.
XA side branch can only be started by explicitly specifying its
Xnumber with the \fI\-r\fR option during check-in.
X.sp 1
X\fICi\fR also determines
Xwhether the revision to be checked in is different from the
Xprevious one, and asks whether to proceed if not.
XThis facility simplifies check-in operations for large systems,
Xbecause one need not remember which files were changed.
X.sp 1
XThe option \fI\-k\fR searches the checked in file for identification
Xmarkers containing
Xthe attributes
Xrevision number, check-in date, author and state, and assigns these
Xto the new revision rather than computing them.  This option is
Xuseful for software distribution: Recipients of distributed software
Xusing RCS should check in updates with the \fI\-k\fR option.
XThis convention guarantees that revision numbers, check-in dates,
Xetc., are the same at all sites.
X.IP "\fIco\fP \fB\- check out revisions\fP"
X.sp 0
X\fICo\fR retrieves revisions according to revision number,
Xdate, author and state attributes.  It either places the revision
Xinto the working file, or prints it on the standard output.
X\fICo\fR always expands the identification markers.
X.IP "\fIident\fP \fB\- extract identification markers\fP"
X.sp 0
X\fIIdent\fR extracts the identification markers expanded by \fIco\fR
Xfrom any file and prints them.
X.IP "\fIrcs\fP \fB\- change RCS file attributes\fP"
X.sp 0
X\fIRcs\fR is an administrative operation that changes access lists,
Xlocks, unlocks, breaks locks, toggles the strict-locking feature,
Xsets state attributes and symbolic revision numbers, changes the
Xdescription, and deletes revisions.  A revision can
Xonly be deleted if it is not the fork of a side branch.
X.IP "\fIrcsclean\fP \fB\- clean working directory\fP"
X.sp 0
X.ne 10
X\fIRcsclean\fR removes working files that were checked out but never changed.*
X.FS *
XThe \fIrcsclean\fP and \fIrcsfreeze\fP commands
Xare optional and are not always installed.
X.FE
X.IP "\fIrcsdiff\fP \fB\- compare revisions\fP"
X.sp 0
X\fIRcsdiff\fR compares two revisions and prints their
Xdifference, using the UNIX tool \fIdiff\fR.
XOne of the revisions compared may be checked out.
XThis command is useful for finding out about changes.
X.IP "\fIrcsfreeze\fP \fB\- freeze a configuration\fP"
X.sp 0
X\fIRcsfreeze\fR assigns the same symbolic revision number
Xto a given revision in all RCS files.
XThis command is useful for accurately recording a configuration.*
X.IP "\fIrcsmerge\fP \fB\- merge revisions\fP"
X.sp 0
X\fIRcsmerge\fR merges two revisions, \fIrev1\fR and \fIrev2\fR,
Xwith respect to a common ancestor.
XA 3-way file comparison determines the segments of lines that
Xare (a) the same in all three revisions, or (b) the same in 2 revisions,
Xor (c) different in all three.  For all segments of type (b) where
X\fIrev1\fR is the differing revision,
Xthe segment in \fIrev1\fR replaces the corresponding segment of \fIrev2\fR.
XType (c) indicates an overlapping change, is flagged as an error, and requires user
Xintervention to select the correct alternative.
X.IP "\fIrlog\fP \fB\- read log messages\fP"
X.sp 0
X\fIRlog\fR prints the log messages and other information in an RCS file.
X.bp
X.LP
X.nr VS 12p
X.vs 12p
X.]<
X.ds [F 1
X.]-
X.ds [K FELD02
X.ds [K MakeArticle
X.ds [A Feldman, Stuart I.
X.ds [D March 1979
X.ds [T Make\*-A Program for Maintaining Computer Programs
X.ds [J Software\*-Practice & Experience
X.ds [V 9
X.ds [N 3
X.ds [P 255-265
X.nr [P 1
X.nr [T 0
X.nr [A 1
X.nr [O 0
X.][ 1 journal-article
X.ds [F 2
X.]-
X.ds [K HUNT01
X.ds [T An Algorithm for Differential File Comparison
X.ds [A Hunt, James W.
X.as [A " and McIlroy, M. D.
X.ds [I Computing Science Technical Report, Bell Laboratories
X.ds [R 41
X.ds [D June 1976
X.nr [T 0
X.nr [A 1
X.nr [O 0
X.][ 4 tech-report
X.ds [F 3
X.]-
X.ds [K SCCS
X.ds [A Rochkind, Marc J.
X.ds [D Dec. 1975
X.ds [T The Source Code Control System
X.ds [J IEEE Transactions on Software Engineering
X.ds [V SE-1
X.ds [N 4
X.ds [P 364-370
X.nr [P 1
X.nr [T 0
X.nr [A 1
X.nr [O 0
X.][ 1 journal-article
X.ds [F 4
X.]-
X.ds [K TICH08
X.ds [T Design, Implementation, and Evaluation of a Revision Control System
X.ds [A Tichy, Walter F.
X.ds [B Proceedings of the 6th International Conference on Software Engineering
X.ds [I ACM, IEEE, IPS, NBS
X.ds [D September 1982
X.ds [P 58-67
X.nr [P 1
X.nr [T 0
X.nr [A 1
X.nr [O 0
X.][ 3 article-in-book
X.ds [F 5
X.]-
X.ds [K LEBL01
X.ds [A Leblang, David B.
X.as [A " and Chase, Robert P.
X.ds [T Computer-Aided Software Engineering in a Distributed Workstation Environment
X.ds [O Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium
X.as [O " on Practical Software Development Environments.
X.ds [J SIGPLAN Notices
X.ds [V 19
X.ds [N 5
X.ds [D May 1984
X.ds [P 104-112
X.nr [P 1
X.nr [T 0
X.nr [A 1
X.nr [O 0
X.][ 1 journal-article
X.ds [F 1
X.ds [F 3
X.ds [F 6
X.]-
X.ds [K SCCSEval
X.ds [A Glasser, Alan L.
X.ds [D Nov. 1978
X.ds [T The Evolution of a Source Code Control System
X.ds [J Software Engineering Notes
X.ds [V 3
X.ds [N 5
X.ds [P 122-125
X.nr [P 1
X.ds [O Proceedings of the Software Quality and Assurance Workshop.
X.nr [T 0
X.nr [A 1
X.nr [O 1
X.][ 1 journal-article
X.ds [F 5
X.ds [F 7
X.]-
X.ds [K IBMClearCaster
X.ds [A Brown, H.B.
X.ds [D 1970
X.ds [T The Clear/Caster System
X.ds [J Nato Conference on Software Engineering, Rome
X.nr [T 0
X.nr [A 1
X.nr [O 0
X.][ 1 journal-article
X.ds [F 3
X.ds [F 8
X.]-
X.ds [K HabermannSDC
X.ds [A Habermann, A. Nico
X.ds [D Jan. 1979
X.ds [T A Software Development Control System
X.ds [I Technical Report, Carnegie-Mellon University, Department of Computer Science
X.nr [T 0
X.nr [A 0
X.nr [O 0
X.][ 2 book
X.ds [F 9
X.]-
X.ds [K CMS
X.ds [A DEC
X.ds [T Code Management System
X.ds [I Digital Equipment Corporation
X.ds [O Document No.\ EA-23134-82
X.ds [D 1982
X.nr [T 0
X.nr [A 0
X.nr [O 0
X.][ 2 book
X.ds [F 10
X.]-
X.ds [K LAMP01
X.ds [A Lampson, Butler W.
X.as [A " and Schmidt, Eric E.
X.ds [T Practical Use of a Polymorphic Applicative Language
X.ds [B Proceedings of the 10th Symposium on Principles of Programming Languages
X.ds [I ACM
X.ds [P 237-255
X.nr [P 1
X.ds [D January 1983
X.nr [T 0
X.nr [A 1
X.nr [O 0
X.][ 3 article-in-book
X.ds [F 5
X.ds [F 11
X.]-
X.ds [K TICH07
X.ds [T A Data Model for Programming Support Environments and its Application
X.ds [A Tichy, Walter F.
X.ds [B Automated Tools for Information System Design and Development
X.ds [E Hans-Jochen Schneider and Anthony I. Wasserman
X.ds [C Amsterdam
X.ds [I North-Holland Publishing Company
X.ds [D 1982
X.nr [T 0
X.nr [A 1
X.nr [O 0
X.][ 3 article-in-book
X.ds [F 4
X.ds [F 2
X.ds [F 12
X.]-
X.ds [K HECK01
X.ds [T A Technique for Isolating Differences Between Files
X.ds [A Heckel, Paul
X.ds [J Communications of the ACM
X.ds [D April 1978
X.ds [V 21
X.ds [N 4
X.ds [P 264-268
X.nr [P 1
X.nr [T 0
X.nr [A 0
X.nr [O 0
X.][ 1 journal-article
X.ds [F 13
X.]-
X.ds [K TICH11
X.ds [T The String-to-String Correction Problem with Block Moves
X.ds [A Tichy, Walter F.
X.ds [D Nov. 1984
X.ds [J ACM Transactions on Computer Systems
X.ds [V 2
X.ds [N 4
X.ds [P 309-321
X.nr [P 1
X.nr [T 0
X.nr [A 1
X.nr [O 0
X.][ 1 journal-article
X.]>
END_OF_FILE
  if test 7103 -ne `wc -c <'rcs.ms.02'`; then
    echo shar: \"'rcs.ms.02'\" unpacked with wrong size!
  fi
  # end of 'rcs.ms.02'
fi
if test -f 'src/conf.heg' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/conf.heg'\"
else
  echo shar: Extracting \"'src/conf.heg'\" \(4342 characters\)
  sed "s/^X//" >'src/conf.heg' <<'END_OF_FILE'
X/* example RCS compile-time configuration */
X
X	/* $Id: conf.heg,v 1.1 1990/11/01 05:03:27 eggert Exp $ */
X
X/*
X * This is an example RCS compile-time configuration.
X * If you can't get conf.sh to work as described in the Makefile,
X * copy this file to conf.h and edit conf.h by hand.
X */
X
X#define exitmain(n) return n /* how to exit from main() */
X#if !MAKEDEPEND
X#	include <stdio.h>
X#	include <sys/types.h>
X#	include <sys/stat.h>
X#	include <fcntl.h>
X#	include <limits.h>
X#	include <stdlib.h>
X#	include <string.h>
X#	include <unistd.h>
X	/* #include <vfork.h> does not work.  */
X#endif /* !MAKEDEPEND */
X#define has_sys_dir_h 0 /* Does #include <sys/dir.h> work?  */
X#define has_sys_param_h 0 /* Does #include <sys/param.h> work?  */
X#define has_sys_wait_h 1 /* Does #include <sys/wait.h> work?  */
X/* #define const */ /* The 'const' keyword works.  */
X/* #define volatile */ /* The 'volatile' keyword works.  */
X/* typedef int gid_t; */ /* Standard headers define gid_t.  */
X/* typedef int mode_t; */ /* Standard headers define mode_t.  */
X/* typedef int pid_t; */ /* Standard headers define pid_t.  */
X/* typedef int sig_atomic_t; */ /* Standard headers define sig_atomic_t.  */
X/* typedef int size_t; */ /* Standard headers define size_t.  */
X/* typedef long time_t; */ /* Standard headers define time_t.  */
X/* typedef int uid_t; */ /* Standard headers define uid_t.  */
X#define has_prototypes 1 /* Do function prototypes work?  */
X#if has_prototypes
X#	define P(params) params
X#	if !MAKEDEPEND
X#		include <stdarg.h>
X#	endif
X#	define vararg_start(ap,p) va_start(ap,p)
X#else
X#	define P(params) ()
X#	if !MAKEDEPEND
X#		include <varargs.h>
X#	endif
X#	define vararg_start(ap,p) va_start(ap)
X#endif
X#define has_getuid 1 /* Does getuid() work?  */
X#define declare_getpwuid struct passwd *getpwuid P((uid_t));
X#define has_rename 1 /* Does rename() work?  */
X#define bad_rename 0 /* Does rename(A,B) fail if B exists?  */
X#define VOID (void) /* 'VOID e;' discards the value of an expression 'e'.  */
X#define signal_type void /* type returned by signal handlers */
X#define sig_zaps_handler 0 /* Must a signal handler reinvoke signal()?  */
X#define has_seteuid 1 /* Does seteuid() obey Posix 1003.1-1990?  */
X#define has_sigaction 1 /* Does struct sigaction work?  */
X#define has_sigblock 0 /* Does sigblock() work?  */
X#define has_sys_siglist 0 /* Does sys_siglist[] work?  */
X#define exit_type void /* type returned by exit() */
X#define underscore_exit_type void /* type returned by _exit() */
Xtypedef size_t fread_type; /* type returned by fread() and fwrite() */
Xtypedef void *malloc_type; /* type returned by malloc() */
X#define free_type void /* type returned by free() */
Xtypedef size_t strlen_type; /* type returned by strlen() */
X#define has_getcwd 1 /* Does getcwd() work?  */
X/* #define has_getwd ? */ /* Does getwd() work?  */
X#define has_vfork 0 /* Does vfork() work?  */
X#define has_vfprintf 1 /* Does vfprintf() work?  */
X#define CO "/usr/local/bin/co" /* name of 'co' program */
X#define COMPAT2 0 /* Are version 2 files supported?  */
X#define DATEFORM "%.2d.%.2d.%.2d.%.2d.%.2d.%.2d" /* e.g. 01.01.01.01.01.01 */
X#define DIFF "/bin/diff" /* name of 'diff' program */
X#define DIFF_FLAGS , "-n" /* Make diff output suitable for RCS.  */
X#define DIFF_L 0 /* Does diff -L work? */
X#define EXECRCS execv /* variant of execv() to use on subprograms */
X#define MERGE "/usr/local/bin/merge" /* name of 'merge' program */
X#define RCSDIR "RCS/" /* subdirectory for RCS files */
X#define SLASH '/' /* path name separator */
X#define TMPDIR "/tmp/" /* default directory for temporary files */
X#define DIFF_PATH_HARDWIRED 1 /* Is DIFF absolute, not relative?  */
X#define ROOTPATH(p) ((p)[0]==SLASH)
X#define RCSSEP ',' /* separator for RCSSUF */
X#define SENDMAIL "/bin/mail" /* how to send mail */
X#if 1 /* These agree with <stdio.h>.  */
X	int fprintf P((FILE*,const char*,...));
X	int printf P((const char*,...));
X#	if has_vfprintf
X		int vfprintf P((FILE*,const char*,...));
X#	else
X		void _doprnt P((const char*,...));
X#	endif
X#endif
Xchar *sprintf P((char*,const char*,...));
Xint chmod P((const char*,mode_t));
Xint fcntl P((int,int,...));
Xint open P((const char*,int,...));
Xmode_t umask P((mode_t));
Xpid_t wait P((int*));
X#ifndef O_CREAT
X	int creat P((const char*,mode_t));
X#endif
X#if has_seteuid
X	int setegid P((gid_t));
X	int seteuid P((uid_t));
X#endif
END_OF_FILE
  if test 4342 -ne `wc -c <'src/conf.heg'`; then
    echo shar: \"'src/conf.heg'\" unpacked with wrong size!
  fi
  # end of 'src/conf.heg'
fi
if test -f 'src/ident.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/ident.c'\"
else
  echo shar: Extracting \"'src/ident.c'\" \(4900 characters\)
  sed "s/^X//" >'src/ident.c' <<'END_OF_FILE'
X/* Copyright (C) 1982, 1988, 1989 Walter Tichy
X   Copyright 1990 by Paul Eggert
X   Distributed under license by the Free Software Foundation, Inc.
X
XThis file is part of RCS.
X
XRCS is free software; you can redistribute it and/or modify
Xit under the terms of the GNU General Public License as published by
Xthe Free Software Foundation; either version 1, or (at your option)
Xany later version.
X
XRCS is distributed in the hope that it will be useful,
Xbut WITHOUT ANY WARRANTY; without even the implied warranty of
XMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
XGNU General Public License for more details.
X
XYou should have received a copy of the GNU General Public License
Xalong with RCS; see the file COPYING.  If not, write to
Xthe Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X
XReport problems and direct all questions to:
X
X    rcs-bugs@cs.purdue.edu
X
X*/
X
X/*
X *                     RCS identification operation
X */
X
X/* $Log: ident.c,v $
X * Revision 5.0  1990/08/22  08:12:37  eggert
X * Don't limit output to known keywords.
X * Remove arbitrary limits and lint.  Ansify and Posixate.
X *
X * Revision 4.5  89/05/01  15:11:54  narten
X * changed copyright header to reflect current distribution rules
X * 
X * Revision 4.4  87/10/23  17:09:57  narten
X * added exit(0) so exit return code would be non random
X * 
X * Revision 4.3  87/10/18  10:23:55  narten
X * Updating version numbers. Changes relative to 1.1 are actually relative
X * to 4.1
X * 
X * Revision 1.3  87/07/09  09:20:52  trinkle
X * Added check to make sure there is at least one arg before comparing argv[1]
X * with "-q".  This necessary on machines that don't allow dereferncing null
X * pointers (i.e. Suns).
X * 
X * Revision 1.2  87/03/27  14:21:47  jenkins
X * Port to suns
X * 
X * Revision 4.1  83/05/10  16:31:02  wft
X * Added option -q and input from reading stdin.
X * Marker matching is now done with trymatch() (independent of keywords).
X * 
X * Revision 3.4  83/02/18  17:37:49  wft
X * removed printing of new line after last file.
X *
X * Revision 3.3  82/12/04  12:48:55  wft
X * Added LOCKER.
X *
X * Revision 3.2  82/11/28  18:24:17  wft
X * removed Suffix; added ungetc to avoid skipping over trailing KDELIM.
X *
X * Revision 3.1  82/10/13  15:58:51  wft
X * fixed type of variables receiving from getc() (char-->int).
X*/
X
X#include  "rcsbase.h"
X
Xstatic int match P((FILE*));
Xstatic int scanfile P((FILE*));
X
XmainProg(identId, "ident", "$Id: ident.c,v 5.0 1990/08/22 08:12:37 eggert Exp $")
X/*  Ident searches the named files for all occurrences
X *  of the pattern $keyword:...$, where the keywords are
X *  Author, Date, Header, Id, Log, RCSfile, Revision, Source, and State.
X */
X
X{
X   FILE *fp;
X   int quiet;
X   int status = EXIT_SUCCESS;
X
X   if ((quiet  =  argc > 1 && strcmp("-q",argv[1])==0)) {
X        argc--; argv++;
X   }
X
X   if (argc<2) {
X	 if ((scanfile(stdin) == 0) && !quiet)
X	    VOID fprintf(stderr, "%s warning: no id keywords in input\n", cmdid);
X	exitmain(EXIT_FAILURE);
X   }
X
X   while ( --argc > 0 ) {
X      if ( (fp = fopen(*++argv, "r") ) == NULL ) {
X	 VOID fprintf(stderr,  "%s error: can't open %s\n", cmdid, *argv);
X	 status = EXIT_FAILURE;
X         continue;
X      } else {
X         VOID printf( "%s:\n", *argv);   /*  print file name  */
X	 if ((scanfile(fp) == 0) && !quiet)
X	    VOID fprintf(stderr, "%s warning: no id keywords in %s\n", cmdid, *argv);
X	 if (argc>1) VOID putchar('\n');
X	 VOID fclose(fp);
X      }
X   }
X   exitmain(status);
X}
X
X#if lint
X#	define exiterr identExit
X#endif
X	exiting void
Xexiterr()
X{
X	_exit(EXIT_FAILURE);
X}
X
X
X	static int
Xscanfile(file)
X	register FILE *file;
X/* Function: scan an open file with descriptor file for keywords.
X * Returns nonzero if a match is found.
X */
X{
X   register int matched;
X   register int c;
X
X
X   matched = false;
X   c = 0;
X   while (c != EOF) {
X      if (c == KDELIM) {
X	 if ((c = match(file)))
X	    continue;
X	 matched = true;
X      }
X      c = getc(file);
X   }
X   return matched;
X}
X
X
X
X	static int
Xmatch(fp)   /* group substring between two KDELIM's; then do pattern match */
X   register FILE *fp;
X{
X   char line[BUFSIZ];
X   register int c;
X   register char * tp;
X
X   tp = line;
X   while ((c = getc(fp)) != VDELIM)
X      switch (ctab[c]) {
X	 case LETTER: case Letter:
X	    *tp++ = c;
X	    if (tp < line+sizeof(line)-4)
X	       break;
X	    /* fall into */
X	 default:
X	    return c ? c : '\n'/* anything but 0 or KDELIM or EOF */;
X      }
X   *tp++ = c;
X   if ((c = getc(fp)) != ' ')
X      return c ? c : '\n';
X   *tp++ = c;
X   while( (c = getc(fp)) != KDELIM ) {
X      switch (ctab[c]) {
X	 default:
X	    *tp++ = c;
X	    if (tp < line+sizeof(line)-2)
X	       break;
X	    /* fall into */
X	 case EOFILE: case NEWLN: case UNKN:
X	    return c ? c : '\n';
X      }
X   }
X   if (tp[-1] != ' ')
X      return tp[-1];
X   *tp++ = c;     /*append trailing KDELIM*/
X   *tp   = '\0';
X   VOID fprintf(stdout, "     %c%s\n", KDELIM, line);
X   return 0;
X}
END_OF_FILE
  if test 4900 -ne `wc -c <'src/ident.c'`; then
    echo shar: \"'src/ident.c'\" unpacked with wrong size!
  fi
  # end of 'src/ident.c'
fi
if test -f 'src/merge.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/merge.sh'\"
else
  echo shar: Extracting \"'src/merge.sh'\" \(2057 characters\)
  sed "s/^X//" >'src/merge.sh' <<'END_OF_FILE'
X: 'Output the merge command as a shell file.'
X
XId='$Id: merge.sh,v 5.3 1990/11/01 05:03:32 eggert Exp $'
X
Xcat >a.sh <<'EOF' && chmod +x a.sh || exit
X#!/bin/sh
Xexport something
XEOF
Xif
X	(
X		./a.sh &&
X		if csh -c :
X		then csh -c ./a.sh
X		else :
X		fi
X	) 2>/dev/null
Xthen
X	echo '#!/bin/sh'
X	echo '# merge - three-way file merge'
X	echo "#	$Id"
Xelse
X	echo ': merge - three-way file merge'
X	echo ": '$Id'"
Xfi
Xrm -f a.sh
X
Xcat <<EOF
X
XDIFF=${DIFF?}
XDIFF3=${DIFF3?}
XEOF
X
Xcat <<'EOF'
XPATH=/bin:/usr/bin
Xlabels=0 p=w say=echo
Xwhile
X	case $1 in
X	-p)
X		p='1,$p';;
X	-q)
X		say=:;;
X	-L)
X		case $labels in
X		0) l1=$2 labels=1;;
X		1) l3=$2 labels=2;;
X		*) echo "merge: too many -L options"; exit 2
X		esac
X		case $# in
X		1) ;;
X		*) shift
X		esac;;
X	-*)
X		echo "merge: $1: unknown option"; exit 2;;
X	*)
X		break
X	esac
Xdo shift
Xdone
X
Xcase $# in
X3) ;;
X*)
X	echo >&2 'merge: usage: merge [-p] [-q] [-L label1 [-L label3]] file1 file2 file3'
X	exit 2
Xesac
X
Xf1=$1 f2=$2 f3=$3
Xcase $1 in +*) f1=./$1;; esac
Xcase $2 in +*|-*) f2=./$2;; esac
Xcase $3 in +*|-*) f3=./$3;; esac
X
Xcase $labels in
X0) l3=$3 l1=$1;;
X1) l3=$3
Xesac
X
Xcase $p in
Xw)
X	if test ! -w "$f1"
X	then
X		echo >&2 "merge: $1 not writeable"
X		exit 2
X	fi
Xesac
X
Xstatus=2
Xtemps=
Xtrap '
X	case $temps in
X	?*) rm -f $temps || status=2
X	esac
X	exit $status
X' 0
Xtrap exit 1 2 3 13 15
Xumask 077
X
Xt=/tmp/d3t$$
X
XEOF
X
Xcase ${DIFF3_TYPE?} in
Xbin) sed 's/^[	 ]*//' <<'EOF'
X	case $p in
X	w) temps=$t;;
X	*) t=
X	esac
X
X	$DIFF3 -am -L "$l1" -L "$l3" "$f1" "$f2" "$f3" >$t
X	s=$?
X
X	case $s in
X	0) ;;
X	1) $say >&2 "merge: overlaps during merge";;
X	*) exit
X	esac
X
X	case $p in
X	w) cp $t "$f1" || s=2
X	esac
X
X	status=$s
XEOF
X;;
X
X*) sed 's/^[	 ]*//' <<'EOF'
X	temps="/tmp/d3a$$ /tmp/d3b$$ $t"
X
X	$DIFF "$f1" "$f3" >/tmp/d3a$$
X	case $? in
X	0|1) ;;
X	*) exit
X	esac
X
X	$DIFF "$f2" "$f3" >/tmp/d3b$$
X	case $? in
X	0|1) ;;
X	*) exit
X	esac
X
X	$DIFF3 -E /tmp/d3a$$ /tmp/d3b$$ "$f1" "$f2" "$f3" "$l1" "$l3" >$t
X	s=$?
X
X	case $s in
X	0) ;;
X	*) s=1; $say >&2 "merge: overlaps or other problems during merge"
X	esac
X
X	echo $p >>$t  &&  ed - "$f1" <$t   ||   s=2
X
X	status=$s
XEOF
Xesac
END_OF_FILE
  if test 2057 -ne `wc -c <'src/merge.sh'`; then
    echo shar: \"'src/merge.sh'\" unpacked with wrong size!
  fi
  # end of 'src/merge.sh'
fi
if test -f 'src/rcsfreeze.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/rcsfreeze.sh'\"
else
  echo shar: Extracting \"'src/rcsfreeze.sh'\" \(3263 characters\)
  sed "s/^X//" >'src/rcsfreeze.sh' <<'END_OF_FILE'
X#! /bin/sh
X
X# rcsfreeze - assign a symbolic revision number to a configuration of RCS files
X
X#	$Id: rcsfreeze.sh,v 4.3 1990/11/01 05:03:45 eggert Exp $
X
X#       The idea is to run rcsfreeze each time a new version is checked
X#       in. A unique symbolic revision number (C_[number], where number
X#       is increased each time rcsfreeze is run) is then assigned to the most
X#       recent revision of each RCS file of the main trunk.
X#
X#       If the command is invoked with an argument, then this
X#       argument is used as the symbolic name to freeze a configuration.
X#       The unique identifier is still generated
X#       and is listed in the log file but it will not appear as
X#       part of the symbolic revision name in the actual RCS file.
X#
X#       A log message is requested from the user which is saved for future
X#       references.
X#
X#       The shell script works only on all RCS files at one time.
X#       It is important that all changed files are checked in (there are
X#       no precautions against any error in this respect).
X#       file names:
X#       {RCS/}.rcsfreeze.ver	version number
X#       {RCS/}.rscfreeze.log	log messages, most recent first
X
XPATH=/usr/local/bin:/bin:/usr/bin:/usr/ucb:$PATH
Xexport PATH
X
XDATE=`date` || exit
X# Check whether we have an RCS subdirectory, so we can have the right
X# prefix for our paths.
Xif [ -d RCS ]
Xthen RCSDIR=RCS/
Xelse RCSDIR=
Xfi
X
X# Version number stuff, log message file
XVERSIONFILE=${RCSDIR}.rcsfreeze.ver
XLOGFILE=${RCSDIR}.rcsfreeze.log
X# Initialize, rcsfreeze never run before in the current directory
X[ -r $VERSIONFILE ] || { echo 0 >$VERSIONFILE && >>$LOGFILE; } || exit
X
X# Get Version number, increase it, write back to file.
XVERSIONNUMBER=`cat $VERSIONFILE` &&
XVERSIONNUMBER=`expr $VERSIONNUMBER + 1` &&
Xecho $VERSIONNUMBER >$VERSIONFILE || exit
X
X# Symbolic Revision Number
XSYMREV=C_$VERSIONNUMBER
X# Allow the user to give a meaningful symbolic name to the revision.
XSYMREVNAME=${1-$SYMREV}
Xecho >&2 "rcsfreeze: symbolic revision number computed: \"$SYMREV\"
Xrcsfreeze: symbolic revision number used:     \"$SYMREVNAME\"
Xrcsfreeze: the two differ only when rcsfreeze invoked with argument
Xrcsfreeze: give log message, summarizing changes (end with EOF or single '.')" \
X	|| exit
X
X# Stamp the logfile. Because we order the logfile the most recent
X# first we will have to save everything right now in a temporary file.
XTMPLOG=/tmp/rcsfrz$$
Xtrap 'rm -f $TMPLOG; exit 1' 1 2 13 15
X# Now ask for a log message, continously add to the log file
X(
X	echo "Version: $SYMREVNAME($SYMREV), Date: $DATE
X-----------" || exit
X	while read MESS
X	do
X		case $MESS in
X		.) break
X		esac
X		echo "	$MESS" || exit
X	done
X	echo "-----------
X" &&
X	cat $LOGFILE
X) >$TMPLOG &&
X
X# combine old and new logfiles
Xcp $TMPLOG $LOGFILE &&
Xrm -f $TMPLOG || exit
Xtrap 1 2 13 15
X
X# Now the real work begins by assigning a symbolic revision number
X# to each rcs file. Take the most recent version of the main trunk.
X
Xstatus=
X
Xfor FILE in ${RCSDIR}*
Xdo
X#   get the revision number of the most recent revision
X    HEAD=`rlog -h $FILE` &&
X	REV=`echo "$HEAD" | sed -n 's/^head:[ 	]*//p'` &&
X#   assign symbolic name to it.
X    echo >&2 "rcsfreeze: $REV $FILE" &&
X    rcs -q -n$SYMREVNAME:$REV $FILE || status=$?
Xdone
X
Xexit $status
END_OF_FILE
  if test 3263 -ne `wc -c <'src/rcsfreeze.sh'`; then
    echo shar: \"'src/rcsfreeze.sh'\" unpacked with wrong size!
  fi
  # end of 'src/rcsfreeze.sh'
fi
if test -f 'src/rcsmap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/rcsmap.c'\"
else
  echo shar: Extracting \"'src/rcsmap.c'\" \(3176 characters\)
  sed "s/^X//" >'src/rcsmap.c' <<'END_OF_FILE'
X/* RCS map of character types */
X
X/* Copyright (C) 1982, 1988, 1989 Walter Tichy
X   Copyright 1990 by Paul Eggert
X   Distributed under license by the Free Software Foundation, Inc.
X
XThis file is part of RCS.
X
XRCS is free software; you can redistribute it and/or modify
Xit under the terms of the GNU General Public License as published by
Xthe Free Software Foundation; either version 1, or (at your option)
Xany later version.
X
XRCS is distributed in the hope that it will be useful,
Xbut WITHOUT ANY WARRANTY; without even the implied warranty of
XMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
XGNU General Public License for more details.
X
XYou should have received a copy of the GNU General Public License
Xalong with RCS; see the file COPYING.  If not, write to
Xthe Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X
XReport problems and direct all questions to:
X
X    rcs-bugs@cs.purdue.edu
X
X*/
X
X#include "rcsbase.h"
X
XlibId(mapId, "$Id: rcsmap.c,v 5.0 1990/08/22 08:13:14 eggert Exp $")
X
X/* map of character types */
X/* ISO 8859/1 (Latin-1) */
X/* For best results, this should match diff's opinion of which */
X/* characters may appear in a text file. */
Xconst enum tokens map[] = {
X	EOFILE, /* ctab[-1] */
X	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,
X	SPACE,	SPACE,	NEWLN,	SPACE,	SPACE,	SPACE,	UNKN,	UNKN,
X	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,
X	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,
X	SPACE,	IDCHAR,	IDCHAR,	IDCHAR,	DELIM,	IDCHAR,	IDCHAR,	IDCHAR,
X	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	DELIM,	IDCHAR,	PERIOD,	IDCHAR,
X	DIGIT,	DIGIT,	DIGIT,	DIGIT,	DIGIT,	DIGIT,	DIGIT,	DIGIT,
X	DIGIT,	DIGIT,	COLON,	SEMI,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,
X	SBEGIN,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,
X	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,
X	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,
X	LETTER,	LETTER,	LETTER,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,
X	IDCHAR,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,
X	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,
X	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,
X	Letter,	Letter,	Letter,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	UNKN,
X	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,
X	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,
X	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,
X	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,
X	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,
X	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,
X	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,
X	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,
X	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,
X	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,
X	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	IDCHAR,
X	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	Letter,
X	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,
X	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,
X	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	IDCHAR,
X	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,
X};
END_OF_FILE
  if test 3176 -ne `wc -c <'src/rcsmap.c'`; then
    echo shar: \"'src/rcsmap.c'\" unpacked with wrong size!
  fi
  # end of 'src/rcsmap.c'
fi
echo shar: End of archive 11 \(of 12\).
cp /dev/null ark11isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 12 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
