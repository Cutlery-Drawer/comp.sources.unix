Subject:  v24i036:  Manipulate data on the chemical elements, Part01/03
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: 5975ff77 725e468c 4526f97d 2106b725

Submitted-by: "J.E. King" <jek5036@ultb.isc.rit.edu>
Posting-number: Volume 24, Issue 36
Archive-name: chemtab/part01

Chemtab was designed in conjunction with the faculty in the science
department at the Lincoln-Sudbury Regional High School.  The database does a
variety of functions:

	1) Graph elemental data (x vs y)
	2) Select a set of elements from given parameters
	3) Look at a certain element and display all known information
	   (at least, all input data) on the element.
It is a screen-oriented program with extensive on-line help.

All elemental information in this program has been extracted from the
following sources:
	CRC Handbook of Chemistry & Physics, 63rd edition, 1982-1983
	CRC Handbook of Chemistry & Physics, 70th edition, 1989-1990


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  README README.FIRST dogph.c doregisgph.c elist esort.c
#   looke.c main.c
# Wrapped by rsalz@litchi.bbn.com on Wed Mar 13 13:55:18 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 3)."'
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(1337 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
XChemTab - A Periodic Table (of the elements) Database
X
XChemtab was written at Lincoln-Sudbury Regional High School during the 1989
Xto 1990 school year.  Chemtab was completed further at Rochester Institute
Xof Technology.
X
XChemtab was designed in conjunction with the faculty in the science
Xdepartment at the Lincoln-Sudbury Regional High School.  The database does a
Xvariety of functions:
X
X	1) Graph elemental data (x vs y)
X	2) Select a set of elements from given parameters
X	3) Look at a certain element and display all known information
X	   (at least, all input data) on the element.
X
XAll elemental information in this program has been extracted from the
Xfollowing sources:
X	CRC Handbook of Chemistry & Physics, 63rd edition, 1982-1983
X	CRC Handbook of Chemistry & Physics, 70th edition, 1989-1990
X
Xo All whole numbers, if rounded, are rounded on the premise that:
X  .01 to .49 considered rounded down
X  .50 to .99 considered rounded up
X
Xo Ionization Energy found in the following manner: (to compromise the
X  chemistry courses at the high school)
X	All figures based on the table of "IONIZATION POTENTIALS", pages
X	E-64 and E-65(82-83), column I, then multiplied by 23.  Rounded.
X
XChemtab; written in C (1990) by Jim King (pulsar@lsrhs)
XChemtab V2.01; (overlay from V1) written in C (1991) by Jim King
X						(jek5036@ultb.isc.rit.edu)
END_OF_FILE
  if test 1337 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test -f 'README.FIRST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README.FIRST'\"
else
  echo shar: Extracting \"'README.FIRST'\" \(2532 characters\)
  sed "s/^X//" >'README.FIRST' <<'END_OF_FILE'
XJim King - January 1991
X
XChemtab supports the following devices:
X	ANY terminal which can utilize the curses screen functions
X	* Graphic Periodic Table - ANY VT1XX compatible
X	* Graphing routine (normal) - any curses terminal
X	* Graphics routing (ReGIS) - any ReGIS compatible (VT240, VT3XX)
X	
X	Chemtab was designed to work on any terminal that has an entry
Xin the /etc/termcap file and has cursor movement sequences in that
Xentry!
X
XHow to setup Chemtab to work at your site..
X
XWARNING: Chemtab has only been tested under Ultrix 3.1 on a VAX 11/780,
X	 and a DEC 5810 RISC Ultrix 4.1 machine.  Chemtab, as is, will
X	 probably only work for BSD compatible systems.  SYSV compatibility
X         is on it's way!  I promise!  Since chemtab uses curses, it should
X	 prove to be portable.
X
XAny comments, suggestions, bugs can be reported to:
X	jek5036@ultb.isc.rit.edu (formerly pulsar@xait.xerox.com!lsrhs)
X
XHow to setup:
X(1) Change the Makefile to suit your site.  Currently, the makefile will
X    compile with cc, with the -O option for optimization, and the new
X    ReGIS flag for DEC ReGIS compatible terminals.
X(2) Change tune.h to suit your needs.
X(3) Change the directions on how to get to your printer at the end of cleanup.c
X    Or, just remove those print statements.  (The statement you want to change
X    is in comments.  This is only helpful if you are running a classroom full
X    of students, each wanting a printout and not knowing how to get it.)
X(4) Type the command, 'make'
X(5) There are some text files which chemtab needs to use, namely:
X	elist, pertab, pertab_graphic, online_help, closevalues
X    These should be put in a library directory somewhere where chemtab
X    can read all of these.  In that same directory, chemtab will need to
X    write to two files: logfile (if you want one) and binlist (binary
X    element list (faster to read in)).  Please make this so.  I would
X    have incorporated it into the Makefile but some people would rather
X    make sure it worked for them...
X
XThat SHOULD be the extent of it.. but don't quote me on that.  I am the
Xauthor, and I am not held responsible for any damage the program might cause,
Xhowever it's not programmed to do any damage whatsoever.
X
XI realize that the directions are sketchy, but I am a programmer,
Xnot a documenter (or a commenter for that matter)..
X
XIf you decide to use this program in a classroom environment, please send me
Xmail over the internet at jek5036@ultb.isc.rit.edu.  I would love to hear
Xfrom anyone who uses chemtab 2.01!  Thanks..			- Jim
END_OF_FILE
  if test 2532 -ne `wc -c <'README.FIRST'`; then
    echo shar: \"'README.FIRST'\" unpacked with wrong size!
  fi
  # end of 'README.FIRST'
fi
if test -f 'dogph.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dogph.c'\"
else
  echo shar: Extracting \"'dogph.c'\" \(7770 characters\)
  sed "s/^X//" >'dogph.c' <<'END_OF_FILE'
X/*
X * chemtab - a periodic table data base (C) 1990 Jim King (pulsar@lsrhs)
X *
X * dogph.c	Contains graphing procedures
X */
X
X#include <curses.h>
X#include "windows.h"
X#include <stdio.h>
X#include <math.h>
X#include "tune.h"
X#include "variables.h"
X#include "element.h"
X#include "graph.h"
X#include "undefs.h"
X
X/*
X * numr(ch)
X *	input:	ch - char - input to determine output
X *	output:	return() - int
X *
X * purpose:	to print the top line of the graph, x vs. y, we need
X *		the array number of the chosen function, array gname[]
X *		found in graph.h...
X */
Xnumr(ch)
Xchar	ch;
X{
X	char	luk[12];
X	int	i;
X
X	strcpy(luk, " abcdefghij");
X	for (i = 1; i < 11; i++)
X		if (ch == luk[i]) return(i);
X}
X
Xfixup(win)
XWINDOW	*win;
X{
X	wmove(win, 0, 0);
X	wmove(btm, 0, 0);
X	wmove(win, 0, 0);
X	move(0, 0);
X	refresh();
X	wrefresh(btm);
X	wrefresh(win);
X}
X
Xextern void find();
X
X/*
X * dogph() - no input
X *
X * purpose:	This is the main graphing routine.
X */
Xdogph()
X{
X	struct	elem	*tmp;
X	char	c, str[80];
X	int	i, j, count;
X
X	for (i = 0; i < 70; i++)		/* clear the x axis points */
X		xaxis[i] = 0;
X	for (i = 0; i < 21; i++)		/* clear the y axis points */
X		yaxis[i] = 0;
X
Xl2:	wclear(graph); wrefresh(graph); clear(); refresh();
X	menu("Graphing Module");
X	mvwaddstr(mn, 0, 0, "a] Atomic Number");
X	mvwaddstr(mn, 1, 0, "b] Atomic Mass");
X	mvwaddstr(mn, 2, 0, "c] Melting Temp.");
X	mvwaddstr(mn, 3, 0, "d] Boiling Temp.");
X	mvwaddstr(mn, 4, 0, "e] Ionization Energy");
X	mvwaddstr(mn, 5, 0, "f] Electronegativity");
X	wrefresh(mn);
X	wmove(mn, 6, 0);
X	wclrtoeol(mn);
X	mvwaddstr(mn, 6, 0, "g] Specific Heat");
X	wrefresh(mn);
X	mvwaddstr(mn, 7, 0, "h] Density");
X	mvwaddstr(mn, 8, 0, "i] Atomic Radius");
X	mvwaddstr(mn, 9, 0, "j] Discovery Year");
X	mvwaddstr(mn, 10, 0, "Graphing by this, across the X axis.");
X	mvwaddstr(mn, 13, 0, "*** Due to lack of information at this time, graphs beyond");
X	mvwaddstr(mn, 14, 0, "*** Atomic number 86 may be misleading.  The program is designed");
X	mvwaddstr(mn, 15, 0, "*** to compensate, but nothing is perfect.");
X	mvwaddstr(mn, 16, 0, ">>> PRESS RETURN TO RETURN TO MAIN MENU.");
Xfirst:	mvwaddstr(mn, 11, 0, "Your choice: ");
X	wrefresh(mn);				/* collect their choices */
X	cur = mn; xp = 14; yp = 11;
X	crmode();
X	noecho();
X	c1 = getchar();	/* X axis chc */
X	if (c1 == '\n') { wclear(mn); return; }
X	if (c1 == '?') { help(3); goto first; }
X	if (c1 < 'a' || c1 > 'j')
X		goto first;
X	for (i = 12; i < 17; i++) {
X		wmove(mn, i, 0); wclrtoeol(mn);
X	}
X
X	find(c1, e->anum);
X	xmax = xmin = x;
X	if (gtot > 0) {
X		for (tmp = e; tmp->next != NULL; tmp = tmp->next) {
X			find(c1, tmp->anum);
X			if (x == -999.0) continue;
X			if (x > xmax) xmax = x;
X			if (x < xmin) xmin = x;
X		}
X	} else {
X		for (i = 1; i < gtot; i++) {
X			find(c1, sub1[i]);
X			if (x == -999.0) continue;
X			if (i == 1) xmax = xmin = x;
X			else {
X				if (x > xmax) xmax = x;
X				if (x < xmin) xmin = x;
X			}
X		}
X	}
X
X	mvwaddstr(mn, 10, 0, "If you would rather use the maximum and minimum values of");
X	mvwaddstr(mn, 11, 0, "all the elements, hit RETURN once.");
X	wmove(mn, 12, 0); wprintw(mn, "All the element's values: Minimum %f, Maximum %f", xmin, xmax);
Xl4:	mvwaddstr(mn, 13, 0, "What range, X Minimum? ");
X	wrefresh(mn);
X	cur = mn; xp = 24; yp = 13;
X	echo(); nocrmode();
X	gets(str);
X	if (str[0] == '?') { help(4); goto l4; }
X	if (!strlen(str)) {
X		xmin = -999;
X		goto nt;
X	}
X	xmin = atof(str);
X	fixup(mn); fixup(stdscr);
X	mvwaddstr(mn, 13, 0, "What range, X Maximum [RETURN for value above]? ");
X	wrefresh(mn);
X	cur = mn; xp = 48; yp = 13;
X	echo(); nocrmode();
X	gets(str);
X	if (strlen(str))
X		xmax = atof(str);
X	fixup(mn);
X	
Xnt:	wmove(mn, 10, 0); wclrtoeol(mn); wmove(mn, 11, 0); wclrtoeol(mn);
X	mvwaddstr(mn, 10, 0, "Graphing by this, down the Y axis.   ");
Xscnd:	wmove(mn, 12, 0); wclrtoeol(mn); wmove(mn, 13, 0); wclrtoeol(mn);
X	mvwaddstr(mn, 11, 0, "Your choice: ");
X	wrefresh(mn);
X	cur = mn; xp = 14; yp = 11;
X	noecho(); crmode();
X	c2 = wgetch(mn); /* Y axis chc */
X	if (c2 == '?') { help(5); goto scnd; }
X	if (c2 < 'a' || c2 > 'j')
X		goto scnd;
X	noecho();
X
X	wclear(mn); wrefresh(mn);
X	clear(); refresh();
X	/* Here we find the x axis max and min values */
X	/* if they are not already defined */
X	if (xmin == -999) {
X		find(c1, e->anum);
X		xmax = xmin = x;
X		for (tmp = e; tmp->next != NULL; tmp = tmp->next) {
X			find(c1, tmp->anum);
X			if (x == -999.0) continue;
X			if (x > xmax) xmax = x;
X			if (x < xmin) xmin = x;
X		}
X	}
X
X	/* Here we find the y axis min and max values */
X
X	find(c2, e->anum);
X	ymax = ymin = x;
X	if (gtot > 0) {
X		for (tmp = e; tmp->next != NULL; tmp = tmp->next) {
X			find(c2, tmp->anum);
X			if (x == -999.0) continue;
X			if (x > ymax) ymax = x;
X			if (x < ymin) ymin = x;
X		}
X	} else {
X		for (i = 1; i < gtot; i++) {
X			find(c2, sub1[i]);
X			if (x == -999.0) continue;
X			if (i == 1)
X				ymax = ymin = x;
X			else {
X				if (x > ymax) ymax = x;
X				if (x < ymin) ymin = x;
X			}
X		}
X	}
X
X	/* Now we have min & maxs we have to put a number in
X	   each slot on both axes using a scale */
X
X	scale = (xmax - xmin) / 69.0; /* 69 is # of slots in X axis */
X
X	xaxis[1] = xmin;
X	for (i = 2; i < 70; i++)
X		xaxis[i] = xaxis[i-1] + scale;
X
X	scale = (ymax - ymin) / 20.0; /* 20 is # of slots in Y axis */
X
X	yaxis[20] = ymin;
X	for (i = 19; i > 1; i--)
X		yaxis[i] = yaxis[i+1] + scale;
X
X	sprintf(str, "%s (x-axis) vs. %s (y-axis)", gname[numr(c1)], gname[numr(c2)]);
X	mvwaddstr(graph, 0, (40 - (strlen(str) / 2)), str);
X	wrefresh(graph);	/* That is the top graph line */
X	for (i = 20; i > 1; i--) {		/* The y axis line */
X		mvwaddstr(graph, i, 10, "|");
X		wrefresh(graph);
X	}
X	for (i = 11; i < 80; i++) {		/* The x axis line */
X		mvwaddstr(graph, 21, i, "-");
X		wrefresh(graph);
X	}
X	fixup(graph);
X	mvwaddstr(graph, 21, 10, "+");		/* The corner */
X	wrefresh(graph);
X	for (i = 20; i > 1; i -= 5) {		/* Y axis points */
X		if (c2 < 'f' || c2 > 'i')
X			sprintf(str, "%d ->", (int)(yaxis[i]+.5));
X		else
X			sprintf(str, "%4.2f ->", yaxis[i]);
X		mvwaddstr(graph, i, 0, str);
X	}
X	for (i = 1; i < 79; i += 10) {		/* X axis points */
X		if (c1 < 'f' || c1 > 'i')
X			sprintf(str, "^%d", (int)(xaxis[i]+.5));
X		else
X			sprintf(str, "^%4.2f", xaxis[i]);
X		mvwaddstr(graph, 22, i+10, str);
X	}
X	/* The actual find & graph */
X
X	if (gtot > 0) {
X		for (tmp = e; tmp->next != NULL; tmp = tmp->next) {
X			find(c1, tmp->anum);
X			if (x == -999.0) continue;
X			if (x < xmin)
X				continue;
X			else if (x < xaxis[2])
X				xspot = 1;
X			else {
X				for (j = 2; j < 70; j++) {
X					if (x > xaxis[j])
X						continue;
X					else
X						break;
X				}
X				xspot = j - 1;
X				if (x > xmax)
X					continue;
X			}
X
X			/* Found where it goes on the x, now the y */
X
X			find(c2, tmp->anum);
X			if (x == -999.0) continue;
X			if (x < yaxis[19])
X				yspot = 20;
X			else {
X				for (j = 19; j > 1; j--) {
X					if (x > yaxis[j])
X						continue;
X					else
X						break;
X				}
X				yspot = j;
X			}
X
X			/* Align and put the dot where X marks the spot */
X
X			mvwaddstr(graph, yspot, xspot+10, "o");
X			wrefresh(graph);
X		}
X	} else {
X		for (i = 1; i < gtot; i++) {
X			find(c1, sub1[i]);
X			if (x == -999.0) continue;
X			if (x < xmin)
X				continue;
X			else if (x < xaxis[2])
X				xspot = 1;
X			else {
X				for (j = 2; j < 70; j++) {
X					if (x > xaxis[j])
X						continue;
X					else
X						break;
X				}
X				xspot = j - 1;
X				if (x > xmax)
X					continue;
X			}
X
X			/* Found where it goes on the x, now the y */
X
X			find(c2, sub1[i]);
X			if (x == -999.0) continue;
X			if (x < yaxis[19])
X				yspot = 20;
X			else {
X				for (j = 19; j > 1; j--) {
X					if (x > yaxis[j])
X						continue;
X					else
X						break;
X				}
X				yspot = j;
X			}
X
X			/* Align and put the dot where X marks the spot */
X
X			mvwaddstr(graph, yspot, xspot+10, "o");
X			wrefresh(graph);
X		}
X	}
X
X	capture(graph, 1, 0);
X	spc();		/* Space to continue? */
X	wclear(graph);
X	wrefresh(graph);
X	return(0);
X}
END_OF_FILE
  if test 7770 -ne `wc -c <'dogph.c'`; then
    echo shar: \"'dogph.c'\" unpacked with wrong size!
  fi
  # end of 'dogph.c'
fi
if test -f 'doregisgph.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doregisgph.c'\"
else
  echo shar: Extracting \"'doregisgph.c'\" \(10517 characters\)
  sed "s/^X//" >'doregisgph.c' <<'END_OF_FILE'
X#ifdef	ReGIS
X
X/*
X * chemtab - a periodic table data base (C) 1990 Jim King
X *           jek5036@ritvax.isc.rit.edu (formerly pulsar@lsrhs)
X *
X * doregisgph.c - Graph better for ReGIS compatible users (OCT 1990)
X */
X
X#include <curses.h>
X#include "windows.h"
X#include <stdio.h>
X#include <math.h>
X#include "variables.h"
X#include "element.h"
X#include "graph.h"
X#include "undefs.h"
X#include <signal.h>
X
Xextern int numr(), stop();
X
X#endif ReGIS
X/*
X * find(ch, en)
X *
X * inputs: char ch; int	enum;
X * returns: floating point integer
X * purpose: replace many switch statements
X */
Xfind(ch, en)
Xint	ch, en;
X{
X	struct elem	*pos;
X	int	i;
X	
X	for (pos = e; en != pos->anum; pos = pos->next) ;
X
X	switch(ch) {
X		case 'a': x = pos->anum; break;
X		case 'b': x = pos->amass; break;
X		case 'c': x = pos->melt; if (x == MEL) x = -999.0;
X			  break;
X		case 'd': x = pos->boil; if (x == BOI) x = -999.0;
X			  break;
X		case 'e': x = pos->fio; if (x == FIO) x = -999.0;
X			  break;
X		case 'f': x = pos->eneg; if (x == ENG) x = -999.0;
X		 	  break;
X		case 'g': x = pos->spht; if (x == SPHT) x = -999.0;
X			  break;
X		case 'h': x = pos->dens; if (x == DENS) x = -999.0;
X			  break;
X		case 'i': x = pos->arad; if (x == ARD) x = -999.0;
X			  break;
X		default:  x = pos->year; if (x == YEA) x = -999.0;
X			  break;
X	}
X}
X
X/*
X * doregisgph - no input
X *
X * purpose:	ReGIS graphics support
X */
Xdoregisgph()
X{
X#ifdef	ReGIS
X	char	c, str[80];
X	int	i, j, grid, lastx, lasty, connect, type, firstup;
X	struct elem	*tmp;
X	
X#ifdef	USERSHELL
X	signal(SIGTSTP, SIG_IGN);
X#endif	USERSHELL
X
X	for (i = 0; i < XAXISDEF; i++)
X		xaxis[i] = 0;
X	for (i = 0; i < YAXISDEF; i++)
X		yaxis[i] = 0;
X
X	wclear(graph); wrefresh(graph); clear(); refresh();
X	menu("ReGIS Graphing Module");
X	mvwaddstr(mn, 0, 0, "a] Atomic Number");
X	mvwaddstr(mn, 1, 0, "b] Atomic Mass");
X	mvwaddstr(mn, 2, 0, "c] Melting Temp.");
X	mvwaddstr(mn, 3, 0, "d] Boiling Temp.");
X	mvwaddstr(mn, 4, 0, "e] Ionization Energy");
X	mvwaddstr(mn, 5, 0, "f] Electronegativity");
X	mvwaddstr(mn, 6, 0, "g] Specific Heat");
X	mvwaddstr(mn, 7, 0, "h] Density");
X	mvwaddstr(mn, 8, 0, "i] Atomic Radius");
X	mvwaddstr(mn, 9, 0, "j] Discovery Year");
X	mvwaddstr(mn, 10, 0, "Graphing by this, across the X axis.");
X	mvwaddstr(mn, 13, 0, "*** Due to lack of information at this time, graphs beyond");
X	mvwaddstr(mn, 14, 0, "*** Atomic number 86 may be misleading.  The program is designed");
X	mvwaddstr(mn, 15, 0, "*** to compensate, but nothing is perfect.");
X	mvwaddstr(mn, 16, 0, ">>> PRESS RETURN TO RETURN TO MAIN MENU.");
Xfirst:	mvwaddstr(mn, 11, 0, "Your choice: ");
X	wrefresh(mn);				/* collect their choices */
X	cur = mn; xp = 14; yp = 11;
X	crmode();
X	noecho();
X	c1 = getchar();	/* X axis chc */
X	if (c1 == '?') { help(3); goto first; }
X	if (c1 == '\n') {
X#ifdef	USERSHELL
X		signal(SIGTSTP, stop);
X#endif	USERSHELL
X		wclear(mn);
X		return;
X	}
X	if (c1 < 'a' || c1 > 'j')
X		goto first;
X	for (i = 12; i < 17; i++) {
X		wmove(mn, i, 0); wclrtoeol(mn);
X	}
X
X	find(c1, e->anum);
X	xmax = xmin = x;
X	if (gtot > 0) {
X		for (tmp = e; tmp->next != NULL; tmp = tmp->next) {
X			find(c1, tmp->anum);
X			if (x == -999.0) continue;
X			if (x > xmax) xmax = x;
X			if (x < xmin) xmin = x;
X		}
X	} else {
X		for (i = 1; i < gtot; i++) {
X			find(c1, sub1[i]);
X			if (x == -999.0) continue;
X			if (i == 1) xmax = xmin = x;
X			else {
X				if (x > xmax) xmax = x;
X				if (x < xmin) xmin = x;
X			}
X		}
X	}
X
X	mvwaddstr(mn, 10, 0, "If you would rather use the maximum and minimum values of");
X	mvwaddstr(mn, 11, 0, "all the elements, hit RETURN once.");
X	wmove(mn, 12, 0); wprintw(mn, "All the element's values: Minimum %f, Maximum %f", xmin, xmax);
Xrl4:	mvwaddstr(mn, 13, 0, "What range, X Minimum? ");
X	wrefresh(mn);
X	cur = mn; xp = 23; yp = 13;
X	echo(); nocrmode();
X	gets(str);
X	if (str[0] == '?') { help(4); goto rl4; }
X	if (!strlen(str)) {
X		xmin = -999;
X		goto nt;
X	}
X	xmin = atof(str);
X	fixup(mn); fixup(stdscr);
X	mvwaddstr(mn, 13, 0, "What range, X Maximum [RETURN for value above]? ");
X	wrefresh(mn);
X	cur = mn; xp = 49; yp = 13;
X	echo(); nocrmode();
X	gets(str);
X	if (strlen(str))
X		xmax = atof(str);
X	fixup(mn);
X	
Xnt:	wmove(mn, 10, 0); wclrtoeol(mn); wmove(mn, 11, 0); wclrtoeol(mn);
X	mvwaddstr(mn, 10, 0, "Graphing by this, down the Y axis.   ");
Xscnd:	wmove(mn, 12, 0); wclrtoeol(mn); wmove(mn, 13, 0); wclrtoeol(mn);
X	mvwaddstr(mn, 11, 0, "Your choice: ");
X	wrefresh(mn);
X	cur = mn; xp = 13; yp = 11;
X	noecho(); crmode();
X	c2 = wgetch(mn); /* Y axis chc */
X	if (c2 == '?') { help(5); goto scnd; }
X	if (c2 < 'a' || c2 > 'j')
X		goto scnd;
X	noecho();
X
X	/* Here we find the x axis max and min values */
X
X	bot("Calculating the X axis max and min values...");
X
X	if (xmin == -999) {
X		find(c1, e->anum);
X		xmax = xmin = x;
X		for (tmp = e; tmp->next != NULL; tmp = tmp->next) {
X			find(c1, tmp->anum);
X			if (x == -999.0) continue;
X			if (x > xmax) xmax = x;
X			if (x < xmin) xmin = x;
X		}
X	}
X
X	/* Here we find the y axis min and max values */
X	bot("Calculating the Y axis max and min values...");
X
X	if (gtot > 0) {
X		find(c2, e->anum);
X		ymax = ymin = x;
X		for (tmp = e; tmp->next != NULL; tmp = tmp->next) {
X			find(c2, tmp->anum);
X			if (x == -999.0) continue;
X			if (x > ymax) ymax = x;
X			if (x < ymin) ymin = x;
X		}
X	} else {
X		for (i = 1; i < gtot; i++) {
X			find(c2, sub1[i]);
X			if (x == -999.0) continue;
X			if (i == 1)
X				ymax = ymin = x;
X			else {
X				if (x > ymax) ymax = x;
X				if (x < ymin) ymin = x;
X			}
X		}
X	}
X
X	/* Now we have min & maxs we have to put a number in
X	   each slot on both axes using the scale */
X
X	bot("Scaling...");
X	scale = (xmax - xmin) / (double)XAXISDEF;
X	xaxis[1] = xmin;
X	for (i = 2; i < XAXISDEF; i++)
X		xaxis[i] = xaxis[i-1] + scale;
X
X	scale = (ymax - ymin) / (double)YAXISDEF;
X	yaxis[YAXISDEF-1] = ymin;
X	for (i = YAXISDEF-2; i > 1; i--)
X		yaxis[i] = yaxis[i+1] + scale;
X
Xrl6:	noecho(); crmode();
X	mvwaddstr(btm, 0, 0, "Would you like a grid? ");
X	wrefresh(btm);
X	cur = btm; xp = 24; yp = 0;
X	switch(getchar()) {
X		case 'y':
X		case 'Y': grid = 1; break;
X		case '?': help(6); goto rl6;
X		default:  grid = 0; break;
X	}
X	if (c1 < 'c') {
Xrl7:		mvwaddstr(btm, 0, 0, "Would you like the points connected? ");
X		wrefresh(btm);
X		cur = btm; xp = 38; yp = 0;
X		switch(getchar()) {
X			case '?': help(7); goto rl7;
X			case 'y': case 'Y': connect = 1; break;
X			default: connect = 0; break;
X		}
X	} else connect = 0;
Xrl8:	wclear(btm);
X	mvwaddstr(btm, 0, 0, "Would you like dots instead of hashmarks (slower) ");
X	wrefresh(btm);
X	cur = btm; xp = 44; yp = 0;
X	switch(getchar()) {
X		case 'y': case 'Y': type = 1; break;
X		case '?': help(8); goto rl8;
X		default: type = 0; break;
X	}
X#ifdef	LASERPRT
Xrl9:	wclear(btm);
X	mvwaddstr(btm, 0, 0, "Would you like a laser print file of this? ");
X	wrefresh(btm);
X	cur = btm; xp = 40; yp = 0;
X	switch(getchar()) {
X		case 'y': case 'Y': laser = 1; break;
X		case '?': help(19); goto rl9;
X		default: laser = 0; break;
X	}
X	if (laser == 1) {
X		if ((lsr = fopen("laser", "w")) == NULL) {
X			bot("Sorry, the file 'laser' could not be opened for writing.");
X			sleep(2);
X			bot("No laser print document will be made.");
X			sleep(2);
X			bot(" ");
X			laser = 0;
X		} else
X			fprintf(lsr, "\014");
X		bot("A copy will be found in the file 'laser' when you exit chemtab.");
X		sleep(2);
X	}
X#endif	LASERPRT
X	bot("Initializing for graphics...");
X	wclear(mn); wrefresh(mn);
X	wclear(btm); wrefresh(btm);
X	clear(); refresh();
X
X	initregis();
X	regisgoto(450, 10);
X	chcolor(RED_3);
X	text(3, 0, -5, "Chemtab V2.01");
X	regisgoto(400 - (strlen(gname[numr(c1)]) * 10), YMAXDEF + 20);
X	text(2, 0, 0, gname[numr(c1)]);
X	regisgoto(YMINDEF - 46, 200 + (strlen(gname[numr(c2)]) * 10));
X	text(2, 90, 0, gname[numr(c2)]);
X	chcolor(WHT_3);
X	mybox(1, XMINDEF, YMINDEF, XMAXDEF, YMAXDEF);
X	mybox(2, 0, 0, 798, 478);
X	for (i = YAXISDEF-1; i > 1; i -= YAXISDEF/7) {
X		if (c2 < 'f' || c2 > 'i')
X			sprintf(str, "%d -", (int)(yaxis[i]+.5));
X		else if (yaxis[i] > 9.99)
X			sprintf(str, "%2.3f", yaxis[i]);
X		else
X			sprintf(str, "%2.3f", yaxis[i]);
X		chcolor(BLU_3);
X		if (grid) line(XMINDEF, i+YBOUND+1, XMAXDEF, i+YBOUND+1);
X		chcolor(RED_3);
X		regisgoto(XMINDEF-60, i-7+YBOUND);
X		text(1, 0, 5, str);
X	}
X	for (i = 1; i < XAXISDEF; i += XAXISDEF/10) {
X		if (c1 < 'f' || c1 > 'i')
X			sprintf(str, "%d", (int)(xaxis[i]+.5));
X		else
X			sprintf(str, "%4.2f", xaxis[i]);
X		chcolor(BLU_3);
X		if (grid && i < XAXISDEF-20) line(i+XBOUND+1, YMINDEF, i+XBOUND+1, YMAXDEF);
X		chcolor(RED_3);
X		regisgoto(i-6+XBOUND, YMAXDEF+2);
X		text(1, 0, 5, str);
X	}
X
X	firstup++;
X	if (gtot <= 0) {
X		for (tmp = e; tmp->next != NULL; tmp = tmp->next) {
X			find(c1, tmp->anum);
X			if (x == -999.0) continue;
X			if (x < xmin)
X				continue;
X			else if (x < xaxis[2])
X				xspot = 1;
X			else {
X				for (j = 2; j < XAXISDEF; j++) {
X					if (x > xaxis[j])
X						continue;
X					else
X						break;
X				}
X				xspot = j;
X				if (x > xmax)
X					continue;
X			}
X
X			/* Found where it goes on the x, now the y */
X
X			find(c2, tmp->anum);	
X			if (x == -999.0) continue;
X			if (x < yaxis[YAXISDEF-1])
X				yspot = YAXISDEF-1;
X			else {
X				for (j = YAXISDEF-2; j > 1; j--) {
X					if (x > yaxis[j])
X						continue;
X					else
X						break;
X				}
X				yspot = j;
X			}
X			chcolor(YEL_3);
X			if (firstup) { lastx = xspot; lasty = yspot; firstup = 0; }
X			if (connect && i != 1) {
X				chcolor(GRN_3);
X				line(xspot+XBOUND, yspot+YBOUND, lastx+XBOUND, lasty+YBOUND);
X				lastx = xspot; lasty = yspot;
X			}
X			hash(xspot+XBOUND, yspot+YBOUND, type);
X		}
X	} else {
X		for (i = 1; i < gtot; i++) {
X			find(c1, sub1[i]);
X			if (x == -999.0) continue;
X			if (x < xmin)
X				continue;
X			else if (x < xaxis[2])
X				xspot = 1;
X			else {
X				for (j = 2; j < XAXISDEF; j++) {
X					if (x > xaxis[j])
X						continue;
X					else
X						break;
X				}
X				xspot = j;
X				if (x > xmax)
X					continue;
X			}
X
X			/* Found where it goes on the x, now the y */
X
X			find(c2, sub1[i]);
X			if (x == -999.0) continue;
X			if (x < yaxis[YAXISDEF-1])
X				yspot = YAXISDEF-1;
X			else {
X				for (j = YAXISDEF; j > 1; j--) {
X					if (x > yaxis[j])
X						continue;
X					else
X						break;
X				}
X				yspot = j;
X			}
X			chcolor(YEL_3);
X			if (i == 1) lastx = xspot, lasty = yspot;
X			if (connect && i != 1) {
X				chcolor(GRN_3);
X				line(xspot+XBOUND, yspot+YBOUND, lastx+XBOUND, lasty+YBOUND);
X				lastx = xspot; lasty = yspot;
X			}
X			hash(xspot+XBOUND, yspot+YBOUND, type);
X		}
X	}
X	regispc();
X	endregis();
X#ifdef	LASERPRT
X	if (laser)
X		fclose(lsr);
X#endif	LASERPRT
X	clear(); refresh();
X	wclear(graph); wrefresh(graph);
X#ifdef	USERSHELL
X	signal(SIGTSTP, stop);
X#endif	USERSHELL
X	return(0);
X#endif ReGIS
X}
END_OF_FILE
  if test 10517 -ne `wc -c <'doregisgph.c'`; then
    echo shar: \"'doregisgph.c'\" unpacked with wrong size!
  fi
  # end of 'doregisgph.c'
fi
if test -f 'elist' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'elist'\"
else
  echo shar: Extracting \"'elist'\" \(8311 characters\)
  sed "s/^X//" >'elist' <<'END_OF_FILE'
XName         Sy   Z    MASS FM R V MELT BOIL FIO YEAR  ENG SPHT  DENS ARD
X
Xactinium     Ac  89 227.028  1 7 9 1050 3200 159 1899 -1.5  -1.5 10.1 -1.5
Xaluminum     Al  13  26.982 13 3 3  660 2467 138 1827  1.5 0.215 2.70 1.43
Xamericium    Am  95 243.000  7 9 9  994 2607 138 1944 -1.5  -1.5 11.7 -1.5
Xantimony     Sb  51 121.753 15 5 5  631 1750 199 1700  1.9 0.049 6.69 1.41
Xargon	     Ar  18  39.948 18 3 0 -189 -186 362 1894 -1.5 0.124 1.40 1.74
Xarsenic      As  33  74.922 15 4 5  817  613 226 1649  2.0 0.078 5.73 1.21
Xastatine     At  85 210.000 17 6 7  302  337  -1 1940  2.2  -1.5 -1.5 1.40
Xbarium       Ba  56 137.327  2 6 2  725 1640 120 1774  0.9 0.046 3.50 2.17
Xberkelium    Bk  97 247.000  9 9 3 -273 -273  -1 1949 -1.5  -1.5 -1.5 -1.5
Xberyllium    Be   4   9.012  2 2 2  127 2970 214 1798  1.5 0.436 1.85 1.12
Xbismuth      Bi  83 208.980 15 6 5  271 1560 168 1753  1.9 0.029 9.80 1.46
Xboron	     B    5  10.811 13 2 3 2079 2550 191 1808  2.0 0.245 2.34 0.88
Xbromine      Br  35  79.904 17 4 7   -7   59 272 1826  2.8 0.113 3.12 1.14
Xcadminium    Cd  48 112.411 12 5 2  321  765 207 1817  1.7 0.055 8.02 1.48
Xcalcium	     Ca  20  40.078  2 4 2  839 1484 141 1808  1.0 0.156 1.54 1.97
Xcalifornium  Cf  98 251.000 10 9 9 -273 -273  -1 1950 -1.5  -1.5 -1.5 -1.5
Xcarbon	     C    6  12.011 14 2 4 3550 4827 259   -1  2.5 0.170 2.25 0.77
Xcerium       Ce  58 140.115  2 8 9  798 3257 126 1803  1.1 0.049 6.70 -1.5
Xcesium       Cs  55 132.905  1 6 1   28  669  90 1860  0.7 0.057 1.84 2.62
Xchlorine     Cl  17  35.452 17 3 7 -101  -35 298 1774  3.0 0.114 1.37 0.99
Xchromium     Cr  24  51.996  6 4 9 1857 2672 156 1798  1.6 0.107 7.18 1.25
Xcobalt	     Co  27  58.933  9 4 9 1495 2870 181 1735  1.8 0.109 8.90 1.25
Xcopper	     Cu  29  63.546 11 4 9 1083 2567 178   -1  1.9 0.092 8.96 1.20
Xcurium       Cm  96 247.000  8 9 3 1340 -273  -1 1944 -1.5  -1.5 -1.5 -1.5
Xdysprosium   Dy  66 162.503 10 8 3 1409 2335 136 1886  1.2 0.041 8.50 -1.5
Xeinsteinum   Es  99 254.000 11 9 9 -273 -273  -1 1952 -1.5  -1.5 -1.5 -1.5
Xerbium       Er  68 167.263 12 8 3 1522 2510 140 1842  1.2 0.040 9.10 -1.5
Xeuropium     Eu  63 151.965  7 8 2  822 1597 130 1890  1.2 0.042 5.30 -1.5
Xfermium      Fm 100 257.000 12 9 9 -273 -273  -1 1952 -1.5  -1.5 -1.5 -1.5
Xfluorine     F    9  18.998 17 2 7 -220 -188 401 1886  4.0 0.197 1.11 0.64
Xfrancium     Fr  87 223.000  1 7 1   27  677  -1 1939  0.7  -1.5 -1.5 2.70
Xgadolinium   Gd  64 157.253  8 8 3 1311 3233 141 1880  1.1 0.055 7.90 -1.5
Xgallium      Ga  31  69.723 13 4 3   30 2403 138 1875  1.6 0.089 5.91 1.22
Xgermanium    Ge  32  72.612 14 4 4  937 2830 182 1886  1.8 0.077 5.32 1.22
Xgold         Au  79 196.967 11 6 1 1064 3080 212   -1  2.4 0.031 19.3 1.50
Xhafnium      Hf  72 178.492  4 6 4 2227 4602 161 1923  1.3 0.035 13.1 1.65
Xhelium	     He   2   4.003 18 1 0 -272 -269 563 1868 -1.5 1.240 0.18 0.93
Xholmium      Ho  67 164.930 11 8 3 1470 2720 138 1878  1.1 0.039 8.80 -1.5
Xhydrogen     H    1   1.008  1 1 1 -259 -253 313 1766  2.2 3.410 0.09 0.30
Xindium       In  49 114.821 13 5 3  157 2080 133 1924  1.7 0.056 7.30 1.44
Xiodine       I   53 126.904 17 5 7  114  184 240 1811  2.5 0.010 4.94 1.33
Xiridium      Ir  77 192.223  9 6 3 2410 4130 209 1803  2.2 0.032 22.5 1.48
Xiron	     Fe  26  55.847  8 4 9 1535 2750 181   -1  1.8 0.106 7.87 1.26
Xkrypton      Kr  36  83.801 18 4 0 -157 -152 322 1898 -1.5 0.059 2.16 1.89
Xlanthanium   La  57 138.906  1 6 9  920 3454 128 1839  1.1 0.047 6.20 1.69
Xlawrencium   Lr 103 260.000 15 9 3 -273 -273  -1 1961 -1.5  -1.5 -1.5 -1.5
Xlead         Pb  82 207.210 14 6 4  328 1720 171   -1  1.8 0.038 11.4 1.75
Xlithium	     Li   3   6.941  1 2 1  181 1342 124 1817  1.0 0.834 0.53 1.52
Xlutetium     Lu  71 174.967 15 8 3 1656 3315 125 1907  1.2 0.037 9.80 -1.5
Xmagnesium    Mg  12  24.305  2 3 2  649 1090 176 1755  1.2 0.245 1.74 1.60
Xmanganese    Mn  25  54.938  7 4 9 1244 1962 171 1774  1.5 0.114 7.21 1.29
Xmendelevium  Md 101 258.000 13 9 3 -273 -273  -1 1955 -1.5  -1.5 -1.5 -1.5
Xmercury      Hg  80 200.593 12 6 1  -39  357 240   -1  1.9 0.033 13.6 1.49
Xmolybdenum   Mo  42  95.941  6 5 6 2617 4612 163 1778  1.8 0.060 9.35 1.47
Xneodymium    Nd  60 144.243  4 8 3 1010 3127 126 1841  1.1 0.049 7.00 -1.5
Xneon	     Ne  10  20.180 18 2 8 -249 -246 496 1898 -1.5 0.246 1.21 1.31
Xneptunium    Np  93 237.048  5 9 4  640 3902  -1 1940 -1.5  -1.5 19.5 -1.5
Xnickel	     Ni  28  58.691 10 4 9 1453 2732 176 1751  1.8 0.106 8.90 1.24
Xniobium      Nb  41  92.906  5 5 5 2468 4742 158 1801  1.6 0.064 7.83 1.48
Xnitrogen     N    7  14.007 15 2 5 -210 -196 334 1772  3.0 0.249 0.81 0.70
Xnobelium     No 102 259.000 14 9 4 -273 -273  -1 1958 -1.5  -1.5 -1.5 -1.5
Xosmium       Os  76 190.210  8 6 8 3045 5027 200 1803  2.2 0.031 22.6 1.52
Xoxygen	     O    8  15.999 16 2 6 -218 -183 313 1774  3.5 0.219 1.14 0.66
Xpalladium    Pd  46 106.421 10 5 4 1554 3140 192 1803  2.2 0.058 10.7 1.44
Xphosphorous  P   15  30.974 15 3 5   44  280 350 1669  2.1 0.181 0.82 1.10
Xplatinum     Pt  78 195.083 10 6 4 1772 3827 207 1735  2.2 0.031 21.4 1.45
Xplutonium    Pu  94 244.000  6 9 5  641 3232 133 1940 -1.5  -1.5 19.5 -1.5
Xpolonium     Po  84 209.000 16 6 6  254  962 194 1898  2.0 0.030 9.20 1.40
Xpotassium    K   19  39.098  1 4 1   64  774 100 1807  0.8 0.180 0.86 2.31
Xpraeseodymium Pr  59 140.908  3 8 3  931 3212 125 1841 1.2 0.046 6.80 -1.5
Xpromethium   Pm  61 145.000  5 8 3 1080 2460 128 1902  1.1 0.044 -1.5 -1.5
Xprotactinium Pa  91 231.035  3 9 4 1600 -273  -1 1913 -1.5 0.029 15.4 -1.5
Xradium       Ra  88 226.025  2 7 2  700 1140 121 1898  0.9 0.028 -1.5 2.20
Xradon        Rn  86 222.000 18 6 0  -71  -62 247 1908 -1.5 0.022 -1.5 2.14
Xrhenium      Re  75 186.207  7 6 7 3180 5627 181 1925  1.9 0.033 21.0 1.56
Xrhodium      Rh  45 102.905  9 5 6 1966 3727 172 1803  2.2 0.058 11.1 1.45
Xrubidium     Rb  37  85.468  1 5 1   39  688  96 1861  0.8 0.086 1.53 2.44
Xruthenium    Ru  44 101.072  8 5 8 2310 3900 170 1827  2.2 0.057 10.9 1.46
Xsamarium     Sm  62 150.363  6 8 2 1072 1778 129 1879  1.2 0.043 7.50 -1.5
Xscandium     Sc  21  44.956  3 4 9 1539 2832 150 1879  1.3 0.133 2.99 1.60
Xselenium     Se  34  78.963 16 4 6  217  685 224 1818  2.4 0.077 4.79 1.17
Xsilicon	     Si  14  28.086 14 3 4 1410 2355 187 1824  1.8 0.169 2.33 1.17
Xsilver       Ag  47 107.868 11 5 2  962 2212 174   -1  1.9 0.057 9.32 1.53
Xsodium	     Na  11  22.990  1 3 1   98  883 118 1807  0.9 0.292 0.97 1.86
Xstrontium    Sr  38  87.621  2 5 2  769 1384 131 1790  1.0 0.072 2.63 2.15
Xsulfur	     S   16  32.066 16 3 6  113  445 238   -1  2.5 0.175 2.06 1.04
Xtantalum     Ta  73 180.948  5 6 5 2996 5425 181 1844  1.5 0.033 16.6 1.62
Xtechnetium   Tc  43  98.000  7 5 7 2172 4877 167 1925  1.9 0.058 11.5 1.47
Xtellurium    Te  52 127.603 16 5 6  450  990 207 1782  2.1 0.048 5.75 1.37
Xterbium      Tb  65 158.925  9 8 3 1360 3041 135 1843  1.2 0.044 8.30 -1.5
Xthallium     Tl  81 204.383 13 6 3  304 1457 140 1861  1.8 0.031 11.9 1.48
Xthorium      Th  90 232.038  2 9 4 1750 4790 139 1828 -1.5 0.027 11.7 -1.5
Xthullium     Tm  69 168.934 13 8 2 1545 1727 142 1879  1.2 0.038 9.10 -1.5
Xtin          Sn  50 118.710 14 5 4  232 2270 169   -1  1.8 0.052 6.98 1.40
Xtitanium     Ti  22  47.883  4 4 9 1660 3287 157 1791  1.4 0.125 4.54 1.46
Xtungsten     W   74 183.853  6 6 6 3410 5660 184 1779  1.7 0.032 19.3 1.60
Xunnilennium  Une 109 266.000  9 7 9 -273 -273  -1 1982 -1.5  -1.5 -1.5 -1.5
Xunnilhexium  Unh 106 263.000  6 7 9 -273 -273  -1 1974 -1.5  -1.5 -1.5 -1.5
Xunniloctium  Uno 108 265.000  8 7 9 -273 -273  -1 1980 -1.5  -1.5 -1.5 -1.5
Xunnilpentium Unp 105 262.000  5 7 9 -273 -273  -1 1967 -1.5  -1.5 -1.5 -1.5
Xunnilquadium Unq 104 261.000  4 7 9 -273 -273  -1 1964 -1.5  -1.5 -1.5 -1.5
Xunnilseptium Uns 107 262.000  7 7 9 -273 -273  -1 1976 -1.5  -1.5 -1.5 -1.5
Xunununium    Unu 110 272.000 10 7 9 -273 -273  -1 1987 -1.5  -1.5 -1.5 -1.5
Xuranium      U   92 238.028  4 9 6 1132 3818  -1 1789 -1.5 0.028 19.1 -1.5
Xvanadium     V   23  50.941  5 4 9 1890 3380 155 1831  1.6 0.116 6.09 1.31
Xxenon        Xe  54 131.292 18 5 0 -112 -107 279 1898 -1.5 0.038 -1.5 2.09
Xytterbium    Yb  70 173.043 14 8 2  824 1193 144 1878  1.2 0.035 7.00 -1.5
Xyttrium      Y   39  88.906  3 5 3 1523 3337 147 1794  1.2 0.068 4.47 1.62
Xzinc	     Zn  30  65.392 12 4 9  420  907 216 1746  1.6 0.093 7.13 1.33
Xzirconium    Zr  40  91.224  4 5 4 1852 4377 157 1824  1.4 0.067 5.80 1.48
END_OF_FILE
  if test 8311 -ne `wc -c <'elist'`; then
    echo shar: \"'elist'\" unpacked with wrong size!
  fi
  # end of 'elist'
fi
if test -f 'esort.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'esort.c'\"
else
  echo shar: Extracting \"'esort.c'\" \(3526 characters\)
  sed "s/^X//" >'esort.c' <<'END_OF_FILE'
X
X/*
X * chemtab - a periodic table data base (C) 1990 Jim King (pulsar@lsrhs)
X *
X * esort.c	Takes the changed values to look for and sifts to sub1
X */
X
X#include "element.h"
X#include "undefs.h"
X#include "variables.h"
X#include "tune.h"
X#include <curses.h>
X#include "windows.h"
X
X
Xint	sift[3][120],	/* Enough spaces to carry all the elements through
X			   the sifting process 3 times. */
X	sftc[3];	/* number telling the amount of elements in sift[x] */
Xint	tmp[120],	/* A place to put compared elements from 1&2 & 2&3 */
X	tc;		/* The temp[x] counter */
X
X/*
X * esort() - no input
X *
X * purpose:	Take the selecting characteristics from dosort[x] which are
X *		defined in schar() and sift the elements through them, then
X *		see what's left and store it away.
X */
Xesort()
X{
X	struct	elem	*tempo;
X	int	i, j, k;		/* loops */
X
X	x = 0.0;			/* floating integer for cmp */
X
X	if (dosort[0].wch == 0)			/* No chars to sort */
X		return(1);
X
X	tc = gtot = 0;				/* Reset counter */
X	for (i = 0; i < 120; i++) {
X		sub1[i] = 0;			/* Clear the olds */
X		sift[0][i] = sift[1][i] = sift[2][i] = 0;
X		tmp[i] = 0;
X	}
X	sftc[0] = sftc[1] = sftc[2] = 0;
X
X	for (i = 0; i < 3; i++) {
X		if (dosort[i].wch != 0) {	/* Sort on this */
X			for (tempo = e; tempo != NULL; tempo = tempo->next) {
X				switch(dosort[i].wch) {
X					case 1: x = tempo->anum;  break;
X					case 2: x = tempo->amass; break;
X					case 3: x = tempo->fam;   break;
X					case 4: x = tempo->row;   break;
X					case 5: x = tempo->val;   break;
X					case 6: x = tempo->melt;  break;
X					case 7: x = tempo->boil;  break;
X					case 8: x = tempo->fio;   break;
X					case 9: x = tempo->year;  break;
X					case 10: x = tempo->eneg; break;
X					case 11: x = tempo->spht; break;
X					case 12: x = tempo->dens; break;
X					case 13: x = tempo->arad; break;
X					default:              break;
X				}
X				if ((x > dosort[i].amt && dosort[i].sgn == GREATER) ||
X				    (x < dosort[i].amt && dosort[i].sgn == LESS) ||
X				    (x == dosort[i].amt && dosort[i].sgn == EQUAL) ||
X				    (x >= dosort[i].amt - closev[dosort[i].wch] && x <= dosort[i].amt + closev[dosort[i].wch] && dosort[i].sgn == CLOSE)) {
X					if (!((dosort[i].wch == 5 && x == VAL) ||
X					    (dosort[i].wch == 6 && x == MEL) ||
X					    (dosort[i].wch == 7 && x == BOI) ||
X					    (dosort[i].wch == 8 && x == FIO) ||
X					    (dosort[i].wch == 10 && x == ENG) ||
X					    (dosort[i].wch == 11 && x == SPHT) ||
X					    (dosort[i].wch == 12 && x == DENS) ||
X					    (dosort[i].wch == 13 && x == ARD))) {
X						sftc[i]++;
X						sift[i][sftc[i]] = tempo->anum;
X					    }
X				}
X			}
X		}
X	}
X					/* Now sift each to other */
X					/* Compare 1 and 2 into tmp[] */
X	if (dosort[1].wch == 0) {	/* Only 1 sort */
X		for (i = 1; i < 120; i++) /* Copy sift[0] into sub1 */
X			sub1[i] = sift[0][i];
X		goto end;
X	}
X	for (j = 1; j < 120; j++) {	/* Compare sift[1] and sift[0] */
X		if (sift[0][j] != 0) {	/* If something to compare */
X			for (k = 1; k < 120; k++) {
X				if (sift[0][j] == sift[1][k]) {
X					tc++;	/* Match */
X					tmp[tc] = sift[0][j];
X				}
X			}
X		}
X	}
X	if (dosort[2].wch == 0) {	/* Only 2 sorts */
X		for (i = 1; i < 120; i++) /* Copy tmp into sub1 */
X			sub1[i] = tmp[i];
X		goto end;
X	}
X					/* Now sift tmp[] with sift[2] */
X	for (i = 1; i < 120; i++) {
X		if (tmp[i] != 0) {
X			for (j = 1; j < 120; j++) {
X				if (tmp[i] == sift[2][j]) {
X					++gtot;
X					sub1[gtot] = tmp[i]; /* Match */
X				}
X			}
X		}
X	}
X	goto rend;
Xend:	for (i = 1; i < 120; i++) {
X		if (sub1[i] != 0)
X			gtot++;
X	}
Xrend:	/* This is the end! */
X	tc = 0;
X	return(0);
X}
END_OF_FILE
  if test 3526 -ne `wc -c <'esort.c'`; then
    echo shar: \"'esort.c'\" unpacked with wrong size!
  fi
  # end of 'esort.c'
fi
if test -f 'looke.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'looke.c'\"
else
  echo shar: Extracting \"'looke.c'\" \(6499 characters\)
  sed "s/^X//" >'looke.c' <<'END_OF_FILE'
X/*
X * chemtab - a periodic table data base (C) 1990 Jim King pulsar@lsrhs
X *
X * looke.c - look for an element, then print known stats
X */
X
X#include <curses.h>
X#include <stdio.h>
X#include <ctype.h>
X#include "element.h"
X#include "variables.h"
X#include "tune.h"
X#include "windows.h"
X#include "undefs.h"
X
X/*
X * matchstr(str)
X * input: string
X * return: int (number if found, 0 if not, -1 if ambiguous)
X * purpose: match chemical names
X */
Xint	matchstr(str)
Xchar	*str;
X{
X	int	last, len, count = 0;
X	struct	elem	*tmp;
X
X	len = strlen(str);
X
X	for (tmp = e; tmp != NULL; tmp = tmp->next) {
X		if (!strncmp(str, tmp->name, len)) {
X			last = tmp->anum;
X			count++;
X		}
X	}
X	
X	if (!count) return(0);
X	else if (count > 1) return(-1);
X	else return(last);
X}
X
X/*
X * getlows(str)
X *	input: none
X *	output: string
X *	purpose: get a lowercase string
X */
Xchar *getlows()
X{
X	char	input[80];
X	int	i;
X
X	gets(input);
X	for (i = 0; i < strlen(input); i++)
X		input[i] = tolower(input[i]);
X
X	return(input);
X}
X
X/*
X * disp(l)
X *	input:	l - int - referring to atomic number of elem. to display
X *	output: curses only
X *
X * purpose:	separate the displaying from the rest of the subroutine
X */
Xdisp(l)
Xint	l;
X{
X	struct	elem	*tmp;
X	int	i;
X
X	for (tmp = e; l != tmp->anum; tmp = tmp->next) ;
X
X	wclear(mn); wrefresh(mn);
X	wclear(graph);
X	wmove(graph, 0, 0); wprintw(graph, "Atomic Name: %s", tmp->name);
X	wmove(graph, 1, 0); wprintw(graph, "Atomic Symbol: %s", tmp->sym);
X	wmove(graph, 2, 0); wprintw(graph, "Atomic Number: %d", tmp->anum);
X	wmove(graph, 3, 0); wprintw(graph, "Atomic Mass: %3.3f a.m.u.", tmp->amass);
X
X	if (tmp->melt == MEL)
X		mvwaddstr(graph, 5, 0, "Melting Temp: NOT AVAILABLE");
X	else {
X		wmove(graph, 5, 0); wprintw(graph, "Melting Temp: %d Celcius (%4.0f Fahrenheit, %d Kelvin)", tmp->melt, ((float)tmp->melt * (9.0 / 5.0) + 32.0), tmp->melt + 273);
X	}
X	if (tmp->boil == BOI)
X		mvwaddstr(graph, 6, 0, "Boiling Temp: NOT AVAILABLE");
X
X	else {
X		wmove(graph, 6, 0); wprintw(graph, "Boiling Temp: %d Celcius (%4.0f Fahrenheit, %d Kelvin)", tmp->boil, ((float)tmp->boil * (9.0 / 5.0) + 32.0), tmp->boil + 273);
X	}
X	if (tmp->spht == SPHT)
X		mvwaddstr(graph, 8, 0, "Specific Heat: NOT AVAILABLE");
X	else {
X		wmove(graph, 8, 0); wprintw(graph, "Specific Heat: %1.3f Calories/gram-Celcius", tmp->spht);
X	}
X	if (tmp->dens == DENS)
X		mvwaddstr(graph, 9, 0, "Density: NOT AVAILABLE");
X	else {
X		wmove(graph, 9, 0); wprintw(graph, "Density: %2.2f gram/cm cubed", tmp->dens);
X	}
X	if (tmp->arad == ARD)
X		mvwaddstr(graph, 10, 0, "Atomic Radius: NOT AVAILABLE");
X	else {
X		wmove(graph, 10, 0); wprintw(graph, "Atomic Radius: %1.2f Angstroms", tmp->arad);
X	}
X	if (tmp->eneg == ENG)
X		mvwaddstr(graph, 11, 0, "Electronegativity: NOT AVAILABLE");
X	else {
X		wmove(graph, 11, 0); wprintw(graph, "Electronegativity: %1.1f", tmp->eneg);
X	}
X	if (tmp->year == YEA)
X		mvwaddstr(graph, 12, 0, "Discovery Year: ANCIENT, B.C.");
X	else {
X		wmove(graph, 12, 0); wprintw(graph, "Discovery Year: %d A.D.", tmp->year);
X	}
X	mvwaddstr(graph, 14, 0, "Family: ");
X	switch(tmp->fam) {
X		case 1: wprintw(graph, "IA (1)"); break;
X		case 2: wprintw(graph, "IIA (2)"); break;
X		case 3: wprintw(graph, "IB (3)"); break;
X		case 4: wprintw(graph, "IIB (4)"); break;
X		case 5: wprintw(graph, "IIIB (5)"); break;
X		case 6: wprintw(graph, "IVB (6)"); break;
X		case 7: wprintw(graph, "VB (7)"); break;
X		case 8: wprintw(graph, "VIB (8)"); break;
X		case 9: wprintw(graph, "VIIB (9)"); break;
X		case 10: wprintw(graph, "VIIIB (10)"); break;
X		case 11: wprintw(graph, "VIXB (11)"); break;
X		case 12: wprintw(graph, "VXB (12)"); break;
X		case 13: wprintw(graph, "IIIA (13)"); break;
X		case 14: wprintw(graph, "IVA (14)"); break;
X		case 15: wprintw(graph, "VA (15)"); break;
X		case 16: wprintw(graph, "VIA (16)"); break;
X		case 17: wprintw(graph, "VIIA (17)"); break;
X		case 18: wprintw(graph, "VIIIA (18)"); break;
X		default: break;
X	}
X	wmove(graph, 15, 0);
X	wprintw(graph, "Row: %d\n", tmp->row);
X	wrefresh(graph);
X	capture(graph, 0, 0);
X	spc();	/* space to continue? */
X}
X	
Xlooke()
X{
X	struct	elem	*tmp;
X	char	*strn,				/* Random input string */
X		srch[80],			/* String comparison */
X		c = '5';			/* choice input */
X	int	i, elk;
X
X	noecho(); crmode();
X	wclear(mn); wrefresh(mn);
X	wclear(srt); wrefresh(srt);
X	clear(); refresh();
X
X	menu("View Elemental Information");
X	mvwaddstr(mn, 2, 0, "Look for element by:");
X	mvwaddstr(mn, 4, 0, "1] Atomic Name");
X	mvwaddstr(mn, 5, 0, "2] Atomic Number");
X	mvwaddstr(mn, 6, 0, "3] Atomic Symbol");
X	mvwaddstr(mn, 7, 0, "4] Return to Main Menu");
Xl9:	mvwaddstr(mn, 9, 0, "Your Choice? ");
X	wrefresh(mn);
X	cur = mn; xp = 14; yp = 9;
X	noecho();
X	crmode();
Xgo:	c = wgetch(mn);
X	if (c == '?') { help(9); goto l9; }
X	if (c < '1' || c > '4') goto go;
X
X	if (c == '4') {
X		wprintw(mn, "Return to Main Menu.");
X		wrefresh(mn);
X		wclear(mn);
X		return(0);
X	}
X	
X	if (c == '1') {		/* look by name */
X		wprintw(mn, "Look by Name (type in full or part of an element name)");
X		wclrtoeol(mn);
Xl10:		mvwaddstr(mn, 11, 0, "Name of Element: ");
X		wrefresh(mn);
X		cur = mn; xp = 17; yp = 11;
X		echo();
X		nocrmode();
X		strcpy(srch, getlows());
X		if (srch[0] == '?') { help(10); goto l10; }
X	}
X
X	if (c == '2') {		/* look by number */
X		wprintw(mn, "Look by Number");
X		wclrtoeol(mn);
Xl11:		mvwaddstr(mn, 11, 0, "Atomic Number:   ");
X		wrefresh(mn);
X		cur = mn; xp = 17; yp = 11;
X		echo();
X		nocrmode();
X		gets(srch);
X		if (srch[0] == '?') { help(11); goto l11; }
X		if (atoi(srch) < 1) looke();
X	}
X
X	if (c == '3') {		/* look by symbol */
X		wprintw(mn, "Look by Symbol");
X		wclrtoeol(mn);
Xl12:		mvwaddstr(mn, 11, 0, "Atomic Symbol:   ");
X		wrefresh(mn);
X		cur = mn; xp = 17; yp = 11;
X		echo();
X		nocrmode();
X		gets(srch);
X		if (srch[0] == '?') { help(12); goto l12; }
X	}
X	
X	for (tmp = e; tmp != NULL; tmp = tmp->next) {
X		switch(c) {		/* then display it */
X			case '1':
X				elk = matchstr(srch);
X				switch(elk) {
X					case -1:
X						if (c == '1')
X							mvwaddstr(mn, 11, 0, "Element name is ambiguous.");
X						else
X							mvwaddstr(mn, 11, 0, "Element symbol is ambiguous.");
X						wrefresh(mn);
X						sleep(2);
X						goto nd;
X					case 0: break;
X					default: disp(elk); goto nd;
X				}
X				break;
X			case '3':
X				if (strcmp(srch, tmp->sym) == 0) {
X					disp(tmp->anum); goto nd;
X				} else break;
X			default:
X				if (atoi(srch) == tmp->anum) {
X					disp(tmp->anum); goto nd;
X				} else
X					break;
X		}
X	}
X	mvwaddstr(mn, 10, 0, "No such element:");
X	wrefresh(mn);
X	sleep(2);
Xnd:	wclear(graph); wrefresh(graph);
X	wclear(mn); wrefresh(mn);
X	looke();
X}
END_OF_FILE
  if test 6499 -ne `wc -c <'looke.c'`; then
    echo shar: \"'looke.c'\" unpacked with wrong size!
  fi
  # end of 'looke.c'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
  echo shar: Extracting \"'main.c'\" \(6298 characters\)
  sed "s/^X//" >'main.c' <<'END_OF_FILE'
X/*
X * chemtab - a periodic table data base (C) 1990 Jim King (pulsar@lsrhs)
X *
X * main.c	Main program structure and branch
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <curses.h>
X#include <time.h>
X#include <signal.h>
X
X#include "variables.h"
X#include "windows.h"
X
X#define	LOCKFILE	"/tmp/chemlock"
X
Xextern int	cleanup(), stop();
Xextern WINDOW	*hlp;
X
X/*
X * main(ac, av) - specify -r flag for ReGIS
X *
X * purpose:	Main program branch & menu & inits
X */
Xvoid main(ac, av)
Xint	ac;
Xchar	*av[];
X{
X	long	secs;		/* For logfile */
X	char	c, str[80];	/* input choice */
X	int	i, rebuild, textonly, closetext;
X	struct	stat	*f1, *f2;
X	
X	f1 = (struct stat *)malloc(sizeof(struct stat));
X	f2 = (struct stat *)malloc(sizeof(struct stat));
X
X	gtot = -1;
X#ifdef ReGIS
X	regis = 0;
X	strcpy(str, getenv("TERM"));
X	if ((!strcmp(str, "vt240")) || (!strncmp(str, "vt3", 3))) {
X		++regis;
X		printf("chemtab: ReGIS terminal recognized.  ReGIS mode enabled.\n");
X		sleep(2);
X	}
X	if (ac > 2) {
X		fprintf(stderr, "chemtab: usage: chemtab [-r]\n");
X		exit(1);
X	} else if ((ac == 2) && (av[1][1] == 'r') && (!regis)) {
X		++regis;
X		printf("chemtab: ReGIS mode enabled for this session.\n");
X		sleep(2);
X	}
X
X#endif ReGIS
X
X	if (stat(PERTABLE, f1) == -1) {
X		printf("Element data (text) is unavailable.\n");
X		exit(1);
X	}
Xlok:	if (stat(BINTABLE, f2) == -1) {
X		printf("Binary element table is missing.\n");
X		if (fopen(LOCKFILE, "r") != NULL) {
X			printf("Someone is already rebuilding the element table.\nPlease wait...\n");
X			sleep(5);
X			goto lok;
X		} else
X			rebuild++;
X	} else if (f1->st_mtime > f2->st_mtime) {
X		printf("Binary element table is outdated.\n");
X		rebuild++;
X	}
X	
X	if (rebuild) {
X		if (creat(LOCKFILE, 022) == -1) {
X			printf("Sorry, cannot create a lockfile.\nProgram will try textfile only.\n");
X			textonly++;
X			goto next;
X		}
X		printf("Rebuilding binary element table.\n");
X		sleep(1);
X		if (readelem() == 888) {
X			printf("The computer has run out of memory.\n");
X			exit(1);
X		}
X		if (binwritelem() == 888) {
X			printf("Trouble building binary element table.\nUsing text file, please contact chemtab coordinator.\n");
X			textonly++;
X		} else
X			printf("Binary element table rebuilt.\n");
X		sleep(1);
X		unlink(LOCKFILE);
X	}
Xnext:	rebuild = 0;  closetext = 0;
X
X	initscr();			/* start curses */
X	hlp = NULL;			/* help screen init */
X	btm = newwin(1, 79, 23, 0);	/* Bottom line window */
X	srt = newwin(5, 79, 0, 0);	/* Top sort window */
X	graph = newwin(0, 0, 0, 0);	/* Whole screen overwrite */
X	mn = newwin(17, 79, 5, 0);	/* Middle (main) window */
X	wrefresh(btm); wrefresh(srt); wrefresh(graph); wrefresh(mn);
X	
X#ifdef	TRANSCRIPT			/* Log time and user in file */
X	time(&secs);
X	bot("Logging you in..");
X	if ((fp = fopen(TRANSCRIPT, "a+")) != NULL) {
X		fprintf(fp, "%s logged in at %s", getenv("USER"), ctime(&secs));
X		fclose(fp);
X	} else {
X		bot("Please set the TRANSCRIPT define in tune.h to work on your machine.");
X		sleep(5);
X		bot("The program will exit so you can do this now.");
X		sleep(5);
X		cleanup();
X	}
X#endif	TRANSCRIPT
X
X	clear();
X	mvaddstr(5, 37, "Chemtab");
X	mvaddstr(9, 28, "Periodic Table Data Base");
X	mvaddstr(10, 30, "Of the Known Elements");
X	standout();
X	mvaddstr(15, 21, "Chemtab 2.01 incorporates online help");
X	mvaddstr(16, 13, "Answer with a question mark at any question for help.");
X	standend();
X	mvaddstr(18, 18, "Version 2.01, January 7th, 1991 by Jim King");
X	mvaddstr(19, 16, "Developed at Lincoln-Sudbury Regional High School");
X	mvaddstr(20, 12, "(and) ReGIS package at Rochester Institute of Technology");
X	refresh();				/* Title page */
X	spc();
Xnxt:	mvwaddstr(btm, 0, 0, "Would you like a transcript of graphs and information? ");
X	wrefresh(btm);	/* transcript flag (trans) */
X	c = getchar();
X	if (c == '?') { help(13); goto nxt; }
X	if (c == 'y') {
X		trans = 1;
X		wclear(btm);
Xl14:		mvwaddstr(btm, 0, 0, "Please enter your last name for the transcript: ");
X		wrefresh(btm);
X		echo(); nocrmode();
X		gets(lnm);
X		if (lnm[0] == '?') { help(14); goto l14; }
X		sprintf(str, "%d.chemtab", getpid());
X		fp = fopen(str, "w");
X		fprintf(fp, "*** ChemTab - Periodic Table Database - Transcript for >> %s <<", lnm);
X	}
X	else if (c != 'n') {
X		mvwaddstr(btm, 0, 58, "(y, n, or ?) ");
X		goto nxt;
X	}
X	wprintw(btm, "no"); wrefresh(btm);
X	wclear(btm);
X	wrefresh(btm);
X	noecho(); crmode();
X	clear();
X	refresh();
X
X	bot("Reading in elements...");
X	if (textonly) {
X		if (readelem() == 888) {
Xouch:			printf("The computer has run out of memory.\n");
X			exit(1);
X		}
X	} else
X		if (binreadelem() == 888) goto ouch;
X
X	bot("Reading close values...");
X	if (getclose() == 888) {
X		printf("\nThe close value file is corrupt.\n");
X		exit(1);
X	}
X
X	signal(SIGINT, cleanup);
X#ifdef	USERSHELL
X	signal(SIGTSTP, stop);
X#else	USERSHELL
X	signal(SIGTSTP, SIG_IGN);
X#endif	USERSHELL
X	signal(SIGQUIT, SIG_IGN);
X	signal(SIGTERM, cleanup);
X	
X	for (i = 0; i < 3; i++)			/* initialize sort choices */
X		dosort[i].wch = 0;
X
X	bot(" ");				/* clear the bottom line */
X
X	for (;;) {				/* main loop */
X		wclear(mn);
X		wrefresh(srt);
X		upsort();			/* Update the sort window */
X		for (i = 1; i < 7; i++) {
X			wmove(mn, i+1, 0);
X			wprintw(mn, "%d] %s", i, mopts[i]);
X		}	/* give me choices, then branch off */
X		menu("Chemtab 2.01 MAIN MENU");
X#ifdef	ReGIS
X		mvwaddstr(mn, 11, 0, "^R toggles ReGIS mode which is currently ");
X		wstandout(mn);
X		wprintw(mn, "%s", regis ? "on." : "off");
X		wstandend(mn);
X#endif	ReGIS
Xloop:		mvwaddstr(mn, 9, 0, "Your choice? ");
X		wclrtoeol(mn);
X		wrefresh(mn);
X		cur = mn; xp = 14; yp = 9;
X		noecho();
X		crmode();
X		switch(wgetch(mn)) {
X			case '?': help(15); goto loop;
X			case '1': looke(); break; /* View specific Element. */
X			case '2': schar(); esort(); break; /* Select Characteristics */
X			case '3': wclear(mn); wclear(srt); vdata(); break; /* View Selected Elements */
X			case '4': wclear(mn); wclear(srt); ptabl(); break; /* Print periodic table.. */
X#ifdef ReGIS
X			case '5': wclear(mn); wclear(srt); if (regis) doregisgph(); else dogph(); break;
X			case '\022': /* ^R */ if (regis) regis = 0; else regis = 1; break;
X#else ReGIS
X			case '5': wclear(mn); wclear(srt); dogph(); break; /* Do a graph for us..... */
X#endif ReGIS
X			case '6': cleanup(); break; /* Exit */
X			case '\026': /* ^V */ version(); break;
X			default: goto loop;
X		}
X	}
X}
END_OF_FILE
  if test 6298 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
  fi
  # end of 'main.c'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
