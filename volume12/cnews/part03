Subject:  v12i028:  C News alpha release, Part03/14
Newsgroups: comp.sources.unix
Sender: sources
Approved: rs@uunet.UU.NET

Submitted-by: utzoo!henry (Henry Spencer)
Posting-number: Volume 12, Issue 28
Archive-name: cnews/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 14)."
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'batch/batchprep' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'batch/batchprep'\"
else
echo shar: Extracting \"'batch/batchprep'\" \(1163 characters\)
sed "s/^X//" >'batch/batchprep' <<'END_OF_FILE'
X# Prepare some batches of size $1 in files named togo.* .  We prepare a
X# total of 5 to stay well within awk's limits on file descriptors.
X#
X# Buglet:  does not count the "#! rnews nnnnn" headers in sizes.
X#
X# If the togo file does not contain file sizes, we make an arbitrary guess
X# at an average size.
X
Xcase $#
Xin
X	0)
X	echo 'Usage: batchprep size' >&2
X	exit 2
X	;;
Xesac
X
XNEWSCTL=${NEWSCTL-/usr/lib/news}
XNEWSUMASK=${NEWSUMASK-002}
Xumask $NEWSUMASK
X
X# Locking.
X(
X	cd $NEWSCTL
X	echo $$ >LOCKTM$$
X	until ln LOCKTM$$ LOCK >/dev/null 2>/dev/null
X	do
X		sleep 15
X	done
X	rm LOCKTM$$
X)
Xtrap "rm -f $NEWSCTL/LOCK ; exit" 0 1 2 3 15
X
Xrm -f togo.overflow
X
Xawk 'BEGIN { total = 0; nfile = 0 ; nbatch = 1 ; batch = "togo." nbatch }
X	{
X		if (NF == 1)
X			size = 3000	# Arbitrary guess.
X		else
X			size = $2
X		if (nfile > 0 && total + size > '$1') {
X			# Go to next batch.
X			nbatch++
X			if (nbatch <= 5) {
X				batch = "togo." nbatch
X				nfile = 0
X			} else {
X				batch = "togo.overflow"
X				nfile = -999999	# rest all goes into overflow
X			}
X			total = 0
X		}
X		nfile++
X		total += size
X		print >batch
X	}' togo
X
Xif test -r togo.overflow
Xthen
X	mv togo.overflow togo
Xelse
X	>togo
Xfi
END_OF_FILE
if test 1163 -ne `wc -c <'batch/batchprep'`; then
    echo shar: \"'batch/batchprep'\" unpacked with wrong size!
fi
# end of 'batch/batchprep'
fi
if test -f 'batch/testmakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'batch/testmakefile'\"
else
echo shar: Extracting \"'batch/testmakefile'\" \(768 characters\)
sed "s/^X//" >'batch/testmakefile' <<'END_OF_FILE'
XFILES = 0 1 2 3 4 5 6 7 8 9 10 11 12 13
X
Xr:	test.togo test.togo.3 $(FILES) chmods
X	rm -f togo*
X	cp test.togo togo
X	cp test.togo.3 togo.3
X	rm -f output
X	NEWSARTS=`pwd` $NEWSBIN/batch/sendbatches test
X	for f in togo* ; do echo === $$f === ; cat $$f ; done >>output
X	@echo 'No news is good news...'
X	cmp output goodoutput && rm -f togo* output $(FILES)
X
Xtry:	test.togo test.togo.3 $(FILES) chmods
X	rm -f togo*
X	cp test.togo togo
X	cp test.togo.3 togo.3
X	rm -f output
X	NEWSARTS=`pwd` sh -x $NEWSBIN/batch/sendbatches test
X	for f in togo* ; do echo === $$f === ; cat $$f ; done >>output
X	cmp output goodoutput && rm -f togo* output $(FILES)
X
X$(FILES):
X	for f in $(FILES) ; do echo $$f >$$f; done
X
Xclean:
X	rm -f togo* output $(FILES)
X
Xchmods:
X	chmod +x batch* queue* roomfor
END_OF_FILE
if test 768 -ne `wc -c <'batch/testmakefile'`; then
    echo shar: \"'batch/testmakefile'\" unpacked with wrong size!
fi
# end of 'batch/testmakefile'
fi
if test -f 'expire/lowest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'expire/lowest.c'\"
else
echo shar: Extracting \"'expire/lowest.c'\" \(896 characters\)
sed "s/^X//" >'expire/lowest.c' <<'END_OF_FILE'
X/*
X * lowest - print the number of the lowest article in a directory
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <dirent.h>
X
X#define	HUGE	999999999L	/* Bigger than any valid article number. */
X
Xchar *progname;
X
X/*
X - main - parse arguments and handle options
X */
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	DIR *d;
X	register struct dirent *dp;
X	long lowest = HUGE;
X	long this;
X	extern long atol();
X
X	progname = argv[0];
X
X	if (argc != 2) {
X		fprintf(stderr, "usage: %s directory\n", progname);
X		exit(2);
X	}
X
X	d = opendir(argv[1]);
X	if (d == NULL) {
X		fprintf(stderr, "%s: can't read directory %s\n", progname,
X								argv[1]);
X		exit(1);
X	}
X	while ((dp = readdir(d)) != NULL) {
X		if (strspn(dp->d_name, "0123456789") == strlen(dp->d_name)) {
X			this = atol(dp->d_name);
X			if (this < lowest)
X				lowest = this;
X		}
X	}
X	closedir(d);
X
X	if (lowest != HUGE)
X		printf("%ld\n", lowest);
X}
END_OF_FILE
if test 896 -ne `wc -c <'expire/lowest.c'`; then
    echo shar: \"'expire/lowest.c'\" unpacked with wrong size!
fi
# end of 'expire/lowest.c'
fi
if test -f 'expire/mkdbm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'expire/mkdbm.c'\"
else
echo shar: Extracting \"'expire/mkdbm.c'\" \(1046 characters\)
sed "s/^X//" >'expire/mkdbm.c' <<'END_OF_FILE'
X/*
X * mkdbm - rebuild dbm file for a history file
X *
X * History file on standard input; the dbm database is generated as
X * it.dir and it.pag.
X */
X#include <stdio.h>
X#include <string.h>
X#include <ctype.h>
X
X
Xchar *progname = "mkdbm";
Xtypedef struct { char *dptr; int dsize; } datum;
X
Xmain()
X{
X	char buf[BUFSIZ];
X	register char *scan;
X	long place;
X	datum lhs;
X	datum rhs;
X	register int ret;
X
X	close(creat("it.dir", 0666));
X	close(creat("it.pag", 0666));
X	dbminit("it");
X
X	for (;;) {
X		place = ftell(stdin);
X		if (fgets(buf, BUFSIZ, stdin) == NULL)
X			break;
X
X		scan = strchr(buf, '\t');
X		if (scan == NULL || buf[strlen(buf)-1] != '\n') {
X			fprintf(stderr, "bad format: %s", buf);
X			exit(1);
X		}
X		*scan = '\0';
X
X		for (scan = buf; *scan != '\0'; scan++)
X			if (isascii(*scan) && isupper(*scan))
X				*scan = tolower(*scan);
X
X		lhs.dptr = buf;
X		lhs.dsize = strlen(buf) + 1;
X		rhs.dptr = (char *)&place;
X		rhs.dsize = sizeof place;
X		ret = store(lhs, rhs);
X		if (ret < 0)
X			fprintf(stderr, "dbm failure '%s' @ %ld\n", buf, place);
X	}
X	exit(0);
X}
END_OF_FILE
if test 1046 -ne `wc -c <'expire/mkdbm.c'`; then
    echo shar: \"'expire/mkdbm.c'\" unpacked with wrong size!
fi
# end of 'expire/mkdbm.c'
fi
if test -f 'expire/upact' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'expire/upact'\"
else
echo shar: Extracting \"'expire/upact'\" \(1194 characters\)
sed "s/^X//" >'expire/upact' <<'END_OF_FILE'
X#! /bin/sh
X# Update 3rd field (minimum art. #) of a 4-field active file.
X
XNEWSCTL=${NEWSCTL-/usr/lib/news}
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}
XNEWSARTS=${NEWSARTS-/usr/spool/news}
XPATH=$NEWSBIN/expire:/bin:/usr/bin ; export PATH
XNEWSUMASK=${NEWSUMASK-002}
Xumask NEWSUMASK
X
Xcd $NEWSCTL || { echo "$0: can't cd to $NEWSCTL" >&2; exit 1; }
X
X# check active file format
Xset ""`sed 1q active`
Xcase $# in
X4)	;;
X*)
X	echo "$0: active file has other than 4 fields" >&2
X	exit 1
X	;;
Xesac
X
X# lock news system
Xuntil ln active LOCK >/dev/null 2>/dev/null
Xdo
X	sleep 30
Xdone
Xtrap "rm -f LOCK" 0 1 2 15	# unlock on exit or death
X
Xwhile read group max min fourth
Xdo
X	dir=`echo $group | tr . / `	# map ng name to directory name
X	min=$max			# default
X	if test -d $NEWSARTS/$dir
X	then
X		min=`lowest $NEWSARTS/$dir`
X	fi
X	case "$min" in		# no files, so
X	"")	min=$max ;;	# use maximum
X	esac
X	case "$min" in
X	[0-9][0-9][0-9][0-9][0-9])	;;	# cool format
X	*)
X		# touch up the article number format: make 5 digits long
X		min=`expr 00000$min : '.*\(.....\)$'`
X		;;
X	esac
X
X	echo $group $max $min $fourth
Xdone <active >active.new
X
X# replace active, carefully
Xrm -f active.old
Xln active active.old
Xmv active.new active
X
Xexit 0
END_OF_FILE
if test 1194 -ne `wc -c <'expire/upact'`; then
    echo shar: \"'expire/upact'\" unpacked with wrong size!
fi
# end of 'expire/upact'
fi
if test -f 'input/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'input/Makefile'\"
else
echo shar: Extracting \"'input/Makefile'\" \(876 characters\)
sed "s/^X//" >'input/Makefile' <<'END_OF_FILE'
X# If you don't have a dirent.h header file, add -I. to CFLAGS and see README.
XDEFINES =
XCFLAGS = -O $(DEFINES) -I../include
XLINTFLAGS = $(DEFINES) -Dvoid=int
XLDFLAGS = -i
XOBJS=newsspool.o
XLIBS= ../libcnews/libcnews.a ../libc/*.a
XTHEM = newsspool newsrun newsrunning
XNEWSBIN = /usr/lib/newsbin
XNEWSCTL = /usr/lib/news
X
Xnewsspool: $(OBJS)
X	$(CC) $(LDFLAGS) $(OBJS) $(LIBS) -o $@
X
Xinstall:	$(THEM)
X	chmod +x $(THEM) rnews
X	cp $(THEM) $(NEWSBIN)/input
X	chmod u+s $(NEWSBIN)/input/newsspool
X	mkdir $(NEWSCTL)/incoming $(NEWSCTL)/incoming/bad
X	cp rnews /bin/rnews
X	cp rnews /bin/cunbatch
X
Xclean:
X	rm -f *.o newsspool
X	rm -rf incoming
X
Xsetup:
X	mkdir incoming incoming/bad
X
Xtry1:	goo newsspool setup
X	NEWSCTL=`pwd` newsspool <goo
X
Xtry2:	try1
X	NEWSCTL=`pwd` sh -x newsrunning off
X	NEWSCTL=`pwd` sh -x newsrun
X
Xtry:	try2
X	NEWSCTL=`pwd` sh -x newsrunning on
X	NEWSCTL=`pwd` sh -x newsrun
END_OF_FILE
if test 876 -ne `wc -c <'input/Makefile'`; then
    echo shar: \"'input/Makefile'\" unpacked with wrong size!
fi
# end of 'input/Makefile'
fi
if test -f 'input/newsrun' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'input/newsrun'\"
else
echo shar: Extracting \"'input/newsrun'\" \(1138 characters\)
sed "s/^X//" >'input/newsrun' <<'END_OF_FILE'
X#! /bin/sh
X# Process spooled news.
X
XNEWSCTL=${NEWSCTL-/usr/lib/news}
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}
XNEWSARTS=${NEWSARTS-/usr/spool/news}
XPATH=$NEWSBIN/input:/bin:/usr/bin ; export PATH
XNEWSUMASK=${NEWSUMASK-002}
Xumask NEWSUMASK
X
Xcd $NEWSCTL/incoming
X
X# First, is it worth trying at all?
Xif test -r stop
Xthen
X	exit 0
Xfi
X
X# Lock against others running.
Xecho $$ >L.$$
Xif ln L.$$ RLOCK >/dev/null 2>&1
Xthen
X	trap "rm -f L.$$ RLOCK" 0 1 2 15
Xelse
X	rm -f L.$$
X	exit 0
Xfi
X
Xwhile true
Xdo
X	# Find some work.
X	them=`ls | egrep '^[0-9]+$' | sort | sed 50q`
X	if test "$them" = ""
X	then
X		break
X	fi
X
X	# Do it.
X	for f in $them
X	do
X		# Check for request to stop.
X		if test -r stop
X		then
X			exit 0
X		fi
X
X		# Decompress if necessary.
X		text=np.$$
X		if compress -d <$f >$text 2>/dev/null
X		then
X			: ok
X		else
X			rm -f $text
X			text=$f
X		fi
X
X		# Do it.
X		$NEWSBIN/relay/realrnews <$text >/tmp/npm$$ 2>&1
X
X		# And handle the consequences.
X		if test -s /tmp/npm$$
X		then
X			bad=bad/$f
X			cp $text $bad
X			( echo rnews $bad failed ; cat /tmp/npm$$ ) | mail news
X		fi
X
X		rm -f /tmp/npm$$ $text $f
X	done
Xdone
X
Xfind bad -ctime +7 -exec rm -f {} \;
X
Xexit 0
END_OF_FILE
if test 1138 -ne `wc -c <'input/newsrun'`; then
    echo shar: \"'input/newsrun'\" unpacked with wrong size!
fi
# end of 'input/newsrun'
fi
if test -f 'lib.proto/control/newgroup' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/control/newgroup'\"
else
echo shar: Extracting \"'lib.proto/control/newgroup'\" \(1152 characters\)
sed "s/^X//" >'lib.proto/control/newgroup' <<'END_OF_FILE'
X#! /bin/sh
X# newgroup group - create group (4-field version: B-2.10.3 and later compatible)
X#	subject to our sys file group pattern
X# B 2.11 requires an Approved: header; someday.
XNEWSCTL=${NEWSCTL-/usr/lib/news}; export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}; export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}; export NEWSARTS
XPATH=/bin:/usr/bin:/usr/ucb:$NEWSCTL:$NEWSBIN; export PATH	# must find mkpdir
XF=/tmp/nc$$
Xadmin=usenet
X
Xcat >$F
XSENDER="`grep '^Sender:' $F | sed 's/^[^:]*: *//'`"
Xcase "$SENDER" in
X"")
X	SENDER="`grep '^From:' $F | sed 's/^[^:]*: *//'`"
X	;;
Xesac
X
Xif grep -s "^`echo $1 | sed 's/\./\\\\./g'` " $NEWSCTL/active; then	# group exists
X	: do nothing
Xelif gngp -a `
X    egrep "^(\`hostname\`|ME):" $NEWSCTL/sys | awk -F: '{print $2; exit}'
X    ` >/dev/null <<!
X$1
X!
Xthen			# no group in active, but sys file likes it: make it
X	case "$2" in
X	moderated)	flag=m ;;
X	*)	flag=y ;;
X	esac
X	echo "$1 00000 00000 $flag" >>$NEWSCTL/active
X	# TODO: is it worth making the directory now? maybe, rn bitches otherwise
X	mkpdir $NEWSARTS/`echo $1 | sed 's/\./\//g' `
X	echo "newsgroup $1 was created by $SENDER." | mail $admin
Xfi
X
Xrm -f $F*
END_OF_FILE
if test 1152 -ne `wc -c <'lib.proto/control/newgroup'`; then
    echo shar: \"'lib.proto/control/newgroup'\" unpacked with wrong size!
fi
# end of 'lib.proto/control/newgroup'
fi
if test -f 'lib.proto/control/newgroup.2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/control/newgroup.2'\"
else
echo shar: Extracting \"'lib.proto/control/newgroup.2'\" \(771 characters\)
sed "s/^X//" >'lib.proto/control/newgroup.2' <<'END_OF_FILE'
X#! /bin/sh
X# newgroup group - create group (2-field version: pre-B-2.10.2 compatible)
XNEWSCTL=${NEWSCTL-/usr/lib/news}; export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}; export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}; export NEWSARTS
XPATH=/bin:/usr/bin:/usr/ucb:$NEWSCTL:$NEWSBIN; export PATH	# must find mkpdir
XF=/tmp/nc$$
Xadmin=usenet
X
Xcat >$F
XSENDER="`grep '^Sender:' $F | sed 's/^[^:]*: *//'`"
Xcase "$SENDER" in
X"")
X	SENDER="`grep '^From:' $F | sed 's/^[^:]*: *//'`"
X	;;
Xesac
X
Xif grep -s "^`echo $1 | sed 's/\./\\\\./g'` " $NEWSCTL/active; then	# group exists
X	: do nothing
Xelse							# no group, make it
X	echo "$1 00000" >>$NEWSCTL/active
X	mkpdir $NEWSARTS/`echo $1 | sed 's/\./\//g' `
X	echo "newsgroup $1 was created by $SENDER." | mail $admin
Xfi
X
Xrm -f $F*
END_OF_FILE
if test 771 -ne `wc -c <'lib.proto/control/newgroup.2'`; then
    echo shar: \"'lib.proto/control/newgroup.2'\" unpacked with wrong size!
fi
# end of 'lib.proto/control/newgroup.2'
fi
if test -f 'lib.proto/control/newgroup.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/control/newgroup.3'\"
else
echo shar: Extracting \"'lib.proto/control/newgroup.3'\" \(773 characters\)
sed "s/^X//" >'lib.proto/control/newgroup.3' <<'END_OF_FILE'
X#! /bin/sh
X# newgroup group - create group (3-field version: B-2.10.2 compatible)
XNEWSCTL=${NEWSCTL-/usr/lib/news}; export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}; export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}; export NEWSARTS
XPATH=/bin:/usr/bin:/usr/ucb:$NEWSCTL:$NEWSBIN; export PATH	# must find mkpdir
XF=/tmp/nc$$
Xadmin=usenet
X
Xcat >$F
XSENDER="`grep '^Sender:' $F | sed 's/^[^:]*: *//'`"
Xcase "$SENDER" in
X"")
X	SENDER="`grep '^From:' $F | sed 's/^[^:]*: *//'`"
X	;;
Xesac
X
Xif grep -s "^`echo $1 | sed 's/\./\\\\./g'` " $NEWSCTL/active; then	# group exists
X	: do nothing
Xelse							# no group, make it
X	echo "$1 00000 00000" >>$NEWSCTL/active
X	mkpdir $NEWSARTS/`echo $1 | sed 's/\./\//g' `
X	echo "newsgroup $1 was created by $SENDER." | mail $admin
Xfi
X
Xrm -f $F*
END_OF_FILE
if test 773 -ne `wc -c <'lib.proto/control/newgroup.3'`; then
    echo shar: \"'lib.proto/control/newgroup.3'\" unpacked with wrong size!
fi
# end of 'lib.proto/control/newgroup.3'
fi
if test -f 'lib.proto/control/newgroup.4' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/control/newgroup.4'\"
else
echo shar: Extracting \"'lib.proto/control/newgroup.4'\" \(1152 characters\)
sed "s/^X//" >'lib.proto/control/newgroup.4' <<'END_OF_FILE'
X#! /bin/sh
X# newgroup group - create group (4-field version: B-2.10.3 and later compatible)
X#	subject to our sys file group pattern
X# B 2.11 requires an Approved: header; someday.
XNEWSCTL=${NEWSCTL-/usr/lib/news}; export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}; export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}; export NEWSARTS
XPATH=/bin:/usr/bin:/usr/ucb:$NEWSCTL:$NEWSBIN; export PATH	# must find mkpdir
XF=/tmp/nc$$
Xadmin=usenet
X
Xcat >$F
XSENDER="`grep '^Sender:' $F | sed 's/^[^:]*: *//'`"
Xcase "$SENDER" in
X"")
X	SENDER="`grep '^From:' $F | sed 's/^[^:]*: *//'`"
X	;;
Xesac
X
Xif grep -s "^`echo $1 | sed 's/\./\\\\./g'` " $NEWSCTL/active; then	# group exists
X	: do nothing
Xelif gngp -a `
X    egrep "^(\`hostname\`|ME):" $NEWSCTL/sys | awk -F: '{print $2; exit}'
X    ` >/dev/null <<!
X$1
X!
Xthen			# no group in active, but sys file likes it: make it
X	case "$2" in
X	moderated)	flag=m ;;
X	*)	flag=y ;;
X	esac
X	echo "$1 00000 00000 $flag" >>$NEWSCTL/active
X	# TODO: is it worth making the directory now? maybe, rn bitches otherwise
X	mkpdir $NEWSARTS/`echo $1 | sed 's/\./\//g' `
X	echo "newsgroup $1 was created by $SENDER." | mail $admin
Xfi
X
Xrm -f $F*
END_OF_FILE
if test 1152 -ne `wc -c <'lib.proto/control/newgroup.4'`; then
    echo shar: \"'lib.proto/control/newgroup.4'\" unpacked with wrong size!
fi
# end of 'lib.proto/control/newgroup.4'
fi
if test -f 'lib.proto/control/rmgroup.auto' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/control/rmgroup.auto'\"
else
echo shar: Extracting \"'lib.proto/control/rmgroup.auto'\" \(995 characters\)
sed "s/^X//" >'lib.proto/control/rmgroup.auto' <<'END_OF_FILE'
X#! /bin/sh
X# rmgroup group - snuff group. active file is locked at entry
XNEWSCTL=${NEWSCTL-/usr/lib/news}; export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}; export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}; export NEWSARTS
XF=/tmp/nc$$
Xadmin=usenet
X
Xcat >$F
X
XSENDER="`grep '^Sender:' $F | sed 's/^[^:]*: *//'`"
Xcase "$SENDER" in
X"")
X	SENDER="`grep '^From:' $F | sed 's/^[^:]*: *//'`"
X	;;
Xesac
X
X# remove active entry
Xsed "/^`echo $1 | sed 's/\./\\\\./g'` /d" $NEWSCTL/active >$F.act
Xcp $NEWSCTL/active $NEWSCTL/active.old
Xcp $F.act $NEWSCTL/active
X
X# rm -rf $NEWSARTS/`echo $1 | sed 's;\.;/;g'`	# remove the directory
Xdir=$NEWSARTS/`echo $1 | sed 's;\.;/;g'`	# name the directory
Xexport dir				# for sub-shell below
X(
X	cd /tmp				# in case "cd $dir" fails but shell continues
X	cd $dir				# go there
X	rm -f *
X	cd ..
X	rmdir `basename "$dir" '' `	# remove the empty directory
X)
X
X# tell the local usenet administrator the bad news
Xecho "rmgrouped $1 cuz $SENDER said to" | mail $admin
X
Xrm -f $F*
END_OF_FILE
if test 995 -ne `wc -c <'lib.proto/control/rmgroup.auto'`; then
    echo shar: \"'lib.proto/control/rmgroup.auto'\" unpacked with wrong size!
fi
# end of 'lib.proto/control/rmgroup.auto'
fi
if test -f 'lib.proto/sys' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/sys'\"
else
echo shar: Extracting \"'lib.proto/sys'\" \(1052 characters\)
sed "s/^X//" >'lib.proto/sys' <<'END_OF_FILE'
X# ourselves: accept almost everything we get from our feed (rather limited)
Xutstat:comp,news,list,to,junk,control,sci.crypt,sci.math,misc.jobs,\
X!comp.binaries,!comp.sys,comp.sys.sun,comp.sys.ibm,comp.sys.mac,\
X!comp.lang.lisp,can,ont,tor,ut,!ut.stardate,utstat,\
X!all.all.amiga,!all.all.atari,!all.all.xenix,!all.all.venix,\
X!all.games,!all.all.games,!all.all.vms,!all.all.ada,!all.all.cpm,\
X!all.all.kermit,!all.all.appletalk,!general/world,na,can,ont,tor,ut,utstat
X# our news feed: send everything & locally-written articles go direct
Xutgpu:all,!to,to.utgpu,!utstat:F:/usr/lib/news/batch/b.utcs/togo
Xutgpu:all,!to,to.utgpu,!utstat:L:/usr/lib/news/sendnews utcs!rnews
X# local groups go out to local sites faster
Xutcsri:world,na,can,ont,tor,ut,to.utcsri:L:/usr/lib/news/sendnews utcsri!rnews
X# eventually chew up mod.map for pathalias; for now mail so they aren't lost
Xuucpmap:comp.mail.map/world,na,can,ont,tor,ut::/usr/lib/news/uucpmapmuncher
X# various individuals get our hacknews by mail
Xhacknewsers:utstat.hacknews/world,utstat::mail hacknewsers
END_OF_FILE
if test 1052 -ne `wc -c <'lib.proto/sys'`; then
    echo shar: \"'lib.proto/sys'\" unpacked with wrong size!
fi
# end of 'lib.proto/sys'
fi
if test -f 'libc/getopt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/getopt.c'\"
else
echo shar: Extracting \"'libc/getopt.c'\" \(1073 characters\)
sed "s/^X//" >'libc/getopt.c' <<'END_OF_FILE'
X/*
X * getopt - get option letter from argv
X */
X
X#include <stdio.h>
X
Xchar	*optarg;	/* Global argument pointer. */
Xint	optind = 0;	/* Global argv index. */
X
Xstatic char	*scan = NULL;	/* Private scan pointer. */
X
Xextern char	*index();
X
Xint
Xgetopt(argc, argv, optstring)
Xint argc;
Xchar *argv[];
Xchar *optstring;
X{
X	register char c;
X	register char *place;
X
X	optarg = NULL;
X
X	if (scan == NULL || *scan == '\0') {
X		if (optind == 0)
X			optind++;
X	
X		if (optind >= argc || argv[optind][0] != '-' || argv[optind][1] == '\0')
X			return(EOF);
X		if (strcmp(argv[optind], "--")==0) {
X			optind++;
X			return(EOF);
X		}
X	
X		scan = argv[optind]+1;
X		optind++;
X	}
X
X	c = *scan++;
X	place = index(optstring, c);
X
X	if (place == NULL || c == ':') {
X		fprintf(stderr, "%s: unknown option -%c\n", argv[0], c);
X		return('?');
X	}
X
X	place++;
X	if (*place == ':') {
X		if (*scan != '\0') {
X			optarg = scan;
X			scan = NULL;
X		} else if (optind < argc) {
X			optarg = argv[optind];
X			optind++;
X		} else {
X			fprintf(stderr, "%s: -%c argument missing\n", argv[0], c);
X			return('?');
X		}
X	}
X
X	return(c);
X}
END_OF_FILE
if test 1073 -ne `wc -c <'libc/getopt.c'`; then
    echo shar: \"'libc/getopt.c'\" unpacked with wrong size!
fi
# end of 'libc/getopt.c'
fi
if test -f 'libc/memcpy.fast/src/duff.long.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/memcpy.fast/src/duff.long.c'\"
else
echo shar: Extracting \"'libc/memcpy.fast/src/duff.long.c'\" \(1064 characters\)
sed "s/^X//" >'libc/memcpy.fast/src/duff.long.c' <<'END_OF_FILE'
X#define LUMP long
X
Xmemcpy(to, from, count)	/* assumes unaligned LUMPs can be copied */
Xregister char *from, *to;
Xregister int count;
X{
X	/*
X	 * This code uses Duff's Device (tm Tom Duff)
X	 * to unroll the copying loop:
X	 * while (count-- > 0)
X	 *	*to++ = *from++;
X	 * Sorry the code is so ugly.
X	 */
X	if (count > 0) {
X		register int loops = count >> 3;	/* /8 */
X		register LUMP *fromlump = (LUMP *)from, *tolump = (LUMP *)to;
X
X		count %= 8;		/* about to copy loops*8 bytes */
X		while (loops-- > 0) {
X			*tolump++ = *fromlump++;
X			*tolump++ = *fromlump++;
X		}
X		from = (char *)fromlump;
X		to = (char *)tolump;
X	}
X	/*
X	 * This code uses Duff's Device (tm Tom Duff)
X	 * to unroll the copying loop the last count%8 times:
X	 * while (count-- > 0)
X	 *	*to++ = *from++;
X	 * Sorry the code is so ugly.
X	 */
X	if (count > 0) {
X		switch (count&(8-1)) {	/* %8 */
X		case 0:
X#define COPYBYTE *to++ = *from++
X				COPYBYTE;
X			case 7:	COPYBYTE;
X			case 6:	COPYBYTE;
X			case 5:	COPYBYTE;
X			case 4:	COPYBYTE;
X			case 3:	COPYBYTE;
X			case 2:	COPYBYTE;
X			case 1:	COPYBYTE;
X		}
X	}
X}
END_OF_FILE
if test 1064 -ne `wc -c <'libc/memcpy.fast/src/duff.long.c'`; then
    echo shar: \"'libc/memcpy.fast/src/duff.long.c'\" unpacked with wrong size!
fi
# end of 'libc/memcpy.fast/src/duff.long.c'
fi
if test -f 'libc/memcpy.fast/times.ian' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/memcpy.fast/times.ian'\"
else
echo shar: Extracting \"'libc/memcpy.fast/times.ian'\" \(1068 characters\)
sed "s/^X//" >'libc/memcpy.fast/times.ian' <<'END_OF_FILE'
XFrom: sq!ian
XTo: utcs!geoff
XCc: darwin!ian
XSubject: bcopy timings
XDate: 25 Feb 1986 0051-EST (Tuesday)
X
XScript started on Mon Feb 24 23:14:31 1986
X% @ for f in obvious duff.byte duff.long duff.longs
X> do echo $f
X> cc bcopy.c $f.o
X> time a.out
X> time a.out
X> time a.out
X> done
Xobvious
XTime:      1:01.0 real        56.6 user         0.4 sys  
XTime:      1:02.0 real        56.6 user         0.4 sys  
XTime:        59.0 real        56.6 user         0.3 sys  
Xduff.byte
XTime:        19.0 real        17.1 user         0.3 sys  
XTime:        17.0 real        17.1 user         0.3 sys  
XTime:        18.0 real        17.1 user         0.3 sys  
Xduff.long
XTime:        13.0 real        11.6 user         0.4 sys  
XTime:        12.0 real        11.5 user         0.3 sys  
XTime:        12.0 real        11.5 user         0.3 sys  
Xduff.longs
XTime:        10.0 real         6.6 user         0.4 sys  
XTime:         7.0 real         6.6 user         0.3 sys  
XTime:         7.0 real         6.6 user         0.3 sys  
X@ 
Xscript done on Mon Feb 24 23:22:43 1986
X
XGreat stuff!
END_OF_FILE
if test 1068 -ne `wc -c <'libc/memcpy.fast/times.ian'`; then
    echo shar: \"'libc/memcpy.fast/times.ian'\" unpacked with wrong size!
fi
# end of 'libc/memcpy.fast/times.ian'
fi
if test -f 'libc/putenv.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/putenv.c'\"
else
echo shar: Extracting \"'libc/putenv.c'\" \(1131 characters\)
sed "s/^X//" >'libc/putenv.c' <<'END_OF_FILE'
X/*
X * putenv - add a variable to the environment
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X
X#define YES 1
X#define NO 0
X
Xint
Xputenv(var)			/* put var in the environment */
Xchar *var;
X{
X	register char **envp, **newenv;
X	register int oldenvcnt;
X	extern char **environ;
X	extern char *malloc();
X
X	/* count variables, look for var */
X	for (envp = environ; *envp != 0; envp++) {
X		register char *varp = var, *ep = *envp;
X		register int namesame;
X
X		namesame = NO;
X		for (; *varp == *ep && *varp != '\0'; ++ep, ++varp)
X			if (*varp == '=')
X				namesame = YES;
X		if (*varp == *ep && *ep == '\0')
X			return;			/* old & new var's are the same */
X		if (namesame) {
X			*envp = var;		/* replace var with new value */
X			return;
X		}
X	}
X	oldenvcnt = envp - environ;
X
X	/* allocate new environment with room for one more variable */
X	newenv = (char **)malloc((oldenvcnt + 1 + 1)*sizeof(*envp));
X	if (newenv == NULL)
X		return NO;
X
X	/* copy old environment pointers, add var, switch environments */
X	(void) memcpy(newenv, environ, oldenvcnt*sizeof(*envp));
X	newenv[oldenvcnt] = var;
X	newenv[oldenvcnt+1] = NULL;
X	environ = newenv;
X	return YES;
X}
END_OF_FILE
if test 1131 -ne `wc -c <'libc/putenv.c'`; then
    echo shar: \"'libc/putenv.c'\" unpacked with wrong size!
fi
# end of 'libc/putenv.c'
fi
if test -f 'libc/stdio.fast/_intro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/stdio.fast/_intro'\"
else
echo shar: Extracting \"'libc/stdio.fast/_intro'\" \(788 characters\)
sed "s/^X//" >'libc/stdio.fast/_intro' <<'END_OF_FILE'
XFrom: geoff (Geoff Collyer)
XTo: research!dmr, sig
XSubject: fast fgets, fread, fwrite, fputs
XDate: 16 Dec 1985 0416-EST (Monday)
X
X[ Approximate wording ]  My new one is 15% faster than DMR's on
X/usr/dict/words and 68% faster on /etc/passwd.  Uglix has some of the
Xsame improvements.
X
XThese are faster versions of fputs, fread and fwrite. Unlike my fgets,
Xthese are much faster than Dennis's and are still public-domain and
Xplug-compatible. I haven't bothered measuring fputs, but I did three
Xtiming trials using fread and fwrite to copy 195k from stdin to stdout
Xeach time, using fread and fwrite buffers of 8 bytes, 512 bytes and
X16,384 bytes.  Again on a 4.2 750, my fread/fwrite were respectively
X1.67, 21.63 and 23.77 times faster than Dennis's.
X
XComments?
X
X[ much code omitted here ]
END_OF_FILE
if test 788 -ne `wc -c <'libc/stdio.fast/_intro'`; then
    echo shar: \"'libc/stdio.fast/_intro'\" unpacked with wrong size!
fi
# end of 'libc/stdio.fast/_intro'
fi
if test -f 'libc/strings/strncmp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/strncmp.c'\"
else
echo shar: Extracting \"'libc/strings/strncmp.c'\" \(755 characters\)
sed "s/^X//" >'libc/strings/strncmp.c' <<'END_OF_FILE'
X/*
X * strncmp - compare at most n characters of string s1 to s2
X */
X
Xint				/* <0 for <, 0 for ==, >0 for > */
Xstrncmp(s1, s2, n)
XCONST char *s1;
XCONST char *s2;
XSIZET n;
X{
X	register CONST char *scan1;
X	register CONST char *scan2;
X	register SIZET count;
X
X	scan1 = s1;
X	scan2 = s2;
X	count = n;
X	while (--count >= 0 && *scan1 != '\0' && *scan1 == *scan2) {
X		scan1++;
X		scan2++;
X	}
X	if (count < 0)
X		return(0);
X
X	/*
X	 * The following case analysis is necessary so that characters
X	 * which look negative collate low against normal characters but
X	 * high against the end-of-string NUL.
X	 */
X	if (*scan1 == '\0' && *scan2 == '\0')
X		return(0);
X	else if (*scan1 == '\0')
X		return(-1);
X	else if (*scan2 == '\0')
X		return(1);
X	else
X		return(*scan1 - *scan2);
X}
END_OF_FILE
if test 755 -ne `wc -c <'libc/strings/strncmp.c'`; then
    echo shar: \"'libc/strings/strncmp.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/strncmp.c'
fi
if test -f 'libc/strings/strtok.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/strtok.c'\"
else
echo shar: Extracting \"'libc/strings/strtok.c'\" \(1103 characters\)
sed "s/^X//" >'libc/strings/strtok.c' <<'END_OF_FILE'
X/*
X * Get next token from string s (NULL on 2nd, 3rd, etc. calls),
X * where tokens are nonempty strings separated by runs of
X * chars from delim.  Writes NULs into s to end tokens.  delim need not
X * remain constant from call to call.
X */
X
X#define	NULL	0
X
Xstatic char *scanpoint = NULL;
X
Xchar *				/* NULL if no token left */
Xstrtok(s, delim)
Xchar *s;
Xregister CONST char *delim;
X{
X	register char *scan;
X	char *tok;
X	register CONST char *dscan;
X
X	if (s == NULL && scanpoint == NULL)
X		return(NULL);
X	if (s != NULL)
X		scan = s;
X	else
X		scan = scanpoint;
X
X	/*
X	 * Scan leading delimiters.
X	 */
X	for (; *scan != '\0'; scan++) {
X		for (dscan = delim; *dscan != '\0'; dscan++)
X			if (*scan == *dscan)
X				break;
X		if (*dscan == '\0')
X			break;
X	}
X	if (*scan == '\0') {
X		scanpoint = NULL;
X		return(NULL);
X	}
X
X	tok = scan;
X
X	/*
X	 * Scan token.
X	 */
X	for (; *scan != '\0'; scan++) {
X		for (dscan = delim; *dscan != '\0';)	/* ++ moved down. */
X			if (*scan == *dscan++) {
X				scanpoint = scan+1;
X				*scan = '\0';
X				return(tok);
X			}
X	}
X
X	/*
X	 * Reached end of string.
X	 */
X	scanpoint = NULL;
X	return(tok);
X}
END_OF_FILE
if test 1103 -ne `wc -c <'libc/strings/strtok.c'`; then
    echo shar: \"'libc/strings/strtok.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/strtok.c'
fi
if test -f 'newsbin.proto/control/newgroup.2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsbin.proto/control/newgroup.2'\"
else
echo shar: Extracting \"'newsbin.proto/control/newgroup.2'\" \(771 characters\)
sed "s/^X//" >'newsbin.proto/control/newgroup.2' <<'END_OF_FILE'
X#! /bin/sh
X# newgroup group - create group (2-field version: pre-B-2.10.2 compatible)
XNEWSCTL=${NEWSCTL-/usr/lib/news}; export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}; export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}; export NEWSARTS
XPATH=/bin:/usr/bin:/usr/ucb:$NEWSCTL:$NEWSBIN; export PATH	# must find mkpdir
XF=/tmp/nc$$
Xadmin=usenet
X
Xcat >$F
XSENDER="`grep '^Sender:' $F | sed 's/^[^:]*: *//'`"
Xcase "$SENDER" in
X"")
X	SENDER="`grep '^From:' $F | sed 's/^[^:]*: *//'`"
X	;;
Xesac
X
Xif grep -s "^`echo $1 | sed 's/\./\\\\./g'` " $NEWSCTL/active; then	# group exists
X	: do nothing
Xelse							# no group, make it
X	echo "$1 00000" >>$NEWSCTL/active
X	mkpdir $NEWSARTS/`echo $1 | sed 's/\./\//g' `
X	echo "newsgroup $1 was created by $SENDER." | mail $admin
Xfi
X
Xrm -f $F*
END_OF_FILE
if test 771 -ne `wc -c <'newsbin.proto/control/newgroup.2'`; then
    echo shar: \"'newsbin.proto/control/newgroup.2'\" unpacked with wrong size!
fi
# end of 'newsbin.proto/control/newgroup.2'
fi
if test -f 'newsbin.proto/control/newgroup.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsbin.proto/control/newgroup.3'\"
else
echo shar: Extracting \"'newsbin.proto/control/newgroup.3'\" \(773 characters\)
sed "s/^X//" >'newsbin.proto/control/newgroup.3' <<'END_OF_FILE'
X#! /bin/sh
X# newgroup group - create group (3-field version: B-2.10.2 compatible)
XNEWSCTL=${NEWSCTL-/usr/lib/news}; export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}; export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}; export NEWSARTS
XPATH=/bin:/usr/bin:/usr/ucb:$NEWSCTL:$NEWSBIN; export PATH	# must find mkpdir
XF=/tmp/nc$$
Xadmin=usenet
X
Xcat >$F
XSENDER="`grep '^Sender:' $F | sed 's/^[^:]*: *//'`"
Xcase "$SENDER" in
X"")
X	SENDER="`grep '^From:' $F | sed 's/^[^:]*: *//'`"
X	;;
Xesac
X
Xif grep -s "^`echo $1 | sed 's/\./\\\\./g'` " $NEWSCTL/active; then	# group exists
X	: do nothing
Xelse							# no group, make it
X	echo "$1 00000 00000" >>$NEWSCTL/active
X	mkpdir $NEWSARTS/`echo $1 | sed 's/\./\//g' `
X	echo "newsgroup $1 was created by $SENDER." | mail $admin
Xfi
X
Xrm -f $F*
END_OF_FILE
if test 773 -ne `wc -c <'newsbin.proto/control/newgroup.3'`; then
    echo shar: \"'newsbin.proto/control/newgroup.3'\" unpacked with wrong size!
fi
# end of 'newsbin.proto/control/newgroup.3'
fi
if test -f 'newsbin.proto/control/rmgroup.auto' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsbin.proto/control/rmgroup.auto'\"
else
echo shar: Extracting \"'newsbin.proto/control/rmgroup.auto'\" \(995 characters\)
sed "s/^X//" >'newsbin.proto/control/rmgroup.auto' <<'END_OF_FILE'
X#! /bin/sh
X# rmgroup group - snuff group. active file is locked at entry
XNEWSCTL=${NEWSCTL-/usr/lib/news}; export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}; export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}; export NEWSARTS
XF=/tmp/nc$$
Xadmin=usenet
X
Xcat >$F
X
XSENDER="`grep '^Sender:' $F | sed 's/^[^:]*: *//'`"
Xcase "$SENDER" in
X"")
X	SENDER="`grep '^From:' $F | sed 's/^[^:]*: *//'`"
X	;;
Xesac
X
X# remove active entry
Xsed "/^`echo $1 | sed 's/\./\\\\./g'` /d" $NEWSCTL/active >$F.act
Xcp $NEWSCTL/active $NEWSCTL/active.old
Xcp $F.act $NEWSCTL/active
X
X# rm -rf $NEWSARTS/`echo $1 | sed 's;\.;/;g'`	# remove the directory
Xdir=$NEWSARTS/`echo $1 | sed 's;\.;/;g'`	# name the directory
Xexport dir				# for sub-shell below
X(
X	cd /tmp				# in case "cd $dir" fails but shell continues
X	cd $dir				# go there
X	rm -f *
X	cd ..
X	rmdir `basename "$dir" '' `	# remove the empty directory
X)
X
X# tell the local usenet administrator the bad news
Xecho "rmgrouped $1 cuz $SENDER said to" | mail $admin
X
Xrm -f $F*
END_OF_FILE
if test 995 -ne `wc -c <'newsbin.proto/control/rmgroup.auto'`; then
    echo shar: \"'newsbin.proto/control/rmgroup.auto'\" unpacked with wrong size!
fi
# end of 'newsbin.proto/control/rmgroup.auto'
fi
if test -f 'rna/lib/bsearch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rna/lib/bsearch.c'\"
else
echo shar: Extracting \"'rna/lib/bsearch.c'\" \(876 characters\)
sed "s/^X//" >'rna/lib/bsearch.c' <<'END_OF_FILE'
X/*LINTLIBRARY*/
X/*
X * Binary search algorithm, generalized from Knuth (6.2.1) Algorithm B.
X *
X * Written by J. S. Rugaber; rewritten by L. Rosler, Dept. 45175, August, 1981.
X */
X
Xtypedef char *POINTER;
X
XPOINTER
Xbsearch(key, base, nel, width, compar)
XPOINTER	key;			/* Key to be located */
XPOINTER	base;			/* Beginning of table */
Xunsigned nel;			/* Number of elements in the table */
Xunsigned width;			/* Width of an element (bytes) */
Xint	(*compar)();		/* Comparison function */
X{
X	int two_width = width + width;
X	POINTER last = base + width * (nel - 1); /* Last element in table */
X
X	while (last >= base) {
X
X		register POINTER p = base + width * ((last - base)/two_width);
X		register int res = (*compar)(key, p);
X
X		if (res == 0)
X			return (p);	/* Key found */
X		if (res < 0)
X			last = p - width;
X		else
X			base = p + width;
X	}
X	return ((POINTER) 0);		/* Key not found */
X}
END_OF_FILE
if test 876 -ne `wc -c <'rna/lib/bsearch.c'`; then
    echo shar: \"'rna/lib/bsearch.c'\" unpacked with wrong size!
fi
# end of 'rna/lib/bsearch.c'
fi
if test -f 'rna/news.help' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rna/news.help'\"
else
echo shar: Extracting \"'rna/news.help'\" \(880 characters\)
sed "s/^X//" >'rna/news.help' <<'END_OF_FILE'
XCommands to read news:
X
XRETURN	    either print current article or go to next article and print header
X
X.	    print current article	+ or ;	  go to next article
X- 	    go to previous article	s [file]  save current article
Xh	    print current header	H	  print current header in full
Xu	    unsubscribe from followups	U	  unsubscribe from current group
Xq or EOT    quit			x	  exit (as if no articles seen)
X<number>    go to article <number>	!cmd	  shell escape
Xn [newsgrp] go to next newsgroup	DEL	  break to command level
X
XCommands to post/reply/cancel news:
X
Xc	    cancel article 		r	  reply to sender (by mail)
Xf	    post a followup article	p	  post new article
Xm person    mail to person
X
XCommands when posting/replying (p, r, f and m commands):
X
X. or EOT    terminate article		.e	  edit article
X.!cmd	    shell escape		.i	  interpolate current item
XDEL	    abort posting/mailing
END_OF_FILE
if test 880 -ne `wc -c <'rna/news.help'`; then
    echo shar: \"'rna/news.help'\" unpacked with wrong size!
fi
# end of 'rna/news.help'
fi
if test -f 'rna/postgroup.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rna/postgroup.sh'\"
else
echo shar: Extracting \"'rna/postgroup.sh'\" \(890 characters\)
sed "s/^X//" >'rna/postgroup.sh' <<'END_OF_FILE'
X# postgroups
X#	Michael Rourke July 84
XDCS= EE= STAFF= HON= PG=
Xfor G in `/etc/bin/mkclass -l`
Xdo
X	case $G in
X	DCS*|C-*)	DCS="$DCS $G";;
X	EE*)	EE="$EE $G";;
X	esac
X	case $G in
X	*Staff)	STAFF="$STAFF $G";;
X	*HON)	HON="$HON $G";;
X	*PG)	PG="$PG $G";;
X	esac
Xdone
XALL="$STAFF $HON $PG"
XBAD= LIST=
Xif [ $# -gt 0 ]
Xthen
X	case "$1" in
X	DCS|EE|STAFF|HON|PG|ALL) LIST="$LIST `eval echo '$'$1`";;
X	*) echo "Unknown group: $1"
X	   BAD=1;;
X	esac
Xfi
Xif [ $# -eq 0 -o -n "$BAD" ]
Xthen
X	cat <<!
XUsage: postgroup group [ postnews_args ... ]
X    Groups are:
X	STAFF	(All staff:$STAFF)
X	DCS	(Dept of CS Staff, Hons & PG Students:
X			$DCS)
X	EE	(Elec Eng Staff, Hons & PG Students:$EE)
X	HON	(Honours Students:$HON)
X	PG	(Post Grad Students:$PG)
X	ALL	(All the above:
X			$ALL)
X!
X	exit 1
Xfi
XNL=
Xfor L in $LIST
Xdo
X	if [ ! "$NL" ]
X	then
X		NL="class.$L"
X	else
X		NL="$NL,class.$L"
X	fi
Xdone
Xexec /bin/postnews -n "$NL" $2*
END_OF_FILE
if test 890 -ne `wc -c <'rna/postgroup.sh'`; then
    echo shar: \"'rna/postgroup.sh'\" unpacked with wrong size!
fi
# end of 'rna/postgroup.sh'
fi
if test -f 'rna/uurec.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rna/uurec.c'\"
else
echo shar: Extracting \"'rna/uurec.c'\" \(1167 characters\)
sed "s/^X//" >'rna/uurec.c' <<'END_OF_FILE'
X/*
X * uurec - receive articles via /bin/mail.
X */
X
X#include "defs.h"
X
X#undef OTHER
X
X#define FROM	01
X#define NLIN	02
X#define BLANK	03
X#define OTHER	04
X
X#define SKIPPING	010
X#define READING		020
X
X#define BFSZ 250
X
Xmain()
X{
X	char buf[BFSZ];
X	register FILE 	*pipe;
X	register int mode, frmflg;
X
X	pipe = stdout;
X	mode = SKIPPING;
X	frmflg = FALSE;
X	while (fgets(buf, BFSZ, stdin) != NULL)
X		switch (mode | type(buf)) {
X		case FROM | SKIPPING:
X			frmflg = TRUE;
X			break;
X
X		case FROM | READING:
X			if (!frmflg) {
X				frmflg = TRUE;
X				pclose(pipe);
X			}
X			break;
X
X		case NLIN | SKIPPING:
X			mode = READING;
X
X		case NLIN | READING:
X			if (frmflg) {
X				frmflg = FALSE;
X				if ((pipe = popen(RNEWS, "w")) == NULL) {
X					perror("uurec: popen failed");
X					exit(1);
X				}
X			}
X			fputs(buf + 1, pipe);
X			break;
X
X		case OTHER | SKIPPING:
X			break;
X
X		case OTHER | READING:
X			pclose(pipe);
X			mode = SKIPPING;
X		}
X	if (pipe)
X		pclose(pipe);
X	exit(0);
X}
X
X
Xtype(p)
Xregister char *p;
X{
X	while (*p == ' ' || *p == '?')
X		++p;
X
X	if (*p == 'N')
X		return (NLIN);
X
X	if (CMPN(p, ">From", 5) == 0)
X		return (FROM);
X
X	if (CMPN(p, "From", 4) == 0)
X		return (FROM);
X
X	return(OTHER);
X}
X
X
END_OF_FILE
if test 1167 -ne `wc -c <'rna/uurec.c'`; then
    echo shar: \"'rna/uurec.c'\" unpacked with wrong size!
fi
# end of 'rna/uurec.c'
fi
if test -f 'rnews/ads/1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/ads/1'\"
else
echo shar: Extracting \"'rnews/ads/1'\" \(1114 characters\)
sed "s/^X//" >'rnews/ads/1' <<'END_OF_FILE'
XINEWS. We have
Xthe technology
Xtoday to bring 'em
Xback tomorrow.
X
X    By the 1990s, fighter pilots will need an inte-
Xgrated electronic warfare suite that fuses the
Xcapabilities of multiple warning and response sys-
Xtems. Advanced technology that provides complete
Xprotection with greater reliability. That system is the
XIntegrated Electronic Warfare System - INEWS.
X    The TRW/Westinghouse Joint Venture is the
Xonly team that offers such a powerful combination
Xof advanced technologies and specific, long-term
Xexperience for INEWS.
X    Our Phase I and II VHSIC contracts, together
Xwith our VHSIC 1750A program, will increase pro-
Xcessing speed and memory and reduce space and
Xpower demands. Our wideband microwave trans-
Xmitters and receivers can make functional integra-
Xtion a cost-effective, operational reality. Our detector
Xtechnologies ensure instant warning of all fore-
Xseeable threats. And our expendables technology
Xprovides a wide range of threat-response options.
X    TRW and Westinghouse with
XHoneywell, Perkin-Elmer, and Tracor.
XThe team with the technology today
Xto bring 'em back tomorrow.
X
X  TRW
END_OF_FILE
if test 1114 -ne `wc -c <'rnews/ads/1'`; then
    echo shar: \"'rnews/ads/1'\" unpacked with wrong size!
fi
# end of 'rnews/ads/1'
fi
if test -f 'rnews/ads/2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/ads/2'\"
else
echo shar: Extracting \"'rnews/ads/2'\" \(979 characters\)
sed "s/^X//" >'rnews/ads/2' <<'END_OF_FILE'
XINEWS. Technology on a totally different plane.
X
X    The Raytheon-Northrop joint
Xventure team brings state-of-the-art
Xtechnology to the competition for
Xthe Integrated Electronic Warfare
XSystem. INEWS will go aboard the
Xnext generation of tactical aircraft.
X    The combination of Raytheon
Xand Northrop unites their comple-
Xmentary capabilities in the design,
Xdevelopment and production of
Xinnovative EW systems.
X    Team members AT&T Tech-
Xnology Systems (Bell Labs), GTE,
XMagnavox and Tracor provide
Xadditional experience which is
Xkey to successful integration of
Xadvanced technologies.
X    No other EW team provides
Xthis same level of expertise in
Xradar systems, surface-to-air mis-
Xsiles and advanced tactical and
Xstrategic aircraft. Strengths that
Xare essential to INEWS develop-
Xment and support.
X    The Raytheon and Northrop
Xjoint venture team. Expertise on a
Xtotally different plane.
X
XRaytheon NORTHROP
XJoint venture program office
X6380 Hollister Avenue
XGoleta, CA 93117
END_OF_FILE
if test 979 -ne `wc -c <'rnews/ads/2'`; then
    echo shar: \"'rnews/ads/2'\" unpacked with wrong size!
fi
# end of 'rnews/ads/2'
fi
if test -f 'rnews/ads/3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/ads/3'\"
else
echo shar: Extracting \"'rnews/ads/3'\" \(1027 characters\)
sed "s/^X//" >'rnews/ads/3' <<'END_OF_FILE'
XINEWS.
XTheir future
Xdepends on it.
X
XIn the 1990's and beyond, our pilots' survival and
Xtheir mission success will rely on an effective
XIntegrated Electronic Warfare Systems (INEWS).
XGuaranteeing the best INEWS for tomorrow
Xmeans selecting the right team to build it today.
X     With Honeywell, Perkin-Elmer, and Tracor,
Xthe TRW/Westinghouse team brings an un-
Xrivaled program and technology baseline to
XINEWS. Together we are concentrating on
Xsystem level development...providing risk
Xreduction where it counts: system software
Xand system integration.
X     Our team offers Ada on VHSIC, complete
XINEWS system simulation, expert system devel-
Xopment for full situation awareness and response
Xmanagement, and reliability and maintainability
Xrisk reduction to reduce operation and support
Xcosts while increasing system availability. The
XTRW/Westinghouse INEWS--reliable perform-
Xance to beat the threat, sustainable in conflict,
Xaffordable for a lifetime.
X    INEWS: The System for Their Future--
Xfrom TRW and Westinghouse.
X
X	TRW
END_OF_FILE
if test 1027 -ne `wc -c <'rnews/ads/3'`; then
    echo shar: \"'rnews/ads/3'\" unpacked with wrong size!
fi
# end of 'rnews/ads/3'
fi
if test -f 'rnews/anews/b.to.a' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/anews/b.to.a'\"
else
echo shar: Extracting \"'rnews/anews/b.to.a'\" \(798 characters\)
sed "s/^X//" >'rnews/anews/b.to.a' <<'END_OF_FILE'
X#! /bin/sh
X# bnewstoa: B-format news to A-format converter (why, oh, why?) (thanks, Norman)
XPATH=/bin:/usr/bin:/usr/ucb; export PATH
X
Xawk '
XNR==1,/^$/	{		# headers: save A headers only
X	if ($0 ~ /^Message-ID: /)
X		msgid=$2
X	else if ($0 ~ /^Newsgroups: /)
X		ngs=$2
X	else if ($0 ~ /^Path: /)
X		path=$2
X	else if ($0 ~ /^Date: /) {
X		date = $2	# skip "Date:"
X		for (i = 3; i <= NF; i++)
X			date = date " " $i	# append remaining fields
X	} else if ($0 ~ /^Subject: /)
X		subj=$2
X	else if ($0 ~ /^$/) {	# end of headers: spew out A-format equivalent
X		print "A" msgid
X		print ngs
X		print path
X		print date
X		print subj
X		inbody = "yes"
X		noblanksyet = "yes"
X	}
X}
Xinbody=="yes"	{	# copy body except first blank line, if present
X	if ($0 ~ /^$/ && noblanksyet == "yes")
X		noblanksyet = "no"
X	else
X		print
X}
X'
END_OF_FILE
if test 798 -ne `wc -c <'rnews/anews/b.to.a'`; then
    echo shar: \"'rnews/anews/b.to.a'\" unpacked with wrong size!
fi
# end of 'rnews/anews/b.to.a'
fi
if test -f 'rnews/hostname.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/hostname.c'\"
else
echo shar: Extracting \"'rnews/hostname.c'\" \(881 characters\)
sed "s/^X//" >'rnews/hostname.c' <<'END_OF_FILE'
X/*
X * hostname - return the Usenet name of this machine
X *
X * One interesting possibility would be to assume that the first
X * name in the sys file is our Usenet name, unless it is "ME",
X * which would require our current strategy anyway.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X
X#include "news.h"
X#include "newspaths.h"
X
X#ifndef NAMEFILE
X#define NAMEFILE libfile("whoami")
X#endif
X
Xchar *
Xhostname()			/* return this Usenet machine's name */
X{
X	static char name[MAXHOST];
X
X	if (name[0] == '\0') {	/* try to get the "news hostname" */
X		FILE *fp;
X
X		fp = fopen(NAMEFILE, "r");
X		if (fp != NULL) {
X			(void) fgets(name, sizeof name, fp);
X			(void) fclose(fp);
X			if (name[0] != '\0' && name[strlen(name) - 1] == '\n')
X				name[strlen(name) - 1] = '\0';
X		}
X	}
X	if (name[0] == '\0')	/* else use the ordinary hostname */
X		(void) gethostname(name, sizeof name);
X	return name;
X}
END_OF_FILE
if test 881 -ne `wc -c <'rnews/hostname.c'`; then
    echo shar: \"'rnews/hostname.c'\" unpacked with wrong size!
fi
# end of 'rnews/hostname.c'
fi
if test -f 'rnews/man/inews.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/man/inews.1'\"
else
echo shar: Extracting \"'rnews/man/inews.1'\" \(1160 characters\)
sed "s/^X//" >'rnews/man/inews.1' <<'END_OF_FILE'
X.TH INEWS 1 Usenet "Public Domain"
X.DA 22 Aug 1987
X.SH NAME
Xinews \- `user-friendly' front-end for rnews
X.SH SYNOPSIS
X.B inews
X[
X.B \-h
X]
X.\" TODO: fill in silly B options here
X[
Xfile ...
X]
X.SH DESCRIPTION
X.I Inews
Xbroadcasts a (network) news article
X(\fIi\fPnjects it into the
X.I news
Xflow)
Xnormally
Xby giving it as standard input to
X.IR rnews (1),
Xafter adding and altering headers.
XThe article will instead be mailed
Xto the moderators of the moderated newsgroups in the
X.I Newsgroups:
Xheader,
Xif any are found.
XNormal usage is simply
X.IR "inews -h" .
X.PP
XThere are plenty of silly options
X(inherited from B news)
Xwhich are essentially all equivalent to
Xadding headers.
X.SH FILES
X.PD 0
X.TP 1.5i
X.IB $NEWSCTL /active
Xcontains (un)moderated flag
X.PD
X.SH "SEE ALSO"
X.IR mail (1),
X.IR rnews (1)
X.\" .SH DIAGNOSTICS
X.\" This section appears ONLY if there is something unobvious and important about
X.\" the diagnostics or the general behavior in case of error.
X.SH HISTORY
XWritten by Geoff Collyer
Xat the University of Toronto
Xas part of the C news project.
X.SH BUGS
X.I Inews
Xshould be unnecessary;
Xmost long-time news posters simply use
X.I rnews
Xdirectly anyway.
END_OF_FILE
if test 1160 -ne `wc -c <'rnews/man/inews.1'`; then
    echo shar: \"'rnews/man/inews.1'\" unpacked with wrong size!
fi
# end of 'rnews/man/inews.1'
fi
if test -f 'rnews/serverrnews' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/serverrnews'\"
else
echo shar: Extracting \"'rnews/serverrnews'\" \(906 characters\)
sed "s/^X//" >'rnews/serverrnews' <<'END_OF_FILE'
X#! /bin/sh
X# execute relaynews commands on the server, for the sake of locking
XNEWSCTL=${NEWSCTL-/usr/lib/news}	# export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}	# export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}	# export NEWSARTS
XPATH=$NEWSCTL:$NEWSBIN:$NEWSBIN/relay:/bin:/usr/bin:/usr/ucb:/usr/local; export PATH
X
X# set -x
Xserver=`cat $NEWSCTL/server 2>/dev/null`
Xcase "$server" in
X"")	server="`hostname`" ;;		# if no server file, assume this is it
Xesac
Xcase "`hostname`" in
X$server)
X	case $# in
X	0)	exec relaynews ;;		# do it locally
X	*)	exec relaynews "$@" ;;		# do it locally
X	esac
X	;;
X*)				# kick it to the server
X	here="`pwd`"
X	case "$here" in
X	/n/*)	;;		# already anchored
X	*)			# needs to be qualified
X		HOST="`hostname`"
X		here=/n/$HOST/$here	# V8-style remote machine name
X		;;
X	esac
X	cmd=""
X	for arg
X	do
X		cmd="$cmd "\'$arg\'
X	done
X	exec rsh $server "cd $here; relaynews $cmd"
X	;;
Xesac
END_OF_FILE
if test 906 -ne `wc -c <'rnews/serverrnews'`; then
    echo shar: \"'rnews/serverrnews'\" unpacked with wrong size!
fi
# end of 'rnews/serverrnews'
fi
if test -f 'rnews/sh/serverrnews' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/sh/serverrnews'\"
else
echo shar: Extracting \"'rnews/sh/serverrnews'\" \(906 characters\)
sed "s/^X//" >'rnews/sh/serverrnews' <<'END_OF_FILE'
X#! /bin/sh
X# execute relaynews commands on the server, for the sake of locking
XNEWSCTL=${NEWSCTL-/usr/lib/news}	# export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}	# export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}	# export NEWSARTS
XPATH=$NEWSCTL:$NEWSBIN:$NEWSBIN/relay:/bin:/usr/bin:/usr/ucb:/usr/local; export PATH
X
X# set -x
Xserver=`cat $NEWSCTL/server 2>/dev/null`
Xcase "$server" in
X"")	server="`hostname`" ;;		# if no server file, assume this is it
Xesac
Xcase "`hostname`" in
X$server)
X	case $# in
X	0)	exec relaynews ;;		# do it locally
X	*)	exec relaynews "$@" ;;		# do it locally
X	esac
X	;;
X*)				# kick it to the server
X	here="`pwd`"
X	case "$here" in
X	/n/*)	;;		# already anchored
X	*)			# needs to be qualified
X		HOST="`hostname`"
X		here=/n/$HOST/$here	# V8-style remote machine name
X		;;
X	esac
X	cmd=""
X	for arg
X	do
X		cmd="$cmd "\'$arg\'
X	done
X	exec rsh $server "cd $here; relaynews $cmd"
X	;;
Xesac
END_OF_FILE
if test 906 -ne `wc -c <'rnews/sh/serverrnews'`; then
    echo shar: \"'rnews/sh/serverrnews'\" unpacked with wrong size!
fi
# end of 'rnews/sh/serverrnews'
fi
if test -f 'rnews/string.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/string.c'\"
else
echo shar: Extracting \"'rnews/string.c'\" \(1092 characters\)
sed "s/^X//" >'rnews/string.c' <<'END_OF_FILE'
X/*
X * string operations
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include "news.h"
X
X/*
X * Copy tokens to firstone, remove all text starting at the first space.
X */
Xfirst(tokens, firstone)
Xregister char *tokens, *firstone;
X{
X	char *space;
X
X	(void) strcpy(firstone, tokens);
X	space = index(firstone, ' ');
X	if (space != NULL)
X		*space = '\0';		/* terminate firstone at first space */
X}
X
X/*
X * Turn a newsgroup name into a file name, in place.
X */
Xmkfilenm(ng)
Xregister char *ng;
X{
X	for (; *ng != '\0'; ng++)
X		if (*ng == NGDELIM)
X			*ng = FNDELIM;
X}
X
Xtrim(s)					/* trim trailing newline */
Xchar *s;
X{
X	register char *nl;
X
X	INDEX(s, '\n', nl);
X	if (nl != NULL)
X		*nl = '\0';
X}
X
Xchar *
Xskipsp(s)				/* skip any whitespace at *s */
Xregister char *s;
X{
X	while (iswhite(*s))
X		s++;
X	return s;
X}
X
X/* like strdup, but error if can't allocate */
Xchar *
Xstrsave(s)			/* copy s into malloced memory, if any */
Xchar *s;
X{
X	register char *news = malloc((unsigned)strlen(s) + 1);	/* include NUL */
X
X	if (news != NULL)
X		(void) strcpy(news, s);
X	else
X		errunlock("out of memory", "");
X	return news;
X}
END_OF_FILE
if test 1092 -ne `wc -c <'rnews/string.c'`; then
    echo shar: \"'rnews/string.c'\" unpacked with wrong size!
fi
# end of 'rnews/string.c'
fi
if test -f 'rnews/system.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/system.h'\"
else
echo shar: Extracting \"'rnews/system.h'\" \(1036 characters\)
sed "s/^X//" >'rnews/system.h' <<'END_OF_FILE'
X/*
X * parsed form of the SYSFILE
X */
Xstruct system {
X	char *sy_name;		/* machine name */
X	char *sy_excl;		/* exclusion list of machines */
X	char *sy_ngs;		/* newsgroup subscription list */
X	char *sy_distr;		/* distribution list */
X	char *sy_cmd;		/* command to transmit articles */
X	unsigned sy_lochops;	/* flags Ln value: local hops */
X	char sy_flags;		/* ornaments, encoded as bits */
X	struct system *sy_next;	/* link to next system */
X};
X
X/* sy_flags bits */
X#define FLG_IHAVEOLD	(1<<0)		/* N: broken I-have/send-me proto */
X/* #define FLG_PERM	(1<<1)		/* U: %s is a permanent file name */
X#define FLG_BATCH	(1<<2)		/* F: sy_cmd is batch filename */
X#define FLG_LOCAL	(1<<3)		/* L: send local articles only */
X#define FLG_IHAVE	(1<<4)		/* I: new I-have/send-me proto */
X#define FLG_MOD		(1<<5)		/* m: send moderated groups only */
X#define FLG_UNMOD	(1<<6)		/* u: send unmoderated groups only */
X#define FLG_SZBATCH	(1<<7)		/* f: like F, but include byte count */
X/* imports from system */
Xextern struct system *oursys(), *nextsys();
END_OF_FILE
if test 1036 -ne `wc -c <'rnews/system.h'`; then
    echo shar: \"'rnews/system.h'\" unpacked with wrong size!
fi
# end of 'rnews/system.h'
fi
if test -f 'rnews/test/demo/arts/art2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/test/demo/arts/art2'\"
else
echo shar: Extracting \"'rnews/test/demo/arts/art2'\" \(1025 characters\)
sed "s/^X//" >'rnews/test/demo/arts/art2' <<'END_OF_FILE'
XNewsgroups: net.drugs,net.emacs
XSubject: Re: Re: RE: re: rE: Re: Re: Orpha - (nf)
XMessage-ID: <willy.geoff@barek>
XHideous-Name: UCBVAX.@MIT-MC.@udel-relay.ARPA.chris.umcp-cs@UDEL-Relay
XDate-Received: yesterday
XRelay-Version: version A+; site rosen.rich
XPath: research!ihnp4!ihnp3!ihnp1!packard!topaz!cbosgd!drugvax!root
X
X> daemon:*:1:daemon,uucp
X> sys:*:2:bin,sys
X> bin70:*:3:
X> uucp70:*:4:
X> general:*:5:adams,al
X
XYou're all a bunch of fascists!
X-- 
XFish Face, Morons Incorporated
X<insert life story here>
XUUCP: ucbvax!mit-mc%udel-relay.arpa@ff:umcp-cs::udel-relay
XARPA: @brl.arpa:ucbvax!mit-mc%udel-relay.arpa@ff:umcp-cs::udel-relay
XCSnet: @brl.arpa:ucbvax!mit-mc%udel-relay.arpa@ff:umcp-cs::udel-relay%csnet-relay
XDEC E-net: rhea::@brl.arpa:ucbvax!mit-mc%udel-relay.arpa@ff:umcp-cs::udel-relay%csnet-relay
XCDNnet: rhea::@brl.arpa:ucbvax!mit-mc%udel-relay.arpa@ff:umcp-cs::udel-relay%csnet-relay.vision.ubc.cdn
XBITnet: psuvax1!rhea::@brl.arpa:ucbvax!mit-mc%udel-relay.arpa@ff:umcp-cs::udel-relay%csnet-relay.vision.ubc.cdn
END_OF_FILE
if test 1025 -ne `wc -c <'rnews/test/demo/arts/art2'`; then
    echo shar: \"'rnews/test/demo/arts/art2'\" unpacked with wrong size!
fi
# end of 'rnews/test/demo/arts/art2'
fi
if test -f 'rnews/test/demo/arts/art3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/test/demo/arts/art3'\"
else
echo shar: Extracting \"'rnews/test/demo/arts/art3'\" \(993 characters\)
sed "s/^X//" >'rnews/test/demo/arts/art3' <<'END_OF_FILE'
XNewsgroups: net.general,comp.unix.lizards,comp.unix.bozos
XPath: vt100aa!uw-muskrat!lbl-clams!MAILER-DAEMON
XDate: 4 May 83 00:16:37 VDT (Wed)
XFrom: lbl-clams!MAILER-DAEMON (Mail Delivery Subsystem)
XTo: uw-muskrat!vt100aa!yzuxab!nail
XRelayed-by: somsite.UUCP
XPast-on-by: another.CCCP
XMunged-up-by: erewhon.UUCP
XPosting-version: 2.9E3
XSubject: Returned mail: Who knows why?
XMessage-Id: <8305040716.AA21547@LBL-CLAMS.BARFA>
XReceived: by LBL-CLAMS.BARFA (3.320/3.21)
X	id AA21547; 4 May 83 00:16:37 VDT (Wed)
X
X   ----- Transcript of session follows -----
Xsparrow@gatech.barfa... Connecting to gatech.tcp...
Xsparrow@gatech.barfa... Like, who knows, man?
X
X   ----- Unsent message follows -----
XDate: 4 May 83 00:16:37 VDT (Wed)
XFrom: vt100aa!yzuxab!nail@uw-muskrat.UUCP
XMessage-Id: <8305040716.AA21545@LBL-CLAMS.BARFA>
XReceived: by LBL-CLAMS.BARFA (3.320/3.21)
X	id AA21545; 4 May 83 00:16:37 VDT (Wed)
XTo: vt100aa!uw-muskrat!lbl-clams!sparrow@gatech.barfa
X
XPlease take my name off your mailing list.
X
END_OF_FILE
if test 993 -ne `wc -c <'rnews/test/demo/arts/art3'`; then
    echo shar: \"'rnews/test/demo/arts/art3'\" unpacked with wrong size!
fi
# end of 'rnews/test/demo/arts/art3'
fi
if test -f 'time/ctime.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'time/ctime.c'\"
else
echo shar: Extracting \"'time/ctime.c'\" \(1181 characters\)
sed "s/^X//" >'time/ctime.c' <<'END_OF_FILE'
X/*
X * ctime time_t ... - print the ascii time of time_t(s)
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include <time.h>
X#include <sys/types.h>
X#include <sys/timeb.h>
X
X#define	DAY	(24L*60L*60L)
X
Xstruct timeb ftnow;
X
Xchar *progname;
X
Xextern int errno;
Xextern char *strcpy();
Xextern char *strncpy();
Xextern char *strcat();
Xextern char *strchr();
Xextern char *strtok();
Xextern long atol();
Xextern char *malloc();
Xextern struct tm *gmtime();
Xextern time_t time();
X
X/* Forwards. */
Xextern void process();
X
X/*
X - main - parse arguments and handle options
X */
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	register int c;
X	register int errflg = 0;
X	extern int optind;
X	extern char *optarg;
X
X	progname = argv[0];
X	ftime(&ftnow);
X
X	while ((c = getopt(argc, argv, "")) != EOF)
X		switch (c) {
X		case '?':
X		default:
X			errflg++;
X			break;
X		}
X	if (errflg || optind == argc) {
X		(void) fprintf(stderr, "Usage: %s ascii_time ...\n", progname);
X		exit(2);
X	}
X
X	for (; optind < argc; optind++)
X		process(argv[optind]);
X	exit(0);
X}
X
X/*
X * process - print time_t of tm
X */
Xvoid
Xprocess(tms)
Xchar *tms;
X{
X	time_t tm;
X	char *ctime();
X	long atol();
X
X	tm = atol(tms);
X	(void) fputs(ctime(&tm), stdout);
X}
END_OF_FILE
if test 1181 -ne `wc -c <'time/ctime.c'`; then
    echo shar: \"'time/ctime.c'\" unpacked with wrong size!
fi
# end of 'time/ctime.c'
fi
echo shar: End of archive 3 \(of 14\).
##  End of shell archive.
exit 0
