Subject:  v12i026:  C News alpha release, Part01/14
Newsgroups: comp.sources.unix
Sender: sources
Approved: rs@uunet.UU.NET

Submitted-by: utzoo!henry (Henry Spencer)
Posting-number: Volume 12, Issue 26
Archive-name: cnews/part01

[  This is a re-write from the ground up of netnews for speed and
    efficiency.  It's a complete re-implmentation, able to learn from the
    previous versions.  It is an *ALPHA* release.  There are extensive
    caveats in the README files, which appear throughout.  Their is a
    paper in the Washington Usenix proceedings that describe the things
    Henry and Geoff did.  --r$  ]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 14)."
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo Making directories
mkdir batch batch/b.test expire gngp include input lib.proto lib.proto/rn
mkdir lib.proto/batch lib.proto/control lib.proto/syscmd libc libc/strings
mkdir libc/stdio.fast libc/memcpy.fast libc/memcpy.fast/src libcnews mail
mkdir mail/coder mail/b.compat newsbin.proto newsbin.proto/control
mkdir newsbin.proto/maint newsbin.proto/syscmd newshist rna rna/lib rna/man
mkdir rna/notes rnews rnews/vers rnews/vers/bsd42 rnews/vers/v7 rnews/vers/v8
mkdir rnews/vers/usg rnews/anews rnews/man rnews/test rnews/test/demo
mkdir rnews/test/demo/arts rnews/test/lib rnews/test/newsbatch
mkdir rnews/test/spool rnews/ads rnews/sh rnews/speed rnews/speed/disk
mkdir rnews/speed/mem rnews/bugs rnews/bugs/zeropad rnews/bugs/zeropad/okay
mkdir rnews/bugs/zeropad/bugged rnews/setnewsids time
if test -f 'batch/b.test/batchmunch' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'batch/b.test/batchmunch'\"
else
echo shar: Extracting \"'batch/b.test/batchmunch'\" \(4 characters\)
sed "s/^X//" >'batch/b.test/batchmunch' <<'END_OF_FILE'
Xcat
END_OF_FILE
if test 4 -ne `wc -c <'batch/b.test/batchmunch'`; then
    echo shar: \"'batch/b.test/batchmunch'\" unpacked with wrong size!
fi
# end of 'batch/b.test/batchmunch'
fi
if test -f 'batch/b.test/batchsize' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'batch/b.test/batchsize'\"
else
echo shar: Extracting \"'batch/b.test/batchsize'\" \(8 characters\)
sed "s/^X//" >'batch/b.test/batchsize' <<'END_OF_FILE'
Xecho 25
END_OF_FILE
if test 8 -ne `wc -c <'batch/b.test/batchsize'`; then
    echo shar: \"'batch/b.test/batchsize'\" unpacked with wrong size!
fi
# end of 'batch/b.test/batchsize'
fi
if test -f 'batch/b.test/batchxmit' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'batch/b.test/batchxmit'\"
else
echo shar: Extracting \"'batch/b.test/batchxmit'\" \(31 characters\)
sed "s/^X//" >'batch/b.test/batchxmit' <<'END_OF_FILE'
X( echo ------ ; cat ) >>output
END_OF_FILE
if test 31 -ne `wc -c <'batch/b.test/batchxmit'`; then
    echo shar: \"'batch/b.test/batchxmit'\" unpacked with wrong size!
fi
# end of 'batch/b.test/batchxmit'
fi
if test -f 'batch/b.test/goodoutput' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'batch/b.test/goodoutput'\"
else
echo shar: Extracting \"'batch/b.test/goodoutput'\" \(273 characters\)
sed "s/^X//" >'batch/b.test/goodoutput' <<'END_OF_FILE'
X------
X#! rnews 2
X0
X------
X#! rnews 2
X1
X#! rnews 2
X2
X------
X#! rnews 2
X3
X------
X#! rnews 2
X4
X------
X#! rnews 2
X5
X#! rnews 2
X6
X------
X#! rnews 2
X7
X------
X#! rnews 2
X8
X=== togo ===
X13 113
X=== togo.2 ===
X9 119
X=== togo.3 ===
X10 110
X=== togo.4 ===
X11 111
X=== togo.5 ===
X12 112
END_OF_FILE
if test 273 -ne `wc -c <'batch/b.test/goodoutput'`; then
    echo shar: \"'batch/b.test/goodoutput'\" unpacked with wrong size!
fi
# end of 'batch/b.test/goodoutput'
fi
if test -f 'batch/b.test/queuelen' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'batch/b.test/queuelen'\"
else
echo shar: Extracting \"'batch/b.test/queuelen'\" \(7 characters\)
sed "s/^X//" >'batch/b.test/queuelen' <<'END_OF_FILE'
Xecho 2
END_OF_FILE
if test 7 -ne `wc -c <'batch/b.test/queuelen'`; then
    echo shar: \"'batch/b.test/queuelen'\" unpacked with wrong size!
fi
# end of 'batch/b.test/queuelen'
fi
if test -f 'batch/b.test/queuemax' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'batch/b.test/queuemax'\"
else
echo shar: Extracting \"'batch/b.test/queuemax'\" \(7 characters\)
sed "s/^X//" >'batch/b.test/queuemax' <<'END_OF_FILE'
Xecho 9
END_OF_FILE
if test 7 -ne `wc -c <'batch/b.test/queuemax'`; then
    echo shar: \"'batch/b.test/queuemax'\" unpacked with wrong size!
fi
# end of 'batch/b.test/queuemax'
fi
if test -f 'batch/b.test/roomfor' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'batch/b.test/roomfor'\"
else
echo shar: Extracting \"'batch/b.test/roomfor'\" \(8 characters\)
sed "s/^X//" >'batch/b.test/roomfor' <<'END_OF_FILE'
Xecho 33
END_OF_FILE
if test 8 -ne `wc -c <'batch/b.test/roomfor'`; then
    echo shar: \"'batch/b.test/roomfor'\" unpacked with wrong size!
fi
# end of 'batch/b.test/roomfor'
fi
if test -f 'batch/b.test/test.togo' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'batch/b.test/test.togo'\"
else
echo shar: Extracting \"'batch/b.test/test.togo'\" \(76 characters\)
sed "s/^X//" >'batch/b.test/test.togo' <<'END_OF_FILE'
X1 10
X2 10
X3 10
X4 57
X5 10
X6 10
X7 117
X8 118
X9 119
X10 110
X11 111
X12 112
X13 113
END_OF_FILE
if test 76 -ne `wc -c <'batch/b.test/test.togo'`; then
    echo shar: \"'batch/b.test/test.togo'\" unpacked with wrong size!
fi
# end of 'batch/b.test/test.togo'
fi
if test -f 'batch/b.test/test.togo.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'batch/b.test/test.togo.3'\"
else
echo shar: Extracting \"'batch/b.test/test.togo.3'\" \(5 characters\)
sed "s/^X//" >'batch/b.test/test.togo.3' <<'END_OF_FILE'
X0 99
END_OF_FILE
if test 5 -ne `wc -c <'batch/b.test/test.togo.3'`; then
    echo shar: \"'batch/b.test/test.togo.3'\" unpacked with wrong size!
fi
# end of 'batch/b.test/test.togo.3'
fi
if test -f 'batch/batchsize' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'batch/batchsize'\"
else
echo shar: Extracting \"'batch/batchsize'\" \(152 characters\)
sed "s/^X//" >'batch/batchsize' <<'END_OF_FILE'
X# How big should the batches be?  100k becomes 50k or so after compression,
X# which is circa 10 minutes at 1200 baud -- a reasonable lump.
X
Xecho 100000
END_OF_FILE
if test 152 -ne `wc -c <'batch/batchsize'`; then
    echo shar: \"'batch/batchsize'\" unpacked with wrong size!
fi
# end of 'batch/batchsize'
fi
if test -f 'batch/batchxmit' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'batch/batchxmit'\"
else
echo shar: Extracting \"'batch/batchxmit'\" \(256 characters\)
sed "s/^X//" >'batch/batchxmit' <<'END_OF_FILE'
X# Transmit batch to $1.  -r for no immediate call, -gd to specify grade
X# of traffic as fairly low, -z to suppress return of exit-status-0 report.
X#
X# The 'exec' cuts down the number of processes active for this simple case.
X
Xexec uux - -r -gd -z $1!rnews
END_OF_FILE
if test 256 -ne `wc -c <'batch/batchxmit'`; then
    echo shar: \"'batch/batchxmit'\" unpacked with wrong size!
fi
# end of 'batch/batchxmit'
fi
if test -f 'batch/queuelen' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'batch/queuelen'\"
else
echo shar: Extracting \"'batch/queuelen'\" \(372 characters\)
sed "s/^X//" >'batch/queuelen' <<'END_OF_FILE'
X# Find size of current queue of news outbound to $1.
X#
X# You'll have to change this:  you almost certainly don't have uuoutq, but
X# you may have something similar.
X#
X# Just "echo 0" will do if you don't care about queue lengths.
X
XPATH=/bin:/usr/bin ; export PATH
Xit=`uuoutq | awk "\\$3 == \"news\" && \\$2 == \"$1\" {print \\$1}"`
Xcase $it
Xin
X	'')
X	it=0
X	;;
Xesac
Xecho $it
END_OF_FILE
if test 372 -ne `wc -c <'batch/queuelen'`; then
    echo shar: \"'batch/queuelen'\" unpacked with wrong size!
fi
# end of 'batch/queuelen'
fi
if test -f 'batch/queuemax' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'batch/queuemax'\"
else
echo shar: Extracting \"'batch/queuemax'\" \(210 characters\)
sed "s/^X//" >'batch/queuemax' <<'END_OF_FILE'
X# What is the maximum number of batches that should be queued for a site?
X# Somewhat arbitrary; really high values can eat disk in the event of a link
X# outage, really low values can impede news flow.
X
Xecho 10
END_OF_FILE
if test 210 -ne `wc -c <'batch/queuemax'`; then
    echo shar: \"'batch/queuemax'\" unpacked with wrong size!
fi
# end of 'batch/queuemax'
fi
if test -f 'expire/active.p' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'expire/active.p'\"
else
echo shar: Extracting \"'expire/active.p'\" \(186 characters\)
sed "s/^X//" >'expire/active.p' <<'END_OF_FILE'
Xfoo.one 00100 00000 m
Xbar.one 00100 00000 y
Xbletch.one 00100 00000 m
Xfoo.two 00100 00000 m
Xbar.two 00100 00000 m
Xbletch.four 00100 00000 m
Xfoo.three 00100 00000 y
Xbar.five 00100 00000 y
END_OF_FILE
if test 186 -ne `wc -c <'expire/active.p'`; then
    echo shar: \"'expire/active.p'\" unpacked with wrong size!
fi
# end of 'expire/active.p'
fi
if test -f 'expire/histconv' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'expire/histconv'\"
else
echo shar: Extracting \"'expire/histconv'\" \(287 characters\)
sed "s/^X//" >'expire/histconv' <<'END_OF_FILE'
X#! /bin/sh
X# Convert a B history file into a C one, naively:  makes no
X# attempt to supply sensible values for expiry date.  See mkhistory
X# for a way to do it right, at rather greater expense.
X
XPATH=/bin:/usr/bin ; export PATH
X
Xawk -F'	' 'BEGIN { OFS=FS } { print $1, $2 "~-", $3 }' $*
END_OF_FILE
if test 287 -ne `wc -c <'expire/histconv'`; then
    echo shar: \"'expire/histconv'\" unpacked with wrong size!
fi
# end of 'expire/histconv'
fi
if test -f 'expire/histdups' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'expire/histdups'\"
else
echo shar: Extracting \"'expire/histdups'\" \(369 characters\)
sed "s/^X//" >'expire/histdups' <<'END_OF_FILE'
X# Awk program to merge history lines for the same article in a sorted history
X# file (such as is generated during the mkhistory processing).
XBEGIN { FS = "\t" ; OFS = "\t" ; mesgid = "" }
X{
X	if ($1 != mesgid) {
X		if (mesgid != "")
X			print mesgid, dates, names
X		mesgid = $1
X		dates = $2
X		names = $3
X	} else
X		names = names " " $4
X}
XEND { print mesgid, dates, names }
END_OF_FILE
if test 369 -ne `wc -c <'expire/histdups'`; then
    echo shar: \"'expire/histdups'\" unpacked with wrong size!
fi
# end of 'expire/histdups'
fi
if test -f 'expire/mkhistory' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'expire/mkhistory'\"
else
echo shar: Extracting \"'expire/mkhistory'\" \(353 characters\)
sed "s/^X//" >'expire/mkhistory' <<'END_OF_FILE'
X# mkhistory spooldir - regenerate a news history file from the spool files
X
XNEWSCTL=${NEWSCTL-/usr/lib/news}
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}
XNEWSARTS=${NEWSARTS-/usr/spool/news}
XPATH=$NEWSBIN/expire:/bin:/usr/bin ; export PATH
X
Xcd $NEWSARTS
Xfind * -type f -name '[0-9]*' -print | xargs histinfo | sort |
X	awk -f $NEWSBIN/expire/histdups | histslash
END_OF_FILE
if test 353 -ne `wc -c <'expire/mkhistory'`; then
    echo shar: \"'expire/mkhistory'\" unpacked with wrong size!
fi
# end of 'expire/mkhistory'
fi
if test -f 'expire/testctl.p' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'expire/testctl.p'\"
else
echo shar: Extracting \"'expire/testctl.p'\" \(117 characters\)
sed "s/^X//" >'expire/testctl.p' <<'END_OF_FILE'
Xfoo.one,bar.one,bletch.one	x	10.5	@
Xfoo,bar				m	15	X/mod
Xfoo				u	5-15	X/unmod
Xall				m	5-10-20	X/mod
Xall				x	30	-
END_OF_FILE
if test 117 -ne `wc -c <'expire/testctl.p'`; then
    echo shar: \"'expire/testctl.p'\" unpacked with wrong size!
fi
# end of 'expire/testctl.p'
fi
if test -f 'expire/todo' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'expire/todo'\"
else
echo shar: Extracting \"'expire/todo'\" \(124 characters\)
sed "s/^X//" >'expire/todo' <<'END_OF_FILE'
Xmark as expired?
Xcheck 2.11 expire options
Xtest checker
Xhooks into dbm simulation for sysv
Xcross-posting tests
Xmake install
END_OF_FILE
if test 124 -ne `wc -c <'expire/todo'`; then
    echo shar: \"'expire/todo'\" unpacked with wrong size!
fi
# end of 'expire/todo'
fi
if test -f 'gngp/makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gngp/makefile'\"
else
echo shar: Extracting \"'gngp/makefile'\" \(254 characters\)
sed "s/^X//" >'gngp/makefile' <<'END_OF_FILE'
X# makefile for gngp
X
XDEFS = # -Dvoid=int
XCFLAGS = $(DEFS) -O # -Z
XLIBS= ../libcnews/libcnews.a ../libc/*.o
XLINTFLAGS = $(DEFS) -ha
X
Xgngp: gngp.o
X	$(CC) $(CFLAGS) gngp.o $(LIBS) -o $@
Xlint:
X	lint $(LINTFLAGS) gngp.c
Xlintport:
X	lint -p $(LINTFLAGS) gngp.c
END_OF_FILE
if test 254 -ne `wc -c <'gngp/makefile'`; then
    echo shar: \"'gngp/makefile'\" unpacked with wrong size!
fi
# end of 'gngp/makefile'
fi
if test -f 'include/fgetmfs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/fgetmfs.h'\"
else
echo shar: Extracting \"'include/fgetmfs.h'\" \(230 characters\)
sed "s/^X//" >'include/fgetmfs.h' <<'END_OF_FILE'
X/* values for fgetmfs flag */
X#define CONT_NO 0		/* no continuations */
X#define CONT_NOSPC 1		/* continue & remove leading whitespace */
X#define CONT_SPC 2		/* continue & keep leading whitespace */
X
X/* exports */
Xchar *fgetmfs();
END_OF_FILE
if test 230 -ne `wc -c <'include/fgetmfs.h'`; then
    echo shar: \"'include/fgetmfs.h'\" unpacked with wrong size!
fi
# end of 'include/fgetmfs.h'
fi
if test -f 'input/goo' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'input/goo'\"
else
echo shar: Extracting \"'input/goo'\" \(63 characters\)
sed "s/^X//" >'input/goo' <<'END_OF_FILE'
X#! cunbatch
X#! cunbatch
X#! cunbatch
Xfoo bar
Xbletch
X#! cunbatch
END_OF_FILE
if test 63 -ne `wc -c <'input/goo'`; then
    echo shar: \"'input/goo'\" unpacked with wrong size!
fi
# end of 'input/goo'
fi
if test -f 'input/rnews' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'input/rnews'\"
else
echo shar: Extracting \"'input/rnews'\" \(249 characters\)
sed "s/^X//" >'input/rnews' <<'END_OF_FILE'
X#! /bin/sh
X# Incoming-news spooling.
X
XNEWSCTL=${NEWSCTL-/usr/lib/news}
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}
XNEWSARTS=${NEWSARTS-/usr/spool/news}
XPATH=$NEWSBIN/input:/bin:/usr/bin ; export PATH
XNEWSUMASK=${NEWSUMASK-002}
Xumask NEWSUMASK
X
Xnewsspool $*
END_OF_FILE
if test 249 -ne `wc -c <'input/rnews'`; then
    echo shar: \"'input/rnews'\" unpacked with wrong size!
fi
# end of 'input/rnews'
fi
if test -f 'input/todo' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'input/todo'\"
else
echo shar: Extracting \"'input/todo'\" \(65 characters\)
sed "s/^X//" >'input/todo' <<'END_OF_FILE'
Xgeoff rnews
Xfrontend should not assume that unknown is cleartext
END_OF_FILE
if test 65 -ne `wc -c <'input/todo'`; then
    echo shar: \"'input/todo'\" unpacked with wrong size!
fi
# end of 'input/todo'
fi
if test -f 'lib.proto/control/ihave' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/control/ihave'\"
else
echo shar: Extracting \"'lib.proto/control/ihave'\" \(348 characters\)
sed "s/^X//" >'lib.proto/control/ihave' <<'END_OF_FILE'
X#! /bin/sh
X# ihave - stub for unimplemented I-have/send-me protocol
XNEWSCTL=${NEWSCTL-/usr/lib/news}; export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}; export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}; export NEWSARTS
XPATH=$NEWSCTL:$NEWSBIN:/bin:/usr/bin; export PATH
X
XSENDER="`newsreply`"
Xecho I-have/send-me not implemented | mail "$SENDER"
END_OF_FILE
if test 348 -ne `wc -c <'lib.proto/control/ihave'`; then
    echo shar: \"'lib.proto/control/ihave'\" unpacked with wrong size!
fi
# end of 'lib.proto/control/ihave'
fi
if test -f 'lib.proto/control/rmgroup' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/control/rmgroup'\"
else
echo shar: Extracting \"'lib.proto/control/rmgroup'\" \(321 characters\)
sed "s/^X//" >'lib.proto/control/rmgroup' <<'END_OF_FILE'
X#! /bin/sh
X# rmgroup group - snuff group
XF=/tmp/nc$$
Xadmin=usenet
X
Xcat >$F
XSENDER="`grep '^Sender:' $F | sed 's/^[^:]*: *//'`"
Xcase "$SENDER" in
X"")
X	SENDER="`grep '^From:' $F | sed 's/^[^:]*: *//'`"
X	;;
Xesac
X
X# tell the local usenet administrator to do it by hand
Xecho "rmgroup $1 says $SENDER" | mail $admin
X
Xrm -f $F*
END_OF_FILE
if test 321 -ne `wc -c <'lib.proto/control/rmgroup'`; then
    echo shar: \"'lib.proto/control/rmgroup'\" unpacked with wrong size!
fi
# end of 'lib.proto/control/rmgroup'
fi
if test -f 'lib.proto/control/rmgroup.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/control/rmgroup.man'\"
else
echo shar: Extracting \"'lib.proto/control/rmgroup.man'\" \(321 characters\)
sed "s/^X//" >'lib.proto/control/rmgroup.man' <<'END_OF_FILE'
X#! /bin/sh
X# rmgroup group - snuff group
XF=/tmp/nc$$
Xadmin=usenet
X
Xcat >$F
XSENDER="`grep '^Sender:' $F | sed 's/^[^:]*: *//'`"
Xcase "$SENDER" in
X"")
X	SENDER="`grep '^From:' $F | sed 's/^[^:]*: *//'`"
X	;;
Xesac
X
X# tell the local usenet administrator to do it by hand
Xecho "rmgroup $1 says $SENDER" | mail $admin
X
Xrm -f $F*
END_OF_FILE
if test 321 -ne `wc -c <'lib.proto/control/rmgroup.man'`; then
    echo shar: \"'lib.proto/control/rmgroup.man'\" unpacked with wrong size!
fi
# end of 'lib.proto/control/rmgroup.man'
fi
if test -f 'lib.proto/control/sendme' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/control/sendme'\"
else
echo shar: Extracting \"'lib.proto/control/sendme'\" \(348 characters\)
sed "s/^X//" >'lib.proto/control/sendme' <<'END_OF_FILE'
X#! /bin/sh
X# ihave - stub for unimplemented I-have/send-me protocol
XNEWSCTL=${NEWSCTL-/usr/lib/news}; export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}; export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}; export NEWSARTS
XPATH=$NEWSCTL:$NEWSBIN:/bin:/usr/bin; export PATH
X
XSENDER="`newsreply`"
Xecho I-have/send-me not implemented | mail "$SENDER"
END_OF_FILE
if test 348 -ne `wc -c <'lib.proto/control/sendme'`; then
    echo shar: \"'lib.proto/control/sendme'\" unpacked with wrong size!
fi
# end of 'lib.proto/control/sendme'
fi
if test -f 'lib.proto/ctl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/ctl'\"
else
echo shar: Extracting \"'lib.proto/ctl'\" \(0 characters\)
sed "s/^X//" >'lib.proto/ctl' <<'END_OF_FILE'
END_OF_FILE
if test 0 -ne `wc -c <'lib.proto/ctl'`; then
    echo shar: \"'lib.proto/ctl'\" unpacked with wrong size!
fi
# end of 'lib.proto/ctl'
fi
if test -f 'lib.proto/errlog' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/errlog'\"
else
echo shar: Extracting \"'lib.proto/errlog'\" \(0 characters\)
sed "s/^X//" >'lib.proto/errlog' <<'END_OF_FILE'
END_OF_FILE
if test 0 -ne `wc -c <'lib.proto/errlog'`; then
    echo shar: \"'lib.proto/errlog'\" unpacked with wrong size!
fi
# end of 'lib.proto/errlog'
fi
if test -f 'lib.proto/history' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/history'\"
else
echo shar: Extracting \"'lib.proto/history'\" \(0 characters\)
sed "s/^X//" >'lib.proto/history' <<'END_OF_FILE'
END_OF_FILE
if test 0 -ne `wc -c <'lib.proto/history'`; then
    echo shar: \"'lib.proto/history'\" unpacked with wrong size!
fi
# end of 'lib.proto/history'
fi
if test -f 'lib.proto/history.dir' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/history.dir'\"
else
echo shar: Extracting \"'lib.proto/history.dir'\" \(0 characters\)
sed "s/^X//" >'lib.proto/history.dir' <<'END_OF_FILE'
END_OF_FILE
if test 0 -ne `wc -c <'lib.proto/history.dir'`; then
    echo shar: \"'lib.proto/history.dir'\" unpacked with wrong size!
fi
# end of 'lib.proto/history.dir'
fi
if test -f 'lib.proto/history.pag' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/history.pag'\"
else
echo shar: Extracting \"'lib.proto/history.pag'\" \(0 characters\)
sed "s/^X//" >'lib.proto/history.pag' <<'END_OF_FILE'
END_OF_FILE
if test 0 -ne `wc -c <'lib.proto/history.pag'`; then
    echo shar: \"'lib.proto/history.pag'\" unpacked with wrong size!
fi
# end of 'lib.proto/history.pag'
fi
if test -f 'lib.proto/log' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/log'\"
else
echo shar: Extracting \"'lib.proto/log'\" \(0 characters\)
sed "s/^X//" >'lib.proto/log' <<'END_OF_FILE'
END_OF_FILE
if test 0 -ne `wc -c <'lib.proto/log'`; then
    echo shar: \"'lib.proto/log'\" unpacked with wrong size!
fi
# end of 'lib.proto/log'
fi
if test -f 'lib.proto/mailpaths' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/mailpaths'\"
else
echo shar: Extracting \"'lib.proto/mailpaths'\" \(30 characters\)
sed "s/^X//" >'lib.proto/mailpaths' <<'END_OF_FILE'
Xutstat	utstat!%s
Xall	uunet!%s
END_OF_FILE
if test 30 -ne `wc -c <'lib.proto/mailpaths'`; then
    echo shar: \"'lib.proto/mailpaths'\" unpacked with wrong size!
fi
# end of 'lib.proto/mailpaths'
fi
if test -f 'lib.proto/mkpdir' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/mkpdir'\"
else
echo shar: Extracting \"'lib.proto/mkpdir'\" \(343 characters\)
sed "s/^X//" >'lib.proto/mkpdir' <<'END_OF_FILE'
X#! /bin/sh
X# mkpdir dir ... - make directory and parents
XPATH=/bin:/usr/bin:/usr/ucb:/usr/lib/news; export PATH	# must include this file's dir.
Xstatus=0
X
Xfor dir
Xdo
X	mkdir "$dir" 2>/dev/null
X	if test ! -d "$dir"; then
X		mkpdir "`echo $dir | sed 's;/[^/]*$;;'`"
X		mkdir "$dir"
X		if test ! -d "$dir"; then
X			status=1
X		fi
X	fi
Xdone
Xexit $status
END_OF_FILE
if test 343 -ne `wc -c <'lib.proto/mkpdir'`; then
    echo shar: \"'lib.proto/mkpdir'\" unpacked with wrong size!
fi
# end of 'lib.proto/mkpdir'
fi
if test -f 'lib.proto/newsboot' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/newsboot'\"
else
echo shar: Extracting \"'lib.proto/newsboot'\" \(93 characters\)
sed "s/^X//" >'lib.proto/newsboot' <<'END_OF_FILE'
X#! /bin/sh
Xcd /usr/lib/news
Xrm -f LOCK* history.n* incoming/ns.* incoming/RLOCK incoming/L.*
END_OF_FILE
if test 93 -ne `wc -c <'lib.proto/newsboot'`; then
    echo shar: \"'lib.proto/newsboot'\" unpacked with wrong size!
fi
# end of 'lib.proto/newsboot'
fi
if test -f 'lib.proto/newsreply' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/newsreply'\"
else
echo shar: Extracting \"'lib.proto/newsreply'\" \(344 characters\)
sed "s/^X//" >'lib.proto/newsreply' <<'END_OF_FILE'
X#! /bin/sh
X# newsreply - print return address from news article on stdin
X# This version assumes a domain mailer (user@host.domain works)
XF=/tmp/nc$$
X
Xcat >$F
X
XSENDER="`grep '^Reply-To:' $F | sed 's/^[^:]*://
Xs/ (.*)//
X1q' `"
Xcase "$SENDER" in
X"")
X	SENDER="`grep '^From:' $F | sed 's/^[^:]*://
Xs/ (.*)//
X1q' `"
X	;;
Xesac
X
Xecho "$SENDER"
Xrm -f $F
END_OF_FILE
if test 344 -ne `wc -c <'lib.proto/newsreply'`; then
    echo shar: \"'lib.proto/newsreply'\" unpacked with wrong size!
fi
# end of 'lib.proto/newsreply'
fi
if test -f 'lib.proto/newsreply.from' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/newsreply.from'\"
else
echo shar: Extracting \"'lib.proto/newsreply.from'\" \(344 characters\)
sed "s/^X//" >'lib.proto/newsreply.from' <<'END_OF_FILE'
X#! /bin/sh
X# newsreply - print return address from news article on stdin
X# This version assumes a domain mailer (user@host.domain works)
XF=/tmp/nc$$
X
Xcat >$F
X
XSENDER="`grep '^Reply-To:' $F | sed 's/^[^:]*://
Xs/ (.*)//
X1q' `"
Xcase "$SENDER" in
X"")
X	SENDER="`grep '^From:' $F | sed 's/^[^:]*://
Xs/ (.*)//
X1q' `"
X	;;
Xesac
X
Xecho "$SENDER"
Xrm -f $F
END_OF_FILE
if test 344 -ne `wc -c <'lib.proto/newsreply.from'`; then
    echo shar: \"'lib.proto/newsreply.from'\" unpacked with wrong size!
fi
# end of 'lib.proto/newsreply.from'
fi
if test -f 'lib.proto/newsreply.path' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/newsreply.path'\"
else
echo shar: Extracting \"'lib.proto/newsreply.path'\" \(220 characters\)
sed "s/^X//" >'lib.proto/newsreply.path' <<'END_OF_FILE'
X#! /bin/sh
X# newsreply - print return address from news article on stdin
X# This version is for those without domain mailers
XF=/tmp/nc$$
X
Xcat >$F
X
XSENDER="`grep '^Path:' $F | sed 's/^[^:]*://' `"
X
Xecho "$SENDER"
Xrm -f $F
END_OF_FILE
if test 220 -ne `wc -c <'lib.proto/newsreply.path'`; then
    echo shar: \"'lib.proto/newsreply.path'\" unpacked with wrong size!
fi
# end of 'lib.proto/newsreply.path'
fi
if test -f 'lib.proto/organisation' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/organisation'\"
else
echo shar: Extracting \"'lib.proto/organisation'\" \(26 characters\)
sed "s/^X//" >'lib.proto/organisation' <<'END_OF_FILE'
XStatistics, U. of Toronto
END_OF_FILE
if test 26 -ne `wc -c <'lib.proto/organisation'`; then
    echo shar: \"'lib.proto/organisation'\" unpacked with wrong size!
fi
# end of 'lib.proto/organisation'
fi
if test -f 'lib.proto/universes' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/universes'\"
else
echo shar: Extracting \"'lib.proto/universes'\" \(127 characters\)
sed "s/^X//" >'lib.proto/universes' <<'END_OF_FILE'
X# universes of control
Xcabal	comp,news,sci,misc,talk,rec,soc
Xalt	alt
Xbit	list
Xlocal	to,junk,control,can,ont,tor,ut
Xmotd	utstat
END_OF_FILE
if test 127 -ne `wc -c <'lib.proto/universes'`; then
    echo shar: \"'lib.proto/universes'\" unpacked with wrong size!
fi
# end of 'lib.proto/universes'
fi
if test -f 'lib.proto/whoami' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/whoami'\"
else
echo shar: Extracting \"'lib.proto/whoami'\" \(7 characters\)
sed "s/^X//" >'lib.proto/whoami' <<'END_OF_FILE'
Xutstat
END_OF_FILE
if test 7 -ne `wc -c <'lib.proto/whoami'`; then
    echo shar: \"'lib.proto/whoami'\" unpacked with wrong size!
fi
# end of 'lib.proto/whoami'
fi
if test -f 'libc/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/README'\"
else
echo shar: Extracting \"'libc/README'\" \(304 characters\)
sed "s/^X//" >'libc/README' <<'END_OF_FILE'
XThese should, ideally, be inserted into your C library if they aren't
Xthere already.  If they can't be put into your C library nor -llocal,
Xjust put the ones not in your C library into libc.a in this directory.
X
XThey were all written by either Henry Spencer, Geoff Collyer or Brian
XKernighan & Rob Pike.
END_OF_FILE
if test 304 -ne `wc -c <'libc/README'`; then
    echo shar: \"'libc/README'\" unpacked with wrong size!
fi
# end of 'libc/README'
fi
if test -f 'libc/closeall.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/closeall.c'\"
else
echo shar: Extracting \"'libc/closeall.c'\" \(136 characters\)
sed "s/^X//" >'libc/closeall.c' <<'END_OF_FILE'
X#include <sys/param.h>
X
Xcloseall(leavestd)
Xint leavestd;
X{
X	register int i;
X
X	for (i = (leavestd? 3: 0); i < NOFILE; i++)
X		close(i);
X}
END_OF_FILE
if test 136 -ne `wc -c <'libc/closeall.c'`; then
    echo shar: \"'libc/closeall.c'\" unpacked with wrong size!
fi
# end of 'libc/closeall.c'
fi
if test -f 'libc/emalloc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/emalloc.c'\"
else
echo shar: Extracting \"'libc/emalloc.c'\" \(360 characters\)
sed "s/^X//" >'libc/emalloc.c' <<'END_OF_FILE'
X/*
X * emalloc - malloc with error() called when out of space
X */
X
X#define	NULL	0
X
Xchar *
Xemalloc(amount)
Xunsigned amount;
X{
X	register char *it;
X	char camount[25];		/* Enough to sprintf an unsigned. */
X	extern char *malloc();
X
X	it = malloc(amount);
X	if (it == NULL) {
X		sprintf(camount, "%u", amount);
X		error("malloc(%s) failed", camount);
X	}	
X
X	return(it);
X}
END_OF_FILE
if test 360 -ne `wc -c <'libc/emalloc.c'`; then
    echo shar: \"'libc/emalloc.c'\" unpacked with wrong size!
fi
# end of 'libc/emalloc.c'
fi
if test -f 'libc/error.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/error.c'\"
else
echo shar: Extracting \"'libc/error.c'\" \(148 characters\)
sed "s/^X//" >'libc/error.c' <<'END_OF_FILE'
X/*
X * error - print best error message possible and exit
X */
X
X#include <stdio.h>
X
Xerror(s1, s2)
Xchar *s1;
Xchar *s2;
X{
X	warning(s1, s2);
X	exit(1);
X}
END_OF_FILE
if test 148 -ne `wc -c <'libc/error.c'`; then
    echo shar: \"'libc/error.c'\" unpacked with wrong size!
fi
# end of 'libc/error.c'
fi
if test -f 'libc/memcpy.fast/src/obvious.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/memcpy.fast/src/obvious.c'\"
else
echo shar: Extracting \"'libc/memcpy.fast/src/obvious.c'\" \(146 characters\)
sed "s/^X//" >'libc/memcpy.fast/src/obvious.c' <<'END_OF_FILE'
Xmemcpy(to, from, count)		/* no alignment assumptions */
Xregister char *from, *to;
Xregister int count;
X{
X	while (count-- > 0)
X		*to++ = *from++;
X}
END_OF_FILE
if test 146 -ne `wc -c <'libc/memcpy.fast/src/obvious.c'`; then
    echo shar: \"'libc/memcpy.fast/src/obvious.c'\" unpacked with wrong size!
fi
# end of 'libc/memcpy.fast/src/obvious.c'
fi
if test -f 'libc/standard.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/standard.c'\"
else
echo shar: Extracting \"'libc/standard.c'\" \(223 characters\)
sed "s/^X//" >'libc/standard.c' <<'END_OF_FILE'
X#define	NULL	0
Xextern char	**environ;
Xstatic char	*stdenv[] = {
X	"PATH=/bin:/usr/bin",
X	"IFS= \t\n",
X	NULL
X};
X
Xstandard()
X{
X	environ = stdenv;
X	closeall(1);
X}
X
Xsafe()
X{
X	setgid(getgid());
X	setuid(getuid());
X	closeall(1);
X}
END_OF_FILE
if test 223 -ne `wc -c <'libc/standard.c'`; then
    echo shar: \"'libc/standard.c'\" unpacked with wrong size!
fi
# end of 'libc/standard.c'
fi
if test -f 'libc/stdio.fast/LEGAL.STDIO' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/stdio.fast/LEGAL.STDIO'\"
else
echo shar: Extracting \"'libc/stdio.fast/LEGAL.STDIO'\" \(163 characters\)
sed "s/^X//" >'libc/stdio.fast/LEGAL.STDIO' <<'END_OF_FILE'
XPage 165 of The C Programming Language describes some of the workings
Xof the UNIX stdio implementation. In particular, it describes the
Xfunction of _ptr and _cnt.
END_OF_FILE
if test 163 -ne `wc -c <'libc/stdio.fast/LEGAL.STDIO'`; then
    echo shar: \"'libc/stdio.fast/LEGAL.STDIO'\" unpacked with wrong size!
fi
# end of 'libc/stdio.fast/LEGAL.STDIO'
fi
if test -f 'libc/stdio.fast/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/stdio.fast/README'\"
else
echo shar: Extracting \"'libc/stdio.fast/README'\" \(234 characters\)
sed "s/^X//" >'libc/stdio.fast/README' <<'END_OF_FILE'
XThis directory does not form a library; fgets.o, fputs.o and rdwr.o
Xconstitute re-written stdio guts, thought to be compatible with the
Xusual UNIX stdio implementation.
X
Xmemcpy.o need only be generated if your C library lacks memcpy.
END_OF_FILE
if test 234 -ne `wc -c <'libc/stdio.fast/README'`; then
    echo shar: \"'libc/stdio.fast/README'\" unpacked with wrong size!
fi
# end of 'libc/stdio.fast/README'
fi
if test -f 'libc/stdio.fast/fputs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/stdio.fast/fputs.c'\"
else
echo shar: Extracting \"'libc/stdio.fast/fputs.c'\" \(161 characters\)
sed "s/^X//" >'libc/stdio.fast/fputs.c' <<'END_OF_FILE'
X#include <stdio.h>
X
Xfputs(s, fp)
Xregister char *s;
Xregister FILE *fp;
X{
X	unsigned len = strlen(s);
X
X	if (fwrite(s, 1, len, fp) < len)
X		return EOF;
X	return 0;
X}
END_OF_FILE
if test 161 -ne `wc -c <'libc/stdio.fast/fputs.c'`; then
    echo shar: \"'libc/stdio.fast/fputs.c'\" unpacked with wrong size!
fi
# end of 'libc/stdio.fast/fputs.c'
fi
if test -f 'libc/stdio.fast/makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/stdio.fast/makefile'\"
else
echo shar: Extracting \"'libc/stdio.fast/makefile'\" \(285 characters\)
sed "s/^X//" >'libc/stdio.fast/makefile' <<'END_OF_FILE'
X# makefile for dmr.faster
X
XSRC=fgets.c fputs.c rdwr.c # memcpy.c
XDEFINES = -DBSD # -pg # -Dvoid=int
XCFLAGS = $(DEFINES) -O
XLINTFLAGS = $(DEFINES) -ha
X
Xdmr.faster: $(SRC)
X	$(CC) $(CFLAGS) -c $(SRC)
X	touch $@
X
Xlint:
X	lint $(LINTFLAGS) -u $(SRC)
Xlintport:
X	lint -p $(LINTFLAGS) -u $(SRC)
END_OF_FILE
if test 285 -ne `wc -c <'libc/stdio.fast/makefile'`; then
    echo shar: \"'libc/stdio.fast/makefile'\" unpacked with wrong size!
fi
# end of 'libc/stdio.fast/makefile'
fi
if test -f 'libc/stdio.fast/memcpy.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/stdio.fast/memcpy.c'\"
else
echo shar: Extracting \"'libc/stdio.fast/memcpy.c'\" \(215 characters\)
sed "s/^X//" >'libc/stdio.fast/memcpy.c' <<'END_OF_FILE'
X/*
X * memcpy(3) stub in case none in C library
X */
X
Xmemcpy(to, from, len)
Xregister char *from, *to;
Xregister unsigned len;
X{
X	/* TODO: copy a word or long at a time */
X	for (++len; --len > 0; )
X		*to++ = *from++;
X}
END_OF_FILE
if test 215 -ne `wc -c <'libc/stdio.fast/memcpy.c'`; then
    echo shar: \"'libc/stdio.fast/memcpy.c'\" unpacked with wrong size!
fi
# end of 'libc/stdio.fast/memcpy.c'
fi
if test -f 'libc/stdio.fast/memcpy.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/stdio.fast/memcpy.h'\"
else
echo shar: Extracting \"'libc/stdio.fast/memcpy.h'\" \(65 characters\)
sed "s/^X//" >'libc/stdio.fast/memcpy.h' <<'END_OF_FILE'
X#ifdef BSD
X#define memcpy(to, from, n) bcopy(from, to, n)
X#endif
END_OF_FILE
if test 65 -ne `wc -c <'libc/stdio.fast/memcpy.h'`; then
    echo shar: \"'libc/stdio.fast/memcpy.h'\" unpacked with wrong size!
fi
# end of 'libc/stdio.fast/memcpy.h'
fi
if test -f 'libc/strings/bcmp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/bcmp.c'\"
else
echo shar: Extracting \"'libc/strings/bcmp.c'\" \(243 characters\)
sed "s/^X//" >'libc/strings/bcmp.c' <<'END_OF_FILE'
X/*
X - bcmp - Berklix equivalent of memcmp
X */
X
Xint				/* == 0 or != 0 for equality and inequality */
Xbcmp(s1, s2, length)
XCONST char *s1;
XCONST char *s2;	
Xint length;
X{
X	return(memcmp((CONST VOIDSTAR)s1, (CONST VOIDSTAR)s2, (SIZET)length));
X}
END_OF_FILE
if test 243 -ne `wc -c <'libc/strings/bcmp.c'`; then
    echo shar: \"'libc/strings/bcmp.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/bcmp.c'
fi
if test -f 'libc/strings/bcopy.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/bcopy.c'\"
else
echo shar: Extracting \"'libc/strings/bcopy.c'\" \(211 characters\)
sed "s/^X//" >'libc/strings/bcopy.c' <<'END_OF_FILE'
X/*
X - bcopy - Berklix equivalent of memcpy
X */
X
Xbcopy(src, dst, length)
XCONST char *src;
Xchar *dst;
Xint length;
X{
X	extern VOIDSTAR memcpy();
X
X	(void) memcpy((VOIDSTAR)dst, (CONST VOIDSTAR)src, (SIZET)length);
X}
END_OF_FILE
if test 211 -ne `wc -c <'libc/strings/bcopy.c'`; then
    echo shar: \"'libc/strings/bcopy.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/bcopy.c'
fi
if test -f 'libc/strings/bzero.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/bzero.c'\"
else
echo shar: Extracting \"'libc/strings/bzero.c'\" \(167 characters\)
sed "s/^X//" >'libc/strings/bzero.c' <<'END_OF_FILE'
X/*
X - bzero - Berklix subset of memset
X */
X
Xbzero(dst, length)
Xchar *dst;
Xint length;
X{
X	extern VOIDSTAR memset();
X
X	(void) memset((VOIDSTAR)dst, 0, (SIZET)length);
X}
END_OF_FILE
if test 167 -ne `wc -c <'libc/strings/bzero.c'`; then
    echo shar: \"'libc/strings/bzero.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/bzero.c'
fi
if test -f 'libc/strings/index.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/index.c'\"
else
echo shar: Extracting \"'libc/strings/index.c'\" \(242 characters\)
sed "s/^X//" >'libc/strings/index.c' <<'END_OF_FILE'
X/*
X * index - find first occurrence of a character in a string
X */
X
X#define	NULL	0
X
Xchar *				/* found char, or NULL if none */
Xindex(s, charwanted)
XCONST char *s;
Xchar charwanted;
X{
X	extern char *strchr();
X
X	return(strchr(s, charwanted));
X}
END_OF_FILE
if test 242 -ne `wc -c <'libc/strings/index.c'`; then
    echo shar: \"'libc/strings/index.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/index.c'
fi
if test -f 'libc/strings/rindex.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/rindex.c'\"
else
echo shar: Extracting \"'libc/strings/rindex.c'\" \(245 characters\)
sed "s/^X//" >'libc/strings/rindex.c' <<'END_OF_FILE'
X/*
X * rindex - find last occurrence of a character in a string
X */
X
X#define	NULL	0
X
Xchar *				/* found char, or NULL if none */
Xrindex(s, charwanted)
XCONST char *s;
Xchar charwanted;
X{
X	extern char *strrchr();
X
X	return(strrchr(s, charwanted));
X}
END_OF_FILE
if test 245 -ne `wc -c <'libc/strings/rindex.c'`; then
    echo shar: \"'libc/strings/rindex.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/rindex.c'
fi
if test -f 'libc/strings/strcat.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/strcat.c'\"
else
echo shar: Extracting \"'libc/strings/strcat.c'\" \(301 characters\)
sed "s/^X//" >'libc/strings/strcat.c' <<'END_OF_FILE'
X/*
X * strcat - append string src to dst
X */
Xchar *				/* dst */
Xstrcat(dst, src)
Xchar *dst;
XCONST char *src;
X{
X	register char *dscan;
X	register CONST char *sscan;
X
X	for (dscan = dst; *dscan != '\0'; dscan++)
X		continue;
X	sscan = src;
X	while ((*dscan++ = *sscan++) != '\0')
X		continue;
X	return(dst);
X}
END_OF_FILE
if test 301 -ne `wc -c <'libc/strings/strcat.c'`; then
    echo shar: \"'libc/strings/strcat.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/strcat.c'
fi
if test -f 'libc/strings/strcpy.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/strcpy.c'\"
else
echo shar: Extracting \"'libc/strings/strcpy.c'\" \(257 characters\)
sed "s/^X//" >'libc/strings/strcpy.c' <<'END_OF_FILE'
X/*
X * strcpy - copy string src to dst
X */
Xchar *				/* dst */
Xstrcpy(dst, src)
Xchar *dst;
XCONST char *src;
X{
X	register char *dscan;
X	register CONST char *sscan;
X
X	dscan = dst;
X	sscan = src;
X	while ((*dscan++ = *sscan++) != '\0')
X		continue;
X	return(dst);
X}
END_OF_FILE
if test 257 -ne `wc -c <'libc/strings/strcpy.c'`; then
    echo shar: \"'libc/strings/strcpy.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/strcpy.c'
fi
if test -f 'libc/strings/strerror.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/strerror.c'\"
else
echo shar: Extracting \"'libc/strings/strerror.c'\" \(317 characters\)
sed "s/^X//" >'libc/strings/strerror.c' <<'END_OF_FILE'
X/*
X * strerror - map error number to descriptive string
X *
X * This version is obviously somewhat Unix-specific.
X */
Xchar *
Xstrerror(errnum)
Xint errnum;
X{
X	extern int errno, sys_nerr;
X	extern char *sys_errlist[];
X
X	if (errnum > 0 && errnum < sys_nerr)
X		return(sys_errlist[errnum]);
X	else
X		return("unknown error");
X}
END_OF_FILE
if test 317 -ne `wc -c <'libc/strings/strerror.c'`; then
    echo shar: \"'libc/strings/strerror.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/strerror.c'
fi
if test -f 'libc/strings/strlen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/strlen.c'\"
else
echo shar: Extracting \"'libc/strings/strlen.c'\" \(218 characters\)
sed "s/^X//" >'libc/strings/strlen.c' <<'END_OF_FILE'
X/*
X * strlen - length of string (not including NUL)
X */
XSIZET
Xstrlen(s)
XCONST char *s;
X{
X	register CONST char *scan;
X	register SIZET count;
X
X	count = 0;
X	scan = s;
X	while (*scan++ != '\0')
X		count++;
X	return(count);
X}
END_OF_FILE
if test 218 -ne `wc -c <'libc/strings/strlen.c'`; then
    echo shar: \"'libc/strings/strlen.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/strlen.c'
fi
if test -f 'libcnews/complain.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libcnews/complain.c'\"
else
echo shar: Extracting \"'libcnews/complain.c'\" \(234 characters\)
sed "s/^X//" >'libcnews/complain.c' <<'END_OF_FILE'
X#include <stdio.h>
X
X/*
X - complain - lodge a complaint
X */
Xvoid
Xcomplain(s1, s2)
Xchar *s1;
Xchar *s2;
X{
X	extern char *progname;
X
X	(void) fprintf(stderr, "%s: ", progname);
X	(void) fprintf(stderr, s1, s2);
X	(void) putc('\n', stderr);
X}
END_OF_FILE
if test 234 -ne `wc -c <'libcnews/complain.c'`; then
    echo shar: \"'libcnews/complain.c'\" unpacked with wrong size!
fi
# end of 'libcnews/complain.c'
fi
if test -f 'libcnews/strlower.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libcnews/strlower.c'\"
else
echo shar: Extracting \"'libcnews/strlower.c'\" \(175 characters\)
sed "s/^X//" >'libcnews/strlower.c' <<'END_OF_FILE'
X/*
X * make a string all lower-case.
X */
X
X#include <ctype.h>
X
Xstrlower(s)
Xregister char *s;
X{
X	for (; *s != '\0'; ++s)
X		if (isascii(*s) && isupper(*s))
X			*s = tolower(*s);
X}
END_OF_FILE
if test 175 -ne `wc -c <'libcnews/strlower.c'`; then
    echo shar: \"'libcnews/strlower.c'\" unpacked with wrong size!
fi
# end of 'libcnews/strlower.c'
fi
if test -f 'mail/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mail/README'\"
else
echo shar: Extracting \"'mail/README'\" \(235 characters\)
sed "s/^X//" >'mail/README' <<'END_OF_FILE'
XThis pair of programs is used to exchange news articles
X(or batches of articles) by mail.
X
XThey are superior to the old B news compatible ones because they permit
Xtransmission of very long lines or binary files even over Bitnet links.
END_OF_FILE
if test 235 -ne `wc -c <'mail/README'`; then
    echo shar: \"'mail/README'\" unpacked with wrong size!
fi
# end of 'mail/README'
fi
if test -f 'mail/b.compat/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mail/b.compat/README'\"
else
echo shar: Extracting \"'mail/b.compat/README'\" \(90 characters\)
sed "s/^X//" >'mail/b.compat/README' <<'END_OF_FILE'
XThis pair of programs is used to exchange news articles
X(or batches of articles) by mail.
END_OF_FILE
if test 90 -ne `wc -c <'mail/b.compat/README'`; then
    echo shar: \"'mail/b.compat/README'\" unpacked with wrong size!
fi
# end of 'mail/b.compat/README'
fi
if test -f 'mail/b.compat/sendnews' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mail/b.compat/sendnews'\"
else
echo shar: Extracting \"'mail/b.compat/sendnews'\" \(161 characters\)
sed "s/^X//" >'mail/b.compat/sendnews' <<'END_OF_FILE'
X#! /bin/sh
X# sendnews destination - protect & mail article on stdin to destination
XPATH=/bin:/usr/bin:/usr/ucb; export PATH
X
X(echo ''; sed 's/^/N/') | mail "$1"
END_OF_FILE
if test 161 -ne `wc -c <'mail/b.compat/sendnews'`; then
    echo shar: \"'mail/b.compat/sendnews'\" unpacked with wrong size!
fi
# end of 'mail/b.compat/sendnews'
fi
if test -f 'mail/b.compat/uurec' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mail/b.compat/uurec'\"
else
echo shar: Extracting \"'mail/b.compat/uurec'\" \(154 characters\)
sed "s/^X//" >'mail/b.compat/uurec' <<'END_OF_FILE'
X#! /bin/sh
X# uurec - strip mail header & leading N's from stdin, feed to rnews
XPATH=/bin:/usr/bin:/usr/ucb; export PATH
X
Xsed -n '1,/^$/d
Xs/^N//p' | rnews
END_OF_FILE
if test 154 -ne `wc -c <'mail/b.compat/uurec'`; then
    echo shar: \"'mail/b.compat/uurec'\" unpacked with wrong size!
fi
# end of 'mail/b.compat/uurec'
fi
if test -f 'mail/coder/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mail/coder/README'\"
else
echo shar: Extracting \"'mail/coder/README'\" \(84 characters\)
sed "s/^X//" >'mail/coder/README' <<'END_OF_FILE'
XThese are rewritten versions of the standard 4BSD uu*code.c,
Xwhich run much faster.
END_OF_FILE
if test 84 -ne `wc -c <'mail/coder/README'`; then
    echo shar: \"'mail/coder/README'\" unpacked with wrong size!
fi
# end of 'mail/coder/README'
fi
if test -f 'mail/coder/dmr.faster' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mail/coder/dmr.faster'\"
else
echo shar: Extracting \"'mail/coder/dmr.faster'\" \(0 characters\)
sed "s/^X//" >'mail/coder/dmr.faster' <<'END_OF_FILE'
END_OF_FILE
if test 0 -ne `wc -c <'mail/coder/dmr.faster'`; then
    echo shar: \"'mail/coder/dmr.faster'\" unpacked with wrong size!
fi
# end of 'mail/coder/dmr.faster'
fi
if test -f 'mail/coder/makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mail/coder/makefile'\"
else
echo shar: Extracting \"'mail/coder/makefile'\" \(262 characters\)
sed "s/^X//" >'mail/coder/makefile' <<'END_OF_FILE'
X# makefile for uuencode and uudecode
XCFLAGS=-O # -p
XLIBS= dmr.faster/*.o
X
Xall: uuencode uudecode
X
Xuuencode: uuencode.o
X	$(CC) $(CFLAGS) -o $@ uuencode.o $(LIBS)
X
Xuudecode: uudecode.o
X	$(CC) $(CFLAGS) -o $@ uudecode.o $(LIBS)
X
Xclean:
X	rm -f uuencode uudecode *.o
END_OF_FILE
if test 262 -ne `wc -c <'mail/coder/makefile'`; then
    echo shar: \"'mail/coder/makefile'\" unpacked with wrong size!
fi
# end of 'mail/coder/makefile'
fi
if test -f 'mail/recmnews' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mail/recmnews'\"
else
echo shar: Extracting \"'mail/recmnews'\" \(350 characters\)
sed "s/^X//" >'mail/recmnews' <<'END_OF_FILE'
X#! /bin/sh
X# recmnews - strip mail header & trailing N's from stdin, uudecode, feed to rnews
XPATH=/bin:/usr/bin:/usr/ucb:/usr/lib/news; export PATH
X
XDIR=/tmp/rmn$$
Xif mkdir $DIR; then
X	: far out
Xelse
X	exit 1
Xfi
Xcd $DIR
X
Xsed -n '1,/^$/d
Xs/N$//p' | uudecode		# TODO: worry about full disks during uudecode
Xif rnews <news; then
X	cd /tmp
X	rm -rf $DIR
Xfi
END_OF_FILE
if test 350 -ne `wc -c <'mail/recmnews'`; then
    echo shar: \"'mail/recmnews'\" unpacked with wrong size!
fi
# end of 'mail/recmnews'
fi
if test -f 'mail/sendmnews' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mail/sendmnews'\"
else
echo shar: Extracting \"'mail/sendmnews'\" \(195 characters\)
sed "s/^X//" >'mail/sendmnews' <<'END_OF_FILE'
X#! /bin/sh
X# sendmnews destination - uuencode, add trailing N & mail article on stdin to destination
XPATH=/bin:/usr/bin:/usr/ucb; export PATH
X
X(echo ''; uuencode news | sed 's/$/N/') | mail "$1"
END_OF_FILE
if test 195 -ne `wc -c <'mail/sendmnews'`; then
    echo shar: \"'mail/sendmnews'\" unpacked with wrong size!
fi
# end of 'mail/sendmnews'
fi
if test -f 'newsbin.proto/control/rmgroup' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsbin.proto/control/rmgroup'\"
else
echo shar: Extracting \"'newsbin.proto/control/rmgroup'\" \(321 characters\)
sed "s/^X//" >'newsbin.proto/control/rmgroup' <<'END_OF_FILE'
X#! /bin/sh
X# rmgroup group - snuff group
XF=/tmp/nc$$
Xadmin=usenet
X
Xcat >$F
XSENDER="`grep '^Sender:' $F | sed 's/^[^:]*: *//'`"
Xcase "$SENDER" in
X"")
X	SENDER="`grep '^From:' $F | sed 's/^[^:]*: *//'`"
X	;;
Xesac
X
X# tell the local usenet administrator to do it by hand
Xecho "rmgroup $1 says $SENDER" | mail $admin
X
Xrm -f $F*
END_OF_FILE
if test 321 -ne `wc -c <'newsbin.proto/control/rmgroup'`; then
    echo shar: \"'newsbin.proto/control/rmgroup'\" unpacked with wrong size!
fi
# end of 'newsbin.proto/control/rmgroup'
fi
if test -f 'newsbin.proto/ctl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsbin.proto/ctl'\"
else
echo shar: Extracting \"'newsbin.proto/ctl'\" \(0 characters\)
sed "s/^X//" >'newsbin.proto/ctl' <<'END_OF_FILE'
END_OF_FILE
if test 0 -ne `wc -c <'newsbin.proto/ctl'`; then
    echo shar: \"'newsbin.proto/ctl'\" unpacked with wrong size!
fi
# end of 'newsbin.proto/ctl'
fi
if test -f 'newsbin.proto/mkpdir' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsbin.proto/mkpdir'\"
else
echo shar: Extracting \"'newsbin.proto/mkpdir'\" \(343 characters\)
sed "s/^X//" >'newsbin.proto/mkpdir' <<'END_OF_FILE'
X#! /bin/sh
X# mkpdir dir ... - make directory and parents
XPATH=/bin:/usr/bin:/usr/ucb:/usr/lib/news; export PATH	# must include this file's dir.
Xstatus=0
X
Xfor dir
Xdo
X	mkdir "$dir" 2>/dev/null
X	if test ! -d "$dir"; then
X		mkpdir "`echo $dir | sed 's;/[^/]*$;;'`"
X		mkdir "$dir"
X		if test ! -d "$dir"; then
X			status=1
X		fi
X	fi
Xdone
Xexit $status
END_OF_FILE
if test 343 -ne `wc -c <'newsbin.proto/mkpdir'`; then
    echo shar: \"'newsbin.proto/mkpdir'\" unpacked with wrong size!
fi
# end of 'newsbin.proto/mkpdir'
fi
if test -f 'newsbin.proto/newsreply' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsbin.proto/newsreply'\"
else
echo shar: Extracting \"'newsbin.proto/newsreply'\" \(344 characters\)
sed "s/^X//" >'newsbin.proto/newsreply' <<'END_OF_FILE'
X#! /bin/sh
X# newsreply - print return address from news article on stdin
X# This version assumes a domain mailer (user@host.domain works)
XF=/tmp/nc$$
X
Xcat >$F
X
XSENDER="`grep '^Reply-To:' $F | sed 's/^[^:]*://
Xs/ (.*)//
X1q' `"
Xcase "$SENDER" in
X"")
X	SENDER="`grep '^From:' $F | sed 's/^[^:]*://
Xs/ (.*)//
X1q' `"
X	;;
Xesac
X
Xecho "$SENDER"
Xrm -f $F
END_OF_FILE
if test 344 -ne `wc -c <'newsbin.proto/newsreply'`; then
    echo shar: \"'newsbin.proto/newsreply'\" unpacked with wrong size!
fi
# end of 'newsbin.proto/newsreply'
fi
if test -f 'newsbin.proto/newsreply.path' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsbin.proto/newsreply.path'\"
else
echo shar: Extracting \"'newsbin.proto/newsreply.path'\" \(220 characters\)
sed "s/^X//" >'newsbin.proto/newsreply.path' <<'END_OF_FILE'
X#! /bin/sh
X# newsreply - print return address from news article on stdin
X# This version is for those without domain mailers
XF=/tmp/nc$$
X
Xcat >$F
X
XSENDER="`grep '^Path:' $F | sed 's/^[^:]*://' `"
X
Xecho "$SENDER"
Xrm -f $F
END_OF_FILE
if test 220 -ne `wc -c <'newsbin.proto/newsreply.path'`; then
    echo shar: \"'newsbin.proto/newsreply.path'\" unpacked with wrong size!
fi
# end of 'newsbin.proto/newsreply.path'
fi
if test -f 'newshist/makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newshist/makefile'\"
else
echo shar: Extracting \"'newshist/makefile'\" \(353 characters\)
sed "s/^X//" >'newshist/makefile' <<'END_OF_FILE'
X# makefile for newshist
XRN=../rnews
XCFLAGS=-f68881 -I$(RN)	# for history.h
XRNEWSOBJS=$(RN)/history.o $(RN)/io.o $(RN)/msgs.o \
X	  $(RN)/clsexec.o $(RN)/memcpy.o $(RN)/string.o
XLIBOBJS= ../libcnews/*.a ../libc/*.a
XLIBS=-ldbm
X
Xnewshist: newshist.o $(RNEWSOBJS)
X	$(CC) $(CFLAGS) -o $@ newshist.o $(RNEWSOBJS) $(LIBOBJS) $(LIBS)
X
Xclean:
X	rm -f *.o newshist
END_OF_FILE
if test 353 -ne `wc -c <'newshist/makefile'`; then
    echo shar: \"'newshist/makefile'\" unpacked with wrong size!
fi
# end of 'newshist/makefile'
fi
if test -f 'rna/lib/itoa.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rna/lib/itoa.c'\"
else
echo shar: Extracting \"'rna/lib/itoa.c'\" \(86 characters\)
sed "s/^X//" >'rna/lib/itoa.c' <<'END_OF_FILE'
Xchar *
Xitoa(i)
Xint i;
X{
X	static char buf[30];
X
X	sprintf(buf, "%d", i);
X	return buf;
X}
END_OF_FILE
if test 86 -ne `wc -c <'rna/lib/itoa.c'`; then
    echo shar: \"'rna/lib/itoa.c'\" unpacked with wrong size!
fi
# end of 'rna/lib/itoa.c'
fi
if test -f 'rna/lib/memset.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rna/lib/memset.c'\"
else
echo shar: Extracting \"'rna/lib/memset.c'\" \(238 characters\)
sed "s/^X//" >'rna/lib/memset.c' <<'END_OF_FILE'
X/*LINTLIBRARY*/
X/*
X * Set an array of n chars starting at sp to the character c.
X * Return sp.
X */
Xchar *
Xmemset(sp, c, n)
Xregister char *sp, c;
Xregister int n;
X{
X	register char *sp0 = sp;
X
X	while (--n >= 0)
X		*sp++ = c;
X	return (sp0);
X}
END_OF_FILE
if test 238 -ne `wc -c <'rna/lib/memset.c'`; then
    echo shar: \"'rna/lib/memset.c'\" unpacked with wrong size!
fi
# end of 'rna/lib/memset.c'
fi
if test -f 'rna/makedistr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rna/makedistr'\"
else
echo shar: Extracting \"'rna/makedistr'\" \(230 characters\)
sed "s/^X//" >'rna/makedistr' <<'END_OF_FILE'
Xp=${1:+$1/}
Xd='!End!Marker!'
Xfor f in *
Xdo
X	if [ -d $f ]
X	then
X		echo "echo 'mkdir $p$f'"
X		echo "mkdir $p$f"
X		(cd $f; sh ../makedistr $p$f)
X	else
X		echo "echo 'x - $p$f'"
X		echo "cat > $p$f <<'"$d"'"
X		cat $f
X		echo $d
X	fi
Xdone
END_OF_FILE
if test 230 -ne `wc -c <'rna/makedistr'`; then
    echo shar: \"'rna/makedistr'\" unpacked with wrong size!
fi
# end of 'rna/makedistr'
fi
if test -f 'rna/man/uurec.8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rna/man/uurec.8'\"
else
echo shar: Extracting \"'rna/man/uurec.8'\" \(308 characters\)
sed "s/^X//" >'rna/man/uurec.8' <<'END_OF_FILE'
X.TH UUREC 8
X.SH NAME
Xuurec \- receive news articles via mail
X.SH SYNOPSIS
X.B /usr/lib/news/uurec
X.SH DESCRIPTION
X.I uurec
Xreads news articles from standard input sent by
X.IR uusend (8),
Xdecodes them, and gives each article to
X.IR postnews (1)
Xfor insertion.
X.SH SEE ALSO
Xpostnews(1), readnews(1),
Xuusend(8).
END_OF_FILE
if test 308 -ne `wc -c <'rna/man/uurec.8'`; then
    echo shar: \"'rna/man/uurec.8'\" unpacked with wrong size!
fi
# end of 'rna/man/uurec.8'
fi
if test -f 'rna/rnews.mail1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rna/rnews.mail1'\"
else
echo shar: Extracting \"'rna/rnews.mail1'\" \(30 characters\)
sed "s/^X//" >'rna/rnews.mail1' <<'END_OF_FILE'
XSubject: Error(s) from rnews
X
END_OF_FILE
if test 30 -ne `wc -c <'rna/rnews.mail1'`; then
    echo shar: \"'rna/rnews.mail1'\" unpacked with wrong size!
fi
# end of 'rna/rnews.mail1'
fi
if test -f 'rna/rnews.mail2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rna/rnews.mail2'\"
else
echo shar: Extracting \"'rna/rnews.mail2'\" \(21 characters\)
sed "s/^X//" >'rna/rnews.mail2' <<'END_OF_FILE'
X
X------------------
X
END_OF_FILE
if test 21 -ne `wc -c <'rna/rnews.mail2'`; then
    echo shar: \"'rna/rnews.mail2'\" unpacked with wrong size!
fi
# end of 'rna/rnews.mail2'
fi
if test -f 'rna/sample.sys' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rna/sample.sys'\"
else
echo shar: Extracting \"'rna/sample.sys'\" \(302 characters\)
sed "s/^X//" >'rna/sample.sys' <<'END_OF_FILE'
Xelecvax:test,general.all,net.all,aus.all,to.elecvax,mod.all,class.all::
Xbasser:net.all,aus.all,mod.all,to.basser::/usr/lib/news/uusend rnews:basser
Xelec70a:test,general.all,to.elec70a,class.all::exec net -helec70a -nrnews -f
Xelec70b:test,general.all,to.elec70b,class.all::exec net -helec70b -nrnews -f
END_OF_FILE
if test 302 -ne `wc -c <'rna/sample.sys'`; then
    echo shar: \"'rna/sample.sys'\" unpacked with wrong size!
fi
# end of 'rna/sample.sys'
fi
if test -f 'rnews/active.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/active.h'\"
else
echo shar: Extracting \"'rnews/active.h'\" \(132 characters\)
sed "s/^X//" >'rnews/active.h' <<'END_OF_FILE'
X/* imports from active */
Xextern long incartnum();
X
X#define nxtartnum(ng) incartnum(ng, 1)
X#define prevartnum(ng) incartnum(ng, -1)
END_OF_FILE
if test 132 -ne `wc -c <'rnews/active.h'`; then
    echo shar: \"'rnews/active.h'\" unpacked with wrong size!
fi
# end of 'rnews/active.h'
fi
if test -f 'rnews/ads/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/ads/README'\"
else
echo shar: Extracting \"'rnews/ads/README'\" \(50 characters\)
sed "s/^X//" >'rnews/ads/README' <<'END_OF_FILE'
XThese are reproduced verbatim from Aviation Week.
END_OF_FILE
if test 50 -ne `wc -c <'rnews/ads/README'`; then
    echo shar: \"'rnews/ads/README'\" unpacked with wrong size!
fi
# end of 'rnews/ads/README'
fi
if test -f 'rnews/anews/a.samp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/anews/a.samp'\"
else
echo shar: Extracting \"'rnews/anews/a.samp'\" \(103 characters\)
sed "s/^X//" >'rnews/anews/a.samp' <<'END_OF_FILE'
XA123@utcs.fun
Xnet.rec.drugs.crack
Xucbvax!ucbarpa!foo
XApr  1 00:00:00 1986
XWhee!
XBoy I like this stuff!
END_OF_FILE
if test 103 -ne `wc -c <'rnews/anews/a.samp'`; then
    echo shar: \"'rnews/anews/a.samp'\" unpacked with wrong size!
fi
# end of 'rnews/anews/a.samp'
fi
if test -f 'rnews/anews/a.samp.to.b' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/anews/a.samp.to.b'\"
else
echo shar: Extracting \"'rnews/anews/a.samp.to.b'\" \(173 characters\)
sed "s/^X//" >'rnews/anews/a.samp.to.b' <<'END_OF_FILE'
XMessage-ID: 123@utcs.fun
XNewsgroups: net.rec.drugs.crack
XPath: ucbvax!ucbarpa!foo
XFrom: ucbvax!ucbarpa!foo
XDate: Apr  1 00:00:00 1986
XSubject: Whee!
X
XBoy I like this stuff!
END_OF_FILE
if test 173 -ne `wc -c <'rnews/anews/a.samp.to.b'`; then
    echo shar: \"'rnews/anews/a.samp.to.b'\" unpacked with wrong size!
fi
# end of 'rnews/anews/a.samp.to.b'
fi
if test -f 'rnews/anews/a.to.b' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/anews/a.to.b'\"
else
echo shar: Extracting \"'rnews/anews/a.to.b'\" \(235 characters\)
sed "s/^X//" >'rnews/anews/a.to.b' <<'END_OF_FILE'
X#! /bin/sh
X# anustob: A-format nus to B-format converter (thanks, Norman)
XPATH=/bin:/usr/bin:/usr/ucb; export PATH
X
Xsed '
X1s/^A/Message-ID: /
X2s/^/Newsgroups: /
X3{
Xs/^/Path: /p
Xs/Path/From/
X}
X4s/^/Date: /
X5{
Xs/^/Subject: /p
Xs/.*//
X}
X'
END_OF_FILE
if test 235 -ne `wc -c <'rnews/anews/a.to.b'`; then
    echo shar: \"'rnews/anews/a.to.b'\" unpacked with wrong size!
fi
# end of 'rnews/anews/a.to.b'
fi
if test -f 'rnews/anews/b.samp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/anews/b.samp'\"
else
echo shar: Extracting \"'rnews/anews/b.samp'\" \(208 characters\)
sed "s/^X//" >'rnews/anews/b.samp' <<'END_OF_FILE'
XPath: ucbvax!ucbarpa!foo
XFrom: ucbvax!ucbarpa!foo
XSubject: Whee!
XNewsgroups: net.rec.drugs.crack
XMessage-ID: 123@utcs.fun
XDate: Apr  1 00:00:00 1986
XHideous-Name: #@$%ucbarpa^edu&*foo
X
XBoy I like this stuff!
END_OF_FILE
if test 208 -ne `wc -c <'rnews/anews/b.samp'`; then
    echo shar: \"'rnews/anews/b.samp'\" unpacked with wrong size!
fi
# end of 'rnews/anews/b.samp'
fi
if test -f 'rnews/anews/b.samp.to.a' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/anews/b.samp.to.a'\"
else
echo shar: Extracting \"'rnews/anews/b.samp.to.a'\" \(102 characters\)
sed "s/^X//" >'rnews/anews/b.samp.to.a' <<'END_OF_FILE'
XA123@utcs.fun
Xnet.rec.drugs.crack
Xucbvax!ucbarpa!foo
XApr 1 00:00:00 1986
XWhee!
XBoy I like this stuff!
END_OF_FILE
if test 102 -ne `wc -c <'rnews/anews/b.samp.to.a'`; then
    echo shar: \"'rnews/anews/b.samp.to.a'\" unpacked with wrong size!
fi
# end of 'rnews/anews/b.samp.to.a'
fi
if test -f 'rnews/bugs/zeropad/bugged/zeropad.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/bugs/zeropad/bugged/zeropad.c'\"
else
echo shar: Extracting \"'rnews/bugs/zeropad/bugged/zeropad.c'\" \(79 characters\)
sed "s/^X//" >'rnews/bugs/zeropad/bugged/zeropad.c' <<'END_OF_FILE'
X/*
X * zero-padding printf format(s) (broken)
X */
X
Xchar ldzeropad[] = "%*.*ld";
END_OF_FILE
if test 79 -ne `wc -c <'rnews/bugs/zeropad/bugged/zeropad.c'`; then
    echo shar: \"'rnews/bugs/zeropad/bugged/zeropad.c'\" unpacked with wrong size!
fi
# end of 'rnews/bugs/zeropad/bugged/zeropad.c'
fi
if test -f 'rnews/bugs/zeropad/okay/zeropad.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/bugs/zeropad/okay/zeropad.c'\"
else
echo shar: Extracting \"'rnews/bugs/zeropad/okay/zeropad.c'\" \(84 characters\)
sed "s/^X//" >'rnews/bugs/zeropad/okay/zeropad.c' <<'END_OF_FILE'
X/*
X * zero-padding printf format(s) (non-broken)
X */
X
Xchar ldzeropad[] = "%0*.*ld";
END_OF_FILE
if test 84 -ne `wc -c <'rnews/bugs/zeropad/okay/zeropad.c'`; then
    echo shar: \"'rnews/bugs/zeropad/okay/zeropad.c'\" unpacked with wrong size!
fi
# end of 'rnews/bugs/zeropad/okay/zeropad.c'
fi
if test -f 'rnews/caches.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/caches.c'\"
else
echo shar: Extracting \"'rnews/caches.c'\" \(246 characters\)
sed "s/^X//" >'rnews/caches.c' <<'END_OF_FILE'
X/*
X * cache control
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include "news.h"
X
Xint
Xloadcaches()				/* reload in-core caches from disk */
X{
X	return artload();
X}
X
Xint
Xsynccaches()				/* force in-core caches to disk */
X{
X	return artsync();
X}
END_OF_FILE
if test 246 -ne `wc -c <'rnews/caches.c'`; then
    echo shar: \"'rnews/caches.c'\" unpacked with wrong size!
fi
# end of 'rnews/caches.c'
fi
if test -f 'rnews/cpu.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/cpu.h'\"
else
echo shar: Extracting \"'rnews/cpu.h'\" \(108 characters\)
sed "s/^X//" >'rnews/cpu.h' <<'END_OF_FILE'
X/*
X * CPU-specific definitions
X */
X
X#ifndef MAXLONG
X#define MAXLONG ((long)(~(unsigned long)0 >> 1))
X#endif
END_OF_FILE
if test 108 -ne `wc -c <'rnews/cpu.h'`; then
    echo shar: \"'rnews/cpu.h'\" unpacked with wrong size!
fi
# end of 'rnews/cpu.h'
fi
if test -f 'rnews/distr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/distr'\"
else
echo shar: Extracting \"'rnews/distr'\" \(0 characters\)
sed "s/^X//" >'rnews/distr' <<'END_OF_FILE'
END_OF_FILE
if test 0 -ne `wc -c <'rnews/distr'`; then
    echo shar: \"'rnews/distr'\" unpacked with wrong size!
fi
# end of 'rnews/distr'
fi
if test -f 'rnews/history.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/history.h'\"
else
echo shar: Extracting \"'rnews/history.h'\" \(68 characters\)
sed "s/^X//" >'rnews/history.h' <<'END_OF_FILE'
X/* imports from history */
Xextern char *findfiles(), *gethistory();
END_OF_FILE
if test 68 -ne `wc -c <'rnews/history.h'`; then
    echo shar: \"'rnews/history.h'\" unpacked with wrong size!
fi
# end of 'rnews/history.h'
fi
if test -f 'rnews/msgs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/msgs.c'\"
else
echo shar: Extracting \"'rnews/msgs.c'\" \(301 characters\)
sed "s/^X//" >'rnews/msgs.c' <<'END_OF_FILE'
X/*
X * print common messages
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include "news.h"
X
Xint
Xfulldisk(status, file)		/* complain once & set ST_DISKFULL */
Xint status;
Xchar *file;
X{
X	if (!(status&ST_DISKFULL))
X		(void) warning("disk filled when writing %s", file);
X	return status | ST_DISKFULL;
X}
END_OF_FILE
if test 301 -ne `wc -c <'rnews/msgs.c'`; then
    echo shar: \"'rnews/msgs.c'\" unpacked with wrong size!
fi
# end of 'rnews/msgs.c'
fi
echo shar: End of archive 1 \(of 14\).
##  End of shell archive.
exit 0
