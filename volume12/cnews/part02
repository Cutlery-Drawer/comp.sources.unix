Subject:  v12i027:  C News alpha release, Part02/14
Newsgroups: comp.sources.unix
Sender: sources
Approved: rs@uunet.UU.NET

Submitted-by: utzoo!henry (Henry Spencer)
Posting-number: Volume 12, Issue 27
Archive-name: cnews/part02



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 14)."
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'expire/olddate.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'expire/olddate.c'\"
else
echo shar: Extracting \"'expire/olddate.c'\" \(458 characters\)
sed "s/^X//" >'expire/olddate.c' <<'END_OF_FILE'
X/*
X * olddate - generate spurious dates for checking news expiry
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X
X#define	DAY	(24L*60L*60L)
X
Xextern time_t time();
Xextern double atof();
X
Xchar *progname;
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	int c;
X	int errflg = 0;
X
X	progname = argv[0];
X
X	if (argc != 2) {
X		fprintf(stderr, "Usage: %s days\n", progname);
X		exit(2);
X	}
X
X	printf("%ld\n", (time_t)(time((time_t *)NULL) - atof(argv[1])*DAY));
X
X	exit(0);
X}
END_OF_FILE
if test 458 -ne `wc -c <'expire/olddate.c'`; then
    echo shar: \"'expire/olddate.c'\" unpacked with wrong size!
fi
# end of 'expire/olddate.c'
fi
if test -f 'expire/oldfile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'expire/oldfile.c'\"
else
echo shar: Extracting \"'expire/oldfile.c'\" \(707 characters\)
sed "s/^X//" >'expire/oldfile.c' <<'END_OF_FILE'
X/*
X * makeold - make an old file, copying from stdin
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X
X#define	DAY	(24L*60L*60L)
X
Xextern time_t time();
Xextern double atof();
X
Xchar buf[BUFSIZ];
X
Xchar *progname;
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	int c;
X	int errflg = 0;
X	int n;
X	int d;
X	time_t t[2];
X
X	progname = argv[0];
X
X	if (argc != 3) {
X		fprintf(stderr, "Usage: %s days filename\n", progname);
X		exit(2);
X	}
X
X	d = creat(argv[2], 0666);
X	if (d < 0)
X		error("can't create `%s'", argv[2]);
X
X	while ((n = read(0, buf, sizeof(buf))) > 0)
X		(void) write(d, buf, n);
X
X	(void) close(d);
X
X	t[0] = (time_t)(time((time_t *)NULL) - atof(argv[1])*DAY);
X	t[1] = t[0];
X
X	(void) utime(argv[2], t);
X
X	exit(0);
X}
END_OF_FILE
if test 707 -ne `wc -c <'expire/oldfile.c'`; then
    echo shar: \"'expire/oldfile.c'\" unpacked with wrong size!
fi
# end of 'expire/oldfile.c'
fi
if test -f 'include/newspaths.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/newspaths.h'\"
else
echo shar: Extracting \"'include/newspaths.h'\" \(546 characters\)
sed "s/^X//" >'include/newspaths.h' <<'END_OF_FILE'
X/*
X * news pathname functions
X */
X
Xextern char *artfile();		/* article pathname, may be relative */
Xextern char *spoolfile();	/* obsolete synonym for artfile() */
Xextern char *fullartfile();	/* article full pathname */
Xextern char *fullspoolfile();	/* obsolete synonym */
Xextern char *ctlfile();		/* control-file name */
Xextern char *libfile();		/* obsolete synonym */
Xextern char *binfile();		/* program pathname */
X
Xextern void cd();		/* chdir() with errunlock() on failure */
X
Xextern void unprivileged();	/* user-supplied privilege dropper */
END_OF_FILE
if test 546 -ne `wc -c <'include/newspaths.h'`; then
    echo shar: \"'include/newspaths.h'\" unpacked with wrong size!
fi
# end of 'include/newspaths.h'
fi
if test -f 'input/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'input/README'\"
else
echo shar: Extracting \"'input/README'\" \(472 characters\)
sed "s/^X//" >'input/README' <<'END_OF_FILE'
XThis is the input processing, which starts at rnews (aka cunbatch).  It
Xinvokes newsspool, which actually puts the stuff where it belongs (peeling
Xoff the silly and unnecessary "#! cunbatch" header, if any, as it goes).
X
XNewsrun should be run regularly; it unspools the stuff and feeds it into
Xthe relay subsystem for processing.  Newsrunning can be used to turn this
Xfunction on and off if you want to avoid news processing during busy hours.
X
XNo manual page yet, sorry.
END_OF_FILE
if test 472 -ne `wc -c <'input/README'`; then
    echo shar: \"'input/README'\" unpacked with wrong size!
fi
# end of 'input/README'
fi
if test -f 'input/newsrunning' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'input/newsrunning'\"
else
echo shar: Extracting \"'input/newsrunning'\" \(405 characters\)
sed "s/^X//" >'input/newsrunning' <<'END_OF_FILE'
X#! /bin/sh
X# newsrunning - turn news processing on and off
X
XNEWSCTL=${NEWSCTL-/usr/lib/news}
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}
XNEWSARTS=${NEWSARTS-/usr/spool/news}
XPATH=$NEWSBIN/input:/bin:/usr/bin ; export PATH
XNEWSUMASK=${NEWSUMASK-002}
Xumask NEWSUMASK
X
Xcase "$1"
Xin
X	on)
X	rm -f $NEWSCTL/incoming/stop
X	;;
X
X	off)
X	>$NEWSCTL/incoming/stop
X	;;
X
X	*)
X	echo "Usage: $0 on/off" >&2
X	exit 2
X	;;
Xesac
X
Xexit 0
END_OF_FILE
if test 405 -ne `wc -c <'input/newsrunning'`; then
    echo shar: \"'input/newsrunning'\" unpacked with wrong size!
fi
# end of 'input/newsrunning'
fi
if test -f 'lib.proto/control/sendsys' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/control/sendsys'\"
else
echo shar: Extracting \"'lib.proto/control/sendsys'\" \(474 characters\)
sed "s/^X//" >'lib.proto/control/sendsys' <<'END_OF_FILE'
X#! /bin/sh
X# sendsys - mail sys file to sender identified in stdin's headers
XNEWSCTL=${NEWSCTL-/usr/lib/news}; export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}; export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}; export NEWSARTS
XPATH=$NEWSCTL:$NEWSBIN:/bin:/usr/bin; export PATH
XNEWSADMIN=usenet
X
XSENDER="`newsreply`"
X(echo "Subject: response to your sendsys"; echo ""; cat $NEWSCTL/sys) |
X	mail "$SENDER"
Xecho "news/sys file has been sent to $SENDER." | mail $NEWSADMIN
END_OF_FILE
if test 474 -ne `wc -c <'lib.proto/control/sendsys'`; then
    echo shar: \"'lib.proto/control/sendsys'\" unpacked with wrong size!
fi
# end of 'lib.proto/control/sendsys'
fi
if test -f 'lib.proto/control/senduuname' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/control/senduuname'\"
else
echo shar: Extracting \"'lib.proto/control/senduuname'\" \(459 characters\)
sed "s/^X//" >'lib.proto/control/senduuname' <<'END_OF_FILE'
X#! /bin/sh
X# senduuname - mail `uuname` to sender identified in stdin's headers
XNEWSCTL=${NEWSCTL-/usr/lib/news}; export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}; export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}; export NEWSARTS
XPATH=$NEWSCTL:$NEWSBIN:/bin:/usr/bin; export PATH
XNEWSADMIN=usenet
X
XSENDER="`newsreply`"
X(echo "Subject: response to your senduuname"; echo ""; uuname) | mail "$SENDER"
Xecho "uuname output sent to $SENDER" | mail $NEWSADMIN
END_OF_FILE
if test 459 -ne `wc -c <'lib.proto/control/senduuname'`; then
    echo shar: \"'lib.proto/control/senduuname'\" unpacked with wrong size!
fi
# end of 'lib.proto/control/senduuname'
fi
if test -f 'lib.proto/control/version' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/control/version'\"
else
echo shar: Extracting \"'lib.proto/control/version'\" \(356 characters\)
sed "s/^X//" >'lib.proto/control/version' <<'END_OF_FILE'
X#! /bin/sh
X# version - mail version id to sender identified in stdin's headers
XNEWSCTL=${NEWSCTL-/usr/lib/news}; export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}; export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}; export NEWSARTS
XPATH=$NEWSCTL:$NEWSBIN:/bin:/usr/bin; export PATH
X
XSENDER="`newsreply`"
Xecho "C, Official Alpha Release" | mail "$SENDER"
END_OF_FILE
if test 356 -ne `wc -c <'lib.proto/control/version'`; then
    echo shar: \"'lib.proto/control/version'\" unpacked with wrong size!
fi
# end of 'lib.proto/control/version'
fi
if test -f 'lib.proto/explist' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.proto/explist'\"
else
echo shar: Extracting \"'lib.proto/explist'\" \(450 characters\)
sed "s/^X//" >'lib.proto/explist' <<'END_OF_FILE'
Xutstat						x	7000	/usr/spool/oldnews
Xnews.lists					x	37	-
Xcomp.mail.maps					x	22-22-22	-
Xall.all.mac					x	0.5-0.5	-
Xall.all.pc,all.all.ibm,comp.protocols.kermit	x	2-2	-
Xcomp.lang.c					x	0.5-0.5	-
Xjunk						x	0.5-0.5	-
Xcontrol						x	0.5-0.5	-
Xto						x	2	-
Xrec,soc,talk,list.humanist			x	0-0	-
Xcomp.mail.elm					x	0-0	-
Xmisc						x	4-4	-
Xsci						x	5-5	-
Xtor.news.stats					x	2-2	-
Xcan,ont,tor,ut					x	5-5	-
Xall						m	3-7-7	-
Xall						u	6-6	-
END_OF_FILE
if test 450 -ne `wc -c <'lib.proto/explist'`; then
    echo shar: \"'lib.proto/explist'\" unpacked with wrong size!
fi
# end of 'lib.proto/explist'
fi
if test -f 'libc/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/Makefile'\"
else
echo shar: Extracting \"'libc/Makefile'\" \(511 characters\)
sed "s/^X//" >'libc/Makefile' <<'END_OF_FILE'
X# c news local libc makefile - added by Ian Darwin
X
XINCLUDE = ../include
X
X# delete from SRCS the ones that are already in your C library or -llocal
XALLSRCS = closeall.c efopen.c emalloc.c error.c fgetmfs.c getopt.c \
X	memlist.c standard.c warning.c
XSRCS = closeall.c emalloc.c fgetmfs.c memlist.c standard.c putenv.c stdfdopen.c
X
X# RANLIB is ranlib on non-USG systems, echo on USG systems
XRANLIB=ranlib
XRANLIB=echo
X
XCFLAGS = -I$(INCLUDE)
X
Xlibc.a:	$(SRCS)
X	cc $(CFLAGS) -c $?
X	ar ru $@ *.o
X	rm *.o
X	$(RANLIB) $@
END_OF_FILE
if test 511 -ne `wc -c <'libc/Makefile'`; then
    echo shar: \"'libc/Makefile'\" unpacked with wrong size!
fi
# end of 'libc/Makefile'
fi
if test -f 'libc/closeall.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/closeall.3'\"
else
echo shar: Extracting \"'libc/closeall.3'\" \(484 characters\)
sed "s/^X//" >'libc/closeall.3' <<'END_OF_FILE'
X.TH CLOSEALL 3 local
X.DA 9 Feb 1982
X.SH NAME
Xcloseall \- close all files
X.SH SYNOPSIS
X.ft B
Xcloseall(leavestd)
X.br
Xint leavestd;
X.ft R
X.SH DESCRIPTION
X.I Closeall
Xcloses all currently-open file descriptors.
XIf
X.I leavestd
Xis non-zero,
Xthe standard input, output, and diagnostic descriptors are left open;
Xotherwise they are closed too.
X.SH SEE ALSO
Xclose(2), standard(3)
X.SH HISTORY
XLocal invention.
X.SH BUGS
XNothing wrong with
X.IR closeall ,
Xbut there ought to be an
X.IR fcloseall .
END_OF_FILE
if test 484 -ne `wc -c <'libc/closeall.3'`; then
    echo shar: \"'libc/closeall.3'\" unpacked with wrong size!
fi
# end of 'libc/closeall.3'
fi
if test -f 'libc/efopen.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/efopen.3'\"
else
echo shar: Extracting \"'libc/efopen.3'\" \(529 characters\)
sed "s/^X//" >'libc/efopen.3' <<'END_OF_FILE'
X.TH EFOPEN 3 local
X.DA 24 April 1984
X.SH NAME
Xefopen \- open a stream, checking for errors
X.SH SYNOPSIS
X.nf
X.B FILE *
X.B efopen(file, mode)
X.B char *file;
X.B char *mode;
X.SH DESCRIPTION
X.I Efopen
Xinvokes
X.IR fopen (3)
Xand checks the result for errors.
XIn the absence of errors, it returns the stream pointer;
Xin the presence of errors, it prints a message and exits.
X.SH SEE ALSO
Xfopen(3), error(3)
X.SH DIAGNOSTICS
XExit status, in the event of error, is 1.
X.SH HISTORY
XLocal product, roughly following the one in Kernighan&Pike.
END_OF_FILE
if test 529 -ne `wc -c <'libc/efopen.3'`; then
    echo shar: \"'libc/efopen.3'\" unpacked with wrong size!
fi
# end of 'libc/efopen.3'
fi
if test -f 'libc/efopen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/efopen.c'\"
else
echo shar: Extracting \"'libc/efopen.c'\" \(477 characters\)
sed "s/^X//" >'libc/efopen.c' <<'END_OF_FILE'
X/*
X * efopen - fopen file, exit with message if impossible
X */
X
X#include <stdio.h>
X
Xstatic char message[] = "can't open file \"%s\" mode ";
X
XFILE *
Xefopen(file, mode)
Xchar *file;
Xchar *mode;
X{
X	FILE *fp;
X	char fullmsg[sizeof(message)+10];
X	extern int errno;
X
X	errno = 0;		/* Wipe out residue of earlier errors. */
X	fp = fopen(file, mode);
X	if (fp == NULL) {
X		strcpy(fullmsg, message);
X		strncat(fullmsg, mode, 10);
X		error(fullmsg, file);
X		/* NOTREACHED */
X	}
X	return(fp);
X}
END_OF_FILE
if test 477 -ne `wc -c <'libc/efopen.c'`; then
    echo shar: \"'libc/efopen.c'\" unpacked with wrong size!
fi
# end of 'libc/efopen.c'
fi
if test -f 'libc/memcpy.fast/src/duff.byte.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/memcpy.fast/src/duff.byte.c'\"
else
echo shar: Extracting \"'libc/memcpy.fast/src/duff.byte.c'\" \(624 characters\)
sed "s/^X//" >'libc/memcpy.fast/src/duff.byte.c' <<'END_OF_FILE'
Xmemcpy(to, from, count)		/* no alignment assumptions */
Xregister char *from, *to;
Xregister int count;
X{
X	/*
X	 * This code uses Duff's Device (tm Tom Duff)
X	 * to unroll the copying loop:
X	 * while (count-- > 0)
X	 *	*to++ = *from++;
X	 * Sorry the code is so ugly.
X	 */
X	if (count > 0) {
X		register int loops = (count+8-1) >> 3;	/* /8 round up */
X
X		switch (count&(8-1)) {	/* %8 */
X		case 0: do {
X#define COPYBYTE *to++ = *from++
X				COPYBYTE;
X			case 7:	COPYBYTE;
X			case 6:	COPYBYTE;
X			case 5:	COPYBYTE;
X			case 4:	COPYBYTE;
X			case 3:	COPYBYTE;
X			case 2:	COPYBYTE;
X			case 1:	COPYBYTE;
X			} while (--loops > 0);
X		}
X	}
X}
END_OF_FILE
if test 624 -ne `wc -c <'libc/memcpy.fast/src/duff.byte.c'`; then
    echo shar: \"'libc/memcpy.fast/src/duff.byte.c'\" unpacked with wrong size!
fi
# end of 'libc/memcpy.fast/src/duff.byte.c'
fi
if test -f 'libc/memcpy.fast/src/memcpy.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/memcpy.fast/src/memcpy.c'\"
else
echo shar: Extracting \"'libc/memcpy.fast/src/memcpy.c'\" \(357 characters\)
sed "s/^X//" >'libc/memcpy.fast/src/memcpy.c' <<'END_OF_FILE'
X#ifndef BYTES
X#define BYTES 10*1024
X#endif
X#ifndef LOOPS
X#define LOOPS 1000
X#endif
X#ifndef FROMALIGN
X#define FROMALIGN 0
X#endif
X#ifndef TOALIGN
X#define TOALIGN 0
X#endif
X
Xmain()		/* time memcpy(3) */
X{
X	register int count = LOOPS;
X	static char from[BYTES], to[BYTES];
X
X	while (count-- > 0)
X		memcpy(to, from, sizeof from - FROMALIGN - TOALIGN);
X	return 0;
X}
END_OF_FILE
if test 357 -ne `wc -c <'libc/memcpy.fast/src/memcpy.c'`; then
    echo shar: \"'libc/memcpy.fast/src/memcpy.c'\" unpacked with wrong size!
fi
# end of 'libc/memcpy.fast/src/memcpy.c'
fi
if test -f 'libc/memcpy.fast/times' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/memcpy.fast/times'\"
else
echo shar: Extracting \"'libc/memcpy.fast/times'\" \(535 characters\)
sed "s/^X//" >'libc/memcpy.fast/times' <<'END_OF_FILE'
XScript started on Sat Feb  8 07:50:49 1986
Xcs% time bcopy.vax
X       12.1 real         6.5 user         0.7 sys  
Xcs% time bcopy.obvious
X       85.5 real        75.0 user         2.4 sys  
Xtimecs%  bcopy.duff
X       28.9 real        27.3 user         1.1 sys  
Xcs% time bcopy.duff.long
X       16.8 real        13.9 user         0.8 sys  
Xcs% time bcopy.duff.double
X       15.6 real        14.5 user         0.7 sys  
Xcs% time bcopy.duff.longs
X        9.4 real         8.2 user         0.6 sys  
Xscript done on Sat Feb  8 09:00:42 1986
END_OF_FILE
if test 535 -ne `wc -c <'libc/memcpy.fast/times'`; then
    echo shar: \"'libc/memcpy.fast/times'\" unpacked with wrong size!
fi
# end of 'libc/memcpy.fast/times'
fi
if test -f 'libc/stdfdopen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/stdfdopen.c'\"
else
echo shar: Extracting \"'libc/stdfdopen.c'\" \(631 characters\)
sed "s/^X//" >'libc/stdfdopen.c' <<'END_OF_FILE'
X/*
X * stdfdopen - ensure that the standard i/o descriptors are open,
X *	to avoid mayhem.
X */
X
X#include <stdio.h>
X#include <errno.h>
X#include <sys/types.h>
X
Xstdfdopen()			/* ensure standard descriptors are open */
X{
X	register int fd;
X
X	for (fd = 0; fd < 3; fd++) {		/* 3 is NSYSFILE on V8 */
X		register int newfd;
X		extern int errno;
X
X		/* TODO: use fstat instead? */
X		newfd = dup(fd);		/* just to check whether it's open */
X		if (newfd < 0 && errno == EBADF)	/* fd is closed */
X			if (open("/dev/null", 2) != fd)	/* open read/write */
X				exit(1);	/* bad news */
X		if (newfd >= 0)			/* fd was open */
X			(void) close(newfd);
X	}
X}
END_OF_FILE
if test 631 -ne `wc -c <'libc/stdfdopen.c'`; then
    echo shar: \"'libc/stdfdopen.c'\" unpacked with wrong size!
fi
# end of 'libc/stdfdopen.c'
fi
if test -f 'libc/strings/memccpy.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/memccpy.c'\"
else
echo shar: Extracting \"'libc/strings/memccpy.c'\" \(656 characters\)
sed "s/^X//" >'libc/strings/memccpy.c' <<'END_OF_FILE'
X/*
X * memccpy - copy bytes up to a certain char
X *
X * CHARBITS should be defined only if the compiler lacks "unsigned char".
X * It should be a mask, e.g. 0377 for an 8-bit machine.
X */
X
X#define	NULL	0
X
X#ifndef CHARBITS
X#	define	UNSCHAR(c)	((unsigned char)(c))
X#else
X#	define	UNSCHAR(c)	((c)&CHARBITS)
X#endif
X
XVOIDSTAR
Xmemccpy(dst, src, ucharstop, size)
XVOIDSTAR dst;
XCONST VOIDSTAR src;
XSIZET size;
X{
X	register char *d;
X	register CONST char *s;
X	register SIZET n;
X	register int uc;
X
X	if (size <= 0)
X		return(NULL);
X
X	s = src;
X	d = dst;
X	uc = UNSCHAR(ucharstop);
X	for (n = size; n > 0; n--)
X		if (UNSCHAR(*d++ = *s++) == uc)
X			return(d);
X
X	return(NULL);
X}
END_OF_FILE
if test 656 -ne `wc -c <'libc/strings/memccpy.c'`; then
    echo shar: \"'libc/strings/memccpy.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/memccpy.c'
fi
if test -f 'libc/strings/memchr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/memchr.c'\"
else
echo shar: Extracting \"'libc/strings/memchr.c'\" \(595 characters\)
sed "s/^X//" >'libc/strings/memchr.c' <<'END_OF_FILE'
X/*
X * memchr - search for a byte
X *
X * CHARBITS should be defined only if the compiler lacks "unsigned char".
X * It should be a mask, e.g. 0377 for an 8-bit machine.
X */
X
X#define	NULL	0
X
X#ifndef CHARBITS
X#	define	UNSCHAR(c)	((unsigned char)(c))
X#else
X#	define	UNSCHAR(c)	((c)&CHARBITS)
X#endif
X
XVOIDSTAR
Xmemchr(s, ucharwanted, size)
XCONST VOIDSTAR s;
Xint ucharwanted;
XSIZET size;
X{
X	register CONST char *scan;
X	register SIZET n;
X	register int uc;
X
X	scan = s;
X	uc = UNSCHAR(ucharwanted);
X	for (n = size; n > 0; n--)
X		if (UNSCHAR(*scan) == uc)
X			return(scan);
X		else
X			scan++;
X
X	return(NULL);
X}
END_OF_FILE
if test 595 -ne `wc -c <'libc/strings/memchr.c'`; then
    echo shar: \"'libc/strings/memchr.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/memchr.c'
fi
if test -f 'libc/strings/memcmp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/memcmp.c'\"
else
echo shar: Extracting \"'libc/strings/memcmp.c'\" \(367 characters\)
sed "s/^X//" >'libc/strings/memcmp.c' <<'END_OF_FILE'
X/*
X * memcmp - compare bytes
X */
X
Xint				/* <0, == 0, >0 */
Xmemcmp(s1, s2, size)
XCONST VOIDSTAR s1;
XCONST VOIDSTAR s2;
XSIZET size;
X{
X	register CONST char *scan1;
X	register CONST char *scan2;
X	register SIZET n;
X
X	scan1 = s1;
X	scan2 = s2;
X	for (n = size; n > 0; n--)
X		if (*scan1 == *scan2) {
X			scan1++;
X			scan2++;
X		} else
X			return(*scan1 - *scan2);
X
X	return(0);
X}
END_OF_FILE
if test 367 -ne `wc -c <'libc/strings/memcmp.c'`; then
    echo shar: \"'libc/strings/memcmp.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/memcmp.c'
fi
if test -f 'libc/strings/memcpy.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/memcpy.c'\"
else
echo shar: Extracting \"'libc/strings/memcpy.c'\" \(450 characters\)
sed "s/^X//" >'libc/strings/memcpy.c' <<'END_OF_FILE'
X/*
X * memcpy - copy bytes
X */
X
XVOIDSTAR
Xmemcpy(dst, src, size)
XVOIDSTAR dst;
XCONST VOIDSTAR src;
XSIZET size;
X{
X	register char *d;
X	register CONST char *s;
X	register SIZET n;
X
X	if (size <= 0)
X		return(dst);
X
X	s = src;
X	d = dst;
X	if (s <= d && s + (size-1) >= d) {
X		/* Overlap, must copy right-to-left. */
X		s += size-1;
X		d += size-1;
X		for (n = size; n > 0; n--)
X			*d-- = *s--;
X	} else
X		for (n = size; n > 0; n--)
X			*d++ = *s++;
X
X	return(dst);
X}
END_OF_FILE
if test 450 -ne `wc -c <'libc/strings/memcpy.c'`; then
    echo shar: \"'libc/strings/memcpy.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/memcpy.c'
fi
if test -f 'libc/strings/memset.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/memset.c'\"
else
echo shar: Extracting \"'libc/strings/memset.c'\" \(524 characters\)
sed "s/^X//" >'libc/strings/memset.c' <<'END_OF_FILE'
X/*
X * memset - set bytes
X *
X * CHARBITS should be defined only if the compiler lacks "unsigned char".
X * It should be a mask, e.g. 0377 for an 8-bit machine.
X */
X
X#ifndef CHARBITS
X#	define	UNSCHAR(c)	((unsigned char)(c))
X#else
X#	define	UNSCHAR(c)	((c)&CHARBITS)
X#endif
X
XVOIDSTAR
Xmemset(s, ucharfill, size)
XCONST VOIDSTAR s;
Xregister int ucharfill;
XSIZET size;
X{
X	register CONST char *scan;
X	register SIZET n;
X	register int uc;
X
X	scan = s;
X	uc = UNSCHAR(ucharfill);
X	for (n = size; n > 0; n--)
X		*scan++ = uc;
X
X	return(s);
X}
END_OF_FILE
if test 524 -ne `wc -c <'libc/strings/memset.c'`; then
    echo shar: \"'libc/strings/memset.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/memset.c'
fi
if test -f 'libc/strings/strchr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/strchr.c'\"
else
echo shar: Extracting \"'libc/strings/strchr.c'\" \(418 characters\)
sed "s/^X//" >'libc/strings/strchr.c' <<'END_OF_FILE'
X/*
X * strchr - find first occurrence of a character in a string
X */
X
X#define	NULL	0
X
Xchar *				/* found char, or NULL if none */
Xstrchr(s, charwanted)
XCONST char *s;
Xregister char charwanted;
X{
X	register CONST char *scan;
X
X	/*
X	 * The odd placement of the two tests is so NUL is findable.
X	 */
X	for (scan = s; *scan != charwanted;)	/* ++ moved down for opt. */
X		if (*scan++ == '\0')
X			return(NULL);
X	return(scan);
X}
END_OF_FILE
if test 418 -ne `wc -c <'libc/strings/strchr.c'`; then
    echo shar: \"'libc/strings/strchr.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/strchr.c'
fi
if test -f 'libc/strings/strcmp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/strcmp.c'\"
else
echo shar: Extracting \"'libc/strings/strcmp.c'\" \(637 characters\)
sed "s/^X//" >'libc/strings/strcmp.c' <<'END_OF_FILE'
X/*
X * strcmp - compare string s1 to s2
X */
X
Xint				/* <0 for <, 0 for ==, >0 for > */
Xstrcmp(s1, s2)
XCONST char *s1;
XCONST char *s2;
X{
X	register CONST char *scan1;
X	register CONST char *scan2;
X
X	scan1 = s1;
X	scan2 = s2;
X	while (*scan1 != '\0' && *scan1 == *scan2) {
X		scan1++;
X		scan2++;
X	}
X
X	/*
X	 * The following case analysis is necessary so that characters
X	 * which look negative collate low against normal characters but
X	 * high against the end-of-string NUL.
X	 */
X	if (*scan1 == '\0' && *scan2 == '\0')
X		return(0);
X	else if (*scan1 == '\0')
X		return(-1);
X	else if (*scan2 == '\0')
X		return(1);
X	else
X		return(*scan1 - *scan2);
X}
END_OF_FILE
if test 637 -ne `wc -c <'libc/strings/strcmp.c'`; then
    echo shar: \"'libc/strings/strcmp.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/strcmp.c'
fi
if test -f 'libc/strings/strcspn.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/strcspn.c'\"
else
echo shar: Extracting \"'libc/strings/strcspn.c'\" \(444 characters\)
sed "s/^X//" >'libc/strings/strcspn.c' <<'END_OF_FILE'
X/*
X * strcspn - find length of initial segment of s consisting entirely
X * of characters not from reject
X */
X
XSIZET
Xstrcspn(s, reject)
XCONST char *s;
XCONST char *reject;
X{
X	register CONST char *scan;
X	register CONST char *rscan;
X	register SIZET count;
X
X	count = 0;
X	for (scan = s; *scan != '\0'; scan++) {
X		for (rscan = reject; *rscan != '\0';)	/* ++ moved down. */
X			if (*scan == *rscan++)
X				return(count);
X		count++;
X	}
X	return(count);
X}
END_OF_FILE
if test 444 -ne `wc -c <'libc/strings/strcspn.c'`; then
    echo shar: \"'libc/strings/strcspn.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/strcspn.c'
fi
if test -f 'libc/strings/strncat.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/strncat.c'\"
else
echo shar: Extracting \"'libc/strings/strncat.c'\" \(404 characters\)
sed "s/^X//" >'libc/strings/strncat.c' <<'END_OF_FILE'
X/*
X * strncat - append at most n characters of string src to dst
X */
Xchar *				/* dst */
Xstrncat(dst, src, n)
Xchar *dst;
XCONST char *src;
XSIZET n;
X{
X	register char *dscan;
X	register CONST char *sscan;
X	register SIZET count;
X
X	for (dscan = dst; *dscan != '\0'; dscan++)
X		continue;
X	sscan = src;
X	count = n;
X	while (*sscan != '\0' && --count >= 0)
X		*dscan++ = *sscan++;
X	*dscan++ = '\0';
X	return(dst);
X}
END_OF_FILE
if test 404 -ne `wc -c <'libc/strings/strncat.c'`; then
    echo shar: \"'libc/strings/strncat.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/strncat.c'
fi
if test -f 'libc/strings/strncpy.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/strncpy.c'\"
else
echo shar: Extracting \"'libc/strings/strncpy.c'\" \(387 characters\)
sed "s/^X//" >'libc/strings/strncpy.c' <<'END_OF_FILE'
X/*
X * strncpy - copy at most n characters of string src to dst
X */
Xchar *				/* dst */
Xstrncpy(dst, src, n)
Xchar *dst;
XCONST char *src;
XSIZET n;
X{
X	register char *dscan;
X	register CONST char *sscan;
X	register SIZET count;
X
X	dscan = dst;
X	sscan = src;
X	count = n;
X	while (--count >= 0 && (*dscan++ = *sscan++) != '\0')
X		continue;
X	while (--count >= 0)
X		*dscan++ = '\0';
X	return(dst);
X}
END_OF_FILE
if test 387 -ne `wc -c <'libc/strings/strncpy.c'`; then
    echo shar: \"'libc/strings/strncpy.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/strncpy.c'
fi
if test -f 'libc/strings/strpbrk.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/strpbrk.c'\"
else
echo shar: Extracting \"'libc/strings/strpbrk.c'\" \(422 characters\)
sed "s/^X//" >'libc/strings/strpbrk.c' <<'END_OF_FILE'
X/*
X * strpbrk - find first occurrence of any char from breakat in s
X */
X
X#define	NULL	0
X
Xchar *				/* found char, or NULL if none */
Xstrpbrk(s, breakat)
XCONST char *s;
XCONST char *breakat;
X{
X	register CONST char *sscan;
X	register CONST char *bscan;
X
X	for (sscan = s; *sscan != '\0'; sscan++) {
X		for (bscan = breakat; *bscan != '\0';)	/* ++ moved down. */
X			if (*sscan == *bscan++)
X				return(sscan);
X	}
X	return(NULL);
X}
END_OF_FILE
if test 422 -ne `wc -c <'libc/strings/strpbrk.c'`; then
    echo shar: \"'libc/strings/strpbrk.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/strpbrk.c'
fi
if test -f 'libc/strings/strrchr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/strrchr.c'\"
else
echo shar: Extracting \"'libc/strings/strrchr.c'\" \(410 characters\)
sed "s/^X//" >'libc/strings/strrchr.c' <<'END_OF_FILE'
X/*
X * strrchr - find last occurrence of a character in a string
X */
X
X#define	NULL	0
X
Xchar *				/* found char, or NULL if none */
Xstrrchr(s, charwanted)
XCONST char *s;
Xregister char charwanted;
X{
X	register CONST char *scan;
X	register CONST char *place;
X
X	place = NULL;
X	for (scan = s; *scan != '\0'; scan++)
X		if (*scan == charwanted)
X			place = scan;
X	if (charwanted == '\0')
X		return(scan);
X	return(place);
X}
END_OF_FILE
if test 410 -ne `wc -c <'libc/strings/strrchr.c'`; then
    echo shar: \"'libc/strings/strrchr.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/strrchr.c'
fi
if test -f 'libc/strings/strspn.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/strspn.c'\"
else
echo shar: Extracting \"'libc/strings/strspn.c'\" \(460 characters\)
sed "s/^X//" >'libc/strings/strspn.c' <<'END_OF_FILE'
X/*
X * strspn - find length of initial segment of s consisting entirely
X * of characters from accept
X */
X
XSIZET
Xstrspn(s, accept)
XCONST char *s;
XCONST char *accept;
X{
X	register CONST char *sscan;
X	register CONST char *ascan;
X	register SIZET count;
X
X	count = 0;
X	for (sscan = s; *sscan != '\0'; sscan++) {
X		for (ascan = accept; *ascan != '\0'; ascan++)
X			if (*sscan == *ascan)
X				break;
X		if (*ascan == '\0')
X			return(count);
X		count++;
X	}
X	return(count);
X}
END_OF_FILE
if test 460 -ne `wc -c <'libc/strings/strspn.c'`; then
    echo shar: \"'libc/strings/strspn.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/strspn.c'
fi
if test -f 'libc/strings/strstr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/strstr.c'\"
else
echo shar: Extracting \"'libc/strings/strstr.c'\" \(635 characters\)
sed "s/^X//" >'libc/strings/strstr.c' <<'END_OF_FILE'
X/*
X * strstr - find first occurrence of wanted in s
X */
X
X#define	NULL	0
X
Xchar *				/* found string, or NULL if none */
Xstrstr(s, wanted)
XCONST char *s;
XCONST char *wanted;
X{
X	register CONST char *scan;
X	register SIZET len;
X	register char firstc;
X	extern int strcmp();
X	extern SIZET strlen();
X
X	/*
X	 * The odd placement of the two tests is so "" is findable.
X	 * Also, we inline the first char for speed.
X	 * The ++ on scan has been moved down for optimization.
X	 */
X	firstc = *wanted;
X	len = strlen(wanted);
X	for (scan = s; *scan != firstc || strncmp(scan, wanted, len) != 0; )
X		if (*scan++ == '\0')
X			return(NULL);
X	return(scan);
X}
END_OF_FILE
if test 635 -ne `wc -c <'libc/strings/strstr.c'`; then
    echo shar: \"'libc/strings/strstr.c'\" unpacked with wrong size!
fi
# end of 'libc/strings/strstr.c'
fi
if test -f 'libc/warning.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/warning.c'\"
else
echo shar: Extracting \"'libc/warning.c'\" \(591 characters\)
sed "s/^X//" >'libc/warning.c' <<'END_OF_FILE'
X/*
X * warning - print best error message possible and clear errno
X */
X
X#include <stdio.h>
X
Xwarning(s1, s2)
Xchar *s1;
Xchar *s2;
X{
X	char *cmdname;
X	extern int errno, sys_nerr;
X	extern char *sys_errlist[];
X	extern char *progname;
X	extern char *getenv();
X
X	cmdname = getenv("CMDNAME");
X	if (cmdname != NULL && *cmdname != '\0')
X		fprintf(stderr, "%s:", cmdname);	/* No space after :. */
X	if (progname != NULL)
X		fprintf(stderr, "%s: ", progname);
X	fprintf(stderr, s1, s2);
X	if (errno > 0 && errno < sys_nerr)
X		fprintf(stderr, " (%s)", sys_errlist[errno]);
X	fprintf(stderr, "\n");
X	errno = 0;
X}
END_OF_FILE
if test 591 -ne `wc -c <'libc/warning.c'`; then
    echo shar: \"'libc/warning.c'\" unpacked with wrong size!
fi
# end of 'libc/warning.c'
fi
if test -f 'libcnews/makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libcnews/makefile'\"
else
echo shar: Extracting \"'libcnews/makefile'\" \(390 characters\)
sed "s/^X//" >'libcnews/makefile' <<'END_OF_FILE'
X# libcnews makefile
X
XCFLAGS= -O -I../include -p # -pg -Dvoid=int -DCHARBITS=0377
XLIB=libcnews.a
X
X$(LIB): readline.c lock.c ngmatch.c path.c strlower.c time.c
X	$(CC) $(CFLAGS) -c $?
X	ar rv $(LIB) *.o
X	rm *.o
X	ranlib $(LIB)
X
X# header dependencies for libcnews.a
Xlock.o: ../include/news.h
Xngmatch.o: ../include/news.h
Xpath.o: ../include/news.h ../include/newspaths.h
Xtime.o: ../include/news.h
END_OF_FILE
if test 390 -ne `wc -c <'libcnews/makefile'`; then
    echo shar: \"'libcnews/makefile'\" unpacked with wrong size!
fi
# end of 'libcnews/makefile'
fi
if test -f 'libcnews/time.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libcnews/time.c'\"
else
echo shar: Extracting \"'libcnews/time.c'\" \(651 characters\)
sed "s/^X//" >'libcnews/time.c' <<'END_OF_FILE'
X/*
X * time utilities
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include "news.h"
X
X/*
X * Write a timestamp of the form "Jun 12 12:34:56" on fp.
X * N.B.: no trailing newline is written.
X */
Xtimestamp(fp, timep, ctmp)
XFILE *fp;
Xtime_t *timep;	/* if non-null, return time() here for later use */
Xchar **ctmp;	/* if non-null, return ctime(&now) here for later use (needed?) */
X{
X	char *prtime;
X	time_t now;
X	char *ctime();
X	time_t time();
X
X	now = time(&now);
X	if (timep != NULL)
X		*timep = now;
X	prtime = ctime(&now);
X	if (ctmp != NULL)
X		*ctmp = prtime;
X	/* .15 excludes yyyy\n\0; + 4 omits day-of-week */
X	(void) fprintf(fp, "%.15s", prtime + 4);
X}
END_OF_FILE
if test 651 -ne `wc -c <'libcnews/time.c'`; then
    echo shar: \"'libcnews/time.c'\" unpacked with wrong size!
fi
# end of 'libcnews/time.c'
fi
if test -f 'newsbin.proto/control/ihave' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsbin.proto/control/ihave'\"
else
echo shar: Extracting \"'newsbin.proto/control/ihave'\" \(348 characters\)
sed "s/^X//" >'newsbin.proto/control/ihave' <<'END_OF_FILE'
X#! /bin/sh
X# ihave - stub for unimplemented I-have/send-me protocol
XNEWSCTL=${NEWSCTL-/usr/lib/news}; export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}; export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}; export NEWSARTS
XPATH=$NEWSCTL:$NEWSBIN:/bin:/usr/bin; export PATH
X
XSENDER="`newsreply`"
Xecho I-have/send-me not implemented | mail "$SENDER"
END_OF_FILE
if test 348 -ne `wc -c <'newsbin.proto/control/ihave'`; then
    echo shar: \"'newsbin.proto/control/ihave'\" unpacked with wrong size!
fi
# end of 'newsbin.proto/control/ihave'
fi
if test -f 'newsbin.proto/control/rmgroup.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsbin.proto/control/rmgroup.man'\"
else
echo shar: Extracting \"'newsbin.proto/control/rmgroup.man'\" \(321 characters\)
sed "s/^X//" >'newsbin.proto/control/rmgroup.man' <<'END_OF_FILE'
X#! /bin/sh
X# rmgroup group - snuff group
XF=/tmp/nc$$
Xadmin=usenet
X
Xcat >$F
XSENDER="`grep '^Sender:' $F | sed 's/^[^:]*: *//'`"
Xcase "$SENDER" in
X"")
X	SENDER="`grep '^From:' $F | sed 's/^[^:]*: *//'`"
X	;;
Xesac
X
X# tell the local usenet administrator to do it by hand
Xecho "rmgroup $1 says $SENDER" | mail $admin
X
Xrm -f $F*
END_OF_FILE
if test 321 -ne `wc -c <'newsbin.proto/control/rmgroup.man'`; then
    echo shar: \"'newsbin.proto/control/rmgroup.man'\" unpacked with wrong size!
fi
# end of 'newsbin.proto/control/rmgroup.man'
fi
if test -f 'newsbin.proto/control/sendme' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsbin.proto/control/sendme'\"
else
echo shar: Extracting \"'newsbin.proto/control/sendme'\" \(348 characters\)
sed "s/^X//" >'newsbin.proto/control/sendme' <<'END_OF_FILE'
X#! /bin/sh
X# ihave - stub for unimplemented I-have/send-me protocol
XNEWSCTL=${NEWSCTL-/usr/lib/news}; export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}; export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}; export NEWSARTS
XPATH=$NEWSCTL:$NEWSBIN:/bin:/usr/bin; export PATH
X
XSENDER="`newsreply`"
Xecho I-have/send-me not implemented | mail "$SENDER"
END_OF_FILE
if test 348 -ne `wc -c <'newsbin.proto/control/sendme'`; then
    echo shar: \"'newsbin.proto/control/sendme'\" unpacked with wrong size!
fi
# end of 'newsbin.proto/control/sendme'
fi
if test -f 'newsbin.proto/control/sendsys' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsbin.proto/control/sendsys'\"
else
echo shar: Extracting \"'newsbin.proto/control/sendsys'\" \(474 characters\)
sed "s/^X//" >'newsbin.proto/control/sendsys' <<'END_OF_FILE'
X#! /bin/sh
X# sendsys - mail sys file to sender identified in stdin's headers
XNEWSCTL=${NEWSCTL-/usr/lib/news}; export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}; export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}; export NEWSARTS
XPATH=$NEWSCTL:$NEWSBIN:/bin:/usr/bin; export PATH
XNEWSADMIN=usenet
X
XSENDER="`newsreply`"
X(echo "Subject: response to your sendsys"; echo ""; cat $NEWSCTL/sys) |
X	mail "$SENDER"
Xecho "news/sys file has been sent to $SENDER." | mail $NEWSADMIN
END_OF_FILE
if test 474 -ne `wc -c <'newsbin.proto/control/sendsys'`; then
    echo shar: \"'newsbin.proto/control/sendsys'\" unpacked with wrong size!
fi
# end of 'newsbin.proto/control/sendsys'
fi
if test -f 'newsbin.proto/control/senduuname' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsbin.proto/control/senduuname'\"
else
echo shar: Extracting \"'newsbin.proto/control/senduuname'\" \(459 characters\)
sed "s/^X//" >'newsbin.proto/control/senduuname' <<'END_OF_FILE'
X#! /bin/sh
X# senduuname - mail `uuname` to sender identified in stdin's headers
XNEWSCTL=${NEWSCTL-/usr/lib/news}; export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}; export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}; export NEWSARTS
XPATH=$NEWSCTL:$NEWSBIN:/bin:/usr/bin; export PATH
XNEWSADMIN=usenet
X
XSENDER="`newsreply`"
X(echo "Subject: response to your senduuname"; echo ""; uuname) | mail "$SENDER"
Xecho "uuname output sent to $SENDER" | mail $NEWSADMIN
END_OF_FILE
if test 459 -ne `wc -c <'newsbin.proto/control/senduuname'`; then
    echo shar: \"'newsbin.proto/control/senduuname'\" unpacked with wrong size!
fi
# end of 'newsbin.proto/control/senduuname'
fi
if test -f 'newsbin.proto/control/version' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsbin.proto/control/version'\"
else
echo shar: Extracting \"'newsbin.proto/control/version'\" \(356 characters\)
sed "s/^X//" >'newsbin.proto/control/version' <<'END_OF_FILE'
X#! /bin/sh
X# version - mail version id to sender identified in stdin's headers
XNEWSCTL=${NEWSCTL-/usr/lib/news}; export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}; export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}; export NEWSARTS
XPATH=$NEWSCTL:$NEWSBIN:/bin:/usr/bin; export PATH
X
XSENDER="`newsreply`"
Xecho "C, Official Alpha Release" | mail "$SENDER"
END_OF_FILE
if test 356 -ne `wc -c <'newsbin.proto/control/version'`; then
    echo shar: \"'newsbin.proto/control/version'\" unpacked with wrong size!
fi
# end of 'newsbin.proto/control/version'
fi
if test -f 'newsbin.proto/newsreply.from' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsbin.proto/newsreply.from'\"
else
echo shar: Extracting \"'newsbin.proto/newsreply.from'\" \(344 characters\)
sed "s/^X//" >'newsbin.proto/newsreply.from' <<'END_OF_FILE'
X#! /bin/sh
X# newsreply - print return address from news article on stdin
X# This version assumes a domain mailer (user@host.domain works)
XF=/tmp/nc$$
X
Xcat >$F
X
XSENDER="`grep '^Reply-To:' $F | sed 's/^[^:]*://
Xs/ (.*)//
X1q' `"
Xcase "$SENDER" in
X"")
X	SENDER="`grep '^From:' $F | sed 's/^[^:]*://
Xs/ (.*)//
X1q' `"
X	;;
Xesac
X
Xecho "$SENDER"
Xrm -f $F
END_OF_FILE
if test 344 -ne `wc -c <'newsbin.proto/newsreply.from'`; then
    echo shar: \"'newsbin.proto/newsreply.from'\" unpacked with wrong size!
fi
# end of 'newsbin.proto/newsreply.from'
fi
if test -f 'newsbin.proto/tear' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsbin.proto/tear'\"
else
echo shar: Extracting \"'newsbin.proto/tear'\" \(416 characters\)
sed "s/^X//" >'newsbin.proto/tear' <<'END_OF_FILE'
X#! /bin/sh
X# tear prefix [file...] - tear RFC822 header and body apart (prefix: /tmp/in$$)
XPATH=/bin:/usr/bin; export PATH
X
Xhdr=${1-/tmp/in0}hdr
Xbody=${1-/tmp/in0}body
Xshift
X>>$hdr					# create files just in case
X>>$body
Xexec awk '
XBEGIN { hdrpat="/^([ \t]|[^ \t]*:)/" }
Xinbody == 0 && $0 ~ /^([ \t]|[^ \t]*:)/ { print $0 >"'$hdr'" }
Xinbody != 0 || $0 !~ /^([ \t]|[^ \t]*:)/ { inbody = 1; print $0 >"'$body'" }
X' $*
END_OF_FILE
if test 416 -ne `wc -c <'newsbin.proto/tear'`; then
    echo shar: \"'newsbin.proto/tear'\" unpacked with wrong size!
fi
# end of 'newsbin.proto/tear'
fi
if test -f 'rna/at.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rna/at.h'\"
else
echo shar: Extracting \"'rna/at.h'\" \(557 characters\)
sed "s/^X//" >'rna/at.h' <<'END_OF_FILE'
X#define SECINWEEK	604800L
X#define SECINDAY	 86400L
X#define SECINHOUR	  3600L
X#define SECINMIN	    60L
X#define	DAYSTO1983	(10*365 + 3*366)
X#define MAXTIME		0x7fffffffL
X
X/*
X * frequencies
X */
X#define HOURLY		1
X#define DAILY		2
X#define WEEKLY		3
X#define MONTHLY		4
X#define BOOT		5
X#define BATCHTIME	6	/* not really a frequency - just looks like one */
X
X/*
X * time types recognised
X */
X#define DAYS		0	/* days only */
X#define TIMES		1	/* days, times */
X#define FULL		2	/* days, times, frequencies */
X#define STIMES		3	/* days, times - be silent about errors */
END_OF_FILE
if test 557 -ne `wc -c <'rna/at.h'`; then
    echo shar: \"'rna/at.h'\" unpacked with wrong size!
fi
# end of 'rna/at.h'
fi
if test -f 'rna/lib/strpbrk.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rna/lib/strpbrk.c'\"
else
echo shar: Extracting \"'rna/lib/strpbrk.c'\" \(376 characters\)
sed "s/^X//" >'rna/lib/strpbrk.c' <<'END_OF_FILE'
X/*
X * Return ptr to first occurance of any character from `brkset'
X * in the character string `string'; NULL if none exists.
X */
X
X#define	NULL	(char *) 0
X
Xchar *
Xstrpbrk(string, brkset)
Xregister char *string, *brkset;
X{
X	register char *p;
X
X	do {
X		for(p=brkset; *p != '\0' && *p != *string; ++p)
X			;
X		if(*p != '\0')
X			return(string);
X	}
X	while(*string++);
X	return(NULL);
X}
END_OF_FILE
if test 376 -ne `wc -c <'rna/lib/strpbrk.c'`; then
    echo shar: \"'rna/lib/strpbrk.c'\" unpacked with wrong size!
fi
# end of 'rna/lib/strpbrk.c'
fi
if test -f 'rna/man/uusend.8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rna/man/uusend.8'\"
else
echo shar: Extracting \"'rna/man/uusend.8'\" \(432 characters\)
sed "s/^X//" >'rna/man/uusend.8' <<'END_OF_FILE'
X.TH UUSEND 8
X.SH NAME
Xuusend \- send news articles via mail
X.SH SYNOPSIS
X.B /usr/lib/news/uusend
Xdestination
X.SH DESCRIPTION
X.I uusend
Xreads an article from standard input,
Xprepends an `N' to each line of the article,
Xand then mails the article to
X.IR destination .
X.P
X.IR uurec (8)
Xis used at the destination host to unpackage the article
Xand pass it to
X.IR postnews (1).
X.SH SEE ALSO
Xpostnews(1), readnews(1),
Xuurec(8), smail(8).
END_OF_FILE
if test 432 -ne `wc -c <'rna/man/uusend.8'`; then
    echo shar: \"'rna/man/uusend.8'\" unpacked with wrong size!
fi
# end of 'rna/man/uusend.8'
fi
if test -f 'rna/notes/Cover.pd' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rna/notes/Cover.pd'\"
else
echo shar: Extracting \"'rna/notes/Cover.pd'\" \(643 characters\)
sed "s/^X//" >'rna/notes/Cover.pd' <<'END_OF_FILE'
XFrom decvax!mulga!michaelr:elecvax Mon Jul 16 04:25:19 1984
XFrom: decvax!mulga!michaelr:elecvax
XReceived: by decvax.UUCP (4.12/1.0)
X	id AA25742; Mon, 16 Jul 84 03:56:35 edt
XReceived: by mulga.OZ (4.3)
X	id AA06943; Mon, 16 Jul 84 14:19:46 EST
XTo: decvax!utcsstat!geoff:mulga
XSubject: Re: your news re-write
X
XYes, my news re-write is in the public domain.
XI couldn't sell it if I wanted to, since it was developed under an
Xeducational license.
X
XPlease distribute it freely as you wish.
X
XMichael Rourke
XUniversity of New South Wales, Kensington, N.S.W. 2033 AUSTRALIA
XPhone:	+61 2 662 2781	Netaddr: {decvax,vax135,sfjec}!mulga!michaelr:elecvax
X
X
END_OF_FILE
if test 643 -ne `wc -c <'rna/notes/Cover.pd'`; then
    echo shar: \"'rna/notes/Cover.pd'\" unpacked with wrong size!
fi
# end of 'rna/notes/Cover.pd'
fi
if test -f 'rna/uusend.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rna/uusend.c'\"
else
echo shar: Extracting \"'rna/uusend.c'\" \(749 characters\)
sed "s/^X//" >'rna/uusend.c' <<'END_OF_FILE'
X/*
X * send article on standard input to remote host via mail
X */
X
X#include "defs.h"
X
Xchar mail[]		 = FASTMAIL;
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	register int c, lastc;
X	register FILE	*out;
X
X	if (argc != 2) {
X		fprintf(stderr, "Usage: uusend address\n");
X		exit(1);
X	}
X	if ((out = tmpfile()) == NULL) {
X		fprintf(stderr, "uusend: can't create tempfile\n");
X		exit(1);
X	}
X
X	fprintf(out, "Subject: network news article\n");
X	fprintf(out, "\n");
X
X	lastc = '\n';
X	while ((c = getc(stdin)) != EOF) {
X		if (lastc == '\n')
X			putc('N', out);
X		putc(lastc = c, out);
X	}
X
X	rewind(out);
X	fclose(stdin);
X	dup(fileno(out));
X	close(fileno(out));
X
X	execl(mail, strrchr(mail, '/') + 1, argv[1], 0);
X	fprintf(stderr, "uusend: can't exec %s\n", mail);
X}
X
X
END_OF_FILE
if test 749 -ne `wc -c <'rna/uusend.c'`; then
    echo shar: \"'rna/uusend.c'\" unpacked with wrong size!
fi
# end of 'rna/uusend.c'
fi
if test -f 'rnews/TODO' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/TODO'\"
else
echo shar: Extracting \"'rnews/TODO'\" \(576 characters\)
sed "s/^X//" >'rnews/TODO' <<'END_OF_FILE'
Xprevent cross-posting across universes: on receipt,
X	use first universe in $NEWSCTL/universes only
Xmodify Path: on reading instead of on writing (in headers.c)?
Xavoid array overruns: use malloc for string storage
X
Xremove embarrassing comments
Xmore packaging effort a la Horton
X
Xtest long headers: >512 bytes, >1024 bytes
Xtest and read all code (including sh scripts) before release
X
XD news idea:
X	read batch into memory (assumes VM); compose whole article in memory,
X	write it all at once, using the right name for the first group.
X	insist on reading from disk? probably not.
END_OF_FILE
if test 576 -ne `wc -c <'rnews/TODO'`; then
    echo shar: \"'rnews/TODO'\" unpacked with wrong size!
fi
# end of 'rnews/TODO'
fi
if test -f 'rnews/checkdir.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/checkdir.c'\"
else
echo shar: Extracting \"'rnews/checkdir.c'\" \(562 characters\)
sed "s/^X//" >'rnews/checkdir.c' <<'END_OF_FILE'
X/*
X * checkdir - make the directories implied by `name'
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include "news.h"
X
Xint
Xcheckdir(name, uid, gid)
Xregister char *name;
X{
X	register char *cp;
X
X	for (cp = name; *cp != '\0'; cp++)
X		if (*cp == '/') {
X			*cp = '\0';
X			if (access(name, 01) < 0) {	/* can't search */
X				char *cbuf = emalloc((unsigned)STRLEN("mkdir ") +
X					strlen(name) + 1);
X
X				(void) sprintf(cbuf, "mkdir %s", name);
X				(void) system(cbuf);
X				free(cbuf);
X				(void) chown(name, uid, gid);
X			}
X			*cp = '/';
X		}
X	return cp[-1] == '/';
X}
END_OF_FILE
if test 562 -ne `wc -c <'rnews/checkdir.c'`; then
    echo shar: \"'rnews/checkdir.c'\" unpacked with wrong size!
fi
# end of 'rnews/checkdir.c'
fi
if test -f 'rnews/io.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/io.c'\"
else
echo shar: Extracting \"'rnews/io.c'\" \(491 characters\)
sed "s/^X//" >'rnews/io.c' <<'END_OF_FILE'
X/*
X * common i/o operations
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include "news.h"
X
XFILE *
Xfopenwclex(name, mode)	/* open name; close-on-exec if OK, else warning */
Xchar *name, *mode;
X{
X	register FILE *fp;
X
X	if ((fp = fopenclex(name, mode)) == NULL)
X		warning("can't open %s", name);
X	return fp;
X}
X
XFILE *
Xfopenclex(file, mode)		/* open file and if OK, close-on-exec */
Xchar *file, *mode;
X{
X	register FILE *fp;
X
X	if ((fp = fopen(file, mode)) != NULL)
X		fclsexec(fp);
X	return fp;
X}
END_OF_FILE
if test 491 -ne `wc -c <'rnews/io.c'`; then
    echo shar: \"'rnews/io.c'\" unpacked with wrong size!
fi
# end of 'rnews/io.c'
fi
if test -f 'rnews/sh/tear' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/sh/tear'\"
else
echo shar: Extracting \"'rnews/sh/tear'\" \(416 characters\)
sed "s/^X//" >'rnews/sh/tear' <<'END_OF_FILE'
X#! /bin/sh
X# tear prefix [file...] - tear RFC822 header and body apart (prefix: /tmp/in$$)
XPATH=/bin:/usr/bin; export PATH
X
Xhdr=${1-/tmp/in0}hdr
Xbody=${1-/tmp/in0}body
Xshift
X>>$hdr					# create files just in case
X>>$body
Xexec awk '
XBEGIN { hdrpat="/^([ \t]|[^ \t]*:)/" }
Xinbody == 0 && $0 ~ /^([ \t]|[^ \t]*:)/ { print $0 >"'$hdr'" }
Xinbody != 0 || $0 !~ /^([ \t]|[^ \t]*:)/ { inbody = 1; print $0 >"'$body'" }
X' $*
END_OF_FILE
if test 416 -ne `wc -c <'rnews/sh/tear'`; then
    echo shar: \"'rnews/sh/tear'\" unpacked with wrong size!
fi
# end of 'rnews/sh/tear'
fi
if test -f 'rnews/tear' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/tear'\"
else
echo shar: Extracting \"'rnews/tear'\" \(416 characters\)
sed "s/^X//" >'rnews/tear' <<'END_OF_FILE'
X#! /bin/sh
X# tear prefix [file...] - tear RFC822 header and body apart (prefix: /tmp/in$$)
XPATH=/bin:/usr/bin; export PATH
X
Xhdr=${1-/tmp/in0}hdr
Xbody=${1-/tmp/in0}body
Xshift
X>>$hdr					# create files just in case
X>>$body
Xexec awk '
XBEGIN { hdrpat="/^([ \t]|[^ \t]*:)/" }
Xinbody == 0 && $0 ~ /^([ \t]|[^ \t]*:)/ { print $0 >"'$hdr'" }
Xinbody != 0 || $0 !~ /^([ \t]|[^ \t]*:)/ { inbody = 1; print $0 >"'$body'" }
X' $*
END_OF_FILE
if test 416 -ne `wc -c <'rnews/tear'`; then
    echo shar: \"'rnews/tear'\" unpacked with wrong size!
fi
# end of 'rnews/tear'
fi
if test -f 'rnews/test/demo/arts/art1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/test/demo/arts/art1'\"
else
echo shar: Extracting \"'rnews/test/demo/arts/art1'\" \(633 characters\)
sed "s/^X//" >'rnews/test/demo/arts/art1' <<'END_OF_FILE'
XNewsgroups: net.slug,net.wretched,net.general
XPath: rabbit!alice!npoiv!npois!hou5f!hou5b!hou5c!hou5e!hou5a!hou5d!hogpc!houxe!lime!we13!otuxa!ll1!sb1!burl!mhuxv!mhuxi!mhuxj!mhuxt!eagle!harpo!decvax!decwrl!amd70!rocksvax!bimmler
XFrom: bimmler@rocksvax.UuCp
XSubject: Re: Re: RE: re: rE: Orphaned Response
XMessage-ID: <123@drugs.ca>
XDate-Received: the epoch
XRelay-Version: version A; site rti.uucp
XPosting-Version: version A+; site trt.uucp
X
X> *NONE*:*:0:root
X> daemon:*:1:daemon,uucp
X> sys:*:2:bin,sys
X> bin70:*:3:
X> uucp70:*:4:
X> general:*:5:adams,al
X
XI agree!
X-- 
XSluggola Slimebreath, Cretins Unlimited.
X<insert silly graphics here>
END_OF_FILE
if test 633 -ne `wc -c <'rnews/test/demo/arts/art1'`; then
    echo shar: \"'rnews/test/demo/arts/art1'\" unpacked with wrong size!
fi
# end of 'rnews/test/demo/arts/art1'
fi
if test -f 'rnews/test/demo/arts/art4' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/test/demo/arts/art4'\"
else
echo shar: Extracting \"'rnews/test/demo/arts/art4'\" \(554 characters\)
sed "s/^X//" >'rnews/test/demo/arts/art4' <<'END_OF_FILE'
XNewsgroups: alt.bozos,bozos.unix
XPath: uw-muskrat!ucbvax!decvax!decwrl!ucbvax!anode!cathode!bozos
XDate: Tue May  3 21:35:59
XMessage-Id: <8305040716.AA21555@LBL-CLAMS.BARFA>
XVia: BRL-UNIX
XVia: Twi-UNIX@Somehost
XVia: Twenex-20@Elsewhere
XVia: Godknows@Where
XFrom: The UNIX Bozos
XRealaid-by: Twit.UUCP
XNonconformant-to: Any RFC's you've ever read.
XLost-by: MIT-BOZOS
XFound-by: MIT-OZ
XMessage-Id: <8305040716.AA21549@MIT-OZ.BARFA>
XRemailed-to: UW-MUSKRAT@LBL-CLAMS.BARFA
XEventually-for: your eyes only.
XSubject: And now for something completely different...
X
END_OF_FILE
if test 554 -ne `wc -c <'rnews/test/demo/arts/art4'`; then
    echo shar: \"'rnews/test/demo/arts/art4'\" unpacked with wrong size!
fi
# end of 'rnews/test/demo/arts/art4'
fi
if test -f 'rnews/test/demo/arts/art5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/test/demo/arts/art5'\"
else
echo shar: Extracting \"'rnews/test/demo/arts/art5'\" \(463 characters\)
sed "s/^X//" >'rnews/test/demo/arts/art5' <<'END_OF_FILE'
XPath: ucbvax!decvax!decwrl!anode!bnode!cnode!slime
XDate: Wed May  4 12:13:14
XMessage-Id: <8301829293.AA839282@CNODE.UUCP>
XVia: CNODE.UUCP
XVia: BNODE.UUCP
XVia: Anode.Electron
XVia: DecWhirl
XVia: DecHax
XNewsgroups: newt.toad
XSubject: Re: And now for something completely different...
X
XThe greatest thing since Monty Boa! I loved it. Thank you.
XWhen can we expect the next installment???
X
XNot afraid to sign my real name,
XThanks (as they say) in advance,
X
XHandy Solo
END_OF_FILE
if test 463 -ne `wc -c <'rnews/test/demo/arts/art5'`; then
    echo shar: \"'rnews/test/demo/arts/art5'\" unpacked with wrong size!
fi
# end of 'rnews/test/demo/arts/art5'
fi
if test -f 'rnews/test/demo/arts/art6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/test/demo/arts/art6'\"
else
echo shar: Extracting \"'rnews/test/demo/arts/art6'\" \(471 characters\)
sed "s/^X//" >'rnews/test/demo/arts/art6' <<'END_OF_FILE'
XPath: ucbvax!decvax!decwrl!anode!bnode!cnode!demon
XDate: Wed May  4 12:13:14
XMessage-Id: <8301829294.AA839282@CNODE.UUCP>
XVia: CNODE.UUCP
XVia: BNODE.UUCP
XVia: Anode.Photon
XVia: DecWhirl
XVia: DecHax
XApparantly-for: /dev/null
XNewsgroups: newt.toad
XSubject: Re: And now for something completely different...
X
XIt stank. What a waste of my damn long-distance UUCP phone bill.
XThis sort of dreck belongs in the bit bucket, not on a public
Xnetwork like plaNET.
X
XThe Mad Flamer.
END_OF_FILE
if test 471 -ne `wc -c <'rnews/test/demo/arts/art6'`; then
    echo shar: \"'rnews/test/demo/arts/art6'\" unpacked with wrong size!
fi
# end of 'rnews/test/demo/arts/art6'
fi
if test -f 'rnews/test/lib/nukehist' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/test/lib/nukehist'\"
else
echo shar: Extracting \"'rnews/test/lib/nukehist'\" \(427 characters\)
sed "s/^X//" >'rnews/test/lib/nukehist' <<'END_OF_FILE'
X#! /bin/sh
X# nukehist - zero history files, unlock, snuff mon.out's, zero logs
X>history
X>history.pag
X>history.dir
X>log
X>errlog
Xrm -f LOCK mon.out
Xcd ../spool
Xrm -f .tmp* core mon.out gmon.out
Xcd net			# clean out old articles
Xrm -rf unix-wizards; mkdir unix-wizards	# special case for speed
Xrm -rf unix; mkdir unix	# special case for speed
Xrm -rf lan; mkdir lan	# special case for speed
Xrm -f */* */*/*		# remove previous runs
END_OF_FILE
if test 427 -ne `wc -c <'rnews/test/lib/nukehist'`; then
    echo shar: \"'rnews/test/lib/nukehist'\" unpacked with wrong size!
fi
# end of 'rnews/test/lib/nukehist'
fi
if test -f 'rnews/vers/usg/gethostname.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/vers/usg/gethostname.c'\"
else
echo shar: Extracting \"'rnews/vers/usg/gethostname.c'\" \(340 characters\)
sed "s/^X//" >'rnews/vers/usg/gethostname.c' <<'END_OF_FILE'
X/*
X * Uglix gethostname simulation
X */
X
X#include <sys/types.h>
X#include <sys/utsname.h>
X
X#define min(a, b) ((a) < (b)? (a): (b))
X
Xint
Xgethostname(buf, size)
Xchar *buf;
Xint size;
X{
X	struct utsname ugnm;
X	char *strncpy();
X
X	if (uname(&ugnm) < 0)
X		return -1;
X	(void) strncpy(buf, ugnm.nodename, min(sizeof ugnm.nodename, size));
X	return 0;
X}
END_OF_FILE
if test 340 -ne `wc -c <'rnews/vers/usg/gethostname.c'`; then
    echo shar: \"'rnews/vers/usg/gethostname.c'\" unpacked with wrong size!
fi
# end of 'rnews/vers/usg/gethostname.c'
fi
if test -f 'rnews/vers/usg/getwd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/vers/usg/getwd.c'\"
else
echo shar: Extracting \"'rnews/vers/usg/getwd.c'\" \(436 characters\)
sed "s/^X//" >'rnews/vers/usg/getwd.c' <<'END_OF_FILE'
X/*
X * 4.2bsd getwd simulation
X */
X
X#include <stdio.h>
X
X#define MAXWD 1024		/* limited by 4.2 getwd(2) */
X
Xchar *
Xgetwd(path)
Xchar *path;
X{
X	char *nlp;
X	FILE *fp;
X	FILE *popen();
X	char *rindex();
X
X	fp = popen("PATH=/bin:/usr/bin pwd", "r");
X	if (fp == NULL)
X		return 0;
X	if (fgets(path, MAXWD, fp) == NULL) {
X		(void) pclose(fp);
X		return 0;
X	}
X	if ((nlp = rindex(path, '\n')) != NULL)
X		*nlp = '\0';
X	(void) pclose(fp);
X	return path;
X}
END_OF_FILE
if test 436 -ne `wc -c <'rnews/vers/usg/getwd.c'`; then
    echo shar: \"'rnews/vers/usg/getwd.c'\" unpacked with wrong size!
fi
# end of 'rnews/vers/usg/getwd.c'
fi
if test -f 'rnews/vers/usg/mkdir.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/vers/usg/mkdir.c'\"
else
echo shar: Extracting \"'rnews/vers/usg/mkdir.c'\" \(368 characters\)
sed "s/^X//" >'rnews/vers/usg/mkdir.c' <<'END_OF_FILE'
X/*
X * 4.2BSD mkdir simulation
X */
X
X#include <stdio.h>
X
Xint
Xmkdir(dir, mode)
Xchar *dir;
Xint mode;
X{
X	int ret;
X	char cbuf[BUFSIZ];
X	char *sprintf();
X
X	(void) sprintf(cbuf, "mkdir %s", dir);
X	ret = system(cbuf);
X	if (mode != 0777) {	/* needs special attention */
X		int oldmask = umask(0);
X
X		(void) umask(oldmask);
X		(void) chmod(dir, mode & ~oldmask);
X	}
X	return ret;
X}
END_OF_FILE
if test 368 -ne `wc -c <'rnews/vers/usg/mkdir.c'`; then
    echo shar: \"'rnews/vers/usg/mkdir.c'\" unpacked with wrong size!
fi
# end of 'rnews/vers/usg/mkdir.c'
fi
if test -f 'rnews/vers/v7/getwd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/vers/v7/getwd.c'\"
else
echo shar: Extracting \"'rnews/vers/v7/getwd.c'\" \(436 characters\)
sed "s/^X//" >'rnews/vers/v7/getwd.c' <<'END_OF_FILE'
X/*
X * 4.2bsd getwd simulation
X */
X
X#include <stdio.h>
X
X#define MAXWD 1024		/* limited by 4.2 getwd(2) */
X
Xchar *
Xgetwd(path)
Xchar *path;
X{
X	char *nlp;
X	FILE *fp;
X	FILE *popen();
X	char *rindex();
X
X	fp = popen("PATH=/bin:/usr/bin pwd", "r");
X	if (fp == NULL)
X		return 0;
X	if (fgets(path, MAXWD, fp) == NULL) {
X		(void) pclose(fp);
X		return 0;
X	}
X	if ((nlp = rindex(path, '\n')) != NULL)
X		*nlp = '\0';
X	(void) pclose(fp);
X	return path;
X}
END_OF_FILE
if test 436 -ne `wc -c <'rnews/vers/v7/getwd.c'`; then
    echo shar: \"'rnews/vers/v7/getwd.c'\" unpacked with wrong size!
fi
# end of 'rnews/vers/v7/getwd.c'
fi
if test -f 'rnews/vers/v7/mkdir.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/vers/v7/mkdir.c'\"
else
echo shar: Extracting \"'rnews/vers/v7/mkdir.c'\" \(368 characters\)
sed "s/^X//" >'rnews/vers/v7/mkdir.c' <<'END_OF_FILE'
X/*
X * 4.2BSD mkdir simulation
X */
X
X#include <stdio.h>
X
Xint
Xmkdir(dir, mode)
Xchar *dir;
Xint mode;
X{
X	int ret;
X	char cbuf[BUFSIZ];
X	char *sprintf();
X
X	(void) sprintf(cbuf, "mkdir %s", dir);
X	ret = system(cbuf);
X	if (mode != 0777) {	/* needs special attention */
X		int oldmask = umask(0);
X
X		(void) umask(oldmask);
X		(void) chmod(dir, mode & ~oldmask);
X	}
X	return ret;
X}
END_OF_FILE
if test 368 -ne `wc -c <'rnews/vers/v7/mkdir.c'`; then
    echo shar: \"'rnews/vers/v7/mkdir.c'\" unpacked with wrong size!
fi
# end of 'rnews/vers/v7/mkdir.c'
fi
if test -f 'rnews/vers/v8/gethostname.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/vers/v8/gethostname.c'\"
else
echo shar: Extracting \"'rnews/vers/v8/gethostname.c'\" \(340 characters\)
sed "s/^X//" >'rnews/vers/v8/gethostname.c' <<'END_OF_FILE'
X/*
X * Uglix gethostname simulation
X */
X
X#include <sys/types.h>
X#include <sys/utsname.h>
X
X#define min(a, b) ((a) < (b)? (a): (b))
X
Xint
Xgethostname(buf, size)
Xchar *buf;
Xint size;
X{
X	struct utsname ugnm;
X	char *strncpy();
X
X	if (uname(&ugnm) < 0)
X		return -1;
X	(void) strncpy(buf, ugnm.nodename, min(sizeof ugnm.nodename, size));
X	return 0;
X}
END_OF_FILE
if test 340 -ne `wc -c <'rnews/vers/v8/gethostname.c'`; then
    echo shar: \"'rnews/vers/v8/gethostname.c'\" unpacked with wrong size!
fi
# end of 'rnews/vers/v8/gethostname.c'
fi
if test -f 'rnews/vers/v8/mkdir.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/vers/v8/mkdir.c'\"
else
echo shar: Extracting \"'rnews/vers/v8/mkdir.c'\" \(368 characters\)
sed "s/^X//" >'rnews/vers/v8/mkdir.c' <<'END_OF_FILE'
X/*
X * 4.2BSD mkdir simulation
X */
X
X#include <stdio.h>
X
Xint
Xmkdir(dir, mode)
Xchar *dir;
Xint mode;
X{
X	int ret;
X	char cbuf[BUFSIZ];
X	char *sprintf();
X
X	(void) sprintf(cbuf, "mkdir %s", dir);
X	ret = system(cbuf);
X	if (mode != 0777) {	/* needs special attention */
X		int oldmask = umask(0);
X
X		(void) umask(oldmask);
X		(void) chmod(dir, mode & ~oldmask);
X	}
X	return ret;
X}
END_OF_FILE
if test 368 -ne `wc -c <'rnews/vers/v8/mkdir.c'`; then
    echo shar: \"'rnews/vers/v8/mkdir.c'\" unpacked with wrong size!
fi
# end of 'rnews/vers/v8/mkdir.c'
fi
echo shar: End of archive 2 \(of 14\).
##  End of shell archive.
exit 0
