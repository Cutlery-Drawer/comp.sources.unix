Subject:  v12i029:  C News alpha release, Part04/14
Newsgroups: comp.sources.unix
Sender: sources
Approved: rs@uunet.UU.NET

Submitted-by: utzoo!henry (Henry Spencer)
Posting-number: Volume 12, Issue 29
Archive-name: cnews/part04

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 14)."
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'COPYRIGHT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'COPYRIGHT'\"
else
echo shar: Extracting \"'COPYRIGHT'\" \(1355 characters\)
sed "s/^X//" >'COPYRIGHT' <<'END_OF_FILE'
X/*
X * Copyright (c) University of Toronto 1985, 1986, 1987.
X * Written by Geoffrey Collyer and Henry Spencer.
X * This software is not subject to any license of the American Telephone
X * and Telegraph Company or of the Regents of the University of California.
X *
X * Permission is granted to anyone to use this software for any purpose on
X * any computer system, and to alter it and redistribute it freely, subject
X * to the following restrictions:
X *
X * 1. The authors are not responsible for the consequences of use of this
X *    software, no matter how awful, even if they arise from flaws in it.
X *
X * 2. The origin of this software must not be misrepresented, either by
X *    explicit claim or by omission.  Since few users ever read sources,
X *    credits must appear in the documentation.
X *
X * 3. Altered versions must be plainly marked as such, and must not be
X *    misrepresented as being the original software.  Since few users
X *    ever read sources, credits must appear in the documentation.
X *
X * 4. This notice may not be removed or altered.
X *
X * 5. This release may be redistributed only in its original state:  existing
X *    material (e.g. sources) may not be deleted, changes may not be made to
X *    the originals, and new materials must be added as a supplementary
X *    distribution rather than interspersed with the originals.
X */
END_OF_FILE
if test 1355 -ne `wc -c <'COPYRIGHT'`; then
    echo shar: \"'COPYRIGHT'\" unpacked with wrong size!
fi
# end of 'COPYRIGHT'
fi
if test -f 'batch/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'batch/Makefile'\"
else
echo shar: Extracting \"'batch/Makefile'\" \(1567 characters\)
sed "s/^X//" >'batch/Makefile' <<'END_OF_FILE'
X# Configuration stuff.
XCFLAGS=-O
XLDFLAGS=-n
XNEWSCTL=/usr/lib/news
XNEWSARTS=/usr/spool/news
XNEWSBIN=/usr/lib/newsbin
X
X# File lists.
XPGMS=batchmake batchmunch batchprep batchsize batchxmit queuelen queuemax \
X	roomfor sendbatches
XALL=README dMakefile batchmake.c batchmunch batchprep batchsize batchxmit \
X	newsbatch.8.p queuelen queuemax roomfor sendbatches teststuff \
X	testmakefile
XPLIST=README Makefile sendbatches batchmake.c batchmunch batchprep \
X	batchsize batchxmit queuelen queuemax roomfor
X
Xthem:	batchmake newsbatch.8
X
Xbatchmake:	batchmake.o
X	cc $(CFLAGS) $(LDFLAGS) batchmake.o -o $@
X
Xnewsbatch.8:	newsbatch.8.p muck
X	sed -f muck newsbatch.8.p >$@
X
Xmuck:
X	echo 's;\$$NEWSCTL;$(NEWSCTL);g' >muck
X	echo 's;\$$NEWSARTS;$(NEWSARTS);g' >>muck
X	echo 's;\$$NEWSBIN;$(NEWSBIN);g' >>muck
X
Xtidy:
X	rm -f batchmake batchmake.o muck newsbatch.8
X
Xinstall:	$(PGMS) newsbatch.8 teststuff muck
X	if test ! -d $(NEWSBIN)/batch ; then mkdir $(NEWSBIN)/batch ; fi
X	cp $(PGMS) $(NEWSBIN)/batch
X	cp newsbatch.8 /usr/man/man8
X	if test ! -d $(NEWSCTL)/batch ; then mkdir $(NEWSCTL)/batch ; fi
X	if test ! -d $(NEWSCTL)/batch/b.test ; then mkdir $(NEWSCTL)/batch/b.test ; fi
X	cat teststuff | ( cd $(NEWSCTL)/batch/b.test ; sh )
X	sed -f muck testmakefile >$(NEWSCTL)/batch/b.test/Makefile
X	@echo 'To test, cd $(NEWSCTL)/batch/b.test and say "make".'
X
X# EXCISE
X
Xteststuff:
X	cd b.test; makedtr * >../teststuff
X
Xdtr:	$(ALL)
X	makedtr $(ALL) >dtr
X
XdMakefile:	Makefile
X	sed '/^# EXCISE/,$$d; s/tidy/clean/' Makefile >$@
X
Xclean:	tidy
X	rm -f teststuff dMakefile
X
Xprint:
X	pr $(PLIST) | hpfour
END_OF_FILE
if test 1567 -ne `wc -c <'batch/Makefile'`; then
    echo shar: \"'batch/Makefile'\" unpacked with wrong size!
fi
# end of 'batch/Makefile'
fi
if test -f 'gngp/gngp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gngp/gngp.c'\"
else
echo shar: Extracting \"'gngp/gngp.c'\" \(1988 characters\)
sed "s/^X//" >'gngp/gngp.c' <<'END_OF_FILE'
X/*
X * gngp - globally find newsgroup and print
X *	like grep, but for newsgroup patterns instead of regular expressions
X */
X
X#include <stdio.h>
X
Xchar *progname;
Xint debug = 0;
X
X/*
X * if true, match only ng at start of line, followed by whitespace or newline.
X */
Xint anchored = 0;
X
XFILE *efopen();
X
X/*
X * main - parse arguments and handle options
X */
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	int c, status = 0;
X	int errflg = 0;
X	FILE *in;
X	extern int optind;
X	extern char *optarg;
X
X	progname = argv[0];
X	while ((c = getopt(argc, argv, "ad")) != EOF)
X		switch (c) {
X		case 'a':		/* anchored at start of line */
X			anchored++;
X			break;
X		case 'd':
X			matchdebug(1);	/* all debugging on */
X			debug++;
X			break;
X		default:
X			errflg++;
X			break;
X		}
X	if (errflg || optind == argc) {
X		(void) fprintf(stderr, "usage: %s [-ad] pattern [file...]\n",
X			progname);
X		exit(2);
X	}
X	if (optind == argc-1)
X		status |= process(argv[optind], stdin, "stdin");
X	else {
X		int patind = optind;
X
X		for (optind++; optind < argc; optind++) {
X			in = efopen(argv[optind], "r");
X			status |= process(argv[patind], in, argv[optind]);
X			(void) fclose(in);
X		}
X	}
X	exit(status != 0? 0: 1);
X}
X
X/*
X * process - process input file
X */
Xprocess(pattern, in, inname)
Xchar *pattern;
XFILE *in;
Xchar *inname;
X{
X	int status = 0;
X	char line[BUFSIZ];
X
X	while (fgets(line, sizeof line, in) != NULL)
X		if (anchored)
X			status |= gngp(pattern, line);
X		else {
X			register char *start;
X
X			for (start = line; *start != '\0'; start++)
X				status |= gngp(pattern, start);
X		}
X	return status;
X}
X
Xint
Xgngp(pattern, text)
Xregister char *pattern, *text;
X{
X	int returned;
X	char savewhite;
X	char *whitesp;
X
X	if (anchored) {
X		extern char *strpbrk();
X
X		whitesp = strpbrk(text, " \t\n");
X		if (whitesp != NULL) {
X			savewhite = *whitesp;
X			*whitesp = '\0';
X		}
X	}
X	returned = ngmatch(pattern, text);
X	if (anchored) {
X		if (whitesp != NULL)
X			*whitesp = savewhite;
X	}
X	if (returned)
X		(void) fputs(text, stdout);
X	return returned;
X}
END_OF_FILE
if test 1988 -ne `wc -c <'gngp/gngp.c'`; then
    echo shar: \"'gngp/gngp.c'\" unpacked with wrong size!
fi
# end of 'gngp/gngp.c'
fi
if test -f 'libc/error.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/error.3'\"
else
echo shar: Extracting \"'libc/error.3'\" \(1621 characters\)
sed "s/^X//" >'libc/error.3' <<'END_OF_FILE'
X.TH ERROR 3 local
X.DA 8 May 1984
X.SH NAME
Xerror, warning \- print error messages
X.SH SYNOPSIS
X.nf
X.B error(s1, s2)
X.B char *s1;
X.B char *s2;
X
X.B warning(s1, s2)
X.B char *s1;
X.B char *s2;
X
X.B extern char *progname;
X.B extern int errno;
X
X.B progname = argv[0];
X.SH DESCRIPTION
X.I Warning
Xprints an error message, with suitable embellishments,
Xand clears
X.IR errno .
X.I Error
Xdoes likewise and then exits.
XThe
X.I s1
Xargument should be a
X.I printf
Xformat string (without a trailing newline), with
X.I s2
Xavailable as an argument.
X.PP
XIf there is an environment variable
X.BR CMDNAME
Xwith non-null value,
Xits contents are printed first, followed by a colon.
XFollowing this,
Xany non-null value of
X.I progname
Xis printed, followed by a colon and a space.
XFollowing this,
X.IR fprintf (3)
Xis invoked with
X.I s1
Xas the format string and
X.I s2
Xas the argument.
XIf the value of
X.I errno
Xis within the normal range,
Xa standard elaborating message is printed (see
X.IR intro (2)).
X.PP
X.B CMDNAME
Xshould be set by shellfiles that expect subordinate programs to
Xissue error message in the shellfile's name.
X.I Progname
Xshould be set by all programs;
X.I argv[0]
Xis usually a suitable thing to set it to.
X.I Errno
Xis set by system calls and various other routines,
Xalthough its use is not universal;
Xnote that it is not reset by successful system calls following an
Xunsuccessful one.
X.SH SEE ALSO
Xintro(2), intro(3), printf(3), exit(2), getopt(3)
X.SH DIAGNOSTICS
X.IR Error 's
Xexit status is 1.
X.SH HISTORY
XLocal products, modelled on the
X.I error
Xin Kernighan&Pike.
X.SH BUGS
XBe nice if they could take a full
X.IR printf -style
Xargument list.
END_OF_FILE
if test 1621 -ne `wc -c <'libc/error.3'`; then
    echo shar: \"'libc/error.3'\" unpacked with wrong size!
fi
# end of 'libc/error.3'
fi
if test -f 'libc/fgetmfs.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/fgetmfs.3'\"
else
echo shar: Extracting \"'libc/fgetmfs.3'\" \(1406 characters\)
sed "s/^X//" >'libc/fgetmfs.3' <<'END_OF_FILE'
X.TH FGETMFS 3 local "Public Domain"
X.DA 3 August 1987
X.SH NAME
Xfgetmfs \- read an arbitrarily long, possibly continued line
X.SH SYNOPSIS
X.B "#include <stdio.h>
X.br
X.B "#include <fgetmfs.h>
X.PP
X.B "char *fgetmfs(stream, cont)"
X.br
X.B "FILE *stream;"
X.br
X.B "int cont;"
X.SH DESCRIPTION
X.I Fgetmfs
Xreads an arbitrarily long line from
X.IR stream ,
Xallocating memory via
X.IR malloc (3)
Xas needed.
XFor efficiency,
Xif
X.I cont
Xis not
X.IR CONT_NO ,
Xsuch as
X.I CONT_NOSPC
Xor
X.IR CONT_SPC ,
Xoccurrences of a backslash and a newline together
Xand in that order
Xwill be deleted from the input stream;
Xif
X.I cont
Xis
X.IR CONT_NOSPC ,
Xany whitespace after the newline
Xin the input stream will also be deleted from it.
X.PP
X.I Fgetmfs
Xis intended to provide a reliable mechanism for reading
Xinput containing lines of arbitrary length,
Xrather than trusting that no line with be longer than some
Xarbitrary tolerance.
X.PP
XThe memory returned by
X.I fgetmfs
Xshould be returned when no longer needed via
X.IR free (3).
X.\" .SH FILES
X.SH SEE ALSO
X.IR malloc (3),
X.IR fgets (3)
X.SH DIAGNOSTICS
XReturns NULL (0) if memory cannot be allocated or upon reading end-of-file;
Xuse
X.I feof(stream)
Xto distinguish.
X.SH HISTORY
XWritten by Geoff Collyer
Xat the University of Toronto
Xas part of the C news project.
X.SH BUGS
XIt's too slow.
X.br
XThe meaning of the
X.I cont
Xflag is ugly,
Xbut layering this form of continuation on top is even slower.
END_OF_FILE
if test 1406 -ne `wc -c <'libc/fgetmfs.3'`; then
    echo shar: \"'libc/fgetmfs.3'\" unpacked with wrong size!
fi
# end of 'libc/fgetmfs.3'
fi
if test -f 'libc/memcpy.fast/src/duff.longs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/memcpy.fast/src/duff.longs.c'\"
else
echo shar: Extracting \"'libc/memcpy.fast/src/duff.longs.c'\" \(1420 characters\)
sed "s/^X//" >'libc/memcpy.fast/src/duff.longs.c' <<'END_OF_FILE'
X#define LUMP long
X
Xmemcpy(to, from, count)	/* assumes unaligned LUMPs can be copied */
Xregister char *from, *to;
Xregister int count;
X{
X	/*
X	 * This code uses Duff's Device (tm Tom Duff)
X	 * to unroll the copying loop:
X	 * while (count-- > 0)
X	 *	*to++ = *from++;
X	 * Sorry the code is so ugly.
X	 */
X	if (count > 0) {
X		register LUMP *fromlump = (LUMP *)from, *tolump = (LUMP *)to;
X		register int inloops;
X		register int loops = count >> 3;	/* /8 */
X
X		count %= 8;		/* about to copy loops*8 bytes */
X		inloops = (loops+8-1) >> 3;	/* /8 round up */
X#define COPY8BYTES	*tolump++ = *fromlump++; \
X			*tolump++ = *fromlump++
X		if (loops > 0) {
X			switch (loops&(8-1)) {	/* %8 */
X			case 0:	do {
X					COPY8BYTES;
X				case 7:	COPY8BYTES;
X				case 6:	COPY8BYTES;
X				case 5:	COPY8BYTES;
X				case 4:	COPY8BYTES;
X				case 3:	COPY8BYTES;
X				case 2:	COPY8BYTES;
X				case 1:	COPY8BYTES;
X				} while (--inloops > 0);
X			}
X			from = (char *)fromlump;
X			to = (char *)tolump;
X		}
X	}
X	/*
X	 * This code uses Duff's Device (tm Tom Duff)
X	 * to unroll the copying loop the last count%8 times:
X	 * while (count-- > 0)
X	 *	*to++ = *from++;
X	 * Sorry the code is so ugly.
X	 */
X	if (count > 0) {
X		switch (count&(8-1)) {	/* %8 */
X		case 0:
X#define COPYBYTE *to++ = *from++
X				COPYBYTE;
X			case 7:	COPYBYTE;
X			case 6:	COPYBYTE;
X			case 5:	COPYBYTE;
X			case 4:	COPYBYTE;
X			case 3:	COPYBYTE;
X			case 2:	COPYBYTE;
X			case 1:	COPYBYTE;
X		}
X	}
X}
END_OF_FILE
if test 1420 -ne `wc -c <'libc/memcpy.fast/src/duff.longs.c'`; then
    echo shar: \"'libc/memcpy.fast/src/duff.longs.c'\" unpacked with wrong size!
fi
# end of 'libc/memcpy.fast/src/duff.longs.c'
fi
if test -f 'libc/standard.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/standard.3'\"
else
echo shar: Extracting \"'libc/standard.3'\" \(1641 characters\)
sed "s/^X//" >'libc/standard.3' <<'END_OF_FILE'
X.TH STANDARD 3 local
X.DA 9 Feb 1982
X.SH NAME
Xstandard, safe \- standardize conditions in preparation for exec
X.SH SYNOPSIS
X.B standard()
X.PP
X.B safe()
X.SH DESCRIPTION
X.I Standard
Xalters a process's environment to make it relatively safe to do
X.IR execvp ,
X.IR system ,
X.IR popen ,
Xetc.
XIt closes all descriptors except
Xthe standard ones and supplies a standard set of environment variables
Xthat ensure a standard interpretation of shell commands and a
Xstandard search path for programs.
X.PP
X.I Safe
Xis similar, but is intended for use in shell escapes and suchlike.
XIt leaves the environment variables untouched but turns off
Xsetuid and setgid permissions.
X.PP
XUse of either one permits a setuid/setgid program to
Xrun other programs without inadvertently bestowing special powers
Xon nonstandard programs.
XCare must still be exercised as to what the standard descriptors
Xrefer to,
Xand it is still possible for
Xprograms executed after use of
X.I standard
X(as opposed to
X.IR safe )
Xto give away special powers through
X.I their
Xcarelessness.
X.SH SEE ALSO
Xenviron(3), closeall(3)
X.SH HISTORY
XLocal products.
X.SH BUGS
X.I Standard
Xmust necessarily supply standard values for some environment variables,
Xbut it is not clear whether it should pass other variables
Xthrough or eliminate them.
XThe current implementation eliminates them, which is safer but sometimes
Xinconvenient.
X.PP
XOne can construct elaborate scenarios in which a setuid
Xprogram employing
X.I safe
Xcould be duped into
Xexecuting a user-supplied program in a current directory
Xthe user ordinarily could not have reached.
X.PP
XPossibly
Xone or both should standardize the
X.I umask
Xsetting.
END_OF_FILE
if test 1641 -ne `wc -c <'libc/standard.3'`; then
    echo shar: \"'libc/standard.3'\" unpacked with wrong size!
fi
# end of 'libc/standard.3'
fi
if test -f 'libc/strings/string.h.proto' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/strings/string.h.proto'\"
else
echo shar: Extracting \"'libc/strings/string.h.proto'\" \(1489 characters\)
sed "s/^X//" >'libc/strings/string.h.proto' <<'END_OF_FILE'
X/*
X * String functions.
X */
X
XVOIDSTAR memcpy(/*VOIDSTAR dst, const VOIDSTAR src, SIZET size*/);
XVOIDSTAR memccpy(/*VOIDSTAR dst, const VOIDSTAR src, int ucharstop, SIZET size*/);
Xchar *strcpy(/*char *dst, const char *src*/);
Xchar *strncpy(/*char *dst, const char *src, SIZET size*/);
Xchar *strcat(/*char *dst, const char *src*/);
Xchar *strncat(/*char *dst, const char *src, SIZET size*/);
Xint memcmp(/*const VOIDSTAR s1, const VOIDSTAR s2, SIZET size*/);
Xint strcmp(/*const char *s1, const char *s2*/);
Xint strncmp(/*const char *s1, const char *s2, SIZET size*/);
XVOIDSTAR memchr(/*const VOIDSTAR s, int ucharwanted, SIZET size*/);
Xchar *strchr(/*const char *s, int charwanted*/);
XSIZET strcspn(/*const char *s, const char *reject*/);
Xchar *strpbrk(/*const char *s, const char *breakat*/);
Xchar *strrchr(/*const char *s, int charwanted*/);
XSIZET strspn(/*const char *s, const char *accept*/);
Xchar *strstr(/*const char *s, const char *wanted*/);
Xchar *strtok(/*char *s, const char *delim*/);
XVOIDSTAR memset(/*VOIDSTAR s, int ucharfill, SIZET size*/);
XSIZET strlen(/*const char *s*/);
X
X/*
X * V7 and Berklix compatibility.
X */
Xchar *index(/*const char *s, int charwanted*/);
Xchar *rindex(/*const char *s, int charwanted*/);
Xint bcopy(/*const char *src, char *dst, int length*/);
Xint bcmp(/*const char *s1, const char *s2, int length*/);
Xint bzero(/*char *dst, int length*/);
X
X/*
X * Putting this in here is really silly, but who am I to argue with X3J11?
X */
Xchar *strerror(/*int errnum*/);
END_OF_FILE
if test 1489 -ne `wc -c <'libc/strings/string.h.proto'`; then
    echo shar: \"'libc/strings/string.h.proto'\" unpacked with wrong size!
fi
# end of 'libc/strings/string.h.proto'
fi
if test -f 'libcnews/lock.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libcnews/lock.c'\"
else
echo shar: Extracting \"'libcnews/lock.c'\" \(1717 characters\)
sed "s/^X//" >'libcnews/lock.c' <<'END_OF_FILE'
X/*
X * C news system locking.
X * It's compatible with B 2.10.1 news, except that locks are never
X * declared stale (blow 'em away in /etc/rc).
X * Only permit rnews to run on a file server to make this sane.
X */
X
X#include <stdio.h>
X#include <errno.h>
X#include <sys/types.h>
X#include "news.h"
X
X#define LOCKNAME "LOCK"
X#define LOCKTEMP "LOCKTMXXXXXX"
X#define INTERVAL 25		/* seconds to sleep on a busy lock */
X
Xstatic int debug = NO;
Xstatic int mylock = NO;
X
Xlockdebug(state)
Xint state;
X{
X	debug = state;
X}
X
Xnewslock()
X{
X	int locktries = 0;
X	char tempnm[MAXFILE], lockfile[MAXFILE];
X	FILE *tempfp;
X	extern int errno;
X	char *libfile();
X	char *strcpy(), *mktemp();
X
X	/* create temporary name for linking; store my pid in it */
X	(void) strcpy(tempnm, libfile(LOCKTEMP));
X	(void) mktemp(tempnm);
X	tempfp = fopen(tempnm, "w");
X	if (tempfp == NULL)
X		error("can't create lock temporary `%s'", tempnm);
X	(void) fprintf(tempfp, "%d\n", getpid());
X	(void) fclose(tempfp);
X
X	/* repeatedly try to link the temporary name to LOCKNAME */
X	(void) strcpy(lockfile, libfile(LOCKNAME));
X	while (link(tempnm, lockfile) < 0) {
X		extern char *progname;
X
X		if (errno != EEXIST)
X			error("can't link `%s' to LOCK", tempnm);
X		/*
X		 * Decide here if lock is stale.
X		 * If so, remove it and try again to lock.
X		 */
X		/* process still alive */
X		if (debug && ++locktries == 1)
X			(void) printf("%s: sleeping on LOCK\n", progname);
X		sleep(INTERVAL);
X	}
X	(void) unlink(tempnm);
X	mylock = YES;
X}
X
Xnewsunlock()
X{
X	char *libfile();
X
X	if (mylock) {
X		(void) unlink(libfile(LOCKNAME));
X		mylock = NO;
X	}
X}
X
Xerrunlock(fmt, s)		/* like error(3), but unlock before exit */
Xchar *fmt, *s;
X{
X	warning(fmt, s);
X	newsunlock();
X	exit(1);
X	/* NOTREACHED */
X}
END_OF_FILE
if test 1717 -ne `wc -c <'libcnews/lock.c'`; then
    echo shar: \"'libcnews/lock.c'\" unpacked with wrong size!
fi
# end of 'libcnews/lock.c'
fi
if test -f 'libcnews/readline.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libcnews/readline.c'\"
else
echo shar: Extracting \"'libcnews/readline.c'\" \(1904 characters\)
sed "s/^X//" >'libcnews/readline.c' <<'END_OF_FILE'
X/*
X * readline - like fgets, but newslock at first EOF
X */
X
X#include <stdio.h>
X#include <signal.h>
X#include <sys/types.h>
X#include "news.h"
X
Xvoid complain();
X
X/* How to get an unsigned char. */
X#ifdef CHARBITS
X#define	UCHARAT(p)	(*(p)&CHARBITS)
X#else
X#define	UCHARAT(p)	((int)*(unsigned char *)(p))
X#endif
X
Xint nlocked = 0;		/* newslock() done? read by the caller */
X
X/* Buffer etc. for readline and friends. */
Xstatic char buf[BUFSIZ];
Xstatic int nleft = 0;
Xstatic char *rest;
X
X/*
X - readline - read a line (sans newline), with locking when we hit EOF
X *
X * Minor flaw:  will lose a last line which lacks a newline.
X */
Xint				/* 0 success, -1 final EOF */
Xreadline(s, n, fd)
Xchar *s;
Xint n;
Xint fd;				/* Note descriptor, not FILE *. */
X{
X	register char *dst;
X	register int ndst;
X	register int c;
X	extern void refill();
X	extern int errno;
X
X	dst = s;
X	for (ndst = n-1; ndst > 0; ndst--) {	/* -1 for NUL */
X		if (nleft <= 0) {
X			refill(fd);
X			if (nleft <= 0)	/* refill gave up. */
X				return -1;
X		}
X		c = UCHARAT(rest);
X		rest++;
X		nleft--;
X
X		if (c == '\n') {
X			*dst++ = '\0';
X			return 0;
X		} else
X			*dst++ = c;
X	}
X
X	*dst++ = '\0';
X	errno = 0;
X	complain("over-long history line `%s'", s);
X	return 0;
X}
X
X/*
X - refill - refill readline's buffer, with locking on EOF
X */
Xvoid
Xrefill(fd)
Xint fd;
X{
X	register int ret;
X
X	/* Just in case... */
X	if (nleft > 0)
X		return;
X
X	/* Try ordinary read. */
X	ret = read(fd, buf, (int)sizeof(buf));
X	if (ret < 0) {
X		complain("read error in history", "");
X		return;
X	}
X	if (ret > 0) {
X		nleft = ret;
X		rest = buf;
X		return;
X	}
X
X	/* EOF. */
X	if (nlocked)
X		return;		/* We're really done. */
X
X	/* EOF but we haven't locked yet.  Lock and try again. */
X	(void) signal(SIGINT, (sigarg_t)SIG_IGN);
X	(void) signal(SIGQUIT, (sigarg_t)SIG_IGN);
X	(void) signal(SIGHUP, (sigarg_t)SIG_IGN);
X	(void) signal(SIGTERM, (sigarg_t)SIG_IGN);
X	newslock();
X	nlocked = 1;
X	refill(fd);
X}
END_OF_FILE
if test 1904 -ne `wc -c <'libcnews/readline.c'`; then
    echo shar: \"'libcnews/readline.c'\" unpacked with wrong size!
fi
# end of 'libcnews/readline.c'
fi
if test -f 'mail/coder/uuencode.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mail/coder/uuencode.c'\"
else
echo shar: Extracting \"'mail/coder/uuencode.c'\" \(1989 characters\)
sed "s/^X//" >'mail/coder/uuencode.c' <<'END_OF_FILE'
X/* based on 5.1 (Berkeley) 7/2/83 */
X
X/*
X * uuencode [input] output
X *
X * Encode a file so it can be mailed to a remote system.
X */
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X
Xmain(argc, argv)
Xchar **argv;
X{
X	FILE *in;
X	struct stat sbuf;
X	int mode;
X
X	/* optional 1st argument */
X	if (argc > 2) {
X		if ((in = fopen(argv[1], "r")) == NULL) {
X			perror(argv[1]);
X			exit(1);
X		}
X		argv++; argc--;
X	} else
X		in = stdin;
X
X	if (argc != 2) {
X		(void) fprintf(stderr, "Usage: uuencode [infile] remotefile\n");
X		exit(2);
X	}
X
X	/* figure out the input file mode */
X	(void) fstat(fileno(in), &sbuf);
X	mode = sbuf.st_mode & 0777;
X	(void) printf("begin %o %s\n", mode, argv[1]);
X
X	encode(in, stdout);
X
X	(void) printf("end\n");
X	exit(0);
X}
X
X/*
X * copy from in to out, encoding as you go along.
X */
Xencode(in, out)
XFILE *in;
XFILE *out;
X{
X	register char *ibp, *obp;
X	register int inbyte, outbyte;
X	register char *ibufend;
X	register int incount;
X	char inbuf[45+1+3];		/* +3 is due to sloppy for test */
X	char outbuf[1+60+1+1];		/* len+text+newline */
X
X/* ENC is the basic 1 character encoding function to make a char printing */
X#define ENC(c) (((c) & 077) + ' ')	/* N.B.: c is evaluated exactly once. */
X
X	do {
X		incount = fread(inbuf, 1, 45, in);
X		ibp = inbuf;
X		obp = outbuf;
X		*obp++ = ENC(incount);
X		for (ibufend = inbuf + incount; ibp < ibufend; ) {
X			/*
X			 * Encode (as 4 bytes pointed at by obp) one group
X			 * of 3 bytes pointed at by ibp.
X			 * Code is obscure to make it blaze along (sorry).
X			 * Each "*obp++ = ENC(...)" emits the next 6 bits of
X			 * the input bytes.
X			 */
X			*obp++ = ENC((inbyte = *ibp++) >> 2);
X			outbyte = (inbyte << 4) /* & 060 */ ;
X			*obp++ = ENC(outbyte | (((inbyte = *ibp++) >> 4) & 017));
X			outbyte = (inbyte << 2) /* & 074 */ ;
X			*obp++ = ENC(outbyte | (((inbyte = *ibp++) >> 6) & 03));
X			*obp++ = ENC(inbyte /* & 077 */ );
X		}
X		*obp++ = '\n';
X		*obp = '\0';
X		(void) fwrite(outbuf, 1, obp - outbuf, out);
X	} while (incount > 0);
X}
END_OF_FILE
if test 1989 -ne `wc -c <'mail/coder/uuencode.c'`; then
    echo shar: \"'mail/coder/uuencode.c'\" unpacked with wrong size!
fi
# end of 'mail/coder/uuencode.c'
fi
if test -f 'newsbin.proto/control/newgroup' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsbin.proto/control/newgroup'\"
else
echo shar: Extracting \"'newsbin.proto/control/newgroup'\" \(1152 characters\)
sed "s/^X//" >'newsbin.proto/control/newgroup' <<'END_OF_FILE'
X#! /bin/sh
X# newgroup group - create group (4-field version: B-2.10.3 and later compatible)
X#	subject to our sys file group pattern
X# B 2.11 requires an Approved: header; someday.
XNEWSCTL=${NEWSCTL-/usr/lib/news}; export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}; export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}; export NEWSARTS
XPATH=/bin:/usr/bin:/usr/ucb:$NEWSCTL:$NEWSBIN; export PATH	# must find mkpdir
XF=/tmp/nc$$
Xadmin=usenet
X
Xcat >$F
XSENDER="`grep '^Sender:' $F | sed 's/^[^:]*: *//'`"
Xcase "$SENDER" in
X"")
X	SENDER="`grep '^From:' $F | sed 's/^[^:]*: *//'`"
X	;;
Xesac
X
Xif grep -s "^`echo $1 | sed 's/\./\\\\./g'` " $NEWSCTL/active; then	# group exists
X	: do nothing
Xelif gngp -a `
X    egrep "^(\`hostname\`|ME):" $NEWSCTL/sys | awk -F: '{print $2; exit}'
X    ` >/dev/null <<!
X$1
X!
Xthen			# no group in active, but sys file likes it: make it
X	case "$2" in
X	moderated)	flag=m ;;
X	*)	flag=y ;;
X	esac
X	echo "$1 00000 00000 $flag" >>$NEWSCTL/active
X	# TODO: is it worth making the directory now? maybe, rn bitches otherwise
X	mkpdir $NEWSARTS/`echo $1 | sed 's/\./\//g' `
X	echo "newsgroup $1 was created by $SENDER." | mail $admin
Xfi
X
Xrm -f $F*
END_OF_FILE
if test 1152 -ne `wc -c <'newsbin.proto/control/newgroup'`; then
    echo shar: \"'newsbin.proto/control/newgroup'\" unpacked with wrong size!
fi
# end of 'newsbin.proto/control/newgroup'
fi
if test -f 'newsbin.proto/control/newgroup.4' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsbin.proto/control/newgroup.4'\"
else
echo shar: Extracting \"'newsbin.proto/control/newgroup.4'\" \(1152 characters\)
sed "s/^X//" >'newsbin.proto/control/newgroup.4' <<'END_OF_FILE'
X#! /bin/sh
X# newgroup group - create group (4-field version: B-2.10.3 and later compatible)
X#	subject to our sys file group pattern
X# B 2.11 requires an Approved: header; someday.
XNEWSCTL=${NEWSCTL-/usr/lib/news}; export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}; export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}; export NEWSARTS
XPATH=/bin:/usr/bin:/usr/ucb:$NEWSCTL:$NEWSBIN; export PATH	# must find mkpdir
XF=/tmp/nc$$
Xadmin=usenet
X
Xcat >$F
XSENDER="`grep '^Sender:' $F | sed 's/^[^:]*: *//'`"
Xcase "$SENDER" in
X"")
X	SENDER="`grep '^From:' $F | sed 's/^[^:]*: *//'`"
X	;;
Xesac
X
Xif grep -s "^`echo $1 | sed 's/\./\\\\./g'` " $NEWSCTL/active; then	# group exists
X	: do nothing
Xelif gngp -a `
X    egrep "^(\`hostname\`|ME):" $NEWSCTL/sys | awk -F: '{print $2; exit}'
X    ` >/dev/null <<!
X$1
X!
Xthen			# no group in active, but sys file likes it: make it
X	case "$2" in
X	moderated)	flag=m ;;
X	*)	flag=y ;;
X	esac
X	echo "$1 00000 00000 $flag" >>$NEWSCTL/active
X	# TODO: is it worth making the directory now? maybe, rn bitches otherwise
X	mkpdir $NEWSARTS/`echo $1 | sed 's/\./\//g' `
X	echo "newsgroup $1 was created by $SENDER." | mail $admin
Xfi
X
Xrm -f $F*
END_OF_FILE
if test 1152 -ne `wc -c <'newsbin.proto/control/newgroup.4'`; then
    echo shar: \"'newsbin.proto/control/newgroup.4'\" unpacked with wrong size!
fi
# end of 'newsbin.proto/control/newgroup.4'
fi
if test -f 'newshist/newshist.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newshist/newshist.c'\"
else
echo shar: Extracting \"'newshist/newshist.c'\" \(1312 characters\)
sed "s/^X//" >'newshist/newshist.c' <<'END_OF_FILE'
X/*
X * newshist msgids - print history lines corresponding to msgids
X */
X
X#include <stdio.h>
X#include "history.h"
X
Xchar *progname;
Xint debug;
Xstatic char *history;		/* unused */
Xint remote;			/* to satisfy rnews code */
X
X/*
X * main - parse arguments and handle options
X */
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	int c;
X	int errflg = 0;
X	extern int optind;
X	extern char *optarg;
X
X	progname = argv[0];
X	while ((c = getopt(argc, argv, "df:")) != EOF)
X		switch (c) {
X		case 'd':
X			++debug;
X			break;
X		case 'f':
X			history = optarg;
X			break;
X		default:
X			errflg++;
X			break;
X		}
X	if (optind == argc || errflg) {
X		fprintf(stderr, "usage: %s [-df file]\n", progname);
X		exit(2);
X	}
X
X	for (; optind < argc; optind++)
X		process(argv[optind]);
X	exit(0);
X}
X
X/*
X * process - message-id argument
X */
Xprocess(msgid)
Xchar *msgid;
X{
X	char *histent;
X
X	if (msgid == NULL)
X		return;		
X	histent = gethistory(msgid);
X	if (histent == NULL) {
X		char newmsgid[1000];
X		extern char *strcpy(), *strcat();
X
X		(void) strcpy(newmsgid, "<");
X		(void) strcat(newmsgid, msgid);
X		(void) strcat(newmsgid, ">");
X		histent = gethistory(newmsgid);
X	}
X	if (histent == NULL)
X		fprintf(stderr, "%s: no history entry for %s nor <%s>\n",
X			progname, msgid, msgid);
X	else
X		fputs(histent, stdout);
X	(void) fflush(stdout);
X}
X
Xunprivileged()
X{
X}
END_OF_FILE
if test 1312 -ne `wc -c <'newshist/newshist.c'`; then
    echo shar: \"'newshist/newshist.c'\" unpacked with wrong size!
fi
# end of 'newshist/newshist.c'
fi
if test -f 'rna/makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rna/makefile'\"
else
echo shar: Extracting \"'rna/makefile'\" \(2018 characters\)
sed "s/^X//" >'rna/makefile' <<'END_OF_FILE'
XDEFINES=-Dstrchr=index -Dstrrchr=rindex
XCFLAGS=-O $(DEFINES) # -s is a stupid idea
XINSTALL=:# install bigpdp
XNFLAG =
XI=/usr/include
XC=/lib/libc.a
XLIBS=lib/*.a
XLIBDIR=/usr/lib/news
XBINDIR=/bin
XCOMMANDS = postnews uurec readnews uusend expire postgroup
XFILES = help
XLCOMMANDS = postnews.lint uurec.lint readnews.lint uusend.lint expire.lint
XPFILES = header.c postnews.c funcs.c active.c history.c maketime.c mtempnam.c
XRFILES = header.c readnews.c funcs.c active.c newsrc.c history.c maketime.c
XROFILES= header.o readnews.o funcs.o active.o newsrc.o history.o maketime.o
XEFILES = expire.c funcs.c active.c
XLINT = lint -ha $(DEFINES)
X
X.c.lint:
X	$(LINT) $< > $@
X
X.c:
X	$(CC) $(CFLAGS) $*.c $(NFLAG) -o $(@F)
X	$(INSTALL) $* bin 711 $@
X
X.sh:
X	$(INSTALL) -c $*.sh bin 755 $@
X
Xall: defs.h $(LIBDIR) $(COMMANDS) $(FILES)
X
Xdefs.h:	at.h $C
X	touch defs.h
X
X$(LIBDIR):
X	mkdir $(LIBDIR)
X	chown news $(LIBDIR)
X	chmod 755 $(LIBDIR)
X
Xlint: $(LCOMMANDS)
X
Xhelp: $(LIBDIR)/help
X$(LIBDIR)/help: news.help
X	$(INSTALL) -c news.help news 644 $(LIBDIR)/help
X
Xpostnews: $(BINDIR)/postnews
X$(BINDIR)/postnews: $(PFILES) defs.h
X	$(CC) $(CFLAGS) $(PFILES) -o postnews
X	$(INSTALL) - postnews news 6711 $(BINDIR)/postnews
X
Xpostgroup: $(BINDIR)/postgroup
X$(BINDIR)/postgroup: postgroup.sh
X
Xuurec: $(LIBDIR)/uurec
X$(LIBDIR)/uurec: uurec.c defs.h
X
Xreadnews: $(BINDIR)/readnews
X$(BINDIR)/readnews: $(ROFILES) defs.h
X	$(CC) $(CFLAGS) $(ROFILES) $(LIBS) -o readnews
X	$(INSTALL) - readnews bin 711 $(BINDIR)/readnews $(BINDIR)/news
X$(ROFILES): defs.h
X
Xuusend: $(LIBDIR)/uusend
X$(LIBDIR)/uusend: defs.h uusend.c
X
Xexpire: $(LIBDIR)/expire
X$(LIBDIR)/expire: $(EFILES) defs.h
X	$(CC) $(CFLAGS) $(EFILES) $(NFLAG) -o expire
X	$(INSTALL) expire news 700 $(LIBDIR)/expire
X
Xpostnews.lint: $(PFILES)
X	$(LINT) $(PFILES) > postnews.lint
X
Xreadnews.lint: $(RFILES)
X	$(LINT) $(RFILES) > readnews.lint
X
Xexpire.lint: $(EFILES)
X	$(LINT) $(EFILES) > expire.lint
X
Xuurec.lint: uurec.c defs.h
Xuusend.lint: uusend.c defs.h
X
X.FINISH:
X	rm -s *.o
Xclean:
X	rm -f *.o core a.out readnews
END_OF_FILE
if test 2018 -ne `wc -c <'rna/makefile'`; then
    echo shar: \"'rna/makefile'\" unpacked with wrong size!
fi
# end of 'rna/makefile'
fi
if test -f 'rna/mtempnam.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rna/mtempnam.c'\"
else
echo shar: Extracting \"'rna/mtempnam.c'\" \(1295 characters\)
sed "s/^X//" >'rna/mtempnam.c' <<'END_OF_FILE'
X/*
X * same as usual tempnam.c except force placement in the directory
X * we ask for
X */
X#include <stdio.h>
X
X#ifndef P_tmpdir
X#define P_tmpdir	"/tmp/"
X#define L_tmpnam	(sizeof(P_tmpdir) + 15)
X#endif
X
X#define max(A,B) (((A)<(B))?(B):(A))
X
Xextern char *malloc(), *getenv(), *mktemp();
Xextern char *strncat(), *strcat(), *strcpy();
Xextern int access();
X
Xstatic char *pcopy(), *seed = "AAA";
X
Xchar *
Xmtempnam(dir, pfx)
Xchar *dir;		/* use this directory please (if non-NULL) */
Xchar *pfx;		/* use this (if non-NULL) as filename prefix */
X{
X	register char *p, *q;
X	int x = 0, y = 0, z;
X
X	z = strlen(P_tmpdir);
X	if (dir != NULL) {
X		y = strlen(dir);
X	}
X	if ((p = malloc((unsigned)(max(max(x, y), z) + 16))) == NULL)
X		return(NULL);
X	if (y > 0 && pcopy(p, dir))
X		goto OK;
X	if (access(pcopy(p, P_tmpdir), 3) == 0)
X		goto OK;
X	if (access(pcopy(p, "/tmp"), 3) != 0)
X		return(NULL);
XOK:
X	strcat(p, "/");
X	if (pfx) {
X		*(p + strlen(p) + 5) = '\0';
X		strncat(p, pfx, 5);
X	}
X	strcat(p, seed);
X	strcat(p, "XXXXXX");
X	q = seed;
X	while (*q == 'Z')
X		*q++ = 'A';
X	++ * q;
X	if (*mktemp(p) == '\0')
X		return(NULL);
X	return(p);
X}
X
X
Xstatic char *
Xpcopy(space, arg)
Xchar *space, *arg;
X{
X	char *p;
X
X	if (arg) {
X		strcpy(space, arg);
X		p = space - 1 + strlen(space);
X		if (*p == '/')
X			*p = '\0';
X	}
X	return(space);
X}
X
X
END_OF_FILE
if test 1295 -ne `wc -c <'rna/mtempnam.c'`; then
    echo shar: \"'rna/mtempnam.c'\" unpacked with wrong size!
fi
# end of 'rna/mtempnam.c'
fi
if test -f 'rna/rnews.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rna/rnews.sh'\"
else
echo shar: Extracting \"'rna/rnews.sh'\" \(1301 characters\)
sed "s/^X//" >'rna/rnews.sh' <<'END_OF_FILE'
X#
X# rnews  (M. J. Liebelt, University of Adelaide, May 1984)
X#
X# netgets files sent to "news" as "newsitem"s and pipes them into
X# postnews, then reads any mail sent to "news" and pipes that into
X# $LIBDIR/uurec, which passes the news portions onto postnews.
X#
X# It should be run as "/etc/su news rnews " (i.e. with uid = news)
X#
X# News should be sent to news at this host from remote hosts thus:
X#      ... | /usr/lib/news/uusend news:thishost   (to send by mail, or)
X#      ... | net -hthishost -nnews -f -Nnewsitem -M
X#
X#    where "thishost" is the NETID of this host.
X#
X# LIBDIR - same as LIBDIR in Makefile
X# BINDIR - same as BINDIR in Makefile
X# NETDIR - where netget lives
XLIBDIR=/usr/lib/news
XBINDIR=/bin
XNETDIR=/bin
X
Xcd %news
X
Xwhile $NETDIR/netget newsitem > /dev/null 2>&1
Xdo
X        $BINDIR/postnews -p < newsitem > rnews.errors 2>&1
X        if [ -s rnews.errors ]
X        then
X               cat $LIBDIR/rnews.mail1 rnews.errors $LIBDIR/rnews.mail2 newsitem | mail root
X        fi
Xdone
X
Xif [ -r .mail ]
Xthen {
X        mv .mail newsmail
X        $LIBDIR/uurec < newsmail > rnews.errors 2>&1
X        if [ -s rnews.errors ]
X        then
X                cat $LIBDIR/rnews.mail1 rnews.errors $LIBDIR/rnews.mail2 newsmail | mail root
X        fi
X        }
Xfi
X
Xrm -f newsitem newsmail rnews.errors
END_OF_FILE
if test 1301 -ne `wc -c <'rna/rnews.sh'`; then
    echo shar: \"'rna/rnews.sh'\" unpacked with wrong size!
fi
# end of 'rna/rnews.sh'
fi
if test -f 'rnews/headers.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/headers.h'\"
else
echo shar: Extracting \"'rnews/headers.h'\" \(1551 characters\)
sed "s/^X//" >'rnews/headers.h' <<'END_OF_FILE'
X/*
X * All the article header values worth retaining.
X *
X * All members of hdrs must point at malloced memory so that freeheaders
X * can free it without knowledge of what's malloced and what's static.
X * Furthermore, each member of hdrs must point at its own private copy
X * of its value string, for the above reason, and no other part of inews
X * may copy any member nor a modified copy of any member.
X * Perhaps C++ will allow this to be enforced by a strings class.
X */
Xstruct headers {
X	char *h_subj;		/* subject - only needed for controls */
X	char *h_ngs;		/* newsgroups */
X	char h_files[MAXLINE];	/* file names for history */
X	char *h_distr;		/* distribution for transmit */
X	char *h_ctlcmd;		/* control command */
X	char *h_approved;	/* needed for acceptance in moderated groups */
X	char *h_msgid;		/* needed for history & rejection */
X	char *h_artid;		/* needed for history & rejection (obs.) */
X	char *h_expiry;		/* needed for history */
X	char *h_path;		/* needed for transmit - must munge */
X	char h_tmpf[MAXFILE];	/* temp link name or first spool dir link */
X	char h_unlink;		/* flag: true iff h_tmpf should be unlinked */
X	char h_filed;		/* flag: true iff article has been filed */
X	char h_xref;		/* flag: true iff Xref: header generated yet */
X	char h_octlchked;	/* flag: true iff ngs checked for all.all.ctl */
X	char h_oldctl;		/* flag: true iff ngs were all.all.ctl when checked */
X	char *h_accum;		/* accumulated headers, if any */
X	unsigned h_bytesleft;	/* in h_accum */
X	long h_charswritten;	/* into spool directory, for batcher */
X};
END_OF_FILE
if test 1551 -ne `wc -c <'rnews/headers.h'`; then
    echo shar: \"'rnews/headers.h'\" unpacked with wrong size!
fi
# end of 'rnews/headers.h'
fi
if test -f 'rnews/man/rnews.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/man/rnews.1'\"
else
echo shar: Extracting \"'rnews/man/rnews.1'\" \(1506 characters\)
sed "s/^X//" >'rnews/man/rnews.1' <<'END_OF_FILE'
X.TH RNEWS 1 Usenet "Public Domain"
X.DA 22 Aug 1987
X.SH NAME
Xrnews, cunbatch \- receive `remote' news articles
X.SH SYNOPSIS
X.B rnews
X.SH DESCRIPTION
X.I Rnews
Xbroadcasts (network) news articles
X(receives `\fIr\fPemote'
X.IR news )
Xfrom its standard input.
X.I Cunbatch
Xis just a link to
X.IR rnews .
XTypically the articles will be in a batch
X(see
X.IR news (5)),
Xwhich may be compressed
X(see
X.IR compress (1)).
X.PP
XTypically articles are stored locally
Xand queued for transmission to one's netnews neighbours via
X.IR newsbatch (1)
Xand thence via
X.IR uux (1)
Xor
X.IR mail (1).
X.SH FILES
X.PD 0
X.TP 1.5i
X.I $NEWSARTS
Xnetnews article tree
X.TP 1.5i
X.IB $NEWSCTL /sys
Xdetermines who receives broadcast netnews articles
X.TP 1.5i
X.IB $NEWSCTL /active
Xcontains locally-legal newsgroups and (un)moderated flag
X.TP 1.5i
X.IB $NEWSCTL /log
Xlog of incoming articles
X.TP 1.5i
X.IB $NEWSCTL /errlog
Xlog of errors, should be empty
X.PD
X.SH "SEE ALSO"
X.IR compress (1),
X.IR mail (1),
X.IR newsbatch (1),
X.IR uux (1),
X.IR news (5)
X.SH DIAGNOSTICS
XBatches which generate
X.I rnews
Xerrors will be mailed to
X.IR usenet ,
Xwho should rerun them by hand after fixing the problem.
X.br
XIf
X.I compress
Xis not found by the standard PATH,
Xcompressed news batches may be mailed to
X.IR usenet .
X.SH HISTORY
XWritten by Geoff Collyer
Xat the University of Toronto
Xas part of the C news project.
X.SH BUGS
X.I Rnews
Xcould run much faster if
X.I Control:
Xwere required to be the first header,
Xif present,
Xand if
X.I Newsgroups:
Xwere required to be the next.
END_OF_FILE
if test 1506 -ne `wc -c <'rnews/man/rnews.1'`; then
    echo shar: \"'rnews/man/rnews.1'\" unpacked with wrong size!
fi
# end of 'rnews/man/rnews.1'
fi
if test -f 'rnews/realrnews' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/realrnews'\"
else
echo shar: Extracting \"'rnews/realrnews'\" \(1318 characters\)
sed "s/^X//" >'rnews/realrnews' <<'END_OF_FILE'
X#! /bin/sh
X# realrnews - receive remote news & relay: feeds incoming news to C news serverrnews
XNEWSCTL=${NEWSCTL-/usr/lib/news}	# export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}	# export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}	# export NEWSARTS
XPATH=$NEWSCTL:$NEWSBIN:$NEWSBIN/relay:/bin:/usr/bin:/usr/local; export PATH
XNOTIFY=usenet
XF=/tmp/rnews$$			# should be lots of room here
XDEBUG=''
X
Xumask 2
Xtrap '' 1 2 15			# ignore signals to avoid losing articles
X
X# don't allow options
Xcase "$1" in
X-*)
X	echo "usage: $0" >&2
X	exit 1
X	;;
Xesac
X
X# capture incoming news in case serverrnews fails
Xif cat $* >$F; then
X	if uncompress <$F >$F.un; then
X		mv $F.un $F	# $F was compressed
X	else
X		rm $F.un	# $F was uncompressed already
X	fi
X	# -p redirects stdout & stderr into log files
X	if serverrnews -p -d "$DEBUG" <$F # -s $NEWSARTS -l $NEWSCTL
X	then
X		rm -f $F	# far out, it worked
X	else
X		status=$?
X		FAIL=$F.m
X		(cat <<!; sed 's/^/X/' $F; echo ---) >$FAIL
Xsubject: failed news; serverrnews status $status
X
X---
X!
X		if mail $NOTIFY <$FAIL; then
X			rm -f $FAIL	# $NOTIFY got told about the failure
X		else
X			# leave $FAIL and $F around to be seen
X			mail $NOTIFY <<!
Xlook at $FAIL and $F, they are lost news.
X!
X		fi
X	fi
Xelse
X	status=$?
X	(echo "subject: lost news; cat status $status"; echo; cat $F) |
X		mail $NOTIFY
Xfi
END_OF_FILE
if test 1318 -ne `wc -c <'rnews/realrnews'`; then
    echo shar: \"'rnews/realrnews'\" unpacked with wrong size!
fi
# end of 'rnews/realrnews'
fi
if test -f 'rnews/setnewsids/setnewsids.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/setnewsids/setnewsids.c'\"
else
echo shar: Extracting \"'rnews/setnewsids/setnewsids.c'\" \(2009 characters\)
sed "s/^X//" >'rnews/setnewsids/setnewsids.c' <<'END_OF_FILE'
X/*
X * setnewsids - sets ids to news/news, execs relay/relaynews.  Should be setuid-root.
X *	also add NEWSPERMS to the environment.
X */
X
X#include <stdio.h>
X#include <errno.h>
X#include <pwd.h>
X#include <grp.h>
X#include <sys/types.h>
X
X#include "news.h"
X#include "newspaths.h"
X
X#ifndef NEWSUSER
X#define NEWSUSER "news"
X#endif
X#ifndef NEWSGROUP
X#define NEWSGROUP "news"
X#endif
X
Xchar *progname;
X
Xstatic int userealids = NO;
X
X/*
X * main - parse arguments and handle options
X */
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	extern int optind;
X	extern char *optarg;
X
X	progname = argv[0];
X
X	/* setuid daemon prelude; various precautions */
X	(void) umask(newsumask());	/* undo silly umasks */
X	(void) alarm(0);		/* cancel any pending alarm */
X	/*
X	 * Reset certain environment variables to sane values.
X	 */
X	if (!putenv("PATH=/bin:/usr/bin") ||
X	    !putenv("IFS= \t\n"))
X		exit(1);
X	closeall(1);			/* closes all but std descriptors */
X	stdfdopen();			/* ensure standard descriptors are open */
X
X	setids();			/* change of real and effective ids */
X	/* we are now running as news, so you can all relax */
X
X	if (!putenv("NEWSPERMS="))	/* avoid loops with this marker */
X		exit(1);
X	execv(binfile("relay/relaynews"), argv);	/* re-run relay/relaynews */
X	error("can't exec %s", binfile("relay/relaynews"));
X}
X
Xsetids()				/* change of real and effective ids */
X{
X	int newsuid = getuid(), newsgid = getgid();	/* default to real ids */
X
X	(void) ctlfile((char *)NULL);	/* trigger unprivileged(), set userealids */
X	if (!userealids) {
X		register struct passwd *pwp;
X		register struct group *grp;
X
X		pwp = getpwnam(NEWSUSER);
X		if (pwp != NULL) {
X			newsuid = pwp->pw_uid;
X			newsgid = pwp->pw_gid;
X		}
X		(void) endpwent();
X		grp = getgrnam(NEWSGROUP);
X		if (grp != NULL)
X			newsgid = grp->gr_gid;
X		(void) endgrent();
X	}
X	(void) setgid(newsgid);
X	(void) setuid(newsuid);
X	/* we are now running as news, so you can all relax */
X}
X
Xvoid
Xunprivileged()			/* called if NEWSARTS, NEWSCTL or NEWSBIN present */
X{
X	userealids = YES;
X}
END_OF_FILE
if test 2009 -ne `wc -c <'rnews/setnewsids/setnewsids.c'`; then
    echo shar: \"'rnews/setnewsids/setnewsids.c'\" unpacked with wrong size!
fi
# end of 'rnews/setnewsids/setnewsids.c'
fi
if test -f 'rnews/sh/realrnews' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/sh/realrnews'\"
else
echo shar: Extracting \"'rnews/sh/realrnews'\" \(1318 characters\)
sed "s/^X//" >'rnews/sh/realrnews' <<'END_OF_FILE'
X#! /bin/sh
X# realrnews - receive remote news & relay: feeds incoming news to C news serverrnews
XNEWSCTL=${NEWSCTL-/usr/lib/news}	# export NEWSCTL
XNEWSBIN=${NEWSBIN-/usr/lib/newsbin}	# export NEWSBIN
XNEWSARTS=${NEWSARTS-/usr/spool/news}	# export NEWSARTS
XPATH=$NEWSCTL:$NEWSBIN:$NEWSBIN/relay:/bin:/usr/bin:/usr/local; export PATH
XNOTIFY=usenet
XF=/tmp/rnews$$			# should be lots of room here
XDEBUG=''
X
Xumask 2
Xtrap '' 1 2 15			# ignore signals to avoid losing articles
X
X# don't allow options
Xcase "$1" in
X-*)
X	echo "usage: $0" >&2
X	exit 1
X	;;
Xesac
X
X# capture incoming news in case serverrnews fails
Xif cat $* >$F; then
X	if uncompress <$F >$F.un; then
X		mv $F.un $F	# $F was compressed
X	else
X		rm $F.un	# $F was uncompressed already
X	fi
X	# -p redirects stdout & stderr into log files
X	if serverrnews -p -d "$DEBUG" <$F # -s $NEWSARTS -l $NEWSCTL
X	then
X		rm -f $F	# far out, it worked
X	else
X		status=$?
X		FAIL=$F.m
X		(cat <<!; sed 's/^/X/' $F; echo ---) >$FAIL
Xsubject: failed news; serverrnews status $status
X
X---
X!
X		if mail $NOTIFY <$FAIL; then
X			rm -f $FAIL	# $NOTIFY got told about the failure
X		else
X			# leave $FAIL and $F around to be seen
X			mail $NOTIFY <<!
Xlook at $FAIL and $F, they are lost news.
X!
X		fi
X	fi
Xelse
X	status=$?
X	(echo "subject: lost news; cat status $status"; echo; cat $F) |
X		mail $NOTIFY
Xfi
END_OF_FILE
if test 1318 -ne `wc -c <'rnews/sh/realrnews'`; then
    echo shar: \"'rnews/sh/realrnews'\" unpacked with wrong size!
fi
# end of 'rnews/sh/realrnews'
fi
if test -f 'rnews/speed/disk/active.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/speed/disk/active.c'\"
else
echo shar: Extracting \"'rnews/speed/disk/active.c'\" \(1426 characters\)
sed "s/^X//" >'rnews/speed/disk/active.c' <<'END_OF_FILE'
X/*
X * active file access functions (on-disk version)
X */
X
X#include <stdio.h>
X#include "inews.h"
X
Xstatic FILE *fp = NULL;
X
Xlong
Xnxtartnum(ng)
Xchar *ng;
X{
X	return incartnum(ng, 1);
X}
X
Xlong
Xprevartnum(ng)
Xchar *ng;
X{
X	return incartnum(ng, -1);
X}
X
Xstatic long
Xincartnum(ng, inc)
Xchar *ng;
Xint inc;
X{
X	register int nglen = strlen(ng);
X	register long pos, nextart = -1;
X	char line[MAXLINE];
X	extern char ldzeropad[];
X	long atol();
X
X	if (artload() != ST_OKAY)
X		return nextart;
X#ifdef MICROLOCKING
X	filelock(libfile("active"));
X#endif
X	(void) fseek(fp, 0L, 0);	/* start at the start */
X	for (pos = ftell(fp); fgets(line, sizeof line, fp) != NULL;
X	     pos = ftell(fp))
X		if (strncmp(line, ng, nglen) == 0 &&
X		    line[nglen] == ' ') {
X			nextart = atol(&line[nglen + 1]) + inc;
X			(void) fseek(fp, pos, 0);	/* back up */
X			(void) fprintf(fp, "%s ", ng);
X			(void) fprintf(fp, ldzeropad,
X				ARTNUMWIDTH, ARTNUMWIDTH, nextart);
X			(void) fflush(fp);
X			break;
X		}
X#ifdef MICROLOCKING
X	fileunlock(libfile("active"));
X#endif
X	return nextart;
X}
X
Xint
Xartload()				/* reload any cached data */
X{
X	int status = 0;
X	char *libfile();
X	FILE *fopenwclex();
X
X	if (fp == NULL)
X		if ((fp = fopenwclex(libfile("active"), "r+")) == NULL)
X			status |= ST_DROPPED;
X	return status;
X}
X
Xint
Xartsync()				/* sync to disk any cached data */
X{
X	int status = 0;
X
X	if (fp != NULL && fclose(fp) == EOF)
X		status |= ST_DROPPED;
X	fp = NULL;
X	return status;
X}
END_OF_FILE
if test 1426 -ne `wc -c <'rnews/speed/disk/active.c'`; then
    echo shar: \"'rnews/speed/disk/active.c'\" unpacked with wrong size!
fi
# end of 'rnews/speed/disk/active.c'
fi
if test -f 'rnews/speed/disk/sys.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/speed/disk/sys.c'\"
else
echo shar: Extracting \"'rnews/speed/disk/sys.c'\" \(1710 characters\)
sed "s/^X//" >'rnews/speed/disk/sys.c' <<'END_OF_FILE'
X/*
X * inews sys file reading functions (on-disk version)
X */
X
X#include <stdio.h>
X#include "inews.h"
X#include "system.h"
X
Xstatic FILE *fp = NULL;		/* descriptor for libfile("sys") */
X
Xstruct system *
Xoursys()			/* return our sys entry */
X{
X	register struct system *sys;
X	static struct system fakesys;
X	char *rindex();
X	char *hostname();
X	struct system *nextsys();
X
X	rewsys();
X	while ((sys = nextsys()) != NULL &&
X	    strcmp(sys->sy_name, hostname()) != 0)
X		;
X	if (sys == NULL) {		/* no entry; cook one up */
X		fakesys.sy_name = hostname();
X		fakesys.sy_ngs = "all";
X		fakesys.sy_flags = "";
X		fakesys.sy_cmd = "";
X		sys = &fakesys;
X	}
X	return sys;
X}
X
X/*
X * Returned pointer points at a static struct whose members
X * point at static storage.
X */
Xstruct system *
Xnextsys()			/* return next sys entry */
X{
X	register char *s;
X	register char **sp;
X	static char sysent[MAXLINE];
X	static struct system sys;	/* pointers into sysent */
X	char *strcpy(), *strcat(), *rindex();
X	char *hostname(), *libfile();
X	FILE *fopenwclex();
X
X	if (fp == NULL)
X		if ((fp = fopenwclex(libfile("sys"), "r")) == NULL)
X			return NULL;
X	while ((s = fgets(sysent, sizeof sysent, fp)) != NULL)
X		if (s[0] != '#')		/* not a comment */
X			break;
X	if (s == NULL)
X		return NULL;
X
X	s = rindex(sysent, '\n');
X	if (s != NULL)
X		*s = '\0';		/* trim newline */
X	sp = &sys.sy_name;		/* point at string pointers */
X	*sp++ = sysent;
X	for (s = sysent; *s != '\0'; s++)
X		if (*s == ':') {
X			*s = '\0';	/* turn colons into NULs */
X			if (sp <= &sys.sy_cmd)
X				*sp++ = s + 1;	/* point at next field */
X		}
X	for (; sp <= &sys.sy_cmd; sp++)
X		*sp = "";		/* fill remaining fields */
X	return &sys;
X}
X
Xrewsys()
X{
X	if (fp != NULL)
X		(void) fseek(fp, 0L, 0);
X}
END_OF_FILE
if test 1710 -ne `wc -c <'rnews/speed/disk/sys.c'`; then
    echo shar: \"'rnews/speed/disk/sys.c'\" unpacked with wrong size!
fi
# end of 'rnews/speed/disk/sys.c'
fi
if test -f 'rnews/test/lib/sys' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/test/lib/sys'\"
else
echo shar: Extracting \"'rnews/test/lib/sys'\" \(1751 characters\)
sed "s/^X//" >'rnews/test/lib/sys' <<'END_OF_FILE'
X# ourselves: accept everything but noise and ut.stardate from U. Texas
Xutcs:all,!ut.stardate,!net.philosophy,!net.politics,!net.religion,!net.flame,!net.bizarre,net.music.synth,!net.music,!net.audio,!net.abortion,!net.movies,!net.women,!net.sf-lovers,!net.origins
X# our news feed: send everything & locally-written articles go direct
Xutzoo:net,comp,news,sci,rec,misc,soc,talk,mod,world,na,can,ont,tor,ut,to.utzoo:F:/usr/src/cmd/news/rnews/test/newsbatch/utzoo
X# sites we feed (no outstanding requests)
X#	utfyzx gets everything we get
Xutfyzx:net,comp,news,sci,rec,misc,soc,talk,mod,world,na,can,ont,tor,ut,to.utfyzx:F:/usr/src/cmd/news/rnews/test/newsbatch/utfyzx
X#	ryesone gets everything we get.
Xryesone:net,comp,news,sci,rec,misc,soc,talk,mod,world,na,can,ont,tor,ut,to.ryesone:F:/usr/src/cmd/news/rnews/test/newsbatch/ryesone
X#	bnr-vpa gets everything we get except ut and tor
Xbnr-vpa:net,comp,news,sci,rec,misc,soc,talk,mod,world,na,can,ont,to.bnr-vpa:F:/usr/src/cmd/news/rnews/test/newsbatch/bnr-vpa
X#	utcsstat gets a few net groups and local groups
Xutcsstat:all.sources,mod.computers.sun,mod.computers.ibm-pc,net.unix-wizards,net.announce,net.math,net.physics,net.micro,net.news.config,world,can,ont,tor,ut,to.utcsstat:F:/usr/src/cmd/news/rnews/test/newsbatch/utcsstat
X#	utcsscb gets a few net groups plus local groups
Xutcsscb:net.announce,net.micro,net.unix,net.math,net.news.config,world,can,ont,tor,ut,to.utcsscb:F:/usr/src/cmd/news/rnews/test/newsbatch/utcsscb
X#	lsuc gets ont and net.news.config only.	their primary feed is mnetor.
Xlsuc:world,ont,net.news.config,to.lsuc:F:/usr/src/cmd/news/rnews/test/newsbatch/lsuc
X#	mnetor gets everything we post locally except ut
X#	utcsri gets just articles in local groups or locally-written articles
END_OF_FILE
if test 1751 -ne `wc -c <'rnews/test/lib/sys'`; then
    echo shar: \"'rnews/test/lib/sys'\" unpacked with wrong size!
fi
# end of 'rnews/test/lib/sys'
fi
if test -f 'rnews/vers/v7/gethostname.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rnews/vers/v7/gethostname.c'\"
else
echo shar: Extracting \"'rnews/vers/v7/gethostname.c'\" \(1379 characters\)
sed "s/^X//" >'rnews/vers/v7/gethostname.c' <<'END_OF_FILE'
X/*
X * v7 gethostname simulation
X *	taken from pathalias and cleaned up.  Thanks, peter.
X */
X
X#include <stdio.h>
X
X#define MAXLINE 256
X#define min(a,b) ((a) < (b)? (a): (b))
X
Xstatic char defhost[] = "INSERT-YOUR-HOST-NAME-HERE";
X
Xint
Xgethostname(hostname, size)
Xchar *hostname;
Xint size;
X{
X	char *ptr;
X	FILE *whoami;
X	char *index(), *strncpy();
X	FILE *fopen(), *popen();
X
X	*hostname = '\0';
X	/* try /etc/whoami */
X	if ((whoami = fopen("/etc/whoami", "r")) != NULL) {
X		(void) fgets(hostname, size, whoami);
X		(void) fclose(whoami);
X		if ((ptr = index(hostname, '\n')) != NULL)
X			*ptr = '\0';
X	}
X	if (*hostname != '\0')
X		return 0;
X	/* try /usr/include/whoami.h */
X	if ((whoami = fopen("/usr/include/whoami.h", "r")) != NULL) {
X		while (!feof(whoami)) {
X			char sysname[MAXLINE];
X
X			if (fgets(sysname, MAXLINE, whoami) == NULL)
X				break;
X			if (sscanf(sysname, "#define sysname \"%[^\"]\"",
X			    hostname) > 0)
X				break;
X		}
X		(void) fclose(whoami);
X		if (*hostname != '\0')
X			return 0;
X	}
X	/* ask uucp */
X	if ((whoami = popen("PATH=/bin:/usr/bin:/usr/ucb uuname -l", "r")) != NULL) {
X		(void) fgets(hostname, size, whoami);
X		(void) pclose(whoami);
X		if ((ptr = index(hostname, '\n')) != NULL)
X			*ptr = '\0';
X	}
X	if (*hostname != '\0')
X		return 0;
X	/* aw hell, i give up!  is this a real unix? */
X	(void) strncpy(hostname, defhost, min(sizeof defhost, size));
X	return 0;
X}
END_OF_FILE
if test 1379 -ne `wc -c <'rnews/vers/v7/gethostname.c'`; then
    echo shar: \"'rnews/vers/v7/gethostname.c'\" unpacked with wrong size!
fi
# end of 'rnews/vers/v7/gethostname.c'
fi
if test -f 'time/getdate.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'time/getdate.c'\"
else
echo shar: Extracting \"'time/getdate.c'\" \(1241 characters\)
sed "s/^X//" >'time/getdate.c' <<'END_OF_FILE'
X/*
X * getdate ascii_time ... - print the time_t of ascii_time(s)
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include <time.h>
X#include <sys/types.h>
X#include <sys/timeb.h>
X
X#define	DAY	(24L*60L*60L)
X
Xstruct timeb ftnow;
X
Xchar *progname;
X
Xextern int errno;
Xextern char *strcpy();
Xextern char *strncpy();
Xextern char *strcat();
Xextern char *strchr();
Xextern char *strtok();
Xextern long atol();
Xextern char *malloc();
Xextern struct tm *gmtime();
Xextern time_t time();
X
Xextern time_t getdate();
X
X/* Forwards. */
Xextern void process();
X
X/*
X - main - parse arguments and handle options
X */
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	register int c;
X	register int errflg = 0;
X	extern int optind;
X	extern char *optarg;
X
X	progname = argv[0];
X	ftime(&ftnow);
X
X	while ((c = getopt(argc, argv, "")) != EOF)
X		switch (c) {
X		case '?':
X		default:
X			errflg++;
X			break;
X		}
X	if (errflg || optind == argc) {
X		(void) fprintf(stderr, "Usage: %s ascii_time ...\n", progname);
X		exit(2);
X	}
X
X	for (; optind < argc; optind++)
X		process(argv[optind]);
X	exit(0);
X}
X
X/*
X * process - print time_t of tm
X */
Xvoid
Xprocess(tm)
Xchar *tm;
X{
X	time_t it;
X
X	it = getdate(tm, &ftnow);
X	if (it < 0)
X		error("`%s' not valid date", tm);
X	else
X		(void) printf("%ld\n", it);
X}
END_OF_FILE
if test 1241 -ne `wc -c <'time/getdate.c'`; then
    echo shar: \"'time/getdate.c'\" unpacked with wrong size!
fi
# end of 'time/getdate.c'
fi
echo shar: End of archive 4 \(of 14\).
##  End of shell archive.
exit 0
