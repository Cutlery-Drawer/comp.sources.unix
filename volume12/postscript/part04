Subject:  v12i053:  A PostScript interpreter, Part04/18
Newsgroups: comp.sources.unix
Sender: sources
Approved: rs@uunet.UU.NET

Submitted-by: Crispin Goswell <caag@vd.rl.ac.uk>
Posting-number: Volume 12, Issue 53
Archive-name: postscript/part04

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 18)."
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'postscript/fonts/Times/rest.r' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'postscript/fonts/Times/rest.r'\"
else
echo shar: Extracting \"'postscript/fonts/Times/rest.r'\" \(7361 characters\)
sed "s/^X//" >'postscript/fonts/Times/rest.r' <<'END_OF_FILE'
XCharStrings
X/Pi
X<C536
X454A
XC636
X464A
XD236
X524A
XD336
X534A
XC236
X5636
XC24A
X494A
XCF4A
X564A
X>
Xput
XMetrics
X/Pi
X[-2
X24]
Xput
XCharStrings
X/Sigma
X<C336
X4A3F
X424A
XC236
X493F
XC236
X5136
X523B
X5036
XC349
X5049
XC24A
X514A
X5245
X504A
X>
Xput
XMetrics
X/Sigma
X[0
X21]
Xput
XCharStrings
X/parenleft
X<CB30
X4932
X4735
X4539
X443E
X4442
X4547
X474B
X494E
X4B50
XC932
X4736
X4639
X453E
X4542
X4647
X474A
X494E
X>
Xput
XMetrics
X/parenleft
X[9
X14]
Xput
XCharStrings
X/parenright
X<C330
X4532
X4735
X4939
X4A3E
X4A42
X4947
X474B
X454E
X4350
XC532
X4736
X4839
X493E
X4942
X4847
X474A
X454E
X>
Xput
XMetrics
X/parenright
X[9
X14]
Xput
XCharStrings
X/Braceleft
X<CA2E
X4731
X4534
X4437
X443A
X453D
X4844
X4947
X494A
X484D
X474F
XC731
X4633
X4536
X4539
X463C
X4943
X4A46
X4A49
X494C
X474F
X4452
X>
Xput
XMetrics
X/Braceleft
X[11
X14]
Xput
XCharStrings
X/Braceright
X<C42E
X4731
X4934
X4A37
X4A3A
X493D
X4644
X4547
X454A
X464D
X474F
XC731
X4833
X4936
X4939
X483C
X4543
X4446
X4449
X454C
X474F
X4A52
X>
Xput
XMetrics
X/Braceright
X[11
X14]
Xput
XCharStrings
X/radical
X<C240
X4640
X514E
XC641
X514F
XC541
X5150
XD728
X5150
X>
Xput
XMetrics
X/radical
X[7
X23]
Xput
XCharStrings
X/integral
X<D531
X5432
X5533
X5632
X5631
X5530
X5330
X5131
X4F33
X4E35
X4D38
X4C3C
X4A48
X494C
X484E
XD032
X4F34
X4E38
X4C44
X4B48
X4A4B
X494D
X474F
X4550
X4350
X424F
X424E
X434D
X444E
X434F
X>
Xput
XMetrics
X/integral
X[4
X24]
Xput
XCharStrings
X/aleph
X<C337
X4439
X5045
X5147
X5149
XC43A
X5046
XC337
X4339
X443B
X5047
X5149
XC83E
X4442
X4344
X4346
X4448
X4349
XC344
X4548
XC442
X4444
X4546
X4548
X4349
XCB41
X503C
XCE37
X4E3A
X4F3C
X513C
X513A
X4F39
X4E37
XCE37
X4F3A
X513C
X>
Xput
XMetrics
X/aleph
X[-1
X20]
Xput
XCharStrings
X/epsilon
X<CE3C
X4C3B
X493B
X463C
X443E
X4341
X4344
X4447
X4548
X4849
X4B49
X4D48
XC93B
X473C
X453E
X4441
X4444
X4547
X4648
X4849
XC442
X4C42
X>
Xput
XMetrics
X/epsilon
X[-3
X17]
Xput
XCharStrings
X/theta
X<CB34
X4835
X4638
X453A
X443D
X4342
X4346
X4448
X4649
X4849
X4B48
X4D45
X4E43
X4F40
X503B
X5037
X4F35
X4D34
X4B34
XCB34
X4935
X4738
X463A
X453D
X4442
X4446
X4548
X4649
XC849
X4A48
X4C45
X4D43
X4E40
X4F3B
X4F37
X4E35
X4D34
XC53E
X4E3E
X>
Xput
XMetrics
X/theta
X[3
X19]
Xput
XCharStrings
X/phi
X<CE34
X4850
XCF34
X4750
XCA3B
X463C
X443E
X4341
X4344
X4446
X4648
X4949
X4C49
X5048
X5246
X5343
X5340
X523E
X503C
X4D3B
X4A3B
XCA3B
X473C
X453E
X4441
X4444
X4546
X4748
X4949
XCC49
X4F48
X5146
X5243
X5240
X513E
X4F3C
X4D3B
X>
Xput
XMetrics
X/phi
X[1
X22]
Xput
XCharStrings
X/zeta
X<CB3B
X4D3C
X4F3E
X4F3D
X4E3C
X4B3B
X483B
X453C
X443D
X433F
X4341
X4443
X4645
X4A48
XC83B
X463C
X453D
X443F
X4441
X4543
X4A48
X4B4A
X4B4C
X4A4D
X484D
X>
Xput
XMetrics
X/2187
X[-3
X18]
Xput
XCharStrings
X/weierstrass
X<C53B
X443C
X433E
X4340
X4443
X4847
X4949
XC340
X4442
X4846
X4949
X494B
X484E
X4650
X4550
X444F
X434D
X434A
X4446
X4642
X483F
X4B3C
X4D3B
X4F3B
X523C
X533E
X5342
X5246
X5048
X4E49
X4D49
X4C48
X4C46
X4D45
X4E46
X4D47
XCF3B
X513C
X523E
X5242
X5146
X5048
X>
Xput
XMetrics
X/weierstrass
X[-3
X22]
Xput
XCharStrings
X/Doublebar
X<C430
X4450
XCA30
X4A50
X>
Xput
XMetrics
X/Doublebar
X[9
X14]
Xput
XCharStrings
X/plusminus
X<CC38
X4C49
XC440
X5440
XC449
X5449
X>
Xput
XMetrics
X/plusminus
X[-4
X24]
Xput
XCharStrings
X/Minusplus
X<CC38
X4C49
XC438
X5438
XC440
X5440
X>
Xput
XMetrics
X/Minusplus
X[-4
X24]
Xput
XCharStrings
X/multiply
X<C439
X5247
XD239
X4447
X>
Xput
XMetrics
X/multiply
X[-4
X22]
Xput
XCharStrings
X/dotmath
X<C53F
X4440
X4541
X4640
X453F
X>
Xput
XMetrics
X/dotmath
X[-4
X10]
Xput
XCharStrings
X/divide
X<CD37
X4C38
X4D39
X4E38
X4D37
XC440
X5640
XCD47
X4C48
X4D49
X4E48
X4D47
X>
Xput
XMetrics
X/divide
X[-4
X26]
Xput
XCharStrings
X/notequal
X<D437
X4649
XC43D
X563D
XC443
X5643
X>
Xput
XMetrics
X/notequal
X[-4
X26]
Xput
XCharStrings
X/equivalence
X<C43B
X563B
XC440
X5640
XC445
X5645
X>
Xput
XMetrics
X/equivalence
X[-4
X26]
Xput
XCharStrings
X/lessequal
X<D434
X443B
X5442
XC444
X5444
XC449
X5449
X>
Xput
XMetrics
X/lessequal
X[0
X24]
Xput
XCharStrings
X/greaterequal
X<C434
X543B
X4442
XC444
X5444
XC449
X5449
X>
Xput
XMetrics
X/greaterequal
X[0
X24]
Xput
XCharStrings
X/proportional
X<D545
X5345
X5144
X4F42
X4C3E
X4B3D
X493C
X473C
X453D
X443F
X4441
X4543
X4744
X4944
X4B43
X4C42
X4F3E
X513C
X533B
X553B
X>
Xput
XMetrics
X/proportional
X[-4
X25]
Xput
XCharStrings
X/similar
X<C343
X4341
X443E
X463D
X483D
X4A3E
X4E41
X5042
X5242
X5441
X553F
XC341
X443F
X463E
X483E
X4A3F
X4E42
X5043
X5243
X5442
X553F
X553D
X>
Xput
XMetrics
X/similar
X[-3
X24]
Xput
XCharStrings
X/acute
X<C834
X433A
XC834
X4935
X433A
X>
Xput
XMetrics
X/acute
X[6
X12]
Xput
XCharStrings
X/grave
X<C434
X493A
XC434
X4335
X493A
X>
Xput
XMetrics
X/grave
X[6
X12]
Xput
XCharStrings
X/caron
X<C334
X4436
X4638
X4939
X4B39
X4E38
X5036
X5134
XC334
X4437
X4639
X493A
X4B3A
X4E39
X5037
X5134
X>
Xput
XMetrics
X/caron
X[2
X20]
Xput
XCharStrings
X/Quoteleft
X<C536
X4635
X4534
X4435
X4437
X4539
X463A
X>
Xput
XMetrics
X/Quoteleft
X[7
X10]
Xput
XCharStrings
X/Quoteright
X<C434
X4535
X4637
X4639
X453A
X4439
X4538
X>
Xput
XMetrics
X/Quoteright
X[7
X10]
Xput
XCharStrings
X/radical
X<C33B
X473B
X4D47
XC63B
X4D49
XD630
X4D49
X>
Xput
XMetrics
X/radical
X[3
X22]
Xput
XCharStrings
X/propersubset
X<D438
X4D38
X4939
X473A
X453C
X443F
X4441
X4544
X4746
X4947
X4D48
X5448
X>
Xput
XMetrics
X/propersubset
X[-4
X24]
Xput
XCharStrings
X/union
X<C438
X443F
X4543
X4645
X4847
X4B48
X4D48
X5047
X5245
X5343
X543F
X5438
X>
Xput
XMetrics
X/union
X[-4
X24]
Xput
XCharStrings
X/propersuperset
X<C438
X4B38
X4F39
X513A
X533C
X543F
X5441
X5344
X5146
X4F47
X4B48
X4448
X>
Xput
XMetrics
X/propersuperset
X[-4
X24]
Xput
XCharStrings
X/intersection
X<C448
X4441
X453D
X463B
X4839
X4B38
X4D38
X5039
X523B
X533D
X5441
X5448
X>
Xput
XMetrics
X/intersection
X[-4
X24]
Xput
XCharStrings
X/element
X<D438
X4D38
X4939
X473A
X453C
X443F
X4441
X4544
X4746
X4947
X4D48
X5448
XC440
X5040
X>
Xput
XMetrics
X/element
X[-4
X24]
Xput
XCharStrings
X/arrowright
X<D33E
X5640
X5342
XD03B
X5540
X5045
XC440
X5540
X>
Xput
XMetrics
X/arrowright
X[-4
X26]
Xput
XCharStrings
X/arrowup
X<C63A
X4837
X4A3A
XC33D
X4838
X4D3D
XC838
X4849
X>
Xput
XMetrics
X/arrowup
X[1
X16]
Xput
XCharStrings
X/arrowleft
X<C73E
X4440
X4742
XCA3B
X4540
X4A45
XC540
X5640
X>
Xput
XMetrics
X/arrowleft
X[-4
X26]
Xput
XCharStrings
X/arrowdown
X<C646
X4849
X4A46
XC343
X4848
X4D43
XC837
X4848
X>
Xput
XMetrics
X/arrowdown
X[1
X16]
Xput
XCharStrings
X/partialdiff
X<CF40
X4E3D
X4D3C
X4B3B
X493B
X463C
X443F
X4342
X4345
X4447
X4548
X4749
X4949
X4C48
X4E46
X4F43
X503E
X5039
X4F36
X4E35
X4C34
X4934
X4735
X4636
X4637
X4737
X4736
XC93B
X473C
X453F
X4442
X4446
X4548
XC949
X4B48
X4D46
X4E43
X4F3E
X4F39
X4E36
X4C34
X>
Xput
XMetrics
X/partialdiff
X[3
X19]
Xput
XCharStrings
X/gradient
X<C234
X4A49
XC334
X4A47
XD234
X4A49
XC234
X5234
XC335
X5135
X>
Xput
XMetrics
X/gradient
X[2
X20]
Xput
XCharStrings
X/Radical1
X<C33B
X483B
X5147
XC73C
X5149
XE128
X5149
X>
Xput
XMetrics
X/Radical1
X[7
X33]
Xput
XCharStrings
X/integral
X<D531
X5432
X5533
X5632
X5631
X5530
X5330
X5131
X4F33
X4E35
X4D38
X4C3C
X4A48
X494C
X484E
XD032
X4F34
X4E38
X4C44
X4B48
X4A4B
X494D
X474F
X4550
X4350
X424F
X424E
X434D
X444E
X434F
X>
Xput
XMetrics
X/integral
X[4
X24]
Xput
XCharStrings
X/florin
X<D531
X5432
X5533
X5632
X5631
X5530
X5330
X5131
X4F33
X4E35
X4D38
X4C3C
X4A48
X494C
X484E
XD032
X4F34
X4E38
X4C44
X4B48
X4A4B
X494D
X474F
X4550
X4350
X424F
X424E
X434D
X444E
X434F
XCB39
X483A
X463C
X453F
X4541
X4644
X4846
X4B47
X4D47
X5046
X5244
X5341
X533F
X523C
X503A
X4D39
X4B39
X>
Xput
XMetrics
X/florin
X[4
X24]
Xput
XCharStrings
X/infinity
X<D641
X5543
X5344
X5144
X4F43
X4E42
X4B3E
X4A3D
X483C
X463C
X443D
X433F
X4341
X4443
X4644
X4844
X4A43
X4B42
X4E3E
X4F3D
X513C
X533C
X553D
X563F
X5641
X>
Xput
XMetrics
X/infinity
X[-3
X25]
Xput
XCharStrings
X/section
X<CB37
X4A38
X4B39
X4C38
X4C37
X4B35
X4934
X4734
X4535
X4437
X4439
X453B
X473D
X4C40
XC53B
X4A3E
X4C40
X4D42
X4D44
X4C46
X4A48
XC63C
X443E
X4340
X4342
X4444
X4646
X4B49
XC444
X4947
X4B49
X4C4B
X4C4D
X4B4F
X4950
X4750
X454F
X444D
X444C
X454B
X464C
X454D
X>
Xput
XMetrics
X/section
X[4
X16]
Xput
XCharStrings
X/dagger
X<C834
X4736
X4838
X4936
X4834
XC834
X4850
XC83F
X4742
X4850
X4942
X483F
XC23B
X443C
X463B
X443A
X423B
XC23B
X4E3B
XCA3B
X4C3C
X4E3B
X4C3A
X4A3B
X>
Xput
XMetrics
X/dagger
X[4
X16]
Xput
XCharStrings
X/daggerdbl
X<C834
X4736
X4838
X4936
X4834
XC834
X4842
XC83E
X4740
X4944
X4846
X4744
X4940
X483E
XC842
X4850
XC84C
X474E
X4850
X494E
X484C
XC23B
X443C
X463B
X443A
X423B
XC23B
X4E3B
XCA3B
X4C3C
X4E3B
X4C3A
X4A3B
XC249
X444A
X4649
X4448
X4249
XC249
X4E49
XCA49
X4C4A
X4E49
X4C48
X4A49
X>
Xput
XMetrics
X/daggerdbl
X[4
X16]
Xput
XCharStrings
X/existential
X<CF34
X4F49
XC234
X4F34
XC73E
X4F3E
XC249
X4F49
X>
Xput
XMetrics
X/existential
X[3
X19]
Xput
END_OF_FILE
if test 7361 -ne `wc -c <'postscript/fonts/Times/rest.r'`; then
    echo shar: \"'postscript/fonts/Times/rest.r'\" unpacked with wrong size!
fi
# end of 'postscript/fonts/Times/rest.r'
fi
if test -f 'source/adapter.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/adapter.c'\"
else
echo shar: Extracting \"'source/adapter.c'\" \(7459 characters\)
sed "s/^X//" >'source/adapter.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X#include "graphics.h"
X#include <stdio.h>
X
X#include "protocol.h"
X
Xstruct hardware
X {
X 	struct hardware *next;
X 	int serial;
X 	int width, height, iswin;
X };
X
Xstatic struct hardware *alloc_hard ();
Xchar *malloc ();
Xvoid send_hardware ();
Xstatic void GetTransferSize ();
X
Xstatic int transfer_size;
X
Xstruct hardware *InitHardware ()
X {
X 	int width, height;
X 	
X 	master_protocol ();
X 	Message ("InitHardware");
X 	
X 	width = recv_short (); height = recv_short ();
X 	GetTransferSize ();
X 	return alloc_hard (width, height, TRUE);
X }
X
Xstatic void GetTransferSize ()
X {
X 	send_byte (GET_TRANSFERSIZE);
X 	flush_protocol ();
X	transfer_size = recv_short ();
X }
X
Xint TransferSize ()
X {
X 	return transfer_size;
X }
X
Xvoid SetTransfer (tran) float *tran;
X {
X	int i;
X	
X	send_byte (SET_TRANSFER);
X	for (i = 0; i < transfer_size; i++)
X		send_small (tran [i]);
X }
X
Xint ScreenSize (freq, rot) float freq, rot;
X {
X 	send_byte (SCREEN_SIZE);
X 	send_float (freq);
X 	send_float (rot);
X 	flush_protocol ();
X 	
X 	return recv_short ();
X }
X
Xvoid BuildScreen (freq, rotation, x, y) float freq, rotation, *x, *y;
X {
X 	int i, size;
X 	
X 	send_byte (BUILD_SCREEN);
X 	send_float (freq);
X 	send_float (rotation);
X 	flush_protocol ();
X 	size = recv_short ();
X 	
X 	for (i = 0; i < size; i++)
X 	 {
X 		x[i] = recv_small ();
X 		y[i] = recv_small ();
X 	 }
X }
X
Xvoid SetScreen (freq, rotation, thresh) float freq, rotation, *thresh;
X {
X 	int i, size = ScreenSize (freq, rotation);
X 	send_byte (SET_SCREEN);
X 	send_float (freq);
X 	send_float (rotation);
X 	
X 	for (i = 0; i < size; i++)
X 		send_small (thresh [i]);
X }
X
Xstruct hardware *NewWindowHardware (width, height) int width, height;
X {
X 	struct hardware *res = alloc_hard (width, height, TRUE);
X	Message ("NewWindowHardware");
X	send_byte (NEW_WINDOW);
X	send_hardware (res);
X	send_short (width);
X	send_short (height);
X	
X	return res;
X }
X
Xstruct hardware *NewBitmapHardware (width, height) int width, height;
X {
X 	struct hardware *res = alloc_hard (width, height, FALSE);
X 	
X 	Message ("NewBitmapHardware");
X 	send_byte (NEW_BITMAP);
X 	send_hardware (res);
X 	send_short (width);
X 	send_short (height);
X 	
X 	return res;
X }
X
Xint IsWindowHardware (h) struct hardware *h;
X {
X 	if (h == NULL)
X 		return TRUE;
X 	return h->iswin;
X }
X
Xvoid DestroyHardware (h) struct hardware *h;
X {
X	if (h == NULL)
X		return;
X	Message ("DestroyHardware");
X	send_byte (DESTROY_HARDWARE);
X	send_hardware (h);
X	free_hard (h);
X }
X
Xvoid BitBlt (from, to, fromPoint, toPoint, ex, rop)
X	struct hardware *from, *to;
X	DevicePoint fromPoint, toPoint, ex;
X	int rop;
X {
X 	if (to == NULL)
X 		return;
X 	Message ("BitBlt");
X 	send_byte (BITBLT);
X 	send_hardware (from);
X 	send_hardware (to);
X 	send_point (fromPoint);
X 	send_point (toPoint);
X 	send_point (ex);
X 	send_byte (rop);
X }
X
Xvoid Paint (from, to, fromPoint, toPoint, ex, colour)
X	struct hardware *from, *to;
X	DevicePoint fromPoint, toPoint, ex;
X	Colour colour;
X {
X 	if (to == NULL)
X 		return;
X 	Message ("Paint");
X 	send_byte (PAINT);
X 	send_hardware (from);
X 	send_hardware (to);
X 	send_point (fromPoint);
X 	send_point (toPoint);
X 	send_point (ex);
X 	send_colour (colour);
X }
X
XMatrix DeviceMatrix (width, height) int width, height;
X {
X 	Matrix m;
X 	
X 	Message ("DeviceMatrix");
X 	send_byte (GET_MATRIX);
X 	send_short (width);
X 	send_short (height);
X 	flush_protocol ();
X 	m.A = recv_float ();
X 	m.B = recv_float ();
X 	m.C = recv_float ();
X 	m.D = recv_float ();
X 	m.tx = recv_float ();
X 	m.ty = recv_float ();
X 	
X 	return m;
X }
X
XDevicePoint HardwareExtent (h) struct hardware *h;
X {
X	return h == NULL ? NewDevicePoint (0, 0) : NewDevicePoint (h->width, h->height);
X }
X
Xstruct hardware *HardwareFromString (s, width, height) unsigned char *s; int width, height;
X {
X	struct hardware *res = alloc_hard (width, height, FALSE);
X	
X	Message ("HardwareFromString");
X	send_byte (SEND_BITMAP);
X	send_hardware (res);
X 	send_short (res->width);
X 	send_short (res->height);
X	send_string (s, hard_size (res));
X	
X	return res;
X }
X
Xchar *StringFromHardware (h) struct hardware *h;
X {
X  	unsigned len = hard_size (h);
X  	char *s;
X  	
X  	Message ("StringFromHardware");
X	send_byte (GET_BITMAP);
X 	send_hardware (h);
X 	flush_protocol ();
X 	recv_string ((s = malloc (len)), len);
X 	
X 	return s;
X }
X
Xvoid Line (h, fromPoint, toPoint, rop)
X	struct hardware *h;
X	DevicePoint fromPoint, toPoint;
X	int rop;
X {
X 	if (h == NULL)
X 		return;
X 	Message ("Line");
X 	send_byte (LINE);
X 	send_hardware (h);
X 	send_point (fromPoint);
X 	send_point (toPoint);
X 	send_byte (rop);
X }
X
Xvoid PaintLine (h, fromPoint, toPoint, colour)
X	struct hardware *h;
X	DevicePoint fromPoint, toPoint;
X	Colour colour;
X {
X 	if (h == NULL)
X 		return;
X 	Message ("PaintLine");
X 	send_byte (PAINT_LINE);
X 	send_hardware (h);
X 	send_point (fromPoint);
X 	send_point (toPoint);
X 	send_colour (colour);
X }
X
Xstatic struct hardware *FreeList = NULL;
Xstatic int next_serial = 1;
X
Xstatic struct hardware *alloc_hard (width, height, iswin) int width, height, iswin;
X {
X 	struct hardware *res;
X 	
X 	if (FreeList == NULL)
X 	 {
X 		res = (struct hardware *) malloc (sizeof (struct hardware));
X 		res->serial = next_serial++;
X 	 }
X 	else
X 	 {
X 	 	res = FreeList;
X 	 	FreeList = FreeList->next;
X 	 }
X 	res->width = width;
X 	res->height = height;
X 	res->iswin = iswin;
X 	
X 	return res;
X }
X
Xfree_hard (h) struct hardware *h;
X {
X 	if (h == NULL)
X 		return;
X 	h->next = FreeList;
X 	FreeList = h;
X }
X
Xint size (width, height) int width, height;
X {
X 	return (width + 7) / 8 * height;
X }
X
Xint hard_size (h) struct hardware *h;
X {
X 	if (h == NULL)
X 		return 0;
X 	return size (h->width, h->height);
X }
X	
Xvoid send_hardware (h) struct hardware *h;
X {
X	send_short (h == NULL ? 0 : h->serial);
X }
X
Xvoid HardUpdate ()
X {
X	send_byte (HARD_FLUSH);
X 	flush_protocol ();
X }
X
Xvoid UpdateControl (h, flag) struct hardware *h; int flag;
X {
X 	send_byte (SET_UPDATE_CONTROL);
X 	send_hardware (h);
X 	send_byte (flag);
X }
X
Xvoid SetClipHardware (h, clip) struct hardware *h, *clip;
X {
X 	send_byte (SET_CLIP_HARDWARE);
X 	send_hardware (h);
X 	send_hardware (clip);
X }
X
Xvoid PaintTrapezoid (to, lefttop, leftbottom, righttop, rightbottom, top, bottom, colour)
X	struct hardware *to;
X	DevicePoint lefttop, leftbottom, righttop, rightbottom;
X	int top, bottom;
X	Colour colour;
X {
X 	if (to == NULL)
X 		return;
X 	Message ("PaintTrapezoid");
X 	send_byte (PAINT_TRAPEZOID);
X 	send_hardware (to);
X 	send_point (lefttop);
X 	send_point (leftbottom);
X 	send_point (righttop);
X 	send_point (rightbottom);
X 	send_short (top);
X 	send_short (bottom);
X 	send_colour (colour);
X }
X
Xvoid BitBltTrapezoid (to, lefttop, leftbottom, righttop, rightbottom, top, bottom, rop)
X	struct hardware *to;
X	DevicePoint lefttop, leftbottom, righttop, rightbottom;
X	int top, bottom, rop;
X {
X 	if (to == NULL)
X 		return;
X 	Message ("BitBltTrapezoid");
X 	send_byte (BITBLT_TRAPEZOID);
X 	send_hardware (to);
X 	send_point (lefttop);
X 	send_point (leftbottom);
X 	send_point (righttop);
X 	send_point (rightbottom);
X 	send_short (top);
X 	send_short (bottom);
X 	send_byte (rop);
X }
END_OF_FILE
if test 7459 -ne `wc -c <'source/adapter.c'`; then
    echo shar: \"'source/adapter.c'\" unpacked with wrong size!
fi
# end of 'source/adapter.c'
fi
if test -f 'source/control.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/control.c'\"
else
echo shar: Extracting \"'source/control.c'\" \(6608 characters\)
sed "s/^X//" >'source/control.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include <signal.h>
X#include "main.h"
X
X/*
X * This file implements the flow control operators of PostScript
X *
X * All operations are implemented using the ExecStack and without recursion.
X * This is to allow error recovery to operate cleanly.
X *
X * Actual control is acheived by stacking continuation operators for the looping
X * operators, declared thus:
X *
X */
X
Xstatic Object OpLoop, OpRepeat, OpStopped;
X
X/*
X * "loop", for example, stacks the following:
X *	proc
X *	OpLoop
X *	proc
X *	Nil
X *
X * OpLoop is the continuer, proc is the body code, passed as a parameter.
X *
X * Nil is placed at the bottom by each of the looping constructs, which are 'exit'able.
X * "exit" pops the exec stack until it encounters a Nil.
X *
X * A Marker is placed on the ExecStack to enclose a Stopped context.
X * A File is placed on the ExecStack to enclose a Run context.
X * A Nil is placed on the ExecStack to enclose a Looping construct.
X * "stop" will unwind the stack down to the Marker, ignoring any Nil or File it might find.
X * "exit" will baulk if it finds a Marker or File before a Nil.
X *
X */
X
Xstatic int PExec (), PIf (), PIfElse (), PRepeat (), PFor (), PLoop ();
Xstatic int PExit (), PCountExecStack ();
Xstatic int PQuit (), PStart ();	
Xint PStop (), PStopped ();
Xstatic int Repeat (), Loop (), Stopped ();
X
XInitControl ()
X {
X 	OpRepeat 	= MakeOp ("(repeat)",	Repeat,	0, 0, 3, 2);
X 	OpLoop	 	= MakeOp ("(loop)",	Loop,	0, 0, 1, 2);
X 	OpStopped	= MakeOp ("(stopped)",	Stopped,0, 1, 1, 0);
X 	
X	InstallOp ("exec",	PExec,		1, 1, 0, 1, Poly);
X  	InstallOp ("if",	PIf,		2, 0, 0, 1, Boolean, Array);
X 	InstallOp ("ifelse",	PIfElse,	3, 0, 0, 1, Boolean, Array, Array);
X 	InstallOp ("repeat",	PRepeat,	2, 0, 0, 4, Integer, Array);
X	InstallOp ("for",	PFor,		4, 0, 0, 6, Poly, Poly, Poly, Array);
X 	InstallOp ("loop",	PLoop,		1, 0, 0, 4, Array);
X	InstallOp ("exit",	PExit,		0, 0, 0, 0);
X 	InstallOp ("stop",	PStop,		0, 1, 0, 0);
X 	InstallOp ("stopped",	PStopped,	1, 1, 0, 3, Array);
X 	InstallOp ("quit",	PQuit, 		0, 0, 0, 0);
X 	InstallOp ("start",	PStart, 	0, 0, 0, 0);
X 	InstallOp ("countexecstack",
X 				PCountExecStack,0, 1, 0, 0);
X }
X
Xstatic int PExec (item) Object item;
X {
X	VOID Push (OpStack, item);
X	if (xCheck (item))
X	 {
X 		Object fn;
X 		
X		fn = Lookup (TypeOf (item), Self);
X		if (TypeOf (fn) != Condition)
X			VOID Push (ExecStack, fn);
X	 }
X	return TRUE;
X }
X
Xstatic int PIf (bool, proc) Object bool, proc;
X {
X	if (!xCheck (proc))
X		return Error (PTypeCheck);
X	if (BodyBoolean (bool))
X		VOID Push (ExecStack, proc);
X	return TRUE;
X }
X
Xstatic int PIfElse (bool, proc1, proc2) Object bool, proc1, proc2;
X {
X	if (!xCheck (proc1) || !xCheck (proc2))
X	 	return Error (PTypeCheck);
X	VOID Push (ExecStack, BodyBoolean (bool) ? proc1 : proc2);
X	return TRUE;
X }
X
Xstatic int PRepeat (count, proc) Object count, proc;
X {
X	if (!xCheck (proc))
X		return Error (PTypeCheck);
X	else if (BodyInteger (count) < 0)
X		return Error (PRangeCheck);
X	
X	VOID Push (ExecStack, Nil);
X	VOID Push (ExecStack, proc);
X	VOID Push (ExecStack, count);
X	VOID Push (ExecStack, OpRepeat);
X	
X	return TRUE;
X }
X
Xstatic int Repeat ()
X {
X 	int count;
X
X	count = BodyInteger (Pop (ExecStack));
X 	
X 	if (count != 0)
X 	 {
X 	 	Object proc;
X 	 	
X 	 	proc = Top (ExecStack);
X 	 	VOID Push (ExecStack, MakeInteger (count - 1));
X 	 	VOID Push (ExecStack, OpRepeat);
X 	 	VOID Push (ExecStack, proc);
X 	 }
X 	else
X 	 {
X 		VOID Pop (ExecStack);
X 		VOID Pop (ExecStack);
X 	 }
X	return TRUE;
X }
X
Xstatic int PFor (initial, increment, limit, proc) Object initial, increment, limit, proc;
X {
X 	int integers = 0, reals = 0, res;
X 	
X 	if (!xCheck (proc))
X 		return Error (PTypeCheck);
X	
X 	if (TypeOf (initial) == Integer || TypeOf (initial) == Real)
X 		integers += TypeOf (initial) == Integer,
X 		reals += TypeOf (initial) == Real;
X 	
X 	if (TypeOf (increment) == Integer || TypeOf (increment) == Real)
X 		integers += TypeOf (increment) == Integer,
X 		reals += TypeOf (increment) == Real;
X 	
X 	if (TypeOf (limit) == Integer || TypeOf (limit) == Real)
X 		integers += TypeOf (limit) == Integer,
X 		reals += TypeOf (limit) == Real;
X 		
X 	if (integers + reals == 3 && integers != 3 && reals != 3)
X 	 {
X 	 	if (TypeOf (initial) == Integer)
X 	 		initial = RealInteger (initial);
X 	 	if (TypeOf (increment) == Integer)
X 	 		increment = RealInteger (increment);
X 	 	if (TypeOf (limit) == Integer)
X 	 		limit = RealInteger (limit);
X 	 }
X 	if (res = Apply (TypeOf (initial)))
X 	 {
X  		VOID Push (OpStack, initial);
X 	 	VOID Push (OpStack, increment);
X 		VOID Push (OpStack, limit);
X		VOID Push (OpStack, proc);
X	 }
X 	return res;
X }
X 
Xstatic int PLoop (proc) Object proc;
X {
X 	if (!xCheck (proc))
X 		return Error (PTypeCheck);
X	
X 	VOID Push (ExecStack, Nil);
X	VOID Push (ExecStack, proc);
X	VOID Push (ExecStack, OpLoop);
X	VOID Push (ExecStack, proc);
X	
X	return TRUE;
X }
X
Xstatic int Loop ()	 /* proc --- */
X {
X 	Object proc;
X 	
X 	proc = Top (ExecStack);
X	VOID Push (ExecStack, OpLoop);
X	VOID Push (ExecStack, proc);
X	return TRUE;
X }
X
Xstatic int PExit ()
X {
X 	int n, m, p;
X 	
X 	if ((n = CountTo (Null, ExecStack)) < 0
X 			|| (m = CountTo (Mark, ExecStack)) >= 0 && m < n	/* don't cross Stopped Context */
X 			|| (p = CountTo (File, ExecStack)) >= 0 && p < n)	/* don't cross Run context */
X 		return Error (PInvExit);
X 	VOID ClearTo (Null, ExecStack);
X 	return TRUE;
X }
X
Xint PStop ()	/* --- */
X {
X 	Object item;
X 	
X 	for (;;)
X 	 {
X 		if (Height (ExecStack) == 0)
X 		 {
X 		 	if (interactive)
X 				return Push (ExecStack, Cvx (NameFrom ("executive")));
X 			else
X 				return TRUE;
X 		 }
X 		item = Pop (ExecStack);
X 		if (item.type == Mark)
X 		 	return Push (OpStack, True);
X 	 }
X }
X
Xstatic int Stopped ()
X {
X	VOID Pop (ExecStack);
X	VOID Push (OpStack, False);
X	return TRUE;
X }
X
Xint PStopped (proc) Object proc;
X {
X	VOID Push (ExecStack, Marker);
X	VOID Push (ExecStack, OpStopped);
X	VOID Push (ExecStack, proc);
X	return TRUE;
X }
X
Xstatic int PCountExecStack ()
X {
X	VOID Push (OpStack, MakeInteger (Height (ExecStack)));
X	return TRUE;
X }
X
X/*
X * PExecStack ()
X *
X * This routine is in stack.c
X *
X */
X
Xstatic int PQuit ()
X {
X 	Cleanup ();
X	exit (0);
X	
X	return TRUE; /* never will */
X }
X
Xstatic int PStart ()
X {
X 	return TRUE;
X }
END_OF_FILE
if test 6608 -ne `wc -c <'source/control.c'`; then
    echo shar: \"'source/control.c'\" unpacked with wrong size!
fi
# end of 'source/control.c'
fi
if test -f 'source/orion.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/orion.c'\"
else
echo shar: Extracting \"'source/orion.c'\" \(6758 characters\)
sed "s/^X//" >'source/orion.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include <graphics/grafix.h>
X#include <graphics/window.h>
X#include <stdio.h>
X
X#include "orion.h"
X
Xint rop_map [16];
X
Xstruct hardware
X {
X	WindowPtr win;
X	BitMapPtr bm;
X };
X
Xstatic int VirtualCol [256], nVirtual, transfer [256], bi_level [256];
X
Xstatic void InitRopMap (), InitVirtualColours ();
Xstatic struct hardware *NewHardware ();
X
Xchar *malloc (), *getenv (), *strcpy (), *strcat ();
X
Xstruct hardware *InitHardware ()
X {
X	InitGraf ();
X	
X	InitVirtualColours ();
X	InitRopMap ();
X	
X	return NewWindowHardware (1, 1);
X }
X
Xstruct hardware *NewBitmapHardware (w, h) int w, h;
X {
X 	BitMapPtr res = (BitMapPtr) malloc (sizeof (BitMap));
X 	
X 	*res = NewRBitMap (w, h, 1);
X	return NewHardware ((WindowPtr) NULL, res);
X }
X
Xstruct hardware *NewWindowHardware (w, h) int w, h;
X {
X	Rect r;
X	WindowPtr win;
X	
X	SetRect (&r, 0, 25, w, h);
X	win = NewWindow (NIL, r, "PostScript", VISIBLE, documentProc, FRONT, NOGOAWAY, 0, 7);
X	
X	return NewHardware (win, &win->port.portBits);
X }
X
Xint IsWindowHardware (h) struct hardware *h;
X {
X	return h->win != (WindowPtr) NULL;
X }
X
Xvoid DestroyHardware (dev) struct hardware *dev;
X {
X	if (dev->win != (WindowPtr) NULL)
X		/* DisposeWindow (dev->win) ? */;
X	else
X		DisposeRBitMap (dev->bm);
X	Free ((char *) dev);
X }
X
Xstatic void InitRopMap ()
X {
X	rop_map [ROP_FALSE]	= R_ZERO;			/*  0 0000 */
X	rop_map [ROP_AND] 	= R_AND;			/* 11 1011 */
X	rop_map [ROP_ANDNOT]	= R_SOURCE_AND_NOT_DEST;	/*  8 1000 */
X	rop_map [ROP_SOURCE] 	= R_SOURCE;			/*  5 0101 */
X	rop_map [ROP_NOTAND] 	= R_NOT_SOURCE_AND_DEST;	/*  7 0111 */
X	rop_map [ROP_DEST]	= R_DEST;			/*  3 0011 */
X	rop_map [ROP_XOR] 	= R_XOR;			/*  9 1001 */
X	rop_map [ROP_OR] 	= R_OR;				/* 15 1111 */
X	rop_map [ROP_NOR]	= R_NOR;			/*  6 0110 */
X	rop_map [ROP_NXOR] 	= R_XNOR;			/* 12 1100 */
X	rop_map [ROP_NOTDEST]	= R_NOT_DEST;			/*  2 0010 */
X	rop_map [ROP_ORNOT]	= R_SOURCE_OR_NOT_DEST;		/* 14 1110 */
X	rop_map [ROP_NOTSOURCE]	= R_NOT_SOURCE;			/*  4 0100 */
X	rop_map [ROP_NOTOR] 	= R_NOT_SOURCE_OR_DEST;		/* 13 1101 */
X	rop_map [ROP_NAND]	= R_NAND;			/* 10 1010 */
X	rop_map [ROP_TRUE]	= R_ONE;			/*  1 0001 */
X }
X
Xstatic ColMap default_cm = {
X	0, srcCopy,
X	0, srcCopy,
X	0, srcCopy,
X	0, srcCopy,
X	0, srcCopy,
X	0, srcCopy,
X	0, srcCopy,
X	0, srcCopy
X};
X
XSCM (col, mode, from, to)
X	int col, mode;
X	ColMap *from, *to;
X {
X	int i, imode = InverseMode (mode);
X
X	for (i = 0; i < 8; i++)
X	 {
X		to->colMapEnt[i].plane = 0;
X		to->colMapEnt[i].mode = (col & (1 << i)) ? mode : imode;
X	 }
X }
X
XUpdateHardware (h, r) struct hardware *h; Rect r;
X {
X	if (IsWindowHardware (h))
X	 {
X		AddUpdate (h->win, r, 0xff);
X		UpdateWindow (h->win);
X	 }
X }
X
XPrintRect (r) Rect r;
X {
X	fprintf (stderr, "[(%d, %d) (%d, %d)]\n", left (r), top (r), width (r), height (r));
X }
X
XSR (r, l, t, w, h) Rect *r; int l, t, w, h;
X {
X	left (*r) = l;
X	top (*r) = t;
X	width (*r) = w;
X	height (*r) = h;
X }
X
Xvoid BitBlt (from, to, fromPoint, toPoint, ex, rop, colour)
X	struct hardware *from, *to;
X	DevicePoint fromPoint, toPoint, ex;
X	int rop;
X	Colour colour;
X {
X 	Rect sr, dr;
X 	int col = HardColour (colour, (IsWindowHardware (to) ? transfer : bi_level));
X 	ColMap cm;
X 	
X 	if (to->bm == NULL)
X 		return;
X 	SR (&sr, fromPoint.dx, fromPoint.dy, ex.dx, ex.dy);
X 	SR (&dr, toPoint.dx, toPoint.dy, ex.dx, ex.dy);
X 	SCM (col, rop_map [rop], &default_cm, &cm);
X 	MapPlanes (from->bm, to->bm, &sr, &dr, &cm.colMapEnt[0]);
X	UpdateHardware (to, dr);
X }
X
XMapPlanes (sb, db, sr, dr, cm)
X	BitMapPtr sb, db;
X	Rect *sr, *dr;
X	CMEPtr cm;
X {
X	int i;
X	BitMap sbm, dbm;
X	sbm = *sb; dbm = *db;
X	sbm.nPlanes = 1; dbm.nPlanes = 1;
X	
X	for (i = 0; i < db->nPlanes; i++)
X	 {
X	 	sbm.baseAddr = sbm.baseAddr + sbm.planeSize * (7 - cm[i].plane);
X	 	CopyBits (&sbm, &dbm, *sr, *dr, cm[7 - i].mode);
X	 	dbm.baseAddr += dbm.planeSize;
X	 }
X }
X
X/*ARGSUSED*/
XMatrix DeviceMatrix (w, h) int w, h;
X {
X	return NewMatrix (PIXELS_PER_INCH / 72.0, 0.0, 0.0, -PIXELS_PER_INCH / 72.0, 0.0, (float) h);
X }
X
XDevicePoint HardwareExtent (h) struct hardware *h;
X {
X	return NewDevicePoint (width (h->bm->bounds), height (h->bm->bounds));
X }
X
Xstatic struct hardware *NewHardware (win, bm) WindowPtr win; BitMapPtr bm;
X {
X 	struct hardware *res = (struct hardware *) malloc (sizeof (struct hardware));
X 	
X 	res->win = win;
X 	res->bm = bm;
X 	
X 	return res;
X }
X
Xstatic int HardColour (colour, transfer) Colour colour; int *transfer;
X {
X	return VirtualCol [transfer [(int) ((nVirtual - 1) * colour.brightness + 0.5)]];
X }
X
Xint TransferSize ()
X {
X 	return nVirtual;
X }
X
Xvoid SetTransfer (tran) float *tran;
X {
X	int i;
X
X	for (i = 0; i < nVirtual; i++)
X		transfer [i] = (nVirtual - 1) * tran[i] + .5;
X }
X
Xstatic void InitVirtualColours ()
X {
X	int i = 0, from, to, j;
X	char name [BUFSIZ];
X	FILE *fp;
X	
X	(void) strcpy (name, getenv ("HOME"));
X	(void) strcat (name, "/.pscolourmap");
X	
X	PanicIf (((fp = fopen (name, "r")) == NULL && (fp = fopen ("/etc/.pscolourmap", "r")) == NULL),
X		".pscolourmap not found");
X	
X	while (fscanf (fp, "%d %d\n", &from, &to) == 2)
X		for (j = from; j <= to; j++)
X			VirtualCol [i++] = j;
X	fclose (fp);
X	nVirtual = i;
X	
X	for (i = 0; i < nVirtual; i++)
X	 {
X	 	int b = 250 * (float) i / nVirtual + 0.5;
X	 	
X	 	SetCLTE (VirtualCol [i], b, b, b);
X	 }
X	
X	for (i = 0; i < nVirtual; i++)
X	 {
X		transfer [i] = i;
X		bi_level [i] = (i < nVirtual / 2) ? 0 : nVirtual - 1;
X	 }
X }
X
Xstruct hardware *HardwareFromString (s, w, h) char *s; int w, h;
X {
X 	char *to;
X 	int i, sw = (w + 7) / 8, dw;
X 	
X 	BitMapPtr bmp = (BitMapPtr) malloc (sizeof (BitMap));
X 	
X 	*bmp = NewRBitMap (w, h, 1);
X 	to = bmp->baseAddr;
X 	dw = bmp->rowBits / 8;
X 	
X 	for (i = 0; i < h; i++)
X 	 {
X 	 	(void) Bcopy (to, s, sw);
X 	 	to += dw;
X 	 	s += sw;
X 	 }
X 	
X 	return NewHardware ((WindowPtr) NULL, bmp);
X }
X
Xchar *StringFromHardware (d) struct hardware *d;
X {
X	unsigned sw, sh, dw = d->bm->rowBits;
X	char *res, *p, *q = d->bm->baseAddr;
X	DevicePoint ex;
X	int i;
X	
X	ex = HardwareExtent (d);
X	sw = (ex.dx + 7) / 8;
X	sh = ex.dy;
X	p = res = malloc (sw * sh);
X	
X	for (i = 0; i < sh; i++)
X	 {
X	 	(void) Bcopy (p, q, sw);
X	 	p += sw; q += dw;
X	 }
X	
X	return res;
X }
X
Xvoid Line (h, fromPoint, toPoint, rop, colour)
X	struct hardware *h;
X	DevicePoint fromPoint, toPoint;
X	int rop;
X	Colour colour;
X {
X	
X }
X
XSetCLTE (col, r, g, b) int col, r, g, b;
X {
X/*	fprintf (stderr, "%d = (%d, %d, %d)\n", col, r, g, b);	*/
X }
X
XHardUpdate ()
X {
X }
END_OF_FILE
if test 6758 -ne `wc -c <'source/orion.c'`; then
    echo shar: \"'source/orion.c'\" unpacked with wrong size!
fi
# end of 'source/orion.c'
fi
if test -f 'source/real.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/real.c'\"
else
echo shar: Extracting \"'source/real.c'\" \(6703 characters\)
sed "s/^X//" >'source/real.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X
Xstatic Object OpFor;
X
Xstatic int For (), PFor (), Eq (), Lt (), Le (), Gt (), Ge (), Identity ();
Xstatic int Abs (), Add (), Sub (), Mul (), Div (), Neg (), EqEq (), Cvi (), Cvs ();
Xstatic int Exp (), Sqrt (), Sin (), Cos (), Atan (), Ln (), Log (), Ceiling (), Floor (), Round (), Truncate ();
X
XInitReal ()
X {
X 	OpFor = MakeOp ("(forreal)", For, 0, 1, 5, 6, Real, Real, Real, Array);
X 	
X	TypeInstallOp (Real, "cvr", 	Identity,	1, 1, 0, 0, Real);
X 	TypeInstallOp (Real, "cvi", 	Cvi,		1, 1, 0, 0, Real);
X 	TypeInstallOp (Real, "cvs", 	Cvs,		2, 1, 0, 0, Real, String);
X	TypeInstallOp (Real, "==", 	EqEq,		1, 0, 0, 0, Real);
X 	TypeInstallOp (Real, "for", 	PFor,		4, 0, 0, 6, Real, Real, Real, Array);
X  	TypeInstallOp (Real, "eq", 	Eq,		2, 1, 0, 0, Real, Real);
X  	TypeInstallOp (Real, "lt", 	Lt,		2, 1, 0, 0, Real, Real);
X 	TypeInstallOp (Real, "le", 	Le,		2, 1, 0, 0, Real, Real);
X 	TypeInstallOp (Real, "gt", 	Gt,		2, 1, 0, 0, Real, Real);
X 	TypeInstallOp (Real, "ge", 	Ge,		2, 1, 0, 0, Real, Real);
X	TypeInstallOp (Real, "abs", 	Abs,		1, 1, 0, 0, Real);
X 	TypeInstallOp (Real, "add",	Add,		2, 1, 0, 0, Real, Real);
X 	TypeInstallOp (Real, "sub", 	Sub,		2, 1, 0, 0, Real, Real);
X 	TypeInstallOp (Real, "mul", 	Mul,		2, 1, 0, 0, Real, Real);
X 	TypeInstallOp (Real, "div", 	Div,		2, 1, 0, 0, Real, Real);
X 	TypeInstallOp (Real, "neg", 	Neg,		1, 1, 0, 0, Real);
X 	TypeInstallOp (Real, "exp", 	Exp,		2, 1, 0, 0, Real, Real);
X 	TypeInstallOp (Real, "sqrt", 	Sqrt,		1, 1, 0, 0, Real);
X 	TypeInstallOp (Real, "sin", 	Sin,		1, 1, 0, 0, Real);
X 	TypeInstallOp (Real, "cos", 	Cos,		1, 1, 0, 0, Real);
X 	TypeInstallOp (Real, "atan",	Atan,		2, 1, 0, 0, Real, Real);
X 	TypeInstallOp (Real, "ln", 	Ln,		1, 1, 0, 0, Real);
X 	TypeInstallOp (Real, "log",	Log,		1, 1, 0, 0, Real);
X 	TypeInstallOp (Real, "ceiling", Ceiling,	1, 1, 0, 0, Real);
X 	TypeInstallOp (Real, "floor", 	Floor,		1, 1, 0, 0, Real);
X 	TypeInstallOp (Real, "round", 	Round,		1, 1, 0, 0, Real);
X 	TypeInstallOp (Real, "truncate",Truncate,	1, 1, 0, 0, Real);
X }
X
XObject MakeReal (f) float f;
X {
X 	Object res;
X 	
X 	res = MakeObject (Real);
X 	res.u.Real = f;
X 	
X 	return res;
X }
X
Xstatic Object Make (f) float f;
X {
X 	Object res;
X 	
X 	res = MakeObject (Real);
X 	res.u.Real = f;
X 	
X 	return res;
X }
X
Xstatic int Identity (item) Object item;
X {
X	return Push (OpStack, item);
X }
X
Xstatic int Cvi (item) Object item;
X {
X 	return Push (OpStack, IntReal (item));
X }
X
Xstatic int Cvs (v, string) Object v, string;
X {
X 	char buf [BUFSIZ];
X 	int length;
X 	
X	VOID sprintf (buf, "%g", BodyReal (v));
X	if ((length = strlen (buf)) > lengthString (string))
X		return Error (PRangeCheck);
X	VOID Bcopy (BodyString (string), buf, length);
X	return Push (OpStack, getIString (string, 0, length));
X }
X
Xstatic int EqEq (v) Object v;
X {
X	printf ("%g", BodyReal (v));
X	return TRUE;
X }
X
Xfloat BodyReal (item) Object item;
X {
X 	return item.u.Real;
X }
X
Xstatic float Body (item) Object item;
X {
X	return item.u.Real;
X }
X
XObject RealInteger (o) Object o;
X {
X 	return Make ((float) BodyInteger (o));
X }
X
Xstatic int PFor (initial, increment, limit, proc) Object initial, increment, limit, proc;
X {
X	VOID Push (ExecStack, Nil);
X	VOID Push (ExecStack, increment);
X	VOID Push (ExecStack, limit);
X	VOID Push (ExecStack, initial);
X	VOID Push (ExecStack, proc);
X	VOID Push (ExecStack, OpFor);
X	
X	return TRUE;
X }
X
Xstatic int For () 
X {
X	Object current, limit, increment, proc;
X	
X	proc	  = Pop (ExecStack);
X	current   = Pop (ExecStack);
X	limit	  = Pop (ExecStack);
X	increment = Pop (ExecStack);
X	
X	if (Body (increment) > 0
X				? Body (current) > Body (limit)
X				: Body (current) < Body (limit))
X	 	VOID Pop (ExecStack);
X	else
X	 {
X	 	VOID Push (ExecStack, increment);
X	 	VOID Push (ExecStack, limit);
X	 	VOID Push (ExecStack, Make (Body (current) + Body (increment)));
X	 	VOID Push (ExecStack, proc);
X	 	VOID Push (ExecStack, OpFor);
X	 	VOID Push (ExecStack, proc);
X	 	VOID Push (OpStack, current);
X	 }
X	return TRUE;
X }
X
Xstatic int Eq (a, b) Object a, b;
X {
X 	return Push (OpStack, MakeBoolean (Body (a) == Body (b)));
X }
X
Xstatic int Lt (a, b) Object a, b;
X {
X 	return Push (OpStack, MakeBoolean (Body (a) < Body (b)));
X }
X
Xstatic int Le (a, b) Object a, b;
X {
X 	return Push (OpStack, MakeBoolean (Body (a) <= Body (b)));
X }
X
Xstatic int Gt (a, b) Object a, b;
X {
X 	return Push (OpStack, MakeBoolean (Body (a) > Body (b)));
X }
X
Xstatic int Ge (a, b) Object a, b;
X {
X 	return Push (OpStack, MakeBoolean (Body (a) >= Body (b)));
X }
X
Xstatic int Abs (v) Object v;
X {
X  	return Push (OpStack, Make (Body (v) >= 0 ? Body (v) : -Body (v)));
X }
X
Xstatic int Add (a, b) Object a, b;
X {
X 	return Push (OpStack, Make (Body (a) + Body (b)));
X }
X
Xstatic int Sub (a, b) Object a, b;
X {
X 	return Push (OpStack, Make (Body (a) - Body (b)));
X }
X
Xstatic int Mul (a, b) Object a, b;
X {
X 	return Push (OpStack, Make (Body (a) * Body (b)));
X }
X
Xstatic int Div (a, b) Object a, b;
X {
X 	return Push (OpStack, Make (Body (a) / Body (b)));
X }
X
Xstatic int Neg (a) Object a;
X {
X	return Push (OpStack, Make (-Body (a)));
X }
X
Xstatic int Sqrt (v) Object v;
X {
X 	return Push (OpStack, Make ((float) sqrt ((double) Body (v))));
X }
X
Xstatic int Exp (a, b) Object a, b;
X {
X	return Push (OpStack, Make ((float) pow ((double) Body (a), (double) Body (b))));
X }
X
Xstatic int Ceiling (v) Object v;
X {
X 	return Push (OpStack, Make ((float) ceil ((double) Body (v))));
X }
X
Xstatic int Floor (v) Object v;
X {
X 	return Push (OpStack, Make ((float) floor ((double) Body (v))));
X }
X
Xstatic int Round (v) Object v;
X {
X	return Push (OpStack, Make (Body (v) - floor ((double) Body (v)) >= 0.5
X 					? ceil ((double) Body (v))
X 					: floor ((double) Body (v))));
X }
X
Xstatic int Truncate (v) Object v;
X {
X 	return Push (OpStack, Make (Body (v) < 0 ? ceil (Body (v)) : floor (Body (v))));
X }
X
Xstatic int Atan (a, b) Object a, b;
X {
X 	return Push (OpStack, Make ((float) Deg (atan2 (Body (a), Body (b)))));
X }
X
Xstatic int Cos (v) Object v;
X {
X 	return Push (OpStack, Make (cos (Rad (Body (v)))));
X }
X
Xstatic int Sin (v) Object v;
X {
X 	return Push (OpStack, Make (sin (Rad (Body (v)))));
X }
X
Xstatic int Ln (v) Object v;
X {
X 	return Push (OpStack, Make (log (Body (v))));
X }
X
Xstatic int Log (v) Object v;
X {
X 	return Push (OpStack, Make (log10 (Body (v))));
X }
END_OF_FILE
if test 6703 -ne `wc -c <'source/real.c'`; then
    echo shar: \"'source/real.c'\" unpacked with wrong size!
fi
# end of 'source/real.c'
fi
if test -f 'source/stack.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/stack.c'\"
else
echo shar: Extracting \"'source/stack.c'\" \(6765 characters\)
sed "s/^X//" >'source/stack.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X
X#define   OPSTACKSIZE	500
X#define EXECSTACKSIZE	250
X#define DICTSTACKSIZE	 20
X
Xstatic StackOb	DStack, EStack, OStack;
X	
XStack	DictStack = &DStack;
XStack	ExecStack = &EStack;
XStack	OpStack   = &OStack;
X
Xstatic int PPop (), PDup (), PExch (), PRoll (), PIndex (), PClear (), PCount (), PClearToMark (); 
Xstatic int PCountToMark (), PExecStack (), PCountDictStack (), PDictStack ();
Xstatic int PReverseStack ();
X
Xstatic StackOb MakeStack ();
X
XInitStack ()
X {
X	DStack	= MakeStack (DICTSTACKSIZE, PDictOverflow,	PDictUnderflow);
X		VOID Push (DictStack, SysDict);
X		
X	OStack	= MakeStack (  OPSTACKSIZE, POpOverflow,	POpUnderflow);
X	EStack	= MakeStack (EXECSTACKSIZE, PExecOverflow,	PExecUnderflow);
X	
X	Install ("mark", Marker);
X	
X	InstallOp ("pop",		PPop,		1, 0, 0, 0, Poly);
X	InstallOp ("dup",		PDup,		1, 2, 0, 0, Poly);
X	InstallOp ("exch",		PExch,		2, 2, 0, 0, Poly, Poly);
X	InstallOp ("roll",		PRoll,		2, 0, 0, 0, Integer, Integer);
X	InstallOp ("index",		PIndex,		1, 1, 0, 0, Integer);
X	InstallOp ("clear",		PClear,		0, 0, 0, 0);
X	InstallOp ("count",		PCount,		0, 1, 0, 0);
X	InstallOp ("cleartomark",	PClearToMark,	0, 0, 0, 0);
X	InstallOp ("counttomark",	PCountToMark,	0, 1, 0, 0);
X	InstallOp ("execstack",		PExecStack,	1, 1, 0, 0, Array);
X	InstallOp ("countdictstack",	PCountDictStack,0, 1, 0, 0);
X	InstallOp ("dictstack",		PDictStack,	1, 1, 0, 0, Array);
X	InstallOp ("reversestack",	PReverseStack,	1, 0, 0, 0, Integer);
X }
X
Xstatic StackOb MakeStack (size, over, under) int size; Object over, under;
X {
X	StackOb res;
X	
X	res.stack_body = (Object *) Malloc ((unsigned) sizeof (Object) * size);
X	res.stack_fill = 0; res.stack_size = size;
X	res.overflow = over; res.underflow = under;
X	
X	return res;
X }
X
X#ifdef notdef
Xint Push (stack, object) Stack stack; Object object;
X {
X	if (stack->stack_fill != stack->stack_size)
X		stack->stack_body[stack->stack_fill++] = object;
X	else
X		return FALSE;
X	return TRUE;
X }
X
XObject Pop (stack) Stack stack;
X {
X	if (stack->stack_fill)
X	 	return stack->stack_body[--stack->stack_fill];
X	printf ("%s", stack == OpStack ? "OpStack" : stack == ExecStack ? "ExecStack" : "OtherStack");
X	Panic (": Pop empty stack");
X	return Nil; /* for lint */
X }
X
XObject Top (stack) Stack stack;
X {
X	if (stack->stack_fill)
X	 	return stack->stack_body[stack->stack_fill - 1];
X	printf ("%s", stack == OpStack ? "OpStack" : stack == ExecStack ? "ExecStack" : "OtherStack");
X	Panic (": Top empty stack");
X	return Nil; /* for lint */
X }
X
Xint Height (s) Stack s;
X {
X 	return s->stack_fill;
X }
X
Xint MaxStack (s) Stack s;
X {
X 	return s->stack_size;
X }
X#endif
X
XObject DictLookup (o) Object o;
X {
X 	int i;
X 	
X 	for (i = DictStack->stack_fill - 1; i >= 0; i--)
X 	 {
X 	 	Object item;
X 	 	
X 	 	item = DictLoad (DictStack->stack_body[i], o);
X 		if (TypeOf (item) != Condition)
X 			return item;
X 	 }
X 	return Absent;
X }
X
XObject Where (key) Object key;
X {
X 	int i;
X 	
X 	for (i = DictStack->stack_fill - 1; i >= 0; i--)
X 	 {
X 	 	Object t;
X 	 	
X 	 	t = DictLoad (DictStack->stack_body[i], key);
X  		if (TypeOf (t) != Condition)
X 			return DictStack->stack_body[i];
X 	 }
X 	return Absent;
X }
X
Xstatic reverse (vec, n) Object *vec; int n;
X {
X 	Object temp;
X 	int i, lim = n / 2;
X 	
X 	for (i = 0; i < lim; i++)
X 		temp = vec[i],
X 		vec[i] = vec[n-1-i],
X 		vec[n-1-i] = temp;
X }
X
Xint CountTo (t, s) Type t; Stack s;
X {
X 	int i;
X 	
X 	Object *body = s->stack_body;
X 	
X 	for (i = Height (s) - 1; i >= 0; i--)
X 		if (TypeOf (body[i]) == t)
X 			return Height (s) - i - 1;
X 	return -1;
X }
X
Xint ClearTo (t, s) Type t; Stack s;
X {
X 	int count;
X 	
X 	if ((count = CountTo (t, s)) >= 0)
X		s->stack_fill = s->stack_fill - (count + 1);
X	else
X		return FALSE;
X	return TRUE;
X }
X
Xstatic int PCountDictStack ()
X {
X 	return Push (OpStack, MakeInteger (DictStack->stack_fill));
X }
X
Xstatic int PDictStack (array) Object array;
X {
X	Object *body = DictStack->stack_body;
X	int i, l = Height (DictStack);
X	
X 	if (!wCheck (array))
X 		return Error (PInvAccess);
X 	if (l > lengthArray (array))
X 		return Error (PRangeCheck);
X	for (i = 0; i < l; i++)
X 		putArray (array, i, body[i]);
X 	return Push (OpStack, getIArray (array, 0, l));
X }
X
X/*ARGSUSED*/
Xstatic int PPop (item) Object item;
X {
X 	return TRUE;
X }
X
Xstatic int PDup (item) Object item;
X {
X 	return Push (OpStack, item), Push (OpStack, item);
X }
X
Xstatic int PExch (a, b) Object a, b;
X {
X 	return Push (OpStack, b), Push (OpStack, a);
X }
X
Xstatic int PRoll (size, count) Object size, count;
X {
X	int s = BodyInteger (size), c = BodyInteger (count);
X	Object *body = OpStack->stack_body + Height (OpStack) - s;
X	
X 	if (BodyInteger (size) < 0)
X 		return Error (PRangeCheck);
X 	if (BodyInteger (size) > Height (OpStack))
X 		return Error (POpUnderflow);
X 	if (BodyInteger (size) == 0)
X 		return TRUE;
X	if (c > 0)
X	 {
X	 	c = c % s;
X		reverse (body, s - c);
X		reverse (body + s - c, c);
X	 }
X	else
X	 {
X	 	c = (-c) % s;
X		reverse (body, c);
X		reverse (body + c, s - c);
X	 }
X	reverse (body, s);
X	return TRUE;
X }
X
Xstatic int PIndex (index) Object index;
X {
X 	if (BodyInteger (index) >= Height (OpStack) || BodyInteger (index) < 0)
X 		return Error (PRangeCheck);
X 	return Push (OpStack, OpStack->stack_body[Height (OpStack) - 1 - BodyInteger (index)]);
X }
X
Xstatic int PClear ()
X {
X 	OpStack->stack_fill = 0;
X 	return TRUE;
X }
X
Xstatic int PCount ()
X {
X	return Push (OpStack, MakeInteger (Height (OpStack)));
X }
X
Xstatic int PClearToMark ()
X {
X 	if (ClearTo (Mark, OpStack))
X 		return TRUE;
X 	else
X 		return Error (PUnMatched);
X }
X
Xstatic int PCountToMark ()
X {
X 	int count;
X 	
X 	if ((count = CountTo (Mark, OpStack)) >= 0)
X 		return Push (OpStack, MakeInteger (count));
X 	else
X 		return Error (PUnMatched);
X }
X
Xstatic int PExecStack (array) Object array;
X {
X	int i, l = Height (ExecStack);
X 	Object *body = ExecStack->stack_body;
X	
X	if(!wCheck (array))
X		return Error (PInvAccess);
X	if (l > lengthArray (array))
X		return Error (PRangeCheck);
X	for (i = 0; i < l; i++)
X		putArray (array, i, body[i]);
X	VOID Push (OpStack, getIArray (array, 0, l));
X	return TRUE;
X }
X
XReverseStack (stack, n) Stack stack; int n;
X {
X 	Object *body = stack->stack_body;
X 	
X 	reverse (&body[Height (stack) - n], n);
X }
X
Xstatic int PReverseStack (n) Object n;
X {
X 	if (BodyInteger (n) > Height (OpStack))
X 		return Error (PRangeCheck);
X 	ReverseStack (OpStack, BodyInteger (n));
X 	return TRUE;
X }
END_OF_FILE
if test 6765 -ne `wc -c <'source/stack.c'`; then
    echo shar: \"'source/stack.c'\" unpacked with wrong size!
fi
# end of 'source/stack.c'
fi
if test -f 'source/ww.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/ww.c'\"
else
echo shar: Extracting \"'source/ww.c'\" \(6749 characters\)
sed "s/^X//" >'source/ww.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X#include "graphics.h"
X#include "canon.h"
X#include "wwinfo.h"
X
Xstatic void xxrasterop ();
X
Xstatic struct hardware *NewHardware ();
X
Xstruct hardware *InitHardware ()
X {
X	wwstartup (2);
X	
X	InitTransfer (wwask (ASKXPPI));
X	
X	return NULL;
X }
X
Xstruct hardware *NewWindowHardware (width, height) int width, height;
X {
X 	DevicePoint real_extent;
X 	window *w;
X 	
X 	real_extent = NewDevicePoint (width, height);
X 	
X 	if (width == 0)
X 		width = 1;
X 	if (height == 0)
X 		height = 1;
X 	
X 	if ((w = wwxget (boxbuild (0, 0, width, height), 2, "PostScript", 0)) == NULL)
X 		return NULL;
X 	return NewHardware (w->w_bm, real_extent, ISWIN);
X }
X
Xstruct hardware *NewBitmapHardware (width, height) int width, height;
X {
X 	DevicePoint real_extent;
X 	bitmap *bm;
X 	
X 	real_extent = NewDevicePoint (width, height);
X 	
X 	if (width == 0)
X 		width = 1;
X 	if (height == 0)
X 		height = 1;
X 	if ((bm = bmget (width, height)) == NULL)
X 		return NULL;
X 	
X 	return NewHardware (bm, real_extent, 0);
X }
X
X#define DeviceBitmap(h) ((bitmap *) ((h)->hard.addr))
X
Xstatic void DestroyHard (dev) struct hardware *dev;
X {
X 	bitmap *bm = DeviceBitmap (dev);
X 	
X 	if (bm)
X 	 {
X 	 	if (bm->bm_window)
X 	 		wwfree (bm->bm_window);
X 		else
X 			bmfree (bm);
X 	 }
X }
X
Xvoid DestroyHardware (dev) struct hardware *dev;
X {
X 	if (dev == NULL)
X 		return;
X 	DestroyHard (dev);
X 	if (dev->aux)
X 		DestroyHardware (dev->aux);
X 	Free ((char *) dev);
X }
X
Xstatic struct hardware *NewHardware (bm, extent, flags) bitmap *bm; DevicePoint extent; int flags;
X {
X 	struct hardware *d = (struct hardware *) Malloc (sizeof (struct hardware));
X 	
X 	d->flags = flags;
X 	d->hard.addr = (char *) bm;
X 	d->aux = d->clip = NULL;
X 	d->extent = extent;
X 	
X 	return d;
X }
X
Xstruct hardware *HardwareFromString (st, width, height) char *st; int width, height;
X {
X 	unsigned size = height * (width + 7) / 8;
X 	char *s = Malloc (size + 4);
X 	struct hardware *h;
X 	
X 	s[0] = height >> 8; s[1] = height;
X 	s[2] = width >> 8;  s[3] = width;
X 	Bcopy (s + 4, st, size);
X 	
X 	h = NewHardware (bmdecode (s, ENWWSTYLE), NewDevicePoint (width, height), 0);
X 	Free ((char *) s);
X 	
X 	return h;
X }
X
Xchar *StringFromHardware (dev) struct hardware *dev;
X {
X 	int length;
X 	
X 	return bmencode (DeviceBitmap (dev), ENWWSTYLE, &length) + 4;
X }
X
Xvoid UpdateControl (h, flag) struct hardware *h; int flag;
X {
X 	window *oldddwin = ddwin;
X 	
X 	if (h == NULL)
X 		return;
X 	ddwin = DeviceBitmap (h)->bm_window;
X 	if (ddwin)
X		wwstack (flag ? WWPOP : WWPUSHOFF);
X	ddwin = oldddwin;
X }
X
Xvoid RasterTile (from, to, toPoint, extent, rop)
X	struct hardware *from, *to;
X	DevicePoint toPoint, extent;
X	int rop;
X {
X 	if (to == NULL || extent.dx == 0 || extent.dy == 0)
X 		return;
X 	bmclip (DeviceBitmap (to), boxbuild (toPoint.dx, toPoint.dy, toPoint.dx + extent.dx - 1, toPoint.dy + extent.dy - 1));
X 	xxrasterop (DeviceBitmap (from), DeviceBitmap (from)->bm_box, DeviceBitmap (to), DeviceBitmap (to)->bm_box, rop);
X 	bmclip (DeviceBitmap (to), noclipbox);
X }
X
Xvoid BitBlt (from, to, fromPoint, toPoint, extent, rop)
X	struct hardware *from, *to;
X	DevicePoint fromPoint, toPoint, extent;
X	int rop;
X {
X	box frombox, tobox;
X	
X	if (to == NULL || extent.dx == 0 || extent.dy == 0)
X 		return;
X	
X 	if (from == NULL)
X 		rop = single_rop [rop];
X 	else
X 		frombox = boxbuild (fromPoint.dx, fromPoint.dy, fromPoint.dx + extent.dx - 1, fromPoint.dy + extent.dy - 1);
X 	
X  	tobox = boxbuild (toPoint.dx, toPoint.dy, toPoint.dx + extent.dx - 1, toPoint.dy + extent.dy - 1);
X	
X	xxrasterop ((from == NULL ? NULL : DeviceBitmap (from)), frombox, DeviceBitmap (to), tobox, rop);
X }
X
Xvoid BitBltLine (h, fromPoint, toPoint, rop) 
X  	struct hardware *h;
X	DevicePoint fromPoint, toPoint;
X	int rop;
X {
X 	if (h == NULL)
X 		return;
X 	
X	switch (single_rop [rop])
X	 {
X	 	case ROP_FALSE: 	rop = WWAND; 	break;
X	 	case ROP_TRUE:  	rop = WWOR;  	break;
X	 	case ROP_NOTDEST: 	rop = WWXOR; 	break;
X	 	case ROP_DEST: 		return; 	break;
X	 	
X	 	default:
X	 		fprintf (stderr, "illegal rasterop\n");
X	 		exit (1);
X	 }
X	
X	ddbm = DeviceBitmap (h);
X 	dd->d_line = rop;
X 	
X	line (fromPoint.dx, fromPoint.dy, LNMOVEABS);
X 	line (toPoint.dx, toPoint.dy, LNDRAWABS);
X }
X
Xvoid BitBltBlob (to, top, height, left, right, rop) struct hardware *to; int top, height, *left, *right, rop;
X {
X 	int i, op, offset = top;
X 	height += top;
X 	switch (rop)
X 	 {
X 	 	case ROP_FALSE: 	op = BMCLEARALL; break;
X 	 	case ROP_DEST: 		return;
X 	 	case ROP_NOTDEST: 	op = BMNOTALL; break;
X 	 	case ROP_TRUE: 		op = BMNOTALL | BMCLEARALL; break;
X 	 }
X 	ddbm = DeviceBitmap (to);
X 	UpdateControl (to, FALSE);
X 	for (i = top; i < height; i++)
X 		bmbox (boxbuild (left[i - offset], i, right[i - offset], i), op);
X 	UpdateControl (to, TRUE);
X }
X
Xstatic void xxrasterop (from, frombox, to, tobox, rop) bitmap *from, *to; box frombox, tobox; int rop;
X {
X	switch (rop)
X 	 {
X 	 	case ROP_FALSE: 							    bmxbox (to, tobox, BMCLEARALL);	break;
X 	 	case ROP_AND: 		bmxcopy (from, frombox, to, tobox, WWAND); 						break;
X 	 	case ROP_ANDNOT:	bmxcopy (from, frombox, to, tobox, WWOR | WWNOT);   bmxbox (to, tobox, BMNOTALL); 	break;
X	 	case ROP_SOURCE: 	bmxcopy (from, frombox, to, tobox, WWCOPY); 						break;
X	 	case ROP_NOTAND: 	bmxcopy (from, frombox, to, tobox, WWAND | WWNOT); 					break;
X 	 	case ROP_DEST: 													break;
X 	 	case ROP_XOR:		bmxcopy (from, frombox, to, tobox, WWXOR); 						break;
X  	 	case ROP_OR:		bmxcopy (from, frombox, to, tobox, WWOR); 						break;
X  	 	case ROP_NOR:		bmxcopy (from, frombox, to, tobox, WWOR); 	    bmxbox (to, tobox, BMNOTALL); 	break;
X  	 	case ROP_NXOR:		bmxcopy (from, frombox, to, tobox, WWXOR); 	    bmxbox (to, tobox, BMNOTALL); 	break;
X	 	case ROP_NOTDEST: 							    bmxbox (to, tobox, BMNOTALL); 	break;
X	 	case ROP_ORNOT:		bmxcopy (from, frombox, to, tobox, WWAND | WWNOT);  bmxbox (to, tobox, BMNOTALL);	break;
X	 	case ROP_NOTSOURCE:	bmxcopy (from, frombox, to, tobox, WWCOPY | WWNOT); 					break;
X  	 	case ROP_NOTOR:		bmxcopy (from, frombox, to, tobox, WWOR | WWNOT); 					break;
X	 	case ROP_NAND:		bmxcopy (from, frombox, to, tobox, WWAND); 	    bmxbox (to, tobox, BMNOTALL); 	break;
X 	 	case ROP_TRUE: 							bmxbox (to, tobox, BMCLEARALL | BMNOTALL); 	break;
X 	 	
X 	 	default:
X 	 		fprintf (stderr, "Illegal rasterop %d (hex 0x%x)\n", rop, rop);
X 	 		exit (1);
X 	 }
X }
END_OF_FILE
if test 6749 -ne `wc -c <'source/ww.c'`; then
    echo shar: \"'source/ww.c'\" unpacked with wrong size!
fi
# end of 'source/ww.c'
fi
echo shar: End of archive 4 \(of 18\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
