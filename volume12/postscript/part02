Subject:  v12i051:  A PostScript interpreter, Part02/18
Newsgroups: comp.sources.unix
Sender: sources
Approved: rs@uunet.UU.NET

Submitted-by: Crispin Goswell <caag@vd.rl.ac.uk>
Posting-number: Volume 12, Issue 51
Archive-name: postscript/part02



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 18)."
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'doc/byte-stream' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/byte-stream'\"
else
echo shar: Extracting \"'doc/byte-stream'\" \(4082 characters\)
sed "s/^X//" >'doc/byte-stream' <<'END_OF_FILE'
XA byte Stream Protocol for low-level graphics operations in PostScript.
X
XThe PostScript interpreter does a great deal of work, so the actual
Xgraphics primitives are not usually a bottle-neck. It thus makes sense
Xto run the interpreter on a number-cruncher and watch the graphics on a
Xbitmapped display.
X
XThis file describes a byte-stream protocol which has been used to
Ximplement this.  It is clear that Remote Procedure Call is the correct
Xway to solve this problem - this interface is described because it is
Xportable and expedient. Most RPC mechanisms are intimately tied to a
Xnetwork protocol of some description. This implementation works through
Xpipes and can be sent accross a network with rsh(1) on 4.2BSD.
X
XA version may appear which uses only a simple command language with no
Xenquiry. This unfortunately cannot provide the full functionality
Xrequired. It would not be possible to read back cached fonts from the
Xviewer for example, as they are held at that end.
X
XThe byte-stream is composed of requests of variable length. The first
Xbyte in each request is a type byte and the format of the remaining
Xbytes is determined by this.
X
XThe current formats are as follows. An indented following line
Xindicates the expected reply (if any).
X
XNEW_WINDOW	hard channel; short width, height;
X		/* create a displayed bitmap of the required size. The
X		initial content is unimportant, as it will be cleared
X		to user-white later */
XNEW_BITMAP	hard channel; short width, height;
X		/* create a non-displayed bitmap. These may vary from
X		full-screen size down to character sizes and are used
X		for caching fonts (among other things */
XBITBLT		hard fromchan, tochan; point fromOrigin, toOrigin, extent;
X		rop rasterOp;
X		/* general purpose rasterop */
XSEND_BITMAP	hard channel; short width, height; string data;
X		/* create a bitmap of the given size and put the
X		following bits in it. */
XGET_BITMAP	hard channel;
X		string data;
X		/* return an encoded bitmap describing the given
X		bitmap. The ability to dump from a window is not yet
X		used, but may be in the future. */
XDESTROY_HARDWARE	hard channel;
X		/* release the bitmap or window associated with a channel */
XLINE		hard channel; point from, to; rop rasterOp;
X		/* draw a line as required */
XGET_MATRIX	short width, height;
X		float A, B, C, D, tx, ty;
XGET_TRANSFERSIZE
X		short size;
XSET_TRANSFER	small tran[size];
XPAINT		hard fromchan, tochan; point fromOrigin, toOrigin, extent;
X		/* fromchan will be a bitmap, tochan will be a window.
X		This is the only combination currently required */
XPAINT_LINE	hard channel; point from, to; small hue, sat, bright;
X		/* paint a line as required */
X
XHARD_FLUSH	/* flush hardware output buffer before user gets prompted
X		(if necessary) */
X
XSCREEN_SIZE	float frequency, rotation;
X		short size;
X
XBUILD_SCREEN	float frequency, rotation;
X		short size; small *x, *y;
X		/* returns XY pairs x[0], y[0], x[1], y[1], ... for
X		spot function */
X
XSET_SCREEN	float frequency, rotation; small *thresh;
X		/* send vector of thresholds from spot-function */
X		
X
Xhard	= short
Xshort 	= low byte followed by high byte
Xsmall	= short from float scaled by 16384 - the float is expected to be in
X		the range -1 to +1
Xfloat	= free format printable representation terminated by newline as
X		generated by printf("%g\n", arg);
Xpoint	= short x, y;	origin is expected to be top-left and units are
X		device pixels.
Xstring 	= an encoding of a bitmap. msb is leftmost, rows are padded to
X		byte-boundaries. Length is computed from the size of the
X		relevant bitmap.
Xrop	= byte	- the meanings are as follows:
X
X#define ROP_FALSE	0	/* F		*/
X#define ROP_AND		1	/* S & D	*/
X#define ROP_ANDNOT	2	/* S & ~D	*/
X#define ROP_SOURCE	3	/* S		*/
X#define ROP_NOTAND	4	/* ~S & D	*/
X#define ROP_DEST	5	/* D		*/
X#define ROP_XOR		6	/* S ^ D	*/
X#define ROP_OR		7	/* S | D	*/
X#define ROP_NOR		8	/* ~(S | D)	*/
X#define ROP_NXOR	9	/* ~(S ^ D)	*/
X#define ROP_NOTDEST	10	/* ~D		*/
X#define ROP_ORNOT	11	/* S | ~D	*/
X#define ROP_NOTSOURCE	12	/* ~S		*/
X#define ROP_NOTOR	13	/* ~S | D	*/
X#define ROP_NAND	14	/* ~(S & D)	*/
X#define ROP_TRUE	15	/* T		*/
END_OF_FILE
if test 4082 -ne `wc -c <'doc/byte-stream'`; then
    echo shar: \"'doc/byte-stream'\" unpacked with wrong size!
fi
# end of 'doc/byte-stream'
fi
if test -f 'source/boolean.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/boolean.c'\"
else
echo shar: Extracting \"'source/boolean.c'\" \(4214 characters\)
sed "s/^X//" >'source/boolean.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X
XObject True, False;
Xstatic Object OpNot;
Xstatic int Cvs (), And (), Or (), Not (), Xor ();
Xstatic int PEq (), PNeq (), EqBoolean ();
X
XInitBoolean ()
X {
X	True = 	MakeObject (Boolean);
X	False = MakeObject (Boolean);
X	
X 	True.u.Boolean = TRUE;
X	False.u.Boolean = FALSE;
X	
X	Install ("true",	True);
X	Install ("false",	False);
X  	
X 	TypeInstallOp (Boolean, "cvs", 	Cvs,  		2, 1, 0, 0, Boolean, String);
X 	TypeInstallOp (Boolean, "and", 	And,  		2, 1, 0, 0, Boolean, Boolean);
X 	TypeInstallOp (Boolean, "or", 	Or,  		2, 1, 0, 0, Boolean, Boolean);
X 	TypeInstallOp (Boolean, "xor", 	Xor,  		2, 1, 0, 0, Boolean, Boolean);
X 	TypeInstallOp (Boolean, "not", 	Not,  		1, 1, 0, 0, Boolean);
X 	TypeInstallOp (Boolean, "eq", 	EqBoolean,  	2, 1, 0, 0, Boolean, Boolean);
X 	
X	OpNot = Lookup (Boolean, NameFrom ("not"));
X	
X 	InstallOp ("eq",	PEq,  		2, 1, 0, 0, Poly, Poly);
X 	InstallOp ("ne",	PNeq, 		2, 1, 0, 0, Poly, Poly);
X 	InstallOp ("ge", 	PolyPair, 	2, 2, 0, 0, Poly, Poly);
X 	InstallOp ("gt", 	PolyPair, 	2, 2, 0, 0, Poly, Poly);
X 	InstallOp ("le", 	PolyPair, 	2, 2, 0, 0, Poly, Poly);
X 	InstallOp ("lt", 	PolyPair, 	2, 2, 0, 0, Poly, Poly);
X 	InstallOp ("not", 	PolyFirst, 	1, 1, 0, 0, Poly);
X 	InstallOp ("and", 	PolyPair, 	2, 2, 0, 0, Poly, Poly);
X 	InstallOp ("or", 	PolyPair, 	2, 2, 0, 0, Poly, Poly);
X 	InstallOp ("xor", 	PolyPair, 	2, 2, 0, 0, Poly, Poly);
X 	InstallOp ("bitshift", 	PolyPair, 	2, 2, 0, 0, Poly, Poly);
X }
X
XObject MakeBoolean (b) int b;
X {
X	return b ? True : False;
X }
X
Xint BodyBoolean (b) Object b;
X {
X 	return b.u.Boolean;
X }
X
Xstatic int Cvs (v, string) Object v, string;
X {
X 	char *choice = BodyBoolean (v) ? "true" : "false";
X 	int length = strlen (choice);
X 	
X	if (lengthString (string) < length)
X		return Error (PRangeCheck);
X	VOID Bcopy (BodyString (string), choice, length);
X	return Push (OpStack, getIString (string, 0, length));
X }
X
Xstatic int PEq (a, b) Object a, b;	/* any any --- boolean */
X {
X	if (!rCheck (a) || !rCheck (b))
X	 	return Error (PInvAccess);
X	if (TypeOf (a) == Name && TypeOf (b) == String)
X 		a = StringName (a);
X 	else if (TypeOf (b) == Name && TypeOf (a) == String)
X 		b = StringName (b);
X	else if (TypeOf (a) == Real && TypeOf (b) == Integer)
X			b = RealInteger (b);
X	else if (TypeOf (a) == Integer && TypeOf (b) == Real)
X			a = RealInteger (a);
X 	if (TypeOf (a) == TypeOf (b))
X 	 {
X 	 	VOID Push (OpStack, a);
X 	 	VOID Push (OpStack, b);
X  		return Apply (TypeOf (a));
X  	 }
X 	else
X 		return Push (OpStack, False);
X }
X
Xstatic int PNeq (a, b) Object a, b;		/* any any --- boolean */
X {
X 	if (!rCheck (a) || !rCheck (b))
X 	 	return Error (PInvAccess);
X	if (TypeOf (a) == Name && TypeOf (b) == String)
X 		a = StringName (a);
X 	else if (TypeOf (b) == Name && TypeOf (a) == String)
X 		b = StringName (b);
X	else if (TypeOf (a) == Real && TypeOf (b) == Integer)
X			b = RealInteger (b);
X	else if (TypeOf (a) == Integer && TypeOf (b) == Real)
X			a = RealInteger (a);
X 	if (TypeOf (a) == TypeOf (b))
X  	 {
X 	 	VOID Push (OpStack, a);
X 	 	VOID Push (OpStack, b);
X 	 	VOID Push (ExecStack, OpNot);
X 	 	Self = NameFrom ("eq");
X  		return Apply (TypeOf (a));
X  	 }
X 	else
X 		return Push (OpStack, True);
X }
X
Xstatic int EqBoolean (a, b) Object a, b;
X {
X  	return Push (OpStack, MakeBoolean (BodyBoolean (a) == BodyBoolean (b)));
X }
X
Xstatic int Not (bool) Object bool;
X {
X 	return Push (OpStack, MakeBoolean (!BodyBoolean (bool)));
X }
X
Xstatic int And (a, b) Object a, b;
X {
X 	return Push (OpStack, MakeBoolean (BodyBoolean (a) && BodyBoolean (b)));
X }
X
Xstatic int Or (a, b) Object a, b;
X {
X 	return Push (OpStack, MakeBoolean (BodyBoolean (a) || BodyBoolean (b)));
X }
X
Xstatic int Xor (a, b) Object a, b;
X {
X 	return Push (OpStack, MakeBoolean (BodyBoolean (a) != BodyBoolean (b)));
X }
END_OF_FILE
if test 4214 -ne `wc -c <'source/boolean.c'`; then
    echo shar: \"'source/boolean.c'\" unpacked with wrong size!
fi
# end of 'source/boolean.c'
fi
if test -f 'source/colour.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/colour.c'\"
else
echo shar: Extracting \"'source/colour.c'\" \(4757 characters\)
sed "s/^X//" >'source/colour.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X#include "graphics.h"
X
X
XColour NewGray (level) float level;
X {
X 	return NewHSBColour (0.0, 0.0, level);
X }
X
XColour NewColour (h, s, b) float h, s, b;
X {
X 	return NewHSBColour (h, s, b);
X }
X
XColour NewHSBColour (h, s, b) float h, s, b;
X {
X	Colour res;
X	
X	res.hue = h;
X	res.saturation = s;
X	res.brightness = b;
X	
X	return res;
X }
X
XColour NewRGBColour (R, G, B) float R, G, B;
X {
X 	float H, S, L, m, M, r, g, b;
X 	
X 	M = R > G ? R : G; M = M > B ? M : B;
X 	m = R < G ? R : G; m = m < B ? m : B;
X 	if (M != m)
X 	 {
X 	 	r = (M - R) / (M - m);
X 	 	g = (M - G) / (M - m);
X 	 	b = (M - B) / (M - m);
X 	 }
X 	L = (M + m) / 2;
X 	
X 	if (M == m)
X 	 	S = 0;
X 	else if (L <= 0.5)
X 		S = (M - m) / (M + m);
X 	else
X 		S = (M - m) / (2 - M - m);
X 	
X 	if (S == 0)
X 		H = 0;
X 	else if (R == M)
X 		H = 2 + b - g;
X 	else if (G == M)
X 		H = 4 + r - b;
X 	else
X 		H = 6 + g - r;
X 	
X 	H /= 6;
X	
X	return NewHSBColour (H, S, L);
X }
X
Xvoid ColourHSB (colour, h, s, b) Colour colour; float *h, *s, *b;
X {
X 	*h = colour.hue;
X 	*s = colour.saturation;
X 	*b = colour.brightness;
X }
X
Xfloat Value (m, M, hue) float m, M, hue;
X {
X 	if (hue < 0.0)
X 		hue += 2 * PI;
X 	if (hue < PI / 3)
X 		return m + (M - m) * hue / (PI / 3);
X 	else if (hue < PI)
X 		return M;
X 	else if (hue < 4 * PI / 3)
X 		return m + (M - m) * (4 * PI / 3 - hue) / (PI / 3);
X 	else
X 		return m;
X }
X
Xvoid ColourRGB (colour, r, g, b) Colour colour; float *r, *g, *b;
X {
X 	float H = colour.hue, S = colour.saturation, L = colour.brightness;
X 	float m, M;
X	
X	if (L <= .5)
X		M = L * (1 + S);
X	else
X		M = (L + S) - (L * S);
X	m = 2 * L - M;
X	H *= 2 * PI;
X	*r = Value (m, M, H);
X	*g = Value (m, M, H - 2 * PI / 3);
X	*b = Value (m, M, H - 4 * PI / 3);
X }
X
Xfloat Brightness (colour) Colour colour;
X {
X 	return colour.brightness;
X }
X
X
X/* 
X * The RGB colour model and Hue Saturation Brightness/Lightness model
X * are derived from the paper:
X * 
X * 	"Colour Gamut Transform Pairs"
X *	by Alvy Ray Smith in Computer Graphics Volume 12 #3. August 1978
X * 
X * PostScript uses the NTSC video colour weights.
X */
X
X#define RED_WEIGHT	0.3333	/* .3	*/
X#define GREEN_WEIGHT	0.3333	/* .59	*/
X#define BLUE_WEIGHT	0.3333	/* .11	*/
X
X#define a0	120.0 * PI / 180		/* 156.58 * PI / 180 */
X#define a1	120.0 * PI / 180		/* 115.68 * PI / 180 */
X
X#define A0	0.0		/* -21.60 * PI / 180 */
X#define A1	0.0		/* 14.98 * PI / 180 */
X#define A2	0.0		/* 10.65 * PI / 180 */
X
X
X/*
Xstatic int SetRGB (red, green, blue) Object red, green, blue;
X {
X 	float R = BodyReal (red), G = BodyReal (green), B = BodyReal (blue);
X 	float r, g, b, r_, g_, b_, d, x, rr, gg, bb, wr_, k0, k1, min, H, S, L;
X 	
X 	if (R < 0 || R > 1 || G < 0 || G > 1 || B < 0 || B > 1)
X 		return Error (PRangeCheck);
X 	L = R * RED_WEIGHT + G * GREEN_WEIGHT + B * BLUE_WEIGHT;
X 	r_ = R/L; g_ = G/L; b_ = B/L;
X 	r = RED_WEIGHT * r_; g = GREEN_WEIGHT * g_; b = BLUE_WEIGHT * b_;
X 	rr = r - RED_WEIGHT; gg = g - GREEN_WEIGHT; bb = b - BLUE_WEIGHT;
X 	min = (r_ < g_ ? r_ : g_); min = min < b_ ? min : b_;
X 	S = 1 - min;
X 	if (S != 0)
X 	 {
X 		k0 = sqrt (rr*rr + gg*gg + bb*bb);
X 		wr_ = 1 - RED_WEIGHT;
X 		d = wr_ * rr - GREEN_WEIGHT * gg + BLUE_WEIGHT * bb;
X 		k1 = sqrt (wr_ * wr_ + GREEN_WEIGHT * GREEN_WEIGHT - BLUE_WEIGHT * BLUE_WEIGHT);
X 		x = d / (k0 * k1);
X 		H = PI / 2 - atan2 (x, sqrt (1 - x*x));
X 		if (b_ > g_)
X 			H = 2 * PI - H;
X 		H /= 2 * PI;
X 	 }
X 	if (H < 0 || H > 1 || S < 0 || S > 1 || L < 0 || L > 1)
X 		return Error (PRangeCheck);
X	gstate->colour = NewHSLColour (H, S, L);
X 	return TRUE;
X }
X
Xstatic int GetRGB ()
X {
X 	float H = gstate->colour.hue, S = gstate->colour.saturation, L = gstate->colour.brightness;
X 	float r, g, b, Wr = RED_WEIGHT, Wg = GREEN_WEIGHT, Wb = BLUE_WEIGHT;
X 	
X 	H *= 2 * PI;
X 	if (0 <= H && H <= a0)
X 	 {
X 	 	H -= A0;
X 	 	b = Wb * (1 - S);
X 	 	r = Wr + Wb * S * cos (H) / cos (PI / 3 - H);
X 	 	g = 1 - (r + b);
X 	 }
X 	else if (a0 <= H  && H <= (a0 + a1))
X 	 {
X 	 	H -= a0 + A1;
X 	 	r = Wr * (1 - S);
X 	 	g = Wg + Wr * S * cos (H) / cos (PI / 3 - H);
X 	 	b = 1 - (r + g);
X 	 }
X 	else
X 	 {
X 	 	H -= a0 + a1 + A2;
X 	 	g = Wg * (1 - S);
X 	 	b = Wb + Wg * S * cos (H) / cos (PI / 3 - H);
X 	 	r = 1 - (g + b);
X 	 }
X 	
X 	VOID Push (OpStack, MakeReal (L* r / Wr));
X 	VOID Push (OpStack, MakeReal (L* g / Wg));
X 	VOID Push (OpStack, MakeReal (L* b / Wb));
X	return TRUE;
X }
X
X*/
END_OF_FILE
if test 4757 -ne `wc -c <'source/colour.c'`; then
    echo shar: \"'source/colour.c'\" unpacked with wrong size!
fi
# end of 'source/colour.c'
fi
if test -f 'source/config.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/config.c'\"
else
echo shar: Extracting \"'source/config.c'\" \(3360 characters\)
sed "s/^X//" >'source/config.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X
Xstatic int SizeArray = 53, SizeMark = 19, SizeBoolean = 53, SizeNull = 19;
Xstatic int SizeCondition = 19, SizeFile = 41, SizeString = 71, SizePoly = 19;
Xstatic int SizeInteger = 71, SizeReal = 71, SizeName = 19, SizeOperator = 19;
Xint SizeSysDict = 1001, SizeDictionary = 53, SizeFloat = 0, SizeFontID = 19;
X
XType Array, Mark, Boolean, Dictionary, Condition, Null, File, Integer;
XType Real, Name, Operator, String, Poly, Float, FontID;
X
Xextern Object Absent, Nil, SysDict;
X
Xchar default_library[] = "/usr/ral/lib/postscript";
X
XInit ()
X {	
X	Nil 	= MakeObject ((Type) 0);
X	Null	  	= Nil.type = MakeType (SizeNull);
X	EmptyDict (Null);	/* needed because of this recursion */
X	
X	Dictionary	= MakeType (SizeDictionary);
X	Condition	= MakeType (SizeCondition);
X 	Name 		= MakeType (SizeName);
X	Operator	= MakeType (SizeOperator);
X 	Array 		= MakeType (SizeArray);
X 	Mark 		= MakeType (SizeMark);
X 	Boolean	 	= MakeType (SizeBoolean);
X 	File 		= MakeType (SizeFile);
X 	Integer 	= MakeType (SizeInteger);
X 	Real 		= MakeType (SizeReal);
X 	String 		= MakeType (SizeString);
X 	Poly 		= MakeType (SizePoly);
X 	Float		= MakeType (SizeFloat);
X	FontID		= MakeType (SizeFontID);
X	
X	Message ("InitDictionary");	InitDictionary ();
X	Message ("InitOperator");	InitOperator ();
X	Message ("InitName");	InitName ();
X	Message ("InitPoly");	InitPoly ();
X	Message ("InitArray");	InitArray ();
X	Message ("InitStack");	InitStack ();
X	Message ("InitFile");	InitFile ();
X	Message ("InitMisc");	InitMisc ();
X	Message ("InitBoolean");	InitBoolean ();
X	Message ("InitInteger");	InitInteger ();
X	Message ("InitReal");	InitReal ();
X	Message ("InitMath");	InitMath ();
X	Message ("InitString");	InitString ();
X	Message ("InitProperty");	InitProperty ();
X	Message ("InitControl");	InitControl ();
X	
X	Message ("InitMatrix");	InitMatrix ();
X	Message ("InitPath");	InitPath ();
X 	Message ("InitFill");	InitFill ();
X	Message ("InitStroke");	InitStroke ();
X	Message ("InitGSave");	InitGSave ();
X	Message ("InitDevices");	InitDevices ();
X	Message ("InitCache");	InitCache ();
X	Message ("InitImage");	InitImage ();
X 	Message ("InitState");	InitState ();
X	Message ("InitFont");	InitFont ();
X	Message ("InitUnix");	InitUnix ();
X	
X	Install ("nulltype",		DictFrom (Null));
X	Install ("dicttype",		DictFrom (Dictionary));
X	Install ("conditiontype",	DictFrom (Condition));
X 	Install ("nametype",		DictFrom (Name));
X	Install ("operatortype",	DictFrom (Operator));
X 	Install ("arraytype",		DictFrom (Array));
X 	Install ("marktype",		DictFrom (Mark));
X 	Install ("booleantype",		DictFrom (Boolean));
X 	Install ("filetype",		DictFrom (File));
X 	Install ("integertype",		DictFrom (Integer));
X 	Install ("realtype",		DictFrom (Real));
X 	Install ("stringtype",		DictFrom (String));
X 	Install ("polytype",		DictFrom (Poly));
X	Install ("fonttype",		DictFrom (FontID));
X	
X	Install ("version",	StringFrom ("Version 1.4"));
X }
END_OF_FILE
if test 3360 -ne `wc -c <'source/config.c'`; then
    echo shar: \"'source/config.c'\" unpacked with wrong size!
fi
# end of 'source/config.c'
fi
if test -f 'source/gsave.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/gsave.c'\"
else
echo shar: Extracting \"'source/gsave.c'\" \(2319 characters\)
sed "s/^X//" >'source/gsave.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X#include "graphics.h"
X
Xstatic struct state gstate_stack [MAXGSAVES];
X
Xstruct state *gstate = gstate_stack;
X
Xstatic int gstate_height = 0;
X
Xint GSave (), GRestore (), GRestoreAll ();
X
XInitGSave ()
X {
X 	InstallOp ("gsave",		GSave, 		0, 0, 0, 0);
X 	InstallOp ("grestore",		GRestore, 	0, 0, 0, 0);
X 	InstallOp ("grestoreall",	GRestoreAll, 	0, 0, 0, 0);
X 	
X 	gstate->screen.count = 0;	/* stops thresh getting freed accidentally */
X 	gstate->transfer.tcount = 0;	/* stops tran getting freed accidentally */
X }
X
Xint GSave ()
X {
X 	if (gstate_height == MAXGSAVES - 1)
X 		return Error (PLimitCheck);
X 	gstate_stack [gstate_height + 1] = gstate_stack [gstate_height];
X 	++gstate_height; ++gstate;
X 	gstate->path = PathCopy (gstate->path);
X 	gstate->clip = PathCopy (gstate->clip);
X 	LinkDevice (gstate->device);
X 	LinkDevice (gstate->clipdevice);
X 	++gstate->screen.count;
X 	++gstate->transfer.tcount;
X 	
X 	return TRUE;
X }
X
Xint GRestore ()
X {
X 	if (gstate_height == 0)
X 		VOID InitGraphics ();
X 	else
X 	 {
X 	 	int sflag = FALSE, tflag = FALSE;
X 	 	
X 		UnlinkDevice (gstate->device);
X  		UnlinkDevice (gstate->clipdevice);
X		PathFree (gstate->path);
X 		PathFree (gstate->clip);
X 		
X 		if (gstate->screen.count == 1)
X 		 {
X 			Free ((char *) gstate->screen.thresh);
X 			sflag = TRUE;
X 		 }
X  		if (gstate->transfer.tcount == 1)
X 		 {
X 			Free ((char *) gstate->transfer.tran);
X 			tflag = TRUE;
X 		 }
X  		--gstate_height;
X 		--gstate;
X 		if (sflag)
X  			SetScreen (gstate->screen.frequency, gstate->screen.rotation, gstate->screen.thresh);
X  		if (tflag)
X  			SetTransfer (gstate->transfer.tran);
X  		SetClipHardware (gstate->device->dev, (gstate->clipdevice ? gstate->clipdevice->dev : NULL));
X	 }
X 	
X 	return TRUE;
X }
X
Xint GRestoreAll ()
X {
X	while (gstate != gstate_stack)
X		VOID GRestore ();
X 	InitGraphics ();
X 	
X 	return TRUE;
X }
END_OF_FILE
if test 2319 -ne `wc -c <'source/gsave.c'`; then
    echo shar: \"'source/gsave.c'\" unpacked with wrong size!
fi
# end of 'source/gsave.c'
fi
if test -f 'source/main.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/main.h'\"
else
echo shar: Extracting \"'source/main.h'\" \(4101 characters\)
sed "s/^X//" >'source/main.h' <<'END_OF_FILE'
X/*
X * Copyright (C) Crispin Goswell 1987, All Rights Reserved.
X */
X
X#include <stdio.h>
X#include <math.h>
X#include <assert.h>
X#include <setjmp.h>
X#include <strings.h>
X
X#define NONE		(-2)
X#define EOS		'\0'
X#define TRUE		1
X#define FALSE		0
X
X#define BUFSIZE	     1000
X
X#define VOID	(void)
X
X#define READABLE	 01
X#define WRITEABLE	 02
X#define EXECUTABLE	 04
X#define PERMANENT	010
X#define PIPED		020
X
Xtypedef struct dict_struct *Type;
X
Xtypedef struct object
X {
X 	int flags;
X	Type type;
X	int Length;
X	union
X	 {
X		int Integer, Boolean, Font;
X	 	float Real;
X	 	Type Dictionary;
X	 	unsigned char *String;
X	 	struct name_struct *Name;
X	 	struct op_struct *Operator;
X	 	struct file_struct *File;
X	 	struct object *Array;
X	 } u;
X	
X } Object;
X 
Xenum file_type { StringFile, StreamFile };
X
Xstruct file_struct
X {
X 	enum file_type file_type;
X 	int available;
X 	union
X 	 {
X 	 	unsigned char	*c_ptr;
X 	 	FILE	*f_ptr;
X 	 } f;
X };
X
Xstruct dict_entry
X {
X 	Object entry_key, entry_value;
X };
X
Xstruct dict_struct
X {
X 	int dict_flags, dict_size, dict_fill;
X 	struct dict_entry *dict_body;
X };
X
Xtypedef struct stack
X {
X 	int stack_fill, stack_size;
X 	Object overflow, underflow, *stack_body;
X } *Stack, StackOb;
X 
XObject SameFlags (), MakeObject (), Cvx (), Cvlit (), ReadOnly (), WriteOnly (), ExecOnly ();
Xint OpCheck (), min (), rCheck (), wCheck (), xCheck ();
XObject MakeArray (), ParseArray (), getArray (), getIArray (), *BodyArray ();
XObject MakeBoolean ();
X
X
XObject MakeDict (), DictLoad (), Lookup (), DictFrom (), Load ();
XType MakeType (), TypeOf (), BodyDict ();
X
Xextern int EqTrue (), Equal ();
X
XObject FileFrom (), FileString ();
X
Xint Getch ();
Xstruct file_struct *BodyFile ();
XObject MakeInteger (), IntReal ();
X
XObject ParseNumber ();
Xfloat Deg (), Rad ();
XObject ParseId (), NameFrom (), MakeName (), Cvn (), StringName ();
Xunsigned char *BodyName ();
XObject MakeOp (), NameOperator ();
XObject Parse ();
X
X
Xint PolyFirst (), PolySecond (), PolyThird (), PolyPair ();
X
XObject MakeReal (), RealInteger ();
X
Xfloat BodyReal (), BodyFloat ();
X
Xchar *Malloc ();
XObject Pop (), Top (), Where (), DictLookup ();
Xint Push ();
X
Xextern Object MakeString (), StringFrom (), getIString (), ParseString (), ParseHexString ();
Xunsigned char *BodyString ();
Xint lengthString ();
X
Xextern Object PDictFull;
Xextern Object PDictOverflow,		PInvFont,		PSyntaxError;
Xextern Object PDictUnderflow,		PInvRestore,		PTypeCheck;
Xextern Object PExecOverflow,		PIOError,		PUndefined;
Xextern Object PExecUnderflow,		PLimitCheck,		PUnFilename;
Xextern Object PInterrupt,		PNoCurrentPoint,	PUnResult;
Xextern Object PInvAccess,		PRangeCheck,		PUnMatched;
Xextern Object PInvExit,			POpOverflow,		PUnregistered;
Xextern Object PInvFileAccess,		POpUnderflow,		PVMError;
X
Xextern Type Boolean, Mark, String, Real, Poly, Operator;
Xextern Type Name, File, Dictionary, Condition, Null, Integer;
Xextern Type Array, Mark, Condition, Null, Float, FontID;
X
Xextern Object SysDict, Absent, Nil;
Xextern Object True, False, Marker, Self;
Xextern Object OpInterp, Lbracket, Rbracket;
Xextern Object StatementEdit, Fstdin, Fstdout, Fstderr;
X
Xextern Stack OpStack, ExecStack, DictStack;
Xextern jmp_buf env;
Xextern int interactive, verbose;
Xextern char default_library[], *library;
Xextern unsigned char *Bcopy ();
Xextern FILE *vfp, *Fopen ();
Xextern void Fclose ();
X
X
X#define TypeOf(a) 	((a).type)
X
X#define Push(stack, object) (((stack)->stack_fill != (stack)->stack_size) ?	\
X		((stack)->stack_body[(stack)->stack_fill] = (object), (stack)->stack_fill++, TRUE) : FALSE)
X
X#define Pop(stack) 	((stack)->stack_body[--(stack)->stack_fill])
X
X#define Top(stack)	((stack)->stack_body[(stack)->stack_fill - 1])
X
X#define Height(stack)	((stack)->stack_fill)
X
X#define MaxStack(stack)		((stack)->stack_size)
X
Xextern int getchbuf;
X
X#define BodyFile(file) ((file).u.File)
X
X#define StatusFile(file) (BodyFile(file)->available != 0)
X
X#define Getch(file) ((StatusFile(file) && BodyFile(file)->file_type == StreamFile) ?\
X	((getchbuf = getc (BodyFile(file)->f.f_ptr)), \
X		((getchbuf != EOF) ? getchbuf : ((BodyFile(file)->available = 0), Close (file), EOF))) \
X	: GeneralGetch (file))
END_OF_FILE
if test 4101 -ne `wc -c <'source/main.h'`; then
    echo shar: \"'source/main.h'\" unpacked with wrong size!
fi
# end of 'source/main.h'
fi
if test -f 'source/mat.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/mat.c'\"
else
echo shar: Extracting \"'source/mat.c'\" \(2868 characters\)
sed "s/^X//" >'source/mat.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X#include "graphics.h"
X
XMatrix identity =   { 1.0, 0.0, 0.0, 1.0, 0.0, 0.0 };
X
XMatrix NewMatrix (A, B, C, D, tx, ty) float A, B, C, D, tx, ty;
X {
X 	Matrix m;
X 	
X 	m.A = A; m.B = B; m.C = C; m.D = D; m.tx = tx; m.ty = ty;
X 	
X 	return m;
X }
X
XVector NewVector (A, B, vt) float A, B, vt;
X {
X 	Vector v;
X 	
X 	v.vx = A; v.vy = B; v.vt = vt;
X 	
X 	return v;
X }
X
XMatrix Translate (m, x, y) Matrix m; float x, y;
X {
X 	return NewMatrix (m.A,				   m.B,
X 			   m.C,				   m.D,
X 			   x * m.A + y * m.C + m.tx, x * m.B + y * m.D + m.ty);
X }
X
XHereTranslate (pm, p) Matrix *pm; Point p;
X {
X 	pm->tx += p.x * pm->A + p.y * pm->C;
X 	pm->ty += p.x * pm->B + p.y * pm->D;
X }
X
XMatrix Scale (m, x, y) Matrix m; float x, y;
X {
X	return NewMatrix (m.A * x, 	m.B * x,
X			   m.C * y,	m.D * y,
X			   m.tx,	m.ty);
X }
X
XMatrix Rotate (m, a) Matrix m; float a;
X {
X 	float ca = cos(a), sa = sin(a);
X 	
X 	return NewMatrix (m.A * ca + m.C * sa, m.B * ca + m.D * sa,
X 			   m.C * ca - m.A * sa, m.D * ca - m.B * sa,
X 			   m.tx,		m.ty);
X }
X
XMatrix MatMult (a, b) Matrix a, b;
X {
X 	return NewMatrix ( a.A  * b.A + a.B * b.C, 	   a.A * b.B + a.B * b.D,
X 			   a.C  * b.A + a.D * b.C, 	   a.C * b.B + a.D * b.D,
X 			   a.tx * b.A + a.ty * b.C + b.tx, a.tx * b.B + a.ty * b.D + b.ty);
X }
X
XMatrix MatInvert (m) Matrix m;		/* know any good matrix inversion algorithms ? */
X {					/* this one will be simplistic */
X 	float det = m.A * m.D - m.B * m.C;
X 	
X	return NewMatrix (m.D / det, 			  -m.B / det,
X			 -m.C  / det, 			   m.A / det,
X			 (m.C * m.ty - m.D * m.tx) / det, -(m.A * m.ty - m.B * m.tx) / det);
X }
X
XVector Transform (v, m) Vector v; Matrix m;
X {
X 	return NewVector (v.vx * m.A + v.vy * m.C + v.vt * m.tx,
X 			   v.vx * m.B + v.vy * m.D + v.vt * m.ty,
X 			   v.vt);
X }
X
XVector DTransform (v, m) Vector v; Matrix m;
X {
X 	return NewVector (v.vx * m.A + v.vy * m.C,
X 			   v.vx * m.B + v.vy * m.D,
X 			   v.vt);
X }
X
XVector ITransform (v, mi) Vector v; Matrix mi;
X {
X 	Matrix m;
X 	
X 	m = MatInvert (mi);
X 	return NewVector (v.vx * m.A + v.vy * m.C + v.vt * m.tx,
X 			   v.vx * m.B + v.vy * m.D + v.vt * m.ty,
X 			   v.vt);
X }
X
XVector IDTransform (v, mi) Vector v; Matrix mi;
X {
X 	Matrix m;
X 	
X 	m = MatInvert (mi);
X 	return NewVector (v.vx * m.A + v.vy * m.C,
X 			   v.vx * m.B + v.vy * m.D,
X 			   v.vt);
X }
X
XVector DiffVector (a, o) Vector a, o;
X {
X 	return NewVector (a.vx - o.vx, a.vy - o.vy, 1.0);
X }
END_OF_FILE
if test 2868 -ne `wc -c <'source/mat.c'`; then
    echo shar: \"'source/mat.c'\" unpacked with wrong size!
fi
# end of 'source/mat.c'
fi
if test -f 'source/name.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/name.c'\"
else
echo shar: Extracting \"'source/name.c'\" \(4755 characters\)
sed "s/^X//" >'source/name.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X
Xstruct name_struct
X {
X	struct name_struct *next_name, *prev_name;
X 	int string_length;
X 	unsigned char *string_body;
X };
X
Xstatic int Cvs (), EqEq (), Eq (), ExecName ();
Xstatic Object OpExecName;
X
XObject Self;
X
XInitName ()
X {
X 	OpExecName = MakeOp ("exec", ExecName,	1, 1, 0, 4, Name);
X 	
X	TypeInstall (Name, "exec", 	OpExecName);
X	
X 	TypeInstallOp (Name, "==", 	EqEq,	1, 0, 0, 0, Name);
X  	TypeInstallOp (Name, "cvs", 	Cvs,	2, 1, 0, 0, Name, String);
X	TypeInstallOp (Name, "eq", 	Eq, 	2, 1, 0, 0, Name, Name);
X }
X
Xunsigned char *BodyName (item) Object item;
X {
X 	return item.u.Name->string_body;
X }
X
Xint lengthName (item) Object item;
X {
X 	return item.u.Name->string_length;
X }
X
Xstatic int Cvs (v, string) Object v, string;
X {
X 	int length;
X 	
X	if (lengthString (string) < (length = lengthName (v)))
X		return Error (PRangeCheck);
X	VOID Bcopy (BodyString (string), BodyName (v), length);
X	return Push (OpStack, getIString (string, 0, length));
X }
X
Xstatic int EqEq (v) Object v;
X {
X	if (!xCheck (v))
X		putchar ('/');
X	PrintName (v);
X	return TRUE;
X }
X
Xstatic int Eq (a, b) Object a, b;
X {
X	return Push (OpStack, MakeBoolean (BodyName (a) == BodyName (b) && lengthName (a) == lengthName (b)));
X }
X
Xstatic int ExecName (item) Object item;
X {
X 	Object v;
X 	
X 	v = DictLookup (item);
X	if (TypeOf (v) == Condition)
X	 	return Error (PUndefined);
X	else
X		return Push (ExecStack, v);
X }
X
Xstatic struct name_struct *name_tree = NULL;
X
Xstatic struct name_struct *FindTreeName (s, length, root) unsigned char *s; int length; struct name_struct **root;
X {
X	if (*root)
X	 {
X	 	int cmp = strncmp (s, (*root)->string_body, min (length, (*root)->string_length));
X	 	
X		if (cmp == 0 && (cmp = length - (*root)->string_length) == 0)
X			return *root;
X		else if (cmp < 0)
X			return FindTreeName (s, length, &(*root)->prev_name);
X		else
X			return FindTreeName (s, length, &(*root)->next_name);
X	 }
X	else
X	 {
X 		struct name_struct *r = *root = (struct name_struct *) Malloc (sizeof (struct name_struct));
X 		
X		r->next_name = r->prev_name = NULL;
X		r->string_body = Bcopy (Malloc ((unsigned) length), s, length);
X		r->string_length = length;
X		
X		return *root;
X	 }
X }
X
Xstatic int HashName (s, length) unsigned char *s; int length;
X {
X	int i, res = 0;
X	
X	while (length--)
X		res += *s++;
X	return res;
X }
X
Xint name_tries = 0, name_hits = 0;
X
X#define HASH_NAME_SIZE	1024
X
Xstatic struct name_struct *hash_name [HASH_NAME_SIZE];
X
Xstatic struct name_struct *FindName (s, length) unsigned char *s; int length;
X {
X 	int hash = HashName (s, length);
X 	struct name_struct *p;
X 	
X 	hash &= (HASH_NAME_SIZE - 1);
X 	
X 	p = hash_name [hash];
X 	++name_tries;
X 	++name_hits;
X 	
X 	if (p == NULL || p->string_length != length || strncmp (s, p->string_body, length))
X 	 {
X		p = FindTreeName (s, length, &name_tree);
X 	 	
X 	 	if (p != NULL)
X 	 	 {
X 	 		hash_name [hash] = p;
X 	 		--name_hits;
X 	 	 }
X 	 }
X 	return p;
X }
X
XObject MakeName (s, length) unsigned char *s; int length;
X {
X 	Object res;
X 	
X 	res = MakeObject (Name);
X 	res.u.Name = FindName (s, length);
X 	
X 	return res;
X }
X
XObject NameFrom (s) unsigned char *s;
X {
X 	Object res;
X	
X 	res = MakeObject (Name);
X 	res.u.Name = FindName (s, strlen (s));
X 	
X 	return res;
X }
X
XObject Cvn (o) Object o;
X {
X	Object res;
X	
X	res = MakeObject (Name);
X	res.u.Name = FindName (BodyString (o), lengthString (o));
X	
X	return res;
X }
X
XObject StringName (o) Object o;
X {
X 	return MakeString (BodyName (o), lengthName (o));
X }
X
XPrintName (n) Object n;
X {
X 	printf ("%.*s", lengthName (n), BodyName (n));
X }
X
XObject ParseId (o) Object o;
X {
X	unsigned char buf[BUFSIZE], *p = buf;
X	int c, length = 0, immediate = FALSE;
X	Object number;
X	
X	if ((c = Getch (o)) == '/')
X		immediate = TRUE;
X	else
X		Ungetch (o, c);
X	
X	for (;;)
X	 {
X	 	switch (c = Getch (o))
X		 {
X		 	case EOF: case ' ': case '\t': case '\n':
X		 	    break;
X		 	
X		 	case '/': case '<': case '>': case '(': case ')':
X			case '%': case '{': case '}': case '[': case ']':
X				Ungetch (o, c);
X			    break;
X			
X			default:
X				*p++ = c; ++length;
X			    continue;
X		 }
X		break;
X	 }
X	if (length == 0)
X		return Absent;
X	
X	number = ParseNumber (buf, length);
X	if (TypeOf (number) != Null)
X		return number;
X	else if (immediate)
X	 	return Load (MakeName (buf, length));
X	else
X		return MakeName (buf, length);
X }
END_OF_FILE
if test 4755 -ne `wc -c <'source/name.c'`; then
    echo shar: \"'source/name.c'\" unpacked with wrong size!
fi
# end of 'source/name.c'
fi
if test -f 'source/poly.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/poly.c'\"
else
echo shar: Extracting \"'source/poly.c'\" \(4311 characters\)
sed "s/^X//" >'source/poly.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X
Xstatic int Copy ();
X
Xint PolyFirst (), PolySecond (), PolyThird (), PolyPair ();
X
XInitPoly ()
X {
X 	Lbracket = Cvx (NameFrom("["));
X	Rbracket = Cvx (NameFrom("]"));
X	
X	InstallOp ("token",		PolyFirst,	1, 1, 0, 0, Poly);
X	InstallOp ("copy",		Copy, 		0, 0, 0, 0);
X	InstallOp ("length",		PolyFirst,	1, 1, 0, 0, Poly);
X	InstallOp ("forall",		PolySecond,	2, 2, 0, 0, Poly, Poly);
X	InstallOp ("get",		PolySecond,	2, 2, 0, 0, Poly, Poly);
X	InstallOp ("put",		PolyThird,	3, 3, 0, 0, Poly, Poly, Poly);
X	InstallOp ("getinterval",	PolyThird,	3, 3, 0, 0, Poly, Poly, Poly);
X	InstallOp ("putinterval",	PolyThird,	3, 3, 0, 0, Poly, Poly, Poly);
X	InstallOp ("signature",		PolyFirst,	1, 0, 0, 0, Poly);
X }
X
XObject Parse (f) Object f;
X {
X 	Object res;
X 	int c;
X 	
X	for (;;)
X	 switch (c = Getch (f))
X	  {
X	 	default:  Ungetch (f, c);
X	 		res = ParseId (f);
X	 		if (TypeOf (res) == Integer || TypeOf (res) == Real)
X	 			return res;
X	 		else
X	 			return Cvx (res);
X	 	
X		case '/': return ParseId (f);
X		case '{': return Cvx (ParseArray (f));
X		case '}': return True;
X		case '[': return Lbracket;
X		case ']': return Rbracket;
X		case '<': return ParseHexString (f);
X		case '(': return ParseString (f);
X		case ')': return Absent;
X		
X	 	case EOF: return False;
X	 	
X	 	case ' ':
X	 	case '\t':
X 		case '\n':
X	 		/* nothing */
X	 	    continue;
X	 	
X 		case '%':
X 			while ((c = Getch (f)) != '\n' && c != EOF)
X 				;
X 			Ungetch (f, c);
X 		    continue;
X	  }
X }
X
X/*
X * The following are a few of the polymorphic generic routines which actually get called
X * by user PostScript.
X * They call type-checked routines on behalf of the types of their arguments.
X *
X */
X
Xint PolyFirst (arg1) Object arg1;	/* type dictionary choice determined by top of stack */
X {
X  	if (!Apply (TypeOf (arg1)))
X 		return Error (PTypeCheck);
X	return Push (OpStack, arg1);
X }
X
Xint PolySecond (arg1, arg2) Object arg1, arg2;	/* type dictionary choice determined by first from top of stack */
X {
X 	if (!Apply (TypeOf (arg1)))
X 		return Error (PTypeCheck);
X 	return Push (OpStack, arg1), Push (OpStack, arg2);
X }
X
Xint PolyThird (arg1, arg2, arg3) Object arg1, arg2, arg3;	/* type dictionary choice determined by second from top of stack */
X {
X 	if (!Apply (TypeOf (arg1)))
X 		return Error (PTypeCheck);
X 	return Push (OpStack, arg1), Push (OpStack, arg2), Push (OpStack, arg3);
X }
X
Xint PolyPair (arg1, arg2) Object arg1, arg2;
X {
X	if (TypeOf (arg1) == Integer && TypeOf (arg2) == Real)
X 		arg1 = RealInteger (arg1);
X 	else if (TypeOf (arg2) == Integer && TypeOf (arg1) == Real)
X 		arg2 = RealInteger (arg2);
X 	if (TypeOf (arg1) != TypeOf (arg2))
X		return Error (PTypeCheck);
X 	if (!Apply (TypeOf (arg1)))
X 		return Error (PTypeCheck);
X	return Push (OpStack, arg1), Push (OpStack, arg2);
X }
X
Xint Apply (type) Type type;
X {
X 	Object fn;
X 	
X 	fn = Lookup (type, Self);
X 	if (TypeOf (fn) == Condition)
X 		return Error (PTypeCheck);
X 	else
X 		return Push (ExecStack, fn);
X }
X
Xstatic int Copy ()	/* any1 . . . anyn N	--- any1 . . . anyn any1 . . . anyn */
X		/* other1  other2	--- subother2 */
X {
X	Object object1, object2;
X	int h = Height (OpStack);
X	
X	object2 = Pop (OpStack);
X	if (h == 0)
X		return Error (POpUnderflow);
X	else if (TypeOf (object2) == Integer)
X	 {
X	  	int n = BodyInteger (object2);
X	  	
X	 	if (n < 0 || n >= h)
X			return Error (PRangeCheck);
X	 	else if (h - 1 + n > MaxStack (OpStack))
X			return Error (POpOverflow);
X	 	else
X	 	 {
X	 	 	int i;
X	 	 	
X	 	 	for (i = h - 1 - n; i < h; i++)
X	 	 		OpStack->stack_body[i+n] = OpStack->stack_body[i];
X	 	 	OpStack->stack_fill += n;
X	 	 	return TRUE;
X	 	 }
X 	 }
X 	object1 = Top (OpStack);
X 	VOID Push (OpStack, object2);
X 	if (TypeOf (object1) != TypeOf (object2))
X		return Error (PTypeCheck);
X	else if (!rCheck (object1) || !wCheck (object2))
X		return Error (PInvAccess);
X	else
X 		return Apply (TypeOf (object1));
X }
END_OF_FILE
if test 4311 -ne `wc -c <'source/poly.c'`; then
    echo shar: \"'source/poly.c'\" unpacked with wrong size!
fi
# end of 'source/poly.c'
fi
if test -f 'source/property.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/property.c'\"
else
echo shar: Extracting \"'source/property.c'\" \(3240 characters\)
sed "s/^X//" >'source/property.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X
Xstatic int PCvs (), PCvrs (), PCvn (), PType (), PCvlit(), PxCheck ();
Xint PCvx ();
X
XObject type;
X
XInitProperty ()
X {
X 	type = NameFrom ("type");
X 	
X 	InstallOp ("type",		PType,		1, 1, 0, 0, Poly);
X 	InstallOp ("cvlit",		PCvlit,		1, 1, 0, 0, Poly);
X 	InstallOp ("cvn",		PCvn,		1, 1, 0, 0, String);
X 	InstallOp ("cvrs",		PCvrs,		3, 1, 0, 0, Integer, Integer, String);
X 	InstallOp ("cvs",		PCvs,		2, 1, 0, 0, Poly, String);
X 	InstallOp ("cvx",		PCvx,		1, 1, 0, 0, Poly);
X 	InstallOp ("xcheck",		PxCheck,	1, 1, 0, 0, Poly);
X	InstallOp ("cvi",		PolyFirst, 	1, 1, 0, 0, Poly);
X	InstallOp ("cvr",		PolyFirst, 	1, 1, 0, 0, Poly);
X	InstallOp ("readonly",		PolyFirst, 	1, 1, 0, 0, Poly);
X	InstallOp ("rcheck",		PolyFirst, 	1, 1, 0, 0, Poly);
X	InstallOp ("wcheck",		PolyFirst, 	1, 1, 0, 0, Poly);
X	InstallOp ("executeonly",	PolyFirst, 	1, 1, 0, 0, Poly);
X }
X
Xstatic int PType (item) Object item;
X {
X 	return Push (OpStack, Lookup (TypeOf (item), type));
X }
X
Xstatic int PCvs (item, string) Object item, string;
X {
X 	int l;
X 	Object t;
X 	
X 	t = Lookup (TypeOf (item), NameFrom ("cvs"));
X	if (TypeOf (t) == Condition)
X		if (lengthString (string) < (l = strlen ("--nostringval--")))
X			return Error (PRangeCheck);
X		else
X		 {
X		 	putIString (string, 0, StringFrom ("--nostringval--"));
X		 	return Push (OpStack, getIString (string, 0, l));
X		 }
X	else
X	 {
X		VOID Push (OpStack, item);
X		VOID Push (OpStack, string);
X 		return Apply (TypeOf (item));
X 	 }
X }
X
Xstatic int PCvlit (item) Object item;
X {
X 	return Push (OpStack, Cvlit (item));
X }
X
Xstatic int PCvn (string) Object string;
X {
X 	return Push (OpStack, SameFlags (string, Cvn (string)));
X }
X
Xstatic int PCvrs (num, base, string) Object num, base, string;
X {
X 	unsigned n = BodyInteger (num);
X	unsigned char buf [BUFSIZE], *p = buf, *q = BodyString (string);
X	int b, length;
X 	
X 	if (!wCheck (string))
X 		return Error (PInvAccess);
X 	else if ((b = BodyInteger (base)) < 2 || b > 36)
X 		return Error (PRangeCheck);
X 	do {
X 		int dig_val = n % b;
X 		
X 		n /= b;
X 		*p++ = dig_val >= 10 ? 'A' + dig_val - 10 : '0' + dig_val;
X 	} while (n != 0);
X 	
X 	if ((length = p - buf) > lengthString (string))
X 		return Error (PRangeCheck);
X 	
X 	while (--p >= buf)
X 		*q++ = *p;
X 	return Push (OpStack, getIString (string, 0, length));
X }
X
X/*ARGSUSED*/
Xint NoStringVal (v, string) Object v, string;
X {
X 	char *mess = "--nostringval--";
X 	int length = strlen (mess);
X 	
X	if (lengthString (string) < length)
X		return Error (PRangeCheck);
X	VOID Bcopy (BodyString (string), mess, length);
X	return Push (OpStack, getIString (string, 0, length));
X }
X
Xint PCvx (item) Object item;
X {
X 	return Push (OpStack, Cvx (item));
X }
X
Xstatic int PxCheck (item) Object item;
X {
X 	return Push (OpStack, MakeBoolean (xCheck (item)));
X }
END_OF_FILE
if test 3240 -ne `wc -c <'source/property.c'`; then
    echo shar: \"'source/property.c'\" unpacked with wrong size!
fi
# end of 'source/property.c'
fi
if test -f 'source/protocol.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/protocol.c'\"
else
echo shar: Extracting \"'source/protocol.c'\" \(3325 characters\)
sed "s/^X//" >'source/protocol.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include <stdio.h>
X
X#include "main.h"
X#include "graphics.h"
X#include "protocol.h"
X
X#define SCALE 16384
X
Xstatic FILE *devfpi, *devfpo;
Xchar *getenv (), *strcpy (), *strcat ();
Xunsigned char getb ();
X
Xvoid master_protocol ()
X {
X 	char name [BUFSIZ], *e = getenv ("POSTSCRIPTDEVICE");
X 	
X 	if (e == NULL || *e == '\0')
X 		VOID strcpy (name, "|viewer");
X 	else
X 		VOID strcpy (name, e);
X 	if (*name == '|')
X 	 {
X 	 	int ip[2], op[2];
X 	 	
X 	 	pipe (ip);
X 	 	pipe (op);
X 	 	devfpi = fdopen (ip[0], "r");
X 	 	devfpo = fdopen (op[1], "w");
X 	 	
X 	 	if (fork () == 0)
X 	 	 {
X 	 	 	dup2 (op[0], 0);
X 	 	 	dup2 (ip[1], 1);
X 	 	 	close (op[1]);
X 	 	 	close (ip[0]);
X 	 	 	
X 	 	 	execl ("/bin/sh", "PSDEV", "-c", name + 1, NULL);
X 	 	 	fprintf (stderr, "NO SHELL!\n");
X 	 	 	exit (1);
X 	 	 }
X 	 	else
X 	 	 {
X 	 	 	close (op[0]);
X 	 	 	close (ip[1]);
X 	 	 }
X 	 }
X 	else if (*name == '%')
X 	 {
X 	 	devfpi = fopen (name + 1, "r");
X 	 	devfpo = fopen (name + 1, "w");
X 	 }
X 	else
X 	 {
X 	 	devfpi = NULL;
X 	 	devfpo = fopen (name, "w");
X 	 }
X }
X
Xvoid slave_protocol ()
X {
X	devfpi = stdin;
X	devfpo = stdout;
X }
X
Xvoid send_colour (colour) Colour colour;
X {
X 	send_small (colour.hue);
X 	send_small (colour.saturation);
X 	send_small (colour.brightness);
X }
X
XColour recv_colour ()
X {
X 	Colour res;
X 	
X 	res.hue = recv_small ();
X 	res.saturation = recv_small ();
X 	res.brightness = recv_small ();
X 	
X 	return res;
X }
X
Xvoid send_small (f) float f;
X {
X 	send_short ((int) (f * SCALE));
X }
X
Xfloat recv_small ()
X {
X	return (float) recv_short () / SCALE;
X }
X
Xvoid send_point (p) DevicePoint p;
X {
X	send_short (p.dx);
X	send_short (p.dy);
X }
X
XDevicePoint recv_point ()
X {
X	short r = recv_short ();
X	
X	return NewDevicePoint (r, recv_short ());
X }
X
Xvoid send_byte (b) unsigned char b;
X {
X	putc (b, devfpo);
X }
X
Xunsigned char recv_byte ()
X {
X	return getb (devfpi);
X }
X
Xvoid send_short (i) short i;
X {
X 	send_byte (i & 0xff);
X 	send_byte (i >> 8);
X }
X
Xshort recv_short ()
X {
X	short i;
X	
X	i = recv_byte () & 0xff;
X	i |= recv_byte () << 8;
X	
X	return i;
X }
X
Xvoid send_float (f) float f;
X {
X	fprintf (devfpo, "%g\n", f);
X }
X
Xfloat recv_float ()
X {
X 	float f;
X 	char buf [BUFSIZ], *p = buf;
X 	
X 	while ((*p++ = getb (devfpi)) != '\n')
X 		;
X 	*p++ = '\0';
X 	sscanf (buf, "%f\n", &f);
X 	
X 	return f;
X }
X
Xvoid send_string (s, len) char *s; int len;
X {
X 	PanicIf (len != fwrite (s, 1, len, devfpo), "could not send bitmap from driver");
X }
X
Xvoid recv_string (s, len) char *s; int len;
X {
X 	while (len--)
X 		*s++ = getb (devfpi);
X }
X
Xvoid flush_protocol ()
X {
X 	fflush (devfpo);
X }
X
Xint can_recv ()
X {
X 	return devfpi != NULL;
X }
X 
Xchar buffer [BUFSIZ], *p;
Xint remaining = 0;
X
Xunsigned char getb (fp) FILE *fp;
X {
X 	if (remaining > 0)
X 	 {
X 	 	--remaining;
X 	 	return *p++;
X 	 }
X 	if ((remaining = read (fp->_file, buffer, BUFSIZ)) <= 0)
X 	 	exit (1);
X 	p = buffer;
X 	return getb (fp);
X }
END_OF_FILE
if test 3325 -ne `wc -c <'source/protocol.c'`; then
    echo shar: \"'source/protocol.c'\" unpacked with wrong size!
fi
# end of 'source/protocol.c'
fi
if test -f 'source/screen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/screen.c'\"
else
echo shar: Extracting \"'source/screen.c'\" \(3510 characters\)
sed "s/^X//" >'source/screen.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X#include "graphics.h"
X#include "canon.h"
X
X/********************************** SET TRANSFER STUFF **********************************/
X
X#define TRANSFER_SIZE	256
X
Xstatic int transfer [TRANSFER_SIZE];
X
Xvoid InitTransfer (ppi) int ppi;
X {
X 	int i;
X 	
X 	pixels_per_inch = ppi;
X 	for (i = 0; i < TRANSFER_SIZE; i++)
X 		transfer [i] = i;
X }
X
Xint HardColour (colour) Colour colour;
X {
X	return transfer [(int) ((TRANSFER_SIZE - 1) * colour.brightness + .5)];
X }
X
Xint TransferSize ()
X {
X	return TRANSFER_SIZE;
X }
X
Xvoid SetTransfer (tran) float *tran;
X {
X 	int i;
X 	
X 	for (i = 0; i < TRANSFER_SIZE; i++)
X 		transfer [i] = (TRANSFER_SIZE - 1) * tran[i] + .5;
X }
X
X/********************************** SET SCREEN STUFF *******************************/
X
Xstruct screen
X {
X 	float val;
X 	int sx, sy;
X 	struct hardware *shade;
X } *screen = NULL;
X
Xstatic int screen_size, screen_side;
X
Xstatic int FreqSize (freq) float freq;
X {
X 	int i = pixels_per_inch / freq + 0.5;
X 	
X 	if (i < 2)
X		return 2;
X	return i;
X }
X
Xstruct hardware *GraySync (col) int col;
X {
X 	col = col * (float) screen_size / TRANSFER_SIZE + 0.5;
X 	
X 	return screen[col].shade;
X }
X
Xint ScreenSize (freq, rot) float freq, rot;
X {
X 	int size = FreqSize (freq);
X 	
X 	return size * size;
X }
X
Xvoid BuildScreen (freq, rotation, x, y) float freq, rotation, *x, *y;
X {
X 	int size = FreqSize (freq);
X 	int i, j;
X 	
X 	for (i = 0; i < size; i++)
X 		for (j = 0; j < size; j++)
X 			*x++ = (2 * i - size + 1) / (float) size,
X 			*y++ = (2 * j - size + 1) / (float) size;
X }
X
Xstatic sgn (a) float a;
X {
X	if (a == 0)
X		return 0;
X	else if (a < 0)
X		return -1;
X	else
X		return 1;
X }
X
Xstatic int screen_cmp (a, b) char *a, *b;
X {
X 	struct screen *aa = (struct screen *) a, *bb = (struct screen *) b;
X 	
X 	return sgn (aa->val - bb->val);
X }
X
Xvoid SetScreen (freq, rotation, thresh) float freq, rotation, *thresh;
X {
X 	struct hardware *temp;
X 	int i, j, size = FreqSize (freq);
X 	struct screen *p;
X 	
X 	if (screen)
X 	 {
X 	 	for (i = 0; i < screen_size; i++)
X 	 		DestroyHardware (screen [i].shade);
X 	 	free ((char *) screen);
X 	 }
X 	p = screen = (struct screen *) Malloc ((unsigned) (((screen_size = size * size) + 1) * sizeof (struct screen)));
X 	screen_side = size;
X 	for (i = 0; i < size; i++)
X 		for (j = 0; j < size; j++)
X 		 {
X 		 	p->val = *thresh++;
X 		 	p->sx = i;
X 		 	p->sy = j;
X 		 	++p;
X 		 }
X 	qsort ((char *) screen, screen_size, sizeof (struct screen), screen_cmp);
X 	temp = NewBitmapHardware (size, size);
X 	BitBlt ((struct hardware *) NULL, temp, NewDevicePoint (0, 0), NewDevicePoint (0, 0), NewDevicePoint (size, size), ROP_TRUE);
X 	
X 	for (i = 0; i < screen_size; i++)
X 	 {
X 	 	screen [i].shade = NewBitmapHardware (size, size);
X 	 	BitBlt (temp, screen[i].shade,
X 	 			NewDevicePoint (0, 0), NewDevicePoint (0, 0),
X 	 			NewDevicePoint (size, size), ROP_SOURCE);
X 	 	BitBlt ((struct hardware *) NULL, temp,
X 	 			NewDevicePoint (0, 0), NewDevicePoint (screen[i].sx, screen[i].sy),
X 	 			NewDevicePoint (1, 1), ROP_FALSE);
X 	 }
X 	screen[screen_size].shade = temp;
X }
END_OF_FILE
if test 3510 -ne `wc -c <'source/screen.c'`; then
    echo shar: \"'source/screen.c'\" unpacked with wrong size!
fi
# end of 'source/screen.c'
fi
if test -f 'source/unix.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/unix.c'\"
else
echo shar: Extracting \"'source/unix.c'\" \(3133 characters\)
sed "s/^X//" >'source/unix.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X#include <signal.h>
X
Xstatic int Chdir (), Fork (), Execv (), Wait (), Exit (), System (), Signal (), Kill ();
X
XInitUnix ()
X {
X 	InstallOp ("chdir",	Chdir,	1, 1, 0, 0, String);
X 	InstallOp ("fork",	Fork,	0, 1, 0, 0);
X  	InstallOp ("wait",	Wait,	0, 5, 0, 0);
X  	InstallOp ("uexit",	Exit,	1, 0, 0, 0, Integer);
X  	InstallOp ("execv",	Execv,	2, 0, 0, 0, Array, String);
X  	InstallOp ("system",	System,	1, 1, 0, 0, String);
X  	InstallOp ("signal", 	Signal, 2, 1, 0, 0, Integer, Integer);
X  	InstallOp ("kill",	Kill,	2, 1, 0, 0, Integer, Integer);
X}
X
Xstatic int Chdir (dir) Object dir;
X {
X 	char buffer [BUFSIZE];
X 	int l = lengthString (dir);
X 	
X 	VOID strncpy (buffer, BodyString (dir), l);
X 	buffer [l] = '\0';
X 	
X 	return Push (OpStack, MakeBoolean (!chdir (buffer)));
X }
X
Xstatic int Fork ()
X {
X 	return Push (OpStack, MakeInteger (fork ()));
X }
X
Xstatic int Exit (status) Object status;
X {
X 	exit (BodyInteger (status));
X 	
X 	return TRUE; /* shuts lint up */
X }
X
Xstatic int Wait ()
X {
X 	int pid, status;
X 	
X 	if ((pid = wait (&status)) < 0)
X 		return Push (OpStack, False);
X 	return Push (OpStack, MakeBoolean (status & 0200))
X 		&& Push (OpStack, MakeInteger (status & 0177))
X 		&& Push (OpStack, MakeInteger (status >> 8))
X 		&& Push (OpStack, MakeInteger (pid))
X 		&& Push (OpStack, True);
X }
X
Xstatic int Execv (args, name) Object args, name;
X {
X 	int i, nl, l = lengthArray (args);
X 	char **av = (char **) Malloc ((unsigned) (l+1) * sizeof (char *));
X 	char buffer [BUFSIZE];
X 	
X 	for (i = 0; i < l; i++)
X 	 {
X 	 	Object elem;
X 	 	
X 	 	elem = getArray (args, i);
X 		if (TypeOf (elem) != String)
X 			return Error (PTypeCheck);
X 		else
X 		 {
X 		 	int l = lengthString (elem);
X 		 	
X 			av[i] = Malloc ((unsigned) l + 1);
X 			VOID strncpy (av[i], BodyString (elem), l);
X 			av[i][l] = '\0';
X 		 }
X 	 }
X 	av[l] = NULL;
X 	
X 	nl = lengthString (name);
X 	VOID strncpy (buffer, BodyString (name), nl);
X 	buffer [nl] = '\0';
X 	
X 	if (execv (buffer, av) == -1)
X 	 {
X 	 	for (i = 0; i < l; i++)
X 	 		Free (av[i]);
X 	 	Free ((char *) av);
X 	 	
X 	 	return Error (PInvFileAccess);
X 	 }
X 	return TRUE;
X }
X
Xstatic int System (s) Object s;
X {
X 	char buffer [BUFSIZE];
X 	int l = lengthString (s);
X 	
X 	VOID strncpy (buffer, BodyString (s), l);
X 	buffer [l] = '\0';
X 	return Push (OpStack, MakeInteger (system (buffer)));
X }
X
Xstatic int Signal (n, s) Object n, s;
X {
X	int sn = BodyInteger (n);
X	
X 	if (sn < 1 || sn > NSIG)
X 		return Error (PRangeCheck);
X	return Push (OpStack, MakeInteger (signal (sn, BodyInteger (s))));
X }
X
Xstatic int Kill (n, s) Object n, s;
X {
X 	return Push (OpStack, MakeBoolean (0 == kill (BodyInteger (n), BodyInteger (s))));
X }
END_OF_FILE
if test 3133 -ne `wc -c <'source/unix.c'`; then
    echo shar: \"'source/unix.c'\" unpacked with wrong size!
fi
# end of 'source/unix.c'
fi
echo shar: End of archive 2 \(of 18\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
