Subject:  v12i058:  A PostScript interpreter, Part09/18
Newsgroups: comp.sources.unix
Sender: sources
Approved: rs@uunet.UU.NET

Submitted-by: Crispin Goswell <caag@vd.rl.ac.uk>
Posting-number: Volume 12, Issue 58
Archive-name: postscript/part09

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 9 (of 18)."
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'postscript/fonts/Times/russian.r' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'postscript/fonts/Times/russian.r'\"
else
echo shar: Extracting \"'postscript/fonts/Times/russian.r'\" \(11645 characters\)
sed "s/^X//" >'postscript/fonts/Times/russian.r' <<'END_OF_FILE'
XCharStrings
X/2901
X<C53D
X453E
X443E
X443D
X453C
X473B
X4B3B
X4D3C
X4E3D
X4F3F
X4F46
X5048
X5149
XCE3D
X4E46
X4F48
X5149
X5249
XCE3F
X4D40
X4741
X4442
X4344
X4346
X4448
X4749
X4A49
X4C48
X4E46
XC741
X4542
X4444
X4446
X4548
X4749
X>
Xput
XMetrics
X/2901
X[-3
X20]
Xput
XCharStrings
X/2902
X<D034
X4F35
X4937
X4639
X443C
X433F
X4343
X4446
X4648
X4949
X4B49
X4E48
X5046
X5143
X5141
X503E
X4E3C
X4B3B
X493B
X463C
X443E
X4341
XD034
X4F36
X4D37
X4938
X463A
X443C
XC93B
X473C
X453E
X4441
X4443
X4546
X4748
X4949
XCB49
X4D48
X4F46
X5043
X5041
X4F3E
X4D3C
X4B3B
X>
Xput
XMetrics
X/2902
X[2
X20]
Xput
XCharStrings
X/2903
X<C53B
X4549
XC63B
X4649
XC23B
X4D3B
X503C
X513E
X513F
X5041
X4D42
XCD3B
X4F3C
X503E
X503F
X4F41
X4D42
XC642
X4D42
X5043
X5145
X5146
X5048
X4D49
X4249
XCD42
X4F43
X5045
X5046
X4F48
X4D49
X>
Xput
XMetrics
X/2903
X[-2
X20]
Xput
XCharStrings
X/2904
X<C53B
X4549
XC63B
X4649
XC23B
X503B
X5040
X4F3B
XC249
X4949
X>
Xput
XMetrics
X/2904
X[-2
X18]
Xput
XCharStrings
X/2905
X<C83B
X483F
X4745
X4648
X4549
XD13B
X5149
XD23B
X5249
XC53B
X553B
XC349
X424E
X4249
X5549
X554E
X5449
X>
Xput
XMetrics
X/2905
X[-2
X23]
Xput
XCharStrings
X/2906
X<C441
X5041
X503F
X4F3D
X4E3C
X4C3B
X493B
X463C
X443E
X4341
X4343
X4446
X4648
X4949
X4B49
X4E48
X5046
XCF41
X4F3E
X4E3C
XC93B
X473C
X453E
X4441
X4443
X4546
X4748
X4949
X>
Xput
XMetrics
X/2906
X[-3
X19]
Xput
XCharStrings
X/2907
X<CD3B
X4D49
XCE3B
X4E49
XCA3B
X513B
XC53C
X443D
X433C
X443B
X453B
X463C
X4840
X4941
X4B42
X5042
X5241
X5340
X553C
X563B
X573B
X583C
X573D
X563C
XCB42
X4943
X4844
X4648
X4549
XCB42
X4944
X4748
X4649
X4449
X4348
X4246
XD042
X5243
X5344
X5548
X5649
XD042
X5244
X5448
X5549
X5749
X5848
X5946
XCA49
X5149
X>
Xput
XMetrics
X/2907
X[-2
X27]
Xput
XCharStrings
X/2908
X<C43D
X433B
X433F
X443D
X453C
X473B
X4B3B
X4E3C
X4F3E
X4F3F
X4E41
X4B42
XCB3B
X4D3C
X4E3E
X4E3F
X4D41
X4B42
XC842
X4B42
X4E43
X4F45
X4F46
X4E48
X4B49
X4749
X4448
X4346
X4345
X4444
X4545
X4446
XCB42
X4D43
X4E45
X4E46
X4D48
X4B49
X>
Xput
XMetrics
X/2908
X[-3
X18]
Xput
XCharStrings
X/2909
X<C53B
X4549
XC63B
X4649
XD03B
X5049
XD13B
X5149
XC23B
X493B
XCD3B
X543B
XC249
X4949
XCD49
X5449
XD03C
X4648
X>
Xput
XMetrics
X/2909
X[-2
X22]
Xput
XCharStrings
X/2910
X<C53B
X4549
XC63B
X4649
XD03B
X5049
XD13B
X5149
XC23B
X493B
XCD3B
X543B
XC249
X4949
XCD49
X5449
XD03C
X4648
XC835
X4834
X4734
X4735
X4837
X4A38
X4C38
X4E37
X4F35
X>
Xput
XMetrics
X/2910
X[1
X22]
Xput
XCharStrings
X/2911
X<C53B
X4549
XC63B
X4649
XC23B
X493B
XC642
X4842
X4B41
X4C40
X4E3C
X4F3B
X503B
X513C
X503D
X4F3C
XC842
X4B43
X4C44
X4E48
X4F49
XC842
X4A43
X4B44
X4D48
X4E49
X5049
X5148
X5246
XC249
X4949
X>
Xput
XMetrics
X/2911
X[-2
X20]
Xput
XCharStrings
X/2912
X<C73B
X473F
X4645
X4548
X4449
X4349
X4248
X4347
X4448
XD03B
X5049
XD13B
X5149
XC43B
X543B
XCD49
X5449
X>
Xput
XMetrics
X/2912
X[-2
X22]
Xput
XCharStrings
X/2913
X<C53B
X4549
XC53B
X4B49
XC63B
X4B47
XD13B
X4B49
XD13B
X5149
XD23B
X5249
XC23B
X463B
XD13B
X553B
XC249
X4849
XCE49
X5549
X>
Xput
XMetrics
X/2913
X[-2
X23]
Xput
XCharStrings
X/2914
X<C53B
X4549
XC63B
X4649
XD03B
X5049
XD13B
X5149
XC23B
X493B
XCD3B
X543B
XC642
X5042
XC249
X4949
XCD49
X5449
X>
Xput
XMetrics
X/2914
X[-2
X22]
Xput
XCharStrings
X/2915
X<C93B
X463C
X443E
X4341
X4343
X4446
X4648
X4949
X4B49
X4E48
X5046
X5143
X5141
X503E
X4E3C
X4B3B
X493B
XC93B
X473C
X453E
X4441
X4443
X4546
X4748
X4949
XCB49
X4D48
X4F46
X5043
X5041
X4F3E
X4D3C
X4B3B
X>
Xput
XMetrics
X/2915
X[-3
X20]
Xput
XCharStrings
X/2916
X<C53B
X4549
XC63B
X4649
XD03B
X5049
XD13B
X5149
XC23B
X543B
XC249
X4949
XCD49
X5449
X>
Xput
XMetrics
X/2916
X[-2
X22]
Xput
XCharStrings
X/2917
X<C53B
X4550
XC63B
X4650
XC63E
X483C
X4A3B
X4C3B
X4F3C
X513E
X5241
X5243
X5146
X4F48
X4C49
X4A49
X4848
X4646
XCC3B
X4E3C
X503E
X5141
X5143
X5046
X4E48
X4C49
XC23B
X463B
XC250
X4950
X>
Xput
XMetrics
X/2917
X[-2
X21]
Xput
XCharStrings
X/2918
X<CF3E
X4E3F
X4F40
X503F
X503E
X4E3C
X4C3B
X493B
X463C
X443E
X4341
X4343
X4446
X4648
X4949
X4B49
X4E48
X5046
XC93B
X473C
X453E
X4441
X4443
X4546
X4748
X4949
X>
Xput
XMetrics
X/2918
X[-3
X19]
Xput
XCharStrings
X/2919
X<C93B
X4949
XCA3B
X4A49
XC43B
X4340
X433B
X503B
X5040
X4F3B
XC649
X4D49
X>
Xput
XMetrics
X/2919
X[-3
X19]
Xput
XCharStrings
X/2920
X<C33B
X4949
XC43B
X4947
XCF3B
X4949
X474D
X454F
X4350
X4250
X414F
X424E
X434F
XC13B
X473B
XCB3B
X513B
X>
Xput
XMetrics
X/2920
X[-1
X18]
Xput
XCharStrings
X/2921
X<CA34
X4A50
XCB34
X4B50
XC734
X4B34
XCA3E
X493C
X483B
X463B
X443C
X433F
X4345
X4448
X4649
X4849
X4948
X4A46
XC63B
X453C
X443F
X4445
X4548
X4649
XCF3B
X503C
X513F
X5145
X5048
X4F49
XCB3E
X4C3C
X4D3B
X4F3B
X513C
X523F
X5245
X5148
X4F49
X4D49
X4C48
X4B46
XC750
X4E50
X>
Xput
XMetrics
X/2921
X[2
X21]
Xput
XCharStrings
X/2922
X<C43B
X4F49
XC53B
X5049
XD03B
X4449
XC23B
X483B
XCC3B
X523B
XC249
X4849
XCC49
X5249
X>
Xput
XMetrics
X/2922
X[-2
X20]
Xput
XCharStrings
X/2923
X<C53B
X4549
XC63B
X4649
XD03B
X5049
XD13B
X5149
XC23B
X493B
XCD3B
X543B
XC249
X5449
X544E
X5349
X>
Xput
XMetrics
X/2923
X[-2
X22]
Xput
XCharStrings
X/2924
X<C53B
X4542
X4644
X4945
X4B45
X4E44
X5042
XC63B
X4642
X4744
X4945
XD03B
X5049
XD13B
X5149
XC23B
X493B
XCD3B
X543B
XCD49
X5449
X>
Xput
XMetrics
X/2924
X[-2
X22]
Xput
XCharStrings
X/2925
X<C53B
X4549
XC63B
X4649
XCF3B
X4F49
XD03B
X5049
XD93B
X5949
XDA3B
X5A49
XC23B
X493B
XCC3B
X533B
XD63B
X5D3B
XC249
X5D49
X>
Xput
XMetrics
X/2925
X[-2
X31]
Xput
XCharStrings
X/2926
X<C53B
X4549
XC63B
X4649
XCF3B
X4F49
XD03B
X5049
XD93B
X5949
XDA3B
X5A49
XC23B
X493B
XCC3B
X533B
XD63B
X5D3B
XC249
X5D49
X5D4E
X5C49
X>
Xput
XMetrics
X/2926
X[-2
X31]
Xput
XCharStrings
X/2927
X<C93B
X4949
XCA3B
X4A49
XC43B
X4340
X433B
X4D3B
XCA42
X4E42
X5143
X5245
X5246
X5148
X4E49
X4649
XCE42
X5043
X5145
X5146
X5048
X4E49
X>
Xput
XMetrics
X/2927
X[-3
X21]
Xput
XCharStrings
X/2928
X<C53B
X4549
XC63B
X4649
XC23B
X493B
XC642
X4A42
X4D43
X4E45
X4E46
X4D48
X4A49
X4249
XCA42
X4C43
X4D45
X4D46
X4C48
X4A49
XD43B
X5449
XD53B
X5549
XD13B
X583B
XD149
X5849
X>
Xput
XMetrics
X/2928
X[-2
X26]
Xput
XCharStrings
X/2929
X<C53B
X4549
XC63B
X4649
XC23B
X493B
XC642
X4A42
X4D43
X4E45
X4E46
X4D48
X4A49
X4249
XCA42
X4C43
X4D45
X4D46
X4C48
X4A49
X>
Xput
XMetrics
X/2929
X[-2
X17]
Xput
XCharStrings
X/2930
X<C43D
X433B
X433F
X443D
X453C
X473B
X4A3B
X4D3C
X4F3E
X5041
X5043
X4F46
X4D48
X4A49
X4749
X4548
X4346
X4345
X4444
X4545
X4446
XCA3B
X4C3C
X4E3E
X4F41
X4F43
X4E46
X4C48
X4A49
XC942
X4F42
X>
Xput
XMetrics
X/2930
X[-3
X19]
Xput
XCharStrings
X/2931
X<C53B
X4549
XC63B
X4649
XC23B
X493B
XC249
X4949
XD23B
X4F3C
X4D3E
X4C41
X4C43
X4D46
X4F48
X5249
X5449
X5748
X5946
X5A43
X5A41
X593E
X573C
X543B
X523B
XD23B
X503C
X4E3E
X4D41
X4D43
X4E46
X5048
X5249
XD449
X5648
X5846
X5943
X5941
X583E
X563C
X543B
XC642
X4C42
X>
Xput
XMetrics
X/2931
X[-2
X29]
Xput
XCharStrings
X/2932
X<CF3B
X4F49
XD03B
X5049
XD33B
X483B
X453C
X443E
X443F
X4541
X4842
X4F42
XC83B
X463C
X453E
X453F
X4641
X4842
XCD42
X4A43
X4944
X4748
X4649
XCD42
X4B43
X4A44
X4848
X4749
X4549
X4448
X4346
XCC49
X5349
X>
Xput
XMetrics
X/2932
X[-3
X21]
Xput
XCharStrings
X/2801
X<CA34
X4349
XCA34
X5149
XCA37
X5049
XC543
X4E43
XC149
X4749
XCD49
X5349
X>
Xput
XMetrics
X/2801
X[2
X20]
Xput
XCharStrings
X/2802
X<C534
X4549
XC634
X4649
XC234
X5234
X523A
X5134
XC63E
X4E3E
X513F
X5240
X5342
X5345
X5247
X5148
X4E49
X4249
XCE3E
X503F
X5140
X5242
X5245
X5147
X5048
X4E49
X>
Xput
XMetrics
X/2802
X[1
X22]
Xput
XCharStrings
X/2803
X<C534
X4549
XC634
X4649
XC234
X4E34
X5135
X5236
X5338
X533A
X523C
X513D
X4E3E
XCE34
X5035
X5136
X5238
X523A
X513C
X503D
X4E3E
XC63E
X4E3E
X513F
X5240
X5342
X5345
X5247
X5148
X4E49
X4249
XCE3E
X503F
X5140
X5242
X5245
X5147
X5048
X4E49
X>
Xput
XMetrics
X/2803
X[1
X22]
Xput
XCharStrings
X/2804
X<C534
X4549
XC634
X4649
XC234
X5134
X513A
X5034
XC249
X4949
X>
Xput
XMetrics
X/2804
X[3
X18]
Xput
XCharStrings
X/2805
X<C834
X483A
X4742
X4646
X4548
X4449
XD234
X5249
XD334
X5349
XC534
X5634
XC149
X5649
XC149
X4150
XC249
X4150
XD549
X5650
XD649
X5650
X>
Xput
XMetrics
X/2805
X[0
X24]
Xput
XCharStrings
X/2806
X<C534
X4549
XC634
X4649
XCC3A
X4C42
XC234
X5234
X523A
X5134
XC63E
X4C3E
XC249
X5249
X5243
X5149
X>
Xput
XMetrics
X/2806
X[1
X21]
Xput
XCharStrings
X/2807
X<CF34
X4F49
XD034
X5049
XCC34
X5334
XC435
X4536
X4437
X4336
X4335
X4434
X4534
X4635
X4737
X483B
X493D
X4B3E
X543E
X563D
X573B
X5837
X5935
X5A34
X5B34
X5C35
X5C36
X5B37
X5A36
X5B35
XCB3E
X493F
X4841
X4746
X4648
X4549
XCB3E
X4A3F
X4941
X4846
X4748
X4649
X4449
X4348
X4246
XD43E
X563F
X5741
X5846
X5948
X5A49
XD43E
X553F
X5641
X5746
X5848
X5949
X5B49
X5C48
X5D46
XCC49
X5349
X>
Xput
XMetrics
X/2807
X[-2
X31]
Xput
XCharStrings
X/2808
X<C437
X4334
X433A
X4437
X4635
X4834
X4C34
X4F35
X5037
X503A
X4F3C
X4C3D
X493D
XCC34
X4E35
X4F37
X4F3A
X4E3C
X4C3D
XCC3D
X4E3E
X5040
X5142
X5145
X5047
X4F48
X4C49
X4749
X4548
X4447
X4345
X4344
X4443
X4544
X4445
XCF3F
X5042
X5045
X4F47
X4E48
X4C49
X>
Xput
XMetrics
X/2808
X[2
X20]
Xput
XCharStrings
X/2809
X<C534
X4549
XC634
X4649
XD234
X5249
XD334
X5349
XC234
X4934
XCF34
X5634
XD236
X4647
XC249
X4949
XCF49
X5649
X>
Xput
XMetrics
X/2809
X[0
X24]
Xput
XCharStrings
X/2810
X<C534
X4549
XC634
X4649
XD234
X5249
XD334
X5349
XC234
X4934
XCF34
X5634
XD236
X4647
XC249
X4949
XCF49
X5649
XC82E
X482D
X472D
X472E
X4830
X4A31
X4E31
X5030
X512E
X>
Xput
XMetrics
X/2810
X[7
X24]
Xput
XCharStrings
X/2811
X<C534
X4549
XC634
X4649
XC234
X4934
XC63E
X4D3E
X4F3D
X503B
X5137
X5235
X5334
X5434
X5535
X5536
X5437
X5336
X5435
XCD3E
X4F3F
X5041
X5146
X5248
X5349
XCD3E
X4E3F
X4F41
X5046
X5148
X5249
X5449
X5548
X5646
XC249
X4949
X>
Xput
XMetrics
X/2811
X[0
X24]
Xput
XCharStrings
X/2812
X<C834
X483A
X4742
X4646
X4548
X4449
X4349
X4248
X4247
X4346
X4447
X4348
XD334
X5349
XD434
X5449
XC534
X5734
XD049
X5749
X>
Xput
XMetrics
X/2812
X[-1
X25]
Xput
XCharStrings
X/2813
X<C534
X4549
XC634
X4C46
XC534
X4C49
XD334
X4C49
XD334
X5349
XD434
X5449
XC234
X4634
XD334
X5734
XC249
X4849
XD049
X5749
X>
Xput
XMetrics
X/2813
X[0
X25]
Xput
XCharStrings
X/2814
X<C534
X4549
XC634
X4649
XD234
X5249
XD334
X5349
XC234
X4934
XCF34
X5634
XC63E
X523E
XC249
X4949
XCF49
X5649
X>
Xput
XMetrics
X/2814
X[0
X24]
Xput
XCharStrings
X/2815
X<CA34
X4735
X4537
X4439
X433D
X4340
X4444
X4546
X4748
X4A49
X4C49
X4F48
X5146
X5244
X5340
X533D
X5239
X5137
X4F35
X4C34
X4A34
XCA34
X4835
X4637
X4539
X443D
X4440
X4544
X4646
X4848
X4A49
XCC49
X4E48
X5046
X5144
X5240
X523D
X5139
X5037
X4E35
X4C34
X>
Xput
XMetrics
X/2815
X[1
X22]
Xput
XCharStrings
X/2816
X<C534
X4549
XC634
X4649
XD234
X5249
XD334
X5349
XC234
X5634
XC249
X4949
XCF49
X5649
X>
Xput
XMetrics
X/2816
X[0
X24]
Xput
XCharStrings
X/2817
X<C534
X4549
XC634
X4649
XC234
X4E34
X5135
X5236
X5338
X533B
X523D
X513E
X4E3F
X463F
XCE34
X5035
X5136
X5238
X523B
X513D
X503E
X4E3F
XC249
X4949
X>
Xput
XMetrics
X/2817
X[1
X22]
Xput
XCharStrings
X/2818
X<D137
X523A
X5234
X5137
X4F35
X4C34
X4A34
X4735
X4537
X4439
X433C
X4341
X4444
X4546
X4748
X4A49
X4C49
X4F48
X5146
X5244
XCA34
X4835
X4637
X4539
X443C
X4441
X4544
X4646
X4848
X4A49
X>
Xput
XMetrics
X/2818
X[1
X21]
Xput
XCharStrings
X/2819
X<C934
X4949
XCA34
X4A49
XC334
X423A
X4234
X5134
X513A
X5034
XC649
X4D49
X>
Xput
XMetrics
X/2819
X[3
X19]
Xput
XCharStrings
X/2820
X<C334
X4A44
XC434
X4B44
XD234
X4B44
X4947
X4848
X4649
X4549
X4448
X4447
X4546
X4647
X4548
XC134
X4734
XCE34
X5434
X>
Xput
XMetrics
X/2820
X[2
X21]
Xput
XCharStrings
X/2821
X<CC34
X4C49
XCD34
X4D49
XC934
X5034
XCA37
X4638
X443A
X433D
X4340
X4443
X4645
X4A46
X4F46
X5345
X5543
X5640
X563D
X553A
X5338
X4F37
X4A37
XCA37
X4738
X453A
X443D
X4440
X4543
X4745
X4A46
XCF46
X5245
X5443
X5540
X553D
X543A
X5238
X4F37
XC949
X5049
X>
Xput
XMetrics
X/2821
X[0
X25]
Xput
XCharStrings
X/2822
X<C334
X5049
XC434
X5149
XD134
X4349
XC134
X4734
XCD34
X5334
XC149
X4749
XCD49
X5349
X>
Xput
XMetrics
X/2822
X[2
X20]
Xput
XCharStrings
X/2823
X<C534
X4549
XC634
X4649
XD234
X5249
XD334
X5349
XC234
X4934
XCF34
X5634
XC249
X5649
XD549
X5650
XD649
X5650
X>
Xput
XMetrics
X/2823
X[0
X24]
Xput
XCharStrings
X/2824
X<C534
X453F
X4641
X4942
X4C42
X4F41
X513F
XC634
X463F
X4741
X4942
XD134
X5149
XD234
X5249
XC234
X4934
XCE34
X5534
XCE49
X5549
X>
Xput
XMetrics
X/2824
X[0
X23]
Xput
XCharStrings
X/2825
X<C534
X4549
XC634
X4649
XD034
X5049
XD134
X5149
XDB34
X5B49
XDC34
X5C49
XC234
X4934
XCD34
X5434
XD834
X5F34
XC249
X5F49
X>
Xput
XMetrics
X/2825
X[-2
X33]
Xput
XCharStrings
X/2826
X<C534
X4549
XC634
X4649
XD034
X5049
XD134
X5149
XDB34
X5B49
XDC34
X5C49
XC234
X4934
XCD34
X5434
XD834
X5F34
XC249
X5F49
XDE49
X5F50
XDF49
X5F50
X>
Xput
XMetrics
X/2826
X[-2
X33]
Xput
XCharStrings
X/2827
X<CA34
X4A49
XCB34
X4B49
XC334
X423A
X4234
X4E34
XCB3E
X523E
X553F
X5640
X5742
X5745
X5647
X5548
X5249
X4749
XD23E
X543F
X5540
X5642
X5645
X5547
X5448
X5249
X>
Xput
XMetrics
X/2827
X[0
X26]
Xput
XCharStrings
X/2828
X<C534
X4549
XC634
X4649
XC234
X4934
XC63E
X4D3E
X503F
X5140
X5242
X5245
X5147
X5048
X4D49
X4249
XCD3E
X4F3F
X5040
X5142
X5145
X5047
X4F48
X4D49
XD834
X5849
XD934
X5949
XD534
X5C34
XD549
X5C49
X>
Xput
XMetrics
X/2828
X[-2
X30]
Xput
XCharStrings
X/2829
X<C534
X4549
XC634
X4649
XC234
X4934
XC63E
X4D3E
X503F
X5140
X5242
X5245
X5147
X5048
X4D49
X4249
XCD3E
X4F3F
X5040
X5142
X5145
X5047
X4F48
X4D49
X>
Xput
XMetrics
X/2829
X[2
X21]
Xput
XCharStrings
X/2830
X<C437
X4334
X433A
X4437
X4635
X4934
X4B34
X4E35
X5037
X5139
X523C
X5241
X5144
X5046
X4E48
X4B49
X4849
X4548
X4447
X4345
X4344
X4443
X4544
X4445
XCB34
X4D35
X4F37
X5039
X513C
X5141
X5044
X4F46
X4D48
X4B49
XC83E
X513E
X>
Xput
XMetrics
X/2830
X[2
X21]
Xput
XCharStrings
X/2831
X<C534
X4549
XC634
X4649
XC234
X4934
XC249
X4949
XD334
X5035
X4E37
X4D39
X4C3D
X4C40
X4D44
X4E46
X5048
X5349
X5549
X5848
X5A46
X5B44
X5C40
X5C3D
X5B39
X5A37
X5835
X5534
X5334
XD334
X5135
X4F37
X4E39
X4D3D
X4D40
X4E44
X4F46
X5148
X5349
XD549
X5748
X5946
X5A44
X5B40
X5B3D
X5A39
X5937
X5735
X5534
XC63E
X4C3E
X>
Xput
XMetrics
X/2831
X[-2
X31]
Xput
XCharStrings
X/2832
X<D034
X5049
XD134
X5149
XD434
X4834
X4535
X4436
X4338
X433A
X443C
X453D
X483E
X503E
XC834
X4635
X4536
X4438
X443A
X453C
X463D
X483E
XCB3E
X493F
X4840
X4547
X4448
X4348
X4247
XC93F
X4841
X4648
X4549
X4349
X4247
X4246
XCD49
X5449
X>
Xput
XMetrics
X/2832
X[1
X22]
Xput
END_OF_FILE
if test 11645 -ne `wc -c <'postscript/fonts/Times/russian.r'`; then
    echo shar: \"'postscript/fonts/Times/russian.r'\" unpacked with wrong size!
fi
# end of 'postscript/fonts/Times/russian.r'
fi
if test -f 'source/image.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/image.c'\"
else
echo shar: Extracting \"'source/image.c'\" \(11874 characters\)
sed "s/^X//" >'source/image.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X#include "graphics.h"
X
Xstatic int RealImage ();
Xstatic int RealImageMask ();
X
Xstruct hardware *ScaleBitmap ();
X
XInitImage ()
X {
X 	InstallOp ("realimage",		RealImage,	5, 0, 0, 0, Integer, Integer, Integer, Array, String);
X 	InstallOp ("realimagemask",	RealImageMask,	5, 0, 0, 0, Integer, Integer, Boolean, Array, String);
X }
X
Xstatic int RealImageMask (width, height, invert, mat, string) Object width, height, invert, mat, string;
X {
X 	Matrix m, m2;
X 	Vector origin, right, bottom;
X 	int w = BodyInteger (width), h = BodyInteger (height);
X 	int inv = BodyBoolean (invert), l = lengthString (string);
X 	int dwidth, dheight;
X 	unsigned char *s = BodyString (string);
X 	
X  	VOID GSave ();
X	if (!ExtractMatrix (&m, mat))
X 		return Error (PTypeCheck);
X 	if (l != (w + 7) / 8 * h || w < 0 || h < 0)
X 		return Error (PRangeCheck);
X 	if (w == 0 || h == 0)
X 		return TRUE;
X 	m = MatInvert (m);
X 	gstate->CTM = m2 = MatMult (m, gstate->CTM);
X 	origin = Transform (NewVector (0.0, 0.0, 1.0), m2);
X 	right  = Transform (NewVector ((float) w, 0.0, 1.0), m2);
X 	bottom = Transform (NewVector (0.0, (float) h, 1.0), m2);
X 	/* fprintf (stderr, "origin = (%g, %g), right = (%g, %g), bottom = (%g, %g)\n", origin.vx, origin.vy, right.vx, right.vy, bottom.vx, bottom.vy);
X 	fprintf (stderr, "matrix == [%g %g %g %g %g %g]\n", m2.A, m2.B, m2.C, m2.D, m2.tx, m2.ty);*/
X 	
X 	dwidth = right.vx - origin.vx; dheight = bottom.vy - origin.vy;
X 	
X 	if (origin.vx == bottom.vx && origin.vy == right.vy &&
X 			dwidth > 0 && dheight > 0/* && dwidth >= w && dheight >= h*/)
X 	 {		/* simple orientation */
X 	 	struct hardware *from, *to;
X 	 	
X 	 	from = HardwareFromString (s, w, h);
X 	 	if (!inv)
X 	 		BitBlt (from, from,
X 	 			NewDevicePoint (0, 0), NewDevicePoint (0, 0),
X 	 			HardwareExtent (from), ROP_NOTSOURCE);
X 		if (dwidth != w || dheight != h)
X 		 {
X 	 		to = ScaleBitmap (from, (float) dwidth / w, (float) dheight / h);
X 	 		DestroyHardware (from);
X 	 	 }
X 	 	else
X 	 		to = from;
X 	 	
X 	 	Paint (to, gstate->device->dev,
X 	 		NewDevicePoint (0, 0),
X 	 		NewDevicePoint ((int) origin.vx, (int) origin.vy),
X 	 		NewDevicePoint (dwidth, dheight),
X 	 		gstate->colour);
X 	 	DestroyHardware (to);
X 	 }
X 	else
X 		DrawBitmap (s, w, h, inv);
X	VOID GRestore ();
X	
X	return TRUE;
X }
X
XDrawBitmap (s, width, height, inv) unsigned char *s; int width, height, inv;
X {
X 	int w, h;
X 	
X 	VOID PNewPath ();
X 	
X 	for (h = 0; h < height; h++)
X 		for (w = 0; w < width; w++)
X 		 	if (((s [h * (width >> 3) + (w >> 3)] & (1 << (7 - (w & 0x7)))) != 0) == inv)
X  		 	 	FillUnitBox (w, h);
X }
X
Xvoid Tile (t, h) struct hardware *t, *h;
X {
X 	DevicePoint xt, xh;
X 	int i, sw, sh;
X 	
X 	xt = HardwareExtent (t);
X 	xh = HardwareExtent (h);
X 	
X  	BitBlt (t, h, NewDevicePoint (0, 0), NewDevicePoint (0, 0), xt, ROP_SOURCE);
X 	
X 	sw = xt.dx;
X	for (i = sw;;)
X 	 {
X 		BitBlt (h, h, NewDevicePoint (0, 0), NewDevicePoint (i, 0), NewDevicePoint (sw, xt.dy), ROP_SOURCE);
X 		if (i >= xh.dx)
X 			break;
X 		i += sw;
X 		sw <<= 1;
X 	 }
X 	
X 	sh = xt.dy;
X	for (i = sh;;)
X 	 {
X 		BitBlt (h, h, NewDevicePoint (0, 0), NewDevicePoint (0, i), NewDevicePoint (xh.dx, sh), ROP_SOURCE);
X 		if (i >= xh.dy)
X 			break;
X 		i += sh;
X 		sh <<= 1;
X 	 }
X }
X
Xvoid FillMask (h, mask, width) struct hardware *h; char mask; int width;
X {
X 	struct hardware *m;
X 	
X 	mask <<= 8 - width;
X 	
X 	m = HardwareFromString (&mask, width, 1);
X 	
X 	Tile (m, h);
X 	
X 	DestroyHardware (m);
X }
X
Xstruct hardware *UnpaddedHardwareFromString (s, w, h) unsigned char *s; int w, h;
X {
X 	struct hardware *thin;
X 	struct hardware *res;
X 	int i;
X 	
X 	if (w & 7 == 0)
X 		return HardwareFromString (s, w, h);
X 	
X 	thin = HardwareFromString (s, w * h, 1);
X 	res = NewBitmapHardware (w, h);
X 	
X 	for (i = 0; i < h; i++)
X 		BitBlt (thin, res, NewDevicePoint (i * w, 0), NewDevicePoint (0, i), NewDevicePoint (w, 1), ROP_SOURCE);
X 	
X 	DestroyHardware (thin);
X 	return res;
X }
X
Xstatic void VerticalReverseImage (h) struct hardware *h;
X {
X 	DevicePoint ex;
X 	int i, n;
X 	
X 	ex = HardwareExtent (h);
X 	
X 	n = ex.dy;
X 	
X 	for (i = 0; i < n / 2; i++)
X 		BitBlt (h, h, NewDevicePoint (0, i), NewDevicePoint (0, n - i - 1), NewDevicePoint (ex.dx, 1), ROP_XOR),
X 		BitBlt (h, h, NewDevicePoint (0, n - i - 1), NewDevicePoint (0, i), NewDevicePoint (ex.dx, 1), ROP_XOR),
X 		BitBlt (h, h, NewDevicePoint (0, i), NewDevicePoint (0, n - i - 1), NewDevicePoint (ex.dx, 1), ROP_XOR);
X }
X
Xstatic int RealImage (width, height, depth, mat, string) Object width, height, depth, mat, string;
X {
X 	Matrix m, m2;
X 	Vector origin, right, bottom;
X 	int w = BodyInteger (width), h = BodyInteger (height);
X 	int vrev = 0, dep = BodyInteger (depth), l = lengthString (string);
X 	int dwidth, dheight;
X 	unsigned char *s = BodyString (string);
X 	
X   	VOID GSave ();
X	if (!ExtractMatrix (&m, mat))
X 		return Error (PTypeCheck);
X 	if (l != (w * dep + 7) / 8 * h || w < 0 || h < 0)
X 		return Error (PRangeCheck);
X 	if (w == 0 || h == 0)
X 		return TRUE;
X  	m = MatInvert (m);
X 	gstate->CTM = m2 = MatMult (m, gstate->CTM);
X 	origin = Transform (NewVector (0.0, 0.0, 1.0), m2);
X 	right  = Transform (NewVector ((float) w, 0.0, 1.0), m2);
X 	bottom = Transform (NewVector (0.0, (float) h, 1.0), m2);
X 	
X	dwidth = right.vx - origin.vx; dheight = bottom.vy - origin.vy;
X	
X	if (dheight < 0)
X		origin.vy += dheight, right.vy += dheight, ++vrev, dheight = -dheight;
X	
X	/* fprintf (stderr, "origin.vx = %g, origin.vy = %g, bottom.vx = %g, right.vy = %g, dwidth = %d, dheight = %d, w = %d, h = %d\n",
X			origin.vx, origin.vy, bottom.vx, right.vy, dwidth, dheight, w, h); */
X 	
X 	if (dep != 16 && (int) origin.vx == (int) bottom.vx && (int) origin.vy == (int) right.vy &&
X 			dwidth > 0 && dheight > 0/* && dwidth >= w && dheight >= h */)
X 	 {		/* simple orientation */
X 	 	struct hardware *from , *to;
X 	 	
X 	 	if (dep == 1)
X 	 	 {
X 	 		from = HardwareFromString (s, w, h);
X 	 		if (vrev)
X 	 			VerticalReverseImage (from);
X 			if (dwidth != w || dheight != h)
X 			 {
X 	 			to = ScaleBitmap (from, (float) dwidth / w, (float) dheight / h);
X 	 			DestroyHardware (from);
X 	 		 }
X 	 		else
X 	 			to = from;
X 	 		
X			Paint (to, gstate->device->dev,
X				NewDevicePoint (0, 0), NewDevicePoint ((int) origin.vx, (int) origin.vy),
X				NewDevicePoint (dwidth, dheight),
X				NewGray (1.0));
X			BitBlt (to, to,
X				NewDevicePoint (0, 0), NewDevicePoint (0, 0),
X				NewDevicePoint (dwidth, dheight),
X				ROP_NOTSOURCE);
X			Paint (to, gstate->device->dev,
X				NewDevicePoint (0, 0), NewDevicePoint ((int) origin.vx, (int) origin.vy),
X				NewDevicePoint (dwidth, dheight),
X				NewGray (0.0));
X 	 		DestroyHardware (to);
X 	 	 }
X 	 	else
X 	 	 {
X 	 		struct hardware *mask, *new, *temp;
X 	 	 	int i, j;
X 	 	 	
X 	 	 	from = HardwareFromString (s, w * dep, h);
X  	 		if (vrev)
X 	 			VerticalReverseImage (from);
X 	 	 	new = HardwareFromString (s, w, h);
X	 	 	mask = NewBitmapHardware (w * dep, h);
X 	 	 	temp = NewBitmapHardware (w * dep, h);
X 	 	 	
X 	 	 	for (i = 0; i < (1<<dep); i++)
X 	 	 	 {
X 	 	 	 	FillMask (mask, i, dep);
X	 	 	 	
X	 	 	 	BitBlt (from, mask, NewDevicePoint (0, 0), NewDevicePoint (0, 0), HardwareExtent (from), ROP_NXOR);
X	 	 	 	BitBlt (NULL, temp, NewDevicePoint (0, 0), NewDevicePoint (0, 0), HardwareExtent (temp), ROP_TRUE);
X 	 	 	 	for (j = 0; j < dep; j++)
X 	 	 	 		BitBlt (mask, temp, NewDevicePoint (j, 0), NewDevicePoint (0, 0), HardwareExtent (mask), ROP_AND);
X 	 	 	 	for (j = 0; j < w; j++)
X 	 	 	 		BitBlt (temp, new, NewDevicePoint (j * dep, 0), NewDevicePoint (j, 0), NewDevicePoint (1, h), ROP_SOURCE);
X 	 	 	 	to = ScaleBitmap (new, (float) dwidth / w, (float) dheight / h);
X		  	 	Paint (to, gstate->device->dev,
X		 	 		NewDevicePoint (0, 0),
X		 	 		NewDevicePoint ((int) origin.vx, (int) origin.vy),
X		 	 		NewDevicePoint (dwidth, dheight),
X		 	 		NewGray ((float) i / ((1 << dep) - 1)));
X		 	 	DestroyHardware (to);
X	 	 	 }
X 	 		DestroyHardware (from);
X 	 		DestroyHardware (mask);
X 	 		DestroyHardware (temp);
X 	 		DestroyHardware (new);
X 	 	 }
X 	 }
X 	else
X 	 {
X 	 	if (vrev)
X 	 		origin.vy += dheight, right.vy += dheight, dheight = -dheight;
X 		DrawColourBitmap (s, w, h, dep);
X 	 }
X	VOID GRestore ();
X	
X	return TRUE;
X }
X
Xstatic log2[] = { 0, 0, 1, 0, 2, 0, 0, 0, 3 };
Xstatic mask[] = { 0, 0x80, 0xc0, 0, 0xf0, 0, 0, 0, 0xff };
X
XDrawColourBitmap (s, width, height, depth) unsigned char *s; int width, height, depth;
X {
X 	int w, h, c;
X 	
X 	VOID PNewPath ();
X 	
X 	if (depth == 16)
X 		for (h = 0; h < height; h++)
X 			for (w = 0; w < width; w++)
X 		 	 {
X 		 	 	gstate->colour = NewColour (0.0, 0.0, (float) ((s [h * (width << 1) + (w << 1)] << 8) |
X 		 	 						s [h * (width << 1) + (w << 1) + 1]) / (1 << 16));
X 		 	 	FillUnitBox (w, h);
X 		 	 }
X 	else
X 		for (c = 0; c < 1 << depth; c++)
X 		 {
X  		 	gstate->colour = NewColour (0.0, 0.0, (float) c / ((1 << depth) - 1));
X			for (h = 0; h < height; h++)
X 				for (w = 0; w < width; w++)
X 				 {
X 			 		int foo = 3 - log2 [depth];
X 			 		int byte = s [h * (width >> foo) + (w >> foo)];
X 			 		int shift = (w & ((1 << foo) - 1)) * depth;
X 			 		if (c == ((byte & (mask [depth] >> shift)) >> (8 - (shift + depth))))
X 		 	 			FillUnitBox (w, h);
X 		 		 }
X 		  }
X }
X
XFillUnitBox (w, h) int w, h;
X {
X 	VOID MoveTo (gstate->path, ExtToInt (NewPoint ((float ) w, (float ) h)));
X	VOID LineTo (gstate->path, ExtToInt (NewPoint ((float ) w+1, (float ) h)));
X	VOID LineTo (gstate->path, ExtToInt (NewPoint ((float ) w+1, (float ) h+1)));
X	VOID LineTo (gstate->path, ExtToInt (NewPoint ((float ) w, (float ) h+1)));
X	VOID ClosePath (gstate->path);
X	VOID Fill ();
X  }
X
Xstruct hardware *ScaleBitmap (from, xscale, yscale) struct hardware *from; float xscale, yscale;
X {	 	 	
X	struct hardware *middle, *middle2, *high, *high2;
X	int i, w, h, dwidth, dheight, ixscale, iyscale;
X	DevicePoint extent;
X	
X	extent = HardwareExtent (from);
X	w = extent.dx; h = extent.dy;
X	dwidth = w * xscale + 0.5; dheight = h * yscale + 0.5;
X	
X	if (dwidth > w)
X	 {
X		middle = NewBitmapHardware (dwidth, h);
X		for (i = 0; i < w; i++)
X			BitBlt (from, 	middle,
X				NewDevicePoint (i, 0), NewDevicePoint ((int) (i*xscale), 0),
X				NewDevicePoint (1, h),
X				ROP_OR);
X		middle2 = NewBitmapHardware (dwidth, h);
X		ixscale = (int) ((float) dwidth / w + 0.5); 
X		for (i = 0; i < ixscale + 1; i++)
X			BitBlt (middle, middle2,
X				NewDevicePoint (0, 0), NewDevicePoint (i, 0),
X				NewDevicePoint (dwidth - ixscale + 1, h),
X				ROP_OR);
X		DestroyHardware (middle);
X	 }
X	else
X	 {
X	 	middle2 = NewBitmapHardware (dwidth, h);
X		for (i = 0; i < dwidth; i++)
X			BitBlt (from, 	middle2,
X				NewDevicePoint ((int) (i/xscale), 0), NewDevicePoint (i, 0),
X				NewDevicePoint (1, h),
X				ROP_OR);
X	 }
X	
X	if (dheight > h)
X	 {
X		high = NewBitmapHardware (dwidth, dheight);
X		for (i = 0; i < h; i++)
X			BitBlt (middle2, high,
X				NewDevicePoint (0, i), NewDevicePoint (0, (int) (i*yscale)),
X				NewDevicePoint (dwidth, 1),
X				ROP_OR);
X		DestroyHardware (middle2);
X		
X		high2 = NewBitmapHardware (dwidth, dheight);
X		iyscale = (int) ((float) dheight / h + 0.5);
X		for (i = 0; i < iyscale + 1; i++)
X			BitBlt (high, 	high2, 
X				NewDevicePoint (0, 0), NewDevicePoint (0, i),
X				NewDevicePoint (dwidth, dheight - iyscale + 1),
X				ROP_OR);
X		DestroyHardware (high);
X	 }
X	else
X	 {
X		high2 = NewBitmapHardware (dwidth, dheight);
X		for (i = 0; i < dheight; i++)
X			BitBlt (middle2, high2,
X				NewDevicePoint (0, (int) (i/yscale)), NewDevicePoint (0, i),
X				NewDevicePoint (dwidth, 1),
X				ROP_OR);
X	 }
X 	return high2;
X }
END_OF_FILE
if test 11874 -ne `wc -c <'source/image.c'`; then
    echo shar: \"'source/image.c'\" unpacked with wrong size!
fi
# end of 'source/image.c'
fi
if test -f 'source/state.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/state.c'\"
else
echo shar: Extracting \"'source/state.c'\" \(10995 characters\)
sed "s/^X//" >'source/state.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X#include "graphics.h"
X
Xextern int InitGraphics ();
Xint ErasePage ();
Xstatic int CopyPage ();
X
Xstatic int SetLineWidth ();
Xstatic int GetLineWidth ();
Xstatic int SetLineCap ();
Xstatic int GetLineCap ();
Xstatic int SetLineJoin ();
Xstatic int GetLineJoin ();
Xstatic int SetDash ();
Xstatic int GetDash ();
Xstatic int SetFlat ();
Xstatic int GetFlat ();
Xstatic int SetMiterLimit ();
Xstatic int GetMiterLimit ();
Xstatic int SetHSB ();
Xstatic int GetHSB ();
Xstatic int SetRGB ();
Xstatic int GetRGB ();
X
Xstatic int PSetRealScreen ();
Xstatic int PBuildScreen ();
Xstatic int PScreenSize ();
Xstatic int GetScreen ();
X
Xstatic int PSetRealTransfer ();
Xstatic int PGetTransfer ();
Xstatic int PTransferSize ();
X
Xstatic int SetGray ();
Xstatic int GetGray ();
X
Xstatic int SetFillMethod ();
Xstatic int GetFillMethod ();
Xstatic int SetStrokeMethod ();
Xstatic int GetStrokeMethod ();
X
Xint fill_method = 1, stroke_method = 0;
X
XInitState ()
X {
X  	InstallOp ("erasepage",		ErasePage,	0, 0, 0, 0);
X 	InstallOp ("copypage",		CopyPage,	0, 0, 0, 0);
X	InstallOp ("setlinewidth",	SetLineWidth,	1, 0, 0, 0, Float);
X 	InstallOp ("currentlinewidth",	GetLineWidth,	0, 1, 0, 0);
X 	InstallOp ("setlinecap",	SetLineCap,	1, 0, 0, 0, Integer);
X 	InstallOp ("currentlinecap",	GetLineCap,	0, 1, 0, 0);
X 	InstallOp ("setlinejoin",	SetLineJoin,	1, 0, 0, 0, Integer);
X 	InstallOp ("currentlinejoin",	GetLineJoin,	0, 1, 0, 0);
X 	InstallOp ("setdash",		SetDash,	2, 0, 0, 0, Array, Float);
X 	InstallOp ("currentdash",	GetDash,	0, 2, 0, 2);
X 	InstallOp ("setflat",		SetFlat,	1, 0, 0, 0, Float);
X 	InstallOp ("currentflat",	GetFlat,	0, 1, 0, 0);
X 	InstallOp ("setmiterlimit",	SetMiterLimit,	1, 0, 0, 0, Float);
X 	InstallOp ("currentmiterlimit",	GetMiterLimit,	0, 1, 0, 0);
X 	
X 	InstallOp ("setgray",		SetGray,	1, 0, 0, 0, Float);
X 	InstallOp ("currentgray",	GetGray,	0, 1, 0, 0);
X 	InstallOp ("sethsbcolor",	SetHSB,		3, 0, 0, 0, Float, Float, Float);
X 	InstallOp ("currenthsbcolor",	GetHSB,		0, 3, 0, 0);
X 	InstallOp ("setrgbcolor",	SetRGB,		3, 0, 0, 0, Float, Float, Float);
X 	InstallOp ("currentrgbcolor",	GetRGB,		0, 3, 0, 0);
X 	
X  	InstallOp ("screensize",	PScreenSize,	2, 1, 0, 0, Float, Float);
X  	InstallOp ("buildscreen",	PBuildScreen,	2, 2, 0, 0, Float, Float);
X  	InstallOp ("setrealscreen",	PSetRealScreen,	4, 0, 0, 0, Float, Float, Array, Array);
X	InstallOp ("currentscreen",	GetScreen,	0, 3, 0, 0);
X	
X 	InstallOp ("setrealtransfer",	PSetRealTransfer,	2, 0, 0, 0, Array, Array);
X 	InstallOp ("currenttransfer",	PGetTransfer,	0, 1, 0, 0);
X 	InstallOp ("transfersize",	PTransferSize,	0, 1, 0, 0);
X 	
X 	InstallOp ("setfillmethod",	SetFillMethod,	1, 0, 0, 0, Integer);
X 	InstallOp ("currentfillmethod",	GetFillMethod,	0, 1, 0, 0);
X 	InstallOp ("setstrokemethod",	SetStrokeMethod,	1, 0, 0, 0, Integer);
X 	InstallOp ("currentstrokemethod",GetStrokeMethod,	0, 1, 0, 0);
X 	InstallOp ("initgraphics",	InitGraphics,	0, 0, 0, 0);
X
X	VOID InitGraphics ();
X }
X
Xint InitGraphics ()
X {
X 	VOID PInitMatrix ();		/* initmatrix */
X 	VOID InitClip ();		/* initclip */
X 	VOID PNewPath ();		/* newpath */
X 	
X 	gstate->colour = NewColour (0.0, 0.0, 0.0);	/* 0 setgray */
X 	gstate->line_width = 1;		/* 1 setlinewidth */
X 	gstate->line_cap = CBUTT;	/* setlinecap */
X 	gstate->line_join = JMITRE;	/* setlinejoin */
X 	gstate->dash_length = 0;	/* [] 0 setdash */
X 	gstate->dash_offset = 0;	
X 	gstate->miter_limit = 10;	/* 10 setmiterlimit */
X 	InitShowContext ();
X 	
X 	return TRUE;
X }
X
Xint ErasePage ()
X {
X	Paint (NULL, gstate->device->dev,
X		NewDevicePoint (0, 0), NewDevicePoint (0, 0),
X		HardwareExtent (gstate->device->dev),
X		White);
X 	return TRUE;
X }
X
Xstatic int CopyPage ()
X {
X 	return TRUE;
X }
X
Xstatic int SetLineWidth (width) Object width;
X {
X 	gstate->line_width = BodyReal (width);
X 	return TRUE;
X }
X
Xstatic int GetLineWidth ()
X {
X 	return Push (OpStack, MakeReal (gstate->line_width));
X }
X
Xstatic int SetLineCap (cap) Object cap;
X {
X 	int v = BodyInteger (cap);
X 	
X 	if (v < 0 || v > 2)
X 		return Error (PRangeCheck);
X 	gstate->line_cap = v;
X 	return TRUE;
X }
X
Xstatic int GetLineCap ()
X {
X 	return Push (OpStack, MakeInteger (gstate->line_cap));
X }
X
Xstatic int SetLineJoin (join) Object join;
X {
X 	int v = BodyInteger (join);
X 	
X 	if (v < 0 || v > 2)
X 		return Error (PRangeCheck);
X 	gstate->line_join = v;
X 	return TRUE;
X }
X
Xstatic int GetLineJoin ()
X {
X  	return Push (OpStack, MakeInteger (gstate->line_join));
X }
X
Xstatic int SetDash (array, offset) Object array, offset;
X {
X 	Object *v = BodyArray (array);
X	int i, length = lengthArray (array);
X	float sum = 0;
X	
X 	if (length > MAXDASH)
X  		return Error (PLimitCheck);
X  	if (length == 0)
X  	 {
X  	 	gstate->dash_length = 0;
X  	 	return TRUE;
X  	 }
X  	for (i = 0; i < length; i++)
X  	 {
X  	 	float val;
X  	 	
X  		if (TypeOf (v[i]) == Real)
X  			val = BodyReal(v[i]);
X  		else if (TypeOf (v[i]) == Integer)
X  			val = (float) BodyInteger (v[i]);
X  		else
X    			return Error (PLimitCheck);
X 	 	if (val < 0)
X 	 		return Error (PRangeCheck);
X 	 	sum += val;
X    	 }
X  	if (sum == 0)
X 		return Error (PRangeCheck);
X   	 
X 	gstate->dash_length = length;
X 	gstate->dash_offset = BodyReal (offset);
X 	for (i = 0; i < length; i++)
X 	 {
X	 	if (TypeOf (v[i]) == Integer)
X 	 		gstate->dash_array [i] = BodyInteger (v[i]);
X 	 	else
X 	 		gstate->dash_array [i] = BodyReal (v[i]);
X 	 }
X 	return TRUE;
X }
X
Xstatic int GetDash ()
X {
X 	int i;
X 	if (!OpCheck (0, gstate->dash_length + 1))
X 		return FALSE;
X 	VOID Push (OpStack, Marker);
X 	for (i = 0; i < gstate->dash_length; i++)
X 		VOID Push (OpStack, MakeReal (gstate->dash_array[i]));
X 	VOID Push (ExecStack, MakeReal (gstate->dash_offset));
X 	VOID Push (ExecStack, Cvx (Rbracket));
X 	return TRUE;
X }
X
Xstatic int SetFlat (flat) Object flat;
X {
X 	gstate->flatness = BodyReal (flat);
X 	return TRUE;
X }
X
Xstatic int GetFlat ()
X {
X 	return Push (OpStack, MakeInteger (gstate->flatness));
X }
X
Xstatic int SetMiterLimit (miter) Object miter;
X {
X 	float m = BodyReal (miter);
X 	
X 	if (m < 1)
X 		return Error (PRangeCheck);
X 	gstate->miter_limit = m;
X 	return TRUE;
X }
X
Xstatic int GetMiterLimit ()
X {
X 	return Push (OpStack, MakeReal (gstate->miter_limit));
X }
X
Xstatic int SetGray (gray) Object gray;
X {
X 	float g = BodyReal (gray);
X 	
X 	if (g < 0 || g > 1)
X 		return Error (PRangeCheck);
X	gstate->colour = NewGray (g);
X 	
X	return TRUE;
X }
X
Xstatic int GetGray ()
X {
X 	return Push (OpStack, MakeReal (Brightness (gstate->colour)));
X }
X
Xstatic int SetHSB (hue, sat, bright) Object hue, sat, bright;
X {
X 	float h = BodyReal (hue), s = BodyReal (sat), b = BodyReal (bright);
X 	if (h < 0 || h > 1 || s < 0 || s > 1 || b < 0 || b > 1)
X 		return Error (PRangeCheck);
X 	gstate->colour = NewHSBColour (h, s, b);
X 	return TRUE;
X }
X
Xstatic int SetRGB (red, green, blue) Object red, green, blue;
X {
X 	float R = BodyReal (red), G = BodyReal (green), B = BodyReal (blue);
X 	
X 	if (R < 0 || R > 1 || G < 0 || G > 1 || B < 0 || B > 1)
X 		return Error (PRangeCheck);
X 	
X 	gstate->colour = NewRGBColour (R, G, B);
X 	return TRUE;
X }
X
Xstatic int GetHSB ()
X {
X 	float h, s, b;
X 	
X 	ColourHSB (gstate->colour, &h, &s, &b);
X 	VOID Push (OpStack, MakeReal (h));
X 	VOID Push (OpStack, MakeReal (s));
X 	VOID Push (OpStack, MakeReal (b));
X 	
X 	return TRUE;
X }
X
Xstatic int GetRGB ()
X {
X 	float R, G, B;
X	
X	ColourRGB (gstate->colour, &R, &G, &B);
X 	VOID Push (OpStack, MakeReal (R));
X 	VOID Push (OpStack, MakeReal (G));
X 	VOID Push (OpStack, MakeReal (B));
X 	
X	return TRUE;
X }
X
Xstatic int PScreenSize (freq, rot) Object freq, rot;
X {
X 	return Push (OpStack, MakeInteger (ScreenSize (BodyReal (freq), BodyReal (rot))));
X }
X
Xstatic int PBuildScreen (freq, rot) Object freq, rot;
X {
X 	float f = BodyReal (freq), r = BodyReal (rot);
X 	int i, ss = ScreenSize (f, r);
X 	float	*x = (float *) Malloc (sizeof (float) * ss),
X 		*y = (float *) Malloc (sizeof (float) * ss);
X 	
X 	Object *px = (Object *) Malloc (sizeof (Object) * ss),
X  		*py = (Object *) Malloc (sizeof (Object) * ss);
X	
X 	BuildScreen (f, r, x, y);
X 	
X 	for (i = 0; i < ss; i++)
X 	 {
X 	 	px [i] = MakeReal (x[i]);
X 	 	py [i] = MakeReal (y[i]);
X 	 }
X 	Free ((char *) x);
X 	Free ((char *) y);
X 	
X 	return Push (OpStack, MakeArray (px, ss)) && Push (OpStack, MakeArray (py, ss));
X }
X
Xstatic int PSetRealScreen (freq, rot, spot, thresh) Object freq, rot, spot, thresh;
X {
X 	float f = BodyReal (freq), r = BodyReal (rot);
X 	int i, ss = ScreenSize (f, r);
X 	float *th = (float *) Malloc (sizeof (float) * ss);
X 	
X 	gstate->screen.frequency 	= f;
X 	gstate->screen.rotation 	= r;
X 	gstate->screen.spot_function 	= spot;
X 	
X 	if (lengthArray (thresh) != ss)
X 	 {
X 	 	free ((char *) th);
X 	 	return Error (PRangeCheck);
X 	 }
X 	
X 	for (i = 0; i < ss; i++)
X 	 {
X 	 	Object a;
X 	 	
X 	 	a = getArray (thresh, i);
X 	 	if (TypeOf (a) != Real)
X 	 	 {
X 	 	 	Free ((char *) th);
X 	 		return Error (PTypeCheck);
X 	 	 }
X 	 	
X 		th[i] = BodyReal (a);
X 	 }
X 	if (gstate->screen.count == 1)	/* allows 0 to mean 'not assigned yet' */
X 		Free ((char *) gstate->screen.thresh);
X 	gstate->screen.thresh = th;
X 	gstate->screen.count = 1;
X 	
X 	SetScreen (f, r, th);
X 	
X 	return TRUE;
X }
X
Xstatic int GetScreen ()
X {
X 	VOID Push (OpStack, MakeReal (gstate->screen.frequency));
X 	VOID Push (OpStack, MakeReal (gstate->screen.rotation));
X 	VOID Push (OpStack, gstate->screen.spot_function);
X 	return TRUE;
X }
X
Xstatic int PSetRealTransfer (transfer, values) Object transfer, values;
X {
X 	Object v;
X 	int i, size = TransferSize ();
X 	float *val;
X 	
X 	if (lengthArray (values) != size)
X 		return Error (PRangeCheck);
X 	
X 	val = (float *) Malloc (sizeof (float) * size);
X 	for (i = 0; i < size; i++)
X 	 {
X 	 	v = getArray (values, i);
X 	 	if (TypeOf (v) == Real)
X 	 		val [i] = BodyReal (v);
X 	 	else
X 	 	 {
X 	 	 	Free ((char *) val);
X 	 	 	return Error (PTypeCheck);
X 	 	 }
X 	 }
X 	
X 	if (gstate->transfer.tcount == 1)
X 	 	Free ((char *) gstate->transfer.tran);
X 	gstate->transfer.transfn = transfer;
X 	gstate->transfer.tran = val;
X 	gstate->transfer.tcount = 1;
X 	
X 	SetTransfer (val);
X 	
X 	return TRUE;
X }
X
Xstatic int PGetTransfer ()
X {
X 	return Push (OpStack, gstate->transfer.transfn);
X }
X
Xstatic int PTransferSize ()
X {
X	return Push (OpStack, MakeInteger (TransferSize ()));
X }
X
Xstatic int SetFillMethod (method) Object method;
X {
X 	fill_method = BodyInteger (method);
X 	return TRUE;
X }
X
Xstatic int GetFillMethod ()
X {
X 	return Push (OpStack, MakeInteger (fill_method));
X }
X
Xstatic int SetStrokeMethod (method) Object method;
X {
X 	stroke_method = BodyInteger (method);
X 	return TRUE;
X }
X
Xstatic int GetStrokeMethod ()
X {
X 	return Push (OpStack, MakeInteger (stroke_method));
X }
END_OF_FILE
if test 10995 -ne `wc -c <'source/state.c'`; then
    echo shar: \"'source/state.c'\" unpacked with wrong size!
fi
# end of 'source/state.c'
fi
if test -f 'source/stroke.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/stroke.c'\"
else
echo shar: Extracting \"'source/stroke.c'\" \(11211 characters\)
sed "s/^X//" >'source/stroke.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X
X#include "graphics.h"
X
Xint PStrokePath ();
X
Xint in_stroke = FALSE;
X
Xint Stroke ();
X
XInitStroke ()
X {
X 	InstallOp ("strokepath",	PStrokePath,	0, 0, 0, 0);
X 	InstallOp ("stroke",		Stroke,		0, 0, 0, 0);
X }
X
Xint Stroke ()
X {
X 	int res;
X 	
X 	if (!PFlattenPath ())
X 		return FALSE;
X 	if (EmptyPath (gstate->path))
X 		return TRUE;
X 	if (gstate->device->dev == NULL)
X 		return PNewPath ();
X 	if (ThinStroke ())
X 		return TRUE;
X 	in_stroke = TRUE;
X 	res = PStrokePath () && Fill ();
X	VOID PNewPath ();
X	in_stroke = FALSE;
X	
X	return res;
X }
X
Xfloat Magnitude (v) Vector v;
X {
X 	return sqrt (v.vx * v.vx + v.vy * v.vy);
X }
X
Xstatic void Dash ()
X {
X 	Matrix m;
X 	Path p, new = NewPath (), last_move, last_dash;
X 	HardPoint move, here, next;
X 	Vector v, unit;
X 	int marking, start_marking = TRUE, index, start_index = 0;
X 	float dash_left, start_dash_left = gstate->dash_offset;
X 	float umag, dmag;
X 	
X 	m = gstate->CTM;
X 	m = NewMatrix (m.A, m.B, m.C, m.D, 0.0, 0.0);
X 	
X 	while (start_dash_left > gstate->dash_array [start_index])
X 	 {
X 	 	start_dash_left -= gstate->dash_array [start_index];
X 	 	if (++start_index == gstate->dash_length)
X 	 		start_index = 0;
X 	 	start_marking = !start_marking;
X 	 }
X 	start_dash_left = gstate->dash_array [start_index] - start_dash_left;
X 	
X 	for (p = gstate->path->next; p != gstate->path; p = p->next)
X 	 switch (p->ptype)
X 	  {
X 	  	case EMove:
X 	  		index = start_index;
X 	  		marking = start_marking;
X 	  		dash_left = start_dash_left;
X 	  		here = move = p->pe.point;
X 	  		VOID MoveTo (new, here);
X 	  		last_move = last_dash = new->last;
X 	  		break;
X 	  	
X 	  	case ELine:
X 	  	case EClose:
X 	  		next = p->ptype == ELine ? p->pe.point : move;
X 	  		v = NewVector (next.hx - here.hx, next.hy - here.hy, 1.0);
X 	  		dmag = Magnitude (v);
X 	  		if (dmag == 0)
X 	  		 {
X 	  		 	here = next;
X 	  			break;
X 	  		 }
X 	  		umag = Magnitude (ITransform (v, m));
X 	  		unit = NewVector (v.vx / umag, v.vy / umag, 1.0);
X 	  		while (umag > dash_left)
X 	  		 {
X 	  		 	here.hx += unit.vx * dash_left;
X 	  		 	here.hy += unit.vy * dash_left;
X 	  		 	(*(marking ? LineTo : MoveTo)) (new, here);
X 	  		 	if (!marking)
X 	  		 		last_dash = new->last;
X 	  		 	marking = !marking;
X 	  		 	umag -= dash_left;
X 	  		 	if (++index == gstate->dash_length)
X 	  		 		index = 0;
X 	  		 	dash_left = gstate->dash_array [index];
X 	  		 }
X 	  		if (p->ptype == ELine)
X 	  		 {
X 	  		 	dash_left -= umag;
X 	  		 	if (marking)
X 	  		 		VOID LineTo (new, next);
X 	  		 }
X 	  		else
X 	  		 {
X 	  		 	if (marking)
X 	  		 	 {
X 	  		 	 	if (start_marking)
X 	  		 	 		if (last_dash == last_move)
X 	  		 	 			ClosePath (new);
X 	  		 	 		else
X 	  		 	 		 {
X	  		 	 		 /*	LineTo (new, move);	*/
X 	  		 	 			MoveChunk (last_move, last_dash, new->last);
X 	  		 	 		 }
X 	  		 	 	else
X 	  		 	 		VOID LineTo (new, move);
X 	  		 	 }
X 	  		 }
X 	  		here = next;
X 	  		break;
X 	  	
X 	  	default:
X 	  		Panic ("Dash: unknown Path Element type");
X 	  }
X 	PathFree (gstate->path);
X 	gstate->path = new;
X 	gstate->cp = new->next->pe.point;
X }
X
XMoveChunk (dest, begin, end) Path dest, begin, end;
X {
X	dest->ptype = ELine;
X	end->next->last = begin->last;
X	begin->last->next = end->next;
X	dest->last->next = begin;
X	
X	end->next = dest;
X	begin->last = dest->last;
X	dest->last = end;
X }
X
X/*
X * is 'b' to the left of 'a' ? if 'a' carries into 'b' ?
X *
X *			   /
X *			  /
X *			 b
X *			/
X *		       /
X * --------- a -------o
X * 
X */
X
Xleftof (a, b) float a, b;
X {
X	return Normalise (b - a) > 0;
X }
X
XMiter (new, last_angle, angle, width) Path new; float last_angle, angle, width;
X {
X 	Matrix old;
X 	float diff;
X	
X	old = gstate->CTM;
X	if (leftof (last_angle, angle))
X	 {
X	 	diff = angle - last_angle;
X		VOID MoveTo (new, ExtToInt (NewPoint (0.0, 0.0)));
X		gstate->CTM = Rotate (gstate->CTM, -diff);
X		VOID LineTo (new, ExtToInt (NewPoint (0.0, -width / 2)));
X		gstate->CTM = Rotate (gstate->CTM, diff / 2);
X		VOID LineTo (new, ExtToInt (NewPoint (0.0, -(width / 2) / cos (diff / 2))));
X		gstate->CTM = old;
X		VOID LineTo (new, ExtToInt (NewPoint (0.0, -width / 2)));
X	 }	
X	else
X	 {
X	 	diff = last_angle - angle;
X		VOID MoveTo (new, ExtToInt (NewPoint (0.0, 0.0)));
X		VOID LineTo (new, ExtToInt (NewPoint (0.0, width / 2)));
X		gstate->CTM = Rotate (gstate->CTM, diff / 2);
X		VOID LineTo (new, ExtToInt (NewPoint (0.0, (width / 2) / cos (diff / 2))));
X		gstate->CTM = Rotate (gstate->CTM, diff / 2);
X		VOID LineTo (new, ExtToInt (NewPoint (0.0, width / 2)));
X		gstate->CTM = old;
X	 }
X	ClosePath (new);
X }
X
XBevel (new, last_angle, angle, width) Path new; float last_angle, angle, width;
X {
X 	Matrix old;
X 	float diff;
X	
X	old = gstate->CTM;
X	if (leftof (last_angle, angle))
X	 {
X	 	diff = angle - last_angle;
X		VOID MoveTo (new, ExtToInt (NewPoint (0.0, 0.0)));
X		gstate->CTM = Rotate (gstate->CTM, -diff);
X		VOID LineTo (new, ExtToInt (NewPoint (0.0, -width / 2)));
X		gstate->CTM = old;
X		VOID LineTo (new, ExtToInt (NewPoint (0.0, -width / 2)));
X	 }
X	else
X	 {
X	 	diff = last_angle - angle;
X		VOID MoveTo (new, ExtToInt (NewPoint (0.0, 0.0)));
X		VOID LineTo (new, ExtToInt (NewPoint (0.0, width / 2)));
X		gstate->CTM = Rotate (gstate->CTM, diff);
X		VOID LineTo (new, ExtToInt (NewPoint (0.0, width / 2)));
X		gstate->CTM = old;
X	 }
X	ClosePath (new);
X }
X
XBeginCap (new, width) Path new; float width;
X {
X	switch (gstate->line_cap)
X	 {
X	 	case CBUTT: break;
X	 	
X	 	case CSQUARE:
X	 		VOID MoveTo (new, ExtToInt (NewPoint (0.0, -width / 2)));
X	 		VOID LineTo (new, ExtToInt (NewPoint (0.0, width / 2)));
X	 		VOID LineTo (new, ExtToInt (NewPoint (-width / 2, width / 2)));
X	 		VOID LineTo (new, ExtToInt (NewPoint (-width / 2, -width / 2)));
X	 		ClosePath (new);
X	 		break;
X	 		
X	 	case CROUND:
X	 		VOID MoveTo (new, ExtToInt (NewPoint (0.0, width / 2)));
X	 		Arc (new, 1, NewPoint (0.0, 0.0), width / 2, PI / 2, 3 * PI / 2);
X	 		ClosePath (new);
X	 		break;
X	 		
X	 	default:
X	 		Panic ("BeginCap  - unknown line cap encountered");
X	 }
X }
X
XLineJoin (new, width, last_angle, angle) Path new; float width, last_angle, angle;
X {
X 	float ang, sa;
X 	
X	switch (gstate->line_join)
X	 {
X	 	case JMITRE:
X	 		ang = Normalise (leftof (last_angle, angle) ? angle - last_angle : last_angle - angle);
X	 		ang = ang < 0 ? -ang : ang;
X	 		ang = ang > PI / 2 ? PI - ang : ang;
X	 		sa = sin (ang / 2);
X	 		if (sa != 0 && 1 / sa <= gstate->miter_limit && 1 / sa >= -gstate->miter_limit)
X	 			Miter (new, last_angle, angle, width);
X	 		else
X	 			Bevel (new, last_angle, angle, width);
X	 		
X	 		break;
X	 	
X	 	case JROUND:
X	 		VOID MoveTo (new, ExtToInt (NewPoint (width / 2, 0.0)));
X	 		Arc (new, 1, NewPoint (0.0, 0.0), width / 2, 0.0, 2 * PI);
X	 		ClosePath (new);
X	 		break;
X	 	
X	 	case JBEVEL: Bevel (new, last_angle, angle, width); break;
X	 	
X	 	default:
X	 		Panic ("LineJoin  - unknown line join encountered");
X	 }
X }
X
XEndCap (new, width, length) Path new; float width, length;
X {
X	switch (gstate->line_cap)
X	 {
X	 	case CBUTT: break;
X	 	
X	 	case CSQUARE:
X	 		VOID MoveTo (new, ExtToInt (NewPoint (length, -width / 2)));
X	 		VOID LineTo (new, ExtToInt (NewPoint (length + width / 2, -width / 2)));
X	 		VOID LineTo (new, ExtToInt (NewPoint (length + width / 2, width / 2)));
X	 		VOID LineTo (new, ExtToInt (NewPoint (length, width / 2)));
X	 		ClosePath (new);
X	 		break;
X	 		
X	 	case CROUND:
X	 		VOID MoveTo (new, ExtToInt (NewPoint (length, -width / 2)));
X	 		Arc (new, 1, NewPoint (length, 0.0), width / 2, -PI / 2, PI / 2);
X	 		ClosePath (new);
X	 		break;
X	 		
X	 	default:
X	 		Panic ("StrokeLineEnd  - unknown line cap encountered");
X	 }
X }
X
Xstatic float move_angle;
Xstatic Matrix move_matrix;
X
Xfloat LineSegment (p, new, ehere, enow, width, last_angle, last_type) Path p, new; Point ehere, enow; float width, last_angle; enum pelem_type last_type;
X {
X 	float angle = atan2 (enow.y - ehere.y, enow.x - ehere.x),
X 		length = sqrt ((enow.y - ehere.y) * (enow.y - ehere.y) + (enow.x - ehere.x) * (enow.x - ehere.x));
X	Matrix old;
X	
X	old = gstate->CTM;
X	
X	gstate->CTM = Rotate (Translate (gstate->CTM, ehere.x, ehere.y), angle);
X	VOID MoveTo (new, ExtToInt (NewPoint (0.0, -width / 2)));
X	VOID LineTo (new, ExtToInt (NewPoint (length, -width / 2)));
X	VOID LineTo (new, ExtToInt (NewPoint (length, width / 2)));
X	VOID LineTo (new, ExtToInt (NewPoint (0.0, width / 2)));
X	ClosePath (new);
X	
X	if (last_type == EMove)
X	 {
X	 	move_angle = angle;
X		move_matrix = gstate->CTM;
X	 }
X	else if (last_type == ELine)
X		LineJoin (new, width, last_angle, angle);
X	
X	if (p->ptype == EClose)
X	 {
X		if (last_type == ELine)
X		 {
X		 	gstate->CTM = move_matrix;
X			LineJoin (new, width, angle, move_angle);
X		 }
X	 }
X	else if (p->next->ptype == EMove || p->next->ptype == EHeader)
X	 {
X		EndCap (new, width, length);
X	 	gstate->CTM = move_matrix;
X	 	BeginCap (new, width);
X	 }
X	
X	gstate->CTM = old;
X	return angle;
X }
X
Xint PStrokePath ()
X {
X 	Path p, new = NewPath ();
X 	HardPoint prev, here, move;
X 	enum pelem_type last_type = EHeader;
X 	float angle, last_angle, width = gstate->line_width;
X 	
X 	PFlattenPath ();
X 	if (gstate->dash_length != 0)
X 		Dash ();
X 	for (p = gstate->path->next; p != gstate->path; last_type = p->ptype, p = p->next)
X 	 {
X	 	switch (p->ptype)
X	 	 {
X	 	  	case EMove:
X			 	prev = here;
X			 	move = here = p->pe.point;
X			 	break;
X			 	
X	 	  	case EClose:
X	 	  		if (last_type == EMove)
X	 	  			break;
X				angle = LineSegment (p, new, IntToExt (here), IntToExt (move), width, last_angle, last_type);
X			 	prev = here;
X			 	here = move;
X			 	last_type = EHeader;
X			 	break;
X			 	
X	 	  	case ELine:
X				angle = LineSegment (p, new, IntToExt (here), IntToExt (p->pe.point), width, last_angle, last_type);
X			 	prev = here;
X			 	here = p->pe.point;
X	 	  		break;
X	 	  		
X	 	  	default:
X	 	  		Panic ("unknown path element type in StrokePath");
X	 	 }
X	 	last_type = p->ptype;
X	 	last_angle = angle;
X	 }
X 	PathFree (gstate->path);
X 	gstate->path = new;
X 	return TRUE;
X }
X
Xint ThinStroke ()
X {
X 	Path p;
X 	Vector v;
X 	HardPoint here, prev;
X 	
X 	if (stroke_method != STROKE_THIN)
X 		return FALSE; /* not used - get better results with area fill */
X 	v = Transform (NewVector (gstate->line_width, gstate->line_width, 0.0), gstate->CTM);
X 	if (fabs (v.vx) > 1.1 || fabs (v.vy) > 1.1)
X 		return FALSE;
X 	if (gstate->dash_length != 0)
X 		Dash ();
X 	for (p = gstate->path->next; p != gstate->path; p = p->next)
X 	 switch (p->ptype)
X 	  {
X 	  	case EMove:
X 	  		here = prev = p->pe.point;
X 	  		break;
X 	  	
X 	  	case ELine:
X 	  		DevicePaintLine (gstate->device, prev, p->pe.point, gstate->colour);
X 	  		prev = p->pe.point;
X 	  		break;
X 	  	
X 	  	case EClose:
X 	  		DevicePaintLine (gstate->device, prev, here, gstate->colour);
X  	  		prev = here;
X	  		break;
X 	  		
X	 	default:
X	 	  	Panic ("unknown path element type in ThinStroke");
X 	  }
X	VOID PNewPath ();
X	
X	return TRUE;
X }
END_OF_FILE
if test 11211 -ne `wc -c <'source/stroke.c'`; then
    echo shar: \"'source/stroke.c'\" unpacked with wrong size!
fi
# end of 'source/stroke.c'
fi
echo shar: End of archive 9 \(of 18\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
