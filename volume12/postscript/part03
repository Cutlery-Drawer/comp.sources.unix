Subject:  v12i052:  A PostScript interpreter, Part03/18
Newsgroups: comp.sources.unix
Sender: sources
Approved: rs@uunet.UU.NET

Submitted-by: Crispin Goswell <caag@vd.rl.ac.uk>
Posting-number: Volume 12, Issue 52
Archive-name: postscript/part03


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 18)."
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'doc/postscript.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/postscript.1'\"
else
echo shar: Extracting \"'doc/postscript.1'\" \(6501 characters\)
sed "s/^X//" >'doc/postscript.1' <<'END_OF_FILE'
X.na
X.TH POSTSCRIPT 1 Rutherford
X.SH NAME
Xpostscript \- PostScript interpreter
X.SH SYNOPSIS
X.B
XPS [ -isc - ] files . . .
X.br
Xpostscript [ -isc - ] files . . .
X.br
Xviewer
X.SH DESCRIPTION
X.I PS
Xis an interpreter for the PostScript language.
XThe language is intended for driving laser printers, but this
Ximplementation is for previewing graphics on a suitable device or
Xfor more general programming.
X.PP
XThe implementation conforms to the PostScript Language Manual as
Xclosely as possible.
X.PP
X.I Postscript
Xis a version of the interpreter which will talk through a pair of pipes to
Xa viewer program, possibly running on a different machine.
X.PP
X.I Postscript looks for the environment variable POSTSCRIPTDEVICE, which may contain
Xthe name of
Xa two-way device or a command with a vertical bar at the front.
XThis is ``|viewer'' by default, and may be something like ``|rsh workstation viewer''.
X.I Postscript
Xmay be run on a compute server with no display, and
X.I viewer
Xon a workstation.
X.PP
XTo create a window of A4 size, the A4 command may be used.
XIf this is specified on the command line (e.g. ``PS -c A4''), postscript will not bother to
Xread its standard input unless told to do so with ``-''.
X.SH INVOCATION
XWhen
X.I postscript
Xstarts up it performs the following actions:
X.PP
XIt reads a number of definitions from a standard library file.
XThis file is
X.I psrc
Xin the directory given as the environment variable
X.I POSTSCRIPTLIB
X(defaults to
X.IR /usr/lib/postscript ).
XThis contains definitions which are part of the PostScript language
Xand can be defined in PostScript.
XIn particular, it reads a procedure called
X.B executive
Xwhich is the top level interpreter used when
X.I postscript
Xis running interactively.
X.PP
XNext it reads a file called
X.I .postscript
Xfrom the users HOME directory.
XThis may contain any useful startup routines that are always wanted.
X.PP
XNext any arguments are processed off the command line.
XThese can be a mixture of options and files, and are executed in order.
XThe options are as follows:
X.IP -c
XCauses the next argument to be treated as an executable postscript string.
X.IP -i
XCauses postscript to behave as if its standard input is a terminal,
Xeven if it isn't.
XThis involves executing the
X.B executive
Xdefinition from the library.
XIf this is absent and the standard input is not a terminal and there are
Xno files or
X-c options on the command line, the standard input will be treated as an
Xordinary file.
X.IP -s
XCauses the standard input to be read, even if there are files or commands
Xon the command line.
X.IP -
XSame as -s.
X.SH CACHING
X.PP
XThis implementation does caching of fonts to disk.
XOnce a font has been selected and used,
X.B savecurrentfont
Xmay be used (without any arguments) to save the current font into the
Xdisk cache.
XIt saves only those glyphs which have been cached so far, and will fail
Xif the
X.I cache
Xdirectory does not contain sub-directories matching the relevant
Xfiles in the
X.I font
Xdirectory.
X.PP
XLoading from the disk cache is automatic - the system is tolerant about
Xabsent cached fonts, and simply reads the whole font specification instead.
XThe intention is that the system should be lazy, so that it doesn't do work
Xunnecessarily.
X.SH FONT MAPPING
X.PP
XMost installations will have a number of fonts which they may wish to use.
XMost
X.Ps
Xfiles will contain font names such as ``Times-Roman'' which are
Xinconvenient to change.
X.Ps
Xthus contains a dictionary in which name pairs can be placed.
XThis dictionary called
X.B FontMap
Xis searched when a font is chosen and the font name is replaced by the value
Xassociated with its dictionary entry if one is present;
Xotherwise the name is not changed.
XThe reason for this is that a previewer gives only an approximation, so it is sometimes useful
Xto use differing fonts, even if the widths are slightly wrong.
X.PP
XAlso, during startup, a file called
X.B font-map
Xin the
X.Ps
Xlibrary gets
X.B run.
XThis is assumed to contain default mappings, and may typically be empty.
X.SH NEW OPERATORS
X.PP
XA number of non-standard operators have been added to this version of
Xthe interpreter.
X.PP
X.B savecurrentfont
Xhas been described already.
X.PP
X.B setstrokemethod
Xand
X.B currentstrokemethod
Xallow thin strokes to be done with line drawing rather than the area fill used for
Xother lines.
XThe option is an integer.
X.B 0
Xturns off this feature,
X.B 1
Xturns it on and is the default.
X.PP
X.B A4
Xand
X.B A5
Xgenerate new windows of the suggested sizes.
XThe old window is deleted unless it is being held in a gsave context.
X.SH ASSUMPTIONS
XThere are a number of Assumptions that have been made in the
Xabsence of more specific documentation.
X.IP
XThat Integer and Real values are only equivalent mathematically,
Xand are normally
Xdistinct except where specified in the manual.
XThe manual requires equivalence in the following places:
X.RS
X.IP
XThe arguments of the arithmetic and mathematical operators.
X.IP
XThe arguments of the relational operators (including
X.B eq
Xand
X.BR ne ).
X.RE
X.IP	
XIn particular integers and reals are distinguished as dictionary keys.
X.IP
XThat
X.B cvrs
Xis not expected to convert reals to any base.
X.IP
XThat the output from
X.B ==
Xand
X.B pstack
Xcan look however we want them to.
X.IP
XThat %stdout and %stderr should not ever be closed - the manual is specific
Xabout %stdin, but not the other two.
X.IP
XThat
X.B stop
Xcan exit a
X.B run
Xcontext.
X.IP
XThat 
X.B flushfile
Xshould close an input stream.
X.B Read
Xwill close its file if it reads nothing,
Xbut the manual doesn't say whether other operators should.
XIt is assumed so.
X.IP
XThat access restrictions on files are implemented using the
Xaccess restrictions on objects.
X.SH FILES
X\&~/.postscript \- profile command source
X.br
X$POSTSCRIPTLIB/psrc \- library of postscript material.
X$POSTSCRIPTLIB/font-map \- library of postscript material.
X.PP
XThe
X.I POSTSCRIPTLIB
Xdirectory may contain:
X.IP psrc
XThe POSTSCRIPT initialisation library.
X.IP font
Xa directory containing font headers, which are executable POSTSCRIPT describing how to load
Xfonts.
X.IP fonts
Xa directory containing font information.
X.IP font-map
Xa file containing default font name mappings.
X.IP cache
Xa directory containing a corresponding set of cached fonts.
X.SH SEE ALSO
X.I The PostScript Language Manual,
X.I Adobe Systems Incorporated, 1984.
X.SH AUTHOR
XCrispin Goswell.
XTony Williams provided important guidance.
X.SH BUGS
XNo ``virtual memory'' \- dummy operators which do a gsave and grestore and provided.
X.PP
XNo access protection, the operators are there, but they don't protect anything.
END_OF_FILE
if test 6501 -ne `wc -c <'doc/postscript.1'`; then
    echo shar: \"'doc/postscript.1'\" unpacked with wrong size!
fi
# end of 'doc/postscript.1'
fi
if test -f 'postscript/demos/mooreform.ps' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'postscript/demos/mooreform.ps'\"
else
echo shar: Extracting \"'postscript/demos/mooreform.ps'\" \(6182 characters\)
sed "s/^X//" >'postscript/demos/mooreform.ps' <<'END_OF_FILE'
X%!
X% moore business forms -- synthetic "image" and complex clipping
X
X/tms /Times-Roman findfont def
X/tmb /Times-Bold findfont def
X/sws /Helvetica findfont def
X/t22 tmb 22 scalefont def
X/s24 sws 24 scalefont def
X/s10 sws 10 scalefont def
X/s12 sws 12 scalefont def
X/s6 sws 6 scalefont def
X
X/lightorange {.9 setgray}def
X/medorange {.5 setgray}def
X/darkbrown {0 setgray}def
X/white {1 setgray}def
X/inch {72 mul}def
X
X%do rounded borders
X/borders
X  {medorange
X   12 194 moveto 0 194 0 750 8 arcto
X   0 750 450 750 8 arcto
X   450 750 450 606 8 arcto
X   450 606 862 606 4 arcto
X   862 606 862 194 8 arcto
X   862 194 428 194 8 arcto
X   428 194 428 88 4 arcto
X   428 88 716 88 4 arcto
X   716 88 716 0 8 arcto
X   716 0 0 0 8 arcto
X   0 0 0 72 8 arcto
X   0 72 lineto
X   0 194 12 194 8 arcto
X   12 194 lineto
X   4 setlinewidth stroke
X   716 44 moveto
X   716 88 862 88 8 arcto
X   862 88 862 0 8 arcto
X   862 0 716 0 8 arcto
X   716 0 716 43 8 arcto
X   closepath
X   4 setlinewidth stroke
X
X %Start the inner border
X   darkbrown
X   /dx 6 def /dy 6 def
X   12 194 dy add moveto 0 dx add 194 dy add 0 dx add 750 dy sub 4 arcto
X   0 dx add 750 dy sub 450 dx sub 750 dy sub 4 arcto
X   450 dx sub 750 dy sub 450 dx sub 606 dy sub 4 arcto
X   450 dx sub 606 dy sub 862 dx sub 606 dy sub 8 arcto
X   862 dx sub 606 dy sub 862 dx sub 194 dy add 4 arcto
X   862 dx sub 194 dy add  428 dx sub 194 dy add 4 arcto
X   428 dx sub 194 dy add  428 dx sub 88 dy sub 8 arcto
X   428 dx sub 88 dy sub 716 dx sub  88 dy sub 8 arcto
X   716 dx sub 88 dy sub 716 dx sub 0 dy add 4 arcto
X   716 dx sub 0 dy add  0 dx add 0 dy add 4 arcto
X   0 dx add 0 dy add 0 dx add 72  4 arcto
X   0 dx add 72 lineto
X   0 dx add 194 dy sub 12 194 dy sub 4 arcto
X   12 194 dy sub lineto
X   4 setlinewidth stroke
X }def
X
X/bx				% make a box
X {/ury exch def /urx exch def /lly exch def /llx exch def
X  llx lly moveto llx ury lineto urx ury lineto urx lly lineto closepath
X }def
X
X/labelbox
X {/pts exch def
X  /tary exch def
X  /lcnt tary length def
X  /ury exch def /urx exch def /lly exch def /llx exch def
X  darkbrown
X  llx lly moveto llx ury lineto urx ury lineto urx lly lineto closepath
X  fill
X  white
X  /st ury ury lly sub lcnt pts mul sub 2 div sub pts .75 mul sub def
X  tary
X   {dup stringwidth pop 2 div urx llx add 2 div exch sub st moveto show
X    /st st pts sub def
X   }forall
X  }def
X
X%given cx y array of strings, then center text.
X/ctext
X {/pts exch def
X  /tary exch def
X  /lcnt tary length def
X  /ty exch def /ctx exch def
X  darkbrown
X  tary
X   {dup stringwidth pop 2 div ctx exch sub ty moveto show
X    /ty ty pts sub def
X   }forall
X  }def
X
X%Build the procedures necessary to implement the fountain.
X/fountainstring 256 string def
X0 1 255 
X  {fountainstring exch dup
X   255 div 180 mul cos neg 2 div .5 add 128 mul 127 add cvi
X   put
X  } for
X
X/rfountainstring 256 string def
X0 1 255
X  {rfountainstring exch dup
X   255 div 180 mul cos neg 2 div .5 add 128 mul 128 exch sub 127 add cvi put
X  }for
X
X/fount %take string llx lly urx ury
X {/fnt exch def
X  /ury exch def /urx exch def
X  /lly exch def /llx exch def
X  gsave llx lly translate 
X  urx llx sub ury lly sub scale
X  1 256 8 [1 0 0 -256 0 256] {fnt} image
X  grestore
X  }def
X
X/fountain
X {fountainstring fount}def
X
X/rfountain
X {rfountainstring fount}def
X
X%This is the logo for the moore business form example.
X/slogo
X {18 18 scale
X  slogo1 slogo2
X  1 18 div dup scale
X }def
X
X/slogo2
X  {0 .3 moveto
X  2 1 3 2.3 3 5 curveto
X  3 10.5 lineto
X  5.1 10.5 lineto
X  5.1 5 lineto
X  5.1 2.5 2 .3 0 .3 curveto closepath
X  2 0 moveto
X  5 .5 6 1 7 3 curveto
X  8 5 9 6 11 6 curveto
X  11 1 7 0 4 0 curveto closepath
X }def
X
X/slogo1
X {0 .3 moveto
X  0 10.5 lineto
X  2.3 10.5 lineto
X  2.3 5 lineto
X  2.3 2.3 1 1 0 .3 curveto closepath
X  0 .2 moveto
X  3 .2 5.5 2.5 5.6 5 curveto
X  5.7 7.5 7 10.5 11 10.5 curveto
X  11 7 lineto
X  9 7 8 6 7 4 curveto
X  6 2 5 0 0 0 curveto closepath
X }def
X
X
X% now do it
X
X8.5 inch 1 inch  translate 90 rotate
X36 40 translate
X.7 .7 scale
X
Xborders
X
Xs6 setfont
Xlightorange
X10 630 442 742 bx fill
X10 600 66 624 bx fill
X67 600 124 624 bx fill
X124 600 168 624 [(Date)]6 labelbox
Xlightorange
X168 600 232 624 bx fill
X232 600 340 624 [(Customer's Order No.)]6 labelbox
Xlightorange
X341 600 442 624 bx fill
X%new set
Xdarkbrown
X10 568 102 592 [(PART)(NUMBER)] 6 labelbox
X103 568 441 592 [(DESCRIPTION)] 6 labelbox
X442 568 513 580 [(ORDERED)] 6 labelbox
X514 568 585 580 [(SHIPPED)] 6 labelbox
X586 568 657 580 [(BALANCE DUE)] 6 labelbox
X442 581 657 592 [(QUANTITY)] 6 labelbox
X658 568 729 592 [(UNIT)(PRICE)] 6 labelbox
X730 568 772 592 [(%)(DISCOUNT)] 6 labelbox
X773 568 852 592 [(AMOUNT)] 6 labelbox
X%new set (main body)
Xgsave
X103 208 441 568 bx 
X514 208 585 568 bx 
X658 208 729 568 bx 
X773 208 852 568 bx 
Xclip
X103 208 852 568 rfountain
Xgrestore
Xgsave
X10 208 102 568 bx 
X2.5 inch 4 inch translate slogo -2.5 inch -4 inch translate
X442 208 513 568 bx 
X586 208 657 568 bx 
X730 208 772 568 bx 
Xclip
X10 208 772 568 fountain
Xgrestore
Xgsave
X10 14 translate
Xlightorange 0 0 100 143 bx fill  0 143 100 167 [(SUB TOTAL)] 6 labelbox
X102 0 translate
Xlightorange 0 0 100 143 bx fill  0 143 100 167 [(TAX)] 6 labelbox
X102 0 translate
Xlightorange 0 0 100 143 bx fill  0 143 100 167 [(FREIGHT)] 6 labelbox
X102 0 translate
Xlightorange 0 0 100 143 bx fill  0 143 100 167 [(TOTAL)] 6 labelbox
Xgrestore
Xgsave
X10 14 translate
X5{0 24 moveto 403 24 lineto 1 setlinewidth stroke 0 24 translate}repeat
Xgrestore
Xgsave
X44 672 translate
X5.4 5.4 scale
Xdarkbrown slogo1 fill
Xmedorange slogo2 fill
Xgrestore
Xdarkbrown
Xt22 setfont
X124 698 moveto
X(J. Sinclair Electronics Inc.)show
Xs10 setfont
X124 680 moveto
X(2972 CONEY ISLAND DRIVE SO.)show
X124 670 moveto
X(SAN RAPHAEL, CALIFORNIA 98568)show
X124 650 moveto
X(Telephone (609) 992-4293)show
X445 65 moveto
X(Received in good condition by:)show
X445 20 moveto
Xs24 setfont 
X(X)show 3.25 72 mul 0 rlineto 1 setlinewidth stroke
Xlightorange
X722 16 856 50 bx fill
Xs12 setfont
X722 50 856 72 [(TOTAL DUE)] 12 labelbox
X789 140 [(PAY THIS)(AMOUNT)] 12 ctext
Xlightorange
X742 124 moveto 836 124 lineto 789 100 lineto closepath fill
X8.6 inch 10.25 inch
X[(This business form)
X(was composed and set)
X(by PostScript(TM))
X(from a master provided by)
X(Moore Business Forms.)]
X12 ctext
X
Xshowpage
X
END_OF_FILE
if test 6182 -ne `wc -c <'postscript/demos/mooreform.ps'`; then
    echo shar: \"'postscript/demos/mooreform.ps'\" unpacked with wrong size!
fi
# end of 'postscript/demos/mooreform.ps'
fi
if test -f 'postscript/fonts/Sans/greek.r' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'postscript/fonts/Sans/greek.r'\"
else
echo shar: Extracting \"'postscript/fonts/Sans/greek.r'\" \(5539 characters\)
sed "s/^X//" >'postscript/fonts/Sans/greek.r' <<'END_OF_FILE'
XCharStrings
X/627
X<C93B
X473C
X453E
X4440
X4343
X4346
X4448
X4649
X4849
X4A48
X4D45
X4F42
X513E
X523B
XC93B
X4B3B
X4C3C
X4D3E
X4F46
X5048
X5149
X5249
X>
Xput
XMetrics
X/627
X[-3
X21]
Xput
XCharStrings
X/628
X<CC34
X4A35
X4837
X463B
X453E
X4442
X4348
X4250
XCC34
X4E34
X5036
X5039
X4F3B
X4E3C
X4C3D
X493D
XC93D
X4B3E
X4D40
X4E42
X4E45
X4D47
X4C48
X4A49
X4849
X4648
X4547
X4444
X>
Xput
XMetrics
X/628
X[3
X19]
Xput
XCharStrings
X/629
X<C13E
X433C
X453B
X463B
X483C
X493D
X4A40
X4A44
X4949
XD13B
X503E
X4F40
X4949
X474D
X4650
X>
Xput
XMetrics
X/629
X[-1
X19]
Xput
XCharStrings
X/630
X<CB3B
X483B
X463C
X443E
X4341
X4344
X4447
X4548
X4749
X4949
X4B48
X4D46
X4E43
X4E40
X4D3D
X4B3B
X4939
X4837
X4835
X4934
X4B34
X4D35
X4F37
X>
Xput
XMetrics
X/630
X[3
X18]
Xput
XCharStrings
X/631
X<CD3D
X4C3C
X4A3B
X473B
X453C
X453E
X4640
X4941
XC941
X4542
X4344
X4346
X4448
X4649
X4949
X4B48
X4D46
X>
Xput
XMetrics
X/631
X[-3
X16]
Xput
XCharStrings
X/632
X<CA34
X4835
X4736
X4737
X4838
X4B39
X4E39
XCE39
X4A3B
X473D
X4440
X4343
X4345
X4447
X4649
X494B
X4A4D
X4A4F
X4950
X4750
X464E
X>
Xput
XMetrics
X/632
X[4
X15]
Xput
XCharStrings
X/633
X<C13F
X423D
X443B
X463B
X473C
X473E
X4642
X4449
XC642
X483E
X4A3C
X4C3B
X4E3B
X503D
X5040
X4F45
X4C50
X>
Xput
XMetrics
X/633
X[-1
X20]
Xput
XCharStrings
X/634
X<C13F
X423D
X443B
X463B
X473C
X473E
X4643
X4646
X4748
X4849
X4A49
X4C48
X4E45
X4F43
X5040
X513B
X5138
X5035
X4E34
X4C34
X4B36
X4B38
X4C3B
X4E3E
X5040
X5342
X>
Xput
XMetrics
X/634
X[1
X21]
Xput
XCharStrings
X/635
X<C63B
X4442
X4346
X4348
X4449
X4649
X4847
X4945
X>
Xput
XMetrics
X/635
X[-1
X11]
Xput
XCharStrings
X/636
X<C63B
X4249
XD03C
X4F3B
X4E3B
X4C3C
X4840
X4641
X4541
XC541
X4742
X4843
X4A48
X4B49
X4C49
X4D48
X>
Xput
XMetrics
X/636
X[-2
X18]
Xput
XCharStrings
X/637
X<C134
X4334
X4535
X4636
X4E49
XC83B
X4249
X>
Xput
XMetrics
X/637
X[4
X16]
Xput
XCharStrings
X/638
X<C73B
X4150
XC63F
X4544
X4547
X4749
X4949
X4B48
X4D46
X4F42
XD13B
X4F42
X4E46
X4E48
X4F49
X5149
X5347
X5445
X>
Xput
XMetrics
X/638
X[-1
X21]
Xput
XCharStrings
X/639
X<C33B
X463B
X4541
X4446
X4349
XD03B
X4F3E
X4E40
X4C43
X4946
X4648
X4349
X>
Xput
XMetrics
X/639
X[-3
X18]
Xput
XCharStrings
X/640
X<CA34
X4835
X4736
X4737
X4838
X4B39
X4E39
XCB39
X483A
X463B
X453D
X453F
X4741
X4A42
X4C42
XCA42
X4643
X4444
X4346
X4348
X454A
X494C
X4A4D
X4A4F
X4850
X4650
X>
Xput
XMetrics
X/640
X[4
X16]
Xput
XCharStrings
X/641
X<C83B
X463C
X443E
X4341
X4344
X4447
X4548
X4749
X4949
X4B48
X4D46
X4E43
X4E40
X4D3D
X4C3C
X4A3B
X483B
X>
Xput
XMetrics
X/641
X[-3
X17]
Xput
XCharStrings
X/642
X<C93B
X4549
XCE3B
X4F41
X5046
X5149
XC23E
X443C
X473B
X543B
X>
Xput
XMetrics
X/642
X[-2
X22]
Xput
XCharStrings
X/643
X<C441
X4444
X4547
X4648
X4849
X4A49
X4C48
X4E46
X4F43
X4F40
X4E3D
X4D3C
X4B3B
X493B
X473C
X453E
X4441
X4050
X>
Xput
XMetrics
X/643
X[0
X18]
Xput
XCharStrings
X/644
X<D23B
X483B
X463C
X443E
X4341
X4344
X4447
X4548
X4749
X4949
X4B48
X4D46
X4E43
X4E40
X4D3D
X4C3C
X4A3B
X>
Xput
XMetrics
X/644
X[-3
X20]
Xput
XCharStrings
X/645
X<CB3B
X4849
XC23E
X443C
X473B
X523B
X>
Xput
XMetrics
X/645
X[-2
X20]
Xput
XCharStrings
X/646
X<C13F
X423D
X443B
X463B
X473C
X473E
X4544
X4547
X4749
X4949
X4C48
X4E46
X5042
X513E
X513B
X>
Xput
XMetrics
X/646
X[-1
X20]
Xput
XCharStrings
X/647
X<C83C
X463D
X443F
X4342
X4345
X4447
X4548
X4749
X4A49
X4D48
X5046
X5243
X5340
X533D
X513B
X4F3B
X4D3D
X4B41
X4946
X4650
X>
Xput
XMetrics
X/647
X[-3
X22]
Xput
XCharStrings
X/648
X<C23B
X443B
X463D
X4C4E
X4E50
X5050
XD13B
X503D
X4E40
X444B
X424E
X4150
X>
Xput
XMetrics
X/648
X[-1
X18]
Xput
XCharStrings
X/649
X<D034
X4850
XC13F
X423D
X443B
X463B
X473C
X473E
X4643
X4646
X4748
X4949
X4B49
X4E48
X5046
X5243
X543E
X553B
X>
Xput
XMetrics
X/649
X[0
X23]
Xput
XCharStrings
X/650
X<C83B
X463C
X443F
X4342
X4345
X4448
X4549
X4749
X4948
X4B45
XCC41
X4B45
X4C48
X4D49
X4F49
X5148
X5345
X5442
X543F
X533C
X523B
X>
Xput
XMetrics
X/650
X[-3
X23]
Xput
XCharStrings
X/527
X<C934
X4149
XC934
X5149
XC442
X4E42
X>
Xput
XMetrics
X/527
X[3
X18]
Xput
XCharStrings
X/528
X<C434
X4449
XC434
X4D34
X5035
X5136
X5238
X523A
X513C
X503D
X4D3E
XC43E
X4D3E
X503F
X5140
X5242
X5245
X5147
X5048
X4D49
X4449
X>
Xput
XMetrics
X/528
X[1
X21]
Xput
XCharStrings
X/529
X<C434
X4449
XC434
X5034
X>
Xput
XMetrics
X/529
X[2
X17]
Xput
XCharStrings
X/530
X<C934
X4149
XC934
X5149
XC149
X5149
X>
Xput
XMetrics
X/530
X[3
X18]
Xput
XCharStrings
X/531
X<C434
X4449
XC434
X5134
XC43E
X4C3E
XC449
X5149
X>
Xput
XMetrics
X/531
X[2
X19]
Xput
XCharStrings
X/532
X<D134
X4349
XC334
X5134
XC349
X5149
X>
Xput
XMetrics
X/532
X[2
X20]
Xput
XCharStrings
X/533
X<C434
X4449
XD234
X5249
XC43E
X523E
X>
Xput
XMetrics
X/533
X[1
X22]
Xput
XCharStrings
X/534
X<C934
X4735
X4537
X4439
X433C
X4341
X4444
X4546
X4748
X4949
X4D49
X4F48
X5146
X5244
X5341
X533C
X5239
X5137
X4F35
X4D34
X4934
XC83E
X4E3E
X>
Xput
XMetrics
X/534
X[1
X22]
Xput
XCharStrings
X/535
X<C434
X4449
X>
Xput
XMetrics
X/535
X[8
X8]
Xput
XCharStrings
X/536
X<C434
X4449
XD234
X4442
XC93D
X5249
X>
Xput
XMetrics
X/536
X[1
X21]
Xput
XCharStrings
X/537
X<C934
X4149
XC934
X5149
X>
Xput
XMetrics
X/537
X[3
X18]
Xput
XCharStrings
X/538
X<C434
X4449
XC434
X4C49
XD434
X4C49
XD434
X5449
X>
Xput
XMetrics
X/538
X[0
X24]
Xput
XCharStrings
X/539
X<C434
X4449
XC434
X5249
XD234
X5249
X>
Xput
XMetrics
X/539
X[1
X22]
Xput
XCharStrings
X/540
X<C234
X5034
XC63E
X4C3E
XC249
X5049
X>
Xput
XMetrics
X/540
X[3
X18]
Xput
XCharStrings
X/541
X<C934
X4735
X4537
X4439
X433C
X4341
X4444
X4546
X4748
X4949
X4D49
X4F48
X5146
X5244
X5341
X533C
X5239
X5137
X4F35
X4D34
X4934
X>
Xput
XMetrics
X/541
X[1
X22]
Xput
XCharStrings
X/542
X<C434
X4449
XD234
X5249
XC434
X5234
X>
Xput
XMetrics
X/542
X[1
X22]
Xput
XCharStrings
X/543
X<C434
X4449
XC434
X4D34
X5035
X5136
X5238
X523B
X513D
X503E
X4D3F
X443F
X>
Xput
XMetrics
X/543
X[1
X21]
Xput
XCharStrings
X/544
X<C234
X493E
X4249
XC234
X5034
XC249
X5049
X>
Xput
XMetrics
X/544
X[3
X18]
Xput
XCharStrings
X/545
X<C834
X4849
XC134
X4F34
X>
Xput
XMetrics
X/545
X[4
X16]
Xput
XCharStrings
X/546
X<C239
X4237
X4335
X4434
X4634
X4735
X4837
X493B
X4949
XD039
X5037
X4F35
X4E34
X4C34
X4B35
X4A37
X493B
X>
Xput
XMetrics
X/546
X[3
X18]
Xput
XCharStrings
X/547
X<CA34
X4A49
XC839
X453A
X443B
X433D
X4340
X4442
X4543
X4844
X4C44
X4F43
X5042
X5140
X513D
X503B
X4F3A
X4C39
X4839
X>
Xput
XMetrics
X/547
X[2
X20]
Xput
XCharStrings
X/548
X<C334
X5149
XC349
X5134
X>
Xput
XMetrics
X/548
X[2
X20]
Xput
XCharStrings
X/549
X<CB34
X4B49
XC23A
X433A
X443B
X453F
X4641
X4742
X4A43
X4C43
X4F42
X5041
X513F
X523B
X533A
X543A
X>
Xput
XMetrics
X/549
X[1
X22]
Xput
XCharStrings
X/550
X<C349
X4749
X4442
X433E
X433A
X4437
X4635
X4934
X4B34
X4E35
X5037
X513A
X513E
X5042
X4D49
X5149
X>
Xput
XMetrics
X/550
X[2
X20]
Xput
END_OF_FILE
if test 5539 -ne `wc -c <'postscript/fonts/Sans/greek.r'`; then
    echo shar: \"'postscript/fonts/Sans/greek.r'\" unpacked with wrong size!
fi
# end of 'postscript/fonts/Sans/greek.r'
fi
if test -f 'postscript/fonts/sans/roman.r' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'postscript/fonts/sans/roman.r'\"
else
echo shar: Extracting \"'postscript/fonts/sans/roman.r'\" \(5642 characters\)
sed "s/^X//" >'postscript/fonts/sans/roman.r' <<'END_OF_FILE'
XCharStrings
X/1
X<C53B
X4144
XC53B
X4944
XC341
X4741
X>
Xput
XMetrics
X/1
X[0
X10]
Xput
XCharStrings
X/2
X<C23B
X4244
XC23B
X463B
X483C
X483E
X463F
XC23F
X463F
X4840
X4843
X4644
X4244
X>
Xput
XMetrics
X/2
X[0
X10]
Xput
XCharStrings
X/3
X<C93C
X473B
X453B
X433C
X423E
X4241
X4343
X4544
X4744
X4943
X>
Xput
XMetrics
X/3
X[0
X11]
Xput
XCharStrings
X/4
X<C23B
X4244
XC23B
X453B
X473C
X483E
X4841
X4743
X4544
X4244
X>
Xput
XMetrics
X/4
X[0
X10]
Xput
XCharStrings
X/5
X<C23B
X4244
XC23B
X483B
XC23F
X463F
XC244
X4844
X>
Xput
XMetrics
X/5
X[0
X10]
Xput
XCharStrings
X/6
X<C23B
X4244
XC23B
X483B
XC23F
X463F
X>
Xput
XMetrics
X/6
X[0
X9]
Xput
XCharStrings
X/7
X<C93C
X473B
X453B
X433C
X423E
X4241
X4343
X4544
X4744
X4943
X4940
XC640
X4940
X>
Xput
XMetrics
X/7
X[0
X11]
Xput
XCharStrings
X/8
X<C23B
X4244
XC83B
X4844
XC23F
X483F
X>
Xput
XMetrics
X/8
X[0
X10]
Xput
XCharStrings
X/9
X<C23B
X4244
X>
Xput
XMetrics
X/9
X[3
X4]
Xput
XCharStrings
X/10
X<C53B
X4542
X4444
X4244
X4142
X4141
X>
Xput
XMetrics
X/10
X[1
X7]
Xput
XCharStrings
X/11
X<C23B
X4244
XC83B
X4241
XC43F
X4844
X>
Xput
XMetrics
X/11
X[0
X10]
Xput
XCharStrings
X/12
X<C23B
X4244
XC244
X4844
X>
Xput
XMetrics
X/12
X[0
X9]
Xput
XCharStrings
X/13
X<C23B
X4244
XC23B
X4644
XCA3B
X4644
XCA3B
X4A44
X>
Xput
XMetrics
X/13
X[-1
X12]
Xput
XCharStrings
X/14
X<C23B
X4244
XC23B
X4844
XC83B
X4844
X>
Xput
XMetrics
X/14
X[0
X10]
Xput
XCharStrings
X/15
X<C53B
X433C
X423E
X4241
X4343
X4544
X4644
X4843
X4941
X493E
X483C
X463B
X453B
X>
Xput
XMetrics
X/15
X[0
X11]
Xput
XCharStrings
X/16
X<C23B
X4244
XC23B
X463B
X483C
X483F
X4640
X4240
X>
Xput
XMetrics
X/16
X[0
X10]
Xput
XCharStrings
X/17
X<C53B
X433C
X423E
X4241
X4343
X4544
X4644
X4843
X4941
X493E
X483C
X463B
X453B
XC642
X4945
X>
Xput
XMetrics
X/17
X[0
X11]
Xput
XCharStrings
X/18
X<C23B
X4244
XC23B
X463B
X483C
X483F
X4640
X4240
XC540
X4844
X>
Xput
XMetrics
X/18
X[0
X10]
Xput
XCharStrings
X/19
X<C83C
X463B
X443B
X423C
X423D
X433E
X4740
X4841
X4843
X4644
X4444
X4243
X>
Xput
XMetrics
X/19
X[0
X10]
Xput
XCharStrings
X/20
X<C53B
X4544
XC13B
X493B
X>
Xput
XMetrics
X/20
X[0
X10]
Xput
XCharStrings
X/21
X<C23B
X4241
X4343
X4544
X4644
X4843
X4941
X493B
X>
Xput
XMetrics
X/21
X[0
X11]
Xput
XCharStrings
X/22
X<C13B
X4544
XC93B
X4544
X>
Xput
XMetrics
X/22
X[0
X10]
Xput
XCharStrings
X/23
X<C23B
X4444
XC63B
X4444
XC63B
X4844
XCA3B
X4844
X>
Xput
XMetrics
X/23
X[-1
X12]
Xput
XCharStrings
X/24
X<C23B
X4844
XC83B
X4244
X>
Xput
XMetrics
X/24
X[0
X10]
Xput
XCharStrings
X/25
X<C13B
X453F
X4544
XC93B
X453F
X>
Xput
XMetrics
X/25
X[0
X10]
Xput
XCharStrings
X/26
X<C83B
X4244
XC23B
X483B
XC244
X4844
X>
Xput
XMetrics
X/26
X[0
X10]
Xput
XCharStrings
X/space
X<8000
X1063E
X4200
X00107
X3C44
X>
Xput
XMetrics
X/space
X[64
X0]
Xput
XCharStrings
X/zero
X<C53B
X433C
X423E
X4241
X4343
X4544
X4743
X4841
X483E
X473C
X453B
X>
Xput
XMetrics
X/zero
X[0
X10]
Xput
XCharStrings
X/one
X<C33D
X453B
X4544
X>
Xput
XMetrics
X/one
X[0
X10]
Xput
XCharStrings
X/two
X<C23C
X443B
X463B
X483C
X483E
X4740
X4244
X4844
X>
Xput
XMetrics
X/two
X[0
X10]
Xput
XCharStrings
X/three
X<C23C
X443B
X463B
X483C
X483E
X463F
XC53F
X463F
X4840
X4843
X4644
X4444
X4243
X>
Xput
XMetrics
X/three
X[0
X10]
Xput
XCharStrings
X/four
X<C63B
X4644
XC63B
X4141
X4941
X>
Xput
XMetrics
X/four
X[0
X10]
Xput
XCharStrings
X/five
X<C33B
X423F
X443E
X453E
X473F
X4841
X4743
X4544
X4444
X4243
XC33B
X473B
X>
Xput
XMetrics
X/five
X[0
X10]
Xput
XCharStrings
X/six
X<C73B
X453B
X433C
X423E
X4241
X4343
X4544
X4743
X4841
X473F
X453E
X433F
X4241
X>
Xput
XMetrics
X/six
X[0
X10]
Xput
XCharStrings
X/seven
X<C83B
X4444
XC23B
X483B
X>
Xput
XMetrics
X/seven
X[0
X10]
Xput
XCharStrings
X/eight
X<C43B
X423C
X423E
X443F
X463F
X483E
X483C
X463B
X443B
XC43F
X4240
X4243
X4444
X4644
X4843
X4840
X463F
X>
Xput
XMetrics
X/eight
X[0
X10]
Xput
XCharStrings
X/nine
X<C83E
X4740
X4541
X4340
X423E
X433C
X453B
X473C
X483E
X4841
X4743
X4544
X4344
X>
Xput
XMetrics
X/nine
X[0
X10]
Xput
XCharStrings
X/period
X<C243
X4244
X4344
X4343
X4243
X>
Xput
XMetrics
X/period
X[-2
X5]
Xput
XCharStrings
X/comma
X<C344
X4244
X4243
X4343
X4345
X4247
X>
Xput
XMetrics
X/comma
X[-2
X5]
Xput
XCharStrings
X/colon
X<C23E
X423F
X433F
X433E
X423E
XC243
X4244
X4344
X4343
X4243
X>
Xput
XMetrics
X/colon
X[0
X5]
Xput
XCharStrings
X/semicolon
X<C23E
X423F
X433F
X433E
X423E
XC344
X4244
X4243
X4343
X4345
X4247
X>
Xput
XMetrics
X/semicolon
X[0
X5]
Xput
XCharStrings
X/exclam
X<C23B
X4240
XC33B
X4340
XC243
X4244
X4344
X4343
X4243
X>
Xput
XMetrics
X/exclam
X[3
X5]
Xput
XCharStrings
X/question
X<C23C
X443B
X453B
X473C
X473E
X443F
X4440
X4540
X453F
X473E
XC443
X4444
X4544
X4543
X4443
X>
Xput
XMetrics
X/question
X[1
X9]
Xput
XCharStrings
X/quotesingle
X<C23B
X423F
X>
Xput
XMetrics
X/quotesingle
X[3
X4]
Xput
XCharStrings
X/quotedbl
X<C23B
X423F
XC63B
X463F
X>
Xput
XMetrics
X/quotedbl
X[1
X8]
Xput
XCharStrings
X/ring
X<C33B
X423C
X423E
X433F
X453F
X463E
X463C
X453B
X433B
X>
Xput
XMetrics
X/ring
X[1
X8]
Xput
XCharStrings
X/dollar
X<C83C
X463B
X443B
X423C
X423E
X443F
X4740
X4841
X4843
X4644
X4444
X4243
XC53A
X4545
X>
Xput
XMetrics
X/dollar
X[1
X10]
Xput
XCharStrings
X/slash
X<C93A
X4145
X>
Xput
XMetrics
X/slash
X[1
X10]
Xput
XCharStrings
X/parenleft
X<C53A
X433C
X423E
X4241
X4343
X4545
X>
Xput
XMetrics
X/parenleft
X[3
X7]
Xput
XCharStrings
X/parenright
X<C23A
X443C
X453E
X4541
X4443
X4245
X>
Xput
XMetrics
X/parenright
X[2
X7]
Xput
XCharStrings
X/bar
X<C23A
X4245
X>
Xput
XMetrics
X/bar
X[4
X4]
Xput
XCharStrings
X/minus
X<C240
X4A40
X>
Xput
XMetrics
X/minus
X[-2
X12]
Xput
XCharStrings
X/plus
X<C63C
X4644
XC240
X4A40
X>
Xput
XMetrics
X/plus
X[-2
X12]
Xput
XCharStrings
X/equal
X<C23E
X4A3E
XC242
X4A42
X>
Xput
XMetrics
X/equal
X[-2
X12]
Xput
XCharStrings
X/multiply
X<C23D
X4843
XC83D
X4243
X>
Xput
XMetrics
X/multiply
X[-2
X10]
Xput
XCharStrings
X/asterisk
X<C53D
X4543
XC23E
X4842
XC83E
X4242
X>
Xput
XMetrics
X/asterisk
X[-2
X10]
Xput
XCharStrings
X/dotmath
X<C23F
X4240
X4340
X433F
X423F
X>
Xput
XMetrics
X/dotmath
X[-1
X5]
Xput
XCharStrings
X/quoteleft
X<C33B
X423D
X423F
X433F
X433E
X423E
X>
Xput
XMetrics
X/quoteleft
X[3
X5]
Xput
XCharStrings
X/quoteright
X<C33C
X423C
X423B
X433B
X433D
X423F
X>
Xput
XMetrics
X/quoteright
X[3
X5]
Xput
XCharStrings
X/arrowright
X<C73D
X4A40
X4743
XC240
X4A40
X>
Xput
XMetrics
X/arrowright
X[-2
X12]
Xput
XCharStrings
X/numbersign
X<C53A
X4345
XC83A
X4645
XC23E
X493E
XC241
X4941
X>
Xput
XMetrics
X/numbersign
X[1
X11]
Xput
XCharStrings
X/currency
X<CA40
X4940
X4841
X4743
X4644
X4344
X4243
X4241
X4340
X463F
X473E
X473C
X463B
X443B
X433C
X433E
X4541
X4743
X4944
X4A44
X>
Xput
XMetrics
X/234
X[-1
X12]
Xput
XCharStrings
X/235
X<C23C
X433F
X4341
X4244
XCA3C
X493F
X4941
X4A44
XC23C
X453D
X473D
X4A3C
XC244
X4543
X4743
X4A44
X>
Xput
XMetrics
X/currency
X[-2
X12]
Xput
END_OF_FILE
if test 5642 -ne `wc -c <'postscript/fonts/sans/roman.r'`; then
    echo shar: \"'postscript/fonts/sans/roman.r'\" unpacked with wrong size!
fi
# end of 'postscript/fonts/sans/roman.r'
fi
if test -f 'postscript/widths/Adobe/Times-Roman' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'postscript/widths/Adobe/Times-Roman'\"
else
echo shar: Extracting \"'postscript/widths/Adobe/Times-Roman'\" \(5333 characters\)
sed "s/^X//" >'postscript/widths/Adobe/Times-Roman' <<'END_OF_FILE'
X(fonts/Times/roman) lib run
Xuserdict /factor 22 put
XFontDirectory /Times-Roman-Adobe get begin
XMetrics /space 250 factor idiv put
XMetrics /exclam 333 factor idiv put
XMetrics /quotedbl 408 factor idiv put
XMetrics /numbersign 500 factor idiv put
XMetrics /dollar 500 factor idiv put
XMetrics /percent 833 factor idiv put
XMetrics /ampersand 778 factor idiv put
XMetrics /quoteright 333 factor idiv put
XMetrics /parenleft 333 factor idiv put
XMetrics /parenright 333 factor idiv put
XMetrics /asterisk 500 factor idiv put
XMetrics /plus 564 factor idiv put
XMetrics /comma 250 factor idiv put
XMetrics /hyphen 333 factor idiv put
XMetrics /period 250 factor idiv put
XMetrics /slash 278 factor idiv put
XMetrics /zero 500 factor idiv put
XMetrics /one 500 factor idiv put
XMetrics /two 500 factor idiv put
XMetrics /three 500 factor idiv put
XMetrics /four 500 factor idiv put
XMetrics /five 500 factor idiv put
XMetrics /six 500 factor idiv put
XMetrics /seven 500 factor idiv put
XMetrics /eight 500 factor idiv put
XMetrics /nine 500 factor idiv put
XMetrics /colon 278 factor idiv put
XMetrics /semicolon 278 factor idiv put
XMetrics /less 564 factor idiv put
XMetrics /equal 564 factor idiv put
XMetrics /greater 564 factor idiv put
XMetrics /question 444 factor idiv put
XMetrics /at 921 factor idiv put
XMetrics /A 722 factor idiv put
XMetrics /B 667 factor idiv put
XMetrics /C 667 factor idiv put
XMetrics /D 722 factor idiv put
XMetrics /E 611 factor idiv put
XMetrics /F 556 factor idiv put
XMetrics /G 722 factor idiv put
XMetrics /H 722 factor idiv put
XMetrics /I 333 factor idiv put
XMetrics /J 389 factor idiv put
XMetrics /K 722 factor idiv put
XMetrics /L 611 factor idiv put
XMetrics /M 889 factor idiv put
XMetrics /N 722 factor idiv put
XMetrics /O 722 factor idiv put
XMetrics /P 556 factor idiv put
XMetrics /Q 722 factor idiv put
XMetrics /R 667 factor idiv put
XMetrics /S 556 factor idiv put
XMetrics /T 611 factor idiv put
XMetrics /U 722 factor idiv put
XMetrics /V 722 factor idiv put
XMetrics /W 944 factor idiv put
XMetrics /X 722 factor idiv put
XMetrics /Y 722 factor idiv put
XMetrics /Z 611 factor idiv put
XMetrics /bracketleft 333 factor idiv put
XMetrics /backslash 278 factor idiv put
XMetrics /bracketright 333 factor idiv put
XMetrics /asciicircum 469 factor idiv put
XMetrics /underscore 500 factor idiv put
XMetrics /quoteleft 333 factor idiv put
XMetrics /a 444 factor idiv put
XMetrics /b 500 factor idiv put
XMetrics /c 444 factor idiv put
XMetrics /d 500 factor idiv put
XMetrics /e 444 factor idiv put
XMetrics /f 333 factor idiv put
XMetrics /g 500 factor idiv put
XMetrics /h 500 factor idiv put
XMetrics /i 278 factor idiv put
XMetrics /j 278 factor idiv put
XMetrics /k 500 factor idiv put
XMetrics /l 278 factor idiv put
XMetrics /m 778 factor idiv put
XMetrics /n 500 factor idiv put
XMetrics /o 500 factor idiv put
XMetrics /p 500 factor idiv put
XMetrics /q 500 factor idiv put
XMetrics /r 333 factor idiv put
XMetrics /s 389 factor idiv put
XMetrics /t 278 factor idiv put
XMetrics /u 500 factor idiv put
XMetrics /v 500 factor idiv put
XMetrics /w 722 factor idiv put
XMetrics /x 500 factor idiv put
XMetrics /y 500 factor idiv put
XMetrics /z 444 factor idiv put
XMetrics /braceleft 480 factor idiv put
XMetrics /bar 200 factor idiv put
XMetrics /braceright 480 factor idiv put
XMetrics /asciitilde 541 factor idiv put
XMetrics /exclamdown 333 factor idiv put
XMetrics /cent 500 factor idiv put
XMetrics /sterling 500 factor idiv put
XMetrics /fraction 167 factor idiv put
XMetrics /yen 500 factor idiv put
XMetrics /florin 500 factor idiv put
XMetrics /section 500 factor idiv put
XMetrics /currency 500 factor idiv put
XMetrics /quotesingle 180 factor idiv put
XMetrics /quotedblleft 444 factor idiv put
XMetrics /guillemotleft 500 factor idiv put
XMetrics /guilsinglleft 333 factor idiv put
XMetrics /guilsinglright 333 factor idiv put
XMetrics /fi 556 factor idiv put
XMetrics /fl 556 factor idiv put
XMetrics /endash 500 factor idiv put
XMetrics /dagger 500 factor idiv put
XMetrics /daggerdbl 500 factor idiv put
XMetrics /periodcentered 250 factor idiv put
XMetrics /paragraph 453 factor idiv put
XMetrics /bullet 350 factor idiv put
XMetrics /quotesinglbase 333 factor idiv put
XMetrics /quotedblbase 444 factor idiv put
XMetrics /quotedblright 444 factor idiv put
XMetrics /guillemotright 500 factor idiv put
XMetrics /ellipsis 1000 factor idiv put
XMetrics /perthousand 1000 factor idiv put
XMetrics /questiondown 444 factor idiv put
XMetrics /grave 333 factor idiv put
XMetrics /acute 333 factor idiv put
XMetrics /circumflex 333 factor idiv put
XMetrics /tilde 333 factor idiv put
XMetrics /macron 333 factor idiv put
XMetrics /breve 333 factor idiv put
XMetrics /dotaccent 333 factor idiv put
XMetrics /dieresis 333 factor idiv put
XMetrics /ring 333 factor idiv put
XMetrics /cedilla 333 factor idiv put
XMetrics /hungarumlaut 333 factor idiv put
XMetrics /ogonek 333 factor idiv put
XMetrics /caron 333 factor idiv put
XMetrics /emdash 1000 factor idiv put
XMetrics /AE 889 factor idiv put
XMetrics /ordfeminine 276 factor idiv put
XMetrics /Lslash 611 factor idiv put
XMetrics /Oslash 722 factor idiv put
XMetrics /OE 889 factor idiv put
XMetrics /ordmasculine 310 factor idiv put
XMetrics /ae 667 factor idiv put
XMetrics /dotlessi 278 factor idiv put
XMetrics /lslash 278 factor idiv put
XMetrics /oslash 500 factor idiv put
XMetrics /oe 722 factor idiv put
XMetrics /germandbls 500 factor idiv put
Xend
END_OF_FILE
if test 5333 -ne `wc -c <'postscript/widths/Adobe/Times-Roman'`; then
    echo shar: \"'postscript/widths/Adobe/Times-Roman'\" unpacked with wrong size!
fi
# end of 'postscript/widths/Adobe/Times-Roman'
fi
if test -f 'source/math.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/math.c'\"
else
echo shar: Extracting \"'source/math.c'\" \(5148 characters\)
sed "s/^X//" >'source/math.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include <signal.h>
X
X#include "main.h"
X
X#define PI 3.14159265358979
X
Xstatic int PRand (), PSrand (), PRrand (), Idiv ();
X
Xstatic catchmath ();
Xextern int errno;
Xjmp_buf env;
X
XInitMath ()
X {
X	InstallOp ("abs",	PolyFirst,	1, 1, 0, 0, Poly);
X	InstallOp ("add",	PolyPair,	2, 1, 0, 0, Poly, Poly);
X	InstallOp ("div",	PolyPair,	2, 1, 0, 0, Poly, Poly);
X	InstallOp ("mod",	PolyPair,	2, 1, 0, 0, Poly, Poly);
X	InstallOp ("mul",	PolyPair,	2, 1, 0, 0, Poly, Poly);
X	InstallOp ("neg",	PolyFirst,	1, 1, 0, 0, Poly);
X	InstallOp ("sub",	PolyPair,	2, 1, 0, 0, Poly, Poly);
X	InstallOp ("sqrt",	PolyFirst,	1, 1, 0, 0, Poly);
X	InstallOp ("exp",	PolyPair,	2, 1, 0, 0, Poly, Poly);
X	InstallOp ("ceiling",	PolyFirst,	1, 1, 0, 0, Poly);
X	InstallOp ("floor",	PolyFirst,	1, 1, 0, 0, Poly);
X	InstallOp ("round",	PolyFirst,	1, 1, 0, 0, Poly);
X	InstallOp ("truncate",	PolyFirst,	1, 1, 0, 0, Poly);
X	InstallOp ("atan",	PolyPair,	2, 1, 0, 0, Poly, Poly);
X	InstallOp ("cos",	PolyFirst,	1, 1, 0, 0, Poly);
X	InstallOp ("sin",	PolyFirst,	1, 1, 0, 0, Poly);
X	InstallOp ("ln",	PolyFirst,	1, 1, 0, 0, Poly);
X	InstallOp ("log",	PolyFirst,	1, 1, 0, 0, Poly);
X	InstallOp ("rand",	PRand,		0, 1, 0, 0);
X	InstallOp ("srand",	PSrand,		1, 0, 0, 0, Integer);
X	InstallOp ("rrand",	PRrand,		0, 1, 0, 0);
X 	InstallOp ("idiv", 	Idiv,		2, 1, 0, 0, Float, Float);
X	
X/*	PanicIf (setjmp (env), "Unexpected floating point error");
X	VOID signal (SIGFPE, catchmath);
X*/ }
X
Xstatic catchmath ()
X {
X	VOID signal (SIGFPE, catchmath);
X 	longjmp (env, TRUE);
X }
X
Xfloat Deg (r) float r;
X {
X	float res = 360 * r / (2 * PI);
X	return res < 0 ? res + 360 : res;
X }
X
Xfloat Rad (d) float d;
X {
X	return 2 * PI * d / 360;
X }
X
Xfloat BodyFloat (ob) Object ob;
X {
X	if (TypeOf (ob) == Integer)
X		return (float) BodyInteger (ob);
X	else if (TypeOf (ob) == Real)
X		return BodyReal (ob);
X	else
X		Panic ("BodyFloat passed arg of bad type");
X	return 0.0;
X }
X
XObject ParseNumber (s, length) char *s; int length;
X {
X 	int c, sign, ival;
X 	float fval;
X 	
X 	/*if (setjmp (env))
X 		return Absent;*/
X 	if (length == 0)
X 		return Nil;
X 	sign = ParseSign (&s, &length);
X 	if (*s == '.')
X 	 {
X 	 	c = *s++;
X 	 	--length;
X 	 	ival = 0;
X 	 }
X 	else
X 	 {
X 	 	ival = ParseInteger (&s, &length, 10);
X 		if (length < 0)
X 			return Nil;
X 		else if (length == 0)
X 			return MakeInteger (ival * sign);
X 		
X 		c = *s++; --length;
X 	 }
X 	if (c == '.')
X 	 {
X 	 	int olength = length, dval;
X 	 	
X		fval = ival;
X 		dval = ParseInteger (&s, &length, 10);
X 		fval += dval * pow (10.0, (float)(length - olength));
X 		if (length < 0)
X 			return Nil;
X 		else if (length == 0)
X 			return MakeReal (sign * fval);
X 	 }
X 	else if (c == '#')
X  	 {
X  	 	int base = ival;
X  	 	
X  	 	if (base < 2 || base > 36)
X  	 		return Nil;
X  	 	ival = ParseInteger (&s, &length, base);
X  		if (length >= 0)
X  			return MakeInteger (ival * sign);
X  		return Nil;
X	 }
X	else
X	 {
X		--s;
X		++length;
X		fval = ival;
X	 }
X	
X	fval *= sign;
X	c = *s++; --length;
X	if (c == 'e' || c == 'E')
X	 {
X	  	Object res;
X	  	int sign = ParseSign (&s, &length), power = ParseInteger (&s, &length, 10);
X	 	
X 		if (length < 0)
X 			return Nil;
X 		res = MakeReal (fval * pow (10.0, (double) power * sign));
X 		return res;
X 	 }
X 	else
X 		return Nil;
X }
X
Xstatic int ParseSign (s, length) char **s; int *length;
X {
X 	int c;
X 	
X 	if (*length == 0)
X 		return 1;
X 	c = *(*s)++;
X 	--*length;
X	if (c == '+')
X 		return 1;
X 	else if (c == '-')
X 		return -1;
X	++*length;
X	--*s;
X	return 1;
X }
X
Xstatic int ParseInteger (p, length, base) char **p; int *length, base;
X {
X 	int present = FALSE, ival = 0, digit;
X 	if (*length == 0)
X 	 {
X 		*length = -1;
X 		return 0;
X 	 }
X 	for (;;)
X 	 {
X 	 	int c = *(*p)++;
X 	 	
X 	 	if (c >= '0' && c <= '9')
X 	 		digit = c - '0';
X 	 	else if (c >= 'a' && c <= 'z')
X 	 		digit = c - 'a' + 10;
X 	 	else if (c >= 'A' && c <= 'Z')
X 	 		digit = c - 'A' + 10;
X 	 	else
X 	 		break;
X 	 	if (digit < base)
X 	 		/*ival = StrictAdd (StrictMul (ival, base), digit);*/
X 	 		ival = ival * base + digit;
X 	 	else
X 	 		break;
X 		++present;
X 	 	if (--*length == 0)
X 	 		return ival;
X 	 }
X 	--*p;
X 	if (!present)
X 		*length = -1;
X 	return ival;
X }
X
Xstatic int seed = 1;
X
Xstatic int random ()
X {
X	return seed = ((seed * 1103515245 + 12345) & 0x7fffffff);
X }
X
Xstatic int PRand ()		/* --- integer */
X {
X 	VOID random ();
X 	return Push (OpStack, MakeInteger (seed));
X }
X
Xstatic int PSrand (see) Object see;
X {
X	srand ((unsigned) (seed = BodyInteger (see)));
X 	return TRUE;
X }
X
Xstatic int PRrand ()
X {
X 	return Push (OpStack, MakeInteger (seed));
X }
X
Xstatic int Idiv (a, b) Object a, b;
X {
X  	if (BodyReal (b) == 0)
X 		return Error (PUnResult);
X	return Push (OpStack, MakeInteger ((int) BodyReal (a) / (int) BodyReal (b)));
X }
END_OF_FILE
if test 5148 -ne `wc -c <'source/math.c'`; then
    echo shar: \"'source/math.c'\" unpacked with wrong size!
fi
# end of 'source/math.c'
fi
if test -f 'source/paint.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/paint.c'\"
else
echo shar: Extracting \"'source/paint.c'\" \(5867 characters\)
sed "s/^X//" >'source/paint.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X#include "graphics.h"
X#include "canon.h"
X
Xstatic NeedAux (h) struct hardware *h;
X {
X 	DevicePoint extent;
X 	
X 	if (h->aux)
X 		return;
X 	extent = HardwareExtent (h);
X 	h->aux = NewBitmapHardware (extent.dx, extent.dy);
X }
X
Xstatic void RasterThreeAdd (from, aux, to, fromPoint, toPoint, extent, rop)	/* depends on aux */
X	struct hardware *from, *aux, *to;
X	DevicePoint fromPoint, toPoint, extent;
X	int rop;
X {
X 	BitBlt (from, aux, fromPoint, toPoint, extent, ROP_AND);
X 	BitBlt (aux, to, toPoint, toPoint, extent, rop);
X }
X
Xstatic void RasterFour (from, mask, aux, to, fromPoint, toPoint, extent, rop)
X	struct hardware *from, *mask, *aux, *to;
X	DevicePoint fromPoint, toPoint, extent;
X	int rop;
X {
X 	if (mask == NULL)
X 		BitBlt (from, to, fromPoint, toPoint, extent, rop);
X 	else if (from == NULL)
X 		BitBlt (mask, to, toPoint, toPoint, extent, rop);
X 	else
X 	 {
X 	 	BitBlt (from, aux, fromPoint, toPoint, extent, ROP_SOURCE);
X 	 	RasterThreeAdd (mask, aux, to, toPoint, toPoint, extent, rop);
X 	 }
X }
X
Xvoid Paint  (from, to, fromPoint, toPoint, extent, colour)
X	struct hardware *from, *to;
X	DevicePoint fromPoint, toPoint, extent;
X	Colour colour;
X {
X  	int col;
X  	
X 	if (to == NULL)
X 		return;
X 	
X 	UpdateControl (to, FALSE);
X 	
X 	col = IsWindowHardware (to) ? HardColour (colour) : 0;
X 	
X 	if (to->clip )
X 		NeedAux (to);	
X 	if (col == 0)
X 		if (to->clip == NULL && from != NULL)
X 		 	BitBlt (from, to, fromPoint, toPoint, extent, ROP_OR);
X 		else
X			RasterFour (from, to->clip, to->aux, to, fromPoint, toPoint, extent, ROP_OR);
X	else if (col == TransferSize () - 1)
X		RasterFour (from, to->clip, to->aux, to, fromPoint, toPoint, extent, ROP_NOTAND);
X 	else
X 	 { 
X 	 	struct hardware *gray = GraySync (col);
X  		NeedAux (to);
X	 	if (from)
X	 	 {
X	 		BitBlt (from, to->aux, fromPoint, toPoint, extent, ROP_SOURCE);
X	 		if (to->clip)
X	 			BitBlt (to->clip, to->aux, toPoint, toPoint, extent, ROP_AND);
X	 		BitBlt (to->aux, to, toPoint, toPoint, extent, ROP_NOTAND);
X	 		RasterTile (gray, to->aux, toPoint, extent, ROP_AND);
X	 		BitBlt (to->aux, to, toPoint, toPoint, extent, ROP_OR);
X	 	 }
X	 	else
X	 	 {
X	 	 	if (to->clip)
X	 	 	 {
X	 	 		BitBlt (to->clip, to->aux, toPoint, toPoint, extent, ROP_SOURCE);
X	 			BitBlt (to->aux, to, toPoint, toPoint, extent, ROP_NOTAND);
X	 			RasterTile (gray, to->aux, toPoint, extent, ROP_AND);
X	 			BitBlt (to->aux, to, toPoint, toPoint, extent, ROP_OR);
X	 		 }
X	 		else
X	 		 	RasterTile (gray, to, toPoint, extent, ROP_SOURCE);
X	 	 	
X	 	 }
X 	 }
X 	UpdateControl (to, TRUE);
X }
X
Xvoid PaintLine (h, fromPoint, toPoint, colour)
X	struct hardware *h;
X	DevicePoint fromPoint, toPoint;
X	Colour colour;
X {
X 	int col;
X 	
X 	if (h == NULL)
X 		return;
X 	
X 	col = IsWindowHardware (h) ? HardColour (colour) : 0;
X 	
X 	UpdateControl (h, FALSE);
X 	
X 	if (h->clip == NULL && (col == 0 || col == TransferSize () - 1))
X	 	BitBltLine (h, fromPoint, toPoint, (col == 0 ? ROP_TRUE : ROP_FALSE));
X	else
X 	 {
X		int mx = Min (fromPoint.dx, toPoint.dx), my = Min (fromPoint.dy, toPoint.dy),
X			Mx = Max (fromPoint.dx, toPoint.dx), My = Max (fromPoint.dy, toPoint.dy);
X  		DevicePoint orig, ex;
X  		
X  		orig = NewDevicePoint (mx, my);
X  		ex = NewDevicePoint (Mx - mx + 1, My - my + 1);
X  		
X		NeedAux (h);
X 		BitBlt ((struct hardware *) NULL, h->aux, orig, orig, ex, ROP_FALSE);
X 		
X 		BitBltLine (h->aux, fromPoint, toPoint, ROP_TRUE);
X		
X		BitBlt (h->clip, h->aux, orig, orig, ex, ROP_AND);
X		BitBlt (h->aux, h, orig, orig, ex, ROP_NOTAND);
X		
X		if (col != 0 && col != TransferSize () - 1)
X		 {
X		 	struct hardware *gray = GraySync (col);
X		 	RasterTile (gray, h->aux, orig, ex, ROP_AND);
X		 }
X		BitBlt (h->aux, h, orig, orig, ex, ROP_OR);
X	 }
X	UpdateControl (h, TRUE);
X }
X
Xvoid PaintTrapezoid (to, lefttop, leftbottom, righttop, rightbottom, top, bottom, colour)
X	struct hardware *to;
X	DevicePoint lefttop, leftbottom, righttop, rightbottom;
X	int top, bottom;
X	Colour colour;
X {
X  	int col;
X  	
X 	if (to == NULL)
X 		return;
X 	
X 	col = IsWindowHardware (to) ? HardColour (colour) : 0;
X 	
X 	UpdateControl (to, FALSE);
X 	
X 	if (to->clip)
X 		NeedAux (to);	
X 	if (col == 0)
X		BitBltTrapezoid (to, lefttop, leftbottom, righttop, rightbottom, top, bottom, ROP_TRUE);
X	else if (col == TransferSize () - 1)
X		BitBltTrapezoid (to, lefttop, leftbottom, righttop, rightbottom, top, bottom, ROP_FALSE);
X 	else
X 	 {
X 	 	DevicePoint origin, extent;
X 	 	struct hardware *gray;
X 	 	
X 	 	int left = lefttop.dx < leftbottom.dx ? lefttop.dx : leftbottom.dx,
X 	 		right = righttop.dx > rightbottom.dx ? righttop.dx : rightbottom.dx;
X 	 	
X 	 	if (righttop.dx < left)
X 	 		left = righttop.dx;
X 	 	if (rightbottom.dx < left)
X 	 		left = rightbottom.dx;
X 	 	if (lefttop.dx > right)
X 	 		right = lefttop.dx;
X 	 	if (leftbottom.dx > right)
X 	 		right = leftbottom.dx;
X 	 	origin = NewDevicePoint (left, top);
X 	 	extent = NewDevicePoint (right - left, bottom - top);
X 	 	
X 	 	gray = GraySync (col);
X  		NeedAux (to);
X 		BitBlt ((struct hardware *) NULL, to->aux, origin, origin, extent, ROP_FALSE);
X		BitBltTrapezoid (to->aux, lefttop, leftbottom, righttop, rightbottom, top, bottom, ROP_TRUE);
X 		if (to->clip)
X 			BitBlt (to->clip, to->aux, origin, origin, extent, ROP_AND);
X 		BitBlt (to->aux, to, origin, origin, extent, ROP_NOTAND);
X 		RasterTile (gray, to->aux, origin, extent, ROP_AND);
X 		BitBlt (to->aux, to, origin, origin, extent, ROP_OR);
X 	 }
X  	UpdateControl (to, TRUE);
X }
END_OF_FILE
if test 5867 -ne `wc -c <'source/paint.c'`; then
    echo shar: \"'source/paint.c'\" unpacked with wrong size!
fi
# end of 'source/paint.c'
fi
if test -f 'source/pixrect.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/pixrect.c'\"
else
echo shar: Extracting \"'source/pixrect.c'\" \(5728 characters\)
sed "s/^X//" >'source/pixrect.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987, All Rights Reserved.
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X
X#include "main.h"
X#include "graphics.h"
X#include "canon.h"
X#include <pixrect/pixrect_hs.h>
X
Xint rop_map [] =
X {
X 	PIX_SRC & PIX_NOT (PIX_SRC),
X 	PIX_SRC & PIX_DST,
X 	PIX_SRC & PIX_NOT (PIX_DST),
X 	PIX_SRC,
X 	PIX_NOT (PIX_SRC) & PIX_DST,
X 	PIX_DST,
X 	PIX_SRC ^ PIX_DST,
X 	PIX_SRC | PIX_DST,
X 	PIX_NOT (PIX_SRC | PIX_DST),
X 	PIX_NOT (PIX_SRC ^ PIX_DST),
X 	PIX_NOT (PIX_DST),
X 	PIX_SRC | PIX_NOT (PIX_DST),
X 	PIX_NOT (PIX_SRC),
X 	PIX_NOT (PIX_SRC) | PIX_DST,
X 	PIX_NOT (PIX_SRC & PIX_DST),
X 	PIX_SRC | PIX_NOT (PIX_SRC)
X };
X
Xstatic struct hardware *NewHardware ();
X
Xstatic struct pixrect *screen;
X
Xchar *malloc ();
X
Xstruct hardware *InitHardware ()
X {
X	screen = pr_open ("/dev/fb");
X	PanicIf (screen == NULL, "could not open display");
X	
X	InitTransfer (82);	/* XXX */
X	
X	return NULL;
X }
X
Xstruct hardware *NewWindowHardware (width, height) int width, height;
X {
X 	DevicePoint real_extent;
X 	struct pixrect *w;
X 	
X 	real_extent = NewDevicePoint (width, height);
X 	
X 	if ((w = pr_region (screen, 0, 0, width, height)) == NULL)
X 		return NULL;
X 	return NewHardware (w, real_extent, ISWIN);
X }
X
Xstruct hardware *NewBitmapHardware (width, height) int width, height;
X {
X 	DevicePoint real_extent;
X 	struct pixrect *bm;
X 	
X 	real_extent = NewDevicePoint (width, height);
X 	
X 	if ((bm = mem_create (width, height, 1)) == NULL)
X 	 {
X 	 	fprintf (stderr, "mem_create (%d, %d, 1)\n", width, height);
X 		Panic ("failed to create bitmap");
X 	 }
X 	
X 	return NewHardware (bm, real_extent, 0);
X }
X
X#define DeviceBitmap(h) ((struct pixrect *) ((h)->hard.addr))
X
Xstatic void DestroyHard (dev) struct hardware *dev;
X {
X 	struct pixrect *bm = DeviceBitmap (dev);
X 	
X 	if (bm)
X 		pr_destroy (bm);
X }
X
Xvoid DestroyHardware (dev) struct hardware *dev;
X {
X 	if (dev == NULL)
X 		return;
X 	DestroyHard (dev);
X 	if (dev->aux)
X 		DestroyHardware (dev->aux);
X 	Free ((char *) dev);
X }
X
Xstatic struct hardware *NewHardware (bm, extent, flags) struct pixrect *bm; DevicePoint extent; int flags;
X {
X 	struct hardware *d = (struct hardware *) Malloc (sizeof (struct hardware));
X 	
X 	d->flags = flags;
X 	d->hard.addr = (char *) bm;
X 	d->aux = d->clip = NULL;
X 	d->extent = extent;
X 	
X 	return d;
X }
X
Xstruct hardware *HardwareFromString (s, width, height) unsigned char *s; int width, height;
X {
X	int words = (width + 15) / 16;
X	struct pixrect *pr = mem_create (width, height, 1);
X	short *d = mpr_d (pr)->md_image;
X	int odd = ((width + 7) / 8) & 1;
X	int i, j;
X
X	for (i = 0; i < height; i++)
X	 {
X		for (j = 0; j < words - odd; j++)
X		 {
X			short word = *s++;
X
X			*d++ = (word << 8) | *s++;
X		 }
X		if (odd)
X			*d++ = *s++ << 8;
X	 }
X	return NewHardware (pr, NewDevicePoint (width, height), 0);
X }
X
Xchar *StringFromHardware (h) struct hardware *h;
X {
X	int words = (h->extent.dx + 15) / 16;
X	char *string = malloc ((h->extent.dx + 7) / 8 * h->extent.dy), *s = string;
X	int i, j, odd = ((h->extent.dx + 7) / 8) & 1;
X	short *d = mpr_d (DeviceBitmap (h))->md_image;
X
X	for (i = 0; i < h->extent.dy; i++)
X	 {
X		for (j = 0; j < words - odd; j++)
X		 {
X			short word = *d++;
X
X			*s++ = (word >> 8) & 0xFF;
X			*s++ = word & 0xFF;
X		 }
X		if (odd)
X			*s++ = (*d++ >> 8) & 0xFF;
X	 }
X	return string;
X }
X
Xvoid UpdateControl (h, flag) struct hardware *h; int flag;
X {
X }
X
Xvoid RasterTile (from, to, toPoint, extent, rop)
X	struct hardware *from, *to;
X	DevicePoint toPoint, extent;
X	int rop;
X {
X	struct pixrect *fr;
X	
X 	if (to == NULL || extent.dx == 0 || extent.dy == 0)
X 		return;
X 	if (from)
X 		fr = DeviceBitmap (from);
X 	else
X 		fr = NULL;
X	
X 	pr_replrop (DeviceBitmap (to), toPoint.dx, toPoint.dy, extent.dx, extent.dy, rop_map [rop], fr, toPoint.dx, toPoint.dy);
X }
X
Xvoid BitBlt (from, to, fromPoint, toPoint, extent, rop)
X	struct hardware *from, *to;
X	DevicePoint fromPoint, toPoint, extent;
X	int rop;
X {
X	struct pixrect *fr;
X	
X	if (to == NULL || extent.dx == 0 || extent.dy == 0)
X 		return;
X 		
X 	if (from)
X 		fr = DeviceBitmap (from);
X 	else
X 	 {
X 		fr = NULL;
X 		rop = single_rop [rop];
X 	 }
X	
X	pr_rop (DeviceBitmap (to), toPoint.dx, toPoint.dy, extent.dx, extent.dy, rop_map [rop], fr, fromPoint.dx, fromPoint.dy);
X }
X
Xvoid BitBltLine (h, fromPoint, toPoint, rop) 
X  	struct hardware *h;
X	DevicePoint fromPoint, toPoint;
X	int rop;
X {
X 	if (h == NULL)
X 		return;
X 	
X	switch (single_rop [rop])
X	 {
X	 	case ROP_FALSE: 	rop = PIX_NOT (PIX_SET); 	break;
X	 	case ROP_TRUE:  	rop = PIX_SET;  	break;
X	 	case ROP_NOTDEST: 	rop = PIX_NOT (PIX_SRC); 	break;
X	 	case ROP_DEST: 		return; 	break;
X	 	
X	 	default:
X	 		fprintf (stderr, "illegal rasterop\n");
X	 		exit (1);
X	 }
X	
X	pr_vector (DeviceBitmap (h), fromPoint.dx, fromPoint.dy, toPoint.dx, toPoint.dy, rop, ~0);
X }
X
Xvoid BitBltBlob (to, top, height, left, right, rop) struct hardware *to; int top, height, *left, *right, rop;
X {
X 	int i, op, offset = top;
X 	struct pixrect *bm;
X 	height += top;
X 	switch (rop)
X 	 {
X 	 	case ROP_FALSE: 	op = PIX_NOT (PIX_SET); break;
X 	 	case ROP_DEST: 		return;
X 	 	case ROP_NOTDEST: 	op = PIX_NOT (PIX_SRC); break;
X 	 	case ROP_TRUE: 		op = PIX_SET; break;
X 	 }
X 	bm = DeviceBitmap (to);
X 	rop = rop_map [rop];
X 	UpdateControl (to, FALSE);
X 	for (i = top; i < height; i++)
X 		pr_rop (bm, left[i - offset], i, right[i - offset] - left[i - offset], 1, op, bm, 0, 0);
X 	UpdateControl (to, TRUE);
X }
END_OF_FILE
if test 5728 -ne `wc -c <'source/pixrect.c'`; then
    echo shar: \"'source/pixrect.c'\" unpacked with wrong size!
fi
# end of 'source/pixrect.c'
fi
echo shar: End of archive 3 \(of 18\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
