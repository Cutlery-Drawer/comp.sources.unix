Subject:  v12i056:  A PostScript interpreter, Part07/18
Newsgroups: comp.sources.unix
Sender: sources
Approved: rs@uunet.UU.NET

Submitted-by:          Crispin Goswell <caag@vd.rl.ac.uk>
Posting-number: Volume 12, Issue 56
Archive-name: postscript/part07

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 18)."
if test -f 'doc/hard-interface.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/hard-interface.c'\"
else
echo shar: Extracting \"'doc/hard-interface.c'\" \(10105 characters\)
sed "s/^X//" >'doc/hard-interface.c' <<'END_OF_FILE'
X#include "main.h"
X#include "graphics.h"
X
Xstruct hardware
X {
X 	/*
X 	 * Each driver is expected to provide its own definition of this structure.
X 	 * It is only ever used as a pointer and is never dereferenced outside the driver.
X 	 */
X 	int pad;
X };
X
X/*
X *	This file describes the interface that PostScript requires to the graphics system at Version 1.4.
X *	
X *	''Hardware'' in this context refers to a pointer to windows and/or bitmaps and is the lowest level
X *	of access that PostScript is interested in. Any Hardware parameter may be expected to be NULL.
X */
X
X/*********************************** CREATION OF WINDOWS AND BITMAPS *******************/
X
Xstruct hardware *InitHardware () {}
X/*
X *	InitHardware () returns a default device which PostScript may use immediately (or NULL if not appropriate).
X *	Its size and shape are not defined. Most typically the user will want to start up another device
X *	before it is used anyway. No attempt will be made by PostScript to Destroy the resulting
X *	device.
X */
X
Xstruct hardware *NewBitmapHardware (width, height) int width, height; {}
X
Xstruct hardware *NewWindowHardware (width, height) int width, height; {}
X/*
X *	NewBitmapHardware () is expected to create a new bitmap. Only one plane will be needed.
X *	
X *	NewWindowHardware () is expected to create a window on the screen. On a colour system this will
X *	be expected to support full colour.
X */
X
Xint IsWindowHardware (h) struct hardware *h; {}
X/*
X *	IsWindowHardware () should return TRUE if the hardware is a window, FALSE otherwise.
X *	NULL is a window.
X */
X
Xvoid DestroyHardware (h) struct hardware *h; {}
X/*	
X *	DestroyHardware () should release the resources required by the hardware, bitmap or window.
X *	This should cause a window device to vanish. NULL is not an error (does nothing).
X */
X
X
XMatrix DeviceMatrix (width, height) int width, height; {}
X
X/*
X *
X *	DeviceMatrix () should return a matrix appropriate to a device of the given height and width.
X *	For a typical display with a graphics origin at the top left of a window,
X *	an appropriate definition would be:
X *	
X *	Matrix DeviceMatrix (width, height) int width, height;
X *	 {
X *	 	return NewMatrix (PIXELS_PER_INCH / 72.0, 0.0, 0.0, -PIXELS_PER_INCH / 72.0, 0.0, (float) height);
X *	 }
X */
X
XDevicePoint HardwareExtent (h) struct hardware *h; {}
X/*	HardwareExtent () returns a DevicePoint describing the width and height of the argument.
X *	NULL has extent NewDevicePoint (0, 0).
X */
X
X/******************************************* OUTPUT PRIMITIVES ******************************/	
X
Xvoid BitBlt (from, to, fromPoint, toPoint, extent, rop)
X	struct hardware *from, *to;
X	DevicePoint toPoint, fromPoint, extent;
X	int rop;
X {}
X
Xvoid Paint (from, to, fromPoint, toPoint, extent, colour)
X	struct hardware *from, *to;
X	DevicePoint toPoint, fromPoint, extent;
X	Colour colour;
X {}
X
X/*	
X *	BitBlt () is a full function RasterOp. The 'rop' argument
X *	will have values as described in the header file hard.h. If the from argument is NULL it is taken to be
X *	a bitmap full of ones the shape of the fromPoint and extent. If the to argument is NULL, this is a no-op.
X *	
X *	Paint () is an addition to BitBlt. Bits that are set in the source are Painted into the destination
X *	in the given colour with a copying rasterop so that they replace pixels previously there. If the
X *	machine does not support colour windows, half-toning should be performed. 
X *	Colour values have hue, saturation and brightness components. on a black and white or greyscale
X *	system the brightness value will be a FP value between 0.0 (black) and 1.1 (white), which can be
X *	used as a grey level.
X *	
X *	Paint is expected to mask with the clip mask. BitBlt is not,
X */
X
Xvoid BitBltTrapezoid (to, lefttop, leftbottom, righttop, rightbottom, top, bottom, rop)
X	struct hardware *to;
X	DevicePoint lefttop, leftbottom, righttop, rightbottom;
X	int top, bottom, rop;
X {}
X
Xvoid PaintTrapezoid (to, lefttop, leftbottom, righttop, rightbottom, top, bottom, colour)
X	struct hardware *to;
X	DevicePoint lefttop, leftbottom, righttop, rightbottom;
X	int top, bottom;
X	Colour colour;
X {}
X
X/*
X * 	BitBltTrapezoid () and PaintTrapezoid () render a complete trapezoidal shape.
X *	The corners of the trapezoid may lie far outside the range of interesting scan-lines, but the slope
X *	of the line should be clipped by the top and bottom. The coordinates are half-open.
X */
X
Xvoid BitBltLine (h, fromPoint, toPoint, rop)
X	struct hardware *h;
X	DevicePoint fromPoint, toPoint;
X	int rop;
X {}
X
Xvoid PaintLine (h, fromPoint, toPoint, colour)
X	struct hardware *h;
X	DevicePoint fromPoint, toPoint;
X	Colour colour;
X {}
X
X/*	
X *	BitBltLine () is expected to draw a line between the given points
X *	with the given RasterOp and colour masking.
X *	The line should be one pixel wide and half-open.
X *	[Thicker lines are done with BitBlt.]
X *	
X *	PaintLine () is expected to Paint a line by analogy with Paint and BitBlt.
X */
X
Xvoid BitBltBlob (to, top, height, left, right, rop)
X	struct hardware *to;
X	int top, height, *left, *right, rop;
X {}
X
X /*
X  *	BitBltBlob () takes a set of pixel coordinates and fills the trapezon figure
X  *	half open.
X  */
X
Xvoid RasterTile (from, to, toPoint, extent, rop)
X	struct hardware *from, *to;
X	DevicePoint toPoint, extent;
X	int rop;
X {}
X
X/*
X *	RasterTile () replicates the whole of ``from'' over ``to'', but clipped by the
X *	rectangle bounded by ``toPoint'' and ``extent''.
X */
X
X/*********************************** BRIGHTNESS TRANSFER FUNCTION ************************/
X
Xint TransferSize () {}
X
Xvoid SetTransfer (vec) float *vec; {}
X/*	
X *	TransferSize () and SetTransfer () control the mapping function between user brightnesses
X *	and device brightnesses. The interface is expected to perform this mapping of brightnesses
X *	to a sufficient resolution. SetTransfer takes a table of floating point numbers between
X *	0 and 1. User brightnesses are scaled to the size of this table and mapped through it.
X *	The argument table given to SetTransfer () will be deleted after use. TransferSize () simply
X *	enquires the required size of the table.
X *	
X *	It may be appropriate to half-tone on a grayscale or colour device to improve rendering if it is not too
X *	expensive. TransferSize () returns the size of the pattern table.
X */
X
X/********************************** BITMAP CONVERSION ********************************/
X
Xchar *StringFromHardware (h) struct hardware *h; {}
X
Xstruct hardware *HardwareFromString (s, width, height) char *s; int width, height; {}
X/*	
X *	StringFromHardware () produces a string from its argument which describes the bitmap.
X *	The bitmap is returned in row-major order with the leftmost bit of each byte in the most significant
X *	position. Rows are padded to byte boundaries. Only single plane bitmaps are used.
X *	
X *	HardwareFromString () performs the inverse mapping, generating a bitmap from a set of bits, given
X *	a width and height. Only single plane bitmaps are used.
X */
X
X/************************************* HALF-TONE SCREEN ***********************************/
X
Xint ScreenSize (freq, rotation) float freq, rotation; {}
X
Xvoid BuildScreen (freq, rotation, x, y) float freq, rotation, *x, *y; {}
X
Xvoid SetScreen (freq, rotation, thresh) float freq, rotation, *thresh; {}
X/*
X *	ScreenSize () allows PostScript to determine how large an array of sample points to expect.
X *	It should return the length of the side of the sample square.
X *	
X *	BuildScreen () returns a set of sampling coordinates to PostScript to hand to the users spot-function
X *	
X *	SetScreen () allows PostScript to set the thresholds for each sample point so that half-tone bitmaps
X *	can be made.
X */
X
X/************************************* CLIPPING **********************************************/
X
Xvoid SetClipHardware (h, clip) struct hardware *h, *clip; {}
X/*	
X *	SetClipHardware sets hardware which is a clip mask for BitBlt. This mask should be ANDed with any output
X *	operation. If clip is NULL, masking will not be needed.
X */
X
X/**************************************** UPDATE CONTROLS ******************************************/
X
Xvoid HardUpdate () {}
X/*
X *	HardUpdate is a hook to allow devices which do output buffering to flush that buffering when appropriate.
X *	This allows an interactive user to see completed graphics between prompts (it is called as a side-effect
X *	of the PostScript flush operator). Typically is is a no-op.
X */
X
Xvoid UpdateControl (h, on) struct hardware *h; int on; {}
X/*
X * 	This call can be used to enable batching of output operations. UpdateControl (h, FALSE) means ``start of
X *	batching'' UpdateControl (h, TRUE) means ``end of batching''. It is used to improve performance on machines
X *	where screen updates have a high locking overhead. It may be a no-op.
X *	The operation should nest if batching is already in progress: FALSE increments a counter,
X *	TRUE decrements a counter. Display changes are allowed when the counter is non-zero.
X */
X
X/********************************** CANONICAL IMPLEMENTATION LIBRARY ******************************/
X
X/*
X *	Some parts of the above interface can be supported by a canonical library.
X *	This library contains:
X
XSetClipHardware
XHardUpdate
XIsWindowHardware
XHardwareExtent
X
XPaintTrapezoid
XBitBltTrapezoid
X
XPaint
XPaintLine
X
XDeviceMatrix
XInitTransfer
XTransferSize
XSetTransfer
XScreenSize
XBuildScreen
XSetScreen
X
X *
X *	As the driver matures, the user may provide his own versions of the canonical routines.
X *	This leaves the following for implementation by the user.
X *
X
XInitHardware
XNewBitmapHardware
XNewWindowHardware
XDestroyHardware
XHardwareFromString
XStringFromHardware
XUpdateControl
XRasterTile
XBitBlt
XBitBltLine
XBitBltBlob
X
X *	There is a pedagogical implementation in null.c
X *	
X *	There are a number of interface issues concerning the canonical driver.
X *	Firstly, a canonical struct hardware is defined, which contains a union of
X *	a char * and an int handle. The remainder are expected to use this to store
X *	device specific information.
X *
X *	InitTransfer() should be called during InitHardware with the number of pixels
X *	per inch on the display as an argument.
X */
END_OF_FILE
if test 10105 -ne `wc -c <'doc/hard-interface.c'`; then
    echo shar: \"'doc/hard-interface.c'\" unpacked with wrong size!
fi
# end of 'doc/hard-interface.c'
fi
if test -f 'postscript/fonts/Sans/italic.r' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'postscript/fonts/Sans/italic.r'\"
else
echo shar: Extracting \"'postscript/fonts/Sans/italic.r'\" \(9970 characters\)
sed "s/^X//" >'postscript/fonts/Sans/italic.r' <<'END_OF_FILE'
XCharStrings
X/651
X<C943
X4841
X4640
X4440
X4241
X4142
X4044
X4046
X4148
X4349
X4549
X4748
X4846
X4A40
X4945
X4948
X4A49
X4B49
X4D48
X4E47
X5044
X>
Xput
XMetrics
X/651
X[0
X16]
Xput
XCharStrings
X/652
X<C044
X4241
X453C
X463A
X4737
X4735
X4634
X4435
X4337
X423B
X4142
X4148
X4249
X4349
X4548
X4746
X4843
X4840
X4944
X4A45
X4C45
X4E44
X>
Xput
XMetrics
X/652
X[7
X14]
Xput
XCharStrings
X/653
X<C742
X4741
X4640
X4440
X4241
X4142
X4044
X4046
X4148
X4349
X4649
X4947
X4B44
X>
Xput
XMetrics
X/653
X[0
X11]
Xput
XCharStrings
X/654
X<C943
X4841
X4640
X4440
X4241
X4142
X4044
X4046
X4148
X4349
X4549
X4748
X4846
X4E34
XCA40
X4945
X4948
X4A49
X4B49
X4D48
X4E47
X5044
X>
Xput
XMetrics
X/654
X[6
X16]
Xput
XCharStrings
X/655
X<C147
X4346
X4445
X4543
X4541
X4440
X4340
X4141
X4043
X4046
X4148
X4349
X4549
X4748
X4847
X4A44
X>
Xput
XMetrics
X/655
X[0
X10]
Xput
XCharStrings
X/656
X<C044
X443F
X463C
X473A
X4837
X4835
X4734
X4535
X4437
X423F
X3F48
X3C4F
X3B52
X3B54
X3C55
X3E54
X3F51
X4048
X4149
X4349
X4548
X4647
X4844
X>
Xput
XMetrics
X/656
X[9
X8]
Xput
XCharStrings
X/657
X<C943
X4841
X4640
X4440
X4241
X4142
X4044
X4046
X4148
X4349
X4549
X4748
X4847
XCA40
X4847
X4452
X4354
X4155
X4054
X4052
X414F
X444C
X474A
X4949
X4C47
X4F44
X>
Xput
XMetrics
X/657
X[0
X15]
Xput
XCharStrings
X/658
X<C044
X4241
X453C
X463A
X4737
X4735
X4634
X4435
X4337
X423B
X4141
X4049
XC049
X4146
X4244
X4441
X4640
X4840
X4941
X4943
X4846
X4848
X4949
X4A49
X4C48
X4D47
X4F44
X>
Xput
XMetrics
X/658
X[7
X15]
Xput
XCharStrings
X/659
X<C33B
X433C
X443C
X443B
X433B
XC044
X4240
X4046
X4048
X4149
X4249
X4448
X4547
X4744
X>
Xput
XMetrics
X/659
X[3
X7]
Xput
XCharStrings
X/660
X<C33B
X433C
X443C
X443B
X433B
XC044
X4240
X3C52
X3B54
X3955
X3854
X3852
X394F
X3C4C
X3F4A
X4149
X4447
X4744
X>
Xput
XMetrics
X/660
X[8
X7]
Xput
XCharStrings
X/661
X<C044
X4241
X453C
X463A
X4737
X4735
X4634
X4435
X4337
X423B
X4141
X4049
XC049
X4146
X4244
X4441
X4640
X4840
X4941
X4943
X4744
X4444
XC444
X4645
X4748
X4849
X4949
X4B48
X4C47
X4E44
X>
Xput
XMetrics
X/661
X[7
X14]
Xput
XCharStrings
X/662
X<C044
X4241
X453C
X463A
X4737
X4735
X4634
X4435
X4337
X423B
X4142
X4148
X4249
X4349
X4548
X4647
X4844
X>
Xput
XMetrics
X/662
X[9
X8]
Xput
XCharStrings
X/663
X<C044
X4241
X4440
X4541
X4542
X4446
X4349
XC446
X4544
X4741
X4940
X4B40
X4C41
X4C42
X4B46
X4A49
XCB46
X4C44
X4E41
X5040
X5240
X5341
X5343
X5246
X5248
X5349
X5449
X5648
X5747
X5944
X>
Xput
XMetrics
X/663
X[0
X25]
Xput
XCharStrings
X/664
X<C044
X4241
X4440
X4541
X4542
X4446
X4349
XC446
X4544
X4741
X4940
X4B40
X4C41
X4C43
X4B46
X4B48
X4C49
X4D49
X4F48
X5047
X5244
X>
Xput
XMetrics
X/664
X[0
X18]
Xput
XCharStrings
X/665
X<C640
X4440
X4241
X4142
X4044
X4046
X4148
X4349
X4549
X4748
X4847
X4945
X4943
X4841
X4640
X4541
X4543
X4645
X4846
X4B46
X4D45
X4E44
X>
Xput
XMetrics
X/665
X[0
X14]
Xput
XCharStrings
X/666
X<C044
X4241
X433F
X4243
X3C55
XC243
X4341
X4540
X4740
X4941
X4A43
X4A45
X4947
X4848
X4649
XC248
X4449
X4749
X4A48
X4C47
X4F44
X>
Xput
XMetrics
X/666
X[4
X15]
Xput
XCharStrings
X/667
X<C943
X4841
X4640
X4440
X4241
X4142
X4044
X4046
X4148
X4349
X4549
X4748
XCA40
X4943
X4748
X444F
X4352
X4354
X4455
X4654
X4751
X474A
X4949
X4C47
X4F44
X>
Xput
XMetrics
X/667
X[0
X15]
Xput
XCharStrings
X/668
X<C044
X4241
X433F
X4341
X4641
X4742
X4744
X4647
X4648
X4749
X4849
X4A48
X4B47
X4D44
X>
Xput
XMetrics
X/668
X[0
X13]
Xput
XCharStrings
X/669
X<C044
X4241
X433F
X4341
X4544
X4646
X4648
X4449
XC048
X4249
X4649
X4848
X4947
X4B44
X>
Xput
XMetrics
X/669
X[0
X11]
Xput
XCharStrings
X/670
X<C044
X4241
X443D
XC734
X4146
X4148
X4249
X4449
X4648
X4747
X4944
XC13C
X483C
X>
Xput
XMetrics
X/670
X[9
X9]
Xput
XCharStrings
X/671
X<C044
X4240
X4046
X4048
X4149
X4349
X4548
X4746
X4943
XCA40
X4846
X4848
X4949
X4A49
X4C48
X4D47
X4F44
X>
Xput
XMetrics
X/671
X[0
X15]
Xput
XCharStrings
X/672
X<C044
X4240
X4145
X4148
X4249
X4349
X4648
X4846
X4943
X4940
XC940
X4A44
X4B45
X4D45
X4F44
X>
Xput
XMetrics
X/672
X[0
X15]
Xput
XCharStrings
X/673
X<C340
X4142
X4045
X4047
X4149
X4349
X4548
X4746
XC940
X4746
X4748
X4849
X4A49
X4C48
X4E46
X4F43
X4F40
XCF40
X5044
X5145
X5345
X5544
X>
Xput
XMetrics
X/673
X[0
X21]
Xput
XCharStrings
X/674
X<C044
X4241
X4440
X4640
X4741
X4748
X4849
X4B49
X4E47
X5044
XCD41
X4C40
X4A40
X4941
X4548
X4449
X4249
X4148
X>
Xput
XMetrics
X/674
X[0
X16]
Xput
XCharStrings
X/675
X<C044
X4240
X4046
X4048
X4149
X4349
X4548
X4746
X4943
XCA40
X4452
X4354
X4155
X4054
X4052
X414F
X444C
X474A
X4949
X4C47
X4F44
X>
Xput
XMetrics
X/675
X[0
X15]
Xput
XCharStrings
X/676
X<C044
X4241
X4440
X4640
X4842
X4844
X4746
X4548
X4249
X444A
X454C
X454F
X4452
X4354
X4155
X4054
X4052
X414F
X444C
X474A
X4B47
X4E44
X>
Xput
XMetrics
X/676
X[0
X14]
Xput
XCharStrings
X/677
X<C149
X4448
X4746
X4944
X4B41
X4D3D
X4E39
X4E37
X4D35
X4B34
X4935
X4836
X4738
X463D
X4642
X4746
X4848
X4A49
X4C49
X4E48
X4F47
X>
Xput
XMetrics
X/677
X[4
X18]
Xput
XCharStrings
X/683
X<CE43
X4E40
X4D3D
X4C3C
X4A3B
X483B
X463C
X443E
X4341
X4344
X4447
X4548
X4749
X4949
X4B48
X4D46
X4E43
X4F3E
X4F39
X4E36
X4D35
X4B34
X4934
X4735
X4537
X>
Xput
XMetrics
X/683
X[3
X18]
Xput
XCharStrings
X/684
X<CD3C
X4B3B
X483B
X463C
X443E
X4341
X4344
X4447
X4548
X4749
X4A49
X4C48
XC342
X4B42
X>
Xput
XMetrics
X/684
X[-3
X16]
Xput
XCharStrings
X/685
X<CA34
X4835
X4638
X453A
X443D
X4342
X4346
X4448
X4549
X4749
X4948
X4B45
X4C43
X4D40
X4E3B
X4E37
X4D35
X4C34
X4A34
XC43E
X4D3E
X>
Xput
XMetrics
X/685
X[4
X17]
Xput
XCharStrings
X/686
X<CE34
X4650
XC93B
X463C
X443E
X4341
X4344
X4446
X4648
X4949
X4B49
X4E48
X5046
X5143
X5140
X503E
X4E3C
X4B3B
X493B
X>
Xput
XMetrics
X/686
X[2
X20]
Xput
XCharStrings
X/687
X<CF3D
X4E3C
X4B3B
X483B
X453C
X443D
X433F
X4341
X4443
X4645
X4A48
X4B4A
X4B4C
X4A4D
X484D
X>
Xput
XMetrics
X/687
X[-3
X18]
Xput
XCharStrings
X/697
X<8000
X27A3C
X4400
X002FB
X3848
X>
Xput
XMetrics
X/697
X[64
X0]
Xput
XCharStrings
X/551
X<C049
X4248
X4545
X4841
X4C3A
X4F34
X4F49
X4E46
X4C43
X4A41
X473F
X453F
X4440
X4442
X4544
X4746
X4A48
X4D49
X5249
X>
Xput
XMetrics
X/551
X[1
X20]
Xput
XCharStrings
X/552
X<CD36
X4E37
X4E3A
X4D3E
X4C41
X4B43
X4946
X4748
X4549
X4449
X4348
X4345
X4440
X453D
X463B
X4838
X4A36
X4C35
X4F34
X5234
X5435
X5537
X5539
X543B
X533C
X513D
X4E3E
XCD3E
X4E3E
X513F
X5240
X5342
X5345
X5247
X5148
X4F49
X4C49
X4A48
X4946
X>
Xput
XMetrics
X/552
X[0
X23]
Xput
XCharStrings
X/553
X<CC3A
X4C3B
X4D3C
X4F3C
X513B
X5239
X5237
X5135
X4F34
X4C34
X4935
X4737
X453A
X443C
X4340
X4344
X4447
X4548
X4749
X4949
X4C48
X4E46
X4F44
X>
Xput
XMetrics
X/553
X[2
X20]
Xput
XCharStrings
X/554
X<CD34
X4B35
X4A37
X493B
X4841
X4744
X4646
X4448
X4249
X4049
X3F48
X3F46
X4045
X4245
X4446
X4648
X4949
X4C49
X4F48
X5146
X5342
X543D
X5439
X5336
X5235
X5034
X4D34
X4B36
X4B38
X4C3B
X4E3E
X5040
X5342
X5543
X>
Xput
XMetrics
X/554
X[1
X23]
Xput
XCharStrings
X/555
X<CE38
X4E39
X4F3A
X513A
X5239
X5237
X5135
X4E34
X4A34
X4735
X4637
X463A
X473C
X483D
X4B3E
X483E
X453F
X4440
X4342
X4345
X4447
X4548
X4849
X4B49
X4E48
X5046
X5144
X>
Xput
XMetrics
X/555
X[2
X20]
Xput
XCharStrings
X/556
X<CA3A
X483A
X4639
X4537
X4635
X4934
X4C34
X5035
X5335
X5534
XD035
X4E3C
X4C42
X4A46
X4848
X4649
X4449
X4248
X4146
X4144
X4243
X4443
X4644
XC93E
X523E
X>
Xput
XMetrics
X/556
X[2
X20]
Xput
XCharStrings
X/557
X<C049
X4248
X4644
X493F
X4A3C
X4B38
X4B35
X4A34
X4934
X4835
X4737
X473A
X483C
X4A3D
X4E3D
X513C
X523B
X5339
X533F
X5244
X5146
X4F48
X4C49
X4849
X4548
X4346
X4244
X4242
X>
Xput
XMetrics
X/557
X[1
X23]
Xput
XCharStrings
X/558
X<C73B
X453A
X4438
X4437
X4535
X4734
X4834
X4A35
X4B37
X4B39
X4A3D
X4843
X4647
X4449
X4249
X4148
X4146
XC740
X503D
X523C
X553A
X5738
X5836
X5835
X5734
X5634
X5436
X523A
X5040
X4F45
X4F48
X5049
X5149
X5348
X5447
X5644
X>
Xput
XMetrics
X/558
X[0
X24]
Xput
XCharStrings
X/559
X<CE44
X4C42
X4A3F
X493D
X483A
X4837
X4935
X4A34
X4C34
X4D35
X4E37
X4E3A
X4D3F
X4B44
X4A46
X4848
X4649
X4449
X4248
X4146
X4144
X4243
X4443
X4644
X>
Xput
XMetrics
X/559
X[3
X17]
Xput
XCharStrings
X/560
X<CA4C
X4849
X4644
X453E
X4538
X4635
X4834
X4A34
X4B35
X4C38
X4C3B
X4B40
X4849
X464F
X4552
X4454
X4255
X4154
X4152
X424F
X444C
X464A
X4948
X4D46
X>
Xput
XMetrics
X/560
X[4
X15]
Xput
XCharStrings
X/561
X<C73B
X453A
X4438
X4437
X4535
X4734
X4834
X4A35
X4B37
X4B39
X4A3D
X4843
X4647
X4449
X4249
X4148
X4146
XD837
X5835
X5734
X5634
X5435
X5237
X503A
X4E3C
X4C3D
X4A3D
XCC3D
X4D3F
X4D46
X4E48
X4F49
X5049
X5248
X5347
X5544
X>
Xput
XMetrics
X/561
X[0
X24]
Xput
XCharStrings
X/562
X<C440
X4640
X4A3F
X4D3D
X4F3B
X5039
X5036
X4F34
X4D34
X4C35
X4B37
X4A3C
X4941
X4844
X4746
X4548
X4349
X4149
X4048
X4046
X4145
X4345
X4546
X4848
X4B49
X4D49
X5048
X5246
X>
Xput
XMetrics
X/562
X[3
X19]
Xput
XCharStrings
X/563
X<C53B
X433A
X4238
X4237
X4335
X4534
X4634
X4835
X4937
X4939
X483E
X4742
X4549
XC742
X4A3A
X4C36
X4D35
X4F34
X5034
X5235
X5337
X5339
X523E
X5142
X4F49
XD142
X543A
X5636
X5735
X5934
X5A34
X5C35
X5D37
X5D39
X5C3E
X5A45
X5A48
X5B49
X5C49
X5E48
X5F47
X6144
X>
Xput
XMetrics
X/563
X[-2
X33]
Xput
XCharStrings
X/564
X<C53B
X433A
X4238
X4237
X4335
X4534
X4634
X4835
X4937
X4939
X483E
X4742
X4549
XC742
X4A3A
X4C36
X4D35
X4F34
X5134
X5335
X5437
X5439
X533E
X5145
X5148
X5249
X5349
X5548
X5647
X5844
X>
Xput
XMetrics
X/564
X[-1
X24]
Xput
XCharStrings
X/565
X<CC34
X4935
X4737
X453A
X443C
X4340
X4344
X4447
X4548
X4749
X4949
X4C48
X4E46
X5043
X5141
X523D
X5239
X5136
X5035
X4E34
X4C34
X4A36
X4A39
X4B3C
X4D3F
X4F41
X5243
X5444
X>
Xput
XMetrics
X/565
X[2
X21]
Xput
XCharStrings
X/566
X<CD36
X4E37
X4E3A
X4D3E
X4C41
X4B43
X4946
X4748
X4549
X4449
X4348
X4345
X4440
X453D
X463B
X4838
X4A36
X4C35
X4F34
X5434
X5635
X5736
X5838
X583B
X573D
X563E
X543F
X513F
X4F3E
X4E3D
X>
Xput
XMetrics
X/566
X[0
X25]
Xput
XCharStrings
X/567
X<CD3A
X4C3C
X4B3D
X493E
X473E
X463C
X463A
X4737
X4935
X4C34
X4F34
X5135
X5237
X523B
X513E
X4F41
X4B45
X4847
X4648
X4349
X4149
X4048
X4046
X4145
X4345
X4546
X4848
X4B49
X4E49
X5148
X5346
X>
Xput
XMetrics
X/567
X[2
X22]
Xput
XCharStrings
X/568
X<CD36
X4E37
X4E3A
X4D3E
X4C41
X4B43
X4946
X4748
X4549
X4449
X4348
X4345
X4440
X453D
X463B
X4838
X4A36
X4C35
X4F34
X5334
X5535
X5636
X5738
X573B
X563D
X553E
X533F
X503F
X4D3E
X4E3F
X4F41
X4F46
X5048
X5249
X5448
X5547
X5744
X>
Xput
XMetrics
X/568
X[0
X25]
Xput
XCharStrings
X/569
X<C049
X4248
X4446
X4742
X493F
X4B3B
X4C38
X4C35
X4B34
X4A34
X4935
X4837
X4839
X493B
X4B3D
X4E3F
X5041
X5143
X5145
X5047
X4F48
X4C49
X4849
X4548
X4346
X4244
X4242
X>
Xput
XMetrics
X/569
X[2
X20]
Xput
XCharStrings
X/570
X<CA3A
X483A
X4639
X4537
X4635
X4934
X4C34
X5035
X5335
X5534
XD035
X4E3C
X4C42
X4A46
X4848
X4649
X4449
X4248
X4146
X4144
X4243
X4443
X4644
X>
Xput
XMetrics
X/570
X[2
X19]
Xput
XCharStrings
X/571
X<C53B
X433A
X4238
X4237
X4335
X4534
X4634
X4835
X4937
X4939
X483D
X4740
X4644
X4646
X4748
X4949
X4B49
X4D48
X4E47
X5043
X533B
X5534
XD33B
X523F
X5145
X5148
X5249
X5349
X5548
X5647
X5844
X>
Xput
XMetrics
X/571
X[-1
X24]
Xput
XCharStrings
X/572
X<C53B
X433A
X4238
X4237
X4335
X4534
X4634
X4835
X4937
X4939
X483D
X4740
X4644
X4647
X4749
X4949
X4B48
X4E45
X5042
X523E
X533B
X5437
X5435
X5334
X5234
X5135
X5037
X5039
X513C
X533E
X553F
X>
Xput
XMetrics
X/572
X[0
X23]
Xput
XCharStrings
X/573
X<C53B
X433A
X4238
X4237
X4335
X4534
X4634
X4835
X4937
X493A
X4849
XD234
X4849
XD234
X5049
XDE34
X5C35
X5938
X563C
X5342
X5049
X>
Xput
XMetrics
X/573
X[-2
X28]
Xput
XCharStrings
X/574
X<C83A
X463A
X4539
X4537
X4635
X4834
X4A34
X4C35
X4D37
X4D3A
X4B43
X4B46
X4C48
X4E49
X5049
X5248
X5346
X5344
X5243
X5043
XD737
X5735
X5634
X5434
X5235
X5037
X4E3A
X4A43
X4846
X4648
X4449
X4249
X4148
X4146
X>
Xput
XMetrics
X/574
X[0
X24]
Xput
XCharStrings
X/575
X<C53B
X433A
X4238
X4237
X4335
X4534
X4634
X4835
X4937
X4939
X483D
X4740
X4644
X4646
X4748
X4849
X4A49
X4C48
X4E46
X5043
X5141
X533B
XD534
X533B
X5045
X4E4B
X4C50
X4A54
X4855
X4754
X4752
X484F
X4A4C
X4D49
X5047
X5544
X>
Xput
XMetrics
X/575
X[0
X23]
Xput
XCharStrings
X/576
X<CD3A
X4C3C
X4B3D
X493E
X473E
X463C
X463A
X4737
X4935
X4C34
X4F34
X5135
X5237
X523B
X513E
X4F42
X4C45
X4848
X4649
X4349
X4248
X4246
X4345
X4645
X4846
X4947
X4A49
X4A4C
X494F
X4851
X4654
X4455
X4354
X4352
X444F
X464C
X4949
X4C47
X5244
X>
Xput
XMetrics
X/576
X[2
X21]
Xput
END_OF_FILE
if test 9970 -ne `wc -c <'postscript/fonts/Sans/italic.r'`; then
    echo shar: \"'postscript/fonts/Sans/italic.r'\" unpacked with wrong size!
fi
# end of 'postscript/fonts/Sans/italic.r'
fi
if test -f 'postscript/fonts/times/italic.r' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'postscript/fonts/times/italic.r'\"
else
echo shar: Extracting \"'postscript/fonts/times/italic.r'\" \(9432 characters\)
sed "s/^X//" >'postscript/fonts/times/italic.r' <<'END_OF_FILE'
XCharStrings
X/a<CB3D
X4944
X4945
X4A46
X4C46
X4D45
X4E43
XCC3D
X4A44
X4A45
X4B46
XCA41
X4A3F
X483D
X463D
X443E
X433F
X4241
X4243
X4345
X4546
X4746
X4944
XC63D
X443F
X4341
X4344
X4546
X>
Xput
XMetrics
X/a[-2
X15]
Xput
XCharStrings
X/b<C539
X4340
XC639
X4440
X4444
X4646
XC440
X453E
X473D
X493D
X4B3E
X4C40
X4C42
X4B44
X4A45
X4846
X4646
X4445
X4343
X4340
XC93D
X4B3F
X4B42
X4A44
X4846
XC339
X4639
X>
Xput
XMetrics
X/b[-1
X14]
Xput
XCharStrings
X/c<CA3E
X4A3F
X4B3F
X4A3E
X483D
X463D
X443E
X433F
X4241
X4243
X4345
X4546
X4746
X4945
X4A44
XC63D
X443F
X4341
X4344
X4546
X>
Xput
XMetrics
X/c[-2
X13]
Xput
XCharStrings
X/d<CC39
X4944
X4945
X4A46
X4C46
X4D45
X4E43
XCD39
X4A44
X4A45
X4B46
XCA41
X4A3F
X483D
X463D
X443E
X433F
X4241
X4243
X4345
X4546
X4746
X4944
XC63D
X443F
X4341
X4344
X4546
XCA39
X4D39
X>
Xput
XMetrics
X/d[0
X15]
Xput
XCharStrings
X/e<C343
X4742
X4941
X4A40
X4A3E
X483D
X463D
X443E
X433F
X4241
X4243
X4345
X4546
X4746
X4945
X4A44
XC63D
X443F
X4341
X4344
X4546
X>
Xput
XMetrics
X/e[-2
X12]
Xput
XCharStrings
X/f<CA39
X4B3A
X4B39
X4939
X473A
X463C
X4347
X4249
X414A
XC939
X483A
X473C
X4447
X4349
X414A
X3F4A
X3F49
X404A
XC33D
X493D
X>
Xput
XMetrics
X/f[2
X11]
Xput
XCharStrings
X/g<CB3D
X4944
X4847
X4749
XCC3D
X4A44
X4947
X4749
X454A
X424A
X4149
X4249
X434A
XCA41
X4A3F
X483D
X463D
X443E
X433F
X4241
X4243
X4345
X4546
X4746
X4944
XC63D
X443F
X4341
X4344
X4546
X>
Xput
XMetrics
X/g[-1
X14]
Xput
XCharStrings
X/h<C539
X4146
XC639
X4246
XC43F
X453E
X473D
X493D
X4B3E
X4B40
X4A43
X4A45
X4B46
XC93D
X4A3E
X4A40
X4943
X4945
X4A46
X4C46
X4D45
X4E43
XC339
X4639
X>
Xput
XMetrics
X/h[0
X15]
Xput
XCharStrings
X/i<C639
X463A
X473A
X4739
X4639
XC140
X423E
X433D
X453D
X463E
X4640
X4543
X4545
X4646
XC43D
X453E
X4540
X4443
X4445
X4546
X4746
X4845
X4943
X>
Xput
XMetrics
X/i[2
X10]
Xput
XCharStrings
X/j<C739
X473A
X483A
X4839
X4739
XC240
X433E
X443D
X463D
X473E
X4740
X4547
X4449
X424A
X404A
X4049
X414A
XC53D
X463E
X4640
X4447
X4349
X424A
X>
Xput
XMetrics
X/j[2
X10]
Xput
XCharStrings
X/k<C539
X4146
XC639
X4246
XCB3E
X4A3F
X4B3F
X4B3E
X4A3D
X493D
X473F
X4540
X4440
XC440
X4541
X4645
X4746
X4946
X4A45
X4B43
XC440
X4641
X4745
X4846
XC339
X4639
X>
Xput
XMetrics
X/k[0
X13]
Xput
XCharStrings
X/l<C539
X4244
X4245
X4346
X4546
X4645
X4743
XC639
X4344
X4345
X4446
XC339
X4639
X>
Xput
XMetrics
X/l[3
X8]
Xput
XCharStrings
X/m<C140
X423E
X433D
X453D
X463E
X463F
X4446
XC43D
X453E
X453F
X4346
XC63F
X473E
X493D
X4B3D
X4D3E
X4D3F
X4B46
XCB3D
X4C3E
X4C3F
X4A46
XCD3F
X4E3E
X503D
X523D
X543E
X5440
X5343
X5345
X5446
XD23D
X533E
X5340
X5243
X5245
X5346
X5546
X5645
X5743
X>
Xput
XMetrics
X/m[-1
X24]
Xput
XCharStrings
X/n<C140
X423E
X433D
X453D
X463E
X463F
X4446
XC43D
X453E
X453F
X4346
XC63F
X473E
X493D
X4B3D
X4D3E
X4D40
X4C43
X4C45
X4D46
XCB3D
X4C3E
X4C40
X4B43
X4B45
X4C46
X4E46
X4F45
X5043
X>
Xput
XMetrics
X/n[-1
X17]
Xput
XCharStrings
X/o<C63D
X443E
X433F
X4241
X4243
X4345
X4546
X4746
X4945
X4A44
X4B42
X4B40
X4A3E
X483D
X463D
XC63D
X443F
X4341
X4344
X4546
XC746
X4944
X4A42
X4A3F
X483D
X>
Xput
XMetrics
X/o[-2
X13]
Xput
XCharStrings
X/p<C140
X423E
X433D
X453D
X463E
X463F
X434A
XC43D
X453E
X453F
X424A
XC63F
X483D
X4A3D
X4C3E
X4D40
X4D42
X4C44
X4B45
X4946
X4746
X4544
X4542
XCA3D
X4C3F
X4C42
X4B44
X4946
XC04A
X454A
X>
Xput
XMetrics
X/p[0
X15]
Xput
XCharStrings
X/q<CB3D
X474A
XCC3D
X484A
XCA41
X4A3F
X483D
X463D
X443E
X433F
X4241
X4243
X4345
X4546
X4746
X4944
XC63D
X443F
X4341
X4344
X4546
XC54A
X4A4A
X>
Xput
XMetrics
X/q[-2
X14]
Xput
XCharStrings
X/r<C140
X423E
X433D
X453D
X463E
X463F
X4446
XC43D
X453E
X453F
X4346
XC63F
X473E
X493D
X4A3D
X4B3E
X4B3F
X4A3F
X4B3E
X>
Xput
XMetrics
X/r[-1
X12]
Xput
XCharStrings
X/s<CA3E
X4A3F
X4B3F
X4A3E
X483D
X453D
X433E
X4340
X4541
X4842
X4A43
XC33F
X4540
X4841
X4A42
X4A45
X4846
X4546
X4345
X4244
X4344
X4345
X>
Xput
XMetrics
X/s[-2
X13]
Xput
XCharStrings
X/t<C539
X4244
X4245
X4346
X4546
X4645
X4743
XC639
X4344
X4345
X4446
XC23D
X473D
X>
Xput
XMetrics
X/t[3
X9]
Xput
XCharStrings
X/u<C140
X423E
X433D
X453D
X463E
X4640
X4543
X4545
X4646
XC43D
X453E
X4540
X4443
X4445
X4646
X4846
X4A45
X4B44
XCD3D
X4B44
X4B45
X4C46
X4E46
X4F45
X5043
XCE3D
X4C44
X4C45
X4D46
X>
Xput
XMetrics
X/u[-1
X17]
Xput
XCharStrings
X/v<C140
X423E
X433D
X453D
X463E
X4640
X4543
X4545
X4646
XC43D
X453E
X4540
X4443
X4445
X4646
X4746
X4945
X4B43
X4C40
X4C3D
X4B3D
X4C3E
X>
Xput
XMetrics
X/v[-1
X14]
Xput
XCharStrings
X/w<C140
X423E
X433D
X453D
X463E
X4640
X4543
X4545
X4646
XC43D
X453E
X4540
X4443
X4445
X4646
X4746
X4945
X4A44
XCC3D
X4A44
X4A45
X4C46
XCD3D
X4B44
X4B45
X4C46
X4D46
X4F45
X5143
X5240
X523D
X513D
X523E
X>
Xput
XMetrics
X/w[-1
X20]
Xput
XCharStrings
X/x<C340
X443E
X463D
X483D
X493E
X4940
XC73D
X483E
X4840
X4743
X4645
X4446
X4346
X4245
X4244
X4344
X4245
XCE3E
X4D3F
X4E3F
X4E3E
X4D3D
X4C3D
X4A3E
X4940
X4843
X4845
X4946
XC743
X4745
X4846
X4A46
X4C45
X4D43
X>
Xput
XMetrics
X/x[-2
X16]
Xput
XCharStrings
X/y<C140
X423E
X433D
X453D
X463E
X4640
X4543
X4545
X4646
XC43D
X453E
X4540
X4443
X4445
X4646
X4846
X4A45
X4B44
XCD3D
X4B44
X4A47
X4949
XCE3D
X4C44
X4B47
X4949
X474A
X444A
X4349
X4449
X454A
X>
Xput
XMetrics
X/y[-1
X16]
Xput
XCharStrings
X/z<CC3D
X4C3E
X4B3F
X4344
X4245
X4246
XC33F
X443D
X473D
X4A3F
XC43E
X473E
X4A3F
X4B3F
XC344
X4444
X4745
X4A45
XC444
X4746
X4A46
X4B44
X>
Xput
XMetrics
X/z[-2
X14]
Xput
XCharStrings
X/A<C939
X4046
XC83B
X4946
XC939
X4A46
XC342
X4942
XBE46
X4346
XC746
X4C46
X>
Xput
XMetrics
X/A[2
X14]
Xput
XCharStrings
X/B<C639
X4246
XC739
X4346
XC439
X4B39
X4D3A
X4D3C
X4C3E
X493F
XCB39
X4C3A
X4C3C
X4B3E
X493F
XC53F
X483F
X4A40
X4B41
X4B43
X4A45
X4746
X4046
XC83F
X4A41
X4A43
X4945
X4746
X>
Xput
XMetrics
X/B[0
X15]
Xput
XCharStrings
X/C<CB3A
X4C3A
X4D39
X4C3C
X4B3A
X4939
X4739
X453A
X443B
X433D
X4240
X4243
X4345
X4546
X4746
X4945
X4A43
XC739
X453B
X443D
X4340
X4344
X4546
X>
Xput
XMetrics
X/C[0
X13]
Xput
XCharStrings
X/D<C639
X4246
XC739
X4346
XC439
X4A39
X4C3A
X4D3C
X4D3F
X4C42
X4B44
X4A45
X4746
X4046
XCA39
X4B3A
X4C3C
X4C3F
X4B42
X4A44
X4945
X4746
X>
Xput
XMetrics
X/D[0
X15]
Xput
XCharStrings
X/E<C639
X4246
XC739
X4346
XC93D
X4841
XC439
X4E39
X4D3C
X4D39
XC53F
X483F
XC046
X4A46
X4B43
X4946
X>
Xput
XMetrics
X/E[0
X15]
Xput
XCharStrings
X/F<C639
X4246
XC739
X4346
XC93D
X4841
XC439
X4E39
X4D3C
X4D39
XC53F
X483F
XC046
X4546
X>
Xput
XMetrics
X/F[0
X14]
Xput
XCharStrings
X/G<CB3A
X4C3A
X4D39
X4C3C
X4B3A
X4939
X4739
X453A
X443B
X433D
X4240
X4243
X4345
X4546
X4746
X4945
X4A44
X4B41
XC739
X453B
X443D
X4340
X4344
X4546
XC746
X4944
X4A41
XC841
X4D41
X>
Xput
XMetrics
X/G[0
X14]
Xput
XCharStrings
X/H<C639
X4246
XC739
X4346
XCE39
X4A46
XCF39
X4B46
XC439
X4939
XCC39
X5139
XC53F
X4C3F
XC046
X4546
XC846
X4D46
X>
Xput
XMetrics
X/H[0
X17]
Xput
XCharStrings
X/I<C639
X4246
XC739
X4346
XC439
X4939
XC046
X4546
X>
Xput
XMetrics
X/I[3
X9]
Xput
XCharStrings
X/J<C939
X4643
X4545
X4446
XCA39
X4743
X4645
X4446
X4346
X4145
X4043
X4142
X4243
X4144
XC739
X4C39
X>
Xput
XMetrics
X/J[1
X12]
Xput
XCharStrings
X/K<C639
X4246
XC739
X4346
XCF39
X4540
XC83E
X4A46
XC93E
X4B46
XC439
X4939
XCC39
X5139
XC046
X4546
XC846
X4D46
X>
Xput
XMetrics
X/K[0
X16]
Xput
XCharStrings
X/L<C639
X4246
XC739
X4346
XC439
X4939
XC046
X4A46
X4B43
X4946
X>
Xput
XMetrics
X/L[0
X13]
Xput
XCharStrings
X/M<C639
X4246
XC63B
X4746
XC739
X4844
XD039
X4746
XD039
X4C46
XD139
X4D46
XC439
X4739
XD039
X5339
XC046
X4446
XCA46
X4F46
X>
Xput
XMetrics
X/M[0
X19]
Xput
XCharStrings
X/N<C639
X4246
XC639
X4A46
XC739
X4A43
XCE39
X4A46
XC439
X4739
XCC39
X5039
XC046
X4446
X>
Xput
XMetrics
X/N[0
X16]
Xput
XCharStrings
X/O<C739
X453A
X443B
X433D
X4240
X4243
X4345
X4546
X4746
X4945
X4A44
X4B42
X4C3F
X4C3C
X4B3A
X4939
X4739
XC739
X453B
X443D
X4340
X4344
X4546
XC746
X4944
X4A42
X4B3F
X4B3B
X4939
X>
Xput
XMetrics
X/O[0
X14]
Xput
XCharStrings
X/P<C639
X4246
XC739
X4346
XC439
X4B39
X4D3A
X4E3B
X4E3D
X4D3F
X4A40
X4540
XCB39
X4D3B
X4D3D
X4C3F
X4A40
XC046
X4546
X>
Xput
XMetrics
X/P[0
X15]
Xput
XCharStrings
X/Q<C739
X453A
X443B
X433D
X4240
X4243
X4345
X4546
X4746
X4945
X4A44
X4B42
X4C3F
X4C3C
X4B3A
X4939
X4739
XC739
X453B
X443D
X4340
X4344
X4546
XC746
X4944
X4A42
X4B3F
X4B3B
X4939
XC445
X4444
X4543
X4643
X4744
X4748
X4849
X4949
X4A48
XC744
X4848
X4949
X>
Xput
XMetrics
X/Q[0
X14]
Xput
XCharStrings
X/R<C639
X4246
XC739
X4346
XC439
X4B39
X4D3A
X4E3B
X4E3D
X4D3F
X4A40
X4540
XCB39
X4D3B
X4D3D
X4C3F
X4A40
XC940
X4A45
X4B46
X4C46
X4D45
XC940
X4A41
X4B45
X4C46
XC046
X4546
X>
Xput
XMetrics
X/R[0
X16]
Xput
XCharStrings
X/S<CC3A
X4D3A
X4E39
X4D3C
X4C3A
X4A39
X4739
X453A
X443B
X443D
X453E
X4A41
X4B42
XC43C
X453D
X4A40
X4B41
X4B44
X4A45
X4846
X4546
X4345
X4243
X4146
X4245
X4345
X>
Xput
XMetrics
X/S[0
X15]
Xput
XCharStrings
X/T<C939
X4546
XCA39
X4646
XC539
X433C
X4439
X4F39
X4E3C
X4E39
XC346
X4846
X>
Xput
XMetrics
X/T[0
X15]
Xput
XCharStrings
X/U<C639
X4343
X4345
X4546
X4946
X4B45
X4C43
X4F39
XC739
X4443
X4445
X4546
XC439
X4939
XCD39
X5139
X>
Xput
XMetrics
X/U[-1
X17]
Xput
XCharStrings
X/V<C439
X4546
XC539
X4644
XCE39
X4546
XC239
X4739
XCB39
X5039
X>
Xput
XMetrics
X/V[0
X14]
Xput
XCharStrings
X/W<C539
X4446
XC639
X4544
XCB39
X4446
XCB39
X4A46
XCC39
X4B44
XD139
X4A46
XC339
X4839
XCF39
X5339
X>
Xput
XMetrics
X/W[-2
X18]
Xput
XCharStrings
X/X<C539
X4946
XC639
X4A46
XCE39
X4146
XC339
X4839
XCB39
X5039
XBF46
X4446
XC746
X4C46
X>
Xput
XMetrics
X/X[1
X15]
Xput
XCharStrings
X/Y<C439
X463F
X4446
XC539
X473F
XCD39
X473F
X4546
XC239
X4739
XCA39
X4F39
XC246
X4746
X>
Xput
XMetrics
X/Y[1
X13]
Xput
XCharStrings
X/Z<CC39
X4046
XCD39
X4146
XC539
X433C
X4439
X4D39
XC046
X4946
X4A43
X4846
X>
Xput
XMetrics
X/Z[1
X13]
Xput
XCharStrings
X/ff
X<CD39
X4E3A
X4F3A
X4D39
X4A39
X483A
X473B
X463D
X4347
X4249
X414A
XCA39
X483B
X473D
X4447
X4349
X414A
X3F4A
X3F49
X404A
XD139
X523A
X5239
X5039
X4E3A
X4D3C
X4A47
X4949
X484A
XD039
X4F3A
X4E3C
X4B47
X4A49
X484A
X464A
X4649
X474A
XC33D
X503D
X>
Xput
XMetrics
X/ff
X[1
X18]
Xput
XCharStrings
X/fi
X<CD39
X4E3A
X4F3A
X4F39
X4A39
X483A
X473B
X463D
X4347
X4249
X414A
XCA39
X483B
X473D
X4447
X4349
X414A
X3F4A
X3F49
X404A
XCD3D
X4B44
X4B45
X4C46
X4E46
X4F45
X5043
XCE3D
X4C44
X4C45
X4D46
XC33D
X4E3D
X>
Xput
XMetrics
X/fi
X[1
X17]
Xput
XCharStrings
X/fl
X<CD39
X4E3A
XCF39
X4A39
X483A
X473B
X463D
X4347
X4249
X414A
XCA39
X483B
X473D
X4447
X4349
X414A
X3F4A
X3F49
X404A
XCE39
X4B44
X4B45
X4C46
X4E46
X4F45
X5043
XCF39
X4C44
X4C45
X4D46
XC33D
X4D3D
X>
Xput
XMetrics
X/fl
X[1
X17]
Xput
XCharStrings
X/ffi
X<CD39
X4E3A
X4E3B
XCF3A
X4D39
X4A39
X483A
X473B
X463D
X4347
X4249
X414A
XCA39
X483B
X473D
X4447
X4349
X414A
X3F4A
X3F49
X404A
XD439
X553A
X563A
X5639
X5139
X4F3A
XCE3B
X4D3D
X4A47
X4949
X484A
XD139
X4F3B
X4E3D
X4B47
X4A49
X484A
X464A
X4649
X474A
XD43D
X5244
X5245
X5346
X5546
X5645
X5743
XD53D
X5344
X5345
X5446
XC33D
X553D
X>
Xput
XMetrics
X/ffi
X[1
X24]
Xput
XCharStrings
X/ffl
X<CD39
X4E3A
X4E3B
XCF3A
X4D39
X4A39
X483A
X473B
X463D
X4347
X4249
X414A
XCA39
X483B
X473D
X4447
X4349
X414A
X3F4A
X3F49
X404A
XD439
X553A
XD639
X5139
X4F3A
XCE3B
X4D3D
X4A47
X4949
X484A
XD139
X4F3B
X4E3D
X4B47
X4A49
X484A
X464A
X4649
X474A
XD539
X5244
X5245
X5346
X5546
X5645
X5743
XD639
X5344
X5345
X5446
XC33D
X543D
X>
Xput
XMetrics
X/ffl
X[1
X24]
Xput
XCharStrings
X/dotlessi
X<C140
X423E
X433D
X453D
X463E
X4640
X4543
X4545
X4646
XC43D
X453E
X4540
X4443
X4445
X4546
X4746
X4845
X4943
X>
Xput
XMetrics
X/dotlessi
X[-1
X10]
Xput
XCharStrings
X/space
X<8000
X46E3D
X4300
X004EF
X3A46
X>
Xput
XMetrics
X/space
X[64
X0]
Xput
END_OF_FILE
if test 9432 -ne `wc -c <'postscript/fonts/times/italic.r'`; then
    echo shar: \"'postscript/fonts/times/italic.r'\" unpacked with wrong size!
fi
# end of 'postscript/fonts/times/italic.r'
fi
if test -f 'source/array.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/array.c'\"
else
echo shar: Extracting \"'source/array.c'\" \(9489 characters\)
sed "s/^X//" >'source/array.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X
Xstatic Object OpForAll;
X
Xstatic int PLength (), PArray (), PRBracket (), PAload (), PAstore ();
X
Xstatic int forAll (), ForAll (), PReadOnly (), PExecOnly (), PrCheck (), PwCheck ();
Xstatic int PutInterval (), GetInterval (), Put (), Get (), Length (), Copy (), Eq ();
X
Xint ExecArray ();
XObject Marker;
X
Xstatic int autobind = 0;
X
Xstatic int PSetAutoBind (), PGetAutoBind ();
X
XInitArray ()
X {
X	TypeInstallOp (Mark, 	"eq", EqTrue, 2, 1, 0, 0, Mark, Mark);
X	
X	Marker = MakeObject (Mark);
X 	
X 	OpForAll = MakeOp ("(forallarray)", forAll, 0, 0, 3, 5);
X 	
X 	Install ("[",		Marker);
X 	Install ("null",	Nil);
X 	
X 	InstallOp ("array", 	PArray,		1, 1, 0, 0, Integer);
X 	InstallOp ("]", 	PRBracket,	0, 1, 0, 0);
X 	InstallOp ("aload", 	PAload,		1, 0, 0, 0, Array);
X 	InstallOp ("astore",	PAstore,	1, 1, 0, 0, Array);
X 	
X 	InstallOp ("setautobind",	PSetAutoBind,	1, 0, 0, 0, Boolean);
X 	InstallOp ("getautobind",	PGetAutoBind,	0, 1, 0, 0);
X	
X 	TypeInstallOp (Array, "exec",		ExecArray,	1, 1, 0, 2, Array);
X 	TypeInstallOp (Array, "eq", 		Eq,		2, 1, 0, 0, Array, Array);
X 	TypeInstallOp (Array, "put", 		Put,		3, 0, 0, 0, Array, Integer, Poly);
X 	TypeInstallOp (Array, "get", 		Get,		2, 1, 0, 0, Array, Integer);
X 	TypeInstallOp (Array, "putinterval", 	PutInterval,	3, 0, 0, 0, Array, Integer, Array);
X 	TypeInstallOp (Array, "getinterval", 	GetInterval,	3, 1, 0, 0, Array, Integer, Integer);
X 	TypeInstallOp (Array, "length",	 	PLength,	1, 1, 0, 0, Array);
X 	TypeInstallOp (Array, "copy", 		Copy,		2, 0, 0, 0, Array, Array);
X 	TypeInstallOp (Array, "forall", 	ForAll,		2, 0, 0, 4, Array, Array);
X 	TypeInstallOp (Array, "executeonly", 	PExecOnly,	1, 1, 0, 0, Array);
X 	TypeInstallOp (Array, "readonly", 	PReadOnly,	1, 1, 0, 0, Array);
X 	TypeInstallOp (Array, "rcheck", 	PrCheck,	1, 1, 0, 0, Array);
X 	TypeInstallOp (Array, "wcheck", 	PwCheck,	1, 1, 0, 0, Array);
X }
X
X
XObject MakeArray (p, length) Object *p; int length;
X {
X 	Object res;
X 	
X 	res = MakeObject (Array);
X 	res.u.Array = p;
X 	res.Length = length;
X 	
X 	return res;
X }
X
X
Xstatic Object Make (p, length) Object *p; int length;
X {
X 	Object res;
X 	
X 	res = MakeObject (Array);
X 	res.u.Array = p;
X 	res.Length = length;
X 	
X 	return res;
X }
X
Xstatic Object *Body (item) Object item;
X {
X 	return item.u.Array;
X }
X
X#define Body(a) ((a).u.Array)
X
XObject *BodyArray (item) Object item;
X {
X 	return item.u.Array;
X }
X
Xstatic Object ArrayStore (n) int n;
X {
X 	Object *body = (Object *) Malloc ((unsigned) sizeof (Object) * n);
X 	int i, h = Height (OpStack);
X 	
X 	for (i = h - n; i < h; i++)
X 		body[i-h+n] = OpStack->stack_body[i];
X 	OpStack->stack_fill -= n;
X 	return Make (body, n);
X }
X
X/*VARARGS
XObject ArrayFrom (length, args) int length; Object args;
X {
X 	Object *argv = &args, *array = (Object *) Malloc ((unsigned) (sizeof (Object) * length));
X 	int i;
X 	
X 	for (i = 0; i < length; i++)
X 		array[i] = argv[i];
X 	return Cvx (Make (array, length));
X }
X*/
X
XlengthArray (item) Object item;
X {
X 	return item.Length;
X }
X
Xstatic int Length (object) Object object;
X {
X 	return object.Length;
X }
X
X#define lengthArray(a) ((a).Length)
X
Xstatic int PLength (object) Object object;
X {
X 	return Push (OpStack, MakeInteger (Length (object)));
X }
X
Xint ExecArray (item) Object item;
X {
X 	int l = lengthArray (item);
X 	
X	if (l == 0)
X 		return TRUE;
X 	Push (ExecStack, SameFlags (item, Make (Body (item) + 1, l - 1)));
X 	if (TypeOf (Body (item) [0]) == Name || TypeOf (Body (item) [0]) == Operator)
X 		Push (ExecStack, Body (item) [0]);
X 	else
X  		Push (OpStack, Body (item) [0]);
X		
X 	return TRUE;
X }
X
Xstatic int Get (object, key) Object object, key;
X {
X 	int index;
X 	
X	if (TypeOf (key) == Integer)
X		index = BodyInteger (key);
X	else if (TypeOf (key) == Real)
X		index = (int) BodyReal (key);
X	else
X	 	return Error (PTypeCheck);
X	if (index >= 0 && index < Length (object))
X	 {
X	 	Object t;
X	 	
X	 	t = Body (object) [index]; /* VAX Compiler Broken */
X		return Push (OpStack, t);
X	 }
X	else
X	 	return Error (PRangeCheck);
X  }
X
XObject getArray (o, index) Object o; int index;
X {
X 	return Body (o)[index];
X }
X
Xstatic int GetInterval (object, begin, length) Object object, begin, length;
X {
X	int b = BodyInteger (begin), l = BodyInteger (length);
X	
X	if (l < 0 || b < 0 || b + l > Length (object))
X		return Error (PRangeCheck);
X	return Push (OpStack, Make (Body (object) + b, l));
X }
X
XObject getIArray (object, begin, length) Object object; int begin, length;
X {
X	return Make (Body (object) + begin, length);
X }
X
Xstatic int Put (object, key, value) Object object, key, value;
X {
X	int index = BodyInteger (key);
X	
X	if (index < 0 || index >= Length (object))
X		return Error (PRangeCheck);
X 	Body (object) [index] = value;
X	return TRUE;
X }
X 
Xint putArray (object, index, value) Object object, value; int index;
X {
X	if (index < 0 || index >= Length (object))
X		return Error (PRangeCheck);
X 	Body (object) [index] = value;
X 	return TRUE;
X
X }
X 
Xstatic int PutInterval (object1, begin, object2) Object object1, begin, object2;
X {
X 	int i, l1 = Length (object1), l2 = Length (object2), b = BodyInteger (begin);
X 	
X	if (b < 0 || l2 + b > l1)
X		return Error (PRangeCheck);
X 	for (i = b; i < b + l2; i++)
X 		Body (object1) [i] = Body (object2) [i - b];
X	return TRUE;
X }
X
Xstatic int Copy (object1, object2) Object object1, object2;
X {
X	if (Length (object1) <= Length (object2))
X		return PutInterval (object2, MakeInteger (0), object1)
X			&& Push (OpStack, Make (Body (object2), Length (object1)));
X	else
X		return Error (PRangeCheck);
X }
X
Xstatic Eq (a, b) Object a, b;
X {
X	return Push (OpStack, MakeBoolean (Length (a) == Length (b) && (Length (a) == 0 || Body (a) == Body (b))));
X }
X
Xstatic int ForAll (array, proc) Object array, proc;
X {
X 	return Push (ExecStack, array)
X 	&& Push (ExecStack, MakeInteger (0))
X 	&& Push (ExecStack, proc)
X	&& Push (ExecStack, OpForAll);
X }
X
Xstatic forAll ()
X {
X 	Object array, index, proc;
X 	
X 	proc  = Pop (ExecStack);
X 	index = Pop (ExecStack);
X 	array = Pop (ExecStack);
X 	
X 	if (BodyInteger (index) >= lengthArray (array))
X 		return TRUE;
X 	return Push (ExecStack, array)
X 	&& Push (ExecStack, MakeInteger (BodyInteger (index) + 1))
X 	&& Push (ExecStack, proc)
X 	&& Push (ExecStack, OpForAll)
X 	&& Push (ExecStack, proc)
X 	&& Push (OpStack, Body (array) [BodyInteger (index)]);
X }
X
Xstatic int PSetAutoBind (bool) Object bool;
X {
X 	autobind = BodyBoolean (bool);
X 	
X 	return TRUE;
X }
X
Xstatic int PGetAutoBind ()
X {
X 	return Push (OpStack, MakeBoolean (autobind));
X }
X
XObject ParseArray (o) Object o;
X {
X 	Object res, *array;
X  	int i, length = 0;
X	struct acc
X 	 {
X 	 	Object item;
X 	 	struct acc *prev;
X 	 } *p = NULL;
X 	
X	for (;;)
X	 {
X	 	struct acc *item = (struct acc *) Malloc (sizeof (struct acc));
X	 	res = Parse (o);
X	 	
X	 	if (TypeOf (res) == Condition)
X	 		return Absent;
X 		if (TypeOf (res) == Boolean)
X 			if (BodyBoolean (res))
X 				break;
X 			else
X 				return Absent;
X 		else if (TypeOf (res) == Null)
X 			return res;
X 		
X 		if (autobind && TypeOf (res) == Name && xCheck (res))
X 		 {
X 			Object binding;
X 			
X 			binding = Load (res);
X 			
X 			if (TypeOf (binding) == Operator)
X 				res = binding;
X 		 }
X	 	item->item = res;
X	 	item->prev = p;
X	 	p = item;
X	 	++length;
X 	 }
X	array = (Object *) Malloc ((unsigned) sizeof (Object) * length);
X	
X	for (i = length - 1; i >= 0; i--)
X	 {
X	 	struct acc *prev = p->prev;
X	 	
X	 	array[i] = p->item;
X	 	Free ((char *)p);
X	 	p = prev;
X	 }
X	PanicIf (p != NULL, "Something badly wrong in Array literal parser\n");
X	return Make (array, length);
X }
X
Xstatic int PArray (size) Object size;
X {
X	if (BodyInteger (size) < 0)
X		return Error (PRangeCheck);
X	else
X	 {
X	 	int i, s = BodyInteger (size);
X	 	Object *body = (Object *) Malloc ((unsigned) sizeof (Object) * s);
X	 	
X	 	for (i = 0; i < s; i++)
X	 		body[i] = Nil;
X	 	return Push (OpStack, Make (body, s));
X	 }
X }
X
Xstatic int PRBracket ()	/* [ a1 ... an --- array */
X {
X 	int n = CountTo (Mark, OpStack);
X 	
X 	if (n < 0)
X 		return Error (PUnMatched);
X 	else
X 	 {
X 	 	Object res;
X 	 	
X 		res = ArrayStore (n);
X 		VOID Pop (OpStack);
X 		return Push (OpStack, res);
X 	 }
X }
X
Xstatic int PAload (array) Object array;
X {
X 	Object *body = Body (array);
X	int i, l = lengthArray (array);
X	
X	if (MaxStack (OpStack) - Height (OpStack) < l + 1)
X		return Error (POpOverflow);
X	else
X	 {
X		for (i = 0; i < l; i++)
X			if (!Push (OpStack, body[i]))
X				break;
X		return Push (OpStack, array);
X	 }
X }
X
Xstatic int PAstore (array) Object array;
X {
X	if (lengthArray (array) > Height (OpStack))
X 		return Error (POpUnderflow);
X 	else
X 	 {
X 	 	Object *body = Body (array);
X 	 	int i, l = lengthArray (array);
X 	 	
X 	 	for (i = l-1; i >= 0; i--)
X 	 		body[i] = Pop (OpStack);
X 	 	return Push (OpStack, array);
X 	 }
X }
X
Xstatic int PExecOnly (item) Object item;
X {
X 	return Push (OpStack, ExecOnly (item));
X }
X
Xstatic int PReadOnly (item) Object item;
X {
X 	return Push (OpStack, ReadOnly (item));
X }
X
Xstatic int PrCheck (v) Object v;
X {
X 	return Push (OpStack, MakeBoolean (rCheck (v)));
X }
X
Xstatic int PwCheck (v) Object v;
X {
X 	return Push (OpStack, MakeBoolean (wCheck (v)));
X }
END_OF_FILE
if test 9489 -ne `wc -c <'source/array.c'`; then
    echo shar: \"'source/array.c'\" unpacked with wrong size!
fi
# end of 'source/array.c'
fi
if test -f 'source/viewer.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/viewer.c'\"
else
echo shar: Extracting \"'source/viewer.c'\" \(10083 characters\)
sed "s/^X//" >'source/viewer.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include <stdio.h>
X#include <signal.h>
X
X#include "main.h"
X#include "graphics.h"
X#include "protocol.h"
X
X#define CHUNK 500
X
Xstruct hardware **hards, *get_hard ();
Xchar *malloc (), *realloc ();
Xvoid set_hard ();
X
Xint nhard = 0;
X
XColour Black, White;
X
Xint monitor;
X
Xmain (argc, argv) int argc; char **argv;
X {
X 	int c;
X 	struct hardware *res;
X 	DevicePoint ex;
X 	
X 	signal (SIGINT, SIG_IGN);
X 	
X 	monitor = !strcmp (argv[0], "monitor");
X 	
X 	if (monitor)
X 		fprintf (stderr, "Monitoring\n");
X 	slave_protocol ();
X  	Black = NewColour (0.0, 0.0, 0.0);
X  	White = NewColour (0.0, 0.0, 1.0);
X	
X 	hards = (struct hardware **) malloc (sizeof (struct hardware *) * CHUNK);
X 	nhard = CHUNK;
X 
X 	(void) set_hard (1, res = InitHardware ());
X 	ex = HardwareExtent (res);
X 	send_short (ex.dx);
X 	send_short (ex.dy);
X 	flush_protocol ();
X 	
X	while ((c = recv_byte ()) != 255)
X	 {
X	 	if (monitor)
X	 		fprintf (stderr, "command = %d\n", c);
X		switch (c)
X		 {
X		 	case NEW_WINDOW: 	DoNewWindow (); 	break;
X		 	case NEW_BITMAP: 	DoNewBitmap (); 	break;
X		 	case BITBLT:		DoBitBlt (); 		break;
X		 	case PAINT:		DoPaint (); 		break;
X		 	case SEND_BITMAP:	DoSendBitmap (); 	break;
X		 	case GET_BITMAP:	DoGetBitmap (); 	break;
X		 	case DESTROY_HARDWARE:	DoDestroyHardware (); 	break;
X		 	case GET_MATRIX:	DoGetMatrix (); 	break;
X		 	case LINE:		DoLine (); 		break;
X		 	case PAINT_LINE:	DoPaintLine (); 	break;
X		 	case GET_TRANSFERSIZE:	DoGetTransferSize (); 	break;
X		 	case SET_TRANSFER:	DoSetTransfer (); 	break;
X			case HARD_FLUSH:	HardUpdate ();		break;
X			case SCREEN_SIZE:	DoScreenSize ();	break;
X			case BUILD_SCREEN:	DoBuildScreen ();	break;
X			case SET_SCREEN:	DoSetScreen ();		break;
X			case SET_CLIP_HARDWARE:	DoSetClipHardware ();	break;
X		 	case BITBLT_TRAPEZOID:	DoBitBltTrapezoid ();	break;
X		 	case PAINT_TRAPEZOID:	DoPaintTrapezoid ();	break;
X		 	case SET_UPDATE_CONTROL:DoSetUpdateControl ();	break;
X		 	
X		 	default:
X		 		fprintf (stderr, "Unknown request type %d\n", c);
X		 		exit (1);
X		 }
X	 }
X }
X
XDoNewWindow ()
X {
X 	int h = recv_hardware ();
X 	int width = recv_short ();
X 	int height = recv_short ();
X 	
X 	if (monitor)
X 		fprintf (stderr, "%d = NewWindowHardware (%d, %d)\n", h, width, height);
X	set_hard (h, NewWindowHardware (width, height));
X }
X
XDoNewBitmap ()
X {
X 	int h = recv_hardware ();
X 	int width = recv_short ();
X 	int height = recv_short ();
X 	
X 	if (monitor)
X 		fprintf (stderr, "%d = NewBitmapHardware (%d, %d)\n", h, width, height);
X 	set_hard (h, NewBitmapHardware (width, height));
X }
X
XDoBitBlt ()
X {
X 	int rop, f, t;
X 	DevicePoint fromPoint, toPoint, extent;
X 	struct hardware *from = get_hard (f = recv_hardware ());
X 	struct hardware *to = get_hard (t = recv_hardware ());
X	
X	fromPoint = recv_point ();
X	toPoint = recv_point ();
X	extent = recv_point ();
X	rop = recv_byte ();
X	
X 	if (monitor)
X 		fprintf (stderr, "BitBlt (%d, %d, (%d, %d), (%d, %d), (%d, %d), %d)\n",
X 		f, t,
X 		fromPoint.dx, fromPoint.dy, toPoint.dx, toPoint.dy,
X 		extent.dx, extent.dy,
X 		rop);
X	BitBlt (from, to, fromPoint, toPoint, extent, rop);
X }
X
XDoPaint ()
X {
X 	int f, t;
X 	Colour colour;
X 	DevicePoint fromPoint, toPoint, extent;
X 	struct hardware *from = get_hard (f = recv_hardware ());
X 	struct hardware *to = get_hard (t = recv_hardware ());
X	
X	fromPoint = recv_point ();
X	toPoint = recv_point ();
X	extent = recv_point ();
X	colour = recv_colour ();
X	
X 	if (monitor)
X 		fprintf (stderr, "Paint (%d, %d, (%d, %d), (%d, %d), (%d, %d), [%g, %g, %g])\n",
X 		f, t,
X 		fromPoint.dx, fromPoint.dy, toPoint.dx, toPoint.dy,
X 		extent.dx, extent.dy,
X 		colour.hue, colour.saturation, colour.brightness);
X	Paint (from, to, fromPoint, toPoint, extent, colour);
X }
X
Xint size (width, height) int width, height;
X {
X 	return (width + 7) / 8 * height;
X }
X
XDoSendBitmap ()		/* actually receives this end */
X {
X 	int h = recv_hardware ();
X 	int width = recv_short ();
X 	int height = recv_short ();
X	int len = size (width, height);
X 	char *s;
X 	
X 	recv_string ((s = malloc (len)), len);
X 	if (monitor)
X 		fprintf (stderr, "%d = HardwareFromString (<string>, %d, %d)\n", h, width, height);
X 	set_hard (h, HardwareFromString (s, width, height));
X 	free (s);
X }
X
XDoGetBitmap ()
X {
X 	struct hardware *h = get_hard (recv_hardware ());
X 	char *s = StringFromHardware (h);
X 	DevicePoint ex;
X 	
X 	ex = HardwareExtent (h);
X 	
X 	if (monitor)
X 		fprintf (stderr, "StringFromHardware (%d)\n", h);
X 	send_string (s, size (ex.dx, ex.dy));
X 	flush_protocol ();
X 	free (s);
X }
X
XDoDestroyHardware ()
X {
X 	int n = recv_hardware ();
X 	
X 	if (monitor)
X 		fprintf (stderr, "DestroyHardware (%d)\n", n);
X 	DestroyHardware (get_hard (n));
X 	set_hard (n, NULL);
X }
X
XDoGetMatrix ()
X {
X	int width = recv_short ();
X	int height = recv_short ();
X	Matrix m;
X	
X 	if (monitor)
X 		fprintf (stderr, "DeviceMatrix (%d, %d)\n", width, height);
X	m = DeviceMatrix (width, height);
X	send_float (m.A);
X	send_float (m.B);
X	send_float (m.C);
X	send_float (m.D);
X	send_float (m.tx);
X	send_float (m.ty);
X	flush_protocol ();
X }
X
XDoLine ()
X {
X 	DevicePoint fromPoint, toPoint;
X 	int rop;
X 	struct hardware *h = get_hard (recv_hardware ());
X 	
X	fromPoint = recv_point ();
X	toPoint = recv_point ();
X	rop = recv_byte ();
X	
X 	if (monitor)
X 		fprintf (stderr, "BitBltLine ((%d, %d), (%d, %d), %d)\n",
X 		fromPoint.dx, fromPoint.dy, toPoint.dx, toPoint.dy,
X 		rop);
X	BitBltLine (h, fromPoint, toPoint, rop);
X }
X
XDoPaintLine ()
X {
X 	DevicePoint fromPoint, toPoint;
X 	Colour colour;
X 	struct hardware *h = get_hard (recv_hardware ());
X 	
X	fromPoint = recv_point ();
X	toPoint = recv_point ();
X	colour = recv_colour ();
X	
X 	if (monitor)
X 		fprintf (stderr, "PaintLine ((%d, %d), (%d, %d), [%g, %g, %g])\n",
X 		fromPoint.dx, fromPoint.dy, toPoint.dx, toPoint.dy,
X 		colour.hue, colour.saturation, colour.brightness);
X	PaintLine (h, fromPoint, toPoint, colour);
X }
X
Xint recv_hardware ()
X {
X 	return recv_short ();
X }
X
Xstruct hardware *get_hard (h) int h;
X {
X 	if (nhard <= h)
X 	 {
X 		fprintf (stderr, "%d is not a valid device\n", h);
X 		return NULL;
X 	 }
X 	return hards [h];
X }
X
Xvoid set_hard (n, h) int n; struct hardware *h;
X {
X 	if (nhard <= n)
X		hards = (struct hardware **) realloc ((char *) hards, sizeof (struct hardware *) * (nhard += CHUNK));
X 	hards [n] = h;
X }
X
Xint Max (a, b) int a, b;
X {
X 	return a > b ? a : b;
X }
X
Xint Min (a, b) int a, b;
X {
X 	return a < b ? a : b;
X }
X
XMatrix NewMatrix (a, b, c, d, e, f) float a, b, c, d, e, f;
X {
X 	Matrix res;
X 	
X 	res.A = a; res.B = b; res.C = c; res.D = d; res.tx = e; res.ty = f;
X 	
X 	return res;
X }
X
Xchar *Malloc (i) unsigned i;
X {
X 	return malloc (i);
X }
X
XFree (s) char *s;
X {
X 	free (s);
X }
X
Xunsigned char *Bcopy (to, from, count) unsigned char *from, *to; int count;
X {
X 	unsigned char *res = to;
X 	
X 	while (count --)
X 		*to++ = *from++;
X 	
X 	return res;
X }
X
XPanicIf (flag, s) int flag; char *s;
X {
X 	if (flag)
X 		fprintf (stderr, "Viewer panic: %s\n", s),
X 		exit (1);
X }
X
XDevicePoint NewDevicePoint (x, y) int x, y;
X {
X 	DevicePoint res;
X 	
X 	res.dx = x; res.dy = y;
X 	
X 	return res;
X }
X
XColour NewColour (h, s, b) float h, s, b;
X {
X 	Colour res;
X 	
X 	res.hue = h;
X 	res.saturation = s;
X 	res.brightness = b;
X 	
X 	return res;
X }
X
XDoGetTransferSize ()
X {
X 	send_short (TransferSize ());
X 	flush_protocol ();
X }
X
XDoSetTransfer ()
X {
X 	int i, size = TransferSize ();
X 	float *val = (float *) malloc (sizeof (float) * size);
X 	
X 	for (i = 0; i < size; i++)
X 		val [i] = recv_small ();
X 	
X 	SetTransfer (val);
X 	Free ((char *) val);
X }
X
XDoScreenSize ()
X {
X 	float freq = recv_float (), rotation = recv_float ();
X 	
X 	send_short (ScreenSize (freq, rotation));
X 	flush_protocol ();
X }
X
XDoBuildScreen ()
X {
X 	float freq = recv_float (), rotation = recv_float ();
X 	int i, size = ScreenSize (freq, rotation);
X 	float *x, *y;
X 	
X 	send_short (size);
X 	x = (float *) malloc (sizeof (float) * size);
X 	y = (float *) malloc (sizeof (float) * size);
X 	
X 	BuildScreen (freq, rotation, x, y);
X 	for (i = 0; i < size; i++)
X 	 	send_small (x[i]),
X 	 	send_small (y[i]);
X 	flush_protocol ();
X 	free ((char *) x);
X 	free ((char *) y);
X }
X
XDoSetScreen ()
X {
X 	float freq = recv_float (), rotation = recv_float ();
X  	int i, size = ScreenSize (freq, rotation);
X	float *th = (float *) malloc (sizeof (float) * size);
X	
X	for (i = 0; i < size; i++)
X		th[i] = recv_small ();
X	SetScreen (freq, rotation, th);
X	free ((char *) th);
X }
X
XDoSetClipHardware ()
X {
X 	struct hardware *h = get_hard (recv_hardware ());
X 	
X 	if (monitor)
X 		fprintf (stderr, "SetClipHardware ()\n");
X	SetClipHardware (h, get_hard (recv_hardware ()));
X }
X
XDoBitBltTrapezoid ()
X {
X 	DevicePoint lefttop, leftbottom, righttop, rightbottom;
X 	int top, bottom, rop;
X 	struct hardware *h = get_hard (recv_hardware ());
X 	
X 	lefttop = recv_point ();
X 	leftbottom = recv_point ();
X 	righttop = recv_point ();
X 	rightbottom = recv_point ();
X 	top = recv_short ();
X 	bottom = recv_short ();
X 	rop = recv_byte ();
X 	
X 	if (monitor)
X 		fprintf (stderr, "BitBltTrapezoid ()\n");
X 	BitBltTrapezoid (h, lefttop, leftbottom, righttop, rightbottom, rop);
X }
X
XDoPaintTrapezoid ()
X {
X 	DevicePoint lefttop, leftbottom, righttop, rightbottom;
X 	int top, bottom;
X 	Colour colour;
X 	struct hardware *h = get_hard (recv_hardware ());
X 	
X 	lefttop = recv_point ();
X 	leftbottom = recv_point ();
X 	righttop = recv_point ();
X 	rightbottom = recv_point ();
X 	top = recv_short ();
X 	bottom = recv_short ();
X 	colour = recv_colour ();
X 	
X  	if (monitor)
X 		fprintf (stderr, "PaintTrapezoid ()\n");
X	PaintTrapezoid (h, lefttop, leftbottom, righttop, rightbottom, top, bottom, colour);
X }
X
XDoSetUpdateControl ()
X {
X 	struct hardware *h = get_hard (recv_hardware ());
X 	UpdateControl (h, recv_byte ());
X }
END_OF_FILE
if test 10083 -ne `wc -c <'source/viewer.c'`; then
    echo shar: \"'source/viewer.c'\" unpacked with wrong size!
fi
# end of 'source/viewer.c'
fi
echo shar: End of archive 7 \(of 18\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
