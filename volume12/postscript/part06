Subject:  v12i055:  A PostScript interpreter, Part06/18
Newsgroups: comp.sources.unix
Sender: sources
Approved: rs@uunet.UU.NET

Submitted-by: Crispin Goswell <caag@vd.rl.ac.uk>
Posting-number: Volume 12, Issue 55
Archive-name: postscript/part06

[  Sorry for the delays; when the net was free, I was  busy.  --r$  ]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 18)."
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'postscript/fonts/Times/greek.r' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'postscript/fonts/Times/greek.r'\"
else
echo shar: Extracting \"'postscript/fonts/Times/greek.r'\" \(8441 characters\)
sed "s/^X//" >'postscript/fonts/Times/greek.r' <<'END_OF_FILE'
XCharStrings
X/2027
X<CA34
X4349
XCA34
X5149
XCA37
X5049
XC543
X4E43
XC149
X4749
XCD49
X5349
X>
Xput
XMetrics
X/2027
X[2
X20]
Xput
XCharStrings
X/2028
X<C534
X4549
XC634
X4649
XC234
X4E34
X5135
X5236
X5338
X533A
X523C
X513D
X4E3E
XCE34
X5035
X5136
X5238
X523A
X513C
X503D
X4E3E
XC63E
X4E3E
X513F
X5240
X5342
X5345
X5247
X5148
X4E49
X4249
XCE3E
X503F
X5140
X5242
X5245
X5147
X5048
X4E49
X>
Xput
XMetrics
X/2028
X[1
X22]
Xput
XCharStrings
X/2029
X<C534
X4549
XC634
X4649
XC234
X5134
X513A
X5034
XC249
X4949
X>
Xput
XMetrics
X/2029
X[3
X18]
Xput
XCharStrings
X/2030
X<CA34
X4249
XCA34
X5249
XCA37
X5149
XC348
X5148
XC249
X5249
X>
Xput
XMetrics
X/2030
X[2
X20]
Xput
XCharStrings
X/2031
X<C534
X4549
XC634
X4649
XCC3A
X4C42
XC234
X5234
X523A
X5134
XC63E
X4C3E
XC249
X5249
X5243
X5149
X>
Xput
XMetrics
X/2031
X[1
X21]
Xput
XCharStrings
X/2032
X<D034
X4349
XD134
X4449
XC434
X433A
X4334
X5134
XC349
X5149
X5143
X5049
X>
Xput
XMetrics
X/2032
X[2
X20]
Xput
XCharStrings
X/2033
X<C534
X4549
XC634
X4649
XD234
X5249
XD334
X5349
XC234
X4934
XCF34
X5634
XC63E
X523E
XC249
X4949
XCF49
X5649
X>
Xput
XMetrics
X/2033
X[0
X24]
Xput
XCharStrings
X/2034
X<CA34
X4735
X4537
X4439
X433D
X4340
X4444
X4546
X4748
X4A49
X4C49
X4F48
X5146
X5244
X5340
X533D
X5239
X5137
X4F35
X4C34
X4A34
XCA34
X4835
X4637
X4539
X443D
X4440
X4544
X4646
X4848
X4A49
XCC49
X4E48
X5046
X5144
X5240
X523D
X5139
X5037
X4E35
X4C34
XC83B
X4842
XCE3B
X4E42
XC83E
X4E3E
XC83F
X4E3F
X>
Xput
XMetrics
X/2034
X[1
X22]
Xput
XCharStrings
X/2035
X<C534
X4549
XC634
X4649
XC234
X4934
XC249
X4949
X>
Xput
XMetrics
X/2035
X[7
X11]
Xput
XCharStrings
X/2036
X<C534
X4549
XC634
X4649
XD334
X4641
XCB3D
X5349
XCA3D
X5249
XC234
X4934
XCF34
X5534
XC249
X4949
XCF49
X5549
X>
Xput
XMetrics
X/2036
X[0
X22]
Xput
XCharStrings
X/2037
X<CA34
X4349
XCA34
X5149
XCA37
X5049
XC149
X4749
XCD49
X5349
X>
Xput
XMetrics
X/2037
X[2
X20]
Xput
XCharStrings
X/2038
X<C534
X4549
XC634
X4C46
XC534
X4C49
XD334
X4C49
XD334
X5349
XD434
X5449
XC234
X4634
XD334
X5734
XC249
X4849
XD049
X5749
X>
Xput
XMetrics
X/2038
X[0
X25]
Xput
XCharStrings
X/2039
X<C534
X4549
XC634
X5247
XC636
X5249
XD234
X5249
XC234
X4634
XCF34
X5534
XC249
X4849
X>
Xput
XMetrics
X/2039
X[1
X23]
Xput
XCharStrings
X/2040
X<C433
X4338
XD333
X5238
XC83C
X4741
XCF3C
X4E41
XC445
X434A
XD345
X524A
XC435
X5235
XC436
X5236
XC83E
X4E3E
XC83F
X4E3F
XC447
X5247
XC448
X5248
X>
Xput
XMetrics
X/2040
X[2
X22]
Xput
XCharStrings
X/2041
X<CA34
X4735
X4537
X4439
X433D
X4340
X4444
X4546
X4748
X4A49
X4C49
X4F48
X5146
X5244
X5340
X533D
X5239
X5137
X4F35
X4C34
X4A34
XCA34
X4835
X4637
X4539
X443D
X4440
X4544
X4646
X4848
X4A49
XCC49
X4E48
X5046
X5144
X5240
X523D
X5139
X5037
X4E35
X4C34
X>
Xput
XMetrics
X/2041
X[1
X22]
Xput
XCharStrings
X/2042
X<C534
X4549
XC634
X4649
XD234
X5249
XD334
X5349
XC234
X5634
XC249
X4949
XCF49
X5649
X>
Xput
XMetrics
X/2042
X[0
X24]
Xput
XCharStrings
X/2043
X<C534
X4549
XC634
X4649
XC234
X4E34
X5135
X5236
X5338
X533B
X523D
X513E
X4E3F
X463F
XCE34
X5035
X5136
X5238
X523B
X513D
X503E
X4E3F
XC249
X4949
X>
Xput
XMetrics
X/2043
X[1
X22]
Xput
XCharStrings
X/2044
X<C334
X4A3E
X4249
XC234
X493E
XC234
X5134
X523A
X5034
XC348
X5048
XC249
X5149
X5243
X5049
X>
Xput
XMetrics
X/2044
X[2
X21]
Xput
XCharStrings
X/2045
X<C934
X4949
XCA34
X4A49
XC334
X423A
X4234
X5134
X513A
X5034
XC649
X4D49
X>
Xput
XMetrics
X/2045
X[3
X19]
Xput
XCharStrings
X/2046
X<C239
X4237
X4335
X4434
X4634
X4735
X4837
X493B
X4949
XC237
X4435
X4635
X4837
XD139
X5137
X5035
X4F34
X4D34
X4C35
X4B37
X4A3B
X4A49
XD137
X4F35
X4D35
X4B37
XC649
X4D49
X>
Xput
XMetrics
X/2046
X[3
X19]
Xput
XCharStrings
X/2047
X<CA34
X4A49
XCB34
X4B49
XC839
X453A
X443B
X433D
X4340
X4442
X4543
X4844
X4D44
X5043
X5142
X5240
X523D
X513B
X503A
X4D39
X4839
XC839
X463A
X453B
X443D
X4440
X4542
X4643
X4844
XCD44
X4F43
X5042
X5140
X513D
X503B
X4F3A
X4D39
XC734
X4E34
XC749
X4E49
X>
Xput
XMetrics
X/2047
X[2
X21]
Xput
XCharStrings
X/2048
X<C334
X5049
XC434
X5149
XD134
X4349
XC134
X4734
XCD34
X5334
XC149
X4749
XCD49
X5349
X>
Xput
XMetrics
X/2048
X[2
X20]
Xput
XCharStrings
X/2049
X<CB34
X4B49
XCC34
X4C49
XC23B
X433A
X453B
X463F
X4741
X4842
X4A43
XC33A
X443B
X453F
X4641
X4742
X4A43
X4D43
X5042
X5141
X523F
X533B
X543A
XCD43
X4F42
X5041
X513F
X523B
X543A
X553B
XC834
X4F34
XC849
X4F49
X>
Xput
XMetrics
X/2049
X[1
X23]
Xput
XCharStrings
X/2050
X<C346
X4449
X4849
X4645
X4441
X433E
X433A
X4437
X4635
X4934
X4D34
X5035
X5237
X533A
X533E
X5241
X5045
X4E49
X5249
X5346
XC645
X4542
X443E
X443A
X4537
X4735
X4934
XCD34
X4F35
X5137
X523A
X523E
X5142
X5045
XC448
X4748
XCF48
X5248
X>
Xput
XMetrics
X/2050
X[1
X22]
Xput
XCharStrings
X/2127
X<CA3B
X473C
X453E
X4440
X4343
X4346
X4448
X4749
X4949
X4B48
X4E45
X5042
X523E
X533B
XCA3B
X483C
X463E
X4540
X4443
X4446
X4548
X4749
XCA3B
X4C3B
X4E3C
X4F3E
X5146
X5248
X5349
XCC3B
X4D3C
X4E3E
X5046
X5148
X5349
X5449
X>
Xput
XMetrics
X/2127
X[-3
X23]
Xput
XCharStrings
X/2128
X<CD34
X4A35
X4837
X463B
X453E
X4442
X4348
X4250
XCD34
X4B35
X4937
X473B
X463E
X4542
X4448
X4350
XCD34
X4F34
X5135
X5236
X5239
X513B
X503C
X4D3D
X493D
XCF34
X5136
X5139
X503B
X4F3C
X4D3D
XC93D
X4D3E
X4F40
X5042
X5045
X4F47
X4E48
X4B49
X4949
X4748
X4647
X4544
XC93D
X4C3E
X4E40
X4F42
X4F45
X4E47
X4D48
X4B49
X>
Xput
XMetrics
X/2128
X[1
X21]
Xput
XCharStrings
X/2129
X<C13E
X433C
X453B
X473B
X493C
X4A3D
X4B40
X4B44
X4A48
X4750
XC23D
X443C
X483C
X4A3D
XD23B
X513E
X5040
X4B47
X484C
X4650
XD13B
X503E
X4F40
X4B47
X>
Xput
XMetrics
X/2129
X[-1
X20]
Xput
XCharStrings
X/2130
X<CD3C
X4B3B
X493B
X463C
X443F
X4342
X4345
X4447
X4548
X4749
X4949
X4C48
X4E45
X4F42
X4F3F
X4E3D
X4A38
X4936
X4934
X4A33
X4C33
X4E34
X5036
XC93B
X473C
X453F
X4442
X4446
X4548
XC949
X4B48
X4D45
X4E42
X4E3E
X4D3C
X4B39
X4A37
X4A35
X4B34
X4D34
X5036
X>
Xput
XMetrics
X/2130
X[4
X19]
Xput
XCharStrings
X/2131
X<CF3E
X4D3C
X4B3B
X473B
X453C
X453E
X4740
X4A41
XC73B
X463C
X463E
X4840
X4A41
XCA41
X4542
X4344
X4346
X4448
X4749
X4A49
X4C48
X4E46
XCA41
X4642
X4444
X4446
X4548
X4749
X>
Xput
XMetrics
X/2131
X[-3
X18]
Xput
XCharStrings
X/2132
X<CB34
X4935
X4836
X4837
X4938
X4C39
X5139
X5138
X4E39
X4A3B
X473D
X4440
X4343
X4345
X4447
X4749
X4A4B
X4B4D
X4B4F
X4A50
X4850
X474F
XCC3A
X483D
X4540
X4443
X4445
X4547
X4749
X>
Xput
XMetrics
X/2132
X[3
X18]
Xput
XCharStrings
X/2133
X<C13F
X423D
X443B
X473B
X483C
X483E
X4742
X4549
XC63B
X473C
X473E
X4642
X4449
XC742
X493E
X4B3C
X4D3B
X4F3B
X513C
X523D
X5240
X5145
X4E50
XCF3B
X513D
X5140
X5045
X4D50
X>
Xput
XMetrics
X/2133
X[-1
X22]
Xput
XCharStrings
X/2134
X<C13F
X423D
X443B
X473B
X483C
X483E
X4743
X4746
X4848
X4949
XC63B
X473C
X473E
X4643
X4646
X4748
X4949
X4B49
X4D48
X4F46
X5143
X5240
X533B
X5337
X5235
X5034
X4E34
X4C36
X4C38
X4D3B
X4F3E
X5140
X5442
XCD48
X4F45
X5043
X5140
X523B
X5237
X5135
X5034
X>
Xput
XMetrics
X/2134
X[0
X23]
Xput
XCharStrings
X/2135
X<C63B
X4442
X4346
X4348
X4449
X4749
X4947
X4A45
XC73B
X4542
X4446
X4448
X4549
X>
Xput
XMetrics
X/2135
X[-1
X12]
Xput
XCharStrings
X/2136
X<C63B
X4249
XC73B
X4349
XD03B
X513C
X523C
X513B
X4F3B
X4D3C
X4940
X4741
X4541
XC741
X4942
X4B48
X4C49
XC741
X4842
X4A48
X4B49
X4D49
X4F48
X5145
X>
Xput
XMetrics
X/2136
X[-2
X20]
Xput
XCharStrings
X/2137
X<C334
X4534
X4735
X4836
X4938
X4F46
X5048
X5149
XC534
X4736
X4838
X4E46
X4F48
X5149
X5249
XCA3B
X4249
XCA3B
X4349
X>
Xput
XMetrics
X/2137
X[2
X20]
Xput
XCharStrings
X/2138
X<C73B
X4150
XC83B
X4250
XC73E
X4644
X4647
X4849
X4A49
X4C48
X4E46
X5043
XD23B
X4F46
X4F48
X5049
X5349
X5547
X5645
XD33B
X5046
X5048
X5149
X>
Xput
XMetrics
X/2138
X[-1
X23]
Xput
XCharStrings
X/2139
X<C63B
X4449
XC73B
X4641
X4546
X4449
XD13B
X503F
X4E43
XD23B
X513E
X5040
X4E43
X4C45
X4947
X4748
X4449
XC33B
X473B
X>
Xput
XMetrics
X/2139
X[-3
X20]
Xput
XCharStrings
X/2140
X<CB34
X4935
X4836
X4837
X4938
X4C39
X4F39
XCC39
X483A
X463B
X453D
X453F
X4741
X4A42
X4D42
XCC39
X493A
X473B
X463D
X463F
X4841
X4A42
XCA42
X4643
X4444
X4346
X4348
X454A
X4A4C
X4B4D
X4B4F
X4950
X4750
XCA42
X4743
X4544
X4446
X4448
X464A
X4A4C
X>
Xput
XMetrics
X/2140
X[3
X17]
Xput
XCharStrings
X/2141
X<C93B
X463C
X443F
X4342
X4345
X4447
X4548
X4749
X4949
X4C48
X4E45
X4F42
X4F3F
X4E3D
X4D3C
X4B3B
X493B
XC93B
X473C
X453F
X4442
X4446
X4548
XC949
X4B48
X4D45
X4E42
X4E3E
X4D3C
X>
Xput
XMetrics
X/2141
X[-3
X18]
Xput
XCharStrings
X/2142
X<C93C
X4549
XC93C
X4649
XCF3C
X4F49
XCF3C
X5049
XC23E
X443C
X473B
X543B
XC23E
X443D
X473C
X543C
X>
Xput
XMetrics
X/2142
X[-2
X22]
Xput
XCharStrings
X/2143
X<C444
X4547
X4648
X4849
X4A49
X4D48
X4F45
X5042
X503F
X4F3D
X4E3C
X4C3B
X4A3B
X473C
X453F
X4442
X4050
XCA49
X4C48
X4E45
X4F42
X4F3E
X4E3C
XCA3B
X483C
X463F
X4542
X4150
X>
Xput
XMetrics
X/2143
X[0
X19]
Xput
XCharStrings
X/2144
X<D33B
X493B
X463C
X443F
X4342
X4345
X4447
X4548
X4749
X4949
X4C48
X4E45
X4F42
X4F3F
X4E3D
X4D3C
X4B3B
XC93B
X473C
X453F
X4442
X4446
X4548
XC949
X4B48
X4D45
X4E42
X4E3E
X4D3C
XCD3C
X533C
X>
Xput
XMetrics
X/2144
X[-3
X21]
Xput
XCharStrings
X/2145
X<CB3C
X4849
XCB3C
X4949
XC23E
X443C
X473B
X523B
XC23E
X443D
X473C
X523C
X>
Xput
XMetrics
X/2145
X[-2
X20]
Xput
XCharStrings
X/2146
X<C13F
X423D
X443B
X473B
X483C
X483E
X4644
X4647
X4849
XC63B
X473C
X473E
X4544
X4547
X4648
X4849
X4949
X4C48
X4E46
X5043
X5140
X513D
X503B
X4F3C
X503D
X5140
XD043
X513D
X>
Xput
XMetrics
X/2146
X[-1
X20]
Xput
XCharStrings
X/2147
X<C83C
X463D
X443F
X4342
X4345
X4447
X4548
X4749
X4A49
X4D48
X5046
X5243
X5340
X533D
X513B
X4F3B
X4D3D
X4B41
X4946
X4650
XC345
X4547
X4748
X4A48
X4D47
X5045
X5243
XD33D
X513C
X4F3C
X4D3E
X4B41
X4947
X4750
X>
Xput
XMetrics
X/2147
X[-3
X22]
Xput
XCharStrings
X/2148
X<C23B
X443B
X463C
X473E
X4C4D
X4D4F
X4E50
XC43B
X453C
X463E
X4B4D
X4C4F
X4E50
X5050
XD13B
X503D
X4E40
X444B
X424E
X4150
X>
Xput
XMetrics
X/2148
X[-1
X18]
Xput
XCharStrings
X/2149
X<CF34
X4950
XD034
X4850
XC13F
X423D
X443B
X473B
X483C
X483E
X4743
X4746
X4948
X4C48
X4E47
X5144
X5341
XC63B
X473C
X473E
X4643
X4646
X4748
X4949
X4C49
X4E48
X5046
X5243
X5341
X553B
X>
Xput
XMetrics
X/2149
X[0
X23]
Xput
XCharStrings
X/2150
X<C43F
X463D
X493C
X483B
X463C
X443F
X4342
X4345
X4448
X4549
X4749
X4948
X4B45
X4C42
XC345
X4447
X4548
X4748
X4947
X4B45
XCB42
X4B45
X4C48
X4D49
X4F49
X5148
X5345
X5442
X543F
X533C
X523B
X513C
X533D
X543F
XCB45
X4C47
X4D48
X4F48
X5147
X5345
X>
Xput
XMetrics
X/2150
X[-3
X23]
Xput
END_OF_FILE
if test 8441 -ne `wc -c <'postscript/fonts/Times/greek.r'`; then
    echo shar: \"'postscript/fonts/Times/greek.r'\" unpacked with wrong size!
fi
# end of 'postscript/fonts/Times/greek.r'
fi
if test -f 'postscript/fonts/Times/roman.r' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'postscript/fonts/Times/roman.r'\"
else
echo shar: Extracting \"'postscript/fonts/Times/roman.r'\" \(9406 characters\)
sed "s/^X//" >'postscript/fonts/Times/roman.r' <<'END_OF_FILE'
XCharStrings
X/a
X<C53D
X453E
X443E
X443D
X453C
X473B
X4B3B
X4D3C
X4E3D
X4F3F
X4F46
X5048
X5149
XCE3D
X4E46
X4F48
X5149
X5249
XCE3F
X4D40
X4741
X4442
X4344
X4346
X4448
X4749
X4A49
X4C48
X4E46
XC741
X4542
X4444
X4446
X4548
X4749
X>
Xput
XMetrics
X/a
X[-3
X20]
Xput
XCharStrings
X/b
X<C534
X4549
XC634
X4649
XC63E
X483C
X4A3B
X4C3B
X4F3C
X513E
X5241
X5243
X5146
X4F48
X4C49
X4A49
X4848
X4646
XCC3B
X4E3C
X503E
X5141
X5143
X5046
X4E48
X4C49
XC234
X4634
X>
Xput
XMetrics
X/b
X[1
X21]
Xput
XCharStrings
X/c
X<CF3E
X4E3F
X4F40
X503F
X503E
X4E3C
X4C3B
X493B
X463C
X443E
X4341
X4343
X4446
X4648
X4949
X4B49
X4E48
X5046
XC93B
X473C
X453E
X4441
X4443
X4546
X4748
X4949
X>
Xput
XMetrics
X/c
X[-3
X19]
Xput
XCharStrings
X/d
X<CF34
X4F49
XD034
X5049
XCF3E
X4D3C
X4B3B
X493B
X463C
X443E
X4341
X4343
X4446
X4648
X4949
X4B49
X4D48
X4F46
XC93B
X473C
X453E
X4441
X4443
X4546
X4748
X4949
XCC34
X5034
XCF49
X5349
X>
Xput
XMetrics
X/d
X[2
X21]
Xput
XCharStrings
X/e
X<C441
X5041
X503F
X4F3D
X4E3C
X4C3B
X493B
X463C
X443E
X4341
X4343
X4446
X4648
X4949
X4B49
X4E48
X5046
XCF41
X4F3E
X4E3C
XC93B
X473C
X453E
X4441
X4443
X4546
X4748
X4949
X>
Xput
XMetrics
X/e
X[-3
X19]
Xput
XCharStrings
X/f
X<CA35
X4936
X4A37
X4B36
X4B35
X4A34
X4834
X4635
X4537
X4549
XC834
X4735
X4637
X4649
XC23B
X4A3B
XC249
X4949
X>
Xput
XMetrics
X/f
X[5
X13]
Xput
XCharStrings
X/g
X<C83B
X463C
X453D
X443F
X4441
X4543
X4644
X4845
X4A45
X4C44
X4D43
X4E41
X4E3F
X4D3D
X4C3C
X4A3B
X483B
XC63C
X453E
X4542
X4644
XCC44
X4D42
X4D3E
X4C3C
XCD3D
X4E3C
X503B
X503C
X4E3C
XC543
X4444
X4346
X4347
X4449
X474A
X4C4A
X4F4B
X504C
XC347
X4448
X4749
X4C49
X4F4A
X504C
X504D
X4F4F
X4C50
X4650
X434F
X424D
X424C
X434A
X4649
X>
Xput
XMetrics
X/g
X[-2
X19]
Xput
XCharStrings
X/h
X<C534
X4549
XC634
X4649
XC63E
X483C
X4B3B
X4D3B
X503C
X513E
X5149
XCD3B
X4F3C
X503E
X5049
XC234
X4634
XC249
X4949
XCD49
X5449
X>
Xput
XMetrics
X/h
X[1
X22]
Xput
XCharStrings
X/i
X<C534
X4435
X4536
X4635
X4534
XC53B
X4549
XC63B
X4649
XC23B
X463B
XC249
X4949
X>
Xput
XMetrics
X/i
X[7
X11]
Xput
XCharStrings
X/j
X<C634
X4535
X4636
X4735
X4634
XC73B
X474D
X464F
X4450
X4250
X414F
X414E
X424D
X434E
X424F
XC63B
X464D
X454F
X4450
XC33B
X473B
X>
Xput
XMetrics
X/j
X[7
X11]
Xput
XCharStrings
X/k
X<C534
X4549
XC634
X4649
XD03B
X4645
XCB41
X5149
XCA41
X5049
XC234
X4634
XCD3B
X533B
XC249
X4949
XCD49
X5349
X>
Xput
XMetrics
X/k
X[1
X21]
Xput
XCharStrings
X/l
X<C534
X4549
XC634
X4649
XC234
X4634
XC249
X4949
X>
Xput
XMetrics
X/l
X[7
X11]
Xput
XCharStrings
X/m
X<C53B
X4549
XC63B
X4649
XC63E
X483C
X4B3B
X4D3B
X503C
X513E
X5149
XCD3B
X4F3C
X503E
X5049
XD13E
X533C
X563B
X583B
X5B3C
X5C3E
X5C49
XD83B
X5A3C
X5B3E
X5B49
XC23B
X463B
XC249
X4949
XCD49
X5449
XD849
X5F49
X>
Xput
XMetrics
X/m
X[-2
X33]
Xput
XCharStrings
X/n
X<C53B
X4549
XC63B
X4649
XC63E
X483C
X4B3B
X4D3B
X503C
X513E
X5149
XCD3B
X4F3C
X503E
X5049
XC23B
X463B
XC249
X4949
XCD49
X5449
X>
Xput
XMetrics
X/n
X[-2
X22]
Xput
XCharStrings
X/o
X<C93B
X463C
X443E
X4341
X4343
X4446
X4648
X4949
X4B49
X4E48
X5046
X5143
X5141
X503E
X4E3C
X4B3B
X493B
XC93B
X473C
X453E
X4441
X4443
X4546
X4748
X4949
XCB49
X4D48
X4F46
X5043
X5041
X4F3E
X4D3C
X4B3B
X>
Xput
XMetrics
X/o
X[-3
X20]
Xput
XCharStrings
X/p
X<C53B
X4550
XC63B
X4650
XC63E
X483C
X4A3B
X4C3B
X4F3C
X513E
X5241
X5243
X5146
X4F48
X4C49
X4A49
X4848
X4646
XCC3B
X4E3C
X503E
X5141
X5143
X5046
X4E48
X4C49
XC23B
X463B
XC250
X4950
X>
Xput
XMetrics
X/p
X[-2
X21]
Xput
XCharStrings
X/q
X<CF3B
X4F50
XD03B
X5050
XCF3E
X4D3C
X4B3B
X493B
X463C
X443E
X4341
X4343
X4446
X4648
X4949
X4B49
X4D48
X4F46
XC93B
X473C
X453E
X4441
X4443
X4546
X4748
X4949
XCC50
X5350
X>
Xput
XMetrics
X/q
X[-3
X20]
Xput
XCharStrings
X/r
X<C53B
X4549
XC63B
X4649
XC641
X473E
X493C
X4B3B
X4E3B
X4F3C
X4F3D
X4E3E
X4D3D
X4E3C
XC23B
X463B
XC249
X4949
X>
Xput
XMetrics
X/r
X[-2
X17]
Xput
XCharStrings
X/s
X<CD3D
X4E3B
X4E3F
X4D3D
X4C3C
X4A3B
X463B
X443C
X433D
X433F
X4440
X4641
X4B43
X4D44
X4E45
XC33E
X443F
X4640
X4B42
X4D43
X4E44
X4E47
X4D48
X4B49
X4749
X4548
X4447
X4345
X4349
X4447
X>
Xput
XMetrics
X/s
X[-3
X17]
Xput
XCharStrings
X/t
X<C534
X4545
X4648
X4849
X4A49
X4C48
X4D46
XC634
X4645
X4748
X4849
XC23B
X4A3B
X>
Xput
XMetrics
X/t
X[5
X15]
Xput
XCharStrings
X/u
X<C53B
X4546
X4648
X4949
X4B49
X4E48
X5046
XC63B
X4646
X4748
X4949
XD03B
X5049
XD13B
X5149
XC23B
X463B
XCD3B
X513B
XD049
X5449
X>
Xput
XMetrics
X/u
X[-2
X22]
Xput
XCharStrings
X/v
X<C33B
X4949
XC43B
X4947
XCF3B
X4949
XC13B
X473B
XCB3B
X513B
X>
Xput
XMetrics
X/v
X[-1
X18]
Xput
XCharStrings
X/w
X<C43B
X4849
XC53B
X4846
XCC3B
X4849
XCC3B
X5049
XCD3B
X5046
XD43B
X5049
XC13B
X483B
XD13B
X573B
X>
Xput
XMetrics
X/w
X[-1
X24]
Xput
XCharStrings
X/x
X<C43B
X4F49
XC53B
X5049
XD03B
X4449
XC23B
X483B
XCC3B
X523B
XC249
X4849
XCC49
X5249
X>
Xput
XMetrics
X/x
X[-2
X20]
Xput
XCharStrings
X/y
X<C43B
X4A49
XC53B
X4A47
XD03B
X4A49
X484D
X464F
X4450
X4350
X424F
X434E
X444F
XC23B
X483B
XCC3B
X523B
X>
Xput
XMetrics
X/y
X[-2
X19]
Xput
XCharStrings
X/z
X<CE3B
X4349
XCF3B
X4449
XC43B
X433F
X433B
X4F3B
XC349
X4F49
X4F45
X4E49
X>
Xput
XMetrics
X/z
X[-3
X18]
Xput
XCharStrings
X/space
X()
Xput
XMetrics
X/space
X[0
X20]
Xput
XCharStrings
X/A
X<CA34
X4349
XCA34
X5149
XCA37
X5049
XC543
X4E43
XC149
X4749
XCD49
X5349
X>
Xput
XMetrics
X/A
X[2
X20]
Xput
XCharStrings
X/B
X<C534
X4549
XC634
X4649
XC234
X4E34
X5135
X5236
X5338
X533A
X523C
X513D
X4E3E
XCE34
X5035
X5136
X5238
X523A
X513C
X503D
X4E3E
XC63E
X4E3E
X513F
X5240
X5342
X5345
X5247
X5148
X4E49
X4249
XCE3E
X503F
X5140
X5242
X5245
X5147
X5048
X4E49
X>
Xput
XMetrics
X/B
X[1
X22]
Xput
XCharStrings
X/C
X<D137
X523A
X5234
X5137
X4F35
X4C34
X4A34
X4735
X4537
X4439
X433C
X4341
X4444
X4546
X4748
X4A49
X4C49
X4F48
X5146
X5244
XCA34
X4835
X4637
X4539
X443C
X4441
X4544
X4646
X4848
X4A49
X>
Xput
XMetrics
X/C
X[1
X21]
Xput
XCharStrings
X/D
X<C534
X4549
XC634
X4649
XC234
X4C34
X4F35
X5137
X5239
X533C
X5341
X5244
X5146
X4F48
X4C49
X4249
XCC34
X4E35
X5037
X5139
X523C
X5241
X5144
X5046
X4E48
X4C49
X>
Xput
XMetrics
X/D
X[1
X22]
Xput
XCharStrings
X/E
X<C534
X4549
XC634
X4649
XCC3A
X4C42
XC234
X5234
X523A
X5134
XC63E
X4C3E
XC249
X5249
X5243
X5149
X>
Xput
XMetrics
X/E
X[1
X21]
Xput
XCharStrings
X/F
X<C534
X4549
XC634
X4649
XCC3A
X4C42
XC234
X5234
X523A
X5134
XC63E
X4C3E
XC249
X4949
X>
Xput
XMetrics
X/F
X[1
X20]
Xput
XCharStrings
X/G
X<D137
X523A
X5234
X5137
X4F35
X4C34
X4A34
X4735
X4537
X4439
X433C
X4341
X4444
X4546
X4748
X4A49
X4C49
X4F48
X5146
XCA34
X4835
X4637
X4539
X443C
X4441
X4544
X4646
X4848
X4A49
XD141
X5149
XD241
X5249
XCE41
X5541
X>
Xput
XMetrics
X/G
X[1
X23]
Xput
XCharStrings
X/H
X<C534
X4549
XC634
X4649
XD234
X5249
XD334
X5349
XC234
X4934
XCF34
X5634
XC63E
X523E
XC249
X4949
XCF49
X5649
X>
Xput
XMetrics
X/H
X[0
X24]
Xput
XCharStrings
X/I
X<C534
X4549
XC634
X4649
XC234
X4934
XC249
X4949
X>
Xput
XMetrics
X/I
X[7
X11]
Xput
XCharStrings
X/J
X<CA34
X4A45
X4948
X4749
X4549
X4348
X4246
X4244
X4343
X4444
X4345
XC934
X4945
X4848
X4749
XC634
X4D34
X>
Xput
XMetrics
X/J
X[5
X15]
Xput
XCharStrings
X/K
X<C534
X4549
XC634
X4649
XD334
X4641
XCB3D
X5349
XCA3D
X5249
XC234
X4934
XCF34
X5534
XC249
X4949
XCF49
X5549
X>
Xput
XMetrics
X/K
X[0
X22]
Xput
XCharStrings
X/L
X<C534
X4549
XC634
X4649
XC234
X4934
XC249
X5149
X5143
X5049
X>
Xput
XMetrics
X/L
X[3
X18]
Xput
XCharStrings
X/M
X<C534
X4549
XC634
X4C46
XC534
X4C49
XD334
X4C49
XD334
X5349
XD434
X5449
XC234
X4634
XD334
X5734
XC249
X4849
XD049
X5749
X>
Xput
XMetrics
X/M
X[0
X25]
Xput
XCharStrings
X/N
X<C534
X4549
XC634
X5247
XC636
X5249
XD234
X5249
XC234
X4634
XCF34
X5534
XC249
X4849
X>
Xput
XMetrics
X/N
X[1
X23]
Xput
XCharStrings
X/O
X<CA34
X4735
X4537
X4439
X433D
X4340
X4444
X4546
X4748
X4A49
X4C49
X4F48
X5146
X5244
X5340
X533D
X5239
X5137
X4F35
X4C34
X4A34
XCA34
X4835
X4637
X4539
X443D
X4440
X4544
X4646
X4848
X4A49
XCC49
X4E48
X5046
X5144
X5240
X523D
X5139
X5037
X4E35
X4C34
X>
Xput
XMetrics
X/O
X[1
X22]
Xput
XCharStrings
X/P
X<C534
X4549
XC634
X4649
XC234
X4E34
X5135
X5236
X5338
X533B
X523D
X513E
X4E3F
X463F
XCE34
X5035
X5136
X5238
X523B
X513D
X503E
X4E3F
XC249
X4949
X>
Xput
XMetrics
X/P
X[1
X22]
Xput
XCharStrings
X/Q
X<CA34
X4735
X4537
X4439
X433D
X4340
X4444
X4546
X4748
X4A49
X4C49
X4F48
X5146
X5244
X5340
X533D
X5239
X5137
X4F35
X4C34
X4A34
XCA34
X4835
X4637
X4539
X443D
X4440
X4544
X4646
X4848
X4A49
XCC49
X4E48
X5046
X5144
X5240
X523D
X5139
X5037
X4E35
X4C34
XC747
X4746
X4844
X4A43
X4B43
X4D44
X4E46
X4F4D
X504E
X524E
X534C
X534B
XCE46
X4F4A
X504C
X514D
X524D
X534C
X>
Xput
XMetrics
X/Q
X[1
X22]
Xput
XCharStrings
X/R
X<C534
X4549
XC634
X4649
XC234
X4E34
X5135
X5236
X5338
X533A
X523C
X513D
X4E3E
X463E
XCE34
X5035
X5136
X5238
X523A
X513C
X503D
X4E3E
XC249
X4949
XCB3E
X4D3F
X4E40
X5147
X5248
X5348
X5447
XCD3F
X4E41
X5048
X5149
X5349
X5447
X5446
X>
Xput
XMetrics
X/R
X[1
X22]
Xput
XCharStrings
X/S
X<D037
X5134
X513A
X5037
X4E35
X4B34
X4834
X4535
X4337
X4339
X443B
X453C
X473D
X4D3F
X4F40
X5142
XC339
X453B
X473C
X4D3E
X4F3F
X5040
X5142
X5146
X4F48
X4C49
X4949
X4648
X4446
X4343
X4349
X4446
X>
Xput
XMetrics
X/S
X[2
X20]
Xput
XCharStrings
X/T
X<C934
X4949
XCA34
X4A49
XC334
X423A
X4234
X5134
X513A
X5034
XC649
X4D49
X>
Xput
XMetrics
X/T
X[3
X19]
Xput
XCharStrings
X/U
X<C534
X4543
X4646
X4848
X4B49
X4D49
X5048
X5246
X5343
X5334
XC634
X4643
X4746
X4948
X4B49
XC234
X4934
XD034
X5634
X>
Xput
XMetrics
X/U
X[0
X24]
Xput
XCharStrings
X/V
X<C334
X4A49
XC434
X4A46
XD134
X4A49
XC134
X4734
XCD34
X5334
X>
Xput
XMetrics
X/V
X[2
X20]
Xput
XCharStrings
X/W
X<C434
X4849
XC534
X4844
XCC34
X4849
XCC34
X5049
XCD34
X5044
XD434
X5049
XC134
X4834
XD134
X5734
X>
Xput
XMetrics
X/W
X[0
X24]
Xput
XCharStrings
X/X
X<C334
X5049
XC434
X5149
XD134
X4349
XC134
X4734
XCD34
X5334
XC149
X4749
XCD49
X5349
X>
Xput
XMetrics
X/X
X[2
X20]
Xput
XCharStrings
X/Y
X<C334
X4A3F
X4A49
XC434
X4B3F
X4B49
XD234
X4B3F
XC134
X4734
XCE34
X5434
XC749
X4E49
X>
Xput
XMetrics
X/Y
X[2
X21]
Xput
XCharStrings
X/Z
X<D034
X4349
XD134
X4449
XC434
X433A
X4334
X5134
XC349
X5149
X5143
X5049
X>
Xput
XMetrics
X/Z
X[2
X20]
Xput
XCharStrings
X/ff
X<CF35
X4E36
X4F37
X5036
X5035
X4E34
X4B34
X4835
X4637
X453A
X4549
XCB34
X4935
X4737
X463A
X4649
XD535
X5436
X5537
X5636
X5635
X5534
X5334
X5135
X5037
X5049
XD334
X5235
X5137
X5149
XC23B
X543B
XC249
X4949
XCD49
X5449
X>
Xput
XMetrics
X/ff
X[1
X23]
Xput
XCharStrings
X/fi
X<D035
X4F36
X5037
X5136
X5035
X4E34
X4B34
X4835
X4637
X453A
X4549
XCB34
X4935
X4737
X463A
X4649
XD03B
X5049
XD13B
X5149
XC23B
X513B
XC249
X4949
XCD49
X5449
X>
Xput
XMetrics
X/fi
X[1
X22]
Xput
XCharStrings
X/fl
X<CF35
X4E36
X4F37
X5036
X5035
X4E34
XD134
X4B34
X4835
X4637
X453A
X4549
XCB34
X4935
X4737
X463A
X4649
XD036
X5049
XD134
X5149
XC23B
X503B
XC249
X4949
XCD49
X5449
X>
Xput
XMetrics
X/fl
X[1
X22]
Xput
XCharStrings
X/ffi
X<D035
X4F36
X5037
X5136
X5035
X4E34
X4B34
X4835
X4637
X453A
X4549
XCB34
X4935
X4737
X463A
X4649
XDB35
X5A36
X5B37
X5C36
X5B35
X5934
X5634
X5335
X5137
X503A
X5049
XD634
X5435
X5237
X513A
X5149
XDB3B
X5B49
XDC3B
X5C49
XC23B
X5C3B
XC249
X4949
XCD49
X5449
XD849
X5F49
X>
Xput
XMetrics
X/ffi
X[-2
X33]
Xput
XCharStrings
X/ffl
X<D035
X4F36
X5037
X5136
X5035
X4E34
X4B34
X4835
X4637
X453A
X4549
XCB34
X4935
X4737
X463A
X4649
XDA35
X5936
X5A37
X5B36
X5B35
X5934
XDC34
X5634
X5335
X5137
X503A
X5049
XD634
X5435
X5237
X513A
X5149
XDB36
X5B49
XDC34
X5C49
XC23B
X5B3B
XC249
X4949
XCD49
X5449
XD849
X5F49
X>
Xput
XMetrics
X/ffl
X[-2
X33]
Xput
XCharStrings
X/dotlessi
X<C53B
X4549
XC63B
X4649
XC23B
X463B
XC249
X4949
X>
Xput
XMetrics
X/dotlessi
X[0
X11]
Xput
END_OF_FILE
if test 9406 -ne `wc -c <'postscript/fonts/Times/roman.r'`; then
    echo shar: \"'postscript/fonts/Times/roman.r'\" unpacked with wrong size!
fi
# end of 'postscript/fonts/Times/roman.r'
fi
if test -f 'source/colour-ww.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/colour-ww.c'\"
else
echo shar: Extracting \"'source/colour-ww.c'\" \(9048 characters\)
sed "s/^X//" >'source/colour-ww.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X#include "graphics.h"
X#include "canon.h"
X#include "wwinfo.h"
X
Xstatic void xxrasterop ();
X
Xstatic struct hardware *NewHardware ();
X
X#define COLOURS 256
X
Xstatic unsigned char reds[COLOURS], greens[COLOURS], blues[COLOURS];
Xstatic int colours_used = 0;
X
Xstruct hardware *InitHardware ()
X {
X	wwstartup (COLOURS);
X 	InitTransfer (wwask (ASKXPPI));
X 	
X 	return NULL;
X }
X
Xint HardColour (h, colour) struct hardware *h; Colour colour;
X {
X	float r, g, b;
X	unsigned char red, green, blue;
X	int i;
X	
X	ColourRGB (colour, &r, &g, &b);
X	
X	red = 255 * r; green = 255 * g; blue = 255 * b;
X	for (i = 0; i < colours_used; i++)
X		if (reds[i] == red && greens[i] == green && blues[i] == blue)
X			return i;
X	if (colours_used == COLOURS)
X		return 0;
X	reds[colours_used] = red; greens[colours_used] = green; blues[colours_used] = blue;
X	colours_used++;
X	
X	InstallColour (h, i);
X	return i;
X }
X
Xvoid Paint  (from, to, fromPoint, toPoint, extent, colour)
X	struct hardware *from, *to;
X	DevicePoint fromPoint, toPoint, extent;
X	Colour colour;
X {
X	dd->d_fore = HardColour (to, colour);
X	BitBlt (from, to, fromPoint, toPoint, extent, ROP_OR);
X }
X
Xvoid PaintLine (h, fromPoint, toPoint, colour)
X	struct hardware *h;
X	DevicePoint fromPoint, toPoint;
X	Colour colour;
X {
X	dd->d_fore = HardColour (h, colour);
X	BitBltLine (h, fromPoint, toPoint, ROP_TRUE);
X }
X
Xvoid PaintTrapezoid (to, lefttop, leftbottom, righttop, rightbottom, top, bottom, colour)
X	struct hardware *to;
X	DevicePoint lefttop, leftbottom, righttop, rightbottom;
X	int top, bottom;
X	Colour colour;
X {
X	dd->d_fore = HardColour (to, colour);
X	BitBltTrapezoid (to, lefttop, leftbottom, righttop, rightbottom, top, bottom, ROP_TRUE);
X }
X
X#define TRANSFER_SIZE	256
X
Xstatic int transfer [TRANSFER_SIZE];
X
Xvoid InitTransfer (ppi) int ppi;
X {
X 	int i;
X 	
X 	pixels_per_inch = ppi;
X 	for (i = 0; i < TRANSFER_SIZE; i++)
X 		transfer [i] = i;
X }
X
Xint TransferSize ()
X {
X	return TRANSFER_SIZE;
X }
X
Xvoid SetTransfer (tran) float *tran;
X {
X 	int i;
X 	
X 	for (i = 0; i < TRANSFER_SIZE; i++)
X 		transfer [i] = (TRANSFER_SIZE - 1) * tran[i] + .5;
X }
X
Xint ScreenSize (freq, rot) float freq, rot;
X {
X 	return 0;
X }
X
Xvoid BuildScreen (freq, rotation, x, y) float freq, rotation, *x, *y;
X {
X }
X
Xvoid SetScreen (freq, rotation, thresh) float freq, rotation, *thresh;
X {
X }
X
Xstruct hardware *NewWindowHardware (width, height) int width, height;
X {
X 	DevicePoint real_extent;
X 	window *w;
X 	
X 	real_extent = NewDevicePoint (width, height);
X 	
X 	if (width == 0)
X 		width = 1;
X 	if (height == 0)
X 		height = 1;
X 	
X 	if ((w = wwxget (boxbuild (0, 0, width, height), COLOURS, "PostScript", 0)) == NULL)
X 		return NULL;
X 	return NewHardware (w->w_bm, real_extent, ISWIN);
X }
X
Xstruct hardware *NewBitmapHardware (width, height) int width, height;
X {
X 	DevicePoint real_extent;
X 	bitmap *bm;
X 	
X 	real_extent = NewDevicePoint (width, height);
X 	
X 	if (width == 0)
X 		width = 1;
X 	if (height == 0)
X 		height = 1;
X 	if ((bm = bmxget (width, height, 2)) == NULL)
X 		return NULL;
X 	
X 	return NewHardware (bm, real_extent, 0);
X }
X
X#define DeviceBitmap(h) ((bitmap *) ((h)->hard.addr))
X
XInstallColour (h, col) struct hardware *h; int col;
X {
X	corep (DeviceBitmap (h), &reds[col], &greens[col], &blues[col], 0, col, 1, COSET);
X }
X
Xstatic void DestroyHard (dev) struct hardware *dev;
X {
X 	bitmap *bm = DeviceBitmap (dev);
X 	
X 	if (bm)
X 	 {
X 	 	if (bm->bm_window)
X 	 		wwfree (bm->bm_window);
X 		else
X 			bmfree (bm);
X 	 }
X }
X
Xvoid DestroyHardware (dev) struct hardware *dev;
X {
X 	if (dev == NULL)
X 		return;
X 	DestroyHard (dev);
X 	if (dev->aux)
X 		DestroyHardware (dev->aux);
X 	Free ((char *) dev);
X }
X
Xstatic struct hardware *NewHardware (bm, extent, flags) bitmap *bm; DevicePoint extent; int flags;
X {
X 	struct hardware *d = (struct hardware *) Malloc (sizeof (struct hardware));
X 	
X 	d->flags = flags;
X 	d->hard.addr = (char *) bm;
X 	d->aux = d->clip = NULL;
X 	d->extent = extent;
X 	
X 	return d;
X }
X
Xstruct hardware *HardwareFromString (st, width, height) char *st; int width, height;
X {
X 	unsigned size = height * (width + 7) / 8;
X 	char *s = Malloc (size + 4);
X 	struct hardware *h;
X 	
X 	s[0] = height >> 8; s[1] = height;
X 	s[2] = width >> 8;  s[3] = width;
X 	Bcopy (s + 4, st, size);
X 	
X 	h = NewHardware (bmdecode (s, ENWWSTYLE), NewDevicePoint (width, height), 0);
X 	Free ((char *) s);
X 	
X 	return h;
X }
X
Xchar *StringFromHardware (dev) struct hardware *dev;
X {
X 	int length;
X 	
X 	return bmencode (DeviceBitmap (dev), ENWWSTYLE, &length) + 4;
X }
X
Xvoid UpdateControl (h, flag) struct hardware *h; int flag;
X {
X 	window *oldddwin = ddwin;
X 	
X 	if (h == NULL)
X 		return;
X 	ddwin = DeviceBitmap (h)->bm_window;
X 	if (ddwin)
X		wwstack (flag ? WWPOP : WWPUSHOFF);
X	ddwin = oldddwin;
X }
X
Xvoid RasterTile (from, to, toPoint, extent, rop)
X	struct hardware *from, *to;
X	DevicePoint toPoint, extent;
X	int rop;
X {
X 	if (to == NULL || DeviceBitmap (to) == NULL || extent.dx == 0 || extent.dy == 0)
X 		return;
X 	bmclip (DeviceBitmap (to), boxbuild (toPoint.dx, toPoint.dy, toPoint.dx + extent.dx - 1, toPoint.dy + extent.dy - 1));
X 	xxrasterop (DeviceBitmap (from), DeviceBitmap (from)->bm_box, DeviceBitmap (to), DeviceBitmap (to)->bm_box, rop);
X 	bmclip (DeviceBitmap (to), noclipbox);
X }
X
Xvoid BitBlt (from, to, fromPoint, toPoint, extent, rop)
X	struct hardware *from, *to;
X	DevicePoint fromPoint, toPoint, extent;
X	int rop;
X {
X	box frombox, tobox;
X	
X	if (to == NULL || DeviceBitmap (to) == NULL || extent.dx == 0 || extent.dy == 0)
X 		return;
X	
X 	if (from == NULL || DeviceBitmap (from) == NULL)
X 		rop = single_rop [rop];
X 	else
X 		frombox = boxbuild (fromPoint.dx, fromPoint.dy, fromPoint.dx + extent.dx - 1, fromPoint.dy + extent.dy - 1);
X 	
X  	tobox = boxbuild (toPoint.dx, toPoint.dy, toPoint.dx + extent.dx - 1, toPoint.dy + extent.dy - 1);
X	
X	xxrasterop ((from == NULL ? NULL : DeviceBitmap (from)), frombox, DeviceBitmap (to), tobox, rop);
X }
X
Xvoid BitBltLine (h, fromPoint, toPoint, rop) 
X  	struct hardware *h;
X	DevicePoint fromPoint, toPoint;
X	int rop;
X {
X 	if (h == NULL || DeviceBitmap (h) == NULL)
X 		return;
X 	
X	switch (single_rop [rop])
X	 {
X	 	case ROP_FALSE: 	rop = WWAND; 	break;
X	 	case ROP_TRUE:  	rop = WWOR;  	break;
X	 	case ROP_NOTDEST: 	rop = WWXOR; 	break;
X	 	case ROP_DEST: 		return; 	break;
X	 	
X	 	default:
X	 		fprintf (stderr, "illegal rasterop\n");
X	 		exit (1);
X	 }
X	
X	ddbm = DeviceBitmap (h);
X 	dd->d_line = rop;
X 	
X	line (fromPoint.dx, fromPoint.dy, LNMOVEABS);
X 	line (toPoint.dx, toPoint.dy, LNDRAWABS);
X }
X
Xvoid BitBltBlob (to, top, height, left, right, rop) struct hardware *to; int top, height, *left, *right, rop;
X {
X 	int i, op, offset = top;
X 	height += top;
X 	switch (rop)
X 	 {
X 	 	case ROP_FALSE: 	op = BMCLEARALL; break;
X 	 	case ROP_DEST: 		return;
X 	 	case ROP_NOTDEST: 	op = BMNOTALL; break;
X 	 	case ROP_TRUE: 		op = BMNOTALL | BMCLEARALL; break;
X 	 }
X 	ddbm = DeviceBitmap (to);
X 	wwstack (WWPUSHOFF);
X 	for (i = top; i < height; i++)
X 		bmbox (boxbuild (left[i - offset], i, right[i - offset], i), op);
X 	wwstack (WWPOP);
X }
X
Xstatic void xxrasterop (from, frombox, to, tobox, rop) bitmap *from, *to; box frombox, tobox; int rop;
X {
X	switch (rop)
X 	 {
X 	 	case ROP_FALSE: 							    bmxbox (to, tobox, BMCLEARALL);	break;
X 	 	case ROP_AND: 		bmxcopy (from, frombox, to, tobox, WWAND); 						break;
X 	 	case ROP_ANDNOT:	bmxcopy (from, frombox, to, tobox, WWOR | WWNOT);   bmxbox (to, tobox, BMNOTALL); 	break;
X	 	case ROP_SOURCE: 	bmxcopy (from, frombox, to, tobox, WWCOPY); 						break;
X	 	case ROP_NOTAND: 	bmxcopy (from, frombox, to, tobox, WWAND | WWNOT); 					break;
X 	 	case ROP_DEST: 													break;
X 	 	case ROP_XOR:		bmxcopy (from, frombox, to, tobox, WWXOR); 						break;
X  	 	case ROP_OR:		bmxcopy (from, frombox, to, tobox, WWOR); 						break;
X  	 	case ROP_NOR:		bmxcopy (from, frombox, to, tobox, WWOR); 	    bmxbox (to, tobox, BMNOTALL); 	break;
X  	 	case ROP_NXOR:		bmxcopy (from, frombox, to, tobox, WWXOR); 	    bmxbox (to, tobox, BMNOTALL); 	break;
X	 	case ROP_NOTDEST: 							    bmxbox (to, tobox, BMNOTALL); 	break;
X	 	case ROP_ORNOT:		bmxcopy (from, frombox, to, tobox, WWAND | WWNOT);  bmxbox (to, tobox, BMNOTALL);	break;
X	 	case ROP_NOTSOURCE:	bmxcopy (from, frombox, to, tobox, WWCOPY | WWNOT); 					break;
X  	 	case ROP_NOTOR:		bmxcopy (from, frombox, to, tobox, WWOR | WWNOT); 					break;
X	 	case ROP_NAND:		bmxcopy (from, frombox, to, tobox, WWAND); 	    bmxbox (to, tobox, BMNOTALL); 	break;
X 	 	case ROP_TRUE: 							bmxbox (to, tobox, BMCLEARALL | BMNOTALL); 	break;
X 	 	
X 	 	default:
X 	 		fprintf (stderr, "Illegal rasterop %d (hex 0x%x)\n", rop, rop);
X 	 		exit (1);
X 	 }
X }
END_OF_FILE
if test 9048 -ne `wc -c <'source/colour-ww.c'`; then
    echo shar: \"'source/colour-ww.c'\" unpacked with wrong size!
fi
# end of 'source/colour-ww.c'
fi
if test -f 'source/integer.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/integer.c'\"
else
echo shar: Extracting \"'source/integer.c'\" \(8759 characters\)
sed "s/^X//" >'source/integer.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include <signal.h>
X#include "main.h"
X
Xstatic Object OpFor;
X	
Xstatic int For (), PFor (), Eq (), Lt (), Le (), Gt (), Ge (), Not (), And (), Or (), Xor (), BitShift ();
Xstatic int Abs (), Add (), Sub (), Mul (), Div (), Mod (), Neg ();
Xstatic int Exp (), Sqrt (), Sin (), Cos (), Atan (), Ln (), Log (), Identity ();
Xstatic int Cvr (), Cvs (), EqEq ();
X
Xstatic int WordSize, Word2, LowMask;
X
XInitInteger ()
X {
X 	unsigned word;
X 	
X 	OpFor = MakeOp ("(forinteger)", For, 0, 1, 5, 6);
X 	
X	TypeInstallOp (Integer, "cvi", 		Identity,	1, 1, 0, 0, Integer);
X 	TypeInstallOp (Integer, "cvr", 		Cvr,		1, 1, 0, 0, Integer);
X  	TypeInstallOp (Integer, "cvs", 		Cvs,		2, 1, 0, 0, Integer, String);
X	TypeInstallOp (Integer, "==", 		EqEq,		1, 0, 0, 0, Integer);
X 	TypeInstallOp (Integer, "for", 		PFor, 		4, 0, 0, 6, Integer, Integer, Integer, Array);
X  	TypeInstallOp (Integer, "eq", 		Eq,		2, 1, 0, 0, Integer, Integer);
X  	TypeInstallOp (Integer, "lt", 		Lt,		2, 1, 0, 0, Integer, Integer);
X 	TypeInstallOp (Integer, "le", 		Le,		2, 1, 0, 0, Integer, Integer);
X 	TypeInstallOp (Integer, "gt", 		Gt,		2, 1, 0, 0, Integer, Integer);
X 	TypeInstallOp (Integer, "ge", 		Ge,		2, 1, 0, 0, Integer, Integer);
X 	TypeInstallOp (Integer, "not", 		Not,		1, 1, 0, 0, Integer);
X 	TypeInstallOp (Integer, "and", 		And,		2, 1, 0, 0, Integer, Integer);
X 	TypeInstallOp (Integer, "or", 		Or,		2, 1, 0, 0, Integer, Integer);
X 	TypeInstallOp (Integer, "xor", 		Xor,		2, 1, 0, 0, Integer, Integer);
X 	TypeInstallOp (Integer, "bitshift", 	BitShift,	2, 1, 0, 0, Integer, Integer);
X 	TypeInstallOp (Integer, "abs", 		Abs,		1, 1, 0, 0, Integer);
X 	TypeInstallOp (Integer, "add", 		Add,		2, 1, 0, 0, Integer, Integer);
X 	TypeInstallOp (Integer, "sub", 		Sub,		2, 1, 0, 0, Integer, Integer);
X 	TypeInstallOp (Integer, "mul", 		Mul,		2, 1, 0, 0, Integer, Integer);
X 	TypeInstallOp (Integer, "div", 		Div,		2, 1, 0, 0, Integer, Integer);
X 	TypeInstallOp (Integer, "mod", 		Mod,		2, 1, 0, 0, Integer, Integer);
X 	TypeInstallOp (Integer, "neg", 		Neg,		1, 1, 0, 0, Integer);
X 	TypeInstallOp (Integer, "exp", 		Exp,		2, 1, 0, 0, Integer, Integer);
X 	TypeInstallOp (Integer, "sqrt", 	Sqrt,		1, 1, 0, 0, Integer);
X 	TypeInstallOp (Integer, "sin", 		Sin,		1, 1, 0, 0, Integer);
X 	TypeInstallOp (Integer, "cos", 		Cos,		1, 1, 0, 0, Integer);
X 	TypeInstallOp (Integer, "atan", 	Atan,		2, 1, 0, 0, Integer, Integer);
X 	TypeInstallOp (Integer, "ln", 		Ln,		1, 1, 0, 0, Integer);
X 	TypeInstallOp (Integer, "log", 		Log,		1, 1, 0, 0, Integer);
X 	TypeInstallOp (Integer, "ceiling", 	Identity,	1, 1, 0, 0, Integer);
X 	TypeInstallOp (Integer, "floor", 	Identity,	1, 1, 0, 0, Integer);
X 	TypeInstallOp (Integer, "round", 	Identity,	1, 1, 0, 0, Integer);
X 	TypeInstallOp (Integer, "truncate", 	Identity,	1, 1, 0, 0, Integer);
X 	
X 	word = -1;
X 	PanicIf (word != ~0, "Need 2's complement machine! Sorry.");
X 	
X 	for (WordSize = 0; word != 0; WordSize++)
X 		word >>= 1;
X 	Word2 = WordSize / 2;
X 	LowMask = (1<<Word2) - 1;
X}
X
Xint StrictMul (a, b) int a, b;
X {
X 	int atop, abot, btop, bbot, sum, signed;
X 	
X 	signed = (a < 0) != (b < 0);
X 	a = a < 0 ? -a : a;
X 	b = b < 0 ? -b : b;
X 	abot = a & LowMask;
X 	bbot = b & LowMask;
X 	atop = a >> Word2;
X 	btop = b >> Word2;
X 	sum = abot * btop + atop * bbot;
X 	sum += ((unsigned) (abot * bbot) >> Word2);
X 	sum = ((unsigned) sum >> Word2) + atop * btop;
X 	if (sum != 0 || a * b < 0)
X 		kill (getpid (), SIGFPE);
X 	return signed ? -a * b : a * b;
X }
X
Xint StrictAdd (a, b) int a, b;
X {
X	if ((a < 0) == (b < 0) && (a < 0) != (a + b < 0))
X		kill (getpid (), SIGFPE);
X	return a + b;
X }
X
Xint BodyInteger (item) Object item;
X {
X 	return item.u.Integer;
X }
X
Xstatic int Body (item) Object item;
X {
X 	return item.u.Integer;
X }
X
XObject MakeInteger (i) int i;
X {
X 	Object res;
X 	
X 	res = MakeObject (Integer);
X 	res.u.Integer = i;
X 	
X 	return res;
X }
X
Xstatic Object Make (i) int i;
X {
X 	Object res;
X 	
X 	res = MakeObject (Integer);
X 	res.u.Integer = i;
X 	
X 	return res;
X }
X
Xstatic int Cvr (item) Object item;
X {
X	return Push (OpStack, RealInteger (item));
X }
X
Xstatic int Cvs (v, string) Object v, string;
X {
X	int length;
X	char buf [BUFSIZE];
X 	
X	VOID sprintf (buf, "%d", BodyInteger (v));
X	if ((length = strlen (buf)) > lengthString (string))
X		return Error (PRangeCheck);
X	VOID Bcopy (BodyString (string), buf, length);
X	return Push (OpStack, getIString (string, 0, length));
X }
X
Xstatic int EqEq (v) Object v;
X {
X	printf ("%d", BodyInteger (v));
X	return TRUE;
X }
X
XObject IntReal (o) Object o;
X {
X 	return Make ((int) BodyReal (o));
X }
X
Xstatic int PFor (initial, increment, limit, proc) Object initial, increment, limit, proc;
X {
X 	VOID Push (ExecStack, Nil);
X	VOID Push (ExecStack, increment);
X	VOID Push (ExecStack, limit);
X	VOID Push (ExecStack, initial);
X	VOID Push (ExecStack, proc);
X	VOID Push (ExecStack, OpFor);
X	
X	return TRUE;
X }
X
Xstatic int For ()
X {
X	Object current, limit, increment, proc;
X	
X	proc	  = Pop (ExecStack);
X	current   = Pop (ExecStack);
X	limit	  = Pop (ExecStack);
X	increment = Pop (ExecStack);
X	
X	if (Body (increment) > 0
X				? Body (current) > Body (limit)
X				: Body (current) < Body (limit))
X	 	VOID Pop (ExecStack);
X	else
X	 {
X	 	VOID Push (ExecStack, increment);
X	 	VOID Push (ExecStack, limit);
X	 	VOID Push (ExecStack, Make (StrictAdd (Body (current), Body (increment))));
X	 	VOID Push (ExecStack, proc);
X	 	VOID Push (ExecStack, OpFor);
X	 	VOID Push (ExecStack, proc);
X	 	VOID Push (OpStack, current);
X	 }
X	return TRUE;
X }
X
Xstatic int Eq (a, b) Object a, b;
X {
X 	return Push (OpStack, MakeBoolean (Body (a) == Body (b)));
X }
X
Xstatic int Lt (a, b) Object a, b;
X {
X 	return Push (OpStack, MakeBoolean (Body (a) < Body (b)));
X }
X
Xstatic int Le (a, b) Object a, b;
X {
X 	return Push (OpStack, MakeBoolean (Body (a) <= Body (b)));
X }
X
Xstatic int Gt (a, b) Object a, b;
X {
X 	return Push (OpStack, MakeBoolean (Body (a) > Body (b)));
X }
X
Xstatic int Ge (a, b) Object a, b;
X {
X 	return Push (OpStack, MakeBoolean (Body (a) >= Body (b)));
X }
X
Xstatic int Not (integer) Object integer;
X {
X 	 return Push (OpStack, Make (~ Body (integer)));
X }
X
Xstatic int And (a, b) Object a, b;
X {
X 	return Push (OpStack, Make (Body (a) & Body (b)));
X }
X
Xstatic int Or (a, b) Object a, b;
X {
X 	return Push (OpStack, Make (Body (a) | Body (b)));
X }
X
Xstatic int Xor (a, b) Object a, b;
X {
X 	return Push (OpStack, Make (Body (a) ^ Body (b)));
X }
X
Xstatic int BitShift (a, b) Object a, b;
X {
X 	if (Body (b) > 0)
X 		return Push (OpStack, Make ((int) ((unsigned) Body (a) << Body (b))));
X 	else
X 		return Push (OpStack, Make ((int) ((unsigned) Body (a) >> (-Body (b)))));
X }
X
Xstatic int Abs (v) Object v;
X {
X 	return Push (OpStack, Make (Body (v) >= 0 ? Body (v) : -Body (v)));
X }
X
Xstatic int Add (a, b) Object a, b;
X {
X 	return Push (OpStack, Make (StrictAdd (Body (a), Body (b))));
X }
X
Xstatic int Sub (a, b) Object a, b;
X {
X 	return Push (OpStack, Make (StrictAdd (Body (a), -Body (b))));
X }
X
Xstatic int Mul (a, b) Object a, b;
X {
X 	return Push (OpStack, Make (StrictMul (Body (a), Body (b))));
X }
X
Xstatic int Div (a, b) Object a, b;
X {
X 	if (Body (b) == 0)
X 		return Error (PUnResult);
X 	return Push (OpStack, MakeReal ((float) Body (a) / (float) Body (b)));
X }
X
Xstatic int Mod (a, b) Object a, b;
X {
X 	if (Body (b) == 0)
X 		return Error (PUnResult);
X 	return Push (OpStack, Make (Body (a) % Body (b)));
X }
X
Xstatic int Neg (a) Object a;
X {
X	return Push (OpStack, Make (-Body (a)));
X }
X
Xstatic int Sqrt (v) Object v;
X {
X  	if (Body (v) < 0)
X 		return Error (PUnResult);
X	return Push (OpStack, MakeReal ((float) sqrt ((double) Body (v))));
X }
X
Xstatic int Exp (a, b) Object a, b;
X {
X	return Push (OpStack, MakeReal ((float) pow ((double) Body (a), (double) Body (b))));
X }
X
Xstatic int Identity (v) Object v;
X {
X 	return Push (OpStack, v);
X }
X
Xstatic int Sin (v) Object v;
X {
X 	return Push (OpStack, MakeReal ((float) sin (Rad ((double) Body (v)))));
X }
X
Xstatic int Cos (v) Object v;
X {
X 	return Push (OpStack, MakeReal ((float) cos (Rad ((double) Body (v)))));
X }
X
Xstatic int Atan (a, b) Object a, b;
X {
X 	return Push (OpStack, MakeReal ((float) Deg (atan2 ((double) Body (a), (double) Body (b)))));
X }
X
Xstatic int Ln (v) Object v;
X {
X 	return Push (OpStack, MakeReal ((float) log ((double) Body (v))));
X }
X
Xstatic int Log (v) Object v;
X {
X 	return Push (OpStack, MakeReal ((float) log10 ((double) Body (v))));
X }
END_OF_FILE
if test 8759 -ne `wc -c <'source/integer.c'`; then
    echo shar: \"'source/integer.c'\" unpacked with wrong size!
fi
# end of 'source/integer.c'
fi
if test -f 'source/operator.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/operator.c'\"
else
echo shar: Extracting \"'source/operator.c'\" \(8110 characters\)
sed "s/^X//" >'source/operator.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X
Xstruct op_struct
X {
X 	Object name;
X 	int (*fn)(), arguments, results, execpop, execpush;
X 	Type *argtypes;
X };
X
Xint ExecOperator ();
Xstatic int EqEq (), Cvs (), Eq (), Signature ();
X
XInitOperator ()
X {
X 	
X	TypeInstallOp (Operator, "==", 	EqEq,			1, 0, 0, 0, Operator);
X  	TypeInstallOp (Operator, "cvs", Cvs,			2, 1, 0, 0, Operator, String);
X  	TypeInstallOp (Operator, "exec",ExecOperator,		1, 0, 0, 0, Operator);
X  	TypeInstallOp (Operator, "eq",	Eq,			2, 1, 0, 0, Operator, Operator);
X  	TypeInstallOp (Operator, "signature",	Signature,	1, 0, 0, 0, Operator);
X }
X
X/*VARARGS6*/
X/*ARGSUSED*/
XObject MakeOp (name, fn, arguments, results, execpop, execpush, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
X		char *name;
X		int (*fn)(), arguments, results, execpop, execpush;
X		Type arg1, arg2, arg3, arg4, arg5, arg6, arg7;
X {
X 	Object res;
X 	struct op_struct *op;
X 	int i;
X 	
X 	res = Cvx (MakeObject (Operator));
X 	res.u.Operator = op = (struct op_struct *) Malloc (sizeof (struct op_struct));
X	
X	op->name	= NameFrom (name);
X	op->fn		= fn;
X 	op->arguments	= arguments;
X 	op->results	= results;
X 	op->execpop	= execpop;
X 	op->execpush	= execpush;
X 	
X 	op->argtypes = (Type *) Malloc ((unsigned) sizeof (Type) * arguments);
X 	
X 	for (i = 0; i < arguments; i++)
X 		op->argtypes[i] = (&arg1)[i];
X 	
X 	return res;
X }
X
X/*VARARGS6*/
X/*ARGSUSED*/
XInstallOp (name, fn, arguments, results, execpop, execpush, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
X		char *name;
X		int (*fn)(), arguments, results, execpop, execpush;
X		Type arg1, arg2, arg3, arg4, arg5, arg6, arg7;
X {
X 	Object res;
X 	struct op_struct *op;
X 	int i;
X 	res = Cvx (MakeObject (Operator));
X 	res.u.Operator = op = (struct op_struct *) Malloc (sizeof (struct op_struct));
X	
X	op->name	= NameFrom (name);
X	op->fn		= fn;
X 	op->arguments	= arguments;
X 	op->results	= results;
X 	op->execpop	= execpop;
X 	op->execpush	= execpush;
X 	
X 	op->argtypes = (Type *) Malloc ((unsigned) sizeof (Type) * arguments);
X	
X/* 	for (i = 0; i < arguments; i++)
X 		op->argtypes[i] = (&arg1)[i];
X */	switch (arguments)
X 	 {
X 	 	default:
X 	 		Panic ("too many arguments in InstallOp");
X 	 		break;
X 	 	case 7: op->argtypes[6] = arg7;
X 		case 6: op->argtypes[5] = arg6;
X 		case 5: op->argtypes[4] = arg5;
X 		case 4: op->argtypes[3] = arg4;
X 		case 3: op->argtypes[2] = arg3;
X 		case 2: op->argtypes[1] = arg2;
X 		case 1: op->argtypes[0] = arg1;
X 		case 0: break;
X 	 }
X	DictStore (SysDict, NameOperator (res), res);
X }
X
X/*VARARGS7*/
X/*ARGSUSED*/
XTypeInstallOp (type, name, fn, arguments, results, execpop, execpush, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
X		char *name;
X		int (*fn)(), arguments, results, execpop, execpush;
X		Type type, arg1, arg2, arg3, arg4, arg5, arg6, arg7;
X {
X 	Object res;
X 	struct op_struct *op;
X 	int i;
X 	
X 	res = Cvx (MakeObject (Operator));
X 	res.u.Operator = op = (struct op_struct *) Malloc (sizeof (struct op_struct));
X	
X	op->name	= NameFrom (name);
X	op->fn		= fn;
X 	op->arguments	= arguments;
X 	op->results	= results;
X 	op->execpop	= execpop;
X 	op->execpush	= execpush;
X 	
X 	op->argtypes = (Type *) Malloc ((unsigned) sizeof (Type) * arguments);
X 	
X 	for (i = 0; i < arguments; i++)
X 		op->argtypes[i] = (&arg1)[i];
X 	
X 	TypeInstall (type, name, res);
X }
X
Xstatic struct op_struct *Body (item) Object item;
X {
X 	return item.u.Operator;
X }
X
X#define Body(op)	((op).u.Operator)
X
Xstatic int Eq (a, b) Object a, b;
X {
X 	return Push (OpStack, MakeBoolean (Body (a) == Body (b)));
X }
X
XObject NameOperator (item) Object item;
X {
X 	return Body (item)->name;
X }
X
X#define NameOperator(op)	((op).u.Operator->name)
X
Xstatic int Cvs (v, string) Object v, string;
X {
X 	Object vv;
X 	int length;
X 	
X 	vv = NameOperator (v);
X 	
X	if (lengthString (string) < (length = lengthName (vv)))
X		return Error (PRangeCheck);
X	VOID strncpy (BodyString (string), BodyName (vv), length);
X	return Push (OpStack, getIString (string, 0, length));
X }
X
Xstatic int EqEq (v) Object v;
X {
X 	VOID Push (OpStack, NameOperator (v));
X 	VOID Push (ExecStack, Cvx (NameFrom ("==")));
X	return TRUE;
X }
X
X/*
X * Operator types.
X *
X *	PostScript has 200 or so operators which can be divided into groups by the
X *	arguments required.
X *
X *	The type Real 		causes an Integer argument to get floated.
X *	The type Unchecked 	causes an argument to be passed through whatever type it has.
X *	The type Number		causes all Number arguments to be Integer or Real
X *
X *	An operator object comprises several pieces of information:
X *
X *	1	Number of arguments required
X *	2	Number of results which may be returned
X *	3	Number of items required on the ExecStack
X *	4	Number of items added to the ExecStack
X *	5	A List of argument types
X *
X *	Functions requiring strange arguments can declare themselves to take few
X *	arguments and then use some directly from the OpStack.
X *
X *	The first four arguments are only required for checking Stack over and underflow,
X *	thus operators are not required to hold to their requests.
X *
X *	After resolving any peculiar type rules, Exec will lookup the operator name in the type
X *	dictionary for the argument type which is specified as being the controlling argument.
X *	The operator will receive the correct number of arguments and will be expected to stack
X *	its own results. There will be a fixed maximum limit of the number of arguments an operator
X *	can declare for itself. This is likely to be the maximum that PostScript uses, i.e. 6 or 7.
X *
X */
X
Xint ExecOperator (item) Object item;
X {
X	struct op_struct *op = Body (item);
X	int i, res, (*fn)() = op->fn;
X	Object arg[7];
X	
X	Self = NameOperator (item);
X	     if (op->results	> MaxStack (OpStack)   - Height (OpStack))	return Error (POpOverflow);
X	else if (op->execpush	> MaxStack (ExecStack) - Height (ExecStack))	return Error (PExecOverflow);
X	else if (op->arguments  > Height   (OpStack))				return Error (POpUnderflow);
X	else if (op->execpop	> Height   (ExecStack))				return Error (PExecUnderflow);
X	
X	for (i = op->arguments - 1; i >= 0; i--)
X		arg[i] = Pop (OpStack);
X	for (i = op->arguments - 1; i >= 0; i--)
X	 {
X	 	Type formal = op->argtypes[i], actual = TypeOf (arg[i]);
X	 	
X	 	if (formal == Float && actual == Integer)
X 	 		arg[i] = RealInteger (arg[i]);
X		if (formal == actual ||
X				formal == Poly ||
X				formal == Float &&
X					(actual == Integer || actual == Real))
X	 	 	continue;
X	 	for (i = 0; i < op->arguments; i++)
X			VOID Push (OpStack, arg[i]);
X		return Error (PTypeCheck);
X	 }
X	
X	/*if (setjmp (env))
X	 	res = Error (PUnResult);
X	else */
X		switch (op->arguments)
X		 {
X		 	case 0: res = (*fn) (); break;
X		 	case 1: res = (*fn) (arg[0]); break;
X		 	case 2: res = (*fn) (arg[0], arg[1]); break;
X		 	case 3: res = (*fn) (arg[0], arg[1], arg[2]); break;
X		 	case 4: res = (*fn) (arg[0], arg[1], arg[2], arg[3]); break;
X		 	case 5: res = (*fn) (arg[0], arg[1], arg[2], arg[3], arg[4]); break;
X		 	case 6: res = (*fn) (arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]); break;
X		 	case 7: res = (*fn) (arg[0], arg[1], arg[2], arg[3], arg[4], arg[5], arg[6]); break;
X		 	
X		 	default: Panic ("primitve with too many arguments");
X		 }
X	 	/*	res = (*fn) (arg[0], arg[1], arg[2], arg[3], arg[4], arg[5], arg[6]);	*/
X	
X	if (!res)
X		for (i = 0; i < op->arguments; i++)
X			VOID Push (OpStack, arg[i]);
X	return res;
X }
X
Xstatic int Signature (op) Object op;
X {
X	Object tn;
X 	struct op_struct *ops = Body (op);
X 	int i;
X 	
X 	tn = NameFrom ("type");
X 	if (!OpCheck (0, ops->arguments + 1))
X 		return FALSE;
X 	for (i = 0; i < ops->arguments; i++)
X 		VOID Push (OpStack, Lookup (ops->argtypes[i], tn));
X 	VOID Push (OpStack, MakeInteger (ops->arguments));
X 	VOID Push (OpStack, MakeInteger (ops->results));
X 	
X 	return TRUE;
X }
END_OF_FILE
if test 8110 -ne `wc -c <'source/operator.c'`; then
    echo shar: \"'source/operator.c'\" unpacked with wrong size!
fi
# end of 'source/operator.c'
fi
echo shar: End of archive 6 \(of 18\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
