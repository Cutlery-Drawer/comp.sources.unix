Subject:  v12i059:  A PostScript interpreter, Part10/18
Newsgroups: comp.sources.unix
Sender: sources
Approved: rs@uunet.UU.NET

Submitted-by: Crispin Goswell <caag@vd.rl.ac.uk>
Posting-number: Volume 12, Issue 59
Archive-name: postscript/part10

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 10 (of 18)."
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'postscript/fonts/Gothic/roman.r' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'postscript/fonts/Gothic/roman.r'\"
else
echo shar: Extracting \"'postscript/fonts/Gothic/roman.r'\" \(12937 characters\)
sed "s/^X//" >'postscript/fonts/Gothic/roman.r' <<'END_OF_FILE'
XCharStrings
X/A<C936
X4737
X4539
X443B
X433E
X4341
X4443
X4644
XC53A
X443D
X4441
X4543
XC936
X4738
X463A
X453D
X4540
X4644
X4646
X4548
X4349
XD136
X5336
X5347
X5147
XD436
X5447
XD535
X5548
XC334
X4635
X4C36
X5136
X5535
X5734
XC53E
X533E
XC349
X4648
X4C47
X5147
X5548
X5749
X>
Xput
XMetrics
X/A[-1
X26]
Xput
XCharStrings
X/B<C735
X4748
XC835
X4848
XCB34
X4935
X4948
X4B49
XC338
X4536
X4735
X4B34
X5034
X5335
X5537
X5539
X543B
XD336
X5437
X5439
X533B
XD034
X5235
X5337
X5339
X523A
XCC43
X4A42
X4940
X493E
X4A3C
X4B3B
X4E3A
X513A
X543B
X563D
X573F
X5742
X5645
X5447
X5248
X4F49
X4B49
X4748
X4547
X4345
XD53D
X563F
X5643
X5545
XD13A
X543C
X553F
X5543
X5446
X5248
X>
Xput
XMetrics
X/B[-1
X26]
Xput
XCharStrings
X/C<D734
X5636
X5538
X5336
X5135
X4E34
X4C34
X4935
X4736
X4538
X443A
X433D
X4340
X4443
X4545
X4747
X4948
X4C49
X4E49
X5148
X5347
X5545
X5647
X5749
XD636
X553B
X5542
X5647
XD539
X5438
XD53C
X5439
X5337
X5135
XC539
X443C
X4441
X4544
XC935
X4737
X4639
X453C
X4541
X4644
X4746
X4948
XD445
X5544
XD148
X5346
X5444
X5541
X>
Xput
XMetrics
X/C[-1
X26]
Xput
XCharStrings
X/D<C635
X4648
XC735
X4748
XC934
X4835
X4848
X4949
XC339
X4437
X4635
X4934
X4E34
X5135
X5336
X5538
X563A
X573D
X5740
X5643
X5545
X5347
X5148
X4E49
X4949
X4648
X4446
X4344
XD539
X563C
X5641
X5544
XD135
X5337
X5439
X553C
X5541
X5444
X5346
X5148
X>
Xput
XMetrics
X/D[-1
X26]
Xput
XCharStrings
X/E<D734
X5636
X5538
X5336
X5135
X4E34
X4C34
X4935
X4736
X4538
X443A
X433D
X4340
X4443
X4545
X4747
X4948
X4C49
X4E49
X5148
X5347
X5545
X5647
X5749
XD636
X553B
X5542
X5647
XD539
X5438
XD53B
X5337
X5135
XC539
X443C
X4441
X4544
XC935
X4737
X4639
X453C
X4541
X4644
X4746
X4948
XD445
X5544
XD148
X5346
X5444
X5541
XC53E
X463D
X493D
X503F
X533F
X553E
XCB3E
X4D3F
X5040
X5240
X543F
XC83D
X4D40
X5041
X5241
X5440
X553E
XD53B
X543A
X533A
X523B
X533C
X543B
X>
Xput
XMetrics
X/E[-1
X26]
Xput
XCharStrings
X/F<C536
X4548
XC835
X4636
X4647
XCA34
X4835
X4737
X4747
X4947
XC338
X4536
X4735
X4A34
X4E34
X5135
X5336
X5437
X5734
XD734
X5636
X553A
X553D
X5641
X5743
XD537
X5439
XD135
X5337
X543A
X553D
XC73E
X483D
X4A3D
X4F3E
X523E
X543D
XCC3E
X4F3F
X513F
X533E
XC93D
X4F40
X5140
X533F
X543D
X543A
X5339
X5239
X513A
X523B
X533A
XC349
X4548
X4947
X4E47
X5448
X5749
X>
Xput
XMetrics
X/F[-1
X26]
Xput
XCharStrings
X/G<D734
X5636
X5538
X5336
X5135
X4E34
X4C34
X4935
X4736
X4538
X443A
X433D
X4340
X4443
X4545
X4747
X4948
X4C49
X4F49
X5148
X5347
X5446
X5544
X5647
X5749
XD636
X553B
X5542
X5647
XD539
X5438
XD53C
X5439
X5337
X5135
XC539
X443C
X4441
X4544
XC935
X4737
X4639
X453C
X4541
X4644
X4746
X4948
XD346
X5444
X5440
XD148
X5247
X5344
X533F
XC641
X4740
X4841
X4742
X4642
X4541
XC53E
X463C
X483B
X4A3B
X4D3C
X503E
X523F
XC63D
X483C
X4A3C
X4D3D
X4F3E
XC53E
X473D
X4A3D
X503F
X543F
X553E
X>
Xput
XMetrics
X/G[-1
X26]
Xput
XCharStrings
X/H<C535
X4548
X4349
XC636
X4648
XC936
X4736
X4748
XC334
X4535
X4936
X4E36
X5435
X5734
XC73E
X483C
X4A3A
X4D39
X5139
X543A
X563C
X573F
X5742
X5643
X5444
XD53C
X563E
X5641
X5543
XD139
X533A
X543B
X553D
X5541
X5444
X5446
X5548
X5749
XC349
X4748
X4B48
X5049
X>
Xput
XMetrics
X/H[-1
X26]
Xput
XCharStrings
X/I<CC37
X4C47
XCD38
X4D46
XCE37
X4E47
XC334
X4736
X4B37
X4F37
X5336
X5734
XC349
X4648
X4A47
X5047
X5448
X5749
X>
Xput
XMetrics
X/I[-1
X26]
Xput
XCharStrings
X/J<CF37
X5137
X5146
X5048
X4E49
XD237
X5246
X5147
XD336
X5347
XC334
X4736
X4B37
X4F37
X5336
X5734
XC43D
X433F
X4343
X4446
X4648
X4949
X4E49
X5148
X5347
X5545
X5742
XC443
X4546
X4647
XC341
X4543
X4646
X4748
X4949
X>
Xput
XMetrics
X/J[-1
X26]
Xput
XCharStrings
X/K<C535
X4548
X4349
XC636
X4648
XC936
X4736
X4748
XC334
X4535
X4936
X4E36
X5435
X5734
XC73E
X483C
X4A3A
X4D39
X5039
X533A
X543B
X543D
X533E
X4E40
X4C41
X4B42
X4B43
X4C44
X4D43
X4C42
XD23A
X533B
X533D
X523E
XD039
X523B
X523D
X513E
X4E40
XCE40
X5140
X5441
X5543
X5545
X5446
XD241
X5443
X5445
XCE40
X5141
X5343
X5446
X5548
X5649
X5749
XC349
X4748
X4B48
X5049
X>
Xput
XMetrics
X/K[-1
X26]
Xput
XCharStrings
X/L<C535
X4548
XC636
X4647
XC936
X4736
X4747
X4947
XD739
X553C
X543E
X5341
X5343
X5445
X5646
XD53D
X5440
X5443
X5545
XD739
X563B
X553F
X5542
X5646
X5749
XC334
X4535
X4936
X4E36
X5435
X5734
XC349
X4548
X4947
X4E47
X5448
X5749
X>
Xput
XMetrics
X/L[-1
X26]
Xput
XCharStrings
X/M<CC37
X4C47
XCD38
X4D46
XCE37
X4E47
XC947
X4745
X4544
X4443
X4340
X433B
X4438
X4636
X4835
X4B34
X4F34
X5235
X5436
X5638
X573B
X5740
X5643
X5544
X5345
X5147
XC543
X4440
X443B
X4538
XC745
X4643
X4540
X453A
X4637
X4835
XD538
X563B
X5640
X5543
XD235
X5437
X553A
X5540
X5443
X5345
XC334
X4736
X4B37
X4F37
X5336
X5734
XC349
X4648
X4A47
X5047
X5448
X5749
X>
Xput
XMetrics
X/M[-1
X26]
Xput
XCharStrings
X/N<C536
X4548
X4349
XC736
X4637
X4648
XCA34
X4835
X4737
X4748
XC338
X4536
X4735
X4A34
X4E34
X5135
X5336
X5538
X563A
X573D
X5741
X5643
X5444
XD539
X563C
X5640
X5543
XD135
X5337
X5439
X553C
X5540
X5444
X5446
X5548
X5649
X5749
XC349
X4748
X4B48
X5049
X>
Xput
XMetrics
X/N[-1
X26]
Xput
XCharStrings
X/O<CC34
X4935
X4736
X4538
X443A
X433D
X4340
X4443
X4545
X4747
X4948
X4C49
X4E49
X5148
X5347
X5545
X5643
X5740
X573D
X563A
X5538
X5336
X5135
X4E34
X4C34
XC539
X443C
X4441
X4544
XC935
X4737
X4639
X453C
X4541
X4644
X4746
X4948
XD544
X5641
X563C
X5539
XD148
X5346
X5444
X5541
X553C
X5439
X5337
X5135
X>
Xput
XMetrics
X/O[-1
X26]
Xput
XCharStrings
X/P<C537
X4548
XC836
X4638
X4647
XCC34
X4A35
X4837
X4739
X4747
X4947
XC339
X4537
X4935
X4C34
X4F34
X5235
X5436
X5638
X573B
X573D
X5640
X5442
X5143
X4D43
X4A42
X4840
X473D
XD538
X563A
X563E
X5540
XD235
X5437
X553A
X553E
X5441
X5143
XC349
X4548
X4947
X4E47
X5448
X5749
X>
Xput
XMetrics
X/P[-1
X26]
Xput
XCharStrings
X/Q<CC34
X4935
X4736
X4538
X443A
X433D
X4340
X4443
X4545
X4747
X4948
X4C49
X4E49
X5148
X5347
X5545
X5643
X5740
X573D
X563A
X5538
X5336
X5135
X4E34
X4C34
XC539
X443C
X4441
X4544
XC935
X4737
X4639
X453C
X4541
X4644
X4746
X4948
XD544
X5641
X563C
X5539
XD148
X5346
X5444
X5541
X553C
X5439
X5337
X5135
XC541
X4643
X4944
X4F45
X5645
X5746
X5748
X5649
X5648
X5747
XCB45
X4D45
XC643
X4945
X4C46
X4E46
X4F45
X>
Xput
XMetrics
X/Q[-1
X26]
Xput
XCharStrings
X/R<C537
X4548
X4349
XC637
X4648
XC736
X4748
XC339
X4537
X4736
X4935
X4C34
X5034
X5435
X5637
X5739
X573C
X563E
X553F
XD436
X5537
X5639
X563C
X553E
XD034
X5235
X5437
X5539
X553D
X543F
XD340
X5041
X4D41
X4B40
X4B3E
X4D3D
X503D
X533E
X5540
X5743
X5745
X5646
X5546
XD33F
X5440
X5644
X5645
X5542
XCF3D
X513E
X5340
X5442
X5546
X5648
X5749
XC349
X4748
X4B48
X5049
X>
Xput
XMetrics
X/R[-1
X26]
Xput
XCharStrings
X/S<CF34
X5535
X5734
X5636
X5638
X5436
X5235
X4F34
X4B34
X4835
X4538
X443B
X443D
X4540
X4742
X4A43
X4D43
X4F42
X5041
X513F
X513E
XD635
X5536
X5638
XC53E
X4640
X4741
X4A42
X4D42
X4F41
XC637
X4539
X453C
X463E
X4840
X4B41
X4D41
X4F40
X513E
X523D
X533D
XC73F
X483F
X493E
X4B3C
X4D3B
X503B
X523C
X543E
X5540
X5543
X5446
X5248
XCB3B
X4D3A
X503A
X533B
X553D
X5640
X5643
X5545
XC445
X4547
X4448
XC93E
X493D
X4A3B
X4B3A
X4D39
X5039
X533A
X563D
X5740
X5742
X5645
X5447
X5248
X4F49
X4B49
X4848
X4647
X4445
X4447
X4349
X4548
X4B49
X>
Xput
XMetrics
X/S[-1
X26]
Xput
XCharStrings
X/T<CC36
X4836
X4637
X4538
X443A
X433D
X4341
X4444
X4546
X4647
X4848
X4B49
X4E49
X5148
X5347
X5545
X5643
X5740
X573C
X5639
X5437
X5236
XD036
X4F37
X4F39
X503A
X5139
X5038
XC441
X4544
X4746
X4947
X4C48
X4F48
X5247
XC538
X443C
X443F
X4542
X4745
X4946
X4C47
X4F47
X5246
X5445
X5642
X5740
XC334
X4637
XC636
X4735
XC435
X4535
X4634
X4835
X4C36
X5236
X5535
X5734
X>
Xput
XMetrics
X/T[-1
X26]
Xput
XCharStrings
X/U<C736
X4538
X443A
X433D
X4340
X4443
X4545
X4747
X4948
X4C49
X5049
X5348
X5547
XC638
X453A
X443D
X4441
X4544
XC637
X4738
X4739
X463B
X453E
X4541
X4644
X4746
X4948
XD136
X5336
X5346
X5248
X5049
XD436
X5446
X5347
XD535
X5547
X5749
XC334
X4635
X4C36
X5136
X5535
X5734
X>
Xput
XMetrics
X/U[-1
X26]
Xput
XCharStrings
X/V<C334
X4D49
XC435
X4536
X4C45
X4D47
XC535
X4636
X4D45
X4E46
XD734
X4D49
XD23C
X5041
XD43A
X503F
X4F42
X4F44
XC334
X4535
X4A36
X5036
X5535
X5734
X>
Xput
XMetrics
X/V[-1
X26]
Xput
XCharStrings
X/W<C736
X4538
X443A
X433D
X4340
X4443
X4545
X4747
X4948
X4C49
X4E49
X5148
X5347
X5545
X5643
X5740
X573D
X563A
X5538
X5336
XC53A
X443D
X4440
X4543
X4645
XC538
X4639
X463A
X453D
X4540
X4644
X4746
X4948
XD445
X5543
X5640
X563D
X553A
XD148
X5346
X5444
X5540
X553D
X543A
X5439
X5538
XCC37
X4C49
XCD38
X4D48
XCE37
X4E49
XC334
X4736
X4B37
X4F37
X5336
X5734
X>
Xput
XMetrics
X/W[-1
X26]
Xput
XCharStrings
X/X<C334
X5347
X5448
XC435
X4636
X5548
XC736
X5749
XD734
X4E3E
XCC40
X4548
XCB41
X4843
X4745
XCC40
X4842
X4743
X4645
X4647
XC334
X4736
X4B37
X4F37
X5336
X5734
XC349
X4548
X4947
X4E47
X5448
X5749
X>
Xput
XMetrics
X/X[-1
X26]
Xput
XCharStrings
X/Y<D336
X5348
XD436
X5447
XD535
X5547
XC636
X4438
X433B
X433E
X4441
X4643
X4844
X4B45
X4E45
X5144
X5343
XC743
X4A44
X5044
XC33E
X4440
X4642
X4943
X4F43
X5144
XC334
X4736
X4B37
X4F37
X5336
X5734
XC345
X4547
X4748
X4B49
X4F49
X5348
X5746
X>
Xput
XMetrics
X/Y[-1
X26]
Xput
XCharStrings
X/Z<C334
X4435
X4636
X4936
X4E34
X5134
X5435
X5537
X5539
X543B
XD335
X5437
X5439
X533B
XD134
X5235
X5337
X533A
XD33C
X4F3D
X4D3D
X4B3C
X4B3A
X4D39
X4F39
X533A
XCF39
X513A
X523B
X513C
X4F3D
XD43B
X563D
X5740
X5742
X5645
X5447
X5248
X4F49
X4B49
X4848
X4647
X4445
X4342
X4340
X443D
X453C
X473B
X493B
X4B3C
X4B3E
X4A3F
X493E
X4A3D
XD33B
X553D
X563F
X5643
X5545
XD33C
X543D
X553F
X5543
X5446
X5248
X>
Xput
XMetrics
X/Z[-1
X26]
Xput
XCharStrings
X/a<C63F
X4342
X4346
X4649
X4A47
XC442
X4446
X4648
XC540
X4545
X4848
XC841
X433C
X443B
X453C
X443D
XC53C
X493C
X4B3B
X4D3D
X4D46
X4E47
XCB3C
X4C3D
X4C46
X4B47
X4C48
X4D47
X4C46
XC93C
X4B3E
X4B46
X4A47
X4C49
X4E47
X>
Xput
XMetrics
X/a[-3
X17]
Xput
XCharStrings
X/b<C536
X4334
X4438
X4446
X4749
X4C47
X4E46
XC536
X4546
X4748
XC536
X4734
X4638
X4645
X4948
XC63D
X4B3B
X4E3E
X4E46
XCB3C
X4D3E
X4D46
XC93C
X4C3F
X4C47
X>
Xput
XMetrics
X/b[3
X17]
Xput
XCharStrings
X/c<C33E
X4347
X4549
X4747
XC43E
X4447
X4548
XC53D
X4546
X4647
X4747
XC33E
X493B
X4B3D
X493E
X473C
XC83C
X4A3D
X>
Xput
XMetrics
X/c[-2
X12]
Xput
XCharStrings
X/d<C83B
X433E
X4346
X4649
X4848
X4B47
X4D47
XC43E
X4446
X4648
XC53D
X4545
X4848
XC637
X4634
X4737
X4D3E
X4D47
XC637
X4C3E
X4C46
XC637
X4337
X4638
X4B3E
X4B47
X>
Xput
XMetrics
X/d[4
X16]
Xput
XCharStrings
X/e<C33E
X4347
X4549
X4747
XC43E
X4447
X4548
XC53D
X4546
X4647
X4747
XC33E
X493B
X4C3F
X4543
XC83C
X4B3F
XC73C
X4A40
X>
Xput
XMetrics
X/e[-2
X13]
Xput
XCharStrings
X/f<C437
X4446
X4347
X4549
XC537
X4546
X4447
X4548
X4647
X4546
XC636
X4646
X4747
X4549
XC437
X4A34
X4C36
X4A37
X4835
XC935
X4B36
XC13B
X443B
XC63B
X4A3B
X>
Xput
XMetrics
X/f[5
X12]
Xput
XCharStrings
X/g<C33E
X4346
X4649
X4B47
XC43E
X4446
X4648
XC53D
X4545
X4848
XC33E
X453D
X4A3B
X4D3E
X4D4B
X4C4D
X4B4E
X494F
X474F
X454E
X434F
X4550
X474F
XCA3C
X4C3E
X4C4B
X4B4D
XC64F
X444F
XC83C
X4B3F
X4B4C
X4A4E
X494F
X>
Xput
XMetrics
X/g[-3
X17]
Xput
XCharStrings
X/h<C536
X4334
X4438
X4446
X4347
X4549
XC536
X4546
X4447
X4548
X4647
X4546
XC536
X4734
X4638
X4646
X4747
X4549
XC63D
X493C
X4B3B
X4E3E
X4E47
X4B4B
X4B4E
X4C50
X4D50
X4B4E
XCB3C
X4D3E
X4D47
X4C49
XC93C
X4C3F
X4C48
X4B4B
X>
Xput
XMetrics
X/h[3
X18]
Xput
XCharStrings
X/i<C534
X4336
X4538
X4736
X4534
XC535
X4436
X4537
X4636
X4535
XC53B
X433D
X443E
X4446
X4347
X4549
XC53E
X463D
X453C
X443D
X453E
X4546
X4447
X4548
X4647
X4546
XC53B
X473D
X463E
X4646
X4747
X4549
X>
Xput
XMetrics
X/i[7
X10]
Xput
XCharStrings
X/j<C534
X4336
X4538
X4736
X4534
XC535
X4436
X4537
X4636
X4535
XC53B
X433D
X443E
X4447
X474B
XC53E
X463D
X453C
X443D
X453E
X4547
X4649
XC53B
X473D
X463E
X4648
X474B
X474E
X4550
X434F
X4350
X4550
X>
Xput
XMetrics
X/j[7
X10]
Xput
XCharStrings
X/k<C536
X4334
X4438
X4446
X4347
X4549
XC536
X4546
X4447
X4548
X4647
X4546
XC536
X4734
X4638
X4646
X4747
X4549
XC63E
X493C
X4B3B
X4D3E
X4A40
X4643
XCA3C
X4C3E
XC93C
X4B3F
XC941
X4A42
X4B47
X4D49
X4F47
XCA41
X4B43
X4C47
X4D48
XCA40
X4B41
X4D46
X4E47
X4F47
X>
Xput
XMetrics
X/k[3
X17]
Xput
XCharStrings
X/l<C536
X4334
X4438
X4446
X4347
X4549
XC536
X4546
X4447
X4548
X4647
X4546
XC536
X4734
X4638
X4646
X4747
X4549
X>
Xput
XMetrics
X/l[7
X10]
Xput
XCharStrings
X/m<C23D
X433D
X443E
X4446
X4347
X4549
XC43C
X453D
X4546
X4447
X4548
X4647
X4546
XC23D
X443B
X463D
X4646
X4747
X4549
XC63D
X493C
X4B3B
X4E3D
X4E46
X4F47
X4D49
XCB3C
X4D3D
X4D46
X4C47
X4D48
X4E47
X4D46
XC93C
X4C3E
X4C46
X4B47
X4D49
XCE3D
X513C
X533B
X563D
X5646
X5747
X5549
XD33C
X553D
X5546
X5447
X5548
X5647
X5546
XD13C
X543E
X5446
X5347
X5549
X>
Xput
XMetrics
X/m[-2
X26]
Xput
XCharStrings
X/n<C23D
X433D
X443E
X4446
X4347
X4549
XC43C
X453D
X4546
X4447
X4548
X4647
X4546
XC23D
X443B
X463D
X4646
X4747
X4549
XC63D
X493C
X4B3B
X4E3D
X4E46
X4F47
X4D49
XCB3C
X4D3D
X4D46
X4C47
X4D48
X4E47
X4D46
XC93C
X4C3E
X4C46
X4B47
X4D49
X>
Xput
XMetrics
X/n[-2
X18]
Xput
XCharStrings
X/o<C33E
X4346
X4649
X4B47
X4D46
XC43E
X4446
X4648
XC53D
X4545
X4848
XC33E
X453D
X4A3B
X4D3E
X4D46
XCA3C
X4C3E
X4C46
XC83C
X4B3F
X4B47
X>
Xput
XMetrics
X/o[-3
X16]
Xput
XCharStrings
X/p<C33B
X443D
X4446
X4247
X4447
X444D
X4350
X454E
XC53D
X454E
XC33B
X453C
X463D
X4646
X4847
X4948
XC547
X4647
X4848
XC648
X4749
X4C47
X4E46
XC648
X464D
X4750
X454E
XC63D
X493C
X4B3B
X4E3E
X4E46
XCB3C
X4D3E
X4D46
XC93C
X4C3F
X4C47
X>
Xput
XMetrics
X/p[-2
X17]
Xput
XCharStrings
X/q<C33E
X4346
X4649
X4B47
XC43E
X4446
X4648
XC53D
X4545
X4848
XC33E
X453D
X4A3B
X4D3E
X4D4D
X4E50
X4C4E
XCA3C
X4C3E
X4C4E
XC83C
X4B3F
X4B4D
X4A50
X4C4E
X>
Xput
XMetrics
X/q[-3
X17]
Xput
XCharStrings
X/r<C23D
X433D
X443E
X4446
X4347
X4549
XC43C
X453D
X4546
X4447
X4548
X4647
X4546
XC23D
X443B
X463D
X4646
X4747
X4549
XC63D
X4A3B
X4C3D
X4A3E
X483C
XC93C
X4B3D
X>
Xput
XMetrics
X/r[-2
X13]
Xput
XCharStrings
X/s<C33E
X4341
X4543
X4B40
X4D42
X4D46
XC43E
X4441
X4542
XC53D
X4541
X4642
XCB41
X4C42
X4C46
XCA41
X4B42
X4B47
XC33E
X493B
X4C3C
X4A3D
X473C
XC83C
X4B3C
XCD46
X4749
X4347
X4546
X4948
XC547
X4748
X>
Xput
XMetrics
X/s[-3
X16]
Xput
XCharStrings
X/t<C536
X4334
X4438
X4446
X4347
X4549
XC536
X4546
X4447
X4548
X4647
X4546
XC536
X4734
X4638
X4646
X4747
X4549
XC13B
X443B
XC63B
X493B
X>
Xput
XMetrics
X/t[7
X10]
Xput
XCharStrings
X/u<C23D
X433D
X443E
X4447
X4749
X4C47
XC43C
X453D
X4547
X4748
XC23D
X443B
X463D
X4646
X4948
XCD3B
X4F3D
X4E3E
X4E46
X4F47
X5047
XCD3E
X4E3D
X4D3C
X4C3D
X4D3E
X4D47
X4E48
XCD3B
X4B3D
X4C3E
X4C47
X4E49
X5047
X>
Xput
XMetrics
X/u[-2
X18]
Xput
XCharStrings
X/v<C33B
X443D
X4446
X4849
X4A47
X4E45
XC43C
X453D
X4546
X4848
XC33B
X453C
X463D
X4645
X4947
X4A47
XCD3B
X4F3D
X4E3E
X4E45
XCD3E
X4E3D
X4D3C
X4C3D
X4D3E
X4D45
XCD3B
X4B3D
X4C3E
X4C46
X>
Xput
XMetrics
X/v[-3
X18]
Xput
XCharStrings
X/w<C33B
X443D
X4446
X4849
X4A47
X4C46
XC43C
X453D
X4546
X4848
XC33B
X453C
X463D
X4645
X4947
X4A47
XCD3B
X4B3D
X4C3E
X4C46
X5049
X5247
X5645
XCD3E
X4E3D
X4D3C
X4C3D
X4D3E
X4D46
X5048
XCD3B
X4F3D
X4E3E
X4E45
X5147
X5247
XD53B
X573D
X563E
X5645
XD53E
X563D
X553C
X543D
X553E
X5545
XD53B
X533D
X543E
X5446
X>
Xput
XMetrics
X/w[-3
X26]
Xput
XCharStrings
X/x<C33D
X453E
X4C48
X4D49
X4F47
XC43C
X463D
X4C47
X4E48
XC33D
X453B
X463C
X4D46
X4F47
XCF3B
X4D3B
X4D3D
X4F3D
X4F3B
X4D3D
X4A41
XC843
X4547
X4349
X4549
X4547
X4347
X4349
XC542
X4842
XCA42
X4D42
X>
Xput
XMetrics
X/x[-3
X18]
Xput
XCharStrings
X/y<C23D
X433D
X443E
X4447
X4749
X4C47
XC43C
X453D
X4547
X4748
XC23D
X443B
X463D
X4646
X4948
XCD3B
X4F3D
X4E3E
X4E4B
X4D4D
X4C4E
X4A4F
X484F
X464E
X444F
X4650
X484F
XCD3E
X4E3D
X4D3C
X4C3D
X4D3E
X4D4C
X4C4D
XC74F
X454F
XCD3B
X4B3D
X4C3E
X4C4C
X4B4E
X4A4F
X>
Xput
XMetrics
X/y[-2
X18]
Xput
XCharStrings
X/z<C63C
X433E
X433D
X463C
X483B
X4B3D
X4B41
X4643
XC83C
X4A3D
X4A41
XC63C
X493E
X4941
X4842
XC643
X4B45
X4B4B
X4A4D
X494E
X474F
X454F
X434E
X414F
X4350
X454F
XCA45
X4A4C
X494D
XC44F
X424F
XC844
X4945
X494C
X484E
X474F
X>
Xput
XMetrics
X/z[-1
X15]
Xput
END_OF_FILE
if test 12937 -ne `wc -c <'postscript/fonts/Gothic/roman.r'`; then
    echo shar: \"'postscript/fonts/Gothic/roman.r'\" unpacked with wrong size!
fi
# end of 'postscript/fonts/Gothic/roman.r'
fi
if test -f 'postscript/psrc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'postscript/psrc'\"
else
echo shar: Extracting \"'postscript/psrc'\" \(11943 characters\)
sed "s/^X//" >'postscript/psrc' <<'END_OF_FILE'
X/executive {
X	{
X		{ (\n) print
X			prompt flush (%statementedit) (r) file
X			dup status not {(\n) print quit} if
X			cvx exec } stopped
X		{ (stopped\n) print } if
X	} loop
X } def
X
X/bind {} def
X
X/save { gsave /save } def
X/restore { grestore pop } def
X/raise { errordict exch get exec } def
X
X/beep ( ) dup 0 7 put def
X/stdin (%stdin) (r) file def
X
X/imagedict 11 dict def
X
X/imagemask { % width height invert matrix proc
X	imagedict begin
X		/p exch def /m exch def /i exch def /h exch def /w exch def
X		
X		/offset 0 def
X		/l1 h w 7 add 8 idiv mul offset add def
X		/s1 l1 string def
X		{
X			/s2 p def
X			/l2 s2 length def
X			l2 0 eq { exit } if
X			s1 offset s2 putinterval
X			/offset offset l2 add def
X			offset l1 gt { end rangecheck raise } if
X			offset l1 eq { exit } if
X		} loop
X		w h i m s1
X	end
X	realimagemask
X} def
X
X/image { % width height depth matrix proc
X	imagedict begin
X		/p exch def /m exch def /d exch def /h exch def /w exch def
X		
X		/offset 0 def
X		/l1 h w d mul 7 add 8 idiv mul offset add def
X		/s1 l1 string def
X		{
X			/s2 p def
X			/l2 s2 length def
X			l2 0 eq { exit } if
X			s1 offset s2 putinterval
X			/offset offset l2 add def
X			offset l1 gt { end rangecheck raise } if
X			offset l1 eq { exit } if
X		} loop
X		w h d m s1
X	end
X	realimage
X} def
X
X/tty (%terminal) (r) file def
X%/tty (|cat -u </dev/tty) (r) file def
X
X/showpage {
X	copypage initgraphics
X	beep print flush
X	false echo
X	{ tty read { pop } if } stopped
X	true echo
X	not {
X		erasepage
X	} if
X} def
X
X/run { { (r) file } stopped { pop stop } if cvx exec } def
X/prompt { (PS>) print } def
X
X/= {
X	dup type /stringtype ne { 30 string cvs } if
X	print (\n) print
X} def
X
X/stack {
X	count dup
X	1 add copy
X	{=} repeat pop
X} def
X
X/pstack {
X	count dup
X	1 add copy array astore
X	{== ( ) print} forall
X	pop
X} def
X
X/showdict 10 dict def
X
X/.show {
X	showdict begin gsave
X	currentpoint translate
X	currentfont dup /FontMatrix get concat
X		dup /BuildChar get	% string font buildchar
X		1 index /FontBBox get	% string font buildchar bbox
X		aload pop	% string font buildchar lx ly hx hy
X		3 -1 roll sub /height exch def
X			% string font buildchar lx hx
X		exch sub /width exch def
X	3 -1 roll % font buildchar string
X	{
X		{ % font buildchar char
X			width 0 setcharwidth
X			3 copy exch exec
X			.adjust
X		} forall
X	} stopped
X	0 0 transform grestore itransform moveto end
X	{ stop } if
X} def
X
X/kshow {
X	showdict begin /p exch def
X		dup length 0 ne {
X			dup 0 get /last exch def
X			dup 0 1 getinterval show
X			dup length 1 sub 1 exch getinterval {
X				last exch dup /last exch def
X				/p load exec
X			} forall
X		} if
X	end
X} def
X
X/stringwidth {
X	gsave
X		matrix currentmatrix nulldevice setmatrix
X		0 0 moveto
X		show
X		currentpoint
X	grestore
X} def
X
X/FontMap 20 dict def
X
X/lib { % name
X	dup length Library length add 1 add string % name s
X	dup 0 Library putinterval % name s
X	dup Library length (/) putinterval % name s
X	exch 1 index exch % s s name
X	Library length 1 add exch % s s l name
X	putinterval
X} def
X
X/findfontdict 10 dict def
X
Xfindfontdict /FFName 256 string put
Xfindfontdict /FFBuf 256 string put
X/font-library (font/) lib def
X
X/oldfindfont /findfont load def
X
X/findfont {
X	dup FontMap exch known {
X		FontMap exch get
X	} if
X	dup FontDirectory exch known
X	{
X		oldfindfont
X	} {
X		dup
X		findfontdict begin
X			FFBuf cvs /FFN exch def
X			FFName 0 font-library putinterval
X			FFName font-library length FFN putinterval
X			FFName 0 FFN length font-library length add getinterval
X				{ run } stopped { pop pop /Times-Roman } if
X		end
X		findfont
X	} ifelse
X} def
X
X
X/StandardEncoding
X[	/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X	/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X	/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X	/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X	/.notdef /.notdef /.notdef /.notdef /space /exclam /quotedbl
X	/numbersign /dollar /percent /ampersand /quoteright /parenleft
X	/parenright /asterisk /plus /comma /hyphen /period /slash /zero
X	/one /two /three /four /five /six /seven /eight /nine /colon
X	/semicolon /less /equal /greater /question /at /A /B /C /D /E /F
X	/G /H /I /J /K /L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z
X	/bracketleft /backslash /bracketright /asciicircum /underscore
X	/quoteleft /a /b /c /d /e /f
X	/g /h /i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z
X	/braceleft /bar /braceright /asciitilde /.notdef /.notdef /.notdef
X	/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X	/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X	/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X	/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X	/.notdef /.notdef /.notdef /exclamdown /cent /sterling /fraction
X	/yen /florin /section /currency /quotesingle /quotedblleft
X	/guillemotleft /guilsinglleft /guilsinglright /fi /fl /.notdef
X	/endash /dagger /daggerdbl /periodcentered /.notdef /paragraph
X	/bullet /quotesinglbase /quotedblbase /quotedblright
X	/guillemotright /ellipsis /perthousand /.notdef /questiondown
X	/.notdef /grave /acute /circumflex /tilde /macron /breve
X	/dotaccent /dieresis /.notdef /ring /cedilla /.notdef
X	/hungarumlaut /ogonek /caron /emdash /.notdef
X	/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X	/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X	/.notdef /AE /.notdef /ordfeminine /.notdef /.notdef /.notdef
X	/.notdef /Lslash /Oslash /OE /ordmasculine /.notdef /.notdef
X	/.notdef /.notdef /.notdef /ae /.notdef /.notdef /.notdef
X	/dotlessi /.notdef /.notdef /lslash /oslash /oe /germandbls
X	/.notdef /.notdef /.notdef /.notdef
X ] def
X
X/AsciiEncoding
X[	/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X	/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X	/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X	/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X	/.notdef /.notdef /.notdef /.notdef /space /exclam /quotedbl
X	/numbersign /dollar /percent /ampersand /quoteright /parenleft
X	/parenright /asterisk /plus /comma /hyphen /period /slash /zero
X	/one /two /three /four /five /six /seven /eight /nine /colon
X	/semicolon /less /equal /greater /question /at /A /B /C /D /E /F
X	/G /H /I /J /K /L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z
X	/bracketleft /backslash /bracketright /asciicircum /underscore
X	/quoteleft /a /b /c /d /e /f
X	/g /h /i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z
X	/braceleft /bar /braceright /asciitilde /.notdef 
X	/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X	/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X	/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X	/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X	/.notdef /.notdef /.notdef /.notdef /space /exclam /quotedbl
X	/numbersign /dollar /percent /ampersand /quoteright /parenleft
X	/parenright /asterisk /plus /comma /hyphen /period /slash /zero
X	/one /two /three /four /five /six /seven /eight /nine /colon
X	/semicolon /less /equal /greater /question /at /A /B /C /D /E /F
X	/G /H /I /J /K /L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z
X	/bracketleft /backslash /bracketright /asciicircum /underscore
X	/quoteleft /a /b /c /d /e /f
X	/g /h /i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z
X	/braceleft /bar /braceright /asciitilde /.notdef 
X ] def
X
X{
X/$pathprocdict 10 dict def
X/pathproc { % make proc from current path
X	$pathprocdict begin
X	/a 0 { pop pop 3 add } { pop pop 3 add } { 6 { pop } repeat 7 add } { 1 add } pathforall
X	array def
X	/n 0 def
X	{ exch a exch n exch put a exch n 1 add exch put a n 2 add /moveto load put /n n 3 add def }
X	{ exch a exch n exch put a exch n 1 add exch put a n 2 add /lineto load put /n n 3 add def }
X	{ /n n 6 add def
X		6 { /n n 1 sub def a exch n exch put } repeat
X		/n n 6 add def
X		a n /curveto load put % was cvx rather than load
X		/n n 1 add def
X	}
X	{ a n /closepath load put /n n 1 add def }
X	pathforall
X	a cvx
X	end
X} def
X} pop
X/charpath {
X	temp-dict begin
X	charpathdict exch /stroking exch put
X	/met currentfont /Metrics get def
X	/enc currentfont /Encoding get def
X	{
X		dup /ch exch def
X		gsave
X			matrix currentmatrix dup
X			nulldevice setmatrix exch
X			currentpoint translate
X			currentfont /FontMatrix get concat
X%			met enc ch get get 1 get 0 charpathdict /setcharwidth get exec
X			currentfont exch currentfont /BuildChar get
X			end
X			charpathdict begin exec end
X			temp-dict begin
X			.currentcharwidth matrix currentmatrix dup 4 0 put dup 5 0 put
X			transform /y exch def /x exch def
X			setmatrix
X			pathproc
X		grestore
X		currentpoint 3 -1 roll
X		exec
X		moveto x y matrix currentmatrix dup 4 0 put dup 5 0 put itransform  rmoveto
X	} forall
X	end
X} def
X
X/charpathdict 10 dict def
X/temp-dict 10 dict def
X
X/settransfer {
X	temp-dict begin
X		dup /fn exch def
X		/n transfersize def
X		0.0 1 n 1 sub div 1.0 { fn cvr } for n array astore
X		setrealtransfer
X	end
X} def
X
X/setscreen {
X	temp-dict begin
X		/spot exch def
X		2 copy screensize /size exch def
X		2 copy buildscreen /y exch def /x exch def
X		size array dup
X		0 1 size 1 sub {
X			dup dup x exch get exch y exch get /spot load end exec temp-dict begin cvr put dup
X		} for
X		pop
X		/spot load exch setrealscreen
X	end
X} def
X
X/userdict 200 dict def
X
Xuserdict begin % second dictionary to be opened, so cannot be closed by end
X
Xcharpathdict begin
X	/stroke { charpathdict /stroking get { strokepath } if } def
X	/setcharwidth { temp-dict exch /y exch put temp-dict exch /x exch put } def
X	/.currentcharwidth { temp-dict /x get temp-dict /y get } def
X	/setcachedevice { pop pop pop pop setcharwidth } def
X	/fill {} def
X	/eofill {} def
Xend
X
Xmarktype begin
X	/type /marktype def
X	/== { pop (MARK) print } def
Xend
X
Xarraytype begin
X	/type /arraytype def
X	/== {
X		dup xcheck dup {({ )} {([ )} ifelse print exch
X		{ == ( ) print } forall
X		{(})} {(])} ifelse print
X	} def
Xend
X
Xbooleantype begin
X	/type /booleantype def
X	/== { 5 string cvs print } def
Xend
X
Xconditiontype begin
X	/type /conditiontype def
X	/== { pop (CONDITION type - you should never see this!) print } def
Xend
X
Xdicttype begin
X	/type /dicttype def
X	/== {
X		(< ) print
X		{ exch == (,) print == ( ) print } forall
X		(>) print
X	} def
Xend
X
Xfiletype begin
X	/type /filetype def
X	/== { pop (FILE) print } def
Xend
X
Xintegertype begin
X	/type /integertype def
Xend
X
Xnametype begin
X	/type /nametype def
Xend
X
Xnulltype begin
X	/type /nulltype def
X	/== { pop (NULL) print } def
X	/cvs { exch pop (NULL) exch cvs } def
Xend
X
Xoperatortype begin
X	/type /operatortype def
Xend
X
Xrealtype begin
X	/type /realtype def
Xend
X
Xstringtype begin
X	/type /stringtype def
Xend
X
Xfonttype begin
X	/type /fonttype def
X	/== { pop (FONTID) print } def
Xend
X
X/A4-300 {
X	5 dict begin
X	/sf 1.13889 300 82 div mul def
X	/m [sf 0 0 sf neg 0 0] def
X	/f m 0 get def
X	/h 11 72 mul f mul cvi def
X	/w 8.25 72 mul f mul 8 div cvi def
X	m 5 h put
X	m w h [] framedevice
X	end
X} def
X
X/A4 {
X	5 dict begin
X	/sf 1.13889 def
X	/m [sf 0 0 sf neg 0 0] def
X	/f m 0 get def
X	/h 11 72 mul f mul cvi def
X	/w 8.25 72 mul f mul 8 div cvi def
X	m 5 h put
X	m w h [] framedevice
X	end
X} def
X
X/A4-x {
X	5 dict begin
X	/m [1.13889 .75 mul 0 0 -1.13889 .75 mul 0 0] def
X	/f m 0 get def
X	/h 11 72 mul f mul cvi def
X	/w 8.25 72 mul f mul 8 div cvi def
X	m 5 h put
X	m w h [] framedevice
X	end
X} def
X
X/A5 {
X	5 dict begin
X	/m [1.13889 0 0 -1.13889 0 0] def
X	/f m 0 get def
X	/h 8.25 72 mul f mul cvi def
X	/w 11.75 2 div 72 mul f mul 8 div cvi def
X	m 5 h put
X	m w h [] framedevice
X	end
X} def
X
X/L4 {
X	5 dict begin
X	/m [1.13889 0 0 -1.13889 0 0] def
X	/f m 0 get def
X	/h 8.25 72 mul f mul cvi def
X	/w 11.75 72 mul f mul 8 div cvi def
X	[ 0 f f 0 0 0] w h [] framedevice
X	end
X} def
X
X/ascii-set ( !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~) def
X
X% end of definitions
X{} settransfer
X20 0.0 { dup mul exch dup mul add 1 sub } setscreen
X
X0 setgray
X
X1 setflat
X
X1 setstrokemethod
X
X(font-map) lib run
X
X150000 100 2000 setcache 2000 setcachelimit
X
X/Times-Roman findfont 10 scalefont setfont
X
Xenableinterrupts
END_OF_FILE
if test 11943 -ne `wc -c <'postscript/psrc'`; then
    echo shar: \"'postscript/psrc'\" unpacked with wrong size!
fi
# end of 'postscript/psrc'
fi
if test -f 'source/dictionary.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/dictionary.c'\"
else
echo shar: Extracting \"'source/dictionary.c'\" \(12534 characters\)
sed "s/^X//" >'source/dictionary.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X
Xextern int SizeUserDict, SizeSysDict;
X
Xstatic Object OpForDict;
X
XObject Absent, Nil, SysDict;
X
XObject DictLookup (), MakeDict (), DictLoad ();
X
Xstatic int LengthDict (), CopyDict (), forDict (), ForDict (), PutDict (), GetDict ();
Xstatic int PDict (), PBegin (), PEnd (), PDef (), PStore (), PKnown (), PLoad ();
Xstatic int PrCheck (), PwCheck (), PReadOnly (), EqDict (); 
Xstatic int PWhere (), PMaxLength (), PCurrentDict (); 
X
Xstatic int hash_tries = 0, hash_collisions = 0, hash_attempts = 0;
Xstatic int PHashStats (), PDictHash ();
X
XInitDictionary ()
X {
X	
X	SysDict 	= MakeDict (SizeSysDict);
X	
X	Absent	= MakeObject (Condition);
X	
X 	OpForDict	= MakeOp ("(foralldict)", forDict, 0, 2, 3, 5);
X 	
X 	Install ("systemdict",	SysDict);
X	
X	InstallOp ("dict",	PDict,		1, 1, 0, 0, Integer);
X	InstallOp ("begin",	PBegin,		1, 0, 0, 0, Dictionary);
X	InstallOp ("end",	PEnd,		0, 0, 0, 0);
X	InstallOp ("def",	PDef,		2, 0, 0, 0, Poly, Poly);
X	InstallOp ("store",	PStore,		2, 0, 0, 0, Poly, Poly);
X	InstallOp ("known",	PKnown,		2, 1, 0, 0, Dictionary, Poly);
X	InstallOp ("load",	PLoad,		1, 1, 0, 0, Poly);
X	InstallOp ("where",	PWhere,		1, 2, 0, 0, Poly);
X	InstallOp ("maxlength",	PMaxLength,	1, 1, 0, 0, Dictionary);
X	InstallOp ("currentdict",PCurrentDict,	0, 1, 0, 0);
X	InstallOp ("hashstats", PHashStats,	0, 0, 0, 0);
X	InstallOp ("dicthash", 	PDictHash,	1, 0, 0, 0, Dictionary);
X	
X	TypeInstallOp (Dictionary, "eq", 	EqDict,		2, 1, 0, 0, Dictionary, Dictionary);
X	TypeInstallOp (Dictionary, "put", 	PutDict,	3, 0, 0, 0, Dictionary, Poly, Poly);
X	TypeInstallOp (Dictionary, "get", 	GetDict,	2, 1, 0, 0, Dictionary, Poly);
X	TypeInstallOp (Dictionary, "length", 	LengthDict,	1, 1, 0, 0, Dictionary);
X	TypeInstallOp (Dictionary, "copy", 	CopyDict,	2, 0, 0, 0, Dictionary, Dictionary);
X	TypeInstallOp (Dictionary, "forall", 	ForDict,	2, 0, 0, 4, Dictionary, Array);
X 	TypeInstallOp (Dictionary, "readonly", 	PReadOnly,	1, 1, 0, 0, Dictionary);
X 	TypeInstallOp (Dictionary, "rcheck", 	PrCheck,	1, 1, 0, 0, Dictionary);
X 	TypeInstallOp (Dictionary, "wcheck", 	PwCheck,	1, 1, 0, 0, Dictionary);
X		
X	TypeInstallOp (Null, "eq", EqTrue, 2, 1, 0, 0, Null, Null);
X }
X
XType MakeType (size) int size;
X {
X	Type dict;
X	int i;
X	struct dict_entry *hash;
X	
X	dict = (struct dict_struct *) Malloc ((unsigned) sizeof (struct dict_struct));
X	dict->dict_size = size;
X	dict->dict_fill = 0;
X	dict->dict_flags = READABLE | WRITEABLE;
X	dict->dict_body = hash = (struct dict_entry *) Malloc ((unsigned) sizeof (struct dict_entry) * size);
X	
X	for (i = 0; i < size; i++)
X		hash[i].entry_key = Nil;
X	return dict;
X }
X
Xvoid EmptyDict (dict) Type dict;
X {
X 	int i, size = dict->dict_size;
X 	struct dict_entry *hash = dict->dict_body;
X	
X	for (i = 0; i < size; i++)
X		hash[i].entry_key = Nil;
X }
X#ifdef notdef
XType TypeOf (item) Object item;
X {
X 	return item.type;
X }
X#endif
XObject MakeDict (size) int size;
X {
X	Object res;
X	
X	res = MakeObject (Dictionary);
X	res.u.Dictionary = MakeType (size);
X	return res;
X }
X
XObject DictFrom (dict) Type dict;
X {
X 	Object res;
X 	
X 	res = MakeObject (Dictionary);
X 	res.u.Dictionary = dict;
X 	return res;
X }
X
X/*ARGSUSED*/
Xint EqTrue (a, b) Object a, b;
X {
X 	return Push (OpStack, True);
X }
X
Xstatic Type Body (item) Object item;
X {
X	return item.u.Dictionary;
X }
X
XType BodyDict (item) Object item;
X {
X	return item.u.Dictionary;
X }
X
Xstatic int PHashStats ()
X {
X 	extern int name_tries, name_hits;
X 	
X 	printf ("Attempts = %d, Successs = %d, Collisions = %d\n", hash_attempts, hash_tries, hash_collisions);
X  	printf ("Name tries = %d, Name hits = %d\n", name_tries, name_hits);
X	return TRUE;
X }
X
Xstatic int PDictHash (dict) Object dict;
X {
X	struct dict_entry *hash = Body (dict)->dict_body;
X 	int i, l = Body (dict)->dict_size;
X 	
X 	for (i = 0; i < l; i++)
X 		if (TypeOf (hash[i].entry_key) == Null)
X 			putchar (' ');
X 		else
X 			putchar ('@');
X 	putchar ('\n');
X 	return TRUE;
X }
X
Xstatic int EqDict (a, b) Object a, b;
X {
X 	return Push (OpStack, MakeBoolean (Body (a) == Body (b)));
X }
X
Xint Equal (a, b) Object a, b;
X {
X	return TypeOf (a) == TypeOf (b) &&
X		a.Length == b.Length &&
X		(a.u.Integer == b.u.Integer || TypeOf (a) == Array && a.Length == 0);
X }
X
Xstatic DictReplace (hash, key, value, size, h) struct dict_entry *hash; Object key, value; int size, h;
X {
X 	int i;
X 	
X 	for (i = h;;)
X	 {
X	 	if (TypeOf (hash[i].entry_key) == Null)
X	 		return FALSE;
X	 	if (Equal (key, hash[i].entry_key))
X	 	 {
X			hash[i].entry_value = value;
X			return TRUE;
X		 }
X		if (++i == size)
X			i = 0;
X		if (i == h)
X			return FALSE;
X	 }
X }
X
Xstatic DictAddition (dict, hash, key, value, size, h)
X		struct dict_struct *dict; struct dict_entry *hash; Object key, value; int size, h;
X {
X 	int i;
X 	
X	for (i = h;;)
X	 {
X	 	if (TypeOf (hash[i].entry_key) == Null)
X		 {
X			hash[i].entry_value = value;
X			hash[i].entry_key = key;
X			if (TypeOf (key) != Null)
X				++dict->dict_fill;
X			return TRUE;
X		 }
X		if (++i == size)
X			i = 0;
X		if (i == h)
X			return FALSE;
X	 }
X }
X
XTypeInstall (dict, name, value) Type dict; char *name; Object value;
X {
X	struct dict_entry *hash = dict->dict_body;
X	int h, size = dict->dict_size;
X	Object key;
X	
X	key = NameFrom (name);
X	
X	PanicIf (size == 0, "dictionary full in Install");
X/*	h = BodyInteger (key) % size;	*/
X	h = (key.Length + BodyInteger (key) + (int) TypeOf (key)) % size;
X	if (TypeOf (key) == String)
X		key = Cvn (key);
X	if (DictReplace (hash, key, value, size, h))
X		return;
X	if (DictAddition (dict, hash, key, value, size, h))
X		return;
X	Panic ("dictionary full in Install");
X }
X
XDictStore (dict, key, value) Object dict, key, value;
X {
X	struct dict_entry *hash = Body (dict)->dict_body;
X	int h, size = Body (dict)->dict_size;
X	
X	PanicIf (size == 0, "dictionary full in DictStore");
X/*	h = BodyInteger (key) % size;	*/
X	h = (key.Length + BodyInteger (key) + (int) TypeOf (key)) % size;
X	if (TypeOf (key) == String)
X		key = Cvn (key);
X	if (DictReplace (hash, key, value, size, h))
X		return;
X	if (DictAddition (Body (dict), hash, key, value, size, h))
X		return;
X	Panic ("dictionary full in DictStore");
X }
X
XInstall (key, value) char *key; Object value;
X {
X	DictStore (SysDict, NameFrom (key), value);
X }
X
Xstatic Object DictFind (hash, key, size) struct dict_entry *hash; Object key; int size;
X {
X 	int i, h;
X 	
X 	++hash_attempts;
X 	
X 	if (size == 0)
X 		return Absent;
X 	if (TypeOf (key) == String)
X		key = Cvn (key);
X/*	h = BodyInteger (key) % size;	*/
X	h = (key.Length + BodyInteger (key) + (int) TypeOf (key)) % size;
X	for (i = h;;)
X	 {
X	 	if (TypeOf (hash[i].entry_key) == Null)
X	 		return Absent;
X	 	if (Equal (key, hash[i].entry_key))
X	 	 {
X			++hash_tries;
X			return hash[i].entry_value;
X		 }
X		if (++i == size)
X			i = 0;
X		if (i == h)
X			break;
X		++hash_collisions;
X	 }
X	return Absent;
X }
X
XObject DictLoad (dict, key) Object dict, key;
X {
X	return DictFind (Body (dict)->dict_body, key, Body (dict)->dict_size);
X }
X
XObject Lookup (dict, key) Type dict; Object key;
X {
X	return DictFind (dict->dict_body, key, dict->dict_size);
X }
X
XObject Load (key) Object key;
X {
X 	int i;
X 	
X 	for (i = Height (DictStack) - 1; i >= 0; i--)
X 	 {
X 	 	Object res;
X 	 	
X 	 	res = DictLoad (DictStack->stack_body[i], key);
X		if (TypeOf (res) != Condition)
X			return res;
X	 }
X	return Absent;
X }
X
Xstatic int ForDict (dict, proc) Object dict, proc;
X {
X 	VOID Push (ExecStack, dict);
X 	VOID Push (ExecStack, MakeInteger (0));
X 	VOID Push (ExecStack, proc);
X	VOID Push (ExecStack, OpForDict);
X	
X	return TRUE;
X }
X
Xstatic int forDict () 
X {
X 	Object dict, index, proc, t; /* VAX Compiler Broken. SUN optimiser broken */
X 	int i;
X 	
X 	proc =	Pop (ExecStack);
X 	index =	Pop (ExecStack);
X 	dict =	Pop (ExecStack);
X 	
X 	for (i = BodyInteger (index); ; i++)
X 	 {
X 		if (i >= maxDict (dict))
X 			return TRUE;
X 		t = Body (dict)->dict_body[i].entry_key;
X 		if (TypeOf (t) != Null)
X 			break;
X 	 }
X 	VOID Push (ExecStack, dict);
X 	VOID Push (ExecStack, MakeInteger (i + 1));
X 	VOID Push (ExecStack, proc);
X 	VOID Push (ExecStack, OpForDict);
X 	VOID Push (ExecStack, proc);
X 	
X 	VOID Push (OpStack, t = Body (dict)->dict_body[i].entry_key);
X 	VOID Push (OpStack, t = Body (dict)->dict_body[i].entry_value);
X 	return TRUE;
X }
X	
Xstatic int GetDict (object, key) Object object, key;
X {
X 	Object res;
X 	
X	res = DictLoad (object, key);
X	if (TypeOf (res) != Condition)
X		return Push (OpStack, res);
X	else
X	 	return Error (PUndefined);
X }
X
Xstatic int PutDict (object, key, value) Object object, key, value;
X {
X	if (lengthDict (object) == maxDict (object))
X	 {
X	 	Object t;	/* SUN optimiser broken */
X	 	
X	 	t = DictLoad (object, key);
X		if (TypeOf (t) == Condition)
X	 		return Error (PDictFull);
X	 }
X	DictStore (object, key, value);
X	return TRUE;
X }
X
Xstatic int CopyDict (object1, object2) Object object1, object2;
X {
X	if (lengthDict (object1) <= maxDict (object2) && lengthDict (object2) == 0)
X	 {
X		copyDict (object1, object2);
X		VOID Push (OpStack, object2);
X		return TRUE;
X	 }
X	return Error (PRangeCheck);
X }
X
Xint copyDict (from, to) Object from, to;
X {
X 	int i, l = maxDict (from);
X 	struct dict_entry *body = Body (from)->dict_body;
X 	
X 	for (i = 0; i < l; i++)
X 		if (TypeOf (body[i].entry_key) != Null)
X 			DictStore (to, body[i].entry_key, body[i].entry_value);
X }
X
Xstatic int PDict (size) Object size;
X {
X 	if (BodyInteger (size) < 0)
X 		return Error (PRangeCheck);
X	else
X		return Push (OpStack, MakeDict (BodyInteger (size)));
X }
X
Xstatic int PBegin (dict) Object dict;
X {
X 	
X 	if (Height (DictStack) == MaxStack (DictStack))
X 		return Error (PDictOverflow);
X 	else
X 	 {
X 	 	VOID Push (DictStack, dict);
X 	 	return TRUE;
X 	 }
X }
X
Xstatic int PEnd ()
X {
X 	if (Height (DictStack) == 2)
X 	 	return Error (PDictUnderflow);
X 	else
X 		VOID Pop (DictStack);
X 	return TRUE;
X }
X
Xstatic int PDef (key, value) Object key, value;
X {
X 	Object dict,t ;	/* SUN optimiser broken */
X 	
X 	if (!wCheck (dict = Top (DictStack)))
X  		return Error (PInvAccess);
X 	else if (maxDict (dict) == lengthDict (dict) && (t = DictLoad (dict, key), TypeOf (t)) == Condition)
X 		return Error (PDictFull);
X 	else
X 	 {
X 	 	DictStore (dict, key, value);
X 	 	return TRUE;
X 	 }
X }
X
Xstatic int PStore (key, value)	Object key, value;
X {
X 	Object dict, t;	/* SUN optimiser broken */
X 	
X 	dict = Where (key);	/* SUN optimiser broken */
X 	if (TypeOf (dict) == Condition)
X 		dict = Top (DictStack);
X 	if (TypeOf (key) == Null)
X 		return Error (PTypeCheck);
X 	else if (!wCheck (dict))
X 		return Error (PInvAccess);
X 	else if (maxDict (dict) == lengthDict (dict) && (t = DictLoad (dict, key), TypeOf (t)) == Condition)
X 		return Error (PDictFull);
X 	else
X 	 {
X 	 	DictStore (dict, key, value);
X 	 	return TRUE;
X 	 }
X }
X
Xstatic int PKnown (dict, key) Object dict, key;
X {
X 	Object t;
X 	
X 	t = DictLoad (dict, key);
X 	return Push (OpStack, MakeBoolean (TypeOf (t) != Condition));
X }
X
Xstatic int PLoad (key) Object key;
X {
X 	Object res;
X 	
X  	res = Load (key);
X 	if (TypeOf (res) == Condition)
X 		return Error (PUndefined);
X 	else if (TypeOf (key) == Null)
X 		return Error (PTypeCheck);
X 	else
X 		return Push (OpStack, res);
X }
X
Xstatic int PWhere (key) Object key;	/* key --- dict true */
X				/* key --- false */
X {
X 	Object where;
X 	
X	if (TypeOf (key) == Null)
X 		return Error (PTypeCheck);
X 	where = Where (key);
X 	if (TypeOf (where) == Condition)
X 		return Push (OpStack, False);
X 	else if (!rCheck (where))
X 		return Error (PInvAccess);
X 	else
X	 	return Push (OpStack, where), Push (OpStack, True);
X }
X
Xint maxDict (dict) Object dict;
X {
X 	return Body (dict)->dict_size;
X }
X
Xstatic int PMaxLength (dict) Object dict;
X {
X 	return Push (OpStack, MakeInteger (maxDict (dict)));
X }
X
Xint lengthDict (dict) Object dict;
X {
X 	return Body (dict)->dict_fill;
X }
X
Xstatic int LengthDict (dict) Object dict;
X {
X 	return Push (OpStack, MakeInteger (lengthDict (dict)));
X }
X
Xstatic int PCurrentDict ()
X {
X  	return Push (OpStack, Top (DictStack));
X }
X
Xstatic int PReadOnly (item) Object item;
X {
X 	return Push (OpStack, ReadOnly (item));
X }
X
Xstatic int PrCheck (v) Object v;
X {
X 	return Push (OpStack, MakeBoolean (rCheck (v)));
X }
X
Xstatic int PwCheck (v) Object v;
X {
X 	return Push (OpStack, MakeBoolean (wCheck (v)));
X }
END_OF_FILE
if test 12534 -ne `wc -c <'source/dictionary.c'`; then
    echo shar: \"'source/dictionary.c'\" unpacked with wrong size!
fi
# end of 'source/dictionary.c'
fi
if test -f 'source/pat.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/pat.c'\"
else
echo shar: Extracting \"'source/pat.c'\" \(13056 characters\)
sed "s/^X//" >'source/pat.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X
X#include "graphics.h"
X
X#define MAXPATHELEMENTS 1500
X
Xstatic struct path_element *free_pelem = NULL;
X 
XPath NewPath ();
XPoint NewPoint (), IntToExt ();
X
XHardPoint NewHardPoint (), ExtToInt ();
X
XPath NewElem (type) enum pelem_type type;
X {
X 	Path res = free_pelem;
X 	
X 	if (res != NULL)
X 		free_pelem = res->next;
X	else
X	 	res = (Path) Malloc (sizeof (struct path_element));
X 	res->ptype = type;
X
X 	return res;
X }
X
Xvoid ElemFree (p) Path p;
X {
X 	PanicIf (p == NULL, "ElemFree given NULL");
X 	p->next = free_pelem;
X 	free_pelem = p;
X }
X
XPath ElemCopy (p) Path p;
X {
X	Path res = NewElem (p->ptype);
X	res->pe = p->pe;
X 	return res;
X }
X
XPath NewMove (type, point) enum pelem_type type; HardPoint point;
X {
X 	Path res = NewElem (type);
X 	
X 	res->pe.point = point;
X 	
X 	return res;
X }
X
XPath NewPath ()
X {
X 	Path res = NewElem (EHeader);
X 	
X 	return res->next = res->last = res;
X }
X
XPathFree (p) Path p;
X {
X 	while (!EmptyPath (p))
X 		PathDelete (p);
X 	ElemFree (p);
X }
X
XPath PathCopy (path) Path path;
X {
X 	Path p, new = NewPath ();
X 	
X 	for (p = path->next; p != path; p = p->next)
X 	 	PathInsert (new, ElemCopy (p));
X 	return new;
X }
X
Xenum pelem_type CurEType (p) Path p;
X {
X 	return p->last->ptype;
X }
X	
Xint EmptyPath (p) Path p;
X {
X 	return p->next == p;
X }
X
XPathDelete (p) Path p;
X {
X	Path res = p->last;
X	
X 	PanicIf (p->next == p, "delete from empty path");
X 	ElemFree (PathRemove (res));
X 	
X 	return TRUE;
X }
X
XPath PathRemove (p) Path p;
X {
X 	p->last->next = p->next;
X 	p->next->last = p->last;
X 	
X 	return p;
X }
X
XPathInsert (p, i) Path p, i;
X {
X 	PanicIf (i == NULL, "PathInsert given NULL");
X 	i->next = p;
X 	i->last = p->last;
X 	p->last->next = i;
X 	p->last = i;
X }
X
Xint MoveTo (p, np) Path p; HardPoint np;
X {
X 	Path res = NewMove (EMove, np);
X 	
X 	if (res == NULL)
X 		return Error (PLimitCheck);
X 	if (!EmptyPath (p) && CurEType (p) == EMove)
X 	 	PathDelete (p);
X 	gstate->cp_defined = TRUE;
X 	gstate->cp = np;
X 	PathInsert (p, res);
X 	return TRUE;
X }
X
Xint LineTo (p, np) Path p; HardPoint np;
X {
X 	Path res = NewMove (ELine, np);
X 	
X 	if (res == NULL)
X 		return Error (PLimitCheck);
X  	gstate->cp = np;
X 	PathInsert (p, res);
X 	return TRUE;
X }
X
Xint CurveTo (p, p0, p1, p2) Path p; HardPoint p0, p1, p2;
X {
X 	Path new = NewElem (ECurve);
X 	
X 	if (new == NULL)
X 		return Error (PLimitCheck);
X 	new->pe.curve.x0 = p0;
X 	new->pe.curve.x1 = p1;
X 	new->pe.curve.x2 = p2;
X 	gstate->cp = p2;
X 	PathInsert (p, new);
X 	return TRUE;
X }
X
Xfloat Normalise (ang) float ang;
X {
X 	while (ang < -PI || ang > PI)
X 		if (ang < PI)
X 			ang += 2 * PI;
X 		else
X 			ang -= 2 * PI;
X	return ang;
X  }
X
X/*
X * In ArcBit, Y = 0 goes through P0, and the centre is at the origin.
X *
X */
X
Xstatic int ArcBit (p, dir, radius, ang) Path p; int dir; float radius, ang;
X {
X 	HardPoint P3;
X 	Point p3;
X 	float x, y;
X 	
X 	gstate->CTM = Rotate (gstate->CTM, dir * ang / 2);
X 	if (dir < 0)
X 		gstate->CTM = MatMult (NewMatrix (1.0, 0.0, 0.0, -1.0, 0.0, 0.0), gstate->CTM);
X 	
X 	gstate->CTM = Rotate (gstate->CTM, ang / 2);
X 	P3 = ExtToInt (NewPoint (radius, 0.0));
X 	gstate->CTM = Rotate (gstate->CTM, -ang / 2);
X 	
X 	p3 = IntToExt (P3);
X 	x = (4 * radius - p3.x) / 3;
X 	y = p3.y * (radius / cos (ang / 2) - x) / p3.x;
X	
X 	return CurveTo (p, ExtToInt (NewPoint (x, -y)), ExtToInt (NewPoint (x, y)), P3);
X }
X
Xint Arc (p, dir, centre, radius, ang1, ang2) Path p; int dir; Point centre; float radius, ang1, ang2;
X {
X 	Matrix old, cent;
X 	int res;
X 	float diff = dir > 0 ? ang2 - ang1 : ang1 - ang2;
X 	float ang;
X	
X	while (diff < 0)
X		diff += 2 * PI;
X	old = gstate->CTM;
X	cent = Translate (old, centre.x, centre.y);
X 	for (ang = 0; ang <= diff - PI / 2; ang += PI / 2)
X	 {
X	 	gstate->CTM = Rotate (cent, ang1 + ang * dir);
X 		if (!ArcBit (p, dir, radius, PI / 2))
X 		 {
X 		 	gstate->CTM = old;
X 			return FALSE;
X 		 }
X 	 }
X 	gstate->CTM = Rotate (cent, ang1 + ang * dir);
X 	res = ArcBit (p, dir, radius, diff - ang);
X 	gstate->CTM = old;
X 	return res;
X }
X
XArcTo (path, cp, x1, y1, x2, y2, r, xt1, yt1, xt2, yt2) 
X		Path path;
X		HardPoint cp;
X		float x1, y1, x2, y2, r;
X		float *xt1, *yt1, *xt2, *yt2;
X {
X 	Point p0;
X 	float x0, y0, x3, y3, dist,
X 		ang, anga, angb, absang, delta;
X 	int dir;
X 	
X 	p0 = IntToExt (cp); x0 = p0.x, y0 = p0.y;
X 	angb = atan2 (y2 - y1, x2 - x1);
X 	if (angb <= 0)
X 		angb += 2 * PI;
X 	anga = atan2 (y0 - y1, x0 - x1);
X 	if (anga <= 0)
X 		anga += 2 * PI;
X 	ang = angb - anga;
X 	if (ang <= 0)
X 		ang += 2 * PI;
X 	if (ang >= 2 * PI)
X 		ang -= 2 * PI;
X 	if (ang >= PI)
X 		ang -= 2 * PI;
X 	dir = ang <= 0 ? 1 : -1;
X 	dist = fabs (r / sin (ang / 2));
X 	absang = ang / 2 + anga;
X 	x3 = dist * cos (absang) + x1;
X 	y3 = dist * sin (absang) + y1;
X 	absang += PI;
X 	delta = (ang + (ang > 0 ? - PI : PI)) / 2;
X	*xt1 = x3 + r * cos (absang - delta);
X	*yt1 = y3 + r * sin (absang - delta);
X	*xt2 = x3 + r * cos (absang + delta);
X	*yt2 = y3 + r * sin (absang + delta);
X	LineTo (path, ExtToInt (NewPoint (*xt1, *yt1)));
X	Arc (path,
X		dir,
X		NewPoint (x3, y3),
X		r, absang - delta,
X		absang + delta);
X	return TRUE;
X }
X
Xint ClosePath (p) Path p;
X {
X 	Path pp, res = NewMove (EClose, ExtToInt (NewPoint (0.0, 0.0)));
X 	
X 	if (res == NULL)
X 		return Error (PLimitCheck);
X 	if (!gstate->cp_defined)
X 		return TRUE;
X 	for (pp = p; pp->ptype != EMove; pp = pp->last)
X 		;
X 	PathInsert (p, res);
X 	VOID MoveTo (p, pp->pe.point);
X	return TRUE;
X }
X
XPoint NewPoint (x, y) float x, y;
X {
X 	Point res;
X 	
X 	res.x = x; res.y = y;
X 	return res;
X }
X
XHardPoint NewHardPoint (x, y) float x, y;
X {
X 	HardPoint res;
X 	
X 	res.hx = x; res.hy = y;
X 	return res;
X }
X
XHardPoint MoveHardPoint (a, b) HardPoint a, b;
X {
X 	return NewHardPoint (a.hx + b.hx, a.hy + b.hy);
X }
X
XPoint MovePoint (a, b) Point a, b;
X {
X 	return NewPoint (a.x + b.x, a.y + b.y);
X }
X
Xfloat PointX (p) Point p;
X {
X 	return p.x;
X }
X
Xfloat PointY (p) Point p;
X {
X 	return p.y;
X }
X
X/*
X * This algorithm subdivides a Bezier curve.
X * The algorithm is taken from:
X *
X *	"The Beta2-split: A special case of the Beta-spline Curve and
X *	 Surface Representation." B. A. Barsky and A. D. DeRose. IEEE, 1985.
X *
X * A vector of control points W is transformed by two matrices into two
X * Vectors which describe the sub-polygons. This is done twice, once each
X * for the X and Y coordinates. The matrices required for the 'left' and
X * 'Right' sub-polygons are as follows:
X *
X *	 /  1    0    0    0  \			 / 1/8  3/8  3/8  1/8 \
X * W  =	|  1/2  1/2   0    0   |	W  =	|   0   1/4  1/2  1/4  |
X *  L	|  1/4  1/2  1/4   0   |	 R	|   0    0   1/2  1/2  |
X *	 \ 1/8  3/8  3/8  1/8 /			 \  0    0    0    1  /
X *
X * The algorithm subdivides the curve recursively until each sub-polygon
X * is deemed to be flat to within the required tolerance. Flatness is
X * defined as the greater distance of the inner control points (P1 & P2)
X * from the line through the outer ones (P0 & P3):
X *
X *						       P2
X *				       /-------------X
X *	      P1	   ------------    	     |\_
X *	       _X---------/			     |	\_
X *	     _/	|				     |	  \_
X *	   _/	|				     |	    \_
X *       _/	|				     |	      \_
X *     _/	| D1				  D2 |		\_
X *   _/		|				     |		  \_
X *  /		|				     |		    \
X * X-----------------------------------------------------------------X
X * P0
X * 							      P3
X */
X
Xstatic int IsFlat (x0, y0, x1, y1, x2, y2, x3, y3) float x0, y0, x1, y1, x2, y2, x3, y3;
X {
X 	int flatness = gstate->flatness;
X 	float sa, ca, y, O = y3 - y0, A = x3 - x0, H = sqrt (O*O + A*A);
X	
X	if (H == 0)
X		return TRUE;
X 	
X 	sa = O / H, ca = A / H;
X 	y = - sa * (x1 - x0) + ca * (y1 - y0);
X 	if (y > flatness || y < -flatness)
X 		return FALSE;
X 	y =  - sa * (x2 - x0) + ca * (y2 - y0);
X 	return y <= flatness && y >= -flatness;
X }
X
XBezier (x0, y0, x1, y1, x2, y2, x3, y3, flat) int (*flat)(); float x0, y0, x1, y1, x2, y2, x3, y3;
X {
X 	if (IsFlat (x0, y0, x1, y1, x2, y2, x3, y3))
X 		return (*flat) (x0, y0, x3, y3);
X	return Bezier (x0, 					y0,
X		(x0 + x1) / 2, 				(y0 + y1) / 2,
X		(x0 + x2) / 4 + x1 / 2, 		(y0 + y2) / 4 + y1 / 2,
X		(x0 + x3) / 8 + 3 * (x1 + x2) / 8, 	(y0 + y3) / 8 + 3 * (y1 + y2) / 8,
X		flat) &&
X	Bezier ((x0 + x3) / 8 + 3 * (x1 + x2) / 8, 	(y0 + y3) / 8 + 3 * (y1 + y2) / 8,
X		(x1 + x3) / 4 + x2 / 2, 		(y1 + y3) / 4 + y2 / 2,
X		(x2 + x3) / 2, 				(y2 + y3) / 2,
X		x3, 					y3,
X		flat);
X }
X
Xstatic int RevSeg (new, p, next) Path new, next; HardPoint p;
X {
X 	switch (next->ptype)
X 	 {
X 	 	case EClose:
X 	 	case EHeader:
X 	 	case EMove:	return MoveTo (new, p);
X 	 	case ELine:	return LineTo (new, p);
X 	 	case ECurve:	return CurveTo (new, next->pe.curve.x1, next->pe.curve.x0, p);
X 	 }
X	Panic ("RevSeg: unknown pe type");
X	return TRUE;
X }
X
XPath ReversePath (path) Path path;
X {
X  	Path p, new = NewPath (), pnew = new;
X  	int closed = FALSE;
X  	
X 	for (p = path->last; p != path; p = p->last)
X 	 switch (p->ptype)
X 	  {
X 	  	case EClose:
X 	  		closed = TRUE;
X 	  		break;
X 	  	
X 	  	case EMove:
X   	  		if (!RevSeg (new, p->pe.point, p->next))
X  	  		 {
X  	  		 	PathFree (new);
X  	  			return NULL;
X  	  		 }
X 	 		if (closed)
X 	 		 {
X 	 			if (!ClosePath (new))
X  	  			 {
X  	  			 	PathFree (new);
X  	  				return NULL;
X  	  			 }
X  	  		 }
X   	  		new = new->next;
X 	 		closed = FALSE;
X 	  		break;
X  	  		
X	  	case ELine:
X 	  		if (!RevSeg (new, p->pe.point, p->next))
X   	  		 {
X  	  		 	PathFree (new);
X  	  			return NULL;
X  	  		 }
X
X	  		break;
X 	  	
X 	  	case ECurve:
X  	  		if (!RevSeg (new, p->pe.curve.x2, p->next))
X   	  		 {
X  	  		 	PathFree (new);
X  	  			return NULL;
X  	  		 }
X
X	  		break;
X	  	
X	  	default:
X	  		Panic ("ReversePath: unknown element type");
X	  }
X 	 PathFree (p);
X 	 
X 	 return pnew;
X }
X
XPath path;
X
X/*ARGSUSED*/
Xstatic int flatten (x0, y0, x1, y1) float x0, y0, x1, y1;
X {
X	return LineTo (path, NewHardPoint (x1, y1));
X }
X
XPath FlattenPath (arg) Path arg;
X {
X 	Path p, new = NewPath ();
X 	HardPoint lastp;
X
X 	path = new;
X 	for (p = arg->next; p != arg; p = p->next)
X 	 switch (p->ptype)
X 	  {
X 	  	case EMove:
X 	  		lastp = p->pe.point;
X 	  		if (!MoveTo (new, lastp))
X 	  		 {
X 	  		 	PathFree (new);
X 	  			return NULL;
X 	  		 }
X 	  		break;
X 	  		
X 	  	case ELine:
X 	  		lastp = p->pe.point;
X 	  		if (!LineTo (new, lastp))
X 	  		 {
X 	  		 	PathFree (new);
X 	  			return NULL;
X 	  		 }
X 	  		break;
X 	  		
X 	  	case EClose:
X 	  		if (!ClosePath (new))
X  	  		 {
X 	  		 	PathFree (new);
X 	  			return NULL;
X 	  		 }
X	 		break;
X 	 	
X 	 	case ECurve:
X 	 		if (!Bezier (lastp.hx, lastp.hy,
X 	 				p->pe.curve.x0.hx, p->pe.curve.x0.hy,
X 	 				p->pe.curve.x1.hx, p->pe.curve.x1.hy,
X 	 				p->pe.curve.x2.hx, p->pe.curve.x2.hy,
X 	 				flatten))
X  	  		 {
X 	  		 	PathFree (new);
X 	  			return NULL;
X 	  		 }
X	 		lastp = p->pe.curve.x2;
X 	 		break;
X 	 	
X 	 	default:
X 	 		Panic ("Flattenpath discovers unknown path element type");
X 	 		break;
X 	  }
X 	return path;
X }
X
Xint CloseAll (path) Path path;	/* closes all open portions of a path *in place* */
X {
X	Path p;
X	enum pelem_type last_type = EHeader;
X	
X	for (p = path->next; p != path; last_type = p->ptype, p = p->next)
X	 if (p->ptype == EMove && last_type != EClose && last_type != EHeader)
X	 	if (!ClosePath (p))
X	 		return Error (PLimitCheck);
X	 if (last_type == EMove)
X	 	return PathDelete (p);
X	 if (last_type == EHeader || last_type == EClose)
X	 	return TRUE;
X	 return ClosePath (p);
X }
X
XSetPath (p, v) Path *p, v;
X {
X 	PathFree (*p);
X 	*p = v;
X }
X
XBound (left, right, top, bottom, p) float *left, *right, *top, *bottom; HardPoint p;
X {
X	if (p.hx < *left) 	*left 	= p.hx;
X	if (p.hx > *right) 	*right 	= p.hx;
X	if (p.hy < *bottom) 	*bottom = p.hy;
X	if (p.hy > *top) 	*top 	= p.hy;
X }
X
Xint PathBBox (left, right, top, bottom) float *left, *right, *top, *bottom;
X {
X 	Path p;
X 	
X 	if (!gstate->cp_defined || EmptyPath (gstate->path))
X 		return Error (PNoCurrentPoint);
X 	
X 	*left = *right = gstate->cp.hx;
X 	*top = *bottom = gstate->cp.hy;
X 	
X 	for (p = gstate->path->next; p != gstate->path; p = p->next)
X 	 switch (p->ptype)
X 	  {
X 	  	case EMove:
X 	  	case ELine:
X 	  		Bound (left, right, top, bottom, p->pe.point);
X 	  		break;
X 	  	case EClose:
X 	  		break;
X 	  	case ECurve:
X 	  		Bound (left, right, top, bottom, p->pe.curve.x0);
X 	  		Bound (left, right, top, bottom, p->pe.curve.x1);
X 	  		Bound (left, right, top, bottom, p->pe.curve.x2); 
X 	  		break;
X 	  	case EHeader:
X 	  		Panic ("PathBBox, header found.");
X 	  		break;
X 	  	default:
X 	  		Panic ("PathBBox, unknown path element type.");
X 	  		break;
X 	  }
X 	
X 	return TRUE;
X }
X
XUserBound (left, right, top, bottom, p) float *left, *right, *top, *bottom; Point p;
X {
X	if (p.x < *left) 	*left 	= p.x;
X	if (p.x > *right) 	*right 	= p.x;
X	if (p.y < *bottom) 	*bottom = p.y;
X	if (p.y > *top) 	*top 	= p.y;
X }
END_OF_FILE
if test 13056 -ne `wc -c <'source/pat.c'`; then
    echo shar: \"'source/pat.c'\" unpacked with wrong size!
fi
# end of 'source/pat.c'
fi
echo shar: End of archive 10 \(of 18\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
