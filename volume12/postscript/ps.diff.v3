Make sure you have already applied patch 'ps.diff.v2'.

If you already have the file "source/X11.c", move it to a safe place
before applying this patch.

To apply this, you need the 'patch' program which is available from
the comp.sources.unix archives.

Change directories to the top-level postscript directory (the one with
the file "MANIFEST" in it) and apply this patch with the command:

patch -p0 <ps.diff.v3

				_.John G. Myers
				jm36+@andrew.cmu.edu

*** /tmp/CHANGES.JGM.v2	Thu Jul 28 14:59:27 1988
--- ./CHANGES.JGM	Thu Jul 28 15:07:01 1988
***************
*** 60,65 ****
--- 60,80 ----
  
  Added operators letter, note, and legal.
  
+ 			      Version 3:
+ 
+ Bugs fixed:
+ 
+ The fourth parameter to the "framedevice" is no longer ignored.  psrc
+ has been modified so that if a driver defines the postscript operator
+ "outputpage", it will be called instead of the "beep and wait for
+ input" routine when the copypage or showpage command is executed.
+ 
+ Enhancements made:
+ 
+ Barry Shein's speedups have been incorporated.
+ 
+ A version of the X11 driver is included.
+ 
  				John G. Myers
  				jm36@andrew.cmu.edu
  				jgm@k.gp.cs.cmu.edu
diff -cr /usr/tmp/ps/postscript/psrc ./postscript/psrc
*** /usr/tmp/ps/postscript/psrc	Thu Jul 28 14:00:59 1988
--- ./postscript/psrc	Thu Jul 28 14:17:45 1988
***************
*** 69,84 ****
  %/tty (|cat -u </dev/tty) (r) file def
  
  /showpage {
! 	copypage initgraphics
! 	beep print flush
! 	false echo
! 	{ tty read { pop } if } stopped
! 	true echo
! 	not {
! 		erasepage
! 	} if
  } def
  
  /run { { (r) file } stopped { pop stop } if cvx exec } def
  /prompt { (PS>) print } def
  
--- 69,87 ----
  %/tty (|cat -u </dev/tty) (r) file def
  
  /showpage {
! 	copypage initgraphics erasepage
  } def
  
+ systemdict /outputpage known not {
+     /outputpage {
+ 	beep print flush
+   	false echo
+   	{ tty read { pop } if } stopped
+   	true echo
+ 	pop
+     } def
+ } if
+ 
  /run { { (r) file } stopped { pop stop } if cvx exec } def
  /prompt { (PS>) print } def
  
***************
*** 423,429 ****
  	/h 11 72 mul f mul cvi def
  	/w 8.25 72 mul f mul 8 div cvi def
  	m 5 h put
! 	m w h [] framedevice
  	end
  } def
  
--- 426,432 ----
  	/h 11 72 mul f mul cvi def
  	/w 8.25 72 mul f mul 8 div cvi def
  	m 5 h put
! 	m w h /outputpage load framedevice	% jgm
  	end
  } def
  
***************
*** 435,441 ****
  	/h 11 72 mul f mul cvi def
  	/w 8.25 72 mul f mul 8 div cvi def
  	m 5 h put
! 	m w h [] framedevice
  	end
  } def
  
--- 438,444 ----
  	/h 11 72 mul f mul cvi def
  	/w 8.25 72 mul f mul 8 div cvi def
  	m 5 h put
! 	m w h /outputpage load framedevice	% jgm
  	end
  } def
  
***************
*** 446,452 ****
  	/h 11 72 mul f mul cvi def
  	/w 8.25 72 mul f mul 8 div cvi def
  	m 5 h put
! 	m w h [] framedevice
  	end
  } def
  
--- 449,455 ----
  	/h 11 72 mul f mul cvi def
  	/w 8.25 72 mul f mul 8 div cvi def
  	m 5 h put
! 	m w h /outputpage load framedevice	% jgm
  	end
  } def
  
***************
*** 457,463 ****
  	/h 8.25 72 mul f mul cvi def
  	/w 11.75 2 div 72 mul f mul 8 div cvi def
  	m 5 h put
! 	m w h [] framedevice
  	end
  } def
  
--- 460,466 ----
  	/h 8.25 72 mul f mul cvi def
  	/w 11.75 2 div 72 mul f mul 8 div cvi def
  	m 5 h put
! 	m w h /outputpage load framedevice	% jgm
  	end
  } def
  
***************
*** 467,473 ****
  	/f m 0 get def
  	/h 8.25 72 mul f mul cvi def
  	/w 11.75 72 mul f mul 8 div cvi def
! 	[ 0 f f 0 0 0] w h [] framedevice
  	end
  } def
  
--- 470,476 ----
  	/f m 0 get def
  	/h 8.25 72 mul f mul cvi def
  	/w 11.75 72 mul f mul 8 div cvi def
! 	[ 0 f f 0 0 0] w h /outputpage load framedevice % jgm
  	end
  } def
  
***************
*** 480,486 ****
  	/h 11 72 mul f mul cvi def
  	/w 8.5 72 mul f mul 8 div cvi def
  	m 5 h put
! 	m w h [] framedevice
  	end
  } def
  
--- 483,489 ----
  	/h 11 72 mul f mul cvi def
  	/w 8.5 72 mul f mul 8 div cvi def
  	m 5 h put
! 	m w h /outputpage load framedevice
  	end
  } def
  
***************
*** 493,499 ****
  	/h 14 72 mul f mul cvi def
  	/w 8.5 72 mul f mul 8 div cvi def
  	m 5 h put
! 	m w h [] framedevice
  	end
  } def
  
--- 496,502 ----
  	/h 14 72 mul f mul cvi def
  	/w 8.5 72 mul f mul 8 div cvi def
  	m 5 h put
! 	m w h /outputpage load framedevice
  	end
  } def
  
*** /usr/tmp/ps/source/makefile	Thu Jul 28 13:53:39 1988
--- ./source/makefile	Thu Jul 28 15:36:09 1988
***************
*** 2,10 ****
--- 2,20 ----
  	integer.o main.o math.o misc.o name.o operator.o\
  	poly.o property.o real.o save.o stack.o string.o unix.o
  LIBS=libww.a -lsuntool -lsunwindow -lpixrect -g
+ XLIB=/usr/lib/libX11.a
  GRAPHICS=cache.o colour.o device.o fill.o font.o gsave.o image.o mat.o matrix.o\
  	pat.o path.o state.o stroke.o
  
+ SOURCES=array.c boolean.c config.c control.c dictionary.c file.c\
+ 	integer.c main.c math.c misc.c name.c operator.c\
+ 	poly.c property.c real.c save.c stack.c string.c unix.c\
+ 	cache.c colour.c device.c fill.c font.c gsave.c image.c mat.c matrix.c\
+ 	pat.c path.c state.c stroke.c
+ LINT=lint
+ LFLAGS= -lm
+ 
+ 
  # For SUN with 68881
  #CFLAGS=-O -f68881
  
***************
*** 11,39 ****
  # For others
  CFLAGS=-O
  
! #default: sunPS
  
  PS:	$(OBJECTS) $(GRAPHICS) hard.o canon.a
! 	cc $(CFLAGS)  $(OBJECTS) $(GRAPHICS) hard.o canon.a -lm `libs` -o PS
  
  sunPS:	$(OBJECTS) $(GRAPHICS) pixrect.o canon.a
! 	cc $(CFLAGS)  $(OBJECTS) $(GRAPHICS) pixrect.o canon.a -lm -lpixrect -o sunPS
  
  CPS:	$(OBJECTS) $(GRAPHICS) colour-ww.o trapezoid.o canon.o
! 	cc $(CFLAGS)  $(OBJECTS) $(GRAPHICS) colour-ww.o canon.o trapezoid.o -lm `libs` -o CPS
  
  postscript:	$(OBJECTS) $(GRAPHICS) adapter.o protocol.o
! 	cc $(CFLAGS) $(OBJECTS) $(GRAPHICS) adapter.o protocol.o -lm -o postscript
  
  XPS:	$(OBJECTS) $(GRAPHICS) X.o
! 	cc $(CFLAGS)  $(OBJECTS) $(GRAPHICS) X.o -lm -lX -o XPS
  
  canon.a:	canon.o screen.o trapezoid.o paint.o
  	ar ruv canon.a canon.o screen.o trapezoid.o paint.o
  	ranlib canon.a
  
  viewer:	protocol.o viewer.o hard.o canon.a
! 	cc protocol.o viewer.o hard.o canon.a `libs` -o viewer
  
  all:	PS postscript viewer
  
--- 21,56 ----
  # For others
  CFLAGS=-O
  
! default: sunPS
  
+ xps: $(OBJECTS) $(GRAPHICS) X11.o canon.a $(XLIB)
+ 	rm -f xps
+ 	$(CC) -o xps $(CFLAGS) $(OBJECTS) $(GRAPHICS) X11.o canon.a -lm $(XLIB)
+ 
  PS:	$(OBJECTS) $(GRAPHICS) hard.o canon.a
! 	$(CC) $(CFLAGS)  $(OBJECTS) $(GRAPHICS) hard.o canon.a -lm `libs` -o PS
  
  sunPS:	$(OBJECTS) $(GRAPHICS) pixrect.o canon.a
! 	$(CC) $(CFLAGS)  $(OBJECTS) $(GRAPHICS) pixrect.o canon.a -lm -lpixrect -o sunPS
  
  CPS:	$(OBJECTS) $(GRAPHICS) colour-ww.o trapezoid.o canon.o
! 	$(CC) $(CFLAGS)  $(OBJECTS) $(GRAPHICS) colour-ww.o canon.o trapezoid.o -lm `libs` -o CPS
  
  postscript:	$(OBJECTS) $(GRAPHICS) adapter.o protocol.o
! 	$(CC) $(CFLAGS) $(OBJECTS) $(GRAPHICS) adapter.o protocol.o -lm -o postscript
  
  XPS:	$(OBJECTS) $(GRAPHICS) X.o
! 	$(CC) $(CFLAGS)  $(OBJECTS) $(GRAPHICS) X.o -lm -lX -o XPS
  
+ lint:
+ 	$(LINT) $(LFLAGS) $(SOURCES) $(LINTFILTER)
+ 
  canon.a:	canon.o screen.o trapezoid.o paint.o
  	ar ruv canon.a canon.o screen.o trapezoid.o paint.o
  	ranlib canon.a
  
  viewer:	protocol.o viewer.o hard.o canon.a
! 	$(CC) protocol.o viewer.o hard.o canon.a `libs` -o viewer
  
  all:	PS postscript viewer
  
***************
*** 44,50 ****
  orion:	orion.o installorion orionlib
  
  X.o:	
! 	cc -c X.c
  
  wwlib:
  	if [ -f libww.a ]; \
--- 61,67 ----
  orion:	orion.o installorion orionlib
  
  X.o:	
! 	$(CC) -c X.c
  
  wwlib:
  	if [ -f libww.a ]; \
*** /dev/null	Thu Jul 28 10:26:48 1988
--- ./source/X11.c	Wed Jul 27 18:15:31 1988
***************
*** 0 ****
--- 1,667 ----
+ /*
+  * Copyright (C) Rutherford Appleton Laboratory 1987
+  * 
+  * This source may be copied, distributed, altered or used, but not sold for profit
+  * or incorporated into a product except under licence from the author.
+  * It is not in the public domain.
+  * This notice should remain in the source unaltered, and any changes to the source
+  * made by persons other than the author should be marked as such.
+  * 
+  *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
+  */
+ #include "main.h"
+ #include "graphics.h"
+ #include <X11/Xlib.h>
+ #include <X11/Xutil.h>
+ #include <X11/Xatom.h>
+ #include <stdio.h>
+ #include "canon.h"
+ 
+ char *DriverType = "X11"; /* jgm */
+ 
+ static void Punt(str)
+ char *str;
+ {
+     fprintf(stderr, "%s\n", str);
+     exit(1);
+ }
+ 
+ 
+ 
+ static Display *dpy;
+ 
+ typedef struct _HardwareRec {
+     Drawable w;
+ } HardwareRec, *Hardware;
+ 
+ #ifdef CANON
+ struct hardware
+ {
+     /*
+      * Each driver is expected to provide its own definition of this
+      * structure.  It is only ever used as a pointer and is never dereferenced
+      * outside the driver.
+      */
+     int pad;
+ };
+ #endif CANON
+ 
+ /*
+  * This file describes the interface that PostScript requires to the graphics
+  * system at Version 1.4.
+  * 	
+  * ''Hardware'' in this context refers to a pointer to windows and/or bitmaps
+  * and is the lowest level of access that PostScript is interested in. Any
+  * Hardware parameter may be expected to be NULL.
+  */
+ 
+ /********************* CREATION OF WINDOWS AND BITMAPS *******************/
+ 
+ #define SCREEN 0		/* What to use as our screen number. */
+ #define MIN(x, y)	(((x) < (y)) ? (x) : (y))
+ 
+ static GC fillgc[16];
+ 
+ struct hardware *InitHardware ()
+ {
+     XGCValues values;
+     int i;
+     if ((dpy = XOpenDisplay(dpy)) == NULL)
+ 	Punt("Could not open display");
+     InitTransfer(DisplayHeight(dpy, SCREEN) / 11);
+     /* This defines our screen as being 11 inches high, no matter what its */
+     /* real size.  What a hack. */
+     values.foreground = AllPlanes;
+     for (i=0 ; i<16 ; i++) {
+ 	values.function = i;
+ 	fillgc[i] = XCreateGC(dpy, RootWindow(dpy, SCREEN),
+ 			      GCFunction | GCForeground, &values);
+     }
+ }
+ /*
+  * InitHardware () returns a default device which PostScript may use
+  * immediately (or NULL if not appropriate).  Its size and shape are not
+  * defined. Most typically the user will want to start up another device
+  * before it is used anyway. No attempt will be made by PostScript to Destroy
+  * the resulting device.
+  */
+ 
+ static struct hardware *NewHardware(width, height)
+ int width, height;
+ {
+     struct hardware *to;
+     Hardware hard;
+     to = (struct hardware *) malloc(sizeof(struct hardware));
+     hard = (Hardware) malloc(sizeof(HardwareRec));
+     to->hard.addr = (char *) hard;
+     to->flags = 0;
+     to->aux = to->clip = NULL;
+     to->extent = NewDevicePoint(width, height);
+     hard->w = NULL;
+     return to;
+ }
+ 
+ 
+ struct hardware *NewBitmapHardware (width, height)
+ int width, height;
+ {
+     struct hardware *to = NewHardware(width, height);
+     Hardware hard = (Hardware) to->hard.addr;
+     to->flags = NULL;
+     hard->w = XCreatePixmap(dpy, RootWindow(dpy, SCREEN), width, height,
+ 			    DefaultDepth(dpy, SCREEN));
+     XFillRectangle(dpy, hard->w, fillgc[GXclear], 0, 0, width, height);
+ 
+ /*    {
+ 	static int y = 0;
+ 	XSetWindowAttributes attributes;
+ 	hard->w = XCreateSimpleWindow(dpy, RootWindow(dpy, SCREEN), 700, y,
+ 				  width, height, 1, BlackPixel(dpy, SCREEN),
+ 				  WhitePixel(dpy, SCREEN));
+ 	attributes.override_redirect = TRUE;
+ 	XChangeWindowAttributes(dpy, hard->w, CWOverrideRedirect, &attributes);
+ 	XMapWindow(dpy, hard->w);
+ 	y+=30;
+     }*/
+     return to;
+ }
+ 
+ struct hardware *NewWindowHardware (width, height)
+ int width, height;
+ {
+     struct hardware *to = NewHardware(width, height);
+     Hardware hard = (Hardware) to->hard.addr;
+     XEvent event;
+     unsigned long vmask;
+     XSetWindowAttributes xswa;
+ 
+     to->flags = ISWIN;
+ /*
+     hard->w = XCreateSimpleWindow(dpy, RootWindow(dpy, SCREEN), 0, 0,
+ 				  width, height, 1, BlackPixel(dpy, SCREEN),
+ 				  0);
+ */
+     vmask = CWBackPixel|CWBorderPixel|CWBackingStore|
+       CWBackingPlanes|CWSaveUnder;
+     xswa.background_pixel = WhitePixel(dpy,SCREEN);
+     xswa.border_pixel = BlackPixel(dpy,SCREEN);
+     xswa.backing_store = Always;
+     xswa.backing_planes = AllPlanes;
+     xswa.save_under = True;
+ 
+     hard->w = XCreateWindow(dpy,RootWindow(dpy,SCREEN),
+ 			    0,0,
+ 			    width,height,
+ 			    1,DefaultDepth(dpy,SCREEN),
+ 			    InputOutput,DefaultVisual(dpy,SCREEN),
+ 			    vmask,&xswa);
+ 
+     XChangeProperty(dpy,hard->w,XA_WM_NAME,XA_STRING,8,
+ 		    PropModeReplace,"POSTSCRIPT",10);
+ 
+     XSelectInput(dpy, hard->w, ExposureMask);
+     XMapWindow(dpy, hard->w);
+     XNextEvent(dpy, &event);
+     XSelectInput(dpy, hard->w, 0);
+     return to;
+ }
+ /*
+  * NewBitmapHardware () is expected to create a new bitmap. Only one plane
+  * will be needed.
+  * 	
+  * NewWindowHardware () is expected to create a window on the screen. On a
+  * colour system this will be expected to support full colour.
+  */
+ 
+ #ifdef CANON
+ int IsWindowHardware (h)
+ struct hardware *h;
+ {}
+ #endif CANON
+ /*
+  * IsWindowHardware () should return TRUE if the hardware is a window, FALSE
+  * otherwise.  NULL is a window.
+  */
+ 
+ void DestroyHardware (h)
+ struct hardware *h;
+ {
+     if (h) {
+ 	Hardware hard = (Hardware) h->hard.addr;
+ 	if (IsWindowHardware(h))
+ 	    XDestroyWindow(dpy, hard->w);
+ 	else
+ 	    XFreePixmap(dpy, hard->w);
+     }
+ }
+ /*
+  * 	
+  * DestroyHardware () should release the resources required by the hardware,
+  * bitmap or window.  This should cause a window device to vanish. NULL is not
+  * an error (does nothing).
+  */
+ 
+ 
+ #ifdef CANON
+ Matrix DeviceMatrix (width, height)
+ int width, height;
+ {}
+ #endif CANON
+ 
+ /*
+  *
+  * DeviceMatrix () should return a matrix appropriate to a device of the given
+  * height and width.  For a typical display with a graphics origin at the top
+  * left of a window, an appropriate definition would be:
+  * 	
+  * Matrix DeviceMatrix (width, height)
+  * int width, height;
+  * {
+  *     return NewMatrix (PIXELS_PER_INCH / 72.0, 0.0, 0.0,
+  * 		         -PIXELS_PER_INCH / 72.0, 0.0, (float) height);
+  * }
+  */
+ 
+ #ifdef CANON
+ DevicePoint HardwareExtent (h)
+ struct hardware *h;
+ {}
+ #endif
+ /*
+  * HardwareExtent () returns a DevicePoint describing the width and height of
+  * the argument.  NULL has extent NewDevicePoint (0, 0).
+  */
+ 
+ /*************************** OUTPUT PRIMITIVES ******************************/	
+ 
+ void BitBlt (from, to, fromPoint, toPoint, extent, rop)
+ struct hardware *from, *to;
+ DevicePoint toPoint, fromPoint, extent;
+ int rop;
+ {
+     Hardware fromhard, tohard;
+     static int count = 0;
+     if (to == NULL) return;
+     tohard = (Hardware) to->hard.addr;
+     if (from == NULL) {
+ 	XFillRectangle(dpy, tohard->w, fillgc[rop], toPoint.dx, toPoint.dy,
+ 		       extent.dx, extent.dy);
+     } else {
+ 	fromhard = (Hardware) from->hard.addr;
+ 	XCopyArea(dpy, fromhard->w, tohard->w, fillgc[rop], fromPoint.dx,
+ 		  fromPoint.dy, extent.dx, extent.dy, toPoint.dx, toPoint.dy);
+     }
+     if (count++ % 50 == 0) XSync(dpy, 0);
+ }
+ 
+ #ifdef CANON
+ void Paint (from, to, fromPoint, toPoint, extent, colour)
+ struct hardware *from, *to;
+ DevicePoint toPoint, fromPoint, extent;
+ Colour colour;
+ {}
+ #endif
+ 
+ /*
+  * 	
+  * BitBlt () is a full function RasterOp. The 'rop' argument will have values
+  * as described in the header file hard.h. If the from argument is NULL it is
+  * taken to be a bitmap full of ones the shape of the fromPoint and extent. If
+  * the to argument is NULL, this is a no-op.
+  *
+  * Paint () is an addition to BitBlt. Bits that are set in the source are
+  * Painted into the destination in the given colour with a copying rasterop so
+  * that they replace pixels previously there. If the machine does not support
+  * colour windows, half-toning should be performed.  Colour values have hue,
+  * saturation and brightness components. on a black and white or greyscale
+  * system the brightness value will be a FP value between 0.0 (black) and 1.1
+  * (white), which can be used as a grey level.
+  * 	
+  * Paint is expected to mask with the clip mask. BitBlt is not,
+  */
+ 
+ #ifdef CANON
+ void BitBltTrapezoid(to, lefttop, leftbottom, righttop, rightbottom,
+ 		     top, bottom, rop)
+ struct hardware *to;
+ DevicePoint lefttop, leftbottom, righttop, rightbottom;
+ int top, bottom, rop;
+ {}
+ #endif CANON
+ 
+ #ifdef CANON
+ void PaintTrapezoid (to, lefttop, leftbottom, righttop, rightbottom,
+ 		     top, bottom, colour)
+ struct hardware *to;
+ DevicePoint lefttop, leftbottom, righttop, rightbottom;
+ int top, bottom;
+ Colour colour;
+ {}
+ #endif CANON
+ 
+ /*
+  * BitBltTrapezoid () and PaintTrapezoid () render a complete trapezoidal
+  * shape.  The corners of the trapezoid may lie far outside the range of
+  * interesting scan-lines, but the slope of the line should be clipped by the
+  * top and bottom. The coordinates are half-open.
+  */
+ 
+ void BitBltLine (h, fromPoint, toPoint, rop)
+ struct hardware *h;
+ DevicePoint fromPoint, toPoint;
+ int rop;
+ {
+     if (h) {
+ 	Hardware hard = (Hardware) h->hard.addr;
+ 	XDrawLine(dpy, hard->w, fillgc[rop], fromPoint.dx, fromPoint.dy,
+ 		  toPoint.dx, toPoint.dy);
+     }
+ }
+ 
+ #ifdef CANON
+ void PaintLine (h, fromPoint, toPoint, colour)
+ struct hardware *h;
+ DevicePoint fromPoint, toPoint;
+ Colour colour;
+ {}
+ #endif CANON
+ 
+ /*
+  * 	
+  * 	BitBltLine () is expected to draw a line between the given points
+  * 	with the given RasterOp and colour masking.
+  * 	The line should be one pixel wide and half-open.
+  * 	[Thicker lines are done with BitBlt.]
+  * 	
+  * 	PaintLine () is expected to Paint a line by analogy with Paint
+  * 	and BitBlt.
+  */
+ 
+ void BitBltBlob (to, top, height, left, right, rop)
+ struct hardware *to;
+ int top, height, *left, *right, rop;
+ {
+     int i;
+     DevicePoint p1, p2;
+     for (i=0 ; i<height ; i++) {
+ 	p1.dx = left[i];
+ 	p2.dx = right[i];
+ 	p1.dy = p2.dy = top + i;
+ 	BitBltLine(to, p1, p2, rop);
+     }
+ }
+ 
+  /*
+   * BitBltBlob () takes a set of pixel coordinates and fills the trapezon
+   * figure half open.
+   */
+ 
+ #ifdef SLOWANDWRONG
+ void RasterTile (from, to, toPoint, extent, rop)
+ struct hardware *from, *to;
+ DevicePoint toPoint, extent;
+ int rop;
+ {
+     Hardware fromhard, tohard;
+     DevicePoint p1, p2, p3;
+     int x, y;
+     if (to == NULL) return;
+     if (from == NULL)
+ 	Punt("Can only RasterTile from Hardware.");
+     fromhard = (Hardware) from->hard.addr;
+     tohard = (Hardware) to->hard.addr;
+     p1.dx = p1.dy = 0;
+     for (x=toPoint.dx ; x < toPoint.dx + extent.dx ; x+=from->extent.dx) {
+ 	for (y=toPoint.dy ; y < toPoint.dy + extent.dy ; y+=from->extent.dy) {
+ 	    p2.dx = x;
+ 	    p2.dy = y;
+ 	    p3.dx = MIN(toPoint.dx + extent.dx - x, from->extent.dx);
+ 	    p3.dy = MIN(toPoint.dy + extent.dy - y, from->extent.dy);
+ 	    BitBlt(from, to, p1, p2, p3, rop);
+ 	}
+     }
+ }
+ #endif SLOWANDWRONG
+ 
+ 
+ void RasterTile (from, to, toPoint, extent, rop)
+ struct hardware *from, *to;
+ DevicePoint toPoint, extent;
+ int rop;
+ {
+     Hardware fromhard, tohard;
+     static GC gc = NULL;
+     XGCValues values;
+     int valuemask;
+     if (to == NULL) return;
+     if (from == NULL || IsWindowHardware(from))
+ 	Punt("Can only RasterTile from Bitmap.");
+     fromhard = (Hardware) from->hard.addr;
+     tohard = (Hardware) to->hard.addr;
+     values.tile = fromhard->w;
+     values.fill_style = FillTiled;
+     values.function = rop;
+     valuemask = GCFunction | GCTile | GCFillStyle;
+     if (gc == NULL)
+ 	gc = XCreateGC(dpy, RootWindow(dpy, SCREEN), valuemask, &values);
+     else
+ 	XChangeGC(dpy, gc, valuemask, &values);
+     XFillRectangle(dpy, tohard->w, gc, toPoint.dx, toPoint.dy,
+ 		   extent.dx, extent.dy);
+ }
+ 
+ /*
+  * RasterTile () replicates the whole of ``from'' over ``to'', but clipped by
+  * the rectangle bounded by ``toPoint'' and ``extent''.
+  */
+ 
+ /******************* BRIGHTNESS TRANSFER FUNCTION ************************/
+ 
+ #ifdef CANON
+ int TransferSize ()
+ {}
+ #endif CANON
+ 
+ #ifdef CANON
+ void SetTransfer (vec)
+ float *vec;
+ {}
+ #endif CANON
+ /*
+  * 	
+  * TransferSize () and SetTransfer () control the mapping function between
+  * user brightnesses and device brightnesses. The interface is expected to
+  * perform this mapping of brightnesses to a sufficient resolution.
+  * SetTransfer takes a table of floating point numbers between 0 and 1. User
+  * brightnesses are scaled to the size of this table and mapped through it.
+  * The argument table given to SetTransfer () will be deleted after use.
+  * TransferSize () simply enquires the required size of the table.
+  * 	
+  * It may be appropriate to half-tone on a grayscale or colour device to
+  * improve rendering if it is not too expensive. TransferSize () returns the
+  * size of the pattern table.
+  */
+ 
+ /********************** BITMAP CONVERSION ********************************/
+ 
+ char *StringFromHardware (h)
+ struct hardware *h;
+ {
+     XImage *image;
+     Hardware hard;
+     unsigned char *result, *ptr, c;
+     int x, y, i;
+     if (h == NULL) return NULL;
+     hard = (Hardware) h->hard.addr;
+     image = XGetImage(dpy, hard->w, 0, 0, h->extent.dx, h->extent.dy,
+ 		      AllPlanes, ZPixmap);
+     result = (unsigned char *) malloc(((h->extent.dx + 7) / 8) * h->extent.dy);
+     ptr = result;
+     for (y=0 ; y<h->extent.dy ; y++) {
+ 	for (x=0 ; x<h->extent.dx ; x+=8) {
+ 	    c = 0;
+ 	    for (i=0 ; i<8 ; i++) {
+ 		c = c << 1;
+ 		if (x+i < h->extent.dx)
+ 		    c |= XGetPixel(image, x+i, y);
+ 	    }
+ 	}
+ 	*ptr++ = c;
+     }
+     free((char *) image);
+     return (char *) result;
+ }
+ 
+ struct hardware *HardwareFromString (s, width, height)
+ char *s;
+ int width, height;
+ {
+     struct hardware *h = NewBitmapHardware(width, height);
+     Hardware hard = (Hardware) h->hard.addr;
+     XImage *image;
+     if (s == NULL) Punt("HardwareFromString called with NULL string!");
+     image = XCreateImage(dpy, DefaultVisual(dpy, SCREEN),
+ 			 DefaultDepth(dpy, SCREEN), ZPixmap, 0, s,
+ 			 width, height, 8, 0);
+     image->bitmap_bit_order = MSBFirst;
+     XPutImage(dpy, hard->w, fillgc[GXcopy], image, 0, 0, 0, 0, width, height);
+     free((char *) image);
+     return h;
+ }
+ /*
+  * 	
+  * StringFromHardware () produces a string from its argument which describes
+  * the bitmap.  The bitmap is returned in row-major order with the leftmost
+  * bit of each byte in the most significant position. Rows are padded to byte
+  * boundaries. Only single plane bitmaps are used.
+  * 	
+  * HardwareFromString () performs the inverse mapping, generating a bitmap
+  * from a set of bits, given a width and height. Only single plane bitmaps are
+  * used.
+  */
+ 
+ /************************* HALF-TONE SCREEN *******************************/
+ 
+ #ifdef CANON
+ int ScreenSize (freq, rotation)
+ float freq, rotation;
+ {}
+ #endif CANON
+ 
+ #ifdef CANON
+ void BuildScreen (freq, rotation, x, y)
+ float freq, rotation, *x, *y;
+ {}
+ #endif CANON
+ 
+ #ifdef CANON
+ void SetScreen (freq, rotation, thresh)
+ float freq, rotation, *thresh;
+ {}
+ #endif CANON
+ /*
+  * ScreenSize () allows PostScript to determine how large an array of sample
+  * points to expect.  It should return the length of the side of the sample
+  * square.
+  * 	
+  * BuildScreen () returns a set of sampling coordinates to PostScript to hand
+  * to the users spot-function
+  * 	
+  * SetScreen () allows PostScript to set the thresholds for each sample point
+  * so that half-tone bitmaps can be made.
+  */
+ 
+ /************************* CLIPPING ******************************************/
+ 
+ #ifdef CANON
+ void SetClipHardware (h, clip)
+ struct hardware *h, *clip;
+ {}
+ #endif
+ /*
+  * 	
+  * SetClipHardware sets hardware which is a clip mask for BitBlt. This mask
+  * should be ANDed with any output operation. If clip is NULL, masking will
+  * not be needed.
+  */
+ 
+ /************************ UPDATE CONTROLS **********************************/
+ 
+ void HardUpdate ()
+ {
+     XFlush(dpy, 0);
+ }
+ /*
+  * HardUpdate is a hook to allow devices which do output buffering to flush
+  * that buffering when appropriate.  This allows an interactive user to see
+  * completed graphics between prompts (it is called as a side-effect of the
+  * PostScript flush operator). Typically is is a no-op.
+  */
+ 
+ void UpdateControl (h, on)
+ struct hardware *h;
+ int on;
+ {}
+ /*
+  * This call can be used to enable batching of output operations.
+  * UpdateControl (h, FALSE) means ``start of batching'' UpdateControl (h,
+  * TRUE) means ``end of batching''. It is used to improve performance on
+  * machines where screen updates have a high locking overhead. It may be a
+  * no-op.  The operation should nest if batching is already in progress: FALSE
+  * increments a counter, TRUE decrements a counter. Display changes are
+  * allowed when the counter is non-zero.
+  */
+ 
+ /********************************** CANONICAL IMPLEMENTATION LIBRARY ******************************/
+ 
+ /*
+  * Some parts of the above interface can be supported by a canonical library.
+  * This library contains:
+ 
+ SetClipHardware
+ HardUpdate
+ IsWindowHardware
+ HardwareExtent
+ 
+ PaintTrapezoid
+ BitBltTrapezoid
+ 
+ Paint
+ PaintLine
+ 
+ DeviceMatrix
+ InitTransfer
+ TransferSize
+ SetTransfer
+ ScreenSize
+ BuildScreen
+ SetScreen
+ 
+  *
+  * As the driver matures, the user may provide his own versions of the
+  * canonical routines.  This leaves the following for implementation by 
+  * the user.
+  *
+ 
+ InitHardware
+ NewBitmapHardware
+ NewWindowHardware
+ DestroyHardware
+ HardwareFromString
+ StringFromHardware
+ UpdateControl
+ RasterTile
+ BitBlt
+ BitBltLine
+ BitBltBlob
+ 
+  * There is a pedagogical implementation in null.c
+  *	
+  * There are a number of interface issues concerning the canonical driver.
+  * Firstly, a canonical struct hardware is defined, which contains a union of
+  * a char * and an int handle. The remainder are expected to use this to store
+  * device specific information.
+  *
+  * InitTransfer() should be called during InitHardware with the number of 
+  * pixels per inch on the display as an argument.
+  */
+ 
+ /* I tacked this lot on the end to avoid altering canon.c - CAAG */
+ 
+ int pixels_per_inch;
+ 
+ int single_rop [] =
+  {
+ 	ROP_FALSE, ROP_DEST, ROP_NOTDEST, ROP_TRUE,
+ 	ROP_FALSE, ROP_DEST, ROP_NOTDEST, ROP_TRUE,
+ 	ROP_FALSE, ROP_DEST, ROP_NOTDEST, ROP_TRUE,
+ 	ROP_FALSE, ROP_DEST, ROP_NOTDEST, ROP_TRUE
+  };
+ 
+ /*ARGSUSED*/
+ Matrix DeviceMatrix (width, height) int width, height;
+  {
+  	return NewMatrix (pixels_per_inch / 72.0, 0.0, 0.0, -pixels_per_inch / 72.0, 0.0, (float) height);
+  }
+ 
+ int IsWindowHardware (h) struct hardware *h;
+  {
+  	return h->flags & ISWIN;
+  }
+ 
+ #define IsWindowHardware(h) ((h)->flags & ISWIN)
+ 
+ DevicePoint HardwareExtent (h) struct hardware *h;
+  {
+  	if (h)
+  		return h->extent;
+  	else
+  		return NewDevicePoint (0, 0);
+  }
+ 
+ void SetClipHardware (h, clip) struct hardware *h, *clip;
+  {
+  	if (h)
+ 		h->clip = clip;
+  }
+ 
diff -cr /usr/tmp/ps/source/array.c ./source/array.c
*** /usr/tmp/ps/source/array.c	Thu Jul 28 14:01:14 1988
--- ./source/array.c	Wed Jul 27 12:02:11 1988
***************
*** 142,151 ****
--- 142,165 ----
  int ExecArray (item) Object item;
   {
   	int l = lengthArray (item);
+ 	Object res;
+ 	register Object *rp = &res;
   	
  	if (l == 0)
   		return TRUE;
+ 	/*
+ 	 * BZS - try some open-coding here
+ 	 *
   	Push (ExecStack, SameFlags (item, Make (Body (item) + 1, l - 1)));
+ 	*/
+ 	rp->type = Array;
+ 	rp->flags = READABLE | WRITEABLE;
+ 	rp->u.Integer = 0;
+ 	rp->u.Array = item.u.Array + 1;
+ 	rp->Length = l - 1;
+ 	rp->flags = item.flags;
+ 	Push(ExecStack,res);
+ 	/* end open-coding */
   	if (TypeOf (Body (item) [0]) == Name || TypeOf (Body (item) [0]) == Operator)
   		Push (ExecStack, Body (item) [0]);
   	else
diff -cr /usr/tmp/ps/source/config.c ./source/config.c
*** /usr/tmp/ps/source/config.c	Thu Jul 28 14:01:20 1988
--- ./source/config.c	Thu Jul 28 14:07:25 1988
***************
*** 92,98 ****
  	
  	/* Begin jgm */
  	strcpy(versionbuf, DriverType);
! 	strcat(versionbuf, " version 1.4 with jgm mods v2");
  	Install ("version",	StringFrom (versionbuf));
  	/* End jgm */
   }
--- 92,98 ----
  	
  	/* Begin jgm */
  	strcpy(versionbuf, DriverType);
! 	strcat(versionbuf, " version 1.4 with jgm/bzs mods v3");
  	Install ("version",	StringFrom (versionbuf));
  	/* End jgm */
   }
diff -cr /usr/tmp/ps/source/device.c ./source/device.c
*** /usr/tmp/ps/source/device.c	Thu Jul 28 14:01:23 1988
--- ./source/device.c	Sat Apr 30 17:45:35 1988
***************
*** 25,31 ****
   	struct hardware *h;
   	DevicePoint extent;
   	
! 	InstallOp ("framedevice",	FrameDevice, 		4, 0, 0, 0, Array, Integer, Integer, Array);
  	InstallOp ("nulldevice",	NullDevice,		0, 0, 0, 0);
  	InstallOp ("grabbits",		GrabBits,		4, 0, 0, 0, Float, Float, Float, Float);
  	
--- 25,31 ----
   	struct hardware *h;
   	DevicePoint extent;
   	
! 	InstallOp ("framedevice",	FrameDevice, 		4, 0, 0, 0, Array, Integer, Integer, Poly /* jgm */);
  	InstallOp ("nulldevice",	NullDevice,		0, 0, 0, 0);
  	InstallOp ("grabbits",		GrabBits,		4, 0, 0, 0, Float, Float, Float, Float);
  	
***************
*** 79,94 ****
   	return TRUE;
   }
  
- /*ARGSUSED*/
  static int FrameDevice (mat, width, height, proc) Object mat, width, height, proc;
   {
   	Matrix m;
   	
   	if (lengthArray (mat) != 6 || !ExtractMatrix (&m, mat))
   		return Error (PTypeCheck);
   	if (BodyInteger (width) < 0 || BodyInteger (height) < 0)
   		return Error (PRangeCheck);
!  	SetDevice (NewWindowDevice (BodyInteger (width) * 8, BodyInteger (height), m));
   	ErasePage ();
   	
  	return TRUE;
--- 79,98 ----
   	return TRUE;
   }
  
  static int FrameDevice (mat, width, height, proc) Object mat, width, height, proc;
   {
   	Matrix m;
+ 	struct device *d;
   	
   	if (lengthArray (mat) != 6 || !ExtractMatrix (&m, mat))
   		return Error (PTypeCheck);
   	if (BodyInteger (width) < 0 || BodyInteger (height) < 0)
   		return Error (PRangeCheck);
! 	/* Begin jgm */
!  	d = NewWindowDevice (BodyInteger (width) * 8, BodyInteger (height), m);
! 	d->output_routine = proc;
!  	SetDevice (d);
! 	/* End jgm */
   	ErasePage ();
   	
  	return TRUE;
***************
*** 148,155 ****
   	res->link_count = 0;
   	res->default_clip = clip;
   	res->default_matrix = m;
   	res->dev = dev;
!  	
   	return res;
   }
  
--- 152,160 ----
   	res->link_count = 0;
   	res->default_clip = clip;
   	res->default_matrix = m;
+ 	res->output_routine = Nil;
   	res->dev = dev;
! 	
   	return res;
   }
  
diff -cr /usr/tmp/ps/source/device.h ./source/device.h
*** /usr/tmp/ps/source/device.h	Thu Jul 28 13:43:09 1988
--- ./source/device.h	Sat Apr 30 16:34:02 1988
***************
*** 9,14 ****
--- 9,15 ----
   	Matrix default_matrix;
   	Path default_clip;
   	int link_count;
+ 	Object output_routine; /* jgm */
   	struct hardware *dev;
   };
  
diff -cr /usr/tmp/ps/source/dictionary.c ./source/dictionary.c
*** /usr/tmp/ps/source/dictionary.c	Thu Jul 28 13:53:28 1988
--- ./source/dictionary.c	Wed Jul 27 12:02:12 1988
***************
*** 17,24 ****
  
  Object Absent, Nil, SysDict;
  
! Object DictLookup (), MakeDict (), DictLoad ();
  
  static int LengthDict (), CopyDict (), forDict (), ForDict (), PutDict (), GetDict ();
  static int PDict (), PBegin (), PEnd (), PDef (), PStore (), PKnown (), PLoad ();
  static int PrCheck (), PwCheck (), PReadOnly (), EqDict (); 
--- 17,29 ----
  
  Object Absent, Nil, SysDict;
  
! /* BZS - DictLoad open-coded */
! #ifndef DictLoad
! Object DictLoad();
! #endif
  
+ Object DictLookup (), MakeDict ();
+ 
  static int LengthDict (), CopyDict (), forDict (), ForDict (), PutDict (), GetDict ();
  static int PDict (), PBegin (), PEnd (), PDef (), PStore (), PKnown (), PLoad ();
  static int PrCheck (), PwCheck (), PReadOnly (), EqDict (); 
***************
*** 166,171 ****
--- 171,182 ----
  		(a.u.Integer == b.u.Integer || TypeOf (a) == Array && a.Length == 0);
   }
  
+ /* BZS - open code Equal */
+ #define Equal(A,B) ((TypeOf(A) == TypeOf(B)) && \
+ 		    (A.Length == B.Length) && \
+ 		    ((A.u.Integer == B.u.Integer)|| \
+ 		     (TypeOf(A) == Array) && (A.Length == 0)))
+ 
  static DictReplace (hash, key, value, size, h) struct dict_entry *hash; Object key, value; int size, h;
   {
   	int i;
***************
*** 250,258 ****
  	DictStore (SysDict, NameFrom (key), value);
   }
  
! static Object DictFind (hash, key, size) struct dict_entry *hash; Object key; int size;
   {
!  	int i, h;
   	
   	++hash_attempts;
   	
--- 261,272 ----
  	DictStore (SysDict, NameFrom (key), value);
   }
  
! /*
!  * BZS - add some register decls, make global for macrification (remove static)
!  */
! Object DictFind (hash, key, size) struct dict_entry *hash; Object key; int size;
   {
!  	register int i, h;
   	
   	++hash_attempts;
   	
***************
*** 266,271 ****
--- 280,286 ----
  	 {
  	 	if (TypeOf (hash[i].entry_key) == Null)
  	 		return Absent;
+ 
  	 	if (Equal (key, hash[i].entry_key))
  	 	 {
  			++hash_tries;
***************
*** 279,289 ****
--- 294,308 ----
  	 }
  	return Absent;
   }
+ #undef Equal
  
+ /* BZS - macro-ified */
+ #ifndef DictLoad
  Object DictLoad (dict, key) Object dict, key;
   {
  	return DictFind (Body (dict)->dict_body, key, Body (dict)->dict_size);
   }
+ #endif
  
  Object Lookup (dict, key) Type dict; Object key;
   {
diff -cr /usr/tmp/ps/source/fill.c ./source/fill.c
*** /usr/tmp/ps/source/fill.c	Thu Jul 28 14:02:56 1988
--- ./source/fill.c	Wed Jul 27 12:02:15 1988
***************
*** 35,41 ****
   *	pool
   */		
  
! static struct edge
   {
  	int topX, topY, bottomX, bottomY; short dir;
  	struct edge *pair;
--- 35,41 ----
   *	pool
   */		
  
! /* static (removed --jgm) */ struct edge
   {
  	int topX, topY, bottomX, bottomY; short dir;
  	struct edge *pair;
***************
*** 70,75 ****
--- 70,126 ----
  static int FillIt ();
  static int EoRule (), NwRule ();
  
+ /*
+  * BZS - Open Code
+  */
+ #define NotThisBit(EDGE,WHERE,EMITFN) { \
+   if((EDGE)->pair != NULL) { \
+      (*EMITFN)((EDGE),(EDGE)->pair,(EDGE)->startingY,WHERE); \
+      (EDGE)->pair->startingY = WHERE; \
+      (EDGE)->pair->where = WHERE; \
+      (EDGE)->pair->pair = NULL; \
+      (EDGE)->pair = NULL; \
+    } \
+   (EDGE)->startingY = WHERE; \
+   (EDGE)->where = WHERE; \
+ }
+ 
+ #define ThisBit(LEFT,RIGHT,WHERE,EMITFN) { \
+    if((LEFT)->pair != (RIGHT) || (RIGHT)->up) { \
+      if((LEFT)->pair != NULL) { \
+         (*EMITFN)(LEFT,(LEFT)->pair,(LEFT)->startingY,(LEFT)->where); \
+         (LEFT)->pair->startingY = (LEFT)->pair->where; \
+   	(LEFT)->pair->pair->startingY = (LEFT)->pair->pair->where; \
+   	(LEFT)->pair->pair = NULL; \
+      } \
+      if ((RIGHT)->pair != NULL) { \
+         (*EMITFN) (RIGHT, (RIGHT)->pair, (RIGHT)->startingY, (RIGHT)->where); \
+ 	(RIGHT)->pair->startingY = (RIGHT)->pair->where; \
+   	(RIGHT)->pair->pair->startingY = (RIGHT)->pair->pair->where; \
+   	(RIGHT)->pair->pair = NULL; \
+      }  \
+      (LEFT)->pair = RIGHT; \
+      (RIGHT)->pair = LEFT; \
+      (LEFT)->startingY = (RIGHT)->startingY = WHERE; \
+    } \
+    (LEFT)->where = (RIGHT)->where = WHERE; \
+    (LEFT)->up = TRUE; \
+    (RIGHT)->up = FALSE; \
+ }
+ 
+ #define UpEdge(COUNT_A,COUNT_B,INC_A,INC_B,RULE_A,RULE_B) \
+   ((*RULE_B)(COUNT_B+INC_B) && !(*RULE_A)(COUNT_A) && \
+    (*RULE_A)(COUNT_A+INC_A)||(*RULE_A)(COUNT_A+INC_A) && \
+    !(*RULE_B)(COUNT_B) && (*RULE_B)(COUNT_B+INC_B))
+ 
+ #define DownEdge(COUNT_A,COUNT_B,INC_A,INC_B,RULE_A,RULE_B) \
+   ((*RULE_B)(COUNT_B+INC_B) && (*RULE_A)(COUNT_A) && \
+    !(*RULE_A)(COUNT_A+INC_A)||(*RULE_A)(COUNT_A+INC_A) && \
+    (*RULE_B)(COUNT_B) && !(*RULE_B)(COUNT_B+INC_B))
+ 
+ #define Xvalue(AX,AY,BX,BY,CY) \
+   ((BX)+((CY)-(BY))*((AX)-(BX))/(float)((AY)-(BY)))
+ 
  static void EmitTrapezoid (left, right, top, bottom) struct edge *left, *right; int top, bottom;
   {
   	struct edge *temp;
***************
*** 286,320 ****
  
  ProcessEdges (rule_a, rule_b, emitfn) int (*rule_a)(), (*rule_b)(); void (*emitfn)();
   {
! 	struct edge *up_edge;
! 	int i, count_a = 0, count_b = 0;
! 	/* static void RemoveEdges (); (unused --jgm) */
! 	
! 	for (i = 0; i < ninteresting; i++)
! 	 {
! 	 	/* static void Emit (); (unused --jgm) */
! 	 	int d_a = 0, d_b = 0;
! 	 	
! 	 	if (interesting[i]->clip)
! 	 		d_a = interesting[i]->dir;
! 	 	else
! 	 		d_b = interesting[i]->dir;
  
! 	 	if (UpEdge (count_a, count_b, d_a, d_b, rule_a, rule_b))
! 	 		up_edge = interesting[i];
! 	 	else if (DownEdge (count_a, count_b, d_a, d_b, rule_a, rule_b))
! 	 	 	ThisBit (up_edge, interesting[i], interestingY, emitfn);
! 	 	else
! 	 	 	NotThisBit (interesting[i], interestingY, emitfn);
! 	 	
! 	 	count_a += d_a;
! 	 	count_b += d_b;
! 	 }
! 	if (count_a || count_b)
! 		fprintf (stderr, "count_a = %dcount_b = %d\n", count_a, count_b);
! 	PanicIf (count_a || count_b, "something wrong in area fill");
   }
  
  ThisBit (left, right, where, emitfn) struct edge *left, *right; int where; void (*emitfn)();	
   {
   	if (left->pair != right || right->up)
--- 337,379 ----
  
  ProcessEdges (rule_a, rule_b, emitfn) int (*rule_a)(), (*rule_b)(); void (*emitfn)();
   {
! 	register struct edge **intp;
!         register struct edge *up_edge;
! 	register int count_a = 0, count_b = 0;
! 	register int i;
  
! 	i = ninteresting;
! 	intp = interesting;
! 	while(i-- > 0) {
! 	  register int d_a = 0, d_b = 0;
! 
! 	  if ((*intp)->clip)
! 	    d_a = (*intp)->dir;
! 	  else
! 	    d_b = (*intp)->dir;
! 
! 	  if (UpEdge (count_a, count_b, d_a, d_b, rule_a, rule_b))
! 	    up_edge = *intp;
! 	  else if(DownEdge (count_a, count_b, d_a, d_b, rule_a, rule_b)){
! 	    ThisBit (up_edge,(*intp), interestingY, emitfn);
! 	  }
! 	  else {
! 	    NotThisBit ((*intp),interestingY,emitfn);
! 	  }
! 	  count_a += d_a;
! 	  count_b += d_b;
! 
! 	  intp++;
! 	}
! 
! 	if (count_a || count_b) {
! 	  fprintf (stderr, "count_a = %dcount_b = %d\n", count_a, count_b);
! 	  Panic("something wrong in area fill");
! 	}
   }
  
+ /* BZS - Open code */
+ #ifndef ThisBit
  ThisBit (left, right, where, emitfn) struct edge *left, *right; int where; void (*emitfn)();	
   {
   	if (left->pair != right || right->up)
***************
*** 341,347 ****
--- 400,412 ----
   	left->where = right->where = where;
   	left->up = TRUE; right->up = FALSE;
   }
+ #endif
  
+ /*
+  * BZS - Open Code this, it can be called hundreds of thousands of times
+  * in even simple pictures. Mooreforms spend 50% of its time in this.
+  */
+ #ifndef NotThisBit
  NotThisBit (edge, where, emitfn) struct edge *edge; int where; void (*emitfn)();	
   {
   	if (edge->pair != NULL)
***************
*** 355,364 ****
    	edge->startingY = where;
   	edge->where = where;
   }
  
  static void RemoveEdges (interestingY, emitfn) int interestingY; void (*emitfn)();
   {
!  	int i, j = 0;
   	
   	for (i = 0; i < ninteresting; i++)
  		if (interesting [i]->bottomY > interestingY)
--- 420,430 ----
    	edge->startingY = where;
   	edge->where = where;
   }
+ #endif
  
  static void RemoveEdges (interestingY, emitfn) int interestingY; void (*emitfn)();
   {
!  	register int i, j = 0;
   	
   	for (i = 0; i < ninteresting; i++)
  		if (interesting [i]->bottomY > interestingY)
***************
*** 368,385 ****
   	ninteresting = j;
   }
  
  static int UpEdge (count_a, count_b, inc_a, inc_b, rule_a, rule_b) int count_a, count_b, inc_a, inc_b, (*rule_a) (), (*rule_b) ();
   {
   	return (*rule_b)(count_b + inc_b) && !(*rule_a) (count_a) && (*rule_a) (count_a + inc_a) ||
   		(*rule_a)(count_a + inc_a) && !(*rule_b) (count_b) && (*rule_b) (count_b + inc_b);
   }
! 
  static int DownEdge (count_a, count_b, inc_a, inc_b, rule_a, rule_b) int count_a, count_b, inc_a, inc_b, (*rule_a) (), (*rule_b) ();
   {
   	return (*rule_b)(count_b + inc_b) && (*rule_a) (count_a) && !(*rule_a) (count_a + inc_a) ||
   		(*rule_a)(count_a + inc_a) && (*rule_b) (count_b) && !(*rule_b) (count_b + inc_b);
   }
! 
  static int EoRule (n) int n;
   {
  	return n & 1;
--- 434,453 ----
   	ninteresting = j;
   }
  
+ #ifndef UpEdge
  static int UpEdge (count_a, count_b, inc_a, inc_b, rule_a, rule_b) int count_a, count_b, inc_a, inc_b, (*rule_a) (), (*rule_b) ();
   {
   	return (*rule_b)(count_b + inc_b) && !(*rule_a) (count_a) && (*rule_a) (count_a + inc_a) ||
   		(*rule_a)(count_a + inc_a) && !(*rule_b) (count_b) && (*rule_b) (count_b + inc_b);
   }
! #endif
! #ifndef DownEdge
  static int DownEdge (count_a, count_b, inc_a, inc_b, rule_a, rule_b) int count_a, count_b, inc_a, inc_b, (*rule_a) (), (*rule_b) ();
   {
   	return (*rule_b)(count_b + inc_b) && (*rule_a) (count_a) && !(*rule_a) (count_a + inc_a) ||
   		(*rule_a)(count_a + inc_a) && (*rule_b) (count_b) && !(*rule_b) (count_b + inc_b);
   }
! #endif
  static int EoRule (n) int n;
   {
  	return n & 1;
***************
*** 405,419 ****
  	return num / denom;
   }
  
  static int Xvalue (ax, ay, bx, by, cy) int ax, ay, bx, by, cy;
   {
   	return bx + (cy - by) * (ax - bx) / (float) (ay - by);
   }
  
  static int intercmp (aa, bb) char *aa, *bb;
   {
!  	struct edge *a = *(struct edge **) aa, *b = *(struct edge **) bb;
!  	int sign;
  	
  	sign = Xvalue (a->topX, a->topY, a->bottomX, a->bottomY, interestingY + 1) -
  		     Xvalue (b->topX, b->topY, b->bottomX, b->bottomY, interestingY + 1);
--- 473,489 ----
  	return num / denom;
   }
  
+ #ifndef Xvalue
  static int Xvalue (ax, ay, bx, by, cy) int ax, ay, bx, by, cy;
   {
   	return bx + (cy - by) * (ax - bx) / (float) (ay - by);
   }
+ #endif
  
  static int intercmp (aa, bb) char *aa, *bb;
   {
!    register struct edge *a = *(struct edge **) aa, *b = *(struct edge **) bb;
!    int sign;
  	
  	sign = Xvalue (a->topX, a->topY, a->bottomX, a->bottomY, interestingY + 1) -
  		     Xvalue (b->topX, b->topY, b->bottomX, b->bottomY, interestingY + 1);
***************
*** 424,449 ****
  
  static void AddInteresting ()
   {
! 	int i;
  	 	
  	nextY = infinity;
  	for (; here < nedges && edge[here].topY <= interestingY; here++) /* look at each new interesting edge */
  	 {
! 	 	int i, n;
! 	 	
! 		for (i = 0; i < ninteresting; i++) /* look at all possible intersections */
  		 {
! 		 	int inter = Yintersect (&edge[here], interesting[i]);
  		 	
! 		 	if (inter >= interestingY && inter <= edge[here].bottomY && inter <= interesting[i]->bottomY)
  		 		AddLowest (inter);
  		 }
  		n = ninteresting++;
! 		interesting[n] = &edge[here];
! 		interesting[n]->pair = NULL;
! 		interesting[n]->up = FALSE;
! 		interesting[n]->startingY = interesting[n]->where = edge[here].topY;
! 		interesting[n]->name = names++;
  	 }
  	i = NextLowest (interestingY);
  	if (i)
--- 494,526 ----
  
  static void AddInteresting ()
   {
! 	register int i;
! 	register struct edge **intp;
  	 	
  	nextY = infinity;
  	for (; here < nedges && edge[here].topY <= interestingY; here++) /* look at each new interesting edge */
  	 {
! 	 	register int i, n;
! 
! 		i = ninteresting;
! 		intp = interesting;
! 		while(i-- > 0) /* look at all possible intersections */
  		 {
! 		 	int inter = Yintersect (&edge[here], (*intp));
  		 	
! 		 	if (inter >= interestingY &&
! 			    inter <= edge[here].bottomY &&
! 			    inter <= (*intp)->bottomY)
  		 		AddLowest (inter);
+ 			intp++;
  		 }
  		n = ninteresting++;
! 		intp = &interesting[n];
! 		*intp = &edge[here];
! 		(*intp)->pair = NULL;
! 		(*intp)->up = FALSE;
! 		(*intp)->startingY = (*intp)->where = edge[here].topY;
! 		(*intp)->name = names++;
  	 }
  	i = NextLowest (interestingY);
  	if (i)
***************
*** 450,461 ****
  		nextY = i;
  	if (here != nedges && edge[here].topY < nextY)
  		nextY = edge[here].topY;
! 	for (i = 0; i < ninteresting; i++)
! 	 {
! 		if (interesting[i]->topY > interestingY && interesting[i]->topY < nextY)
! 			nextY = interesting[i]->topY;
! 		if (interesting[i]->bottomY > interestingY && interesting[i]->bottomY < nextY)
! 			nextY = interesting[i]->bottomY;
  	 }
  	qsort ((char *) interesting, (unsigned) ninteresting, sizeof (struct edge *), intercmp);
   }
--- 527,541 ----
  		nextY = i;
  	if (here != nedges && edge[here].topY < nextY)
  		nextY = edge[here].topY;
! 	i = ninteresting;
! 	intp = interesting;
! 	while(i-- > 0)
! 	  {
! 		if ((*intp)->topY > interestingY && (*intp)->topY < nextY)
! 			nextY = (*intp)->topY;
! 		if ((*intp)->bottomY > interestingY && (*intp)->bottomY < nextY)
! 			nextY = (*intp)->bottomY;
! 		intp++;
  	 }
  	qsort ((char *) interesting, (unsigned) ninteresting, sizeof (struct edge *), intercmp);
   }
***************
*** 462,468 ****
  
  static void FindInfinity ()
   {
!  	int i;
   	
  	infinity = edge[0].topY;
  	for (i = 0; i < nedges; i++)
--- 542,548 ----
  
  static void FindInfinity ()
   {
!  	register int i;
   	
  	infinity = edge[0].topY;
  	for (i = 0; i < nedges; i++)
***************
*** 503,509 ****
  
  static void BuildEdgeList (path, clip) Path path; int clip;
   {
!  	Path p;
   	HardPoint move, here;
   	
   	for (p = path->next; p != path; p = p->next)
--- 583,589 ----
  
  static void BuildEdgeList (path, clip) Path path; int clip;
   {
!  	register Path p;
   	HardPoint move, here;
   	
   	for (p = path->next; p != path; p = p->next)
***************
*** 533,539 ****
  static int NextLowest (y) int y;
   {
  	int res;
! 	struct lowest *p;
  	
  	for (p = lowest; p && p->e <= y; p = lowest)	/* delete any which are now irrelevent */
  	 {
--- 613,619 ----
  static int NextLowest (y) int y;
   {
  	int res;
! 	register struct lowest *p;
  	
  	for (p = lowest; p && p->e <= y; p = lowest)	/* delete any which are now irrelevent */
  	 {
***************
*** 551,557 ****
  
  static void AddLowest (e) int e;
   {
!  	struct lowest *res, *p, *q;
   	
   	for (p = lowest; p && p->e < e; q = p, p = p->higher)
   		;
--- 631,637 ----
  
  static void AddLowest (e) int e;
   {
!  	register struct lowest *res, *p, *q;
   	
   	for (p = lowest; p && p->e < e; q = p, p = p->higher)
   		;
diff -cr /usr/tmp/ps/source/font.c ./source/font.c
*** /usr/tmp/ps/source/font.c	Thu Jul 28 14:02:59 1988
--- ./source/font.c	Wed Jul 27 12:02:18 1988
***************
*** 362,372 ****
   	else
   		return NewVector (0.0, 0.0, 1.0);
   }
! 
  static int BuildHershey (font, code) Object font, code;
   {
  	Vector met;
! 	Object *bbox, string, nm;
   	unsigned char *s;
   	Path p;
   	int i, l;
--- 362,374 ----
   	else
   		return NewVector (0.0, 0.0, 1.0);
   }
! /*
!  * BZS - some small changes to allow macrification of DictLoad()
!  */
  static int BuildHershey (font, code) Object font, code;
   {
  	Vector met;
! 	Object *bbox, string, nm, tmp;
   	unsigned char *s;
   	Path p;
   	int i, l;
***************
*** 373,381 ****
--- 375,391 ----
   	
  	bbox 	= BodyArray (DictLoad (font, FontBBox));
  	nm 	= BodyArray (DictLoad (font, Encoding)) [BodyInteger (code)];
+ 	/*
  	met 	= GetMetrics (DictLoad (DictLoad (font, Metrics), nm));
+ 	*/
+ 	tmp = DictLoad(font,Metrics);
+ 	met = GetMetrics(DictLoad(tmp,nm));
  	met.vx -= 2; /* hershey bodge - they look better closer */
+ 	/*
  	string 	= DictLoad (DictLoad (font, CharStrings), nm);
+ 	*/
+ 	tmp = DictLoad(font,CharStrings);
+ 	string = DictLoad(tmp,nm);
  	
  	SetCacheDevice (nm, NewPoint (met.vx, met.vy),
  		BodyReal (bbox[0]), BodyReal (bbox[1]),
diff -cr /usr/tmp/ps/source/main.h ./source/main.h
*** /usr/tmp/ps/source/main.h	Thu Jul 28 13:53:36 1988
--- ./source/main.h	Wed Jul 27 12:02:21 1988
***************
*** 166,170 ****
--- 166,176 ----
  		((getchbuf != EOF) ? getchbuf : ((BodyFile(file)->available = 0), Close (file), EOF))) \
  	: GeneralGetch (file))
  
+ /*
+  * BZS - macro-ify some things
+  */
+ Object DictFind();
+ #define DictLoad(DICT,KEY) DictFind((DICT.u.Dictionary)->dict_body,KEY,\
+ 				    (DICT.u.Dictionary)->dict_size)
  /* Next line --jgm */
  #define PanicIf(flag,s) do { if (flag) Panic(s); } while (0)
diff -cr /usr/tmp/ps/source/matrix.c ./source/matrix.c
*** /usr/tmp/ps/source/matrix.c	Thu Jul 28 14:03:05 1988
--- ./source/matrix.c	Wed Jul 27 12:02:22 1988
***************
*** 393,400 ****
  HardPoint ExtToInt (p) Point p;
   {
  	Vector v;
! 	
  	v = Transform (NewVector (p.x, p.y, 1.0), gstate->CTM);
  	return NewHardPoint (v.vx, v.vy);
   }
  
--- 393,413 ----
  HardPoint ExtToInt (p) Point p;
   {
  	Vector v;
! 	register Vector *vp;
! 	register Matrix *mp;
! 	register Point *pp;
! /*
!  * BZS - try open coding this
!  *	
  	v = Transform (NewVector (p.x, p.y, 1.0), gstate->CTM);
+  */
+ 	mp = &gstate->CTM;
+ 	vp = &v;
+ 	pp = &p;
+ 
+ 	vp->vx = pp->x * mp->A + pp->y * mp->C + mp->tx;
+ 	vp->vy = pp->x * mp->B + pp->y * mp->D + mp->ty;
+ 
  	return NewHardPoint (v.vx, v.vy);
   }
  
diff -cr /usr/tmp/ps/source/misc.c ./source/misc.c
No differences encountered
diff -cr /usr/tmp/ps/source/operator.c ./source/operator.c
*** /usr/tmp/ps/source/operator.c	Thu Jul 28 14:03:10 1988
--- ./source/operator.c	Wed Jul 27 12:02:23 1988
***************
*** 203,212 ****
   *
   */
  
  int ExecOperator (item) Object item;
   {
! 	struct op_struct *op = Body (item);
! 	int i, res, (*fn)() = op->fn;
  	Object arg[7];
  	
  	Self = NameOperator (item);
--- 203,216 ----
   *
   */
  
+ /*
+  * BZS - try to speed up a little
+  */
  int ExecOperator (item) Object item;
   {
! 	register struct op_struct *op = Body (item);
! 	register int i, res;
! 	int (*fn)() = op->fn;
  	Object arg[7];
  	
  	Self = NameOperator (item);
***************
*** 219,225 ****
  		arg[i] = Pop (OpStack);
  	for (i = op->arguments - 1; i >= 0; i--)
  	 {
! 	 	Type formal = op->argtypes[i], actual = TypeOf (arg[i]);
  	 	
  	 	if (formal == Float && actual == Integer)
   	 		arg[i] = RealInteger (arg[i]);
--- 223,229 ----
  		arg[i] = Pop (OpStack);
  	for (i = op->arguments - 1; i >= 0; i--)
  	 {
! 	 	register Type formal = op->argtypes[i], actual = TypeOf (arg[i]);
  	 	
  	 	if (formal == Float && actual == Integer)
   	 		arg[i] = RealInteger (arg[i]);
diff -cr /usr/tmp/ps/source/screen.c ./source/screen.c
*** /usr/tmp/ps/source/screen.c	Thu Jul 28 13:44:08 1988
--- ./source/screen.c	Sat Apr 30 18:44:06 1988
***************
*** 55,61 ****
   	struct hardware *shade;
   } *screen = NULL;
  
! static int screen_size, screen_side;
  
  static int FreqSize (freq) float freq;
   {
--- 55,61 ----
   	struct hardware *shade;
   } *screen = NULL;
  
! static int screen_size /* , screen_side (unused --jgm) */;
  
  static int FreqSize (freq) float freq;
   {
***************
*** 121,127 ****
   	 	free ((char *) screen);
   	 }
   	p = screen = (struct screen *) Malloc ((unsigned) (((screen_size = size * size) + 1) * sizeof (struct screen)));
!  	screen_side = size;
   	for (i = 0; i < size; i++)
   		for (j = 0; j < size; j++)
   		 {
--- 121,127 ----
   	 	free ((char *) screen);
   	 }
   	p = screen = (struct screen *) Malloc ((unsigned) (((screen_size = size * size) + 1) * sizeof (struct screen)));
!  	/* screen_side = size; (unused --jgm) */
   	for (i = 0; i < size; i++)
   		for (j = 0; j < size; j++)
   		 {
diff -cr /usr/tmp/ps/source/state.c ./source/state.c
*** /usr/tmp/ps/source/state.c	Thu Jul 28 14:03:20 1988
--- ./source/state.c	Sat Apr 30 16:47:57 1988
***************
*** 123,128 ****
--- 123,133 ----
  
  static int CopyPage ()
   {
+         /* Begin jgm */
+         if (TypeOf(gstate->device->output_routine) != Null) {
+ 	    Push(ExecStack, gstate->device->output_routine);
+ 	}
+ 	/* End jgm */
   	return TRUE;
   }
  
diff -cr /usr/tmp/ps/source/stroke.c ./source/stroke.c
*** /usr/tmp/ps/source/stroke.c	Thu Jul 28 13:48:04 1988
--- ./source/stroke.c	Sat Apr 30 18:26:27 1988
***************
*** 358,364 ****
  int PStrokePath ()
   {
   	Path p, new = NewPath ();
!  	HardPoint prev, here, move;
   	enum pelem_type last_type = EHeader;
   	float angle, last_angle, width = gstate->line_width;
   	
--- 358,364 ----
  int PStrokePath ()
   {
   	Path p, new = NewPath ();
!  	HardPoint /* prev, (unused --jgm) */ here, move;
   	enum pelem_type last_type = EHeader;
   	float angle, last_angle, width = gstate->line_width;
   	
***************
*** 370,376 ****
  	 	switch (p->ptype)
  	 	 {
  	 	  	case EMove:
! 			 	prev = here;
  			 	move = here = p->pe.point;
  			 	break;
  			 	
--- 370,376 ----
  	 	switch (p->ptype)
  	 	 {
  	 	  	case EMove:
! 			 	/* prev = here; (unused --jgm) */
  			 	move = here = p->pe.point;
  			 	break;
  			 	
***************
*** 378,384 ****
  	 	  		if (last_type == EMove)
  	 	  			break;
  				angle = LineSegment (p, new, IntToExt (here), IntToExt (move), width, last_angle, last_type);
! 			 	prev = here;
  			 	here = move;
  			 	last_type = EHeader;
  			 	break;
--- 378,384 ----
  	 	  		if (last_type == EMove)
  	 	  			break;
  				angle = LineSegment (p, new, IntToExt (here), IntToExt (move), width, last_angle, last_type);
! 			 	/* prev = here; (unused --jgm) */
  			 	here = move;
  			 	last_type = EHeader;
  			 	break;
***************
*** 385,391 ****
  			 	
  	 	  	case ELine:
  				angle = LineSegment (p, new, IntToExt (here), IntToExt (p->pe.point), width, last_angle, last_type);
! 			 	prev = here;
  			 	here = p->pe.point;
  	 	  		break;
  	 	  		
--- 385,391 ----
  			 	
  	 	  	case ELine:
  				angle = LineSegment (p, new, IntToExt (here), IntToExt (p->pe.point), width, last_angle, last_type);
! 			 	/* prev = here; (unused --jgm) */
  			 	here = p->pe.point;
  	 	  		break;
  	 	  		
*** /dev/null	Thu Jul 28 10:26:48 1988
--- wwinfo.h	Thu Jul 28 14:36:37 1988
***************
*** 0 ****
--- 1,14 ----
+ Now that I've gotten your attention...
+ 
+ If your system doesn't have the wwinfo.h file, that probably means
+ that you don't have the ww window manager, which is rumored to be
+ available only to academic sites in the U.K.  In that case, a version
+ of the Postscript Interpreter compiled to produce output for ww
+ is probably worthless to you.
+ 
+ Please examine the file source/makefile and select a version that is
+ appropriate for you--possible choices include "sunPS", "XPS", and
+ "xps".
+ 
+ 				_.John G. Myers
+ 
