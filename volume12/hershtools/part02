Subject:  v12i041:  Hershey font manipulation tools and data, Part02/05
Newsgroups: comp.sources.unix
Sender: sources
Approved: rs@uunet.UU.NET

Submitted-by: lee@uhccux.UUCP (Greg Lee)
Posting-number: Volume 12, Issue 41
Archive-name: hershtools/part02

# This is a shell archive.  Remove anything before this line
# then unpack it by saving it in a file and typing "sh file"
# (Files unpacked will be owned by you and have default permissions).
# This archive contains the following files:
#	./htrans.c
#	./plot.doc
#	./src.chr
#	./srd.chr
#	./srp.chr
#	./srs.chr
#	./termio.c
#
if `test ! -s ./htrans.c`
then
echo "writing ./htrans.c"
sed 's/^X//' > ./htrans.c << '\Rogue\Monster\'
X/*
X		 HTRANS
X
XTranslate a range of character definitions in occidental.hsy into
Xan editable file format.
X
Xcompile: cc htrans -e1600
Xlink:    li htrans -n
X
XGreg Lee, 10/84
X
X*/
X#include <stdio.h>
X#include <sys/file.h>
X
Xchar cbuf[1024];
Xint cnum, firstc, lastc, cocnt, fd, i, maxi;
Xchar dummy, letter, bndflag, fname[20];
XFILE *fchr;
X
Xmain()
X{	/*int fd, i, maxi;
X	char fname[20];*/
X
X
X	printf("Htrans - Create file of plot points from Hershey database.\n");
X
X	if ((fd = open("occidental.hsy",O_RDONLY,"r")) == NULL)
X	{	printf("File occidental.hsy needed in current directory.");
X		exit(1);
X	}
X
X	printf("Output .chr file name?  : "); scanf("%s", fname);
X	strcat(fname, ".chr");
X	if ((fchr = fopen(fname, "w")) == NULL)
X	{	printf("Can't open %s for output.", fname);
X		exit(1);
X	}
X
X	printf("first number? : "); scanf("%d", &firstc);
X	scanf("%c", &dummy);
X	printf("first letter? : "); scanf("%c", &letter);
X	if (letter > ' ')
X	{	scanf("%c", &dummy);
X		printf("last letter?  : ");
X		scanf("%c", &bndflag);
X		lastc = firstc + bndflag - letter;
X	}
X	else { printf("last number?  : "); scanf("%d", &lastc); }
X
X	cnum = 0; cocnt = 0;
X	bndflag = 1;
X	i = 2;
X
X	maxi = read(fd, cbuf, 1024);
X
X	for (; cnum <= lastc ; i++,i++)
X	{	if (i >= maxi)
X		{	i = 0;
X			if (maxi < 1024) break;
X			maxi = read(fd, cbuf, 1024);
X			if (!maxi) break;
X		}
X
X		if (dspc(cbuf[i], cbuf[i+1]))
X		 if (letter > ' ' && letter < 128)
X			fprintf(fchr, "'%c': ", letter++);
X		 else fprintf(fchr,"%d: ", cnum);
X	}
X
X	fprintf(fchr, "\n");
X	fclose(fchr);
X
X}
X
Xdspc(b1, b2)
Xchar b1, b2;
X{	int i1, i2;
X
X	i1 = b1 - 64; i2 = b2 - 64;
X
X	if (i1 == -64 && i2 == -64)
X	{	if (cnum >= firstc) fprintf(fchr," End Char\n");
X		cnum++;
X		cocnt = 0; bndflag = 1;
X		if (cnum >= firstc && cnum <= lastc) return(cnum);
X		return(0);
X	}
X
X	if (cnum < firstc) return(0);
X
X	if (i1 == -64 && i2 == 0)
X	{	fprintf(fchr," Pen Up\n    ");
X		cocnt = 0;
X	}
X	else
X	{	if (cocnt >8) {cocnt = 0; fprintf(fchr,"\n    ");}
X
X		if (bndflag)
X		{ fprintf(fchr,"Bounds(%d,%d)", i1,i2); bndflag = 0; }
X		else fprintf(fchr,"(%d,%d)", i1,i2);
X		cocnt++;
X	}
X
X	return(0);
X}
\Rogue\Monster\
else
  echo "will not over write ./htrans.c"
fi
if [ `wc -c ./htrans.c | awk '{printf $1}'` -ne 2077 ]
then
echo `wc -c ./htrans.c | awk '{print "Got " $1 ", Expected " 2077}'`
fi
if `test ! -s ./plot.doc`
then
echo "writing ./plot.doc"
sed 's/^X//' > ./plot.doc << '\Rogue\Monster\'
X
XEplot, Hplot -- (c) Greg Lee, October 1984 (revised July 1987)
X
X
XEplot is an interactive screen editor for modifying files of plotting
Xpoints, as a preliminary to using such files with Hplot to create
Xcharacter fonts. It will also create PostScript fonts, and .pl files
Xfor use with the TeX utility 'pltotf' to make .tfm files.
X
X
Xe	Edit		Enters edit mode. See below for subcommands.
X
Xc	Create		Make a new character ready to have plotting
X			points added in edit mode.
X
Xr	Read		Read plotting points from .chr file.
X
Xz	Zap		Get rid of all plotting info.
X
Xp	Plot		Plot a character.
X
Xv	Display		Display the currently plotted character.
X
Xb	Base		Set y-coordinate of base line (default 9).
X
Xh	Height		Set height of character above the base line (def. 22).
X
Xd	Depth		Set depth below base line (def. 7).
X
Xf	Factors		The stretch/shrink factors X1/X2 and Y1/Y2
X			modify the plotting points as they are read
X			in from the .chr file, as well as affecting
X			the editing display.
X
X^I	Italic		Points are sloped by I1/I2 as a .chr file is read.
X
Xt	Tall		Alter display mode for tall characters.
X
X^L	set Line style
X
X		The values of X Heavy, X Light, and Y Heavy, Y Light modify
X		the action of the line drawing algorithm. This is not
X		very useful.
X
X
X^S	set serif level
X
X		This has an effect only when a file of plotting points
X		is read in, and then only if the plotting points responsible
X		for drawing serifs have been identified with a prefix 'S'
X		or 's'. When the serif level is 0, points 'S(x,y)' and
X		's(x,y)' are ignored. When the level is 1, only points
X		'S(x,y)' are ignored.  For higher levels, all points are
X		used.
X
Xn	Name file	Change name of file (.chr, .ps, or .pl) to save in
X
Xs	Save .chr	Save edited plotting points in .chr file.
X
Xa	Save .a		Save edited plotting points in .a assembler src file.
X
X^P	save .ps file	Save edited plotting points as a PostScript font.
X
X^T	save .pl file	Create .pl file with char dimensions (to make .tfm file)
X
X?	info		(same as HPLOT command)
X
X\\	debug		(same as HPLOT command)
X
Xx	eXit
X
Xq	same as x
X
X
XEdit mode commands:
X
X
XCursor movement
X
X	^S	cursor left
X	^D	cursor right
X	^E	cursor up
X	^X	cursor down
X	^R	cursor up 8
X	^C	cursor down 8
X	^A	cursor left 8
X	^F	cursor right 8
X	^W	scroll up
X	^Z	scroll down
X	^Q	center scroll
X
XControl
X
X	CR	end edit
X	^L	plot Letter
X	^N	New plot
X
XPen movement
X
X   any non-control character (other than Space)
X		pen to beginning of line named by character
X
X	^B	pen Back to previous point
X	Space	pen forward to next point
X	^U	pen Up
X
X
XPlotting point modification
X
X	^P	change Point
X	^I	Insert point
X	^G	delete point
X	^Y	delete line
X	^T	pull points toward cursor, when followed by:
X			u	pulls points above (Up)
X			d	pulls points below (Down)
X			r	pulls at right
X			l	pulls at left
X	   or	push points away from cursor, when followed by:
X			U	pushes above
X			D	pushes below
X			R	pushes at right
X			L	pushes at left
X	^H	change next line to hairline
X
X
X
XHPLOT -- Greg Lee, October, 1984
X
X
X
XHplot creates fonts from lists of plotting points for each character.
XSource plotting points are in an editable text file. Text files of
Xplotting points can be extracted from the Hershey data base with the
Xutility program HTRANS (see below). The raster fonts created are in
Xunix vfont format.
X
XIn outline, the procedure for creating a font is:
X	A. read one or more files of plotting points (with the 'r' command)
X	B. set various parameters determining size and style
X	C. plot characters (with the 'p' or 'V' commands)
X	D. assign a name to the font (with the 'n' command)
X	E. generate and save the font (with the 'g' command)
X	F. exit (with the 'x' command)
X
XHere is a list of commands available:
X
Xr	Read in a file of plotting points
X
X		A plotting point is specified in the form '(x,y)',
X		where x and y are the x-coordinate and the
X		y-coordinate. The lowest y values correspond to
X		the top of the character (strangely enough). The
X		lists of points for each character are headed by
X		the character, surrounded by single quotes and followed
X		by a colon. (^ replaces the first single quote for a
X		control character.) There are various commands interspered
X		among the plotting points, namely:
X
X			End Char	to end the list for a character
X			Pen Up		to raise the pen
X			Hair		to raise the pen and draw only
X					 every other dot of the next line
X			Bounds(x1,x2)	to define the left and right
X					 boundaries of a character (but
X					 HPLOT currently ignores this)
X			Height(y)	to define the height of characters
X					 above the base line
X			x Height(y)	to define the height of character
X					 bodies above the base line
X			Base(y)		to define the distance of the base
X					 line below y-coordinate 0
X			Depth(y)	to define the depth of a character
X					 below the baseline
X			Bearings(x,y)	to define the amount of white space
X					 at the left and right of the inked
X					 portion of the character
X			S(x,y)		for a point of a big serif
X			s(x,y)		for a point of a small serif
X
X		Any stuff in the file which is not recognized as a point
X		or any of the other items listed above is ignored, along
X		with the remainder of the line in which it occurs.
X
X
Xz	Zap -- delete all plotting points
X
X		Plotting data (in a compressed format) is kept in
X		a buffer whose size depends on how much RAM happens to be
X		available in your system. If you're about to run out of
X		room, you'll want to clear out the buffer before reading
X		in another file of data.
X
Xp	Plot a character
X
X		The plotted character is shown on the screen with the
X		lines that were drawn identified as '1','2',...,'9','A',...,
X		'Z','a',...,'z','"',....  This is some help in identifying
X		plotting points that need to be changed. When the character
X		crosses the base line, the latter is shown with '-'s.
X
X		The maximum size for a character plot is 160 by 160 dots
X		but at most 80 dots of width can be displayed.
X
Xg	Generate a font by plotting all characters for which plotting
X	points are available and save the font in the file named with the
X	'n' command.
X
Xc	Read a .fn2 font. A subsequent 'g' generates a vfont file with
X	equivalent rasters.
X
Xv	Display the last character plotted.
X
Xb	set the Base line adjust value
X
X		The base lines of characters are considered to be at this
X		value below y-coordinate 0.
X
Xh	set the Height value
X
X		The top of the character is considered to be at this
X		value above the base line. The height and the base line
X		will determine which vertical portion of the plotted character
X		is placed in the font.
X
Xd	set the Depth value
X
Xf	set the magnification Factors
X
X		As characters are plotted, they are stretched or shrunk
X		by X1/X2 horizontally, and they are stretched or shrunk
X		by Y1/Y2 vertically. Negative fractions cause reflections
X		about the y- or x- axis.
X
X2	set the magnification Factors for other plot
X
X		If XX1 and XX2 or YY1 and YY2 are given non-zero values,
X		each character is plotted twice, once with the 2nd set
X		of magnification factors.
X
X^A	set factors for magnifying Ascenders
X
X		Ascenders of lower case letters are stretched or shrunk
X		by A1/A2. For this to work, commands 'Base(n)' and
X		'x Height(n)' must be present in the file of plotting
X		points.
X
X^D	set factors for magnifying Descenders
X
X		Descenders of lower case letters are stretched or shrunk
X		by D1/D2. For this to work, commands 'Base(n)' and
X		'x Height(n)' must be present in the file of plotting
X		points.
X
X^I	set factors for Italic slant
X
X		Positive I1/I2 back-slants characters to the left. This
X		is mainly useful for removing the rightward slant given
X		to some of the Hershey characters. If the font characters
X		are slanted, this produces ugly variations in spacing.
X
Xt	toggle Tall switch
X
X		Tall makes the font duplex, so that characters can be
X		up to 48 dots high.
X
X^P	set Pen style
X
X		The imaginary pen that draws the lines between pairs of
X		plotting points can be widened and tilted. Its width is
X		one plus the value assigned to Width. Thinking of it as
X		a brush for a moment, the x- and y-distances between
X		bristles are given as Delta X and Delta Y. If Square Pen
X		has the value 3, the pen takes on the shape of a hollow
X		square (or diamond), but for values of 1 or 2, only two or
X		three sides of the square are drawn.
X
X		The width of the pen can be varied with Blob and Delta
X		Blob. Each time the pen goes down it is widened by one
X		eighth of the value of Blob, but this is decreased by
X		Delta Blob for each dot that is drawn in the course of
X		the stroke. (The stroke begins at the end of the line
X		that is furthest from the x-axis.)
X
X		The pen style parameters are all treated as signed
X		values. The width of the blob goes toward 0, but it
X		may oscillate if Delta Blob is large.
X
X^H	sHade
X
X		Characters can be shaded on the lower right side with a
X		series of diagonals, whose length is defined by the
X		value of Shading. The separation from the body of the
X		character is given by Y Shade, and the spacing of the
X		lines from each other is controlled by X Shade.
X
X^L	set Line style
X
X		The values of X Heavy, X Light, and Y Heavy, Y Light modify
X		the action of the line drawing algorithm. This is not
X		very useful.
X
X^R	Retrace
X
X		Causes the next plotted character to overlay the last.
X
X^O	toggle Open switch
X
X		Open causes interior dots to be deleted.
X
Xl	toggle Light switch
X
X		Light causes every other interior dot to be deleted, and
X		insures that there will be no two contiguous horizontal
X		dots. This improves the appearance of fonts when used at
X		low resolution.
X
X^F	set Fill pattern
X
X		When ^O has been used to open up the interiors of characters,
X		the inside space can be filled with various patterns. The
X		pattern is configured by assigning values to the seven
X		parameters below. Except for Width, the number assigned
X		determines the periodicity of the pattern. Except for Width
X		and Grey, negative values give white-on-black instead of
X		black-on-white. For combinations of patterns, only dots
X		belonging to all the requested patterns are drawn.
X
X		Grey -- Fill with spaced dots. Values 0 and 1 have no effect.
X		A negative value prevents the outside of the character from
X		being drawn, and -1 does only this.
X
X		Vertical -- Vertical stripes.
X
X		Horizontal -- Horizontal stripes.
X
X		Checked -- Checkerboard pattern.
X
X		Hatched -- Cross-hatching.
X
X		Diagonal -- Diagonal stripes going from upper left to to
X		lower right. But if the value is negative, the stripes
X		go from lower left to upper right.
X
X		Width -- Controls the width of the stripes drawn for the
X		previous five types of pattern (Vertical, Horizontal,
X		Checked, Hatched, and Diagonal). If the value is 0, nothing
X		is drawn. Value 1 gives one dot wide lines, and value 2
X		gives stripes of width 1/2 the periodicity. Higher values
X		give wider stripes.
X
X^B	Box
X
X		Options for creating characters in boxes.
X
X		Width -- Sets the width of the box. Any non-zero value
X		causes a clearance of at least two dot-spaces to be left
X		on either side of each character.
X
X		Edge -- Sets the thickness of the edge.
X
X		Reverse -- A non-zero value causes a fill pattern for open
X		characters to be placed outside the character, rather than
X		inside.
X
X^S	set serif level
X
X		This has an effect only when a file of plotting points
X		is read in, and then only if the plotting points responsible
X		for drawing serifs have been identified with a prefix 'S'
X		or 's'. When the serif level is 0, points 'S(x,y)' and
X		's(x,y)' are ignored. When the level is 1, only points
X		'S(x,y)' are ignored.  For higher levels, all points are
X		used.
X
Xn	assign Name to font file
X
Xs	Save plotted characters in font file
X
X?	list commands and show room in buffers
X
X		Store room is what is left in the plotting point buffer.
X		Font room is what is left in the font buffer.
X
X\	debug
X
X		Shows more stuff on screen as characters are being plotted.
X
Xx	eXit to unix
X
X
X
X
X
XHTRANS utility
X
XThe Hershey data base of occidental characters is available in the National
XBureau of Standards Special Publication 424, but the machine-readable form
Xas supplied by the NBS (or with the Fancy Font system) is in a compressed,
Xnon-editable format. HPLOT, however, needs its plotting data in an editable
Xtext file. HTRANS will extract a continuous range of characters from the
Xcompressed file occidental.hsy and create the requisite text file. The
Xcompressed Hershey file is not in the same format as distributed by the NTIS.
X
XFour items of information are asked for by HTRANS:
X
X(1) the name of the text file to be made (the extension .CHR will be added)
X
X(2) the sequential number of the starting character in the Hershey data base,
X    from 0 to 1593 (these numbers are not the same as those given in the
X    NBS publication mentioned above)
X
X(3) the first letter to associate plotting data with --- you can answer
X    this query with a CR if you want the lists of points labeled by
X    Hershey number
X
X(4) the last letter in the range of letters to associate plotting data
X    or (if you answered the 3rd question with a CR)
X    the last sequential number in the Hershey data base
X
X
XWhen the points are labeled by Hershey number, you will have to edit the
Xfile later to replace the number labels with character labels, since HPLOT
Xneeds the latter.
\Rogue\Monster\
else
  echo "will not over write ./plot.doc"
fi
if [ `wc -c ./plot.doc | awk '{printf $1}'` -ne 13136 ]
then
echo `wc -c ./plot.doc | awk '{print "Got " $1 ", Expected " 13136}'`
fi
if `test ! -s ./src.chr`
then
echo "writing ./src.chr"
sed 's/^X//' > ./src.chr << '\Rogue\Monster\'
X'A': Bounds(-9,9)(0,-12)(-8,9) Pen Up
X    (0,-12)(8,9) Pen Up
X    (-5,2)(5,2) End Char
X'B': Bounds(-11,10)(-7,-12)(-7,9) Pen Up
X    (-7,-12)(2,-12)(5,-11)(6,-10)(7,-8)(7,-6)(6,-4)(5,-3)(2,-2) Pen Up
X    (-7,-2)(2,-2)(5,-1)(6,0)(7,2)(7,5)(6,7)(5,8)(2,9)
X    (-7,9) End Char
X'C': Bounds(-10,11)(8,-7)(7,-9)(5,-11)(3,-12)(-1,-12)(-3,-11)(-5,-9)(-6,-7)
X    (-7,-4)(-7,1)(-6,4)(-5,6)(-3,8)(-1,9)(3,9)(5,8)(7,6)
X    (8,4) End Char
X'D': Bounds(-11,10)(-7,-12)(-7,9) Pen Up
X    (-7,-12)(0,-12)(3,-11)(5,-9)(6,-7)(7,-4)(7,1)(6,4)(5,6)
X    (3,8)(0,9)(-7,9) End Char
X'E': Bounds(-10,9)(-6,-12)(-6,9) Pen Up
X    (-6,-12)(7,-12) Pen Up
X    (-6,-2)(2,-2) Pen Up
X    (-6,9)(7,9) End Char
X'F': Bounds(-10,8)(-6,-12)(-6,9) Pen Up
X    (-6,-12)(7,-12) Pen Up
X    (-6,-2)(2,-2) End Char
X'G': Bounds(-10,11)(8,-7)(7,-9)(5,-11)(3,-12)(-1,-12)(-3,-11)(-5,-9)(-6,-7)
X    (-7,-4)(-7,1)(-6,4)(-5,6)(-3,8)(-1,9)(3,9)(5,8)(7,6)
X    (8,4)(8,1) Pen Up
X    (3,1)(8,1) End Char
X'H': Bounds(-11,11)(-7,-12)(-7,9) Pen Up
X    (7,-12)(7,9) Pen Up
X    (-7,-2)(7,-2) End Char
X'I': Bounds(-4,4)(0,-12)(0,9) End Char
X'J': Bounds(-8,8)(4,-12)(4,4)(3,7)(2,8)(0,9)(-2,9)(-4,8)(-5,7)
X    (-6,4)(-6,2) End Char
X'K': Bounds(-11,10)(-7,-12)(-7,9) Pen Up
X    (7,-12)(-7,2) Pen Up
X    (-2,-3)(7,9) End Char
X'L': Bounds(-10,7)(-6,-12)(-6,9) Pen Up
X    (-6,9)(6,9) End Char
X'M': Bounds(-12,12)(-8,-12)(-8,9) Pen Up
X    (-8,-12)(0,9) Pen Up
X    (8,-12)(0,9) Pen Up
X    (8,-12)(8,9) End Char
X'N': Bounds(-11,11)(-7,-12)(-7,9) Pen Up
X    (-7,-12)(7,9) Pen Up
X    (7,-12)(7,9) End Char
X'O': Bounds(-11,11)(-2,-12)(-4,-11)(-6,-9)(-7,-7)(-8,-4)(-8,1)(-7,4)(-6,6)
X    (-4,8)(-2,9)(2,9)(4,8)(6,6)(7,4)(8,1)(8,-4)(7,-7)
X    (6,-9)(4,-11)(2,-12)(-2,-12) End Char
X'P': Bounds(-11,10)(-7,-12)(-7,9) Pen Up
X    (-7,-12)(2,-12)(5,-11)(6,-10)(7,-8)(7,-5)(6,-3)(5,-2)(2,-1)
X    (-7,-1) End Char
X'Q': Bounds(-11,11)(-2,-12)(-4,-11)(-6,-9)(-7,-7)(-8,-4)(-8,1)(-7,4)(-6,6)
X    (-4,8)(-2,9)(2,9)(4,8)(6,6)(7,4)(8,1)(8,-4)(7,-7)
X    (6,-9)(4,-11)(2,-12)(-2,-12) Pen Up
X    (1,5)(7,11) End Char
X'R': Bounds(-11,10)(-7,-12)(-7,9) Pen Up
X    (-7,-12)(2,-12)(5,-11)(6,-10)(7,-8)(7,-6)(6,-4)(5,-3)(2,-2)
X    (-7,-2) Pen Up
X    (0,-2)(7,9) End Char
X'S': Bounds(-10,10)(7,-9)(5,-11)(2,-12)(-2,-12)(-5,-11)(-7,-9)(-7,-7)(-6,-5)
X    (-5,-4)(-3,-3)(3,-1)(5,0)(6,1)(7,3)(7,6)(5,8)(2,9)
X    (-2,9)(-5,8)(-7,6) End Char
X'T': Bounds(-8,8)(0,-12)(0,9) Pen Up
X    (-7,-12)(7,-12) End Char
X'U': Bounds(-11,11)(-7,-12)(-7,3)(-6,6)(-4,8)(-1,9)(1,9)(4,8)(6,6)
X    (7,3)(7,-12) End Char
X'V': Bounds(-9,9)(-8,-12)(0,9) Pen Up
X    (8,-12)(0,9) End Char
X'W': Bounds(-12,12)(-10,-12)(-5,9) Pen Up
X    (0,-12)(-5,9) Pen Up
X    (0,-12)(5,9) Pen Up
X    (10,-12)(5,9) End Char
X'X': Bounds(-10,10)(-7,-12)(7,9) Pen Up
X    (7,-12)(-7,9) End Char
X'Y': Bounds(-9,9)(-8,-12)(0,-2)(0,9) Pen Up
X    (8,-12)(0,-2) End Char
X'Z': Bounds(-10,10)(7,-12)(-7,9) Pen Up
X    (-7,-12)(7,-12) Pen Up
X    (-7,9)(7,9) End Char
X
X)(-2,9)(2,9)(4,8)(6,6)(7,4)(8,1)(8,-4)(7,-7)
X    (6,-9)(4,-11)(2,-12)(-2,-12) Pen Up
\Rogue\Monster\
else
  echo "will not over write ./src.chr"
fi
if [ `wc -c ./src.chr | awk '{printf $1}'` -ne 2992 ]
then
echo `wc -c ./src.chr | awk '{print "Got " $1 ", Expected " 2992}'`
fi
if `test ! -s ./srd.chr`
then
echo "writing ./srd.chr"
sed 's/^X//' > ./srd.chr << '\Rogue\Monster\'
X'0': Bounds(-10,10)(-1,-12)(-4,-11)(-6,-8)(-7,-3)(-7,0)(-6,5)(-4,8)(-1,9)
X    (1,9)(4,8)(6,5)(7,0)(7,-3)(6,-8)(4,-11)(1,-12)(-1,-12) End Char
X'1': Bounds(-10,10)(-4,-8)(-2,-9)(1,-12)(1,9) End Char
X'2': Bounds(-10,10)(-6,-7)(-6,-8)(-5,-10)(-4,-11)(-2,-12)(2,-12)(4,-11)(5,-10)
X    (6,-8)(6,-6)(5,-4)(3,-1)(-7,9)(7,9) End Char
X'3': Bounds(-10,10)(-5,-12)(6,-12)(0,-4)(3,-4)(5,-3)(6,-2)(7,1)(7,3)
X    (6,6)(4,8)(1,9)(-2,9)(-5,8)(-6,7)(-7,5) End Char
X'4': Bounds(-10,10)(3,-12)(-7,2)(8,2) Pen Up
X    (3,-12)(3,9) End Char
X'5': Bounds(-10,10)(5,-12)(-5,-12)(-6,-3)(-5,-4)(-2,-5)(1,-5)(4,-4)(6,-2)
X    (7,1)(7,3)(6,6)(4,8)(1,9)(-2,9)(-5,8)(-6,7)(-7,5) End Char
X'6': Bounds(-10,10)(6,-9)(5,-11)(2,-12)(0,-12)(-3,-11)(-5,-8)(-6,-3)(-6,2)
X    (-5,6)(-3,8)(0,9)(1,9)(4,8)(6,6)(7,3)(7,2)(6,-1)
X    (4,-3)(1,-4)(0,-4)(-3,-3)(-5,-1)(-6,2) End Char
X'7': Bounds(-10,10)(7,-12)(-3,9) Pen Up
X    (-7,-12)(7,-12) End Char
X'8': Bounds(-10,10)(-2,-12)(-5,-11)(-6,-9)(-6,-7)(-5,-5)(-3,-4)(1,-3)(4,-2)
X    (6,0)(7,2)(7,5)(6,7)(5,8)(2,9)(-2,9)(-5,8)(-6,7)
X    (-7,5)(-7,2)(-6,0)(-4,-2)(-1,-3)(3,-4)(5,-5)(6,-7)(6,-9)
X    (5,-11)(2,-12)(-2,-12) End Char
X'9': Bounds(-10,10)(6,-5)(5,-2)(3,0)(0,1)(-1,1)(-4,0)(-6,-2)(-7,-5)
X    (-7,-6)(-6,-9)(-4,-11)(-1,-12)(0,-12)(3,-11)(5,-9)(6,-5)(6,0)
X    (5,5)(3,8)(0,9)(-2,9)(-5,8)(-6,6) End Char
\Rogue\Monster\
else
  echo "will not over write ./srd.chr"
fi
if [ `wc -c ./srd.chr | awk '{printf $1}'` -ne 1311 ]
then
echo `wc -c ./srd.chr | awk '{print "Got " $1 ", Expected " 1311}'`
fi
if `test ! -s ./srp.chr`
then
echo "writing ./srp.chr"
sed 's/^X//' > ./srp.chr << '\Rogue\Monster\'
X*
X*	Simplex Roman punctuation
X*
X*21
X'!': Bounds(-5,5)(0,-12)(0,2) Pen Up
X    (0,7)(-1,8)(0,9)(1,8)(0,7) End Char
X*22
X'"': Bounds(-8,8)(-4,-12)(-4,-5) Pen Up
X    (4,-12)(4,-5) End Char
X*23
X'#': Bounds(-10,11)(1,-12)(-6,16) Pen Up
X    (7,-12)(0,16) Pen Up
X    (-6,-1)(8,-1) Pen Up
X    (-7,5)(7,5) End Char
X*24
X'$': Bounds(-10,10)(-2,-12)(-2,11) Pen Up
X    (2,-12)(2,11) Pen Up
X    (7,-7)(5,-9)(2,-10)(-2,-10)(-5,-9)(-7,-7)(-7,-6)(-6,-4)(-5,-3)
X    (-3,-2)(3,0)(5,1)(6,2)(7,4)(7,6)(5,8)(2,9)(-2,9)
X    (-5,8)(-7,6) End Char
X*25	918	%
X'%': Bounds(-12,12)(9,-12)(-9,9) Pen Up
X    (-4,-12)(-2,-10)(-2,-8)(-3,-6)(-5,-5)(-7,-5)(-9,-7)(-9,-9)(-8,-11)
X    (-6,-12)(-4,-12)(-2,-11)(1,-10)(4,-10)(7,-11)(9,-12) Pen Up
X    (5,2)(3,3)(2,5)(2,7)(4,9)(6,9)(8,8)(9,6)(9,4)
X    (7,2)(5,2) End Char
X*26
X'&': Bounds(-13,13)(10,-3)(10,-4)(9,-5)(8,-5)(7,-4)(6,-2)(4,3)(2,6)
X    (0,8)(-2,9)(-6,9)(-8,8)(-9,7)(-10,5)(-10,3)(-9,1)(-8,0)
X    (-1,-4)(0,-5)(1,-7)(1,-9)(0,-11)(-2,-12)(-4,-11)(-5,-9)(-5,-7)
X    (-4,-4)(-2,-1)(3,6)(5,8)(7,9)(9,9)(10,8)(10,7) End Char
X*27
X''': Bounds(-4,4)(3,-12)(0,-5) End Char
X*28
X'(': Bounds(-7,7)(4,-12)(2,-10)(0,-8)(-2,-5)(-3,0)(-3,4)(-2,9)(0,12)
X    (2,14)(4,16) End Char
X*29
X')': Bounds(-7,7)(-4,-12)(-2,-10)(0,-8)(2,-5)(3,0)(3,4)(2,9)(0,12)
X    (-2,14)(-4,16) End Char
X*2A
X'*': Bounds(-8,8)(0,-6)(0,6) Pen Up
X    (-5,-3)(5,3) Pen Up
X    (5,-3)(-5,3) End Char
X*2B
X'+': Bounds(-13,13)(0,-9)(0,9) Pen Up
X    (-9,0)(9,0) End Char
X*2C
X',': Bounds(-5,5)(1,8)(0,9)(-1,8)(0,7)(1,8)(1,10)(0,12)(-1,13) End Char
X*2D
X'-': Bounds(-13,13)(-4,0)(4,0) End Char
X*2E
X'.': Bounds(-5,5)(0,7)(-1,8)(0,9)(1,8)(0,7) End Char
X*2F
X'/': Bounds(-11,11)(9,-12)(-9,16) End Char
X*3A
X':': Bounds(-5,5)(0,-5)(-1,-4)(0,-3)(1,-4)(0,-5) Pen Up
X    (0,7)(-1,8)(0,9)(1,8)(0,7) End Char
X*3B
X';': Bounds(-5,5)(0,-5)(-1,-4)(0,-3)(1,-4)(0,-5) Pen Up
X    (1,8)(0,9)(-1,8)(0,7)(1,8)(1,10)(0,12)(-1,13) End Char
X*3C	888	<
X'<': Bounds(-12,12)(8,-9)(-8,0)(8,9) End Char
X*3D
X'=': Bounds(-13,13)(-9,-3)(9,-3) Pen Up
X    (-9,3)(9,3) End Char
X*3E	889	>
X'>': Bounds(-12,12)(-8,-9)(8,0)(-8,9) End Char
X*3F
X'?': Bounds(-9,9)(-6,-7)(-6,-8)(-5,-10)(-4,-11)(-2,-12)(2,-12)(4,-11)(5,-10)
X    (6,-8)(6,-6)(5,-4)(4,-3)(0,-1)(0,2) Pen Up
X    (0,7)(-1,8)(0,9)(1,8)(0,7) End Char
X*40	920	@
X'@': Bounds(-13,14)(5,-4)(4,-6)(2,-7)(-1,-7)(-3,-6)(-4,-5)(-5,-2)(-5,1)
X    (-4,3)(-2,4)(1,4)(3,3)(4,1) Pen Up
X    (-1,-7)(-3,-5)(-4,-2)(-4,1)(-3,3)(-2,4) Pen Up
X    (5,-7)(4,1)(4,3)(6,4)(8,4)(10,2)(11,-1)(11,-3)(10,-6)
X    (9,-8)(7,-10)(5,-11)(2,-12)(-1,-12)(-4,-11)(-6,-10)(-8,-8)(-9,-6)
X    (-10,-3)(-10,0)(-9,3)(-8,5)(-6,7)(-4,8)(-1,9)(2,9)(5,8)
X    (7,7)(8,6) Pen Up
X    (6,-7)(5,1)(5,3)(6,4) End Char
X*5B
X'[': Bounds(-7,7)(-3,-12)(-3,16) Pen Up
X    (-3,-12)(4,-12) Pen Up
X    (-3,16)(4,16) End Char
X*5C
X'/': Bounds(-11,11)(-9,-12)(9,16) End Char
X*5D
X']': Bounds(-7,7)(3,-12)(3,16) Pen Up
X    (-4,-12)(3,-12) Pen Up
X    (-4,16)(3,16) End Char
X*5E	up arrow
X'^': Bounds(-8,8)(-2,-6)(0,-9)(2,-6) Pen Up
X    (-5,-3)(0,-8)(5,-3) Pen Up
X    (0,-8)(0,9) End Char
X*5F	_
X'_': Bounds(-13,13)(-9,16)(9,16) End Char
X*60	`
X'`': Bounds(-4,4)(-3,-12)(0,-5) End Char
X*7B
X'{': Bounds(-7,7)(2,-12)(0,-11)(-1,-10)(-2,-9)(-2,-7)(-1,-6)(0,-5)(1,-3)
X    (1,-1)(-1,1) Pen Up
X    (0,-11)(-1,-9)(-1,-8)(0,-7)(1,-6)(2,-4)(2,-2)(1,0)(-3,2)
X    (1,4)(2,6)(2,8)(1,10)(0,11)(-1,12)(-1,13)(0,15) Pen Up
X    (-1,3)(1,5)(1,7)(0,9)(-1,10)(-2,11)(-2,13)(-1,14)(0,15)
X    (2,16) End Char
X*7C
X'|': Bounds(-4,4)(0,-12)(0,16) End Char
X*7D
X'}': Bounds(-7,7)(-2,-12)(0,-11)(1,-10)(2,-9)(2,-7)(1,-6)(0,-5)(-1,-3)
X    (-1,-1)(1,1) Pen Up
X    (0,-11)(1,-9)(1,-8)(0,-7)(-1,-6)(-2,-4)(-2,-2)(-1,0)(3,2)
X    (-1,4)(-2,6)(-2,8)(-1,10)(0,11)(1,12)(1,13)(0,15) Pen Up
X    (1,3)(-1,5)(-1,7)(0,9)(1,10)(2,11)(2,13)(1,14)(0,15)
X    (-2,16) End Char
X*7E	893	low tilde
X'~': Bounds(-12,12)(-9,3)(-9,1)(-8,-2)(-6,-3)(-4,-3)(-2,-2)(2,1)(4,2)
X    (6,2)(8,1)(9,-1) Pen Up
X    (-9,1)(-8,-1)(-6,-2)(-4,-2)(-2,-1)(2,2)(4,3)(6,3)(8,2)
X    (9,-1)(9,-3) End Char
X
X*FROM SPECIAL
X*from 894	low circumflex
X^D': Bounds(-11,11)(-8,-8)(0,-12)(8,-8) End Char
X*895	acute
X^C': Bounds(-6,6)(2,-12)(-3,-6) Pen Up
X    (2,-12)(3,-11)(-3,-6) End Char
X*896	grave
X^B': Bounds(-6,6)(-2,-12)(3,-6) Pen Up
X    (-2,-12)(-3,-11)(3,-6) End Char
X*897	short
X^S': Bounds(-10,10)(-7,-12)(-6,-10)(-4,-8)(-1,-7)(1,-7)(4,-8)(6,-10)(7,-12) Pen Up
X    (-7,-12)(-6,-9)(-4,-7)(-1,-6)(1,-6)(4,-7)(6,-9)(7,-12) End Char
X*923	section
X^M': Bounds(-8,8)(3,-9)(2,-8)(3,-7)(4,-8)(4,-9)(3,-11)(1,-12)(-1,-12)
X    (-3,-11)(-4,-9)(-4,-7)(-3,-5)(-1,-3)(4,0) Pen Up
X    (-3,-5)(2,-2)(4,0)(5,2)(5,4)(4,6)(2,8) Pen Up
X    (-2,-4)(-4,-2)(-5,0)(-5,2)(-4,4)(-2,6)(3,9) Pen Up
X    (-4,4)(1,7)(3,9)(4,11)(4,13)(3,15)(1,16)(-1,16)(-3,15)
X    (-4,13)(-4,12)(-3,11)(-2,12)(-3,13) End Char
X*924	dagger
X^K': Bounds(-8,8)(0,-12)(-1,-10)(0,-8)(1,-10)(0,-12) Pen Up
X    (0,-12)(0,16) Pen Up
X    (0,-1)(-1,2)(0,16)(1,2)(0,-1) Pen Up
X    (-6,-5)(-4,-4)(-2,-5)(-4,-6)(-6,-5) Pen Up
X    (-6,-5)(6,-5) Pen Up
X    (2,-5)(4,-4)(6,-5)(4,-6)(2,-5) End Char
X*925	double dagger
X^L': Bounds(-8,8)(0,-12)(-1,-10)(0,-8)(1,-10)(0,-12) Pen Up
X    (0,-12)(0,2) Pen Up
X    (0,-2)(-1,0)(1,4)(0,6)(-1,4)(1,0)(0,-2) Pen Up
X    (0,2)(0,16) Pen Up
X    (0,12)(-1,14)(0,16)(1,14)(0,12) Pen Up
X    (-6,-5)(-4,-4)(-2,-5)(-4,-6)(-6,-5) Pen Up
X    (-6,-5)(6,-5) Pen Up
X    (2,-5)(4,-4)(6,-5)(4,-6)(2,-5) Pen Up
X    (-6,9)(-4,10)(-2,9)(-4,8)(-6,9) Pen Up
X    (-6,9)(6,9) Pen Up
X    (2,9)(4,10)(6,9)(4,8)(2,9) End Char
X
X
\Rogue\Monster\
else
  echo "will not over write ./srp.chr"
fi
if [ `wc -c ./srp.chr | awk '{printf $1}'` -ne 5410 ]
then
echo `wc -c ./srp.chr | awk '{print "Got " $1 ", Expected " 5410}'`
fi
if `test ! -s ./srs.chr`
then
echo "writing ./srs.chr"
sed 's/^X//' > ./srs.chr << '\Rogue\Monster\'
XHeight(22)
Xx Height(15)
XBase(9)
X'a': Bounds(-9,10)(6,-5)(6,9) Pen Up
X    (6,-2)(4,-4)(2,-5)(-1,-5)(-3,-4)(-5,-2)(-6,1)(-6,3)(-5,6)
X    (-3,8)(-1,9)(2,9)(4,8)(6,6) End Char
X'b': Bounds(-10,9)(-6,-12)(-6,9) Pen Up
X    (-6,-2)(-4,-4)(-2,-5)(1,-5)(3,-4)(5,-2)(6,1)(6,3)(5,6)
X    (3,8)(1,9)(-2,9)(-4,8)(-6,6) End Char
X'c': Bounds(-9,9)(6,-2)(4,-4)(2,-5)(-1,-5)(-3,-4)(-5,-2)(-6,1)(-6,3)
X    (-5,6)(-3,8)(-1,9)(2,9)(4,8)(6,6) End Char
X'd': Bounds(-9,10)(6,-12)(6,9) Pen Up
X    (6,-2)(4,-4)(2,-5)(-1,-5)(-3,-4)(-5,-2)(-6,1)(-6,3)(-5,6)
X    (-3,8)(-1,9)(2,9)(4,8)(6,6) End Char
X'e': Bounds(-9,9)(-6,1)(6,1)(6,-1)(5,-3)(4,-4)(2,-5)(-1,-5)(-3,-4)
X    (-5,-2)(-6,1)(-6,3)(-5,6)(-3,8)(-1,9)(2,9)(4,8)(6,6) End Char
X'f': Bounds(-5,7)(5,-12)(3,-12)(1,-11)(0,-8)(0,9) Pen Up
X    (-3,-5)(4,-5) End Char
X'g': Bounds(-9,10)(6,-5)(6,11)(5,14)(4,15)(2,16)(-1,16)(-3,15) Pen Up
X    (6,-2)(4,-4)(2,-5)(-1,-5)(-3,-4)(-5,-2)(-6,1)(-6,3)(-5,6)
X    (-3,8)(-1,9)(2,9)(4,8)(6,6) End Char
X'h': Bounds(-9,10)(-5,-12)(-5,9) Pen Up
X    (-5,-1)(-2,-4)(0,-5)(3,-5)(5,-4)(6,-1)(6,9) End Char
X'i': Bounds(-4,4)(-1,-12)(0,-11)(1,-12)(0,-13)(-1,-12) Pen Up
X    (0,-5)(0,9) End Char
X'j': Bounds(-5,5)(0,-12)(1,-11)(2,-12)(1,-13)(0,-12) Pen Up
X    (1,-5)(1,12)(0,15)(-2,16)(-4,16) End Char
X'k': Bounds(-9,8)(-5,-12)(-5,9) Pen Up
X    (5,-5)(-5,5) Pen Up
X    (-1,1)(6,9) End Char
X'l': Bounds(-4,4)(0,-12)(0,9) End Char
X'm': Bounds(-15,15)(-11,-5)(-11,9) Pen Up
X    (-11,-1)(-8,-4)(-6,-5)(-3,-5)(-1,-4)(0,-1)(0,9) Pen Up
X    (0,-1)(3,-4)(5,-5)(8,-5)(10,-4)(11,-1)(11,9) End Char
X'n': Bounds(-9,10)(-5,-5)(-5,9) Pen Up
X    (-5,-1)(-2,-4)(0,-5)(3,-5)(5,-4)(6,-1)(6,9) End Char
X'o': Bounds(-9,10)(-1,-5)(-3,-4)(-5,-2)(-6,1)(-6,3)(-5,6)(-3,8)(-1,9)
X    (2,9)(4,8)(6,6)(7,3)(7,1)(6,-2)(4,-4)(2,-5)(-1,-5) End Char
X'p': Bounds(-10,9)(-6,-5)(-6,16) Pen Up
X    (-6,-2)(-4,-4)(-2,-5)(1,-5)(3,-4)(5,-2)(6,1)(6,3)(5,6)
X    (3,8)(1,9)(-2,9)(-4,8)(-6,6) End Char
X'q': Bounds(-9,10)(6,-5)(6,16) Pen Up
X    (6,-2)(4,-4)(2,-5)(-1,-5)(-3,-4)(-5,-2)(-6,1)(-6,3)(-5,6)
X    (-3,8)(-1,9)(2,9)(4,8)(6,6) End Char
X'r': Bounds(-7,6)(-3,-5)(-3,9) Pen Up
X    (-3,1)(-2,-2)(0,-4)(2,-5)(5,-5) End Char
X's': Bounds(-8,9)(6,-2)(5,-4)(2,-5)(-1,-5)(-4,-4)(-5,-2)(-4,0)(-2,1)
X    (3,2)(5,3)(6,5)(6,6)(5,8)(2,9)(-1,9)(-4,8)(-5,6) End Char
X't': Bounds(-5,7)(0,-12)(0,5)(1,8)(3,9)(5,9) Pen Up
X    (-3,-5)(4,-5) End Char
X'u': Bounds(-9,10)(-5,-5)(-5,5)(-4,8)(-2,9)(1,9)(3,8)(6,5) Pen Up
X    (6,-5)(6,9) End Char
X'v': Bounds(-8,8)(-6,-5)(0,9) Pen Up
X    (6,-5)(0,9) End Char
X'w': Bounds(-11,11)(-8,-5)(-4,9) Pen Up
X    (0,-5)(-4,9) Pen Up
X    (0,-5)(4,9) Pen Up
X    (8,-5)(4,9) End Char
X'x': Bounds(-8,9)(-5,-5)(6,9) Pen Up
X    (6,-5)(-5,9) End Char
X'y': Bounds(-8,8)(-6,-5)(0,9) Pen Up
X    (6,-5)(0,9)(-2,13)(-4,15)(-6,16)(-7,16) End Char
X'z': Bounds(-8,9)(6,-5)(-5,9) Pen Up
X    (-5,-5)(6,-5) Pen Up
X    (-5,9)(6,9) End Char
X
\Rogue\Monster\
else
  echo "will not over write ./srs.chr"
fi
if [ `wc -c ./srs.chr | awk '{printf $1}'` -ne 2847 ]
then
echo `wc -c ./srs.chr | awk '{print "Got " $1 ", Expected " 2847}'`
fi
if `test ! -s ./termio.c`
then
echo "writing ./termio.c"
sed 's/^X//' > ./termio.c << '\Rogue\Monster\'
X#include "termio.h"
X
Xchar	*getenv(),		/* These are here so we can use termlib */
X	*tgetstr(),
X	PC;			/* global used for padding character */
X#undef	putchar			/* need to undefine it so we can redefine it */
Xint	putchar();
Xshort	ospeed;			/* global used by tputs */
Xchar	*term_name,
X	str_buf[60],
X	*ptr2ptr,
X	*cl_str,
X	*cm_str,
X	*ce_str,
X	terminfo_buff[1024];
X	
X
Xint	timer();		/* pre-declare for signal setup in unblocked_io	*/
Xjmp_buf	env;			/* environment storage for setjmp/longjmp */
X
Xstruct	sgttyb	org_stty,	/* Global so that we can restore Exact state */
X		cur_stty;
X
X/*
X	Assign_tty: Attempts to open a tty device by pathname (ie.
X	/dev/ttyi2). If successful, then return file descriptor, else
X	return -1. Will also set terminal for exclusive use mode if
X	open was successful.
X
X	On Entry: string pointer to tty pathname
X	On Exit:  file descriptor or -1 for failure
X*/
X
Xassign_tty(path)
Xchar	*path;
X{
Xint	tty_fd;
X
X	if ( (tty_fd = open(path, O_RDWR)) >= 0 )
X	{
X		if ( ioctl(tty_fd, TIOCEXCL) == -1 )
X		{
X			tty_fd = -1;
X		}
X	}
X	return((tty_fd < 0) ? -1 : tty_fd);
X}
X
X
X/*
X	Deassign_tty: Attempts to close a tty device by file descriptor.
X	First, will reset tty to non-exclusive use mode.
X
X	On Entry: int file descriptor
X	On Exit:  0 for success or -1 for failure
X*/
X
Xdeassign_tty(tty_fd)
Xint	tty_fd;
X{
X
X	ioctl(tty_fd, TIOCNXCL);
X	return(close(tty_fd));
X}
X
X
X/* 
X	Get_tty: Will return the current sgttyb structure information
X		 for a previously assigned tty.
X
X	On Entry: tty file descriptor, and a pointer to a structure to
X		  store the information in.
X	On Exit:  return -1 if error else tty info in structure if all ok
X*/
X
X
Xget_tty(tty_fd, tty_struct)
Xint	tty_fd;
Xstruct	sgttyb	*tty_struct;
X{
X	return(ioctl(tty_fd, TIOCGETP, tty_struct));
X}
X
X
X
X/* 
X	Set_tty: Will set a previously assigned tty to the parameters
X		 passed in the sgttyb structure.
X
X	On Entry: tty file descriptor, and a pointer to a structure to
X		  read the information from.
X	On Exit:  return -1 if error.
X*/
X
X
Xset_tty(tty_fd, tty_struct)
Xint	tty_fd;
Xstruct	sgttyb	*tty_struct;
X{
X	return(ioctl(tty_fd, TIOCSETP, tty_struct));
X}
X
X
X/*
X	Raw_tty: Attempts to open a tty device by pathname (ie.
X	/dev/ttyi2), and then will set terminal up for raw i/o
X	mode.
X
X	On Entry: string pointer to tty pathname
X	On Exit:  file descriptor or -1 for failure
X*/
X
Xraw_tty(terminal)
Xchar	*terminal;
X{
Xint	tty_fd;
X
X	if ( -1 == (tty_fd = assign_tty(terminal)) )
X	{
X		return(-1);		/* return with error code	*/
X	}
X
X	if ( -1 == get_tty(tty_fd, &org_stty) )
X	{
X		deassign_tty(tty_fd);
X		return(-1);		/* return with error code	*/
X	}
X
X	cur_stty = org_stty;		/* copy information	*/
X	cur_stty.sg_flags |= RAW;	/* raw mode (all 8 bits pass)	*/
X	cur_stty.sg_flags &= ~(TANDEM|ECHO|CRMOD);	/* remove all char processing */
X
X	if ( -1 == set_tty(tty_fd, &cur_stty) )
X	{
X		deassign_tty(tty_fd);
X		return(-1);		/* return with error code	*/
X	}
X	return(tty_fd);		/* all went well, return tty file desc	*/
X}
X
X
X/*
X	cbreak_tty: Attempts to open a tty device by pathname (ie.
X	/dev/ttyi2), and then will set terminal up for cbreak i/o
X	mode.
X
X	On Entry: string pointer to tty pathname
X	On Exit:  file descriptor or -1 for failure
X*/
X
Xcbreak_tty(terminal)
Xchar	*terminal;
X{
Xint	tty_fd;
X
X	if ( -1 == (tty_fd = assign_tty(terminal)) )
X	{
X		return(-1);		/* return with error code	*/
X	}
X
X	if ( -1 == get_tty(tty_fd, &org_stty) )
X	{
X		deassign_tty(tty_fd);
X		return(-1);		/* return with error code	*/
X	}
X
X	cur_stty = org_stty;		/* copy information	*/
X	cur_stty.sg_flags |= CBREAK;	/* raw mode (all 8 bits pass)	*/
X/*	cur_stty.sg_flags &= ~(TANDEM|ECHO|CRMOD); remove all char processing */
X
X	if ( -1 == set_tty(tty_fd, &cur_stty) )
X	{
X		deassign_tty(tty_fd);
X		return(-1);		/* return with error code	*/
X	}
X	return(tty_fd);		/* all went well, return tty file desc	*/
X}
X
X
X/*
X	cook_tty: Will set a terminal back to its original state by
X	file descriptor and will leave that descriptor open.
X
X	On Entry: tty file descriptor
X	On Exit:  returns 0 on success or -1 on failure
X*/
X
Xcook_tty(tty_fd)
Xint	tty_fd;
X{
X	if ( -1 == set_tty(tty_fd, &org_stty) )
X	{
X		return(-1);		/* return with error code	*/
X	}
X
X	return(0);	/* return with no errors	*/
X}
X
X
X/*
X	uncook_tty: Will set a terminal back to its raw state by
X	file descriptor and will leave that descriptor open.
X
X	On Entry: tty file descriptor
X	On Exit:  returns 0 on success or -1 on failure
X*/
X
Xuncook_tty(tty_fd)
Xint	tty_fd;
X{
X	if ( -1 == set_tty(tty_fd, &cur_stty) )
X	{
X		return(-1);		/* return with error code	*/
X	}
X
X	return(0);	/* return with no errors	*/
X}
X
X
X/*
X	reset_tty: Attempts to set a terminal back to its original state by
X	file descriptor and then will close tty file descriptor.
X
X	On Entry: tty file descriptor
X	On Exit:  returns 0 on success or -1 on failure
X*/
X
Xreset_tty(tty_fd)
Xint	tty_fd;
X{
X	if ( -1 == set_tty(tty_fd, &org_stty) )
X	{
X		deassign_tty(tty_fd);
X		return(-1);		/* return with error code	*/
X	}
X
X	deassign_tty(tty_fd);
X	return(0);	/* return with no errors	*/
X}
X
X
X/*
X	blocked_io: Attempts to set a terminal to blocked i/o mode by
X	file descriptor.
X
X	On Entry: tty file descriptor
X	On Exit:  returns fcntl value on success or -1 on failure
X*/
X
Xblocked_io(tty_fd)
Xint	tty_fd;
X{
Xint	f_flags;
X
X	f_flags = fcntl(tty_fd, F_GETFL, 0);	/* get current file flags */
X	if (f_flags == -1)
X	{
X		return(-1);
X	}
X	f_flags += FNDELAY;	/* no delay on read/write (no blocking i/o) */
X	return(fcntl(tty_fd, F_SETFL, f_flags));
X}
X
X
X/*
X	unblocked_io: Attempts to set a terminal to unblocked i/o mode by
X	file descriptor.
X
X	On Entry: tty file descriptor
X	On Exit:  returns fcntl value on success or -1 on failure
X*/
X
Xunblocked_io(tty_fd)
Xint	tty_fd;
X{
Xint	f_flags;
X
X	f_flags = fcntl(tty_fd, F_GETFL, 0);	/* get current file flags */
X	if (f_flags == -1)
X	{
X		return(-1);
X	}
X	f_flags -= FNDELAY;	/* delay on read/write (blocking i/o) */
X	return(fcntl(tty_fd, F_SETFL, f_flags));
X}
X
X
X/*	timer: Is an interrupt routine that will perform a longjmp 	*/
X/*		when it is called by the alarm interrupt.		*/
X
Xtimer(signal)
Xint	signal;	/* variable to catch signal sent to routine.	*/
X		/* we will just ignore it.			*/
X{
X	longjmp(env, 1);
X}
X
X
X/*	timed_read: Will attempt to read from the terminal specified	*/
X/*		    by the tty file descriptor for a set period of time.*/
X/*									*/
X/*	On Entry: tty file descriptor to read from, pointer to a byte	*/
X/*		  to return received char in number of bytes to read	*/
X/*		  and time in seconds.					*/
X/*	On Exit:  0 for ok read or -1 for no char received.		*/
X/*									*/
X
Xtimed_read(tty_fd, ch, count, seconds)
Xint	tty_fd,
X	count;
Xbyte	*ch;
Xunsigned	seconds;
X{
Xint	ret_code,
X	tim_code;
X
X
X	signal(SIGALRM, timer);
X	alarm(seconds);
X
X	ret_code = -1;	/* assume bad read */
X
X	tim_code = setjmp(env);
X	while ( (tim_code == 0) && (ret_code != 1) )
X	{
X		ret_code = read(tty_fd, ch, count);
X	}
X
X	alarm(0);	/* turn alarms off */
X	signal(SIGALRM, SIG_DFL);
X
X	return( ((ret_code != -1) && (ret_code == count)) ? 0 : -1 );
X}
X
X
X/*	stimed_read: Will attempt to read from the terminal specified	*/
X/*		    by the tty file descriptor for a set period of time.*/
X/*									*/
X/*	On Entry: tty file descriptor to read from, pointer to a byte	*/
X/*		  to return received char in.				*/
X/*		  and time in seconds.					*/
X/*	On Exit:  0 for ok read or -1 for no char received.		*/
X/*									*/
X
Xstimed_read(tty_fd, ch, seconds)
Xint	tty_fd;
Xbyte	*ch;
Xunsigned	seconds;
X{
Xint	ret_code,
X	tim_code;
X
X
X	signal(SIGALRM, timer);
X	alarm(seconds);
X
X	ret_code = -1;	/* assume bad read */
X
X	tim_code = setjmp(env);
X	while ( (tim_code == 0) && (ret_code != 1) )
X	{
X		ret_code = read(tty_fd, ch, 1);
X	}
X
X	alarm(0);	/* turn alarms off */
X	signal(SIGALRM, SIG_DFL);
X
X	return( (ret_code != -1) ? 0 : ret_code );
X}
X
X
Xterm_setup()
X{
X	term_name = getenv("TERM");	/* get terminal type name */
X	if (term_name == (char *) 0)	/* see if TERM is defined */
X	{
X		return(-1);		/* no, so return error */
X	}
X
X	if (tgetent(terminfo_buff, term_name) != 1)	/* read termcap info */
X	{
X		return(-1);		/* if not in termcap then return error */
X	}
X
X	gtty(1, &org_stty);		/* get stdout info */
X	ospeed = org_stty.sg_ospeed;	/* set global for tputs to use */
X
X	ptr2ptr = str_buf;		/* setup pointer to a pointer */
X	cm_str = tgetstr("pc", &ptr2ptr); /* get pad character */
X	if (cm_str)			/* if any pad character */
X	{
X		PC = *cm_str;		/* set global to it */
X	}
X	else
X	{
X		PC = 0;			/* else say no padding needed */
X	}
X
X	cl_str = tgetstr("cl", &ptr2ptr);	/* get clear screen string */
X	cm_str = tgetstr("cm", &ptr2ptr);	/* get cursor motion string */
X	ce_str = tgetstr("ce", &ptr2ptr);	/* get clear to end of line */
X
X	return(0);		/* return all ok */
X}
X
X
Xcls()
X{
X	tputs(cl_str, tgetnum("li"), putchar);
X}
X
Xclr_eol()
X{
X	tputs(ce_str, tgetnum("li"), putchar);
X}
X
X
Xmov_cur(col, line)
Xint	col,
X	line;
X{
X	/*col--;*/		/* termlib starts screens at 0,0 so we */
X	/*line--;*/		/* need to normalize OUR coordinates */
X
X	tputs(tgoto(cm_str, col, line), 1, putchar);
X}
X
X
Xtolower(ch)
Xchar	ch;
X{
X	return( ( (ch >= 'A') && (ch <= 'Z') ) ? ch + ' ' : ch );
X}
\Rogue\Monster\
else
  echo "will not over write ./termio.c"
fi
if [ `wc -c ./termio.c | awk '{printf $1}'` -ne 8994 ]
then
echo `wc -c ./termio.c | awk '{print "Got " $1 ", Expected " 8994}'`
fi
echo "Finished archive 2 of 4"
# if you want to concatenate archives, remove anything after this line
exit

