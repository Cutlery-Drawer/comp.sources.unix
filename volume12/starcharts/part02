Subject:  v12i072:  StarChart program and Yale star data, Part02/07
Newsgroups: comp.sources.unix
Sender: sources
Approved: rs@uunet.UU.NET

Submitted-by: awpaeth@watcgl.waterloo.edu (Alan W. Paeth)
Posting-number: Volume 12, Issue 72
Archive-name: starchart/part02

# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
#
# Wrapped by watcgl!awpaeth on Mon Oct  5 18:39:01 EDT 1987
# Contents:  starlaser.c starpic.c starpost.c startek.c starchart.1 epoch.c
#	moonphase.c messier.star ephem.star con.locs
 
echo x - starlaser.c
sed 's/^@//' > "starlaser.c" <<'@//E*O*F starlaser.c//'
/*
** Hewlett-Packard Laserjet (2686a) laser printer driver
** for starchart.
** Low-level routines (starting with 'HPLJET') written and copyrighted by
** Jyrki Yli-Nokari (jty@intrin.FI),
** Petri Launiainen (pl@intrin.FI),
** Intrinsic, Ltd.,  FINLAND.
**
** You may use this code as you wish if credit is given and this message
** is retained.
*/

/*
** This code is intended for ALL Laserjet family printers.
** Because the base version has only 59 k raster buffer, the
** stars are not completely round, but not too ugly either.
*/

#include <stdio.h>
#include "starchart.h"

char *calloc ();

#define SCALEU	29		/* graphics scaling */
#define SCALEL	40

#define TSCALEU	69		/* text mode scaling */
#define TSCALEL	10

#define XOFF	1060		/* text centering offset (in decipoints) */
#define YOFF	(-80)

#define HPLJETXMAX 743		/* Number of pixels in X-axis */
#define HPLJETYMAX 557		/* Number of pixels in Y-axis */

/*
** Chart parameters (limiting magnitude and window x,y,w,h)
*/

mapblock thumbnail =	{ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
			3.2, 1.0, 420, 35, 480, 195, 0.0 };

mapblock master =	{ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
			8.0, 3.0, 20, 265, 880, 500, 0.0 };

/*
** Generic functions
*/

vecopen ()
{
	HPLJETorient ();
	r_makeraster (HPLJETXMAX, HPLJETYMAX);
}

vecclose ()
{
	HPLJETdump ();
}

vecsize (points)
int points;
{
/**/
}

vecmove (x, y)
int x,y;
{
	x = (x*SCALEU)/SCALEL; /* adjust to bitmap size */
	y = (y*SCALEU)/SCALEL;

	HPLJETmove (x, y);
}

vecdraw (x, y)
int x,y;
{
	x = (x*SCALEU)/SCALEL; /* adjust to bitmap size */
	y = (y*SCALEU)/SCALEL;

	HPLJETdraw (x, y);
}

vecdrawdot(x, y)
    {
    vecdraw(x, y); /* dotted and solid the same? (any HP folks out there?) */
    }

vecdrawhyph(x, y)
    {
    vecdraw(x, y); /* ditto */
    }
    
/*
** Text handling is a pain because of separate text/graphics mode
** and separated axises
*/
vecsym (x, y, s)
int x,y;
char s;
{
	y = 767 - y; /* change y axis on text output */
	y -= 5; /* center character strings */
	x = (x*TSCALEU)/TSCALEL + XOFF; /* adjust to bitmap size */
	y = (y*TSCALEU)/TSCALEL + YOFF;

	printf ("\033&a%dh%dV%c", x, y, s);
}

vecsyms (x, y, s)
int x,y;
char *s;
{
	y = 767 - y; /* change y axis on text output */
	y -= 5; /* center character strings */
	x = (x*TSCALEU)/TSCALEL + XOFF; /* adjust to bitmap size */
	y = (y*TSCALEU)/TSCALEL + YOFF;

	printf ("\033&a%dh%dV%s", x, y, s);
}

vecmovedraw (x1, y1, x2, y2)
int x1, x2, y1, y2;
{
	x1 = (x1*SCALEU)/SCALEL; /* adjust to bitmap size */
	y1 = (y1*SCALEU)/SCALEL;

	x2 = (x2*SCALEU)/SCALEL; /* adjust to bitmap size */
	y2 = (y2*SCALEU)/SCALEL;

	HPLJETmove (x1, y1);
	HPLJETdraw (x2, y2);
}

drawlen (x, y, dx, dy, len)
int x, y, dx, dy, len;
{
	x = (x*SCALEU)/SCALEL; /* adjust to bitmap size */
	y = (y*SCALEU)/SCALEL;

	HPLJETmove (x + dx, y + dy);
	HPLJETdraw (x + dx + len - 1, y+dy);
}

/*
** Low Level Laserjet Plotting Routines
*/

HPLJETorient ()	/* switch to portrait text orientation mode */
{
	printf ("\033&l1O");
}

HPLJETmove (x, y)	/* move to (x,y) */
int x, y;
{
	r_move (x, y);
}

HPLJETdraw (x, y)	/* draw to (x,y) */
int x, y;
{
	r_draw (x, y);
}

#define IN(i,size)	((unsigned)i < size)
typedef char ritem;
typedef ritem *raster[];

static raster *r_p;	/* global pointer to raster */
static int r_currx, r_curry;	/* the current coordinates */
static int r_xsize, r_ysize;	/* the size of the raster */

/*
** set pixel (x,y) to value val (zero or nonzero).
*/
void
r_setpixel(x, y, val)
int x, y;
ritem val;
{
	if (IN(x, r_xsize) && IN(y, r_ysize)) {
		*(((*r_p)[y]) + x) = val;
	}
}

/*
** get pixel (x,y) value (0 or 1)
*/
int
r_getpixel(x, y)
{
	if (IN(x, r_xsize) && IN(y, r_ysize)) {
		return *(((*r_p)[y]) + x);
	}
	else
		return (0);
}

/*
** allocate the raster
*/
r_makeraster(x, y)
{
	register int j;
	
	/* allocate row pointers */
	if ((r_p = (raster *)calloc(y, sizeof(ritem *))) == NULL) {
		perror("Raster buffer allocation failure");
		exit(1);
	}
	for (j = 0; j < y; j++) {
		if (((*r_p)[j] = (ritem *)calloc(x, sizeof(ritem))) == NULL) {
			perror("Raster buffer allocation failure");
			exit(1);
		}
	}
	r_xsize = x; r_ysize = y;
	r_currx = r_curry = 0;
}
	
/*
** plot a line from (x0,y0) to (x1,y1)
*/
r_plot(x0, y0, x1, y1)
int x0, y0, x1, y1;
{
	int e, hx, hy, dx, dy, i;
	/*
	** We use Bresenham's alorithm for plotting
	** (IBM system journal 4(1):25-30, 1965)
	*/
	hx = abs(x1 - x0);
	hy = abs(y1 - y0);
	dx = (x1 > x0) ? 1 : -1;
	dy = (y1 > y0) ? 1 : -1;
	
	if (hx > hy) {
		/*
		** loop over x-axis
		*/
		e = hy + hy - hx;
		for (i = 0; i <= hx; i++) {
			r_setpixel(x0, y0, 1);
			if (e > 0) {
				y0 += dy;
				e += hy + hy - hx - hx;
			} else {
				e += hy + hy;
			}
			x0 += dx;
		}
	} else {
		/*
		** loop over y-axis
		*/
		e = hx + hx - hy;
		for (i = 0; i <= hy; i++) {
			r_setpixel(x0, y0, 1);
			if (e > 0) {
				x0 += dx;
				e += hx + hx - hy - hy;
			} else {
				e += hx + hx;
			}
			y0 += dy;
		}
	}
}

/*
** move to (x,y)
*/

r_move(x, y)
int x, y;
{
	r_currx = x;
	r_curry = y;
}

/*
** draw to (x,y)
** (move pen down)
*/

r_draw(x, y)
int x, y;
{
	r_plot(r_currx, r_curry, x, y);
	r_currx = x;
	r_curry = y;
}

/*
** free the allocated raster
*/
void
r_freeraster()
{
	int y;

	for (y = 0; y < r_ysize; y++) {
		free((char *)(*r_p)[y]);
	}
	free((char *)r_p);
}

HPLJETdump ()
{
	int x, y, i;
	unsigned v;

	printf("\033*t75R\033&a0r\033&a135C\033&a-2R\033*r1A");
	for (x = r_xsize-1; x >= 0; x--) {
		printf("\033*b%dW", r_ysize/8);
		for (y = r_ysize-8; y >= 0; y -= 8) {
			v = 0;
			for (i = 7; i >= 0; i--) {
				v = (v << 1) | r_getpixel(x, y + i);
			}
			putc(v, stdout);
		}
	}
	r_freeraster();
	printf("\033*rB\f");
}

vecsymsgk(str, x, y)
    char *str;
    {
    vecsyms(str, x, y);
    }
@//E*O*F starlaser.c//
chmod u=rwx,g=rwx,o=rwx starlaser.c
 
echo x - starpic.c
sed 's/^@//' > "starpic.c" <<'@//E*O*F starpic.c//'
/*
 * Unix Pic file format driver for startchart.c mainline
 */

#include <stdio.h>
#include "starchart.h"

#define PICFRAG 8	/* split long "move,draw,...,draw" chains for pic */
#define DNONE 0		/* track current line style for chains */
#define DSOLID 1
#define DDOT 2
#define DHYPH 3

static int style;
static float xold, yold;

/*
 * Chart parameters (limiting magnitude and window x,y,w,h)
 */

mapblock thumbnail =	{ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
			3.2, 1.0, 480, 0, 480, 240, 0.0 };

mapblock master =	{ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
			8.0, 3.0, 0, 370, 960, 960, 0.0 };

/*
 * Generic Star Drawing Stuff
 */

static int oldps, dcount;

#define PICSCALE (1.0/160.0) /* roughly 6.5/1024.0 */

float conv(i)
    {
    return(i*PICSCALE);
    }

vecsize(newps)
    int newps;
    {
    if (newps != oldps) printf("\n.ps %d", newps);
    oldps = newps;
    }

 vecopen()
   {
   printf(".nf\n.ll 6.75i\n.po 0.75i\n.RT\n.PS");
   vecsize(10);
   printf("\n.tl'Database: \\fIYale Star Catalog\\fP'\\s18\\fBStarChart\\fP\\s0'Software: \\fIAWPaeth@watCGL\\fP'");
   printf("\n.ll 7.25i");
   }

vecclose()
    {
    printf("\n.PE\n");
    fflush(stdout);
    }

vecmove(x, y)
    {
    dcount = 0;
    printf("\nline from %.3fi,%.3fi", xold = conv(x), yold = conv(y));
    style = DNONE;
    }

vecbreak()
    {		/* repost current location when changing line attributes */
    dcount = 0;
    printf("\nline from %.3fi,%.3fi", xold, yold);
    style = DNONE;
    }

vecdraw(x, y)
    {
    if ((style != DNONE) && (style != DSOLID)) vecbreak();
    printf(" to %.3fi,%.3fi", xold = conv(x), yold = conv(y));
    dcount++;
    if (dcount > PICFRAG) vecmove(x,y);	/* must fragment long pic commands */
    style = DSOLID;
    }

vecdrawdot(x, y)
    {
    if ((style != DNONE) && (style != DDOT)) vecbreak();
    printf(" to %.3fi,%.3fi dotted", xold = conv(x), yold = conv(y));
    dcount++;
    if (dcount > PICFRAG) vecmove(x,y);	/* must fragment long pic commands */
    style = DDOT;
    }

vecdrawhyph(x, y)
    {
    if ((style != DNONE) && (style != DHYPH)) vecbreak();
    printf(" to %.3fi,%.3fi dashed", xold = conv(x), yold = conv(y));
    dcount++;
    if (dcount > PICFRAG) vecmove(x,y);	/* must fragment long pic commands */
    style = DHYPH;
    }

vecsyms(x, y, s)
    char *s;
    {
    printf("\n\"\\ %s\" ljust at %.3fi,%.3fi", s, conv(x), conv(y));
    }

vecmovedraw(x1, y1, x2, y2)
    {
    vecmove(x1, y1);
    vecdraw(x2, y2);
    }

drawGalx(x, y)
    {
    vecsize(10);
    vecsymcen(x, y, "@");
    }

drawNebu(x, y)
    {
    vecsize(10);
    vecsymcen(x, y, "\\v'3p'~\\v'-3p'"); /* vertical motion to lower '~' */
    }

drawClus(x, y)
    {
    vecsize(10);
    vecsymcen(x, y, "%");
    }

drawPlan(x, y)
    {
    vecsize(10);
    vecsymcen(x, y, "+");
    }

vecsymcen(x, y, s)
    char *s;
    {
    printf("\n\"%s\" at %.3fi,%.3fi", s, conv(x), conv(y));
    }

drawStar(x, y, mag, type, color)
    char type, *color;
    {
    switch (mag)
	{
	case -1: vecsize(18); break;
	case  0: vecsize(18); break;
	case  1: vecsize(16); break;
	case  2: vecsize(12); break;
	case  3: vecsize(10); break;
	case  4: vecsize(8);  break;
	default: vecsize(6);  break;
	}
    switch (type)
	{
	default:
/*
 * unadulterated overstrikes to form star symbols
 */

	case 'S': vecsymcen(x, y, "\\(bu"); break;
	case 'D': vecsymcen(x, y, "\\o'\\(em\\(bu'"); break;
	case 'V': vecsymcen(x, y, "\\o'O\\(bu'"); break;

/*
 * an attempt to raise (with troff local motion commands) the bullet by
 * two printer's points, as it rides a touch low in the Waterloo fonts.
 */
/*
 *	case 'S': vecsymcen(x, y, "\\v'2p'\\(bu\\v'-2p'"); break;
 *	case 'D': vecsymcen(x, y, "\\o'\\(em\\v'2p'\\(bu\\v'-2p''"); break;
 *	case 'V': vecsymcen(x, y, "\\o'O\\v'2p'\\(bu\\v'-2p''"); break;
 */
	}
    }

/*
 * Additions for Greek fonts
 */

char *intable = " 0123456789abgdezh@iklmnEoprstuOx%w";
char *outtable[] = {
    " ", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
    "\\(*a", "\\(*b", "\\(*g", "\\(*d", "\\(*e", "\\(*z", "\\(*y", "\\(*h",
    "\\(*i", "\\(*k", "\\(*l", "\\(*m", "\\(*n", "\\(*c", "\\(*o", "\\(*p",
    "\\(*r", "\\(*s", "\\(*t", "\\(*u", "\\(*f", "\\(*x", "\\(*q", "\\(*w"
    };

vecsymsgk(x, y, s)
    char *s;
    {
    char ch, line[200];
    int i;
    line[0] = '\0';
    while (ch = *s++)
	{
	i = 0;
	while (intable[i] && (intable[i] != ch)) i++;
	strcat(line, intable[i] ? outtable[i] : " ");
	}
    printf("\n\"\\ %s\" ljust at %.3fi,%.3fi", line, conv(x), conv(y));
    }
@//E*O*F starpic.c//
chmod u=rwx,g=rwx,o=rwx starpic.c
 
echo x - starpost.c
sed 's/^@//' > "starpost.c" <<'@//E*O*F starpost.c//'
/*
 * PostScript file format driver for startchart.c mainline
 */

#include <stdio.h>
#include "starchart.h"

/*
 * Chart parameters (limiting magnitude and window x,y,w,h)
 */

mapblock thumbnail =	{ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
			3.2, 1.0, 480, 0, 480, 240, 0.0 };

mapblock master =	{ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
			8.0, 3.0, 0, 370, 960, 960, 0.0 };

/*
 * Generic Star Drawing Stuff
 */

#define PICSCALE (72.0/160.0) /* roughly 6.5 inches/1024.0 units */

static int oldps, vecstate;

out(s)
    char *s;
    {
    printf("%s\n", s);
    }

float conv(i)
    {
    return(i*PICSCALE+80);	/* 1.1" margins left and bottom */
    }

vecsize(newps)
    int newps;
    {
    if (newps != oldps) printf("%d fsize\n", newps);
    oldps = newps;
    }

vecopen()
    {
out("%!PSAdobe-1.0");
out("%%Creator: AWPaeth@watCGL");
out("%%Title: StarChart");
out("%%Pages: 1");
out("%%DocumentFonts Times-Bold Symbol");
out("%%BoundingBox 0 0 612 792");
out("%%EndComments");
out("%%EndProlog");
out("%%Page: 0 1");
out("%");
out("% alias moveto/drawto");
out("%");
out("/mt {moveto} def");				/* move to */
out("/st {lineto} def");				/* solid to */
out("/dt {[1] 0 setdash lineto [] 0 setdash} def");	/* dotted to */
out("/ht {[3] 0 setdash lineto [] 0 setdash} def");	/* hyphen to */
out("%");
out("% show: right, center, left adjust");
out("%");
out("/fsize {/Times-Bold findfont exch scalefont setfont} def");
out("/lshow {5 0 8#040 4 3 roll widthshow} def");
out("/cshow {dup stringwidth pop 2 div neg 0 rmoveto show} def");
out("/rshow {dup stringwidth pop neg 0 rmoveto show} def");
out("/gshow {currentfont exch");
out("        /Symbol findfont 10 scalefont setfont lshow setfont} def");
out("%");
out("% star/planet macros");
out("%");
out("/movereldraw {newpath 4 2 roll mt rlineto stroke} def");
out("/starminus {3 copy 0 movereldraw neg 0 movereldraw} def");
out("/starplus {3 copy 0 movereldraw 3 copy neg 0 movereldraw");
out( "          3 copy 0 exch movereldraw 0 exch neg movereldraw} def");
out("/starcirc {newpath 0 360 arc closepath stroke} def");
out("/starbody {newpath 0 360 arc closepath fill} def");
out("/starbodyvar {3 copy 1 add starcirc starbody} def");
out("/starbodydbl {3 copy dup 3 div add starminus starbody} def");
out("% non-stellar object macros (better designs most welcome)");
out("/planet  {2 copy 2.5 starcirc 3.5 starplus} def");
out("/galaxy  {2 copy 2.5 starcirc 3.5 starminus} def");
out("/nebula  {2 copy 1 setgray 2.5 starcirc 0 setgray [2] 0 setdash");
out("          2.5 starcirc [] 0 setdash} def");
out("/cluster {2.5 starcirc} def");
out("%");
out("/back {3 copy 0.5 add 1 setgray} def");
out("/fore {0 setgray} def");
out("/s {back starbody fore starbody} def");
out("/d {back starbodydbl fore starbodydbl} def");
out("/v {back starbodyvar fore starbodyvar} def");
out("/s0 {4.5 s} def");
out("/d0 {4.5 d} def");
out("/v0 {4.5 v} def");
out("/s1 {3.8 s} def");
out("/d1 {3.8 d} def");
out("/v1 {3.8 v} def");
out("/s2 {3.1 s} def");
out("/d2 {3.1 d} def");
out("/v2 {3.1 v} def");
out("/s3 {2.4 s} def");
out("/d3 {2.4 d} def");
out("/v3 {2.4 v} def");
out("/s4 {1.7 s} def");
out("/d4 {1.7 d} def");
out("/v4 {1.7 v} def");
out("/s5 {1.0 s} def");
out("/d5 {1.0 d} def");
out("/v5 {1.0 v} def");
out("%");
out("% alter line drawing defaults, guarentee solid black lines");
out("0.5 setlinewidth 2 setlinecap");
out("[] 0 setdash 0 setgray");
out("%");
out("% boiler-plate");
out("%");
vecsize(10);
out(" 76 685 mt (Database: Yale Star Catalog) show");
out("548 685 mt (Software: AWPaeth@watCGL) rshow");
vecsize(18);
out("314 685 mt (StarChart) cshow");
vecsize(10);
out("%");
out("% THE STUFF");
out("%");
    }

vecclose()
    {
    out("showpage");
    out("%");
    out("%%Trailer");
    out("%%Pages: 1");
    fflush(stdout);
    }

vecmove(x, y)
    {
    if (vecstate==2) printf("stroke\n");
    if (vecstate==2 || (vecstate == 0)) printf("newpath\n");
    printf("%.1f %.1f mt\n", conv(x), conv(y));
    vecstate = 1;
    }

vecdraw(x, y)
    {
    printf("%.1f %.1f st\n", conv(x), conv(y));
    vecstate = 2;
    }

vecdrawdot(x, y)
    {
    printf("%.1f %.1f dt\n", conv(x), conv(y));
    vecstate = 2;
    }

vecdrawhyph(x, y)
    {
    printf("%.1f %.1f ht\n", conv(x), conv(y));
    vecstate = 2;
    }

vecsyms(x, y, s)
    char *s;
    {
    vecmove(x,y-4);
    printf("(%s) lshow\n", s);
    }

vecmovedraw(x1, y1, x2, y2)
    {
    vecmove(x1, y1);
    vecdraw(x2, y2);
    }

drawPlan(x, y)
    {
    printf("%.1f %.1f planet\n", conv(x), conv(y));
    }

drawGalx(x, y)
    {
    printf("%.1f %.1f galaxy\n", conv(x), conv(y));
    }

drawNebu(x, y)
    {
    printf("%.1f %.1f nebula\n", conv(x), conv(y));
    }

drawClus(x, y)
    {
    printf("%.1f %.1f cluster\n", conv(x), conv(y));
    }

drawStar(x, y, mag, type, color)
    char type, *color;
    {
    char *code;
    switch (mag)
	{
	case -1: vecsize(18); break;
	case  0: vecsize(18); break;
	case  1: vecsize(16); break;
	case  2: vecsize(14); break;
	case  3: vecsize(12); break;
	case  4: vecsize(8); break;
	default: vecsize(6); break;
	}
    if (mag<0) mag = 0;
    if (mag>5) mag = 5;
    switch (type)
	{
	default:
	case 'S': code = "s"; break;
	case 'D': code = "d"; break;
	case 'V': code = "v"; break;
	}
    printf("%.1f %.1f %s%1d\n", conv(x), conv(y), code, mag);
    }

/*
 * Additions for Greek fonts
 */

char  *intable = " 0123456789abgdezh@iklmnEoprstuOx%w";
char *outtable = " 0123456789abgdezhqiklmnxoprstujcyw";

vecsymsgk(x, y, s)
    char *s;
    {
    char ch;
    int i, j;
    i = 0;
    while (ch = s[i])
	{
	j = 0;
	while (intable[j] && (intable[j] != ch)) j++;
	s[i] = intable[j] ? outtable[j] : ' ';
	i++;
	}
    vecmove(x,y-4);
    printf("(%s) gshow\n", s);
    }
@//E*O*F starpost.c//
chmod u=rwx,g=rwx,o=rwx starpost.c
 
echo x - startek.c
sed 's/^@//' > "startek.c" <<'@//E*O*F startek.c//'
/*
 * Tektronix driver for startchart.c mainline
 */

#include <stdio.h>
#include "starchart.h"

/*
 * The following rational fractions are for Tek output on limited (and
 * not 1024x768) bitmap devices, and attempt to cause graceful scaling of
 * glyphs, by defining the distance between adjacent output pixels in terms
 * of Tek coordinates. They should be fine-tuned for your Tektronix emulator.
 * Additional tuning (for rounding considerations) must take place in the
 * routine where the four values are referenced.
 *
 * Typical fractions are 5/8 (yields 640x480), 1/2, and 3/4
 *
 * For full resolution Tektronix devices (full 1024x768), all values are 1.
 */

#ifndef TEK
#define XSCALEI 5
#define XSCALEO 8
#define YSCALEI 5
#define YSCALEO 8
#else
#define XSCALEI 1
#define XSCALEO 1
#define YSCALEI 1
#define YSCALEO 1
#endif

/*
 * Chart parameters (limiting magnitude and window x,y,w,h)
 */

mapblock thumbnail =	{ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
			3.2, 1.0, 420, 35, 480, 195, 0.0 };

mapblock master =	{ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
			8.0, 3.0, 20, 265, 880, 500, 0.0 };

/*
 * Generic Star Drawing Stuff
 */

vecopen()
   {
   tekclear();
   }

vecclose()
    {
    tekmove(0,0);
    tekalpha();
    fflush(stdout);
    }

vecsize(points)
    int points;
    {
    }

vecmove(x, y)
    {
    tekmove(x, y);
    }

vecdraw(x, y)
    {
    tekdraw(x, y);
    }

vecdrawdot(x, y)
    {
    vecdraw(x, y);	/* dotted and solid the same */
    }

vecdrawhyph(x, y)
    {
    vecdraw(x, y);	/* dashed and solid the same */
    }


vecsym(x, y, s)
    char s;
    {
    tekmove(x, y-11); /* center character strings */
    tekalpha();
    printf("%c",s);
    }

vecsyms(x, y, s)
    char *s;
    {
    tekmove(x, y-11); /* center character strings */
    tekalpha();
    printf(s);
    }

vecmovedraw(x1, y1, x2, y2)
    {
    tekmove(x1, y1);
    tekdraw(x2, y2);
    fflush(stdout);
    }


drawlen(x, y, dx, dy, len)
    {
    vecmovedraw((x*XSCALEI/XSCALEO+dx)*XSCALEO/XSCALEI,
		(y*YSCALEI/YSCALEO+dy)*YSCALEO/YSCALEI,
		(x*XSCALEI/XSCALEO+dx+len-1)*XSCALEO/XSCALEI+1,
		(y*YSCALEI/YSCALEO+dy)*YSCALEO/YSCALEI);
    }

/*
 * Low Level Tektronix Plotting Routines
 */

#define	GS	035
#define	US	037
#define ESC	033
#define FF	014

static int oldHiY = 0, oldLoY = 0, oldHiX = 0;

tekplot()	/* switch to plot mode */
    {
    putchar(GS);
    putchar('@');
    oldHiY = oldLoY = oldHiX = 0;
    }

tekalpha()	/* switch to alpha mode */
    {
    putchar(US);
    fflush(stdout);
    }

tekclear()
    {
    putchar(ESC);
    putchar(FF);
    fflush(stdout);
    }

tekmove(x, y)	/* move to (x,y) */
    {
    putchar(GS);
    tekdraw(x, y);
    }

tekdraw(x, y)	/* draw to (x,y) */
    {
    int hiY, loY, hiX, loX;
    if (x < 0) x = 0;
    if (y < 0) y = 0;
    if (x > 1023) x = 1023;
    if (y > 767) y = 767;

    hiY = 0040 | (y>>5 & 037),
    loY = 0140 | (y    & 037),
    hiX = 0040 | (x>>5 & 037),
    loX = 0100 | (x    & 037);

    if (hiY != oldHiY) putchar(hiY);
    if (loY != oldLoY || hiX != oldHiX) putchar(loY);
    if (hiX != oldHiX) putchar(hiX);
    putchar(loX);

    oldHiY = hiY;
    oldLoY = loY;
    oldHiX = hiX;
    }

vecsymsgk(str, x, y)
    char *str;
    {
    vecsyms(str, x, y);
    }
@//E*O*F startek.c//
chmod u=rwx,g=rwx,o=rwx startek.c
 
echo x - starchart.1
sed 's/^@//' > "starchart.1" <<'@//E*O*F starchart.1//'
@.TH starchart LOCAL 9/22/87
@.ad b
@.SH NAME
stardsp, starpic, startek, starpost, starhp, starlaser
@.br
\- print astronomical star charts using Yale database.
@.SH SYNOPSIS
\fBstar* RA DE [ scale title maglim lbllim ]\fR
@.br
or
@.br
\fB-r Ra -d Dl -s scale -t title -m maglim -l lbllim -f x.star\fR
@.br
or
@.br
\fB-c constellation ...
@.SH DESCRIPTION
These programs generate star charts based on data extracted from the Yale
public domain star catalog.
Output is to the terminal 
@.RB ( stardsp ),
Unix PIC file format
@.RB ( starpic ),
Tektronix
vector format
@.RB ( startek ),
PostScript format
@.RB ( starpost ),
Hewlett-Packard terminal vector format
@.RB (starhp)
or in Hewlett-Packard Laserjet printer format
@.RB ( starlaser ).
@.PP
Star data is optionally overlayed with other cosmic objects, such as planets.
If limiting magnitudes are properly set and the Messier database is available,
Messier objects and some NGC objects are also printed.
@.PP
The starchart center is specified by two parameters: Right
Ascension [0.00 to 24.00 hours] and Declination [-90.00 to +90.00 degrees].
An optional third parameter defines the N/S range of the output window, in
degrees of declination.  Digits after decimal point are taken as minutes:
object positions can therefore be taken directly from a star catalog.
@.PP
An optional fourth parameter gives a title.  This conforms to the 'old'
Yale star chart format.  Two new parameters can be added after title,
defining the magnitude limit and label printing magnitude limit.  These
are discussed below.  All parameters can be given by using options,
which offers more flexibility. Parameters are:
@.TP
@.B \-r
Right ascension.
@.TP
@.B \-d
Declination.
@.TP
@.B \-s
Scale.
@.TP
@.B \-t
Title.  All these work as described above.  New options are:
@.TP
@.B \-m
Star limiting magnitude. This sets limits on the faintest stars displayed
on the "master" view. Default limits are device driver dependent (more below).
The "thumbnail" finder view is set to a related limit.
@.TP
@.B \-l
Label limiting magnitude. The new Yale database contains both a small set of
familiar names (for stars and special objects), plus an extensive list of
labels (Greek Bayer letter or Flamsteed numbers). Star names (including planet
names) always print for this small set. To avoid clutter, the labels may be
omitted below a cut-off magnitude by specifying this value.
@.TP
@.B \-c
A three or four character mnemonic follows, which is a search string for a
matching line-item entry in the file \fBcon.locs\fP. If found, then the
initial values for Ra, Decl, Scale and Title are taken from that file.
Because the command line is parsed from left to right, subsequent switches
might change the scale, title, or otherwise fine-tune the new defaults.
@.TP
@.B \-f
A file may be given containing ephemerides in the .star format, which will
overlay the output. This is also useful for generating constellation
boundaries, Milky Way isophots, and planet or satellite tracks. (The .star
format additionally includes records for vector and text annotation).
@.PP
The present implementations draw two viewports: a ``master'' chart plus a
``thumbnail'' overview with low limiting magnitude.
Their location and the limiting magnitude is specified by records in
the device driver, allowing the chart layout be tuned on a per-device basis.
The output is annotated with viewport boundaries, a legend and axis labels.
@.PP
Sanson's sinusoidal projection is used to map coordinates.
This projection preserves both area and linearity in Declination (y axis).
It gives good conformality (angle correctness) near the equator, so it is
useful along the Ecliptic.
Lines of RA converge at the poles (unlike cylindrical projections),
though Cassiopeia and the Dipper reproduce well.
@.SH EXAMPLES 
@.nf
# Sagittarius: a nice bunch of Messier objects.
starpost -c sgr -t "(Sagittarius 31 Oct 87)" >sag.ps
@.sp
# Orion: the belt lies near 5h40m in RA, just below the CE.
stardsp 5.32 -5 12 "Trapezium (Orion)" 8 5 | more
@.fi
@.SH FILES
@.nf
@.ta 2.6i
\fByale.star\fP	stellar information (mandatory)
\fBmessier.star\fP	Messier objects (optional)
\fBplanet.star\fP	Planets (optional)
\fBcon.locs\fP	default mnemonic locations
@.fi
@.br
@.sp
These default paths can be easily changed in the Makefile.
@.SH BUGS
No testing for bogus ranges and scales which may wrap the poles.
The present implementation expects
@.B yale.star
sorted by decreasing magnitude so that output is sequential, and then cuts off
below a limiting magnitude.
For more detailed charts spatial sorting is more appropriate.
@.PP
If <minutes> part of the parameters is greater than 59 it is silently
truncated to 59.
@.PP
All .star file coordinates are for epoch E2000.0. The Messier objects
in \fBmessier.star\fP were taken from precessed E1975.0 data. The additional
NGC objects were taken from data in the star atlas by \fINorton\fP and
precessed from E1950.0. Rough guesses on visual magnitude were made.
@.SH AUTHOR/EDITOR
Alan Paeth, University of Waterloo (AWPaeth@watCGL)
@.SH CONTRIBUTORS
Petri Launiainen (pl@intrin.FI)
@.br
Jyrki Yli-Nokari (jty@intrin.FI)
@.br
Robert Tidd (inp@VIOLET.BERKELEY.EDU)
@//E*O*F starchart.1//
chmod u=rwx,g=rwx,o=rwx starchart.1
 
echo x - epoch.c
sed 's/^@//' > "epoch.c" <<'@//E*O*F epoch.c//'
/*
 * epoch.c -- convert reduced Yale databases between epochs.
 *		(initial RA and DL fields rewritten, rest of input copied
 *		verbatim, so tool may be used on either reduced Yale dataset)
 *
 * copyright (c) 1987 by Alan Paeth
 *
 * transformations are based on equations appearing in
 * "Celestial BASIC" by Eric Burgess (SYBEX 1982)
 */

#include <stdio.h>
#include <math.h>

#define EPLOW 1850.0
#define EPHI  2100.0
#define DEFEIN 1950.0
#define DEFEOUT 2000.0

#define LINELEN 80

#define DLDEGSEC 3600.0
#define DLMINSEC 60.0
#define RAHRSSEC 54000.0
#define RAMINSEC 900.0
#define RASECSEC 15.0

#define DEGTORAD (3.14159265359/180.0)
#define DSIN(x) (sin((x)*DEGTORAD))
#define DCOS(x) (cos((x)*DEGTORAD))
#define DTAN(x) (tan((x)*DEGTORAD))

#define USAGE "{inputepoch=1950.0} {outputepoc=2000.0} <stdin >stdout"

char buf[LINELEN];	/* global to carry remainer of input line easily */

main(argc, argv)
    char **argv;
    {
    float r, d, r2, d2, ein, eout;
    ein  = DEFEIN;
    eout = DEFEOUT;
    switch (argc)
	{
	default: fprintf(stderr, "usage: [%s] %s\n", argv[0], USAGE); exit(1);
	case 3: eout = atof(argv[2]);
	case 2: ein =  atof(argv[1]);
	case 1: break;
	}
    if ((ein < EPLOW) || (ein > EPHI) || (eout < EPLOW) || (eout > EPHI))
	{
	fprintf(stderr, "epoch not in range [%.1f..%.1f]\n", EPLOW, EPHI);
	exit(1);
	}
    while(readline(&r, &d))
	{
	xform(r, d, &r2, &d2, ein, eout);		/* r2d2 ?! */
	writeline(r2, d2);
	}
    exit(0);
    }

readline(ra, de)
    float *ra, *de;
    {
    float rah, ram, ras, dld, dlm;
    char sign;

    fgets(buf, LINELEN, stdin);
    if (feof(stdin)) return(0);
    sscanf(buf, "%2f%2f%2f%c%2f%2f", &rah, &ram, &ras, &sign, &dld, &dlm);
    *ra = (RAHRSSEC*rah + RAMINSEC*ram + RASECSEC*ras)/DLDEGSEC;
    *de = (DLDEGSEC*dld + DLMINSEC*dlm)/DLDEGSEC;
    if (sign == '-') *de = -(*de);
    return(1);
    }

writeline(ra, de, rst)
    float ra, de;
    char *rst;
    {
    int rah, ram, ras, dld, dlm, sign;
    ra *= DLDEGSEC;
    rah = ra/RAHRSSEC;
    ra -= rah*RAHRSSEC;
    ram = ra/RAMINSEC;
    ra -= ram*RAMINSEC;
    ras = ra/RASECSEC;
    sign = (de < 0.0);
    if (sign) de = -de;
    dld = de;
    de -= dld;
    dlm = de * DLMINSEC + 0.5;
    if (dlm >= 60) dlm = 59;
    printf("%02d%02d%02d%s%02d%02d%s",
	rah, ram, ras, sign ? "-":"+", dld, dlm, &buf[11]);
    }

xform(rin, din, rout, dout, ein, eout)
    float rin, din, *rout, *dout, ein, eout;
    {
    float t, t2, x, y, z, w, d;
    t2 = ( (ein+eout)/2.0 - 1900.0 ) / 100.0;
    x = 3.07234 + (.00186 * t2);
    y = 20.0468 - (.0085 * t2);
    z = y/15;
    t = eout-ein;
    w = .0042 * t * (x + (z * DSIN(rin) * DTAN(din)) );
    d = .00028 * t * y * DCOS(rin);
    *rout = rin + w;
    if (*rout >= 360.0) *rout -= 360.0;
    if (*rout < 0.0) *rout += 360.0;
    *dout = din + d;
    }
@//E*O*F epoch.c//
chmod u=rwx,g=rwx,o=rwx epoch.c
 
echo x - moonphase.c
sed 's/^@//' > "moonphase.c" <<'@//E*O*F moonphase.c//'
/****************************************************************************
 pom.c

     Phase of the Moon. Calculates the current phase of the moon.
     Based on routines from `Practical Astronomy with Your Calculator',
        by Duffett-Smith.
     Comments give the section from the book that particular piece
        of code was adapted from.

     -- Keith E. Brandt  VIII 1984

 ****************************************************************************/

#include <stdio.h>
#include <sys/time.h>
#include <math.h>
#define PI         3.141592654
#define EPOCH   1983
#define EPSILONg 279.103035     /* solar ecliptic long at EPOCH */
#define RHOg     282.648015     /* solar ecliptic long of perigee at EPOCH */
#define e          0.01671626   /* solar orbit eccentricity */
#define lzero    106.306091     /* lunar mean long at EPOCH */
#define Pzero    111.481526     /* lunar mean long of perigee at EPOCH */
#define Nzero     93.913033     /* lunar mean long of node at EPOCH */

main()  {

double dtor();
double adj360();
double potm();

long *lo = (long *) calloc (1, sizeof(long)); /* used by time calls */
struct tm *pt; /* ptr to time structure */

double days;   /* days since EPOCH */
double phase;  /* percent of lunar surface illuminated */
double phase2; /* percent of lunar surface illuminated one day later */
int i = EPOCH;

time (lo);  /* get system time */
pt = gmtime(lo);  /* get ptr to gmt time struct */
cfree(lo);

/* calculate days since EPOCH */
days = (pt->tm_yday +1) + ((pt->tm_hour + (pt->tm_min / 60.0)
       + (pt->tm_sec / 3600.0)) / 24.0);
while (i < pt->tm_year + 1900)
   days = days + 365 + ly(i++);

phase = potm(days);
printf("The Moon is ");
if ((int)(phase + .5) == 100) {
   printf("Full\n");
   }
else if ((int)(phase + 0.5) == 0) 
   printf("New\n");
else if ((int)(phase + 0.5) == 50)  {
   phase2 = potm(++days);
   if (phase2 > phase)
      printf("at the First Quarter\n");
   else 
      printf("at the Last Quarter\n");
   }
else if ((int)(phase + 0.5) > 50) {
   phase2 = potm(++days);
   if (phase2 > phase)
      printf("Waxing ");
   else 
      printf("Waning ");
   printf("Gibbous (%1.0f%% of Full)\n", phase);
   }
else if ((int)(phase + 0.5) < 50) {
   phase2 = potm(++days);
   if (phase2 > phase)
      printf("Waxing ");
   else
      printf("Waning ");
   printf("Crescent (%1.0f%% of Full)\n", phase);
   }
}

double potm(days)
double days;
{
double N;
double Msol;
double Ec;
double LambdaSol;
double l;
double Mm;
double Ev;
double Ac;
double A3;
double Mmprime;
double A4;
double lprime;
double V;
double ldprime;
double D;
double Nm;

N = 360 * days / 365.2422;  /* sec 42 #3 */
adj360(&N);

Msol = N + EPSILONg - RHOg; /* sec 42 #4 */
adj360(&Msol);

Ec = 360 / PI * e * sin(dtor(Msol)); /* sec 42 #5 */

LambdaSol = N + Ec + EPSILONg;       /* sec 42 #6 */
adj360(&LambdaSol);

l = 13.1763966 * days + lzero;       /* sec 61 #4 */
adj360(&l);

Mm = l - (0.1114041 * days) - Pzero; /* sec 61 #5 */
adj360(&Mm);

Nm = Nzero - (0.0529539 * days);     /* sec 61 #6 */
adj360(&Nm);

Ev = 1.2739 * sin(dtor(2*(l - LambdaSol) - Mm)); /* sec 61 #7 */

Ac = 0.1858 * sin(dtor(Msol));       /* sec 61 #8 */
A3 = 0.37 * sin(dtor(Msol));

Mmprime = Mm + Ev - Ac - A3;         /* sec 61 #9 */

Ec = 6.2886 * sin(dtor(Mmprime));    /* sec 61 #10 */

A4 = 0.214 * sin(dtor(2 * Mmprime)); /* sec 61 #11 */

lprime = l + Ev + Ec - Ac + A4;      /* sec 61 #12 */

V = 0.6583 * sin(dtor(2 * (lprime - LambdaSol))); /* sec 61 #13 */

ldprime = lprime + V;                /* sec 61 #14 */

D = ldprime - LambdaSol;             /* sec 63 #2 */

return (50 * (1 - cos(dtor(D))));    /* sec 63 #3 */
}

ly(yr)
int yr;
{
/* returns 1 if leapyear, 0 otherwise */
return (yr % 4 == 0 && yr % 100 != 0 || yr % 400 == 0);
}

double dtor(deg)
double deg;
{
/* convert degrees to radians */
return (deg * PI / 180);
}

double adj360(deg)
double *deg;
{
/* adjust value so 0 <= deg <= 360 */
do if (*deg < 0)
   *deg += 360;
else if (*deg > 360)
   *deg -= 360;
while (*deg < 0 || *deg > 360);
}
@//E*O*F moonphase.c//
chmod u=rwx,g=rwx,o=rwx moonphase.c
 
echo x - messier.star
sed 's/^@//' > "messier.star" <<'@//E*O*F messier.star//'
053430+2202840ND    TAUm1  Crab Nebula
213317-0047700CG    AQRm2
134209+2821700CG    CVNm3
162302+2624640CG    SCOm4  ,unusually large
151916+0205620CG    SERm5  ,spectacular
173938-3213600GC    SCOm6  ,butterfly shape
175340-3448500GC    SCOm7  ,wider than m6
180332-2423600ND    SGRm8  Lagoon Nebula
171828-1831800CG    OPHm9  ,bright center
165719-0407700CG    OPHm10
185121-0616630GC    SCTm11 Wild Duck Cluster
164718-0158700CG    OPHm12
164154+3627570CG    HERm13 Great Hercules
173719-0315880CG    OPHm14
213013+1212700CG    PEGm15
181925-1347650CO    SERm16 Eagle
182127-1611700ND    SGRm17 Omega
181927-1708700CO    SGRm18
170233-2615800CG    OPHm19
180231-2302900ND    SGRm20 Trifid
180431-2230700CO    SGRm21
183632-2355590CG    SGRm22
175629-1901700CO    SGRm23
181828-1824500CO    SGRm24 ,very large
183229-1915600CO    SGRm25 ,colors, sprawling
184522-0924800CO    SCTm26
200005+2244760NP    VULm27 Dumbell
182433-2452760CG    SGRm28
202355+3832710CO    CYGm29 ,good at low pwr
214025-2308840CG    CAPm30 ,small
004322+4117480GS    ANDm31 Andromeda
004322+4053870GP    ANDm32 Andromeda Companion
013425+3041580GS    TRIm33 ,neb in face-on galaxy
024237+4249550CO    PERm34 ,bright, loose cl
060932+2421530CO    GEMm35
053640+3406630CO    AURm36 ,bright
055338+3233620CO    AURm37
052841+3549740CO    AURm38
213254+4828520CO    CYGm39 ,very large
064704-2044600CO    CMAm41
053514-0523500ND    ORIm42 Orion Nebula
053514-0516700ND    ORIm43
084026+1959370CO    CNCm44 Praesepe, Beehive Cl
034729+2408400CO    TAUm45 Pleiades
074209-1450700CO    PUPm46
073709-1430450CO    PUPm47 ,good binocular obj
081314-0546590SA    HYAm48 ,doubtful
123016+0759860GS    VIRm49 ,featureless glow
070312-0820600CO    MONm50
133003+4710860GS    CVNm51 Whirlpool
232407+6137760CO    CASm52 ,W-shaped, orange star SW corn
131314+1809760CG    COMm53 ,small dim
185436-3029770CG    SGRm54
193935-3057610CG    SGRm55
191658+3011860CG    LYRm56 ,like m53
185356+3303930NP    LYRm57 Ring Nebula
123816+1148960GS    VIRm58 ,dim near m59
124216+1139960GP    VIRm59 ,spherical
124416+1133970GP    VIRm60 ,spherical w/sga near
122217+0428990GS    VIRm61
170136-3007720CG    OPHm62
131607+4200950GS    CVNm63 ,bright
125714+2140880GS    COMm64 Black-Eye
111918+1305960GS    LEOm65 ,spindle shape
112018+1259840GS    LEOm66 ,near m65
085022+1148700CO    CNCm67
123920-2645900CG    HYAm68
183038-3221770CG    SGRm69
184238-3219820CG    SGRm70
195407+1847800CO    SGRm71 ,dim
205322-1233920CG    AQRm72
205722-1243850CO    AQRm73 ,very open 4 stars
013721+1549900GS    PSCm74 ,difficult
200529-2157830CG    SGRm75
014235+5136999NP    PERm76 Little Dumbell
024317+0002990GS    CETm77 ,small indistinct
054717+0003800ND    ORIm78
052402-2432830CG    LEPm79 ,small bright
161730-2259820CG    SCOm80
095603+6902760GS    UMAm81 Great Spiral in UMa
095605+6940880GS    UMAm82 ,spindle shape
133725-2954750GS    HYAm83 ,pale
122516+1252960GP    VIRm84 ,circular
122516+1810960GS    COMm85 ,small
122616+1255970GP    VIRm86 ,near m84
123116+1222960GP    VIRm87
123216+1424990GS    COMm88
123616+1232999GP    VIRm89
123716+1308990GS    VIRm90 ,bright nucleus
123616+1354999GS    COMm91 ,doubtful, comet
171746+4308710CG    HERm92 ,superb globular
074404-2352600CO    PUPm93
125111+4106890GS    CVNm94 ,very easy galaxy
104319+1144990GS    LEOm95
104719+1148960GS    LEOm96 ,very near m95
111527+5459999NP    UMAm97 Owl Nebula, very dim
121416+1453990GS    COMm98 ,faint, v.elongated
121916+1424990GS    COMm99 ,dim oval
122316+1548990GS    COMm100,v.faint
140253+5420840GS    UMAm101,use low magnif
013340+6043740GC    CASm103,easily resolved 30x
124018-1137840GS    VIRm104Sombrero
104819+1234960GS    LEOm105
121914+4717860GS    CVNm106,easy elongated
163224-1305920GC    OPHm107,pale globular
111227+5539990GS    UMAm108,near Merak, elongated
115818+5321990GS    UMAm109
004022+4143940GS    ANDm110,Andromeda companion
002408-7205500CG  47TUCNGC104
004332+6148650CI    CASNGC225
010225-7050600CG    TUCNGC362
011910+5819650CO    CASNGC457
014557+6115650CO    CASNGC663
022045+5709520CO    PERNGCGC869 Sword Handle
022358+5707520CO  x PERNGC884
053844-6907570ND    DORNGC2070 Looped Nebula
063240+0452570CO    MONNGC2244
074150-1812700NP    PUPNGC2440
075954-1035750CO    MONNGC2506
091159-6451700CG    CARNGC2808
102443-1838700NP    HYANGC3242
104457-5941700ND  n CARNGC3372 Keyhole Nebula
110626-5840700CO    CARNGC3532
113614-6137650CG    CENNGC3766
121859+4717750GS    CVNNGC4258
123624+2559700GS    COMNGC4565
125342-6021500CG  k CRUNGC4755 Jewel Box
132642-4719480CG  w CENNGC5139
134935+6010600ND    UMANGC5322
160341-6029600CO    TRANGC6025
161321-5413700CG    NORNGC6067
164428+2528700NP    HERNGC6210
175835+6638650NP    DRANGC6543
181238+0651800NP    OPHNGC6572
191050-5959700CG    PAVNGC6752
210408-1122700NP    AQRNGC7009 Saturn Nebula
221505+4953650CO    LACNGC7243
232549+4229700NP    ANDNGC7662
235133+1616500CO    PEGNGC7772
235702+5643800CO    CASNGC7789
@//E*O*F messier.star//
chmod u=rwx,g=rx,o=rx messier.star
 
echo x - ephem.star
sed 's/^@//' > "ephem.star" <<'@//E*O*F ephem.star//'
053500+0617500I        Orion's Shoulder
053500+0617500VM
052500+0714500VD
051500+0811500VS
050500+0908500VM
045500+1007500VH
044500+1104500VD
@//E*O*F ephem.star//
chmod u=rw,g=r,o=r ephem.star
 
echo x - con.locs
sed 's/^@//' > "con.locs" <<'@//E*O*F con.locs//'
/ con.locs	StarChart 'macro library' for canned views
/		Bob Tidd  inp@amber.berkeley.edu  6/87
/
/ This is a first cut and not a "cannonical" list of celestial locations.
/ Users should feel free to revise and extend (and post!) new versions.
/
/  column 4 coding (to distinguish "virgo area" from "virgo constellation"
/  c (or blank)=constellation
/  a=area
/  f=messier finder chart
/  t=time of year (evening sky)
/
/ columns 1-4 exclusively belong to the mnemonic, column five is ignored.
/ The remaining four parameters are three floats plus a string (terminated
/ by the end of line). The first two floats (Ra and Decl) appear in the
/ "hh" or "hh.mm" format used on the command line. Scale is a "traditional"
/ floating point value.
/
/...+....1....+....2....+....3....+
/
and  1     35   30   Andromeda ?
and  23.45 40   20   Andromeda
aqu  22.30 -5   30   Aquarius
ari  2.15  -18  18   Aries
aur  5.30  40   20   Auriga ?
boo  14.45 30   30   Bootes
can  8.30  18   20   Cancer
cap  21    -20  20   Capricorn
cas  1.0   60   15   Cassiopeia
cep  22    70   30   Cepheus
cet  7     -5   35   Cetus
cma  6.45  -20  20   Canis Major
com  13    25   10   Coma Bereneces
cor  15.45 28   10   Corona Borealis
cvn  13    40   10   Canes Venatici
cyg  20.30 40   30   Cygnus
equ  21.18 8    8    EQU
gem  7.30  20   30   Gemini
her  17    35   35   Hercules
hyd  11    -15  40   Hydra
lac  22.20 45   15   LAC
leo  11    20   30   Leo
lib  15    -20  20   Libra
lyr  18.30 35   12   Lyra
oph  17    0    30   Ophiuchius
ori  5.5   -.1  21   Orion
peg  23    30   20   Pegasus
per  3.30  45   35   Perseus
pis  1     15   40   Pisces
sco  17    -30  30   Scorpio
sct  18.35 -10  10   Scutum
sgr  18    -23  25   Sagittarius
trp  5.36  -5   12   Trapezium (Orion)
tau  4.30  20   30   Taurus
uma  12.30 55   30   Ursa Major
vir  13.0  -10  30   Virgo  +-
vul  19.30 25   10   Vulpecula
/
101f 14.05 54   3 M101 Area
andf 0.45  41   3 Andromeda, M31
coma 12.25 16   6 Coma Bereneces M100
dbcf 2.25  57   2.3 Double Cluster
hyaf 4.30  17   5 Hyades Cluster
m47f 7.35  15.4 3 M47 Finder
m81f 9.55  69   3 M81, M82
orif 5.35  -5   6 Orion Nebula
perf 3.25  49   4 Perseus Detail
plef 3.50  24   3 The Pleiades
praf 8.40  20   2 Praesepe, M44
sgra 18.10 -18  10 Sagitarius Cluster
umaf 11.25 58   12 Ursa Major Bowl
vira 12.25 14   8 Virgo Cluster
/
mayt 13.0  30   110 May Sky
@//E*O*F con.locs//
chmod u=rwx,g=rwx,o=rwx con.locs
 
exit 0

