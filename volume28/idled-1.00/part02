Newsgroups: comp.sources.unix
From: crider@cs.hope.edu (The FLASH)
Subject: v28i208: idled-1.00 - idle (et al) session detector/sanctioner, V1.00, Part02/02
References: <1.786345433.1153@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: crider@cs.hope.edu (The FLASH)
Posting-Number: Volume 28, Issue 208
Archive-Name: idled-1.00/part02

#!/bin/sh
# This is a shell archive (produced by GNU shar 4.0).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1994-12-01 23:50 EST by <crider@oin>.
# Source directory was `/home/crider/main/projects/idled'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#  21769 -rw-r--r-- idled-1.00/parse.c
#   3494 -rw-r--r-- idled-1.00/parse.y
#  17166 -rw-r--r-- idled-1.00/scan.c
#    976 -rw-r--r-- idled-1.00/scan.l
#   4949 -rw-r--r-- idled-1.00/warn.c
#   2530 -rw-r--r-- idled-1.00/xlock_check.c
#    500 -rw-r--r-- idled-1.00/y.tab.h
#   2078 -rw-r--r-- idled-1.00/zap.c
#
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo 'WARNING: not restoring timestamps'
fi
rm -f 1231235999 $$.touch
#
# ============= idled-1.00/parse.c ==============
if test ! -d 'idled-1.00'; then
  echo 'x - creating directory idled-1.00'
  mkdir 'idled-1.00'
fi
if test -f 'idled-1.00/parse.c' && test X"$1" != X"-c"; then
  echo 'x - skipping idled-1.00/parse.c (File already exists)'
else
  echo 'x - extracting idled-1.00/parse.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'idled-1.00/parse.c' &&
X
# line 2 "parse.y"
#include <stdio.h> 
#include <grp.h>
#include "idled.h"
X
int		num;
char		*name;
struct	group	*grp;
X
extern	char	*yytext;
X
extern	void	addlist();
X
X  /*
X   *  The order of the tokens in the *first line* is significant.  
X   *
X   *  They dictate which rules and exemptions have precence.
X   *  The second two %token lines may be ordered anyway. 
X   *  DEFAULT is the least specific, but will always match. 
X   *  It must always remain in the last position.
X   */ 
X
# line 31 "parse.y"
typedef union
#ifdef __cplusplus
X	YYSTYPE
#endif
X {
X	char *sb; 
X	int nb;
X       } YYSTYPE;
# define TTY 257
# define LOGIN 258
# define GROUP 259
# define DEFAULT 260
# define EXEMPT 261
# define TIMEOUT 262
# define SLEEP 263
# define WARN 264
# define CONSWINS 265
# define SESSION 266
# define REFUSE 267
# define NUM 268
# define IDLE 269
# define MULTIPLE 270
# define NAME 271
# define ALL 272
# define THRESHOLD 273
# define NL 274
# define NORMAL 275
# define OFF 276
X
#include <malloc.h>
#include <memory.h>
#include <values.h>
X
#ifdef __cplusplus
X
#ifndef yyerror
X	void yyerror(const char *);
#endif
X
#ifndef yylex
#ifdef __EXTERN_C__
X	extern "C" { int yylex(void); }
#else
X	int yylex(void);
#endif
#endif
X	int yyparse(void);
X
#endif
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
extern int yychar;
extern int yyerrflag;
YYSTYPE yylval;
YYSTYPE yyval;
typedef int yytabelem;
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
#if YYMAXDEPTH > 0
int yy_yys[YYMAXDEPTH], *yys = yy_yys;
YYSTYPE yy_yyv[YYMAXDEPTH], *yyv = yy_yyv;
#else	/* user does initial allocation */
int *yys;
YYSTYPE *yyv;
#endif
static int yymaxdepth = YYMAXDEPTH;
# define YYERRCODE 256
X
# line 182 "parse.y"
X
X
static	int	errorcnt = 0;
X
X
X
int
yyerror(sb)
char *sb;
{
X	extern	int	linenum;
X
X	logfile("%s: line %d: %s", CONFIG, linenum, sb);
X	errorcnt++;
X	return 0;
}
X
X
X
int
yywrap()
{
X	extern	int	linenum;
X        extern  time_t  conf_oldstamp;
X
X	if ( errorcnt > 0 && conf_oldstamp <= 1 )
X	{
X	    logfile("Aborting due to conf file syntax errors.");
X	    exit(1);
X	}
X
X	linenum = 1;
X	return 1;
}
yytabelem yyexca[] ={
-1, 1,
X	0, -1,
X	-2, 0,
X	};
# define YYNPROD 41
# define YYLAST 95
yytabelem yyact[]={
X
X    10,    39,    76,    75,    74,    12,    13,    15,    16,    17,
X    18,    14,    73,    36,    72,    71,    70,    19,    11,    52,
X    37,    38,    50,    49,    67,    47,    48,    65,    46,    64,
X     9,    63,    62,    61,    60,    59,    58,    57,    56,    55,
X    51,    20,    44,    35,    69,    33,    68,    66,    54,    53,
X     8,     7,    43,     6,     5,    34,    42,    32,    29,    26,
X    24,    25,    28,    41,    26,    24,    25,    31,    26,    24,
X    25,    22,    26,    24,    25,    21,     4,     3,     2,     1,
X    23,    45,     0,     0,     0,     0,     0,     0,     0,    27,
X    30,     0,     0,     0,    40 };
yytabelem yypact[]={
X
-10000000,  -256,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,
X  -233,-10000000,  -185,  -198,  -189,  -211,  -213,  -255,  -193,  -214,
-10000000,  -244,  -234,  -252,-10000000,-10000000,-10000000,  -219,  -220,  -235,
X  -236,  -237,  -238,  -239,  -240,  -241,  -242,  -243,  -245,  -247,
X  -221,  -250,  -222,  -224,  -258,  -259,-10000000,-10000000,-10000000,-10000000,
-10000000,-10000000,-10000000,  -260,  -262,-10000000,-10000000,-10000000,-10000000,-10000000,
-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,  -270,-10000000,  -271,  -272,
-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000 };
yytabelem yypgo[]={
X
X     0,    75,    81,    80,    79,    78,    77,    76,    54,    53,
X    51,    50,    30 };
yytabelem yyr1[]={
X
X     0,     4,     4,     4,     4,     4,     4,     4,     4,     4,
X     4,     4,    12,    12,    12,     5,     5,     7,     7,    11,
X    11,     6,     6,     6,     8,     8,     9,     9,    10,    10,
X    10,    10,     1,     3,     3,     3,     2,     2,     2,     2,
X     2 };
yytabelem yyr2[]={
X
X     0,     0,     4,     4,     4,     4,     4,     4,     4,     4,
X     6,     4,     9,     9,     7,     9,     7,     7,     7,     9,
X     7,     9,     9,     7,     7,     7,     7,     7,     7,     7,
X     7,     7,     5,     3,     3,     3,     3,     3,     3,     3,
X     3 };
yytabelem yychk[]={
X
-10000000,    -4,    -5,    -6,    -7,    -8,    -9,   -10,   -11,   -12,
X   256,   274,   261,   262,   267,   263,   264,   265,   266,   273,
X   274,    -1,   256,    -3,   258,   259,   257,    -1,   260,   256,
X    -1,   256,   268,   256,   268,   256,   268,   275,   276,   256,
X    -1,   256,   270,   266,   256,    -2,   272,   269,   270,   267,
X   266,   274,   271,   268,   268,   274,   274,   274,   274,   274,
X   274,   274,   274,   274,   274,   274,   268,   274,   268,   268,
X   274,   274,   274,   274,   274,   274,   274 };
yytabelem yydef[]={
X
X     1,    -2,     2,     3,     4,     5,     6,     7,     8,     9,
X     0,    11,     0,     0,     0,     0,     0,     0,     0,     0,
X    10,     0,     0,     0,    33,    34,    35,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,    36,    37,    38,    39,
X    40,    16,    32,     0,     0,    23,    17,    18,    24,    25,
X    26,    27,    28,    29,    30,    31,     0,    20,     0,     0,
X    14,    15,    21,    22,    19,    12,    13 };
typedef struct
#ifdef __cplusplus
X	yytoktype
#endif
{ char *t_name; int t_val; } yytoktype;
#ifndef YYDEBUG
#	define YYDEBUG	0	/* don't allow debugging */
#endif
X
#if YYDEBUG
X
yytoktype yytoks[] =
{
X	"TTY",	257,
X	"LOGIN",	258,
X	"GROUP",	259,
X	"DEFAULT",	260,
X	"EXEMPT",	261,
X	"TIMEOUT",	262,
X	"SLEEP",	263,
X	"WARN",	264,
X	"CONSWINS",	265,
X	"SESSION",	266,
X	"REFUSE",	267,
X	"NUM",	268,
X	"IDLE",	269,
X	"MULTIPLE",	270,
X	"NAME",	271,
X	"ALL",	272,
X	"THRESHOLD",	273,
X	"NL",	274,
X	"NORMAL",	275,
X	"OFF",	276,
X	"-unknown-",	-1	/* ends search */
};
X
char * yyreds[] =
{
X	"-no such reduction-",
X	"cmd_cmd : /* empty */",
X	"cmd_cmd : cmd_cmd exempt_cmd",
X	"cmd_cmd : cmd_cmd idle_cmd",
X	"cmd_cmd : cmd_cmd refuse_cmd",
X	"cmd_cmd : cmd_cmd sleep_cmd",
X	"cmd_cmd : cmd_cmd warn_cmd",
X	"cmd_cmd : cmd_cmd conswins_cmd",
X	"cmd_cmd : cmd_cmd session_cmd",
X	"cmd_cmd : cmd_cmd thresh_cmd",
X	"cmd_cmd : cmd_cmd error NL",
X	"cmd_cmd : cmd_cmd NL",
X	"thresh_cmd : THRESHOLD MULTIPLE NUM NL",
X	"thresh_cmd : THRESHOLD SESSION NUM NL",
X	"thresh_cmd : THRESHOLD error NL",
X	"exempt_cmd : EXEMPT who exempt_type NL",
X	"exempt_cmd : EXEMPT error NL",
X	"refuse_cmd : REFUSE who NL",
X	"refuse_cmd : REFUSE error NL",
X	"session_cmd : SESSION who NUM NL",
X	"session_cmd : SESSION error NL",
X	"idle_cmd : TIMEOUT who NUM NL",
X	"idle_cmd : TIMEOUT DEFAULT NUM NL",
X	"idle_cmd : TIMEOUT error NL",
X	"sleep_cmd : SLEEP NUM NL",
X	"sleep_cmd : SLEEP error NL",
X	"warn_cmd : WARN NUM NL",
X	"warn_cmd : WARN error NL",
X	"conswins_cmd : CONSWINS NUM NL",
X	"conswins_cmd : CONSWINS NORMAL NL",
X	"conswins_cmd : CONSWINS OFF NL",
X	"conswins_cmd : CONSWINS error NL",
X	"who : name_type NAME",
X	"name_type : LOGIN",
X	"name_type : GROUP",
X	"name_type : TTY",
X	"exempt_type : ALL",
X	"exempt_type : IDLE",
X	"exempt_type : MULTIPLE",
X	"exempt_type : REFUSE",
X	"exempt_type : SESSION",
};
#endif /* YYDEBUG */
/*
X * Copyright (c) 1993 by Sun Microsystems, Inc.
X */
X
#pragma ident	"@(#)yaccpar	6.12	93/06/07 SMI"
X
/*
** Skeleton parser driver for yacc output
*/
X
/*
** yacc user known macros and defines
*/
#define YYERROR		goto yyerrlab
#define YYACCEPT	return(0)
#define YYABORT		return(1)
#define YYBACKUP( newtoken, newvalue )\
{\
X	if ( yychar >= 0 || ( yyr2[ yytmp ] >> 1 ) != 1 )\
X	{\
X		yyerror( "syntax error - cannot backup" );\
X		goto yyerrlab;\
X	}\
X	yychar = newtoken;\
X	yystate = *yyps;\
X	yylval = newvalue;\
X	goto yynewstate;\
}
#define YYRECOVERING()	(!!yyerrflag)
#define YYNEW(type)	malloc(sizeof(type) * yynewmax)
#define YYCOPY(to, from, type) \
X	(type *) memcpy(to, (char *) from, yynewmax * sizeof(type))
#define YYENLARGE( from, type) \
X	(type *) realloc((char *) from, yynewmax * sizeof(type))
#ifndef YYDEBUG
#	define YYDEBUG	1	/* make debugging available */
#endif
X
/*
** user known globals
*/
int yydebug;			/* set to 1 to get debugging */
X
/*
** driver internal defines
*/
#define YYFLAG		(-10000000)
X
/*
** global variables used by the parser
*/
YYSTYPE *yypv;			/* top of value stack */
int *yyps;			/* top of state stack */
X
int yystate;			/* current state */
int yytmp;			/* extra var (lasts between blocks) */
X
int yynerrs;			/* number of errors */
int yyerrflag;			/* error recovery flag */
int yychar;			/* current input token number */
X
X
X
#ifdef YYNMBCHARS
#define YYLEX()		yycvtok(yylex())
/*
** yycvtok - return a token if i is a wchar_t value that exceeds 255.
**	If i<255, i itself is the token.  If i>255 but the neither 
**	of the 30th or 31st bit is on, i is already a token.
*/
#if defined(__STDC__) || defined(__cplusplus)
int yycvtok(int i)
#else
int yycvtok(i) int i;
#endif
{
X	int first = 0;
X	int last = YYNMBCHARS - 1;
X	int mid;
X	wchar_t j;
X
X	if(i&0x60000000){/*Must convert to a token. */
X		if( yymbchars[last].character < i ){
X			return i;/*Giving up*/
X		}
X		while ((last>=first)&&(first>=0)) {/*Binary search loop*/
X			mid = (first+last)/2;
X			j = yymbchars[mid].character;
X			if( j==i ){/*Found*/ 
X				return yymbchars[mid].tvalue;
X			}else if( j<i ){
X				first = mid + 1;
X			}else{
X				last = mid -1;
X			}
X		}
X		/*No entry in the table.*/
X		return i;/* Giving up.*/
X	}else{/* i is already a token. */
X		return i;
X	}
}
#else/*!YYNMBCHARS*/
#define YYLEX()		yylex()
#endif/*!YYNMBCHARS*/
X
/*
** yyparse - return 0 if worked, 1 if syntax error not recovered from
*/
#if defined(__STDC__) || defined(__cplusplus)
int yyparse(void)
#else
int yyparse()
#endif
{
X	register YYSTYPE *yypvt;	/* top of value stack for $vars */
X
#if defined(__cplusplus) || defined(lint)
/*
X	hacks to please C++ and lint - goto's inside switch should never be
X	executed; yypvt is set to 0 to avoid "used before set" warning.
*/
X	static int __yaccpar_lint_hack__ = 0;
X	switch (__yaccpar_lint_hack__)
X	{
X		case 1: goto yyerrlab;
X		case 2: goto yynewstate;
X	}
X	yypvt = 0;
#endif
X
X	/*
X	** Initialize externals - yyparse may be called more than once
X	*/
X	yypv = &yyv[-1];
X	yyps = &yys[-1];
X	yystate = 0;
X	yytmp = 0;
X	yynerrs = 0;
X	yyerrflag = 0;
X	yychar = -1;
X
#if YYMAXDEPTH <= 0
X	if (yymaxdepth <= 0)
X	{
X		if ((yymaxdepth = YYEXPAND(0)) <= 0)
X		{
X			yyerror("yacc initialization error");
X			YYABORT;
X		}
X	}
#endif
X
X	{
X		register YYSTYPE *yy_pv;	/* top of value stack */
X		register int *yy_ps;		/* top of state stack */
X		register int yy_state;		/* current state */
X		register int  yy_n;		/* internal state number info */
X	goto yystack;	/* moved from 6 lines above to here to please C++ */
X
X		/*
X		** get globals into registers.
X		** branch to here only if YYBACKUP was called.
X		*/
X	yynewstate:
X		yy_pv = yypv;
X		yy_ps = yyps;
X		yy_state = yystate;
X		goto yy_newstate;
X
X		/*
X		** get globals into registers.
X		** either we just started, or we just finished a reduction
X		*/
X	yystack:
X		yy_pv = yypv;
X		yy_ps = yyps;
X		yy_state = yystate;
X
X		/*
X		** top of for (;;) loop while no reductions done
X		*/
X	yy_stack:
X		/*
X		** put a state and value onto the stacks
X		*/
#if YYDEBUG
X		/*
X		** if debugging, look up token value in list of value vs.
X		** name pairs.  0 and negative (-1) are special values.
X		** Note: linear search is used since time is not a real
X		** consideration while debugging.
X		*/
X		if ( yydebug )
X		{
X			register int yy_i;
X
X			printf( "State %d, token ", yy_state );
X			if ( yychar == 0 )
X				printf( "end-of-file\n" );
X			else if ( yychar < 0 )
X				printf( "-none-\n" );
X			else
X			{
X				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
X					yy_i++ )
X				{
X					if ( yytoks[yy_i].t_val == yychar )
X						break;
X				}
X				printf( "%s\n", yytoks[yy_i].t_name );
X			}
X		}
#endif /* YYDEBUG */
X		if ( ++yy_ps >= &yys[ yymaxdepth ] )	/* room on stack? */
X		{
X			/*
X			** reallocate and recover.  Note that pointers
X			** have to be reset, or bad things will happen
X			*/
X			int yyps_index = (yy_ps - yys);
X			int yypv_index = (yy_pv - yyv);
X			int yypvt_index = (yypvt - yyv);
X			int yynewmax;
#ifdef YYEXPAND
X			yynewmax = YYEXPAND(yymaxdepth);
#else
X			yynewmax = 2 * yymaxdepth;	/* double table size */
X			if (yymaxdepth == YYMAXDEPTH)	/* first time growth */
X			{
X				char *newyys = (char *)YYNEW(int);
X				char *newyyv = (char *)YYNEW(YYSTYPE);
X				if (newyys != 0 && newyyv != 0)
X				{
X					yys = YYCOPY(newyys, yys, int);
X					yyv = YYCOPY(newyyv, yyv, YYSTYPE);
X				}
X				else
X					yynewmax = 0;	/* failed */
X			}
X			else				/* not first time */
X			{
X				yys = YYENLARGE(yys, int);
X				yyv = YYENLARGE(yyv, YYSTYPE);
X				if (yys == 0 || yyv == 0)
X					yynewmax = 0;	/* failed */
X			}
#endif
X			if (yynewmax <= yymaxdepth)	/* tables not expanded */
X			{
X				yyerror( "yacc stack overflow" );
X				YYABORT;
X			}
X			yymaxdepth = yynewmax;
X
X			yy_ps = yys + yyps_index;
X			yy_pv = yyv + yypv_index;
X			yypvt = yyv + yypvt_index;
X		}
X		*yy_ps = yy_state;
X		*++yy_pv = yyval;
X
X		/*
X		** we have a new state - find out what to do
X		*/
X	yy_newstate:
X		if ( ( yy_n = yypact[ yy_state ] ) <= YYFLAG )
X			goto yydefault;		/* simple state */
#if YYDEBUG
X		/*
X		** if debugging, need to mark whether new token grabbed
X		*/
X		yytmp = yychar < 0;
#endif
X		if ( ( yychar < 0 ) && ( ( yychar = YYLEX() ) < 0 ) )
X			yychar = 0;		/* reached EOF */
#if YYDEBUG
X		if ( yydebug && yytmp )
X		{
X			register int yy_i;
X
X			printf( "Received token " );
X			if ( yychar == 0 )
X				printf( "end-of-file\n" );
X			else if ( yychar < 0 )
X				printf( "-none-\n" );
X			else
X			{
X				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
X					yy_i++ )
X				{
X					if ( yytoks[yy_i].t_val == yychar )
X						break;
X				}
X				printf( "%s\n", yytoks[yy_i].t_name );
X			}
X		}
#endif /* YYDEBUG */
X		if ( ( ( yy_n += yychar ) < 0 ) || ( yy_n >= YYLAST ) )
X			goto yydefault;
X		if ( yychk[ yy_n = yyact[ yy_n ] ] == yychar )	/*valid shift*/
X		{
X			yychar = -1;
X			yyval = yylval;
X			yy_state = yy_n;
X			if ( yyerrflag > 0 )
X				yyerrflag--;
X			goto yy_stack;
X		}
X
X	yydefault:
X		if ( ( yy_n = yydef[ yy_state ] ) == -2 )
X		{
#if YYDEBUG
X			yytmp = yychar < 0;
#endif
X			if ( ( yychar < 0 ) && ( ( yychar = YYLEX() ) < 0 ) )
X				yychar = 0;		/* reached EOF */
#if YYDEBUG
X			if ( yydebug && yytmp )
X			{
X				register int yy_i;
X
X				printf( "Received token " );
X				if ( yychar == 0 )
X					printf( "end-of-file\n" );
X				else if ( yychar < 0 )
X					printf( "-none-\n" );
X				else
X				{
X					for ( yy_i = 0;
X						yytoks[yy_i].t_val >= 0;
X						yy_i++ )
X					{
X						if ( yytoks[yy_i].t_val
X							== yychar )
X						{
X							break;
X						}
X					}
X					printf( "%s\n", yytoks[yy_i].t_name );
X				}
X			}
#endif /* YYDEBUG */
X			/*
X			** look through exception table
X			*/
X			{
X				register int *yyxi = yyexca;
X
X				while ( ( *yyxi != -1 ) ||
X					( yyxi[1] != yy_state ) )
X				{
X					yyxi += 2;
X				}
X				while ( ( *(yyxi += 2) >= 0 ) &&
X					( *yyxi != yychar ) )
X					;
X				if ( ( yy_n = yyxi[1] ) < 0 )
X					YYACCEPT;
X			}
X		}
X
X		/*
X		** check for syntax error
X		*/
X		if ( yy_n == 0 )	/* have an error */
X		{
X			/* no worry about speed here! */
X			switch ( yyerrflag )
X			{
X			case 0:		/* new error */
X				yyerror( "syntax error" );
X				goto skip_init;
X			yyerrlab:
X				/*
X				** get globals into registers.
X				** we have a user generated syntax type error
X				*/
X				yy_pv = yypv;
X				yy_ps = yyps;
X				yy_state = yystate;
X			skip_init:
X				yynerrs++;
X				/* FALLTHRU */
X			case 1:
X			case 2:		/* incompletely recovered error */
X					/* try again... */
X				yyerrflag = 3;
X				/*
X				** find state where "error" is a legal
X				** shift action
X				*/
X				while ( yy_ps >= yys )
X				{
X					yy_n = yypact[ *yy_ps ] + YYERRCODE;
X					if ( yy_n >= 0 && yy_n < YYLAST &&
X						yychk[yyact[yy_n]] == YYERRCODE)					{
X						/*
X						** simulate shift of "error"
X						*/
X						yy_state = yyact[ yy_n ];
X						goto yy_stack;
X					}
X					/*
X					** current state has no shift on
X					** "error", pop stack
X					*/
#if YYDEBUG
#	define _POP_ "Error recovery pops state %d, uncovers state %d\n"
X					if ( yydebug )
X						printf( _POP_, *yy_ps,
X							yy_ps[-1] );
#	undef _POP_
#endif
X					yy_ps--;
X					yy_pv--;
X				}
X				/*
X				** there is no state on stack with "error" as
X				** a valid shift.  give up.
X				*/
X				YYABORT;
X			case 3:		/* no shift yet; eat a token */
#if YYDEBUG
X				/*
X				** if debugging, look up token in list of
X				** pairs.  0 and negative shouldn't occur,
X				** but since timing doesn't matter when
X				** debugging, it doesn't hurt to leave the
X				** tests here.
X				*/
X				if ( yydebug )
X				{
X					register int yy_i;
X
X					printf( "Error recovery discards " );
X					if ( yychar == 0 )
X						printf( "token end-of-file\n" );
X					else if ( yychar < 0 )
X						printf( "token -none-\n" );
X					else
X					{
X						for ( yy_i = 0;
X							yytoks[yy_i].t_val >= 0;
X							yy_i++ )
X						{
X							if ( yytoks[yy_i].t_val
X								== yychar )
X							{
X								break;
X							}
X						}
X						printf( "token %s\n",
X							yytoks[yy_i].t_name );
X					}
X				}
#endif /* YYDEBUG */
X				if ( yychar == 0 )	/* reached EOF. quit */
X					YYABORT;
X				yychar = -1;
X				goto yy_newstate;
X			}
X		}/* end if ( yy_n == 0 ) */
X		/*
X		** reduction by production yy_n
X		** put stack tops, etc. so things right after switch
X		*/
#if YYDEBUG
X		/*
X		** if debugging, print the string that is the user's
X		** specification of the reduction which is just about
X		** to be done.
X		*/
X		if ( yydebug )
X			printf( "Reduce by (%d) \"%s\"\n",
X				yy_n, yyreds[ yy_n ] );
#endif
X		yytmp = yy_n;			/* value to switch over */
X		yypvt = yy_pv;			/* $vars top of value stack */
X		/*
X		** Look in goto table for next state
X		** Sorry about using yy_state here as temporary
X		** register variable, but why not, if it works...
X		** If yyr2[ yy_n ] doesn't have the low order bit
X		** set, then there is no action to be done for
X		** this reduction.  So, no saving & unsaving of
X		** registers done.  The only difference between the
X		** code just after the if and the body of the if is
X		** the goto yy_stack in the body.  This way the test
X		** can be made before the choice of what to do is needed.
X		*/
X		{
X			/* length of production doubled with extra bit */
X			register int yy_len = yyr2[ yy_n ];
X
X			if ( !( yy_len & 01 ) )
X			{
X				yy_len >>= 1;
X				yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
X				yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
X					*( yy_ps -= yy_len ) + 1;
X				if ( yy_state >= YYLAST ||
X					yychk[ yy_state =
X					yyact[ yy_state ] ] != -yy_n )
X				{
X					yy_state = yyact[ yypgo[ yy_n ] ];
X				}
X				goto yy_stack;
X			}
X			yy_len >>= 1;
X			yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
X			yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
X				*( yy_ps -= yy_len ) + 1;
X			if ( yy_state >= YYLAST ||
X				yychk[ yy_state = yyact[ yy_state ] ] != -yy_n )
X			{
X				yy_state = yyact[ yypgo[ yy_n ] ];
X			}
X		}
X					/* save until reenter driver code */
X		yystate = yy_state;
X		yyps = yy_ps;
X		yypv = yy_pv;
X	}
X	/*
X	** code supplied by user is placed in this switch
X	*/
X	switch( yytmp )
X	{
X		
case 12:
# line 58 "parse.y"
{
X			m_threshold = yypvt[-1].nb; 
X		} break;
case 13:
# line 62 "parse.y"
{
X			s_threshold = yypvt[-1].nb; 
X		} break;
case 14:
# line 66 "parse.y"
{
X			yyerror("Malformed threshold command.");
X		} break;
case 15:
# line 73 "parse.y"
{
X			addlist(exmpt, yypvt[-2].nb, name, num, yypvt[-1].nb);
X		} break;
case 16:
# line 77 "parse.y"
{
X			yyerror("Malformed exempt command.");
X		} break;
case 17:
# line 83 "parse.y"
{
X			addlist(refuse, yypvt[-1].nb, name, 0, 0);
X		} break;
case 18:
# line 87 "parse.y"
{
X			yyerror("Malformed refuse command.");
X		} break;
case 19:
# line 93 "parse.y"
{
X			addlist(session, yypvt[-2].nb, name, num, yypvt[-1].nb);
X		} break;
case 20:
# line 97 "parse.y"
{
X			yyerror("Malformed session command.");
X		} break;
case 21:
# line 103 "parse.y"
{
X			addlist(rules, yypvt[-2].nb, name, num, yypvt[-1].nb);
X		} break;
case 22:
# line 107 "parse.y"
{
X			addlist(rules, DEFAULT, NULL, 0, yypvt[-1].nb);
X		} break;
case 23:
# line 111 "parse.y"
{
X			yyerror("Malformed timeout command.");
X		} break;
case 24:
# line 117 "parse.y"
{
X			sleeptime = yypvt[-1].nb;
X		} break;
case 25:
# line 121 "parse.y"
{
X			yyerror("Malformed sleep command.");
X		} break;
case 26:
# line 127 "parse.y"
{
X			warntime = yypvt[-1].nb;
X		} break;
case 27:
# line 131 "parse.y"
{
X			yyerror("Malformed warn command.");
X		} break;
case 28:
# line 137 "parse.y"
{
X			conswins_time = yypvt[-1].nb;
X		} break;
case 29:
# line 141 "parse.y"
{
X                        conswins_time = -2;
X                } break;
case 30:
# line 145 "parse.y"
{
X                        conswins_time = -1;
X                } break;
case 31:
# line 149 "parse.y"
{
X			yyerror("Malformed cons(ole) win(dow)s idle time command.");
X		} break;
case 32:
# line 155 "parse.y"
{ 
X			yyval.nb = yypvt[-1].nb;
X			name = yypvt[-0].sb;
X
X			if (yypvt[-1].nb == GROUP)
X			{
X				grp = getgrnam(name);
X				if (grp != NULL)
X                                	num = grp->gr_gid;
X				else
X					logfile("Error parsing conf file:  unknown group name '%s'.",name);
X			}
X		} break;
case 33:
# line 170 "parse.y"
{ yyval.nb = LOGIN;   } break;
case 34:
# line 171 "parse.y"
{ yyval.nb = GROUP;   } break;
case 35:
# line 172 "parse.y"
{ yyval.nb = TTY;     } break;
case 36:
# line 175 "parse.y"
{ yyval.nb = ALL; 	 } break;
case 37:
# line 176 "parse.y"
{ yyval.nb = IDLE; 	 } break;
case 38:
# line 177 "parse.y"
{ yyval.nb = MULTIPLE; } break;
case 39:
# line 178 "parse.y"
{ yyval.nb = REFUSE;	 } break;
case 40:
# line 179 "parse.y"
{ yyval.nb = SESSION;  } break;
X	}
X	goto yystack;		/* reset registers in driver code */
}
X
SHAR_EOF
  $shar_touch -am 1129161894 'idled-1.00/parse.c' &&
  chmod 0644 'idled-1.00/parse.c' ||
  echo 'restore of idled-1.00/parse.c failed'
  shar_count="`wc -c < 'idled-1.00/parse.c'`"
  test 21769 -eq "$shar_count" ||
    echo "idled-1.00/parse.c: original size 21769, current size $shar_count"
fi
# ============= idled-1.00/parse.y ==============
if test -f 'idled-1.00/parse.y' && test X"$1" != X"-c"; then
  echo 'x - skipping idled-1.00/parse.y (File already exists)'
else
  echo 'x - extracting idled-1.00/parse.y (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'idled-1.00/parse.y' &&
%{
#include <stdio.h> 
#include <grp.h>
#include "idled.h"
X
int		num;
char		*name;
struct	group	*grp;
X
extern	char	*yytext;
X
extern	void	addlist();
X
X  /*
X   *  The order of the tokens in the *first line* is significant.  
X   *
X   *  They dictate which rules and exemptions have precence.
X   *  The second two %token lines may be ordered anyway. 
X   *  DEFAULT is the least specific, but will always match. 
X   *  It must always remain in the last position.
X   */ 
%}
X
%token TTY LOGIN GROUP DEFAULT
X
%token EXEMPT TIMEOUT SLEEP WARN CONSWINS SESSION REFUSE
%token NUM IDLE MULTIPLE NAME ALL 
%token THRESHOLD NL
%token NORMAL OFF
X
%union {
X	char *sb; 
X	int nb;
X       }
X
%type <sb> NAME
%type <nb> NUM LOGIN GROUP TTY ALL IDLE MULTIPLE 
%type <nb> who exempt_type name_type
X
%start cmd_cmd
X
%%
X
cmd_cmd		: /*EMPTY*/
X		| cmd_cmd exempt_cmd
X		| cmd_cmd idle_cmd
X		| cmd_cmd refuse_cmd
X		| cmd_cmd sleep_cmd
X		| cmd_cmd warn_cmd
X		| cmd_cmd conswins_cmd
X		| cmd_cmd session_cmd
X		| cmd_cmd thresh_cmd
X		| cmd_cmd error NL
X		| cmd_cmd NL
X		;
X
thresh_cmd	: THRESHOLD MULTIPLE NUM NL
X		{
X			m_threshold = $3; 
X		}
X		| THRESHOLD SESSION NUM NL
X		{
X			s_threshold = $3; 
X		}
X		| THRESHOLD error NL
X		{
X			yyerror("Malformed threshold command.");
X		}
X		;
X	
X
exempt_cmd	: EXEMPT who exempt_type NL
X		{
X			addlist(exmpt, $2, name, num, $3);
X		}
X		| EXEMPT error NL
X		{
X			yyerror("Malformed exempt command.");
X		}
X		;
X
refuse_cmd	: REFUSE who NL
X		{
X			addlist(refuse, $2, name, 0, 0);
X		}
X		| REFUSE error NL
X		{
X			yyerror("Malformed refuse command.");
X		}
X		;
X
session_cmd     : SESSION who NUM NL
X		{
X			addlist(session, $2, name, num, $3);
X		}
X		| SESSION error NL
X		{
X			yyerror("Malformed session command.");
X		}
X		;
X
idle_cmd	: TIMEOUT who NUM NL
X		{
X			addlist(rules, $2, name, num, $3);
X		}
X		| TIMEOUT DEFAULT NUM NL
X		{
X			addlist(rules, DEFAULT, NULL, 0, $3);
X		}
X		| TIMEOUT error NL
X		{
X			yyerror("Malformed timeout command.");
X		}
X		;
X
sleep_cmd	: SLEEP NUM NL
X		{
X			sleeptime = $2;
X		}
X		| SLEEP error NL
X		{
X			yyerror("Malformed sleep command.");
X		}
X		;
X
warn_cmd	: WARN NUM NL
X		{
X			warntime = $2;
X		}
X		| WARN error NL
X		{
X			yyerror("Malformed warn command.");
X		}
X		;
X
conswins_cmd	: CONSWINS NUM NL
X		{
X			conswins_time = $2;
X		}
X                | CONSWINS NORMAL NL
X                {
X                        conswins_time = -2;
X                }
X                | CONSWINS OFF NL
X                {
X                        conswins_time = -1;
X                }
X		| CONSWINS error NL
X		{
X			yyerror("Malformed cons(ole) win(dow)s idle time command.");
X		}
X		;
X
who		: name_type NAME
X		{ 
X			$$ = $1;
X			name = $2;
X
X			if ($1 == GROUP)
X			{
X				grp = getgrnam(name);
X				if (grp != NULL)
X                                	num = grp->gr_gid;
X				else
X					logfile("Error parsing conf file:  unknown group name '%s'.",name);
X			}
X		}
X		;
X
name_type	: LOGIN 	{ $$ = LOGIN;   }
X		| GROUP		{ $$ = GROUP;   }
X		| TTY		{ $$ = TTY;     }
X		;
X
exempt_type	: ALL		{ $$ = ALL; 	 }
X		| IDLE		{ $$ = IDLE; 	 }
X		| MULTIPLE	{ $$ = MULTIPLE; }
X		| REFUSE	{ $$ = REFUSE;	 }
X		| SESSION	{ $$ = SESSION;  }
X		;
X
%%
X
static	int	errorcnt = 0;
X
X
X
int
yyerror(sb)
char *sb;
{
X	extern	int	linenum;
X
X	logfile("%s: line %d: %s", CONFIG, linenum, sb);
X	errorcnt++;
X	return 0;
}
X
X
X
int
yywrap()
{
X	extern	int	linenum;
X        extern  time_t  conf_oldstamp;
X
X	if ( errorcnt > 0 && conf_oldstamp <= 1 )
X	{
X	    logfile("Aborting due to conf file syntax errors.");
X	    exit(1);
X	}
X
X	linenum = 1;
X	return 1;
}
SHAR_EOF
  $shar_touch -am 1129155294 'idled-1.00/parse.y' &&
  chmod 0644 'idled-1.00/parse.y' ||
  echo 'restore of idled-1.00/parse.y failed'
  shar_count="`wc -c < 'idled-1.00/parse.y'`"
  test 3494 -eq "$shar_count" ||
    echo "idled-1.00/parse.y: original size 3494, current size $shar_count"
fi
# ============= idled-1.00/scan.c ==============
if test -f 'idled-1.00/scan.c' && test X"$1" != X"-c"; then
  echo 'x - skipping idled-1.00/scan.c (File already exists)'
else
  echo 'x - extracting idled-1.00/scan.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'idled-1.00/scan.c' &&
#include <stdio.h>
# define U(x) x
# define NLSTATE yyprevious=YYNEWLINE
# define BEGIN yybgin = yysvec + 1 +
# define INITIAL 0
# define YYLERR yysvec
# define YYSTATE (yyestate-yysvec-1)
# define YYOPTIM 1
# define YYLMAX BUFSIZ
#ifndef __cplusplus
# define output(c) (void)putc(c,yyout)
#else
# define lex_output(c) (void)putc(c,yyout)
#endif
X
#if defined(__cplusplus) || defined(__STDC__)
X
#if defined(__cplusplus) && defined(__EXTERN_C__)
extern "C" {
#endif
X	int yyback(int *, int);
X	int yyinput(void);
X	int yylook(void);
X	void yyoutput(int);
X	int yyracc(int);
X	int yyreject(void);
X	void yyunput(int);
X	int yylex(void);
#ifdef YYLEX_E
X	void yywoutput(wchar_t);
X	wchar_t yywinput(void);
#endif
#ifndef yyless
X	void yyless(int);
#endif
#ifndef yywrap
X	int yywrap(void);
#endif
#ifdef LEXDEBUG
X	void allprint(char);
X	void sprint(char *);
#endif
#if defined(__cplusplus) && defined(__EXTERN_C__)
}
#endif
X
#ifdef __cplusplus
extern "C" {
#endif
X	void exit(int);
#ifdef __cplusplus
}
#endif
X
#endif
# define unput(c) {yytchar= (c);if(yytchar=='\n')yylineno--;*yysptr++=yytchar;}
# define yymore() (yymorfg=1)
#ifndef __cplusplus
# define input() (((yytchar=yysptr>yysbuf?U(*--yysptr):getc(yyin))==10?(yylineno++,yytchar):yytchar)==EOF?0:yytchar)
#else
# define lex_input() (((yytchar=yysptr>yysbuf?U(*--yysptr):getc(yyin))==10?(yylineno++,yytchar):yytchar)==EOF?0:yytchar)
#endif
#define ECHO fprintf(yyout, "%s",yytext)
# define REJECT { nstr = yyreject(); goto yyfussy;}
int yyleng; extern char yytext[];
int yymorfg;
extern char *yysptr, yysbuf[];
int yytchar;
FILE *yyin = {stdin}, *yyout = {stdout};
extern int yylineno;
struct yysvf { 
X	struct yywork *yystoff;
X	struct yysvf *yyother;
X	int *yystops;};
struct yysvf *yyestate;
extern struct yysvf yysvec[], *yybgin;
X
X
# line 4 "scan.l"
/*
**  Lex grammer to scan input file for idled
*/
X
#include <stdio.h>
#include "y.tab.h"
X
#define makestr(Z)	((char *)strcpy(malloc(strlen(Z)+1),Z))
X
int linenum = 1;	/* current line number for error messages */
X
# define YYNEWLINE 10
yylex(){
int nstr; extern int yyprevious;
#ifdef __cplusplus
/* to avoid CC and lint complaining yyfussy not being used ...*/
static int __lex_hack = 0;
if (__lex_hack) goto yyfussy;
#endif
while((nstr = yylook()) >= 0)
yyfussy: switch(nstr){
case 0:
if(yywrap()) return(0); break;
case 1:
X
# line 17 "scan.l"
X	return ALL;
break;
case 2:
X
# line 18 "scan.l"
X	return DEFAULT;
break;
case 3:
X
# line 19 "scan.l"
X	return EXEMPT;
break;
case 4:
X
# line 20 "scan.l"
X	return GROUP;
break;
case 5:
X
# line 21 "scan.l"
X	return IDLE;
break;
case 6:
X
# line 22 "scan.l"
X       return CONSWINS;
break;
case 7:
X
# line 23 "scan.l"
X	return LOGIN;
break;
case 8:
X
# line 24 "scan.l"
return MULTIPLE;
break;
case 9:
X
# line 25 "scan.l"
X	return REFUSE;
break;
case 10:
X
# line 26 "scan.l"
X	return SESSION;
break;
case 11:
X
# line 27 "scan.l"
X	return SLEEP;
break;
case 12:
X
# line 28 "scan.l"
X           return WARN;
break;
case 13:
X
# line 29 "scan.l"
return THRESHOLD;
break;
case 14:
X
# line 30 "scan.l"
X	return TIMEOUT;
break;
case 15:
X
# line 31 "scan.l"
X	return TTY;
break;
case 16:
X
# line 32 "scan.l"
X         return NORMAL;
break;
case 17:
X
# line 33 "scan.l"
X            return OFF;
break;
case 18:
X
# line 35 "scan.l"
{   
X				yylval.sb = makestr(yytext);
X				return NAME; 
X			}
break;
case 19:
X
# line 40 "scan.l"
X		{
X				yylval.nb = atoi(yytext);
X				return NUM;
X			}
break;
case 20:
X
# line 45 "scan.l"
X		;
break;
case 21:
X
# line 47 "scan.l"
X		{ 
X				linenum++; 
X				return NL;
X			}
break;
case 22:
X
# line 51 "scan.l"
X		;
break;
case 23:
X
# line 53 "scan.l"
X		{
X				static	char	errormsg[] = "Illegal character ' '.";
X
X				errormsg[19] = yytext[0];
X				yyerror(errormsg);
X			}
break;
case -1:
break;
default:
(void)fprintf(yyout,"bad switch yylook %d",nstr);
} return(0); }
/* end of yylex */
int yyvstop[] = {
0,
X
22,
0,
X
22,
0,
X
23,
0,
X
22,
23,
0,
X
21,
0,
X
20,
23,
0,
X
18,
23,
0,
X
19,
23,
0,
X
18,
23,
0,
X
18,
23,
0,
X
18,
23,
0,
X
18,
23,
0,
X
18,
23,
0,
X
18,
23,
0,
X
18,
23,
0,
X
18,
23,
0,
X
18,
23,
0,
X
18,
23,
0,
X
18,
23,
0,
X
18,
23,
0,
X
18,
23,
0,
X
18,
23,
0,
X
22,
0,
X
20,
0,
X
18,
0,
X
19,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
1,
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
17,
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
15,
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
5,
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
12,
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
4,
18,
0,
X
7,
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
11,
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
3,
18,
0,
X
18,
0,
X
16,
18,
0,
X
9,
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
18,
0,
X
2,
18,
0,
X
18,
0,
X
10,
18,
0,
X
18,
0,
X
14,
18,
0,
X
6,
18,
0,
X
8,
18,
0,
X
18,
0,
X
13,
18,
0,
0};
# define YYTYPE unsigned char
struct yywork { YYTYPE verify, advance; } yycrank[] = {
0,0,	0,0,	1,3,	0,0,	
0,0,	6,24,	0,0,	0,0,	
0,0,	0,0,	1,4,	1,5,	
4,23,	6,24,	6,0,	24,0,	
0,0,	0,0,	0,0,	0,0,	
0,0,	0,0,	0,0,	0,0,	
0,0,	0,0,	0,0,	0,0,	
0,0,	0,0,	0,0,	0,0,	
0,0,	0,0,	0,0,	4,23,	
1,6,	0,0,	0,0,	0,0,	
0,0,	0,0,	0,0,	0,0,	
0,0,	0,0,	0,0,	0,0,	
1,7,	1,8,	0,0,	6,24,	
6,24,	0,0,	0,0,	0,0,	
0,0,	2,6,	8,26,	8,26,	
8,26,	8,26,	8,26,	8,26,	
8,26,	8,26,	8,26,	8,26,	
0,0,	0,0,	0,0,	0,0,	
0,0,	0,0,	0,0,	0,0,	
0,0,	0,0,	0,0,	0,0,	
0,0,	0,0,	0,0,	0,0,	
0,0,	0,0,	0,0,	0,0,	
0,0,	0,0,	0,0,	0,0,	
0,0,	0,0,	0,0,	0,0,	
1,3,	0,0,	1,9,	6,24,	
1,10,	1,11,	1,12,	11,29,	
1,13,	14,32,	1,14,	18,36,	
19,37,	1,15,	1,16,	1,17,	
1,18,	9,27,	10,28,	1,19,	
1,20,	1,21,	13,31,	2,9,	
1,22,	2,10,	2,11,	2,12,	
12,30,	2,13,	15,33,	2,14,	
16,34,	17,35,	2,15,	2,16,	
2,17,	2,18,	22,43,	27,44,	
2,19,	2,20,	2,21,	28,45,	
29,46,	2,22,	7,25,	7,25,	
7,25,	7,25,	7,25,	7,25,	
7,25,	7,25,	7,25,	7,25,	
7,25,	30,47,	31,48,	32,49,	
33,50,	34,51,	35,52,	36,53,	
7,25,	7,25,	7,25,	7,25,	
7,25,	7,25,	7,25,	7,25,	
7,25,	7,25,	7,25,	7,25,	
7,25,	7,25,	7,25,	7,25,	
7,25,	7,25,	7,25,	7,25,	
7,25,	7,25,	7,25,	7,25,	
7,25,	7,25,	37,54,	38,55,	
39,56,	40,57,	7,25,	41,58,	
7,25,	7,25,	7,25,	7,25,	
7,25,	7,25,	7,25,	7,25,	
7,25,	7,25,	7,25,	7,25,	
7,25,	7,25,	7,25,	7,25,	
7,25,	7,25,	7,25,	7,25,	
7,25,	7,25,	7,25,	7,25,	
7,25,	7,25,	20,38,	21,40,	
21,41,	42,59,	43,60,	45,61,	
46,62,	20,39,	47,63,	48,64,	
49,65,	50,66,	51,67,	21,42,	
52,68,	54,69,	55,70,	56,71,	
57,72,	58,73,	60,74,	61,75,	
62,76,	63,77,	64,78,	66,79,	
67,80,	68,81,	69,82,	70,83,	
71,84,	72,85,	73,86,	75,87,	
76,88,	77,89,	80,90,	81,91,	
82,92,	83,93,	85,94,	86,95,	
87,96,	88,97,	90,98,	93,99,	
94,100,	95,101,	96,102,	98,103,	
100,104,	104,105,	0,0,	0,0,	
0,0};
struct yysvf yysvec[] = {
0,	0,	0,
yycrank+-1,	0,		yyvstop+1,
yycrank+-22,	yysvec+1,	yyvstop+3,
yycrank+0,	0,		yyvstop+5,
yycrank+3,	0,		yyvstop+7,
yycrank+0,	0,		yyvstop+10,
yycrank+-4,	0,		yyvstop+12,
yycrank+95,	0,		yyvstop+15,
yycrank+10,	0,		yyvstop+18,
yycrank+5,	yysvec+7,	yyvstop+21,
yycrank+3,	yysvec+7,	yyvstop+24,
yycrank+2,	yysvec+7,	yyvstop+27,
yycrank+4,	yysvec+7,	yyvstop+30,
yycrank+4,	yysvec+7,	yyvstop+33,
yycrank+5,	yysvec+7,	yyvstop+36,
yycrank+15,	yysvec+7,	yyvstop+39,
yycrank+11,	yysvec+7,	yyvstop+42,
yycrank+18,	yysvec+7,	yyvstop+45,
yycrank+5,	yysvec+7,	yyvstop+48,
yycrank+7,	yysvec+7,	yyvstop+51,
yycrank+117,	yysvec+7,	yyvstop+54,
yycrank+115,	yysvec+7,	yyvstop+57,
yycrank+37,	yysvec+7,	yyvstop+60,
yycrank+0,	yysvec+4,	yyvstop+63,
yycrank+-5,	yysvec+6,	yyvstop+65,
yycrank+0,	yysvec+7,	yyvstop+67,
yycrank+0,	yysvec+8,	yyvstop+69,
yycrank+27,	yysvec+7,	yyvstop+71,
yycrank+29,	yysvec+7,	yyvstop+73,
yycrank+38,	yysvec+7,	yyvstop+75,
yycrank+52,	yysvec+7,	yyvstop+77,
yycrank+43,	yysvec+7,	yyvstop+79,
yycrank+47,	yysvec+7,	yyvstop+81,
yycrank+53,	yysvec+7,	yyvstop+83,
yycrank+49,	yysvec+7,	yyvstop+85,
yycrank+44,	yysvec+7,	yyvstop+87,
yycrank+57,	yysvec+7,	yyvstop+89,
yycrank+84,	yysvec+7,	yyvstop+91,
yycrank+72,	yysvec+7,	yyvstop+93,
yycrank+87,	yysvec+7,	yyvstop+95,
yycrank+75,	yysvec+7,	yyvstop+97,
yycrank+82,	yysvec+7,	yyvstop+99,
yycrank+100,	yysvec+7,	yyvstop+101,
yycrank+108,	yysvec+7,	yyvstop+103,
yycrank+0,	yysvec+7,	yyvstop+105,
yycrank+108,	yysvec+7,	yyvstop+108,
yycrank+127,	yysvec+7,	yyvstop+110,
yycrank+117,	yysvec+7,	yyvstop+112,
yycrank+110,	yysvec+7,	yyvstop+114,
yycrank+127,	yysvec+7,	yyvstop+116,
yycrank+124,	yysvec+7,	yyvstop+118,
yycrank+114,	yysvec+7,	yyvstop+120,
yycrank+123,	yysvec+7,	yyvstop+122,
yycrank+0,	yysvec+7,	yyvstop+124,
yycrank+116,	yysvec+7,	yyvstop+127,
yycrank+119,	yysvec+7,	yyvstop+129,
yycrank+134,	yysvec+7,	yyvstop+131,
yycrank+135,	yysvec+7,	yyvstop+133,
yycrank+136,	yysvec+7,	yyvstop+135,
yycrank+0,	yysvec+7,	yyvstop+137,
yycrank+128,	yysvec+7,	yyvstop+140,
yycrank+120,	yysvec+7,	yyvstop+142,
yycrank+123,	yysvec+7,	yyvstop+144,
yycrank+129,	yysvec+7,	yyvstop+146,
yycrank+130,	yysvec+7,	yyvstop+148,
yycrank+0,	yysvec+7,	yyvstop+150,
yycrank+133,	yysvec+7,	yyvstop+153,
yycrank+139,	yysvec+7,	yyvstop+155,
yycrank+148,	yysvec+7,	yyvstop+157,
yycrank+131,	yysvec+7,	yyvstop+159,
yycrank+142,	yysvec+7,	yyvstop+161,
yycrank+136,	yysvec+7,	yyvstop+163,
yycrank+134,	yysvec+7,	yyvstop+165,
yycrank+139,	yysvec+7,	yyvstop+167,
yycrank+0,	yysvec+7,	yyvstop+169,
yycrank+146,	yysvec+7,	yyvstop+172,
yycrank+144,	yysvec+7,	yyvstop+174,
yycrank+137,	yysvec+7,	yyvstop+176,
yycrank+0,	yysvec+7,	yyvstop+178,
yycrank+0,	yysvec+7,	yyvstop+181,
yycrank+142,	yysvec+7,	yyvstop+184,
yycrank+147,	yysvec+7,	yyvstop+186,
yycrank+155,	yysvec+7,	yyvstop+188,
yycrank+146,	yysvec+7,	yyvstop+190,
yycrank+0,	yysvec+7,	yyvstop+192,
yycrank+154,	yysvec+7,	yyvstop+195,
yycrank+142,	yysvec+7,	yyvstop+197,
yycrank+150,	yysvec+7,	yyvstop+199,
yycrank+145,	yysvec+7,	yyvstop+201,
yycrank+0,	yysvec+7,	yyvstop+203,
yycrank+154,	yysvec+7,	yyvstop+206,
yycrank+0,	yysvec+7,	yyvstop+208,
yycrank+0,	yysvec+7,	yyvstop+211,
yycrank+153,	yysvec+7,	yyvstop+214,
yycrank+153,	yysvec+7,	yyvstop+216,
yycrank+149,	yysvec+7,	yyvstop+218,
yycrank+151,	yysvec+7,	yyvstop+220,
yycrank+0,	yysvec+7,	yyvstop+222,
yycrank+166,	yysvec+7,	yyvstop+225,
yycrank+0,	yysvec+7,	yyvstop+227,
yycrank+160,	yysvec+7,	yyvstop+230,
yycrank+0,	yysvec+7,	yyvstop+232,
yycrank+0,	yysvec+7,	yyvstop+235,
yycrank+0,	yysvec+7,	yyvstop+238,
yycrank+169,	yysvec+7,	yyvstop+241,
yycrank+0,	yysvec+7,	yyvstop+243,
0,	0,	0};
struct yywork *yytop = yycrank+269;
struct yysvf *yybgin = yysvec+1;
char yymatch[] = {
X  0,   1,   1,   1,   1,   1,   1,   1, 
X  1,   9,  10,   1,   1,   1,   1,   1, 
X  1,   1,   1,   1,   1,   1,   1,   1, 
X  1,   1,   1,   1,   1,   1,   1,   1, 
X  9,   1,   1,   1,   1,   1,   1,   1, 
X  1,   1,   1,   1,   1,   1,   1,  47, 
X 48,  48,  48,  48,  48,  48,  48,  48, 
X 48,  48,   1,   1,   1,   1,   1,   1, 
X  1,  47,  47,  47,  47,  47,  47,  47, 
X 47,  47,  47,  47,  47,  47,  47,  47, 
X 47,  47,  47,  47,  47,  47,  47,  47, 
X 47,  47,  47,   1,   1,   1,   1,  95, 
X  1,  47,  47,  47,  47,  47,  47,  47, 
X 47,  47,  47,  47,  47,  47,  47,  47, 
X 47,  47,  47,  47,  47,  47,  47,  47, 
X 47,  47,  47,   1,   1,   1,   1,   1, 
X  1,   1,   1,   1,   1,   1,   1,   1, 
X  1,   1,   1,   1,   1,   1,   1,   1, 
X  1,   1,   1,   1,   1,   1,   1,   1, 
X  1,   1,   1,   1,   1,   1,   1,   1, 
X  1,   1,   1,   1,   1,   1,   1,   1, 
X  1,   1,   1,   1,   1,   1,   1,   1, 
X  1,   1,   1,   1,   1,   1,   1,   1, 
X  1,   1,   1,   1,   1,   1,   1,   1, 
X  1,   1,   1,   1,   1,   1,   1,   1, 
X  1,   1,   1,   1,   1,   1,   1,   1, 
X  1,   1,   1,   1,   1,   1,   1,   1, 
X  1,   1,   1,   1,   1,   1,   1,   1, 
X  1,   1,   1,   1,   1,   1,   1,   1, 
X  1,   1,   1,   1,   1,   1,   1,   1, 
X  1,   1,   1,   1,   1,   1,   1,   1, 
X  1,   1,   1,   1,   1,   1,   1,   1, 
0};
char yyextra[] = {
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0};
/*	Copyright (c) 1989 AT&T	*/
/*	  All Rights Reserved  	*/
X
/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/
X
#pragma ident	"@(#)ncform	6.7	93/06/07 SMI"
X
int yylineno =1;
# define YYU(x) x
# define NLSTATE yyprevious=YYNEWLINE
char yytext[YYLMAX];
struct yysvf *yylstate [YYLMAX], **yylsp, **yyolsp;
char yysbuf[YYLMAX];
char *yysptr = yysbuf;
int *yyfnd;
extern struct yysvf *yyestate;
int yyprevious = YYNEWLINE;
#if defined(__cplusplus) || defined(__STDC__)
int yylook(void)
#else
yylook()
#endif
{
X	register struct yysvf *yystate, **lsp;
X	register struct yywork *yyt;
X	struct yysvf *yyz;
X	int yych, yyfirst;
X	struct yywork *yyr;
# ifdef LEXDEBUG
X	int debug;
# endif
X	char *yylastch;
X	/* start off machines */
# ifdef LEXDEBUG
X	debug = 0;
# endif
X	yyfirst=1;
X	if (!yymorfg)
X		yylastch = yytext;
X	else {
X		yymorfg=0;
X		yylastch = yytext+yyleng;
X		}
X	for(;;){
X		lsp = yylstate;
X		yyestate = yystate = yybgin;
X		if (yyprevious==YYNEWLINE) yystate++;
X		for (;;){
# ifdef LEXDEBUG
X			if(debug)fprintf(yyout,"state %d\n",yystate-yysvec-1);
# endif
X			yyt = yystate->yystoff;
X			if(yyt == yycrank && !yyfirst){  /* may not be any transitions */
X				yyz = yystate->yyother;
X				if(yyz == 0)break;
X				if(yyz->yystoff == yycrank)break;
X				}
#ifndef __cplusplus
X			*yylastch++ = yych = input();
#else
X			*yylastch++ = yych = lex_input();
#endif
X			if(yylastch > &yytext[YYLMAX]) {
X				fprintf(yyout,"Input string too long, limit %d\n",YYLMAX);
X				exit(1);
X			}
X			yyfirst=0;
X		tryagain:
# ifdef LEXDEBUG
X			if(debug){
X				fprintf(yyout,"char ");
X				allprint(yych);
X				putchar('\n');
X				}
# endif
X			yyr = yyt;
X			if ( (int)yyt > (int)yycrank){
X				yyt = yyr + yych;
X				if (yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transitions */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					if(lsp > &yylstate[YYLMAX]) {
X						fprintf(yyout,"Input string too long, limit %d\n",YYLMAX);
X						exit(1);
X					}
X					goto contin;
X					}
X				}
# ifdef YYOPTIM
X			else if((int)yyt < (int)yycrank) {		/* r < yycrank */
X				yyt = yyr = yycrank+(yycrank-yyt);
# ifdef LEXDEBUG
X				if(debug)fprintf(yyout,"compressed state\n");
# endif
X				yyt = yyt + yych;
X				if(yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transitions */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					if(lsp > &yylstate[YYLMAX]) {
X						fprintf(yyout,"Input string too long, limit %d\n",YYLMAX);
X						exit(1);
X					}
X					goto contin;
X					}
X				yyt = yyr + YYU(yymatch[yych]);
# ifdef LEXDEBUG
X				if(debug){
X					fprintf(yyout,"try fall back character ");
X					allprint(YYU(yymatch[yych]));
X					putchar('\n');
X					}
# endif
X				if(yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transition */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					if(lsp > &yylstate[YYLMAX]) {
X						fprintf(yyout,"Input string too long, limit %d\n",YYLMAX);
X						exit(1);
X					}
X					goto contin;
X					}
X				}
X			if ((yystate = yystate->yyother) && (yyt= yystate->yystoff) != yycrank){
# ifdef LEXDEBUG
X				if(debug)fprintf(yyout,"fall back to state %d\n",yystate-yysvec-1);
# endif
X				goto tryagain;
X				}
# endif
X			else
X				{unput(*--yylastch);break;}
X		contin:
# ifdef LEXDEBUG
X			if(debug){
X				fprintf(yyout,"state %d char ",yystate-yysvec-1);
X				allprint(yych);
X				putchar('\n');
X				}
# endif
X			;
X			}
# ifdef LEXDEBUG
X		if(debug){
X			fprintf(yyout,"stopped at %d with ",*(lsp-1)-yysvec-1);
X			allprint(yych);
X			putchar('\n');
X			}
# endif
X		while (lsp-- > yylstate){
X			*yylastch-- = 0;
X			if (*lsp != 0 && (yyfnd= (*lsp)->yystops) && *yyfnd > 0){
X				yyolsp = lsp;
X				if(yyextra[*yyfnd]){		/* must backup */
X					while(yyback((*lsp)->yystops,-*yyfnd) != 1 && lsp > yylstate){
X						lsp--;
X						unput(*yylastch--);
X						}
X					}
X				yyprevious = YYU(*yylastch);
X				yylsp = lsp;
X				yyleng = yylastch-yytext+1;
X				yytext[yyleng] = 0;
# ifdef LEXDEBUG
X				if(debug){
X					fprintf(yyout,"\nmatch ");
X					sprint(yytext);
X					fprintf(yyout," action %d\n",*yyfnd);
X					}
# endif
X				return(*yyfnd++);
X				}
X			unput(*yylastch);
X			}
X		if (yytext[0] == 0  /* && feof(yyin) */)
X			{
X			yysptr=yysbuf;
X			return(0);
X			}
#ifndef __cplusplus
X		yyprevious = yytext[0] = input();
X		if (yyprevious>0)
X			output(yyprevious);
#else
X		yyprevious = yytext[0] = lex_input();
X		if (yyprevious>0)
X			lex_output(yyprevious);
#endif
X		yylastch=yytext;
# ifdef LEXDEBUG
X		if(debug)putchar('\n');
# endif
X		}
X	}
#if defined(__cplusplus) || defined(__STDC__)
int yyback(int *p, int m)
#else
yyback(p, m)
X	int *p;
#endif
{
X	if (p==0) return(0);
X	while (*p) {
X		if (*p++ == m)
X			return(1);
X	}
X	return(0);
}
X	/* the following are only used in the lex library */
#if defined(__cplusplus) || defined(__STDC__)
int yyinput(void)
#else
yyinput()
#endif
{
#ifndef __cplusplus
X	return(input());
#else
X	return(lex_input());
#endif
X	}
#if defined(__cplusplus) || defined(__STDC__)
void yyoutput(int c)
#else
yyoutput(c)
X  int c; 
#endif
{
#ifndef __cplusplus
X	output(c);
#else
X	lex_output(c);
#endif
X	}
#if defined(__cplusplus) || defined(__STDC__)
void yyunput(int c)
#else
yyunput(c)
X   int c; 
#endif
{
X	unput(c);
X	}
SHAR_EOF
  $shar_touch -am 1129161994 'idled-1.00/scan.c' &&
  chmod 0644 'idled-1.00/scan.c' ||
  echo 'restore of idled-1.00/scan.c failed'
  shar_count="`wc -c < 'idled-1.00/scan.c'`"
  test 17166 -eq "$shar_count" ||
    echo "idled-1.00/scan.c: original size 17166, current size $shar_count"
fi
# ============= idled-1.00/scan.l ==============
if test -f 'idled-1.00/scan.l' && test X"$1" != X"-c"; then
  echo 'x - skipping idled-1.00/scan.l (File already exists)'
else
  echo 'x - extracting idled-1.00/scan.l (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'idled-1.00/scan.l' &&
%{
X
/*
**  Lex grammer to scan input file for idled
*/
X
#include <stdio.h>
#include "y.tab.h"
X
#define makestr(Z)	((char *)strcpy(malloc(strlen(Z)+1),Z))
X
int linenum = 1;	/* current line number for error messages */
X
%}
X
%%
all		return ALL;
default		return DEFAULT;
exempt		return EXEMPT;
group		return GROUP;
idle		return IDLE;
conswins        return CONSWINS;
login		return LOGIN;
multiple	return MULTIPLE;
refuse		return REFUSE;
session		return SESSION;
sleep		return SLEEP;
warn            return WARN;
threshold	return THRESHOLD;
timeout		return TIMEOUT;
tty		return TTY;
normal          return NORMAL;
off             return OFF;
X
[/A-Za-z][/A-Za-z0-9_]*	{   
X				yylval.sb = makestr(yytext);
X				return NAME; 
X			}
X
[0-9]+			{
X				yylval.nb = atoi(yytext);
X				return NUM;
X			}
X
"#".*			;
X
"\n"			{ 
X				linenum++; 
X				return NL;
X			}
[ \t]*			;
X
X.			{
X				static	char	errormsg[] = "Illegal character ' '.";
X
X				errormsg[19] = yytext[0];
X				yyerror(errormsg);
X			}
SHAR_EOF
  $shar_touch -am 1026080094 'idled-1.00/scan.l' &&
  chmod 0644 'idled-1.00/scan.l' ||
  echo 'restore of idled-1.00/scan.l failed'
  shar_count="`wc -c < 'idled-1.00/scan.l'`"
  test 976 -eq "$shar_count" ||
    echo "idled-1.00/scan.l: original size 976, current size $shar_count"
fi
# ============= idled-1.00/warn.c ==============
if test -f 'idled-1.00/warn.c' && test X"$1" != X"-c"; then
  echo 'x - skipping idled-1.00/warn.c (File already exists)'
else
  echo 'x - extracting idled-1.00/warn.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'idled-1.00/warn.c' &&
/*
**	Warn users of impending logout, and zap them if they
**	have already been warned.
*/
#include <unistd.h>
X
#include <signal.h>
#include <sys/ioctl.h>
X
#include "idled.h"
#include "y.tab.h"
X
#ifdef SYSV
#include <sys/termios.h>
#include <sys/fcntl.h>
#endif /* SYSV */
X
jmp_buf	env_buf;
X
extern	void	finish(),
X		wakeup(),
X		zap();
X
extern	char	*ctime(),
X		*malloc(),
X		*strcpy();
X
extern	int	strlen();
X
time_t		time();
X
#define debug logfile
X
void
warn(i, type)
register int	i;
int		type;
{
X   register struct user *him;
X   int     opened = 0;
X   FILE   *termf;
X   time_t  tempus;
X
X   if (type == IS_IDLE || type == IS_XLOCK)
X      him = &users[i];
X   else				/* type == IS_MULT || type == IS_LIMIT || type == IS_REFU */
X      him = pusers[i];
X
X
X   switch (fork ())
X    {
X    case SYSERROR:
X       logfile ("Cannot fork in warn.");
X       finish ();
X
X    case 0:
X       break;
X
X    default:
X       if (type == IS_MULT && !(him->warned & IS_MULT))
X	  him->warned |= IS_MULT;
X
X       if (type == IS_IDLE && !(him->warned & IS_IDLE))
X	  him->warned |= IS_IDLE;
X
X       if (type == IS_LIMIT && !(him->warned & IS_LIMIT))
X	  him->warned |= IS_LIMIT;
X
X       wait (0);
X       return;
X    }
X
X
X   /*
X    *  Normal zero return means we just continue.
X    *  1 is returned on timeout by SIGALRM, see wakeup
X    *  free FILE without write
X    */
X
X   if (setjmp (env_buf) == 1)
X   {
X      if (opened)
X      {
X	 termf->_ptr = termf->_base;
X	 (void) fclose (termf);
X      }
X
X      exit (0);
X   }
X
X   (void) alarm (5);
X
X   if ((termf = fopen (him->line, "w")) == (FILE *) NULL)
X   {
X      logfile
X	 (
X	    "Error in warn:  Cannot open %s for %s.",
X	    him->line,
X	    him->uid
X	 );
X
X      exit (0);
X   }
X
X   opened = 1;
X
X   /* start the terminal if stopped */
X
X   (void) ioctl (fileno (termf), TIOCSTART, (char *) 0);
X   tempus = time ((long *) NULL);
X
X   switch (type)
X    {
X    case IS_MULT:
X       if (him->warned & IS_MULT)
X       {
X	  zap (him, "multiple");
X	  break;
X       }
X
X       if ((sleeptime % 60) == 0)
X       {
X	  (void) fprintf
X	     (
X		termf,
X		"%s%19.19s%s%s %d %s",
X		"\007\r\n\r\n",
X		ctime (&tempus),
X		"\nThis user id is logged on more than once, please end\r\n",
X		"all but one of your logins in the next",
X		sleeptime / 60,
X		"minutes\r\nor you will be logged out by the system.\r\n\r\n\007"
X	     );
X       }
X       else
X       {
X	  (void) fprintf
X	     (
X		termf,
X		"%s%19.19s%s%s %d %s",
X		"\007\r\n\r\n",
X		ctime (&tempus),
X		"\nThis user id is logged on more than once, please end\r\n",
X		"all but one of your logins in the next",
X		sleeptime,
X		"seconds\r\nor you will be logged out by the system.\r\n\r\n\007"
X	     );
X       }
X
X       break;
X
X    case IS_XLOCK:
X       zap (him, "xlock");
X       break;
X
X    case IS_IDLE:
X       if (him->warned & IS_IDLE)
X       {
X	  zap (him, "idle");
X	  break;
X       }
X
X       if ((warntime % 60) == 0)
X       {
X	  (void) fprintf
X	     (
X		termf,
X		"%s%19.19s%s %d %s %d %s",
X		"\007\r\n\r\n",
X		ctime (&tempus),
X		"\nThis terminal has been idle",
X		him->idle / 60,
X		"minutes. If it remains idle\r\nfor",
X		warntime / 60,
X		"more minutes it will be logged out by the system.\r\n\r\n\007"
X	     );
X       }
X       else
X       {
X	  (void) fprintf
X	     (
X		termf,
X		"%s%19.19s%s %d %s %d %s",
X		"\007\r\n\r\n",
X		ctime (&tempus),
X		"\nThis terminal has been idle",
X		him->idle / 60,
X		"minutes. If it remains idle\r\nfor",
X		warntime,
X		"more seconds it will be logged out by the system.\r\n\r\n\007"
X	     );
X       }
X
X       break;
X
X    case IS_LIMIT:
X       if (him->warned & IS_LIMIT)
X       {
X	  zap (him, "session");
X	  break;
X       }
X
X       if ((sleeptime % 60) == 0)
X       {
X	  (void) fprintf
X	     (
X		termf,
X		"%s%19.19s%s %d %s %d %s",
X		"\007\r\n\r\n",
X		ctime (&tempus),
X		"\nThis terminal has been in use",
X		him->session / 60,
X		"minutes.\nIn",
X		sleeptime / 60,
X		"minutes it will be logged out by the system.\r\n\r\n\007"
X	     );
X       }
X       else
X       {
X	  (void) fprintf
X	     (
X		termf,
X		"%s%19.19s%s %d %s %d %s",
X		"\007\r\n\r\n",
X		ctime (&tempus),
X		"\nThis terminal has been in use",
X		him->session / 60,
X		"minutes.\nIn",
X		sleeptime,
X		"seconds it will be logged out by the system.\r\n\r\n\007"
X	     );
X       }
X
X       break;
X
X    case IS_REFU:
X       (void) fprintf
X	  (
X	     termf,
X	     "%s%19.19s%s %s",
X	     "\007\r\n\r\n",
X	     ctime (&tempus),
X	     "\nYour terminal session is about to be",
X	     "terminated by the system.\r\n\r\n\007"
X	  );
X
X       /* 5 is what I wanted here, but for some reason it would cause
X        * the running process to give up and exit at this statement if
X        * I did 5 or more.  Hence, 4 seconds of warn time before zapping.
X        */
X       (void) sleep ((unsigned) 4);
X       zap (him, "refused");
X       break;
X    }
X
X   (void) fclose (termf);
X   opened = 0;
X   (void) alarm (0);
X   exit (0);			/* child exits here */
}
X
X
/* signal handler for SIGALRM */
X
void
wakeup()
{
X	(void)longjmp(env_buf, 1);
}
SHAR_EOF
  $shar_touch -am 1129165694 'idled-1.00/warn.c' &&
  chmod 0644 'idled-1.00/warn.c' ||
  echo 'restore of idled-1.00/warn.c failed'
  shar_count="`wc -c < 'idled-1.00/warn.c'`"
  test 4949 -eq "$shar_count" ||
    echo "idled-1.00/warn.c: original size 4949, current size $shar_count"
fi
# ============= idled-1.00/xlock_check.c ==============
if test -f 'idled-1.00/xlock_check.c' && test X"$1" != X"-c"; then
  echo 'x - skipping idled-1.00/xlock_check.c (File already exists)'
else
  echo 'x - extracting idled-1.00/xlock_check.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'idled-1.00/xlock_check.c' &&
/* This module checks for an "xlock" console locking programming
X * running on the machine by the person logged in on console.
X * If one is found, it returns the time that it was started.
X */
X 
#include <stdlib.h>     /* Don't leave home without it. */
#include <dirent.h>     /* For opendir, readdir, and such */
#include <string.h>     /* For my string copies and compares */
#include <pwd.h>        /* For struct passwd and getpwnam */
X
#include "idled.h"
X
#ifdef HAVE_PROC_FS
#include <sys/signal.h>
#include <sys/fault.h>
#include <sys/syscall.h>
#include <sys/procfs.h>
#endif
X
#ifdef SYSV
#include <fcntl.h>
#endif
X
extern void   logfile();
#define debug logfile
X
int sameuser(char *username, prpsinfo_t procinfo)
{
X   struct passwd *pw;
X
X   pw = getpwnam(username);
X   if (pw->pw_uid == procinfo.pr_uid)
X   {
X      return 1;
X   }
X   return 0;
}
X   
time_t xlock_check(char *username)
{
#ifdef HAVE_PROC_FS
X   int starttime;
X   time_t tempus;
X   prpsinfo_t procinfo;
X   int     procfd;
X   DIR    *dirp;
X   struct dirent *dp;
X   static char procfile[] = "/proc/XXXXX";
X
X   (void) time(&tempus);
X
X   dirp = opendir ("/proc");
X   if (dirp == NULL)
X   {
X      debug ("Error.  Cannot open /proc");
X      return NULL;
X   }
X
X   starttime = -1;
X   while ((dp = readdir (dirp)) != NULL)
X   {
X      /* Skip "." and ".." (some NFS filesystems' directories lack them). */
X      if (dp->d_name != NULL && strcmp (".", dp->d_name) != 0 && strcmp ("..", dp->d_name) != 0)
X      {
X	 strncpy (procfile + 6, dp->d_name, 5);
X
X	 if ((procfd = open (procfile, O_RDONLY)) >= 0)
X	 {
X	    ioctl (procfd, PIOCPSINFO, &procinfo);
X	    close (procfd);
X
X	    /* Only collect non-zombies with controlling tty */
X	    if (procinfo.pr_ttydev != PRNODEV && !procinfo.pr_zomb)
X	    {
X	       if (procinfo.pr_fname == NULL)
X	       {
X		  debug ("procinfo.pr_fname is null");
X	       }
X	       else if (strcmp(procinfo.pr_fname,XLOCK_NAME) == 0)
X	       {
X                  if (sameuser(username,procinfo))
X                  {
X                     starttime = tempus-procinfo.pr_start.tv_sec;
X                     debug ("Program %19s	started by %d at %d.", procinfo.pr_fname, procinfo.pr_uid,
X                           starttime);
X                     break;     /* Just find the first xlock program */
X                  }
X                  else
X                  {
X                     debug ("xlock running by different user.");
X                  }
X	       }
X	    }
X
X	 }
X      }
X   }
X   closedir (dirp);
X
X   return starttime;
#endif /* HAVE_PROC_FS */
}
SHAR_EOF
  $shar_touch -am 1004211394 'idled-1.00/xlock_check.c' &&
  chmod 0644 'idled-1.00/xlock_check.c' ||
  echo 'restore of idled-1.00/xlock_check.c failed'
  shar_count="`wc -c < 'idled-1.00/xlock_check.c'`"
  test 2530 -eq "$shar_count" ||
    echo "idled-1.00/xlock_check.c: original size 2530, current size $shar_count"
fi
# ============= idled-1.00/y.tab.h ==============
if test -f 'idled-1.00/y.tab.h' && test X"$1" != X"-c"; then
  echo 'x - skipping idled-1.00/y.tab.h (File already exists)'
else
  echo 'x - extracting idled-1.00/y.tab.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'idled-1.00/y.tab.h' &&
X
typedef union
#ifdef __cplusplus
X	YYSTYPE
#endif
X {
X	char *sb; 
X	int nb;
X       } YYSTYPE;
extern YYSTYPE yylval;
# define TTY 257
# define LOGIN 258
# define GROUP 259
# define DEFAULT 260
# define EXEMPT 261
# define TIMEOUT 262
# define SLEEP 263
# define WARN 264
# define CONSWINS 265
# define SESSION 266
# define REFUSE 267
# define NUM 268
# define IDLE 269
# define MULTIPLE 270
# define NAME 271
# define ALL 272
# define THRESHOLD 273
# define NL 274
# define NORMAL 275
# define OFF 276
SHAR_EOF
  $shar_touch -am 1129161894 'idled-1.00/y.tab.h' &&
  chmod 0644 'idled-1.00/y.tab.h' ||
  echo 'restore of idled-1.00/y.tab.h failed'
  shar_count="`wc -c < 'idled-1.00/y.tab.h'`"
  test 500 -eq "$shar_count" ||
    echo "idled-1.00/y.tab.h: original size 500, current size $shar_count"
fi
# ============= idled-1.00/zap.c ==============
if test -f 'idled-1.00/zap.c' && test X"$1" != X"-c"; then
  echo 'x - skipping idled-1.00/zap.c (File already exists)'
else
  echo 'x - extracting idled-1.00/zap.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'idled-1.00/zap.c' &&
/*
**	Actually does the killing of terminal jobs 
*/
X
#include <utmp.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/file.h>
#include <sys/resource.h>       /* For rlimit stuff */
X
#include "idled.h"
X
#ifdef SYSV
#include <sys/termios.h>
#include <sys/fcntl.h>
#endif /* SYSV */
X
#include <signal.h>             /* For "kill" and SIGKILL */
X
static	char	message[] = "\n\n\007Logged out by the system.\n";
X
extern	char	*ctime(),
X		*malloc(),
X		*strcpy();
X
time_t		time();
X
void close_descriptors();
X
#define debug logfile
X
/*
**	Disconnect the person logged on to tty "dev".
** 	Get a new controlling terminal and then use
**	infinitely clever vhangup to disconnect it.  
*/
X
void
zap(him, type)
register struct	user	*him;
char			*type;
{
X   register int dts;
X   register int td;
X   time_t  tempus;
X
X   /* close all the child's descriptors */
X
X   close_descriptors();
X
X   /* now tell him it's over, and disconnect */
X
X   td = open (him->line, O_RDWR, 0600);
X   (void) ioctl (td, TIOCSTART, (char *) 0);
X   tempus = time ((long *) NULL);
X
X   if (td >= 0)
X   {
#ifndef DEBUG
X      (void) write (td, message, sizeof (message));
X      (void) fsync (td);
X      (void) ioctl (td, TIOCFLUSH, (char *) 0);
X      close (td);
X
X      kill ((pid_t) him->pid, SIGKILL);
X
X
X      logfile
X	 (
X	    "%19.19s : %s on %s because %s",
X	    ctime (&tempus),
X	    him->uid,
X	    him->line,
X	    type
X	 );
#else
X      debug("Just pretended to kill user %s on %s because of %s with pid %d.",
X            him->uid, him->line, type, him->pid);
#endif
X   }
X   else
X   {
X      logfile
X	 (
X	    "%19.19s : couldn't open %s for %s.",
X	    ctime (&tempus),
X	    him->line,
X	    him->uid
X	 );
X   }
}
X
void
close_descriptors()
{
X   int     nfds, fd, i;
X   struct rlimit rl;
X
#ifdef RLIMIT_NOFILE
X   if (getrlimit (RLIMIT_NOFILE, &rl) < 0)
X      logfile ("Error calling system function: getrlimit");
X   nfds = rl.rlim_max;
#else /* RLIMIT_NOFILE */
X   nfds = getdtablesize ();
#endif /* RLIMIT_NOFILE */
X
X   /* Close all fds. */
X   for (fd = 0; fd < nfds; ++fd)
X   {
X      (void) close (fd);
X   }
}
SHAR_EOF
  $shar_touch -am 1129163994 'idled-1.00/zap.c' &&
  chmod 0644 'idled-1.00/zap.c' ||
  echo 'restore of idled-1.00/zap.c failed'
  shar_count="`wc -c < 'idled-1.00/zap.c'`"
  test 2078 -eq "$shar_count" ||
    echo "idled-1.00/zap.c: original size 2078, current size $shar_count"
fi
exit 0
