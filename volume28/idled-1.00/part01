Newsgroups: comp.sources.unix
From: crider@cs.hope.edu (The FLASH)
Subject: v28i207: idled-1.00 - idle (et al) session detector/sanctioner, V1.00, Part01/02
Message-id: <1.786345433.1153@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: crider@cs.hope.edu (The FLASH)
Posting-Number: Volume 28, Issue 207
Archive-Name: idled-1.00/part01

        Idled is a "demon" that runs on a machine to keep an eye on current
users.  If users have been idle for too long, or have been logged on for
too long, it will warn them and log them out appropriately.  The types of
checks that idled performs are the following:

        idle:     If a user is idle more than their allotted time, as
                  specified by the idled configuration file, he/she will be
                  warned.  If no action has taken place during the warn
                  time, the user will then be logged out.

        session:  If a user is logged on for longer than the allotted
                  time, he/she will be warned and logged out in 'sleep'
                  seconds if the user is still logged on then.

        multiple: If too many user sessions are active (ie. many users
                  logged on, or some users logged on many times), idled
                  will choose 1 session for each user to keep, will
                  warn the others, and log those out in 'sleep' seconds
                  (such as 120) if there are still too many logged in
                  then.         **** See TODO file! ***

        refuse:   If a user matches this setting, idled will terminate
                  the user's session after about a 5 second warning.
                  The basically "refuse"s access for that user (or
                  tty, or group) to the machine, though there may be
                  some time allowed when idled is sleeping between
                  checks.

        All comments and suggestions for idled would be greatly appreciated
and should be sent to crider@cs.hope.edu

#!/bin/sh
# This is a shell archive (produced by GNU shar 4.0).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1994-12-01 23:50 EST by <crider@oin>.
# Source directory was `/home/crider/main/projects/idled'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#   4748 -rw-r--r-- idled-1.00/README
#   2942 -rw-r--r-- idled-1.00/Makefile
#   1366 -rw-r--r-- idled-1.00/TODO
#   6770 -rw-r--r-- idled-1.00/Untamo.Readmes
#  21551 -rw-r--r-- idled-1.00/idled.c
#   2265 -rw-r--r-- idled-1.00/idled.8
#   1573 -rw-r--r-- idled-1.00/idled.cf
#   5789 -rw-r--r-- idled-1.00/idled.cf.5
#   3285 -rw-r--r-- idled-1.00/idled.h
#    432 -rw-r--r-- idled-1.00/insque.c
#   3889 -rw-r--r-- idled-1.00/list.c
#
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo 'WARNING: not restoring timestamps'
fi
rm -f 1231235999 $$.touch
#
# ============= idled-1.00/README ==============
if test ! -d 'idled-1.00'; then
  echo 'x - creating directory idled-1.00'
  mkdir 'idled-1.00'
fi
if test -f 'idled-1.00/README' && test X"$1" != X"-c"; then
  echo 'x - skipping idled-1.00/README (File already exists)'
else
  echo 'x - extracting idled-1.00/README (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'idled-1.00/README' &&
X                            Idled  --  Idle "Demon"
X
X                                  Version 1.00
X                                        
X                          Written by Michael P. Crider
X
X                        with guidance from Mike Jipping
X
X                        Hope College -- Holland, MI  USA
X
X                                Based on Untamo
X
INTRODUCTION
X
X        Idled is a "demon" that runs on a machine to keep an eye on current
users.  If users have been idle for too long, or have been logged on for
too long, it will warn them and log them out appropriately.  The types of
checks that idled performs are the following:
X
X        idle:     If a user is idle more than their allotted time, as
X                  specified by the idled configuration file, he/she will be
X                  warned.  If no action has taken place during the warn
X                  time, the user will then be logged out.
X
X        session:  If a user is logged on for longer than the allotted
X                  time, he/she will be warned and logged out in 'sleep'
X                  seconds if the user is still logged on then.
X
X        multiple: If too many user sessions are active (ie. many users
X                  logged on, or some users logged on many times), idled
X                  will choose 1 session for each user to keep, will
X                  warn the others, and log those out in 'sleep' seconds
X                  (such as 120) if there are still too many logged in
X                  then.         **** See TODO file! ***
X
X        refuse:   If a user matches this setting, idled will terminate
X                  the user's session after about a 5 second warning.
X                  The basically "refuse"s access for that user (or
X                  tty, or group) to the machine, though there may be
X                  some time allowed when idled is sleeping between
X                  checks.
X
FEATURES
X
X        Idled is configurable without recompilation for its settings, such
as the maximum allowed idle times, session limits, thresholds before
session limits and multiple login checks begin, and also the important
exemption lists.  The configuration file is automatically re-read every
'sleep' seconds (specified in the configuration file).  If the
configuration file missing or contains errors when idled attempts to update
its configuration, it will simply report the errors to its log file and
continue normal operation, either with its previous settings (in the event
of the file not being there or not being readable) or with all valid
settings (in the event of errors in the conf file).  Idled must exit,
however, if the configuration file is doesn't exist or is not readable when
it first starts, and will also exit at the start if there are errors in the
configuration file (since they should be fixed then).
X        Exemptions can be set for any user, group, or tty for any of the
checks that idled performs, such as allowing idle timeouts to default to 60
minutes for everyone, but exempting the 'staff' group from these timeouts.
X        Idled has the ability to handle the console as special, so that
XX-Windows environments can have appropriate settings.  The special handling
includes giving an idle time for the console, with checking for activity by
checking the keyboard and mouse (if in X-Windows), allowing the person on
console to be exempt from idle logins on that machine, and checking to see
if the person on console is running xlock (or some terminal locking
program--the name is configurable at compilation time) and logging the user
off if the xlock program runs longer than the allowed console idle time.
The special xlock check prevents users from running xlock and leaving the
terminal for a long period of time, but not getting logged off, since other
users may press a key or move the mouse to see if the machine is available,
and in doing so makes the logged in user no longer idle.  See TODO file for
a comment on xlock.
X        The configuration file's path may be specified on the command line,
so that one executable can be used on multiple machines with different path
structures.
X
ACKNOWLEDGEMENTS
X
X        Idled was heavily based on the code from Untamo 3.  We give many
thanks to Craig Bishop of Deakin University for his rework of the original
Untamo, as well as many thanks to Andy Wilcox and Marc Megel of Purdue
University for their hard work on the original Untamo.  Idled certainly
would not have all the functionality it has if it was not for these people.
X
AVAILABILITY
X        The newest version of idled is available via anonymous ftp to
ftp.cs.hope.edu in /pub
X        All comments and suggestions for idled would be greatly appreciated
and should be sent to crider@cs.hope.edu
X
SHAR_EOF
  $shar_touch -am 1130102394 'idled-1.00/README' &&
  chmod 0644 'idled-1.00/README' ||
  echo 'restore of idled-1.00/README failed'
  shar_count="`wc -c < 'idled-1.00/README'`"
  test 4748 -eq "$shar_count" ||
    echo "idled-1.00/README: original size 4748, current size $shar_count"
fi
# ============= idled-1.00/Makefile ==============
if test -f 'idled-1.00/Makefile' && test X"$1" != X"-c"; then
  echo 'x - skipping idled-1.00/Makefile (File already exists)'
else
  echo 'x - extracting idled-1.00/Makefile (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'idled-1.00/Makefile' &&
# Makefile for Idled
#
X
# C compiler flags
INCLUDE = 
# Not recommended to compile for BSD at this time, since it won't
# work under it!  (It is a TODO.)
#DEFS += -DBSD4_2
DEFS += -DSYSV -DSVR4
# Define DEBUG to have idled put more debug information in its logfile.
# It will not log anyone off when compiled in debug mode!
#DEFS += -DDEBUG
CFLAGS = -g ${DEFS} ${INCLUDE}
LIBS =
X
#install flags
DEST = /local/bin
FDEST = /local/lib
MDEST = /usr/local/man
OWNER = bin
FOWNER = root
MOWNER = man
GROUP = bin
FGROUP = operator
MODE = 750
FMODE = 664
MMODE = 644
X
# Source files to be mkdepended
SRC = insque.c list.c idled.c warn.c xlock_check.c zap.c
SRCl = parse.y scan.l
SRCg = parse.c scan.c
HDR = idled.h
OBJ = insque.o list.o parse.o scan.o idled.o warn.o xlock_check.o zap.o
X
# programs that need explicit make lines, plain files
BINARY = idled
COMMFILE = idled.cf
MAN5  = idled.cf.5
MAN8  = idled.8
X
all: ${BINARY} ${COMMFILE}
X
clean:
X	rm -f a.out ${OBJ} core errs lint.errs Makefile.bak *.s tags \
X		${SRCg} ${BINARY} y.tab.* lex.yy.c
X
depend: ${SRC} ${SRCg} ${HDR}
X	maketd -a ${DEFS} ${INCLUDE} ${SRC} ${SRCg}
X
install: all 
X	install -c -m ${MODE} -o ${OWNER} -g ${GROUP} ${BINARY} ${DEST}
X	install -c -m ${FMODE} -o ${FOWNER} -g ${FGROUP} ${COMMFILE} ${FDEST}
X	install -c -m ${MMODE} -o ${MOWNER} ${MAN5} ${MDEST}/man5
X	install -c -m ${MMODE} -o ${MOWNER} ${MAN8} ${MDEST}/man8
X
lint: ${SRC} ${SRCg}
X	lint -hxn ${DEFS} ${SRC} ${SRCg}
X	
print: 
X	print -n -J "Idled Source" Makefile ${HDR} ${SRCl} ${SRC}
X
shar:
X	shar README Makefile ${COMMFILE} ${MAN} ${SRC} ${SRCl} ${HDR} > idled.shar
X
source: ${SRC} ${SRCl} ${HDR} ${MAN} ${COMMFILE}
X
spotless:
X	rm -f a.out ${OBJ} core errs lint.errs Makefile.bak y.tab.* yacc.act\
X		yacc.tmp *.s ${BINARY} tags parse.c scan.c
X	rcsclean ${SRC} ${SRCl} ${HDR} ${COMMFILE} ${MAN}
X
tags: ${SRCS} ${SRCg} tags
X	ctags ${SRC} ${SRCg}
X
${SRC} ${SRCl} ${HDR} ${COMMFILE} ${MAN}:
X	co $@
X
# rules for everybody in ${BINARY} go here
idled: ${OBJ}
X	cc ${CFLAGS} -o idled ${OBJ} ${LIBS}
X
y.tab.h: parse.c
X
parse.c:
X	yacc -d parse.y
X	mv y.tab.c parse.c
X
scan.c:
X	lex scan.l
X	mv lex.yy.c scan.c
X
# DO NOT DELETE THIS LINE - make depend DEPENDS ON IT
I=/usr/include
S=/usr/include/sys
X
insque.o: insque.c
X
list.o: $I/setjmp.h $I/stdio.h $S/file.h $S/types.h list.c idled.h y.tab.h
X
idled.o: $I/pwd.h $I/setjmp.h $I/signal.h $I/stdio.h $S/file.h $S/ioctl.h \
X	$S/stat.h $S/ttychars.h $S/types.h $I/utmp.h \
X	idled.c idled.h y.tab.h
X
idled.o: $I/setjmp.h $I/stdio.h $S/types.h idled.h
X
warn.o: $I/setjmp.h $I/signal.h $I/stdio.h $S/ioctl.h \
X	$S/ttychars.h $S/types.h idled.h warn.c y.tab.h
X
xlock_check.o: $I/stdlib.h $I/dirent.h $I/string.h
X
zap.o: $I/setjmp.h $I/stdio.h $S/file.h $S/ioctl.h $S/ttychars.h \
X	$S/types.h $S/wait.h $I/utmp.h idled.h zap.c
X
parse.o: $I/grp.h $I/setjmp.h $I/stdio.h $S/types.h parse.c idled.h
X
scan.o: $I/stdio.h scan.c y.tab.h
X
# *** Do not add anything here - It will go away. ***
SHAR_EOF
  $shar_touch -am 1129195994 'idled-1.00/Makefile' &&
  chmod 0644 'idled-1.00/Makefile' ||
  echo 'restore of idled-1.00/Makefile failed'
  shar_count="`wc -c < 'idled-1.00/Makefile'`"
  test 2942 -eq "$shar_count" ||
    echo "idled-1.00/Makefile: original size 2942, current size $shar_count"
fi
# ============= idled-1.00/TODO ==============
if test -f 'idled-1.00/TODO' && test X"$1" != X"-c"; then
  echo 'x - skipping idled-1.00/TODO (File already exists)'
else
  echo 'x - extracting idled-1.00/TODO (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'idled-1.00/TODO' &&
Things on the TODO list:
X
1.  Rewrite the MULTIPLE Timeouts such that it will allow users
X    to have more than one login ig the situation is appropriate.
X    Right now, if there are X many logins, such as 20, among 2
X    users or so, and it is at or over the multiple threshold,
X    then each user, in this case both users, are allowed only
X    1 tty each.  This is really dumb.  I want to rewrite it to
X    allow floor(X/(num users)).
X
2.  Get it all working for SunOS 4.1.x.
X
3.  Session timeouts should be edited to prevent a user from
X    logging in again right after being subject to a session limit.
X
4.  The current xlock check is a little cheesy, sincea user can
X    avoid the checks by running it under a different name than
X    chosen at compile time.  I would like to rewrite the checks
X    to see if a program has grabbed full control of the keyboard,
X    and if one does, it is probably an xlock program.  I'm not
X    sure how I would work it all right now, but idled might have
X    to simply notice the first time it found such a program and
X    see if one is still running 'idle time' minutes later.  This
X    is imperfect, however, as it is possible for the user to exit
X    the xlock program for a very short period of time (less than
X    'sleep' seconds, as specified in the conf file) and start a
X    new one.  But, I would like to do something.
SHAR_EOF
  $shar_touch -am 1129183394 'idled-1.00/TODO' &&
  chmod 0644 'idled-1.00/TODO' ||
  echo 'restore of idled-1.00/TODO failed'
  shar_count="`wc -c < 'idled-1.00/TODO'`"
  test 1366 -eq "$shar_count" ||
    echo "idled-1.00/TODO: original size 1366, current size $shar_count"
fi
# ============= idled-1.00/Untamo.Readmes ==============
if test -f 'idled-1.00/Untamo.Readmes' && test X"$1" != X"-c"; then
  echo 'x - skipping idled-1.00/Untamo.Readmes (File already exists)'
else
  echo 'x - extracting idled-1.00/Untamo.Readmes (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'idled-1.00/Untamo.Readmes' &&
**********************************************************************
****************** README from reworked UNTAMO ***********************
**********************************************************************
The original Purdue University UNTAMO has been totally reworked, session
limits now work and thresholds do what the manual says.
X
A large amount of effort was put in with the allocation of variables to
registers, and the logging was reworked. This has resulted in a noticable
speed increase.
X
The above work was eased by a clean and quite clever design, any future
changes are likely to be just as easy.
X
More work will need to be done in the future to detect a user relogging in
after a session timeout, as well as a more flexible configuation syntax
at the moment several desirable system limits cannot be enforced.
X
Craig Bishop
Deakin University
**********************************************************************
**********************************************************************
**********************************************************************
X
**********************************************************************
******************** README from original UNTAMO *********************
**********************************************************************
Untamo is a locally developed daemon which periodically wakes up and
logs off idle terminals; it also can deal with multiply-logged in
users.  It is configurable without recompilation, and features tunable
parameters such as maximum allowed idle time, maximum allowable
multiple logins, exemption lists, and so on.
X
We use this program to ensure availability of one of our scarcer
resources: terminals.  Others may find it useful for different reasons;
preventing users from leaving a terminal logged-in and unattended
for hours is probably a reasonable security measure.
X
The original posting caused a deluge of mail, as the sources contained
references to local include files.  This has been fixed by #ifdef'ing
the code which applies only locally.  This version has been successfully
compiled on a Sequent Balance 21000 running Dynix v2.0.6, a CCI 6/32
running 4.3bsd, a DEC VAX-8600 running 4.3bsd, a Gould PowerNode 9080
Running UTX-32 Release 1.3, and and a VAX-11/780 running 4.2bsd.
**********************************************************************
**********************************************************************
**********************************************************************
X
**********************************************************************
***************** DOC file from original UNTAMO **********************
**********************************************************************
X                              The 'Untamo' Project
X
X                          Andy Wilcox and Marc Mengel
X
X                       Purdue University Computing Center
X
The Purdue University Computing Center needs more machines and
terminals to provide better services to our users.  The purchase
of more machines and terminals will come in time.  However, ways are needed
now to more evenly distribute our present resources.
The Untamo project is an attempt to solve these and related problems.
X
There is always a problem at the beginning of the semester with naive
users who turn their terminals off without logging out.  Many of these
unfortunate souls will soon be in the consultants office explaining
how their account was booby trapped by a malicious user.  Untamo will
decide that a terminal is idle if the keyboard has not been touched
for thirty minutes (this choice of time is under investigation).  Untamo
will then log out idle terminals after a warning message has been sent to them.
This will help combat this serious security problem, and save large
amounts of work on the user's part if his or her files were deleted.
X
Sometimes it is advantageous to have idle terminals, for example, a
Vaxen console.  Untamo also provides an 'exemption' feature that allows 
such cases.
X
Late in the semester when final projects are due, there are inevitably
waiting lines for the terminals, and ideally we would prefer one user to
be logged on only once.  With job control in c-shell, there is no
need to be logged in more than once.  Untamo looks for these multiple logins,
warns each one of them, and then will log out all but the first terminal
to be logged on.
X
Once again, there are exceptions to the case of multiple logins.  
Many times the consultants can log a person in again and fix a hung terminal
by killing a runaway process without having to call the console room.
Untamo allows a few minutes of multiple login time, which is enough time
to locate and kill a runaway process.
X
Another problem has arisen since the advent of unrestricted terminal access,
namely people staying logged on for long periods of time, and causing huge
queues to build up waiting for ports on busy machines.
We have recorded times in the queue in excess of 2 hours, and have had eight
deep rlogins on ports from people avoiding going back out to the switch.
The apparently neccesary solution to these problems is session limits. 
Untamo will now enforce session limits -- after the specified session limit
has expired, the user is given a warning, and soon thereafter logged off.
X
Similar to idle time, there are terminals and/or people who need to be
logged on indefinitely.
Untamo provides exemptions for session limits to provide for theses situations.
X
Untamo is also usage sensitive.
It can be configured with a threshold number of users for both multiple login
restriction and session limit enforcement.
This allows Untamo to enforce these policies only when they are needed
(i.e. when ports are scarce), and not at other times.
X
It is important to note that Untamo will primarily affect our public
terminals.  Most other terminals will be 'exempt'.
X
Untamo is a dynamically reconfigurable program, so if there is a 
problem with someone needing more idle time, or a multiple login,
it can be added without killing Untamo, recompiling, reinstalling, 
and restarting.  These changes take effect in a few minutes, so the
wait is not long.  
X
The amount of time Untamo 'sleeps' between checking logins and idle times
is also redefinable, it can be made larger by the operator on a 
heavily loaded machine to allow more time for a multiple login.  This 
necessary human interaction with Untamo is questionable, and 
ways of making the sleep time a function of the 
load are being investigated.  In any case, the operator always has
final control of Untamo.
**********************************************************************
**********************************************************************
**********************************************************************
SHAR_EOF
  $shar_touch -am 1129152094 'idled-1.00/Untamo.Readmes' &&
  chmod 0644 'idled-1.00/Untamo.Readmes' ||
  echo 'restore of idled-1.00/Untamo.Readmes failed'
  shar_count="`wc -c < 'idled-1.00/Untamo.Readmes'`"
  test 6770 -eq "$shar_count" ||
    echo "idled-1.00/Untamo.Readmes: original size 6770, current size $shar_count"
fi
# ============= idled-1.00/idled.c ==============
if test -f 'idled-1.00/idled.c' && test X"$1" != X"-c"; then
  echo 'x - skipping idled-1.00/idled.c (File already exists)'
else
  echo 'x - extracting idled-1.00/idled.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'idled-1.00/idled.c' &&
/*
X *	Main idled routine contols everything.
X */
X
#include <utmp.h>
#include <signal.h>
#include <sys/file.h>
X
#include "idled.h"
X
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <pwd.h>
#include <grp.h>
#include <sys/resource.h>
X
#include "y.tab.h"
X
#ifdef SYSV
#include <sys/termios.h>
#include <sys/fcntl.h>
#endif /* SYSV */
X
#define min(a,b)	( (a)<(b)?(a):(b) )
#define max(a,b)	( (a)>(b)?(a):(b) )
X
#define debug logfile
X
X
struct	user	users[MAXUSERS];
struct	user	*pusers[MAXUSERS];
X
struct	qelem	*exmpt;	 	/* lists for exemptions */
struct	qelem	*refuse;	/* lists for refusals */
struct	qelem	*rules;		/* lists for timeouts */
struct	qelem	*session;	/* lists for session limits */
char    console_user[NAMELEN];  /* name of the person on console */
X
int	m_threshold;	/* number of users before multiple limits */
int	s_threshold;	/* number of users before session limits */
int	sleeptime;	/* max time to sleep between checks */
int	warntime;	/* time to allow for idle warning time */
int     conswins_time;  /* time to allow for idle time for terminals opened
X                         * by the user on console on this machine.
X                         */
X
void	chk_idle(),
X	chk_multiple(),
X	chk_refuse(),
X	chk_session(),
X        console_check(),
X	finish(),
X	getgroups_func(),
X	logfile();
X
int	comp(),
X	decide();
X
extern	void	wakeup();
X
extern	void	freelist(),
X		setlimits(),
X		warn();
X
extern	char	*malloc(),
X		*strcpy(),
X		*ctime(),
X		*strcat();
X
extern	int	strlen();
X
extern	time_t	time();
X
extern  int     xlock_check();    /* From xlock_check.c */
X
/* Configuration Stuffs */
char    *config_file;
int     update_configuration();
time_t  conf_oldstamp;
X
void daemonize();
X
int
main(int argc, char *argv[])
{
X   register int userptr;
X   register int utmptr;
X   register struct user *user;
X   int     fl_idle = 1;
X   int     fl_multiple = 1;
X   int     fl_refuse = 1;
X   int     fl_session = 1;
X   int     new;
X   int     res;
X   int     td;
X   int     utmpfd;
X   char    pathbuf[20];
X   char    tmpname[NAMELEN + 1];
X   time_t  tempus;
X   int     nextcheck;   /* Number of seconds to next check status */
X   FILE   *logfd;
X   struct utmp utmpbuf;
X   struct stat statbuf;
X   struct passwd *pswd;
X   int     i;
X
X   strcpy(console_user,"");
X   conswins_time = -2;          /* default the actions to 'normal' logouts */
X
X   config_file = CONFIG;
X
X   for (i = 1; i < argc; i++)
X   {
X      if (argv[i] == NULL)
X         continue;
X      if (argv[i][0] == '-' && argv[i][2] == '\0')
X      {
X         switch (argv[i][1])
X         {
X         case 'm':		/* no multiple login checks */
X            fl_multiple = 0;
X            break;
X
X         case 'i':		/* no idle timeouts */
X            fl_idle = 0;
X            break;
X
X         case 'r':		/* no refusals */
X            fl_refuse = 0;
X            break;
X
X         case 's':		/* no session limits */
X            fl_session = 0;
X            break;
X
X         case 'f':             /* Set the configuration file name */
X            if (argv[i+1] != NULL)
X            {
X               config_file = (char *) malloc(strlen(argv[i+1])+1);
X               strcpy(config_file,argv[i+1]);
X               fprintf(stderr,"Using configuration file '%s'.\n",config_file);
X               i++;
X            }
X            else
X               fprintf(stderr,"idled: flag -f specified without naming config file\n");
X            break;
X
X         default:
X            (void) fprintf (stderr, "idled: bad flag -%c\n", argv[i][1]);
X            break;
X         }
X      }
X      else
X         (void) fprintf (stderr, "idled: bad flag -%s\n", &argv[i][1]);
X   }
X
X   /* do nothing!! */
X
X   if (!fl_idle && !fl_multiple && !fl_refuse && !fl_session)
X      exit (0);
X
X   (void) signal (SIGHUP, SIG_IGN);
X   (void) signal (SIGQUIT, SIG_IGN);
X   (void) signal (SIGINT, SIG_IGN);
X
#ifdef BSD4_2
X   (void) signal (SIGTTOU, SIG_IGN);
X   (void) signal (SIGTSTP, SIG_IGN);
#endif	/* BSD4_2 */
X
X   (void) signal (SIGTERM, finish);
X   (void) signal (SIGALRM, wakeup);
X
X   /* a very old stamp for the configuration file */
X
X   conf_oldstamp = 1;
X
X   /* set up new header nodes for each of the lists */
X
X   exmpt = (struct qelem *) malloc (sizeof (struct qelem));
X   refuse = (struct qelem *) malloc (sizeof (struct qelem));
X   rules = (struct qelem *) malloc (sizeof (struct qelem));
X   session = (struct qelem *) malloc (sizeof (struct qelem));
X
X   exmpt->q_forw = exmpt->q_back = exmpt;
X   refuse->q_forw = refuse->q_back = refuse;
X   rules->q_forw = rules->q_back = rules;
X   session->q_forw = session->q_back = session;
X   exmpt->q_item = refuse->q_item = rules->q_item = session->q_item = NULL;
X
X   if ((logfd = fopen (LOGFILE, "a")) != (FILE *) NULL)
X   {
X      tempus = time ((long *) NULL);
X      (void) fprintf (logfd, "%24.24s  Idled started.\n", ctime (&tempus));
X      (void) fclose (logfd);
X   }
X   else
X   {
X      (void) fprintf (stderr, "idled: Cannot open log file: %s\n", LOGFILE);
X      exit (1);
X   }
X
X   switch (fork ())
X    {
X    case SYSERROR:
X       logfile ("Cannot fork.");
X       (void) fprintf (stderr, "idled: Cannot fork\n");
X       exit (1);
X
X    case 0:
X       break;
X
X    default:
X       exit (0);
X    }
X
X   /* lose our controlling terminal */
X   daemonize();
X   /* No more printing to stdout, or stderr allowed after this point! */
X
X   /* now sit in an infinite loop and work */
X
X   for (;;)
X   {
X      new = update_configuration();
X
X      (void) time (&tempus);
X
X      if ((utmpfd = open (UTMP, O_RDONLY, 0)) == SYSERROR)
X      {
X	 logfile ("%19.19s:  Cannot open /etc/utmp.",ctime(&tempus));
X	 exit (1);
X      }
X
X      /* Set our nextcheck time to the max (sleeptime), though it may
X       * be lowered in the coming for loop so that an idle tty gets
X       * only the alloted time to be idle before being warned.
X       */
X      nextcheck = tempus + sleeptime;
X
X      /*
X       * look through the utmp file, compare each entry to the users
X       * array to see if an entry has changed.  If it has, build a new
X       * record for that person, if it hasn't, see if it is time to
X       * examine him again.
X       */
X
X      for (utmptr = 0, userptr = 0; (res = read (utmpfd, (char *) &utmpbuf, sizeof (struct utmp))) > 0;)
X      {
X	 if (res != sizeof (struct utmp))
X	 {
X	    logfile ("Error reading utmp file, continuing.");
X            break;
/*	    continue;*/
X	 }
X
X	 (void) time (&tempus);
X
#ifdef SYSV
X         if (utmpbuf.ut_type == 7)
#else SYSV
X	 if (utmpbuf.ut_name[0] != NULL)
#endif SYSV
X	 {
X	    user = &users[utmptr];
X	    (void) strncpy (tmpname, utmpbuf.ut_name, NAMELEN);
X	    tmpname[NAMELEN] = NULL;
X
X	    if (!strcmp (user->uid, tmpname) && user->time_on == utmpbuf.ut_time)
X	    {
X	       if (new)
X		  setlimits (utmptr);
X
X               /* If we are handling idle stuff, check to see if it is time
X                * to see if this tty is idle, giving ourself five seconds of
X                * leeway time.
X                */
X	       if (fl_idle && tempus > user->next-5)
X		  chk_idle (utmptr);
X
X               if (fl_idle && (user->next < nextcheck) && (user->next > tempus))
X               {
/*                  debug("Shortening this pause to %d seconds due to %s.",user->next-tempus,user->line);*/
X                  nextcheck = user->next;
X               }
X	    }
X	    else
X	    {
#ifdef SYSV
X               user->pid = utmpbuf.ut_pid;
#else SYSV
X    /* HOW TO DO??? */
#endif SYSV
X	       (void) strcpy (pathbuf, DEV);
X	       (void) strcat (pathbuf, utmpbuf.ut_line);
X	       (void) strcpy (user->line, pathbuf);
X	       (void) stat (pathbuf, &statbuf);
X	       (void) strcpy (user->uid, tmpname);
X	       pswd = getpwnam (user->uid);
X               if (pswd == NULL)
X                  logfile ("Error:  could not get info on supposed user %s.",user->uid);
X               else
X                  getgroups_func (pswd->pw_name, user->groups, pswd->pw_gid);
X	       user->time_on = utmpbuf.ut_time;
X	       setlimits (utmptr);
X	       user->next = tempus;
X
X               /* If this is the line for CONSOLE_NAME (ie. "/dev/console")
X                * then set console_user to this person.
X                */
X               if (strcmp(CONSOLE_NAME,user->line) == 0)
X               {
X                  strcpy(console_user,user->uid);
X               }
X
X               /* Ensure that the sleep time is not greater than the smallest
X                * allowed idle time
X                */
X               if (user->idle < sleeptime)
X               {
X                  sleeptime = user->idle;
X                  if ((tempus + sleeptime) < nextcheck)
X                     nextcheck = tempus+sleeptime;
X               }
X	    }
X
X     /* NOTE: user->host is "printed" here, but it is never set.  THIS MIGHT BE NICE!! */
#ifdef DEBUG
X	    logfile
X	       (
X		  "debug: %s %s %s %d %d %s %x %d",
X		  user->uid,
X		  user->line,
X		  user->host,
X		  user->session,
X		  user->idle,
X		  user->refuse == true ? "true" : "false",
X		  user->exempt,
X		  user->warned
X	       );
#endif	/* DEBUG */
X
X	    pusers[userptr++] = user;
X	 }
X         else
X         {
X            /* If this line is the console, and it is not a current user
X             * tty, then make our console_user string empty.
X             */
X            if (strcmp(CONSOLE_NAME,utmpbuf.ut_line) == 0)
X            {
X               strcpy(console_user,"");
X            }
X         }
X
X
X	 utmptr++;
X      }
X
X      (void) close (utmpfd);
X
X      if (fl_refuse)
X	 chk_refuse (userptr);
X
X      if (fl_session)
X	 chk_session (userptr);
X
X      if (fl_multiple)
X	 chk_multiple (userptr);
X
X      (void) time (&tempus);
X      (void) sleep ((unsigned) (nextcheck - tempus));
X   }
}
X
/* If the configuration file has changed, then read in the new settings.
X * If it is gone, then log that fact, and keep going.
X * Returns:  0 == No changes.
X *           1 == Changes.  Set "new" in calling procedure to true.
X */
int update_configuration()
{
X   FILE   *conffd;
X   struct stat statbuf;
X   time_t  tempus;
X
X   (void) time(&tempus);
X
X   if (stat (config_file, &statbuf) == SYSERROR)
X   {
X      logfile ("%19.19s:  Cannot stat conf file.",ctime(&tempus));
X      if (conf_oldstamp == 1)
X      {
X         logfile ("Have never read in conf settings.  Must die.");
X         exit (1);
X      }
X      else
X      {
X         logfile ("Ignoring, and maintaining old settings.");
X         return 0;
X      }
X   }
X
X   if (statbuf.st_mtime > conf_oldstamp)
X   {
X      logfile ("%19.19s   Reading in configuration file.", ctime(&tempus));
X
X      if ((conffd = freopen (config_file, "r", stdin)) == (FILE *) NULL)
X      {
X         logfile ("%19.19s:  Cannot open configuration file.", ctime(&tempus));
X         if (conf_oldstamp == 1)
X         {
X            logfile ("Have never read in conf settings.  Must die.");
X            exit (1);
X         }
X         else
X         {
X            logfile ("Ignoring, and maintaining old settings.");
X            return 0;
X         }
X      }
X
X      /* get rid of the old rules and exempt lists */
X
X      freelist (exmpt);
X      freelist (refuse);
X      freelist (rules);
X      freelist (session);
X      m_threshold = 0;
X      s_threshold = 0;
X
X      conswins_time = -2;          /* default the actions to 'normal' logouts */
X
X      /* now read the conf file and set up the rules */
X
X      (void) yyparse ();
X      (void) fclose (conffd);
X
X      /* Update the stamp time */
X      conf_oldstamp = statbuf.st_mtime;
X
X      return 1;
X   }
X   else
X      return 0;
}
X
/* check for refusal, tell user he is going then zap him */
X
void
chk_refuse(n_users)
register int	n_users;
{
X   register int who;
X
X   for (who = 0; who < n_users; who++)
X      if (!(pusers[who]->exempt & IS_REFU) && pusers[who]->refuse == true)
X	 warn (who, IS_REFU);
}
X
X
/* check session limits, warn users who have exceeded session limits */
X
void
chk_session(n_users)
register int	n_users;
{
X   register int who;
X   time_t  tempus;
X
X   if (s_threshold == 0 || n_users < s_threshold)
X      return;
X
X   (void) time (&tempus);
X
X   for (who = 0; who < n_users; who++)
X      if (!(pusers[who]->exempt & IS_LIMIT) && pusers[who]->session > 0
X         && ( pusers[who]->warned & IS_LIMIT
X         || (tempus - pusers[who]->time_on) > pusers[who]->session))
X	 warn (who, IS_LIMIT);
}
X
X
/* given the number of users, warn any of them that have multiple logins */
X
void
chk_multiple(n_users)
register int	n_users;
{
X   register int i;
X   int     match;
X   int     skip;
X   int     wait = 0;
X
X   if (m_threshold == 0 || n_users < m_threshold)
X      return;
X
X   (void) qsort ((char *) pusers, n_users, sizeof (struct user *), comp);
X
X   for (i = 0; i < n_users - 1; i++)
X   {
X      /*
X       * if not all the multiple logins logged out,
X       * decide on one not to kill, clear his warned
X       * bit, and continue.  But don't look again until
X       * we have passed all the guys with the same login.
X       */
X
X      if (wait == 0)
X      {
X	 match = 0;
X	 skip = decide (i, n_users, &wait);
X      }
X      else
X	 wait--;
X
X      if ((*pusers[i]).exempt & IS_MULT || i == skip)
X	 continue;
X
X      if (!strcmp ((*pusers[i]).uid, (*pusers[i + 1]).uid))
X      {
X	 match = 1;
X	 warn (i, IS_MULT);
X      }
X      else
X      {
X	 if (match)
X	    warn (i, IS_MULT);
X
X	 match = 0;
X      }
X   }
}
X
X
/*
X *	Given a bunch of multiply logged on terminals that did
X * 	not heed the warning, decide returns the index into the 
X *	*pusers array of the user NOT to log off.  Wait is the
X *  	number of ids that chk_multiple must skip before calling
X *	decide again.  Admittedly this is gross, but it works.
X */
X
int
decide(j, num, wait)
register int	j;
register int	num;
int		*wait;
{
X   register int i;
X   int     count = 1;
X   int     warned = 1;
X   int     skip;
X
X   for (i = j; i < num; i++)
X   {
X      if (!((*pusers[i]).warned & IS_MULT))
X	 warned = 0;
X
X      if (((pusers[i]) == NULL) || ((pusers[i + 1]) == NULL))
X	 break;
X      if (!strcmp ((*pusers[i]).uid, (*pusers[i + 1]).uid))
X	 count++;
X      else
X	 break;
X   }
X
X   /* now, if there is a need to skip someone, do it */
X
X   *wait = count - 1;
X
X   if (warned && count > 1)
X   {
X      skip = j;
X
X      /* set skip to the alpha-numerical least tty */
X
X      for (i = j + 1; i < j + count; i++)
X	 if (strcmp ((*pusers[skip]).line, (*pusers[i]).line) > 0)
X	    skip = i;
X
X      (*pusers[skip]).warned &= ~IS_MULT;
X      return skip;
X   }
X
X   return -1;
}
X
X	
/* 
**	Given a user, see if we want to warn him about idle time.
**	First check the exempt vector to see if he is exempt.
**	As a side effect this routine also calculates the next time
**	this user structure should be examined.
*/
X
void
chk_idle(i)
int i;
{
X   struct stat statbuf;
X   int     allowed_time;
X   time_t  tempus;
X
X   if (strcmp(users[i].line,CONSOLE_NAME) == 0)
X   {
X      console_check(i);
X      return;
X   }
X
X   (void) time (&tempus);
X   (void) stat (users[i].line, &statbuf);
X
X   /* Default allowed time for the user is whatever it is.  :-) */
X   allowed_time = users[i].idle;
X
X   /* If this terminal is one owned by the user on console, then
X    * allow them "conswins_time" instead (be it greater or smaller).
X    * If conswins_time == -1, then it is 'off', so don't check this tty.
X    * If it is -2, then ignore the setting, otherwise set it.
X    */
X   if ((strcmp(console_user,users[i].uid) == 0) && (conswins_time == -1))
X   {
/*      debug("not checking user %s",console_user);*/
X      return;
X   }
X   else if ((strcmp(console_user,users[i].uid) == 0) && (conswins_time != -2))
X   {
X      allowed_time = conswins_time;
X   }
X
X   /* 5 seconds leeway here, captain!!! */
X   if (tempus - statbuf.st_atime < allowed_time-5)
X   {
X      users[i].warned &= ~IS_IDLE;
X
X      if (users[i].session > 0)
X         users[i].next = min (statbuf.st_atime + allowed_time,
X                              users[i].time_on + users[i].session);
X      else
X         users[i].next = statbuf.st_atime + allowed_time;
X   }
X   else if (!(users[i].exempt & IS_IDLE))
X   {
X      if (users[i].warned & IS_IDLE)
X      {
X         /* If the user has already been warned, then they should
X          * get zapped this time.  If the zap doesn't work, however,
X          * let's not shorten the sleep time to have it try again.
X          * Leaving the next time to check as less than the current
X          * time means that idled will attempt to zap the person
X          * again whenever it next wakes up (at sleeptime or less).
X          */
X         users[i].next = statbuf.st_atime + allowed_time;
X      }
X      else
X      {
X         /* The user hasn't been warned yet, so allow 'warntime'
X          * seconds to do something to become un-idle
X          */
X         users[i].next = tempus+warntime;
X      }
X
X      warn (i, IS_IDLE);
X   }
X
}
X
unsigned int
idle_time(allowed_console_idle, i)
int allowed_console_idle, i;
{
X
X   struct stat sb;
X   unsigned min_time;
X   time_t  curr_time;
X   time_t  touch_time;
X
X   (void) time(&curr_time);
X
X   stat (KEYBOARD_NAME, &sb);                           /* CRIDER */
X   touch_time = max (sb.st_atime, sb.st_mtime);         /* CRIDER */
X   min_time = curr_time - touch_time;                   /* CRIDER */
X
X   if (min_time >= allowed_console_idle)
X   {
X      stat (MOUSE_NAME, &sb);
X      touch_time = max (sb.st_atime, sb.st_mtime);
X      min_time = min (min_time, (unsigned) (curr_time - touch_time));
X   }
X
X   if (min_time > (curr_time-users[i].time_on))
X   {
X      stat (CONSOLE_NAME, &sb);
X      touch_time = max (sb.st_atime, sb.st_mtime);
X      debug("Not in openwin!  Changing from %d seconds idle to %d.",min_time,curr_time-touch_time);
X      min_time = curr_time - touch_time;
X
X      /* MAKE THIS USER NEVER BE IDLE, since it TOTALLY screws things up if it is */
X      min_time = 0;
X   }
X
X   return min_time;
}
X
void
console_check(i)
int i;
{
#define XLOCK_TIME users[i].idle-5
X   struct stat statbuf;
X   time_t tempus;
X   time_t idle, xlock;
X
X   (void) time(&tempus);
X
X   idle = idle_time(users[i].idle,i);
X   xlock = xlock_check(users[i].uid);
X   if (xlock > 0)
X      debug ("There is an xlock running.  Has been running for %d seconds.",xlock);
X   /* 5 seconds leeway (in case we are a couple of seconds too early */
X   if ((idle >= users[i].idle-5) || (xlock >= XLOCK_TIME))
X   {
X      if ((xlock >= XLOCK_TIME) && !(users[i].exempt & IS_IDLE))
X      {
X         users[i].warned &= IS_XLOCK;
X         warn (i, IS_XLOCK);
X      }
X      else if (!(users[i].exempt & IS_IDLE))
X      {
X         debug ("Console user has been warned.");
X         if (users[i].warned & IS_IDLE)
X         {
X            /* If the user has already been warned, then they should
X             * get zapped this time.  If the zap doesn't work, however,
X             * let's not shorten the sleep time to have it try again.
X             * Leaving the next time to check as less than the current
X             * time means that idled will attempt to zap the person
X             * again whenever it next wakes up (at sleeptime or less).
X             */
X            users[i].next = max(idle,xlock) + users[i].idle;
X         }
X         else
X         {
X            /* The user on console hasn't been warned yet, so allow
X             * 'warntime' seconds to do something to become un-idle
X             */
X            users[i].next = tempus+warntime;
X         }
X
X         warn (i, IS_IDLE);
X      }
X   }
X   else
X   {
X      users[i].warned &= ~IS_IDLE;
X
X      if (users[i].session > 0)
X         users[i].next = min (tempus-max(idle,xlock) + users[i].idle,
X                              users[i].time_on + users[i].session);
X      else
X         users[i].next = tempus-max(idle,xlock) + users[i].idle;
X   }
X   
}
X
/* get all the groups a user belongs to */
X
void
getgroups_func(pw_name, groups, pw_group)
char	*pw_name;
int	groups[];
int	pw_group;
{
X   register int i;
X   register int ngroups = 0;
X   register struct group *grp;
X
X   if (pw_group >= 0)
X      groups[ngroups++] = pw_group;
X
X   setgrent ();
X
X   while (grp = getgrent ())
X   {
X      if (grp->gr_gid == pw_group)
X	 continue;
X
X      for (i = 0; grp->gr_mem[i]; i++)
X	 if (!strcmp (grp->gr_mem[i], pw_name))
X	 {
X	    groups[ngroups++] = grp->gr_gid;
X	    break;
X	 }
X
X      if (ngroups == NGROUPS)
X	 break;
X   }
X
X   if (ngroups < NGROUPS)
X      groups[ngroups] = -1;
X
X   endgrent ();
}
X
X
/* comp -- used by qsort to sort by id */
X
int
comp(h1, h2)
struct	user	**h1;
struct	user	**h2;
{
X   return (strcmp ((**h1).uid, (**h2).uid));
}
X
X
/* process a log message */
X
/* VARARGS */
void
logfile(s, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
char	*s;
char	*a1;
char	*a2;
char	*a3;
char	*a4;
char	*a5;
char	*a6;
char	*a7;
char	*a8;
char	*a9;
char	*a10;
{
X   register FILE *logfd;
X
X   if ((logfd = fopen (LOGFILE, "a")) == (FILE *) NULL)
X      return;
X
X   (void) fprintf (logfd, s, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
X   (void) putc ('\n', logfd);
X   (void) fclose (logfd);
}
X
X
/* finish Idled */
X
void
finish()
{
X   time_t  tempus;
X
X   (void) signal (SIGTERM, SIG_IGN);
X   tempus = time ((long *) NULL);
X   logfile ("%24.24s  Idled killed.", ctime (&tempus));
X   exit (1);
}
X
void
daemonize()
{
X   int     nfds, fd, i;
X   struct rlimit rl;
X
X   switch (fork ())
X    {
X    case SYSERROR:
X       logfile ("Cannot fork.");
X       (void) fprintf (stderr, "idled: Cannot fork\n");
X       exit (1);
X
X    case 0:
X       break;
X
X    default:
X       exit (0);
X    }
X
#ifdef RLIMIT_NOFILE
X   if (getrlimit (RLIMIT_NOFILE, &rl) < 0)
X      logfile ("Error calling system function: getrlimit");
X   nfds = rl.rlim_max;
#else /* RLIMIT_NOFILE */
X   nfds = getdtablesize ();
#endif /* RLIMIT_NOFILE */
X
X   /* Close all fds. */
X   for (fd = 0; fd < nfds; ++fd)
X   {
X      (void) close (fd);
X   }
X
#if HAVE_SETSID
X   (void) setsid ();
#endif
}
SHAR_EOF
  $shar_touch -am 1129154694 'idled-1.00/idled.c' &&
  chmod 0644 'idled-1.00/idled.c' ||
  echo 'restore of idled-1.00/idled.c failed'
  shar_count="`wc -c < 'idled-1.00/idled.c'`"
  test 21551 -eq "$shar_count" ||
    echo "idled-1.00/idled.c: original size 21551, current size $shar_count"
fi
# ============= idled-1.00/idled.8 ==============
if test -f 'idled-1.00/idled.8' && test X"$1" != X"-c"; then
  echo 'x - skipping idled-1.00/idled.8 (File already exists)'
else
  echo 'x - extracting idled-1.00/idled.8 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'idled-1.00/idled.8' &&
X.TH IDLED 8 LOCAL
X.SH NAME
idled \- Idle terminal and multiple login monitor daemon.
X.SH SYNOPSIS
X.B idled
[-f
X.B config_file
]
X.SH DESCRIPTION
X.PP
X.I Idled
wakes up at regular intervals and scans /etc/utmp to see
which users are currently logged in, how long they have been idle,
whether they are logged in more than once, etc.
X.I Idled
then warns and logs out users based on a set of rules in its
configuration file.
X.I Idled
is usually started from /etc/rc.local.
X.PP
X.I Idled
uses a configuration file,
X.IR idled.cf ,
to find out how long a terminal must be unused to be considered
\*(lqidle\*(rq, and which users, groups, terminals, or clusters of
terminals are exempt from being logged out.
X.PP
The path of the configuration file, which is compiled in, can be overriden
by using the flag
X.B -f
followed by the name of the configuration file to use (and path,
if necessary).
X.PP
X.I Idled
was written from a program called
X.I Untamo,
which gets its name from the Finnish god of sleep and dreams.
X.SH FILES
X.TP
X.B /usr/contrib/lib/idled.cf
Configuration file which specifies how often idled is to wake up, and
exemptions to rules, etc.
There is no need to restart idled to change the configuration. 
If changes are made to this file, idled will re-read the configuration
rules.
X.TP
X.B /var/log/idled.log
Log of when idled is started, killed, who it logs off and why, and any
errors it encounters.
X.SH AVAILABILITY
X.PP
The newest version of idled is available via anonymous ftp to
ftp.cs.hope.edu in /pub
X.PP
All comments and suggestions for idled would be greatly appreciated
and should be sent to crider@cs.hope.edu
X.SH DIAGNOSTICS
Various \*(lqcouldn't open ...\*(rq error messages.  Since idled
dissacociates itself from the invoking terminal, most of the errors
get put in the log file.
X.SH SEE ALSO
idled.cf(5), utmp(5)
X.SH BUGS
If a user logs off and then on again fast enough and manages to get a
different tty, he may be warned about a multiple login.
X.PP
It currently will not log off the person on console if that person
is not in X-Windows, since things get really screwy then (due to
some wierdness in the system blocking reading of the utmp file
until a person hits <return> on the console's keyboard--and that is
one <return> for each utmp line!).
SHAR_EOF
  $shar_touch -am 1130102594 'idled-1.00/idled.8' &&
  chmod 0644 'idled-1.00/idled.8' ||
  echo 'restore of idled-1.00/idled.8 failed'
  shar_count="`wc -c < 'idled-1.00/idled.8'`"
  test 2265 -eq "$shar_count" ||
    echo "idled-1.00/idled.8: original size 2265, current size $shar_count"
fi
# ============= idled-1.00/idled.cf ==============
if test -f 'idled-1.00/idled.cf' && test X"$1" != X"-c"; then
  echo 'x - skipping idled-1.00/idled.cf (File already exists)'
else
  echo 'x - extracting idled-1.00/idled.cf (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'idled-1.00/idled.cf' &&
#
# HOW LONG TO SLEEP BETWEEN CHECKS (in seconds):
#
X	sleep 120
#
# NUMBER OF SECONDS TO ALLOW FOR IDLE WARNING BEFORE LOGOUT:
#
X	warn 300
#
# NUMBER OF MINUTES TO ALLOW FOR IDLE TIME FOR TERMINALS
# OWNED BY THE PERSON CURRENTLY LOGGED IN ON CONSOLE:
#
# If this is not set at all, or is set to 'normal', the normal
# idle logouts will be in effect.  If set to OFF, then idle
# logouts will be disabled for these terminals
#
X        conswins off
#
# THRESHOLDS FOR MULTIPLE LOGINS AND SESSIONS:
#
# 64 users must be logged on before multiple login checks
# NOTE:  I haven't tested this part much, yet.
X	threshold multiple 64
# 10 sessions amongst all users must be active before idled
# will be active for session limits
X	threshold session 10
#
# TIMEOUT RULES:
#
# Set the console idle timeout to 15 minutes before warning
# the user and killing the main login shell 'warn' time
# seconds later if no action is performed by the user.
# (Killing the login shell has everything else cascade
# afterwards).
# Default idle timeout = 60 minutes for normal users.
# Default idle timeout = 120 minutes for group staff
#
X      timeout tty console 15
X      timeout default 600
X      timeout group staff 120
X      timeout login crider 60
#
# REFUSALS:
#
# Immediately kill any logins by user 'stupid'
#      refuse login stupid
#
#
# SESSION LIMITS:
#
# Students must not remain logged in for longer than 120 minutes
#
#   session group student 120
#
#
# EXEMPTIONS:
#
X        exempt tty console session
X	exempt group staff all
X	exempt group sys multiple
#	exempt login crider all
SHAR_EOF
  $shar_touch -am 1129174894 'idled-1.00/idled.cf' &&
  chmod 0644 'idled-1.00/idled.cf' ||
  echo 'restore of idled-1.00/idled.cf failed'
  shar_count="`wc -c < 'idled-1.00/idled.cf'`"
  test 1573 -eq "$shar_count" ||
    echo "idled-1.00/idled.cf: original size 1573, current size $shar_count"
fi
# ============= idled-1.00/idled.cf.5 ==============
if test -f 'idled-1.00/idled.cf.5' && test X"$1" != X"-c"; then
  echo 'x - skipping idled-1.00/idled.cf.5 (File already exists)'
else
  echo 'x - extracting idled-1.00/idled.cf.5 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'idled-1.00/idled.cf.5' &&
X.TH IDLED.CF 5 LOCAL
X.SH NAME
/usr/contrib/lib/idled.cf \- idled configuration file format
X.SH DESCRIPTION
X.IR Idled,
the login monitor daemon, decides how it should act based on the file
idled.cf.
This file consists of a series of specifications which each
describe an aspect of idled's actions.  There are eight types of commands: 
X.IP 1.
X.B Exemption  
commands
specify people that are exempt from idled's actions.
X.IP 2.
X.B Session
commands specify people who are restricted in the length of time
they may remain logged in.
X.IP 3.
X.B Refuse
commands specify people to immediately log off when they are found.
X.IP 4.
X.B Sleep
sets the number of minutes idled should sleep between checks. 
X.IP 5.
X.B Wait
sets the number of seconds idled should give to an idle tty after it
warns before it logs it out.
X.IP 6.
X.B Conswins
specifies whether or not tty's owned by the user logged in on console
should be exempt from idle logouts, or how long those tty's should get.
X.IP 7.
X.B Timeout
defines how long a terminal must be idle before it is logged out.
X.IP 8.
X.B Threshold
sets the threshold number of users who must be logged in before multiple
login or session login control takes effect.
X.PP
Lines beginning with a hash in column one are comments.
Other lines may be indented for readability.
X.SH Exemptions
X.PP
Exemptions have the form:
X.IP
X.B exempt
X.I who
X.I from
X.PP
where
X.I who
must be one of:
X.IP
X.B login
X.I username
X.IP
X.B group
X.I groupname
X.IP
X.B tty
X.I ttyname
X.PP
where
X.I Username
must be a valid login name as in /etc/passwd.
X.I Groupname
must be a valid group name as in /etc/group.
X.I Ttyname
is a terminal name as in /etc/utmp (e.g., \*(lqtty\fIXX\fP\*(rq).
X.PP
and
X.I from 
must be one of:
X.IP
X.B multiple
X.IP
X.B idle
X.IP
X.B session
X.IP
X.B all
X.PP
which specify that
X.I who
is exempt from being logged off for maintaining multiple logins,
remaining idle longer than the idle timeout period, exceeding a login
session limit, or all three.
X.SH Session
X.PP
Session commands take the form:
X.IP
X.B session
X.I who
X.I minutes
X.PP
where
X.I who
is the same as above and
X.I minutes
is a decimal number.
The command indicates the length of time a user may be logged in for
before they must terminate their
X.IR session . 
Warnings and logouts will be issued if the
X.I session
limit is exceeded.
X.SH Refuse
X.PP
Refuse commands take the form:
X.IP
X.B refuse
X.I who
X.PP
where
X.I who
is the same as above. 
X.I minutes
As soon as idled spots a user matching a refuse statement, it will
tell the user that the session will be terminated, and will actually
do so approximately 5 seconds later.
X.SH Sleep
X.PP
Sleep commands are of the form:
X.IP
X.B sleep
X.I seconds
X.PP
and specify that idled will sleep 
X.I seconds
seconds between its checks.
If there is more than one sleep specification, only the last one is used.
X.SH Warn
X.PP
Warn commands are of the form:
X.IP
X.B warn
X.I seconds
X.PP
and specify that idled will sleep 
X.I seconds
seconds between warnings and logouts.
If there is more than one warn specification, only the last one is used.
X.SH Console Windows Idled time
X.PP
The allowed idled time for tty's owned by the user logged in
on console can be specified with the
X.B conswins
command.  This command can be in one of the following forms:
X.IP
X.B conswins
X.I minutes
X.IP
X.B conswins normal
X.IP
X.B conswins off
X.PP
Minutes specifies the number of minutes allowed for these tty's and
X.I will overide
what the 
X.B timeout
setting for the user would otherwise be.
X.I normal
specifies to use the default timeout for that user (specified with
the
X.B timeout
command).
X.I off
instructs
X.B idled
to not log off any such tty's, depite how long they have been idle.
X.SH Timeout 
X.PP
Timeouts are of the form:
X.IP
X.B timeout
X.I who
X.I minutes
X.PP
where
X.I who
is the same as above, but can also be
X.I default
and 
X.I minutes 
is a decimal number.
This command indicates that
X.I who
will be logged off after remaining idle for
X.I minutes
minutes.  The default idle timeout affects
anyone not otherwise exempted from timeouts or mentioned
in an explicit timeout rule.
X.SH Thresholds
X.PP
Threshold commands are of the form:
X.IP
X.B threshold 
X.I type
X.I number 
X.PP
where
X.I type
must be on of:
X.IP
X.I multiple
X.IP
X.I session
X.PP
This specifies that at least 
X.I number
ttys must be active before idled will check for the terminal usage
X.IR type .
If the number of users is equal to or exceeds the
threshold, then warnings and logouts for
X.I multiple
logins or be the case
X.I sessions
will be issued.
If a
X.I threshold
is not set the no checking will be done.
X.SH EXAMPLE
X.PP
A sample idled configuration file follows:
X.br
X.nf
X
X   #
X   # sleep 2 minutes between checks (specified in seconds)
X   #
X       sleep 120
X   #
X   # Give 5 minutes between warning and logout (in seconds)
X   #
X       warn 300
X   #
X   # Set conswins to off, so that idle logouts will be disabled
X   # for tty's owned by the user logged in on console.
X   #
X       conswins off
X   #
X   # 30 users must be logged on before
X   # multiple login checks will begin
X   #
X       threshold multiple 30
X   #
X   # We want session limits to apply all the time, you know
X   # RSI and all that sort of thing.
X   #
X       threshold session 1
X   #
X   # Set the default idle timeout to 5 minutes.  For the
X   # group staff, set the idle timeout to 15 minutes.
X   #
X       timeout default 5
X       timeout group staff 15
X   #
X   # Students must not remain logged in for longer than 45 minutes
X   #
X       session group stud 45
X   #
X   # Necessary exemptions to make sure the console doesn't
X   # get logged off for session limits or multiple logins and
X   # staff members don't get logged off at all.
X   #
X       exempt tty console session
X       exempt tty console multiple
X       exempt group staff all
X
X.fi
X.SH SEE ALSO
idled(8), utmp(5)
SHAR_EOF
  $shar_touch -am 1129165494 'idled-1.00/idled.cf.5' &&
  chmod 0644 'idled-1.00/idled.cf.5' ||
  echo 'restore of idled-1.00/idled.cf.5 failed'
  shar_count="`wc -c < 'idled-1.00/idled.cf.5'`"
  test 5789 -eq "$shar_count" ||
    echo "idled-1.00/idled.cf.5: original size 5789, current size $shar_count"
fi
# ============= idled-1.00/idled.h ==============
if test -f 'idled-1.00/idled.h' && test X"$1" != X"-c"; then
  echo 'x - skipping idled-1.00/idled.h (File already exists)'
else
  echo 'x - extracting idled-1.00/idled.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'idled-1.00/idled.h' &&
#include <sys/types.h>
#include <stdio.h>
#include <setjmp.h>
#include <sys/param.h>
X
#define	SYSERROR	(-1)
X
#define UTMP 		"/etc/utmp"	/* name of utmp file */
X
#ifdef DEBUG
#define CONFIG          "./idled.cf"
#define LOGFILE         "./idled.log"
#else DEBUG
#define CONFIG		"/usr/contrib/lib/idled.cf"
#define LOGFILE		"/var/log/idled.log"
#endif DEBUG
X
#define DEV		"/dev/\0"
X
/* Name of the console device */
#define CONSOLE_NAME    "/dev/console"
X
/* If you have setsid(), then define this
X * to allow total daemonizing of idled
X */
#define HAVE_SETSID 1
X
/* If you are running Solaris 2.x, define HAVE_PROC_FS
X * It is used for checking to see if xlock is running.
X */
#define HAVE_PROC_FS 1
X
X
/* Keyboard and Mouse Devices to Check in Place of Console */
#define KEYBOARD_NAME   "/dev/kbd"
#define MOUSE_NAME      "/dev/mouse"
X
/* Name of the X console locking program */
#define XLOCK_NAME      "xlock"
X
#define MAXUSERS	100		/* max people expected */
#define NAMELEN		8		/* length of login name */
#define NGROUPS         10              /* ?????? HELP ?????? */
#define IS_IDLE		0x1
#define IS_MULT		0x2
#define IS_LIMIT	0x4
#define	IS_REFU		0x8
#define IS_XLOCK	0x16
X
typedef	enum	{ false = 0, true = 1 }	bool;
X
struct user
{
X	int	idle;		  /* max idle limit for this user */
X	int	groups[NGROUPS];  /* gids from passwd and group files */
X	bool	refuse;		  /* true is user should be refused access */
X	int	session;	  /* session limit for this user */
X	int	warned;		  /* if he has been warned before */
X	int	exempt;		  /* what is this guy exempt from? */
X	time_t	next;		  /* next time to examine this structure */
X	time_t	time_on;	  /* loggin time */
X	char	uid[NAMELEN + 1]; /* who is this is? */
X	char	line[14];	  /* his tty in the form "/dev/ttyxx"*/
X	char	host[16];	  /* the host this user is connecting from */
X        int     pid;              /* the process number of this login */
};
X
/* 
** next will be cur_time+limit-idle do all we have to do is check
** the current time against the action field when the daemon comes
** around.  if >= then it's time to check the idle time again, else
** just skip him.
*/
X
extern	struct	user	users[];
extern	struct	user	*pusers[];
X
/* records that the nodes of the linked list will have pointers too */
X
struct item
{
X	int	name_t;		/* is it a login, group, etc... */
X	char	*name;		/* which login, etc */
X	int	num;		/* group */
X	int	flag;		/* what is the timeout/exemption ? */
};
X
/* necessary structures to use the system linked list stuff */
X
struct qelem
{
X	struct	qelem	*q_forw;
X	struct	qelem	*q_back;
X	struct	item	*q_item;
};
X
/* These items are gleaned from the configuration file...	*/
X
extern	struct	qelem	*rules; 	/* list of idle timeout rules	*/
extern	struct	qelem	*exmpt; 	/* list of exemptions		*/
extern	struct	qelem	*refuse;	/* list of refuse rules		*/
extern	struct	qelem	*session;	/* list of session limit rules  */
X
extern	int	sleeptime;	/* max time to sleep between scans of utmp */
extern	int	warntime;	/* how long to allow for warnings */
extern	int	conswins_time;	/* max idle time for wins of console user */
extern	int	m_threshold;	/* multiple login warning threshold */
extern	int	s_threshold;	/* session limit warning threshold */
extern	int	warn_flags;	/* what warnings to make */
X
extern	void	logfile();
SHAR_EOF
  $shar_touch -am 1118225794 'idled-1.00/idled.h' &&
  chmod 0644 'idled-1.00/idled.h' ||
  echo 'restore of idled-1.00/idled.h failed'
  shar_count="`wc -c < 'idled-1.00/idled.h'`"
  test 3285 -eq "$shar_count" ||
    echo "idled-1.00/idled.h: original size 3285, current size $shar_count"
fi
# ============= idled-1.00/insque.c ==============
if test -f 'idled-1.00/insque.c' && test X"$1" != X"-c"; then
  echo 'x - skipping idled-1.00/insque.c (File already exists)'
else
  echo 'x - extracting idled-1.00/insque.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'idled-1.00/insque.c' &&
/*
**	Queue insertion and deletion routines for non-Vaxen
*/
X
X
struct	qelem
{ 
X	struct	qelem	*q_forw;
X	struct	qelem	*q_back;
#ifdef LINT
X	char q_data[];
#endif LINT
};
X
X
#ifndef VAX
X
int
insque(elem , pred)
register struct	qelem	*elem;
struct	 qelem		*pred;
{
X	register struct	qelem	*pred_ptr = pred;
X
X	elem->q_forw = pred_ptr->q_forw;
X	pred_ptr->q_forw = elem;
X	elem->q_forw->q_back = elem;
X	elem->q_back = pred_ptr;
}
X
#endif VAX
SHAR_EOF
  $shar_touch -am 0911215491 'idled-1.00/insque.c' &&
  chmod 0644 'idled-1.00/insque.c' ||
  echo 'restore of idled-1.00/insque.c failed'
  shar_count="`wc -c < 'idled-1.00/insque.c'`"
  test 432 -eq "$shar_count" ||
    echo "idled-1.00/insque.c: original size 432, current size $shar_count"
fi
# ============= idled-1.00/list.c ==============
if test -f 'idled-1.00/list.c' && test X"$1" != X"-c"; then
  echo 'x - skipping idled-1.00/list.c (File already exists)'
else
  echo 'x - extracting idled-1.00/list.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'idled-1.00/list.c' &&
/*
**	List manipulation routines
*/
X
#include <sys/file.h>
#include "idled.h"
#include "y.tab.h"
X
int	find();
X
extern	char	*ctime(),
X		*malloc(),
X		*strcpy();
X
extern	int	strlen();
extern	time_t	time();
X
/*
**	adds a record to the list "list".
**      list -- which list to add the rule
**      type -- what kind of rule (LOGIN, GROUP, etc)
**      name -- who it applies to (ajw, console, etc)
**      num  -- who it applies to (5 (group staff) )
**      flag -- idle time for a "rule" rule, or exemption type
**	        for "exempt" rule: IDLE, MULTIPLE, etc.
*/
X
void
addlist(list, type, name, num, flag)
struct	qelem	*list;
int		type;
char		*name;
int		num;
int		flag;
{
X	register struct	item	*new_data;
X	register struct	qelem	*new_node;
X	register struct	qelem	*ptr;
X
X	/* make all the new structures */
X
X	new_node = (struct qelem *) malloc(sizeof(struct qelem));
X	new_data = (struct item  *) malloc(sizeof(struct item ));
X	new_data->name_t = type;
X	new_data->name = name;
X	new_data->num = num;
X	new_data->flag = flag;
X	new_node->q_item = new_data; 
X
X	/* find where to insert it in the list, and insert it */
X
X	for ( ptr = list->q_forw; ptr != list; ptr = ptr->q_forw )
X		if ( ptr->q_item->name_t <= new_data->name_t )
X			break;
X
X	(void)insque(new_node, ptr->q_back);
}
X
X
/* frees up the space in the list pointed to by ptr */
X
void
freelist(ptr)
struct	qelem	*ptr;
{
X	register struct	qelem	*dead;
X	register struct qelem	*elemp;
X	register struct	qelem	*start = ptr;
X
X	for ( elemp = start->q_forw; elemp != start; )
X	{
X		dead = elemp;
X		elemp = elemp->q_forw;
X		(void)free( (char *) dead->q_item);  	/* kill the data */
X		(void)free( (char *) dead );		/* now get the node */
X	}
X
X	start->q_forw = start;		/* reset pointers for a null list */
X	start->q_back = start;
}
X
X
/*
**	looks through the rules list and uses the most
**	specific rule for users[i], then looks through
**	all the exemptions setting them as they apply.
*/
X
void
setlimits(i)
register int	i;
{
X	register int		rule;
X	register struct	qelem	*ptr;
X	time_t			tempus;
X
X	(void)time(&tempus);
X	users[i].exempt = 0;		/* clear exemption flag */
X	users[i].idle = 0;		/* clear his idle length */
X	users[i].refuse = false;	/* clear refuse flag */
X	users[i].session = 0;		/* clear his session length */
X	users[i].warned = 0;		/* clear his warning flag */
X
X	/* next time is set to now, so the new rules take affect immediately */
X
X	users[i].next = tempus;		
X
X	for ( rule = 0, ptr = rules->q_back; ptr != rules && !rule; ptr = ptr->q_back )
X		if ( rule = find(ptr, i) ) 
X			users[i].idle = (ptr->q_item)->flag * 60;
X
X	for ( rule = 0, ptr = refuse->q_back; ptr != refuse && !rule; ptr = ptr->q_back )
X		if ( rule = find(ptr, i) ) 
X			users[i].refuse = true;
X
X	for ( rule = 0, ptr = session->q_back; ptr != session && !rule; ptr = ptr->q_back )
X		if ( rule = find(ptr, i) )
X			users[i].session = (ptr->q_item)->flag * 60;
X
X	for ( ptr = exmpt->q_forw; ptr != exmpt; ptr = ptr->q_forw )
X		if ( find(ptr, i) )
X			switch ( (ptr->q_item)->flag )
X			{
X			case ALL:
X				users[i].exempt = IS_IDLE|IS_MULT|IS_LIMIT|IS_REFU;
X				break;
X
X			case IDLE:
X				users[i].exempt |= IS_IDLE;
X				break;
X
X			case MULTIPLE:
X				users[i].exempt |= IS_MULT;
X				break;
X
X			case REFUSE:
X				users[i].exempt |= IS_REFU;
X				break;
X
X			case SESSION:
X				users[i].exempt |= IS_LIMIT;
X				break;
X			}
}
X
X
/* given a rule and a users structure, see if it applies */
X
int
find(ptr,i)
register struct	qelem	*ptr;
register int		i;
{
X	register int	j;
X
X	switch ( (ptr->q_item)->name_t )
X	{
X	case DEFAULT:
X		return(1);
X
X	case GROUP:
X		for ( j = 0; j < NGROUPS && users[i].groups[j] >= 0; j++ )
X			if ( (ptr->q_item)->num == users[i].groups[j] ) 
X				return(1);
X
X		break;
X
X	case LOGIN: 
X		if ( !strcmp((ptr->q_item)->name, users[i].uid) )
X			return(1);
X
X		break;
X
X	case TTY:
X		if ( !strcmp((ptr->q_item)->name, users[i].line+5) ) 
X			return(1);
X
X		break;
X	}
X
X	return(0);
}
SHAR_EOF
  $shar_touch -am 0928154194 'idled-1.00/list.c' &&
  chmod 0644 'idled-1.00/list.c' ||
  echo 'restore of idled-1.00/list.c failed'
  shar_count="`wc -c < 'idled-1.00/list.c'`"
  test 3889 -eq "$shar_count" ||
    echo "idled-1.00/list.c: original size 3889, current size $shar_count"
fi
exit 0
