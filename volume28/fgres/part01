Newsgroups: comp.sources.unix
From: stumvoll@pool.informatik.rwth-aachen.de (Wolfgang Stumvoll)
Subject: v28i036: fgres - search and replace character patterns, Part01/01
Message-id: <1.769203013.20709@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: stumvoll@pool.informatik.rwth-aachen.de (Wolfgang Stumvoll)
Posting-Number: Volume 28, Issue 36
Archive-Name: fgres/part01

	fgres 1.5
	fgres string replace utility for binary and text files/pipes
	Copyright (c) 1994, W. Stumvoll, Germany

fgres' ( Fast GREp and Substitute ) primary function is to substitute or delete
character patterns. It can operate on binary and text files or in a pipe.

It is ideally suited for  quick  and  dirty  replacements  in  multiple  files.
Especially for this  purpose, fgres supports in situ replacements, which do not
need any temporary files.

For example:
   If you want to replace all variables `foo' by `foobar' in all  your  program
   sources, a mere:

      fgres foo foobar *.[ch]

   will do.

The more demanding user can create fgres command files. They  can  contain  any
number of substitution patterns which will  be  simultaneously searched for and
can be collected in named groups.  These  groups can be used to generate finite
automatons.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  fgres fgres/MANPAGE fgres/Makefile fgres/README
#   fgres/file_io.c fgres/gen_man.fgres fgres/global.h fgres/main.c
#   fgres/messages.c fgres/patchlevel.h fgres/program.c
# Wrapped by bytewurm@maroren on Tue May 17 11:12:28 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test ! -d 'fgres' ; then
    echo shar: Creating directory \"'fgres'\"
    mkdir 'fgres'
fi
if test -f 'fgres/MANPAGE' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fgres/MANPAGE'\"
else
echo shar: Extracting \"'fgres/MANPAGE'\" \(15926 characters\)
sed "s/^X//" >'fgres/MANPAGE' <<'END_OF_FILE'
X.\' t
X.TH FGRES 1 "February 16, 1994"
X.\"{{{}}}
X.\"{{{  Name
X.SH NAME
Xfgres \- search and replace character patterns (v"VERSION") 
X.\"}}}
X.\"{{{  comment
X.SH ATTENTION
XThe \fB"\fP\fISTRING\fP\fB"\fP patterns in this manual page will be
Xreplaced by \fBfgres\fP with the constants, used in the sources, so the
Xmanual are up-to-date for used characters and constants.  This text will
Xalso be removed.  The filtered file can be generated with
X.IP 
X\fBmake manual\fP
X.\"}}}
X.\"{{{  Synopsis
X.SH SYNOPSIS
X.ad l
X\fBfgres\fP \fI<options>\fP \fIsearch\fP [\fIreplace\fP [\fIfile\fP .\|.\|.\|]]
X.br
X\fBfgres\fP \fI<options>\fP [\fB\-"OPT_IN"\fP \fIin\fP] [\fB\-"OPT_OUT"\fP \fIout\fP] \fIsearch\fP [\fIreplace\fP]
X.br
X\fBfgres\fP \fI<options>\fP \fI<program>\fP [\fIfile\fP .\|.\|.\|]
X.br
X\fBfgres\fP \fI<options>\fP \fI<program>\fP [\fB\-"OPT_IN"\fP \fIin\fP] [\fB\-"OPT_OUT"\fP \fIout\fP]
X.br
X.br
Xwhere:
X.br
X  \fI<options>\fP=[\fB\-"OPT_BIN""OPT_GROW""OPT_HELP""OPT_CASE""OPT_PAD""OPT_SHRINK""OPT_VERB"\fP] [\fB"OPT_BLOCKS"\fP \fInumber\fP] [\fB\-"OPT_SEP"\fP \fIdelimiter\fP]
X  \fI<program>\fP=(\fB\-"OPT_CMDF"\fP \fIcommand-file\fP | \fB\-"OPT_CMD"\fP \fIcommand\fP) .\|.\|.
X.ad b
X.\"}}}
X.\"{{{  Description
X.SH DESCRIPTION
X.\"{{{  general description
X.SS "General Description"
X\fBfgres\fP (\fBF\fPast \fBGRE\fPp and \fBS\fPubstitute) primary
Xfunction is to substitute or delete character patterns.  It can operate
Xon binary and text files or in a pipe.
X.PP
XThe command language consists of very straightforward substitution
Xpatterns.  These commands can be collected in named groups, which can be
Xdynamically enabled and disabled.
X.PP
XIn addition to the \fBfgres\fP command language, you can also use simple 
Xcommand line arguments for search and replace patterns.
X.\"}}}
X.\"{{{  command line
X.SS "Search and Replace Patterns on Command Line"
XThis can be used in the follwoing two ways:
X.TP
X\fBfgres\fP \fI<options>\fP \fIsearch\fP \fIreplace\fP \fIfile\fP .\|.\|.\|
XReplace \fIsearch\fP with \fIreplace\fP (default: empty word) in all
Xfiles \fIfile\fP .\|.\|.  .  The replacement is done in the files,
Xwithout copying them.
X.TP
X\fBfgres\fP \fI<options>\fP [\fB\-"OPT_IN"\fP \fIin\fP] [\fB\-"OPT_OUT"\fP \fIout\fP] \fIsearch\fP [\fIreplace\fP]
XReplace \fIsearch\fP with \fIreplace\fP (default: empty word).  Read all
Xfiles given with \fB\-"OPT_IN"\fP \fIin\fP (default: standard input) and
Xwrite to the file, given with \fB\-"OPT_OUT"\fP \fIout\fP (default:
Xstandard output).
X.PP
X\fIsearch\fP and \fIreplace\fP are taken literally. 
X.\"}}}
X.\"{{{  program
X.SS "Program with \-"OPT_CMD" or \-"OPT_CMDF":"
XThis can be used in the following two ways:
X.TP
X\fBfgres\fP \fI<options>\fP \fI<program>\fP \fIfile\fP .\|.\|.\|
XExecute the command given in \fI<program>\fP and the corresponding 
Xactions in all files \fIfile\fP .\|.\|. .
XThe replacement is done in the files, without copying them.
X.TP
X\fBfgres\fP \fI<options>\fP \fI<program>\fP [\fB\-"OPT_IN"\fP \fIin\fP] [\fB\-"OPT_OUT"\fP \fIout\fP]
XExecute the command given in \fI<program>\fP and the corresponding
Xactions.  Read all files given with \fB\-"OPT_IN"\fP \fIin\fP (default:
Xstandard input) and write to the file, given with \fB\-"OPT_OUT"\fP
X\fIout\fP (default: standard output).
X.PP
XThe basic elements of the \fBfgres\fP program \fI<program>\fP are
Xsearch-and-replace commands.  While these commands can be grouped and
Xthose groups can be switched on and off, you can build up a kind of a
X\fBfinite state machine\fP.  In detail, a \fBfgres\fP program is a
Xsequence of the following statements (field separator is set to the
Xdefault \fB"DFLT_SEPARATOR"\fP):
X.\"{{{  fgres comments
X.IP "\fB"QUOTE_CHAR""CMD_ADRESS""CMD_ADRESS"\fP this is a comment"
XNo comment :-)
X.\"}}}
X.\"{{{  pattern
X.IP "\fIsearch\fP [\fIreplace\fP [ (\fB"CMD_START"\fP|\fB"CMD_STOP"\fP)\fIswitch\fP .\|.\|.\|]]"
XReplace the \fIsearch\fP string with \fIreplace\fP and execute the optional
Xswitches. A switch turns on/off the corresponding named group of commands.
XIf switches have to be used with the empty replace string, use
X\fB"QUOTE_CHAR""CMD_ADRESS"\fP for \fIreplace\fP.
X.\"}}}
X.\"{{{  address
X.IP "\fB"QUOTE_CHAR""CMD_ADRESS"\fP\fIstart\fP[\fB"CMD_REGION_LEN"\fP\fIlen\fP] [\fIreplace\fP [ (\fB"CMD_START"\fP|\fB"CMD_STOP"\fP)\fIswitch\fP .\|.\|.\|]]"
XReplace the \fIlen\fP characters, starting at byte number \fIstart\fP
X("START_COUNT" is the first), with \fIreplace\fP and execute the optional
Xswitches.  \fIlen\fP defaults to zero.  \fIstart\fP and \fIlen\fP can be
Xdecimal, octal (starting with 0) or hex (starting with 0x).  If switches have
Xto be used with the empty replace string, use
X\fB"QUOTE_CHAR""CMD_ADRESS"\fP for \fIreplace\fP.
X.\"}}}
X.\"{{{  group
X.PP
X\fB"QUOTE_CHAR""CMD_ADRESS"\fP \fIname\fP
X.br
X   \fIcommand-1\fP
X.br
X    :
X   \fIcommand-n\fP
X.br
X.br
X\fB"QUOTE_CHAR""CMD_ADRESS"\fP
X.IP
XAll \fIcommand\fPs belong to the group \fIname\fP.  They are controlled by
Xcorresponding (\fB"CMD_START"\fP|\fB"CMD_STOP"\fP)\fIname\fP switches.
XNamed groups are switched off at startup.  Nested groups are not allowed.
X.RS
X.PP
XThere are three reserved group names:
X.\"{{{  "DFLT_GROUP"
X.IP \fB"DFLT_GROUP"\fP
XThis group contains all commands, which are declared outside of groups.
X.\"}}}
X.\"{{{  "WRT_GROUP"
X.IP \fB"WRT_GROUP"\fP
XThese switches do not belong to a set of commands, but switch on/off writing to
Xthe output file.  If \fB"CMD_START""WRT_GROUP"\fP and
X\fB"CMD_STOP""WRT_GROUP"\fP are both used for a command line, the
Xreplace pattern is printed and output is disabled afterwards.
X.\"}}}
X.\"{{{  "POS_GROUP"
X.IP \fB"POS_GROUP"\fP
XThese switches do not belong to a set of commands, but print the current match
Xposition in hex.  If \fB"CMD_START"\fP(\fB"CMD_STOP"\fP) is used, the
Xposition will be printed in front (behind) of the replace pattern.  If
X\fB"CMD_START"\fP and \fB"CMD_STOP"\fP are used together, only the last
Xone will be activated.  Like in adress patterns, counting starts with
X"START_COUNT".
X.\"}}}
X.RE
X.\"}}}
X.PP
XIn strings, you can use \fB"QUOTE_CHAR""QUOTE_CHAR"\fP to get a
X\fB"QUOTE_CHAR"\fP, \fB"QUOTE_CHAR""QUOTE_FOR_NL"\fP to get a
X\fBnewline\fP and \fB"QUOTE_CHAR""QUOTE_FOR_TAB"\fP to get a \fBtab\fP.
XYou can also use \fB"QUOTE_CHAR"\fP followed by a decimal, octal
X(starting with 0) or hex (starting with 0x) number to get any character
X(non-printables!) of your character set.
X.PP
XGroup identifiers can consist of \fBa\fP-\fBzA\fP-\fBZ_0\fP-\fB9\fP.
X.\"}}}
X.\"}}}
X.\"{{{  Options
X.SH OPTIONS
X.\"{{{  "OPT_CMD"
X.TP
X\fB\-"OPT_CMD"\fP \fIcommand\fP
XAdd \fBexpression\fP \fIcommand\fP to the command list.  \fIcommand\fP
Xmay contain one line of a \fBfgres\fP program.
X.\"}}}
X.\"{{{  "OPT_CMDF"
X.TP
X\fB\-"OPT_CMDF"\fP \fIcmd-file\fP
XRead commands from \fBfile\fP \fIcmd-file\fP. 
X.\"}}}
X.\"{{{  "OPT_SEP"
X.TP
X\fB\-"OPT_SEP"\fP \fIdelimiter\fP
XAny character in the string \fIdelimiter\fP will be used as \fBfield
Xseparator\fP on \fBfgres\fP program lines.  The default is
X\fB"DFLT_SEPARATOR"\fP.
X.\"}}}
X.\"{{{  "OPT_CASE"
X.TP
X\fB\-"OPT_CASE"\fP
XPattern matching is done \fBcase insensitive\fP.
X.\"}}}
X.\"{{{  "OPT_BIN"
X.TP
X\fB\-"OPT_BIN"\fP
XAllow only replace commands, which do not change the filesize (typically
Xused on \fBbinary\fP files).
X.\"}}}
X.\"{{{  "OPT_GROW"
X.TP
X\fB\-"OPT_GROW"\fP
XIf \fB\-"OPT_BIN"\fP was used, this option enables commands, which
Xlet the file \fBgrow\fP.  If option \fB\-"OPT_BIN"\fP is used after
X\fB\-"OPT_GROW"\fP, this will overwrite \fB\-"OPT_GROW"\fP!
X.\"}}}
X.\"{{{  "OPT_SHRINK"
X.TP
X\fB\-"OPT_SHRINK"\fP
XIf \fB\-"OPT_BIN"\fP was used, this option enables commands, which
Xlet the file \fBshrink\fP.  If option \fB\-"OPT_BIN"\fP is used
Xafter \fB\-"OPT_SHRINK"\fP, this will overwrite
X\fB\-"OPT_SHRINK"\fP!
X.\"}}}
X.\"{{{  "OPT_PAD"
X.TP
X\fB\-"OPT_PAD"\fP
XActivate \fBpadding\fP.  If \fB\-"OPT_BIN"\fP was used, pad
Xsubstitute patterns with trailing null characters or cut them off, in
Xorder to match the length of the search pattern.  Using
X\fB\-"OPT_SHRINK"\fP or \fB\-"OPT_GROW"\fP disables padding
Xrespectively cutting.
X.\"}}}
X.\"{{{  "OPT_VERB"
X.TP
X\fB\-"OPT_VERB"\fP
XSwitch on \fBverbose\fP mode.  \fBfgres\fP prints information about read
Xand written bytes and meybe some warning messages, if
X\fB\-"OPT_PAD"\fP is used.
X.\"}}}
X.\"{{{  "OPT_IN"
X.TP
X\fB\-"OPT_IN"\fP \fIin\fP
X\fBRead\fP from file \fIin\fP.  If \fIin\fP is \fB"STD_FILE"\fP,
Xstandard input is used. Multiple usage of \fB\-"OPT_IN"\fP is allowed.
X.\"}}}
X.\"{{{  "OPT_OUT"
X.TP
X\fB\-"OPT_OUT"\fP \fIout\fP
X\fBWrite\fP to file \fIout\fP.  If \fIout\fP is \fB"STD_FILE"\fP, standard
Xoutput is used.
X.\"}}}
X.\"{{{  "OPT_BLOCKS"
X.TP
X\fB\-"OPT_BLOCKS"\fP \fInumber\fP
XIf \fBfgres\fP is not used in a pipe, \fBfgres\fP stores blocks of
X"BLOCKSIZE" characters in memory, while extending files.  This option
Xoverwrites the default value of "BLOCKS" blocks by \fInumber\fP blocks.
X.\"}}}
X.\"{{{  "OPT_HELP"
X.TP
X\fB\-"OPT_HELP"\fP
XPrint a long usage as \fBhelp\fP.
X.\"}}}
X.\"}}}
X.\"{{{  Errors
X.SH "RETURN VALUE and ERRORS"
X\fBfgres\fP uses standard output only, if \fBfgres\fP was used in a pipe
X(\fB\-"OPT_IN"\fP or \fB\-"OPT_OUT"\fP or no filter files on command
Xline).  The following exit values are used by \fBfgres\fP:
X.PP
X.TS
Xtab(@);
Xl r | l.
XExit Status@@Used for
X_
X\fBEX_OK\fP@(0)@everything goes as planed
X
X\fBEX_USAGE\fP@(64)@command line arguments are incorrect
X\fBEX_DATAERR\fP@(65)@\fBfgres\fP program is incorrect or missing
X\fBEX_NOINPUT\fP@(66)@error on reading the filter source
X\fBEX_SOFTWARE\fP@(70)@should never appear
X\fBEX_OSERR\fP@(71)@error on \fImalloc\fP(3), \fIlseek\fP(2),..
X\fBEX_CANTCREAT\fP@(73)@error on writing the filter output
X\fBEX_IOERR\fP@(74)@error on reading/writing
X_
X@(\fI*\fP)@T{
XThese are the standard UNIX values for the given symbolic constants.
XT}
X.TE
X.\"}}}
X.\"{{{  examples
X.SH EXAMPLES
X.\"{{{  simple
X.SS "Simple Replacement"
XSubstitue all occurrences of \fIfoo\fP with \fIbar\fP in file \fIname\fP:
X.IP
X\fBfgres\fP \fIfoo bar name\fP
X.PP
Xor
X.IP
X\fBfgres \-"OPT_CMD" "\fP\fIfoo bar\fP\fB"\fP \fIname\fP
X.\"}}}
X.\"{{{  long
X.SS "Tagged Replacement"
XSubstitute the string \fIfoo\fP with \fIbar\fP in the string part of an
Xassembler listing \fIlist\fP.  The string part begins with a line
X\fIBEGIN_STRING_DATA\fP and ends at a line \fIEND_STRING_DATA\fP:
X.\"{{{  called with script
X.IP "Use \fBfgres\fP script file \fIfoobar.script\fP:"
X.sp
X\fB"QUOTE_CHAR""CMD_ADRESS""CMD_ADRESS"\fP start foo-bar replace if matching:
X.br
X\fIBEGIN_STRING_DATA BEGIN_STRING_DATA\fP \fB"CMD_START"\fPfoobar
X.sp
X\fB"QUOTE_CHAR""CMD_ADRESS"\fP foobar
X.br
X   \fB"QUOTE_CHAR""CMD_ADRESS""CMD_ADRESS"\fP this is the replace line
X.br
X   \fIfoo bar\fP
X.br
X\fB"QUOTE_CHAR""CMD_ADRESS"\fP
X.sp
X\fB"QUOTE_CHAR""CMD_ADRESS""CMD_ADRESS"\fP end foo-bar replace if matching:
X.br
X\fIEND_STRING_DATA END_STRING_DATA\fP \fB"CMD_STOP"\fPfoobar
X.IP "and call:"
X.sp
X\fBfgres \-"OPT_CMDF"\fP \fIfoobar.script list\fP
X.\"}}}
X.\"{{{  called via command line
X.IP "or simulate \fIfoobar.script\fP with \fB\-"OPT_CMD"\fP options and call:"
X.sp
X\fBfgres \e\fP
X.br
X  \fB\-"OPT_CMD" "\fP\fIBEGIN_STRING_DATA BEGIN_STRING_DATA\fP \fB"CMD_START"\fPfoobar\fB" \e\fP
X.br
X  \fB\-"OPT_CMD" ""QUOTE_CHAR""CMD_ADRESS" \fPfoobar\fB" \e\fP
X.br
X  \fB\-"OPT_CMD" "\fP   \fIfoo bar\fP\fB" \e\fP
X.br
X  \fB\-"OPT_CMD" ""QUOTE_CHAR""CMD_ADRESS"" \e\fP
X.br
X  \fB\-"OPT_CMD" "\fP\fIEND_STRING_DATA END_STRING_DATA\fP \fB"CMD_STOP"\fPfoobar\fB" \e\fP
X.br
X  \fIlist\fP
X.\"}}}
X.\"}}}
X.\"{{{  get positions
X.SS "Show Positions"
XGet all positions of string \fIpattern\fP in a file \fIsource\fP (which can be
Xa binary file, so that \fIgrep\fP(1) and similar commands cannot be used):
X.RS
X.IP "Use \fBfgres\fP with options:"
X.sp
X\fBfgres \-"OPT_IN"\fP \fIsource\fP \fB\e\fP
X.br
X  \fB\-"OPT_CMD" '"QUOTE_CHAR""CMD_ADRESS""START_COUNT" "QUOTE_CHAR""CMD_ADRESS" "CMD_STOP""WRT_GROUP"' \e\fP
X.br
X  \fB\-"OPT_CMD" '\fP\fIpattern\fP \fB"QUOTE_CHAR""QUOTE_FOR_NL" "CMD_START""WRT_GROUP" "CMD_STOP""WRT_GROUP" "CMD_START""POS_GROUP"'\fP
X.RE
X.\"}}}
X.\"{{{  count occurrences
X.SS "Count Occurrences"
XCount the number of occurrences of string \fIpattern\fP in a file \fIsource\fP
X(which can be a binary file, so that \fIgrep\fP(1) and similar commands cannot
Xbe used):
X.IP "Use example \fBShow Positions\fP, piped through \fIwc\fP(1):"
X.sp
X\fBfgres \-"OPT_IN"\fP \fIsource\fP \fB\e\fP
X.br
X  \fB\-"OPT_CMD" '"QUOTE_CHAR""CMD_ADRESS""START_COUNT" "QUOTE_CHAR""CMD_ADRESS" "CMD_STOP""WRT_GROUP"' \e\fP
X.br
X  \fB\-"OPT_CMD" '\fP\fIpattern\fP \fB"QUOTE_CHAR""QUOTE_FOR_NL" "CMD_START""WRT_GROUP" "CMD_STOP""WRT_GROUP" "CMD_START""POS_GROUP"' \e\fP
X.br
X\fB| wc -l\fP
X.\"}}}
X.\"}}}
X.\"{{{  Files
X.SH FILES
X\fBfgres\fP uses \fItmpnam\fP(3) for temporary files.
X.\"}}}
X.\"{{{  Notes
X.SH NOTES
XObviously sequences of \fB\-"OPT_CMD"\fP and \fB\-"OPT_CMDF"\fP
Xoptions are allowed.  In this case, the options are handled
Xleft-to-right.  The different program parts are joined together and
Xhandled as a single unit.
X.PP
XMultiple usage of option \fB\-"OPT_IN"\fP is handled left-to-right,
Xall given files will be read one after the other.  Only one output
Xfile is generated.
X.\"}}}
X.\"{{{  Diagnostics
X.SH DIAGNOSTICS
X.\"{{{  warnings
X.IP "Warning messages:"
X.RS
X.\"{{{  "OPT_BIN" and "OPT_PAD"
X.PP
X"warn_long_replace"
X.br
X"warn_short_replace"
X.IP
XIf \fB\-"OPT_VERB"\fP, \fB\-"OPT_BIN"\fP and \fB\-"OPT_PAD"\fP are active
Xand a replace pattern is longer than the corresponding search pattern,
Xthis messages shows the position of the \fB\-"OPT_BIN"\fP violation.
X.\"}}}
X.\"{{{  remporary file
X.PP
X"warn_temp_file"
X.IP
XThe extension of an filtered file cannot be hold in memory and is stored
Xin a temporary file (\fItempnam\fP(3)).  Option \fB\-"OPT_BLOCKS"\fP can
Xbe used to increase the number of bytes, hold in memory.  
X.\"}}}
X.RE
X.\"}}}
X.\"{{{  errors
X.IP "Error messages:"
X.RS
X.\"{{{  program errors
X.\"{{{  empty program/line
X.PP
X"error_empty_search"
X"error_no_prog"
X.br
X.IP
XEmpty \fBfgres\fP programs or invalid search patterns are not allowed.
X.\"}}}
X.\"{{{  nested groups
X.PP
X"error_group"
X.br
X"error_no_group"
X.br
X"error_open_group"
X.IP
XNested groups for \fBfgres\fP commands are not allowed. The start- and 
Xclose-group statements do not fit.
X.\"}}}
X.\"{{{  preserved group ids
X.PP
X"error_invalid_group"
X.IP
XInvalid group action on replace line or invalid group name on definition
Xof a group.  Group names \fB"WRT_GROUP"\fP, \fB"POS_GROUP"\fP and
X\fB"DFLT_GROUP"\fP are not allowed on start-group command lines.
X.\"}}}
X.\"{{{  "OPT_BIN"
X.PP
X"error_grow_command"
X.br
X"error_shrink_command"
X.br
X"error_pos"
X.br
X"error_stop_write"
X.IP
XOption \fB\-"OPT_BIN"\fP used. The corresponding \fBfgres\fP program 
Xlines violates this restriction!
X.\"}}}
X.\"}}}
X.\"{{{  option errors
X.PP
X"error_noblocks"
X.br
X"error_separator"
X.br 
X"error_redirect"
X.IP
XCommand line parameters are used in an invalid combination or their
Xparameters are invalid.
X.\"}}}
X.\"{{{  system errors
X.PP
X"error_open_file"
X.br
X"error_write"
X.br
X"error_seek"
X.br
X"error_truncate"
X.br
X"error_close_f"
X.br
X"error_unlink"
X.IP
XSystem errors occur, the corresponding action couldt not be performed.
X\fBfgres\fP tries to tell you the reason in the fences.
X.\"}}}
X.RE
X.\"}}}
X.\"}}}
X.\"{{{  Restrictions
X.SH RESTRICTIONS
XIf there are overlapping patterns/adresses, it is undefined, which of
Xthese patterns/adresses triggers its actions.
X.PP
XDifferent \fBfgres\fP program lines for the same pattern/adress are allowed. 
XThis situation is handled in the same way, overlapping patterns/adresses
Xare handled.
X.PP
XIf \fB\-"OPT_IN"\fP \fIin\fP is used more than once, patterns are only
Xhandled inside of the files.  Patterns on the border of two files are not
Xrecognized!
X.PP
XThe output file, given with \fB\-"OPT_OUT"\fP or standard output may
Xnot be an inputfile!
X.\"}}}
X.\"{{{  Author
X.SH AUTHOR
X.TP
XWolfgang Stumvoll at RWTH-Aachen, Germany 
X(stumvoll@pool.informatik.rwth-aachen.de)
X.\"}}}
X.\"{{{  See also
X.SH "SEE ALSO"
Xawk(1), dd(1), sed(1), tr(1)
X.\"}}}
END_OF_FILE
if test 15926 -ne `wc -c <'fgres/MANPAGE'`; then
    echo shar: \"'fgres/MANPAGE'\" unpacked with wrong size!
fi
# end of 'fgres/MANPAGE'
fi
if test -f 'fgres/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fgres/Makefile'\"
else
echo shar: Extracting \"'fgres/Makefile'\" \(2674 characters\)
sed "s/^X//" >'fgres/Makefile' <<'END_OF_FILE'
XBINDIR=		$(HOME)/bin$(ARCHITECTURE)
XMANDIR=		$(HOME)/man
XCC=		gcc -O2
XINSTALL=	install
X
X#{{{}}}
X#{{{  usually not needed configuration on buffer size..:
X# Reading and writing files is done in blocks of BLOCKSIZE(16384) bytes (or
X# multiples of this value, if the search/replace patterns are very long).
X# Up to BLOCKS(64) blocks of BLOCKSIZE bytes of text are hold in memory, while
X# extending a file, so extensions with more than BLOCKS*BLOCKSIZE may use
X# a temporary file.
X# These constants can be redefined with:
X#BLC_CPP=	-DBLOCKS=64
X#BLS_CPP=	-DBLOCKSIZE=16384
X
X# in case, you cannot use ftruncate, uncomment
X#TRUNC_CPP=	-DNO_FTRUNCATE
X
X# in case, you do not want to unlink a temporary file after opening,
X# but on close, uncomment
X#UNL_CPP=	-DDELAYED_CLOSE
X
X# in case, your system does not have <sysexit.h>, uncomment
X#SE_CPP=	-DNOSYSEXIT
X#}}}
X#{{{  known targets:
X#   default               ==binary and manual page
X#   all                   ==default
X#   fgres                 ==generate the executable
X#   manual                ==generate the manual page
X#   fgres.1               ==manual
X#   install               ==man_install and cmd_install
X#   man_install           ==install manual page in $(MANDIR)/man1
X#   cmd_install           ==install binary in $(BINDIR)
X#   clean                 ==remove object files
X#   clobber               ==remove all generated files
X#}}}
X#{{{  changes below this line should not be neccessary
Xall default:	fgres fgres.1
X
X#{{{  headers,sources and objects are
XHEADERS=	global.h patchlevel.h
X
XSOURCES=	file_io.c main.c messages.c program.c
X
XOBJECTS=	$(SOURCES:.c=.o)
X#}}}
X#{{{  cc and cpp flags
XCPPFLAGS= $(TRUNC_CPP) $(UNL_CPP) $(BLC_CPP) $(BLS_CPP) $(SE_CPP)
X
XCFLAGS=$(CPPFLAGS)
X#}}}
X#{{{  dependencies and create command
X$(OBJECTS):	$(HEADERS) Makefile
X
Xfgres:	$(OBJECTS)
X	$(CC) -o $@ $(OBJECTS)
X#}}}
X#{{{  MANPAGE rules
Xmanual:		fgres.1
X
Xfgres.1:	MANPAGE man.fgres fgres
X	./fgres -f man.fgres <MANPAGE >$@
X
Xman.fgres:	global.h messages.c patchlevel.h gen_man.fgres fgres Makefile
X	cat global.h patchlevel.h | ./fgres -f gen_man.fgres >man.fgres.tmp
X	cp man.fgres.tmp $@
X	./fgres -f man.fgres.tmp <messages.c | ./fgres -f gen_man.fgres >>$@
X	/bin/rm -f man.fgres.tmp
X#}}}
X#{{{  install and deinstall
Xinstall:	cmd_install man_install
X
Xcmd_install:	fgres
X	$(INSTALL) fgres $(BINDIR)/fgres
X	strip $(BINDIR)/fgres
X	chmod 755 $(BINDIR)/fgres
X
Xman_install:	fgres.1
X	$(INSTALL) fgres.1 $(MANDIR)/man1/fgres.1
X	chmod 644 $(MANDIR)/man1/fgres.1
X
Xdeinstall:
X	rm -f $(BINDIR)/fgres $(MANDIR)/man1/fgres.1
X#}}}
X#{{{  clean and clobber
Xclean:
X	rm -f $(OBJECTS) core*
X
Xvery_clean:	clobber
X
Xclobber:	clean
X	rm -f fgres* man.fgres*
X#}}}
X#}}}
END_OF_FILE
if test 2674 -ne `wc -c <'fgres/Makefile'`; then
    echo shar: \"'fgres/Makefile'\" unpacked with wrong size!
fi
# end of 'fgres/Makefile'
fi
if test -f 'fgres/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fgres/README'\"
else
echo shar: Extracting \"'fgres/README'\" \(2100 characters\)
sed "s/^X//" >'fgres/README' <<'END_OF_FILE'
Xfgres string replace utility for binary and text files/pipes
X
X-------------------------------------------------------------------------------
X
XCopyright (c) 1994, W. Stumvoll, Germany
X
XSome legal stuff:
X
XUse this software package at your own  risk.  The  programmer  cannot  be  held
Xliable  for  any  incurred  damages,  directly or indirectly due to the use  or
Xinability to use this software.
X
XYou are encouraged to distribute this package freely. This package  is  however
Xnot to be sold (minor transfer costs excepted) or included in any  commercially
Xsold software package (if you want to  do  this  anyway,  contact  me  (address
Xbelow), and we'll work something out).
X
XIf you distribute it, please leave the package intact. You are allowed to  take
Xparts from this distribution and distribute these separately  as  long  as  you
Xretain the copyright messages. If you redistribute any part  of this package in
Xa modified form, be sure to  mark  the  parts  you  changed.  If  you have some
Ximportant  changes  that  might be useful to the rest of the world, contact  me
Xinstead.           
X
Xstumvoll@pool.informatik.rwth-aachen.de
X
X-------------------------------------------------------------------------------
XSubmitted-By: stumvoll@pool.informatik.rwth-aachen.de (Wolfgang Stumvoll)
XArchive-Name: fgres/part01
XEnvironment: ANSI-C, UNIX
X
Xfgres' ( Fast GREp and Substitute ) primary function is to substitute or delete
Xcharacter patterns. It can operate on binary and text files or in a pipe. 
X
XIt is ideally suited for  quick  and  dirty  replacements  in  multiple  files.
XEspecially for this  purpose, fgres supports in situ replacements, which do not
Xneed any temporary files.
X
XFor example:
X   If you want to replace all variables `foo' by `foobar' in all  your  program
X   sources, a mere:
X
X      fgres foo foobar *.[ch]
X
X   will do.
X
XThe more demanding user can create fgres command files. They  can  contain  any
Xnumber of substitution patterns which will  be  simultaneously searched for and
Xcan be collected in named groups.  These  groups can be used to generate finite
Xautomatons.
END_OF_FILE
if test 2100 -ne `wc -c <'fgres/README'`; then
    echo shar: \"'fgres/README'\" unpacked with wrong size!
fi
# end of 'fgres/README'
fi
if test -f 'fgres/file_io.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fgres/file_io.c'\"
else
echo shar: Extracting \"'fgres/file_io.c'\" \(10714 characters\)
sed "s/^X//" >'fgres/file_io.c' <<'END_OF_FILE'
X/*{{{}}}*/
X/*{{{  copyright*/
X/************************************************************************
X *	File I/O routines fgres, including insito handling for files	*
X *									*
X *	Copyright (c) 1994, W. Stumvoll, Germany			*
X *	#include "README"						*
X ************************************************************************/
X/*}}}  */
X
X#include "global.h"
X
X/*{{{  variables*/
X/*{{{  counters for input/output*/
Xpublic off_t dat_read;
Xpublic off_t dat_write;
X/*}}}  */
X/*{{{  buffersize*/
Xprivate off_t r_b_size;
X/*}}}  */
X/*{{{  read buffer*/
Xprivate unsigned char *read_buff=0;
Xprivate off_t read_pos;
Xpublic unsigned char *dat_start;
Xpublic unsigned char *dat_end;
Xpublic off_t skip_data;
X/*}}}  */
X/*{{{  write buffer*/
Xprivate off_t really_written;
Xprivate int stored;
Xprivate int overflow;
Xprivate int do_write;
Xprivate unsigned int written_blocks;
Xprivate unsigned char write_buffer[BLOCKSIZE];
Xprivate off_t write_pos;
Xprivate struct wrt_b_t
X { unsigned char t[BLOCKSIZE];
X   struct wrt_b_t *next;
X } *wrt_over_buff;
Xpublic int no_blocks=BLOCKS;
X/*}}}  */
X/*{{{  data files*/
Xprivate int dat_fin= -1;
Xprivate int dat_fout= -1;
Xpublic char *dat_dummy=0;
Xprivate int dat_save_out= -1;
X/*}}}  */
X/*}}}  */
X
X/*{{{  file access*/
X/*{{{  write_data*/
Xprivate int write_data(int fildes,const unsigned char *b,size_t n)
X { int ret;
X
X   for (ret=0;n;)
X    { ret=write(fildes,b,n);
X      if (ret==-1)
X#ifdef EINTR
X         if (errno==EINTR)
X            ret=0;
X         else
X#endif
X            exit_ma_prog(error_write,error_msg(msg_no_file),EX_IOERR);
X      n-=ret;
X      b+=ret;
X    }
X   return(ret);
X }
X/*}}}  */
X/*{{{  read_data*/
Xprivate int read_data(int fildes,unsigned char *b,size_t n)
X { size_t read_in;
X
X   for (read_in=0;read_in<n;)
X    { size_t ret;
X
X      ret=read(fildes,b,n-read_in);
X      if
X       /*{{{  ret==0 && repeat cannot be succesfull*/
X       (    ret==0
X         && (    1
X#       ifdef EAGAIN
X              && errno!=EAGAIN
X#       endif
X#       ifdef EINTR
X              && errno!=EINTR
X#       endif
X#       ifdef EWOULDBLOCK
X              && errno!=EWOULDBLOCK
X#       endif
X            )
X       )
X       /*}}}  */
X         break;
X      read_in+=ret;
X      b+=ret;
X    }
X   return(read_in);
X }
X/*}}}  */
X/*{{{  close_data*/
Xpublic int close_data(const int fildes)
X { int ret;
X
X   for (;;)
X    { ret=close(fildes);
X      if (!ret || errno!=EINTR)
X         break;
X    }
X   return(ret);
X }
X/*}}}  */
X/*{{{  block_init*/
Xprivate void block_init(void)
X {
X   written_blocks=0;
X   really_written=0;
X   overflow=0;
X   stored=0;
X }
X/*}}}  */
X/*{{{  block_flush*/
Xprivate void block_flush(int mode)
X {
X   assert(dat_dummy,"flush and not inplace");
X   if (mode)
X    /*{{{  flush all data*/
X    {
X      /*{{{  seek to write position*/
X      if (lseek(dat_fout,(off_t)0,0)==-1 || lseek(dat_save_out,really_written,0)==-1)
X         goto seek_error;
X      /*}}}  */
X      /*{{{  write local memory data*/
X      while (wrt_over_buff)
X       { struct wrt_b_t *x;
X
X         stored--;
X         write_data(dat_save_out,wrt_over_buff->t,(size_t)BLOCKSIZE);
X         x=wrt_over_buff->next;
X         free(wrt_over_buff);
X         wrt_over_buff=x;
X       }
X      /*}}}  */
X      /*{{{  write data from file*/
X      while (written_blocks--)
X       { read_data(dat_fout,read_buff,(size_t)BLOCKSIZE);
X         write_data(dat_save_out,read_buff,(size_t)BLOCKSIZE);
X       }
X      /*}}}  */
X    }
X    /*}}}  */
X   else if (!overflow && wrt_over_buff && really_written+BLOCKSIZE<dat_read)
X    /*{{{  flush start of overflow list*/
X    {
X      /*{{{  maybe seek to write position*/
X      if (read_pos!=really_written)
X         if (lseek(dat_save_out,really_written,0)==-1)
X            goto seek_error;
X      /*}}}  */
X      /*{{{  write*/
X      do
X       { struct wrt_b_t *x;
X
X         stored--;
X         write_data(dat_save_out,wrt_over_buff->t,(size_t)BLOCKSIZE);
X         x=wrt_over_buff->next;
X         free(wrt_over_buff);
X         wrt_over_buff=x;
X         really_written+=BLOCKSIZE;
X       }
X      while (wrt_over_buff && really_written+BLOCKSIZE<dat_read);
X      /*}}}  */
X      read_pos=really_written;
X    }
X    /*}}}  */
X   return;
X
X seek_error:
X   exit_ma_prog(error_seek,error_msg(msg_unknown),EX_IOERR);
X }
X/*}}}  */
X/*{{{  block_write*/
Xprivate void block_write(const unsigned char * const block)
X {
X   if (dat_dummy)
X    /*{{{  maybe store file data local*/
X    { struct wrt_b_t *new;
X
X      block_flush(0);
X      if (!overflow && really_written+BLOCKSIZE<dat_read)
X       /*{{{  write direct on file*/
X       { if (read_pos!=really_written)
X            if (lseek(dat_save_out,really_written,0)==-1)
X               exit_ma_prog(error_seek,error_msg(msg_unknown),EX_IOERR);
X         write_data(dat_save_out,block,(size_t)BLOCKSIZE);
X         really_written+=BLOCKSIZE;
X         read_pos=really_written;
X       }
X       /*}}}  */
X      else
X       /*{{{  store data*/
X       { if (stored<no_blocks && (new=malloc(sizeof(struct wrt_b_t))))
X          { stored++;
X            /*{{{  add new block to list*/
X            if (wrt_over_buff)
X             { struct wrt_b_t *x;
X
X               for (x=wrt_over_buff;x->next;x=x->next);
X               x->next=new;
X             }
X            else
X               wrt_over_buff=new;
X            new->next=0;
X            /*}}}  */
X            memcpy(new->t,block,(size_t)BLOCKSIZE);
X          }
X         else
X          { overflow=1;
X            if (written_blocks==0)
X               fprintf(stderr,warn_temp_file,dat_dummy);
X            write_data(dat_fout,block,(size_t)BLOCKSIZE);
X            written_blocks++;
X          }
X
X       }
X       /*}}}  */
X    }
X    /*}}}  */
X   else
X      write_data(dat_fout,block,(size_t)BLOCKSIZE);
X }
X/*}}}  */
X/*}}}  */
X/*{{{  data read/write functions*/
X/*{{{  dat_init*/
Xpublic void dat_init(int fin,int fout)
X {
X   if (fin==fout)
X    /*{{{  use temporary file*/
X    { debug_m("data init for in-place\n");
X      dat_save_out=fout;
X      errno=sys_nerr;
X      if
X       (    !(dat_dummy=tmpnam((char*)0))
X         || (fout=open(dat_dummy,O_RDWR|O_CREAT|O_TRUNC))<0
X       )
X         exit_maa_prog(error_open_file,"temporary",error_msg(msg_no_file),EX_CANTCREAT);
X#     ifndef DELAYED_CLOSE
X         if (unlink(dat_dummy))
X            exit_ma_prog(error_unlink,error_msg(msg_unknown),EX_OSERR);
X#     endif
X      dat_init(fin,fout);
X    }
X    /*}}}  */
X   else
X    /*{{{  init buffers for read/write*/
X    { debug_m("data init for different files\n");
X      block_init();
X      dat_fin=fin;
X      dat_fout=fout;
X      /*{{{  maybe malloc store for program*/
X      if (!read_buff)
X       { for
X          ( r_b_size=BLOCKSIZE
X          ; r_b_size<2*program.max_length
X          ; r_b_size+=BLOCKSIZE
X          )
X          ;
X         read_buff=do_malloc((size_t)(2*r_b_size));
X       }
X      /*}}}  */
X      read_pos=0;
X      dat_read=dat_write=skip_data=0;
X      dat_end=dat_start=read_buff;
X      write_pos=0;
X    }
X    /*}}}  */
X }
X/*}}}  */
X/*{{{  dat_get*/
Xpublic off_t dat_get(void)
X { off_t used;
X
X   if ((used=dat_end-dat_start)<program.max_length)
X    /*{{{  buffer to small, read new data*/
X    { off_t diff;
X
X      if (used && dat_start!=read_buff)
X       /*{{{  shift data to start of buffer*/
X       { off_t i;
X
X         debug_ma("shift %ld bytes back\n",(long int)used);
X         for (i=used,dat_end=read_buff;i;*dat_end++= *dat_start++,i--);
X       }
X       /*}}}  */
X      dat_start=read_buff;
X      dat_end=read_buff+used;
X      /*{{{  maybe seek forward to reading position*/
X      if (read_pos!=dat_read)
X         if (lseek(dat_fin,dat_read,0)==-1)
X            exit_ma_prog(error_seek,error_msg(msg_unknown),EX_IOERR);
X      /*}}}  */
X      diff=(off_t)read_data(dat_fin,dat_end,(size_t)r_b_size);
X      used+=diff;
X      dat_read+=diff;
X      read_pos=dat_read;
X      dat_end=dat_start+used;
X      debug_ma("read got %ld bytes => ",(long int)diff);
X    }
X    /*}}}  */
X   debug_ma("can handle %ld bytes\n",(long int)used);
X   return(used);
X }
X/*}}}  */
X/*{{{  dat_skip*/
Xpublic void dat_skip(off_t skip_width)
X {
X   debug_ma("skip %ld bytes\n",(long int)skip_width);
X   skip_data+=skip_width;
X   if ((dat_start+=skip_width)>dat_end)
X    { debug_maa("start %p end %p\n",dat_start,dat_end);
X      exit_m_prog("crashed skip width\n",EX_SOFTWARE);
X    }
X }
X/*}}}  */
X/*{{{  dat_put*/
Xpublic void dat_put(const unsigned char * s,off_t l)
X { off_t store_len;
X
X   debug_maa("put %ld bytes (%s)\n",(long int)l,do_write?"done":"ignored");
X   if (l && do_write)
X    { dat_write+=l;
X      store_len=BLOCKSIZE-write_pos;
X      if (store_len>=l)
X       { memcpy(write_buffer+write_pos,s,(size_t)l);
X         write_pos+=l;
X       }
X      else
X       { memcpy(write_buffer+write_pos,s,(size_t)store_len);
X         l-=store_len;
X         s+=store_len;
X         block_write(write_buffer);
X         while (l>BLOCKSIZE)
X          { block_write(s);
X            s+=BLOCKSIZE;
X            l-=BLOCKSIZE;
X          }
X         memcpy(write_buffer,s,(size_t)l);
X         write_pos=l;
X
X       }
X    }
X }
X/*}}}  */
X/*{{{  dat_null*/
Xpublic void dat_null(off_t l)
X { 
X   debug_maa("put %ld 0 bytes (%s)\n",(long int)l,do_write?"done":"ignored");
X   while (l)
X    { const unsigned char c[]="";
X
X      dat_put(c,(off_t)1);
X      l--;
X    }
X }
X/*}}}  */
X/*{{{  dat_flush*/
X#ifdef NO_FTRUNCATE
X#  define ftruncate(x,y) 1
X#endif
X
Xpublic void dat_flush(void)
X {
X   if (dat_dummy)
X    /*{{{  flush stored write data, append last block and maybe truncate*/
X    { block_flush(1);
X      if (write_pos)
X         write_data(dat_save_out,write_buffer,(size_t)write_pos);
X      /*{{{  maybe truncate or pad with 0*/
X      if (dat_write<dat_read && ftruncate(dat_save_out,dat_write))
X       { fprintf(stderr,error_truncate,(long int)(dat_read-dat_write));
X         memset(write_buffer,0,(size_t)BLOCKSIZE);
X         while (dat_write<dat_read)
X          { off_t use;
X
X            use=dat_read-dat_write;
X            if (use>BLOCKSIZE)
X               use=BLOCKSIZE;
X            write_data(dat_save_out,write_buffer,(size_t)use);
X            dat_write+=use;
X          }
X       }
X      /*}}}  */
X      /*{{{  close and unlink temporary file*/
X      if (close(dat_fout))
X         exit_maa_prog(error_close_f,dat_dummy,error_msg(msg_unknown),EX_CANTCREAT);
X#      ifdef DELAYED_CLOSE
X         if (unlink(dat_dummy))
X            exit_ma_prog(error_unlink,error_msg(msg_unknown),EX_OSERR);
X#      endif
X      /*}}}  */
X      dat_fout=dat_save_out;
X      dat_save_out=0;
X    }
X    /*}}}  */
X   else
X      write_data(dat_fout,write_buffer,(size_t)write_pos);
X }
X/*}}}  */
X/*{{{  dat_start_write*/
Xpublic void dat_start_write(void)
X {
X   do_write=1;
X }
X/*}}}  */
X/*{{{  dat_stop_write*/
Xpublic void dat_stop_write(void)
X {
X   do_write=0;
X }
X/*}}}  */
X/*}}}  */
END_OF_FILE
if test 10714 -ne `wc -c <'fgres/file_io.c'`; then
    echo shar: \"'fgres/file_io.c'\" unpacked with wrong size!
fi
# end of 'fgres/file_io.c'
fi
if test -f 'fgres/gen_man.fgres' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fgres/gen_man.fgres'\"
else
echo shar: Extracting \"'fgres/gen_man.fgres'\" \(2114 characters\)
sed "s/^X//" >'fgres/gen_man.fgres' <<'END_OF_FILE'
X\##{{{}}}
X\##{{{  copyright
X\########################################################################
X\##	fgres script to transform global.h/messages.c files into a	#
X\##	fgres-script, which replaces the symbolic strings in the man-	#
X\##	page bye the used string constants. 				#
X\##									#
X\##	Copyright (c) 1994, W. Stumvoll, Germany			#
X\##	#include "README"						#
X\########################################################################
X\##}}}
X\##{{{  comment
X\########################################################################
X\##									#
X\##	This is not a good example for a fgres script!			#
X\##	It has to generate another fgres script (many quotes), reading	#
X\##	C-source, ignoring its quotes!					#
X\##									#
X\########################################################################
X\##}}}
X\##{{{  startup
X\#0	.\\\\"{{{\\\ \\\ comment\ .\\\\"\\\ skipped\\\ auto-comment\ -write\ -default\ +comm_skip\n\\#\ comm_skip\n\\\\"}}}\ \\#\ +write\ -comm_skip\ +default\n\\#\n -write
X\##}}}
X\##{{{  handle define lines for global constants
X/*{{{\ \ global\ constants*/\n \\##\ constant\ fold\ started\n +handle -default +write
X\# handle
X	#define\ 	"		+write
X	\t
X	'		"\t		-handle +char
X	"		"\t		-handle +text_or_number
X	(		"\t		-handle +text_or_number
X	/*}}}		\#		-write -handle +default
X\#
X\# text_or_number
X	"\n		\n		-write -text_or_number +handle
X	)\n		\n		-write -text_or_number +handle
X\#
X\# char
X	-		\\\\-
X	','		\\\\fP\\\ or\\\ \\\\fB
X	\  		space
X	\\t		tab
X	\\n		newline
X	\\\\		\\\\e
X	'\n		\n		-write -char +handle
X\#
X\##}}}
X\##{{{  error message handling
X/*{{{\ \ global\ messages:	\\##\ msg\ fold\ started\n +write +error -default -write
X\# error
X	public\ const\ char\ 	"	+write -error +message
X	/*}}}		\#		-error +default
X\#
X\# message
X	\ 		\\\ 		+write
X	[]="		"\t\\\\fB
X	"PROG_POS_F"	(\\\\fP\\\\fIprogram-position\\\\fP\\\\fB)
X	"FILE_TYPE_F"	\\\\fP\\\\fIfile-type\\\\fP\\\\fB
X	"FILE_NAME_F"	\\\\fP\\\\fIfile-name\\\\fP\\\\fB
X	"SYS_ERROR_F"	(\\\\fP\\\\fIsystem-error\\\\fP\\\\fB)
X	"BYTE_COUNT_F"	\\\\fP\\\\fInumber-bytes\\\\fP\\\\fB
X	\\n
X	";\n		\\\\fP\n	-write -message +error
X\#
X\##}}}
END_OF_FILE
if test 2114 -ne `wc -c <'fgres/gen_man.fgres'`; then
    echo shar: \"'fgres/gen_man.fgres'\" unpacked with wrong size!
fi
# end of 'fgres/gen_man.fgres'
fi
if test -f 'fgres/global.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fgres/global.h'\"
else
echo shar: Extracting \"'fgres/global.h'\" \(7260 characters\)
sed "s/^X//" >'fgres/global.h' <<'END_OF_FILE'
X/*{{{}}}*/
X/*{{{  copyright*/
X/************************************************************************
X *	fgres global constants and prototypes				*
X *									*
X *	Copyright (c) 1994, W. Stumvoll, Germany			*
X *	#include "README"						*
X ************************************************************************/
X/*}}}  */
X
X/*{{{  includes*/
X#define _POSIX_SOURCE
X#include <limits.h>
X#include <ctype.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <stdlib.h>
X#include <string.h>
X#include <stdio.h>
X#include <errno.h>
X#include <unistd.h>
X#include <fcntl.h>
X#include "patchlevel.h"
X/*}}}  */
X
X/*{{{  constants*/
X#ifndef CHAR_BIT
X#  define CHAR_BIT 8
X#endif
X#define WRT_GROUP_ID 1
X#define POS_GROUP_ID 2
X#define DFLT_GROUP_ID 3
X#define CMD_SEPARATOR '\n'
X#ifndef BLOCKS
X/*{{{  global constants*/
X#define BLOCKS		(64)
X/*}}}  */
X#endif
X#ifndef BLOCKSIZE
X/*{{{  global constants*/
X#define BLOCKSIZE	(16384)
X/*}}}  */
X#endif
X/*{{{  global constants*/
X#define START_COUNT	(0)
X#define STD_FILE	"-"
X#define WRT_GROUP	"write"
X#define POS_GROUP	"position"
X#define DFLT_GROUP	"default"
X#define QUOTE_CHAR	'\\'
X#define QUOTE_FOR_NL	'n'
X#define QUOTE_FOR_TAB	't'
X#define DFLT_SEPARATOR	' ','\t'
X#define CMD_ADRESS	'#'
X#define CMD_REGION_LEN	'-'
X#define CMD_START	'+'
X#define CMD_STOP	'-'
X#define OPT_BIN		"b"
X#define OPT_CMD		"e"
X#define OPT_CMDF	"f"
X#define OPT_GROW	"g"
X#define OPT_HELP	"h"
X#define OPT_CASE	"i"
X#define OPT_BLOCKS	"n"
X#define OPT_PAD		"p"
X#define OPT_IN		"r"
X#define OPT_SHRINK	"s"
X#define OPT_VERB	"v"
X#define OPT_OUT		"w"
X#define OPT_SEP		"F"
X/*}}}  */
X/*}}}  */
X
X/*{{{  debug/assert switching*/
X/*#define DEBUG   					 /* enables asserts */
X#ifdef DEBUG
X#  define DEBUG_OUT				/* enable debugging outputs */
X#endif
X/*}}}  */
X/*{{{  public/private*/
X#define public
X#define private static
X/*}}}  */
X
X/*{{{  system externals*/
Xextern int sys_nerr;
Xextern char *sys_errlist[];
Xextern int memcmp(const void*,const void*,size_t);
X/*}}}  */
X/*{{{  exit*/
X/*{{{  get exit values*/
X#ifndef NOSYSEXIT
X#  include <sysexits.h>
X#endif
X#ifndef EX_OK
X#  define EX_OK		0	/* successful termination */
X#endif
X#ifndef EX_USAGE
X#  define EX_USAGE	64	/* command line usage error */
X#endif
X#ifndef EX_DATAERR
X#  define EX_DATAERR	65	/* data format error */
X#endif
X#ifndef EX_NOINPUT
X#  define EX_NOINPUT	66	/* cannot open input */
X#endif
X#ifndef EX_SOFTWARE
X#  define EX_SOFTWARE	70	/* internal software error */
X#endif
X#ifndef EX_OSERR
X#  define EX_OSERR	71	/* system error (e.g., can't fork) */
X#endif
X#ifndef EX_CANTCREAT
X#  define EX_CANTCREAT	73	/* can't create (user) output file */
X#endif
X#ifndef EX_IOERR
X#  define EX_IOERR	74	/* input/output error */
X#endif
X/*}}}  */
X#define exit_m_prog(msg,ret) (fprintf(stderr,msg),exit(ret))
X#define exit_ma_prog(msg,arg1,ret) (fprintf(stderr,msg,arg1),exit(ret))
X#define exit_maa_prog(msg,arg1,arg2,ret) (fprintf(stderr,msg,arg1,arg2),exit(ret))
X#define exit_maaa_prog(msg,arg1,arg2,arg3,ret) (fprintf(stderr,msg,arg1,arg2,arg3),exit(ret))
X/*}}}  */
X/*{{{  file_io*/
Xextern char *dat_dummy;
Xextern off_t dat_read;
Xextern off_t dat_write;
Xextern unsigned char *dat_start;
Xextern unsigned char *dat_end;
Xextern off_t skip_data;
Xextern int no_blocks;
Xextern int close_data(const int);
Xextern void dat_init(int,int);
Xextern off_t dat_get(void);
Xextern void dat_skip(off_t);
Xextern void dat_put(const unsigned char*,off_t);
Xextern void dat_flush(void);
Xextern void dat_start_write(void);
Xextern void dat_stop_write(void);
X/*}}}  */
X/*{{{  main*/
Xextern int verbose;
Xextern void *do_malloc(size_t);
Xextern void *do_realloc(void*,size_t);
X/*}}}  */
X/*{{{  messages*/
X/*{{{  error messages*/
Xextern const char error_close_f[];
Xextern const char error_empty_search[];
Xextern const char error_group[];
Xextern const char error_grow_command[];
Xextern const char error_invalid_group[];
Xextern const char error_memory[];
Xextern const char *error_msg(const char *);
Xextern const char error_noblocks[];
Xextern const char error_no_group[];
Xextern const char error_no_prog[];
Xextern const char error_open_file[];
Xextern const char error_open_group[];
Xextern const char error_pos[];
Xextern const char error_redirect[];
Xextern const char error_seek[];
Xextern const char error_separator[];
Xextern const char error_shrink_command[];
Xextern const char error_stop_write[];
Xextern const char error_truncate[];
Xextern const char error_unlink[];
Xextern const char error_write[];
X/*}}}  */
X/*{{{  usage*/
Xextern const char msg_short_usage[];
Xextern const char msg_long_usage[];
X/*}}}  */
X/*{{{  some msg's*/
Xextern const char msg_unknown[];
Xextern const char e_command[];
Xextern const char msg_no_file[];
Xextern const char msg_out[];
Xextern const char msg_statistic[];
Xextern const char simple_command[];
X/*}}}  */
X/*{{{  warnings*/
Xextern const char warn_long_replace[];
Xextern const char warn_short_replace[];
Xextern const char warn_temp_file[];
X/*}}}  */
X/*}}}  */
X/*{{{  program*/
X/*{{{  types*/
X/*{{{  cmd_list_t*/
Xtypedef struct
X { int file;
X   const char *cmd;
X } cmd_list_t;
X/*}}}  */
X/*{{{  prg_t*/
Xtypedef struct
X { enum { no_prg=0,open_grp_prg,ok_prg } mode;
X   off_t min_length;
X   off_t max_length;
X   off_t skip_width[1<<CHAR_BIT];
X   struct cmd_list
X    { int group;
X      enum run_t { inactive=0,active } mode;
X      enum guard_t { nop,pattern,adress } type;
X      off_t len_search;
X      union { const unsigned char *s; off_t add; } guard;
X      off_t len_replace;
X      const unsigned char *r;
X      off_t null_pad;
X      struct act_list
X       { int group_and_action;
X         struct act_list *next;
X       } *act_list;
X      enum pos_mode_t
X       { no_pos=0,
X         pre_pos= -POS_GROUP_ID,
X         post_pos= POS_GROUP_ID
X       } pos_mode;
X      struct cmd_list *next;
X    } *list[(1<<CHAR_BIT)+1],*pos_pattern;
X } prg_t;
X/*}}}  */
X/*{{{  rp_mode_t*/
Xtypedef enum
X { same=0,
X   lower=1,
X   higher=2,
X   same_or_lower=same|lower,
X   same_or_higher=same|higher,
X   all=same|lower|higher,
X   DFLT_MODE=all
X } rp_mode_t;
X/*}}}  */
X/*}}}  */
Xextern const unsigned char dflt_sep_list[];
Xextern const unsigned char *separator_list;
Xextern prg_t program;
Xextern rp_mode_t rp_mode;
Xextern int pad;
Xextern int (*f_memcmp)(const void*,const void*,size_t);
X#ifdef DEBUG
X   extern void debug_prog(char*);
X#endif
Xextern int test_separator(unsigned int);
Xextern int case_memcmp(const void*,const void*,size_t);
Xextern void cmd_init(void);
Xextern enum guard_t cmd_exec
X ( const unsigned char*,off_t,off_t*const,const struct cmd_list**const );
Xextern int cmd_group_handle(struct act_list*);
Xextern void simple_cmd_cmp(const unsigned char*const,const unsigned char*);
Xextern void cmd_compiler(cmd_list_t*,int);
X/*}}}  */
X
X/*{{{  assert*/
X#ifdef DEBUG
X#  define assert(check,com) \
X   ((check)\
X     ?0\
X     :(fprintf(stderr,"assertation failed (%s) at %d\n",com,__LINE__),\
X       abort(),\
X       0\
X      )\
X   )
X#else
X#  define assert(check,str)
X#endif
X/*}}}  */
X/*{{{  debugging functions*/
X#ifdef DEBUG_OUT
X#  define debug_m(msg) fprintf(stderr,msg)
X#  define debug_ma(msg,arg) fprintf(stderr,msg,arg)
X#  define debug_maa(msg,arg1,arg2) fprintf(stderr,msg,arg1,arg2)
X   extern void debug_prog(char*);
X#else
X#  define debug_m(msg)
X#  define debug_ma(msg,arg)
X#  define debug_maa(msg,arg1,arg2)
X#  define debug_prog(s)
X#endif
X/*}}}  */
END_OF_FILE
if test 7260 -ne `wc -c <'fgres/global.h'`; then
    echo shar: \"'fgres/global.h'\" unpacked with wrong size!
fi
# end of 'fgres/global.h'
fi
if test -f 'fgres/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fgres/main.c'\"
else
echo shar: Extracting \"'fgres/main.c'\" \(11131 characters\)
sed "s/^X//" >'fgres/main.c' <<'END_OF_FILE'
X/*{{{}}}*/
X/*{{{  copyright*/
X/************************************************************************
X *	fgres main routine, including argument parsing and signal	*
X *	handlers							*
X *									*
X *	Copyright (c) 1994, W. Stumvoll, Germany			*
X *	#include "README"						*
X ************************************************************************/
X/*}}}  */
X
X#include "global.h"
X
X/*{{{  variables*/
Xpublic int verbose=0;
Xprivate const char std_file[]=STD_FILE;
X/*}}}  */
X
X/*{{{  mallocing*/
X/*{{{  do_malloc*/
Xpublic void *do_malloc(size_t l)
X { void *x;
X
X   x=malloc(l);
X   if (!x)
X      exit_ma_prog(error_memory,(long int)l,EX_OSERR);
X
X   return(x);
X }
X/*}}}  */
X/*{{{  do_realloc*/
Xpublic void *do_realloc(void *x,size_t l)
X {
X   x=realloc(x,l);
X   if (!x)
X      exit_ma_prog(error_memory,(long int)l,EX_OSERR);
X
X   return(x);
X }
X/*}}}  */
X/*}}}  */
X/*{{{  signals*/
Xint got_sig_stop= -1;
X
X/*{{{  init_signals*/
Xprivate void init_signals(void)
X {
X#   ifdef SIGTERM
X      if (signal(SIGTERM,got_sterm)==SIG_IGN)
X          signal(SIGTERM,SIG_IGN);
X#   endif
X#   ifdef SIGHUP
X      if (signal(SIGHUP,got_scrash)==SIG_IGN)
X          signal(SIGHUP,SIG_IGN);
X#   endif
X#   ifdef SIGQUIT
X      if (signal(SIGQUIT,got_sterm)==SIG_IGN)
X          signal(SIGQUIT,SIG_IGN);
X#   endif
X#   ifdef SIGINT
X      if (signal(SIGINT,got_sterm)==SIG_IGN)
X          signal(SIGINT,SIG_IGN);
X#   endif
X }
X/*}}}  */
X/*{{{  got_scrash*/
Xprivate void got_scrash(int sig)
X{
X  fprintf(stderr,"killed on signal %d\n",sig);
X# ifdef DELAYED_CLOSE
X     if (dat_dummy && *dat_dummy && unlink(dat_dummy))
X        exit_ma_prog(error_unlink,error_msg(msg_unknown),EX_OSERR);
X# endif
X  exit(EX_OSERR);
X}
X/*}}}  */
X/*{{{  got_sterm*/
Xprivate void got_sterm(int sig)
X {
X   init_signals();
X   if (got_sig_stop)
X      got_scrash(sig);
X   got_sig_stop=sig;
X }
X/*}}}  */
X/*}}}  */
X/*{{{  filter functions*/
X/*{{{  filter*/
Xvoid filter(int fin,int fout,int init)
X { off_t buff_len;
X
X   debug_m("start filtering\n");
X   dat_init(fin,fout);
X   if (init)
X      cmd_init();
X   while ((buff_len=dat_get()))
X    { off_t find;
X      const struct cmd_list *pat;
X
X      for (;;)
X       { switch (cmd_exec(dat_start,buff_len,&find,&pat))
X          { case nop:
X               break;
X            default:
X               assert(0,"CRASH");
X            case adress:
X            case pattern:
X             { int wrt_off;
X
X               debug_ma("match replace %p\n",pat);
X               dat_put(dat_start,find);
X               dat_skip(find+pat->len_search);
X               wrt_off=cmd_group_handle(pat->act_list);
X               if (pat->pos_mode==pre_pos)
X                /*{{{  handle pre position*/
X                { char buff[sizeof(off_t)*3];
X
X                  sprintf(buff,"%lx",(long int)(skip_data-pat->len_search+START_COUNT));
X                  dat_put((unsigned char*)buff,(off_t)strlen(buff));
X                }
X                /*}}}  */
X               dat_put(pat->r,pat->len_replace);
X               dat_null(pat->null_pad);
X               if (pat->pos_mode==post_pos)
X                /*{{{  handle post position*/
X                { char buff[sizeof(off_t)*3];
X
X                  sprintf(buff,"%lx",(long int)(skip_data-pat->len_search+START_COUNT));
X                  dat_put((unsigned char*)buff,(off_t)strlen(buff));
X                }
X                /*}}}  */
X               if (wrt_off)
X                  dat_stop_write();
X               buff_len=dat_get();
X               continue;
X             }
X          }
X         break;
X       }
X      debug_ma("no match in %ld bytes\n",(long int)buff_len);
X      if (buff_len>=program.max_length)
X         buff_len-=program.max_length-1;
X      dat_put(dat_start,buff_len);
X      dat_skip(buff_len);
X    }
X   dat_flush();   
X }
X/*}}}  */
X/*{{{  filter_file*/
Xint filter_file(const char * const fname,int old_ret)
X { int f; 
X   struct stat buf;
X
X   if ((f=open(fname,O_RDWR))<0)
X    /*{{{  complain*/
X    { fprintf(stderr,error_open_file,"filter",fname,error_msg(msg_unknown));
X      old_ret=EX_NOINPUT;
X    }
X    /*}}}  */
X   else if (fstat(f,&buf) || S_ISDIR(buf.st_mode))
X    /*{{{  complain on directory*/
X    { fprintf(stderr,error_open_file,"filter",fname,"directory");
X      old_ret=EX_NOINPUT;
X    }
X    /*}}}  */
X   else
X    /*{{{  filter*/
X    { filter(f,f,1);
X      if (close_data(f))
X       { fprintf(stderr,error_close_f,fname,error_msg(msg_unknown));
X         old_ret=EX_CANTCREAT;
X       }
X      if (verbose)
X         fprintf(stderr,msg_statistic,fname,(long int)dat_read,(long int)dat_write);
X    }
X    /*}}}  */
X
X   return(old_ret);
X }
X/*}}}  */
X/*{{{  filter_pipe*/
Xint filter_pipe(const char **in_list,int in_count,const char *out_name)
X { int fin,fout;
X   int first;
X   int ret;
X
X   ret=EX_OK;
X   assert(out_name,"output missing");
X   if (!strcmp(out_name,std_file))
X    /*{{{  use stdout*/
X    { fout=fileno(stdout);
X      out_name="stdout";
X    }
X    /*}}}  */
X   else if ((fout=open(out_name,O_WRONLY))<0)
X    /*{{{  complain*/
X    { fprintf(stderr,error_open_file,"filter-output",out_name,error_msg(msg_unknown));
X      ret=EX_CANTCREAT;
X    }
X    /*}}}  */
X   if (fout>=0)
X    { first=1;
X      assert(in_count && in_list[0],"input missing");
X      do
X       { assert(in_count && in_list[0],"input missing");
X         if (!strcmp(*in_list,std_file))
X          /*{{{  use stdin*/
X          { fin=fileno(stdin);
X            *in_list="stdin";
X          }
X          /*}}}  */
X         else if ((fin=open(*in_list,O_RDONLY))<0)
X          /*{{{  complain*/
X          { fprintf(stderr,error_open_file,"filter-input",*in_list,error_msg(msg_unknown));
X            ret=EX_NOINPUT;
X          }
X          /*}}}  */
X         if (fin>=0)
X          { filter(fin,fout,first);
X            first=0;
X            if (close_data(fin))
X             { fprintf(stderr,error_close_f,*in_list,error_msg(msg_unknown));
X               ret=EX_IOERR;
X             }
X            if (verbose)
X               fprintf(stderr,msg_statistic,*in_list,(long int)dat_read,(long int)dat_write);
X          }
X         in_list++;
X       }
X      while (--in_count);
X      if (close_data(fout))
X       { fprintf(stderr,error_close_f,out_name,error_msg(msg_unknown));
X         ret=EX_CANTCREAT;
X       }
X      if (verbose)
X         fprintf(stderr,msg_out,out_name);
X    }
X
X   return(ret);
X }
X/*}}}  */
X/*}}}  */
X/*{{{  main*/
Xpublic int main(argc,argv) int argc;char **argv;
X { const char *output_file=0;
X   int ef_used;
X   cmd_list_t *ef_list;
X   int r_used;
X   const char **r_list;
X   extern int optind;
X   int ret;
X
X   /*{{{  argument decoding*/
X   { extern int getopt();
X     extern char *optarg;
X
X     /*{{{  init buffer for -e/f -r*/
X     ef_list=do_malloc(argc*sizeof(cmd_list_t));
X     ef_used=0;
X     r_list=do_malloc(argc*sizeof(const char**));
X     r_used=0;
X     /*}}}  */
X     /*{{{  handle arguments*/
X     for (;;)
X      { int c;
X
X        /*{{{  c=getopt(options)*/
X        c=getopt
X           ( argc,argv,
X             OPT_BIN
X             OPT_BLOCKS":"
X             OPT_CASE
X             OPT_CMD":"
X             OPT_CMDF":"
X             OPT_SEP":"
X             OPT_GROW
X             OPT_HELP
X             OPT_IN":"
X             OPT_OUT":"
X             OPT_PAD
X             OPT_SHRINK
X             OPT_VERB
X           );
X        /*}}}  */
X        /*{{{  OPT_IN*/
X        if (c==OPT_IN[0])
X         { r_list[r_used++]=optarg;
X           continue;
X         }
X        /*}}}  */
X        /*{{{  OPT_OUT*/
X        if (c==OPT_OUT[0])
X         { output_file=optarg;
X           continue;
X         }
X        /*}}}  */
X        /*{{{  OPT_CMD[F]*/
X        if (c==OPT_CMD[0] || c==OPT_CMDF[0])
X         { ef_list[ef_used].file=(c==OPT_CMDF[0]);
X           ef_list[ef_used].cmd=optarg;
X           ef_used++;
X           continue;
X         }
X        /*}}}  */
X        /*{{{  OPT_SEP*/
X        if (c==OPT_SEP[0])
X         { if
X            (    !(separator_list=(unsigned char*)optarg)
X              || test_separator(CMD_SEPARATOR)
X              || test_separator(QUOTE_CHAR)
X            )
X            {
X              fprintf(stderr,error_separator);
X              separator_list=dflt_sep_list;
X            }
X           continue;
X         }
X        /*}}}  */
X        /*{{{  OPT_BIN/GROW/CASE*/
X        if (c==OPT_BIN[0])
X         { rp_mode=same;
X           continue;
X         }
X        if (c==OPT_CASE[0])
X         { f_memcmp=case_memcmp;
X           continue;
X         }
X        if (c==OPT_GROW[0])
X         { rp_mode|=higher;
X           continue;
X         }
X        if (c==OPT_SHRINK[0])
X         { rp_mode|=lower;
X           continue;
X         }
X        if (c==OPT_PAD[0])
X         { pad=1;
X           continue;
X         }
X        /*}}}  */
X        /*{{{  OPT_BLOCKS*/
X        if (c==OPT_BLOCKS[0])
X         { no_blocks=atoi(optarg);
X           if (no_blocks<=1)
X            { fprintf(stderr,error_noblocks);
X              goto error_opt;
X            }
X           continue;
X         }
X        /*}}}  */
X        /*{{{  OPT_HELP/VERB/error*/
X        if (c==OPT_VERB[0])
X         { verbose=1;
X           continue;
X         }
X        if (c==OPT_HELP[0])
X           exit_ma_prog(msg_long_usage,msg_short_usage,EX_USAGE);
X        if (c=='?')
X         { error_opt:
X
X           exit_m_prog(msg_short_usage,EX_USAGE);
X         }
X        /*}}}  */
X        break;
X      }
X     /*}}}  */
X   }
X   /*}}}  */
X   init_signals();
X   /*{{{  compile program*/
X   if (!ef_used)
X    /*{{{  compile command line replace*/
X    {
X      /*{{{  no serach given -> error*/
X      if (argc-optind==0)
X       { fprintf(stderr,error_no_prog);
X         goto error_opt;
X       }
X      /*}}}  */
X      debug_maa("need to compile args '%s' '%s'\n",argv[optind],(argc-optind>=2)?argv[optind+1]:"");
X      if (argc-optind>=2)
X       /*{{{  search and replace given*/
X       { simple_cmd_cmp
X          ( (unsigned char*)argv[optind],
X            (unsigned char*)argv[optind+1]
X          );
X         optind+=2;
X       }
X       /*}}}  */
X      else
X       /*{{{  only search given*/
X       { simple_cmd_cmp
X          ( (unsigned char*)argv[optind],
X            (unsigned char*)0
X          );
X         optind+=1;
X       }
X       /*}}}  */
X    }
X    /*}}}  */
X   else
X      cmd_compiler(ef_list,ef_used);
X   free(ef_list);
X   /*}}}  */
X   /*{{{  filter files/pipe*/
X   /*{{{  command line files and pipe arguments -> error*/
X   if (argc-optind>0 && (r_used || output_file))
X    { fprintf(stderr,error_redirect);
X      goto error_opt;
X    }
X   /*}}}  */
X   ret=EX_OK;
X   if (optind==argc)
X    /*{{{  use pipe arguments*/
X    { debug_m("need to filter pipe\n");
X      /*{{{  no -r, so fake one: -r -*/
X      if (!r_used)
X       { r_used=1;
X         r_list[0]=std_file;
X       }
X      /*}}}  */
X      /*{{{  no -w, so fake one: -w -*/
X      if (!output_file)
X         output_file=std_file;
X      /*}}}  */
X      ret=filter_pipe(r_list,r_used,output_file);
X    }
X    /*}}}  */
X   else
X    /*{{{  use command line files*/
X      do
X       { debug_ma("need to filter %s\n",argv[optind]);
X         ret=filter_file(argv[optind],ret);
X         if (got_sig_stop>=0)
X            got_sterm(got_sig_stop);
X       }
X      while (++optind<argc);
X    /*}}}  */
X   /*}}}  */
X
X   return(ret);
X }
X/*}}}  */
END_OF_FILE
if test 11131 -ne `wc -c <'fgres/main.c'`; then
    echo shar: \"'fgres/main.c'\" unpacked with wrong size!
fi
# end of 'fgres/main.c'
fi
if test -f 'fgres/messages.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fgres/messages.c'\"
else
echo shar: Extracting \"'fgres/messages.c'\" \(4075 characters\)
sed "s/^X//" >'fgres/messages.c' <<'END_OF_FILE'
X/*{{{}}}*/
X/*{{{  copyright*/
X/************************************************************************
X *	fgres messages							*
X *									*
X *	Copyright (c) 1994, W. Stumvoll, Germany			*
X *	#include "README"						*
X ************************************************************************/
X/*}}}  */
X
X#include "global.h"
X
X/*{{{  format constants for messages*/
X#define PROG_POS_F	"(%s %d)"
X#define FILE_TYPE_F	"%s"
X#define FILE_NAME_F	"%s"
X#define SYS_ERROR_F	"(%s)"
X#define BYTE_COUNT_F	"%ld"
X/*}}}  */
X
X/*{{{  error_msg*/
Xpublic const char *error_msg(const char *def)
X {
X   return((errno<sys_nerr) ? sys_errlist[errno] : def);
X }
X/*}}}  */
X/*{{{  global messages:error messages*/
Xpublic const char error_close_f[]="cannot close "FILE_NAME_F" "SYS_ERROR_F"\n";
Xpublic const char error_empty_search[]="empty search "PROG_POS_F"\n";
Xpublic const char error_group[]="group active "PROG_POS_F"\n";
Xpublic const char error_grow_command[]="growing command "PROG_POS_F"\n";
Xpublic const char error_invalid_group[]="invalid group id "PROG_POS_F"\n";
Xpublic const char error_memory[]="no more memory, malloc "BYTE_COUNT_F" bytes failed\n";
Xpublic const char error_noblocks[]="-"OPT_BLOCKS": invalid value\n";
Xpublic const char error_no_group[]="no group active "PROG_POS_F"\n";
Xpublic const char error_no_prog[]="no program given\n";
Xpublic const char error_open_file[]="cannot open "FILE_TYPE_F" file "FILE_NAME_F" "SYS_ERROR_F"\n";
Xpublic const char error_open_group[]="group open at end of program\n";
Xpublic const char error_pos[]="-"OPT_BIN" disables position output "PROG_POS_F"\n";
Xpublic const char error_redirect[]="option "OPT_IN"/"OPT_OUT" and file argument conflict\n";
Xpublic const char error_seek[]="seek failed "SYS_ERROR_F"\n";
Xpublic const char error_separator[]="-"OPT_SEP": invalid string, using default\n";
Xpublic const char error_shrink_command[]="shrinking command "PROG_POS_F"\n";
Xpublic const char error_stop_write[]="-"OPT_BIN" disables stop writing "PROG_POS_F"\n";
Xpublic const char error_truncate[]="truncate file failes, padded with "BYTE_COUNT_F" 0\n";
Xpublic const char error_unlink[]="remove temporary file failed "SYS_ERROR_F"\n";
Xpublic const char error_write[]="write failed "SYS_ERROR_F"\n";
X/*}}}  */
X/*{{{  usage*/
Xpublic const char msg_short_usage[]=
X  "fgres - version "VERSION", usage is:\n"
X  "   fgres <options> [-"OPT_IN" in] [-"OPT_OUT" out] search [replace]\n"
X  "   fgres <options> search [replace [file .. ]]\n"
X  "   fgres <options> <program> file .. \n"
X  "   fgres <options> <program> [-"OPT_IN" in] [-"OPT_OUT" out]\n"
X  "where:  <options>:	[-"OPT_BIN OPT_CASE OPT_GROW OPT_HELP OPT_PAD OPT_SHRINK OPT_VERB"] [-"OPT_BLOCKS" number] [-"OPT_SEP" limiter]\n"
X  "        <program>:	(-"OPT_CMD" cmd | -"OPT_CMDF" file) ..\n";
Xpublic const char msg_long_usage[]=
X  "%swith:\n"
X  "   -"OPT_BIN		  "\t"	"binary, filesize may not be changed\n"
X  "   -"OPT_CASE	  "\t"	"case insensitive pattern match\n"
X  "   -"OPT_PAD		  "\t"	"pad short and cut long replaces\n"
X  "   -"OPT_GROW	  "\t"	"allow file grow\n"
X  "   -"OPT_SHRINK	  "\t"	"allow file shrink\n"
X  "   -"OPT_CMD		  "\t"	"command\n"
X  "   -"OPT_CMDF	  "\t"	"command file\n"
X  "   -"OPT_IN		  "\t"	"input file\n"
X  "   -"OPT_OUT		  "\t"	"output file\n"
X  "   -"OPT_BLOCKS	  "\t"	"set number of stored I/O blocks for file replacement k\n"
X  "   -"OPT_HELP	  "\t"	"this message\n"
X  "   -"OPT_VERB	  "\t"	"verbose\n";
X/*}}}  */
X/*{{{  some msg's*/
Xpublic const char msg_unknown[]="unkown";
Xpublic const char e_command[]="-e argument";
Xpublic const char msg_no_file[]="no file";
Xpublic const char msg_out[]="written to file "FILE_NAME_F"\n";
Xpublic const char msg_statistic[]="filtered "FILE_NAME_F" ("BYTE_COUNT_F" -> "BYTE_COUNT_F")\n";
Xpublic const char simple_command[]="command line argument";
X/*}}}  */
X/*{{{  global messages:warnings*/
Xpublic const char warn_long_replace[]="cut long replace "PROG_POS_F"\n";
Xpublic const char warn_short_replace[]="padding short replace "PROG_POS_F"\n";
Xpublic const char warn_temp_file[]="(using temporary file "FILE_NAME_F")\n";
X/*}}}  */
END_OF_FILE
if test 4075 -ne `wc -c <'fgres/messages.c'`; then
    echo shar: \"'fgres/messages.c'\" unpacked with wrong size!
fi
# end of 'fgres/messages.c'
fi
if test -f 'fgres/patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fgres/patchlevel.h'\"
else
echo shar: Extracting \"'fgres/patchlevel.h'\" \(70 characters\)
sed "s/^X//" >'fgres/patchlevel.h' <<'END_OF_FILE'
X/*{{{}}}*/
X/*{{{  global constants*/
X#define VERSION		"1.5"
X/*}}}  */
END_OF_FILE
if test 70 -ne `wc -c <'fgres/patchlevel.h'`; then
    echo shar: \"'fgres/patchlevel.h'\" unpacked with wrong size!
fi
# end of 'fgres/patchlevel.h'
fi
if test -f 'fgres/program.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fgres/program.c'\"
else
echo shar: Extracting \"'fgres/program.c'\" \(24940 characters\)
sed "s/^X//" >'fgres/program.c' <<'END_OF_FILE'
X/*{{{}}}*/
X/*{{{  copyright*/
X/************************************************************************
X *	Compiler for command language and program executer		*
X *									*
X *	Copyright (c) 1994, W. Stumvoll, Germany			*
X *	#include "README"						*
X ************************************************************************/
X/*}}}  */
X
X#include "global.h"
X
X/*{{{  variables*/
Xpublic const unsigned char dflt_sep_list[]={ DFLT_SEPARATOR,'\0' };
Xpublic const unsigned char *separator_list=dflt_sep_list;
Xpublic prg_t program;
Xpublic rp_mode_t rp_mode=DFLT_MODE;
Xpublic int pad=0;
Xpublic int (*f_memcmp)(const void*,const void*,size_t)=memcmp;
X/*}}}  */
X
X#ifdef DEBUG_OUT
X   /*{{{  show all program buffers!*/
X   public void debug_prog(char *s)
X    { int i;
X
X      fprintf(stderr,"Program at:%s (min/max=%ld/%ld)\n",s,(long)program.min_length,(long)program.max_length);
X      for (i=0;i<=(1<<CHAR_BIT);i++)
X       { struct cmd_list *l;
X
X         for (l=program.list[i];l;l=l->next)
X          { struct act_list *a;
X
X            fprintf(stderr," %p %c ",l,(l->mode==active)?'+':'-');
X            if (l->type==adress)
X               fprintf(stderr," add %ld ",l->guard.add);
X            else
X             { int k;
X
X               fprintf(stderr," >");
X               for (k=0;k<l->len_search;k++)
X                  fprintf(stderr,"%c",l->guard.s[k]?l->guard.s[k]:'.');
X               fprintf(stderr,"< ");
X             }
X            fprintf(stderr,"-> %ld/%ld >",(long)l->len_replace,(long)l->null_pad);
X            { int k;
X
X              for (k=0;k<l->len_replace;k++)
X                 fprintf(stderr,"%c",l->r[k]?l->r[k]:'.');
X            }
X            if ((a=l->act_list))
X               do
X                  if (a->group_and_action>0)
X                     fprintf(stderr,"(START %d)",a->group_and_action);
X                  else
X                     fprintf(stderr,"(STOP %d)",-a->group_and_action);
X               while ((a=a->next));
X            fprintf(stderr,"\n");
X          }
X       }
X    }
X   /*}}}  */
X#endif
X/*{{{  test_separator*/
Xpublic int test_separator(unsigned int c)
X {
X   return(c && strchr((char*)separator_list,c));
X }
X/*}}}  */
X/*{{{  case_memcmp*/
Xpublic int case_memcmp(const void *s1,const void *s2,size_t l)
X { char c1,c2;
X   const char *p1,*p2;
X
X   for (p1=(char*)s1,p2=(char*)s2;l;l--);
X    { c1= *p1++;
X      c2= *p2++;
X      if (c1!=c2)
X       { c1=toupper(c1);
X         if (c1!=c2)
X            return(1);
X       }
X    }
X   return(0);
X }
X/*}}}  */
X/*{{{  cmd_init*/
Xpublic void cmd_init(void)
X { int i;
X
X   dat_start_write();
X   program.list[1<<CHAR_BIT]=program.pos_pattern;
X   for (i=1<<CHAR_BIT;i>=0;i--)
X    { struct cmd_list *c;
X
X      for (c=program.list[i];c;c=c->next)
X         c->mode=(c->group==DFLT_GROUP_ID);
X    }
X }
X/*}}}  */
X/*{{{  cmd_exec*/
Xpublic enum guard_t cmd_exec
X ( const unsigned char *s,
X   off_t length,
X   off_t * const pos,
X   const struct cmd_list * * const pat
X )
X { const unsigned char *start;
X   enum guard_t ret;
X   off_t len;
X
X   debug_prog("pre exec");
X   ret=nop;
X   len=length;
X   /*{{{  search for pattern*/
X   if (len>=program.min_length)
X      for (start=s;;)
X       { size_t diff;
X         unsigned int c;
X
X         assert(len>0,"check empty string?");
X         diff=program.skip_width[c= *s];
X         if (diff)
X          /*{{{  skip over text*/
X          { s+=diff;
X            if ((len-=diff)<=0)
X               break;
X          }
X          /*}}}  */
X         else
X          /*{{{  test matches*/
X          { struct cmd_list *list;
X
X            for (list=program.list[c];list;list=list->next)
X               if (list->mode==active)
X                { const unsigned char *word;
X                  size_t lg;
X
X                  lg=list->len_search-1;
X                  word=s-lg;
X                  if (word>=start && !f_memcmp(word,list->guard.s,(size_t)lg))
X                   { *pos=word-start;
X                     *pat=list;
X                     ret=list->type;
X                     goto ad_handle;
X                   }
X                }
X            if (--len)
X               s++;
X            else
X               break;
X          }
X          /*}}}  */
X       }
X   /*}}}  */
X ad_handle:
X   /*{{{  check, if a adress pattern is front of the found string pattern*/
X   { off_t ad;
X     struct cmd_list *x;
X
X     debug_maa("skip %ld len %ld=>",(long)skip_data,(long)length);
X     /*{{{  get compare adress*/
X     if (ret==nop)
X        ad=skip_data+(length-program.min_length);
X     else
X        ad= *pos;
X     /*}}}  */
X     debug_maa("check adress %s %ld\n",((ret==nop)?"nomatch":"match"),(long)ad);
X     /*{{{  compare against adress patterns*/
X     for (x=program.list[1<<CHAR_BIT];x;x=x->next)
X      { debug_ma(" -> %ld\n",(long)x->guard.add);
X        if (x->mode==active && x->guard.add<ad)
X         { ret=adress;
X           *pos=x->guard.add-skip_data-1;
X           *pat=x;
X           break;
X         }
X      }
X     /*}}}  */
X     /*{{{  cut remove unneded adress patterns*/
X     while
X      (    program.list[1<<CHAR_BIT]
X        && program.list[1<<CHAR_BIT]->guard.add<=ad
X      )
X        program.list[1<<CHAR_BIT]=program.list[1<<CHAR_BIT]->next;
X     /*}}}  */
X   }
X   /*}}}  */
X   return(ret);
X }
X/*}}}  */
X/*{{{  cmd_group_handle*/
Xpublic int cmd_group_handle(struct act_list *l)
X { int ret;
X
X   debug_ma("group_handle %p\n",l);
X   for (ret=0;l;l=l->next)
X    { int id;
X      enum run_t new;
X
X
X      debug_ma("group_handle %d\n",l->group_and_action);
X      /*{{{  get id and action*/
X      id=l->group_and_action;
X      if (id>0)
X         new=active;
X      else
X       { new=inactive;
X         id=0-id;
X       }
X      /*}}}  */
X      if (id==WRT_GROUP_ID)
X       /*{{{  start/stop writing*/
X       { if (new==active)
X            dat_start_write();
X         else
X            ret=1;
X         debug_ma("write-switch %d\n",new==active);
X       }
X       /*}}}  */
X      else
X       /*{{{  [in]activate command group*/
X       { int i;
X
X         debug_maa("switch group %d %d\n",id,new==active);
X         for (i=1<<CHAR_BIT;i>=0;i--)
X          { struct cmd_list *c;
X
X            for (c=program.list[i];c;c=c->next)
X               if (c->group==id)
X                  c->mode=new;
X          }
X       }
X       /*}}}  */
X    }
X   return(ret);
X }
X/*}}}  */
X/*{{{  cmd_cmp*/
Xprivate const char *cmd_file_name=0;
Xprivate int cmd_lineno=0;
X/*{{{  add_prg*/
Xprivate void add_prg(struct cmd_list * const pat)
X { off_t len,pad_count;
X
X   len=pat->len_search;
X   pad_count=0;
X   /*{{{  handle -bgsp*/
X   if (!(rp_mode&lower) && len>pat->len_replace)
X    /*{{{  shrinking command, but not allowed*/
X    { if (pad)
X       { unsigned char *new_rep;
X
X         pad_count=len-pat->len_replace;
X         if (verbose)
X            fprintf(stderr,warn_short_replace,cmd_file_name,cmd_lineno);
X       }
X      else
X         exit_maa_prog(error_shrink_command,cmd_file_name,cmd_lineno,EX_DATAERR);
X    }
X    /*}}}  */
X   if (!(rp_mode&higher) && len<pat->len_replace)
X    /*{{{  growing command, but not allowed*/
X    { if (pad)
X       { pat->len_replace=len;
X         if (verbose)
X            fprintf(stderr,warn_long_replace,cmd_file_name,cmd_lineno);
X       }
X      else
X         exit_maa_prog(error_grow_command,cmd_file_name,cmd_lineno,EX_DATAERR);
X    }
X    /*}}}  */
X   pat->null_pad=pad_count;
X   /*}}}  */
X   if (pat->type==pattern)
X    /*{{{  insert pattern match*/
X    { unsigned int key;
X
X      if (f_memcmp==case_memcmp)
X       /*{{{  search pattern to uppercase*/
X       { off_t l;
X
X         for (l=0;l<len;l++)
X           ((char*)(pat->guard.s))[l]=toupper(pat->guard.s[l]);
X       }
X       /*}}}  */
X      key=pat->guard.s[len-1];
X      /*{{{  add to list, sorted by len*/
X      pat->next=program.list[key];
X      program.list[key]=pat;
X      if (f_memcmp==case_memcmp)
X         program.list[tolower(key)]=program.list[key];
X      /*}}}  */
X      /*{{{  add to jump table*/
X      { int i;
X
X        /*{{{  shrink or set maximum skip width*/
X        for (i=0;i<1<<CHAR_BIT;i++)
X           if (program.skip_width[i]>len || program.mode==no_prg)
X              program.skip_width[i]=len;
X        /*}}}  */
X        /*{{{  reduce for chars in current string*/
X        for (i=0;i<len;i++)
X         { unsigned int c;
X
X           c=pat->guard.s[i];
X           if (program.skip_width[c]>len-i-1)
X              program.skip_width[c]=len-i-1;
X           if (f_memcmp==case_memcmp)
X            { unsigned int c1;
X
X              c1=tolower(c);
X              if (c1!=c)
X                 if (program.skip_width[c1]>len-i-1)
X                    program.skip_width[c1]=len-i-1;
X            }
X         }
X        /*}}}  */
X      }
X      /*}}}  */
X    }
X    /*}}}  */
X   else
X    /*{{{  insert adress match*/
X    { off_t pos;
X      struct cmd_list **x;
X
X      assert(pat->type==adress,"unknown op type");
X      pos=pat->guard.add;
X      for (x=program.list+(1<<CHAR_BIT);;x= &((*x)->next))
X           if (!*x || (*x)->guard.add>pos)
X            { pat->next= *x;
X              *x=pat;
X              break;
X            }
X      program.pos_pattern=program.list[1<<CHAR_BIT];
X    }
X    /*}}}  */
X   /*{{{  set min/max len*/
X   if (program.mode==no_prg || len+pad_count>program.max_length)
X      program.max_length=len+pad_count;
X   if (program.mode==no_prg || len+pad_count<program.min_length)
X      program.min_length=len+pad_count;
X   /*}}}  */
X }
X/*}}}  */
X
X/*{{{  simple_cmd_cmp*/
Xpublic void simple_cmd_cmp
X ( const unsigned char * const search,
X   const unsigned char * replace
X )
X { struct cmd_list *p;
X
X   cmd_file_name=simple_command;
X   cmd_lineno=1;
X   if (!replace)
X      replace=(unsigned char*)"";
X   assert(search && replace,"null command pointer given");
X   p=do_malloc(sizeof(struct cmd_list));
X   p->group=DFLT_GROUP_ID;
X   p->type=pattern;
X   p->len_search=strlen((char*)search);
X   p->guard.s=search;
X   p->len_replace=strlen((char*)replace);
X   p->r=replace;
X   p->pos_mode=no_pos;
X   p->act_list=0;
X   add_prg(p);
X   program.mode=ok_prg;
X   debug_prog("post-simple command!");
X }
X/*}}}  */
X/*{{{  cmd_compiler*/
X/*{{{  white_skip*/
Xprivate const unsigned char *white_skip(const unsigned char *s)
X {
X   while (test_separator(*s))
X      s++;
X   return(s);
X }
X/*}}}  */
X/*{{{  grp_skip*/
Xprivate const unsigned char *grp_skip(const unsigned char *s)
X {
X   while (isalnum(*s) || *s=='_')
X      s++;
X   return(s);
X }
X/*}}}  */
X/*{{{  get_group*/
Xprivate int get_group(const unsigned char * const name)
X {
X   static int next_id=WRT_GROUP_ID+DFLT_GROUP_ID+1;
X   static const struct grp_list
X    { const unsigned char *name;
X      int id;
X      struct grp_list *next;
X    } pos_grp={ (unsigned char*)POS_GROUP,POS_GROUP_ID,0 },
X      wrt_grp={ (unsigned char*)WRT_GROUP,WRT_GROUP_ID,(struct grp_list*)&pos_grp },
X      dflt_grp={ (unsigned char*)DFLT_GROUP,DFLT_GROUP_ID,(struct grp_list*)&wrt_grp };
X   static struct grp_list *groups=(struct grp_list*)&dflt_grp;
X   int res;
X
X   res=DFLT_GROUP_ID;
X   if (name && name[0])
X    { struct grp_list *x;
X
X      for (x=groups;;x=x->next)
X         if (!x)
X          /*{{{  add new group, break*/
X          { struct grp_list *new;
X
X            new=do_malloc(sizeof(struct grp_list));
X            res=new->id=next_id++;
X            new->name=name;
X            new->next=groups;
X            groups=new;
X            break;
X          }
X          /*}}}  */
X         else if (!strcmp((char*)name,(char*)x->name))
X          /*{{{  found, break*/
X          { res=x->id;
X            break;
X          }
X          /*}}}  */
X
X    }
X
X   return(res);
X }
X/*}}}  */
X/*{{{  test_comment*/
Xprivate int test_comment(const unsigned char * const s)
X {
X   return
X    (    s[0]==CMD_SEPARATOR
X      || (s[0]==QUOTE_CHAR && s[1]==CMD_ADRESS && s[2]==CMD_ADRESS)
X    );
X }
X/*}}}  */
X/*{{{  cmd_reading*/
Xprivate cmd_list_t *cmd_data=0;
Xprivate int cmd_open=0;
Xprivate unsigned char *cmd_buffer=0;
Xprivate size_t cmd_size=0;
X
X/*{{{  init_cmd_read*/
Xprivate void init_cmd_read(cmd_list_t *cmds,int used)
X {
X   assert(used,"no program given\n");
X   cmd_data=cmds;
X   cmd_open=used;
X   debug_m("init cmd_read\n");
X }
X/*}}}  */
X/*{{{  cmd_read*/
Xprivate const unsigned char *cmd_read(void)
X { 
X
X   debug_maa("cmd_read open=%d cur=>%s<\n",cmd_open,cmd_data->cmd?cmd_data->cmd:"empty");
X   for (;cmd_open;)
X    { if (cmd_data->file)
X       /*{{{  get data from file*/
X       { size_t readin;
X         int c;
X         static FILE *f=0;
X
X         if (!cmd_buffer)
X          /*{{{  malloc new space for command*/
X          { cmd_size=BLOCKSIZE;
X            debug_ma("growing cmd buffer to %ld\n",(long int)cmd_size);
X            cmd_buffer=do_malloc(cmd_size);
X          }
X          /*}}}  */
X         /*{{{  maybe open command file*/
X         if (!f)
X          { cmd_file_name=cmd_data->cmd;
X            cmd_lineno=0;
X            if (!(f=fopen(cmd_file_name,"r")))
X               exit_maaa_prog(error_open_file,"command",cmd_file_name,error_msg(msg_unknown),EX_DATAERR);
X          }
X         /*}}}  */
X         for (readin=0;;)
X          { switch ((c=fgetc(f)))
X             { default:
X                  if (readin==cmd_size)
X                   /*{{{  extend read buffer*/
X                   { cmd_size=2*cmd_size;
X                     debug_ma("growing cmd buffer to %ld\n",(long int)cmd_size);
X                     cmd_buffer=do_realloc(cmd_buffer,cmd_size);
X                   }
X                   /*}}}  */
X                  cmd_buffer[readin++]=c;
X                  continue;
X               case EOF:
X                  fclose(f);
X                  f=0;
X                  cmd_data++;
X                  cmd_open--;
X               case CMD_SEPARATOR:
X                  cmd_lineno++;
X                  cmd_buffer[readin]=CMD_SEPARATOR;
X                  cmd_buffer[readin+1]='\0';
X                  break;
X             }
X            break;
X          }
X         if (cmd_buffer[0]==CMD_SEPARATOR && cmd_buffer[1]=='\0' && !f)
X            continue;
X       }
X       /*}}}  */
X      else
X       /*{{{  get cmd-line arg*/
X       { static const char lim[]= { CMD_SEPARATOR,'\0' };
X         static int e_count=0;
X
X         cmd_file_name=e_command;
X         cmd_lineno=++e_count;
X         if (cmd_size<strlen(cmd_data->cmd)+2)
X          /*{{{  malloc new space for command*/
X          { if (cmd_buffer)
X               free(cmd_buffer);
X            cmd_size=strlen(cmd_data->cmd);
X            debug_ma("growing cmd buffer to %ld\n",(long int)cmd_size);
X            cmd_buffer=do_malloc(cmd_size);
X          }
X          /*}}}  */
X         strcpy((char*)cmd_buffer,cmd_data->cmd);
X         strcat((char*)cmd_buffer,lim);
X         cmd_data++;
X         cmd_open--;
X       }
X       /*}}}  */
X      /*{{{  overread leading gap and maybe get loop on comment or empty line*/
X      { const unsigned char *ret;
X
X        switch ((ret=white_skip(cmd_buffer))[0])
X         { case QUOTE_CHAR:
X              if (ret[1]==CMD_ADRESS && ret[2]==CMD_ADRESS)
X           case CMD_SEPARATOR:
X                 continue;
X           default:
X              return(ret);
X         }
X      }
X      /*}}}  */
X    }
X   return(0);
X }
X/*}}}  */
X/*{{{  end_cmd_read*/
Xprivate void end_cmd_read(void)
X {
X   assert(!cmd_open,"crashed ending compilation");
X   if (cmd_buffer)
X      free(cmd_buffer);
X   debug_m("end cmd_read\n");
X }
X/*}}}  */
X/*}}}  */
X
Xpublic void cmd_compiler(cmd_list_t *cmds,int used)
X { const unsigned char *buff;
X   const unsigned char *err_msg=error_no_prog;
X
X   init_cmd_read(cmds,used);
X   while ((buff=cmd_read()))
X    { static int active_group=DFLT_GROUP_ID;
X
X      debug_prog("pre compiler");
X      debug_ma("Compile: >%s<\n",buff);
X      if
X       /*{{{  group command*/
X       (    buff[0]==QUOTE_CHAR
X         && buff[1]==CMD_ADRESS
X         && (test_separator(buff[2]) || buff[2]==CMD_SEPARATOR)
X       )
X       /*}}}  */
X       /*{{{  handle group braces*/
X       { buff=white_skip(buff+2);
X         if (test_comment(buff))
X          /*{{{  stop group*/
X            if (active_group!=DFLT_GROUP_ID)
X               active_group=DFLT_GROUP_ID;
X            else
X             { err_msg=error_no_group;
X               goto error_exit;
X             }
X          /*}}}  */
X         else
X          /*{{{  start group*/
X          { unsigned char *s;
X            unsigned char c;
X
X            if (active_group!=DFLT_GROUP_ID)
X             { err_msg=error_group;
X               goto error_exit;
X             }
X            s=(unsigned char*)grp_skip(buff);
X            c=s[0];
X            *s='\0';
X            switch ((active_group=get_group(buff)))
X             { default:
X                  s[0]=c;
X                  buff=white_skip(s);
X                  if (test_comment(buff))
X                     break;
X               case POS_GROUP_ID:
X               case WRT_GROUP_ID:
X               case DFLT_GROUP_ID:
X                  err_msg=error_invalid_group;
X                  goto error_exit;
X             }
X          }
X          /*}}}  */
X       }
X       /*}}}  */
X      else
X       /*{{{  command*/
X       {
X         /*{{{  variables*/
X         struct cmd_list *p;
X         unsigned char *dest;
X         enum guard_t mode;
X         enum pos_mode_t pos_mode;
X         struct { off_t l;off_t o; } f_add;
X         struct { off_t l;unsigned char *t; } p1,p2;
X         struct act_list *actions;
X         /*}}}  */
X
X         if (buff[0]==QUOTE_CHAR && buff[1]==CMD_ADRESS)
X          /*{{{  get adress*/
X          { p1.l=0;
X            buff+=2;
X            mode=adress;
X            f_add.o=(off_t)strtol((char*)buff,(char**)&buff,0);
X            f_add.o=f_add.o+1-START_COUNT;
X            f_add.l=0;
X            if (buff[0]==CMD_REGION_LEN)
X             { buff++;
X               f_add.l=(off_t)strtol((char*)buff,(char**)&buff,0);
X             }
X            buff=white_skip(buff);
X            dest=(unsigned char*)buff;
X          }
X          /*}}}  */
X         else
X          /*{{{  scan search*/
X          { mode=pattern;
X            for (p1.l=0,dest=p1.t=(unsigned char*)buff;;)
X             { unsigned int c;
X
X               switch ((c=buff[0]))
X                { default:
X                     if (test_separator(c))
X                      { buff=white_skip(buff);
X                  case CMD_SEPARATOR:
X                        break;
X                  case QUOTE_CHAR:
X                        switch ((c= *++buff))
X                         { case QUOTE_FOR_NL:
X                              c='\n';
X                              break;
X                           case QUOTE_FOR_TAB:
X                              c='\t';
X                              break;
X                           default:
X                              if (!test_separator(c))
X                               { const unsigned char *s;
X
X                                 s=buff;
X                                 c=(unsigned int)strtol
X                                                  ( (char*)buff,
X                                                    (char**)&buff,
X                                                    0
X                                                  );
X                                 if (s==buff)
X                                    c=s[0];
X                               }
X                           case QUOTE_CHAR:
X                           case CMD_ADRESS:
X                              break;
X                         }
X                      }
X                     *dest++=c;
X                     buff++;
X                     p1.l++;
X                     continue;
X                }
X               break;
X             }
X            if (!p1.l)
X             { err_msg=error_empty_search;
X               goto error_exit;
X             }
X          }
X          /*}}}  */
X         /*{{{  scan replace*/
X         p2.l=0;
X         p2.t=dest;
X         if (buff[0]==QUOTE_CHAR && buff[1]==CMD_ADRESS)
X          /*{{{  empty replace*/
X            buff+=2;
X          /*}}}  */
X         else
X          /*{{{  scan word*/
X            for (;;)
X             { unsigned char c;
X
X               switch ((c=buff[0]))
X                { default:
X                     if (test_separator(c))
X                      {
X                  case CMD_SEPARATOR:
X                        break;
X                  case QUOTE_CHAR:
X                        switch ((c= *++buff))
X                         { case QUOTE_FOR_NL:
X                              c='\n';
X                              break;
X                           case QUOTE_FOR_TAB:
X                              c='\t';
X                              break;
X                           default:
X                              if (!test_separator(c))
X                               { const unsigned char *s;
X
X                                 s=buff;
X                                 c=(unsigned int)strtol
X                                                  ( (char*)buff,
X                                                    (char**)&buff,
X                                                    0
X                                                  );
X                                 if (s==buff)
X                                    c=s[0];
X                               }
X                           case QUOTE_CHAR:
X                           case CMD_ADRESS:
X                              break;
X                         }
X                      }
X                     *dest++=c;
X                     p2.l++;
X                     buff++;
X                     continue;
X                }
X               break;
X             }
X          /*}}}  */
X         /*}}}  */
X         /*{{{  handle groups commands*/
X         pos_mode=no_pos;
X         for (actions=0;;)
X          { int grp_mode=1;
X
X            buff=white_skip(buff);
X            switch (*buff)
X             { case QUOTE_CHAR:
X                  if (test_comment(buff))
X               case CMD_SEPARATOR:
X                     break;
X               default:
X                  err_msg=error_invalid_group;
X                  goto error_exit;
X               /*{{{  START/STOP handle the group*/
X               case CMD_STOP:
X                  grp_mode= -1;
X               case CMD_START:
X                { off_t grp_len;
X                  struct act_list *new;
X                  unsigned char *name;
X
X                  buff++;
X                  grp_len=grp_skip(buff)-buff;
X                  /*{{{  malloc and store action name*/
X                  new=do_malloc((size_t)(sizeof(struct act_list)+grp_len+1));
X                  name=(unsigned char*)((struct act_list*)new+1);
X                  memcpy(name,buff,(size_t)grp_len);
X                  name[grp_len]='\0';
X                  /*}}}  */
X                  /*{{{  check for action permission*/
X                  switch ((new->group_and_action=get_group(name)*grp_mode))
X                   { case -WRT_GROUP_ID:
X                        if (!(rp_mode&lower))
X                         { err_msg=error_stop_write;
X                           goto error_exit;
X                         }
X                        break;
X                     case POS_GROUP_ID:
X                     case -POS_GROUP_ID:
X                        if (!(rp_mode&higher))
X                         { err_msg=error_pos;
X                           goto error_exit;
X                         }
X                        pos_mode=(enum pos_mode_t)-new->group_and_action;
X                        break;
X                     default:
X                        break;
X                   }
X                  /*}}}  */
X                  /*{{{  link command to list*/
X                  new->next=actions;
X                  actions=new;
X                  /*}}}  */
X                  buff+=grp_len;
X                  continue;
X                }
X               /*}}}  */
X             }
X            break;
X          }
X         /*}}}  */
X         /*{{{  build repl command*/
X         p=do_malloc((size_t)(sizeof(struct cmd_list)+p1.l+p2.l));
X         p->group=active_group;
X         if ((p->type=mode)==pattern)
X          { p->len_search=p1.l;
X            p->guard.s=(const unsigned char*)((struct cmd_list*)p+1);
X            memcpy((char*)p->guard.s,p1.t,(size_t)p1.l);
X            p->r=p->guard.s+p1.l;
X          }
X         else
X          { p->len_search=f_add.l;
X            if (f_add.l>program.max_length)
X               program.max_length=f_add.l;
X            p->guard.add=f_add.o;
X            p->r=(const unsigned char*)((struct cmd_list*)p+1)+p1.l;
X          }
X         p->len_replace=p2.l;
X         memcpy((char*)p->r,p2.t,(size_t)p2.l);
X         p->pos_mode=pos_mode;
X         p->act_list=actions;
X         /*}}}  */
X         add_prg(p);
X       }
X       /*}}}  */
X      program.mode=(active_group==DFLT_GROUP_ID)?ok_prg:open_grp_prg;
X    }
X   end_cmd_read();
X   debug_prog("pre-checks");
X   /*{{{  check compiled program*/
X   switch (program.mode)
X    { case open_grp_prg:
X         err_msg=error_open_group;
X      case no_prg:
X         exit_m_prog(err_msg,EX_DATAERR);
X      case ok_prg:
X         if (!program.max_length)
X            program.max_length=1;
X         break;
X    }
X   /*}}}  */
X   debug_prog("post-checks!");
X   return;
X
X error_exit:
X   exit_maa_prog(err_msg,cmd_file_name,cmd_lineno,EX_DATAERR);
X }
X/*}}}  */
X/*}}}  */
END_OF_FILE
if test 24940 -ne `wc -c <'fgres/program.c'`; then
    echo shar: \"'fgres/program.c'\" unpacked with wrong size!
fi
# end of 'fgres/program.c'
fi
echo shar: End of shell archive.
exit 0
