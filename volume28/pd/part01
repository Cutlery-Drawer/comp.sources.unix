Newsgroups: comp.sources.unix
From: s.fehrman@sunbird.Central.Sun.COM (Scott Fehrman SE Northern IL)
Subject: v28i050: pd - an alternative to "ls", Part01/01
Message-id: <1.770413289.18361@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: s.fehrman@sunbird.Central.Sun.COM (Scott Fehrman SE Northern IL)
Posting-Number: Volume 28, Issue 50
Archive-Name: pd/part01

Description:   This program will read the current directory or the 
               directories listed on the command line and display the
               contents showing the "files" first then the "directories".
               This program can be used instead of "ls".

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  Makefile README pd.1 pd.c
# Wrapped by sfehrman@fire on Tue May 31 10:18:43 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(328 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Makefile for pd, Scott Fehrman
X
XCC = cc
XCFLAGS = -g
XRM = /bin/rm
XRMFLAGS = -f
XOBJS = pd.o
XINSTALLDIR = /usr/bin
XMANDIR = /usr/man
X
Xall : pd install clean
X
Xpd: $(OBJS)
X	$(CC) $(CFLAGS) $(OBJS) -o pd
X
Xinstall:
X	cp pd $(INSTALLDIR)/pd
X	cp pd.1 $(MANDIR)/man1/pd.1	
X	chmod 755 $(MANDIR)/man1/pd.1
X
Xclean:
X	$(RM) $(RMFLAGS) *.o pd
END_OF_FILE
if test 328 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(13539 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XREADME for pd
X
X  Description:   This program will read the current directory or the 
X                 directories listed on the command line and display the
X                 contents showing the "files" first then the "directories".
X                 This program can be used instead of "ls".
X
X                 The first generation (rev 1.x) used a front-end shell script 
X                 to feed the directories contants into the program. Using the 
X                 UNIX "ls" option that showed a slash character "/" after a 
X                 directory, the program would seperate files from directories. 
X                 After the data was seprated it was displayed like the Primos
X                 "LD" (Files first then Directories).
X
X                 The second generation (rev 2.x) does not rely on a front-end 
X                 shell script for input. The program uses the UNIX functions
X                 opendir() & readdir() to open and read the contants. 
X                 The stat() function is used to determine what kind of files 
X                 are in a given directory (i.e. files or sub-directories).
X
X                 The third generation (rev 3.x) was a rewrite of rev 2.10.2.
X                 This generation uses arrays of data structures instead of 
X                 individual arrays for the file name, file size, and date 
X                 modified. Dynamic Memory allocation is also used instead of
X                 static arrays. The entry qty boundry limitiation has been
X                 removed. The sorting mechanism was rewritten. Custom sort 
X                 functions were replaced with the unix qsort() function.
X
X   Installing:   Compiling this program is very easy, enter the following:
X 
X                 *** systems that use AT&T SVR3 UNIX do not support symbolic 
X                     links, the option -DSVR3 must be used on these systems
X
X                 EXL300: #cc -o pd pd.c -O -s -x -DSVR3
X                 Mips:   #cc -o pd pd.c -O3 -s -x pd.c
X                 Sun3-4: #cc -o pd pd.c -O3
X                 Ultrix: #cc -o pd pd.c -O3
X
X                 copy the "pd" program to a directory that is in the users
X                 search path. If you want the output of "pd" to stop at each
X                 screen full of data, pipe "|" the output into the "more"
X                 (or "pg -e" for System V users) command. There currently is
X                 a utility named "ld" on standard unix machines. To use "pd"
X                 as a true "LD" command create the following alias and place
X                 it in your ".cshrc" file: 
X                     # alias ld "pd \!* | more"
X                 The "csh" process will use the "alias" before the "ld" linker
X                 utility. For the System V users, create a script as follows:
X                     #! /bin/sh
X                     pd $* | pg -e
X                 Place the new "ld" script in a search directory other that the
X                 one where the "ld" linker program is. To use the "ld" script
X                 change your PATH variable to search your local programs before
X                 the standard directories. (i.e. /usr/local/bin:/bin:/usr/bin)
X
X      Systems:   Sun Microsystems, Inc.            OS: SunOS {4.x, 5.x}
X                 Prime Computer, exl300            OS: System V Rel 3.1
X                 Prime Computer, exl7000 (MIPS)    OS: RISC/os 4.52
X                 Digital Equip. Corp. (DECStation) OS: Ultrix 4.2A
X                 IBM Corp. (RS/6000)               OS: AIX 3.2
X
X      History:   ( rev / by / date / description )
X  
X                 rev number = (major_release . minor_release . fix_release)
X                 fix_release = 0 then "beta release"
X
X                 3.3.1  slf  01/19/93  release version 3.3:(see list above)
X                                       all platforms defined by "Systems:"
X                 3.3.0  slf  12/18/92  (beta) new feature(s):
X                                       * opt: "-nd | -no_dot" hides dot files
X                                       * if using ENV options show ":" not "." 
X                                         after entry, file, dir quantities
X                 3.2.3  slf  10/14/92  changed version banner
X                                       documented all functions
X                 3.2.2  slf  09/04/92  fixed alt output w/ all name len < 4
X                                       re-wrote comments/documentation
X                 3.2.1  slf  07/14/92  release version 3.2 :(see list above)
X                                       all platforms defined by "Systems:"
X                 3.2.0  slf  06/17/92  (beta) new features:
X                                       * new option: -lc | -link_cnt
X                                         show file link count
X                 3.1.1  slf  05/21/92  release version 3.1 on:
X                                       sun3, sun4, exl300, mips(exl7000)
X                 3.1.0  slf  05/18/92  (beta) new features:
X                                       * show major / minor if special file
X                                       * show suid & sgid if set: x=S
X                 3.0.2  slf  04/29/92  sort_name() was sort_default()
X                                       don't read array backwards for reverse
X                                       have qsort() do reverse sort
X                                       new funcs: sort_rev_*
X                 3.0.1  slf  04/21/92  release version 3.0 on:
X                                       sun3, sun4, exl300, mips (exl7000)
X                 3.0.0  slf  03/20/92  (beta) rewrite internal data management
X                                       * use struct instead of name,size,date
X                                       * use pointer arrays for performance
X                                       * dynamically allocate memory instead
X                                         of large static arrays.
X                                       * removed check_array function "n/a"
X                                       * use qsort() instead of own functions
X                                       * removed #ifdef DEBUG, using "dbx"
X                                       * program checked with "lint"
X                2.10.2  slf  03/13/92  when using cmd line wildcards "*" and
X                                       -f or -d switch only show files or dirs
X                2.10.1  slf  03/12/92  release version 2.10 on:
X                                       sun3, sun4, exl300, mips (exl7000)
X                2.10.0  slf  02/07/92  (beta) new option "-nh"
X                                       don't show header for extended output
X                                       "-b | -brief" = "-nh -np -nq"
X                                       use proper exit value:
X                                       exit 0 if ok, else exit > 0
X                 2.9.3  slf  01/28/92  changed "expanded" output header
X                                       User was Owner & Other was World
X                 2.9.2  slf  01/16/92  fixed major perf. problem w/alt sorts
X                                       created arrays for date & size
X                                       now reads date & size along with name
X                                       changed sort func. for new technique
X                 2.9.1  slf  01/14/92  release version 2.9 on:
X                                       sun3, sun4, EXL300, MIPS (EXL7000)
X                 2.9.0  slf  01/02/92  (beta) new reverse sort technique 
X                                       print array backwards if "-r" option
X                                       new option "-sm" or "-sort_dtm"
X                                       sort by date/time modified
X                                       new option "-ss" or "-sort_size"
X                                       sort by size
X                                       sort_default() was sort_directory()
X                 2.8.2  slf  12/31/91  re-support EXL300 (SVR3) compile option
X                                       expanded internal notation.
X                 2.8.1  slf  12/27/91  release 2.8 version:
X                                       sun3, sun4, EXL7000
X                 2.8.0  slf  12/19/91  (beta) option to display "inode #"
X                                       "-i" or "-inode"
X                 2.7.4  slf  12/18/91  changed all DEBUG's to use #ifdef
X                                       debug if compiled with "-DDEBUG" option
X                 2.7.3  slf  10/23/91  changed ">" to ">=" in check_array
X                                       halted when qty files = MAX_FILE+1
X                 2.7.2  slf  09/30/91  changed "Other" to "World" in protection
X                                       used by the expanded output format
X                 2.7.1  slf  09/24/91  released 2.7 version:
X                                       Sun3, Sun4, EXL7000
X                 2.7.0  slf  09/17/91  (beta) handle invalid links
X                                       display link as a file, "?" before name
X                                       and the word "Broken Link" if expanded
X                 2.6.2  slf  09/17/91  skip invalid links, don't abort ...
X                                       display error, then continue processing
X                 2.6.1  slf  08/27/91  released 2.6 version:
X                                       Sun3, Sun4, EXL7000
X                 2.6.0  slf  08/23/91  (beta) new options: ( -l | -link )
X                                       show what symbolic links point to
X                                       global variable ENV_NAME options support
X                                       dropped support for EXL300
X                                       changed program name from "pld" to "pd"
X                 2.5.1  slf  08/07/91  released 2.5 version: 
X                                       Sun3, Sun4, Exl300, Exl7000
X                                       expanded copyright notice
X                 2.5.0  slf  08/06/91  (beta) new command line processor
X                                       seperate files from directories
X                 2.4.1  slf  08/02/91  released 2.4 version:
X                                       Sun3, Sun4, Exl300, Exl7000
X                 2.4.0  slf  08/01/91  (beta) new ver stamp & new features: 
X                                       support file only listings (no error)
X                                       option "-w | -wide" 132 column format
X                 2.3.4  slf  07/16/91  added program notes, document code,
X                 2.3.3  slf  07/05/91  option to show count only "-c | -count"
X                 2.3.2  slf  07/03/91  option to show "." & ".." files
X                 2.3.1  slf  07/03/91  released SunOS 4.x, EXL300
X                 2.3.0  slf  07/02/91  new features: size, owner.group,
X                                       protection data "rwx" (beta)
X                 2.2.1  slf  07/01/91  released:
X                                       sun3, sun4, EXL300, EXL7000
X                 2.2.0  slf  07/01/91  new features: date/time options (beta)
X                                       accessed, modified, status changed 
X                 2.1.6  slf  06/28/91  added extra options (f,d)
X                                       added new output (single column "sc")
X                 2.1.5  slf  06/27/91  fixed reverse sort for files
X                 2.1.4  slf  06/18/91  added "-r | -reverse" reverse sort
X                 2.1.3  slf  06/17/91  was not sorting data properly
X                                       added "-ns | -no_sort" for debug
X                                       changed setting of "iSwap" flag
X                 2.1.2  slf  06/11/91  "swap" use memcpy() instead of strcpy()
X                                       proper display with "-nq -np" options
X                                       fix sort for directories (didn't sort)
X                 2.1.1  slf  06/10/91  released: Sun3, Sun4, EXL300, EXL7000
X                                       array, MAX_FILE was 500 now 1500
X                                       check for array out of bounds
X                 2.1.0  slf  06/10/91  new features ( beta test ) 
X                                       changed option characters to words
X                                       use getcwd() instead of system("pwd")
X                                       move header into display_directory()
X                 2.0.1  slf  06/07/91  released: 
X                                       Sun3, Sun4, EXL300, EXL7000
X                 2.0.0  slf  06/06/91  totally rewritten ( beta test )
X                                       use opendir() & readdir()
X                                       use stat() to determine entry type
X                 1.5.0  slf  04/09/91  cleaned code, changed char array size
X                                       better technique
X                 1.4.0  slf  01/28/91  diff. "printf" if only 1 item found
X                                       empty dir: "No entries selected."
X                 1.3.0  slf  01/23/91  added source code documentation
X                                       removed "pd rev" banner
X                 1.2.0  slf  01/23/91  added strcmp() to check for "." & ".."
X                                       changed <strings.h> to <string.h>
X                 1.1.0  slf  01/23/91  Modified to check for "." and ".."
X                                       Initial code did not work on EXL
X                 1.0.0  slf  01/22/91  Initial coding ( beta test )
X                                       tested on: Sun3, Sun4
X
END_OF_FILE
if test 13539 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'pd.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pd.1'\"
else
echo shar: Extracting \"'pd.1'\" \(5543 characters\)
sed "s/^X//" >'pd.1' <<'END_OF_FILE'
X.\" @(#)pd.1v 3.2.1 92/07/14; from Sun Microsystems, Inc
X.TH PD 1 "19 January 1993"
X.SH NAME
X.B pd 
X\- print directory, seperates the "files" from the "sub-directories", a substitute for "ls".
X.SH SYNOPSIS
X.B pd
X[
X.B \-<options>
X]
X.I dirname(s) | filename(s)
X\&.\|.\|.
X.SH DESCRIPTION
XFor each
X.I dirname, 
X.B pd
Xlists the contents of the directory; for each 
X.I filename, 
X.B pd
Xrepeats its name and any other information requested. By default, the output
Xis sorted alphabetically. When no
X.I dirname
Xor 
X.I filename
Xis given, the current directory is listed.  When several
X.I dirnames
Xor
X.I filenames
Xare given, the files are shown first then the directories are shown in the 
Xorder as they appear on the command-line. Each directory will be displayed in
Xtwo parts: Files will be shown first then any sub-directories will be shown.
X.LP
X.B pd
Xuses two different output formats: 
X.I normal & extended. 
XThe 
X.I normal
Xoutput displays the entries
Xusing multiple columns. The 
X.I extended
Xoutput displays each entry on a line of its own. The
X.I extended
Xoutput format is used by the following options: -i -p, -s, -lc, -sm, -ss, -det,
X-dta, -dtm, -dts.
X.LP
XIf an option is going to be used on a regular basis, set an environment variable call "PD" equal
Xto the option(s) that are to be used.
X.LP
X.SH OPTIONS
XMore than one option can be used on the command-line by seperating each option with a
Xspace. Each option
X.I must
Xhave it's own dash (\-) character.
X.LP
X.TP
X.B \-a
XList all entries; include the entries 
X.RB ` . '
Xand
X.RB ` .. '
X(by default, these two entries are
X.I not
Xshown). alias:
X.B \-all
X.TP
X.B \-b
XSuppress extraneous information and remove all blank lines, only directory and
Xfile data will be displayed. alias:
X.B \-brief
X.TP
X.B \-c
XShow only the entry counts. alias:
X.B \-count
X.TP
X.B \-d
XList only the entries that are sub-directories of the selected directory. alias:
X.B \-dir
X.TP
X.B \-f
XList only the entries that are files in the selected directory. alias:
X.B \-file
X.TP
X.B \-h
XDisplay the help summary for the
X.B pd
Xprogram. alias:
X.B \-help
X.TP
X.B \-i
XShow the UNIX inode file number. This option uses the extended output
Xformat. alias:
X.B -inode
X.TP
X.B \-l
XShow the symbolic link status, NOT the status of what the link is pointing to. 
XThis option only applies when used with another option that uses the extended
Xoutput format.
X.B NOTICE: 
XThis option is NOT available on System V Release 3 UNIX systems. alias:
X.B \-link
X.TP
X.B \-p
XDisplay the protection/access and ownership of the files and sub-directories in the
Xselected directory. This option displays the entries in a single column format.
XNote: If the "SUID" or "SGID" bit is set, an "S" will be shown in the execute 
Xcolumn of the protection data. alias:
X.B \-pro
X.TP
X.B \-r
XUse a reverse sort for the files and sub-directories in the selected directory.
XThis option will also reverse sort by date modified and by file size when used
Xalong with those options. alias:
X.B \-reverse
X.TP
X.B \-s
XDisplay the file size (bytes) of the files and sub-directories. Note: The size shown
Xfor directories is 
X.I not
Xthe size of the data within a directory, it's the size of the directory file.
XNote: If an entry is either a Character or Block Special file, then the major
Xand minor unit numbers will be shown. alias:
X.B \-size
X.TP
X.B \-v
XDisplay the version stamp for the 
X.B pd
Xprogram. alias:
X.B \-version
X.TP
X.B \-w
XDisplay the output in a 132 column format. alias:
X.B \-wide
X.TP
X.B \-lc
XDisplay the link count for each file. alias:
X.B \-link_count
X.TP
X.B \-nd
XDon't show any files/dirs that start with a dot (.). Notice: this option is
Xoveriden with the "-a" or "-all" option. alias:
X.B \-no_dot
X.TP
X.B \-nh
XDon't show header information when the extended output format is used. alias:
X.B \-no_hdr
X.TP
X.B \-np
XDon't show the pathname of the selected directory. alias:
X.B \-no_pwd
X.TP
X.B \-nq
XDon't show the quantites for the selected directory (i.e. total entries, files, 
Xsub-directories). alias:
X.B \-no_qty
X.TP
X.B \-ns
XDon't sort the entries in the selected directory. alias:
X.B \-no_sort
X.TP
X.B \-sc
XForce the output to be displayed in a single column. alias:
X.B \-sglcol
X.TP
X.B \-sm
XSort files and sub-directories by the date they were was last modified. This 
Xoption uses the extended output format. alias:
X.B \-sort_dtm
X.TP
X.B \-ss
XSort files and sub-directories by the size of the file. This option uses the
Xextended output format. alias:
X.B \-sort_size
X.TP
X.B \-det
XShow detailed date information for the entries in the selected directory. This
Xoption uses the
X.B \-dta \-dtm \-dts
Xoptions. alias:
X.B \-detail
X.TP
X.B \-dta
XShow the date/time accessed information for the entries in the selected directory.
Xalias:
X.B \-accessed
X.TP
X.B \-dtm
XShow the date/time modified information for the entries in the selected 
Xdirectory. alias:
X.B \-modified
X.TP
X.B \-dts
XShow the date/time status changed for the entries in the seleted directory. 
Xalias:
X.B \-status
X.SH FILES
X.PD 0
X.TP 20
X.B /etc/passwd
Xto get user
X.SM ID\s0's
Xfor
X.RB ` "pd \-p" '
X.TP
X.B /etc/group
Xto get group
X.SM ID\s0
Xfor
X.RB ` "pd \-p" '
X.SH NOTES
X.LP
XIf a directory contains a 
X.I "Symbolic Link"
Xthat refers to a file or directory which does not exist, 
X.B "pd"
Xwill list the 
Xlink as a file when the normal output format is used. When the extended format
Xoutput is used, the link will be listed as a file along with the error message: 
X.B "(Broken Link) destination doesn't exist".
XTo see the status about the link, use the "-l" option.
X.SH BUGS
X.LP
XNone are known at the release version of 3.3.1
END_OF_FILE
if test 5543 -ne `wc -c <'pd.1'`; then
    echo shar: \"'pd.1'\" unpacked with wrong size!
fi
chmod +x 'pd.1'
# end of 'pd.1'
fi
if test -f 'pd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pd.c'\"
else
echo shar: Extracting \"'pd.c'\" \(50008 characters\)
sed "s/^X//" >'pd.c' <<'END_OF_FILE'
X/**************************************************************************
X
X N O T I C E :   Copyright 1991,1992,1993 (c) Scott Fehrman
X                 
X                 This program and it's related documents may be distributed
X                 and/or copied without charge. The related source code and 
X                 executable files may be used freely providing that all 
X                 copyright notices and information about the author and 
X                 company are not removed or altered in any manner. The users
X                 of this program and it's related documents understand that 
X                 this material is provided "as is" with no warranty. The 
X                 author and/or company are not responsible for any 
X                 "side effects" and/or problems that this material may have
X                 on system and/or application files and data. The use of this
X                 program and it's related material implies that the user 
X                 understands the terms and conditions for which it is provided.
X
X      Program:   pd.c
X
X       Author:   Scott L. Fehrman, Systems Engineer
X                 Sun Microsystems Computer Corporation
X                 Two Pierce Place
X                 Suite 1500
X                 Itasca, IL 60173
X                 (708) 285-7632
X                 scott.fehrman@Central.Sun.COM
X
X***************************************************************************/
X
X/*** include system header files ***/
X
X#include <stdio.h>                /* standard unix input/output facilities */
X#include <time.h>                 /* file date/time data */
X#include <sys/types.h>            /* system types used by <sys/stat.h> */
X#include <sys/param.h>            /* machine dependant paramters */
X#include <dirent.h>               /* directory entry information */
X#include <sys/stat.h>             /* status information about files */
X#include <malloc.h>               /* dyn memory allocation */
X#include <errno.h>                /* error handling */
X#include <pwd.h>                  /* passwd file data */
X#include <grp.h>                  /* group file data */
X
X/*** define constant variables ***/
X
X#define       VERSION  "3.3.1"    /* program revision stamp */
X#define  MAX_NAME_LEN  60         /* max character length of a file name */
X#define MAX_ERROR_LEN  60         /* max character length of error mess */
X#define  SCREEN_WIDTH  80         /* number of characters on screen, max */
X#define          TRUE  1          /* define the TRUE value */ 
X#define         FALSE  0          /* define the FALSE value */
X#define     NUM_BLANK  2          /* blank characters between columns */
X#define      ENV_NAME  "PD"       /* environment variable options */
X#define    ENTRY_FILE  0         
X#define     ENTRY_DIR  1
X#define       CMD_DIR  2 
X
X/*** define macros if needed ***/
X
X#ifndef S_ISDIR
X#define    S_ISDIR(m)  (((m)&S_IFMT) == S_IFDIR) /* is a directory */
X#endif
X
X#ifndef SVR3
X#ifndef S_ISLNK
X#define    S_ISLNK(m)  (((m)&S_IFMT) == S_IFLNK) /* is symbolic link */
X#endif
X#endif
X
X#ifndef S_ISBLK
X#define    S_ISBLK(m)  (((m)&S_IFMT) == S_IFBLK) /* is block device */
X#endif
X
X#ifndef S_ISCHR
X#define    S_ISCHR(m)  (((m)&S_IFMT) == S_IFCHR) /* is char device */
X#endif
X
X#ifndef major
X#define major(dev) (((dev) >> 8) & 0xff)         /* device major # */
X#endif
X
X#ifndef minor
X#define minor(dev) ((dev) & 0xff)                /* device minor # */
X#endif
X
X/*** function prototypes ***/
X
Xint  open_directory();            /* open the directory */
Xint  sort_name();                 /* func for qsort() by file name, default */
Xint  sort_date_modified();        /* func for qsort() by date modified */
Xint  sort_size();                 /* func for qsort() by file size */
Xint  sort_rev_name();             /* func for qsort() by file name, reverse */
Xint  sort_rev_date_modified();    /* func for qsort() by date modified, rev */
Xint  sort_rev_size();             /* func for qsort() by file size, rev */
Xvoid entry_store();               /* store entry in ptr array */
Xvoid entry_release();             /* release allocated memory for arrays */
Xvoid process_cmd_dir();           /* process the dirs on command line */
Xvoid process_cmd_file();          /* process the files on command line */
Xvoid command_option();            /* command line option */
Xvoid process_directory();         /* process the opened directory */
Xvoid display_header();            /* print header data (pathname) */
Xvoid read_directory();            /* read the files in the open directory */
Xvoid close_directory();           /* close the directory */
Xvoid display_directory();         /* display directory as "n" columns */
Xvoid display_expanded();          /* display entry in expanded format */
Xvoid getenv_option();             /* get any environment options */
Xvoid stat_file();                 /* get file status from argument */
Xvoid align_column();              /* align output to a specific column */
Xvoid repeat_char();               /* repeat a character # of times */
Xvoid program_usage();             /* if error, how to use program */
Xvoid program_help();              /* help with this program */
Xvoid program_version();           /* display version stamp */
X
X/*** declare variables ***/
X
Xtypedef struct EntryTag {                     /* struct for entries */
X              char szName[MAX_NAME_LEN];      /* entry name */
X              int  iSize;                     /* entry size */
X              int  iMod;                      /* entry date modified */
X              } EntryData;
X
Xextern char   *getenv();                      /* ptr to external string */
X
XEntryData     *File,                          /* ptr to array, files */
X              *Dir,                           /* ptr to array, directories */
X              *Cmd;                           /* ptr to array, cmd line dirs */
X
Xchar          *szProgName,                    /* program name argv[0] */
X              szDirName[MAX_NAME_LEN],        /* dir name argv[0+x] */
X              cQtyChar = '.';                 /* qty terminating char */
X
Xint           iAllocFile = 100,               /* # files to alloc memory */
X              iAllocDir = 100,                /* # dirs to alloc memory */
X              iAllocCmd = 100,                /* # cmd dirs to alloc memory */
X              iReturn,                        /* Return value */
X              iCmdFiles = 0,                  /* qty cmd line files */
X              iCmdDirs = 0,                   /* qty cmd line dirs */
X              iRemoteDir = FALSE,             /* is remote directory */
X              iNumFiles,                      /* counter # files */
X              iNumDirs,                       /* counter # dirs */
X              iNumEntries = 0,                /* counter total entries */
X              iLongest,                       /* length of longest name */
X              iNumColumns,                    /* # of columns to display */
X              iScrWidth = SCREEN_WIDTH,       /* Screen width # columns */
X              iSortOptions = 0,               /* qty of sort options */
X              iFlagAbort = FALSE,             /* flag, do not run -h, -v */
X              iFlagAccessed = FALSE,          /* flag, date/time accessed */
X              iFlagAltOutput = FALSE,         /* flag, alternate output */
X              iFlagBrief = FALSE,             /* flag, brief output */
X              iFlagCount = FALSE,             /* flag, count entries only */
X              iFlagDirs = TRUE,               /* flag, show files */
X              iFlagDot = TRUE,                /* flag, show files start with .*/
X              iFlagFiles = TRUE,              /* flag, show directories */
X              iFlagHidden = FALSE,            /* flag, show "." & ".." */
X              iFlagHeader = TRUE,             /* flag, show header extn dis */
X              iFlagInode = FALSE,             /* flag, show file inode # */
X              iFlagLink = FALSE,              /* flag, show link status */
X              iFlagLinkCnt = FALSE,           /* flag, show file link count */
X              iFlagModified = FALSE,          /* flag, date/time modified */
X              iFlagPath = TRUE,               /* flag, show pathname */
X              iFlagPro = FALSE,               /* flag, protection data */
X              iFlagQty = TRUE,                /* flag, show qty of entries */
X              iFlagReverse = FALSE,           /* flag, reverse sort */
X              iFlagSingle = FALSE,            /* flag, single column */
X              iFlagSize = FALSE,              /* flag, size & owner data */
X              iFlagSort = TRUE,               /* flag, sort files -ns */
X              iFlagSortModified = FALSE,      /* flag, sort date modified */
X              iFlagSortSize = FALSE,          /* flag, sort file size */
X              iFlagStatus = FALSE,            /* flag, date/time stat mod */
X              iFlagWide = FALSE,              /* flag, wide format 132 col */
X              iFilesOnly = FALSE;             /* flag, cmd line, files only */
X
XDIR           *dirp;                          /* ptr to dir struct DIR */
Xstruct dirent *filep;                         /* ptr to file struct dirent */
Xstruct stat   stb;                            /* ptr to file status struct */
Xstruct tm     *tmp;                           /* ptr to time/date struct */
Xstruct passwd *passwdp;                       /* ptr to passwd struct */
Xstruct group  *groupp;                        /* ptr to group struct */
X
X/**********************************************************************/
Xint main(argc, argv)
X/**********************************************************************
X
Xmain function: "returns an integer"
X
X   * check the environment varaible for any program options.
X   * allocate an inital amount of memory for storing entries
X   * parse the command line: ( we don't care about the order ) 
X   * seperate the file/dir names from the options, 
X   * for each file, store name in file array
X   * for each directory, store name in directory array
X   * if no "command-line" files or dirs, add the current dir "." to array
X   * if files found, call function to process them
X   * if directories found, call function to process them
X
X**********************************************************************/
Xint   argc; 
Xchar *argv[];
X{
X   register int  t;
X   int           iTemp;
X   char          szError[MAX_ERROR_LEN], 
X                 szOption[MAX_NAME_LEN];
X
X   iReturn = 0;
X   szProgName = argv[0];
X   getenv_option();
X
X   File = (EntryData *)malloc((unsigned int)(sizeof(EntryData)*iAllocFile));
X   Dir  = (EntryData *)malloc((unsigned int)(sizeof(EntryData)*iAllocDir));
X   Cmd  = (EntryData *)malloc((unsigned int)(sizeof(EntryData)*iAllocCmd));
X
X   if ( !File || !Dir || !Cmd ) {
X      (void)sprintf(szError,"%s: malloc()",szProgName);
X      perror(szError);
X      exit(TRUE);
X   }
X
X   for ( t=1 ; t<argc ; t++ ) {
X      if ( argv[t][0] == '-' ) {
X         (void)strcpy(szOption,++argv[t]);
X         command_option(szOption);
X      }
X      else {
X         iRemoteDir = TRUE;
X         if ( !iFlagAbort ) {
X            if ( stat(argv[t], &stb) < 0 ) {                 /* valid file */
X#ifdef SVR3
X               iFlagAbort = TRUE;
X               iReturn = TRUE;
X               (void)sprintf(szError,"%s: %s",szProgName,argv[t]);
X               perror(szError);
X#else
X               if ( lstat(argv[t], &stb) < 0 ) {           /* maybe a link */
X                  iFlagAbort = TRUE;
X                  iReturn = TRUE;
X                  (void)sprintf(szError,"%s: %s",szProgName,argv[t]);
X                  perror(szError);
X               }
X               else {
X                  entry_store(ENTRY_FILE,argv[t],
X                     (int)stb.st_mtime,(int)stb.st_size,iCmdFiles++);
X               }
X#endif
X            }
X            else {                                           /* valid entry */
X               if ( S_ISDIR(stb.st_mode) ) {                   /* directory */
X                  entry_store(CMD_DIR,argv[t],0,0,iCmdDirs++);
X               }
X               else {                                               /* file */
X                  iTemp = strlen(argv[t]);
X                  if ( iTemp > iLongest ) iLongest = iTemp;
X                  entry_store(ENTRY_FILE,argv[t],
X                     (int)stb.st_mtime,(int)stb.st_size,iCmdFiles++);
X               }
X            }
X         }
X      }
X   }
X   if ( !iCmdFiles && !iCmdDirs ) {
X      entry_store(CMD_DIR,".",0,0,iCmdDirs++);
X   }
X   if ( !iFlagAbort ) {
X      if ( iCmdFiles && iFlagFiles ) 
X         process_cmd_file(iCmdFiles);
X      if ( iCmdDirs ) {
X         process_cmd_dir(iCmdDirs);
X         entry_release(CMD_DIR);
X      }
X      entry_release(ENTRY_FILE);
X      entry_release(ENTRY_DIR);
X   }
X   return(iReturn);
X}
X
X/**********************************************************************/
Xvoid entry_store(iType,pszName,iMod,iSize,iCount)
X/**********************************************************************
X
Xentry store function: "returns nothing"
X
X   * receives a pointer to entry name, type, modify date, size, and count
X   * places data into proper pointer array depending on the type
X   * each array is checked for memory overflow
X   * if overflow, then realloc() is called to double memory size
X
X**********************************************************************/
Xchar *pszName;
Xint   iType,
X      iMod,
X      iSize,
X      iCount;
X{
X   char szError[MAX_ERROR_LEN];
X   switch ( iType ) {
X      case CMD_DIR:
X         if ( iCount == iAllocCmd ) {
X            iAllocCmd *= 2;
X            Cmd = (EntryData *)realloc(
X                  (char *)Cmd,
X                  (unsigned int)(sizeof(EntryData)*iAllocCmd));
X            if ( !Cmd ) {
X               (void)sprintf(szError,"%s: realloc()",szProgName);
X               perror(szError);
X               exit(1);
X            }
X         }
X         (void)strcpy(Cmd[iCount].szName,pszName);
X         break;
X      case ENTRY_FILE:
X         if ( iCount == iAllocFile ) {
X            iAllocFile *= 2;
X            File = (EntryData *)realloc(
X                   (char *)File,
X                   (unsigned int)(sizeof(EntryData)*iAllocFile));
X            if ( !File ) {
X               (void)sprintf(szError,"%s: realloc()",szProgName);
X               perror(szError);
X               exit(1);
X            }
X         }
X         (void)strcpy(File[iCount].szName,pszName);
X         File[iCount].iMod = iMod;
X         File[iCount].iSize = iSize;
X         break;
X      case ENTRY_DIR:
X         if ( iCount == iAllocDir ) {
X            iAllocDir *= 2;
X            Dir = (EntryData *)realloc(
X                  (char *)Dir,
X                  (unsigned int)(sizeof(EntryData)*iAllocDir));
X            if ( !Dir ) {
X               (void)sprintf(szError,"%s: realloc()",szProgName);
X               perror(szError);
X               exit(1);
X            }
X         }
X         (void)strcpy(Dir[iCount].szName,pszName);
X         Dir[iCount].iMod = iMod;
X         Dir[iCount].iSize = iSize;
X         break;
X   }
X   return;
X}
X
X/**********************************************************************/
Xvoid entry_release(iType)
X/**********************************************************************
X
Xentry release function: "returns nothing"
X
X   * receives an entry type
X   * releases the allocated memory for the given type
X
X**********************************************************************/
Xint iType;
X{
X   switch ( iType ) {
X      case CMD_DIR:
X         (void)free((char *)Cmd);
X         break;
X      case ENTRY_FILE:
X         (void)free((char *)File);
X         break;
X      case ENTRY_DIR:
X         (void)free((char *)Dir);
X         break;
X   }
X   return;
X}
X
X/**********************************************************************/
Xvoid process_cmd_dir(iDir)
X/**********************************************************************
X
Xprocess command-line directory: "returns nothing"
X
X* reads each directory name in the pointer array
X* for each name, the directory is opened then processed
X
X**********************************************************************/
Xint iDir;
X{
X   register int i;
X   for ( i=0 ; i<iDir ; i++ ) {
X      szDirName[0] = '\0';
X      (void)strcpy(szDirName,Cmd[i].szName);
X      if ( open_directory() ) process_directory();
X   }
X   return;
X}
X
X/**********************************************************************/
Xvoid process_cmd_file(iFile)
X/**********************************************************************
X
Xprocess command-line file: "returns nothing"
X
X* the files in the pointer array are sorted depending on the options
X* the display_directory function is called
X
X**********************************************************************/
Xint iFile;
X{
X   int iTemp;
X   iNumFiles = iFile;
X   iNumEntries = iFile;
X   iNumDirs = 0;
X   iNumColumns = iScrWidth / ( iLongest+NUM_BLANK );
X   if ( iFlagSingle ) iNumColumns = 1;
X   szDirName[0] = '\0';
X   if ( iNumFiles ) {
X      if ( iFlagSort && iNumFiles > 1 ) {
X         if ( iFlagReverse ) 
X            qsort((char *)File,iNumFiles,sizeof(EntryData),sort_rev_name);
X         else 
X            qsort((char *)File,iNumFiles,sizeof(EntryData),sort_name);
X      }
X      else if ( iFlagSortModified && iNumFiles > 1 ) {
X         qsort((char *)File,iNumFiles,sizeof(EntryData),sort_name);
X         if ( iFlagReverse )
X            qsort((char *)File,iNumFiles,sizeof(EntryData),
X               sort_rev_date_modified);
X         else 
X            qsort((char *)File,iNumFiles,sizeof(EntryData),
X               sort_date_modified);
X      }
X      else if ( iFlagSortSize && iNumFiles > 1 ) {
X         qsort((char *)File,iNumFiles,sizeof(EntryData),sort_name);
X         if ( iFlagReverse )
X            qsort((char *)File,iNumFiles,sizeof(EntryData),sort_rev_size);
X         else
X            qsort((char *)File,iNumFiles,sizeof(EntryData),sort_size);
X      }
X      iTemp = iFlagPath;
X      iFlagPath = FALSE;
X      iFilesOnly = TRUE;
X      display_directory();
X      iFlagPath = iTemp;
X      iFilesOnly = FALSE;
X   }
X   return;
X}
X
X/**********************************************************************/
Xvoid getenv_option()
X/**********************************************************************
X
Xget environment options: "returns nothing"
X
X* calls the getenv() system function
X* the character array is parsed for multiple options
X* for each option, the command_option() pd function is called
X* set the qty terminating character if ENV options are used
X
X**********************************************************************/
X{
X   register int i, j;
X   int          iChar;
X   char        *szEnv = getenv(ENV_NAME),
X                szOption[MAX_NAME_LEN];
X   if ( szEnv != NULL ) {
X      cQtyChar = ':';
X      if ( (iChar = strlen(szEnv)) ) {
X         szOption[0] = '\0';
X         j=0;
X         for ( i=0 ; i<iChar ; i++ ) {
X            if ( szEnv[i] == ' ' ) {
X               if ( strlen(szOption) ) {
X                  szOption[j] = '\0';
X                  command_option(szOption);
X                  szOption[0] = '\0';
X                  j=0;
X               }
X            }
X            else if ( szEnv[i] != '-' ) szOption[j++] = szEnv[i];
X         }
X         if ( strlen(szOption) ) {
X            szOption[j] = '\0';
X            command_option(szOption);
X         }
X      }
X   }
X   return;
X}
X
X/**********************************************************************/
Xvoid command_option(szOption)
X/**********************************************************************
X
Xcommand-line options: "returns nothing"
X
X* receives an option string (character array)
X* checks for a valid option name
X* if valid option then various flags are set
X
X**********************************************************************/
Xchar *szOption;
X{
X   if ( !strcmp(szOption,"h") || !strcmp(szOption,"help") ){
X      program_help();
X      iFlagAbort = TRUE;
X   }
X   else if ( !strcmp(szOption,"a") || !strcmp(szOption,"all") ){
X      iFlagHidden = TRUE;
X      iFlagDot = TRUE;
X   }
X   else if ( !strcmp(szOption,"b") || !strcmp(szOption,"brief") ){
X      iFlagBrief = TRUE;
X      iFlagHeader = FALSE;
X      iFlagPath = FALSE;
X      iFlagQty = FALSE;
X   }
X   else if ( !strcmp(szOption,"c") || !strcmp(szOption,"count")){
X      iFlagCount = TRUE;
X      iFlagSort = FALSE;
X   }
X   else if ( !strcmp(szOption,"d") || !strcmp(szOption,"dir") ){
X      iFlagFiles = FALSE;
X   }
X   else if ( !strcmp(szOption,"f") || !strcmp(szOption,"file") ){
X      iFlagDirs = FALSE;
X   }
X   else if ( !strcmp(szOption,"r") || !strcmp(szOption,"reverse")){
X      iFlagReverse = TRUE;
X   }
X   else if ( !strcmp(szOption,"v") || !strcmp(szOption,"version") ){
X      program_version();
X      iFlagAbort = TRUE;
X   }
X   else if ( !strcmp(szOption,"lc") || !strcmp(szOption,"link_cnt") ){
X      iFlagAltOutput = TRUE;
X      iFlagLinkCnt = TRUE;
X   }
X   else if ( !strcmp(szOption,"nd") || !strcmp(szOption,"no_dot") ){
X      if ( !iFlagHidden ) iFlagDot = FALSE;
X   }
X   else if ( !strcmp(szOption,"nh") || !strcmp(szOption,"no_hdr") ){
X      iFlagHeader = FALSE;
X   }
X   else if ( !strcmp(szOption,"np") || !strcmp(szOption,"no_pwd") ){
X      iFlagPath = FALSE;
X   }
X   else if ( !strcmp(szOption,"nq") || !strcmp(szOption,"no_qty") ){
X      iFlagQty = FALSE;
X   }
X   else if ( !strcmp(szOption,"ns") || !strcmp(szOption,"no_sort") ){
X      iFlagSort = FALSE;
X   }
X   else if ( !strcmp(szOption,"sc") || !strcmp(szOption,"sglcol")) {
X      iFlagSingle = TRUE;
X   }
X   else if ( !strcmp(szOption,"sm") || !strcmp(szOption,"sort_dtm")) {
X      iFlagSortModified = TRUE;
X      iFlagAltOutput = TRUE;
X      iFlagModified = TRUE;
X      iFlagSort = FALSE;
X      iSortOptions++;
X   }
X   else if ( !strcmp(szOption,"ss") || !strcmp(szOption,"sort_size")) {
X      iFlagSortSize = TRUE;
X      iFlagAltOutput = TRUE;
X      iFlagSize = TRUE;
X      iFlagSort = FALSE;
X      iSortOptions++;
X   }
X   else if ( !strcmp(szOption,"dta") || !strcmp(szOption,"accessed")){
X      iFlagAltOutput = TRUE;
X      iFlagAccessed = TRUE;
X   }
X   else if ( !strcmp(szOption,"dtm") || !strcmp(szOption,"modified")){
X      iFlagAltOutput = TRUE;
X      iFlagModified = TRUE;
X   }
X   else if ( !strcmp(szOption,"dts") || !strcmp(szOption,"status")){
X      iFlagAltOutput = TRUE;
X      iFlagStatus = TRUE;
X   }
X   else if ( !strcmp(szOption,"det") || !strcmp(szOption,"detail")){
X      iFlagAltOutput = TRUE; 
X      iFlagAccessed = TRUE;
X      iFlagModified = TRUE;
X      iFlagStatus = TRUE; 
X   }
X   else if ( !strcmp(szOption,"s") || !strcmp(szOption,"size")){
X      iFlagAltOutput = TRUE;
X      iFlagSize = TRUE;
X   }
X   else if ( !strcmp(szOption,"p") || !strcmp(szOption,"pro")){
X      iFlagAltOutput = TRUE;
X      iFlagPro = TRUE;
X   }
X   else if ( !strcmp(szOption,"w") || !strcmp(szOption,"wide")){
X      iFlagWide = TRUE;
X      iScrWidth = 132;
X   }
X#ifndef SVR3
X   else if ( !strcmp(szOption,"l") || !strcmp(szOption,"link")) {
X      iFlagLink = TRUE;
X   }
X#endif
X   else if ( !strcmp(szOption,"i") || !strcmp(szOption,"inode")) {
X      iFlagAltOutput = TRUE;
X      iFlagInode = TRUE;
X   }
X   else {
X      iReturn = 1;
X      (void)printf("Error: Invalid option: '-%s', use '-h' for help.",szOption);
X      program_usage();
X      iFlagAbort = TRUE;
X   }
X   if ( iSortOptions > 1 ) {
X      iReturn = 1;
X      (void)printf("Error: incompatible sort options specified, other than '-r'.");
X      program_usage();
X      iFlagAbort = TRUE;
X   }
X   return;
X}
X
X/**********************************************************************/
Xint open_directory()
X/**********************************************************************
X
Xopen directory: "returns an integer"
X
X* uses the dir name string (character array)
X* calls the opendir() system function
X* obtains a pointer to the directory entry
X
X**********************************************************************/
X{
X   char szError[MAX_ERROR_LEN];
X   int  iReturnValue = FALSE;
X   if ( (dirp = opendir(szDirName)) != NULL ) 
X      iReturnValue = TRUE;
X   else {
X      iReturn = TRUE;
X      (void)printf("\n");
X      (void)sprintf(szError,"%s: %s",szProgName, szDirName);
X      perror(szError);
X      (void)printf("\n");
X   }
X   return(iReturnValue);
X}
X
X/**********************************************************************/
Xvoid process_directory()
X/**********************************************************************
X
Xprocess directory: "returns nothing"
X
X* reads the given directory
X* closes the directory
X* sorts the entries depending on the options
X* calls the display_directory() function 
X
X**********************************************************************/
X{
X   read_directory(); 
X   close_directory();
X   iNumColumns = iScrWidth / ( iLongest+NUM_BLANK );
X   if ( iFlagSingle ) iNumColumns = 1;
X   if ( iNumFiles+iNumDirs > 0 ) {
X      if ( iFlagSort ) {
X         if ( iNumFiles > 1 )
X            if ( iFlagReverse ) 
X               qsort((char *)File,iNumFiles,sizeof(EntryData),sort_rev_name);
X            else
X               qsort((char *)File,iNumFiles,sizeof(EntryData),sort_name);
X         if ( iNumDirs > 1 )
X            if ( iFlagReverse )
X               qsort((char *)Dir,iNumDirs,sizeof(EntryData),sort_rev_name);
X            else
X               qsort((char *)Dir,iNumDirs,sizeof(EntryData),sort_name);
X      }
X      else if ( iFlagSortModified ) {
X         if ( iNumFiles > 1 ) {
X            qsort((char *)File,iNumFiles,sizeof(EntryData),sort_name);
X            if ( iFlagReverse )
X               qsort((char *)File,iNumFiles,sizeof(EntryData),
X                  sort_rev_date_modified);
X            else
X               qsort((char *)File,iNumFiles,sizeof(EntryData),
X                  sort_date_modified);
X         }
X	 if ( iNumDirs > 1 ) {
X            qsort((char *)Dir,iNumDirs,sizeof(EntryData),sort_name);
X            if ( iFlagReverse )
X               qsort((char *)Dir,iNumDirs,sizeof(EntryData),
X                  sort_rev_date_modified);
X            else
X               qsort((char *)Dir,iNumDirs,sizeof(EntryData),
X                  sort_date_modified);
X         }
X      }
X      else if ( iFlagSortSize ) {
X         if ( iNumFiles > 1 ) {
X            qsort((char *)File,iNumFiles,sizeof(EntryData),sort_name);
X            if ( iFlagReverse )
X               qsort((char *)File,iNumFiles,sizeof(EntryData),sort_rev_size);
X            else
X               qsort((char *)File,iNumFiles,sizeof(EntryData),sort_size);
X         }
X         if ( iNumDirs > 1 ) {
X            qsort((char *)Dir,iNumDirs,sizeof(EntryData),sort_name);
X            if ( iFlagReverse )
X               qsort((char *)Dir,iNumDirs,sizeof(EntryData),sort_rev_size);
X            else
X               qsort((char *)Dir,iNumDirs,sizeof(EntryData),sort_size);
X         }
X      }
X      display_directory();
X   }
X   if ( !iNumEntries ) {
X      iReturn = TRUE;
X      (void)printf("No entries selected. \n\n");
X   }
X   return;
X}
X
X/**********************************************************************/
Xvoid display_header()
X/**********************************************************************
X
Xdisplay header: "returns nothing"
X
X* show the directory pathname if local dir then use "." 
X* show the quantity of entries in the directory
X
X**********************************************************************/
X{
X   char *cwd, *getcwd();
X   if ( iRemoteDir ) 
X      (void)printf("%s",szDirName);
X   else {
X      cwd = getcwd((char *)NULL, 128);
X      (void)printf("%s",cwd);
X   }
X   if (iNumEntries == 1) 
X      (void)printf("           %d Entry%c\n\n",iNumEntries,cQtyChar);
X   else                  
X      (void)printf("           %d Entries%c\n\n",iNumEntries,cQtyChar);
X   return;
X}
X
X/**********************************************************************/
Xvoid read_directory()
X/**********************************************************************
X
Xread directory: "returns nothing"
X
X* reads the given directory
X* file entries are stored in the file pointer array
X* dir entries are stored in the dir pointer array
X
X**********************************************************************/
X{
X   int  iTemp,
X        iDone = FALSE;
X   char szEntry[MAX_NAME_LEN],
X        szFullName[MAX_NAME_LEN],
X        szError[MAX_ERROR_LEN];
X
X   iTemp = 0;
X   iNumFiles = 0;
X   iNumDirs = 0;
X   iLongest = 0;
X
X   do {
X      filep = readdir(dirp);
X      if ( filep ) {
X         (void)strcpy(szEntry,filep->d_name);
X         if ( strcmp(szEntry,".") && strcmp(szEntry,"..") || iFlagHidden ) {
X            (void)strcpy(szFullName,szDirName);
X            if ( strcmp(szDirName,"/") ) (void)strcat(szFullName,"/");
X            (void)strcat(szFullName,szEntry);
X            if ( stat(szFullName, &stb) < 0 ) {
X               if ( errno == ENOENT ) {                   /* No such entry */
X                  if ( szEntry[0] == '.' && iFlagDot == FALSE ) {
X                     continue;
X                  }
X                  else {
X                     entry_store(ENTRY_FILE,szEntry,0,0,iNumFiles++);
X                  }
X               }
X               else {
X                  iReturn = TRUE;
X                  (void)sprintf(szError,"%s: %s",szProgName,szFullName);
X                  perror(szError);
X               }
X            }
X            else {
X               if ( S_ISDIR(stb.st_mode) ) {              /* directory */
X                  if ( szEntry[0] == '.' && iFlagDot == FALSE ) {
X                     continue;
X                  }
X                  else {
X                     entry_store(ENTRY_DIR,szEntry,
X                        (int)stb.st_mtime,(int)stb.st_size,iNumDirs++);
X                  }
X               }
X               else {                                     /* file */
X                  if ( szEntry[0] == '.' && iFlagDot == FALSE ) {
X                     continue;
X                  }
X                  else {
X                     entry_store(ENTRY_FILE,szEntry,
X                        (int)stb.st_mtime,(int)stb.st_size,iNumFiles++);
X                  }
X               }
X               iTemp = strlen(szEntry);
X               if ( iTemp > iLongest ) iLongest = iTemp;
X            }
X         }
X      }
X      else iDone = TRUE;
X   } while ( !iDone );
X   return;
X}
X
X/**********************************************************************/
Xvoid close_directory()                   /* close an opened directory */
X/**********************************************************************/
X{
X   (void)closedir(dirp);
X   return;
X}
X
X/**********************************************************************/
Xint sort_name(entry1,entry2)          /* qsort func, by entry name */
X/**********************************************************************/
XEntryData *entry1,
X          *entry2;
X{
X   return strcmp(entry1->szName,entry2->szName);
X}
X
X/**********************************************************************/
Xint sort_rev_name(entry1,entry2)     /* qsort func, by rev entry name */
X/**********************************************************************/
XEntryData *entry1,
X          *entry2;
X{
X   return strcmp(entry2->szName,entry1->szName);
X}
X
X/**********************************************************************/
Xint sort_date_modified(entry1,entry2)      /* qsort func, by date mod */
X/**********************************************************************/
XEntryData *entry1,
X          *entry2;
X{
X   return(entry2->iMod - entry1->iMod);
X}
X
X/**********************************************************************/
Xint sort_rev_date_modified(entry1,entry2) /* qsort func, rev date mod */
X/**********************************************************************/
XEntryData *entry1,
X          *entry2;
X{
X   return(entry1->iMod - entry2->iMod);
X}
X
X/**********************************************************************/
Xint sort_size(entry1,entry2)                   /* qsort func, by size */
X/**********************************************************************/
XEntryData *entry1,
X          *entry2;
X{
X   return(entry2->iSize - entry1->iSize);
X}
X
X/**********************************************************************/
Xint sort_rev_size(entry1,entry2)           /* qsort func, rev by size */
X/**********************************************************************/
XEntryData *entry1,
X          *entry2;
X{
X   return(entry1->iSize - entry2->iSize);
X}
X
X/**********************************************************************/
Xvoid display_directory()
X/**********************************************************************
X
Xdisplay directory: "returns nothing"
X
X* shows pathname and entry qty if needed
X* shows file and dir count if needed
X* if using alternate output show column header
X* for each entry in the directory display its name
X* if using alternate output show the needed details
X
X**********************************************************************/
X{
X   register int t,
X                i;
X   int          iColCnt,
X                iColWidth,
X                iNblanks, 
X                iSpace = 3;
X   char         szPathName[MAX_NAME_LEN];
X
X   iColWidth = iScrWidth / iNumColumns;
X   iNumEntries = 0;
X
X   if ( iFlagBrief && iFlagCount ) iFlagQty = TRUE;
X   if ( !iFlagFiles && !iFlagDirs ) {
X      iFlagFiles = TRUE;
X      iFlagDirs = TRUE;
X   }
X   if ( iFlagFiles )  iNumEntries += iNumFiles;
X   if ( iFlagDirs )   iNumEntries += iNumDirs;
X   if ( !iFlagBrief ) (void)printf("\n");
X   if ( iFlagPath )   display_header();
X   if ( iNumFiles && iFlagFiles ) {
X      iColCnt = 0;
X      iNblanks = 0;
X      if ( iFlagQty ) {
X         if (iNumFiles == 1) 
X            (void)printf("%d File%c\n",iNumFiles,cQtyChar);
X         else
X            (void)printf("%d Files%c\n",iNumFiles,cQtyChar);
X         if ( !iFlagBrief ) (void)printf("\n");
X      }
X      if ( !iFlagCount ) {   
X         if ( iFlagAltOutput ) {            /* ALTERNATE OUTPUT FORMAT */
X            if ( iFlagHeader ) {
X               (void)printf("Name");
X               align_column(iLongest,strlen("name"),iSpace);
X               if ( iFlagInode )    (void)printf(" Inode #  ");
X               if ( iFlagLinkCnt )  (void)printf("Link Cnt  ");
X               if ( iFlagSize )     (void)printf("Size (bytes)  ");
X               if ( iFlagPro )     {(void)printf("User  Group Other  ");
X                                    (void)printf("    User.Group     ");}
X               if ( iFlagAccessed ) (void)printf("Accessed           ");
X               if ( iFlagModified ) (void)printf("Modified           ");
X               if ( iFlagStatus )   (void)printf("Status Changed     ");
X               (void)printf("\n");
X               repeat_char('-',iScrWidth-1); (void)printf("\n");
X            }
X            for ( t=0 ; t<iNumFiles ; ++t ) {
X               if ( iFilesOnly ) (void)strcpy(szPathName,File[t].szName);
X               else {
X                  (void)strcpy(szPathName,szDirName);
X                  if ( strcmp(szDirName,"/") ) (void)strcat(szPathName,"/");
X                  (void)strcat(szPathName,File[t].szName);
X               }
X               stat_file(File[t].szName,szPathName);
X            }
X            if ( !iFlagBrief ) (void)printf("\n");
X         }
X         else {                                            /* DEFAULT FORMAT */
X            for ( t=0 ; t<iNumFiles ; ++t ) {
X               for ( i=0; i<iNblanks ; ++i ) (void)putchar(' ');
X               (void)printf("%s",File[t].szName);
X               if (++iColCnt >= iNumColumns) {
X                  (void)putchar('\n');
X                  iColCnt = 0;
X                  iNblanks = 0;
X               }
X               else iNblanks = iColWidth - strlen(File[t].szName);
X            }
X            if (iColCnt != 0) (void)putchar('\n');
X            if ( !iFlagBrief ) (void)printf("\n");
X         }
X      }
X   }
X   if ( iNumDirs && iFlagDirs ) {                    /* DISPLAY DIRECTORIES */
X      iColCnt = 0;
X      iNblanks = 0;
X      if ( iFlagQty ) {                     /* DISPLAY THE QTY OF DIRS FLAG */
X         if (iNumDirs == 1) 
X            (void)printf("%d Directory%c\n",iNumDirs,cQtyChar);
X         else
X            (void)printf("%d Directories%c\n",iNumDirs,cQtyChar);
X         if ( !iFlagBrief ) (void)printf("\n");
X      }
X      if ( !iFlagCount ) {   
X         if ( iFlagAltOutput ) {                 /* ALTERNATE OUTPUT FORMAT */
X            if ( iFlagHeader ) {
X               (void)printf("Name");
X               align_column(iLongest,strlen("name"),iSpace);
X               if ( iFlagInode )    (void)printf(" Inode #  ");
X               if ( iFlagLinkCnt )  (void)printf("Link Cnt  ");
X               if ( iFlagSize )     (void)printf("Size (bytes)  ");
X               if ( iFlagPro )     {(void)printf("User  Group Other  ");
X                                    (void)printf("    User.Group     ");}
X               if ( iFlagAccessed ) (void)printf("Accessed           ");
X               if ( iFlagModified ) (void)printf("Modified           ");
X               if ( iFlagStatus )   (void)printf("Status Changed     ");
X               (void)printf("\n");
X               repeat_char('-',iScrWidth-1); (void)printf("\n");
X            }
X            for ( t=0 ; t<iNumDirs ; ++t ) {
X               (void)strcpy(szPathName,szDirName);
X               if ( strcmp(szDirName,"/") ) 
X                  (void)strcat(szPathName,(char *)"/");
X               (void)strcat(szPathName,Dir[t].szName);
X               stat_file(Dir[t].szName,szPathName);
X            }
X            if ( !iFlagBrief ) (void)printf("\n");
X         }
X         else {                                           /* DEFAULT FORMAT */
X            for ( t=0 ; t<iNumDirs ; ++t ) {
X               for ( i=0 ; i<iNblanks ; ++i ) (void)putchar(' ');
X               (void)printf("%s",Dir[t].szName);
X               if (++iColCnt >= iNumColumns) {
X                  (void)putchar('\n');
X                  iColCnt = 0;
X                  iNblanks = 0;
X               }
X               else iNblanks = iColWidth - strlen(Dir[t].szName);
X               }
X            if (iColCnt != 0) (void)putchar('\n');
X            if ( !iFlagBrief ) (void)printf("\n");
X         }
X      }
X   }
X   return;
X}
X
X/**********************************************************************/
Xvoid stat_file(szFileName,szPathName)
X/**********************************************************************
X
Xstat file: "returns nothing"
X
X* receives the file name and the path name
X* calls the system stat() function
X* depending on the flags, various information is displayed
X
X**********************************************************************/
Xchar *szFileName,
X     *szPathName;
X{
X   int  iLink, 
X        iSpace = 3, 
X        iValidFile = TRUE;
X   char szError[MAX_ERROR_LEN], 
X        szLinkName[MAX_NAME_LEN];
X
X   szLinkName[0] = '\0';
X   if ( lstat(szPathName, &stb) < 0 ) {
X      iReturn = TRUE;
X      (void)sprintf(szError,"%s: %s",szProgName,szPathName);
X      perror(szError);
X   }
X   else {
X
X#ifndef SVR3
X      if ( S_ISLNK(stb.st_mode) )
X         if ( (iLink = readlink(szPathName,szLinkName,MAX_NAME_LEN)) ) 
X            szLinkName[iLink] = '\0';
X#endif
X
X      if ( iFlagLink ) {
X         (void)printf("%s",szFileName);
X         if ( iLongest >= strlen("Name") )
X            align_column(iLongest,strlen(szFileName),iSpace);
X         else
X            align_column(strlen("Name"),strlen(szFileName),iSpace);        
X         display_expanded(szLinkName, iValidFile);
X         (void)printf("\n");
X      }
X      else {
X         if ( stat(szPathName, &stb) < 0 ) {
X            if ( errno == ENOENT ) {
X               iValidFile = FALSE;
X               (void)printf("%s",szFileName);
X               if ( iLongest >= strlen("Name") )
X                  align_column(iLongest,strlen(szFileName),iSpace);
X               else
X                  align_column(strlen("Name"),strlen(szFileName),iSpace);
X               display_expanded(szLinkName, iValidFile);
X               (void)printf("\n");
X            }
X            else {
X               iReturn = TRUE;
X               (void)sprintf(szError,"%s: %s",szProgName,szPathName);
X               perror(szError);
X            }
X         }
X         else {
X            (void)printf("%s",szFileName);
X            if ( iLongest >= strlen("Name") )
X               align_column(iLongest,strlen(szFileName),iSpace);
X            else
X               align_column(strlen("Name"),strlen(szFileName),iSpace);
X            display_expanded(szLinkName, iValidFile);
X            (void)printf("\n");
X         }
X      }
X   }
X   return;
X}
X
X/**********************************************************************/
Xvoid display_expanded(szLinkName, iValid) 
X/**********************************************************************
X
Xdisplay expanded: "returns nothing"
X
X* this is used only for alternate outputs
X* depending on various flags, different sections are used
X
X**********************************************************************/
Xchar *szLinkName; 
Xint   iValid;
X{
X   int iHour, iMin, iSec, iMonth, iDay, iYear;
X   if ( iValid ) {
X      if ( iFlagInode )   (void)printf("%7ld   ",stb.st_ino);
X      if ( iFlagLinkCnt ) (void)printf("%6d    ",stb.st_nlink);
X      if ( iFlagSize ) {
X         if ( S_ISCHR(stb.st_mode) || S_ISBLK(stb.st_mode) ) {
X            (void)printf("   %3u,  %3u  ",
X               major(stb.st_rdev),minor(stb.st_rdev));
X         }
X         else {
X            (void)printf("%12ld  ",stb.st_size);
X         }
X      }
X      if ( iFlagPro ) {
X         if ( stb.st_mode & S_IRUSR ) (void)printf("r");
X         else                         (void)printf("-");
X         if ( stb.st_mode & S_IWUSR ) (void)printf("w");
X         else                         (void)printf("-");
X         if ( stb.st_mode & S_ISUID ) {
X            (void)printf("S");
X         }
X         else {
X            if ( stb.st_mode & S_IXUSR ) (void)printf("x");
X            else                         (void)printf("-");
X         }
X         (void)printf("   ");
X         if ( stb.st_mode & S_IRGRP ) (void)printf("r");
X         else                         (void)printf("-");
X         if ( stb.st_mode & S_IWGRP ) (void)printf("w");
X         else                         (void)printf("-");
X         if ( stb.st_mode & S_ISGID ) {
X            (void)printf("S");
X         }
X         else {
X            if ( stb.st_mode & S_IXGRP ) (void)printf("x");
X            else                         (void)printf("-");      
X         }
X         (void)printf("   ");
X         if ( stb.st_mode & S_IROTH ) (void)printf("r");
X         else                         (void)printf("-");
X         if ( stb.st_mode & S_IWOTH ) (void)printf("w");
X         else                         (void)printf("-");
X         if ( stb.st_mode & S_IXOTH ) (void)printf("x");
X         else                         (void)printf("-");      
X         (void)printf("    ");
X         passwdp = (struct passwd *)getpwuid((int)stb.st_uid);
X         if ( passwdp != NULL ) (void)printf("%8s.",passwdp->pw_name);
X         else                   (void)printf("%8d.",stb.st_uid);
X         groupp = (struct group *)getgrgid((int)stb.st_gid);
X         if ( groupp != NULL )  (void)printf("%-8s",groupp->gr_name);
X         else                   (void)printf("%-8d",stb.st_gid);
X         (void)printf("  ");
X      }
X      if ( iFlagAccessed ) {
X         tmp = localtime(&stb.st_atime);
X         iHour = tmp->tm_hour; iMin = tmp->tm_min; iSec = tmp->tm_sec;
X         iMonth = tmp->tm_mon+1; iDay = tmp->tm_mday; iYear = tmp->tm_year;
X         if ( iMonth < 10 ) (void)printf("0%1d/",iMonth);
X         else               (void)printf("%2d/",iMonth);
X         if ( iDay < 10 )   (void)printf("0%1d/",iDay);
X         else               (void)printf("%2d/",iDay);
X         if ( iYear < 10 )  (void)printf("0%1d",iYear);
X         else               (void)printf("%2d",iYear);
X         (void)printf("-");
X         if ( iHour < 10 ) (void)printf("0%1d:",iHour);
X         else              (void)printf("%2d:",iHour);
X         if ( iMin < 10 )  (void)printf("0%1d:",iMin);
X         else              (void)printf("%2d:",iMin);
X         if ( iSec < 10 )  (void)printf("0%1d",iSec);
X         else              (void)printf("%2d",iSec);
X         (void)printf("  ");
X      }
X      if ( iFlagModified ) {
X         tmp = localtime(&stb.st_mtime);
X         iHour = tmp->tm_hour; iMin = tmp->tm_min; iSec = tmp->tm_sec;
X         iMonth = tmp->tm_mon+1; iDay = tmp->tm_mday; iYear = tmp->tm_year;
X         if ( iMonth < 10 ) (void)printf("0%1d/",iMonth);
X         else               (void)printf("%2d/",iMonth);
X         if ( iDay < 10 )   (void)printf("0%1d/",iDay);
X         else               (void)printf("%2d/",iDay);
X         if ( iYear < 10 )  (void)printf("0%1d",iYear);
X         else               (void)printf("%2d",iYear);
X         (void)printf("-");
X         if ( iHour < 10 ) (void)printf("0%1d:",iHour);
X         else              (void)printf("%2d:",iHour);
X         if ( iMin < 10 )  (void)printf("0%1d:",iMin);
X         else              (void)printf("%2d:",iMin);
X         if ( iSec < 10 )  (void)printf("0%1d",iSec);
X         else              (void)printf("%2d",iSec);
X         (void)printf("  ");
X      }
X      if ( iFlagStatus ) {
X         tmp = localtime(&stb.st_ctime);
X         iHour = tmp->tm_hour; iMin = tmp->tm_min; iSec = tmp->tm_sec;
X         iMonth = tmp->tm_mon+1; iDay = tmp->tm_mday; iYear = tmp->tm_year;
X         if ( iMonth < 10 ) (void)printf("0%1d/",iMonth);
X         else               (void)printf("%2d/",iMonth);
X         if ( iDay < 10 )   (void)printf("0%1d/",iDay);
X         else               (void)printf("%2d/",iDay);
X         if ( iYear < 10 )  (void)printf("0%1d",iYear);
X         else               (void)printf("%2d",iYear);
X         (void)printf("-");
X         if ( iHour < 10 ) (void)printf("0%1d:",iHour);
X         else              (void)printf("%2d:",iHour);
X         if ( iMin < 10 )  (void)printf("0%1d:",iMin);
X         else              (void)printf("%2d:",iMin);
X         if ( iSec < 10 )  (void)printf("0%1d",iSec);
X         else              (void)printf("%2d",iSec);
X         (void)printf("  ");
X      }
X   }
X   else {
X      (void)printf("(Broken Link) destination doesn't exist:   ");
X   }
X   if ( strlen(szLinkName) ) {
X      if ( iFlagLink ) (void)printf("(Link Status)");
X      else             (void)printf("-> %s",szLinkName);
X   }
X   return;
X}
X
X/**********************************************************************/
Xvoid align_column(iLong,iCurrent,iGap)  /* pad stdout to align column */
X/**********************************************************************/
Xint iLong, 
X    iCurrent,
X    iGap;
X{
X   register int i,
X                t;
X   t = iLong - iCurrent;
X   for ( i=0 ; i<t ; i++ ) (void)putchar(' ');
X   for ( i=0 ; i<iGap ; i++ ) (void)putchar(' ');
X   return;
X}
X
X/**********************************************************************/
Xvoid repeat_char(cChar,iQty)             /* repeat a char in a string */
X/**********************************************************************/
Xchar         cChar;
Xregister int iQty;
X{
X   register int i;
X   for ( i=0 ; i<iQty ; i++ ) (void)putchar(cChar);
X   return;
X}
X
X/**********************************************************************/
Xvoid program_usage()
X/**********************************************************************/
X{
X   (void)printf("\n");
X   (void)printf("Usage: %s  <options>  <list of files/dirs>\n",szProgName);
X   return;
X}
X
X/**********************************************************************/
Xvoid program_help()
X/**********************************************************************/
X{
X   (void)printf(
X   "       -a   | -all       ...   show all entries ( include '.' & '..' ).\n");
X   (void)printf(
X   "       -b   | -brief     ...   same as '-nh -np -nq' & no blank lines.\n");
X   (void)printf(
X   "       -c   | -count     ...   show counts only.\n");
X   (void)printf(
X   "       -d   | -dir       ...   directories only.\n");
X   (void)printf(
X   "       -f   | -file      ...   files only.\n");
X   (void)printf(
X   "       -h   | -help      ...   help information.\n");
X   (void)printf(
X   "       -i   | -inode     ...   show file inode number.\n");
X#ifndef SVR3
X   (void)printf(
X   "       -l   | -link      ...   if symbolic link, show links status\n");
X#endif
X   (void)printf(
X   "       -p   | -pro       ...   file protection (user,group,other).\n");
X   (void)printf(
X   "       -r   | -reverse   ...   sort entries in reverse order.\n");
X   (void)printf(
X   "       -s   | -size      ...   file size.\n");
X   (void)printf(
X   "       -v   | -version   ...   version stamp.\n");
X   (void)printf(
X   "       -w   | -wide      ...   wide format output ( 132 columns ).\n");
X   (void)printf(
X   "       -lc  | -link_cnt  ...   hard link count.\n");
X   (void)printf(
X   "       -nd  | -no_dot    ...   don't show files that start with '.'.\n");
X   (void)printf(
X   "       -nh  | -no_hdr    ...   don't show header on extended output.\n");
X   (void)printf(
X   "       -np  | -no_pwd    ...   don't show pathname.\n");
X   (void)printf(
X   "       -nq  | -no_qty    ...   don't show quantities.\n");
X   (void)printf(
X   "       -ns  | -no_sort   ...   don't sort the files/directories.\n");
X   (void)printf(
X   "       -sc  | -sglcol    ...   force single column output.\n");
X   (void)printf(
X   "       -sm  | -sort_dtm  ...   sort by date modified.\n");
X   (void)printf(
X   "       -ss  | -sort_size ...   sort by file size.\n");
X   (void)printf(
X   "       -det | -detail    ...   all date/time options.\n");
X   (void)printf(
X   "       -dta | -accessed  ...   date/time accessed.\n");
X   (void)printf(
X   "       -dtm | -modified  ...   date/time modified.\n");
X   (void)printf(
X   "       -dts | -status    ...   date/time status changed.\n");
X   program_usage();
X   return;
X}
X
X/**********************************************************************/
Xvoid program_version()
X/**********************************************************************/
X{
X   (void)printf(
X   "[ print directory (pd)           Scott L. Fehrman           version (%s)]\n"
X   ,VERSION);
X   return;
X}
X
X#ifdef SVR3
X/**********************************************************************/
Xint lstat()  /*** this is a dumb function if using SVR3 UNIX system ***/
X/**********************************************************************/
X{
X   return(0);
X}
X#endif
END_OF_FILE
if test 50008 -ne `wc -c <'pd.c'`; then
    echo shar: \"'pd.c'\" unpacked with wrong size!
fi
# end of 'pd.c'
fi
echo shar: End of shell archive.
exit 0
