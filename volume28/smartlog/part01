Newsgroups: comp.sources.unix
From: bytewurm@pandora.oche.de (smartlog)
Subject: v28i037: smartlog - Logfile maintenance utility, V2.3, Part01/01
Message-id: <1.769203156.20738@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: bytewurm@pandora.oche.de (smartlog)
Posting-Number: Volume 28, Issue 37
Archive-Name: smartlog/part01

          smartlog
          (c) 1994 by Michael Weber

smartlog was written to prevent logfiles from growing out of bounds.  It will
manage archives with sliding histories of log messages.  It gathers the
logfiles spread all over the system in one directory and gives you various
possibilities to process these archives.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  smartlog smartlog/CREDITS smartlog/HISTORY
#   smartlog/MANIFEST smartlog/Makefile smartlog/README
#   smartlog/getmode.c smartlog/install.sh smartlog/rc.bytewurm
#   smartlog/rc.sample smartlog/smartlog smartlog/smartlog.1
#   smartlog/smartlog.awk smartlog/smartlog.def smartlog/smartlog.sh
# Wrapped by bytewurm@maroren on Tue May 17 11:14:10 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test ! -d 'smartlog' ; then
    echo shar: Creating directory \"'smartlog'\"
    mkdir 'smartlog'
fi
if test -f 'smartlog/CREDITS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'smartlog/CREDITS'\"
else
echo shar: Extracting \"'smartlog/CREDITS'\" \(619 characters\)
sed "s/^X//" >'smartlog/CREDITS' <<'END_OF_FILE'
XThanks to
X
X  - Wolfgang Stumvoll for helping me up with awk and getmode.
X    He always had ideas to improve the functionality and the structure.
X    Thank you for the many xbattles we fought.
X
X  - Stephen R. van den Berg for his shiftlog routines, the introduction
X    to the deeper sh-philosophy and his patience.
X
X  - Stefan Michael Kuklik for listening to my weird ideas and giving new
X    hints while we both had (more or less) too much beer.
X
X  - all the other people for testing prior versions of smartlog and
X    flaming me for stupid errors :-)
X
X
X Aachen, May 1994
X
X   Michael Weber
X   bytewurm@pandora.oche.de
END_OF_FILE
if test 619 -ne `wc -c <'smartlog/CREDITS'`; then
    echo shar: \"'smartlog/CREDITS'\" unpacked with wrong size!
fi
# end of 'smartlog/CREDITS'
fi
if test -f 'smartlog/HISTORY' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'smartlog/HISTORY'\"
else
echo shar: Extracting \"'smartlog/HISTORY'\" \(1494 characters\)
sed "s/^X//" >'smartlog/HISTORY' <<'END_OF_FILE'
XV0.1	basic version with very low funcionality
X	field dependent format for rc-file
X	only a given maximum of lines to hold
X
XV0.9	awk parser, field independent structure for rc-file
X	shiftlog implementation
X	package split in several files (caller, parser and executor)
X	identifier and delimiter implemented, line independent
X	smartlog.def implemented
X
XV1.0	major internal restructuring
X	Makefile and install.sh created
X	getmode written by stumvoll
X	"ash" & "bsh" implemented
X
XV1.1	implemented some neat features, nearly full functionality achieved
X	(e.g. making it possible to archive smartlog-archives)
X	minor bugfixes and cosmetics
X	install.sh improved (whitch() and makedir())
X
XV2.0	major bugfix for compress/uncompress in combination with shiftlog
X	major internal restructuring of lame loop-structures
X	*-feature for "arch" implemented
X	rough double-archive check implemented
X	major changes in install.sh (e.g. fgres support)
X	manpage created
X
XV2.1	medium bugfix in awk-parser
X	lots of cosmetics
X	"size" implemented
X	manpage rewritten and restructured
X	medium bugfix in double-archive checking routines
X	install.sh modified
X	$[]-support implemented
X
XV2.2	"ext" autodetection improved
X	"nsh" implemented
X	minor internal restructuring
X	cosmetics all over the package
X
XV2.3	incomplete parsing-structures fixed, indented lines are parsed
X	correctly now
X	minor bugfix for path-checking in install.sh
X	minor bugfix in shiftlog-routines
X	inline comments allowed now
X	parser speedup and restructuring
END_OF_FILE
if test 1494 -ne `wc -c <'smartlog/HISTORY'`; then
    echo shar: \"'smartlog/HISTORY'\" unpacked with wrong size!
fi
# end of 'smartlog/HISTORY'
fi
if test -f 'smartlog/MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'smartlog/MANIFEST'\"
else
echo shar: Extracting \"'smartlog/MANIFEST'\" \(702 characters\)
sed "s/^X//" >'smartlog/MANIFEST' <<'END_OF_FILE'
XREADME 		- hmm, uh, well ... perhaps you should read it?!
XHISTORY		- once upon a time, there was a time without smartlog
XCREDITS		- people who helped me up again and again
XMANIFEST	- you are reading it right now
X
XMakefile	- comfortable way to install smartlog
Xgetmode.c	- returns uid, gid, size and modemask of a given file
Xinstall.sh	- does the real work for the installation
X
Xsmartlog	- caller script
Xsmartlog.awk	- awk-parser, invoked by caller
Xsmartlog.sh	- does the archiving, invoked by parser
Xsmartlog.def	- system defaults, parsed first
Xsmartlog.1	- a manpage, I s'gest :-)
X
Xrc.sample	- a small example for your private smartlogrc
Xrc.bytewurm	- I use this one on my pandora, may give you hints
END_OF_FILE
if test 702 -ne `wc -c <'smartlog/MANIFEST'`; then
    echo shar: \"'smartlog/MANIFEST'\" unpacked with wrong size!
fi
# end of 'smartlog/MANIFEST'
fi
if test -f 'smartlog/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'smartlog/Makefile'\"
else
echo shar: Extracting \"'smartlog/Makefile'\" \(655 characters\)
sed "s/^X//" >'smartlog/Makefile' <<'END_OF_FILE'
X#
X# smartlog  (c) 1994 by Michael Weber
X#
X
X#
X# using the current path could make trouble
X# create your own if necessary, it will be used for install.sh as well
X# this way smartlog can use your favourite system tools
X#
X#BIN_PATH=	"/usr/gnu/bin:/bin:/usr/bin:/local/bin:/lbin:/usr/local/bin:/sbin"
XBIN_PATH=	$(PATH)
X
XCC=		gcc -O2
X
X#{{{}}}
X#{{{  all/default
Xall default:	getmode
X		echo "type 'make install' now."
X#}}}
X#{{{  getmode
Xgetmode:
X		$(CC) getmode.c -o getmode
X		strip getmode
X#}}}
X#{{{  install
Xinstall:	getmode
X		PATH=$(BIN_PATH); sh install.sh
X#}}}
X#{{{  clean
Xclean:
X		rm -f *.o a.out core
X#}}}
X#{{{  clobber
Xclobber:	clean
X		rm -f getmode
X#}}}
END_OF_FILE
if test 655 -ne `wc -c <'smartlog/Makefile'`; then
    echo shar: \"'smartlog/Makefile'\" unpacked with wrong size!
fi
# end of 'smartlog/Makefile'
fi
if test -f 'smartlog/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'smartlog/README'\"
else
echo shar: Extracting \"'smartlog/README'\" \(2788 characters\)
sed "s/^X//" >'smartlog/README' <<'END_OF_FILE'
Xsmartlog - Logfile maintenance utility, V2.3
X
X(c) 1994 by Michael Weber
X            bytewurm@pandora.oche.de
X
X
Xsmartlog was written to prevent logfiles from growing out of bounds.  It will
Xmanage archives with sliding histories of log messages.
XIt collects the logfiles spread all over the system in one directory and gives
Xyou various possibilities to process these archives.
X
XFor installation simply type 'make install' in the smartlog directory.  All
Xfiles will be copied to the given directory.  Do not remove any of them or you
Xmay run into trouble.
X
XIf your system does not have all necessary tools in the current path, the
Xinstall-script will complain with '<systool> is missing in the path'.
XEdit 'BIN_PATH' in the Makefile then (respectively install the tool).
X
XFor detailed instructions and descriptions have a look at the manpage,
Xrc.sample and rc.bytewurm.
X
XYou should run smartlog via roots' crontab like this:
X
X 0 1 * * * /etc/smartlog/smartlog  # run smartlog at 1am every day
X
X
XNOTE: smartlog requires POSIX conform AWK and SH.
X
X-------------------------------------------------------------------------------
Xproject information and some legal stuff:
X
X idea and realisation   Michael Weber
X                        bytewurm@pandora.oche.de
X
X awk parsing, getmode   Wolfgang Stumvoll
X                        stumvoll@pool.informatik.rwth-aachen.de
X
X shiftlog routines      Stephen R. van den Berg
X                        berg@pool.informatik.rwth-aachen.de
X
X
XUse smartlog at your own risk; the programmers cannot be held liable for any
Xincurred damages, directly or indirectly due to the use or inability to use it.
X
XYou are encouraged to distribute this package freely. This package is however
Xnot to be sold (minor transfer costs excepted) or included in any commercially
Xsold software package (if you want to do this anyway, contact me, and we'll
Xwork something out).
X
XIf you distribute it, please leave the package intact. You are allowed to take
Xparts from this distribution and distribute these separately as long as you
Xretain the project information. If you redistribute any part of this package
Xin a modified form, be sure to mark the parts you changed.  If you have some
Ximportant changes that might be useful to the rest of the world, contact me
Xinstead.
X
XHowever, as with any program, bugs cannot be completely ruled out.  I tested
Xthe program extensively, and believe it should be relatively bug free. Should,
Xhowever, anyone find any bugs (highly unlikely :-), I would be pleased (well,
Xsort of :-) to hear about it.  Please send me the patches or bug report. I'll
Xlook at them and will try to fix it in a future release.
X
X(Legal stuff text taken from Stephens' procmail-package)
X-------------------------------------------------------------------------------
END_OF_FILE
if test 2788 -ne `wc -c <'smartlog/README'`; then
    echo shar: \"'smartlog/README'\" unpacked with wrong size!
fi
# end of 'smartlog/README'
fi
if test -f 'smartlog/getmode.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'smartlog/getmode.c'\"
else
echo shar: Extracting \"'smartlog/getmode.c'\" \(798 characters\)
sed "s/^X//" >'smartlog/getmode.c' <<'END_OF_FILE'
X/* 
X   getmode.c (conforming K&R)
X   returns uid, gid, size and mode-mask of a given file
X
X   (w) 1994 by Wolfgang Stumvoll
X               stumvoll@pool.informatik.rwth-aachen.de
X*/
X
X/*{{{}}}*/
X/*{{{  includes*/
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X/*}}}  */
X
Xint main(argc,argv) int argc;char **argv;
X{  int ret=0;
X
X   struct stat result;
X
X   if (stat(argv[1],&result))
X     /*{{{  complain on stat-fail*/
X     { fprintf(stderr,"stat %s failed\n",argv[1]);
X       ret=1;
X     } 
X     /*}}}  */
X   else
X     /*{{{  print uid, gid, size and mode-mask*/
X     fprintf
X      ( stdout,
X        "%d %d %ld %o\n",
X        (int)result.st_uid,
X        (int)result.st_gid,
X        (long)result.st_size,
X        (int)(result.st_mode&07777)
X      );
X     /*}}}  */
X
X  return(ret);
X}
END_OF_FILE
if test 798 -ne `wc -c <'smartlog/getmode.c'`; then
    echo shar: \"'smartlog/getmode.c'\" unpacked with wrong size!
fi
# end of 'smartlog/getmode.c'
fi
if test -f 'smartlog/install.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'smartlog/install.sh'\"
else
echo shar: Extracting \"'smartlog/install.sh'\" \(6680 characters\)
sed "s/^X//" >'smartlog/install.sh' <<'END_OF_FILE'
X#! /bin/sh
X: &&O='cd .' || exec /bin/sh "$0" $argv:q # we're in a csh, feed myself to sh
X$O || exec /bin/sh "$0" "$@"              # we're in a buggy zsh
X
X#
X# smartlog  (c) 1994 by Michael Weber
X#
X
X#{{{}}}
X#{{{  init
X#{{{  make sure we get decent shell
Xif [ -z "$IFS" ]
Xthen IFS=" \
X	\
X
X"
X  export IFS
Xfi
X
XSHELL=/bin/sh
Xexport SHELL
X#}}}
X
X#{{{  panic()
Xpanic()
X{ 1>&2
X  echo "Panic: $*. Aborted."
X  exit 1
X}
X#}}}
X#{{{  whitch()
X#
X# avoiding strange which-formats, we import our own.
X# it's magic :-)
X#
Xwhitch()
X{ OIFS="$IFS"
X  IFS=":"
X  found=""
X  for xx in $PATH
X  do
X    if [ -x "$xx/$1" ]
X    then
X      found="$xx/$1"
X      break
X    fi
X  done
X  IFS="$OIFS"
X}
X#}}}
X#{{{  makedir()
X#
X# some systems do not support mkdir -p
X# or it does not work properly, so we import our own
X# must be called in a subshell!
X#
Xmakedir()
X{ cd /
X  IFS="/"
X  for xx in $1
X  do
X    if [ "$xx" ]
X    then
X      [ -d $xx ] || (mkdir "$xx" || panic "dir-creation failed for $xx of $1")
X      cd $xx || panic "$xx of $1 not accessable"
X    fi
X  done
X}
X#}}}
X#{{{  checkawk()
Xcheckawk()
X{ [ "x`$awk -v foo=2 '\
X    BEGIN {\
X      if (match(\"-foo\",\"foo\")==2 && system(\"exit 2\")==2)\
X       print foo;\
X    } \
X    { print } \
X    ' </dev/null`" != "x2" ] && awk=""
X}
X#}}}
X
X#{{{  version
Xversion="V2.3"
X#}}}
X#{{{  check test
X#
X# these are the 'test' features we need
X# I don't think the test is really necessary, but better doing too much
X#
X
Xtmp="./foo.$$"
Xcat </dev/null >$tmp
Xchmod 755 $tmp
X
Xfor opt in f x r w
Xdo
X  [ -$opt $tmp ] || panic "'test' is invalid for option '-$opt'"
Xdone
X
X[ -s $tmp ] && panic "'test' is invalid for option '-s'"
X[ -d . ] || panic "'test' is invalid for '-d'"
X[ 1 = 1 -a xy != x ] || panic "'test' is invalid for comparisons"
X[ 2 -ge 1 -a 2 -ge 2 ] || panic "'test' is invalid for option '-ge'"
X[ 2 -gt 1 ] || panic "'test' is invalid for option '-gt'"
X
Xrm -f $tmp
X#}}}
X#}}}
X#{{{  get install path
Xclear
Xecho ""
Xecho "smartlog $version"
Xecho "-install.sh in progress-"
Xecho ""
Xecho ""
Xecho "Which directory to use for installation? [CR=/etc/smartlog] :"
Xread sm_path
X
X[ ! "$sm_path" ] && sm_path="/etc/smartlog"
X
Xdpath=`dirname $sm_path`
Xwhile [ ! -w $dpath -a ! -z $dpath -a $dpath != "/" -a $dpath != "." ]
Xdo
X  dpath=`dirname $dpath`
Xdone
X
X[ -f $sm_path -o $dpath = "." -o ! -w $dpath ] && \
X   panic "invalid directory $sm_path"
X#}}}
X#{{{  get man path
Xecho""
Xecho "Where to install the manpage? [CR=$sm_path] :"
Xread man_path
X[ ! "$man_path" ] && man_path="$sm_path"
X
Xmpath=`dirname $man_path`
Xwhile [ ! -w $mpath -a ! -z $mpath -a $mpath != "/" -a $mpath != "." ]
Xdo
X  mpath=`dirname $mpath`
Xdone
X
X[ -f "$man_path" -o $mpath = "."  -o "$sm_path" != "$man_path" -a ! -w "$mpath" ] \
X && panic "invalid man-dir $man_path"
X#}}}
X#{{{  check system tools
Xecho""
Xecho "Checking system tools..."
X#{{{  standard tools
Xfor systool in ls rm mv cat sed grep mkdir chmod chown chgrp dirname
Xdo
X  whitch "$systool"
X#  {{{  found || ! found ?
X  if [ -z "$found" ]
X  then
X    panic "'$systool' is missing in the path"
X  else
X    echo "$systool is $found"
X    eval "$systool=$found"
X  fi
X#  }}}
Xdone
X#}}}
X#{{{  fgrep
X#
X# grep should be installed everywhere, but what about fgrep?
X#
Xwhitch "fgrep"
X[ -z "$found" ] || grep="$found"
X#}}}
X#{{{  fgres
Xfgres=""
Xwhitch "fgres"
X[ -z "$found" ] ||\
X  $found -i -F "" -r /dev/null -w /dev/null "" 2>/dev/null && fgres="$found"
X#}}}
X#{{{  $[]-builtin
Xecho ""
X([ $[1 + 1] = 2 ] 2>/dev/null)
X
Xif [ $? != 0 ]
Xthen
X#  {{{  $[] not available, checkout 'expr'
X  whitch "expr"
X  if [ -z "$found" ]
X  then
X    panic "'expr' is missing in the path"
X  else
X    expr="$found"
X    echo "using $expr for calculations"
X  fi
X#  }}}
Xelse
X  expr=""
X  echo "using \$[]-builtin for calculations"
Xfi
X#}}}
X#}}}
X#{{{  look for awk
Xecho""
Xecho "Looking for an awk to use..."
Xawk=""
Xfor i in awk gawk mawk
Xdo
X   echo "Checking $i."
X   whitch $i
X   $found '{ print }' </dev/null >/dev/null 2>/dev/null
X#   {{{  a valid choice?
X   if [ $? = 0 ]
X   then
X     awk="$found"
X     checkawk
X   fi
X#   }}}
Xdone
X#{{{  ask for awk if none found
Xif [ ! "$awk" ]
Xthen
X  echo ""
X  echo "I could not find a posix conform awk. Which awk should I use? :"
X  read awk
X  $awk '{ print }' </dev/null >/dev/null 2>/dev/null || panic "$awk not found"
X  checkawk
X  [ ! "$awk" ] && panic "Sorry, this awk is not posix conform"
Xfi
X
Xecho "$awk seems to be posix conform. I'll use it."
X#}}}
X#}}}
X#{{{  install files in $sm_path
Xecho ""
Xecho "Installing smartlog in $sm_path,"
X
X[ -d $sm_path ] || (makedir $sm_path)
X
Xrm -f $sm_path/getmode
Xcp getmode $sm_path
X#}}}
X#{{{  substitutions
Xif [ "$fgres" ]
Xthen
X#  {{{  use fgres for substitutions
X  echo "using 'fgres' for substitutions."
X  for file in smartlog* rc.*
X  do
X#    {{{  the fgres-substitutions
X    fgres -e ">>>sm_path<<< $sm_path" \
X          -e ">>>ls<<< $ls" \
X          -e ">>>rm<<< $rm" \
X          -e ">>>mv<<< $mv" \
X          -e ">>>awk<<< $awk" \
X          -e ">>>cat<<< $cat" \
X          -e ">>>sed<<< $sed" \
X          -e ">>>expr<<< $expr" \
X          -e ">>>grep<<< $grep" \
X          -e ">>>mkdir<<< $mkdir" \
X          -e ">>>chmod<<< $chmod" \
X          -e ">>>chgrp<<< $chgrp" \
X          -e ">>>chown<<< $chown" \
X          -e ">>>dirname<<< $dirname" \
X          -e ">>>version<<< $version" \
X    <$file >$sm_path/$file
X#    }}}
X  done
X#  }}}
Xelse
X#  {{{  use sed for substitutions
X  echo "using 'sed' for substitutions."
X#  {{{  prepare quoted vars
X#  
X#   we have to quote /'s to avoid sed-confusion
X#   hard job ain't it? :-)
X#  
X  for conv in sm_path awk ls rm mv cat sed expr grep mkdir chmod chown chgrp dirname
X  do
X    eval "tmp=$"$conv""
X    eval "q$conv=`echo $tmp | sed 's/\//\\\\\\\\\//g'`"
X  done
X#  }}}
X  for file in smartlog* rc.*
X  do
X#    {{{  the sed-substitutions
X    sed -e "s/>>>sm_path<<</$qsm_path/g" \
X        -e "s/>>>ls<<</$qls/" \
X        -e "s/>>>rm<<</$qrm/" \
X        -e "s/>>>mv<<</$qmv/" \
X        -e "s/>>>cat<<</$qcat/" \
X        -e "s/>>>sed<<</$qsed/" \
X        -e "s/>>>awk<<</$qawk/" \
X        -e "s/>>>expr<<</$qexpr/" \
X        -e "s/>>>grep<<</$qgrep/" \
X        -e "s/>>>mkdir<<</$qmkdir/" \
X        -e "s/>>>chmod<<</$qchmod/" \
X        -e "s/>>>chgrp<<</$qchgrp/" \
X        -e "s/>>>chown<<</$qchown/" \
X        -e "s/>>>dirname<<</$qdirname/" \
X        -e "s/>>>version<<</$version/" \
X    <$file >$sm_path/$file
X#    }}}
X  done
X#  }}}
Xfi
X#}}}
X#{{{  finish installation
Xchmod 755 $sm_path/smartlog $sm_path/smartlog.sh $sm_path/getmode
X
Xchmod 644 $sm_path/smartlog.awk $sm_path/smartlog.1 \
X          $sm_path/smartlog.def $sm_path/rc.*
X
Xif [ "$man_path" != "$sm_path" ]
Xthen
X  (makedir $man_path)
X  mv -f "$sm_path/smartlog.1" "$man_path"
Xfi
X
Xecho ""
Xecho "Done."
X#}}}
END_OF_FILE
if test 6680 -ne `wc -c <'smartlog/install.sh'`; then
    echo shar: \"'smartlog/install.sh'\" unpacked with wrong size!
fi
chmod +x 'smartlog/install.sh'
# end of 'smartlog/install.sh'
fi
if test -f 'smartlog/rc.bytewurm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'smartlog/rc.bytewurm'\"
else
echo shar: Extracting \"'smartlog/rc.bytewurm'\" \(1902 characters\)
sed "s/^X//" >'smartlog/rc.bytewurm' <<'END_OF_FILE'
X#
X# smartlog >>>version<<<
X# (c) 1994 by Michael Weber
X#
X#
X# smartlogrc for pandora
X#
X
X#
X# I use this to archive all the logfiles on my system
X#
X
Xdate=`/bin/date +%x`
Xzip=/bin/gzip
Xzap=/bin/gunzip
Xext=.gz
Xsize=1024
X
X# ext would automagically become .gz (default is "auto")
X# but ext=.gz is faster and preferred
X
Xhold=14
Xcomp=y
Xarch=news
X
X# this group will create the following archives:
X# news.log, news.errlog, news.history and news.adm
X
Xlogfile=/var/news/log:arch=*.log
Xlogfile=/var/news/errlog:90:arch=*.errlog
Xlogfile=/var/news/history:arch=*.history
Xlogfile=/var/news/news.adm:arch=*.adm
X
X
Xarch=smail
X
Xlogfile=/var/smail/log/logfile:30:arch=*.log
Xlogfile=/var/smail/log/paniclog:90:comp=n:arch=*.paniclog
X
X
Xcomp=n
Xarch=uucp
X
X# (tornado [tornado.oche.de] is my local pollpoint)
X
Xlogfile=/var/spool/uucp/.Admin/xferstats:comp:arch=*.xferstats
Xlogfile=/var/spool/uucp/.Admin/audit.local:90:arch=*.audit.local
Xlogfile=/var/spool/uucp/.Log/uucico/tornado:arch=*.uucico.tornado
Xlogfile=/var/spool/uucp/.Log/uux/tornado:arch=*.uux.tornado
Xlogfile=/var/spool/uucp/.Log/uuxqt/tornado:arch=*.uuxqt.tornado
X
X
Xlocal=y
Xcomp=y
X
X# arch=none is *very* important because any archive would be "smail" if
X# I would not undefine it
X# I could use local=n as well, because the files are already in /var/log,
X# but I would need an arch-entry for each file to avoid things like
X# /var/log/var.log.sycritical ...
X
Xarch=none
X# arch="" would work as well ir arch=def if you know about the defaultvalue
X
Xash=kill -1 `cat /etc/syslog.pid`
X
X# looks weird - I have split my syslogd-logfiles
Xlogfile=/var/log/sysnotice
Xlogfile=/var/log/sysatcron
Xlogfile=/var/log/syscritical
Xlogfile=/var/log/sysauth
Xlogfile=/var/log/syskernel
Xlogfile=/var/log/sysmail
X
X
Xlocal=n
Xcomp=n
X
X# undefinig ash is as important as it is for arch
Xash=none
X
Xlogfile=/var/adm/getty.log:30
Xlogfile=/var/adm/sulog:90:comp
Xlogfile=/var/adm/wtmp:7:shift
X#{{{}}}
END_OF_FILE
if test 1902 -ne `wc -c <'smartlog/rc.bytewurm'`; then
    echo shar: \"'smartlog/rc.bytewurm'\" unpacked with wrong size!
fi
# end of 'smartlog/rc.bytewurm'
fi
if test -f 'smartlog/rc.sample' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'smartlog/rc.sample'\"
else
echo shar: Extracting \"'smartlog/rc.sample'\" \(1936 characters\)
sed "s/^X//" >'smartlog/rc.sample' <<'END_OF_FILE'
X#
X# smartlog >>>version<<<
X# (c) 1994 by Michael Weber
X#
X#
X# sample rc-file for smartlog
X#
X
X#
X# hashes (#) introduce comments
X# for readability (what a word :-) blank lines maybe used as well
X#
X
X#
X# and now the fun begins :-)
X# you may use variables global or local, global means it was defined
X# in a single line, local means, it was defined in a line starting
X# with "logfile="
X# so you may handle groups of logfiles with one special value,
X# switch to another value and handle the next group but you may
X# also redefine a variable for a single logfile in a group
X#
X
X# use shiftlog for group and create a maximum of 14 archives
Xhold=14
Xshift=y
X
X# only 5 archives for the next one
Xlogfile=/doug/adams:5
X
X# and 14 files again for this one
Xlogfile=/thanx/for/all/the/fish
X
X# this one with standard archive (14 generations)
Xlogfile=/hitchhikers/guide:shift=n
X
X# but this one is shifted again
Xlogfile=/to/the/galaxy
X
Xshift=n
Xcompress=yes
X
X# the next group will be compressed and not shifted
X
X# ...
X
Xbsh=echo "Hello World."   # this is not really a good example :-)
X
X# the next group is compressed, not shifted and before any
X# archiving action "Hello World." is printed
X
X# logfile x
X# logfile y
X# logfile z
X
X# next file without bsh
Xlogfile=/do/not/panic:bsh=none
X
X# if you know that the default of bsh is none you could write this like
Xlogfile=/do/not/panic:bsh=def
X
X# logfile xyz .. executed with bsh="Hello World." again
X
Xbsh= # reset bsh to basic default
X#      or bsh=def or bsh=default
X
X# usage examples for bsh and ash :
X
X# assuming you would like to archive /var/log/notice which is
X# written by syslogd, you have to tell it that its logfile changed
X# (send HUP signal)
X# before archiving you would like to remove an (imaginary) lockfile
X# (just for demonstration)
X
Xlogfile=/var/log/notice:bsh=rm -f /var/spool/lock/imaginary.lockfile:ash=kill -1 `cat /etc/syslog.pid`
X
X# for a working smartlogrc have a look at rc.bytewurm
X#{{{}}}
END_OF_FILE
if test 1936 -ne `wc -c <'smartlog/rc.sample'`; then
    echo shar: \"'smartlog/rc.sample'\" unpacked with wrong size!
fi
# end of 'smartlog/rc.sample'
fi
if test -f 'smartlog/smartlog' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'smartlog/smartlog'\"
else
echo shar: Extracting \"'smartlog/smartlog'\" \(3109 characters\)
sed "s/^X//" >'smartlog/smartlog' <<'END_OF_FILE'
X#! /bin/sh
X: &&O='cd .' || exec /bin/sh "$0" $argv:q # we're in a csh, feed myself to sh
X$O || exec /bin/sh "$0" "$@"              # we're in a buggy zsh
X
X#
X# smartlog >>>version<<<
X# (c) 1994 by Michael Weber
X#
X
X#{{{}}}
X#{{{  init
X#{{{  make sure we get a decent shell
Xif [ -z "$IFS" ]
Xthen IFS=" \
X	\
X
X"
X  export IFS
Xfi
X
XSHELL=/bin/sh
Xexport SHELL
X#}}}
X
X#{{{  ftouch()
X#
X# emulating "touch" using "cat"
X# why to use more systools than absolutely necessary?
X#
Xftouch()
X{ $CAT </dev/null >"$1"
X}
X#}}}
X#{{{  makedir()
X#
X# some systems do not support mkdir -p
X# or it does not work properly, so we import our own
X# must be called in a subshell!
X#
Xmakedir()
X{ cd /
X  IFS="/"
X  for xx in $1
X  do
X    if [ "$xx" ]
X    then
X      [ -d $xx ] || ($MKDIR "$xx" || panic "dir-creation failed for $sm_user ($xx of $1)")
X      cd $xx || panic "$xx of $1 not accessable"
X    fi
X  done
X}
X#}}}
X#{{{  panic()
Xpanic()
X{ 1>&2
X  echo "Panic: $*. Aborted."
X  exit 1
X}
X#}}}
X#{{{  show_usage()
Xshow_usage()
X{ 1>&2
X  echo "Usage: smartlog [-d directory] [-n] [-v 1|2]"
X  echo "   -d|--dir ...       use alternate dir instead of $HOME/.smartlog"
X  echo "   -n|--noexec        do not execute but show actions"
X  echo "   -v|--verbose ...   work noisy on level 1 or 2"
X  exit 64
X}
X#}}}
X
X#{{{  systools and variables
Xsm_path=">>>sm_path<<<"
Xsm_def="$sm_path/smartlog.def"
Xsm_get="$sm_path/getmode"
Xsm_awk="$sm_path/smartlog.awk"
X
X[ -z "$HOME" -o ! -d "$HOME" ] && panic '$HOME is invalid'
Xsm_user="$HOME/.smartlog"
Xsm_file="$sm_user/smartlogrc"
Xsm_log="$sm_user/logfile"
X
XAWK=">>>awk<<<"
XCAT=">>>cat<<<"
XCHOWN=">>>chown<<<"
XMKDIR=">>>mkdir<<<"
X
Xverbose=0
Xnoexec=0
Xoptpath=0
X#}}}
X#}}}
X#{{{  parse parameters
Xwhile [ ! -z "$1" ]
Xdo
X  case "$1" in
X#    {{{  -d --dir
X    -d|--dir) [ -z "$2" ] && show_usage
X              sm_user="$2";shift;optpath=1;;
X#    }}}
X#    {{{  -n --noexec
X    -n|--noexec) noexec=1;;
X#    }}}
X#    {{{  -v --verbose
X    -v|--verbose) case "$2" in
X                    1|2) verbose="$2";;
X                    *) show_usage;;
X                  esac
X                  shift;;
X#    }}}
X    *) show_usage;;
X  esac
X  shift
Xdone
X#}}}
X#{{{  checkups
X#{{{  check smartlog in general
X[ -r "$sm_def" ] || panic "missing or unreadable $sm_def"
X[ -x "$sm_get" ] || panic "missing or unexecutable $sm_get"
X[ -r "$sm_awk" ] || panic "missing or unreadable $sm_awk"
X[ -x "$sm_path/smartlog.sh" ] || panic "missing or unexecutable $sm_path/smartlog.sh"
X#}}}
X#{{{  check $HOME/.smartlog
Xif [ ! -d "$sm_user" ]
Xthen
X  [ $optpath = 1 ] && panic "$sm_user does not exist"
X
X  (makedir "$sm_user")
X
X  ftouch "$sm_log"
X  ftouch "$sm_file"
X  $CHOWN -R 700 "$sm_user"
Xfi
X#}}}
X#{{{  check rcfile
Xif [ ! -r "$sm_file" ]
Xthen
X  echo "$sm_file not found or unreadable, using $sm_def only."
X  echo "`/bin/date`: Warning: $sm_file not found or unreadable, using $sm_def only." >>$sm_log
X  sm_file=""
Xfi
X#}}}
X#}}}
X#{{{  call parser
X#
X# sequential calling structure
X# the awk-parser calls smartlog.sh for each logfile with the parsed values
X#
X$AWK -v noexec=$noexec -v verbose=$verbose -v DQ='"' -v LOG=$sm_log \
X -f $sm_awk $sm_def $sm_file
X#}}}
END_OF_FILE
if test 3109 -ne `wc -c <'smartlog/smartlog'`; then
    echo shar: \"'smartlog/smartlog'\" unpacked with wrong size!
fi
chmod +x 'smartlog/smartlog'
# end of 'smartlog/smartlog'
fi
if test -f 'smartlog/smartlog.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'smartlog/smartlog.1'\"
else
echo shar: Extracting \"'smartlog/smartlog.1'\" \(10731 characters\)
sed "s/^X//" >'smartlog/smartlog.1' <<'END_OF_FILE'
X.TH SMARTLOG 1
X.\"{{{}}}
X.\"{{{  name
X.SH NAME
Xsmartlog - logfile maintenance utility, >>>version<<<
X.\"}}}
X.\"{{{  synopsis
X.SH SYNOPSIS
X.I smartlog [-d directory] [-n] [-v 1|2]
X.\"}}}
X.\"{{{  description
X.SH DESCRIPTION
X\fBsmartlog\fP was written to prevent logfiles from growing out of bounds.
XIt will manage archives with sliding histories of log messages.
XIt collects the logfiles spread all over the system in one directory and gives
Xyou various possibilities to process these archives.
X
XBy default \fBsmartlog\fP uses $HOME/.smartlog/smartlogrc and writes messages
Xto $HOME/.smartlog/logfile. If $HOME/.smartlog does not exist it will be
Xcreated automagically unless you have chosen an alternative directory using
Xoption -d (--dir).
X.\"}}}
X.\"{{{  options
X.SH OPTIONS
X.I
X.IP -d,--dir
Xuse alternate directory instead of $HOME/.smartlog.
X.I
X.IP -n,--noexec
Xdo not execute but show the work.
XThis is only useful for debugging, maybe not even then.
X.I
X.IP -v,--verbose
Xrequires 1 or 2 to set the verbose level.
X1 will show logging-actions, 2 will show the parsing as well
X(for debugging).
X.\"}}}
X.\"{{{  usage
X.SH USAGE
X.\"{{{  general usage
XIn smartlogrc you specify how to handle the logfiles you want to
Xarchive. The keywords may be used in two forms :
X.br
X\fIvar=value\fP    : the given value is assigned to var
X.br
X\fIvar=\fP         : sets var back to its current default but
X.br
X\fIvar=def(ault)\fP  maybe used as well
X
XYou can set the defaults by using the keyword \fIDEFAULTS\fP which uses all
Xcurrent settings as defaults for later use (var=, var=def(ault)).
X
XThe global defaults maybe changed in smartlog.def, the builtin emergency
Xdefaults are represented in the virgin file.
X.\"}}}
X.\"{{{  logfile
X.I
X.IP logfile
Xis the file you want to archive e.g. /var/smail/log/logfile.
XYou should use absolute pathnames, otherwise you may run into trouble.
X\fIlogfile\fP introduces a special line where all variable assignments will be
Xused for THAT single line ONLY. Additional settings are seperated with colons.
X.\"}}}
X.\"{{{  hold
X.I
X.IP hold
Xis the number of generations you want to hold in the archive.  If used with
X\fIshift\fP, \fIhold\fP will be the maximum number of archives to be created.
X.\"}}}
X.\"{{{  local
X.I
X.IP local
Xtells smartlog to put the archive in the same directory as the logfile, the
Xarchives name will be logfile.SLA (SmartLogArchive).  Default is to archive
Xinto \fIdir\fP/path.to.logfile.SLA.
X.\"}}}
X.\"{{{  shift
X.I
X.IP shift
Xswitches to shifting mode.  Every time smartlog runs on the logfile, the
Xarchives will be shifted one position (archive.0+1...archive.n+1) and the
Xlogfile becomes archive.0.  There will be no SLA suffix in shifting mode.  If
Xnot in shifting mode, there will be only one archive where a delimiter
Xseperates the generations.
X.\"}}}
X.\"{{{  comp(ress)
X.I
X.IP comp(ress)
Xif set, the archive will be compressed.  When used with \fIshift\fP an integer
Xvalue is interpreted as the FIRST archive to be compressed, otherwise all
Xarchives will be compressed.  You can turn this on or off as you like, archives
Xare handled pertinently.
X.\"}}}
X.\"{{{  arch(ive)
X.I
X.IP arch(ive)
Xthis defines an alternate archive name instead of the default.  To this name no .SLA
Xsuffix will be appended.
X.br
XWithin \fIlogfile\fP definition-lines you may use \fIarch=*whatever\fP which will
Xappend \fIwhatever\fP to the current (global) \fIarch\fP-setting.
X.\"}}}
X.\"{{{  dir
X.I
X.IP dir
Xthis defines another archive-dir instead of the default /var/log.
X.\"}}}
X.\"{{{  bsh
X.I
X.IP bsh
Xthis defines a sh-command which will be executed BEFORE any action.
X.\"}}}
X.\"{{{  ash
X.I
X.IP ash
Xthis defines a sh-command which will be executed AFTER any action.
X.\"}}}
X.\"{{{  nsh
X.I
X.IP nsh
Xthis defines a sh-command which will be executed if NO action is performed.
XThis happens when the logfile has a size below \fIsize\fP bytes.
X.\"}}}
X.\"{{{  tmp
X.I
X.IP tmp
Xselects other tmp-file or tmp-directory.  If you assigned a path to a filename
Xit will be used otherwise \fItmp\fP/smartlog.$$ will be used for temporary data.
X.\"}}}
X.\"{{{  date
X.I
X.IP date
Xthis defines another value for date, what about `/bin/date +%x`?
X.\"}}}
X.\"{{{  zip
X.I
X.IP zip
Xdefines compressing binary instead of the default.  You have to uncompress
Xarchives manually if you changed the compress-binary, because internal
Xhandling would fail on different compress extensions.
XIf you do not uncompress files manually you will get multiple archives with the
Xsame name but different extensions.  But usually you select your favourite
Xcompress binary once and use it forever.
X.\"}}}
X.\"{{{  zap
X.I
X.IP zap
Xdefines uncompressing binary (should correspond to \fIzip\fP-field).
X.\"}}}
X.\"{{{  ext
X.I
X.IP ext
Xselects a new extension which is appended to compressed archives.  If set to
X\fIauto\fP it will be set according to the given compress binary.  First \fIsmartlog\fP
Xtries to determine the extension created by \fIzip\fP, if this fails \fIext\fP
Xwill become .Z for compress, .gz for gzip, .z for zip, .C for compact, .F for freeze
Xor .SLAZ if none of those matches.
X.br
XUsing \fIauto\fP is very useful if you want to work with different compress-binaries.
XIf you use only one, you'd better set \fIext\fP explicitely to save time.
X.br
XYou may use any extension you want, compressing and uncompressing work suffix-independent.
X.br
XIf you change the compress-extension you have to uncompress all archives manually (see \fIzip\fP).
X.\"}}}
X.\"{{{  size
X.I
X.IP size
Xonly logfiles greater or equal \fIsize\fP-bytes will be archived.
X.\"}}}
X.\"{{{  DEFAULTS
X.I
X.IP DEFAULTS
Xmake the current settings the defaults (USE WITH CARE!).
X.\"}}}
X.\"{{{  additional stuff
X.br
X
XYou must not use any quotes, space or tab within assignments, except
X\fIdate, bsh, ash\fP and \fInsh\fP fields.
X
XFor \fIbsh, ash, nsh\fP and \fIarch\fP \fInone\fP is valid to unset these fields.
XFor \fIext\fP \fIauto\fP can be used to force \fIsmartlog\fP to determine
Xthe compress-extension on its own.
X
XValid assignments for \fIlocal, shift\fP and \fIcomp(ress)\fP
Xare any words starting with one of [yYnN] (e.g.  local=yes, local=y,
Xlocal=Yabadabadoo, local=NEVER).  Simple occurance of the keyword equals [yY].
X
XHashes (#) introduce comments. Blank lines may be used as well to make the
Xrc-files more readable.
X.\"}}}
X.\"}}}
X.\"{{{  examples
X.SH EXAMPLES
X.I var=value
X.br
X# all assignments are local in the next line
X.br
X\fBlogfile=/doug/adams/hgttg:var=value:var=:var=\fP
X.br
X# the next lines reset var to the default (flexible syntax)
X.br
X\fBvar=\fP
X.br
X\fBvar=def\fP
X.br
X\fBvar=default\fP
X.br
XFor a detailed description have a look at >>>sm_path<<</rc.(sample|bytewurm).
X.\"}}}
X.\"{{{  environment
X.SH ENVIRONMENT
X\fBsmartlog\fP requires \fIHOME\fP, especially when invoked via \fIcron\fP
Xyou have to make sure \fIHOME\fP is set properly.
X.\"}}}
X.\"{{{  files
X.SH FILES
X.IP >>>sm_path<<</smartlog
Xmain program
X.IP >>>sm_path<<</smartlog.awk
Xrc-file parser
X.IP >>>sm_path<<</smartlog.sh
Xdoes the real work
X.IP >>>sm_path<<</rc.sample
Xsome examples
X.IP >>>sm_path<<</rc.bytewurm
Xthe smartlogrc for my own system
X
X.IP $HOME/.smartlog/smartlogrc
Xusers' personal rc-file
X.IP $HOME/.smartlog/logfile
Xusers' logfile of smartlog-activity
X.\"}}}
X.\"{{{  conforming to
X.SH "CONFORMING TO"
XPOSIX
X.\"}}}
X.\"{{{  notes
X.SH NOTES
XArchives are converted if you switch between standard and shifting mode.
XOverhanging shift-archives and generations will be deleted (depending on
X\fIhold\fP). This will NOT work if you changed \fIlocal\fP or \fIarch\fP, too.
XConverting will fail on a changed \fIext\fP-value as well, see \fIzip\fP
X
XIf \fIlogfile\fP is the first parameter in a line any definition in the same
Xline seperated with a colon will be used for this logfile only.
XFor the next lines the previous values will be active again.  You may use the
Xdefault for any value by using \fIvar=\fP or \fIvar=def(ault)\fP in the
Xlogfile-line.
X
XIf a variable is set more than once in a \fIlogfile\fP-line the last value will
Xbe used.
X
XIf you use \fIhold=value\fP within a \fIlogfile\fP-line you may simply write
Xsomething like \fIlogfile=/do/not/panic:14\fP
X
XThere will be no operation on logfile and archives if the logfile is no regular
Xfile or has a size lower than \fIsize\fP-bytes; if set \fInsh\fP will be
Xexecuted then.
X
XAfter archiving it the logfile will be cleared (well, the whole stuff wouldn't make any sense if not :-).
XAny archive will get the ownership, grouppermission and modemask of the original logfile.
X
XUsing absolute pathes in smartlogrc (for \fIlogfile, zip, zap, dir, tmp\fP and \fIdate\fP)
Xis highly recommended.
X.\"}}}
X.\"{{{  warnings
X.SH WARNINGS
XYou must not use identical archivenames in the same directory!
X(The archivename does NOT include Suffices or shiftlog-extensions!)
XDisobeying will result in panic-exits or corrupt archives.
XTake extreme care if you set \fIarch\fP, make sure it will not be active
Xfor the wrong group of logfiles.
X
XYou MUST uncompress all your archives if you change any of the
X\fIzip, zap\fP or \fIext\fP-fields, see \fIzip\fP.
XIf you don't, smartlog will definitely produce corrupt archives.
XI hope to get rid of that in future versions but internal
Xhandling is hard when the optional settings have changed.
X.\"}}}
X.\"{{{  diagnostics
X.SH DIAGNOSTICS
X\fBsmartlog\fP has very detailed error messages. Initial errors such as missing
Xfiles etc. will be printed to stderr and \fBsmartlog\fP exits back to the shell.
XErrors occuring during work will be reported in the logfile ($HOME/.smartlog/logfile).
XSince error messages are self explaining I will list only the worst one with
Xsome suggestions to fix the trouble.
X
X.I
X.IP "double archive file1 & file2"
Xarchives with the same basename exist in the same place,
Xremove one of them or use different directories.
XAn intelligent \fIarch\fP setting may help you up as well.
XThe double-check routines are *very* rough, tell me about trouble.
X.PP
X
XIf you get a \fBcat\fP-usage message, you'll have to change the
X\fBcat\fP assignment in smartlog.sh. It includes \fI\--\fP to make
Xsure it will not get confused on a given \fI-\fP, delete the \fI--\fP and
Xmake sure no file will start with a \fI-\fP.
XProbably this will never happen.
X.\"}}}
X.\"{{{  authors
X.br
X.SH AUTHORS
Xsmartlog (c) 1994 was written by
X
X.I Michael Weber:
Xidea, realisation and main coordination
X.br
X    bytewurm@pandora.oche.de
X.br
X
X.I Wolfgang Stumvoll:
Xawk-parser, getmode, general advice
X.br
X    stumvoll@pool.informatik.rwth-aachen.de
X.br
X
X.I Stephen R. van den Berg:
Xshiftlog-routines, general advice
X.br
X    berg@pool.informatik.rwth-aachen.de
X.\"}}}
X.\"{{{  see also
X.SH "SEE ALSO"
X>>>sm_path<<</smartlog.def
X.br
X>>>sm_path<<</rc.sample, >>>sm_path<<</rc.bytewurm
X.br
Xor have a look at the scripts if you dare :-)
X.\"}}}
END_OF_FILE
if test 10731 -ne `wc -c <'smartlog/smartlog.1'`; then
    echo shar: \"'smartlog/smartlog.1'\" unpacked with wrong size!
fi
# end of 'smartlog/smartlog.1'
fi
if test -f 'smartlog/smartlog.awk' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'smartlog/smartlog.awk'\"
else
echo shar: Extracting \"'smartlog/smartlog.awk'\" \(10085 characters\)
sed "s/^X//" >'smartlog/smartlog.awk' <<'END_OF_FILE'
X#
X# smartlog >>>version<<<
X# (c) 1994 by Michael Weber
X#
X# original smartlog.awk written by Wolfgang Stumvoll
X# (modified and extended)
X#
X
X#{{{}}}
X#{{{  startup
XBEGIN { 
X   SCRIPT=">>>sm_path<<</smartlog.sh"
X   FS=":"
X   ORIGIN=""
X#   {{{  set emergency defaults
X   hold_def=hold_wrk="14"
X   local_def=local_wrk="local=no"
X   shift_def=shift_wrk="shift=no"
X   comp_def=comp_wrk="comp=no"
X   arch_def=arch_wrk="arch='none'"
X   ash_def=ash_wrk="ash=none"
X   bsh_def=bsh_wrk="bsh=none"
X   nsh_def=nsh_wrk="nsh=none"
X   zip_def=zip_wrk="zip=/bin/compress"
X   zap_def=zap_wrk="zap=/bin/uncompress"
X   ext_def=ext_wrk="ext=auto"
X   dir_def=dir_wrk="dir='/var/log'"
X   tmp_def=tmp_wrk="tmp='/tmp'"
X   date_def=date_wrk="date=`/bin/date`"
X   size_def=size_wrk="0"
X#   }}}
X   if (verbose>0)
X      SCRIPT=SCRIPT" -v"
X}
X#}}}
X#{{{  verbose comment
Xverbose==2 {
X   if (file!=FILENAME) {
X      file=FILENAME
X      print("handling file "file) >>LOG
X   }
X   print("handling command '"$0"'") >>LOG
X}
X#}}}
X#{{{  prepare lines for parsing
X/^[ 	]*(#.*)?$/ { next }                          # skip comment/blank lines
X
X#
X# get a copy for working and cut trailing blanks
X# using sub("[ 	]*$","") would be nice but it does not work
X# because this stupid thing cuts off the stringterminator as well :-(
X# so we have to use the WRK-crutch...
X#
X{ WRK=$0
X  l=length(WRK)
X  while(match(substr(WRK,l,1),"[    ]")) {
X    l=l-1
X    WRK=susbtr(WRK,l)
X  }
X}
X
XWRK~/^[ 	]*/ { sub("[ 	]*","",WRK) }            # cut leading blanks
XWRK~/^.*[^\\]#.*/ { sub("[      ]*[^\\\\]#.*","",WRK) }  # cut inline comments
XWRK~/^.*[\\]#.*/ { gsub("[\\\\]#","#",WRK) }             # handle quoted hashes
X#}}}
X#{{{  overwrite defaults
X#{{{  change hold default
XWRK~/^hold=(def(ault)?)?$/ { hold_wrk=hold_def;next }
XWRK~/^hold=[0-9]+$/ { hold_wrk=WRK;next }
XWRK~/^[0-9]+$/ { hold_wrk="hold="WRK;next }
X#}}}
X#{{{  change local default
XWRK~/^local=(def(ault)?)?$/ { local_wrk=local_def;next }
XWRK~/^local=[nN]/ { local_wrk="local=no";next }
XWRK~/^local(=[yY].*)?$/ { local_wrk="local=yes";next }
X#}}}
X#{{{  change shift default
XWRK~/^shift=(def(ault)?)?$/ { shift_wrk=shift_def;next }
XWRK~/^shift=[nN]/ { shift_wrk="shift=no";next }
XWRK~/^shift(=[yY].*)?$/ { shift_wrk="shift=yes";next }
X#}}}
X#{{{  change comp default
XWRK~/^comp(ress)?=(def(ault)?)?$/ { comp_wrk=comp_def;next }
XWRK~/^comp(ress)?=[0-9]+$/ { comp_wrk="comp="substr(WRK,1+match(WRK,"="));next }
XWRK~/^comp(ress)?=[nN]/ { comp_wrk="comp=no";next }
XWRK~/^comp(ress)?(=[yY].*)?$/ { comp_wrk="comp=yes";next }
X#}}}
X#{{{  change arch default
XWRK~/^arch(ive)?=(def(ault)?)?$/ { arch_wrk=arch_def;next }
XWRK~/^arch(ive)?=[^'"`* 	]+$/ { arch_wrk="arch='"substr(WRK,1+match(WRK,"="))"'";next }
X#}}}
X#{{{  change ash default
XWRK~/^ash=(def(ault)?)?$/ { ash_wrk=ash_def;next }
XWRK~/^ash=/ {
X   v=substr(WRK,5)
X#   {{{  quote text
X   for (of=1;;of=of+l+9) {
X      l=match(substr(v,of),"'")
X      if (l==0)
X         break
X      v=substr(v,1,of+l-2)"'\\'\\\\\\'\\''"substr(v,of+l)
X   }
X#   }}}
X   ash_wrk="ash='"v"'"
X   next
X}
X#}}}
X#{{{  change bsh default
XWRK~/^bsh=(def(ault)?)?$/ { bsh_wrk=bsh_def;next }
XWRK~/^bsh=/ {
X   v=substr(WRK,5)
X#   {{{  quote text
X   for (of=1;;of=of+l+9) {
X      l=match(substr(v,of),"'")
X      if (l==0)
X         break
X      v=substr(v,1,of+l-2)"'\\'\\\\\\'\\''"substr(v,of+l)
X   }
X#   }}}
X   bsh_wrk="bsh='"v"'"
X   next
X}
X#}}}
X#{{{  change nsh default
XWRK~/^nsh=(def(ault)?)?$/ { nsh_wrk=nsh_def;next }
XWRK~/^nsh=/ {
X   v=substr(WRK,5)
X#   {{{  quote text
X   for (of=1;;of=of+l+9) {
X      l=match(substr(v,of),"'")
X      if (l==0)
X         break
X      v=substr(v,1,of+l-2)"'\\'\\\\\\'\\''"substr(v,of+l)
X   }
X#   }}}
X   nsh_wrk="nsh='"v"'"
X   next
X}
X#}}}
X#{{{  change zip default
XWRK~/^zip=(def(ault)?)?$/ { zip_wrk=zip_def;next }
XWRK~/^zip=[^ 	'"`]+$/ { zip_wrk="zip='"substr(WRK,5)"'";next }
X#}}}
X#{{{  change zap default
XWRK~/^zap=(def(ault)?)?$/ { zap_wrk=zap_def;next }
XWRK~/^zap=[^ 	'"`]+$/ { zap_wrk="zap='"substr(WRK,5)"'";next }
X#}}}
X#{{{  change ext default
XWRK~/^ext=(def(ault)?)?$/ { ext_wrk=ext_def;next }
XWRK~/^ext=[^ 	'"`]+$/ { ext_wrk="ext='"substr(WRK,5)"'";next }
X#}}}
X#{{{  change dir default
XWRK~/^dir=(def(ault)?)?$/ { dir_wrk=dir_def;next }
XWRK~/^dir=[^ 	'"`]+$/ { dir_wrk="dir='"substr(WRK,5)"'";next }
X#}}}
X#{{{  change tmp default
XWRK~/^tmp=(def(ault)?)?$/ { tmp_wrk=tmp_def;next }
XWRK~/^tmp=[^ 	'"`]+$/ { tmp_wrk="tmp='"substr(WRK,5)"'";next }
X#}}}
X#{{{  change date default
XWRK~/^date=(def(ault)?)?$/ { date_wrk=date_def;next }
XWRK~/^date=[^ 	]+/ {
X   v=substr(WRK,6)
X#   {{{  quote text
X   for (of=1;;of=of+l+9) {
X      l=match(substr(v,of),"'")
X      if (l==0)
X         break
X      v=substr(v,1,of+l-2)"'\\'\\\\\\'\\''"substr(v,of+l)
X   }
X#   }}}
X   date_wrk="date='"v"'"
X   next
X}
X
X#}}}
X#{{{  change size default
XWRK~/^size=(def(ault)?)?$/ { size_wrk=size_def;next }
XWRK~/^size=[0-9]+$/ { size_wrk=WRK;next }
X#}}}
X#{{{  DEFAULTS
XWRK~/^DEFAULTS/ {
X   hold_def=hold_wrk
X   local_def=local_wrk
X   shift_def=shift_wrk
X   comp_def=comp_wrk
X   arch_def=arch_wrk
X   ash_def=ash_wrk
X   bsh_def=bsh_wrk
X   nsh_def=nsh_wrk
X   zip_def=zip_wrk
X   zap_def=zap_wrk
X   ext_def=ext_wrk
X   dir_def=dir_wrk
X   tmp_def=tmp_wrk
X   date_def=date_wrk
X   size_def=size_wrk
X   next
X}
X#}}}
X#}}}
X#{{{  check and parse logfile-lines
XWRK~/^logfile=[^:'"` 	]+[ 	]*(:[ 	]*(\
X((local|shift|comp(ress)?)(=([ynYN][^'"` 	]*)?)?)|\
X(((comp(ress)?|size|hold)=)?[0-9]+)|\
X((z[ia]p|ext|dir|tmp|arch(ive)?)=([^'"` 	]*)?)|\
X(([abn]sh|date)(=(.+)?))\
X))*$/ {
X#  {{{  parse line and assign arguments
X#  {{{  default init
X  hold=hold_wrk
X  local=local_wrk
X  shift=shift_wrk
X  comp=comp_wrk
X  arch=arch_wrk
X  ash=ash_wrk
X  bsh=bsh_wrk
X  nsh=nsh_wrk
X  zip=zip_wrk
X  zap=zap_wrk
X  ext=ext_wrk
X  dir=dir_wrk
X  tmp=tmp_wrk
X  date=date_wrk
X  size=size_wrk
X#  }}}
X  for (i=1;i<=NF;i++) {
X     v=$i
X#     {{{  cut leading/trailing blanks
X     sub("^[ 	]*","",v)
X
X     l=length(v)
X     while(match(substr(v,l,1),"[ 	]")) {
X       l=l-1
X       WRK=susbtr(v,l)
X     }
X#     }}}
X#     {{{  quote text
X     for (of=1;;of=of+l+9) {
X        l=match(substr(v,of),"'")
X        if (l==0)
X           break
X        v=substr(v,1,of+l-2)"'\\'\\\\\\'\\''"substr(v,of+l)
X     }
X#     }}}
X     if (i==1)
X        logfile="logfile="DQ substr(v,9) DQ
X     else {
X#        {{{  set hold arg
X        if (match(v,"^hold=(def(ault)?)?$"))
X           hold=hold_def
X        else if (match(v,"^hold=[0-9]+$"))
X           hold=v
X        else if (match(v,"^[0-9]+$"))
X           hold="hold="v
X#        }}}
X#        {{{  set local arg
X        if (match(v,"^local=(def(ault)?)?$"))
X           local=lcoal_def
X        else if (match(v,"^local=[nN]"))
X           local=local"local=no"
X        else if (match(v,"^local(=[yY].*)?$"))
X           local="local=yes"
X#        }}}
X#        {{{  set shift arg
X        if (match(v,"^shift=(def(ault)?)?$"))
X           shift=shift_def
X        else if (match(v,"^shift=[nN]"))
X           shift="shift=no"
X        else if (match(v,"^shift(=[yY].*)?$"))
X           shift="shift=yes"
X#        }}}
X#        {{{  set comp arg
X        if (match(v,"^comp(ress)?=(def(ault)?)?$"))
X           comp=comp_def
X        else if (match(v,"^comp(ress)?=[nN]"))
X           comp="comp=no"
X        else if (match(v,"^comp(ress)?(=[yY].*)?$"))
X           comp="comp=yes"
X        else if (match(v,"^comp(ress)?=[0-9]+$"))
X           comp="comp="substr(v,1+match(v,"="))
X#        }}}
X#        {{{  set arch arg
X        if (match(v,"^arch(ive)?=(def(ault)?)?$"))
X           arch=arch_def
X        else if (match(v,"^arch(ive)?=\\*"))
X           arch=arch DQ substr(v,2+match(v,"=")) DQ
X        else if (match(v,"^arch(ive)?="))
X           arch="arch="DQ substr(v,1+match(v,"=")) DQ
X#        }}}
X#        {{{  set shell args
X        if (match(v,"^ash=(def(ault)?)?$"))
X           ash=ash_def
X        else if (match(v,"^ash="))
X           ash="ash=\\''"substr(v,5)"'\\'"
X
X        if (match(v,"^bsh=(def(ault)?)?$"))
X           bsh=bsh_def
X        else if (match(v,"^bsh="))
X           bsh="bsh=\\''"substr(v,5)"'\\'"
X
X        if (match(v,"^nsh=(def(ault)?)?$"))
X           nsh=nsh_def
X        else if (match(v,"^nsh="))
X           nsh="nsh=\\''"substr(v,5)"'\\'"
X#        }}}
X#        {{{  set zip arg
X        if (match(v,"^zip=(def(ault)?)?$"))
X           zip=zip_def
X        else if (match(v,"^zip="))
X           zip="zip='"substr(v,5)"'"
X#        }}}
X#        {{{  set zap arg
X        if (match(v,"^zap=(def(ault)?)?$"))
X           zap=zap_def
X        else if (match(v,"^zap="))
X           zap="zap='"substr(v,5)"'"
X#        }}}
X#        {{{  set ext arg
X        if (match(v,"^ext=(def(ault)?)?$"))
X           ext=ext_def
X        else if (match(v,"^ext="))
X           ext="ext='"substr(v,5)"'"
X#        }}}
X#        {{{  set dir arg
X        if (match(v,"^dir=(def(ault)?)?$"))
X           dir=dir_def
X        else if (match(v,"^dir="))
X           dir="dir=\\''"substr(v,5)"'\\'"
X#        }}}
X#        {{{  set tmp arg
X        if (match(v,"^tmp=(def(ault)?)?$"))
X           tmp=tmp_def
X        else if (match(v,"^tmp="))
X           tmp="tmp=\\''"substr(v,5)"'\\'"
X#        }}}
X#        {{{  set date arg
X        if (match(v,"^date=(def(ault)?)?$"))
X           date=date_def
X        else if (match(v,"^date="))
X           date="date='"substr(v,6)"'"
X#        }}}
X#        {{{  set size arg
X        if (match(v,"^size=(def(ault)?)?$"))
X           size=size_def
X        else if (match(v,"^size=[0-9]+$"))
X           size=v
X#        }}}
X     }
X  }
X#  }}}
X#  {{{  create commandline and call smartlog.sh
X  cmd=SCRIPT" "DQ logfile DQ" "DQ hold DQ" "DQ local DQ" "DQ shift DQ" "DQ comp DQ" "DQ arch DQ" "DQ bsh DQ" "DQ nsh DQ" "DQ ash DQ" "DQ zip DQ" "DQ zap DQ" "DQ ext DQ" "DQ dir DQ" "DQ tmp DQ" "DQ date DQ" "DQ size DQ
X  if (verbose==2)
X     print("calling '"cmd"'") >>LOG
X
X  close(LOG)
X
X  if (noexec==1)
X     e=0
X  else
X     e=system(cmd)
X
X  if (e!=0) {
X     print("exit code "e) >>LOG
X     if (verbose==0)
X        print("error while executing: "cmd) >>LOG
X#  }}}
X  }
X  next
X}
X#}}}
X#{{{  complain about invalid lines
X{
X   print("Invalid line in "FILENAME", line "FNR": "$0) >>LOG
X   next
X}
X#}}}
END_OF_FILE
if test 10085 -ne `wc -c <'smartlog/smartlog.awk'`; then
    echo shar: \"'smartlog/smartlog.awk'\" unpacked with wrong size!
fi
# end of 'smartlog/smartlog.awk'
fi
if test -f 'smartlog/smartlog.def' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'smartlog/smartlog.def'\"
else
echo shar: Extracting \"'smartlog/smartlog.def'\" \(1547 characters\)
sed "s/^X//" >'smartlog/smartlog.def' <<'END_OF_FILE'
X#
X# smartlog >>>version<<<
X# (c) 1994 by Michael Weber
X#
X
X#
X# these values are the defaults, handle with extreme care
X# if you assign illegal values or leave them empty, builtin emergency
X# defaults will be used which are the same as in this "virgin" default-file
X# newline after "=" result in assigning the current default where
X# var=def or var=default would have the same effect
X#
X
X# we do not archive empty files (but all greater or equal 1 byte)
Xsize=1
X
X# default is to hold 14 generations of logfiles (usually days)
Xhold=14
X
X# default archive-dir
Xdir=/var/log
X
X# default is to use the archive-dir $dir
Xlocal=no
X
X# default is to use standard (one-file) archives
Xshift=no
X
X# default is not to compress archives
Xcomp=no
X
X# default alternative archive is, of cause, none
Xarch=none
X
X# default command to execute BEFORE archiving is none
Xbsh=none
X
X# default command to execute AFTER archiving is none
Xash=none
X
X# default command to execute on NO action is none
Xnsh=none
X
X# default is to use compress, should be installed everywhere
Xzip=/bin/compress
Xzap=/bin/uncompress
X
X# if ext=auto smartlog will try to determine ZIP's suffix, if this doesn't
X# work ext will become .Z for compress, .gz for gzip, .zip for zip,
X# .C for compress and .F for freeze if none of those matches it becomes .SLAZ
Xext=auto
X
X# archives and the logfile look very nice with `/bin/date +%x`
X# but it may be not implemented everywhere
Xdate=`/bin/date`
X
X# this keyword makes all current settings the default which can be used
X# using "var= or var=def(ault)"
XDEFAULTS
X#{{{}}}
END_OF_FILE
if test 1547 -ne `wc -c <'smartlog/smartlog.def'`; then
    echo shar: \"'smartlog/smartlog.def'\" unpacked with wrong size!
fi
# end of 'smartlog/smartlog.def'
fi
if test -f 'smartlog/smartlog.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'smartlog/smartlog.sh'\"
else
echo shar: Extracting \"'smartlog/smartlog.sh'\" \(12143 characters\)
sed "s/^X//" >'smartlog/smartlog.sh' <<'END_OF_FILE'
X#! /bin/sh
X: &&O='cd .' || exec /bin/sh "$0" $argv:q # we're in a csh, feed myself to sh
X$O || exec /bin/sh "$0" "$@"              # we're in a buggy zsh
X
X#
X# smartlog >>>version<<<
X# (c) 1994 by Michael Weber
X#
X
X#{{{}}}
X#{{{  init
X#{{{  parameters
X#{{{  check for -v
Xif [ x"$1" = x"-v" ]
Xthen
X  verbose="y"
X  shift
Xelse
X  verbose=""
Xfi
X#}}}
Xeval "$@"
X#}}}
X#{{{  variables
Xsm_path=">>>sm_path<<<"
Xsm_user="$HOME/.smartlog"
Xsm_logfile="$sm_user/logfile"
Xsm_get="$sm_path/getmode"
X
XLS=">>>ls<<<"
XRM=">>>rm<<< -f"
XMV=">>>mv<<< -f"
XCAT=">>>cat<<< --"
XSED=">>>sed<<<"
XAWK=">>>awk<<<"
XEXPR=">>>expr<<<"
XGREP=">>>grep<<<"
XCHOWN=">>>chown<<<"
XCHGRP=">>>chgrp<<<"
XCHMOD=">>>chmod<<<"
XDIRNAME=">>>dirname<<<"
X
X[ "$local" = "no" ] && local=""
X[ "$shift" = "no" ] && shift=""
X[ "$comp" = "no" ] && comp=""
X[ "$ash" = "none" ] && ash=""
X[ "$bsh" = "none" ] && bsh=""
X[ "$nsh" = "none" ] && nsh=""
X[ "$arch" = "none" ] && arch=""
X
Xlog=""
Xmagiclog=""
Xsuffix=".SLA"
Xsuffix2="$suffix"   # needed for comparisons
Xidentifier="##### SLA #####"
X
Xtrap '$RM "$tmp"; panic "TRAP-EXIT"' 1 2 3 15
X#}}}
X
X#{{{  assign()
Xassign()
X{ fuid="$1"
X  fgid="$2"
X  fsize="$3"
X  fmode="$4"
X}
X#}}}
X#{{{  calc()
Xcalc()
X{ if [ -z "$EXPR" ]
X  then
X    result=$[$*]
X  else
X    result=`$EXPR $*`
X  fi
X}
X#}}}
X#{{{  compress()
Xcompress()
X{ if [ "$comp" -a ! -z "$ext" ]
X  then
X    $zip <"$1" >"$1$ext"
X    $RM "$1"
X    restore "$1$ext"
X  fi
X}
X#}}}
X#{{{  ftouch()
X#
X# emulating "touch" using "cat"
X# why to use more systools than absolutely necessary?
X#
Xftouch()
X{ $CAT </dev/null >"$1"
X}
X#}}}
X#{{{  move()
X#
X# shiftlog function
X#
Xmove()
X{ if [ -f "$1" ]
X  then
X    $MV "$1" "$2"
X    compress "$2"
X  elif [ -f "$1$ext" ]
X    then
X      $MV "$1$ext" "$2$ext"
X      restore "$2$ext"
X  fi
X}
X#}}}
X#{{{  panic()
Xpanic()
X{ echo "$date: Panic: $*." >>$sm_logfile
X  $RM "$tmp" # clear tmpfile
X  exit 1
X}
X#}}}
X#{{{  restore()
Xrestore()
X{ [ -f "$1" ] || ftouch "$1"
X  $CHOWN "$fuid" "$1"
X  $CHGRP "$fgid" "$1"
X  $CHMOD "$fmode" "$1"
X}
X#}}}
X#{{{  uncompress()
Xuncompress()
X{ if [ -r "$1$ext2" ]
X  then
X    $zap <"$1$ext2" >"$1"
X    $RM "$1$ext2"
X    restore "$1"
X  fi
X}
X#}}}
X#{{{  warn()
Xwarn()
X{ echo "$date: Warning: $*." >> $sm_logfile
X}
X#}}}
X
X#{{{  check parameter integrity
X#{{{  check/set tmp
Xif [ -d "$tmp" ]
Xthen
X  [ -w "$tmp" ] || panic "$tmp is not writable"
X  tmp="$tmp/smartlog.$$"
Xfi
X$RM "$tmp" # just to be sure we have no tmp-file lazing around
X#}}}
X#{{{  check logfile and archdir
X[ -f "$logfile" ] || panic "$logfile is not a regular file or does not exist"
X[ -r "$logfile" ] || panic "$logfile is not readable"
X[ -f "$dir" ] && panic "archive dir $dir is a regular file"
X[ -w "$dir" ] || panic "archive dir $dir does not exist or is unwritable"
X#}}}
X#{{{  check zip/zap
X[ "x`(echo 'foo' | $zip | $zap) 2>/dev/null`" != "xfoo" ] && panic "zip/zap do not exist or are incompatible"
X#}}}
X#{{{  set ext if necessary
X#
X# "none" is for compatibility to prior versions (2.1 or below)
X# "auto" sounds more logical, ain't it?!
X#
Xif [ x"$ext" = x"auto" -o x"$ext" = x"none" ]
Xthen
X#  {{{  compress a file and look for the suffix
X#  
X#   a file called "99999" should not collide with any other
X#   (hopefully :-)
X#  
X  echo "--------------------------------------------------------\
X        Some programs do not compress empty or very small files.\
X        But this size should be ok, even for a dumb 'compress'.
X        --------------------------------------------------------" > "99999"
X  $zip "99999" 2>&1 >/dev/null
X  ext=`$LS 99999* | $SED "s/9//g"`
X  $RM 99999*
X#  }}}
X#  {{{  if $zip gave no hint, we try something else
X  if [ -z "$ext" ]
X  then
X    case $zip in
X      *compress) ext=".Z";;
X      *gzip) ext=".gz";;
X      *zip) ext=".zip";;
X      *freeze) ext=".F";;
X      *compact) ext=".C";;  # just for nostalgia :-)
X      *) ext=".SLAZ";warn "cannot determine suffix for $zip-$zap, using .SLAZ";;
X    esac
X  fi
X#  }}}
Xfi
Xext2="$ext" # needed for comparisons
X#}}}
X#}}}
X#{{{  get the files' mode and size
X#
X# assign will set fuid, fgid and fmode to the
X# files' permissions which will be used to restore
X# a logfiles' original permissions and ownership
X# fsize wil be set to the files' size
X#
Xassign `$sm_get $logfile`
X#}}}
X#}}}
X
Xif [ "$fsize" -ge "$size" ]
Xthen
X#  {{{  preparatory work
X#  {{{  what is the archives' name?
X#  {{{  are we in shifting-mode?
X  [ "$shift" ] && suffix=""   # yep, no suffix needed
X#  }}}
X  if [ -z "$arch" ]
X  then
X#    {{{  no alternative archive given
X    if [ "$local" ]
X    then
X      archive="$logfile"
X    else
X      archive="$dir/"`echo "$logfile" | $SED -e "s/\//./g" -e "/./s/.//"`
X    fi
X    archive2="$archive" # save archive without suffix
X    archive="$archive$suffix"
X#    }}}
X  else
X#    {{{  alternative archive given
X    if [ "$local" ]
X    then
X      archive=`$DIRNAME "$logfile"`"/$arch"
X    else
X      archive="$dir/$arch"
X    fi
X    archive2="$archive" # save archive without suffix
X#    }}}
X  fi
X#  }}}
X#  {{{  checkups
X#  {{{  archivepath
X  [ ! -w `$DIRNAME $archive` ] && panic "invalid archive-path ($archive)"
X#  }}}
X#  {{{  logfile==archive
X  [ x"$archive" = x"$logfile" -a ! "$shift" ] && panic "archive and logfile are identical for $logfile"
X#  }}}
X#  {{{  double archives
X#  
X#   these checks are *very* rough
X#   but should suffice
X#  
X  [ -f "$archive" -a -f "$archive2$suffix2" -a \
X    x"$archive" != x"$archive2$suffix2" -a \
X    x"$archive" != x"$logfile" \
X  ] && panic "double archive $archive & $archive2$suffix2"
X
X  [ -f "$archive" -a -f "$archive2" -a \
X    x"$archive" != x"$archive2" -a \
X    x"$archive2" != x"$logfile" \
X  ] && panic "double archive $archive & $archive2"
X#  }}}
X#  }}}
X#  {{{  a present for archiving junkies
X#  
X#   if someone archives smartlog-archives (NO COMMENT!!!)
X#   we have to adapt the identifier and the delimiter
X#   this will even work for the archive of an archive of an archive ...
X#  
X  while [ `$GREP -c "$identifier" "$logfile"` -gt 0 ]
X  do
X    identifier="#####$identifier"    # grow identifier significantly
X  done
X
X  delimiter="$identifier=============== $date ==============="
X#  }}}
X#  }}}
X#  {{{  archiving routines
X#  {{{  bsh
X#  
X#   I know that two subshells are not going to win a cutie-prize
X#   but they make sure all parts will be processed correctly
X#  
X  [ ! -z "$bsh" ] && (($bsh 2>>"$sm_logfile") || warn "bsh: '$bsh' exited with status $?")
X#  }}}
X  if [ "$shift" ]
X  then
X#    {{{  shifting mode
X#    
X#     original shiftlog routines by Stephen R. van den Berg
X#     (modified)
X#    
X#    {{{  convert standard-archive if any
X#    {{{  determine archive to convert
X    if [ "$arch" ]
X    then
X      convarch="$archive"
X    else
X      convarch="$archive$suffix2"
X    fi
X    uncompress "$convarch"
X#    }}}
X    if [ -f "$convarch" ]
X    then
X#      {{{  panic on existing shift-archives
X#      
X#       this will kick you out if you somehow made it to create
X#       standard and shift archives with the same name
X#      
X      [ -f "$archive2.0" ] && panic "convert: $archive2.* already exist"
X#      }}}
X#      {{{  awk does it
X      $AWK -v IDENT="$identifier" -v DEST="$archive2"\
X        'BEGIN { i=-1; ok=0 }\
X        index($0,IDENT)==1 { close(DEST"."i); i=i+1; ok=1; next }\
X        ok==1 { print >>DEST"."i }' <"$convarch"
X#      }}}
X      $RM "$convarch"
X#      {{{  give all archives the right mode
X      i=0
X      while [ -f $archive.$i ]
X      do
X        restore "$archive.$i"
X        calc $i + 1; i=$result
X      done
X#      }}}
X      magiclog=$magiclog"/$convarch split into $i files"
X    fi
X#    }}}
X#    {{{  compress || !compress
X    if [ "$comp" ]
X    then
X      case "$comp" in
X        *[!0-9]*) firstcomp=0;;  # no integer, compress all archives
X        *) firstcomp=$comp;; # interpret integer variables
X      esac
X    else
X      ext=""
X      firstcomp=0 # make sure integer comparisons won't fail
X    fi
X#    }}}
X#    {{{  cycle old archives
X    i="$hold"  # start with the HIGHEST value (=LAST archive)
X    while [ $i -gt 0 ]
X    do
X      calc $i - 1; ip=$result
X#      {{{  uncompress archive if necessary
X#      
X#       archive with minor numbers maybe compressed
X#       and we are uncompressing then now
X#      
X      [ -z "$ext" ] && uncompress "$archive.$ip"
X#      }}}
X      move "$archive.$ip" "$archive.$i"
X      [ $i = $firstcomp ] && ext=""  # no compression on minor numbers
X      i=$ip
X    done
X#    }}}
X#    {{{  move the logfile to the archive
X    move "$logfile" "$archive.0"
X    restore "$logfile"    # recreate $logfile with its exact permissions
X#    }}}
X#    {{{  kill overhanging shift-archives
X    calc $hold + 1; i=$result # we look for archives >max hold
X
X    while [ -f "$archive.$i" -o -f "$archive.$i$ext2" ]
X    do
X#      
X#       i know its not nice to remove both if one was detected,
X#       but it makes the stuff more readable
X#      
X      $RM "$archive.$i" "$archive.$i$ext2"
X      calc $i + 1; i=$result
X    done
X#    }}}
X#    }}}
X  else
X#    {{{  standard mode
X#    {{{  uncompress archive if any
X    uncompress "$archive"
X    uncompress "$archive2$suffix"
X#    }}}
X#    {{{  panic on existing standard AND shift archive
X#    
X#     this will kick you out if you somehow made it to create
X#     standard and shift archives with the same name
X#    
X    [ -f "$archive" -a -f "$archive2.0" ] && \
X      panic "convert: $archive already exists"
X#    }}}
X#    {{{  convert shift-archives if any
X    i=0
X    $RM "$tmp" # just to be sure
X    while [ -f "$archive2.$i" -o -f "$archive2.$i$ext2" ]
X    do
X#      {{{  collect archives in tmp-file
X      uncompress "$archive2.$i"
X      echo "$delimiter" >> "$tmp"
X      $CAT "$archive2.$i" >> "$tmp"
X      $RM "$archive2.$i"
X      calc $i + 1; i=$result
X#      }}}
X    done
X#    {{{  save stuff if we have some
X    if [ $i -gt 0 ]
X    then
X      $MV "$tmp" "$archive"
X      magiclog=$magiclog"/$i files collected"
X    fi
X#    }}}
X#    }}}
X#    {{{  restore archives' permissions or touch it
X    restore "$archive"
X#    }}}
X#    {{{  delete old entries
X    held=`$GREP -c "$identifier" "$archive" 2>/dev/null`
X    calc $held - $hold + 1
X
X    if [ $result -gt 0 ]
X    then
X#      {{{  awk call to cut the leading generations
X#      
X#       you wonder about the double DEL==0 line? makes is fast!
X#       the first one prints out the rest of the file
X#       the second one saves the delimiter of the first generation
X#       staying in the archive
X#      
X      $AWK -v IDENT="$identifier" -v DEL="$result"\
X       'BEGIN { DEL=DEL+1 }\
X        DEL==0 { print; next }\
X        index($0,IDENT)==1 { DEL=DEL-1 }\
X        DEL==0 { print }' <"$archive" >"$tmp"
X#      }}}
X      $MV "$tmp" "$archive" # move modified file back to origin
X    fi
X#    }}}
X#    {{{  collect archive and logfile in a new archive
X    echo "$delimiter" >> "$archive"
X    $CAT "$archive" "$logfile" > "$tmp"
X    $CAT </dev/null >"$logfile"  # this saves the logfiles' permissions
X    $MV "$tmp" "$archive"
X    restore "$archive"   # we want archives with logfile-permissions
X    compress "$archive"  # compress archive if necessary
X#    }}}
X#    }}}
X  fi
X#  {{{  ash
X  [ ! -z "$ash" ] && (($ash 2>>"$sm_logfile") || warn "ash: '$ash' exited with status $?")
X#  }}}
X#  }}}
X#  {{{  diagnostic output for verbose mode
X  if [ "$verbose" ]
X  then
X#    {{{  rig up output
X    log="$logfile ($fsize bytes) --> $archive (maxhold $hold)"
X    [ "$local" ] && log=$log"/local"
X    [ "$shift" ] && log=$log"/shift"
X    if [ "$comp" ]
X    then
X     log=$log"/compress"
X     [ "$shift" ] && log=$log" (first #$firstcomp)"
X    fi
X    [ "$bsh" ] && log=$log"/bsh='$bsh'"
X    [ "$ash" ] && log=$log"/ash='$ash'"
X    [ "$nsh" ] && log=$log"/(nsh='$nsh')"
X    log="$log$magiclog" # append info from automagical functions
X#    }}}
X    echo "$date: $log" >>"$sm_logfile"
X  fi
X#  }}}
Xelse
X#  {{{  file too small, execute nsh?
X  if [ "$size" = 1 ]
X  then
X    echo "$date: $logfile is empty." >>$sm_logfile
X  else
X    echo "$date: $logfile has size below $size bytes." >>$sm_logfile
X  fi
X  
X  if [ "$nsh" ]
X  then
X    echo "$date: executing '$nsh' instead." >>$sm_logfile
X    (($nsh 2>>"$sm_logfile") || warn "nsh: '$nsh' exited with status $?")
X  fi
X#  }}}
Xfi
X
X$RM "$tmp" # just to be *really* sure
X
Xexit 0
END_OF_FILE
if test 12143 -ne `wc -c <'smartlog/smartlog.sh'`; then
    echo shar: \"'smartlog/smartlog.sh'\" unpacked with wrong size!
fi
chmod +x 'smartlog/smartlog.sh'
# end of 'smartlog/smartlog.sh'
fi
echo shar: End of shell archive.
exit 0
