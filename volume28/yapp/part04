Newsgroups: comp.sources.unix
From: thalerd@quip.eecs.umich.edu (Dave Thaler)
Subject: v28i048: yapp - conferencing system (similar to PicoSpan), Part04/05
References: <1.770288965.8721@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: thalerd@quip.eecs.umich.edu (Dave Thaler)
Posting-Number: Volume 28, Issue 48
Archive-Name: yapp/part04

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 5)."
# Contents:  driver.c rfp.c sep.c
# Wrapped by thalerd@clippers.engin.umich.edu on Sat Jan 22 23:38:11 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'driver.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'driver.c'\"
else
echo shar: Extracting \"'driver.c'\" \(25131 characters\)
sed "s/^X//" >'driver.c' <<'END_OF_FILE'
X/* DRIVER.C */
Xstatic	char sccsid[] = "@(#)driver.c 1.2 94/01/20 (c)1993 thalerd";
X#include <stdio.h>
X#include <string.h>
X#include <stdlib.h>
X#include <ctype.h>
X#ifndef NeXT
X#include <unistd.h>
X#endif
X#include <sys/types.h>
X#include <sys/file.h>
X#include <sys/stat.h>
X#include <signal.h>
X#include <pwd.h>
X#include "config.h"
X#include "struct.h"
X#include "driver.h"
X#include "xalloc.h"
X#include "lib.h"
X#include "macro.h"
X#include "joq.h"
X#include "rfp.h"
X#include "change.h"
X#include "item.h" /* needed by sep.h */
X#include "sep.h"
X#include "help.h"
X#include "conf.h"
X#include "system.h"
X#include "files.h"
X#include "sum.h"   /* for refresh_list */
X#include "edbuf.h" /* for text_cmd_dispatch */
X#include "misc.h"  /* for misc_cmd_dispatch */
X
X/* GLOBAL VARS */
X
X/* Status info */
Xflag_t         flags =0;            /* user settable parameter flags */
Xunsigned char  mode  =M_OK;         /* input mode (which prompt)     */
Xflag_t         status=0;            /* system status flags           */
X
X/* Conference info */
Xshort   current = -1;              /* current index to cflist       */
Xshort   confidx = -1;              /* current index to conflist     */
Xshort   defidx  = -1;
Xshort   joinidx = -1;              /* current index to conflist     */
Xchar    confname[MAX_LINE_LENGTH]; /* name of current conference    */
Xchar  **cflist = (char **)0;       /* User's conflist               */
Xchar  **fw;                        /* List of FW's for current conf */
Xpartentry_t part[MAX_ITEMS];       /* User participation info       */
X
X/* System info */
Xchar    bbsdir[MAX_LINE_LENGTH];   /* Directory for bbs files       */
Xchar    helpdir[MAX_LINE_LENGTH];  /* Directory for help files      */
Xassoc_t conflist[MAX_LIST_LENGTH]; /* System table of conferences   */
Xshort   maxconf=0;                 /* maximum index to conflist     */
Xchar    hostname[MAX_LINE_LENGTH]; /* System host name */
X
X/* Info on the user */
Xuid_t   uid;                       /* User's UID                    */
Xchar    login[L_cuserid];          /* User's login                  */
Xchar    home[MAX_LINE_LENGTH];     /* User's home directory         */
Xchar    work[MAX_LINE_LENGTH];     /* User's work directory         */
X
X/* Item statistics */
Xstatus_t   st_glob;                /* statistics on current conference */
Xstatus_t   st_new;                 /* statistics on new conference to join */
Xsumentry_t sum[MAX_ITEMS];         /* items in current conference      */
Xresponse_t re[MAX_RESPONSES];      /* responses to current item        */
X
X/* Variables global to this module only */
Xstatic char cmdbuf[MAX_LINE_LENGTH];
X       char pipebuf[MAX_LINE_LENGTH];
X       char evalbuf[MAX_LINE_LENGTH];
Xstatic char *options="dulosnj:";    /* Command-line options          */
Xoption_t option[]={                /* User-definable flags          */
X/*  name,       mask,        default, */
X   "debug",     O_DEBUG,     DEFAULT_OFF,
X   "buffer",    O_BUFFER,    DEFAULT_ON,
X   "default",   O_DEFAULT,   DEFAULT_ON,
X   "observe",   O_OBSERVE,   DEFAULT_OFF,
X   "st_rip",    O_STRIP,     DEFAULT_OFF,
X   "so_urce",   O_SOURCE,    DEFAULT_ON,
X   "f_orget",   O_FORGET,    DEFAULT_ON,
X   "sta_y",     O_STAY,      DEFAULT_OFF,
X   "dot",       O_DOT,       DEFAULT_ON,
X   "ed_always", O_EDALWAYS,  DEFAULT_OFF,
X   "me_too",    O_METOO,     DEFAULT_ON,
X   "nu_mbered", O_NUMBERED,  DEFAULT_OFF,
X   "d_ate",     O_DATE,      DEFAULT_OFF,
X   "u_id",      O_UID,       DEFAULT_OFF,
X   "ma_iltext", O_MAILTEXT,  DEFAULT_OFF,
X   "autosave",  O_AUTOSAVE,  DEFAULT_OFF,
X   "verbose",   O_VERBOSE,   DEFAULT_OFF,
X   "scr_ibbler",O_SCRIBBLER, DEFAULT_OFF,
X   "sig_niture",O_SIGNITURE, DEFAULT_OFF,
X   "readonly",  O_READONLY,  DEFAULT_OFF
X};
X
Xvoid
Xopen_pipe()
X{
X   char *pager,*p;
X
X   /* Need to check if pager exists */
X   if (!(status & S_REDIRECT)) {
X      if (!pipebuf[0]) strcpy(pipebuf,expand("pager",DM_VAR));
X
X      /* Compress it a bit */
X      pager=pipebuf;
X      while (*pager && *pager==' ') pager++; /* skip leading/trailing spaces */
X      for (p=pager+strlen(pager)-1; *p==' ' && p>=pager; p--) *p='\0'; 
X      if (*pager=='"') {
X         pager++;
X         if (p>=pager && *p=='"') { *p='\0'; p--; }
X      }
X      if (*pager=='\'') {
X         pager++;
X         if (p>=pager && *p=='\'') { *p='\0'; p--; }
X      }
X
X      if (!(flags & O_BUFFER) 
X       || (pager[0] && (st_glob.outp =spopen(pager))==NULL))
X         pager[0]='\0';
X      if (!pager[0]) 
X         st_glob.outp =stdout;
X   }
X}
X
X/******************************************************************************/
X/* PRINT PROMPT FOR AN INPUT MODE                                             */
X/******************************************************************************/
Xvoid               /* RETURNS: (nothing) */
Xprint_prompt(mod)  /* ARGUMENTS:         */
Xunsigned char mod; /*    Input mode      */
X{ 
X   char *str;
X
X   switch(mod & M_MASK) {
X   case M_OK :  /* In a conference or not? */
X                str = (confidx<0) ? "noconfp" : "prompt";
X                break;
X   case M_RFP:  str = (st_glob.c_status & (CS_OBSERVER|CS_NORESPONSE))?
X                 "obvprompt":"rfpprompt";
X                break;
X   case M_TEXT: str="text";      break;
X   case M_JOQ:  str="joqprompt"; break;
X   case M_EDB:  str="edbprompt"; break;
X   }
X   if (flags & O_DEBUG) printf("!%s!\n",str);
X   confsep(str,confidx,&st_glob,part,1); /* expand seps & print */
X}
X
X/******************************************************************************/
X/* COMMAND LOOP: PRINT PROMPT & GET RESPONSE                                  */
X/******************************************************************************/
Xchar             /* RETURNS: 0 on eof, 1 else   */
Xget_command(def) /* ARGUMENTS:                  */
Xchar *def;       /*    Default command (if any) */
X{
X   char ok=1,inbuff[MAX_LINE_LENGTH],*inb;
X
X   if (status & S_INT) status &= ~S_INT; /* Clear interrupt */
X   if (status & S_REDIRECT) spclose(st_glob.outp );
X   if (cmdbuf[0]) strcpy(inbuff,cmdbuf);
X   else {
X      print_prompt(mode);
X      if (mode==M_OK) status &= ~S_STOP;
X   }
X   if (cmdbuf[0] || (ok = (ngets(inbuff,st_glob.inp)!=NULL))) {
X
X      /* Strip leading & trailing spaces */
X      for (inb=inbuff+strlen(inbuff)-1; inb>=inbuff && *inb==' '; inb--) *inb=0;
X      for (inb=inbuff; *inb==' '; inb++);
X
X      if (!*inb) ok = command(def,0);
X      else       ok = command(inb,0);
X   }
X   return ok;
X}
X
X/******************************************************************************/
X/* CLEAN UP MEMORY AND EXIT                                                   */
X/******************************************************************************/
Xvoid        /* RETURNS: (nothing) */
Xendbbs(ret) /* ARGUMENTS:         */
Xint ret;    /*    Exit status     */
X{
X   int i;
X
X   if (flags & O_DEBUG) printf("endbbs:\n");
X   if (confidx>=0) leave(0,(char**)0); /* leave current conference */
X
X   /* Free up space, etc */
X   for (i=0; i<maxconf; i++) {
X      xfree(conflist[i].name);
X      xfree(conflist[i].location);
X   }
X   for (i=0; i<MAX_RESPONSES; i++) {
X      if (re[i].login)    { xfree(re[i].login);    re[i].login   =0; }
X      if (re[i].fullname) { xfree(re[i].fullname); re[i].fullname=0; }
X#ifdef NEWS
X      if (re[i].mid)      { xfree(re[i].mid);      re[i].mid     =0; }
X#endif
X   }
X	clear_cache();   /* throw out stat cache */
X   undefine(~0);    /* undefine all macros */
X   xfree(cflist);
X   mcheck();        /* verify that files are closed */
X   xcheck();        /* verify that memory is clean */
X   (void)exit(ret);
X}
X
Xvoid
Xopen_cluster(bdir,hdir)
Xchar *bdir, /*   BBSDIR  */
X     *hdir; /*   HELPDIR */
X{
X   short i;
X
X   /* Free up space, etc */
X   for (i=0; i<maxconf; i++) {
X      xfree(conflist[i].name);
X      xfree(conflist[i].location);
X   }
X
X   /* Read in /usr/bbs/conflist */
X   strcpy(bbsdir,bdir);
X   strcpy(helpdir,hdir);
X   if (!grab_list(bbsdir,"conflist",conflist,&maxconf)) 
X      endbbs(2);
X   for (i=1; i<maxconf; i++)
X      if (!strcmp(conflist[0].location,conflist[i].location)
X       ||   match(conflist[0].location,conflist[i].name)) defidx=i;
X   if (defidx<0) printf("Warning: bad default conference\n");
X
X   /* Source system rc file */
X   mode = M_SUPERSANE;
X   source(bbsdir,"rc");
X   mode = M_OK;
X}
X
X/******************************************************************************/
X/* PROCESS COMMAND LINE ARGUMENTS                                             */
X/******************************************************************************
XFunction:    init
XCalled by:   main
XArguments:   
XReturns:    
XCalls:       source for .cfonce and system rc
X             grab_file to get .cflist and conflist
XDescription: Sets up global variables, i.e. uid, login, envars,
X             workdir, processes rc file for system and for user
X******************************************************************************/
Xvoid            /* RETURNS: (nothing)                  */
Xinit(argc,argv) /* ARGUMENTS:                          */
Xint    argc;    /*    Number of command-line arguments */
Xchar **argv;    /*    Command-line argument list       */
X{
X   short c,o,i;
X   struct passwd *pwd;
X   extern char *optarg;
X   extern int optind,opterr;
X   char **namestr,buff[MAX_LINE_LENGTH];
X   char mbox[MAX_LINE_LENGTH],*mail;
X   struct sigvec vec;
X
X   /* Print identification */
X
X   /* Start up interrupt handling *
X   for (c=1; c<=32; c++)
X      signal(c, handle_other);
X    * */
X   signal(SIGINT,  handle_int);
X   signal(SIGPIPE, handle_pipe);
X   /* *
X   signal(SIGINT,  handle_other);
X   signal(SIGPIPE, handle_other);
X    * */
X   sigvec(SIGINT,  NULL, &vec);
X   vec.sv_flags &= ~SV_INTERRUPT;
X   sigvec(SIGINT,  &vec, NULL);
X
X   /* Initialize options */
X   for (o=0; o<sizeof(option)/sizeof(option_t); o++)
X      flags |= option[o].deflt * option[o].mask;
X
X   /* Set up user variables */
X   cmdbuf[0] = pipebuf[0] = evalbuf[0] = '\0';
X   st_glob.c_status = 0;
X#ifdef NEWS
X	st_glob.c_article = 0;
X#endif
X   st_glob.inp = stdin;
X   uid = getuid();
X   if (!(pwd = getpwuid(uid))) {
X      error("reading ","user entry");
X      endbbs(2);
X   }
X   strcpy(login,   pwd->pw_name);
X   strcpy(st_glob.fullname,pwd->pw_gecos);
X   strcpy(home,    pwd->pw_dir);
X   if (access(home,X_OK)) {
X      error("accessing ",home);
X      endbbs(2);
X   }
X   sprintf(work,"%s/.cfdir",home);
X   if (access(work,X_OK)) strcpy(work,home);
X   strcpy(buff,work);
X   if (gethostname(hostname,MAX_LINE_LENGTH))
X      error("getting host name",NULL);
X
X   /* Process command line options here */
X   if (!uid || uid==geteuid()) {
X      printf("login %s -- invoking bbs -%s\n",login,(uid)?"n":"no");
X      flags &= ~(O_SOURCE); /* for security */
X      if (!uid) 
X			flags |= O_OBSERVE|O_READONLY; 
X   }
X   confname[0]=0;
X   while ((c = getopt(argc, argv, options)) != -1) {
X      o = strchr(options,c)-options;
X      if (o>=0 && o<6) flags ^= (1<<o);
X      else if (c=='j') strcpy(confname,optarg);
X		if (c=='o')
X			flags ^= O_READONLY;  /* -o does observer AND readonly */
X   }
X   if (optind < argc) strcpy(confname,argv[argc-1]);
X
X   /* Read in WORK/.cflist */
X   st_glob.listtime = 0;
X   refresh_list();
X   
X   for (i=0; i<MAX_RESPONSES; i++) {
X      re[i].fullname = re[i].login = NULL;
X#ifdef NEWS
X		re[i].mid = NULL;
X      re[i].article = 0;
X#endif
X   }
X
X   /* Set up user customizations */
X   def_macro("today",DM_PARAM,"+0");
X   mail = getenv("MAIL");
X   if (!mail) {
X      sprintf(mbox,"%s/%s",MAILDIR,login);
X      mail = mbox;
X   }
X   def_macro("mailbox",DM_VAR,mail);
X   mail = getenv("SHELL");
X   if (mail) def_macro("shell",DM_VAR|DM_ENVAR,mail);
X   mail = getenv("EDITOR");
X   if (mail) def_macro("editor",DM_VAR|DM_ENVAR,mail);
X   mail = getenv("MESG");
X   if (mail) def_macro("mesg",DM_VAR|DM_ENVAR,mail);
X
X   /* Read in /usr/bbs/conflist */
X   for (i=0; i<MAX_LIST_LENGTH; i++)
X      conflist[i].name = conflist[i].location = 0;
X   open_cluster(BBSDIR,HELPDIR);
X
X   if (strcmp(work,buff)) { /* for cfdir command */
X      strcpy(buff,work);
X      refresh_list();
X   }
X
X   /* Execute user's cfonce file */
X   source(work,".cfonce");
X   if (strcmp(work,buff))
X      source(work,".cfonce");
X
X   /* Reset name */
X   namestr=explode(pwd->pw_gecos,expand("gecos",DM_VAR));
X   strcpy(st_glob.fullname,(xsizeof(namestr)>0)? namestr[0] : "Unknown");
X   xfree(namestr);
X
X   /* Join initial conference */
X   if (flags & O_DEBUG)
X      printf("Default: %hd %s\n",defidx,conflist[defidx].name);
X   if (!(flags & O_DEFAULT) || defidx<0) {
X      current = -1;
X      st_glob.i_current = 0; /* No current item */
X   } else if (confname[0])
X      join(confname, 0);
X   else if (cflist && xsizeof(cflist))
X      join(cflist[current=0], 2); /* force join */
X   else {
X      join(compress(conflist[defidx].name), 2); /* force join */
X   }
X}
X
X/******************************************************************************/
X/* PROCESS COMMAND LINE ARGUMENTS                                             */
X/******************************************************************************
XFunction:    char source(char *dir, char *filename)
XCalled by:   init
XArguments:   File to source
XReturns:     
XCalls:       command for each statement
XDescription: Executes commands in a file, does NOT grab_file since it
X             only needs 1-time sequential access.
X*******************************************************************************/
Xchar                 /* RETURNS: 0 on error, 1 else         */
Xsource(dir,filename) /* ARGUMENTS:                          */
Xchar *dir;           /*    Directory containing file        */
Xchar *filename;      /*    Filename of commands to execute  */
X{
X   FILE *fp;
X   char buff[MAX_LINE_LENGTH];
X
X   if (filename)
X      sprintf(buff,"%s/%s",dir,filename);
X   else
X      strcpy(buff,dir);
X   if (flags & O_DEBUG) printf("source: %s\n",buff);
X   if ((fp=mopen(buff,O_R|O_SILENT))==NULL) return 0;
X   if (st_glob.inp != stdin) 
X      mclose(st_glob.inp);
X   st_glob.inp = stdin;
X   while (ngets(buff, fp)) {
X      if ((flags & O_VERBOSE) && mode==M_SANE)
X         printf("command: %s\n",buff);
X      st_glob.inp = fp;
X      command(buff,0);
X      st_glob.inp = stdin;
X   }
X   mclose(fp);
X   return 1;
X}
X            
X/******************************************************************************/
X/* PROCESS COMMAND LINE ARGUMENTS                                             */
X/******************************************************************************
XFunction:    char command(char *command)
XCalled by:   main
XArguments:   command to process
XReturns:     0 if done, 1 else
XCalls:       join() for "join", "next" commands
X             leave() for "next", "quit" commands
XDescription: For all command modes, this processes a user command.
X             Interrupts go back to here, without changing command mode.
X*******************************************************************************/
Xchar              /* RETURNS: Done flag                  */
Xcommand(str,lvl)  /* ARGUMENTS:                          */
Xchar *str;        /*    Command to execute               */
Xint   lvl;        /*    Recursion depth                  */
X{
X   int argc=0;    /*    Number of arguments */
X   unsigned short i;
X   char *argv[MAX_ARGS],cmddel,bufdel;
X   char *Sptr,*Eptr,state=1,ok;
X   char cmd[MAX_LINE_LENGTH],*cmd2;
X
X   if (!str || !*str) return 1;
X   if (flags & O_DEBUG) printf("command: %s\n",str);
X   if (lvl > CMD_DEPTH) {
X      printf("UNK Too many expansions.\n");
X      return 0;
X   }
X
X   /* Process shell escape */
X   if (str[0]=='!') {
X/* Undone at request of sno and jep
X      if (mode==M_SANE)
X         printf("Conference rc cannot exec: %s\n",str);
X      else {
X*/
X         unix_cmd(str+1);
X         printf("!\n");
X/*    } */
X      return 1;
X
X   /* And comments */
X   } else if (str[0]=='#') return 1;
X
X   cmddel = expand("cmddel",DM_VAR)[0];
X   bufdel = expand("bufdel",DM_VAR)[0];
X
X   /* Get arguments using a state machine for lexical analysis */
X   Sptr=str;
X   pipebuf[0]=cmdbuf[0]='\0';
X   while (state && argc<MAX_ARGS) {
X      switch(state) {
X      case 1: /* between words */
X              while (isspace(*Sptr)) Sptr++;
X              if      (*Sptr==cmddel)  { Sptr++;    state=0; }
X              else if (*Sptr==bufdel)  { Eptr= ++Sptr; state=6; }
X              else if (*Sptr=='|')  { Eptr= ++Sptr; state=7; }
X              else if (*Sptr=='>')  { Eptr=Sptr; state=9; }
X              else if (*Sptr=='\'') { Eptr= ++Sptr; state=4; }
X              else if (*Sptr=='`')  { Eptr= ++Sptr; state=8; }
X/*            else if (*Sptr=='\"') { Eptr= ++Sptr; state=3; } */
X              else if (*Sptr=='\"') { Eptr=Sptr; state=3; }
X              else if (*Sptr=='\\') { Eptr=Sptr; state=5; }
X              else if (*Sptr)       { Eptr=Sptr; state=2; }
X              else       state=0;
X              break;
X
X      case 2: /* normal word */
X              while (*Eptr && !isspace(*Eptr)
X               && *Eptr!=cmddel && *Eptr!=bufdel 
X               && !strchr("|`'>\\\"",*Eptr)
X               && !(Eptr>Sptr && *(Eptr-1)=='=') /* '=' terminates word */
X               && (argc || *Sptr=='-' || isdigit(*Sptr) || !isdigit(*Eptr)))
X                 Eptr++;
X
X              argv[argc]=(char*)xalloc(0,Eptr-Sptr+1);
X              strncpy(argv[argc],Sptr,Eptr-Sptr);
X              argv[argc++][Eptr-Sptr]=0;
X              Sptr = Eptr;
X
X              if (argc==1) {
X                 cmd2=(char *)expand(argv[0],((mode & M_MASK)==M_RFP)? DM_RFP : DM_OK);
X                 if (cmd2) {
X                    sprintf(cmd,"%s%s",cmd2,Eptr);
X                    xfree(argv[argc=0]);
X                    Sptr = cmd;
X                 }
X              }
X
X              state=1;
X              break;
X
X      case 3: /* "stuff" */
X              do { 
X                 Eptr++; 
X              } while (*Eptr && (*Eptr!='\"' || *(Eptr-1)=='\\'));
X/*            argv[argc]=xalloc(0,Eptr-Sptr+1); */
X              argv[argc]=(char*)xalloc(0,Eptr-Sptr+2);
X/*            strncpy(argv[argc],Sptr,Eptr-Sptr); */
X              strncpy(argv[argc],Sptr,Eptr-Sptr+1);
X/*            argv[argc++][Eptr-Sptr]=0; */
X              argv[argc++][Eptr-Sptr+1]=0;
X
X              if (*Eptr) Eptr++;
X              Sptr = Eptr;
X              state=1;
X              break;
X
X      case 4: /* 'stuff' */
X              do { Eptr++; } while (*Eptr && *Eptr!='\'');
X              argv[argc]=(char*)xalloc(0,Eptr-Sptr+1);
X              strncpy(argv[argc],Sptr,Eptr-Sptr);
X              argv[argc++][Eptr-Sptr]=0;
X
X              if (*Eptr) Eptr++;
X              Sptr = Eptr;
X              state=1;
X              break;
X
X      case 5: /* \\ */
X              argv[argc]=(char*)xalloc(0,2);
X              strcpy(argv[argc++],"\\");
X              Sptr = Eptr+1;
X              state=1;
X              break;
X
X      case 6: /* ,stuff */
X              do { Eptr++; } while (*Eptr && *Eptr!=cmddel);
X              strncpy(cmdbuf,Sptr,Eptr-Sptr);
X              cmdbuf[Eptr-Sptr]=0;
X              Sptr = Eptr;
X              state=1;
X              break;
X
X      case 7: /* | stuff */
X              do { Eptr++; } while (*Eptr && *Eptr!=cmddel && *Eptr!=bufdel);
X              strncpy(pipebuf,Sptr,Eptr-Sptr);
X              pipebuf[Eptr-Sptr]=0;
X              Sptr = Eptr;
X              state=1;
X              break;
X
X      case 8: /* `command` */
X              do { Eptr++; } while (*Eptr && *Eptr!='`');
X              strncpy(cmd,Sptr,Eptr-Sptr);
X              cmd[Eptr-Sptr]=0;
X
X              status |=  S_EXECUTE;
X              evalbuf[0] = '\0';
X              command(cmd,lvl+1);
X              status &= ~S_EXECUTE;
X              argv[argc]=(char*)xalloc(0,strlen(evalbuf)+1);
X              strcpy(argv[argc++],evalbuf);
X
X              if (*Eptr) Eptr++;
X              Sptr = Eptr;
X              state=1;
X              break;
X
X      case 9: /* > file */
X              do { Eptr++; } while (*Eptr=='>');
X              do { Eptr++; } while (isspace(*Eptr));
X              do { 
X                 Eptr++; 
X              } while (*Eptr && *Eptr!=cmddel && *Eptr!=bufdel && *Eptr!=' ');
X              strcpy(pipebuf,"cat ");
X              strncat(pipebuf,Sptr,Eptr-Sptr);
X              pipebuf[4+Eptr-Sptr]=0;
X              Sptr = Eptr;
X              state=1;
X              break;
X      }
X   }
X/*
X   if (*Sptr) strcpy(cmdbuf,Sptr);
X   else       cmdbuf[0]='\0';
X*/
X   if (argc) {
X   
X      /* Expand macros */
X#if 0
X/*
X      cmd2=(char *)expand(argv[0],((mode & M_MASK)==M_RFP)? DM_RFP : DM_OK);
X*/
X      cmd2=0;
X      if (cmd2) {
X         xfree(argv[0]);
X         strcpy(cmd,cmd2);
X/* implode(cmd+strlen(cmd),argv," ",1); argv isn't malloc'ed */
X         for (i=1; i<argc; i++) {
X            strcat(cmd," ");
X            strcat(cmd,argv[i]);
X            xfree(argv[i]);
X         }
X         ok = command(cmd,lvl+1);
X      } else 
X#endif
X      {
X      
X         /* Execute command */
X         switch(mode & M_MASK) {
X         case M_OK:   ok=  ok_cmd_dispatch(argc,argv); break;
X         case M_JOQ:  ok= joq_cmd_dispatch(argc,argv); break;
X         case M_TEXT: ok=text_cmd_dispatch(argc,argv); break;
X         case M_RFP:  ok= rfp_cmd_dispatch(argc,argv); break;
X         case M_EDB:  ok= edb_cmd_dispatch(argc,argv); break;
X         default: printf("Unknown mode %d\n",mode); break;
X         }
X   
X         /* Free args */
X         for (i=0; i<argc; i++) xfree(argv[i]);
X      }
X   } else
X      ok=1; /* don't abort on null command */
X
X   /* Do next ; cmd unless EOF or command says to halt (ok==2) */
X   if (ok==1 && *Sptr && !(status & S_STOP)) {
X      ok=command(Sptr,lvl+1); 
X   } 
X/* else if (*Sptr) status &= ~S_STOP; */
X   return ok;
X}
X
X/* Commands available at the Ok: prompt only */
Xstatic dispatch_t ok_cmd[]={
X   "i_tem",     do_read,
X   "r_ead",     do_read,
X   "pr_int",    do_read,
X   "e_nter",    enter,
X   "s_can",     do_read,
X   "b_rowse",   do_read,
X   /* j_oin */
X   "le_ave",    leave,
X   "n_ext",     do_next,
X   "che_ck",    check,
X   "rem_ember", remember,
X   "forget",    forget,
X   "unfor_get", remember,
X   "k_ill",     do_kill,
X   "freeze",    freeze,
X   "thaw",      freeze,
X   /* sync_hronous */
X   /* async_hronous */
X   "retire",    freeze,
X   "unretire",  freeze,
X   "f_ind",     do_find,
X   "l_ocate",   do_find,
X   "seen",      fixseen,
X   "fix_seen",  fixseen,
X   "re_spond",  respond,
X   /* lpr_int */
X   "li_nkfrom", linkfrom,
X   "abort",     leave,
X/* ex_it q_uit st_op good_bye log_off log_out h_elp exp_lain sy_stem unix al_ias
X * def_ine una_lias und_efine ec_ho echoe echon echoen echone so_urce m_ail 
X * t_ransmit sen_dmail chat write d_isplay que_ry */
X   "p_articipants", participants,
X/* w_hoison am_superuser */
X   "resign",    resign,
X/* chd_ir uma_sk sh_ell f_iles dir_ectory ty_pe e_dit cdate da_te t_est 
X * clu_ster 
X */
X   "ps_eudonym",respond,
X   "list",      check,
X   0, 0
X};
X
X/******************************************************************************/
X/* DISPATCH CONTROL TO APPROPRIATE MISC. COMMAND FUNCTION                     */
X/******************************************************************************/
Xchar                       /* RETURNS: 0 to quit, 1 else */
Xok_cmd_dispatch(argc,argv) /* ARGUMENTS:                 */
Xint    argc;               /*    Number of arguments     */
Xchar **argv;               /*    Argument list           */
X{
X   int i;
X
X   for (i=0; ok_cmd[i].name; i++)
X      if (match(argv[0],ok_cmd[i].name))
X         return ok_cmd[i].func(argc,argv);
X
X   /* Command dispatch */
X   if (match(argv[0],"j_oin"))    {
X      if (argc==2) join(argv[1],0); 
X      else if (confidx>=0) {
X         confsep("joinmsg",confidx,&st_glob,part,0); 
X      } else 
X         printf("Not in a conference!\n");
X   } else return misc_cmd_dispatch(argc,argv);
X   return 1;
X}
X
X/******************************************************************************/
X/* PROCESS A GENERIC SIGNAL (if enabled)                                      */
X/******************************************************************************/
Xvoid 
Xhandle_other(sig, code, scp, addr)
Xint sig, code;
X/* struct sigcontext */ void *scp;
Xchar *addr;
X{
X   if (status & S_PIPE) printf("%d Pipe interrupt %d!\n",getpid(),sig);
X   else printf("%d Interrupt %d!\n",getpid(),sig);
X   status |= S_INT;
X}
X
X/******************************************************************************/
X/* PROCESS A USER INTERRUPT SIGNAL                                            */
X/******************************************************************************/
Xvoid         /* RETURNS: (nothing) */
Xhandle_int() /* ARGUMENTS: (none)  */
X{
X   struct sigvec vec;
X
X   if (!(status & S_PIPE)) {
X      printf("Interrupt!\n");
X      status |= S_INT;
X   }
X   signal(SIGINT,  handle_int);
X   sigvec(SIGINT,  NULL, &vec);
X   vec.sv_flags |= SV_INTERRUPT;
X   sigvec(SIGINT,  &vec, NULL);
X}
X
X/******************************************************************************/
X/* PROCESS AN INTERRUPT CAUSED BY A PIPE ABORTING                             */
X/******************************************************************************/
Xvoid          /* RETURNS: (nothing) */
Xhandle_pipe() /* ARGUMENTS: (none)  */
X{
X   printf("Pipe interrupt?\n");
X   /* spclose(st_glob.outp );*/
X   signal(SIGPIPE, handle_pipe);
X   status |= S_INT;
X}
END_OF_FILE
if test 25131 -ne `wc -c <'driver.c'`; then
    echo shar: \"'driver.c'\" unpacked with wrong size!
fi
# end of 'driver.c'
fi
if test -f 'rfp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rfp.c'\"
else
echo shar: Extracting \"'rfp.c'\" \(24139 characters\)
sed "s/^X//" >'rfp.c' <<'END_OF_FILE'
X/* RFP.C */
Xstatic	char sccsid[] = "@(#)rfp.c 1.3 94/01/20 (c)1993 thalerd";
X#include <stdio.h>
X#include <string.h>
X#include <sys/types.h>
X#include <sys/time.h>
X#include "config.h"
X#include "struct.h"
X#include "globals.h"
X#include "rfp.h"
X#include "item.h"
X#include "macro.h"
X#include "driver.h"
X#include "lib.h"
X#include "sum.h"
X#include "xalloc.h"
X#include "arch.h"
X#include "system.h"
X#include "files.h"
X#include "range.h"
X#include "sep.h"
X#include "news.h"
X#include "stats.h" /* for get_config */
X
Xextern FILE *ext_fp;
Xextern short ext_first,ext_last;
X
X/* Commands available in RFP mode */
Xstatic dispatch_t rfp_cmd[]={
X   "cen_sor",    censor,
X   "scr_ibble",  censor,
X   "e_nter",     enter,
X   "pr_eserve",  preserve,
X   "po_stpone",  preserve,
X   "hide",       preserve,
X   "p_ass",      preserve,
X   "n_ew",       preserve,
X   "wait",       preserve,
X   "tree",       tree,
X   "*freeze",    freeze,
X   "*thaw",      freeze,
X   "*forget",    freeze,
X   "*retire",    freeze,
X   "*unretire",  freeze,
X   "r_espond",   rfp_respond,
X   "ps_eudonym", rfp_respond,
X   "*rem_ember", remember,
X   "*unfor_get", remember,
X   "*kill",      do_kill,
X   "*f_ind",     do_find,
X   "*lo_cate",   do_find,
X/* "*fix_seen",  fixseen,  this by itself doesn't work */
X   "reply",      reply,
X   0, 0
X};
X
X/******************************************************************************/
X/* DISPATCH CONTROL TO APPROPRIATE RFP MODE FUNCTION                          */
X/******************************************************************************/
Xchar                        /* RETURNS: 0 on abort, 1 else */
Xrfp_cmd_dispatch(argc,argv) /* ARGUMENTS:                  */
Xint    argc;                /*    Number of arguments      */
Xchar **argv;                /*    Argument list            */
X{
X   short a,b,c;
X   int i,j;
X
X   for (i=0; rfp_cmd[i].name; i++) {
X      if (match(argv[0],rfp_cmd[i].name))
X         return rfp_cmd[i].func(argc,argv);
X      else if (rfp_cmd[i].name[0]=='*' && match(argv[0],rfp_cmd[i].name+1)) {
X         char buff[MAX_LINE_LENGTH];
X
X         mode = M_OK; 
X         st_glob.r_first = st_glob.r_last+1;
X         sprintf(buff,"%s %d",compress(rfp_cmd[i].name+1),st_glob.i_current);
X         for (j=1; j<argc; j++) {
X            strcat(buff," ");
X            strcat(buff,argv[j]);
X         }
X         return command(buff,0);
X      }
X   }
X
X   /* Command dispatch */
X   if (match(argv[0],"h_eader")) {
X      show_header();
X   } else if (match(argv[0],"text"))     { /* re-read from 0 */
X      st_glob.r_first = 0;
X      st_glob.r_last  = MAX_RESPONSES;
X      show_range();
X   } else if (match(argv[0],"a_gain"))   { /* re-read same range */
X      sepinit(IS_ITEM|IS_ALL);
X      show_header();
X      st_glob.r_first = ext_first;
X      st_glob.r_last  = ext_last;
X      if (st_glob.r_first>0)
X         show_nsep(ext_fp); /* nsep between header and responses */
X      show_range();
X   } else if (match(argv[0],"^")
X    ||        match(argv[0],"fi_rst"))   {
X      st_glob.r_first = 1;
X      st_glob.r_last  = MAX_RESPONSES;
X      show_range();
X   } else if (match(argv[0],".")
X    ||        match(argv[0],"th_is")
X    ||        match(argv[0],"cu_rrent")) {
X      st_glob.r_first = st_glob.r_current;
X      st_glob.r_last  = MAX_RESPONSES;
X      show_range();
X   } else if (match(argv[0],"$")
X    ||        match(argv[0],"l_ast"))  {
X      st_glob.r_first = st_glob.r_max;
X      st_glob.r_last  = MAX_RESPONSES;
X      show_range();
X   } else if (match(argv[0],"up")
X    ||        match(argv[0],"par_ent")) {
X      short a;
X
X      if ((a=parent(st_glob.r_current)) < 0)
X         printf("No previous response\n");
X      else {
X         st_glob.r_first = a;
X         st_glob.r_last  = a;
X         show_range();
X      }
X   } else if (match(argv[0],"chi_ldren")
X     ||       match(argv[0],"do_wn")) {
X      short a;
X
X      /* Find 1st child */
X      if ((a = child(st_glob.r_current)) < 0)
X         printf("No children\n");
X      else {
X         st_glob.r_first = a;
X         st_glob.r_last  = a;
X         show_range();
X      }
X   } else if (match(argv[0],"sib_ling")
X    ||        match(argv[0],"ri_ght")) {
X      short a;
X
X      /* Find next sibling */
X      if ((a = sibling(st_glob.r_current)) < 0)
X         printf("No more siblings\n");
X      else {
X         st_glob.r_first = a;
X         st_glob.r_last  = a;
X         show_range();
X      }
X   } else if (match(argv[0],"sync_hronous"))   { mode = M_OK; /* KKK */ }
X   else   if (match(argv[0],"async_hronous"))  { mode = M_OK; /* KKK */ }
X   else if (match(argv[0],"si_nce"))         {   
X      time_t t;
X      short i;
X
X      i=0;
X      t=since(argc,argv,&i);
X      for (i=st_glob.r_max; i>=0; i--) {
X         if (!re[i].date) get_resp(ext_fp,&(re[i]),(short)GR_HEADER,i);
X         if (re[i].date<t) break;
X      }
X      st_glob.r_first = i+1;
X      st_glob.r_last  = MAX_RESPONSES;
X      show_range();
X   } else if (match(argv[0],"onl_y"))          { 
X      if (argc>2) {
X         printf("Bad parameters near \"%s\"\n",argv[2]);
X         return 2;
X      } else if (argc>1 && sscanf(argv[1],"%hd",&a)==1) {
X         st_glob.r_first = a;
X         st_glob.r_last  = a;
X         show_range();
X      } else
X         wputs("You must specify a comment number\n");
X   } else if (argc && sscanf(argv[0],"%hd-%hd",&a,&b)==2) {
X      if (b<a) { c=a; a=b; b=c; }
X      if (a<0) {
X         printf("Response #%d is too small\n",a);
X      } else if (b>st_glob.r_max) {
X         printf("Response #%d is too big (last %d)\n",a,st_glob.r_max);
X      } else {
X         st_glob.r_first = a;
X         st_glob.r_last  = b;
X         show_range();
X      }
X   } else if (argc && (sscanf(argv[0],"%hd",&a)==1
X    || !strcmp(argv[0],"-") || !strcmp(argv[0],"+"))) {
X      if (!strcmp(argv[0],"-")) a = -1; 
X      if (!strcmp(argv[0],"+")) a =  1;
X      if (argv[0][0]=='+' || argv[0][0]=='-')
X         a += st_glob.r_current;
X      if (a<0) {
X         printf("Response #%d is too small\n",a);
X      } else if (a>st_glob.r_max) {
X         printf("Response #%d is too big (last %d)\n",a,st_glob.r_max);
X      } else {
X         st_glob.r_first = a;
X         st_glob.r_last  = MAX_RESPONSES;
X         show_range();
X      }
X   } else {
X      a=misc_cmd_dispatch(argc,argv);
X      if (!a) preserve(argc,argv);
X      return a;
X   }
X   return 1;
X}
X
X/******************************************************************************/
X/* ADD A NEW RESPONSE                                                         */
X/******************************************************************************/
Xint
Xadd_response(this,text,idx,sum,part,stt,art,mid,uid,login,fullname,resp)
Xsumentry_t  *this; /*   New item summary */
Xchar       **text; /*   New item text    */
Xshort        idx;
Xsumentry_t  *sum;
Xpartentry_t *part;
Xstatus_t    *stt;
Xlong         art;
Xchar        *mid;
Xuid_t        uid;
Xchar        *login;
Xchar        *fullname;
Xshort        resp;
X{
X   short item,line,nr;
X   char  buff2[MAX_LINE_LENGTH];
X   FILE *fp;
X
X   item = stt->i_current;
X   nr = sum[ item-1 ].nr;
X   sprintf(buff2, "%s/_%d", conflist[idx].location, item);
X
X   /* Begin critical section */
X   if (fp=mopen(buff2, O_A|O_NOCREATE)) {
X      short n;
X
X      /* was: update before open, in case of a link - why? (was wrong) */
X      if (!art)
X         refresh_sum(item,idx,sum,part,stt);
X
X      n = sum[item-1].nr - nr;
X      if (n>1) {
X         printf("Warning: %d comments slipped in ahead of yours at %d-%d!\n",
X          n,nr,sum[item-1].nr-1);
X      } else if (n==1) {
X         printf("Warning: a comment slipped in ahead of yours at %d!\n",
X          sum[item-1].nr-1);
X      } else if (!(flags & O_STAY))
X         stt->r_last = -1; 
X
X      re[sum[item-1].nr].offset   = ftell(fp);
X      fprintf(fp,",R%04X\n,U%d,%s\n,A%s\n,D%lX\n",
X         RF_NORMAL,uid,login,fullname,(art)? this->last : time((time_t *)0));
X      if (resp)
X         fprintf(fp,",P%d\n",resp-1);
X      fprintf(fp,",T\n");
X      re[sum[item-1].nr].parent   = resp;
X      re[sum[item-1].nr].textoff  = ftell(fp);
X      re[sum[item-1].nr].numchars = -1;
X      if (art) {
X         fprintf(fp,",N%06ld\n",art);
X         fprintf(fp,",M%s\n",mid);
X      } else {
X         for (line=0; line<xsizeof(text); line++) {
X            if (text[line][0]==',') fprintf(fp,",,%s\n",text[line]);
X            else                    fprintf(fp,"%s\n",  text[line]);
X         }
X      }
X      if (fprintf(fp,",E\n")>=0) {
X
X         /* Update seen */
X         stt->r_current = stt->r_max = sum[item-1].nr;
X   /*    if (!(flags & O_METOO) && stt->r_lastseen==sum[item-1].nr)  */
X         time(&(part[item-1].last));
X         if (!(flags & O_METOO)) {
X            part[item-1].nr    = sum[item-1].nr;
X            stt->r_lastseen = stt->r_current+1;
X         }
X
X         sum[item-1].last  = time((time_t *)0);
X         sum[item-1].nr++;
X         save_sum(sum,(short)(item-1),idx,stt);
X
X      } else 
X	 error("writing response","");
X      mclose(fp);
X
X   } 
X   /* End critical section */
X
X   xfree(text);
X}
X
X/******************************************************************************/
X/* ENTER A RESPONSE INTO THE CURRENT ITEM                                     */
X/******************************************************************************/
Xvoid                /* RETURNS: (nothing)              */
Xdo_respond(ps,resp) /* ARGUMENTS:                      */
Xint   ps;           /*    Use a pseudo?                */
Xshort resp;         /*    Response to prev. response # */
X{
X   short         nr;
X   char          buff[MAX_LINE_LENGTH],
X					  pseudo[MAX_LINE_LENGTH],
X					**file;
X   unsigned char omode;
X   FILE         *fp;
X	char        **config;
X
X   /* Check for valid permissions and arguments */
X   if (st_glob.c_status & CS_NORESPONSE) {
X      printf("You only have read access.\n");
X      return;
X   }
X
X   if (sum[st_glob.i_current-1].flags & IF_FROZEN) {
X      wputs("Item is frozen!\n");
X      return;
X   }
X   nr = sum[ st_glob.i_current-1 ].nr;
X   if (resp>nr) {
X      printf("Highest response # is %d\n",nr-1);
X      return;
X   }
X   
X   /* Get pseudo */
X   if (ps) {
X      printf("What's your handle? ");
X      if (!ngets(buff, st_glob.inp)) 
X	 return;
X      if (strlen(buff)) 
X	 strcpy(pseudo,buff);
X      else {
X         wputs("Response aborted!  Returning to current item.\n");
X         return;
X      }
X   } else strcpy(pseudo,st_glob.fullname);
X   
X   if (nr >= MAX_RESPONSES) {
X      wputs("Too many responses on this item!\n");
X      return;
X   }
X   
X#ifdef NEWS
X   if (st_glob.c_security & CT_NEWS) {
X      char rnh[MAX_LINE_LENGTH];
X
X      if (!resp) resp=nr;
X
X		if (!(config = get_config(confidx)))
X		   return;
X      sprintf(buff,"%s/%s/%d",NEWSDIR,dot2slash(config[CF_NEWSGROUP]),
X       st_glob.i_current);
X
X      if (resp>0) {
X         if ((fp=mopen(buff,O_R))==NULL) return;
X         get_resp(fp,&(re[resp-1]),GR_ALL,resp-1);
X         mclose(fp);
X      }
X
X      make_rnhead(re,resp);
X      if (resp>0)
X         xfree(re[resp-1].text);
X      sprintf(rnh,"%s/.rnhead",home);
X      sprintf(buff,"Pnews -h %s",rnh);
X      unix_cmd(buff);
X      rm(rnh,SL_USER);
X      return;
X   } else 
X#endif
X	if (text_loop(1,1)) { /* success */
X      omode = mode;
X      mode = M_OK;
X      if (!(file = grab_file(work,"cf.buffer",0)))
X         wputs("can't open cfbuffer\n");
X      else if (!xsizeof(file)) {
X         wputs("No text in buffer!\n");
X         xfree(file);
X      } else {
X         add_response(&(sum[st_glob.i_current-1]),file,confidx,sum,part,
X	  &st_glob,0, NULL,uid,login,pseudo,resp);
X      }
X
X      if (flags & O_STAY)
X         mode = omode;
X   } else
X      wputs("Response aborted!  Returning to current item.\n");
X   
X   /* Delete text buffer */
X   sprintf(buff,"%s/cf.buffer",work);
X   rm(buff,SL_USER);
X}
X
X/******************************************************************************/
X/* ADD A RESPONSE TO THE CURRENT ITEM                                         */
X/******************************************************************************/
Xint                /* RETURNS: (nothing)          */
Xrespond(argc,argv) /* ARGUMENTS:                  */
Xint    argc;       /*    Number of arguments      */
Xchar **argv;       /*    Argument list            */
X{
X   char buff[MAX_LINE_LENGTH];
X   char act[MAX_ITEMS];
X   short j,fl;
X
X   /* Check for valid permissions and arguments */
X   if (st_glob.c_status & CS_NORESPONSE) {
X      printf("You only have read access.\n");
X      return 1;
X   }
X
X   rangeinit(&st_glob,act);
X   refresh_sum(0,confidx,sum,part,&st_glob);
X   st_glob.r_first = -1;
X
X   fl = 0;
X   if (argc<2) {
X      printf("Error, no item specified! (try HELP RANGE)\n");
X   } else { /* Process args */
X      range(argc,argv,&fl,act,sum,&st_glob,0);
X   }
X
X   /* Process items */
X   for (j=st_glob.i_first; j<=st_glob.i_last && !(status & S_INT); j++) {
X      if (!act[j-1] || !sum[j-1].flags) continue;
X
X#ifdef NEWS
X      if (st_glob.c_security & CT_NEWS) {
X			char **config;
X
X         if (!(config = get_config(confidx)))
X			  return 1;
X         sprintf(buff,"%s/%s/%d",NEWSDIR,dot2slash(config[CF_NEWSGROUP]),
X	  j);
X      } else
X#endif
X         sprintf(buff,"%s/_%d",conflist[confidx].location,j);
X      st_glob.i_current=j;
X      show_header();
X      if (status & S_REDIRECT) spclose(st_glob.outp);
X      do_respond(argc>0 && match(argv[0],"ps_eudonym"),st_glob.r_first+1);
X   }
X   return 1;
X}
X
X/******************************************************************************/
X/* ENTER A RESPONSE IN THE CURRENT ITEM                                       */
X/******************************************************************************/
Xint                    /* RETURNS: (nothing)          */
Xrfp_respond(argc,argv) /* ARGUMENTS:                  */
Xint    argc;           /*    Number of arguments      */
Xchar **argv;           /*    Argument list            */
X{
X   short a= -1;
X
X   if (argc>2 || (argc>1 && (sscanf(argv[1],"%hd",&a)<1 || a<0))) {
X      printf("Bad parameters near \"%s\"\n",argv[(argc>2)?2:1]);
X      return 2;
X   } else
X      do_respond(argc>0 && match(argv[0],"ps_eudonym"),(short)a+1);
X
X   return 1;
X}
X
Xvoid
Xdump_reply(sep) 
Xchar *sep;
X{
X      sepinit(IS_START);
X      itemsep(sep,0);
X      for (st_glob.l_current=0;
X           st_glob.l_current<xsizeof(re[st_glob.r_current].text)
X        && !(status & S_INT);
X           st_glob.l_current++) {
X         sepinit(IS_ITEM);
X         itemsep(sep,0);
X      }
X      sepinit(IS_CFIDX);
X      itemsep(sep,0);
X}
X
X/******************************************************************************/
X/* MAIL A REPLY TO THE AUTHOR OF A RESPONSE                                   */
X/******************************************************************************/
Xint              /* RETURNS: (nothing)          */
Xreply(argc,argv) /* ARGUMENTS:                  */
Xint    argc;     /*    Number of arguments      */
Xchar **argv;     /*    Argument list            */
X{
X   char buff[MAX_LINE_LENGTH];
X   short i;
X   FILE *fp,*pp;
X   flag_t ss;
X   register int cpid,wpid;
X   int statusp;
X
X   /* Validate arguments */
X   if (argc<2 || sscanf(argv[1],"%hd",&i)<1) {
X      printf("You must specify a comment number.\n");
X      return 1;
X   } else if (argc>2) {
X      printf("Bad parameters near \"%s\"\n",argv[2]);
X      return 2;
X   }
X   refresh_sum(0,confidx,sum,part,&st_glob);
X   if (i<0 || i>=sum[st_glob.i_current - 1].nr) {
X      wputs("Can't go that far! near \"<newline>\"\n");
X      return 1;
X   }
X
X   if (re[i].flags & RF_CENSORED) {
X      wputs("Cannot reply to censored response!\n");
X      return 1;
X   }
X   if (re[i].offset < 0) {
X      printf("Offset error.\n"); /* should never happen */
X      return 1;
X   }
X
X   /* Get complete text */
X#ifdef NEWS
X   if (st_glob.c_security & CT_NEWS) {
X		char **config;
X
X		if (!(config = get_config(confidx)))
X			return 1;
X      sprintf(buff,"%s/%s/%d",NEWSDIR,dot2slash(config[CF_NEWSGROUP]),st_glob.i_current);
X   } else
X#endif
X      sprintf(buff,"%s/_%d",conflist[confidx].location,st_glob.i_current);
X   if ((fp=mopen(buff,O_R))==NULL) return 1;
X   get_resp(fp,&(re[i]),GR_ALL,i);
X   mclose(fp);
X
X   /* Fork & setuid down when creating cf.buffer */
X   if (cpid=fork()) { /* parent */
X      if (cpid<0) return -1; /* error: couldn't fork */
X      while ((wpid = wait(&statusp)) != cpid && wpid != -1);
X      /* post = !statusp; */
X   } else { /* child */
X      if (setuid(getuid())) error("setuid","");
X      setgid(getgid());
X
X      /* Save to cf.buffer */
X      sprintf(buff,"%s/cf.buffer",work);
X      if ((fp=mopen(buff,O_W))==NULL) {
X         xfree( re[i].text );
X         return 1;
X      }
X
X      pp = st_glob.outp;
X      ss = status;
X      st_glob.r_current = i;
X      st_glob.outp = fp;
X      status |= S_REDIRECT;
X 
X      dump_reply("replysep");
X
X      st_glob.outp = pp;
X      status     = ss;
X
X      dump_reply("replysep");
X
X      mclose(fp);
X      exit(0);
X   }
X
X   /* Invoke mailer */
X   sprintf(buff,"mail %s",re[i].login);
X   command(buff,0);
X
X   xfree( re[i].text );
X   mode = M_RFP;
X   return 1;
X}
X
X/******************************************************************************/
X/* CENSOR A RESPONSE IN THE CURRENT ITEM                                      */
X/******************************************************************************/
Xint               /* RETURNS: (nothing)          */
Xcensor(argc,argv) /* ARGUMENTS:                  */
Xint    argc;      /*    Number of arguments      */
Xchar **argv;      /*    Argument list            */
X{
X   char buff[MAX_LINE_LENGTH],over[MAX_LINE_LENGTH];
X   short i,typ,j,k;
X   FILE *fp;
X   char **text; short len;
X
X   typ = (match(argv[0],"scr_ibble"))? RF_CENSORED|RF_SCRIBBLED : RF_CENSORED;
X
X   /* Validate arguments */
X   if (argc<2 || sscanf(argv[1],"%hd",&i)<1) {
X      printf("You must specify a comment number.\n");
X      return 1;
X   } else if (argc>2) {
X      printf("Bad parameters near \"%s\"\n",argv[2]);
X      return 2;
X   }
X   refresh_sum(0,confidx,sum,part,&st_glob);
X   if (i<0 || i>=sum[st_glob.i_current - 1].nr) {
X      wputs("Can't go that far! near \"<newline>\"\n");
X      return 1;
X   }
X
X   /* Check for permission to censor */
X   if (!(st_glob.c_status & CS_FW) && uid!=re[i].uid) {
X      wputs("You can't do that!\n");
X      return 1;
X   }
X   if (sum[st_glob.i_current-1].flags & IF_FROZEN) {
X      wputs("Cannot censor frozen items!\n");
X      return 1;
X   }
X
X   if ((re[i].flags & typ)==typ) return 1; /* already done */
X   if (re[i].offset < 0) {
X      printf("Offset error.\n"); /* should never happen */
X      return 1;
X   }
X
X   sprintf(buff,"%s/_%d",conflist[confidx].location,st_glob.i_current);
X   if ((fp=mopen(buff,O_RPLUS))!=NULL) {
X      if (fseek(fp,re[i].offset,0))
X         error("fseeking in ",buff);
X      fprintf(fp,",R%04d\n",typ);
X
X      /* log it and overwrite it, unless it's a news article */
X#ifdef NEWS
X      if (!re[i].article) {
X#endif
X         get_resp(fp,&(re[i]),GR_ALL,i);
X         fseek(fp,re[i].textoff,0);
X         text = re[i].text;
X         if (typ & RF_SCRIBBLED) {
X            sprintf(over,"%s %s %s ",login,get_date(time((time_t *)0),0),st_glob.fullname);
X            len = strlen(over);
X            for (j=re[i].numchars; j>76; j-=76) {
X               for (k=0; k<75; k++)
X                  fputc(over[k%len],fp);
X               fputc('\n',fp);
X            }
X            for (k=0; k<j-1; k++)
X               fputc(over[k%len],fp);
X            fputc('\n',fp);
X         }
X#ifdef NEWS
X      }
X#endif
X      mclose(fp);
X   }
X
X   /* free_sum(sum); unneeded, always SF_FAST */
X
X   /* Write to censorlog */
X   sprintf(buff,"%s/censored",bbsdir);
X   if (fp=mopen(buff,O_A|O_PRIVATE)) {
X      fprintf(fp,",C %s item %d resp %d rflg %d %s,%d %s date %s\n",
X       conflist[confidx].location, st_glob.i_current, i, typ,
X       login, uid, get_date(time((time_t *)0),0), st_glob.fullname);
X      fprintf(fp,",R%04X\n,U%d,%s\n,A%s\n,D%lX\n,T\n",
X       re[i].flags,re[i].uid,re[i].login,re[i].fullname,re[i].date);
X      for (j=0; j<xsizeof(text); j++) 
X         fprintf(fp,"%s\n",text[j]);
X      fprintf(fp,",E\n");
X      mclose(fp);
X   }
X   xfree( re[i].text );
X   re[i].flags=typ;
X   return 1;
X}
X
Xshort stack[MAX_RESPONSES],top=0;
Xvoid
Xtraverse(i)
Xshort i;
X{
X   short c,l,s;
X
X   printf("%s%3d", (top)?"-":" ", i);
X   stack[top++]=i;
X   c=child(i);
X   if (c<0) putchar('\n');
X   else     traverse(c);
X   
X   top--;
X   if (!top) return;
X
X   c=sibling(i);
X   if (c>=0) {
X      for (l=1; l<=top; l++) {
X         printf("   "); /* printf("(%d)",stack[l]); */
X         s=sibling(stack[l]);
X         if (s<0) putchar(' ');
X         else if (l<top) putchar('|');
X         else putchar( (sibling(s)<0)?'\\':'+' );
X      }
X      traverse(c);
X   }
X}
X
X/******************************************************************************/
X/* DISPLAY RESPONSE TREE                                                      */
X/******************************************************************************/
Xint                 /* RETURNS: (nothing)          */
Xtree(argc,argv) /* ARGUMENTS:                  */
Xint    argc;        /*    Number of arguments      */
Xchar **argv;        /*    Argument list            */
X{
X   short i=0;
X
X   /* Validate arguments */
X   if (argc>2 || (argc>1 && sscanf(argv[1],"%hd",&i)<1)) {
X      printf("Bad parameters near \"%s\"\n",argv[2]);
X      return 2;
X   }
X   refresh_sum(0,confidx,sum,part,&st_glob);
X   if (i<0 || i>=sum[st_glob.i_current-1].nr) {
X      wputs("Can't go that far! near \"<newline>\"\n");
X      return 1;
X   }
X   traverse(i);
X   return 1;
X}
X
X/******************************************************************************/
X/* PRESERVE RESPONSES IN THE CURRENT ITEM                                     */
X/******************************************************************************/
Xint                 /* RETURNS: (nothing)          */
Xpreserve(argc,argv) /* ARGUMENTS:                  */
Xint    argc;        /*    Number of arguments      */
Xchar **argv;        /*    Argument list            */
X{
X   short i;
X	short i_i;
X
X   if (match(argv[0],"pr_eserve") || match(argv[0],"po_stpone")
X    || match(argv[0],"n_ew") ||      match(argv[0],"wait")) {
X      wputs("This item will still be new.\n");
X      st_glob.r_last = -2; 
X   } else
X      st_glob.r_last = -1; /* re-read nothing */
X
X   /* Lots of ways to stop, so check inverse */
X   i_i = st_glob.i_current - 1;
X   if (!match(argv[0],"pr_eserve") && !match(argv[0],"po_stpone")
X    && !match(argv[0],"p_ass") && !match(argv[0],"hide")) {
X      if (st_glob.opt_flags & OF_REVERSE)
X         st_glob.i_current = st_glob.i_first;
X      else
X        st_glob.i_current = st_glob.i_last;
X      wputs("Stopping.\n");
X      status |= S_STOP;
X   }
X
X   if (argc<2) {
X      mode = M_OK;
X      return 1;
X   }
X
X   /* Validate arguments */
X   if (sscanf(argv[1],"%hd",&i)<1) {
X      printf("You must specify a comment number.\n");
X      return 1;
X   } else if (argc>2) {
X      printf("Bad parameters near \"%s\"\n",argv[2]);
X      return 2;
X   }
X   refresh_sum(0,confidx,sum,part,&st_glob);
X   if (i<0 || i>=sum[i_i].nr) {
X      wputs("Can't go that far! near \"<newline>\"\n");
X      return 1;
X   }
X   
X   /* Do it */
X   part[i_i].nr = st_glob.r_lastseen = i;
X   if (st_glob.r_last == -2)
X      st_glob.r_last  =  -1;
X   else
X      time(&(part[i_i].last));
X   mode = M_OK;
X   
X   return 1;
X}
X
Xshort
Xsibling(r)
Xshort r;
X{
X      short a,p;
X
X      /* Find next sibling */
X      p = parent(r);
X      a=r+1;
X      if (!re[a].date) get_resp(ext_fp,&(re[a]),GR_HEADER,a);
X      while (a<=st_glob.r_max && parent(a)!=p) {
X         a++;
X         if (!re[a].date) get_resp(ext_fp,&(re[a]),GR_HEADER,a);
X      }
X      if (a>st_glob.r_max) return -1;
X      else return a;
X}
X
Xshort 
Xparent(r)
Xshort r;
X{
X      return (re[r].parent < 1)? r-1 : re[r].parent-1;
X}
X
Xshort
Xchild(r)
Xshort r;
X{
X      short a,p;
X
X      /* Find 1st child */
X      a = p = r+1;
X      if (!re[a].date) get_resp(ext_fp,&(re[a]),GR_HEADER,a);
X      if (re[a].parent && re[a].parent!=p) {
X         a++;
X         if (!re[a].date) get_resp(ext_fp,&(re[a]),GR_HEADER,a);
X         while (a<=st_glob.r_max && re[a].parent!=p) {
X            a++;
X            if (!re[a].date) get_resp(ext_fp,&(re[a]),GR_HEADER,a);
X         }
X      }
X      return (a>st_glob.r_max)? -1 : a;
X}
END_OF_FILE
if test 24139 -ne `wc -c <'rfp.c'`; then
    echo shar: \"'rfp.c'\" unpacked with wrong size!
fi
# end of 'rfp.c'
fi
if test -f 'sep.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sep.c'\"
else
echo shar: Extracting \"'sep.c'\" \(21784 characters\)
sed "s/^X//" >'sep.c' <<'END_OF_FILE'
X/* SEP.C */
Xstatic	char sccsid[] = "@(#)sep.c 1.19 93/06/06 Copyright (c)1993 thalerd";
X/* This module takes care of most of the fancy output, and allows
X * users and administrators to completely customize the output
X * of many functions.  A "separator" string is passed to confsep
X * or itemsep, which break it up and generate output based on the
X * codes therein.  For more information, do "help separators"
X * from within the program.
X */
X#include <stdio.h>
X#include <string.h>
X#include <ctype.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include "config.h"
Xtime_t time PROTO((time_t *tloc));
X#include "struct.h"
X#include "item.h"
X#include "range.h"
X#include "globals.h"
X#include "sep.h"
X#include "change.h" /* to get CF_PUBLIC */
X#include "lib.h"
X#include "sum.h"    /* to get SF_FAST */
X#include "macro.h"
X#include "xalloc.h"
X#include "main.h"
X#include "news.h"
X#include "stats.h"
X
Xstatic char *lchars="ntvbrface";
Xstatic char *rchars="\n\t\v\b\r\f\007\377\033";
Xstatic int lastnum=0,show[100],depth = 0,num=0,tabs=1;
Xstatic int newline,qfail,once,zero;
Xstatic char buff[MAX_LINE_LENGTH];
Xextern char *cfiles[];
X
X/******************************************************************************/
X/* OUTPUT A STRING TO THE DESIRED FORMAT                                      */
X/******************************************************************************/
Xstatic void                    /* RETURNS: (nothing)           */
Xstring(b,fp)                   /* ARGUMENTS:                   */
Xchar *b;                       /*    String to output          */
XFILE *fp;                      /*    File pointer to output to */
X{                              /* LOCAL VARIABLES:             */
X   char fmt[MAX_LINE_LENGTH];  /*    Format string             */
X   char buff[MAX_LINE_LENGTH]; /*    Formatted output          */
X
X   if (!show[depth]) return;
X   if (num)
X      sprintf(fmt,"%%%ds",num);
X   else
X      strcpy(fmt,"%s");
X   sprintf(buff,fmt,b);
X   wfputs(buff,fp);
X}
X
X/******************************************************************************/
X/* OUTPUT A NUMBER TO THE DESIRED FORMAT                                      */
X/******************************************************************************/
Xstatic void  /* RETURNS: (nothing)   */
Xnumber(b,fp) /* ARGUMENTS:           */
Xshort b;     /*    Number to output  */
XFILE *fp;    /*    Stream to send to */
X{
X   char fmt[MAX_LINE_LENGTH];
X
X   if (!show[depth]) return;
X   if (num)
X      sprintf(fmt,"%%%dd",num);
X   else
X      strcpy(fmt,"%d");
X   if (!b && zero)
X      sprintf(buff,"%co",("nN")[zero-1]);
X   else
X      sprintf(buff,fmt,b);
X   wfputs(buff,fp);
X   lastnum=b;
X}
X
X/******************************************************************************/
X/* PROCESS CONDITIONS FOR BOTH ITEM/CONF SEPS                                 */
X/******************************************************************************/
Xstatic char   /* RETURNS: 1 on true, 0 on false */
Xmisccond(spp) /* ARGUMENTS: */
Xchar **spp;   /*    Separator string */
X{
X   char *sp,ret=0;
X   sp = *spp;
X   
X   switch(*(sp++)) {
X   case 'P': ret=(lastnum!=1); break;
X   default: ret=0; break; /* don't show */
X   }
X
X   *spp = sp;
X   return ret;
X}
X
X/******************************************************************************/
X/* PROCESS SEPS FOR BOTH ITEM/CONF SEPS                                       */
X/******************************************************************************/
Xvoid            /* RETURNS: (nothing) */
Xmiscsep(spp,fp) /* ARGUMENTS: */
Xchar **spp;     /*    Separator string */
XFILE *fp;       /*    Stream to send to */
X{
X   char *sp;
X   short i;
X   sp = *spp;
X
X   switch(*(sp++)) {
X
X   /* Customization separators */
X   case '%': string("%",fp); break;
X   case 'E': if (!depth || show[depth-1]) show[depth]= !show[depth]; break;
X   case 'c': newline=0; break;
X   case 'S': if (lastnum!=1) string("s",fp); break;
X   case 'T': tabs=num; break;
X   case 'X': for (i=0; i<tabs; i++) 
X                if (show[depth]) wfputc(' ',fp); 
X             break;
X   case ')': 
X/*
Xfor (i=0; i<depth; i++) printf("   ");
Xprintf("---\n");
X*/
X             depth--; break;
X   case 'D': if (show[depth]) wfputs(get_date(time((time_t*)0),num),fp); break;
X
X   default:  break; /* do nothing */
X   }
X
X   *spp = sp;
X}
X
X/******************************************************************************/
X/* PROCESS CONDITIONS FOR ITEM SEPS ONLY                                      */
X/******************************************************************************/
Xchar             /* RETURNS: 1 true, 0 false */
Xitemcond(spp,fl) /* ARGUMENTS:               */
Xchar **spp;      /*    Separator string      */
Xlong  fl;        /*    Sep flags             */
X{
X   char *sp,ret=0,not=0;
X   response_t *cre;
X
X   sp = *spp;
X   cre = &(re[st_glob.r_current]);
X
X   if (*sp=='!' || *sp=='~') { not = !not; sp++; }
X   for (num=0; isdigit(*sp); sp++) num= num*10+(*sp-'0'); 
X   
X   switch(*(sp++)) {
X   case 'T': ret=((fl & OF_FORMFEED)>0); break;
X   case 'E': ret=(( cre->flags & RF_EXPIRED)>0); break;
X   case 'V': ret=(( cre->flags & RF_CENSORED)>0); break;
X   case 'W': ret=(( cre->flags & RF_SCRIBBLED)>0); break;
X   case 'X': ret=((sum[st_glob.i_current-1].flags & IF_RETIRED)>0); 
X             once &= ~IS_RETIRED;
X             break;
X   case 'Y': ret=((sum[st_glob.i_current-1].flags & IF_FORGOTTEN)>0); 
X             once &= ~IS_FORGOTTEN;
X             break;
X   case 'Z': ret=((sum[st_glob.i_current-1].flags & IF_FROZEN)>0); 
X             once &= ~IS_FROZEN;
X             break;
X   case 'R': ret=((once & (IS_ITEM|IS_RESP))>0);  
X             once&= ~(IS_ITEM|IS_RESP);  
X/*
X             ret= ((!part[st_glob.i_current-1].nr && sum[st_glob.i_current-1].nr) 
X                 || (part[st_glob.i_current-1].nr  < sum[st_glob.i_current-1].nr));
X*/
X             break;
X   case 'F': ret=((fl & OF_NUMBERED) || (flags & O_NUMBERED)); break;
X   case 'D': ret=((once & IS_DATE)>0); break;
X   case 'U': ret=((once & IS_UID)>0); break;
X   case 'L': ret=(st_glob.l_current>=0 && cre->text 
X              &&  st_glob.l_current<xsizeof(cre->text)
X              &&  cre->text[st_glob.l_current]); break;
X   case 'I': /* ret= (!part[st_glob.i_current-1].nr && sum[st_glob.i_current-1].nr); 
X             break; fall through into O */
X   case 'O': ret=((once & IS_ITEM)>0);  once&= ~IS_ITEM;  break;
X   case 'B': ret=((once & IS_START)>0); once&= ~IS_START; break;
X   case 'N': ret=(st_glob.r_current>0); 
X/*           ret= (!(!part[st_glob.i_current-1].nr && sum[st_glob.i_current-1].nr) 
X                  && (part[st_glob.i_current-1].nr  < sum[st_glob.i_current-1].nr));
X*/
X             break;
X   case 'p': once &= ~IS_PARENT;
X             ret=(cre->parent>0); break;
X   case 'x': ret= (once & num); /* once &= ~num; */ break;
X   default: return misccond(spp);
X   }
X
X   *spp = sp;
X   if (!show[depth]) return 0;
X   return ret^not;
X}
X
X/******************************************************************************/
X/* PROCESS SEPS FOR ITEM SEPS ONLY                                            */
X/* This works only for the current conference                                 */
X/******************************************************************************/
Xvoid                /* RETURNS: (nothing) */
Xitemsep2(spp,fl,fp) /* ARGUMENTS: */
Xchar **spp;         /*    Separator string */
Xlong *fl;           /*    Flags (see sep.h) */
XFILE *fp;           /*    Stream to output to */
X{
X   char *sp;
X   char *sub,neg=0;
X   response_t *cre;
X   char subbuf[MAX_LINE_LENGTH];
X
X   cre = &(re[st_glob.r_current]);
X   sp = *spp;
X   buff[0]=0;
X   num=0;
X
X   /* Get number */
X   zero=0;
X   if (*sp == 'z') { zero=1; sp++; }
X   else if (*sp == 'Z') { zero=2; sp++; }
X   if (*sp == '-') { neg=1; sp++; }
X   while (isdigit(*sp)) { num= num*10+(*sp-'0'); sp++; }
X   if (neg) num = -num;
X
X   switch(*(sp++)) {
X
X   /* Item Function Codes */
X   case 'a': string(cre->fullname,fp);    break;
X   case 'C': if (confidx>=0) string(compress(conflist[confidx].name),fp); break;
X   case 'h': string(get_subj(confidx,st_glob.i_current-1,sum),fp);       break;
X   case 'i': number(st_glob.i_current,fp); break;
X   case 'l': string(cre->login,fp);       break;
X   case 'L': string(cre->text[st_glob.l_current],fp); break;
X#ifdef NEWS
X   case 'm': string(message_id(compress(conflist[confidx].name),
X	       st_glob.i_current,st_glob.r_current,re),fp); break;
X#endif
X   case 'n': number(sum[st_glob.i_current-1].nr - 1,fp);     break;
X   case 'N': number(st_glob.l_current+1,fp); break;
X   case 'r': number(st_glob.r_current,fp); break;
X   case 's': number((cre->flags & (RF_SCRIBBLED|RF_EXPIRED))? 0 : xsizeof(cre->text),fp); 
X             break;
X   case 'k': number((cre->numchars+1023)/1024,fp); break;
X   case 'q': number(cre->numchars,fp); break;
X   case 'K': /* KKK */ break;
X   case 'Q': /* KKK */ break;
X   case 'u': number((short)cre->uid,fp); 
X             /* *fl &= ~OF_UID; */
X             once &= ~IS_UID; break;
X   case 'd': if (show[depth]) wfputs(get_date(cre->date,num?num:1),fp); 
X             /* *fl &= ~OF_DATE; */
X             once &= ~IS_DATE; break;
X   case 't': if (show[depth]) wfputs(get_date(cre->date,num),fp); 
X             /* *fl &= ~OF_DATE; */
X             once &= ~IS_DATE; break;
X   case 'p': number((short)cre->parent,fp); once&=~IS_PARENT; break;
X   case '<': for (sub=subbuf; *sp && *sp!='>'; sp++,sub++) *sub = *sp;
X             sp++;
X             (*sub)='\0';
X             itemsep(subbuf,1);
X             break;
X   case '{': for (sub=subbuf; *sp && *sp!='}'; sp++,sub++) *sub = *sp;
X             sp++;
X             (*sub)='\0';
X             itemsep(subbuf,1);
X             break;
X   case '(': show[depth+1]=itemcond(&sp,*fl); 
X             depth++;
X             break; /* ) */
X   
X   default:  *spp=sp-1; miscsep(spp,fp);
X   }
X
X   *spp = sp;
X}
X
X/******************************************************************************/
X/* PROCESS CONDITIONS FOR CONF SEPS ONLY                                      */
X/******************************************************************************/
Xchar              /* RETURNS: 1 true, 0 false */
Xconfcond(spp,idx,st) /* ARGUMENTS:          */
Xchar **spp;       /*    Separator string */
Xshort idx;        /*    Conference index */
Xstatus_t *st;
X{
X   char buff[MAX_LINE_LENGTH];
X   struct stat stt;
X   char *sp,ret=0,not=0;
X
X   sp = *spp;
X
X   if (*sp=='!' || *sp=='~') { not = !not; sp++; }
X   for (num=0; isdigit(*sp); sp++) num= num*10+(*sp-'0'); 
X/*
Xint i;
Xfor (i=0; i<depth; i++) printf("   ");
Xprintf("%1d: %c ",i,*sp);
X*/
X   switch(*(sp++)) {
X   case 'y': lastnum=st->i_unseen; ret=lastnum; break;
X   case 'n': lastnum=st->i_brandnew+st->i_newresp; ret= lastnum; break;
X   case 'b': lastnum=st->i_brandnew; ret= lastnum; break;
X   case 'r': lastnum=st->i_newresp; ret= lastnum; break;
X   case 'm': ret= (status & S_MAIL);  break;
X   case 'x': ret= (once & num); /* once &= ~num; */ break;
X   case 'N': if (num>=0 && num<CF_PUBLIC && idx>=0) {
X                sprintf(buff,"%s/%s",conflist[idx].location,compress(cfiles[num]));
X                if (stat(buff,&stt) || stt.st_size<=0) ret=0;
X                else if (st->c_status & CS_JUSTJOINED) ret=1;
X                else ret=(stt.st_mtime > st->parttime);
X             }
X             break;
X   case 'F': if (num>=0 && num<CF_PUBLIC && idx>=0) {
X                sprintf(buff,"%s/%s",conflist[idx].location,compress(cfiles[num]));
X                ret=!stat(buff,&stt);
X             }
X             break;
X   case 'O': ret= (st->c_status & CS_OTHERCONF)?1:0; break;
X   case 'C': ret= (idx>=0); break;
X   case 'i': ret= (st->i_first<=st->i_last); break;
X   case 's': ret= (st->c_status & CS_FW); break;
X   case 'f': if (num>=0 && idx>=0) {
X                sprintf(buff,"%s/sum",conflist[idx].location);
X                ret = !stat(buff,&stt);
X             }
X             break;
X   case 'j': ret= (st->c_status & CS_JUSTJOINED)?1:0; break;
X   case 'l': ret= (st->c_status & CS_NORESPONSE); break;
X   case 'B': ret= (idx == confidx); break;
X   case 'k': ret= (once & IS_CFIDX); /* once &= ~IS_CFIDX; */ break;
X   default: return misccond(spp);
X   }
X/*
Xprintf("%d\n",ret);
X*/
X   *spp = sp;
X   if (!show[depth]) return 0;
X   return ret^not;
X}
X
X/******************************************************************************/
X/* PROCESS SEPS FOR CONF SEPS ONLY                                            */
X/******************************************************************************/
Xvoid
Xconfsep2(spp,idx,st,part,fp) /* ARGUMENTS: */
Xchar **spp;               /*    Separator string */
Xpartentry_t *part;        /*    User participation info */
Xshort idx;                /*    Conference index */
Xstatus_t *st;
XFILE *fp;                 /*    Stream to output to */
X{
X   char  *sp,*sub,*sh,*sh2,neg=0;
X   char   subbuf[MAX_LINE_LENGTH];
X   time_t t;
X	char **config;
X
X   sp = *spp;
X   num=0;
X
X   /* Get number */
X   zero=0;
X   if (*sp == 'z') { zero=1; sp++; }
X   else if (*sp == 'Z') { zero=2; sp++; }
X   if (*sp == '-') { neg=1; sp++; }
X   while (isdigit(*sp)) { num= num*10+(*sp-'0'); sp++; }
X   if (neg) num = -num;
X
X   switch(*(sp++)) {
X
X   /* Conference separators */
X#ifdef NEWS
X   case 'A': number(st->c_article, fp); break;
X#endif
X   case 'y': number(st->i_unseen,fp); break;
X   case 'n': number(st->i_brandnew+st->i_newresp,fp); break;
X   case 'b': number(st->i_brandnew,fp); break;
X   case 'r': number(st->i_newresp,fp); break;
X   case 'k': number(st->count,fp); break;
X   case 'u': string(st->fullname,fp); break;
X   case 'v': string(login,fp); break;
X   case 'w': string(work,fp); break;
X   case 'f': number(st->i_first,fp); break;
X   case 'l': number(st->i_last,fp); break;
X   case 'Q': if (idx<0) { string("Not in a conference!",fp); qfail=1; } break;
X   case 'i': number(st->i_numitems,fp); break;
X   case 't': number(st->c_security,fp); break;
X   case 's': if (idx>=0) string(compress(conflist[idx].name),fp); break;
X   case 'p': if (config = get_config(idx))
X				    string(config[CF_PARTFILE],fp); 
X				 break;
X   case 'd': if (idx>=0) string(conflist[idx].location,fp); break;
X   case 'q': if (idx>=0) {
X                sh=conflist[idx].location;
X                for (sh2=sh+strlen(sh)-1; sh2>=sh && *sh2!='/'; sh2--);
X                string(sh2+1,fp);
X             }
X             break;
X   case 'o': if (show[depth]) wfputs(get_date(st->parttime,num),fp); break;
X   case 'm': /* NEW: lastmod of sum file, if any */
X/*
X             if (idx<0) t=0;
X             else {
X                sprintf(buff,"%s/sum",conflist[idx].location);
X                t= (stat(buff,&stt))? 0 : stt.st_mtime;
X             }
X*/
X             t = st->sumtime;
X             if (show[depth]) wfputs(get_date(t,num),fp); 
X             break;
X   case 'g': if (num>=0 && num<CF_PUBLIC && show[depth] && idx>=0) 
X                cat(conflist[idx].location,compress(cfiles[num]));
X             break; /* KKK later, redirect cat to fp? */
X   case '<': for (sub=subbuf; *sp && *sp!='>'; sp++,sub++) *sub = *sp;
X             sp++;
X             (*sub)='\0';
X             confsep(subbuf,idx,st,part,1);
X             break;
X   case '{': for (sub=subbuf; *sp && *sp!='}'; sp++,sub++) *sub = *sp;
X             sp++;
X             (*sub)='\0';
X             confsep(subbuf,idx,st,part,1);
X             break;
X   case '(': /* Get number */
X             /* for (num=0; isdigit(*sp); sp++) num= num*10+(*sp-'0'); */
X             show[depth+1]=confcond(&sp,idx,st); /* for ultrix */
X             depth++;
X             break; /* ) */
X
X   default:  *spp=sp-1; miscsep(spp,fp);
X   }
X
X   *spp = sp;
X}
X
X/******************************************************************************/
X/* SET "ONCE-ONLY" FLAGS VALUE                                                */
X/******************************************************************************/
Xvoid       /* RETURNS: (nothing) */
Xsepinit(x) /* ARGUMENTS:         */
Xshort x;   /*    Flags to set    */
X{
X   once |= x;
X}
X
X/******************************************************************************/
X/* PROCESS ITEMSEP STRING                                                     */
X/* Output to pipe, if one is open, else to stdout                             */
X/******************************************************************************/
Xvoid         /* RETURNS: (nothing) */
Xitemsep(sep,fl) /* ARGUMENTS: */
Xchar *sep;   /*    Separator variable */
Xint          fl;         /*    Force %c? */
X{
X   char       *sp,*tp;
X   response_t *cre;
X   FILE       *fp;
X   char       *str;
X   char        buff[MAX_LINE_LENGTH];
X   
X   str = expand(sep,DM_VAR);
X   if (!str) str = sep;
X
X   /* Force %c */
X   if (fl) {
X      sprintf(buff,"%s%%c",str);
X      str = buff;
X   }
X
X   if (status & S_EXECUTE)        fp = 0;
X   else if (status & S_REDIRECT) fp = st_glob.outp;
X   else                           fp = stdout;
X
X   /* get status without trashing subj's in memory */
X   cre = &(re[st_glob.r_current]);
X
X   show[depth=0]=1;
X   newline=1;
X   sp=str;
X
X   for(;;) {
X      switch (*sp) {
X      case '%':   sp++; 
X                  itemsep2(&sp,&st_glob.opt_flags,fp);
X                  break;
X      case '\0':  if ((once & IS_UID)  && ((st_glob.opt_flags & OF_UID ) || (flags & O_UID )))
X                     fprintf(fp," uid %d",cre->uid);
X                  if ((once & IS_DATE) && ((st_glob.opt_flags & OF_DATE) || (flags & O_DATE))) 
X                     fprintf(fp," on %.24s",get_date(cre->date,0));
X                  if ((once & IS_RETIRED) 
X                  && (sum[st_glob.i_current-1].flags & IF_RETIRED))
X                     wfputs("\n   <item is retired>",fp);
X                  if ((once & IS_FORGOTTEN) 
X                  && (sum[st_glob.i_current-1].flags & IF_FORGOTTEN))
X                     wfputs("\n   <item is forgotten>",fp);
X                  if ((once & IS_FROZEN) 
X                  && (sum[st_glob.i_current-1].flags & IF_FROZEN))
X                     wfputs("\n   <item is frozen>",fp);
X                  if ((once & IS_LINKED) 
X                  && (sum[st_glob.i_current-1].flags & IF_PARTY))
X                     wfputs("\n   <synchronous (party) item>",fp);
X                  if ((once & IS_LINKED) 
X                  && (sum[st_glob.i_current-1].flags & IF_LINKED))
X                     wfputs("\n   <linked item>",fp);
X                  if ((once & IS_PARENT) 
X                  && (cre->parent>0))
X                     fprintf(fp,"   <response to #%d>",cre->parent-1);
X
X                  if (once & IS_CENSORED) {
X                     if (cre->flags & RF_EXPIRED)
X                        wfputs("   <expired>",fp);
X                     else if (cre->flags & RF_SCRIBBLED) {
X                        if (cre->numchars>8 && cre->text 
X			 && (flags & O_SCRIBBLER)) {
X                           char buff[MAX_LINE_LENGTH];
X                           short i;
X
X                           for (i=0; i<8 && ((char*)cre->text)[i]!=' '; i++)
X                              buff[i] = ((char*)cre->text)[i];
X                           buff[i] = '\0';
X                        
X                           fprintf(fp,"   <censored & scribbled by %s>",buff);
X                        } else
X                           wfputs("   <censored & scribbled>",fp);
X                     } else if (cre->flags & RF_CENSORED)
X                        wfputs("   <censored>",fp);
X		  }
X
X                  if (newline) wfputc('\n',fp);
X                  once=0;
X                  fflush(fp);
X                  return;
X      case '\\':  /* Translate lchar into rchar */
X                  sp++; 
X                  tp=strchr(lchars,*sp); 
X                  if (tp) {    /* if *sp is 0 byte, will insert a 0 byte */
X                     if (show[depth]) wfputc(rchars[tp-lchars],fp);
X                     sp++;
X                     break;
X                  } /* else fall through into default */
X      default:    if (show[depth]) wfputc(*sp++,fp);
X                  else             sp++;
X      }
X   }
X}
X
X/******************************************************************************/
X/* PROCESS CONFSEP STRING                                                     */
X/******************************************************************************/
Xvoid                     /* RETURNS: (nothing)                    */
Xconfsep(sep,idx,st,part,fl) /* ARGUMENTS:                            */
Xchar        *sep;        /*    Sep string to process              */
Xpartentry_t *part;       /*    User participation info            */
Xshort        idx;        /*    Index of which cf we're processing */
Xstatus_t *st;
Xint          fl;         /*    Force %c? */
X{
X   char *sp,*tp,*str;
X   FILE *fp;
X   char buff[MAX_LINE_LENGTH];
X
X   str = expand(sep,DM_VAR);
X   if (!str) str=sep;
X   
X   /* Compatibility: force "...prompt" to end in \c */
X   if (fl) {
X      sprintf(buff,"%s%%c",str);
X      str = buff;
X   }
X
X   if (status & S_EXECUTE)        fp = 0;
X   else if (status & S_REDIRECT) fp = st_glob.outp;
X   else                           fp = stdout;
X
X   show[depth=0]=1;
X   newline=1; qfail=0;
X   sp=str;
X
X   while (!qfail) {
X      switch (*sp) {
X      case '%':   sp++; 
X                  confsep2(&sp,idx,st,part,fp);
X                  break;
X      case '\0':  if (newline) wfputc('\n',fp);
X                  once=0;
X                  fflush(fp);
X                  return;
X      case '\\':  /* Translate lchar into rchar */
X                  sp++; 
X                  tp=strchr(lchars,*sp); 
X                  if (tp) {    /* if *sp is 0 byte, will insert a 0 byte */
X                     if (show[depth]) wfputc(rchars[tp-lchars],fp);
X                     sp++;
X                     break;
X                  } /* else fall through into default */
X      default:    if (show[depth]) wfputc(*sp++,fp);
X                  else             sp++;
X                  break;
X      }
X   }
X   if (newline) wfputc('\n',fp);
X   fflush(fp);
X}
END_OF_FILE
if test 21784 -ne `wc -c <'sep.c'`; then
    echo shar: \"'sep.c'\" unpacked with wrong size!
fi
# end of 'sep.c'
fi
echo shar: End of archive 4 \(of 5\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
