Newsgroups: comp.sources.unix
From: thalerd@quip.eecs.umich.edu (Dave Thaler)
Subject: v28i047: yapp - conferencing system (similar to PicoSpan), Part03/05
References: <1.770288965.8721@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: thalerd@quip.eecs.umich.edu (Dave Thaler)
Posting-Number: Volume 28, Issue 47
Archive-Name: yapp/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 5)."
# Contents:  conf.c lib.c news.c sum.c
# Wrapped by thalerd@clippers.engin.umich.edu on Sat Jan 22 23:38:02 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'conf.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'conf.c'\"
else
echo shar: Extracting \"'conf.c'\" \(20880 characters\)
sed "s/^X//" >'conf.c' <<'END_OF_FILE'
X/* CONF.C */
Xstatic   char sccsid[] = "@(#)conf.c 1.2 94/01/20 (c)1993 thalerd";
X/* PHASE 1: Conference Subsystem 
X         Be able to enter/exit the program, and move between conferences
X         Commands: join, next, quit, source
X         Files: rc files, cflist, login, logout, bull
X*/
X
X#include <stdio.h>
X#include <string.h>
X#include <ctype.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <errno.h>
X#include <time.h>
X#include <pwd.h> /* for participants */
X#include "config.h"
X#include "struct.h"
X#include "globals.h"
X#include "conf.h"
X#include "lib.h"
X#include "joq.h"
X#include "sum.h"
X#include "item.h"
X#include "range.h"
X#include "macro.h"
X#include "system.h"
X#include "change.h"
X#include "sep.h"
X#include "xalloc.h"
X#include "driver.h"  /* for source */
X#include "stats.h"   /* for get_config */
X
X/******************************************************************************/
X/* PROCESS COMMAND LINE ARGUMENTS                                             */
X/******************************************************************************
XFunction:    join(char *conference, short idx, int force)
XCalled by:   command, main
XArguments:   cf name or conference # to join, force flag
XReturns:   
XCalls:       source() for CONF/rc and WORK/.cfrc files
X             cat() for login
X             get_idx to find cf name in conflist
XDescription: 
X*******************************************************************************/
X#define O_JOIN 0x0002
Xchar                   /* RETURNS: 1 on success, 0 else       */
Xjoin(conf, force)      /* ARGUMENTS:                          */
Xchar *conf;            /*    Conference name to join          */
Xint   force;           /*    Force Observe/join flags         */
X{
X    char        buff[MAX_LINE_LENGTH];
X    struct stat st;
X    time_t      t1;
X    char      **config;
X
X    /* Initialize st_new structure */
X    st_new.outp       = st_glob.outp;
X    st_new.inp        = st_glob.inp;
X    st_new.mailsize   = st_glob.mailsize;
X    st_new.listtime   = st_glob.listtime;
X    st_new.c_security = st_new.i_current = st_new.c_status = 0;
X    st_new.sumtime    = 0;
X#ifdef NEWS
X    st_new.c_article = 0;
X#endif
X    strcpy(st_new.fullname, st_glob.fullname);
X
X    /* Check for existence */
X    if (!conf) return 0; 
X    joinidx=get_idx(conf,conflist,maxconf);
X    if (joinidx<0) { 
X       printf("Cannot access conference %s.\n",conf);
X       return 0; 
X    } 
X    if(flags & O_DEBUG) printf("join: %hd dir=%s\n",joinidx,conflist[joinidx].location);
X
X    /* Read in config file */
X    if (!(config=get_config(joinidx)))
X       return 0; 
X
X    /* Pass security checks */
X    if (xsizeof(config)>CF_SECURITY) 
X       st_new.c_security=atoi(config[CF_SECURITY]);
X#ifdef NEWS
X    if (xsizeof(config)<=CF_NEWSGROUP)
X       st_new.c_security &= ~CT_NEWS;
X#endif
X    if (!checkpoint(joinidx,st_new.c_security)) {
X       if (st_new.c_security & CT_READONLY) 
X          force |= O_READONLY;
X       else {
X          return 0;
X       }
X    }
X
X    /* Do stuff with WORK/.name.cf */
X    sprintf(buff,"%s/%s",work,config[CF_PARTFILE]);
X    if (flags & O_DEBUG) printf("join: Partfile=%s\n",buff);
X    if (stat(buff,&st)) { /* Not a member */
X       if (!((flags|force) & O_OBSERVE)) {
X
X          /* Main JOQ cmd loop */
X          mode = M_JOQ;
X          if ((force & O_JOIN) || (status & S_MOTIF)) {
X             sprintf(buff,"You are being automatically registered in %s\n",
X              conflist[joinidx].location);
X             wputs(buff);
X             command("join",0);
X          } else {
X             printf("You are not a member of %s\nDo you wish to:",
X              conflist[joinidx].location);
X             while (mode==M_JOQ && get_command(NULL));
X          }
X
X          if (status & S_QUIT) {
X             printf("registration aborted (didn't leave)\n");
X             status &= ~S_QUIT;
X             return 0;
X          }
X       }
X       t1 = (time_t)0;
X    } else {
X       t1 = st.st_mtime; /* last time .*.cf was touched */
X    }
X    if (flags & O_DEBUG) printf("join: t1=%x\n",t1);
X
X    if (confidx>=0) leave(0,(char**)0);
X
X    memcpy(&st_glob,&st_new,sizeof(st_new));
X
X    confidx =joinidx; /* passed all security checks */
X    if (xsizeof(config)>CF_FWLIST)
X       fw = explode(config[CF_FWLIST],",");
X    else
X       fw = 0;
X    read_part(config[CF_PARTFILE],part,&st_glob,confidx);
X
X    /* Set status */
X    if ((flags|force) & O_OBSERVE)
X       st_glob.c_status |=  CS_OBSERVER;
X    if ((flags|force) & O_READONLY)
X       st_glob.c_status |=  CS_NORESPONSE;
X
X    /* Allow FW to be specified by login or by UID */
X    sprintf(buff,"%d",uid);
X    if (searcha(login,fw,0)>=0 || searcha(buff,fw,0)>=0 || uid==geteuid()) 
X       st_glob.c_status |=  CS_FW;
X    if (flags & O_DEBUG) printf("join: Status=%hd\n",(short)status);
X
X    st_glob.sumtime = 0;
X    refresh_sum(0,confidx,sum,part,&st_glob);
X
X    /* Source CONF/rc file and WORK/.cfrc files */
X    if (flags & O_SOURCE) {
X       mode = M_SANE;
X       source(conflist[confidx].location,"rc");
X/*     mode = M_OK;
X       source(work,".cfrc");
X */
X    }
X
X    /* Display login file */
X    sepinit(IS_START|IS_ITEM);
X/*printf("PARTTIME=%d\n",st_glob.parttime);*/
X    confsep("linmsg",confidx,&st_glob,part,0);
X    check_mail(1);
X
X    /* Source WORK/.cfrc files */
X    if (flags & O_SOURCE) {
X       mode = M_OK;
X       source(work,".cfrc");
X    }
X    return 1;
X}
X
X/******************************************************************************/
X/* FIND INDEX OF NAME IN AN ASSOCIATIVE LIST                                  */
X/******************************************************************************/
Xshort                  /* RETURNS: -1 on error, else index of elt in list */
Xget_idx(elt,list,size) /* ARGUMENTS:                                      */
Xchar    *elt;          /*    String to match                              */
Xassoc_t *list;         /*    List of elements to search                   */
Xshort    size;         /*    Number of elements in the list               */
X{
X   short i;
X
X   for (i=1; i<size && !match(elt,list[i].name); i++);
X   return (i<size)? i : -1;
X}
X
X/******************************************************************************/
X/* PROCESS COMMAND LINE ARGUMENTS                                             */
X/******************************************************************************
XFunction:    leave
XCalled by:   command
XArguments:   
XReturns:   
XCalls:       cat() for logout
XDescription: 
X*******************************************************************************/
Xint                         /* RETURNS: error flag                 */
Xleave(argc,argv)            /* ARGUMENTS: (none)                   */
Xint argc;
Xchar **argv;
X{
X   char **config;
X   if (flags & O_DEBUG) printf("leave: %hd\n",confidx);
X   if (confidx<0) return 1; /* (noconf) */
X
X   if (!argc || argv[0][0]!='a') { /* not "abort" */
X
X      /* Display logout */
X      /* more(conflist[confidx].location,"logout"); */
X      sepinit(IS_START|IS_ITEM);
X      confsep("loutmsg",confidx,&st_glob,part,0);
X
X      /* Write participation file unless observing */
X      if (!(st_glob.c_status & CS_OBSERVER)) {
X         if (!(config = get_config(confidx)))
X            return 1;
X         write_part(config[CF_PARTFILE]);
X      }
X   }
X
X   /* Free config info */
X   xfree(fw);
X
X   st_glob.sumtime = 0;
X   st_glob.c_status = 0; /* |= CS_OTHERCONF; */
X
X   confidx = -1;
X   undefine(DM_SANE);
X
X   /* Re-source system rc file */
X   mode = M_SUPERSANE;
X   source(bbsdir,"rc");
X   mode = M_OK;
X
X   return (!argc || argv[0][0]!='a');
X}
X
X/******************************************************************************/
X/* CHECK A LIST OF CONFERENCES FOR NEW ITEMS                                  */
X/******************************************************************************/
Xint              /* RETURNS: (nothing)     */
Xcheck(argc,argv) /* ARGUMENTS:             */
Xint    argc;     /*    Number of arguments */
Xchar **argv;     /*    Argument list       */
X{
X   int i;
X   char **list,*cfname,sec,buff[MAX_LINE_LENGTH],**fw;
X   short size,idx,all=0,count=0,argidx=1;
X   partentry_t part2[MAX_ITEMS],*part3;
X   sumentry_t  sum2[MAX_ITEMS];
X   status_t   *st,st_temp;
X   struct stat stt;
X   char      **config;
X   long        force;
X
X   /* Check for before/since dates */
X   st_glob.since = st_glob.before = 0;
X   if (argc>argidx) {
X      if (match(argv[argidx],"si_nce") 
X       || match(argv[argidx],"S=")) {
X         st_glob.since  = since(argc,argv,&argidx);
X         argidx++;
X      } else if (match(argv[argidx],"before") 
X       ||        match(argv[argidx],"B=")) {
X         st_glob.before = since(argc,argv,&argidx);
X         argidx++;
X      }
X   }
X
X   if (argc>argidx) {            /* list given by user */
X      size = argc-argidx;
X      list = argv+argidx;
X   } else if (argv[0][0]=='l') { /* use conflist */
X      all  = 1;
X      size = maxconf-1;
X   } else {                      /* use .cflist */
X      refresh_list();
X      size = xsizeof(cflist);
X      list = cflist;
X   }
X
X   sepinit(IS_START);
X   for (i=0; i<size && !(status & S_INT); i++) {
X      force = 0;
X      idx=(all)? i+1 : get_idx(list[i],conflist,maxconf);
X      cfname = (all)? compress(conflist[idx].name) : list[i];
X      if (idx<0 || !(config=get_config(idx))) {
X         printf("Cannot access conference %s.\n",cfname);
X         continue;
X      } 
X
X      /* Pass security checks */
X      sec=(xsizeof(config)>CF_SECURITY)? atoi(config[CF_SECURITY]) : 0;
X#ifdef NEWS
X      if (xsizeof(config)<=CF_NEWSGROUP)
X         sec &= ~CT_NEWS;
X#endif
X      if (!checkpoint(idx,sec)) {
X         if (sec & CT_READONLY) {
X            force |= O_READONLY;
X         } else {
X            continue;
X         }
X      }
X
X/*    if (idx==confidx)  */
X      if (!strcmp(conflist[idx].location,conflist[confidx].location)) {
X         refresh_sum(0,confidx,sum,part,&st_glob);
X         st = &st_glob;
X         part3=part;
X      } else {
X         st = &st_temp;
X#ifdef NEWS
X         st->c_article = 0;
X#endif
X         read_part(config[CF_PARTFILE],part2,st,idx); /* Read in partfile */
X
X         /* Initialize c_status */
X         st->c_status = 0;
X         sprintf(buff,"%d",uid);
X         if (xsizeof(config)>CF_FWLIST)
X            fw = explode(config[CF_FWLIST],",");
X         else
X            fw = 0;
X         if (searcha(login,fw,0)>=0 || searcha(buff,fw,0)>=0 || uid==geteuid()) 
X            st->c_status |=  CS_FW;
X         else
X            st->c_status &= ~CS_FW;
X         xfree(fw);
X         if ((flags|force) & O_OBSERVE)
X            st->c_status |=  CS_OBSERVER;
X         else
X            st->c_status &= ~CS_OBSERVER;
X         if ((flags|force) & O_READONLY)
X            st->c_status |=  CS_NORESPONSE;
X         else
X            st->c_status &= ~CS_NORESPONSE;
X
X         sprintf(buff,"%s/%s",work,config[CF_PARTFILE]);
X         st->parttime   = (stat(buff,&stt))? 0 : stt.st_mtime;
X         st->c_security = (xsizeof(config)>CF_SECURITY)? 
X          atoi(config[CF_SECURITY]) : 0;
X
X         /* Read in sumfile */
X         get_status(st,sum2,part2,idx); 
X         part3=part2;
X      }
X      st->c_security = sec;
X
X      if ((!st_glob.before || st->sumtime < st_glob.before)
X       &&  (st_glob.since <= st->sumtime)) {
X         st->count = (++count);
X         sepinit(IS_ITEM);
X         if (argc<2 && current==i) sepinit(IS_CFIDX);
X         confsep((argv[0][0]=='l')?"listmsg":"checkmsg",idx,st,part3,0);
X      }
X   }
X   return 1;
X}
X
X/******************************************************************************/
X/* ADVANCE TO NEXT CONFERENCES WITH NEW ITEMS                                 */
X/******************************************************************************/
Xint                                   /* RETURNS: (nothing)     */
Xdo_next(argc,argv)                    /* ARGUMENTS:             */
Xint    argc;                          /*    Number of arguments */
Xchar **argv;                          /*    Argument list       */
X{                                     /* LOCAL VARIABLES:       */
X   char      **config,
X               buff[MAX_LINE_LENGTH];
X   char        sec;                   /*    Conference's security type     */
X   short       idx;
X   partentry_t part2[MAX_ITEMS];
X   sumentry_t  sum2[MAX_ITEMS];
X   status_t    st;
X   struct stat stt;
X
X   if (argc>1) {
X      printf("Bad parameters near \"%s\"\n",argv[1]);
X      return 2;
X   }
X
X   refresh_list(); /* make sure .cflist is current */
X   for (; current+1 < xsizeof(cflist) && !(status & S_INT); current++) {
X      idx=get_idx(cflist[current+1],conflist,maxconf);
X      if (idx<0 || !(config=get_config(idx))) {
X         printf("Cannot access conference %s.\n",cflist[current+1]);
X         continue;
X      } 
X
X      /* Check security */
X      sec=(xsizeof(config)>CF_SECURITY)? atoi(config[CF_SECURITY]) : 0;
X#ifdef NEWS
X      if (xsizeof(config)<=CF_NEWSGROUP)
X         sec &= ~CT_NEWS;
X#endif
X      if (!(sec & CT_READONLY) && !checkpoint(idx,sec))
X         continue;
X
X/*    if (idx==confidx)  */
X      if (!strcmp(conflist[idx].location,conflist[confidx].location)) {
X         refresh_sum(0,confidx,sum,part,&st_glob);
X         if (st_glob.i_newresp || st_glob.i_brandnew) {
X            join(cflist[++current],0);
X            return 1;
X         }
X      } else {
X         read_part(config[CF_PARTFILE],part2,&st,idx); /* Read in partfile */
X         sprintf(buff,"%s/%s",work,config[CF_PARTFILE]);
X         st.parttime   = (stat(buff,&stt))? 0 : stt.st_mtime;
X         st.c_security = (xsizeof(config)>CF_SECURITY)? 
X          atoi(config[CF_SECURITY]) : 0;
X#ifdef NEWS
X         st.c_article = 0;
X#endif
X         get_status(&st,sum2,part2,idx);  /* Read in sumfile */
X         st.sumtime = 0;
X         if (st.i_newresp || st.i_brandnew) {
X            join(cflist[++current],0);
X            return 1;
X         }
X      }
X      printf("No new items in %s\n",cflist[current+1]);
X   }
X   printf("No more conferences left.\n");
X   return 2;
X}
X
X/******************************************************************************/
X/* RESIGN FROM (UNJOIN) THE CURRENT CONFERENCE                                */
X/******************************************************************************/
Xint              /* RETURNS: (nothing)     */
Xresign(argc,argv) /* ARGUMENTS:             */
Xint    argc;      /*    Number of arguments */
Xchar **argv;      /*    Argument list       */
X{
X   char    buff[MAX_LINE_LENGTH];
X   char **config;
X
X   if (argc>1) {
X      printf("Bad parameters near \"%s\"\n",argv[1]);
X      return 2;
X   }
X   if (st_glob.c_status & CS_OBSERVER) {
X      printf("But you don't belong to this conference!\n");
X      return 1;
X   }
X   if (get_yes("Are you sure you wish to resign? ")) {
X      if (!(config = get_config(confidx)))
X         return 1;
X      sprintf(buff,"%s/%s",work,config[CF_PARTFILE]);
X      rm(buff,SL_USER);
X      st_glob.c_status |= CS_OBSERVER;
X      printf("You are now just an observer.\n");
X   } 
X   return 1;
X}
X
X/******************************************************************************/
X/* DETERMINE IF USER IS ALLOWED TO JOIN A CONFERENCE                          */
X/******************************************************************************/
Xchar                /* RETURNS: 1 if passed, 0 if failed */
Xcheckpoint(idx,sec) /* ARGUMENTS:                        */
Xshort idx;          /*    Conference # to checkpoint     */
Xchar  sec;          /*    Conference's security type     */
X{
X   char **password,**ulst,osec;
X   char buff[MAX_LINE_LENGTH];
X    
X    /* Do Security checks */
X    osec = sec;
X    sec &= CT_BASIC;
X    if (sec==CT_PRESELECT || sec==CT_PARANOID) {
X       if (!(ulst=grab_file(conflist[idx].location,"ulist",GF_WORD|GF_IGNCMT))) 
X          return 0;
X       sprintf(buff,"%d",uid);
X       if (searcha(login,ulst,0)<0 && searcha(buff,ulst,0)<0) {
X          if (!(osec & CT_READONLY))
X             printf("Access failed for %s\n", compress(conflist[idx].name));
X          xfree(ulst);
X          return 0;
X       }
X    } else ulst=0;
X    if (sec==CT_PASSWORD || sec==CT_PARANOID) {
X       if (!(password=grab_file(conflist[idx].location,"secret",0))) {
X          xfree(ulst);
X          return 0;
X       }
X       if (xsizeof(password)>0) {
X          printf("Password for %s: ",compress(conflist[idx].name));
X          if (strcmp(get_password(),password[0])) {
X             printf("UNK: Invalid password.\n");
X             xfree(password);
X             xfree(ulst);
X             return 0;
X          }
X       }
X       xfree(password);
X    }
X    xfree(ulst);
X    return 1;
X}
X
X/******************************************************************************/
X/* GET INFORMATION ON CONFERENCE PARTICIPANTS                                 */
X/******************************************************************************/
Xint                     /* RETURNS: (nothing)     */
Xparticipants(argc,argv) /* ARGUMENTS:             */
Xint    argc;            /*    Number of arguments */
Xchar **argv;            /*    Argument list       */
X{
X   char         **ulst,**namestr,
X                **config;
X   struct passwd *pwd;
X   struct stat    st;
X   short          j,all=0,dump=0;
X   time_t         tparttime;
X   uid_t          tuid;
X   char           tlogin[L_cuserid];
X   char           tfullname[MAX_LINE_LENGTH];
X   char           twork[MAX_LINE_LENGTH];
X   char           buff[MAX_LINE_LENGTH];
X   char           file[MAX_LINE_LENGTH],file2[MAX_LINE_LENGTH];
X
X   /* Save user info */
X   tuid = uid;                 strcpy(tlogin,login); 
X   strcpy(tfullname,st_glob.fullname); strcpy(twork,work);
X   tparttime = st_glob.parttime;
X   st_glob.count = 0;
X
X   if (argc>1) { /* User list specified */
X      ulst = xalloc(argc-1,sizeof(char *));
X      for (j=1; j<argc; j++)
X         ulst[j-1] = xstrdup(argv[j]);
X   } else {
X      sprintf(file,"%s/ulist",conflist[confidx].location);
X      if
X(!(ulst=grab_file(conflist[confidx].location,"ulist",GF_WORD|GF_SILENT|GF_IGNCMT))) {
X         all = 1;
X         setpwent();
X      } else if (!((st_glob.c_security & CT_BASIC)==CT_PRESELECT 
X       ||          (st_glob.c_security & CT_BASIC)==CT_PARANOID)) {
X         dump=1;
X         sprintf(file2,"%s/ulist.tmp",conflist[confidx].location,"ulist");
X      }
X   }
X
X   open_pipe();
X
X   /* Process items */
X   sepinit(IS_START);
X   confsep("partmsg",confidx,&st_glob,part,0);
X
X   for (j=0; !(status & S_INT); j++) {
X      if (all) {
X         if (!(pwd = getpwent())) break;
X      } else { 
X         if (j>=xsizeof(ulst)) break;
X         if (isdigit(ulst[j][0]))
X            pwd = getpwuid((uid_t)atoi(ulst[j]));
X         else
X            pwd = getpwnam(ulst[j]);
X         if (!pwd) {
X            printf(" User %s not found\n",ulst[j]);
X            if (dump) {
X               xfree(ulst[j]);
X               ulst[j] = 0;
X               dump = 2;
X            }
X            continue;
X         }
X      }
X
X      if (!(config = get_config(confidx)))
X         return 1;
X
X      sprintf(work,"%s/.cfdir",pwd->pw_dir);
X      sprintf(buff,"%s/%s",work,config[CF_PARTFILE]);
X      if (stat(buff,&st)) {
X         strcpy(work,pwd->pw_dir);
X         sprintf(buff,"%s/%s",work, config[CF_PARTFILE]);
X         if (stat(buff,&st)) {
X            if (dump) { /* someone resigned or deleted a part file */
X               xfree(ulst[j]);
X               ulst[j] = 0;
X               dump = 2;
X            } 
X            fprintf(st_glob.outp,"User %s not a member\n",pwd->pw_name);
X            fflush(st_glob.outp);
X            continue;
X         }
X      }
X      uid = pwd->pw_uid;
X      strcpy(login, pwd->pw_name);
X      namestr=explode(pwd->pw_gecos,expand("gecos",DM_VAR));
X      strcpy(st_glob.fullname,namestr[0]);
X      xfree(namestr);
X      st_glob.parttime = st.st_mtime;
X      st_glob.count++;
X      sepinit(IS_ITEM);
X      confsep("partmsg",confidx,&st_glob,part,0);
X
X      if (all) {
X         sprintf(buff,"%s\n",login);
X         write_file(file,buff);
X      }
X   }
X   sepinit(IS_CFIDX);
X   confsep("partmsg",confidx,&st_glob,part,0);
X
X   if (dump==2) { /* reset ulist file */
X      for (j=0; j<xsizeof(ulst); j++) {
X         if (ulst[j]) {
X            sprintf(buff,"%s\n",ulst[j]);
X            if (!write_file(file2,buff)) {
X               dump=3; 
X               break;
X            }
X         }
X      }
X   }
X   if (dump==2)
X      if (rename(file2,file)) error("renaming ",file);
X
X   if (all) endpwent();
X   else xfree(ulst);
X
X   /* Restore user info */
X   uid = tuid;                 
X   strcpy(login,tlogin); 
X   strcpy(st_glob.fullname,tfullname); 
X   st_glob.parttime = tparttime;
X   strcpy(work,twork);
X
X   return 1;
X}
X
Xvoid
Xlog(idx,str)
Xshort idx;
Xchar *str;
X{
X   char buff[MAX_LINE_LENGTH],
X        file[MAX_LINE_LENGTH],
X        timestamp[MAX_LINE_LENGTH];
X   time_t t;
X
X   sprintf(file, "%s/log", conflist[idx].location);
X   time(&t);
X   strcpy(timestamp,ctime(&t)+4);
X   timestamp[20]='\0';
X   sprintf(buff,"%s %s %s\n", timestamp, login, str);
X   write_file(file, buff);
X}
END_OF_FILE
if test 20880 -ne `wc -c <'conf.c'`; then
    echo shar: \"'conf.c'\" unpacked with wrong size!
fi
# end of 'conf.c'
fi
if test -f 'lib.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.c'\"
else
echo shar: Extracting \"'lib.c'\" \(20276 characters\)
sed "s/^X//" >'lib.c' <<'END_OF_FILE'
X/* LIB.C */
Xstatic	char sccsid[] = "@(#)lib.c 1.34 93/06/09 Copyright (c)1993 thalerd";
X#include <stdio.h>
X#include <string.h>
X#include <sys/types.h> 
X#include <sys/file.h> 
X#include <sys/stat.h> 
X#include <time.h> 
X#include <errno.h>
X#include <fcntl.h> /* to get O_CREAT, etc */
X#include <ctype.h>
X#include <signal.h> /* to get sigvec stuff */
X#ifndef linux
Xextern char *sys_errlist[]; /* standard error messages, usu. in errno.h */
X#endif
X#include "config.h"
X#include "struct.h"
X#include "xalloc.h"
X#include "globals.h"
X#include "lib.h"
X#include "macro.h"
X#include "system.h"
X#include "main.h"
X#include "files.h"
X
X/******************************************************************************/
X/* FIND INDEX OF ELT IN ARR AT OR AFTER START, -1 IF NOT FOUND                */
X/******************************************************************************/
Xshort                  /* RETURNS: index of elt or -1  */
Xsearcha(elt,arr,start) /* ARGUMENTS:                   */
Xchar  *elt;            /*    String to search for      */
Xchar **arr;            /*    String array to search    */
Xshort  start;          /*    Index to start looking at */
X{
X   short i,l;
X   l=xsizeof(arr);
X   for (i=start; i<l; i++)
X      if (!strcmp(arr[i],elt)) return i;
X   return -1;
X}
X
X/******************************************************************************/
X/* CHECK FOR A PARTIAL STRING MATCH (required_optional)                       */
X/******************************************************************************/
Xchar           /* RETURNS: 1 if match, 0 else        */
Xmatch(ent,und) /* ARGUMENTS:                         */
Xchar *ent,     /*    String entered by user          */
X     *und;     /*    String with underlines to match */
X{
X   char *q;
X   short n;
X
X   q=strchr(und,'_');          /* "_optional" */
X   n=(q)? q-und : strlen(und); /* number of required chars */
X   if (!n) return !strlen(ent);     /* dont match "" with anything but "" */
X   if (strnicmp(ent,und,n))                    return 0; /* match before _ */
X   if (q && strnicmp(ent+n,q+1,strlen(ent)-n)) return 0; /* match after  _ */
X   if (strlen(ent) > strlen(und)-(q!=0)) return 0; /* no extra chars */
X   return 1;
X}
X            
X/******************************************************************************/
X/* READ A FILE INTO AN ARRAY OF STRINGS (1 ELT PER LINE)                      */
X/******************************************************************************
XFunction:    char **grab_file(char *dir,char *filename, char flags)
XCalled by:   main
XArguments:   Filename to grab
XReturns:     Array of char *'s with lines of file
XCalls:
XDescription: This function will read in an entire file of text into
X             memory, dynamically allocating enough space to hold it.
X*******************************************************************************/
X#define MAX_LINES 5000
X#define HEADER_LINES 6
Xchar **                     /* RETURNS: (nothing)                  */
Xgrab_file(dir,filename,fl)  /* ARGUMENTS:                          */
Xchar *dir;                  /*    Directory containing file        */
Xchar *filename;             /*    Filename to read into memory     */
Xchar fl;                    /*    Flags (see lib.h)                */
X{
X   char **mem;
X   FILE *fp;
X   char buff[MAX_LINE_LENGTH],buff2[MAX_LINE_LENGTH];
X   short lines, max;
X
X   if (filename)
X      sprintf(buff,"%s/%s",dir,filename);
X   else
X      strcpy(buff,dir);
X   if ((fp=mopen(buff,(fl & GF_SILENT)? O_R|O_SILENT : O_R))==NULL)
X      return 0;
X   max=(fl & GF_HEADER)? HEADER_LINES : MAX_LINES;
X   mem=xalloc(max,sizeof(char *));
X   if (flags & O_DEBUG)
X      printf("MEM: %x size=%d  want %d  eltsize=%d\n", mem, sizeof(mem), 
X       max, sizeof(char *));
X   if (fl & GF_WORD) /* count each word as a line */
X      for (lines=0; lines<max && fscanf(fp,"%s",buff2)==1; ) {
X         if (buff2[0]=='#' && (fl & GF_IGNCMT))
X            fgets(buff2, MAX_LINE_LENGTH, fp);
X         else
X            mem[lines++]=xstrdup(buff2);
X      }
X   else {
X/* for (lines=0; lines<max && ngets(buff2,fp) && !(status & S_INT); lines++) */
X      for (lines=0; lines<max && ngets(buff2,fp); ) {
X         if (buff2[0]!='#' || !(fl & GF_IGNCMT))
X            mem[lines++]=xstrdup(buff2);
X      }
X   }
X   mclose(fp);
X   if (lines<max) mem=xrealloc(mem,lines);
X   else if (lines==MAX_LINES) {
X      printf("Error: %s too long\n",buff);
X      mem=xrealloc(mem,(short)0);
X   }
X   return mem;
X}
X
X/******************************************************************************/
X/* GRAB SOME MORE OF A FILE UNTIL WE FIND SOME STRING                         */
X/******************************************************************************/
Xchar **              /* RETURNS: (nothing)                  */
Xgrab_more(fp,end,fl) /* ARGUMENTS:                          */
XFILE *fp;            /*    Input file pointer               */
Xchar *end;           /*    String to stop after             */
Xchar  fl;            /*    Flags (see lib.h)                */
X{
X   char **mem;
X   char buff[MAX_LINE_LENGTH];
X   short lines,max;
X
X   max=(fl & GF_HEADER)? HEADER_LINES : MAX_LINES;
X   mem=xalloc(max,sizeof(char *));
X   if (flags & O_DEBUG)
X      printf("MEM: %x size=%d  want %d  eltsize=%d\n", mem, sizeof(mem), 
X       max, sizeof(char *));
X   if (fl & GF_WORD) /* count each word as a line */
X      for (lines=0; lines<max && fscanf(fp,"%s",buff)==1; lines++) {
X         mem[lines]=xstrdup(buff);
X         if (end && !strcmp(buff,end)) break;
X      }
X   else 
X      for (lines=0; lines<max && ngets(buff,fp); lines++) {
X         if (end && buff[0]==end[0] && buff[1]==end[0])
X            mem[lines]=xstrdup(buff+2);
X         else
X            mem[lines]=xstrdup(buff);
X         if (end && (!strcmp(buff,end) || !strncmp(buff,",R",2))) break;
X      }
X   if (lines<max) mem=xrealloc(mem,lines);
X   return mem;
X}
X
X/* return static string of fields */
Xvoid
Ximplode(buff,arr,sep,start)
Xchar *buff;
Xchar **arr;
Xchar *sep;
Xshort start;
X{
X   short i,s;
X
X   buff[0]='\0';
X   s = xsizeof(arr);
X   if (s>start) strcpy(buff,arr[start]);
X   for (i=start+1; i<s; i++) {
X      strcat(buff,sep);
X      strcat(buff,arr[i]);
X   }
X}
X
X/******************************************************************************/
X/* SPLIT A STRING INTO AN ARRAY OF FIELDS                                     */
X/******************************************************************************/
Xchar **                     /* RETURNS: (nothing)                  */
Xexplode(str,sep)            /* ARGUMENTS:                          */
Xchar *str;                  /*    Filename to read into memory     */
Xchar *sep;                  /*    Field separator string           */
X{
X   char **mem,*ln,*nstr;
X   short lines;
X
X   mem=xalloc(MAX_LINES,sizeof(char *));
X   nstr=xstrdup(str);
X
X   if (sep) {
X      ln=strtok(nstr,sep);
X      for (lines=0; ln && lines<MAX_LINES; lines++) {
X         while (*ln == ' ') ln++; /* skip leading spaces */
X         mem[lines]=xstrdup(ln);
X         while (strlen(mem[lines]) && mem[lines][ strlen(mem[lines])-1 ] == ' ')
X            mem[lines][ strlen(mem[lines])-1 ] = 0; /* trash trailing spaces */
X         ln = strtok(NIL,sep);
X      }
X   } else {
X      mem[0]=xstrdup(str);
X      lines=1;
X   }
X
X   mem=xrealloc(mem,lines);
X   xfree(nstr);
X   return mem;
X}
X
X/******************************************************************************/
X/* APPEND A LINE TO A FILE                                                    */
X/******************************************************************************
XFunction:    char write_file(char *filename, char *string)
XCalled by:  
XArguments:   filename to put stuff in, string to put there
XReturns:     1 on success, 0 if error
XCalls:
XDescription: Appends a block of text to a file with a single operation.
X             Locks & unlocks file to be safe.
X*******************************************************************************/
Xchar                        /* RETURNS: 1 on success, 0 if error   */
Xwrite_file(filename,str)    /* ARGUMENTS:                          */
Xchar *filename;             /*    Filename to append to            */
Xchar *str;                  /*    Block of text to write           */
X{
X   FILE *fp;
X   long mod=O_A;
X
X   if (st_glob.c_status & CT_BASIC) mod |= O_PRIVATE;
X   if ((fp=mopen(filename,mod))==NULL) return 0;
X   fwrite(str,strlen(str),1,fp);
X   mclose(fp);
X   return 1;
X}
X            
X/******************************************************************************/
X/* DUMP A FILE TO THE OUTPUT                                                  */
X/******************************************************************************
XFunction:    char cat(char *dir, char *filename)
XCalled by:   
XArguments:   filename to display
XReturns:     1 on success, 0 on failure
XCalls:
XDescription: Copies a file to the screen (not grab_file)
X*******************************************************************************/
Xchar                        /* RETURNS: (nothing)                  */
Xcat(dir,filename)           /* ARGUMENTS:                          */
Xchar *dir;                  /*    Directory containing file        */
Xchar *filename;             /*    Filename to display              */
X{
X   FILE *fp;
X   int c;
X   char buff[MAX_LINE_LENGTH];
X
X   if (filename)
X      sprintf(buff,"%s/%s",dir,filename);
X   else
X       strcpy(buff,dir);
X   if (flags & O_DEBUG) printf("cat: %s\n",buff);
X   if ((fp=mopen(buff,O_R))==NULL) return 0;
X   while ((c=fgetc(fp))!=EOF && !(status & S_INT)) wputchar(c);
X   mclose(fp);
X   return 1;
X}
Xextern char pipebuf[MAX_LINE_LENGTH];
X/******************************************************************************/
X/* DUMP A FILE TO THE OUTPUT THROUGH A PAGER                                  */
X/******************************************************************************
Xchar                        /* RETURNS: (nothing)                  */
Xmore(dir,filename)          /* ARGUMENTS:                          */
Xchar *dir;                  /*    Directory containing file        */
Xchar *filename;             /*    Filename to display              */
X{
X   FILE *fp,*pp;
X   char buff[MAX_LINE_LENGTH];
X   int c;
X
X   /* Need to check if pager exists */
X   if (!pipebuf[0]) strcpy(pipebuf,expand("pager",DM_VAR));
X   if (!(flags & O_BUFFER) || !pipebuf[0])
X      return cat(dir,filename);
X
X   if (filename)
X      sprintf(buff,"%s/%s",dir,filename);
X   else
X       strcpy(buff,dir);
X   if (flags & O_DEBUG) printf("CAT: %s\n",buff);
X   if ((fp=mopen(buff,O_R))==NULL) return 0;
X   open_pipe();
X   while ((c=fgetc(fp))!=EOF) 
X      if (fputc(c,st_glob.outp)==EOF) break;
X   spclose(st_glob.outp);
X   mclose(fp);
X   status &= ~S_INT;
X   return 1;
X}
X
X/******************************************************************************/
X/* GET INPUT WITHOUT ECHOING IT                                               */
X/******************************************************************************/
Xchar *         /* RETURNS: text entered */
Xget_password() /* ARGUMENTS: (none)     */
X{
X   static char buff[MAX_LINE_LENGTH];
X   short i=0,c;
X 
X   unix_cmd("/bin/stty -echo");
X   while ((c=getchar())!=10 && c!=13 && c!= -1 && i<MAX_LINE_LENGTH) 
X      buff[i++]=c;
X   buff[i]=0;
X   putchar('\n');
X   unix_cmd("/bin/stty echo");
X   return buff;
X}
X
X/******************************************************************************/
X/* GET INPUT WITHOUT OVERFLOWING BUFFER                                       */
X/******************************************************************************/
Xchar *        /* RETURNS: text entered */
Xngets(str,fp) /* ARGUMENTS:            */
Xchar *str;    /*    Input buffer       */
XFILE *fp;     /*    Input stream       */
X{
X   char *ok;
X   int i,j,strip=0;
X   char buff[MAX_LINE_LENGTH];
X   struct sigvec vec;
X
X   if (fp==st_glob.inp) {
X      if (status & S_REDIRECT)
X         spclose(st_glob.outp); 
X
X      /* Make INT abort fgets() */
X      sigvec(SIGINT,  NULL, &vec);
X      vec.sv_flags |= SV_INTERRUPT;
X      sigvec(SIGINT,  &vec, NULL);
X   }
X
X   ok=fgets(str,MAX_LINE_LENGTH,fp);
X   
X   if (fp==st_glob.inp) {
X
X      /* Stop INT from aborting fgets() */
X      sigvec(SIGINT,  NULL, &vec);
X      vec.sv_flags &= ~SV_INTERRUPT;
X      sigvec(SIGINT,  &vec, NULL);
X
X      if (!ok) { 
X	 if (fp==stdin) {
X            clearerr(fp); 
X            printf("\n"); 
X	 } else {
X	    mclose(fp);
X	    st_glob.inp = stdin;
X	    return ngets(str, st_glob.inp);
X	 }
X      }
X   }
X   if (ok)
X      str[ strlen(str)-1 ] =0; /* trash newline */
X   else if ((status & S_INT) && (fp==st_glob.inp)) {
X      /* for systems where interrupts abort fgets */
X      str[0]='\0';
X      return str;
X   }
X
X   if ((fp==st_glob.inp) && (flags & O_STRIP)) {
X      for (i=j=0; i<strlen(str); i++) {
X         if (isprint(str[i]) || isspace(str[i])) buff[j++]=str[i];
X         else {
X            printf("%s ^%c",(strip++)? "" : "Stripping bad input:", str[i]+64);
X         }
X      }
X      if (strip) printf("\n");
X      buff[j]='\0';
X      strcpy(str,buff);
X   }
X   return ok;
X}
X
X/******************************************************************************/
X/* GET INPUT UNTIL USER SAYS YES OR NO                                        */
X/******************************************************************************/
Xchar        /* RETURNS: 1 for yes, 0 no */
Xget_yes(pr) /* ARGUMENTS:               */
Xchar *pr;   /*    Prompt                */
X{
X   char buff[MAX_LINE_LENGTH];
X   
X   for(;;) {
X      if (status & S_MOTIF)
X         wgets(buff,pr);
X      else {
X         wputs(pr);
X         if (!ngets(buff,st_glob.inp)) return 0;
X      }
X      if (match(buff,"n_on") || match(buff,"nop_e")) return 0;
X      if (match(buff,"y_es") || match(buff,"ok")) return 1;
X      printf("Try yes or no.\n");
X   } 
X}
X
X#ifdef NOSTRNICMP
X/******************************************************************************/
X/* STANDARD strnicmp() CODE FOR THOSE OS'S WHICH DON'T HAVE IT                */
X/******************************************************************************/
Xint 
Xstrnicmp(a,b,n)
Xchar *a,*b;
Xint  n;
X{
X   char *s;
X   for (s=a; (tolower(*s) == tolower(*b)) && (s-a < n); s++, b++)
X      if (*s == '\0')
X         return 0;
X   if (s-a >= n) return 0;
X   return tolower(*s) - tolower(*b);
X}
X#endif
X
X/******************************************************************************/
X/* READ IN ASSOCIATIVE LIST                                                   */
X/* ! and # begin comments and are not part of the list                        */
X/* =filename chains to another file                                           */
X/******************************************************************************/
Xchar                              /* RETURNS: 1 on success, 0 error */
Xgrab_list(dir,filename,list,size) /* ARGUMENTS:                     */
Xchar   *dir;                      /*    Directory containing file   */
Xchar   *filename;                 /*    Filename to read from       */
Xassoc_t list[];                   /*    Array to fill in            */
Xshort  *size;                     /*    Size of array               */
X{
X   FILE *fp;
X   char buff[MAX_LINE_LENGTH],name[MAX_LINE_LENGTH],*loc;
X
X   if (filename && dir) sprintf(name,"%s/%s",dir,filename);
X   else if (dir)        strcpy(name,dir);
X   else if (filename)   strcpy(name,filename);
X   else return 0;
X
X   if ((fp=mopen(name,O_R|O_SILENT))==NULL) {
X      error("grabbing list ",name);
X      return 0;
X   }
X
X   do {
X      loc=ngets(buff,fp);
X   } while(loc && (buff[0]=='#' || buff[0]=='!'));
X   if (!loc) {
X      (void)fprintf(stderr,"Error: %s is empty.\n",name);
X      return 0;
X   }
X   list[0].name     = xstrdup("");
X   list[0].location = xstrdup(buff);
X   if (flags & O_DEBUG) printf("Default: '%s'\n",buff);
X   if (strchr(buff,':')) 
X      (void)fprintf(stderr,"Warning: %s may be missing default.\n",name);
X   
X   for (*size =1; ngets(buff,fp) && (*size)<MAX_LIST_LENGTH; ) {
X      if (flags & O_DEBUG) printf("Buff: '%s'\n",buff);
X      if (buff[0]=='#' || buff[0]=='\0') continue;
X      if (loc = strchr(buff,':')) {
X         strncpy(name,buff,loc-buff);
X         name[loc-buff]=0;
X         loc++;
X
X         list[*size].name     = xstrdup(name);
X         list[*size].location = xstrdup(loc);
X         if (flags & O_DEBUG)
X            printf("Name: '%s' Dir: '%s'\n",list[*size].name, 
X             list[*size].location);
X         (*size)++;
X
X      /* Chain to another file */
X      } else if (buff[0]=='=' && strlen(buff)>1) {
X         mclose(fp);
X
X         if (buff[1]=='%') sprintf(name,"%s/%s",bbsdir,buff+2);
X         else if (dir)     sprintf(name,"%s/%s",dir,buff+1);
X         else              strcpy(name,buff+1);
X
X         if ((fp=mopen(name,O_R|O_SILENT))==NULL) {
X            error("grabbing list ",name);
X            return 1;
X         }
X         ngets(buff,fp); /* read magic line */
X         if (flags & O_DEBUG) printf("grab_list: magic %s\n",buff);
X
X      } else {
X         (void)fprintf(stderr,"UNK Bad line read: %s\n",buff);
X      }
X   }
X   mclose(fp);
X   if (*size == MAX_LIST_LENGTH) 
X      printf("Warning: list length exceeded.\n");
X   return 1;
X}
X
X/******************************************************************************/
X/* CONVERT TIMESTAMP INTO A STRING IN VARIOUS FORMATS                         */
X/******************************************************************************/
Xchar *          /* RETURNS: Date string */
Xget_date(t,sty) /* ARGUMENTS:           */
Xtime_t t;       /*    Timestamp         */
Xchar sty;       /*    Output style      */
X{
X   static char buff[MAX_LINE_LENGTH];
X   struct tm *tms;
X   static char *fmt[]={
X#ifdef NOEDATE
X   /*  0 */ "%a %b %d %H:%M:%S %Y",         /* dates must be in 05 format */
X   /*  1 */ "%a, %b %d, %Y (%H:%M)",  
X#else
X   /*  0 */ "%a %b %e %H:%M:%S %Y",         /* dates need not have leading 0 */
X   /*  1 */ "%a, %b %e, %Y (%H:%M)", 
X#endif
X   /*  2 */ "%a", 
X   /*  3 */ "%b",
X   /*  4 */ "%e",
X   /*  5 */ "%y",
X   /*  6 */ "%Y",
X   /*  7 */ "%H",
X   /*  8 */ "%M",
X   /*  9 */ "%S",
X   /* 10 */ "%I",
X   /* 11 */ "%p",
X   /* 12 */ "%p",
X#ifdef NOEDATE
X   /* 13 */ "(%H:%M:%S) %B %d, %Y"
X#else
X   /* 13 */ "(%H:%M:%S) %B %e, %Y"
X#endif
X   };
X
X   tms = localtime(&t);
X   if (sty<0 || sty>13) sty=0;
X   strftime(buff,MAX_LINE_LENGTH,fmt[sty],tms);
X   return buff;
X}
X
X/******************************************************************************/
X/* GENERATE STRING WITHOUT ANY "'_s IN IT                                     */
X/******************************************************************************/
Xchar *       /* RETURNS: New string */
Xnoquote(s,x) /* ARGUMENTS:          */
Xchar *s;     /*    Original string  */
Xint x;       /*    Remove _'s too?  */
X{
X   static char buff[MAX_LINE_LENGTH];
X   char *p,*q,qu=0;
X
X   q=s;
X   if (*q=='"' || *q=='\'') { qu= *q; q++; }
X   for (p=buff; *q; q++)
X      if (x==0 || *q != '_')
X         *p++ = *q;
X   *p=0;
X   p--;
X   if (p>=buff && *p==qu) *p=0;
X   return buff;
X}
X
X/******************************************************************************/
X/* GENERATE STRING WITHOUT ANY _'s IN IT                                      */
X/******************************************************************************/
Xchar *      /* RETURNS: New string */
Xcompress(s) /* ARGUMENTS:          */
Xchar *s;    /*    Original string  */
X{
X   static char buff[MAX_LINE_LENGTH];
X   char *p,*q;
X
X   for (p=buff,q=s; *q; q++)
X      if (*q != '_') 
X         *p++ = *q;
X   *p=0;
X   return buff;
X}
X
Xvoid
Xerror(str1,str2)
Xchar *str1,*str2;
X{
X   FILE *fp;
X   char errorlog[MAX_LINE_LENGTH];
X   char timestamp[MAX_LINE_LENGTH];
X   time_t t;
X
X   if (errno)
X      fprintf(stderr,"Got error %d (%s) in %s%s\n",errno,sys_errlist[errno],
X       str1,str2);
X   sprintf(errorlog,"%s/errorlog",bbsdir);
X   if (fp=fopen(errorlog,"a")) {
X      time(&t);
X      strcpy(timestamp,ctime(&t)+4);
X      timestamp[20]='\0';
X      if (errno)
X         fprintf(fp,"%-8s %s Got error %d (%s) in %s%s\n",
X          login, timestamp, errno,sys_errlist[errno],str1,str2);
X      else
X         fprintf(fp,"%-8s %s WARNING: %s%s\n", login, timestamp, str1,str2);
X      fclose(fp);
X   }
X}
X
Xchar *
Xlower_case(arg)
Xchar *arg;
X{
X   char lwr[MAX_LINE_LENGTH];
X   int  i;
X
X   for (i=0; i<=strlen(arg); i++)
X     lwr[i] = tolower(arg[i]);
X   return lwr;
X}
END_OF_FILE
if test 20276 -ne `wc -c <'lib.c'`; then
    echo shar: \"'lib.c'\" unpacked with wrong size!
fi
# end of 'lib.c'
fi
if test -f 'news.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'news.c'\"
else
echo shar: Extracting \"'news.c'\" \(14362 characters\)
sed "s/^X//" >'news.c' <<'END_OF_FILE'
X/* NEWS.C */
Xstatic   char sccsid[] = "@(#)news.c 1.3 94/01/20 (c)1993 thalerd";
X#include <stdio.h>
X#include <string.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <dirent.h>
X#include <ctype.h>
X#include "config.h"
X#include "struct.h"
X#include "news.h"
X#include "arch.h"
X#include "item.h"
X#include "sep.h"
X#include "range.h"
X#include "sum.h"
X#include "files.h"
X#include "globals.h"
X#include "xalloc.h"
X#include "lib.h"
X#include "stats.h"
X#include "rfp.h"   /* for add_response */
X
X#ifdef NEWS
X
X/* So far each item can only have 1 response */
X
Xint
Xmake_rnhead(re,par)
Xresponse_t *re;
Xshort par;
X{
X   FILE *fp,*pp,*sp;
X   flag_t ss;
X   char buff[MAX_LINE_LENGTH];
X   short curr;
X   register int cpid,wpid;
X   int statusp;
X   char *sub;
X   char **config;
X
X   sub = get_subj(confidx, st_glob.i_current-1, sum);
X   if (!(config = get_config(confidx)))
X      return 0;
X
X   /* Fork & setuid down when creating .rnhead */
X   if (cpid=fork()) { /* parent */
X      if (cpid<0) return -1; /* error: couldn't fork */
X      while ((wpid = wait(&statusp)) != cpid && wpid != -1);
X      /* post = !statusp; */
X   } else { /* child */
X      if (setuid(getuid())) error("setuid","");
X      setgid(getgid());
X
X      sprintf(buff,"%s/.rnhead",home);
X      if (!(fp = mopen(buff,O_W))) exit(1);
X      fprintf(fp,"Newsgroups: %s\n",config[CF_NEWSGROUP]);
X      fprintf(fp,"Subject: %s%s\n",(sub)?"Re: ":"", 
X       (sub)? sub : "" );
X      fprintf(fp,"Summary: \nExpires: \n");
X   
X      /* add parents mids:
X      fprintf(fp,"References:"); 
X      buff[0]='\0';
X      for (curr = par-1; curr>=0; curr = re[curr].parent-1) {
X         sprintf(buff2," <%s>%s", message_id(compress(conflist[confidx].name),
X             st_glob.i_current,curr,re), buff); 
X         strcpy(buff,buff2);   
X      }
X      fprintf(fp,"%s\n",buff);
X      */
X      if (par>0)
X         fprintf(fp,"References: <%s>\n", message_id(compress(
X     conflist[confidx].name), st_glob.i_current, curr,re));
X
X      fprintf(fp,"Sender: \nFollowup-To: \nDistribution: world\n");
X      fprintf(fp,"Organization: \nKeywords: \n\n");
X      if (par > 0) { /* response to something? */
X         pp = st_glob.outp;
X         ss = status;
X         st_glob.r_current = par-1;
X         st_glob.outp = fp;
X         status |= S_REDIRECT;
X   
X         dump_reply("newssep");
X   
X         st_glob.outp = pp;
X         status     = ss;
X   
X         /* dump_reply("newssep"); don't dump to screen */
X      }
X      sprintf(buff,"%s/.signiture",home);
X      if (sp = mopen(buff,O_R)) {
X         fprintf(fp,"--\n");
X         while (ngets(buff,sp))
X       fprintf(fp,"%s\n",buff);
X         mclose(sp);
X      }
X      mclose(fp);
X      exit(0);
X   }
X   return 1;
X}
X
X/******************************************************************************/
X/* NEWS_ITEM_SUM: Incorporate a new article (art) into an item                */
X/******************************************************************************/
Xint                    /* RETURNS: 1 on valid, 0 else      */
Xnews_item_sum(art,sum,part,stt,idx) /* ARGUMENTS: */
Xlong         art;      /*    Article number to incorporate */
Xsumentry_t  *sum;      /*    Item summary array to fill in */
Xpartentry_t *part;     /*    Participation info            */
Xshort        idx;      /*    Conference index              */
Xstatus_t    *stt;
X{
X   FILE       *fp;
X   char        path[MAX_LINE_LENGTH];
X   char        buff[MAX_LINE_LENGTH];
X   char        sj[MAX_LINE_LENGTH], mid[MAX_LINE_LENGTH],
X               fromF[MAX_LINE_LENGTH],fromL[MAX_LINE_LENGTH];
X   short       i;
X   sumentry_t  this;
X   char      **config;
X
X   /* Load in Subject and Date */
X   if (!(config = get_config(idx)))
X      return 0;
X   sprintf(path,"%s/%s/%ld",NEWSDIR,dot2slash(config[CF_NEWSGROUP]),art);
X   if ((fp = mopen(path,O_R))==NULL) return 0;
X   do {
X      ngets(buff,fp); 
X      if (!strncmp(buff,"Subject: ",9)) {
X         strcpy(sj , buff+9);
X      } else if (!strncmp(buff,"Date: ",6)) {
X    char *b;
X    for (b=buff+6; *b && !isdigit(*b); b++);
X    getdate(&(this.last),b);
X    this.first = this.last;
X      } else if (!strncmp(buff,"From: ",6)) {
X            char *p,*q;
X
X            if (p = strchr(buff+6,'(')) { /* login (fullname) */
X               sscanf(buff+6,"%s",fromL);
X               q = strchr(p,')');
X               strncpy(fromF,p+1, q-p-1);
X               fromF[q-p-1]='\0';
X       } else if (p = strchr(buff+6,'<')) { /* fullname <login> */
X               strncpy(fromF,buff+6, p-buff-6);
X               fromF[p-buff-6]='\0';
X               q = strchr(p,'>');
X               strncpy(fromL,p+1, q-p-1);
X               fromL[q-p-1]='\0';
X       } else { /* login */
X               strcpy(fromL,buff+6);
X               strcpy(fromF,fromL);
X       }
X      } else if (!strncmp(buff,"Message-ID: <",13)) {
X       char *p;
X         p = strchr(buff,'>');
X       *p='\0';
X       strcpy(mid,buff+13);
X      }
X   } while (strlen(buff)); /* until blank line */
X   mclose(fp);
X
X   /* Find what item it should go in */
X   i=stt->i_last+1;
X/* Duplicate subjects are separate items */
X   if (!strncmp(sj,"Re: ",4)) 
X      for (i=stt->i_first; 
X           i<=stt->i_last && (!sum[i-1].nr 
X          || (strcmp(sj+4, get_subj(idx,i-1,sum)) 
X           && strcmp(sj,   get_subj(idx,i-1,sum)))); 
X         i++);
X/* Duplicate subjects in same item 
X   for (i=stt->i_first; 
X        i<=stt->i_last && (!sum[i-1].nr 
X    || ((strcmp(sj+4, get_subj(idx,i-1,sum)) || strncmp(sj,"Re: ",4)) 
X     && strcmp(sj, get_subj(idx, i-1, sum)))); 
X   i++);
X */
X   if (i>stt->i_last) {
X      i=stt->i_last+1;
X
X      /* Enter a new item */
X/* printf("%d Subject '%s' is new item %d\n",art,sj,i); */
X		printf(".");
X      this.nr = 1;
X      this.flags = IF_ACTIVE;
X      do_enter(&this,sj,NULL,idx,sum,part,stt,art,mid,
X       uid,fromL,fromF);
X      store_subj(idx, i-1, sj);
X   } else {
X      short resp=0;
X
X      /* KKK Find previous reference for parent */
X
X      /* Response to item i */
X/* printf("%d Subject '%s' is response to item %d\n",art,sj,i); */
X		printf(".");
X      stt->i_current = i;
X      add_response(&this,NULL,idx,sum,part,stt,art,
X       mid,uid,fromL,fromF,resp);
X
X   }
X   return 1;
X}
X
Xvoid
Xnews_show_header()
X{
X   short pr;
X   FILE *fp;
X   char  buff[MAX_LINE_LENGTH];
X   char **config;
X
X   open_pipe();
X   if (!(config = get_config(confidx)))
X      return;
X   sprintf(buff,"%s/%s/%d",NEWSDIR,dot2slash(config[CF_NEWSGROUP]),st_glob.i_current);
X   if (fp=mopen(buff,O_R)) {
X      st_glob.r_current = 0; /* current resp = header */
X      get_resp(fp,re,(short)GR_HEADER,(short)0); /* Get header of #0 */
X/* The problem here is that itemsep uses r_current as an index to
X   the information in re, so we can't show # new responses
X      st_glob.r_current = sum[st_glob.i_current-1].nr
X       - abs(part[st_glob.i_current-1].nr);
X */
X
X      /* Get info about the actual item text if possible */
X      if (re[st_glob.r_current].flags & (RF_EXPIRED|RF_SCRIBBLED))
X    pr = 0;
X      else if (re[st_glob.r_current].flags & RF_CENSORED)
X         pr = ((st_glob.opt_flags & OF_NOFORGET) ||!(flags & O_FORGET));
X      else
X     pr = 1;
X
X      if (pr) get_resp(fp,&(re[st_glob.r_current]),(short)GR_ALL,st_glob.r_current);
X      if ((re[st_glob.r_current].flags & RF_SCRIBBLED)
X       && re[st_glob.r_current].numchars>7) {
X         fseek(fp,re[st_glob.r_current].textoff,0);
X         ngets(buff,fp);
X         re[st_glob.r_current].text = (char**)buff;
X      }
X
X      sepinit(IS_CENSORED|IS_UID|IS_DATE);
X      itemsep((st_glob.opt_flags & OF_SHORT)?"ishort":"isep",0);
X      if (pr) xfree(re[st_glob.r_current].text);
X      st_glob.r_current = 0; /* current resp = header */
X      mclose(fp);
X   }
X}
X
Xchar *
Xmessage_id(c,i,r,re)
Xchar       *c;
Xshort       i,r;
Xresponse_t *re;      /*    Response to make id for     */
X{
X   char str[MAX_LINE_LENGTH];
X
X   if (!re[r].mid) {
X      sprintf(str,"%d.%d.%X@%s",r,re[r].uid,re[r].date,hostname);
X      re[r].mid = xstrdup(str);
X   }
X   return re[r].mid;
X}
X
X/******************************************************************************/
X/* GET AN ACTUAL ARTICLE                                                      */
X/******************************************************************************/
Xvoid                     /* RETURNS: (nothing)             */
Xget_article(re)      /* ARGUMENTS                      */
Xresponse_t *re;          /*    Response to fill in         */
X{                        /* LOCAL VARIABLES:               */
X   char       buff[MAX_LINE_LENGTH];
X   char       done=0;
X   FILE      *fp;        /*    Article file pointer        */
X   char     **config;
X
X   re->text = NULL;
X   if (!(config = get_config(confidx))) {
X      re->flags  |= RF_EXPIRED;
X      return;
X   }
X   sprintf(buff,"%s/%s/%d",NEWSDIR,dot2slash(config[CF_NEWSGROUP]),re->article);
X   if ((fp=mopen(buff,O_R|O_SILENT))==NULL) {
X      re->flags  |= RF_EXPIRED;
X      /* anything else? */
X      return;
X   }
X
X   /* Get response */
X   re->flags   = 0;
X   if (re->mid) { xfree(re->mid); re->mid = NULL; }
X   re->parent = re->article = 0;
X
X   while (!done && !(status & S_INT)) {
X      if (!ngets(buff,fp)) {
X         done=1; 
X         break; 
X      }
X
X#if 0
X      if (!strncmp(buff,"From: ",6)) {
X         char *p,*q;
X
X         if (p = strchr(buff+6,'(')) { /* login (fullname) */
X            sscanf(buff+6,"%s",n1);
X            q = strchr(p,')');
X            strncpy(n2,p+1, q-p-1);
X            n2[q-p-1]='\0';
X    } else if (p = strchr(buff+6,'<')) { /* fullname <login> */
X            strncpy(n2,buff+6, p-buff-6);
X            n2[p-buff-6]='\0';
X            q = strchr(p,'>');
X            strncpy(n1,p+1, q-p-1);
X            n1[q-p-1]='\0';
X    } else { /* login */
X            strcpy(n1,buff+6);
X            strcpy(n2,n1);
X    }
X
X         re->uid = 0;
X         if (re->login) xfree(re->login);
X         re->login = xstrdup(n1);
X         if (re->fullname) xfree(re->fullname);
X         re->fullname=xstrdup(n2);
X      } else if (!strncmp(buff,"Date: ",6)) {
X         getdate(&(re->date),buff+11);
X      } else 
X#endif
X      if (!strncmp(buff,"Message-ID: <",13)) {
X       char *p;
X         p = strchr(buff,'>');
X       *p='\0';
X       re->mid = xstrdup(buff+13);
X      } else if (!strlen(buff)) {
X     long textoff;
X
X          textoff = ftell(fp); 
X          re->text = grab_more(fp,(flags & O_SIGNITURE)?NULL:"--",0);
X          re->numchars= ftell(fp) - textoff;
X          done=1;
X          break;
X      }
X   }
X   mclose(fp);
X}
X
X/******************************************************************************/
X/* DOT2SLASH: Return directory/string/form of news.group.string passed in     */
X/******************************************************************************/
Xchar *         /* RETURNS: Slash-separated string */
Xdot2slash(str) /* ARGUMENTS:                      */
Xchar *str;     /*    Dot-separated string         */
X{
Xstatic char buff[MAX_LINE_LENGTH];
X       char *f,*t;
X
X   for (f=str,t=buff; *f; f++,t++) {
X      *t = (*f == '.')? '/' : *f;
X   }
X   *t = '\0';
X   return buff;
X}
X
X/******************************************************************************/
X/* REFRESH_NEWS: Look for any new articles, and if any are found, incorporate */
X/* them into item files                                                       */
X/******************************************************************************/
Xvoid                                     /* RETURNS: (nothing)             */
Xrefresh_news(sum,part,stt,idx) /* ARGUMENTS:                     */
Xsumentry_t  *sum;                        /*    Summary array to update     */
Xpartentry_t *part;                       /*    Participation info          */
Xshort        idx;                        /*    Conference index to update  */
Xstatus_t    *stt;                        /*    Status info to update       */
X{
X   char           path[MAX_LINE_LENGTH],
X                  artpath[MAX_LINE_LENGTH],
X                  fmt[MAX_LINE_LENGTH];
X   struct stat    st;
X   char         **config;
X   long           article;
X   DIR           *fp;
X	FILE          *artp;
X   struct dirent *dp;
X   int            i;
X
X   strcpy(fmt,"%d");
X   if (!(config = get_config(idx)))
X      return;
X
X   sprintf(path,"%s/%s",NEWSDIR,dot2slash(config[CF_NEWSGROUP]));
X   if (stat(path,&st)) {
X      error("refreshing ",path);
X      return;
X   }
X
X   /* Is there new stuff? */
X   if (st.st_mtime!=stt->sumtime) {
X      long mod;
X      struct stat artst;
X
X      sprintf(artpath,"%s/article",conflist[idx].location);
X
X      /* Create if doesn't exist, else update */
X      if (stat(artpath,&artst)) mod = O_W;
X      else                      mod = O_RPLUS;
X
X      /* if (stt->c_security & CT_BASIC) mod |= O_PRIVATE;*/
X      if ((artp=mopen(path, mod))==NULL) return;  /* can't lock */
X
X      if ((fp = opendir(path))==NULL) {
X         error("opening ",path);
X         return;
X      }
X      refresh_stats(sum,part,stt); /* update stt */
X     
X      /* Load in stats 1 piece at a time - the slow stuff */
X      article = stt->c_article;
X      for (dp = readdir(fp); dp != NULL && !(status & S_INT); dp=readdir(fp)) {
X         long i2;
X         if (sscanf(dp->d_name,fmt,&i2)==1 && i2>stt->c_article) {
X            news_item_sum(i2,sum,part,stt,idx);
X            if (i2>article) {
X               article=i2;
X					fseek(artp, 0L, 0);
X               fprintf(artp,"%ld\n",article);
X            }
X            refresh_stats(sum,part,stt); /* update stt */
X         }
X      }
X      closedir(fp);
X
X      /* Check for expired */
X      for (i=stt->i_first; i<=stt->i_last; i++) {
X         response_t re;
X         FILE *fp2;
X         char buff[MAX_LINE_LENGTH];
X
X         sprintf(buff,"%s/_%d",conflist[idx].location,i);
X         if (fp2=mopen(buff,O_R)) {
X            re.fullname = re.login = re.mid = 0;
X            re.text = 0;
X            re.offset = -1;
X
X            get_resp(fp2, &re, GR_ALL, 0);
X            if (re.flags & RF_EXPIRED)
X               sum[i-1].flags |= IF_EXPIRED;
X            mclose(fp2);
X
X            if (re.fullname) xfree(re.fullname);
X            if (re.login)    xfree(re.login);
X            if (re.text)     xfree(re.text);
X            if (re.mid)      xfree(re.mid);
X         }
X      }
X
X      stt->sumtime   = st.st_mtime; 
X      stt->c_article = article;
X      refresh_stats(sum,part,stt); /* update stt */
X      save_sum(sum,0,idx,stt);
X
X      mclose(artp); /* release lock on article file */
X   }
X}
X#endif
END_OF_FILE
if test 14362 -ne `wc -c <'news.c'`; then
    echo shar: \"'news.c'\" unpacked with wrong size!
fi
# end of 'news.c'
fi
if test -f 'sum.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sum.c'\"
else
echo shar: Extracting \"'sum.c'\" \(20727 characters\)
sed "s/^X//" >'sum.c' <<'END_OF_FILE'
X/* SUM.C */
Xstatic	char sccsid[] = "@(#)sum.c 1.5 94/01/22 (c)1993 thalerd";
X#include <stdio.h>
X#include <time.h>
X#include <sys/types.h> /* for sys/stat.h under ultrix */
X#include <sys/stat.h>
X#include <string.h>
X#include <memory.h>
X#include <stdlib.h>   /* for getenv() */
X#include <errno.h>
X#include <dirent.h>
X#include "config.h"
X#include "struct.h"
X#include "globals.h"
X#include "lib.h"
X#include "sum.h"
X#include "item.h"
X#include "xalloc.h"
X#include "files.h"
X#include "macro.h"
X#include "sep.h"
X#include "news.h"
X#include "stats.h"
X
X#define ST_LONG 0x01
X#define ST_SWAP 0x02
X
X#define SHORT_MAGIC 0x00001537L
X#define SHORT_BACK  0x37150000L
X#define LONG_MAGIC  0x12345678L
X#define LONG_BACK   0x78563412L
X#define OLD_YAPP    0x58585858L
X
Xtypedef struct {
X   long   flags,nr;
X   time_t last,first;
X} longsumentry_t;
X
Xlong
Xget_hash(str)
Xchar *str;
X{
X   long ret=0;
X   char *p;
X
X   for (p=str; *p; p++)
X      ret = (ret*4) ^ (*p);
X   return ret;
X}
X
Xlong
Xget_sumtype(buff)
Xchar *buff;
X{
X   long temp, sumtype;
X   short       swap=BYTESWAP; /* constant used for byte swap check */
X
X   /* Determine byte order & file type */
X   memcpy((char *)&temp, buff, sizeof(long));
X   switch(temp) {
X   case SHORT_MAGIC : sumtype = ST_LONG;            break;
X   case SHORT_BACK  : sumtype = ST_LONG  | ST_SWAP; break;
X   case LONG_MAGIC  : sumtype = 0;                  break;
X   case LONG_BACK   : sumtype = ST_SWAP;            break;
X   case OLD_YAPP    : swap=(*((char*)&swap)); 
X                      sumtype = swap * ST_SWAP;     break;
X   default: printf("invalid sum type = %08X\n", temp);
X            swap=(*((char*)&swap)); /* check which byte contains the 1 */
X            sumtype = swap * ST_SWAP;               break;
X   }
X
X#ifdef SDEBUG
X   printf("sum type = %08X (%d)\n", temp, sumtype);
X   printf("%s %s\n", (sumtype & ST_LONG)? "long":"short", 
X    (sumtype & ST_SWAP)? "swap":"normal");
X#endif
X   return sumtype;
X}
X
X/******************************************************************************/
X/* SWAP BYTES IF LOW BIT IN HIGH BYTE (INTEL)                                 */
X/* This is so machines with Intel processors and those with Motorola          */
X/* processors can both use the same data files on the same filesystem         */
X/******************************************************************************/
Xstatic void           /* RETURNS: (nothing)        */
Xbyteswap(word,length) /* ARGUMENTS:                */
Xchar *word;           /*    Byte string to reverse */
Xint length;           /*    Number of bytes        */
X{
X  int i;
X
X  if (length>1)
X     for (i = 0; i <= (length - 2) / 2; i++)
X       word[i] ^= (word[length - 1 - i] ^= (word[i] ^= word[length - 1 - i]));
X}
X
X#ifdef NEWS
Xvoid
Xsave_article(art, idx)
Xlong art;
Xshort idx;
X{
X   FILE       *fp;
X   char        path[MAX_LINE_LENGTH];
X   struct stat st;
X   long        mod;
X
X   sprintf(path,"%s/article",conflist[idx].location);
X
X   /* Create if doesn't exist, else update */
X   if (stat(path,&st)) mod = O_W;
X   else                mod = O_RPLUS;
X
X   /* if (stt->c_security & CT_BASIC) mod |= O_PRIVATE;*/
X   if ((fp=mopen(path, mod))==NULL) return;
X   fprintf(fp,"%ld\n",art);
X   mclose(fp);
X}
X
Xvoid
Xload_article(art,idx)
Xlong *art;
Xshort idx;
X{
X   FILE       *fp;
X   char        path[MAX_LINE_LENGTH];
X
X   sprintf(path,"%s/article",conflist[idx].location);
X
X   if ((fp=mopen(path, O_R))==NULL) {
X      *art = 0;
X      return;
X   }
X   fscanf(fp,"%d\n",art);
X   mclose(fp);
X}
X#endif
X 
X/******************************************************************************/
X/* SAVE SUM FILE FOR CONFERENCE                                               */
X/******************************************************************************/
Xvoid                       /* RETURNS: (nothing)              */
Xsave_sum(newsum,where,idx,stt) /* ARGUMENTS:                      */
Xsumentry_t *newsum;        /*    Modified record              */
Xshort       where;         /*    Index of modified record     */
Xshort       idx;           /*    Conference to write file for */
Xstatus_t   *stt;
X{
X   FILE       *fp;
X   short       i=1;
X   char        path[MAX_LINE_LENGTH], buff[17], 
X             **config;
X   sumentry_t  entry;
X   longsumentry_t  longentry;
X   short       swap=BYTESWAP; /* constant used for byte swap check */
X   long        mod;
X   struct stat st;
X   long         temp,
X               sumtype;
X
X   if (flags & O_DEBUG)
X      printf("SAVE_SUM %x %d\n", newsum, where); 
X
X   swap=(*((char*)&swap)); /* check which byte contains the 1 */
X
X   sprintf(path,"%s/sum",conflist[idx].location); 
X
X   /* Create if doesn't exist, else update */
X   if (stat(path,&st)) mod = O_W;
X   else                mod = O_RPLUS;
X
X   if (stt->c_security & CT_BASIC) mod |= O_PRIVATE;
X   if ((fp=mopen(path,mod))==NULL) return;
X
X   /* Determine file type */
X   if (mod==O_W || (i=fread(buff,16,1,fp)) <16) /* new file */
X      sumtype = ST_LONG;
X   else
X      sumtype = get_sumtype(buff+12);
X   rewind(fp);
X
X   if (!(config=get_config(idx)))
X      return;
X
X   /* Write header */
X   if (sumtype & ST_LONG) {
X      fwrite("!<sm02>\n",8,1,fp);
X      temp = get_hash( config[CF_PARTFILE] );
X      fwrite((char *)&temp,sizeof(long),1,fp);
X      temp = SHORT_MAGIC;
X      fwrite((char *)&temp,sizeof(long),1,fp);
X      temp = LONG_MAGIC;
X      fwrite((char *)&temp,sizeof(long),1,fp);
X   } else {
X      short tshort;
X
X      fwrite("!<pr03>\n",8,1,fp);
X      tshort = get_hash( config[CF_PARTFILE] );
X      fwrite((char *)&tshort,sizeof(short),1,fp);
X      temp = SHORT_MAGIC;
X      fwrite((char *)&tshort,sizeof(short),1,fp);
X      temp = LONG_MAGIC;
X      fwrite((char *)&temp,sizeof(long),1,fp);
X   }
X
X   for (i=1; i<=stt->i_last; i++) {
X      short t;
X
X   /* if (newsum[i-1].nr) printf("%d: %d\n",i,newsum[i-1].nr); */
X      t=newsum[i-1].flags;
X      newsum[i-1].flags &= IF_SAVEMASK;
X
X      if (sumtype & ST_LONG) {
X         longentry.nr    = newsum[i-1].nr;
X         longentry.flags = newsum[i-1].flags;
X         longentry.last  = newsum[i-1].last ;
X         longentry.first = newsum[i-1].first;
X         if (sumtype & ST_SWAP) {
X            byteswap((char*)&(longentry.nr   ),sizeof(long  ));
X            byteswap((char*)&(longentry.flags),sizeof(long  ));
X            byteswap((char*)&(longentry.first),sizeof(time_t));
X            byteswap((char*)&(longentry.last ),sizeof(time_t));
X         }
X         fwrite((char *)&longentry,sizeof(longsumentry_t),1,fp);
X      } else {
X         memcpy((char *)&entry,(char *)&(newsum[i-1]),sizeof(sumentry_t));
X         if (sumtype & ST_SWAP) {
X            byteswap((char*)&(entry.nr   ),sizeof(short ));
X            byteswap((char*)&(entry.flags),sizeof(short ));
X            byteswap((char*)&(entry.first),sizeof(time_t));
X            byteswap((char*)&(entry.last ),sizeof(time_t));
X         }
X         fwrite((char *)&entry,sizeof(sumentry_t),1,fp);
X      }
X
X      newsum[i-1].flags=t;
X   }
X
X   mclose(fp);
X}
X
Xvoid
Xrefresh_sum(item,idx,sum,part,stt)
Xshort item;
Xshort idx;
Xsumentry_t  *sum;        /*    Item summary             */
Xpartentry_t *part;       /*    User participation info  */
Xstatus_t    *stt;        /*    Status structure         */
X{
X   struct stat st;
X   char   path[MAX_LINE_LENGTH];
X   short  i,last,first;
X
X#ifdef NEWS
X   char **config;
X
X   if (!(config = get_config(idx)))
X      return;
X   if (stt->c_security & CT_NEWS) {
X      sprintf(path,"%s/%s",NEWSDIR,dot2slash(config[CF_NEWSGROUP]));
X      if (stat(path,&st)) {
X         stt->sumtime=0;
X         st.st_mtime    =1;
X      }
X      if (st.st_mtime!=stt->sumtime) {
X         load_sum(sum,part,stt,idx);
X         stt->sumtime = st.st_mtime; 
X      }
X      refresh_stats(sum,part,stt); /* update stt */
X      return;
X   }
X#endif
X
X   /* Is global information current? */
X   sprintf(path,"%s/sum",conflist[idx].location);
X   if (stat(path,&st)) {
X      stt->sumtime=0;
X      st.st_mtime    =1;
X   }
X   if (st.st_mtime!=stt->sumtime) {
X
X      /* Load global information */
X      load_sum(sum,part,stt,idx);
X      stt->sumtime = st.st_mtime;
X   }
X
X   /* Are links current? */
X   last  = (item)? item : MAX_ITEMS;
X   first = (item)? item : 1;
X   for (i=first-1; i<last; i++)
X      refresh_link(stt,sum,part,idx,i);
X
X   /* Need to refresh stats anyway, in case part[] changed */
X   refresh_stats(sum,part,stt); /* update stt */
X}
X
Xint                          /* RETURNS: 1 on valid, 0 else */
Xitem_sum(i,sum,part,idx,stt) /* ARGUMENTS: */
Xshort i;
Xsumentry_t  *sum;            /*    Item summary array to fill in */
Xpartentry_t *part;           /*    Participation info */
Xshort idx;                   /*    Conference index */
Xstatus_t *stt;
X{
X   FILE       *fp,*nfp;
X   char        path[MAX_LINE_LENGTH];
X   struct stat st;
X   char        buff[MAX_LINE_LENGTH];
X   long        art;
X   char      **config;
X
X   sum[i].flags=sum[i].nr=0;
X
X   sprintf(path,"%s/_%d",conflist[idx].location,i+1);
X   if (!(config = get_config(idx)))
X      return 0;
X   if (stat(path,&st)) 
X      return 0;
X   else
X      sum[i].flags |= IF_ACTIVE;
X   if (st.st_nlink > 1) 
X      sum[i].flags |= IF_LINKED;
X   if (!(st.st_mode & S_IWUSR))
X      sum[i].flags |= IF_FROZEN;
X   if (part[i].nr < 0)
X      sum[i].flags |= IF_FORGOTTEN;
X   sum[i].last = st.st_mtime;
X   if (!(st.st_mode & S_IRUSR) || !(fp = mopen(path,O_R))) {
X      sum[i].flags |= IF_RETIRED;
X      sum[i].nr     = 0;
X      sum[i].first  = 0;
X   } else {
X      if (st.st_mode & S_IXUSR)
X         sum[i].flags |= IF_RETIRED;
X      sum[i].nr     = 0; /* count them */
X
X      ngets(buff,fp); /* magic - ignore */
X      ngets(buff,fp); /* H - ignore if FAST */
X      store_subj(idx, i, buff+2);
X      ngets(buff,fp); /* R - ignore */
X      ngets(buff,fp); /* U - ignore */
X      ngets(buff,fp); /* A - ignore */
X      ngets(buff,fp); /* date */
X      sscanf(buff+2,"%x",&(sum[i].first));
X      while (ngets(buff,fp)) {
X         if (!strcmp(buff,",T")) sum[i].nr++; 
X
X#ifdef NEWS
X         if (!strncmp(buff,",N",2)) {
X            art = atoi(buff+2);
X
X            /* Check to see if it has expired */
X            sprintf(buff,"%s/%s/%d",NEWSDIR,dot2slash(config[CF_NEWSGROUP]),
X             art);
Xprintf("Checking %s ",buff);
X            if ((nfp=mopen(buff,O_R|O_SILENT))==NULL) {
X               sum[i].flags |= IF_EXPIRED;
Xprintf("EXPIRED\n");
X            } else {
X               mclose(nfp);
Xprintf("OK\n");
X            }
X
X            if (art > stt->c_article)
X               stt->c_article = art;
X            /* printf("Found article %d\n",art); */
X         }
X#endif
X      }
X      mclose(fp);
X   }
X   return 1;
X}
X
X/******************************************************************************/
X/* Load SUM data for arbitrary conference (requires part be done previously)  */
X/******************************************************************************/
Xvoid                         /* RETURNS: (nothing) */
Xload_sum(sum,part,stt,idx) /* ARGUMENTS: */
Xsumentry_t  *sum;            /*    Item summary array to fill in */
Xpartentry_t *part;           /*    Participation info */
Xstatus_t *stt;
Xshort idx;                   /*    Conference index */
X{
X   FILE       *fp;
X   short       i=1,j;
X   char        path[MAX_LINE_LENGTH];
X   char      **config;
X   struct stat st;
X   char        buff[MAX_LINE_LENGTH];
X   short       confitems=0;
X   short       swap=BYTESWAP; /* constant used for byte swap check */
X   long        sumtype=0;
X   long        temp;
X   short       tshort;
X
X   for (j=0; j<MAX_ITEMS; j++) {
X      sum[j].nr = sum[j].flags = 0;
X   }
X   
X   swap=(*((char*)&swap));
X   sprintf(path,"%s/sum",conflist[idx].location);
X
X   /* If SUM doesn't exist */
X   if ((fp=mopen(path,O_R|O_LOCK|O_SILENT))==NULL) {
X      DIR *fp;
X      struct dirent *dp;
X      char fmt[6];
X
X      strcpy(path,conflist[idx].location);
X      strcpy(fmt,"_%d");
X
X      if ((fp = opendir(path))==NULL) {
X         error("opening ",path);
X         return;
X      }
X     
X      /* Load in stats 1 piece at a time - the slow stuff */
X      for (dp = readdir(fp); dp != NULL; dp = readdir(fp)) {
X         long i2;
X         if (sscanf(dp->d_name,fmt,&i2)==1) {
X            i = i2-1;
X            confitems += item_sum(i,sum,part,idx,stt);
X         }
X      }
X      closedir(fp);
X
X      /* Load in stats 1 piece at a time - the slow stuff 
X      for (i=0; i<MAX_ITEMS; i++) {
X         confitems += item_sum(i,sum,part,idx,stt);
X      }
X      */
X
X#ifdef NEWS
X      /* Update ITEM files with new articles */
X      /* printf("Article=%d\n",stt->c_article); */
X      if (stt->c_security & CT_NEWS)
X         refresh_news(sum,part,stt,idx);
X#endif
X
X      return;
X   }
X
X   /* Read in SUM file - the fast stuff */
X   if (!stat(path,&st)) 
X      stt->sumtime = st.st_mtime;
X
X   if (!(i=fread(buff,16,1,fp)) 
X    || (strncmp(buff,"!<sm02>\n",8) && strncmp(buff,"!<pr03>\n",8))) {
X      mclose(fp);
X      errno=0;
X      error(path," failed magic check");
X      /* printf("WARNING: %s failed magic check\n",path); */
X
X      /* Load in stats 1 piece at a time - the slow stuff */
X      for (i=0; i<MAX_ITEMS; i++)
X         confitems += item_sum(i,sum,part,idx,stt);
X
X      refresh_stats(sum,part,stt);
X      save_sum(sum,(short)-1,idx,stt);
X      return;
X   }
X
X/*
X   fread((char *)&confitems, sizeof(confitems),1,fp); * skip first 16 bytes *
X   fread((char *)sum,sizeof(sumentry_t),1,fp); *fseek fails for some reason *
X*/
X
X   /* Determine byte order & file type */
X   sumtype = get_sumtype(buff+12);
X   if (!(config = get_config(idx)))
X      return;
X
X   if (sumtype & ST_LONG) {
X      fread((char *)&temp, sizeof(long), 1, fp); /* skip 4 more bytes */
X      memcpy((char *)&temp, buff+8, sizeof(long));
X
X      if (temp != get_hash( config[CF_PARTFILE] )) {
X         errno = 0;
X         error("bad participation filename hash for ", config[CF_PARTFILE]);
X      }
X   } else {
X      memcpy((char *)&tshort, buff+8, sizeof(short));
X      if (tshort != (short)get_hash( config[CF_PARTFILE] )) {
X         errno = 0;
X         error("bad participation filename hash for ", config[CF_PARTFILE]);
X      }
X   }
X
X#ifdef NEWS
X   if (stt->c_security & CT_NEWS)
X      load_article(&stt->c_article, idx);
X#endif
X
X   if (sumtype & ST_LONG) {
X      longsumentry_t longsum[MAX_ITEMS];
X      int i;
X
X      confitems=fread((char *)longsum, sizeof(longsumentry_t), MAX_ITEMS, fp);
X
X      for (i=0; i<confitems; i++) {
X         if (!longsum[i].nr) 
X            continue; /* skip if deleted */
X
X         if (sumtype & ST_SWAP) {
X            byteswap((char*)&(longsum[i].nr   ),sizeof(long  ));
X            byteswap((char*)&(longsum[i].flags),sizeof(long  ));
X            byteswap((char*)&(longsum[i].first),sizeof(time_t));
X            byteswap((char*)&(longsum[i].last ),sizeof(time_t));
X         }
X
X         sum[i].nr    = longsum[i].nr;
X         sum[i].flags = longsum[i].flags;
X         sum[i].first = longsum[i].first;
X         sum[i].last  = longsum[i].last;
X      }
X
X   } else {
X
X      confitems=fread((char *)sum, sizeof(sumentry_t), MAX_ITEMS, fp);
X
X      for (i=0; i<confitems; i++) {
X         if (!sum[i].nr) 
X            continue; /* skip if deleted */
X
X         /* Check for byte swapping and such */
X         if (sumtype & ST_SWAP) {
X            byteswap((char*)&(sum[i].nr   ),sizeof(short ));
X            byteswap((char*)&(sum[i].flags),sizeof(short ));
X            byteswap((char*)&(sum[i].first),sizeof(time_t));
X            byteswap((char*)&(sum[i].last ),sizeof(time_t));
X         }
X      }
X   }
X
X   mclose(fp);
X   /* printf("confitems=%d\n",confitems);*/
X
X   for (i=0; i<confitems; i++) {
X      if (!sum[i].nr) 
X         continue; /* skip if deleted */
X
X/*printf("i=%d : nr=%d fl=%d fi=%lX la=%lX\n",i,sum[i].nr,sum[i].flags,sum[i].first,sum[i].last);*/
X      if (sum[i].nr < 0 || sum[i].nr > MAX_RESPONSES) {
X         printf("UNK: Invalid format of sum file\n");
X         break;
X      }
X
X      if (part[i].nr < 0)
X         sum[i].flags |= IF_FORGOTTEN;
X
X      /* verify it's still linked, didnt used to check sumtime */
X      refresh_link(stt,sum,part,idx,i);
X   }
X
X   for (; i<MAX_ITEMS; i++) {
X      sum[i].flags=sum[i].nr=0;
X   }
X
X#ifdef NEWS
X   /* Update ITEM files with new articles */
X   if (stt->c_security & CT_NEWS)
X      refresh_news(sum,part,stt,idx);
X#endif
X}
X
Xvoid
Xrefresh_stats(sum,part,st)
Xsumentry_t  *sum;            /*    Sum array to fill in (optional)    */
Xpartentry_t *part;           /*    Previously read participation data */
Xstatus_t    *st;             /*    pointer to status structure */
X{
X   short i;
X
X   st->i_numitems = st->i_brandnew = st->i_newresp = st->i_unseen = 0;
X   st->i_first = MAX_ITEMS+1;
X   st->i_last  = 0;
X
X   for (i=1; i<=MAX_ITEMS; i++) {
X      if (sum[i-1].nr) {
X         if (!sum[i-1].flags || (sum[i-1].flags & IF_EXPIRED)) continue;
X         st->i_numitems++;
X         if (i<st->i_first) st->i_first=i;
X         if (i>st->i_last ) st->i_last =i;
X      }
X   }
X   for (i=1; i<=MAX_ITEMS; i++) {
X      if (sum[i-1].nr) {
X         if (!sum[i-1].flags) continue;
X         if ((sum[i-1].flags & (IF_RETIRED|IF_FORGOTTEN|IF_EXPIRED)) 
X     && (flags & O_FORGET))
X            continue;
X         if (!part[i-1].nr && sum[i-1].nr) {
X            st->i_unseen++; /* unseen */
X            /* if (part[i-1].last < sum[i-1].last) */
X            /* if (st->parttime < sum[i-1].last) before change new partfile */
X            if (part[i-1].last < sum[i-1].last)
X               st->i_brandnew++; 
X         } 
X/* 
X         else if (part[i-1].nr < sum[i-1].nr) st->i_newresp++;
X * the problem with the following is that we may have recently read A
X   response, but not ALL the responses -- Ok acc to Russ
X */
X         else if (part[i-1].last < sum[i-1].last) st->i_newresp++; 
X      }
X   }
X}
X
Xvoid
Xrefresh_link(stt,sum,part,idx,i)
Xstatus_t    *stt;            /*    pointer to status structure */
Xsumentry_t  *sum;            /*    Sum array to fill in (optional)    */
Xpartentry_t *part;           /*    Previously read participation data */
Xshort        idx;            /*    Index of conference to process     */
Xshort        i;
X{
X   char path[MAX_LINE_LENGTH];
X   struct stat st;
X
X   if (sum[i].flags & IF_LINKED) { /* verify it's still linked */
X      sprintf(path,"%s/_%d",conflist[idx].location,i+1);
X      if (stat(path,&st) || st.st_nlink < 2)
X         sum[i].flags &= ~IF_LINKED;
X      if (st.st_mtime > stt->sumtime) { /* new activity */
X         item_sum(i,sum,part,idx,stt);
X      }
X   }
X}
X
X/******************************************************************************/
X/* UPDATE THE GLOBAL STATUS STRUCTURE, OPTIONALLY GET ITEM SUBJECTS           */
X/******************************************************************************/
X/* note: does load_sum and not free_sum if argument is there */
Xvoid                         /* RETURNS: (nothing) */
Xget_status(st,s,part,idx) /* ARGUMENTS:                            */
Xstatus_t *st;                /*    pointer to status structure */
Xsumentry_t  *s;              /*    Sum array to fill in (optional)    */
Xpartentry_t *part;           /*    Previously read participation data */
Xshort        idx;            /*    Index of conference to process     */
X{
X   sumentry_t  s1[MAX_ITEMS];
X   sumentry_t *sum;
X   short i;
X
X   sum  = (s)?   s : s1;
X   
X   if (st != (&st_glob))
X      st->sumtime=0; 
X   refresh_sum(0,idx,sum,part,st);
X
X   /* Are links current? */
X   for (i=0; i<MAX_ITEMS; i++)
X      refresh_link(st,sum,part,idx,i);
X
X   refresh_stats(sum,part,st);
X}
X
Xvoid
Xrefresh_list() {
X   char path[MAX_LINE_LENGTH];
X   struct stat st;
X
X   sprintf(path,"%s/%s",work,".cflist");
X   if (stat(path,&st)) return;
X   if (st_glob.listtime < st.st_mtime) {
X      xfree(cflist);
X      cflist=grab_file(work,".cflist",GF_WORD|GF_SILENT|GF_IGNCMT);
X      st_glob.listtime = st.st_mtime;
X      current = -1;
X   }
X}
X
Xvoid
Xcheck_mail(f) 
Xint f;
X{
X   static int prev=0;
X   int f2=f;
X   char mbox[MAX_LINE_LENGTH],*mail;
X   struct stat st;
X
X   /* Mail is currently only checked in conf.c, when should new mail
X    * be reported?  At Ok:? or only when join or display new? 
X    * If conf.c is the only place, perhaps it should be moved there.
X    * Note: the above was fixed when seps were added
X    */
X   mail = expand("mailbox",DM_VAR);
X   if (!mail) mail = getenv("MAIL");
X   if (!mail) {
X      sprintf(mbox,"%s/%s",MAILDIR,login);
X      mail = mbox;
X   }
X   if (!stat(mail,&st) && st.st_size>0) {
X      status |= S_MAIL;
X      if (st_glob.mailsize && st.st_size > st_glob.mailsize)
X         status |=  S_MOREMAIL;
X      st_glob.mailsize = st.st_size;
X   } else {
X      status &= ~S_MAIL;
X      st_glob.mailsize = 0;
X   }
X
X   if (status & S_MAIL) {
X      if (!prev) f2=1;
X      if (status & S_MOREMAIL) { sepinit(IS_START|IS_ITEM); f2=1; }
X      if (f2)
X         confsep("mailmsg",confidx,&st_glob,part,0);
X      status &= ~S_MOREMAIL;
X   }
X   prev = (status & S_MAIL);
X}
END_OF_FILE
if test 20727 -ne `wc -c <'sum.c'`; then
    echo shar: \"'sum.c'\" unpacked with wrong size!
fi
# end of 'sum.c'
fi
echo shar: End of archive 3 \(of 5\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
