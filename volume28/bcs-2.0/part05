Newsgroups: comp.sources.unix
From: ejb@ERA.COM (Jay Berkenbilt)
Subject: v28i006: bcs-2.0 - A Baseline Configuration System, Part05/25
References: <1.764985670.1461@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: ejb@ERA.COM (Jay Berkenbilt)
Posting-Number: Volume 28, Issue 6
Archive-Name: bcs-2.0/part05

#!/bin/sh
# this is bcs.05 (part 5 of bcs-2.0)
# do not concatenate these parts, unpack them in order with /bin/sh
# file bcs-2.0/lib/util.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 5; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping bcs-2.0/lib/util.c'
else
echo 'x - continuing file bcs-2.0/lib/util.c'
sed 's/^X//' << 'SHAR_EOF' >> 'bcs-2.0/lib/util.c' &&
X		    }
X		}
X		if (close(out) == -1)
X		{
X		    bcs_message(bcs_obj, stderr, "can't close %s: %s",
X				to, error_string(errno));
X		    status = BCS_ERR_SYSTEM;
X		}
X	    }
X	    else
X	    {
X		bcs_message(bcs_obj, stderr, "can't open %s to write: %s",
X			    to, error_string(errno));
X		status = BCS_ERR_SYSTEM;
X	    }
X	    /* No need to check return status of close for read only files. */
X	    (void) close(in);
X	}
X	else
X	{
X	    bcs_message(bcs_obj, stderr, "can't open %s read only: %s",
X			from, error_string(errno));
X	    status = BCS_ERR_SYSTEM;
X	}
X    }
X
X    return status;
}
SHAR_EOF
echo 'File bcs-2.0/lib/util.c is complete' &&
chmod 0444 bcs-2.0/lib/util.c ||
echo 'restore of bcs-2.0/lib/util.c failed'
Wc_c="`wc -c < 'bcs-2.0/lib/util.c'`"
test 13691 -eq "$Wc_c" ||
	echo 'bcs-2.0/lib/util.c: original size 13691, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/make/config.mk.in ==============
if test ! -d 'bcs-2.0/make'; then
    echo 'x - creating directory bcs-2.0/make'
    mkdir 'bcs-2.0/make'
fi
if test -f 'bcs-2.0/make/config.mk.in' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/make/config.mk.in (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/make/config.mk.in (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/make/config.mk.in' &&
#
# Note: the following RCS strings refer to config.mk.in, not config.mk
#
# $Id: config.mk.in,v 1.6 1994/03/19 14:08:32 qjb Exp $
# $Source: /local/tmp/bcs-2.0/make/RCS/config.mk.in,v $
# $Author: qjb $
#
LN_S=@LN_S@
CC=@CC@
INSTALL=@INSTALL@
RANLIB=@RANLIB@
XXCFLAGS=@XCFLAGS@
srcdir=@srcdir@
prefix=@prefix@
exec_prefix=@exec_prefix@
bindir=$(exec_prefix)/bin
manext=1
mandir=$(prefix)/man/man$(manext)
infodir=$(prefix)/info
SHAR_EOF
chmod 0444 bcs-2.0/make/config.mk.in ||
echo 'restore of bcs-2.0/make/config.mk.in failed'
Wc_c="`wc -c < 'bcs-2.0/make/config.mk.in'`"
test 428 -eq "$Wc_c" ||
	echo 'bcs-2.0/make/config.mk.in: original size 428, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/make/params.mk ==============
if test -f 'bcs-2.0/make/params.mk' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/make/params.mk (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/make/params.mk (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/make/params.mk' &&
#
# $Id: params.mk,v 1.8 1994/03/19 14:53:37 qjb Exp $
# $Source: /local/tmp/bcs-2.0/make/RCS/params.mk,v $
# $Author: qjb $
#
XXCPPFLAGS =
DFLAGS = -g -DDEBUG
# DFLAGS = -O
XXLDFLAGS =
RM = rm -f
CP = cp
TEXI2DVI = texi2dvi
MAKEINFO = makeinfo
DVIPS = dvips
FIG2DEV = fig2dev
X
AR = ar
AR_ARGS = rv
SHAR_EOF
chmod 0444 bcs-2.0/make/params.mk ||
echo 'restore of bcs-2.0/make/params.mk failed'
Wc_c="`wc -c < 'bcs-2.0/make/params.mk'`"
test 297 -eq "$Wc_c" ||
	echo 'bcs-2.0/make/params.mk: original size 297, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/make/rules.mk ==============
if test -f 'bcs-2.0/make/rules.mk' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/make/rules.mk (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/make/rules.mk (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/make/rules.mk' &&
#
# $Id: rules.mk,v 1.11 1994/02/12 00:40:19 qjb Exp $
# $Source: /local/tmp/bcs-2.0/make/RCS/rules.mk,v $
# $Author: qjb $
#
include ../make/config.mk
include ../make/params.mk
X
ALL_CFLAGS = $(DFLAGS) $(XCFLAGS) $(CFLAGS)
CPPFLAGS = $(INCPATH) $(DEFS) $(XCPPFLAGS)
INCPATH = -I../include
X
COMMON_HDRS = \
X	../include/bcs.h \
X	../include/common.h \
X	../include/config.h \
X	../include/flexlist.h \
X	../include/cm.h
X
.c.o:
X	$(RM) $@
X	$(CC) -c $(CPPFLAGS) $(ALL_CFLAGS) $<
X
.PHONY: all clean depend install
X
clean::
X	$(RM) *~ *% core a.out *.o
X
depend:
SHAR_EOF
chmod 0444 bcs-2.0/make/rules.mk ||
echo 'restore of bcs-2.0/make/rules.mk failed'
Wc_c="`wc -c < 'bcs-2.0/make/rules.mk'`"
test 550 -eq "$Wc_c" ||
	echo 'bcs-2.0/make/rules.mk: original size 550, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/man/Makefile ==============
if test ! -d 'bcs-2.0/man'; then
    echo 'x - creating directory bcs-2.0/man'
    mkdir 'bcs-2.0/man'
fi
if test -f 'bcs-2.0/man/Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/man/Makefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/man/Makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/man/Makefile' &&
#
# $Id: Makefile,v 1.2 1994/01/11 16:57:47 ejb Exp $
# $Source: /local/tmp/bcs-2.0/man/RCS/Makefile,v $
# $Author: ejb $
#
X
include ../make/config.mk
X
SHELL = /bin/sh
X
MANPAGE = bcs
INCMANPAGES = \
X	classify_files \
X	in_baseline \
X	register_file \
X	stage \
X	sync_staging \
X	update_baseline \
X	unstage \
X	bcs_info \
X	in_staging_area \
X	id_important \
X	id_unimportant \
X	id_staged
X
MANPAGES = $(MANPAGE) $(INCMANPAGES)
MANPAGESRCS = $(MANPAGES:%=%.man)
MANPAGEDESTS = $(MANPAGES:%=%.$(manext))
X
all: $(MANPAGESRCS)
X
install: all
X	../mkinstalldirs $(DESTDIR)$(mandir)
X	for i in $(MANPAGES); do \
X		$(RM) $(DESTDIR)$(mandir)/$$i.$(manext); \
X		echo "Installing $$i.$(manext) in $(DESTDIR)$(mandir)"; \
X		$(INSTALL) $$i.man $(DESTDIR)$(mandir)/$$i.$(manext); \
X		chmod 644 $(DESTDIR)$(mandir)/$$i.$(manext); \
X	done
X
uninstall:
X	for i in $(MANPAGES); do \
X		echo "Removing $$i.$(manext) from $(DESTDIR)$(mandir)"; \
X		$(RM) $(DESTDIR)$(mandir)/$$i.$(manext); \
X	done
X
$(MANPAGESRCS):
X	echo ".so man$(manext)/bcs.$(manext)" > $@
X
clean:
X	$(RM) *~ *% $(INCMANPAGES:%=%.man)
SHAR_EOF
chmod 0444 bcs-2.0/man/Makefile ||
echo 'restore of bcs-2.0/man/Makefile failed'
Wc_c="`wc -c < 'bcs-2.0/man/Makefile'`"
test 1068 -eq "$Wc_c" ||
	echo 'bcs-2.0/man/Makefile: original size 1068, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/man/bcs.man ==============
if test -f 'bcs-2.0/man/bcs.man' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/man/bcs.man (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/man/bcs.man (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/man/bcs.man' &&
.\"
.\" $Id: bcs.man,v 1.3 1994/03/19 15:06:36 qjb Exp $
.\" $Source: /local/tmp/bcs-2.0/man/RCS/bcs.man,v $
.\" $Author: qjb $
.\"
.TH BCS 1 "January 1994" 
.SH NAME
in_baseline, in_staging_area, classify_files, id_important,
id_unimportant, id_staged, bcs_info, sync_staging, stage,
unstage, bcs, update_baseline, register_file \- Baseline
Configuration System (BCS)
X
.SH SYNOPSIS
.B in_baseline 
[
.I file
][
.I standard_options
]
.LP
.B in_staging_area 
[
.I file 
][
.I standard_options 
]
.LP
.B classify_files 
[
.B -dirs 
|
.B -nodirs 
][
.B -descend 
|
.B -nodescend 
] 
.I file 
|
.I dir
[
.I file ...
|
.I dir ...
][
.I standard_options
]
.LP
.B id_important 
[
.B -dirs 
| 
.B -nodirs 
] [
.B -descend 
| 
.B -nodescend 
] 
.B file 
|
.I dir
[
.I file ...
|
.I dir ...
][
.I standard_options
]
.LP
.B id_unimportant 
[
.B -dirs 
|
.B -nodirs 
][
.B -descend 
|
.B -nodescend 
]
.I file
|
.I dir
[
.I file ...
|
.I dir ...
][
.I standard_options
]
.LP
.B id_staged 
[
.B -dirs 
| 
.B -nodirs
] [
.B -descend 
| 
.B -nodescend
] 
.I file 
| 
.I dir 
[
.I file ...
|
.I dir ...
][
.I standard_options
]
.LP
.B bcs_info 
[
.B -dirs 
|
.B -nodirs
][
.B -descend 
|
.B -nodescend
] 
.I file 
|
.I dir 
[
.I file ...
|
.I dir ...
][
.I standard_options
]
.LP
.B sync_staging 
.I dir 
[
.I dir ...
][
.B standard_options 
]
.LP
.B stage 
.I path 
[
.I path ...
][
.B standard_options 
]
.LP
.B unstage 
.I path 
[
.I path ...
][
.B --force 
| 
.B -f 
| 
.B --interactive 
| 
.B -i 
] [
.I stanadard_options
]
.LP
.B bcs
.I cmd 
.I args 
[
.I standard_options 
]
.LP
.B update_baseline 
.I file
[
.I file ...
][
.I standard_options 
]
.LP
.LP
.B register_file
.I file
[
.I file ...
][
.I standard_options 
]
X
.SH DESCRIPTION
.I BCS
is a set of programs to manage configuration of a stable
baseline and multiple work areas called
.I staging 
.IR areas .
Each of the above commands accepts the following standard
options: 
X
.TP
.BR \--help ,\ \fB-h\fR
If this flag is specified, the usage message is printed and
the command exits.  No additional checks are performed.
.TP
.B \--version
If this flag is specified, the current version of the
software and the list of supported configuration management
packages are printed and the program exits.  No additional
checks are performed. 
.TP
.B \--baseline
This option is followed by a single directory name or a
colon-separated list of directory names.  It is used to
override the setting of the 
.B BASELINE
environment
variable which does not have to be set if this flag is
provided. 
.TP
.B \--staging
This option is followed by a single directory name or a
colon-separated list of directory names.  It is used to
override the setting of the 
.B STAGING
environment
variable which does not have to be set if this flag is
provided. 
.TP
.B \--debug
This flag is only available when BCS has been compiled with
debugging enabled.
This option is followed by a colon-separated list of debug
flags.  This command is intended for use only in debugging
BCS and is not recommended for use by end-users.  
.TP
.B \--silent
The presence of this option causes the suppression of some
diagnostic messages but not the suppression of error messages.
.TP
.BR \--recursive ,\ \fB-r\fR
For applicable commands, this flag indicates that the
operation should be performed recursively.  This flag is used
only for the commands
.BR classify_files ,
.BR id_important , 
.BR id_unimportant ,
.BR id_staged , 
and
.BR sync_staging . 
.TP
.BR \--no-action ,\ \fB-n\fR
This flag specifies that the baseline and staging areas
should not be modified but that the commands should print
what they would do.  The output of a command with the
.B \--no-action
flag may differ from the
command's output without the flag since frequently one
operation by a command is dependent upon the outcome of
previous actions.  This option is not meaningful for all
commands. 
X
More information about all of these commands and about BCS in
general can be found in the BCS users manual through info.
SHAR_EOF
chmod 0444 bcs-2.0/man/bcs.man ||
echo 'restore of bcs-2.0/man/bcs.man failed'
Wc_c="`wc -c < 'bcs-2.0/man/bcs.man'`"
test 4001 -eq "$Wc_c" ||
	echo 'bcs-2.0/man/bcs.man: original size 4001, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/progs/Makefile ==============
if test ! -d 'bcs-2.0/progs'; then
    echo 'x - creating directory bcs-2.0/progs'
    mkdir 'bcs-2.0/progs'
fi
if test -f 'bcs-2.0/progs/Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/progs/Makefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/progs/Makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/progs/Makefile' &&
#
# $Id: Makefile,v 1.21 1994/02/12 00:40:19 qjb Exp $
# $Source: /local/tmp/bcs-2.0/progs/RCS/Makefile,v $
# $Author: qjb $
#
X
SHELL = /bin/sh
X
PROGS = \
X	bcs \
X	classify_files \
X	in_baseline \
X	register_file \
X	stage \
X	sync_staging \
X	update_baseline \
X	unstage
X
EXTRAPROGS = \
X	bcs_info \
X	in_staging_area \
X	id_important \
X	id_unimportant \
X	id_staged
X
BCS_LIBS = -lbcs
ALL_LDFLAGS = $(DFLAGS) $(XLDFLAGS) $(CFLAGS) $(LDFLAGS)
LDPATH = -L../lib
LDLIBS = $(LDPATH) $(BCS_LIBS) $(LIBS)
X
# Override this to install binaries below a certain directory
# DESTDIR's value should not end with a slash (/).
DESTDIR=
X
# For some people, this pattern matching line is the only thing that
# prevents the native make from working.  Instead, repeat the list of
# sources.
# SRCS = $(PROGS:%=%.c)
SRCS = 	bcs.c \
X	classify_files.c \
X	in_baseline.c \
X	register_file.c \
X	stage.c \
X	sync_staging.c \
X	update_baseline.c \
X	unstage.c
X
all: $(PROGS) $(EXTRAPROGS)
X
install: all
X	../mkinstalldirs $(DESTDIR)$(bindir)
X	for i in $(PROGS); do \
X		$(RM) $(DESTDIR)$(bindir)/$$i; \
X		echo "Installing $$i in $(DESTDIR)$(bindir)"; \
X		$(INSTALL) $$i $(DESTDIR)$(bindir); \
X		if strip $(DESTDIR)$(bindir)/$$i; then true; fi; \
X		chmod 755 $(DESTDIR)$(bindir)/$$i; \
X	done
X	for i in $(EXTRAPROGS); do \
X		$(RM) $(DESTDIR)$(bindir)/$$i; \
X	done
X	$(LN_S) in_baseline $(DESTDIR)$(bindir)/in_staging_area
X	$(LN_S) classify_files $(DESTDIR)$(bindir)/bcs_info
X	$(LN_S) classify_files $(DESTDIR)$(bindir)/id_important
X	$(LN_S) classify_files $(DESTDIR)$(bindir)/id_unimportant
X	$(LN_S) classify_files $(DESTDIR)$(bindir)/id_staged
X
uninstall:
X	for i in $(PROGS); do \
X		echo "Removing $$i from $(DESTDIR)$(bindir)"; \
X		$(RM) $(DESTDIR)$(bindir)/$$i; \
X	done
X	for i in $(EXTRAPROGS); do \
X		echo "Removing $$i from $(DESTDIR)$(bindir)"; \
X		$(RM) $(DESTDIR)$(bindir)/$$i; \
X	done
X
X
$(PROGS): ../lib/libbcs.a
X
% : %.o
X	$(PURIFY) $(CC) -o $@ $< $(ALL_LDFLAGS) $(LDLIBS)
X
# Note: some makes don't seem to like $< and $@ in the following rules.
X
in_staging_area: in_baseline
X	$(RM) in_staging_area
X	$(LN_S) in_baseline in_staging_area
X
bcs_info: classify_files
X	$(RM) bcs_info
X	$(LN_S) classify_files bcs_info
X
id_important: classify_files
X	$(RM) id_important
X	$(LN_S) classify_files id_important
X
id_unimportant: classify_files
X	$(RM) id_unimportant
X	$(LN_S) classify_files id_unimportant
X
id_staged: classify_files
X	$(RM) id_staged
X	$(LN_S) classify_files id_staged
X
clean::
X	$(RM) $(PROGS) $(EXTRAPROGS)
X
include ../make/rules.mk
X
bcs.o: bcs.c $(COMMON_HDRS)
bcs_info.o: bcs_info.c $(COMMON_HDRS)
classify_files.o: classify_files.c $(COMMON_HDRS)
in_baseline.o: in_baseline.c $(COMMON_HDRS)
register_file.o: register_file.c $(COMMON_HDRS)
stage.o: stage.c $(COMMON_HDRS)
sync_staging.o: sync_staging.c $(COMMON_HDRS)
unstage.o: unstage.c $(COMMON_HDRS)
update_baseline.o: update_baseline.c $(COMMON_HDRS)
SHAR_EOF
chmod 0444 bcs-2.0/progs/Makefile ||
echo 'restore of bcs-2.0/progs/Makefile failed'
Wc_c="`wc -c < 'bcs-2.0/progs/Makefile'`"
test 2873 -eq "$Wc_c" ||
	echo 'bcs-2.0/progs/Makefile: original size 2873, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/progs/bcs.c ==============
if test -f 'bcs-2.0/progs/bcs.c' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/progs/bcs.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/progs/bcs.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/progs/bcs.c' &&
/* 
X * $Id: bcs.c,v 1.7 1994/03/07 21:47:41 qjb Exp $
X * $Source: /local/tmp/bcs-2.0/progs/RCS/bcs.c,v $
X * $Author: qjb $
X *
X * Copyright (C) 1994  E. Jay Berkenbilt
X * 
X * This file is part of BCS.  BCS may be distributed according to the terms
X * of the General Public License and/or the Artistic License.  See the
X * `COPYING' and `Artistic' files with the source distribution for details.
X * This notice must be kept intact when this file is distributed.
X *
X * bcs command.  This is the front end to the underlying CM package
X * for checkin and checkout.
X */
X
#if !defined(lint) && !defined(CODECENTER) || defined(RCS_HDRS)
/* Define a static function and call it.  No warnings this way. */
static void rcsid(char *s)
{rcsid("@(#)$Id: bcs.c,v 1.7 1994/03/07 21:47:41 qjb Exp $");}
#endif /* !lint && !CODECENTER || RCS_HDRS */
X
#include "bcs.h"
X
void usage(char *whoami)
{
X    fprintf(stderr, "Usage: %s cmd args [standard_opts]\n", whoami);
X    fprintf(stderr, "  Check files in or out in the staging area.  "
X	    "The --recursive flag ");
X    fprintf(stderr, "is ignored\n    for this command.\n");
X    fprintf(stderr, "  For this command, cmd is a command in the CM system and "
X	    "args are\n    arguments to cmd.\n");
X    bcs_print_standard_opts();
}
X
int main(int argc, char *argv[])
{
X    bcs_obj_type bcs_obj;
X    int status;
X    char *cmd_str;
X    cm_command *cmd;
X    bcs_stringlist files;
X
X    bcs_start(&bcs_obj, &argc, argv, usage);
X
X    if (argc < 2)
X    {
X	usage(bcs_obj->whoami);
X	exit(BCS_ERR_USAGE);
X    }
X
X    cmd_str = argv[1];
X
X    if ((cmd = cm_lookup_command(bcs_obj, cmd_str)) == NULL)
X    {
X	bcs_message(bcs_obj, stderr, "unknown %s command %s",
X		    bcs_obj->baseline->data[0]->cm_name,
X		    cmd_str);
X	bcs_message(bcs_obj, stderr,
X		    "Please type %s --help for a detailed help message.",
X		    bcs_obj->whoami);
X	return BCS_ERR_USAGE;
X    }
X    
X    files = cmd->get_file_args(bcs_obj, &argv[2]);
X    if (files->n == 0)
X    {
X	bcs_message(bcs_obj, stderr, "no files were specified.");
X	bcs_message(bcs_obj, stderr,
X		    "Please type %s --help for a detailed help message.",
X		    bcs_obj->whoami);
X	return BCS_ERR_USAGE;
X    }
X
X    if (cm_eligible(bcs_obj, cmd->cmd_type, files))
X    {
X	status = cm_run_command(bcs_obj, cmd, &argv[1]);
X    }
X    else
X    {
X	bcs_message(bcs_obj, stderr, "no operations were performed");
X	status = BCS_ERR_USER;
X    }
X
X    return status;
}
SHAR_EOF
chmod 0444 bcs-2.0/progs/bcs.c ||
echo 'restore of bcs-2.0/progs/bcs.c failed'
Wc_c="`wc -c < 'bcs-2.0/progs/bcs.c'`"
test 2413 -eq "$Wc_c" ||
	echo 'bcs-2.0/progs/bcs.c: original size 2413, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/progs/classify_files.c ==============
if test -f 'bcs-2.0/progs/classify_files.c' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/progs/classify_files.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/progs/classify_files.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/progs/classify_files.c' &&
/* 
X * $Id: classify_files.c,v 1.20 1994/03/07 21:47:41 qjb Exp $
X * $Source: /local/tmp/bcs-2.0/progs/RCS/classify_files.c,v $
X * $Author: qjb $
X *
X * Copyright (C) 1994  E. Jay Berkenbilt
X * 
X * This file is part of BCS.  BCS may be distributed according to the terms
X * of the General Public License and/or the Artistic License.  See the
X * `COPYING' and `Artistic' files with the source distribution for details.
X * This notice must be kept intact when this file is distributed.
X *
X * classify_files, id_important, id_unimportant, id_staged, and
X * bcs_info commands.  Given standard bcs arguments with additional
X * arguments being file names, classify named files as important or
X * unimportant, or given other information about the files.
X */
X
#if !defined(lint) && !defined(CODECENTER) || defined(RCS_HDRS)
/* Define a static function and call it.  No warnings this way. */
static void rcsid(char *s)
{rcsid("@(#)$Id: classify_files.c,v 1.20 1994/03/07 21:47:41 qjb Exp $");}
#endif /* !lint && !CODECENTER || RCS_HDRS */
X
#include "bcs.h"
X
typedef enum { bad_entry, classify, id_imp,
X		   id_unimp, id_staged, bcs_info } entry_type;
X
typedef struct {
X    char *name;
X    entry_type which_entry;
} valid_entry;
X
valid_entry valid_entries[] = {
{ "classify_files", classify },
{ "id_important", id_imp },
{ "id_unimportant", id_unimp },
{ "id_staged", id_staged },
{ "bcs_info", bcs_info },
{ NULL, bad_entry },
};
X
static entry_type cur_entry;
X
typedef struct {
X    int printdirs;
} classify_args;
X
void usage(char *whoami)
{
X    fprintf(stderr,
X	    "Usage: %s { file | dir }  [ { file | dir } ...] "
X	    "[standard_opts]\n", whoami);
X
X    switch (cur_entry)
X    {
X      case bcs_info:
X	fprintf(stderr,
X		"  Print general bcs information about the given files.\n"
X		"  This command is intended primarily for debugging "
X		"baseline configurations.\n");
X	break;
X
X      case classify:
X	fprintf(stderr, "  Print the names of the given files or directories "
X		"and whether they are\n");
X	fprintf(stderr, "  important or unimportant.\n");
X	break;
X
X      case id_imp:
X	fprintf(stderr, "  Print the names of the given files that are "
X		"important.\n");
X	break;
X
X      case id_unimp:
X	fprintf(stderr, "  Print the names of the given files that are "
X		"not important.\n");
X	break;
X
X      case id_staged:
X	fprintf(stderr, "  Print the names of the given files that are "
X		"staged.\n");
X	break;
X
X      default:
X	fprintf(stderr, "  PROGRAMMER ERROR in usage(): default reached\n");
X	break;
X	
X    }
X
X    fprintf(stderr, "\n");
X    fprintf(stderr, "  The -dirs and -nodirs flags are used to determine ");
X    fprintf(stderr, "whether directory names\n  are printed as well as ");
X    fprintf(stderr, "file names.  If the recursive option is given, the\n  ");
X    fprintf(stderr, "default is -nodirs.  If not, the default is -dirs.  ");
X    fprintf(stderr, "Directory names are\n  printed with trailing slashes ");
X    fprintf(stderr, "for clarity.\n");
X    fprintf(stderr, "\n");
X    fprintf(stderr, "  The -descend flag means that when directories are ");
X    fprintf(stderr, "specified on the command\n  line, information is ");
X    fprintf(stderr, "printed about the files in the directories instead ");
X    fprintf(stderr, "of\n  the directories themselves.  If -nodescend is ");
X    fprintf(stderr, "specified, the command will\n  operate on the ");
X    fprintf(stderr, "directories rather than their contents.  The ");
X    fprintf(stderr, "default is\n  -descend.  If --recursive is ");
X    fprintf(stderr, "specified, then these flags are ignored, and\n  ");
X    fprintf(stderr, "-descend is always assumed.\n");
X    fprintf(stderr, "\n");
X
X    bcs_print_standard_opts();
}
X
X
/* Callback for examine_dir */
void print_classification(bcs_obj_type bcs_obj, bcs_file_info file_info,
X			  void *cbdata)
{
X    classify_args *cargs = (classify_args *)cbdata;
X    char *dirstr;
X
X    if ((! cargs->printdirs) && (fi_isdir(bcs_obj, file_info)))
X	return;
X    
X    dirstr = (fi_isdir(bcs_obj, file_info)) ? PATH_SEP_STR : "";
X    
X    switch (cur_entry)
X    {
X      case classify:
X	printf("%s%s: %s\n", fi_user_path(bcs_obj, file_info), dirstr,
X	       fi_important(bcs_obj, file_info) ?
X	       "important" : "unimportant");
X	break;
X	
X      case id_imp:
X	if (fi_important(bcs_obj, file_info))
X	    printf("%s%s\n", fi_user_path(bcs_obj, file_info), dirstr);
X	break;
X	
X      case id_unimp:
X	if (! fi_important(bcs_obj, file_info))
X	    printf("%s%s\n", fi_user_path(bcs_obj, file_info), dirstr);
X	break;
X	
X      case id_staged:
X	if (fi_is_staged(bcs_obj, file_info))
X	    printf("%s%s\n", fi_user_path(bcs_obj, file_info), dirstr);
X	break;
X	
X      case bcs_info:
X	bcs_print_file_info(bcs_obj, file_info);
X	break;
X
X      default:
X	bcs_message(bcs_obj, stderr,
X		    "INTERNAL ERROR in main: default reached");
X	break;
X    }
}
X
X
int main(int argc, char *argv[])
{
X    bcs_obj_type bcs_obj;
X    int i;
X    int status;
X    char *whoami;
X    valid_entry *entry;
X    int printdirs = FALSE;
X    int descend = TRUE;
X    int count;
X    int return_status = BCS_SUCCESS;
X    bcs_file_info file_info = NULL;
X    classify_args cargs;
X
X    if ((whoami = strrchr(argv[0], '/')) == NULL)
X	whoami = argv[0];
X    else
X	whoami++;
X
X    cur_entry = bad_entry;
X    for (entry = valid_entries; entry->name; entry++)
X    {
X	if (strcmp(entry->name, whoami) == 0)
X	    cur_entry = entry->which_entry;
X    }
X
X    if (cur_entry == bad_entry)
X    {
X	fprintf(stderr, "%s: Must be invoked as one of the following:\n",
X		whoami);
X	for (entry = valid_entries; entry->name; entry++)
X	    fprintf(stderr, "   %s\n", entry->name);
X	exit(BCS_ERR_USAGE);
X    }
X
X    bcs_start(&bcs_obj, &argc, argv, usage);
X
X    count = argc;
X    printdirs = (! bcs_obj->recursive);
X    for (i = 1; i < argc; i++)
X    {
X	if (strcmp(argv[i], "-dirs") == 0)
X	{
X	    printdirs = TRUE;
X	    argv[i] = NULL;
X	    count--;
X	}
X	else if (strcmp(argv[i], "-nodirs") == 0)
X	{
X	    printdirs = FALSE;
X	    argv[i] = NULL;
X	    count--;
X	}
X	else if (strcmp(argv[i], "-descend") == 0)
X	{
X	    descend = TRUE;
X	    argv[i] = NULL;
X	    count--;
X	}
X	else if (strcmp(argv[i], "-nodescend") == 0)
X	{
X	    descend = FALSE;
X	    argv[i] = NULL;
X	    count--;
X	}
X    }
X
X    cargs.printdirs = printdirs;
X    if (bcs_obj->recursive)
X	descend = TRUE;
X
X    if (count < 2)
X    {
X	usage(bcs_obj->whoami);
X	exit(BCS_ERR_USAGE);
X    }
X
X    for (i = 1; i < argc; i++)
X    {
X	if (argv[i])
X	{
X	    bcs_strip_dir_path(argv[i]);
X	    if (descend &&
X		(bcs_isdir(bcs_obj, argv[i]) ||
X		 bcs_isbldir(bcs_obj, argv[i], NULL, NULL, NULL)))
X	    {
X		/* This argument is a directory */
X		if ((status = bcs_examine_dir(bcs_obj, argv[i],
X					      bcs_obj->recursive,
X					      print_classification,
X					      &cargs)) != BCS_SUCCESS)
X		    return_status = BCS_ERR_PARTIAL;
X	    }
X	    else
X	    {
X		if ((file_info = bcs_get_file_info(bcs_obj, argv[i])) == NULL)
X		{
X		    bcs_message(bcs_obj, stderr, "%s does not exist.",
X				argv[i]);
X		    return_status = BCS_ERR_PARTIAL;
X		}
X		else
X		    print_classification(bcs_obj, file_info, &cargs);
X	    }
X	}
X    }
X
X    return return_status;
}
X
SHAR_EOF
chmod 0444 bcs-2.0/progs/classify_files.c ||
echo 'restore of bcs-2.0/progs/classify_files.c failed'
Wc_c="`wc -c < 'bcs-2.0/progs/classify_files.c'`"
test 7093 -eq "$Wc_c" ||
	echo 'bcs-2.0/progs/classify_files.c: original size 7093, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/progs/in_baseline.c ==============
if test -f 'bcs-2.0/progs/in_baseline.c' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/progs/in_baseline.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/progs/in_baseline.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/progs/in_baseline.c' &&
/* 
X * $Id: in_baseline.c,v 1.11 1994/03/07 21:47:41 qjb Exp $
X * $Source: /local/tmp/bcs-2.0/progs/RCS/in_baseline.c,v $
X * $Author: qjb $
X *
X * Copyright (C) 1994  E. Jay Berkenbilt
X * 
X * This file is part of BCS.  BCS may be distributed according to the terms
X * of the General Public License and/or the Artistic License.  See the
X * `COPYING' and `Artistic' files with the source distribution for details.
X * This notice must be kept intact when this file is distributed.
X *
X * in_baseline and in_staging_area commands.  Determine whether the
X * directory or file named is in a baseline or staging area depending
X * on invocation.  Print either "1" or "0" to stdout.  This program is
X * intended primarily for use in scripts.
X */
X
#if !defined(lint) && !defined(CODECENTER) || defined(RCS_HDRS)
/* Define a static function and call it.  No warnings this way. */
static void rcsid(char *s)
{rcsid("@(#)$Id: in_baseline.c,v 1.11 1994/03/07 21:47:41 qjb Exp $");}
#endif /* !lint && !CODECENTER || RCS_HDRS */
X
#include "bcs.h"
X
static bcs_which which;
X
#define BASELINE "in_baseline"
#define STAGING "in_staging_area"
X
void usage(char *whoami)
{
X    fprintf(stderr, "Usage: %s [file] [standard_opts]\n", whoami);
X    fprintf(stderr, "  Tells whether file is in %s.\n",
X	    (which == in_baseline) ? "the baseline" : "a staging area");
X    fprintf(stderr, "  If file is omitted, the current directory is used.\n");
X    fprintf(stderr, "  The recursive option is ignored for this command.\n");
X    bcs_print_standard_opts();
}
X
int main(int argc, char *argv[])
{
X    bcs_obj_type bcs_obj;
X    char *file;
X    char *whoami;
X    int indx;
X    bcs_which file_which;
X
X    if ((whoami = strrchr(argv[0], '/')) == NULL)
X	whoami = argv[0];
X    else
X	whoami++;
X
X    if (strcmp(whoami, BASELINE) == 0)
X	which = in_baseline;
X    else if (strcmp(whoami, STAGING) == 0)
X	which = in_staging;
X    else
X    {
X	fprintf(stderr, "%s: This command must be run as `%s' or `%s'\n",
X		whoami, BASELINE, STAGING);
X	exit(BCS_ERR_USAGE);
X    }
X
X    bcs_start(&bcs_obj, &argc, argv, usage);
X
X    if (argc == 1)
X	file = ".";
X    else if (argc == 2)
X    {
X	file = argv[1];
X	bcs_strip_dir_path(file);
X    }
X    else
X    {
X	usage(bcs_obj->whoami);
X	exit(BCS_ERR_USAGE);
X    }
X
X    bcs_get_bl_index(bcs_obj, file, &indx, &file_which);
X    printf("%d\n", (which == file_which) ? 1 : 0);
X    return 0;
}
SHAR_EOF
chmod 0444 bcs-2.0/progs/in_baseline.c ||
echo 'restore of bcs-2.0/progs/in_baseline.c failed'
Wc_c="`wc -c < 'bcs-2.0/progs/in_baseline.c'`"
test 2372 -eq "$Wc_c" ||
	echo 'bcs-2.0/progs/in_baseline.c: original size 2372, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/progs/register_file.c ==============
if test -f 'bcs-2.0/progs/register_file.c' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/progs/register_file.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/progs/register_file.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/progs/register_file.c' &&
/* 
X * $Id: register_file.c,v 1.3 1994/03/07 21:47:41 qjb Exp $
X * $Source: /local/tmp/bcs-2.0/progs/RCS/register_file.c,v $
X * $Author: qjb $
X *
X * Copyright (C) 1994  E. Jay Berkenbilt
X * 
X * This file is part of BCS.  BCS may be distributed according to the terms
X * of the General Public License and/or the Artistic License.  See the
X * `COPYING' and `Artistic' files with the source distribution for details.
X * This notice must be kept intact when this file is distributed.
X *
X * register_file command.  Create a new file in the baseline and
X * staging area.
X */
X
#if !defined(lint) && !defined(CODECENTER) || defined(RCS_HDRS)
/* Define a static function and call it.  No warnings this way. */
static void rcsid(char *s)
{rcsid("@(#)$Id: register_file.c,v 1.3 1994/03/07 21:47:41 qjb Exp $");}
#endif /* !lint && !CODECENTER || RCS_HDRS */
X
#include "bcs.h"
X
void usage(char *whoami)
{
X    fprintf(stderr, "Usage: %s file [file ...] [standard_opts]\n", whoami);
X    fprintf(stderr,
X	    "  Add new files files to the baseline and staging areas.\n");
X    bcs_print_standard_opts();
}
X
int main(int argc, char *argv[])
{
X    bcs_obj_type bcs_obj;
X    char **arg;
X    int status;
X    int return_status = BCS_SUCCESS;
X
X    bcs_start(&bcs_obj, &argc, argv, usage);
X
X    if (argc < 2)
X    {
X	usage(bcs_obj->whoami);
X	exit(BCS_ERR_USAGE);
X    }
X
X    for (arg = &argv[1]; *arg; arg++)
X    {
X	bcs_strip_dir_path(*arg);
X	status = cm_register_file(bcs_obj, *arg);
X	if (status)
X	    return_status = BCS_ERR_PARTIAL;
X    }
X
X    return return_status;
}
SHAR_EOF
chmod 0444 bcs-2.0/progs/register_file.c ||
echo 'restore of bcs-2.0/progs/register_file.c failed'
Wc_c="`wc -c < 'bcs-2.0/progs/register_file.c'`"
test 1546 -eq "$Wc_c" ||
	echo 'bcs-2.0/progs/register_file.c: original size 1546, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/progs/stage.c ==============
if test -f 'bcs-2.0/progs/stage.c' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/progs/stage.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/progs/stage.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/progs/stage.c' &&
/* 
X * $Id: stage.c,v 1.7 1994/03/07 21:47:41 qjb Exp $
X * $Source: /local/tmp/bcs-2.0/progs/RCS/stage.c,v $
X * $Author: qjb $
X *
X * Copyright (C) 1994  E. Jay Berkenbilt
X * 
X * This file is part of BCS.  BCS may be distributed according to the terms
X * of the General Public License and/or the Artistic License.  See the
X * `COPYING' and `Artistic' files with the source distribution for details.
X * This notice must be kept intact when this file is distributed.
X *
X * stage command.  Replace links from staging area to baseline with
X * actual copies.
X */
X
#if !defined(lint) && !defined(CODECENTER) || defined(RCS_HDRS)
/* Define a static function and call it.  No warnings this way. */
static void rcsid(char *s)
{rcsid("@(#)$Id: stage.c,v 1.7 1994/03/07 21:47:41 qjb Exp $");}
#endif /* !lint && !CODECENTER || RCS_HDRS */
X
#include "bcs.h"
X
void usage(char *whoami)
{
X    fprintf(stderr, "Usage: %s file [file ...] [standard_opts]\n", whoami);
X    fprintf(stderr, "  Stage files or directories.  The --recursive flag is ");
X    fprintf(stderr, "ignored for this\n  command.\n");
X    bcs_print_standard_opts();
}
X
int main(int argc, char *argv[])
{
X    bcs_obj_type bcs_obj;
X    char **arg;
X    int status;
X    int return_status = BCS_SUCCESS;
X
X    bcs_start(&bcs_obj, &argc, argv, usage);
X
X    if (argc < 2)
X    {
X	usage(bcs_obj->whoami);
X	exit(BCS_ERR_USAGE);
X    }
X
X    for (arg = &argv[1]; *arg; arg++)
X    {
X	bcs_strip_dir_path(*arg);
X	status = bcs_stage(bcs_obj, *arg, FALSE);
X	if (status)
X	    return_status = BCS_ERR_PARTIAL;
X    }
X
X    return return_status;
}
SHAR_EOF
chmod 0444 bcs-2.0/progs/stage.c ||
echo 'restore of bcs-2.0/progs/stage.c failed'
Wc_c="`wc -c < 'bcs-2.0/progs/stage.c'`"
test 1573 -eq "$Wc_c" ||
	echo 'bcs-2.0/progs/stage.c: original size 1573, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/progs/sync_staging.c ==============
if test -f 'bcs-2.0/progs/sync_staging.c' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/progs/sync_staging.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/progs/sync_staging.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/progs/sync_staging.c' &&
/* 
X * $Id: sync_staging.c,v 1.11 1994/03/07 21:47:41 qjb Exp $
X * $Source: /local/tmp/bcs-2.0/progs/RCS/sync_staging.c,v $
X * $Author: qjb $
X *
X * Copyright (C) 1994  E. Jay Berkenbilt
X * 
X * This file is part of BCS.  BCS may be distributed according to the terms
X * of the General Public License and/or the Artistic License.  See the
X * `COPYING' and `Artistic' files with the source distribution for details.
X * This notice must be kept intact when this file is distributed.
X *
X * sync_staging command.  Synchronize staging area with the baseline.
X */
X
#if !defined(lint) && !defined(CODECENTER) || defined(RCS_HDRS)
/* Define a static function and call it.  No warnings this way. */
static void rcsid(char *s)
{rcsid("@(#)$Id: sync_staging.c,v 1.11 1994/03/07 21:47:41 qjb Exp $");}
#endif /* !lint && !CODECENTER || RCS_HDRS */
X
#include "bcs.h"
X
void usage(char *whoami)
{
X    fprintf(stderr, "Usage: %s dir [dir ...] [standard_opts]\n", whoami);
X    fprintf(stderr, "  Synchronize staging area with baseline\n");
X    bcs_print_standard_opts();
}
X
int main(int argc, char *argv[])
{
X    bcs_obj_type bcs_obj;
X    int i;
X    char **dirnamep;
X    int error = FALSE;
X    int status;
X    int indx;
X    bcs_which which;
X    int return_status = BCS_SUCCESS;
X    int isdir;
X
X    bcs_start(&bcs_obj, &argc, argv, usage);
X
X    if (argc < 2)
X    {
X	usage(bcs_obj->whoami);
X	exit(BCS_ERR_USAGE);
X    }
X
X    /* Make sure all remaining arguments are directories in the staging area */
X    for (i = 1; i < argc; i++)
X    {
X	bcs_strip_dir_path(argv[i]);
X	isdir = TRUE;
X	if (! bcs_isdir(bcs_obj, argv[i]))
X	{
X	    /*
X	     * Special case: if this is a symbolic link to a top-level
X	     * staging area directory, pretend the actual directory
X	     * was specified.
X	     */
X
X	    if (! bcs_isbldir(bcs_obj, argv[i], NULL, &indx, &which))
X	    {
X		bcs_message(bcs_obj, stderr, "%s is not a directory",
X			    argv[i]);
X		error = TRUE;
X		isdir = FALSE;
X	    }
X	    else
X	    {
X		/*
X		 * Handle case of in_baseline so next part of this
X		 * program will print the proper error message...
X		 */
X		if (which == in_baseline)
X		    argv[i] = bcs_obj->baseline->data[indx]->path.can_path;
X		else if (which == in_staging)
X		    argv[i] = bcs_obj->staging->data[indx]->path.can_path;
X	    }
X	}
X
X	if (isdir)
X	{
X	    bcs_get_bl_index(bcs_obj, argv[i], &indx, &which);
X	    if (which != in_staging)
X	    {
X		bcs_message(bcs_obj, stderr, "%s is not in the staging area",
X			    argv[i]);
X		error = TRUE;
X	    }
X	}
X    }
X
X    if (error)
X    {
X	bcs_message(bcs_obj, stderr,
X		    "Please type %s --help for a detailed help message.",
X		    bcs_obj->whoami);
X	exit(BCS_ERR_USAGE);
X    }
X
X    for (dirnamep = &argv[1]; *dirnamep; dirnamep++)
X    {
X	status = bcs_sync_staging(bcs_obj, *dirnamep, bcs_obj->recursive, TRUE);
X	if (status)
X	    return_status = BCS_ERR_PARTIAL;
X    }
X
X    return return_status;
}
SHAR_EOF
chmod 0444 bcs-2.0/progs/sync_staging.c ||
echo 'restore of bcs-2.0/progs/sync_staging.c failed'
Wc_c="`wc -c < 'bcs-2.0/progs/sync_staging.c'`"
test 2881 -eq "$Wc_c" ||
	echo 'bcs-2.0/progs/sync_staging.c: original size 2881, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/progs/unstage.c ==============
if test -f 'bcs-2.0/progs/unstage.c' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/progs/unstage.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/progs/unstage.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/progs/unstage.c' &&
/* 
X * $Id: unstage.c,v 1.5 1994/03/07 21:47:41 qjb Exp $
X * $Source: /local/tmp/bcs-2.0/progs/RCS/unstage.c,v $
X * $Author: qjb $
X *
X * Copyright (C) 1994  E. Jay Berkenbilt
X * 
X * This file is part of BCS.  BCS may be distributed according to the terms
X * of the General Public License and/or the Artistic License.  See the
X * `COPYING' and `Artistic' files with the source distribution for details.
X * This notice must be kept intact when this file is distributed.
X *
X * unstage command.  Replace files in staging area with links to the
X * baseline.
X */
X
#if !defined(lint) && !defined(CODECENTER) || defined(RCS_HDRS)
/* Define a static function and call it.  No warnings this way. */
static void rcsid(char *s)
{rcsid("@(#)$Id: unstage.c,v 1.5 1994/03/07 21:47:41 qjb Exp $");}
#endif /* !lint && !CODECENTER || RCS_HDRS */
X
#include "bcs.h"
X
void usage(char *whoami)
{
X    fprintf(stderr, "Usage: %s [ --interactive | --force ] "
X	    "file [file ...] [standard_opts]\n", whoami);
X    fprintf(stderr, "  Unstage files or directories.  The --recursive flag ");
X    fprintf(stderr, "is ignored for this\n  command.\n");
X    fprintf(stderr, "  When unstage detects a file that may not be updated "
X	    "properly, it asks for\n");
X    fprintf(stderr, "  confirmation before continuing.  If the --interactive "
X	    "(or -i) option is\n");
X    fprintf(stderr, "  given, the program will always ask for confirmation ");
X    fprintf(stderr, "when uncertain.  Otherwise, it will only do so when the ");
X    fprintf(stderr, "program is run interactively.  If the --force (or -f) ");
X    fprintf(stderr, "flag is given, no questions will be asked.\n  If both ");
X    fprintf(stderr, "flags are given, whichever is specified last prevails.\n");
X    bcs_print_standard_opts();
}
X
int main(int argc, char *argv[])
{
X    bcs_obj_type bcs_obj;
X    int status;
X    int return_status = BCS_SUCCESS;
X    int i;
X    unstage_param_type unstage_params;
X
X    bcs_start(&bcs_obj, &argc, argv, usage);
X
X    if (argc < 2)
X    {
X	usage(bcs_obj->whoami);
X	exit(BCS_ERR_USAGE);
X    }
X
X    if (isatty(0))
X	unstage_params = us_ask;
X    else
X	unstage_params = us_negative;
X
X    for (i = 1; i < argc; i++)
X    {
X	if ((strcmp(argv[i], "--interactive") == 0) ||
X	    (strcmp(argv[i], "-i") == 0))
X	{
X	    argv[i] = NULL;
X	    unstage_params = us_ask;
X	}
X	else if ((strcmp(argv[i], "--force") == 0) ||
X		 (strcmp(argv[i], "-f") == 0))
X	{
X	    argv[i] = NULL;
X	    unstage_params = us_affirmative;
X	}
X    }
X
X    for (i = 1; i < argc; i++)
X    {
X	if (argv[i])
X	{
X	    bcs_strip_dir_path(argv[i]);
X	    status = bcs_unstage(bcs_obj, argv[i], unstage_params);
X	    if (status)
X		return_status = BCS_ERR_PARTIAL;
X	}
X    }
X
X    return return_status;
}
SHAR_EOF
chmod 0444 bcs-2.0/progs/unstage.c ||
echo 'restore of bcs-2.0/progs/unstage.c failed'
Wc_c="`wc -c < 'bcs-2.0/progs/unstage.c'`"
test 2718 -eq "$Wc_c" ||
	echo 'bcs-2.0/progs/unstage.c: original size 2718, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/progs/update_baseline.c ==============
if test -f 'bcs-2.0/progs/update_baseline.c' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/progs/update_baseline.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/progs/update_baseline.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/progs/update_baseline.c' &&
/* 
X * $Id: update_baseline.c,v 1.3 1994/03/07 21:47:41 qjb Exp $
X * $Source: /local/tmp/bcs-2.0/progs/RCS/update_baseline.c,v $
X * $Author: qjb $
X *
X * Copyright (C) 1994  E. Jay Berkenbilt
X * 
X * This file is part of BCS.  BCS may be distributed according to the terms
X * of the General Public License and/or the Artistic License.  See the
X * `COPYING' and `Artistic' files with the source distribution for details.
X * This notice must be kept intact when this file is distributed.
X *
X * update_baseline command.  Checkout default version of file in
X * baseline and unstage the file if necessary.
X */
X
#if !defined(lint) && !defined(CODECENTER) || defined(RCS_HDRS)
/* Define a static function and call it.  No warnings this way. */
static void rcsid(char *s)
{rcsid("@(#)$Id: update_baseline.c,v 1.3 1994/03/07 21:47:41 qjb Exp $");}
#endif /* !lint && !CODECENTER || RCS_HDRS */
X
#include "bcs.h"
X
void usage(char *whoami)
{
X    fprintf(stderr, "Usage: %s file [file ...] [standard_opts]\n", whoami);
X    fprintf(stderr, "  Update files in the baseline.  The --recursive flag ");
X    fprintf(stderr, "is ignored for this\n  command.\n");
X    bcs_print_standard_opts();
}
X
int main(int argc, char *argv[])
{
X    bcs_obj_type bcs_obj;
X    int status;
X    int return_status = BCS_SUCCESS;
X    int i;
X
X    bcs_start(&bcs_obj, &argc, argv, usage);
X
X    if (argc < 2)
X    {
X	usage(bcs_obj->whoami);
X	exit(BCS_ERR_USAGE);
X    }
X
X    for (i = 1; i < argc; i++)
X    {
X	if (argv[i])
X	{
X	    bcs_strip_dir_path(argv[i]);
X	    status = bcs_update_bl(bcs_obj, argv[i]);
X	    if (status)
X		return_status = BCS_ERR_PARTIAL;
X	}
X    }
X
X    return return_status;
}
SHAR_EOF
chmod 0444 bcs-2.0/progs/update_baseline.c ||
echo 'restore of bcs-2.0/progs/update_baseline.c failed'
Wc_c="`wc -c < 'bcs-2.0/progs/update_baseline.c'`"
test 1651 -eq "$Wc_c" ||
	echo 'bcs-2.0/progs/update_baseline.c: original size 1651, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/tests/in_baseline.test ==============
if test ! -d 'bcs-2.0/tests'; then
    echo 'x - creating directory bcs-2.0/tests'
    mkdir 'bcs-2.0/tests'
fi
if test -f 'bcs-2.0/tests/in_baseline.test' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/tests/in_baseline.test (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/tests/in_baseline.test (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/tests/in_baseline.test' &&
# -*- perl -*-
#
# $Id: in_baseline.test,v 1.3 1994/03/07 21:47:41 qjb Exp $
# $Source: /local/tmp/bcs-2.0/tests/RCS/in_baseline.test,v $
# $Author: qjb $
#
# Copyright (C) 1994  E. Jay Berkenbilt
#
(scalar(@ARGV) == 4) || die "This script should be run from bcs_test.\n";
($srcdir, $bindir, $tests, $testdir) = (@ARGV);
$category = "Baseline containment";
X
require "$tests/test_routines.pl";
X
# BASELINE CONTAINMENT TESTS
#   Perform all these tests with multiple baseline and staging
#   area directories as defined in setup.pl:
#     Top-level baseline directories
#     Top-level staging area directories
#     Files in baseline
#     Files in staging area
#     Files not in baseline or staging area
#
X
$ENV{"BASELINE"} = $xbaseline;
$ENV{"STAGING"} = $xstaging;
X
for (@xbaseline)
{
X    &runtest("baseline in baseline", "in_baseline $_", "^1", 0, $pass);
X    &runtest("baseline in staging area", "in_staging_area $_", "^0", 0, $pass);
}
X
for (@xstaging)
{
X    &runtest("staging in staging area", "in_staging_area $_", "^1", 0, $pass);
X    &runtest("staging in baseline", "in_baseline $_", "^0", 0, $pass);
}
X
# Files in neither baseline nor staging area
&runtest("external", "in_baseline /etc/passwd", "^0", 0, $pass);
&runtest("external", "in_staging_area /etc/passwd", "^0", 0, $pass);
X
# Check for a non-existent file.  
&runtest("non-existent",
X         "in_baseline /this_file_shouldnt_exist", "^0", 0, $pass);
X
&report;
SHAR_EOF
chmod 0444 bcs-2.0/tests/in_baseline.test ||
echo 'restore of bcs-2.0/tests/in_baseline.test failed'
Wc_c="`wc -c < 'bcs-2.0/tests/in_baseline.test'`"
test 1431 -eq "$Wc_c" ||
	echo 'bcs-2.0/tests/in_baseline.test: original size 1431, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/tests/init.test ==============
if test -f 'bcs-2.0/tests/init.test' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/tests/init.test (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/tests/init.test (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/tests/init.test' &&
# -*- perl -*-
#
# $Id: init.test,v 1.5 1994/03/07 21:47:41 qjb Exp $
# $Source: /local/tmp/bcs-2.0/tests/RCS/init.test,v $
# $Author: qjb $
#
# Copyright (C) 1994  E. Jay Berkenbilt
#
# This file performs tests to make sure initialization picks up
# certain problems.
#
# INIT TESTS
#   Baseline or Staging not set
#   Wrong number of staging area directories
#   Staging area doesn't point to baseline
#   Baselines not using same CM package
#   Missing .baseline_path
#   Non-existent staging directory
#   Missing .baseline_conf
#   Non-existent baseline directory
#
X
(scalar(@ARGV) == 4) || die "This script should be run from bcs_test.\n";
($srcdir, $bindir, $tests, $testdir) = (@ARGV);
$category = "BCS initialization";
X
require "$tests/test_routines.pl";
X
$testdir .= "/init";
mkdir($testdir, 0777) || die "Can't create test directory\n";
X
# Set up necessary environment, files, and directories
delete $ENV{"BASELINE"};
delete $ENV{"STAGING"};
X
mkdir("$testdir/bl1", 0755);
mkdir("$testdir/bl2", 0755);
mkdir("$testdir/st1", 0755);
mkdir("$testdir/st2", 0755);
&write_file("$testdir/bl1/.baseline_conf", "cm: RCS\n");
&write_file("$testdir/bl2/.baseline_conf", "cm: RCS\n");
&write_file("$testdir/st1/.baseline_path", "..");
&write_file("$testdir/st2/.baseline_path", "../bl2");
X
&runtest("syntax",
X	 "in_baseline", "^in_baseline: either the --baseline", 1, $pass);
X
$baseline = "$testdir/bl1:$testdir/bl2";
$staging =  "$testdir/st1";
X
&runtest("number of components", 
X	 "in_baseline --baseline $baseline --staging $staging",
X	 "in_baseline: .*same number of components", 2, $pass);
X
$baseline = "$testdir/bl1";
X
&runtest("bad staging area",
X	 "in_baseline --baseline $baseline --staging $staging",
X	 "in_baseline: .*\\.baseline_path.*st1.*errors", 2, $pass);
X
unlink("$testdir/bl1/.baseline_conf");
unlink("$testdir/st1/.baseline_path");
&write_file("$testdir/bl1/.baseline_conf", "cm: SCCS\n");
&write_file("$testdir/st1/.baseline_path", "../bl1");
X
$baseline = "$testdir/bl1:$testdir/bl2";
$staging =  "$testdir/st1:$testdir/st2";
X
&runtest("CM package inconsistency", 
X	 "in_baseline --baseline $baseline --staging $staging",
X	 "in_baseline: CM package must be the same", 2, $pass);
X
$baseline = "$testdir/bl2";
$staging =  "$testdir/st2";
X
unlink("$testdir/st2/.baseline_path");
X
&runtest("missing .baseline_path",
X	 "in_baseline --baseline $baseline --staging $staging",
X	 "in_baseline: .*st2/\\.baseline_path.*does not exist", 2, $pass);
X
$staging =  "$testdir/trash";
X
&runtest("staging area not directory",
X	 "in_baseline --baseline $baseline --staging $staging",
X	 "in_baseline: .*/trash.*is not a directory", 2, $pass);
X
unlink("$testdir/bl2/.baseline_conf");
$staging =  "$testdir/st2";
X
&runtest("missing .baseline_conf",
X	 "in_baseline --baseline $baseline --staging $staging",
X	 "in_baseline: .*bl2/\\.baseline_conf.*does not exist", 2, $pass);
X
$baseline = "$testdir/btrash";
X
&runtest("baseline not directory", 
X	 "in_baseline --baseline $baseline --staging $staging",
X	 "in_baseline: .*/btrash.*is not a directory", 2, $pass);
X
&report;
SHAR_EOF
chmod 0444 bcs-2.0/tests/init.test ||
echo 'restore of bcs-2.0/tests/init.test failed'
Wc_c="`wc -c < 'bcs-2.0/tests/init.test'`"
test 3066 -eq "$Wc_c" ||
	echo 'bcs-2.0/tests/init.test: original size 3066, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/tests/rcs.test ==============
if test -f 'bcs-2.0/tests/rcs.test' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/tests/rcs.test (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/tests/rcs.test (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/tests/rcs.test' &&
# -*- perl -*-
#
# $Id: rcs.test,v 1.12 1994/03/07 21:47:41 qjb Exp $
# $Source: /local/tmp/bcs-2.0/tests/RCS/rcs.test,v $
# $Author: qjb $
#
# Copyright (C) 1994  E. Jay Berkenbilt
#
# No need to perform these tests in all the baseline and staging
# area configurations set up in setup.
#
# Test checkin, checkout, register_file, and some unstage
# functions with RCS as the CM system.
#
# When adding tests to this file, consider whether it is
# appropriate to add them to tests for other CM packages as
# well. 
#
# Tests:
#
# REGISTER FILE
#   Make sure register file works when directories need to be created
#   Register file that already exists in staging area
#   Try to register file that exists in baseline
# 
# IMPORTANCE TESTS
#   file with CM log
# 
# BCS TESTS
#   Try checking some files in and out
#
# UNSTAGE TESTS
#   Writable files with logs
#   Checked-in, non-updated files
# 
# UPDATE BASELINE
#   Files with no logs
#   Writable files with logs
#   Out-of-date files with logs
#   Checked-in, non-updated files
# 
X
(scalar(@ARGV) == 4) || die "This script should be run from bcs_test.\n";
($srcdir, $bindir, $tests, $testdir) = (@ARGV);
X
$category = "RCS support";
require "$tests/test_routines.pl";
X
# If we don't have RCS, skip this test.
&report if (system("grep HAVE_RCS $srcdir/lib/rcs_paths.h " .
X		   ">/dev/null 2>&1") != 0);
X
$testdir .= "/rcs";
&rmrf($testdir);
&make_dir("$testdir");
X
$ENV{"BASELINE"} = $baseline = "$testdir/bl";
$ENV{"STAGING"} = $staging = "$testdir/st";
X
&make_dir("$baseline");
&write_file("$baseline/.baseline_conf", "cm: RCS\n");
SHAR_EOF
true || echo 'restore of bcs-2.0/tests/rcs.test failed'
fi
echo 'End of bcs-2.0 part 5'
echo 'File bcs-2.0/tests/rcs.test is continued in part 6'
echo 6 > _shar_seq_.tmp
exit 0
