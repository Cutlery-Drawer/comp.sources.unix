Newsgroups: comp.sources.unix
From: ejb@ERA.COM (Jay Berkenbilt)
Subject: v28i021: bcs-2.0 - A Baseline Configuration System, Part20/25
References: <1.764985670.1461@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: ejb@ERA.COM (Jay Berkenbilt)
Posting-Number: Volume 28, Issue 21
Archive-Name: bcs-2.0/part20

#!/bin/sh
# this is bcs.20 (part 20 of bcs-2.0)
# do not concatenate these parts, unpack them in order with /bin/sh
# file bcs-2.0/doc/bcs.info-2 continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 20; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping bcs-2.0/doc/bcs.info-2'
else
echo 'x - continuing file bcs-2.0/doc/bcs.info-2'
sed 's/^X//' << 'SHAR_EOF' >> 'bcs-2.0/doc/bcs.info-2' &&
on March 19, 1994.
X
X   Copyright (C) 1994  E. Jay Berkenbilt
X
X   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.
X
X   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.
X
X   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation.
X
X
File: bcs.info,  Node: Creating the Baseline,  Next: Internal Files,  Prev: Setting up BCS,  Up: Technical Guide to BCS
X
Creating the Baseline
=====================
X
X   The baseline can have any structure that is convenient for the
project.  The only constraint that BCS imposes is that the underlying
configuration management system be one that it supports.  As of the
writing of this document, only RCS and SCCS are supported.  However, it
would be easy to add support for any configuration management system
that is similar to RCS or SCCS.  For information about this, see *Note
Configuration Management Package Interface::.  The baseline should
first be set up to support use of the underlying package.  In the case
of RCS, this means that `RCS' directories should be created in every
directory in which files will be checked in.  Please see the RCS manual
pages for more information about RCS.  In the case of SCCS, `SCCS'
directories should be created.  See the SCCS documentation for more
information about SCCS.  It is suggested but not required that the
baseline directories be created with the setgid bit set.  This way,
they will pass their group on to files and directories created in
them.(1) All directories in the baseline must be writable by all users
of the system who are authorized to check files in, register files, and
update the baseline.
X
X   ---------- Footnotes ----------
X
X   (1)  This does not work on all operating systems.
X
X
File: bcs.info,  Node: Internal Files,  Next: Creating Staging Areas,  Prev: Creating the Baseline,  Up: Technical Guide to BCS
X
Internal Files
==============
X
X   For BCS to operate according to specific project needs, a number of
special files can be be created.  Most of these reside in the baseline
and most are optional.  The special files (referred to here as
"internal files") are as follows:
X
`.baseline_conf'
X     This file must exist at each top-level baseline directory.  A file
X     by this name is not treated specially by BCS if it exists in any
X     other location.  This file sets various parameters specific to
X     this baseline for BCS.  In some cases, the information in the
X     `.baseline_conf' files must agree in all baseline directories.
X     (BCS enforces this, so there is no risk of accidental
X     inconsistency.)  The format of this file is a list of key-value
X     pairs.  Only one pair should appear on each line.  The keys and
X     values are separated by colons.  Blank lines are ignored.  The
X     following keys are valid:
X
X        * `cm'.  This key is required.  Its value is the name of a
X          supported configuration management package.
X
X        * `unimp_warn_suffixes'.  This key is used to specify a list of
X          suffixes that should be given special treatment by the
X          `unstage' and `sync_staging' commands.  Specifically, any
X          unimportant files encountered that end with one of the
X          suffixes listed are brought to the attention of the user by
X          `sync_staging' and are not deleted by `unstage' without
X          confirmation.  Suffixes listed here are separated by
X          white-space.  This behavior can be turned off on a
X          per-directory basis with the `.unimp_nowarn' file.
X
`.baseline_path'
X     This file must exist at each top-level staging area directory.
X     This file is not treated specially by BCS if it appears in any
X     other location.  This file should contain one line: the path to
X     the baseline with respect to the staging area directory.  It can
X     be either an absolute path or a relative path.  The links created
X     in the staging area by `stage' and `sync_staging' use this
X     information.  If a staging area is moved so that the baseline path
X     is no longer valid, it is sufficient to update this file and run a
X     recursive `sync_staging'.  This is likewise sufficient after the
X     baseline is moved or after the baseline path has been changed from
X     absolute to relative or relative to absolute.
X
`.important'
X     A file by this name is treated specially by BCS only when it
X     appears in the baseline.  This file can exist in any baseline
X     directory at any level.  If it exists, it generally contains a
X     list of files, one per line, to be considered important even if
X     they would not be important by default.  Although it cannot
X     contain regular expressions in general, if it contains only a line
X     with the `*' character in it, it means that all files in the
X     directory are automatically important.  It is not generally
X     necessary to make specific files important explicitly, but it can
X     be useful in certain instances.  For example, in a software
X     project, it may be desirable to put `*' in `.important' in a
X     directory that contains installed binary files or to put a few
X     specific installed binaries in a `.important' file in a directory
X     that contains a combination of a few installed binaries and some
X     scripts with history logs.  Gratuitous use of this file is
X     discouraged.  It is not appropriate to use this file to avoid
X     having to check in files that you want to see in the staging areas
X     unless those files really aren't supposed to be edited by the
X     user.  (In this case, putting them in `.no_stage' may also be
X     desirable.)  If you find yourself making frequent use of the
X     `.important' file, you should probably rethink your baseline
X     configuration.
X
`.unimportant'
X     A file by this name is treated specially by BCS only when it
X     appears in the baseline.  This file can exist in any baseline
X     directory at any level.  If it exists, it contains a list of
X     files, one per line, that are explicitly unimportant.  It can be
X     useful for preventing temporary directories created in the
X     baseline from showing up in the staging area, for example.
X     Another good use of the `.unimportant' file is to prevent a
X     directory in the baseline that contains staging areas from showing
X     up in people's staging areas.  If a file appears in both
X     `.unimportant' and `.important', the file is considered important.
X
`.auto_stage'
X     A file by this name is treated specially by BCS only when it
X     appears in the baseline.  This file can exist in any baseline
X     directory at any level.  If it exists, it contains a list of
X     files, one per line, that should be staged automatically when the
X     directory is staged.  This can be useful for forcing directories
X     that the system writes into at run time to be staged separately in
X     each user's staging area.
X
`.no_stage'
X     A file by this name is treated specially by BCS only when it
X     appears in the baseline.  This file can exist in any baseline
X     directory at any level.  If it exists, it contains a list of
X     files, one per line, that are prohibited from being staged.  This
X     can be useful for files that are explicitly made important but
X     shouldn't be edited in the staging areas or for directories that
X     must be shared across all staging areas.
X
`.unimp_nowarn'
X     A file by this name is treated specially by BCS only when it
X     appears in the baseline.  This file can exist in any baseline
X     directory at any level.  The contents of the file are currently
X     ignored.  If this file exists, then `sync_staging' and `unstage'
X     will not warn when they find unimportant directories or
X     unimportant files with special suffixes.  This can be useful in a
X     baseline where, for example, files ending with `.c' are special but
X     one directory contains many automatically generated `.c' files
X     that are not important and shouldn't be.  This file should be used
X     with caution since it turns off some checks.  This file's effect
X     is limited to the directory in which it appears.  It does not
X     apply recursively.  It also does not affect checks that are made
X     on important files.
X
X
File: bcs.info,  Node: Creating Staging Areas,  Next: Adding BCS to an Existing Baseline,  Prev: Internal Files,  Up: Technical Guide to BCS
X
Creating Staging Areas
======================
X
X   Staging areas are special symbolic link farms to the baseline.  A
staging area must contain the same number of top-level directories as
the baseline.  Each top-level staging area directory must contain a
`.baseline_path' file as described above.  To create a staging area,
simply create a directory corresponding to each baseline directory and
populate it with a `.baseline_path' file.  Then run `sync_staging' in
each staging area directory to populate it with the initial set of
links.  It may be desirable for specific programs to provide scripts
for users to use to create their own staging areas to assure that
staging areas parallel baselines in their structure.  This will not
generally be necessary if there is only one top-level directory in the
baseline.
X
X   Here is a simple example of creating a staging area.  We assume that
the user `q_user' is working on a project called `q_project'.  The
baseline consists of one top-level directory called
`/projects/q_project'.  All users in this project are in the group `q'.
The user wishes to create a staging area in his or her own home
directory.
X
X     cd
X     mkdir q_project
X     chmod g+s q_project
X     chgrp q q_project
X     cd q_project
X     echo /projects/q_project > .baseline_path
X     sync_staging .
X
X
File: bcs.info,  Node: Adding BCS to an Existing Baseline,  Prev: Creating Staging Areas,  Up: Technical Guide to BCS
X
Adding BCS to an Existing Baseline
==================================
X
X   Adding BCS to an existing baseline that uses a supported
configuration management system is fairly straight forward.  All that
is required is placing the correct internal files (as described above)
in the correct locations.  It may be desirable to set up the
compilation tools so that they know about BCS, but with suitable use of
internal files, even this is not generally necessary.  At the very
least, a baseline needs a `.baseline_conf' file to use BCS.
X
X   A set of makefiles and scripts that implement a build environment
suitable for use with BCS is provided with the sources.  These are in
the public domain and not protected under any of the licenses included
with BCS.  The contributed makefiles use features of GNU make, but the
functionality of GNU make is not required to support BCS.  These
makefile templates can be found in the sample baseline under the
`unsupported/sample-baseline' directory in the source distribution.
X
X
File: bcs.info,  Node: Example Uses of BCS,  Next: Possible Future Enhancements,  Prev: Technical Guide to BCS,  Up: Top
X
Example Uses of BCS
*******************
X
X   This section describes some example uses of BCS.  It is not intended
to be a complete list of uses or to be a thorough set of instructions
for any of these situations.  This section is merely provided in an
effort to help give new or prospective users some ideas of how they
might use this tool.
X
* Menu:
X
* Multiple Simultaneous Developers::
* Support for a Multi-platform Environment::
X
X
File: bcs.info,  Node: Multiple Simultaneous Developers,  Next: Support for a Multi-platform Environment,  Prev: Example Uses of BCS,  Up: Example Uses of BCS
X
Multiple Simultaneous Developers
================================
X
X   BCS was originally designed for use by many developers working on a
common body of source code.  Since this was the situation for which BCS
was designed, it works well for this case.  In this situation, the
baseline is the authoritative body of source code, documentation, etc.
for the project.  It is controlled under a version control or
configuration management system such as RCS or SCCS.  BCS can be used
to provide a degree of concurrency without fundamentally changing the
structure or organization of the baseline.  Each programmer on the
project will have his or her own staging area and will stage only the
sections of the project that he or she is currently working on.
Programmers will test their changes in their own staging areas and
update the baseline only when their changes are stable.  BCS will be
only part of the baseline management procedures that this project
should use.  BCS provides concurrency.  Other procedures must be in
place to maintain the stability of the baseline.  These procedures
could be a simple as specifying who is or is not authorized to update
the baseline at what times.  They could also be much more elaborate.
An example procedure follows.
X
* Menu:
X
* Maintaining Baseline Stability::
X
X
File: bcs.info,  Node: Maintaining Baseline Stability,  Prev: Multiple Simultaneous Developers,  Up: Multiple Simultaneous Developers
X
Example Procedure for Maintaining Baseline Stability
----------------------------------------------------
X
X   This section suggests a possible solution to the problem of having
conflicting changes being made to files in the baseline or to changes
being made by one user and covered up by another user.
X
* Menu:
X
* Stability Problem::
* Stability Solution::
* Example of Stability Problem::
* Stability Implications::
X
X
File: bcs.info,  Node: Stability Problem,  Next: Stability Solution,  Prev: Maintaining Baseline Stability,  Up: Maintaining Baseline Stability
X
The Problem
...........
X
X   RCS was not designed to be a concurrency management system.
Instead, it was designed to be a system to handle preventing multiple
users from working on a given file simultaneously.  In a system such as
RCS in which a file is owned and locked by a single user, concurrency
problems are detected at the time when a file is checked out.  In other
configuration management paradigms, these problems are delayed until
the files are checked in at which point a merge is performed.
X
X   Given the structure and organization of many baselines, neither
solution is always practical.  If only one lock per file is allowed,
people will not be able to make progress on changes that require edits
to be made in large numbers of files.  However, if conflict resolution
is postponed until checkin, merge problems will consume the majority of
every developer's time.
X
X
File: bcs.info,  Node: Stability Solution,  Next: Example of Stability Problem,  Prev: Stability Problem,  Up: Maintaining Baseline Stability
X
A Possible Solution
...................
X
X   Given the above situation, the following incremental merging
procedure is proposed.  At present, this procedure will need to be
followed manually.  If it turns out to work well enough, perhaps it can
be refined and incorporated into a future version of BCS.
X
X   Under the current BCS paradigm, files can be checked in multiple
times before being updated in the baseline.  This means that it is
possible for the last stable version of a file to be earlier than the
last version that has been checked into RCS.  This means that if
another user does an `update_baseline' on this file, an unstable
version will appear in the baseline.  Likewise, when a user checks a
file out, he or she will have, in the staging area, a file that may
contain someone's untested, incremental edits.  To avoid this situation,
we must enforce that a revision will be added to the default branch of
a file only when it is tested and considered stable.
X
X   To make this possible, all incremental changes to a file must be
made on a branch originating from the latest revision on the main
branch.  When the changes made in a given branch are ready to be merged
into the baseline, coordination is required between all holders of a
given branch.  When a suitably merged file exists, it will be checked
into the main branch and updated in the baseline.  At all times, there
will be one developer who is the *owner* of a file and will be
responsible for coordinating merges of other branches.  This person
will be the holder of the lock on the main branch.
X
X   The mechanics of this method are probably best explained with
examples since the general concept is somewhat difficult.
X
X
File: bcs.info,  Node: Example of Stability Problem,  Next: Stability Implications,  Prev: Stability Solution,  Up: Maintaining Baseline Stability
X
Example
.......
X
X   Suppose the file `a.c' currently exists in the baseline and is
stable.  The latest revision on the head branch is revision `1.4'.
This revision is not locked and has no branches based upon it.
X
X   User `A' decides to make some changes to `a.c'.  When user `A' goes
to check out the file, the checkout succeeds, and user `A' acquires a
lock on revision `1.4' of `a.c'.  As user `A' makes incremental changes
and checkins of `a.c', he or she will start the branch `1.4.1' from
`1.4'.  `A''s revisions will be `1.4.1.1', `1.4.1.2', etc.
X
X   Now user `B' comes along.  When `B' tries to check out `a.c', the
checkout initially fails because user `A' already has a lock.  In this
situation, user `B' contacts user `A' to discuss the nature of their
changes.  If user `B' needs to make changes that can easily be
performed by user `A', it may be best for `A' to make the the changes
rather than having `B' get involved.  (An example would be correcting a
typographical error in a comment, reordering include directives, etc.)
If `B' really needs to change `a.c' at the same time as `A', then `B'
will use BCS to check out `a.c' in his or her own staging area without
a lock, manually give him or herself write permission, and check in any
changes made in the new branch `1.4.2'.  If a user `C' were to come
along, `C' would have to contact both `A' and `B'.  We will ignore this
case for now and assume that we only have two branches of `a.c'.
X
X   Now suppose that `B' finishes making changes and determines that
those changes are stable and ready to be put back into the baseline.
At this point, `B' will want to check in his or her changes as revision
`1.5'.  `A' must therefore release the lock on `1.4'.  When `B' creates
`1.5' and updates the baseline, `A' should obtain a lock on revision
`1.5' and merge the changes from `1.4.1.x' to `1.5' into his or her
working version.(1)  This new merged file now begins a new branch of
`1.5'.  User `A' can continue making changes from here.  The `1.4.1'
branch is now defunct.
X
X   Note that if `A' finishes first, `A' can simply notify `B' and then
update the baseline.  `B' can then acquire a lock on revision `1.5',
merge in his changes, and continue editing.  BCS version 2.0 warns
during `update_baseline' if any locks exist on the file being updated.
This should alert the user doing the update that it may be necessary to
warn other users that there are changes to be merged.  Given this, how
do we enforce that `B' be notified when `A' is ready to update changes?
`A' might not even remember that there are any other active branches
of revision `1.4'.  One possibility would be for BCS to send mail to
the users who have branches locked.  Another would be for BCS to warn
that this situation exists and require confirmation from the user
before continuing with the update.  Any comments on this can be
directed to the author.
X
X   ---------- Footnotes ----------
X
X   (1)  The `rcsmerge' program is good for this purpose if the merges
are simple.  If they are more complex, the `emerge' facility that comes
with GNU Emacs version 19 can greatly simplify performing such merges.
X
X
File: bcs.info,  Node: Stability Implications,  Prev: Example of Stability Problem,  Up: Maintaining Baseline Stability
X
Implications
............
X
X   The above situation is quite complex, but the author asserts that the
complexity of performing the above operations is less than it would be
if merges were further delayed.  The above scenario essentially
describes incremental merging.  With this scenario, all merges are
performed as soon as possible rather than as late as possible.  The
above discipline should also reduce the frequency with which people
make gratuitous changes to files in the baseline when those changes can
be delayed.  For example, it would be appropriate to go through the
above hassle if something simple like changing includes occurs or if
two non-conflicting functionalities implemented in the same file both
need to be changed.  It would not, however, be a good idea to go through
the above if one user wanted to reindent a file that another user was
working on.  In this case, the reindentation should be performed
separately when no other branches exist or should be performed by the
single user who has a lock on the file.  In any case, such changes
should always be isolated via the configuration management system from
other changes that are made at the same time (i.e., check the file out,
reindent, and check in).
X
X
File: bcs.info,  Node: Support for a Multi-platform Environment,  Prev: Multiple Simultaneous Developers,  Up: Example Uses of BCS
X
Support for a Multi-platform Environment
========================================
X
X   Although supporting a multi-platform development environment is best
done outside the configuration management system, there are certain
instances in which the use of BCS can help ease the process of porting
a system to a new architecture.  This section describes an example of
how to approach this problem with BCS.  For an example of how to
approach this problem with makefiles, see the sample baseline included
with the BCS distribution in `unsupported/sample-baseline'.
X
X   Suppose a fairly stable system exists on a single platform.  The
makefiles (or whatever is used to build the system) and the system
sources are not set up to support easy builds on multiple platforms.
Assume that all the files required to build and run the system are
controlled in a version control system that is supported by BCS.  In
this situation, a port can be done simply by making the stable source
tree into the BCS baseline.  A staging area can then be set up in which
to build the system on another platform.  Unless the build procedure is
integrated with BCS, it will be necessary to stage all directories in
this staging area that will contain object files or other
architecture-dependent files.  The sample baseline included with the
BCS distribution includes makefiles that handle these details
automatically.  Once the necessary directories have been staged, the
staging area has essentially the same structure as the baseline except
that the source files and `RCS' or `SCCS' directories are symbolic
links.  At this point, BCS commands can be used to check out files,
make changes, and test the results before merging the patched code into
the stable baseline.  It would even be possible to use the staging area
to build on the original platform to make sure that the changes didn't
break the previous system.  Once the port had been completed and
tested, the baseline could be updated, and the port would be complete.
X
X
File: bcs.info,  Node: Possible Future Enhancements,  Next: Acknowledgments,  Prev: Example Uses of BCS,  Up: Top
X
Possible Future Enhancements
****************************
X
X   This section describes a few ideas for future expansion of BCS.
These features, if they are implemented, will not be part of 2.0, but
will probably still be part of major version 2.  These changes could be
made without fundamental change to the way BCS works and without
radically changing the semantics of existing commands.
X
* Menu:
X
* Hierarchical Staging Areas::
* Secure Baseline::
X
X
File: bcs.info,  Node: Hierarchical Staging Areas,  Next: Secure Baseline,  Prev: Possible Future Enhancements,  Up: Possible Future Enhancements
X
Hierarchical Staging Areas
==========================
X
X   In BCS version 2.0, the baseline/staging area structure is
two-tiered: the baseline is the authoritative copy of the controlled
files, and the staging areas are all equal and all inherit directly
from the baseline.  Certain assumptions are made about the baseline
including that the `RCS' or `SCCS' directories are actually directories
and that the baseline is self-contained.
X
X   There are many instances in which it would be useful to have a
hierarchical system of staging areas.  In this paradigm, there would
still be a single, authoritative baseline.  Staging areas, however,
could either inherit directly from the baseline, or they could inherit
from other staging areas.  A command (perhaps called `promote') could
be added to BCS that would be similar to `update_baseline' except that
it would promote a file up one level in the staging area hierarchy.  If
one staging area inherits from another, the inheritance could be set up
using a configuration file at the top-level of the staging area in much
the same way the `.baseline_path' file is used now.  BCS could do some
amount of loop detection and validation to make sure that the given
staging area eventually points back to the baseline.  There could be
several possible applications for such a setup.  Some are considered
here.
X
* Menu:
X
* Integration of Changes in Two Staging Areas::
* Maintenance of Multiple Revisions of Software::
X
X
File: bcs.info,  Node: Integration of Changes in Two Staging Areas,  Next: Maintenance of Multiple Revisions of Software,  Prev: Hierarchical Staging Areas,  Up: Hierarchical Staging Areas
X
Integration of Changes in Two Staging Areas
-------------------------------------------
X
X   In the current BCS paradigm, each staging area is generally
maintained by a single developer.  Changes are made and tested in this
staging area.  Once they are stable, the files are updated directly
into the baseline.  One can easily imagine situations in which a major
piece of functionality in a system is being changed, and more than one
developer works on different parts of the change.  Although each
developer will generally be able to do some testing in his or her
private staging area, a separate staging area may be needed to do some
integration testing before imposing the changes on the baseline.  In
the current BCS implementation, this can be done, but it requires
manually checking out the correct versions of files in the new staging
area.  In a BCS that supports hierarchical staging areas, each
developer would merely reparent his or her staging area, run
`sync_staging', and then promote files that are ready for integration.
Integration could be done in this special staging area, and then, when
changes are tested, integrated, and shown to be stable, the baseline
could be updated.
X
X   Such integration staging areas could be created on the fly for
particular purposes, or they could be in place for the duration of a
development effort.  One can imagine situations in which all developers
of all levels would have access to update the staging area that is the
parent of their individual staging areas, but that only more
experienced developers or baseline administrators could update the
baseline.  This way, users would be free to promote changes for
thorough integration testing without intervention, but could still be
denied write access to the baseline.
X
X
File: bcs.info,  Node: Maintenance of Multiple Revisions of Software,  Prev: Integration of Changes in Two Staging Areas,  Up: Hierarchical Staging Areas
X
Maintenance of Multiple Revisions of Software
---------------------------------------------
X
X   If BCS had the ability to have one staging area inherit from
another, then it would automatically have the ability to support
baselines whose `RCS' or `SCCS' directories are symbolic links.  If the
additional feature of supporting default revisions for a staging area
were supported, then a single set of version control logs could
underlie, say, a maintenance or bug-fix area for version 1 of a system
and a development area for version 2.  All users who are working
maintaining version 1 could inherit from a special staging area that has
version 1 as its default, and all users working on new development could
inherit from the baseline directly or from another staging area set up
for version 2 development.  Exactly how this would work is not yet
known, but it would probably be based on having BCS automatically
specify a revision when checking files in or out based on some
information in a per-staging-area configuration file.
X
X
File: bcs.info,  Node: Secure Baseline,  Prev: Hierarchical Staging Areas,  Up: Possible Future Enhancements
X
Secure Baseline
===============
X
X   Depending on the size of a project and on other constraints, it is
sometimes desirable to restrict who has what access to the baseline.
One could divide security levels of the baseline into these categories:
X   * All users have write-access to the baseline directories.  No
X     restrictions are put upon who can check files in or out, update
X     the baseline, or register new files.
X
X   * Only authorized users can check files in, register files, or
X     update the baseline, but any user can check files out.
X
X   * Only authorized users can perform any operations that require
X     modification of the baseline or history logs.
X
X   The first and third of the above conditions can be achieved with
file protections alone.  The second configuration is difficult to
achieve this way because configuration management packages such as RCS
and SCCS require the user to have write access to the baseline in order
to lock files.  To compensate for this, BCS could operate in secure
mode.  In secure mode, the `bcs' command could be installed "setuid".
It could effectively become a user with write-access to the baseline for
the locking operation.  This way, access to the baseline could be
restricted to all but a small group of users without losing the ability
for individual users to check files out as needed.  This would also
prevent unauthorized users from operating on baseline files with the
underlying configuration management commands directly.
X
X   Whether or not a baseline would operate in secure mode could be
controlled by a flag in the `.baseline_conf' file.  The security
mentioned above assumes that the underlying file system is secure and
that setuid operation of bcs commands is permitted.
X
X   At present, there seems to be much less demand for this type of
secure operation than there is for hierarchical staging areas,
especially since much of this functionality could be achieved that way
as well.
X
X
File: bcs.info,  Node: Acknowledgments,  Next: Internals,  Prev: Possible Future Enhancements,  Up: Top
X
Acknowledgments
***************
X
X   So many people have supported my development of BCS that there it
would be difficult to list all of them here by name.  I'd like to thank
all the people at Engineering Research Associates who served as my
alpha testers and who supported me in developing this software on my
own time and distributing it under the terms of the General Public
License and/or the Artistic License.  I am also appreciative to the
beta testers out in netland who have offered many helpful suggestions
and exposed the software to valuable testing.  I also thank my wife,
Lisa (also a BCS alpha tester), for allowing me to spend several
consecutive weekends working on BCS.  I couldn't have completed this
project without her support.
X
X
File: bcs.info,  Node: Internals,  Next: Index,  Prev: Acknowledgments,  Up: Top
X
Internals
*********
X
X   This section partially documents the internals of BCS.  Information
covered includes algorithms and data structures used, design intent,
etc.
X
* Menu:
X
* Overview of Internals::
* Classification of Files::
* Caching File System Information::
* The File Information Table::
* Debugging::
* Configuration Management Package Interface::
* Staging and Synchronization::
* Unstaging Files and Directories::
X
X
File: bcs.info,  Node: Overview of Internals,  Next: Classification of Files,  Prev: Internals,  Up: Internals
X
Overview
========
X
X   BCS exists to manipulate people's source code.  It therefore must be
extremely conservative about what it does.  This means that operations
should be atomic when possible and that there should always be some
reasonable recovery from errors and user-initiated aborts.  BCS should
never delete files haphazardly.  Deleting symbolic links in the staging
area that don't point anywhere or don't have corresponding files or
links in the baseline is acceptable as is deleting files when unstaging
directories provided that the necessary checks have been made.
X
X   BCS should be efficient and should avoid doing multiple accesses to
the file system for the same file.  This means that an invocation of a
BCS command will typically result in a large amount of information
being cached.
X
X   BCS is based on top of configuration management packages.  RCS is
the recommended package, but BCS is implemented in a way that makes it
easy to plug in other packages as well.  This document explains how BCS
interfaces with its underlying configuration management packages.
X
X   BCS implements a baseline and multiple staging areas.  With the
exception of printing help messages and version information, all BCS
operations require the baseline and staging area to be identified in
the environment or on the command line.  A configuration file must
exist at the top-level of each baseline directory.  This configuration
file must specify what the baseline's configuration management package
is, etc.
X
X
File: bcs.info,  Node: Classification of Files,  Next: Caching File System Information,  Prev: Overview of Internals,  Up: Internals
X
Classification of Files
=======================
X
X   The basis of BCS involves being able to distinguish between
important and unimportant files.  Every file is either important or
unimportant.  Determination of the importance of a file is done based
upon the underlying configuration management system and other
constraints.
X
X   A file's importance is determined in several ways.  This discussion
of importance applies to files in the baseline.  Files in the staging
area that do not have corresponding files in the baseline are
considered unimportant.  (The exception is internal files which are
always considered important.)  Other staging area files inherit their
importance from their baseline counterparts.  The only circumstance
under which a staging area file will have a different importance from
its baseline counterpart is if instances of filenames that are used
internally by the BCS in the baseline appear in the staging area.  In
this case, they are unimportant in the staging area and important in
the baseline.  (This would include `.important', `.unimportant',
`.auto_stage', `.no_stage', and `.unimp_nowarn' at any level, and
`.baseline_conf' at the top level.  The contents of files are ignored
by the utilities if they are encountered in the staging area.  There is
no reason for these files to exist in the staging area.)
X
X   Every file has an importance which can be overridden explicitly.  By
default, files in the baseline that are neither symbolic links nor
directories files are important if they are registered with the
underlying configuration management package and are unimportant
otherwise.  Directories are considered important by default.  Symbolic
links to files in the baseline inherit their importance from the files
they are ultimately linked to.  Symbolic links to files outside of the
baseline are unimportant by default.  A file or directory can be made
explicitly unimportant by appearing in the `.unimportant' file or made
explicitly important by appearing in the `.important' file in its
containing directory.  If a file appears in both a `.important' file
and a `.unimportant' file, it is considered important.  A `.important'
file containing only `*' means all files are important in that
directory.  The `.important' file cannot contain regular expressions in
general; `*' is a special case.
X
X
File: bcs.info,  Node: Caching File System Information,  Next: The File Information Table,  Prev: Classification of Files,  Up: Internals
X
Caching File System Information
===============================
X
X   When analyzing performance of BCS, it became evident that the most
expensive operations by far were calls to the `lstat' system call.
This call is used to obtain specific information about a named file
from the file system.  Since BCS requires frequent access to the layout
of the file system and into specific information about files, this
information is cached.  The cache is implemented as a tree that has the
same shape as the file system.  When files are removed, they are
removed from the cache as well.  Since the cache is structured to be
parallel to the file system, the chance of an inconsistency appearing
in the cache is very low.
X
X
File: bcs.info,  Node: The File Information Table,  Next: Debugging,  Prev: Caching File System Information,  Up: Internals
X
The File Information Table
==========================
X
X   All information needed about files encountered in an invocation of
BCS is cached in a table which will be referred to as the "file
information table".  The file information table consists of a number of
file information structures which are stored in the file system cache
described above.
X
X   A file information structure contains all the information needed
about a file for determining its importance and its eligibility for
being staged.  Some information about whether the file is eligible to
be unstaged is stored as well.  See the definition of
`bcs_file_info_rec' in `file_info.h' for the specific fields.
X
X   To explicitly populate the table, the `bcs_examine_dir' routine is
called with a directory name and a recursive flag.  If the recursive
flag is set, the directory is inserted recursively.  For each
directory, all the files in the directory are checked and inserted in
the table.  If the directory is in the staging area, the directory's
baseline counterpart is searched too.  "Precious directories" (those
used internally by configuration management packages) are omitted from
the list of directories and are not searched recursively.  A pointer to
a callback function is passed to this routine.  If the pointer is
non-`NULL', the function is called with passed in data, the global bcs
state object, and the current file information structure for item found
by `bcs_examine_dir'.  The `bcs_examine_dir' function is organized in
such a way that the callback is called on file information structures in
sorted order.  This way, commands such as `classify_files' or
`id_staged' can call `bcs_examine_dir' once with a callback function and
avoid multiple lookups or long delays before the user sees any results.
X
X   An individual file can be looked up in the table by name with the
`bcs_get_file_info' routine.  If a file's information is found in the
table, it is returned.  Otherwise, a new file information structure is
allocated and inserted into the table.  Individual fields of the file
information structure are not computed until they are needed.
X
X
File: bcs.info,  Node: Debugging,  Next: Configuration Management Package Interface,  Prev: The File Information Table,  Up: Internals
X
Debugging
=========
X
X   If BCS was compiled with debugging enabled, the environment variable
`DEBUG_BCS' is checked when the utilities initialize.  The value of
this variable can be overridden with the `--debug' option on the
commandline.  If no debugging information is requested, none will be
printed.  This variable consists of a colon-separated list of lower-case
keywords specifying what kind of information should be displayed.
Valid keywords are
X
`logic'
X     Print information about major decisions and why they are being
X     made;
X
`trace'
X     Print information about function calls and returns;
X
`verbose'
X     Print verbose messages at certain times;
X
`path'
X     Print message specific to pathname processing;
X
`all'
X     All debugging is turned on;
X
`none'
X     Turn off debugging information.  This keyword is ignored if
X     accompanied by other options.  Any keyword other than one
X     mentioned above will serve this purpose.
X
X   Note that information printed by these debug flags are only as
complete as was necessary during the development.  For example, turning
on `trace' does not trace all function calls and does not always print
all the information that would be useful when a function is entered or
exited.  Even so, running BCS with `--debug all' will produce a
considerable volume of output.
X
X
File: bcs.info,  Node: Configuration Management Package Interface,  Next: Staging and Synchronization,  Prev: Debugging,  Up: Internals
X
Configuration Management Package Interface
==========================================
X
X   BCS implements generic support for underlying configuration
management packages.  In order for BCS to provide a front end to
various configuration management packages, it needs to know a specific
set of things about each underlying package.  Specifically, it needs to
know the following:
X
X   * The name of the package;
X
X   * The list of commands that are needed for checkin and
X     checkout operations and which operation they perform;
X
X   * What files are for internal use by the configuration
X     management system (referred       to as "precious" files since
X     they must always exist);
X
X   * How to tell whether a file has a log;
X
X   * How to tell whether a file is up-to-date;
X
X   * How to update the baseline copy of a file;
X
X   * How to register a new file with the system.
X
X   Adding support for a new configuration management system is a matter
of writing code to implement the above functions.  See `cm.h' for
definitions of the appropriate structures.  If you wish to add support
for a new configuration management package, look at the implementation
of RCS and SCCS support.  To implement support for a new configuration
management package, a source and header file to implement the above
functionality must be added.  This file fills in the fields of a
structure which is returned by the one externally callable routine in
the file: the register routine.  A prototype for this routine should be
added to `cm.h' and a call to it should be placed in `init.c'.  In
addition, of course, the makefile will need to be modified so that the
file is compiled and linked in to the system.  No other changes should
be required for implementation of a new configuration management
package.  It is possible that other changes may be made if the
configuration management package has some needs that are not handled by
the current interface.  If this is the case, extreme care should be
made to avoid putting any package-specific knowledge into the code.
Support for a configuration management package should be implemented so
that BCS will still compile and run without that configuration
management package present.  Look at support for RCS and SCCS for one
way to do this.
X
X   For checkin and checkout of files, the `bcs' command itself is used.
It takes as arguments a command with arguments.  It determines what
kind of operation the given command is with respect to the underlying
configuration management package so it can know whether it needs to
stage files or not.  Once it makes sure that the necessary
prerequisites have been met and that this file is eligible for the
specified operation, it will invoke the underlying configuration
management package's command as passed in on the commandline.
X
X   When classifying files, BCS must be able to determine whether a file
has a history log since this determines the default importance of
files.  When synchronizing and staging, BCS must know what files or
directories must exist in the staging area for the shared history log
support to work.  In the case of RCS or SCCS, this is the RCS or SCCS
directory.  It is conceivable that other files or directories could be
needed for other configuration management packages.  BCS tries to be
general about this, but it is possible this this functionality would
require modification for configuration management packages that don't
work basically like RCS.  These special files or directories, which we
refer to as "precious", are always important and unstageable.  This
cannot be overridden with `.auto_stage' or `.unimportant' files.
X
X   When unstaging files, BCS warns if a file has not been updated in
the baseline.  The configuration management package support must
include a function to tell this for this purpose.
X
X   The list of supported configuration management packages is
determined at compile-time.  A configuration management package becomes
supported by BCS by being registered.  To register a configuration
management package, a structure containing function pointers and other
information must be passed to the register function.  BCS enforces that
a specific baseline (possibly including multiple top-level directories)
only uses one configuration management package.  When the baseline
configuration files are read at startup, BCS activates the information
about a specific configuration management package by name.  If that
configuration management package was registered, everything is fine,
and BCS can proceed without knowing any of the details about the
configuration management package.
X
SHAR_EOF
echo 'File bcs-2.0/doc/bcs.info-2 is complete' &&
chmod 0664 bcs-2.0/doc/bcs.info-2 ||
echo 'restore of bcs-2.0/doc/bcs.info-2 failed'
Wc_c="`wc -c < 'bcs-2.0/doc/bcs.info-2'`"
test 45968 -eq "$Wc_c" ||
	echo 'bcs-2.0/doc/bcs.info-2: original size 45968, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/doc/bcs.info-3 ==============
if test -f 'bcs-2.0/doc/bcs.info-3' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/doc/bcs.info-3 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/doc/bcs.info-3 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/doc/bcs.info-3' &&
This is Info file bcs.info, produced by Makeinfo-1.55 from the input
file bcs.texinfo.
X
X   This documentation describes BCS, a Baseline Configuration System
that provides an automated means for maintaining a stable software
baseline along with multiple, individually owned work areas.  This
document describes version 2.0 of BCS.  This document was last revised
on March 19, 1994.
X
X   Copyright (C) 1994  E. Jay Berkenbilt
X
X   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.
X
X   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.
X
X   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation.
X
X
File: bcs.info,  Node: Staging and Synchronization,  Next: Unstaging Files and Directories,  Prev: Configuration Management Package Interface,  Up: Internals
X
Staging and Synchronization
===========================
X
X   The staging and synchronization operations are tightly integrated.
They are defined here in terms of each other.  Synchronization of the
staging area is the process of assuring that the contents of the
staging area are consistent with those of the baseline.  The staging
area should always contain all important baseline files either directly
or in the form of symbolic links.  The only symbolic links that are
allowed to appear in the staging area are links to their own baseline
counterparts, links whose baseline counterparts are also links that
point to the same place, and links that point within the staging area
to unimportant files.  The reason for allowing the last case is that
such links may be makefile targets.  (For example, if a makefile causes
the creation of an executable file along with several links to it,
those links will only have baseline counterparts if the target has been
built in the baseline.  Even if they do have baseline counterparts,
they will not be important.  Even so, it would be undesirable for
`sync_staging' to remove those links.)
X
X   The following steps are performed by the `sync_staging' command. All
steps are done recursively if requested.
X
X   * Verify that all directories requested are in the staging area.
X       Stop if any of them are not suitable.
X
X   * Examine requested directories' baseline counterparts.
X
X   * For each important file in the baseline that is not marked
X     (internally) as       `no_mirror',(1) make sure the corresponding
X     file exists in the       staging area.
X        - If the file in the baseline is a file and the file in the
X          staging area is a file, do nothing.
X
X        - If the file in the baseline is a file and the file in the
X          staging area doesn't exist or is a link to other than its
X          baseline counterpart, make it a link to its baseline
X          counterpart.  If the file has autostage status, stage 	 the
SHAR_EOF
true || echo 'restore of bcs-2.0/doc/bcs.info-3 failed'
fi
echo 'End of bcs-2.0 part 20'
echo 'File bcs-2.0/doc/bcs.info-3 is continued in part 21'
echo 21 > _shar_seq_.tmp
exit 0
