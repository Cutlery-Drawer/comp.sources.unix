Newsgroups: comp.sources.unix
From: ejb@ERA.COM (Jay Berkenbilt)
Subject: v28i002: bcs-2.0 - A Baseline Configuration System, Part01/25
References: <1.764985670.1461@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: ejb@ERA.COM (Jay Berkenbilt)
Posting-Number: Volume 28, Issue 2
Archive-Name: bcs-2.0/part01

#!/bin/sh
# This is bcs-2.0, a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 03/20/1994 04:51 UTC by ejb@ERA.COM
# Source directory /usr/tmp
#
# existing files will NOT be overwritten unless -c is specified
#
# This is part 1 of a multipart archive                                    
# do not concatenate these parts, unpack them in order with /bin/sh        
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#   2034 -rw-rw-r-- bcs-2.0/include/config.h.in
#   4556 -r--r--r-- bcs-2.0/include/bcs.h
#   3311 -r--r--r-- bcs-2.0/include/cm.h
#   3068 -r--r--r-- bcs-2.0/include/common.h
#   1588 -r--r--r-- bcs-2.0/include/flexlist.h
#    555 -r--r--r-- bcs-2.0/include/patchlevel.h
#    521 -r--r--r-- bcs-2.0/include/version.h
#   1507 -r--r--r-- bcs-2.0/lib/Makefile
#   5574 -r--r--r-- bcs-2.0/lib/bcs_p.h
#  11029 -r--r--r-- bcs-2.0/lib/cm.c
#  30386 -r--r--r-- bcs-2.0/lib/file_info.c
#   2509 -r--r--r-- bcs-2.0/lib/file_info.h
#    445 -r--r--r-- bcs-2.0/lib/find_cmd
#   2676 -r--r--r-- bcs-2.0/lib/flexlist.c
#  21921 -r--r--r-- bcs-2.0/lib/init.c
#    930 -r--r--r-- bcs-2.0/lib/make_rcs_h
#    691 -r--r--r-- bcs-2.0/lib/make_sccs_h
#  19680 -r--r--r-- bcs-2.0/lib/path.c
#   1309 -r--r--r-- bcs-2.0/lib/path.h
#   7475 -r--r--r-- bcs-2.0/lib/rcs_cm.c
#    969 -r--r--r-- bcs-2.0/lib/rcs_cm.h
#   7789 -r--r--r-- bcs-2.0/lib/sccs_cm.c
#    958 -r--r--r-- bcs-2.0/lib/sccs_cm.h
#  26143 -r--r--r-- bcs-2.0/lib/staging.c
#  13691 -r--r--r-- bcs-2.0/lib/util.c
#    428 -r--r--r-- bcs-2.0/make/config.mk.in
#    297 -r--r--r-- bcs-2.0/make/params.mk
#    550 -r--r--r-- bcs-2.0/make/rules.mk
#   1068 -r--r--r-- bcs-2.0/man/Makefile
#   4001 -r--r--r-- bcs-2.0/man/bcs.man
#   2873 -r--r--r-- bcs-2.0/progs/Makefile
#   2413 -r--r--r-- bcs-2.0/progs/bcs.c
#   7093 -r--r--r-- bcs-2.0/progs/classify_files.c
#   2372 -r--r--r-- bcs-2.0/progs/in_baseline.c
#   1546 -r--r--r-- bcs-2.0/progs/register_file.c
#   1573 -r--r--r-- bcs-2.0/progs/stage.c
#   2881 -r--r--r-- bcs-2.0/progs/sync_staging.c
#   2718 -r--r--r-- bcs-2.0/progs/unstage.c
#   1651 -r--r--r-- bcs-2.0/progs/update_baseline.c
#   1431 -r--r--r-- bcs-2.0/tests/in_baseline.test
#   3066 -r--r--r-- bcs-2.0/tests/init.test
#   9354 -r--r--r-- bcs-2.0/tests/rcs.test
#   7023 -r--r--r-- bcs-2.0/tests/sccs.test
#   3940 -r--r--r-- bcs-2.0/tests/setup.pl
#  14929 -r--r--r-- bcs-2.0/tests/stage.test
#    502 -r--r--r-- bcs-2.0/tests/template
#   4470 -r--r--r-- bcs-2.0/tests/test_routines.pl
#    604 -r--r--r-- bcs-2.0/tests/version.test
# 131253 -r--r--r-- bcs-2.0/doc/texinfo.tex
#   1256 -r--r--r-- bcs-2.0/doc/Makefile
#    968 -r--r--r-- bcs-2.0/doc/baseline.fig
#    781 -r--r--r-- bcs-2.0/doc/baseline.txt
# 111860 -r--r--r-- bcs-2.0/doc/bcs.texinfo
#   1735 -r--r--r-- bcs-2.0/doc/stagea.fig
#    769 -r--r--r-- bcs-2.0/doc/stagea.txt
#   2227 -r--r--r-- bcs-2.0/doc/stageb.fig
#   1067 -r--r--r-- bcs-2.0/doc/stageb.txt
#   2308 -r--r--r-- bcs-2.0/doc/stagec.fig
#   1067 -r--r--r-- bcs-2.0/doc/stagec.txt
#   1845 -rwxrwxr-x bcs-2.0/doc/tex3patch
#   2682 -rw-rw-r-- bcs-2.0/doc/baseline.EPS
#   3822 -rw-rw-r-- bcs-2.0/doc/stagea.EPS
#   4485 -rw-rw-r-- bcs-2.0/doc/stageb.EPS
#   4616 -rw-rw-r-- bcs-2.0/doc/stagec.EPS
# 315784 -rw-rw-r-- bcs-2.0/doc/bcs.PS
#   3108 -rw-rw-r-- bcs-2.0/doc/bcs.info
#  50024 -rw-rw-r-- bcs-2.0/doc/bcs.info-1
#  45968 -rw-rw-r-- bcs-2.0/doc/bcs.info-2
#  19389 -rw-rw-r-- bcs-2.0/doc/bcs.info-3
#   5182 -rw-r--r-- bcs-2.0/Artistic
#   8493 -r--r--r-- bcs-2.0/ChangeLog
#   2072 -r--r--r-- bcs-2.0/Makefile.in
#   4414 -r--r--r-- bcs-2.0/README
#    277 -r--r--r-- bcs-2.0/acconfig.h
#   2393 -r--r--r-- bcs-2.0/bcs_test
#   1217 -r--r--r-- bcs-2.0/configure.in
#      8 -r--r--r-- bcs-2.0/unsupported/sample-baseline/.baseline_conf
#      8 -r--r--r-- bcs-2.0/unsupported/sample-baseline/.unimportant
#     68 -r--r--r-- bcs-2.0/unsupported/sample-baseline/Makefile
#    194 -r--r--r-- bcs-2.0/unsupported/sample-baseline/RCS/.baseline_conf,v
#    194 -r--r--r-- bcs-2.0/unsupported/sample-baseline/RCS/.unimportant,v
#    242 -r--r--r-- bcs-2.0/unsupported/sample-baseline/RCS/Makefile,v
#   2381 -r--r--r-- bcs-2.0/unsupported/sample-baseline/RCS/README,v
#    762 -r--r--r-- bcs-2.0/unsupported/sample-baseline/RCS/setup,v
#   1851 -r--r--r-- bcs-2.0/unsupported/sample-baseline/README
#     84 -r--r--r-- bcs-2.0/unsupported/sample-baseline/library/Makefile
#    258 -r--r--r-- bcs-2.0/unsupported/sample-baseline/library/RCS/Makefile,v
#    349 -r--r--r-- bcs-2.0/unsupported/sample-baseline/library/RCS/util.c,v
#    257 -r--r--r-- bcs-2.0/unsupported/sample-baseline/library/RCS/util.h,v
#    174 -r--r--r-- bcs-2.0/unsupported/sample-baseline/library/util.c
#     82 -r--r--r-- bcs-2.0/unsupported/sample-baseline/library/util.h
#    516 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/IRIX.mki
#    520 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/Linux.mki
#    692 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/RCS/IRIX.mki,v
#    660 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/RCS/Linux.mki,v
#    677 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/RCS/ccprog.mk,v
#    670 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/RCS/cprog.mk,v
#   1689 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/RCS/global.mki,v
#   1318 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/RCS/library.mk,v
#    730 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/RCS/local.mki,v
#    979 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/RCS/lucid.mki,v
#   9549 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/RCS/make.doc,v
#   1356 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/RCS/prog.mki,v
#   2099 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/RCS/recursive.mk,v
#   6395 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/RCS/rules.mki,v
#    635 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/RCS/sparc.mki,v
#    520 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/RCS/sun_cc.mki,v
#    493 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/RCS/toplevel.mk,v
#    707 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/RCS/HP-UX.mki,v
#    535 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/ccprog.mk
#    528 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/cprog.mk
#   1548 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/global.mki
#   1175 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/library.mk
#    590 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/local.mki
#    837 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/lucid.mki
#   9407 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/make.doc
#   1215 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/prog.mki
#   1942 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/recursive.mk
#   5131 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/rules.mki
#    495 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/sparc.mki
#    378 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/sun_cc.mki
#    351 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/toplevel.mk
#    535 -r--r--r-- bcs-2.0/unsupported/sample-baseline/make/HP-UX.mki
#     67 -r--r--r-- bcs-2.0/unsupported/sample-baseline/prog/Makefile
#    241 -r--r--r-- bcs-2.0/unsupported/sample-baseline/prog/RCS/Makefile,v
#    620 -r--r--r-- bcs-2.0/unsupported/sample-baseline/prog/RCS/main.c,v
#    445 -r--r--r-- bcs-2.0/unsupported/sample-baseline/prog/main.c
#    328 -r--r--r-- bcs-2.0/unsupported/sample-baseline/setup
#    548 -r-xr-xr-x bcs-2.0/unsupported/sample-baseline/tools/RCS/archtype,v
#   1326 -r-xr-xr-x bcs-2.0/unsupported/sample-baseline/tools/RCS/gen_deps,v
#   3702 -r-xr-xr-x bcs-2.0/unsupported/sample-baseline/tools/RCS/installsw,v
#   1257 -r-xr-xr-x bcs-2.0/unsupported/sample-baseline/tools/RCS/islink,v
#   1296 -r-xr-xr-x bcs-2.0/unsupported/sample-baseline/tools/RCS/recursive_make,v
#   1831 -r-xr-xr-x bcs-2.0/unsupported/sample-baseline/tools/RCS/unstage_unit,v
#    374 -r-xr-xr-x bcs-2.0/unsupported/sample-baseline/tools/archtype
#   1182 -r-xr-xr-x bcs-2.0/unsupported/sample-baseline/tools/gen_deps
#   3159 -r-xr-xr-x bcs-2.0/unsupported/sample-baseline/tools/installsw
#    669 -r-xr-xr-x bcs-2.0/unsupported/sample-baseline/tools/islink
#    818 -r-xr-xr-x bcs-2.0/unsupported/sample-baseline/tools/recursive_make
#   1677 -r-xr-xr-x bcs-2.0/unsupported/sample-baseline/tools/unstage_unit
#  17982 -rw-rw-r-- bcs-2.0/COPYING
#   5341 -rw-rw-r-- bcs-2.0/INSTALL
#    619 -rwxrwxr-x bcs-2.0/mkinstalldirs
#  28388 -rwxrwxr-x bcs-2.0/configure
#
if test -r _shar_seq_.tmp; then
	echo 'Must unpack archives in sequence!'
	echo Please unpack part `cat _shar_seq_.tmp` next
	exit 1
fi
# ============= bcs-2.0/include/config.h.in ==============
if test ! -d 'bcs-2.0'; then
    echo 'x - creating directory bcs-2.0'
    mkdir 'bcs-2.0'
fi
if test ! -d 'bcs-2.0/include'; then
    echo 'x - creating directory bcs-2.0/include'
    mkdir 'bcs-2.0/include'
fi
if test -f 'bcs-2.0/include/config.h.in' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/include/config.h.in (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/include/config.h.in (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/include/config.h.in' &&
/* include/config.h.in.  Generated automatically from configure.in by autoheader.  */
X
/* Define to empty if the keyword does not work.  */
#undef const
X
/* Define if you have dirent.h.  */
#undef DIRENT
X
/* Define if you don't have vprintf but do have _doprnt.  */
#undef HAVE_DOPRNT
X
/* Define if you have the vprintf function.  */
#undef HAVE_VPRINTF
X
/* Define if on MINIX.  */
#undef _MINIX
X
/* Define if you don't have dirent.h, but have ndir.h.  */
#undef NDIR
X
/* Define if the system does not provide POSIX.1 features except
X   with this defined.  */
#undef _POSIX_1_SOURCE
X
/* Define if you need to in order for stat and other things to work.  */
#undef _POSIX_SOURCE
X
/* Define if the `S_IS*' macros in <sys/stat.h> do not work properly.  */
#undef STAT_MACROS_BROKEN
X
/* Define if you have the ANSI C header files.  */
#undef STDC_HEADERS
X
/* Define if you don't have dirent.h, but have sys/dir.h.  */
#undef SYSDIR
X
/* Define if you don't have dirent.h, but have sys/ndir.h.  */
#undef SYSNDIR
X
/* Define if the closedir function returns void instead of int.  */
#undef VOID_CLOSEDIR
X
/* Define if `sys_errlist' is declared in <errno.h>.  */
#undef SYS_ERRLIST_DECLARED
X
/* Define if `errno' is declared in <errno.h>.  */
#undef ERRNO_DECLARED
X
/* Define if `free' is declared in <stdlib.h>.  */
#undef FREE_DECLARED
X
/* Define if you have _sys_errlist.  */
#undef HAVE__SYS_ERRLIST
X
/* Define if you have getcwd.  */
#undef HAVE_GETCWD
X
/* Define if you have strerror.  */
#undef HAVE_STRERROR
X
/* Define if you have sys_errlist.  */
#undef HAVE_SYS_ERRLIST
X
/* Define if you have the <memory.h> header file.  */
#undef HAVE_MEMORY_H
X
/* Define if you have the <stdarg.h> header file.  */
#undef HAVE_STDARG_H
X
/* Define if you have the <stdlib.h> header file.  */
#undef HAVE_STDLIB_H
X
/* Define if you have the <string.h> header file.  */
#undef HAVE_STRING_H
X
/* Define if you have the <sys/param.h> header file.  */
#undef HAVE_SYS_PARAM_H
X
/* Define if you have the <unistd.h> header file.  */
#undef HAVE_UNISTD_H
SHAR_EOF
chmod 0664 bcs-2.0/include/config.h.in ||
echo 'restore of bcs-2.0/include/config.h.in failed'
Wc_c="`wc -c < 'bcs-2.0/include/config.h.in'`"
test 2034 -eq "$Wc_c" ||
	echo 'bcs-2.0/include/config.h.in: original size 2034, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/include/bcs.h ==============
if test -f 'bcs-2.0/include/bcs.h' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/include/bcs.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/include/bcs.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/include/bcs.h' &&
/* 
X * $Id: bcs.h,v 1.34 1994/03/07 21:47:41 qjb Exp $
X * $Source: /local/tmp/bcs-2.0/include/RCS/bcs.h,v $
X * $Author: qjb $
X *
X * Copyright (C) 1994  E. Jay Berkenbilt
X * 
X * This file is part of BCS.  BCS may be distributed according to the terms
X * of the General Public License and/or the Artistic License.  See the
X * `COPYING' and `Artistic' files with the source distribution for details.
X * This notice must be kept intact when this file is distributed.
X *
X * This is the header file for BCS.  It contains information shared by
X * all source files.
X */
X
#ifndef __BCS_H__
#define __BCS_H__
X
#if !defined(lint) && !defined(CODECENTER) || defined(RCS_HDRS)
/* Define a static function and call it.  No warnings this way. */
static void rcsid_bcs_h(char *s)
{rcsid_bcs_h("@(#)$Id: bcs.h,v 1.34 1994/03/07 21:47:41 qjb Exp $");}
#endif /* !lint && !CODECENTER || RCS_HDRS */
X
/* This must be first */
#include "common.h"
X
#include "flexlist.h"
X
/* Filename path separator */
#define PATH_SEP_CHAR '/'
#define PATH_SEP_STR "/"
X
/* Return statuses */
#define BCS_SUCCESS	  0	/* must be defined as zero */
#define BCS_ERR_USAGE	  1
#define BCS_ERR_USER	  2
#define BCS_ERR_MEMORY 	  3
#define BCS_ERR_SYSTEM	  4
#define BCS_ERR_INTERNAL  5
#define BCS_ERR_PARTIAL	  6
X
/* Debugging support */ 
#define DEBUG_ENV		"DEBUG_BCS"
#define BCS_DEBUG_LOGIC 	(1 << 1)
#define BCS_DEBUG_TRACE 	(1 << 2)
#define BCS_DEBUG_VERBOSE	(1 << 3)
#define BCS_DEBUG_PATH		(1 << 4)
X
FL_DEFINE(bcs_stringlist_rec, bcs_stringlist, char *);
X
typedef enum { which_uninitialized, in_none,
X		   in_baseline, in_staging } bcs_which;
X
typedef struct {
X    char *user_path;
X    char *can_path;
X    int ino;
X    int dev;
} bcs_path_info;
X
typedef struct bcs_baseline_info_rec {
X    bcs_path_info path;
X    char *cm_name;
X    int secure;
X    bcs_stringlist unimp_warn_suffixes;
} *bcs_baseline_info;
X    
typedef struct bcs_staging_info_rec {
X    bcs_path_info path;
X    char *bl_path;
} *bcs_staging_info;
X
X
FL_DEFINE(bcs_baseline_rec, bcs_baseline, bcs_baseline_info);
FL_DEFINE(bcs_staging_rec, bcs_staging, bcs_staging_info);
X
/* State */
typedef struct bcs_obj_rec {
X    char *whoami;		/* how this program was invoked */
#ifdef DEBUG
X    int debug_flags;		/* what type of debugging we are using */
#endif
X    bcs_baseline baseline;	/* paths to baseline */
X    bcs_staging staging;	/* paths to staging area */
X    struct bcs_cm_info_rec *cm;	/* info for current CM package */
X    int silent;			/* don't print diagnostic messages */
X    int recursive;		/* whether directory operations are recursive */
X    int no_action;		/* true if we are not taking any action */
} *bcs_obj_type;
X
typedef void (*usage_type)(char *);
X  
/*
X * File information structures
X */
X  
/* Opaque type */
typedef struct bcs_file_info_rec *bcs_file_info;
X
FL_DEFINE(bcs_file_info_list_rec, bcs_file_info_list, bcs_file_info);
X
typedef enum { us_negative, us_ask, us_affirmative } unstage_param_type;
X
/* Callback for bcs_examine_dir */
typedef void (*bcs_ed_callback)(bcs_obj_type, bcs_file_info, void *);
X
/* Must be after above definitions */
#include "cm.h"
X
/* Function prototypes */
X
/* file_info.c */
int bcs_examine_dir(bcs_obj_type, char *, int, bcs_ed_callback, void *);
bcs_file_info bcs_get_file_info(bcs_obj_type, char *);
void bcs_print_file_info(bcs_obj_type, bcs_file_info);
char *fi_user_path(bcs_obj_type, bcs_file_info);
int fi_important(bcs_obj_type, bcs_file_info);
int fi_is_staged(bcs_obj_type, bcs_file_info);
int fi_isdir(bcs_obj_type, bcs_file_info);
X
/* init.c */
/* args: &bcs_obj, &argc, argv */
void bcs_print_standard_opts(void);
void bcs_start(bcs_obj_type *, int *, char *[], usage_type);
X
/* path.c */
int bcs_isbldir(bcs_obj_type, char *, struct stat *, int *, bcs_which *);
int bcs_isdir(bcs_obj_type, char *);
int bcs_islink(bcs_obj_type, char *);
void bcs_get_bl_index(bcs_obj_type, char *, int *, bcs_which *);
X
/* staging.c */
int bcs_sync_staging(bcs_obj_type, char *, int, int);
int bcs_stage(bcs_obj_type, char *, int);
int bcs_unstage(bcs_obj_type, char *, unstage_param_type);
int bcs_update_bl(bcs_obj_type, char *);
X
/* util.c */
void bcs_message(bcs_obj_type, FILE *, const char *, ...)
#ifdef __GNUC__
__attribute__ ((format (printf, 3, 4)));
#else
;
#endif /* __GNUC__ */
X
#ifdef DEBUG
#define DPRINT(x) bcs_dprint x
void bcs_dprint(bcs_obj_type, int, const char *, ...)
#ifdef __GNUC__
__attribute__ ((format (printf, 3, 4)));
#else
;
#endif /* __GNUC__ */
#else
#define DPRINT(x)
#endif /* DEBUG */
X
void bcs_strip_dir_path(char *);
X
#endif /* __BCS_H__ */
SHAR_EOF
chmod 0444 bcs-2.0/include/bcs.h ||
echo 'restore of bcs-2.0/include/bcs.h failed'
Wc_c="`wc -c < 'bcs-2.0/include/bcs.h'`"
test 4556 -eq "$Wc_c" ||
	echo 'bcs-2.0/include/bcs.h: original size 4556, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/include/cm.h ==============
if test -f 'bcs-2.0/include/cm.h' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/include/cm.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/include/cm.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/include/cm.h' &&
/* 
X * $Id: cm.h,v 1.13 1994/03/07 21:47:41 qjb Exp $
X * $Source: /local/tmp/bcs-2.0/include/RCS/cm.h,v $
X * $Author: qjb $
X *
X * Copyright (C) 1994  E. Jay Berkenbilt
X * 
X * This file is part of BCS.  BCS may be distributed according to the terms
X * of the General Public License and/or the Artistic License.  See the
X * `COPYING' and `Artistic' files with the source distribution for details.
X * This notice must be kept intact when this file is distributed.
X *
X * Header file for cm implementations
X */
X
#ifndef __BCS_CM_H__
#define __BCS_CM_H__
X
#if !defined(lint) && !defined(CODECENTER) || defined(RCS_HDRS)
/* Define a static function and call it.  No warnings this way. */
static void rcsid_bcs_cm_h(char *s)
{rcsid_bcs_cm_h("@(#)$Id: cm.h,v 1.13 1994/03/07 21:47:41 qjb Exp $");}
#endif /* !lint && !CODECENTER || RCS_HDRS */
X
/* Args: bcs object, argv for command.  Returns a list of file names
X * from the arguments */
typedef bcs_stringlist (*cm_fileargtype)(bcs_obj_type, char *[]);
X
/* Args: bcs object, filename.  Returns TRUE or FALSE */
typedef int (*cm_haslog_type)(bcs_obj_type, char *);
X
/* Args: bcs object, filename.  Returns TRUE or FALSE */
typedef int (*cm_locked_type)(bcs_obj_type, char *);
X
/* Args: bcs object, filename.  Returns TRUE or FALSE */
typedef int (*cm_uptodate_type)(bcs_obj_type, char *);
X
/* Args: bcs object, fileame.  Returns TRUE if successful or FALSE otherwise */
typedef int (*cm_update_bl_type)(bcs_obj_type, bcs_file_info);
X
/* Args: bcs object, bl filename, st filename.  Returns TRUE or FALSE */
typedef int (*cm_register_type)(bcs_obj_type, char *, char *);
X
typedef enum { cm_checkout, cm_checkin } cm_command_type;
X
typedef struct {
X    char *name;			/* name of command for bcs */
X    char *fullcmd;		/* full path of command */
X    cm_command_type cmd_type;	/* what kind of command this is */
X    cm_fileargtype get_file_args; /* fn to get filename args */
} cm_command;
X
typedef enum { cm_none, cm_file, cm_dir } cm_file_type;
X
typedef struct {
X    char *path;
X    cm_file_type file_type;
} cm_precious;
X
typedef struct bcs_cm_info_rec {
X    char *name;			/* name of package */
X    cm_command *cmds;		/* list of supported commands */
X    cm_precious *precious_files; /* files needed for shared CM logs */
X    cm_haslog_type haslog;	/* tells whether a file has a log */
X    cm_locked_type locked;	/* tells whether a file is locked */
X    cm_uptodate_type uptodate;	/* tells whether a file is up-to-date */
X    cm_update_bl_type update_bl; /* update the baseline */
X    cm_register_type register_file; /* create a new file */
} bcs_cm_info;
X
/* Function Prototypes */
/* cm.c */
void cm_register(bcs_obj_type, bcs_cm_info *);
void cm_print_cm_packages(bcs_obj_type);
void cm_use(bcs_obj_type, char *);
int cm_is_precious(bcs_obj_type, char *);
int cm_haslog(bcs_obj_type, char *);
int cm_locked(bcs_obj_type, char *);
int cm_uptodate(bcs_obj_type, char *);
int cm_update_bl(bcs_obj_type, bcs_file_info);
int cm_register_file(bcs_obj_type, char *);
int cm_eligible(bcs_obj_type, cm_command_type, bcs_stringlist);
int cm_run_command(bcs_obj_type, cm_command *, char *[]);
cm_command *cm_lookup_command(bcs_obj_type, char *);
X
/* rcs_cm.c */
void cm_register_rcs(bcs_obj_type);
X
/* sccs_cm.c */
void cm_register_sccs(bcs_obj_type);
X
#endif /* __BCS_CM_H__ */
SHAR_EOF
chmod 0444 bcs-2.0/include/cm.h ||
echo 'restore of bcs-2.0/include/cm.h failed'
Wc_c="`wc -c < 'bcs-2.0/include/cm.h'`"
test 3311 -eq "$Wc_c" ||
	echo 'bcs-2.0/include/cm.h: original size 3311, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/include/common.h ==============
if test -f 'bcs-2.0/include/common.h' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/include/common.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/include/common.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/include/common.h' &&
/* 
X * $Id: common.h,v 1.4 1994/03/07 21:47:41 qjb Exp $
X * $Source: /local/tmp/bcs-2.0/include/RCS/common.h,v $
X * $Author: qjb $
X *
X * Copyright (C) 1994  E. Jay Berkenbilt
X * 
X * This file is part of BCS.  BCS may be distributed according to the terms
X * of the General Public License and/or the Artistic License.  See the
X * `COPYING' and `Artistic' files with the source distribution for details.
X * This notice must be kept intact when this file is distributed.
X *
X * This header file includes header files and defines macros
X * common to all of BCS.  It uses the information generated
X * by autoconf.
X */
X
#ifndef __COMMON_H__
#define __COMMON_H__
X
#if !defined(lint) && !defined(CODECENTER) || defined(RCS_HDRS)
/* Define a static function and call it.  No warnings this way. */
static void rcsid_common_h(char *s)
{rcsid_common_h("@(#)$Id: common.h,v 1.4 1994/03/07 21:47:41 qjb Exp $");}
#endif /* !lint && !CODECENTER || RCS_HDRS */
X
/* This must be first */
#include "config.h"
X
/*
X * Set things up here so that other files don't have to be cluttered with
X * checking for autoconf definitions.
X */
X
#include <stdio.h>
#include <sys/types.h>
#include <ctype.h>
X
#if STDC_HEADERS || HAVE_STDLIB_H
# include <stdlib.h>
#endif
X
#if STDC_HEADERS || HAVE_STDARG_H
# include <stdarg.h>
# define USE_VARARGS 0
#else
# include <varargs.h>
# define USE_VARARGS 1
#endif
X
#if HAVE_STRING_H
# include <string.h>
#else
# include <strings.h>
# define strrchr rindex
# define strchr index
#endif
X
#if (! STDC_HEADERS) && HAVE_MEMORY_H
# include <memory.h>
#endif
X
#if HAVE_MEMORY_H || STDC_HEADERS
# define mem_zero(s, l) memset(s, 0, l)
#else
# define mem_zero(s, l) bzero(s, l)
#endif
X
#if HAVE_UNISTD_H
# include <unistd.h>
#endif
X
#if HAVE_SYS_PARAM_H
# include <sys/param.h>
#else
# ifndef MAXPATHNEN
#  define MAXPATHLEN 1024
# endif
#endif
X
/* unistd.h defines _POSIX_VERSION on POSIX.1 systems.  */
#if defined(DIRENT) || defined(_POSIX_VERSION)
# include <dirent.h>
#else /* not (DIRENT or _POSIX_VERSION) */
# define dirent direct
# ifdef SYSNDIR
#  include <sys/ndir.h>
# endif /* SYSNDIR */
# ifdef SYSDIR
#  include <sys/dir.h>
# endif /* SYSDIR */
# ifdef NDIR
#  include <ndir.h>
# endif /* NDIR */
#endif /* not (DIRENT or _POSIX_VERSION) */
X
#if ! HAVE_GETCWD
# define getcwd(s, l) getwd(s)
#endif
X
#include <sys/stat.h>
#ifdef STAT_MACROS_BROKEN
# ifdef S_ISDIR
#  undef S_ISDIR
# endif
# ifdef S_ISLNK
#  undef S_ISLNK
# endif
# define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
# define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
#endif
X
#include <errno.h>
#if HAVE_STRERROR
# define error_string(e) strerror(e)
#else
# if HAVE_SYS_ERRLIST || HAVE__SYS_ERRLIST
#  ifndef SYS_ERRLIST_DECLARED
X    extern char *sys_errlist[];
#  endif
#  define error_string(e) sys_errlist[e]
# else
#  error "Sorry, don't know how to define error_string."
# endif
#endif
X
#ifndef ERRNO_DECLARED
extern int errno;
#endif
X
#ifndef FREE_DECLARED
extern void free(void *);
#endif
X
#ifndef TRUE
#define TRUE 1
#endif
X
#ifndef FALSE
#define FALSE 0
#endif
X
#endif /* __COMMON_H__ */
SHAR_EOF
chmod 0444 bcs-2.0/include/common.h ||
echo 'restore of bcs-2.0/include/common.h failed'
Wc_c="`wc -c < 'bcs-2.0/include/common.h'`"
test 3068 -eq "$Wc_c" ||
	echo 'bcs-2.0/include/common.h: original size 3068, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/include/flexlist.h ==============
if test -f 'bcs-2.0/include/flexlist.h' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/include/flexlist.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/include/flexlist.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/include/flexlist.h' &&
/* 
X * $Id: flexlist.h,v 1.5 1994/03/07 21:47:41 qjb Exp $
X * $Source: /local/tmp/bcs-2.0/include/RCS/flexlist.h,v $
X * $Author: qjb $
X *
X * Copyright (C) 1994  E. Jay Berkenbilt
X * 
X * This file is part of BCS.  BCS may be distributed according to the terms
X * of the General Public License and/or the Artistic License.  See the
X * `COPYING' and `Artistic' files with the source distribution for details.
X * This notice must be kept intact when this file is distributed.
X *
X * Header file for flexlist implementation
X */
X
#ifndef __FLEXLIST_H__
#define __FLEXLIST_H__
X
#if !defined(lint) && !defined(CODECENTER) || defined(RCS_HDRS)
/* Define a static function and call it.  No warnings this way. */
static void rcsid_flexlist_h(char *s)
{rcsid_flexlist_h("@(#)$Id: flexlist.h,v 1.5 1994/03/07 21:47:41 qjb Exp $");}
#endif /* !lint && !CODECENTER || RCS_HDRS */
X
#ifndef TRUE
#define TRUE 1
#endif
X
#ifndef FALSE
#define FALSE 0
#endif
X
#define FLEX_MAX_INIT 4
X
typedef void *fl_pointer;
X
/*
X * This is our half-hearted attempt at handling type parameterization
X * for the flexlist structure.
X */
X
#define FL_DEFINE(rn, tn, t) \
X    typedef struct rn {	\
X	int max;	\
X	int n;		\
X	t *data;	\
X    } *tn
X
FL_DEFINE(flex_list_rec, flex_list, fl_pointer);
X
typedef void (*fl_free_fn_type)(void *);
X
flex_list fl_new_flex_list(char *);
void fl_delete_flex_list(flex_list *, fl_free_fn_type);
void fl_add_to_tail(char *, flex_list, fl_pointer);
void fl_delete_range(char *, flex_list, int, int, fl_free_fn_type);
void fl_insert(char *, flex_list, int, fl_pointer);
X
#endif /* __FLEXLIST_H__ */
SHAR_EOF
chmod 0444 bcs-2.0/include/flexlist.h ||
echo 'restore of bcs-2.0/include/flexlist.h failed'
Wc_c="`wc -c < 'bcs-2.0/include/flexlist.h'`"
test 1588 -eq "$Wc_c" ||
	echo 'bcs-2.0/include/flexlist.h: original size 1588, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/include/patchlevel.h ==============
if test -f 'bcs-2.0/include/patchlevel.h' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/include/patchlevel.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/include/patchlevel.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/include/patchlevel.h' &&
/* 
X * $Id: patchlevel.h,v 1.20 1994/03/07 21:41:51 qjb Exp $
X * $Source: /local/tmp/bcs-2.0/include/RCS/patchlevel.h,v $
X * $Author: qjb $
X *
X */
X
#ifndef __BCS_PATCHLEVEL_H__
#define __BCS_PATCHLEVEL_H__
X
#if !defined(lint) && !defined(CODECENTER) || defined(RCS_HDRS)
char *rcsid_bcs_patchlevel_h = "@(#)$Id: patchlevel.h,v 1.20 1994/03/07 21:41:51 qjb Exp $";
#endif /* !lint && !CODECENTER || RCS_HDRS */
X
#define PATCHLEVEL 0
X
/* define this to 1 for a real release or 0 when between releases */
#define RELEASE 1
X
#endif /* __BCS_PATCHLEVEL_H__ */
SHAR_EOF
chmod 0444 bcs-2.0/include/patchlevel.h ||
echo 'restore of bcs-2.0/include/patchlevel.h failed'
Wc_c="`wc -c < 'bcs-2.0/include/patchlevel.h'`"
test 555 -eq "$Wc_c" ||
	echo 'bcs-2.0/include/patchlevel.h: original size 555, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/include/version.h ==============
if test -f 'bcs-2.0/include/version.h' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/include/version.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/include/version.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/include/version.h' &&
/* 
X * $Id: version.h,v 1.4 1994/03/07 21:42:19 qjb Exp $
X * $Source: /local/tmp/bcs-2.0/include/RCS/version.h,v $
X * $Author: qjb $
X *
X */
X
#ifndef __BCS_VERSION_H__
#define __BCS_VERSION_H__
X
#if !defined(lint) && !defined(CODECENTER) || defined(RCS_HDRS)
char *rcsid_bcs_version_h = "@(#)$Id: version.h,v 1.4 1994/03/07 21:42:19 qjb Exp $";
#endif /* !lint && !CODECENTER || RCS_HDRS */
X
#include "patchlevel.h"
X
#define MAJOR_VERSION 2
#define MINOR_VERSION 0
#define EXTRA_VERSION ""
X
#endif /* __BCS_VERSION_H__ */
SHAR_EOF
chmod 0444 bcs-2.0/include/version.h ||
echo 'restore of bcs-2.0/include/version.h failed'
Wc_c="`wc -c < 'bcs-2.0/include/version.h'`"
test 521 -eq "$Wc_c" ||
	echo 'bcs-2.0/include/version.h: original size 521, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/lib/Makefile ==============
if test ! -d 'bcs-2.0/lib'; then
    echo 'x - creating directory bcs-2.0/lib'
    mkdir 'bcs-2.0/lib'
fi
if test -f 'bcs-2.0/lib/Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/lib/Makefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/lib/Makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/lib/Makefile' &&
#
# $Id: Makefile,v 1.16 1994/02/12 01:08:22 qjb Exp $
# $Source: /local/tmp/bcs-2.0/lib/RCS/Makefile,v $
# $Author: qjb $
#
X
SHELL = /bin/sh
X
LIBSRCS = \
X	cm.c \
X	file_info.c \
X	flexlist.c \
X	init.c \
X	path.c \
X	rcs_cm.c \
X	sccs_cm.c \
X	staging.c \
X	util.c
X
SRCS = $(LIBSRCS) 
X
# For some people, this type of pattern matching line is the only thing that
# prevents the native make from working.  Instead, repeat the list of
# sources.
# OBJS = $(SRCS:%.c=%.o)
OBJS = 	cm.o \
X	file_info.o \
X	flexlist.o \
X	init.o \
X	path.o \
X	rcs_cm.o \
X	sccs_cm.o \
X	staging.o \
X	util.o
X
LIB = libbcs.a
LIBS = -lbcs
X
all: $(LIB) 
X
rcs_cm.o rcs_cm.d: rcs_paths.h
X
sccs_cm.o sccs_cm.d: sccs_paths.h
X
rcs_paths.h: make_rcs_h
X	$(RM) rcs_paths.h
X	sh make_rcs_h
X
sccs_paths.h: make_sccs_h
X	$(RM) sccs_paths.h
X	sh make_sccs_h
X
builddate.h:
X	$(RM) builddate.h
X	echo \#define BUILDDATE \"`date`\" > builddate.h
X
libbcs.a: $(OBJS)
X	$(RM) $@
X	$(AR) $(AR_ARGS) $@ $(OBJS) 
X	$(RANLIB) $@
X
clean::
X	$(RM) $(LIB) rcs_paths.h sccs_paths.h builddate.h
X
include ../make/rules.mk
X
LIB_HDRS = bcs_p.h 
X
LIB_DEPS = $(COMMON_HDRS) $(LIB_HDRS)
X
cm.o: cm.c $(LIB_DEPS)
file_info.o: file_info.c $(LIB_DEPS) file_info.h 
flexlist.o: flexlist.c $(LIB_DEPS)
init.o: init.c $(LIB_DEPS) \
X	../include/version.h ../include/patchlevel.h builddate.h
path.o: path.c $(LIB_DEPS) path.h 
rcs_cm.o: rcs_cm.c $(LIB_DEPS) rcs_cm.h rcs_paths.h 
sccs_cm.o: sccs_cm.c $(LIB_DEPS) sccs_cm.h sccs_paths.h 
staging.o: staging.c $(LIB_DEPS)
util.o: util.c $(LIB_DEPS)
SHAR_EOF
chmod 0444 bcs-2.0/lib/Makefile ||
echo 'restore of bcs-2.0/lib/Makefile failed'
Wc_c="`wc -c < 'bcs-2.0/lib/Makefile'`"
test 1507 -eq "$Wc_c" ||
	echo 'bcs-2.0/lib/Makefile: original size 1507, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/lib/bcs_p.h ==============
if test -f 'bcs-2.0/lib/bcs_p.h' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/lib/bcs_p.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/lib/bcs_p.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/lib/bcs_p.h' &&
/* 
X * $Id: bcs_p.h,v 1.8 1994/03/07 21:47:41 qjb Exp $
X * $Source: /local/tmp/bcs-2.0/lib/RCS/bcs_p.h,v $
X * $Author: qjb $
X *
X * Copyright (C) 1994  E. Jay Berkenbilt
X * 
X * This file is part of BCS.  BCS may be distributed according to the terms
X * of the General Public License and/or the Artistic License.  See the
X * `COPYING' and `Artistic' files with the source distribution for details.
X * This notice must be kept intact when this file is distributed.
X *
X * This is the private header file for BCS.  It contains information
X * shared by all source files in the library.  Public routines (those
X * intended to be called outside the library) are defined in bcs.h.
X */
X
#ifndef __BCS_P_H__
#define __BCS_P_H__
X
#if !defined(lint) && !defined(CODECENTER) || defined(RCS_HDRS)
/* Define a static function and call it.  No warnings this way. */
static void rcsid_bcs_p_h(char *s)
{rcsid_bcs_p_h("@(#)$Id: bcs_p.h,v 1.8 1994/03/07 21:47:41 qjb Exp $");}
#endif /* !lint && !CODECENTER || RCS_HDRS */
X
#include "bcs.h"
X
/* Environment Variables */
#define STAGING_ENV	"STAGING"
#define BASELINE_ENV	"BASELINE"
X
/*
X * Files used internally by BCS.
X *
X **********************************************************************
X *
X * NOTE: If a file is added here, make sure its importance is handled
X * as a special case in file_info.c if that is desired.
X *
X **********************************************************************
X *
X * These files should have names <= 14 characters for the benefit of
X * those file systems or versions of UNIX that don't have long
X * filenames... 
X */
#define BL_PATH		".baseline_path"
#define BL_CONF		".baseline_conf"
#define IMPFILE		".important"
#define UNIMPFILE	".unimportant"
#define AUTOSTAGE	".auto_stage"
#define NOSTAGE		".no_stage"
#define NOWARN		".unimp_nowarn"
X
/*
X * File information structures
X */
X  
typedef enum {
X    stage_param_type_uninitialized,
X    fi_normal,			/* no special constraints */
X    fi_auto_stage,		/* file is automatically staged with parent */
X    fi_no_stage,		/* file can never be staged */
X    fi_no_mirror		/* file cannot appear in the staging area */
} stage_param_type;
X
typedef enum {
X    link_type_uninitialized,
X    fi_not_link,
X    fi_dangling,		/* link to nowhere */
X    fi_to_baseline,		/* link from staging to baseline counterpart */
X    fi_internal,		/* link dest within same "which" as link */
X    fi_external			/* link dest has different "which" as link */
} bcs_link_type;
X
/* Path caching information */
/* Opaque type */
typedef struct path_cache_rec *path_cache;
X
/* Function prototypes */
X
/* file_info.c */
void bcsi_delete_file_info(bcs_file_info);
char *bcsi_calc_bl_path(bcs_obj_type, int, char *);
void bcsi_remove_file_info(bcs_obj_type, char *);
char *fi_clean_path(bcs_obj_type, bcs_file_info);
char *fi_rel_path(bcs_obj_type, bcs_file_info);
char *fi_cont_path(bcs_obj_type, bcs_file_info);
char *fi_can_path(bcs_obj_type, bcs_file_info);
int fi_index(bcs_obj_type, bcs_file_info);
bcs_which fi_which(bcs_obj_type, bcs_file_info);
bcs_link_type fi_link_type(bcs_obj_type, bcs_file_info);
char *fi_linkpath(bcs_obj_type, bcs_file_info);
char *fi_ult_linkpath(bcs_obj_type, bcs_file_info);
bcs_file_info fi_ult_link_info(bcs_obj_type, bcs_file_info);
int fi_unimp_warn(bcs_obj_type, bcs_file_info);
stage_param_type fi_stage_params(bcs_obj_type, bcs_file_info);
bcs_stringlist *fi_lists(bcs_obj_type, bcs_file_info);
int fi_has_baseline_counterpart(bcs_obj_type, bcs_file_info);
char *fi_bl_path(bcs_obj_type, bcs_file_info);
bcs_file_info fi_bl_info(bcs_obj_type, bcs_file_info);
int fi_writable(bcs_obj_type, bcs_file_info);
X
/* path.c */
int bcsi_exists(bcs_obj_type, char *);
int bcsi_readable(bcs_obj_type, char *);
int bcsi_paths_eq(bcs_obj_type, char *, char *);
path_cache bcsi_path_info_from_parent(bcs_obj_type, char *, path_cache);
path_cache bcsi_get_path_info(bcs_obj_type, char *);
int bcsi_lstat(bcs_obj_type, char *, struct stat *);
char *pc_can_path(bcs_obj_type, path_cache);
bcs_file_info pc_file_info(bcs_obj_type, path_cache);
struct stat *pc_statbuf(bcs_obj_type, path_cache);
void pc_get_bl_index(bcs_obj_type, path_cache, int *, bcs_which *);
char *pc_linkpath(bcs_obj_type, path_cache);
char *pc_lastcomp(bcs_obj_type, path_cache);
int pc_isdir(bcs_obj_type, path_cache);
int pc_islink(bcs_obj_type, path_cache);
path_cache pc_parent(bcs_obj_type, path_cache);
void pc_insert_file_info(bcs_obj_type, path_cache, bcs_file_info);
void pc_remove_file_info(bcs_obj_type, path_cache);
void pc_remove_path_info(bcs_obj_type, path_cache);
path_cache pc_ult_link_info(bcs_obj_type, path_cache);
X
/* staging.c */
int bcsi_sync_file(bcs_obj_type, bcs_file_info, int);
int bcsi_stageable(bcs_obj_type, char *, bcs_stringlist *);
X
/* util.c */
void *bcsi_safe_malloc(char *, int);
char *bcsi_safe_strdup(char *, char *);
int bcsi_safe_strcat(char *, char *, int);
void bcsi_concat_paths(char *, char *, char *);
void bcsi_append_last_component(char *, char *);
void bcsi_resolve_readlink(char *, char *, char *);
int bcsi_in_stringlist(char *, bcs_stringlist);
bcs_stringlist bcsi_file_to_stringlist(bcs_obj_type, char *);
int bcsi_yn(char *);
int bcsi_read_directory_entries(bcs_obj_type, char *, bcs_stringlist *);
void bcsi_split_string(bcs_obj_type, bcs_stringlist, char *);
int bcsi_create_empty_file(bcs_obj_type, char *, int);
int bcsi_remove_file(bcs_obj_type bcs_obj, char *path);
int bcsi_make_link(bcs_obj_type, char *, char *);
int bcsi_make_directory(bcs_obj_type, char *);
int bcsi_copy_file(bcs_obj_type, char *, char *);
X
#endif /* __BCS_P_H__ */
SHAR_EOF
chmod 0444 bcs-2.0/lib/bcs_p.h ||
echo 'restore of bcs-2.0/lib/bcs_p.h failed'
Wc_c="`wc -c < 'bcs-2.0/lib/bcs_p.h'`"
test 5574 -eq "$Wc_c" ||
	echo 'bcs-2.0/lib/bcs_p.h: original size 5574, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/lib/cm.c ==============
if test -f 'bcs-2.0/lib/cm.c' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/lib/cm.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/lib/cm.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/lib/cm.c' &&
/* 
X * $Id: cm.c,v 1.20 1994/03/07 21:47:41 qjb Exp $
X * $Source: /local/tmp/bcs-2.0/lib/RCS/cm.c,v $
X * $Author: qjb $
X *
X * Copyright (C) 1994  E. Jay Berkenbilt
X * 
X * This file is part of BCS.  BCS may be distributed according to the terms
X * of the General Public License and/or the Artistic License.  See the
X * `COPYING' and `Artistic' files with the source distribution for details.
X * This notice must be kept intact when this file is distributed.
X *
X * This file implements the basic functionality of supporting
X * different configuration management systems.
X */
X
#if !defined(lint) && !defined(CODECENTER) || defined(RCS_HDRS)
/* Define a static function and call it.  No warnings this way. */
static void rcsid(char *s)
{rcsid("@(#)$Id: cm.c,v 1.20 1994/03/07 21:47:41 qjb Exp $");}
#endif /* !lint && !CODECENTER || RCS_HDRS */
X
#include "bcs_p.h"
X
FL_DEFINE(cm_info_list_rec, cm_info_list, bcs_cm_info *);
X
static cm_info_list registered_cm;
static int cm_inited = FALSE;
X
X
/*
X * PRIVATE FUNCTIONS
X */
void cm_init(bcs_obj_type bcs_obj)
{
X    registered_cm = (cm_info_list) fl_new_flex_list(bcs_obj->whoami);
X    bcs_obj->cm = NULL;
X    cm_inited = TRUE;
}
X
X
/*
X * PUBLIC FUNCTIONS
X */
X
/*
X * Register a given CM package.
X */
void cm_register(bcs_obj_type bcs_obj, bcs_cm_info *cm_info)
{
X    int i;
X
X    if (! cm_inited)
X	cm_init(bcs_obj);
X
X    /*
X     * Make sure that we don't already have a CM package by this name
X     * registered
X     */
X    for (i = 0; i < registered_cm->n; i++)
X    {
X	if (strcmp(registered_cm->data[i]->name, cm_info->name) == 0)
X	{
X	    bcs_message(bcs_obj, stderr,
X			"can't register two CM packages named %s; exiting",
X			cm_info->name);
X	    exit(BCS_ERR_USAGE);
X	}
X    }
X
X    /* Add this CM package to the list of known packages */
X    DPRINT((bcs_obj, BCS_DEBUG_VERBOSE, "registering CM package %s",
X	    cm_info->name));
X    fl_add_to_tail(bcs_obj->whoami, (flex_list) registered_cm, cm_info);
}
X
void cm_print_cm_packages(bcs_obj_type bcs_obj)
{
X    int i;
X
X    if (! cm_inited)
X	cm_init(bcs_obj);
X
X    if (registered_cm->n > 0)
X    {
X	printf("Supported configuration management packages: ");
X	for (i = 0; i < registered_cm->n; i++)
X	{
X	    printf("%s%s", registered_cm->data[i]->name,
X		   (i == (registered_cm->n - 1)) ? "\n" : ", ");
X	}
X    }
X    else
X    {
X	printf("No supported configuration management packages.\n");
X    }
}
X
/*
X * Set the current CM package
X */
void cm_use(bcs_obj_type bcs_obj, char *name)
{
X    int i;
X    int found = FALSE;
X
X    if (! cm_inited)
X	cm_init(bcs_obj);
X
X    /*
X     * Look up the named package and install.
X     */
X    for (i = 0; (i < registered_cm->n) && (! found); i++)
X    {
X	if (strcmp(registered_cm->data[i]->name, name) == 0)
X	{
X	    found = TRUE;
X	    bcs_obj->cm = registered_cm->data[i];
X	}
X    }
X
X    if (! found)
X    {
X	bcs_message(bcs_obj, stderr,
X		    "no CM package named %s is registered; exiting", name);
X	exit(BCS_ERR_USAGE);
X    }
}
X
/*
X * CM ENTRY POINTS.  These can't be called before initialization
X */
X
cm_command *cm_lookup_command(bcs_obj_type bcs_obj, char *cmd_str)
{
X    cm_command *cmd;
X
X    for (cmd = bcs_obj->cm->cmds; cmd->name; cmd++)
X    {
X	if (strcmp(cmd->name, cmd_str) == 0)
X	    return cmd;
X    }
X
X    return NULL;
}
X
int cm_is_precious(bcs_obj_type bcs_obj, char *filename)
{
X    cm_precious *precious;
X    char *lastcomp;
X
X    if ((lastcomp = strrchr(filename, PATH_SEP_CHAR)) == NULL)
X	lastcomp = filename;
X    else
X	lastcomp++;
X
X    for (precious = bcs_obj->cm->precious_files;
X	 precious->path; precious++)
X    {
X	if (strcmp(lastcomp, precious->path) == 0)
X	    return TRUE;
X    }
X
X    return FALSE;
}
X
int cm_haslog(bcs_obj_type bcs_obj, char *filename)
{
X    return (*(bcs_obj->cm->haslog))(bcs_obj, filename);
}
X
int cm_locked(bcs_obj_type bcs_obj, char *filename)
{
X    return (*(bcs_obj->cm->locked))(bcs_obj, filename);
}
X
int cm_uptodate(bcs_obj_type bcs_obj, char *filename)
{
X    return (*(bcs_obj->cm->uptodate))(bcs_obj, filename);
}
X
int cm_update_bl(bcs_obj_type bcs_obj, bcs_file_info file_info)
{
X    return (*(bcs_obj->cm->update_bl))(bcs_obj, file_info);
}
X
int cm_register_file(bcs_obj_type bcs_obj, char *filename)
{
X    char workpath[MAXPATHLEN];
X    char bl_path[MAXPATHLEN];
X    bcs_file_info file_info;
X    char *p1 = NULL, *p2 = NULL;
X    int status = BCS_SUCCESS;
X
X    if (filename[0] == PATH_SEP_CHAR)
X	strcpy(workpath, filename);
X    else
X	bcsi_concat_paths(workpath, ".", filename);
X
X    /* Make sure this path would be under a staging area. */
X    p2 = NULL;
X    do
X    {
X	file_info = bcs_get_file_info(bcs_obj, workpath);
X	if (file_info == NULL)
X	{
X	    p1 = strrchr(workpath, PATH_SEP_CHAR);
X	    if (p1)
X	    {
X		*p1 = '\0';
X		if (p2)
X		    *p2 = PATH_SEP_CHAR;
X		p2 = p1;
X	    }
X	}
X	else
X	{
X	    if (p2)
X	    {
X		*p2 = PATH_SEP_CHAR;
X		p2++;
X	    }
X	}
X    } while ((! file_info) && p1);
X
X    if (! (file_info && (fi_which(bcs_obj, file_info) == in_staging)))
X    {
X	bcs_message(bcs_obj, stderr,
X		    "can't register %s since it would not be in "
X		    "the staging area.", filename);
X	return BCS_ERR_USER;
X    }
X
X    /*
X     * Figure out what the baseline path to the corresponding file
X     * would be.  p2 points to the part of workpath that is after
X     * the file we found to exist.
X     */
X    strcpy(bl_path, bcs_obj->baseline->data
X	   [fi_index(bcs_obj, file_info)]->path.user_path);
X    if (strlen(fi_rel_path(bcs_obj, file_info)))
X    {
X	strcat(bl_path, PATH_SEP_STR);
X	strcat(bl_path, fi_rel_path(bcs_obj, file_info));
X    }
X    if (p2 && strlen(p2))
X    {
X	strcat(bl_path, PATH_SEP_STR);
X	strcat(bl_path, p2);
X    }
X
X    if (bcsi_exists(bcs_obj, bl_path))
X    {
X	bcs_message(bcs_obj, stderr,
X		    "can't register %s since %s already exists.",
X		    filename, bl_path);
X	return BCS_ERR_USER;
X    }
X
X    if (cm_haslog(bcs_obj, bl_path))
X    {
X	bcs_message(bcs_obj, stderr,
X		    "can't register %s since %s already has a log.",
X		    filename, bl_path);
X	return BCS_ERR_USER;
X    }
X
X    /*
X     * Make the directory that will contain bl_path and the directory
X     * that will contain the staging area file.  It's okay if they
X     * already exist.
X     */
X
X    /*
X     * both workpath bl_path necessarily contain PATH_SEP_CHAR because
X     * bl_path was based upon a baseline directory and workpath
X     * was handled specially above.
X     */
X    if ((p1 = strrchr(bl_path, PATH_SEP_CHAR)) == NULL)
X    {
X	bcs_message(bcs_obj, stderr,
X		    "INTERNAL ERROR in register_file: bl_path (%s) "
X		    "has no %c", bl_path, PATH_SEP_CHAR);
X	abort();
X    }
X    *p1 = '\0';
X    status = bcsi_make_directory(bcs_obj, bl_path);
X    *p1 = PATH_SEP_CHAR;
X    if (status)
X	return status;
X
X    if ((p1 = strrchr(workpath, PATH_SEP_CHAR)) == NULL)
X    {
X	bcs_message(bcs_obj, stderr,
X		    "INTERNAL ERROR in register_file: workpath (%s) "
X		    "has no %c", workpath, PATH_SEP_CHAR);
X	abort();
X    }
X    *p1 = '\0';
X    status = bcsi_make_directory(bcs_obj, workpath);
X    *p1 = PATH_SEP_CHAR;
X    if (status)
X	return status;
X
X    if (bcsi_exists(bcs_obj, filename))
X    {
X	/* Copy the file into the baseline before registering */
X	bcsi_copy_file(bcs_obj, filename, bl_path);
X    }
X
X    status = (*bcs_obj->cm->register_file)(bcs_obj, bl_path, filename);
X    if (status)
X	return status;
X
X    /*
X     * If the does not exist, create it; otherwise, remove its file_info
X     * which would now be out of date (since the importance of the file
X     * has changed as well as whether it is staged, etc.).
X     */
X    if (bcsi_exists(bcs_obj, filename))
X    {
X	bcsi_remove_file_info(bcs_obj, filename);
X    }
X    else
X    {
X	if ((status = bcsi_create_empty_file(bcs_obj, filename, 0644)))
X	    return status;
X    }
X
X    return status;
}
X
int cm_eligible(bcs_obj_type bcs_obj, cm_command_type cmd_type,
X		bcs_stringlist files)
{
X    int i;
X    int result = TRUE;
X    bcs_file_info file_info;
X    char *filename;
X    bcs_stringlist staged_files; /* to keep track of what we staged */
X
X    staged_files = (bcs_stringlist) fl_new_flex_list(bcs_obj->whoami);
X
X    for (i = 0; i < files->n; i++)
X    {
X	/*
X	 * A file is eligible to be checked in or out if it is in the staging
X	 * area, is staged, and has a CM log.
X	 */
X
X	filename = files->data[i];
X	file_info = bcs_get_file_info(bcs_obj, filename);
X	if (file_info == NULL)
X	{
X	    bcs_message(bcs_obj, stderr,
X			"can't check %s in or out since it cannot be found.",
X			filename);
X	    result = FALSE;
X	}
X
X	if (result)
X	{
X	    if (! fi_important(bcs_obj, file_info))
X	    {
X		bcs_message(bcs_obj, stderr,
X			    "can't check %s in or out since it is "
X			    "not important.", filename);
X		result = FALSE;
X	    }
X	}
X
X	if (result)
X	{
X	    if ((! fi_is_staged(bcs_obj, file_info)) &&
X		(cmd_type == cm_checkout))
X	    {
X		/* Try staging this file */
X		if (bcs_stage(bcs_obj, filename, FALSE) == BCS_SUCCESS)
X		{
X		    fl_add_to_tail(bcs_obj->whoami, (flex_list) staged_files,
X				   filename);
X		    /* Reobtain the file info since it just changed */
X		    file_info = bcs_get_file_info(bcs_obj, filename);
X		}
X		else
X		{
X		    bcs_message(bcs_obj, stderr,
X				"can't check %s out since it can't be staged.",
X				filename);
X		    result = FALSE;
X		}
X	    }
X	}
X
X	/*
X	 * Must check this AFTER trying to stage since it could fail
X	 * if the file is indirectly stageable.
X	 */
X	if (result)
X	{
X	    if (fi_which(bcs_obj, file_info) != in_staging)
X	    {
X		bcs_message(bcs_obj, stderr,
X			    "can't check %s in or out since it is "
X			    "not in the staging area.",
X			    filename);
X		result = FALSE;
X	    }
X	}
X
X	if (result)
X	{
X	    if (! fi_is_staged(bcs_obj, file_info))
X	    {
X		bcs_message(bcs_obj, stderr,
X			    "can't check %s in or out since it is not staged.",
X			    filename);
X		result = FALSE;
X	    }
X	}
X
X	if (result)
X	{
X	    if (! cm_haslog(bcs_obj, filename))
X	    {
X		bcs_message(bcs_obj, stderr,
X			    "can't check %s in or out since it does "
X			    "not have a CM log.",
X			    filename);
X		result = FALSE;
X	    }
X	}
X    }
X
X    if (result == FALSE)
X    {
X	int i;
X
X	/* Unstage files we staged */
X	for (i = 0; i < staged_files->n; i++)
X	{
X	    bcs_unstage(bcs_obj, staged_files->data[i], us_negative);
X	}
X    }
X
X    fl_delete_flex_list((flex_list *)&staged_files, NULL);
X
X    return result;
}
X
/*
X * This function expects as argv a complete cm command.  It then
X * runs the command (using an absolute path as obtained from the
X * cm_command structure) and returns a standard BCS error code.
X */
int cm_run_command(bcs_obj_type bcs_obj_type, cm_command *cmd, char *argv[])
{
X    char command[2 * MAXPATHLEN];
X    char **arg;
X
X    /*
X     * Use system() here to avoid hassles of writing wait() code
X     * portably.  This should probably be fixed sometime but isn't
X     * so important since we are using an absolute path...
X     * In addition, realize that fullcmd here may be more than
X     * one word.
X     */
X
X    strcpy(command, cmd->fullcmd);
X
X    for (arg = &argv[1]; *arg; arg++)
X    {
X	strcat(command, " ");
X	strcat(command, *arg);
X    }
X
X    return (system(command) == 0) ? BCS_SUCCESS : BCS_ERR_USER;
}
SHAR_EOF
chmod 0444 bcs-2.0/lib/cm.c ||
echo 'restore of bcs-2.0/lib/cm.c failed'
Wc_c="`wc -c < 'bcs-2.0/lib/cm.c'`"
test 11029 -eq "$Wc_c" ||
	echo 'bcs-2.0/lib/cm.c: original size 11029, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/lib/file_info.c ==============
if test -f 'bcs-2.0/lib/file_info.c' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/lib/file_info.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/lib/file_info.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/lib/file_info.c' &&
/* 
X * $Id: file_info.c,v 1.45 1994/03/14 16:53:44 ejb Exp $
X * $Source: /local/tmp/bcs-2.0/lib/RCS/file_info.c,v $
X * $Author: ejb $
X *
X * Copyright (C) 1994  E. Jay Berkenbilt
X * 
X * This file is part of BCS.  BCS may be distributed according to the terms
X * of the General Public License and/or the Artistic License.  See the
X * `COPYING' and `Artistic' files with the source distribution for details.
SHAR_EOF
true || echo 'restore of bcs-2.0/lib/file_info.c failed'
fi
echo 'End of bcs-2.0 part 1'
echo 'File bcs-2.0/lib/file_info.c is continued in part 2'
echo 2 > _shar_seq_.tmp
exit 0
