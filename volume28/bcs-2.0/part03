Newsgroups: comp.sources.unix
From: ejb@ERA.COM (Jay Berkenbilt)
Subject: v28i004: bcs-2.0 - A Baseline Configuration System, Part03/25
References: <1.764985670.1461@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: ejb@ERA.COM (Jay Berkenbilt)
Posting-Number: Volume 28, Issue 4
Archive-Name: bcs-2.0/part03

#!/bin/sh
# this is bcs.03 (part 3 of bcs-2.0)
# do not concatenate these parts, unpack them in order with /bin/sh
# file bcs-2.0/lib/init.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 3; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping bcs-2.0/lib/init.c'
else
echo 'x - continuing file bcs-2.0/lib/init.c'
sed 's/^X//' << 'SHAR_EOF' >> 'bcs-2.0/lib/init.c' &&
X    {
X	lineno++;
X
X	if (line[strlen(line) - 1] == '\n')
X	    line[strlen(line) - 1] = '\0';
X
X	/*
X	 * Strip off leading and trailing blanks, get rid of comment
X	 * characters.
X	 */
X	if ((p = strchr(line, BL_CONF_COMMENT)) != NULL)
X	    *p = '\0';
X
X	for (p = line + strlen(line); (p > line) && ((! *p) || isspace(*p));
X	     p--);
X	*(p+1) = '\0';
X	for (p = line; *p && isspace(*p); p++);
X	
X	/* skip blank lines */
X	if (strlen(p) == 0)
X	    continue;
X
X	/* Find separator */
X	if ((value = strchr(line, BL_CONF_SEPARATOR)) == NULL)
X	{
X	    value = "";
X	}
X	else
X	{
X	    *value = '\0';
X	    value++;
X	}
X	
X	/* strip trailing blanks off of key and leading off of value */
X	key = p;
X	for (p = key + strlen(key); (p > key) && ((! *p) || isspace(*p));
X	     p--);
X	*(p+1) = '\0';
X	for (; *value && isspace(*value); value++);
X
X	DPRINT((bcs_obj, BCS_DEBUG_LOGIC,
X		"%s, line %d: key: *%s*, value *%s*",
X		filename, lineno, key, value));
X
X	if (strcmp(key, "cm") == 0)
X	{
X	    bl_info->cm_name = bcsi_safe_strdup(bcs_obj->whoami, value);
X	}
X	else if (strcmp(key, "secure") == 0)
X	{
X	    bcs_message(bcs_obj, stderr,
X			"WARNING: secure baseline is not implemented.");
X	    bl_info->secure = TRUE;
X	}
X	else if (strcmp(key, "unimp_warn_suffixes") == 0)
X	{
X	    bcsi_split_string(bcs_obj, bl_info->unimp_warn_suffixes, value);
X	}
X	else
X	{
X	    bcs_message(bcs_obj, stderr,
X			"unrecognized key `%s', line %d of %s",
X			key, lineno, filename);
X	    error = TRUE;
X	}
X    }
X
X    if (bl_info->cm_name == NULL)
X    {
X	bcs_message(bcs_obj, stderr, "%s does not contain a cm line",
X		    filename);
X	error = 1;
X    }
X
X    fclose(bl);
X
X    return error ? FALSE : TRUE;
}
X
/*
X * Check to make sure baseline is valid.  The baseline is valid
X * if each path is a directory and contains a BL_CONF file.
X */
static int validate_baseline(bcs_obj_type bcs_obj, bcs_stringlist paths)
{
X    int i;
X    int error = FALSE;
X    bcs_baseline_info bl_info;
X    char *cm;
X    int secure;
X
X    error = check_for_file(bcs_obj, paths, BL_CONF);
X
X    if (! error)
X    {
X	/*
X	 * Now that we know each directory has a configuration file,
X	 * prepare to read the files.
X	 */
X	bcs_obj->baseline = (bcs_baseline) fl_new_flex_list(bcs_obj->whoami);
X	for (i = 0; i < paths->n; i++)
X	{
X	    bl_info = new_baseline_info(bcs_obj, paths->data[i]);
X
X	    fl_add_to_tail(bcs_obj->whoami, (flex_list)bcs_obj->baseline,
X			   bl_info);
X	    if (! parse_bl_conf(bcs_obj, bl_info))
X		error = TRUE;
X	}
X    }
X
X    if (! error)
X    {
X	cm = bcs_obj->baseline->data[0]->cm_name;
X	for (i = 1; (error == FALSE) && (i < bcs_obj->baseline->n); i++)
X	{
X	    if (strcmp(cm, bcs_obj->baseline->data[i]->cm_name) != 0)
X	    {
X		bcs_message(bcs_obj, stderr,
X			    "CM package must be the same for all "
X			    "baseline directories");
X		error = 1;
X	    }
X	}
X    }
X
X    if (! error)
X    {
X	secure = bcs_obj->baseline->data[0]->secure;
X	for (i = 1; (error == FALSE) && (i < bcs_obj->baseline->n); i++)
X	{
X	    if (secure != bcs_obj->baseline->data[i]->secure)
X	    {
X		bcs_message(bcs_obj, stderr,
X			    "secure setting must be the same for all "
X			    "baseline directories");
X		error = 1;
X	    }
X	}
X    }
X
X    if (! error)
X	cm_use(bcs_obj, cm);
X
X    return (error) ? FALSE : TRUE;
}
X
/*
X * Check to make sure staging is valid.	 The staging area list is
X * valid if each path is a directory and contains a BL_PATH file
X * that points to the corresponding baseline directory.
X */
static int validate_staging(bcs_obj_type bcs_obj, bcs_stringlist paths)
{
X    int i;
X    int error = FALSE;
X    char prefix[MAXPATHLEN];
X
X    /* Make sure staging and baseline have same number of components */
X    if (paths->n != bcs_obj->baseline->n)
X    {
X	bcs_message(bcs_obj, stderr,
X		    "baseline and staging must have same number "
X		    "of components");
X	error = TRUE;
X    }
X
X    if (! error)
X	error = check_for_file(bcs_obj, paths, BL_PATH);
X
X    if (! error)
X    {
X	/*
X	 * Now that we know each directory has a prefix file, make sure
X	 * the baseline prefix file points back to the corresponding
X	 * baseline directory.
X	 */
X	bcs_obj->staging = (bcs_staging) fl_new_flex_list(bcs_obj->whoami);
X	for (i = 0; i < paths->n; i++)
X	{
X	    fl_add_to_tail(bcs_obj->whoami, (flex_list)bcs_obj->staging,
X			   new_staging_info(bcs_obj, paths->data[i]));
X
X	    /*
X	     * Make sure the prefix file points to the right
X	     * baseline directory
X	     */
X	    bcs_obj->staging->data[i]->bl_path =
X		read_bl_path(bcs_obj, paths->data[i]);
X	    if (bcs_obj->staging->data[i]->bl_path[0] == PATH_SEP_CHAR)
X		strcpy(prefix, bcs_obj->staging->data[i]->bl_path);
X	    else
X	    {
X		strcpy(prefix, paths->data[i]);
X		strcat(prefix, PATH_SEP_STR);
X		strcat(prefix, bcs_obj->staging->data[i]->bl_path);
X	    }
X	    strcat(prefix, PATH_SEP_STR);
X	    strcat(prefix, ".");
X
X	    if (! bcsi_paths_eq(bcs_obj,
X				bcs_obj->baseline->data[i]->path.can_path,
X				prefix))
X	    {
X		error = TRUE;
X		bcs_message(bcs_obj, stderr,
X			    "%s and %s are not the same directory; "
X			    "%s in %s may contain errors.",
X			    bcs_obj->baseline->data[i]->path.can_path,
X			    prefix, BL_PATH,
X			    bcs_obj->staging->data[i]->path.user_path);
X	    }
X	}
X    }
X
X    return (error) ? FALSE : TRUE;
}
X
X
/*
X * This routine checks argc and argv for bcs-wide arguments
X * and mutates them to remove the arguments.  If successful,
X * it returns (through bcs_obj) an allocated and initialized
X * bcs object.  This object lives for the life of the invocation
X * so it is not necessary for the caller to free before exiting.
X */
static int bcs_init(bcs_obj_type *bcs_obj, int *argc, char *argv[],
X		    usage_type usage_fn)
{
X    char *whoami;
X    int status = BCS_SUCCESS;
X    int i, j;
X    bcs_stringlist bl_paths = NULL;
X    bcs_stringlist st_paths = NULL;
X
X    if ((whoami = strrchr(argv[0], PATH_SEP_CHAR)) == NULL)
X	whoami = argv[0];
X    else
X	whoami++;
X
X    /*
X     * Registration of CM packages must be done first so that --version
X     * can show available CM packages.
X     */
X    *bcs_obj = new_bcs_obj(whoami);
X    cm_register_rcs(*bcs_obj);
X    cm_register_sccs(*bcs_obj);
X
X    for (i = 1; i < *argc; i++)
X    {
X	if (strcmp(argv[i], "--version") == 0)
X	{
X	    printf("Baseline Configuration System version %d.%d", 
X		   MAJOR_VERSION, MINOR_VERSION);
X	    if (sizeof(EXTRA_VERSION) > 1)
X		printf(" %s", EXTRA_VERSION);
X	    if (PATCHLEVEL > 0)
X		printf(" patch level %d", PATCHLEVEL);
X	    if (! RELEASE)
X		printf(" (pre-release)");
X	    printf("\n");
X	    printf("Compiled on %s\n", BUILDDATE);
X	    cm_print_cm_packages(*bcs_obj);
#ifdef DEBUG
X	    printf("Debugging enabled.\n");
#endif
X	    exit(0);
X	}
X
X	if ((strcmp(argv[i], "--help") == 0) ||
X	    (strcmp(argv[i], "-h") == 0))
X	{
X	    usage_fn(whoami);
X	    exit(0);
X	    break;
X	}
X    }
X
X    if (status == BCS_SUCCESS)
X    {
X	status = parse_dflags(*bcs_obj, *argc, argv);
X    }
X
X    DPRINT((*bcs_obj, BCS_DEBUG_VERBOSE, "bcs_init: dflags = %x",
X	    (*bcs_obj)->debug_flags));
X
X    if (status == BCS_SUCCESS)
X    {
X	DPRINT((*bcs_obj, BCS_DEBUG_VERBOSE, "getting baseline"));
X	status = get_baseline(*bcs_obj, *argc, argv, &bl_paths);
X    }
X
X    if (status == BCS_SUCCESS)
X    {
X	DPRINT((*bcs_obj, BCS_DEBUG_VERBOSE, "getting staging"));
X	status = get_staging(*bcs_obj, *argc, argv, &st_paths);
X    }
X
X    /*
X     * Check for other flags
X     */
X
X    DPRINT((*bcs_obj, BCS_DEBUG_VERBOSE, "checking flags"));
X    if (status == BCS_SUCCESS)
X    {
X	for (i = 1; i < *argc; i++)
X	{
X	    if (! argv[i])
X		continue;
X
X	    if (strcmp(argv[i], "--") == 0)
X		break;
X
X	    if (strcmp(argv[i], "--silent") == 0)
X	    {
X		(*bcs_obj)->silent = TRUE;
X		argv[i] = NULL;
X		continue;
X	    }
X
X	    if ((strcmp(argv[i], "--recursive") == 0) ||
X		(strcmp(argv[i], "-r") == 0))
X	    {
X		(*bcs_obj)->recursive = TRUE;
X		argv[i] = NULL;
X		continue;
X	    }
X
X	    if ((strcmp(argv[i], "--no-action") == 0) ||
X		(strcmp(argv[i], "-n") == 0))
X	    {
X		(*bcs_obj)->no_action = TRUE;
X		argv[i] = NULL;
X		continue;
X	    }
X	}
X    }
X
X    if (status == BCS_SUCCESS)
X	status = (validate_baseline(*bcs_obj, bl_paths))
X	    ? BCS_SUCCESS : BCS_ERR_USER;
X
X    if (status == BCS_SUCCESS)
X	status = (validate_staging(*bcs_obj, st_paths))
X	    ? BCS_SUCCESS : BCS_ERR_USER;
X
X    /*
X     * Must not free strings in bl_paths and st_paths since
X     * the allocated strings are stored in the baseline and staging
X     * info structures
X     */
X    fl_delete_flex_list((flex_list *)&bl_paths, NULL);
X    fl_delete_flex_list((flex_list *)&st_paths, NULL);
X
X    if (status == BCS_SUCCESS)
X    {
X	/*
X	 * Coalesce argv.  This is potentially n^2 in number of args,
X	 * but who cares...
X	 */
X	
X	DPRINT((*bcs_obj, BCS_DEBUG_LOGIC, "coalescing argv; argc = %d",
X		*argc));
X	
X	for (i = 1; i < *argc; )
X	{
X	    if (argv[i] == NULL)
X	    {
X		DPRINT((*bcs_obj, BCS_DEBUG_LOGIC, "argv[%d] is NULL", i));
X		for (j = i + 1; j <= *argc; j++)
X		    argv[j - 1] = argv[j];
X		(*argc)--;
X	    }
X	    else
X	    {
X		DPRINT((*bcs_obj, BCS_DEBUG_LOGIC, "argv[%d] is non-NULL", i));
X		i++;
X	    }
X	}
X	
X	DPRINT((*bcs_obj, BCS_DEBUG_LOGIC, "argc == %d", *argc));
X	for (i = 0; i < *argc; i++)
X	{
X	    DPRINT((*bcs_obj, BCS_DEBUG_LOGIC, "argv[%d] = %s", i, argv[i]));
X	}
X    }
X
X    return status;
}
X
/**
X ** PUBLIC ROUTINES
X **/
X
void bcs_print_standard_opts(void)
{
X    fprintf(stderr, "  Standard options include\n");
X    fprintf(stderr, "    --help | -h\n");
X    fprintf(stderr, "    --version\n");
X    fprintf(stderr, "    --baseline dir[:dir:...]\n");
X    fprintf(stderr, "    --staging dir[:dir:...]\n");
#ifdef DEBUG
X    fprintf(stderr, "    --debug opt[:opt:...]\n");
#endif
X    fprintf(stderr, "    --silent\n");
X    fprintf(stderr, "    --recursive | -r\n");
X    fprintf(stderr, "    --no-action | -n\n");
#ifdef DEBUG
X    fprintf(stderr, "  Debug options include\n");
X    fprintf(stderr, "    all     - all debugging options\n");
X    fprintf(stderr, "    logic   - show complex logic in code\n");
X    fprintf(stderr, "    trace   - trace function calls\n");
X    fprintf(stderr, "    verbose - give frequent progress reports\n");
X    fprintf(stderr, "    path    - show pathname processing details\n");
#endif
}
X
/*
X * Convenience startup function.  Either exits or returns success
X * with all initialization completed.
X */
void bcs_start(bcs_obj_type *bcs_obj, int *argc, char *argv[],
X	       usage_type usage_fn)
{
X    char *whoami;
X    int status;
X    static bcs_obj_type bcs_obj_keeper;
X
X    if ((whoami = strrchr(argv[0], PATH_SEP_CHAR)) == NULL)
X	whoami = argv[0];
X    else
X	whoami++;
X
X    status = bcs_init(bcs_obj, argc, argv, usage_fn);
X    switch (status)
X    {
X      case BCS_SUCCESS:
X	break;
X
X      case BCS_ERR_USAGE:
X	fprintf(stderr,
X		"%s: Please type %s --help for a detailed help message.\n",
X		whoami, whoami);
X	exit(BCS_ERR_USAGE);
X	break;
X
X      case BCS_ERR_MEMORY:
X	fprintf(stderr, "%s: no memory\n", argv[0]);
X	/* fall through */
X
X      default:
X	exit(status);
X    }
X
X    /*
X     * This assignment is because of Purify, a software package that
X     * can be used to detect memory errors including leaks.  Purify
X     * flags any memory that is not accessible at program exit as a
X     * leak.  Since we don't bother to free any of the memory used in
X     * bcs_obj before exiting, all of it is flagged as a leak.  To
X     * prevent this from happening without adding the overhead of
X     * freeing it, we assign it to a static variable that will never
X     * again be used.  This way, the memory in bcs_obj will be
X     * addressable even during program exit.  This will allow us to
X     * find other leaks that purify may detect.
X     */
X    bcs_obj_keeper = *bcs_obj;
X
X    DPRINT((*bcs_obj, -1, "*** STARTUP COMPLETE ***"));
}
SHAR_EOF
echo 'File bcs-2.0/lib/init.c is complete' &&
chmod 0444 bcs-2.0/lib/init.c ||
echo 'restore of bcs-2.0/lib/init.c failed'
Wc_c="`wc -c < 'bcs-2.0/lib/init.c'`"
test 21921 -eq "$Wc_c" ||
	echo 'bcs-2.0/lib/init.c: original size 21921, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/lib/make_rcs_h ==============
if test -f 'bcs-2.0/lib/make_rcs_h' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/lib/make_rcs_h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/lib/make_rcs_h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/lib/make_rcs_h' &&
#!/bin/sh
#
# $Id: make_rcs_h,v 1.3 1993/10/28 21:26:18 ejb Exp $
# $Source: /local/tmp/bcs-2.0/lib/RCS/make_rcs_h,v $
# $Author: ejb $
#
# Generate RCS header file with full rcs pathnames
#
X
rcsdiff_path=`sh find_cmd rcsdiff`
co_path=`sh find_cmd co`
ci_path=`sh find_cmd ci`
rlog_path=`sh find_cmd rlog`
wc_path=`sh find_cmd wc`
test_path=`sh find_cmd test`
X
cat <<EOF > rcs_paths.h
/*
X * This file is automatically generated by $0; Do not edit.
X * If this file is empty besides these comments, then RCS commands
X * could not be found out build-time. 
X */
EOF
X
if test "$rcsdiff_path" != "" -a "$co_path" != "" -a "$ci_path" != ""; then
X  cat << EOF >> rcs_paths.h
#ifndef _RCS_PATHS_H
#define _RCS_PATHS_H
X
#define HAVE_RCS
#define RCSDIFF_PATH "$rcsdiff_path"
#define CO_PATH "$co_path"
#define CI_PATH "$ci_path"
#define RLOG_PATH "$rlog_path"
#define WC_PATH "$wc_path"
#define TEST_PATH "$test_path"
X
#endif
EOF
fi
X
Xexit 0
SHAR_EOF
chmod 0444 bcs-2.0/lib/make_rcs_h ||
echo 'restore of bcs-2.0/lib/make_rcs_h failed'
Wc_c="`wc -c < 'bcs-2.0/lib/make_rcs_h'`"
test 930 -eq "$Wc_c" ||
	echo 'bcs-2.0/lib/make_rcs_h: original size 930, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/lib/make_sccs_h ==============
if test -f 'bcs-2.0/lib/make_sccs_h' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/lib/make_sccs_h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/lib/make_sccs_h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/lib/make_sccs_h' &&
#!/bin/sh
#
# $Id: make_sccs_h,v 1.2 1994/01/25 14:11:18 ejb Exp $
# $Source: /local/tmp/bcs-2.0/lib/RCS/make_sccs_h,v $
# $Author: ejb $
#
# Generate SCCS header file with full sccs pathnames
#
X
sccs_path=`sh find_cmd sccs`
diff_path=`sh find_cmd diff`
X
cat <<EOF > sccs_paths.h
/*
X * This file is automatically generated by $0; Do not edit.
X * If this file is empty besides these comments, then SCCS commands
X * could not be found out build-time. 
X */
EOF
X
if test "$sccs_path" != "" -a "$diff_path" != ""; then
X  cat << EOF >> sccs_paths.h
#ifndef _SCCS_PATHS_H
#define _SCCS_PATHS_H
X
#define HAVE_SCCS
#define SCCS_PATH "$sccs_path"
#define DIFF_PATH "$diff_path"
X
#endif
EOF
fi
X
Xexit 0
SHAR_EOF
chmod 0444 bcs-2.0/lib/make_sccs_h ||
echo 'restore of bcs-2.0/lib/make_sccs_h failed'
Wc_c="`wc -c < 'bcs-2.0/lib/make_sccs_h'`"
test 691 -eq "$Wc_c" ||
	echo 'bcs-2.0/lib/make_sccs_h: original size 691, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/lib/path.c ==============
if test -f 'bcs-2.0/lib/path.c' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/lib/path.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/lib/path.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/lib/path.c' &&
/* 
X * $Id: path.c,v 1.31 1994/03/07 21:47:41 qjb Exp $
X * $Source: /local/tmp/bcs-2.0/lib/RCS/path.c,v $
X * $Author: qjb $
X *
X * Copyright (C) 1994  E. Jay Berkenbilt
X * 
X * This file is part of BCS.  BCS may be distributed according to the terms
X * of the General Public License and/or the Artistic License.  See the
X * `COPYING' and `Artistic' files with the source distribution for details.
X * This notice must be kept intact when this file is distributed.
X *
X * This file contains routines that deal with path manipulation and
X * caching of non-BCS-specific file system information.
X */
X
#if !defined(lint) && !defined(CODECENTER) || defined(RCS_HDRS)
/* Define a static function and call it.  No warnings this way. */
static void rcsid(char *s)
{rcsid("@(#)$Id: path.c,v 1.31 1994/03/07 21:47:41 qjb Exp $");}
#endif /* !lint && !CODECENTER || RCS_HDRS */
X
#include "bcs_p.h"
#include "path.h"
X
#define MAX_SYMLINKS 50		/* for now, this is our loop detection... */
X
/*
X * Hashing constant for various caches.  This is log_2 of
X * the size of the table.
X */
#define HASH_CONST		6
#define HASH_SIZE		(1 << (HASH_CONST))
X
static path_cache fs_root = NULL;
X
/*
X * PRIVATE ROUTINES
X */
X
static void delete_path_cache(path_cache path_info)
{
X    if (path_info)
X    {
X	if (path_info->children)
X	{
X	    int i;
X	    for (i = 0; i < HASH_SIZE; i++)
X	    {
X		/* delete_flex_list checks for nulls... */
X		fl_delete_flex_list((flex_list *)&(path_info->children[i]),
X				    (fl_free_fn_type) delete_path_cache);
X	    }
X	    free(path_info->children);
X	}
X
X	if (path_info->lastcomp)
X	    free(path_info->lastcomp);
X	if (path_info->canpath)
X	    free(path_info->canpath);
X	if (path_info->file_info)
X	    bcsi_delete_file_info(path_info->file_info);
X	if (path_info->linkpath)
X	    free(path_info->linkpath);
X	free(path_info);
X    }
}
X
static path_cache new_path_cache(bcs_obj_type bcs_obj, char *name,
X				 path_cache parent)
{
X    path_cache result;
X    char workpath[MAXPATHLEN];
X    struct stat statbuf;
X
X    if (parent == NULL)
X    {
X	strcpy(workpath, "/");
X	name = "";
X    }
X    else
X    {
X	strcpy(workpath, parent->canpath);
X	bcsi_append_last_component(workpath, name);
X    }
X
X    /* This should be the only call to lstat in BCS. */
X    if (lstat(workpath, &statbuf) == -1)
X    {
X	return NULL;
X    }
X
X    result = bcsi_safe_malloc(bcs_obj->whoami, sizeof(struct path_cache_rec));
X    result->lastcomp = bcsi_safe_strdup(bcs_obj->whoami, name);
X    result->canpath = bcsi_safe_strdup(bcs_obj->whoami, workpath);
X    result->statbuf = statbuf;
X    result->file_info = NULL;
X    result->parent = parent;
X    result->linkpath = NULL;
X    result->children = NULL;
X
X    if (S_ISLNK(statbuf.st_mode))
X    {
X	char tmppath[MAXPATHLEN];
X	mem_zero(tmppath, sizeof(tmppath));
X	/* This should be the only call to readlink in BCS */
X	if (readlink(workpath, tmppath, sizeof(workpath)) == -1)
X	{
X	    bcs_message(bcs_obj, stderr, "can't read link value for %s: %s",
X			workpath, error_string(errno));
X	    exit(BCS_ERR_SYSTEM);
X	}
X	result->linkpath = bcsi_safe_strdup(bcs_obj->whoami, tmppath);
X    }
X
X    if (S_ISDIR(statbuf.st_mode))
X    {
X	int i;
X	result->children =
X	    bcsi_safe_malloc(bcs_obj->whoami,
X			     sizeof(path_cache_list) * HASH_SIZE);
X	for (i = 0; i < HASH_SIZE; i++)
X	    result->children[i] = NULL;
X    }
X    
X    return result;
}
X
static int string_hash(char *str)
{
X    int len;
X
X    /*
X     * Return hash table index based upon string.  Since most strings
X     * here are path names components, going on first or last characters
X     * would be unwise.  Instead, we multiply the middle character by
X     * the length and clear high-order bits to put within range.
X     */
X
X    len = strlen(str);
X    return ((str[len >> 1] * len) & ((1 << HASH_CONST) - 1));
}
X
static void init_root(bcs_obj_type bcs_obj)
{
X    if (fs_root)
X	return;
X
X    fs_root = new_path_cache(bcs_obj, "", NULL);
}
X
static void split_path(bcs_obj_type bcs_obj, char *path,
X		       bcs_stringlist components, int indx)
{
X    char workpath[MAXPATHLEN];
X    char *p1, *p2;
X    int i;
X
X    /* Split path into components */
X    strcpy(workpath, path);
X    DPRINT((bcs_obj, BCS_DEBUG_PATH, "path_split: splitting path %s",
X	    workpath));
X    p1 = workpath;
X    while (*p1 == PATH_SEP_CHAR)
X	p1++;
X    do {
X	p2 = strchr(p1, PATH_SEP_CHAR);
X	if (p2)
X	    *p2 = '\0';
X	DPRINT((bcs_obj, BCS_DEBUG_PATH, "path_split: comp: %s", p1));
X	fl_insert(bcs_obj->whoami, (flex_list) components, indx,
X		  bcsi_safe_strdup(bcs_obj->whoami, p1));
X	indx++;
X	if (p2)
X	{
X	    *p2 = PATH_SEP_CHAR;
X	    p1 = p2;
X	    while (*p1 == PATH_SEP_CHAR)
X		p1++;
X	}
X    } while (p2 && *p1);
X
X    DPRINT((bcs_obj, BCS_DEBUG_PATH, "path_split: components now:"));
X    for (i = 0; i < components->n; i++)
X	DPRINT((bcs_obj, BCS_DEBUG_PATH, "   %s", components->data[i]));
}
X
/*
X * PUBLIC, INTERNAL ROUTINES
X */
X
path_cache bcsi_path_info_from_parent(bcs_obj_type bcs_obj, char *name,
X				      path_cache parent)
{
X    path_cache_list list;
X    path_cache result = NULL;
X    int cindex;
#ifdef CACHE_STATS
X    static int hits = 0;
X    static int misses = 0;
#endif
X
X    /* Do nothing if this node doesn't have any children */
X    if (parent->children)
X    {
X	/* If it does, try to find a child with this last component */
X	cindex = string_hash(name);
X
X	if ((list = parent->children[cindex]) != NULL)
X	{
X	    int i;
X	    for (i = 0; i < list->n; i++)
X	    {
X		if (strcmp(name, list->data[i]->lastcomp) == 0)
X		{
X		    result = list->data[i];
X		    break;
X		}
X	    }
X	}
X	
X	/* If not found in cache, check the file system */
X	if (result == NULL)
X	{
#ifdef PATH_CACHE
X	    misses++;
#endif
X	    if ((result = new_path_cache(bcs_obj, name, parent)))
X	    {
X		/* If found in file system, add to cache */
X		if (parent->children[cindex] == NULL)
X		    parent->children[cindex] = 
X			(path_cache_list) fl_new_flex_list(bcs_obj->whoami);
X
X		fl_add_to_tail(bcs_obj->whoami,
X			       (flex_list) parent->children[cindex],
X			       result);		
X	    }
X	}
X	else
X	{
#ifdef PATH_CACHE
X	    hits++;
#endif
X	}
X	
#ifdef PATH_CACHE
X	DPRINT((bcs_obj, BCS_DEBUG_PATH,
X		"get_path_cache: hits: %d, misses: %d", hits, misses));
#endif
X    }
X
X    return result;
}
X
/*
X * Replacement for lstat.  This routine behaves like lstat does
X * but looks in an internal cache before returning something
X */
int bcsi_lstat(bcs_obj_type bcs_obj, char *filename, struct stat *statbuf)
{
X    int found = FALSE;
X    path_cache path_info;
X    
X    if ((path_info = bcsi_get_path_info(bcs_obj, filename)) == NULL)
X	found = FALSE;
X    else
X    {
X	*statbuf = *(pc_statbuf(bcs_obj, path_info));
X	found = TRUE;
X    }
X    
#ifdef CHECK_PATH_CACHE
X    if (found)
X    {
X	struct stat tmp;
X	lstat(filename, &tmp);
X	if ((tmp.st_ino != statbuf->st_ino) ||
X	    (tmp.st_dev != statbuf->st_dev))
X	{
X	    DPRINT((bcs_obj, BCS_DEBUG_PATH, "bcsi_lstat: "
X		    "mismatch for %s: table: %d, %d; actual: %d, %d",
X		    filename, statbuf->st_ino, statbuf->st_dev,
X		    tmp.st_ino, tmp.st_dev));
X	}
X    }
#endif
X    
X    return (found ? 0 : -1);
}
X
/*
X * Test whether a file exists
X */
int bcsi_exists(bcs_obj_type bcs_obj, char *path)
{
X    struct stat statbuf;
X    
X    return (bcsi_lstat(bcs_obj, path, &statbuf) == -1) ? FALSE : TRUE;	
}
X
/*
X * Test whether a file is readable.
X */
int bcsi_readable(bcs_obj_type bcs_obj, char *path)
{
X    return (access(path, R_OK) == 0) ? TRUE : FALSE;
}
X
/*
X * Test whether to paths correspond to the same file.  Two files
X * are the same if they have the same inode and device numbers.
X *
X * Use lstat instead of stat so that a symbolic link to a file
X * is not considered the same as the file it is a link to.
X */
int bcsi_paths_eq(bcs_obj_type bcs_obj, char *p1, char * p2)
{
X    struct stat s1, s2;
X    
X    if (bcsi_lstat(bcs_obj, p1, &s1) == -1)
X	return FALSE;
X    if (bcsi_lstat(bcs_obj, p2, &s2) == -1)
X	return FALSE;
X    
X    return ((s1.st_dev == s2.st_dev) &&
X	    (s1.st_ino == s2.st_ino));
}
X
/*
X * Look up a path in the path cache.  The path cache is a tree
X * structure that looks like the file system.  Canonicalize the path
X * entering information not already present into the tape as we go.
X *
X * No loop detection is performed.  Instead, a count of symbolic links
X * is kept and overflow is checked for the working string.
X */
path_cache bcsi_get_path_info(bcs_obj_type bcs_obj, char *path)
{
X    char tmppath[MAXPATHLEN];
X    int symlinks = 0;
X    bcs_stringlist components = NULL;
X    int absolute;
X    int cur_comp;
X    char pwd[MAXPATHLEN];
X    path_cache cur_path_info;
X    path_cache new_path_info;
X    path_cache result = NULL;
X    int error = FALSE;
X    
X    DPRINT((bcs_obj, BCS_DEBUG_TRACE, "ENTERING get_path_info(%s)",
X	    path));
X
X    init_root(bcs_obj);
X    
X    components = (bcs_stringlist) fl_new_flex_list(bcs_obj->whoami);
X    
X    absolute = (path[0] == PATH_SEP_CHAR);
X    if (absolute)
X	strcpy(tmppath, path);
X    else
X    {
X	if (getcwd(pwd, sizeof(pwd)) == NULL)
X	{
X	    bcs_message(bcs_obj, stderr,
X			"can't get current directory; exiting: %s",
X			error_string(errno));
X	    exit(BCS_ERR_SYSTEM);
X	}
X	strcpy(tmppath, pwd);
X	strcat(tmppath, PATH_SEP_STR);
X	strcat(tmppath, path);
X    }
X    split_path(bcs_obj, tmppath, components, 0);
X    
X    /*
X     * Iterate through path one component at a time.  At each component,
X     * stat the path so far.  If the component is a link, read the link
X     * and replace or append based on whether this is relative or absolute.
X     */
X    cur_comp = 0;
X    cur_path_info = fs_root;
X    while (cur_comp < components->n)
X    {
X	if (strcmp(components->data[cur_comp], ".") == 0)
X	{
X	    /* skip . in path */
X	    DPRINT((bcs_obj, BCS_DEBUG_PATH,
X		    "path_canon: skipping . as path component"));
X	    fl_delete_range(bcs_obj->whoami, (flex_list) components, cur_comp,
X			    cur_comp, (fl_free_fn_type) free);
X	    continue;
X	}
X
X	if (strcmp(components->data[cur_comp], "..") == 0)
X	{
X	    /*
X	     * Up to this point, our path is fully canonicalized.  Is is,
X	     * therefore, safe to do text manipulation on the path name
X	     * to strip .. components from the path
X	     */
X	    DPRINT((bcs_obj, BCS_DEBUG_PATH,
X		    "path_canon: resolving .. as path component"));
X	    if (cur_comp == 0)
X	    {
X		/*
X		 * If this is the first component, just skip it since /.. == /
X		 */
X		fl_delete_range(bcs_obj->whoami, (flex_list) components,
X				cur_comp, cur_comp, (fl_free_fn_type) free);
X	    }
X	    else
X	    {
X		/*
X		 * Otherwise, delete this component and the previous one,
X		 * and adjust workpath appropriately.
X		 */
X		fl_delete_range(bcs_obj->whoami, (flex_list) components,
X				cur_comp - 1, cur_comp,
X				(fl_free_fn_type) free);
X		cur_comp--;
X		cur_path_info = cur_path_info->parent;
X	    }
X	    continue;
X	}
X
X	if (cur_path_info->children == NULL)
X	{
X	    if (result)
X	    {
X		/* this is a dangling link; just return what we have. */
X		break;
X	    }
X	    else
X	    {
X		error = TRUE;
X		break;
X	    }
X	}
X	new_path_info = bcsi_path_info_from_parent(bcs_obj,
X						   components->data[cur_comp],
X						   cur_path_info);
X	
X	if (new_path_info == NULL)
X	{
X	    if (result)
X	    {
X		/* This is a dangling link; just return what we have. */
X		break;
X	    }
X	    else
X	    {
X		error = TRUE;
X		break;
X	    }
X	}
X	
X	/*
X	 * If this is the last component, we will return its information
X	 * directly.  Still, though, we will examine it if it is a link
X	 * before returning.  In case this is a link, make sure we only
X	 * assign result one time.
X	 */
X	if ((cur_comp == components->n - 1) && (result == NULL))
X	    result = new_path_info;
X
X	DPRINT((bcs_obj, BCS_DEBUG_PATH,
X		"get_path_info: current path = %s",
X		new_path_info->canpath));
X	
X	if (new_path_info->linkpath)
X	{
X	    if (++symlinks > MAX_SYMLINKS)
X	    {
X		bcs_message(bcs_obj, stderr,
X			"too many levels of symbolic links (> %d) "
X			"encountered while getting information about %s.",
X			MAX_SYMLINKS, path);
X		exit(BCS_ERR_SYSTEM);
X	    }
X	    absolute = (new_path_info->linkpath[0] == PATH_SEP_CHAR);
X	    if (absolute)
X	    {
X		fl_delete_range(bcs_obj->whoami, (flex_list) components,
X				0, cur_comp, (fl_free_fn_type) free);
X		cur_comp = 0;
X		cur_path_info = fs_root;
X	    }
X	    else
X	    {
X		fl_delete_range(bcs_obj->whoami, (flex_list)components,
X				cur_comp, cur_comp, (fl_free_fn_type) free);
X	    }
X	    split_path(bcs_obj, new_path_info->linkpath, components, cur_comp);
X	}
X	else
X	{
X	    cur_comp++;
X	    cur_path_info = new_path_info;
X	}
X    }
X    
X    /*
X     * If we never encountered the last component (because it was . or ..),
X     * whatever we last looked at is the result.
X     */
X    if ((result == NULL) && (! error))
X	result = cur_path_info;
X
X    fl_delete_flex_list((flex_list *)&components, (fl_free_fn_type) free);
X
X    DPRINT((bcs_obj, BCS_DEBUG_PATH, "get_path_info(%s) = %s",
X	    path, (result) ? result->canpath : "--none--"));
X
X    DPRINT((bcs_obj, BCS_DEBUG_TRACE, "LEAVING get_path_info(%s)",
X	    path));
X
X    return result;
}
X
static int ispath(bcs_obj_type bcs_obj, int dev, int ino,
X		  int *indx, bcs_which *which, bcs_path_info *path)
{
X    if ((dev == path->dev) && (ino == path->ino))
X    {
X	DPRINT((bcs_obj, BCS_DEBUG_LOGIC,
X		"ispath: matches %s", path->can_path));
X	return TRUE;
X    }
X
X    return FALSE;
}
X
static int is_real_bldir(bcs_obj_type bcs_obj, int dev, int ino,
X			 int *indx, bcs_which *which)
{
X    int i;
X
X    for (i = 0; i < bcs_obj->staging->n; i++)
X    {
X	if (ispath(bcs_obj, dev, ino, indx, which, 
X		   &(bcs_obj->staging->data[i]->path)))
X	{
X	    *which = in_staging;
X	    *indx = i;
X	    return TRUE;
X	}
X    }
X
X    for (i = 0; i < bcs_obj->baseline->n; i++)
X    {
X	if (ispath(bcs_obj, dev, ino, indx, which, 
X		   &(bcs_obj->baseline->data[i]->path)))
X	{
X	    *which = in_baseline;
X	    *indx = i;
X	    return TRUE;
X	}
X    }
X
X    return FALSE;
}
X
/*
X * PUBLIC, EXTERNAL ROUTINES
X */
X
/*
X * Test whether a path is a directory.  Do not follow symbolic links.
X */
int bcs_isdir(bcs_obj_type bcs_obj, char *path)
{
X    struct stat statbuf;
X
X    if ((bcsi_lstat(bcs_obj, path, &statbuf)) != -1)
X    {
X	if (S_ISDIR(statbuf.st_mode))
X	    return TRUE;
X    }
X
X    return FALSE;
}
X
/*
X * Test whether a path is a link.
X */
int bcs_islink(bcs_obj_type bcs_obj, char *path)
{
X    struct stat statbuf;
X
X    if ((bcsi_lstat(bcs_obj, path, &statbuf)) != -1)
X    {
X	if (S_ISLNK(statbuf.st_mode))
X	    return TRUE;
X    }
X
X    return FALSE;
}
X
/*
X * Test to see whether this device and inode number matches that
X * of one of the baseline or staging area directories.  The
X * checking order here is important.  We must check all staging
X * area directories first so that if a staging area is under
X * a baseline, a file in the staging area shows up as not under
X * the baseline but under the staging area instead.
X */
int bcs_isbldir(bcs_obj_type bcs_obj, char *filename, struct stat *statbuf,
X		int *indx, bcs_which *which)
{
X    struct stat tmpstat;
X    int dummy_index;
X    bcs_which dummy_which;
X    struct stat dummy_statbuf;
X
X    /*
X     * If index or which is NULL, fill in these dummy values.  Don't
X     * worry; we're not returning pointers to static variables.  The
X     * index and which returned by this routine will still be NULL...
X     */
X    if (indx == NULL)
X	indx = &dummy_index;
X    if (which == NULL)
X	which = &dummy_which;
X
X    if (statbuf == NULL)
X    {
X	statbuf = &dummy_statbuf;
X	/* This must be lstat so we can tell whether it's a link. */
X	if (bcsi_lstat(bcs_obj, filename, statbuf) == -1)
X	    return FALSE;
X    }
X    
X    if (is_real_bldir(bcs_obj, statbuf->st_dev, statbuf->st_ino, indx, which))
X	return TRUE;
X
X    if (S_ISLNK(statbuf->st_mode))
X    {
X	/*
X	 * Special case: link to a top-level baseline or staging directory
X	 * is considered in that directory.
X	 */
X	/* This must be stat so we can see through a link. */
X	if (stat(filename, &tmpstat) == 0)
X	{
X	    /*
X	     * If it is a bl directory, which and index are updated;
X	     * otherwise, they are not touched.
X	     */
X	    if (is_real_bldir(bcs_obj, tmpstat.st_dev, tmpstat.st_ino,
X			      indx, which))
X		return TRUE;
X	}
X    }
X
X    return FALSE;
}
X
void bcs_get_bl_index(bcs_obj_type bcs_obj, char *path, int *indx,
X		      bcs_which *which)
{
X    path_cache path_info;
X
X    path_info = bcsi_get_path_info(bcs_obj, path);
X    pc_get_bl_index(bcs_obj, path_info, indx, which);
}
X
char *pc_can_path(bcs_obj_type bcs_obj, path_cache path_info)
{
X    return path_info->canpath;
}
X
bcs_file_info pc_file_info(bcs_obj_type bcs_obj, path_cache path_info)
{
X    return path_info->file_info;
}
X
struct stat *pc_statbuf(bcs_obj_type bcs_obj, path_cache path_info)
{
X    return &(path_info->statbuf);
}
X
/*
X * Set which to indicate whether a file is in the baseline, in a
X * staging area, or neither.  If it is in one, set index to the index
X * into the component list of baseline or staging area directories to
X * the directory containing this file.
X */
void pc_get_bl_index(bcs_obj_type bcs_obj, path_cache path_info,
X		     int *indx, bcs_which *which)
{
X    path_cache cur_path_info;
X    int dummy_index;
X    bcs_which dummy_which;
X
X    /* Use dummy variables so caller can pass NULL for index or which */
X    if (indx == NULL)
X	indx = &dummy_index;
X    if (which == NULL)
X	which = &dummy_which;
X
X    *indx = -1;
X    *which = in_none;
X
X    if (path_info == NULL)
X	return;
X
X    for (cur_path_info = path_info; cur_path_info;
X	 cur_path_info = cur_path_info->parent)
X    {
X	DPRINT((bcs_obj, BCS_DEBUG_PATH,
X		"pc_get_bl_index: checking %s", cur_path_info->canpath));
X	
X	if (bcs_isbldir(bcs_obj, cur_path_info->canpath,
X			&(cur_path_info->statbuf), indx, which))
X	    return;
X    }
}
X
char *pc_linkpath(bcs_obj_type bcs_obj, path_cache path_info)
{
X    return path_info->linkpath;
}
X
char *pc_lastcomp(bcs_obj_type bcs_obj, path_cache path_info)
{
X    return path_info->lastcomp;
}
X
int pc_isdir(bcs_obj_type bcs_obj, path_cache path_info)
{
X    if (path_info)
X	return S_ISDIR(path_info->statbuf.st_mode);
X    else
X	return FALSE;
}
X
int pc_islink(bcs_obj_type bcs_obj, path_cache path_info)
{
X    return S_ISLNK(path_info->statbuf.st_mode);
}
X
path_cache pc_parent(bcs_obj_type bcs_obj, path_cache path_info)
{
X    return path_info->parent;
}
X
void pc_insert_file_info(bcs_obj_type bcs_obj, path_cache path_info,
X			 bcs_file_info file_info)
{
X    path_info->file_info = file_info;
}
X
void pc_remove_file_info(bcs_obj_type bcs_obj, path_cache path_info)
{
X    if (path_info->file_info)
X    {
X	bcsi_delete_file_info(path_info->file_info);
X	path_info->file_info = NULL;
X    }
}
X
void pc_remove_path_info(bcs_obj_type bcs_obj, path_cache path_info)
{
X    path_cache parent;
X    int cindex;
X    path_cache_list list = NULL;
X
X    parent = path_info->parent;
X    /*
X     * If parent is undefined, this is the root.  We won't remove
X     * the root path cache, but we can remove its file_info.
X     */
X    if (parent)
X    {
X	cindex = string_hash(path_info->lastcomp);
X	if ((list = parent->children[cindex]) != NULL)
X	{
X	    int i;
X	    for (i = 0; i < list->n; i++)
X	    {
X		if (list->data[i] == path_info)
X		{
X		    fl_delete_range(bcs_obj->whoami,
X				    (flex_list) list, i, i,
X				    (fl_free_fn_type) delete_path_cache);
X		    break;
X		}
X	    }
X	}
X    }
X    else
X    {
X	pc_remove_file_info(bcs_obj, path_info);
X    }
}
X
path_cache pc_ult_link_info(bcs_obj_type bcs_obj, path_cache path_info)
{
X    char tmppath[MAXPATHLEN];
X    path_cache cur_path_info;
X    char *cur_linkpath;
X
X    cur_path_info = path_info;
X    while (cur_path_info &&
X	   ((cur_linkpath = pc_linkpath(bcs_obj, cur_path_info))))
X    {
X	bcsi_resolve_readlink(tmppath, cur_linkpath,
X			      pc_can_path(bcs_obj, cur_path_info));
X	cur_path_info = bcsi_get_path_info(bcs_obj, tmppath);
X    }
X
X    return cur_path_info;
}
X
SHAR_EOF
chmod 0444 bcs-2.0/lib/path.c ||
echo 'restore of bcs-2.0/lib/path.c failed'
Wc_c="`wc -c < 'bcs-2.0/lib/path.c'`"
test 19680 -eq "$Wc_c" ||
	echo 'bcs-2.0/lib/path.c: original size 19680, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/lib/path.h ==============
if test -f 'bcs-2.0/lib/path.h' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/lib/path.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/lib/path.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/lib/path.h' &&
/* 
X * $Id: path.h,v 1.3 1994/03/07 21:47:41 qjb Exp $
X * $Source: /local/tmp/bcs-2.0/lib/RCS/path.h,v $
X * $Author: qjb $
X *
X * Copyright (C) 1994  E. Jay Berkenbilt
X * 
X * This file is part of BCS.  BCS may be distributed according to the terms
X * of the General Public License and/or the Artistic License.  See the
X * `COPYING' and `Artistic' files with the source distribution for details.
X * This notice must be kept intact when this file is distributed.
X *
X * This file defines the structures needed for caching of path
X * information.
X */
X
#ifndef __PATH_H__
#define __PATH_H__
X
#if !defined(lint) && !defined(CODECENTER) || defined(RCS_HDRS)
/* Define a static function and call it.  No warnings this way. */
static void rcsid_path_h(char *s)
{rcsid_path_h("@(#)$Id: path.h,v 1.3 1994/03/07 21:47:41 qjb Exp $");}
#endif /* !lint && !CODECENTER || RCS_HDRS */
X
#include "bcs_p.h"
X
FL_DEFINE(path_cache_list_rec, path_cache_list, path_cache);
X
struct path_cache_rec {
X    char *lastcomp;		/* last component of path */
X    char *canpath;		/* canonical path */
X    struct stat statbuf;
X    bcs_file_info file_info;
X    path_cache parent;
X    char *linkpath;		/* result of a single readlink if a link */
X    path_cache_list *children;	/* if initialized, array of HASH_SIZE */
};
X
X
#endif /* __PATH_H__ */
SHAR_EOF
chmod 0444 bcs-2.0/lib/path.h ||
echo 'restore of bcs-2.0/lib/path.h failed'
Wc_c="`wc -c < 'bcs-2.0/lib/path.h'`"
test 1309 -eq "$Wc_c" ||
	echo 'bcs-2.0/lib/path.h: original size 1309, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/lib/rcs_cm.c ==============
if test -f 'bcs-2.0/lib/rcs_cm.c' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/lib/rcs_cm.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/lib/rcs_cm.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/lib/rcs_cm.c' &&
/* 
X * $Id: rcs_cm.c,v 1.21 1994/03/07 21:47:41 qjb Exp $
X * $Source: /local/tmp/bcs-2.0/lib/RCS/rcs_cm.c,v $
X * $Author: qjb $
X *
X * Copyright (C) 1994  E. Jay Berkenbilt
X * 
X * This file is part of BCS.  BCS may be distributed according to the terms
X * of the General Public License and/or the Artistic License.  See the
X * `COPYING' and `Artistic' files with the source distribution for details.
X * This notice must be kept intact when this file is distributed.
X *
X * This file implements RCS support for BCS.  The whole file
X * is #ifdefed based on whether or not we have RCS.  This is
X * defined in an automatically generated header file created
X * at build-time.
X */
X
#if !defined(lint) && !defined(CODECENTER) || defined(RCS_HDRS)
/* Define a static function and call it.  No warnings this way. */
static void rcsid(char *s)
{rcsid("@(#)$Id: rcs_cm.c,v 1.21 1994/03/07 21:47:41 qjb Exp $");}
#endif /* !lint && !CODECENTER || RCS_HDRS */
X
#include "bcs_p.h"
#include "rcs_cm.h"
X
#ifdef HAVE_RCS
X
static bcs_cm_info rcs_cm;
X
static cm_precious rcs_precious[] = {
{ "RCS", cm_dir },
{ NULL, cm_none },
};
X
/* Must fill in get_file_args later since it is not a constant */
static cm_command rcs_cmds[] = {
{ "co", CO_PATH, cm_checkout, NULL },
{ "ci", CI_PATH, cm_checkin, NULL },
{ NULL, NULL, 0, NULL},
};
X
/*
X * PRIVATE FUNCTIONS
X */
X
/*
X * Test whether a file has an RCS log.  A file does not have to
X * exist to have a log.
X */
static int rcs_haslog(bcs_obj_type bcs_obj, char *filename)
{
X    char logfile[MAXPATHLEN];
X    char lastcomp[MAXPATHLEN];
X    char *p;
X
X    /*
X     * In RCS 5.6, by default, there are three legal names for the
X     * logfile for path/file.  In order of preference, they are path 
X     * path/RCS/file,v; path/file,v; and path/RCS/file.  We will check
X     * to make sure at least one of these exists.  We don't need to
X     * check in any order, so we'll check in the most convenient order
X     * for the code.  In addition, if a file ends with the default
X     * suffix, it is considered to be a log even if it may have a log
X     * by the above standards.  Thus, never consider a file ending with
X     * ,v to have a log.  [Note: there are obscure exceptions to this,
X     * but RCS doesn't handle them right anyway at least as of 5.6.0.1.
X     * For example, if a,v and RCS/a,v,v both exist, co RCS/a,v,v will
X     * update a,v but co a,v will try to update a.]
X     */
X
X    if ((strlen(filename) >= strlen(RCS_SUFFIX)) &&
X	(strcmp(filename + strlen(filename) - strlen(RCS_SUFFIX),
X		RCS_SUFFIX) == 0))
X    {
X	return FALSE;
X    }
X	 
X
X    strcpy(logfile, filename);
X    strcat(logfile, RCS_SUFFIX);
X
X    /* Check for path/file,v */ 
X    if (bcsi_exists(bcs_obj, logfile))
X	return TRUE;
X
X    strcpy(logfile, filename);
X    if ((p = strrchr(logfile, PATH_SEP_CHAR)) == NULL)
X    {
X	strcpy(lastcomp, filename);
X	p = logfile;
X    }
X    else
X    {
X	p++;
X	strcpy(lastcomp, p);
X    }
X
X    strcpy(p, RCS_DIR);
X    strcat(p, PATH_SEP_STR);
X    strcat(p, lastcomp);
X
X    /* Check for path/RCS/file */
X    if (bcsi_exists(bcs_obj, logfile))
X	return TRUE;
X
X    strcat(p, RCS_SUFFIX);
X
X    /* Check for path/RCS/file,v */
X    return (bcsi_exists(bcs_obj, logfile));
}
X
static int rcs_locked(bcs_obj_type bcs_obj, char *filename)
{
X    char command[2 * MAXPATHLEN];
X
X    
X    sprintf(command, "%s \"`%s -L -R %s | %s -l`\" -eq \"1\"",
X	    TEST_PATH, RLOG_PATH, filename, WC_PATH);
X    DPRINT((bcs_obj, BCS_DEBUG_VERBOSE, "rcs_locked: running %s",
X	    command));
X    return (system(command) == 0);
}
X
static int rcs_uptodate(bcs_obj_type bcs_obj, char *filename)
{
X    char command[2 * MAXPATHLEN];
X
X    sprintf(command, "/bin/sh -c \"%s %s > /dev/null 2>&1\"",
X	    RCSDIFF_PATH, filename);
X    DPRINT((bcs_obj, BCS_DEBUG_VERBOSE, "rcs_uptodate: running %s",
X	    command));
X    return (system(command) == 0);
}
X
static int rcs_update_bl(bcs_obj_type bcs_obj, bcs_file_info file_info)
{
X    char command[2 * MAXPATHLEN];
X
X    if (! fi_bl_info(bcs_obj, file_info))
X    {
X	bcs_message(bcs_obj, stderr,
X		    "rcs_update_bl called with file_info with no bl_info");
X	abort();
X    }
X
X    sprintf(command, "%s %s", CO_PATH,
X	    fi_clean_path(bcs_obj, fi_bl_info(bcs_obj, file_info)));
X    DPRINT((bcs_obj, BCS_DEBUG_VERBOSE, "rcs_update_bl: running %s",
X	    command));
X    return (system(command) == 0);
}
X
static int rcs_register_file(bcs_obj_type bcs_obj, char *bl_filename,
X			     char *st_filename)
{
X    char workpath[MAXPATHLEN];
X    char dirpath[MAXPATHLEN];
X    char *p;
X    int status;
X    char cmd[2 * MAXPATHLEN];
X    bcs_file_info file_info;
X    int mode = 0444;
X    struct stat statbuf;
X
X    strcpy(workpath, bl_filename);
X    strcpy(dirpath, bl_filename);
X
X    /* Make the RCS directory if it doesn't exist */
X    if ((p = strrchr(dirpath, PATH_SEP_CHAR)) == NULL)
X	p = dirpath;
X    else
X	p++;
X
X    strcpy(p, RCS_DIR);
X
X    if (! bcsi_exists(bcs_obj, dirpath))
X    {
X	if (mkdir(dirpath, 0777) == -1)
X	{
X	    bcs_message(bcs_obj, stderr, "mkdir %s failed: %s",
X			dirpath, error_string(errno));
X	    return BCS_ERR_SYSTEM;
X	}
X    }
X
X    /*
X     * Create the file locked initially. 
X     * If the file exists in the staging area already, preserve its mode
X     * (except for write permission) if possible.
X     */
X
X    if (bcsi_lstat(bcs_obj, st_filename, &statbuf) != -1)
X    {
X	/*
X	 * It doesn't matter whether there are write permissions; these
X	 * will be eliminated when the file is checked in anyway.
X	 */
X	mode = statbuf.st_mode;
X    }
X    if (! bcsi_exists(bcs_obj, bl_filename))
X    {
X	if ((status = bcsi_create_empty_file(bcs_obj, bl_filename, mode)))
X	    return status;
X    }
X    sprintf(cmd, "%s -t-\"\" -l %s", CI_PATH, bl_filename);
X    if (system(cmd) != 0)
X	return BCS_ERR_SYSTEM;
X    /* It doesn't really matter whether this fails... */
X    (void) chmod(bl_filename, (mode & S_IXUSR) ? 0555 : 0444);
X
X    /* Make sure the RCS directory exists in the staging area */
X    file_info = bcs_get_file_info(bcs_obj, dirpath);
X    if (file_info == NULL)
X    {
X	bcs_message(bcs_obj, stderr,
X		    "can't get file information for %s which we just "
X		    "checked for!", dirpath);
X	return BCS_ERR_SYSTEM;
X    }
X
X    bcsi_concat_paths
X	(workpath,
X	 bcs_obj->staging->data[fi_index(bcs_obj, file_info)]->path.user_path,
X	 fi_rel_path(bcs_obj, file_info));
X
X    status = bcsi_sync_file(bcs_obj, file_info, FALSE);
X    return status;
}
X
/*
X * This routine takes a set of arguments and returns a stringlist
X * containing those that are filenames.  The stringlist points into
X * the argv array.
X */
bcs_stringlist rcs_get_file_args(bcs_obj_type bcs_obj, char *argv[])
{
X    char **arg;
X    bcs_stringlist list;
X
X    list = (bcs_stringlist) fl_new_flex_list(bcs_obj->whoami);
X
X    for (arg = argv; *arg; arg++)
X    {
X	if ((*arg)[0] != '-')
X	{
X	    fl_add_to_tail(bcs_obj->whoami, (flex_list) list, *arg);
X	}
X    }
X
X    return list;
}
X
/*
X * PUBLIC FUNCTIONS
X */
X
void cm_register_rcs(bcs_obj_type bcs_obj)
{
X    cm_command *cmd;
X
X    for (cmd = rcs_cmds; cmd->name; cmd++)
X	cmd->get_file_args = rcs_get_file_args;
X
X    rcs_cm.name = "RCS";
X    rcs_cm.cmds = rcs_cmds;
X    rcs_cm.precious_files = rcs_precious;
X    rcs_cm.haslog = rcs_haslog;
X    rcs_cm.locked = rcs_locked;
X    rcs_cm.uptodate = rcs_uptodate;
X    rcs_cm.update_bl = rcs_update_bl;
X    rcs_cm.register_file = rcs_register_file;
X
X    cm_register(bcs_obj, &rcs_cm);
}
X
#else /* HAVE_RCS */
X
void cm_register_rcs(bcs_obj_type bcs_obj)
{
X    return;
}
X
#endif /* HAVE_RCS */
SHAR_EOF
chmod 0444 bcs-2.0/lib/rcs_cm.c ||
echo 'restore of bcs-2.0/lib/rcs_cm.c failed'
Wc_c="`wc -c < 'bcs-2.0/lib/rcs_cm.c'`"
test 7475 -eq "$Wc_c" ||
	echo 'bcs-2.0/lib/rcs_cm.c: original size 7475, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/lib/rcs_cm.h ==============
if test -f 'bcs-2.0/lib/rcs_cm.h' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/lib/rcs_cm.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/lib/rcs_cm.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/lib/rcs_cm.h' &&
/* 
X * $Id: rcs_cm.h,v 1.5 1994/03/07 21:47:41 qjb Exp $
X * $Source: /local/tmp/bcs-2.0/lib/RCS/rcs_cm.h,v $
X * $Author: qjb $
X *
X * Copyright (C) 1994  E. Jay Berkenbilt
X * 
X * This file is part of BCS.  BCS may be distributed according to the terms
X * of the General Public License and/or the Artistic License.  See the
X * `COPYING' and `Artistic' files with the source distribution for details.
X * This notice must be kept intact when this file is distributed.
X *
X * This file defines parameters for RCS support
X */
X
#ifndef __BCS_RCS_CM_H__
#define __BCS_RCS_CM_H__
X
#if !defined(lint) && !defined(CODECENTER) || defined(RCS_HDRS)
/* Define a static function and call it.  No warnings this way. */
static void rcsid_bcs_rcs_cm_h(char *s)
{rcsid_bcs_rcs_cm_h("@(#)$Id: rcs_cm.h,v 1.5 1994/03/07 21:47:41 qjb Exp $");}
#endif /* !lint && !CODECENTER || RCS_HDRS */
X
#include "rcs_paths.h"
#define RCS_DIR  "RCS"
#define RCS_SUFFIX ",v"
X
#endif /* __BCS_RCS_CM_H__ */
SHAR_EOF
chmod 0444 bcs-2.0/lib/rcs_cm.h ||
echo 'restore of bcs-2.0/lib/rcs_cm.h failed'
Wc_c="`wc -c < 'bcs-2.0/lib/rcs_cm.h'`"
test 969 -eq "$Wc_c" ||
	echo 'bcs-2.0/lib/rcs_cm.h: original size 969, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/lib/sccs_cm.c ==============
if test -f 'bcs-2.0/lib/sccs_cm.c' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/lib/sccs_cm.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/lib/sccs_cm.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/lib/sccs_cm.c' &&
/* 
X * $Id: sccs_cm.c,v 1.14 1994/03/07 21:47:41 qjb Exp $
X * $Source: /local/tmp/bcs-2.0/lib/RCS/sccs_cm.c,v $
X * $Author: qjb $
X *
X * Copyright (C) 1994  E. Jay Berkenbilt
X * 
X * This file is part of BCS.  BCS may be distributed according to the terms
X * of the General Public License and/or the Artistic License.  See the
X * `COPYING' and `Artistic' files with the source distribution for details.
X * This notice must be kept intact when this file is distributed.
X *
X * This file implements SCCS support for BCS.  The whole file
X * is #ifdefed based on whether or not we have SCCS.  This is
X * defined in an automatically generated header file created
X * at build-time.
X */
X
#if !defined(lint) && !defined(CODECENTER) || defined(RCS_HDRS)
/* Define a static function and call it.  No warnings this way. */
static void rcsid(char *s)
{rcsid("@(#)$Id: sccs_cm.c,v 1.14 1994/03/07 21:47:41 qjb Exp $");}
#endif /* !lint && !CODECENTER || RCS_HDRS */
X
#include "bcs_p.h"
#include "sccs_cm.h"
X
#ifdef HAVE_SCCS
X
static bcs_cm_info sccs_cm;
X
static cm_precious sccs_precious[] = {
{ "SCCS", cm_dir },
{ NULL, cm_none },
};
X
/* Must fill in get_file_args later since it is not a constant. */ 
static cm_command sccs_cmds[] = {
{ "edit", NULL, cm_checkout, NULL },
{ "get", NULL, cm_checkout, NULL },
{ "deledit", NULL, cm_checkin, NULL },
{ "delget", NULL, cm_checkin, NULL },
{ "unedit", NULL, cm_checkin, NULL },
{ "unget", NULL, cm_checkin, NULL },
{ NULL, NULL, 0, NULL},
};
X
/*
X * PRIVATE FUNCTIONS
X */
X
/*
X * Test whether a file has an SCCS log.  A file does not have to
X * exist to have a log.
X */
static int sccs_haslog(bcs_obj_type bcs_obj, char *filename)
SHAR_EOF
true || echo 'restore of bcs-2.0/lib/sccs_cm.c failed'
fi
echo 'End of bcs-2.0 part 3'
echo 'File bcs-2.0/lib/sccs_cm.c is continued in part 4'
echo 4 > _shar_seq_.tmp
exit 0
