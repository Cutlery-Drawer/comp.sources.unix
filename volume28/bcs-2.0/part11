Newsgroups: comp.sources.unix
From: ejb@ERA.COM (Jay Berkenbilt)
Subject: v28i012: bcs-2.0 - A Baseline Configuration System, Part11/25
References: <1.764985670.1461@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: ejb@ERA.COM (Jay Berkenbilt)
Posting-Number: Volume 28, Issue 12
Archive-Name: bcs-2.0/part11

#!/bin/sh
# this is bcs.11 (part 11 of bcs-2.0)
# do not concatenate these parts, unpack them in order with /bin/sh
# file bcs-2.0/doc/bcs.texinfo continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 11; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping bcs-2.0/doc/bcs.texinfo'
else
echo 'x - continuing file bcs-2.0/doc/bcs.texinfo'
sed 's/^X//' << 'SHAR_EOF' >> 'bcs-2.0/doc/bcs.texinfo' &&
@comment  node-name,  next,  previous,  up
@subsubsection The Problem
RCS was not designed to be a concurrency management system.
Instead, it was designed to be a system to handle preventing
multiple users from working on a given file simultaneously.  In
a system such as RCS in which a file is owned and locked by a
single user, concurrency problems are detected at the time when
a file is checked out.  In other configuration management
paradigms, these problems are delayed until the files are
checked in at which point a merge is performed.
X
Given the structure and organization of many baselines, neither
solution is always practical.  If only one lock per file is
allowed, people will not be able to make progress on changes
that require edits to be made in large numbers of files.
However, if conflict resolution is postponed until checkin,
merge problems will consume the majority of every developer's
time.
X
@node Stability Solution, Example of Stability Problem, Stability Problem, Maintaining Baseline Stability
@comment  node-name,  next,  previous,  up
@subsubsection A Possible Solution
Given the above situation, the following incremental merging
procedure is proposed.  At present, this procedure will need to
be followed manually.  If it turns out to work well enough,
perhaps it can be refined and incorporated into a future version
of BCS.  
X
Under the current BCS paradigm, files can be checked in multiple
times before being updated in the baseline.  This means that it
is possible for the last stable version of a file to be earlier
than the last version that has been checked into RCS.
This means that if another user does an
@code{update_baseline} on this file, an unstable version will appear in
the baseline.  Likewise, when a user checks a file out, he or
she will have, in the staging area, a file that may contain
someone's untested, incremental edits.  To avoid this situation,
we must enforce that a revision will be added to the default
branch of a file only when it is tested and considered stable.  
X
To make this possible, all incremental changes to a file must be
made on a branch originating from the latest revision on the main
branch.  When the changes made in a given branch are ready to be
merged into the baseline, coordination is required between all
holders of a given branch.  When a suitably merged file exists,
it will be checked into the main branch and updated in the
baseline.  At all times, there will be one developer who is the
@emph{owner} of a file and will be responsible for coordinating
merges of other branches.  This person will be the holder of the
lock on the main branch.
X
The mechanics of this method are probably best explained with
examples since the general concept is somewhat difficult.
X
@node Example of Stability Problem, Stability Implications, Stability Solution, Maintaining Baseline Stability
@comment  node-name,  next,  previous,  up
@subsubsection Example
Suppose the file @file{a.c} currently exists in the baseline and is
stable.  The latest revision on the head branch is revision
@samp{1.4}. 
This revision is not locked and has no branches based upon it.
X
User @samp{A} decides to make some changes to @file{a.c}.  When
user @samp{A} goes to check out the file, the checkout succeeds,
and user @samp{A} acquires a lock on revision @file{1.4} of
@file{a.c}.  As user @samp{A} makes incremental changes and
checkins of @file{a.c}, he or she will start the branch
@samp{1.4.1} from @samp{1.4}.  @samp{A}'s revisions will be
@samp{1.4.1.1}, @samp{1.4.1.2}, etc. 
X
Now user @samp{B} comes along.  When @samp{B} tries to check out
@file{a.c}, the checkout initially fails because user @samp{A}
already has a lock.  In this situation, user @samp{B} contacts
user @samp{A} to discuss the nature of their changes.  If user
@samp{B} needs to make changes that can easily be performed by
user @samp{A}, it may be best for @samp{A} to make the the
changes rather than having @samp{B} get involved.  (An example
would be correcting a typographical error in a comment,
reordering include directives, etc.)  If @samp{B} really needs
to change @file{a.c} at the same time as @samp{A}, then @samp{B}
will use BCS to check out @file{a.c} in his or her own staging
area without a lock, manually give him or herself write
permission, and check in any changes made in the new branch
@samp{1.4.2}.  If a user @samp{C} were to come along, @samp{C} would
have to contact both @samp{A} and @samp{B}.  We will ignore this
case for now and assume that we only have two branches of
@file{a.c}.
X
Now suppose that @samp{B} finishes making changes and determines
that those changes are stable and ready to be put back into the
baseline.  At this point, @samp{B} will want to check in his or
her changes as revision @samp{1.5}.  @samp{A} must therefore
release the lock on @samp{1.4}.  When @samp{B} creates
@samp{1.5} and updates the baseline, @samp{A} should obtain a
lock on revision @samp{1.5} and merge the changes from
@samp{1.4.1.x} to @samp{1.5} into his or her working
@c can't use ~ here inside a footnote...
version.@footnote{The @code{rcsmerge} program is good for this
purpose if the merges are simple.  If they are more complex, the
@code{emerge} facility that comes with GNU Emacs 
version 19
can greatly simplify performing such merges.}  This new merged
file now begins a new branch of @samp{1.5}.  User @samp{A} can
continue making changes from here.  The @samp{1.4.1} branch is
now defunct.
X
Note that if @samp{A} finishes first, @samp{A} can simply notify
@samp{B} and then update the baseline.  @samp{B} can then
acquire a lock on revision @samp{1.5}, merge in his changes, and
continue editing.  BCS 
@ifinfo
version 2.0 
@end ifinfo
@iftex
@tex version~2.0  @end tex
@end iftex
warns during
@code{update_baseline} if any locks exist on the file being
updated.  This should alert the user doing the update that it
may be necessary to warn other users that there are changes to
be merged.  Given this, how do we enforce that @samp{B} be
notified when @samp{A} is ready to update changes?  @samp{A}
might not even remember that there are any other active branches
of revision @samp{1.4}.  One possibility would be for BCS to
send mail to the users who have branches locked.  Another would
be for BCS to warn that this situation exists and require
confirmation from the user before continuing with the update.
Any comments on this can be directed to the author.
X
@node Stability Implications,  , Example of Stability Problem, Maintaining Baseline Stability
@comment  node-name,  next,  previous,  up
@subsubsection Implications
The above situation is quite complex, but the author asserts that the
complexity of performing the above operations is less than it
would be if merges were further delayed.  The above scenario
essentially describes incremental merging.  With this scenario,
all merges are performed as soon as possible rather than as late as
possible.  The above discipline should also reduce the frequency
with which people make gratuitous changes to files in the baseline
when those changes can be delayed.  For example, it would be
appropriate to go through the above hassle if something simple
like changing includes occurs or if two non-conflicting
functionalities implemented in the same file both need to be
changed.  It would not, however, be a good idea to go through
the above if one user wanted to reindent a file that another
user was working on.  In this case, the reindentation should be
performed separately when no other branches exist or should be
performed by the single user who has a lock on the file.  In any
case, such changes should always be isolated via the
configuration management system 
from other changes that are made at the same time 
@iftex
@tex
({\sl i.e.},
@end tex
@end iftex
@ifinfo
(i.e.,
@end ifinfo
check
the file out, reindent, and check in).
X
@node Support for a Multi-platform Environment,  , Multiple Simultaneous Developers, Example Uses of BCS
@comment  node-name,  next,  previous,  up
@section Support for a Multi-platform Environment
@cindex multi-platform support
@cindex porting to multiple platforms
X
Although supporting a multi-platform development environment is
best done outside the configuration management system, there are
certain instances in which the use of BCS can help ease the
process of porting a system to a new architecture.  This section
describes an example of how to approach this problem with BCS.
For an example of how to approach this problem with makefiles,
see the sample baseline included with the BCS distribution in
@file{unsupported/sample-baseline}. 
X
Suppose a fairly stable system exists on a single platform.  The
makefiles (or whatever is used to build the system) and the
system sources are not set up to support easy builds on multiple
platforms.  Assume that all the files required to build and run
the system are controlled in a version control system that is
supported by BCS.  In this situation, a port can be done simply
by making the stable source tree into the BCS baseline.  A
staging area can then be set up in which to build the system on
another platform.  Unless the build procedure is integrated with
BCS, it will be necessary to stage all directories in this
staging area that will contain object files or other
architecture-dependent files.  The sample baseline included with
the BCS distribution includes makefiles that handle these details
automatically.  Once the necessary directories have been staged,
the staging area has essentially the same structure as the
baseline except that the source files and @file{RCS} or
@file{SCCS} directories are symbolic links.  At this point, BCS
commands can be used to check out files, make changes, and test
the results before merging the patched code into the stable
baseline.  It would even be possible to use the staging area to
build on the original platform to make sure that the changes
didn't break the previous system.  Once the port had been
completed and tested, the baseline could be updated, and the
port would be complete.
X
@node Possible Future Enhancements, Acknowledgments, Example Uses of BCS, Top
@comment  node-name,  next,  previous,  up
@chapter Possible Future Enhancements
@cindex future enhancements
X
This section describes a few ideas for future expansion of BCS.
These features, if they are implemented, will not be part
@ifinfo
of 2.0, 
@end ifinfo
@iftex
@tex of~2.0,  @end tex
@end iftex
but will probably still be part of major 
@ifinfo
version 2.
@end ifinfo
@iftex
@tex version~2. @end tex
@end iftex
These changes could be made without fundamental change to the
way BCS works and without radically changing the semantics of
existing commands.
X
@menu
* Hierarchical Staging Areas::  
* Secure Baseline::             
@end menu
X
@node Hierarchical Staging Areas, Secure Baseline, Possible Future Enhancements, Possible Future Enhancements
@comment  node-name,  next,  previous,  up
@section Hierarchical Staging Areas
@cindex hierarchical staging areas
@cindex inherited staging areas
X
In BCS 
@ifinfo
version 2.0, 
@end ifinfo
@iftex
@tex version~2.0,  @end tex
@end iftex
the baseline/staging area structure is
two-tiered: the baseline is the authoritative copy of the
controlled files, and the staging areas are all equal and all
inherit directly from the baseline.  Certain assumptions are
made about the baseline including that the @file{RCS} or
@file{SCCS} directories are actually directories and that the
baseline is self-contained.
X
There are many instances in which it would be useful to have a
hierarchical system of staging areas.  In this paradigm, there
would still be a single, authoritative baseline.  Staging areas,
however, could either inherit directly from the baseline, or
they could inherit from other staging areas.  A command (perhaps
called @code{promote}) could be added to BCS that would be
similar to @code{update_baseline} except that it would
promote a file up one level in the staging area hierarchy.  If
one staging area inherits from another, the inheritance could be
set up using a configuration file at the top-level of the
staging area in much the same way the @file{.baseline_path} file
is used now.  BCS could do some amount of loop detection and
validation to make sure that the given staging area eventually
points back to the baseline.  There could be several possible
applications for such a setup.  Some are considered here.
X
@menu
* Integration of Changes in Two Staging Areas::  
* Maintenance of Multiple Revisions of Software::  
@end menu
X
@node Integration of Changes in Two Staging Areas, Maintenance of Multiple Revisions of Software, Hierarchical Staging Areas, Hierarchical Staging Areas
@comment  node-name,  next,  previous,  up
@subsection Integration of Changes in Two Staging Areas
@cindex integrating changes
X
In the current BCS paradigm, each staging area is generally
maintained by a single developer.  Changes are made and tested in
this staging area.  Once they are stable, the files are updated
directly into the baseline.  One can easily imagine situations
in which a major piece of functionality in a system is being
changed, and more than one developer works on different parts of the
change.  Although each developer will generally be able to do
some testing in his or her private staging area, a separate
staging area may be needed to do some integration testing before
imposing the changes on the baseline.  In the current BCS
implementation, this can be done, but it requires manually
checking out the correct versions of files in the new staging
area.  In a BCS that supports hierarchical staging areas, each
developer would merely reparent his or her staging area, run
@code{sync_staging}, and then promote files that are ready
for integration.  Integration could be done in this special
staging area, and then, when changes are tested, integrated, and
shown to be stable, the baseline could be updated.  
X
Such integration staging areas could be created on the fly for
particular purposes, or they could be in place for the duration
of a development effort.  One can imagine situations in which
all developers of all levels would have access to update the staging
area that is the parent of their individual staging areas, but
that only more experienced developers or baseline administrators
could update the baseline.  This way, users would be free to
promote changes for thorough integration testing without
intervention, but could still be denied write access to the
baseline.  
X
@node Maintenance of Multiple Revisions of Software,  , Integration of Changes in Two Staging Areas, Hierarchical Staging Areas
@comment  node-name,  next,  previous,  up
@subsection Maintenance of Multiple Revisions of Software
@cindex multiple software revisions
X
If BCS had the ability to have one staging area inherit from
another, then it would automatically have the ability to support
baselines whose @file{RCS} or @file{SCCS} directories are
symbolic links.  If the additional feature of supporting default
revisions for a staging area were supported, then a single set
of version control logs could underlie, say, a maintenance or
bug-fix area for 
@ifinfo
version 1 
@end ifinfo
@iftex
@tex version~1  @end tex
@end iftex
of a system and a development area
for 
@ifinfo
version 2.  
@end ifinfo
@iftex
@tex version~2.   @end tex
@end iftex
All users who are working maintaining 
@ifinfo
version 1
@end ifinfo
@iftex
@tex version~1 @end tex
@end iftex
could inherit from a special staging area that has 
@ifinfo
version 1 
@end ifinfo
@iftex
@tex version~1  @end tex
@end iftex
as
its default, and all users working on new development could
inherit from the baseline directly or from another staging area
set up for 
@ifinfo
version 2 
@end ifinfo
@iftex
@tex version~2  @end tex
@end iftex
development.  Exactly how this would work
is not yet known, but it would probably be based on having BCS
automatically specify a revision when checking files in or out
based on some information in a per-staging-area configuration
file. 
X
@node Secure Baseline,  , Hierarchical Staging Areas, Possible Future Enhancements
@comment  node-name,  next,  previous,  up
@section Secure Baseline
@cindex secure baseline
@cindex restricting access
X
Depending on the size of a project and on other constraints, it
is sometimes desirable to restrict who has what access to the
baseline.  One could divide security levels of the baseline into
these categories:
@itemize @bullet
@item
All users have write-access to the baseline directories.
No restrictions are put upon who can check files in or out, 
update the baseline, or register new files.
X
@item
Only authorized users can check files in, register files,
or update the baseline, but any user can check files out.
X
@item 
Only authorized users can perform any operations that
require modification of the baseline or history logs.
@end itemize
X
The first and third of the above conditions can be achieved with
file protections alone.  The second configuration is difficult
to achieve this way because configuration management packages
such as RCS and SCCS require the user to have write access to
the baseline in order to lock files.  To compensate for this,
BCS could operate in secure mode.  In secure mode, the
@code{bcs} command could be installed @dfn{setuid}.  It could
effectively become a user with write-access to the baseline for
the locking operation.  This way, access to the baseline could be
restricted to all but a small group of users without losing the
ability for individual users to check files out as needed.  This
would also prevent unauthorized users from operating on baseline
files with the underlying configuration management commands directly.
X
Whether or not a baseline would operate in secure mode could be
controlled by a flag in the @file{.baseline_conf} file.  The
security mentioned above assumes that the underlying file system
is secure and that setuid operation of bcs commands is
permitted.
X
At present, there seems to be much less demand for this type of
secure operation than there is for hierarchical staging areas,
especially since much of this functionality could be achieved
that way as well.
X
@node Acknowledgments, Internals, Possible Future Enhancements, Top
@comment  node-name,  next,  previous,  up
@chapter Acknowledgments
@cindex acknowledgments
X
So many people have supported my development of BCS that there
it would be difficult to list all of them here by name.  I'd
like to thank all the people at Engineering Research Associates
who served as my alpha testers and who supported me in
developing this software on my own time and distributing it
under the terms of the General Public License and/or the
Artistic License.  I am also appreciative to the beta testers
out in netland who have offered many helpful suggestions and
exposed the software to valuable testing.  I also thank my wife,
Lisa (also a BCS alpha tester), for allowing me to spend several
consecutive weekends working on BCS.  I couldn't have completed
this project without her support.
X
@node Internals, Index, Acknowledgments, Top
@comment  node-name,  next,  previous,  up
@appendix Internals
X
This section partially documents the internals of BCS.
Information covered includes algorithms and data structures
used, design intent, etc.
X
@menu
* Overview of Internals::       
* Classification of Files::     
* Caching File System Information::  
* The File Information Table::  
* Debugging::                   
* Configuration Management Package Interface::  
* Staging and Synchronization::  
* Unstaging Files and Directories::  
@end menu
X
@node Overview of Internals, Classification of Files, Internals, Internals
@comment  node-name,  next,  previous,  up
@appendixsec Overview
X
BCS exists to manipulate people's source code.  It therefore
must be extremely conservative about what it does.  This means
that operations should be atomic when possible and that there
should always be some reasonable recovery from errors and
user-initiated aborts.  BCS should never delete files
haphazardly.  Deleting symbolic links in the staging area that
don't point anywhere or don't have corresponding files or links
in the baseline is acceptable as is deleting files when
unstaging directories provided that the necessary checks have been
made.
X
BCS should be efficient and should avoid doing multiple accesses
to the file system for the same file.  This means that an
invocation of a BCS command will typically result in a large
amount of information being cached.
X
BCS is based on top of configuration management packages.  RCS
is the recommended package, but BCS is
implemented in a way that makes it easy to plug in
other packages as well.  This document explains how BCS interfaces
with its underlying configuration management packages.
X
BCS implements a baseline and multiple staging areas.  With the
exception of printing help messages and version information, all
BCS operations require the baseline and staging area to be
identified in the environment or on the command line.  A
configuration file must exist at the top-level of each baseline
directory.  This configuration file must specify what the
baseline's configuration management package is, etc.
X
@node Classification of Files, Caching File System Information, Overview of Internals, Internals
@comment  node-name,  next,  previous,  up
@appendixsec Classification of Files
@comment index entries for this topic point a node in the "use" section
The basis of BCS involves being able to distinguish between
important and unimportant files.  Every file is either important
or unimportant.  Determination of the importance of a file is
done based upon the underlying configuration management system
and other constraints.
X
A file's importance is determined in several ways.  This
discussion of importance applies to files in the baseline.
Files in the staging area that do not have corresponding files
in the baseline are considered unimportant.  (The exception is
internal files which are always considered important.)  Other
staging area files inherit their importance from their baseline
counterparts.  The only circumstance under which a staging area
file will have a different importance from its baseline counterpart
is if instances of filenames that are used internally by the
BCS in the baseline appear in the staging area.
In this case, they are unimportant in the staging area and
important in the baseline.  (This would include @file{.important},
@file{.unimportant}, @file{.auto_stage}, @file{.no_stage},
and @file{.unimp_nowarn} at any level, and @file{.baseline_conf}
at the top 
level.  The contents of files are ignored by the utilities if
they are encountered in the staging area.  There is no reason
for these files to exist in the staging area.)
X
Every file has an importance which can be overridden explicitly.
By default, files in the baseline that are neither symbolic
links nor directories files are important if they are registered
with the underlying configuration management package and are
unimportant otherwise. 
Directories are considered important by default.  Symbolic links
to files in the baseline inherit their importance from the files
they are ultimately linked to.  Symbolic links to files outside
of the baseline are unimportant by default.  A file or directory
can be made explicitly unimportant by appearing in the
@file{.unimportant} file or made explicitly important by appearing in
the @file{.important} file in its containing directory.  If a file
appears in both a @file{.important} file and a
@file{.unimportant} file, it is considered important.  A
@file{.important} file containing only @samp{*} means all files are
important in that directory.  The @file{.important} file cannot
contain regular expressions in general; @samp{*} is a special
case.
X
@node Caching File System Information, The File Information Table, Classification of Files, Internals
@comment  node-name,  next,  previous,  up
@appendixsec Caching File System Information
@cindex file information caching
X
When analyzing performance of BCS, it became evident that the
most expensive operations by far were calls to the
@code{lstat} system call.  This call is used to obtain specific
information about a named file from the file system.
Since BCS requires frequent access to the layout of the file
system and into specific information about files, this
information is cached.  The cache is implemented as a tree that
has the same shape as the file system.  When files are removed,
they are removed from the cache as well.  Since the cache is
structured to be parallel to the file system, the chance of an
inconsistency appearing in the cache is very low.
X
@node The File Information Table, Debugging, Caching File System Information, Internals
@comment  node-name,  next,  previous,  up
@appendixsec The File Information Table
@cindex file information table
X
All information needed about files
encountered in an invocation of BCS is cached in a table which
will be referred to as the @dfn{file information table}.  The
file information table consists of a number of file information
structures which are stored in the file system cache described
above. 
X
A file information structure contains all the information needed
about a file for determining its importance and its eligibility
for being staged.  Some information about whether the file is
eligible to be unstaged is stored as well.  See the definition
of @code{bcs_file_info_rec} in @file{file_info.h} for
the specific fields. 
X
To explicitly populate the table, the
@code{bcs_examine_dir} routine is called with a directory
name and a recursive flag.  If the recursive flag is set, the
directory is inserted recursively.  For each directory, all the
files in the directory are checked and inserted in the table.
If the directory is in the staging area, the directory's
baseline counterpart is searched too.
@dfn{Precious directories} (those used internally by configuration
management packages) are omitted from the list of directories
and are not searched recursively.  A pointer to a callback
function is passed to this routine.  If the pointer is
non-@code{NULL}, the function is called with passed in data,
the global bcs state object, and the current file information
structure for item found by @code{bcs_examine_dir}.  The
@code{bcs_examine_dir} function is organized in such a way
that the callback is called on file information structures in
sorted order.  This
way, commands such as @code{classify_files} or
@code{id_staged} can call 
@code{bcs_examine_dir} once with a callback function and
avoid multiple lookups or long delays before the user sees any
results.
X
An individual file can be looked up in the table by name with the
@code{bcs_get_file_info} routine.  If a file's information is
found in the table, it is returned.  Otherwise, a new file
information structure is allocated and inserted into the table.
Individual fields of the file information structure are not
computed until they are needed.
X
@node Debugging, Configuration Management Package Interface, The File Information Table, Internals
@comment  node-name,  next,  previous,  up
@appendixsec Debugging
@cindex debugging
X
If BCS was compiled with debugging enabled, the environment
variable @code{DEBUG_BCS} is checked when the utilities
initialize.  The value of this variable can be overridden with
the @code{--debug} option on the commandline.  If no
debugging information is requested, none will be printed.  This
variable consists of a colon-separated list of lower-case
keywords specifying what kind of information should be
displayed.  Valid keywords are
X
@table @code
@item logic
Print information about major decisions and
why they are being made;
X
@item trace
Print information about function calls and
returns;
X
@item verbose
Print verbose messages at certain times;
X
@item path
Print message specific to pathname processing;
X
@item all
All debugging is turned on;
X
@item none
Turn off debugging information.  This keyword
is ignored if accompanied by other options.  Any keyword
other than one mentioned above will serve this purpose. 
X
@end table
X
Note that information printed by these debug flags are only as
complete as was necessary during the development.  For example,
turning on @code{trace} does not trace all function calls and
does not always print all the information that would be useful
when a function is entered or exited.  Even so, running BCS with
@code{--debug all} will produce a considerable volume
of output.
X
@node Configuration Management Package Interface, Staging and Synchronization, Debugging, Internals
@comment  node-name,  next,  previous,  up
@appendixsec Configuration Management Package Interface
@cindex configuration management package interface
@cindex supporting new configuration management package
X
BCS implements generic support for underlying configuration
management packages.  In order for BCS to provide a front end to
various configuration management packages, it needs to know a
specific set of things about each underlying package.
Specifically, it needs to know the following:
X
@itemize @bullet
X
@item The name of the package;
X
@item The list of commands that are needed for checkin and
X      checkout operations and which operation they perform;
X
@item What files are for internal use by the configuration
X      management system (referred 
X      to as @dfn{precious} files since they must always exist);
X
@item How to tell whether a file has a log;
X
@item How to tell whether a file is up-to-date;
X
@item How to update the baseline copy of a file;
X
@item How to register a new file with the system.
X
@end itemize
X
Adding support for a new configuration management system is a
matter of writing code to implement the above functions.  See
@file{cm.h} for definitions of the appropriate structures.  If
you wish to add support for a new configuration management
package, look at the implementation of RCS and SCCS support.  To
implement support for a new configuration management package, a
source and header file to implement the above functionality must
be added.  This file fills in the fields of a structure which is
returned by the one externally callable routine in the file: the
register routine.  A prototype for this routine should be added
to @file{cm.h} and a call to it should be placed in
@file{init.c}.  In addition, of course, the makefile will need
to be modified so that the file is compiled and linked in to the
system.  No other changes should be required for implementation
of a new configuration management package.  It is possible that
other changes may be made if the configuration management
package has some needs that are not handled by the current
interface.  If this is the case, extreme care should be made to
avoid putting any package-specific knowledge into the code.
Support for a configuration management package should be
implemented so that BCS will still compile and run without that
configuration management package present.  Look at support for
RCS and SCCS for one way to do this.
X
For checkin and checkout of files, the @code{bcs} command itself
is used.  It takes as arguments a command with arguments.  It
determines what kind of operation the given command is with
respect to the underlying configuration management package so it
can know whether it needs to stage files or not.  Once it makes
sure that the necessary prerequisites have been met and that
this file is eligible for the specified operation, it will
invoke the underlying configuration management package's command
as passed in on the commandline.
X
When classifying files, BCS must be able to determine whether a
file has a history log since this determines the default
importance of files.  When synchronizing and staging, BCS must
know what files or directories must exist in the staging area
for the shared history log support to work.  In the case of RCS
or SCCS, this is the RCS or SCCS directory.  It is conceivable
that other files or directories could be needed for other
configuration management packages.  BCS tries to be general
about this, but it is possible this this functionality would
require modification for configuration management packages that
don't work basically like RCS.  These special files or
directories, which we refer to as @dfn{precious}, are always
important and unstageable.  This cannot be overridden with
@file{.auto_stage} or @file{.unimportant} files.
X
When unstaging files, BCS warns if a file has not been updated
in the baseline.  The configuration management package support
must include a function to tell this for this purpose.
X
The list of supported configuration management packages is
determined at compile-time.  A configuration management package
becomes supported by BCS by being registered.  To register a
configuration management package, a structure containing
function pointers and other information must be passed to the
register function.  BCS enforces that a specific baseline
(possibly including multiple top-level directories) only uses
one configuration management package.  When the baseline
configuration files are read at startup, BCS activates the
information about a specific configuration management package by
name.  If that configuration management package was registered,
everything is fine, and BCS can proceed without knowing any of
the details about the configuration management package.
X
@node Staging and Synchronization, Unstaging Files and Directories, Configuration Management Package Interface, Internals
@comment  node-name,  next,  previous,  up
@appendixsec Staging and Synchronization
@cindex staging
@cindex synchronization
X
The staging and synchronization operations are tightly
integrated.  They are defined here in terms of each other.
Synchronization of the staging area is the process of assuring
that the contents of the staging area are consistent with those
of the baseline.  The staging area should always contain all
important baseline files either directly or in the form of
symbolic links.  The only symbolic links that are allowed to appear
in the staging area are links to their own baseline
counterparts, links whose baseline counterparts are also links
that point to the same place, and links that point within the
staging area to unimportant files.  The reason for allowing the
last case is that such links may be makefile targets.  (For
example, if a makefile causes the creation of an executable file
along with several links to it, those links will only have
baseline counterparts if the target has been built in the
baseline.  Even if they do have baseline counterparts, they will
not be important.  Even so, it would be undesirable for
@code{sync_staging} to remove those links.)
X
The following steps are performed by the @code{sync_staging}
command. All steps are done recursively if requested.
X
@itemize @bullet
X
@item Verify that all directories requested are in the staging area.
X      Stop if any of them are not suitable.
@item Examine requested directories' baseline counterparts.
@item For each important file in the baseline that is not marked
X      (internally) as
X      @code{no_mirror},@footnote{Only internal files are marked this
X      way.} make sure the corresponding file exists in the 
X      staging area. 
X   @itemize @minus
X   @item If the file in the baseline is a file and the file in the
X	 staging area is a file, do nothing.
X   @item If the file in the baseline is a file and the file in the
X	 staging area doesn't exist or is a link to other than its
X	 baseline counterpart, make it a link to its baseline
X	 counterpart.  If the file has autostage status, stage
X	 the file.
X   @item If the file in the baseline is prohibited from being
X	 staged and the file is staged in the staging area,
X	 print a warning to that effect.  @emph{Do not remove the
X	 file in the staging area.} 
X   @item If the file in the baseline is a link and the file within
X	 the staging area is a file, print a warning to that effect.
X	 @emph{Do not remove the file in the staging area.}
X   @item If the file in the baseline is a link and the file in the
X	 staging area is a link or does not exist
X       @itemize @bullet
X       @item If the baseline file is a link to outside the baseline,
X	     make the staging area file a link to the baseline file.
X       @item If the baseline file is a link to within the baseline,
X	     make the staging area file a link to the corresponding
X	     file in the staging area.
X       @item If the file is a dangling link, remove the staging area
X	     link if one exists.  (Dangling links without
X	     baseline counterparts are also removed, but not in
X	     this step.)
X       @end itemize
X   @end itemize
@item Re-examine the staging area directories to take into account
X      the new files that could have been created.
@item For each link in the staging area that is unimportant,
X      do nothing if it points to an unimportant file within the
X      staging area.  Otherwise, remove it.  The reasoning here is
X      that, in general, unimportant links should be removed.  This
X      way, if an internal link is removed in the baseline,
X      @code{sync_staging} will cause it to be removed in
X      the staging area as well if it was originally created
X      by @code{sync_staging}.  The exception would be internal
X      links that were created manually to other unimportant
X      files.  @code{sync_staging} should leave these 
X      alone. 
X
@end itemize
X
For full details, read the source.  The heart of the algorithms
are implemented in @file{staging.c} in the routine
@code{bcsi_sync_staging_dir} and 
@code{sync_file}.
X
Staging a file or directory is simply replacing a symbolic
link in the staging area with an actual file or directory.  In
order for a file to be a candidate for being staged, it must be
a link to its baseline counterpart (which must exist) and must
not be explicitly forbidden from being staged.  Staging a file
involves removing the link and copying the file, preserving the
file's mode.  Staging a directory involves replacing the link
with an empty directory whose mode is based on the user's umask
and then synchronizing that directory with the baseline.
X
The complicated part of staging is determining whether a file is
eligible to be staged.  Part of this determination may be based
on the actual path used to refer to the file.  Specifically,
determining eligibility for being staged involves two steps.  A
file is directly eligible if it is a link to its baseline
counterpart and not explicitly forbidden from being staged.  In
addition, its baseline counterpart cannot be a link.  A file is
indirectly eligible to be staged if it is logically part of the
staging area but is actually in the baseline because of crossing
through symbolicly linked directories.  In order to be a
candidate for indirect 
eligibility for being staged, the file must fail direct
qualification only by virtue of being in the baseline.  In this
case, the following is done recursively:
X
@itemize @bullet
X
@item The directory portion of the non-canonicalized path to the
X      file is checked for eligibility.
X   @itemize @minus
X   @item If it is directly eligible, then the original file can be
X	 staged.  This directory becomes a @dfn{prerequisite
X	 directory}.
X   @item If it is indirectly eligible, repeat this procedure
X	 recursively on this directory.  This directory becomes
X	 a prerequisite directory.
X   @item Otherwise, the original file is not eligible.
X   @end itemize
X
@end itemize
X
In the case of an indirectly eligible file, all prerequisite
directories are staged first.  Then, the actual file is staged.
X
@node Unstaging Files and Directories,  , Staging and Synchronization, Internals
@comment  node-name,  next,  previous,  up
@appendixsec Unstaging Files and Directories
@cindex unstaging
X
Unstaging files and directories can be a potentially dangerous
operation since BCS may actually remove files in the staging
area in this situation.  In order to make the operation as safe
as possible certain precautions are taken.
X
Unstaging a file involves replacing the file with a symbolic
link to its baseline counterpart.  For a file to be eligible to
be unstaged, it must be staged.  Unstaging a file that is
already a link to its baseline counterpart is not considered an
error.  No action is taken in this case.  If a file is eligible
to be unstaged, the file is unstaged without confirmation if it
does not have a log in the underlying configuration management
system, is not a directory, and does not end with a suffix
specified in the @file{.baseline_conf} file.  If it does have a
log, it is unstaged without confirmation if the file is not
writable and if it appears to be up-to-date in the baseline.  If
the file has a history log and is writable or does not appear to
be updated, or if the file is an unimportant directory or an
unimportant file with a special suffix, unstaging will occur
only under the following circumstances:
X
@itemize @bullet
X
@item Unstage is run interactively and the user responds
X      affirmatively to a prompt from the software;
@item The @code{--force} or @code{-f} option
X      has been passed to the unstage program. 
X
@end itemize
X
If the @code{--force} flag has not been specified and the program is not
running interactively, the unstage program takes the same action
as it would take in response to a negative reply from the user
to a prompt.  The unstage program is interactive by default if
it is running from a terminal.  (For UNIX programmers, this is
true if @samp{stdin} is a @samp{tty}.)  It can be forced into
interactive mode with the 
@code{--interactive} or @code{-i} flag.
X
Unstaging a directory involves recursively removing the
directory and replacing it with a link to its baseline
counterpart.  A directory is eligible to be unstaged in the same
way a file is; that is, it must be staged.  In addition, all
staged files in the directory must meet all constraints for
unstaging.  Unstaging a directory is an all-or-nothing
operation.  If there are any files in the directory that would
require confirmation before being unstaged, the names of the
files are presented and the user is asked for confirmation once.
Then the entire unstage operation is either performed or
canceled.  The same behavior based on @code{--interactive} or
@code{--force} applies here as does to files.  In both cases, if
the @code{--force} option is given, no checks are performed and
no warnings are issued to the user.
X
If a file is unimportant, removing it in an unstage operation
requires confirmation from the user if the file is a directory
or ends with one of the suffixes specified in the
@code{unimp_warn_suffixes} line in the @file{.baseline_conf}
file.  These confirmations are not required if a
@file{.unimp_nowarn} file exists in 
the baseline directory for these files.  A good use of this is
to add the line
X
@example
unimp_warn_suffixes: .c .h .cc
@end example
X
@noindent to a @file{.baseline_conf} file.  Then, unstage will
confirm before 
removing unimportant @samp{.c}, @samp{.h}, or @samp{.cc} files
as well as unimportant 
directories (which would generally exist in the staging area
only if they didn't have baseline counterparts).  This can be a
good check against forgetting to register new files in the
baseline and could potentially prevent the inadvertent loss of
work.  The @file{.unimp_nowarn} file could be useful in a directory
that contains numerous automatically generated source files or
has many suspicious unimportant files for another reason.
This will prevent unstage from asking questions in this
directory without preventing it from asking questions in other
directories.  At present, there is no way to be more specific
about when to ask and when not to ask for confirmation in these
cases.  This could be a possible future expansion.
X
In the case of both files and directories, unstaging autostage
files @emph{is permitted}.  In this case, however, instead of the
files or directories being replaced with links to their baseline
counterparts, they are replaced with freshly staged copies.
This means that unstaging an autostage file is effectively the
same as reverting any changes that were made to it and unstaging
an autostage directory is effectively the same as recursively
removing all unimportant files in it and unstaging its contents.
X
@node Index,  , Internals, Top
@comment  node-name,  next,  previous,  up
@unnumbered Index
X
@printindex cp
X
@contents
X
@bye
SHAR_EOF
echo 'File bcs-2.0/doc/bcs.texinfo is complete' &&
chmod 0444 bcs-2.0/doc/bcs.texinfo ||
echo 'restore of bcs-2.0/doc/bcs.texinfo failed'
Wc_c="`wc -c < 'bcs-2.0/doc/bcs.texinfo'`"
test 111860 -eq "$Wc_c" ||
	echo 'bcs-2.0/doc/bcs.texinfo: original size 111860, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/doc/stagea.fig ==============
if test -f 'bcs-2.0/doc/stagea.fig' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/doc/stagea.fig (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/doc/stagea.fig (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/doc/stagea.fig' &&
#FIG 2.1
80 2
2 1 0 1 -1 0 0 0 0.000 -1 0 0
X	 404 79 344 139 9999 9999
2 1 0 1 -1 0 0 0 0.000 -1 0 0
X	 404 79 384 139 9999 9999
2 1 0 1 -1 0 0 0 0.000 -1 0 0
X	 404 79 424 139 9999 9999
2 1 0 1 -1 0 0 0 0.000 -1 0 0
X	 404 79 464 139 9999 9999
2 1 0 1 -1 0 0 0 0.000 -1 1 0
X	0 0 1.000 4.000 8.000
X	 379 159 364 159 9999 9999
2 1 0 1 -1 0 0 0 0.000 -1 1 0
X	0 0 1.000 4.000 8.000
X	 419 159 404 159 9999 9999
2 1 0 1 -1 0 0 0 0.000 -1 1 0
X	0 0 1.000 4.000 8.000
X	 459 159 444 159 9999 9999
2 1 0 1 -1 0 0 0 0.000 7 0 0
X	 144 79 84 139 9999 9999
2 1 0 1 -1 0 0 0 0.000 7 0 0
X	 144 79 124 139 9999 9999
2 1 0 1 -1 0 0 0 0.000 7 0 0
X	 144 79 164 139 9999 9999
2 1 0 1 -1 0 0 0 0.000 7 0 0
X	 144 79 204 139 9999 9999
2 1 0 1 -1 0 0 0 0.000 7 0 0
X	 84 159 64 219 9999 9999
2 1 0 1 -1 0 0 0 0.000 7 0 0
X	 84 164 104 219 9999 9999
2 1 0 1 -1 0 0 0 0.000 7 0 0
X	 104 239 84 299 9999 9999
2 1 0 1 -1 0 0 0 0.000 7 0 0
X	 104 239 124 299 9999 9999
2 1 0 1 -1 0 0 0 0.000 7 0 0
X	 124 319 124 379 9999 9999
2 1 0 1 -1 0 0 0 0.000 7 1 0
X	0 0 1.000 4.000 8.000
X	 339 159 324 159 9999 9999
4 0 12 12 0 -1 0 0.00000 4 14 7 339 154 A
4 0 12 12 0 -1 0 0.00000 4 14 7 379 154 B
4 0 12 12 0 -1 0 0.00000 4 14 7 419 154 C
4 0 12 12 0 -1 0 0.00000 4 14 21 114 314 RCS
4 0 12 12 0 -1 0 0.00000 4 14 7 79 154 A
4 0 12 12 0 -1 0 0.00000 4 14 7 119 154 B
4 0 12 12 0 -1 0 0.00000 4 14 7 159 154 C
4 0 12 12 0 -1 0 0.00000 4 14 7 59 234 E
4 0 12 12 0 -1 0 0.00000 4 14 7 104 234 F
4 0 12 12 0 -1 0 0.00000 4 14 7 204 154 D
4 0 12 12 0 -1 0 0.00000 4 14 56 119 74 Baseline
4 0 12 12 0 -1 0 0.00000 4 14 49 379 74 Staging
4 0 12 12 0 -1 0 0.00000 4 14 7 464 154 D
4 0 12 12 0 -1 0 0.00000 4 14 35 109 394 a.c,v
4 0 12 12 0 -1 0 0.00000 4 14 21 74 314 a.c
SHAR_EOF
chmod 0444 bcs-2.0/doc/stagea.fig ||
echo 'restore of bcs-2.0/doc/stagea.fig failed'
Wc_c="`wc -c < 'bcs-2.0/doc/stagea.fig'`"
test 1735 -eq "$Wc_c" ||
	echo 'bcs-2.0/doc/stagea.fig: original size 1735, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/doc/stagea.txt ==============
if test -f 'bcs-2.0/doc/stagea.txt' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/doc/stagea.txt (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/doc/stagea.txt (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/doc/stagea.txt' &&
@c character below required to first line from being misindented.
-
X
X              Baseline                           Staging
X                 |                                  |
X        +-----+--+--+-----+                +-----+--+--+-----+
X        |     |     |     |                |     |     |     |
X        |     |     |     |                |     |     |     |
X        |     |     |     |                |     |     |     |
X        A     B     C     D             <--A  <--B  <--C  <--D
X       /\                                                    
X      /  \
X     /    \
X    /      \
X    E      F
X          /\
X         /  \
X        /    \
X       /      \
X      a.c     RCS
X               |
X               |
X               |
X               |
X             a.c,v
SHAR_EOF
chmod 0444 bcs-2.0/doc/stagea.txt ||
echo 'restore of bcs-2.0/doc/stagea.txt failed'
Wc_c="`wc -c < 'bcs-2.0/doc/stagea.txt'`"
test 769 -eq "$Wc_c" ||
	echo 'bcs-2.0/doc/stagea.txt: original size 769, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/doc/stageb.fig ==============
if test -f 'bcs-2.0/doc/stageb.fig' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/doc/stageb.fig (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/doc/stageb.fig (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/doc/stageb.fig' &&
#FIG 2.1
80 2
2 1 0 1 -1 0 0 0 0.000 -1 0 0
X	 404 79 344 139 9999 9999
2 1 0 1 -1 0 0 0 0.000 -1 0 0
X	 404 79 384 139 9999 9999
2 1 0 1 -1 0 0 0 0.000 -1 0 0
X	 404 79 424 139 9999 9999
2 1 0 1 -1 0 0 0 0.000 -1 0 0
X	 404 79 464 139 9999 9999
2 1 0 1 -1 0 0 0 0.000 -1 0 0
X	 344 159 324 219 9999 9999
2 1 0 1 -1 0 0 0 0.000 -1 0 0
X	 344 164 364 219 9999 9999
2 1 0 1 -1 0 0 0 0.000 -1 0 0
X	 364 239 344 299 9999 9999
2 1 0 1 -1 0 0 0 0.000 -1 0 0
X	 364 239 384 299 9999 9999
2 1 0 1 -1 0 0 0 0.000 -1 1 0
X	0 0 1.000 4.000 8.000
X	 379 159 364 159 9999 9999
2 1 0 1 -1 0 0 0 0.000 -1 1 0
X	0 0 1.000 4.000 8.000
X	 459 159 444 159 9999 9999
2 1 0 1 -1 0 0 0 0.000 -1 1 0
X	0 0 1.000 4.000 8.000
X	 319 239 304 239 9999 9999
2 1 0 1 -1 0 0 0 0.000 -1 1 0
X	0 0 1.000 4.000 8.000
X	 379 319 364 319 9999 9999
SHAR_EOF
true || echo 'restore of bcs-2.0/doc/stageb.fig failed'
fi
echo 'End of bcs-2.0 part 11'
echo 'File bcs-2.0/doc/stageb.fig is continued in part 12'
echo 12 > _shar_seq_.tmp
exit 0
