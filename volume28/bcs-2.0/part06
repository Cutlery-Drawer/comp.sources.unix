Newsgroups: comp.sources.unix
From: ejb@ERA.COM (Jay Berkenbilt)
Subject: v28i007: bcs-2.0 - A Baseline Configuration System, Part06/25
References: <1.764985670.1461@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: ejb@ERA.COM (Jay Berkenbilt)
Posting-Number: Volume 28, Issue 7
Archive-Name: bcs-2.0/part06

#!/bin/sh
# this is bcs.06 (part 6 of bcs-2.0)
# do not concatenate these parts, unpack them in order with /bin/sh
# file bcs-2.0/tests/rcs.test continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 6; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping bcs-2.0/tests/rcs.test'
else
echo 'x - continuing file bcs-2.0/tests/rcs.test'
sed 's/^X//' << 'SHAR_EOF' >> 'bcs-2.0/tests/rcs.test' &&
X
&make_dir("$staging");
&write_file("$staging/.baseline_path", "../bl\n");
X
&runtest("register file",
X	 "register_file $staging/src/a.c $staging/src/b.c $staging/src/c.c",
X	 "$baseline/src/RCS/a.c,v.*$baseline/src/a.c\n" .
X	 "initial revision: 1.1\n" .
X	 "done\n" .
X	 "$baseline/src/RCS/b.c,v.*$baseline/src/b.c\n" .
X	 "initial revision: 1.1\n" .
X	 "done\n" .
X	 "$baseline/src/RCS/c.c,v.*$baseline/src/c.c\n" .
X	 "initial revision: 1.1\n" .
X	 "done\n",
X	 0, $pass);
X
&check_condition("permissions", "(-w \"$baseline/src/a.c\")", 0, $pass);
&check_condition("permissions", "(-w \"$staging/src/a.c\")", 1, $pass);
&check_condition("permissions", "(-w \"$baseline/src/b.c\")", 0, $pass);
&check_condition("permissions", "(-w \"$staging/src/b.c\")", 1, $pass);
&check_condition("permissions", "(-w \"$baseline/src/c.c\")", 0, $pass);
&check_condition("permissions", "(-w \"$staging/src/c.c\")", 1, $pass);
X
# Register a file that already exists in baseline
&runtest("register file existing in baseline",
X	 "register_file $staging/src/a.c",
X	 "register_file: can't register $staging/src/a.c since .* " .
X	 "already exists.\n",
X	 6, $pass);
X
&write_file("$staging/src/d.c", "");
X
# Register a file that already exists in staging area
&runtest("register file existing in staging area",
X	 "register_file $staging/src/d.c",
X	 "$baseline/src/RCS/d.c,v.*$baseline/src/d.c\n" .
X	 "initial revision: 1.1\n" .
X	 "done\n",
X	 0, $pass);
X
# Update a writable file
&runtest("update writable file",
X	 "update_baseline $staging/src/a.c",
X	 "update_baseline: not updating baseline copy of $staging/src/a.c " .
X	 "since the staging area copy is writable.\n" .
X	 ".*Is the file checked in.*\n",
X	 6, $pass);
X
# Try to unstage writable file with log
&runtest("unstage writable file with log",
X	 "unstage $staging/src/a.c < /dev/null",
X	 "unstage: $staging/src/a\\.c is writable.\n" .
X	 "unstage: NOT unstaging $staging/src/a\\.c\n",
X	 6, $pass);
X
# Update a file that is writable in the baseline
chmod 0444, "$staging/src/a.c";
chmod 0644, "$baseline/src/a.c";
&runtest("update when baseline file is writable",
X	 "update_baseline $staging/src/a.c",
X	 "update_baseline: not updating baseline copy of $staging/src/a.c " .
X	 "since the baseline copy is writable.\n",
X	 6, $pass);
X
# Update a locked file
chmod 0444, "$staging/src/a.c";
unlink("$baseline/src/a.c");
&write_file("$baseline/src/a.c", "This is a changed file.\n");
chmod 0444, "$baseline/src/a.c";
X
&runtest("update when file is locked", 
X	 "update_baseline $staging/src/a.c",
X	 "update_baseline: WARNING: $staging/src/a.c currently has " .
X	 "outstanding locks.\n" .
X	 "  Please notify the owners of those locks that the " .
X	 "file is being updated.\n" . 
X	 "$baseline/src/RCS/a.c,v.*$baseline/src/a.c\n" .
X	 "revision 1.1\n" .
X	 "done\n" .
X	 "update_baseline: unstaged $staging/src/a.c\n",
X	 0, $pass);
X
X
unlink("$staging/src/b.c");
&write_file("$staging/src/b.c", "This is a file.\n");
X
&runtest("check in",
X	 "bcs ci -u -mchange $staging/src/b.c",
X	 "$staging/src/RCS/b.c,v.*$staging/src/b.c\n" .
X	 "new revision: 1.2; previous revision: 1.1\n" .
X	 "done\n",
X	 0, $pass);
X	 
# Try to unstage a checked-in but not updated file.
&runtest("unstage non-updated",
X	 "unstage $staging/src/b.c < /dev/null",
X	 "unstage: $staging/src/b\\.c.*not.*updated in the baseline;\n" .
X	 "\tchanges may be hidden.\n" .
X	 "unstage: NOT unstaging $staging/src/b\\.c\n",
X	 6, $pass);
X
# Update a checked-in file
&runtest("update",
X	 "update_baseline $staging/src/b.c",
X	 "$baseline/src/RCS/b.c,v.*$baseline/src/b.c\n" .
X	 "revision 1.2\n" .
X	 "done\n" .
X	 "update_baseline: unstaged $staging/src/b.c\n",
X	 0, $pass);
X
X
# Update a file that is already up-to-date
&runtest("check in already updated",
X	 "bcs ci -u -mchange $staging/src/c.c $staging/src/d.c",
X	 "$staging/src/RCS/c.c,v.*$staging/src/c.c\n" .
X	 "file is unchanged; reverting.*\n" .
X	 "done\n" .
X	 "$staging/src/RCS/d.c,v.*$staging/src/d.c\n" .
X	 "file is unchanged; reverting.*\n" .
X	 "done\n",
X	 0, $pass);
X
# Leave one of the files staged
&runtest("update already updated",
X	 "update_baseline $staging/src/c.c $staging/src/d.c",
X	 "update_baseline: $staging/src/c.c is already up-to-date.\n" .
X	 "update_baseline: unstaged $staging/src/c.c\n" .
X	 "update_baseline: $staging/src/d.c is already up-to-date.\n" .
X	 "update_baseline: unstaged $staging/src/d.c\n",
X	 0, $pass);
X
# Unstage directory and try to check out a file
&runtest("unstage directory",
X	 "unstage $staging/src < /dev/null",
X	 "unstage: unstaged $staging/src\n",
X	 0, $pass);
X
# XXX Warning: output is reversed from what you would expect running
# from a tty because of buffering.  This may be system-dependent.
# We need to run commands from runtest in a tty.
&runtest("check out multilevel",
X	 "bcs co -l $staging/src/b.c",
X	 "$staging/src/RCS/b.c,v.*$staging/src/b.c\n" .
X	 "revision 1.2 \\(locked\\)\n" .
X	 "done\n" .
X	 "bcs: staged $staging/src\n" .
X	 "bcs: staged $staging/src/b.c\n",
X	 0, $pass);
X
# Try to check out an unimportant file
&write_file("$staging/src/e.c", "");
&runtest("check out unimportant", 
X	 "bcs co -l $staging/src/e.c",
X	 "bcs: can't check $staging/src/e.c in or out since " .
X	 "it is not important.\n" .
X	 "bcs: no operations were performed\n",
X	 2, $pass);
X
# Try to check out an unstageable file
&write_file("$baseline/src/.no_stage", "d.c\n");
&runtest("check out unstageable",
X	 "bcs co -l $staging/src/d.c",
X	 "bcs: $staging/src/d.c is forbidden from being staged.\n" .
X	 "bcs: can't check $staging/src/d.c out since " .
X	 "it can't be staged.\n" .
X	 "bcs: no operations were performed\n",
X	 2, $pass);
X
# Try to register a file that doesn't exist but has a log
&write_file("$baseline/src/RCS/f.c,v", "");
&runtest("register file with log",
X	 "register_file $staging/src/f.c",
X	 "register_file: can't register $staging/src/f.c since .* " .
X	 "already has a log.\n",
X	 6, $pass);
X
# Try to register a file that has execute permission.  Make sure
# the baseline file and log have proper permissions
# Try to register a file that doesn't exist but has a log
&write_file("$staging/src/a", "");
chmod 0775, "$staging/src/a";
&runtest("register file preserving execute",
X	 "register_file $staging/src/a",
X	 "$baseline/src/RCS/a,v.*$baseline/src/a\n" .
X	 "initial revision: 1.1\n" .
X	 "done\n",
X	 0, $pass);
&check_condition("permissions", "(-w \"$staging/src/a\")", 1, $pass);
&check_condition("permissions", "(-x \"$staging/src/a\")", 1, $pass);
&check_condition("permissions", "(-x \"$baseline/src/RCS/a,v\")", 1, $pass);
&check_condition("permissions", "(-x \"$baseline/src/a\")", 1, $pass);
&check_condition("permissions", "(! -w \"$baseline/src/a\")", 1, $pass);
X
# Test alternative logfile names
&make_dir("$baseline/logtest");
&make_dir("$baseline/logtest/RCS");
&write_file("$baseline/logtest/a", "");
&write_file("$baseline/logtest/b", "");
&write_file("$baseline/logtest/c", "");
&write_file("$baseline/logtest/d", "");
&runtest("check in for next test",
X	 "ci -u -t-\"\" $baseline/logtest/[abc]",
X	 "$baseline/logtest/RCS/a,v.*$baseline/logtest/a\n" .
X	 "initial revision: 1.1\n" .
X	 "done\n" .
X	 "$baseline/logtest/RCS/b,v.*$baseline/logtest/b\n" .
X	 "initial revision: 1.1\n" .
X	 "done\n" .
X	 "$baseline/logtest/RCS/c,v.*$baseline/logtest/c\n" .
X	 "initial revision: 1.1\n" .
X	 "done\n",
X	 0, $pass);
X
# Create alternative logfile names
rename("$baseline/logtest/RCS/b,v", "$baseline/logtest/RCS/b");
rename("$baseline/logtest/RCS/c,v", "$baseline/logtest/c,v");
X
# Make sure we can handle bizzare case where a log looks like it has a log
&write_file("$baseline/logtest/RCS/c,v,v", "");
X
&runtest("check for alternative log names",
X	 "id_important $baseline/logtest",
X	 "$baseline/logtest/a\n" .
X	 "$baseline/logtest/b\n" .
X	 "$baseline/logtest/c\n",
X	 0, $pass);
X
&report;
SHAR_EOF
echo 'File bcs-2.0/tests/rcs.test is complete' &&
chmod 0444 bcs-2.0/tests/rcs.test ||
echo 'restore of bcs-2.0/tests/rcs.test failed'
Wc_c="`wc -c < 'bcs-2.0/tests/rcs.test'`"
test 9354 -eq "$Wc_c" ||
	echo 'bcs-2.0/tests/rcs.test: original size 9354, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/tests/sccs.test ==============
if test -f 'bcs-2.0/tests/sccs.test' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/tests/sccs.test (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/tests/sccs.test (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/tests/sccs.test' &&
# -*- perl -*-
#
# $Id: sccs.test,v 1.7 1994/03/07 21:47:41 qjb Exp $
# $Source: /local/tmp/bcs-2.0/tests/RCS/sccs.test,v $
# $Author: qjb $
#
# Copyright (C) 1994  E. Jay Berkenbilt
#
# No need to perform these tests in all the baseline and staging
# area configurations set up in setup.
#
# Test checkin, checkout, register_file, and some unstage
# functions with SCCS as the CM system.
#
# When adding tests to this file, consider whether it is
# appropriate to add them to tests for other CM packages as
# well. 
#
# Tests:
#
# REGISTER FILE
#   Make sure register file works when directories need to be created
#   Register file that already exists in staging area
#   Try to register file that exists in baseline
# 
# IMPORTANCE TESTS
#   file with CM log
# 
# BCS TESTS
#   Try checking some files in and out
#
# UNSTAGE TESTS
#   Writable files with logs
#   Checked-in, non-updated files
# 
# UPDATE BASELINE
#   Files with no logs
#   Writable files with logs
#   Out-of-date files with logs
#   Checked-in, non-updated files
# 
X
(scalar(@ARGV) == 4) || die "This script should be run from bcs_test.\n";
($srcdir, $bindir, $tests, $testdir) = (@ARGV);
X
$category = "SCCS support";
require "$tests/test_routines.pl";
X
# If we don't have SCCS, skip this test.
&report if (system("grep HAVE_SCCS $srcdir/lib/sccs_paths.h " .
X		   ">/dev/null 2>&1") != 0);
X
$testdir .= "/sccs";
&rmrf($testdir);
&make_dir("$testdir");
X
$ENV{"BASELINE"} = $baseline = "$testdir/bl";
$ENV{"STAGING"} = $staging = "$testdir/st";
X
&make_dir("$baseline");
&write_file("$baseline/.baseline_conf", "cm: SCCS\n");
X
&make_dir("$staging");
&write_file("$staging/.baseline_path", "../bl\n");
X
# Register a file in another directory
X
&runtest("register file other directory",
X	 "register_file $staging/src/a.c",
X	 "No id keywords.*\n" .
X	 "1.1\n" .
X	 "No id keywords.*\n" .
X	 "0 lines\n",
X	 0, $pass);
X
&check_condition("permissions", "(-w \"$baseline/src/a.c\")", 0, $pass);
&check_condition("permissions", "(-w \"$baseline/src/SCCS/p.a.c\")", 1, $pass);
&check_condition("permissions", "(-w \"$staging/src/a.c\")", 1, $pass);
&check_condition("permissions", "(-l \"$staging/src/SCCS\")", 1, $pass);
X
# SCCS only works on files in the current directory.
chdir($staging);
X
&runtest("register file",
X	 "register_file $staging/a.c $staging/b.c $staging/c.c",
X	 "No id keywords.*\n" .
X	 "1.1\n" .
X	 "No id keywords.*\n" .
X	 "0 lines\n" .
X	 "No id keywords.*\n" .
X	 "1.1\n" .
X	 "No id keywords.*\n" .
X	 "0 lines\n" .
X	 "No id keywords.*\n" .
X	 "1.1\n" .
X	 "No id keywords.*\n" .
X	 "0 lines\n",
X	 0, $pass);
X
&check_condition("permissions", "(-w \"$baseline/a.c\")", 0, $pass);
&check_condition("permissions", "(-w \"$baseline/SCCS/p.a.c\")", 1, $pass);
&check_condition("permissions", "(-w \"$staging/a.c\")", 1, $pass);
&check_condition("file type", "(-l \"$staging/SCCS\")", 1, $pass);
&check_condition("permissions", "(-w \"$baseline/b.c\")", 0, $pass);
&check_condition("permissions", "(-w \"$baseline/SCCS/p.b.c\")", 1, $pass);
&check_condition("permissions", "(-w \"$staging/b.c\")", 1, $pass);
&check_condition("file type", "(-l \"$staging/SCCS\")", 1, $pass);
&check_condition("permissions", "(-w \"$baseline/c.c\")", 0, $pass);
&check_condition("permissions", "(-w \"$baseline/SCCS/p.c.c\")", 1, $pass);
&check_condition("permissions", "(-w \"$staging/c.c\")", 1, $pass);
&check_condition("file type", "(-l \"$staging/SCCS\")", 1, $pass);
X
# Register a file that already exists in baseline
&runtest("register file existing in baseline",
X	 "register_file $staging/a.c",
X	 "register_file: can't register $staging/a.c since .* " .
X	 "already exists.\n",
X	 6, $pass);
X
&write_file("$staging/d.c", "");
X
# Register a file that already exists in staging area
&runtest("register file existing in staging area",
X	 "register_file $staging/d.c",
X	 "No id keywords.*\n" .
X	 "1.1\n" .
X	 "No id keywords.*\n" .
X	 "0 lines\n",
X	 0, $pass);
X
&check_condition("permissions", "(-w \"$baseline/d.c\")", 0, $pass);
&check_condition("permissions", "(-w \"$staging/SCCS/p.d.c\")", 1, $pass);
&check_condition("permissions", "(-w \"$staging/d.c\")", 1, $pass);
&check_condition("file type", "(-l \"$staging/SCCS\")", 1, $pass);
X
# Update a writable file
&runtest("update writable file",
X	 "update_baseline $staging/src/a.c",
X	 "update_baseline: not updating baseline copy of $staging/src/a.c " .
X	 "since the staging area copy is writable.  " .
X	 "Is the file checked in.*\n",
X	 6, $pass);
X
# Try to unstage writable file with log
&runtest("unstage writable file with log",
X	 "unstage $staging/a.c < /dev/null",
X	 "unstage: $staging/a\\.c is writable.\n" .
X	 "unstage: NOT unstaging $staging/a\\.c\n",
X	 6, $pass);
X
# Update a file that is writable in the baseline
chmod 0444, "$staging/src/a.c";
chmod 0644, "$baseline/src/a.c";
&runtest("update when baseline file is writable",
X	 "update_baseline $staging/src/a.c",
X	 "update_baseline: not updating baseline copy of $staging/src/a.c " .
X	 "since the baseline copy is writable.\n",
X	 6, $pass);
X
# Update a locked file
chmod 0444, "$staging/src/a.c";
unlink("$baseline/src/a.c");
&write_file("$baseline/src/a.c", "This is a changed file.\n");
chmod 0444, "$baseline/src/a.c";
X
&runtest("update file with locks",
X	 "update_baseline $staging/src/a.c",
X	 "update_baseline: WARNING: $staging/src/a.c currently has " .
X	 "outstanding locks.  " .
X	 "Please notify the owners of those locks that the " .
X	 "file is being updated.\n" . 
X	 "1.1\n" .
X	 "0 lines\n" .
X	 "No id keywords.*\n" .
X	 "update_baseline: unstaged $staging/src/a.c\n",
X	 0, $pass);
X
unlink("$staging/b.c");
&write_file("$staging/b.c", "This is a file.\n");
X
&runtest("check in",
X	 "bcs delget -ychange $staging/b.c",
X	 "No id keywords.*\n" .
X	 "1.2\n" .
X	 "1 inserted\n" .
X	 "0 deleted\n" .
X	 "0 unchanged\n" .
X	 "1.2\n" .
X	 "No id keywords.*\n" .
X	 "1 lines\n",
X	 0, $pass);
X	 
# Try to unstage a checked-in but not updated file.
&runtest("unstage non-updated file",
X	 "unstage $staging/b.c < /dev/null",
X	 "unstage: $staging/b\\.c.*not.*updated in the baseline;\n" .
X	 "\tchanges may be hidden.\n" .
X	 "unstage: NOT unstaging $staging/b\\.c\n",
X	 6, $pass);
X
# Update a checked-in file
&runtest("update",
X	 "update_baseline $staging/b.c",
X	 "1.2\n" .
X	 "1 lines\n" .
X	 "No id keywords.*\n" .
X	 "update_baseline: unstaged $staging/b.c\n",
X	 0, $pass);
X
X
&runtest("check in unchanged file",
X	 "bcs unedit $staging/c.c",
X	 "1.1\n" .
X	 "No id keywords.*\n" .
X	 "0 lines\n" .
X	 " c.c: removed\n",
X	 0, $pass);
X	 
# Leave one of the files staged
&runtest("update already updated",
X	 "update_baseline $staging/c.c",
X	 "update_baseline: $staging/c.c is already up-to-date.\n" .
X	 "update_baseline: unstaged $staging/c.c\n",
X	 0, $pass);
X
# XXX Warning: output is reversed from what you would expect running
# from a tty because of buffering.  This may be system-dependent.
# We need to run commands from runtest in a tty.
&runtest("check out multilevel",
X	 "bcs edit $staging/b.c",
X	 "1.2\n" .
X	 "new delta 1.3\n" .
X	 "1 lines\n",
X	 0, $pass);
X
&report;
SHAR_EOF
chmod 0444 bcs-2.0/tests/sccs.test ||
echo 'restore of bcs-2.0/tests/sccs.test failed'
Wc_c="`wc -c < 'bcs-2.0/tests/sccs.test'`"
test 7023 -eq "$Wc_c" ||
	echo 'bcs-2.0/tests/sccs.test: original size 7023, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/tests/setup.pl ==============
if test -f 'bcs-2.0/tests/setup.pl' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/tests/setup.pl (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/tests/setup.pl (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/tests/setup.pl' &&
# -*- perl -*-
#
# $Id: setup.pl,v 1.3 1994/01/11 15:35:26 ejb Exp $
# $Source: /local/tmp/bcs-2.0/tests/RCS/setup.pl,v $
# $Author: ejb $
#
# Author: E. Jay Berkenbilt (ejb@ERA.COM)
# This file contains routines for running tests.  This file is in the public 
# domain.
#
# This script does setup necessary for many of the tests.  This saves
# each test from having to create its own set of baseline and staging
# area directories.
#
# This routine sets up baseline and staging area directories that are
# both directories and links.  In addition, both absolute paths and
# relative paths are used.  There are a set of staging area directories
# that are nested beneath their baseline directories and there are some
# that aren't.  
#
# The following variables are independent:
#
#   0: 	0 = baseline is directory, 	1 = baseline is link
#   1: 	0 = staging area is directory, 	1 = staging area is link
#   2:	0 = bl_path is absolute		1 = bl_path is relative
#   3:	0 = staging area is not nested	1 = staging area is nested
# 
# Many tests are run on all combinations of the above.  That means that
# there are 16 (2^n, for n independent variables) pairs of baseline
# and staging area directories.
#
X
(scalar(@ARGV) == 4) || die "This script should be run from bcs_test.\n";
($srcdir, $bindir, $tests, $testdir) = (@ARGV);
X
defined($cm_pkg) || ($cm_pkg = "RCS");
X
#
# Set up baseline and staging directories.  Each pair of directories
# has names of the form "baseline-n" and "staging-n".  The number "n"
# is the decimal equivalent to the variable values defined above
# for the particular pair.  Variable i is in the i-th bit.  For 
# cases where a directory is a link, the real directory will be dir.real.
# In cases of nested staging areas, the staging area is a subdirectory
# of the "staging" directory in the baseline.
#
X
# Number of variables we are testing for
$numvars = 4;
X
$xtestdir = "$testdir/bltest";
# Do we create the directories or just set up the list of names?
$create = (! (-r "$xtestdir/.done"));
if ($create)
{
X    &rmrf($xtestdir);
X    &make_dir($xtestdir);
}
chop($pwd = `pwd`);
chdir($xtestdir) || die "Can't chdir $xtestdir\n";
chop($xtestdir = `pwd`);
chdir($pwd);
X
for ($i = 0; $i < (1 << $numvars); $i++)
{
X    @vars = &calc_vars($i);
X
X    # Create baseline directory
X    $dir = "$xtestdir/baseline-$i";
X    $xbaseline[$i] = $dir;
X    if ($create)
X    {
X	if ($vars[0])
X	{
X	    &make_dir("$dir.real");
X	    &make_link("baseline-$i.real", "$dir");
X	}
X	else
X	{
X	    &make_dir($dir);
X	}
X	&write_file("$dir/.baseline_conf",
X		    "cm: $cm_pkg\nunimp_warn_suffixes: .c");
X    }
X
X    # Create staging area directory
X    $dir = ($vars[3] ? "$dir/staging/staging-$i" : "$xtestdir/staging-$i");
X    $xstaging[$i] = $dir;
X    if ($create)
X    {
X	($vars[3]) && &make_dir("$xbaseline[$i]/staging");
X	if ($vars[1])
X	{
X	    &make_dir("$dir.real");
X	    &make_link("staging-$i.real", "$dir");
X	}
X	else
X	{
X	    &make_dir($dir);
X	}
X	if ($vars[2])
X	{
X	    $bl_path = ($vars[3] ? "../.." : "../baseline-$i");
X	}
X	else
X	{
X	    $bl_path = $xbaseline[$i];
X	}
X	&write_file("$dir/.baseline_path", "$bl_path\n");
X    }
}
X
&write_file("$xtestdir/.done", "");
$xbaseline = join(':', @xbaseline);
$xstaging = join(':', @xstaging);
X
X
sub calc_vars {
X    local($num) = @_;
X    local($i);
X    local(@vars);
X
X    for ($i = 0; $i < $numvars; $i++)
X    {
X	@vars[$i] = ($num & (1 << $i)) ? 1 : 0;
X    }
X
X    @vars;
}
X
sub write_file {
X    local($file, $string) = @_;
X    open(F, ">$file") || warn "can't open $file\n";
X    print F $string;
X    close(F);
}
X
sub make_dir {
X    local($dir) = @_;
X    mkdir($dir, 0777) || warn "can't make directory $dir\n";
}
X
sub make_link {
X    local($src, $dest) = @_;
X    symlink($src, $dest) || warn "can't make link $dest -> $src\n";
}
X
sub clear_xbl {
X    # Force test area to be recreated for next test file
X    unlink("$xtestdir/.done");
}
X
sub rmrf {
X    local($file) = @_;
X    system("rm -rf $file");
}
SHAR_EOF
chmod 0444 bcs-2.0/tests/setup.pl ||
echo 'restore of bcs-2.0/tests/setup.pl failed'
Wc_c="`wc -c < 'bcs-2.0/tests/setup.pl'`"
test 3940 -eq "$Wc_c" ||
	echo 'bcs-2.0/tests/setup.pl: original size 3940, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/tests/stage.test ==============
if test -f 'bcs-2.0/tests/stage.test' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/tests/stage.test (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/tests/stage.test (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/tests/stage.test' &&
# -*- perl -*-
#
# $Id: stage.test,v 1.14 1994/03/19 14:47:15 qjb Exp $
# $Source: /local/tmp/bcs-2.0/tests/RCS/stage.test,v $
# $Author: qjb $
#
# Copyright (C) 1994  E. Jay Berkenbilt
#
# This is the main test file of BCS.  It tests staging,
# unstaging, synchronization, and importance.
# 
X
(scalar(@ARGV) == 4) || die "This script should be run from bcs_test.\n";
($srcdir, $bindir, $tests, $testdir) = (@ARGV);
X
$category = "Staging";
require "$tests/test_routines.pl";
X
# Force test area to be recreated for next test file
&clear_xbl;
X
#
# Run some tests for each combination of baseline and staging area
# directories.  Run others for only the first configuration.
#
$first = 1;
for ($i = 0; $i < scalar(@xbaseline); $i++)
{
X    printf TTY ("$category: case %d of %d\n", $i + 1, scalar(@xbaseline));
X    $baseline = $ENV{"BASELINE"} = $xbaseline[$i];
X    $staging = $ENV{"STAGING"}  = $xstaging[$i];
X
X    # Create a directory that will contain all important files
X    # Test * in .important
X    &make_dir("$baseline/allimp");
X    &write_file("$baseline/allimp/.important", "*\n");
X    &write_file("$baseline/allimp/a", "");
X    &write_file("$baseline/allimp/b", "");
X    # Create some miscellaneous files to test with
X    # internal link with relative path
X    &make_link("a", "$baseline/allimp/l1");
X    # internal link with absolute path
X    &make_link("$baseline/allimp/a", "$baseline/allimp/l2");
X    # external link
X    &make_link("/etc/passwd", "$baseline/allimp/l3");
X    # dangling link
X    &make_link("/does_not_exist", "$baseline/allimp/l4");
X    &write_file("$baseline/allimp/.unimp_nowarn", "");
X
X    # Make sure classify_files works for all kinds of top-level directories
X    &runtest("classify top level",
X	     "classify_files $baseline",
X	     "$baseline/\\.baseline_conf: important\n" .
X	     "$baseline/allimp/: important\n",
X	     0, $pass);
X
X    if ($first)
X    {
X	&runtest("classify all important",
X		 "classify_files $baseline/allimp",
X		 "$baseline/allimp/\\.important: important\n" .
X		 "$baseline/allimp/\\.unimp_nowarn: important\n" .
X		 "$baseline/allimp/a: important\n" .
X		 "$baseline/allimp/b: important\n" .
X		 "$baseline/allimp/l1: important\n" .
X		 "$baseline/allimp/l2: important\n" .
X		 "$baseline/allimp/l3: important\n" .
X		 "$baseline/allimp/l4: important\n",
X		 0, $pass);
X    }
X
X    &write_file("$staging/f1", "");
X    # unimportant link to unimportant file
X    &make_link("f1", "$staging/l1");
X    # dangling link in staging area
X    &make_link("/does_not_exist", "$staging/l2");
X
X    # sync_staging should not remove l1
X    &runtest("sync_staging top level",
X	     "sync_staging $staging",
X	     "sync_staging: linking.*allimp\n" .
X	     (($staging =~ m,/staging/,) ?
X	     "sync_staging: linking.*/staging/.*staging\n" : "") .
X	     "sync_staging: removing unimportant link .*/l2\n",
X	     0, $pass);
X
X    # No output expected...
X    &runtest("sync_staging with repeated directory",
X	     "sync_staging $staging $staging", "", 0, $pass);
X
X    if ($first)
X    {
X	&runtest("sync_staging non-directory",
X		 "sync_staging $staging/allimp",
X		 "sync_staging: .*not a directory", 1, $pass);
X    }
X
X    &runtest("stage all important",
X	     "stage $staging/allimp",
X	     "stage: staged.*allimp\n",
X	     0, $pass);
X
X    #
X    # Remaining tests do not need to be run in all configurations.
X    #
X    next if (! $first);
X
X    &runtest("classify staged all important",
X	     "classify_files $staging/allimp",
X	     "$staging/allimp/a: important\n" .
X	     "$staging/allimp/b: important\n" .
X	     "$staging/allimp/l1: important\n" .
X	     "$staging/allimp/l2: important\n" .
X	     "$staging/allimp/l3: important\n",
X	     0, $pass);
X    
X    &check_condition
X	("link target",
X	 "readlink(\"$staging/allimp/l1\") eq \"$staging/allimp/a\"",
X	 1, $pass);
X    &check_condition
X	("link target",
X	 "readlink(\"$staging/allimp/l2\") eq \"$staging/allimp/a\"",
X	 1, $pass);
X    &check_condition
X	("link target",
X	 "readlink(\"$staging/allimp/l3\") eq \"$baseline/allimp/l3\"",
X	 1, $pass);
X
X    # Create a direectory that will contain .important and .unimportant
X    # Test files in .important
X    # Test files in .unimportant
X    # Test files in both .important and .unimportant
X    # Test dangling link (unimportant)
X    # Test link to important file
X    # Test link to unimportant file
X    # Test directory
X    # Test .auto_stage and .no_stage
X    # Make sure .baseline_path and .baseline_conf are not important
X    #   in lower-level directories.
X    # Make sure can't make precious directory unimportant
X    &make_dir("$baseline/expimp");
X    &write_file("$baseline/expimp/.important", "a\nb\n");
X    &write_file("$baseline/expimp/.unimportant", "a\nc\nRCS\n");
X    &write_file("$baseline/expimp/a", "");
X    &write_file("$baseline/expimp/b", "");
X    &make_dir("$baseline/expimp/c");
X    &write_file("$baseline/expimp/d", "");
X    &make_link("x", "$baseline/expimp/e");
X    &make_link("a", "$baseline/expimp/f");
X    &make_link("c", "$baseline/expimp/g");
X    &make_dir("$baseline/expimp/h");
X    &make_dir("$baseline/expimp/h/1");
X    &make_dir("$baseline/expimp/i");
X    &make_dir("$baseline/expimp/i/j");
X    &make_dir("$baseline/expimp/i/j/k");
X    &make_dir("$baseline/expimp/RCS");
X    &write_file("$baseline/expimp/.auto_stage", "b\n");
X    &write_file("$baseline/expimp/.no_stage", "h\n");
X    &write_file("$baseline/expimp/.baseline_conf", "");
X    &write_file("$baseline/expimp/.baseline_path", "");
X
X    if ($first)
X    {
X	&runtest("classify with .important file",
X		 "classify_files $baseline/expimp",
X		 "$baseline/expimp/\\.auto_stage: important\n" .
X		 "$baseline/expimp/\\.baseline_conf: unimportant\n" .
X		 "$baseline/expimp/\\.baseline_path: unimportant\n" .
X		 "$baseline/expimp/\\.important: important\n" .
X		 "$baseline/expimp/\\.no_stage: important\n" .
X		 "$baseline/expimp/\\.unimportant: important\n" .
X		 "$baseline/expimp/RCS/: important\n" .
X		 "$baseline/expimp/a: important\n" .
X		 "$baseline/expimp/b: important\n" .
X		 "$baseline/expimp/c/: unimportant\n" .
X		 "$baseline/expimp/d: unimportant\n" .
X		 "$baseline/expimp/e: unimportant\n" .
X		 "$baseline/expimp/f: important\n" .
X		 "$baseline/expimp/g: unimportant\n" .
X		 "$baseline/expimp/h/: important\n" .
X		 "$baseline/expimp/i/: important\n",
X		 0, $pass);
X    }
X
X    &runtest("sync_staging with .important file",
X	     "sync_staging $staging",
X	     "sync_staging: linking.*expimp\n",
X	     0, $pass);
X
X    &runtest("stage with .important file",
X	     "stage $staging/expimp",
X	     "stage: staged.*expimp/b\n" .
X	     "stage: staged.*expimp\n",
X	     0, $pass);
X
X    # Make sure multi-level stages work for more than two levels
X    &runtest("stage multilevel",
X	     "stage $staging/expimp/i/j/k",
X	     "stage: staged.*expimp/i\n" .
X	     "stage: staged.*expimp/i/j\n" .
X	     "stage: staged.*expimp/i/j/k\n",
X	     0, $pass);
X    
X
X    # Make sure unimportant in baseline applies to staging area
X    # by creating an unimportant files explicitly in the staging
X    # area
X    &make_dir("$staging/expimp/c");
X    &write_file("$staging/expimp/d", "");
X    
X    &runtest("classify with unimportant files",
X	     "classify_files $staging/expimp",
X	     "$staging/expimp/RCS: important\n" .
X	     "$staging/expimp/a: important\n" .
X	     "$staging/expimp/b: important\n" .
X	     "$staging/expimp/c/: unimportant\n" .
X	     "$staging/expimp/d: unimportant\n" .
X	     "$staging/expimp/f: important\n" .
X	     "$staging/expimp/h: important\n",
X	     0, $pass);
X
X    # Try staging an unimportant link back to the baseline
X    unlink("$baseline/expimp/.important");
X    &write_file("$baseline/expimp/.important", "b\n");
X    # Now a is no longer important
X    &runtest("stage unimportant link to baseline counterpart",
X	     "stage $staging/expimp/a",
X	     "stage: can't stage $staging/expimp/a since " .
X	     "it is not important.\n",
X	     6, $pass);
X    # Restore to previous state
X    unlink("$baseline/expimp/.important");
X    &write_file("$baseline/expimp/.important", "a\nb\n");
X
X    # Test for staging precious files
X    &runtest("stage precious files",
X	     "stage $staging/expimp/RCS", "RCS.*forbidden from being staged.",
X	     6, $pass);
X
X    # Test for staging .no_stage files
X    &runtest("stage unstageable",
X	     "stage $staging/expimp/h", "h.*forbidden from being staged.",
X	     6, $pass);
X
X    # Test for staging children of .no_stage files
X    &runtest("stage children of unstagebale",
X	     "stage $staging/expimp/h/1", "h.*forbidden from being staged.",
X	     6, $pass);
X
X    # Test for unstage of .auto_stage
X    &runtest("unstage auto stage",
X	     "unstage $staging/expimp/b",
X	     "unstage: removed $staging/expimp/b\n" .
X	     "unstage: staged $staging/expimp/b\n" .
X	     "unstage: unstaged and restaged $staging/expimp/b\n",
X	     0, $pass);
X
X    # Test for unstage of already unstaged
X    &runtest("unstage already unstaged",
X	     "unstage $staging/expimp/h",
X	     "unstage: $staging/expimp/h is already unstaged\n",
X	     0, $pass);
X
X    # Make sure sync_staging notices staged .no_stage or files that
X    # should be links
X    unlink("$staging/expimp/h");
X    &make_dir("$staging/expimp/h");
X    unlink("$staging/expimp/f");
X    &write_file("$staging/expimp/f", "");
X    &runtest("sync_staging with errors",
X	     "sync_staging $staging/expimp",
X	     "sync_staging: WARNING: .*/expimp/f is a file but " .
X	     "should be a link\n" .
X	     "sync_staging: WARNING: .*/expimp/h is staged but " .
X	     "is marked unstageable\n",
X	     0, $pass);
X
X    # Make sure id_staged doesn't consider unimportant files to be staged
X    # but does catch real staged files.  Make sure files whose baseline
X    # counterparts are links are not listed as staged
X    
X    &runtest("id_staged with unimportant files",
X	     "id_staged $staging/expimp",
X	     "$staging/expimp/b\n" .
X	     "$staging/expimp/h/\n" .
X	     "$staging/expimp/i/\n",
X	     0, $pass);
X    
X    rmdir("$staging/expimp/h");
X    unlink("$staging/expimp/f");
X    &write_file("$staging/expimp/a.c", "");
X    &write_file("$staging/allimp/a.c", "");
X
X    &runtest("sync_staging with unimportant directories",
X	     "sync_staging -r $staging",
X	     "sync_staging: linking.*expimp/f\n" .
X	     "sync_staging: linking.*expimp/h\n" .
X	     "sync_staging: WARNING: found unimportant file.*a\\.c\n",
X	     0, $pass);
X
X    &write_file("$baseline/.unimp_nowarn");
X    &runtest("sync_staging with unimportant warnings suppressed",
X	     "sync_staging -r $staging",
X	     "",
X	     0, $pass);
X    unlink("$baseline/.unimp_nowarn");
X
X    unlink("$staging/allimp/a.c");
X    &runtest("unstage",
X	     "unstage $staging/allimp < /dev/null",
X	     "unstage: unstaged.*allimp\n",
X	     0, $pass);
X
X    &runtest("unstage with unimportant warnings",
X	     "unstage $staging/expimp < /dev/null",
X	     "unstage: file.*expimp/a\\.c is unimportant.\n" .
X	     "unstage: directory.*expimp/c is unimportant.\n" .
X	     "unstage: NOT unstaging.*expimp\n",
X	     6, $pass);
X
X    &runtest("unstage interactive",
X	     "echo y | unstage $staging/expimp --interactive",
X	     "unstage: file.*expimp/a\\.c is unimportant.\n" .
X	     "unstage: directory.*expimp/c is unimportant.\n" .
X	     "Unstage.*anyway?.*unstaged.*expimp\n",
X	     0, $pass);
X
X    &runtest("restage directory for next test",
X	     "stage $staging/expimp",
X	     "stage: staged.*expimp\n",
X	     0, $pass);
X    
X    &write_file("$staging/expimp/a.c", "");
X    &write_file("$baseline/expimp/.unimp_nowarn");
X    &runtest("unstage with unimportant warnings suppressed",
X	     "unstage $staging/expimp",
X	     "unstage: unstaged.*expimp\n",
X	     0, $pass);
X    unlink("$baseline/expimp/.unimp_nowarn");
X
X    $first = 0;
}
X
printf TTY ("$category: miscellanous tests\n");
for ($i = 0; $i < scalar(@xbaseline); $i++)
{
X    # Try to find a staging directory that is nested
X    if ($xstaging[$i] =~ m,/staging/,)
X    {
X	$baseline = $ENV{"BASELINE"} = $xbaseline[$i];
X	$staging = $ENV{"STAGING"} = $xstaging[$i];
X	last;
X    }
}
X
# Make sure you can stage nested `staging' dir when it's not made unimportant
&runtest("stage nested staging",
X	 "stage $staging/staging",
X	 "stage: staged $staging/staging\n",
X	 0, $pass);
X
# Make sure it doesn't have any files in it when you have.
@files = (<$staging/staging/*>);
&check_condition("number of files", "(scalar(@files) == 0)", 1, $pass);
X
#
# Check condition of staging all files in a directory where the directory
# is a link and some of the files are unimportant.
#
$baseline = $ENV{"BASELINE"} = $xbaseline[0];
$staging = $ENV{"STAGING"} = $xstaging[0];
X
&make_dir("$baseline/dir");
&make_dir("$baseline/di", "");
&write_file("$baseline/dir/a", "");
&make_dir("$baseline/dir/b", "");
&write_file("$baseline/dir/c", "");
&runtest("link dir",
X	 "sync_staging $staging",
X	 "sync_staging: linking.*di\n" .
X	 "sync_staging: linking.*dir\n",
X	 0, $pass);
# XXX Warning: output is reversed from what you would expect running
# from a tty because of buffering.  This may be system-dependent.
# We need to run commands from runtest in a tty.  The output below
# has four lines: 1, 2, 3, 4.  As listed below, the order in which
# they actually print on a tty is 2, 3, 4, 1.
&runtest("stage through link to unimportant files",
X	 "stage $staging/dir/*",
X	 "stage: can't stage $staging/dir/c because it does not exist\n" .
X	 "stage: staged $staging/dir\n" .
X	 "stage: can't stage $staging/dir/a because it does not exist\n" .
X	 "stage: staged $staging/dir/b\n",
X	 6, $pass);
X
# Stage file in baseline
&runtest("stage file in baseline",
X	 "stage $baseline/dir",
X	 "stage: can't stage $baseline/dir since it is in the " .
X	 "baseline\.\n",
X	 6, $pass);
X
# Stage file neither in baseline nor in staging area
&runtest("stage file not in baseline or staging",
X	 "stage /etc/passwd",
X	 "stage: can't stage /etc/passwd since it is not in the " .
X	 "staging area\.\n",
X	 6, $pass);
X
# Stage directory with name whose first letters are common with dir
&runtest("stage directory for next tests",
X	 "stage $staging/di",
X	 "stage: staged $staging/di\n",
X	 0, $pass);
X
# Try to unstage current directory
chop($pwd = `pwd`);
chdir("$staging/dir/b");
&runtest("unstage current directory",
X	 "unstage .",
X	 "unstage: can't unstage . because it would cause removal " .
X	 "of current directory.\n",
X	 6, $pass);
X
# Try to unstage parent directory
chdir("..");
&runtest("unstage parent directory",
X	 "unstage ..",
X	 "unstage: can't unstage .. because it would cause removal " .
X	 "of current directory.\n",
X	 6, $pass);
X
# Try to unstage directory whose name starts the same as parent directory
&runtest("unstage higher directory with tricky name",
X	 "unstage ../di",
X	 "unstage: unstaged ../di\n",
X	 0, $pass);
X
chdir($pwd);
X	 
# Other possible tests not currently implemented:
# STAGE/SYNC_STAGING TESTS
#   Move staging area, resync
#   Change .baseline_path from relative to absolute, resync
#   Change .baseline_path from absolute to relative, resync
X
&report;
SHAR_EOF
chmod 0444 bcs-2.0/tests/stage.test ||
echo 'restore of bcs-2.0/tests/stage.test failed'
Wc_c="`wc -c < 'bcs-2.0/tests/stage.test'`"
test 14929 -eq "$Wc_c" ||
	echo 'bcs-2.0/tests/stage.test: original size 14929, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/tests/template ==============
if test -f 'bcs-2.0/tests/template' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/tests/template (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/tests/template (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/tests/template' &&
# -*- perl -*-
#
# $Id: template,v 1.3 1994/03/07 21:47:41 qjb Exp $
# $Source: /local/tmp/bcs-2.0/tests/RCS/template,v $
# $Author: qjb $
#
# Copyright (C) 1994  E. Jay Berkenbilt
#
(scalar(@ARGV) == 4) || die "This script should be run from bcs_test.\n";
($srcdir, $bindir, $tests, $testdir) = (@ARGV);
X
$category = "test category";
require "$tests/test_routines.pl";
X
&runtest("test name", "cmd", "output", status, $pass);
&check_condition("test name", condition, exp_value, exp_outcome);
X
&report;
SHAR_EOF
chmod 0444 bcs-2.0/tests/template ||
echo 'restore of bcs-2.0/tests/template failed'
Wc_c="`wc -c < 'bcs-2.0/tests/template'`"
test 502 -eq "$Wc_c" ||
	echo 'bcs-2.0/tests/template: original size 502, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/tests/test_routines.pl ==============
if test -f 'bcs-2.0/tests/test_routines.pl' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/tests/test_routines.pl (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/tests/test_routines.pl (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/tests/test_routines.pl' &&
#!/usr/local/bin/perl -w-- -*- perl -*-
#
# $Id: test_routines.pl,v 1.4 1994/02/11 23:56:15 qjb Exp $
# $Source: /local/tmp/bcs-2.0/tests/RCS/test_routines.pl,v $
# $Author: qjb $
#
# Author: E. Jay Berkenbilt (ejb@ERA.COM)
# This file contains routines for running tests.  This file is in the public 
# domain.  Feel free to use it with your own sources.  It contains no
# bcs-specific code.
#
X
require "$tests/setup.pl";
X
$verbose = (defined($ENV{"VERBOSE"}) && $ENV{"VERBOSE"} == 1);
X
open(TTY, ">/dev/tty") || die "Can't open /dev/tty\n";
X
$SIG{"INT"} = 'quit';
X
$tmpfile = "$srcdir/testout.tmp";
X
$passes = $fails = $xpasses = $xfails = 0;
$pass = 1;
$fail = 2;
$testnum = 1;
X
#
# We'll be running lots of tests programs and looking at their output.
# Make sure output is unbuffered.
#
$| = 1;
X
#
# Usage: runtest command exp_output exp_status exp_outcome
# Runs command and expects output exp_output and resturn code exp_status.
#
# If both match, the test passes; otherwise the test fails.  
# exp_outcome should be either $pass or $fail.  If the test passes and
# is expected to pass, this is a pass.  If the test passes and is expected
# to fail, this is an unexpected pass.  If the test fails and is expected
# to pass, this is a fail.  If the test fails and is expected to fail,
# this is an expected fail.  Fails and unexpected passes are considered
# error conditions.
#
sub runtest {
X    local($name, $cmd, $exp_output, $exp_status, $exp_outcome) = @_;
X    local($testid, $output, $status, $output_match, $status_match, $outcome);
X    local($mod_output, $mod_exp_output);
X
X    $* = 1;
X
X    &print_testid($name);
X    &check_exp_outcome($exp_outcome) || return;
X
X    $verbose && print TTY "Running $cmd\n";
X    $status = (system("$cmd > $tmpfile 2>&1") >> 8);
X    $output = `cat $tmpfile`;
X    $verbose && print TTY "Status: $status\nOutput: $output\n";
X    $status_match = ($status == $exp_status);
X
X    # Modify output and expected output so that the arrangement of
X    # whitespace is not important.
X    $mod_output = $output;
X    $mod_exp_output = $exp_output;
X    $mod_output =~ s/[\s\n]+/ /g;
X    # replacing spaces and newlines with a single space triggers a perl
X    # bug for some versions of perl that makes the test fail erroneously.
X    $mod_exp_output =~ s/[\s\n]+/\\s*/g;
X    $output_match = ($mod_output =~ m/$mod_exp_output/);
X    
X    $outcome = ($output_match && $status_match) ? $pass : $fail;
X    &update_counters($outcome, $exp_outcome);
X
X    if (($outcome == $fail) && ($outcome != $exp_outcome))
X    {
X	print TTY "command: $cmd\n";
X	if (! $status_match)
X	{
X	    printf TTY ("\tExpected status: %d\n", $exp_status);
X	    printf TTY ("\tActual   status: %d\n", $status);
X	}
X	if (! $output_match)
X	{
X	    printf TTY ("\tExpected output:\n%s\n", $exp_output);
X	    printf TTY ("\tActual   output:\n%s\n", $output);
X	} 
X    }
X
}
X
# Like runtest, but checks a boolean condition instead of running
# a command.
sub check_condition {
X    local($name, $condition, $exp_value, $exp_outcome) = @_;
X    local($value);
X
X    &print_testid($name);
X    &check_exp_outcome($exp_outcome) || return;
X
X    $value = eval($condition);
X    $outcome = ($value == $exp_value) ? $pass : $fail;
X    &update_counters($outcome, $exp_outcome);
X
X    if (($outcome == $fail) && ($outcome != $exp_outcome))
X    {
X	print TTY "Condition: $condition\n";
X	printf TTY ("Expected value: %d; actual value: %d\n",
X		    $exp_value, $value);	
X    }
}
X
sub print_testid {
X    local($name) = @_;
X    printf TTY ("$category $testnum %-35s ... ", "($name)");
X    $testnum++;
}
X
sub check_exp_outcome {
X    local($exp_outcome) = @_;
X
X    if (! (($exp_outcome == $pass) || ($exp_outcome == $fail)))
X    {
X	printf TTY ("skipping: invalid expected outcome (%s)\n", $exp_outcome);
X	0;
X    }
X    else
X    {
X	1;
X    }
}
X
sub update_counters {
X    local($outcome, $exp_outcome) = @_;
X
X    if ($outcome == $pass)
X    {
X	printf TTY ("PASSED%s\n",
X		    ($exp_outcome == $fail) ? " -- fail expected" : "");
X    }
X    else
X    {
X	printf TTY ("FAILED%s\n",
X		    ($exp_outcome == $pass) ? " -- pass expected" :
X		    " -- fail expected");
X    }
X    (($outcome == $pass) && ($exp_outcome == $pass)) && $passes++;
X    (($outcome == $pass) && ($exp_outcome == $fail)) && $xpasses++;
X    (($outcome == $fail) && ($exp_outcome == $pass)) && $fails++;
X    (($outcome == $fail) && ($exp_outcome == $fail)) && $xfails++;
}
X
sub report {
X    print "$passes $fails $xpasses $xfails\n";
X    exit 0;
}
X
1;
SHAR_EOF
chmod 0444 bcs-2.0/tests/test_routines.pl ||
echo 'restore of bcs-2.0/tests/test_routines.pl failed'
Wc_c="`wc -c < 'bcs-2.0/tests/test_routines.pl'`"
test 4470 -eq "$Wc_c" ||
	echo 'bcs-2.0/tests/test_routines.pl: original size 4470, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/tests/version.test ==============
if test -f 'bcs-2.0/tests/version.test' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/tests/version.test (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/tests/version.test (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/tests/version.test' &&
# -*- perl -*-
#
# $Id: version.test,v 1.6 1994/03/07 21:47:41 qjb Exp $
# $Source: /local/tmp/bcs-2.0/tests/RCS/version.test,v $
# $Author: qjb $
#
# Copyright (C) 1994  E. Jay Berkenbilt
#
(scalar(@ARGV) == 4) || die "This script should be run from bcs_test.\n";
($srcdir, $bindir, $tests, $testdir) = (@ARGV);
$category = "Version/Help";
X
require "$tests/test_routines.pl";
X
&runtest("version",
X	 "bcs --version",
X	 "Baseline Configuration System version.*\n" .
X	 "Compiled on.*\n" .
X	 ".*configuration management.*\n",
X	 0, $pass);
&runtest("help", "bcs --help", "^Usage: bcs ", 0, $pass);
X
&report;
SHAR_EOF
chmod 0444 bcs-2.0/tests/version.test ||
echo 'restore of bcs-2.0/tests/version.test failed'
Wc_c="`wc -c < 'bcs-2.0/tests/version.test'`"
test 604 -eq "$Wc_c" ||
	echo 'bcs-2.0/tests/version.test: original size 604, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bcs-2.0/doc/texinfo.tex ==============
if test ! -d 'bcs-2.0/doc'; then
    echo 'x - creating directory bcs-2.0/doc'
    mkdir 'bcs-2.0/doc'
fi
if test -f 'bcs-2.0/doc/texinfo.tex' -a X"$1" != X"-c"; then
	echo 'x - skipping bcs-2.0/doc/texinfo.tex (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bcs-2.0/doc/texinfo.tex (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bcs-2.0/doc/texinfo.tex' &&
%% TeX macros to handle texinfo files
X
%   Copyright (C) 1985, 86, 88, 90, 91, 92, 1993 Free Software Foundation, Inc.
X
%This texinfo.tex file is free software; you can redistribute it and/or
%modify it under the terms of the GNU General Public License as
%published by the Free Software Foundation; either version 2, or (at
%your option) any later version.
X
%This texinfo.tex file is distributed in the hope that it will be
%useful, but WITHOUT ANY WARRANTY; without even the implied warranty
%of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
%General Public License for more details.
X
%You should have received a copy of the GNU General Public License
%along with this texinfo.tex file; see the file COPYING.  If not, write
%to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139,
%USA.
X
X
%In other words, you are welcome to use, share and improve this program.
%You are forbidden to forbid anyone else to use, share and improve
%what you give them.   Help stamp out software-hoarding!
X
\def\texinfoversion{2.108}
\message{Loading texinfo package [Version \texinfoversion]:}
X
% Print the version number if in a .fmt file.
\everyjob{\message{[Texinfo version \texinfoversion]}\message{}}
X
% Save some parts of plain tex whose names we will redefine.
X
\let\ptexlbrace=\{
\let\ptexrbrace=\}
\let\ptexdots=\dots
\let\ptexdot=\.
\let\ptexstar=\*
\let\ptexend=\end
\let\ptexbullet=\bullet
\let\ptexb=\b
\let\ptexc=\c
\let\ptexi=\i
\let\ptext=\t
\let\ptexl=\l
\let\ptexL=\L
X
\def\tie{\penalty 10000\ }     % Save plain tex definition of ~.
X
\message{Basics,}
\chardef\other=12
X
% If this character appears in an error message or help string, it
% starts a new line in the output.
\newlinechar = `^^J
X
% Ignore a token.
%
\def\gobble#1{}
X
\hyphenation{ap-pen-dix}
\hyphenation{mini-buf-fer mini-buf-fers}
\hyphenation{eshell}
X
% Margin to add to right of even pages, to left of odd pages.
\newdimen \bindingoffset  \bindingoffset=0pt
\newdimen \normaloffset   \normaloffset=\hoffset
\newdimen\pagewidth \newdimen\pageheight
\pagewidth=\hsize \pageheight=\vsize
X
% Sometimes it is convenient to have everything in the transcript file
% and nothing on the terminal.  We don't just call \tracingall here,
% since that produces some useless output on the terminal.
%
\def\gloggingall{\begingroup \globaldefs = 1 \loggingall \endgroup}%
\def\loggingall{\tracingcommands2 \tracingstats2
X   \tracingpages1 \tracingoutput1 \tracinglostchars1
X   \tracingmacros2 \tracingparagraphs1 \tracingrestores1
X   \showboxbreadth\maxdimen\showboxdepth\maxdimen
}%
X
%---------------------Begin change-----------------------
%
%%%% For @cropmarks command.
% Dimensions to add cropmarks at corners Added by P. A. MacKay, 12 Nov. 1986
%
\newdimen\cornerlong \newdimen\cornerthick
\newdimen \topandbottommargin
\newdimen \outerhsize \newdimen \outervsize
\cornerlong=1pc\cornerthick=.3pt	% These set size of cropmarks
\outerhsize=7in
%\outervsize=9.5in
% Alternative @smallbook page size is 9.25in
\outervsize=9.25in
\topandbottommargin=.75in
%
%---------------------End change-----------------------
X
% \onepageout takes a vbox as an argument.  Note that \pagecontents
% does insertions itself, but you have to call it yourself.
\chardef\PAGE=255  \output={\onepageout{\pagecontents\PAGE}}
\def\onepageout#1{\hoffset=\normaloffset
\ifodd\pageno  \advance\hoffset by \bindingoffset
\else \advance\hoffset by -\bindingoffset\fi
{\escapechar=`\\\relax % makes sure backslash is used in output files.
\shipout\vbox{{\let\hsize=\pagewidth \makeheadline} \pagebody{#1}%
{\let\hsize=\pagewidth \makefootline}}}%
\advancepageno \ifnum\outputpenalty>-20000 \else\dosupereject\fi}
X
%%%% For @cropmarks command %%%%
X
% Here is a modification of the main output routine for Near East Publications
% This provides right-angle cropmarks at all four corners.
% The contents of the page are centerlined into the cropmarks,
% and any desired binding offset is added as an \hskip on either
% site of the centerlined box.  (P. A. MacKay, 12 November, 1986)
%
\def\croppageout#1{\hoffset=0pt % make sure this doesn't mess things up
{\escapechar=`\\\relax % makes sure backslash is used in output files.
X		 \shipout
X		 \vbox to \outervsize{\hsize=\outerhsize
X                 \vbox{\line{\ewtop\hfill\ewtop}}
X                 \nointerlineskip
X                 \line{\vbox{\moveleft\cornerthick\nstop}
X                       \hfill
X                       \vbox{\moveright\cornerthick\nstop}}
X                 \vskip \topandbottommargin
X                 \centerline{\ifodd\pageno\hskip\bindingoffset\fi
X			\vbox{
X			{\let\hsize=\pagewidth \makeheadline}
X			\pagebody{#1}
X			{\let\hsize=\pagewidth \makefootline}}
X			\ifodd\pageno\else\hskip\bindingoffset\fi}
X		 \vskip \topandbottommargin plus1fill minus1fill
X                 \boxmaxdepth\cornerthick
X                 \line{\vbox{\moveleft\cornerthick\nsbot}
X                       \hfill
X                       \vbox{\moveright\cornerthick\nsbot}}
X                 \nointerlineskip
X                 \vbox{\line{\ewbot\hfill\ewbot}}
X	}}
X  \advancepageno
X  \ifnum\outputpenalty>-20000 \else\dosupereject\fi}
%
% Do @cropmarks to get crop marks
\def\cropmarks{\let\onepageout=\croppageout }
X
\def\pagebody#1{\vbox to\pageheight{\boxmaxdepth=\maxdepth #1}}
{\catcode`\@ =11
\gdef\pagecontents#1{\ifvoid\topins\else\unvbox\topins\fi
\dimen@=\dp#1 \unvbox#1
\ifvoid\footins\else\vskip\skip\footins\footnoterule \unvbox\footins\fi
SHAR_EOF
true || echo 'restore of bcs-2.0/doc/texinfo.tex failed'
fi
echo 'End of bcs-2.0 part 6'
echo 'File bcs-2.0/doc/texinfo.tex is continued in part 7'
echo 7 > _shar_seq_.tmp
exit 0
