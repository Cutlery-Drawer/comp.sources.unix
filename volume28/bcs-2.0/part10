Newsgroups: comp.sources.unix
From: ejb@ERA.COM (Jay Berkenbilt)
Subject: v28i011: bcs-2.0 - A Baseline Configuration System, Part10/25
References: <1.764985670.1461@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: ejb@ERA.COM (Jay Berkenbilt)
Posting-Number: Volume 28, Issue 11
Archive-Name: bcs-2.0/part10

#!/bin/sh
# this is bcs.10 (part 10 of bcs-2.0)
# do not concatenate these parts, unpack them in order with /bin/sh
# file bcs-2.0/doc/bcs.texinfo continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 10; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping bcs-2.0/doc/bcs.texinfo'
else
echo 'x - continuing file bcs-2.0/doc/bcs.texinfo'
sed 's/^X//' << 'SHAR_EOF' >> 'bcs-2.0/doc/bcs.texinfo' &&
the same file.@footnote{Please note: Users must exercise some caution
if they intend to leave files unlocked while having them checked
out.  Although many configuration management packages allow this
mode of operation, it can have undesirable side effects when
used with BCS.  See the documentation for your configuration
management package for
further information.}  The file itself, however, is not touched
until 
the user runs @code{update_baseline}.  This way, file
modification times of checked out files are not changed until
the files contents are changed.  This prevents unnecessary
recompilation.  (Please note: If the underlying configuration
management package allows multiple locks on the same file, so
will BCS.)
X
@item BCS is written in a portable fashion in ``C'' and uses GNU
Autoconf for configuration.  This makes it easy to build from
source ``out of the box'' on a variety of UNIX platforms.  In
addition, BCS is delivered with a set of regression tests.  This
way, potential users can obtain the source code to BCS, easily
build and install the software with the aid of an automatically
generated @code{configure} script and @file{Makefile}, and then run
the regression test suite before installing the
@c can't use ~ here inside a footnote
package.@footnote{The regression test suite that comes with BCS
requires Perl 
version 4 
to run.}
@end itemize
X
@node Use of BCS, Command Descriptions, Advantages of BCS, Top
@comment  node-name,  next,  previous,  up
@chapter Use of BCS
X
This chapter provides detailed information on how to use BCS.
X
@menu
* Environment Variables::       
* Important and Unimportant Files::  
* Automatically Staged and Unstageable Files::  
@end menu
X
@node Environment Variables, Important and Unimportant Files, Use of BCS, Use of BCS
@comment  node-name,  next,  previous,  up
@section Environment Variables
@cindex environment variables
@cindex BASELINE environment variable
@cindex STAGING environment variable
X
BCS uses two environment variables:
@code{BASELINE}, which contains the pathname of the top-level
directory or directories in the baseline; and @code{STAGING},
which contains the 
pathname of the top-level directory or directories in the user's
staging area. 
All of the BCS programs require both of these variables to be
set before they will run.  Typically these environment variables
will be set automatically upon login in a given project
environment.  Both @code{BASELINE} and @code{STAGING} can be
set to colon-separated lists of directories.  BCS requires the
staging area to contain the same number of directories as the
baseline and requires each staging area directory to point to
its corresponding baseline directory.  For more information,
see @ref{Setting up BCS}.  It is possible
to specify baseline and staging area directories on the
commandline, but this functionality is provided primarily for
overriding the environment variables.  Users will find it less
cumbersome to set their @code{BASELINE} and @code{STAGING}
environment variables instead.
X
@node Important and Unimportant Files, Automatically Staged and Unstageable Files, Environment Variables, Use of BCS
@comment  node-name,  next,  previous,  up
@section Important and Unimportant Files
@cindex important files
@cindex unimportant files
@cindex importance of files
@cindex determining file importance
X
Although a description of the concepts of important and
unimportant files may seem out of place at this point in the
document, it is necessary that this concept be somewhat
understood before explanations of the commands will make sense.
Note that it is not important that you understand this whole
section.  In order to understand the commands, all you really
need to know is that importance of files is defined so that, in
general, the files you would need in your staging area if you
staged a directory end up being important.  The rest of this
section describes exactly what determines the importance
designation of a file.  You should be able to use the basic BCS
commands even if you don't fully understand the following
explanations.
X
@cindex important files
@cindex unimportant files
@cindex importance
@cindex file importance
@cindex file classification
@cindex classification of files
All files in the baseline are either important or unimportant;
that is, no file is without an importance designation.  A file
can be explicitly deemed important or unimportant, but
this is seldom necessary.
X
Files in the staging area are important if they are either for
internal use by BCS (currently only the top-level
@file{.baseline_path} file is) or if they have important baseline
counterparts that are not for internal use.  Files in the
baseline have their importance determined in several ways.
Every file has an importance which can be overridden explicitly.
By default, files in the baseline that are neither symbolic
links nor directories are important if they are registered
with the underlying configuration management package and are
unimportant otherwise. 
Directories are considered important by default.  Symbolic links
to files in the baseline inherit their importance from the files
they are ultimately linked to.  Symbolic links to files outside
of the baseline are unimportant by default.  A file or directory
becomes explicitly unimportant by appearing in the
@file{.unimportant} file or explicitly important by appearing in
the @file{.important} file in its containing directory.  These
files each may have only one file per line.  If a file appears
in both a @file{.important} file and a @file{.unimportant} file,
it is considered important.  The @file{.important} file
generally contains a list of files or directories that are
important.  Although this file cannot contain regular
expressions in general, the special case of the
@file{.important} file containing @samp{*} alone means all
files in the directory are considered important.  This is useful
for directories that contain installed targets such as programs
or libraries.
X
Files that are used internally by BCS or the underlying
configuration management package are special cases.  They are
always considered important and cannot have their importance
designation overridden.  Files used internally by BCS are the
only files that can be important in the baseline and
unimportant in the staging area.  They are also the only
important files that do not get linked into the staging area. 
X
@node Automatically Staged and Unstageable Files,  , Important and Unimportant Files, Use of BCS
@comment  node-name,  next,  previous,  up
@section Automatically Staged and Unstageable Files
@cindex automatically staged files
@cindex unstageable files
@cindex staging files automatically
@cindex preventing files from being staged
X
In general, every file in the baseline is a candidate for
editing by developers of a system.  There are cases, however, in
which it is desirable to restrict some files from being able to
be staged or force other files to be staged automatically.  For
example, suppose one of the functions of a system involves
creating or accessing multiple data files, and it is desired that
all users always access the same set of files.  If the data
files are stored in the baseline, the directory containing them
could be made unstageable.  This way, the logical path from the
top of each staging area and from the top of the baseline would
always point to the same actual files.  On the other hand, if it
was desired that all users always see different copies of these
files, the containing directory could be set to be automatically
staged.  In this case, the users would not be able to
accidentally overwrite the baseline copies of the files.
X
Files are made unstageable by putting their names (one file per
line) in a @file{.no_stage} file and are made automatically
stageable by putting their names (one file per line) in a
@file{.auto_stage} file.  These files should exist only in the
baseline and are optional.  They can exist in any directory in
the baseline.
X
@node Command Descriptions, Supported Configuration Management Systems, Use of BCS, Top
@comment  node-name,  next,  previous,  up
@chapter Command Descriptions
@cindex command descriptions
X
All BCS commands understand a core set of options and accept them
without error.  Not all commands pay attention to all
options.  The following sections describe the standard options
and the BCS commands.
X
@menu
* Standard Options::            
* BCS Command Summary::         
@end menu
X
@node Standard Options, BCS Command Summary, Command Descriptions, Command Descriptions
@comment  node-name,  next,  previous,  up
@section Standard Options
@cindex standard command line options
@cindex commandline flags
@cindex standard flags
X
@table @asis
@item @code{--help} or @code{-h}
X   If this flag is specified, the usage message is printed, and
X   the command exits.
X
@item @code{--version}
X   If this flag is specified, the current version of the
X   software and the list of supported configuration management
X   packages are printed, and the program exits.
X
@item @code{--baseline}
X   This option is followed by a single directory name or a
X   colon-separated list of directory names.  It is used to
X   override the setting of the @code{BASELINE} environment
X   variable which does not have to be set if this flag is
X   provided. 
X
@item @code{--staging}
X   This option is followed by a single directory name or a
X   colon-separated list of directory names.  It is used to
X   override the setting of the @code{STAGING} environment
X   variable which does not have to be set if this flag is
X   provided. 
X
@item @code{--debug}
X   This option is followed by a colon-separated list of debug
X   flags.  This command is intended for use only in debugging
X   BCS and is not recommended for use by end-users.  It is only
X   available if BCS was compiled with debugging enabled.  For
X   more information, see @ref{Debugging}.
X
@item @code{--silent}
X   This flag causes the suppression of diagnostic messages but
X   not the suppression of error messages.
X
@item @code{--recursive} or @code{-r}
X   For applicable commands, this flag indicates that the
X   operation should be performed recursively.  This flag is used
X   only for the commands @code{classify_files},
X   @code{id_important}, 
X   @code{id_unimportant}, @code{id_staged}, and
X   @code{sync_staging}. 
X
@item @code{--no-action} or @code{-n}
X   This flag specifies that the baseline and staging areas
X   should not be modified but that the commands should print
X   what they would do.  The output of a command with the
X   @code{--no-action} flag may differ from the
X   command's output without the flag since frequently one
X   operation by a command is dependent upon the outcome of
X   previous actions.  This option is not meaningful for all
X   commands. 
X
@end table
X
@node BCS Command Summary,  , Standard Options, Command Descriptions
@comment  node-name,  next,  previous,  up
@section BCS Command Summary
@cindex command summary
@cindex BCS commands
X
The complete list of BCS commands appears here
with brief synopses and descriptions.  All the commands
except for @code{in_baseline} and
@code{in_staging_area} require arguments.  The order of
arguments is not important.  When any other
command is invoked without arguments, it gives a brief summary
of its usage.  Usage is available for all commands by invoking
them with the @code{--help} or @code{-h} flags.
X
@menu
* Baseline Containment Commands::  
* File Classification Commands::  
* Staging Area Maintenance Commands::  
@end menu
X
@node Baseline Containment Commands, File Classification Commands, BCS Command Summary, BCS Command Summary
@comment  node-name,  next,  previous,  up
@subsection Baseline Containment Commands
@cindex baseline containment commands
@table @code
@item in_baseline
@cindex in_baseline command
X
@c I know that the Texinfo document recommends using @samp
@c instead of @code for this type of thing, but I don't want
@c quotes around command usage messages.
X
Usage: @code{in_baseline [ @var{file} ] [ @var{standard-options} ]}
X
This command takes an optional filename as an argument and
prints @samp{1} if it is in the baseline or @samp{0}
otherwise.  If no path is given, the current directory is
used. 
X
@item in_staging_area
@cindex in_staging_area command
Usage: @code{in_staging_area [ @var{file} ] [ @var{standard-options} ]}
X
This command prints @samp{1} if you are in your staging or
@samp{0} otherwise.
X
@end table
X
These commands are intended for use in shell scripts.  They allow you to 
say
X
@example
if (`in_baseline`) @dots{}
@end example
X
If staging areas are subdirectories of the baseline, a file
in the staging area is logically under a baseline directory.
Even so, the @code{in_baseline} command will print @samp{1}
only if the file in 
question is not in a staging area.  This way,
@code{in_baseline} and @code{in_staging_area} will
never both print @samp{1} for a given file.
X
@node File Classification Commands, Staging Area Maintenance Commands, Baseline Containment Commands, BCS Command Summary
@comment  node-name,  next,  previous,  up
@subsection File Classification Commands
@cindex file classification commands
X
The commands described in this section are used to find out
about the classification of given files or to make lists of
files with certain attributes.
In addition to the standard options understood by all BCS
commands, the file classification commands understand the
following additional command line options:
X
@table @code
@item [ -dirs | -nodirs ]
X   The @code{-dirs} and @code{-nodirs} flags are used to
X   determine whether directory names are printed as well as file
X   names.  If the recursive option is given, the default is
X   @code{-nodirs}.  If not, the default is @code{-dirs}.
X   Directory names are printed with trailing slashes for
X   clarity. 
X
@item [ -descend | -nodescend ]
X   The @code{-descend} flag means that when directories are specified on
X   the command line, information is printed about the files in
X   the directories 
X   instead of the directories themselves.  If
X   @code{-nodescend} is specified, the
X   command will operate on the directories rather than their
X   contents.  The 
X   default is @code{-descend}.  If @code{--recursive} is
X   specified, then these flags are ignored, and
X   @code{-descend} is always assumed.
X
@end table
X
@noindent Here are descriptions of the file classification commands:
X
@table @code
@item classify_files
@cindex classify_files command
X
Usage: @code{classify_files @var{file} [ @var{file} @dots{}@: ]
[ @var{standard-options} ]}
X
The @code{classify_files} command identifies files as either
important or unimportant.
X
This command prints a list of all files in the current
directory (recursively if the @code{--recursive}
flag is specified) followed by whether the
file is important or unimportant.
X
@item id_important
@cindex id_important command
X
Usage: @code{id_important @var{file} [ @var{file} @dots{}@: ]
[ @var{standard-options} ]}
X
The @code{id_important} command prints the names of all
important files in the specified directory or directories.
Directories are descended recursively if the
@code{--recursive} flag is specified.
X
@item id_unimportant
@cindex id_unimportant command
X   
Usage: @code{id_unimportant @var{file} [ @var{file} @dots{}@: ]
[ @var{standard-options} ]}
X
The @code{id_unimportant} command prints the names of all
unimportant files in the specified directory or directories.
Directories are descended recursively if the
@code{--recursive} flag is specified.
X
@item id_staged
@cindex id_staged command
Usage: @code{id_staged @var{file} [ @var{file} @dots{}@: ]
[ @var{standard-options} ]}
X
The @code{id_staged} command prints the names of all
staged files in the specified directory or directories.
Directories are descended recursively if the
@code{--recursive} flag is specified.
X
This command is handy when used 
in shell substitutions.  For example, to check in all
staged files in the current directory, one may issue a
command such as
X
@example
bcs ci -u `id_staged -nodirs .`
@end example
X
@item bcs_info
@cindex bcs_info command
X
Usage: @code{bcs_info @var{file} [ @var{file} @dots{}@: ]
[ @var{standard-options} ]}
X
The @code{bcs_info} command gives general information
about the files or directories passed to it.  It is used
primarily for debugging baseline and staging area configurations
and can be useful for advanced users.  Its output is not
terribly friendly, but it provides some information that is
not available from other sources.
X
@end table
X
@node Staging Area Maintenance Commands,  , File Classification Commands, BCS Command Summary
@comment  node-name,  next,  previous,  up
@subsection Staging Area Maintenance Commands
@cindex staging area maintenance commands
X
The commands described in this section are used for maintenance
of the staging area.
X
@table @code
@item sync_staging
@cindex sync_staging command
X
Usage: @code{sync_staging @var{dir} [ @var{dir} @dots{}@: ] 
[ @var{standard-options} ]}
X
The @code{sync_staging} command is used to synchronize the
staging area with the baseline.
X
Each directory on the command line is synchronized.  If the
@code{--recursive} flag is present, the directories
listed are synchronized recursively.  It is a good idea to run
X
@example
sync_staging -r .
@end example
X
at each top-level staging
area directory every few days or whenever you are aware of new
additions to or deletions from the baseline.
X
When @code{sync_staging} is run, dangling symbolic links
are removed, missing symbolic links are created, and outdated
symbolic links are updated.  In addition, any automatically
stageable files are staged and any staged files that are
marked as unstageable cause a warning to be issued.
X
If @code{sync_staging} detects unimportant directories or
unimportant files with specified suffixes in the staging
area, it will warn the user to that effect.  The special
suffixes can be specified in the baseline's
@file{.baseline_conf} file.  For more information,
see @ref{Internal Files}.
X
For more detail on the exact procedure used for synchronization,
see @ref{Staging and Synchronization}. 
X
@item stage
@cindex stage command
X
Usage: @code{stage @var{path} [ @var{path} @dots{}@: ] 
[ @var{standard-options} ]}
X
The @code{stage} command is used to replace symbolic links
from the staging area to the baseline with actual files and
directories.  The @code{--recursive} flag is ignored
for this command.
X
The @var{path} arguments to this command must logically fall
within the user's staging area.  The @code{stage} command
performs whatever
operations are necessary to cause the specified paths to
actually exist in the staging area.  In the simplest case,
@var{path} is a symbolic link in the staging area to a
file in the baseline.  In this case, the link is removed and
replaced with a copy of the file.  If @var{path} is a
link to a directory, the link is removed and replaced by a
directory which is then populated with links to the
baseline.  In the most complicated case, the file being
staged isn't a link but one of its containing directories is.
In this case, @code{stage} will automatically stage all
necessary directories down to @var{path} before staging
@var{path}.  This command will refuse to stage
unimportant files or files that are explicitly forbidden from
being staged by appearing in the @file{.no_stage} file in
the baseline directory containing the file.
X
If you try to stage a file or directory that is already
staged, a message is printed to that effect.  This is not
considered an error condition.
X
For more detailed information on what happens when files or
directories are staged, see @ref{Staging and Synchronization}.
X
@item unstage
@cindex unstage command
X
@iftex
@tex
Usage: @code{unstage @var{path}} @code{[ @var{path} @dots{}@: ]}
@code{[ --force | -f | --interactive | -i ]}
@code{[ @var{stan\-dard-op\-tions} ]}
@end tex
@end iftex
@ifinfo
Usage: @code{unstage @var{path} [ @var{path} @dots{}@: ]
[ --force | -f | --interactive | -i ]
[ @var{standard-options} ]}
@end ifinfo
X
The @code{unstage} command is used to replace a file or
directory in the staging area with a link to the baseline.
It is the opposite of the @code{stage} command.  The
@code{--recursive} flag is meaningless for this
command and is ignored.
X
Since the unstage command removes files from the user's
staging area, it is potentially dangerous.  For this reason,
a number of checks are made.  If @var{path} is a file, it
must be a file that is staged.  If the file has a history log,
additional checks are performed.  Specifically, if the file
is writable or does not appear to be updated in the baseline,
the @code{unstage} command will proceed only after
receiving confirmation from the user.  When unstaging a
directory, this command performs checks on all files in the
directory and its subdirectories that have logs in the
configuration management system.  If any are writable or not
updated, it asks for confirmation for all at once.  The
entire unstage operation is then either performed or canceled.
X
In addition, if unimportant directories or unimportant files
are detected, this command will require confirmation before
removing these as well.  This can save the user from losing
work if new source files are added without being registered
(with the @code{register_file} command) or if directories
without baseline counterparts are created in the staging
area. 
X
By default, the @code{unstage} command only solicits user
input if it detects that it is running interactively.  If you
want it to try to ask regardless, specify the
@code{--interactive} or @code{-i} flag to the
program.  Otherwise, negative answers will be assumed for all
questions.  If you want positive answers to be assumed for all
questions, specify the @code{--force} or
@code{-f} flag to the program.  This flag should be used
with extreme care since it is turns off checks and could
cause changes to be lost.
X
Note that since no checks are performed for unimportant files
without special suffixes or for staged files without history logs,
unstaging directories should be done with caution.  If you
avoid creating files in your staging area that you wish to
save without registering them, you should be safe.  If you
think you have created new files and not registered them with the
configuration management package (see the
@code{register_file} command), you may want to perform a
recursive @code{id_unimportant} command to make sure that
you are prepared to lose all unimportant files.
X
The @code{unstage} command
is most useful when you are finished making changes to a
component of the system and have tested your changes.  It can
also be useful for replacing binary or library directories in
your staging area with links back to the baseline.
X
If you try to unstage a file that is already unstaged, a
message to that effect will be printed.  This is not an error
condition.
X
It is permissible to unstage files that are automatically
stageable.  In this case, the files will be restaged
automatically 
after being unstaged.  This provides a convenient way of
removing all unimportant files or reverting some kinds of
changes. 
X
Note that it is generally not necessary to unstage a file
since the
@code{update_baseline} does this for you.  It is sometimes 
desirable to unstage a file when backing out changes,
however, since this would prevent unnecessary updates to the
baseline.  Even this is not generally necessary since the
@code{update_baseline} command detects when files are
already up-to-date.  Refer to the documentation for your
configuration management
system for more information on reverting files.
X
@item bcs
@cindex bcs command
X
Usage: @code{bcs command arguments [ @var{standard-options}]}
X
The @code{bcs} command serves as a front-end to the
underlying configuration management system.
The arguments to the @code{bcs} command
should make a complete
command for the underlying configuration
management system.  The command is executed as given except
that additional checking is done to assure that the desired
files are in the staging area and are eligible.  When this
command is used to check files out, it will also stage them. 
For example, the command
X
@example
bcs co -l src/a.c
@end example
X
would do the same thing as
X
@example
co -l src/a.c
@end example
X
X except that it would stage the files and verify that they are
valid for being checked out.
X
For RCS, valid commands for @code{bcs} are @code{co} and
@code{ci}.  For SCCS, valid commands are @code{edit},
@code{get}, @code{deledit}, @code{delget}, @code{unedit},
and @code{unget}.
X
@item update_baseline
@cindex update_baseline command
X
Usage: @code{update_baseline @var{file} [ @var{file} @dots{}@: ]
[ @var{standard-options} ]}
X
The @code{update_baseline} command updates the baseline
copy of a 
file by setting it to the default version in its history log.
Unless the user has explicitly specified otherwise in the history
log, this is generally the most recent version of the file.  If
@code{update_baseline} succeeds in updating the baseline
copy of a file, it will unstage the file.
X
The @code{update_baseline} command requires its arguments
to be non-writable files.  If the file is already unstaged,
the baseline copy will be updated anyway.  This command
detects if a file is already up-to-date.  This reduces the
likelihood of updating a file's modification time needlessly
in the baseline and can prevent extra compiles from occurring
if a file is checked out and then not modified before being
checked in.
X
@item register_file
@cindex register_file command
X
Usage: @code{register_file @var{file} [ @var{file} @dots{}@: ]
[ @var{standard-options} ]}
X
The @code{register_file} command is used to add new files
to the baseline.
If @var{file} already exists in the baseline, this
command will fail.  Otherwise, if the file does not already
exist in the staging area, all necessary directories will be
created, an empty file will be created in both the
baseline and the staging area, and the file will be locked and
made writable in the staging area.  If the file does exist in
the staging area, the file will be copied into the baseline
(with execute permissions preserved),
checked in, and locked.
Typically, @code{register_file} should be used
before the file is created in the staging area.  This
decreases the likelihood that two users will simultaneously
create the same file in their staging areas and run into
conflicts when they are ready to update the baseline.
X
@end table
X
@node Supported Configuration Management Systems, Example Baseline, Command Descriptions, Top
@comment  node-name,  next,  previous,  up
@chapter Supported Configuration Management Systems
@cindex supported configuration management systems
X
This chapter briefly discusses how the supported configuration
management systems fit into BCS.
X
@menu
* RCS support::                 
* SCCS support::                
@end menu
X
@node RCS support, SCCS support, Supported Configuration Management Systems, Supported Configuration Management Systems
@comment  node-name,  next,  previous,  up
@section RCS support
@cindex RCS support
@cindex using BCS with RCS
X
This section describes behavior of BCS that is specific to
RCS-based baselines.  When using RCS, the @code{bcs} command
should be used instead of the @code{co} and @code{ci}
commands from RCS.  Whenever you would use a @code{co} or
@code{ci} command, use @code{bcs co} or @code{bcs ci}
instead.  For all other cases, use the RCS commands directly.
BCS is most flexible when used with RCS since it does not take
away any of RCS's functionality.  Specifically, execute
permissions are preserved on files when they are checked in,
checked out, staged, or updated, and it is possible to check
files in and out that aren't in your current working directory. 
X
@node SCCS support,  , RCS support, Supported Configuration Management Systems
@comment  node-name,  next,  previous,  up
@section SCCS support
@cindex SCCS support
@cindex using BCS with SCCS
X
X
This section describes behavior of BCS that is specific to
SCCS-based baselines.  Because of certain restrictions of SCCS,
BCS cannot be as robust or versatile with SCCS as the underlying
configuration management
package as it can with RCS.  Specifically, the SCCS checkin
and checkout operations only work on files in the current
directory.  Trying to use BCS to do otherwise will result in the
same kinds of problems as trying to use SCCS to do otherwise.
See the documentation on SCCS for more details.  In addition,
since SCCS is not as robust at handling user errors or aborts as
RCS, BCS cannot be as robust in handling user errors or aborts
with SCCS as it is with RCS as the underlying package.  In
spite of these limitations, all the main features of BCS work
with SCCS 
including being able to update the baseline and register files
that are not in the current directory.
X
It should be noted that there is currently a problem with
updating the baseline when the @code{%T%} or @code{%D%} SCCS
keywords are used in files.  Since these are updated with the
last checkout time instead of the last checkin time or lock
time, comparing the existing baseline version with the last
checked-in version will always fail when these are present in
the file.  A fix for this may be pending if there is enough
demand. 
X
When using SCCS as the underlying configuration management
package, BCS should be used in place of SCCS for the @code{sccs
edit}, @code{sccs get}, @code{sccs deledit}, @code{sccs delget},
@code{sccs unedit}, and @code{sccs unget} commands.
Specifically, use @code{bcs edit}, @code{bcs get}, @code{bcs
deledit}, @code{bcs delget}, @code{bcs unedit}, and @code{bcs
unget} instead.  Normal SCCS commands can be used in all other
cases.
X
@node Example Baseline, Technical Guide to BCS, Supported Configuration Management Systems, Top
@comment  node-name,  next,  previous,  up
@chapter Example Baseline
@cindex example baseline
@cindex baseline example
X
@set figbaseline 1
@set figstagea 2
@set figstageb 3
@set figstagec 4
X
This section presents an example of what you need to do to edit
a file and update the changes in the baseline.  For these
examples, the baseline configuration shown in
@ifinfo
Figure @value{figbaseline} 
@end ifinfo
@iftex
@tex Figure~@value{figbaseline}  @end tex
@end iftex
will be used.  In addition, we assume
that the baseline uses RCS.  Note that everything in
the picture is a directory except for the files @file{a.c} and
@file{a.c,v}. 
X
@sp 2
X
@ifset DVIPS
@tex
\input epsf
\centerline{\epsfbox{baseline.EPS}}
\vskip\baselineskip
\centerline{Figure @value{figbaseline}: Baseline}
@end tex
@end ifset
X
@ifclear DVIPS
@cartouche
@smallexample
@include baseline.txt
X
Figure @value{figbaseline}: Baseline
X
@end smallexample
@end cartouche
@end ifclear
X
@sp 2
X
Now suppose we have a staging area.  Let's assume that the
staging area is in its initial state; 
@iftex
@tex
{\sl i.e.},
@end tex
@end iftex
@ifinfo
i.e.,
@end ifinfo
the top-level
directory exists and all other directories are links.  The staging
area will look like 
@ifinfo
Figure @value{figstagea}.
@end ifinfo
@iftex
@tex Figure~@value{figstagea}. @end tex
@end iftex
X
@sp 2
X
@ifset DVIPS
@tex
\input epsf
\centerline{\epsfbox{stagea.EPS}}
\vskip\baselineskip
\centerline{Figure @value{figstagea}: Initial staging area}
@end tex
@end ifset
X
@ifclear DVIPS
@cartouche
@smallexample
@include stagea.txt
X
Figure @value{figstagea}: Initial Staging Area
X
@end smallexample
@end cartouche
@end ifclear
X
@sp 2
X
At this point, the user will want to check out the file
@file{a.c}.  The user types 
X
@example
cd Staging
bcs co -l A/F/a.c
@end example
X
BCS will stage @file{A}, @file{A/F}, and @file{A/F/a.c} before
checking out @file{A/F/a.c}.  The staging area will then look
like 
@ifinfo
Figure @value{figstageb}. 
@end ifinfo
@iftex
@tex Figure~@value{figstageb}.  @end tex
@end iftex
X
@sp 2
X
@ifset DVIPS
@tex
\input epsf
\centerline{\epsfbox{stageb.EPS}}
\vskip\baselineskip
\centerline{Figure @value{figstageb}: 
Staging area after checking out @file{A/F/a.c}}
@end tex
@end ifset
X
@ifclear DVIPS
@cartouche
@smallexample
@include stageb.txt
X
Figure @value{figstageb}: Staging area after checking out @file{A/F/a.c}
X
@end smallexample
@end cartouche
@end ifclear
X
@sp 2
X
Now the user can edit the file, check it in, and
update it in the baseline.
X
@example
cd A/F
(edit a.c)
bcs ci -u a.c
update_baseline a.c
@end example
X
After the user updates the baseline, the file @file{a.c} will be
a link to the baseline.  This is shown in 
@ifinfo
Figure @value{figstagec}. 
@end ifinfo
@iftex
@tex Figure~@value{figstagec}.  @end tex
@end iftex
X
@sp 2
X
@ifset DVIPS
@tex
\input epsf
\centerline{\epsfbox{stagec.EPS}}
\vskip\baselineskip
\centerline{Figure @value{figstagec}: Staging area after updating @file{a.c}}
@end tex
@end ifset
X
@ifclear DVIPS
@cartouche
@smallexample
@include stagec.txt
X
Figure @value{figstagec}: Staging area after updating @file{a.c}
X
@end smallexample
@end cartouche
@end ifclear
X
@sp 2
X
Finally, the user can unstage @file{A} at the top of the staging
area.  
X
@example
cd ../..
unstage A
@end example
X
At this point, the staging area will once again look like
@ifinfo
Figure @value{figstagea}. 
@end ifinfo
@iftex
@tex Figure~@value{figstagea}.  @end tex
@end iftex
X
@menu
* Common Operations::           
@end menu
X
@node Common Operations,  , Example Baseline, Example Baseline
@comment  node-name,  next,  previous,  up
@section Common Operations
@cindex common operations
@cindex frequently used commands
X
The following table shows a list of situations and the commands
that would be used in those situations.
X
@cartouche
@table @asis
@item To check out a file to edit
@example
bcs co -l @var{file}
@end example
X
@item To check in a file but keep working
@example
bcs ci -l @var{file}
@end example
X
@item To check in a file and update baseline
@example
bcs ci -u @var{file}
update_baseline @var{file}
@end example
X
@item To recover from accidental check out of a file
@example
bcs ci -u @var{file}
X   (file is reverted)
unstage @var{file}
X   @emph{OR}
update_baseline @var{file}
@end example
X
@item To revert and discard changes to a file
@example
bcs co -u @var{file}
X   (answer yes to RCS; file is reverted)
unstage @var{file}
X   @emph{OR}
update_baseline @var{file}
@end example
X
@item To create a new file and edit it
@example
register_file @var{file}
X   (edit the file)
@end example
X
@item To add a file that already exists to the baseline
@example
register_file @var{file}
bcs ci -u @var{file}
update_baseline @var{file}
@end example
X
@item To synchronize entire staging area
@example
cd @var{top-staging-area-directory}
sync_staging -r .
@end example
X
@end table
@end cartouche
X
X
@node Technical Guide to BCS, Example Uses of BCS, Example Baseline, Top
@comment  node-name,  next,  previous,  up
@chapter Technical Guide to BCS
X
The material in this section is primarily intended for the
system or baseline administrator but could be useful for end
users as well.  This section describes how to configure a
baseline for use with BCS and how to customize the behavior of
BCS to suit your needs.
X
@menu
* Setting up BCS::              
* Creating the Baseline::       
* Internal Files::              
* Creating Staging Areas::      
* Adding BCS to an Existing Baseline::  
@end menu
X
@node Setting up BCS, Creating the Baseline, Technical Guide to BCS, Technical Guide to BCS
@comment  node-name,  next,  previous,  up
@section Setting up BCS
@cindex setting up BCS
@cindex initial setup
X
BCS should to be installed on the system as a third-party
application.  It may be delivered with a baseline as long as the
terms of the General Public License or Artistic License
(@pxref{Copying}) are followed.  See the BCS distribution 
for instructions on building and installing BCS.
X
Users of BCS should have the BCS commands in their path. 
They will probably also want the
command of the underlying configuration management package in
their path, but this is 
not necessary for BCS since it invokes all commands with full
pathnames (selected at compile-time) for security reasons.
They also need to have the
environment variables @code{BASELINE} and @code{STAGING} set
to the tops of the baseline and their staging areas.  It is a
good idea to provide something for users to source from their
@file{.cshrc} and/or @file{.login} files (or wherever you add such
things on your system) so that users don't have to be concerned
about these details themselves.
X
@node Creating the Baseline, Internal Files, Setting up BCS, Technical Guide to BCS
@comment  node-name,  next,  previous,  up
@section Creating the Baseline
@cindex creating the baseline
@cindex baseline creation
@cindex initial baseline creation
X
The baseline can have any structure that is convenient for the
project.  The only constraint that BCS imposes is that the
underlying configuration management system be one that it
supports.  As of the writing of this document, only RCS and SCCS
are supported.  However, it would be easy to add support for any
configuration management system that is similar to RCS or SCCS.
For information about this, 
see @ref{Configuration Management Package Interface}.
The baseline should first be set up to
support use of the underlying package.  In the case of RCS,
this means that @file{RCS} directories should be created in every
directory in which files will be checked in.  Please see the
RCS manual pages for more information about RCS.  In
the case of SCCS, @file{SCCS} directories should be created.
See the SCCS documentation for more information about SCCS.
It is suggested but not required that the baseline directories
be created with the setgid bit set.  This way, they will pass
their group on to files and directories created in
them.@footnote{This does not work on all operating systems.}
All 
directories in the baseline must be writable by all users of the
system who are authorized to check files in, register files, and
update the baseline.
X
@node Internal Files, Creating Staging Areas, Creating the Baseline, Technical Guide to BCS
@comment  node-name,  next,  previous,  up
@section Internal Files
@cindex internal files
X
For BCS to operate according to specific project needs, a number
of special files can be be created.  Most of these reside in the
baseline and most are optional.  The special files (referred to
here as @dfn{internal files}) are as follows:
X
@table @code
X
@item .baseline_conf
@cindex .baseline_conf file
X
This file must exist at each
top-level baseline directory.  A file by this name is not  
treated specially by BCS if it exists in any other location.
This file sets various parameters specific to this baseline for
BCS.  In some cases, the information in the
@file{.baseline_conf} files must agree in all baseline
directories.  (BCS enforces this, so there is no risk of
accidental inconsistency.)  The format of this file is a list of
key-value pairs.  Only one pair should appear on each line.  The keys
and values are separated by colons.  Blank lines are ignored.
The following keys are valid:
X
@itemize @bullet
@item
@code{cm}.  This key is required.  Its value is the name
of a supported configuration management package.
@item
@code{unimp_warn_suffixes}.  This key is used to specify
a list of suffixes that should be given special treatment by the
@code{unstage} and @code{sync_staging} commands.
Specifically, any unimportant files encountered that end with
one of the suffixes listed are brought to the attention of the
user by @code{sync_staging} and are not deleted by
@code{unstage} without confirmation.  Suffixes listed here
are separated by white-space.  This behavior can be turned off
on a per-directory basis with the @file{.unimp_nowarn} file.
@end itemize
X
@item .baseline_path
@cindex .baseline_path file
This file must exist at each
top-level staging area directory.  This file is not treated
specially by BCS if it appears in any other location.  This file
should contain one line: the path to the baseline
with respect to the staging area directory.  It can be either an
absolute path or a relative path.  The links created in the
staging area by @code{stage} and @code{sync_staging} use
this information.  If a staging area is moved so that the
baseline path is no longer valid, it is sufficient to update
this file and run a recursive @code{sync_staging}.  This is
likewise sufficient after the baseline is moved or after the
baseline path has been changed from absolute to relative or
relative to absolute.
X
@item .important
@cindex .important file
A file by this name is treated
specially by BCS only when it appears in the baseline.  This
file can exist in any baseline directory at any level.  If it
exists, it generally contains a list of files, one per line, to
be considered important even if they would not be important by
default.  Although it cannot contain regular expressions in
general, if it contains only a line with the @samp{*} character
in it, it means that all files in the directory are
automatically important.  It is not generally necessary to make
specific files important explicitly, but it can be useful in
certain instances.  For example, in a software project, it may
be desirable to put
@samp{*} in @file{.important} in a directory that contains
installed binary files or to put a few specific installed
binaries in a @file{.important} file in a directory that
contains a combination of a few installed binaries and some
scripts with history logs.  Gratuitous use of this file is
discouraged.  It is not appropriate to use this file to
avoid having to check in files that you want to see in the
staging areas unless those files really aren't supposed to be
edited by the user.  (In this case, putting them in
@file{.no_stage} may also be desirable.)  If you find yourself
making frequent use of the @file{.important} file, you should
probably rethink your baseline configuration.
X
@item .unimportant
@cindex .unimportant file
A file by this name is treated
specially by BCS only when it appears in the baseline.  This
file can exist in any baseline directory at any level.  If it
exists, it contains a list of files, one per line, that are
explicitly unimportant.  It can be useful for preventing
temporary directories created in the baseline from showing up in
the staging area, for example.  Another good use of the
@file{.unimportant} file is to prevent a directory in the
baseline that contains staging areas from showing up in people's
staging areas.  If a file appears in both @file{.unimportant}
and @file{.important}, the file is considered important.
X
@item .auto_stage
@cindex .auto_stage file
A file by this name is treated
specially by BCS only when it appears in the baseline.  This
file can exist in any baseline directory at any level.  If it
exists, it contains a list of files, one per line, that should
be staged automatically when the directory is staged.  This can
be useful for forcing directories that the system writes into at
run time to be staged separately in each user's staging area.
X
@item .no_stage
@cindex .no_stage file
A file by this name is treated
specially by BCS only when it appears in the baseline.  This
file can exist in any baseline directory at any level.  If it
exists, it contains a list of files, one per line, that are
prohibited from being staged.  This can be useful for files that
are explicitly made important but shouldn't be edited in the
staging areas or for directories that must be shared across all
staging areas.
X
@item .unimp_nowarn
@cindex .unimp_nowarn file
A file by this name is treated
specially by BCS only when it appears in the baseline.  This
file can exist in any baseline directory at any level.  The
contents of the file are currently ignored.  If this file
exists, then @code{sync_staging} and @code{unstage} will
not warn when they find unimportant directories
or unimportant files with special suffixes.  This can be useful
in a baseline 
where, for example, files ending with @samp{.c} are special but
one directory contains many automatically generated @samp{.c}
files that are not important and shouldn't be.  This file should
be used with caution since it turns off some checks.  This file's
effect is limited to the directory in which it appears.  It does
not apply recursively.  It also does not affect checks that are
made on important files.
@end table
X
@node Creating Staging Areas, Adding BCS to an Existing Baseline, Internal Files, Technical Guide to BCS
@comment  node-name,  next,  previous,  up
@section Creating Staging Areas
@cindex staging area creation
@cindex creating staging areas
@cindex making new staging areas
@cindex new staging areas
X
Staging areas are special symbolic link farms to the baseline.
A staging area must contain the same number of top-level
directories as the baseline.  Each top-level staging area
directory must 
contain a @file{.baseline_path} file as described above.
To create a staging area, simply create a directory corresponding
to each baseline directory and populate it with a
@file{.baseline_path} file.  Then run @code{sync_staging}
in each staging area directory to populate it with the initial
set of links.  It may be desirable for specific programs to
provide scripts for users to use to create their own staging
areas to assure that staging areas parallel baselines in their
structure.  This will not generally be necessary if there is
only one top-level directory in the baseline.
X
Here is a simple example of creating a staging area.  We assume
that the user @samp{q_user} is working on a project called
@samp{q_project}.  The baseline consists of one top-level directory
called @file{/projects/q_project}.  All users in this project
are in the group @samp{q}.  The user wishes to create a staging
area in his or her own home directory.
X
@example
cd
mkdir q_project
chmod g+s q_project
chgrp q q_project
cd q_project
echo /projects/q_project > .baseline_path
sync_staging .
@end example
X
@node Adding BCS to an Existing Baseline,  , Creating Staging Areas, Technical Guide to BCS
@comment  node-name,  next,  previous,  up
@section Adding BCS to an Existing Baseline
@cindex adding BCS to an existing baseline
@cindex converting a baseline to use BCS
X
Adding BCS to an existing baseline that uses a supported
configuration management system is fairly straight forward.
All that is required is placing the
correct internal files (as described above) in the correct
locations.  It may be desirable to set up the compilation tools
so that they know about BCS, but with suitable use of internal
files, even this is not generally necessary.  At the very least,
a baseline needs a @file{.baseline_conf} file to use BCS.
X
A set of makefiles and scripts that implement a build
environment suitable for use with BCS is provided with the
sources.  These are in the public domain and not protected under
any of the licenses included with BCS.  The contributed
makefiles use features of GNU make, but the functionality of GNU
make is not required to support BCS.  These makefile templates
can be found in the sample baseline under the
@file{unsupported/sample-baseline} directory in the source
distribution.
X
@node Example Uses of BCS, Possible Future Enhancements, Technical Guide to BCS, Top
@comment  node-name,  next,  previous,  up
@chapter Example Uses of BCS
X
This section describes some example uses of BCS.  It is not
intended to be a complete list of uses or to be a thorough set
of instructions for any of these situations.  This section is
merely provided in an effort to help give new or prospective
users some ideas of how they might use this tool.
X
@menu
* Multiple Simultaneous Developers::  
* Support for a Multi-platform Environment::  
@end menu
X
@node Multiple Simultaneous Developers, Support for a Multi-platform Environment, Example Uses of BCS, Example Uses of BCS
@comment  node-name,  next,  previous,  up
@section Multiple Simultaneous Developers
@cindex multiple developers
X
BCS was originally designed for use by many developers working
on a common body of source code.  Since this was the situation
for which BCS was designed, it works well for this case.  In
this situation, the baseline is the authoritative body of source
code, documentation, etc.@: for the project.  It is controlled
under a version control or configuration management system such
as RCS or SCCS.  BCS can be used to provide a degree of
concurrency without fundamentally changing the structure or
organization of the baseline.  Each programmer on the project
will have his or her own staging area and will stage only the
sections of the project that he or she is currently working on.
Programmers will test their changes in their own staging areas
and update the baseline only when their changes are stable.
BCS will be only part of the baseline management procedures that
this project should use.  BCS provides concurrency.  Other
procedures must be in place to maintain the stability of the
baseline.  These procedures could be a simple as specifying who
is or is not authorized to update the baseline at what times.
They could also be much more elaborate.  An example procedure
follows.
X
@menu
* Maintaining Baseline Stability::  
@end menu
X
@node Maintaining Baseline Stability,  , Multiple Simultaneous Developers, Multiple Simultaneous Developers
@comment  node-name,  next,  previous,  up
@subsection Example Procedure for Maintaining Baseline Stability
@cindex maintaining baseline stability
@cindex merging procedures
@cindex incremental merging
X
This section suggests a possible solution to the problem of
having conflicting changes being made to files in the baseline
or to changes being made by one user and covered up by another
user.  
X
@menu
* Stability Problem::           
* Stability Solution::          
* Example of Stability Problem::  
* Stability Implications::      
@end menu
X
@node Stability Problem, Stability Solution, Maintaining Baseline Stability, Maintaining Baseline Stability
SHAR_EOF
true || echo 'restore of bcs-2.0/doc/bcs.texinfo failed'
fi
echo 'End of bcs-2.0 part 10'
echo 'File bcs-2.0/doc/bcs.texinfo is continued in part 11'
echo 11 > _shar_seq_.tmp
exit 0
