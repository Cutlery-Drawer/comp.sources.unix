Newsgroups: comp.sources.unix
From: gwr@mc.com (Gordon W. Ross)
Subject: v28i116: bootp-2.4.0 - RFC 1048,1533 "bootp" server (updates V27I63), Part02/04
References: <1.777611200.751@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: gwr@mc.com (Gordon W. Ross)
Posting-Number: Volume 28, Issue 116
Archive-Name: bootp-2.4.0/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 4)."
# Contents:  Changes bootpd.8 bootptab.5 bootptest.c dovend.c dumptab.c
#   getether.c hash.c
# Wrapped by vixie@gw.home.vix.com on Mon Aug 22 20:04:22 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Changes' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Changes'\"
else
echo shar: Extracting \"'Changes'\" \(8535 characters\)
sed "s/^X//" >'Changes' <<'END_OF_FILE'
XChanges, most recent first
XDate, <email> Real Name
X	what...
X
X--> bootp-2.4.0
X
X08/20/94  gwr@mc.com (Gordon W. Ross)
X	Fix code to build bootfile name based on combination of
X	client requested name and bootfile specifications.
X	Behave similarly with or without CHECK_FILE_ACCESS.
X
X07/30/94  Dirk Koeppen <dirk@incom.de>
X	Add "min wait" option (mw) to cause bootpd to ignore
X	requests from clients that have not waited long enough.
X	Add code to honor client requests containing the DHCP
X	option "Maximum Message Size" and use its value to
X	determine the size of the reply message.
X
X--> bootp-2.3.8
X
X06/25/94  Christos Zoulas <christos@deshaw.com>
X	Add "-h" flag to override host name (affects default IP
X	address provided in reply messages.  (Also minor bug fix)
X
X05/27/94  gwr@mc.com (Gordon W. Ross)
X	Add code to call "arp -s IPADDR HWADDR" on systems
X	that do not provide an SIOCSARP ioctl (i.e. NetBSD)
X
X--> bootp-2.3.7
X
X05/05/94  Walter Wong <wcw+@CMU.EDU>
X	Reduce noize at debug level one, where log messages
X	are generated only for hosts that are recognized
X	and replied to by bootpd.  (At request of HP folks.)
X
X04/30/94  gwr@mc.com (Gordon W. Ross)
X	Use memxxx functions unless USE_BFUNCS is defined.
X	Added -f <file> option to bootptest (requested file).
X
X04/29/94  tpaquett@ita.lgc.com (Trevor Paquette)
X	Remove call to haddr_conv802() in sendreply().
X	The setarp should get the non-transformed address.
X
X04/27/94  gwr@mc.com
X	Improve logic for building bootfile pathname, so a path
X	will be put in the reply if either the client or bootpd
X	specifies a boot file.  (Needed for NetBSD diskless boot)
X
X04/25/94  shamash@boxhill.com (Ari Shamash)
X	Fix prs_inetaddr() so it allows '_' in hostnames.
X
X04/16/94  gwr@mc.com (Gordon W. Ross)
X	Fix setarp for SVR4 (needs to use I_STR ioctl)
X	Thanks to several people: (all sent the same fix)
X		Barney Wolff <barney@databus.com>,
X		bear@upsys.se (Bj|rn Sj|holm),
X		Michael Kuschke <Michael.Kuschke@Materna.DE>,
X
X03/25/95  Ulrich Heuer </I=zhhi9/G=Ulrich/S=Heuer/@zhflur.ubs.ubs.ch>
X	Make option string lengths not include a null terminator.
X	The trailing null breaks some clients.
X
X03/15/94  "Edmund J. Sutcliffe" <ejs1@tower.york.ac.uk>
X	Add support for the "EX" option:  Execute a program
X	before sending a BOOTREPLY to a client.  Support for
X	this option is conditional on YORK_EX_OPTION.
X
X03/10/94  Nigel Metheringham <nigelm@ohm.york.ac.uk>
X	Make getether.c work on Linux.
X
X03/09/94  Koch@Math.Uni-Duisburg.DE (Peter Koch)
X	Add missing MANDIR definition to Makefile.
X
X03/08/94  Jeroen.Scheerder@let.ruu.nl
X	Fix args to report in getether code for Ultrix.
X	Run install individually for each program.
X
X--> bootp-2.3.6
X03/07/94  gwr@mc.com
X	Cleanup for release (run gnu indent, tab-size=4)
X
X02/24/94  Jeroen.Scheerder@let.ruu.nl
X	Allow underscore in host names - readfile.c:goodname()
X	Add ConvOldTab.sh - converts 1.1 bootptab to new format.
X
X02/20/94  gwr@mc.com (Gordon W. Ross)
X	Make readfile tolerant of hardware addresses that start
X	with a letter.  (If lookup_hwa() fails, assume numeric.)
X	Fix whitespace skip before :vm= auto: and avoid lookup.
X
X02/12/94  walker@zk3.dec.com (Mary Walker)
X	Added support for 64-bit longs (for the DEC Alpha)
X	Allow ieee802 hardware address in bit-reversed oreder
X
X02/07/94  hl@tekla.fi (Harald Lundberg)
X	Fix conflict with DUMP_FILE in syslog.h on OSF1
X	Use int for (struct bootp).bp_xid (for DEC Alpha)
X	Added Ultrix support to bootptest (getether)
X
X02/06/94  brezak@ch.hp.com (John Brezak)
X	Add man-page and install targets to Makefile.NetBSD
X	Add getether support for NetBSD
X
X02/05/94  gwr@mc.com (Gordon W. Ross)
X	Added tags 40,41,42 (NIS domain, NIS server, NTP server)
X	Add stub to getether for machines not yet supported.
X
X--> bootp-2.3.5
X01/29/94  gwr@mc.com (Gordon W. Ross)
X	Make bootpgw put a correct address in "giaddr" when
X		the client request came via broadcast.
X
X01/22/94  gwr@mc.com (Gordon W. Ross)
X	Fix syslog call (missing "facility" code)
X	Add SVR4/Streams support to getif() and getether()
X	Fix getif bug (matched when it should not)
X	Macro-ize lots of similar cases in readfile.c
X
X12/27/93  brezak@ch.hp.com (John Brezak)
X	Remove all newlines passed to syslog(3)
X	Add /etc/ethers support for NetBSD.
X
X12/18/93  gwr@mc.com (Gordon W. Ross)
X	Fix bootptest IP address printing.
X	Fix byte-order bugs in bootpgw and bootptest.
X	Clean-up signed/unsigned mismatches.
X	Back out SLIP support changes for now
X		(code fragment saved in ToDo).
X
X--> bootp-2.3.4 (beta test release)
X12/12/93  gwr@mc.com (Gordon W. Ross)
X	Fixed several more NULL references in readfile.
X	Added proper length checks to option insertions.
X
X--> bootp-2.3.3 (beta test release)
X12/09/93  gwr@mc.com (Gordon W. Ross)
X	Added ASSERT checks to readfile.c:fill_defaults()
X
X12/08/93  brezak@ch.hp.com (John Brezak)
X	New Makefile.NetBSD
X	Added setsid() and #ifdef TIOCNOTTY
X		(bootpd.c, bootpgw.c)
X	Moved #include <net/if.h> out of #ifdef SUNOS
X	Fixed several multiple declaration problems
X
X12/04/93  gwr@mc.com (Gordon W. Ross)
X	Re-implemented Extension File support
X	  based on work by Jason Zions <jazz@hal.com>
X	Added support for Reply-Address-Override to support
X	  HP clients (need reply sent to broadcast address)
X	  from David R. Linn <drl@vuse.vanderbilt.edu>
X
X--> bootp-2.3.2 (beta test release)
X11/27/93  gwr@mc.com (Gordon W. Ross)
X	Incorporated bootptest into the bootp release.
X	Added ANSI function prototypes everywhere.
X
X11/17/93  dpm@depend.com (David P. Maynard)
X	Added automatic SLIP address determination.
X	(This is NOT dynamic IP address assignment.)
X	Cleaned up some type warnings from gcc.
X
X11/11/93  gwr@mc.com (Gordon W. Ross)
X	Works (again) with no -DSYSLOGD defined.
X	Provide a default value for the subnet mask.
X	More #ifdef's for SunOS specific code (lookup_hwa)
X	Added a simple BOOTP gateway program: bootpgw
X	Reorganized for more code sharing (with bootpgw)
X
X--> bootp-2.3.1 (alpha test release)
X11/08/93  gwr@mc.com (Gordon W. Ross)
X	Back-out changes to honor option structure in request
X		(this needs to be a per-client option).
X	Merged changes from NetBSD and Columbia versions.
X	Allow host name anywhere IP address is expected.
X	Add null terminators to option strings.
X	Add missing symbols to dump routine, dump symbols
X		in alphabetical order, one tag per line.
X
X--> bootp-2.2.D (posted as patch 2)
X10/19/93  gwr@mc.com (Gordon W. Ross)
X	Fix references to free memory (leads to core dumps).
X
X--> bootp-2.2.C (posted as patch 1)
X10/14/93  gwr@mc.com (Gordon W. Ross)
X	Fix data access alignment problems on SPARC/Solaris.
X
X--> bootp-2.2.B (posted to usenet)
X10/11/93  gwr@mc.com (Gordon W. Ross)
X	Allow extended-length BOOTP packets (more vendor options)
X	Honor option format specified in client requests.
X	Added Solaris-2.X changes from db@sunbim.be (Danny Backx).
X
XAll history before this point may be inaccurate.  Please send
Xchanges if any of the credits are incorrect. -gwr
X
X--> bootp-2.2+NetBSD released
X08/27/93  brezak@ch.hp.com (John Brezak)
X	Added RFC 1396 support (tags 14-17)
X
X--> bootp-2.2+NetBSD (version?)
X??/??/93  mckim@lerc.nasa.gov (Jim McKim)
X	Ported to NetBSD (see Makefile.NetBSD)
X	Set server host name in responses.
X	Check all interfaces in address match routine.
X
X--> bootp-2.2+FdC released
X01/27/93  <fdc@watsun.cc.columbia.edu> Frank da Cruz
X	Added RFC 1395 information: Merit dump file, 
X	client domain name, swap server address, root path.
X
X--> bootp-2.2alpha released
X11/14/91 <walt+@cmu.edu> Walter L. Wimer
X	Add "td" to TFTP directory for "secure" (chroot) TFTP.
X	Add "sa" tag to set explicit server address.
X	Automatically determine if child of inetd.
X	Use RFC 1048 format when request has magic number zero.
X	Fixed various bugs.  Give bootptab a separate man page.
X
X--> bootp-2.1 released
X01/09/89  <walt+@cmu.edu> Walter L. Wimer
X	Check world read bit on TFTP boot file.
X	Add support for rfc1085 "bootfile size" tag.
X	Add generic tags.  Fix byte order of rfc1048 data.
X	Fix various crashing bugs.
X
X--> bootp-2.0 released
X07/15/88  <walt+@cmu.edu> Walter L. Wimer
X	Added vendor information to conform to RFC1048.
X	Adopted termcap-like file format to support above.
X	Added hash table lookup instead of linear search.
X	Other cleanups.
X
X--> bootp-1.3(?) released
X07/24/87  <ddp@andrew.cmu.edu> Drew D. Perkins
X	Modified to use syslog instead of Kovar's
X	routines.  Add debugging dumps.  Many other fixups.
X
X--> bootp-1.2(?) released
X07/30/86  David Kovar at Carnegie Mellon University
X	Modified to work at CMU.
X
X--> bootp-1.1 released
X01/22/86  Bill Croft at Stanford University
X	Original created.
END_OF_FILE
if test 8535 -ne `wc -c <'Changes'`; then
    echo shar: \"'Changes'\" unpacked with wrong size!
fi
# end of 'Changes'
fi
if test -f 'bootpd.8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bootpd.8'\"
else
echo shar: Extracting \"'bootpd.8'\" \(7425 characters\)
sed "s/^X//" >'bootpd.8' <<'END_OF_FILE'
X.\" Copyright (c) 1988, 1989, 1991 Carnegie Mellon University
X.\"
X.\"	$Header: $
X.\"
X.TH BOOTPD 8 "November 06, 1993" "Carnegie Mellon University"
X.SH NAME
Xbootpd, bootpgw \- Internet Boot Protocol server/gateway
X.SH SYNOPSIS
X.B bootpd
X[
X.B \-i
X.B \-s
X.B \-t
Xtimeout
X.B \-d
Xlevel
X.B \-c
Xchdir\-path
X]
X[
X.I bootptab
X[
X.I dumpfile
X] ]
X.br
X.B bootpgw
X[
X.B \-i
X.B \-s
X.B \-t
Xtimeout
X.B \-d
Xlevel
X] server
X.SH DESCRIPTION
X.I Bootpd
Ximplements an Internet Bootstrap Protocol (BOOTP) server as defined in
XRFC951, RFC1532, and RFC1533.
X.I Bootpgw
Ximplements a simple BOOTP gateway which can be used to forward
Xrequests and responses between clients on one subnet and a
XBOOTP server (i.e.
X.IR bootpd )
Xon another subnet. While either
X.I bootpd
Xor
X.I bootpgw
Xwill forward BOOTREPLY packets, only
X.I bootpgw
Xwill forward BOOTREQUEST packets.
X.PP
XOne host on each network segment is normally configured to run either
X.I bootpd
Xor
X.I bootpgw
Xfrom
X.I inetd
Xby including one of the following lines in the file
X.IR /etc/inetd.conf :
X.IP
Xbootps dgram udp wait root /etc/bootpd bootpd bootptab
X.br
Xbootps dgram udp wait root /etc/bootpgw bootpgw server
X.PP
XThis mode of operation is referred to as "inetd mode" and causes
X.I bootpd
X(or
X.IR bootpgw )
Xto be started only when a boot request arrives.  If it does not
Xreceive another packet within fifteen minutes of the last one
Xit received, it will exit to conserve system resources.  The
X.B \-t
Xoption controls this timeout (see OPTIONS).
X.PP
XIt is also possible to run
X.I bootpd
X(or
X.IR bootpgw )
Xin "standalone mode" (without
X.IR inetd )
Xby simply invoking it from a shell like any other regular command.
XStandalone mode is particularly useful when
X.I bootpd
Xis used with a large configuration database, where the start up
Xdelay might otherwise prevent timely response to client requests.
X(Automatic start up in standalone mode can be done by invoking
X.I bootpd
Xfrom within
X.IR /etc/rc.local ,
Xfor example.)
XStandalone mode is less useful for
X.I bootgw
Xwhich
Xhas very little start up delay because
Xit does not read a configuration file.
X.PP
XEither program automatically detects whether it was invoked from inetd
Xor from a shell and automatically selects the appropriate mode.
XThe 
X.B \-s
Xor
X.B \-i
Xoption may be used to force standalone or inetd mode respectively
X(see OPTIONS).
X.SH OPTIONS
X.TP
X.BI \-t \ timeout
XSpecifies the
X.I timeout
Xvalue (in minutes) that a
X.I bootpd
Xor
X.I bootpgw
Xprocess will wait for a BOOTP packet before exiting.
XIf no packets are recieved for
X.I timeout
Xseconds, then the program will exit.
XA timeout value of zero means "run forever".
XIn standalone mode, this option is forced to zero.
X.TP
X.BI \-d \ debug\-level
XSets the
X.I debug\-level
Xvariable that controls the amount of debugging messages generated.
XFor example, -d4 or -d 4 will set the debugging level to 4.
XFor compatibility with older versions of
X.IR bootpd ,
Xomitting the numeric parameter (i.e. just -d) will
Xsimply increment the debug level by one.
X.TP
X.BI \-c \ chdir\-path
XSets the current directory used by
X.I bootpd
Xwhile checking the existence and size of client boot files.  This is
Xuseful when client boot files are specified as relative pathnames, and
X.I bootpd
Xneeds to use the same current directory as the TFTP server
X(typically /tftpboot).  This option is not recoginzed by
X.IR bootpgw .
X.TP
X.B \-i
XForce inetd mode.  This option is obsolete, but remains for
Xcompatibility with older versions of
X.IR bootpd .
X.TP
X.B \-s
XForce standalone mode.  This option is obsolete, but remains for
Xcompatibility with older versions of
X.IR bootpd .
X.TP
X.I bootptab
XSpecifies the name of the configuration file from which
X.I bootpd
Xloads its database of known clients and client options
X.RI ( bootpd
Xonly).
X.TP
X.I dumpfile
XSpecifies the name of the file that
X.I bootpd
Xwill dump its internal database into when it receives a
XSIGUSR1 signal
X.RI ( bootpd
Xonly).  This option is only recognized if
X.I bootpd
Xwas compiled with the -DDEBUG flag.
X.TP
X.I server
XSpecifies the name of a BOOTP server to which
X.I bootpgw
Xwill forward all BOOTREQUEST packets it receives
X.RI ( bootpgw
Xonly).
X.SH OPERATION
X.PP
XBoth
X.I bootpd
Xand
X.I bootpgw
Xoperate similarly in that both listen for any packets sent to the
X.I bootps
Xport, and both simply forward any BOOTREPLY packets.
XThey differ in their handling of BOOTREQUEST packets.
X.PP
XWhen
X.I bootpgw
Xis started, it determines the address of a BOOTP server
Xwhose name is provided as a command line parameter.  When
X.I bootpgw
Xreceives a BOOTREQUEST packet, it sets the "gateway address"
Xand "hop count" fields in the packet and forwards the packet
Xto the BOOTP server at the address determined earlier.
XRequests are forwarded only if they indicate that
Xthe client has been waiting for at least three seconds.
X.PP
XWhen
X.I bootpd
Xis started it reads a configuration file, (normally
X.IR /etc/bootptab )
Xthat initializes the internal database of known clients and client
Xoptions.  This internal database is reloaded
Xfrom the configuration file when
X.I bootpd
Xreceives a hangup signal (SIGHUP) or when it discovers that the
Xconfiguration file has changed.
X.PP
XWhen
X.I bootpd
Xreceives a BOOTREQUEST packet, it
X.\" checks the modification time of the
X.\" configuration file and reloads the database if necessary.  Then it
Xlooks for a database entry matching the client request.
XIf the client is known,
X.I bootpd
Xcomposes a BOOTREPLY packet using the database entry found above,
Xand sends the reply to the client (possibly using a gateway).
XIf the client is unknown, the request is discarded
X(with a notice if debug > 0).
X.PP
XIf
X.I bootpd
Xis compiled with the -DDEBUG option, receipt of a SIGUSR1 signal causes
Xit to dump its internal database to the file
X.I /etc/bootpd.dump
Xor the dumpfile specified as a command line parameter.
X.PP
XDuring initialization, both programs
Xdetermine the UDP port numbers to be used by calling
X.I getservbyname
X(which nomally uses
X.IR /etc/services).
XTwo service names (and port numbers) are used:
X.IP
Xbootps \- BOOTP Server listening port
X.br
Xbootpc \- BOOTP Client destination port
X.LP
XIf the port numbers cannot
Xbe determined using
X.I getservbyname
Xthen the values default to boopts=67 and bootpc=68.
X.SH FILES
X.TP 20
X/etc/bootptab
XDatabase file read by
X.IR bootpd .
X.TP
X/etc/bootpd.dump
XDebugging dump file created by
X.IR bootpd .
X.TP
X/etc/services
XInternet service numbers.
X.TP
X/tftpboot
XCurrent directory typically used by the TFTP server and
X.IR bootpd .
X
X.SH BUGS
XIndividual host entries must not exceed 1024 characters.
X
X.SH CREDITS
X.PP
XThis distribution is currently maintained by
XWalter L. Wimer <walt+@cmu.edu>.
X.PP
XThe original BOOTP server was created by
XBill Croft at Stanford University in January 1986.
X.PP
XThe current version of
X.I bootpd
Xis primarily the work of David Kovar,
XDrew D. Perkins, and Walter L. Wimer,
Xat Carnegie Mellon University.
X.TP
XEnhancements and bug\-fixes have been contributed by:
X(in alphabetical order)
X.br
XDanny Backx <db@sunbim.be>
X.br
XJohn Brezak <brezak@ch.hp.com>
X.br
XFrank da Cruz <fdc@cc.columbia.edu>
X.br
XDavid R. Linn <drl@vuse.vanderbilt.edu>
X.br
XJim McKim <mckim@lerc.nasa.gov>
X.br
XGordon W. Ross <gwr@mc.com>
X.br
XJason Zions <jazz@hal.com>
X.SH "SEE ALSO"
X.LP
Xbootptab(5), inetd(8), tftpd(8)
X.LP
XDARPA Internet Request For Comments:
X.TP 10
XRFC951
XBootstrap Protocol
X.TP 10
XRFC1532
XClarifications and Extensions for the Bootstrap Protocol
X.TP 10
XRFC1533
XDHCP Options and BOOTP Vendor Extensions
END_OF_FILE
if test 7425 -ne `wc -c <'bootpd.8'`; then
    echo shar: \"'bootpd.8'\" unpacked with wrong size!
fi
# end of 'bootpd.8'
fi
if test -f 'bootptab.5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bootptab.5'\"
else
echo shar: Extracting \"'bootptab.5'\" \(10485 characters\)
sed "s/^X//" >'bootptab.5' <<'END_OF_FILE'
X.\" Copyright (c) 1988, 1989, 1991 Carnegie Mellon University
X.\"
X.\"	$Header: $
X.\"
X.TH BOOTPTAB 5 "October 31, 1991" "Carnegie Mellon University"
X.UC 6
X
X.SH NAME
Xbootptab \- Internet Bootstrap Protocol server database
X.SH DESCRIPTION
XThe
X.I bootptab
Xfile is the configuration database file for
X.IR bootpd ,
Xthe Internet Bootstrap Protocol server.
XIt's format is similar to that of
X.IR termcap (5)
Xin which two-character case-sensitive tag symbols are used to
Xrepresent host parameters.  These parameter declarations are separated by
Xcolons (:), with a general format of:
X.PP
X.I "	hostname:tg=value. . . :tg=value. . . :tg=value. . . ."
X.PP
Xwhere
X.I hostname
Xis the actual name of a bootp client (or a "dummy entry"), and
X.I tg
Xis a two-character tag symbol.  Dummy entries have an invalid hostname
X(one with a "." as the first character) and are used to provide
Xdefault values used by other entries via the
X.B tc=.dummy-entry
Xmechanism.  Most tags must be followed by an equals-sign
Xand a value as above.  Some may also appear in a boolean form with no
Xvalue (i.e.
X.RI : tg :).
XThe currently recognized tags are:
X.PP
X.br
X	bf	Bootfile
X.br
X	bs	Bootfile size in 512-octet blocks
X.br
X	cs	Cookie server address list
X.br
X	df	Merit dump file
X.br
X	dn	Domain name
X.br
X	ds	Domain name server address list
X.br
X	ef	Extension file
X.br
X	gw	Gateway address list
X.br
X	ha	Host hardware address
X.br
X	hd	Bootfile home directory
X.br
X	hn	Send client's hostname to client
X.br
X	ht	Host hardware type (see Assigned Numbers RFC)
X.br
X	im	Impress server address list
X.br
X	ip	Host IP address
X.br
X	lg	Log server address list
X.br
X	lp	LPR server address list
X.br
X	ns	IEN-116 name server address list
X.br
X	nt	NTP (time) Server (RFC 1129)
X.br
X	ra	Reply address override
X.br
X	rl	Resource location protocol server address list
X.br
X	rp	Root path to mount as root
X.br
X	sa	TFTP server address client should use
X.br
X	sm	Host subnet mask
X.br
X	sw	Swap server address
X.br
X	tc	Table continuation (points to similar "template" host entry)
X.br
X	td	TFTP root directory used by "secure" TFTP servers
X.br
X	to	Time offset in seconds from UTC
X.br
X	ts	Time server address list
X.br
X	vm	Vendor magic cookie selector
X.br
X	yd	YP (NIS) domain name
X.br
X	ys	YP (NIS) server address
X
X.PP
XThere is also a generic tag,
X.RI T n ,
Xwhere
X.I n
Xis an RFC1084 vendor field tag number.  Thus it is possible to immediately
Xtake advantage of future extensions to RFC1084 without being forced to modify
X.I bootpd
Xfirst.  Generic data may be represented as either a stream of hexadecimal
Xnumbers or as a quoted string of ASCII characters.  The length of the generic
Xdata is automatically determined and inserted into the proper field(s) of the
XRFC1084-style bootp reply.
X.PP
XThe following tags take a whitespace-separated list of IP addresses:
X.BR cs ,
X.BR ds ,
X.BR gw ,
X.BR im ,
X.BR lg ,
X.BR lp ,
X.BR ns ,
X.BR nt ,
X.BR ra ,
X.BR rl ,
Xand
X.BR ts .
XThe
X.BR ip ,
X.BR sa ,
X.BR sw ,
X.BR sm ,
Xand
X.B ys
Xtags each take a single IP address.
XAll IP addresses are specified in standard Internet "dot" notation
Xand may use decimal, octal, or hexadecimal numbers
X(octal numbers begin with 0, hexadecimal numbers begin with '0x' or '0X').
XAny IP addresses may alternatively be specified as a hostname, causing
X.I bootpd
Xto lookup the IP address for that host name using gethostbyname(3).
XIf the
X.B ip
Xtag is not specified,
X.I bootpd
Xwill determine the IP address using the entry name as the host name.
X(Dummy entries use an invalid host name to avoid automatic IP lookup.)
X.PP
XThe
X.B ht
Xtag specifies the hardware type code as either an unsigned decimal, octal, or
Xhexadecimal integer or one of the following symbolic names:
X.B ethernet
Xor
X.B ether
Xfor 10Mb Ethernet,
X.B ethernet3
Xor
X.B ether3
Xfor 3Mb experimental Ethernet,
X.BR ieee802 ,
X.BR tr ,
Xor
X.B token-ring
Xfor IEEE 802 networks,
X.B pronet
Xfor Proteon ProNET Token Ring, or
X.BR chaos ,
X.BR arcnet ,
Xor
X.B ax.25
Xfor Chaos, ARCNET, and AX.25 Amateur Radio networks, respectively.
XThe
X.B ha
Xtag takes a hardware address which may be specified as a host name
Xor in numeric form.  Note that the numeric form
X.I must
Xbe specified in hexadecimal; optional periods and/or a leading '0x' may be
Xincluded for readability.  The
X.B ha
Xtag must be preceded by the
X.B ht
Xtag (either explicitly or implicitly; see
X.B tc
Xbelow).
XIf the hardware address is not specified and the type is specified
Xas either "ethernet" or "ieee802", then
X.I bootpd
Xwill try to determine the hardware address using ether_hton(3).
X.PP
XThe hostname, home directory, and bootfile are ASCII strings which may be
Xoptionally surrounded by double quotes (").  The client's request and the
Xvalues of the
X.B hd
Xand
X.B bf
Xsymbols determine how the server fills in the bootfile field of the bootp
Xreply packet.
X.PP
XIf the client provides a file name it is left as is.
XOtherwise, if the
X.B bf
Xoption is specified its value is copied into the reply packet.
XIf the
X.B hd
Xoption is specified as well, its value is prepended to the
Xboot file copied into the reply packet.
XThe existence of the boot file is checked only if the
X.BR bs =auto
Xoption is used (to determine the boot file size).
XA reply may be sent whether or not the boot file exists.
X.PP
XSome newer versions of
X.I tftpd
Xprovide a security feature to change their root directory using
Xthe
X.IR chroot (2)
Xsystem call.
XThe
X.B td
Xtag may be used to inform
X.I bootpd
Xof this special root directory used by
X.IR tftpd .
X(One may alternatively use the
X.I bootpd
X"-c chdir" option.)
XThe
X.B hd
Xtag is actually relative to the root directory specified by the
X.B td
Xtag.
XFor example, if the real absolute path to your BOOTP client bootfile is
X/tftpboot/bootfiles/bootimage, and
X.IR tftpd
Xuses /tftpboot as its "secure" directory, then specify the following in
X.IR bootptab :
X.PP
X.br
X	:td=/tftpboot:hd=/bootfiles:bf=bootimage:
X.PP
XIf your bootfiles are located directly in /tftpboot, use:
X.PP
X.br
X	:td=/tftpboot:hd=/:bf=bootimage:
X.PP
XThe
X.B sa
Xtag may be used to specify the IP address of the particular TFTP server
Xyou wish the client to use.  In the absence of this tag,
X.I bootpd
Xwill tell the client to perform TFTP to the same machine
X.I bootpd
Xis running on.
X.PP
XThe time offset
X.B to
Xmay be either a signed decimal integer specifying the client's
Xtime zone offset in seconds from UTC, or the keyword
X.B auto
Xwhich uses the server's time zone offset.  Specifying the
X.B to
Xsymbol as a boolean has the same effect as specifying
X.B auto
Xas its value.
X.PP
XThe bootfile size
X.B bs
Xmay be either a decimal, octal, or hexadecimal integer specifying the size of
Xthe bootfile in 512-octet blocks, or the keyword
X.B auto
Xwhich causes the server to automatically calculate the bootfile size at each
Xrequest.  As with the time offset, specifying the
X.B bs
Xsymbol as a boolean has the same effect as specifying
X.B auto
Xas its value.
X.PP
XThe vendor magic cookie selector (the
X.B vm
Xtag) may take one of the following keywords:
X.B auto
X(indicating that vendor information is determined by the client's request),
X.B rfc1048
Xor
X.B rfc1084
X(which always forces an RFC1084-style reply), or
X.B cmu
X(which always forces a CMU-style reply).
X.PP
XThe
X.B hn
Xtag is strictly a boolean tag; it does not take the usual equals-sign and
Xvalue.  It's presence indicates that the hostname should be sent to RFC1084
Xclients.
X.I Bootpd
Xattempts to send the entire hostname as it is specified in the configuration
Xfile; if this will not fit into the reply packet, the name is shortened to
Xjust the host field (up to the first period, if present) and then tried.
XIn no case is an arbitrarily-truncated hostname sent (if nothing reasonable
Xwill fit, nothing is sent).
X.PP
XOften, many host entries share common values for certain tags (such as name
Xservers, etc.).  Rather than repeatedly specifying these tags, a full
Xspecification can be listed for one host entry and shared by others via the
X.B tc
X(table continuation) mechanism.
XOften, the template entry is a dummy host which doesn't actually exist and
Xnever sends bootp requests.  This feature is similar to the
X.B tc
Xfeature of
X.IR termcap (5)
Xfor similar terminals.  Note that
X.I bootpd
Xallows the
X.B tc
Xtag symbol to appear anywhere in the host entry, unlike
X.I termcap
Xwhich requires it to be the last tag.  Information explicitly specified for a
Xhost always overrides information implied by a
X.B tc
Xtag symbol, regardless of its location within the entry.  The
Xvalue of the
X.B tc
Xtag may be the hostname or IP address of any host entry
Xpreviously listed in the configuration file.
X.PP
XSometimes it is necessary to delete a specific tag after it has been inferred
Xvia
X.BR tc .
XThis can be done using the construction
X.IB tag @
Xwhich removes the effect of
X.I tag
Xas in
X.IR termcap (5).
XFor example, to completely undo an IEN-116 name server specification, use
X":ns@:" at an appropriate place in the configuration entry.  After removal
Xwith
X.BR @ ,
Xa tag is eligible to be set again through the
X.B tc
Xmechanism.
X.PP
XBlank lines and lines beginning with "#" are ignored in the configuration
Xfile.  Host entries are separated from one another by newlines; a single host
Xentry may be extended over multiple lines if the lines end with a backslash
X(\\).  It is also acceptable for lines to be longer than 80 characters.  Tags
Xmay appear in any order, with the following exceptions:  the hostname must be
Xthe very first field in an entry, and the hardware type must precede the
Xhardware address.
X.PP
XAn example
X.I /etc/bootptab
Xfile follows:
X.PP
X.nf
X	# Sample bootptab file (domain=andrew.cmu.edu)
X
X	.default:\\
X		:hd=/usr/boot:bf=null:\\
X		:ds=netserver, lancaster:\\
X		:ns=pcs2, pcs1:\\
X		:ts=pcs2, pcs1:\\
X		:sm=255.255.255.0:\\
X		:gw=gw.cs.cmu.edu:\\
X		:hn:to=-18000:
X
X	carnegie:ht=6:ha=7FF8100000AF:tc=.default:
X	baldwin:ht=1:ha=0800200159C3:tc=.default:
X	wylie:ht=1:ha=00DD00CADF00:tc=.default:
X	arnold:ht=1:ha=0800200102AD:tc=.default:
X	bairdford:ht=1:ha=08002B02A2F9:tc=.default:
X	bakerstown:ht=1:ha=08002B0287C8:tc=.default:
X
X	# Special domain name server and option tags for next host
X	butlerjct:ha=08002001560D:ds=128.2.13.42:\\
X		:T37=0x12345927AD3BCF:\\
X		:T99="Special ASCII string":\\
X		:tc=.default:
X
X	gastonville:ht=6:ha=7FFF81000A47:tc=.default:
X	hahntown:ht=6:ha=7FFF81000434:tc=.default:
X	hickman:ht=6:ha=7FFF810001BA:tc=.default:
X	lowber:ht=1:ha=00DD00CAF000:tc=.default:
X	mtoliver:ht=1:ha=00DD00FE1600:tc=.default:
X
X.fi
X.SH FILES
X/etc/bootptab
X
X.SH "SEE ALSO"
X.br
Xbootpd(8), tftpd(8),
X.br
XDARPA Internet Request For Comments RFC951, RFC1048, RFC1084, Assigned Numbers
END_OF_FILE
if test 10485 -ne `wc -c <'bootptab.5'`; then
    echo shar: \"'bootptab.5'\" unpacked with wrong size!
fi
# end of 'bootptab.5'
fi
if test -f 'bootptest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bootptest.c'\"
else
echo shar: Extracting \"'bootptest.c'\" \(11001 characters\)
sed "s/^X//" >'bootptest.c' <<'END_OF_FILE'
X/*
X * bootptest.c - Test out a bootp server.
X *
X * This simple program was put together from pieces taken from
X * various places, including the CMU BOOTP client and server.
X * The packet printing routine is from the Berkeley "tcpdump"
X * program with some enhancements I added.  The print-bootp.c
X * file was shared with my copy of "tcpdump" and therefore uses
X * some unusual utility routines that would normally be provided
X * by various parts of the tcpdump program.  Gordon W. Ross
X *
X * Boilerplate:
X *
X * This program includes software developed by the University of
X * California, Lawrence Berkeley Laboratory and its contributors.
X * (See the copyright notice in print-bootp.c)
X *
X * The remainder of this program is public domain.  You may do
X * whatever you like with it except claim that you wrote it.
X *
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
X * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
X * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X *
X * HISTORY:
X *
X * 12/02/93 Released version 1.4 (with bootp-2.3.2)
X * 11/05/93 Released version 1.3
X * 10/14/93 Released version 1.2
X * 10/11/93 Released version 1.1
X * 09/28/93 Released version 1.0
X * 09/93 Original developed by Gordon W. Ross <gwr@mc.com>
X */
X
Xchar *usage = "bootptest [-h] server-name [vendor-data-template-file]";
X
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/ioctl.h>
X#include <sys/file.h>
X#include <sys/time.h>
X#include <sys/stat.h>
X
X#include <net/if.h>
X#include <netinet/in.h>
X#include <arpa/inet.h>			/* inet_ntoa */
X
X#include <stdlib.h>
X#include <signal.h>
X#include <stdio.h>
X#include <string.h>
X#include <errno.h>
X#include <ctype.h>
X#include <netdb.h>
X#include <assert.h>
X
X#include "bootp.h"
X#include "bootptest.h"
X#include "getif.h"
X#include "patchlevel.h"
X
X#define LOG_ERR 1
X#define BUFLEN 1024
X#define WAITSECS 1
X#define MAXWAIT  10
X
Xint vflag = 1;
Xint tflag = 0;
Xint thiszone;
Xchar *progname;
Xunsigned char *packetp;
Xunsigned char *snapend;
Xint snaplen;
X
X
X/*
X * IP port numbers for client and server obtained from /etc/services
X */
X
Xu_short bootps_port, bootpc_port;
X
X
X/*
X * Internet socket and interface config structures
X */
X
Xstruct sockaddr_in sin_server;	/* where to send requests */
Xstruct sockaddr_in sin_client;	/* for bind and listen */
Xstruct sockaddr_in sin_from;	/* Packet source */
Xu_char eaddr[16];				/* Ethernet address */
X
X/*
X * General
X */
X
Xint debug = 1;					/* Debugging flag (level) */
Xchar hostname[64];
Xchar *sndbuf;					/* Send packet buffer */
Xchar *rcvbuf;					/* Receive packet buffer */
X
X/*
X * Vendor magic cookies for CMU and RFC1048
X */
X
Xunsigned char vm_cmu[4] = VM_CMU;
Xunsigned char vm_rfc1048[4] = VM_RFC1048;
Xshort secs;						/* How long client has waited */
X
Xchar *get_errmsg();
Xextern void bootp_print();
X
X/*
X * Initialization such as command-line processing is done, then
X * the receiver loop is started.  Die when interrupted.
X */
X
Xmain(argc, argv)
X	int argc;
X	char **argv;
X{
X	struct bootp *bp;
X	struct servent *sep;
X	struct hostent *hep;
X
X	char *servername = NULL;
X	char *vendor_file = NULL;
X	char *bp_file = NULL;
X	int32 server_addr;			/* inet addr, network order */
X	int s;						/* Socket file descriptor */
X	int n, tolen, fromlen, recvcnt;
X	int use_hwa = 0;
X	int32 vend_magic;
X	int32 xid;
X
X	progname = strrchr(argv[0], '/');
X	if (progname)
X		progname++;
X	else
X		progname = argv[0];
X	argc--;
X	argv++;
X
X	if (debug)
X		printf("%s: version %s.%d\n", progname, VERSION, PATCHLEVEL);
X
X	/*
X	 * Verify that "struct bootp" has the correct official size.
X	 * (Catch evil compilers that do struct padding.)
X	 */
X	assert(sizeof(struct bootp) == BP_MINPKTSZ);
X
X	sndbuf = malloc(BUFLEN);
X	rcvbuf = malloc(BUFLEN);
X	if (!sndbuf || !rcvbuf) {
X		printf("malloc failed\n");
X		exit(1);
X	}
X
X	/* default magic number */
X	bcopy(vm_rfc1048, (char*)&vend_magic, 4);
X
X	/* Handle option switches. */
X	while (argc > 0) {
X		if (argv[0][0] != '-')
X			break;
X		switch (argv[0][1]) {
X
X		case 'f':				/* File name to reqest. */
X			if (argc < 2)
X				goto error;
X			argc--; argv++;
X			bp_file = *argv;
X			break;
X
X		case 'h':				/* Use hardware address. */
X			use_hwa = 1;
X			break;
X
X		case 'm':				/* Magic number value. */
X			if (argc < 2)
X				goto error;
X			argc--; argv++;
X			vend_magic = inet_addr(*argv);
X			break;
X
X		error:
X		default:
X			puts(usage);
X			exit(1);
X
X		}
X		argc--;
X		argv++;
X	}
X
X	/* Get server name (or address) for query. */
X	if (argc > 0) {
X		servername = *argv;
X		argc--;
X		argv++;
X	}
X	/* Get optional vendor-data-template-file. */
X	if (argc > 0) {
X		vendor_file = *argv;
X		argc--;
X		argv++;
X	}
X	if (!servername) {
X		printf("missing server name.\n");
X		puts(usage);
X		exit(1);
X	}
X	/*
X	 * Create a socket.
X	 */
X	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
X		perror("socket");
X		exit(1);
X	}
X	/*
X	 * Get server's listening port number
X	 */
X	sep = getservbyname("bootps", "udp");
X	if (sep) {
X		bootps_port = ntohs((u_short) sep->s_port);
X	} else {
X		fprintf(stderr, "udp/bootps: unknown service -- using port %d\n",
X				IPPORT_BOOTPS);
X		bootps_port = (u_short) IPPORT_BOOTPS;
X	}
X
X	/*
X	 * Set up server socket address (for send)
X	 */
X	if (servername) {
X		if (isdigit(servername[0]))
X			server_addr = inet_addr(servername);
X		else {
X			hep = gethostbyname(servername);
X			if (!hep) {
X				fprintf(stderr, "%s: unknown host\n", servername);
X				exit(1);
X			}
X			bcopy(hep->h_addr, &server_addr, sizeof(server_addr));
X		}
X	} else {
X		/* Get broadcast address */
X		/* XXX - not yet */
X		server_addr = INADDR_ANY;
X	}
X	sin_server.sin_family = AF_INET;
X	sin_server.sin_port = htons(bootps_port);
X	sin_server.sin_addr.s_addr = server_addr;
X
X	/*
X	 * Get client's listening port number
X	 */
X	sep = getservbyname("bootpc", "udp");
X	if (sep) {
X		bootpc_port = ntohs(sep->s_port);
X	} else {
X		fprintf(stderr, "udp/bootpc: unknown service -- using port %d\n",
X				IPPORT_BOOTPC);
X		bootpc_port = (u_short) IPPORT_BOOTPC;
X	}
X
X	/*
X	 * Set up client socket address (for listen)
X	 */
X	sin_client.sin_family = AF_INET;
X	sin_client.sin_port = htons(bootpc_port);
X	sin_client.sin_addr.s_addr = INADDR_ANY;
X
X	/*
X	 * Bind client socket to BOOTPC port.
X	 */
X	if (bind(s, (struct sockaddr *) &sin_client, sizeof(sin_client)) < 0) {
X		perror("bind BOOTPC port");
X		if (errno == EACCES)
X			fprintf(stderr, "You need to run this as root\n");
X		exit(1);
X	}
X	/*
X	 * Build a request.
X	 */
X	bp = (struct bootp *) sndbuf;
X	bzero(bp, sizeof(*bp));
X	bp->bp_op = BOOTREQUEST;
X	xid = (int32) getpid();
X	bp->bp_xid = (u_int32) htonl(xid);
X	if (bp_file)
X		strncpy(bp->bp_file, bp_file, BP_FILE_LEN);
X
X	/*
X	 * Fill in the hardware address (or client IP address)
X	 */
X	if (use_hwa) {
X		struct ifreq *ifr;
X
X		ifr = getif(s, &sin_server.sin_addr);
X		if (!ifr) {
X			printf("No interface for %s\n", servername);
X			exit(1);
X		}
X		if (getether(ifr->ifr_name, eaddr)) {
X			printf("Can not get ether addr for %s\n", ifr->ifr_name);
X			exit(1);
X		}
X		/* Copy Ethernet address into request packet. */
X		bp->bp_htype = 1;
X		bp->bp_hlen = 6;
X		bcopy(eaddr, bp->bp_chaddr, bp->bp_hlen);
X	} else {
X		/* Fill in the client IP address. */
X		gethostname(hostname, sizeof(hostname));
X		hep = gethostbyname(hostname);
X		if (!hep) {
X			printf("Can not get my IP address\n");
X			exit(1);
X		}
X		bcopy(hep->h_addr, &bp->bp_ciaddr, hep->h_length);
X	}
X
X	/*
X	 * Copy in the default vendor data.
X	 */
X	bcopy((char*)&vend_magic, bp->bp_vend, 4);
X	if (vend_magic)
X		bp->bp_vend[4] = TAG_END;
X
X	/*
X	 * Read in the "options" part of the request.
X	 * This also determines the size of the packet.
X	 */
X	snaplen = sizeof(*bp);
X	if (vendor_file) {
X		int fd = open(vendor_file, 0);
X		if (fd < 0) {
X			perror(vendor_file);
X			exit(1);
X		}
X		/* Compute actual space for options. */
X		n = BUFLEN - sizeof(*bp) + BP_VEND_LEN;
X		n = read(fd, bp->bp_vend, n);
X		close(fd);
X		if (n < 0) {
X			perror(vendor_file);
X			exit(1);
X		}
X		printf("read %d bytes of vendor template\n", n);
X		if (n > BP_VEND_LEN) {
X			printf("warning: extended options in use (len > %d)\n",
X				   BP_VEND_LEN);
X			snaplen += (n - BP_VEND_LEN);
X		}
X	}
X	/*
X	 * Set globals needed by print_bootp
X	 * (called by send_request)
X	 */
X	packetp = (unsigned char *) eaddr;
X	snapend = (unsigned char *) sndbuf + snaplen;
X
X	/* Send a request once per second while waiting for replies. */
X	recvcnt = 0;
X	bp->bp_secs = secs = 0;
X	send_request(s);
X	while (1) {
X		struct timeval tv;
X		int readfds;
X
X		tv.tv_sec = WAITSECS;
X		tv.tv_usec = 0L;
X		readfds = (1 << s);
X		n = select(s + 1, (fd_set *) & readfds, NULL, NULL, &tv);
X		if (n < 0) {
X			perror("select");
X			break;
X		}
X		if (n == 0) {
X			/*
X			 * We have not received a response in the last second.
X			 * If we have ever received any responses, exit now.
X			 * Otherwise, bump the "wait time" field and re-send.
X			 */
X			if (recvcnt > 0)
X				exit(0);
X			secs += WAITSECS;
X			if (secs > MAXWAIT)
X				break;
X			bp->bp_secs = htons(secs);
X			send_request(s);
X			continue;
X		}
X		fromlen = sizeof(sin_from);
X		n = recvfrom(s, rcvbuf, BUFLEN, 0,
X					 (struct sockaddr *) &sin_from, &fromlen);
X		if (n <= 0) {
X			continue;
X		}
X		if (n < sizeof(struct bootp)) {
X			printf("received short packet\n");
X			continue;
X		}
X		recvcnt++;
X
X		/* Print the received packet. */
X		printf("Recvd from %s", inet_ntoa(sin_from.sin_addr));
X		/* set globals needed by bootp_print() */
X		snaplen = n;
X		snapend = (unsigned char *) rcvbuf + snaplen;
X		bootp_print(rcvbuf, n, sin_from.sin_port, 0);
X		putchar('\n');
X		/*
X		 * This no longer exits immediately after receiving
X		 * one response because it is useful to know if the
X		 * client might get multiple responses.  This code
X		 * will now listen for one second after a response.
X		 */
X	}
X	fprintf(stderr, "no response from %s\n", servername);
X	exit(1);
X}
X
Xsend_request(s)
X	int s;
X{
X	/* Print the request packet. */
X	printf("Sending to %s", inet_ntoa(sin_server.sin_addr));
X	bootp_print(sndbuf, snaplen, sin_from.sin_port, 0);
X	putchar('\n');
X
X	/* Send the request packet. */
X	if (sendto(s, sndbuf, snaplen, 0,
X			   (struct sockaddr *) &sin_server,
X			   sizeof(sin_server)) < 0)
X	{
X		perror("sendto server");
X		exit(1);
X	}
X}
X
X/*
X * Print out a filename (or other ascii string).
X * Return true if truncated.
X */
Xint
Xprintfn(s, ep)
X	register u_char *s, *ep;
X{
X	register u_char c;
X
X	putchar('"');
X	while (c = *s++) {
X		if (s > ep) {
X			putchar('"');
X			return (1);
X		}
X		if (!isascii(c)) {
X			c = toascii(c);
X			putchar('M');
X			putchar('-');
X		}
X		if (!isprint(c)) {
X			c ^= 0x40;			/* DEL to ?, others to alpha */
X			putchar('^');
X		}
X		putchar(c);
X	}
X	putchar('"');
X	return (0);
X}
X
X/*
X * Convert an IP addr to a string.
X * (like inet_ntoa, but ina is a pointer)
X */
Xchar *
Xipaddr_string(ina)
X	struct in_addr *ina;
X{
X	static char b[24];
X	u_char *p;
X
X	p = (u_char *) ina;
X	sprintf(b, "%d.%d.%d.%d", p[0], p[1], p[2], p[3]);
X	return (b);
X}
X
X/*
X * Local Variables:
X * tab-width: 4
X * c-indent-level: 4
X * c-argdecl-indent: 4
X * c-continued-statement-offset: 4
X * c-continued-brace-offset: -4
X * c-label-offset: -4
X * c-brace-offset: 0
X * End:
X */
END_OF_FILE
if test 11001 -ne `wc -c <'bootptest.c'`; then
    echo shar: \"'bootptest.c'\" unpacked with wrong size!
fi
# end of 'bootptest.c'
fi
if test -f 'dovend.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dovend.c'\"
else
echo shar: Extracting \"'dovend.c'\" \(10168 characters\)
sed "s/^X//" >'dovend.c' <<'END_OF_FILE'
X/*
X * dovend.c : Inserts all but the first few vendor options.
X */
X
X#include <sys/types.h>
X
X#include <netinet/in.h>
X#include <arpa/inet.h>			/* inet_ntoa */
X
X#include <stdlib.h>
X#include <stdio.h>
X#include <string.h>
X#include <errno.h>
X#include <syslog.h>
X
X#ifndef USE_BFUNCS
X# include <memory.h>
X/* Yes, memcpy is OK here (no overlapped copies). */
X# define bcopy(a,b,c)    memcpy(b,a,c)
X# define bzero(p,l)      memset(p,0,l)
X# define bcmp(a,b,c)     memcmp(a,b,c)
X# define index           strchr
X#endif
X
X#include "bootp.h"
X#include "bootpd.h"
X#include "report.h"
X#include "dovend.h"
X
X#ifdef	__STDC__
X#define P(args) args
X#else
X#define P(args) ()
X#endif
X
XPRIVATE int insert_generic P((struct shared_bindata *, byte **, int *));
X
X/*
X * Insert the 2nd part of the options into an option buffer.
X * Return amount of space used.
X *
X * This inserts everything EXCEPT:
X *   magic cookie, subnet mask, gateway, bootsize, extension file
X * Those are handled separately (in bootpd.c) to allow this function
X * to be shared between bootpd and bootpef.
X *
X * When an "extension file" is in use, the options inserted by
X * this function go into the exten_file, not the bootp response.
X */
X
Xint
Xdovend_rfc1497(hp, buf, len)
X	struct host *hp;
X	byte *buf;
X	int len;
X{
X	int bytesleft = len;
X	byte *vp = buf;
X	char *tmpstr;
X
X	static char noroom[] = "%s: No room for \"%s\" option";
X#define	NEED(LEN, MSG) do                       \
X		if (bytesleft < (LEN)) {         	    \
X			report(LOG_NOTICE, noroom,          \
X				   hp->hostname->string, MSG);  \
X			return (vp - buf);                  \
X		} while (0)
X
X	/*
X	 * Note that the following have already been inserted:
X	 *   magic_cookie, subnet_mask, gateway, bootsize
X	 *
X	 * The remaining options are inserted in order of importance.
X	 * (Of course the importance of each is a matter of opinion.)
X	 * The option insertion order should probably be configurable.
X	 *
X	 * This is the order used in the NetBSD version.  Can anyone
X	 * explain why the time_offset and swap_server are first?
X	 * Also, why is the hostname so far down the list?  -gwr
X	 */
X
X	if (hp->flags.time_offset) {
X		NEED(6, "to");
X		*vp++ = TAG_TIME_OFFSET;/* -1 byte  */
X		*vp++ = 4;				/* -1 byte  */
X		insert_u_long(htonl(hp->time_offset), &vp);	/* -4 bytes */
X		bytesleft -= 6;
X	}
X	/*
X	 * swap server, root path, dump path
X	 */
X	if (hp->flags.swap_server) {
X		NEED(6, "sw");
X		/* There is just one SWAP_SERVER, so it is not an iplist. */
X		*vp++ = TAG_SWAP_SERVER;/* -1 byte  */
X		*vp++ = 4;				/* -1 byte  */
X		insert_u_long(hp->swap_server.s_addr, &vp);	/* -4 bytes */
X		bytesleft -= 6;			/* Fix real count */
X	}
X	if (hp->flags.root_path) {
X		/*
X		 * Check for room for root_path.  Add 2 to account for
X		 * TAG_ROOT_PATH and length.
X		 */
X		len = strlen(hp->root_path->string);
X		NEED((len + 2), "rp");
X		*vp++ = TAG_ROOT_PATH;
X		*vp++ = (byte) (len & 0xFF);
X		bcopy(hp->root_path->string, vp, len);
X		vp += len;
X		bytesleft -= len + 2;
X	}
X	if (hp->flags.dump_file) {
X		/*
X		 * Check for room for dump_file.  Add 2 to account for
X		 * TAG_DUMP_FILE and length.
X		 */
X		len = strlen(hp->dump_file->string);
X		NEED((len + 2), "df");
X		*vp++ = TAG_DUMP_FILE;
X		*vp++ = (byte) (len & 0xFF);
X		bcopy(hp->dump_file->string, vp, len);
X		vp += len;
X		bytesleft -= len + 2;
X	}
X	/*
X	 * DNS server and domain
X	 */
X	if (hp->flags.domain_server) {
X		if (insert_ip(TAG_DOMAIN_SERVER,
X					  hp->domain_server,
X					  &vp, &bytesleft))
X			NEED(8, "ds");
X	}
X	if (hp->flags.domain_name) {
X		/*
X		 * Check for room for domain_name.  Add 2 to account for
X		 * TAG_DOMAIN_NAME and length.
X		 */
X		len = strlen(hp->domain_name->string);
X		NEED((len + 2), "dn");
X		*vp++ = TAG_DOMAIN_NAME;
X		*vp++ = (byte) (len & 0xFF);
X		bcopy(hp->domain_name->string, vp, len);
X		vp += len;
X		bytesleft -= len + 2;
X	}
X	/*
X	 * NIS (YP) server and domain
X	 */
X	if (hp->flags.nis_server) {
X		if (insert_ip(TAG_NIS_SERVER,
X					  hp->nis_server,
X					  &vp, &bytesleft))
X			NEED(8, "ds");
X	}
X	if (hp->flags.nis_domain) {
X		/*
X		 * Check for room for nis_domain.  Add 2 to account for
X		 * TAG_NIS_DOMAIN and length.
X		 */
X		len = strlen(hp->nis_domain->string);
X		NEED((len + 2), "dn");
X		*vp++ = TAG_NIS_DOMAIN;
X		*vp++ = (byte) (len & 0xFF);
X		bcopy(hp->nis_domain->string, vp, len);
X		vp += len;
X		bytesleft -= len + 2;
X	}
X	/* IEN 116 name server */
X	if (hp->flags.name_server) {
X		if (insert_ip(TAG_NAME_SERVER,
X					  hp->name_server,
X					  &vp, &bytesleft))
X			NEED(8, "ns");
X	}
X	if (hp->flags.rlp_server) {
X		if (insert_ip(TAG_RLP_SERVER,
X					  hp->rlp_server,
X					  &vp, &bytesleft))
X			NEED(8, "rl");
X	}
X	/* Time server (RFC 868) */
X	if (hp->flags.time_server) {
X		if (insert_ip(TAG_TIME_SERVER,
X					  hp->time_server,
X					  &vp, &bytesleft))
X			NEED(8, "ts");
X	}
X	/* NTP (time) Server (RFC 1129) */
X	if (hp->flags.ntp_server) {
X		if (insert_ip(TAG_NTP_SERVER,
X					  hp->ntp_server,
X					  &vp, &bytesleft))
X			NEED(8, "ts");
X	}
X	/*
X	 * I wonder:  If the hostname were "promoted" into the BOOTP
X	 * response part, might these "extension" files possibly be
X	 * shared between several clients?
X	 *
X	 * Also, why not just use longer BOOTP packets with all the
X	 * additional length used as option data.  This bootpd version
X	 * already supports that feature by replying with the same
X	 * packet length as the client request packet. -gwr
X	 */
X	if (hp->flags.name_switch && hp->flags.send_name) {
X		/*
X		 * Check for room for hostname.  Add 2 to account for
X		 * TAG_HOST_NAME and length.
X		 */
X		len = strlen(hp->hostname->string);
X#if 0
X		/*
X		 * XXX - Too much magic.  The user can always set the hostname
X		 * to the short version in the bootptab file. -gwr
X		 */
X		if ((len + 2) > bytesleft) {
X			/*
X			 * Not enough room for full (domain-qualified) hostname, try
X			 * stripping it down to just the first field (host).
X			 */
X			tmpstr = hp->hostname->string;
X			len = 0;
X			while (*tmpstr && (*tmpstr != '.')) {
X				tmpstr++;
X				len++;
X			}
X		}
X#endif
X		NEED((len + 2), "hn");
X		*vp++ = TAG_HOST_NAME;
X		*vp++ = (byte) (len & 0xFF);
X		bcopy(hp->hostname->string, vp, len);
X		vp += len;
X		bytesleft -= len + 2;
X	}
X	/*
X	 * The rest of these are less important, so they go last.
X	 */
X	if (hp->flags.lpr_server) {
X		if (insert_ip(TAG_LPR_SERVER,
X					  hp->lpr_server,
X					  &vp, &bytesleft))
X			NEED(8, "lp");
X	}
X	if (hp->flags.cookie_server) {
X		if (insert_ip(TAG_COOKIE_SERVER,
X					  hp->cookie_server,
X					  &vp, &bytesleft))
X			NEED(8, "cs");
X	}
X	if (hp->flags.log_server) {
X		if (insert_ip(TAG_LOG_SERVER,
X					  hp->log_server,
X					  &vp, &bytesleft))
X			NEED(8, "lg");
X	}
X	/*
X	 * XXX - Add new tags here (to insert options)
X	 */
X	if (hp->flags.generic) {
X		if (insert_generic(hp->generic, &vp, &bytesleft))
X			NEED(64, "(generic)");
X	}
X	/*
X	 * The end marker is inserted by the caller.
X	 */
X	return (vp - buf);
X#undef	NEED
X}								/* dovend_rfc1497 */
X
X
X
X/*
X * Insert a tag value, a length value, and a list of IP addresses into the
X * memory buffer indirectly pointed to by "dest".  "tag" is the RFC1048 tag
X * number to use, "iplist" is a pointer to a list of IP addresses
X * (struct in_addr_list), and "bytesleft" points to an integer which
X * indicates the size of the "dest" buffer.
X *
X * Return zero if everything fits.
X *
X * This is used to fill the vendor-specific area of a bootp packet in
X * conformance to RFC1048.
X */
X
Xint
Xinsert_ip(tag, iplist, dest, bytesleft)
X	byte tag;
X	struct in_addr_list *iplist;
X	byte **dest;
X	int *bytesleft;
X{
X	struct in_addr *addrptr;
X	unsigned addrcount = 1;
X	byte *d;
X
X	if (iplist == NULL)
X		return (0);
X
X	if (*bytesleft >= 6) {
X		d = *dest;				/* Save pointer for later */
X		**dest = tag;
X		(*dest) += 2;
X		(*bytesleft) -= 2;		/* Account for tag and length */
X		addrptr = iplist->addr;
X		addrcount = iplist->addrcount;
X		while ((*bytesleft >= 4) && (addrcount > 0)) {
X			insert_u_long(addrptr->s_addr, dest);
X			addrptr++;
X			addrcount--;
X			(*bytesleft) -= 4;	/* Four bytes per address */
X		}
X		d[1] = (byte) ((*dest - d - 2) & 0xFF);
X	}
X	return (addrcount);
X}
X
X
X
X/*
X * Insert generic data into a bootp packet.  The data is assumed to already
X * be in RFC1048 format.  It is inserted using a first-fit algorithm which
X * attempts to insert as many tags as possible.  Tags and data which are
X * too large to fit are skipped; any remaining tags are tried until they
X * have all been exhausted.
X * Return zero if everything fits.
X */
X
Xstatic int
Xinsert_generic(gendata, buff, bytesleft)
X	struct shared_bindata *gendata;
X	byte **buff;
X	int *bytesleft;
X{
X	byte *srcptr;
X	int length, numbytes;
X	int skipped = 0;
X
X	if (gendata == NULL)
X		return (0);
X
X	srcptr = gendata->data;
X	length = gendata->length;
X	while ((length > 0) && (*bytesleft > 0)) {
X		switch (*srcptr) {
X		case TAG_END:
X			length = 0;			/* Force an exit on next iteration */
X			break;
X		case TAG_PAD:
X			*(*buff)++ = *srcptr++;
X			(*bytesleft)--;
X			length--;
X			break;
X		default:
X			numbytes = srcptr[1] + 2;
X			if (*bytesleft < numbytes)
X				skipped += numbytes;
X			else {
X				bcopy(srcptr, *buff, numbytes);
X				(*buff) += numbytes;
X				(*bytesleft) -= numbytes;
X			}
X			srcptr += numbytes;
X			length -= numbytes;
X			break;
X		}
X	} /* while */
X	return (skipped);
X}
X
X/*
X * Insert the unsigned long "value" into memory starting at the byte
X * pointed to by the byte pointer (*dest).  (*dest) is updated to
X * point to the next available byte.
X *
X * Since it is desirable to internally store network addresses in network
X * byte order (in struct in_addr's), this routine expects longs to be
X * passed in network byte order.
X *
X * However, due to the nature of the main algorithm, the long must be in
X * host byte order, thus necessitating the use of ntohl() first.
X */
X
Xvoid
Xinsert_u_long(value, dest)
X	u_int32 value;
X	byte **dest;
X{
X	byte *temp;
X	int n;
X
X	value = ntohl(value);		/* Must use host byte order here */
X	temp = (*dest += 4);
X	for (n = 4; n > 0; n--) {
X		*--temp = (byte) (value & 0xFF);
X		value >>= 8;
X	}
X	/* Final result is network byte order */
X}
X
X/*
X * Local Variables:
X * tab-width: 4
X * c-indent-level: 4
X * c-argdecl-indent: 4
X * c-continued-statement-offset: 4
X * c-continued-brace-offset: -4
X * c-label-offset: -4
X * c-brace-offset: 0
X * End:
X */
END_OF_FILE
if test 10168 -ne `wc -c <'dovend.c'`; then
    echo shar: \"'dovend.c'\" unpacked with wrong size!
fi
# end of 'dovend.c'
fi
if test -f 'dumptab.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dumptab.c'\"
else
echo shar: Extracting \"'dumptab.c'\" \(9017 characters\)
sed "s/^X//" >'dumptab.c' <<'END_OF_FILE'
X/*
X * dumptab.c - handles dumping the database
X */
X
X#include <sys/types.h>
X#include <netinet/in.h>
X#include <arpa/inet.h>			/* inet_ntoa */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <syslog.h>
X#include <time.h>
X
X#ifndef USE_BFUNCS
X#include <memory.h>
X/* Yes, memcpy is OK here (no overlapped copies). */
X#define bcopy(a,b,c)    memcpy(b,a,c)
X#define bzero(p,l)      memset(p,0,l)
X#define bcmp(a,b,c)     memcmp(a,b,c)
X#endif
X
X#include "bootp.h"
X#include "hash.h"
X#include "hwaddr.h"
X#include "report.h"
X#include "patchlevel.h"
X#include "bootpd.h"
X
X#ifdef	__STDC__
X#define P(args) args
X#else
X#define P(args) ()
X#endif
X
Xstatic void dump_generic P((FILE *, struct shared_bindata *));
Xstatic void dump_host P((FILE *, struct host *));
Xstatic void list_ipaddresses P((FILE *, struct in_addr_list *));
X
X#undef P
X
X#ifndef	DEBUG
Xvoid
Xdumptab(filename)
X	char *filename;
X{
X	report(LOG_INFO, "No dumptab support!");
X}
X
X#else /* DEBUG */
X
X/*
X * Dump the internal memory database to bootpd_dump.
X */
X
Xvoid
Xdumptab(filename)
X	char *filename;
X{
X	int n;
X	struct host *hp;
X	FILE *fp;
X	long t;
X	/* Print symbols in alphabetical order for reader's convenience. */
X	static char legend[] = "#\n# Legend:\t(see bootptab.5)\n\
X#\tfirst field -- hostname (not indented)\n\
X#\tbf -- bootfile\n\
X#\tbs -- bootfile size in 512-octet blocks\n\
X#\tcs -- cookie servers\n\
X#\tdf -- dump file name\n\
X#\tdn -- domain name\n\
X#\tds -- domain name servers\n\
X#\tef -- extension file\n\
X#\tex -- exec file (YORK_EX_OPTION)\n\
X#\tgw -- gateways\n\
X#\tha -- hardware address\n\
X#\thd -- home directory for bootfiles\n\
X#\thn -- host name set for client\n\
X#\tht -- hardware type\n\
X#\tim -- impress servers\n\
X#\tip -- host IP address\n\
X#\tlg -- log servers\n\
X#\tlp -- LPR servers\n\
X#\tms -- message size\n\
X#\tmw -- min wait (secs)\n\
X#\tns -- IEN-116 name servers\n\
X#\tnt -- NTP servers (RFC 1129)\n\
X#\tra -- reply address override\n\
X#\trl -- resource location protocol servers\n\
X#\trp -- root path\n\
X#\tsa -- boot server address\n\
X#\tsm -- subnet mask\n\
X#\tsw -- swap server\n\
X#\ttc -- template host (points to similar host entry)\n\
X#\ttd -- TFTP directory\n\
X#\tto -- time offset (seconds)\n\
X#\tts -- time servers\n\
X#\tvm -- vendor magic number\n\
X#\tyd -- YP (NIS) domain\n\
X#\tys -- YP (NIS) servers\n\
X#\tTn -- generic option tag n\n\
X\n";
X
X	/*
X	 * Open bootpd.dump file.
X	 */
X	if ((fp = fopen(filename, "w")) == NULL) {
X		report(LOG_ERR, "error opening \"%s\": %s",
X			   filename, get_errmsg());
X		exit(1);
X	}
X	t = time(NULL);
X	fprintf(fp, "\n# %s %s.%d\n", progname, VERSION, PATCHLEVEL);
X	fprintf(fp, "# %s: dump of bootp server database.\n", filename);
X	fprintf(fp, "# Dump taken %s", ctime(&t));
X	fwrite(legend, 1, sizeof(legend) - 1, fp);
X
X	n = 0;
X	for (hp = (struct host *) hash_FirstEntry(nmhashtable); hp != NULL;
X		 hp = (struct host *) hash_NextEntry(nmhashtable)) {
X		dump_host(fp, hp);
X		fprintf(fp, "\n");
X		n++;
X	}
X	fclose(fp);
X
X	report(LOG_INFO, "dumped %d entries to \"%s\".", n, filename);
X}
X
X
X
X/*
X * Dump all the available information on the host pointed to by "hp".
X * The output is sent to the file pointed to by "fp".
X */
X
Xstatic void
Xdump_host(fp, hp)
X	FILE *fp;
X	struct host *hp;
X{
X	/* Print symbols in alphabetical order for reader's convenience. */
X	if (hp) {
X		fprintf(fp, "%s:", (hp->hostname ?
X							hp->hostname->string : "?"));
X		if (hp->flags.bootfile) {
X			fprintf(fp, "\\\n\t:bf=%s:", hp->bootfile->string);
X		}
X		if (hp->flags.bootsize) {
X			fprintf(fp, "\\\n\t:bs=");
X			if (hp->flags.bootsize_auto) {
X				fprintf(fp, "auto:");
X			} else {
X				fprintf(fp, "%d:", hp->bootsize);
X			}
X		}
X		if (hp->flags.cookie_server) {
X			fprintf(fp, "\\\n\t:cs=");
X			list_ipaddresses(fp, hp->cookie_server);
X			fprintf(fp, ":");
X		}
X		if (hp->flags.dump_file) {
X			fprintf(fp, "\\\n\t:df=%s:", hp->dump_file->string);
X		}
X		if (hp->flags.domain_name) {
X			fprintf(fp, "\\\n\t:dn=%s:", hp->domain_name->string);
X		}
X		if (hp->flags.domain_server) {
X			fprintf(fp, "\\\n\t:ds=");
X			list_ipaddresses(fp, hp->domain_server);
X			fprintf(fp, ":");
X		}
X		if (hp->flags.exten_file) {
X			fprintf(fp, "\\\n\t:ef=%s:", hp->exten_file->string);
X		}
X		if (hp->flags.exec_file) {
X			fprintf(fp, "\\\n\t:ex=%s:", hp->exec_file->string);
X		}
X		if (hp->flags.gateway) {
X			fprintf(fp, "\\\n\t:gw=");
X			list_ipaddresses(fp, hp->gateway);
X			fprintf(fp, ":");
X		}
X		/* FdC: swap_server (see below) */
X		if (hp->flags.homedir) {
X			fprintf(fp, "\\\n\t:hd=%s:", hp->homedir->string);
X		}
X		/* FdC: dump_file (see above) */
X		/* FdC: domain_name (see above) */
X		/* FdC: root_path (see below) */
X		if (hp->flags.name_switch && hp->flags.send_name) {
X			fprintf(fp, "\\\n\t:hn:");
X		}
X		if (hp->flags.htype) {
X			int hlen = haddrlength(hp->htype);
X			fprintf(fp, "\\\n\t:ht=%u:", (unsigned) hp->htype);
X			if (hp->flags.haddr) {
X				fprintf(fp, "ha=\"%s\":",
X						haddrtoa(hp->haddr, hlen));
X			}
X		}
X		if (hp->flags.impress_server) {
X			fprintf(fp, "\\\n\t:im=");
X			list_ipaddresses(fp, hp->impress_server);
X			fprintf(fp, ":");
X		}
X		/* NetBSD: swap_server (see below) */
X		if (hp->flags.iaddr) {
X			fprintf(fp, "\\\n\t:ip=%s:", inet_ntoa(hp->iaddr));
X		}
X		if (hp->flags.log_server) {
X			fprintf(fp, "\\\n\t:lg=");
X			list_ipaddresses(fp, hp->log_server);
X			fprintf(fp, ":");
X		}
X		if (hp->flags.lpr_server) {
X			fprintf(fp, "\\\n\t:lp=");
X			list_ipaddresses(fp, hp->lpr_server);
X			fprintf(fp, ":");
X		}
X		if (hp->flags.msg_size) {
X			fprintf(fp, "\\\n\t:ms=%d:", hp->msg_size);
X		}
X		if (hp->flags.min_wait) {
X			fprintf(fp, "\\\n\t:mw=%d:", hp->min_wait);
X		}
X		if (hp->flags.name_server) {
X			fprintf(fp, "\\\n\t:ns=");
X			list_ipaddresses(fp, hp->name_server);
X			fprintf(fp, ":");
X		}
X		if (hp->flags.ntp_server) {
X			fprintf(fp, "\\\n\t:nt=");
X			list_ipaddresses(fp, hp->ntp_server);
X			fprintf(fp, ":");
X		}
X		if (hp->flags.reply_addr) {
X			fprintf(fp, "\\\n\t:ra=%s:", inet_ntoa(hp->reply_addr));
X		}
X		if (hp->flags.rlp_server) {
X			fprintf(fp, "\\\n\t:rl=");
X			list_ipaddresses(fp, hp->rlp_server);
X			fprintf(fp, ":");
X		}
X		if (hp->flags.root_path) {
X			fprintf(fp, "\\\n\t:rp=%s:", hp->root_path->string);
X		}
X		if (hp->flags.bootserver) {
X			fprintf(fp, "\\\n\t:sa=%s:", inet_ntoa(hp->bootserver));
X		}
X		if (hp->flags.subnet_mask) {
X			fprintf(fp, "\\\n\t:sm=%s:", inet_ntoa(hp->subnet_mask));
X		}
X		if (hp->flags.swap_server) {
X			fprintf(fp, "\\\n\t:sw=%s:", inet_ntoa(hp->subnet_mask));
X		}
X		if (hp->flags.tftpdir) {
X			fprintf(fp, "\\\n\t:td=%s:", hp->tftpdir->string);
X		}
X		/* NetBSD: rootpath (see above) */
X		/* NetBSD: domainname (see above) */
X		/* NetBSD: dumpfile (see above) */
X		if (hp->flags.time_offset) {
X			fprintf(fp, "\\\n\t:to=%ld:", hp->time_offset);
X		}
X		if (hp->flags.time_server) {
X			fprintf(fp, "\\\n\t:ts=");
X			list_ipaddresses(fp, hp->time_server);
X			fprintf(fp, ":");
X		}
X		if (hp->flags.vm_cookie) {
X			fprintf(fp, "\\\n\t:vm=");
X			if (!bcmp(hp->vm_cookie, vm_rfc1048, 4)) {
X				fprintf(fp, "rfc1048:");
X			} else if (!bcmp(hp->vm_cookie, vm_cmu, 4)) {
X				fprintf(fp, "cmu:");
X			} else {
X				fprintf(fp, "%d.%d.%d.%d:",
X						(int) ((hp->vm_cookie)[0]),
X						(int) ((hp->vm_cookie)[1]),
X						(int) ((hp->vm_cookie)[2]),
X						(int) ((hp->vm_cookie)[3]));
X			}
X		}
X		if (hp->flags.nis_domain) {
X			fprintf(fp, "\\\n\t:yd=%s:",
X					hp->nis_domain->string);
X		}
X		if (hp->flags.nis_server) {
X			fprintf(fp, "\\\n\t:ys=");
X			list_ipaddresses(fp, hp->nis_server);
X			fprintf(fp, ":");
X		}
X		/*
X		 * XXX - Add new tags here (or above,
X		 * so they print in alphabetical order).
X		 */
X
X		if (hp->flags.generic) {
X			dump_generic(fp, hp->generic);
X		}
X	}
X}
X
X
Xstatic void
Xdump_generic(fp, generic)
X	FILE *fp;
X	struct shared_bindata *generic;
X{
X	u_char *bp = generic->data;
X	u_char *ep = bp + generic->length;
X	u_char tag;
X	int len;
X
X	while (bp < ep) {
X		tag = *bp++;
X		if (tag == TAG_PAD)
X			continue;
X		if (tag == TAG_END)
X			return;
X		len = *bp++;
X		if (bp + len > ep) {
X			fprintf(fp, " #junk in generic! :");
X			return;
X		}
X		fprintf(fp, "\\\n\t:T%d=", tag);
X		while (len) {
X			fprintf(fp, "%02X", *bp);
X			bp++;
X			len--;
X			if (len)
X				fprintf(fp, ".");
X		}
X		fprintf(fp, ":");
X	}
X}
X
X
X
X/*
X * Dump an entire struct in_addr_list of IP addresses to the indicated file.
X *
X * The addresses are printed in standard ASCII "dot" notation and separated
X * from one another by a single space.  A single leading space is also
X * printed before the first adddress.
X *
X * Null lists produce no output (and no error).
X */
X
Xstatic void
Xlist_ipaddresses(fp, ipptr)
X	FILE *fp;
X	struct in_addr_list *ipptr;
X{
X	unsigned count;
X	struct in_addr *addrptr;
X
X	if (ipptr) {
X		count = ipptr->addrcount;
X		addrptr = ipptr->addr;
X		while (count > 0) {
X			fprintf(fp, "%s", inet_ntoa(*addrptr++));
X			count--;
X			if (count)
X				fprintf(fp, ", ");
X		}
X	}
X}
X
X#endif /* DEBUG */
X
X/*
X * Local Variables:
X * tab-width: 4
X * c-indent-level: 4
X * c-argdecl-indent: 4
X * c-continued-statement-offset: 4
X * c-continued-brace-offset: -4
X * c-label-offset: -4
X * c-brace-offset: 0
X * End:
X */
END_OF_FILE
if test 9017 -ne `wc -c <'dumptab.c'`; then
    echo shar: \"'dumptab.c'\" unpacked with wrong size!
fi
# end of 'dumptab.c'
fi
if test -f 'getether.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getether.c'\"
else
echo shar: Extracting \"'getether.c'\" \(9139 characters\)
sed "s/^X//" >'getether.c' <<'END_OF_FILE'
X/*
X * getether.c : get the ethernet address of an interface
X *
X * All of this code is quite system-specific.  As you may well
X * guess, it took a good bit of detective work to figure out!
X *
X * If you figure out how to do this on another system,
X * please let me know.  <gwr@mc.com>
X */
X
X#include <sys/types.h>
X#include <sys/socket.h>
X
X#include <ctype.h>
X#include <syslog.h>
X
X#include "report.h"
X#define EALEN 6
X
X#if defined(ultrix) || (defined(__osf__) && defined(__alpha))
X/*
X * This is really easy on Ultrix!  Thanks to
X * Harald Lundberg <hl@tekla.fi> for this code.
X *
X * The code here is not specific to the Alpha, but that was the
X * only symbol we could find to identify DEC's version of OSF.
X * (Perhaps we should just define DEC in the Makefile... -gwr)
X */
X
X#include <sys/ioctl.h>
X#include <net/if.h>				/* struct ifdevea */
X
Xgetether(ifname, eap)
X	char *ifname, *eap;
X{
X	int rc = -1;
X	int fd;
X	struct ifdevea phys;
X	bzero(&phys, sizeof(phys));
X	strcpy(phys.ifr_name, ifname);
X	if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
X		report(LOG_ERR, "getether: socket(INET,DGRAM) failed");
X		return -1;
X	}
X	if (ioctl(fd, SIOCRPHYSADDR, &phys) < 0) {
X		report(LOG_ERR, "getether: ioctl SIOCRPHYSADDR failed");
X	} else {
X		bcopy(&phys.current_pa[0], eap, EALEN);
X		rc = 0;
X	}
X	close(fd);
X	return rc;
X}
X
X#define	GETETHER
X#endif /* ultrix|osf1 */
X
X
X#ifdef	SUNOS
X
X#include <sys/sockio.h>
X#include <sys/time.h>			/* needed by net_if.h */
X#include <net/nit_if.h>			/* for NIOCBIND */
X#include <net/if.h>				/* for struct ifreq */
X
Xgetether(ifname, eap)
X	char *ifname;				/* interface name from ifconfig structure */
X	char *eap;					/* Ether address (output) */
X{
X	int rc = -1;
X
X	struct ifreq ifrnit;
X	int nit;
X
X	bzero((char *) &ifrnit, sizeof(ifrnit));
X	strncpy(&ifrnit.ifr_name[0], ifname, IFNAMSIZ);
X
X	nit = open("/dev/nit", 0);
X	if (nit < 0) {
X		report(LOG_ERR, "getether: open /dev/nit: %s",
X			   get_errmsg());
X		return rc;
X	}
X	do {
X		if (ioctl(nit, NIOCBIND, &ifrnit) < 0) {
X			report(LOG_ERR, "getether: NIOCBIND on nit");
X			break;
X		}
X		if (ioctl(nit, SIOCGIFADDR, &ifrnit) < 0) {
X			report(LOG_ERR, "getether: SIOCGIFADDR on nit");
X			break;
X		}
X		bcopy(&ifrnit.ifr_addr.sa_data[0], eap, EALEN);
X		rc = 0;
X	} while (0);
X	close(nit);
X	return rc;
X}
X
X#define	GETETHER
X#endif /* SUNOS */
X
X
X#if defined(__386BSD__) || defined(__NetBSD__)
X/* Thanks to John Brezak <brezak@ch.hp.com> for this code. */
X#include <sys/ioctl.h>
X#include <net/if.h>
X#include <net/if_dl.h>
X#include <net/if_types.h>
X
Xgetether(ifname, eap)
X	char *ifname;				/* interface name from ifconfig structure */
X	char *eap;					/* Ether address (output) */
X{
X	int fd, rc = -1;
X	register int n;
X	struct ifreq ibuf[16], ifr;
X	struct ifconf ifc;
X	register struct ifreq *ifrp, *ifend;
X
X	/* Fetch the interface configuration */
X	fd = socket(AF_INET, SOCK_DGRAM, 0);
X	if (fd < 0) {
X		report(LOG_ERR, "getether: socket %s: %s", ifname, get_errmsg());
X		return (fd);
X	}
X	ifc.ifc_len = sizeof(ibuf);
X	ifc.ifc_buf = (caddr_t) ibuf;
X	if (ioctl(fd, SIOCGIFCONF, (char *) &ifc) < 0 ||
X		ifc.ifc_len < sizeof(struct ifreq)) {
X		report(LOG_ERR, "getether: SIOCGIFCONF: %s", get_errmsg);
X		goto out;
X	}
X	/* Search interface configuration list for link layer address. */
X	ifrp = ibuf;
X	ifend = (struct ifreq *) ((char *) ibuf + ifc.ifc_len);
X	while (ifrp < ifend) {
X		/* Look for interface */
X		if (strcmp(ifname, ifrp->ifr_name) == 0 &&
X			ifrp->ifr_addr.sa_family == AF_LINK &&
X		((struct sockaddr_dl *) &ifrp->ifr_addr)->sdl_type == IFT_ETHER) {
X			bcopy(LLADDR((struct sockaddr_dl *) &ifrp->ifr_addr), eap, EALEN);
X			rc = 0;
X			break;
X		}
X		/* Bump interface config pointer */
X		n = ifrp->ifr_addr.sa_len + sizeof(ifrp->ifr_name);
X		if (n < sizeof(*ifrp))
X			n = sizeof(*ifrp);
X		ifrp = (struct ifreq *) ((char *) ifrp + n);
X	}
X
X  out:
X	close(fd);
X	return (rc);
X}
X
X#define	GETETHER
X#endif /* __NetBSD__ */
X
X
X#ifdef	SVR4
X/*
X * This is for "Streams TCP/IP" by Lachman Associates.
X * They sure made this cumbersome!  -gwr
X */
X
X#include <sys/sockio.h>
X#include <sys/dlpi.h>
X#include <stropts.h>
X#ifndef NULL
X#define NULL 0
X#endif
X
Xgetether(ifname, eap)
X	char *ifname;				/* interface name from ifconfig structure */
X	char *eap;					/* Ether address (output) */
X{
X	int rc = -1;
X	char devname[32];
X	char tmpbuf[sizeof(union DL_primitives) + 16];
X	struct strbuf cbuf;
X	int fd, flags;
X	union DL_primitives *dlp;
X	char *enaddr;
X	int unit = -1;				/* which unit to attach */
X
X	sprintf(devname, "/dev/%s", ifname);
X	fd = open(devname, 2);
X	if (fd < 0) {
X		/* Try without the trailing digit. */
X		char *p = devname + 5;
X		while (isalpha(*p))
X			p++;
X		if (isdigit(*p)) {
X			unit = *p - '0';
X			*p = '\0';
X		}
X		fd = open(devname, 2);
X		if (fd < 0) {
X			report(LOG_ERR, "getether: open %s: %s",
X				   devname, get_errmsg());
X			return rc;
X		}
X	}
X#ifdef	DL_ATTACH_REQ
X	/*
X	 * If this is a "Style 2" DLPI, then we must "attach" first
X	 * to tell the driver which unit (board, port) we want.
X	 * For now, decide this based on the device name.
X	 * (Should do "info_req" and check dl_provider_style ...)
X	 */
X	if (unit >= 0) {
X		memset(tmpbuf, 0, sizeof(tmpbuf));
X		dlp = (union DL_primitives *) tmpbuf;
X		dlp->dl_primitive = DL_ATTACH_REQ;
X		dlp->attach_req.dl_ppa = unit;
X		cbuf.buf = tmpbuf;
X		cbuf.len = DL_ATTACH_REQ_SIZE;
X		if (putmsg(fd, &cbuf, NULL, 0) < 0) {
X			report(LOG_ERR, "getether: attach: putmsg: %s", get_errmsg());
X			goto out;
X		}
X		/* Recv the ack. */
X		cbuf.buf = tmpbuf;
X		cbuf.maxlen = sizeof(tmpbuf);
X		flags = 0;
X		if (getmsg(fd, &cbuf, NULL, &flags) < 0) {
X			report(LOG_ERR, "getether: attach: getmsg: %s", get_errmsg());
X			goto out;
X		}
X		/*
X		 * Check the type, etc.
X		 */
X		if (dlp->dl_primitive == DL_ERROR_ACK) {
X			report(LOG_ERR, "getether: attach: dlpi_errno=%d, unix_errno=%d",
X				   dlp->error_ack.dl_errno,
X				   dlp->error_ack.dl_unix_errno);
X			goto out;
X		}
X		if (dlp->dl_primitive != DL_OK_ACK) {
X			report(LOG_ERR, "getether: attach: not OK or ERROR");
X			goto out;
X		}
X	} /* unit >= 0 */
X#endif	/* DL_ATTACH_REQ */
X
X	/*
X	 * Get the Ethernet address the same way the ARP module
X	 * does when it is pushed onto a new stream (bind).
X	 * One should instead be able just do an dl_info_req
X	 * but many drivers do not supply the hardware address
X	 * in the response to dl_info_req (they MUST supply it
X	 * for dl_bind_ack because the ARP module requires it).
X	 */
X	memset(tmpbuf, 0, sizeof(tmpbuf));
X	dlp = (union DL_primitives *) tmpbuf;
X	dlp->dl_primitive = DL_BIND_REQ;
X	dlp->bind_req.dl_sap = 0x8FF;	/* XXX - Unused SAP */
X	cbuf.buf = tmpbuf;
X	cbuf.len = DL_BIND_REQ_SIZE;
X	if (putmsg(fd, &cbuf, NULL, 0) < 0) {
X		report(LOG_ERR, "getether: bind: putmsg: %s", get_errmsg());
X		goto out;
X	}
X	/* Recv the ack. */
X	cbuf.buf = tmpbuf;
X	cbuf.maxlen = sizeof(tmpbuf);
X	flags = 0;
X	if (getmsg(fd, &cbuf, NULL, &flags) < 0) {
X		report(LOG_ERR, "getether: bind: getmsg: %s", get_errmsg());
X		goto out;
X	}
X	/*
X	 * Check the type, etc.
X	 */
X	if (dlp->dl_primitive == DL_ERROR_ACK) {
X		report(LOG_ERR, "getether: bind: dlpi_errno=%d, unix_errno=%d",
X			   dlp->error_ack.dl_errno,
X			   dlp->error_ack.dl_unix_errno);
X		goto out;
X	}
X	if (dlp->dl_primitive != DL_BIND_ACK) {
X		report(LOG_ERR, "getether: bind: not OK or ERROR");
X		goto out;
X	}
X	if (dlp->bind_ack.dl_addr_offset == 0) {
X		report(LOG_ERR, "getether: bind: ack has no address");
X		goto out;
X	}
X	if (dlp->bind_ack.dl_addr_length < EALEN) {
X		report(LOG_ERR, "getether: bind: ack address truncated");
X		goto out;
X	}
X	/*
X	 * Copy the Ethernet address out of the message.
X	 */
X	enaddr = tmpbuf + dlp->bind_ack.dl_addr_offset;
X	memcpy(eap, enaddr, EALEN);
X	rc = 0;
X
X  out:
X	close(fd);
X	return rc;
X}
X
X#define	GETETHER
X#endif /* SVR4 */
X
X
X#ifdef	linux
X/*
X * This is really easy on Linux!  This version (for linux)
X * written by Nigel Metheringham <nigelm@ohm.york.ac.uk>
X *
X * The code is almost identical to the Ultrix code - however
X * the names are different to confuse the innocent :-)
X * Most of this code was stolen from the Ultrix bit above.
X */
X
X#include <sys/ioctl.h>
X#include <net/if.h>	       	/* struct ifreq */
X
X/* In a properly configured system this should be either sys/socketio.h
X   or sys/sockios.h, but on my distribution these don't line up correctly */
X#include <linux/sockios.h>	/* Needed for IOCTL defs */
X
Xgetether(ifname, eap)
X	char *ifname, *eap;
X{
X	int rc = -1;
X	int fd;
X	struct ifreq phys;
X	bzero(&phys, sizeof(phys));
X	strcpy(phys.ifr_name, ifname);
X	if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
X		report(LOG_ERR, "getether: socket(INET,DGRAM) failed");
X		return -1;
X	}
X	if (ioctl(fd, SIOCGIFHWADDR, &phys) < 0) {
X		report(LOG_ERR, "getether: ioctl SIOCGIFHWADDR failed");
X	} else {
X		bcopy(phys.ifr_hwaddr, eap, EALEN);
X		rc = 0;
X	}
X	close(fd);
X	return rc;
X}
X
X#define	GETETHER
X#endif	/* linux */
X
X
X/* If we don't know how on this system, just return an error. */
X#ifndef	GETETHER
Xgetether(ifname, eap)
X	char *ifname, *eap;
X{
X	return -1;
X}
X
X#endif /* !GETETHER */
X
X/*
X * Local Variables:
X * tab-width: 4
X * c-indent-level: 4
X * c-argdecl-indent: 4
X * c-continued-statement-offset: 4
X * c-continued-brace-offset: -4
X * c-label-offset: -4
X * c-brace-offset: 0
X * End:
X */
END_OF_FILE
if test 9139 -ne `wc -c <'getether.c'`; then
    echo shar: \"'getether.c'\" unpacked with wrong size!
fi
# end of 'getether.c'
fi
if test -f 'hash.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hash.c'\"
else
echo shar: Extracting \"'hash.c'\" \(10386 characters\)
sed "s/^X//" >'hash.c' <<'END_OF_FILE'
X/************************************************************************
X          Copyright 1988, 1991 by Carnegie Mellon University
X
X                          All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted, provided
Xthat the above copyright notice appear in all copies and that both that
Xcopyright notice and this permission notice appear in supporting
Xdocumentation, and that the name of Carnegie Mellon University not be used
Xin advertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.
X
XCARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
XSOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
XIN NO EVENT SHALL CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
XDAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
XPROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
XACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X************************************************************************/
X
X#ifndef lint
Xstatic char rcsid[] = "$Id: hash.c $";
X#endif
X
X
X/*
X * Generalized hash table ADT
X *
X * Provides multiple, dynamically-allocated, variable-sized hash tables on
X * various data and keys.
X *
X * This package attempts to follow some of the coding conventions suggested
X * by Bob Sidebotham and the AFS Clean Code Committee of the
X * Information Technology Center at Carnegie Mellon.
X */
X
X
X#include <sys/types.h>
X#include <stdlib.h>
X
X#ifndef USE_BFUNCS
X#include <memory.h>
X/* Yes, memcpy is OK here (no overlapped copies). */
X#define bcopy(a,b,c)    memcpy(b,a,c)
X#define bzero(p,l)      memset(p,0,l)
X#define bcmp(a,b,c)     memcmp(a,b,c)
X#endif
X
X#include "hash.h"
X
X#define TRUE		1
X#define FALSE		0
X#ifndef	NULL
X#define NULL		0
X#endif
X
X/*
X * This can be changed to make internal routines visible to debuggers, etc.
X */
X#ifndef PRIVATE
X#define PRIVATE static
X#endif
X
X#ifdef	__STDC__
X#define P(args) args
X#else
X#define P(args) ()
X#endif
X
XPRIVATE void hashi_FreeMembers P((hash_member *, hash_freefp));
X
X#undef P
X
X
X
X/*
X * Hash table initialization routine.
X *
X * This routine creates and intializes a hash table of size "tablesize"
X * entries.  Successful calls return a pointer to the hash table (which must
X * be passed to other hash routines to identify the hash table).  Failed
X * calls return NULL.
X */
X
Xhash_tbl *
Xhash_Init(tablesize)
X	unsigned tablesize;
X{
X	register hash_tbl *hashtblptr;
X	register unsigned totalsize;
X
X	if (tablesize > 0) {
X		totalsize = sizeof(hash_tbl)
X			+ sizeof(hash_member *) * (tablesize - 1);
X		hashtblptr = (hash_tbl *) malloc(totalsize);
X		if (hashtblptr) {
X			bzero((char *) hashtblptr, totalsize);
X			hashtblptr->size = tablesize;	/* Success! */
X			hashtblptr->bucketnum = 0;
X			hashtblptr->member = (hashtblptr->table)[0];
X		}
X	} else {
X		hashtblptr = NULL;		/* Disallow zero-length tables */
X	}
X	return hashtblptr;			/* NULL if failure */
X}
X
X
X
X/*
X * Frees an entire linked list of bucket members (used in the open
X * hashing scheme).  Does nothing if the passed pointer is NULL.
X */
X
XPRIVATE void
Xhashi_FreeMembers(bucketptr, free_data)
X	hash_member *bucketptr;
X	hash_freefp free_data;
X{
X	hash_member *nextbucket;
X	while (bucketptr) {
X		nextbucket = bucketptr->next;
X		(*free_data) (bucketptr->data);
X		free((char *) bucketptr);
X		bucketptr = nextbucket;
X	}
X}
X
X
X
X
X/*
X * This routine re-initializes the hash table.  It frees all the allocated
X * memory and resets all bucket pointers to NULL.
X */
X
Xvoid
Xhash_Reset(hashtable, free_data)
X	hash_tbl *hashtable;
X	hash_freefp free_data;
X{
X	hash_member **bucketptr;
X	unsigned i;
X
X	bucketptr = hashtable->table;
X	for (i = 0; i < hashtable->size; i++) {
X		hashi_FreeMembers(*bucketptr, free_data);
X		*bucketptr++ = NULL;
X	}
X	hashtable->bucketnum = 0;
X	hashtable->member = (hashtable->table)[0];
X}
X
X
X
X/*
X * Generic hash function to calculate a hash code from the given string.
X *
X * For each byte of the string, this function left-shifts the value in an
X * accumulator and then adds the byte into the accumulator.  The contents of
X * the accumulator is returned after the entire string has been processed.
X * It is assumed that this result will be used as the "hashcode" parameter in
X * calls to other functions in this package.  These functions automatically
X * adjust the hashcode for the size of each hashtable.
X *
X * This algorithm probably works best when the hash table size is a prime
X * number.
X *
X * Hopefully, this function is better than the previous one which returned
X * the sum of the squares of all the bytes.  I'm still open to other
X * suggestions for a default hash function.  The programmer is more than
X * welcome to supply his/her own hash function as that is one of the design
X * features of this package.
X */
X
Xunsigned
Xhash_HashFunction(string, len)
X	unsigned char *string;
X	register unsigned len;
X{
X	register unsigned accum;
X
X	accum = 0;
X	for (; len > 0; len--) {
X		accum <<= 1;
X		accum += (unsigned) (*string++ & 0xFF);
X	}
X	return accum;
X}
X
X
X
X/*
X * Returns TRUE if at least one entry for the given key exists; FALSE
X * otherwise.
X */
X
Xint
Xhash_Exists(hashtable, hashcode, compare, key)
X	hash_tbl *hashtable;
X	unsigned hashcode;
X	hash_cmpfp compare;
X	hash_datum *key;
X{
X	register hash_member *memberptr;
X
X	memberptr = (hashtable->table)[hashcode % (hashtable->size)];
X	while (memberptr) {
X		if ((*compare) (key, memberptr->data)) {
X			return TRUE;		/* Entry does exist */
X		}
X		memberptr = memberptr->next;
X	}
X	return FALSE;				/* Entry does not exist */
X}
X
X
X
X/*
X * Insert the data item "element" into the hash table using "hashcode"
X * to determine the bucket number, and "compare" and "key" to determine
X * its uniqueness.
X *
X * If the insertion is successful 0 is returned.  If a matching entry
X * already exists in the given bucket of the hash table, or some other error
X * occurs, -1 is returned and the insertion is not done.
X */
X
Xint
Xhash_Insert(hashtable, hashcode, compare, key, element)
X	hash_tbl *hashtable;
X	unsigned hashcode;
X	hash_cmpfp compare;
X	hash_datum *key, *element;
X{
X	hash_member *temp;
X
X	hashcode %= hashtable->size;
X	if (hash_Exists(hashtable, hashcode, compare, key)) {
X		return -1;				/* At least one entry already exists */
X	}
X	temp = (hash_member *) malloc(sizeof(hash_member));
X	if (!temp)
X		return -1;				/* malloc failed! */
X
X	temp->data = element;
X	temp->next = (hashtable->table)[hashcode];
X	(hashtable->table)[hashcode] = temp;
X	return 0;					/* Success */
X}
X
X
X
X/*
X * Delete all data elements which match the given key.  If at least one
X * element is found and the deletion is successful, 0 is returned.
X * If no matching elements can be found in the hash table, -1 is returned.
X */
X
Xint
Xhash_Delete(hashtable, hashcode, compare, key, free_data)
X	hash_tbl *hashtable;
X	unsigned hashcode;
X	hash_cmpfp compare;
X	hash_datum *key;
X	hash_freefp free_data;
X{
X	hash_member *memberptr, *tempptr;
X	hash_member *previous = NULL;
X	int retval;
X
X	retval = -1;
X	hashcode %= hashtable->size;
X
X	/*
X	 * Delete the first member of the list if it matches.  Since this moves
X	 * the second member into the first position we have to keep doing this
X	 * over and over until it no longer matches.
X	 */
X	memberptr = (hashtable->table)[hashcode];
X	while (memberptr && (*compare) (key, memberptr->data)) {
X		(hashtable->table)[hashcode] = memberptr->next;
X		/*
X		 * Stop hashi_FreeMembers() from deleting the whole list!
X		 */
X		memberptr->next = NULL;
X		hashi_FreeMembers(memberptr, free_data);
X		memberptr = (hashtable->table)[hashcode];
X		retval = 0;
X	}
X
X	/*
X	 * Now traverse the rest of the list
X	 */
X	if (memberptr) {
X		previous = memberptr;
X		memberptr = memberptr->next;
X	}
X	while (memberptr) {
X		if ((*compare) (key, memberptr->data)) {
X			tempptr = memberptr;
X			previous->next = memberptr = memberptr->next;
X			/*
X			 * Put the brakes on hashi_FreeMembers(). . . .
X			 */
X			tempptr->next = NULL;
X			hashi_FreeMembers(tempptr, free_data);
X			retval = 0;
X		} else {
X			previous = memberptr;
X			memberptr = memberptr->next;
X		}
X	}
X	return retval;
X}
X
X
X
X/*
X * Locate and return the data entry associated with the given key.
X *
X * If the data entry is found, a pointer to it is returned.  Otherwise,
X * NULL is returned.
X */
X
Xhash_datum *
Xhash_Lookup(hashtable, hashcode, compare, key)
X	hash_tbl *hashtable;
X	unsigned hashcode;
X	hash_cmpfp compare;
X	hash_datum *key;
X{
X	hash_member *memberptr;
X
X	memberptr = (hashtable->table)[hashcode % (hashtable->size)];
X	while (memberptr) {
X		if ((*compare) (key, memberptr->data)) {
X			return (memberptr->data);
X		}
X		memberptr = memberptr->next;
X	}
X	return NULL;
X}
X
X
X
X/*
X * Return the next available entry in the hashtable for a linear search
X */
X
Xhash_datum *
Xhash_NextEntry(hashtable)
X	hash_tbl *hashtable;
X{
X	register unsigned bucket;
X	register hash_member *memberptr;
X
X	/*
X	 * First try to pick up where we left off.
X	 */
X	memberptr = hashtable->member;
X	if (memberptr) {
X		hashtable->member = memberptr->next;	/* Set up for next call */
X		return memberptr->data;	/* Return the data */
X	}
X	/*
X	 * We hit the end of a chain, so look through the array of buckets
X	 * until we find a new chain (non-empty bucket) or run out of buckets.
X	 */
X	bucket = hashtable->bucketnum + 1;
X	while ((bucket < hashtable->size) &&
X		   !(memberptr = (hashtable->table)[bucket])) {
X		bucket++;
X	}
X
X	/*
X	 * Check to see if we ran out of buckets.
X	 */
X	if (bucket >= hashtable->size) {
X		/*
X		 * Reset to top of table for next call.
X		 */
X		hashtable->bucketnum = 0;
X		hashtable->member = (hashtable->table)[0];
X		/*
X		 * But return end-of-table indication to the caller this time.
X		 */
X		return NULL;
X	}
X	/*
X	 * Must have found a non-empty bucket.
X	 */
X	hashtable->bucketnum = bucket;
X	hashtable->member = memberptr->next;	/* Set up for next call */
X	return memberptr->data;		/* Return the data */
X}
X
X
X
X/*
X * Return the first entry in a hash table for a linear search
X */
X
Xhash_datum *
Xhash_FirstEntry(hashtable)
X	hash_tbl *hashtable;
X{
X	hashtable->bucketnum = 0;
X	hashtable->member = (hashtable->table)[0];
X	return hash_NextEntry(hashtable);
X}
X
X/*
X * Local Variables:
X * tab-width: 4
X * c-indent-level: 4
X * c-argdecl-indent: 4
X * c-continued-statement-offset: 4
X * c-continued-brace-offset: -4
X * c-label-offset: -4
X * c-brace-offset: 0
X * End:
X */
END_OF_FILE
if test 10386 -ne `wc -c <'hash.c'`; then
    echo shar: \"'hash.c'\" unpacked with wrong size!
fi
# end of 'hash.c'
fi
echo shar: End of archive 2 \(of 4\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
