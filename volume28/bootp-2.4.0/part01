Newsgroups: comp.sources.unix
From: gwr@mc.com (Gordon W. Ross)
Subject: v28i115: bootp-2.4.0 - RFC 1048,1533 "bootp" server (updates V27I63), Part01/04
Message-id: <1.777611200.751@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: gwr@mc.com (Gordon W. Ross)
Posting-Number: Volume 28, Issue 115
Archive-Name: bootp-2.4.0/part01

	This is an enhanced version of the CMU BOOTP server which was
	derived from the original BOOTP server created by Bill Croft at
	Stanford.  This version merges most of the enhancements and
	bug-fixes from the NetBSD, Columbia, and other versions.

		gwr@mc.com (Gordon W. Ross)

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 4)."
# Contents:  Announce ConvOldTab.sh Installation MANIFEST Makefile
#   Problems README ToDo bootp.h bootpd.h bootpef.8 bootpef.c
#   bootptab.cmu bootptab.mcs bootptest.8 bootptest.h bptypes.h
#   dot-indent.pro dovend.h getif.c getif.h hash.h hwaddr.c hwaddr.h
#   lookup.c lookup.h patchlevel.h readfile.h report.c report.h
#   strerror.c syslog.conf syslog.h trygetea.c trygetif.c trylook.c
#   tzone.c tzone.h
# Wrapped by vixie@gw.home.vix.com on Mon Aug 22 20:04:21 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Announce' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Announce'\"
else
echo shar: Extracting \"'Announce'\" \(2382 characters\)
sed "s/^X//" >'Announce' <<'END_OF_FILE'
X
XThis is an enhanced version of the CMU BOOTP server which was derived
Xfrom the original BOOTP server created by Bill Croft at Stanford.
XThis version merges most of the enhancements and bug-fixes from the
XNetBSD, Columbia, and other versions.
X
XNew features in version 2.4 include:
X
X	Added a simple BOOTP gateway program: bootpgw
X	Allow host name anywhere IP address is expected.
X	Automatically lookup the IP address when the name of a
X		bootptab entry is a valid hostname.
X		(Dummy entries names should start with '.')
X	Merged changes from NetBSD and Columbia versions.
X	Merged changes for Solaris-2.X and SVR4 systems.
X	Combined bootptest into the bootp release.
X	Merged tag 18 support (:ef=...:) from Jason Zions.
X		Use :ef=extension_file_name: and make the
X		extension files for all clients using bootpef.
X	Merged HP compatibility (:ra=...:) from David R Linn.
X		Allows you to override the reply address.
X		(i.e. send the reply to a broadcast address)
X	Add /etc/ethers support for NetBSD.
X	More systems support getether (Ultrix, OSF, NetBSD)
X	Added RFC 1533 tags 40,41,42
X		:yd=<NIS domain>:ys=<NIS server>:nt=<NTP server>:
X	ConvOldTab.sh to convert old (1.1) bootptab to new format.
X	Permits extended-length replies with more option data.
X
XProblems fixed in this version:
X
X	Fixed references to free host structures.
X		(used to cause core dump on Solaris)
X	Remove change that added null terminator to string options.
X		(this annoyed some clients...)
X	Add missing symbols to dump routine, fix order.
X	Works (again) with no -DSYSLOGD defined.
X	Fixed several more NULL references in readfile.
X	Added proper length checks to option insertions.
X	Fixed bootptest IP address printing.
X	Cleaned-up signed/unsigned and byteorder bugs.
X	Added SVR4/Streams support to getif and getether
X	Removed extra newlines in syslog messages.
X	Specify facility code when calling syslog(3)
X	When lookup_hwa fails, assume numeric HW address.
X
XSystems on which I have seen this code work:
X	SunOS 4.X (Solaris 1.X)
X	SunOS 5.X (Solaris 2.X)
X	System V/386 Rel. 4.0
X
XSystems on which others say this code works:
X	CDC EP/IX (1.4.3, 2.1.1)
X	DEC Ultrix (4.2, 4.3)
X	NetBSD (Current-8/94)
X	OSF/1 (DEC Alpha CPU)
X
XPlease direct questions, comments, and bug reports to:
X	<bootp@andrew.cmu.edu>
X
XGordon W. Ross  		Mercury Computer Systems
Xgwr@mc.com      		199 Riverneck Road
X508-256-1300			Chelmsford, MA 01824-2820
END_OF_FILE
if test 2382 -ne `wc -c <'Announce'`; then
    echo shar: \"'Announce'\" unpacked with wrong size!
fi
# end of 'Announce'
fi
if test -f 'ConvOldTab.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ConvOldTab.sh'\"
else
echo shar: Extracting \"'ConvOldTab.sh'\" \(3781 characters\)
sed "s/^X//" >'ConvOldTab.sh' <<'END_OF_FILE'
X#!/bin/sh
X#   convert_bootptab	Jeroen.Scheerder@let.ruu.nl 02/25/94
X#	This script can be used to convert bootptab files in old format
X#	to new (termcap-like) bootptab files
X#
X# The old format - real entries are commented out by '###'
X#
X# Old-style bootp files consist of two sections.
X# The first section has two entries:
X# First, a line that specifies the home directory
X# (where boot file paths are relative to)
X
X###/tftpboot
X
X# The next non-empty non-comment line specifies the default bootfile
X
X###no-file
X
X# End of first section - indicated by '%%' at the start of the line
X
X###%%
X
X# The remainder of this file contains one line per client
X# interface with the information shown by the table headings
X# below. The host name is also tried as a suffix for the
X# bootfile when searching the home directory (that is,
X# bootfile.host)
X#
X# Note that htype is always 1, indicating the hardware type Ethernet.
X# Conversion therefore always yields ':ha=ether:'.
X#
X# host	htype	haddr	iaddr	bootfile
X#
X
X###somehost	1	00:0b:ad:01:de:ad	128.128.128.128	dummy
X
X# That's all for the description of the old format.
X# For the new-and-improved format, see bootptab(5).
X
Xset -u$DX
X
Xcase $#
Xin	2 )	OLDTAB=$1 ; NEWTAB=$2 ;;
X	* )	echo "Usage: `basename $0` <Input> <Output>"
X		exit 1
Xesac
X
Xif [ ! -r $OLDTAB ]
Xthen
X	echo "`basename $0`: $OLDTAB does not exist or is unreadable."
X	exit 1
Xfi
X
Xif touch $NEWTAB 2> /dev/null
Xthen
X	:
Xelse
X	echo "`basename $0`: cannot write to $NEWTAB."
X	exit 1
Xfi
X
X
Xcat << END_OF_HEADER >> $NEWTAB
X# /etc/bootptab: database for bootp server (/etc/bootpd)
X# This file was generated automagically
X
X# Blank lines and lines beginning with '#' are ignored.
X#
X# Legend:	(see bootptab.5)
X#	first field -- hostname (not indented)
X#	bf -- bootfile
X#	bs -- bootfile size in 512-octet blocks
X#	cs -- cookie servers
X#	df -- dump file name
X#	dn -- domain name
X#	ds -- domain name servers
X#	ef -- extension file
X#	gw -- gateways
X#	ha -- hardware address
X#	hd -- home directory for bootfiles
X#	hn -- host name set for client
X#	ht -- hardware type
X#	im -- impress servers
X#	ip -- host IP address
X#	lg -- log servers
X#	lp -- LPR servers
X#	ns -- IEN-116 name servers
X#	ra -- reply address
X#	rl -- resource location protocol servers
X#	rp -- root path
X#	sa -- boot server address
X#	sm -- subnet mask
X#	sw -- swap server
X#	tc -- template host (points to similar host entry)
X#	td -- TFTP directory
X#	to -- time offset (seconds)
X#	ts -- time servers
X#	vm -- vendor magic number
X#	Tn -- generic option tag n
X#
X# Be careful about including backslashes where they're needed.  Weird (bad)
X# things can happen when a backslash is omitted where one is intended.
X# Also, note that generic option data must be either a string or a
X# sequence of bytes where each byte is a two-digit hex value.
X
X# First, we define a global entry which specifies the stuff every host uses.
X# (Host name lookups are relative to the domain: your.domain.name)
X
XEND_OF_HEADER
X
X# Fix up HW addresses in aa:bb:cc:dd:ee:ff and aa-bb-cc-dd-ee-ff style first
X# Then awk our stuff together
Xsed -e  's/[:-]//g' < $OLDTAB | \
Xnawk 'BEGIN	{ PART = 0 ; FIELD=0 ; BOOTPATH="unset" ; BOOTFILE="unset" }
X	/^%%/	{
X				PART = 1
X				printf ".default:\\\n\t:ht=ether:\\\n\t:hn:\\\n\t:dn=your.domain.name:\\\n\t:ds=your,dns,servers:\\\n\t:sm=255.255.0.0:\\\n\t:hd=%s:\\\n\t:rp=%s:\\\n\t:td=%s:\\\n\t:bf=%s:\\\n\t:to=auto:\n\n", BOOTPATH, BOOTPATH, BOOTPATH, BOOTFILE
X				next
X			}
X	/^$/	{ next }
X	/^#/	{ next }
X		{
X			if ( PART == 0 && FIELD < 2 )
X		  	{
X				if ( FIELD == 0 ) BOOTPATH=$1
X				if ( FIELD == 1 ) BOOTFILE=$1
X				FIELD++
X			}
X		}
X		{
X			if ( PART == 1 )
X			{
X				HOST=$1
X				HA=$3
X				IP=$4
X				BF=$5
X				printf "%s:\\\n\t:tc=.default:\\\n\t:ha=0x%s:\\\n\t:ip=%s:\\\n\t:bf=%s:\n", HOST, HA, IP, BF
X			}
X		}' >> $NEWTAB
X
Xexit 0
END_OF_FILE
if test 3781 -ne `wc -c <'ConvOldTab.sh'`; then
    echo shar: \"'ConvOldTab.sh'\" unpacked with wrong size!
fi
chmod +x 'ConvOldTab.sh'
# end of 'ConvOldTab.sh'
fi
if test -f 'Installation' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Installation'\"
else
echo shar: Extracting \"'Installation'\" \(742 characters\)
sed "s/^X//" >'Installation' <<'END_OF_FILE'
X
XInstallation instructions for SunOS
X
XCompile the executable:
XFor SunOS 4.X:
X	make sunos4
XFor SunOS 5.X:  (Solaris)
X	make sunos5
X
XInstall the executables:
X
X	make install
X
XEdit (or create) the bootptab:
X(See bootptab.sample and bootptab.5 manual entry)
X	edit /etc/bootptab
X
XEdit /etc/services to add these two lines:
Xbootps		67/udp		bootp		# BOOTP Server
Xbootpc		68/udp				# BOOTP Client
X
XEdit /etc/inetd.conf to add the line:
Xbootp	dgram	udp	wait	root	/usr/etc/bootpd bootpd -i
X
XIf you compiled report.c with LOG_LOCAL2 (defined in the Makefile)
Xthen you may want to capture syslog messages from BOOTP by changing
Xyour syslog.conf file.  (See the sample syslog.conf file here).
XTest the change with:  logger -t test -p local2.info "message"
X
END_OF_FILE
if test 742 -ne `wc -c <'Installation'`; then
    echo shar: \"'Installation'\" unpacked with wrong size!
fi
# end of 'Installation'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1664 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Announce                   1	
X Changes                    2	
X ConvOldTab.sh              1	
X Installation               1	
X MANIFEST                   1	This shipping list
X Makefile                   1	
X Problems                   1	
X README                     1	
X ToDo                       1	
X bootp.h                    1	
X bootpd.8                   2	
X bootpd.c                   3	
X bootpd.h                   1	
X bootpef.8                  1	
X bootpef.c                  1	
X bootpgw.c                  3	
X bootptab.5                 2	
X bootptab.cmu               1	
X bootptab.mcs               1	
X bootptest.8                1	
X bootptest.c                2	
X bootptest.h                1	
X bptypes.h                  1	
X dot-indent.pro             1	
X dovend.c                   2	
X dovend.h                   1	
X dumptab.c                  2	
X getether.c                 2	
X getif.c                    1	
X getif.h                    1	
X hash.c                     2	
X hash.h                     1	
X hwaddr.c                   1	
X hwaddr.h                   1	
X lookup.c                   1	
X lookup.h                   1	
X patchlevel.h               1	
X print-bootp.c              3	
X readfile.c                 4	
X readfile.h                 1	
X report.c                   1	
X report.h                   1	
X strerror.c                 1	
X syslog.conf                1	
X syslog.h                   1	
X trygetea.c                 1	
X trygetif.c                 1	
X trylook.c                  1	
X tzone.c                    1	
X tzone.h                    1	
END_OF_FILE
if test 1664 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(4890 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#
X# Makefile for the BOOTP programs:
X#   bootpd	- BOOTP server daemon
X#   bootpef	- BOOTP extension file builder
X#   bootpgw	- BOOTP gateway daemon
X#   bootptest	- BOOTP tester (client)
X#
X
X# OPTion DEFinitions:
X# Remove the -DVEND_CMU if you don't wish to support the "CMU vendor format"
X# in addition to the RFC1048 format.  Leaving out DEBUG saves little.
XOPTDEFS= -DSYSLOG -DVEND_CMU -DDEBUG
X
X# Uncomment and edit this to choose the facility code used for syslog.
X# LOG_FACILITY= "-DLOG_BOOTP=LOG_LOCAL2"
X
X# SYStem DEFinitions:
X# Either uncomment some of the following, or do:
X#	"make sunos4"	(or "make sunos5", etc.)
X# SYSDEFS= -DSUNOS -DETC_ETHERS
X# SYSDEFS= -DSVR4
X# SYSLIBS= -lsocket -lnsl
X
X# Uncomment this if your system does not provide streror(3)
X# STRERROR=strerror.o
X
X# FILE DEFinitions:
X# The next few lines may be uncommented and changed to alter the default
X# filenames bootpd uses for its configuration and dump files.
X#CONFFILE= -DCONFIG_FILE=\"/usr/etc/bootptab\"
X#DUMPFILE= -DDUMPTAB_FILE=\"/usr/etc/bootpd.dump\"
X#FILEDEFS= $(CONFFILE) $(DUMPFILE)
X
X# MORE DEFinitions (whatever you might want to add)
X# One might define NDEBUG (to remove "assert()" checks).
XMOREDEFS=
X
XINSTALL=/usr/bin/install
XDESTDIR=
XBINDIR=/usr/etc
XMANDIR=/usr/local/man
X
XCFLAGS= $(OPTDEFS) $(SYSDEFS) $(FILEDEFS) $(MOREDEFS)
XPROGS= bootpd bootpef bootpgw bootptest
XTESTS= trylook trygetif trygetea
X
Xall: $(PROGS)
X
Xtests: $(TESTS)
X
Xsystem: install
X
Xinstall: $(PROGS)
X	-for f in $(PROGS) ;\
X	do \
X		$(INSTALL) -c -s $$f $(DESTDIR)$(BINDIR) ;\
X	done
X
XMAN5= bootptab.5
XMAN8= bootpd.8 bootpef.8 bootptest.8
Xinstall.man: $(MAN5) $(MAN8)
X	-for f in $(MAN5) ;\
X	do \
X		$(INSTALL) -c -m 644 $$f $(DESTDIR)$(MANDIR)/man5 ;\
X	done
X	-for f in $(MAN8) ;\
X	do \
X		$(INSTALL) -c -m 644 $$f $(DESTDIR)$(MANDIR)/man8 ;\
X	done
X
Xclean:
X	-rm -f core *.o
X	-rm -f $(PROGS) $(TESTS)
X
Xdistclean:
X	-rm -f *.BAK *.CKP *~ .emacs*
X
X#
X# Handy targets for individual systems:
X#
X
X# DEC/OSF1 on the Alpha
Xalpha:
X	$(MAKE) SYSDEFS="-DETC_ETHERS -Dint32=int -D_SOCKADDR_LEN" \
X		STRERROR=strerror.o
X
X# Control Data EP/IX 1.4.3 system, BSD 4.3 mode
Xepix143:
X	$(MAKE) CC="cc -systype bsd43" \
X		SYSDEFS="-Dconst= -D_SIZE_T -DNO_UNISTD -DUSE_BFUNCS" \
X		STRERROR=strerror.o
X
X# Control Data EP/IX 2.1.1 system, SVR4 mode
Xepix211:
X	$(MAKE) CC="cc -systype svr4" \
X		SYSDEFS="-DSVR4" \
X		SYSLIBS="-lsocket -lnsl"
X
X# Silicon Graphics IRIX  (no <sys/sockio.h>, so not SVR4)
Xirix:
X	$(MAKE) SYSDEFS="-DSYSV -DIRIX"
X
X# SunOS 4.X
Xsunos4:
X	$(MAKE) SYSDEFS="-DSUNOS -DETC_ETHERS" \
X		STRERROR=strerror.o
X
X# Solaris 2.X (i.e. SunOS 5.X)
Xsunos5:
X	$(MAKE) SYSDEFS="-DSVR4 -DETC_ETHERS" \
X		SYSLIBS="-lsocket -lnsl"
X
X# UNIX System V Rel. 4 (also: IRIX 5.X, others)
Xsvr4:
X	$(MAKE) SYSDEFS="-DSVR4" \
X		SYSLIBS="-lsocket -lnsl"
X
X#
X# How to build each program:
X#
X
XOBJ_D=	bootpd.o dovend.o readfile.o hash.o dumptab.o \
X	 lookup.o getif.o hwaddr.o tzone.o report.o $(STRERROR)
Xbootpd: $(OBJ_D)
X	$(CC) -o $@ $(OBJ_D) $(SYSLIBS)
X
XOBJ_EF=	bootpef.o dovend.o readfile.o hash.o dumptab.o \
X	 lookup.o hwaddr.o tzone.o report.o $(STRERROR)
Xbootpef: $(OBJ_EF)
X	$(CC) -o $@ $(OBJ_EF) $(SYSLIBS)
X
XOBJ_GW= bootpgw.o getif.o hwaddr.o report.o $(STRERROR)
Xbootpgw: $(OBJ_GW)
X	$(CC) -o $@ $(OBJ_GW) $(SYSLIBS)
X
XOBJ_TEST= bootptest.o print-bootp.o getif.o getether.o \
X	 report.o $(STRERROR)
Xbootptest: $(OBJ_TEST)
X	$(CC) -o $@ $(OBJ_TEST) $(SYSLIBS)
X
X# This is just for testing the lookup functions.
XTRYLOOK= trylook.o lookup.o report.o $(STRERROR)
Xtrylook : $(TRYLOOK)
X	$(CC) -o $@ $(TRYLOOK) $(SYSLIBS)
X
X# This is just for testing getif.
XTRYGETIF= trygetif.o getif.o report.o $(STRERROR)
Xtrygetif : $(TRYGETIF)
X	$(CC) -o $@ $(TRYGETIF) $(SYSLIBS)
X
X# This is just for testing getether.
XTRYGETEA= trygetea.o getether.o report.o $(STRERROR)
Xtrygetea : $(TRYGETEA)
X	$(CC) -o $@ $(TRYGETEA) $(SYSLIBS)
X
X# This rule just keeps the LOG_BOOTP define localized.
Xreport.o : report.c
X	$(CC) $(CFLAGS) $(LOG_FACILITY) -c $<
X
X# Punt SunOS -target noise
X.c.o:
X	$(CC) $(CFLAGS) -c $<
X
X#
X# Header file dependencies:
X#
X
Xbootpd.o  : bootp.h bptypes.h hash.h hwaddr.h bootpd.h dovend.h
Xbootpd.o  : readfile.h report.h tzone.h patchlevel.h getif.h
Xbootpef.o : bootp.h bptypes.h hash.h hwaddr.h bootpd.h dovend.h
Xbootpef.o : readfile.h report.h tzone.h patchlevel.h
Xbootpgw.o : bootp.h bptypes.h getif.h hwaddr.h report.h patchlevel.h
Xbootptest.o : bootp.h bptypes.h bootptest.h getif.h patchlevel.h
Xdovend.o : bootp.h bptypes.h bootpd.h hash.h hwaddr.h report.h dovend.h
Xdumptab.o : bootp.h bptypes.h hash.h hwaddr.h report.h patchlevel.h bootpd.h
Xgetif.o : getif.h report.h
Xhash.o : hash.h
Xhwaddr.o : bptypes.h hwaddr.h report.h
Xlookup.o : bootp.h bptypes.h lookup.h report.h
Xprint-bootp.o : bootp.h bptypes.h bootptest.h
Xreadfile.o : bootp.h bptypes.h hash.h hwaddr.h lookup.h readfile.h
Xreadfile.o : report.h tzone.h bootpd.h
Xreport.o : report.h
Xtzone.o : bptypes.h report.h tzone.h
END_OF_FILE
if test 4890 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'Problems' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Problems'\"
else
echo shar: Extracting \"'Problems'\" \(1800 characters\)
sed "s/^X//" >'Problems' <<'END_OF_FILE'
X
XCommon problems and ways to work around them:
X
XBootpd complains that it "can not get IP addr for HOSTNAME"
X
X	If the entry is a "dummy" (not a real host) used only for
X	reference by other entries, put '.' in front of the name.
X
X	If the entry is for a real client and the IP address for
X	the client can not be found using gethostbyname(), specify
X	the IP address for the client using numeric form.
X
XBootpd takes a long time to finish parsing the bootptab file:
X
X	Excessive startup time is usually caused by waiting for
X	timeouts on failed DNS lookup operations.  If this is the
X	problem, find the client names for which DNS lookup fails
X	and change the bootptab to specify the IP addresses for
X	those clients using numeric form.
X
X	When bootptab entries do not specify an ip address, bootpd
X	attempts to lookup the tagname as a host name to find the
X	IP address.  To suppress this default action, either make
X	the entry a "dummy" or specify its IP numeric address.
X
X	If your DNS lookups work but are just slow, consider either
X	running bootpd on the same machine as the DNS server or
X	running a caching DNS server on the host running bootpd.
X
XMy huge bootptab file causes startup time to be so long that clients
Xgive up waiting for a reply.
X
X	Truly huge bootptab files make "inetd" mode impractical.
X	Start bootpd in "standalone" mode when the server boots.
X
X	Another possibility is to run one bootpd on each network
X	segment so each one can have a smaller bootptab.  Only one
X	instance of bootpd may run on one server, so you would need
X	to use a different server for each network segment.
X
XMy bootp clients are given responses with a boot file name that is
Xnot a fully specified path.
X
X	Make sure the TFTP directory or home directory tags are set:
X	:td=/tftpboot:	(or)
X	:hd=/usr/boot:	(for example)
X
END_OF_FILE
if test 1800 -ne `wc -c <'Problems'`; then
    echo shar: \"'Problems'\" unpacked with wrong size!
fi
# end of 'Problems'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(5202 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X
XThis is an enhanced version of the CMU BOOTP server which was derived
Xfrom the original BOOTP server created by Bill Croft at Stanford.
XThis version merges all the enhancements and bug-fixes from the
XNetBSD, Columbia, and other versions.
X
XPlease direct questions, comments, and bug reports to the list:
X	<bootp@andrew.cmu.edu>
X
XYou can subscribe to this mailing list by sending mail to:
X	bootp-request@andrew.cmu.edu
X(The body of the message should contain: "Add <your-address>")
X
X[ From the NetBSD README file: ]
X
XBOOTPD is a useful adjunct to the nfs diskless boot EPROM code.
X
XThe alternatives for initiating a boot of a kernel across a network
Xare to use RARP protocol, or BOOTP protocol. BOOTP is more flexible;
Xit allows additional items of information to be returned to the
Xbooting client; it also supports booting across gateways.
X
X[ From the CMU README file: ]
X
XNotes:
X1) BOOTP was originally designed and implemented by Bill Croft at Stanford.
X   Much of the credit for the ideas and the code goes to him.  We've added
X   code to support the vendor specific area of the packet as specified in
X   RFC1048.  We've also improved the host lookup algorithm and added some
X   extra logging.
X
X2) The server now uses syslog to do logging.  Specifically it uses the 4.3bsd
X   version.  I've #ifdef'd all of these calls.  If you are running 4.2 you
X   should compile without the -DSYSLOG switch.
X
X3) You must update your /etc/services file to contain the following two lines:
X	bootps		67/udp		bootp		# BOOTP Server
X	bootpc		68/udp				# BOOTP Client
X
X4) Edit the bootptab.  It has some explanitory comments, and there
X   is a manual entry describing its format (bootptab.5)
X   If you have any questions, just let us know.
X
XConstruction:
X    [ See the file Installation which is more up-to-date. -gwr ]
X
X    Make sure all of the files exist first.  If anything is missing,
X    please contact either Walt Wimer or Drew Perkins by E-mail or phone.
X    Addresses and phone numbers are listed below.
X
X    Type 'make'.  The options at present are: -DSYSLOG which enables logging
X    code, -DDEBUG which enables table dumping via signals, and -DVEND_CMU
X    which enables the CMU extensions for CMU PC/IP.
X
X    Edit the bootptab.  The man page and the comments in the file should
X    explain how to go about doing so.  If you have any problems, let me know.
X
X    Type 'make install'.  This should put all of the files in the right place.
X
X    Edit your /etc/rc.local or /etc/inetd.conf file to start up bootpd upon
X    reboot.  The following is a sample /etc/inetd.conf entry:
X	# BOOTP server
X	bootps dgram udp wait root /usr/etc/bootpd bootpd -i
X
XCare and feeding:
X    If you change the interface cards on your host or add new hosts you will
X    need to update /etc/bootptab.  Just edit it as before.  Once you write
X    it back out, bootpd will notice that there is a new copy and will
X    reread it the next time it gets a request.
X
X    If your bootp clients don't get a response then several things might be
X    wrong.  Most often, the entry for that host is not in the database.
X    Check the hardware address and then check the entry and make sure
X    everything is right.  Other problems include the server machine crashing,
X    bad cables, and the like.  If your network is very congested you should
X    try making your bootp clients send additional requests before giving up.
X
X
XNovember 7, 1988
X
X
XWalter L. Wimer			Drew D. Perkins
Xww0n@andrew.cmu.edu		ddp@andrew.cmu.edu
X(412) 268-6252			(412) 268-8576
X
X4910 Forbes Ave
XPittsburgh, PA  15213
X
X[ Contents description by file: ]
X
XAnnounce*	Text of release announcements
XChanges  	Change history, reverse chronological
XInstallation	Instructions for building and installing
XMakefile*	for "make"
XREADME		This file
XToDo		Things not yet done
Xbootp.h		The protocol header file
Xbootpd.8	Manual page for bootpd, boopgw
Xbootpd.c	BOOTP server main module
Xbootpd.h	 header for above (and others)
Xbootpef.8	Manual page for bootpef
Xbootpef.c	BOOTP extension file compiler
Xbootpgw.c	BOOTP gateway main module
Xbootptab.5	A manual describing the bootptab format
Xbootptab.cmu	A sample database file for the server
Xbootptab.mcs	Another sample from <gwr@mc.com>
Xbootptest.8	Manual page for bootptest
Xbootptest.c	BOOTP test program (fake client)
Xbootptest.h	 header for above
Xdovend.c	Vendor Option builder (for bootpd, bootpef)
Xdovend.h	 header for above
Xdumptab.c	Implements debugging dump for bootpd
Xgetether.c	For bootptest (not used yet)
Xgetif.c		Get network interface info.
Xgetif.h		 header for above
Xhash.c		The hash table module
Xhash.h		 header for above
Xhwaddr.c	Hardware address support
Xhwaddr.h	 header for above
Xlookup.c	Internet Protocol address lookup
Xlookup.h	 header for above
Xpatchlevel.h	Holds version numbers
Xprint-bootp.c	Prints BOOTP packets (taken from BSD tcpdump)
Xreadfile.c	The configuration file-reading routines
Xreadfile.h	 header for above
Xreport.c	Does syslog-style messages
Xreport.h	 header for above
Xstrerror.c	Library errno-to-string (for systems lacking it)
Xsyslog.conf	Sample config file for syslogd(8)
Xsyslog.h	For systems that lack syslog(3)
Xtry*.c		Test programs (for debugging)
Xtzone.c		Get timezone offset
Xtzone.h		 header for above
END_OF_FILE
if test 5202 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'ToDo' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ToDo'\"
else
echo shar: Extracting \"'ToDo'\" \(1855 characters\)
sed "s/^X//" >'ToDo' <<'END_OF_FILE'
XToDo:							-*- text -*-
X
X----------------------------------------------------------------------
XMemory allocation locality:
X
XCurrently mallocs memory in a very haphazard manner.  As such, most of
Xthe program ends up core-resident all the time just to follow all the
Xstupid pointers around. . . .
X
X----------------------------------------------------------------------
XInput parser:
X
XThe reader implemented in readfile.c could use improvement.  Some sort
Xof "data-driven" parser should be used so the big switch statements
Xwould have only one case for each data type instead of one case for
Xevery recognized option symbol.  Then adding a new tag would involve
Xonly adding a new element to the data table describing known symbols.
XHopefully, this would shrink the code a bit too. -gwr
X
X----------------------------------------------------------------------
XSLIP Initialization via BOOTP:
X
XIn the function handle_request(), both in bootpd and bootpgw,
Xwe might want to add code like the following just before testing
Xthe client IP address field for zero. (bp->bp_ciaddr == 0)
X(David suggests we leave this out for now. -gwr)
X
X#if 1	/* XXX - Experimental */
X	/*
X	 * SLIP initialization support.
X	 *
X	 * If this packet came from a SLIP driver that does
X	 * automatic IP address initialization, then the socket
X	 * will have the IP address and the packet will
X	 * have zeros for both the IP and HW addresses.
X	 *
X	 * Thanks to David P. Maynard <dpm@depend.com>
X	 * for explaining how this works. -gwr
X	 */
X	if ((bp->bp_ciaddr.s_addr == 0) &&
X		(bp->bp_htype == 0))
X	{
X		/* Pretend the client knows its address.  It will soon. */
X		bp->bp_ciaddr = recv_addr.sin_addr;
X		if (debug)
X			report(LOG_INFO, "fixed blank request from IP addr %s",
X				   inet_ntoa(recv_addr.sin_addr));
X	}
X#endif
X
X----------------------------------------------------------------------
END_OF_FILE
if test 1855 -ne `wc -c <'ToDo'`; then
    echo shar: \"'ToDo'\" unpacked with wrong size!
fi
# end of 'ToDo'
fi
if test -f 'bootp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bootp.h'\"
else
echo shar: Extracting \"'bootp.h'\" \(5049 characters\)
sed "s/^X//" >'bootp.h' <<'END_OF_FILE'
X/************************************************************************
X          Copyright 1988, 1991 by Carnegie Mellon University
X
X                          All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted, provided
Xthat the above copyright notice appear in all copies and that both that
Xcopyright notice and this permission notice appear in supporting
Xdocumentation, and that the name of Carnegie Mellon University not be used
Xin advertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.
X
XCARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
XSOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
XIN NO EVENT SHALL CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
XDAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
XPROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
XACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X************************************************************************/
X
X/*
X * Bootstrap Protocol (BOOTP).  RFC951 and RFC1395.
X *
X * $Id: bootp.h $
X *
X *
X * This file specifies the "implementation-independent" BOOTP protocol
X * information which is common to both client and server.
X *
X */
X
X#include "bptypes.h"	/* for int32, u_int32 */
X
X#define BP_CHADDR_LEN	 16
X#define BP_SNAME_LEN	 64
X#define BP_FILE_LEN	128
X#define BP_VEND_LEN	 64
X#define BP_MINPKTSZ	300	/* to check sizeof(struct bootp) */
X
Xstruct bootp {
X    unsigned char    bp_op;			/* packet opcode type */
X    unsigned char    bp_htype;			/* hardware addr type */
X    unsigned char    bp_hlen;			/* hardware addr length */
X    unsigned char    bp_hops;			/* gateway hops */
X    unsigned int32   bp_xid;			/* transaction ID */
X    unsigned short   bp_secs;			/* seconds since boot began */
X    unsigned short   bp_flags;			/* RFC1532 broadcast, etc. */
X    struct in_addr   bp_ciaddr;			/* client IP address */
X    struct in_addr   bp_yiaddr;			/* 'your' IP address */
X    struct in_addr   bp_siaddr;			/* server IP address */
X    struct in_addr   bp_giaddr;			/* gateway IP address */
X    unsigned char    bp_chaddr[BP_CHADDR_LEN];	/* client hardware address */
X    char	     bp_sname[BP_SNAME_LEN];	/* server host name */
X    char	     bp_file[BP_FILE_LEN];	/* boot file name */
X    unsigned char    bp_vend[BP_VEND_LEN];	/* vendor-specific area */
X    /* note that bp_vend can be longer, extending to end of packet. */
X};
X
X/*
X * UDP port numbers, server and client.
X */
X#define	IPPORT_BOOTPS		67
X#define	IPPORT_BOOTPC		68
X
X#define BOOTREPLY		2
X#define BOOTREQUEST		1
X
X/*
X * Hardware types from Assigned Numbers RFC.
X */
X#define HTYPE_ETHERNET		  1
X#define HTYPE_EXP_ETHERNET	  2
X#define HTYPE_AX25		  3
X#define HTYPE_PRONET		  4
X#define HTYPE_CHAOS		  5
X#define HTYPE_IEEE802		  6
X#define HTYPE_ARCNET		  7
X
X/*
X * Vendor magic cookie (v_magic) for CMU
X */
X#define VM_CMU		"CMU"
X
X/*
X * Vendor magic cookie (v_magic) for RFC1048
X */
X#define VM_RFC1048	{ 99, 130, 83, 99 }
X
X
X
X/*
X * Tag values used to specify what information is being supplied in
X * the vendor (options) data area of the packet.
X */
X/* RFC 1048 */
X#define TAG_END			((unsigned char) 255)
X#define TAG_PAD			((unsigned char)   0)
X#define TAG_SUBNET_MASK		((unsigned char)   1)
X#define TAG_TIME_OFFSET		((unsigned char)   2)
X#define TAG_GATEWAY		((unsigned char)   3)
X#define TAG_TIME_SERVER		((unsigned char)   4)
X#define TAG_NAME_SERVER		((unsigned char)   5)
X#define TAG_DOMAIN_SERVER	((unsigned char)   6)
X#define TAG_LOG_SERVER		((unsigned char)   7)
X#define TAG_COOKIE_SERVER	((unsigned char)   8)
X#define TAG_LPR_SERVER		((unsigned char)   9)
X#define TAG_IMPRESS_SERVER	((unsigned char)  10)
X#define TAG_RLP_SERVER		((unsigned char)  11)
X#define TAG_HOST_NAME		((unsigned char)  12)
X#define TAG_BOOT_SIZE		((unsigned char)  13)
X/* RFC 1395 */
X#define TAG_DUMP_FILE		((unsigned char)  14)
X#define TAG_DOMAIN_NAME		((unsigned char)  15)
X#define TAG_SWAP_SERVER		((unsigned char)  16)
X#define TAG_ROOT_PATH		((unsigned char)  17)
X/* RFC 1497 */
X#define TAG_EXTEN_FILE		((unsigned char)  18)
X/* RFC 1533 */
X#define TAG_NIS_DOMAIN		((unsigned char)  40)
X#define TAG_NIS_SERVER		((unsigned char)  41)
X#define TAG_NTP_SERVER		((unsigned char)  42)
X/* DHCP maximum message size. */
X#define TAG_MAX_MSGSZ		((unsigned char)  57)
X
X/* XXX - Add new tags here */
X
X
X/*
X * "vendor" data permitted for CMU bootp clients.
X */
X
Xstruct cmu_vend {
X	char		v_magic[4];	/* magic number */
X	unsigned int32	v_flags;	/* flags/opcodes, etc. */
X	struct in_addr 	v_smask;	/* Subnet mask */
X	struct in_addr 	v_dgate;	/* Default gateway */
X	struct in_addr	v_dns1, v_dns2; /* Domain name servers */
X	struct in_addr	v_ins1, v_ins2; /* IEN-116 name servers */
X	struct in_addr	v_ts1, v_ts2;	/* Time servers */
X	int32		v_unused[6];	/* currently unused */
X};
X
X
X/* v_flags values */
X#define VF_SMASK	1	/* Subnet mask field contains valid data */
END_OF_FILE
if test 5049 -ne `wc -c <'bootp.h'`; then
    echo shar: \"'bootp.h'\" unpacked with wrong size!
fi
# end of 'bootp.h'
fi
if test -f 'bootpd.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bootpd.h'\"
else
echo shar: Extracting \"'bootpd.h'\" \(5311 characters\)
sed "s/^X//" >'bootpd.h' <<'END_OF_FILE'
X/************************************************************************
X          Copyright 1988, 1991 by Carnegie Mellon University
X
X                          All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted, provided
Xthat the above copyright notice appear in all copies and that both that
Xcopyright notice and this permission notice appear in supporting
Xdocumentation, and that the name of Carnegie Mellon University not be used
Xin advertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.
X
XCARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
XSOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
XIN NO EVENT SHALL CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
XDAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
XPROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
XACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X************************************************************************/
X
X
X/*
X * bootpd.h -- common header file for all the modules of the bootpd program.
X */
X
X#include "bptypes.h"
X#include "hash.h"
X#include "hwaddr.h"
X
X#ifndef TRUE
X#define TRUE	1
X#endif
X#ifndef FALSE
X#define FALSE	0
X#endif
X
X#ifndef PRIVATE
X#define PRIVATE static
X#endif
X
X#ifndef SIGUSR1
X#define SIGUSR1			 30	/* From 4.3 <signal.h> */
X#endif
X
X#define MAXSTRINGLEN		 80	/* Max string length */
X
X/* Local definitions: */
X#define MAX_MSG_SIZE		(3*512) /* Maximum packet size */
X
X
X/*
X * Return pointer to static string which gives full network error message.
X */
X#define get_network_errmsg get_errmsg
X
X
X/*
X * Data structure used to hold an arbitrary-lengthed list of IP addresses.
X * The list may be shared among multiple hosts by setting the linkcount
X * appropriately.
X */
X
Xstruct in_addr_list {
X    unsigned int	linkcount, addrcount;
X    struct in_addr	addr[1];		/* Dynamically extended */
X};
X
X
X/*
X * Data structures used to hold shared strings and shared binary data.
X * The linkcount must be set appropriately.
X */
X
Xstruct shared_string {
X    unsigned int	linkcount;
X    char		string[1];		/* Dynamically extended */
X};
X
Xstruct shared_bindata {
X    unsigned int	linkcount, length;
X    byte		data[1];		/* Dynamically extended */
X};
X
X
X/*
X * Flag structure which indicates which symbols have been defined for a
X * given host.  This information is used to determine which data should or
X * should not be reported in the bootp packet vendor info field.
X */
X
Xstruct flag {
X    unsigned	bootfile	:1,
X		bootserver	:1,
X		bootsize	:1,
X		bootsize_auto	:1,
X		cookie_server	:1,
X		domain_server	:1,
X		gateway		:1,
X		generic		:1,
X		haddr		:1,
X		homedir		:1,
X		htype		:1,
X		impress_server	:1,
X		iaddr		:1,
X		log_server	:1,
X		lpr_server	:1,
X		name_server	:1,
X		name_switch	:1,
X		rlp_server	:1,
X		send_name	:1,
X		subnet_mask	:1,
X		tftpdir		:1,
X		time_offset	:1,
X		time_server	:1,
X		dump_file	:1,
X		domain_name	:1,
X		swap_server	:1,
X		root_path	:1,
X		exten_file	:1,
X		reply_addr	:1,
X		nis_domain	:1,
X		nis_server	:1,
X		ntp_server	:1,
X		exec_file	:1,
X		msg_size	:1,
X		min_wait	:1,
X		/* XXX - Add new tags here */
X		vm_cookie	:1;
X};
X
X
X
X/*
X * The flags structure contains TRUE flags for all the fields which
X * are considered valid, regardless of whether they were explicitly
X * specified or indirectly inferred from another entry.
X *
X * The gateway and the various server fields all point to a shared list of
X * IP addresses.
X *
X * The hostname, home directory, and bootfile are all shared strings.
X *
X * The generic data field is a shared binary data structure.  It is used to
X * hold future RFC1048 vendor data until bootpd is updated to understand it.
X *
X * The vm_cookie field specifies the four-octet vendor magic cookie to use
X * if it is desired to always send the same response to a given host.
X *
X * Hopefully, the rest is self-explanatory.
X */
X
Xstruct host {
X    unsigned		    linkcount;		/* hash list inserts */
X    struct flag		    flags;		/* ALL valid fields */
X    struct in_addr_list	    *cookie_server,
X			    *domain_server,
X			    *gateway,
X			    *impress_server,
X			    *log_server,
X			    *lpr_server,
X			    *name_server,
X			    *rlp_server,
X			    *time_server,
X			    *nis_server,
X			    *ntp_server;
X    struct shared_string    *bootfile,
X			    *hostname,
X			    *domain_name,
X			    *homedir,
X			    *tftpdir,
X			    *dump_file,
X			    *exten_file,
X			    *root_path,
X			    *nis_domain,
X			    *exec_file;
X    struct shared_bindata   *generic;
X    byte		    vm_cookie[4],
X			    htype,  /* RFC826 says this should be 16-bits but
X				       RFC951 only allocates 1 byte. . . */
X			    haddr[MAXHADDRLEN];
X    int32		    time_offset;
X    unsigned int32	    bootsize,
X			    msg_size,
X			    min_wait;
X    struct in_addr	    bootserver,
X			    iaddr,
X			    swap_server,
X			    reply_addr,
X			    subnet_mask;
X    /* XXX - Add new tags here (or above as appropriate) */
X};
X
X
X
X/*
X * Variables shared among modules.
X */
X
Xextern int debug;
Xextern char *bootptab;
Xextern char *progname;
X
Xextern u_char vm_cmu[4];
Xextern u_char vm_rfc1048[4];
X
Xextern hash_tbl *hwhashtable;
Xextern hash_tbl *iphashtable;
Xextern hash_tbl *nmhashtable;
X
END_OF_FILE
if test 5311 -ne `wc -c <'bootpd.h'`; then
    echo shar: \"'bootpd.h'\" unpacked with wrong size!
fi
# end of 'bootpd.h'
fi
if test -f 'bootpef.8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bootpef.8'\"
else
echo shar: Extracting \"'bootpef.8'\" \(1179 characters\)
sed "s/^X//" >'bootpef.8' <<'END_OF_FILE'
X.\" bootpef.8
X.TH BOOTPEF 8 "4 Dec 1993" "MAINTENANCE COMMANDS"
X.SH NAME
Xbootpef \- BOOTP Extension File compiler
X.SH SYNOPSIS
X.LP
X.B bootpef
X.RI [ "-c chdir" ]
X.RI [ "-d debug-level" ]
X.RI [ "-f config-file" ]
X.RI [ client-name " [...]]"
X.SH DESCRIPTION
X.B bootpef
Xbuilds the
X.I Extension Path
Xfiles described by RFC 1497 (tag 18).
XIf any
X.I client-name
Xarguments are specified, then
X.I bootpef
Xcompiles the extension files for only those clients.
X.SH OPTIONS
X.TP
X.BI \-c \ chdir\-path
XSets the current directory used by
X.I bootpef
Xwhile creating extension files.  This is useful when the
Xextension file names are specified as relative pathnames, and
X.I bootpef
Xneeds to use the same current directory as the TFTP server
X(typically /tftpboot).
X.TP
X.BI \-d \ debug\-level
XSets the
X.I debug\-level
Xvariable that controls the amount of debugging messages generated.
XFor example, -d4 or -d 4 will set the debugging level to 4.
X.TP
X.BI \-f \ config\-file
XSet the name of the config file that specifies the option
Xdata to be sent to each client.
X.SH "SEE ALSO"
Xbootpd(8), tftpd(8)
X.SH REFERENCES
X.TP
XRFC951
XBOOTSTRAP PROTOCOL (BOOTP)
X.TP
XRFC1497
XBOOTP Vendor Information Extensions
X
X
END_OF_FILE
if test 1179 -ne `wc -c <'bootpef.8'`; then
    echo shar: \"'bootpef.8'\" unpacked with wrong size!
fi
# end of 'bootpef.8'
fi
if test -f 'bootpef.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bootpef.c'\"
else
echo shar: Extracting \"'bootpef.c'\" \(7256 characters\)
sed "s/^X//" >'bootpef.c' <<'END_OF_FILE'
X/************************************************************************
X          Copyright 1988, 1991 by Carnegie Mellon University
X
X                          All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted, provided
Xthat the above copyright notice appear in all copies and that both that
Xcopyright notice and this permission notice appear in supporting
Xdocumentation, and that the name of Carnegie Mellon University not be used
Xin advertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.
X
XCARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
XSOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
XIN NO EVENT SHALL CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
XDAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
XPROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
XACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X************************************************************************/
X
X#ifndef lint
Xstatic char rcsid[] = "$Id: bootpef.c $";
X#endif
X
X
X/*
X * bootpef - BOOTP Extension File generator
X *	Makes an "Extension File" for each host entry that
X *	defines an and Extension File. (See RFC1497, tag 18.)
X *
X * HISTORY
X *	See ./Changes
X *
X * BUGS
X *	See ./ToDo
X */
X
X
X
X#ifdef	__STDC__
X#include <stdarg.h>
X#else
X#include <varargs.h>
X#endif
X
X#include <sys/types.h>
X#include <sys/time.h>
X
X#include <netinet/in.h>
X#include <arpa/inet.h>			/* inet_ntoa */
X
X#ifndef	NO_UNISTD
X#include <unistd.h>
X#endif
X#include <stdlib.h>
X#include <stdio.h>
X#include <string.h>
X#include <errno.h>
X#include <ctype.h>
X#include <syslog.h>
X
X#ifndef	USE_BFUNCS
X#include <memory.h>
X/* Yes, memcpy is OK here (no overlapped copies). */
X#define bcopy(a,b,c)    memcpy(b,a,c)
X#define bzero(p,l)      memset(p,0,l)
X#define bcmp(a,b,c)     memcmp(a,b,c)
X#endif
X
X#include "bootp.h"
X#include "hash.h"
X#include "hwaddr.h"
X#include "bootpd.h"
X#include "dovend.h"
X#include "readfile.h"
X#include "report.h"
X#include "tzone.h"
X#include "patchlevel.h"
X
X#define	BUFFERSIZE   		0x4000
X
X#ifndef CONFIG_FILE
X#define CONFIG_FILE		"/etc/bootptab"
X#endif
X
X
X
X/*
X * Externals, forward declarations, and global variables
X */
X
X#ifdef	__STDC__
X#define P(args) args
X#else
X#define P(args) ()
X#endif
X
Xstatic void dovend_rfc1048 P((struct bootp *, struct host *, int32));
Xstatic void mktagfile P((struct host *));
Xstatic void usage P((void));
X
X#undef P
X
X
X/*
X * General
X */
X
Xchar *progname;
Xchar *chdir_path;
Xint debug = 0;					/* Debugging flag (level) */
Xbyte *buffer;
X
X/*
X * Globals below are associated with the bootp database file (bootptab).
X */
X
Xchar *bootptab = CONFIG_FILE;
X
X
X/*
X * Print "usage" message and exit
X */
Xstatic void
Xusage()
X{
X	fprintf(stderr,
X	   "usage:  $s [ -c chdir ] [-d level] [-f configfile] [host...]\n");
X	fprintf(stderr, "\t -c n\tset current directory\n");
X	fprintf(stderr, "\t -d n\tset debug level\n");
X	fprintf(stderr, "\t -f n\tconfig file name\n");
X	exit(1);
X}
X
X
X/*
X * Initialization such as command-line processing is done and then the
X * main server loop is started.
X */
Xvoid
Xmain(argc, argv)
X	int argc;
X	char **argv;
X{
X	struct host *hp;
X	char *stmp;
X	int n;
X
X	progname = strrchr(argv[0], '/');
X	if (progname) progname++;
X	else progname = argv[0];
X
X	/* Get work space for making tag 18 files. */
X	buffer = (byte *) malloc(BUFFERSIZE);
X	if (!buffer) {
X		report(LOG_ERR, "malloc failed");
X		exit(1);
X	}
X	/*
X	 * Set defaults that might be changed by option switches.
X	 */
X	stmp = NULL;
X
X	/*
X	 * Read switches.
X	 */
X	for (argc--, argv++; argc > 0; argc--, argv++) {
X		if (argv[0][0] != '-')
X			break;
X		switch (argv[0][1]) {
X
X		case 'c':				/* chdir_path */
X			if (argv[0][2]) {
X				stmp = &(argv[0][2]);
X			} else {
X				argc--;
X				argv++;
X				stmp = argv[0];
X			}
X			if (!stmp || (stmp[0] != '/')) {
X				fprintf(stderr,
X						"bootpd: invalid chdir specification\n");
X				break;
X			}
X			chdir_path = stmp;
X			break;
X
X		case 'd':				/* debug */
X			if (argv[0][2]) {
X				stmp = &(argv[0][2]);
X			} else if (argv[1] && argv[1][0] == '-') {
X				/*
X				 * Backwards-compatible behavior:
X				 * no parameter, so just increment the debug flag.
X				 */
X				debug++;
X				break;
X			} else {
X				argc--;
X				argv++;
X				stmp = argv[0];
X			}
X			if (!stmp || (sscanf(stmp, "%d", &n) != 1) || (n < 0)) {
X				fprintf(stderr,
X						"bootpd: invalid debug level\n");
X				break;
X			}
X			debug = n;
X			break;
X
X		case 'f':				/* config file */
X			if (argv[0][2]) {
X				stmp = &(argv[0][2]);
X			} else {
X				argc--;
X				argv++;
X				stmp = argv[0];
X			}
X			bootptab = stmp;
X			break;
X
X		default:
X			fprintf(stderr, "bootpd: unknown switch: -%c\n",
X					argv[0][1]);
X			usage();
X			break;
X		}
X	}
X
X	/* Get the timezone. */
X	tzone_init();
X
X	/* Allocate hash tables. */
X	rdtab_init();
X
X	/*
X	 * Read the bootptab file.
X	 */
X	readtab(1);					/* force read */
X
X	/* Set the cwd (i.e. to /tftpboot) */
X	if (chdir_path) {
X		if (chdir(chdir_path) < 0)
X			report(LOG_ERR, "%s: chdir failed", chdir_path);
X	}
X	/* If there are host names on the command line, do only those. */
X	if (argc > 0) {
X		unsigned int tlen, hashcode;
X
X		while (argc) {
X			tlen = strlen(argv[0]);
X			hashcode = hash_HashFunction((u_char *)argv[0], tlen);
X			hp = (struct host *) hash_Lookup(nmhashtable,
X											 hashcode,
X											 nmcmp, argv[0]);
X			if (!hp) {
X				printf("%s: no matching entry\n", argv[0]);
X				exit(1);
X			}
X			if (!hp->flags.exten_file) {
X				printf("%s: no extension file\n", argv[0]);
X				exit(1);
X			}
X			mktagfile(hp);
X			argv++;
X			argc--;
X		}
X		exit(0);
X	}
X	/* No host names specified.  Do them all. */
X	hp = (struct host *) hash_FirstEntry(nmhashtable);
X	while (hp != NULL) {
X		mktagfile(hp);
X		hp = (struct host *) hash_NextEntry(nmhashtable);
X	}
X}
X
X
X
X/*
X * Make a "TAG 18" file for this host.
X * (Insert the RFC1497 options.)
X */
X
Xstatic void
Xmktagfile(hp)
X	struct host *hp;
X{
X	FILE *fp;
X	int bytesleft, len;
X	byte *vp;
X	char *tmpstr;
X
X	if (!hp->flags.exten_file)
X		return;
X
X	vp = buffer;
X	bytesleft = BUFFERSIZE;
X	bcopy(vm_rfc1048, vp, 4);	/* Copy in the magic cookie */
X	vp += 4;
X	bytesleft -= 4;
X
X	/*
X	 * The "extension file" options are appended by the following
X	 * function (which is shared with bootpd.c).
X	 */
X	len = dovend_rfc1497(hp, vp, bytesleft);
X	vp += len;
X	bytesleft -= len;
X
X	if (bytesleft < 1) {
X		report(LOG_ERR, "%s: too much option data",
X			   hp->exten_file->string);
X		return;
X	}
X	*vp++ = TAG_END;
X	bytesleft--;
X
X	/* Write the buffer to the extension file. */
X	printf("Updating \"%s\"\n", hp->exten_file->string);
X	if ((fp = fopen(hp->exten_file->string, "w")) == NULL) {
X		report(LOG_ERR, "error opening \"%s\": %s",
X			   hp->exten_file->string, get_errmsg());
X		return;
X	}
X	len = vp - buffer;
X	if (len != fwrite(buffer, 1, len, fp)) {
X		report(LOG_ERR, "write failed on \"%s\" : %s",
X			   hp->exten_file->string, get_errmsg());
X	}
X	fclose(fp);
X
X} /* dovend_rfc1048 */
X
X/*
X * Local Variables:
X * tab-width: 4
X * c-indent-level: 4
X * c-argdecl-indent: 4
X * c-continued-statement-offset: 4
X * c-continued-brace-offset: -4
X * c-label-offset: -4
X * c-brace-offset: 0
X * End:
X */
END_OF_FILE
if test 7256 -ne `wc -c <'bootpef.c'`; then
    echo shar: \"'bootpef.c'\" unpacked with wrong size!
fi
# end of 'bootpef.c'
fi
if test -f 'bootptab.cmu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bootptab.cmu'\"
else
echo shar: Extracting \"'bootptab.cmu'\" \(4241 characters\)
sed "s/^X//" >'bootptab.cmu' <<'END_OF_FILE'
X# /etc/bootptab: database for bootp server (/etc/bootpd)
X# (I've hacked on this but can't test it... -gwr)
X
X# Blank lines and lines beginning with '#' are ignored.
X#
X# Legend:	(see bootptab.5)
X#	first field -- hostname (not indented)
X#	bf -- bootfile
X#	bs -- bootfile size in 512-octet blocks
X#	cs -- cookie servers
X#	df -- dump file name
X#	dn -- domain name
X#	ds -- domain name servers
X#	ef -- extension file
X#	gw -- gateways
X#	ha -- hardware address
X#	hd -- home directory for bootfiles
X#	hn -- host name set for client
X#	ht -- hardware type
X#	im -- impress servers
X#	ip -- host IP address
X#	lg -- log servers
X#	lp -- LPR servers
X#	ns -- IEN-116 name servers
X#	ra -- reply address
X#	rl -- resource location protocol servers
X#	rp -- root path
X#	sa -- boot server address
X#	sm -- subnet mask
X#	sw -- swap server
X#	tc -- template host (points to similar host entry)
X#	td -- TFTP directory
X#	to -- time offset (seconds)
X#	ts -- time servers
X#	vm -- vendor magic number
X#	Tn -- generic option tag n
X#
X# Be careful about including backslashes where they're needed.  Weird (bad)
X# things can happen when a backslash is omitted where one is intended.
X# Also, note that generic option data must be either a string or a
X# sequence of bytes where each byte is a two-digit hex value.
X
X# First, we define a global entry which specifies the stuff every host uses.
X# (Host name lookups are relative to the domain: andrew.cmu.edu)
X.default:\
X	:hn:dn=cmu.edu:\
X	:hd=/usr/boot:\
X	:ds=netserver, lancaster:\
X	:ns=pcs2, pcs1:\
X	:ts=pcs2, pcs1:\
X	:sm=255.255.0.0:\
X	:gw=gw.cs.cmu.edu:\
X	to=auto:
X
X
X# Next, we can define different master entries for each subnet. . .
X.subnet13	:sm=255.255.255.0:gw=128.2.13.1  :tc=.default:
X.subnet19	:sm=255.255.255.0:gw=128.2.19.1  :tc=.default:
X.subnet232	:sm=255.255.255.0:gw=128.2.232.1 :tc=.default:
X
X#
X# We should be able to use as many levels of indirection as desired.  Use
X# your imagination. . .
X#
X
X
X# Individual entries (could also have different servers for some/all of these
X# hosts, but we don't really use this feature at CMU):
X
Xcarnegie:tc=.subnet13:ht=ieee802:ha=7FF8100000AF:
Xbaldwin:tc=.subnet19:ha=0800200159C3:
Xwylie:tc=.subnet232:ha=00DD00CADF00:
Xarnold:tc=.subnet19:ha=0800200102AD:
Xbairdford:tc=.subnet19:ha=08002B02A2F9:
Xbakerstown:tc=.subnet19:ha=08002B0287C8:
Xbutlerjct:tc=.subnet232:ha=08002001560D:
Xgastonville:tc=.subnet232:ht=ieee802:ha=7FFF81000A47:
Xhahntown:tc=.subnet13:ht=ieee802:ha=7FFF81000434:
Xhickman:tc=.subnet19:ht=ieee802:ha=7FFF810001BA:
Xlowber:tc=.subnet13:ha=00DD00CAF000:
Xmtoliver:tc=.subnet19:ha=00DD00FE1600:
Xosborne:tc=.subnet232:ha=00DD00CAD600:
Xrusselton:tc=.subnet232:ha=080020017FC3:
Xthornburg:tc=.subnet13:ha=080020012A33:
X
X
X# Hmmm. . .  Let's throw in some whitespace for readability. . . .
X
Xandrew:		tc=.subnet19:ha=00DD00C88900:
Xbirdville:	tc=.subnet19:ha=00DD00FE2D00:
Xcoudersport:	tc=.subnet13:ha=00DD00CB1E00:
Xbridgeville:	tc=.subnet232:ha=080020011394:
Xfranklin:	tc=.subnet19:ha=08002B02A5D5:
Xhollidaysburg:	tc=.subnet19:ht=ieee802:ha=7FFF810002C8:
Xhonesdale:	tc=.subnet19:ha=08002B02F83F:
Xhuntingdon:	tc=.subnet19:ha=08002B02E410:
Xindiana:	tc=.subnet13:ha=08002B029BEC:
Xjimthorpe:	tc=.subnet232:ha=08002B02FBBA:
Xkittanning:	tc=.subnet232:ha=08002B0273FC:
Xlebanon:	tc=.subnet232:ha=08002B037F67:
Xlewisburg:	tc=.subnet19:ha=50005A1A0DE4:
Xmiddleburg:	tc=.subnet232:ha=00DD00FE1200:
Xaspinwall:	tc=.subnet13:ha=08002B03C163:
Xberlin:		tc=.subnet13:ha=00DD000A4400:
Xnorristown:	tc=.subnet13:ha=08002001455B:
Xpottsville:	tc=.subnet13:ha=00DD000A3700:
Xridgway:	tc=.subnet19:ha=08002B029425:
Xscranton:	tc=.subnet232:ha=0800200113A1:
Xchalfont:	tc=.subnet13:ha=08002001124B:
Xwashington:	tc=.subnet19:ha=00DD00656E00:
Xwellsboro:	tc=.subnet13:ha=00DD00CB1C00:
Xbb1:		tc=.subnet19:ha=00DD000A1F00:
Xadamstown:	tc=.subnet13:ha=08002B02D0E6:
Xbeta:		tc=.subnet19:ha=02070100B197:
Xcarbondale:	tc=.subnet232:ha=08002B022A73:
Xclairton:	tc=.subnet19:ha=080020010FD1:
Xegypt:		tc=.subnet13:ha=00DD00847B00:
Xfairchance:	tc=.subnet232:ha=00DD000AB100:
Xfairhope:	tc=.subnet232:ha=00DD00CB0800:
Xgaleton:	tc=.subnet232:ha=08002001138C:
Ximperial:	tc=.subnet232:ha=08002001130C:
Xkingston:	tc=.subnet232:ha=080020011382:
Xknox:		tc=.subnet232:ha=50005A1A0D2A:
Xlakecity:	tc=.subnet13:ha=080020011380:
END_OF_FILE
if test 4241 -ne `wc -c <'bootptab.cmu'`; then
    echo shar: \"'bootptab.cmu'\" unpacked with wrong size!
fi
# end of 'bootptab.cmu'
fi
if test -f 'bootptab.mcs' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bootptab.mcs'\"
else
echo shar: Extracting \"'bootptab.mcs'\" \(2546 characters\)
sed "s/^X//" >'bootptab.mcs' <<'END_OF_FILE'
X# /etc/bootptab: database for bootp server (/etc/bootpd)
X# Last update: gwr, Sun Dec 12 19:00:00 EDT 1993
X# Blank lines and lines beginning with '#' are ignored.
X#
X# Legend:	(see bootptab.5)
X#	first field -- hostname (not indented)
X#	bf -- bootfile
X#	bs -- bootfile size in 512-octet blocks
X#	cs -- cookie servers
X#	df -- dump file name
X#	dn -- domain name
X#	ds -- domain name servers
X#	ef -- extension file
X#	gw -- gateways
X#	ha -- hardware address
X#	hd -- home directory for bootfiles
X#	hn -- host name set for client
X#	ht -- hardware type
X#	im -- impress servers
X#	ip -- host IP address
X#	lg -- log servers
X#	lp -- LPR servers
X#	ns -- IEN-116 name servers
X#	ra -- reply address
X#	rl -- resource location protocol servers
X#	rp -- root path
X#	sa -- boot server address
X#	sm -- subnet mask
X#	sw -- swap server
X#	tc -- template host (points to similar host entry)
X#	td -- TFTP directory
X#	to -- time offset (seconds)
X#	ts -- time servers
X#	vm -- vendor magic number
X#	Tn -- generic option tag n
X#
X# Be careful about including backslashes where they're needed.  Weird (bad)
X# things can happen when a backslash is omitted where one is intended.
X# Also, note that generic option data must be either a string or a
X# sequence of bytes where each byte is a two-digit hex value.
X
X# First, we define a global entry which specifies the stuff every host uses.
X
X# If you leave "td" empty, run bootpd with the "-c /tftpboot" switch
X# so path names (boot files) will be interpreted relative to the same
X# directory as tftpd will use when opening files.
X.default:\
X	:hn:dn="mc.com":\
X	:td=/tftpboot:\
X	:ds=merlin, jericho:\
X	:to=auto:
X
X# Next, we can define different master entries for each subnet. . .
X
X.subnet16:\
X	:tc=.default:\
X	:sm=255.255.255.0:\
X	:gw=merlin:\
X	:sa=merlin:
X
X.subnet17:\
X	:tc=.default:\
X	:sm=255.255.255.0:\
X	:gw=merlin-gw:\
X	:sa=merlin-gw:
X
X#
X# We should be able to use as many levels of indirection as desired.  Use
X# your imagination. . .
X#
X
X# Individual entries (could also have different servers for some/all of these
X# hosts, but we don't really use this feature at CMU):
X
X# Emulex terminal server
Xemulex:	tc=.subnet16:ha=00.00.C9.00.42.E0:bf=P4KTL0E:
X
X# Lantronix eps1
Xeps1:	tc=.subnet16:ha=00.80.A3.04.1D.78:
X
X# Tadpole 885 board.
Xtp885:  tc=.subnet17:ha=08.00.4C.00.2F.74:bf=tp885sys2.cfe:
X
X# MVME147 VxWorks board.
X#mvme147:tc=.subnet17:ha=08.00.3e.20.da.47:bf=mv147vxw.st:
X
X# These are just for testing
X
Xwalnut:tc=.subnet16:ha=walnut:
Xbanana:tc=.subnet17:ha=banana:
Xthor:tc=.subnet17:ha=thor:
Xclassic:tc=.subnet16:ha=classic:
END_OF_FILE
if test 2546 -ne `wc -c <'bootptab.mcs'`; then
    echo shar: \"'bootptab.mcs'\" unpacked with wrong size!
fi
# end of 'bootptab.mcs'
fi
if test -f 'bootptest.8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bootptest.8'\"
else
echo shar: Extracting \"'bootptest.8'\" \(1703 characters\)
sed "s/^X//" >'bootptest.8' <<'END_OF_FILE'
X.\" bootptest.8
X.TH BOOTPTEST 8 "10 June 1993" "MAINTENANCE COMMANDS"
X.SH NAME
Xbootptest \- send BOOTP queries and print responses
X.SH SYNOPSIS
X.LP
X.B bootptest
X[
X.B \-f
X.I bootfile
X]
X[
X.B \-h
X]
X[
X.B \-m
X.I magic_number
X]
X.I server\-name
X.RI [ template-file ]
X.SH DESCRIPTION
X.B bootptest
Xsends BOOTP requests to the host specified as
X.I server\-name
Xat one\-second intervals until either a response is received,
Xor until ten requests have gone unanswered.
XAfter a response is received,
X.B bootptest
Xwill wait one more second listening for additional responses.
X.SH OPTIONS
X.TP
X.B \-f
X.I bootfile
XFill in the boot file field of the request with
X.IR bootfile .
X.TP
X.B \-h
XUse the hardware (Ethernet) address to identify the client.
XBy default, the IP address is copied into the request
Xindicating that this client already knows its IP address.
X.TP
X.B \-m
X.I magic_number
XInitialize the first word of the vendor options field with
X.IR magic_number .
X.LP
XA
X.I template-file
Xmay be specified, in which case
X.B bootptest
Xuses the (binary) contents of this file to initialize the
X.I options
Xarea of the request packet.
X.SH CREDITS
X.LP
XThe bootptest program is a combination of original and derived works.
XThe main program module (bootptest.c) is original work by
XGordon W. Ross <gwr@mc.com>.
XThe packet printing module (print-bootp.c) is a slightly modified
Xversion of a file from the BSD tcpdump program.
X.LP
XThis program includes software developed by the University of
XCalifornia, Lawrence Berkeley Laboratory and its contributors.
X(See the copyright notice in print-bootp.c)
X.SH "SEE ALSO"
X.LP
Xbootpd(8)
X.SH REFERENCES
X.TP
XRFC951
XBOOTSTRAP PROTOCOL (BOOTP)
X.TP
XRFC1048
XBOOTP Vendor Information Extensions
END_OF_FILE
if test 1703 -ne `wc -c <'bootptest.8'`; then
    echo shar: \"'bootptest.8'\" unpacked with wrong size!
fi
# end of 'bootptest.8'
fi
if test -f 'bootptest.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bootptest.h'\"
else
echo shar: Extracting \"'bootptest.h'\" \(666 characters\)
sed "s/^X//" >'bootptest.h' <<'END_OF_FILE'
X/* bootptest.h */
X/*
X * Hacks for sharing print-bootp.c between tcpdump and bootptest.
X */
X#define ESRC(p) (p)
X#define EDST(p) (p)
X
X#ifndef	USE_BFUNCS
X/* Use mem/str functions */
X/* There are no overlapped copies, so memcpy is OK. */
X#define bcopy(a,b,c)    memcpy(b,a,c)
X#define bzero(p,l)      memset(p,0,l)
X#define bcmp(a,b,c)     memcmp(a,b,c)
X#endif
X
Xextern int vflag; /* verbose flag */
X
X/* global pointers to beginning and end of current packet (during printing) */
Xextern unsigned char *packetp;
Xextern unsigned char *snapend;
X
X#ifdef	__STDC__
X#define P(args) args
X#else
X#define P(args) ()
X#endif
X
Xextern char *ipaddr_string P((struct in_addr *));
X
X#undef P
END_OF_FILE
if test 666 -ne `wc -c <'bootptest.h'`; then
    echo shar: \"'bootptest.h'\" unpacked with wrong size!
fi
# end of 'bootptest.h'
fi
if test -f 'bptypes.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bptypes.h'\"
else
echo shar: Extracting \"'bptypes.h'\" \(303 characters\)
sed "s/^X//" >'bptypes.h' <<'END_OF_FILE'
X/* bptypes.h */
X
X#ifndef	BPTYPES_H
X#define	BPTYPES_H
X
X/*
X * 32 bit integers are different types on various architectures
X */
X
X#ifndef	int32
X#define int32 long
X#endif
Xtypedef unsigned int32 u_int32;
X
X/*
X * Nice typedefs. . .
X */
X
Xtypedef int boolean;
Xtypedef unsigned char byte;
X
X
X#endif	/* BPTYPES_H */
END_OF_FILE
if test 303 -ne `wc -c <'bptypes.h'`; then
    echo shar: \"'bptypes.h'\" unpacked with wrong size!
fi
# end of 'bptypes.h'
fi
if test -f 'dot-indent.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dot-indent.pro'\"
else
echo shar: Extracting \"'dot-indent.pro'\" \(144 characters\)
sed "s/^X//" >'dot-indent.pro' <<'END_OF_FILE'
X -nbad -nbap -nbbb -nbc -br -bli4 -c33 -cd33  -cdb  -ce -ci4
X -cli0 -cp1 -d0 -di0 -nfc1 -nfca -i4 -ip4 -l75 -lp -npcs
X -psl -sc -nsob -nss -ts4
END_OF_FILE
if test 144 -ne `wc -c <'dot-indent.pro'`; then
    echo shar: \"'dot-indent.pro'\" unpacked with wrong size!
fi
# end of 'dot-indent.pro'
fi
if test -f 'dovend.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dovend.h'\"
else
echo shar: Extracting \"'dovend.h'\" \(289 characters\)
sed "s/^X//" >'dovend.h' <<'END_OF_FILE'
X/* dovend.h */
X
X#ifdef	__STDC__
X#define P(args) args
X#else
X#define P(args) ()
X#endif
X
Xextern int dovend_rfc1497 P((struct host *hp, u_char *buf, int len));
Xextern int insert_ip P((int, struct in_addr_list *, u_char **, int *));
Xextern void insert_u_long P((u_int32, u_char **));
X
X#undef P
END_OF_FILE
if test 289 -ne `wc -c <'dovend.h'`; then
    echo shar: \"'dovend.h'\" unpacked with wrong size!
fi
# end of 'dovend.h'
fi
if test -f 'getif.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getif.c'\"
else
echo shar: Extracting \"'getif.c'\" \(3087 characters\)
sed "s/^X//" >'getif.c' <<'END_OF_FILE'
X/*
X * getif.c : get an interface structure
X */
X
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/ioctl.h>
X
X#if defined(SUNOS) || defined(SVR4)
X#include <sys/sockio.h>
X#endif
X#ifdef	SVR4
X#include <sys/stropts.h>
X#endif
X
X#include <net/if.h>				/* for struct ifreq */
X#include <netinet/in.h>
X
X#ifndef	NO_UNISTD
X#include <unistd.h>
X#endif
X#include <syslog.h>
X#include <errno.h>
X#include <assert.h>
X
X#include "getif.h"
X#include "report.h"
X
X#ifdef	__bsdi__
X#define BSD 43
X#endif
X
Xstatic struct ifreq ifreq[10];	/* Holds interface configuration */
Xstatic struct ifconf ifconf;	/* points to ifreq */
X
Xstatic int nmatch();
X
X/* Return a pointer to the interface struct for the passed address. */
Xstruct ifreq *
Xgetif(s, addrp)
X	int s;						/* socket file descriptor */
X	struct in_addr *addrp;		/* destination address on interface */
X{
X	int maxmatch;
X	int len, m, incr;
X	struct ifreq *ifrq, *ifrmax;
X	struct sockaddr_in *sip;
X	char *p;
X
X	/* If no address was supplied, just return NULL. */
X	if (!addrp)
X		return (struct ifreq *) 0;
X
X	/* Get the interface config if not done already. */
X	if (ifconf.ifc_len == 0) {
X#ifdef	SVR4
X		/*
X		 * SysVr4 returns garbage if you do this the obvious way!
X		 * This one took a while to figure out... -gwr
X		 */
X		struct strioctl ioc;
X		ioc.ic_cmd = SIOCGIFCONF;
X		ioc.ic_timout = 0;
X		ioc.ic_len = sizeof(ifreq);
X		ioc.ic_dp = (char *) ifreq;
X		m = ioctl(s, I_STR, (char *) &ioc);
X		ifconf.ifc_len = ioc.ic_len;
X		ifconf.ifc_req = ifreq;
X#else	/* SVR4 */
X		ifconf.ifc_len = sizeof(ifreq);
X		ifconf.ifc_req = ifreq;
X		m = ioctl(s, SIOCGIFCONF, (caddr_t) & ifconf);
X#endif	/* SVR4 */
X		if ((m < 0) || (ifconf.ifc_len <= 0)) {
X			report(LOG_ERR, "ioctl SIOCGIFCONF");
X			return (struct ifreq *) 0;
X		}
X	}
X	maxmatch = 7;				/* this many bits or less... */
X	ifrmax = (struct ifreq *) 0;/* ... is not a valid match  */
X	p = (char *) ifreq;
X	len = ifconf.ifc_len;
X	while (len > 0) {
X		ifrq = (struct ifreq *) p;
X		sip = (struct sockaddr_in *) &ifrq->ifr_addr;
X		m = nmatch(addrp, &(sip->sin_addr));
X		if (m > maxmatch) {
X			maxmatch = m;
X			ifrmax = ifrq;
X		}
X		/* XXX - Could this be just #ifndef IFNAMSIZ instead? -gwr */
X#if (BSD - 0) < 43
X		/* BSD not defined or earlier than 4.3 */
X		incr = sizeof(*ifrq);
X#else /* NetBSD */
X		incr = ifrq->ifr_addr.sa_len + IFNAMSIZ;
X#endif /* NetBSD */
X
X		p += incr;
X		len -= incr;
X	}
X
X	return ifrmax;
X}
X
X/*
X * Return the number of leading bits matching in the
X * internet addresses supplied.
X */
Xstatic int
Xnmatch(ca, cb)
X	u_char *ca, *cb;			/* ptrs to IP address, network order */
X{
X	u_int m = 0;				/* count of matching bits */
X	u_int n = 4;				/* bytes left, then bitmask */
X
X	/* Count matching bytes. */
X	while (n && (*ca == *cb)) {
X		ca++;
X		cb++;
X		m += 8;
X		n--;
X	}
X	/* Now count matching bits. */
X	if (n) {
X		n = 0x80;
X		while (n && ((*ca & n) == (*cb & n))) {
X			m++;
X			n >>= 1;
X		}
X	}
X	return (m);
X}
X
X/*
X * Local Variables:
X * tab-width: 4
X * c-indent-level: 4
X * c-argdecl-indent: 4
X * c-continued-statement-offset: 4
X * c-continued-brace-offset: -4
X * c-label-offset: -4
X * c-brace-offset: 0
X * End:
X */
END_OF_FILE
if test 3087 -ne `wc -c <'getif.c'`; then
    echo shar: \"'getif.c'\" unpacked with wrong size!
fi
# end of 'getif.c'
fi
if test -f 'getif.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getif.h'\"
else
echo shar: Extracting \"'getif.h'\" \(125 characters\)
sed "s/^X//" >'getif.h' <<'END_OF_FILE'
X/* getif.h */
X
X#ifdef	__STDC__
Xextern struct ifreq *getif(int, struct in_addr *);
X#else
Xextern struct ifreq *getif();
X#endif
END_OF_FILE
if test 125 -ne `wc -c <'getif.h'`; then
    echo shar: \"'getif.h'\" unpacked with wrong size!
fi
# end of 'getif.h'
fi
if test -f 'hash.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hash.h'\"
else
echo shar: Extracting \"'hash.h'\" \(4998 characters\)
sed "s/^X//" >'hash.h' <<'END_OF_FILE'
X#ifndef	HASH_H
X#define HASH_H
X/* hash.h */
X/************************************************************************
X          Copyright 1988, 1991 by Carnegie Mellon University
X
X                          All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted, provided
Xthat the above copyright notice appear in all copies and that both that
Xcopyright notice and this permission notice appear in supporting
Xdocumentation, and that the name of Carnegie Mellon University not be used
Xin advertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.
X
XCARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
XSOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
XIN NO EVENT SHALL CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
XDAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
XPROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
XACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X************************************************************************/
X
X/*
X * Generalized hash table ADT
X *
X * Provides multiple, dynamically-allocated, variable-sized hash tables on
X * various data and keys.
X *
X * This package attempts to follow some of the coding conventions suggested
X * by Bob Sidebotham and the AFS Clean Code Committee.
X */
X
X
X/*
X * The user must supply the following:
X *
X *	1.  A comparison function which is declared as:
X *
X *		int compare(data1, data2)
X *		hash_datum *data1, *data2;
X *
X *	    This function must compare the desired fields of data1 and
X *	    data2 and return TRUE (1) if the data should be considered
X *	    equivalent (i.e. have the same key value) or FALSE (0)
X *	    otherwise.  This function is called through a pointer passed to
X *	    the various hashtable functions (thus pointers to different
X *	    functions may be passed to effect different tests on different
X *	    hash tables).
X *
X *	    Internally, all the functions of this package always call the
X *	    compare function with the "key" parameter as the first parameter,
X *	    and a full data element as the second parameter.  Thus, the key
X *	    and element arguments to functions such as hash_Lookup() may
X *	    actually be of different types and the programmer may provide a
X *	    compare function which compares the two different object types
X *	    as desired.
X *
X *	    Example:
X *
X *		int compare(key, element)
X *		char *key;
X *		struct some_complex_structure *element;
X *		{
X *		    return !strcmp(key, element->name);
X *		}
X *
X *		key = "John C. Doe"
X *		element = &some_complex_structure
X *		hash_Lookup(table, hashcode, compare, key);
X *
X *	2.  A hash function yielding an unsigned integer value to be used
X *	    as the hashcode (index into the hashtable).  Thus, the user
X *	    may hash on whatever data is desired and may use several
X *	    different hash functions for various different hash tables.
X *	    The actual hash table index will be the passed hashcode modulo
X *	    the hash table size.
X *
X *	    A generalized hash function, hash_HashFunction(), is included
X *	    with this package to make things a little easier.  It is not
X *	    guarenteed to use the best hash algorithm in existence. . . .
X */
X
X
X
X/*
X * Various hash table definitions
X */
X
X
X/*
X * Define "hash_datum" as a universal data type
X */
X#ifdef __STDC__
Xtypedef void hash_datum;
X#else
Xtypedef char hash_datum;
X#endif
X
Xtypedef struct hash_memberstruct  hash_member;
Xtypedef struct hash_tblstruct     hash_tbl;
Xtypedef struct hash_tblstruct_hdr hash_tblhdr;
X
Xstruct hash_memberstruct {
X    hash_member *next;
X    hash_datum  *data;
X};
X
Xstruct hash_tblstruct_hdr {
X    unsigned	size, bucketnum;
X    hash_member *member;
X};
X
Xstruct hash_tblstruct {
X    unsigned	size, bucketnum;
X    hash_member *member;		/* Used for linear dump */
X    hash_member	*table[1];		/* Dynamically extended */
X};
X
X/* ANSI function prototypes or empty arg list? */
X#ifdef	__STDC__
X#define P(args) args
X#else
X#define P(args) ()
X#endif
X
Xtypedef int (*hash_cmpfp) P((hash_datum *, hash_datum *));
Xtypedef void (*hash_freefp) P((hash_datum *));
X
Xextern hash_tbl	  *hash_Init P((u_int tablesize));
X
Xextern void	   hash_Reset P((hash_tbl *tbl, hash_freefp));
X
Xextern unsigned	   hash_HashFunction P((u_char *str, u_int len));
X
Xextern int	   hash_Exists P((hash_tbl *, u_int code,
X				  hash_cmpfp, hash_datum *key));
X
Xextern int	   hash_Insert P((hash_tbl *, u_int code,
X				  hash_cmpfp, hash_datum *key,
X				  hash_datum *element));
X
Xextern int	   hash_Delete P((hash_tbl *, u_int code,
X				  hash_cmpfp, hash_datum *key,
X				  hash_freefp));
X
Xextern hash_datum *hash_Lookup P((hash_tbl *, u_int code,
X				  hash_cmpfp, hash_datum *key));
X
Xextern hash_datum *hash_FirstEntry P((hash_tbl *));
X
Xextern hash_datum *hash_NextEntry P((hash_tbl *));
X
X#undef P
X
X#endif	/* HASH_H */
END_OF_FILE
if test 4998 -ne `wc -c <'hash.h'`; then
    echo shar: \"'hash.h'\" unpacked with wrong size!
fi
# end of 'hash.h'
fi
if test -f 'hwaddr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hwaddr.c'\"
else
echo shar: Extracting \"'hwaddr.c'\" \(7249 characters\)
sed "s/^X//" >'hwaddr.c' <<'END_OF_FILE'
X/*
X * hwaddr.c - routines that deal with hardware addresses.
X * (i.e. Ethernet)
X */
X
X#include <sys/types.h>
X#include <sys/param.h>
X#include <sys/socket.h>
X#include <sys/ioctl.h>
X
X#if defined(SUNOS) || defined(SVR4)
X#include <sys/sockio.h>
X#endif
X#ifdef	SVR4
X#include <sys/stream.h>
X#include <stropts.h>
X#include <fcntl.h>
X#endif
X
X#include <net/if_arp.h>
X#include <netinet/in.h>
X#include <stdio.h>
X#ifndef	NO_UNISTD
X#include <unistd.h>
X#endif
X#include <syslog.h>
X
X#ifndef USE_BFUNCS
X/* Yes, memcpy is OK here (no overlapped copies). */
X#include <memory.h>
X#define bcopy(a,b,c)    memcpy(b,a,c)
X#define bzero(p,l)      memset(p,0,l)
X#define bcmp(a,b,c)     memcmp(a,b,c)
X#endif
X
X#include "bptypes.h"
X#include "hwaddr.h"
X#include "report.h"
X
Xextern int debug;
X
X/*
X * Hardware address lengths (in bytes) and network name based on hardware
X * type code.  List in order specified by Assigned Numbers RFC; Array index
X * is hardware type code.  Entries marked as zero are unknown to the author
X * at this time.  .  .  .
X */
X
Xstruct hwinfo hwinfolist[] =
X{
X	{0, "Reserved"},			/* Type 0:  Reserved (don't use this)   */
X	{6, "Ethernet"},			/* Type 1:  10Mb Ethernet (48 bits)	*/
X	{1, "3Mb Ethernet"},		/* Type 2:   3Mb Ethernet (8 bits)	*/
X	{0, "AX.25"},				/* Type 3:  Amateur Radio AX.25		*/
X	{1, "ProNET"},				/* Type 4:  Proteon ProNET Token Ring   */
X	{0, "Chaos"},				/* Type 5:  Chaos			*/
X	{6, "IEEE 802"},			/* Type 6:  IEEE 802 Networks		*/
X	{0, "ARCNET"}				/* Type 7:  ARCNET			*/
X};
Xint hwinfocnt = sizeof(hwinfolist) / sizeof(hwinfolist[0]);
X
X
X/*
X * Setup the arp cache so that IP address 'ia' will be temporarily
X * bound to hardware address 'ha' of length 'len'.
X */
Xvoid
Xsetarp(s, ia, ha, len)
X	int s;						/* socket fd */
X	struct in_addr *ia;
X	u_char *ha;
X	int len;
X{
X#ifdef	SIOCSARP
X	struct arpreq arpreq;		/* Arp request ioctl block */
X	struct sockaddr_in *si;
X#ifdef	SVR4
X	int fd;
X	struct strioctl iocb;
X#endif	/* SVR4 */
X
X	bzero((caddr_t) & arpreq, sizeof(arpreq));
X	arpreq.arp_flags = ATF_INUSE | ATF_COM;
X
X	/* Set up the protocol address. */
X	arpreq.arp_pa.sa_family = AF_INET;
X	si = (struct sockaddr_in *) &arpreq.arp_pa;
X	si->sin_addr = *ia;
X
X	/* Set up the hardware address. */
X	bcopy(ha, arpreq.arp_ha.sa_data, len);
X
X#ifdef	SVR4
X	/*
X	 * And now the stuff for System V Rel 4.x which does not
X	 * appear to allow SIOCxxx ioctls on a socket descriptor.
X	 * Thanks to several people: (all sent the same fix)
X	 *   Barney Wolff <barney@databus.com>,
X	 *   bear@upsys.se (Bj|rn Sj|holm),
X	 *   Michael Kuschke <Michael.Kuschke@Materna.DE>,
X	 */
X	if ((fd=open("/dev/arp", O_RDWR)) < 0) {
X	    report(LOG_ERR, "open /dev/arp: %s\n", get_errmsg());
X	}
X	iocb.ic_cmd = SIOCSARP;
X	iocb.ic_timout = 0;
X	iocb.ic_dp = (char *)&arpreq;
X	iocb.ic_len = sizeof(arpreq);
X	if (ioctl(fd, I_STR, (caddr_t)&iocb) < 0) {
X	    report(LOG_ERR, "ioctl I_STR: %s\n", get_errmsg());
X	}
X	close (fd);
X
X#else	/* SVR4 */
X	/*
X	 * On SunOS, the ioctl sometimes returns ENXIO, and it
X	 * appears to happen when the ARP cache entry you tried
X	 * to add is already in the cache.  (Sigh...)
X	 * XXX - Should this error simply be ignored? -gwr
X	 */
X	if (ioctl(s, SIOCSARP, (caddr_t) & arpreq) < 0) {
X		report(LOG_ERR, "ioctl SIOCSARP: %s", get_errmsg());
X	}
X#endif	/* SVR4 */
X#else	/* SIOCSARP */
X	/*
X	 * Oh well, SIOCSARP is not defined.  Just run arp(8).
X	 * XXX - Gag!
X	 */
X	char buf[256];
X	int status;
X
X	sprintf(buf, "arp -s %s %s temp",
X			inet_ntoa(*ia), haddrtoa(ha, len));
X	if (debug > 2)
X		report(LOG_INFO, buf);
X	status = system(buf);
X	if (status)
X		report(LOG_ERR, "arp failed, exit code=0x%x", status);
X	return;
X#endif	/* SIOCSARP */
X}
X
X
X/*
X * Convert a hardware address to an ASCII string.
X */
Xchar *
Xhaddrtoa(haddr, hlen)
X	u_char *haddr;
X	int hlen;
X{
X	static char haddrbuf[3 * MAXHADDRLEN + 1];
X	char *bufptr;
X
X	if (hlen > MAXHADDRLEN)
X		hlen = MAXHADDRLEN;
X
X	bufptr = haddrbuf;
X	while (hlen > 0) {
X		sprintf(bufptr, "%02X:", (unsigned) (*haddr++ & 0xFF));
X		bufptr += 3;
X		hlen--;
X	}
X	bufptr[-1] = 0;
X	return (haddrbuf);
X}
X
X
X/*
X * haddr_conv802()
X * --------------
X *
X * Converts a backwards address to a canonical address and a canonical address
X * to a backwards address.
X *
X * INPUTS:
X *  adr_in - pointer to six byte string to convert (unsigned char *)
X *  addr_len - how many bytes to convert
X *
X * OUTPUTS:
X *  addr_out - The string is updated to contain the converted address.
X *
X * CALLER:
X *  many
X *
X * DATA:
X *  Uses conv802table to bit-reverse the address bytes.
X */
X
Xstatic u_char conv802table[256] =
X{
X	/* 0x00 */ 0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
X	/* 0x08 */ 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
X	/* 0x10 */ 0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
X	/* 0x18 */ 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
X	/* 0x20 */ 0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
X	/* 0x28 */ 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
X	/* 0x30 */ 0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
X	/* 0x38 */ 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
X	/* 0x40 */ 0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
X	/* 0x48 */ 0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
X	/* 0x50 */ 0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
X	/* 0x58 */ 0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
X	/* 0x60 */ 0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
X	/* 0x68 */ 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
X	/* 0x70 */ 0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
X	/* 0x78 */ 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
X	/* 0x80 */ 0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
X	/* 0x88 */ 0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
X	/* 0x90 */ 0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
X	/* 0x98 */ 0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
X	/* 0xA0 */ 0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
X	/* 0xA8 */ 0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
X	/* 0xB0 */ 0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
X	/* 0xB8 */ 0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
X	/* 0xC0 */ 0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
X	/* 0xC8 */ 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
X	/* 0xD0 */ 0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
X	/* 0xD8 */ 0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
X	/* 0xE0 */ 0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
X	/* 0xE8 */ 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
X	/* 0xF0 */ 0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
X	/* 0xF8 */ 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF,
X};
X
Xvoid
Xhaddr_conv802(addr_in, addr_out, len)
X	register u_char *addr_in, *addr_out;
X	int len;
X{
X	u_char *lim;
X
X	lim = addr_out + len;
X	while (addr_out < lim)
X		*addr_out++ = conv802table[*addr_in++];
X}
X
X#if 0
X/*
X * For the record, here is a program to generate the
X * bit-reverse table above.
X */
Xstatic int
Xbitrev(n)
X	int n;
X{
X	int i, r;
X
X	r = 0;
X	for (i = 0; i < 8; i++) {
X		r <<= 1;
X		r |= (n & 1);
X		n >>= 1;
X	}
X	return r;
X}
X
Xmain()
X{
X	int i;
X	for (i = 0; i <= 0xFF; i++) {
X		if ((i & 7) == 0)
X			printf("/* 0x%02X */", i);
X		printf(" 0x%02X,", bitrev(i));
X		if ((i & 7) == 7)
X			printf("\n");
X	}
X}
X
X#endif
X
X/*
X * Local Variables:
X * tab-width: 4
X * c-indent-level: 4
X * c-argdecl-indent: 4
X * c-continued-statement-offset: 4
X * c-continued-brace-offset: -4
X * c-label-offset: -4
X * c-brace-offset: 0
X * End:
X */
END_OF_FILE
if test 7249 -ne `wc -c <'hwaddr.c'`; then
    echo shar: \"'hwaddr.c'\" unpacked with wrong size!
fi
# end of 'hwaddr.c'
fi
if test -f 'hwaddr.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hwaddr.h'\"
else
echo shar: Extracting \"'hwaddr.h'\" \(965 characters\)
sed "s/^X//" >'hwaddr.h' <<'END_OF_FILE'
X/* hwaddr.h */
X#ifndef	HWADDR_H
X#define HWADDR_H
X
X#define MAXHADDRLEN		8	/* Max hw address length in bytes */
X
X/*
X * This structure holds information about a specific network type.  The
X * length of the network hardware address is stored in "hlen".
X * The string pointed to by "name" is the cononical name of the network.
X */
Xstruct hwinfo {
X    unsigned int hlen;
X    char *name;
X};
X
Xextern struct hwinfo hwinfolist[];
Xextern int hwinfocnt;
X
X#ifdef	__STDC__
X#define P(args) args
X#else
X#define P(args) ()
X#endif
X
Xextern void setarp P((int, struct in_addr *, u_char *, int));
Xextern char *haddrtoa P((u_char *, int));
Xextern void haddr_conv802 P((u_char *, u_char *, int));
X
X#undef P
X
X/*
X * Return the length in bytes of a hardware address of the given type.
X * Return the canonical name of the network of the given type.
X */
X#define haddrlength(type)	((hwinfolist[(int) (type)]).hlen)
X#define netname(type)		((hwinfolist[(int) (type)]).name)
X
X#endif	/* HWADDR_H */
END_OF_FILE
if test 965 -ne `wc -c <'hwaddr.h'`; then
    echo shar: \"'hwaddr.h'\" unpacked with wrong size!
fi
# end of 'hwaddr.h'
fi
if test -f 'lookup.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lookup.c'\"
else
echo shar: Extracting \"'lookup.c'\" \(2264 characters\)
sed "s/^X//" >'lookup.c' <<'END_OF_FILE'
X/*
X * lookup.c - Lookup IP address, HW address, netmask
X */
X
X#include <sys/types.h>
X#include <sys/socket.h>
X
X#include <net/if.h>
X#include <netinet/in.h>
X
X#ifdef	ETC_ETHERS
X#include <netinet/if_ether.h>
Xextern int ether_hostton();
X#endif
X
X#include <netdb.h>
X#include <syslog.h>
X
X#ifndef USE_BFUNCS
X#include <memory.h>
X/* Yes, memcpy is OK here (no overlapped copies). */
X#define bcopy(a,b,c)    memcpy(b,a,c)
X#endif
X
X#include "bootp.h"
X#include "lookup.h"
X#include "report.h"
X
X/*
X * Lookup an Ethernet address and return it.
X * Return NULL if addr not found.
X */
Xu_char *
Xlookup_hwa(hostname, htype)
X	char *hostname;
X	int htype;
X{
X	switch (htype) {
X
X		/* XXX - How is this done on other systems? -gwr */
X#ifdef	ETC_ETHERS
X	case HTYPE_ETHERNET:
X	case HTYPE_IEEE802:
X		{
X			static struct ether_addr ea;
X			/* This does a lookup in /etc/ethers */
X			if (ether_hostton(hostname, &ea)) {
X				report(LOG_ERR, "no HW addr for host \"%s\"",
X					   hostname);
X				return (u_char *) 0;
X			}
X			return (u_char *) & ea;
X		}
X#endif /* ETC_ETHERS */
X
X	default:
X		report(LOG_ERR, "no lookup for HW addr type %d", htype);
X	}							/* switch */
X
X	/* If the system can't do it, just return an error. */
X	return (u_char *) 0;
X}
X
X
X/*
X * Lookup an IP address.
X * Return non-zero on failure.
X */
Xint
Xlookup_ipa(hostname, result)
X	char *hostname;
X	u_int32 *result;
X{
X	struct hostent *hp;
X	hp = gethostbyname(hostname);
X	if (!hp)
X		return -1;
X	bcopy(hp->h_addr, result, sizeof(*result));
X	return 0;
X}
X
X
X/*
X * Lookup a netmask
X * Return non-zero on failure.
X *
X * XXX - This is OK as a default, but to really make this automatic,
X * we would need to get the subnet mask from the ether interface.
X * If this is wrong, specify the correct value in the bootptab.
X */
Xint
Xlookup_netmask(addr, result)
X	u_int32 addr;				/* both in network order */
X	u_int32 *result;
X{
X	int32 m, a;
X
X	a = ntohl(addr);
X	m = 0;
X
X	if (IN_CLASSA(a))
X		m = IN_CLASSA_NET;
X
X	if (IN_CLASSB(a))
X		m = IN_CLASSB_NET;
X
X	if (IN_CLASSC(a))
X		m = IN_CLASSC_NET;
X
X	if (!m)
X		return -1;
X	*result = htonl(m);
X	return 0;
X}
X
X/*
X * Local Variables:
X * tab-width: 4
X * c-indent-level: 4
X * c-argdecl-indent: 4
X * c-continued-statement-offset: 4
X * c-continued-brace-offset: -4
X * c-label-offset: -4
X * c-brace-offset: 0
X * End:
X */
END_OF_FILE
if test 2264 -ne `wc -c <'lookup.c'`; then
    echo shar: \"'lookup.c'\" unpacked with wrong size!
fi
# end of 'lookup.c'
fi
if test -f 'lookup.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lookup.h'\"
else
echo shar: Extracting \"'lookup.h'\" \(319 characters\)
sed "s/^X//" >'lookup.h' <<'END_OF_FILE'
X/* lookup.h */
X
X#include "bptypes.h"	/* for int32, u_int32 */
X
X#ifdef	__STDC__
X#define P(args) args
X#else
X#define P(args) ()
X#endif
X
Xextern u_char *lookup_hwa P((char *hostname, int htype));
Xextern int lookup_ipa P((char *hostname, u_int32 *addr));
Xextern int lookup_netmask P((u_int32 addr, u_int32 *mask));
X
X#undef P
END_OF_FILE
if test 319 -ne `wc -c <'lookup.h'`; then
    echo shar: \"'lookup.h'\" unpacked with wrong size!
fi
# end of 'lookup.h'
fi
if test -f 'patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patchlevel.h'\"
else
echo shar: Extracting \"'patchlevel.h'\" \(63 characters\)
sed "s/^X//" >'patchlevel.h' <<'END_OF_FILE'
X/* patchlevel.h */
X#define VERSION 	"2.4"
X#define PATCHLEVEL	0
END_OF_FILE
if test 63 -ne `wc -c <'patchlevel.h'`; then
    echo shar: \"'patchlevel.h'\" unpacked with wrong size!
fi
# end of 'patchlevel.h'
fi
if test -f 'readfile.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'readfile.h'\"
else
echo shar: Extracting \"'readfile.h'\" \(373 characters\)
sed "s/^X//" >'readfile.h' <<'END_OF_FILE'
X/* readfile.h */
X
X#include "bptypes.h"
X#include "hash.h"
X
X#ifdef	__STDC__
X#define P(args) args
X#else
X#define P(args) ()
X#endif
X
Xextern boolean hwlookcmp P((hash_datum *, hash_datum *));
Xextern boolean iplookcmp P((hash_datum *, hash_datum *));
Xextern boolean nmcmp P((hash_datum *, hash_datum *));
Xextern void readtab P((int));
Xextern void rdtab_init P((void));
X
X#undef P
X
END_OF_FILE
if test 373 -ne `wc -c <'readfile.h'`; then
    echo shar: \"'readfile.h'\" unpacked with wrong size!
fi
# end of 'readfile.h'
fi
if test -f 'report.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'report.c'\"
else
echo shar: Extracting \"'report.c'\" \(2705 characters\)
sed "s/^X//" >'report.c' <<'END_OF_FILE'
X/*
X * report() - calls syslog
X */
X
X#ifdef	__STDC__
X#include <stdarg.h>
X#else
X#include <varargs.h>
X#endif
X
X#include <stdio.h>
X#include <syslog.h>
X
X#include "report.h"
X
X#ifndef LOG_NDELAY
X#define LOG_NDELAY	0
X#endif
X#ifndef LOG_DAEMON
X#define LOG_DAEMON	0
X#endif
X#ifndef	LOG_BOOTP
X#define LOG_BOOTP	LOG_DAEMON
X#endif
X
Xextern int debug;
Xextern char *progname;
X
X/*
X * This is initialized so you get stderr until you call
X *	report_init()
X */
Xstatic int stderr_only = 1;
X
Xvoid
Xreport_init(nolog)
X	int nolog;
X{
X	stderr_only = nolog;
X#ifdef SYSLOG
X	if (!stderr_only) {
X		openlog(progname, LOG_PID | LOG_NDELAY, LOG_BOOTP);
X	}
X#endif
X}
X
X/*
X * This routine reports errors and such via stderr and syslog() if
X * appopriate.  It just helps avoid a lot of "#ifdef SYSLOG" constructs
X * from being scattered throughout the code.
X *
X * The syntax is identical to syslog(3), but %m is not considered special
X * for output to stderr (i.e. you'll see "%m" in the output. . .).  Also,
X * control strings should normally end with \n since newlines aren't
X * automatically generated for stderr output (whereas syslog strips out all
X * newlines and adds its own at the end).
X */
X
Xstatic char *levelnames[] = {
X#ifdef LOG_SALERT
X	"level(0): ",
X	"alert(1): ",
X	"alert(2): ",
X	"emerg(3): ",
X	"error(4): ",
X	"crit(5):  ",
X	"warn(6):  ",
X	"note(7):  ",
X	"info(8):  ",
X	"debug(9): ",
X	"level(?): "
X#else
X	"emerg(0): ",
X	"alert(1): ",
X	"crit(2):  ",
X	"error(3): ",
X	"warn(4):  ",
X	"note(5):  ",
X	"info(6):  ",
X	"debug(7): ",
X	"level(?): "
X#endif
X};
Xstatic int numlevels = sizeof(levelnames) / sizeof(levelnames[0]);
X
X
X/*
X * Print a log message using syslog(3) and/or stderr.
X * The message passed in should not include a newline.
X */
X#ifdef	__STDC__
Xvoid
Xreport(int priority, char *fmt,...)
X#else
X/*VARARGS2*/
Xvoid
Xreport(priority, fmt, va_alist)
X	int priority;
X	char *fmt;
X	va_dcl
X#endif
X{
X	va_list ap;
X	static char buf[128];
X
X	if ((priority < 0) || (priority >= numlevels)) {
X		priority = numlevels - 1;
X	}
X#ifdef	__STDC__
X	va_start(ap, fmt);
X#else
X	va_start(ap);
X#endif
X	vsprintf(buf, fmt, ap);
X	va_end(ap);
X
X	/*
X	 * Print the message
X	 */
X	if (stderr_only || (debug > 2)) {
X		fprintf(stderr, "%s: %s %s\n",
X				progname, levelnames[priority], buf);
X	}
X#ifdef SYSLOG
X	if (!stderr_only)
X		syslog((priority | LOG_BOOTP), "%s", buf);
X#endif
X}
X
X
X
X/*
X * Return pointer to static string which gives full filesystem error message.
X */
Xchar *
Xget_errmsg()
X{
X	extern int errno;
X	extern char *strerror();
X
X	return strerror(errno);
X}
X
X/*
X * Local Variables:
X * tab-width: 4
X * c-indent-level: 4
X * c-argdecl-indent: 4
X * c-continued-statement-offset: 4
X * c-continued-brace-offset: -4
X * c-label-offset: -4
X * c-brace-offset: 0
X * End:
X */
END_OF_FILE
if test 2705 -ne `wc -c <'report.c'`; then
    echo shar: \"'report.c'\" unpacked with wrong size!
fi
# end of 'report.c'
fi
if test -f 'report.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'report.h'\"
else
echo shar: Extracting \"'report.h'\" \(213 characters\)
sed "s/^X//" >'report.h' <<'END_OF_FILE'
X/* report.h */
X
X#ifdef	__STDC__
X#define P(args) args
X#else
X#define P(args) ()
X#endif
X
Xextern void report_init P((int nolog));
Xextern void report P((int, char *, ...));
Xextern char *get_errmsg P((void));
X
X#undef P
END_OF_FILE
if test 213 -ne `wc -c <'report.h'`; then
    echo shar: \"'report.h'\" unpacked with wrong size!
fi
# end of 'report.h'
fi
if test -f 'strerror.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'strerror.c'\"
else
echo shar: Extracting \"'strerror.c'\" \(389 characters\)
sed "s/^X//" >'strerror.c' <<'END_OF_FILE'
X/*
X * strerror() - for those systems that don't have it yet.
X * Doing it this way avoids yet another ifdef...
X */
X
X/* These are part of the C library. (See perror.3) */
Xextern char *sys_errlist[];
Xextern int sys_nerr;
X
Xstatic char errmsg[80];
X
Xchar *
Xstrerror(en)
X	int en;
X{
X	if ((0 <= en) && (en < sys_nerr))
X		return sys_errlist[en];
X
X	sprintf(errmsg, "Error %d", en);
X	return errmsg;
X}
END_OF_FILE
if test 389 -ne `wc -c <'strerror.c'`; then
    echo shar: \"'strerror.c'\" unpacked with wrong size!
fi
# end of 'strerror.c'
fi
if test -f 'syslog.conf' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'syslog.conf'\"
else
echo shar: Extracting \"'syslog.conf'\" \(2132 characters\)
sed "s/^X//" >'syslog.conf' <<'END_OF_FILE'
X#
X# syslog configuration file for SunOS 4.X
X# (modified to do local2 separately)
X#
X# This file is processed by m4 so be careful to quote (`') names
X# that match m4 reserved words.  Also, within ifdef's, arguments
X# containing commas must be quoted.
X#
X# Note: Have to exclude user from most lines so that user.alert
X#	and user.emerg are not included, because old sendmails
X#	will generate them for debugging information.  If you
X#	have no 4.2BSD based systems doing network logging, you
X#	can remove all the special cases for "user" logging.
X
X#*.err;kern.debug;auth.notice;user.none		/dev/console
Xkern.debug;user,mail.crit;auth.notice		/dev/console
Xdaemon,syslog,lpr,news,uucp,cron.err		/dev/console
X
X#*.err;kern.debug;daemon,auth.notice;mail.crit;user.none /var/adm/messages
Xkern.debug;user,mail.crit;auth.notice		/var/adm/messages
Xdaemon.notice;syslog,news,uucp,cron.err		/var/adm/messages
X
Xlpr.debug					/var/adm/lpd-errs
X
X*.alert;kern.err;daemon.err;user.none		operator
X*.alert;user.none				root
X
X*.emerg;user.none				*
X
X# for loghost machines, to have authentication messages (su, login, etc.)
X# logged to a file, un-comment out the following line and adjust the file name
X# as appropriate.
X#
X# if a non-loghost machine chooses to have such messages 
X# sent to the loghost machine, un-comment out the following line.
X#
X#auth.notice			ifdef(`LOGHOST', /var/log/authlog, @loghost)
X
Xmail.debug			ifdef(`LOGHOST', /var/log/syslog, @loghost)
X
X# following line for compatibility with old sendmails.  they will send
X# messages with no facility code, which will be turned into "user" messages
X# by the local syslog daemon.  only the "loghost" machine needs the following
X# line, to cause these old sendmail log messages to be logged in the
X# mail syslog file.
X#
Xifdef(`LOGHOST',
Xuser.alert					/var/log/syslog
X)
X#
X# non-loghost machines will use the following lines to cause "user"
X# log messages to be logged locally.
X#
Xifdef(`LOGHOST', ,
Xuser.err					/dev/console
Xuser.err					/var/adm/messages
Xuser.alert					`root, operator'
Xuser.emerg					*
X)
X
X# Local2: (bootpd, pppd)
Xlocal2.debug				/dev/console
X#local2.debug				/var/log/local2
END_OF_FILE
if test 2132 -ne `wc -c <'syslog.conf'`; then
    echo shar: \"'syslog.conf'\" unpacked with wrong size!
fi
# end of 'syslog.conf'
fi
if test -f 'syslog.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'syslog.h'\"
else
echo shar: Extracting \"'syslog.h'\" \(816 characters\)
sed "s/^X//" >'syslog.h' <<'END_OF_FILE'
X/*
X * Fake syslog.h for systems without it  (just defines priorities).
X * To use this, compile with: -I/usr/include -I.
X */
X
X/*
X * Copyright (c) 1982, 1986 Regents of the University of California.
X * All rights reserved.  The Berkeley software License Agreement
X * specifies the terms and conditions for redistribution.
X */
X
X/*
X *  Priorities (these are ordered)
X */
X#define LOG_EMERG	0	/* system is unusable */
X#define LOG_ALERT	1	/* action must be taken immediately */
X#define LOG_CRIT	2	/* critical conditions */
X#define LOG_ERR		3	/* error conditions */
X#define LOG_WARNING	4	/* warning conditions */
X#define LOG_NOTICE	5	/* normal but signification condition */
X#define LOG_INFO	6	/* informational */
X#define LOG_DEBUG	7	/* debug-level messages */
X
X/* XXX - Just in case: */
X#define openlog fake_syslog_openlog
END_OF_FILE
if test 816 -ne `wc -c <'syslog.h'`; then
    echo shar: \"'syslog.h'\" unpacked with wrong size!
fi
# end of 'syslog.h'
fi
if test -f 'trygetea.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'trygetea.c'\"
else
echo shar: Extracting \"'trygetea.c'\" \(798 characters\)
sed "s/^X//" >'trygetea.c' <<'END_OF_FILE'
X/*
X * trygetea.c - test program for getether.c
X */
X
X#include <sys/types.h>
X#include <sys/socket.h>
X
X#if defined(SUNOS) || defined(SVR4)
X#include <sys/sockio.h>
X#endif
X
X#include <net/if.h>				/* for struct ifreq */
X#include <netinet/in.h>
X#include <arpa/inet.h>			/* inet_ntoa */
X
X#include <netdb.h>
X#include <stdio.h>
X#include <ctype.h>
X#include <errno.h>
X
Xint debug = 0;
Xchar *progname;
X
Xmain(argc, argv)
X	char **argv;
X{
X	u_char ea[16];				/* Ethernet address */
X	int i;
X
X	progname = argv[0];			/* for report */
X
X	if (argc < 2) {
X		printf("need interface name\n");
X		exit(1);
X	}
X	if ((i = getether(argv[1], ea)) < 0) {
X		printf("Could not get Ethernet address (rc=%d)\n", i);
X		exit(1);
X	}
X	printf("Ether-addr");
X	for (i = 0; i < 6; i++)
X		printf(":%x", ea[i] & 0xFF);
X	printf("\n");
X
X	exit(0);
X}
END_OF_FILE
if test 798 -ne `wc -c <'trygetea.c'`; then
    echo shar: \"'trygetea.c'\" unpacked with wrong size!
fi
# end of 'trygetea.c'
fi
if test -f 'trygetif.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'trygetif.c'\"
else
echo shar: Extracting \"'trygetif.c'\" \(1309 characters\)
sed "s/^X//" >'trygetif.c' <<'END_OF_FILE'
X/*
X * trygetif.c - test program for getif.c
X */
X
X#include <sys/types.h>
X#include <sys/socket.h>
X
X#if defined(SUNOS) || defined(SVR4)
X#include <sys/sockio.h>
X#endif
X
X#include <net/if.h>				/* for struct ifreq */
X#include <netinet/in.h>
X#include <arpa/inet.h>			/* inet_ntoa */
X
X#include <netdb.h>
X#include <stdio.h>
X#include <ctype.h>
X#include <errno.h>
X
X#include "getif.h"
X
Xint debug = 0;
Xchar *progname;
X
Xmain(argc, argv)
X	char **argv;
X{
X	struct hostent *hep;
X	struct sockaddr ea;			/* Ethernet address */
X	struct sockaddr_in *sip;	/* Interface address */
X	struct ifreq *ifr;
X	struct in_addr dst_addr;
X	struct in_addr *dap;
X	int i, s;
X
X	progname = argv[0];			/* for report */
X
X	dap = NULL;
X	if (argc > 1) {
X		dap = &dst_addr;
X		if (isdigit(argv[1][0]))
X			dst_addr.s_addr = inet_addr(argv[1]);
X		else {
X			hep = gethostbyname(argv[1]);
X			if (!hep) {
X				printf("gethostbyname(%s)\n", argv[1]);
X				exit(1);
X			}
X			memcpy(&dst_addr, hep->h_addr, sizeof(dst_addr));
X		}
X	}
X	s = socket(AF_INET, SOCK_DGRAM, 0);
X	if (s < 0) {
X		perror("socket open");
X		exit(1);
X	}
X	ifr = getif(s, dap);
X	if (!ifr) {
X		printf("no interface for address\n");
X		exit(1);
X	}
X	printf("Intf-name:%s\n", ifr->ifr_name);
X	sip = (struct sockaddr_in *) &(ifr->ifr_addr);
X	printf("Intf-addr:%s\n", inet_ntoa(sip->sin_addr));
X
X	exit(0);
X}
END_OF_FILE
if test 1309 -ne `wc -c <'trygetif.c'`; then
    echo shar: \"'trygetif.c'\" unpacked with wrong size!
fi
# end of 'trygetif.c'
fi
if test -f 'trylook.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'trylook.c'\"
else
echo shar: Extracting \"'trylook.c'\" \(715 characters\)
sed "s/^X//" >'trylook.c' <<'END_OF_FILE'
X/*
X * trylook.c - test program for lookup.c
X */
X
X#include <sys/types.h>
X#include <netinet/in.h>
X#include <stdio.h>
X
X#include "report.h"
X#include "lookup.h"
X
Xextern char *ether_ntoa();
Xextern char *inet_ntoa();
X
Xint debug = 0;
Xchar *progname;
X
Xmain(argc, argv)
X	char **argv;
X{
X	int i;
X	struct in_addr in;
X	char *a;
X	u_char *hwa;
X
X	progname = argv[0];			/* for report */
X
X	for (i = 1; i < argc; i++) {
X
X		/* Host name */
X		printf("%s:", argv[i]);
X
X		/* IP addr */
X		if (lookup_ipa(argv[i], &in.s_addr))
X			a = "?";
X		else
X			a = inet_ntoa(in);
X		printf(" ipa=%s", a);
X
X		/* Ether addr */
X		hwa = lookup_hwa(argv[i], 1);
X		if (!hwa)
X			a = "?";
X		else
X			a = ether_ntoa(hwa);
X		printf(" hwa=%s\n", a);
X
X	}
X	exit(0);
X}
END_OF_FILE
if test 715 -ne `wc -c <'trylook.c'`; then
    echo shar: \"'trylook.c'\" unpacked with wrong size!
fi
# end of 'trylook.c'
fi
if test -f 'tzone.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tzone.c'\"
else
echo shar: Extracting \"'tzone.c'\" \(1041 characters\)
sed "s/^X//" >'tzone.c' <<'END_OF_FILE'
X/*
X * tzone.c - get the timezone
X *
X * This is shared by bootpd and bootpef
X */
X
X#ifdef	SVR4
X/* XXX - Is this really SunOS specific? -gwr */
X/* This is in <time.h> but only visible if (__STDC__ == 1). */
Xextern long timezone;
X#else /* SVR4 */
X/* BSD or SunOS */
X# include <sys/time.h>
X# include <syslog.h>
X#endif /* SVR4 */
X
X#include "bptypes.h"
X#include "report.h"
X#include "tzone.h"
X
X/* This is what other modules use. */
Xint32 secondswest;
X
X/*
X * Get our timezone offset so we can give it to clients if the
X * configuration file doesn't specify one.
X */
Xvoid
Xtzone_init()
X{
X#ifdef	SVR4
X	/* XXX - Is this really SunOS specific? -gwr */
X	secondswest = timezone;
X#else /* SVR4 */
X	struct timezone tzp;		/* Time zone offset for clients */
X	struct timeval tp;			/* Time (extra baggage) */
X	if (gettimeofday(&tp, &tzp) < 0) {
X		secondswest = 0;		/* Assume GMT for lack of anything better */
X		report(LOG_ERR, "gettimeofday: %s", get_errmsg());
X	} else {
X		secondswest = 60L * tzp.tz_minuteswest;	/* Convert to seconds */
X	}
X#endif /* SVR4 */
X}
END_OF_FILE
if test 1041 -ne `wc -c <'tzone.c'`; then
    echo shar: \"'tzone.c'\" unpacked with wrong size!
fi
# end of 'tzone.c'
fi
if test -f 'tzone.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tzone.h'\"
else
echo shar: Extracting \"'tzone.h'\" \(66 characters\)
sed "s/^X//" >'tzone.h' <<'END_OF_FILE'
X/* tzone.h */
Xextern int32 secondswest;
Xextern void tzone_init();
END_OF_FILE
if test 66 -ne `wc -c <'tzone.h'`; then
    echo shar: \"'tzone.h'\" unpacked with wrong size!
fi
# end of 'tzone.h'
fi
echo shar: End of archive 1 \(of 4\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
