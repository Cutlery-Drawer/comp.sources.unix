Newsgroups: comp.sources.unix
From: kstailey@leidecker.gsfc.nasa.gov (Kenneth Stailey)
Subject: v28i140: pint - PINT is not TWAIN (scanner interface toolset), Part02/07
References: <1.783771355.23520@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: kstailey@leidecker.gsfc.nasa.gov (Kenneth Stailey)
Posting-Number: Volume 28, Issue 140
Archive-Name: pint/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 7)."
# Contents:  pint/README pint/ibm/Makefile pint/ibm/PdDv.scan.add
#   pint/ibm/mkinventory.c pint/ibm/sm_cmd_hdr.add
#   pint/ibm/sm_name_hdr.add pint/ibm/ucfgscan.c
#   pint/sun/dist/confmod.c pint/sun/driver/scandd.h
#   pint/sun/misc/SCANNER pint/sun/misc/files.scan
#   pint/util/set_scanner.c
# Wrapped by kstailey@leidecker on Tue Nov  1 12:27:52 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'pint/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pint/README'\"
else
echo shar: Extracting \"'pint/README'\" \(4461 characters\)
sed "s/^X//" >'pint/README' <<'END_OF_FILE'
X
X		       PINT: PINT Is Not TWAIN
X
X
X	       common scanner driver interface for UN*X
X
X
X
XCopyright (C) 1994 Kenneth Stailey ken@spacenet.com
X
XThis program is free software; you can redistribute it and/or modify
Xit under the terms of the GNU General Public License as published by
Xthe Free Software Foundation; either version 2 of the License, or
X(at your option) any later version.
X
XThis program is distributed in the hope that it will be useful,
Xbut WITHOUT ANY WARRANTY; without even the implied warranty of
XMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
XGNU General Public License for more details.
X
XYou should have received a copy of the GNU General Public License
Xalong with this program; if not, write to the Free Software
XFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
X
XPINT is a first stab at a scanner interface with enough flexibility to
Xwork with fairly divergent scanners (although currently only SCSI
Xscanners are supported, they are disappointingly divergent).  In
Xadditon PINT is portable across two pretty divergent versions of UNIX,
XAIX 3.2 and SunOS 4.1
X
XPINT uses the traditional UNIX character special file interface and
Xsupports open/close/read/ioctl operations.
X
XBasic workflow for scanning
X1. open driver
X2. ioctl to get parameters
X3. modify parameters
X4. ioctl to set parameters
X5. ioctl to get "active area" size in pixels
X6. read data based on size from scanner
X7. close driver
X
XSteps 2-4 will alleviate you from having to set every parameter by hand.
X
XSteps 5-6 deal with scanners that do not support as much resolution
X	  as was specified via the ioctl, and with scanners that
X	  do funny things to the size of the image data like
X	  pad or truncate it to a byte or word boundary.
X
XThe PINT ioctl interface as of version 0.1
X
Xioctl(fd, cmd, &arg) where command is:
X
X SCAN_GET
X	Get scanner parameters.
X
X SCAN_SET
X	Set scanner parameters.
X
X	these ioctls use the following struct as their argument
X
Xstruct scan_io {
X  ulong   scan_window_width;	/* width in 1/1200ths of an inch */
X  ulong   scan_window_length;	/* length in 1/1200ths of an inch */
X  ushort  scan_x_resolution;	/* horizontal resolution in dots-per-inch */
X  ushort  scan_y_resolution;	/* vertical resolution in dots-per-inch */
X  ulong   scan_x_origin;	/* horizontal coordinate of upper left corner */
X  ulong   scan_y_origin;	/* vertical coordinate of upper left corner */
X  uchar   scan_image_mode;	/* type of image data sent by scanner: */
X
X SIM_BINARY_MONOCHROME   	- good old black-and-white
X
X SIM_DITHERED_MONOCHROME 	- half-toned monochrome
X
X SIM_GRAYSCALE  		- multibit monochrome
X
X SIM_COLOR			- "one pass color"
X
X SIM_RED
X SIM_GREEN			- red, green or blue filter is applied
X SIM_BLUE
X
X  uchar   scan_brightness;	/* brightness control for those to can do it */
X  uchar   scan_contrast;	/* contrast control for those to can do it */
X  uchar   scan_scanner_type;	/* type of scanner (read only variable) */
X
X RICOH_IS410		- Ricoh IS410
X IBM_2456		- IBM 2456
X FUJITSU_M3096G 	- Fujitsu M3096G
X HP_SCANJET_IIC 	- HP Scanjet IIc
X RICOH_IS50		- Ricoh IS50
X UMAX_UC630		- UMAX UC630
X UMAX_UG630		- UMAX UG630
X RICOH_FS1		- Ricoh FS1
X SHARP_JX600		- Sharp JX600
X
X  uchar   scan_use_adf;		/* whether to use Automatic Document Feeder */
X};
X
X
X SCAN_GET_PIXEL_SIZE
X	Retrieve the scanner's opinion of the size of the activer area in
X	pixels into a structure like this:
X
Xstruct scan_pixel_sizes {
X  uint pix_width;
X  uint pix_height;
X};
X
X SCAN_PAPER_PUSH
X	First make a blind effort at unloading the ADF with no error return
X	then load the ADF.
X
X	this ioctl has no arguments
X
X
XI'm sure that many people will take offense to the fixed unit size of
X1/1200" of an inch, but I haven't given the issue of multiple/variable
Xunits.  I don't want to bloat the kernal code for this feature.
XProbably a library routine for converting from a fixed interal size
Xwill be used.  Suggestions are welcome.
X
X
X******************            Using PINT           **********************
X
XWith the driver and utilities installed and the scanner hooked up you
Xcan view the scanner's parameters with "get_scanner".  The
X"set_scanner" utility changes the parameters.  The grabscan utility
Xwill tranfer image data from the scanner to standard output in PNM
Xformat.  Try "set_scanner -i m; grabscan > test.pbm"
X
XIf you have/get all of PBMPLUS installed you can generate images in
Xmany graphics formats.  A viewer like loadimage, or xv can be used to
Xview the images on screen.
X
END_OF_FILE
if test 4461 -ne `wc -c <'pint/README'`; then
    echo shar: \"'pint/README'\" unpacked with wrong size!
fi
# end of 'pint/README'
fi
if test -f 'pint/ibm/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pint/ibm/Makefile'\"
else
echo shar: Extracting \"'pint/ibm/Makefile'\" \(3773 characters\)
sed "s/^X//" >'pint/ibm/Makefile' <<'END_OF_FILE'
X#  PINT Makefile for AIX 3.2 systems
X#  version 0.1
X#
X#  PINT Pint Is Not TWAIN - common scanner driver interface for UN*X
X#  Copyright (C) 1994 Kenneth Stailey ken@spacenet.com
X#
X#  This program is free software; you can redistribute it and/or modify
X#  it under the terms of the GNU General Public License as published by
X#  the Free Software Foundation; either version 2 of the License, or
X#  (at your option) any later version.
X#
X#  This program is distributed in the hope that it will be useful,
X#  but WITHOUT ANY WARRANTY; without even the implied warranty of
X#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#  GNU General Public License for more details.
X#
X#  You should have received a copy of the GNU General Public License
X#  along with this program; if not, write to the Free Software
X#  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X#defines:
X# -DIOSTAT
X# -DDEBUG_CLOSE
X# -DDEBUG_CONFIG
X# -DDEBUG_IOCTL
X# -DDEBUG_IODONE
X# -DDEBUG_OPEN
X# -DDEBUG_PIN
X# -DDEBUG_READ
X# -DDEBUG_SCSI_CMD
X# -DDEBUG_SET_WINDOW
X# -DDEBUG_ADAPTER_ERROR
X# -DDEBUG_UIO
X# -DDEBUG_PERFORMANCE
X
XCFLAGS = -O -DIOSTAT
X#CFLAGS = -O -DDEBUG_READ
X#CFLAGS = -O -DIOSTAT -DDEBUG_IOCTL -DDEBUG_SCSI_CMD
X
XLD	= /bin/ld
XBIND	= -b"binder:/usr/lib/bind glink:/lib/glink.o"
XLIBS	= -lcsys -lsys
XLDOPTS	= -s -D0 -H512 -T512
XLDFLAGS	= ${BIND} ${LDOPTS} ${LIBS}
X
XTOPIMP  = -b"I:/lib/kernex.exp I:/lib/syscalls.exp I:scan_b.exp E:scan_t.exp"
XBOTIMP  = -b"I:/lib/kernex.exp I:/lib/syscalls.exp I:scan_t.exp E:scan_b.exp"
X
Xall: scandd scandd_pin cfgscan ucfgscan scanner.cat mkinventory
X
Xscandd: scandd.t.o window_size.o
X	$(LD) $(LDFLAGS) $(TOPIMP) scandd.t.o window_size.o \
X	-e scanconfig -o scandd
X
Xscandd_pin: scandd.b.o
X	$(LD) $(LDFLAGS) $(BOTIMP) scandd.b.o -e scaniodone -o scandd_pin
X
Xscandd.t.o: scandd.t.c scandd.h scanio.h
X	$(CC) $(CFLAGS) -c scandd.t.c
X
Xscandd.b.o: scandd.b.c scandd.h
X	$(CC) $(CFLAGS) -c scandd.b.c
X
Xwindow_size.o: window_size.c
X	gcc -c window_size.c
X
Xcfgscan: cfgscan.o
X	$(CC) -o cfgscan cfgscan.o -lcfg -lodm -lPW
X
Xcfgscan.o: cfgscan.c scandd.h
X	$(CC) $(CFLAGS) -c cfgscan.c
X
Xucfgscan: ucfgscan.o
X	$(CC) -o ucfgscan ucfgscan.o -lcfg -lodm
X
Xscanner.cat: scanner.messages
X	runcat scanner scanner.messages
X
Xmkinventory: mkinventory.c
X	$(CC) -o mkinventory mkinventory.c
X
Xsmit: sm_cmd_hdr.add sm_cmd_opt.add sm_menu_opt.add sm_name_hdr.add
X	purge-smit-of-scanner
X	odmadd sm_cmd_hdr.add
X	odmadd sm_cmd_opt.add
X	odmadd sm_menu_opt.add
X	odmadd sm_name_hdr.add
X
Xdist: all
X	rm -f dist/usr/include/sys/scanio.h
X	ln scanio.h dist/usr/include/sys/scanio.h
X	rm -f dist/etc/drivers/scandd
X	ln scandd dist/etc/drivers
X	rm -f dist/etc/drivers/scandd_pin
X	ln scandd_pin dist/etc/drivers
X	rm -f dist/etc/methods/cfgscan
X	ln cfgscan dist/etc/methods
X	rm -f dist/etc/methods/ucfgscan
X	ln ucfgscan dist/etc/methods
X	rm -f dist/usr/lpp/msg/En_US/scanner.cat
X	ln scanner.cat dist/usr/lpp/msg/En_US
X	rm -f dist/usr/lpp/scanner/mkinventory
X	ln mkinventory dist/usr/lpp/scanner
X	rm -f dist/usr/lpp/scanner/PdAt.scan.add
X	ln PdAt.scan.add dist/usr/lpp/scanner
X	rm -f dist/usr/lpp/scanner/PdDv.scan.add
X	ln PdDv.scan.add dist/usr/lpp/scanner
X	rm -f dist/usr/lpp/scanner/sm_cmd_hdr.add
X	ln sm_cmd_hdr.add dist/usr/lpp/scanner
X	rm -f dist/usr/lpp/scanner/sm_cmd_opt.add
X	ln sm_cmd_opt.add dist/usr/lpp/scanner
X	rm -f dist/usr/lpp/scanner/sm_menu_opt.add
X	ln sm_menu_opt.add dist/usr/lpp/scanner
X	rm -f dist/usr/lpp/scanner/sm_name_hdr.add
X	ln sm_name_hdr.add dist/usr/lpp/scanner
X	rm -f dist/usr/lpp/scanner/scanner-get-pw
X	ln scanner-get-pw dist/usr/lpp/scanner/scanner-get-pw
X	rm -f dist/usr/lpp/scanner/X-scanner-get-pw
X	ln X-scanner-get-pw dist/usr/lpp/scanner/X-scanner-get-pw
X
Xclean:
X	rm -f scandd scandd_pin cfgscan ucfgscan scanner.cat mkinventory
X	rm -f *.o a.out core
END_OF_FILE
if test 3773 -ne `wc -c <'pint/ibm/Makefile'`; then
    echo shar: \"'pint/ibm/Makefile'\" unpacked with wrong size!
fi
# end of 'pint/ibm/Makefile'
fi
if test -f 'pint/ibm/PdDv.scan.add' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pint/ibm/PdDv.scan.add'\"
else
echo shar: Extracting \"'pint/ibm/PdDv.scan.add'\" \(6437 characters\)
sed "s/^X//" >'pint/ibm/PdDv.scan.add' <<'END_OF_FILE'
X*  ODM predefined devices entries for PINT
X*  version 0.1
X*
X*  PINT Pint Is Not TWAIN - common scanner driver interface for UN*X
X*  Copyright (C) 1994 Kenneth Stailey ken@spacenet.com
X*
X*  This program is free software; you can redistribute it and/or modify
X*  it under the terms of the GNU General Public License as published by
X*  the Free Software Foundation; either version 2 of the License, or
X*  (at your option) any later version.
X*
X*  This program is distributed in the hope that it will be useful,
X*  but WITHOUT ANY WARRANTY; without even the implied warranty of
X*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X*  GNU General Public License for more details.
X*
X*  You should have received a copy of the GNU General Public License
X*  along with this program; if not, write to the Free Software
X*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X*
X
X* most compliant SCSI interface award goes to:
X
XPdDv:
X	class		= "scanner"
X	subclass	= "scsi"
X	type		= "ricoh_is410"
X	prefix		= "scan"
X	devid		= ""
X	base		= 0
X	has_vpd		= 0
X	detectable	= 1
X	chgstatus	= 0
X	bus_ext		= 0
X	inventory_only	= 0
X	fru		= 1
X	led		= 0x333
X	setno		= 1
X	msgno		= 101
X	catalog		= "scanner.cat"
X	DvDr		= "scandd"
X	Define		= "/etc/methods/define"
X	Configure	= "/etc/methods/cfgscan"
X	Change		= "/etc/methods/chggen"
X	Unconfigure	= "/etc/methods/ucfgscan"
X	Undefine	= "/etc/methods/undefine"
X	Start		= ""
X	Stop		= ""
X	uniquetype	= "scanner/scsi/ricoh_is410"
X
X* the IBM 2456 is really the Ricoh IS-410 in drag
X
XPdDv:
X	class		= "scanner"
X	subclass	= "scsi"
X	type		= "ibm_2456"
X	prefix		= "scan"
X	devid		= ""
X	base		= 0
X	has_vpd		= 0
X	detectable	= 1
X	chgstatus	= 0
X	bus_ext		= 0
X	inventory_only	= 0
X	fru		= 1
X	led		= 0x333
X	setno		= 1
X	msgno		= 102
X	catalog		= "scanner.cat"
X	DvDr		= "scandd"
X	Define		= "/etc/methods/define"
X	Configure	= "/etc/methods/cfgscan"
X	Change		= "/etc/methods/chggen"
X	Unconfigure	= "/etc/methods/ucfgscan"
X	Undefine	= "/etc/methods/undefine"
X	Start		= ""
X	Stop		= ""
X	uniquetype	= "scanner/scsi/ibm_2456"
X
X* fastest gray-scale scanner award goes to:
X
XPdDv:
X	class		= "scanner"
X	subclass	= "scsi"
X	type		= "fujitsu"
X	prefix		= "scan"
X	devid		= ""
X	base		= 0
X	has_vpd		= 0
X	detectable	= 1
X	chgstatus	= 0
X	bus_ext		= 0
X	inventory_only	= 0
X	fru		= 1
X	led		= 0x333
X	setno		= 1
X	msgno		= 100
X	catalog		= "scanner.cat"
X	DvDr		= "scandd"
X	Define		= "/etc/methods/define"
X	Configure	= "/etc/methods/cfgscan"
X	Change		= "/etc/methods/chggen"
X	Unconfigure	= "/etc/methods/ucfgscan"
X	Undefine	= "/etc/methods/undefine"
X	Start		= ""
X	Stop		= ""
X	uniquetype	= "scanner/scsi/fujitsu"
X
X* faster color scanner we support goes to:
X* too bad about the escape-code interface
X
XPdDv:
X	class		= "scanner"
X	subclass	= "scsi"
X	type		= "hp_scanjet_IIc"
X	prefix		= "scan"
X	devid		= ""
X	base		= 0
X	has_vpd		= 0
X	detectable	= 1
X	chgstatus	= 0
X	bus_ext		= 0
X	inventory_only	= 0
X	fru		= 1
X	led		= 0x333
X	setno		= 1
X	msgno		= 108
X	catalog		= "scanner.cat"
X	DvDr		= "scandd"
X	Define		= "/etc/methods/define"
X	Configure	= "/etc/methods/cfgscan"
X	Change		= "/etc/methods/chggen"
X	Unconfigure	= "/etc/methods/ucfgscan"
X	Undefine	= "/etc/methods/undefine"
X	Start		= ""
X	Stop		= ""
X	uniquetype	= "scanner/scsi/hp_scanjet_IIc"
X
X* the ADF support may need some work on this one...
X
XPdDv:
X	class		= "scanner"
X	subclass	= "scsi"
X	type		= "ricoh_is50"
X	prefix		= "scan"
X	devid		= ""
X	base		= 0
X	has_vpd		= 0
X	detectable	= 1
X	chgstatus	= 0
X	bus_ext		= 0
X	inventory_only	= 0
X	fru		= 1
X	led		= 0x333
X	setno		= 1
X	msgno		= 105
X	catalog		= "scanner.cat"
X	DvDr		= "scandd"
X	Define		= "/etc/methods/define"
X	Configure	= "/etc/methods/cfgscan"
X	Change		= "/etc/methods/chggen"
X	Unconfigure	= "/etc/methods/ucfgscan"
X	Undefine	= "/etc/methods/undefine"
X	Start		= ""
X	Stop		= ""
X	uniquetype	= "scanner/scsi/ricoh_is50"
X
X* Good color, no SCSI disconnect, slow, helps to have disk drives on another
X* scsi IO controller or they are unavailable while scanning.
X* Needs SCSI I/O controller card (not integral SCSI), or boot takes forever.
X* This may be a SCSI termination issue, like it is on the Sun.
X
XPdDv:
X	class		= "scanner"
X	subclass	= "scsi"
X	type		= "umax_uc630"
X	prefix		= "scan"
X	devid		= ""
X	base		= 0
X	has_vpd		= 0
X	detectable	= 1
X	chgstatus	= 0
X	bus_ext		= 0
X	inventory_only	= 0
X	fru		= 1
X	led		= 0x333
X	setno		= 1
X	msgno		= 106
X	catalog		= "scanner.cat"
X	DvDr		= "scandd"
X	Define		= "/etc/methods/define"
X	Configure	= "/etc/methods/cfgscan"
X	Change		= "/etc/methods/chggen"
X	Unconfigure	= "/etc/methods/ucfgscan"
X	Undefine	= "/etc/methods/undefine"
X	Start		= ""
X	Stop		= ""
X	uniquetype	= "scanner/scsi/umax_uc630"
X
X* grayscale version of uc630, otherwise the same
X
XPdDv:
X	class		= "scanner"
X	subclass	= "scsi"
X	type		= "umax_ug630"
X	prefix		= "scan"
X	devid		= ""
X	base		= 0
X	has_vpd		= 0
X	detectable	= 1
X	chgstatus	= 0
X	bus_ext		= 0
X	inventory_only	= 0
X	fru		= 1
X	led		= 0x333
X	setno		= 1
X	msgno		= 107
X	catalog		= "scanner.cat"
X	DvDr		= "scandd"
X	Define		= "/etc/methods/define"
X	Configure	= "/etc/methods/cfgscan"
X	Change		= "/etc/methods/chggen"
X	Unconfigure	= "/etc/methods/ucfgscan"
X	Undefine	= "/etc/methods/undefine"
X	Start		= ""
X	Stop		= ""
X	uniquetype	= "scanner/scsi/umax_ug630"
X
X* This thing needs to be turn on AFTER the RS/6000 boots, or the system hangs!
X
XPdDv:
X	class		= "scanner"
X	subclass	= "scsi"
X	type		= "ricoh_fs1"
X	prefix		= "scan"
X	devid		= ""
X	base		= 0
X	has_vpd		= 0
X	detectable	= 1
X	chgstatus	= 0
X	bus_ext		= 0
X	inventory_only	= 0
X	fru		= 1
X	led		= 0x333
X	setno		= 1
X	msgno		= 103
X	catalog		= "scanner.cat"
X	DvDr		= "scandd"
X	Define		= "/etc/methods/define"
X	Configure	= "/etc/methods/cfgscan"
X	Change		= "/etc/methods/chggen"
X	Unconfigure	= "/etc/methods/ucfgscan"
X	Undefine	= "/etc/methods/undefine"
X	Start		= ""
X	Stop		= ""
X	uniquetype	= "scanner/scsi/ricoh_fs1"
X
X* So slow and no disconnects!  must read in <5K chunks or you disk drives will
X* time out!
X* oh well, it's got a large color flatbed...
X
XPdDv:
X	class		= "scanner"
X	subclass	= "scsi"
X	type		= "sharp_jx600"
X	prefix		= "scan"
X	devid		= ""
X	base		= 0
X	has_vpd		= 0
X	detectable	= 1
X	chgstatus	= 0
X	bus_ext		= 0
X	inventory_only	= 0
X	fru		= 1
X	led		= 0x333
X	setno		= 1
X	msgno		= 104
X	catalog		= "scanner.cat"
X	DvDr		= "scandd"
X	Define		= "/etc/methods/define"
X	Configure	= "/etc/methods/cfgscan"
X	Change		= "/etc/methods/chggen"
X	Unconfigure	= "/etc/methods/ucfgscan"
X	Undefine	= "/etc/methods/undefine"
X	Start		= ""
X	Stop		= ""
X	uniquetype	= "scanner/scsi/sharp_jx600"
END_OF_FILE
if test 6437 -ne `wc -c <'pint/ibm/PdDv.scan.add'`; then
    echo shar: \"'pint/ibm/PdDv.scan.add'\" unpacked with wrong size!
fi
# end of 'pint/ibm/PdDv.scan.add'
fi
if test -f 'pint/ibm/mkinventory.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pint/ibm/mkinventory.c'\"
else
echo shar: Extracting \"'pint/ibm/mkinventory.c'\" \(4744 characters\)
sed "s/^X//" >'pint/ibm/mkinventory.c' <<'END_OF_FILE'
X/*
X *  PINT Pint Is Not TWAIN - common scanner driver interface for UN*X
X *  Copyright (C) 1994 Kenneth Stailey ken@spacenet.com
X *
X *  This program is free software; you can redistribute it and/or modify
X *  it under the terms of the GNU General Public License as published by
X *  the Free Software Foundation; either version 2 of the License, or
X *  (at your option) any later version.
X *
X *  This program is distributed in the hope that it will be useful,
X *  but WITHOUT ANY WARRANTY; without even the implied warranty of
X *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *  GNU General Public License for more details.
X *
X *  You should have received a copy of the GNU General Public License
X *  along with this program; if not, write to the Free Software
X *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X/* 
X * mkinventory.c: given an apply list "al" create an inventory file "inventory"
X */
X
X#include <stdio.h>
X#include <string.h>
X#include <pwd.h>
X#include <grp.h>
X#include <sys/stat.h>
X
Xvoid gen_inventory(FILE *, FILE *, char *);
Xchar *get_option_name(FILE *);
X
Xmain()
X{
X  FILE *al, *inventory, *lpp_name, *opt_inv;
X  char line[128];
X  char *option_name;
X
X  if ((lpp_name = fopen("../../../lpp_name", "r")) == NULL) {
X    perror("mkinventory: can't open 'lpp_name'");
X    exit(1);
X  }
X
X  option_name = get_option_name(lpp_name);
X
X  fclose(lpp_name);
X
X  sprintf(line, "%s.inv.u", option_name);
X
X  if ((opt_inv = fopen(line, "w")) == NULL) {
X    perror("mkinventory: can't open 'option.inv.u'");
X    exit(1);
X  }
X
X  if ((al = fopen("al", "r")) == NULL) {
X    perror("mkinventory: can't open 'al'");
X    exit(1);
X  }
X
X  if ((inventory = fopen("inventory", "w")) == NULL) {
X    perror("mkinventory: can't open 'inventory'");
X    exit(1);
X  }
X
X  chdir("../../..");
X
X  while (fgets(line, 128, al) != NULL) {
X    line[strlen(line) - 1] = '\0'; /* eat newline */
X    gen_inventory(inventory, opt_inv, line);
X  }
X
X  fclose(al);
X  fclose(inventory);
X  fclose(opt_inv);
X
X  exit(0);
X}
X
Xvoid gen_inventory(FILE *inv, FILE *opt_inv, char *item)
X{
X  struct stat stat_buf;
X  struct passwd *pwp;
X  struct group *grp;
X  FILE *sum;
X  char sum_value[128];
X  char abs_item[128];
X  char err[128];
X  char cmd[128];
X  char *p;
X
X#if 1
X  /* XXX -> stupid hack need because the lppchk program is run after
X   *        these files get renamed and therefore won't find them
X   */
X  if (strcmp(item, "./usr/bin/X11/ice_scan.3.1") == 0 ||
X      strcmp(item, "./usr/bin/X11/ice_scan.3.2") == 0)
X    return;
X#endif
X
X  if (stat(item, &stat_buf) < 0) {
X    sprintf(err, "mkinventory: can't stat %s", item);
X    perror(err);
X    exit(2);
X  }
X
X  if ((pwp = getpwuid(stat_buf.st_uid)) == NULL) {
X    fprintf(stderr, "mkinventory: can't get password entry for uid %d\n",
X	    stat_buf.st_uid);
X    exit(2);
X  }
X
X  if ((grp = getgrgid(stat_buf.st_gid)) == NULL) {
X    fprintf(stderr, "mkinventory: can't get group entry for gid %d\n",
X	    stat_buf.st_gid);
X    exit(2);
X  }
X
X  sprintf(cmd, "sum %s", item);
X  if ((sum = popen(cmd, "r")) == NULL) {
X    sprintf(err, "mkinventory: can't run %s", cmd);
X    perror(err);
X    exit(2);
X  }
X  fgets(sum_value, 128, sum);
X  pclose(sum);
X  p = strrchr(sum_value, ' ');	/* get rid of the program name */
X  ++p;
X  *p = '\0';
X
X  if (item[0] == '.') {
X    strcpy(abs_item, "/");
X    strcat(abs_item, &item[2]);
X  } else
X    strcpy(abs_item, item);
X
X  fprintf(inv, "%s:\n", abs_item);
X  fprintf(inv, "\towner = %s\n", pwp->pw_name);
X  fprintf(inv, "\tgroup = %s\n", grp->gr_name);
X  fprintf(inv, "\ttype = FILE\n");
X  fprintf(inv, "\tmode = ");
X  if (stat_buf.st_mode & S_ISUID)
X    fprintf(inv, "SUID,");
X  if (stat_buf.st_mode & S_ISGID)
X    fprintf(inv, "SGID,");
X  fprintf(inv, "%o\n", stat_buf.st_mode & ~(_S_IFMT|S_ISUID|S_ISGID));
X  fprintf(inv, "\tsize = %d\n", stat_buf.st_size);
X  fprintf(inv, "\tchecksum = \"%s\"\n", sum_value);
X  fprintf(inv, "\n");
X
X  fprintf(opt_inv, "%s:\n", abs_item);
X  fprintf(opt_inv, "\towner = %s\n", pwp->pw_name);
X  fprintf(opt_inv, "\tgroup = %s\n", grp->gr_name);
X  fprintf(opt_inv, "\ttype = FILE\n");
X  fprintf(opt_inv, "\tmode = ");
X  if (stat_buf.st_mode & S_ISUID)
X    fprintf(opt_inv, "SUID,");
X  if (stat_buf.st_mode & S_ISGID)
X    fprintf(opt_inv, "SGID,");
X  fprintf(opt_inv, "%o\n", stat_buf.st_mode & ~(_S_IFMT|S_ISUID|S_ISGID));
X  fprintf(opt_inv, "\toldpath = %s\n", abs_item);
X  fprintf(opt_inv, "\tsize = %d\n", stat_buf.st_size);
X  fprintf(opt_inv, "\tchecksum = \"%s\"\n", sum_value);
X  fprintf(opt_inv, "\n");
X}
X
Xchar *get_option_name(FILE *lpp_name)
X{
X  static char option_name[128];
X  char *p;
X
X  fgets(option_name, 128, lpp_name);
X  fgets(option_name, 128, lpp_name);
X  p = strchr(option_name, ' ');
X  *p = '\0';
X
X  return (option_name);
X}
END_OF_FILE
if test 4744 -ne `wc -c <'pint/ibm/mkinventory.c'`; then
    echo shar: \"'pint/ibm/mkinventory.c'\" unpacked with wrong size!
fi
# end of 'pint/ibm/mkinventory.c'
fi
if test -f 'pint/ibm/sm_cmd_hdr.add' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pint/ibm/sm_cmd_hdr.add'\"
else
echo shar: Extracting \"'pint/ibm/sm_cmd_hdr.add'\" \(8920 characters\)
sed "s/^X//" >'pint/ibm/sm_cmd_hdr.add' <<'END_OF_FILE'
X*
X*  PINT Pint Is Not TWAIN - common scanner driver interface for UN*X
X*  Copyright (C) 1994 Kenneth Stailey ken@spacenet.com
X*
X*  This program is free software; you can redistribute it and/or modify
X*  it under the terms of the GNU General Public License as published by
X*  the Free Software Foundation; either version 2 of the License, or
X*  (at your option) any later version.
X*
X*  This program is distributed in the hope that it will be useful,
X*  but WITHOUT ANY WARRANTY; without even the implied warranty of
X*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X*  GNU General Public License for more details.
X*
X*  You should have received a copy of the GNU General Public License
X*  along with this program; if not, write to the Free Software
X*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X*
X*  smit menus for PINT
X*  first release, version 0.1
X
Xsm_cmd_hdr:
X	id = "lsdscan"
X	option_id = ""
X	has_name_select = "n"
X	name = "List All Defined Scanners"
X	name_msg_file = "scanner.cat"
X	name_msg_set = "3"
X	name_msg_id = "1"
X	cmd_to_exec = "lsdev -C -c scanner -H"
X	ask = ""
X	exec_mode = ""
X	ghost = "y"
X	cmd_to_discover = ""
X	cmd_to_discover_postfix = ""
X	name_size = 0
X	value_size = 0
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_cmd_hdr:
X	id = "lssscan"
X	option_id = ""
X	has_name_select = "n"
X	name = "List All Supported Scanners"
X	name_msg_file = "scanner.cat"
X	name_msg_set = "3"
X	name_msg_id = "2"
X	cmd_to_exec = "lsdev -P -c scanner -F \"type subclass description\" -H"
X	ask = ""
X	exec_mode = ""
X	ghost = "y"
X	cmd_to_discover = ""
X	cmd_to_discover_postfix = ""
X	name_size = 0
X	value_size = 0
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_cmd_hdr:
X	id = "makscan_fujitsu_hdr"
X	option_id = "scan_add,scan_resolution_as_list,scan_common"
X	has_name_select = "y"
X	name = "Add a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 4
X	name_msg_id = 20
X	cmd_to_exec = "mkdev -c scanner"
X	ask = ""
X	exec_mode = ""
X	ghost = "n"
X	cmd_to_discover = "lsattr -c scanner"
X	cmd_to_discover_postfix = "-s subclass -t type -D -O"
X	name_size = 0
X	value_size = 0
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_cmd_hdr:
X	id = "makscan_ricoh_is410_hdr"
X	option_id = "scan_add,scan_common_ricoh_is410,scan_resolution_as_range,scan_common"
X	has_name_select = "y"
X	name = "Add a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 4
X	name_msg_id = 20
X	cmd_to_exec = "mkdev -c scanner"
X	ask = ""
X	exec_mode = ""
X	ghost = "n"
X	cmd_to_discover = "lsattr -c scanner"
X	cmd_to_discover_postfix = "-s subclass -t type -D -O"
X	name_size = 0
X	value_size = 0
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_cmd_hdr:
X	id = "makscan_ricoh_is50_hdr"
X	option_id = "scan_add,scan_common_ricoh_is410,scan_resolution_as_range,scan_common"
X	has_name_select = "y"
X	name = "Add a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 4
X	name_msg_id = 20
X	cmd_to_exec = "mkdev -c scanner"
X	ask = ""
X	exec_mode = ""
X	ghost = "n"
X	cmd_to_discover = "lsattr -c scanner"
X	cmd_to_discover_postfix = "-s subclass -t type -D -O"
X	name_size = 0
X	value_size = 0
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_cmd_hdr:
X	id = "makscan_ricoh_fs1_hdr"
X	option_id = "scan_add,scan_resolution_as_list,scan_common"
X	has_name_select = "y"
X	name = "Add a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 4
X	name_msg_id = 20
X	cmd_to_exec = "mkdev -c scanner"
X	ask = ""
X	exec_mode = ""
X	ghost = "n"
X	cmd_to_discover = "lsattr -c scanner"
X	cmd_to_discover_postfix = "-s subclass -t type -D -O"
X	name_size = 0
X	value_size = 0
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_cmd_hdr:
X	id = "makscan_sharp_jx600_hdr"
X	option_id = "scan_add,scan_resolution_as_list,scan_common"
X	has_name_select = "y"
X	name = "Add a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 4
X	name_msg_id = 20
X	cmd_to_exec = "mkdev -c scanner"
X	ask = ""
X	exec_mode = ""
X	ghost = "n"
X	cmd_to_discover = "lsattr -c scanner"
X	cmd_to_discover_postfix = "-s subclass -t type -D -O"
X	name_size = 0
X	value_size = 0
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_cmd_hdr:
X	id = "chgscan_fujitsu_scsi"
X	option_id = "scan_chg,scan_resolution_as_list,scan_common"
X	has_name_select = "y"
X	name = "Change/Show Characteristics of a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 27
X	name_msg_id = 1101
X	cmd_to_exec = "chdev "
X	ask = ""
X	exec_mode = "P"
X	ghost = "n"
X	cmd_to_discover = "lsattr "
X	cmd_to_discover_postfix = "-l logicname -E -O"
X	name_size = 0
X	value_size = 0
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_cmd_hdr:
X	id = "chgscan_ricoh_is410_scsi"
X	option_id = "scan_chg,scan_common,scan_common_ricoh_is410,scan_resolution_as_range"
X	has_name_select = "y"
X	name = "Change/Show Characteristics of a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 27
X	name_msg_id = 1101
X	cmd_to_exec = "chdev "
X	ask = ""
X	exec_mode = "P"
X	ghost = "n"
X	cmd_to_discover = "lsattr "
X	cmd_to_discover_postfix = "-l logicname -E -O"
X	name_size = 0
X	value_size = 0
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_cmd_hdr:
X	id = "chgscan_ibm_2456_scsi"
X	option_id = "scan_chg,scan_common,scan_common_ricoh_is410,scan_resolution_as_range"
X	has_name_select = "y"
X	name = "Change/Show Characteristics of a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 27
X	name_msg_id = 1101
X	cmd_to_exec = "chdev "
X	ask = ""
X	exec_mode = "P"
X	ghost = "n"
X	cmd_to_discover = "lsattr "
X	cmd_to_discover_postfix = "-l logicname -E -O"
X	name_size = 0
X	value_size = 0
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_cmd_hdr:
X	id = "chgscan_ricoh_is50_scsi"
X	option_id = "scan_chg,scan_common,scan_resolution_as_range,scan_common_ricoh_is410"
X	has_name_select = "y"
X	name = "Change/Show Characteristics of a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 27
X	name_msg_id = 1101
X	cmd_to_exec = "chdev "
X	ask = ""
X	exec_mode = "P"
X	ghost = "n"
X	cmd_to_discover = "lsattr "
X	cmd_to_discover_postfix = "-l logicname -E -O"
X	name_size = 0
X	value_size = 0
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_cmd_hdr:
X	id = "chgscan_ricoh_fs1_scsi"
X	option_id = "scan_chg,scan_common,scan_resolution_as_list"
X	has_name_select = "y"
X	name = "Change/Show Characteristics of a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 27
X	name_msg_id = 1101
X	cmd_to_exec = "chdev "
X	ask = ""
X	exec_mode = "P"
X	ghost = "n"
X	cmd_to_discover = "lsattr "
X	cmd_to_discover_postfix = "-l logicname -E -O"
X	name_size = 0
X	value_size = 0
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_cmd_hdr:
X	id = "chgscan_sharp_jx600_scsi"
X	option_id = "scan_chg,scan_common,scan_resolution_as_list"
X	has_name_select = "y"
X	name = "Change/Show Characteristics of a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 27
X	name_msg_id = 1101
X	cmd_to_exec = "chdev "
X	ask = ""
X	exec_mode = "P"
X	ghost = "n"
X	cmd_to_discover = "lsattr "
X	cmd_to_discover_postfix = "-l logicname -E -O"
X	name_size = 0
X	value_size = 0
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_cmd_hdr:
X	id = "chgscan_umax_uc630_scsi"
X	option_id = "scan_chg,scan_resolution_as_range,scan_common"
X	has_name_select = "y"
X	name = "Change/Show Characteristics of a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 27
X	name_msg_id = 1101
X	cmd_to_exec = "chdev "
X	ask = ""
X	exec_mode = "P"
X	ghost = "n"
X	cmd_to_discover = "lsattr "
X	cmd_to_discover_postfix = "-l logicname -E -O"
X	name_size = 0
X	value_size = 0
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_cmd_hdr:
X	id = "chgscan_umax_ug630_scsi"
X	option_id = "scan_chg,scan_resolution_as_range,scan_common"
X	has_name_select = "y"
X	name = "Change/Show Characteristics of a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 27
X	name_msg_id = 1101
X	cmd_to_exec = "chdev "
X	ask = ""
X	exec_mode = "P"
X	ghost = "n"
X	cmd_to_discover = "lsattr "
X	cmd_to_discover_postfix = "-l logicname -E -O"
X	name_size = 0
X	value_size = 0
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_cmd_hdr:
X	id = "chgscan_hp_scanjet_IIc_scsi"
X	option_id = "scan_chg,scan_common,scan_common_ricoh_is410,scan_resolution_as_range"
X	has_name_select = "y"
X	name = "Change/Show Characteristics of a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 27
X	name_msg_id = 1101
X	cmd_to_exec = "chdev "
X	ask = ""
X	exec_mode = "P"
X	ghost = "n"
X	cmd_to_discover = "lsattr "
X	cmd_to_discover_postfix = "-l logicname -E -O"
X	name_size = 0
X	value_size = 0
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_cmd_hdr:
X	id = "rmvscan_hdr"
X	option_id = "scan_rmv"
X	has_name_select = "y"
X	name = "Remove a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 0
X	name_msg_id = 0
X	cmd_to_exec = "rmdev "
X	ask = "y"
X	exec_mode = ""
X	ghost = "n"
X	cmd_to_discover = ""
X	cmd_to_discover_postfix = ""
X	name_size = 0
X	value_size = 0
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_cmd_hdr:
X	id = "cfgscan_hdr"
X	option_id = "scan_cfg"
X	has_name_select = "y"
X	name = "Configure a Defined Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 0
X	name_msg_id = 0
X	cmd_to_exec = "mkdev "
X	ask = ""
X	exec_mode = ""
X	ghost = "y"
X	cmd_to_discover = ""
X	cmd_to_discover_postfix = ""
X	name_size = 0
X	value_size = 0
X	help_msg_id = ""
X	help_msg_loc = ""
END_OF_FILE
if test 8920 -ne `wc -c <'pint/ibm/sm_cmd_hdr.add'`; then
    echo shar: \"'pint/ibm/sm_cmd_hdr.add'\" unpacked with wrong size!
fi
# end of 'pint/ibm/sm_cmd_hdr.add'
fi
if test -f 'pint/ibm/sm_name_hdr.add' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pint/ibm/sm_name_hdr.add'\"
else
echo shar: Extracting \"'pint/ibm/sm_name_hdr.add'\" \(6901 characters\)
sed "s/^X//" >'pint/ibm/sm_name_hdr.add' <<'END_OF_FILE'
X*
X*  PINT Pint Is Not TWAIN - common scanner driver interface for UN*X
X*  Copyright (C) 1994 Kenneth Stailey ken@spacenet.com
X*
X*  This program is free software; you can redistribute it and/or modify
X*  it under the terms of the GNU General Public License as published by
X*  the Free Software Foundation; either version 2 of the License, or
X*  (at your option) any later version.
X*
X*  This program is distributed in the hope that it will be useful,
X*  but WITHOUT ANY WARRANTY; without even the implied warranty of
X*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X*  GNU General Public License for more details.
X*
X*  You should have received a copy of the GNU General Public License
X*  along with this program; if not, write to the Free Software
X*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X*
X*  smit menus for PINT
X*  first release, version 0.1
X
Xsm_name_hdr:
X	id = "chgscan"
X	next_id = "chgscan_"
X	option_id = "scanner_ln_opt"
X	has_name_select = "n"
X	name = "Change / Show Characteristics of a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 4
X	name_msg_id = 2
X	type = "c"
X	ghost = "y"
X	cmd_to_classify = "xx () \n\
X{ \n\
Xlsdev -C -l $1 -F \"type:subclass:parent:connwhere:location:status:description\"   | sed 's/^\\([^:]*\\):\\([^:]*\\):/\\1_\\2:&/' \n\
X} \n\
Xxx "
X	cmd_to_classify_postfix = " logicname "
X	raw_field_name = "logicname"
X	cooked_field_name = "_cookedname:type:subclass:parent:port:loc:state:desc"
X	next_type = "d"
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_name_hdr:
X	id = "cfgscan"
X	next_id = "cfgscan_hdr"
X	option_id = "scanner_ln_opt"
X	has_name_select = "n"
X	name = "Configure a Defined Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 4
X	name_msg_id = 3
X	type = ""
X	ghost = "y"
X	cmd_to_classify = ""
X	cmd_to_classify_postfix = ""
X	raw_field_name = "logicname"
X	cooked_field_name = ""
X	next_type = "d"
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_name_hdr:
X	id = "rmvscan"
X	next_id = "rmvscan_hdr"
X	option_id = "scanner_ln_opt"
X	has_name_select = "n"
X	name = "Remove a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 4
X	name_msg_id = 4
X	type = ""
X	ghost = "y"
X	cmd_to_classify = ""
X	cmd_to_classify_postfix = ""
X	raw_field_name = "logicname"
X	cooked_field_name = ""
X	next_type = "d"
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_name_hdr:
X	id = "makscan"
X	next_id = "makscan_"
X	option_id = "scanner_predef_opt"
X	has_name_select = "n"
X	name = "Add a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 4
X	name_msg_id = 1
X	type = "c"
X	ghost = "y"
X	cmd_to_classify = "class () # str1 str2 str3\n\
X{\n\
Xecho $1 | sed 's/^\\([^ ]*\\)[ ]*\\([^ ]*\\)[ ]*/\\1_\\2:\\1:\\2:/'\n\
X}\n\
Xclass "
X	cmd_to_classify_postfix = "_rawname"
X	raw_field_name = ""
X	cooked_field_name = "_cookedname:type:subclass:desc"
X	next_type = "n"
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_name_hdr:
X	id = "makscan_scsi"
X	next_id = "makscan_scsi_hdr"
X	option_id = "makscan_parent_opt"
X	has_name_select = "y"
X	name = "Add a Scanner"
X	name_msg_file = "smit.cat"
X	name_msg_set = 4
X	name_msg_id = 6
X	type = ""
X	ghost = "y"
X	cmd_to_classify = ""
X	cmd_to_classify_postfix = ""
X	raw_field_name = "parent"
X	cooked_field_name = ""
X	next_type = "d"
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_name_hdr:
X	id = "makscan_fujitsu_scsi"
X	next_id = "makscan_fujitsu_hdr"
X	option_id = "makscan_parent_opt"
X	has_name_select = "y"
X	name = "Add a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 4
X	name_msg_id = 1
X	type = ""
X	ghost = "y"
X	cmd_to_classify = ""
X	cmd_to_classify_postfix = ""
X	raw_field_name = "parent"
X	cooked_field_name = ""
X	next_type = "d"
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_name_hdr:
X	id = "makscan_ricoh_is410_scsi"
X	next_id = "makscan_ricoh_is410_hdr"
X	option_id = "makscan_parent_opt"
X	has_name_select = "y"
X	name = "Add a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 4
X	name_msg_id = 1
X	type = ""
X	ghost = "y"
X	cmd_to_classify = ""
X	cmd_to_classify_postfix = ""
X	raw_field_name = "parent"
X	cooked_field_name = ""
X	next_type = "d"
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_name_hdr:
X	id = "makscan_ibm_2456_scsi"
X	next_id = "makscan_ricoh_is410_hdr"
X	option_id = "makscan_parent_opt"
X	has_name_select = "y"
X	name = "Add a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 4
X	name_msg_id = 1
X	type = ""
X	ghost = "y"
X	cmd_to_classify = ""
X	cmd_to_classify_postfix = ""
X	raw_field_name = "parent"
X	cooked_field_name = ""
X	next_type = "d"
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_name_hdr:
X	id = "makscan_ricoh_is50_scsi"
X	next_id = "makscan_ricoh_is50_hdr"
X	option_id = "makscan_parent_opt"
X	has_name_select = "y"
X	name = "Add a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 4
X	name_msg_id = 1
X	type = ""
X	ghost = "y"
X	cmd_to_classify = ""
X	cmd_to_classify_postfix = ""
X	raw_field_name = "parent"
X	cooked_field_name = ""
X	next_type = "d"
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_name_hdr:
X	id = "makscan_ricoh_fs1_scsi"
X	next_id = "makscan_ricoh_fs1_hdr"
X	option_id = "makscan_parent_opt"
X	has_name_select = "y"
X	name = "Add a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 4
X	name_msg_id = 1
X	type = ""
X	ghost = "y"
X	cmd_to_classify = ""
X	cmd_to_classify_postfix = ""
X	raw_field_name = "parent"
X	cooked_field_name = ""
X	next_type = "d"
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_name_hdr:
X	id = "makscan_sharp_jx600_scsi"
X	next_id = "makscan_sharp_jx600_hdr"
X	option_id = "makscan_parent_opt"
X	has_name_select = "y"
X	name = "Add a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 4
X	name_msg_id = 1
X	type = ""
X	ghost = "y"
X	cmd_to_classify = ""
X	cmd_to_classify_postfix = ""
X	raw_field_name = "parent"
X	cooked_field_name = ""
X	next_type = "d"
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_name_hdr:
X	id = "makscan_umax_uc630_scsi"
X	next_id = "makscan_ricoh_is410_hdr"
X	option_id = "makscan_parent_opt"
X	has_name_select = "y"
X	name = "Add a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 4
X	name_msg_id = 1
X	type = ""
X	ghost = "y"
X	cmd_to_classify = ""
X	cmd_to_classify_postfix = ""
X	raw_field_name = "parent"
X	cooked_field_name = ""
X	next_type = "d"
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_name_hdr:
X	id = "makscan_umax_ug630_scsi"
X	next_id = "makscan_ricoh_is410_hdr"
X	option_id = "makscan_parent_opt"
X	has_name_select = "y"
X	name = "Add a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 4
X	name_msg_id = 1
X	type = ""
X	ghost = "y"
X	cmd_to_classify = ""
X	cmd_to_classify_postfix = ""
X	raw_field_name = "parent"
X	cooked_field_name = ""
X	next_type = "d"
X	help_msg_id = ""
X	help_msg_loc = ""
X
Xsm_name_hdr:
X	id = "makscan_hp_scanjet_IIc_scsi"
X	next_id = "makscan_ricoh_is410_hdr"
X	option_id = "makscan_parent_opt"
X	has_name_select = "y"
X	name = "Add a Scanner"
X	name_msg_file = "scanner.cat"
X	name_msg_set = 4
X	name_msg_id = 1
X	type = ""
X	ghost = "y"
X	cmd_to_classify = ""
X	cmd_to_classify_postfix = ""
X	raw_field_name = "parent"
X	cooked_field_name = ""
X	next_type = "d"
X	help_msg_id = ""
X	help_msg_loc = ""
END_OF_FILE
if test 6901 -ne `wc -c <'pint/ibm/sm_name_hdr.add'`; then
    echo shar: \"'pint/ibm/sm_name_hdr.add'\" unpacked with wrong size!
fi
# end of 'pint/ibm/sm_name_hdr.add'
fi
if test -f 'pint/ibm/ucfgscan.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pint/ibm/ucfgscan.c'\"
else
echo shar: Extracting \"'pint/ibm/ucfgscan.c'\" \(4425 characters\)
sed "s/^X//" >'pint/ibm/ucfgscan.c' <<'END_OF_FILE'
X/*
X *  PINT Pint Is Not TWAIN - common scanner driver interface for UN*X
X *  Copyright (C) 1994 Kenneth Stailey ken@spacenet.com
X *
X *  This program is free software; you can redistribute it and/or modify
X *  it under the terms of the GNU General Public License as published by
X *  the Free Software Foundation; either version 2 of the License, or
X *  (at your option) any later version.
X *
X *  This program is distributed in the hope that it will be useful,
X *  but WITHOUT ANY WARRANTY; without even the implied warranty of
X *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *  GNU General Public License for more details.
X *
X *  You should have received a copy of the GNU General Public License
X *  along with this program; if not, write to the Free Software
X *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X/* 
X * unconfigure method for PINT
X * first release, version 0.1
X */
X
X#include <sys/types.h> 
X#include <sys/cfgdb.h> 
X#include <sys/cfgodm.h>
X#include <sys/sysconfig.h>
X#include <sys/device.h>
X#include <sys/mode.h>
X#include <sys/errno.h>
X#include <stdlib.h>
X#include <stdio.h>
X#include <cf.h>
X
X#define USAGE(S)      (fprintf(stderr, "Usage: %s -l name\n", (S)), exit(E_ARGS))
X
Xint		lock_id;
X
Xclose_odm_exit(err)
X{
X  odm_unlock(lock_id);
X  odm_terminate();
X
X  exit(err);
X}
X
X
Xmain(int argc, char *argv[])
X{
X  struct cfg_dd	cfg;
X  struct cfg_load unload;
X  struct PdDv	pddv;
X  struct CuDv	cudv;
X  char	 search_string[0x100];
X  char   *logical_name = NULL;
X  char   *odm_path;		/* the ODM directory */
X  char   odm_lock_path[1024];	/* the ODM configure lock file */
X  char   devpath[0x100];
X  long	 majorno, minor;
X  int    how_many;
X  int    c;			/* for command line processing */
X
X  extern int   optind;		/* for getopt() */
X  extern char *optarg;		/* ditto */
X
X
X  /****  command line argument processing section  ***/
X
X  while ((c = getopt(argc, argv, "l:")) != EOF) {
X    switch (c) {
X    case 'l':
X      if (logical_name != NULL)
X	USAGE(*argv);
X      logical_name = optarg;
X      break;
X    default:
X      USAGE(*argv);
X    }
X  }
X
X  if (logical_name == NULL) /* must have a logical device name */
X    USAGE(*argv);
X
X
X  /****   bring up & lock the ODM  ***/
X
X  if (odm_initialize() < 0)
X    exit(E_ODMINIT);
X
X  if ((odm_path = getenv("ODMDIR")) == NULL) {
X    fprintf(stderr, "%s: ODMDIR environment variable is undefined.\n", argv[0]);
X    exit(E_ODMLOCK);
X  }
X  strcpy(odm_lock_path, odm_path);
X  strcat(odm_lock_path, "/config_lock");
X  if ((lock_id = odm_lock(odm_lock_path, 10)) == -1)
X    close_odm_exit(E_ODMLOCK);
X
X
X  /****  get the CuDv entry with our logical_name  ***/
X
X  sprintf(search_string, "name = '%s'", logical_name);
X  switch ((int)odm_get_first(CuDv_CLASS, search_string, &cudv))	{
X  case 0:
X    close_odm_exit(E_NOCuDv);
X  case -1:
X    close_odm_exit(E_ODMGET);
X  }
X
X
X  /**** if the device is in state DEFINED, then no unconfigure work to do   ***/
X
X  if (cudv.status == (short)DEFINED)
X    close_odm_exit(E_OK);
X
X
X  /****   get the PreDefined data from the ODM  ***/
X
X  sprintf(search_string, "uniquetype = '%s'", cudv.PdDvLn_Lvalue);
X  switch ((int)odm_get_first(PdDv_CLASS, search_string, &pddv))	{
X  case 0:
X    close_odm_exit(E_NOPdDv);
X  case -1:
X    close_odm_exit(E_ODMGET);
X  }
X
X
X  /****   remove the special file   ***/
X
X  sprintf(devpath, "/dev/%s", cudv.name);
X  if (unlink(devpath) < 0 && errno != ENOENT)
X    close_odm_exit(E_RMSPECIAL);
X
X  /*   get the kmid   */
X
X  unload.path = "/etc/drivers/scandd";
X  unload.libpath = "";
X  unload.kmid = 0;
X
X  if (sysconfig(SYS_QUERYLOAD, &unload, sizeof(unload)) == CONF_FAIL) {
X    fprintf(stderr, "sysconfig: query failed %d\n", errno);
X    exit(errno);
X  }
X
X  if (*pddv.DvDr != 0) {
X
X    if ((majorno = genmajor(pddv.DvDr)) == -1)
X      close_odm_exit(E_MAJORNO);
X
X    /* your minor is your logical name's number */
X
X    minor = atol(&logical_name[4]);
X    
X    cfg.devno  = makedev(majorno, minor);
X    cfg.kmid   = unload.kmid;
X    cfg.ddsptr = NULL;
X    cfg.ddslen = 0;
X    cfg.cmd    = CFG_TERM;
X
X    if (sysconfig(SYS_CFGDD, &cfg, sizeof(struct cfg_dd)) == -1)
X      close_odm_exit(E_CFGTERM);
X
X    if (loadext(pddv.DvDr, FALSE, FALSE) == NULL)
X      close_odm_exit(E_UNLOADEXT);
X  } else {
X#ifdef DEBUG
X    fprintf(stderr, "ucfgscan: *pddv.DvDr == 0\n");
X#endif
X  }
X
X  cudv.status = DEFINED;
X  if (odm_change_obj(CuDv_CLASS, &cudv) < 0)
X    close_odm_exit(E_ODMUPDATE);
X
X  close_odm_exit(E_OK);
X}
END_OF_FILE
if test 4425 -ne `wc -c <'pint/ibm/ucfgscan.c'`; then
    echo shar: \"'pint/ibm/ucfgscan.c'\" unpacked with wrong size!
fi
# end of 'pint/ibm/ucfgscan.c'
fi
if test -f 'pint/sun/dist/confmod.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pint/sun/dist/confmod.c'\"
else
echo shar: Extracting \"'pint/sun/dist/confmod.c'\" \(4215 characters\)
sed "s/^X//" >'pint/sun/dist/confmod.c' <<'END_OF_FILE'
X/*
X *  PINT Pint Is Not TWAIN - common scanner driver interface for UN*X
X *  Copyright (C) 1994 Kenneth Stailey ken@spacenet.com
X *
X *  This program is free software; you can redistribute it and/or modify
X *  it under the terms of the GNU General Public License as published by
X *  the Free Software Foundation; either version 2 of the License, or
X *  (at your option) any later version.
X *
X *  This program is distributed in the hope that it will be useful,
X *  but WITHOUT ANY WARRANTY; without even the implied warranty of
X *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *  GNU General Public License for more details.
X *
X *  You should have received a copy of the GNU General Public License
X *  along with this program; if not, write to the Free Software
X *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X/* Attempt to modify "conf" file automatically.
X * Maybe this should be done using a scripting language like awk, sed or perl.
X */
X
X#include <stdlib.h>
X#include <string.h>
X#include <stdio.h>
X#include <fcntl.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X
Xchar *prog_name;
X
Xchar *readconf(filename)
Xchar *filename;
X{
X  struct stat stat_buf;
X  char *buf;
X  int fd;
X
X  if (stat(filename, &stat_buf) < 0) {
X    perror("stat failed");
X    fprintf(stderr, "%s: can't stat %s", prog_name, filename);
X    exit(0);
X  }
X
X  if ((buf = malloc(stat_buf.st_size + 1)) == NULL) {
X    perror("malloc failed");
X    fprintf(stderr, "%s: malloc failed", prog_name);
X    exit(0);
X  }
X
X  if ((fd = open(filename, O_RDONLY)) < 0) {
X    perror("open failed");
X    fprintf(stderr, "%s: can't open %s", prog_name, filename);
X    exit(0);
X  }
X
X  if (read(fd, buf, stat_buf.st_size) != stat_buf.st_size) {
X    perror("read failed");
X    fprintf(stderr, "%s: can't read %s", prog_name, filename);
X    exit(0);
X  }
X
X  buf[stat_buf.st_size] = '\0';
X  close(fd);
X  return(buf);
X}
X
Xvoid write_defines(out)
XFILE *out;
X{
X  fprintf(out, "#include \"scan.h\"\n");
X  fprintf(out, "#if NSCAN > 0\n");
X  fprintf(out, "extern int scanopen(), scanclose(), scanread(), scanioctl();\n");
X  fprintf(out, "#else\n");
X  fprintf(out, "#define scanopen  nodev\n");
X  fprintf(out, "#define scanclose nodev\n");
X  fprintf(out, "#define scanread  nodev\n");
X  fprintf(out, "#define scanioctl nodev\n");
X  fprintf(out, "#endif\n\n");
X}
X
Xvoid write_cdevsw_stuff(out, n)
XFILE *out;
Xint n;
X{
X  fprintf(out, "    {\n");
X  fprintf(out, "\tscanopen,\tscanclose,\tscanread,\tnodev,\t\t/*%d*/\n", n);
X  fprintf(out, "\tscanioctl,\tnodev,\t\tnodev,\t\t0,\n");
X  fprintf(out, "\t0,\t\t0,\n");
X  fprintf(out, "    },\n");
X}
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X  enum actions { append, search } action;
X  char numeral[10];
X  char *conf_buf;
X  char *seltrue_spot;
X  char *p, *q;
X  FILE *out;
X  int last_major;
X  int commas;
X
X  if (argc != 4) {
X    fprintf(stderr, "%s: bad arguments\n", argv[0]);
X    exit(0);
X  }
X
X  prog_name = argv[0];
X
X  switch (argv[3][0]) {
X  case 'a':
X    action = append;
X    break;
X  case 't':
X    action = search;
X    break;
X  default:
X    fprintf(stderr, "%s: bad action (not a or t)\n", argv[0]);
X    exit(0);
X  }
X
X  if (action == append) {
X    if ((out = fopen(argv[2], "w")) == NULL) {
X      perror("open failed");
X      fprintf(stderr, "%s: can't open %s for writing\n", argv[0], argv[2]);
X      exit(0);
X    }
X  }
X
X  conf_buf = readconf(argv[1]);
X
X  if ((seltrue_spot = strstr(conf_buf, "extern int seltrue")) == NULL) {
X    fprintf(stderr, "%s: can't find 'extern int seltrue' in %s\n", argv[0], argv[1]);
X    exit(0);
X  }
X
X  if (action == append) {
X    *seltrue_spot = '\0';
X    fprintf(out, "%s", conf_buf);
X    *seltrue_spot = 'e';
X    write_defines(out);
X  }
X
X  p = strstr(seltrue_spot, "struct cdevsw");
X  p = strstr(p, "};");
X  commas = 8;
X  while (commas) {
X    --p;
X    if (*p == ',')
X      --commas;
X  }
X  p = strstr(p, "/*");
X  p += 2;
X  q = numeral;
X  while (isdigit(*p))
X    *q++ = *p++;
X  sscanf(numeral, "%d", &last_major);
X
X  if (action == append) {
X    p = strstr(p, "}");
X    ++p;
X    *p = '\0';
X    fprintf(out, "%s,\n", seltrue_spot);
X    ++p;
X    ++last_major;
X    write_cdevsw_stuff(out, last_major);
X    fprintf(out, "%s", p);
X    fclose(out);
X  }
X
X  exit(last_major);
X}
END_OF_FILE
if test 4215 -ne `wc -c <'pint/sun/dist/confmod.c'`; then
    echo shar: \"'pint/sun/dist/confmod.c'\" unpacked with wrong size!
fi
# end of 'pint/sun/dist/confmod.c'
fi
if test -f 'pint/sun/driver/scandd.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pint/sun/driver/scandd.h'\"
else
echo shar: Extracting \"'pint/sun/driver/scandd.h'\" \(5025 characters\)
sed "s/^X//" >'pint/sun/driver/scandd.h' <<'END_OF_FILE'
X/*
X *  PINT Pint Is Not TWAIN - common scanner driver interface for UN*X
X *  Copyright (C) 1994 Kenneth Stailey ken@spacenet.com
X *
X *  This program is free software; you can redistribute it and/or modify
X *  it under the terms of the GNU General Public License as published by
X *  the Free Software Foundation; either version 2 of the License, or
X *  (at your option) any later version.
X *
X *  This program is distributed in the hope that it will be useful,
X *  but WITHOUT ANY WARRANTY; without even the implied warranty of
X *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *  GNU General Public License for more details.
X *
X *  You should have received a copy of the GNU General Public License
X *  along with this program; if not, write to the Free Software
X *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X/*
X * scandd.h include file for PINT scanner driver for SunOS 4.1
X * first release version 0.1
X */
X
X/************************************************************************
X *									*
X * Defines for SCSI generic device driver				*
X *									*
X ***********************************************************************/
X
X/*
X * Define various buffer and I/O block sizes
X */
X
X#define SECSIZE			512		/* Bytes/sector */
X#define SECDIV			9		/* log2 (SECSIZE) */
X#define UN_TMPBUF_SIZE		SECSIZE		/* For internal DVMA */
X
X/************************************************************************
X *									*
X * Private data structure. Pointed to by the un_private pointer		*
X * of one of the SCSI_DEVICE structures.				*
X *									*
X ************************************************************************/
X
Xstruct scsi_scan {
X  struct  scsi_device *un_sd;	/* back pointer to SCSI_DEVICE */
X  struct  scsi_pkt *un_rsp;	/* ptr to request sense command pkt */
X  struct  buf *un_rbufp;	/* for use in raw io */
X  struct  buf *un_sbufp;	/* for use in special io */
X  u_int	  un_err_resid;		/* resid from last error */
X  u_char  un_err_severe;	/* error severity */
X  u_char  un_status;		/* sense key from last error */
X  u_char  un_err_code;		/* vendor unique error code  */
X  u_char  un_retries;		/* retry count */
X  u_char  un_state;		/* current state */
X  u_char  un_last_state;	/* last state */
X  u_int	  un_attached;		/* device attached flag */
X  u_char  un_triggered;		/* set window, & read trigger sent */
X  u_short un_bufcnt;		/* count of bufs on un_quehd */
X  u_long  window_size;		/* size of scanner active area in bytes */
X  struct  buf *un_quehd;	/* list of pending requests */
X  struct  buf *un_quetl;	/* last buf on queue */
X  struct  buf *un_active;	/* currently active request */
X  struct  scancmd un_ucmd;	/* for SCANIOC_CMD */
X  struct  scan_io sio;		/* scanner parameters */
X  u_char  using_adf;		/* umax is/was using ADF for read */
X  u_char  buf_status[3];	/* for Ricoh SCMD_GET_BUFFER_STATUS command */
X  enum   adf_states {
X    ADF_UNUSED,			/* scan from flatbed, not ADF             */
X    ADF_ARMED,			/* scan from ADF, everything's set up     */
X    ADF_CLEANUP,		/* eject paper from ADF on close          */
X  } adf_state;
X  caddr_t un_tmpbuf;		/* local buffer */
X};
X
X/* defines for image modes */
X
X#define BINARY_MONOCHROME   0
X#define DITHERED_MONOCHROME 1
X#define GRAYSCALE 2
X#define COLOR 5
X#define RED   103
X#define GREEN 104
X#define BLUE  105
X
X#define SCANNING_MEASUREMENT_PARAMETERS (uchar)(3)
X#define ADF_CONTROL (uchar)(0x26)
X
X/* sizes for mode parameter's base_measurement_unit */
X
X#define INCHES 0
X#define MILLIMETERS 1
X#define POINTS 2
X
X/*
X *  SCSI_MODE_SELECT parameter list
X */
Xstruct ricoh_mode_params {
X  /* header */
X  uchar mode_data_length;
X  uchar medium_type;
X  uchar device_specific_parameter;
X  uchar block_descriptor_length;
X
X  /* page descriptor */
X  uchar page_code;
X  uchar paramter_length;
X  uchar base_measurement_unit;
X  uchar reserved1;
X  uchar measurement_unit_devisor_msb;
X  uchar measurement_unit_devisor_lsb;
X  uchar reserved2;
X  uchar reserved3;
X
X  /* ADF support */
X  uchar adf_page_code;
X  uchar adf_parameter_length;
X  uchar adf_control;
X  uchar reserved4;
X  uchar reserved5;
X  uchar reserved6;
X  uchar reserved7;
X  uchar reserved8;
X};
X
X/*
X * Driver states
X */
X
X#define	SCAN_STATE_NIL		0
X#define	SCAN_STATE_CLOSED	1
X#define	SCAN_STATE_OPENING	2
X#define	SCAN_STATE_OPEN		3
X#define	SCAN_STATE_SENSING	4
X#define	SCAN_STATE_RWAIT	5
X#define	SCAN_STATE_DETACHED	6
X
X/*
X * Error levels
X */
X
X#define	SCANERR_ALL		0
X#define	SCANERR_UNKNOWN		1
X#define	SCANERR_INFORMATIONAL	2
X#define	SCANERR_RECOVERED	3
X#define	SCANERR_RETRYABLE	4
X#define	SCANERR_FATAL		5
X
X/*
X * scanintr codes
X */
X
X#define	COMMAND_DONE		0
X#define	COMMAND_DONE_ERROR	1
X#define	QUE_COMMAND		2
X#define	QUE_SENSE		3
X#define	JUST_RETURN		4
X
X/*
X * scanner specific commands
X */
X#define SCMD_TRIGGER_SCAN       0x1b
X#define SCMD_SET_WINDOW         0x24
X#define SCMD_OBJECT_POSITION    0x31
X#define SCMD_GET_BUFFER_STATUS  0x34
X/*
X * Special fake command to tag a user defined command
X */
X#define SCMD_UCMD	0xFF
X
X/*
X *  ADF codes
X */
X#define UNLOAD_ADF 0
X#define LOAD_ADF 1
END_OF_FILE
if test 5025 -ne `wc -c <'pint/sun/driver/scandd.h'`; then
    echo shar: \"'pint/sun/driver/scandd.h'\" unpacked with wrong size!
fi
# end of 'pint/sun/driver/scandd.h'
fi
if test -f 'pint/sun/misc/SCANNER' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pint/sun/misc/SCANNER'\"
else
echo shar: Extracting \"'pint/sun/misc/SCANNER'\" \(7777 characters\)
sed "s/^X//" >'pint/sun/misc/SCANNER' <<'END_OF_FILE'
X#
X# SCANNER - SunOS 4.1.x kernal configure file
X# derived from master 1.47 91/08/05 SMI
X#
X# (search for "scan")
X#
X# This config file describes a generic Sun-4c kernel, including all
X# possible standard devices and software options.
X#
X# The following lines include support for all Sun-4c CPU types.
X# There is little to be gained by removing support for particular
X# CPUs, so you might as well leave them all in.
X#
Xmachine		"sun4c"
Xcpu		"SUN4C_60"	# Sun-4/60  (it's really for all the Sun-4c's)
X
X#
X# Name this kernel SCANNER.
X#
Xident		"SCANNER"
X
X#
X# This kernel supports about 8 users.  Count one user for each
X# timesharing user, one for each window that you typically use, and one
X# for each diskless client you serve.  This is only an approximation used
X# to control the size of various kernel data structures, not a hard limit.
X#
Xmaxusers	8
X
X#
X# Include all possible software options.
X#
X# The INET option is not really optional; every kernel must include it.
X#
Xoptions	INET		# basic networking support - mandatory
X
X#
X# The following options are all filesystem related.  You only need
X# QUOTA if you have UFS.  You only need UFS if you have a disk.
X# Diskless machines can remove QUOTA, UFS, and NFSSERVER.  LOFS and TFS
X# are only needed if you're using the Sun Network Software Environment.
X# HSFS is only needed if you have a CD-ROM drive and want to access
X# ISO-9660, High Sierra, or Rock Ridge format CD discs.
X#
Xoptions	QUOTA		# disk quotas for local disks
Xoptions	UFS		# filesystem code for local disks
Xoptions	NFSCLIENT	# NFS client side code
Xoptions	NFSSERVER	# NFS server side code
Xoptions	LOFS		# loopback filesystem - needed by NSE
Xoptions	TFS		# translucent filesystem - needed by NSE
Xoptions	TMPFS		# tmp (anonymous memory) file system
X#options	HSFS		# High Sierra (ISO 9660) with Rock Ridge extensions CD-ROM file system
Xoptions	PCFS		# Unix access to MS-DOS file system
X
X#
X# The following options are for accounting and auditing.  SYSAUDIT
X# should be removed unless you are using the C2 security features.
X#
Xoptions	SYSACCT		# process accounting, see acct(2) & sa(8)
X#options	SYSAUDIT	# C2 auditing for security
X
X#
X# The following options are for various System V IPC facilities.
X# Most standard software does not need them, although they are
X# used by SunGKS and some third-party software.
X#
X#options	IPCMESSAGE	# System V IPC message facility
X#options	IPCSEMAPHORE	# System V IPC semaphore facility
X#options	IPCSHMEM	# System V IPC shared-memory facility
X
X#
X# The following option is only needed if you want to use the trpt
X# command to debug TCP problems.
X#
X#options	TCPDEBUG	# TCP debugging, see trpt(8)
X
X#
X# The following option includes the software DES support, needed if
X# you're using secure NFS or secure RPC.
X#
X#options	CRYPT		# software encryption
X
X#
X# The following two options are only needed if you want to use RFS.
X#
X#options	RFS
X#options	VFSSTATS
X
X#
X# The following two options are needed for asynchronous I/O.
X#
Xoptions	LWP		# kernel threads
Xoptions	ASYNCHIO	# asynch I/O (requires LWP)
X
X#
X# The following option adds support for loadable kernel modules.
X#
Xoptions	VDDRV		# loadable modules
X
X#
X# The following option adds support for SunView 1 journaling.
X#
X#options	WINSVJ		# SunView 1 journaling support
X
X#
X# Build one kernel based on this basic configuration.
X# It will use the generic swap code so that you can have
X# your root filesystem and swap space on any supported device.
X# Put the kernel configured this way in a file named "vmunix".
X#
Xconfig	vmunix	swap generic
X
X#
X# Include support for all possible pseudo-devices.
X#
X# The first few are mostly concerned with networking.
X# You should probably always leave these in.
X#
Xpseudo-device	pty		# pseudo-tty's, also needed for SunView
Xpseudo-device	ether		# basic Ethernet support
Xpseudo-device	loop		# loopback network - mandatory
X
X#
X# The next few are for SunWindows support, needed to run SunView 1.
X#
Xpseudo-device	win128		# window devices, allow 128 windows
Xpseudo-device	dtop4		# desktops (screens), allow 4
Xpseudo-device	ms		# mouse support
X
X#
X# The following is needed to support the Sun keyboard, with or
X# without the window system.
X#
Xpseudo-device	kb		# keyboard support
X
X#
X# The "open EEPROM" pseudo-device is required to support the
X# eeprom command.
X#
Xpseudo-device	openeepr	# onboard configuration NVRAM
X
X#
X# The following is needed to support the Sun dialbox.
X#
X#pseudo-device	db	# dialbox support
X
X#
X# The following is for the streams pipe device, which is required by RFS.
X#
X#pseudo-device	sp		# streams pipe device
X
X#
X# The following are for streams NIT support.  NIT is used by
X# etherfind, traffic, rarpd, and ndbootd.  As a rule of thumb,
X# NIT is almost always needed on a server and almost never
X# needed on a diskless client.
X#
Xpseudo-device	snit		# streams NIT
Xpseudo-device	pf		# packet filter
Xpseudo-device	nbuf		# NIT buffering module
X
X#
X# The following is for the "clone" device, used with streams devices.
X# This is required if you include streams NIT support, RFS, or an audio
X# device.
X#
Xpseudo-device	clone		# clone device
X
X#
X# The following is for TLI. Include these if you want to use RFS and/or
X# the TLI library.
X#
Xpseudo-device	tim64
Xpseudo-device	tirw64
X
X#
X# The following is for the TCP TLI stream head. This provides a TLI-conforming
X# interface on top of which you can run RFS and/or the TLI library. This is
X# required by RFS.
X#
Xpseudo-device	tcptli32
X
X#
X# The following section describes which standard device drivers this
X# kernel supports.
X#
Xdevice-driver	sbus		# 'driver' for sbus interface
X#device-driver	bwtwo		# monochrome frame buffer
X#device-driver	cgthree		# 8-bit color frame buffer
Xdevice-driver	cgsix		# 8-bit accelerated color frame buffer
X#device-driver	cgtwelve	# 24-bit accelerated color frame buffer
X#device-driver	gt		# double-buffered 24-bit graphics accelerator
Xdevice-driver	dma		# 'driver' for dma engine on sbus interface
Xdevice-driver	esp		# Emulex SCSI interface
Xdevice-driver	fd		# Floppy disk
Xdevice-driver	audioamd	# AMD79C30A sound chip
Xdevice-driver	lebuf		# ethernet buffer
Xdevice-driver	le		# LANCE ethernet
Xdevice-driver	zs		# UARTs
X
X#
X# The following section describes SCSI device unit assignments.
X#
Xscsibus0 at esp				# declare first scsi bus
Xdisk sd0 at scsibus0 target 3 lun 0	# first hard SCSI disk
Xdisk sd1 at scsibus0 target 1 lun 0	# second hard SCSI disk
Xdisk sd2 at scsibus0 target 2 lun 0	# third hard SCSI disk
Xdisk sd3 at scsibus0 target 0 lun 0	# fourth hard SCSI disk
X#tape st0 at scsibus0 target 4 lun 0	# first SCSI tape
X#tape st1 at scsibus0 target 5 lun 0	# second SCSI tape
Xdevice scan0 at scsibus0 target 4 lun 0	# first SCSI scanner
Xtape st0 at scsibus0 target 5 lun 0	# first SCSI tape
Xdisk sr0 at scsibus0 target 6 lun 0	# CD-ROM device
X
Xscsibus1 at esp				# declare second scsi bus
Xdisk sd4 at scsibus1 target 3 lun 0	# fifth hard SCSI disk
Xdisk sd5 at scsibus1 target 1 lun 0	# sixth hard SCSI disk
Xdisk sd6 at scsibus1 target 2 lun 0	# seventh hard SCSI disk
Xdisk sd7 at scsibus1 target 0 lun 0	# eighth hard SCSI disk
Xtape st2 at scsibus1 target 4 lun 0	# third SCSI tape
Xtape st3 at scsibus1 target 5 lun 0	# fourth SCSI tape
Xdisk sr1 at scsibus1 target 6 lun 0	# 2nd CD-ROM device
X
Xscsibus2 at esp				# declare third scsi bus
Xdisk sd8 at scsibus2 target 3 lun 0	# ninth hard SCSI disk
Xdisk sd9 at scsibus2 target 1 lun 0	# tenth hard SCSI disk
Xdisk sd10 at scsibus2 target 2 lun 0	# eleventh hard SCSI disk
Xdisk sd11 at scsibus2 target 0 lun 0	# twelfth hard SCSI disk
X
Xscsibus3 at esp				# declare fourth scsi bus
Xdisk sd12 at scsibus3 target 3 lun 0	# thirteenth hard SCSI disk
Xdisk sd13 at scsibus3 target 1 lun 0	# fourteenth hard SCSI disk
Xdisk sd14 at scsibus3 target 2 lun 0	# fifteenth hard SCSI disk
Xdisk sd15 at scsibus3 target 0 lun 0	# sixteenth hard SCSI disk
X
END_OF_FILE
if test 7777 -ne `wc -c <'pint/sun/misc/SCANNER'`; then
    echo shar: \"'pint/sun/misc/SCANNER'\" unpacked with wrong size!
fi
# end of 'pint/sun/misc/SCANNER'
fi
if test -f 'pint/sun/misc/files.scan' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pint/sun/misc/files.scan'\"
else
echo shar: Extracting \"'pint/sun/misc/files.scan'\" \(10394 characters\)
sed "s/^X//" >'pint/sun/misc/files.scan' <<'END_OF_FILE'
X#
X#  PINT (Pint Is Not TWAIN) - common scanner driver interface for UN*X
X#  Copyright (C) 1994 Kenneth Stailey ken@spacenet.com
X#
X#  This program is free software; you can redistribute it and/or modify
X#  it under the terms of the GNU General Public License as published by
X#  the Free Software Foundation; either version 2 of the License, or
X#  (at your option) any later version.
X#
X#  This program is distributed in the hope that it will be useful,
X#  but WITHOUT ANY WARRANTY; without even the implied warranty of
X#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#  GNU General Public License for more details.
X#
X#  You should have received a copy of the GNU General Public License
X#  along with this program; if not, write to the Free Software
X#  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# files.scane "files" file customized for SCSI PINT scanner driver
X# based on files 1.60 92/04/07 SMI
X#
Xinclude ../../conf.common/files.cmn
X#
X# Only one of i386dev,sbusdev, and sundev/fd.c should be defined
X#
X#i386dev/fd.c		optional fd device-driver not-supported
Xi386dev/hd.c		optional hd device-driver not-supported
Xi386dev/pp.c		optional pp device-driver not-supported
Xi386dev/wds.c		optional wds device-driver not-supported
Xpixrect/../gt/gt_colormap.c	optional win gt device-driver
Xpixrect/../gt/gt_ioctl.c	optional win gt device-driver
Xpixrect/../gt/gt_rop.c	  	optional win gt device-driver
Xpixrect/../cg12/cg12_colormap.c	optional win cgtwelve device-driver
Xpixrect/../cg12/cg12_ioctl.c	optional win cgtwelve device-driver
Xpixrect/../mem/mem_colormap.c	optional win device-driver
Xpixrect/../mem/mem_kern.c	optional win device-driver
Xpixrect/../mem/mem_rop.c	optional win device-driver
Xpixrect/../pr/pr_clip.c		optional win device-driver
Xpixrect/../pr/pr_dblbuf.c	optional win device-driver
Xpixrect/../pr/pr_plngrp.c	optional win device-driver
X#
Xsbusdev/aclone.c	standard device-driver
Xsbusdev/audio.c		standard 
X#
Xsbusdev/audio_79C30.c	optional audioamd device-driver
Xsbusdev/dbri.c		optional dbri device-driver not-supported
Xsbusdev/dbri_conf.c	optional dbri device-driver not-supported
Xsbusdev/dbri_driver.c	optional dbri device-driver not-supported
Xsbusdev/dbri_isr.c	optional dbri device-driver not-supported
Xsbusdev/dbri_mmcodec.c	optional dbri device-driver not-supported
Xsbusdev/dbri_subr.c	optional dbri device-driver not-supported
X#
Xsbusdev/bwtwo.c		optional bwtwo device-driver
Xsbusdev/cgthree.c	optional cgthree device-driver
Xsbusdev/cgsix.c		optional cgsix device-driver
Xsbusdev/cgeight.c	optional cgeight not-supported
Xsbusdev/cgtwelve.c	optional cgtwelve device-driver
Xsbusdev/gt.c		optional gt device-driver
Xsbusdev/gt_printbuf.c optional gt device-driver
Xsbusdev/dmaga.c		optional dma device-driver
Xsbusdev/fbutil.c	optional bwtwo device-driver
Xsbusdev/fbutil.c	optional cgthree device-driver
Xsbusdev/fbutil.c	optional cgsix device-driver
Xsbusdev/fbutil.c	optional cgtwelve device-driver
Xsbusdev/fbutil.c	optional gt device-driver
Xsbusdev/fd.c		optional fd device-driver
Xsbusdev/fd_asm.s	optional device-driver
Xsbusdev/lebuf.c		optional le device-driver
Xsbusdev/bpp.c		optional bpp device-driver not suported
X#
X# SCSI for Campus
X#
Xscsi/adapters/esp.c		optional esp scsibus device-driver
Xscsi/conf/scsi_confdata.c	optional scsibus
Xscsi/conf/scsi_confsubr.c	optional scsibus
Xscsi/impl/scsi_capabilities.c	optional scsibus
Xscsi/impl/scsi_control.c	optional scsibus
Xscsi/impl/scsi_resource.c	optional scsibus
Xscsi/impl/scsi_data.c		optional scsibus
Xscsi/impl/scsi_subr.c		optional scsibus
Xscsi/impl/scsi_transport.c	optional scsibus
Xscsi/targets/sd_conf.c		optional sd scsibus
Xscsi/targets/sd.c		optional sd scsibus
Xscsi/targets/sf.c		optional sf scsibus not-supported
Xscsi/targets/sg.c		optional sg scsibus not-supported
Xscsi/targets/sr.c		optional sr scsibus
Xscsi/targets/st_conf.c		optional st scsibus
Xscsi/targets/st.c		optional st scsibus
Xscsi/targets/scan.c		optional scan scsibus
X#
Xsparc/addupc.s		standard
Xsparc/copy.s		standard
Xsparc/crt.s		standard
Xsparc/float.s		standard
Xsparc/fpu/addsub.c	standard
Xsparc/fpu/compare.c	standard
Xsparc/fpu/div.c		standard
Xsparc/fpu/fpu.c		standard
Xsparc/fpu/fpu_simulator.c	standard
Xsparc/fpu/iu_simulator.c	standard
Xsparc/fpu/mul.c		standard
Xsparc/fpu/pack.c	standard
Xsparc/fpu/unpack.c	standard
Xsparc/fpu/utility.c	standard
Xsparc/fpu/uword.c	standard
Xsparc/mcount.s		optional profiling-routine
Xsparc/ocsum.s		standard
Xsparc/overflow.s	standard
Xsparc/sparc_subr.s	standard
Xsparc/swtch.s		standard
Xsparc/underflow.s	standard
Xsparc/zs_asm.s		optional zs device-driver
Xsun/conf.c		standard
Xsun/cons.c		standard
Xsun/consfb.c		standard device-driver
Xsun/conskbd.c		standard
Xsun/consms.c		optional ms
X#sun/dkbad.c		standard
Xsun/in_cksum.c		optional INET
Xsun/mb_machdep.c	standard device-driver
Xsun/openprom_util.c	standard
Xsun/probe.c		standard
Xsun/seg_kmem.c		standard
Xsun/str_conf.c		standard
Xsun/subr_crash.c	standard
Xsun/swapgeneric.c	standard
Xsun/ufs_machdep.c	standard
Xsun/vdconf.c		optional VDDRV
Xsun/vddrv.c		optional VDDRV
Xsun/vdmodsw.c		optional VDDRV
Xsun/wscons.c		standard
Xsun4/vm_hat.c		standard
Xsun4/vm_hatasm.s	standard
Xsun4c/audio_79C30_intr.s	optional audioamd device-driver
Xsun4c/autoconf.c	standard device-driver
Xsun4c/openprom_xxx.c	standard device-driver
Xsun4c/clock.c		standard device-driver
Xsun4c/dbx_machdep.c	optional dbx symbolic-info
Xsun4c/kprof.s		optional profiling-routine
Xsun4c/locore.s		standard special
Xsun4c/lwp/low.s		optional LWP
Xsun4c/lwp/lwpmachdep.c	optional LWP
Xsun4c/lwp/lwputil.c	optional LWP
Xsun4c/lwp/stack.c	optional LWP
Xsun4c/machdep.c		standard
Xsun4c/map.s		standard
Xsun4c/mem.c		standard
Xsun4c/memerr.c		standard
Xsun4c/mmu.c		standard
Xsun4c/subr.s		standard
Xsun4c/trap.c		standard
Xsun4c/vm_machdep.c	standard
Xsunchat/chat.c		optional chat device-driver
Xsunchat/chatunit.c	optional chat device-driver
Xsundev/ar.c		optional ar not-supported
Xsundev/cgtwo.c		optional cgtwo not-supported
Xsundev/cgfour.c		optional cgfour not-supported
Xsundev/cgnine.c		optional cgnine not-supported
Xsundev/db.c		optional db
Xsundev/dbx_sundev.c	optional dbx symbolic-info
Xsundev/des.c		optional des not-supported
Xsundev/fpa.c		optional fpa not-supported
X#sundev/fd.c		optional fd device-driver
Xsundev/ft.c		optional ft device-driver
Xsundev/gpone.c		optional gpone not-supported
Xsundev/hrc.c		optional hrc device-driver
Xsundev/hrc_common.c	optional hrc device-driver
Xsundev/id.c		optional id device-driver not-supported
Xsundev/ipi.c		optional ipi device-driver not-supported
Xsundev/ipi_trace.c	optional ipi device-driver not-supported
Xsundev/is.c		optional is device-driver not-supported
Xsundev/is_conf.c	optional is device-driver not-supported
Xsundev/kbd.c		optional kb
Xsundev/keytables.c	optional kb
Xsundev/kg.c		optional kg device-driver
Xsundev/lightpen.c	optional gt device-driver
X# no mb.c for sun4c
X#sundev/mb.c		standard device-driver
Xsundev/mcp.c            optional mcp not-supported
Xsundev/mcp_async.c      optional mcpa not-supported
Xsundev/mcp_bsc.c	optional mcpb not-supported
Xsundev/mcp_bsctables.c	optional mcpb not-supported
Xsundev/mcp_conf.c       optional mcp not-supported
Xsundev/mcp_isdlc.c	optional mcps not-supported
Xsundev/mcp_proto.c      optional mcp not-supported
Xsundev/mcp_sdlc.c	optional mcph not-supported
Xsundev/ms.c		optional ms 
Xsundev/mti.c		optional mti not-supported
Xsundev/mti_conf.c	optional mti not-supported
Xsundev/ns.c		optional ns device-driver
Xsundev/openprom.c	optional openeepr device-driver
Xsundev/pc.c		optional pc device-driver
Xsundev/pc_conf.c	optional pc device-driver
Xsundev/pi.c		optional pi not-supported
Xsundev/rd.c		optional rd device-driver
Xsundev/sc.c		optional sc OLDSCSI device-driver
Xsundev/sc_conf.c	optional OLDSCSI device-driver
Xsundev/sd.c		optional sd OLDSCSI device-driver
Xsundev/se.c		optional se OLDSCSI device-driver
Xsundev/sf.c		optional sf OLDSCSI device-driver not-supported
Xsundev/si.c		optional si OLDSCSI device-driver
Xsundev/st.c		optional st OLDSCSI device-driver
Xsundev/sw.c		optional sw OLDSCSI device-driver
Xsundev/taac.c		optional taac not-supported
Xsundev/tm.c		optional mt not-supported
Xsundev/tod.c		optional tod not-supported
Xsundev/tvone.c		optional tvone not-supported
Xsundev/vp.c		optional vp not-supported
Xsundev/vpa.c            optional vpa not-supported
Xsundev/vpc.c		optional vpc not-supported
Xsundev/vuid_queue.c	optional kb
Xsundev/vuid_store.c	optional win device-driver
Xsundev/vx.c		optional vx not-supported
Xsundev/xd.c		optional xd not-supported
Xsundev/xd_conf.c	optional xd not-supported
Xsundev/xt.c		optional xt not-supported
Xsundev/xy.c		optional xy not-supported
Xsundev/xy_conf.c	optional xy not-supported
Xsundev/zs_async.c	optional zs device-driver
Xsundev/zs_bsc.c		optional zsb device-driver
Xsundev/zs_bsctables.c	optional zsb device-driver
Xsundev/zs_common.c	optional zs device-driver
Xsundev/zs_conf.c	optional zs device-driver
Xsundev/zs_isdlc.c	optional zsi device-driver
Xsundev/zs_proto.c	optional zs device-driver
Xsundev/zs_sdlc.c	optional zss device-driver
Xsunif/dbx_sunif.c	optional dbx INET symbolic-info
Xsunif/dcp.c		optional dcp device-driver
Xsunif/ie_conf.c		optional ie device-driver
Xsunif/if_dcp.c		optional dcp device-driver
Xsunif/if_ec.c		optional ec INET device-driver
Xsunif/if_en.c		optional en INET device-driver
Xsunif/if_hy.c		optional hy not-supported
Xsunif/if_ie.c		optional ie INET device-driver
Xsunif/if_le.c		optional le INET device-driver
Xsunif/if_me.c		optional pc INET device-driver
Xsunif/if_subr.c		optional ether INET
Xsunif/le_conf.c		optional le device-driver
Xsunif/tbi.c		optional tbi device-driver
Xsunwindow/rect/rect.c		optional win device-driver
Xsunwindow/rect/rect_data.c	optional win device-driver
Xsunwindow/rect/rectlist.c	optional win device-driver
Xsunwindowdev/dtopnub.c		optional dtop device-driver
Xsunwindowdev/win.c		optional win device-driver
Xsunwindowdev/win_syscall.c	optional win device-driver
Xsunwindowdev/wincms.c		optional win device-driver
Xsunwindowdev/windevconf.c       optional win device-driver
Xsunwindowdev/windt.c		optional win device-driver
Xsunwindowdev/winioctl.c		optional win device-driver
Xsunwindowdev/winlock.c		optional win device-driver
Xsunwindowdev/winshared.c	optional win device-driver
Xsunwindowdev/wintree.c		optional win device-driver
Xsunwindowdev/ws.c		optional dtop device-driver
Xsunwindowdev/ws_dispense.c	optional win device-driver
Xsunwindowdev/ws_interrupt.c	optional win device-driver
Xsun/stubs.c	standard
END_OF_FILE
if test 10394 -ne `wc -c <'pint/sun/misc/files.scan'`; then
    echo shar: \"'pint/sun/misc/files.scan'\" unpacked with wrong size!
fi
# end of 'pint/sun/misc/files.scan'
fi
if test -f 'pint/util/set_scanner.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pint/util/set_scanner.c'\"
else
echo shar: Extracting \"'pint/util/set_scanner.c'\" \(7915 characters\)
sed "s/^X//" >'pint/util/set_scanner.c' <<'END_OF_FILE'
X/*
X *  PINT Pint Is Not TWAIN - common scanner driver interface for UN*X
X *  Copyright (C) 1994 Kenneth Stailey ken@spacenet.com
X *
X *  This program is free software; you can redistribute it and/or modify
X *  it under the terms of the GNU General Public License as published by
X *  the Free Software Foundation; either version 2 of the License, or
X *  (at your option) any later version.
X *
X *  This program is distributed in the hope that it will be useful,
X *  but WITHOUT ANY WARRANTY; without even the implied warranty of
X *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *  GNU General Public License for more details.
X *
X *  You should have received a copy of the GNU General Public License
X *  along with this program; if not, write to the Free Software
X *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X/*
X * set-scanner.c:
X *
X *   Set the scan area in decimal fractions of inches.
X *   If the defaults are to be changed use system("chdev...")
X *   otherwise use ioctl()
X */
X
X#include <stdlib.h>
X#include <stdio.h>
X#include <string.h>
X#include <fcntl.h>
X#include <sys/scanio.h>
X
X#define UNINITIALIZED -10
X
Xint inches_to_1200th(char *numeral);
Xvoid usage(char *prog_name);
Xint xlate_image_code(char *);
Xint ipow10(int);
Xint scanner_type(char *);
X
Xmain(int argc, char *argv[])
X{
X  int width, height;
X  int x_origin, y_origin;
X  int brightness, contrast;
X  int resolution, image_mode;
X
X  int defaults = FALSE;
X
X  char *logical_name = "scan0";
X  char device_special[255];
X
X  int    c;			/* for command line parsing */
X  extern int   optind;		/* for getopt() */
X  extern char *optarg;		/* for getopt() */
X
X  char command[256];
X  struct scan_io s_io;
X
X  int s_fd;
X
X  brightness = contrast = resolution =
X    width = height = x_origin = y_origin =
X      image_mode =
X	UNINITIALIZED;
X
X  while ((c = getopt(argc, argv, "w:h:x:y:l:b:c:r:i:d")) != EOF) {
X    switch (c) {
X    case 'w':
X      width = inches_to_1200th(optarg);
X      break;
X    case 'h':
X      height = inches_to_1200th(optarg);
X      break;
X    case 'x':
X      x_origin = inches_to_1200th(optarg);
X      break;
X    case 'y':
X      y_origin = inches_to_1200th(optarg);
X      break;
X    case 'l':
X      logical_name = optarg;
X      break;
X    case 'd':
X      defaults = TRUE;		/* use chdev to set defaults */
X      break;
X    case 'b':
X      brightness = atol(optarg);
X      break;
X    case 'c':
X      contrast = atol(optarg);
X      break;
X    case 'r':
X      resolution = atol(optarg);
X      break;
X    case 'i':
X      image_mode = xlate_image_code(optarg);
X      if (image_mode == -1) {
X	usage(argv[0]);
X      }
X      break;
X    case '?':
X      usage(argv[0]);
X    }
X  }
X
X#ifdef __IBMR2
X  if (defaults) {
X    sprintf(command, "chdev -l %s", logical_name);
X
X    if (width != UNINITIALIZED)
X      sprintf(command, "%s -a window_width=%d", command, width);
X
X    if (height != UNINITIALIZED)
X      sprintf(command, "%s -a window_length=%d", command, height);
X
X    if (x_origin != UNINITIALIZED)
X      sprintf(command, "%s -a x_origin=%d", command, x_origin);
X
X    if (y_origin != UNINITIALIZED)
X      sprintf(command, "%s -a y_origin=%d", command, y_origin);
X
X    if (brightness != UNINITIALIZED)
X      sprintf(command, "%s -a brightness=%d", command, brightness);
X
X    /* note that the FUJITSU doesn't support contrast via the ODM */
X    if (contrast != UNINITIALIZED && scanner_type(logical_name) != FUJITSU)
X      sprintf(command, "%s -a contrast=%d", command, contrast);
X
X    if (resolution != UNINITIALIZED) {
X      sprintf(command, "%s -a x_resolution=%d", command, resolution);
X      sprintf(command, "%s -a y_resolution=%d", command, resolution);
X    }
X
X    if (image_mode != UNINITIALIZED) {
X      sprintf(command, "%s -a image_mode=", command);
X      switch (image_mode) {
X      case SIM_BINARY_MONOCHROME:
X	sprintf(command, "%smonochrome ", command);
X	break;
X      case SIM_DITHERED_MONOCHROME:
X	sprintf(command, "%sdithered ", command);
X	break;
X      case SIM_GRAYSCALE:
X	sprintf(command, "%sgrayscale ", command);
X	break;
X      case SIM_COLOR:
X	sprintf(command, "%scolor ", command);
X	break;
X      case SIM_RED:
X	sprintf(command, "%sred ", command);
X	break;
X      case SIM_GREEN:
X	sprintf(command, "%sgreen ", command);
X	break;
X      case SIM_BLUE:
X	sprintf(command, "%sblue ", command);
X	break;
X      }
X    }
X
X    system(command);
X
X  } else { 			/* use ioctl() instead of chdev */
X#endif
X    sprintf(device_special, "/dev/%s", logical_name);
X    if ((s_fd = open(device_special, O_RDONLY)) < 0) {
X      fprintf(stderr, "open of %s failed: ", device_special);
X      perror("");
X      exit(-1);
X    }
X
X    if (ioctl(s_fd, SCAN_GET, &s_io) < 0) {
X      perror("ioctl SCAN_GET");
X      exit(-1);
X    }
X
X    if (width != UNINITIALIZED)
X      s_io.scan_window_width = width;
X
X    if (height != UNINITIALIZED)
X      s_io.scan_window_length = height;
X
X    if (x_origin != UNINITIALIZED)
X      s_io.scan_x_origin = x_origin;
X
X    if (y_origin != UNINITIALIZED)
X      s_io.scan_y_origin = y_origin;
X
X    if (brightness != UNINITIALIZED)
X      s_io.scan_brightness = brightness;
X
X    if (contrast != UNINITIALIZED)
X      s_io.scan_contrast = contrast;
X
X    if (resolution != UNINITIALIZED) {
X      s_io.scan_x_resolution = resolution;
X      s_io.scan_y_resolution = resolution;
X    }
X
X    if (image_mode != UNINITIALIZED)
X      s_io.scan_image_mode = image_mode;
X
X    if (ioctl(s_fd, SCAN_SET, &s_io) < 0) {
X      perror("ioctl SCAN_SET");
X      exit(-1);
X    }
X#ifdef _IBMR2
X  }
X#endif
X
X  exit(0);
X}
X
X/*
X * Convert a numeral representing inches into a number representing
X * 1/1200ths of an inch.  If multipling the input by 1200 still leaves
X * a fractional part then abort with an error message.
X *
X * Note that "numeral" here means string of digits with optional decimal point
X */
Xint
Xinches_to_1200th(char *numeral)
X{
X  FILE *bc;
X  char result[50];
X  char *p;
X
X  /* test to see if "numeral" really is a numeral */
X  p = numeral;
X  while (*p) {
X    if (!isdigit(*p) && *p != '.')
X      usage("set_scanner");
X    ++p;
X  }
X
X  /* test to see if it is a multiple of 1/1200 */
X
X  if ((bc = fopen("/tmp/set_scanner.bc_work", "w")) == NULL) {
X    perror("creating temp file '/tmp/set_scanner.bc_work'");
X    exit(-1);
X  }
X  fprintf(bc, "%s * 1200\nquit\n", numeral);
X  fclose(bc);
X
X  if ((bc = popen("bc -l /tmp/set_scanner.bc_work", "r")) == NULL) {
X    perror("running bc");
X    exit(-1);
X  }
X  fgets(result, 50, bc);
X  result[strlen(result) - 1] = '\0';  /* eat newline from fgets */
X  pclose(bc);
X  unlink("/tmp/set_scanner.bc_work");
X
X  if ((p = strchr(result, '.')) != NULL) {
X    ++p;
X    while (*p)
X      if (*p++ != '0') {
X	fprintf(stderr, "set_scanner: please do not use fractions with a  ");
X	fprintf(stderr, "granularity less than\nset_scanner: one ");
X	fprintf(stderr, "twelve-thousandths of an inch\n");
X	exit(-1);
X      }
X  }
X
X  return (atoi(result));
X}
X
Xvoid
Xusage(char *prog_name)
X{
X  fprintf(stderr,
X	  "usage: %s [-w width] [-h height] [-x x_origin] [-y y_origin]\n[-r resolution] [-l logical name] [-i image mode] [-d (for setting defaults)]\n",
X	  prog_name);
X  exit(-1);
X}
X
Xint xlate_image_code(char *image_code)
X{
X  switch (image_code[0]) {
X  case 'm':
X    return (SIM_BINARY_MONOCHROME);
X  case 'd':
X    return (SIM_DITHERED_MONOCHROME);
X  case 'g':
X    return (SIM_GRAYSCALE);
X  case 'c':
X    return (SIM_COLOR);
X  case 'R':
X    return (SIM_RED);
X  case 'G':
X    return (SIM_GREEN);
X  case 'B':
X    return (SIM_BLUE);
X  default:
X    return (-1);
X  }
X}
X
Xint scanner_type(char *lname)
X{
X  char special_file[256];
X  int scan_fd;
X  struct scan_io sp;
X
X  sprintf(special_file, "/dev/%s", lname);
X
X  if ((scan_fd = open(special_file, O_RDONLY)) < 0) {
X    perror("set_scanner: can't open scanner--");
X    exit(1);
X  }
X
X  if (ioctl(scan_fd, SCAN_GET, &sp) < 0) {
X    perror("set_scanner: can't get parameters from scanner--");
X    exit(1);
X  }
X
X  close(scan_fd);
X
X  return ((int)sp.scan_scanner_type);
X}
END_OF_FILE
if test 7915 -ne `wc -c <'pint/util/set_scanner.c'`; then
    echo shar: \"'pint/util/set_scanner.c'\" unpacked with wrong size!
fi
# end of 'pint/util/set_scanner.c'
fi
echo shar: End of archive 2 \(of 7\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
