Newsgroups: comp.sources.unix
From: rca@ingres.com (Bob Arnold)
Subject: v28i070: saenv_alldisks - sysadmin env, disk management and backups, Part06/06
References: <1.771948808.8446@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: rca@ingres.com (Bob Arnold)
Posting-Number: Volume 28, Issue 70
Archive-Name: saenv_alldisks/part06

#!/bin/sh
# this is saenv_alld.06 (part 6 of saenv_alld)
# do not concatenate these parts, unpack them in order with /bin/sh
# file src/backup/backup continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 6; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping src/backup/backup'
else
echo 'x - continuing file src/backup/backup'
sed 's/^X//' << 'SHAR_EOF' >> 'src/backup/backup' &&
X					# last line should end in a newline
X					od -c $dfout | tail -2 | grep '\\n *$' > /dev/null
X					if test $isit1 -eq 1 -a $? = 0 ; then
X						echo "$pr: Filesystem list '$dfout' looks OK to me."
X					else
X						echo "$pr: Filesystem list '$dfout' is probably mangled."
X					fi
X					echo "$pr: YOU check it out.  If YOU think it looks mangled, type 'q' to quit."
X					cat $dfout
X					eval "$EXITQ"
X					break
X				fi
X			fi
X		done
X
X		# try to get positioning info from the old backup working
X		# directory - not implemented yet.
X		#bworkdir=$hdir/`awk '/#Workdir:/ {print $2}' $brpt` > /dev/null
X		#gotrpt=false
X		#if test -s $bworkdir/*rpt ; then
X		#	:
X		#	# this won't work right now since there aren't any with
X		#	# reports in the proper format yet
X		#fi
X		# Getting positioning from old logs isn't working yet
X		gotrpt=false
X		if test $gotrpt = false ; then
X			if test -z "$firstfslist" ; then
X				dofirstfslist=false
X			else
X				# trim any spaces from $firstfslist
X				dofirstfslist=true
X				set $firstfslist
X				firstfslist="$*"
X				echo "$pr: firstfslist='$firstfslist'"
X			fi
X			firstfs1=`awk 'NR == 1 {print $NF ; exit}' $dfout`
X			echo "$pr: Volume '1': First backup is $firstfs1"
X			echo      "Volume '1': First backup is $firstfs1" > $firstblist
X			n=2
X			while test -n "$nvol" -a $n -le "$nvol" -a $mtype != file -a $mtype != dir ; do
X				if test -n "$1" -a $dofirstfslist = true ; then
X					fs1=$1
X				else
X					echo "$pr: What is the first filsystem on alldisks volume '$n'?"
X					echo $epre "$pr: Enter filesystem name (or 'unknown'): "$esuf
X					eval "$READ" fs1
X				fi
X				case $fs1 in
X				"")
X					continue
X				;;
X				un*)
X					echo "$pr: The first filesystem on volume '$n' is UNKNOWN !!?!??  AARRGGHH !!!"
X					if test -s $whodid ; then
X						initials=`cat $whodid`
X						#x=`grep "^$initials[ 	]" $oplist | sed -e 's/^[^ 	]*[ 	]*//'`
X						x=`sed -n -e "/^$initials[ 	][ 	]*[^ 	]*[ 	]*/s///p" $oplist`
X					fi
X					if test -n "$x" ; then
X						echo "$pr: You must now severely scold '$x', who made this backup."
X					elif test -n "$initials" ; then
X						echo "$pr: You must now severely scold '$initials', who made this backup."
X					else
X						echo "$pr: You must now severely scold the person who made this backup."
X					fi
X					echo "$pr: They should have written this information on the tape label!!"
X					echo "$pr: I can not reliably position the $media at the correct archive."
X					echo "$pr: Maybe you'll get REALLY lucky ..."
X					echo "$pr: Volume '$n': First backup is unknown"
X					echo      "Volume '$n': First backup is unknown" >> $firstblist
X					n=`expr $n + 1`
X					eval "$EXITQ"
X				;;
X				/*)
X					# if it's a valid filesystem
X					if egrep "[ 	]$fs1\$" $dfout > /dev/null ; then
X						# DG's "dump2" and at least
X						# one other vendor can continue
X						# a dump when it hits EOT, so
X						# was this archive continued
X						# *from_the_previous* volume?
X						# (note this has nothing to do
X						# with $cont2next variable,
X						# which says whether or not an
X						# archive was continued
X						# *to_the_next* volume)
X						while : ; do
X							contstr=''
X							if test -z "$1" -o $dofirstfslist != true ; then
X								echo $epre "$pr: Was $fs1 continued from the previous volume? [yn] "$esuf
X								eval "$READ" yesno
X							elif test "$2" = cont ; then
X								yesno=y
X								shift
X								shift
X							else
X								yesno=n
X								shift
X							fi
X							case $yesno in
X							[yY]*)	contstr=' (continued)' ;;
X							[nN]*)	: ;;
X							*)	continue ;;
X							esac
X							break
X						done
X						echo "$pr: Volume '$n': First backup is $fs1$contstr"
X						echo      "Volume '$n': First backup is $fs1$contstr" >> $firstblist
X						n=`expr $n + 1`
X					else
X						dofirstfslist=false
X						echo "$pr: Could not find '$fs1' in $dfout."
X						echo "$pr: Here are the available filesystems:"
X						cat $dfout
X					fi
X				;;
X				*)
X					dofirstfslist=false
X					echo "$pr: Filesystem names must begin with a '/'."
X				;;
X				esac
X			done
X			cat $firstblist >> $report
X
X			# Now we have list of first filesystems, so
X			# we can build filesystem-tape map.
X			# The trick is to build two somewhat independently
X			# processed lists: a) $* for each volume, and
X			# b) $f from $dfout which lists all the filesystems
X			# The $volinc stuff is to handle our best guess at
X			# which volume filesystems are on when we've got
X			# 'unknown' first filesystems
X			# A rather elegant solution, yes indeed; now if
X			# only we could explain it more clearly :-)
X			echo "1	alldisks_header" > $volmap
X			n=0
X			volinc=1
X			# This simple awk code works everywhere but
X			# Solaris 2.1 and 2.2: "awk '{print $6 $7}'"
X			# Because it coredumps if there are less than 7 fields
X			# on the first input line for Solaris 2.[12], we've
X			# had to replace it with equivalent awk code in
X			# the following statement:
X			set `awk '{printf("%s%s\n", $6, $7)}' $firstblist`
X			for f in `awk '{print $NF}' $dfout` ; do
X				if test "$f" = "$1" ; then
X					n=`expr $n + $volinc`
X					echo "$n	$f" >> $volmap
X					shift
X					volinc=1
X					while test "$1" = unknown ; do
X						shift
X						volinc=`expr $volinc + 1`
X					done
X				elif test "$f(continued)" = "$1" ; then
X					echo "$n	$f" >> $volmap
X					n=`expr $n + $volinc`
X					echo "$n	$f(continued)" >> $volmap
X					shift
X					volinc=1
X					while test "$1" = unknown ; do
X						shift
X						volinc=`expr $volinc + 1`
X					done
X				else
X					echo "$n	$f" >> $volmap
X				fi
X			done
X		fi
X	esac
X
X	# if we are doing get/verify of a single filesystem from an alldisks
X	# tape set we have a lot of work to do to select the filesystem
X	# and position the media there.  This includes setting $onvol for
X	# verify onedisk, and much more stuff if we're looking at an alldisks
X	case $getmode in
X	knownfs|listdisks|lastdisk)
X
X		# can check the media contents vs. label if it's an alldisks
X		if test -z "$parent" ; then
X			report_p=$breport
X			eval "$LABELQ"
X		fi
X
X		## determine the filesystem to get
X		# if the user requested a specific filesystem
X		case $getmode in
X		knownfs)
X			# verify the filesystem, being very careful with egrep
X			# remember, the regular expression must be
X			# [<SPACE><TAB>]$fs<DOLLAR>
X			if egrep "[ 	]$fs\$" $dfout > /dev/null ; then
X				echo "$pr: Good news - '$fs' is in this backup set."
X			else
X				getmode=listdisks
X				echo "$pr: '$fs' was not put on this backup $media."
X			fi
X		;;
X		lastdisk)
X			fs=`tail -1 $dfout | awk '{print $NF}'`
X			if test -n "$fs" ; then
X				getmode=knownfs
X				echo "$pr: Last filesystem is '$fs'"
X			else
X				getmode=listdisks
X				echo "$pr: Attempt to pick last filesystem failed."
X			fi
X		;;
X		esac
X		while test $getmode = listdisks ; do
X			echo ''
X			echo "$pr: Backups were made of these disks:"
X			cat $dfout
X			echo "$pr: What is the filesystem you want to $mode?"
X			echo $epre "$pr: Enter the filesystem (or 'q' to quit): "$esuf
X			eval "$READ" ans
X			case $ans in
X			[qQ]*)
X				echo "$pr: OK, will quit.  Bye."
X				exit
X			;;
X			/*)
X				# verify the filesystem, being very careful with egrep
X				if egrep "[ 	]$ans\$" $dfout > /dev/null ; then
X					getmode=knownfs
X					fs=$ans
X				else
X					egrep "[ 	]$ans\$" $dfout
X					echo "$pr: Could not find '$ans' in $dfout."
X				fi
X			;;
X			*)
X				echo "$pr: Try again."
X			;;
X			esac
X		done
X
X		# if user didn't tell us which volume the backup is on
X		# and how many files to skip, then calculate it
X		mapent=`egrep    "[ 	]$fs\$" $volmap`
X		onvol=`echo $mapent | sed -e 's/[ 	].*//'`
X		thisvolmap=`egrep "^$onvol[ 	]" $volmap`
X		bkpn=`echo "$thisvolmap" | egrep -n "[ 	]$fs\$" | sed -e 's/:.*//'`
X		filen=`echo "$thisvolmap" | egrep -n "[ 	]$fs\$" | sed -e 's/:.*//'`
X		fileskip=`expr $filen - 1`
X		# if the filesystem we want is the first one on $onvol
X		nextvol=`expr $onvol + 1`
X		if egrep "[ 	]$fs\$" $firstblist > /dev/null ; then
X			: do nothing - we know we are ok
X		# else if there is a next volume and its first
X		# filesystem is unknown, then the filesystem we want
X		# could be on $onvol or the next one (or the next ...)
X		elif egrep "'$nextvol':.*[ 	]unknown" $firstblist > /dev/null ; then
X			echo ""
X			echo "$pr: Since the first filesystem on volume '$nextvol' is 'unknown', it is"
X			echo "$pr: impossible to determine exactly which volume $fs is on."
X			echo "$pr: It could be on volume '$onvol' or '$nextvol',"
X			echo "$pr: but there is no way to know for sure."
X			echo "$pr: We will have to start with volume '$onvol'"
X			echo "$pr: and skip '$fileskip' files until we reach the backup for '$fs'."
X			echo "$pr: If necessary, I will ask you to change ${media}'s."
X			echo "$pr: This is the best we can do.  If $fs is on volume '$onvol',"
X			echo "$pr: this scheme will work; if not the odds are really bad."
X			eval "$EXITQ"
X		fi
X
X		bkpn=`grep -v '[ 	](alldisks_header|\(continued\))$' $volmap | egrep -n "[ 	]$fs\$" | sed -e 's/:.*//'`
X		echo "#fs=$fs bkpn=$bkpn onvol=$onvol fileskip=$fileskip" >> $report
X		echo ''
X		if test $getmode = knownskip ; then
X			echo "$pr: We have to skip $fileskip file(s) on volume $onvol"
X		else
X			echo "$pr: We have to skip $fileskip file(s) on this volume"
X		fi
X		echo "$pr: to position the $media at the backup of $fs."
X		case $bkpn in
X		[0-9])	fsnn=0$bkpn ;;
X		*)	fsnn=$bkpn ;;
X		esac
X		eval "$MDEV"
X		if test $onvol -gt 1 ; then
X			# prompt operator for $onvol approval
X			eval "$OFFLINE"
X			echo "$pr: Please mount volume $onvol."
X			eval "$MREADYQ"
X			# Make sure the new volume is online
X			while : ; do
X				# tell user what we're doing if $SHOWDD is true
X				eval $SHOWDD Make sure $media is on line
X				# try to read media, using $mtestibs - if
X				# the read fails then it's not on line.
X				if test "$mhost" = "$lhost" ; then
X					$bdd if=$rewdev bs=$mtestibs count=1 of=/dev/null 2> /dev/null && online=true
X				else
X					online=`$bdd if=$rewdev bs=$mtestibs count=1 of=/dev/null '2> /dev/null && echo true' | grep '^true$'`
X				fi
X				if test "$online" = true ; then
X					break
X				else
X					eval "$CHKMREAD"
X					eval "$EXITQ"
X				fi
X			done
X			# At this point, we'd also like to make sure the
X			# operator didn't leave the first volume in the drive,
X			# but it's too much work:
X			# tar doesn't mind if it reads a dump, and
X			# we have no guarantee the beginning of $onvol
X			# is the start of a dump or cpio archive.
X			# We'd have to do something like extract the
X			# header archive again, and see if we succeed.
X		fi
X	;;
X	esac
X
X	# position the media if we have to
X	case $getmode in
X	knownfs|knownskip|listdisks|lastdisk)
X		case $mtype in
X		dir|file)	: do nothing ;;
X		*)		echo '' ; echo "$pr: Positioning $media.  This may take a while." ;;
X		esac
X		eval "$SKIP2ARCHIVE"
X	;;
X	esac
X
X	# OK!  We've now done any necessary work to choose a filesystem
X	# and position the media.
X	# So we can set "$fsproxy" here, which we'll use in reports and when
X	# we tell the user whether we think a verify attempt PASSED or FAILED.
X	case $getmode in
X	onedisk)	fsproxy='(onedisk)' ;;
X	alldisks)	fsproxy='(alldisks)' ;;
X	*)		fsproxy=$fs ;;
X	esac
X
X	# If we're doing a get (as opposed to a verify), do we do an
X	# interactive restore or do we restore the entire dump?
X	rmode=NA	# in case we're doing a verify not a get
X	while test $mode = get -a -z "$entire" ; do
X		echo "$pr: Do you want to do an interactive restore, or"
X		echo "$pr: do you want to restore the entire dump/cpio archive?"
X		echo "$pr: NOTE - restoring the entire archive may restore"
X		echo "$pr: MASSIVE amounts of data."
X		echo $epre "$pr: Enter 'i' for interactive, 'e' for entire [ie]: "$esuf
X
X		eval "$READ" rmode
X		case $rmode in
X		[iI]*)
X			while : ; do
X				echo "$pr: You chose an interactive restore."
X				echo $epre "$pr: Is this OK? [y(n)]: "$esuf
X				eval "$READ" ans
X				case $ans in
X				[yY]*)	entire=false ; break ;;
X				*)	continue 2 ;;
X				esac
X			done
X		;;
X		[eE]*)
X			while : ; do
X				echo "$pr: You chose to restore the entire archive."
X				echo $epre "$pr: Is this OK? [y(n)]: "$esuf
X				eval "$READ" ans
X				case $ans in
X				[yY]*)	entire=true ; break ;;
X				*)	continue 2 ;;
X				esac
X			done
X		;;
X		*)
X			continue
X		;;
X		esac
X	done
X	if test $mode = get ; then
X		case $entire in
X		true)
X			rmode=r
X			getlist=''
X			echo "$pr: You chose to restore the entire archive."
X		;;
X		false)
X			if test $bprog != cpio ; then
X				rmode=i
X				echo "$pr: You chose an interactive restore."
X			else
X				echo "$pr: I don't know how to do an interactive cpio restore."
X				echo "$pr: If you exit here by entering $QUOTEDQ, I will leave"
X				echo "$pr: the $media in it's current position.  Or you can choose"
X				echo "$pr: to restore the entire cpio archive by entering anything else."
X				eval "$EXITQ"
X			fi
X		;;
X		esac
X	fi
X
X	# Make the user choose the target directory they really want to
X	# restore_to / be_in.  If we're doing a verify, do the extraction
X	# into a subdirectory of $workdir so we don't run into name conflicts.
X	# This avoids trouble in the case where the last file in the archive
X	# is called something like "./backup/1213.183147im/b.03.out"
X	# which would cause problems because we may have just extracted
X	# the "backup" script from an alldisks tar header archive.
X	echo ''
X	case $mode$getmode in
X	get*)
X		echo "$pr: We are almost ready to try to 'get' your file restoration going."
X		test -z "$target" && target=$startdir
X	;;
X	verifyalldisks)
X		: do nothing
X	;;
X	verify*)
X		echo "$pr: We are almost ready to try to begin your verification."
X		test -z "$target" && target=$workdir/extract && mkdir $target
X	;;
X	esac
X	while test $mode$getmode != verifyalldisks ; do
X		echo "$pr: What is the target directory for the RESTORATION TREE?"
X		if test $mode = verify -a $autoverify = true ; then
X			echo "$pr autoverify: Assume target:"
X			echo "$pr autoverify: '$target'"
X			testdir=$target
X		elif test "$targetarg" = true ; then
X			echo "$pr: Restoration target directory specified:"
X			echo "$pr: '$target'."
X			testdir=$target
X		else
X			echo $epre "$pr: Enter the name ($target): "$esuf
X			eval "$READ" ans
X			case $ans in
X			'')	testdir=$target ;;
X			*)	testdir=$ans ;;
X			esac
X		fi
X		# if $testdir isn't a directory, make sure we ask for target
X		if test ! -d "$testdir" ; then
X			echo "$pr: '$testdir' is not a directory.  Try again."
X			targetarg=false
X			continue
X		# else make sure we can create files in $testdir
X		# should be able to use "touch" here but Ultrix 2.0 and 3.0
X		# touch is buggy
X		elif echo "$pr: (workdir=$workdir) - can we put files in $testdir?" > $testdir/bkp.get.junk ; then
X			rm -f $testdir/bkp.get.junk
X			if test $autoverify = true -o $targetarg = true ; then
X				: do not ask about target
X			else
X				echo "$pr: Put restoration tree in target directory"
X				echo $epre "$pr: '$testdir'? [y(n)] "$esuf
X				eval "$READ" ans
X				case $ans in
X				[yY]*)	: do nothing - fall through to break ;;
X				*)	continue ;;
X				esac
X			fi
X			target=$testdir
X			cd $target
X			break
X		else
X			targetarg=false
X			echo "$pr: Cannot create files in '$testdir'.  Check:"
X			echo "$pr: -> Is '$testdir' on an NFS filesystem (check with 'df')?"
X			echo "$pr:    (If so, try another directory.)"
X			echo "$pr: -> Does '$testdir' have write permission?"
X			ls -ld $testdir
X			echo "$pr:    (If not, try another directory or try 'chmod u+w $testdir'.)"
X		fi
X	done
X
X	echo "#get/verify filesystem '$fsproxy', restore mode '$rmode' into target directory '$target'" >> $workdir/$report
X
X	## At last! start restore or verify!
X	umask 0
X	if test $getmode = knownfs -o $getmode = listdisks ; then
X		echo "$pr: About to read the backup of '$fs' (we hope)."
X	fi
X	case $mode in
X	get)
X		echo "$pr: Starting 'get' process." | tee -a $workdir/$report
X
X		# $getlist, $rans, $rmode, $rout for $DO_GET
X		getlist=""
X		rans=""
X		rmode="$rmode"
X		rout="2>&1 | tee -a $workdir/$report"
X		eval "$DO_GET"
X	;;
X	verify)
X		## See verify strategy comments in the README
X		## cpio archive: get $breport and $flist
X		## dump archive: get name of last file on the desired filesystem
X
X		# $getlist, $rans, $rmode, $rout for $DO_GET
X		case $bprog in
X		cpio)	getlist="/usr/tmp/$breport /usr/tmp/$flist" ;;
X		*)	getlist="" ;;
X		esac
X		rans="echo 1 |"
X		rmode="tv"
X		rout="> $vlist 2>&1"
X	esac
X
X	case $mode$getmode in
X	verifyalldisks)
X		report_p=$workdir/$breport
X		eval "$LABELQ"
X		fsnn=00
X		voln=1
X		while test $voln -le $nvol ; do
X			if test $voln -gt 1 -a $mtype != file -a $mtype != dir ; then
X				eval "$OFFLINE"
X				echo ""
X				echo "$pr: Finished verification of all the filesystems on volume '`expr $voln - 1`'."
X				echo "$pr: Please make sure volume '$voln' is in the $media drive."
X				eval "$MREADYQ"
X			fi
X			fslist=`awk '$1 == '$voln' {print $2 $3}' $workdir/$volmap`
X			fileskip=0	# initialize fileskip
X			for fs in $fslist ; do
X				## don't verify alldisks header
X				## or continued archives
X				case $fs in
X				*'(continued)'|alldisks_header)
X					fileskip=`expr $fileskip + 1`
X					continue
X				;;
X				esac
X				## increment two digit filesystem counter
X				eval "$FSNNPLUS1"
X				## handle backups in files on disk (uses $fsnn)
X				eval "$MDEV"
X				case $mtype in
X				dir|file)	diskfile=$mdev ;;
X				*)		diskfile='' ;;
X				esac
X				## handle filesystems continued onto next volume
X				# we know this filesystem wasn't continued
X				# (see also similar code for setting $do_auto)
X				# if the media is a disk file
X				if test $mtype = file -o $mtype = dir ; then
X					notcont=notcont
X				# else if this is the last volume
X				elif test $voln -eq $nvol ; then
X					notcont=notcont
X				# else if the first filesystem on the next
X				# volume is unknown
X				elif grep "'`expr $voln + 1`': .* unknown$" $firstblist > /dev/null ; then
X					notcont=''
X				# else if this filesystem *was* continued
X				elif grep " $fs (continued)" $firstblist > /dev/null ; then
X					notcont=''
X				# else this filesystem was *not* continued
X				else
X					notcont=notcont
X				fi
X				# tell child verify about its parent directory
X				case "$parent" in
X				'')	child=$wdir ;;
X				*)	child=$parent/$wdir ;;
X				esac
X				# tell child verify about
X				case $marg in
X				*dir)	childmarg=`echo $marg | sed -e 's/dir$/file/'` ;;
X				*)	childmarg=$marg
X				esac
X				# add "nomail" to child args if it isn't
X				# already set
X				case " $childargs " in
X				*" nomail "*)	: do nothing ;;
X				*)		childargs="$childargs nomail" ;;
X				esac
X				## OK, we're ready to issue the command!
X				echo ''
X				echo "$pr: ================================backup>>> verify $fs"
X
X				vcmd="./$pr verify $fs $childmarg $diskfile $extravol $child skip $fileskip $notcont $childargs"
X				echo "$pr: $vcmd"
X				curdir=`pwd`
X				cd $hdir
X				eval $vcmd
X				cd $curdir
X				fileskip=`expr $fileskip + 1`
X			done
X			voln=`expr $voln + 1`
X		done
X		echo "$pr: ================================backup>>> verify alldisks done"
X	;;
X	verify*)
X		case $bprog in
X		cpio)
X			echo "$pr: Getting '$getlist' from cpio archive." | tee -a $workdir/$report
X		;;
X		*dump*)
X			echo "$pr: Getting name of last file in archive." | tee -a $workdir/$report
X			echo "$pr: IGNORE the 'Specify next volume #:' question."
X		;;
X		esac
X		eval "$DO_GET"
X
X		# save the list of files we found
X		case $bprog in
X		cpio)	cp /usr/tmp/$flist $workdir ;;
X		*dump*)	cp $vlist          $workdir ;;
X		esac
X
X		# we put problems we find in $workdir/$failrpt
X		case $bprog in
X		cpio)
X			# simple checks
X			if test $getstat -ne 0 ; then
X				echo "$pr: cpio had problems reading archive, exited with status '$getstat'" >> $workdir/$failrpt
X			fi
X			for f in $breport $flist ; do
X				if test ! -s /usr/tmp/$f ; then
X					echo "$pr: Extraction of '/usr/tmp/$f' failed." >> $workdir/$failrpt
X				else
X					if test `wc -l < /usr/tmp/$f` -lt 2 ; then
X						wc -l /usr/tmp/$f >> $workdir/$failrpt
X						echo "$pr: '/usr/tmp/$f' should have at least 2 lines." >> $workdir/$failrpt
X					fi
X				fi
X			done
X			# if we're OK
X			if test ! -f $workdir/$failrpt ; then
X				echo "$pr: Extraction succeeded." | tee -a $workdir/$report
X				ls -l $getlist
X				# if it's a onedisk archive
X				# and we haven't already checked the label
X				# and it's a real tape
X				# and our parent didn't already do it,
X				# we need to check media contents vs. label here
X				if test $getmode = onedisk -a $mtype != dir -a $mtype != file -a -z "$parent" ; then
X					report_p=/usr/tmp/$breport
X					eval "$LABELQ"
X				fi
X			fi
X			rm -f $getlist
X		;;
X		*dump*)
X			## get last file in dump
X			# if nothing was dumped, we should get:
X			# '. is not on tape'	most versions of restore
X			# '. is not on volume'	SunOS 4.1.2, others?
X			x=`egrep '\. is not on (tape|volume)' $vlist  | sed 1q`
X			if test -n "$x" ; then
X				lastfile="$x"
X			# else get lastfile (usually a "leaf" but maybe a "dir")
X			else
X				lastfile=`grep '^leaf' $vlist | sort +1n -2 | tail -1 | awk '{print $NF}'`
X				# if there are only directories, e.g. it's
X				# a brand new filesystem with only lost+found
X				if test -z "$lastfile" ; then
X					lastfile=`grep '^dir'  $vlist | sort +1n -2 | tail -1 | awk '{print $NF}'`
X				fi
X			fi
X
X			## We decide an archive is OK if it looks like a
X			## "normal" empty archive, e.g. ". is not on tape"
X			## Known failures go in $workdir/$failrpt
X			case $lastfile in
X			# we have a problem
X			'')
X				# show any error messages from 'restore t'
X				echo "$pr: Error messages from 'restore t':"
X				tail -20 $vlist | tee -a $workdir/$failrpt
X				echo "$pr: Something went wrong with choosing the last file on the archive." | tee -a $workdir/$failrpt
X
X			;;
X			# nothing was dumped - a common incremental situation
X			# but wrong for a full dump.
X			'. is not on '*)
X				echo ''
X				echo "$pr: The 'restore tf ...' says '$lastfile', so nothing was dumped." | tee -a $workdir/$report
X				# if we can't check further
X				if test $getmode = onedisk ; then
X					# just give message
X					echo "$pr: Please check the tape label."
X					while : ; do
X						echo "$pr: Is this a full or incremental backup tape?"
X						echo $epre "$pr: Enter 'f' for full, 'i' for incremental: "$esuf
X						eval "$READ" ans
X						case $ans in
X						[fF]*)	bkp_was=full ; break ;;
X						[iI]*)	bkp_was=incr ; break ;;
X						esac
X					done
X				# else check this ourselves!
X				else
X					if grep '^#Invocation:.* incr.*' $workdir/$breport > /dev/null 2>&1 ; then
X						bkp_was=incr
X					else
X						bkp_was=full
X					fi
X				fi
X				if test $bkp_was = incr ; then
X					echo "$pr: This is a common incremental situation." | tee -a $workdir/$report
X				else
X					echo "$pr: This is wrong for a full dump." >> $workdir/$failrpt
X				fi
X			;;
X			# we have a real file name, so try to get it
X			*)
X				echo ''
X				echo "$pr: The last file in the archive is '$lastfile'."
X				case $mtype in
X				dir|file)	: do nothing ;;
X				*)		echo '' ; echo "$pr: Repositioning the $media again; Please wait." ;;
X				esac
X				eval "$SKIP2ARCHIVE"
X
X				## Q: if autoverify==true, can we really do it?
X				## A: if and only if one of these is true
X				##    * the entire archive is on the same tape
X				##    * it's a file
X				##    * it's a group of files in a directory
X				## (see also similar code for setting $notcont)
X				#
X				# if we aren't doing autoverify
X				if test $autoverify != true ; then
X					do_auto=false
X				# else we can handle disk files
X				elif test $mtype = file -o $mtype = dir ; then
X					do_auto=true
X				# else if there's more than one volume for
X				# a onedisk verify
X				elif test $getmode = onedisk -a $nvol -gt 1 ; then
X					do_auto=false
X				# else if we were told that this filesystem
X				# wasn't continued onto the next volume,
X				# we can handle it
X				elif test "$cont2next" = false ; then
X					do_auto=true
X				# else if our archive is on the last volume
X				# of the set, we can handle it
X				elif test $onvol = $nvol ; then
X					do_auto=true
X				# else if this filesystem is continued, it will
X				# say "... $fs (continued)" in $firstblist
X				elif grep " $fs (continued)" $firstblist > /dev/null ; then
X					do_auto=false
X					echo "$pr autoverify: Filesystem '$fs' is split over multiple volumes."
X					echo "$pr autoverify: Cannot actually autoverify '$fs'."
X					echo "$pr autoverify: Doing normal verify of '$fs'."
X					eval "$EXITQ"
X				# else if the operator didn't know the name of
X				# the first filesystem the next tape, punt.
X				elif sed -n -e "`expr $onvol + 1`p" $firstblist | grep ' unknown$' > /dev/null ; then
X					do_auto=false
X					echo "$pr autoverify: The first filesystem on the next volume is 'unknown', so"
X					echo "$pr autoverify: '$fs' might be split over multiple volumes."
X					echo "$pr autoverify: Cannot actually autoverify '$fs'."
X					echo "$pr autoverify: Doing normal verify of '$fs'."
X					eval "$EXITQ"
X				# else so far as we can tell this filesystem
X				# is on only one volume
X				else
X					do_auto=true
X				fi
X
X				# now try to get the last file in the archive
X				# echo's are for typical questions listed in
X				# comments on $GVRPT_ED
X				echo "$pr: Extracting into '`pwd`'" | tee -a $workdir/$report
X				case $do_auto in
X				true)	echo "$pr: IGNORE the 'Specify next volume #:' question." ;;
X				false)	echo "$pr: ANSWER the 'Specify next volume #:' question." ;;
X				esac
X
X				# $getlist, $rans, $rmode, $rout for $DO_GET
X				getlist="$lastfile"
X				case $do_auto in
X				true)	rans="{ echo 1 ; echo n ; } |" ;;
X				false)	rans="" ;;
X				esac
X				rmode="xv"
X				rout="2>&1 | tee -a $workdir/$report"
X				eval "$DO_GET"
X
X				# did we pass or not?
X				echo ''
X				pwd | tee -a $workdir/$report
X				lsout="`ls -ld $lastfile      2> /dev/null`"
X				lserr="`ls -ld $lastfile 2>&1  > /dev/null`"
X				if test -n "$lsout" ; then
X					echo "$lsout" | tee -a $workdir/$report
X				else
X					echo "$lserr" >> $workdir/$failrpt
X				fi
X			;;
X			esac
X		;;
X		esac
X	;;
X	esac
X
X	## take tape offline and finish get/verify report and send to $rptto
X	# if this backup/verify was called by a parent backup/verify
X	if test -n "$parent" ; then
X		# simply rewind tape
X		eval "$REW"
X	else
X		# else take the tape offline (if $offline is true)
X		# do $OFFLINE work in "/" in case user wants to
X		# wants to umount a filesystem we may have just restored;
X		# also run it in background so user doesn't have to wait
X		cd /		
X		eval "$OFFLINE" &
X	fi
X	cd $workdir		# finish up in $workdir
X	echo "$GVRPT_ED" | ed - $report
X	if   test $mode = verify -a -f $failrpt ; then
X		cat $failrpt
X		echo "$pr: Verify of '$fsproxy' FAILED."
X	elif test $mode = verify -a $multi != true ; then
X		echo "$pr: Verify of '$fsproxy' PASSED."
X	elif test $mode = verify -a $multi = true ; then
X		egrep 'PASSED|FAILED' $report
X		if grep FAILED $report > /dev/null ; then
X			echo "$pr: Verify of '$fsproxy' FAILED."
X		else
X			echo "$pr: Verify of '$fsproxy' PASSED."
X		fi
X	elif test -f $failrpt ; then
X		cat $failrpt
X	else
X		: no failure and not verify mode so do nothing
X	fi \
X	| tee -a $report
X	enddate=`date`
X	echo "#End time:   $enddate" >> $report
X	if test -n "$parent" ; then
X		grep "$pr: Verify of " $report >> ../$report
X		echo "#Verify end: $enddate" >> ../$report
X		eval "$MAILRPT"
X	fi
X;;
Xesac
X
X## Final cleanup
Xcd $workdir
Xecho ''
X# while we're sending mail and there was a problem we need to report, and
X# we don't have a parent backup/verify, send $report to $propbto
X# (the while loop gives us something to break out of if we're doing a verify)
Xeval "$PROBTO"		# figure out who we're supposed to send problems to
Xwhile test $mail = true -a -n "$probto" -a \( -s $probsend -o -s $failrpt \) -a -z "$parent" ; do
X	while echo $mode | egrep 'get|verify' > /dev/null ; do
X		echo $epre "$pr: Do you want to send a '$mode' problem report to $probto? [yn] "$esuf
X		eval "$READ" ans
X		case $ans in
X		[yY]*)	echo "$pr: OK, will do." ; break ;;
X		[nN]*)	break 2	;;
X		*)	continue ;;
X		esac
X	done
X	mailerr=mail.err	# save stdout and stderr from $MAILER errors
X	{
X		# show real operator login for any automated processer scripts
X		echo "%login=$operlogin"
X		# report *new* problem filesystems if there are any
X		case $mode in full|incr|tincr) echo 'NEW problem filesystem(s) BEGIN:' ;; esac
X		test -f $probsend && cat $probsend
X		case $mode in full|incr|tincr) echo 'NEW problem filesystem(s) END.'   ;; esac
X		echo ''
X		cat $report
X		# if we're doing a get or verify, we may have extracted a
X		# backup report file from the media
X		echo ''
X		case $mode in
X		get|verify)
X			if test -f $breport ; then
X				echo "Sending extracted backup report:"
X				cat $breport
X			else
X				echo "No extracted backup report to send."
X			fi
X		;;
X		esac
X	} \
X	| $MAILER -s "backup $mode failed $lhost:~backup/$wdir" $probto > $mailerr 2>&1
X	# if we detect a mailer failure
X	if test $? -ne 0 -o -f dead.letter -o -s $mailerr ; then
X		echo "$pr: WARNING: The mailer '$MAILER' had"
X		echo "$pr: problems sending a failure report!!!"
X		test -s $mailerr && cat $mailerr
X	# else
X	else
X		# record the fact that we've tried to report this problem
X		test -f $probsend && cat $probsend >> $probsent
X		# make sure $probsent is readable by backup account
X		chmod 644 $probsent
X	fi
X	# make sure we break out
X	break
Xdone
X
X# if we just completed a backup, ask if they want to report problems
X# and tell the user how to label any tapes
Xcase $mode in
Xfull|incr|tincr)
X	echo ''
X	while test $probq = true ; do
X		echo $epre "$pr: Do you want to report any problems with this backup? [yn] "$esuf
X		eval "$READ" ans
X		case "$ans" in
X		[yY]*)
X			echo "$pr: Enter reason for failure.  Type as many lines as you want."
X			echo "$pr: Then type '<ctrl>D' when you are done:"
X			cat >> $failrpt
X			echo "$pr: Thank you."
X			break
X		;;
X		[nN]*)
X			echo "$pr: No failure will be reported.  Thank you."
X			break
X		;;
X		*)	
X			echo "$pr: Answer 'y' or 'n'."
X			continue
X		;;
X		esac
X	done
X	case $mtype in
X	dir|file)
X		: no labels for a disk file or directory
X	;;
X	null)
X		# no labels for null archive, but we should remind user
X		echo ''
X		echo "$pr: WARNING! media is '$media' !!!"
X		echo "$pr: NO BACKUP WAS MADE !!!"
X	;;
X	*)
X		echo "$pr: Please label the backup $media(s) as shown below."
X		cat $firstblist
X	;;
X	esac
X;;
Xesac
X# if we're not a child verify
Xif test -z "$parent" ; then
X	echo "$pr: We're done.  Thanks!  Bye!"
Xfi
Xchown backup . `echo * | sed -e "s/$pr //" -e "s/$pr\$//"`
X# Silently expire any old work directories if we're doing a backup.
X# Don't do this if we are doing a get or verify, since we may be on a machine
X# that has a monthly backup schedule, and we may not want to have these old
X# work dirs disappear.
Xcase $mode in
Xfull|incr|tincr)
X	cd $hdir
X	# Toss stderr from subshell so operator doesn't see
X	# the background PID for the "find".
X	# Toss stdout from the subshell so operator doesn't see
X	# "Sending output to 'nohup.out'" from nohup
X	(
X		# Must nohup "find" and do it in background so it can continue
X		# after script exits.  Throw out stderr since
X		# "[01][0-9][0123][0-9].*" won't exist on new alldisks hosts.
X		nohup find [01][0-9][0123][0-9].* -type d -mtime +$expire -exec /bin/rm -rf '{}' \; 2> /dev/null &
X
X	) > /dev/null 2>&1
X	# we don't care about nohup.out - sleep 3 seconds to let previous
X	# nohup create nohup.out before we blow it away
X	( sleep 3 ; rm -f nohup.out & ) > /dev/null 2>&1
X;;
Xesac
X
X## Th-th-th-that's all, folks!
SHAR_EOF
echo 'File src/backup/backup is complete' &&
chmod 0755 src/backup/backup ||
echo 'restore of src/backup/backup failed'
Wc_c="`wc -c < 'src/backup/backup'`"
test 158638 -eq "$Wc_c" ||
	echo 'src/backup/backup: original size 158638, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= src/backup/bkp.site ==============
if test -f 'src/backup/bkp.site' -a X"$1" != X"-c"; then
	echo 'x - skipping src/backup/bkp.site (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting src/backup/bkp.site (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'src/backup/bkp.site' &&
X:
X# This is "bkp.site", a configuration file sourced by
X# the 'alldisks' backup script.  Remember - it is Bourne shell "sh" code.
X# If you break it, it will break 'alldisks' in a more or less serious fashion.
X#
X# You should read through bkp.site carefully, making changes depending on what
X# you'd like to see at your site.
X#
X# You will probably leave most of this unchanged.  However, you may want
X# to do something about the PROBTO macro.  If you have HP-UX 8.0 at your
X# site, you may want to consider uncommenting the HACK4HPUX8 macro.
X#
X# If you leave everything unchanged, then you actually don't need to install
X# this file.  Whatever you do, you can change your mind later and re-install
X# or de-install it as appropriate.
X#
X# Some of the parameters set here are actually MACROs.  MACROs are
X# single-quoted or double-quoted strings containing Bourne shell code.
X# They are used by eval'ing them within double-quotes, like this:
X#	eval "$MACRO"
X# MACROs are often used where we might use Bourne shell functions if
X# they existed everywhere.
X#
X# Variables with "CAPITAL" letters are used throughout these scripts to
X# designate several different types:
X# 	1) System environment variables (e.g. $PATH)
X#	2) sahead/saenv variables (e.g. $STASH and $RSH_C)
X#	3) simple strings (e.g. $USAGE)
X#	4) macros (e.g. $PROBTO)
X#
X# Variables with "lowercase" letters are used throughout these scripts to
X# designate simple local (unexported) variables.
X#
X# bkp.site has simple variables followed by MACROs.
X
X# ============================================================================
X##
X##		Simple Variables for 'inst-alldisks' and 'linst-alldisks'
X##
X## These four simple variables ($bhdir, $bkpuid, $chkaixdev, $perm) are
X## only used by 'inst-alldisks' and/or 'linst-alldisks'.  All the other
X## variables and MACROs are only used by the alldisks script itself,
X## and are listed in alphabetical order.
X
X## bhdir
X# Default home directory for backup account
X#
X# Change and uncomment if you want it to be something else
X# bhdir=/home/backup	# (default /home/backup)
X
X## bkpuid
X# Default UID for backup account
X#
X# Uncomment and pick a UID which doesn't conflict with other UIDs at your site.
X# bkpuid=194		# (default 194)
X
X## chkaixdev
X# Default is for 'linst-alldisks' not to warn about AIX video drives using
X# only half the tape capacity.
X#
X# chkaixdev=true	# warn about AIX 3.X video drives
X# chkaixdev=false	# no warning about AIX 3.X video drives (default)
X
X## perm
X# Try to install the backup script as setuid or not setuid.
X# Setuid scripts aren't supported everywhere, so this is only what we try
X# to do if $perm is set to 4755.
X#
X# Uncomment one of these
X# perm=755		# not setuid root (default)
X# perm=4755		# setuid root
X
X# ============================================================================
X##
X##		Simple Variables for 'alldisks' Backup Script
X##
X## These simple variables below are only used by the alldisks script itself
X## and are listed in alphabetical order.
X
X## $expire
X# How long should we keep old log directories?  We'll remove anything
X# over $expire days old.  Backup home directories on cpio machines
X# are typically larger than ones which use BSD dump, but experience
X# shows that keeping them 21 days will add roughly 0.5Meg to 2Meg
X# to backup's home directory.
X#
X# Uncomment and pick some positive integer
X# expire=21		# (default 21)
X
X## $incr
X# Incremental dump level (alldisks cpio backups only understand level "full"
X# and level "incr")
X# In general, it is recommended that you do a full backup of each filesystem
X# once per week, and an incremental backup of each filesystem on the
X# other days.
X#
X# Uncomment and pick some integer between 1 and 9
X# incr=5		# (default 5)
X
X## $joke
X# Try it, you'll like it!  (or hate it!)
X#
X# Uncomment one of these lines:
X# joke=true		# do cpio joke if using cpio (default)
X# joke=false		# don't do cpio joke
X
X## $mail
X# Do we send backup/get/verify reports to $rptto and problem reports to
X# $probto?  (See also $rptto below)
X#
X# Uncomment one of these lines:
X# mail=true		# send reports to $rptto (default)
X# mail=false		# don't send reports to $rptto
X
X## $probto
X# Who do we send problems to?  (See also $PROBTO macro below)
X#
X# Uncomment this line and enter a list of valid mail recipients
X# probto="acct1 acct2"	# (default root)
X
X## $rptto
X# Who do we send backup/get/verify to?  (See also $mail above)
X#
X# Uncomment this line and enter a list of valid mail recipients
X# rptto="$STASH"	# (default "$STASH")
X
X## $offline
X# Some sites don't like to leave tapes ejected when the backups are done.
X# If ejected, tapes are more vulnerable to dust or being hit.  On the
X# other hand, some drives take a long time to eject a tape and having
X# 'alldisks' do it for you will save a lot of time.
X#
X# Uncomment one of these lines:
X# offline=true		# take tape offline when done (default)
X# offline=false		# don't take tape offline when done
X
X# ============================================================================
X##
X##		MACROS
X##
X
X## HACK4HPUX8 - work around HP-UX 8.0 dump/rdump bug
X# Make sure /etc/dumpdates is 664, group operator.
X# Best if readable by world, because HP-UX 8.00 may foil us otherwise.
X# Besides, it probably can't hurt if ordinary users can read it.
X# HP-UX 8.00 has a bug where "dump" called from a setuid script
X# can read a 660 dumpdates but "rdump" can't, even though they are
X# the same binary!
X#
X# If you have this bug, and you want to work around it, and don't
X# mind opening permissions up a bit, you can try uncommenting the 4 lines
X# below.  They just chmod/chgrp the dang file, and hope that does
X# the trick.  Note: later on in the script, similar code will be called
X# *and the script will exit* if we actually trip over the bug with
X# the first failed dump/rdump.  That's because the dump has not
X# been properly logged (but hopefully all following dumps will be).
X#
X#HACK4HPUX8='
X#chmod 664 /etc/dumpdates
X#chgrp operator /etc/dumpdates
X#'
X
X## PROBTO - define $probto, which is who we send problem reports to
X# We'd like to know about problems.  The question is who do you tell?
X# Sites with only two sysadmins might send email to both of them
X# by doing something like this:
X# 
X#	PROBTO='probto="sysad1@herhost sysad2@hishost"'
X#
X# Sites with a larger sysadmin crew might have a more complicated
X# decision making process.  At Ingres, we email problem reports to queues
X# in our 'calltrack' problem-tracking Ingres application.  Which queue
X# we mail it to depends on what we're doing and what OS we're running on:
X#	PROBTO='
X#	case $mode$OS_S in
X#	get*|verify*)   probto="callt-3@$SAHOST"  ;;	# probs to backup queue
X#	*ULTRIX)        probto="callt-16@$SAHOST" ;;	# probs to Ultrix queue
X#	*)              probto="callt-12@$SAHOST" ;;	# probs to UNIX queue
X#	esac
X#	'
X#
X# Unless PROBTO redefines it, $probto is set to 'root' (default).
X#
X# Uncomment this line and enter a list of valid mail recipients
X# PROBTO='probto="root"'	# (default "root")
X
X## DOPOSTDEFS - Do after definitions
X# This MACRO is sourced after simple variable and MACROs are defined,
X# but before any output goes to the screen or command arguments are processed.
X# Sites may want to override some of the initial assumptions, or perhaps
X# take care of some early housekeeping like sending an email message
X# whenever the backup script starts.
X#
X# Uncomment this line and change as necessary
X# DOPOSTDEFS=''
X
X# ============================================================================
X##
X##	End of bkp.site
X##
SHAR_EOF
chmod 0644 src/backup/bkp.site ||
echo 'restore of src/backup/bkp.site failed'
Wc_c="`wc -c < 'src/backup/bkp.site'`"
test 7496 -eq "$Wc_c" ||
	echo 'src/backup/bkp.site: original size 7496, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= src/backup/bkp.opers ==============
if test -f 'src/backup/bkp.opers' -a X"$1" != X"-c"; then
	echo 'x - skipping src/backup/bkp.opers (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting src/backup/bkp.opers (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'src/backup/bkp.opers' &&
X#initls	login		fullname
Xcron	cron		automated by cron
Xjd	jdoe		jane doe
Xringo	ringo		ringo starr
SHAR_EOF
chmod 0644 src/backup/bkp.opers ||
echo 'restore of src/backup/bkp.opers failed'
Wc_c="`wc -c < 'src/backup/bkp.opers'`"
test 96 -eq "$Wc_c" ||
	echo 'src/backup/bkp.opers: original size 96, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= src/backup/bkp.media ==============
if test -f 'src/backup/bkp.media' -a X"$1" != X"-c"; then
	echo 'x - skipping src/backup/bkp.media (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting src/backup/bkp.media (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'src/backup/bkp.media' &&
X# bkp.media - device data for some/all backup devices at your site
X#
X# Put the master version of this file in $SAHOST:~sa/dist/bkp.media.
X# It is distributed by $SAHOST:~sa/bin/inst-alldisks.
X# It is searched by the 'alldisks' backup script.
X#
X# The first time you fill this out, you will want to replace Vendor/OS names
X# with hostnames that have tape drives at your site.  They are shown this
X# way here for your convenience, but 'alldisks' will not understand them
X# if you leave them that way.  Make sure you copy the appropriate entries
X# and change them for the real hostnames of your machines.
X#
X# Device names vary between UNIXs and between systems, as you know,
X# so make sure your device names are correct.  The 'alldisks'
X# script will try to complain if they are wrong, but it's much safer to
X# get your rewind/norewind device names correct the first time.
X# (Lots of operating systems are shown below, but many of these entries
X# have been taken from machines with sometimes unusual device names.)
X#
X# EXAMPLE: If you have a Sun running SunOS called "jumper",
X# which has an Exabyte 8200 with rewind/norewind device names
X# /dev/rst0 and /dev/nrst0, then copy this entry:
X#SunOS	video0	xx	400000	rst1		nrst1		126 165000 E82
X# Then make the new entry like this (without the hashmark '#'):
X#jumper	video0	xx	400000	rst0		nrst0		126 165000 E82
X#
X# If the fourth field (the number of 5k blocks per tape) says "xx",
X# it means we've probably never tried to do a cpio backup to such a
X# device for that OS/Vendor.  It should work if you fill in an appropriate
X# number, but without testing who knows?
X#
X# The Rules:
X# 1) Comment lines begin with a hashmark (#).
X# 2) Fields are seperated by white space.  The last column (for QICformat,
X#    cpio options, and dump options) can have several space-seperated options.
X# 3) All fields must be filled in (true since alldisks script version 2.07).
X# 4) The table is sorted in alphabetical order by hostname for convenience,
X#    and each device on each host must have it's own line/entry.
X# 5) Different "media alias" names for the same "devices" are accepted.
X#    (See "video/video0" example for bushdog below.)
X# 6) Identical "media alias" names the for same "host" are a Bad Idea.  The
X#    'alldisks' script gets confused by two "tape0" entries for the same host.
X# 7) The third field is unused as of alldisks 4.23, but put "xx" in it anyway.
X# 8) The "# of 5k blocks per tape" field must be true decimal.  For example,
X#    use "10000" not "10k".
X# 9) The fourth and fifth columns for device names should be the real OS device
X#    names, not the Data Center standard device names.
X#10) The last column may contain several space-seperated fields.  It
X#    holds a) dump options, b) cpio options, and/or QICformat/Exabyte info.
X#    The QICformat info in the last column is FYI only; the script explicitly
X#    ignores it.  "alldisks" script figures out what each option means
X#    according to what it looks like:
X#       1000|1600|3200|6250|6670|23000)			dump "d" density
X#	4|9|18)						dump "t" tracks
X#	126|[1-9][02468])				dump "b" blocking factor
X#	330000|165000|[1-9][02][05]|[1-9][0-9][02][05])	dump "s" size option
X#	c|C)						dump "c|C" cart option
X#	C)						cpio "C" cart option
X#	QIC*)						ignored
X#	E8[25])						ignored
X#	DAT1|DAT2)					ignored
X#    The alldisks script builds the dump/cpio key from this column.
X#
X# The Ingres Data Center has standard device names, e.g. /dev/video0/8500nr.
X# But we want the OS device names (not DC standard device names) because:
X# a) this is a handy place to document the real OS device names
X# b) the DC device names don't do you any good when you want to know which
X# device drivers were used to make the tapes, e.g. was it "rrt0" (third party
X# Ciprico drivers) or "rmt0" (Sun drivers).
X#
X# We can construct dump, rdump, restore, and rrestore commands like this:
X#	/etc/dump $level$key $device $options $fsname
X#	/etc/rdump $level$key $remhost:$device $options $fsname
X#	/etc/restore if $device
X#	/etc/rrestore if $remhost:$device
X#
X###############################################################################
X# Tape capacity notes and info
X#
X# 1) The capacity of a 9track tape at a given density varies due to:
X#	a) manufacturer's minimum/maximum interrecord gap for the drive
X#	b) device drivers use different interrecord gaps if they are streaming
X#          or not
X#	c) temperature (1%-2%)
X#
X# 2) It's a Good Idea to use 12500 ftpi (Frame Tracks Per Inch) carts
X# in all cartridge drives at QIC150 density or less
X#
X# 3) The highest "-b" blocking factor available with most tape drives is 126,
X# which is equivalent to 63k.
X# 
X# Dump defaults and other info from SunOS 4.x dump(8) man page and
X# other sources appear below.
X# 
X#                                                dump option
X#                                       =============================   # of 5k
X#                              capacity    "-b"   "-t"   "-s"    "-d"    blocks
X# media                           using   block   cart   size density       per
X# type  description                dump factor* tracks (feet)   (BPI)      tape
X# ----- ------------------------- ===== ------- ------ ------ -------  ========
X# tk50  TK50                        70M?     ??     NA     NA    6670?
X# tk70  TK70                        90M?     ??     NA     NA    6670?
X# cart  QIC11   600' 1/4"           25M      ??      4    425    1000    5000
X# cart  QIC24   600' 1/4"           60M      ??      9    425    1000   12000
X# cart  QIC120  600' 1/4"          120M      ??     NA     NA      NA   24000
X# cart  QIC150  600' 1/4"          150M      ??     18    600    1000   30000
X# tape  9track 2400' 1/2"           45M      32     NA   2300    1600    6600**
X# tape  9track 2400' 1/2"          145M      32     NA   2300    6250   18000
X# video Exabyte 8200 112m 8mm     2200M     126     NA 165000      NA  400000
X# video Exabyte 8500 112m 8mm     5000M     126     NA 330000      NA
X# video Exabyte 8200 112m 8mm     2200M     126     NA   6000   54000  400000
X# video Exabyte 8500 112m 8mm     5000M     126     NA  13000   54000
X# diskette (dump option "-D")     1.44M***   NA     NA     NA      NA
X#
X# *   Blocking factor shown here in 512-character blocks.  However versions
X#     of BSD dump from some vendors e.g. Pyramid and HP, require that this
X#     be specified in 1k blocks.  Also, Pyramid's blocking factor must be
X#     an even number, e.g. "62".  Values shown here are common but not
X#     definitely not universal.  See your OS manuals for more info.
X# **  based on actual tests with CDC (avg 6950) and Cipher (avg 7380) drives
X# *** (Actually 1422 blocks, with one cylinder reserved for bad block info.)
X#
X###############################################################################
X#
X# Reminder:	Fields are separated by white space (spaces or tabs).
X#		All fields must be filled in.
X#
X#			# of 5k	OS		OS
X#        		blocks	name for	name for	QICformat/
X# host-	media		per	rewind		no-rewind	cpio options/
X# name	alias	unused	tape	device		device		dump options
X#------	-------	-------	-------	--------------	--------------- --------------
X#AIX2.1	cart0	xx	30000	rmt0		rmt4		QIC150
X#AIX2.1	cart1	xx	8000	rmt1		rmt5		QIC24
X## AIX3.0 "video0" example uses 512byte blocks, so it can only hold 1Gig
X## AIX3.0 "video1" example uses proper 1024byte blocks, so it can hold 2Gig
X#AIX3.0	cart0	xx	30000	rmt0		rmt0.1		QIC150
X#AIX3.0	video0	xx	200000	rmt1		rmt1.1		E82
X#AIX3.0	video1	xx	400000	rmt0		rmt0.1		E82
X#ATTSVR3	cart0	xx	12000	rmt/c1t2d0s0	rmt/c1t2d0s0n	QIC60
X#ATTSVR3	cart0	xx	24000	rmt/c1t2d0s1	rmt/c1t2d0s1n	QIC120
X#ATTSVR3	tape0	xx	6600	rmt/0m		rmt/0mn
X#Arix	cart0	xx	30000	rmt0		rmt1		QIC150
X#Auspex	video0	xx	xx	rast4		nrast4		100 141000 11500
X#Auspex	video1	xx	xx	rast9		nrast9		100 141000 11500
X#B.O.S.	cart0	xx	xx	rct/0		rct/0n		C QIC150
X#B.O.S.	cart0	xx	xx	rct/0		rct/0n		C QIC150
X#BSDI	video0	xx	400000	rmt0		nrmt0		165000 E82
X## Convergent's cart says QIC150 but can only hold 125Meg :-(
X#Convergent cart0 xx	25000	rmt0		rmt4		QIC150
X#ConvexOS tape0	xx	25000	rmt/0h		rmt/0hn		6250
X#ConvexOS tape1	xx	25000	rmt16		rmt20		6250
X#DG/UX	cart0	xx	xx	rmt/0		rmt/0n		M QIC150
X#DG/UX	dat0	xx	400000	rmt/1		rmt/1n		M DAT2
X#Dynix	cart0	xx	xx	rts0		rts8		1000 600 QIC24
X#Dynix	tape0	xx	25000	rmt10		rmt14		6250 2000
X#Dynix	video0	xx	xx	rmt/xt0		rmt/xt0n	E82 165000
X#Dynix/ptx cart0 xx	8000	rmt/tm0		rmt/tm0n	QIC24
X#Dynix/ptx cart0 xx	xx	rSA/ctape0	rSA/ctape0n	1000 600 QIC24
X#Dynix/ptx video0 xx	xx	rmt/tx0		rmt/tx0n	126 165000
X#Dynix/ptx video0 xx	xx	rmt/xt0		rmt/xt0n	165000
X#HP-UX	dat0	xx	200000	rmt/0m		rmt/0mn		70000 DAT1
X#HP-UX	dat1	xx	400000	rmt/1m		rmt/1mn		140000 DAT2
X#HP-UX	tape0	xx	25000	rmt/0h		rmt/0hn		6250
X#Motorola cart0	xx	25000	rSA/ctap	rSA/ctape	QIC150
X#NCRSVR3 cart0	xx	24000	rstp/34ny	rstp/34nn	QIC120
X#NCRSVR3 video0	xx	400000	rmt/0ny		rmt/0nn
X#NCRSVR4 cart0	xx	64000	rmt/c1t1d0s0ny	rmt/c1t1d0s0nn	QIC320
X#NCRSVR4 video0	xx	400000	rmt/c11t3d0s0ny	rmt/c11t3d0s0nn	126 165000
X#OSx	tape0	xx	24000	iop/rptape00h	iop/rptape00hn	6250 2200
X#OSx	tape0	xx	25000	iop0/rptape000h iop0/rptape000hn 6250
X#OSx	video0	xx	xx	iop/rptape01	iop/rptape01n	E82 62 165000
X#SCO	cart0	xx	8000	rct0		nrct0
X#Solaris video0	xx	xx	rmt/0		rmt/0n		126 165000 E82
X#Solaris video1	xx	xx	rmt/9		rmt/9n		126 165000 E85
X#Solbourne video0 xx	xx	rst1		nrst1		126 165000 E82
X#Stardent cart0	xx	22000	rmt/c0d6h	rmt/c0d6hn	QIC150
X#SunOS	cart0	xx	22000	rst0		nrst0		18 600 1000 c QIC150
X#SunOS	tape0	xx	25000	rmt0		nrmt0		6250
X#SunOS	video0	xx	400000	rst1		nrst1		126 165000 E82
X#SunOS	video1	xx	1000000	rst8		nrst8		E85 126 330000
X## TI's cpio option "-T" would be nice for readability on other machines, but
X## TI can't read multi-vol archives if written using "-T".
X#TI_SVR3	cart	xx	12000	rqt/0h		rqt/0hn		QIC60
X#UMIPS	cart0	xx	24000	rmt/Q120-0	rmt/Q120n-0	23000 600 QIC120
X#UTS	tape0	xx	xx	rmt0		nrmt0		1600
X#UTS	tape1	xx	xx	rmt1		nrmt1		6250
X#UTS2.1	tape0	xx	24000	rmt/181h	rmt/181hn	6250
X#Ultrix	tape0	xx	25000	rmt2h		nrmt2h		6250 2200
X#Ultrix	tk0	xx	xx	rmt1h		nrmt1h		TK50 6670
X#Ultrix	video0	xx	xx	rmt1h		nrmt1h		165000
X#Ultrix	video1	xx	xx	rmt1h		nrmt1h		330000
X#
X# Reminder:	Fields are separated by white space (spaces or tabs are fine).
X#		All fields must be filled in.  See "The Rules" above.
X#
SHAR_EOF
chmod 0644 src/backup/bkp.media ||
echo 'restore of src/backup/bkp.media failed'
Wc_c="`wc -c < 'src/backup/bkp.media'`"
test 10285 -eq "$Wc_c" ||
	echo 'src/backup/bkp.media: original size 10285, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= src/backup/backup.dd ==============
if test -f 'src/backup/backup.dd' -a X"$1" != X"-c"; then
	echo 'x - skipping src/backup/backup.dd (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting src/backup/backup.dd (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'src/backup/backup.dd' &&
X:
X# backup.dd - written by Bob Arnold
X
X# handles unusual dd outputs from several vendors (see end of script)
X# requires $LHOST and $MHOST environment variables
X# handles writing to remote hosts (requires $RSH_C from environment)
X# exits with non-zero exit status if
X#	a) no data is written
X#	b) interrupted
X#	c) we get an unexpected output message from "dd"
X
X#set -x
X
Xtrap 'rm -f \$t1 \$t2 \$t3 ; exit 1' 1 2 3 15
X
Xpr=`basename $0`
Xargs="$*"
Xt1=/tmp/bkpddt1.$$
Xt2=/tmp/bkpddt2.$$
Xt3=/tmp/bkpddt3.$$
X
X# need LHOST and MHOST, can live without BDDSHOW
Xif test -z "$LHOST" ; then
X	echo "$pr: \$LHOST not set in environment" 1>&2
X	exit 1
Xelse
X	lhost="$LHOST"
Xfi
Xif test -z "$MHOST" ; then
X	echo "$pr: \$MHOST not set in environment" 1>&2
X	exit 1
Xelse
X	mhost="$MHOST"
Xfi
X
Xif test $lhost = $mhost ; then
X	if test "$BDDSHOW" = true ; then
X		echo "$pr: dd $args 2> $t1" > /dev/tty
X	fi
X	dd $args 2> $t1
X	ddstat=$?
Xelse
X	if test -z "$RSH_C" ; then
X		echo "$pr: \$RSH_C not set in environment" 1>&2
X		exit 1
X	# else assume we have permission to run commands on $host
X	else
X		if test "$BDDSHOW" = true ; then
X			echo "$pr: $RSH_C $mhost dd $args '&& echo ok' \> $t3 2> $t1" > /dev/tty
X		fi
X		# must create $t3 on the remote host; otherwise it will
X		# merge with dd's standard out which is a bummer!
X		$RSH_C $mhost dd $args '&& echo ok' \> $t3 2> $t1
X		if test "`$RSH_C $mhost cat $t3 2>&1`" = ok ; then
X			ddstat=0
X		else
X			ddstat=1
X		fi
X		$RSH_C $mhost /bin/rm -f $t3
X	fi
Xfi
X
X# massage data only if we have exactly two lines and $ddstat is 0
Xif test `wc -l < $t1` -ne 2 -o $ddstat -ne 0 ; then
X	cp $t1 $t2
Xelse
X	# first sed takes care of AIX 3.0 and newer versions too
X	# awk deals with TI
X	# second sed deals with TI and CCI SysV
X	sed -e 's/^.* \([0-9][0-9]*+[0-9][0-9]*.*\)\.$/\1/' $t1 \
X	| awk '
X		{
X			if ($0 ~ /^dd [a-z ]* [0-9]* full blocks and [0-9]* partial blocks *$/) {
X				if ($2=="read") {io="in"}
X				else {io="out"}
X				print $3 "+" $7, $9, io
X			} else {
X				print
X			}
X		}' \
X	| sed -e 's/block/record/' > $t2
Xfi
X
X# now that we have a reasonable output, see if we have a problem
Xif test $ddstat -ne 0 ; then
X	exitstat=$ddstat
Xelif egrep '0+0 records out' $t2 > /dev/null ; then
X	exitstat=1
Xelif test `egrep '^[0-9]+\+[0-9]+ records [io][nu]t* *$' $t2 | wc -l` -ne 2 ; then
X	exitstat=1
Xelse
X	exitstat=0
Xfi
X
X# put (possibly massaged) dd output on stderr, cleanup, and exit before comments
Xcat $t2 1>&2
Xrm -f $t1 $t2 $t3
Xexit $exitstat
X
X# Sample dd outputs that we have to massage to conform to normal dd output
X#
X# Normal dd output
X# 0+0 records in
X# 0+0 records out
X#
X# AIX 3.0 and 3.1 dd output has extra "dd: 0511-040 " and trailing ".".
X# dd: 0511-040 1+0 records in.
X# dd: 0511-041 1+0 records out.
X#
X# AIX 3.2 dd output has extra "dd: " and trailing ".".
X# dd: 1+0 records in.
X# dd: 1+0 records out.
X#
X# TI dd output (user-friendly but experienced-sysadmin- and script-hostile)
X# dd read  21194 full blocks and 0 partial blocks
X# dd wrote 2119 full blocks and 1 partial blocks
X#
X# CCI Sys V uses "blocks" instead of "records"
X# 0+0 blocks in
X# 0+0 blocks out
X#
X# End of sample dd outputs
X
X# version number parallels changes in alldisks script
X# version 4.03 Apr  5 1990 Bob Arnold created
X# version 4.03 Apr 24 1991
X# version 4.12 Jul 11 1991
X# version 4.14 Aug 09 1991
X# version 4.15 Aug 19 1991 put BDDSHOW output on /dev/tty, fix exitstat for remote hosts
X# version 4.17 Sep 20 1991 quieter attempt to read $t3 on remote host
X# version 4.29 Jul  1 1992 handle 3.2 AIX dd message format, remove tick hack
X# version 4.30 Jul 10 1992 bug fix for 3.2 AIX dd message format handling
SHAR_EOF
chmod 0755 src/backup/backup.dd ||
echo 'restore of src/backup/backup.dd failed'
Wc_c="`wc -c < 'src/backup/backup.dd'`"
test 3592 -eq "$Wc_c" ||
	echo 'src/backup/backup.dd: original size 3592, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= src/backup/backup.c ==============
if test -f 'src/backup/backup.c' -a X"$1" != X"-c"; then
	echo 'x - skipping src/backup/backup.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting src/backup/backup.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'src/backup/backup.c' &&
X#include <stdio.h>
X
X#define	SCRIPT_P	"/home/backup/backup.sh"
X
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X{
X	char str[BUFSIZ];
X	int status;
X
X	/* run as root */
X	setuid(0);
X
X	/* call backup.sh script with arguments */
X	sprintf(str,SCRIPT_P);
X	while ( --argc > 0 ) {
X		sprintf(str,"%s %s",str,*++argv);
X	}
X	sprintf(str,"%s \n",str);
X	system(str);
X}
SHAR_EOF
chmod 0644 src/backup/backup.c ||
echo 'restore of src/backup/backup.c failed'
Wc_c="`wc -c < 'src/backup/backup.c'`"
test 344 -eq "$Wc_c" ||
	echo 'src/backup/backup.c: original size 344, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= src/backup/gen.bkp.media ==============
if test -f 'src/backup/gen.bkp.media' -a X"$1" != X"-c"; then
	echo 'x - skipping src/backup/gen.bkp.media (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting src/backup/gen.bkp.media (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'src/backup/gen.bkp.media' &&
X:
X# gen.bkp.media - try to generate a bkp.media entry for $HOST
X
X. /etc/dist/sahead	# as always
X
Xecho "$pr: This script has not been heavily tested, but it hopefully"
Xecho "$pr: will help give you an idea of how to create an entry in"
Xecho "$pr: the 'bkp.media' file."
Xecho $ECHOPRE "$pr: Press <return> to contine: "$ECHOSUF
Xread remain_in_light
X
Xecho "$pr: What is the rewind device name for your tape drive on $HOST?"
Xecho $ECHOPRE "$pr: Enter the name: "$ECHOSUF
Xread ans
Xrewans=$ans
Xrewdev=`echo $ans | sed -e 's=^/dev/=='`
X
Xecho "$pr: What is the no-rewind device name for your tape drive on $HOST?"
Xecho $ECHOPRE "$pr: Enter the name: "$ECHOSUF
Xread ans
Xnorewdev=`echo $ans | sed -e 's=^/dev/=='`
X
Xecho "$pr: What kind of tape drive is $HOST:$rewans? "
Xecho "$pr: Your choices are:"
XTAPETYPES='1.	cart (QIC cart drive)
X2.	dat (4mm)
X3.	tape (9track)
X4.	tk50/70 (DEC proprietary)
X5.	video (8mm Exabyte)'
Xecho "$TAPETYPES"
Xecho $ECHOPRE "$pr: Enter the number of your choice [12345]: "$ECHOSUF
Xread ans
X
X# media alias
Xcase $ans in
X1)	malias=cart0  ;;
X2)	malias=dat0   ;;
X3)	malias=tape0  ;;
X4)	malias=tk0    ;;
X5)	malias=video0 ;;
Xesac
X
X# $h is "human name"
X# $c is capacity (in 5k blocks)
X# $d is dump arguments
Xcase $malias in
Xcart0)
X	echo "$pr: What type of cart drive is it:"
X	echo $ECHOPRE "$pr: [qic24, qic60, qic120, or qic150]? "$ECHOSUF
X	read type
X	type=`echo $type | tr a-z A-Z`
X;;
Xdat0)
X	echo $ECHOPRE "$pr: Is this DAT drive a 1Gig or 2Gig drive? [1 or 2] "$ECHOSUF
X	read size
X	type=DAT$size
X;;
Xvideo0)
X	echo $ECHOPRE "$pr: Is this exabyte a 2Gig or 5Gig video drive? [2 or 5] "$ECHOSUF
X	read size
X	type=E8$size
X;;
Xtape0)
X	echo $ECHOPRE "$pr: What is the density of this 9track drive? [6250 or 1600] "$ECHOSUF
X	read dens
X	type=$dens
X;;
Xtk0)
X	echo "$pr:  Oooog.  I'm sorry.  I don't have solid data on tk50/tk70's."
X	echo $ECHOPRE "$pr: Is this a TK50 or tk70 [tk50 or tk70] "$ECHOSUF
X	read type
X;;
Xesac
X
Xent=`grep "^\#$OS_S[ 	].*$type" bkp.media`
Xif test -z "$ent" ; then
X	echo "$pr: I'm sorry, I couldn't find an entry in the original"
X	echo "$pr: 'bkp.media' file for OS '$OS_S' and drive type '$type'."
Xelse
X	set `echo "$ent" \
X	| awk '
X		{printf "%s ", $4}
X		{for (n=7;n<=NF;n++) {printf "%s ", $n}}
X		END {printf "\n"}' \
X	| sed 's/ $//'`
X	cap=$1
X	shift
X	last="$*"
Xfi
X
Xecho ''
Xecho "$pr: Here is a guess at how each field should look, based on"
Xecho "$pr: the information you gave me.  The 'bkp.media' file has"
Xecho "$pr: seven fields; the seventh field should contain appropriate"
Xif test -n "$DUMP_P" ; then
X	echo "$pr: $DUMP_P arguments and an optional drive type."
Xelse
X	echo "$pr: cpio arguments and an optional drive type."
Xfi
Xecho "$pr: Each field should say something like:"
Xecho "
X1. hostname:				$HOST
X2. media alias:				$malias
X3. (unused):				xx
X4. capacity (number of 5k blocks):	$cap
X5. rewind device name:			$rewdev
X6. no-rewind device name:		$norewdev
X7. dump/cpio args & drive type:		$last
X
XThis creates a full 'bkp.media' entry looking like:
X$HOST	$malias	xx	$cap	$rewdev		$norewdev		$last
X
XThe above entry is based on the following example from the original
X'bkp.media' file for OS '$OS_S' and drive type '$type':
X$ent
X"
SHAR_EOF
chmod 0755 src/backup/gen.bkp.media ||
echo 'restore of src/backup/gen.bkp.media failed'
Wc_c="`wc -c < 'src/backup/gen.bkp.media'`"
test 3162 -eq "$Wc_c" ||
	echo 'src/backup/gen.bkp.media: original size 3162, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
rm -f _shar_seq_.tmp
echo You have unpacked the last part
exit 0
