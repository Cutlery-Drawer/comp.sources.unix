Newsgroups: comp.sources.unix
From: rca@ingres.com (Bob Arnold)
Subject: v28i065: saenv_alldisks - sysadmin env, disk management and backups, Part01/06
Message-id: <1.771948808.8446@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: rca@ingres.com (Bob Arnold)
Posting-Number: Volume 28, Issue 65
Archive-Name: saenv_alldisks/part01

This is the introductory letter for the Alpha Release of the
saenv/alldisks toolset.

The 'saenv' part is a research toolset to describe the system
administration environment on many different UNIXs.  It has been
described in "If You've Seen One UNIX, You've Seen Them All", Bob Arnold,
LISA V Conference Proceedings, USENIX, 1991 (a postscript version is
included).  This paper also discusses an 'update' toolset, so that is
also included in the release.

The 'alldisks' part is a full service backup/restore/verify toolset
which depends on the 'saenv' toolset.

Both tools have been heavily used for several years at ASK/Ingres
on a wide variety of UNIX platforms, including every major UNIX
vendor and many minor ones.

To begin using these tools, do the following:

	1) Save these articles in seperate files.
	2) Create a sysadmin account called say, 'sysad' on a machine where
	   you plan to keep this toolset.
	3) Remove the "Cut Here" line and everything above it from each
	   file you saved in step 1.
	4) Extract the shar archive, one file at a time, into sysad's home
	   directory (it will take a little over 500k).  Do this by first
	   cd'ing to sysad's home directory, and then issue an "sh file" for
	   each file you saved in step 3.
	5) Follow the instructions in ~sysad/README.

Enjoy!

		Bob

  __   _    _   Bob Arnold		Ingres, An ASK Group company
|/  \ / \  / \| 			1080 Marina Village Parkway
|    /    /   |				Alameda, CA, 94501
|    \__/ \__/| rca@ingres.com		510/748-2819


#!/bin/sh
# This is saenv_alld, a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 06/17/1994 22:37 UTC by rca@ingres.com
# Source directory /home/k9/rti/sys/sa/src/backup/rel
#
# existing files will NOT be overwritten unless -c is specified
#
# This is part 1 of a multipart archive                                    
# do not concatenate these parts, unpack them in order with /bin/sh        
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#   1501 -rw-r--r-- LETTER
#   9205 -rw-rw-r-- README
#   3298 -rw-rw-r-- README.alpha
#    691 -rwxr-xr-x bin/inst-saenv
#   1900 -rwxr-xr-x bin/inst-alldisks
#    743 -rwxr-xr-x bin/distfiles
#   1411 -rwxr-xr-x bin/shield
#   7299 -rwxr-xr-x bin/rrun
#   3222 -rwxr-xr-x bin/inst-toolset
#   1337 -rwxrwxr-x dist/bin/crontab.conv43
#    837 -rwxrwxr-x dist/bin/cut-paste
#    463 -rwxrwxr-x dist/bin/mkpath
#    930 -rwxrwxr-x dist/bin/realdir
#  14700 -rwxr-xr-x dist/bin/showsys
#   1603 -rwxr-xr-x dist/bin/sleep-number
#   5193 -rwxr-xr-x dist/bin/upd-dist
#   4197 -rw-r--r-- dist/sahead
#  33376 -r--r--r-- dist/saenv.setup
#    676 -rw-r--r-- dist/crontab.dist
#    159 -rw-r--r-- dist/dlist
#   1976 -rwxr-xr-x firstinst-saenv
#   2176 -rw-rw-r-- lib/rrun.hosts
#  98998 -rw-r--r-- saenv.paper.ps
#   5703 -rw-r--r-- src/backup/doc/alld.features
#   3637 -rw-r--r-- src/backup/doc/alld.q
#  22366 -rw-r--r-- src/backup/doc/gen.restore.q
#   4485 -rw-rw-r-- src/backup/doc/alld.prob
#  20677 -rw-rw-r-- src/backup/doc/alld.notes
#  19005 -rw-r--r-- src/backup/README
#   5952 -rw-r--r-- src/backup/.cshrc
#   1007 -rw-r--r-- src/backup/.getoper.csh
#    596 -rw-r--r-- src/backup/.getoper.sh
#    795 -rw-r--r-- src/backup/.profile
#   9092 -rwxr-xr-x src/backup/linst-alldisks
# 158638 -rwxr-xr-x src/backup/backup
#   7496 -rw-r--r-- src/backup/bkp.site
#     96 -rw-r--r-- src/backup/bkp.opers
#  10285 -rw-r--r-- src/backup/bkp.media
#   3592 -rwxr-xr-x src/backup/backup.dd
#    344 -rw-r--r-- src/backup/backup.c
#   3162 -rwxr-xr-x src/backup/gen.bkp.media
#
if test -r _shar_seq_.tmp; then
	echo 'Must unpack archives in sequence!'
	echo Please unpack part `cat _shar_seq_.tmp` next
	exit 1
fi
# ============= LETTER ==============
if test -f 'LETTER' -a X"$1" != X"-c"; then
	echo 'x - skipping LETTER (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting LETTER (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'LETTER' &&
XThis is the introductory letter for the Alpha Release of the
Xsaenv/alldisks toolset.
X
XThe 'saenv' part is a research toolset to describe the system
Xadministration environment on many different UNIXs.  It has been
Xdescribed in "If You've Seen One UNIX, You've Seen Them All", Bob Arnold,
XLISA V Conference Proceedings, USENIX, 1991 (a postscript version is
Xincluded).  This paper also discusses an 'update' toolset, so that is
Xalso included in the release.
X
XThe 'alldisks' part is a full service backup/restore/verify toolset
Xwhich depends on the 'saenv' toolset.
X
XBoth tools have been heavily used for several years at ASK/Ingres
Xon a wide variety of UNIX platforms, including every major UNIX
Xvendor and many minor ones.
X
XTo begin using these tools, do the following:
X
X	1) Save these articles in seperate files.
X	2) Create a sysadmin account called say, 'sysad' on a machine where
X	   you plan to keep this toolset.
X	3) Remove the "Cut Here" line and everything above it from each
X	   file you saved in step 1.
X	4) Extract the shar archive, one file at a time, into sysad's home
X	   directory (it will take a little over 500k).  Do this by first
X	   cd'ing to sysad's home directory, and then issue an "sh file" for
X	   each file you saved in step 3.
X	5) Follow the instructions in ~sysad/README.
X
XEnjoy!
X
X		Bob
X
X  __   _    _   Bob Arnold		Ingres, An ASK Group company
X|/  \ / \  / \| 			1080 Marina Village Parkway
X|    /    /   |				Alameda, CA, 94501
X|    \__/ \__/| rca@ingres.com		510/748-2819
SHAR_EOF
chmod 0644 LETTER ||
echo 'restore of LETTER failed'
Wc_c="`wc -c < 'LETTER'`"
test 1501 -eq "$Wc_c" ||
	echo 'LETTER: original size 1501, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= README ==============
if test -f 'README' -a X"$1" != X"-c"; then
	echo 'x - skipping README (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'README' &&
X
XWelcome to the 'saenv' system administration environment and
X'alldisks' backup toolsets.
X
XThe system administration environment toolset ('saenv' for short) is
Xbasically a research tool which looks at various interesting questions
Xabout your version(s) of UNIX, and writes out a report.  It is
Xdescribed much more fully in "If You've Seen One UNIX, You've Seen Them
XAll", Large Installation System Administration V Conference
XProceedings, USENIX, Berkeley, CA.  Also included are versions of
Xthe 'update' scripts which were discussed in that paper.  A postscript
Xversion of this paper is available in "saenv.paper.ps" in this directory.
X
XThe 'alldisks' toolset is a backup program which depends on the saenv
Xtoolset to describe its environment.  It has lots of handy dandy
Xfeatures (backup, file recovery, verification, etc.), and works on lots
Xof UNIXs.  Backups are typically done by saying something like:
X	backup full alldisks <media>
XSee the "src/backup/README" file for more info.
X
X				DISCLAIMER
X	The 'saenv' and 'alldisks' toolsets are not products of the
X	ASK Group.  While we have tried to make sure that both toolsets
X	work on many UNIX platforms, and that the included comments and
X	documents are accurate, the ASK Group and its agents take no
X	responsibility for any possible inaccuracies, or for any loss
X	or damage to equipment or data that may result from the use of
X	these toolsets or accompanying information.  These toolsets are
X	offered "as is" free of charge without any warranty of any type.
X
XYou may not want to install 'alldisks' everywhere, since you may not be
Xbacking up each and every workstation.  But you will probably want to
Xinstall the 'saenv' and 'update' tools, because the update tools will
Xkeep config files up to date, including any new versions of the 'saenv'
Xresearch scripts "saenv.setup" and "showsys".
X
XWARNING: For each update client, the procedure for updating distributed
Xfiles and the alldisks backup script requires rsh/rcp access for the
Xclient's root account to the $SAACCT account (called 'sysad', say) on
Xyour master sysadmin host which you installed in step 2 of the
Xaccompanying "LETTER" file.  Naturally, this could be a major a
Xsecurity concern at some sites.  If this is a concern for you, you will
Xwant to read the relevant literature on software distribution
Xmethodologies.  The distribution methodology used here is certainly not
Xas sophisticated as some of those described in the various Large
XInstallation Systems Administration Proceedings.  In case you don't
Xhave any other available means of restricting such access, you may also
Xwant to consider installing the "bin/shield" script as the login shell
Xfor the $SAACCT.  This script is a simple attempt to restrict the
Xallowed activities of anyone accessing the $SAACCT, and has been briefly
Xtested under SunOS.
X
X1) To begin using these toolsets, bootstrap the 'saenv' toolset on the
Xsysadmin master host by doing the following:
X	a) Choose a host to run it on first.  If you are brave and
X	bold, you can do this on a host that is heavily used by the
X	system administration community at your site.  Such a host
X	could be termed a "sysadmin master host".  This is probably
X	what you want to do, however if you are cautious, you may want
X	to do it on a relatively unimportant workstation.
X	b) Copy all the files in this archive to a your choice machine,
X	c) Edit the the following variables in the "dist/sahead" file:
X		SAHOST	your sysadmin master host
X		SAACCT	the sysad account you created in step 2 of the "LETTER"
X		SAHOME	the home directory for $SAACCT on $SAHOST
X		STASH	an email address to send backup reports to
X	You might want to edit other variables too, but you'll definitely want
X	to edit these.
X	d) Run "./firstinst-saenv" as root on the box.  This finishes the
X	'saenv' bootstrap procedure.
X
X2) To use the 'alldisks' toolset, there is some initial setup work to
Xbe done.  Follow the instructions in the "src/backup/README" file,
Xespecially the section which answers this question: "What do I need to
Xdo before using it?"
X
X3) Now you can finish installing these toolsets on your SAHOST, followed
Xby any other hosts you would like to use them on.  Note that by default this
Xprocedure will modify root's crontab file on each target host in order to
Xinstall an entry for automatic updates; otherwise it will leave your system
Xconfiguration files untouched.
X
XIf your SAHOST is called "bigfun", and the sysadmin account you are using
Xfor SAACCT is called "sysad", you would do the following as root on "bigfun":
X	cd ~sysad ; ./bin/inst-toolset bigfun
XThis will install the saenv, update, and alldisks toolsets on "bigfun".
XYou can get a usage message and see the default behaviours by issuing
Xthe "inst-toolset -h" command.
X
X4) If your SAHOST has root access to other hosts where you want to install
Xthese tools, you would do:
X	cd ~sysad ; ./bin/inst-toolset <host>
XIf you had more than one host to try it on, you could do
X	cd ~sysad ; ./bin/rrun inst-toolset \; host1 host2 host3 ...
X
X5) If your SAHOST does not have root access to an saenv/update/alldisks
Xclient, you would have to install these tools by a less automated
Xprocedure for each client:
X
X	On the SAHOST:
X	a) echo "client root" >> ~sysad/.rhosts
X	On the client:
X	b) Install the 'saenv' toolset by:
X		Make sure that /etc/dist and /etc/dist/bin exist
X		Copy these files to the client:
X			/etc/dist/sahead
X			/etc/dist/saenv.setup
X			/etc/dist/bin/realdir
X			/etc/dist/bin/showsys
X		As root on the client, run "sh /etc/dist/saenv.setup"
X	c) Install the 'update' toolset by (this will modify the client's
X	root crontab file, and leave other system config files untouched):
X		Copy these files to the client:
X			/etc/dist/bin/upd-dist
X			/etc/dist/bin/mkpath
X		Get all the files we are updating by doing this as root:
X			/etc/dist/bin/upd-dist now all nosaenv
X	d) Install the 'alldisks' toolset, if you want to, by:
X			/etc/dist/bin/upd-alldisks <default|/path/to/home> now
X
X6) Maintenance from here on out is fairly easy, at least on the many
Xversions of UNIX which these toolsets understand :-)  For example, if
Xyou attach a new tape drive to a machine which has 'alldisks'
Xinstalled, you just need to edit the "dist/bkp.media" file to add an
Xentry for the new drive, and then wait overnight for "upd-dist" on each
Xof the clients to retrieve it.  If you add a new host to the net, and
Xyou want to install the toolsets, follow the above procedures.  You can
Xdefine builtin host lists for "rrun" in the "lib/rrun" file.
X
XHere's a list of files that come with the 'saenv/alldisks' toolsets:
X
XLETTER			the cover letter email message
XREADME			this file you are reading
XREADME.alpha		README for this alpha release of these toolsets
Xbin/distfiles		called by upd-dist on remote host to get new file list
Xbin/inst-alldisks	run on master host to install alldisks on remote host
Xbin/inst-saenv		run on master host to install saenv tool on remote host
Xbin/inst-toolset	run on master host to install both tools on remote host
Xbin/rrun		runs one command against many hosts; "rrun -h" for help
Xbin/shield		sample restricted login shell
Xdata/saenv		directory to store /etc/saenv files from other hosts
Xdata/saenv		directory to store /etc/passwd files from other hosts
Xdist/bin/crontab.conv43* converts crontab files to 4.3BSD format
Xdist/bin/cut-paste*	appends master distributed to local mods
Xdist/bin/mkpath*	builds a full path to a directory
Xdist/bin/realdir*	shows real directory of file in question
Xdist/bin/showsys*	shows system description - used by saenv.setup
Xdist/bin/sleep-number*	used by upd-dist to stagger attack on master sysad host
Xdist/bin/upd-dist*	update distributed files
Xdist/crontab.dist*	distributed crontab for root account
Xdist/dlist		list of distributed files (marked with an asterisk *)
Xdist/saenv.setup*	this is the OS research tool
Xdist/sahead*		defines site-wide variables
Xdist/stamp		directory of time-stamps for upd-dist hosts
Xfirstinst-saenv		use this first to bootstrap the toolset on a master host
Xlib/rrun.hosts		sourced by bin/rrun; contains your handy host lists
Xsaenv.paper.ps		postscript version of "If You've Seen One UNIX, ..."
Xsrc/backup/.cshrc		for the backup account
Xsrc/backup/.getoper.csh		for the backup account
Xsrc/backup/.getoper.sh		for the backup account
Xsrc/backup/.profile		for the backup account
Xsrc/backup/README		the 'alldisks' "manual" - read it!
Xsrc/backup/backup		the 'alldisks' script itself
Xsrc/backup/backup.dd		"dd" wrapper
Xsrc/backup/backup.c		C wrapper for doing backups as setuid root
Xsrc/backup/bkp.media*		put all your tape drives in here
Xsrc/backup/bkp.opers*		list of operators at your site
Xsrc/backup/bkp.site*		alldisks config file for your site
Xsrc/backup/doc/alld.features	describes alldisks features
Xsrc/backup/doc/alld.notes	misc notes
Xsrc/backup/doc/alld.prob	known weaknesses and problems
Xsrc/backup/doc/alld.q		more Q&A about alldisks
Xsrc/backup/doc/gen.restore.q	general questions about BSD restore
Xsrc/backup/linst-alldisks	local inst-alldisks script
X
XGood Luck, and Enjoy!
X
X  __   _    _   Bob Arnold		Ingres, An ASK Group company
X|/  \ / \  / \| 			1080 Marina Village Parkway
X|    /    /   |				Alameda, CA, 94501
X|    \__/ \__/| rca@ingres.com		510/748-2819
SHAR_EOF
chmod 0664 README ||
echo 'restore of README failed'
Wc_c="`wc -c < 'README'`"
test 9205 -eq "$Wc_c" ||
	echo 'README: original size 9205, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= README.alpha ==============
if test -f 'README.alpha' -a X"$1" != X"-c"; then
	echo 'x - skipping README.alpha (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting README.alpha (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'README.alpha' &&
X	saenv_alldisks OS research / backup tools (Alpha Release)
X
XThis is an Alpha Release of the 'saenv' and 'alldisks' toolsets.
X
XThe reason it is an alpha level release is because it has seen very
Xlimited testing outside of the ASK/Ingres environment.  While the most
Ximportant scripts have been in heavy production usage for several years
Xinternally, others are brand new with this release.  Another group of
Xtools have been in use internally, but the released versions have been
Xchanged to support only the tools which were available for release.
X
XTools which are virtually unchanged include:
X	* the 'saenv' research tools 
X	* the 'alldisks' backup script and its supporting scripts and
X	  config files
X	* the "rrun" script which can be used to run commands against
X	  multiple hosts
X
XTools which are new or modified for this release:
X	* the "firstinst-saenv" script (because it only needs to be run
X	  once, and the 'saenv' toolset is already installed here :-)
X	* the "upd-dist" script
X	* the "shield" script which you may want to install as the login
X	  shell for your sysadmin account
X	* Most of the accompanying documentation
X
XYou may also want to see the "src/backups/doc/alld.probs" file, where
Xmany known problems with these toolsets are documented.
X
XIf you try these tools, I would appreciate feedback, good or bad.
X
XI won't be surprised at problems in several areas:
X	* Fully qualified domain names, NIS, NIS+, and DNS see limited
X	  use here (in part because of our commitment to our customers to
X	  support some very old platforms) so our concept of "hostname" and
X	  the best way of determining host info may be different than at
X	  other sites.  This also has implications for adding a "backup"
X	  account when installing the 'alldisks' backup script.
X	* Some topics which the "saenv.setup" and "showsys" research
X	  scripts attempt to answer are more important to us than others.
X	  Our priorities may be different than yours, so if you can think
X	  of ways to make the code more robust or handle additional
X	  environments that would be great.
X	* You may have topics which you would like to add to the 'seanv'
X	  toolset.
X	* Certainly, both the 'saenv' and 'alldisks' toolsets will need
X	  to be taught about environments they have never seen before.
X	  This is sometimes easy, and sometimes hard.
X	* Unlike the core research and backup scripts, which have been tried
X	  on many UNIXs, the initial installation process has only been
X	  tried under SunOS.  It is likely that any problems with the
X	  initial installation will be small, but I am interested in
X	  how it works on other common platforms, such as AIX, HP-UX,
X	  OSF, SGI, Solaris, Ultrix, etc.
X
XI would like to be able to fold additional environments and desired
Xenhancements into 'saenv' and 'alldisks'.  The usual caveats to such
Xwishes apply here: there is only so much time in the day, and it is
Xcertainly much more important to my employer that I support the
Xoperating systems we manage here.  However to the extent that I am
Xable, I hope to be able to make these toolsets even more broadly useful
Xthan they already are.
X
X		Bob
X
X  __   _    _   Bob Arnold		Ingres, An ASK Group company
X|/  \ / \  / \| 			1080 Marina Village Parkway
X|    /    /   |				Alameda, CA, 94501
X|    \__/ \__/| rca@ingres.com		510/748-2819
SHAR_EOF
chmod 0664 README.alpha ||
echo 'restore of README.alpha failed'
Wc_c="`wc -c < 'README.alpha'`"
test 3298 -eq "$Wc_c" ||
	echo 'README.alpha: original size 3298, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bin/inst-saenv ==============
if test ! -d 'bin'; then
    echo 'x - creating directory bin'
    mkdir 'bin'
fi
if test -f 'bin/inst-saenv' -a X"$1" != X"-c"; then
	echo 'x - skipping bin/inst-saenv (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bin/inst-saenv (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bin/inst-saenv' &&
X#!/bin/sh
X# inst-saenv
X# written by Bob Arnold
X#
X# use via "rrun -l inst-saenv [-verbose] $host"
X
X. /etc/dist/sahead
X
Xrsh="$RSH_C"
XUSAGE="usage: $0 [-verbose] host"
X
Xwhile test $# -gt 1 ; do
X	case $1 in
X	-v*)	verbose=-x ;;
X	esac
X	shift
Xdone
X
Xif test -n "$1" ; then
X	host=$1
Xelse
X	echo "$USAGE"
X	exit 1
Xfi
X
X# if any of this fails now, we need to quit.
Xset -e
X
X# do initial setup work
Xcd $DSRC
X$rsh $host -n "test -d $DTGT || mkdir $DTGT $DTGTBIN"
X# sahead depends on these:
Xrcp saenv.setup sahead $host:$DTGT
Xrcp $DSRCBIN/realdir $DSRCBIN/showsys $host:$DTGTBIN
Xstat=`$rsh $host -n sh $verbose $DTGT/saenv.setup 2>&1`
Xcase "$stat" in
X	*ELESSVAR*)	echo "$stat" ; exit 1 ;;
X	*)		exit 0 ;;
Xesac
SHAR_EOF
chmod 0755 bin/inst-saenv ||
echo 'restore of bin/inst-saenv failed'
Wc_c="`wc -c < 'bin/inst-saenv'`"
test 691 -eq "$Wc_c" ||
	echo 'bin/inst-saenv: original size 691, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bin/inst-alldisks ==============
if test -f 'bin/inst-alldisks' -a X"$1" != X"-c"; then
	echo 'x - skipping bin/inst-alldisks (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bin/inst-alldisks (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bin/inst-alldisks' &&
X:
X# inst-alldisks - install alldisks backup script on remote host
X# written by Bob Arnold
X#
X# basic strategy is for this script to copy "linst-alldisks" script
X# and necessary files to the remote host, and then run "linst-alldisks"`
X# on the remote machine.
X#
X# run against a single host by doing "inst-alldisks <host>"
X# run against multiple hosts via "rrun -l inst-alldisks alldiskshosts"
X
X. /etc/dist/sahead
X
Xbhdir=			# leave empty here; linst-alldisks knows default
Xtdir=/tmp/ialld		# working dir on remote host
Xrsh="$RSH_C"		# name of remote shell command
XUSAGE="usage: $pr [-saenv] [-verbose] host [homedir]"	# usage string
X
X# process command args
Xwhile test $# -gt 0 ; do
X	case $1 in
X	# does this look like a UNIX host name?
X	[a-z0-9][a-zA-Z0-9]*)
X		host=$1
X	;;
X	-s*)
X		saenv=true
X	;;
X	-v*)
X		verbose="-v"
X		set -x
X	;;
X	/*)
X		bhdir=$1
X	;;
X	*)
X		echo "$USAGE"
X		exit 1
X	;;
X	esac
X	shift
Xdone
X
X# make sure we actually have a host
Xif test -z "$host" ; then
X	echo "$USAGE"
X	exit 1
Xfi
X
X# so user knows what's happening
Xecho -n "$pr: "
X
X# initialize environment on remote host if necessary
Xx=`$rsh $host -n "sh -c 'test -f $SAENV && echo gotit'"`
Xif test "$saenv" = true -o -z "$x" ; then
X	echo "$pr: Installing saenv on $host"
X	inst-saenv $host
Xfi
X
X# supply tools
Xcd $SABKP
X$rsh $host -n "sh -c 'test -d $tdir || mkdir $tdir'"
Xgrep '^backup:' /etc/passwd | sed 1q > pwent.$SAHOST
Xrcp linst-alldisks .??* backup backup.c backup.dd bkp.media bkp.opers bkp.site pwent.$SAHOST $host:$tdir
X
X# do install
Xwhile : ; do
X	out=`$rsh $host -n $tdir/linst-alldisks $verbose $bhdir`
X	# report on install
X	echo "$out"
X	# if we succeeded
X	if echo "$out" | egrep 'backup$|backup.sh$' > /dev/null ; then
X		break
X	# elif saenv isn't installed
X	elif echo "$out" | egrep 'saenv' > /dev/null ; then
X		inst-saenv $host
X		continue
X	# else we don't know what went wrong so quit
X	else
X		echo "$pr: FAILED"
X		exit 1
X	fi
Xdone
SHAR_EOF
chmod 0755 bin/inst-alldisks ||
echo 'restore of bin/inst-alldisks failed'
Wc_c="`wc -c < 'bin/inst-alldisks'`"
test 1900 -eq "$Wc_c" ||
	echo 'bin/inst-alldisks: original size 1900, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bin/distfiles ==============
if test -f 'bin/distfiles' -a X"$1" != X"-c"; then
	echo 'x - skipping bin/distfiles (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bin/distfiles (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bin/distfiles' &&
X#!/bin/sh
X# distfiles - called by upd-dist on remote host to generate its
X# list of files to update.  Puts list on stdout.
X#
X# Written by Bob Arnold 03/03/94
X
Xtrap 'exit' 0 1 2 3 15
X
X# as usual
X. /etc/dist/sahead
X
Xdsrc=$DSRC				# distribution source directory
Xstampdir=$dsrc/stamp			# time stamp directory
XUSAGE="usage: distfiles host [all]"	# ditto
X
X# process command args
Xcase $# in
X1|2)	host=$1 ;;
X*)	echo "$USAGE" 1>&2 ; exit 1 ;;
Xesac
Xtstamp=$stampdir/$host
Xcase "$2" in
X'')	newer="-newer $tstamp" ;;
Xall)	newer="" ;;
X*)	echo "$USAGE" 1>&2 ; exit 1 ;;
Xesac
X
X# produce list for $host
Xcd $dsrc || exit 1
Xif test -f $tstamp ; then
X	find `egrep -v '^\#' dlist` $newer -type f -print
Xelse
X	find `egrep -v '^\#' dlist`        -type f -print
Xfi
SHAR_EOF
chmod 0755 bin/distfiles ||
echo 'restore of bin/distfiles failed'
Wc_c="`wc -c < 'bin/distfiles'`"
test 743 -eq "$Wc_c" ||
	echo 'bin/distfiles: original size 743, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bin/shield ==============
if test -f 'bin/shield' -a X"$1" != X"-c"; then
	echo 'x - skipping bin/shield (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bin/shield (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bin/shield' &&
X#!/bin/sh
X# $SABIN/shield - SHell for Incoming ELective Determination :-)
X# If you can think of a better acronym, more power to you :-)
X#
X#	Bob Arnold
X#
X## how shield works:
X# Simple "date" commands look like this:
X# "sh -c date"
X#
X# We even control rcp's since we know what they say:
X# rcp copy_to	"sh -c rcp [-d|-r] -t <file>"
X# rcp copy_from	"sh -c rcp [-d|-r] -f <file>"
X# if to/from target/from is a directory we get an optional -d, and
X# if to/from target/from is recursive,  we get an optional -r
X#
X# This isn't a substitute for a real TCP/IP wrapper, but it's something.
X
Xtrap 'exit 1' 0 1 2 3 15
X
X. /etc/dist/sahead
X
Xlog=$SAHOME/log/shield.$USER	# $USER is not portable
Xvalid=false			# assume invalid unless proven otherwise
X
X# drop the "-c"
Xshift
X
X# We allow "sh -c rcp [-d] -f $dsrc/...." for upd-dist
X# In this case statement, be careful of quoting:
X#	a) do *not* quote "?" or "*"
X#	b) *do* quote spaces (probably with backslashes)
Xcase "$*" in
Xdate)					valid=true ;;
Xrcp\ -f\ $dsrc/?*)			valid=true ;;
Xrcp\ -d\ -f\ $dsrc/?*)			valid=true ;;
Xrcp\ -f\ /usr/rti/sys/sa/dist/?*)	valid=true ;;
Xtouch\ $SAHOME/dist/stamp/?*)		valid=true ;;
X$SABIN/distfiles\ ?*)			valid=true ;;
Xesac
X
X# if invalid, tell user, log it, and quit
Xif test $valid = false ; then
X	echo "Permission denied." 1>&2		# rshd version of this message
X	echo "`date`	denied	'$@'" >> $log
X	exit 1
Xfi
X
X# we pass muster so exec it
Xexec $@
SHAR_EOF
chmod 0755 bin/shield ||
echo 'restore of bin/shield failed'
Wc_c="`wc -c < 'bin/shield'`"
test 1411 -eq "$Wc_c" ||
	echo 'bin/shield: original size 1411, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bin/rrun ==============
if test -f 'bin/rrun' -a X"$1" != X"-c"; then
	echo 'x - skipping bin/rrun (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bin/rrun (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bin/rrun' &&
X#!/bin/sh
X# $SABIN/rrun - remote program runner
X#
X#	Bob Arnold
X#
X# version 1.00 Dec  4 1989
X# version 2.00 Dec  6 1990 - new options, sources /etc/saenv
X# version 3.00 Jan 15 1992 - finally get the design right by adding many
X#			     options and improving interface
X# version 4.00 Feb 10 1992 - give output as we go along, put hostlist in
X#			     $SALIB/$pr.hosts, no more stats, misc efficiencies
X
X## initial stuff
X. /etc/dist/sahead
X
X# if interrupted trap - cleanup and die
Xtrap "echo $pr: Interrupted.  Quitting. ; /bin/rm -f \$rmlist ; exit 1"  2 3 15
X
Xumask 007
X
X# set variables, including defaults
Xblock=false		# assume we don't block, i.e. we use rsh '-n' option
Xckping=true		# assume check of ping and rsh to each host
Xckrsh=true		# assume check of rsh to each host
Xheader=true		# assume we're printing the header
Xkeep=false		# assume we don't keep the file in /tmp (copy mode)
Xshowstat=true		# assume we're showing hostname, ping and rsh status
Xshowlist=false		# assume we're doing more than just showing the hostlist
Xhostlist=		# list of hosts to run $prog on - get from command args
Xtmp=/tmp/$pr.tmp	# scratch output file
Xrmlist="$tmp"		# rmlist is removal list for cleanup
Xlhost=$HOST		# local hostname
Xrsh=$RSH_C		# remote shell
Xepre="$ECHOPRE"		# echo prefix
Xesuf="$ECHOSUF"		# echo suffix
XU_LOCPR="$SAHOST:prog [-progopts] \$host"
XU_RCPPR='rcp prog $host:/tmp ; rsh $host /tmp/prog [-progopts]'
XU_RSHPR='rsh $host prog [-progopts]'
XUSAGE="usage: $pr -h
Xusage: $pr -s hostlist
Xusage: $pr -c|-l|-r [-HPRS] prog [-progopts] hostlist
X-h help mode:      print this usage message and exit
X-c copy mode:      $U_RCPPR
X-l local mode:     $U_LOCPR
X-r rsh mode:       $U_RSHPR
X-s showhosts mode: show hosts in 'hostlist' and exit
X-B                 do not use 'rsh -n' "noblock" option (i.e. we will block)
X-H                 do not print header info
X-K		   do not remove file; i.e. keep file in /tmp; -c copy mode only
X-P		   do not check ping or rsh to each host
X-R		   do not check rsh to each host (assumed for '-r' rsh mode)
X-S		   do not show hostname, rsh status, or ping status
X-progopts must begin with a minus '-' sign or be terminated by '--' or '\;'
X'hostlist' may be a builtin list and/or supplied by the user
Xin local mode, the word 'HOST' may be used to show desired placement of \$host
Xexample: rrun -l rsh HOST cat /etc/motd \; sun4hosts
Xexample: rrun -l rcp ~$SAACCT/dist/bkp.media HOST:/tmp \; sun4hosts"
X
X## verify command args (report errors)
X# make sure we have enough arguments
Xtest $# -lt 2 && {
X	echo "$USAGE"
X	exit 1
X}
X
X## process command args
X# rrun options first
Xwhile : ; do
X	case $1 in
X	-c)	mode=c ; rcppr=true ;;
X	-h)	mode=h ; echo "$USAGE" ; exit 0 ;;
X	-l)	mode=l ; locpr=true ;;
X	-r)	mode=r ; rshpr=true ; ckrsh=false ;;
X	-s)	mode=s ; showlist=true ;;
X	-B)	block=true ;;
X	-H)	header=false ;;
X	-K)	keep=true ;;
X	-P)	ckping=false ; ckrsh=false ;;
X	-R)	ckrsh=false ;;
X	-S)	showstat=false ;;
X	-*)	echo "$USAGE" ; exit 1 ;;
X	*)	break ;;
X	esac
X	shift
Xdone
X
Xtest -z "$mode" && {
X	echo "$pr: mode (-c|-h|-l|-r|-s) must be specified"
X	echo "$USAGE"
X	exit 1
X}
X
X# get prog name and prog options
Xtest "$showlist" != true && {
X	prog="$1"
X	shift
X	test "$rcppr" = true -a ! -x "$prog" && {
X		echo "$pr: can't find '$prog'."
X		exit 1
X	}
X	# the X is needed in case $1 is now "-n", which echo will treat
X	# as "echo -n ...", which in turn seems to act strangely in
X	# this construct
X	echo X"$*" | egrep ';|--' > /dev/null && {
X		while : ; do
X			case $1 in
X			--|\;)	shift ; break ;;
X			*)	progopts="$progopts $1" ; shift ;;
X			esac
X		done
X	} || {
X		while : ; do
X			case $1 in
X			-*)	progopts="$progopts $1" ;;
X			*)	break ;;
X			esac
X			shift
X		done
X	}
X}
X# again, the "X" business is needed in case the first progopt is "-n"
Xprogopts=`echo X$progopts | sed -e 's/X//'`
X
X# get input hostlist
Xinhost="$*"
X
X## verify $hostlist, but first we have to set up internal known host lists
X## set up host lists
X
X. $SALIB/$pr.hosts
X
X## build hostlist from $inhosts
Xfor i in $inhost ; do
X	case $i in
X	*hosts)
X		# see if it's a known list
X		egrep "^$i=" $SALIB/$pr.hosts > /dev/null && {
X			eval hostlist="\"$hostlist \$$i\""
X		} || {
X			echo "$pr: '$i' is not a known hostlist"
X			badhostlist=true
X		}
X	;;
X	*)
X		hostlist="$hostlist $i"
X	;;
X	esac
Xdone
Xtest "$badhostlist" = true && {
X	echo "$pr: see '$SALIB/$pr.hosts' for valid internal hostlists"
X	exit 1
X}
X
X# show resulting hostlist
Xif test $header = true ; then
X	echo "$pr: hostlist="
X	echo $hostlist | fmt
Xfi
X
X# exit if we're done
Xtest "$showlist" = true && {
X	exit 0
X}
X
X# set rsh noblock option
Xtest "$block" = true && {
X	noblock=''
X} || {
X	noblock='-n'
X}
X
X# do that rrun thang ...
Xprogbn=`basename $prog`
Xcase "$progopts" in
X*HOST*)	C_LOCPR="$SAHOST:$progbn `echo $progopts | sed s/HOST/\\\$host/g`" ;;
X*)	C_LOCPR="$SAHOST:$progbn $progopts \$host"
Xesac
Xif test $header = true ; then
X	C_RCPPR="rcp $progbn \$host:/tmp ; rsh \$host /tmp/$progbn $progopts"
X	C_RSHPR="rsh \$host $progbn $progopts"
X	case $mode in
X	c)	head1="mode=copy"  ; gencmd="$C_RCPPR" ;;
X	l)	head1="mode=local" ; gencmd="$C_LOCPR" ;;
X	r)	head1="mode=rsh"   ; gencmd="$C_RSHPR" ;;
X	esac
X	head2="$gencmd"
X	head3="============================================================="
X	if test $showstat = true ; then
X		echo  "      ping  rsh $head1"
X		echo  "\$host stat stat $head2"
X		echo  "=============== $head3"
X	else
X		echo  "$head1"
X		echo  "$head2"
X		echo  "$head3"
X	fi
Xfi
Xfor host in $hostlist ; do
X	# initialize variables every time
X	p=''		# ping status
X	r=''		# rsh status
X	pingrsh=''	# ping/rsh stdout and stderr
X	progstat=''	# program status
X
X	# if we're showing status
X	if test $showstat = true ; then
X		echo $host | awk '{printf("%-8s",$0)}'
X	fi
X	# show ping status
X	test "$ckping" != true && {
X		p=NA
X	} || {
X		pingrsh=`ping $host 5`
X		case "$pingrsh" in
X		*"$host is alive"*|*"$host.ingres.com is alive"*)
X			p=0
X		;;
X		*)
X			p=1
X		;;
X		esac
X	}
X	# if we're showing status
X	test $showstat = true && {
X		echo $p | awk '{printf("%2s",$0)}'
X	}
X	# show rsh status
X	test "$ckrsh" != true -o "$p" != 0 && {
X		r=NA
X	} || {
X		pingrsh="`$rsh $host $noblock date 2>&1`"
X		# see if we got a valid date
X		echo "$pingrsh" | grep ' [0-2][0-9]:[0-5][0-9]:[0-5][0-9] ' > /dev/null && {
X			r=0
X		} || {
X			r=1
X		}
X	}
X	# if we're showing status
X	test $showstat = true && {
X		echo $r | awk '{printf("%5s ",$0)}'
X	}
X	# show problems if any, else run prog
X	test "$p" = 1 -o "$r" = 1 && {
X		# we're not showing the host, but we should if there's a problem
X		test $showstat = false && {
X			echo $host | awk '{printf("%-8s",$0)}'
X		}
X		echo "$pingrsh"
X	} || {
X		case $mode in
X		# copy mode
X		c)
X			rcp $prog $host:/tmp/$progbn
X			$rsh $host $noblock /tmp/$progbn $progopts 2>&1 | tee $tmp
X			progstat=$?
X			if test $keep = false ; then
X				rsh $host $noblock rm -f /tmp/$progbn
X			fi
X		;;
X		# local mode
X		l)
X			case "$progopts" in
X			*HOST*)	progopthost="`echo $progopts | sed -e s/HOST/$host/g`" ;;
X			*)	progopthost="$progopts $host" ;;
X			esac
X			$prog $progopthost 2>&1 | tee $tmp
X			progstat=$?
X		;;
X		# rsh mode
X		r)
X			rsh $host $noblock $prog $progopts 2>&1 | tee $tmp
X			progstat=$?
X		;;
X		esac
X		case $progstat in
X		[1-9]*)	echo "$pr: WARNING - $prog exit status $progstat" ;;
X		*)	test ! -s $tmp && echo '' ;;	# newline if no output
X		esac
X	}
Xdone
X
X# cleanup
Xrm -f $rmlist
SHAR_EOF
chmod 0755 bin/rrun ||
echo 'restore of bin/rrun failed'
Wc_c="`wc -c < 'bin/rrun'`"
test 7299 -eq "$Wc_c" ||
	echo 'bin/rrun: original size 7299, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bin/inst-toolset ==============
if test -f 'bin/inst-toolset' -a X"$1" != X"-c"; then
	echo 'x - skipping bin/inst-toolset (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bin/inst-toolset (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bin/inst-toolset' &&
X#!/bin/sh
X# inst-toolset - install ASK/Ingres Data Center toolsets on a host
X#
X# Bob Arnold
X
X## get it or quit
X. /etc/dist/sahead
X
X## mostly for $bhdir
X. $SABKP/bkp.site
X
Xrsh=$RSH_C			# remote shell command
Xbackup=ask			# ask if we install alldisks backup script
Xsaenv=true			# assume we install saenv on the host
Xupdate=true			# assume we run upd-dist on the host
Xbhdir=${bhdir-/home/backup}	# default home directory for 'backup' account
X
Xtrap ":                                ; rm -f $rmlist ; exit  " 0
Xtrap "echo $pr: Interrupted, quitting. ; rm -f $rmlist ; exit 1" 1 2 3 15
X
X# usage string
XUSAGE="usage:
X$pr -h
X$pr [-b|-B] [-s|-S] [-u|-U] [/path/to/backup/homedir] host
X-h		print this help message
X[-b|-B]		do/don't install backup (alldisks) script	(default ask)
X[-s|-S]		do/don't install saenv				(default do)
X[-u|-U]		do/don't run     upd-dist			(default do)"
X
X# get args
Xwhile test $# -gt 0 ; do
X	case $1 in
X	/*)	bhomearg=$1 ;;
X	[a-z]*)	host=$1 ;;
X	-b*)	backup=true ;;
X	-B*)	backup=false ;;
X	-s*)	saenv=true ;;
X	-S*)	saenv=false ;;
X	-u*)	update=true ;;
X	-U*)	update=false ;;
X	-h*)	echo "$USAGE" ; exit 0 ;;
X	*)	echo "$USAGE:" ; exit 1 ;;
X	esac
X	shift
Xdone
X
X# make sure we have a hostname
Xif test -z "$host" ; then
X	echo "$pr: No host specified."
X	echo "$USAGE"
X	exit 1
Xfi
X
X# set up it's sysad environment
Xcase $saenv in
Xfalse)
X	echo "$pr: Skipping 'inst-saenv $host'"
X;;
Xtrue)
X	echo "$pr: Running 'inst-saenv $host'"
X	inst-saenv $host
X	if test $? -ne 0 ; then
X		echo "$pr: There was a problem running inst-saenv on $host; quitting."
X		exit 1
X	fi
X	## get new saenv file
X	rcp $host:/etc/saenv $SADATA/saenv/$host
X;;
Xesac
X
X## prepare for distribution of standard files
Xegrep "^$host[ 	]+root[ 	]*$" $SAHOME/.rhosts > /dev/null 2>&1
Xif test $? -ne 0 ; then
X	echo "$pr: Adding '$host root' to '$SAHOME/.rhosts' for"
X	echo "$pr: the 'update' tools."
X	echo "$host root" >> $SAHOME/.rhosts
Xfi
X
X## do distribution of standard files
X# we use nosaenv because inst-saenv has already been run
Xif test $update != true ; then
X	echo "$pr: Skipping upd-dist of $host"
Xelse
X	echo "$pr: Running upd-dist of $host"
X	rcp $DSRCBIN/mkpath $DSRCBIN/upd-dist $host:$DTGTBIN
X	$rsh $host -n $DTGTBIN/upd-dist now all nosaenv
Xfi
X
X## install alldisks backup script if desired
Xcase $backup in
Xask)
X	echo $ECHOPRE "$pr: Do you wish to install the 'alldisks' backup script? [y(n)] "$ECHOSUF
X	read ans
X	case "$ans" in
X	[yY]*)	backup=true ;;
X	*)	backup=false ;;
X	esac
X;;
Xesac
Xcase $backup in
Xtrue)
X	echo "$pr: Installing 'alldisks' backup script"
X	rcp $host:/etc/passwd $SADATA/passwd/$host
X	hostbhdir=`grep '^backup:' $SADATA/passwd/$host | awk -F: '{print $6}'`
X	if test -n "$hostbhdir" ; then
X		bhdir=$hostbhdir
X	elif test -n "$bhomearg" ; then
X		bhdir=$bhomearg
X	else
X		while : ; do
X			echo "$pr: Enter backup's home directory on $host"
X			echo $ECHOPRE "$pr: (default $bhdir): "$ECHOSUF
X			read ans
X			case $ans in
X			'')	bhdir=$bhdir	;;	# accept default
X			/*)	bhdir=$ans	;;	# use answer
X			*)	continue	;;	# try again
X			esac
X			break
X		done
X	fi
X	inst-alldisks $host $bhdir
X	echo "$pr: You may want to add $host to $SALIB/rrun.hosts"
X;;
Xfalse)
X	echo "$pr: Skipping install of 'alldisks' backup script"
X;;
Xesac
X
Xecho "$pr: Host $host done."
SHAR_EOF
chmod 0755 bin/inst-toolset ||
echo 'restore of bin/inst-toolset failed'
Wc_c="`wc -c < 'bin/inst-toolset'`"
test 3222 -eq "$Wc_c" ||
	echo 'bin/inst-toolset: original size 3222, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= dist/bin/crontab.conv43 ==============
if test ! -d 'dist'; then
    echo 'x - creating directory dist'
    mkdir 'dist'
fi
if test ! -d 'dist/bin'; then
    echo 'x - creating directory dist/bin'
    mkdir 'dist/bin'
fi
if test -f 'dist/bin/crontab.conv43' -a X"$1" != X"-c"; then
	echo 'x - skipping dist/bin/crontab.conv43 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting dist/bin/crontab.conv43 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dist/bin/crontab.conv43' &&
X:
X# usage: crontab.conv43 infile
X#
X# Sep 27 1988 - rca
X# crontab.conv43 converts normal crontab files to 4.3BSD format.
X# It reads from $infile and writes to standard output
X#
X# If the normal crontab file looks like this:
X##This is a comment line (note no changes)
X#0 * * * *		/bin/date > /dev/console
X#30 1 1 * *	su news -c /usr/lib/news/mvlogs > /usr/spool/news/mvlogd 2>&1
X#
X# then the converted-to-4.3 version of the file looks like:
X##This is a comment line (note no changes)
X#0 * * * *	root	/bin/date > /dev/console 
X#30 1 1 * *	news	/usr/lib/news/mvlogs > /usr/spool/news/mvlogd 2>&1 
X
XUSAGE="usage: crontab.conv43 infile"
X
X# check syntax
Xif test $# -ne 1 ; then
X	echo "$USAGE"
X	exit 1;
Xfi
X
Xinfile=$1
X# do conversion
Xawk '
X	{
X		if ( $1 ~ /^#/ ) {
X			print
X		} else {
X			## two possible 'su' entries, one non-su entry
X			#	* * * * *	su - ctdba -c some command
X			#	* * * * *	su   ctdba -c some command
X			#	* * * * *	              some command
X			## printf time fields, user, command, and newline
X			printf "%s %s %s %s %s	", $1, $2, $3, $4, $5
X			if ( $6 == "su" ) {
X				if ( $7 == "-" ) {
X					cmdfield = 10
X				} else {
X					cmdfield = 9
X				}
X				printf "%s	", $(cmdfield-2)
X			} else {
X				cmdfield = 6
X				printf "root	"
X			}
X			for ( i = cmdfield ; i <= NF ; i++ ) {
X				printf "%s ", $i
X			}
X			printf "\n"
X		}
X	}' $infile
SHAR_EOF
chmod 0775 dist/bin/crontab.conv43 ||
echo 'restore of dist/bin/crontab.conv43 failed'
Wc_c="`wc -c < 'dist/bin/crontab.conv43'`"
test 1337 -eq "$Wc_c" ||
	echo 'dist/bin/crontab.conv43: original size 1337, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= dist/bin/cut-paste ==============
if test -f 'dist/bin/cut-paste' -a X"$1" != X"-c"; then
	echo 'x - skipping dist/bin/cut-paste (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting dist/bin/cut-paste (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dist/bin/cut-paste' &&
X:
X# cut-paste - allows you to cut and paste a file which
X# has a line matching this regular expression: "/^##<><><><><>/"
X# written -      Diane Alter   10/07/87
X# code cleanup - Bob Arnold    06/19/91
X# code cleanup - Bob Arnold    02/27/94
X
X. /etc/dist/sahead
X
Xtmpfile=/tmp/cut-paste$$
XUSAGE="$pr: addfile outfile"
X
Xif test $# -ne 2 ; then
X	echo "$USAGE"
X	exit 1
Xfi
Xaddfile=$1
Xoutfile=$2
Xif test ! -s $addfile ; then
X	echo "$pr: $addfile not found. Bye."
X	exit 1
Xfi
X
X# if $outfile doesn't exist, install $addfile as $outfile, give friendly warning
Xif test ! -f $outfile ; then
X	echo "$pr: $outfile not found, installing $addfile as $outfile"
X	cp $addfile $outfile
X# else preserve local mods and then append $addfile to $outfile
Xelse
X	sed -e '/^##<><><><><>/,$d' $outfile > $tmpfile
X	cat $tmpfile $addfile > $outfile
Xfi
X
Xrm -f $tmpfile
SHAR_EOF
chmod 0775 dist/bin/cut-paste ||
echo 'restore of dist/bin/cut-paste failed'
Wc_c="`wc -c < 'dist/bin/cut-paste'`"
test 837 -eq "$Wc_c" ||
	echo 'dist/bin/cut-paste: original size 837, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= dist/bin/mkpath ==============
if test -f 'dist/bin/mkpath' -a X"$1" != X"-c"; then
	echo 'x - skipping dist/bin/mkpath (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting dist/bin/mkpath (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dist/bin/mkpath' &&
X:
X# mkpath - make a path
X#
X# build a complete directory path, even if intermediary directories don't exist.
X#
X# history:
X# Jan 15 1990 - rca - first version
X# Dec  5 1990 - rca - made it silent and added usage test
X
Xif test $# -ne 1 ; then
X	echo "usage: $0 dirname"
X	exit 1
Xfi
X
Xumask 002
Xif test -r $1 ; then
X	exit
Xelse
X	mkdir $1 > /dev/null 2>&1
X	if test $? -ne 0 ; then
X		parent=`echo $1 | sed 's,/[^/][^/]*$,,'`
X		$0 $parent
X		mkdir $1 > /dev/null 2>&1
X	fi
Xfi
SHAR_EOF
chmod 0775 dist/bin/mkpath ||
echo 'restore of dist/bin/mkpath failed'
Wc_c="`wc -c < 'dist/bin/mkpath'`"
test 463 -eq "$Wc_c" ||
	echo 'dist/bin/mkpath: original size 463, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= dist/bin/realdir ==============
if test -f 'dist/bin/realdir' -a X"$1" != X"-c"; then
	echo 'x - skipping dist/bin/realdir (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting dist/bin/realdir (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dist/bin/realdir' &&
X:
X# realdir - report directory where the requested file really lives - rca
X# the user must supply the guesses for the directory
Xif test $# -lt 2 ; then
X	echo usage: realdir file dir [ dir ... ]
X	exit 1
Xfi
Xfile=$1
Xshift
Xfor dir in $* ; do
X	test -n "`find $dir/$file -type f -print 2>/dev/null`" && echo $dir && break
Xdone
X
Xexit
X
X# We use "find $dir/$file -type f -print" because "test -f <symlink>"
X# exits with status 0 if the file <symlink> points at exists.
X# Luckily, "find" syntax does what we want on virtually all systems.
X#
X# There are a few machines where symbolic links act strangely with
X# and "find <findlist> -type f".  Symbolic links are supposed to be their
X# own file type, as far as find(1) is concerned.  So:
X#	find <symlink> -type f -print
X# should print nothing.
X#
X# There's at least one UNIX out there where "find <symlink> -type f -print"
X# produces incorrect results - I just can't remember which one! - rca
SHAR_EOF
chmod 0775 dist/bin/realdir ||
echo 'restore of dist/bin/realdir failed'
Wc_c="`wc -c < 'dist/bin/realdir'`"
test 930 -eq "$Wc_c" ||
	echo 'dist/bin/realdir: original size 930, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= dist/bin/showsys ==============
if test -f 'dist/bin/showsys' -a X"$1" != X"-c"; then
	echo 'x - skipping dist/bin/showsys (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting dist/bin/showsys (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dist/bin/showsys' &&
X:
X# showsys - show system information
X#
X# Written by Bob Arnold
X
X# "showsys" is usually used by saenv.setup, before any "sa" family tools
X# like sahead and saenv are in place.  In fact, saenv.setup calls this
X# tool to help build "saenv".  So this script must be self-sufficient,
X# and live without saenv, sahead, etc.
X
X# Why does this tool exist?
X#
X# Although we like to do as much dynamic testing as possible in our toolset,
X# some questions are either impossible or very difficult to answer using
X# automated tests.  For example:
X#
X#	a) Bull's B.O.S. version of dd reports a failure exit status if it is
X#	asked to use an input blocksize greater than 60k for a QIC150 cart;
X#	no other vendor we know of has this weird behavior.
X#	b) Many vendors have similar sendmail.cf formats, but some
X#	e.g. HP, Bull, AIX, SGI, SCO, and others have their own little
X#	bugs and/or peculiarities.
X#
X# One way to handle this problem is to have tools make decisions based
X# on things like vendor, OS, and OS level rather than on some particular
X# OS feature or behavior that we have actually tested for.  This script
X# researches these items, as well as other info that may be useful or
X# just handy to know.
X#
X# Output is available in two forms.  The default is suitable for putting
X# into saenv.  If used without any command line options, you get:
X# VENDOR_S=Sun    # vendor / manufacturer
X# OS_S=SunOS              # operating system
X# OSLEVEL_S=4.1.2 # release level of OS
X# KERNEL_P=/vmunix        # name of kernel
X# ARCH_S=sun4             # cpu architecture / chip
X# MODEL_S=SUN_4/330       # model of this machine
X# ID_S=23001313           # hostid / serial number of machine
X#
X# The "oneline" option says to put out the all the answers on one line
X# (without descriptive variable names).  The "oneline" option guarantees
X# each field to have exactly one word and to be non-blank, so the output
X# can be easily parsed.  Unknown fields are shown as "-------".
X#
X# The "showhost" option says to show the hostname.
X#
X# So, for example, on a Sun called bigfun, "showsys oneline showhost" would
X# produce something like this:
X#
X# bigfun    Sun       SunOS       4.1.2          /vmunix sun4        SUN_4/330     23001313
X# The formatting with the "oneline" option helps the answers line up neatly if
X# run on many hosts via
X#	rrun -c ~sa/dist/bin/showsys oneline showhost <hostlist>
X
X## OK, enough background info.  Let's get to work.
X
X# set defaults
Xpr=`basename $0`	# get program name
Xoneline=false		# assume we're printing variable names for
Xshowhost=false		# assume we don't show the hostname
Xcr=/tmp/os.crash	# script we have to create to use "crash"
Xrmlist="$cr"		# list of files to clean up
XUSAGE="usage: $pr [oneline] [showhost]"
X
X# process command args
Xfor arg in $* ; do
X	case $arg in
X	oneline)	oneline=true ;;
X	showhost)	showhost=true ;;
X	*)		echo "$USAGE" ; exit 1 ;;
X	esac
Xdone
X
X# if we have to report our hostname then use the following code chunk
X# from "saenv.setup".
Xif test "$showhost" = true ; then
X	## This code chunk is stolen from saenv.setup; we may need $host
X	# host - name of our local host
X	if (hostname) > /dev/null 2>&1 ; then
X		host="`hostname`"       # normal BSD
X	else
X		host="`uname -n`"       # Sys V
X	fi
X	# strip domain qualifier
X	# this is probably not the right answer at some sites
X	host=`echo "$host" | sed -e 's/\..*//'`	
Xfi
X
X# get easier stuff - uname -a, arch -k, sed 1q /etc/motd, path to kernel,
X# "file $kernel", "strings $kernel", and "strings /bin/login" info
X#
X# kernel names and where they came from, listed alphabetically
X# /dgux			DG/UX
X# /dynix		DYNIX (but not DYNIX/ptx)
X# /hp-ux		Hewlett-Packard
X# /kernel/unix		Solaris
X# /stand/unix		SVR4 generic
X# /syst			Arete
X# /sysV68		Motorola
X# /unix			SVR[0123] and derivitives
X# /usr/lib/boot/unix	IBM AIX, Bull BOSX
X# /vmunix		BSD and derivitives
X# /xenix		Xenix
X# kernel_list is in most probable order around here
Xkernel_list="/vmunix /unix /hp-ux /dynix /dgux /syst /sysV68 /xenix /stand/unix /kernel/unix /usr/lib/boot/unix"
Xfor f in $kernel_list ; do
X	# if the kernel exists and isn't a symlink
X	if test -f $f -a -z "`find $f -type l -print 2> /dev/null`" ; then
X		kernel=$f && break
X	fi
Xdone
Xif test -n "$kernel" ; then
X	skernel="`(strings $kernel    | egrep 'Unisys U 6000|NCR UNIX'      | sed 1q) 2> /dev/null`"
X	fkernel="`(file    $kernel                                          | sed 1q) 2> /dev/null`"
Xfi
Xlogin="`  (strings /bin/login | egrep 'Stardent|IRIX|Convex|Encore|NonStop-UX' | sed 1q) 2> /dev/null`"
X# the uname "att" trick is needed for dual universe machines
Xuname_a="`( uname -a ) 2> /dev/null || (att uname -a) 2> /dev/null`"
Xmotd1="`sed 1q /etc/motd 2> /dev/null`"
Xarch="`  (arch ) 2> /dev/null`"
Xarch_k="`(arch -k) 2> /dev/null`"
X
X#XENIX
X#uname -a says:
X#sysname=XENIX
X#nodename=(empty)
X#release=2.3.1
X#version=SysV
X#machine=i80386
X#origin=3
X#oem=3000
X#serial#=3615
X# that's right folks one per line - ugly indeed
Xif test "$kernel" = /xenix ; then
X	uname_a=`echo "$uname_a" | sed -e 's/^.*=//'`	# strip first words
X	uname_a=`echo $uname_a`				# strip newlines
X	# which produces
X	# tick  uname  XENIX (empty) 2.3.1 SysV i80386 3 3000 3615
X	o=XENIX
Xfi
X
Xif test -n "$uname_a" ; then 
X	set $uname_a
X	for n in 1 2 3 4 5 6 7 8 9 ; do
X		eval u$n=\$$n
X	done
Xfi
Xif test -n "$motd1" ; then 
X	set $motd1
X	for n in 1 2 3 4 5 6 7 8 9 ; do
X		eval m$n=\$$n
X	done
Xfi
Xif test -n "$login" ; then 
X	set $login
X	for n in 1 2 3 4 5 6 7 8 9 ; do
X		eval l$n=\$$n
X	done
Xfi
Xif test -n "$skernel" ; then 
X	set $skernel
X	for n in 1 2 3 4 5 6 7 8 9 ; do
X		eval k$n=\$$n
X	done
Xfi
Xif test -n "$fkernel" ; then 
X	# grossness needed for Tower32/700
X	fkernel=`echo $fkernel | sed 's///g'`
X	set $fkernel
X	for n in 1 2 3 4 5 6 7 8 9 ; do
X		eval f$n=\$$n
X	done
Xfi
X
X## take first crack at OS
X#
X# The order of this OS list is important.
X#
X# Weirdos go at the beginning:
X# DC/OSx and SMP_DC.OSx must be before OSx.
X# DYNIX/ptx must be before DYNIX because "DYNIX" will get both
X# CTIX must be before TI because "TI" will get both
X# OS/MP must be before SunOS because Solbourne will report success for both.
X# Auspex must be before SunOS because Auspex will report success for both.
X# Worksystem must be before Ultrix because motd has to be parsed differently.
X#
X# Generally, however, it is sorted in alphabetical order with the
X# word "UNKNOWN" at the end.
XOSLIST='
XDC/OSx
XSMP_DC.OSx
XOS/MP
XCTIX
XWorksystem
XAuspex
X3B15
X3B2
XAIX
XB.O.S.
XBOSX
XConvexOS
Xdgux
XDYNIX/ptx
XDYNIX
XHP-UX
XIRIX
XMotorola
XNonStop-UX
XOSF
XOSx
XRISCos
XStardent
XSunOS
XTI
XULTRIX
XUltrix
XUmax
XUMIPS
XUnisysOS
Xuts
XXENIX
XUNKNOWN'
X
Xa=		# cpu architecture (e.g. sun4)
XA=		# cpu/kernel architecture (e.g. sun4c)
Xl=		# level of os
Xm=		# model
Xo=		# os
Xv=		# vendor
Xtos=		# testos
Xfor tos in $OSLIST ; do
X	case "$uname_a $motd1 $login" in
X	*$tos*)	o=$tos ; break ;;
X	*)	continue ;;
X	esac
Xdone
X# more attempts to discover OS - handle some special cases
Xcase $tos in
X3B15)		o=SVR3	;;	# real gross hack
X3B2)		o=SVR3	;;	# real gross hack
XOSx)		o=$u1	;;	# usually it's OSxsomething
XUltrix)		o=ULTRIX;;	# capitalize because newer versions do
XOSF)		case "$m1" in DEC) o="${m1}_$m2" ;; esac ;;
XSunOS)
X	case $u3 in
X	4*)	: do nothing we are really SunOS ;;
X	5*)	o=Solaris ;;
X	esac
X;;
XUNKNOWN)
X	# try more tricks
X	# the 'while' gives us something to break out of
X	while : ; do
X		#NCR boxes
X		#Tower   uname  UnixV.3 $host 010101 8 68030
X		#SVR4    uname  $host $host 4.0 2.0 i386/i486 386/486/MC
X		# level for a all NCR boxes can be found by checking /etc/.relid
X		# rodent: RELEASE 010000 Release Version 16 NST OS
X		if test -f /etc/.relid ; then
X			test -d /ncrm && o=TowerOS && break
X			#strings /unix | grep 'NCR UNIX' generates:
X			#NCR UNIX System V/386 Release %s Version %s
X			#NCR UNIX V.4 MPCA Driver, Release %s
X			echo "$skernel" | grep 'NCR UNIX' > /dev/null && o=NCR_SVR4.2 && break
X		fi
X
X		#Stardent login  Stardent UNIX Release %s on %s Series
X		#SGI      login  IRIX System V Release %s %s
X		#Encore   login  2.5.1.1   10/13/91, Encore Computer Corp.
X		case "$login" in
X		*IRIX*)		o=IRIX		; break ;;
X		*Stardent*)	o=Stardent	; break ;;
X		*Convex*)	o=ConvexOS	; break ;;
X		*Encore*)	o=Umax    	; break ;;
X		esac
X
X		#UNISYS
X		#$host    kernel Unisys U 6000 - System V - Jan 1988
X		case "$skernel" in
X		*Unisys*)	o=UnisysOS	; break ;;
X		esac
X
X		#Arete
X		# syst:           Arete' 68000 pure  not stripped - version 32
X		echo "$fkernel" | grep Arete > /dev/null && o=AreteOS && break
X
X		# ICL
X		if test -d /icl && echo $uname_a | grep 'DRS [36]000' > /dev/null ; then
X			# DRS6000 is sparc, DRS3000 is i486
X			o=ICL_SVR4
X			break
X		fi
X
X		#Motorola 680x0
X		if test "$kernel" = /sysV68 -a "$f2" = V/68 -a "$u5" = M68030 ; then
X			o=Motorola
X		fi
X
X		# make sure we break out
X		break
X	done
X;;
Xesac
X
X## A modified version of this code from install_unbundled which came
X## with DBE for 4.1.2 is used for setting "$l" in the SunOS case below
X#SOS_COMPAT="4.1.2"
X#SOS_LEVEL=`/usr/ucb/strings /vmunix \
X#| /usr/bin/egrep '^Sun UNIX|^SunOS' | /usr/bin/egrep 'Release'\
X#| /bin/sed -e 's/.*Release \([^ ][^ ]*\) .*/\1/'`
X## Just the OS release number, with decimal point, but w/o ALPHA/BETA/whatever.
X#SOS_RELEASE=`echo $SOS_LEVEL | sed -e 's/[_a-zA-Z].*//'`
X
X# now see what we've got
X# do the easier stuff first
Xcase $o in
XAIX)		m=	; v=IBM		; l=$u4.$u3	; a=	; A=	;;
XAreteOS)	m=	; v=Arete	; l=$u4		; a=$u5	; A=	;;
XAuspex)		m=	; v=Auspex	; l="${m2}_$m3"	; a=$arch_k	; A=	;;
XB.O.S.)		m=$u5	; v=Bull	; l=$u3		; a=$f2	; A=	;;
XBOSX)		m=	; v=Bull	; l=$u4.$u3	; a=	; A=	;;
X# from motd on Convex:	*       ConvexOS and Utilities V9.1 installed.
XConvexOS)	m=	; v=Convex	; l=`grep 'ConvexOS and Utilities' /etc/motd | tail -1 | awk '{print $5}'` ; A=	;;
XCTIX)		m=	; v=Convergent	; l=$u3		; a=	; A=	;;
Xdgux)		m=$u5	; v=DG		; l=$u3		; a=$u6 ; A=	;;
XDYNIX)		m=$f2	; v=Sequent	; l=$m2		; a=$u5	; A=	;;
XDYNIX/ptx)	m=	; v=Sequent	; l=$m2		; a=$u5	; A=	;;
XHP-UX)		m=$u5	; v=HP		; l=`echo $u3 | sed -e 's/.*\([1-9]\.[0-9][0-9]*\)$/\1/'`	; a=$f2 ; A=	;;
XICL_SVR4)	m=$u5$u6; v=ICL		; l=$u4		; a=$u7	; A=	;;
XIRIX)		m=$u5	; v=SGI		; l=$u3		; a=$u6	; A=	;;
XMotorola)	m=	; v=Motorola	; l=$u3		; a=$u5	; A=	;;
X# from .relid on NCR_SVR4.2:	010791 RELEASE 010000 Release Version 16 NST OS
XNCR_SVR4.2)	m=	; v=NCR		; l=`sort +2n -3 /etc/.relid | tail -1 | awk '{print $3}'` ; A=	;;
XNonStop-UX)	m=	; v=Tandem	; l=$u3		; a=$u5	; A=	;;
XOS/MP)		m=	; v=Solbourne	; l=$m2		; a=$arch_k	; A=	;;
XDEC_OSF/1)	m=	; v=DEC		; l=$m3		; a=$u5	; A=	;;
XSMP_DC.OSx)	m=$u5	; v=Pyramid	; l=$u3		; a=$u7	; A=	;;
XDC/OSx)		m=$u5	; v=Pyramid	; l=$u4		; a=	; A=	;;
XOSx*)		m=$u5	; v=Pyramid	; l=$u3		; a=	; A=	;;
XRISCos)		m=	; v=MIPS	; l=$u3		; a=$u5	; A=	;;
XStardent)	m=	; v=Stardent	; l=$u3		; a=	; A=	;;
XSolaris)	m=$a	; v=Sun		; l=`echo $u3 | sed -e 's/[-_a-zA-Z].*//'`	; a=$arch	; A=$arch_k	;;
XSunOS)		m=$a	; v=Sun		; l=`echo $u3 | sed -e 's/[-_a-zA-Z].*//'`	; a=$arch	; A=$arch_k	;;
XSVR3)		m=$tos	; v=ATT		; l=$u3		; a=$f2	; A=	;;
XTI)		m=	; v=TI		; l=$u6		; a=$u7	; A=	;;
XTowerOS)	m=	; v=NCR		; l=$u3		; a=`echo $uname_a | awk '{print $NF}'` ; A=	;;
XULTRIX)		m=	; v=DEC		; l=$m2		; a=$u5	; A=	;;
XUmax)		m=	; v=Encore	; l=$u3		; a=$u5 ; A=	;;
XUMIPS)		m=	; v=MIPS	; l=$u3		; a=	; A=	;;
XUnisysOS)	m=$k2$k3; v=Unisys	; l=$u3		; a=$u5	; A=	;;
Xuts)		m=	; v=Amdahl	; l=$u4		; a=	; A=	;;
XWorksystem)	m=	; v=DEC		; l=$m2$m3	; a=	; A=	;;
XXENIX)		m=	; v=SCO		; l=$u3		; a=$u5	; A=	;;
Xesac
X
X## fill in some of the gaps now
Xcase $o in
XWorksystem)	o=ULTRIX ;;	# now that we've parsed the motd
Xesac
X
X# now do some harder stuff using 'crash' and other miscellaneous tricks
X# crash is available lots of places but it often contains nothing more
X# helpful than uname -a output and has a bazillion formats
Xecho '(echo stat | crash) 2> /dev/null' > $cr
Xchmod +x $cr
Xcase $o$l in
XAIX*)
X	echo "$fkernel" | grep 'RISC System/6000' > /dev/null && m=RS/6000
X;;
XTowerOS*)
X	test $f3 = 200/700 && m=$f2/700 || m=$f2
X;;
XDEC_OSF/1)
X	m=`(sizer -c | sed -e 's/cpu[ 	]*"//' -e 's/".*//') 2> /dev/null`
X	# just in case, crash's sum command is sometimes helpful
X	if test -z "$m" ; then
X		m=`( echo sum | crash ) 2> /dev/null | awk '/cpu:/ {print $2}'`
X	fi
X;;
XOS/MP*)
X	m="`$cr | awk '/machine type:/ {print $4}'"
X;;
XSunOS[43]*|Auspex*)
X	m="`$cr | sed -n -e '/machine type:[ 	]*/s///p'`"
X;;
XSunOS5*)
X	m="`strings "$kernel" | awk '/^Machine type/ {print $5}'`"
X;;
XULTRIX*)
X	# if we're running an Ultrix 2.x or 3.x then the
X	# architecture must be VAX
X	test -z "$a" && echo "$l" | grep -s '^[VT][23]' && a=VAX
X	# best method is sizer -c, but output isn't consistent
X	m=`(sizer -c) 2> /dev/null`
X	# just in case, crash's sum command is sometimes helpful
X	if test -z "$m" ; then
X		m=`( echo sum | crash ) 2> /dev/null | awk '/cpu:/ {print $2}'`
X	fi
X#	# getting the info from uerf sometimes works but can be sloooow
X#	#Fri May 22 04:33:55 PDT 1992
X#	#uerf -t s:13-apr-1986,10:47:00 e:20-apr-1986,17:30:00
X#	if test -z "$m" ; then
X#		# restrict to one year back because it's easy
X#		startdate=`date | awk '{print $3 "-" $2 "-" $NF - 1}'`
X#		m=`uerf -R -r 300 -t s:$startdate | grep DEC | grep -v 0: | awk 'NR==1 {print $1, $2;exit}'`
X#	fi
X;;
Xesac
X
X# get hostid/serial number
X# If it exists, and if it is used at all, the "hostid" command on many systems
X# is set (often in /etc/rc.local) to the hex version of the system's IP
X# address.  It does exist on some SysV and BSD derived systems.
X# Under SunOS, hostid gets a hex number from the CPU board's ID PROM (see
X# gethostid(2)) which is unique across all Suns.
X# Under Ultrix, if it isn't set it is reported as "0" which is useless.
Xcase $o in
XXENIX)		h=$u8	;;
X*)		h=`(hostid) 2> /dev/null | egrep -v '^ *(0|0x0) *$'` ;;
Xesac
X
X## Done at last!!  Now print it out!
X# first convert spaces in each field to underscores
Xfor var in v o l kernel a m h ; do
X	eval $var=`eval echo \"\$"$var"\" | sed -e 's/ /_/g'`
Xdone
X# second, print it
Xcase "$oneline" in
Xtrue)
X	# if unknown, show as dashes
X	for var in host v o l kernel a m h ; do
X		eval test -z \"\$"$var"\" && eval $var=-------
X	done
X	if test "$showhost" = true ; then
X		echo $host | awk '{printf("%-9s "),$1}'
X	fi
X	echo "$v" "$o" "$l" "$kernel" "$a" "$m" "$h" \
X	| awk '{printf("%-9s %-11s %-14s %-7s %-11s %-13s %-10s\n",$1,$2,$3,$4,$5,$6,$7)}' \
X	| sed 's/ *$//'
X;;
Xfalse)
X	if test "$showhost" = true ; then
X		echo "HOST=$host	# name of this host"
X	fi
X	echo "VENDOR_S=$v	# vendor / manufacturer"
X	echo "OS_S=$o		# operating system"
X	echo "OSLEVEL_S=$l	# release level of OS"
X	echo "KERNEL_P=$kernel	# name of kernel"
X	echo "ARCH_S=$a		# cpu architecture / chip (e.g. 'sun4')"
X	echo "ARCHK_S=$A	# cpu/kernel architecture / chip (e.g. 'sun4m')"
X	echo "MODEL_S=$m	# model of this machine"
X	echo "ID_S=$h		# hostid / serial number of machine"
X;;
Xesac
X
X# final cleanup
Xrm -f $rmlist
SHAR_EOF
chmod 0755 dist/bin/showsys ||
echo 'restore of dist/bin/showsys failed'
Wc_c="`wc -c < 'dist/bin/showsys'`"
test 14700 -eq "$Wc_c" ||
	echo 'dist/bin/showsys: original size 14700, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= dist/bin/sleep-number ==============
if test -f 'dist/bin/sleep-number' -a X"$1" != X"-c"; then
	echo 'x - skipping dist/bin/sleep-number (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting dist/bin/sleep-number (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dist/bin/sleep-number' &&
X:
X# sleep-number - based on last digits of IP address, output number of minutes
X# to sleep.  This is used by various to stagger requests from clients to
X# $SAHOST and $DHOST.
X# D.Alter 5/15/89
X# S.Shapiro 1/10/90 - make sure we get only one line from the hosts file
X# D.Alter 3/22/90 - moved tools from badger to pony. excluded mail 
X# machine from sleep stuff.
X# rca 1/29/91 - source sahead, change factor to 1 to spread out accesses to k9
X# rca 6/14/91 - make sure we get our IP address and print one only line
X# rca 3/13/94 - add code for NIS and DNS
X
X. /etc/dist/sahead
X
X# F is the factor (number of concurrent jobs allowed from same subnet)
X# wait time is 5 % 254 or max of 50 minutes sleep.
X# wait time is 3 % 254 or max of 84 minutes sleep. D.Alter 4/10/90
XF=1
X
X# get IP address from /etc/hosts
Xif test -f /etc/hosts ; then
X	ip=`cat /etc/hosts \
X	| sed -e 's/[ 	]*#.*//' -e '/^[ 	]*$/d' \
X	| egrep "[ 	]$HOST[ 	]|[ 	]$HOST$" \
X	| awk '{print $1}'`
Xfi
X
X# if we didn't get it from hosts, try DNS
Xif test -z "$ip" ; then
X	ip=`nslookup $HOST \
X	| grep '^Address: ' \
X	| tail -1 \
X	| grep -v '0\.0\.0\.0' \
X	| sed -e 's/.*[ 	]//'`
Xfi
X
X# else try NIS
Xif test -z "$ip" ; then
X	ip=`ypcat hosts 2> /dev/null \
X	| sed -e 's/[ 	]*#.*//' -e '/^[ 	]*$/d' \
X	| egrep "[ 	]$HOST[ 	]|[ 	]$HOST$" \
X	| awk '{print $1}'`
Xfi
X
Xf4=`echo "$ip" | sed -n -e 's/^[0-9]*\.[0-9]*\.[0-9]*\.\([0-9]*\).*/\1/p' -e '/^[0-9][0-9]*$/q'`
X
X# if we haven't figured it out, penalize by long wait (300 is illegal IP
X# number but legal sleep time :-)
Xif test -z "$f4" ; then
X	f4=300
Xfi
X
X# print sleep number
Xecho `expr 60 \* $f4 / $F`
SHAR_EOF
chmod 0755 dist/bin/sleep-number ||
echo 'restore of dist/bin/sleep-number failed'
Wc_c="`wc -c < 'dist/bin/sleep-number'`"
test 1603 -eq "$Wc_c" ||
	echo 'dist/bin/sleep-number: original size 1603, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= dist/bin/upd-dist ==============
if test -f 'dist/bin/upd-dist' -a X"$1" != X"-c"; then
	echo 'x - skipping dist/bin/upd-dist (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting dist/bin/upd-dist (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dist/bin/upd-dist' &&
X:
X# upd-dist - update distributed files
X
X# do this first, as usual
X. /etc/dist/sahead
X
Xtrap ":                                ; rm -f \$rmlist ; exit  " 0
Xtrap "echo $pr: interrupted, quitting. ; rm -f \$rmlist ; exit 1" 1 2 3 15
X
X# set up variables
Xnargs=$#		# number of command line arguments
Xnap=true		# assume we have to nap
Xgetall=false		# assume we look at the timestamp
Xsaenv=true		# assume we run setup.saenv if it is new
Xgetlist=/tmp/upd.get$$	# for updated files we need to get from $DHOST
Xscratch=/tmp/upd.tmp$$	# scratch file
Xpsstat=/tmp/upd.ps$$	# temporary file to store exit status of ps
Xstampdir=$DSRC/stamp	# where we put time stamps
Xtstamp=$stampdir/$HOST	# path to time stamp file for $HOST
Xrmlist="$getlist $scratch $psstat"		# cleanup list
XUSAGE="usage: $pr [now] [all] [nosaenv]"	# usage message
X
X# process command line args
Xfor i in $* ; do
X	case $i in
X	now)		nap=false ;;
X	all)		getall=true ;;
X	nosaenv)	saenv=false ;;
X	*)		echo "$USAGE" ; exit 1 ;;
X	esac
Xdone
X
X# nap time - we don't want all boxes to upd-dist from $DHOST at
X# the same time!
Xif test "$nap" = "true" -a -f $DTGTBIN/sleep-number ; then
X	sleep `$DTGTBIN/sleep-number`
Xfi
X
X# Before we do anything real, make sure cron is running.  This job assigned
X# to upd-dist because it is usually run by hand when we notice that a machine
X# hasn't timestamped itself in a few days.
X# /usr/lib/cron/FIFO is from SystemV R3.2.2
X# /usr/spool/cron/FIFO is from SunOS 4.*
X# make sure ps shows all processes so we don't start cron twice!
X# * check for line ending in cron, to make sure we catch .../cron and cron.
X# * check for line ending in cron<space>* (needed for TI)
X# * a possibly mis-behaving ULTRIX 4.2A says " (cron)$" 
Xif test -n "$PSALL_K" ; then
X	# number of cron jobs
X	ncron=`{ ps $PSALL_K ; echo $? > $psstat ; } | egrep '[ /(]?cron[ )]?$' | grep -v grep | wc -l`
X	# if the "ps" succeeded, and no crons are running
X	case "`cat $psstat`" in
X	0)
X		if test $ncron -eq 0 ; then
X			rm -f /usr/spool/cron/FIFO /usr/lib/cron/FIFO
X			cron
X		fi
X		rm -f $psstat
X	;;
X	*)
X		echo "$pr: 'ps $PSALL_K' exit status '`cat $psstat`' in $psstat"
X	;;
X	esac
Xfi
X
X# set up copy stuff
Xif test "$HOST" = "$DHOST" ; then
X	copy="cp"
X	cmd=""
Xelse
X	copy="rcp"
X	if test -z "$RSH_C" ; then
X		grep '^RSH_C' $SAENV
X		echo "$pr: \$RSH_C is null (please check $SAENV), quitting."
X		exit 1
X	fi
X	cmd="$RSH_C $DHOST -l $SAACCT"
X	if test "$RCPFORM" = 'host.login:' ; then
X		uid="$DHOST.$SAACCT:"
X	else
X		uid="$SAACCT@$DHOST:"
X	fi
X	# copy some small file, might as well be dlist
X	if test `rcp $uid$DSRC/dlist $scratch 2>&1 | wc -l` -ne 0 ; then
X		rcp $uid$DSRC/dlist $scratch
X		echo "$pr: '$HOST' can't rcp from '$DHOST' as '$SAACCT', quitting."
X		exit 1
X	fi
Xfi
X
X# get list of files to retrieve
Xcase $getall in
Xtrue)	$cmd $SABIN/distfiles $HOST all > $getlist ;;
Xfalse)	$cmd $SABIN/distfiles $HOST     > $getlist ;;
Xesac
Xif test $? -ne 0 ; then
X	$cmd date
X	echo "$pr: '$HOST' can't do remote shell to '$DHOST' as '$SAACCT', quitting."
X	exit 1
Xfi
X
X# if nothing has changed, then we're done
Xif test ! -s $getlist ; then
X	$cmd touch $tstamp
X	exit 0
Xfi
X
X# figure out which files we're getting
Xif test "$DHOST" = "$HOST" ; then
X	sed -e "s,^,$DSRC/,"     $getlist > $scratch
Xelse
X	sed -e "s,^,$uid$DSRC/," $getlist > $scratch
Xfi
Xmv $scratch $getlist
Xdistfiles=`   grep -v "/bin/"    $getlist`
Xdistbinfiles=`grep    "/bin/"    $getlist | grep -v "/bin/$pr"`
Xupd_distfile=`grep    "/bin/$pr" $getlist`	# special case - do $pr last!
X
X# get $distbinfiles (if there are any) first to pick up new tools
Xif test -n "$distbinfiles" ; then
X	# if we've got an interactive session
X	if test $nargs -gt 0 ; then
X		echo "$pr: copy over $DTGTBIN files"
X	fi
X	$copy $distbinfiles $DTGTBIN
Xfi
X
X# get $distfiles now if there are any
Xif test -n "$distfiles" ; then
X
X	## copy files for $DTGT
X	cd $DTGT
X	if test $nargs -gt 0 ; then
X		echo "$pr: copy over $DTGT files"
X	fi
X	$copy $distfiles .
X
X	# if it's a new setup.saenv, sahead or showsys, run setup.saenv;
X	# and if restorehost or some other hasn't told us not to
X	if test $saenv = true -a -n "`find setup.saenv sahead bin/showsys -mtime -1 -print 2> /dev/null`" ; then
X		sh setup.saenv
X	fi
X
X	# if it's a new crontab file, install it
X	if test -n "`find crontab.dist -mtime -1 -print 2> /dev/null`" ; then
X		current=/tmp/crontab.cur
X		new=/tmp/crontab.new
X		# get current version
X		if test "$CRONCMD_B" = true ; then
X			crontab -l > $current
X		else
X			cp $CRON_P $current
X		fi 
X		# get new version, converting to 4.3BSD format if necessary
X		if test "$CRON43_B" = "true" ; then
X			$DTGTBIN/crontab.conv43 crontab.dist > $new
X		else
X			cp crontab.dist $new
X		fi
X		# merge new and current version
X		$DTGTBIN/cut-paste $new $current
X		# install merged version
X		if test "$CRONCMD_B" = true ; then
X			crontab -r
X			crontab $current
X		else
X			cp $current $CRON_P 
X		fi
X		# cleanup
X		/bin/rm -f $current $new
X	fi
Xfi
X
X# clean up
X$cmd touch $tstamp
X
X# special case - get newest version of $pr if any - do this last!
Xif test -n "$upd_distfile" ; then
X	# if we have an interactive session
X	if test $nargs -gt 0 ; then
X		echo "$pr: copy over $upd_distfile"
X	fi
X	$copy $upd_distfile $DTGTBIN/$pr.new
X	mv $DTGTBIN/$pr.new $DTGTBIN/$pr
Xfi
SHAR_EOF
chmod 0755 dist/bin/upd-dist ||
echo 'restore of dist/bin/upd-dist failed'
Wc_c="`wc -c < 'dist/bin/upd-dist'`"
test 5193 -eq "$Wc_c" ||
	echo 'dist/bin/upd-dist: original size 5193, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= dist/sahead ==============
if test -f 'dist/sahead' -a X"$1" != X"-c"; then
	echo 'x - skipping dist/sahead (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting dist/sahead (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dist/sahead' &&
X:
X# sahead - header for Data Center System Administration "sh" tools
X# written by Bob Arnold (rca@ingres.com)
X#
X# The master version of this file is in $SAHOST:$DSRC (see $DSRC below).
X#
X# This file should 644 root, and should be sourced via ". /etc/dist/sahead".
X# It is distributed automatically.
X#
X# The code includes lots of variable definitions and macros for our
X# System Administration scripts.
X#
X# The variable names in all these scripts use the following conventions:
X#
X# abbr	meaning				example(s)
X#------	-------------------------------	---------------------------------------
X# XX_F	name of XX file			CRON_F=root
X# XX_D	directory where file XX lives	CRON_D=/usr/spool/cron/crontabs
X# XX_P	full path to file XX		CRON_P=/usr/spool/cron/crontabs/root
X# XX_P	XX_P=$XX_D/$XX_F by definition	CRON_P=$CRON_D/$CRON_F
X# XX_N	number				ALIASRO_N=5
X# XX_K	key				PSALL_K=ax (BSD), PSALL_K=-e (SysV)
X# XX_S	string				OS_S=SunOS, OSLEVEL_S=4.1.3
X# XX_B	boolean				INTERP_B=true if "#!" is supported
X# XX_C	command				RSH_C=rsh, RSH_C=remsh
X#
X# Remember - only the first 8 characters of a variable name are significant.
X# When choosing variable names I have tried to preserve the "_X" part, but
X# it has been necessary to drop the underscore sometimes.
X#
X# File, directory, path and string variables are set to null if they do not
X# exist or are not supported on the box.  For example, /etc/saenv would say
X# "CSH_P=" on AT&T SVR3 machines because they do not support csh.
X#
X# These scripts should not put single-quotes around the values assigned
X# to variables if the value will be only one word or token.  Tools may grep
X# /etc/saenv and /etc/dist/sahead, and the single-quotes can be misleading
X# in such usages.  E.g.:
X# XXXX=value		# Used where value is never more than one word/token
X# XXXX='values ...'	# Used where value might be two or more words/tokens
X
X## untested PATH, /etc/saenv will fix later
XPATH=/bin:/etc:/usr/bin:/usr/etc:/usr/ucb:/sbin:/usr/amdahl/bin:/usr/lbin:/usr/local/bin:/etc/dist/bin
Xexport PATH
X
X## actual variable definitions
XSAENV=/etc/saenv	# sysad environment description, created for each box
XSAHOST=_____		# sysad host
XSAACCT=_____		# system administration account on $SAHOST
XSAHOME=_____		# home dir for $SAACCT on both $SAHOST and $DHOST
XSAABIN=$SAHOME/abin	# sa executables run automatically by cron go here
XSABIN=$SAHOME/bin	# sa executables run by hand go here
XSADATA=$SAHOME/data	# data files live here
XSALIB=$SAHOME/lib	# for stuff needed by various utilities
XSALOG=$SAHOME/log	# logs of various stuff live here
XSASRC=$SAHOME/src	# all source code for sysad tools goes here
XSABKP=$SASRC/backup	# source for alldisks backup script, etc.
XDHOST=$SAHOST		# distribution host (convenient if same as $SAHOST)
XDSRC=$SAHOME/dist	# distribution source config files
XDSRCBIN=$DSRC/bin	# distribution source executables
XDTGT=/etc/dist		# distribution target, contains (links to) config files
XDTGTBIN=$DTGT/bin	# distribution target, contains executables
XSTASH=_____@$SAHOST	# receives reports from maintained hosts
X
X## if we're *creating* saenv (i.e. if we're being sourced by setup.saenv)
Xif test "$DOSETUP" = true ; then
X	# make sure it exists in case setup.saenv needs it
X	touch $SAENV
X## else the calling script can't do anything without /etc/saenv
Xelse
X	if   test ! -f /etc/saenv ; then
X		echo "$0: ESAENV - /etc/saenv does not exist; quitting."
X		exit 1
X	elif test ! -r /etc/saenv ; then
X		echo "$0: ESAENV - /etc/saenv is unreadable; quitting."
X		exit 1
X	elif test ! -s /etc/saenv ; then
X		echo "$0: ESAENV - /etc/saenv is empty; quitting."
X		exit 1
X	else
X		. /etc/saenv
X	fi
Xfi
X
X## now that we've got our SA environment set up, let's do some
X## globally useful stuff
X
X# pr is name of program which is sourcing this file
Xpr=`basename $0`	
X# this should never happen but just in case
Xif test -z "$pr" ; then
X	pr=$0
Xfi
X
X# get real user name (as opposed to effective uid given by whoami)
X# in the sed, the "!" is for most BSD-ish machines, the ":" is for AIX 3.0
Xrealuid=`who am i 2> /dev/null | awk '{print $1}' | sed -e 's/^.*[!:]//'`
Xif test -z "$realuid" ; then
X	if test -n "$LOGNAME" ; then
X		realuid=$LOGNAME
X	elif test -n "$USER" ; then
X		realuid=$USER
X	fi
Xfi
SHAR_EOF
chmod 0644 dist/sahead ||
echo 'restore of dist/sahead failed'
Wc_c="`wc -c < 'dist/sahead'`"
test 4197 -eq "$Wc_c" ||
	echo 'dist/sahead: original size 4197, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= dist/saenv.setup ==============
if test -f 'dist/saenv.setup' -a X"$1" != X"-c"; then
	echo 'x - skipping dist/saenv.setup (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting dist/saenv.setup (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dist/saenv.setup' &&
X:
X# saenv.setup
X
X# create a System Administration Environment "sh" script called /etc/saenv,
X# which is preferably sourced by /etc/dist/sahead, which is in turn sourced
X# by the calling script that needs all this stuff.
X
X# written by Bob Arnold (rca@ingres.com), first version 9/5/90.
X
X# Invoke with "sh saenv.setup" to make sure we run it through sh.
X# Install like this to *force* running it through sh by root:
X# -r--r--r--  1 root        29958 Jun  1 11:08 /etc/dist/bin/saenv.setup
X# Do first install via "inst-saenv host" on $SAHOST.
X# Whenever a new version of this script is installed in $SAHOST:$DSRC,
X# each host gets it and runs it thanks to "upd-dist".
X
X## before we do ANY real work, enforce proper permissions and usage
X# we'd like to use "test -x $0" but it's not available under Version 7 test.
X# The extra <space><star> in the egrep regular expression is for AIX 3.0
X# (and any other machines) which have a trailing space after the ls -F
X# asterisk.
Xif ls -dF $0 | egrep '\* *$' > /dev/null ; then
X	echo "$0: fixing permissions on $0"
X	chmod 400 $0
X	chown root $0
X	exec sh $0
Xfi
X
X## without /etc/dist/sahead we can't do anything
Xif   test ! -f /etc/dist/sahead ; then
X	echo "$0: ESAHEAD - /etc/dist/sahead does not exist ; quitting."
X        exit 1
Xelif test ! -r /etc/dist/sahead ; then
X	echo "$0: ESAHEAD - /etc/dist/sahead is unreadable; quitting."
X        exit 1
Xelif test ! -s /etc/dist/sahead ; then
X	echo "$0: ESAHEAD - /etc/dist/sahead is empty; quitting."
X        exit 1
Xelse
X	# sahead *requires* DOSETUP=true if we're trying to create a new
X	# /etc/saenv file (especially if we don't have one already!)
X	DOSETUP=true
X        . /etc/dist/sahead
Xfi
X
X################################################################################
X#### Initialize key strings (including PATH) and other variables
X
Xtsaenv=/tmp/saenvt$$	# temporary sysadmin environment file
Xscript=/tmp/saenvs$$	# temporary scripts used to test things
Xwrapper=/tmp/saenvw$$	# C object wrapper for temporary scripts
Xjunkdir=/tmp/saenvd$$	# scratch directory
Xjunkf=$junkdir/junk	# scratch file
Xout=$SAENV		# default output file
X# seperate cleanup lists for safety against mistakes in coding this script
Xrmlist="$script $script.c $wrapper $junkf"
Xrmrlist="$junkdir"
X
X## USAGE
XUSAGE='sh saenv.setup [-h | outfile]'	# make sure the script is run by "sh"
X
X## exit errors must be reported so inst-saenv can determine exit status
XELESSVAR="$0: ELESSVAR - '$tsaenv', the temp version of saenv,
X$0: has fewer variables than the current real version.
X$0: The temp version has NOT been installed as $SAENV."
X
X## HEADER for output file, which is usually $SAENV
XHEADER=':
X# This is /etc/saenv, which should be 444 root.
X# Bourne shell (or "ksh") scripts should source it via ". /etc/dist/sahead",
X# which should also be 444 root.  "csh" and "perl" scripts could modify it
X# easily using "sed" (or perl) to generate a useful environment.
X#
X# It is created by root doing "sh /etc/dist/saenv.setup", which should
X# be 444 root.  It can be created by hand, but normally it is created
X# by "/etc/dist/bin/upd-dist" on the local host.  It is also possible for
X# root on $SAHOST to create it via "rrun -l inst-saenv host".
X'
X
Xtest -d $DTGT    || mkdir $DTGT    || { echo "$pr: can't mkdir $DTGT"    ; exit 1 ; }
Xtest -d $DTGTBIN || mkdir $DTGTBIN || { echo "$pr: can't mkdir $DTGTBIN" ; exit 1 ; }
Xtest -d $junkdir || mkdir $junkdir || { echo "$pr: can't mkdir $junkdir" ; exit 1 ; }
Xchmod 700 $junkdir
X
X## set PATH environment variable
X# We always want the stuff in $endpath, need to test the other stuff.  Notes:
X# 1) Want system stuff, then BSD-ish stuff before SysV-ish stuff; this means
X# {/usr,}/{s,}bin before /usr/ucb before /usr/5bin
X# 2) if $SABIN exists and we're $SAHOST then we want it in the PATH, so
X# we have to find out our hostname now, before we do it officially later
X# 3) vendor OS variants:
X#	/sbin		SunOS 4.x, NCR SVR4, Pyramid SVR4
X#	/usr/bsd	IRIX
X#	/usr/bsd43/bin	MIPS
X#	/usr/amdahl/bin	UTS
X#	/usr/ccs/bin	SVR4
X#	/usr/lbin	Bull's B.O.S., Encore, Dynix/ptx, CCI SysV, Mips, NCR
X#	/usr/sbin	SVR4, Irix
X#	/usr/ucb	BSD, many vendors
X#	/usr/5bin	Pyramid, SunOS
X# 4) Since we're trying to describe the OS, PATH for this script should be
X# in order of OS bin directories followed by vendor stuff and then local stuff.
X# We put /sbin last since we don't normally want this on Suns, but we have
X# to have it on NCR SysVR4
Xguesscommon="/usr/sbin /sbin /usr/bin /bin /etc /usr/etc /usr/ucb"
Xguessvendor="/usr/bsd /usr/bsd43/bin /usr/5bin /usr/amdahl/bin /usr/lbin /usr/ccs/bin"
Xguess="$guesscommon $guessvendor"
Xlocal=":$DTGTBIN:/usr/local/bin"
Xfor dir in $guess ; do
X	if test -d $dir ; then
X		# if first dir in path
X		if test -z "$path" ; then
X			path=$dir
X		else
X			path=$path:$dir
X		fi
X	fi
Xdone
Xhost="`(hostname) 2> /dev/null`"	# early version of $host needed here
Xif test "$host" = $SAHOST -a -d $SABIN ; then
X	path=$path:$SABIN
Xfi
Xpath=$path$local
XPATH=$path
Xexport PATH
X
X################################################################################
X#### process command args
X
Xif test $# -gt 1 ; then
X	echo "$USAGE"
X	exit 1
Xelif test $# -eq 1 ; then
X	case "$1" in
X	-h)     echo "$USAGE" ; exit ;;
X	'')     : this is defensive measure - do nothing ;;
X	*)      out=$1 ;;
X	esac
Xfi
X
X################################################################################
X#### initial setup of temporary saenv
Xecho "$HEADER" > $tsaenv	# create $tsaenv
Xecho "PATH=$PATH	# exportable PATH" >> $tsaenv
X
X################################################################################
X#### host/network stuff
X
X## HOST - name of our local host
Xif (hostname) > /dev/null 2>&1 ; then
X	HOST="`hostname`"	# normal BSD
Xelse
X	HOST="`uname -n`"	# Sys V
Xfi
Xecho "HOST=$HOST 	# the name of this host" >> $tsaenv
X
X## RSH_C - name of remote shell command
X# as a last-ditch effort, try rcmd (SCO), nsh (Encore), resh (Dynix/ptx), rshell (Bull's B.O.S)
X# but first a bit of prep work to make sure $HOST trusts itself
Xegrep "^$HOST[ 	]+root" /.rhosts > /dev/null || echo "$HOST root" >> /.rhosts
Xegrep "^$HOST\$" /etc/hosts.equiv > /dev/null || echo "$HOST" >> /etc/hosts.equiv
X# and more prep work to make sure we don't have a file/directory/whatever
X# called $HOST in our current directory.
Xcd $junkdir
Xrm -f $HOST
X# OK, we're finally ready
Xfor i in remsh rsh resh rcmd nsh rshell ; do
X	# if subshell succeeds, or $HOST doesn't trust itself, or $HOST is a
X	# diskless host which doesn't have its IP address in its hosts file,
X	# or doesn't want to talk to itself for some reason
X	x=`( $i $HOST date ) 2>&1`
X	if test $? -eq 0 || echo "$x" | sed 1q | egrep "[Pp]ermission denied|$HOST: unknown host|Connection timed out" > /dev/null ; then
X		rsh=$i
X		break
X	fi
Xdone
X# if we still haven't found $rsh, try some other tricks
X# the "while" gives us something to break out of if we find it
Xwhile test -z "$rsh" ; do
X	# for convex which has both a /bin and a /usr/ucb "rsh", if $rsh
X	# is null try again to force /usr/ucb/rsh and screw if that fails.
X	# Do the same for /usr/bsd/rsh for SGI.
X	for i in /usr/ucb/rsh /usr/bsd/rsh ; do
X		if ( $i $HOST date ) > /dev/null 2>&1 ; then
X			rsh=$i
X			break ; break
X		fi
X	done
X	# if we haven't found it by now, give up
X	break
Xdone
Xecho "RSH_C=$rsh 	# rsh command: 'rsh' (BSD,XENIX), 'remsh' (SysV), 'rcmd' (SCO), 'nsh' (Encore), 'resh' (Dynix/ptx), 'rshell' (B.O.S.), '/usr/ucb/rsh' (misc)" >> $tsaenv
X
X## RCPFORM - get form for rcp commands if we're trying to an rcp as another user
X# this test relies on $HOST trusting it's own root account, but we just
X# took care of that above in $RSH_C.  The stupidity of using "wc" instead
X# of checking rcp's exit status is required because rcp on UTS 2.1 (and
X# maybe other UNIXs?) exits with a status of 0 even if the host is unknown
X# or the form/syntax is wrong.
Xrm -f $junkf
Xif   test `rcp $HOST.root:/etc/group $junkf 2>&1 | wc -l` -eq 0 ; then
X	RCPFORM="host.login:"
Xelif test `rcp root@$HOST:/etc/group $junkf 2>&1 | wc -l` -eq 0 ; then
X	RCPFORM="login@host:"
X# else we have to protect against strange network events, so
X# use the old version if it is available
Xelse
X	eval `grep 'RCPFORM=' $SAENV`
X	RCPFORM=${RCPFORM-''}
Xfi
Xrm -f $junkf
Xecho "RCPFORM=$RCPFORM 	# rcp form: 'host.login:' or 'login@host:'" >> $tsaenv
X
X## EXOSHOST_B - is /etc/hosts in EXOS format?
XEXOSHOST_B=false
Xsed -e 's/		*/ /g' -e 's/ *\#.*//' -e '/^ *$/d' -e 's/$/ /' /etc/hosts > $junkf
Xegrep '^127\.0\.0\.[01] localhost '             $junkf > /dev/null
Xstat1=$?
Xegrep " $HOST .*localhost | localhost.* $HOST " $junkf > /dev/null
Xstat2=$?
Xif test $stat1 -ne 0 -a $stat2 -eq 0 ; then
X	EXOSHOST_B=true
Xfi
Xrm -f $junkf
Xecho "EXOSHOST_B=$EXOSHOST_B 	# is /etc/hosts in EXOS format?" >> $tsaenv
X
X## Find path to automounter
X#
X# Some variants on the name/location
X# /usr/etc/automount:	SunOS 4.0/4.1/4.1.1
X# /usr/lib/nfs/automount:		Sun solaris 2.0
Xfor i in /usr/etc/automount /usr/lib/nfs/automount ; do
X	if test -f $i ; then
X		AUTOMOUNT_P=$i
X		break
X	fi
Xdone
Xecho "AUTOMOUNT_P=$AUTOMOUNT_P	# automounter path" >> $tsaenv
X
X################################################################################
X#### looking for files, directories, and such
X
X## CSH_P - path to csh (if we have it)
Xfor i in `echo $PATH | tr : ' '` ; do
X	#if ls -dF $i/csh | egrep '\* *$' > /dev/null ; then
X	if test -f $i/csh ; then
X		if ( $i/csh -c alias ) > /dev/null 2>&1 ; then
X			CSH_P=$i/csh
X			break
X		fi
X	fi
Xdone
Xecho "CSH_P=$CSH_P	# path to csh" >> $tsaenv
X
X## Find path to BSD dump/restore (deal with Dynix's hdump for 8mm next)
X## DRMINUS - does the dump/restore key requires a "-" sign at the beginning?
X# except for Bull B.O.S., restore is called "restore/rrestore"
X#
X# Some variants on the name/location:
X# AU/X for the Apple mac2 calls bsd dump "dumpfs" and att dump "dump".
X# ULTRIX does it the better way - bsd dump is "dump" and att dump is "dumpfs".
X# CCI SysV has "fdump" and "rdump".
X# /etc/dump		Ultrix 2.0(?), CCI 4.3, Dynix/ptx, HP/UX, ConvexOS,
X#			Pyramid, UTX/32 2.1a, SunOS 3.x, DG/UX
X# /etc/dump2		DG/UX (which is different from DG/UX's /etc/dump)
X# /usr/etc/dump		SunOS 4.0, 4.1.X, IRIX
X# /bin/dump		Ultrix 2.x(?)/3.x/4.x
X# /etc/bsddump		Convex R2.4 has /etc/bsd{dump,rdump,restore,rrestore}
X# /etc/fdump		CCI SysV
X# /usr/sbin/dump	DG AViiON
X# /sbin/ufsdump		Pyramid SVR4: why did Pyramid put them in ...
X# /usr/sbin/rufsdump	Pyramid SVR4: ... different directories :-(
X# /usr/lib/fs/ufs/ufsdump	SVR4 from ICL, NCR and others
X# /etc/fsdump		Bull B.O.S., with a number of frustrations
X#	a) fsdump requires a "-" before the dump key, e.g. "dumpfs -0f ..."
X#	b) fsdump -W redraws the screen, which means that ...
X#	c) fsdump -W complains to stderr if $TERM is not set or it doesn't
X#	   know how to deal with your terminal type
X#
X# Sequent's Dynix has "/etc/hdump" (see below) for the 8mm helical scan video
X# drives and normal "/etc/dump" for other work.
X#
X# DG's DG/UX has both dump and dump2.  However, once dump2 has touched
X# dumpdates, dump can't be used again without converting dumpdates back
X# to standard dump format.  So, practically speaking they are mutually
X# exclusive.
X#
X# SGI's IRIX 5.0.1 DUMP(1M) man page notes under the BUGS section:
X# "dump with the W or w options does not report filesystems that have
X# never been recorded in /etc/dumpdates, even if listed in /etc/fstab."
X# And it's true :-( but hey let's give them credit for documenting it!
X#
X# SGI's RISCos 5.01 is weird: these are all valid, but /usr/{etc,sbin}/dump
X# is a "smart" front end which checks for "ffs" filesystem type.
X# /etc/dump -> ../usr/sbin/dump
X# /usr/etc/dump
X# /usr/sbin/dump
X# /etc/rdump -> ../sbin/rdump
X# /sbin/rdump
X# /etc/restore
X# /sbin/restore
X# /etc/rrestore -> ../sbin/rrestore
X# /sbin/rrestore
X# We pick the {rdump,restore,rrestore} in /etc, not /sbin.
X#
X# Tandem's NonStop-UX 4.0 has two filesystem types: ufs and vxfs (Veritas)
X# /sbin/vxdump and /usr/lib/fs/ufs/ufsdump are used to back up these
X# filesystems.
X#
X# Someday we should integrate AIX's /etc/backup, /etc/rdump, /etc/restore,
X# and /etc/rrestore.  The "/etc/backup W" trick doesn't work for AIX :-(
X#
X# The path to BSD restore is usually the same as the path to dump, 
X# with a couple of known exceptions handled in the code (see below).
X# 
X# Under SunOS 4.0.3 and 4.1.1, "/usr/etc/dump W" gives a "Segmentation fault"
X# if /etc/dumpdates doesn't exist, so create one temporarily if necessary.
Xif test ! -f /etc/dumpdates ; then
X	touch /etc/dumpdates
X	tmpdumpdates=true
Xfi
Xfor i in /usr/etc/dump /bin/dump /etc/dump /etc/dump2 /etc/bsddump /etc/fdump /etc/dumpfs /usr/sbin/dump /sbin/ufsdump /usr/lib/fs/ufs/ufsdump /etc/fsdump ; do
X	if test -f $i ; then
X		for flag in '' '-' ; do
X			if test -n "`$i ${flag}W 2> /dev/null`" ; then
X				dump=$i
X				drminus=$flag
X				break
X			fi
X		done
X		# SGI's "/usr/etc/dump W" can produce no output, especially
X		# on a new system!  The strategy here is:
X		# SysV dump probably won't live in /usr/etc/dump along
X		# with a /usr/etc/restore; and if the "/usr/etc/dump W" exit
X		# status is 0 we've probably found what we want.
X		if test -z "$dump" -a $i = /usr/etc/dump -a -f /usr/etc/restore ; then
X			if $i W > /dev/null 2>&1 ; then	
X				dump=$i
X				drminus=''
X			fi
X		fi
X		# Solaris's '/usr/lib/fs/ufs/ufsdump W' croaks with
X		# "Segmentation Fault (core dumped)" in C-shell and
X		# "Segmentation Fault - core dumped" in Bourne-shell if it sees
X		# a single "-" in the filesystem_type field of /etc/vfstab.
X		# This is probably a Solaris and not a generic SVR4 problem.
X		# Note we have to use csh to trap this, because sh seems to be
X		# writing to /dev/tty (anyway it's for sure not writing to
X		# STDOUT or STDERR).  Luckily, Solaris has csh.
X		if test -z "$dump" -a $i = /usr/lib/fs/ufs/ufsdump -a -f $i ; then
X			if test "`csh -c '/usr/lib/fs/ufs/ufsdump W'`" = 'Segmentation Fault (core dumped)' ; then
X				echo "$pr: Solaris' ufsdump has a bug which causes it to dump core when"
X				echo "$pr: it sees a '-' in the filesystem_type field of /etc/vfstab."
X				echo "$pr: These are probably the offending lines /etc/vfstab:"
X				awk '$0 !~ /^\#/ && $4 == "-"' /etc/vfstab
X				echo "$pr: You can test this with:"
X				echo "$pr:         csh -c '$i W'"
X				echo "$pr: You have a problem if this says:"
X				echo "$pr:         Segmentation Fault (core dumped)"
X				echo "$pr: Please fix /etc/vfstab."
X				exit 1
X			fi
X		fi
X		# if we got this far we're *probably* a Bull B.O.S. machine
X		# so we've got to do the check with TERM in the environment
X		if test -z "$dump" -a $i = /etc/fsdump -a -f /etc/fsrestore ; then
X			# bull's grok vt100
X			x=$TERM
X			TERM=vt100 ; export TERM
X			if test -n "`$i -W 2> /dev/null`" ; then
X				dump=$i
X				drminus="-"
X				TERM=$x ; export TERM
X			fi
X			TERM=$x ; export TERM
X		fi
X	fi
X	# if we found dump, get its friends restore, rdump, and rrestore; and
X	# then break out of the main "for" loop here.
X	# handle case for DG's dump2;
X	# handle cases like Solaris where ufsdump handles remote filesystems
X	# too - this is only a fallback guess since we have no quick
X	# and easy way to verify it.
X	# handle SGI's RISCos with /usr/etc/{r,}dump and /etc/{r,}restore
X	if test -n "$dump" ; then
X		dumphead=`echo $i | sed -e 's,dump[^/]*$,,'`
X		for p in restore rdump rrestore ; do
X			# deal with SGI's RISCos
X			if   test $p =  rdump   -a $dump = /usr/etc/dump -a -f /etc/rdump    ; then
X				rdump=/etc/rdump
X			elif test $p =  restore -a $dump = /usr/etc/dump -a -f /etc/restore  ; then
X				restore=/etc/restore
X			# deal with SGI's RISCos again
X			elif test $p = rrestore -a $dump = /usr/etc/dump -a -f /etc/rrestore ; then
X				rrestore=/etc/rrestore
X			# deal with DG/UX
X			elif test $p = rdump -a $dump = /etc/dump2 ; then
X				rdump=$dump
X			# deal with Pyramid's SVR4
X			elif test $p = rdump    -a $dump = /sbin/ufsdump -a -f /usr/sbin/rufsdump ; then
X				rdump=/usr/sbin/rufsdump
X			# deal with Pyramid's SVR4 again
X			elif test $p = rrestore -a $dump = /sbin/ufsdump -a -f /usr/sbin/rufsrestore ; then
X				rrestore=/usr/sbin/rrestore
X			# the most common and most desirable case
X			elif test -f $dumphead$p ; then
X				eval $p=$dumphead$p
X			# another common case
X			elif test $p = rdump ; then
X				rdump=$dump
X			# still another common case
X			elif test $p = rrestore ; then
X				rrestore=$restore
X			fi
X		done
X		break
X	fi
Xdone
X# if we had to create a temporary /etc/dumpdates, clean up
Xif test "$tmpdumpdates" = true ; then
X	rm -f /etc/dumpdates
Xfi
Xecho "DUMP_P=$dump		# BSD dump path: many variations" >> $tsaenv
Xecho "RDUMP_P=$rdump		# BSD rdump path: many variations" >> $tsaenv
Xecho "RESTOR_P=$restore		# BSD restore" >> $tsaenv
Xecho "RRESTOR_P=$rrestore	# BSD rrestore" >> $tsaenv
Xecho "DRMINUS=$drminus		# BSD dump/restore key minus sign: '' (normal) ; '-' (B.O.S, ICL SVR4, DG/UX's dump2)" >> $tsaenv
X
X## HDUMP_P and HRDUMP_P - Sequent's helical scan BSD dump stuff
Xhdump=''
Xhrdump=''
Xif ls -dF /etc/hdump 2>&1 | egrep '\*$' > /dev/null ; then
X	hdump=/etc/hdump
X	hrdump=/etc/hrdump
Xfi
Xecho "HDUMP_P=$hdump		# Sequent's old Dynix helical scan BSD dump path" >> $tsaenv
Xecho "HRDUMP_P=$hrdump		# Sequent's old Dynix helical scan BSD rdump path" >> $tsaenv
X
X## DRB_K - dump/restore block size key
X# On every system that has restore, bad restore key characters generate:
X# "Bad key character <char>"
X# ("every system" means every system running alldisks on Dec 18, 1990 :-)
X#
X# Ultrix [34].x dump accepts "b" but restore doesn't.
X# Pyramid's man pages and actual behavior for dump are not consistent.
X# Pyramid dump uses "b"; man dump says "the default is 5", dump itself says
X#	DUMP: Block size must be a positive, even integer
X# Pyramid restore uses "b", but "b" must be "positive and a power of 2"
X# if restore has been found, see if we have a dump/restore blocksize key
Xif test -n "$restore" ; then
X	# we've got to make sure the restore quits, so we do it by
X	# providing an odd negative block size, a non-dump file,
X	# and the "quit" command.  Luckily BSD restore seems to
X	# evaluate the key itself before looking at anything else.
X	echo quit | $restore ${DRMINUS}ifb $script -3 2>&1 | egrep "Bad key character $i" > /dev/null
X	# if "b" isn't a bad key character
X	if test $? -ne 0 ; then
X		DRB_K=b
X	fi
Xfi
Xecho "DRB_K=$DRB_K	# dump/restore blocksize key: 'b' (normal), '' (Ultrix, old HP, or dump/restore not supported)" >>$tsaenv
X
X## CRON_P - path to real crontab file
X# /usr/lib, /etc, /usr/etc		Version 7 and BSD decendants
X# /private.MC68020/usr/lib/crontab	SunOS 3.x
X# /usr/spool/cron/crontabs/root		SysV
Xcron_d=`$DTGTBIN/realdir crontab /usr/etc /etc /usr/lib /private.MC68020/usr/lib` 
Xif test -z "$cron_d" ; then
X	if test -d /usr/spool/cron/crontabs ; then
X		CRON_P=/usr/spool/cron/crontabs/root
X		# make sure crontab for root exists - needed for "crontab -l"
SHAR_EOF
true || echo 'restore of dist/saenv.setup failed'
fi
echo 'End of saenv_alld part 1'
echo 'File dist/saenv.setup is continued in part 2'
echo 2 > _shar_seq_.tmp
exit 0
