Newsgroups: comp.sources.unix
From: jeff@forys.cranbury.nj.us (Jeff Forys)
Subject: v28i087: skill - signal or reprioritize specified processes, V3.6, Part01/03
Message-id: <1.774325799.5452@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: jeff@forys.cranbury.nj.us (Jeff Forys)
Posting-Number: Volume 28, Issue 87
Archive-Name: skill/part01

	`skill' is a program which sends signals to processes given
any combination of user names, ttys, commands, and pids.  `snice' is
a program which changes the priority of processes (given the same).
It's actually one program which examines argv to determine what action
is to be taken on matching processes.  It is similar to kill(1) and
renice(8), however the command line is completely order independent.
There are also verbose, search, and interactive modes of operation.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 3)."
# Contents:  Config GuessOS MANIFEST Makefile README argparse.c conf.h
#   machdep machdep/bsd-44.c machdep/irix-5.c machdep/mach-26.c
#   machdep/next-2.c machdep/sunos-40.c machdep/sunos-41.c
#   machdep/umax-42.c main.c skill.1
# Wrapped by vixie@gw.home.vix.com on Fri Jul 15 19:29:12 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Config' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Config'\"
else
echo shar: Extracting \"'Config'\" \(1461 characters\)
sed "s/^X//" >'Config' <<'END_OF_FILE'
X#!/bin/sh
X#
X#	$Header: Config,v 1.14 1994/06/26 03:17:00 forys Exp $
X#
X#	Configure - edit skill Makefile filling in OSTYPE, COPTS, and LIBS.
X#	Contributed by: Ric Anderson <ric@cs.arizona.edu>
X#
XOSTYPE=
XCOPTS=
XLIBS=
X
XSYS=`sh GuessOS 2>/dev/null`
Xcase $SYS in
X    bsd42)
X	OSTYPE=bsd-43 COPTS=-DNO_UID_T
X	;;
X
X    bsd43)
X	OSTYPE=bsd-43
X	;;
X
X    bsd44)
X	OSTYPE=bsd-44 LIBS=-lkvm
X	;;
X
X    sos3)
X	OSTYPE=sunos-3
X	;;
X
X    sos4)
X	OSTYPE=sunos-40 LIBS=-lkvm
X	;;
X
X    sos4_1)
X	OSTYPE=sunos-41 LIBS=-lkvm
X	;;
X
X    dynix3)
X	OSTYPE=dynix-3
X	;;
X
X    osx*)
X	OSTYPE=osx-4
X	;;
X
X    svr*)
X	OSTYPE=sys-5r4
X	;;
X
X    hpux8|hpux9)
X	OSTYPE=hpux-91
X	;;
X
X    hpux7)
X	OSTYPE=hpux-70
X	;;
X
X    hpux*)
X	OSTYPE=hpux-70 COPTS=-DNO_UID_T
X	;;
X
X    mach2)
X	OSTYPE=mach-26 LIBS=-lsys
X	;;
X
X    mach3)
X	OSTYPE=mach-26
X	;;
X
X    next1)
X	OSTYPE=mach-26
X	;;
X
X    next*)
X	OSTYPE=next-2
X	;;
X
X    umips*)
X	OSTYPE=umips-21 LIBS=-lmld
X	;;
X
X    ultrix2)
X	OSTYPE=ultrix-22
X	;;
X
X    ultrix4)
X	OSTYPE=ultrix-4
X	;;
X
X    aos43)
X	OSTYPE=aos-43
X	;;
X
X    aix3)
X	OSTYPE=aix-3
X	;;
X
X    irix3)
X	OSTYPE=irix-3 LIBS=-lmld
X	;;
X
X    irix4)
X	OSTYPE=irix-4 LIBS=-lmld
X	;;
X
X    irix5)
X	OSTYPE=irix-5
X	;;
X
X    umax42)
X	OSTYPE=umax-42 COPTS=-DNO_UID_T
X	;;
X
X    *)
X	echo Config: unknown system type: $SYS
X	exit 1
X	;;
Xesac
Xecho Configuring as ${SYS}: OSTYPE=${OSTYPE} COPTS=${COPTS} LIBS=${LIBS}
Xchmod u+w Makefile
Xed - Makefile <<EOS
X/^OSTYPE=/c
XOSTYPE=	${OSTYPE}
X.
X/^COPTS=/c
XCOPTS=	${COPTS}
X.
X/^LIBS=/c
XLIBS=	${LIBS}
X.
Xw
Xq
XEOS
END_OF_FILE
if test 1461 -ne `wc -c <'Config'`; then
    echo shar: \"'Config'\" unpacked with wrong size!
fi
chmod +x 'Config'
# end of 'Config'
fi
if test -f 'GuessOS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'GuessOS'\"
else
echo shar: Extracting \"'GuessOS'\" \(2034 characters\)
sed "s/^X//" >'GuessOS' <<'END_OF_FILE'
X#!/bin/sh
X#
X#	$Header: GuessOS,v 1.12 1994/06/26 03:17:24 forys Exp $
X#
X#	GuessOS - guess the OS type for skill.
X#	Contributed by: Ric Anderson <ric@cs.arizona.edu>
X#
X#	the OS name is echoed to standard output, based on /etc/motd,
X#	or, failing that, the location of some files.
X#
X
Xcase "`exec 2>/dev/null; head -2 /etc/motd`" in
X    *"DYNIX(R) V3."*)
X	OS=dynix3
X	;;
X    *"Sun UNIX 4.2 Release 3."*)
X	OS=sos3
X	;;
X    *"SunOS Release 4.1"*)
X	OS=sos4_1
X	;;
X    *"SunOS Release 4."*)
X	OS=sos4
X	;;
X    *"ULTRIX V4."*)
X	OS=ultrix4
X	;;
X    *"Ultrix"*"V2"*)
X	OS=ultrix2
X	;;
X    *"NeXT Mach 1"*)
X	OS=next1
X	;;
X    *"NeXT Mach 2"*)
X	OS=next2
X	;;
X    *"Mach 3"*)
X	OS=mach3
X	;;
X    *"4.3 BSD UNIX"*)
X	if [ -f /etc/ttylocal ]; then
X	    OS=xinu43
X	else
X	    OS=bsd43
X	fi
X	;;
X    *"4.3 BSD Reno UNIX"*)
X	OS=bsd44
X	;;
X    *"4.4BSD"*)
X	OS=bsd44
X	;;
X    *"UMIPS"*)
X	OS=umips
X	;;
X    *"Umax 4.2"*)
X	OS=umax-42
X	;;
X#
X# RATS!!!  Try to sniff out a file or two.
X#
X    *)
X	if [ -f /usr/lib/libNeXT_s.a ]; then
X	    OS=next2
X	elif [ -f /mach ]; then
X	    OS=mach2
X	elif [ -f /bin/universe ]; then
X	    OS=osx
X	elif [ -f /bin/4d ]; then
X	    case "`exec 2>/dev/null; uname -r`" in
X		"3."*)
X		    OS=irix3
X		    ;;
X		"4."*)
X		    OS=irix4
X		    ;;
X		"5."*)
X		    OS=irix5
X		    ;;
X		*)
X		    OS=unknown
X		    ;;
X	    esac
X	elif [ -f /sbin/uname ]; then
X	    case "`exec 2>/dev/null; /bin/uname -r`" in
X		3.*)
X		    OS=svr3
X		    ;;
X		4.*)
X		    OS=svr4
X		    ;;
X		*)
X		    OS=svrx
X		    ;;
X	    esac
X	elif [ -d /etc/aix -o -d /etc/aixdwm ]; then
X	    OS=aix3
X	elif [ -f /usr/bin/cat ]; then
X	    OS=sos4
X	elif [ -f /etc/nd ]; then
X	    OS=sos3
X	elif [ -f /etc/ttylocal ]; then
X	    OS=xinu43
X	elif [ -f /Umax.image ]; then
X	    OS=umax42
X	elif [ -d /usr/ibm ]; then
X	    OS=aos43
X	elif [ -f /bin/hp9000s800 ]; then
X	    case "`exec 2>/dev/null; /bin/uname -r`" in
X		A.B7.*|7.*)
X		    OS=hpux7
X		    ;;
X		A.B8.*|8.*|A.08.*|A.B9.*|9.*|A.09.*)
X		    OS=hpux9
X		    ;;
X		*)
X		    OS=hpux
X		    ;;
X	    esac
X	else
X	    OS=unknown
X	fi
X	;;
Xesac
Xecho "${OS}"
Xexit 0
END_OF_FILE
if test 2034 -ne `wc -c <'GuessOS'`; then
    echo shar: \"'GuessOS'\" unpacked with wrong size!
fi
chmod +x 'GuessOS'
# end of 'GuessOS'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1075 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Config                     1	
X GuessOS                    1	
X MANIFEST                   1	This shipping list
X Makefile                   1	
X README                     1	
X argparse.c                 1	
X conf.h                     1	
X machdep                    1	
X machdep/aix-3.c            2	
X machdep/aos-43.c           3	
X machdep/bsd-43.c           3	
X machdep/bsd-44.c           1	
X machdep/dynix-3.c          2	
X machdep/hpux-70.c          2	
X machdep/hpux-91.c          2	
X machdep/irix-3.c           3	
X machdep/irix-4.c           3	
X machdep/irix-5.c           1	
X machdep/mach-26.c          1	
X machdep/next-2.c           1	
X machdep/osx-4.c            2	
X machdep/sunos-3.c          2	
X machdep/sunos-40.c         1	
X machdep/sunos-41.c         1	
X machdep/sys-5r4.c          2	
X machdep/ultrix-22.c        2	
X machdep/ultrix-4.c         3	
X machdep/umax-42.c          1	
X machdep/umips-21.c         2	
X main.c                     1	
X skill.1                    1	
END_OF_FILE
if test 1075 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(3884 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#
X# $Header: Makefile,v 1.21 1994/07/14 03:20:37 forys Exp $
X#
X# First, find the CONFIGURE comments and set up the "BIN*" and "MAN*"
X# defines according to local customs.  Next, if your operating system
X# is listed below, type "make config" to set OSTYPE, COPTS, and LIBS
X# for your machine.  If the auto-configuration script reports that it
X# failed, look for and fill in the CONFIGURE(Config) comments manually.
X# Now type "make" followed by "make install".
X#
X# Currently supported operating systems include:
X#
X# Vendor	Release		OSTYPE		Notes
X# ------------	--------------	--------------	--------------
X# AT&T/DELL	SVR4		sys-5r4
X# Berkeley	4.2BSD		bsd-43		COPTS= -DNO_UID_T
X# Berkeley	4.3BSD		bsd-43
X# Berkeley	4.4BSD		bsd-44		LIBS= -lkvm
X# CMU		Mach 2.6	mach-26		LIBS= -lsys
X# CMU		Mach 3.0	mach-26
X# DEC		Ultrix 2.2	ultrix-22
X# DEC		Ultrix 4.2	ultrix-4
X# Encore	UMAX 4.2	umax-42		COPTS= -DNO_UID_T
X# HP		HP-UX 6.5	hpux-70		COPTS= -DNO_UID_T
X# HP		HP-UX 7.0	hpux-70
X# HP		HP-UX 8.0-9.1	hpux-90
X# IBM		AIX 3.2		aix-3
X# IBM		AOS 4.3		aos-43
X# MIPS		UMIPS 2.1	umips-21	LIBS= -lmld
X# NeXT		NeXT OS 1.0	mach-26
X# NeXT		NeXT OS 2.1	next-2
X# Pyramid	OSx 4.0		osx-4
X# SGI		Irix 3.3	irix-3		LIBS= -lmld
X# SGI		Irix 4.0.1	irix-4		LIBS= -lmld
X# SGI		Irix 5.2	irix-5
X# Sequent	Dynix 3.1	dynix-3
X# Sun		SunOS 2-3	sunos-3
X# Sun		SunOS 4.0	sunos-40	LIBS= -lkvm
X# Sun		SunOS 4.1	sunos-41	LIBS= -lkvm
X# Sun		SunOS 5.1-3	sys-5r4
X
XDESTDIR=
XSHELL=	/bin/sh
X
X# CONFIGURE: Set location of executable, it's group and mode.
XBINDIR=	/usr/local/bin
XBINGRP=	kmem
XBINMOD=	2755
X
X# CONFIGURE: Set location of man directory and man page suffix.
XMANDIR=	/usr/man/manl
XMANSFX=	l
X
X# CONFIGURE(Config): Select an OSTYPE for your machine from the list above.
XOSTYPE=	sys-5r4
X
X# CONFIGURE(Config): Add any OS-specific options here.
XCOPTS=	
X
X# CONFIGURE(Config): Add any special libraries your system needs.
XLIBS=	
X
XSRCS=	main.c argparse.c getproc.c
XOBJS=	main.o argparse.o getproc.o
XHDRS=	conf.h
X
XCFLAGS=	-O ${COPTS}
X
Xall:	skill
X
Xskill:	${OBJS}
X	${CC} ${CFLAGS} ${OBJS} -o skill ${LIBS}
X
Xgetproc.c:
X	rm -f getproc.c getproc.o
X	ln -s machdep/${OSTYPE}.c getproc.c
X
X${OBJS}: ${HDRS}
X
Xinstall: skill
X#(SysV)	filepriv -d ${DESTDIR}/${BINDIR}/skill
X	rm -f ${DESTDIR}/${BINDIR}/skill ${DESTDIR}/${MANDIR}/skill.${MANSFX}
X	rm -f ${DESTDIR}/${BINDIR}/snice ${DESTDIR}/${MANDIR}/snice.${MANSFX}
X#	install -c -g ${BINGRP} -m ${BINMOD} -s skill ${DESTDIR}/${BINDIR}
X	cp skill ${DESTDIR}/${BINDIR}/skill
X	strip ${DESTDIR}/${BINDIR}/skill
X	chgrp ${BINGRP} ${DESTDIR}/${BINDIR}/skill
X	chmod ${BINMOD} ${DESTDIR}/${BINDIR}/skill
X	ln ${DESTDIR}/${BINDIR}/skill ${DESTDIR}/${BINDIR}/snice
X#(SysV)	filepriv -f dacread ${DESTDIR}/${BINDIR}/skill
X#	install -c -m 644 skill.1 ${DESTDIR}/${MANDIR}/skill.${MANSFX}
X	cp skill.1 ${DESTDIR}/${MANDIR}/skill.${MANSFX}
X	chmod 644 ${DESTDIR}/${MANDIR}/skill.${MANSFX}
X	ln ${DESTDIR}/${MANDIR}/skill.${MANSFX}\
X		${DESTDIR}/${MANDIR}/snice.${MANSFX}
X
Xconfig Config: FRC
X	./Config
X
Xclean:
X	rm -f skill snice *.o [Ee]rrs [Ii][Ee]rrs mklog a.out core getproc.c
X
Xlint:	getproc.c
X	lint ${COPTS} ${SRCS} ${LIBS}
X
XFRC:
X
Xdepend: ${SRCS}
X	for i in ${SRCS}; do \
X	    cc -M ${COPTS} $$i | sed 's/\.o//' | \
X	    awk ' { if ($$1 != prev) \
X		{ if (rec != "") print rec; rec = $$0; prev = $$1; } \
X		else { if (length(rec $$2) > 78) { print rec; rec = $$0; } \
X		else rec = rec " " $$2 } } \
X		END { print rec } ' >> makedep; done
X	echo '/^# DO NOT DELETE THIS LINE/+2,$$d' >eddep
X	echo '$$r makedep' >>eddep
X	echo 'w' >>eddep
X	cp Makefile Makefile.bak
X	ed - Makefile < eddep
X	rm eddep makedep
X	echo '# DEPENDENCIES MUST END AT END OF FILE' >> Makefile
X	echo '# IF YOU PUT STUFF HERE IT WILL GO AWAY' >> Makefile
X	echo '# see make depend above' >> Makefile
X
X# DO NOT DELETE THIS LINE -- make depend uses it
X
X# DEPENDENCIES MUST END AT END OF FILE
X# IF YOU PUT STUFF HERE IT WILL GO AWAY
X# see make depend above
END_OF_FILE
if test 3884 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(7966 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X$Header: README,v 1.25 1994/07/14 03:19:56 forys Exp $
X
X	`skill' is a program which sends signals to processes given
Xany combination of user names, ttys, commands, and pids.  `snice' is
Xa program which changes the priority of processes (given the same).
XIt's actually one program which examines argv to determine what action
Xis to be taken on matching processes.  It is similar to kill(1) and
Xrenice(8), however the command line is completely order independent.
XThere are also verbose, search, and interactive modes of operation.
X
XThe name `skill' stems from `SuperKILL', but if you use it under `csh',
Xyou may discover another reason for calling it `skill' (hint "s!!").
X
XBoth programs run under a variety of operating systems, including:
X
X	AT&T/DELL SysVR4
X	4.2BSD, 4.3BSD, 4.4BSD (and many PC variants)
X	Mach 2.6, 3.0
X	DEC Ultrix 2.2, 4.1-2
X	Encore UMAX 4.2
X	HP-UX 6.5, 7.0, 8.0, 9.0-1
X	IBM AIX 3.1-2
X	IBM AOS 4.3
X	MIPS UMIPS 2.1
X	NeXT OS 1.0, 2.1
X	Pyramid OSx 4.0
X	SGI Irix 3.3, 4.0, 5.2
X	Sequent Dynix 3.0-1
X	SunOS 2, 3, 4.0-1, 5.0-3
X
XConsult the Makefile for more information on what needs to be done
Xto make this program run under the aforementioned operating systems.
XIn general, given a particular OSTYPE, previous releases up to that
XOSTYPE should work as well.  For example, OSTYPE "sunos-3" should
Xsupport "sunos-2" and "sunos-3", but not "sunos-40" or "sunos-41".
XIf you find that an OSTYPE supports a later release of an operating
Xsystem, please drop me a note so I can update the OSTYPE.
X
XOn some SVR4 machines, you need to do "filepriv -f dacread skill" to
Xallow skill/snice to safely read all processes from "/proc".  Support
Xfor this is provided in the Makefile, however you must uncomment the
Xtwo "#SysV" lines yourself.  Do not worry if you don't have "filepriv",
Xboth programs will still function effectively without it.  At any
Xrate, do not install either program setuid root unless you *really*
Xtrust your user community!
X
XDale Wyttenbach <wytten@commissions.leg.state.mn.us> noted that with
Xa slight modification (strcmp() -> strstr()), one can use this simple
Xshell script to allow skill/snice to autoconfigure at run-time:
X	#!/bin/sh
X	exec $0-`uname -m` "$@"
XWhere the actual executables/scripts might be named:
X	-rwxr-xr-x  [...]   195 Feb 23 09:44 skill*
X	-rwxr-sr-x  [...] 24576 Feb 23 09:34 skill-sun4*
X	-rwxr-sr-x  [...] 24576 Feb 23 09:34 skill-sun4c*
X	-rwxr-sr-x  [...] 24576 Feb 23 09:36 skill-sun4m*
X	lrwxrwxrwx  [...]     5 Feb 23 09:42 snice -> skill*
X	lrwxrwxrwx  [...]    10 Feb 23 09:28 snice-sun4 -> skill-sun4*
X	lrwxrwxrwx  [...]    11 Feb 23 09:28 snice-sun4c -> skill-sun4c*
X	lrwxrwxrwx  [...]    11 Feb 23 09:28 snice-sun4m -> skill-sun4
XTo allow sites the option of doing this, machine-dependent code should
Xbe written to use strstr() when checking the program name; the cost in
Xexecution time is certainly minimal.  However, as not all C-libraries
Xprovide strstr(), you may be able to do this only on the more recent
Xoperating systems (or, pick up a free copy of strstr() from somewhere).
X
XPorting this program to other operating systems can be trivial, or
Xseemingly impossible.  If you plan on porting skill to your machine,
Xthe machine-dependent directory (machdep) is a good place to start
Xas you may find an operating system similar to what you are running.
XAnother good source of information is the ps(1) source, however be
Xsure that you do not include any proprietary code.  Also, more and
Xmore OS vendors are providing an easy-to-use library interface to
Xretrieve process information from the kernel, or via "/proc".
XFinally, if none of this is applicable to your situation, you can
Xoften find out all you need to know by plowing through your include
Xfiles, and using the "strings" program on binaries (e.g. to find any
Xunique kernel variables that need to be nlist'd).
X
XIn summary, the machine-independent code expects 5 things from the
Xmachine-dependent code:
X
X	SigMap[]      - Mapping of signal numbers to signal names.
X	NSig          - The total number of signals available.
X	MdepInit(pn)  - Declares/initializes global variables (MyPid,
X			MyUid, ProgName, Skill, PrioMin, PrioMax, SigPri),
X			changes working directory to tty dev dir, and
X			possibly raises priority of process.  This routine
X			can usually be copied intact from an existing
X			machine-dependent file.
X	MdepAction(p) - Carries out an action (kill or renice) on a
X			specific process id.  This is trivial and can
X			usually be copied as well.
X	GetProc()     - A routine that returns processes, one at-a-time
X			in the form of a "struct ProcInfo".  This is,
X			by far, where you will spend most of your time.
X
XOn some operating systems, the machine-dependent module may be unable
Xto examine processes belonging to other users.  This generally occurs
Xon some SVR4 machines with a "/proc" file system; when executed without
Xspecial privileges, skill/snice can only open(2) processes which belong
Xto a particular user.  While not really a problem, the machine-dependent
Xdriver must keep track of these failed open(2)'s by incrementing the
Xexternal integer "MissedProcCnt" (see the SysVR4 module for an example).
X
XAfter you have completed/tested the above (make sure you test for
Xboth in-core and swapped-out processes; see ps(1) for details), you
Xneed to come up with an OSTYPE (for the Makefile).  The scheme I
Xchose was the catenation of the Operating System and Release, in
Xthe form "<os>-<release>".  Then, name your machine-dependent file
X"machdep/<os>-<release>.c".  Also, look at the "GuessOS" and "Config"
Xscripts and figure out a clever way to discern your operating system
Xfrom all the other ones.  Finally, when you feel you are finished,
Xplease send all your changes back to me!
X
XI helped Tom Christiansen shake out some of the bugs in a perl version
Xof skill/snice.  While not included here, the perl version is easier
Xto port to certain operating systems (i.e. those still lacking an easy
Xmeans for gathering process information).  However, the perl version
Xgives away a great deal in terms of size and speed; not only does it
Xinvoke "perl", but also "ps" before it can act on a process.  This will
Xmake it more difficult to catch run-away processes, and on some systems,
Xlaunching a large program can cause "ps" to display invalid process
Xinformation (since the OS may start paging process u-area's around).
X
XThe latest release of skill/snice is available from jaguar.cs.utah.edu
X[155.99.212.101] via anonymous ftp, in "~ftp/pub/skill".
X
X					Jeff Forys
X					NEC Systems Laboratory, Inc.
X					+1 609 734 6074
X					jeff@forys.cranbury.nj.us
X
X===========================================================================
XThe list of people who have contributed to this program continues to
Xgrow.  The following people have ported skill/snice to run on their
Xoperating system, or have otherwise helped in making this program what
Xis is today.
X
XJohn LoVerso <john@loverso.southborough.ma.us>
X	- Asked me to make 4.2BSD talkd work between byte-mismatched
X	  machines; I then wrote skill to kill the talk daemon.
X
XDon Gworek <gworek@fa.disney.com>
X	- Kept telling me that skill was a useful program.
X
XGeorge Howlett <gah@mhcnet.att.com>
X	- Originally designed for super-users, George explained that
X	  skill could be useful to any user.  He was right.
X
XUsenet <net.sources>
X	- Skill, Version 1.9, was posted on April 16, 1986.
X
XDavid Muir Sharnoff <muir@ucbvax.berkeley.edu>
X	- Added `snice'.
X
XGreg Earle <earle@isolar.Tujunga.CA.US>
X	- SunOS 4.0 and 4.1 support.
X
XGorodecki Tom <tom@taux01.nsc.com>
X	- Dynix 3.0 support.
X
XChristos Zoulas <christos@deshaw.com>
X	- HP-UX 6.5 and 8.0/9.0 support.
X	- AOS4.3 (ibm-rt) support.
X	- Misc bug fixes.
X
XMike Hibler <mike@cs.utah.edu>
X	- HP300/BSD support.
X
XRic Anderson <ric@cs.arizona.edu>
X	- Ultrix 4 support.
X	- NeXT OS 2.x support.
X	- System-V support.
X	- Auto-configuration (GuessOS, Configure).
X	- Misc bug fixes.
X
XJay Lepreau <lepreau@cs.utah.edu>
X	- Gave me 4 days to polish up Version 3.
END_OF_FILE
if test 7966 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'argparse.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'argparse.c'\"
else
echo shar: Extracting \"'argparse.c'\" \(7355 characters\)
sed "s/^X//" >'argparse.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char rcsid[] = "$Header: argparse.c,v 1.7 1994/06/26 04:09:17 forys Exp $";
X#endif
X
X/*
X**  This program may be freely redistributed for noncommercial purposes.
X**  This entire comment MUST remain intact.
X**
X**  Copyright 1994 by Jeff Forys (jeff@forys.cranbury.nj.us)
X*/
X
X#define	NO_AEXTERN
X#include "conf.h"
X#undef	NO_AEXTERN
X
X#include <stdio.h>
X#include <ctype.h>
X#include <pwd.h>
X
X/*
X *  Define/initialize linked lists of user supplied things.
X */
Xtty_T	*TtyList = NULL;		/* list of ttys */
Xuid_T	*UidList = NULL;		/* list of user id's */
Xpid_T	*PidList = NULL;		/* list of process id's */
Xcmd_T	*CmdList = NULL;		/* list of commands */
Xint	TtyIndx = 0, UidIndx = 0, PidIndx = 0, CmdIndx = 0;
Xint	Fflag = 0, Iflag = 0, Nflag = 0, Vflag = 0, Wflag = 0;
X
X/*
X * ArgParse(argc, argv)
X *
X * Destructively parse argv[] into appropriate global variables.
X */
Xvoid
XArgParse(argc, argv)
X	int argc;
X	char *argv[];
X{
X	extern int atoi();
X	extern char *calloc();
X	struct passwd *pp;
X	struct stat st;
X	int argcnt = argc;	/* saved so ALLOC() knows max mem to allocate */
X	int haveno = 0;		/* set when we get a signal or priority */
X	int help, argloop;
X
X#define	ALLOC(cnt,type,loc,nstr)					\
X	if ((loc = (type) calloc((unsigned)cnt,sizeof(type))) == NULL)	\
X		Exceed(nstr)
X
X	/*
X	 * This is the main argument parsing loop.  At first glance
X	 * this may look confusing.  We destructively move across
X	 * arguments by incrementing that which "*argv" points to.
X	 *
X	 * Basically, for each argument, we first check if we have a
X	 * flag (flags are preceded by a `-').  If so, then we enter
X	 * the flag loop, processing each character until we reach
X	 * end of string, or we hit a flag that requires special
X	 * processing (i.e. any of "ltucp", "SIGNO", or "PRIORITY").
X	 *
X	 * Second, we check for the special case flag, "+PRIORITY".
X	 * Finally, if we do not have a flag, we simply go on to the
X	 * argument classification phase.  This is where we decide
X	 * if a string represents a tty, a user name, a process id,
X	 * or a command.
X	 *
X	 * If at any time something incomprehensible is unearthed,
X	 * we call Usage(), who in turn calls exit().  Using "-l" also
X	 * forces an immediate exit() (through ListSigs() or Usage()).
X	 */
X	while (--argc > 0) {		/* for each argument */
X		help = 0;
X		if (**(++argv) == '-') {	/* found a flag */
X		    do {
X			argloop = 0;
X			switch (*++(*argv)) {
X			    case 'l':
X				if (Skill)
X					ListSigs();
X				else
X					Usage(E_USAGE);
X				/*NOTREACHED*/
X				break;
X			    case 'f':	/* fast mode (if possible) */
X				Fflag++;
X				argloop++;	/* look for more flags */
X				break;
X			    case 'i':	/* interactive mode */
X				Iflag++;
X				argloop++;	/* look for more flags */
X				break;
X			    case 'v':	/* verbose mode */
X				Vflag++;
X				argloop++;	/* look for more flags */
X				break;
X			    case 'w':	/* display warning messages */
X				Wflag++;
X				argloop++;	/* look for more flags */
X				break;
X			    case 'n':	/* display pid's (do not act on them) */
X				Nflag++;
X				argloop++;	/* look for more flags */
X				break;
X			    case 't':
X			    case 'u':
X			    case 'c':
X			    case 'p':
X				help = **argv;
X				break;
X			    default:
X				/*
X				 * This code is kind of gnarly.  The user
X				 * may specify "-SIGNO" or "-PRIORITY"
X				 * (depending on what we are doing).  This
X				 * is further complicated by the fact that
X				 * SIGNO may be the signal *name*.  The
X				 * special case of "+PRIORITY" is handled
X				 * outside this switch() statement.
X				 */
X				if (haveno)
X					Usage(E_USAGE);
X
X				if (isdigit(**argv)) {
X					if (Skill) {
X						SigPri = atoi(*argv);
X						if (SigPri < 0 || SigPri > NSig)
X							Usage(E_SIGNO);
X					} else {
X						SigPri = -atoi(*argv);
X						if (SigPri < PrioMin)
X							SigPri = PrioMin;
X					}
X					haveno++;
X				} else if (!Skill) {
X					Usage(E_USAGE);
X				} else for (SigPri=0; SigPri <= NSig; SigPri++)
X					if (STREQU(SigMap[SigPri], *argv)) {
X						haveno++;
X						break;
X					}
X				if (!haveno) {
X					fprintf(stderr, "%s: Unknown signal (%s); %s -l lists signals.\n",
X					        ProgName, *argv, ProgName);
X					exit(EX_UERR);
X				}
X				break;
X			}
X		    } while (argloop && *(*argv+1) != '\0');
X
X		    /*
X		     * There can be no more flags in this string.  If the
X		     * help variable was not set, we can short-circuit the
X		     * remainder of the argument processing and move on to
X		     * the next argument.
X		     */
X		    if (!help)			/* go to next arg */
X			continue;
X		} else if (!Skill && **argv == '+') {	/* "+priority" */
X			++(*argv);
X			if (isdigit(**argv)) {
X				SigPri = atoi(*argv);
X				if (SigPri > PrioMax)
X					SigPri = PrioMax;
X				haveno++;
X				continue;	/* go to next arg */
X			}
X			Usage(E_USAGE);	/* dopey priority: usage error */
X		}
X
X		/*
X		 * At this point, all we have left are ttys, user names,
X		 * processes id's, and commands.  If we have `help', our
X		 * job is easy; otherwise we have to hunt for things.
X		 */
X		if (help && !(*++(*argv) || (--argc && *++argv)))
X			Usage(E_USAGE);	/* no arg following flag */
X
X		if (!help || help == 't') {	/* tty? */
X			if (stat(*argv,&st)>=0&&(st.st_mode&S_IFMT)==S_IFCHR) {
X				if (TtyIndx == 0)
X					ALLOC(argcnt, tty_T *, TtyList, "tty");
X				*(TtyList + TtyIndx++) = st.st_rdev;
X				help = -1;
X			} else if (help)
X				Not(*argv, "tty");
X		}
X
X		if (!help || help == 'u') {	/* user name? */
X 			if ((pp=getpwnam(*argv)) != NULL) {
X				if (UidIndx == 0)
X					ALLOC(argcnt, uid_T *, UidList, "user");
X				*(UidList + UidIndx++) = pp->pw_uid;
X				help = -1;
X			} else if (help)
X				Not(*argv, "user name");
X		}
X
X		if (!help || help == 'p') {	/* process id? */
X			if (isdigit(**argv)) {
X				if (PidIndx == 0)
X					ALLOC(argcnt, pid_T *, PidList, "pid");
X				*(PidList + PidIndx++) = atoi(*argv);
X				help = -1;
X			} else if (help)
X				Not(*argv, "process id");
X		}
X
X		if (help > -1) {		/* default: it's a command */
X			if (CmdIndx == 0)
X				ALLOC(argcnt, cmd_T *, CmdList, "command");
X			*(CmdList + CmdIndx++) = *argv;
X		}
X	}
X
X	if (TtyIndx == 0 && UidIndx == 0 && PidIndx == 0 && CmdIndx == 0)
X		Usage(E_USAGE);
X
X	/*
X	 *  If this is not the superuser and no specific users were
X	 *  mentioned, we assume they only want to deal with their
X	 *  own processes.  This cuts down on error messages since
X	 *  the general user is not usually allowed to modify the
X	 *  state of other users' processes.
X	 */
X	if (UidIndx == 0 && MyUid != ROOTUID) {
X		ALLOC(1, uid_T *, UidList, "user");
X		*(UidList + UidIndx++) = MyUid;
X	}
X#undef	ALLOC
X}
X
X/*
X * ListSigs()
X *
X * Display a list of available signals and exit.
X */
Xvoid
XListSigs()
X{
X	register int signo;
X	register int didprint = 0;
X
X	for (signo = 1; signo <= NSig; signo++)
X		if (!isdigit(*SigMap[signo])) {
X			printf("%s%c", SigMap[signo],	/* 16 signals/line */
X			       (++didprint % 16) == 0? '\n': ' ');
X		}
X
X	if ((didprint % 16) != 0)
X		(void) putc('\n', stdout);
X
X	exit(EX_OKAY);
X}
X
X/*
X * Not(thought, this)
X *
X * The user incorrectly forced a type (e.g. "-u tty00").
X * Display an error message and exit.
X */
Xvoid
XNot(thought, this)
X	char *thought, *this;
X{
X	fprintf(stderr, "%s: %s: not a %s\n", ProgName, thought, this);
X	exit(EX_UERR);
X}
X
X/*
X * Exceed(what)
X *
X * Ran out of memory allocating space for `what'.
X */
Xvoid
XExceed(what)
X	char *what;
X{
X	fprintf(stderr, "%s: out of memory (can't alloc %s)\n", ProgName, what);
X	exit(EX_SERR);
X}
END_OF_FILE
if test 7355 -ne `wc -c <'argparse.c'`; then
    echo shar: \"'argparse.c'\" unpacked with wrong size!
fi
# end of 'argparse.c'
fi
if test -f 'conf.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'conf.h'\"
else
echo shar: Extracting \"'conf.h'\" \(2623 characters\)
sed "s/^X//" >'conf.h' <<'END_OF_FILE'
X/* $Header: conf.h,v 1.11 1994/06/26 04:10:16 forys Exp $ */
X
X/*
X**  This program may be freely redistributed for noncommercial purposes.
X**  This entire comment MUST remain intact.
X**
X**  Copyright 1994 by Jeff Forys (jeff@forys.cranbury.nj.us)
X*/
X
X#include <sys/param.h>
X#ifdef	NO_TYPES_INC		/* normally, <sys/param.h> includes this */
X#include <sys/types.h>
X#endif
X#include <sys/stat.h>
X#include <sys/signal.h>
X
X/*
X * Set up common typedef's.
X */
X#ifdef	NO_UID_T		/* "uid_t" arrived 20 months after 4.2BSD */
Xtypedef	int	uid_T;		/* uids */
X#else
Xtypedef	uid_t	uid_T;		/* uids */
X#endif
Xtypedef	dev_t	tty_T;		/* ttys (actually, device numbers) */
Xtypedef	int	pid_T;		/* process id's */
Xtypedef	char *	cmd_T;		/* commands */
X
X/*
X * Error codes used by Usage().
X */
X#define	E_USAGE	1		/* generic usage error */
X#define	E_PRIOR	2		/* priority out of range */
X#define	E_SIGNO	3		/* invalid signal number */
X
X/*
X * Error codes used by exit().
X */
X#define	EX_OKAY	0		/* success */
X#define	EX_UERR	1		/* user error */
X#define	EX_SERR	2		/* system error */
X
X/*
X * Miscellaneous #define's.
X */
X#define	ROOTUID	0		/* super-user's UID */
X#define	ROOTUSR	"root"		/* what the Super-user likes to be called */
X
X#define STREQU(s1,s2)		((*s1 == *s2) && (strcmp(s1,s2) == 0))
X#define STRNEQU(s1,s2,n)	((*s1 == *s2) && (strncmp(s1,s2,n) == 0))
X
X/*
X * This is all we need/want to know about a process.  The machine-dependent
X * routine GetProc() returns a "struct ProcInfo" pointer (or NULL if no more
X * processes).
X */
Xstruct ProcInfo {
X	int	pi_flags;	/* various flags (see below) */
X	cmd_T	pi_cmd;		/* pointer to path-stripped command name */
X	pid_T	pi_pid;		/* process id */
X	uid_T	pi_uid;		/* user id of process */
X	tty_T	pi_tty;		/* controlling tty */
X};
X
X/* pi_flags */
X#define	PI_CTLTTY	0x01	/* has a controlling tty ("pi_tty" valid) */
X#define	PI_ZOMBIE	0x02	/* is a zombie */
X#define	PI_SWEXIT	0x04	/* is in the process of exiting */
X#define	PI_ASKUSR	0x10	/* check with user before doing anything */
X
X#ifndef	NO_AEXTERN		/* external variables (from "argparse.c") */
Xextern	tty_T	*TtyList;
Xextern	uid_T	*UidList;
Xextern	pid_T	*PidList;
Xextern	cmd_T	*CmdList;
Xextern	int	TtyIndx, UidIndx, PidIndx, CmdIndx;
Xextern	int	Fflag, Iflag, Nflag, Vflag, Wflag;
X#endif	/* NO_AEXTERN */
X
X#ifndef	NO_MEXTERN		/* external variables (machine-dependent) */
Xextern	char	*SigMap[];
Xextern	int	NSig, Skill, PrioMin, PrioMax, SigPri;
Xextern	pid_T	MyPid;
Xextern	uid_T	MyUid;
Xextern	char	*ProgName;
Xextern	int	MdepAction();
Xextern	struct ProcInfo *GetProc();
X#endif	/* NO_MEXTERN */
X
Xvoid MdepInit(), ArgParse(), ListSigs(), Usage(), Not(), Exceed();
END_OF_FILE
if test 2623 -ne `wc -c <'conf.h'`; then
    echo shar: \"'conf.h'\" unpacked with wrong size!
fi
# end of 'conf.h'
fi
if test ! -d 'machdep' ; then
    echo shar: Creating directory \"'machdep'\"
    mkdir 'machdep'
fi
if test -f 'machdep/bsd-44.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machdep/bsd-44.c'\"
else
echo shar: Extracting \"'machdep/bsd-44.c'\" \(6027 characters\)
sed "s/^X//" >'machdep/bsd-44.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char rcsid[] = "$Header: bsd-44.c,v 1.11 1994/06/26 04:20:08 forys Exp $";
X#endif
X
X/*
X**  This program may be freely redistributed for noncommercial purposes.
X**  This entire comment MUST remain intact.
X**
X**  Copyright 1994 by Jeff Forys (jeff@forys.cranbury.nj.us)
X*/
X
X#define	NO_MEXTERN
X#include "conf.h"
X#undef	NO_MEXTERN
X
X#include <sys/user.h>
X#include <sys/proc.h>
X
X#include <stdio.h>
X
X#ifndef	P_WEXIT		/* backward compatibility */
X#define	P_WEXIT	SWEXIT
X#endif
X
X/*
X * Define SigNames, NSig, and TtyDevDir here; they are used by other
X * routines and must be global.  Everyone seems to have their own
X * idea as to what NSIG should be.  Here, `NSig' is the number of
X * signals available, not counting zero.
X */
Xchar *SigMap[] = { "0",
X	"HUP", "INT", "QUIT", "ILL", "TRAP", "ABRT",		/*  1 -  6 */
X	"EMT", "FPE", "KILL", "BUS", "SEGV", "SYS",		/*  7 - 12 */
X	"PIPE", "ALRM", "TERM", "URG", "STOP", "TSTP",		/* 13 - 18 */
X	"CONT", "CHLD", "TTIN", "TTOU", "IO", "XCPU",		/* 19 - 24 */
X	"XFSZ", "VTALRM", "PROF", "WINCH", "INFO", "USR1",	/* 25 - 30 */
X	"USR2", "32",						/* 31 - 32 */
X};
Xint NSig = NSIG;
X
X#define	SETCMD(dst,src,maxlen) {			\
X	extern char *rindex();				\
X	if (maxlen > 0) src[maxlen] = '\0';		\
X	dst = (dst = rindex(src, '/')) ? ++dst: src;	\
X}
X
Xstatic char *TtyDevDir = "/dev";
X
Xint	Skill;			/* set 1 if running `skill', 0 if `snice' */
Xint	PrioMin, PrioMax;	/* min and max process priorities */
Xint	SigPri;			/* signal to send or priority to set */
Xpid_T	MyPid;			/* pid of this process */
Xuid_T	MyUid;			/* uid of this process */
Xchar	*ProgName;		/* program name */
X
X/*
X * This is the machine-dependent initialization routine.
X *
X *   - The following global variables must be initialized:
X *     MyPid, MyUid, ProgName, Skill, PrioMin, PrioMax, SigPri
X *   - The working directory will be changed to that which contains the
X *     tty devices (`TtyDevDir'); this makes argument parsing go faster.
X *   - If possible, this routine should raise the priority of this process.
X */
Xvoid
XMdepInit(pname)
X	char *pname;
X{
X	extern char *rindex(), *SysErr();
X
X	MyPid = (pid_T) getpid();
X	MyUid = (uid_T) getuid();
X	SETCMD(ProgName, pname, 0)
X
X	/*
X	 * If we are running as root, raise our priority to better
X	 * catch runaway processes.
X	 */
X	if (MyUid == ROOTUID)
X		(void) setpriority(PRIO_PROCESS, MyPid, PRIO_MIN);
X
X	/*
X	 * Determine what we are doing to processes we find.  We will
X	 * either send them a signal (skill), or renice them (snice).
X	 */
X	Skill = (strstr(ProgName, "snice") == NULL);
X
X	/*
X	 * chdir to `TtyDevDir' to speed up tty argument parsing.
X	 */
X	if (chdir(TtyDevDir) < 0) {
X		fprintf(stderr, "%s: chdir(%s): %s\n", ProgName, TtyDevDir,
X		        SysErr());
X		exit(EX_SERR);
X	}
X
X	/*
X	 * Set up minimum and maximum process priorities.
X	 * Initialize SigPri to either default signal (`skill') or
X	 * default priority (`snice').
X	 */
X	PrioMin = PRIO_MIN;
X	PrioMax = PRIO_MAX;
X	SigPri = Skill? SIGTERM: 4;
X}
X
X/*
X * Carry out an action on a particular process.  If this is `skill',
X * then send the process a signal, otherwise this is `snice' so change
X * it's priority.
X *
X * If 0 is returned, the operation was successful, otherwise -1 is
X * returned and `errno' set.
X */
Xint
XMdepAction(pid)
X	pid_T pid;
X{
X	if (Skill)
X		return(kill((int)pid, SigPri));
X	else
X		return(setpriority(PRIO_PROCESS, (int)pid, SigPri));
X}
X
X/*
X * Now, set up everything we need to write a GetProc() routine.
X */
X
X#include <kvm.h>
X#include <fcntl.h>
X
X#if defined(BSD4_4) && (BSD < 199306)
X#include <sys/kinfo.h>
X#include <sys/kinfo_proc.h>
X#define	_ALLPROCFLAG	KINFO_PROC_ALL
X#else
X#include <sys/sysctl.h>
X#define	_ALLPROCFLAG	KERN_PROC_ALL
X#endif
X
Xstatic	char	*pidmap[] = { "swapper", "init", "pagedaemon" };
Xstatic	int	pidmapsiz = sizeof(pidmap) / sizeof(pidmap[0]);
X
Xextern	off_t lseek();
X
X#define	PROC(kprocp)	kprocp->kp_proc
X#define	EPROC(kprocp)	kprocp->kp_eproc
X
X/*
X * GetProc()
X *
X * Fill in and return a `struct ProcInfo' with information about the
X * next process.  If no processes are left, return NULL.
X */
Xstruct ProcInfo *
XGetProc()
X{
X	static struct ProcInfo procinfo;
X	static int nproc = -1;
X	static struct kinfo_proc *aproc;
X	static kvm_t *kd = NULL;
X	char errbuf[256];
X
X	/*
X	 * If this is our first time here, prepare to read procs from kernel.
X	 */
X	if (nproc == -1) {
X		kd = kvm_openfiles((char *)NULL, (char *)NULL, (char *)NULL,
X		                   O_RDONLY, errbuf);
X		if (kd == NULL) {
X			fprintf(stderr, "%s: %s\n", ProgName, errbuf);
X			exit(EX_SERR);
X		}
X
X		if ((aproc=kvm_getprocs(kd, _ALLPROCFLAG, 0, &nproc)) == NULL) {
X			fprintf(stderr, "%s: %s\n", ProgName, kvm_geterr(kd));
X			exit(EX_SERR);
X		}
X	}
X
X	if (nproc == 0) {
X		if (kd != NULL) {
X			kvm_close(kd);
X			kd = NULL;
X		}
X		return((struct ProcInfo *)NULL);
X	}
X
X	do {
X		if (PROC(aproc).p_stat != 0) {
X			/*
X			 * Make sure this isn't a "zombie" or "exiting"
X			 * process.  If it is, fill in procinfo and return.
X			 */
X			procinfo.pi_flags = 0;
X			procinfo.pi_pid = (pid_T) PROC(aproc).p_pid;
X			procinfo.pi_uid = (uid_T) EPROC(aproc).e_ucred.cr_uid;
X
X			if (PROC(aproc).p_stat == SZOMB) {	/* zombie */
X				static char *zombie = "<defunct>";
X				procinfo.pi_flags |= PI_ZOMBIE;
X				procinfo.pi_cmd = zombie;
X			} else if (PROC(aproc).p_flag & P_WEXIT) { /* exiting */
X				static char *exiting = "<exiting>";
X				procinfo.pi_flags |= PI_SWEXIT;
X				procinfo.pi_cmd = exiting;
X			}
X
X			if (procinfo.pi_flags) {
X				nproc--;
X				aproc++;
X				return(&procinfo);
X			}
X		}
X	} while (PROC(aproc).p_stat == 0);
X
X	/*
X	 * We now have a process (`aproc').
X	 * Fill in the rest of `procinfo'.
X	 */
X	if (EPROC(aproc).e_tdev != NODEV) {	/* controlling tty */
X		procinfo.pi_flags |= PI_CTLTTY;
X		procinfo.pi_tty = (tty_T) EPROC(aproc).e_tdev;
X	}
X
X	if (PROC(aproc).p_pid < pidmapsiz) {	/* special */
X		procinfo.pi_cmd = pidmap[PROC(aproc).p_pid];
X		procinfo.pi_flags |= PI_ASKUSR;
X	} else				 /* set path-stripped command name */
X		SETCMD(procinfo.pi_cmd, PROC(aproc).p_comm, MAXCOMLEN)
X
X	nproc--;
X	aproc++;
X	return(&procinfo);
X}
END_OF_FILE
if test 6027 -ne `wc -c <'machdep/bsd-44.c'`; then
    echo shar: \"'machdep/bsd-44.c'\" unpacked with wrong size!
fi
# end of 'machdep/bsd-44.c'
fi
if test -f 'machdep/irix-5.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machdep/irix-5.c'\"
else
echo shar: Extracting \"'machdep/irix-5.c'\" \(5626 characters\)
sed "s/^X//" >'machdep/irix-5.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char rcsid[] = "$Header: irix-5.c,v 1.1 1994/06/25 02:40:08 forys Exp $";
X#endif
X
X/*
X**  This program may be freely redistributed for noncommercial purposes.
X**  This entire comment MUST remain intact.
X**
X**  Copyright 1994 by Jeff Forys (jeff@forys.cranbury.nj.us)
X*/
X
X
X#define	NO_MEXTERN
X#include "conf.h"
X#undef	NO_MEXTERN
X
X#include <sys/user.h>
X#include <sys/proc.h>
X#include <sys/resource.h>
X
X#include <stdio.h>
X#include <dirent.h>
X
Xextern int MissedProcCnt;
X
X/*
X * Define SigNames, NSig, and TtyDevDir here; they are used by other
X * routines and must be global.  Everyone seems to have their own
X * idea as to what NSIG should be.  Here, `NSig' is the number of
X * signals available, not counting zero.
X */
Xchar *SigMap[] = { "0",
X	"HUP", "INT", "QUIT", "ILL", "TRAP", "ABRT",		/*  1 -  6 */
X	"EMT", "FPE", "KILL", "BUS", "SEGV", "SYS",		/*  7 - 12 */
X	"PIPE", "ALRM", "TERM", "USR1", "USR2", "CHLD",		/* 13 - 18 */
X	"PWR", "WINCH", "URG", "POLL", "STOP", "TSTP",		/* 19 - 24 */
X	"CONT", "TTIN", "TTOU", "VTALRM", "PROF", "XCPU",	/* 25 - 30 */
X	"XFSZ", "32", "33", "34", "35", "36",			/* 31 - 36 */
X        "37", "38", "39", "40", "41", "42",			/* 37 - 42 */
X        "43", "44", "45", "46", "47", "48",			/* 43 - 48 */
X        "49", "50", "51", "52", "53", "54",			/* 49 - 54 */
X        "55", "56", "57", "58", "59", "60",			/* 55 - 60 */
X        "61", "62", "63", "64",					/* 61 - 64 */
X};
Xint NSig = NUMSIGS;
X
X#define	SETCMD(dst,src,maxlen) {			\
X	extern char *strrchr();				\
X	if (maxlen > 0) src[maxlen] = '\0';		\
X	dst = (dst = strrchr(src, '/')) ? ++dst: src;	\
X}
X
Xstatic char *TtyDevDir = "/dev";
X
Xint	Skill;			/* set 1 if running `skill', 0 if `snice' */
Xint	PrioMin, PrioMax;	/* min and max process priorities */
Xint	SigPri;			/* signal to send or priority to set */
Xpid_T	MyPid;			/* pid of this process */
Xuid_T	MyUid;			/* uid of this process */
Xchar	*ProgName;		/* program name */
X
X/*
X * This is the machine-dependent initialization routine.
X *
X *   - The following global variables must be initialized:
X *     MyPid, MyUid, ProgName, Skill, PrioMin, PrioMax, SigPri
X *   - The working directory will be changed to that which contains the
X *     tty devices (`TtyDevDir'); this makes argument parsing go faster.
X *   - If possible, this routine should raise the priority of this process.
X */
X
Xvoid skill_getpri(int *low, int *high);
Xint skill_setpri(pid_t pid,int niceval);
X
Xvoid
XMdepInit(pname)
X	char *pname;
X{
X	extern char *rindex(), *SysErr();
X
X	MyPid = (pid_T) getpid();
X	MyUid = (uid_T) getuid();
X	SETCMD(ProgName, pname, 0)
X
X	/*
X	 * If we are running as root, raise our priority to better
X	 * catch runaway processes.
X	 */
X	if (MyUid == ROOTUID)
X		(void) setpriority(PRIO_PROCESS, MyPid, PRIO_MIN);
X
X	/*
X	 * Determine what we are doing to processes we find.  We will
X	 * either send them a signal (skill), or renice them (snice).
X	 */
X	Skill = (strstr(ProgName, "snice") == NULL);
X
X	/*
X	 * chdir to `TtyDevDir' to speed up tty argument parsing.
X	 */
X	if (chdir(TtyDevDir) < 0) {
X		fprintf(stderr, "%s: chdir(%s): %s\n", ProgName, TtyDevDir,
X		        SysErr());
X		exit(EX_SERR);
X	}
X
X	/*
X	 * Set up minimum and maximum process priorities.
X	 * Initialize SigPri to either default signal (`skill') or
X	 * default priority (`snice').
X	 */
X	PrioMin = PRIO_MIN;
X	PrioMax = PRIO_MAX;
X	SigPri = Skill? SIGTERM: 4;
X}
X
X/*
X * Carry out an action on a particular process.  If this is `skill',
X * then send the process a signal, otherwise this is `snice' so change
X * it's priority.
X *
X * If 0 is returned, the operation was successful, otherwise -1 is
X * returned and `errno' set.
X */
Xint
XMdepAction(pid)
X	pid_T pid;
X{
X	if (Skill)
X		return(kill((int)pid, SigPri));
X	else
X		return(setpriority(PRIO_PROCESS, (int)pid, SigPri));
X}
X
X/*
X * Now, set up everything we need to write a GetProc() routine.
X */
X
X#include <sys/procfs.h>
X
X#include <fcntl.h>
X
Xstatic char *ProcDir =	"/proc/pinfo";		/* proc direcotry */
Xstatic char *ProcFil =	"/proc/pinfo/%s";	/* proc image status's */
X
X/*
X * GetProc()
X *
X * Fill in and return a `struct ProcInfo' with information about the
X * next process.  If no processes are left, return NULL.
X */
Xstruct ProcInfo *
XGetProc()
X{
X	extern char *SysErr();
X	static char *zombie = "<defunct>";
X	static struct ProcInfo procinfo;
X	static DIR *dirfp = NULL;
X	static struct prpsinfo pinfo;
X	struct dirent *dp;
X	char flnm[FILENAME_MAX];
X	int fd;
X
X	/*
X	 * If this is our first time here, open the proc directory,...
X	 */
X	if (dirfp == NULL && (dirfp=opendir(ProcDir)) == NULL) {
X		fprintf(stderr, "%s: %s: %s\n", ProgName, ProcDir, SysErr());
X		exit(EX_SERR);
X	}
X
X	while ((dp = readdir(dirfp)) != NULL) {
X		if (strcmp(dp->d_name,".") == 0 || strcmp(dp->d_name,"..") == 0)
X			continue;
X		(void) sprintf(flnm, ProcFil, dp->d_name);
X		if ((fd = open(flnm, O_RDONLY)) < 0) {
X			MissedProcCnt++;
X			continue;	/* ignore procs we don't own */
X		}
X		if (ioctl(fd, PIOCPSINFO, &pinfo) == -1) {
X			(void) close(fd);
X			continue;	/* ignore these too */
X		}
X		(void) close(fd);
X
X		/*
X		 * Information about a process now resides in 'pinfo'.
X		 */
X		procinfo.pi_flags = 0;
X		procinfo.pi_pid = pinfo.pr_pid;
X		procinfo.pi_uid = pinfo.pr_uid;
X		if (pinfo.pr_zomb != 0) {
X			procinfo.pi_flags |= PI_ZOMBIE;
X			procinfo.pi_cmd = zombie;
X		} else {
X			if (pinfo.pr_pid < 5)	/* low pids are special */
X				procinfo.pi_flags |= PI_ASKUSR;
X			if (pinfo.pr_ttydev != PRNODEV) {
X				procinfo.pi_flags |= PI_CTLTTY;
X				procinfo.pi_tty = pinfo.pr_ttydev;
X			}
X			procinfo.pi_cmd = pinfo.pr_fname;
X		}
X		return(&procinfo);
X	}
X
X	(void) closedir(dirfp);
X	dirfp = NULL;
X	return((struct ProcInfo *)NULL);
X}
END_OF_FILE
if test 5626 -ne `wc -c <'machdep/irix-5.c'`; then
    echo shar: \"'machdep/irix-5.c'\" unpacked with wrong size!
fi
# end of 'machdep/irix-5.c'
fi
if test -f 'machdep/mach-26.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machdep/mach-26.c'\"
else
echo shar: Extracting \"'machdep/mach-26.c'\" \(5653 characters\)
sed "s/^X//" >'machdep/mach-26.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char rcsid[] = "$Header: mach-26.c,v 1.7 1994/06/26 04:16:01 forys Exp $";
X#endif
X
X/*
X**  This program may be freely redistributed for noncommercial purposes.
X**  This entire comment MUST remain intact.
X**
X**  Copyright 1994 by Jeff Forys (jeff@forys.cranbury.nj.us)
X*/
X
X#define	NO_MEXTERN
X#include "conf.h"
X#undef	NO_MEXTERN
X
X#include <sys/user.h>
X#include <sys/proc.h>
X
X#include <stdio.h>
X
X/*
X * Define SigNames, NSig, and TtyDevDir here; they are used by other
X * routines and must be global.  Everyone seems to have their own
X * idea as to what NSIG should be.  Here, `NSig' is the number of
X * signals available, not counting zero.
X */
Xchar *SigMap[] = { "0",
X	"HUP", "INT", "QUIT", "ILL", "TRAP", "IOT",		/*  1 -  6 */
X	"EMT", "FPE", "KILL", "BUS", "SEGV", "SYS",		/*  7 - 12 */
X	"PIPE", "ALRM", "TERM", "URG", "STOP", "TSTP",		/* 13 - 18 */
X	"CONT", "CHLD", "TTIN", "TTOU", "IO", "XCPU",		/* 19 - 24 */
X	"XFSZ", "VTALRM", "PROF", "WINCH", "29", "USR1",	/* 25 - 30 */
X	"USR2", "32",						/* 31 - 32 */
X};
Xint NSig = NSIG;
X
X#define	SETCMD(dst,src,maxlen) {			\
X	extern char *rindex();				\
X	if (maxlen > 0) src[maxlen] = '\0';		\
X	dst = (dst = rindex(src, '/')) ? ++dst: src;	\
X}
X
Xstatic char *TtyDevDir = "/dev";
X
Xint	Skill;			/* set 1 if running `skill', 0 if `snice' */
Xint	PrioMin, PrioMax;	/* min and max process priorities */
Xint	SigPri;			/* signal to send or priority to set */
Xpid_T	MyPid;			/* pid of this process */
Xuid_T	MyUid;			/* uid of this process */
Xchar	*ProgName;		/* program name */
X
X/*
X * This is the machine-dependent initialization routine.
X *
X *   - The following global variables must be initialized:
X *     MyPid, MyUid, ProgName, Skill, PrioMin, PrioMax, SigPri
X *   - The working directory will be changed to that which contains the
X *     tty devices (`TtyDevDir'); this makes argument parsing go faster.
X *   - If possible, this routine should raise the priority of this process.
X */
Xvoid
XMdepInit(pname)
X	char *pname;
X{
X	extern char *rindex(), *SysErr();
X
X	MyPid = (pid_T) getpid();
X	MyUid = (uid_T) getuid();
X	SETCMD(ProgName, pname, 0)
X
X	/*
X	 * If we are running as root, raise our priority to better
X	 * catch runaway processes.
X	 */
X	if (MyUid == ROOTUID)
X		(void) setpriority(PRIO_PROCESS, MyPid, PRIO_MIN);
X
X	/*
X	 * Determine what we are doing to processes we find.  We will
X	 * either send them a signal (skill), or renice them (snice).
X	 */
X	Skill = (strcmp(ProgName, "snice") != 0);
X
X	/*
X	 * chdir to `TtyDevDir' to speed up tty argument parsing.
X	 */
X	if (chdir(TtyDevDir) < 0) {
X		fprintf(stderr, "%s: chdir(%s): %s\n", ProgName, TtyDevDir,
X		        SysErr());
X		exit(EX_SERR);
X	}
X
X	/*
X	 * Set up minimum and maximum process priorities.
X	 * Initialize SigPri to either default signal (`skill') or
X	 * default priority (`snice').
X	 */
X	PrioMin = PRIO_MIN;
X	PrioMax = PRIO_MAX;
X	SigPri = Skill? SIGTERM: 4;
X}
X
X/*
X * Carry out an action on a particular process.  If this is `skill',
X * then send the process a signal, otherwise this is `snice' so change
X * it's priority.
X *
X * If 0 is returned, the operation was successful, otherwise -1 is
X * returned and `errno' set.
X */
Xint
XMdepAction(pid)
X	pid_T pid;
X{
X	if (Skill)
X		return(kill((int)pid, SigPri));
X	else
X		return(setpriority(PRIO_PROCESS, (int)pid, SigPri));
X}
X
X/*
X * Now, set up everything we need to write a GetProc() routine.
X */
X
X#undef	PI_ZOMBIE		/* #define'd in "conf.h" *and* <sys/table.h> */
X#define	PI_ZOMB	3		/* value from "conf.h" (it *wont* change) */
X
X#include <sys/table.h>
X
X#define	NPROCS	32			/* number of procs to read at once */
X
Xextern	off_t lseek();
X
X/*
X * GetProc()
X *
X * Fill in and return a `struct ProcInfo' with information about the
X * next process.  If no processes are left, return NULL.
X */
Xstruct ProcInfo *
XGetProc()
X{
X	extern int errno;
X	extern char *SysErr();
X	static struct tbl_procinfo procs[NPROCS], *procsp;
X	static struct ProcInfo procinfo;
X	register struct tbl_procinfo *aproc;
X	static int procindx = 0;
X	static int thisproc = 0;
X
X	/*
X	 * Read in NPROCS proc structures at-a-time.  Decrement `nproc'
X	 * by the number of proc structures we have read; when it reaches
X	 * zero, we are finished (return NULL).
X	 */
X	do {
X		if (thisproc == 0) {
X			thisproc = table(TBL_PROCINFO, procindx, (char *)procs,
X			                 NPROCS, sizeof(struct tbl_procinfo));
X			if (thisproc <= 0) {
X				if (thisproc != 0 && errno != EINVAL)
X					fprintf(stderr, "%s: read proc: %s\n",
X					        ProgName, SysErr());
X				return((struct ProcInfo *)NULL);
X			}
X			procsp = procs;
X			procindx += thisproc;
X		}
X
X		aproc = procsp++;
X		thisproc--;
X
X		if (aproc->pi_status != PI_EMPTY) {
X			/*
X			 * Make sure this isn't a "zombie" or "exiting"
X			 * process.  If it is, we have all the information
X			 * we need; fill in procinfo and return.
X			 */
X			procinfo.pi_flags = 0;
X			procinfo.pi_pid = (pid_T) aproc->pi_pid;
X			procinfo.pi_uid = (uid_T) aproc->pi_uid;
X
X			if (aproc->pi_status == PI_ZOMBIE) {	/* zombie */
X				static char *zombie = "<defunct>";
X				procinfo.pi_flags |= PI_ZOMB;
X				procinfo.pi_cmd = zombie;
X			} else if (aproc->pi_status == PI_EXITING) {
X				static char *exiting = "<exiting>";
X				procinfo.pi_flags |= PI_SWEXIT;
X				procinfo.pi_cmd = exiting;
X			}
X
X			if (procinfo.pi_flags)
X				return(&procinfo);
X		}
X
X	} while (aproc->pi_status == PI_EMPTY);
X
X	/*
X	 * We now have a process (`aproc').
X	 * Fill in the rest of `procinfo'.
X	 */
X	if (aproc->pi_ttyd != -1) {	/* has a controlling tty */
X		procinfo.pi_flags |= PI_CTLTTY;
X		procinfo.pi_tty = (tty_T) aproc->pi_ttyd;
X	}
X
X	/* set path-stripped command name */
X	SETCMD(procinfo.pi_cmd, aproc->pi_comm, PI_COMLEN)
X
X	return(&procinfo);
X}
END_OF_FILE
if test 5653 -ne `wc -c <'machdep/mach-26.c'`; then
    echo shar: \"'machdep/mach-26.c'\" unpacked with wrong size!
fi
# end of 'machdep/mach-26.c'
fi
if test -f 'machdep/next-2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machdep/next-2.c'\"
else
echo shar: Extracting \"'machdep/next-2.c'\" \(5831 characters\)
sed "s/^X//" >'machdep/next-2.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char rcsid[] = "$Header: next-2.c,v 1.4 1994/06/26 04:18:20 forys Exp $";
X#endif
X
X/*
X**  This program may be freely redistributed for noncommercial purposes.
X**  This entire comment MUST remain intact.
X**
X**  NeXT OS 2.x support by Ric Anderson (ric@cs.arizona.edu)
X**
X**  Copyright 1994 by Jeff Forys (jeff@forys.cranbury.nj.us)
X*/
X
X#define NO_MEXTERN
X#include "conf.h"
X#undef  NO_MEXTERN
X
X#include <sys/user.h>
X#include <sys/proc.h>
X
X#include <stdio.h>
X
X/*
X * Define SigNames, NSig, and TtyDevDir here; they are used by other
X * routines and must be global.  Everyone seems to have their own
X * idea as to what NSIG should be.  Here, `NSig' is the number of
X * signals available, not counting zero.
X */
Xchar *SigMap[] = { "0",
X  "HUP", "INT", "QUIT", "ILL", "TRAP", "IOT",		/*  1 -  6 */
X  "EMT", "FPE", "KILL", "BUS", "SEGV", "SYS",		/*  7 - 12 */
X  "PIPE", "ALRM", "TERM", "URG", "STOP", "TSTP",	/* 13 - 18 */
X  "CONT", "CHLD", "TTIN", "TTOU", "IO", "XCPU",		/* 19 - 24 */
X  "XFSZ", "VTALRM", "PROF", "WINCH", "29", "USR1",	/* 25 - 30 */
X  "USR2", "32"						/* 31 - 32 */
X};
Xint NSig = NSIG;
X
X#define	SETCMD(dst,src,maxlen) {			\
X	extern char *rindex();				\
X	if (maxlen > 0) src[maxlen] = '\0';		\
X	dst = (dst = rindex(src, '/')) ? ++dst: src;	\
X}
X
Xstatic char *TtyDevDir = "/dev";
X
Xint	Skill;			/* set 1 if running `skill', 0 if `snice' */
Xint	PrioMin, PrioMax;	/* min and max process priorities */
Xint	SigPri;			/* signal to send or priority to set */
Xpid_T	MyPid;			/* pid of this process */
Xuid_T	MyUid;			/* uid of this process */
Xchar	*ProgName;		/* program name */
X
X/*
X * This is the machine-dependent initialization routine.
X *
X *   - The following global variables must be initialized:
X *     MyPid, MyUid, ProgName, Skill, PrioMin, PrioMax, SigPri
X *   - The working directory will be changed to that which contains the
X *     tty devices (`TtyDevDir'); this makes argument parsing go faster.
X *   - If possible, this routine should raise the priority of this process.
X */
Xvoid
XMdepInit(pname)
X	char *pname;
X{
X	extern char *rindex(), *SysErr();
X
X	MyPid = (pid_T) getpid();
X	MyUid = (uid_T) getuid();
X	SETCMD(ProgName, pname, 0)
X
X	/*
X	 * If we are running as root, raise our priority to better
X	 * catch runaway processes.
X	 */
X	if (MyUid == ROOTUID)
X		(void) setpriority(PRIO_PROCESS, MyPid, PRIO_MIN);
X
X	/*
X	 * Determine what we are doing to processes we find.  We will
X	 * either send them a signal (skill), or renice them (snice).
X	 */
X	Skill = (strcmp(ProgName, "snice") != 0);
X
X	/*
X	 * chdir to `TtyDevDir' to speed up tty argument parsing.
X	 */
X	if (chdir(TtyDevDir) < 0) {
X		fprintf(stderr, "%s: chdir(%s): %s\n", ProgName, TtyDevDir,
X		        SysErr());
X		exit(EX_SERR);
X	}
X
X	/*
X	 * Set up minimum and maximum process priorities.
X	 * Initialize SigPri to either default signal (`skill') or
X	 * default priority (`snice').
X	 */
X	PrioMin = PRIO_MIN;
X	PrioMax = PRIO_MAX;
X	SigPri = Skill? SIGTERM: 4;
X}
X
X/*
X * Carry out an action on a particular process.  If this is `skill',
X * then send the process a signal, otherwise this is `snice' so change
X * it's priority.
X *
X * If 0 is returned, the operation was successful, otherwise -1 is
X * returned and `errno' set.
X */
Xint
XMdepAction(pid)
X	pid_T pid;
X{
X	if (Skill)
X		return(kill((int)pid, SigPri));
X	else
X		return(setpriority(PRIO_PROCESS, (int)pid, SigPri));
X}
X
X/*
X * Now, set up everything we need to write a GetProc() routine.
X */
X
X#undef  PI_ZOMBIE	/* #define'd in "conf.h" *and* <sys/table.h> */
X#define PI_SKILL_ZOMBIE 3   /* value from "conf.h" (it *wont* change) */
X
X#include <sys/table.h>
X
X#define NPROCS	32767	/* max number of processes to check */
X			/* Should be gotten from the kernel somehow */
Xextern  off_t lseek();
X
X/*
X * GetProc()
X *
X * Fill in and return a `struct ProcInfo' with information about the
X * next process.  If no processes are left, return NULL.
X */
Xstruct ProcInfo *
XGetProc()
X{   int rtn_status;
X    static int procindx = 0;
X    static struct ProcInfo procinfo;
X    static struct tbl_procinfo proc;
X    extern char *SysErr();
X    extern int errno;
X
X    /*
X     * Read in one proc structure at-a-time.  Table() seems to
X     * return -1 (errno = ESRCH) if you ask for a range of items
X     * under NeXT OS 2.1 and some members of the range are empty.
X     * I don't have any good clues on how to determine the number
X     * of procs to try so I'm using NPROCS.
X     * When we are finished (return NULL).
X     */
X
X    do {
X	rtn_status = table(TBL_PROCINFO,procindx++,(char *) &proc,1,
X          sizeof(proc));
X    } while(procindx < NPROCS  &&  rtn_status < 0  &&  errno == ESRCH);
X    if (procindx >= NPROCS  ||  rtn_status <= 0) {
X	if (rtn_status != 0  &&  errno != ESRCH) {
X	    fprintf(stderr, "%s: read proc: %s\n",
X	      ProgName, SysErr());
X	}
X	return((struct ProcInfo *)NULL);
X    }
X
X
X    /*
X     * Make sure this isn't a "zombie" or "exiting"
X     * process.  If it is, we have all the information
X     * we need; fill in procinfo and return.
X     */
X    procinfo.pi_flags = 0;
X    procinfo.pi_pid = (pid_T) proc.pi_pid;
X    procinfo.pi_uid = (uid_T) proc.pi_uid;
X
X    if (proc.pi_status == PI_ZOMBIE) {    /* zombie */
X	static char *zombie = "<defunct>";
X	procinfo.pi_flags |= PI_SKILL_ZOMBIE;
X	procinfo.pi_cmd = zombie;
X    } else if (proc.pi_status == PI_EXITING) {
X	static char *exiting = "<exiting>";
X	procinfo.pi_flags |= PI_SWEXIT;
X	procinfo.pi_cmd = exiting;
X    }
X
X    if (procinfo.pi_flags != 0)
X      return(&procinfo);
X
X    /*
X     * We now have a non-zombie, non-exiting process.
X     * Fill in the rest of `procinfo'.
X     */
X    if (proc.pi_ttyd != -1) { /* has a controlling tty */
X	procinfo.pi_flags |= PI_CTLTTY;
X	procinfo.pi_tty = (tty_T) proc.pi_ttyd;
X    }
X
X    /* set path-stripped command name */
X    SETCMD(procinfo.pi_cmd, proc.pi_comm, PI_COMLEN)
X
X    return(&procinfo);
X}
END_OF_FILE
if test 5831 -ne `wc -c <'machdep/next-2.c'`; then
    echo shar: \"'machdep/next-2.c'\" unpacked with wrong size!
fi
# end of 'machdep/next-2.c'
fi
if test -f 'machdep/sunos-40.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machdep/sunos-40.c'\"
else
echo shar: Extracting \"'machdep/sunos-40.c'\" \(5830 characters\)
sed "s/^X//" >'machdep/sunos-40.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char rcsid[] = "$Header: sunos-40.c,v 1.6 1994/06/26 04:17:24 forys Exp $";
X#endif
X
X/*
X**  This program may be freely redistributed for noncommercial purposes.
X**  This entire comment MUST remain intact.
X**
X**  SunOS 4.0 support by Greg Earle (earle@isolar.Tujunga.CA.US)
X**
X**  Copyright 1994 by Jeff Forys (jeff@forys.cranbury.nj.us)
X*/
X
X#define	NO_MEXTERN
X#include "conf.h"
X#undef	NO_MEXTERN
X
X#include <sys/user.h>
X#include <sys/proc.h>
X
X#include <stdio.h>
X
X/*
X * Define SigNames, NSig, and TtyDevDir here; they are used by other
X * routines and must be global.  Everyone seems to have their own
X * idea as to what NSIG should be.  Here, `NSig' is the number of
X * signals available, not counting zero.
X */
Xchar *SigMap[] = { "0",
X	"HUP", "INT", "QUIT", "ILL", "TRAP", "IOT",		/*  1 -  6 */
X	"EMT", "FPE", "KILL", "BUS", "SEGV", "SYS",		/*  7 - 12 */
X	"PIPE", "ALRM", "TERM", "URG", "STOP", "TSTP",		/* 13 - 18 */
X	"CONT", "CHLD", "TTIN", "TTOU", "IO", "XCPU",		/* 19 - 24 */
X	"XFSZ", "VTALRM", "PROF", "WINCH", "LOST", "USR1",	/* 25 - 30 */
X	"USR2", "32",						/* 31 - 32 */
X};
Xint NSig = NSIG;
X
X#define	SETCMD(dst,src,maxlen) {			\
X	extern char *rindex();				\
X	if (maxlen > 0) src[maxlen] = '\0';		\
X	dst = (dst = rindex(src, '/')) ? ++dst: src;	\
X}
X
Xstatic char *TtyDevDir = "/dev";
X
Xint	Skill;			/* set 1 if running `skill', 0 if `snice' */
Xint	PrioMin, PrioMax;	/* min and max process priorities */
Xint	SigPri;			/* signal to send or priority to set */
Xpid_T	MyPid;			/* pid of this process */
Xuid_T	MyUid;			/* uid of this process */
Xchar	*ProgName;		/* program name */
X
X/*
X * This is the machine-dependent initialization routine.
X *
X *   - The following global variables must be initialized:
X *     MyPid, MyUid, ProgName, Skill, PrioMin, PrioMax, SigPri
X *   - The working directory will be changed to that which contains the
X *     tty devices (`TtyDevDir'); this makes argument parsing go faster.
X *   - If possible, this routine should raise the priority of this process.
X */
Xvoid
XMdepInit(pname)
X	char *pname;
X{
X	extern char *rindex(), *SysErr();
X
X	MyPid = (pid_T) getpid();
X	MyUid = (uid_T) getuid();
X	SETCMD(ProgName, pname, 0)
X
X	/*
X	 * If we are running as root, raise our priority to better
X	 * catch runaway processes.
X	 */
X	if (MyUid == ROOTUID)
X		(void) setpriority(PRIO_PROCESS, MyPid, PRIO_MIN);
X
X	/*
X	 * Determine what we are doing to processes we find.  We will
X	 * either send them a signal (skill), or renice them (snice).
X	 */
X	Skill = (strcmp(ProgName, "snice") != 0);
X
X	/*
X	 * chdir to `TtyDevDir' to speed up tty argument parsing.
X	 */
X	if (chdir(TtyDevDir) < 0) {
X		fprintf(stderr, "%s: chdir(%s): %s\n", ProgName, TtyDevDir,
X		        SysErr());
X		exit(EX_SERR);
X	}
X
X	/*
X	 * Set up minimum and maximum process priorities.
X	 * Initialize SigPri to either default signal (`skill') or
X	 * default priority (`snice').
X	 */
X	PrioMin = PRIO_MIN;
X	PrioMax = PRIO_MAX;
X	SigPri = Skill? SIGTERM: 4;
X}
X
X/*
X * Carry out an action on a particular process.  If this is `skill',
X * then send the process a signal, otherwise this is `snice' so change
X * it's priority.
X *
X * If 0 is returned, the operation was successful, otherwise -1 is
X * returned and `errno' set.
X */
Xint
XMdepAction(pid)
X	pid_T pid;
X{
X	if (Skill)
X		return(kill((int)pid, SigPri));
X	else
X		return(setpriority(PRIO_PROCESS, (int)pid, SigPri));
X}
X
X/*
X * Now, set up everything we need to write a GetProc() routine.
X */
X
X#include <sys/file.h>
X
X#include <kvm.h>
X#include <nlist.h>
X
Xstatic kvm_t *kd = NULL;
X
Xstatic	char	*pidmap[] = { "swapper", "init", "pagedaemon" };
Xstatic	int	pidmapsiz = sizeof(pidmap) / sizeof(pidmap[0]);
X
Xextern	off_t lseek();
X
X/*
X * GetProc()
X *
X * Fill in and return a `struct ProcInfo' with information about the
X * next process.  If no processes are left, return NULL.
X */
Xstruct ProcInfo *
XGetProc()
X{
X	static char *WarnMsg = "Warning: can't read ";
X	static struct ProcInfo procinfo;
X	register struct user *auser;
X	register struct proc *aproc;
X
X	/*
X	 * If this is our first time here, prepare to read procs from kernel.
X	 */
X	if (kd == NULL) {
X		if ((kd = kvm_open((char *)NULL, (char *)NULL, (char *)NULL,
X		              O_RDONLY, ProgName)) == NULL)
X			exit(EX_SERR);
X		if (kvm_setproc(kd) == -1) {
X			fprintf(stderr,"%s: kvm_setproc: failed\n", ProgName);
X			exit(EX_SERR);
X		}
X	}
X
X	do {
X		if ((aproc = kvm_nextproc(kd)) == NULL)
X			return((struct ProcInfo *)NULL);
X
X		if (aproc->p_stat != 0) {
X			/*
X			 * Before we go through the trouble of reading
X			 * in the user struct, let's make sure this isn't
X			 * a "zombie" or "exiting" process.  If it is,
X			 * we have all the information we need; fill in
X			 * procinfo and return.
X			 */
X			procinfo.pi_flags = 0;
X			procinfo.pi_pid = (pid_T) aproc->p_pid;
X			procinfo.pi_uid = (uid_T) aproc->p_uid;
X
X			if (aproc->p_stat == SZOMB) {		/* zombie */
X				static char *zombie = "<defunct>";
X				procinfo.pi_flags |= PI_ZOMBIE;
X				procinfo.pi_cmd = zombie;
X			} else if (aproc->p_flag & SWEXIT) {	/* exiting */
X				static char *exiting = "<exiting>";
X				procinfo.pi_flags |= PI_SWEXIT;
X				procinfo.pi_cmd = exiting;
X			}
X
X			if (procinfo.pi_flags)
X				return(&procinfo);
X			else if ((auser = kvm_getu(kd, aproc)) == NULL)
X				printf("%su for pid %d with kvm_getu\n",
X				       WarnMsg, aproc->p_pid);
X		}
X
X	} while (aproc->p_stat == 0 || auser == NULL);
X
X	/*
X	 * We now have a process (`aproc') and a user (`auser').
X	 * Fill in the rest of `procinfo'.
X	 */
X	if (auser->u_ttyp != 0) {	/* has a controlling tty */
X		procinfo.pi_flags |= PI_CTLTTY;
X		procinfo.pi_tty = (tty_T) auser->u_ttyd;
X	}
X
X	if (aproc->p_pid < pidmapsiz) {	/* special */
X		procinfo.pi_cmd = pidmap[aproc->p_pid];
X		procinfo.pi_flags |= PI_ASKUSR;
X	} else				 /* set path-stripped command name */
X		SETCMD(procinfo.pi_cmd, auser->u_comm, MAXCOMLEN)
X
X	return(&procinfo);
X}
END_OF_FILE
if test 5830 -ne `wc -c <'machdep/sunos-40.c'`; then
    echo shar: \"'machdep/sunos-40.c'\" unpacked with wrong size!
fi
# end of 'machdep/sunos-40.c'
fi
if test -f 'machdep/sunos-41.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machdep/sunos-41.c'\"
else
echo shar: Extracting \"'machdep/sunos-41.c'\" \(5921 characters\)
sed "s/^X//" >'machdep/sunos-41.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char rcsid[] = "$Header: sunos-41.c,v 1.7 1994/06/26 04:17:35 forys Exp $";
X#endif
X
X/*
X**  This program may be freely redistributed for noncommercial purposes.
X**  This entire comment MUST remain intact.
X**
X**  SunOS 4.1 support by Greg Earle (earle@isolar.Tujunga.CA.US)
X**
X**  Copyright 1994 by Jeff Forys (jeff@forys.cranbury.nj.us)
X*/
X
X#define	NO_MEXTERN
X#include "conf.h"
X#undef	NO_MEXTERN
X
X#include <sys/user.h>
X#include <sys/proc.h>
X
X#include <stdio.h>
X
X/*
X * Define SigNames, NSig, and TtyDevDir here; they are used by other
X * routines and must be global.  Everyone seems to have their own
X * idea as to what NSIG should be.  Here, `NSig' is the number of
X * signals available, not counting zero.
X */
Xchar *SigMap[] = { "0",
X	"HUP", "INT", "QUIT", "ILL", "TRAP", "IOT",		/*  1 -  6 */
X	"EMT", "FPE", "KILL", "BUS", "SEGV", "SYS",		/*  7 - 12 */
X	"PIPE", "ALRM", "TERM", "URG", "STOP", "TSTP",		/* 13 - 18 */
X	"CONT", "CHLD", "TTIN", "TTOU", "IO", "XCPU",		/* 19 - 24 */
X	"XFSZ", "VTALRM", "PROF", "WINCH", "LOST", "USR1",	/* 25 - 30 */
X	"USR2", "32",						/* 31 - 32 */
X};
Xint NSig = NSIG;
X
X#define	SETCMD(dst,src,maxlen) {			\
X	extern char *rindex();				\
X	if (maxlen > 0) src[maxlen] = '\0';		\
X	dst = (dst = rindex(src, '/')) ? ++dst: src;	\
X}
X
Xstatic char *TtyDevDir = "/dev";
X
Xint	Skill;			/* set 1 if running `skill', 0 if `snice' */
Xint	PrioMin, PrioMax;	/* min and max process priorities */
Xint	SigPri;			/* signal to send or priority to set */
Xpid_T	MyPid;			/* pid of this process */
Xuid_T	MyUid;			/* uid of this process */
Xchar	*ProgName;		/* program name */
X
X/*
X * This is the machine-dependent initialization routine.
X *
X *   - The following global variables must be initialized:
X *     MyPid, MyUid, ProgName, Skill, PrioMin, PrioMax, SigPri
X *   - The working directory will be changed to that which contains the
X *     tty devices (`TtyDevDir'); this makes argument parsing go faster.
X *   - If possible, this routine should raise the priority of this process.
X */
Xvoid
XMdepInit(pname)
X	char *pname;
X{
X	extern char *rindex(), *SysErr();
X
X	MyPid = (pid_T) getpid();
X	MyUid = (uid_T) getuid();
X	SETCMD(ProgName, pname, 0)
X
X	/*
X	 * If we are running as root, raise our priority to better
X	 * catch runaway processes.
X	 */
X	if (MyUid == ROOTUID)
X		(void) setpriority(PRIO_PROCESS, MyPid, PRIO_MIN);
X
X	/*
X	 * Determine what we are doing to processes we find.  We will
X	 * either send them a signal (skill), or renice them (snice).
X	 */
X	Skill = (strstr(ProgName, "snice") == NULL);
X
X	/*
X	 * chdir to `TtyDevDir' to speed up tty argument parsing.
X	 */
X	if (chdir(TtyDevDir) < 0) {
X		fprintf(stderr, "%s: chdir(%s): %s\n", ProgName, TtyDevDir,
X		        SysErr());
X		exit(EX_SERR);
X	}
X
X	/*
X	 * Set up minimum and maximum process priorities.
X	 * Initialize SigPri to either default signal (`skill') or
X	 * default priority (`snice').
X	 */
X	PrioMin = PRIO_MIN;
X	PrioMax = PRIO_MAX;
X	SigPri = Skill? SIGTERM: 4;
X}
X
X/*
X * Carry out an action on a particular process.  If this is `skill',
X * then send the process a signal, otherwise this is `snice' so change
X * it's priority.
X *
X * If 0 is returned, the operation was successful, otherwise -1 is
X * returned and `errno' set.
X */
Xint
XMdepAction(pid)
X	pid_T pid;
X{
X	if (Skill)
X		return(kill((int)pid, SigPri));
X	else
X		return(setpriority(PRIO_PROCESS, (int)pid, SigPri));
X}
X
X/*
X * Now, set up everything we need to write a GetProc() routine.
X */
X
X#include <sys/file.h>
X
X#include <kvm.h>
X#include <nlist.h>
X
Xstatic kvm_t *kd = NULL;
X
Xstatic	char	*pidmap[] = { "swapper", "init", "pagedaemon" };
Xstatic	int	pidmapsiz = sizeof(pidmap) / sizeof(pidmap[0]);
X
Xextern	off_t lseek();
X
X/*
X * GetProc()
X *
X * Fill in and return a `struct ProcInfo' with information about the
X * next process.  If no processes are left, return NULL.
X */
Xstruct ProcInfo *
XGetProc()
X{
X	static char *WarnMsg = "Warning: can't read ";
X	static struct ProcInfo procinfo;
X	static struct sess s;
X	register struct user *auser;
X	register struct proc *aproc;
X
X	/*
X	 * If this is our first time here, prepare to read procs from kernel.
X	 */
X	if (kd == NULL) {
X		if ((kd = kvm_open((char *)NULL, (char *)NULL, (char *)NULL,
X		              O_RDONLY, ProgName)) == NULL)
X			exit(EX_SERR);
X		if (kvm_setproc(kd) == -1) {
X			fprintf(stderr,"%s: kvm_setproc: failed\n", ProgName);
X			exit(EX_SERR);
X		}
X	}
X
X	do {
X		if ((aproc = kvm_nextproc(kd)) == NULL)
X			return((struct ProcInfo *)NULL);
X
X		if (aproc->p_stat != 0) {
X			/*
X			 * Before we go through the trouble of reading
X			 * in the user struct, let's make sure this isn't
X			 * a "zombie" or "exiting" process.  If it is,
X			 * we have all the information we need; fill in
X			 * procinfo and return.
X			 */
X			procinfo.pi_flags = 0;
X			procinfo.pi_pid = (pid_T) aproc->p_pid;
X			procinfo.pi_uid = (uid_T) aproc->p_uid;
X
X			if (aproc->p_stat == SZOMB) {		/* zombie */
X				static char *zombie = "<defunct>";
X				procinfo.pi_flags |= PI_ZOMBIE;
X				procinfo.pi_cmd = zombie;
X			} else if (aproc->p_flag & SWEXIT) {	/* exiting */
X				static char *exiting = "<exiting>";
X				procinfo.pi_flags |= PI_SWEXIT;
X				procinfo.pi_cmd = exiting;
X			}
X
X			if (procinfo.pi_flags)
X				return(&procinfo);
X			else if ((auser = kvm_getu(kd, aproc)) == NULL)
X				printf("%su for pid %d with kvm_getu\n",
X				       WarnMsg, aproc->p_pid);
X		}
X
X	} while (aproc->p_stat == 0 || auser == NULL);
X
X	/*
X	 * We now have a process (`aproc') and a user (`auser').
X	 * Fill in the rest of `procinfo'.
X	 */
X	if (kvm_read(kd, (u_long)aproc->p_sessp, (char *)&s, sizeof(s)) != -1 &&
X	    s.s_ttyp != 0) {		/* has a controlling tty */
X		procinfo.pi_flags |= PI_CTLTTY;
X		procinfo.pi_tty = (tty_T) s.s_ttyd;
X	}
X
X	if (aproc->p_pid < pidmapsiz) {	/* special */
X		procinfo.pi_cmd = pidmap[aproc->p_pid];
X		procinfo.pi_flags |= PI_ASKUSR;
X	} else				 /* set path-stripped command name */
X		SETCMD(procinfo.pi_cmd, auser->u_comm, MAXCOMLEN)
X
X	return(&procinfo);
X}
END_OF_FILE
if test 5921 -ne `wc -c <'machdep/sunos-41.c'`; then
    echo shar: \"'machdep/sunos-41.c'\" unpacked with wrong size!
fi
# end of 'machdep/sunos-41.c'
fi
if test -f 'machdep/umax-42.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machdep/umax-42.c'\"
else
echo shar: Extracting \"'machdep/umax-42.c'\" \(7043 characters\)
sed "s/^X//" >'machdep/umax-42.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char rcsid[] = "$Header: umax-42.c,v 1.4 1994/06/26 04:18:10 forys Exp $";
X#endif
X
X/*
X**  This program may be freely redistributed for noncommercial purposes.
X**  This entire comment MUST remain intact.
X**
X**  Copyright 1994 by Jeff Forys (jeff@forys.cranbury.nj.us)
X*/
X
X#define	NO_MEXTERN
X#include "conf.h"
X#undef	NO_MEXTERN
X
X#include <sys/time.h>
X#include <sys/resource.h>
X
X#include <stdio.h>
X
X#define	CRIT_PID	1	/* Query kills for pids .LE. this number */
X
X/*
X * Define SigNames, NSig, and TtyDevDir here; they are used by other
X * routines and must be global.  Everyone seems to have their own
X * idea as to what NSIG should be.  Here, `NSig' is the number of
X * signals available, not counting zero.
X */
Xchar *SigMap[] = { "0",
X	"HUP", "INT", "QUIT", "ILL", "TRAP", "IOT",		/*  1 -  6 */
X	"EMT", "FPE", "KILL", "BUS", "SEGV", "SYS",		/*  7 - 12 */
X	"PIPE", "ALRM", "TERM", "URG", "STOP", "TSTP",		/* 13 - 18 */
X	"CONT", "CHLD", "TTIN", "TTOU", "IO", "XCPU",		/* 19 - 24 */
X	"XFSZ", "VTALRM", "PROF", "28", "29", "30",		/* 25 - 30 */
X	"31", "32",						/* 31 - 32 */
X};
Xint NSig = NSIG;
X
X#define	SETCMD(dst,src,maxlen) {			\
X	extern char *rindex();				\
X	if (maxlen > 0) src[maxlen] = '\0';		\
X	dst = (dst = rindex(src, '/')) ? ++dst: src;	\
X}
X
Xstatic char *TtyDevDir = "/dev";
X
Xint	Skill;			/* set 1 if running `skill', 0 if `snice' */
Xint	PrioMin, PrioMax;	/* min and max process priorities */
Xint	SigPri;			/* signal to send or priority to set */
Xpid_T	MyPid;			/* pid of this process */
Xuid_T	MyUid;			/* uid of this process */
Xchar	*ProgName;		/* program name */
X
X/*
X * This is the machine-dependent initialization routine.
X *
X *   - The following global variables must be initialized:
X *     MyPid, MyUid, ProgName, Skill, PrioMin, PrioMax, SigPri
X *   - The working directory will be changed to that which contains the
X *     tty devices (`TtyDevDir'); this makes argument parsing go faster.
X *   - If possible, this routine should raise the priority of this process.
X */
Xvoid
XMdepInit(pname)
X	char *pname;
X{
X	extern char *rindex(), *SysErr();
X
X	MyPid = (pid_T) getpid();
X	MyUid = (uid_T) getuid();
X	SETCMD(ProgName, pname, 0)
X
X	/*
X	 * If we are running as root, raise our priority to better
X	 * catch runaway processes.
X	 */
X	if (MyUid == ROOTUID)
X		(void) setpriority(PRIO_PROCESS, MyPid, PRIO_MIN);
X
X	/*
X	 * Determine what we are doing to processes we find.  We will
X	 * either send them a signal (skill), or renice them (snice).
X	 */
X	Skill = (strcmp(ProgName, "snice") != 0);
X
X	/*
X	 * chdir to `TtyDevDir' to speed up tty argument parsing.
X	 */
X	if (chdir(TtyDevDir) < 0) {
X		fprintf(stderr, "%s: chdir(%s): %s\n", ProgName, TtyDevDir,
X		        SysErr());
X		exit(EX_SERR);
X	}
X
X	/*
X	 * Set up minimum and maximum process priorities.
X	 * Initialize SigPri to either default signal (`skill') or
X	 * default priority (`snice').
X	 */
X	PrioMin = PRIO_MIN;
X	PrioMax = PRIO_MAX;
X	SigPri = Skill? SIGTERM: 4;
X}
X
X/*
X * Carry out an action on a particular process.  If this is `skill',
X * then send the process a signal, otherwise this is `snice' so change
X * it's priority.
X *
X * If 0 is returned, the operation was successful, otherwise -1 is
X * returned and `errno' set.
X */
Xint
XMdepAction(pid)
X	pid_T pid;
X{
X	if (Skill)
X		return(kill((int)pid, SigPri));
X	else
X		return(setpriority(PRIO_PROCESS, (int)pid, SigPri));
X}
X
X/*
X * Now, set up everything we need to write a GetProc() routine.
X */
X
X#include <sys/statistics.h>
X#include <sys/procstats.h>
X
Xextern	off_t lseek();
X
X#ifndef SZOMB
X#define	SZOMB	0x08
X#endif
X
X/*
X * GetProc()
X *
X * Fill in and return a `struct ProcInfo' with information about the
X * next process.  If no processes are left, return NULL.
X *
X * Fflag support:
X *	If Fflag is set we will try to avoid stat'ing ttys for dev_t's.
X *	We can do this only if TtyIndx is zero.
X */
Xstruct ProcInfo *
XGetProc()
X{
X	extern int errno;
X	extern char *SysErr();
X	static struct stat_descr pdesc;
X	static struct proc_config pconf;
X	static struct proc_detail *procsp;
X	static struct ProcInfo procinfo;
X	register struct proc_detail *aproc;
X	static int thisproc = 0;
X	static int initialized = 0;
X	static int needtty = 1;			/* Fflag support */
X
X	/*
X	 * Read in all the processes at once, into a large block of memory;
X	 * if `pinfo' is big enough, we'll use that, o/w we will calloc()
X	 * what we need.  Either way, `procsp' will point to the next proc.
X	 *
X	 * The first time thisproc == 0, we do the `procsp' initialization.
X	 * The second time thisproc == 0, we are finished and return NULL.
X	 * The following `while' is for sanity; it could be an `if'.
X	 */
X	while (thisproc == 0) {
X		extern char *calloc();
X		char *errstr = "%s: %s: %s\n";
X
X		if (initialized)
X			return((struct ProcInfo *)NULL);
X
X		pdesc.sd_next = NULL;
X		pdesc.sd_subsys = SUBSYS_PROC;
X		pdesc.sd_type = PROCTYPE_CONFIG;
X		pdesc.sd_options = NULL;
X		pdesc.sd_objid = NULL;
X		pdesc.sd_addr = (char *)&pconf;
X		pdesc.sd_size = sizeof(struct proc_config);
X
X		if (inq_stats(1, &pdesc) < 0) {
X			fprintf(stderr, errstr, ProgName, "inq_stats(CONFIG)",
X			        SysErr());
X			exit(EX_SERR);
X		}
X		thisproc = pconf.pc_nprocs;
X
X		if ((procsp = (struct proc_detail *) calloc((unsigned)thisproc,
X		     sizeof(struct proc_detail))) == NULL) {
X			fprintf(stderr, errstr, ProgName, "GetProc",
X			        "out of memory");
X			exit(EX_SERR);
X		}
X
X		pdesc.sd_next = NULL;
X		pdesc.sd_subsys = SUBSYS_PROC;
X		pdesc.sd_type = PROCTYPE_DETAIL;
X		pdesc.sd_options = PROC_DETAIL_ALL|PROC_DETAIL_ALLPROC;
X		pdesc.sd_objid = NULL;
X		pdesc.sd_addr = (char *)procsp;
X		pdesc.sd_size = thisproc * sizeof(struct proc_detail);
X
X		if (inq_stats(1, &pdesc) < 0) {
X			fprintf(stderr, errstr, ProgName, "inq_stats(DETAIL)",
X			        SysErr());
X			exit(EX_SERR);
X		}
X
X		thisproc = pdesc.sd_sizeused / sizeof (struct proc_detail);
X
X		/*
X		 * We can avoid a stat() syscall if we dont need dev_t's.
X		 */
X		if (Fflag && TtyIndx == 0)
X			needtty = 0;
X
X		initialized = 1;
X	}
X
X	/*
X	 * Trudge thru `procsp'.  Decrement `thisproc' as we go.
X	 */
X	aproc = procsp++;
X	thisproc--;
X
X	/*
X	 * Make sure this isn't a "zombie" process.  If it is, we are
X	 * finished; fill in procinfo and return.
X	 */
X	procinfo.pi_flags = 0;
X	procinfo.pi_pid = (pid_T) aproc->pd_pid;
X	procinfo.pi_uid = (uid_T) aproc->pd_uid;
X
X	if (aproc->pd_flag & SZOMB) {	/* zombie */
X		static char *zombie = "<defunct>";
X		procinfo.pi_flags |= PI_ZOMBIE;
X		procinfo.pi_cmd = zombie;
X	}
X
X	if (procinfo.pi_flags)
X		return(&procinfo);
X
X	/*
X	 * Fill in the rest of `procinfo'.
X	 */
X	if (aproc->pd_pid <= CRIT_PID)	/* special */
X		procinfo.pi_flags |= PI_ASKUSR;
X
X	/* set path-stripped command name */
X	SETCMD(procinfo.pi_cmd, aproc->pd_command, 12)
X
X	/*
X	 * Encore gives us a character string representing the device.
X	 * We want the actual device major/minor!
X	 */
X	if (needtty && *aproc->pd_device != '?') {
X		static struct stat st;
X		if (stat(aproc->pd_device, &st) >= 0 &&
X		    (st.st_mode & S_IFMT) == S_IFCHR) {
X			procinfo.pi_flags |= PI_CTLTTY;
X			procinfo.pi_tty = (tty_T) st.st_rdev;
X		}
X	}
X
X	return(&procinfo);
X}
END_OF_FILE
if test 7043 -ne `wc -c <'machdep/umax-42.c'`; then
    echo shar: \"'machdep/umax-42.c'\" unpacked with wrong size!
fi
# end of 'machdep/umax-42.c'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
echo shar: Extracting \"'main.c'\" \(7161 characters\)
sed "s/^X//" >'main.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char rcsid[] = "$Header: main.c,v 1.12 1994/07/13 20:31:16 forys Exp $";
X/*
X * SCCS version release number is manually updated (for what(1), etc).
X * If you use SCCS, please use last extension for version (e.g. "3.6.1.1").
X */
Xstatic char sccsid[] = 
X	"@(#)skill	3.6.1.0 (jeff@forys.cranbury.nj.us) 7/15/94";
X#endif
X
X/*
X**  skill - send signals to processes by tty, user name, command or proc id.
X**  snice - change process priorities by tty, user name, command or proc id.
X**
X**  Version 3.6
X**
X**  This program may be freely redistributed for noncommercial purposes.
X**  This entire comment MUST remain intact.
X**
X**  Copyright 1994 by Jeff Forys (jeff@forys.cranbury.nj.us)
X*/
X
X#include "conf.h"
X
X#include <stdio.h>
X#include <errno.h>
X#include <pwd.h>
X
X/*
X * Processes which could not be checked -- usually due to permission
X * problems (SunOS 4.1, Dunix 3) -- are tallied in "MissedProcCnt".
X * The machine dependent code is responsible for incrementing this;
X * if it does not, we simply assume that all reasonable processes
X * have been investigated (i.e. zombies are not reasonable).
X */
Xint MissedProcCnt = 0;
X
Xint
Xmain(argc, argv)
X	int argc;
X	char *argv[];
X{
X	extern char *SysErr(), *WhoIs();
X	register struct ProcInfo *proc;	/* process we are examining */
X	int reterr = -1;		/* -1:matchless, 0:okay, 1:error(s) */
X	register int i;
X
X	/*
X	 * Ignore SIGHUP (in case we kill our shell).
X	 */
X	(void) signal(SIGHUP, SIG_IGN);
X
X	/*
X	 * Call machine-dependent initialization routine; besides setting
X	 * up many global variables, this routine will change our working
X	 * directory to where tty devs reside and may raise our priority.
X	 *
X	 * When machine-dependent initialization is complete, parse the
X	 * argument list.
X	 */
X	MdepInit(argv[0]);
X	ArgParse(argc, argv);
X
X	/*
X	 * Our friend ArgParse() has painfully categorized the arguments
X	 * as ttys, users, commands, or pids. Loop through the list of
X	 * currently running processes and find things that match.  In
X	 * order for a match, we must have 1 item from each category
X	 * (unless a category is empty).  When a match is found, the
X	 * process is either sent signal `SigPri' (`Skill' == 1) or has
X	 * it's priority is changed to `SigPri' (`Skill' == 0).
X	 */
X#define	PID	proc->pi_pid		/* process id */
X#define	UID	proc->pi_uid		/* process owner */
X#define	TTY	proc->pi_tty		/* controlling tty */
X#define	CMD	proc->pi_cmd		/* command being executed */
X#define	FLAGS	proc->pi_flags		/* various flags (see conf.h) */
X
X	while ((proc = GetProc()) != NULL) {
X		if (TtyIndx > 0) {
X			if ((FLAGS & PI_CTLTTY) == 0)
X				continue;	/* no controlling tty */
X
X			for (i = 0; i < TtyIndx && *(TtyList+i) != TTY; i++)
X				;
X			if (i == TtyIndx)	/* no matching tty */
X				continue;
X		}
X
X		if (UidIndx > 0) {
X			for (i = 0; i < UidIndx && *(UidList+i) != UID; i++)
X				;
X			if (i == UidIndx)	/* no matching uid */
X				continue;
X		}
X
X		if (PidIndx > 0) {
X			for (i = 0; i < PidIndx && *(PidList+i) != PID; i++)
X				;
X			if (i == PidIndx)	/* no matching pid */
X				continue;
X		}
X
X		if (CmdIndx > 0) {
X			for (i = 0; i < CmdIndx; i++) {
X				if (STREQU(CMD, *(CmdList + i)))
X					break;
X			}
X			if (i == CmdIndx)	/* no matching cmd  */
X				continue;
X		}
X
X		if (PID == MyPid || PID == 0)	/* ignore self */
X			continue;
X
X		if (Iflag || (!Nflag && (FLAGS & PI_ASKUSR))) {	/* ask user */
X			static char yesno[10];
X
X			(void) fseek(stdin, 0L, 0);
X
X			fputs(ProgName, stdout);
X			if (Skill)
X				printf(": send #%d a %s", PID, SigMap[SigPri]);
X			else
X				printf(": renice #%d to %s%d", PID,
X				       (SigPri >= 0)? "+": "", SigPri);
X			printf(" (%s executing %s)? ", WhoIs(UID), CMD);
X			(void) fflush(stdout);
X
X			if (fgets(yesno, 10, stdin) == NULL) {	/* EOF */
X				(void) putc('\n', stdout);
X				return(EX_OKAY);
X			}
X
X			if (reterr < 0)
X				reterr = 0;
X
X			if (*yesno != 'y' && *yesno != 'Y')
X				continue;
X		}
X
X		if (FLAGS & PI_ZOMBIE) {	/* zombie process */
X			fprintf(stderr, "%d: zombie process\n", PID);
X			continue;
X		} else if (FLAGS & PI_SWEXIT) {	/* process is exiting */
X			fprintf(stderr, "%d: exiting process\n", PID);
X			continue;
X		}
X
X		/*
X		 * Finally do what we came here to do.  First, if
X		 * we are only displaying process id's, then do so.
X		 * If `Skill' is set, send signal `SigPri' to the
X		 * process, otherwise, set priority of process to
X		 * `SigPri'.  If either setpriority(2) or kill(2)
X		 * return -1, display the system error message.
X		 */
X		if (Nflag) {
X			printf("%d", (int)PID);
X			if (Vflag)
X				printf(" (%s executing %s)", WhoIs(UID), CMD);
X			(void) putc('\n', stdout);
X			reterr = 0;
X		} else if (MdepAction(PID) < 0) {
X			fprintf(stderr, "%d: %s (%s executing %s)\n",
X			        PID, SysErr(), WhoIs(UID), CMD);
X			reterr = 1;
X		} else {			/* success! */
X			if (reterr < 0)
X				reterr = 0;
X
X			if (Vflag) {
X				if (Skill)
X					printf("> sent #%d a %s",
X					       PID, SigMap[SigPri]);
X				else
X					printf("> reniced #%d to %s%d", PID,
X					       (SigPri >= 0)? "+": "", SigPri);
X
X				if (!Iflag)
X					printf(" (%s executing %s)",
X					       WhoIs(UID), CMD);
X				(void) putc('\n', stdout);
X				(void) fflush(stdout);
X			}
X		}
X	}
X
X	if (reterr == -1) {
X		fprintf(stderr, "%s: no matching processes", ProgName);
X		if (MissedProcCnt > 0)
X			fprintf(stderr, " (but %d could not be checked)",
X			        MissedProcCnt);
X		(void) putc('\n', stderr);
X		reterr = 1;
X	}
X
X	return(reterr? EX_UERR: EX_OKAY);
X}
X
X/*
X * Whois(uid)
X *
X * Given a user id, return its associated user name.
X */
Xchar *
XWhoIs(uid)
X	uid_T uid;
X{
X	extern char *strncpy();			/* avoid <string/strings> war */
X	static char usrcache[64] = ROOTUSR;	/* user name */
X	static uid_T uidcache = ROOTUID;	/* user id */
X	struct passwd *pp;
X
X	if (uid == ROOTUID)			/* be consistant w/ROOTUID */
X		return(ROOTUSR);
X
X	if (uid == uidcache)			/* lucky break: same person */
X		return(usrcache);
X
X	if ((pp=getpwuid((int) uid)) == NULL)	/* entry is gone? */
X		(void) sprintf(usrcache, "<uid:%d>", (int)uid);
X	else {
X		(void) strncpy(usrcache, pp->pw_name, 63);
X		usrcache[63] = '\0';
X	}
X
X	uidcache = uid;
X	return(usrcache);
X}
X
X/*
X * Usage(error)
X *
X * The user typed something incorrect; explain their mistake (encoded
X * in `error'), display usage information, and exit.
X */
Xvoid
XUsage(error)
X	int error;
X{
X	switch (error) {
X	    case E_USAGE:
X		fprintf(stderr,
X		        "Usage: %s [%s] [-ivfwn] {<tty> <user> <pid> <cmd>}\n",
X		        ProgName, Skill? "-<signal>": "(+|-)<priority>");
X		break;
X	    case E_PRIOR:	/* unused... remains for posterity? */
X		fprintf(stderr, "%s: no such priority (%d)\n",
X		        ProgName, SigPri);
X		break;
X	    case E_SIGNO:
X		fprintf(stderr, "%s: bad signal number (%d)\n",
X		        ProgName, SigPri);
X		break;
X	    default:
X		fprintf(stderr, "%s: internal error: Usage(%d)\n",
X		        ProgName, error);
X		break;
X	}
X	exit(EX_UERR);
X	/*NOTREACHED*/
X}
X
X/*
X * SysErr()
X *
X * Return the error message described by `errno'.
X */
Xchar *
XSysErr()
X{
X	extern int errno;
X#if !defined(_FSTDIO) || defined(_ANSI_SOURCE) || defined(__STRICT_ANSI__)
X	extern char *sys_errlist[];
X	extern int sys_nerr;
X#endif
X
X	return((errno > sys_nerr)? "unknown error": (char *)sys_errlist[errno]);
X}
END_OF_FILE
if test 7161 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
fi
# end of 'main.c'
fi
if test -f 'skill.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'skill.1'\"
else
echo shar: Extracting \"'skill.1'\" \(4780 characters\)
sed "s/^X//" >'skill.1' <<'END_OF_FILE'
X.\"
X.\" $Header: skill.1,v 1.9 1994/07/12 15:02:35 forys Exp $
X.\"
X.\" skill - send signals to processes by tty, user name, command or proc id.
X.\" skill - change process priorities by tty, user name, command or proc id.
X.\"
X.\" This program may be freely redistributed for noncommercial purposes.
X.\" This entire comment MUST remain intact.
X.\"
X.\" Copyright 1994 by Jeff Forys (jeff@forys.cranbury.nj.us)
X.\"
X.TH SKILL 1 "July 15, 1994" "" "Local UNIX Programmer's Manual"
X.UC 4
X.SH NAME
Xskill, snice \- signal or reprioritize specified processes
X.SH SYNOPSIS
X.B skill
X[\-signal] [\-ivfwn] {tty user command pid}
X.br
X.B snice
X[(\-\||\|+)priority] [\-ivfwn] {tty user command pid}
X.br
X.B skill
X\-l
X.SH DESCRIPTION
X.I Skill
Xsends the 
X.I terminate
Xsignal to a set of processes.
XIf a signal name (or number) preceded by a `-' is given,
Xthat signal will be substituted for terminate.  The command
X.I `skill -l'
Xdisplays a list of available signals.
X.PP
X.I Snice
Xalters the scheduling priority of selected processes.  By default,
Xthe new priority is
X.I +4,
Xbut an argument of the form `+n' (or `-n') can be used to specify
Xdifferent values.
XAn invalid priority is quietly rounded down (or up) to the first
Xacceptable value.
X.PP
XOptions accepted by both commands are as follows:
X.IP \-i
XIn interactive mode, the user is prompted with each process
Xthat is a candidate for action.  Responding `y' will carry out
Xthe stated action.  Also, a ^D at this prompt causes
X.I skill
Xor
X.I snice
Xto exit immediately.
X.IP \-v
XIn verbose mode, the id of each process successfully acted
Xupon is displayed.
X.IP \-f
XIn fast mode, the machine-dependent code responsible for reading
Xprocesses is allowed to make decisions to improve speed at the
Xexpense of error reporting (e.g. commands may not be displayed).
XThis option mainly exists to aid in killing runaway processes
Xon operating systems with complicated VM designs.
X.IP \-w
XDisplay warning messages for unreachable processes.
X.IP \-n
XDisplay process id's but do
X.I not
Xact on them.
X.PP
XAll command line arguments are order independent.
X.I Skill
Xand
X.I snice
Xallow processes to be specified using any combination of
Xttys, user names, and commands (as well as process id's).
XOnly processes that match something in
Xeach category are acted upon.  An empty category
Xguarantees a match.  For example, `skill -HUP vi ex tty00' will
Xsend the
X.I hangup
Xsignal to all
X.I vi(1)
Xand
X.I ex(1)
Xprocesses associated with
X.I tty00.
XSimilarly, `snice +10 find root' will change the priority of
Xall
X.I find(1)
Xprocesses owned by
X.I root
Xto
X.I +10.
X.PP
XUnprivileged users can only change their own processes so they need
X.B not
Xspecify their user name as part of the argument list.
XOn the other hand, the super-user should be more careful
X(e.g. the command `snice -5 vi' will change the priority of 
X.B every
Xvi(1) process on the system).
X.PP
XSince
X.I skill
Xand
X.I snice
Xcategorize their arguments, there is a chance that they
Xwill do so incorrectly (e.g. a system command is also a user
Xname).  Both programs try to match an argument with a
X.I tty,
Xa
X.I user name,
Xand a
X.I process id,
Xbefore classifying it as a
X.I command.
XTo override this, an argument can be
X.B forced
Xto a particular type by preceding it with "-c" (command), "-u"
X(user), "-t" (tty), or "-p" (process id).
X.PP
XProcess id's are not known beforehand, so both kernel memory and the
Xswap device must be searched for the required information.  Alternately,
Xon some systems, the "/proc" file system is examined.  When
Xa process fitting each category is discovered, it is immediately
Xacted upon (unless running in interactive mode).  Processes must
Xbelong to the current user unless s/he is the super-user.  Neither
Xprogram will ever act on itself, but everything else is fair game.
X.PP
XExit status is normally 0; if the user makes a mistake, 1 is returned.
XIf a system error occurs, exit status is 2.
X.SH "FILES"
X/vmunix		system name list
X.br
X/dev/mem		physical memory
X.br
X/dev/kmem		kernel virtual memory
X.br
X/dev/drum		swap device
X.br
X/proc		process file system
X.br
X/dev			searched to map ttys into device numbers
X.SH "SEE ALSO"
Xkill(1), nice(1), priocntl(1), renice(1), ps(1),
X.br
Xkill(2), setpriority(2), signal(2), proc(4)
X.SH "AUTHOR"
XJeff Forys
X.SH "CONTRIBUTORS"
XDavid Sharnoff		Greg Earle		Christos Zoulas
X.br
XGorodecki Tom		Mike Hibler		Ric Anderson
X.SH "BUGS"
XThings change while these programs execute, occasionally
Xprocesses will be missed (the `-w' flag displays these).
X.sp
XCommand names may be truncated to a machine-dependent size.
X.sp
XOn some operating systems, these programs are unable to investigate
Xprocesses belonging to other users.  While not a problem, this fact is
Xreflected in the "(but N could not be checked)" notice, which follows
Xthe "no matching processes" message.
END_OF_FILE
if test 4780 -ne `wc -c <'skill.1'`; then
    echo shar: \"'skill.1'\" unpacked with wrong size!
fi
# end of 'skill.1'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
