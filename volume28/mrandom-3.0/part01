Newsgroups: comp.sources.unix
From: cthombor@theory.lcs.mit.edu (Clark D. Thomborson)
Subject: v28i027: mrandom-3.0 - random number generator with persistent state, Part01/06
Message-id: <1.768285901.18944@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: cthombor@theory.lcs.mit.edu (Clark D. Thomborson)
Posting-Number: Volume 28, Issue 27
Archive-Name: mrandom-3.0/part01

This is an updated version of Volume 25's mrandom package.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 6)."
# Contents:  MANIFEST README doc doc/latexinfo.sty man man/mrtest.1
#   man/mrtest.1.txt src src/bentley.c src/bentley.h src/makefile
#   src/newrng.c src/newrng.h src/pcrand.c src/pcrand.h src/ran0.c
#   src/ran0.h src/ran1.c src/ran1.h src/ran2.c src/ran2.h src/rngs.h
#   src/script src/ultra.c src/ultra.h src/xsq.c src/xsq.h
# Wrapped by vixie@gw.home.vix.com on Fri May  6 21:42:55 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1212 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	
X README                     1	
X doc                        1	
X doc/latexinfo.sty          1	
X doc/mrandom.ps.1           6	
X doc/mrandom.ps.2           5	
X doc/mrandom.tex            4	
X doc/mrandom.txt            3	
X man                        1	
X man/mrandom.3              2	
X man/mrandom.3.txt          2	
X man/mrtest.1               1	
X man/mrtest.1.txt           1	
X src                        1	
X src/bentley.c              1	
X src/bentley.h              1	
X src/makefile               1	
X src/mrandom.c              3	
X src/mrandom.h              2	
X src/mrtest.c               2	
X src/newrng.c               1	
X src/newrng.h               1	
X src/pcrand.c               1	
X src/pcrand.h               1	
X src/ran0.c                 1	
X src/ran0.h                 1	
X src/ran1.c                 1	
X src/ran1.h                 1	
X src/ran2.c                 1	
X src/ran2.h                 1	
X src/rngs.h                 1	
X src/script                 1	
X src/ultra.c                1	
X src/ultra.h                1	
X src/xsq.c                  1	
X src/xsq.h                  1	
END_OF_FILE
if test 1212 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(4835 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X/* README 3.1 5/28/93 */
X
X[ comp.sources.unix note: i uncompressed doc/mrandom.ps.Z and split
X  it into two files (doc/mrandom.ps.{1,2}).  you will have to cat
X  them together before printing them.				--vix ]
X
XThis ftp directory contains the file mrandom-3.0.tar.Z, a new
Xdistribution of the public-domain mrandom package in 4.3bsd Unix
Xtar'red, compressed format.
X
XMrandom is a package of routines intended to help anyone writing
Xmachine-independent C-language programs that call pseudorandom number
Xgenerators (RNGs).  We provide a standard interface to nine different
XRNGs, making it easy to write efficient programs in which the choice
Xof RNG algorithm is deferred until runtime.  We also provide a set of
Xcommonly-used "RNG utility functions" (e.g. to generate integers
Xuniformly distributed in a restricted range), as well as a small suite
Xof RNG tests.
X
XTo date, we have only tested the mrandom package on SparcStations and
XDECstations.  However, we believe that it will run correctly, without
Xmodification, on any IEEE-compliant, ANSI C, 32-bit computational
Xplatform which can link to the 4.3bsd Unix RNGs "random", "rand", and
X"nrand48".  Please send bug reports and comments to Clark Thomborson,
Xcthombor@ua.d.umn.edu.
X
XYou can use the ftp commands 
X	ftp> binary
X	ftp> get mrandom-3.0.tar.Z
X	ftp> bye
Xto retrieve this file.  Move it into a suitable directory on your home
Xsystem, then unpack it with the 4.3bsd Unix sequence
X	your-home-machine% zcat mrandom-3.0.tar.Z | tar xvf -
XIf all goes well, you will have created a new subdirectory, named
Xmrandom-3.0, containing the complete software distribution for version
X3.0 of mrandom.
X
XThe rest of this file briefly outlines the changes in the program's
Xinterface since the last version.  See the User's Manual, included in
Xthe distribution in several formats (files mrandom-3.0/doc/mrandom.tex,
Xmrandom.txt, mrandom.ps.Z), for detailed information about these
Xchanges, for general information about this package, and for
Xcompilation instructions.
X
X
Xinit_rng()
X	Old version:
X	int init_rng(rng, alg, seed1, seed2, count1, count2)
X	RNGdata *rng;
X	long alg;
X	long seed1, seed2;
X	long count1, count2;
X
X	New version:
X	RNGdata *init_rng(alg, mrandom_alg, seed, count1, count2, bufsize)
X	long alg;
X	long mrandom_alg;
X	long *seed;
X	long count1, count2;
X	long bufsize;
X
Xrestart_rng()
X	Old version:
X	int restart_rng(rng, filename)
X	RNGdata *rng;
X	char *filename;
X
X	New version:
X	RNGdata *restart_rng(filename)
X	char *filename;
X
Xkill_rng()
X	There is now a kill_rng() routine:
X	int kill_rng(rng)
X	RNGdata *rng;
X
Xxrandomrv()
X	xrandomrv() has been replaced by a family of routines for
Xproviding unbuffered generates from an RNG:
X	double dxrandomrv(rng, n, v)
X	RNGdata *rng;
X	long n;
X	double v[];
X
X	float fxrandomrv(rng, n, v)
X	RNGdata *rng;
X	long n;
X	float v[];
X
X	long lxrandomrv(rng, n, v)
X	RNGdata *rng;
X	long n;
X	long v[];
X
X	int bxrandomrv(rng, n, v)
X	RNGdata *rng;
X	long n;
X	int v[];
X
X	double bxrandomrv_f(rng, n, v)
X	RNGdata *rng;
X	long n;
X	int v[];
X
XBuffered generating routines
X	A family of routines has been added for providing buffered
Xoutput of generates from an RNG:
X	double drandomrv(rng, n, v)
X	RNGdata *rng;
X	long n;
X	double v[];
X
X	float frandomrv(rng, n, v)
X	RNGdata *rng;
X	long n;
X	float v[];
X
X	long lrandomrv(rng, n, v)
X	RNGdata *rng;
X	long n;
X	long v[];
X
X	int brandomrv(rng, n, v)
X	RNGdata *rng;
X	long n;
X	int v[];
X
X	double brandomrv_f(rng, n, v)
X	RNGdata *rng;
X	long n;
X	int v[];
X
Xflush_rng()
X	A routine has been added for flushing the RNG's buffers:
X	int flush_rng(rng)
X	RNGdata *rng;
X
Xmrandomrv()
X	The interface to mrandomrv() has remained unchanged:
X	long mrandomrv(rng, m, n, v)
X	RNGdata *rng;
X	long m, n, v[];
X
X	However, mrandomrv() is now capable of using one of two
Xdifferent algorithms for producing restricted-range integer generates.
X
Xsave_rng() and restart_rng()
X	The interface to save_rng() has remained unchanged.  However,
Xsome files saved with the old save_rng() (e.g. files containing state
Xtables for nrand48) are not compatible with the new version.  The
Xinterface to restart_rng() is now the following:
X	RNGdata *restart_rng(filename)
X	char *filename;
X
Xseed_rng()
X	There is now a seed_rng() routine:
X	void seed_rng(rng, seed)
X	RNGdata *rng;
X	long *seed;
X
Xcheck_rng()
X	checkrandom() is now called check_rng() and has the following
Xinterface:
X	int check_rng(rng)
X	RNGdata *rng;
X
Xdescribe_rng()
X	The string created and returned by describe_rng() now has the
Xfollowing format:
X
X	RNG state identifier is (alg, mralg; seed1, seed2; count1,
Xcount2; bufsize, split)
X
Xmralg_rng(), split_rng(), and range_rng()
X	Three routines for examining and modifying the parameters of
XRNG's have been added:
X	int mralg_rng(rng, new_value)
X	RNGdata *rng;
X	long new_value;
X
X	int split_rng(rng, new_value)
X	RNGdata *rng;
X	long new_value;
X
X	double range_rng(rng)
X	RNGdata *rng;
END_OF_FILE
if test 4835 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test ! -d 'doc' ; then
    echo shar: Creating directory \"'doc'\"
    mkdir 'doc'
fi
if test -f 'doc/latexinfo.sty' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/latexinfo.sty'\"
else
echo shar: Extracting \"'doc/latexinfo.sty'\" \(18583 characters\)
sed "s/^X//" >'doc/latexinfo.sty' <<'END_OF_FILE'
X% latexinfo.sty 3.1 5/28/93
X%% TeX macros to handle latexinfo files
X%% \include{ 5 page GNU copyleft here }
X%   Copyright (C) 1985, 1986 Richard M. Stallman
X%   Copyleft  (0) 1988, 1989 Michael E. Clarkson
X
X\def\latexinfoversion{1.2}
X\message{Loading Latexinfo package [Version \latexinfoversion]:}
X\message{}
X
X\setcounter{tocdepth}{2}
X\setcounter{secnumdepth}{3}
X
X\def\oddfoot#1{\def\@oddfoot{#1}}
X\def\evenfoot#1{\def\@evenfoot{#1}}
X
X% Save some parts of plain tex whose names we will redefine.
X
X\let\ptexlbrace=\{
X\let\ptexrbrace=\}
X\let\ptexdot=\.
X\let\ptexstar=\*
X\let\ptexend=\end
X\let\ptexbullet=\bullet
X\let\ptexb=\b
X\let\ptexc=\c
X\let\ptexi=\i
X\let\ptext=\t
X\let\ptexl=\l
X\let\ptexL=\L
X\def\pline{\hbox to\hsize}
X\def\pleftline#1{\pline{#1\hss}}
X\def\prightline#1{\pline{\hss#1}}
X
X\def\centerline#1{\pline{\hss#1\hss}}
X
X\def\tie{\penalty 10000\ }     % Save plain tex definition of ~.
X
X\let\normal=\normalsize
X
X\message{Basics,}
X\chardef\other=12
X
X\hyphenation{ap-pen-dix}
X\hyphenation{mini-buf-fer mini-buf-fers}
X
X% Parse an argument, then pass it to #1.
X% The argument can be delimited with [...] or with "..." or braces
X% or it can be a whole line.
X% #1 should be a macro which expects
X% an ordinary undelimited TeX argument.
X
X\def\parsearg #1{\let\next=#1\begingroup\obeylines\futurelet\temp\parseargx}
X
X\def\parseargx{%
X\ifx \obeyedspace\temp \aftergroup\parseargdiscardspace \else%
X\aftergroup \parseargline %
X\fi \endgroup}
X
X{\obeyspaces %
X\gdef\parseargdiscardspace {\begingroup\obeylines\futurelet\temp\parseargx}}
X
X\gdef\obeyedspace{\ }
X
X\def\parseargline{\begingroup \obeylines \parsearglinex}
X{\obeylines %
X\gdef\parsearglinex #1^^M{\endgroup \next {#1}}}
X
X\def\flushcr{\ifx\par\lisppar \def\next##1{}\else \let\next=\relax \fi \next}
X
X% Single-spacing is done by various environments.
X
X\newskip\singlespaceskip
X\singlespaceskip = \baselineskip
X\def\singlespace{%
X{\advance \baselineskip by -\singlespaceskip
X\kern \baselineskip}%
X\baselineskip=\singlespaceskip
X}
X
X\def\arrow{$\rightarrow$}
X
X% Used to generate quoted braces.
X
X\def\mylbrace {{\tt \char '173}}
X\def\myrbrace {{\tt \char '175}}
X\let\{=\mylbrace
X\let\}=\myrbrace
X
X% \: forces normal size whitespace following.
X\def\:{\spacefactor=1000 }
X
X% \* forces a line break.
X\def\*{\hfil\break}
X
X% \. is an end-of-sentence period.
X\def\.{.\spacefactor=3000 }
X
X% \w prevents a word break
X\def\w#1{\hbox{#1}}
X
X% \br   forces paragraph break
X
X\let\br = \par
X
X% \dots{}  output some dots
X
X\def\dots{$\ldots$}
X
X% \page    forces the start of a new page
X%\def\page{\clearpage}
X
X% \exdent text....
X% outputs text on separate line in roman font, starting at standard page margin
X
X\def\exdent{\errmessage{@exdent in filled text}}
X  % \lisp, etc, define \exdent locally from \internalexdent
X
X{\obeyspaces
X\gdef\internalexdent{\parsearg\exdentzzz}}
X
X\def\exdentzzz #1{{\advance \leftskip by -\lispnarrowing
X\advance \hsize by -\leftskip
X\advance \hsize by -\rightskip
X\leftline{{\rm#1}}}}
X
X% \sp n   outputs n lines of vertical space
X\def\sp#1{\par\vskip #1\baselineskip\relax}
X
X% \comment ...line which is ignored...
X% \c is the same as @comment
X% \begin{ignore} ... \end{ignore}  is another way to write a comment
X\def\comment{\parsearg \commentxxx}
X
X\def\commentxxx #1{}
X
X\let\c=\comment
X
X% Some texinfo constructs that are trivial in tex
X\newenvironment{iftex}{}{}
X
X\catcode`@=11
X
X\message{menus,}
X{\catcode`\^^M=13 \gdef\@gobblecr{\@ifnextchar
X{\@gobble}{\ignorespaces}}}
X
X\chardef\active=13
X
X{\catcode`\ =\active\gdef\@vobeyspaces{\catcode`\ \active \let \@xobeysp}}
X 
X\begingroup \catcode `|=0 \catcode `[= 1
X\catcode`]=2 \catcode `\{=12 \catcode `\}=12
X\catcode`\\=12 
X|gdef|@xmenu#1\end{menu}[|end[menu]]
X|gdef|@xifinfo#1\end{ifinfo}[|end[ifinfo]]
X|gdef|@xignore#1\end{ignore}[|end[ignore]]
X|endgroup
X
X\def\@menu{\begingroup
X\@tempswafalse 
X\def\par{\if@tempswa\hbox{}\fi\@tempswatrue\@@par}
X\obeylines \let\do\@makeother \dospecials}
X
X\def\menu{\@menu\@xmenu }
X\let\endmenu=\endgroup
X\def\ifinfo{\@menu\@xifinfo }
X\let\endifinfo=\endgroup
X\def\ignore{\@menu\@xignore }
X\let\endignore=\endgroup
X
X\def\node{\parsearg\nodezzz}
X\def\nodezzz#1{\nodexxx [#1,]}
X\def\nodexxx[#1,#2]{\gdef\lastnode{#1}}
X%\def\node#1#2#3#4{\gdef\lastnode{#1}}
X\let\lastnode=\relax
X
X
X\let\refill=\relax
X
X\let\setfilename=\comment
X
X\def\inforef #1{\inforefzzz #1,,,,**}
X\def\inforefzzz #1,#2,#3,#4**{See Info file \file{\losespace#3{}}, node `\losespace#1{}'}
X\def\losespace #1{#1}
X
X\message{fonts,}
X
X% Font-change commands.
X
X\def\li{\sf}
X
X%% Add scribe-like font environments, plus \l for inline lisp (usually sans
X%% serif) and \ii for TeX italic
X
X\def\i#1{{\sl #1}}
X\let\var=\i
X\let\dfn=\i
X\let\emph=\i
X
X\def\b#1{{\bf #1}}
X\let\strong=\b
X
X\def\t#1{{\tt \rawbackslash #1}\null}
X\let\ttfont=\t
X\let\kbd=\t
X\let\code=\t
X\def\samp#1{`{\tt \rawbackslash #1}'\null}
X\def\key#1{{\tt \uppercase{#1}}\null}
X\def\ctrl#1{$\uparrow${\tt #1}}
X
X\let\file=\samp
X
X\def\l#1{{\li #1}\null}
X
X\def\r#1{{\rm #1}}
X\def\s#1{{\sc #1}}
X\def\ii#1{{\it #1}}
X
X\def\bullet{$\ptexbullet$}
X\def\labelitemi{$\ptexbullet$}
X
X\def\minus{$-$}
X
X% Make altmode in file print out right
X
X\catcode `\^^[=\active \def^^[{$\diamondsuit$}
X
X\message{indexing,}
X% Index generation facilities
X
X% Define the texinfo user-accessible indexing commands for backwrds 
X% compatability.
X
X\def\findex{\fnindex}
X\def\kindex{\kyindex}
X\def\cindex{\cpindex}
X\def\vindex{\vrindex}
X\def\tindex{\tpindex}
X\def\pindex{\pgindex}
X\def\cindex{\cpindex}
X
X
X% \newindex {foo} defines an index named foo.
X% It automatically defines \fooindex such that
X% \fooindex ...rest of line... puts an entry in the index foo.
X% It also defines \fooindfile to be the number of the output channel for
X% the file that	accumulates this index.  The file's extension is foo.
X% The name of an index should be no more than 2 characters long
X% for the sake of vms.
X
X\def\newindex#1{\csname newindex#1\endcsname}
X
X% Yes I know this could be done shorter, but safer??
X
X\def\newindexcp{\if@filesw \newwrite\@cpindexfile
X  \immediate\openout\@cpindexfile=\jobname.cp
X  \def\cpindex{\@bsphack\begingroup
X             \def\protect####1{\string####1\space}\@sanitize
X             \@wrindex\@cpindexfile}%
X  \def\cpsubindex{\@bsphack\begingroup
X             \def\protect####1{\string####1\space}\@sanitize
X             \@wrsubindex\@cpindexfile}%
X  \def\cpindexbold{\@bsphack\begingroup
X             \def\protect####1{\string####1\space}\@sanitize
X             \@wrindexbold\@cpindexfile}
X   \typeout{Writing concepts index file \jobname.cp }%
X   \fi}
X
X\def\cpindex{\@bsphack\begingroup \@sanitize\@index}
X\def\cpsubindex{\@bsphack\begingroup \@sanitize\@index}
X\def\cpindexbold{\@bsphack\begingroup \@sanitize\@index}
X
X\def\@wrindex#1#2{\let\thepage\relax
X   \xdef\@gtempa{\write#1{\string \entry{#2}{\thepage}{#2}}}\endgroup\@gtempa
X   \if@nobreak \ifvmode\nobreak\fi\fi\@esphack}
X
X\def\@wrindexbold#1#2{\let\thepage\relax \let\bf\relax
X   \xdef\@gtempa{\write#1{\string \entry{#2}{\b{\thepage}}{#2}}}\endgroup\@gtempa
X   \if@nobreak \ifvmode\nobreak\fi\fi\@esphack}
X
X\def\@wrsubindex#1#2#3{\let\thepage\relax
X	\xdef\@gtempa{\write#1{\string \entry{#2 #3}{\thepage}{#2}{#3}}}\endgroup%
X	\@gtempa
X   \if@nobreak \ifvmode\nobreak\fi\fi\@esphack}
X
X\def\@index#1{\endgroup\@esphack}
X
X\def\pgindex{\@bsphack\begingroup \@sanitize\@index}
X\def\newindexpg{\if@filesw \newwrite\@pgindexfile
X  \immediate\openout\@pgindexfile=\jobname.pg
X  \def\pgindex{\@bsphack\begingroup
X             \def\protect####1{\string####1\space}\@sanitize
X             \@wrindex\@pgindexfile}\typeout{Writing index file \jobname.pg }\fi}
X
X\def\newindexvr{\if@filesw \newwrite\@vrindexfile
X  \immediate\openout\@vrindexfile=\jobname.vr
X  \def\vrindex{\@bsphack\begingroup
X             \def\protect####1{\string####1\space}\@sanitize
X             \@wrindex\@vrindexfile}
X  \def\vrindexbold{\@bsphack\begingroup
X             \def\protect####1{\string####1\space}\@sanitize
X             \@wrindexbold\@vrindexfile}
X	\typeout{Writing variable index file \jobname.vr }\fi}
X
X\def\vrindex{\@bsphack\begingroup \@sanitize\@index}
X\def\vrindexbold{\@bsphack\begingroup \@sanitize\@index}
X
X\def\newindextp{\if@filesw \newwrite\@tpindexfile
X  \immediate\openout\@tpindexfile=\jobname.tp
X  \def\tpindex{\@bsphack\begingroup
X             \def\protect####1{\string####1\space}\@sanitize
X             \@wrindex\@tpindexfile}
X	\typeout{Writing datatype index file \jobname.tp }\fi}
X
X\def\tpindex{\@bsphack\begingroup \@sanitize\@index}
X
X\def\newindexky{\if@filesw \newwrite\@kyindexfile
X  \immediate\openout\@kyindexfile=\jobname.ky
X  \def\kyindex{\@bsphack\begingroup
X             \def\protect####1{\string####1\space}\@sanitize
X             \@wrindex\@kyindexfile}\typeout{Writing key index file \jobname.ky }\fi}
X
X\def\kyindex{\@bsphack\begingroup \@sanitize\@index}
X
X\def\newindexfn{\if@filesw \newwrite\@fnindexfile
X  \immediate\openout\@fnindexfile=\jobname.fn
X  \def\fnindex{\@bsphack\begingroup
X             \def\protect####1{\string####1\space}\@sanitize
X             \@wrindex\@fnindexfile}
X  \def\fnindexbold{\@bsphack\begingroup
X             \def\protect####1{\string####1\space}\@sanitize
X             \@wrindexbold\@fnindexfile}
X	\typeout{Writing function index file \jobname.fn }\fi}
X
X\def\fnindex{\@bsphack\begingroup \@sanitize\@index}
X
X
X% \synindex{foo}{bar}    makes index foo feed into index bar.
X\def\synindex#1#2{\expandafter\xdef \csname @#1index\endcsname{%
X	\noexpand\csname @#2index\endcsname}%
X\expandafter \chardef \csname @#1indfile\endcsname=\csname @#2indfile\endcsname}
X
X
X% Define the macros used in formatting output of the sorted index material.
X% This is what you call to cause a particular index to get printed.
X% Write
X% \section*{Function Index}
X% \printindex{fn}
X
X\newskip\secondaryindent
X\secondaryindent=0.5cm
X
X%\catcode`\%=\other\catcode`\&=\other\catcode`\#=\other
X%\catcode`\@=\other\catcode`\$=\other\catcode`\_=\other
X%\catcode`\~=\other\catcode`\^=\other
X%\tex %
X%\catcode`\%=\other\catcode`\&=\other\catcode`\#=\other
X%\catcode`\@=\other\catcode`\$=\other\catcode`\_=\other
X%\catcode`\~=\other\catcode`\^=\other
X
X\def\printindex#1{
X\def\indexbackslash{\rawbackslashxx}
X\tolerance=9500 \advance\baselineskip -1pt
X\openin 1 \jobname.#1s
X\ifeof 1 \else \closein 1 \input \jobname.#1s
X\fi
X}
X
X% These macros are used by the sorted index file itself.
X% Change them to control the appearance of the index.
X
X\def\Dotsbox{\hbox to 1em{\hss.\hss}} % Used by index macros
X
X\def\initial#1{%
X{\bigbreak\pline{\large\bf#1\hfill}\kern 2pt\penalty3000}}
X
X\def\entry #1#2{
X{\parfillskip=0in \parskip=0in \parindent=0in \small
X\hangindent=1in \hangafter=1%
X\noindent\hbox{#1}\leaders\Dotsbox\hskip 0pt plus 1filll\relax #2\par
X}}
X
X\def\primary #1{\pline{\small#1\hfil}}
X
X\def\secondary #1#2{
X{\parfillskip=0in \parskip=0in \small
X\hangindent =1in \hangafter=1
X\noindent\hskip\secondaryindent\hbox{#1}\leaders\Dotsbox\hskip 0pt plus 1filll#2\par
X}}
X
X%%% Args are the skip and penalty (usually negative)
X\def\dobreak#1#2{\par\ifdim\lastskip<#1\removelastskip\penalty#2\vskip#1\fi}
X
X\message{environments,}
X
X% \begin{tex} ... \end{tex}    escapes into raw Tex temporarily.
X
X\def\tex{\begingroup
X\catcode `\\=0 \catcode `\{=1 \catcode `\}=2
X\catcode `\$=3 \catcode `\&=4 \catcode `\#=6
X\catcode `\^=7 \catcode `\_=8 \catcode `\~=13 \let~=\tie
X\catcode `\%=14
X\catcode`\"=12
X\catcode`\|=12
X\catcode`\<=12
X\catcode`\>=12
X
X\let\{=\ptexlbrace
X\let\}=\ptexrbrace
X\let\.=\ptexdot
X\let\*=\ptexstar
X\let\bullet=\ptexbullet
X\let\b=\ptexb \let\c=\ptexc \let\i=\ptexi \let\t=\ptext \let\l=\ptexl
X\let\L=\ptexL
X
X\let\endtex=\endgroup}
X
X% Define \lisp ... \endlisp.
X% \lisp does a \begingroup so it can rebind things,
X% including the definition of \endlisp (which normally is erroneous).
X
X% Amount to narrow the margins by for \lisp.
X\newskip\lispnarrowing \lispnarrowing=\parindent
X
X% This is the definition that ^M gets inside \lisp
X% phr: changed space to \null, to avoid overfull hbox problems.
X{\obeyspaces%
X\gdef\lisppar{\null\endgraf}}
X
X% Cause \obeyspaces to make each Space cause a word-separation
X% rather than the default which is that it acts punctuation.
X% This is because space in tt font looks funny.
X{\obeyspaces %
X\gdef\sepspaces{\def {\ }}}
X
X\newskip\aboveenvskipamount \aboveenvskipamount= 0pt
X\def\aboveenvbreak{{\advance\aboveenvskipamount by \parskip
X\endgraf \ifdim\lastskip<\aboveenvskipamount
X\removelastskip \penalty-50 \vskip\aboveenvskipamount \fi}}
X
X\def\afterenvbreak{\endgraf \ifdim\lastskip<\aboveenvskipamount
X\removelastskip \penalty-50 \vskip\aboveenvskipamount \fi}
X
X\newenvironment{example}{\aboveenvbreak
X	\hfuzz=12truept % Don't be fussy
X	\sepspaces % Make spaces be word-separators rather than space tokens.
X	\singlespace % Single space lines
X	% The following causes blank lines not to be ignored
X	% by adding a space to the end of each line.
X	\let\par=\lisppar
X	\parskip=0pt \advance \rightskip by \lispnarrowing 
X	\advance \leftskip by \lispnarrowing
X	\parindent=0pt
X	\let\exdent=\internalexdent
X	\obeyspaces \obeylines \tt \rawbackslash \bgroup\samepage
X	\def\next##1{}\next}{\egroup\afterenvbreak}
X
X%same is the same as an enclosed \samepage
X\newenvironment{same}{\bgroup\samepage}{\egroup}
X
X% This is \begin{display}; same as \begin{lisp} except use roman font.
X
X\newenvironment{display}{\aboveenvbreak
X	% Make spaces be word-separators rather than space tokens.
X	\sepspaces %
X	% Single space lines
X	\singlespace %
X	% The following causes blank lines not to be ignored
X	% by adding a space to the end of each line.
X	\let\par=\lisppar
X	\parskip=0pt \advance \rightskip by \lispnarrowing 
X	\advance \leftskip by \lispnarrowing
X	\parindent=0pt
X	\let\exdent=\internalexdent
X	\obeyspaces \obeylines
X		\def\next##1{}\next}{\afterenvbreak}
X
X% This is \format; same as \lisp except use roman font and don't narrow margins
X
X\newenvironment{format}{\aboveenvbreak
X	% Make spaces be word-separators rather than space tokens.
X	\sepspaces %
X	\singlespace %
X	% The following causes blank lines not to be ignored
X	% by adding a space to the end of each line.
X	\let\par=\lisppar
X	\parskip=0pt \parindent=0pt
X	\obeyspaces \obeylines
X	\def\next##1{}\next}{\afterenvbreak}
X
X\message{cross reference,}
X% Define cross-reference macros
X
X% \xref and \pxref generate cross references to specified points.
X
X\def\pxref #1{see \xrefX [#1,,,,,,,]}
X\def\xref #1{See \xrefX [#1,,,,,,,]}
X
X%\def\xrefX [#1,#2,#3,#4,#5,#6]{section \ref{#1} [%
X%{\setbox0=\hbox{\losespace#3{}}%
X%\ifdim \wd0 =0pt \losespace#1{}\else\unhbox0\fi}],
X%page\tie \pageref{#1}}
X
X\def\xrefX [#1,#2,#3,#4,#5,#6]{%
X\setbox1=\hbox{\i{\losespace#5{}}}%
X\setbox0=\hbox{\losespace#3{}}%
X\ifdim \wd0 =0pt \setbox0=\hbox{\losespace#1{}}\fi%
X\ifdim \wd1 >0pt%
Xsection \unhbox0{} in \unhbox1%
X\else%
X\ref{#1} [\unhbox0], page\tie \pageref{#1}%
X\fi }
X
X\message{sectioning,}
X% Define chapters, sections, etc.
X
X\def\@chapter[#1]#2{\ifnum \c@secnumdepth >\m@ne
X \refstepcounter{chapter}
X\ifx\lastnode\relax\else\label{\lastnode}\fi
X\let\lastnode=\relax
X \typeout{\@chapapp\space\thechapter.}
X \addcontentsline{toc}{chapter}{\protect
X \numberline{\thechapter}#1}\else
X \addcontentsline{toc}{chapter}{#1}\fi
X \chaptermark{#1}
X \addtocontents{lof}{\protect\addvspace{10pt}}
X\addtocontents{lot}{\protect\addvspace{10pt}} \if@twocolumn
X\@topnewpage[\@makechapterhead{#2}] 
X \else \@makechapterhead{#2}
X \@afterheading \fi} 
X\def\@schapter#1{\if@twocolumn \@topnewpage[\@makeschapterhead{#1}]
X \else \@makeschapterhead{#1} 
X \@afterheading\fi}
X
X\def\@sect#1#2#3#4#5#6[#7]#8{\ifnum #2>\c@secnumdepth
X     \def\@svsec{}\else 
X     \refstepcounter{#1}
X\ifx\lastnode\relax\else\label{\lastnode}\fi
X\let\lastnode=\relax
X	\edef\@svsec{\csname the#1\endcsname\hskip 1em }\fi
X     \@tempskipa #5\relax
X      \ifdim \@tempskipa>\z@ 
X        \begingroup #6\relax
X          \@hangfrom{\hskip #3\relax\@svsec}{\interlinepenalty \@M #8\par}
X        \endgroup
X       \csname #1mark\endcsname{#7}\addcontentsline
X         {toc}{#1}{\ifnum #2>\c@secnumdepth \else
X                      \protect\numberline{\csname the#1\endcsname}\fi
X                    #7}\else
X        \def\@svsechd{#6\hskip #3\@svsec #8\csname #1mark\endcsname
X                      {#7}\addcontentsline
X                           {toc}{#1}{\ifnum #2>\c@secnumdepth \else
X                             \protect\numberline{\csname the#1\endcsname}\fi
X                       #7}}\fi
X     \@xsect{#5}}
X
X\def\smallbook{
X\global\lispnarrowing = 0.3in
X\global\baselineskip 12pt
X\global\parskip 3pt plus 1pt
X\global\hsize = 5in
X\global\doublecolumnhsize=2.4in \global\doublecolumnvsize=15.0in
X\global\vsize=7.5in
X\global\tolerance=700
X\global\hfuzz=1pt
X
X\global\pagewidth=\hsize
X\global\pageheight=\vsize
X\global\font\ninett=cmtt9
X
X\global\let\smalllisp=\smalllispx
X\global\let\smallexample=\smalllispx
X\global\def\Esmallexample{\Esmalllisp}
X}
X
X%% For a final copy, take out the rectangles
X%% that mark overfull boxes (in case you have decided
X%% that the text looks ok even though it passes the margin).
X\def\finalout{\overfullrule=0pt}
X
X\message{and turning on texinfo input format.}
X
X{\catcode`\@=0
X
X% \rawbackslashxx output one backslash character in current font
X{\catcode`\\=\other
X@gdef@rawbackslashxx{\}}
X
X% \rawbackslash redefines \ as input to do \rawbackslashxx.
X{\catcode`\\=\active
X@gdef@rawbackslash{@let\=@rawbackslashxx }}
X}
X
X% \back outputs one backslash in fixed width font.
X\gdef\back{\tt\rawbackslashxx\ignorespaces}
X
X\def\document{\endgroup
X  \@colht\textheight  \@colroom\textheight \vsize\textheight
X   \columnwidth\textwidth \@clubpenalty\clubpenalty
X   \if@twocolumn \advance\columnwidth -\columnsep 
X      \divide\columnwidth\tw@ \hsize\columnwidth \@firstcolumntrue 
X   \fi
X  \hsize\columnwidth \linewidth\hsize
X  \begingroup\@floatplacement\@dblfloatplacement
X   \makeatletter\let\@writefile\@gobbletwo
X   \@input{\jobname.aux}\endgroup 
X  \if@filesw \immediate\openout\@mainaux=\jobname.aux
X    \immediate\write\@mainaux{\relax}\fi
X  \def\do##1{\let ##1\@notprerr}
X  \@preamblecmds
X  \let\do\noexpand
X\@normalsize\everypar{}\nospecials}
X
X
X% Here is a list of the characters that have been specially catcoded:
X\def\dosomespecials{\do\$\do\&\do\#\do\%\do\~\do\^}
X
X{\catcode`\"=\active
X\catcode`\>=\active
X\catcode`\<=\active
X\catcode`\_=\active
X\gdef\nospecials{
X\catcode`\"=\active
X\gdef\activedoublequote{{\tt \char '042}}
X\let"=\activedoublequote
X\catcode`\>=\active
X\gdef\activegtr{{\tt \char '076}}
X\let>=\activegtr
X\catcode`\<=\active
X\gdef\activeless{{\tt \char '074}}
X\let<=\activeless
X\catcode`\_=\active
X\gdef\activeunderscore{{\tt \char '137}}
X\let_=\activeunderscore
X\@noligs\let\do\@makeother \dosomespecials}
X}
END_OF_FILE
if test 18583 -ne `wc -c <'doc/latexinfo.sty'`; then
    echo shar: \"'doc/latexinfo.sty'\" unpacked with wrong size!
fi
# end of 'doc/latexinfo.sty'
fi
if test ! -d 'man' ; then
    echo shar: Creating directory \"'man'\"
    mkdir 'man'
fi
if test -f 'man/mrtest.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/mrtest.1'\"
else
echo shar: Extracting \"'man/mrtest.1'\" \(3500 characters\)
sed "s/^X//" >'man/mrtest.1' <<'END_OF_FILE'
X.\" mrtest.1 3.1 5/28/93
X.TH MRTEST 1 "5/28/93"
X.SH NAME
Xmrtest, mrtestv \- test-driver for the mrandom() routines
X.SH SYNOPSIS
X.B mrtest
X.RB [ " nnn " ]
X.RB [ " \-dnnnn " ]
X.RB [ " \-S[n[,n \&.\|.\|. ]] " ]
X.RB [ " \-mnnnnn " ]
X.RB [ " \-Mnn " ]
X.RB [ " \-q " ]
X.RB [ " \-t " ]
X.RB [ " \-e " ]
X.RB [ " \-f " ]
X.RB [ " \-v " ]
X.RB [ " \-p " ]
X.SH DESCRIPTION
X.IX  "mrtest command"  ""  "\fLmrtest\fP \(em test random number generator"
X.LP
X.B mrtest
Xgenerates random integers, using any
Xone of several possible random number generation (RNG) algorithms,
Xthen tests these integers for ``randomness''.
X
X.SH OPTIONS
X.TP
X.B nnn
Xsets the number of random generates to be tested.  Default is 10.
X.TP
X.B \-dnnnn 
Xdiscards nnnn generates between tested values.  Default is 0.
X.TP
X.B \-S[n[,n[,n[,n[,n]]]]] initializes an RNG, as follows:
X.IP
XThe first parameter sets the RNG algorithm, default 1, as
X.RS
X.IP 0.
Xan additive linear scheme (for testing only);
X.IP 1.
X4.3bsd random;
X.IP 2.
XKnuth/Bentley prand();
X.IP 3.
XL'Ecuyer's portable combined multiplicative RNG;
X.IP 4.
X4.3bsd nrandom48;
X.IP 5.
X4.3bsd rand;
X.IP 6.
XPress and Teukolsky's ran0;
X.IP 7.
XPress and Teukolsky's ran1;
X.IP 8.
XPress and Teukolsky's ran2; and
X.IP 9.
XMaraglia's Ultra.
X.RE
X.IP
XThe second parameter sets the first RNG seed, default 1.
X.IP
XThe third parameter sets the second RNG seed, default 1.
XNote that most RNG algorithms will ignore this value.
X.IP
XThe fourth parameter sets the number of times to cycle the RNG
Xbefore starting the tests, mod 1 billion.  Default is 0.
X.IP
XThe fifth parameter of \-S sets the number of times to cycle the RNG
Xbefore starting the tests, div 1 billion.  Default is 0.
X.TP
X.B \-mnnnnn
Xor
X.B \-Mnn
Xsets the range of the RNG to be nnnnn or 2^(nn), respectively.
XAt most one of these two options should be selected.
XDefault is -m100.
X.TP
X.B \-q
Xor
X.B \-quiet
Xturns off the (default) printing of each random integer, as it is generated.
X.TP
X.B \-t
Xeliminates most RNG tests, for timing measurements.
X.TP
X.B \-e 
Xechos the command line.  Useful in scripts.
X.TP
X.B \-f
Xor
X.B \-p
Xselects one of two non-default methods, other than mrandom(),
Xfor generating random integers.
XThe \-f option uses (int)(frandom()*m), which is slightly
Xfaster, but also slightly biased.
XThe \-p uses xrandom()%m to generate integers, a poor method for many RNGs.
X.TP
X.B \-v
Xuses the vectorized interface, mrandomrv().
X.LP
XNote: the last three options are unavailable in the version of the code,
X.B mrtestv,
Xcompiled with \-DVECTORIZED.
XIn mrtestv, the mrandomrv() call is always used.
X.LP
XThe
X.B script
Xfile supplied with the software distribution contains a number of csh-level
Xcalls to mrtest, illustrating its use as well as demonstrating various problems
Xwith the 4.3bsd random number generators rand() and nrand48().
X
X.SH AUTHOR
XClark Thomborson, cthombor@ub.d.umn.edu
X
X.SH DIAGNOSTICS
XIf error-checking code in
X.I init_rng, restart_rng,
Xor
X.I save_rng
Xdiscovers a problem, an error message is printed on the stderr stream.
X
X.SH "SEE ALSO"
Xrandom(3), rand(3C), drand48(3), mrandom(3)
X
X.SH BUGS
XThe estimated standard deviations are merely estimates, and not very
Xaccurate ones at that, especially on the upper tail.  A better
XX-squared analysis routine would help.
X
X.SH THEORY
XFor more information on the X-squared analysis implemented in this
Xcode, see "Tools for Randomized Experimentation" by Clark Thomborson,
Xto appear in the Proceedings of the 25th Symposium on the Interface:
XComputing Science and Statistics, 1993.
END_OF_FILE
if test 3500 -ne `wc -c <'man/mrtest.1'`; then
    echo shar: \"'man/mrtest.1'\" unpacked with wrong size!
fi
# end of 'man/mrtest.1'
fi
if test -f 'man/mrtest.1.txt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/mrtest.1.txt'\"
else
echo shar: Extracting \"'man/mrtest.1.txt'\" \(4232 characters\)
sed "s/^X//" >'man/mrtest.1.txt' <<'END_OF_FILE'
X
X
X
XMRTEST(1)                USER COMMANDS                  MRTEST(1)
X
X
X
XNAME
X     mrtest, mrtestv - test-driver for the mrandom() routines
X
XSYNOPSIS
X     mrtest [ nnn ] [ -dnnnn ] [ -S[n[,n ... ]] ] [ -mnnnnn  ]  [
X     -Mnn ] [ -q ] [ -t ] [ -e ] [ -f ] [ -v ] [ -p ]
X
XDESCRIPTION
X     mrtest generates random integers, using any one  of  several
X     possible  random  number  generation  (RNG) algorithms, then
X     tests these integers for ``randomness''.
X
X
XOPTIONS
X     nnn  sets the number  of  random  generates  to  be  tested.
X          Default is 10.
X
X     -dnnnn
X          discards nnnn generates between tested values.  Default
X          is 0.
X
X     -S[n[,n[,n[,n[,n]]]]] initializes an RNG, as follows:
X
X          The first parameter sets the RNG algorithm, default  1,
X          as
X
X          0.   an additive linear scheme (for testing only);
X
X          1.   4.3bsd random;
X
X          2.   Knuth/Bentley prand();
X
X          3.   L'Ecuyer's portable combined multiplicative RNG;
X
X          4.   4.3bsd nrandom48;
X
X          5.   4.3bsd rand;
X
X          6.   Press and Teukolsky's ran0;
X
X          7.   Press and Teukolsky's ran1;
X
X          8.   Press and Teukolsky's ran2; and
X
X          9.   Maraglia's Ultra.
X
X          The second parameter sets the first RNG  seed,  default
X          1.
X
X          The third parameter sets the second RNG  seed,  default
X          1.   Note  that  most  RNG  algorithms will ignore this
X          value.
X
X
X
XSun Release 4.1       Last change: 5/28/93                      1
X
X
X
X
X
X
XMRTEST(1)                USER COMMANDS                  MRTEST(1)
X
X
X
X          The fourth parameter sets the number of times to  cycle
X          the  RNG  before  starting  the  tests,  mod 1 billion.
X          Default is 0.
X
X          The fifth parameter of -S sets the number of  times  to
X          cycle the RNG before starting the tests, div 1 billion.
X          Default is 0.
X
X     -mnnnnn
X          or -Mnn sets the range  of  the  RNG  to  be  nnnnn  or
X          2^(nn), respectively.  At most one of these two options
X          should be selected.  Default is -m100.
X
X     -q   or -quiet turns off the (default) printing of each ran-
X          dom integer, as it is generated.
X
X     -t   eliminates most RNG tests, for timing measurements.
X
X     -e   echos the command line.  Useful in scripts.
X
X     -f   or -p selects one of  two  non-default  methods,  other
X          than mrandom(), for generating random integers.  The -f
X          option uses (int)(frandom()*m), which is slightly  fas-
X          ter, but also slightly biased.  The -p uses xrandom()%m
X          to generate integers, a poor method for many RNGs.
X
X     -v   uses the vectorized interface, mrandomrv().
X
X     Note: the last three options are unavailable in the  version
X     of  the  code,  mrtestv,  compiled  with  -DVECTORIZED.   In
X     mrtestv, the mrandomrv() call is always used.
X
X     The script file supplied with the software distribution con-
X     tains  a  number  of csh-level calls to mrtest, illustrating
X     its use as well as demonstrating various problems  with  the
X     4.3bsd random number generators rand() and nrand48().
X
X
XAUTHOR
X     Clark Thomborson, cthombor@ub.d.umn.edu
X
X
XDIAGNOSTICS
X     If error-checking code in _i_n_i_t__r_n_g, _r_e_s_t_a_r_t__r_n_g, or _s_a_v_e__r_n_g
X     discovers  a  problem,  an  error  message is printed on the
X     stderr stream.
X
X
XSEE ALSO
X     random(3), rand(3C), drand48(3), mrandom(3)
X
X
X
X
X
XSun Release 4.1       Last change: 5/28/93                      2
X
X
X
X
X
X
XMRTEST(1)                USER COMMANDS                  MRTEST(1)
X
X
X
XBUGS
X     The estimated standard deviations are merely estimates,  and
X     not  very  accurate  ones  at  that, especially on the upper
X     tail.  A better X-squared analysis routine would help.
X
X
XTHEORY
X     For more information on the X-squared  analysis  implemented
X     in  this code, see "Tools for Randomized Experimentation" by
X     Clark Thomborson, to appear in the Proceedings of  the  25th
X     Symposium  on  the  Interface: Computing Science and Statis-
X     tics, 1993.
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
XSun Release 4.1       Last change: 5/28/93                      3
X
X
X
END_OF_FILE
echo shar: 24 control characters may be missing from \"'man/mrtest.1.txt'\"
if test 4232 -ne `wc -c <'man/mrtest.1.txt'`; then
    echo shar: \"'man/mrtest.1.txt'\" unpacked with wrong size!
fi
# end of 'man/mrtest.1.txt'
fi
if test ! -d 'src' ; then
    echo shar: Creating directory \"'src'\"
    mkdir 'src'
fi
if test -f 'src/bentley.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/bentley.c'\"
else
echo shar: Extracting \"'src/bentley.c'\" \(3963 characters\)
sed "s/^X//" >'src/bentley.c' <<'END_OF_FILE'
X/* bentley.c 3.1 5/28/93 */
X/*  This is mrandom's RNG Algorithm #2				    */
X
X/*  Original Author: Jon Bentley				    */
X/*    (Source code obtained from DIMACS shared account, March 1992.)*/
X/*  Header file/mrandom interface by Clark Thomborson, May 1992     */
X/*  Vectorized interface by Clark Thomborson, June 1992		    */
X/*  Updated mrandom interface by Robert Plotkin, Feb/March 1993     */
X/*                                                                  */
X/*  This file contains a set of c-language functions for generating */
X/*  uniform integers.   This is a COMPLETELY PORTABLE generator.    */
X/*  It will give IDENTICAL sequences of random numbers for any      */
X/*  architecture with at least 30-bit integers, regardless of the   */
X/*  integer representation, MAXINT value, or roundoff/truncation    */
X/*  method, etc.                                                    */
X
X/*  This Truly Remarkable RNG is described more fully in            */
X/*  J. Bentley's column, ``The Software Exploratorium ''            */
X/*  to appear in Unix Review in 1991.                               */ 
X/*  It is based on one in Knuth, Vol 2, Section 3.2.2 (Algorithm A) */ 
X
X#include "bentley.h"
X
X/*----RNG Global Variables-------*/ 
X
X#define arr rngstate
X#define a (rngstate[RNGstatesize_2 - 2])
X#define b (rngstate[RNGstatesize_2 - 1])
X
X/*********************************/
X/* External interface to mrandom */
X/*********************************/
X/* Generating procedure */
Xlong _lprand(RNGdata *rng)
X{
Xreturn(lprand(RNGstate));
X}
X
X/* Seeding procedure */
Xvoid _lprand_seed(rng, seed)
XRNGdata *rng;
Xlong *seed;
X{
Xsprand(*seed, RNGstate);
X}
X
X/* Checking procedure */
Xint _lprand_check(rng)
XRNGdata *rng;
X{
Xreturn(ckrand(RNGstate));
X}
X
X
X/*----RNG Initializer------------*/
X/* Call once before using lprand */ 
X
Xextern void sprand (seed, rngstate)
Xlong seed; 
Xlong rngstate[RNGstatesize_2];
X{
X  int i, ii;
X  long last, next, v[55];
X  arr[0] = last = seed; 
X  next = 1;
X  for (i=1; i < 55; i++) {
X    ii = ( 21 * i ) % 55;
X    arr[ii] = next;
X    next = last - next; 
X    if (next < 0)
X      next += PRANDMAX;
X    last = arr[ii];
X  }
X
X  a = 0; /* invariant: (b-a-24)%55 = 0 */
X  b = 24; 
X  /* cycle 165 times (more would probably be better -cdt) */
X  for (i=0;i<165;i++) {
X    lprand(rngstate);
X  }
X}
X
X/*---------RNG---------------------*/
X/* Returns a long integer in the range 0...PRANDMAX-1 */
X
Xextern long lprand(rngstate)
Xlong rngstate[RNGstatesize_2];
X{
X  long t,ta,tb,retval;
X  
X  /* get local copies of a,b from state array */ 
X  ta = a;
X  tb = b;
X  
X  if (ta-- == 0) ta = 54;
X  if (tb-- == 0) tb = 54;
X  
X  t = arr[ta] - arr[tb];
X  if (t < 0) t+= PRANDMAX;
X  
X  arr[ta] = t;
X  retval = t;
X  
X  /* update state array */
X  a = ta;
X  b = tb;
X  
X  return(retval);
X}
X
X/*---------CKRAND---------------------*/
X/* Returns 0 if rngstate is corrupted */
X
Xextern int ckrand(rngstate)
Xlong rngstate[RNGstatesize_2];
X{
X  if ( (b-a-24)%55 != 0 ) return(0); else return(1);
X}
X
X/*-----------------------------------------------*/
X/* This is a little driver program so you can    */
X/* test the code.              */
X/* Typing: a.out 0 3 1         */
X/* should produce              */
X/*     921674862               */
X/*     250065336               */
X/*     377506581               */
X/*  Typing: a.out 1000000 1 2  */ 
X/*  should produce             */
X/*     57265995                */
X
X#ifdef DEBUG
Xmain(argc, argv)
Xint argc;
Xint *argv;
X{
X  int i;
X  long j;
X  int n;
X  int m; 
X  long seed; 
X  long rngstate[RNGstatesize_2];
X
X  m = atoi(argv[1]);    /* Number to discard initially */ 
X  n = atoi(argv[2]);    /* Number to print */ 
X  seed = atoi(argv[3]); /* Seed */ 
X
X  sprand(seed,rngstate);
X
X  if ( !ckrand(rngstate) ) printf("Error detected by ckrand()\n");
X
X  for (i=0; i < m; i++) j = lprand(rngstate);
X  for (i=0; i < n; i++) printf("%ld\n", lprand(rngstate));
X
X  if ( !ckrand(rngstate) ) printf("Error detected by ckrand()\n");
X} 
X#endif               
X
END_OF_FILE
if test 3963 -ne `wc -c <'src/bentley.c'`; then
    echo shar: \"'src/bentley.c'\" unpacked with wrong size!
fi
# end of 'src/bentley.c'
fi
if test -f 'src/bentley.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/bentley.h'\"
else
echo shar: Extracting \"'src/bentley.h'\" \(2181 characters\)
sed "s/^X//" >'src/bentley.h' <<'END_OF_FILE'
X/* bentley.h 3.1 5/28/93 */
X/*  Original Author: Jon Bentley				    */
X/*    (Source code obtained from DIMACS shared account, March 1992.)*/
X/*								    */
X/*  Header file/mrandom interface by Clark Thomborson, May 1992     */
X/*  Vectorized interface by Clark Thomborson, June 1992		    */
X/*  Updated mrandom interface by Robert Plotkin, Feb/March 1993     */
X/*                                                                  */
X/*  This file contains a set of c-language functions for generating */
X/*  uniform integers.   This is a COMPLETELY PORTABLE generator.    */
X/*  It will give IDENTICAL sequences of random numbers for any      */
X/*  architecture with at least 30-bit integers, regardless of the   */
X/*  integer representation, MAXINT value, or roundoff/truncation    */
X/*  method, etc.                                                    */
X
X/*  This Truly Remarkable RNG is described more fully in            */
X/*  J. Bentley's column, ``The Software Exploratorium ''            */
X/*  to appear in Unix Review in 1991.                               */ 
X/*  It is based on one in Knuth, Vol 2, Section 3.2.2 (Algorithm A) */ 
X
X#ifndef MRANDOM
X#include "mrandom.h"
X#endif
X
X#define PRANDMAX          1000000000
X
X/* Information for mrandom */
X#define RNGstatesize_2    57
X#define RNGseedsize_2     1
X#define RNGrange_2        (double)PRANDMAX
X#define RNGname_2         "(Knuth/Bentley prand: lagged Fibbonacci)\n"
X#define RNGreturns_2      RET_LONG
X#define RNGstatetype_2    STATE_LONG
X#define RNGdgen_2        0
X#define RNGlgen_2        _lprand
X#define RNGseed_2         _lprand_seed
X#define RNGcheck_2        _lprand_check
X
X/*----RNG Initializer------------*/
X/* Call once before using lprand */ 
X
Xvoid sprand (/* long seed, rngstate[RNGstatesize_2] */);
X
X/*---------RNG---------------------*/
X/* Returns a long integer in the range 0...PRANDMAX-1 */ 
X
Xlong lprand(/* long rngstate[RNGstatesize_2] */);
X
X/*---------CKRAND---------------------*/
X/* Returns 0 if rngstate is corrupted */
X
Xint ckrand(/* long rngstate */);
X
X/* mrandom interface routines */
Xlong _lprand(/*RNGdata **/);
Xvoid _lprand_seed(/*RNGdata *, long **/);
Xint _lprand_check(/*RNGdata **/);
END_OF_FILE
if test 2181 -ne `wc -c <'src/bentley.h'`; then
    echo shar: \"'src/bentley.h'\" unpacked with wrong size!
fi
# end of 'src/bentley.h'
fi
if test -f 'src/makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/makefile'\"
else
echo shar: Extracting \"'src/makefile'\" \(2089 characters\)
sed "s/^X//" >'src/makefile' <<'END_OF_FILE'
X# makefile 3.1 5/28/93
X
X# HOST should be the name of your machine
XHOST = SunSS1p
X
X# CC should be the name of your favorite C compiler
XCC = gcc
X
X# set your compiler flag(s) here
XCBFLAG1 = -O2
XCBFLAG2 =
XCBFLAG3 =
X# the following compiler flags go at the end of the command line; use for
X# flags that are required by the compiler to be at the end of the line
XCEFLAG1 = -lm
XCEFLAG2 = 
X
X# you shouldn't have to change anything below this line
XCBFLAGS = ${CBFLAG1} ${CBFLAG2} ${CBFLAG3}
XCEFLAGS = ${CEFLAG1} ${CEFLAG2}
X
X# where the results of the test script will be written
XRESULTFILE = results.${HOST}.${CC}${CBFLAG1}${CBFLAG2}${CBFLAG3}${CEFLAG1}${CEFLAG2}
X
X# a standard resultfile
XRESULTSTD = results.SunSS1p.gcc.O2-lm.orig
X
XINCS =  mrandom.h bentley.h pcrand.h ran0.h ran1.h ran2.h ultra.h xsq.h
X
XSRCS = mrtest.c mrandom.c bentley.c pcrand.c ran0.c ran1.c ran2.c\
X	ultra.c xsq.c
X
XOBJS = mrandom.o bentley.o pcrand.o ran0.o ran1.o ran2.o ultra.o xsq.o
X
Xall:
X	make mrandom.a
X	make mrtest
X
Xmrandom.a: ${OBJS}
X	ar r mrandom.a ${OBJS}
X	ranlib mrandom.a
X	chmod a+rwx mrandom.a
X
Xmrtest	: mrtest.c mrandom.a
X	${CC} ${CBFLAGS} mrtest.c -o mrtest mrandom.a ${CEFLAGS}
X
Xmrtestv	: mrandom.a mrtest.c
X	${CC} ${CBFLAGS} -DVECTOR mrtest.c -o mrtestv mrandom.a \
X	  ${CEFLAGS}
X
Xmrtestv.s: ${OBJS} mrtest.c
X	${CC} ${CBFLAGS} -S -DVECTOR mrtest.c \
X	  -o mrtestv.s mrandom.a ${CEFLAGS}
X
Xmrtestg	: ${OBJS} mrtest.c
X	${CC} ${CFLAGS} -g mrtest.c \
X	  -o mrtestg mrandom.a ${CEFLAGS}
X
Xtest	:
X# force recompilation, just in case CFLAGS or CC have changed.
X	/bin/rm -f ${OBJS} mrandom.a
X# The following command should take a few minutes...
X	./script > ${RESULTFILE}
X#
X# Since mrtest's output should be machine- and compiler independent,
X# the following diff should show only differences in timing and
X# in compiler invocation lines.  If you see anything else, please
X# contact cthombor@mars.d.umn.edu.
X# 
X	-diff ${RESULTFILE} ${RESULTSTD}
X#
X# End of test.
X
Xclean	:
X	rm -f *.o *.s
X	rm -f mrtest mrtestv mrtestg mrtestv.s mrandom.a
X	rm -f ${RESULTFILE} RNGstatefile
X
Xrealclean	:
X	make clean
X	rm -f mrtest mrandom.a
X
END_OF_FILE
if test 2089 -ne `wc -c <'src/makefile'`; then
    echo shar: \"'src/makefile'\" unpacked with wrong size!
fi
# end of 'src/makefile'
fi
if test -f 'src/newrng.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/newrng.c'\"
else
echo shar: Extracting \"'src/newrng.c'\" \(665 characters\)
sed "s/^X//" >'src/newrng.c' <<'END_OF_FILE'
X/* newrng.c 3.1 5/28/93 */
X/* RNG source file template */
X/* Robert Plotkin
X/* 5/3/93 */
X
X#include "newrng.h"
X
X/* Generating procedure */
X/* Only one of the following two procedures should be defined, */
X/* depending on the kind of value that your RNG returns        */
X
Xlong newrng_lgen(rng)
XRNGdata *rng;
X{
X/* Your generating procedure goes here */
X}
X
Xdouble newrng_dgen(rng)
XRNGdata *rng;
X{
X/* Your generating procedure goes here */
X}
X
X/* Seeding procedure */
Xvoid newrng_seed(rng,seed)
XRNGdata *rng;
Xlong *seed;
X{
X/* Your seeding procedure goes here */
X}
X
X/* Checking procedure */
Xint newrng_check(rng)
XRNGdata *rng;
X{
X/* Your checking procedure goes here */
X}
END_OF_FILE
if test 665 -ne `wc -c <'src/newrng.c'`; then
    echo shar: \"'src/newrng.c'\" unpacked with wrong size!
fi
# end of 'src/newrng.c'
fi
if test -f 'src/newrng.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/newrng.h'\"
else
echo shar: Extracting \"'src/newrng.h'\" \(485 characters\)
sed "s/^X//" >'src/newrng.h' <<'END_OF_FILE'
X/* newrng.h 3.1 5/28/93 */
X/* RNG header file template */
X/* Robert Plotkin
X/* 5/3/93 */
X
X#include "mrandom.h"
X
X/* Information for mrandom */
X#define RNGstatesize_n    
X#define RNGseedsize_2
X#define RNGrange_2
X#define RNGname_2
X#define RNGreturns_2
X#define RNGstatetype_2
X#define RNGdgen_2
X#define RNGlgen_2
X#define RNGseed_2
X#define RNGcheck_2
X
X/* mrandom interface routines */
Xlong newrng_gen(/*RNGdata **/);
Xvoid newrng_seed(/*RNGdata *, long **/);
Xint newrng_check(/*RNGdata **/);
END_OF_FILE
if test 485 -ne `wc -c <'src/newrng.h'`; then
    echo shar: \"'src/newrng.h'\" unpacked with wrong size!
fi
# end of 'src/newrng.h'
fi
if test -f 'src/pcrand.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/pcrand.c'\"
else
echo shar: Extracting \"'src/pcrand.c'\" \(9579 characters\)
sed "s/^X//" >'src/pcrand.c' <<'END_OF_FILE'
X/* pcrand.c 3.1 5/28/93 */
X/* **********************
X
X
XPurpose:        This file has routines to implement a
X                Combined Prime Multiplicative Congruential
X                Psuedo-Random Number Generator.
X
X		The original algorithms and selection of
X		prime numbers comes from two articles in the
X		Communications of the ACM: June 1988 (v31 #6)
X		the article by Pierre L'Ecuyer called,
X		"Efficient and Portable Combined Random Number Generators"
X		and the October (v31 #10), Stephen Park and Keith Miller
X		"Random Number Generators: Good Ones are Hard to Find."
X
X		This implementation of these algorithms has been released
X		to the Public Domain. 91.03.10; 91.09.25.
X
XAuthor:         Jesse Chisholm
XModified by:	Clark Thomborson, Robert Plotkin
X
XAuditor:
X
XCreation Date:  91.03.04
X
XModifications by Jesse Chisholm:
X
X	0.0.0	91.03.04	Initial creation from the articles
X				mentioned.
X
X	0.0.1	91.03.04	cleaned up some, and added test main(s).
X
X	0.0.2	91.03.06	added support routines for retaining
X				continuation of sequence across program
X				invokations.
X
X	0.0.3	91.03.10	ported to UNIX
X
X	1.0.0	91.03.10	Released to the Public Domain.
X
X	1.0.1	91.09.25	Re-Released to the Public Domain.
X
XModifications by Clark Thomborson:
X
X	1.0.2	92.01.01	Added SUN compatibility; allowed RNGHOME
X				to differ from $HOME; wrote Unix Makefile
X
X	2.0.0	92.01.02	Rewrote _rand to comply with L'Ecuyer's
X				recommendations.  New function is called
X				pcrand(), of type double.  Discarded
X				nrand(), since it was inaccurate.
X				Added RNGFILENAME.  Reformatted statefile
X				to include pedigree of current state.
X
X	2.0.1	92.01.06	Rewrote urand() to generate full-range
X				(31-bit) integers in an unbiased fashion.	
X
X	2.0.2   92.01.15	Removed a tiny residual bias in urand().
X
X	3.0.0   92.05.06	Interfaced to mrandom().  Discarded
X				urand() and non-Sun code.
X
X*************************************************** */
X
X/* #define TEST */
X
X/* include directives */
X
X#include <stdio.h>
X#include "pcrand.h"
X
X/*
X**      this is the current state of the generator
X*/
X#define curr_seed1 rngstate[0]
X#define curr_seed2 rngstate[1]
X
X/* These constants define the generator */
X
X#define ROOT1 40014L
X#define ROOT2 40692L
X
X/*
X**      If you should choose to change primes or roots,
X**      please be sure that these conditions hold:
X**              (QUO > REM)
X**              (QUO > 0)
X**              (REM > 0)
X*/
X/* QUO = PRIME / ROOT */
X#define QUO1 53668L
X#define QUO2 52774L
X
X/* REM = PRIME % ROOT */
X#define REM1 12211L
X#define REM2 3791L
X
X/*
X**      The 10000th seed from 1L for arithmetic checking
X*/
X#define PRCHK1  1919456777L
X#define PRCHK2  2006618587L
X
X/* ***************************************************
X
XName:           lpcrand
X
XPurpose:        This is the basic routine for generating
X                random numbers.  The range is 0..(PRIME1-2).
X                The period is humongous.  Roughly 2^62.
X
XSample Call:    l = lpcrand(rngstate);
X
XInputs:         rngstate (array of 2 longs, holding seed1 and seed2)
X
XOutputs:        none
X
XReturns:        long l;  MSBs are random
X
XAlgorithm:      seed1 = seed1 * ROOT1 % PRIME1
X                seed2 = seed2 * ROOT2 % PRIME2
X                U = (seed1 - seed2) mod (PRIME1 - 1)
X		return (U==0 ? (PRIME1 - 1): U)
X
X        This implementation used the following numbers:
X
X        PRIME           ROOT            RANGE
X        2147483563      40014           1..2147483562
X        2147483399      40692           1..2147483398
X
X*************************************************** */
X/*
X**      NOTES ABOUT RND taken from earlier implementation
X**
X**  This is the basic routine.
X**
X**      new_seed = old_seed * ROOT % PRIME;
X**
X**  The table below shows some convenient values
X**
X**      PRIME       primitive root      alternate root      range
X**
X**      17              5                   6               1..16
X**      257             19                  17              1..256
X**      32749           182                 128             1..32748
X**      65537           32749               32719           1..65536
X**      2147483647      16807               39373           1..2147483646
X**      2147483647      48271               69621           1..2147483646
X**      2147483647      397204094           630360016       1..2147483646
X**
X**  This is the best single primitive root for 2^31-1 according to
X**  Pierre L'Ecuyer; "Random Numbers for Simulation"; CACM 10/90.
X**
X**      2147483647      41358                               1..2147483646
X**
X**  He also lists the prime 4611685301167870637
X**  and the primitive root  1968402271571654650
X**  as being pretty good.  However, it doesn't lend itself to
X**  this algorithm as the quotient is less than the remainder in p/r.
X**
X**  As a way of checking the arithmetic in any given implementation,
X**  the table below shows what the 10,000th seed should be when the
X**  generator is started at 1L for various primes and roots.
X**
X**      PRIME           ROOT    1st seed        10,000th seed
X**      ----------      -----   -               ----------
X**      2147483647L     16807L  1L              1043618065L
X**      2147483647L     48271L  1L               399268537L
X**      2147483647L     69621L  1L               190055451L
X**      2147483563L     40014L  1L              1919456777L
X**      2147483399L     40692L  1L              2006618587L
X**
X**  There are many other primitive roots available for these
X**  or other primes.  These were chosen as esthetically pleasing.
X**  Also chosen so that `p / x > p % x' for prime p, and root x.
X**
X**  A number (x) is a primitive root of a prime (p)
X**  iff in the equation:
X**
X**      t = x^i % p
X**
X**      when (i == p-1) and (t == 1)
X**
X**      for all (1 <= i < p-1) then (t >= 2)
X**
X**  The number of primitive roots for a given prime (p) is the number
X**  of numbers less that (p-1) that are relatively prime to (p-1).
X**
X**  Note: that is how many, not which ones.
X** 
X**  if x is a primitive root of p, and y is relatively prime to p-1
X**  then (x^y % p) is also a primitive root of p.
X**  also (x^(p-1-y) % p) is a primitive root of p.
X**
X*/
X
Xlong lpcrand(rngstate)
Xlong rngstate[RNGstatesize_3];
X{
X  long k;
X  long U;
X
X  /* the following code is taken from Figure 3 of L'Ecuyer's article */
X  k = curr_seed1 / QUO1;
X  curr_seed1 = ROOT1 * (curr_seed1 - k * QUO1) - k * REM1;
X  if (curr_seed1 < 0) {
X    curr_seed1 += PRIME1;
X  }
X
X  k = curr_seed2 / QUO2;
X  curr_seed2 = ROOT2 * (curr_seed2 - k * QUO2) - k * REM2;
X  if (curr_seed2 < 0) {
X    curr_seed2 += PRIME2;
X  }
X
X  U = curr_seed1 - curr_seed2;
X  if (U < 1) {
X    U += PRIME1 - 1;
X  }
X
X  return(U-1);
X}
X
X/* ***************************************************
X
XName:           checkran
X
XPurpose:        This routine returns 1 if the RNG state looks ok.
X
XSample Call:    if ( !checkran(rngstate) ) fprintf(stderr,"RNG unitialized!\n");
X
XInputs:         none
X
XOutputs:        none
X
XReturns:        none
X
XAlgorithm:      Return 1 if 0 < seed1 < PRIME1 and 0 < seed2 < PRIME2,
X		else return 0
X
X*************************************************** */
Xextern int checkran(rngstate)
Xlong rngstate[RNGstatesize_3];
X{
X  if (curr_seed1 <= 0 || curr_seed1 >= PRIME1 ||
X      curr_seed2 <= 0 || curr_seed2 >= PRIME2) {
X    return(0);
X  } else {
X    return(1);
X  }
X}
X
X/* ***************************************************
X
XName:           setran
X
XPurpose:        This routine sets the random number sequence, checking to see
X		if the seeds are legal.  Prints message to stderr if illegal.
X
XSample Call:    setran(1L,1L,rngstate);
X
XInputs:         long seed1;             starting seed for 1st generator
X                long seed2;             starting seed for 2nd generator
X		long rngstate[2];	where seed1 and seed2 are to be stored
X
XOutputs:        none
X
XReturns:        none
X
XAlgorithm:      copy seed1, seed2 into rngstate[]; call checkran() to
X		confirm that seeds are legal.  Print error message to
X		stderr if illegal.
X
X*************************************************** */
Xvoid setran(seed1, seed2, rngstate)
Xlong seed1, seed2, rngstate[RNGstatesize_3];
X{
X  curr_seed1 = seed1;
X  curr_seed2 = seed2;
X  if ( !checkran(rngstate) ) {
X    fprintf(stderr,"Illegal seed values: %ld, %ld", seed1, seed2); 
X    fflush(stderr);
X  }
X}
X
X/*********************************/
X/* External interface to mrandom */
X/*********************************/
Xlong _lpcrand(RNGdata *rng)
X{
Xreturn(lpcrand(rng->rngstate));
X}
X
Xvoid _lpcrand_seed(rng, seed)
XRNGdata *rng;
Xlong *seed;
X{
Xsetran(seed[0], seed[1], RNGstate);
X}
X
Xint _lpcrand_check(rng)
XRNGdata *rng;
X{
Xreturn(checkran(RNGstate));
X}
X
X#ifdef TEST
X
Xmain()
X{
Xint num;
Xlong dd;
Xint limit;
Xlong rngstate[RNGstatesize_3];
X
X        printf("Testing validity of arithmetic in this implementation\n");
X        printf("of the EXTENDED STANDARD RANDOM NUMBER GENERATOR\n\n");
X
X	printf("Testing error check code.\n");
X	setran(0L,0L,rngstate);
X
X	/* now try a legal seed */
X        setran(1L,1L,rngstate);
X        limit = 10000;
X
X        for(num=0; num<limit; num++) {
X                dd = lpcrand(rngstate);
X                if ((num % 100) == 0) {
X                        printf("\nIteration %d", num);
X                }
X        }
X        printf("\rSeed should be %ld,%ld\n        and is %ld,%ld.\n",
X                PRCHK1, PRCHK2, curr_seed1, curr_seed2);
X        if ((curr_seed1 == PRCHK1) && (curr_seed2 == PRCHK2)) {
X                printf ("Arithmetic is performed correctly.\n");
X        } else {
X                printf ("Arithmetic is performed INCORRECTLY!\n");
X        }
X
X        exit(0);
X}
X
X#endif /* TEST */
X
X/* end of pcrand.c */
END_OF_FILE
if test 9579 -ne `wc -c <'src/pcrand.c'`; then
    echo shar: \"'src/pcrand.c'\" unpacked with wrong size!
fi
# end of 'src/pcrand.c'
fi
if test -f 'src/pcrand.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/pcrand.h'\"
else
echo shar: Extracting \"'src/pcrand.h'\" \(3367 characters\)
sed "s/^X//" >'src/pcrand.h' <<'END_OF_FILE'
X/* pcrand.h 3.1 5/28/93 */
X/* **********************
X
XPurpose:        This file has routines to implement a
X                Combined Prime Multiplicative Congruential
X                Psuedo-Random Number Generator.
X
X		The original algorithms and selection of
X		prime numbers comes from two articles in the
X		Communications of the ACM: June 1988 (v31 #6)
X		the article by Pierre L'Ecuyer called,
X		"Efficient and Portable Combined Random Number Generators"
X		and the October (v31 #10), Stephen Park and Keith Miller
X		"Random Number Generators: Good Ones are Hard to Find."
X
X		This implementation of these algorithms has been released
X		to the Public Domain. 91.03.10; 91.09.25.
X
XAuthor:         Jesse Chisholm
XModified by:	Clark Thomborson, Robert Plotkin
X*/
X
X#ifndef MRANDOM
X#include "mrandom.h"
X#endif
X
X/* constants defining this multiplicative generator */
X#define PRIME1 2147483563L
X#define PRIME2 2147483399L
X
X/* Information for mrandom */
X#define RNGstatesize_3  2
X#define RNGseedsize_3   2
X#define RNGrange_3      (PRIME1-2.0)
X#define RNGreturns_3    RET_LONG
X#define RNGstatetype_3  STATE_LONG
X#define RNGdgen_3      0
X#define RNGlgen_3      _lpcrand
X#define RNGseed_3       _lpcrand_seed
X#define RNGcheck_3      _lpcrand_check
X#define RNGname_3       "(Portable Combined Multiplicative)\n"
X
X
X/* ***************************************************
X
XName:           lpcrand
X
XPurpose:        This is the basic routine for generating
X                random numbers.  The range is 0..(PRIME1-2).
X                The period is humongous.  Roughly 2^62.
X
XSample Call:    l = lpcrand(rngstate);
X
XInputs:         rngstate (array of 2 longs, holding seed1 and seed2)
X
XOutputs:        none
X
XReturns:        long l;  MSBs are random
X
XAlgorithm:      seed1 = seed1 * ROOT1 % PRIME1
X                seed2 = seed2 * ROOT2 % PRIME2
X                U = (seed1 - seed2) mod (PRIME1 - 1)
X		return (U==0 ? (PRIME1 - 1): U)
X
X*/
X
Xlong lpcrand(/* long rngstate[RNGstatesize_3] */);
X
X/* ***************************************************
X
XName:           setran
X
XPurpose:        This routine sets the random number sequence, checking to see
X		if the seeds are legal.  Prints message to stderr if illegal.
X
XSample Call:    setran(1L,1L,rngstate);
X
XInputs:         long seed1;             starting seed for 1st generator
X                long seed2;             starting seed for 2nd generator
X		long rngstate[2];	where seed1 and seed2 are stored
X
XOutputs:        none
X
XReturns:        none
X
XAlgorithm:      copy seed1, seed2 into rngstate[]; call checkran() to
X		confirm that seeds are legal.  Print error message to
X		stderr if illegal.
X
X*************************************************** */
Xvoid setran(/* long seed1, seed2, rngstate[RNGstatesize_3] */);
X
X/* ***************************************************
X
XName:           checkran
X
XPurpose:        This routine returns 1 if the RNG state looks ok.
X
XSample Call:    if ( !checkran(rngstate) ) fprintf(stderr,"RNG unitialized!\n");
X
XInputs:         none
X
XOutputs:        none
X
XReturns:        none
X
XAlgorithm:      Return 1 if 0 < seed1 < PRIME1 and 0 < seed2 < PRIME2,
X		else return 0
X
X*************************************************** */
Xint checkran(/* rngstate[RNGstatesize_3] */);
X
X/* mrandom interface routines */
Xint _lpcrand_check(RNGdata *);
Xlong _lpcrand(/*RNGdata **/);
Xvoid _lpcrand_seed(/*RNGdata *, long **/);
END_OF_FILE
if test 3367 -ne `wc -c <'src/pcrand.h'`; then
    echo shar: \"'src/pcrand.h'\" unpacked with wrong size!
fi
# end of 'src/pcrand.h'
fi
if test -f 'src/ran0.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/ran0.c'\"
else
echo shar: Extracting \"'src/ran0.c'\" \(1462 characters\)
sed "s/^X//" >'src/ran0.c' <<'END_OF_FILE'
X/* ran0.c 3.1 5/28/93 */
X/* Portable Random Number Generator 0 */
X/* From "Portable Random Number Generators */
X/* William H. Press and Saul A Teukolsky */
X/* Computers in Phyics, Vol. 6, No. 5, Sep/Oct 1992 */
X
X/* Ported to C on Athena: January 12, 1993 */
X/* by Robert Plotkin */
X
X#include "ran0.h"
X
X#define IA	16807
X#define IQ	127773
X#define IR	2836
X#define MASK	123459876
X
Xstatic double am=1.0/IM;
X
X/*********************************/
X/* External interface to mrandom */
X/*********************************/
Xdouble _ran0(rng)
XRNGdata *rng;
X{
Xreturn(ran0(RNGstate));
X}
X
Xvoid _ran0_seed(rng, seed)
XRNGdata *rng;
Xlong *seed;
X{
XRNGstate[0]=seed[0];
X}
X
Xint _ran0_check(rng)
XRNGdata *rng;
X{
Xreturn(RNGstate[0] >= 0);
X}
X
X/* "Minimal" random number generator of Park and Miller.  Returns a
X	uniform random deviate between 0.0 and 1.0.  Set or reset
X	idum to any integer value (except the unlikely value mask) to
X	initialize the sequence; idum _must_ not be altered between
X	calls for successive deviates in a sequence */
Xdouble ran0(idum)
Xlong *idum;
X{
Xlong k;
Xdouble ran_num;
X
X(*idum) ^= MASK;	/* XORing with MASK allows use of zero and other simple
X		   bit patterns for idum. */
Xk=(*idum)/IQ;
X(*idum)=IA*((*idum)-k*IQ)-IR*k;	/* Compute idum=mod(IA*idum,IM)
X				   without overflows by Schrage's
X				   method */
Xif (*idum < 0)
X	(*idum)+=IM;
Xran_num=am*(*idum);	/* Convert idum to a floating result */
X(*idum) ^= MASK;	/* Unmask before return */
Xreturn(ran_num);
X}
END_OF_FILE
if test 1462 -ne `wc -c <'src/ran0.c'`; then
    echo shar: \"'src/ran0.c'\" unpacked with wrong size!
fi
# end of 'src/ran0.c'
fi
if test -f 'src/ran0.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/ran0.h'\"
else
echo shar: Extracting \"'src/ran0.h'\" \(1127 characters\)
sed "s/^X//" >'src/ran0.h' <<'END_OF_FILE'
X/* ran0.h 3.1 5/28/93 */
X/* Portable Random Number Generator 0 */
X/* From "Portable Random Number Generators */
X/* William H. Press and Saul A Teukolsky */
X/* Computers in Phyics, Vol. 6, No. 5, Sep/Oct 1992 */
X
X#ifndef MRANDOM
X#include "mrandom.h"
X#endif
X
X#define IM	2147483647
X
X/* Information for mrandom */
X#define RNGstatesize_6    1
X#define RNGseedsize_6     1
X#define RNGrange_6        IM
X#define RNGname_6         "(Press and Teukolsky's ran0)\n"
X#define RNGreturns_6      RET_DOUBLE
X#define RNGstatetype_6    STATE_LONG
X#define RNGdgen_6        _ran0
X#define RNGlgen_6        0
X#define RNGseed_6         _ran0_seed
X#define RNGcheck_6        _ran0_check
X
X/* "Minimal" random number generator of Park and Miller.  Returns a
X	uniform random deviate between 0.0 and 1.0.  Set or reset
X	idum to any integer value (except the unlikely value mask) to
X	initialize the sequence; idum _must_ not be altered between
X	calls for successive deviates in a sequence */
Xdouble ran0(/* long *idum */);
X
X/* mrandom interface routines */
Xdouble _ran0(/*RNGdata **/);
Xvoid _ran0_seed(/*RNGdata *, long **/);
Xint _ran0_check(/*RNGdata **/);
END_OF_FILE
if test 1127 -ne `wc -c <'src/ran0.h'`; then
    echo shar: \"'src/ran0.h'\" unpacked with wrong size!
fi
# end of 'src/ran0.h'
fi
if test -f 'src/ran1.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/ran1.c'\"
else
echo shar: Extracting \"'src/ran1.c'\" \(2161 characters\)
sed "s/^X//" >'src/ran1.c' <<'END_OF_FILE'
X/* ran1.c 3.1 5/28/93 */
X/* Portable Random Number Generator 1 */
X/* From "Portable Random Number Generators */
X/* William H. Press and Saul A Teukolsky */
X/* Computers in Phyics, Vol. 6, No. 5, Sep/Oct 1992 */
X
X/* Ported to C on Athena for use with mrandom: January 13, 1993 */
X/* by Robert Plotkin */
X
X#include "ran1.h"
X
X#define IA	16807
X#define IQ	127773
X#define IR	2836
X#define MASK	123459876
X#define NDIV (1+(IM-1)/NTAB)
X#define EPS 1.2e-7
X#define RNMX 1.0-EPS
X
X#define iy RNGstate[1]
X#define iv (RNGstate+2)
X
Xstatic double am=1.0/IM;
X#define max(a,b) (a>b ? a:b)
X#define min(a,b) (a<b ? a:b)
X
X/*********************************/
X/* External interface to mrandom */
X/*********************************/
X/* "Minimal" random number generator of Park and Miller with */
X /* Bays-Durham shuffled and added safeguards.  Returns a uniform */
X /* random deviate between 0.0 and 1.0 (exclusive of the endpoint */
X /* values).  Call with idum a negative integer to initialize; */
X /* thereafter, do not alter idum between successive deviates in a */
X /* sequence.  RNMX should approximate the largest floating value that */
X /* is less than 1. */
Xdouble _ran1(rng)
XRNGdata *rng;
X{
Xdouble ran_num;
Xlong j,k;
Xlong *idum;
X
Xidum=RNGstate;
X
Xif ((*idum) <=0 || iy==0) { /* Initialize */
X     (*idum)=max(-(*idum),1); /* Be sure to prevent idum = 0 */
X     for (j=NTAB+7;j>=0;j--) { /* Load the shuffle table (after 8 warm-ups) */
X       k=(*idum)/IQ;
X       (*idum)=IA*((*idum)-k*IQ)-IR*k;
X       if ((*idum) < 0) (*idum)+=IM;
X       if (j < NTAB) iv[j]=(*idum);
X     }
X     iy=iv[0];
X     }
X
Xk=(*idum)/IQ; /* Start here when not initializing */
X(*idum)=IA*((*idum)-k*IQ)-IR*k; /* Compute idum=mod(IA*idum,IM) without
X			     overflows by Schrage's method */
Xif ((*idum) < 0) (*idum)+=IM;
Xj=iy/NDIV; /* Will be in the range 0:NTAB-1 */
Xiy=iv[j]; /* Output previously stored value and refill the shuffle table */
Xiv[j]=(*idum);
Xran_num=min(am*iy,RNMX); /* Because users don't expect endpoint values */
X
Xreturn(ran_num);
X}
X
Xvoid _ran1_seed(rng, seed)
XRNGdata *rng;
Xlong *seed;
X{
Xiy=0;
XRNGstate[0]=seed[0];
X}
X
Xint _ran1_check(rng)
XRNGdata *rng;
X{
Xreturn(RNGstate[0] >= 0);
X}
END_OF_FILE
if test 2161 -ne `wc -c <'src/ran1.c'`; then
    echo shar: \"'src/ran1.c'\" unpacked with wrong size!
fi
# end of 'src/ran1.c'
fi
if test -f 'src/ran1.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/ran1.h'\"
else
echo shar: Extracting \"'src/ran1.h'\" \(1148 characters\)
sed "s/^X//" >'src/ran1.h' <<'END_OF_FILE'
X/* ran1.h 3.1 5/28/93 */
X/* Portable Random Number Generator 1 */
X/* From "Portable Random Number Generators */
X/* William H. Press and Saul A Teukolsky */
X/* Computers in Phyics, Vol. 6, No. 5, Sep/Oct 1992 */
X
X#ifndef MRANDOM
X#include "mrandom.h"
X#endif
X
X#define IM	2147483647
X#define NTAB 32
X
X/* Information for mrandom */
X#define RNGstatesize_7    2+NTAB
X#define RNGseedsize_7     1
X#define RNGrange_7        IM
X#define RNGname_7         "(Press and Teukolsky's ran1)\n"
X#define RNGreturns_7      RET_DOUBLE
X#define RNGstatetype_7    STATE_LONG
X#define RNGdgen_7        _ran1
X#define RNGlgen_7        0
X#define RNGseed_7         _ran1_seed
X#define RNGcheck_7        _ran1_check
X
X/* "Minimal" random number generator of Park and Miller.  Returns a
X	uniform random deviate between 0.0 and 1.0.  Set or reset
X	idum to any integer value (except the unlikely value mask) to
X	initialize the sequence; idum _must_ not be altered between
X	calls for successive deviates in a sequence */
Xdouble ran1(/* long *idum */);
X
X/* mrandom interface routines */
Xdouble _ran1(/*RNGdata **/);
Xvoid _ran1_seed(/*RNGdata *, long **/);
Xint _ran1_check(/*RNGdata **/);
END_OF_FILE
if test 1148 -ne `wc -c <'src/ran1.h'`; then
    echo shar: \"'src/ran1.h'\" unpacked with wrong size!
fi
# end of 'src/ran1.h'
fi
if test -f 'src/ran2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/ran2.c'\"
else
echo shar: Extracting \"'src/ran2.c'\" \(2538 characters\)
sed "s/^X//" >'src/ran2.c' <<'END_OF_FILE'
X/* ran2.c 3.1 5/28/93 */
X/* Portable Random Number Generator 2 */
X/* From "Portable Random Number Generators */
X/* William H. Press and Saul A Teukolsky */
X/* Computers in Phyics, Vol. 6, No. 5, Sep/Oct 1992 */
X
X/* Ported to C on Athena for use with mrandom: January 13, 1993 */
X/* by Robert Plotkin */
X
X#include "ran2.h"
X
X#define IM2 2147483388
X#define IMM1 IM1-1
X#define IA1 40014
X#define IA2 40692
X#define IQ1 53668
X#define IQ2 52774
X#define IR1 12211
X#define IR2 3791
X#define NDIV (1+IMM1/NTAB)
X#define EPS 1.2e-7
X#define RNMX 1.0-EPS
X
X#define iy    RNGstate[1]
X#define idum2 RNGstate[2]
X#define iv    (RNGstate+3)
X
Xdouble am=1.0/IM1;
X#define max(a,b) (a>b ? a:b)
X#define min(a,b) (a<b ? a:b)
X
X/*********************************/
X/* External interface to mrandom */
X/*********************************/
X/* Long period (> 2 X 10^18) random number generator of L'Ecuyer with */
X /* Bays-Durham shuffle and added safeguards.  Returns a uniform */
X /* random deviate between 0.0 and 1.0 (exclusive of the endpoint */
X /* values).  Call with idum a negative integer to initialize; */
X /* thereafter, do not alter idum between successive deviates in a */
X /* sequence.  RNMX should approximate the largest floating value */
X /* that is less than 1. */
Xdouble _ran2(rng)
XRNGdata *rng;
X{
Xdouble ran_num;
Xlong j,k;
Xlong *idum;
X
Xidum = RNGstate;
X
Xif ((*idum) <=0 || iy==0) { /* Initialize */
X     (*idum)=max(-(*idum),1); /* Be sure to prevent idum = 0 */
X     for (j=NTAB+7;j>=0;j--) { /* Load the shuffle table (after 8 warm-ups) */
X       k=(*idum)/IQ1;
X       (*idum)=IA1*((*idum)-k*IQ1)-IR1*k;
X       if ((*idum) < 0) (*idum)+=IM1;
X       if (j < NTAB) iv[j]=(*idum);
X     }
X     iy=iv[0];
X     }
X
Xk=(*idum)/IQ1; /* Start here when not initializing */
X(*idum)=IA1*((*idum)-k*IQ1)-IR1*k; /* Compute idum=mod(IA1*idum,IM1) without
X			     overflows by Schrage's method */
Xif ((*idum) < 0) (*idum)+=IM1;
X
Xk=idum2/IQ2; /* Compute idum2=mod(IA2*idum2,IM2) likewise */
Xidum2=IA2*(idum2-k*IQ2)-IR2*k; /* Compute idum=mod(IA1*idum,IM1) without
X			     overflows by Schrage's method */
Xif (idum2 < 0) idum2+=IM2;
X
Xj=iy/NDIV; /* Will be in the range 0:NTAB-1 */
Xiy=iv[j]-idum2; /* Output previously stored value and refill the */
X		/* shuffle table */
Xiv[j]=(*idum);
Xif (iy < 1) iy+=IMM1;
Xran_num=min(am*iy,RNMX); /* Because users don't expect endpoint values */
Xreturn(ran_num);
X}
X
Xvoid _ran2_seed(rng, seed)
XRNGdata *rng;
Xlong *seed;
X{
Xiy=0;
Xidum2=123456789;
XRNGstate[0]=seed[0];
X}
X
Xint _ran2_check(rng)
XRNGdata *rng;
X{
Xreturn(RNGstate[0] >= 0);
X}
END_OF_FILE
if test 2538 -ne `wc -c <'src/ran2.c'`; then
    echo shar: \"'src/ran2.c'\" unpacked with wrong size!
fi
# end of 'src/ran2.c'
fi
if test -f 'src/ran2.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/ran2.h'\"
else
echo shar: Extracting \"'src/ran2.h'\" \(1152 characters\)
sed "s/^X//" >'src/ran2.h' <<'END_OF_FILE'
X/* ran2.h 3.1 5/28/93 */
X/* Portable Random Number Generator 1 */
X/* From "Portable Random Number Generators */
X/* William H. Press and Saul A Teukolsky */
X/* Computers in Phyics, Vol. 6, No. 5, Sep/Oct 1992 */
X
X#ifndef MRANDOM
X#include "mrandom.h"
X#endif
X
X#define IM1 2147483563
X#define NTAB 32
X
X/* Information for mrandom */
X#define RNGstatesize_8    3+NTAB
X#define RNGseedsize_8     1
X#define RNGrange_8        IM1
X#define RNGname_8         "(Press and Teukolsky's ran1)\n"
X#define RNGreturns_8      RET_DOUBLE
X#define RNGstatetype_8    STATE_LONG
X#define RNGdgen_8         _ran2
X#define RNGlgen_8         0
X#define RNGseed_8         _ran2_seed
X#define RNGcheck_8        _ran2_check
X
X/* "Minimal" random number generator of Park and Miller.  Returns a
X	uniform random deviate between 0.0 and 1.0.  Set or reset
X	idum to any integer value (except the unlikely value mask) to
X	initialize the sequence; idum _must_ not be altered between
X	calls for successive deviates in a sequence */
Xdouble ran2(/* long *idum */);
X
X/* mrandom interface routines */
Xdouble _ran2(/*RNGdata **/);
Xvoid _ran2_seed(/*RNGdata *, long **/);
Xint _ran2_check(/*RNGdata **/);
END_OF_FILE
if test 1152 -ne `wc -c <'src/ran2.h'`; then
    echo shar: \"'src/ran2.h'\" unpacked with wrong size!
fi
# end of 'src/ran2.h'
fi
if test -f 'src/rngs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/rngs.h'\"
else
echo shar: Extracting \"'src/rngs.h'\" \(3634 characters\)
sed "s/^X//" >'src/rngs.h' <<'END_OF_FILE'
X/* rngs.h 3.1 5/28/93 */
X/* These are the "built in" rngs */
X/* Robert Plotkin 1/27/93 */
X
X#ifndef MRANDOM
X#include "mrandom.h"
X#endif
X
X/* RNGstate[0] for random(), table length 32 */
X#define MRNGSTATE0	3
X
X/* RNG state sizes */
X#define RNGstatesize_0 1
X#define	RNGstatesize_1 32
X#define	RNGstatesize_4 2
X#define	RNGstatesize_5 1
X
X/* RNG seed sizes */ 
X#define RNGseedsize_0 2
X#define RNGseedsize_1 1
X#define RNGseedsize_4 2
X#define RNGseedsize_5 1
X
X/* RNG output ranges */
X#define RNGrange_0 (MAXLONG+1.0)
X#define RNGrange_1 (MAXLONG+1.0)
X#define RNGrange_4 (MAXLONG+1.0)
X/* According to my Sun man pages, System V unix has a different rand() */
X#ifdef __SYSTEM_FIVE
X#define RNGrange_5 (MAXSHORT+1.0)
X#else
X#define RNGrange_5 (MAXLONG+1.0)
X#endif
X
X/* RNG return types */
X#define RNGreturns_0 4
X#define RNGreturns_1 4
X#define RNGreturns_4 4
X#define RNGreturns_5 4
X
X/* RNG state/seed types */
X#define RNGstatetype_0 STATE_LONG
X#define RNGstatetype_1 STATE_LONG
X#define RNGstatetype_4 STATE_INT
X#define RNGstatetype_5 STATE_LONG
X
X/* Procedures for returning a random number */
X#define RNGdgen_0 0
X#define RNGlgen_0 _triv
X#define RNGdgen_1 0
X#define RNGlgen_1 _random
X#define RNGdgen_4 0
X#define RNGlgen_4 _nrand48
X#define RNGdgen_5 0
X#define RNGlgen_5 _rand
X
X/* RNG seed procedures */
X#define RNGseed_0 _triv_seed
X#define RNGseed_1 _random_seed
X#define RNGseed_4 _nrand48_seed
X#define RNGseed_5 _rand_seed
X
X/* RNG check procedures */
X#define RNGcheck_0 _triv_check
X#define RNGcheck_1 _random_check
X#define RNGcheck_4 _nrand48_check
X#define RNGcheck_5 _rand_check
X
X/* RNG names */
X#define RNGname_0	"(trivial RNG: long state=seed1; state += seed2)\n"
X#define RNGname_1	"(4.3bsd random.c: Non-linear additive feedback)\n"
X#define RNGname_4	"(4.3bsd nrand48.c: 48-bit multiplicative)\n"
X#define RNGname_5	"(4.3bsd rand.c: 32-bit multiplicative)\n"
X
X/********************************/
X/* triv                         */
X/********************************/
X/* A trivial RNG, which can be set up to return a constant or an
X * arithmetic progression.  Can come in handy for debugging. 
X */
Xlong _triv(rng)
XRNGdata *rng;
X{
X  RNGstate[0] += RNGseed[1];
X  RNGstate[0] &= MAXLONG; /* clear sign bit */
X  return(RNGstate[0]);
X}
X
Xvoid _triv_seed(rng, seed)
XRNGdata *rng;
Xlong *seed;
X{
XRNGstate[0] = seed[0];
X}
X
Xint _triv_check(rng)
XRNGdata *rng;
X{
Xreturn(RNGstate[0] >= 0);
X}
X
X/* bsd4.3 random */
Xlong _random(rng)
XRNGdata *rng;
X{
Xreturn(random());
X}
X
Xvoid _random_seed(rng, seed)
XRNGdata *rng;
Xlong *seed;
X{
X/* Call the 4.3bsd random() initialization routine */
Xinitstate(seed[0], RNGstate, RNGstatesize*4);
X}
X
Xint _random_check(rng)
XRNGdata *rng;
X{
Xreturn(RNGstate[0] == MRNGSTATE0);
X}
X
X/* 4.3bsd nrand48 */
Xlong _nrand48(rng)
XRNGdata *rng;
X{
Xreturn(nrand48(RNGstate));
X}
X
Xvoid _nrand48_seed(rng, seed)
XRNGdata *rng;
Xlong *seed;
X{
Xunsigned short *sarray;
X
X/* Copy seeds into the state array */
X  sarray = (unsigned short *) RNGstate;
X  sarray[0] = seed[1]&0xFFFF; /* LSBs of seed */
X  sarray[1] = seed[0]&0xFFFF;
X  sarray[2] = (seed[0]>>16)&0xFFFF; /* MSBs of seed */
X  sarray[3] = 0; /* stuff a 0 into the other half of RNGstate[1] */
X}
X
Xint _nrand48_check(rng)
XRNGdata *rng;
X{
Xunsigned short *sarray;
X
Xsarray = (unsigned short *) RNGstate;
Xreturn(sarray[3] == 0);
X}
X
X/* 4.3bsd rand */
Xlong _rand(rng)
XRNGdata *rng;
X{
X/* Very inefficient for many calls!!! */
Xsrand(RNGstate[0]); /* In case RNGs were switched */
Xreturn(RNGstate[0]=rand());
X}
X
Xvoid _rand_seed(rng, seed)
XRNGdata *rng;
Xlong *seed;
X{
X/* Use ran() */
XRNGstate[0] = seed[0]; /* The srand() call will be made later */
X}
X
Xint _rand_check(rng)
XRNGdata *rng;
X{
Xreturn(RNGstate[0] >= 0);
X}
X
END_OF_FILE
if test 3634 -ne `wc -c <'src/rngs.h'`; then
    echo shar: \"'src/rngs.h'\" unpacked with wrong size!
fi
# end of 'src/rngs.h'
fi
if test -f 'src/script' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/script'\"
else
echo shar: Extracting \"'src/script'\" \(2424 characters\)
sed "s/^X//" >'src/script' <<'END_OF_FILE'
X#! /bin/csh -f
X# script 3.1 5/28/93
X#
X# Make, test, and show some features of the mrandom package.
X#
Xecho "Making..."
Xmake mrtest
Xecho " "
Xecho "Exhibit a problem with the -f method of generating large integers."
Xmrtest -e -f -S1,1 -m100663296 -q 100000
Xecho " "
Xecho "Exhibit a problem with the -p method of generating large integers."
Xmrtest -e -p -m201326592 -q 100000
Xecho " "
Xmake mrtestv
Xecho " "
Xecho "What is the 100,000th output from 4.3bsd random(), seed = 1?"
Xmrtestv -e -S1,1,0,100000 -M31 1
Xecho " "
Xecho "How long does 4.3bsd random() take to generate 1e6 ints"
Xecho "  in 0..99, using vectorized code?" 
Xtime mrtestv -e -t -q -m100 1000000
Xecho " "
Xecho "What is the 100,000th output from Jon Bentley's rng, seed 1?"
Xecho "  Note that Bentley's rng has a range of 1e9."
Xmrtestv -e -S2,1,0,100000 -m1000000000 1
Xecho " "
Xecho "How long does Bentley's RNG take to generate 1e6 ints?"
Xtime mrtestv -e -t -m100 1000000
Xecho " "
Xecho "What is the 100,000th output from the Portable Combined multiplicative"
Xecho "  generator (pcrand), with seeds = (1,2)?"
Xecho "  Note that this rng has a range of 2147483561." 
Xmrtestv -e -S3,1,2,100000 -m2147483561 1
Xecho " "
Xecho "How long does pcrand() take to generate 1e6 ints?"
Xtime mrtestv -e -t -q -m100 1000000
Xecho " "
Xecho "What is the 100,000th output from nrand48 with 48-bit seed = (1<<16)+2?"
Xmrtestv -e -S4,1,2,100000 -M31 1
Xecho " "
Xecho "Exhibit a problem with long-range correlation in nrand48."
Xmrtestv -e -S4,1,2,200001 -M16 -d1023 -q 1000
Xecho " "
Xecho "How long does nrand48() take to generate 1e6 ints?"
Xtime mrtestv -e -t -q -m100 1000000
Xecho " "
Xecho "What is the 100,000th output from 4.3bsd rand, seed = 1?"
Xmrtestv -e -S5,1,0,100000 -M31 1
Xecho " "
Xecho "Exhibit a problem with the low-order bits of rand."
Xmrtestv -e -M31 -q 500
Xecho " "
Xecho "Try the weak equi-distribution test on the low-order bits of rand."
Xmrtestv -e -M31 -q 240000
Xecho " "
Xecho "Exhibit a problem with the middle bits of rand."
Xmrtestv -e -M16 -q 100000
Xecho " "
Xecho "Exhibit a problem with long-range correlation of the MSBs in rand."
Xmrtestv -e -M3 -d1023 -q 500
Xecho " "
Xecho "How long does 4.3bsd rand() take to generate 1e6 ints?  (Who cares?)"
Xtime mrtestv -e -t -q -m100 1000000
Xecho " "
Xecho "Just for fun, observe the catastrophic failures of an additive RNG."
Xmrtestv -e -S0,0,65536 -q -M16 2000
Xecho " "
Xecho "The mrandom exhibition script is complete."
Xexit(0)
END_OF_FILE
if test 2424 -ne `wc -c <'src/script'`; then
    echo shar: \"'src/script'\" unpacked with wrong size!
fi
chmod +x 'src/script'
# end of 'src/script'
fi
if test -f 'src/ultra.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/ultra.c'\"
else
echo shar: Extracting \"'src/ultra.c'\" \(5108 characters\)
sed "s/^X//" >'src/ultra.c' <<'END_OF_FILE'
X/* ultra.c 3.1 5/28/93 */
X/*
XFSU - ULTRA	The greatest random number generator that ever was
X		or ever will be.  Way beyond Super-Duper.
X		(Just kidding, but we think its a good one.)
X
XAuthors:	Arif Zaman (arif@stat.fsu.edu) and
X		George Marsaglia (geo@stat.fsu.edu).
X
XDate:		27 May 1992
X
XVersion:	1.05
X
XCopyright:	To obtain permission to incorporate this program into
X		any commercial product, please contact the authors at
X		the e-mail address given above or at
X
X		Department of Statistics and
X		Supercomputer Computations Research Institute
X		Florida State University
X		Tallahassee, FL 32306.
X
XSee Also:	README		for a brief description
X		ULTRA.DOC	for a detailed description
X
X-----------------------------------------------------------------------
X                Modified by Robert Plotkin for use with mrandom, 4/93
X*/
X/*
X   File: ULTRA.C
X
X   This is the ULTRA random number generator written entirely in C.
X
X   This may serve as a model for an assembler version of this routine.
X   The programmer should avoid simply duplicating and instead use the
X   usual assembler features to increase the speed of this routine.
X
X   Especially the subroutine SWB should be replaced by the one
X   machine instruction (usually called subtract-with-borrow) that
X   is available in almost every hardware.
X
X   For people not familiar with 8086 assembler, it may help to
X   consult this when reading the assembler code. This program should
X   be a dropin replacement for the assembler versions, but is about
X   half as fast.
X*/
X
X#include "ultra.h"
X
X#define N  37           /* size of table        */
X#define N2 24           /* The shorter lag      */
X
X#define swb32   RNGstate
X#define swbseed (RNGstate+N)
X#define swb32p  ((long *)RNGstate[N+N])
X#define swb32n  RNGstate[N+N+1]
X#define flags   ((char)RNGstate[N+N+2]) /* The carry flag for
X					   the SWB generator	*/
X#define congx   ((long unsigned)RNGstate[N+N+3]) /* Seed */
X
X/* SWB is the subtract-with-borrow operation which should be one line
X   in assembler code. This should be done by using the hardware s-w-b
X   operation in the SWBfill routine.
X
X   What has been done here is to look at the msb of x, y and z=x-y-c.
X   Using these three bits, one can determine if a borrow bit is needed
X   or not according to the following table:
X
X	msbz=0  msby=0  msby=1          msbz=1  msby=0  msby=1
X
X	msbx=0  0       1               msbx=0  1       1
X	msbx=1  0       0               msbx=1  0       1
X
X   PS: note that the definition is very carefully written because the
X   calls to SWB have y and z as the same memory location, so y must
X   be tested before z is assigned a value.
X*/
X#define SWB(c,x,y,z) \
Xc = (y<0) ? (((z=x-y-c) < 0) || (x>=0)) : (((z=x-y-c) < 0) && (x>=0))
X
X/*
X  The first two lines of this macro are the heart of the system and
X  should be written is assembler to be as fast as possible. It may even
X  make sense to unravel the loop and simply write 37 consecutive SWB
Xoperations!  */
Xvoid SWBfill(x,rng)
Xlong *x;
XRNGdata *rng;
X{ short i;
X
X  for (i=0;  i<N2; i++) SWB(flags,swbseed[i+N-N2],swbseed[i],swbseed[i]);
X  for (i=N2; i<N;  i++) SWB(flags,swbseed[i  -N2],swbseed[i],swbseed[i]);
X  for (i=0;  i<N;  i++) *(x++) = swbseed[i] ^ (congx = congx * 69069);
X}
X
Xlong swb32fill(rng)
XRNGdata *rng;
X{ long temp;
X  swb32p = swb32;
X  SWBfill(swb32,rng);
X  swb32n = N-1;
X  return *(swb32p++);
X}
X
Xlong  i32bit(rng)
XRNGdata *rng;
X{ return  (swb32n--) ? *(swb32p++) : swb32fill(rng); }
X
Xlong  i31bit(rng)
XRNGdata *rng;
X{ return ((swb32n--) ? *(swb32p++) : swb32fill(rng)) & 0x7FFFFFFF; }
X
X#define two2neg31  ( (2.0/0x10000) / 0x10000 )
X#define two2neg32  ( (1.0/0x10000) / 0x10000 )
X
X/*********************************/
X/* External interface to mrandom */
X/*********************************/
Xdouble _uni(rng)
XRNGdata *rng;
X{
X  long temp;
X
X  temp = i31bit(rng);
X  if (temp & 0xFF000000) { return temp * two2neg31; }
X  return (temp + i32bit(rng) * two2neg32) * two2neg31;
X}
X
X/* rinit initializes the constants and fills the seed array one bit at
X   a time by taking the leading bit of the xor of a shift register
X   and a congruential sequence. The same congruential generator continues
X   to be used as a mixing generator for the Subtract-with-borrow generator
X   to produce the `ultra' random numbers
X
X   Since this is called just once, speed doesn't matter much and it might
X   be fine to leave this subroutine coded just as it is.
X
X   PS:	there are quick and easy ways to fill this, but since random number
X	generators are really "randomness amplifiers", it is important to
X	start off on the right foot. This is why we take such care here.
X*/
Xvoid _rinit(rng, seed)
XRNGdata *rng;
Xunsigned long *seed;
X{
X  short i,j;
X  unsigned long tidbits;
X  unsigned long congy, shrgx;
X
X  congy=seed[0];
X  shrgx=seed[1];
X
X  congx=congy*2+1;
X  for (i=0;i<N;i++) {
X    for (j=32;j>0;j--) {
X      congx = congx * 69069;
X      shrgx = shrgx ^ (shrgx >> 15);
X      shrgx = shrgx ^ (shrgx << 17);
X      tidbits = (tidbits>>1) | (0x80000000 & (congx^shrgx));
X    }
X    swbseed[i] = tidbits;
X  }
X  swb32n = 0;
X  flags = 0;
X}
X
Xint _ultra_check(rng)
XRNGdata *rng;
X{
Xreturn(1);
X}
END_OF_FILE
if test 5108 -ne `wc -c <'src/ultra.c'`; then
    echo shar: \"'src/ultra.c'\" unpacked with wrong size!
fi
# end of 'src/ultra.c'
fi
if test -f 'src/ultra.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/ultra.h'\"
else
echo shar: Extracting \"'src/ultra.h'\" \(1436 characters\)
sed "s/^X//" >'src/ultra.h' <<'END_OF_FILE'
X/* ultra.h 3.1 5/28/93 */
X/*
XFSU - ULTRA	The greatest random number generator that ever was
X		or ever will be.  Way beyond Super-Duper.
X		(Just kidding, but we think its a good one.)
X
XAuthors:	Arif Zaman (arif@stat.fsu.edu) and
X		George Marsaglia (geo@stat.fsu.edu).
X
XDate:		27 May 1992
X
XVersion:	1.05
X
XCopyright:	To obtain permission to incorporate this program into
X		any commercial product, please contact the authors at
X		the e-mail address given above or at
X
X		Department of Statistics and
X		Supercomputer Computations Research Institute
X		Florida State University
X		Tallahassee, FL 32306.
X
XSee Also:	README		for a brief description
X		ULTRA.DOC	for a detailed description
X
X-----------------------------------------------------------------------
X                Modified by Robert Plotkin for use with mrandom, 4/93 
X*/
X
X#ifndef MRANDOM
X#include "mrandom.h"
X#endif
X
X#define N  37   /* size of table */
X#define N2 24   /* The shorter lag */
X
X/* Information for mrandom */
X#define RNGstatesize_9  N*2+4
X#define RNGseedsize_9   2
X#define RNGrange_9      4294967296.0
X#define RNGname_9       "Marsaglia's Ultra\n"
X#define RNGreturns_9    RET_DOUBLE
X#define RNGstatetype_9  STATE_LONG
X#define RNGdgen_9      _uni
X#define RNGlgen_9      0
X#define RNGseed_9       _rinit
X#define RNGcheck_9      _ultra_check
X
X/* mrandom interface routines */
Xdouble _uni(/*RNGdata **/);
Xvoid _rinit(/*RNGdata *, long **/);
Xint _ultra_check(/*RNGdata **/);
END_OF_FILE
if test 1436 -ne `wc -c <'src/ultra.h'`; then
    echo shar: \"'src/ultra.h'\" unpacked with wrong size!
fi
# end of 'src/ultra.h'
fi
if test -f 'src/xsq.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/xsq.c'\"
else
echo shar: Extracting \"'src/xsq.c'\" \(8127 characters\)
sed "s/^X//" >'src/xsq.c' <<'END_OF_FILE'
X/* xsq.c 3.1 5/28/93 */
X/* xsq.c: routines for interpreting X-squared test statistics
X * 
X * Author: Clark Thomborson
X * Original version (named chisq.c): May 1992
X * Revised July 1992 to be more accurate on the extreme upper tail:
X *   now uses Wallace's approximation, and Thomborson's multinomial
X *   correction.
X */
X
X#include <math.h>
X
X#define min(x,y)	( ((x)<(y)) ? (x) : (y) )
X#define max(x,y)	( ((x)>(y)) ? (x) : (y) )
X#define LOG2PI		1.837877		/* log(2*pi) */
X
Xdouble t; /* temp for efficient evaluation of squares and cubes by macro */
X#define square(x)	( t=(x), t*t )
X#define cube(x)		( t=(x), t*t*t )
X
X/* Evaluate an X-squared variate xsq (for n items placed in k bins,
X * with all bins equi-probable), returning the number of standard
X * deviations the equivalent normal deviate differs from its expectation.
X * That is, if this function returns -2.326, the xsq value is at the
X * p=0.01 point of its distribution.
X *
X * The value of *approx is set to 1 if the calculated stddev has more than
X * 10% relative error.
X *
X * See Thomborson's SODA '93 submission for an explanation of this code.
X */
Xdouble xsq_to_stddev(xsq,k,n,approx)
Xdouble xsq,k,n;
Xint *approx;
X{
X  double stddev,v,wsq,w,a,keff,twologp,u;
X
X  xsq = xsq + k/n;  /* apply a "continuity correction" */
X  v = k-1.0; /* degrees of freedom in Chi-squared approximation */
X  /* Wallace's approximation */
X  wsq = xsq - v - v*log(xsq/v);
X  if (wsq<0.0) wsq=0.0; /* avoid sqrt(-0.0), as a result of round-off errors */
X  w = sqrt(wsq);
X  a = sqrt(2.0/v)/3.0;
X  if (xsq <= v) { /* lower tail: use Wallace's approx */
X    stddev = -w+a;
X  } else { /* upper tail: min(multinomial approx, Wallace's approx) */
X    keff = k/(1.0+xsq/n) * (1.0 - exp(-(xsq+n)/k));
X    twologp = (2.0*n - 1.0 - 2.0*keff) * log(k/keff) - 2.0*keff + LOG2PI;
X    /* if twologp is small, make it huge (so it won't affect the output) */
X    if (twologp < 2.83) twologp = 1000.0;
X    /* convert 2*log(p) to (approx.) quantile of normal distribution */
X    u = sqrt(twologp - log(twologp - LOG2PI) - LOG2PI);
X    stddev = min(u,w+a);
X  }
X  if (fabs(stddev) > n/sqrt(2.0*v)) {
X    *approx = 1;
X  } else {
X    *approx = 0;
X  }
X  return(stddev);
X}
X
X/* Print a low-precision float, using "%f" format where possible.
X * Uses "%f" format if this would print at most 3 significant digits;
X * otherwise uses "%.2g".  Always prints at least 2 significant digits,
X * never prints more than 3.
X */
Xprint2digits(f)
Xdouble f;
X{
X  double a;
X  a = fabs(f);
X  if (a > 1000.0)
X    printf("%#.2g", f);
X  else if (a > 10.0)
X    printf("%.0f", f);
X  else if (a > 1.0)
X    printf("%.1f", f);
X  else if (a > 0.1)
X    printf("%.2f", f);
X  else if (a > 0.01)
X    printf("%.3f", f);
X  else
X    printf("%#.2g", f);
X}
X
X/* Print a message describing the significance of a test statistic = xsq
X * computed by placing n items into k bins, with each bin equally likely.
X *
X * The estimate of the number of standard deviations can be inaccurate
X * for small df, moderate or small n, and large +/- stddev.  The symbol
X * "~" instead of "=" appears in the print line in these cases.
X *
X * If n is too small, a message is printed indicating that little can be
X * concluded from this xsq statistic.
X */
Xextern void interpret_xsq(xsq,k,n)
Xdouble xsq, k, n;
X{
X  double stddev;/* temp for calculating # of std devations */
X  int i; /* loop counter */
X  int robust; /* true if we can do a 2-tailed test with p < 1e-6 */
X  int accurate; /* true if the stddev estimate is accurate */ 
X  double nrobust,ngiveup; /* min n to give (robust,adequate) test results */
X  double smallxsq; /* temp for nrobust and ngiveup calculations */
X
X  /* Give a diagnostic message if some parameter value is ridiculous */
X  if (k < 2.0 || xsq < 0.0 || n < 1.0) {
X    printf("Argument error in interpret_xsq(%f,%f,%f)!\n",xsq,k,n);
X    exit(1);
X  }
X
X  /* I have two tests for small n.  The less restrictive test, below,
X   * checks whether the computed, continuity-corrected xsq value
X   * could ever fall below the 5% point on the Chi-squared distribution.
X   * In all cases, if there is a xsq outcome below the 5% point, there
X   * are (many) above the 95% point, so a two-sided test is reasonably
X   * accurate.
X   *
X   * The smallest xsq value is (n mod k)(k - (n mod k))/n.  For the case
X   * of n > k, a monotone envelope is
X   *		smallestxsq1 = k^2/(4*n)
X   * For the case of n <= k, the smallest xsq value is just
X   * 		smallestxsq2 = k - n
X   * We thus use max(smallestxsq1, smallestxsq2) =
X   * 		smallxsq = max(k-n, k*k/(4*max(n,k)) )
X   * as a monotone envelope for this function.
X   *
X   * My "ngiveup" calculation evaluates smallxsq for n = (3*sqrt(k))*(1.1)^i,
X   * for i=0,1,... until the resulting xsq_to_stddev value falls below -1.645.
X   * The factor of 1.1 implies that we'll overshoot the smallest possible
X   * value of ngiveup by at most 10%.  (Alternatively, we could symbolically
X   * invert the calculations in the xsq_to_stddev() function, perhaps
X   * approximating in terms of a power series.  This would take a lot
X   * of my time: I'd rather let your CPU do a bit of extra work when
X   * evaluating ngiveup.) 
X   *
X   * For large k, ngiveup is 3*sqrt(k).  For very small k, ngiveup 
X   * is moderately large: 725 at k=2, 51 at k=3, 24 at k=4, 17 at k=5,
X   * 13 at k=6, ..., 11 at k = 10, then rising with 3*sqrt(k) for k>10.
X   */
X
X  ngiveup = ceil(3.0*sqrt(k));
X  for (i=0; i<500; i++) {
X    smallxsq = max(k-ngiveup, k*k/(4*max(ngiveup,k)) );
X    if (xsq_to_stddev(smallxsq,k,ngiveup,&accurate) < -1.645) break;
X    ngiveup = ceil(ngiveup*1.1);
X  }
X
X  /* My nrobust calculation is similar to the ngiveup calculation,
X   * except that the cutoff probability is 0.5*10^{-6}, i.e. the
X   * stddev value must fall below -4.892.  This allows an xsq value
X   * to be rejected at the 1-in-a-million level.
X   *
X   * is 60; for k = 10, nrobust is 182; for k == 5, nrobust is about
X   * 5600; for k == 3, nrobust is approximately 10^7; for k == 2,
X   * nrobust is about 3*10^{13}.  For k >= 50, nrobust < k.
X   *
X   * Perhaps I should use only a 1-tailed test on xsq for k<4,
X   * since a 2-tailed test with small failure probability requires
X   * an ``unreasonably-large'' amount of data.
X   *
X   * The statistician's "rule of thumb" for Chi-squared testing
X   * is n >= 5*k, which is much larger than my nrobust for large k,
X   * and much smaller than my ngiveup for small k.  I have found
X   * no reason to test for n >= 5*k.  Indeed, Kendall and Stuart
X   * (Vol 2, 2nd ed, p. 440) say there is "No general theoretical
X   * basis for this rule."
X   */
X
X  nrobust = ceil(7.0*sqrt(k));
X  for (i=0; i<500; i++) {
X    smallxsq = max(k-nrobust, k*k/(4*max(nrobust,k)) );
X    if (xsq_to_stddev(smallxsq,k,nrobust,&accurate) < -4.892) break;
X    nrobust = ceil(nrobust*1.1);
X  }
X
X  /* quit if sample is too small */
X  if (n<ngiveup) {
X    printf("  This test requires ");
X    print2digits(ngiveup);
X    printf(" or more random generates.\n");
X    return;
X  }
X
X  if (n<nrobust) {
X    printf("  Note: at least ");
X    print2digits(nrobust);
X    printf(" random generates are needed\n");
X    printf("    for a two-tailed test with confidence p > 1-1.0e-6\n");
X  };
X
X  printf("  X^2 = ");
X  print2digits(xsq);
X  printf(", k = ");
X  print2digits(k);
X  printf(", equivalent normal standard deviation ");
X  printf(accurate? "= " : "~ ");
X  stddev = xsq_to_stddev(xsq,k,n,&accurate);
X  print2digits(stddev);
X  printf("\n", stddev);
X
X  if (fabs(stddev) > 6.1) {
X    printf("\n");
X    printf("  THIS RNG IS FAULTY!  Confidence level p > 1-1.0e-9\n");
X    printf("\n");
X  } else if (fabs(stddev) > 4.9) {
X    printf("\n");
X    printf("  This rng is faulty!  Confidence level p > 1-1.0e-6\n");
X    printf("\n");
X  } else if (fabs(stddev) > 2.6) {
X    printf("\n");
X    printf("  This rng may be faulty.  Confidence level p > 1-1.0e-3\n");
X    printf("\n");
X  } else {
X    printf("  This message should appear ");
X    if (!accurate) {
X      printf("about ");
X    }
X    if (fabs(stddev) > 1.645) {
X      printf("10%% of the time.\n");
X    } else {
X      printf("90%% of the time.\n");
X    }
X  }
X} /* end interpret_xsq */
X
X/* end of xsq.c */
END_OF_FILE
if test 8127 -ne `wc -c <'src/xsq.c'`; then
    echo shar: \"'src/xsq.c'\" unpacked with wrong size!
fi
# end of 'src/xsq.c'
fi
if test -f 'src/xsq.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/xsq.h'\"
else
echo shar: Extracting \"'src/xsq.h'\" \(885 characters\)
sed "s/^X//" >'src/xsq.h' <<'END_OF_FILE'
X/* xsq.h 3.1 5/28/93 */
X/* xsq.h: header for xsq.c, giving access to a routine for 
X * printing interpretations of X-squared test statistics
X * 
X * Author: Clark Thomborson
X * Original version (named chisq.c): May 1992
X * Revised July 1992 to be more accurate on the extreme upper tail:
X *   now uses Wallace's approximation, and Thomborson's multinomial
X *   correction.
X */
X
X
Xvoid interpret_xsq(/* double xsq,k,n; */);
X/* Print a message describing the significance of a test statistic = xsq
X * computed by placing n items into k bins, with each bin equally likely.
X *
X * The estimate of the number of standard deviations can be inaccurate
X * for small df, moderate or small n, and large +/- stddev.  The word
X * "approx." appears in the print line in these cases.
X *
X * If n is too small, a message is printed indicating that little can be
X * concluded from this xsq statistic.
X */
END_OF_FILE
if test 885 -ne `wc -c <'src/xsq.h'`; then
    echo shar: \"'src/xsq.h'\" unpacked with wrong size!
fi
# end of 'src/xsq.h'
fi
echo shar: End of archive 1 \(of 6\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
