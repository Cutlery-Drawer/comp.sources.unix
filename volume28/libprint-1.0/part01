Newsgroups: comp.sources.unix
From: schwartz@galapagos.cse.psu.edu (Scott Schwartz)
Subject: v28i206: libprint-1.0 -- extensible and dynamic string formatting library, Part01/01
Message-id: <1.785820768.17753@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: schwartz@galapagos.cse.psu.edu (Scott Schwartz)
Posting-Number: Volume 28, Issue 206
Archive-Name: libprint-1.0/part01

libprint 1.0 --

The routines in this library format strings similarly to the printf
family of functions.  They are better in the following ways:

	* they are small and efficient 
		(about 5K on a sparc)
	* user installable format specifiers 
		(e.g. %I to print an ip quad given a struct in_addr*)
	* you can print into dynamically allocated memory
		(using either malloc or a user supplied allocation function)
	* they are reentrant
		(as all good code should be)

This code is derived from Paul Haahr's print library, which is part of
Byron Rakitzis' popular implementation of the rc shell.  This release
cleans up a number of bugs, makes everything reentrant, and adds a
uniform set of entry points.

This package doesn't do floating point conversions, although they would
be easy to add.  

To compile, edit the makefile.  It is organized for SunOS 4.1; on other
systems you will want to alter or elide the shared library stuff.
You'll need an ansi compiler.

There are a number of test programs included; see them for examples
if you don't want to read the manpage.

-- Scott Schwartz <schwartz@cse.psu.edu>

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  COPYRIGHT blurb print.3 print.c mprint.c conv.c print.h
#   makefile .depend t1.c t2.c t3.c t4.c t5.c
# Wrapped by schwartz@galapagos on Thu Nov 24 17:59:30 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'COPYRIGHT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'COPYRIGHT'\"
else
echo shar: Extracting \"'COPYRIGHT'\" \(1136 characters\)
sed "s/^X//" >'COPYRIGHT' <<'END_OF_FILE'
X/*
X * Copyright 1994 Paul Haahr, Scott Schwartz, Byron Rakitzis.
X * All rights reserved.
X *
X * This software is not subject to any license of the American Telephone
X * and Telegraph Company or of the Regents of the University of California.
X *
X * Permission is granted to anyone to use this software for any purpose on
X * any computer system, and to alter it and redistribute it freely, subject
X * to the following restrictions:
X *
X * 1. The author is not responsible for the consequences of use of this
X *    software, no matter how awful, even if they arise from flaws in it.
X *
X * 2. The origin of this software must not be misrepresented, either by
X *    explicit claim or by omission.  Since few users ever read sources,
X *    credits must appear in the documentation.
X *
X * 3. Altered versions must be plainly marked as such, and must not be
X *    misrepresented as being the original software.  Since few users
X *    ever read sources, credits must appear in the documentation.
X *
X * 4. This notice may not be removed or altered.
X *
X *    [this copyright notice is adapted from Henry Spencer's
X *    "awf" copyright notice.]
X */
END_OF_FILE
if test 1136 -ne `wc -c <'COPYRIGHT'`; then
    echo shar: \"'COPYRIGHT'\" unpacked with wrong size!
fi
# end of 'COPYRIGHT'
fi
if test -f 'blurb' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'blurb'\"
else
echo shar: Extracting \"'blurb'\" \(1085 characters\)
sed "s/^X//" >'blurb' <<'END_OF_FILE'
X
Xlibprint 1.0 --
X
XThe routines in this library format strings similarly to the printf
Xfamily of functions.  They are better in the following ways:
X
X	* they are small and efficient 
X		(about 5K on a sparc)
X	* user installable format specifiers 
X		(e.g. %I to print an ip quad given a struct in_addr*)
X	* you can print into dynamically allocated memory
X		(using either malloc or a user supplied allocation function)
X	* they are reentrant
X		(as all good code should be)
X
XThis code is derived from Paul Haahr's print library, which is part of
XByron Rakitzis' popular implementation of the rc shell.  This release
Xcleans up a number of bugs, makes everything reentrant, and adds a
Xuniform set of entry points.
X
XThis package doesn't do floating point conversions, although they would
Xbe easy to add.  
X
XTo compile, edit the makefile.  It is organized for SunOS 4.1; on other
Xsystems you will want to alter or elide the shared library stuff.
X
XThere are a number of test programs included; see them for examples
Xif you don't want to read the manpage.
X
X-- Scott Schwartz <schwartz@cse.psu.edu>
END_OF_FILE
if test 1085 -ne `wc -c <'blurb'`; then
    echo shar: \"'blurb'\" unpacked with wrong size!
fi
# end of 'blurb'
fi
if test -f 'print.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'print.3'\"
else
echo shar: Extracting \"'print.3'\" \(8009 characters\)
sed "s/^X//" >'print.3' <<'END_OF_FILE'
X.\"
X.\" $Id: print.3,v 1.10 1994/07/27 04:05:11 schwartz Exp $ -*-nroff-*-
X.\"
X.TH PRINT 3
X.SH NAME
Xprint \- string formatting and printing library
X.SH SYNOPSYS
X.LP
X.nf
X.ft B
X#include <print.h>
X.ft
X.fi
X.LP
X.nf
Xtypedef struct Format Format;
Xtypedef int (*Fmtconv)(Format *, int);
X
Xstruct Format {
X	/* for the formatting routines */
X	va_list args;
X	long flags, f1, f2;
X	Fmtconv* fmttab;
X	/* for the buffer maintainence routines */
X	char *buf, *bufbegin, *bufend;
X	int flushed;
X	int (*grow)(Format *, SIZE_T);
X	int error;
X	union { int n; void *p; } u;
X	/* misc */
X	void* client_data;
X};
X.fi
X.LP
X.nf
Xint print (const char *fmt,...)
Xint eprint (const char *fmt,...)
Xint fprint (int fd, const char *fmt,...)
Xint vfprint (int fd, const char *fmt, va_list)
X.fi
X.LP
X.nf
Xint sprint (char *buf, const char *fmt,...)
Xint snprint (char *buf, int buflen, const char *fmt,...)
Xint vsnprint (char *buf, int buflen, const char *fmt, va_list)
X.fi
X.LP
X.nf
Xchar *mprint (const char *fmt,...)
Xchar *smprint (Alloc alloc, SIZE_T* len, const char* fmt, ...)
Xchar *vsmprint (Alloc alloc, SIZE_T* len, const char* fmt, va_list)
Xchar *palloc (char* p, SIZE_T size)
X.fi
X.LP
X.nf
XFmtconv fmtinstall (int c, Fmtconv f)
X.fi
X.LP
X.nf
Xint fmtputc (Format *f, const char c)
Xint fmtappend (Format *format, const char *s, SIZE_T len)
Xint fmtcat (Format *format, const char *s)
X.fi
X.LP
X.nf
Xint fmtengine (Format *format, const char *fmt)
Xint fmtprint (Format *format, const char *fmt,...)
X.fi
X.SH SUMMARY
XThese routines format strings similarly to the printf family of
Xfunctions.  Unlike printf, they support user supplied format specifiers,
Xthey can format into memory that is allocated as needed (using a user
Xsupplied allocation function), they are reentrant (except for errno, the
Xglobal table of format specifiers, and possibly malloc if you choose to
Xuse it), and they are 8 bit clean ('\\0' bytes can be printed).
XPrint is also space efficient.  The program text is about 5K
Xwhen compiled for a sparc.
X
X.B fprint
Xwrites formatted text to a file descriptor
Xand returns the number of bytes written, or -1 on error.
X.B print
Xwrites text to stdout
Xwhile
X.B eprint
Xwrites text to stderr.
X.B vfprint
Xformats arguments supplied in a
X.I va_list
Xobtained from
X.B stdargs.
X
X.B sprint
Xwrites text into a user supplied buffer.  It writes at most
XFMT_SPRINT_BUFSIZ bytes including the terminating '\\0'.  It returns
Xthe number of bytes written, or -1 on error.
X.B snprint
Xwrites at most 
X.I n
Xbytes into a user supplied buffer.
X.B vsnprint
Xdoes the same, but takes its  arguments from a
X.I va_list.
X
X.B mprint
Xformats into a dynamically allocated buffer, to which it returns
Xa pointer.
XThe space is obtained
Xfrom 
X.B malloc
Xand should be freed when no longer needed.
X.B smprint
Xtakes a user supplied allocation function as an argument.  This
Xfunction should behave as ANSI-\fBrealloc\fP
Xdoes.  Some pre-ANSI systems' realloc fails to treat
Xrealloc(0,\fIn\fP)
Xas equivalent to
Xmalloc(\fIn\fP),
Xso we provide a routine
X.B palloc
Xwhich does.
Xsmprint also returns the number of bytes generated by writing
Xinto the *len argument if it is a non-null pointer.
X.B vsmprint
Xis like smprint, but that it reads arguments from a va_list.
X
X.B fmtinstall
Xinstalls a user supplied conversion function for a given character,
Xand returns the old value.  A conversion function takes a pointer
Xto a format structure and the character that induced the call.
XIt must return FMT_flag if the format character signals
Xsetting a flag and FMT_verb if it signals performing a conversion.
X
XA conversion function can use 
X.B fmtappend
Xor
X.B fmtputc
Xto put new text into the output buffer.
X.B fmtcat
Xis supplied for convenience.
X
X.B fmtengine 
Xis the entry point for the actual formatting engine.  Given a properly
Xinitialized format structure and a format string, it will do the 
Xspecified work.  
X
X.B fmtprint 
Xis a very general interface to 
X.B fmtengine.
XIts arguments are a properly initialized format structure, a format
Xstring, and a matching number of parameters.  
X.B fmtprint
Xsaves and restores the argument list stored in the format structure, so
Xit can be used inside a conversion function to perform arbitrary
Xformatting operations.  This usage avoids the temporary buffers
Xthat 
X.B fmtappend
Xwould require.
X.B fmtengine
Xand 
X.B fmtprint
Xreturn the number of characters that they generated.
X
X.LP
XThe format structure contains three kinds of information.
XFirst, variables used by the formatting routines.
XThese are:
X.I args,
Xthe argument list containing the data to be formatted.
X.I flags, 
Xa bitmask storing the flags set at the time each conversion
Xfunction is called.  Possible values are given in print.h.
X.I "f1, f2"
Xare the field width and precision of each conversion.
XThe flags, f1, and f2 are zeroed before each conversion begins.
X.I "fmttab"
Xis a pointer to the per-format array of conversion functions, indexed
Xby conversion character.  If it is
Xzero, the global table will be used instead.
X
XSecond, variables used for buffer maintainance:
XThese are:
X.I "buf, bufbegin, bufend",
Xpointers to the insertion point in the output buffer, 
Xthe buffer itself, and the end of the buffer.
X.I "flushed",
Xthe number of characters that have been transmitted to their
Xultimate destination thus far.
X.I "grow", 
Xthe buffer growing function, called when the buffer is nearly full
Xso that it can be flushed or reallocated.
X.I "error",
Xnonzero if an error has occurred during formatting.
XFormatting will stop after the first error is noticed.
X.I "u.n, u.p",
Xthe name of the file descriptor to write to, or the
Xrealloc function to call to resize a buffer.
X
XFinally,
X.I "client_data"
Xprovides access to other arguments
Xin a reentrant way.
X
X.LP
XA simple format function, the one for  %c, looks like this:
X
X.nf
Xstatic int cconv(Format *format, int c) {
X    fmtputc(format, va_arg(format->args, int));
X    return FMT_verb;
X}
X.fi
X.LP
XA more interesting example is a conversion function that formats
Xa string with all unprintable characters quoted as in C.
X
X.nf
Xint print_cquote_conv (Format* format, int c)
X{
X    unsigned char* s = va_arg (format->args, unsigned char*);
X    unsigned char ch;
X
X    while ((ch = *s++)) {
X	if (isascii (ch) && isalnum (ch)) {
X	    if (ch == '\\\\')
X		fmtputc (format, ch);
X	    fmtputc (format, ch);
X	} else {
X	    fmtprint (format, "\\\\%03uo", ch);
X	}
X    }
X    return FMT_verb;
X}
X.fi
X
X
X.SH STANDARD CONVERSIONS
X.SS verbs
X.LP
X.PD 0
X.TP 10
X.B %
XA literal percent.
X.TP
X.B s
XA string.  With the # flag, use f2 for size and don't assume '\\0' termination.
X.TP
X.B c
XA single character.
X.TP
X.B "d, i"
XA decimal integer.
X.TP
X.B o
XAn octal integer. With #, prefix 0.
X.TP
X.B x
XA hex integer. With #, prefix 0x.
X.TP
X.B "e, f, g"
XFloating point conversions (not implemented).
X.TP
X.B "r, m"
Xsys_errlist[errno].  With # flag, errno.
X.TP
X.B "n"
Xwrites the number of characters emitted thus far into into an
Xint* argument.
X.PD
X.SS flags
X.PD 0
X.TP 10
X.B u
XArg is unsigned.
X.TP
X.B h
XArg is short.
X.TP
X.B l
XArg is long.
X.TP
X.B q
XArg is quad (not implemented).
X.TP
X.B #
XSelect alternate output format.
X.TP
X.B -
XLeft justify output.
X.TP
X.B 0
XZero pad output.
X.TP
X.B 1-9
XSet the f1 (field width) specifier.
X.TP
X.B .
XThe f2 (precision) specifier follows.
X.TP
X.B *
XSet f1 or f2 from int arg.
X.PD
X.LP
X
X.SH NOTES
XUnlike printf, flags like 'u' need to be followed by a verb like 'd'.
X
XThis code is derived from the print routines  that Paul Haahr wrote for
XByron Rakitzis' implementation of
X.I rc.
X
X.SH AUTHORS
X.LP
XPaul Haahr, 
XByron Rakitzis,
XScott Schwartz.
X
X.SH BUGS
X.LP
XWhat to do when an invalid print char is detected?  BSD printf emits
Xthe character without comment.  We print a warning to stderr and stop
Xformatting.
X.LP
XThe namespace
Xfor installable format specifiers
Xis very small, so collisions and mistakes will probably cause trouble.
X.LP
XNo floating point conversion functions (%e, %f, %g) yet.
X.LP
XQuadword conversions (%qd) would be nice too.
X.LP
XDoes %d really work in boundary cases (signed/unsigned long/int/short
Xmaxint, minint)?
X.LP
Xfmtputc feels kludgy.
END_OF_FILE
if test 8009 -ne `wc -c <'print.3'`; then
    echo shar: \"'print.3'\" unpacked with wrong size!
fi
# end of 'print.3'
fi
if test -f 'print.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'print.c'\"
else
echo shar: Extracting \"'print.c'\" \(12965 characters\)
sed "s/^X//" >'print.c' <<'END_OF_FILE'
X/* print.c -- formatted printing routines */
X/* this by Scott Schwartz, derived from Paul Haahr's version of 12/91 */
X
Xstatic const char rcsid[] = 
X"@(#)$Id: print.c,v 1.32 1994/10/17 01:15:32 schwartz Exp $";
X
X#include <unistd.h>
X#include <stdlib.h>
X#include <stdarg.h>
X#include <string.h>
X#include <errno.h>
X#include "print.h"
X
X#ifdef __GNUC__
Xextern void * memcpy (void *, const void *, long unsigned int);
X#endif
X
X/*
X * functions for inserting strings in the format buffer
X */
X
X#if !defined __GNUC__ || defined __STRICT_ANSI__
X#define inline /* */
X#endif
X
Xinline /*extern*/ int fmtputc (Format *f, const char c) {
X    if (f->error)
X	return 0;
X    if (f->buf >= f->bufend)
X	if ((*f->grow)(f, 1))
X	    return 0;
X    *f->buf++ = c;
X    return 1;
X}
X
Xextern int fmtappend (Format *format, const char *s, SIZE_T len) {
X    if (format->error)
X	return 0;
X    while (len > format->bufend - format->buf) {
X	SIZE_T split = format->bufend - format->buf;
X	memcpy (format->buf, s, split);
X	format->buf += split;
X	s += split;
X	len -= split;
X	if ((*format->grow)(format, len))
X	    return 0;
X    }
X    memcpy (format->buf, s, len);
X    format->buf += len;
X    return 1;
X}
X
Xextern int fmtcat (Format *format, const char *s) {
X    return fmtappend (format, s, strlen (s));
X}
X
X/*
X * conversion functions
X *	true return -> flag changes only, not a conversion
X */
X
X#define Flag(name, flag) \
Xstatic int name (Format *format, int c) { \
X	format->flags |= flag; \
X	return FMT_flag; \
X}
X
XFlag (uconv,	FMT_unsigned)
XFlag (hconv,	FMT_short)
XFlag (lconv,	FMT_long)
XFlag (altconv,	FMT_altform)
XFlag (leftconv,	FMT_leftside)
XFlag (dotconv,	FMT_f2set)
X
Xstatic int digitconv (Format *format, int c) {
X    if (format->flags & FMT_f2set)
X	format->f2 = 10 * format->f2 + c - '0';
X    else {
X	format->flags |= FMT_f1set;
X	format->f1 = 10 * format->f1 + c - '0';
X    }
X    return FMT_flag;
X}
X
Xstatic int zeroconv (Format *format, int c) {
X    if (format->flags & (FMT_f1set | FMT_f2set))
X	return digitconv (format, '0');
X    format->flags |= FMT_zeropad;
X    return FMT_flag;
X}
X
Xstatic int starconv (Format *format, int c) {
X    int n = va_arg (format->args, int);
X    if (format->flags & FMT_f2set)
X	format->f2 = n;
X    else {
X	format->flags |= FMT_f1set;
X	format->f1 = n;
X    }
X    return FMT_flag;
X}
X
Xstatic void pad (Format *format, SIZE_T len, int c) {
X    do; while (len-- != 0 && fmtputc (format, c));
X}
X
Xstatic int sconv (Format *format, int c) {
X    SIZE_T maxbytes, minwidth, extra;
X    char *s = va_arg (format->args, char *);
X
X    if (!s) s = "(null)";
X
X    if (format->flags & FMT_altform) {
X	maxbytes = (format->flags & FMT_f2set) ? format->f2 : strlen (s);
X	/* maxbytes may overrun s,  but this way we don't have 
X	   to assume that s is null terminated when f2 is set. 
X	   Maybe use a different format character for this? */
X    } else {
X	/* do f2 like printf */
X	maxbytes = strlen (s);
X	if ((format->flags & FMT_f2set) && (format->f2 < maxbytes))
X	    maxbytes = format->f2;
X    }
X
X    minwidth = (format->flags & FMT_f1set) ? format->f1 : maxbytes;
X    extra = (minwidth > maxbytes) ? minwidth - maxbytes : 0;
X
X    if (format->flags & FMT_leftside) {
X	fmtappend (format, s, maxbytes);
X	pad (format, extra, ' ');
X    } else {
X	pad (format, extra, ' ');
X	fmtappend (format, s, maxbytes);
X    }
X	
X    return FMT_verb;
X}
X
Xstatic char *utoa (unsigned long u, 
X		  char *t, unsigned int radix, const char *digit) {
X    if (u >= radix) {
X	t = utoa (u / radix, t, radix, digit);
X	u %= radix;
X    }
X    *t++ = digit[u];
X    return t;
X}
X
Xstatic void intconv (Format *format, 
X		    unsigned int radix, int upper, const char *altform) {
X    static const char * const table[] = {
X	"0123456789abcdefghijklmnopqrstuvwxyz",
X	"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
X    };
X    char padchar;
X    SIZE_T len, pre, zeroes, padding, width;
X    long n, flags;
X    unsigned long u;
X    char number[64], prefix[20];
X
X    if (radix > 36)
X	return;
X
X    flags = format->flags;
X    if (flags & FMT_unsigned) {
X	if (flags & FMT_long)
X	    n = (unsigned long) va_arg (format->args, long);
X	else if (flags & FMT_short)
X	    n = (unsigned long)(unsigned short) va_arg (format->args, int);
X	else
X	    n = (unsigned long)(unsigned int) va_arg (format->args, int);
X    } else {
X	if (flags & FMT_long)
X	    n = (long) va_arg (format->args, long);
X	else if (flags & FMT_short)
X	    n = (long)(short) va_arg (format->args, int);
X	else
X	    n = (long) va_arg (format->args, int);
X    }
X
X    pre = 0;
X    if ((flags & FMT_unsigned) || n >= 0)
X	u = n;
X    else {
X	prefix[pre++] = '-';
X	u = -n;
X    }
X
X    if (flags & FMT_altform)
X	while (*altform != '\0')
X	    prefix[pre++] = *altform++;
X
X    len = utoa (u, number, radix, table[upper]) - number;
X    if ((flags & FMT_f2set) && (SIZE_T) format->f2 > len)
X	zeroes = format->f2 - len;
X    else
X	zeroes = 0;
X
X    width = pre + zeroes + len;
X    if ((flags & FMT_f1set) && (SIZE_T) format->f1 > width) {
X	padding = format->f1 - width;
X    } else
X	padding = 0;
X
X    padchar = ' ';
X    if (padding > 0 && flags & FMT_zeropad) {
X	padchar = '0';
X	if ((flags & FMT_leftside) == 0) {
X	    zeroes += padding;
X	    padding = 0;
X	}
X    }
X
X    if ((flags & FMT_leftside) == 0)
X	pad (format, padding, padchar);
X    fmtappend (format, prefix, pre);
X    pad (format, zeroes, '0');
X    fmtappend (format, number, len);
X    if (flags & FMT_leftside)
X	pad (format, padding, padchar);
X}
X
Xstatic int cconv (Format *format, int c) {
X    fmtputc (format, va_arg (format->args, int));
X    return FMT_verb;
X}
X
Xstatic int dconv (Format *format, int c) {
X    intconv (format, 10, 0, "");
X    return FMT_verb;
X}
X
Xstatic int oconv (Format *format, int c) {
X    intconv (format, 8, 0, "0");
X    return FMT_verb;
X}
X
Xstatic int xconv (Format *format, int c) {
X    intconv (format, 16, 0, "0x");
X    return FMT_verb;
X}
X
Xstatic int litconv (Format *format, int c) {
X    fmtputc (format, c);
X    return FMT_verb;
X}
X
Xextern int fmt_badconv (Format *format, int c) {
X    eprint ("libprint: bad conversion char '%c'\n", c);
X    format->error = 1; /* XXX - stop or not? consume an argv? */
X    return FMT_verb;
X}
X
Xstatic int nconv (Format* format, int c)
X{
X    /* write the current write length into an int* argument */
X    int *p = va_arg (format->args, int*);
X    if (p) *p = format->buf - format->bufbegin + format->flushed;
X    return FMT_verb;
X}
X
Xstatic int rconv (Format *format, int c) {
X    int e = errno;
X    /* do we have to store errno in the format structure because
X       the grow proc could make a syscall that sets errno before
X       we get here? */
X
X    if (format->flags & FMT_altform) {
X	fmtprint (format, "%d", e);
X    } else {
X	/* strerror() might be better, but this way we can range check */
X        extern int sys_nerr;
X        extern char* sys_errlist[];
X	if ((0 <= e) && (e < sys_nerr)) 
X	    fmtcat (format, sys_errlist[e]);
X	else
X	    fmtprint (format, "unknown error (%d)", e);
X    }
X    return FMT_verb;	
X}
X
X/*
X * conversion table management
X */
X
Xstatic Fmtconv dflt_fmttab[FMT_MAXCONV];
X
Xstatic Fmtconv* ensure_inittab (Fmtconv fmttab[])
X{
X    int i;
X
X    if (fmttab[0] != 0)
X	return fmttab;
X
X    for (i = 0; i < FMT_MAXCONV; i++)
X	fmttab[i] = fmt_badconv;
X
X    fmttab['%'] = litconv;
X
X    fmttab['s'] = sconv;
X    fmttab['c'] = cconv;
X    fmttab['d'] = dconv;
X    fmttab['i'] = dconv;
X    fmttab['o'] = oconv;
X    fmttab['x'] = xconv;
X    fmttab['r'] = rconv;
X    fmttab['m'] = rconv;
X    fmttab['n'] = nconv;
X
X    fmttab['u'] = uconv;
X    fmttab['h'] = hconv;
X    fmttab['l'] = lconv;
X    fmttab['#'] = altconv;
X    fmttab['-'] = leftconv;
X    fmttab['.'] = dotconv;
X    fmttab['*'] = starconv;
X
X    fmttab['0'] = zeroconv;
X    for (i = '1'; i <= '9'; i++)
X	fmttab[i] = digitconv;
X
X    return fmttab;
X}
X
Xextern Fmtconv fmtinstall (int c, Fmtconv f)
X{
X    Fmtconv oldf;
X
X    ensure_inittab (dflt_fmttab);
X    c &= FMT_MAXCONV - 1;
X    oldf = dflt_fmttab[c];
X    if (f != 0)
X	dflt_fmttab[c] = f;
X    return oldf;
X}
X
X/* --- */
X
Xstatic void fmtinitbuf (Format *format, 
X			char *buf, SIZE_T size, int (*grow)(Format *, SIZE_T))
X{
X    format->buf      = buf;
X    format->bufbegin = buf;
X    format->bufend   = buf + size;
X    format->grow     = grow;
X    format->flushed  = 0;
X    format->error    = 0;
X}
X
Xstatic void fmtinitarg (Format *format, 
X			va_list args, Fmtconv* fmttab, void* client_data)
X{
X    format->args = args;
X    format->fmttab = 0;
X    format->client_data = 0;
X}
X		     
X/*
X * the formatting engine
X */
X
Xextern int fmtengine (Format *format, const char *fmt)
X{
X    const unsigned char *s = (const unsigned char *) fmt;
X    Fmtconv* fmttab;
X 
X    if ((fmttab = format->fmttab) == 0)
X        fmttab = ensure_inittab (dflt_fmttab);
X
X    for (;;) {
X	int c = *s++;
X
X	switch (c) {
X	case '%':
X	    format->flags = format->f1 = format->f2 = 0;
X	    do
X		c = *s++;
X	    while ((*fmttab[c])(format, c) == FMT_flag);
X	    if (!format->error)
X		break;
X	    /* else FALLTHRU and return */
X	case '\0':
X	    return format->buf - format->bufbegin + format->flushed;
X	default:
X	    fmtputc (format, c);
X	    break;
X	}
X    }
X}
X
X
X/*
X * the public entry points
X */
X
Xextern int fmtprint (Format *format, const char *fmt,...) {
X    int n = -format->flushed;
X    va_list ap, saveargs;
X
X    va_start (ap, fmt);
X    saveargs = format->args;
X    format->args = ap;
X    n += fmtengine (format, fmt);
X    va_end (format->args);
X    format->args = saveargs;
X
X    return n + format->flushed;
X}
X
X/* --- */
X
Xstatic int writeall (int fd, char *buf, SIZE_T n) {
X    int i, remain;
X
X    for (i = 0, remain = n; remain > 0; buf += i, remain -= i)
X	if ((i = write (fd, buf, remain)) <= 0)
X	    if ((errno == EAGAIN) || (errno = EWOULDBLOCK))
X		continue;
X	    else
X		break;
X
X    return n - remain;
X}
X
X/* --- */
X
Xextern int fmt_fprint_flush (Format *format, SIZE_T more) {
X    SIZE_T n = format->buf - format->bufbegin;
X    SIZE_T r;
X
X    r = writeall (format->u.n, format->bufbegin, n);
X    format->flushed += r;
X    format->buf -= r;
X    format->error |= (r != n);
X
X    return format->error;
X}
X
Xextern int vfprint (int fd, const char *fmt, va_list ap) {
X    char buf[1024];
X    Format format;
X
X    fmtinitbuf (&format, buf, sizeof buf, fmt_fprint_flush);
X    fmtinitarg (&format, ap, 0, 0);
X    format.u.n = fd;
X
X    fmtengine (&format, fmt);
X    fmt_fprint_flush (&format, 0);
X    return format.error ? -1 : format.flushed;
X}
X
Xextern int fprint (int fd, const char *fmt,...) {
X    int n;
X    va_list ap;
X
X    va_start (ap, fmt);
X    n = vfprint (fd, fmt, ap);
X    va_end (ap);
X    return n;
X}
X
Xextern int print (const char *fmt,...) {
X    int n;
X    va_list ap;
X
X    va_start (ap, fmt);
X    n = vfprint (1, fmt, ap);
X    va_end (ap);
X    return n;
X}
X
Xextern int eprint (const char *fmt,...) {
X    int n;
X    va_list ap;
X
X    va_start (ap, fmt);
X    n = vfprint (2, fmt, ap);
X    va_end (ap);
X    return n;
X}
X
X/* --- */
X
Xextern int fmt_memprint_grow (Format *format, SIZE_T more) {
X    char *buf = 0;
X    SIZE_T len = format->bufend - format->bufbegin + 1;
X    len = (len >= more)
X	? len * 2 
X        : ((len + more) + FMT_PRINT_ALLOCSIZE) &~ (FMT_PRINT_ALLOCSIZE - 1);
X
X    buf = ((Alloc)format->u.p)(format->bufbegin, len);
X    if (buf) {
X	format->buf	 = buf + (format->buf - format->bufbegin);
X	format->bufbegin = buf;
X	format->bufend   = buf + len - 1;
X	return 0;
X    }
X    return format->error = 1;
X}
X
Xextern char *fmt_memprint (Format *format, const char *fmt, SIZE_T* len) {
X    char* buf;
X    int n;
X
X    buf = (*(Alloc)format->u.p) (0, FMT_PRINT_ALLOCSIZE);
X    if (!buf) {
X	format->error = 1;
X	return 0;
X    }
X
X    fmtinitbuf (format, buf, FMT_PRINT_ALLOCSIZE - 1, fmt_memprint_grow);
X    n = fmtengine (format, fmt);
X    *format->buf = '\0';
X    if (len) *len = n;
X
X    return format->error ? 0 : format->bufbegin;
X}
X
Xextern char *vsmprint (Alloc a, SIZE_T* len, const char* fmt, va_list ap) {
X    Format format;
X
X    fmtinitarg (&format, ap, 0, 0);
X    format.u.p = (void*) a;
X
X    return fmt_memprint (&format, fmt, len);
X}
X
Xextern char *smprint (Alloc alloc, SIZE_T* len, const char* fmt, ...) {
X    char* result;
X    va_list ap;
X
X    va_start (ap, fmt);
X    result = vsmprint (alloc, len, fmt, ap);
X    va_end (ap);
X    return result;
X}
X
X/* note -- moved palloc and mprint to mprint.c */
X
X/* --- */
X
Xextern int fmt_snprint_grow (Format *format, SIZE_T more) {
X    return 1;
X}
X
Xextern int vsnprint (char *buf, int buflen, const char *fmt, va_list ap) {
X    int n;
X    Format format;
X
X    fmtinitbuf (&format, buf, buflen - 1, fmt_snprint_grow);
X    fmtinitarg (&format, ap, 0, 0);
X    format.args = ap;
X
X    n = fmtengine (&format, fmt);
X    *format.buf = '\0';
X    return format.error ? -n : n;
X}
X
Xextern int snprint (char *buf, int buflen, const char *fmt,...) {
X    int n;
X    va_list ap;
X
X    va_start (ap, fmt);
X    n = vsnprint (buf, buflen, fmt, ap);
X    va_end (ap);
X    return n;
X}
X
Xextern int sprint (char *buf, const char *fmt,...) {
X    int n;
X    va_list ap;
X
X    va_start (ap, fmt);
X    n = vsnprint (buf, FMT_SPRINT_BUFSIZ, fmt, ap);
X    va_end (ap);
X    return n;
X}
END_OF_FILE
if test 12965 -ne `wc -c <'print.c'`; then
    echo shar: \"'print.c'\" unpacked with wrong size!
fi
# end of 'print.c'
fi
if test -f 'mprint.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mprint.c'\"
else
echo shar: Extracting \"'mprint.c'\" \(475 characters\)
sed "s/^X//" >'mprint.c' <<'END_OF_FILE'
X#include <stdlib.h>
X#include "print.h"
X
Xstatic const char rcsid[] = 
X"@(#)$Id: mprint.c,v 1.3 1994/10/15 19:37:26 schwartz Exp $";
X
X/* this is what ansi realloc does, but not e.g. sunos realloc */
Xextern char* palloc (char* p, SIZE_T size) {
X    return p ? realloc(p, size) : malloc(size);
X}
X
Xextern char *mprint(const char *fmt,...) {
X    char* result;
X    va_list ap;
X
X    va_start(ap, fmt);
X    result = vsmprint (palloc, 0, fmt, ap);
X    va_end(ap);
X    return result;
X}
END_OF_FILE
if test 475 -ne `wc -c <'mprint.c'`; then
    echo shar: \"'mprint.c'\" unpacked with wrong size!
fi
# end of 'mprint.c'
fi
if test -f 'conv.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'conv.c'\"
else
echo shar: Extracting \"'conv.c'\" \(1288 characters\)
sed "s/^X//" >'conv.c' <<'END_OF_FILE'
X/* miscellaneous conversion functions for the print library */
X
Xstatic const char rcsid[] =
X"@(#)$Id: conv.c,v 1.9 1994/10/15 19:37:26 schwartz Exp $";
X
X#include <netdb.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <netinet/in.h>
X#include <arpa/inet.h>
X#include <ctype.h>
X#include "print.h"
X
X/* %I prints a struct in_addr* in dotted quad form */
X
Xint print_inaddr_conv(Format *format, int c) 
X{
X    struct in_addr* in;
X
X    in = va_arg (format->args, struct in_addr*);
X    if (in)
X	fmtcat (format, inet_ntoa (*in));
X    else
X	fmtcat (format, "0.0.0.0");
X    return FMT_verb;
X}
X
X/* %Q writes a string quoted for reading by /bin/rc */
X
Xint print_rcquote_conv (Format* format, int c)
X{
X    unsigned char* s = va_arg (format->args, unsigned char*);
X    unsigned char ch;
X
X    while ((ch = *s++)) {
X	if (ch == '\'') 
X	    fmtputc (format, ch);
X	fmtputc (format, ch);
X    }
X    return FMT_verb;
X}
X
Xint print_cquote_conv (Format* format, int c)
X{
X    unsigned char* s = va_arg (format->args, unsigned char*);
X    unsigned char ch;
X
X    /* XXX - ignores f1 and f2 */
X    while ((ch = *s++)) {
X	if (isascii (ch) && isalnum (ch)) {
X	    if (ch == '\\')
X		fmtputc (format, ch);
X	    fmtputc (format, ch);
X	} else {
X	    fmtprint (format, "\\%03uo", ch);
X	}
X    }
X    return FMT_verb;
X}
END_OF_FILE
if test 1288 -ne `wc -c <'conv.c'`; then
    echo shar: \"'conv.c'\" unpacked with wrong size!
fi
# end of 'conv.c'
fi
if test -f 'print.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'print.h'\"
else
echo shar: Extracting \"'print.h'\" \(2621 characters\)
sed "s/^X//" >'print.h' <<'END_OF_FILE'
X/* from rc 1.4 - code by Byron and Paul */
X#ifndef __nicer_print_h
X#define __nicer_print_h
X
X#include <stdarg.h>
X
X#ifndef SIZE_T
Xtypedef unsigned long int SIZE_T;
X#endif
X
Xenum {
X  /* return values of conversion functions */
X  FMT_flag = 0,			/* uhl#-.[0-9] */
X  FMT_verb = 1,			/* scdoxr */
X  FMT_error = 2,  		/* error during formatting */
X
X  /* sizes of various things */
X  FMT_MAXCONV = 256,	  	/* number of conversion characters */
X  FMT_PRINT_ALLOCSIZE = 64,	/* grow by this many bytes when necessary */
X  FMT_SPRINT_BUFSIZ = 1024	/* bytes */
X};
X
Xtypedef char* (*Alloc)(char *, SIZE_T);
X
Xtypedef struct Format Format;
Xtypedef int (*Fmtconv)(Format *, int);
X
Xstruct Format {
X	/* for the formatting routines */
X	va_list args;
X	long flags, f1, f2;
X	Fmtconv* fmttab;
X	/* for the buffer maintainence routines */
X	char *buf, *bufbegin, *bufend;
X	int flushed;
X	int (*grow)(Format *, SIZE_T);
X	int error;
X	union { int n; void *p; } u;
X	/* for the sake of reentrancy */
X	void* client_data;
X};
X
X/* Format->flags values */
Xenum {
X	FMT_long	= (1<<0),	/* %l */
X	FMT_short	= (1<<1),	/* %h */
X	FMT_unsigned	= (1<<2),	/* %u */
X	FMT_zeropad	= (1<<3),	/* %0 */
X	FMT_leftside	= (1<<4),	/* %- */
X	FMT_altform	= (1<<5),	/* %# */
X	FMT_f1set	= (1<<6),	/* %<n> */
X	FMT_f2set	= (1<<7)	/* %.<n> */
X};
X
Xextern int fmtputc(Format *f, const char c);
Xextern int fmtappend(Format *format, const char *s, SIZE_T len);
Xextern int fmtcat(Format *format, const char *s);
Xextern Fmtconv fmtinstall(int c, Fmtconv f);
Xextern int fmtengine(Format *format, const char *fmt);
Xextern int fmtprint(Format *format, const char *fmt,...);
Xextern int fmt_fprint_flush (Format *format, SIZE_T more);
Xextern int vfprint(int fd, const char *fmt, va_list ap);
Xextern int fprint(int fd, const char *fmt,...);
Xextern int print(const char *fmt,...);
Xextern int eprint(const char *fmt,...);
Xextern char *fmt_memprint (Format *format, const char *fmt, SIZE_T* len);
Xextern int fmt_memprint_grow (Format *format, SIZE_T more);
Xextern char *vsmprint (Alloc a, SIZE_T* len, const char* fmt, va_list ap);
Xextern char *smprint (Alloc alloc, SIZE_T* len, const char* fmt, ...);
Xextern int fmt_snprint_grow (Format *format, SIZE_T more);
Xextern char* palloc (char* p, SIZE_T size);
Xextern char *mprint(const char *fmt,...);
Xextern int vsnprint(char *buf, int buflen, const char *fmt, va_list ap);
Xextern int snprint(char *buf, int buflen, const char *fmt,...);
Xextern int sprint(char *buf, const char *fmt,...);
X
Xextern int print_inaddr_conv (Format*, int);
Xextern int print_cquote_conv (Format*, int);
Xextern int print_rcquote_conv (Format*, int);
X
X#endif /* __nicer_print_h */
END_OF_FILE
if test 2621 -ne `wc -c <'print.h'`; then
    echo shar: \"'print.h'\" unpacked with wrong size!
fi
# end of 'print.h'
fi
if test -f 'makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile'\"
else
echo shar: Extracting \"'makefile'\" \(1189 characters\)
sed "s/^X//" >'makefile' <<'END_OF_FILE'
XDEST=/usr/local	# /{lib,man,include}
X
XCC=gcc
X#CFLAGS=-fkeep-inline-functions -O2 -g -Wall
XCFLAGS=-O2 -g -Wall
XPIC=-fpic
X
X#CC=acc
X#CFLAGS=-O2
X#PIC=-pic
X
XLDFLAGS=-L. -lprint
XREV=1.0
X
XCO=co
XCOFLAGS=
X
XSRC=print.c mprint.c conv.c
XOBJ=print.o mprint.o conv.o
XHDR=print.h
XMAN=print.3
XLIB=libprint.a libprint.so.$(REV)
X
Xall: $(LIB) test
X
Xtest: t1 t2 t3 t4
Xt1 t2 t3 t4: $(LIB)
X
Xlibprint.a: $(OBJ)
X	$(AR) rcv libprint.a $(OBJ)
X	ranlib libprint.a
X
Xlibprint.so.$(REV): shared $(OBJ)
X	cd shared; ld -assert pure-text $(OBJ) -o ../$@
X
Xinstall:
X	install -m 644 libprint.so.$(REV) $(DEST)/lib
X	install -m 644 libprint.a $(DEST)/lib
X	ranlib  -t $(DEST)/lib/libprint.a
X	install -m 644 $(MAN) $(DEST)/man/man3
X	install -m 644 print.h $(DEST)/include
Xclean:
X	delete -f *.o a.out *.a *.s *.so.* t? *~ shared/*
Xdepend:
X	gcc -MM $(CFLAGS) $(SRC) >.depend
Xshar:
X	shar COPYRIGHT blurb $(MAN) $(SRC) $(HDR) makefile .depend t*.c >print.shar
X
Xshared:
X	mkdir shared
X
X%.o: %.c
X	rm -f $*.o shared/$*.o
X	$(CC) $(CFLAGS) $(PIC) -c $< && mv $*.o shared
X	$(CC) $(CFLAGS) -c $<
X%.s: %.c
X	$(CC) $(CFLAGS) -S -c $<
X%: %.c
X	$(CC) $(CFLAGS) $< -o $@ $(LDFLAGS)
X%:: RCS/%,v
X	test -f $@ || $(CO) $(COFLAGS) $< $@
X
Xinclude .depend
END_OF_FILE
if test 1189 -ne `wc -c <'makefile'`; then
    echo shar: \"'makefile'\" unpacked with wrong size!
fi
# end of 'makefile'
fi
if test -f '.depend' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'.depend'\"
else
echo shar: Extracting \"'.depend'\" \(81 characters\)
sed "s/^X//" >'.depend' <<'END_OF_FILE'
Xprint.o : print.c print.h 
Xmprint.o : mprint.c print.h 
Xconv.o : conv.c print.h 
END_OF_FILE
if test 81 -ne `wc -c <'.depend'`; then
    echo shar: \"'.depend'\" unpacked with wrong size!
fi
# end of '.depend'
fi
if test -f 't1.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'t1.c'\"
else
echo shar: Extracting \"'t1.c'\" \(2633 characters\)
sed "s/^X//" >'t1.c' <<'END_OF_FILE'
X#include <errno.h>
X#include <netdb.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/time.h>
X#include <sys/resource.h>
X#include <netinet/in.h>
X#include <arpa/inet.h>
X
X#include "print.h"
X
Xextern int print_inaddr_conv(Format*,int);
X
Xchar junk[9000];
X
Xvoid main(int argc, char**argv)
X{
X  struct in_addr* in = 0;
X  struct rlimit rl;
X  long int i, j;
X  unsigned long int u;
X  short int h;
X  unsigned short int uh;
X
X  fmtinstall('I', print_inaddr_conv);
X
X  if (argc > 1) {
X      rl.rlim_cur = rl.rlim_max = 1024 * atoi(argv[1]);
X      if (setrlimit (RLIMIT_DATA,&rl) < 0)
X	  eprint("setrlimit: %r");
X  }
X  
X  for (i = 0; i < sizeof(junk); ++i) 
X    junk[i] = (i&63) + ' ';
X  junk[sizeof(junk) - 1] = 0;
X
X  /* print nuls */
X  print ("%c%c\n", 0, 0);
X
X  /* test badconv */
X  print ("%Z", 0);
X
X  /* integers */
X  print("%d %#xd %0d %10.5d\n", 3,4,5,6);
X
X  /* nconv */
X  print ("%s\n%n", "foo", &i);
X  print ("len=%d\n", i);
X
X  /* print ip quads */
X  { struct hostent* h;
X    for (h = gethostbyname ("globin.cse.psu.edu"); 
X	h && *h->h_addr_list; h->h_addr_list++) {
X      in = (struct in_addr*) *h->h_addr_list;
X      print("g=%#ux [%I]\n", in->s_addr, in);
X    }
X  }
X
X  /* print errno */
X  for (errno = 0; errno < 10; ++errno) {
X    i = print("error %#r: %r");
X    print(" (%d)\n", i);
X  }
X  errno = 345; i = print("error %#r: %r"); print(" (%d)\n", i);
X
X
X  /* indirect field specs */
X  for (i = 0; i < 10; ++i)
X	for (j = 0; j < 5; ++j)
X		print ("%*.*s\n", i, j, "12345");
X
X  for (i = 0; i < 10; ++i)
X	for (j = 0; j < 10; ++j)
X		print ("%*.*d\n", i, j, 12345);
X
X  /* short conversions */
X  uh = 55555;  h = -12345;
X  print("-12345 %hd\n55555 %uhd\n", h, uh);
X
X  h = 32766; print("32766 %hd\n", h);
X  h = 32767; print("32767 %hd\n", h);
X  h = 32768; print("32768 %hd\n", h);
X  h = 32769; print("32769 %hd\n", h);
X  
X  uh = 32766; print("32766 %uhd\n", uh);
X  uh = 32767; print("32767 %uhd\n", uh);
X  uh = 32768; print("32768 %uhd\n", uh);
X  uh = 32769; print("32769 %uhd\n", uh);
X
X  h = -3; print("-3 %hd\n", h);
X  h = -2; print("-2 %hd\n", h);
X  h = -1; print("-1 %hd\n", h);
X  h = -0; print("-0 %hd\n", h);
X
X  uh = -3; print("-3 %hd\n", uh);
X  uh = -2; print("-2 %hd\n", uh);
X  uh = -1; print("-1 %hd\n", uh);
X  uh = -0; print("-0 %hd\n", uh);
X
X  i = fprint(1, "junk=%s\n", junk);
X
X  /* force extra memory allocations */
X  print(">>> %s\n", 
X	smprint(palloc, (SIZE_T*)&i,
X		"%d %s %s %s %I %d %r\n", 
X		strlen(junk), junk, "\n===\n", "\n---\n", in, 12312) );
X  print("rc=%d %r\n", i);
X
X  i = fprint(1, "!!! %d %s %s %s %I %d %r\n", 
X	 strlen(junk), junk, "\n===\n", "\n---\n", in, 12312);
X  print("rc=%d\n", i);
X  _exit(0);
X}
END_OF_FILE
if test 2633 -ne `wc -c <'t1.c'`; then
    echo shar: \"'t1.c'\" unpacked with wrong size!
fi
# end of 't1.c'
fi
if test -f 't2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'t2.c'\"
else
echo shar: Extracting \"'t2.c'\" \(191 characters\)
sed "s/^X//" >'t2.c' <<'END_OF_FILE'
X#include "print.h"
X
Xint main()
X{
X    char buf[32];
X    int i;
X
X    i = snprint (buf, sizeof buf, "123456789012345678901234567890");
X    print ("snprint (%s) -> %d\n", buf, i);
X    exit(0);
X}
END_OF_FILE
if test 191 -ne `wc -c <'t2.c'`; then
    echo shar: \"'t2.c'\" unpacked with wrong size!
fi
# end of 't2.c'
fi
if test -f 't3.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'t3.c'\"
else
echo shar: Extracting \"'t3.c'\" \(2848 characters\)
sed "s/^X//" >'t3.c' <<'END_OF_FILE'
X#include <time.h>
X#include "print.h"
X
Xvoid free (void*);
X
XFmtconv date_tab[FMT_MAXCONV];
X
X/* XXX - expose these things from print.c? */
X
Xstatic int badconv (Format *format, int c) {
X    eprint ("dateconv: bad conversion char '%c'\n", c);
X    format->error = 1;
X    return FMT_verb;
X}
X
Xstatic int litconv (Format *format, int c) {
X    fmtputc (format, c);
X    return FMT_verb;
X}
X
X/* XXX - expose intconv() instead? */
X
Xstatic void put_int02 (Format* format, int i)
X{
X    Fmtconv* save = format->fmttab;
X    format->fmttab = 0;
X    fmtprint (format, "%02d", i);
X    format->fmttab = save;
X}
X
Xstatic int dconv (Format *format, int c)
X{
X    struct tm* tm = (struct tm*) format->client_data;
X    put_int02 (format, tm->tm_mday);
X    return FMT_verb ;
X}
X
Xstatic int mconv (Format *format, int c)
X{
X    struct tm* tm = (struct tm*) format->client_data;
X    put_int02 (format, tm->tm_mon+1);
X    return FMT_verb ;
X}
X
Xstatic int yconv (Format *format, int c)
X{
X    struct tm* tm = (struct tm*) format->client_data;
X    put_int02 (format, tm->tm_year);
X    return FMT_verb ;
X}
X
Xstatic int Dconv (Format *format, int c)
X{
X    fmtprint (format, "%m/%d/%y");
X    return FMT_verb ;
X}
X
Xstatic int Hconv (Format *format, int c)
X{
X    struct tm* tm = (struct tm*) format->client_data;
X    put_int02 (format, tm->tm_hour);
X    return FMT_verb ;
X}
X
Xstatic int Mconv (Format *format, int c)
X{
X    struct tm* tm = (struct tm*) format->client_data;
X    put_int02 (format, tm->tm_min);
X    return FMT_verb ;
X}
X
Xstatic int Sconv (Format *format, int c)
X{
X    struct tm* tm = (struct tm*) format->client_data;
X    put_int02 (format, tm->tm_sec);
X    return FMT_verb ;
X}
X
Xstatic int Tconv (Format *format, int c)
X{
X    fmtprint (format, "%H:%M:%S");
X    return FMT_verb ;
X}
X
Xstatic void init_date_tab ()
X{
X    int i;
X    Fmtconv* fmttab = date_tab;
X
X    for (i = 0; i < FMT_MAXCONV; i++)
X	fmttab[i] = badconv;
X
X    fmttab['%'] = litconv;
X
X    fmttab['d'] = dconv;	/* day of month */
X    fmttab['m'] = mconv;	/* month */
X    fmttab['y'] = yconv;	/* year */
X    fmttab['D'] = Dconv;	/* %m/%d/%y */
X
X    fmttab['H'] = Hconv;	/* hour */
X    fmttab['M'] = Mconv;	/* min */
X    fmttab['S'] = Sconv;	/* sec */
X    fmttab['T'] = Tconv;	/* %H:%M:%S */
X}
X
Xchar* format_date (time_t clock, char* fmt)
X{
X    struct tm tm = *gmtime (&clock);
X    Format format;
X  
X    format.buf      = 0;
X    format.bufbegin = 0;
X    format.bufend   = 0;
X    format.flushed  = 0;
X    format.error    = 0;
X
X    format.args     = 0;
X    format.u.p      = (void*)palloc;
X    format.grow     = fmt_memprint_grow;
X    format.fmttab   = date_tab;
X    format.client_data = &tm;
X
X    if (date_tab[0] == 0)
X	init_date_tab ();
X
X    return fmt_memprint (&format, fmt, 0);
X}
X
Xint main ()
X{
X    char* ds = format_date (time(0), "%% the date is %D at time %T");
X    print ("%s\n", ds);
X    free (ds);
X    return 0;
X}
END_OF_FILE
if test 2848 -ne `wc -c <'t3.c'`; then
    echo shar: \"'t3.c'\" unpacked with wrong size!
fi
# end of 't3.c'
fi
if test -f 't4.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'t4.c'\"
else
echo shar: Extracting \"'t4.c'\" \(247 characters\)
sed "s/^X//" >'t4.c' <<'END_OF_FILE'
X#include "print.h"
X
Xint main()
X{
X    fmtinstall ('Q', print_cquote_conv);
X    fmtinstall ('R', print_rcquote_conv);
X
X    print ("\"%Q\"\n", "\001\002\200\127abcde\nend\n");
X    print ("'%R'\n", "this can't be and isn't either\n");
X    exit (0);
X}
END_OF_FILE
if test 247 -ne `wc -c <'t4.c'`; then
    echo shar: \"'t4.c'\" unpacked with wrong size!
fi
# end of 't4.c'
fi
if test -f 't5.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'t5.c'\"
else
echo shar: Extracting \"'t5.c'\" \(162 characters\)
sed "s/^X//" >'t5.c' <<'END_OF_FILE'
X
X#include "print.h"
X
Xint main()
X{
X    int i;
X    char ch;
X
X    for (i=0; i<256; ++i) {
X	ch = i;
X        print ("%o %o %03uo\n", i, ch, ch);
X    }
X    exit (0);
X}
END_OF_FILE
if test 162 -ne `wc -c <'t5.c'`; then
    echo shar: \"'t5.c'\" unpacked with wrong size!
fi
# end of 't5.c'
fi
echo shar: End of shell archive.
exit 0
