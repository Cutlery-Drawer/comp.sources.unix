Newsgroups: comp.sources.unix
From: bcr@physics.purdue.edu (Bill C. Riemers)
Subject: v28i166: term-2.2.5 - SLIP-like functionality between two *IX hosts (REPOST), Part03/09
References: <1.784237938.15304@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: bcr@physics.purdue.edu (Bill C. Riemers)
Posting-Number: Volume 28, Issue 166
Archive-Name: term-2.2.5/part03

#!/bin/sh
# This is `part03' (part 3 of a multipart archive).
# Do not concatenate these parts, unpack them in order with `/bin/sh'.
# File `term-2.2.5/Term.HOWTO' is being continued...
#
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  echo 'WARNING: not restoring timestamps.  Consider getting and'
  echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if test ! -r _sharseq.tmp; then
  echo 'Please unpack part 1 first!'
  exit 1
fi
shar_sequence=`cat _sharseq.tmp`
if test "$shar_sequence" != 3; then
  echo "Please unpack part $shar_sequence next!"
  exit 1
fi
if test ! -f _sharnew.tmp; then
  echo 'x - still skipping term-2.2.5/Term.HOWTO'
else
  echo 'x - continuing file term-2.2.5/Term.HOWTO'
  sed 's/^X//' << 'SHAR_EOF' >> 'term-2.2.5/Term.HOWTO' &&
X  lower.  Note that if you have a slower machine with 16450 uart on your
X  serial port, high baudrates can cause data loss by overloading the
X  chip on your serial port. term will recover from this, but if you see
X  a lot of error messages in your log file, (or get overrun warnings
X  from linux kernel versions 0.99pl15 and up) you again might want to
X  lower this number.
X
X  -c off : This turns data compression off. I have got a compressing
X  modem, and I do not want to compress things twice.
X
X  -w 10 -t 150 : Again, these are options to optimize my fast modem
X  link.  I have set my window to 10 and my timeout to 150. This is per
X  the recommendation in the term_setup man page.
X
X  Escape back to your local machine and suspend your comm program (^Z
X  under kermit). You do not want it running while term is running,
X  because it will fight with term over the serial port. If you can
X  convince your modem to not hang up when you exit your comm program
X  (when it toggles DTR), you could just exit the program at this point.
X
X  Now run term locally. I use:
X
X  term -r -c off -l $HOME/tlog -s 38400 -w 10 -t 150 < /dev/modem >
X  /dev/modem &
X
X
X  The only option here that is different from the other end is the -r
X  option. You need this on one end, otherwise term clients will
X  spontaneously die on you. I need to tell term where the modem is, so I
X  point both standard input and output at /dev/modem (that is what the <
X  and > do). I also run it in the background, so I can use this screen
X  for something else if I want to.
X
X  term should work now :-). Try a trsh, and see what happens. If you
X  hang, or your link seems slow, take a look at your tlog on each end.
X  Are you getting timeouts or error messages? If so, then you have
X  configured something incorrectly. Try again (after you have finished
X  reading this :-). Note that the connection won't seem blazingly fast,
X  especially if you are using compression - it will be a little jumpy.
X  The real speed comes in during file transfer and the like.
X
X  3.7.  Terminate your term connection
X
X
X  Most certain, after you have done a lot of work using term, you want
X  to finish your work and bring your term connection down. For this to
X  be realized there are three ways:
X
X
X  1. Kill the term programs on both sides of the connection. This is the
X     least recommended way of terminating your connection
X
X  2. A better way is to execute the following command locally:
X
X
X     echo '00000' > /dev/modem
X
X
X
X  This will nicely terminate your term connection. It will work for all
X  version of term. Make sure that the sequence of zeros contains at
X  least five zeros.
X
X  3. Starting with version 1.14 there is the program tshutdown (actually
X     for version 1.14 it is available as a patch, for newer versions it
X     is in the package). Executing tshutdown nicely terminates your term
X     connection.
X
X
X  3.8.  Gotchas to Watch Out For
X
X
X  If your .term or term directory is mounted with NFS you need to set
X  the flag -DTERM_NFS_DIR in the CFLAGS line of the Makefile. Alas, for
X  the author this flag causes a compile error when term 1.19 is compiled
X  on a machine running sunOS 4.*.
X
X  Are you running the right binary? term has been updated quite a lot,
X  and many systems have different versions of the programs floating
X  around. Make sure you are using the right version. Note that this
X  applies to linecheck too. You can use bash's type -a or the whereis
X  command to find which program is being run.  term versions after 1.11
X  should print out their version number when they start up.  (Although
X  version 1.14 claims to be 1.12.  Sigh.)
X
X  Do you have the right termrc? Depending of the version of term you are
X  running and the way you installed term (being root or user) this file
X  has to be in one of the following directories: /usr/local/lib/term,
X  $HOME/.term or $HOME. Some systems have pre-installed termrc's, make
X  sure they are gone before you set things up. If you are running things
X  as root, lookout for /.term. term creates files (sockets actually)
X  while it is running, so it has its own directory, $HOME/.term, where
X  the file termrc goes (note, there is no leading dot in termrc!).
X
X  With newer versions of term the structure of the directory tree under
X  /usr/local/lib/term has changed a couple of times. If you are not
X  aware of this, it can cause all kinds of error messages. The best
X  thing to do is to delete the directory tree under /usr/local/lib/term
X  (save your termrc) and then install your new term version. This way,
X  you avoid the struggle with a messed up directory tree.
X
X  Once you have got term running, you might want to try to get things
X  optimized. A good way to measure the speed of your link is to run tmon
X  in one window while up/downloading a file in another. Try both (big)
X  text files and compressed files, the plain text should go a factor of
X  two-ish faster than the compressed files.  The parameters you want to
X  fiddle with are compression (-c), windows (-w), timeout (-t) and
X  retrain (-A.  Watch out with the retrain parameter. I got a
X  performance decrease of 80% to 90% compared to running term without
X  the retrain parameter. It is not clear if this is a bug in term
X  version 1.19, the version I am running and if this problem exists only
X  with term version 1.19.
X
X
X  Compression: you want this on if you do not have a compressing modem.
X  If you do have such a modem, turn compression off, otherwise you will
X  be compressing things twice, which typically increases the amount of
X  data transmitted. Compressing modems are ones that use the MNP-5 or
X  V42.bis protocols. Check your modem documentation and the message when
X  your modem connects.
X
X  Windows: this is the number of chunks of data, or packets, that term
X  will let go over the line before it gets an acknowledgment (or ack)
X  from the remote term. For fast modems, increasing this can be a win,
X  for slower links this can overwhelm the remote end.
X
X  Timeout: the time term will wait for an ack. If you have increased
X  windows, and you are getting timeouts in your logfile, try increasing
X  this.
X
X  For 14400/V42.bis, I use -c off -w 10 -t 150. I typically get around
X  1700 cps on compressed files and 3500 cps on ascii files using
X  tupload.
X
X
X  4.  term clients
X
X
X  term provides several default clients. They include trsh, tmon,
X  tupload, tredir, txconn and in newer versions trdate, trdated and from
X  version 2.0.0 tudpredir. This section will deal with trsh, tmon,
X  tupload, trdate and trdated.  The others each have their own section.
X  No term client will work until you have established a term link.
X
X  tmon is a simple utility to monitor the statistics of your link.  It
X  prints a time histogram of characters transmitted and received. It is
X  invoked simply as tmon. Since around version 1.11, tmon has had a bug
X  that causes some information to be garbled. Send me mail if you'd like
X  a patch to fix this.
X
X  trsh is similar to rsh. Without arguments, it spawns an interactive
X  shell on the remote system (i.e. it logs you in).  trsh is one of the
X  primary means of accessing the remote end of the link via term. If
X  given an argument, trsh executes that argument as a command on the
X  remote system. For example trsh ls would give you a listing of the
X  files in your home directory on the remote system.
X
X  tupload is the term's basic file transfer program. It will transfer a
X  file, given as its first argument, to the opposite end of the link. By
X  default, the files will be put in the same directory that you invoked
X  term from on the other side. To put files in another directory, give
X  its name as a second argument to tupload. For example, if I want to
X  put a copy of the file term114.tar.gz in /usr/tmp on the remote
X  system, I would type tupload term114.tar.gz /usr/tmp. There is no
X  client to do a download - to download files, trsh to the remote system
X  and do a tupload.
X
X  trdate is a time setting utility. it reads the time on the remote
X  machine and sets the local clock to the remote time. It must be run as
X  root.
X
X  trdated is the daemon version of trdate. When it is started in
X  rc.local it is run as daemon in which case it updates the time every 5
X  minutes. Even when there is no term connection, this daemon will start
X  up when set in the rc.local. Once a term connection is created it
X  starts updating the time.
X
X
X  5.  X and term
X
X
X  term allows users to open up X windows on the local machine from
X  clients that are running on a machine on the network. This is done by
X  using the txconn client. txconn is executed on the remote, network-
X  connected machine, it is invoked simply as txconn. It goes into the
X  background and returns a number on the standard output, this number is
X  the display number that clients should use to access the X server on
X  the local machine. An example should make this clear.  I am logged in,
X  via trsh, to my remote term host, named foo. On foo, I do the
X  following
X
X
X
X  foo$ txconn
X  Xconn bound to screen 10
X  :10
X  foo$
X
X
X
X  Now, on any host that I wish to run an X client, that is to display on
X  my local machine's X server, I do setenv DISPLAY foo:10 (for bash you
X  should use export DISPLAY=foo:10). In some cases it can furthermore be
X  necessary to do a xhost + foo on your local machine. Now when I start
X  the client, it will try to connect to screen 10 on machine foo, but
X  txconn is listening to this screen, and will forward all X protocol
X  packets via term to the X server on the local host - i.e. the window
X  will open up on your local machine.
X
X  It is possible to go the other way - run a client on your local
X  machine and have it open up a window on a remote machine on the
X  network, however we will defer explaining this until after we have
X  discussed tredir.
X
X  txconn is not terribly secure, anyone can connect to your local server
X  via term and perform all sorts of mischief. If you are worried about
X  this sort of thing, it might be a good idea to consider using xauth to
X  authorize your connections. Consult the xauth man page.
X
X  The X protocol is not very efficient, it wastes some bandwidth. This
X  is usually not a problem over an ethernet, but can be murder over a
X  modem. X11R6 is supposed to introduce a low bandwidth version of the X
X  protocol, LBX. However, this is not of much use, since R6 has not been
X  released at the time of this writing. There is a utility named sxpc
X  which compresses the X protocol, improving response over serial lines.
X  sxpc includes a write-up on how to get it working with term, and is
X  recommended. The sxpc package also explains how to use xauth, so it is
X  doubly recommended.
X
X
X  6.  tredir
X
X
X  tredir is one of term's most powerful utilities, allowing most
X  important network services to be performed over a term link. Before we
X  explain how to use tredir, it is necessary to give some background on
X  network services. We have talked about network services before, but we
X  have not said exactly what they are. Services are just that - services
X  that are provided by the network. Examples of services include telnet,
X  which provides logins between machines, the File Transfer Protocol,
X  ftp, which transfers files between machines, and smtp, the Simple Mail
X  Transfer Protocol, which is used whenever you send electronic mail.
X  Each network service has a port number associated with it.  The
X  mapping of port numbers to services is given in the file
X  /etc/services. This file should be the same on all internet-connected
X  machines.
X
X  How are these services invoked? Each networked machine runs a daemon
X  called inetd, which listens for attempts to connect to the network
X  ports. These requests can come from either the network or the local
X  machine. A network service is obtained by connecting to a particular
X  inetd port.  When a network request is made, inetd knows exactly which
X  service is involved by the port number that request is made on.  If
X  inetd is configured to do so, it then provides the relevant service to
X  the requesting connection. inetd's configuration is given by the file
X  /etc/inetd.conf, which has a list of the services that inetd provides.
X  For more information, see the man pages for inetd and inetd.conf.
X
X  You can communicate directly with network services by using telnet
X  (n.b. not termtelnet). For example, to talk to the sendmail, (or smtp)
X  daemon on machine machine_name, you can do a telnet machine_name smtp,
X  or telnet machine_name 25, (since 25 is the number assigned to smtp in
X  /etc/services). You should get a polite greeting from the daemon on
X  the remote machine. This is a very useful trick for debugging network
X  problems and checking ports redirected with tredir (see below).
X
X  tredir works very much like inetd. It runs in the background as a
X  daemon, listening to the network ports, waiting for a request. When a
X  request for a service is made, instead of providing that service, as
X  inetd does, tredir forwards the request over the term link to the
X  remote term, which makes the request over the network, returning the
X  result back over the link to the local client. tredir can forward the
X  request to any machine on the network, but by default sends it to the
X  machine on the other end of the term link.  tredir ``redirects''
X  network services over the term link (hence the name ``tredir'').
X
X  An example should make this clear. Let's redirect a local port to the
X  telnet port on the remote machine. To do this we would do tredir 2023
X  23.  Now, anyone who connects to port 2023 on the local machine will
X  be redirected to port 23 (telnet) on the remote machine.  Here's an
X  example session, the local machine is mymachine.modem.home and the
X  remote machine is netsun.
X
X
X
X  $ tredir 2023 23
X  Redirecting 2023 to 23
X  $ telnet localhost 2023
X  Trying 127.0.0.1...
X  Connected to mymachine.modem.home
X  Escape character is '^]'.
X
X
X  SunOS UNIX (netsun)
X  login:
X
X
X
X  This example is actually quite useful. If I were instead to do the
X  tredir on netsun, I could then telnet in to mymachine from the
X  network, simply by connecting to the redirected port on the networked
X  machine (using telnet) - i.e. telnet netsun 2023.
X
X  The general principle in using tredir is to redirect the desired
X  service to a machine on the network. Our next example will allow us to
X  read news on the local machine over our term link from a news server
X  on the network. News is provided by the nntp service, port number 119.
X  All decent news readers allow you to specify what port number they
X  will use, either via a configuration file or an environment variable.
X  Let's specify this local port to be 2119. Now, let's say that our news
X  server is news.domain.org. We will redirect port 2119 to port 119 on
X  news.domain.org, we will then tell our news reading software that the
X  nntp server is located at port 2119 on the local host (??). Since this
X  will depend on the news reader that you use, I will just test the link
X  with telnet instead of firing up a news reader:
X
X
X  $ tredir 2119 news.domain.org:119
X  Redirecting 2119 to news.domain.org:119
X  $ telnet localhost 2119
X  Trying 127.0.0.1...
X  Connected to mymachine.modem.home.
X  Escape character is '^]'.
X  200 news.domain.org InterNetNews NNRP server INN 1.4 07-Dec-41 ready
X  (posting ok).
X
X
X
X  If you can get this far, all you have to do is configure your news
X  reader to be able to read news via term. (n.b., if you read news like
X  this, be sure that in all your posts you set a Reply-To: header to an
X  network email address that you can be reached at, otherwise people who
X  want to get in touch with you will be sending mail to whatever (wrong)
X  data your newsreader puts in the From: header).
X
X
X  6.1.  tredir can bite!
X
X
X  The astute reader, after reading the last example will be wondering
X  why port 2119 was redirected to port 119 - since newsreaders default
X  to port 119, why could not I do a tredir 119 news.domain.org:119 and
X  skip the newsreader configuration? The answer is that all ports
X  numbered less than 1024 are ``reserved ports'', and only the superuser
X  can listen on them. If one is willing to take a security risk and make
X  tredir an suid program, or run tredir as root, then one can redirect
X  reserve ports and avoid the  of renaming services.
X
X  Another problem with using reserved ports is that inetd is often
X  already listening to these ports, and only one program at time can
X  listen to a port. In order to use such a port, you must change
X  inetd.conf so that inetd no longer listens on the port you want to
X  redirect. This is most easily done by commenting out the line with the
X  offending service by putting a # character at the beginning of the
X  line. The superuser must then send inetd a HUP signal (kill -1 inetd-
X  pid) to get it to reread its configuration.
X
X  All of the services we have been discussing so far are TCP
X  (Transmission Control Protocol) services. TCP is just a protocol for
X  sending packets (data) over a net. term versions upto 1.19 only
X  support TCP. Starting with version 2.0.0 term also supports UDP (User
X  Datagram Protocol). This makes things like NFS and archie available
X  over a term link.
X
X
X  6.2.  Stupid tredir tricks
X
X
X  In this section we will describe some of the more common uses for
X  tredir. We have already described how to redirect nntp and telnet
X  services, here we will give some more complicated examples.
X  6.2.1.  X windows
X
X
X  In a previous section, we described how to get an X client running on
X  the network to open a window on your home machine using txconn. The
X  same technique could be used on your home machine to display a client
X  on the machine at the remote end of your term link.  But how does one
X  display an X client on a network machine that is not the remote end?
X  The answer lies in knowing that X uses a particular network service
X  just like the other programs we have been discussing. An X server
X  listens for network request on a port whose number is given by the
X  formula  port = 6000 + display number, e.g. an X server managing
X  screen 0 on a machine would listen to port 6000, if it were managing
X  screen 2, it would listen on port 6002.  When you set your DISPLAY
X  environment variable to xmachine:n, your X clients will try to connect
X  to port 6000 +n on xmachine.
X
X  We can use this to trick X clients on your local machine to open up
X  windows on remote displays. Let's say I want to open up an xterm,
X  running on my local machine, on display 0 of machine xmachine, which
X  is running some place on the network.  I first pick a local display
X  number, say 2 (do not use 0, since that is what your local X server
X  will be using). I will map this display to display 0 on xmachine. In
X  terms of ports, this means I want to redirect the local port 6002 to
X  the remote port 6000.  I do the following
X
X
X
X  $ tredir 6002 xmachine:6000
X  $ setenv DISPLAY localhost:2
X  $ xterm
X
X
X
X
X  This should open up an xterm on machine xmachine.  Note that I set the
X  DISPLAY to localhost:2. This is because X clients will sometimes use
X  unix domain sockets instead of internet domain sockets, at their own
X  option, when connecting to a local display, if DISPLAY is set to :2.
X  localhost:2  says to use a tcp connection.
X
X  Note that as far as xmachine is concerned, the X request is coming
X  from the machine on the remote end of your term link (remotemachine) -
X  so if you need to authorize the connection, you should either do an
X  xhost + remotemachine on xmachine or use xauth to update the
X  .Xauthority file on your local machine for display number 2, using the
X  key from xmachine.
X
X  Again, to speed up X connections, you can use the program sxpc, which
X  includes an explanation of how to use tredir to establish the link and
X  authorize it using xauth.
X
X
X  6.2.2.  Mail with term
X
X
X  Well, you asked for it. Electronic mail has the justifiable reputation
X  of being one of the most difficult things to get working right on a
X  UNIX system. To really get term working correctly with mail means that
X  you have to understand how mail works, which is beyond the scope of
X  this document. To learn more about mail, you should consult a book on
X  UNIX system administration and/or the comp.mail.misc FAQ, available
X  for anonymous ftp on rtfm.mit.edu in pub/usenet/comp.mail.misc. There
X  are also currently two packages available for anonymous ftp on
X  sunsite.unc.edu that will help you get mail running under term - they
X  are term.mailerd+smail by Byron A. Jeff and the BCRMailHandlerXXX by
X  Bill C. Riemers.
X
X  That being said, we will give a thumbnail description of how mail
X  works.  There are two parts to getting mail running, sending messages
X  and receiving messages. We will begin with sending messages from your
X  local box to the network.
X
X  There are two classes of mail programs. The first is the mail user
X  agent (MUA). MUA's help you read, compose and send messages. Examples
X  of MUA's are elm, pine, Mail and vm.  MUA's do not really do any
X  networking, they just put the messages together - the real work of
X  sending mail is done by the second class of mail programs, the mail
X  transfer agents (MTA's). These are invoked by the MUA's. They take the
X  message, decide where to send it by looking at the address, and then
X  actually deliver it over the network.
X
X  The two most common MTA's on Linux systems are sendmail and smail. The
X  basic idea is to get your MTA to connect to another MTA running on a
X  machine on the net that will know what to do with your message. This
X  is done by redirecting a local port to the smtp port on the net
X  machine. You then have to tell you MTA to take any message it does not
X  know what to do with and send it out over the redirected port on your
X  local machine to the MTA on the remote machine, which will then route
X  your message to its correct destination.
X
X  How do we do this using smail?  We first redirect a port to the smtp
X  port on the network mail machine (mailhost):
X
X  tredir XXXX mailhost:25
X
X  here XXXX is the port number that the smail on the localhost will
X  connect to (note that I have to give this port a name in my
X  /etc/services to get smail to recognize it).  smail has several
X  configuration files that usually live in /usr/local/lib/smail.  The
X  ones we care about are config, routers and transports. Note that I am
X  assuming you have already got smail configured correctly for local
X  mail - delivery to files and pipes and such.  Again, consult the
X  documentation if you do not.
X
X  In the file config, we put the following definition:
X
X
X  smart_path=localhost
X
X
X
X  localhost is the machine that smail connects to when it does not know
X  what to do with a message.
X
X  In routers we put
X
X
X
X  smart_host:
X  driver=smarthost,
X  transport=termsmtp;
X  path = localhost
X
X
X
X  In transports we put
X
X
X
X
X
X  termsmtp:        driver=tcpsmtp,
X          inet,
X          return_path,
X          remove_header="From",
X          append_header="From: YOUR_NET_ADDRESS",
X          -received,
X          -max_addrs, -max_chars;
X          service=YOUR_SMTP_SERVICE,
X
X
X
X  In the above, the header lines change the From header in all your
X  outgoing mail to the address, YOUR_NET_ADDRESS, which is the network
X  address you want mail for sent. If more than one user is going to be
X  using your term link, you will have to do something more fancy, like
X  keep a database of local user's network addresses and insert these in
X  the From: headers.
X
X  The service line is the name of the local portnumber that you have
X  redirected to the smtp port on the network connected machine. On my
X  version of smail, I cannot just set this to a number, I have to set it
X  to a name, like ``foo'', and then define ``foo'' in my /etc/services
X  to be the number of my redirected port. If you use an suid tredir and
X  just redirect the smtp port (25), you do not need to define this.
X
X  This should be enough to get you going. If you decide to use sendmail,
X  the principles are the same but the details differ.  Ronald Florence
X  (ron@mlfarm.com) told me that the stock Sun sendmail will not send
X  multiple queued messages over a redirected port; BSD sendmail 8.6.9
X  works fine.  He made the following changes to sendmail.cf to get it
X  working with term. In his case, the default sendmail port (25) is used
X  for SMTP traffic over a local ethernet, so Internet mail is forwarded
X  to a redirected TCP port.
X
X
X  #
X  #Create the termsmtp mailer, which sends mail via a re-directed TCP port
X  #
X  Mtermsmtp,P=[TCP], F=mDFMuCXe, S=22, R=22, A=TCP $h PORTNUMBER
X
X
X
X  Here, PORTNUMBER is the number of the redirected port on the local
X  machine. This should be an unused port over 2000. We next tell
X  sendmail to which machine to connect to, and set termsmtp as the
X  default mailer.
X
X
X  #
X  # major relay mailer
X  #
X  DMtermsmtp
X  #
X  # major relay host: use the $M mailer to send mail to other domains
X  #
X  DR HOSTNAME
X  CR HOSTNAME
X
X
X
X  Here HOSTNAME is the name of your local host (does localhost work?).
X  The last entry goes under Rule 0 to forward Internet mail.
X
X
X
X
X  # Pass other valid names up the ladder to our forwarder
X  R$*<@$*.$+>$*           $#$M    $@$R $:$1<@$2.$3>$4     user@any.domain
X
X
X
X  When the term connection is established to the Internet host, run the
X  following commands on the local machine.
X
X
X  tredir PORTNUMBER internet.host:25
X  /usr/lib/sendmail -q
X
X
X
X  We now turn to receiving electronic mail using term. We will assume
X  that mail is sent to your account on the network machine mailhost. The
X  simplest solution is to just use trsh or termtelnet to log on to
X  mailhost and read your mail on there.  However, it is also possible to
X  have your mail automatically downloaded to your local machine. One way
X  to do this is to use the Post Office Protocol, (POP).  POP was
X  designed for exactly this purpose: to deliver mail to machines that
X  have intermittent network connections. To use POP, you must have a POP
X  server installed on mailhost. Assuming that you do, you can then use a
X  POP client to download your mail every few minutes. This is done, as
X  you might expect, using tredir. The POP service is 110 (note that
X  there is an older protocol, POP-2, which uses port 109; in this
X  document we describe POP-3, which is the latest version of POP). There
X  are several POP clients available. One, written using the script
X  language perl is pop-perl-1.X, written by William Perry and maintained
X  by myself - it can be found on sunsite in /pub/Linux/system/Mail.
X
X  To use POP, you redirect a local port to port 110 on mailhost and
X  configure your client to retrieve your mail from localhost using the
X  local port. As an example, we will assume that there is a POP server
X  running on mailhost. We will redirect the local port 2110, and fire up
X  the pop-perl client:
X
X
X  $ tredir 2110 mailhost:110
X  Redirecting 2110 to mailhost:110
X  $ pop
X  Username: bill
X  Password: <enter your password for mailhost>
X  Pop Host: localhost
X  Pop Port: 2110
X  Starting popmail daemon for bill
X
X
X
X
X  If you do not have a POP server available, the BCRMailHandler package
X  has a program to download your mail over a term link to your local
X  machine. I have not used it, but anyone who has is welcome to comment.
X
X
X
X  7.  Automating Things
X
X
X
X  Now that you know how to get all of your network services over term,
X  it would be nice to set things up so your link is set up and
X  configured automatically. There are basically an infinite number of
X  ways of doing this, depending on what comm program you use and how you
X  log in to your remote system.
X
X  One program, that I have not used, but I have heard is quite nice, is
X  fet: a front end for term. It is designed to log you into a remote
X  system and fire up term and all your tredir's.  Any comments on fet
X  would be most welcome.
X
X  I shall now give an example of a set of commands that use kermit to
X  log into the remote system and then performs all of the term
X  initializations. Obviously, if you use these examples, you will have
X  to modify them for your own login procedures.
X
X  The command which is actually invoked is the shell script knet, given
X  by:
X
X
X
X
X  #!/bin/sh
X  /usr/bin/kermit -y $HOME/.kerm_term > $HOME/klog < /dev/null 2>& 1
X  exec $HOME/bin/tstart >> $HOME/klog 2>& 1
X
X
X
X  The script .kerm_term is given by:
X
X
X
X  pause 2
X  # The number you want to dial
X  output atdtXXXXXXX \13
X  # Login to the terminal server
X  input 145 {name: }
X  output MYNAME \13
X  input 3 {word: }
X  output MYPASSWORD \13
X  input 5 {xyplex>}
X  # Make the line transparent
X  output term telnet-t \13
X  output term stopb 1 \13
X  # Connect to the remote host
X  output telnet remotehost.somedomain.org \13
X  input 10 {ogin: }
X  output MYOTHERNAME \13
X  input 3 word:
X  output MYOTHERPASSWORD \13
X  pause 5
X  # Fire up term on the remote host
X  output exec term -s 38400 -l $HOME/tlog -w 10 -t 150  \13
X  ! /usr/bin/term -r -l $HOME/tlog -s 38400 -c off -w 10 -t 150 < /dev/modem > /dev/modem &
X  # Open other clients here
X  suspend
X  !killall -KILL term
X
X
X
X  and finally, the script tstart which fires up the term clients is
X  given by
X
X
X
X
X
X
X
X
X
X
X  #!/bin/sh
X  #
X  # This lets mail get out, can read news here, can pick up my mail here
X  #
X  /usr/local/bin/tredir 2025 25 2119 newshost:119 2110 pophost:110
X  #
X  # So I can open up Xwindows here
X  #
X  /usr/local/bin/trsh -s txconn
X  #
X  # So I will receive mail....
X  #
X  /usr/local/bin/pop
X  #
X  # Clean out the queue, in case of boo-boos
X  #
X  /usr/bin/runq
X  #
X  # Done now
X  #
X  echo ^G^G > /dev/console
X
X
X
X  When finally you want to close the connection, you resume and
X  terminate kermit. The last line of the script kills the local term and
X  returns the system in its initial state.
X
X  ( Note of the author: instead of doing '!killall -KILL term', I think
X  it should be possible just to do '!tshutdown'. This should also work?)
X
X  As I said, there are zillions of ways to do this, these are just meant
X  as examples to get you started.
X
X
X  8.  Other programs and term
X
X
X  A number of programs can already be used in combination with term. To
X  become these programs there are two possibilities:
X
X
X  1. Use ready made binaries.
X
X  2. Port and compile the sources.
X
X
X  8.1.  Use ready made binaries
X
X
X  Some programs are modified to work with term. They include telnet,
X  (nc)ftp, Mosaic and many others. Binaries of these programs can be
X  found on sunsite.unc.edu in /pub/Linux/apps/comm/termstuff and in
X  /pub/Linux/apps/comm/term/term/extra.
X
X  Most of these programs are compiled form term 1.17 or earlier. They
X  should, however, still work with the newer versions of term as
X  explained earlier.
X
X
X
X  9.  Term speed table
X
X
X  Thanks to Bill McCarthy we now have a table with term speed
X  information for different modems, term versions and connection
X  conditions. Its purpose is to give new and experienced user some idea
X  what other folks are using and the results they are getting.
X
X
X
X                                  LINUX TERM CHART 8/14/94
X
X
X       |___modem speed/make___|___line speed__|__avg cps__|__high__|__term ver_|
X       | 1)  USR SP 14.4      |   9600        |  950      |  963   | 1.1.7     |
X       | 2)  USR SP 14.4      |  14400        | 1376      |  n/a   | 1.18p06   |
X       | 3)  Zoom 2400        |   2400        |  220      |  230   | 1.19      |
X       | 4)  Boca V.32bis 14  |  57600        | 1400      |  n/a   | 1.01/09?  |
X       | 5)  Viva 14.4        |  14400        | 1300      |  n/a   | 1.16      |
X       | 6)  USR SP 14.4      |  14400+       | 1550      | 1680   | 1.19      |
X       | 7)  Intel 14.4 Fax   |  14400        | 1400      | 1650   | 2.0.4     |
X       | 8)  cable tv hookup  |  57600        | 1500      | 1800   | 1.18p06   |
X       | 9)  Twincom 144/DFi  |  57600        | 1500      | 4000?  | 2.0.4     |
X       | 10) USR SP 14.4      |  14400        | 1200      | 1500   | 1.08      |
X       | 11) cable tv hookup  |  19200        | 1300      | 1800   | 1.1.9     |
X       |-----------------------------------------------------------------------|
X
X       +Command flags/termrc settings:
X
X       1) default escapes   2) window 5       3) baudrate 2400    4) n/a
X          baudrate 9600        timeout 200       window 3
X          window 10                              noise on
X          timeout 150
X
X       5) compress off      6) baudrate 19200  7) ignore 19+17    8) compress off
X          window 10            compress on        window 4           escape 0, 13,
X          timeout 150                             timeout 90         16-19, 255
X          baudrate 38400                                             baudrate 0
X                                                                     shift 224
X                                                                     flowcrtl 500
X                                                                     window 10
X                                                                     timeout 70
X                                                                     retrain on
X                                                                     breakout 24
X       9) compress off     10) compress off      11) baudrate 19200
X          baudrate 57600       baudrate 38400        compress on
X          window 10            escape 17, 19         shift 224
X          timeout 200          remote                escape 0, 13 16-17
X          noise on                                   19, 255
X          share on                                   window 10
X          remote                                     timeout 40
X
X       Escaping characters on one site also implies ignoring them on the other site.
X
X
X
X
X
X  10.  Term clients used in the world
X
X
X  Below a list of application running with term is given. I am not
X  stating that this list is complete so any completion is welcome. As
X  far as possible I will present the site and directory where the
X  application can be found (all to my knowledge). When I state
X  sunsite.unc.edu as place to find the application I mean that you can
X  find it in one of the following two directories:
X
X
X  1. /pub/Linux/apps/comm/termstuff
X
X  2. /pub/Linux/apps/comm/term/term/extra
X
X  Here we go :-)
X
X
X
X       tupload             term package
X       trsh                term package
X       tmon                term package
X       tredir              term package
X       tudpredir           term package (versions 2.0.0 and higher)
X       txconn              term package
X       trdate(d)           term package
X       tshutdown           term package
X       libtermnet          term package
X       termftp
X       ncftp               sunsite.unc.edu
X       fsp                 sunsite.unc.edu
X       lynx                sunsite.unc.edu
X       Mosaic              sunsite.unc.edu:/pub/Linux/system/Network/Info-systems
X       chimera
X       finger              sunsite.unc.edu
X       rlogin
X       tin                 sunsite.unc.edu
X       slurp               sunsite.unc.edu
X       xgopher
X       gopher              sunsite.unc.edu
X       xboard              sunsite.unc.edu
X       ircII               sunsite.unc.edu
X       whois               sunsite.unc.edu
X       xwebster            sunsite.unc.edu
X       termtelnet          sunsite.unc.edu
X       term.mailerd+smail  sunsite.unc.edu
X       BCRMailHandlerXXX   bohr.physics.purdue.edu:/pub/bcr/term
X       sxpc                ftp.x.org:/R5contrib
X       xarchie             (compiled by some one, term version 2.0.x)
X       archie              (compiled by some one, term version 2.0.x)
X
X
X
X
X
X  11.  Things to remember
X
X
X  In this section I try to present you a list of usefull ftp addresses,
X  URL's etc. where you can find software and information about term.
X
X  ftp:
X
X  sunsite.unc.edu:/pub/Linux/apps/comm/term/<whole-directory-tree>
X  sunsite.unc.edu:/pub/Linux/apps/comm/termstuff
X  sunsite.unc.edu:/pub/Linux/docs/HOWTO
X  bohr.physics.purdue.edu:/pub/bcr/term
X
X
X
X  URL:
X
X  http://sunsite.unc.edu/mdw/HOWTO/Term-HOWTO.html
X  http://zeus.cs.kun.nl:4080/term-howto/Term-HOWTO.html
X
X
X
X  netnews:
X
X  comp.os.linux.announce           announce of new Term-HOWTO
X  comp.os.linux.help               ask your questions about term here
X  comp.os.linux.misc               or here
X
X
X
X  When you start asking questions on netnews please make sure that you
X  present people in the groups as much information as they need to solve
X  your problem (term version number, way you set up your connection
X  etc.). At this moment many term versions are in use and all have their
X  specific and common problems. Therefore, when you want a useful answer
X  at least state the version of term you are using. Otherwise, in some
X  cases only wild guesses are possible to help you save your problems.
X
X
X  12.  Other Stuff
X
X
X  Some things that might be included:
X
X
X  o  libtermnet.a
X
X  o  Suggestions
X
X  Anyways, if you have comments, criticisms, suggestions, or anything
X  else to say about this document, please fire away. As Bill Reynolds is
X  very busy at this moment I, Patrick Reijnen, have taken over the the
X  authorship of the Term-HOWTO. I can (currently) be reached at
X  patrickr@sci.kun.nl or patrickr@cs.kun.nl.
X
X
X  13.  Acks
X
X  Thanks go to a lot of people. First and foremost to Michael O'Reilly
X  and all the developers of term, who have provided us with such a great
X  tool. I would also like to thanks everyone who gave feedback and
X  contributed to this HOWTO, they include Ronald Florence, Tom Payerle,
X  Bill C. Riemers, Hugh Secker-Walker, Matt Welsh, Bill McCarthy, Sergio
X  and everybody forgotten to mention.
SHAR_EOF
  echo 'File term-2.2.5/Term.HOWTO is complete' &&
  $shar_touch -am 1028144694 'term-2.2.5/Term.HOWTO' &&
  chmod 0644 'term-2.2.5/Term.HOWTO' ||
  echo 'restore of term-2.2.5/Term.HOWTO failed'
  shar_count="`wc -c < 'term-2.2.5/Term.HOWTO'`"
  test 55220 -eq "$shar_count" ||
    echo "term-2.2.5/Term.HOWTO: original size 55220, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/checksum.c ==============
if test -f 'term-2.2.5/checksum.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/checksum.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/checksum.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/checksum.c' &&
X/*
XFrom alfred!nevets!ssd@osceola.cs.ucf.edu Sun Dec 13 14:25:07 1992
XReturn-Path: <alfred!nevets!ssd@osceola.cs.ucf.edu>
XReceived: from osceola.cs.ucf.edu by tartarus.uwa.edu.au (5.65c/SMI-4.1)
X	id AA01410; Sun, 13 Dec 1992 14:24:59 +0800
XReceived: from alfred.UUCP by osceola.cs.ucf.edu (4.1/1.34)
X	id AA17217; Sun, 13 Dec 92 01:23:58 EST
XReceived: by alfred.oau.org (/\==/\ Smail3.1.28.1 #28.1)
X	id <m0n0mW0-00009iC@alfred.oau.org>; Sun, 13 Dec 92 01:09 EST
XReceived: by nevets.oau.org (Smail3.1.28.1 #2)
X	id m0n0mJs-0000OhC; Sun, 13 Dec 92 00:56 EST
XMessage-Id: <m0n0mJs-0000OhC@nevets.oau.org>
XFrom: ssd@nevets.oau.org (Steven S. Dick)
XDate: Sun, 13 Dec 1992 00:56:47 EST
XX-Mailer: Mail User's Shell (7.2.4 2/2/92)
XTo: oreillym
XSubject: term checksum stuff
XStatus: OR
X
XI've got some old code to do checksums...
XWould you like me to just send you this code as I have it?
X
XIf I get around to it (I've got 4 other projects going), I am thinking
Xof possibly modifying tupload to use this to verify the files when it
Xfinishes...especially to verify that it is identical on both ends before
Xit starts appending.
X
XAlso, I've had problems with the checksum stuff.
XOccasionally, I get a really bad blast of line noise that gets by
Xthe checksums, and then the compression routines core dump on bad data.
XIt would be nice to have better error checking in this respect.
X
XThe checksum routines I have are table driven...
X
X[heck, the thing is 3k, I'll just include it here.]
X
X        Steve
X
X-----------------------
X crc - list length and checksum		Author: Johan W. Stevenson */
X
X/* crctab calculated by Mark G. Mendel, Network Systems Corporation */
Xstatic unsigned short crctab[256] = {
X	0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,
X	0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,
X	0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,
X	0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,
X	0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
X	0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,
X	0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,
X	0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,
X	0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
X	0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,
X	0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,
X	0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
X	0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,
X	0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,
X	0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,
X	0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,
X	0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,
X	0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
X	0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,
X	0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,
X	0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,
X	0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
X	0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,
X	0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,
X	0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,
X	0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,
X	0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
X	0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,
X	0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,
X	0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,
X	0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
X	0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0
X};
X
X/*
X * updcrc macro derived from article Copyright (C) 1986 Stephen Satchell. 
X *  NOTE: First argument must be in range 0 to 255.
X *        Second argument is referenced twice.
X * 
X * Programmers may incorporate any or all code into their programs, 
X * giving proper credit within the source. Publication of the 
X * source routines is permitted so long as proper credit is given 
X * to Stephen Satchell, Satchell Evaluations and Chuck Forsberg, 
X * Omen Technology.
X */
X
X#define updcrc(cp, crc) ( crctab[((crc >> 8) & 255)] ^ (crc << 8) ^ cp)
X
Xint check_sum(unsigned char *d, int len, int mask)
X{
X  unsigned short crc = 0;
X  while (len-->0)
X    crc = updcrc(((*d++) & mask), crc);
X
X  return (int) crc;
X}
X
Xunsigned short update_crc(unsigned short old, unsigned char c)
X{
X  return updcrc(c, old);
X}
X
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/checksum.c' &&
  chmod 0644 'term-2.2.5/checksum.c' ||
  echo 'restore of term-2.2.5/checksum.c failed'
  shar_count="`wc -c < 'term-2.2.5/checksum.c'`"
  test 4561 -eq "$shar_count" ||
    echo "term-2.2.5/checksum.c: original size 4561, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/client.c ==============
if test -f 'term-2.2.5/client.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/client.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/client.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/client.c' &&
X#define I_IOCTL
X#define I_SYS
X#define I_GETOPT
X#define I_STAT
X#define I_SIGNAL
X#define I_STRING
X#define I_ARGS
X#define I_INET
X#include "includes.h"
X
X#include "client.h"
X
Xchar *term_server = "";
X
Xint lcompression = -1;		/* defaults. */
Xint rcompression = -1;
Xint verbose = 0;
Xint priority = 0;
Xchar com_result[1024];
Xchar *command_result=NULL;
Xint savedeid     = -1;
Xlong unsigned remote_term_version = 0;
Xlong unsigned term_localaddr = INADDR_ANY;
Xlong unsigned term_remoteaddr = INADDR_ANY;
Xchar term_localhost[256];
Xchar term_remotehost[256];
X
Xstatic int try_connect_server(int S,char *server) {
X  char *path;
X  char *ptr=NULL;
X  int s;
X 
X  if (!server) server = "";
X
X  if (share) {
X
X    if (savedeid >= 0) {
X      if (share == 2)
X        setuid(savedeid);
X      else
X        setgid(savedeid);
X    }
X    do {
X      if ((path = get_term_path(&ptr))) {
X        strcat(path,"/tmp/private");
X        strcat(path,server);
X        if (eaccess(path, getuid() ? (X_OK | R_OK) : 0) >= 0) break;
X      }else break;
X    } while ( ptr );
X#ifdef _POSIX_SAVED_IDS
X    if(share == 2)
X      setuid(getuid());
X    else
X      setgid(getgid());
X#endif /* _POSIX_SAVED_IDS */
X  }else{
X    do {
X      if ((path = get_term_path(&ptr))) {
X        strcat(path,"/.term");
X        if (access(path, X_OK | R_OK | W_OK) >= 0) break;
X      }else break;
X    } while ( ptr );
X  };
X  if (!path) {
X    sprintf(com_result, "XX%cCan't find term directory.", I_NA);
X    return -1;
X  }
X  if (!share) 
X    sprintf(&path[strlen(path)],"/socket%s", server);
X  else
X    strcat(&path[strlen(path)],"/socket");
X
X				/* Try and connect to term. */
X#ifdef _POSIX_SAVED_IDS
X  if (savedeid >= 0)
X    if (share == 2)
X      setuid(savedeid);
X    else
X      setgid(savedeid);
X#endif /* _POSIX_SAVED_IDS */
X  s = connect_unix(S,path);
X#ifdef _POSIX_SAVED_IDS
X  if (share == 2)
X    setuid(getuid());
X  else
X    setgid(getgid());
X#endif /* _POSIX_SAVED_IDS */
X
X
X  if(s<0){
X    sprintf(com_result,"XX%cFailed to connect to term socket '%s'",I_NA,path);
X    if (!remote_term_version) {
X      memset(term_remotehost,0,sizeof(term_remotehost));
X      if (term_localaddr == INADDR_ANY) 
X        get_term_localaddr(inet_addr("127.0.0.1"));
X      strcpy(term_remotehost,term_localhost);
X      term_remoteaddr = term_localaddr;
X    }
X    return -1;
X  };
X
X  if (!remote_term_version) {
X    memset(term_remotehost,0,sizeof(term_remotehost));
X    strcpy(term_remotehost,"remotehost");
X    if (send_command(s, C_STATS, 1, "%d", -10) >= 0) 
X      sscanf(command_result,"VERSION %lu %lx %s",&remote_term_version,
X        &term_remoteaddr, term_remotehost);
X    if (! remote_term_version) {
X      send_command(s, C_STATS, 0, "%d", -1);	/* This is a dummy command */
X      if (send_command(s, C_STATS, 1, "%d", -10) >= 0) 
X        sscanf(command_result,"VERSION %lu %lx %s",&remote_term_version,
X          &term_remoteaddr, term_remotehost);
X      if (! remote_term_version)  
X        remote_term_version = 10800;
X    }
X  }
X  if (term_remoteaddr == INADDR_ANY)
X     term_remoteaddr = ntohl(inet_addr("127.0.0.254"));
X
X  if ( lcompression >=0)
X    send_command(s, C_COMPRESS, 1, "%d", lcompression);
X  if (rcompression >= 0) 
X    send_command(s, C_COMPRESS, 0, "%d", rcompression);
X
X  if (priority) {
X    send_command(s, C_PRIORITY, 1, "%d", priority);
X    send_command(s, C_PRIORITY, 0, "%d", priority);
X  }
X
X  return s;
X}
X
X				/* parse all the options, and then */
X				/* return the first unused argument. */
Xint client_options(int argc, char *argv[], char *myopts, Callback callback)
X{
X  int c, i;
X  char args[200];
X
X  command_result = &com_result[3];
X
X  /* make sure we get all the args to pass to getopt */
X  if (getenv("TERMSERVER"))
X    term_server = getenv("TERMSERVER");
X
X
X  strcpy(args, "t:crp:S:");
X  strcat(args, myopts);
X
X  while ((c = term_getopt(argc, argv, args))!=EOF) {
X    switch(c) {
X    case 't':
X      term_server = term_optarg;	
X      break;
X    case 'c': /* for compression */
X      lcompression = 1;
X      rcompression = 1;
X      break;
X    case 'r': /* for raw, no compression */
X      lcompression = 0;
X      rcompression = 0;
X      break;
X    case 'p':
X      priority = atoi(term_optarg);
X      fprintf(stderr, "Changing priority to %d\n", priority);
X      break;
X    case 'v':
X      verbose++;
X      break;
X    case 'S':
X      if ( !(i = atoi(term_optarg) ? atoi(term_optarg) : !strcmp(term_optarg,"on"))) 
X        share = 0;
X      else
X        share = (share == 1) ? 1 : 2;
X      break;
X    case '?':
X      sprintf(com_result,"XX%c'?' is an illegal for some unknown reason",I_NA);
X      return -1;
X    default:
X      if ( (callback == NULL) || ( callback(c, term_optarg) == -1 ) )
X	{
X	  sprintf(com_result, "XX%cUnrecognized option '%s'",I_NA,
X            argv[term_optind]);
X	  return -1; 
X	}
X      break;
X    }
X  }
X  return term_optind;
X}
X				/* Send a command to the Term */
X				/* process.*/ 
X#ifdef USE_VARARGS
Xint send_command(sock , comm, local , fmt, va_alist)
Xint sock , comm, local;
Xchar *fmt;
Xva_dcl {
X#else
Xint send_command(int sock, int comm, int local, char *fmt, ...) {
X#endif
X  char buff[1024];
X  va_list v;
X  unsigned long version;
X  int i, blocking;
X  char old = 0;
X#ifdef USE_VARARGS
X  va_start(v);
X#else
X  va_start(v, fmt);
X#endif
X				/* A command follows.. */
X  buff[0] = C_SWITCH;
X				/* Is it for the local term? or the */
X				/* remote term? */
X  if (local)
X    buff[1] = C_SWITCH - 1;
X  else
X    buff[1] = C_SWITCH - 2;
X
X  if (old)
X    old = com_result[3];
X  else
X    old = I_NA;
X
X  sprintf(com_result,"XX%cUnsupported term option", I_NA);
X  command_result = &com_result[3];
X
X  if (comm == C_WAIT) {
X    comm = C_STATS;
X    if (old == I_OK || old == I_FAIL) return 0;
X  }
X
X  if (local) 
X    version = VERSION;
X  else
X    version = remote_term_version;
X
X	/* Here I support older versions */
X  switch (comm) {
X  case C_DUMP:
X    if (version < 20000)
X      comm = C_DUMP_OLD ;
X    break; 
X  case C_NAME:
X    if (version < 20000)
X      comm = C_NAME_OLD;
X    break; 
X  case C_PRIORITY:
X    if (version < 20000)
X      comm = C_PRIORITY_OLD ;
X    break; 
X  case C_RESIZE:
X    if (version < 20000) 
X      comm = C_RESIZE_OLD ;
X    break; 
X  case C_X_SERVER:
X    if (version < 11500)
X      comm = C_SOCKET;
X    break;
X  case C_GETPEERNAME:
X  case C_GETSOCKNAME:
X    if (version < 11714)
X      return -1;
X    break;
X  case C_UBIND:
X  case C_UDPSET:
X  case C_USOCK:
X    if (version < 20000) 
X      return -1;
X    break;
X  case C_PUTENV:
X    if (version < 20000) 
X      return -1;
X    break;
X  case C_CLIENTNUM:
X    return -1;
X    break; 
X  case C_CHMOD:
X    if (version < 20055)
X      return -1;
X    break;
X  case C_DOWNLOAD:
X    if (version < 20058)
X      return -1;
X    break;
X  case C_SETPEERNAME:
X    if (version < 20154)
X      return -1;
X    break;
X  case C_LISTEN:
X    if (version < 20155)
X      return 0;
X    break;
X  }
X
X				/* Set the command in. */
X  buff[2] = comm;
X  if (fmt)
X    vsprintf(buff+3, fmt, v);
X  else
X    buff[3] = 0;
X
X  va_end(v);
X
X  switch (comm) {
X  case C_GETHOSTNAME:
X    if (! buff[3] || !strcmp(&buff[3],"remotehost") 
X        || !strcmp(&buff[3],term_remotehost)) {
X      if (version > 20053 || version < 11714) { 
X        sprintf(com_result,"XX%c%lx %s", I_NA,
X          term_remoteaddr, term_remotehost);
X        return 0;
X      }
X    }else if (version < 11714) return -1;
X    break;
X  }
X
X  blocking = set_block(sock);
X				/* Ok. Buff holds the entire command. */
X				/* Lets do the damned thing.. */
X  sprintf(com_result,"XX%cWrite error", I_NA);
X  if (write(sock, buff, strlen(buff)+1) < 0)
X    return -1;
X
X  memset(com_result,0,sizeof(com_result));
X  sprintf(com_result,"XX%cno result forthcoming", I_NA);
X				/* If the command is C_DUMB, then no */
X				/* reply will be forthcoming. */
X  switch (comm) {
X  case C_CLCLOSE:
X  case C_CLOSE:
X  case C_CHMOD:
X  case C_DUMB:
X  case C_QUIT:
X  case C_DUMP:
X  case C_PUTENV:
X  case C_NAME:
X  case C_PRIORITY:
X  case C_RESIZE:
X  case C_SETPEERNAME:
X  case C_LISTEN:
X    return 1;
X  }
X
X  i = 0;
X  do {
X    read(sock, &com_result[i], 1);
X  } while (com_result[i++]);
X
X  if (!blocking) set_nonblock(sock);
X
X  if (com_result[2] != I_OK)
X    return -1;
X/*  printf("command return was (%d)%s", i, com_result);*/
X  return 1;
X}
X
X
X/* This is a short routine to allow the user to try to connect a socket
X * to term.  If a negative file descriptor is supplied, a new socket 
X * will be created.
X */
X
Xint socket_connect_server(int S,char *server) {
X  int s = -1;
X
X  sprintf(com_result,"XX%cNo error reported", I_NA);
X  command_result = &com_result[3];
X
X  set_share_mode(0,share);
X	/* If "share" is still undecided, I try both shared and unshared. */
X  if(share == -1){
X    set_share_mode(0,1);
X    s=try_connect_server(S,server);
X    if ( s < 0 ) {
X      set_share_mode(0,2);
X      s=try_connect_server(S,server);
X      if ( s < 0 ) share = 0;
X    }
X  };
X  if ( s < 0 ) 
X    s=try_connect_server(S,server);
X  if ( s < 0 )
X    return -1;
X  return s;
X}
X
X/* This is a short routine to allow the user to try to connect to a term
X * server.  The main difference between this and socket_connect_server with
X * a negative file descriptor, is this routine will never return if the
X * connection attempt fails.
X */
X
Xint connect_server(char *server) {
X  int s = -1;
X
X  sprintf(com_result,"XX%cNo error reported", I_NA);
X  command_result = &com_result[3];
X
X  set_share_mode(0,share);
X	/* If "share" is still undecided, I try both shared and unshared. */
X  if (share == -1){
X    set_share_mode(0,1);
X    s = try_connect_server(-1,server);
X    if (s < 0) {
X      set_share_mode(0,2);
X      s = try_connect_server(-1,server);
X      if (s < 0) share = 0;
X    }
X  };
X  if (s < 0) s = try_connect_server(-1,server);
X  if (s < 0) exit(1);  	/* Do not elminate this line... If you do not */
X			/* wish to exit use socket_connect_server(-1,server) */
X			/* I know it is stupid, but it is needed for */
X			/* backwards compatability. */
X  return s;
X}
X
X
X/* build_arg: build a string from char ** argv to be passed 
X * to C_EXEC family. 
X *
X * by: croutons
X *
X * Notes:
X *  returns a pointer to malloced space.
X *  takes a null pointer as the end of the array of char*.
X *  assumes null terminated strings. (for using string(3))
X *  returns NULL on error.
X *
X *  we assume '\377' is ok for the new terminator
X */
Xchar *build_arg( char **arg )
X{
X	int i, s;
X	static char *f = NULL;
X        char *term = NULL;
X
X        if (f) free(f);
X	if (! arg) return NULL;
X        if (*arg == NULL) return NULL;
X
X	for (s = i = 0; NULL != arg[i]; i++) s += strlen(arg[i]);
X
X        if (remote_term_version >= 11715) {
X          term = getenv("TERM");
X          if (term != NULL)
X            s += strlen(term) + strlen("-DTERM=") + 1;
X        }
X        s += i + 2;
X
X	if ( NULL == (f = (char *)malloc( s * sizeof(char) ) ) ) 
X		return NULL;
X
X		/* This passes the terminal type */
X
X        if (term != NULL) 
X          sprintf(f,"-DTERM=%s%c",term,'\377');
X        else
X          f[0] = '\0';
X
X 	for ( i = 0; NULL != arg[i]; i++ ) {	
X		strcat(f,arg[i]);
X                strcat(f,"\377");
X        }
X
X	return f;
X}
X
Xint use_term_command(int type) {
X  char *ptr=NULL;
X  char *path;
X  static int use_term = -1;
X
X  switch (type) {
X  case PUBLIC:
X#ifdef _POSIX_SAVED_IDS
X    if (savedeid < 0) 
X      set_share_mode(0,share);
X#endif
X     break;
X  case PRIVILEGED:
X  default:
X    set_share_mode(1,share);
X    break;
X  }
X
X  if (use_term >= 0) return use_term;
X  if (getenv("TERMMODE")) return (use_term=1);
X  do {
X    if ((path = get_term_path(&ptr))) {
X      strcat(path,"/termnet");
X      strcat(path,term_server);
X      if (access(path, 0) >= 0) break;
X    }else break;
X  }while (ptr);
X  if ((ptr = getenv("TERMDEBUG")))
X    term_debug = atoi(ptr);
X  return (use_term = (path != NULL));
X}
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/client.c' &&
  chmod 0644 'term-2.2.5/client.c' ||
  echo 'restore of term-2.2.5/client.c failed'
  shar_count="`wc -c < 'term-2.2.5/client.c'`"
  test 11682 -eq "$shar_count" ||
    echo "term-2.2.5/client.c: original size 11682, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/client.h ==============
if test -f 'term-2.2.5/client.h' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/client.h (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/client.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/client.h' &&
X#ifndef CLIENT_H
X#define CLIENT_H
X#include "config.h"
X#include "terminal.h"
X
X#ifndef un_char
X#define un_char unsigned char
X#endif
X
Xstruct Buffer {
X    un_char * data;
X    int start, end;
X    int size;
X    int alloced;
X    };
X
X#define C_SWITCH        '@'
X#define PUBLIC  0
X#define PRIVILEGED 1
X
X/* Client commands.  If you need to reserve a something for a patch you
X * are working on, let me know.  If we run out, we can start going to
X * two character commands for less common commands.  If you don't absolutely
X * need to add something don't as this breaks forward compatibility. 
X * (forcing people to upgrade...)
X *
X *   (bcr@physics.purdue.edu)
X */
X
X/* First the obsolete switches */
X#define C_WAIT		'\0'	/* This is just a delay */
X#define C_PRIORITY_OLD  'B'	/* Raise/lower the priority of this */
X				/* client. */
X#define C_NAME_OLD      'G'	/* Set the name of this client. Only */
X				/* used by C_STATS. */
X#define C_RESIZE_OLD    'H'	/* For handling SIGWINCH */
X#define C_DUMP_OLD      'L'	/* Go dumb for the next 'n' bytes. */
X#define C_CLIENTNUM     'I'	/* Not used. Obsolete. */
X
X/* Now the current ones */
X
X#define C_OPEN		'1'	/* Open a file a file for uploading */
X				/* without truncating it. */
X#define	C_CLOSE		'2'	/* Close a connection. */
X#define C_EXEC		'3'	/* Not used/implemented. */
X#define C_PTYEXEC	'4'	/* Fork() a shell attached to a pty. */
X#define C_DUMB		'5'	/* Go dumb. Escape all '@' received, */
X				/* so no commands are processed. */
X#define C_UPLOAD	'6'	/* Open a file for writing, creating */
X				/* it if it doesn't exist, truncating */
X				/* it if it does. */
X#define C_DOWNLOAD	'7'	/* Open a file for reading. */
X#define C_UNLINK	'Z'	/* Delete a file */
X#define C_SOCKET        '8'	/* Connect to a unix-domain socket. */
X#define C_PUTENV        '9'	/* Puts an environmental variable */
X#define C_PORT          'A'	/* Connect to a TCP/IP port on the */
X				/* specified host, and port number. */
X#define C_PRIORITY      'd'	/* Raise/lower the priority of this */
X				/* client. */
X#define C_COMPRESS	'C'  	/* note, i jumped B :) (croutons). */
X				/* Turn compression on or off. */
X#define C_STAT          'D'	/* Get information on a remote file. */
X#define C_SEEK          'E'	/* Execute an lseek() on the remote */
X				/* file descriptor. Assumes the remote */
X				/* is a file handle, and not a socket. */
X#define C_STATS         'F'	/* Get information on various parts of */
X				/* term.  */
X#define C_NAME          'g'	/* Set the name of this client. Only */
X				/* used by C_STATS. */
X#define C_RESIZE        'h'	/* For handling SIGWINCH */
X#define C_BIND          'J'	/* Bind a remote socket. */
X#define C_ACCEPT        'K'	/* Accept a connection from a remotely */
X				/* bound sockets. */
X#define C_DUMP          'l'	/* Go dumb for the next 'n' bytes. */
X#define C_CLCLOSE       'M'     /* Close the remote fd when the */
X				/* buffers have been emptied. */
X#define C_QUIT          'N'	/* Shutdown term. */
X#define C_CHMOD		'O'	/* Change the mode of a file */
X#define C_BINDN         'U'     /* Bind a remote unspecified socket. -ot */
X#define C_BINDS         'S'     /* Allow connects one time only from a tcpip */
X                                /* socket... */
X#define C_UBIND         'T'     /* Bind a UDP socket */
X#define C_USOCK         'V'     /* Create a UDP socket */
X#define C_UDPSET        'W'     /* set UDP parameters */
X#define C_X_SERVER	'X'	/* Open connection to X server */
X
X#define C_GETSOCKNAME   'a'     /* Get the sockaddr */
X#define C_GETPEERNAME   'b'     /* Get the peername */
X#define C_GETHOSTNAME   'c'     /* Get the hostname */
X#define C_SETPEERNAME   'e'     /* Set the peername */
X#define C_LISTEN        'f'     /* Listens for connections */
X
X/* Return status */
X
X#define I_FAIL		'a'
X#define I_CLOSE		'b'
X#define I_EXIT		'c'
X#define I_OK		'd'
X#define I_NA		'X'
X
X#define HEADER_SIZE 6
X
X/* Prototypes */
X
Xint read_into_buff(int fd, struct Buffer *, int);
Xint write_from_buff(int fd, struct Buffer *, int);
Xint write_from_buff_async(int fd, struct Buffer *, int);
X
X
Xvoid set_share_mode(int, int);
Xint socket_connect_server(int,char *);
Xint connect_server(char *);
X
Xvoid set_nonblock(int);
Xint set_block(int);
X
Xvoid set_ttyraw(int);
Xvoid set_ttynormal(int);
X
Xtypedef int (*Callback) ( char, char *);
X
Xint client_options(int argc, char *argv[], char *myopts, Callback callback);
X
X#ifdef USE_VARARGS
Xint send_command();
X#else
Xint send_command(int, int, int, char *, ...);
X#endif
X
Xchar * build_arg(char**);
Xextern int priority;
Xextern int verbose;
X
Xint open_unix(char *);
Xint connect_unix(int,char *);
Xint duplicate_connect(int, int);
Xint bind_tcp(unsigned int);
Xint bind_tcp_listen(unsigned int, int);
Xint bind_unix(char *);
Xint use_term_command(int);
Xvoid do_select_loop(int, int, int);
Xextern char *term_server;
X
Xextern char *command_result;
X
Xint eaccess(char *pathname, int mode);
X
Xvoid do_connect(int num, int *svs, int (*get_server)(int,struct sockaddr *)); /* -ot */
X
Xchar *get_term_path(char **);
X
Xint term_putenv(char *);
X
Xvoid get_term_localaddr(unsigned long);
X
Xstruct hostent *host_lookup(char *,int,int,int,struct hostent *);
X
Xvoid term_do_exit(void);
X#if 0
Xint term_getpeername(int, struct sockaddr *, int *);
Xint term_getsockname(int, struct sockaddr *, int *);
Xint term_bind(int, struct sockaddr *, int);
Xint term_accept(int, struct sockaddr *, int *);
Xint term_connect(int, struct sockaddr *, int);
Xint term_recvfrom( int, char *, int, int, struct sockaddr *, int *);
Xint term_sendto(int, void *, int, unsigned int, struct sockaddr *, int); 
Xint term_gethostname(char *, size_t);
X#endif
Xint term_shutdown(int, int);
Xint term_close(int);
Xint term_listen(int, int);
Xint term_socket(int, int, int);
Xint term_rcmd(char **, unsigned short, char *, char *, char *, int *);
Xint term_fork(void);
Xint term_vfork(void);
Xint term_recv(int, char *, int, int);
Xstruct hostent *term_gethostbyname(char *);
Xvoid term_exit(int);
X
X#endif
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/client.h' &&
  chmod 0644 'term-2.2.5/client.h' ||
  echo 'restore of term-2.2.5/client.h failed'
  shar_count="`wc -c < 'term-2.2.5/client.h'`"
  test 5917 -eq "$shar_count" ||
    echo "term-2.2.5/client.h: original size 5917, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/compress.c ==============
if test -f 'term-2.2.5/compress.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/compress.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/compress.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/compress.c' &&
X/*
X** Copyright Michael O'Reilly. All rights reserved.
X*/
X#include "includes.h"
X#include "debug.h"
X				/* Following used for debugging. */
X#if 0
X#define ASSERT(a) \
X	((a) ? 0: abort() )
X#else
X#define ASSERT(a)
X#endif
X
X#define BYTE_WIDTH_OUT	tok_byte_width_out
X#define BYTE_MASK_OUT	tok_byte_mask_out
X
X#define BYTE_MASK_IN	tok_byte_mask_in
X#define BYTE_WIDTH_IN	tok_byte_width_in
X
Xint tok_byte_mask_out = 255,
X  tok_byte_width_out = 8;
Xint tok_byte_mask_in = 255,
X  tok_byte_width_in = 8;
X
Xint stat_comp_in = 0,
X  stat_comp_out = 0,
X  stat_uncomp_in = 0,
X  stat_uncomp_out = 0;
X/*
X** token 256 is reserved to signal that dict clearing should take place.
X** token 257 is reserved for future use.
X**
X** the max token size is 16 bits.
X*/
X
X#define DICT_SIZE  8192
X#define DICT_CLEAR_2 4096
X#define DICT_CLEAR_2_TSIZE 13
X
X/* #define DEBUG **/
X
Xtypedef struct node {
X    short   ch;			/* character for this node */
X    struct node *next_node;	/* Pointer to the next link on this node. */
X    struct node *child;		/* Pointer to a child of this node. */
X    int     len;		/* You tell me.  */
X    int     num;		/* token number for this node */
X}                   NODE;
X
X#ifdef DEBUG
XFILE * stdprn = 0;
X#endif
X#if 0
Xextern  void * malloc (int);
Xextern  void * realloc (char *, int);
X#endif
X
Xvoid clear_table (NODE *, int);
Xint  uncomp_dict[DICT_SIZE][2];
XNODE comp_dict = {
X    0, 0, 0, 0, 0
X};
X
Xstatic int  c_token_mask,
X            c_token_bits,
X            unc_token_bits,
X            unc_token_mask,
X
X            comp_table_size,
X            uncomp_table_size;
Xstatic int  stack[1024];
X
Xstatic int  stk_ptr = 0;
Xint compress_init (void) {
X    int     i;
X    if (comp_dict.child) {
X	for (i = 0; i < 256; ++i)
X	    clear_table (&(comp_dict.child[i]), 255);
X    }
X    else
X	comp_dict.child = (NODE *) malloc (256 * sizeof (NODE));
X    comp_dict.len = 256;
X    comp_dict.ch = 0;
X    comp_dict.num = 0;
X    comp_dict.next_node = 0;	/* Only one NODE in this node. */
X    for (i = 0; i < 256; ++i) {
X	uncomp_dict[i][0] = comp_dict.child[i].ch = i;
X	uncomp_dict[i][1] = -1;
X
X	comp_dict.child[i].num = i;
X	comp_dict.child[i].child = NULL;
X	comp_dict.child[i].len = 0;
X	comp_dict.child[i].next_node = &comp_dict.child[i+1];
X    }
X    comp_dict.child[255].next_node = (NODE *) 0;
X
X    comp_table_size = 258;
X    uncomp_table_size = 258;
X
X    c_token_bits = 9;
X    c_token_mask = 511;
X    unc_token_bits = 9;
X    unc_token_mask = 511;
X
X#ifdef DEBUG
X    if (!stdprn) stdprn = fopen ("compress.debug", "w");
X    setbuf(stdprn , 0);
X    fprintf(stdprn,"init\n");
X#endif
X    return 1;
X}
X
Xvoid compress_shut (void) {
X#ifdef DEBUG
X    fclose (stdprn);
X#endif
X}
X
X/* gets size bits from starting from bit 'curr' in the bit stream data */
X
Xunsigned int    get_token (un_char *data, int *curr, int max_size) {
X    unsigned long   ret;
X    int     byte,
X            bit,
X            read = 0,
X            tmp;
X    byte = *curr / BYTE_WIDTH_IN;
X    bit = *curr % BYTE_WIDTH_IN;
X    ret = 0;
X    while (read < unc_token_bits && byte < max_size) {
X	ret += ((int)(data[byte++] & BYTE_MASK_IN) >> bit) << read;
X	tmp = BYTE_WIDTH_IN - bit;
X	read += tmp;
X	bit = 0;
X    }
X    ret = ret & unc_token_mask;
X    *curr += unc_token_bits;
X    DEBUG_C(stderr, "%s:c_got: %ld\n", term_server, ret);
X    return (unsigned int) ret;
X}
X
Xvoid put_token (un_char *data, int *curr, unsigned int ch) {
X    int     byte,
X            bit;
X    DEBUG_C(stderr, "%s:c_put: %d\n", term_server, ch);
X    byte = *curr / BYTE_WIDTH_OUT;
X    bit = *curr % BYTE_WIDTH_OUT;
X    ch = ch & c_token_mask;
X    while (ch) {
X	data[byte] |= (ch&BYTE_MASK_OUT) << bit;
X	ch = ch >> (BYTE_WIDTH_OUT - bit);
X	bit = 0;
X	++byte;
X    }
X    *curr += c_token_bits;
X}
X
X/* Add a node to the list of free node's */
XNODE * node_list = NULL;
Xvoid free_node (n)
XNODE * n;
X{
X    n -> next_node = node_list;
X    node_list = n;
X}
X
X/* Take a node of the list of free nodes, creating more nodes if there */
X/* aren't enough to spare.. */
XNODE * get_node (void) {
X    NODE * n;
X    if (!node_list) {
X	n = (NODE *) malloc (sizeof (*n));
X	if (!n) abort();	/* fatal */
X	return n;
X    }
X    n = node_list;
X    node_list = node_list -> next_node;
X    return n;
X}
X
X/* Free this node, and any nodes pointed to by this node. */
Xvoid free_nodes(NODE *t) {
X    if (!t) return;
X    if (t->child) free_nodes(t->child);
X    if (t->next_node) free_nodes(t->next_node);
X    free_node(t);
X    }
X
X/* Clear all nodes larger than 'limit' */
X/* The compression dictionary is a tree , built from a list of lists. */
X /* The tree is a 1-256 tree. (each node can have up to 256 children). */
X /* This is implemented as each node being a list of child pointers. */
X /* Each node has a l for the child node, and an n pointer for the */
X /* next node on this level. */
X
X/* Thus, searching the tree consists of running down the 'n' list */
X /* until the first character is matched, and then following the 'l' */
X /* link. Then running down the 'n' again, and so on. */
Xvoid clear_table (dict, limit)
XNODE * dict;
Xint     limit;
X{
X    NODE * t, *t1, *tmp;
X    /* If we have no dictionary do nothing. */
X    if (!dict)
X	return;
X				/* This is fairly messy. We run across */
X				/* the current node, and build a list */
X				/* of all the nodes we still want. One */
X				/* of the properties of the tree we */
X				/* take advantage of that that all */
X				/* lower nodes are guaranteed to */
X				/* higher token numbers. */
X    tmp = 0;
X    for (t = dict -> child; t;)	/* Run across the current tree node. */
X	if (t -> num > limit) {	/* If this node is too large... */
X	    t1 = t;		/* remember current node, */
X	    t = t->next_node;	/* move loop pointer to next one */
X	    t1->next_node = 0;	/* and free just the one we had. */
X	    free_nodes(t1);
X	    }
X	else {
X	    clear_table (t, limit); /* Ok. Recurse through and look */
X				    /* through the lower levels. */
X	    t1 = t->next_node;	/* Move to next node,  */
X	    t->next_node = tmp;	/* and put the current node on the */
X				/* list of nodes to remember. */
X	    tmp = t;
X	    t = t1;
X	    }
X
X    dict->child = tmp;		/* ok. We built the list, now store it. */
X}
X
Xint     compress (un_char *outpath, int maxlen, int prefix) {
X  int     out_fd = 0;
X  int     suffix;
X  int	  input_count = 0, output_count;
X  int     max_bytes = 2048;	/* If you have better than 2048:maxlen */
X				/* compression your packet size will be */
X				/* smaller than maxlen. */
X  char    *kludge;
X  NODE * prfix, *pt;
X  int     i,
X  lim;
X  extern int stat_rare_out;
X
X  if ((prefix) < 0)		/* Get a byte if we can. */
X    return 0;			/* we can't, so we managed to compress */
X				/* zero bytes..  */
X
X  ++stat_comp_in;
X  prfix = &comp_dict.child[prefix]; /* Move to right point in dictionary.. */
X  
X  kludge = (char *) outpath;	/* this relies on 4 byte int's */
X  for (i = 0; i < 260; ++i)	/* clear the output buffer (need to do */
X				/* this, as the token out routines use */
X				/* OR'ing). Assumes the buffer can */
X				/* hold 260 characters. Thanks to */
X				/* Janne Sinkkonen for pointing this */
X				/* out. *blush*  */
X    kludge[i] = 0;
X  
X  
X  if (comp_table_size >= DICT_SIZE - 2) { /* if table is full. */
X#if 0
X    fprintf(stderr, "Clearing dict table\n");
X#endif
X    for (i = 0; i < 256; ++i)
X      clear_table (&(comp_dict.child[i]), DICT_CLEAR_2 - 1);
X    comp_table_size = DICT_CLEAR_2;
X    put_token (outpath, &out_fd, 256); /* Clear table. */
X    c_token_mask = 511;
X    c_token_bits = 9;
X  }
X  lim = (maxlen - 4) * BYTE_WIDTH_OUT; /* The maximum number of bits to */
X				/* output. */
X  
X#ifdef DEBUG
X  fprintf(stdprn, "Setting lim to %d\n", lim);
X#endif
X  while (out_fd < lim && max_bytes >= 0) { /* while we have output less then */
X				/* 'lim' bits. */
X    suffix = get_client_byte(); /* get the next byte. */
X    --max_bytes;
X    input_count++;
X    ++stat_comp_in;
X    ++stat_rare_out;
X
X    DEBUG_C(stderr, "%s:got byte == %d\n", term_server, suffix);
X
X    if (suffix < 0)		/* We has nothing left to compress so exit. */
X      break;
X    suffix &= 255;		/* Make it 8 bits. Not needed */
X				/* theoretically, but.. */
X    for (pt = prfix -> child; pt; pt = pt -> next_node)
X      if (pt -> ch == suffix)
X	break;
X    
X    if (pt) {			/* found */
X#ifdef DEBUG
X      fprintf(stdprn, " found\n");
X#endif
X      prfix = pt;		/* Just remember new prefix. */
X    }
X    else {			/* Ok. We have no token for this */
X				/* sequence, so we make a new token */
X				/* for it. */
X      if (comp_table_size < DICT_SIZE - 1) { /* if the dict isn't */
X					     /* full.. */
X	pt = get_node ();	/* Get a new node.. */
X	pt -> next_node = prfix -> child; /* and put it into tree. */
X	prfix -> child = pt;
X	pt -> ch = suffix;
X	pt -> child = NULL;	/* No child strings. */
X	pt -> num = comp_table_size++; /* Set the token number. */
X      }
X				/* Seeing as we are using explicit */
X				/* signaling to increase the token */
X				/* size, we might as well put it off */
X				/* for as long as we can. */
X      while (prfix->num > c_token_mask) { /* do we need to increase token */
X				/* size?? */
X	put_token(outpath, &out_fd, 257);
X	c_token_mask = (c_token_mask <<1) + 1;
X	c_token_bits ++;
X      }
X
X      put_token (outpath, &out_fd, (unsigned) prfix -> num); /* we output the */
X						  /* token as well. */
X      prfix = &comp_dict.child[suffix]; /* and init prfix to the new value. */
X    }
X  }
X
X  while (prfix->num > c_token_mask) { /* Just in case we need to increase */
X    put_token(outpath, &out_fd, 257); /* the token size. */
X    c_token_mask = (c_token_mask <<1) + 1;
X    c_token_bits ++;
X  }
X  put_token (outpath, &out_fd, (unsigned) prfix -> num); /* Put the last token we */
X					      /* had out. */
X  output_count = (out_fd+BYTE_WIDTH_OUT - 1) / BYTE_WIDTH_OUT;
X  stat_comp_out += output_count;
X  return (output_count > input_count) ? -out_fd : out_fd;
X}
X
Xint uncompress(un_char *data, int len, un_char *outpath) {
Xint out_fd = 0, in_fd = 0;
Xstatic int token, oldtoken, newtoken, finaltoken;
Xint size;
Xstatic int started = 0;
X
X#ifdef DEBUG
X	fprintf(stdprn, "Uncompress\n");
X#endif
X	if (uncomp_dict == NULL) return -1;
X	stk_ptr = in_fd = out_fd = 0;
X	size = len * BYTE_WIDTH_IN ;
X	if (!started) {
X	        ASSERT(in_fd == 0);
X		token = get_token(data , &in_fd, len);
X		oldtoken= token;
X		finaltoken = token;
X		outpath[out_fd++]= token;
X#ifdef DEBUG
X		fprintf(stdprn, "[%d]", token);
X#endif
X		}
X
X	if (started == 0) started = 2;
X	else started = 1;
X#ifdef DEBUG
X	fprintf(stdprn, "Uncompress 1\n");
X#endif
X	while (in_fd + unc_token_bits <= size) {
X        	token = get_token(data, &in_fd, len);
X		ASSERT(in_fd <= size);
X#ifdef DEBUG
X	fprintf(stdprn, "new token == %d\n", token);
X#endif
X		if (token == 256) {
X			uncomp_table_size = DICT_CLEAR_2;
X			unc_token_bits = 9;
X			unc_token_mask = 511;
X			continue;
X			}
X		else if (token == 257) { /* increase token size by one bit. */
X			unc_token_bits ++;
X			unc_token_mask <<=1;
X			++unc_token_mask;
X			continue;
X			}
X		newtoken = token;
X
X		if (uncomp_table_size <= newtoken) {
X			stack[stk_ptr ++ ] = finaltoken;
X			ASSERT(stk_ptr > 0);
X			ASSERT(stk_ptr < 1024);
X#ifdef DEBUG
X		fprintf(stdprn, "[%d]", finaltoken);
X#endif
X			token = oldtoken;
X			}
X		while (uncomp_dict[token][1]>=0) {
X		  stack[stk_ptr++] = uncomp_dict[token][1];
X		  ASSERT(stk_ptr < 1024);
X		  ASSERT(stk_ptr > 0);
X		  token = uncomp_dict[token][0];
X		}
X		
X		outpath[out_fd++] = token;
X		ASSERT(out_fd < 2048);
X		ASSERT(out_fd > 0);
X#ifdef DEBUG
X		fprintf(stdprn, "[ %d]", token);
X#endif
X		finaltoken = token;
X		while (stk_ptr) {
X		  outpath[out_fd++] = stack[--stk_ptr];
X		  ASSERT(out_fd < 2048);
X		  ASSERT(out_fd > 0);
X			ASSERT(stk_ptr >= 0);
X#ifdef DEBUG
X			fprintf(stdprn, "[%d]", stack[stk_ptr]);
X#endif
X			}
X		ASSERT(uncomp_table_size < (DICT_SIZE + 1));
X		if (uncomp_table_size <DICT_SIZE) {
X/*		        if (oldtoken == token) abort(); */
X			uncomp_dict[uncomp_table_size][0] = oldtoken;
X			uncomp_dict[uncomp_table_size][1] = token;
X
X
X#ifdef DEBUG
X			fprintf(stdprn, "Adding %d %d to table as %d\n", oldtoken, token, uncomp_table_size);
X#endif
X			if (started ==1 ) started = 2;
X			else ++uncomp_table_size;
X			}
X		oldtoken = newtoken;
X		}
X	return out_fd;
X	}
X
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/compress.c' &&
  chmod 0644 'term-2.2.5/compress.c' ||
  echo 'restore of term-2.2.5/compress.c failed'
  shar_count="`wc -c < 'term-2.2.5/compress.c'`"
  test 12112 -eq "$shar_count" ||
    echo "term-2.2.5/compress.c: original size 12112, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/config.h ==============
if test -f 'term-2.2.5/config.h' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/config.h (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/config.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/config.h' &&
X/*
X *
X * USE_IOCTL use ioctl() to set non-blocked io instead of fcntl()
X *
X * USE_SETSID use setsid() to become process leader
X *
X * USE_TIOCSCTTY use ioctl() to acquire a controlling terminal
X *
X * USE_TERMIOS uses the termios struct to control terminals.
X *   Comment this out if you want to use sgtty instead.
X * 
X * ERR_BLOCK sets the errno that is returned for an operation
X * that blocked.
X *
X * USE_VHANGUP says to run vhangup() on the new ptys.
X *
X * USE_TCATTR uses tc{get/set}attr() instead of ioctl's to set
X * termios.
X *
X * USE_SIGWINCH tells trsh to watch for SIGWINCH. Only define it if
X * your system supports it.
X *
X * USE_WINCHKILL if you sigwinch is broken, and doesn't send the
X * signal when the window size gets changed.
X *
X * USE_HERROR specifies that herror() should be used, not term_herror().
X *
X * USE_CONNBLOCK this specifies that term may block waiting for a
X * a connection.
X *
X * USE_WAITPID use waitpid() instead of wait3()
X *
X * USE_ONEXIT use onexit instead of atexit()
X *
X * USE_NOEOF when a client is closing, don't wait for an EOF in the stream.
X *
X * NO_ATEXIT don't use either
X *
X * Any combination of the following may be defined for txconn:
X *    X_TCP_SOCKET   - use a tcp style of socket for txconn (default)
X *    X_UNIX_SOCKET  - use a plain unix socket for txconn
X *    X_STREAMS_PIPE - use a streams pipe for txconn
X */
X
X	/* First we do simple, OS specific rules */
X
X#ifdef linux
X#define USE_SIGWINCH
X#define USE_SETSID
X#define USE_TERMIOS
X#define USE_VHANGUP
X#define USE_HERROR 
X#define ERR_BLOCK  EAGAIN
X#endif
X
X#ifdef DGUX
X#ifndef SYSV
X#define SYSV
X#endif
X#define USE_IOCTL
X#define USE_SETSID
X#define USE_TERMIOS
X#define USE_TCATTR
X#define USE_WINCHKILL
X#define ERR_BLOCK EAGAIN
X#ifdef NO_UNIX_DOMAIN
X#undef NO_UNIX_DOMAIN
X#endif
X#endif
X
X#ifdef EPIX
X/* this works for the EP/IX Version 2.1.1AC */
X#define USE_SIGWINCH
X#define USE_VHANGUP
X#define ERR_BLOCK  EWOULDBLOCK
X#define USE_SETPGRP
X#define USE_TIOCNOTTY
X#define NO_ATEXIT
X#ifdef BSD
X#undef BSD
X#endif
X#endif
X 
X#ifdef ISC
X#ifndef SYSV
X# define SYSV
X#endif
X#define USE_SETSID
X#define USE_TERMIOS
X#define USE_TCATTR
X#define USE_WINCHKILL
X#define USE_WAITPID
X#define ERR_BLOCK EAGAIN
X#define NO_VFORK
X#ifndef NO_UNIX_DOMAIN
X#define NO_UNIX_DOMAIN
X#endif
X#define NO_ATEXIT
X#define _XOPEN_SOURCE
X#endif /* ISC */
X
X#ifdef DYNIXPTX
X#ifndef SYSV
X#  define SYSV
X#endif
X#define HAS_PSEUDO
X#define USE_WAITPID
X#define USE_SIGWINCH
X#define USE_TERMIOS
X#define USE_TCATTR
X#define USE_STIME
X#define ERR_BLOCK EAGAIN
X#define USE_SETPGRP
X#ifndef I_TIME
X# define I_TIME
X#endif
X#ifndef I_TYPES
X#define I_TYPES
X#endif
X#endif
X
X#ifdef SVR4
X#ifndef SYSV
X# define SYSV
X#endif
X#define USE_WAITPID
X#define USE_SIGWINCH
X#define USE_SETSID
X#define USE_TERMIOS
X#define USE_TCATTR
X#define ERR_BLOCK  EAGAIN
X#endif
X
X#ifdef SCO
X#ifndef SYSV
X#define SYSV
X#endif
X#define X_DEFAULT_DISPLAY_NUM 7
X#define USE_IOCTL
X#define USE_SETSID
X#define USE_TERMIOS
X#define USE_TCATTR
X#define USE_WINCHKILL
X#define ERR_BLOCK EAGAIN
X#define STREAMS_PIPE
X#define X_STREAMS_PIPE
X#ifndef NO_UNIX_DOMAIN
X#define NO_UNIX_DOMAIN
X#endif
X#endif
X
X#ifdef ultrix
X#define USE_IOCTL
X#define USE_SIGWINCH
X#define USE_TIOCNOTTY
X#define USE_VHANGUP
X#define USE_TERMIOS
X#define USE_HERROR
X#define ERR_BLOCK EWOULDBLOCK
X#endif
X
X#ifdef NeXT
X#define USE_IOCTL
X#define USE_VHANGUP
X#define USE_TCATTR
X#define USE_SIGWINCH
X#define USE_TIOCNOTTY
X#define ERR_BLOCK EWOULDBLOCK
X#ifndef I_TYPES
X#define I_TYPES
X#endif
X#endif
X
X#ifdef BSDI
X#define USE_TCATTR
X#define ERR_BLOCK EWOULDBLOCK
X#define USE_TIOCNOTTY
X#endif
X
X#ifdef __MACHTEN__
X#define USE_VHANGUP
X#define USE_HERROR
X#define USE_SIGWINCH
X#define ERR_BLOCK  EAGAIN
X#endif
X 
X#if defined(__hpux)
X#define X_UNIX_SOCKET
X#define X_TCP_SOCKET
X#define USE_SIGWINCH
X#define USE_TERMIOS
X#define USE_TCATTR
X#define USE_NOEOF
X#define USE_SETSID
X#define ERR_BLOCK EAGAIN
X#endif
X
X#ifdef _AIX
X#define USE_SIGWINCH
X#define USE_TERMIOS
X#define USE_TCATTR
X#define ERR_BLOCK EAGAIN
X#define USE_SETPGRP
X#define USE_TIOCNOTTY
X#endif
X
X#ifdef sgi
X#define	USE_SETSID
X#define	USE_VHANGUP
X#define	USE_TERMIOS
X#define	USE_TCATTR
X#define ERR_BLOCK EAGAIN
X#endif
X
X#ifdef __QNX__
X#define NO_STRERROR
X#define USE_WAITPID
X#define USE_HERROR 
X#define USE_SIGWINCH
X#define USE_TCATTR
X#define USE_TERMIOS
X#define USE_TTYNAME
X#define USE_SPAWN
X#define USE_NOEOF
X#define ERR_BLOCK      EAGAIN
X#endif
X
X#ifdef titan
X#define NO_PTYEXEC
X#define USE_VARARGS
X#define	USE_SETIDS
X#define NO_SIGWINCH
X#define NO_ATEXIT
X#endif
X
X#ifdef IRIX
X#define NO_SIGWINCH
X#define NO_VFORK
X#endif
X
X#ifdef __NetBSD__
X#define USE_TERMIOS
X#define USE_TCATTR
X#define ERR_BLOCK EWOULDBLOCK
X#define USE_SETPGRP
X#endif
X
X#if defined(___386BSD___) || defined(__386BSD__)
X#define USE_TCATTR
X#define ERR_BLOCK EWOULDBLOCK
X#define USE_SETPGRP
X#endif
X
X#if defined(__OSF1__)  || defined(__OSF__) || defined(__osf__)
X#ifndef SYSV
X#define SYSV
X#endif
X#define USE_TCATTR
X#define ERR_BLOCK EWOULDBLOCK
X#define USE_SETSID
X#define USE_TIOCSCTTY
X#define USE_SIGWINCH
X#define NO_VHANGUP
X#endif
X
X	/* Now the more complicated stuff */
X
X#if defined(__convex__) && !defined(convex)
X#define convex
X#endif
X
X#ifndef SVR4
X#if defined(sun) || defined(convex)
X#define USE_TERMIOS
X#define USE_TCATTR
X#define ERR_BLOCK EAGAIN
X#ifndef NO_VHANGUP
X#define USE_VHANGUP
X#endif
X#ifndef NO_SIGWINCH
X#define USE_SIGWINCH
X#endif
X#if defined(sun)
X#define HAS_SETSID
X#define USE_STRERROR
X#define USE_WINCHKILL
X#define USE_ONEXIT
X#define USE_SETPGRP
X#else
X#define USE_SETSID
X#endif
X#endif
X#endif /* SVR4 */
X
X#if defined(BSD) && !defined(BSDI)
X#define USE_TCATTR
X#define USE_SETPGRP
X#define ERR_BLOCK EWOULDBLOCK
X#endif
X
X#if defined(BSD) && !defined(NO_SIGWINCH)
X#define USE_SIGWINCH
X#endif
X
X#ifdef hcx
X#ifdef att_universe
X#define USE_VHANGUP
X#define USE_TERMIOS
X#define USE_TCATTR
X#else /* ucb_universe */
X#define NO_VSPRINTF
X#endif
X#define USE_SETSID
X#define ERR_BLOCK EAGAIN
X#define USE_HERROR
X#define USE_SIGWINCH
X#endif
X
X#if !defined(NO_UNIX_DOMAIN) && defined(TERM_NFS_DIR)
X# define NO_UNIX_DOMAIN
X#endif
X
X#if !defined(ERR_BLOCK) /* if no OS defined */
X/* 
X#error "Need to define an OS" 
XUltrix MIPS compiler chokes on this, even though ERR_BLOCK is defined!
X*/
X"Compilation directive: You need to define an OS";
X/* (Note: We do need the semicolon above for the Mips-CC , argh ;-() */
X/* If your OS isn't defined you need to work out which of the above defines */
X/* you need and build and entry for it. Please send me the diff if you do so */
X/* I am oreillym@tartarus.uwa.edu.au */
X#endif
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/config.h' &&
  chmod 0644 'term-2.2.5/config.h' ||
  echo 'restore of term-2.2.5/config.h failed'
  shar_count="`wc -c < 'term-2.2.5/config.h'`"
  test 6479 -eq "$shar_count" ||
    echo "term-2.2.5/config.h: original size 6479, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/configure ==============
if test -f 'term-2.2.5/configure' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/configure (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/configure (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/configure' &&
X#!/bin/sh
X# Simple configure script for term.  No feature detection is done; we just
X# figure out which OS we are using and modify the Makefile appropriately.
X#
X# The argument parsing and srcdir code are modified Gnu autoconf output.
X# That puts this script under GPL, but there is no configure.in to 
X# distribute along with it; so it goes.
X#
X# Chris Metcalf, June 1994
X# Modified June 1994, bcr@physics.purdue.edu
X
Xprefix=unknown
Xsrcdir=unknown
Xjump_lib=unknown
Xjump_dir=unknown
Xbindir=unknown
Xlibdir=unknown
Xincdir=unknown
Xmandir=unknown
Xshlib=unknown
Xsharedir=unknown
Xis_root=unknown
Xone_client=unknown
XMakefile=Makefile
XSTRIP='strip'
X
X# Figure out how to echo without newline
Xif [ x"`echo -n`" = x-n ]; then
X       echo_n=
X       echo_c='\c'
Xelse
X       echo_n=-n
X       echo_c=
Xfi
X
X
Xfor arg
Xdo
X  # 	Handle arguments with a space
X  if [ x$next_Makefile = xyes ] ; then Makefile=$arg; next_Makefile=
X  elif [ x$next_prefix = xyes ] ; then prefix=$arg; next_prefix=
X  elif [ x$next_srcdir = xyes ] ; then srcdir=$arg; next_srcdir=
X  elif [ x$next_jump_lib = xyes ] ; then jump_lib=$arg; next_jump_lib=
X  elif [ x$next_mandir = xyes ] ; then mandir=$arg; next_mandir=
X  elif [ x$next_bindir = xyes ] ; then bindir=$arg; next_bindir=
X  elif [ x$next_incdir = xyes ] ; then incdir=$arg; next_incdir=
X  elif [ x$next_libdir = xyes ] ; then libdir=$arg; next_libdir=
X  elif [ x$next_sharedir = xyes ] ; then sharedir=$arg; next_sharedir=
X  else
X    case $arg in
X     -Makefile=* | --Makefile=*)
X	Makefile=`echo $arg | sed 's/[-A-Za-z_]*=//'` ;;
X     -M | -Makefile | --Makefile)
X	next_Makefile=yes ;;
X
X     -prefix=* | --prefix=*)
X	prefix=`echo $arg | sed 's/[-A-Za-z_]*=//'` ;;
X     -p | -prefix | --prefix)
X	next_prefix=yes ;;
X
X     -srcdir=* | --srcdir=*)
X	srcdir=`echo $arg | sed 's/[-A-Za-z_]*=//'` ;;
X     -s | -srcdir | --srcdir)
X	next_srcdir=yes ;;
X
X     -jump_lib=* | --jump_lib=*)
X	jump_lib=`echo $arg | sed 's/[-A-Za-z_]*=//'` ;;
X     -j | -jump_lib | --jump_lib)
X	next_jump_lib=yes ;;
X
X     -mandir=* | --mandir=*)
X	mandir=`echo $arg | sed 's/[-A-Za-z_]*=//'` ;;
X     -m | -mandir | --mandir)
X	next_mandir=yes ;;
X
X     -bindir=* | --bindir=*)
X	bindir=`echo $arg | sed 's/[-A-Za-z_]*=//'` ;;
X     -b | -bindir | --bindir)
X	next_bindir=yes ;;
X
X     -incdir=* | --incdir=*)
X	incdir=`echo $arg | sed 's/[-A-Za-z_]*=//'` ;;
X     -i | -incdir | --incdir)
X	next_incdir=yes ;;
X
X     -libdir=* | --libdir=*)
X	libdir=`echo $arg | sed 's/[-A-Za-z_]*=//'` ;;
X     -l | -libdir | --libdir)
X	next_libdir=yes ;;
X
X     -sharedir=* | --sharedir=*)
X	sharedir=`echo $arg | sed 's/[-A-Za-z_]*=//'` ;;
X     -S | -sharedir | --sharedir)
X	next_sharedir=yes ;;
X
X     -u | -user | --user)
X       is_root=no ;;
X
X     -r | -root | --root)
X       is_root=yes ;;
X
X     -h | -usage | --usage | -help | --help)
X       echo 'Usage: configure [<OS Type>] [-user] [-root] [-prefix=/usr/local]'
X       echo '                 [-mandir=$prefix/man/man1] [-bindir=$prefix/bin]'
X       echo '                 [-libdir=$prefix/lib] [-sharedir=$libdir/term]'
X       echo '                 [-incdir=$prefix/include] [-shlib] [-static]'
X       echo '                 [-verbose] [-usage]'
X       exit 0 ;;
X
X     -v | -verbose | --verbose)
X       verbose=yes ;;
X
X     -shlib | --shlib)
X       shlib=yes ;;
X
X     -static | --static)
X       shlib=no ;;
X
X     *) OS=$arg ;;
X    esac
X  fi
Xdone
X
X
X# A filename unique to this package, relative to the directory that
X# configure is in, which we can look for to find out if srcdir is correct.
Xunique_file=term_putenv.c
X
X# Find the source files, if location was not specified.
Xif [ "x$srcdir" = xunknown ] ; then
X  srcdirdefaulted=yes
X  # Try the directory containing this script, then `..'.
X  prog=$0
X  confdir=`echo $prog|sed 's%/[^/][^/]*$%%'`
X  [ "X$confdir" = "X$prog" ] && confdir=.
X  srcdir=$confdir
X  if [ ! -r $srcdir/$unique_file -a ! -r "$srcdir/$unique_file",v ]; then
X    srcdir=..
X  fi
Xfi
X
Xif [ ! -r $srcdir/$unique_file -a ! -r "$srcdir/$unique_file",v ] ; then
X  if [ x$srcdirdefaulted = xyes ] ; then
X    echo "configure: Can not find sources in \`${confdir}' or \`..'." 1>&2
X  else
X    echo "configure: Can not find sources in \`${srcdir}'." 1>&2
X  fi
X  exit 1
Xfi
X
X# Preserve a srcdir of `.' to avoid automounter screwups with pwd.
X# But we can't avoid them for `..', to make subdirectories work.
Xcase $srcdir in
X  .|/*|~*) ;;
X  *) srcdir=`cd $srcdir; pwd` ;; # Make relative path absolute.
Xesac
X
X# If you cd and need to find the srcdir
Xabs_srcdir=`cd $srcdir; pwd`
Xif [ x$jump_lib = xunknown ] ; then
X  jump_dir=$abs_srcdir"/jump"
X  jump_lib=libtermnet
Xelse
X  jump_dir=`pwd`/jump
Xfi  
X
Xif [ x$is_root = xunknown ] ; then
X  if [ -w /etc/passwd ] ; then
X    is_root=yes  
X  elif [ x$USER = xroot ] ; then
X    is_root=yes 
X  elif [ x$LOGNAME = xroot ] ; then
X    is_root=yes
X  else 
X    ans=
X    while [ x$ans != xy -a x$ans != xn ] ; do  
X      echo $echo_n "Can you install as root? (y/n) $echo_c"
X      read ans
X    done
X    if [ x$ans = xy ] ; then
X      is_root=yes
X    else
X      is_root=no
X    fi
X  fi
Xfi
X  
Xif [ x$is_root = xyes ] ; then
X  setid=g+s
X  if [ x$prefix = xunknown ] ; then prefix=/usr/local ; fi
X  if [ x$libdir = xunknown ] ; then libdir=$prefix/lib ; fi
X  if [ x$sharedir = xunknown ] ; then sharedir=$libdir/term ; fi
Xelse
X  setid=u+s
X  if [ x$prefix = xunknown ] ; then prefix=$HOME ; fi
X  if [ x$sharedir = xunknown ] ; then sharedir=$prefix/term ; fi
X  if [ x$libdir = xunknown ] ; then libdir=$prefix/term ; fi
Xfi
SHAR_EOF
  : || echo 'restore of term-2.2.5/configure failed'
fi
echo 'End of archive part 3'
echo 'File term-2.2.5/configure is continued in part 4'
echo 4 > _sharseq.tmp
exit 0
