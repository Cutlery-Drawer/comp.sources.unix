Newsgroups: comp.sources.unix
From: bcr@physics.purdue.edu (Bill C. Riemers)
Subject: v28i168: term-2.2.5 - SLIP-like functionality between two *IX hosts (REPOST), Part05/09
References: <1.784237938.15304@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: bcr@physics.purdue.edu (Bill C. Riemers)
Posting-Number: Volume 28, Issue 168
Archive-Name: term-2.2.5/part05

#!/bin/sh
# This is `part05' (part 5 of a multipart archive).
# Do not concatenate these parts, unpack them in order with `/bin/sh'.
# File `term-2.2.5/download.c' is being continued...
#
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  echo 'WARNING: not restoring timestamps.  Consider getting and'
  echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if test ! -r _sharseq.tmp; then
  echo 'Please unpack part 1 first!'
  exit 1
fi
shar_sequence=`cat _sharseq.tmp`
if test "$shar_sequence" != 5; then
  echo "Please unpack part $shar_sequence next!"
  exit 1
fi
if test ! -f _sharnew.tmp; then
  echo 'x - still skipping term-2.2.5/download.c'
else
  echo 'x - continuing file term-2.2.5/download.c'
  sed 's/^X//' << 'SHAR_EOF' >> 'term-2.2.5/download.c' &&
X	    if ((lcksum) && (lcksum!=rcksum)) {
X	      fprintf(stderr, "F\n\tRemote and local file checksums don't"
X		      " match after upload!\n");
X	      err=j=1;
X	    } else {
X	      fprintf(stderr, "OK\n");
X	    }
X	  } else {
X	    fprintf(stderr, "?\n");
X	  }
X	}
X      }
X      if (!err && download_unlinkmode)
X        remote_unlink = file;
X    }
X
X  /* delete the last file if it was transferred successfully... painful */
X  if (remote_unlink) {
X    if (send_command(term, C_UNLINK, 0, "%s", remote_unlink) < 0) {
X      fprintf(stderr,"\tUnable to remove sent file\n");
X      j=1;
X    } else
X      fprintf(stderr,"\tSent file removed.\n");
X    remote_unlink = NULL;
X  }
X  }
X
X  /* give them global cps rating */
X  if ( (verbose > 1) && (filesent > 1) ) {
X    gettime(&total_stoptime);
X    etime = download_delta_timeval(&total_stoptime, &total_starttime);
X    if (etime == 0)
X      etime = 0.1;
X    fprintf(stderr, "%ld total bytes received in %.1f seconds; overall CPS %.0f\n",
X      total_bytesrecvd, etime, total_bytesrecvd/total_etime); 
X  }
X
X  exit(j);
X}
SHAR_EOF
  echo 'File term-2.2.5/download.c is complete' &&
  $shar_touch -am 1028144694 'term-2.2.5/download.c' &&
  chmod 0644 'term-2.2.5/download.c' ||
  echo 'restore of term-2.2.5/download.c failed'
  shar_count="`wc -c < 'term-2.2.5/download.c'`"
  test 17164 -eq "$shar_count" ||
    echo "term-2.2.5/download.c: original size 17164, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/host_lookup.c ==============
if test -f 'term-2.2.5/host_lookup.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/host_lookup.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/host_lookup.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/host_lookup.c' &&
X#define I_MEMORY
X#include "includes.h"
X
X/* This intended to speedup hostname lookups by keeping a list of
X * already known hostnames.  The translations is:
X *   gethostbyaddr(addr,len,type) --> host_lookup(addr,len,type,0,NULL)
X *   gethostbyname(name)          --> host_lookup(name,0,AF_INET,0,NULL)
X *
X *    how -->  0 is for local network lookups, 1 is for special lookups.
X *    add_hp --> Only makes sense with "how=1".  This specifies that if
X *               the host isn't already listed, add this host lookup
X *		 to the table of hostnames.
X *
X * The main advantage of this routine is the lookup table avoids saves time
X * by avoiding networking calls to get addresses we already know.  The main
X * disadvantage is that if there is a problem with the named server, the
X * client program won't check again later to see if it has been resolved.
X */
X
Xstruct hostent *host_lookup(char *addr,int length, int type, int how,
X    struct hostent *add_hp) {
X  int i, j, k;
X  static int num_hosts = 0;
X  struct hostent *hp = NULL;
X  typedef struct {
X	struct hostent hs;
X	unsigned long ip_addr;
X        int active, how, h_errno;
X    } Hosts_type;
X  static Hosts_type *Hosts = NULL;
X  extern int h_errno;
X
X  if (! addr) return add_hp;
X  if (type != AF_INET) {
X    if (! length) 
X      return hp = gethostbyname(addr);
X    else
X      return hp = gethostbyaddr(addr, length, type);
X  }
X
X  if (! length) {
X    for(i=0;i < num_hosts; ++i) 
X      if (Hosts[i].hs.h_name && how == Hosts[i].how) {
X        if (! strcmp(addr,Hosts[i].hs.h_name)) break;
X	if (! Hosts[i].hs.h_aliases) continue;
X        for(j = 0; Hosts[i].hs.h_aliases[j]; j++) 
X          if (! strcmp(addr,Hosts[i].hs.h_aliases[j]) ) break;
X        if (Hosts[i].hs.h_aliases[j]) break;
X      }
X  }else  {
X    for(i=0;i < num_hosts; ++i) 
X      if (Hosts[i].ip_addr != ~0 && how == Hosts[i].how) {
X        if (! memcmp(addr,&Hosts[i].ip_addr,length)) break;
X	if (! Hosts[i].hs.h_addr_list) continue;
X	for(j = 0; Hosts[i].hs.h_addr_list[j]; j++) 
X          if (! memcmp(addr,Hosts[i].hs.h_addr_list[j],length)) break;
X        if (Hosts[i].hs.h_addr_list[j]) break;
X      }
X  }
X
X  if (i < num_hosts) {
X    if (Hosts[i].active) return &Hosts[i].hs;
X    h_errno = Hosts[i].h_errno;
X    return NULL;
X  }
X
X  if (how && ! add_hp) return NULL;
X
X  if (!Hosts) 
X    Hosts = (Hosts_type *) malloc(sizeof(Hosts_type));
X  else 
X    Hosts = (Hosts_type *) realloc((char *) Hosts, (num_hosts + 1) *
X                                   sizeof(Hosts_type)); 
X  memset(&Hosts[(i = num_hosts++)],0,sizeof(Hosts_type));
X
X
X  Hosts[i].hs.h_addrtype = AF_INET;
X  Hosts[i].hs.h_name = NULL;
X  Hosts[i].how = how;
X  Hosts[i].ip_addr = ~0;
X  Hosts[i].hs.h_aliases = NULL;
X  if (! how) {
X    if (! length) 
X      hp = gethostbyname(addr);
X    else
X      hp = gethostbyaddr(addr, length, AF_INET);
X  }else {
X    hp = add_hp;
X  }
X
X  Hosts[i].active = 0;
X  if (! hp) {
X    char *s = NULL;
X    Hosts[i].h_errno = h_errno;
X    Hosts[i].hs.h_length = sizeof(unsigned long);
X    if (! length) {
X      if ((s = (char *)malloc(strlen(addr)+2))) {
X        strcpy(s,addr);
X        s[strlen(s)+1] = 0;
X        Hosts[i].hs.h_name = s;
X      }
X    }else {
X      memcpy(&Hosts[i].ip_addr,addr,length);
X    }
X    return NULL;
X  }
X  Hosts[i].h_errno = 0;
X  Hosts[i].hs.h_length = hp->h_length;
X  if (hp->h_addrtype != AF_INET) return hp;
X
X	/* Copy the list of aliases */
X
X
X  for(k=j=0; hp->h_aliases[j]; ++j)
X    k += 1 + strlen(hp->h_aliases[j]);
X
X  if ((Hosts[i].hs.h_aliases = (char **)malloc((j+1) * sizeof(char *)))) {
X    char *s = NULL;
X    if ((s = (char *)malloc(k))) {
X      for(j=0; hp->h_aliases[j]; ++j) {
X        strcpy(s,hp->h_aliases[j]);
X        Hosts[i].hs.h_aliases[j] = s;
X        s += strlen(s) + 1;
X      }
X      Hosts[i].hs.h_aliases[j] = NULL;
X    }else {
X      Hosts[i].hs.h_aliases[0] = NULL;
X    }
X  }
X	/* Copy the list of addresses */
X
X  for(k=j=0; hp->h_addr_list[j]; ++j)
X    k += hp->h_length;
X
X  if ((Hosts[i].hs.h_addr_list = (char **)malloc((j+1) * sizeof(char *)))) {
X    char *s = NULL;
X    if ((s = (char *)malloc(k))) {
X      for(j=0; hp->h_addr_list[j]; ++j) {
X        unsigned long l;
X        memcpy(s,hp->h_addr_list[j],hp->h_length);
X        Hosts[i].hs.h_addr_list[j] = s;
X	memcpy(&l,s,hp->h_length);
X        s += hp->h_length;
X      }
X      Hosts[i].hs.h_addr_list[j] = NULL;
X    }else {
X      Hosts[i].hs.h_addr_list[0] = NULL;
X    }
X  }
X
X	/* Make sure the input is part of the stored entry */
X
X  if (! length) {
X    memcpy(&Hosts[i].ip_addr,Hosts[i].hs.h_addr,hp->h_length);
X    Hosts[i].hs.h_name = (char *) malloc(strlen(addr)+1);
X    strcpy((char *)Hosts[i].hs.h_name, addr);
X  }else {
X    memcpy(&Hosts[i].ip_addr,addr,sizeof(Hosts[i].ip_addr)); 
X    Hosts[i].hs.h_name = (char *) malloc(strlen(hp->h_name)+1);
X    strcpy((char *)Hosts[i].hs.h_name, hp->h_name);
X  }
X  Hosts[i].active = 1;
X  return hp;
X}
X
X
X
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/host_lookup.c' &&
  chmod 0644 'term-2.2.5/host_lookup.c' ||
  echo 'restore of term-2.2.5/host_lookup.c failed'
  shar_count="`wc -c < 'term-2.2.5/host_lookup.c'`"
  test 4867 -eq "$shar_count" ||
    echo "term-2.2.5/host_lookup.c: original size 4867, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/includes.h ==============
if test -f 'term-2.2.5/includes.h' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/includes.h (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/includes.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/includes.h' &&
X
X/*
X**
X*/
X
X#include "config.h"
X
X	/* This is just to help track what is always being included */
X#ifndef I_ALWAYS
X# define I_ALWAYS
X#endif
X
X#ifndef I_TIME
X# ifdef I_SYS
X#  define I_TIME
X# endif
X#endif
X
X	/* This helps avoid conflicts when using libtermnet.a */
X#if defined(I_ERRNO)
X# include <errno.h>
X#endif
X
X#ifdef I_CTYPE
X# include <ctype.h>
X#endif
X
X#ifdef I_ALWAYS
X# ifndef titan
X#  include <sys/types.h>
X#  ifdef ISC
X#   include <sys/bsdtypes.h>
X#   include <net/errno.h>
X#  endif /* ISC */
X# else
X#  include <types.h>
X# endif
X#endif
X
X#ifdef I_IOCTL
X# if !defined(I_TTY) || !defined(sun) || defined(SVR4)
X#  include <sys/ioctl.h>
X# endif
X# if defined(SVR4)
X#  include <sys/filio.h>		/* FIONREAD */
X# endif
X# include <fcntl.h>
X# ifndef FD_CLOEXEC
X#  define FD_CLOEXEC 1
X# endif
X#endif
X
X#ifdef I_STRING
X# include <string.h>
X#endif
X
X#ifdef I_ALWAYS
X# if !defined(NO_UNIX_DOMAIN)
X#  include <sys/un.h>
X# endif
X# include <netinet/in.h>
X# include <netdb.h>
X# include <sys/socket.h>
X# ifdef SYSV
X#  include <sys/utsname.h>
X# endif
X# ifdef SVR4
X   int accept(int, struct sockaddr *, int *);
X   int bind(int, struct sockaddr *, int);
X   int connect(int, struct sockaddr *, int);
X   int listen(int, int);
X   int socket(int, int, int);
X   int socketpair(int, int, int, int[]);
X   int shutdown(int, int);
X   int gethostname(char *, size_t);
X#ifdef UNIX_SV
X   int recvfrom(int,char *,int,struct sockaddr *,int);
X   int sendto(int,char *,int,struct sockaddr *,int);
X   int getpeername(int, struct sockaddr *, int);
X   int getsockname(int, struct sockaddr *, int);
X   int rcmd(char **,unsigned short, char *, char *, char *, int *);
X#endif
X# endif
X# ifdef SVR3
X#  define socketpair term_socketpair
X# endif
X# ifndef NO_UNIX_DOMAIN
X#  define S_Pipe(soc) socketpair(AF_UNIX, SOCK_STREAM, 0, soc) 
X# else
X#  ifndef SCO
X#   define S_Pipe(soc) socketpair(AF_INET, SOCK_STREAM, 0, soc)
X#  else
X#   define S_Pipe(soc) s_pipe(soc)
X#  endif
X# endif
X#endif
X
X#ifdef I_GETOPT
X  int term_getopt(int argc, char *argv[], char *optstring);
X  extern char *term_optarg;
X  extern int term_optind, term_opterr, term_optopt;
X#endif
X
X#ifdef I_TTY
X# ifdef USE_TERMIOS
X#   include <termios.h>
X# else
X#  include <sgtty.h>
X# endif
X#endif
X
X#ifdef I_ALWAYS
X# include <stdio.h>
X# ifndef titan
X#  include <stdlib.h>
X# else
X   extern char *getenv(char *name);
X#  include <malloc.h>
X# endif /* titan */
X# ifndef NeXT
X#  include <unistd.h>
X# endif
X# if defined(ultrix) || defined(NeXT)
X#  include <sys/file.h>
X# endif
X# ifndef R_OK
X#  define R_OK 4
X# endif
X# ifndef W_OK
X#  define W_OK 2
X# endif
X# ifndef X_OK
X#  define X_OK 1
X# endif
X# ifndef IXANY
X#  define IXANY 0
X# endif
X# if !defined(ONLCR) && defined(__QNX__)
X#  define ONLCR OPOST
X# endif
X# ifndef STDIN_FILENO
X#  define STDIN_FILENO 0
X# endif
X# ifndef USE_HERROR
X#  define herror term_herror
Xvoid term_herror(char *);
X# endif
X# ifdef NO_VFORK
X#  define vfork fork
X# endif
X# ifdef USE_ONEXIT
X#  define atexit(procp) on_exit(procp, 0)
X# endif
X# ifdef NO_ATEXIT
X#  define atexit(procp) while(0)
X# endif
X#endif
X
X#ifdef I_SIGNAL
X# include <signal.h>
X# ifndef SIGWINCH
X#  define SIGWINCH SIGWINDOW 
X# endif
X#endif
X
X#ifdef I_TIMES
X# include <sys/times.h>
X#endif
X
X#ifdef I_TIME
X# include <sys/time.h>
X# ifdef USE_STIME
X#  define gettime(a) get_process_stats(a,getpid(),0,0)
X#  define settime(a) stime(a)
X# else
X#  ifdef SVR4
X    int gettimeofday(struct timeval *);
X    int settimeofday(struct timeval *);
X#   define gettime gettimeofday
X#   define settime settimeofday
X#  else
X#   define gettime(a) gettimeofday((a), (struct timezone *)0)
X#   define settime(a) settimeofday((a), (struct timezone *)0)
X#  endif
X# endif
X#endif
X
X#ifdef I_UTIME
X# if !defined(titan) && !defined(NeXT)
X#  include <utime.h>
X# else
X          struct    utimbuf        {
X               time_t      actime; /* access time */
X               time_t      modtime;/* modification time */
X          };
X# endif
X#endif
X
X
X#ifdef I_ARGS
X# ifndef NO_VSPRINTF
X#  ifndef USE_VARARGS
X#   include <stdarg.h>
X#  else /* USE_VARARGS */
X#   include <varargs.h>
X#  endif /* USE_VARARGS */
X# else /* NO_VSPRINTF */
X#  define va_alist a1,a2,a3,a4,a5,a6,a7,a8,a9
X#  define va_dcl long a1,a2,a3,a4,a5,a6,a7,a8,a9;
X#  define vsprintf(buf,fmt,v) sprintf((buf),(fmt),a1,a2,a3,a4,a5,a6,a7,a8,a9)
X#  define va_list int
X#  define va_start(v)
X#  define va_end(v)
X#  define USE_VARARGS
X# endif /* NO_VSPRINTF */
X#endif /* I_ARGS */
X
X#ifdef I_SYS
X# if defined (_AIX) || defined(__QNX__) || defined(DYNIXPTX)
X#  include <sys/select.h>
X# endif
X# if defined(DYNIXPTX) || defined(SVR4)
X   int select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
X# endif
X#endif
X
X#ifdef I_INET
X# include <arpa/inet.h>
X#endif
X
X#ifdef I_PARAM
X# include <sys/param.h>
X#endif
X
X#ifdef I_MEMORY
X# ifndef convex
X#  include <memory.h>
X# endif
X#endif
X
X#ifdef I_PWD
X# include <pwd.h>
X#endif
X
X#ifdef I_PROCESS
X# ifdef __QNX__
X#  include <process.h>
X# endif
X#endif
X
X#ifdef I_WAIT
X# include <sys/wait.h>
X#endif
X
X#ifdef I_STROPT
X# if defined(SCO) || defined(SYSV) || defined(SVR3)
X#  include <stropts.h>
X# endif
X#endif
X
X#ifdef I_POLL
X# ifdef SVR3
X#   include <poll.h>
X# endif
X#endif
X
X#ifdef I_STREAM
X# include <sys/stream.h>
X#endif
X
X#ifdef I_STAT
X# include <sys/stat.h>
X# ifndef S_ISREG
X#  define S_ISREG(a) (((a) & S_IFMT) == S_IFREG)
X#  define S_ISDIR(a) (((a) & S_IFMT) == S_IFDIR)
X# endif
X#endif
X
X#ifdef I_LIMITS
X# include <limits.h> 
X# include <sys/param.h> 
X# ifndef _POSIX_PIPE_BUF
X#  define _POSIX_PIPE_BUF 512
X# endif
X# ifndef PIPE_BUF
X#  define PIPE_BUF 4096
X# endif
X# define PIPE_BUFFER ((PIPE_BUF<30720&&PIPE_BUF>0)?PIPE_BUF:30720)
X# ifndef PATH_MAX
X#  define PATH_MAX 1024
X# endif
X#endif
X
X#include "term_main.h"
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/includes.h' &&
  chmod 0644 'term-2.2.5/includes.h' ||
  echo 'restore of term-2.2.5/includes.h failed'
  shar_count="`wc -c < 'term-2.2.5/includes.h'`"
  test 5645 -eq "$shar_count" ||
    echo "term-2.2.5/includes.h: original size 5645, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/jump/README.jump-updating ==============
if test ! -d 'term-2.2.5/jump'; then
  echo 'x - creating directory term-2.2.5/jump'
  mkdir 'term-2.2.5/jump'
fi
if test -f 'term-2.2.5/jump/README.jump-updating' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/jump/README.jump-updating (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/jump/README.jump-updating (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/jump/README.jump-updating' &&
X--------------------------------------------------------------------
XJUMP.LOG
X
XIt is created in case new symbols appear in the module processed
Xby jumpas. 
X
XNEW SYMBOLS
X
XThese are the symbols jumpas sees that exist in source, but not
Xin jump.vars, neither jump.funcs.
X
XWHAT IF MAKE PROCESS IS ABORTED
X
XIf there are errors while compiling fresh code with new symbols
X(this is possible with high probability), then jumpas should not
Xbe run after the compilation with errors. 
X
XHowever, even if there are no errors, you might have done an unwanted
Xmake process, and jump.log can be appended with unwanted new symbols,
Xso duplicates are possible and there is not an easy way to prevent
Xdouble makings. The real solution would be jumpas that takes care
Xof duplicates, but the present one seems it doesn't.
X
XIn both cases, safe side is to delete jump.log before each re-makings,
Xregardless of the fact that jump.log, in its present contents might
Xhave useful entries. It's better to loose some time for making if
Xsome symbols are missing than to contaminate jump.* files.
X
XSAFE METHOD
X
XAfter you are satisfied with your code, delete jump/jump.log, then
Xcreate empty one by touching it and run make jump-update twice.
XFirst time, a complete new jump.log has the chance to appear, and
Xsecond jump-update will see if jump.log has appeared and will do the
Xright thing in the second pass.
X
XDavor Jadrijevic <davor%emard.uucp@ds5000.irb.hr>
X--------------------------------------------------------------------
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/jump/README.jump-updating' &&
  chmod 0644 'term-2.2.5/jump/README.jump-updating' ||
  echo 'restore of term-2.2.5/jump/README.jump-updating failed'
  shar_count="`wc -c < 'term-2.2.5/jump/README.jump-updating'`"
  test 1499 -eq "$shar_count" ||
    echo "term-2.2.5/jump/README.jump-updating: original size 1499, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/jump/jump.funcs ==============
if test -f 'term-2.2.5/jump/jump.funcs' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/jump/jump.funcs (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/jump/jump.funcs (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/jump/jump.funcs' &&
X00000000 T _build_arg           libtermnet       client 
X00000000 T _client_options      libtermnet       client 
X00000000 T _connect_server      libtermnet       client 
X00000000 T _send_command        libtermnet       client 
X00000000 T _socket_connect_server libtermnet       client 
X00000000 T _use_term_command    libtermnet       client
X00000000 T _do_connect          libtermnet       connect 
X00000000 T _add_to_buffer       libtermnet       lib 
X00000000 T _eaccess             libtermnet       lib 
X00000000 T _get_from_buffer     libtermnet       lib 
X00000000 T _get_term_path       libtermnet       lib
X00000000 T _make_sockaddr       libtermnet       lib
X00000000 T _read_into_buff      libtermnet       lib 
X00000000 T _recvfrom_into_buff  libtermnet       lib
X00000000 T _sendto_from_buff    libtermnet       lib
X00000000 T _set_block           libtermnet       lib 
X00000000 T _set_nonblock        libtermnet       lib 
X00000000 T _set_share_mode      libtermnet       lib 
X00000000 T _sockaddr_to_sstr    libtermnet       lib
X00000000 T _sockaddr_to_str     libtermnet       lib
X00000000 T _str_to_sockaddr     libtermnet       lib
X00000000 T _sstr_to_sockaddr    libtermnet       lib
X00000000 T _str_version         libtermnet       lib 
X00000000 T _strerror            libtermnet       lib 
X00000000 T _write_from_buff     libtermnet       lib 
X00000000 T _term_getopt         libtermnet       term_getopt 
X00000000 T _term_herror         libtermnet       term_herror
X00000000 T _lose_ctty           libtermnet       terminal 
X00000000 T _terminal_baud       libtermnet       terminal
X00000000 T _terminal_new        libtermnet       terminal 
X00000000 T _terminal_raw        libtermnet       terminal 
X00000000 T _terminal_restore    libtermnet       terminal 
X00000000 T _terminal_save       libtermnet       terminal 
X00000000 T _term_accept         libtermnet       termnet 
X00000000 T _term_bind           libtermnet       termnet 
X00000000 T _term_close          libtermnet       termnet 
X00000000 T _term_connect        libtermnet       termnet 
X00000000 T _term_dup            libtermnet       termnet
X00000000 T _term_dup2           libtermnet       termnet
X00000000 T _term_fcntl          libtermnet       termnet
X00000000 T _term_fork           libtermnet       termnet 
X00000000 T _term_gethostbyaddr  libtermnet       termnet 
X00000000 T _term_gethostbyname  libtermnet       termnet 
X00000000 T _term_gethostname    libtermnet       termnet
X00000000 T _term_getpeername    libtermnet       termnet 
X00000000 T _term_getsockname    libtermnet       termnet 
X00000000 T _term_listen         libtermnet       termnet 
X00000000 T _term_rcmd           libtermnet       termnet 
X00000000 T _term_recv           libtermnet       termnet
X00000000 T _term_recvfrom       libtermnet       termnet
X00000000 T _term_send           libtermnet       termnet
X00000000 T _term_sendto         libtermnet       termnet
X00000000 T _term_shutdown       libtermnet       termnet 
X00000000 T _term_socket         libtermnet       termnet
X00000000 T _term_vfork          libtermnet       termnet 
X00000000 T _s_pipe              libtermnet       spipe
X00000000 T _do_select_loop      libtermnet       select 
X00000000 T _bind_tcp            libtermnet       socket 
X00000000 T _bind_unix           libtermnet       socket 
X00000000 T _connect_unix        libtermnet       socket 
X00000000 T _open_unix           libtermnet       socket 
X00000000 T _write_from_buff_async libtermnet     lib
X00000000 T _term_putenv         libtermnet       term_putenv
X00000000 T _term_strherror      libtermnet     term_herror
X00000000 T _get_term_localaddr  libtermnet     lib
X00000000 T _term_socketpair     libtermnet     term_spair
X00000000 T _bind_tcp_listen     libtermnet     sockets
X00000000 T _connect_tcp         libtermnet     sockets
X00000000 T _duplicate_connect   libtermnet     sockets
X00000000 T _term_chroot         libtermnet     termnet
X00000000 T _check_sum           libtermnet     shared/checksum
X00000000 T _update_crc          libtermnet     shared/checksum
X00000000 T _file_crc            libtermnet     shared/utils
X00000000 T _host_lookup         libtermnet     shared/host_lookup
X00000000 T _term_strerror       libtermnet     shared/termnet
X00000000 T _term_perror         libtermnet     shared/termnet
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/jump/jump.funcs' &&
  chmod 0644 'term-2.2.5/jump/jump.funcs' ||
  echo 'restore of term-2.2.5/jump/jump.funcs failed'
  shar_count="`wc -c < 'term-2.2.5/jump/jump.funcs'`"
  test 4326 -eq "$shar_count" ||
    echo "term-2.2.5/jump/jump.funcs: original size 4326, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/jump/jump.ignore ==============
if test -f 'term-2.2.5/jump/jump.ignore' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/jump/jump.ignore (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/jump/jump.ignore (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/jump/jump.ignore' &&
X00000000 T _term_do_exit        libtermnet     termnet
X00000000 T _internal_write_from_buff libtermnet     lib
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/jump/jump.ignore' &&
  chmod 0644 'term-2.2.5/jump/jump.ignore' ||
  echo 'restore of term-2.2.5/jump/jump.ignore failed'
  shar_count="`wc -c < 'term-2.2.5/jump/jump.ignore'`"
  test 111 -eq "$shar_count" ||
    echo "term-2.2.5/jump/jump.ignore: original size 111, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/jump/jump.params ==============
if test -f 'term-2.2.5/jump/jump.params' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/jump/jump.params (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/jump/jump.params (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/jump/jump.params' &&
XName=libtermnet
XText=0x66000000
XData=0x00000000
XJump=0x00001000
XGOT=0x00004000
XVersion=2.2.3
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/jump/jump.params' &&
  chmod 0644 'term-2.2.5/jump/jump.params' ||
  echo 'restore of term-2.2.5/jump/jump.params failed'
  shar_count="`wc -c < 'term-2.2.5/jump/jump.params'`"
  test 93 -eq "$shar_count" ||
    echo "term-2.2.5/jump/jump.params: original size 93, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/jump/jump.undefs ==============
if test -f 'term-2.2.5/jump/jump.undefs' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/jump/jump.undefs (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/jump/jump.undefs (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/jump/jump.undefs' &&
X66011270 D __NEEDS_SHRLIB_libc_4
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/jump/jump.undefs' &&
  chmod 0644 'term-2.2.5/jump/jump.undefs' ||
  echo 'restore of term-2.2.5/jump/jump.undefs failed'
  shar_count="`wc -c < 'term-2.2.5/jump/jump.undefs'`"
  test 33 -eq "$shar_count" ||
    echo "term-2.2.5/jump/jump.undefs: original size 33, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/jump/jump.vars ==============
if test -f 'term-2.2.5/jump/jump.vars' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/jump/jump.vars (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/jump/jump.vars (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/jump/jump.vars' &&
X00000004 D _share               libtermnet lib 
X00000004 D _termerrno           libtermnet lib 
X00000400 C _com_result          libtermnet client 
X00000004 C _command_result      libtermnet client 
X00000004 D _lcompression        libtermnet client 
X00000004 D _priority            libtermnet client 
X00000004 D _rcompression        libtermnet client 
X00000004 D _remote_term_version libtermnet client 
X00000004 D _savedeid            libtermnet client 
X00000004 D _term_server         libtermnet client 
X00000004 C _term_optarg         libtermnet term_getopt 
X00000004 D _term_opterr         libtermnet term_getopt 
X00000004 D _term_optind         libtermnet term_getopt 
X00000004 C _term_optopt         libtermnet term_getopt 
X00000004 D _term_debug          libtermnet termnet 
X00000004 D _term_localaddr      libtermnet client
X00000004 D _term_remoteaddr     libtermnet client
X00000100 C _term_localhost      libtermnet client
X00000100 C _term_remotehost     libtermnet client
X00000004 D _verbose             libtermnet     client
X00000004 D _use_term            libtermnet     termnet
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/jump/jump.vars' &&
  chmod 0644 'term-2.2.5/jump/jump.vars' ||
  echo 'restore of term-2.2.5/jump/jump.vars failed'
  shar_count="`wc -c < 'term-2.2.5/jump/jump.vars'`"
  test 1089 -eq "$shar_count" ||
    echo "term-2.2.5/jump/jump.vars: original size 1089, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/jump/size.nm ==============
if test -f 'term-2.2.5/jump/size.nm' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/jump/size.nm (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/jump/size.nm (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/jump/size.nm' &&
X00000000 T _share
X00000004 T _termerrno
X00000008 T _com_result
X00000408 T _command_result
X0000040c T _lcompression
X00000410 T _priority
X00000414 T _rcompression
X00000418 T _remote_term_version
X0000041c T _savedeid
X00000420 T _term_server
X00000424 T _term_optarg
X00000428 T _term_opterr
X0000042c T _term_optind
X00000430 T _term_optopt
X00000434 T _term_debug
X00000438 T _term_localaddr
X0000043c T _term_remoteaddr
X00000440 T _term_localhost
X00000540 T _term_remotehost
X00000640 T _verbose
X00000644 T __done
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/jump/size.nm' &&
  chmod 0644 'term-2.2.5/jump/size.nm' ||
  echo 'restore of term-2.2.5/jump/size.nm failed'
  shar_count="`wc -c < 'term-2.2.5/jump/size.nm'`"
  test 505 -eq "$shar_count" ||
    echo "term-2.2.5/jump/size.nm: original size 505, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/linecheck.1 ==============
if test -f 'term-2.2.5/linecheck.1' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/linecheck.1 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/linecheck.1 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/linecheck.1' &&
X.TH LINECHECK 1
X.SH NAME
Xlinecheck \- debugging tool for 
X.IR term
Xserial lines
X.SH SYNOPSIS
X.B linecheck 
X[ escape ... ] < /dev/tty?? >/dev/tty??
X.SH DESCRIPTION
XThe
X.IR linecheck
Xprogram performs a first-order test of the transparency of the link.
X.IR Linecheck 
Xsends packets, once per second, each of which contains one of the 256
Xpossible 8-bit character codes.
XThe diagnostic output helps you determine which characters do not get
Xthrough.
XThis is important, since almost all of the problems associated with
Xgetting 
X.IR term 
Xrunning occur because individual characters or character
Xsequences do not get through the serial link or cause other characters
Xto be sent and/or echoed by the link.
X.IR Term
Xcan easily be told to avoid sending these characters by listing them
Xin the termrc file, the problem is
Xdetermining which ones to avoid.
X.IR Linecheck
Xtests all 256 individual characters and helps you determine which are
Xnot getting through.  It only checks individual characters, not character sequences.
X.PP
X.IR Linecheck
Xmust be run on both systems the same way 
X.IR term
Xis run.
XThat is, the stdin and stdout should be directed to the serial port
Xwhile the stderr goes to a log file.
XRemotely you can type
X.PP
X\ \ \ linecheck 2>/tmp/linecheck.log
X.PP
Xto the sh, or
X.PP
X\ \ \ sh -c 'exec linecheck 2> /tmp/linecheck.log'
X.PP
Xto the csh.
XLocally you should escape from your comm program and type something
Xlike
X.PP
X\ \ \ linecheck < /dev/modem > /dev/modem 2> /tmp/linecheck.log
X.PP
Xto a sh.
X.PP
XYou can tell linecheck not to test certain characters by listing their decimal numbers
Xon the command line.  For instance, if you know flow-control will get eaten,
Xyou can use "linecheck 17 19", and it won't test those chars.  Or, if
Xyour link goes through an 
X.IR rlogin (1)
Xon the remote end, you will want to put 126 on the command line to
Xescape the '~' character.  Also, in this case, you'll want to use
X.PP
X\ \ \ rlogin <system> -8 -L
X.PP
Xin a bid to establish a maximally transparent rlogin.
X.PP
XOnce
X.IR linecheck
Xhas finished running on both ends, you should examine the
Xrespective log files on the two systems.
XThese files will contain lines of the form '<num> sending
Xchar' and '<num> received valid', where <num> is the
Xdecimal number of the character in the packet.  
XThese indicate that the local
X.IR linecheck
X(the one generating the log file)
Xsent the character or received the character from the other 
X.IR linecheck.
XIt's normal if the 'sending' and 'received' numbers are not in sync.
X.PP
XLines of the form 'Invalid packet: <data>' are the interesting output.
XThey indicate a packet was received, but was corrupted.
XThis may be due to simple line noise, or to
Xthe opacity of the link to a character generated by either the remote
Xor the local
X.IR linecheck
Xprogram.
XAt least three possible kinds of link opacity can lead to invalid
Xpackets.  When a character that should be be escaped is sent
Xthe link may simply not transmit the character
Xin question, or the link may transmit a different or extra characters.
XAlso, at the same time, the link itself may echo characters back to
Xthe system which sent the character in the first place.
XYou must study the log files from both systems to determine which
Xdirection of the link causes the problems and which characters should
Xbe escaped on which system.
XReal link problems like these should be repeatable while line noise
Xeffects will not.
X.PP
XThe bottom of the log file lists characters that linecheck believes
Xshould be escaped by the other system in the termrc file.
XThese are characters that the other system sent, but which were not
Xreceived correctly.
XIf you had no invalid packets then this summary is probably reliable.
XIf there were invalid packets it is possible that 
X.IR linecheck's
Xrecommendations are wrong.  You must examine both logs closely to
Xdetermine what caused the invalid packets.
X.PP
XIf, for some reason, you get stuck out in lala land, and can't kill
Xthe remote program,
Xtry typing '00000'.  That should kill it, and restore your terminal.
X.SH BUGS
X.IR Linecheck
Xis too slow and won't detect if 17 and 19 need to be escaped.
X.SH SEE ALSO
X.IR term (1),
X.IR termtest (1),
X.IR term_setup (1),
X.IR term_clients (1)
X.SH AUTHOR
XMichael O'Reilly, michael@iinet.com.au
X.br
XBill C. Riemers, bcr@physics.purdue.edu, is temporarily maintaining term.
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/linecheck.1' &&
  chmod 0644 'term-2.2.5/linecheck.1' ||
  echo 'restore of term-2.2.5/linecheck.1 failed'
  shar_count="`wc -c < 'term-2.2.5/linecheck.1'`"
  test 4334 -eq "$shar_count" ||
    echo "term-2.2.5/linecheck.1: original size 4334, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/linecheck.c ==============
if test -f 'term-2.2.5/linecheck.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/linecheck.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/linecheck.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/linecheck.c' &&
X#define I_STRING
X#define I_CTYPE
X#define I_SIGNAL
X#include "includes.h"
X
X#include "terminal.h"
X
X/*
X initially written by Michael O'Reilly
X rewritten by jeff grills (jefftep@cs.utexas.edu)
X
X to use, run remotely like:   linecheck remote.out
X             locally:         linecheck stderr < /dev/modem > /dev/modem
X
X linecheck's first argument must be the name of a file to write the information
X into.  if you specify "stderr," then the output is written to the standard error
X stream, as normal.  this is what you prefer to do on your local machine so you can
X watch it work.  on the remote machine, you need to specify a file to record this
X information in.
X
X you can tell linecheck not to test certain chars by listing their decimal number
X on the command line.  for instance, if you know flow-control will get eaten,
X you can use "linecheck stderr 17 19", and it won't test those chars.  this is also
X useful for testing a set of escape sequences, to make sure it makes your line
X clean.
X
X if it says something needs escaped, that means it didn't get through okay
X this time. if you get an invalid packet printed, it means the packet wasn't
X sent by the linecheck on the other side, and may either be line static,
X or some very braindead terminal response to a (possibly series) of characters
X to what was printed over the line.  in this case, it's your responsibility
X to determine which, and escape the previously sent char if needed.  There is
X no way this program can identity a braindead terminal server from line static,
X so this is the way it has to be.
X
X if, for some reason, you get stuck out in lala land, and can't kill the program,
X try typing "00000".  That should kill it, and restore your terminal.
X
X It'll print "### sending char" and "### received valid".  Don't worry if these
X two number are out of sync.  That's fine.  Just worry, on either side, if you
X get some "Invalid packet: " lines.  Look at them closely, and see if it's line
X static, or a real problem.
X
X At the end, it'll print out a summary of what it thinks you should escape.
X This just means these chars didn't get received correctly this time.  Again,
X if line static munched something, some of these may be valid. 
X
X *** IF *** your terminal server generates extra responses for odd chars,
X then you may not be told to escape something, but need to anyway.  This will
X be evident from a "Invalid packet: " on the local side, after attempting to
X send a character.  Again, it may be line static. You have to make the call.
X
X if you're running it locally in a xterm, I suggest you turn on window logging.
X
X if you have problems with this program, and want me to look at it, mail me
X *both* the local and remote output, and label them appropriately.
X*/
X
X/* -------------------------------------------------- */
X
X#define START_AT 0
X#define STOP_AT  256
X
X#define START      'A'
X#define STOP       'B'
X#define END_PACKET 'C'
X#define XON        '\021'
X#define DONE       "done"
X#define RDONE      "rdone"
X#define SLEEP      1
X#define TRIES      1
X#define BUMS       1
X
X#define BUFFSIZE  200
X
X/* -------------------------------------------------- */
X
Xunsigned char buff[BUFFSIZE];
X
Xint valid[STOP_AT+1], skip[STOP_AT], pid, debugging;
X
X/* -------------------------------------------------- */
X
Xvoid sig_int(int x) {
X	if (pid)
X		kill(pid, SIGINT);
X	exit(-1);
X}
X
X/* -------------------------------------------------- */
X
Xvoid debug(unsigned char *s)
X{
X  while (*s) {
X		/* boy, there are some screwed up isprint()s out there */
X    if ( isprint(*s) && (*s < 128) )
X      fprintf(stderr, "%c", *(s++));
X    else      
X      fprintf(stderr, "<%d>", (int) *(s++));
X  }
X  fprintf(stderr, "\n");
X}
X
X/* -------------------------------------------------- */
X
Xint mgets(unsigned char *buff, int len)
X{
X  unsigned char ch;
X  int i, zcount;
X  
X  i = 0;
X  zcount = 0;
X  
X  while(1) {
X		read(STDIN_FILENO, &ch, 1);
X
X		/* check if we get five 0's and abort */
X		if ( ch == '0' ) {
X			if (++zcount == 5) {
X				kill(pid, SIGINT);
X				terminal_restore(0,0);
X				exit(0);
X			}
X		}
X		else
X			zcount = 0;
X		
X		/* handle next char */
X		if (ch == '\n')
X
X			/* check if this is really inside the packet */
X			if ( (i == 4) && (buff[0] == '1') && (buff[1] == '0') && (buff[2] == ' ') &&
X					(buff[3] == START) )
X				buff[i++] = ch;
X			else {
X				buff[i] = '\0';
X				return i;
X			}
X
X		else {
X			/* store this char in the buffer */
X			buff[i++] = ch;
X			
X			/* don't let packet overflow */
X			if ( (i+1) == len) {
X			  buff[i] = '\0';
X				return i;
X			}
X		}
X	}
X}
X
X/* -------------------------------------------------- */
X
Xvoid handshake()
X{
X  int i;
X
X	fprintf(stderr, "Handshaking\n");
X
X	printf("\n%c\n", START);
X	i = 0;
X	while ( ! i ) { 
X		mgets(buff, BUFFSIZE);
X
X		if ( (buff[0] == START) && (buff[1] == '\0') ) {
X			i = 1;
X			printf("\n%c\n", STOP);
X		}
X		else
X			if ( (buff[0] == STOP) && (buff[1] == '\0') )
X				i = 1;
X			else
X				if (buff[0] != '\0' ) { 
X					fprintf(stderr, "unexpected packet: ");
X					debug(buff);
X				}
X	}
X	
X	fprintf(stderr, "Handshaking successful\n");
X}
X
X/* -------------------------------------------------- */
X
Xvoid skipchars(char **s)
X{
X	while(*s) {
X		skip[atoi(*(s++))] = 1;
X	}
X}
X
X/* -------------------------------------------------- */
X
Xvoid bum(char *s)
X{
X  int i;
X	for (i=0; i<BUMS; i++) { 
X		if ( s == NULL )
X			printf("\n");
X		else
X			printf("\n%s\n", s);
X		sleep(SLEEP);
X	}
X}
X
X/* -------------------------------------------------- */
X
Xvoid check(unsigned char *s)
X{
X  int k;
X  unsigned char *t;
X  t = s;
X
X	if (debugging) {
X		fprintf(stderr, "incoming packet: ");
X		debug(t);
X	}
X
X	/* convert int to number */
X	k = 0;
X	while ( isdigit(*s) )
X		k = (k * 10) + (*(s++) - '0');
X
X	/* verify this is a valid packet */
X	if ( (s[0] == ' ') && (s[1] == START) && (s[2] == (unsigned char)k) && (s[3] == STOP) ) {
X		fprintf(stderr, "%3d received valid\n", k);
X		valid[k] = 1;
X	}
X	else {
X		if (debugging)
X			fprintf(stderr, "was invalid packet\n");
X		else {
X			fprintf(stderr, "invalid packet: ");
X			debug(t);
X		}
X	}
X}
X
X/* -------------------------------------------------- */
X
Xvoid do_reads()
X{
X	int ldone, rdone;
X
X	ldone = 0;
X	rdone = 0;
X
X	while ( (!ldone) || (!rdone) ) {
X
X		/* get a non-empty line */
X		while( !mgets(buff, BUFFSIZE) );
X		
X		/* see if they are done sending test packets */
X		if (strcmp((char *)buff,DONE) == 0) {
X			rdone = 1;
X			bum(RDONE);
X		}
X		else
X			/* see if we are done sending packets to them */
X			if (strcmp((char *)buff,RDONE) == 0)
X				ldone = 1;
X			else
X				check(buff);
X	}
X}
X
X/* -------------------------------------------------- */
X
Xvoid do_writes()
X{
X	int i, k;
X
X  /* test all the chars */
X  for (i = START_AT; i < STOP_AT; i++ ) {
X
X		/* don't send chars we are told to skip */
X    if ( skip[i] )
X      continue;
X		
X    fprintf(stderr, "%3d sending char\n", i);
X
X    /* attempt to send this char across, in a cute little packet */
X		for (k=0; k < TRIES; k++) { 
X
X			if ( !skip[(int)XON] )
X				printf("\n%d %c%c%c%c%c\n", i, START, (unsigned char)i, STOP, XON, END_PACKET );
X			else
X				printf("\n%d %c%c%c%c\n", i, START, (unsigned char)i, STOP, END_PACKET );
X			
X			bum(NULL);
X		}
X	}
X
X  bum(DONE);
X}
X
X/* -------------------------------------------------- */
X
Xvoid print_esc(void)
X{
X  int i, j;
X
X  /* make printing at the end easier by making it more generic */
X	valid[STOP_AT] = 1;
X
X  /* print out the valid list */
X  j = -1;
X	fprintf(stderr, "\n");
X  for (i = START_AT; i <= STOP_AT; i++)
X		if ( valid[i] && (j != -1) )
X		{
X			if ((j <= 128) && (i == STOP_AT))
X			{
X				fprintf(stderr, "sevenbit\n");
X				if ( j < 127 )
X					fprintf(stderr, "escape %d-%d\n", j, 127);
X				if ( j == 127 )
X					fprintf(stderr, "escape 127\n");
X			}
X			else
X				if (j == (i-1))
X					fprintf(stderr, "escape %d\n", j);
X				else
X					fprintf(stderr, "escape %d-%d\n", j, i-1);
X			j = -1;
X		}
X		else
X			if ( (!valid[i]) && (j == -1) )
X				j = i; 
X}
X
X/* -------------------------------------------------- */
X
Xint main(int argc, char **argv)
X{
X	int i;
X
X	pid = 0;
X	debugging = 0;
X
X	argv++;
X	argc--;
X	if (!argc) {
X		fprintf(stderr, "need output filename\n");
X		exit(-2);
X	}
X
X	if (strcmp("-d",*argv) == 0) {
X		debugging = 1;
X		argc--;
X		argv++;
X		if (!argc) {
X			fprintf(stderr, "need output filename\n");
X			exit(-2);
X		}
X	}
X
X	/* check the output file */
X	if (strcmp("stderr",*argv) && strcmp("-",*argv))
X		freopen(*argv, "w", stderr);
X	argc--;
X	argv++;
X
X  /* nothing has gotten through okay yet */	
X  for (i = START_AT; i < STOP_AT; i++) {
X		valid[i] = 0;
X		skip[i] = 0;
X	}
X
X  skipchars(argv);
X
X	signal(SIGINT, sig_int);
X
X	terminal_save(0);
X	terminal_raw(0);
X
X  setbuf(stdout,NULL);
X  setbuf(stderr,NULL);
X	
X  handshake();
X
X	/* parent should be reader to remain in control */
X	if ((pid = fork())) {
X		do_reads();
X	}	
X	else {
X		do_writes();
X		exit(0);
X	}	
X
X  print_esc();
X	terminal_restore(0,0);
X  exit(0);
X}
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/linecheck.c' &&
  chmod 0644 'term-2.2.5/linecheck.c' ||
  echo 'restore of term-2.2.5/linecheck.c failed'
  shar_count="`wc -c < 'term-2.2.5/linecheck.c'`"
  test 8804 -eq "$shar_count" ||
    echo "term-2.2.5/linecheck.c: original size 8804, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/main.c ==============
if test -f 'term-2.2.5/main.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/main.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/main.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/main.c' &&
X#define I_SYS
X#define I_ERRNO
X#define I_GETOPT
X#define I_STRING
X#define I_IOCTL
X#define I_STAT
X#define I_SIGNAL
X#define I_TIME
X#define I_WAIT
X#define I_CTYPE
X#define I_LIMITS
X#define I_INET
X#include "includes.h"
X
X#include "debug.h"
X
X/*
X *
X * main file. Calls everything else. ;)
X * 
X * basically consists of select() and then calls things based on the select().
X *
X */
X/*------------------------------------------------------------------------*/
X
X#define INFINITE_BAUD 115200	/* Nothing is really unlimited.  This should */
X				/* be the maximum baudrate you could achieve */
X				/* when running with baudrate = 0.  As you */
X				/* We need some sort of limit so baudrate 0 */
X				/* doesn't use 30-40% of the cpu time. */
X				/* Note: This # is really just accurate to */
X				/* an order of magnitude. */
X#ifndef CLOCKS_PER_SEC 
X#define CLOCKS_PER_SEC 1000
X#endif
X#define FUDGE_FACTOR 3
X
X/* truly global vars. Used everywhere. */
Xunsigned long current_time = 0;
Xint do_shutdown	 = 0;
Xint term_debug = 0;
Xint compressing = 1;
Xstruct Onetime onetime_term[MAX_CLIENTS];
X/*------------------------------------------------------------------------*/
X/* Various global variables. Note that most of these vars are local to    */
X/* this file. Where possible (i.e. where it doesn't impinge on efficiency) */
X/* this is enforced */
Xint remote = 0;
X
Xstruct Client clients[MAX_CLIENTS];
Xint num_clients = 0;
Xunsigned long baudrate = 1;
Xint max_cps = 0;
Xint auto_retrain = 0; /* Don't automatically adjust timing values */
Xint bytes_left = _POSIX_PIPE_BUF; /* bytes available to send now.. */
Xint fudge_flow = 0; /* should we generate periodic control-Q's */
Xint byte_shift = 0; /* So we can map less frequently uses section down to */
X                    /* 0-32 */
Xint window_size_max = -1; /* This will automatically be adjusted */
X
Xint window_size = 1; /* Don't change this */
Xunsigned long packet_timeout = 70; /* wait 3.5 seconds for a packet to time out */
Xint write_noise = 0; /* whether we should print out all the the serial stuff */
X				/* we get that we don't understand.. */
X
Xint seven_bit_in = 0;		/* Are we on a line that ignores the */
X				/* top bit. */
Xfloat stop_bits = 1;		/* # of stop bits being used */
Xstatic long unsigned delay = 20000;
X				/* This is a 20000 micro-second delay to decrease */ 
X				/* cpu usage. */
Xstatic int collisions = 0;	/* Use this if you have problems with data */
X				/* Collisions */
Xint term_inc = 20;		/* This is the # of times / second term will */
X				/* attempt to send data */
Xint in_mask = 255;
Xint seven_bit_out = 0;
Xint out_mask = 255;
Xint block_size = -1;		/* This is the size of block the serial devices uses */
Xint packet_len = -1;
Xint breakout_char = '0';
Xchar breakout_string[256];
Xstatic int quiet = 0, rc_quiet = 0;
Xint user_share = -1;
Xint modem_noise = -1;
Xstatic int hangup_on_exit = 0;	/* tell local modem to hang up on exit */
Xstatic int explicit_hangup = 1;	/* local modem needs ath0 after +++ to hangup */
X
Xint stat_modem_in = 0,
X  stat_modem_recv = 0,
X  stat_modem_out = 0,
X  stat_modem_ack = 0,
X  stat_cooked_in = 0,
X  stat_cooked_out = 0,
X  stat_rare_out = 0;
X
Xchar *share_p = NULL;
Xchar *home_p = NULL;
X
Xint rshtype = 0;  /* Default to allow rsh and use login shell_command */
X
Xstatic char ownroot[256] = "";
Xstatic char shell_command[256] = "";
Xchar escapes[256];
Xchar ignores[256];
X
Xint modem_in = 0, modem_out = 1;
X/*------------------------------------------------------------------------*/
X/* module function prototypes */
X
Xvoid get_term_localaddr(unsigned long);
Xvoid read_int_type(int *o, char *c);
Xvoid read_ulong_type(unsigned long *o, char *c);
Xvoid var_init(void);
Xvoid main_loop(int);
Xvoid main_init(void);
Xvoid do_link_in(void);
Xvoid do_link_out(void);
Xvoid clear_buffers(struct Client *cl);
X/*------------------------------------------------------------------------*/
X/* main. */
X
Xvoid read_int_type(int *o, char *c) {
X
X	/* This reads an integer with "on" == 1, "off" == 0, and default == 1 */
X
X  if (isdigit(*c))
X    *o = atoi(c);
X  else
X    *o = !!strncmp(c, "off", 3);
X}
X        
Xvoid read_ulong_type(unsigned long *o, char *c) {
X
X	/* This reads an integer with "on" == 1, "off" == 0, and default == 1 */
X
X  if (isdigit(*c))
X    sscanf(c,"%lu",o);
X  else
X    *o = !!strncmp(c, "off", 3);
X}
X        
Xvoid var_init(void) {
X  int k;
X
X  get_term_localaddr(inet_addr("127.0.0.1"));
X  memset(term_remotehost, 0, sizeof(term_remotehost));
X  strcpy(term_remotehost,"remotehost");
X
X  for(k=0;k<MAX_CLIENTS;k++) {
X    onetime_term[k].socket = -1;
X    onetime_term[k].timeout = 0;
X  }
X
X  if (fudge_flow < 0)
X    fudge_flow = 0;
X  if (byte_shift < 0 || byte_shift > 255)
X    byte_shift = 0;
X  if (packet_timeout < 10 || packet_timeout > 1000){
X    fprintf(stderr, "Invalid timeout value (%lu).\r\n", packet_timeout);
X    auto_retrain = 1;
X    packet_timeout = 70;
X  }
X
X  if (strlen(breakout_string) < 5) 
X    sprintf(breakout_string,"%c%c%c%c%c",
X      breakout_char,breakout_char,breakout_char,breakout_char,breakout_char);
X
X  if ( seven_bit_out ) {
X    extern int tok_byte_mask_out, tok_byte_width_out;
X    out_mask = 127;
X    tok_byte_mask_out = 127;
X    tok_byte_width_out = 7;
X  }
X
X  if (seven_bit_in) {
X    extern int tok_byte_mask_in, tok_byte_width_in;
X    in_mask = 127;
X    tok_byte_mask_in = 127;
X    tok_byte_width_in = 7;
X  }
X
X  if (baudrate == 1) {
X    baudrate = terminal_baud(modem_out);
X  }else if (baudrate < 300 && baudrate) {
X    baudrate = 300;
X    fprintf(stderr, "baudrate set too low. Reset to 300\r\n");
X  }else if (baudrate >= INFINITE_BAUD) 
X    baudrate = 0;
X
X  max_cps = baudrate ? (2 * baudrate) /
X    (unsigned long) ((int)(0.5 + 2 * stop_bits) + (seven_bit_out ? 14 : 16))
X    : 0;  /* avoiding round-off problems */
X
X  if ( block_size < 0) block_size = (max_cps) ? 512 : PIPE_BUFFER;
X  if ( block_size < 127 || block_size > PIPE_BUFFER ) {
X    fprintf(stderr, "Invalid packet length %d (must be 1..%d) resetting to %d\n",
X      block_size, PIPE_BUFFER, 512);
X    block_size = 512;
X  }
X  if (max_cps && block_size > max_cps) block_size = max_cps;
X
X  if (packet_len < 0) 
X    packet_len = out_mask + 1;
X  else if (packet_len < 1 || packet_len > out_mask+1) {
X    packet_len = out_mask + 1;
X    fprintf(stderr, "packetsize has to be 1..%d.  Reset to %d\r\n", 
X      packet_len, packet_len);
X  }
X
X
X  if ( !max_cps ) 
X    term_inc = INFINITE_BAUD /
X      (unsigned long) ((block_size > 512) ? 512 : block_size);
X 
X  if ( term_inc < 20 ) term_inc = 20;
X
X  if ( term_inc < FUDGE_FACTOR * (max_cps / block_size)) {
X    k = term_inc;
X    term_inc = FUDGE_FACTOR * (max_cps / block_size); 
X    if (k == 20) packet_timeout = (packet_timeout * term_inc) / k;
X  }
X
X  if ( delay > 400000 / (unsigned long) term_inc)
X    delay = 400000 / (unsigned long) term_inc;
X
X  if ( 2 * term_inc > CLOCKS_PER_SEC ) delay = 0;
X
X  if (window_size_max < 0 ) {
X    window_size_max = 2 + (max_cps / 199);
X    if (window_size_max >= N_PACKETS / 2 || window_size_max < 3)
X      window_size_max = (N_PACKETS / 2) - 1;
X  }else if (window_size_max > N_PACKETS / 2 ) {
X    fprintf(stderr, "Invalid window size %d\r\n", window_size_max);
X     window_size_max = (N_PACKETS / 2) - 1;
X  }else if (window_size_max < 2) {
X    fprintf(stderr, "Invalid window size %d\r\n", window_size_max);
X    window_size_max = 2;
X  }
X  if (write_noise && write_noise < quiet + 1) write_noise += quiet;
X  if (modem_noise < 0) 
X    modem_noise = remote;
X}
X
Xvoid main_init(void) {
X  int i;
X
X  for (i = 0; i < MAX_CLIENTS;++i) {
X    clients[i].fd = -1;
X    clients[i].state = -1;
X    clients[i].in_buff.data = NULL;
X    clients[i].out_buff.data = NULL;
X    clients[i].in_buff.alloced = 0;
X    clients[i].out_buff.alloced = 0;
X  }
X}
X				/* In case of sudden death, do some */
X				/* minimal clean up. */
Xvoid sig_quit(int dummy) {
X  set_block(0);
X  set_block(1);
X  terminal_restore(0,0);
X  terminal_restore(1,0);
X  set_block(modem_in);
X  set_block(modem_out);
X  exit(0);
X}
X				/* Drop a core. */
Xvoid sig_core(int dummy) {
X  set_block(0);
X  set_block(1);
X  terminal_restore(0,0);
X  terminal_restore(1,0);
X  set_block(modem_in);
X  set_block(modem_out);
X  abort();
X}
X				/* We ignore this signal. There was */
X				/* some problem with it on linux. A */
X				/* bit odd, and I can't track it down. */
X				/* I suspect it is a bad shell_command. So we */
X				/* just ignore it. */
Xvoid sig_ignore(int dummy) {
X  signal(SIGALRM, sig_ignore);
X  signal(SIGPIPE, sig_ignore);
X}
X
Xvoid sig_child(int dummy) {
X  int p, i;
X#ifdef USE_WAITPID
X  int stat_loc;
X
X  p = waitpid((pid_t)-1, &stat_loc, WNOHANG);
X#else
X  p = wait3(0, WNOHANG, 0);
X#endif /* SVR4 */
X#ifndef SYSV
X  signal(SIGCHLD, sig_child);
X#endif /* SYSV */
X
X  if (p < 1) return;
X  DEBUG_MAIN(stderr, "%s:sig child kicked\n", term_server);
X  for (i = 0; i < MAX_CLIENTS;++i) {
X    if (clients[i].pid == p && clients[i].state > 0) {
X#ifdef USE_NOEOF /* ++kay: let term read until EOF */
X      clients[i].state = 2;
X#endif
X      return;
X    }
X  }
X  /* Hmm. child that we don't know about died!?!?! */
X  if (dummy)
X    dummy = 0;
X}
X
Xvoid read_rc(char *p) {
X  FILE *f = NULL;
X  char *file = NULL, *ptr = NULL;
X  static int Chdir[256];
X  static int seven_bit=0, login_type = 0;
X#define INT_TYPE 1
X#define CHAR_TYPE 2
X#define RANGE_TYPE 3
X#define ULONG_TYPE 4
X#define FLOAT_TYPE 5
X  static char int_type=INT_TYPE, char_type=CHAR_TYPE, range_type=RANGE_TYPE,
X	ulong_type=ULONG_TYPE, float_type=FLOAT_TYPE;
X#define RC_OPTIONS_SIZE 90
X  int m, n;
X  static char *rc_options[RC_OPTIONS_SIZE] = {
X	"compress",	& int_type,	(char *) &compressing,
X	"breakout",	& int_type,	(char *) &breakout_char,
X	"remote",	& int_type,	(char *) &remote,
X	"chdir",	& char_type,	(char *) Chdir,
X	"escape",	& range_type,	(char *) escapes,
X	"ignore",	& range_type,	(char *) ignores,
X	"baudrate",	& ulong_type,	(char *) &baudrate,
X	"retrain",	& int_type,	(char *) &auto_retrain,
X	"shift",	& int_type,	(char *) &byte_shift,
X	"window",	& int_type,	(char *) &window_size_max,
X	"timeout",	& int_type,	(char *) &packet_timeout,
X	"noise",	& int_type,	(char *) &write_noise,	
X	"sevenbit",	& int_type,	(char *) &seven_bit,	
X	"seven_out",	& int_type,	(char *) &seven_bit_out,
X	"seven_in",	& int_type,	(char *) &seven_bit_in,
X	"flowcontrol",	& int_type,	(char *) &fudge_flow,
X	"login",	& int_type,	(char *) &login_type,	
X	"denyrsh",	& int_type,	(char *) &rshtype,
X	"chroot",	& char_type,	(char *) ownroot,
X	"collisions",	& int_type,	(char *) &collisions,
X	"increment",	& int_type,	(char *) &term_inc,
X	"stopbits",	& float_type,	(char *) &stop_bits,
X	"quiet",	& int_type,	(char *) &rc_quiet,
X	"share",	& int_type,	(char *) &user_share,
X	"shell",	& char_type,	(char *) shell_command,
X	"blocksize",	& int_type,	(char *) &block_size,
X	"packetsize",	& int_type,	(char *) &packet_len,
X	"terminate",	& char_type,	(char *) breakout_string,
X	"hangup_on_exit", & int_type,	(char *) &hangup_on_exit,
X	"explicit_hangup", & int_type,	(char *) &explicit_hangup
X      };
X
X#define DEFAULT_PATH "/usr/local/lib/term:/usr/lib/term:/usr/etc:/etc" 
X
X  set_share_mode(0,share);
X  if(share == -1){
X    share = (getgid() != getegid());
X    set_share_mode(0,share);
X  }
X
X  setuid(geteuid());
X  if (share != 1)
X    setgid(getgid());
X  else if (savedeid >= 0)
X    setgid(savedeid);
X
X  do {
X    if ((file = get_term_path(&ptr))) {
X      if(share != 1) 
X        strcat(file, "/.term");
X      strcat(file, "/termrc");
X      if (p != NULL) if ( p[0] )
X        sprintf(&file[strlen(file)], ".%s",p);
X      if (! eaccess(file, R_OK)) break;
X    }else break;
X  } while ( ptr );
X
X  if (file) {
X    if (!quiet) 
X      fprintf(stderr,"Reading file:  %s\r\n",file);
X    f = fopen(file, "r");
X  }
X
X#ifdef _POSIX_SAVED_IDS
X  if (share) {
X    if(share == 2) 
X      setuid(getuid());
X    else
X      setgid(getgid());
X  }
X#endif
X  if (!file || !f) return;
X
X  if (! quiet) quiet = rc_quiet;  
X  Chdir[0] = '\0';
X  while (!feof(f)) {
X    char line[256];
X
X    fgets(line,	256,	f);
X				/* skip blank lines + comments. */
X    if (!line[0] || line[0] == '\n' || line[0] == '#')
X      continue;
X			
X
X    for(m = 0;m < RC_OPTIONS_SIZE;m += 3)
X      if ((n = strlen((char *) rc_options[m])) < strlen(line))
X        if (! strncmp((char *) rc_options[m], line, n)  
X            && isspace(line[n])) {
X
X      while (isspace(line[++n]));
X 
X      switch ( (int) *rc_options[m+1] ){
X        case CHAR_TYPE:
X        {
X          int i, quote=0;
X          if (  line[n] == '\47' ||
X                line[n] == '"' ) {
X            quote = line[n++];
X            for(i=0;i<256 && line[n] != quote && line[n];++i,++n){
X              if ( (rc_options[m+2][i] = line[n]) == '\\' && line[n+1] )
X                rc_options[m+2][i] = line[++n];
X            };
X          }else {
X            for(i=0;i<256 && ! isspace(line[n]) && line[n];++i,++n){
X              if ( (rc_options[m+2][i] = line[n]) == '\\' && line[n+1] )
X                rc_options[m+2][i] = line[++n];
X            };
X          };
X          rc_options[m+2][i] = 0;
X          break;
X        }
X        case RANGE_TYPE:
X        {
X          char *p;
X          int i,j;
X      
X          if(strchr(&line[n],'#'))
X            *strchr(&line[n],'#') = '\0';
X          i = atoi(&line[n]);	/* get the number following. */
X          if (i < 0 || i > 255) {	/* check for sanity. */
X            fprintf(stderr, "Invalid escape/ignore %d in termrc\n", i);
X            continue;
X          }
X          if ((p = strchr(&line[n], '-')) != NULL) { /* See if this is a */
X  					     /* range.. */
X            while (isspace(*++p));	/* skip whitespace. Note that it */
X				/* automatically skips the '-'. */
X            j = atoi(p);		/* if it is, then get the second number. */
X            if (j < 0 || j > 255) {	/* sanity check again. */
X              fprintf(stderr, "Invalid range limit %d in termrc\n", j);
X              continue;
X            }
X            for (;i != j; i = (i+1) & 255) /* Ok. mark all the characters */
X				/* in the range as being escaped. */
X              rc_options[m+2][i] = '\1';   
X          }
X          else rc_options[m+2][i] = '\1';	/* else just set the one character as */
X				/* to be escaped. */
X          break;
X        }
X
X        case INT_TYPE:
X          read_int_type((int *) rc_options[m+2],&line[n]);
X          break;
X        case ULONG_TYPE:
X	{
X	  if(strchr(&line[n],'#'))
X	    *strchr(&line[n],'#') = '\0';
X	  read_ulong_type((unsigned long *) rc_options[m+2],&line[n]);
X          break;
X        }
X        case FLOAT_TYPE:
X	{
X	  if(strchr(&line[n],'#'))
X	    *strchr(&line[n],'#') = '\0';
X	  sscanf(&line[n],"%f",(float *) rc_options[m+2]); 
X          break;
X        }
X      };
X      break;	
X    };
X    if (m == RC_OPTIONS_SIZE){
X      if(! strncmp("remote",line,6)){
X         remote = 1;
X      }else{
X        fprintf(stderr, "Unrecognized line in %s\r\n",file);
X        fprintf(stderr, "\t%s\r\n",line);
X      }
X    }
X  }
X  if(f != NULL) fclose(f);
X
X  if (Chdir[0] != '\0')
X    chdir((char *) Chdir);
X
X  if(seven_bit){
X    seven_bit_in = 1;
X    seven_bit_out = 1;
X  }
X
X  if (! login_type && !rshtype)
X    rshtype = -1;
X
X  if (!user_share) {
X    share = 0;
X    savedeid = -1;
X  }else if (user_share > 0) {
X    share = (share == 1) ? 1 : 2;
X  };
X
X#if 0 /* Useful for debugging */
X  for(m = 0;m < RC_OPTIONS_SIZE;m += 3)
X    switch ( (int) *rc_options[m+1] ){
X    case INT_TYPE:
X    {
X      int *o;
X      o = (int *) rc_options[m+2];
X      fprintf(stderr,"%s %d\r\n",rc_options[m],*o);
X      break;
X    }
X  }
X#endif
X}
X
X#define GETOPT_OPTS "Aac:d:f:l:n:ors:t:v:w:P:S:q"
X
Xint main(int argc, char *argv[]) 
X{
X  
X  int s, c, i, hangup;
X  char *ptr=NULL, *path=NULL;
X  int umask_old;
X
X  breakout_string[0] = 0;
X  term_opterr = 0;
X  while ((c = term_getopt (argc, argv, GETOPT_OPTS)) != EOF) 
X    switch(c) {
X    case 'S':
X      read_int_type(&user_share,term_optarg);
X      if (!user_share) share=0;
X      break;
X    case 'q':
X      ++quiet;
X      break;
X  }; term_optind = 1;
X
X  if (quiet <= 1)
X    fprintf(stderr, "Term version: %s\r\n",str_version(VERSION));
X
X  /* initialize character escaping. */
X  for (i = 0; i < 256;i++) {
X    ignores[i] = 0;
X    escapes[i] = 0;
X  }
X
X  escapes['^'] = 1;
X
X  main_init();
X
X  if (!term_server) {
X    term_server=getenv("TERMSERVER");
X    if (!term_server) term_server = "";
X  }
X
X  /* read in the termrc file. */
X  read_rc(0);
X
X  if(share > 0)
X    fprintf(stderr, "Using shared mode.\r\n");
X
X  /* then check env variables. */
X  setbuf(stderr, 0);
X  if (getenv("BAUDRATE")) 
X    read_ulong_type(&baudrate,getenv("BAUDRATE"));
X
X  /* Then check command line options */
X  /*
X    The code to parse the command line was written by the
X    one and only Muhammad Saggaf. If you have any question
X    about Linux, networking, Unix, or life in general, 
X    don't ask him mate! :). Chances are he doesn't know the 
X    answer.
X    */
X  
X  term_opterr = 0;
X  
X  while ((c = term_getopt (argc, argv, GETOPT_OPTS)) !=EOF)
X    switch(c) {
X    case 'A':
X      auto_retrain = 1;
X      break;
X    case 'a':
X      {
X	extern int tok_byte_mask_out, tok_byte_width_out,
X	  tok_byte_mask_in, tok_byte_width_in;
X	tok_byte_mask_out = tok_byte_mask_in = 127;
X	tok_byte_width_out = tok_byte_width_in = 7;
X
X	seven_bit_in = seven_bit_out = 1;
X	in_mask = out_mask = 127;
X	break;
X      }
X    case 'f': 
X      read_int_type(&fudge_flow,term_optarg);
X      break;
X    case 'l':
X      i = open(term_optarg, O_RDWR | O_CREAT | O_TRUNC, 0644);
X      if (i < 0) {
X	perror("open");
X	fprintf(stderr, "Unable to open log file %s\r\n", term_optarg);
X	break;
X      }else {
X        modem_noise = 0;
X      }
X      if (i != 2) {
X	close(2);		/* Just to make sure.. */
X	dup2(i, 2);
X	close(i);
X      }
X      break;
X    case 'r': remote = 1; break;
X    case 't':
X      read_ulong_type(&packet_timeout,term_optarg);
X      break;
X    case 'v':
X
X				/* add a device to the list. */
X      i = open(term_optarg, O_RDWR);
X      if (i < 0) {
X	perror("open");
X	fprintf(stderr,"Unable to open modem device %s\r\n", term_optarg);
X	break;
X      }
X      if(modem_in>=0) close(modem_in);
X      if(modem_out>=0) close(modem_out);
X      modem_in = i;
X      modem_out = i;
X      break;
X    case 'w':
X      read_int_type(&window_size_max,term_optarg);
X      break;
X    case 'd': 
X      read_int_type(&term_debug,term_optarg);
X      fprintf(stderr, "Debugging = %x\n", term_debug);
X      break;
X    case 'c':
X      read_int_type(&compressing,term_optarg);
X      break;
X    case 'n':
X      read_int_type(&write_noise,term_optarg);
X      break;
X    case 's':
X      read_ulong_type(&baudrate,term_optarg);
X      break;
X    case 'q':
X    case 'S':
X      break;
X    default:
X      fprintf(stderr, "unrecognized or incomplete argument '%s'. Exiting\r\n",  argv[term_optind-1]);
X    }
X
X  if (term_optind < argc)
X    term_server = argv[term_optind];
X  
X  for (s = 0; s < MAX_CLIENTS;++s) {
X    clients[s].fd = -1;
X  }
X
X				/* Read in a specific termrc. */
X  if (term_server[0])
X    read_rc(term_server);
X
X  if (!share) {
X    do {
X      if ((path = get_term_path(&ptr))) {
X        strcat(path,"/.term");
X        if (access(path, X_OK | R_OK | W_OK) < 0) continue;
X        if (chmod(path,0700)  < 0) {
X          if (!quiet) 
X            fprintf(stderr,"Can't set permissions on %s to 0700\r\n",
X              path);
X          continue;
X        }
X        break;
X      }else break;
X    } while ( ptr );
X    if (! path) {
X      fprintf(stderr, "Failed to find any of:\r\n");
X      ptr = NULL;
X      do {
X        if ((path = get_term_path(&ptr))) {
X          strcat(path,"/.term");
X          fprintf(stderr,"\t%s\r\n",path);
X        }else break;
X      } while ( ptr );
X      exit(1);
X    }
X    strcat(path,"/socket");
X    strcat(path,term_server);
X  }else{
X    if (savedeid >= 0){ 
X      if (share == 2)
X        setuid(savedeid);
X      else
X        setgid(savedeid);
X    }
X
X/* set the protection to be explicitly what I define below */
X    umask_old=umask(0);
X
X    do {
X      if ((path = get_term_path(&ptr))) {
X        if (eaccess(path, getuid() ? (X_OK | R_OK) : 0) < 0) continue;
X        break;
X      }else break;
X    } while ( ptr );
X    if (! path) {
X      fprintf(stderr, "Failed to find any of:\r\n");
X      ptr = NULL;
X      do {
X        if ((path = get_term_path(&ptr))) {
X          fprintf(stderr,"\t%s\r\n",path);
X        }else break;
X      } while ( ptr );
X      exit(1);
X    }
X
X/* Create a link to "." as ".term" for backwards compatibility */
X
X    i=strlen(path);
X    strcat(path,"/.term");
X    if (eaccess(path, X_OK | R_OK ) < 0) 
X      symlink("./tmp/private",path);
X    path[i]='\0';
X
X/* If the needed directories don't exist, create them */
X    strcat(path,"/tmp");
X    mkdir(path,0777);
X
X/* Make sure we can access the directory */
X
X    if (eaccess(path, getuid() ?  (X_OK | W_OK | R_OK) : 0) < 0) 
X      if (chmod(path,0777) < 0) {
X      fprintf(stderr, "Can't read, write, &/or execute %s\r\n", path);
X      exit(1);
X    }
X
X/* It seems that the protection on sock_unix is ignored, so we need a 
X   a make a subdirectory, that only term can see. */
X
X    strcat(path,"/private");
X    strcat(path,term_server);
X
X/* Remove any old sockets */
X    i=strlen(path);
X    strcat(path,"/socket");
X    unlink(path);
X    path[i]='\0';
X
X/* Remove and recreate the private directory, so we can be sure we can see it */
X    rmdir(path);
X    if (share == 2) {
X      mkdir(path, 0700|S_ISUID);
X      chmod(path, 0700|S_ISUID);
X    }else {
X      mkdir(path, 0770|S_ISGID);
X      chmod(path, 0770|S_ISGID);
X    };
X  
X/* Finally make sure we can access the directory */
X
X    if (eaccess(path, getuid() ? (X_OK | W_OK | R_OK) : 0) < 0) {
X      fprintf(stderr, "Can't read, write, &/or execute %s\r\n",
X        path);
X      exit(1);
X    }
X
X    strcat(path,"/socket");
X
X/* Restore the mask to what the user wants to use with tupload. */
X    umask(umask_old);
X  }
X
X/* It doesn't hurt to unlink twice ... */  
X  unlink(path);
X  if ((s = bind_unix(path)) < 0) 
X    exit(1);
X
X  setuid(getuid());
X  setgid(getgid());
X
X  /* init modules */
X 
X  var_init();
X
X  serial_init();
X  compress_init();
X  update_time();
X
X  if (ownroot[0]) {
X    if (chroot(ownroot) < 0) {
X      perror("chroot");
X      if (rshtype > 0) {
X        fprintf(stderr, "Your chroot failed.  Exiting rather than risking invasion\n");
X        exit(1);
X      }
X    }
X  }else if (rshtype > 0) {
X    if (!quiet) 
X      fprintf(stderr, "Warning: If you use chroot, you probably want denyrsh"
X        "as well\n");
X  }
X  
X#ifdef SYSV
X  sigset(SIGCHLD, sig_child);
X#else
X  signal(SIGCHLD, sig_child);
X#endif /* SYSV */
X  signal(SIGHUP, sig_quit);
X  signal(SIGPIPE, sig_ignore);
X  signal(SIGINT, sig_quit);
X  signal(SIGQUIT, sig_quit);
X  signal(SIGIOT, sig_core);
X  signal(SIGSEGV, sig_core);
X  signal(SIGALRM, sig_ignore);
X
X  terminal_save(0);
X  set_nonblock(s);
X  set_nonblock(modem_in);
X  set_nonblock(modem_out);
X  terminal_raw(modem_in);
X  terminal_raw(modem_out);
X
X  main_loop(s);
X
X  	/* with C_QUIT 2 or if hangup_on_exit and not C_QUIT 1 */
X  hangup = do_shutdown == 2 || (hangup_on_exit && do_shutdown!=1);
X
X  set_block(modem_in);
X  set_block(modem_out);
X  terminal_restore(0,hangup);
X  terminal_restore(1,hangup);
X
X  set_block(s);
X
X	/* If terminal_restore didn't hangup, this might. */
X	/* This is way too specific for my blood.  This assumes your modem */
X	/* will respond to +++ and the AT command set.  In most cases with */
X	/* an annex port, it won't work. */
X  if (!remote && hangup) {
X    sleep(2);	/* one second may not be enough */
X    if (write(modem_out, "+++", 3) > 0) {
X      sleep(2);
X      if (explicit_hangup) 
X        write(modem_out, "ath0\r", 5);
X    }
X  }
X  exit(0);
X}
X
X/*-----------------------------------------------------------------------*/
Xvoid check_client(int cl, int ret) {
X  DEBUG_MAIN(stderr, "%s: termerrno == %d\n", term_server, termerrno);
X  if (!termerrno) return;
X  if (clients[cl].state == 3 ) {
X    DEBUG_FP(stderr, "%s:truncating out_buff\n", term_server);
X    clients[cl].out_buff.size = 0;
X    clients[cl].out_buff.start = clients[cl].out_buff.end;
X    return;
X  }
X#if 0
X  if (ret < 0)
X    perror("client gave this");
X#endif
X				/* Ok. Close the descriptor. */
X  if(clients[cl].fd >= 0) close(clients[cl].fd);
X  clients[cl].fd = -1;
X				/* And go to state 2. */
X  clients[cl].state = 2;
X}
X
Xint new_client(int fd) {
X  int j;
X
X  for (j = remote; j < MAX_CLIENTS;j += 2)
X    if (clients[j].fd < 0 && clients[j].state < 0) break;
X
X  if (j == MAX_CLIENTS) return -1; /* not maximum clients */
X
X  DEBUG_FP(stderr, "%s: new client %d.\n", term_server, j);
X  
X  clear_buffers(&clients[j]);
X
X  clients[j].fd = fd;
X  clients[j].type = T_SMART | T_RDFILE | T_WRFILE;
X  clients[j].udp_type = 0; 
X  clients[j].udp_size = 0; 
X  clients[j].dump_count = 0;
X  clients[j].cl_type = CL_SOCKET;
X  clients[j].compress = compressing;
X  clients[j].state = 1;
X  clients[j].c_state = 0;
X  clients[j].number = j;
X  clients[j].priority = 0;
X  clients[j].queue = 0;
X  clients[j].name[0] = 0;
X  clients[j].parent = -1;
X  clients[j].peername.sin_port = ~0;
X  clients[j].peername.sin_addr.s_addr = term_localaddr;
X  clients[j].peername.sin_family = ~0;
X  set_nonblock(fd);
X  return j;
X}
X/*------------------------------------------------------------------------*/
X/* Main loop. Hangs around waiting for things to get ready, and calls to  */
X/* appropriate routines. 						  */
X
Xvoid main_loop(int socket) {
X  struct timeval timeout;
X  fd_set reads, writes, excepts;
X  int i, j, k, empty = 1, csocket = -1, bytes_received = 0, script_fd = -1;
X  int max = 0;
X
X  while (!do_shutdown) {
X
X/* If the serial out buffer is empty, try and put something in it */
X    if (bytes_left > 0 && serial_out.size < bytes_left) {
X      DEBUG_SER(stderr, "%s: doing serial out\n",
X	       term_server);
X      do_serial_out(0);
X      if (!serial_out.size)
X	do_link_out();
X      if (!serial_out.size) 
X	do_serial_out(0);
X      DEBUG_SER(stderr, "%s:  serial out size %d\n",
X	       term_server, serial_out.size);
X    }
X
X/* Set up client stuff */
X/* We select to read if: */
X/*	The input buffer is empty */
X/* We select to write if: */
X/*      The output buffer is not empty */
X/*      We're waiting for a connection to complete (state == 5) */
X
X    FD_ZERO(&reads);
X    FD_ZERO(&writes);
X    FD_ZERO(&excepts);
X    
X    if (p_in_num && empty)
X      do_link_in();
X    
X    for (i = 0; i < MAX_CLIENTS;++i) {
X				/* If it's closing down, and the */
X				/* buffers are empty, then kill it. */
X      if ((clients[i].state == 3 || clients[i].state == 4) &&
X	  (clients[i].type & T_UDP ||
X           (!clients[i].in_buff.size && !clients[i].out_buff.size ))) {
X        int l;
X
X	DEBUG_FP(stderr, "%s:real close %d %d %d\n", term_server , i,
X		 clients[i].state, clients[i].fd);
X        for(l=0;l<MAX_CLIENTS;++l)
X          if(clients[l].parent == i && clients[l].state == 1 )
X            clients[l].state = 3;
X	if (clients[i].fd > 0) close(clients[i].fd);
X	clients[i].fd = -1;
X	if (clients[i].state == 3)
X	  clients[i].state = -1; 
X	else clients[i].state = 1;
X	continue;
X      }
X				/* If it's a file, we don't need to */
X				/* select() on it. */
X      if (clients[i].cl_type == CL_FILE) continue;
X      if (clients[i].fd < 0) continue; /* If it's not a file, and */
X				       /* there is no fd, then no */
X				       /* select(). */
X      if (clients[i].in_buff.size < 2 * packet_len &&
X            (clients[i].type & T_RDFILE) && clients[i].state == 1) {
X	FD_SET(clients[i].fd, &reads);
X      }
X      if ((clients[i].out_buff.size && (clients[i].type & T_WRFILE)) ||
X	  (clients[i].state == 5)) {
X	FD_SET(clients[i].fd, &writes);
X      }
X      FD_SET(clients[i].fd, &excepts);
X      if (max < clients[i].fd) max = clients[i].fd;
X    }
X    
X/* Select for socket and modem */
X/* We select read for socket if we aren't at the maximum number */
X/* of clients */
X    if (num_clients < MAX_CLIENTS) {
X      FD_SET(socket, &reads);
X      if (max < socket) max = socket;
X      for (k=0;k < MAX_CLIENTS;k++) if(onetime_term[k].socket >= 0){
X        FD_SET(onetime_term[k].socket, &reads);
X        if (max < onetime_term[k].socket) max = onetime_term[k].socket;
X      }
X    }
X
X/* We select for read on the modem if the serial in buffer is empty */
X    if (!serial_in.size) {
X      FD_SET(modem_in, &reads);
X      if (max < modem_in) max = modem_in;
X    }
X
X/* Now if there is anything in the serial out buffer, select for writing */
X
X    if (serial_out.size && bytes_left > 0) {
X      DEBUG_SER(stderr, "%s: dso: fd set\n",
X	       term_server);
X      FD_SET(modem_out, &writes);
X      if (max < modem_out) max = modem_out;
X    }
X
X/* We need to call the script from the main loop, since we want term up */
X/* and running first. To avoid sending data too soon, the script won't run */
X/* until the first term command has been sent by the user. This may cause */
X/* some confusion, if for example the script is 'txconn' and the first */
X/* command is 'trsh -s xterm', but I can't think of a way to avoid this. */
X
X    if (shell_command[0] && remote_term_version) { 
X      script_fd = open_socket(shell_command); 
X        set_nonblock(script_fd);
X      shell_command[0] = 0;
X    }
X    if (script_fd >= 0) 
X      FD_SET(script_fd, &reads);
X
X				/* This is only for my own purposes. */
X
X/* This is intended as a short delay to help decrease CPU usage. */
X    timeout.tv_sec = 0;
X    timeout.tv_usec = (unsigned long int) delay;
X    if(max_cps > 0) select(0, NULL, NULL, NULL, &timeout); 
X
X/* Set the timeout value for select(). */
X    timeout.tv_sec = 0;
X    timeout.tv_usec = 500000; /* 0.5 seconds */
X
X/* do select() */	
X    if (select(max+1, &reads, &writes, &excepts, &timeout) < 0) {
X				/* This is perfectly normal. Things */
X				/* that send signals will cause select */
X				/* to exit with an error. */
X#if 0
X      perror("select");
X#endif
X      continue;
X    }	
X
X/* Update current_time. This is maintained in 20th s of a second */
X    update_time();
X
X/* start checking to see what's ready and what's not */
X
X/* See if it is just the script */
X
X    if (script_fd >= 0 && FD_ISSET(script_fd, &reads)) {
X      memset(shell_command,0,sizeof(shell_command));
X      j = read(script_fd, &shell_command[1], sizeof(shell_command)-1);
X      if ( j <= 0 && errno != ERR_BLOCK) {
X        close(script_fd);
X        script_fd = -1;
X      }else {   /* I copy this exactly to stderr */
X        if (write_noise < 2) fwrite(&shell_command[1],j,sizeof(char),stderr);
X      }
X    }
X
X/* Can we read from modem  ?? */
X    bytes_received = 0;
X    if (!serial_in.size && FD_ISSET(modem_in , &reads)) {
X      j = read_into_buff(modem_in, &serial_in, 0);
X      if ( j < 0 && errno != ERR_BLOCK) {
X	perror("read from modem");
X	return;
X      }
X      else{
X        stat_modem_in += j;
X        if (collisions) bytes_received = j;
X      }
X    }
X
X/* Now we process any new data before writing out to the modem. */
X
X    if (serial_in.size) 
X      do_serial_in();
X
X/* test for new client */
X
X    for(k=0;k <= MAX_CLIENTS;k++){
X      switch (k){
X        case MAX_CLIENTS:
X          csocket = socket;
X          break;
X        default:
X          if (onetime_term[k].socket > 0 && 
X              current_time > onetime_term[k].timeout) {
X            close(onetime_term[k].socket);
X            onetime_term[k].socket = -1;
X          }
X          csocket = onetime_term[k].socket;
X          break;
X      };
X      if(csocket<0) continue;
X      if (FD_ISSET(csocket, &reads)) { /* try for a connect. */
X
X        struct sockaddr_in addr_in;
X
X#if defined(STREAMS_PIPE) || defined(X_STREAMS_PIPE)
X 	i = CheckClientConnection(csocket);
X	if (i != -2) {			/* we have a streams pipe */
X		if (i == -1) {
X			fprintf(stderr, "can't add client\n");
X			continue;
X		} /* else fall through to add new client after "accept ..." */
X	} else 		/* not a streams pipe */
X#endif
X        {
X          int din = sizeof(addr_in);
X          if ((i = accept(csocket , (struct sockaddr *) &addr_in, &din)) >= 0) {
X            if (addr_in.sin_family == AF_INET) {
X              if (addr_in.sin_addr.s_addr != htonl(term_localaddr)
X                  && addr_in.sin_addr.s_addr != INADDR_ANY 
X                  && addr_in.sin_addr.s_addr != inet_addr("127.0.0.1") ) {
X                close(i);
X                i = -1;
X                DEBUG_FP(stderr,"%s: rejected connection from %s\n",
X                  term_server, inet_ntoa(addr_in.sin_addr));
X              }else {
X                DEBUG_FP(stderr,"%s: accepted connection %d from %s\n",
X                  term_server, i, inet_ntoa(addr_in.sin_addr));
X              }
X            }else {
X              DEBUG_FP(stderr,"%s: accept connection from unix domain\n",
X                term_server);
X            } 
X          }
X        }
X        if (k < MAX_CLIENTS) {
X	  int on=1;
X          onetime_term[k].socket = -1;
X          close(csocket);
X	  setsockopt(i, SOL_SOCKET, SO_REUSEADDR,
X            (char *)&on, sizeof(on));
X        }
X        
X        if (i >= 0) { /* a new client */
X	  if((j = new_client(i)) < 0) 
X            close(i);
X          else
X            memcpy(&clients[i].peername,&addr_in,sizeof(clients[i].peername));
X        }
X        else if (termerrno != 1) {
X#if 0
X	  perror("accept");
X#endif
X        }
X      }
X    };
X
X/* test for data being read from clients */
X    for (i = 0; i < MAX_CLIENTS;++i) {
X      if (clients[i].fd < 0) continue;
X      if (clients[i].in_buff.size >= 2*packet_len) continue;
X      switch (clients[i].cl_type) {
X      case CL_CHILD:		/* fall through */
X      case CL_SOCKET:		/* fall through */
X#if defined(STREAMS_PIPE) || defined(X_STREAMS_PIPE)
X      case CL_SPIPE:
X#endif
X	if (!FD_ISSET(clients[i].fd, &reads) &&
X	    !FD_ISSET(clients[i].fd, &excepts))
X	  continue;
X				/* Fall through. */
X	if (!(clients[i].type & T_RDFILE)) continue;
X        if (clients[i].type & T_UDP)
X          j = recvfrom_into_buff(&clients[i]);
X        else
X	  j = read_into_buff(clients[i].fd, &clients[i].in_buff, 0); 
X	DEBUG_FP(stderr, "%s:read %d bytes from client %d\n",
X		 term_server , j, i);
X				/* Did this client start sending?? */
X	DEBUG_FP(stderr, "%s:j %d, inf_buff.size %d\n",
X		 term_server , j, clients[i].in_buff.size);
X
X				/* Hmmm. Something errored. Lets take */
X				/* a look... */
X	if (j <= 0)
X	  check_client(i, j);
X	if (termerrno == 1)
X	  check_client(i, j);
X	break;
X      case CL_FILE:
X	if (!(clients[i].type & T_RDFILE)) continue;
X	if (! clients[i].dump_count) {
X          close(clients[i].fd);
X          clients[i].fd = -1;
X          clients[i].cl_type = CL_SOCKET;
X          clients[i].type = T_RDFILE | T_WRFILE;
X          clients[i].state = 1;
X          continue;
X        }
X	j = read_into_buff(clients[i].fd, &clients[i].in_buff,
X          (clients[i].dump_count > 32767) ? 32767 
X          : (int) clients[i].dump_count); 
X	DEBUG_FP(stderr, "%s:read %d bytes from file client %d\n",
X		 term_server , j, i);
X	DEBUG_FP(stderr, "%s:j %d, inf_buff.size %d\n",
X		 term_server , j, clients[i].in_buff.size);
X	if (j <= 0)
X	  check_client(i, j);
X	if (termerrno == 1) termerrno = 0;
X	break;
X      case CL_BOUND:
X	if (!FD_ISSET(clients[i].fd, &reads)) continue;
X	{
X	  un_char num[10]; int k;
X				/* We have an accept ready... */
X	  clients[i].type &= ~T_RDFILE; /* Don't try reading it until */
X				/* the accept is done. */
X	  sprintf((char *) num, "%d", i);
X	  for (k =0 ;num[k];++k)
X	    add_to_buffer(&clients[i].in_buff, num[k]);
X	  add_to_buffer(&clients[i].in_buff, 0);
X	}
X	break;
X      }
X    } /* for clients loop */
X    
X#ifndef USE_CONNBLOCK
X/* Test pending connections. */
X    for (i = 0; i < MAX_CLIENTS; ++i) {
X      if (clients[i].state == 5) {
X	char	dummy;
X
X	if (FD_ISSET(clients[i].fd, &writes)) {
X          void ret_ok(struct Client *, int);
X
X	  ret_ok(&clients[i], 0);
X		/* safe to call from here? */
X	  clients[i].state = 1;
X	}
X	else if (read(clients[i].fd, &dummy, 0) < 0) {
X	  void ret_fail(struct Client *, int, int, char *);
X	  switch (errno) {
X          case ERR_BLOCK:
X	  case ENOTCONN:	/* no status, but maybe timed out */
X	    if (current_time >= clients[i].timeout) {
X	      errno = ETIMEDOUT;
X	      ret_fail(&clients[i], 0, 1, 
X                "connect() timed out");
X	      perror("async connect()");
X	      clients[i].state = 2;
X	    }
X	    break;
X	  default:
X	    ret_fail(&clients[i], 0, 1,
X              "connect() timed out");
X	    perror("async connect()");
X	    clients[i].state = 2;
X	    break;
X	  }
X	}
X      }
X    }
X#endif
X
X/* test for data being sent to clients */
X    empty = 1;
X    for (i = 0; i < MAX_CLIENTS;++i) {
X      if (clients[i].fd < 0) continue;
X      if (!clients[i].out_buff.size) continue;
X      if (clients[i].type & T_UDP &&
X        clients[i].out_buff.size < clients[i].udp_size ) continue;
X      switch (clients[i].cl_type) {
X      case CL_CHILD:
X      case CL_SOCKET:
X#if defined(STREAMS_PIPE) || defined(X_STREAMS_PIPE)
X      case CL_SPIPE:
X#endif
X	if  (!FD_ISSET(clients[i].fd, &writes)) continue;
X      case CL_FILE:
X	if (!(clients[i].type & T_WRFILE)) continue;
X				/* something there! :) */
X        if (clients[i].type & T_UDP) {
X          j = sendto_from_buff(&clients[i]);
X          if (!j) break;
X        }else
X  	  j = write_from_buff(clients[i].fd, &clients[i].out_buff,0);
X	DEBUG_FP(stderr, "%s:write %d bytes to client %d\n", 
X		 term_server, j, i);
X	if (j <= 0)
X	  check_client(i, j);
X	else stat_cooked_in += j;
X	break;
X      case CL_BOUND:
X	break;
X      }				/* switch */
X    }				/* for clients loop */
X    
X/* Ok. Can we write to modem ??? */
X    if (FD_ISSET(modem_out, &writes) && bytes_left > 0) {
X      
X      int t = bytes_left;
X      if (t > serial_out.size)
X	t = serial_out.size;
X      if (t > block_size)
X        t = block_size;
X      DEBUG_SER(stderr, "%s: dso: write from buff\n",
X	       term_server);
X      j = write_from_buff(modem_out, &serial_out, t);
X      if (j < 1 && termerrno != 1) {
X	errno = termerrno - 1;
X	perror("write to modem");
X	return;
X      }else {
X	stat_modem_out += j;
X        bytes_left -= j + bytes_received + (modem_noise ? modem_noise - 1 : 0);
X      }
X    }
X
X  } /* while loop */
X
X  if (script_fd >= 0) close(script_fd);
X 
X} /* function */
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/main.c' &&
  chmod 0644 'term-2.2.5/main.c' ||
  echo 'restore of term-2.2.5/main.c failed'
  shar_count="`wc -c < 'term-2.2.5/main.c'`"
  test 37822 -eq "$shar_count" ||
    echo "term-2.2.5/main.c: original size 37822, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/meta.c ==============
if test -f 'term-2.2.5/meta.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/meta.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/meta.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/meta.c' &&
X#include "includes.h"
X#include "debug.h"
X
Xextern char * term_server;
X				/* This file is intended to be the */
X				/* replacement for checkline, and */
X				/* linerem. This should be able to */
X				/* work out which character */
X				/* combinations are getting eaten, and */
X				/* set up a termrc file accordingly. */
X
Xint meta_state(int i) 
X{
X  static int state = 0;
X
X/*  static char control[10];*/
X  switch (state) {
X  case 0:
X    /* We wait for start of packet processes. */
X    if (i != 'E') return 1;
X    state = 1;
X    break;
X  case 1:			/* We got an E, now receive a number */
X    
X    return 0;			/* return to normal processing. */
X  }
X  return 0;
X}
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/meta.c' &&
  chmod 0644 'term-2.2.5/meta.c' ||
  echo 'restore of term-2.2.5/meta.c failed'
  shar_count="`wc -c < 'term-2.2.5/meta.c'`"
  test 659 -eq "$shar_count" ||
    echo "term-2.2.5/meta.c: original size 659, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/misc.c ==============
if test -f 'term-2.2.5/misc.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/misc.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/misc.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/misc.c' &&
X#define I_IOCTL
X#define I_SYS
X#define	I_TTY
X#define I_SIGNAL
X#define I_LIMITS
X#define I_CTYPE
X#include "includes.h"
X#include "debug.h"
X
X
Xextern char breakout_string[256];
X
Xvoid update_time(void) {
X  struct timeval t;
X  extern int bytes_left;
X  unsigned long old_time = current_time;
X  
X  gettime(&t);
X  current_time = ((unsigned long)t.tv_sec) * (unsigned long)term_inc + 
X		(unsigned long)(t.tv_usec / (1000000 / (unsigned long)term_inc));
X  if (max_cps) {
X    bytes_left += ((current_time - old_time) * max_cps) / term_inc;
X    if (bytes_left > block_size) bytes_left = block_size;
X  }else {
X    bytes_left = block_size;
X  }
X  if (bytes_left < 0) bytes_left = 0;/* sanity check */
X}
X
Xvoid do_debug(int level, char *c) {
X/*  fprintf(stderr, "%s\n", c); */
X  return;
X}
X
Xvoid do_noise(int a) {
X  static int count=0;
X  extern int modem_noise;
X
X  if (modem_noise) modem_noise++;
X
X	/* This routine tries to print things out in a readable format */
X	/* without ever outputting the breakout string or upper case on */
X	/* the remote machine. */
X  if (!write_noise && !do_shutdown) return;
X  a ^= byte_shift;
X
X  if (do_shutdown) {
X    fprintf(stderr, "%c",a);
X  }else if ((a != '\b' && a != '\t' && a != '\n' &&
X      a != '\r' && a < ' ') || a > 127) {
X    fprintf(stderr, "<%u>", a);
X    count = 0;
X  }else if ( !remote ) {
X    fprintf(stderr, "%c",a);
X  }else {
X    a = tolower(a);
X    if (a != breakout_string[count]) {
X      count = 0;
X      fprintf(stderr, "%c", a);
X    }else if ( count++ > 4 || escapes[a]) {
X      if ( a != toupper(a) && a >= 'A' && a < 'A'+MAX_TYPE)
X        fprintf(stderr, "%c", toupper(a));
X      else 
X        fprintf(stderr, "<%d>", a);
X      count = 0;
X    }else { 
X       fprintf(stderr, "%c", a);
X    }
X  }
X}
X
Xvoid do_alert(char *s) {
X  if (remote) return;
X  fprintf(stderr, "%s", s);
X}
X
X/* rebuild the arg list
X * compliment to build_arg()
X *
X * by: croutons
X * 
X * mallocs the array that is returned.
X * see build_arg() for other assumptions.
X */
Xchar ** rebuild_arg(char * f)
X{
X	int i,s;
X	static char ** a;
X
X        if (a) free(a);
X	DEBUG_FP(stderr,"%s:rebuild :%s:\n", term_server, f);
X	if ( ! f || !f[0]) return NULL;
X	for ( s = 0, i = 2; '\0' != f[s]; s++ ) { 
X/*		if ( '\xff' == f[s] ) { Ultrix MIPS compiler chokes on this */
X		if ( '\377' == f[s] ) {
X			i++;
X		}
X	}
X	if ( NULL == ( a = (char**) malloc(i*sizeof(char*)) ) ) {
X		return NULL;
X	}
X	a[0]=f;
X	for ( s = i = 0; '\0' != f[s]; s++ ) {
X/*		if ( '\xff' == f[s] ) { */
X		if ( '\377' == f[s] ) {
X			f[s] = '\0';
X			a[++i] = &f[s+1];
X		}
X	}
X	a[i] = NULL;
X	return a;
X}
X
X#ifdef USE_SIGWINCH
Xvoid do_resize(int number, int rows, int cols, int ypixels, int xpixels)
X{
X  int i;
X#ifdef USE_WINCHKILL
X  int pg;
X#endif
X
X  for (i=0; i < MAX_CLIENTS; i++)
X    {
X      if (clients[i].fd >= 0 && clients[i].number == number)
X	{
X#ifdef TIOCSWINSZ
X	  struct winsize ws;
X
X	  ws.ws_row = rows;
X	  ws.ws_col = cols;
X	  ws.ws_ypixel = ypixels;
X	  ws.ws_xpixel = xpixels;
X	  ioctl(clients[i].fd, TIOCSWINSZ, &ws);
X#else
X#ifdef TIOCSSIZE
X	  struct ttysize ts;
X
X	  ts.ts_lines = rows;
X	  ts.ts_cols = cols;
X	  ts.ts_yyy = ypixels;
X	  ts.ts_xxx = xpixels;
X	  ioctl(clients[i].fd, TIOCSSIZE, &ts);
X#endif
X#endif
X
X#ifdef USE_WINCHKILL
X#ifdef SYSV
X	  pg = getpgid(clients[i].pid);
X	  if (pg > 0)
X	      kill(pg, SIGWINCH);
X#else
X	  pg = getpgrp(clients[i].pid);
X	  if (pg > 0)
X	      killpg(pg, SIGWINCH);
X#endif
X#endif	/* USE_WINCHKILL */
X	}
X    }
X
X    return;
X}
X#endif /* USE_SIGWINCH */
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/misc.c' &&
  chmod 0644 'term-2.2.5/misc.c' ||
  echo 'restore of term-2.2.5/misc.c failed'
  shar_count="`wc -c < 'term-2.2.5/misc.c'`"
  test 3454 -eq "$shar_count" ||
    echo "term-2.2.5/misc.c: original size 3454, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/old/Blurb ==============
if test ! -d 'term-2.2.5/old'; then
  echo 'x - creating directory term-2.2.5/old'
  mkdir 'term-2.2.5/old'
fi
if test -f 'term-2.2.5/old/Blurb' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/old/Blurb (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/old/Blurb (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/old/Blurb' &&
X
X#
X# this file written by Olaf (sorry , lost email).
X# LOTS of nice things. Read.
X#
X
XThis is a set of enhancements to term 1.0.7. I consider it to be in
Xbeta stage and would appreciate any bug reports, especially if
Xsomething that works with 1.0.7 gets broken by this patch (which
Xreally shouldn't happen). Probably this stuff could get into the
Xofficial distribution but that depends on Michael.  :-)
X
XI'm distributing this as one large collection of unified diffs against
Xstock term 1.0.7 (termdiff.all - just feed it to patch, there should
Xbe absolutely no problems with backward compatibility) and one
Xseparate file for patching into ftp.c (of either stock BSD or ncftp
Xflavor - the diff is noproxy.d against the ncftp version of ftp.c, for
Xthe BSD version apply the patch manually - it's very easy).
X
XSee the file 'Changed' for a table of additional features vs. changed
Xfiles.
X
XThe following features are added:
X- tredir may now redirect several ports at once
X       Affects clients only
X- Support for HP-UX 8.07 
X       Affects server and clients under HP-UX only
X- Enhanced security: trsh requests can be blocked, term can run under
X  chroot.
X       Affects server only
X
XBug corrections:
X- mistype in pty handling: alphabetical sequence was incorrect
X       Affects server only
X- C_BIND works now: correct update of # of active clients
X       Affects server only but makes certain clients usable
X- Redundancy taken out: don't request own address and delete it just 
X  afterwards
X       In the server, affects nothing (as far as I can tell now)
X- Finally, non-existing "linecheck.1" taken out of Makefile
X       Affects installation process only
X
XAnd one major feature was added, which unfortunately required a
Xprotocol change.  The termftp clients as known use proxy (passive)
Xserver mode. This will break with ancient ftp servers and with certain
Xfirewalls (the latter situation provided the incentive for me to write
Xthis, s.b.)).  To use the PORT command like the genuine ftp client,
Xterm needs the C_BIND command which does not work. I've corrected this
X(making possible some other new clients as well... see tclient.c for
Xan example. Anyone dares to hack up ircII to do DCC file transfer over
Xterm in both directions?)  Also, to properly implement this mode, the
Xftp client needs to get a listening socket from the system (usual
Xtechnique: bind to 0.0.0.0:0 and get port # with getsockname()). For
Xthis I have inserted a new command, C_BINDN, which will return the
Xport number used. I've not seen any possibility to transfer this
Xcritical information - the port # - from the remote server to the
Xclient other than a new protocol element.
X       Affects server and termftp clients only, but *could* cause
X       problems with future clients *if* protocol is changed again
X       (very unlikely)
X
XTo get termftp working with this, you need to completely replace the
SHAR_EOF
  : || echo 'restore of term-2.2.5/old/Blurb failed'
fi
echo 'End of archive part 5'
echo 'File term-2.2.5/old/Blurb is continued in part 6'
echo 6 > _sharseq.tmp
exit 0
