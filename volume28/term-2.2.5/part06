Newsgroups: comp.sources.unix
From: bcr@physics.purdue.edu (Bill C. Riemers)
Subject: v28i169: term-2.2.5 - SLIP-like functionality between two *IX hosts (REPOST), Part06/09
References: <1.784237938.15304@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: bcr@physics.purdue.edu (Bill C. Riemers)
Posting-Number: Volume 28, Issue 169
Archive-Name: term-2.2.5/part06

#!/bin/sh
# This is `part06' (part 6 of a multipart archive).
# Do not concatenate these parts, unpack them in order with `/bin/sh'.
# File `term-2.2.5/old/Blurb' is being continued...
#
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  echo 'WARNING: not restoring timestamps.  Consider getting and'
  echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if test ! -r _sharseq.tmp; then
  echo 'Please unpack part 1 first!'
  exit 1
fi
shar_sequence=`cat _sharseq.tmp`
if test "$shar_sequence" != 6; then
  echo "Please unpack part $shar_sequence next!"
  exit 1
fi
if test ! -f _sharnew.tmp; then
  echo 'x - still skipping term-2.2.5/old/Blurb'
else
  echo 'x - continuing file term-2.2.5/old/Blurb'
  sed 's/^X//' << 'SHAR_EOF' >> 'term-2.2.5/old/Blurb' &&
Xfunctions initconn() and dataconn() in ftp.c, inside the #ifdef TERM
Xor TERM_FTP, with the ones provided in ftpconn.c. (I've done this in a
Xseparate branch with #ifdef TERMPROXY.) This applies to both termftp
X(patched original BSD ftp client) and ncftp+term (patched ncftp);
Xncftp is derived from BSD anyway.
X
X*** Explanations - only of interest if you really need to know ***
X
X  Multiple redirections 
XHave you ever worried about the long list of tredir's in the ps
Xlisting? One process can manage as many ports as file descriptors are
Xavailable, only the standard tredir doesn't use this capability. (as
Xfrom the release note of 0.99.something) The changes are rather
Xtrivial (get tredir to process a set of arguments in the first place,
Xand add an argument to the redirecting function in the client lib - the
Xlatter means that every client compiled with the new lib has to be
Xadapted (trivially), but old ones will run unchanged. Refer to the
Xdiff for xconn.c to see what has to be changed.)
X
X  HPUX support 
XThis is the result of my (eventually successful) attempts to get term
X1.0.7 to run on a HP with a rather screwy OS (some sort of a mixture
Xof HPUX 8.05 and 8.07). Some definitions in the Makefile are changed,
Xetc. The most prominent feature is the use of SIGWINCH (which is
Xcalled SIGWINDOW and not used properly in HPUX, but required anyway).
XI'm using the c89 compiler (cc refuses to run), there is no install
Xcommand, and other minor annoyances.
X
X  Security considerations 
XEver run term as root on one end? Don't.  Everyone who has access to
Xthe other end's term socket (at least root on that machine) can become
Xroot on your box - all he has to do is trsh. Also, if term runs as
Xroot, it can clobber every file on your system with an appropriate
Xtupload. The solution: two more options in the termrc file, one to
Xdeny trsh's from the other end and one to run term in a chroot
Xenvironment (much like anonymous ftp does). The changes are only a few
Xlines of addition.
X
X  Why not use proxy mode with FTP? Why does termftp fail on some sites?
XThere are two ways how the data port of FTP can be opened: the client
Xconnects to a port of the server, or the server connects to a port of
Xthe client. Proxy FTP mode (the client sends PASV command and connects
Xto the socket returned by the server for data connections) works well
Xin an open network with modern ftp servers (the PASV command is now
Xrequired). However, there is a subtle difference to the usual scheme
X(where the client sends PORT <port> command and the server connects to
X<port>). If you bother to look at netstat, you will see the
Xdifference:
X(Example: A.B.C.D be the host with term and Internet connection, and
XM.N.O.P the ftp server; 9999 denotes an arbitrary port number, the *
Xside is the active end)
Xeither   *A.B.C.D:9999   M.N.O.P:9999  (termftp, proxy mode)
Xor        A.B.C.D:9999  *M.N.O.P:20    (the usual scheme)
X
XIn the latter case (which is set up by the PORT command), the
Xconnection is from a standard port (20 - ftp data). In the former
Xcase, you can get two non-standard ports, which will be blocked by
X"packet filtering gateways" (the most modest and least annoying form
Xof firewalls). To avoid this problem, one side of the connection must
Xbe port 20, and for this in the first case (proxy mode) the client had
Xto run setuid root. This is impractical just in the situation where it
Xwould be needed, so proxy mode can't be used. If you have termftp or
Xncftp-term, and it "hangs" on the first "ls", "get" or "put" command,
Xthen you're perhaps in this situation. If you can use standard
XInternet ftp, you can likely use my enhanced termftp as well - it uses
Xthe same ports and makes the term server behave exactly like an
Xordinary ftp client.
X  More FTP chicanery
XAssume you have an ftp client on your Internet box that is setuid
Xroot, and any other ftp client (compiled by yourself) won't run. Then
Xyou're out of luck with term anyway and should ask your network
Xadministration a few polite questions. The same holds for a genuine
Xfirewall - a network gateway which doesn't let anything "through" at
Xall. In this case you can't do anything but FTPing the files to the
Xfirewall and tupload'ing them afterwards (or vice versa).
X
SHAR_EOF
  echo 'File term-2.2.5/old/Blurb is complete' &&
  $shar_touch -am 1028144694 'term-2.2.5/old/Blurb' &&
  chmod 0644 'term-2.2.5/old/Blurb' ||
  echo 'restore of term-2.2.5/old/Blurb failed'
  shar_count="`wc -c < 'term-2.2.5/old/Blurb'`"
  test 7095 -eq "$shar_count" ||
    echo "term-2.2.5/old/Blurb: original size 7095, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/old/INTERNALS ==============
if test -f 'term-2.2.5/old/INTERNALS' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/old/INTERNALS (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/old/INTERNALS (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/old/INTERNALS' &&
XA quick run down of the internal structure.
X
Xmain.c:
X	main() Just sets things up. Opens socket, and set terminal
X		to non-blocking. calls main_loop();
X
X	main_loop() program sits here until exit.
X		Runs in a loop doing select().
X		calls do_serial_out() to set data to modem.
X		do_link_out() to queue packets.
X		update_time() to maintain 1/20th second clock.
X		do_serial_in() to build packets from raw serial.
X		
X
Xserial.c
X	do_serial_out(). Runs down the list of queued packets looking for
X		one to send. Picks the one that has been waiting the longest
X		for an ack.
X	do_serial_in(). a FSM, that builds packets from serial. Tries
X		to find a header, then uses header to get length of packet
X		and reads in that packet. calls get_serial() which may	
X		return -1 if there is nothing in serial in buffer.
X
X	do_ack(). Takes an outgoing packet of the queue. It has been acked.
X		
X	send_ack(). We correctly received a packet, so send an ack.
X
X	check_sum() is not a good one. Someone write a better one. :)
X
Xlink.c:
X	do_link_out(). Builds a packet if there is space on the queue.
X		calls get_data() to build the packets.
X
X	do_link_in(). Takes a packet of the in queue, uncompress it if
X		necessary, and gives it to put_data().
X
X	get_data(). Call get_client_byte until we have a full packet, or
X		have run out of data, and then (optionally) compress it.
X	
X	do_control(). Handle control messages. This routine handle only
X		remote control messages. I.e. messages sent from the other
X		end.
X
X	get_next_client() returns the struct for the next client ready to 
X		give data.
X
X	get_client_data returns the next byte from the client.
X
X	put_client_data() handles control messages calling do_control(), and
X		puts non-control data in client buffer.
X
X	
X	get_client_byte() returns the next bytes from the client. handles
X		local control messages. Handles stream switching. Yet another
X		finite state machine...
X
X	
X	put_data(). Put data to clients. Handles stream switching, switch
X		char escaping, and thats about it. calls put_client_data()
X		to send actual data or client control messages.
X
X	
X		
X
X	
XProtocols:
XClosing down.
X	state is 1 while running.
X	if an error on read or write occurs then state goes to 2.
X	then when buffer is empty, a C_CLOSE is sent, and state goes
X	to 3.
X
X	if a C_CLOSE is received, then state goes to 3.
X	
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/old/INTERNALS' &&
  chmod 0644 'term-2.2.5/old/INTERNALS' ||
  echo 'restore of term-2.2.5/old/INTERNALS failed'
  shar_count="`wc -c < 'term-2.2.5/old/INTERNALS'`"
  test 2313 -eq "$shar_count" ||
    echo "term-2.2.5/old/INTERNALS: original size 2313, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/old/PROTOCOL.seria ==============
if test -f 'term-2.2.5/old/PROTOCOL.seria' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/old/PROTOCOL.seria (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/old/PROTOCOL.seria (binary)'
  sed 's/^X//' << 'SHAR_EOF' > _sharuue.tmp &&
Xbegin 600 term-2.2.5/old/PROTOCOL.seria
XM1F%I<FQY('-I;7!L92X*"DET(&ES('-T<G5C='5R960@87,@82!S=')E86T@
XM;V8@<&%C:V5T<RX@4&%C:V5T(&9O<FUA="!I<PH*0V]N=')O;"!B>71E.@H)
XM:G5S="`G02<@*R!T:&4@='EP92X*3&5N9W1H(&)Y=&5S.@H)5&AE(&QE;F=T
XM:"!O9B!T:&4@9&%T82!I;B!T:&4@<&%C:V5T+@I086-K970@;G5M8F5R.@H)
XM4&%C:V5T<R!A<F4@;G5M8F5R960N(%1H92!P86-K970@=VEN9&]W(&ES('5P
XM('1O(#$V('!A8VME=',@;&]N9RX*"6%C8V]R9&EN9VQY('!A8VME="!N=6UB
XM97)S(')A;F=E(&9R;VT@,"`M+3X@,S(N($YO=&4@=&AA="!T:&5R90H)87)E
XM(#,@8FET<R!C=7)R96YT;'D@=6YU<V5D+B!4:&5R92!M87D@8F4@9&5F:6YE
XM9"!L871E<BX*0VAE8VMS=6TZ"@E*=7-T('1H92!S=6T@;V8@=&AE('!R979I
XM;W5S('1H<F5E(&)Y=&5S+@H*1&%T83H*"3`@;W(@;6]R92!B>71E<RX*"D1A
XM=&$@8VAE8VMS=6TZ"@DR(&)Y=&5S(&-O;G1A:6YI;F<@=&AE(&-H96-K<W5M
XM(&]F('1H92!D871A+@H*"@H*"@I!8VL@<&%C:V5T<R!A<F4@<V5N="!A<RXN
XM+@H*"2=!)R`K(&%C:PH)5&AE('!A8VME="!N=6UB97(@8F5I;F<@86-K960N
XM"@E4:&4@<W5M(&]F('1H92!P<F5V:6]U<R`R(&)Y=&5S"@E4:&4@<W5M(&]F
X6('1H92!P<F5V:6]U<R`S(&)Y=&5S+F]U
X`
Xend
SHAR_EOF
  echo 'uudecoding file term-2.2.5/old/PROTOCOL.seria' &&
  uudecode _sharuue.tmp < _sharuue.tmp && rm -f _sharuue.tmp &&
  $shar_touch -am 1028144694 'term-2.2.5/old/PROTOCOL.seria' &&
  chmod 0644 'term-2.2.5/old/PROTOCOL.seria' ||
  echo 'restore of term-2.2.5/old/PROTOCOL.seria failed'
  shar_count="`wc -c < 'term-2.2.5/old/PROTOCOL.seria'`"
  test 652 -eq "$shar_count" ||
    echo "term-2.2.5/old/PROTOCOL.seria: original size 652, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/old/PROTOCOL.unix ==============
if test -f 'term-2.2.5/old/PROTOCOL.unix' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/old/PROTOCOL.unix (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/old/PROTOCOL.unix (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/old/PROTOCOL.unix' &&
X#define SWITCH '@'.
X
Xthere are 4 kinds of commands defined.
X
X
XSWITCH, SWITCH   This just sends the SWITCH character through. Used to escape
X		the switch character.
X
XSWITCH, SWITCH+n Switch to the stream n. Streams are numbered from 1.
X
XSWITCH, SWITCH-1, "%s" , 0
X	Do the control sequence "%s" on the local end.
XSWITCH, SWITCH-2, "%s" , 0
X	Do the control sequence on the remote end.
XSWITCH, SWITCH-3, "%s", 0
X	Pass the control sequence through to the remote client. This is
X	how the results of commands are passed back to the client. A 
X	switch, switch-3 sequence is generated in the term server, and passed
X	to the client.
X
X"%s" is simply a string of non-zero bytes.  Brackets indicate optional items.
XLegal control sequences are.
X
XOption					Returns status?
X
XC_NAME "%s"				No
X       "<client name>"
X        Sets the name of this client to be '%s'.  Returned by C_STATS
X        Does not return success of failure.
X
XC_PUTENV "%s=%s"			No
X	 "<variable>=<value>"
X        Puts a variable into the environment.  This will be inherited by 
X        any C_EXEC commands.
X
XC_CLOSE "[%d]"				No
X	"[<client number>]"
X	Close the current client's file, or the client number specified's file.
X
XC_CLCLOSE "[%d]"			No
X          "[<client number>]"
X	Close the current client, or the client number specified.
X
XC_DUMB  				No
X	Downgrade clients status to dumb. All control message are now
X	ignored, and all switch characters become escaped. Only makes
X	sense as a local command.
X
XC_DUMP "%d"				No
X       "<count>"
X	Effectively makes term go dump for the next %d bytes. All command
X	bytes are ignored in the data stream until %d bytes have passed.
X	Measured from the first byte to be send after the C_DUMP command.
X	Sending 0 means to go dumb permanently.
X
X
XC_CHMOD "%s\n%o [%ld [%ld]]"		No
X        "<filename>\n<mode> [<access time> [<modify time>]]"
X	Changes the mode of a file, and optionally the access time and 
X        modification time.  Times are specified relative to the current
X        time.
X 
XC_SETPEERNAME "%d,%d,%d,%d,%d,%d"	No
X              ** cf. RFC 959
X	Changes the socket address that will be returned by C_GETPEERNAME.
X	This is usefull, if the connection has been redirected.
X
XC_OPEN "%s [%ld [%o]]"			Yes
X       "<filename> [<seek value> [<file mode>]]>"
X	To attach a O_RDWR|O_CREAT file to the file descriptor.
X	(only makes sense as a remote command).
X
XC_UPLOAD "%s [%ld [%o]]"		Yes
X       "<filename> [<seek value> [<file mode>]]>"
X	To attach a O_TRUNC|O_CREAT|O_TRUNC file to the file descriptor.
X	(only makes sense as a remote command).
X
XC_DOWNLOAD "%s [%ld [%o]]"		Yes
X       "<filename> [<seek value> [<file mode>]]>"
X	To attach a O_RDONLY file to the file descriptor.
X	(only makes sense as a remote command).
X
XC_STAT "%s"				"%ld %d %d %ld %ld %o"
X       "<filename>"			"<size> <type> <effective permissions>
X                                         <access time> <modification time>
X					 <file mode>"
X        Returns the given stats for the specified file.  <type> is 0 for
X        a file, 1 for a directory, and 2 for anything else.  <effective
X        permissions> are 4+2+1 for (rwx).  <access time> and <modification
X        time> is relative to the current time.
X
XC_UNLINK "%s"				Yes
X         "<filename>"
X	Unlinks the specified file.
X
XC_EXEC "%s\254%s\%s\254%s\254 ...\254\254" 	Yes
X       "<argv 0>\254<argv 1>\254<argv 2>\254...\254\254"
X	Forks and exec's the above command.
X
XC_PTYEXEC "%s\254%s...\254\254"		Yes
X          "<argv 0>\254<argv 1>\254<argv 2>\254...\254\254"
X	Same as C_EXEC, but opens a pty to execute it in first. This is how
X	remote shells are spawned.
X
XC_BIND "%u [%d]"			"%u"
X       "<port> [<backlog>]"		"<port>"
X        Binds the remote port %d.  If <backlog> is greater than 0, will
X        listen for <backlog> connections.  Otherwise you will need to use
X        C_LISTEN.  <backlog> defaults to 5.   See C_LISTEN.
X
XC_ACCEPT "%d"				"%d,%d,%d,%d,%d,%d"
X	 "<client>"			** cf. RFC 959
X	Tries to do an accept() on the socket indicated by the client
X	number. The number is the result of a C_BIND command.
X
XC_X_SERVER 				Yes
X	Tries to connect the display.
X
XC_SOCKET "%s"				Yes
X	Tries to open the unix domain socket with name "%s".
X
XC_PORT "[%s:]%d [%d]" 			Yes
X       "[<hostname>:]<port> [<old>]"
X	Tries to open a connection to <port> on the host specified.
X	<hostname> defaults to "remotehost".  If <old> is 0, the socket
X        will be closed and recreated, otherwise the existing socket will
X        be used.  <old> defaults to 0.
X
XC_LISTEN "%d %d"			No
X	"<client> <backlog>"
X	Listens to for connections on a bound socket. When a socket is ready
X	accept()'ing, a client number is written to the stream. This number
X	should be passed as a parameter to C_ACCEPT. It is acceptable to 
X	select() on the server socket until it is ready for reading. If it
X	is ready for reading, then the socket must be ready for accepting.
X
XC_PRIORITY "%d"				No
X           "<priority>"
X	Changes the client to the specified value.  Normally priorities range
X	from 20 to -20, with 20 allowed the most outgoing term traffic and -20
X	allowed the least.  The local priority is separate from the remote
X	priority.
X
XC_COMPRESS "%c" 			No
X           "<yes or no>"
X	Turns on and off compression respectively.  The any of 'y','c','Y','C',
X        '1' or '\01' means compress, and 'n', 'u', 'r', 'N', 'U', 'R', '0',
X        or '\0' means don't compress.
X
XC_STATS "%d"				Yes --> Varies
X	"<option>"
X	>= 0 to stat that client number.
X	-1 for a space separated list of active client numbers.
X	-2 , "%d %d", being the number of bytes fed to the compressor,
X		followed by the number of bytes output by the compressor.
X	-3 "%d %d", being the number of bytes read from the modem port,
X		followed by the number of bytes written to the modem port.
X	-4 "%d %d", being the number of packets in the input queue, followed
X		by the number of the packets in the output queue.
X	-5 "%d" being the baudrate term is operating at.
X	-6 being the client number of the client that asked for the C_STATS.
X
XC_SEEK "%d"				Yes
X       "<offset>"
X	lseek()s to that offset on the file descriptor.
X
XC_RESIZE "%d %d %d"			No
X         "<client> <columns> <rows>"
X	Sets the window size of <client> to be <columns>
X	wide by <rows> high.
X
XC_BINDN "%d"				"%d,%d,%d,%d,%d,%d"
X	"<port>"			** cf. RFC 959
X	binds a remote port selected by the system. It immediately writes
X	back to the stream the remote getsockname() information in the format
X	a,b,c,d,e,f (cf. RFC 959). Then it proceeds like C_BIND. 
X	(I've added this to support a non-passive termftp client for 
X	the benefit of firewalled people. -ot)
X
XC_GETSOCKNAME "[%d]"			"%d,%d,%d,%d,%d,%d"
X              "[<client>]"		** cf. RFC 959
X	Returns the socket name.
X
XC_GETPEERNAME "[%d]"			"%d,%d,%d,%d,%d,%d"
X              "[<%d>]"			** cf. RFC 959
X	Returns the peername.
X
XC_GETHOSTNAME "[%s]"			"%lx %s"
X              "[<hostname>]"		"<ip address> <proper hostname>"
X	Finds the <ip address> and <proper hostname> of the given host.
X	If no hostname is specified, it finds the <ip address> and 
X	<proper name> of the <hostname> returned with gethostname().
X
XC_BINDS					"%u"
X					"<port>"
X	Causes term to listen for a single connection from <port> instead
X	of the normal unix domain socket.  This only makes sense as a
X	local command, when the connecting socket must be tcpip instead
X	of unix domain.
X
XC_USOCK "%d %d"				Yes
X	"<client> <udp-type>"
X	Changes the udp-type of a socket.
X
XC_UBIND "%d %u"				Yes
X	"<client> <port>"
X	Binds the udp socket of <client> to the specified port.
X
XC_UDPSET "%d:%d,%d,%d,%d,%d,%d"		Yes
X         "<client>:<** cf. RFC 959>"
X	Sets the default address where the udp socket transmits its data.
X
XC_QUIT "%d"				Yes
X       "<option>"
X	Shutdown term.  If <option> is 1, it doesn't hangup the modem,
X	if 2, it will hangup, if -1 or not specified, performs the default
X	shutdown action.
X
X** cf. RFC 959		Is the socket address in the following format:
X   "<ip number with ","'s instead of "."'s>,<port/256>,<port%256>"
X
X
XThe very first data packet received may be of the form:
X
X  "VERSION %lu %lx %s"  == "VERSION <term version> <local address> <hostname>"
X
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/old/PROTOCOL.unix' &&
  chmod 0644 'term-2.2.5/old/PROTOCOL.unix' ||
  echo 'restore of term-2.2.5/old/PROTOCOL.unix failed'
  shar_count="`wc -c < 'term-2.2.5/old/PROTOCOL.unix'`"
  test 8113 -eq "$shar_count" ||
    echo "term-2.2.5/old/PROTOCOL.unix: original size 8113, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/patches/README.patches ==============
if test ! -d 'term-2.2.5/patches'; then
  echo 'x - creating directory term-2.2.5/patches'
  mkdir 'term-2.2.5/patches'
fi
if test -f 'term-2.2.5/patches/README.patches' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/patches/README.patches (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/patches/README.patches (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/patches/README.patches' &&
XThe patches in this directory have already been applied.  You can reverse
Xthem by the command:
X
X   gzip -c < patches/<patch-name> |patch -p1 -R 
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/patches/README.patches' &&
  chmod 0644 'term-2.2.5/patches/README.patches' ||
  echo 'restore of term-2.2.5/patches/README.patches failed'
  shar_count="`wc -c < 'term-2.2.5/patches/README.patches'`"
  test 146 -eq "$shar_count" ||
    echo "term-2.2.5/patches/README.patches: original size 146, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/patches/term-2.2.1.patch.gz ==============
if test -f 'term-2.2.5/patches/term-2.2.1.patch.gz' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/patches/term-2.2.1.patch.gz (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/patches/term-2.2.1.patch.gz (binary)'
  sed 's/^X//' << 'SHAR_EOF' > _sharuue.tmp &&
Xbegin 600 term-2.2.5/patches/term-2.2.1.patch.gz
XM'XL(`')II"X``ZT7_5/B2/9G\U>\8:Q;0A)(`'648TJ6<90]10_4<\NQ8B9T
XMH)>0I-*)H[.S__N]UTD@^+%[W!U4==+O^_7[ZAB&`4VS63>WK/W]=L,R&]8>
XM-)L'[9T#:U?1-`T2%B^,9KU9MQJ_I8M(+O7(B9V%6/'L@VD>M%H'[;9R>`A&
XM2V^#1LOAH0*?G,3IFH]F_E/@%Y20`RP).#Z_S/=MVAO7+!8\#+JH5=%*F[JE
XM&)O8VS_I#8^/QF^::>DMT"S]`YFI?>:/3$`2@M0*8,#`]]G4\8$'(HE3-T$K
XMP`O38()K#+-0)+8?AO,TJKL9P_AZU(9O3ASP8"K`]9D3L`D@7M'PCX(M,#Y*
XM^4#D_9D33)'`#0//YR@_F(+'?0:!LV"BGA'U)A,D^6G.?=_Q_9_(0/(P82*I
XM;W8:9\Z<D?@Z#]X^D2:>AB97"MU[&(8).X"!!T]A"JXT&)(9@X<L*O!>EYA%
XM*A*H+%`#Q,SQI>L5!:Z/1N/!^=`^Z_UR/H(N-$N@P3`'&1>]R_Z)?7IT?72*
XM+G?!+$##WMD12%#=5+3G9%8!*I%9*P7#JS,).\Q-M8-T@2XIT.]W#UWW4/K;
XM_M#6+1.T_$D^;VU71V<J-!+,]>WJ4AKJ4"7R=*B"(>`^^C:Y?XN*>W`+V]62
XMQ<@S3<"$.^C0^07P13&V`-R)%-&!I9$8^NXS@1V(73'AGH=,&C)5-^8"Y#)2
XM,.)[]AC%L**4@5'A2PVP$D$K8R@^ZGV]X%CW!:S[7.R]Q[$@MK?+IH#AA;X?
XM?@,C>8H8>&`$88(+H;[4](?U?7WZ'8PHYD%RGY_*#YA^YQ$8+GQ$S;U1_V1P
XM?:1BTTG<&5%W\H-8T:E_0DE6OAH0K+2=M8C`%L:W?Z&^*FJ[.A[U/PU&:D."
XMF&C4E^*9+[`LXI1UL(`)N%%A4OWS:1JS-\NRV=K5=T&C1U&8Y__04>.3;!CB
XM221L88B(N=SC+KI##0@;B'2[\KA]/JY@)3R"X8"!N3-DCTDOB@3<9:ZC#^?C
XM;H!016-^P70U'-S8X^L*O"/6@E0CTC3@C^)!0>5DRC%_8-CE7JHK>*0+>TWI
XMPEY;WY,N],/@@3V>CU42Z,H-=#H*G%P85S?J%D%G49K!!N.^"J4?XKAP":7E
XM5JHKLR2'`DPX+C[E.++V2'>K:>;'IX!(`]2!K:`R=5TP_H6]%=<@-/@BPE[,
XMDPIE@W3H<5O,?/Z5/$J#>1!^"PK'0"*Z3TQ0W*4YBI89(1WX?-H['G<KQB<:
XM#!4X'?Q,.U^$[IQA_ON!\"NYM2+TFQOR;)1C$S3;#YU)W7TSR?8^8&0TN=(9
XM`613#WY./8_%\%4^.H3`.1!#S4T3K(29#C7*07SXH>OX.A#PMKFS<Z?+Y*0J
XMEUO)BE4NS4+<A/"Q2#"/L4L@'X*%#KRC&`!I(/B4IJ>8A7$"OCL7*3+%\MFA
XM<;ND()'/\;DF61PL0!6_=4U4E_J^U-(U)8D?XL2-&:)CML!!9PO^'0V1?LCW
XM%=77)YRX,7,?T.HD3!"_@G0V"P4/7#^=X("?O1T*B_(55ZN5QR+SDF.=!U5.
XM#N&B=I:8+#V6F-?1D</C=1*YW-ZI\D`E)3GDQ>%"TF5QUNDUSP42Y$PF.;3$
XMAZ<\2<)-N:9H%&,QI4AFV$L&>,%!R`TXQ"Q-*/O+QU:21M<X*2TW&RCN=IDH
XM=A>3'%O3U_-2AX+K^9,8:RIU1SP8[M$+]R;,HSMBBW:`&QZP4FADCMBK?78A
XMV]G7K1V\DNW2!,A:?YY`\'?L^XV$TUUQ]A$1N2;%>)^I&MCC7\>XH[Z<:9M`
XMU>X-;E3X\:.`5&W[G\,;VUZ#??H5N^K%Y8U*W.OZ!/.9FY!"H_!M3<.*MRR0
XMFIE*=9TG"\G(`N)-;(&-K?;Z6QY=<O(!;^(U#$M);?Y$UPN'+P=G1Z\>479"
XM>0RNQD?V6)+*(]Z3P]5:3J;W<I[+("UCUI:U5"0-20R]B?-4?<5`;5EU?T%(
XM"HHTR(6N"5\CR(6M"94$TE8Y8:VVG+!6BS(F<Z3@)H^O>Z/>Z'B\S$EHU&!X
XM;E^/+T:#X>5GJ#6*'"+,P"9B`N),6TLH[7]**.WMA-**R&K_:4)I_X^$*JDM
XM*FB54(/AT>5:0CEQY&`+9UD);-+WUSX87VG]N]E=Q:0I+-=B"CL)WNE.D%O8
XM\CY=D^]X'QE>G9[*)H\W-^RB\BAF-HOC()07!'GOK4H>O,/U/DMO5/B=SNT5
XM#)WO.Z`N2C19OB/5.\`A/DUF*BCY]0M'9HKJ9A':D+?0KT^RB4KF;.ZL$M,R
XMLZ]*L_BL+'[2CUM^5Y]A!\N^'+H@.F\1.#YW!!.WYMT:V1^RK^!OP19N]%3]
XMVY*+1S89I#\3@R";1BD*T@M>D'T_]*K/F=6BHDO6Y"CZ5'V)?*$#R?+QH;XP
XM+7?B#_D!\7OAT9N.R"6/QM+__U;SAO='%!K,_R1QK>9^BU(W?Z[B3#G$\4MT
XMRI-JK1BWJKIRMW27DW>M>2D#YEVJ-6EQ=<G;@5789E%WF8*2:NGQ7"]B.E?U
XM9?8O`R992S7Y%XPZX`62"DXM)5[)PW>S"%V"E>7/I!?&ZZ9>2#3U7-Z_`30X
X&`$>%$P``
X`
Xend
SHAR_EOF
  echo 'uudecoding file term-2.2.5/patches/term-2.2.1.patch.gz' &&
  uudecode _sharuue.tmp < _sharuue.tmp && rm -f _sharuue.tmp &&
  $shar_touch -am 1018173494 'term-2.2.5/patches/term-2.2.1.patch.gz' &&
  chmod 0644 'term-2.2.5/patches/term-2.2.1.patch.gz' ||
  echo 'restore of term-2.2.5/patches/term-2.2.1.patch.gz failed'
  shar_count="`wc -c < 'term-2.2.5/patches/term-2.2.1.patch.gz'`"
  test 1941 -eq "$shar_count" ||
    echo "term-2.2.5/patches/term-2.2.1.patch.gz: original size 1941, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/patches/term-2.2.2.patch.gz ==============
if test -f 'term-2.2.5/patches/term-2.2.2.patch.gz' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/patches/term-2.2.2.patch.gz (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/patches/term-2.2.2.patch.gz (binary)'
  sed 's/^X//' << 'SHAR_EOF' > _sharuue.tmp &&
Xbegin 600 term-2.2.5/patches/term-2.2.2.patch.gz
XM'XL(`-<%I2X``Y5476_:0!!\KG_%*'G!`1N?(4J`$!DYD!`%4N6#5^MR'.!B
XMWR%_-$FK_O?>':00E*H-2(MV/3L[.W?&<1SXGN^2+Z35:M:)5R<M>%Z[T6@W
XMB%6M5E'P+'5\5WWKW\IT98*[HAE-\]T>0MI-KWU\:@4!G$:MB:H.06#A@A:T
XMZ[UXFX^%:\6P*1!3N+Q]V.1-G3L3GN6Q%%T]58G837W+^8SB\*HWONS??R#T
XMQ`@EM1-4==!"!_$+SU%(Z#$`'`R3A,]I@ECD15:R0JG`3)9BJF*&A<R+*)%R
XM6:Y<MFZXG]PU\4PS$8MY#I9P*O@4ZKGE6%4-"&66<5:HXBJ33PE/%8J6N<J?
XM7E$L.`:/%Y?]:-`+'V[O\+S@`F6NR""3J5DL8YC%"<]="Y822N"<;_6&"RKF
XMBHM),4MBI5<U:C0$377+I[P;T277S6XL_GK0Q*^=*@-UU`X>8BP+WL9PAE=9
XM@ADY9JWOZS/$8<T\2<N\P$&J)B#C-#%&'5B8]._NA[?C:-2[5MMWX>^4AN--
XMR?G:>PBOHIO^I'^CMNZ"O)7&O5$?IJ2OS3[,?ROMP'8&C!]'IA9LI$:B3`-M
XM<AAV`\:"SYF7TEBX[`/?6L8WGQQKX_0/(<8ZZ!.,9Z@8EB@6#&=J'.QMKE;P
XM.DJ1LP\\PE,BV3+*XQ\<]?=7Z`PI?8G8*K>A;^#^A'?8(U0V8,6RI;1M_-2]
XMP%)I>&ON:,'85?=?7!VLJ;001:=WLK&B;,F+J(A3+LM"457V*D=_YMB*;MG1
XM'+^LK6=3GM!7G*-I_F(4I%**/)[KER^18KXUT5ZK7N.[_\9WK-\<`0O%(@4`
X!`+^L
X`
Xend
SHAR_EOF
  echo 'uudecoding file term-2.2.5/patches/term-2.2.2.patch.gz' &&
  uudecode _sharuue.tmp < _sharuue.tmp && rm -f _sharuue.tmp &&
  $shar_touch -am 1019044194 'term-2.2.5/patches/term-2.2.2.patch.gz' &&
  chmod 0644 'term-2.2.5/patches/term-2.2.2.patch.gz' ||
  echo 'restore of term-2.2.5/patches/term-2.2.2.patch.gz failed'
  shar_count="`wc -c < 'term-2.2.5/patches/term-2.2.2.patch.gz'`"
  test 631 -eq "$shar_count" ||
    echo "term-2.2.5/patches/term-2.2.2.patch.gz: original size 631, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/patches/term-2.2.3.patch.gz ==============
if test -f 'term-2.2.5/patches/term-2.2.3.patch.gz' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/patches/term-2.2.3.patch.gz (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/patches/term-2.2.3.patch.gz (binary)'
  sed 's/^X//' << 'SHAR_EOF' > _sharuue.tmp &&
Xbegin 600 term-2.2.5/patches/term-2.2.3.patch.gz
XM'XL(`&H%J"X``]4\^U?:V-8_ZU^QRTQ;*($21/$Q>&N1.LRUZ!+L=%;;Q8IP
XMD-20\.7AX^NT?_O=>Y]S0L"@8G'=N9U9G.3D//;[E1,+A0*42^5B><7<VJJ\
XM-DNOS2TPS>U*:;M27LWG\Q`*?U3``<6UUV]/#]KQN+()YN:VN;Z]7EY]\P8*
XMFT9Y$_+X6X(W;U9!_K/=(!16WP#/!]<+X<KS+\`*P7*<(D!VWQ.!^S*$0(@1
XMA!Z<"3!+I>=Z=N`YE]:9(PPXBT*:Y@@KP-'>2$#/"D0`P="+G#[-TV.+N558
XM+0"LX?IM&DCPVP-;].%T_QC&OG?N6Z/``,>^$'`36LX%#"WW'.P!#Z6Y##D#
XMYD>N:^-#<2E<&"`2/<]U12^T/3<@@!VO9SE#+PB+>E[V3]MQ:)LSA.9&0X:[
XM7]GA$,*A`%=<X\*"<"%H"S2S@M!F'!N7'HK>10;Z2!@F&"XT%CXN%`K$?.!X
XM5P1"Z'L.](:6;_40YF`U+_']B144Q<TJ6&X?S"WB3F=H!P@VHA-:%X+)[KD"
XMK-&9C02(F`",G*;Y.L%`1.SZR/1L+L.+R9XKWPX%=>&:KA!]I`C14_-#LB-S
XM/;8=+\P4":/*\E93V&7;8=2_(7X2'XA'CAAIX#<4`:/KZ[[GC?*T3X8$((!1
XMU!M"@)03/LZTW.0X-<2[Q&?MP^8Q@[Z^K+4TX,V7ERCRD>\+-T16!B+$R8B[
XMP@&LP.ZCF@2VVQ-26.-%0"\RM9%-W/,8$&+CV+%NBD5-BBJ"7S^I`XM2P)0-
XMH['C67UF0=CWKER^(Y$([1%*VL"R';@:XL9$VH'M8)_EBUB;^@BXC;J"*W?\
XM&Y"K:4X$UDC.0>T'N1YK2V%P>6GPEG;(@JB7FU(O7!G*9&!&GB_D=&8",?34
XM[2,9#@EQ`XJOB0^L!BS5.+//^_>MT(*![XT4\#Z.4/B&'BU%_^C1E>\AR$&(
XM`CDB3(@%B@L,3L^*`A3%LQNP4`3/>FBWS@VX$+XK'+[6BR&TR/K(13N(%B04
XM_=<C.RC$=W!I^39;,\F03=RL*<VD9`>;P+'PQHXT<"^1G;[E!K@*FB;P<1'F
XM+<+4%SU?L+$DFFH*$IEH4;1]*"UHZ<X$\HZV)''H(_8V03(E92@@P):XB>9K
XM)$9GPH^70QA,LP)]NS_A*,XE!GLP(N-!UL8]YQX<[/?`&TLS*BTM::QS$Z_G
XMP5`X8T(?[OOWE@0#R;2()_L:C<;\4QQ;9#!2O-HZ>[4UHP)Y^B&?MH]R4BM=
XME]2_5?@#5U`=)G<<''74?87N"Q_0MB*2-=H5@4C>KBT&<?WWO=9!8[[[+1L;
XMD"\;IO:^!6@ZCCBW'/;!?L0^"V4G<J6I)*?5=3SO(AH7>W)"^\-)!:XLGSQ>
XM`#UT4"Z*8C0NRL=U#\U/CZ13R4.0D'=B^KO3_8-&]]U>O7-T(FU!%!"_/?30
XMBN=L&%@[D^O%:MGS1F,R`VH#.>Z=?8UC&#A4(40'?5<_ZFF7>MIJ?NRV/\#8
XM"GM#.8/U76F+C"I0R@D25`1G`CU/CUP;AWJ]"Q&2O[PR2%2;$.!#-']]J;!A
XM;`T0)?2`$/;&]EA-8R$M%TTH[`)Q61*+A!U!1%<[0%4*:7>V<*[%]FDAWK]'
XM]TN3B[:;PO\UYK]9-C#\XE\2@%^@Y85B&YH#N/$BJ7N"N70I91!^,?C)*$*Z
XM9T;DX(DZS/7,*GQHG+2;1ZWN^[T_D)DU*">ZFBW553C>Z]1_[QXV/C0.$>M$
XM5VOO?0.XB\1^=MB:[DH,6YMLT#I]SWUO%*A=-QJ](2+7Z[4WO=X;QG=KC?#%
XMWPV)+X9O&)QT>XY-_@!6),>*R+#^V!=]V\=+W88CS\4F&$;LRO#R<\H*H1^@
XM#7+PZ35%?=B2E>DTVIVCMW^T8:46RVW1PRB.8MIM.+-=^#5[V&S]NYTC%T!#
XM7)01B^`GD[8MM;7$["J72HI?JS1S&Z<>GQP=M-D/Z]6I5^^*X>+*K]EZ/:<V
XM>7>XAZ/QIG5TO'>0@X(W4:;$++P^PEC@+<[/3Y:=@,^K\=,'KYXR&9&@7@GO
XMR?M6H[/?.,ZI.PG'*J1MH-:=&JD774A1).^*O?GF?&/+J*)!YT;2'2B:Z@88
XM"HONR.N+;,G@F]P.`OOZ%6E0ACLX:`I"BAS0B(H>QC28V#31\6(<XJ$IX5$R
XM1,(PCF^*\.HU^31[D.6.6JU@YKZ14=$]4*L!]\F,9Q84D\#@)S7<IZO2CVX@
XM?%2.;-N0%WH0BG`6`O@-2I"#;PO2#BV5?1[Y8C[QRB83CQLB7A"YN945U,K,
XM>:\'A3]1`_#7]0KVB.('.T1#LK*"0'V"ZU^#(:H#:O5UY%Z@G77ARP[9(Q?X
XM0>U&!#MH(6%GAV2?K')PB8L?M5E&:IG"/GF`#)!4X)TC;2\4'#=P,C0K/V\.
XM%/:5C[AC-@H"IC+EA79<,.;`V-R)^FC\ARD4WF`*5TW#7(,\->LZBT9_AX8$
XMTV@WBY<&W2MVTQ,)5/PD_?'8LOWI(?SSZ0N.S.N1RA@F-]'/SD5(X0*YKBSE
XMC/"*4HW_%UT>A(:S+P;:#\=;HV^_I)B:%U2SZ%(&(PR9U>^KWB3(&)6'WJ*S
XM$,2QP#B;0&0,;D^`6S/HX0-F%.X@4>$A)-*#_-ZHKYZ^,M!$V.<48`5#S\?U
XM]*S9EB:^RL6\^(DUB%=(7'M`X4%\(;F'HKY&=Y@N#&Q7)`2'1;@[N9?11FF#
XM3(%9VM3^EZ!C^8;?@O,PO"D.=Y/;R+9`>J;DI=G=._QS[Z\VPQ!/#?NV1U,7
XMTJR19;NI1K\J0P5SW=C"6($;J572402?OGXI_E\D(K3"4-J9>4"\_%3ZDO8(
XMDP:*$<AR,W>3CY04%C'T[8Z1*VI4_MY1/VYODQQ%,ED,N`$9>G2Y^D0==P(Q
XML$8VYH'W@A&/4X"0+W(]]PQWN<@.^E)U?!%&O@M?\>;[8DS2D=`M/FUL8Z;$
XM0=$ZR13_RI!.245&N?5A1HF/2_+3.#IN'77:I\?'JX5?E-1.^A!9E/;;W3]*
XML3!.5L*']:-6"WOT!-63W(0]X-JZ@5#G5:L#"'*[;:02.=X<3%PQ=]:DZLRZ
XM[H)I2,62#CPGYWZ3"7`X&G>%[[O>A&O3G8I%R*2QC\H]R/):^-3S#<AT*)A:
XMVX;G0<:@G&J$(4G7%T'D:`,(/(TF9.,(0['V_=[';OVPV6AUVOS@^P3';%"+
XM*P,:'T*$T%PF!HS`=J+6RN4ET9<8+1,ANT;NIJN6S`8&U+OMSEZG;8")A'S>
XM1P(6-IX`-[4-+OXXW'J.%XAL@+<LE^M;'#BH-BF7LR@2KPC+T_91_=\&E!A+
XM8$2EFAG)BDOV=/^XV^FV&ZW]=N>D>?S[_@G\#;+SI%'?V]_'GMR3T(<!I$(3
XMYK$(WQ29-(@*X@=2[;MP,'E_`%',^41)$*1Y@'EPXXGQ9Q._!/192JI5P]Q`
XM*9%M4DJFW0GE),T6,O>DN]?Z*T?!37=Z!(9`V,=7&;-<+9;P/S.3DWO?2>&W
XMS=9^*H61@$]"1MKP,3IVO[0<-#K$(RIB),R%1.=)<$EL^',8/<L2Z[JV6\O.
XM1+W8AY$B=G9#KZL[L],;*/D;AI[KS$A.CG1A*3C7+:H*<U';X6JVS+YH$Q$$
XM"UI+6X%`6E`QJQ1FR(9T0`;)TAF'/F]/$3X0F-&(T"%5XT&!#(QJ\3@U9D?F
XM^$A8J@^RKL#??ZL5X!EG^-H=!3LR_9\_^$<I.5@IE#2$VNMJX5)^+OFHIA>-
XMY?7X].UALQX7$D+/%\Q:VQUXY+[Q_];IX:&R$I4RETAD0_1Y_4J^Z!CB6O1:
XMA^FKZ_AH!H!)$8`U"(7,%A3T`5<_T,9<>K8L\G;'DFR2FB-DI'4NE,"D4\33
XMU/LVGVJ>)IJBA]I$+S\5#:@(@!%=DX*PI@5AN;3D?1"O&168$7Z)T43P,>%X
XM(!Z,0G6#_;YJ-1+(L2,70WEOK-[')2(IC]X0T@L`2UFJ9\PD@)DP-GZ#/WA\
XM&#O'!LRQ`G<%LY4[@]E4G8_COV1IH&U0PS^.</70[QK_[#P[?]QHG$@[7])V
XM7G/]D_VEJ&S^\I&?VORI:$"2M*Y*3ZJ5DO0H.4J1HO]Z+F0^,A?ZJA,&B</]
XM4<"#I>,GL9K:=ALXE`*%9#MM]T?A3H*Q44&!J$!>M4\D&(CP?T<TB&:2;%2^
XM6XA*4_Y8%XEB\I$7>)CT_'[4[B2D1\-"^KE\F=&;/5(A)%9<JE8I9_5VROF/
XM*X5L/1);VN]N#M:[A\UVI]$R2H;.9V+=NXAU[\SJ73C>>6[Y&8'<'5[RWB\5
XMFBD0@`)ADCH^,&?<K)0I2)*-CB]LJEC6W-`;!ED24TP:"KNZDIG;64WR/:AQ
XM=6C9KE%1H.6%VO;P:326H,P]/E'O@+OQI<)TG=]NR4:+\QUE(I7))@HHR<))
XM&@^8;,L/D>:FNJ#@2LW>[@9R#@$EG;8DG;82$A$'JYGD:Y5<S(GYR;2DY?YQ
XMN]&)RP+;R2)'&I!QMDI):NAG7]"-49HMQ"PM_MR.87Q`WITJ=3+EV-Q:-TPZ
XM)2M;3;WOTQJ#0-TNL[;3JJQ+1'#QT%(GU0]A\+TUU:6R:H'2:CJS")EOTU6V
XMFA5Z=G;>(NF(U[ML(R:^@97+F!2Z0",_%_VY!+C;%#RPZ#67MY*=W^3KLXTM
XMHXR>7K52:!-%]%A!OVH%I7R<R:4,WA)=WEZO)\8AT&G)$1WX(AN'NZ4:C!@>
XM(VG3[B@/S<@Q!:6INO@$KSQ4I%)=+%+Y6:U;2@#]<Z\RDKHV4TY!'-*4+E%@
XMD>6)--3WZO7&<2<M(8NE(I?[K91[`C<LMY9)69"(!R?BN+@I4N_<2QQRZPOM
XM/B8N8LI91OTQ5^CE001OD$U[F$L>'6+7,Q6NQ>9-8MH7=`)SMS9EN)=KNQ(1
XMG>`#EWQV_GZ#M5"<44J),^+7*;>BB_^1X,(LT7L=D^1#7DR"LT>6\9(![92W
XME^)B*TF(K>6#HY8EB8PRFIOW1"]W^KC4%SP/#%F6BL;"@<N=:"F)V*K(8SK<
XM)C[+XJKS*YOJ#`DUG_/J#N.8XZ.33B*.D:F?>E^42/VF4B"@@]^YW"S)[B#:
XM'62[V^02>)0$OU0UL`?"-Y^R:8F/:98X%U;MA)HZ6'HX%8-MC@:YY/0/I26!
XMJ,FY$*`+$G5M71)5MBJX5)J9?8;FMS<:9X,Q[M?ELG7F:NAE<OJ\K*]VJV5\
XMZD]&%$L(.9_SUSWT$1T=^/4Q//'DQPYD=6Y$6$3O'D/VL'*2Q!G]-^/,;7P,
XM.2Z"9O?>=9LM<E14XD6K<-+8>T\OR">OUR>#9TUY,&O)EQNA;BQ:2TN^>S77
XMJHK;U?(M@Z0JJKRE_DCA-S#-JEF!*2/URB)YQ&431P]2K/IM]Y]:;,U\+F6>
XMS+!/[3EEU1?U5O/0EF3=W))DW4P695A,:_3N1[B7V0R=K<\DPSV0#ARF`KW'
XM)_#_8&^H`NB**?5.MLGP"&*"&2\_KU6K+PU);0.%,D)5,K2A26[X?6?:Y-NW
XM"/(4]KGQL5&_AQ)S14BBV)T^/&96JC)*D.T_NI*_MV!^O-@15?7-T/P3JJAX
XM3"ELS+(2('2(E"B<18,!4N"%;&-C34>GZ!3\S',NDJM##UFEIW-)"JDTU>?N
XM^:M>(N;4,G>XD/POI!.)&<P,=2@V_Q"86$_2H6(^#!3_@A"]9BRZSX//[ES6
XMB6L[?"37^EX7:7"1RK9R?*1E4QYIV8R_%I-'?3$P^ZO](0<O7L`SW;/_5ZOY
XM\;CSD5]2JO-141B0DZ=/=D<[D_/L`/N-MZ<'W7?'&EER*ML(DO[&'IV8*HH]
XM[V.^N<TT2)#.6"VL`.6>A5TWHD]JD4+RTXO[5L;H)&WQU?S*U/J0Y=-9.?@7
XM9/@J@U%=1CI;/JXVO;$,1?CKQVQO<AJ%_MP"&A]^=:A40;XO46TB&M87ND5C
XM(>L/7&_8B3\)1S&;"B;5^?/D>9][QOTHW4I>+F`W+G?<.MF&8LIOFN<^3YC*
XMD1CUQC?9]/-Q\GT#J`X#+M*RRN29"_2A:LZ+27&%R;AN5NGC!-7JKQ,*NY//
XM$E9TU^T/$@J[M[]$P+Z[/D%(?_PCL>*"'QW,S+C]M<&\`8D34#1HT$?631@J
XM?91\,#GTS,,2\>1&108^LI74"T(KM'ORBYV0C@XBO3A'H3^\8<#(NN;E"'HU
XME(^C*;7Z5%Y?_\*0ISW$U*_R92=A%^I2_5[U'(D,7MND1`Q=%1TJ%^SHHER9
XMB7=M=1!B9?IM,RC8&&&U+4&>SQ/G[9VD7O"?$MD%A&HMH3&*II'OJX]9)7&Y
XM5J/(.OTL%R^JPZ5XI;L@^*XOZ"N_%?6M9"C_)@(?WAP*^OX'O`%?TBD0-4X=
XM::,_C2#&<.[9[GFQ&)]#4^0ATISYPKI0OI+^3<Q?%OUB`@TT<Y';E><*<QKJ
XMW(.(]>?>2:O9.I@RL_+8M7)5$%S8XS%][$E_,L/QW/-M^)QY7EPK!<5B\7-&
XL6EU(_)NRO[>`N47DQV*%#(BKBTK2R[$,:=+Q0#JQ(XTZ4?D_,Y3_E_5'``!&
X`
Xend
SHAR_EOF
  echo 'uudecoding file term-2.2.5/patches/term-2.2.3.patch.gz' &&
  uudecode _sharuue.tmp < _sharuue.tmp && rm -f _sharuue.tmp &&
  $shar_touch -am 1021111694 'term-2.2.5/patches/term-2.2.3.patch.gz' &&
  chmod 0644 'term-2.2.5/patches/term-2.2.3.patch.gz' ||
  echo 'restore of term-2.2.5/patches/term-2.2.3.patch.gz failed'
  shar_count="`wc -c < 'term-2.2.5/patches/term-2.2.3.patch.gz'`"
  test 4859 -eq "$shar_count" ||
    echo "term-2.2.5/patches/term-2.2.3.patch.gz: original size 4859, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/patches/term-2.2.4.patch.gz ==============
if test -f 'term-2.2.5/patches/term-2.2.4.patch.gz' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/patches/term-2.2.4.patch.gz (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/patches/term-2.2.4.patch.gz (binary)'
  sed 's/^X//' << 'SHAR_EOF' > _sharuue.tmp &&
Xbegin 600 term-2.2.5/patches/term-2.2.4.patch.gz
XM'XL(`%,?JRX``ZU666_:2A1^CG_%22M%.%Z"#3<;EPJ$:,-50JILNE(4(6,&
XM/,%X+,^X*;=*?WO/>&<)MY'*`X8S9_G.]HT-PP"[;IN-/>OLK'EDU8]L"ZS3
XM<^NO\X:M:)H&@D0+PS9MLWG4N^@.O_1O2]4FU.WS9N/<LI1.!XQC_1BT8_T$
XM.AT%``SX3+^3"=P^W#1A',^`!B)BD]A%V0L5'MP/!_^.;A\@=(3KI1:7-(B_
XM`R=DP4$P&!/PG&\TF$%$'!_"B(U]>928QP%%5>;.B>`0L!<=_\``.!ZZ'IE(
XMAP`B#GWF3*2SF!-P0+@A#3,S4]%DT!Z+(N(*A.4Q+D8^8_,X3"+ZS`4212PR
XM`;XRQ(\Z+!8P7@)<<TZA"W>QSP(2F`HH8)L6&)_P8:?9]#PGF*&)RX*I3UTA
XM$YE2GT#@+`@W%>,]U;]RYD0:FS1XLP.6K9^"EGS+'GR$(1/D'`936+(8W`0.
XM"(_`-Q)QR@+XJ"<GBY@+^+#`"$G:KD^<X(,"#_V;V\'U<'35_>?Z!MI@5T2#
XM828ROG;O>A>CR_Y#_Q*S;D,C%PV[5WU(1&9#T=;5FKFHHM8L`PSOKQ)9)X,Z
XM"N)%1Q:YUVMW7+?SON)5&FNZ6\IWG)2O:>G6&6CR<9H-,<"4137:KK<H_`V(
XM821=\19H&E4AU0"@4ZA=2/DC?3(];GHCV6$X.,")>H%V&\I#]J+"C]PNM=P'
XM+B)W$=:<R232-_VH*HRQ+?.68NQ)-,]8EGH+5A4=GSJ<\,?GIQ8\:YH,HNVE
XMWK<JJG(J<2)CTI);`$6NO^>]S.#_<RB-52A3R:U?5XOQMFEF6#5[)3XN=5[/
XMG9TRW@R!@$<^Q05XNUV[ZIZ;5RM?)`?(4IS.`B0!I(D9^*WJV8(LW'!9._#7
XM"U;QB:Q&_R-L6O-5M>C42A8T3`Q@OPT_ZSN2*+J<]DL&S_MUL.Y,]TDP$UXY
XM>6_,4@YT99K>5:S-0:H"VU&7=82_.5`5%]M'*F&"DQ-YEYT<ZSD/;'H1RY!@
XMCMW/H\&P?]?:5$HHH`W#^\O+M5/9']FEI)\;?91M7#VIKD+58UJO*J6DDJPT
XM16V]$*UF1,B%&"\EKJ2Z.$\RUS-+MS'9,UNW3@K6P[LB@L.5:%5`([P5`R:S
XM2']M*$C$*0Q4RB9X9174K&,2\?:E1\-:"N-0721W<<T^S%RE<A4_Q6;CV'`B
XMMKO2Z_J&Z8[X!2/\"02YL^T8MG3M1_56J57*D&-`ID7=M(6:+1%4+A1)P\@I
XM7,\Z7!X\9G9<U:RG9#O+PZV3RRM+M9V6ZT^I6K%`QIIV.=/UUL;AVD(FSO)4
XM-Q@I"Y(R?I%OSJ`;_%4EL3\4.7U$1,114&X%YKRZW,5JU+=P0K$27FA\RO\6
XMNYP*"W+9+]A%S<-Z8;JS5J.)[]GXIB??N?.=W=FERAJ_%KCWC@[Q[3=<)N^$
XHR<2S*<CXA,L%/#Q2$@Z1?#YO/^/5"B7$DL<U[5E5?@&0YZ^T2@P``#=<
X`
Xend
SHAR_EOF
  echo 'uudecoding file term-2.2.5/patches/term-2.2.4.patch.gz' &&
  uudecode _sharuue.tmp < _sharuue.tmp && rm -f _sharuue.tmp &&
  $shar_touch -am 1023194394 'term-2.2.5/patches/term-2.2.4.patch.gz' &&
  chmod 0644 'term-2.2.5/patches/term-2.2.4.patch.gz' ||
  echo 'restore of term-2.2.5/patches/term-2.2.4.patch.gz failed'
  shar_count="`wc -c < 'term-2.2.5/patches/term-2.2.4.patch.gz'`"
  test 1120 -eq "$shar_count" ||
    echo "term-2.2.5/patches/term-2.2.4.patch.gz: original size 1120, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/pty.c ==============
if test -f 'term-2.2.5/pty.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/pty.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/pty.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/pty.c' &&
X#define I_IOCTL
X#define I_ERRNO
X#define I_STRING
X#define I_SYS
X#define I_STAT
X#define I_SIGNAL
X#define I_STRING
X#define I_PTY
X#define I_LIMITS
X#define I_STROPT
X#define I_PROCESS
X#include "includes.h"
X
X#include "debug.h"
X
X#ifdef SYSV
X#if defined(SVR4) || defined(SCO)
Xint grantpt(int);
Xchar *ptsname(int);
Xint unlockpt(int);
X#endif
X#endif
X
Xint pty_pid;
X
X/*
X * This area heavily modified to use Dynix/PTX ptys
X * basically just dropped in a replacement open_pty command
X * Barry Boone (boone@a.cs.okstate.edu), June 4, 1994
X * Note that *prog is ignored... the shell is determined by SHELL if present,
X * or uses /bin/sh
X */
X
X
X/* I've tried to make things more readable.  Hopefully I didn't invent
X * too many new errors in the process.  First you have about 5 different
X * versions of getpseudotty.  You need to figure out which will work or
X * write your own to add to the list...  Maybe if you are really lucky
X * your system already has this.  Then the terminal settings in open_pty
X * will probably need some OS specific command.  But without this you should
X * get some type of result still to tell you that the getpseudotty is working.
X */
X
X
X#ifdef SYSV
X#define HAS_PSEUDO
X#define MASTERLINE "/dev/ptmx"
Xint getpseudotty(char **Slaveline, char **Masterline)
X{
X  int masterfd = -1;
X  void (*savesig)(int);
X
X  *Masterline = MASTERLINE;
X
X  if ((masterfd = open(*Masterline, O_RDWR, 0)) < 0)
X    return -1;
X  savesig = signal(SIGCHLD, SIG_DFL);
X  if (grantpt(masterfd) < 0) {
X    close(masterfd);
X    sigset(SIGCHLD, savesig);
X    return -1;
X  }
X  sigset(SIGCHLD, savesig);
X  if (unlockpt(masterfd) < 0) {
X    close(masterfd);
X    return -1;
X  }
X  *Slaveline = ptsname(masterfd);
X  if (*Slaveline == NULL) {
X    close(masterfd);
X    return -1;
X  }
X  return masterfd;
X}
X#endif
X
X#ifdef _AIX
X#define HAS_PSEUDO
X#define MASTERLINE "/dev/ptc"
X
Xint getpseudotty(char **Slaveline, char **Masterline)
X{
X  int masterfd = -1;
X
X  *Masterline = MASTERLINE;
X
X  if ( (masterfd=open(*Masterline,O_RDWR,0600)) < 0 )
X      return -1; /* No ptys available */
X  *Slaveline = ttyname(masterfd);
X  if(masterfd < 0) return -1;
X  return masterfd;
X}
X#endif
X
X#ifdef sgi
X# define HAS_PSEUDO
Xint getpseudotty(char **Slaveline, char **Masterline)
X{
X  int masterfd = -1;
X
X  *Masterline = NULL;
X  *Slaveline = _getpty(&masterfd, O_RDWR, 0600, 0);
X  
X  if (*Slaveline == NULL)
X    return -1; /* no ptys available */
X  
X  /* Don't check slave - have to assume it's going to work */
X  if(masterfd < 0) return -1;
X  return masterfd;
X}
X#endif /* sgi */
X
X
X
X#ifdef USE_TTYNAME
X#define HAS_PSEUDO
X#define MASTERLINE "/dev/ptyX-"
X#define FIRST "pqrstuvwxyz"
X
Xint getpseudotty(char **Slaveline, char **Masterline)
X{
X  int masterfd = -1, slavefd = -1, j;
X  char *first=FIRST;
X  static char masterline[sizeof(MASTERLINE)];
X
X  *Masterline = strcpy(masterline,MASTERLINE);
X
X#define MFIRST  (sizeof (MASTERLINE) - 3)
X
X  for (j = 0; first[j]; ++j) {
X     masterline[MFIRST] = first[j];
X     if ((masterfd = open(masterline, O_RDWR)) >= 0) {
X         basename(*Slaveline = (char *)ttyname(masterfd))[0] = 't';
X         if ((slavefd = open(*Slaveline, O_RDWR)) >= 0) {
X             close(slavefd);
X             break;
X         }
X         close(masterfd);
X     }
X  }
X
X  if(masterfd < 0) return -1;
X  return masterfd;
X}
X#endif /* USE_TTYNAME */
X
X
X	/* Here is the routine, as complicated as it is... */
X
X#ifndef HAS_PSEUDO
X
X#ifdef __hpux
X#define MASTERLINE "/dev/ptym/ptyXY"
X#define SLAVELINE "/dev/pty/ttyXY"
X#define FIRST "pqrstuv"
X#define SECOND "0123456789abcde"
X#else
X#define MASTERLINE "/dev/ptyXY"
X#define SLAVELINE "/dev/ttyXY"
X#define SECOND "0123456789abcdef"
X#ifdef convex
X#define FIRST "pqrstonmlkjihgfe"
X#else
X#define FIRST "pqrstuvwxyz"
X#endif
X#endif
X
Xint getpseudotty(char **Slaveline, char **Masterline)
X{
X  int masterfd = -1, slavefd = -1;
X  int i, j;
X  char *first = FIRST;
X  char *second = SECOND;
X  static char masterline[sizeof(MASTERLINE)];
X  static char slaveline[sizeof(SLAVELINE)];
X
X#define SFIRST  (sizeof (SLAVELINE) - 3)
X#define SSECOND (sizeof (SLAVELINE) - 2)
X
X                                /* Ok. Stuff for not sgi. */
X#define MFIRST  (sizeof (MASTERLINE) - 3)
X#define MSECOND (sizeof (MASTERLINE) - 2)
X
X  *Masterline = strcpy(masterline,MASTERLINE);
X  *Slaveline = strcpy(slaveline,SLAVELINE);
X
X  /* get a pseudo tty */
X  for (j = 0; first[j]; ++j) {
X    struct stat statbuff;
X    
X    masterline[MFIRST] = first[j];
X    masterline[MSECOND] = '0';
X    
X    if (stat (masterline, &statbuff) < 0)
X      continue; /* no ptys on this bank available */
X
X    for (i=0; second[i]; ++i) {
X      for (; second[i]; ++i) {
X        masterline[MSECOND] = second[i];
X        if ((masterfd = open (masterline, O_RDWR, 0)) >= 0)
X          break;
X      }
X      if (! second[i]) break;
X
X                                /* Ok. now check to make sure we can */
X                                /* open the slave as well. */
X      slaveline[SFIRST] = masterline[MFIRST];
X      slaveline[SSECOND] = masterline[MSECOND];
X
X      if ((slavefd = open (slaveline, O_RDWR, 0)) >= 0) break;
X      perror("Term: Slave tty");
X      close(masterfd);
X    };
X    if (second[i]) break;
X  }
X
X  if (! first[j])
X    return -1;
X  
X  DEBUG_FP(stderr, "%s: opened pty master=%s(%u) slave=%s(%u)\n",
X              term_server, masterline, masterfd, slaveline, slavefd);
X
X#ifdef SUIDROOT
X  if (fchmod (slavefd, 0622))
X    return -2;
X#endif
X  
X  close(slavefd);
X
X  if(masterfd < 0) return -1;
X  return masterfd;
X}
X#endif /* HAS_PSEUDO */
X
X
X	/* OK, this routine does opens a pty and runs a command in it.  */
X	/* I've tried to make it more readable, but it is still a bitch. */
X
Xint open_pty(char *prog)
X{
X  int masterfd = -1, slavefd = -1, i, pid;
X  char *slaveline=NULL, *masterline=NULL;
X#if !defined(DYNIXPTX) && !defined(USE_SPAWN)
X  int pip[2];
X#endif
X
X	/* Here is where we get the tty */
X
X  if ( (masterfd = getpseudotty(&slaveline, &masterline) ) < 0)
X    return -1;
X
X	/* Next we open some sort of pipe so we know if we are successful */
X
X  fflush (stdout);
X
X#if defined(DYNIXPTX) || !defined(USE_SPAWN)
X  if (pipe(pip) < 0) 	/* This is only for debugging purposes */
X      pip[0] = pip[1] = -1;
X#endif
X
X  /* Now we fork, and save the parent some work. */
X
X#ifndef USE_SPAWN
X  if ((pid = fork()) < 0) {
X    perror("Term: fork");
X    return -3;
X  }
X  if (! pid) {
X#else
X  { char iov[10];
X#endif
X    char **a, *b[2];
X    char argv0[PATH_MAX];
X    char *progname=NULL;
X    int loginshell=0;
X
X    b[0]=b[1]=NULL;
X
X#ifndef USE_SPAWN
X    close(0);
X    close(1);
X    close(2);
X#ifndef DYNIXPTX
X    lose_ctty();
X#else
X    setpgrp();
X#endif    
X#endif
X
X	/* make it control tty */
X    if ((slavefd = open (slaveline, O_RDWR, 0)) < 0) exit(1);
X
X	/* I don't understand this but I'll leave it */
X#if defined(USE_VHANGUP) && !defined(USE_SPAWN)
X    signal (SIGHUP, SIG_IGN);
X    vhangup ();
X    signal (SIGHUP, SIG_DFL);
X    
X    if ((slavefd = open (slaveline, O_RDWR, 0)) < 0) exit(1);
X#endif
X
X#ifdef USE_TIOCSCTTY
X    ioctl(slavefd, TIOCSCTTY, 0);
X#endif
X
X#ifdef SYSV
X    if (ioctl(slavefd, I_PUSH, "ptem") < 0) {
X      exit(1);
X    }
X    if (ioctl(slavefd, I_PUSH, "ldterm") < 0) {
X      exit(1);
X    }
X#ifdef SVR4
X    if (ioctl(slavefd, I_PUSH, "ttcompat") < 0) {
X      exit(1);
X    }
X#endif /* SVR4 */
X#endif /* SYSV */
X
X
X	/* Set up input and output */
X	/* Let's close things down before doing the exec */
X	/* Here we reset/set the terminal */
X#ifndef USE_SPAWN
X    dup2 (slavefd, 0);
X    dup2 (slavefd, 1);
X    dup2 (slavefd, 2);  
X    if (slavefd > 2) close(slavefd);
X
X#ifdef DYNIXPTX
X    for (i = 3; i < 256; i++)
X      fcntl(i,F_SETFD,1);
X
X    terminal_restore(0,0);
X#else /* DYNIXPTX */
X    for (i = 3; i < 256; ++i) 
X      if (i != pip[1])  close(i);
X    if (pip[1] >= 0) if (fcntl (pip[1], F_SETFD, 1) == -1) {
X      if (pip[1] >= 0) close (pip[1]);
X      if (pip[0] >= 0) close (pip[0]);
X      pip[0] = pip[1] = -1;
X    }
X#if !(defined(SVR4)) && !(defined(__hpux)) && !defined(DYNIXPTX)
X    terminal_new(0); 
X#endif
X#endif /* DYNIXPTX */
X#else /* USE_SPAWN */
X    iov[0] = iov[1] = iov[2] = slavefd;
X    iov[3] = iov[4] = iov[5] = iov[6] = iov[7] = iov[8] = iov[9] = -1;
X
X    for (i = 0; i < 10; i++)	 /* changed */
X      fcntl(i,F_SETFD,FD_CLOEXEC);
X
X    terminal_new(slavefd);
X#endif /* USE_SPAWN */
X
X	/* Lets build the exec() arguments */
X
X  /* find out what shell to run. */
X    a = rebuild_arg(prog);
X    if ( !a )
X      a = b;
X    else if ( !a[0] )
X      a = b;
X    else {
X      while(strchr(a[0],'=') != NULL && ! strncmp(a[0],"-D",2)) {
X        term_putenv(&a[0][2]);
X        a = &a[1];
X        if ( !a[0] ) break;
X      };
X      if ( !a[0] ) 
X        a = b;
X      else if ( !*a[0] )
X        a = b;
X    }
X
X    if(!rshtype) {
X      if ( !a[0] )  { a[0] = getenv("SHELL"); loginshell=1; }
X      if ( !a[0] )  a[0] = "/bin/sh";
X      progname = a[0];
X      if (loginshell) {
X        sprintf(argv0, "-%s", strrchr(a[0], '/') ?
X               (char*)(strrchr(a[0], '/') + 1 ) : (char*) a[0]);
X        a[0] = argv0;
X      }
X    }
X#ifndef DYNIXPT
X    else {
X      if ( !a[0] ) { a[0] = getenv("SHELL"); loginshell=1; }
X      if ( !a[0] ) a[0] = "/bin/sh";
X    }
X#endif
X
X	/* OK, now just a few misc. things before executing */
X
X#if !defined(hcx)
X     /*  If the strings are too long, the printfs blocks on hcx ! */
X    printf ("Remote: term %s\r\n", str_version(VERSION));
X    printf ("tty %s. exec %s\r\n", slaveline, a[0]);
X#endif
X	/* Finally we can execute */
X
X    setgid(getgid());
X    setuid(getuid());
X#ifndef USE_SPAWN
X#ifdef DYNIXPTX
X    execl(progname, progname, NULL);
X#endif
X#if !defined(USE_SPAWN) && !defined(DYNIXPTX)
X    execvp(rshtype ? a[0] : progname, a);
X
X   /* write something so parent notes exec failure */
X    write(pip[1],"",1);
X    close(pip[1]);
X#endif
X    /* for what it's worth */
X    printf ("Exec failed %s\r\n", a[0]);
X    exit(1);
X#else /* USE_SPAWN */
X    pid = qnx_spawn(0, 0, 0, -1, -1, _SPAWN_SETSID|_SPAWN_TCSETPGRP,
X                rshtype ? a[0] : progname, a, environ, iov, 0);
X    setgid(0);
X    setuid(0);
X
X    if (pid == -1) {	/* for what it's worth */
X      DEBUG_FP(stderr,"%s:exec failed %s\r\n", term_server, a[0]);
X      close(masterfd);
X      return -1;
X    }
X    DEBUG_FP (stderr, "%s:exec succeeded\n", term_server);
X#endif /* USE_SPAWN */
X  }
X
X	/* Now get the status of the process and get out of here! */
X
X  if (slavefd >= 0) close(slavefd);
X  set_nonblock(masterfd);
X  pty_pid = pid;
X
X#if !defined(__QNX__) && !defined(DYNIXPTX)
X  if (pip[1] > 0) close(pip[1]);
X
X  if (pip[0] > 0) {	/* Wait for exec or pipe is closed */
X    if (read(pip[0], (char *) &i, 1) == 0)
X      DEBUG_FP (stderr, "%s:exec apparently succeeded\n", term_server);
X    else
X      DEBUG_FP (stderr, "%s:exec apparently failed\n", term_server);
X    close(pip[0]);
X  }
X#endif
X
X  return masterfd;
X}
X
X
X
Xstatic char *argv[4] = {"/bin/sh", "-c", "rlogin localhost", NULL};
X
X/* non-pty exec */
X/* usage is more like rsh, shell can handle compound command */
Xint open_socket(char *prog) 
X{
X  int i=0,j=0;
X  int soc[2];
X  int pid;
X  int pip[2];
X
X  if (S_Pipe(soc) < 0)
X	return -4;	/* no stream pipe */
X
X  /* soc[0] is term's end */
X  set_nonblock(soc[0]);
X
X  pipe(pip);
X  if ((pid = fork ()) < 0)
X    return -3; /* unable to fork */
X  
X  if (pid == 0) /* child. */
X  { 
X    close (0);
X    close (1);
X    close (2);
X    close (pip[0]);
X
X    lose_ctty();
X
X    /* soc[1] is child's end */
X    dup2 (soc[1], 0);
X    dup2 (soc[1], 1);
X    dup2 (soc[1], 2);
X    for (i = 3; i < 64;++i)
X      if (i != pip[1])
X	close(i);
X    
X    setbuf(stdout, NULL);
X    
X    if(prog[0] != '\0'){
X
X      /* unpack args */
X
X      for (j = 0; prog[j] == '-' && prog[j+1] == 'D'; j = i + 1) {
X        char e[256];
X
X        for (i=j+2; prog[i] != '\0' && prog[i] != '\377'; ++i);
X        strncpy(e,&prog[j+2],256);
X        e[i-j-2] = '\0'; 
X        if(! strchr(e,'=')) break;
X        term_putenv(e);
X      }
X
X      for (i=j; prog[i] != '\0'; ++i)
X        if (prog[i] == '\377')
X  	  prog[i] = ' ';
X
X      argv[2] = &prog[j];
X    };
X
X    /* pipe will close upon successful exec */
X    if (fcntl (pip[1], F_SETFD, 1) == -1)
X      close (pip[1]);
X
X    setuid(getuid());
X    setgid(getgid());
X
X#ifndef DYNIXPTX
X    execvp(argv[0], argv);
X#else
X    execl(argv[0], argv[0], argv[1], argv[2], argv[3]);
X#endif
X
X    write(pip[1],"",1);
X    close(pip[1]);
X    
X    printf ("Exec failed %s\r\n", argv[0]);
X    exit(1);
X  }
X
X  /* parent */
X  close(pip[1]);
X  close(soc[1]);
X
X  /* Wait for exec, read blocks until pipe is closed */
X  if (read(pip[0], (char *) &i, 1) == 0)
X    DEBUG_FP (stderr, "%s:exec apparently succeeded\n", term_server);
X  else
X    DEBUG_FP (stderr, "%s:exec apparently failed\n", term_server);
X  close(pip[0]);
X
X  pty_pid = pid;
X  return soc[0];
X}
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/pty.c' &&
  chmod 0644 'term-2.2.5/pty.c' ||
  echo 'restore of term-2.2.5/pty.c failed'
  shar_count="`wc -c < 'term-2.2.5/pty.c'`"
  test 12695 -eq "$shar_count" ||
    echo "term-2.2.5/pty.c: original size 12695, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/redir.c ==============
if test -f 'term-2.2.5/redir.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/redir.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/redir.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/redir.c' &&
X#define I_ERRNO
X#define I_SYS
X#define I_SIGNAL
X#include "includes.h"
X
X#include "client.h"
X
X#define MAXREDIR 32
X/* improved version - does multiple redirs  -ot */
X
X#ifdef ONE_CLIENT
X# define main tredir
X#else
Xint term_debug = 0;
X#endif
X
Xchar *sockaddr_to_str(struct sockaddr *,int trans);
Xchar *remote_port[MAXREDIR];
X
Xint rd_connect_server(int n, struct sockaddr *addr) {
X  int s;
X  
X  if ((s = socket_connect_server(-1,term_server)) <0) {
X    fprintf(stderr,"Term: %s\n",command_result);
X    close(s);
X    return -1;
X  }
X
X  send_command(s, C_SETPEERNAME, 0, "%s", sockaddr_to_str(addr,0));
X
X  if (send_command(s, C_PORT, 0, "%s", remote_port[n])< 0) {
X    fprintf(stderr,"Term C_PORT: %s\n",command_result);
X    return -1;
X  }
X
X  send_command(s, C_DUMB, 1, 0);
X  return s;
X}
X
Xvoid check_usage(int n) {
X  if ( n < 2 )
X    {
X      fprintf ( stderr, "Usage: redir [options] {<localport> <[host:]remoteport>}\n" );
X      exit(1);
X    }
X}
X
Xint main(int argc, char *argv[]) {
X  int s;
X  int first, i;
X  int svs[MAXREDIR];
X
X  signal(SIGPIPE, SIG_IGN);
X
X  if ((first = client_options(argc, argv,"",NULL)) < 0) exit(1);
X
X  setbuf(stderr, 0);
X	check_usage(argc-first);
X
X	for (i = 0; i < MAXREDIR && first < argc;first += 2) {
X		check_usage(argc - first);
X		fprintf(stderr, "Redirecting %s to %s\n", argv[first], argv[first+1] );
X    remote_port[i] = argv[first+1];
X    
X    /* Bind the local socket we are going */
X    /* to listen on.  */
X    s = bind_tcp_listen((unsigned short int) atoi(argv[first]),5);
X    if (s == -2) {
X      fprintf(stderr, "Port is already bound.\n");
X    } else if (s < 0) {
X      fprintf(stderr, "Can't bind to requested address. s = %d\n", s);
X    } else {
X      svs[i++] = s;
X    }
X  };
X  if(!i){
X    fprintf(stderr,"Nothing to do.\n");
X    exit(1);
X  };
X  do_connect(i, svs, rd_connect_server);
X  exit(0);
X}
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/redir.c' &&
  chmod 0644 'term-2.2.5/redir.c' ||
  echo 'restore of term-2.2.5/redir.c failed'
  shar_count="`wc -c < 'term-2.2.5/redir.c'`"
  test 1829 -eq "$shar_count" ||
    echo "term-2.2.5/redir.c: original size 1829, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/samples/termrc-14.4k-1 ==============
if test ! -d 'term-2.2.5/samples'; then
  echo 'x - creating directory term-2.2.5/samples'
  mkdir 'term-2.2.5/samples'
fi
if test -f 'term-2.2.5/samples/termrc-14.4k-1' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/samples/termrc-14.4k-1 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/samples/termrc-14.4k-1 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/samples/termrc-14.4k-1' &&
X# This is what I use from Linux -> TitanOS (bcr)
X# For a description of what the options mean, look at the TERMRC file.
X
Xbaudrate 14400
Xcollisions on
Xcompress on
Xnoise on
Xstopbits 0.5
Xterminate 'NO CARRIER'
Xtimeout 200
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/samples/termrc-14.4k-1' &&
  chmod 0644 'term-2.2.5/samples/termrc-14.4k-1' ||
  echo 'restore of term-2.2.5/samples/termrc-14.4k-1 failed'
  shar_count="`wc -c < 'term-2.2.5/samples/termrc-14.4k-1'`"
  test 219 -eq "$shar_count" ||
    echo "term-2.2.5/samples/termrc-14.4k-1: original size 219, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/samples/termrc-14.4k-2 ==============
if test -f 'term-2.2.5/samples/termrc-14.4k-2' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/samples/termrc-14.4k-2 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/samples/termrc-14.4k-2 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/samples/termrc-14.4k-2' &&
X# This is what I use TitanOS -> Linux (bcr)
X# For a description of what the options mean, look at the TERMRC file.
X
Xremote on
Xbaudrate 38400
Xcollisions on
Xcompress off
Xnoise on
Xshare off
Xstopbits 0.5
Xterminate 'NO CARRIER'
Xwindow 10
Xtimeout 200
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/samples/termrc-14.4k-2' &&
  chmod 0644 'term-2.2.5/samples/termrc-14.4k-2' ||
  echo 'restore of term-2.2.5/samples/termrc-14.4k-2 failed'
  shar_count="`wc -c < 'term-2.2.5/samples/termrc-14.4k-2'`"
  test 245 -eq "$shar_count" ||
    echo "term-2.2.5/samples/termrc-14.4k-2: original size 245, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/samples/termrc-2400-1 ==============
if test -f 'term-2.2.5/samples/termrc-2400-1' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/samples/termrc-2400-1 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/samples/termrc-2400-1 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/samples/termrc-2400-1' &&
X# This is what I would try first of a 2400 baud line. (bcr)
X# For a description of what the options mean, look at the TERMRC file.
X
Xbaudrate 2400
Xcompress on
Xnoise off
Xstopbits 1
Xterminate 'NO CARRIER'
Xtimeout 70
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/samples/termrc-2400-1' &&
  chmod 0644 'term-2.2.5/samples/termrc-2400-1' ||
  echo 'restore of term-2.2.5/samples/termrc-2400-1 failed'
  shar_count="`wc -c < 'term-2.2.5/samples/termrc-2400-1'`"
  test 213 -eq "$shar_count" ||
    echo "term-2.2.5/samples/termrc-2400-1: original size 213, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/samples/termrc-2400-2 ==============
if test -f 'term-2.2.5/samples/termrc-2400-2' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/samples/termrc-2400-2 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/samples/termrc-2400-2 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/samples/termrc-2400-2' &&
X# This is what I use at both ends of a connection where the remote host
X# speaks XON/XOFF to its local switch connector, but the switch internally
X# runs at 9600 baud with no flow control, and therefore tends to lose data
X# if more than three 256-byte packets arrive at the 2400 baud modem at once.
X# The packetsize 240 keeps total size with headers and acks under the limit,
X# while still allowing three packets to be in flight at one time.  (metcalf)
X# For a description of what the options mean, look at the TERMRC file.
X
Xescape 17
Xescape 19
Xignore 17
Xignore 19
Xbaudrate 2500
Xpacketsize 240
Xwindow 3
Xtimeout 100
Xnoise on
Xterminate 'NO CARRIER'
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/samples/termrc-2400-2' &&
  chmod 0644 'term-2.2.5/samples/termrc-2400-2' ||
  echo 'restore of term-2.2.5/samples/termrc-2400-2 failed'
  shar_count="`wc -c < 'term-2.2.5/samples/termrc-2400-2'`"
  test 648 -eq "$shar_count" ||
    echo "term-2.2.5/samples/termrc-2400-2: original size 648, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/serial.c ==============
if test -f 'term-2.2.5/serial.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/serial.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/serial.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/serial.c' &&
X#include "includes.h"
X
X#include "debug.h"
X
Xstatic int breakout = 0;
Xextern char breakout_string[256];
Xextern char *term_server;
Xextern int fudge_flow;
Xextern int byte_shift;
X
Xstatic int rewind_count=0;		/* This is so we can rescan data */
Xstatic un_char rewind_buffer[264];
X
X/*
X * Handles the serial side of things.
X *
X * 4 main routines..
X * do_serial_in() is called when the serial port is ready for reading and
X *	the in packet buffer isn't full.
X * do_serial_out() is called when the serial port is available for writing and
X * 	there are packets waiting.
X *
X * Compression is done at this level. I opted for the computational more 
X * expensive method of trying to compress each packet, rewinding the dictionary
X * if it failed.
X *
X * this module sees 4 buffers.
X * serial_in[]	are characters read from modem.
X * serial_out[] are characters waiting to be sent to modem.
X *
X * Note that serial_in() won't be called if link_in() has any characters in it.
X */
X/*----------------------------------------------------------------------*/
X/* function prototypes for this module */
Xvoid do_ack(unsigned int);
Xvoid send_ack(unsigned int);
Xint check_match(int, int);
X
X/*----------------------------------------------------------------------*/
X/* Various ring buffers */
X#ifndef titan
Xstruct Buffer serial_in = {0,0,0,0,0}, serial_out = {0,0,0,0,0};
X#else
Xstruct Buffer serial_in, serial_out;
X#endif
Xint inhabit_send = 0;
X
X#define PUT_SERIAL(c) add_to_buffer(&serial_out, c)
X#define GET_SERIAL() get_from_buffer(&serial_in)
X
X/* Packet information */
Xstruct Packet_out p_out[N_PACKETS];
Xint p_out_s, p_out_e;
Xint p_out_num, p_mismatch=0;
X
Xstruct Packet_in p_in[N_PACKETS];
Xint p_in_e;
Xint p_in_num;
X
Xvoid serial_init() {
X  int i;
X	      
X  p_out_s =
X  p_out_e = 
X  p_out_num =
X		    
X  p_in_e =
X  p_in_num = 0;
X
X  for (i = 0; i < N_PACKETS;++i) {
X    p_out[i].type = -1;
X    p_in[i].type = -1;
X  }
X  add_to_buffer(&serial_in, 0);
X  get_from_buffer(&serial_in);
X}
X
X/*---------------------------------------------------------------------------*/
X/* Takes a byte, and puts it in the serial buffer. */
X/* If necessary, it emits escape characters until the byte is valid */
X /* for the serial line. It adds 33.  33 is a generator for */
X /* 0-255. As you can see, it is VERY expensive if there are a lot of */
X /* escaped characters. Hopefully this won't be the case. */
X
Xvoid put_serial(unsigned int a) {
X  static int count=0; 
X  static int f_c = 1;
X  if (fudge_flow && !--f_c) {	/* If we need to generate */
X				/* flow control characters, and */
X				/* there has been enough */
X				/* intervening characters, */
X				/* then generate an XON. */
X    PUT_SERIAL(17);		/* emit an XON */
X    f_c = fudge_flow;		/* and reset the counter. */
X  }
X
X  a ^= byte_shift;		/* and shift it to try and avoid */
X				/* characters that need escaping. */
X  a &= out_mask;
X  if (a == breakout_string[count]) {
X    count++;
X  }else {
X    count=0;
X  }
X
X  DEBUG_PED(stderr, "%s:o%X\n", term_server, a); /* debugging.. */
X
X  while (escapes[a] || !breakout_string[count+2]) 
X		{		/* Ok. While it is a */
X				/* character that needs escaping, we */
X				/* emit escapes and try again. */
X    PUT_SERIAL('^');		/* emit the escape character. */
X    a = (a + 33);		/* and pick a new character.*/
X				/* 33 is a generator for [0..255] */
X    a &= out_mask;
X    count=0;
X  }
X  PUT_SERIAL((un_char) a);		/* Now put the character out. */
X}
X
X/* collect stats on the distribution of input characters */
Xvoid do_histogram(int h)
X{
X  static int counter = 0;
X  static long hist_gram[256];
X  h &= 255;
X  ++hist_gram[h];
X  ++counter;
X
X  return;
X}
X  
X  
X
X/* Ok. get a byte from the serial in buffer */
X/* we handle character escapes here. */
Xint get_serial(void) {
X  unsigned int a;		/* Our byte. */
X  static int state = 0;
X  
X  while (serial_in.size) {
X    if (state == 0) {		/* If we aren't in the middle of */
X				/* handling and escape.. */
X      SANITY(rewind_count < sizeof(rewind_buffer));
X      if (rewind_count)
X        a = rewind_buffer[--rewind_count];
X      else {
X        a = GET_SERIAL() & in_mask;		/* then get the next byte. */
X        if (a == '^') {		/* Is it an escape?? */
X  	  state++;		/* yes, go to escape handling. */
X	  breakout=0;
X	  continue;
X        }
X        if (ignores[a]) {		/* This char MUST be line noise */
X          noise((int) a);		/* We were told the remote system will */
X      	  continue;		/* never generate this character. */
X        }
X        DEBUG_PED(stderr, "%s:i%X\n", term_server,a); /* For debugging.. */
X      }
X      return ((int) a ^ byte_shift) & in_mask; /* Ok. Return it modulo the */
X					 /* byte shift. As the */
X					 /* byte_shift could be larger */
X					 /* than the mask, mask it */
X					 /* again. */
X    }
X
X    a = GET_SERIAL();		/* Ok. escape handling. Get the next */
X				/* byte. */
X    a &= in_mask;
X
X    if ( a== '^') {		/* Ok! It is an escaped escape. Try again. */
X      ++state;
X      continue;
X    }
X    if (ignores[a]) continue;
X				/* control junk. else it is line */
X				/* noise. Either way, we don't want it. */
X    a = (a - 33 * state) ^ byte_shift; /* Ok. Work out what the byte */
X				/* should be.. */
X    state = 0;			/* and return to normal character */
X				/* processing. */
X    a &= in_mask;
X    DEBUG_PED(stderr, "%s:i%X\n", term_server, a); /* debug */
X    return (int) a;		/* and return byte to caller. */
X  }
X  return -1;			/* Nothing left in buffer. Return EOF */
X}
X
X/*---------------------------------------------------------------------------*/
X/* Main routines. */
X
X/* This is very horrible. We find the packet that has been waiting for a 
X * ack the longest and send it..... This should be a list structure 
X * But that would be very messy to do. (Where do we add new packets?? )
X * This works fine for now. We will wait and see what sort of cpu time 
X * it uses..
X */
Xvoid do_serial_out(int force) {
X  int i, j;
X  unsigned int l;
X				/* port is ready for writing. see */
X				/* what's available. */ 
X  
X  if (!p_out_num || serial_out.size || inhabit_send)
X    return;			/* Hmm. How did this get called. */
X  
X				/* Check for timeouts.. */
X				/* First we find the packet that has */
X				/* been waiting longest. */
X  l = p_out_s;
X  for ( j = p_out_s, i = 0; i < N_PACKETS;++i, j = ((j+1)%N_PACKETS)) {
X    if (p_out[j].type < 0) continue;
X    if (p_out[j].timeout < p_out[l].timeout || p_out[l].type < 0)
X      l = j;
X  }
X				/* Then we check to make sure that */
X				/* this is longer than the minimum */
X				/* packet timeout period and that we */
X				/* actually found a packet. */
X  if (p_out[l].type < 0)
X    return;
X
X  if (current_time < (p_out[l].timeout + packet_timeout))
X    return;
X
X				/* And then we send it. */
X  if (fudge_flow && p_out[l].timeout)
X    put_serial(19);
X
X  put_serial((unsigned) 'A'+p_out[l].type); 
X  put_serial((unsigned) p_out[l].len);
X  put_serial(l);
X  j = update_crc(update_crc(update_crc(0,(unsigned) ('A'+p_out[l].type)),
X			    (unsigned) p_out[l].len), l);
X  put_serial((unsigned int) j & 255);
X  DEBUG_CHECK(stderr, "%s:header check == %x\n", term_server, j&255);
X  
X  for (j = 0; j < p_out[l].len;++ j)
X    put_serial(p_out[l].data[j]);
X  j = check_sum(p_out[l].data, j , out_mask);
X  DEBUG_CHECK(stderr, "%s:p %d len %d checksum == %x\n", term_server, 
X	      l, p_out[l].len , j);
X  put_serial((unsigned int) j & 255);
X  put_serial((unsigned int) (j >> 8) & 255);
X  if (p_out[l].timeout) {
X    WARNING(stderr, "\n%s:%s timed out %d at %ld trans %d\n", term_server, 
X            remote ? "remote" : "local", l, 
X	    current_time - p_out[l].timeout, p_out[l].trans);
X    window_size = 1;  /* This allows for a complete recovery. */
X  }
X  p_out[l].timeout = current_time;
X  if (!p_out[l].trans++) 
X    *p_out[l].queue = (*p_out[l].queue > 0) ? (*p_out[l].queue - 1) : 0;
X}
X
Xvoid do_serial_in() {
X  int i, j;
X  int check;
X  static int breakout_last = 0;
X
X  static unsigned int		/* various state flags */
X    curr_p_stage = 0,
X    curr_p_len = 0,
X    curr_p_index = 0, 
X    curr_p_type = 0,
X    curr_p_num = 0;
X  static un_char header[4];
X  
X  if (p_in_num > N_PACKETS/2 || !serial_in.size)
X    return; /* packet window is full */
X  
X  while (serial_in.size) {  
X    DEBUG_STATE(stderr, "%s:d_s_i state %d len %d ind %d type %d num %d\n", 
X		term_server, curr_p_stage, curr_p_len, curr_p_index, curr_p_type,
X		curr_p_num);  
X    switch (curr_p_stage) {
X    case -1:	/* This handles breakout strings */
X      i = get_serial();
X      if ( i < 0) break;
X
X      if ( breakout && (i == (breakout_string[breakout]^byte_shift)) ) {
X        breakout_last = breakout++;
X        if ( !breakout_string[breakout] ) {
X          int k;
X	  do_shutdown = 1;
X          for(k=0; breakout_string[k] ; ++k) noise(breakout_string[k]);
X          noise('\r');
X          noise('\n');
X        }
X        break;
X      }
X      rewind_buffer[rewind_count++] = i^byte_shift;
X      SANITY(rewind_count < sizeof(rewind_buffer));
X      while(breakout_last >= 0) {
X        rewind_buffer[rewind_count++] =
X          breakout_string[breakout_last--]^byte_shift;
X        SANITY(rewind_count < sizeof(rewind_buffer));
X      }
X      breakout = curr_p_stage = 0;
X      break;
X
X    case 0:			/* waiting for packet header */
X      i = get_serial();
X      if ( i < 0) break;
X
X      if ( !breakout_last && i == (breakout_string[breakout++]^byte_shift) ) {
X        curr_p_stage = -1;
X        break;
X      }
X      breakout_last = breakout = 0;
X
X      if (i < 'A' || i > ('A'+MAX_TYPE)) {
X        noise(i);
X        break;
X      }
X
X				/* ok. for now we will assume that it */
X				/* is a header. */ 
X      curr_p_index = 0;
X      header[curr_p_index++] = i;
X      curr_p_stage = 1;
X      break;
X    case 1:			/* read header */
X      i = get_serial();
X      if (i < 0) 
X	break;
X      header[curr_p_index++] = i;
X      if (curr_p_index < 4) 
X	break;			/* more to read yet */
X				/* Ok. We have the whole header. Check */
X				/* the checksum */ 
X      i = update_crc(update_crc(update_crc(0,
X		(unsigned int) header[0]& (unsigned int) in_mask),
X		(unsigned int) header[1]& (unsigned int) in_mask),
X		(unsigned int) header[2]& (unsigned int) in_mask); 
X      if (!check_match( i & in_mask,(int) header[3])) {
X	DEBUG_CHECK(stderr, "%s:invalid check calc %x, read %x\n", 
X		    term_server, i, header[3]);
X				/* checksum failed. treat first byte as noise */
X				/* and start again with the next byte */
X				/* Since this may just be a talk message or */
X				/* such I make the warning optional. */
X       
X        if (header[2] < N_PACKETS && header[0] == 'D')
X          NOTIFY(stderr,"%s:discarding possible ack %o %d %o",
X            term_server, header[1], header[2], header[3]); 
X
X        noise((int) header[0]);		/* This byte is noise, the rest is */
X					/* Placed back in the rewind buffer */
X        for (i=4;i > 1;) {
X          rewind_buffer[rewind_count++]=header[--i]^byte_shift;
X          SANITY(rewind_count < sizeof(rewind_buffer));
X        }
X	curr_p_stage = 0;
X	break;
X      }
X
X				/* ok. checksum was good. see what */
X				/* type packet is */ 
X      if (header[0] == 'D') {
X				/* it is an ack */
X				/* we do a more stringent checksum here */
X				/* cos bad acks are a real pain in the butt */
X	DEBUG_SER(stderr, "%s:got ack %d.\n",term_server,header[1]);
X	if (!check_match(((int) header[0] ^
X			 (int) header[1]) & (int) in_mask,
X			 (int) header[2] & (int) in_mask)) {
X	  DEBUG_CHECK(stderr,
X		      "%s:d_s_i: secondary. calc %x, read %x\n", 
X		      term_server, header[0] ^ header[1], header[2]);
X				/* heh heh. bad secondary checksum. */
X				/* lose that sucker */ 
X	  curr_p_stage = 0;
X	  break;
X	}
X	do_ack(header[1]);
X	curr_p_stage = 0;
X	break;
X      }			
X				/* see if we want the packet */
X      if (!header[1] && remote_term_version >= 20000)
X        curr_p_len = 258;
X      else	
X        curr_p_len = header[1] + 2; /* get checksum as well. */
X
X      i = (N_PACKETS + header[2] - (unsigned)p_in_e) % N_PACKETS;  
X      if ( i + i >  N_PACKETS) {  
X	DEBUG_SER(stderr, "%s:d_s_i: got old packet %d\n", term_server, i);
X				/* an old packet. just lose it */
X        WARNING(stderr,"old packet %d received.  try raising your %s timeout.\n",
X          i, remote ? "local" : "remote");
X        noise((int) header[0]);	/* This byte is noise, the rest is */
X				/* Placed back in the rewind buffer */
X        for (i=4;i > 1;) {
X          rewind_buffer[rewind_count++]=header[--i]^byte_shift;
X          SANITY(rewind_count < sizeof(rewind_buffer));
X        }
X	send_ack(header[2]);
X	curr_p_stage = 0;
X	break;
X      }
X      curr_p_num = header[2] % N_PACKETS;
X      if (p_in[curr_p_num].type >= 0) {
X	DEBUG_SER(stderr, "%s:got dup packet\n", term_server);
X				/* Hmm. We think we already have it . */
X				/* check it */ 
X	if (header[1] != p_in[curr_p_num].len) {
X				/* We have a different length !! */
X	  alert("Duplicate packet received with a different\n");
X	  alert("lengths.  Considering this noise:\n");
X				/* just ignore it for now. Will HAVE */
X				/* to be fixed */ 
X          noise((int) header[0]);	/* This byte is noise, the rest is */
X					/* Placed back in the rewind buffer */
X          for (i=4;i > 1;) {
X            rewind_buffer[rewind_count++]=header[--i]^byte_shift;
X            SANITY(rewind_count < sizeof(rewind_buffer));
X          }
X	  curr_p_stage = 0;
X	  break;
X	}
X        WARNING(stderr,"duplicate packet received\n");
X				/* discard following data and checksum */
X        noise((int) header[0]);	/* This byte is noise, the rest is */
X					/* Placed back in the rewind buffer */
X        for (i=4;i > 1;) {
X          rewind_buffer[rewind_count++]=header[--i]^byte_shift;
X          SANITY(rewind_count < sizeof(rewind_buffer));
X        }
X	curr_p_stage = 0;
X	break;
X      }
X      curr_p_stage = 2;
X      curr_p_index = 0;
X      stat_modem_recv += curr_p_len;
X      break;
X    case 2:			/* read data */
X      i = get_serial();
X      if (i < 0)
X	break;
X      p_in[curr_p_num].data[curr_p_index ++ ] = i;
X      if (curr_p_index < curr_p_len) 
X	break; /* more to read yet */
X				/* all read. now test the checksum */
X      j = (p_in[curr_p_num].data[(int) curr_p_len - 1] <<8) +
X	p_in[curr_p_num].data[(int) curr_p_len -2] ;
X      
X      check = check_sum(p_in[curr_p_num].data, (int) curr_p_len-2, in_mask);
X      
X      if (!check_match(j, check) ) {
X	DEBUG_CHECK(stderr, "%s:d_s_i: main calced = %x, read = %x\n", 
X		    term_server, check, j);
X	
X				/* failed checksum . sigh. back to beginning */
X        WARNING(stderr,"\nbad packet! garbage follows:\n");
X        noise((int) header[0]);		/* This byte is noise, the rest is */
X					/* Placed back in the rewind buffer */
X        for (i=curr_p_len=0;i > 0;) {
X          rewind_buffer[rewind_count++]=p_in[curr_p_num].data[--i]^byte_shift;
X          SANITY(rewind_count < sizeof(rewind_buffer));
X        }
X        for (i=4;i > 1;) {
X          rewind_buffer[rewind_count++]=header[--i]^byte_shift;
X          SANITY(rewind_count < sizeof(rewind_buffer));
X        }
X	curr_p_stage = 0;
X	break;
X      }
X      
X				/* ok. got a complete packet. */
X				/* whack it in list. This is */
X				/* difficult. grin. */ 
X
X      send_ack(curr_p_num);
X      p_in[curr_p_num].type = header[0] - 'A';
X      p_in[curr_p_num].len = curr_p_len - 2;
X      
X      ++p_in_num;
X      DEBUG_LINK(stderr, "%s:Packet %d added to in Q\n", term_server, curr_p_num);
X      curr_p_stage = 0;
X      break;    
X    case 3:			/* discard */
X      if ((int) curr_p_len <= 0) {	/* sanity check */
X	curr_p_stage  = 0;
X	break;
X      }
X      if (get_serial() < 0)
X	break;
X      if (!--curr_p_len)
X	curr_p_stage = 0;
X      break;
X    case 4:			/* This state is special. This is the */
X				/* meta-state used by term to check */
X				/* for characters that are getting */
X				/* eaten, or to do other things that */
X				/* aren't based on packets. */
X      i = get_serial();
X      if (i < 0) break;
X
X      if (meta_state(i))
X	break;
X				/* Return to normal packet handling. */
X      inhabit_send = 0;
X      curr_p_stage = 0;
X      break;
X    default:
X      curr_p_stage = 0;
X      break;
X    }
X  }
X}
X
Xvoid do_ack(unsigned int num) {
X
X  DEBUG_FP(stderr, "%s:got ack for packet %d\n", term_server, num);
X  num %= N_PACKETS;
X  if (p_out[num].type < 0) {
X    DEBUG_SER(stderr, "%s:was dup.\n", term_server);
X    return;
X  }
X
X  stat_modem_ack += p_out[num].len;
X
X  p_out[num].type = -1;
X
X  while (p_out[p_out_e].type < 0 && p_out_num > 0) {
X    p_out_e = (p_out_e + 1 ) % N_PACKETS;
X    --p_out_num;
X  }
X
X	/* In case of timeouts, we need to dequeue all the packets befor */
X	/* we continue. */
X  if(window_size == 1 && ((p_out_e + N_PACKETS) - p_out_num) % N_PACKETS <= 1 ) 
X    window_size = window_size_max;
X}
X
X
X
Xvoid send_ack(unsigned int num) {
X				/* yucky eh?? 4 bytes to transmit 1. */
X				/* Oh well. I fix it in some other version */ 
X				/* lets get it working first. ;) */
X  DEBUG_SER(stderr, "%s:sending ack for %d\n", term_server, num);
X  put_serial('D');
X  put_serial(num);
X  put_serial(num ^ 'D');
X  put_serial( update_crc(update_crc(update_crc(0, 'D'),
X				    num), num ^ 'D'));
X}
X
Xint check_match(int check, int calc) {
X  if (!seven_bit_in)
X    return check == calc;
X  
X  return ((check & 127) == (calc & 127)) &&
X    (((check >> 8) & 127) == ((calc>>8) & 127));
X}
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/serial.c' &&
  chmod 0644 'term-2.2.5/serial.c' ||
  echo 'restore of term-2.2.5/serial.c failed'
  shar_count="`wc -c < 'term-2.2.5/serial.c'`"
  test 17163 -eq "$shar_count" ||
    echo "term-2.2.5/serial.c: original size 17163, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/server.c ==============
if test -f 'term-2.2.5/server.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/server.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/server.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/server.c' &&
X
X#include "includes.h"
X
X
Xvoid int(int argc, char *argv[]) {
X				/* Nothing yet. */
X}
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/server.c' &&
  chmod 0644 'term-2.2.5/server.c' ||
  echo 'restore of term-2.2.5/server.c failed'
  shar_count="`wc -c < 'term-2.2.5/server.c'`"
  test 85 -eq "$shar_count" ||
    echo "term-2.2.5/server.c: original size 85, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/sevenbit.c ==============
if test -f 'term-2.2.5/sevenbit.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/sevenbit.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/sevenbit.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/sevenbit.c' &&
X
X#include "includes.h"
X#include "debug.h"
X/* gets size bits from starting from bit 'curr' in the bit stream data */
X
Xint s_2_e_buff(un_char *data, un_char *out, int len) {
X    int     byte,
X            bit,
X            j;
X    byte = 0;
X    bit = 0;
X    j = 0;
X    do {
X      out[j] = ((unsigned)(data[byte++] & 127) >> bit);
X      out[j] |= (data[byte] & 127) << (7 - bit);
X      if (++bit == 7) {
X	bit = 0;
X	++byte;
X      }
X      ++j;
X    } while (byte + 1< len);
X    return j;
X}
X
Xint e_2_s_put(un_char *out, un_char data, int key) {
X  int bit = 0;
X  bit = key&7;
X  key>>=3;
X  if (bit ==7) {
X    out[++key]=0;
X    bit = 0;
X  }
X  out[key++] |= (data<<bit) & 127;
X  out[key] = data >> (7 - bit);
X  ++bit;
X  return key * 8 + bit;
X}
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/sevenbit.c' &&
  chmod 0644 'term-2.2.5/sevenbit.c' ||
  echo 'restore of term-2.2.5/sevenbit.c failed'
  shar_count="`wc -c < 'term-2.2.5/sevenbit.c'`"
  test 731 -eq "$shar_count" ||
    echo "term-2.2.5/sevenbit.c: original size 731, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/shutdown.c ==============
if test -f 'term-2.2.5/shutdown.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/shutdown.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/shutdown.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/shutdown.c' &&
X#include "includes.h"
X#include "client.h"
X
X#ifdef ONE_CLIENT
X# define main tshutdown
X#else
Xint term_debug = 0;
X#endif
X
Xint arg = -1;
X
Xstatic int local_options ( char opt, char *term_optarg )
X{
X  switch(opt)
X  {
X  case 'h' :
X    arg = 2; 
X    break;
X  case 'n' :
X    arg = 1; 
X    break;
X  default:
X    return -1;
X  }
X  return 0;
X}
X
Xint main(int argc, char *argv[]) {
X  int s;
X
X  (void) client_options(argc, argv,"vhn",local_options);
X
X  use_term_command(PRIVILEGED);
X
X  if ((s = socket_connect_server(-1,term_server)) <0) {
X    fprintf(stderr,"Term: %s\n", command_result);
X    exit(1);
X  }
X
X  if (verbose) 
X    printf ("Shutting down remote...\n");
X  if (send_command(s, C_QUIT, 0, "%d", arg) < 0) {
X    fprintf(stderr,"Couldn't shutdown remote: %u\n", termerrno);
X    exit(1);
X  }
X  if (verbose)
X    printf ("Shutting down local...\n");
X  if (send_command(s, C_QUIT, 1, "%d", arg) < 0) {
X    fprintf(stderr,"Couldn't shutdown local: %u\n", termerrno);
X    exit(1);
X  }
X  exit(0);
X}
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/shutdown.c' &&
  chmod 0644 'term-2.2.5/shutdown.c' ||
  echo 'restore of term-2.2.5/shutdown.c failed'
  shar_count="`wc -c < 'term-2.2.5/shutdown.c'`"
  test 984 -eq "$shar_count" ||
    echo "term-2.2.5/shutdown.c: original size 984, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/sockets.c ==============
if test -f 'term-2.2.5/sockets.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/sockets.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/sockets.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/sockets.c' &&
X#define I_SYS
X#define I_ERRNO
X#define I_STRING
X#define I_INET
X#define I_IOCTL
X#include "includes.h"
X
Xextern char com_result[1024];
X
Xstruct sockaddr *make_sockaddr(unsigned int port, char *host,
X  unsigned long defaultaddr);
X
Xchar *sockaddr_to_str(struct sockaddr *,int trans);
X
X/* This binds to the specified port, and optionally listens for connections.
X */
X
Xint bind_tcp_listen(unsigned int port, int queue)
X{
X  struct sockaddr_in sin, *addr_in;
X  int s;
X
X  addr_in = (struct sockaddr_in *)make_sockaddr(port,NULL,INADDR_ANY);
X
X  if (term_localaddr == INADDR_ANY) 
X    get_term_localaddr(inet_addr("127.0.0.1"));
X  memset(&sin, 0, sizeof(sin));
X  sin.sin_addr.s_addr = term_localaddr;
X  sin.sin_port = htons( port );
X  sin.sin_family = AF_INET;
X
X  s = socket(sin.sin_family, SOCK_STREAM, 0); 
X
X  if (s == -1) {
X    sprintf(com_result,"XXXsocket:%s",strerror(errno));
X    return -1;
X  }
X
X  if (bind(s, (struct sockaddr * ) addr_in, sizeof(sin)) < 0) {
X    if (errno != EADDRINUSE) {	/* if it wasn't in use */
X      if ( addr_in != &sin ) {
X         addr_in = &sin;
X      }else {
X        close(s);
X        return -1; 		/* then we can't handle it, so abort. */
X      }
X    }else {
X      close(s);
X      return -2;		/* handled specially by some clients. */
X    }
X  }
X
X  if (! queue) return s;
X
X  if (listen(s, queue) == -1) {	/* If we can't listen... */
X    sprintf(com_result,"XXXlisten:%s",strerror(errno));
X    				/* then just dump. We can't handle */
X				/* errors here. */
X    close(s);
X    return -1;
X  }
X  return s;
X}
X
Xint bind_tcp(unsigned int s) {
X  return bind_tcp_listen(s,5);
X}
X
X/*      if NO_UNIX_DOMAIN
X *
X *	We bind the socket, and then write the address to the requested
X *	file.  We are the server.
X */
X
X/*	if STREAMS_PIPE
X *
X *	This is a bit of a hack.  If STREAMS_PIPE is defined, we look for the
X *	environment variable TERM_BORROWED_DISPLAY_NUMBER, and interpret the
X *	value as an X-server display number, and use that streams pipe as
X *	our client/server IPC channel.
X *
X *	This is for SCO.  It would probably work on other systems if you
X *	became root and set up the appropriate /dev/X?R and /dev/X?S entries
X */
X
Xint bind_unix(char *path) 
X{
X#if defined(NO_UNIX_DOMAIN)
X  struct sockaddr_in sock_in;
X  int size_in;
X  int fd;
X#else
X  struct sockaddr_un sock_un;
X#endif
X#ifdef STREAMS_PIPE
X  char *borrowed_display_number;
X#endif
X
X  int s;
X
X#ifdef STREAMS_PIPE
X  borrowed_display_number = getenv("TERM_BORROWED_DISPLAY_NUMBER");
X  if (borrowed_display_number != 0) {
X    s = open_stream_pipe(atoi(borrowed_display_number));
X    if (s < 0) {
X      sprintf(com_result, "XXXcannot borrow X display channel %s", borrowed_display_number);
X      return -1;
X    } else {
X      sprintf(com_result, "XXXBorrowed X display channel %d\n", atoi(borrowed_display_number));
X      return s;
X    }
X  }
X
X#endif
X
X#if defined(NO_UNIX_DOMAIN)
X  if ((s = socket(AF_INET, SOCK_STREAM, 0 )) < 0) {
X    sprintf(com_result,"XXXsocket:%s",strerror(errno));
X    return -1;
X  }
X
X  sock_in.sin_family = AF_INET;
X  sock_in.sin_addr.s_addr = htonl(INADDR_ANY);
X  sock_in.sin_port = htons(0);
X  if (bind(s, (struct sockaddr *) &sock_in, sizeof(sock_in)) < 0) {
X    sprintf(com_result,"XXXbind:%s",strerror(errno));
X    close(s);
X    return -1;
X  }
X
X  size_in = sizeof(sock_in);
X  if (getsockname(s, (struct sockaddr *) &sock_in, &size_in) < 0) {
X    sprintf(com_result,"XXXgetsockname:%s",strerror(errno));
X    close(s);
X    return -1;
X  }
X  fd = open(path, O_WRONLY|O_CREAT, 0666);
X  if (fd < 0) {
X    sprintf(com_result,"XXXopen:%s",strerror(errno));
X    close(s);
X    return -1;
X  }
X
X  { char port[10];
X
X    sprintf(port,"%u\n",ntohl(sock_in.sin_port));
X    if (write(fd, port, sizeof(port)) < 0) {
X      sprintf(com_result,"XXXwrite:%s",strerror(errno));
X      close(s);
X      return -1;
X    }
X  }
X
X  sprintf(com_result, "XXXOK, Port is %d", ntohs(sock_in.sin_port));
X#else
X  if ((s = socket(AF_UNIX, SOCK_STREAM, 0 )) < 0) {
X    sprintf(com_result,"XXXsocket:%s",strerror(errno));
X    return -1;
X  }
X
X  sock_un.sun_family = AF_UNIX;
X  
X  strcpy(sock_un.sun_path, path);
X  unlink(sock_un.sun_path);
X  if (bind(s, (struct sockaddr *) &sock_un, strlen(sock_un.sun_path) + 2)) {
X    sprintf(com_result,"XXXbind:%s\n%s %s\n",strerror(errno),
X      "Can't bind a socket at %s",path);
X    close(s);
X    return -1;
X  }
X
X#endif
X  /* ok. Start looking for connections. */
X  if (listen(s, 5) < 0) {
X    sprintf(com_result,"XXXlisten%s",strerror(errno));
X    close(s);
X    return -1;
X  }
X  return s;
X}
X
X/* Connect to the specified port/address */
X
Xint connect_tcp(int s, char *hostname, unsigned int port) {
X  struct sockaddr *addr;
X
X  if(term_localaddr == INADDR_ANY)
X    get_term_localaddr(inet_addr("127.0.0.1"));
X
X  if (!(addr=make_sockaddr(port,hostname,htonl(term_localaddr)))) {
X    sprintf(com_result,"XXXmake_sockaddr:%s",strerror(errno));
X    return -1;
X  }
X
X  if (s < 0) if ((s = socket(AF_INET, SOCK_STREAM, 0 )) < 0) {
X    sprintf(com_result,"XXXsocket:%s",strerror(errno));
X    return -1;
X  }
X
X  if (connect(s,addr,sizeof(struct sockaddr))<0) {
X    sprintf(com_result,"XXXconnect: %s", strerror(errno));
X    close(s);
X    return  -1;
X  }
X  return s;
X}
X
X/* This routine allows one to duplicate a term connection without accessing
X * the unix socket.
X */
X
Xint duplicate_connect(int s, int Sock)
X{
X  char port[10];
X
X  if (s < 0) if ((s = socket(AF_INET, SOCK_STREAM, 0 )) < 0) {
X    sprintf(com_result,"XXXsocket:%s",strerror(errno));
X    return -1;
X  }
X
X  if(send_command(Sock,C_BINDS,1,"%d",0)<0){
X    sprintf(com_result,"XXXC_BINDS:%s",command_result);
X    close(s);
X    return -1;
X  }
X  if(read(Sock,port,sizeof(port))<0){
X    sprintf(com_result,"XXXread:%s",strerror(errno));
X    close(s);
X    return -1;
X  }
X  if(port[2]!= I_OK){
X    sprintf(com_result,"XXXC_BINDS: port not ok");
X    close(s);
X    return -1;
X  }
X  return connect_tcp(s,NULL,(unsigned int)atoi(&port[3]));
X}
X
X/* This routine connects to a unix socket, intended to be term...
X */
X
X/* if STREAMS_PIPE
X *
X *	This is a bit of a hack.  If STREAMS_PIPE is defined, we look for the
X *	environment variable TERM_BORROWED_DISPLAY_NUMBER, and interpret the
X *	value as an X-server display number, and use that streams pipe as
X *	our client/server IPC channel.
X *
X *	This is for SCO.  It would probably work on other systems if you
X *	became root and set up the appropriate /dev/X?R and /dev/X?S entries
X */
X
X
Xint open_unix(char *p){
X  return connect_unix(-1,p);
X}
X
X/*      To hack things even more, I now have tried to make it possible to
X *      connect non-unix type sockets to term with the command C_BINDS. (bcr)
X */
X
Xint connect_unix(int S, char *p)
X{
X  struct sockaddr_in sock_in;
X#if !defined(NO_UNIX_DOMAIN)
X  struct sockaddr_un sock_un;
X#endif
X#ifdef STREAMS_PIPE
X  char *borrowed_display_number;
X#endif
X  int s = -1;
X
X#ifdef STREAMS_PIPE
X  borrowed_display_number = getenv("TERM_BORROWED_DISPLAY_NUMBER");
X  if (borrowed_display_number != 0) {
X    if(S<0)
X      s = MakeStreamPipeConnection(atoi(borrowed_display_number));
X    else
X      s = S;
X    if (s < 0) {
X      sprintf(com_result, "XXXcannot borrow X display channel %s", borrowed_display_number);
X      return -1;
X    } else {
X      return s;
X    }
X  }
X
X#endif
X
X#if !defined(NO_UNIX_DOMAIN)
X	/* First we find out if S is a unix domain socket. */
X	/* If it is, we can connect it directly to the term socket. */
X  if(S>=0){
X    int size_in;
X
X    size_in = sizeof(sock_in);
X    if (getsockname(S, (struct sockaddr *) &sock_in, &size_in) < 0) {
X      sprintf(com_result,"XXXgetsockname:%s",strerror(errno));
X      close(s);
X      return -1;
X    }
X    if(sock_in.sin_family==AF_UNIX) s=S;
X  }
X  if (s<0) if ((s = socket(AF_UNIX, SOCK_STREAM, 0 )) < 0) {
X    sprintf(com_result,"XXXsocket:%s",strerror(errno));
X    return -1;
X  }
X
X  sock_un.sun_family =  AF_UNIX; 
X  
X  sprintf(sock_un.sun_path,"%s",p);
X  
X  if (connect(s, (struct sockaddr *) &sock_un, 
X	      strlen(sock_un.sun_path) + 2)) {
X    sprintf(com_result,"XXXconnect 2:%s",strerror(errno));
X    close(s);
X    return -1;
X  }
X 	/* If S is a tcp socket, then we duplicate the connection as tcp */
X	/* and then close the unix socket we just created. */
X  if(S>=0 && S!=s){
X    S = duplicate_connect(S, s);
X    close(s);
X    s = S;
X  }
X  return s;
X}
X#else /* NO_UNIX_DOMAIN */
X
X	/* Instead of a unix socket, we just have a file with the port # to */
X	/* connect to. */
X
X  {
X    int fd;
X    char port[10];
X
X    fd = open(p, O_RDONLY);
X    if (fd < 0) {
X      sprintf(com_result,"XXXopen:%s",strerror(errno));
X      return -1;
X    }
X
X    if (read(fd, port, sizeof(port)) < 0) {
X      sprintf(com_result,"XXXread:%s",strerror(errno));
X      close(fd);
X      return -1;
X    }
X
X    close(fd);
X  }
X
X	/* If needed open a socket. */
X
X  return connect_tcp(S,NULL,atoi(port));
X}
X#endif
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/sockets.c' &&
  chmod 0644 'term-2.2.5/sockets.c' ||
  echo 'restore of term-2.2.5/sockets.c failed'
  shar_count="`wc -c < 'term-2.2.5/sockets.c'`"
  test 8755 -eq "$shar_count" ||
    echo "term-2.2.5/sockets.c: original size 8755, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/spipe.c ==============
if test -f 'term-2.2.5/spipe.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/spipe.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/spipe.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/spipe.c' &&
X#if defined(STREAMS_PIPE)
X/*
X * Portions Copyright (C) 1994 The Santa Cruz Operation, Inc.
X * All Rights Reserved.
X * 
X * Permission to use, copy, modify and distribute this software
X * for any purpose is hereby granted without fee, provided that the 
X * above copyright notice and this notice appear in all copies
X * and that both the copyright notice and this notice appear in
X * supporting documentation.  SCO makes no representations about
X * the suitability of this software for any purpose.  It is provided
X * "AS IS" without express or implied warranty.
X * 
X * SCO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, 
X * INCLUDING ALL IMPLIED WARRANTIES OR MERCHANTABILITY AND FITNESS.  
X * IN NO EVENT SHALL SCO BE LIABLE FOR ANY SPECIAL, INDIRECT, 
X * PUNITIVE, CONSEQUENTIAL OR INCIDENTAL DAMAGES OR ANY DAMAGES 
X * WHATSOEVER RESULTING FROM LOSS OF USE, LOSS OF DATA OR LOSS OF
X * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER 
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR 
X * PERFORMANCE OF THIS SOFTWARE.
X *
X *	THIS COPYRIGHT NOTICE DOES NOT APPLY TO THE FUNCTION
X *	spipe() WHICH WAS OBTAINED FROM:
X *
X *	Stevens, W. Richards.  UNIX Network Programming, Prentice-Hall,
X *	1990.  [If you program on UNIX, you want this book.  Really.
X *	One of the best. (tom@sco.com)]
SHAR_EOF
  : || echo 'restore of term-2.2.5/spipe.c failed'
fi
echo 'End of archive part 6'
echo 'File term-2.2.5/spipe.c is continued in part 7'
echo 7 > _sharseq.tmp
exit 0
