Newsgroups: comp.sources.unix
From: bcr@physics.purdue.edu (Bill C. Riemers)
Subject: v28i170: term-2.2.5 - SLIP-like functionality between two *IX hosts (REPOST), Part07/09
References: <1.784237938.15304@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: bcr@physics.purdue.edu (Bill C. Riemers)
Posting-Number: Volume 28, Issue 170
Archive-Name: term-2.2.5/part07

#!/bin/sh
# This is `part07' (part 7 of a multipart archive).
# Do not concatenate these parts, unpack them in order with `/bin/sh'.
# File `term-2.2.5/spipe.c' is being continued...
#
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  echo 'WARNING: not restoring timestamps.  Consider getting and'
  echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if test ! -r _sharseq.tmp; then
  echo 'Please unpack part 1 first!'
  exit 1
fi
shar_sequence=`cat _sharseq.tmp`
if test "$shar_sequence" != 7; then
  echo "Please unpack part $shar_sequence next!"
  exit 1
fi
if test ! -f _sharnew.tmp; then
  echo 'x - still skipping term-2.2.5/spipe.c'
else
  echo 'x - continuing file term-2.2.5/spipe.c'
  sed 's/^X//' << 'SHAR_EOF' >> 'term-2.2.5/spipe.c' &&
X *		
X */
X
X#define I_IOCTL
X#define I_STROPTS
X#define I_ERRNO
X#define I_TYPES
X#define I_STREAM
X#define I_STRING
X#include "includes.h"
X
X#define SPX_DEVICE	"/dev/spx"
X
X/*
X *	Create an un-named stream pipe to replace a socketpair.
X *	From Stevens: UNIX Network Programming.  This is not
X *	covered by SCO copyright.
X */
X
Xint
Xs_pipe(int fd[2])
X{
X	struct strfdinsert ins;
X	queue_t	*pointer;
X
X	/* open clone device /dev/spx twice */
X
X	if ((fd[0] = open(SPX_DEVICE, O_RDWR)) < 0)
X		return -1;
X	if ((fd[1] = open(SPX_DEVICE, O_RDWR)) < 0) {
X		close(fd[0]);
X		return -1;
X	}
X
X	/* link streams together with I_FDINSERT */
X
X	ins.ctlbuf.buf = (char *) &pointer;
X	ins.ctlbuf.maxlen = sizeof(queue_t *);
X	ins.ctlbuf.len = sizeof(queue_t *);
X
X	ins.databuf.buf = (char *) 0;
X	ins.databuf.len = -1;	/* magic -1 for streams pipes */
X	ins.databuf.maxlen = 0;
X
X	ins.fildes = fd[1];	/* the fd to connect */
X	ins.flags = 0;
X	ins.offset = 0;
X
X	if (ioctl(fd[0], I_FDINSERT, (char *) &ins) < 0) {
X		close(fd[0]);
X		close(fd[1]);
X		return -1;
X	}
X	return 0;
X}
X
X/*
X *	Code adapted from SCO X-server to do IPC over
X *	streams pipes.  Thanks SCO.
X */
X
X/*
X *	This is the server side code
X */
X
X
X#define X_UNIX_PATH	"/dev/X"
X
X/* 
X *	This is executed by a server to establish a streams pipe
X *	on which connection requests can be made.
X *
X *	The parameter tells which device to use.  For X, it
X *	is the display number.  When term is configured for
X *	streams pipes, we "borrow" one of the X devices ...
X *
X */
X
Xint
Xopen_stream_pipe (int number)
X{
X	struct flock mylock;		/* Used for fcntl F_SETLK  S012 */
X	struct strfdinsert fdins;	/* Used in FDINSERT ioctl's */
X	int connmaster;			/* Master pipe for making connections */
X	int connother;			/* Other end of connmaster */
X	char mybuf[sizeof (struct file *)]; /* Buffer for FDINSERT message */
X	char strnamebuf[sizeof X_UNIX_PATH + 5];
X  
X  	/*
X  	 * The server creates both ends of a stream pipe on two special
X	 * minor devices of the stream pipe driver.  One of these will be the
X	 * master connection, which is the value we return.  The other we
X	 * simply forget;  we will hold it open as long as the server runs.
X	 *
X	 * The name of the special minor device is "/dev/X<n>[RS]", where
X	 * <n> is the input parameter.  R is the request device (which is
X	 * written to open a connection);  S is the server's end of the
X	 * request device.
X	 */
X
X	sprintf(strnamebuf,"%s%dS", X_UNIX_PATH, number);
X
X	connmaster = open (strnamebuf, O_RDWR | O_NDELAY);
X	if (connmaster < 0) {
X	    fprintf(stderr, "Can't open %s\n", strnamebuf);
X	    return -1;
X	}
X
X	/* S012
X	 * Lock the master connection device.
X	 * This is the atomic operation that resolves
X	 * duplicate server startup races.
X	 * The lock will automagically disappear
X	 * whenever the master is closed.
X	 */
X	mylock.l_type   = F_WRLCK;
X	mylock.l_whence = 0;
X	mylock.l_start  = 0;	/* lock entire "file" */
X	mylock.l_len    = 0;
X	if (fcntl (connmaster, F_SETLK, &mylock) < 0) {
X	    if (errno == EACCES) {
X		fprintf(stderr, "streams pipe %s is busy\n", strnamebuf);
X	    } else {
X		fprintf(stderr, "cannot lock %s\n", strnamebuf);
X	    }
X	    close (connmaster);
X	    return -1;
X	}
X
X	sprintf(strnamebuf,"%s%dR", X_UNIX_PATH, number);
X
X	connother = open (strnamebuf, O_RDWR | O_NDELAY);
X	if (connother < 0) {
X	    fprintf(stderr, "Can't open %s\n", strnamebuf);
X	    close (connmaster);
X	    return -1;
X	}
X	fdins.ctlbuf.maxlen = sizeof mybuf;
X	fdins.ctlbuf.len = sizeof mybuf;
X	fdins.ctlbuf.buf = mybuf;
X	fdins.databuf.maxlen = 0;
X	fdins.databuf.len = -1;
X	fdins.databuf.buf = NULL;
X	fdins.fildes = connother;
X	fdins.offset = 0;
X	fdins.flags = 0;
X
X	if (ioctl (connmaster, I_FDINSERT, &fdins) < 0) {
X	    fprintf(stderr, "cannot pass file descriptor\n");
X	    close (connmaster);
X	    close (connother);
X	    return -1;
X	}
X	return connmaster;
X}
X
X/*
X *	This code (in the server) adds a connection to a new client.
X *	The client has already sent a byte on the "R" pipe, which the
X *	server has noticed.
X */
X
Xaddclient (int connmaster)			/* Add connection to new slave */
X{
X	struct strfdinsert	fdins;	/* Used for FDINSERT on master */
X	int			fd;	/* FD of new connection */
X	char			mybuf[sizeof (struct file *)];
X
X	if (read (connmaster, &fd, 1) != 1)	/* Read the dummy byte */
X	    return -1;
X	fd = open (SPX_DEVICE, O_RDWR);
X	if (fd < 0) {
X	    /* send zero-length msg to client to signal error */
X	    fdins.ctlbuf.buf = mybuf;
X	    fdins.ctlbuf.len = 0;
X	    putmsg (connmaster, &fdins.ctlbuf, NULL, 0);
X	    return -1;
X	}
X
X	fdins.ctlbuf.maxlen = sizeof mybuf;
X	fdins.ctlbuf.len = sizeof mybuf;
X	fdins.ctlbuf.buf = mybuf;
X	fdins.databuf.maxlen = 0;
X	fdins.databuf.len = -1;
X	fdins.databuf.buf = NULL;
X	fdins.fildes = fd;
X	fdins.offset = 0;
X	fdins.flags = 0;
X
X	if (ioctl (connmaster, I_FDINSERT, &fdins) < 0) {
X	    close (fd);
X	    return -1;
X	}
X	return fd;
X}
X
X
X/*
X *	This is the client side code.  "number" is the X
X *	display number to use (or borrow).
X */
X
Xint MakeStreamPipeConnection (int number)
X{
X	int errsave;			/* Place to save errno if trouble */
X	int flags;			/* Flags to getmsg call */
X	int mfd;			/* Fd to talk to master */
X	char mybuf[sizeof (struct file *)]; /* Buffer for linkup message */
X	struct strbuf myctlbuf;		/* Control reception buffer */
X	int retfd;			/* Resulting fd to talk on */
X	static char strnamebuf[sizeof X_UNIX_PATH + 5];
X
X	/*
X	 * The server creates both ends of a stream pipe on two special
X	 * minor devices of the stream pipe driver.  One of these is the
X	 * connection we will make our request on.
X	 */
X
X	sprintf(strnamebuf,"%s%dR",X_UNIX_PATH,number);
X
X	mfd = open (strnamebuf, O_RDWR);
X	if (mfd < 0) {
X	    perror(strnamebuf);
X	    return -1;
X	}
X
X	retfd = open (SPX_DEVICE, O_RDWR);
X	if (retfd < 0) {
X	    perror(SPX_DEVICE);
X	    errsave = errno;
X	    close (mfd);
X	    errno = errsave;
X	    return -1;
X	}
X
X	if (write (mfd, (char *)&mfd, 1) != 1) { /* Ask for a connection */
X	    errsave = errno;
X	    close (retfd);
X	    close (mfd);
X	    errno = errsave;
X	    return -1;
X	}
X
X	myctlbuf.maxlen = sizeof (mybuf);
X	myctlbuf.buf = mybuf;
X	flags = 0;
X
X	/*
X	 *	Get the file descriptor sent by the server
X	 */
X
X	if (getmsg (mfd, &myctlbuf, (struct strbuf *) NULL, &flags) < 0) {
X	    errsave = errno;
X	    close (retfd);
X	    close (mfd);
X	    errno = errsave;
X	    return -1;
X	}
X
X	/*
X	 *	Connect our endpoint to the server's endpoint
X	 */
X
X	if (putmsg (retfd, &myctlbuf, (struct strbuf *) NULL, 0) < 0) {
X	    errsave = errno;
X	    close (retfd);
X	    close (mfd);
X	    errno = errsave;
X	    return -1;
X	}
X	close (mfd);
X	return retfd;
X}
X
Xint
XCheckClientConnection(int socket)
X{
X	char dumb;
X	int s;
X
X	if (ioctl(socket, FIONREAD, &dumb) == -1) {
X		if ((s = addclient(socket)) < 0) {
X			return -1;	/* couldn't add client */
X		} else
X			return s;
X	} else
X		return -2;		/* not a streams pipe */
X}
X
X#else
X/* This keeps "ranlib" from complaining */
Xint s_pipe(int fd[2]){return -1;};
X#endif
SHAR_EOF
  echo 'File term-2.2.5/spipe.c is complete' &&
  $shar_touch -am 1028144694 'term-2.2.5/spipe.c' &&
  chmod 0644 'term-2.2.5/spipe.c' ||
  echo 'restore of term-2.2.5/spipe.c failed'
  shar_count="`wc -c < 'term-2.2.5/spipe.c'`"
  test 8206 -eq "$shar_count" ||
    echo "term-2.2.5/spipe.c: original size 8206, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/statistics.c ==============
if test -f 'term-2.2.5/statistics.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/statistics.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/statistics.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/statistics.c' &&
X#define I_STRING
X#define I_SYS
X#include "includes.h"
X
X
Xvoid do_stats(char *ret, int opt, struct Client *cl) {
X  char buff[20];
X  extern int stat_cooked_out, stat_uncomp_in, stat_uncomp_out,
X  stat_cooked_in, stat_cooked_out;
X  struct timeval t;
X
X  int i;
X  switch(opt) {
X  case -10:
X    if (term_remoteaddr != INADDR_ANY)
X      sprintf(ret, "VERSION %lu %lx %s", remote_term_version, term_remoteaddr,
X        term_remotehost);
X    else
X      sprintf(ret, "VERSION %lu %lx %s", remote_term_version, term_remoteaddr,
X        "remotehost");
X    break;
X  case -9:
X	gettime(&t);
X	sprintf(ret, "%ld %ld", (long)t.tv_sec, (long)t.tv_usec);
X	break;
X  case -8:
X    sprintf(ret, "%d %d", stat_cooked_in, stat_cooked_out);
X    break;
X  case -6:
X    sprintf(ret, "%d", cl->number);
X    break;
X  case -5:
X    sprintf(ret, "%u %d %lu", max_cps, window_size, packet_timeout);
X    break;
X  case -4:
X    sprintf(ret, "%d %d", p_in_num, p_out_num);
X    break;
X  case -3:
X    sprintf(ret,"%d %d %d %d", stat_modem_recv, stat_modem_ack, stat_modem_in, stat_modem_out);
X    break;
X  case -2:			/* Return the compression statistics. */
X    sprintf(ret,"%d %d %d %d", stat_comp_in, stat_comp_out,
X	    stat_uncomp_in, stat_uncomp_out);
X    break;
X  case -1:			/* Return a list of all the active clients.*/
X    ret[0] = 0;
X    for (i = 0; i < MAX_CLIENTS;++i) {
X      if (clients[i].fd >= 0) {
X	sprintf(buff,"%d %d ", i, clients[i].in_buff.size
X			+ clients[i].out_buff.size);
X	strcat(ret, buff);
X      }
X    }
X    break;
X  default:
X    sprintf(ret, "%d %d %d %d %d %d %s", 
X	    clients[opt].fd,
X	    clients[opt].priority,
X	    clients[opt].type,
X	    clients[opt].state,
X	    clients[opt].pid,
X	    clients[opt].number, 
X	    clients[opt].name);
X    
X  }
X}
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/statistics.c' &&
  chmod 0644 'term-2.2.5/statistics.c' ||
  echo 'restore of term-2.2.5/statistics.c failed'
  shar_count="`wc -c < 'term-2.2.5/statistics.c'`"
  test 1736 -eq "$shar_count" ||
    echo "term-2.2.5/statistics.c: original size 1736, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/tclient.c ==============
if test -f 'term-2.2.5/tclient.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/tclient.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/tclient.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/tclient.c' &&
X#include "includes.h"
X#include "client.h"
X
Xint main(int argc, char *argv[]) {
X  int first, s, new, port;
X  char buff[10];
X
X  first = client_options(argc, argv);
X  printf("first is %d\n", first);
X
X
X  s = connect_server(term_server);
X  if ((send_command(s, C_BIND, 0, "%d", 4040)) < 0) {
X    printf("Couldn't run C_BIND.\n");
X    printf("reason given: %s\n", command_result);
X  }
X
X  read(s, buff, 2);
X  printf("buf == %s\n", buff);
X  port = atoi(buff);
X
X  new = connect_server(term_server);
X  if ((send_command(new, C_ACCEPT, 0, "%d", port)) < 0) {
X    printf("C_accept failed.\n");
X    printf("Reason given: %s\n", command_result);
X  }
X  write(new, "Hello.\n", 8);
X  sleep(2);
X  close(new);
X  close(s);
X}
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/tclient.c' &&
  chmod 0644 'term-2.2.5/tclient.c' ||
  echo 'restore of term-2.2.5/tclient.c failed'
  shar_count="`wc -c < 'term-2.2.5/tclient.c'`"
  test 704 -eq "$shar_count" ||
    echo "term-2.2.5/tclient.c: original size 704, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/term.1 ==============
if test -f 'term-2.2.5/term.1' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/term.1 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/term.1 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/term.1' &&
X.TH TERM 1
X.SH NAME
Xterm \- server for multiple communication channels on a serial link
X.SH SYNOPSIS
X.na
X.B "term "
X[-s speed] [-n on|off] [-c on|off] [-S on|off] [-r] [-f arg]
X[-w arg] [-t arg] [-o] [-a] [-d lev] [-l file] [-v file] [-1] [-q] 
X<server>
X.ad
X.SH DESCRIPTION
X.IR Term
Xand its clients support multiple, compressed, and error-corrected communication 
Xchannels over a regular serial link, typically a modem connection.  
XThe clients can set up channels to run an interactive shell on the other
Xsystem similar to
X.IR rlogin (1),
Xto execute commands on the other system similar to
X.IR rsh (1),
Xto transfer files in either direction, to redirect X server connections
Xfrom one system to the other, or to redirect any network port 
Xconnection from one system to a port on the other.
XAny of these can occur simultaneously, and in either direction.
X.PP
XTo support these multiple clients,
Xa term daemon on each system takes control of the device connected to the modem.
XSo you must compile
X.IR term 
Xand the clients on both systems.
XSource is available by anonymous ftp temporarily from 
X.PP
X\ \ \ physics.purdue.edu:/pub/bcr/term/
X.PP
XNormally source is available by anonymous ftp  from 
X.PP
X\ \ \ tartarus.uwa.edu.au:/pub/oreillym/term/
X.PP
Xand 
X.PP
X\ \ \ nic.funet.fi:/pub/OS/Linux/BETA/
X.PP
Xbut not at the time of this patch.
X.SH DEFINITION
XDue to the fact that anything 
X.IR term
Xand its clients can initiate from one end of the link
Xthey will just as happily initiate from the
Xother, the following frame of reference will be used throughout this 
Xdocumentation.  The remote system refers to the system at the other
Xend of the modem link, and the local host refers to the machine you are
Xtyping on, typically the user's home system.
X.SH USAGE
X.IR Term 
Xis run as a daemon which accepts connections from its clients and establishes
Xchannels for each client's data.  
X.IR Term
Xmust be run on both ends.
XOn the remote system, execute something like
X.PP
X\ \ \ term -r -n off
X.PP
XThen, on the local system, you can exit your comm program and type
X.PP
X\ \ \ term -v /dev/tty?? [-n off] &
X.PP
Xwhere tty?? is the device name for your modem or serial port.
XYou may be able to start the local term from within your comm program,
Xe.g. for xcomm type
X.PP
X\ \ \ control-A x "$ term"
X.PP
XOnce the term daemons are running at both ends they handle the
Xtransmission of data over the link.
XThese clients connect to a local 
X.IR term
Xdaemon which establishes a communication
Xchannel with the remote daemon and/or remote processes.
XThe clients are discussed in detail in
X.IR term_clients (1).
XBriefly,
X.IR trsh
Xruns an interactive shell or commands on the remote system, 
X.IR tupload
Xtransfers files from the local system to the remote,
X.IR tdownload
Xtransfers files from the remote to the local system,
X.IR tredir 
Xredirects connections from a port on the local system to a port on the
Xremote system,
X.IR txconn 
Xredirects X server connections from the local system to the remote,
Xand
X.IR tmon
Xmonitors client statistics.
X.SH OPTIONS
X.IR Term 
Xaccepts a number of command-line options which override settings
Xestablished by the termrc file (see below):
X.TP
X.BR \-S \ off|on
XTurns off|on share mode.  This option is on by default if the program is 
Xset user or group id.
X.TP
X.BR \-c \ off|on
XTurns off compression.  Still does error correction.  Consider this option
Xif you have hardware compression (ie. v.32.bis) or are transferring compressed
Xfiles. The default is to have compression on.
X.TP 
X.BR \-n \ on|off
XTurns on line noise echoing.  Talk requests, writes, and biffs to the login
Xwhich is running term will then appear.  This is a useful option to use on the
Xlocal end (the end you are sitting at).  Without this, you will never see any
Xtalk requests directed to your remote login. Default is off.
X.TP 
X.BR \-f \ off|<number>
XMakes term send XON at specified interval.  Zero is no flow control emulation,
X10 is a single XON every 10 characters. The default is zero. 100 is a
Xreasonable value.
X.TP
X.BR \-s \ off|<number>
XSpecifies a maximum number of bits per second (baudrate) term will try
Xto send over the serial link.  Term will avoid sending characters
Xat a higher data rate than this.  
XThis overrides the BAUDRATE environment variable.
XThe default is to use the speed of your computer's serial port, but
Xbe warned that this may be too high if your modem runs at a lower rate
Xover the phone line.  The baudrate option is intended 
Xfor systems that buffer output to the modem.
XDuring setup and tuning it is better to have <number> be too small
Xrather than too large.  For high speed links (> 38400), making it
Xunlimited is probably advantageous. This is achieved by using the value of
X.IR off.
X.IR term
Xwill then rely solely on your kernel to do flow control.
X.TP
X.BR \-w \ <number>
XSets the transmission window size; that is, the number of
Xunacknowledged packets that term may send.  Lower numbers may lead to
Xbetter interactive response times.  Higher numbers may lead to better
Xthroughput, particularly if the serial link latencies are large and
Xthe timeout length is set large.  Higher numbers can also improve
Xefficiency on noisy lines.  The default is determined as a function
Xof your baudrate.
X.TP
X.BR \-t \ <number>
XTimeout length in 20ths of a second.  This specifies how long term
Xwill wait for an acknowledgement before retransmitting a packet.
XDefault is 70 (i.e. 3.5 seconds), maximum 1000.
XDecreasing both window size and timeouts can lead to less latencies
Xfor interactive work, and faster noise recovery at the expense of
Xtotal throughput speed.
X.TP
X.BR \-r
XUse this on the remote term so that client numbers won't clash.
X.TP
X.BR \-a
XTurns on seven bit line mode.  Use only if you have a seven bit line, as 
Xdetermined by 
X.IR linecheck.
X.TP
X.BR \-l \ <filename>
XOutput all log/noise/debugging to the file <filename>
X.TP
X.BR \-v \ <filename>
XSet the modem device to be <filename>.  Appropriate usage is something like
X"-v/dev/ttys1"
X.TP
X.BR \-1
XUse stdout instead of stdin as the modem port.  This is ignored if a \-v
Xis also present.
X.TP
X.BR \-d \ off|<number>
XThis sets the debugging level.  This is useful for monitoring packet timeout 
Xconditions and other things.  Level 64 is suggested, 478 is verbose.
XRead debug.h and the other source files to find out what the levels do.
XIf you are not familiar with packet protocols and pouring through
Xsource code, then this option is unlikely to help you. 
X.TP
X.BR \-o
XTurns on packet send forcing.  Re-transmits oldest packet if nothing to send.
XDefault off.  Of dubious utility. Not properly debugged. Very bad idea
Xif speed is unlimited.
X.TP
X.BR \-q
XMake term quieter.  Multiple `-q' options make term more quiet.
X.TP 8
X.PD 0
X
X.BR <server>
XUse this to tell term to use a unique socket name. Then for term clients \
Xto work, you will need the following:
X.IP "" 16
Xsetenv \ TERMSERVER \ <server> \ (csh, tcsh)
X.IP "" 8
Xor:
X.IP "" 16
Xexport \ TERMSERVER=<server> \ (sh, bash)
X.IP "" 8
XThis option is normally used only if your machine has multiple modems \
Xso that users can specify which term server they wish to use.
X.RE
X.PD
X.SH INITIALIZATION FILE
XThe file
X.IR termrc 
Xin the 
X.IR .term 
Xdirectory in your home directory may be used to specify default
Xsettings for a user.
XThese settings are overruled by values set in the command line,
Xbut several options can only be set in this file.
XBlank lines and lines beginning with '#' are comments; other lines
Xmust begin with one of the options.
XLegal options are:
X.TP
X.IR escape \ <number>
XThis is one of the most important options for term. Usage is
Xeither 'escape <some decimal number>' or 'escape <start of
Xrange>-<end of range>'. This tells term to never transmit the
Xcharacter or characters in the range. 
XThis is essential for serial lines that aren't fully transparent. For
Xexample, lines that use software flow control will want to
Xdo 'escape 17' and 'escape 19'. 
XIf you only have a seven-bit link, DO NOT use 'escape 128-255', see
Xthe termrc 'sevenbit' option below.
XSee also the 
X.IR linecheck
Xprogram, and 
X.IR term_setup (1).
X.TP
X.IR ignore \ <number>
XThis tells term to silently strip this character if it is received
Xover the serial link.
XIts use should correspond to 'escape' options used
Xby the term on the other system.
XE.g. if you use 'escape 126' on one end, you
Xshould use 'ignore 126' on the other.
X.TP
X.IR compress \ on|off
XTurns the default compression mode on or off. The default
Xis 'compress on'.  With this on, all data will be compressed by term
Xbefore sending over the serial line, and then un-compressed at the
Xother end.  If you are sending already compressed data, it is
Xis slightly more efficient to turn compression off.  Similarly, if your modem
Xalready does compression you may consider leaving it off.  You can turn
Xcompression on and off on a client-by-client basis with the '-c' option
Xfor clients. See 
X.IR term_clients (1).
X.TP
X.IR baudrate \ off|<number>
XThis is used to limit the rate at which
Xterm sends data. Set this to
Xthe minimum of your modem speed, and the computer-to-modem baud rate. 
XValues that are too high will cause packet retransmissions if data is lost;
Xvalues that are too low will cause loss of throughput.
X.IR off
Xwill make your rate unlimited.
X.TP
X.IR timeout \ <number>
XSet the number of 1/20ths of a second to wait before
Xre-sending packets that haven't been acknowledged.
XLow values will provide faster recovery from line noise, but higher
Xvalues are required if the latencies in your link are large.
XValues between 50 and 120 are typical.
XThe default value is 70.  
X.TP
X.IR noise \ on|off
XIf this is set, then term will send anything it doesn't
Xunderstand to the standard error or the \-l file. 
XThis is where talk requests, mail biffs, writes, and corrupted packets
Xwill end up. 
XThis is recommended for the local end. 
X.TP
X.IR remote
XThis should be set on the remote side.  It should always be specified on one
Xand only one end of the link.  This prevents client number clashes, and
Xdetermines which server says hello first.
X.TP
X.IR window \ <number>
XThis set the maximum number of packets that can be outstanding the large the
Xvalue, the better your maximum possible transmission speed, but if it is
Xtoo large, it will take a long to recover from timeout errors!  Allowed
Xvalues are 1-16.  The default is based on your baudrate. 
X.TP
X.IR shift \ <number>
XThis sets a 'shift' value. This number is XOR'ed with all bytes before they
Xare sent and dramatically reduces the # of escape characters sent.  Typically
Xnumbers between 224 and 255 give the best results.
X.TP
X.IR sevenbit \ on|off
XUse this if you are running on a 7 bit line.  By default this is off.
X.TP
X.IR seven_in \ on|off
XUse this if your incoming line is seven bit or you need to escape most of the
Xcharacters between 128 and 255.  If 
X.IR seven_in
Xis
X.IR on
Xat one machine, 
X.IR seven_out
Xmust be 
X.IR on
Xat on the other machine.
X.TP
X.IR seven_out \ on|off
XUse your outgoing line is seven bit. See
X.IR seven_in.
X.TP
X.IR stopbits \ <number>
XThis is used in the transmission speed calculations.  The default value is 1.
XFractional values may be specified; 0.5 appears to be typical for modern 
Xmodems with error correction.
X.TP
X.IR denyrsh \ on|off
XThis allows you to block incoming execution requests.  The default is off.
X.TP
X.IR chroot \ <pathname>
XThis performs a chroot() to the specified path, just before entering main loop.
XThis option might cause problems if term is started by anybody except root.
XSee 
X.IR chroot.1
Xfor more information.
X.TP
X.IR share \ on|off
XThis controls whether other users my access the term socket by setting
Xthe TERMMODE and TERMSHARE environmental variables, and using SUID -or-
XSGID programs.
X.TP
X.IR chdir \ <pathname>
XThis makes the default directory the specified path.
X.TP
X.IR login \ on|off
XUse this to specify you don't want "trsh" to default with a login shell.
XThe default is off.
X.TP
X.IR quiet \ <number>
XThis sets the "quietness level", zero by default.  This is equivalent to
X[-q], but only takes effect after reading the termrc, so it has no effect
Xon the initial messages printed before reading termrc. 
X.TP
X.IR terminate \ <string>
XThis sets a string that will cause term to exit, and is '00000' by default.
XTo help prevent accidently terminations this must be at least 5 characters
Xlong.
X.TP
X.IR shell \ <command>
XThis specifies some command you want to be given as soon as you execute your
Xfirst term command.  Normally this should be a script name.
X.TP
X.IR blocksize \ <number>
XUse this to set the maximum size block that can be written to your modem
Xat once.  Typical values are 256, 512, or 1024.  The default is 512 and
Xyou probably don't need to change this.
X.TP
X.IR collisions \ on|off
XUse this if you get lots of timeout errors only when transmitting and 
Xreceiving at the same time.
X.TP
X.IR flowcontrol \ off|<number>
XUse this to tell term to generate control-Q's every now and then
Xin case your terminal server understands flow control and things 
Xaccidently turn it off, i.e. line noise.  This is off by default,
Xbut may be set to any non-negative value.
X.TP
X.IR increment \ <number>
XThis controls how many times a second term tries to send data.  Normally
Xthe default of 20 should be fine, but if you are using term to get by
Xa firewall, you might improve your transmission speeds by raising this.
X.TP
X.IR packetsize \ <number>
XThis is the maximum size packet term will use.  The default is 256 and
Xyou probably won't need to change this.  Valid values are anything between
X1 and 256.
X.TP
X.IR hangup_on_exit \ on|off
XThe local term will hang up the line when it exits (typically by waiting
Xone second, sending "+++", waiting another second, and sending "ath0").
XOff by default.
X.TP
X.IR explicit_hangup \ on|off
XIf set to off, term won't bother to send "ath0" for hangup_on_exit (above).
XOn by default.
X
X.SH ENVIRONMENT VARIABLES
X.TP
X.BR BAUDRATE
XUsed to set the speed.  Overridden by termrc or command line setting.
X.TP 
X.BR SHELL
XDefault shell for 
X.IR trsh.
X.TP
X.BR TERMDIR
XWhere to find the .term directory in private mode.  This directory will
Xcontain the socket used by all term clients.  The default is HOME.
X.TP
X.BR TERMSHARE
XWhere term runs from in shared mode.  The default is /usr/local/lib/term.
X.TP
X.BR TERMMODE
XWhat mode term will attempt to use. 0 == private, 1 == system shared,
X2 == user shared.
X.TP
X.BR TERMSERVER
XThis should specify the <server> name, if you used one.
X.SH DIAGNOSTICS
XThe 
X.B \-d
Xoption provides debugging output.  See 
X.IR term_setup (1)
Xor
X.IR linecheck (1)
Xfor further diagnostic information.
X.SH SEE ALSO
X.TP
X.IR term_clients (1)
XThe man page for the 
X.IR term
Xclients.
X.TP
X.IR term_setup (1)
XThe man page for 
X.IR term
Xsetup.
X.TP
X.IR linecheck (1)
XThe manual page for the
X.IR linecheck
Xprogram for
Xdebugging your serial link.
X.TP
X.IR termtest (1)
XThe manual page for the
X.IR termtest
Xprogram for
Xexercising 
X.IR term
Xand clients.
X.TP
X.IR term/INSTALL
XDocuments how to install 
X.IR term 
Xon your machine.
X.TP
X.IR term/README
XThe original documents for 
X.IR term 
Xfrom which these man pages were written.
X.TP
X.IR term/README.security
XDescribes in more detail how 
X.IR term's
Xshared mode works.
X.TP
X.IR term/README.porting
XHow to compile and link network-using programs to take advantage of term's
Xtransparent network emulation.
X.TP
X.IR term/Term.HOWTO
XA detailed description of how to make term work.  It may be somewhat
Xout of date with the current version of
X.IR term.
X.TP
X.IR term/FAQ
XAnswers to some frequently asked questions.
X.TP
X.IR term/TERMRC
XAnother description of the syntax and options the user may set in ~/.term/termrc.
X.TP
X.IR term/CREDITS
XCredits for many of the people who have contributed to 
X.IR term.
X.TP
X.IR term/CHANGES
XA list of changes to the program since these manuals were edited (version 
X1.19).
X.SH BUGS
XIf a remote client stops consuming its input but leaves the channel
Xopen,  the local term daemon will continue to resend unacked packets.
X.IR Term 
Xby default requires a line which passes through all ascii values from 0 to
X255.  Xyplex-type terminal servers may require the use of set session passall
Xto work correctly.
X.SH AUTHOR
XMichael O'Reilly, michael@iinet.com.au
X.br
XBill C. Riemers, bcr@physics.purdue.edu, is temporarily maintaining term.
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/term.1' &&
  chmod 0644 'term-2.2.5/term.1' ||
  echo 'restore of term-2.2.5/term.1 failed'
  shar_count="`wc -c < 'term-2.2.5/term.1'`"
  test 16226 -eq "$shar_count" ||
    echo "term-2.2.5/term.1: original size 16226, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/term_clients.1 ==============
if test -f 'term-2.2.5/term_clients.1' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/term_clients.1 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/term_clients.1 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/term_clients.1' &&
X.TH TERM_CLIENTS 1
X.SH NAME
Xtrsh, tupload, tdownload, tredir, tudpredir, txconn, tmon, tshutdown, trdate, 
Xtrdated \- clients to term
X.SH SYNOPSIS
X.IR trsh 
X[\-S\ on|off] [\-p\ <number>] [\-t\ <server>] [\-c] [\-r] [\-v]
X[\-s] [<command>]
X.PP
X.IR tupload 
X[\-S\ on|off] [\-p\ <number>] [\-t\ <server>] [\-c] [\-r] [\-v]
X[\-f] [\-u] [\-q] <local\ file> [\-\-as\ <remote\ file>]
X[<local\ file> [\-\-as\ <remote\ file>] ...] [<remote\ directory>]
X.PP
X.IR tdownload 
X[\-S\ on|off] [\-p\ <number>] [\-t\ <server>] [\-c] [\-r] [\-v]
X[\-f] [\-u] [\-q] <local\ file> [\-\-as\ <local\ file>]
X[<local\ file> [\-\-as\ <local\ file>] ...] [<local directory>]
X.PP
X.IR tredir 
X[\-S\ on|off] [\-p\ <number>] [\-t\ <server>] [\-c] [\-r] [\-v]
X<local\ port> [<remote\ host>:]<remote\ port> 
X[<local\ port> [<remote\ host>:]<remote\ port> ...]
X.PP
X.IR tudpredir 
X[\-S\ on|off] [\-p\ <number>] [\-t\ <server>] [\-c] [\-r] [\-v]
X<local\ port> [<remote\ host>:]<remote\ port> 
X[<local\ port> [<remote\ host>:]<remote\ port> ...]
X.PP
X.IR txconn 
X[\-S\ on|off] [\-p\ <number>] [\-t\ <server>] [\-c] [\-r] [\-v]
X[<local display>]
X.PP
X.IR tmon
X[\-S\ on|off] [\-p\ <number>] [\-t\ <server>] [\-c] [\-r] [\-v]
X.PP
X.IR tshutdown
X[\-S\ on|off] [\-p\ <number>] [\-t\ <server>] [\-c] [\-r] [\-v]
X[\-h] [\-n]
X.PP
X.IR trdate
X[\-S\ on|off] [\-p\ <number>] [\-t\ <server>] [\-c] [\-r] [\-v]
X.PP
X.IR trdated
X[\-S\ on|off] [\-p\ <number>] [\-t\ <server>] [\-c] [\-r] [\-v]
X[\-d\ <delay>]
X.SH DESCRIPTION
XThese clients connect to a local 
X.IR term (1)
Xdaemon and initiate a communication
Xlink with the remote daemon and remote processes.
X.IR Trsh
Xruns an interactive shell or commands on the remote system, 
X.IR tupload
Xtransfers files from the local system to the remote, and
X.IR tdownload
Xdoes the reverse.
X.IR tredir
Xand
X.IR tupdredir
Xredirect connections from ports on the local system to ports on a
Xremote system (TCP or UDP respectively),
X.IR txconn 
Xredirects X server connections from the local system to the remote,
Xand
X.IR tmon
Xprints summary information about a 
X.IR term 
Xlink.
X.PP
XAs far as the clients are concerned,
Xthe link established by
X.IR term (1)
Xis completely symmetric; the clients don't know
Xwhich system is your physically local system (the system you're typing at) and
Xwhich is physically remote.
XFrom a client's point of view, the local system is the one on which
Xthe client is executing.
XThe remote system is the other system, the one on which the client is
Xnot executing.
X.SH USAGE
X.TP
X.IR "trsh \ \ \ "
XWith no arguments,
X.IR trsh 
Xis similar to 
X.IR rlogin (1).
XAn interactive shell is started on the remote system.  
XTerminal features such as character echoing, line editing, and window
Xresizing are handled by a tty on the remote system.
XIf a \fIcommand\fR is given, it executes on the remote system instead of
Xthe default shell.
XSpecifying \fIcommand\fR without the \-s option is primarily useful
Xfor starting a non-default shell remotely.
X.TP
X.IR 
XThere is a single
X.IR trsh
Xspecific option:
X.IR 
X.RS
X.TP
X.BR \-s
XUse a simple connection.
XThis makes 
X.IR trsh
Xbehave more like
X.IR rsh (1).
XThe specified \fIcommand\fR is executed by a shell on the remote
Xsystem.
XLike
X.IR rsh (1),
Xquoted shell metacharacters are interpreted remotely, so filename
Xredirection, multiple commands, or pipes can be used remotely.
XIf no \fIcommand\fR is given, the \-s option is ignored.
X.PP
XThe \-s option should almost always be used 
Xwhen a \fIcommand\fR is provided.
XIn particular, it should be used if 
X.IR trsh
Xis part of a pipeline.
XThe only exception to this rule is when
Xremote terminal features are needed.
X.RE
X.TP
X.IR 
X.IR Trsh
Xdiffers from 
X.IR rlogin (1)
Xand
X.IR rsh (1)
Xin a couple of significant ways.  First, the stdout and stderr of the
Xremote shell or command are both directed to the local stdout.
XSecond, the connection is broken as soon as a local end-of-file occurs.
XThis means that any output generated by the remote system after EOF is
Xlost.
XFor example,
X.TP
X.IR 
X.IR 
X\ \ \ trsh -s wc < /etc/passwd
X.TP
X.IR 
Xruns the remote 
X.IR wc (1)
Xcommand on the contents of the local /etc/passwd, but will not produce any output.
X.TP
X.IR tredir
X.IR Tredir
Xaccept pairs of port numbers, the first of each being the local port
Xnumber to redirect, and the second the remote port to redirect into.  
XThey will also accept
Xa hostname with each of the second port numbers.  For example, 
X.TP
X.IR 
X\ \ \ tredir\ 119\ my.nntp.host:119
X.TP
X.IR 
Xcan be run on the non-internet side of the link.
XThen, any local program  
Xthat connects to port 119 (like an NNTP newsreader), will be connected to
Xport 119 on my.nntp.host.
X.IR Tredir
Xbecomes a background daemon once it has successfully established the
Xlocal port. More than one port can be redirected at once with a single
X.IR tredir.
XFor example,
X.TP
X.IR 
X\ \ \ tredir\ 119\ my.nntp.host:119\ 4000\ remote.home:23
X.TP
X.IR 
Xwould redirect ports 119 and 4000, 119 to the nntp port on
Xmy.nntp.host, and port 4000 to the login port on remote.host.
X.IR Tredir
Xhandles redirecting TCP ports.
X.TP
X.IR tudpredir
X.IR Tudpredir
Xworks similarly to 
X.IR tredir
Xexcept a UDP port is redirected instead of a TCP port.  One important
Xdifference is
X.IR tudpredir
Xcommands must be placed in the background manually.
X.TP 
X.IR tupload
X.IR Tupload
Xtakes a list of local file names to upload. If there is more than one name, 
Xthen the last name is checked to see if it matches a remote directory.
XIf it does match a remote directory, the files are uploaded
Xto this directory.  If a previous upload was aborted without modifying
Xeither the local or remote file, then the upload will be resumed.
X.IR 
XTupload specific options are:
X.RS
X.TP
X.BR \-f
XTells 
X.IR upload 
Xto force the upload by overwriting the file if it can't resume.
X.TP
X.BR \-u
XUnlink the local file after a successful upload.
X.TP
X.BR \-v
XVerbose mode. Will write out the number of bytes transferred, the name
Xof the remote file, and the CPS rate. Two 'v's will produce more
Xoutput; note, however, that the "current CPS" values shown will be less 
Xaccurate at the beginning and end of the upload, since tupload has no 
Xdirect knowledge about how fast term is sending data.
X.TP
X.BR \-q
XQuiet mode. Tupload will not write out any messages.
X.TP
X.BR \-\-as\ <remote\ file>
XAny of the local \fIfile\fR names may be followed by the \-\-as
X<remote\ file> option to specify a new name for the remote copy of the
Xfile. 
XBy default the remote file will have the same name as the local file.
X.RE
X.TP
X.IR tdownload
X.IR Tdownload
Xtakes the same arguments as 
X.IR tupload,
Xbut uses them to transfer the file(s) in the opposite direction.
XIf the last name is a local directory, it is used to put all the
Xfiles in.  One or more local files may be specified "-\-as -" and the 
Xfile's data will be sent to stdout.
X.TP
X.IR txconn
X.IR Txconn
Xestablishes an X screen port on the system it is run on.
XConnections to that screen will be redirected to the X server on the
Xother system.
XIf your DISPLAY environment variable is set,
X.IR txconn
Xwill try to use the screen number given by DISPLAY.
X.IR Txconn
Xprints the number of the screen it actually establishes in a format
Xsuitable for re-setting your DISPLAY variable.
XThe recommended method of starting
X.IR txconn
Xand setting your DISPLAY variable at the same time is to run
X.TP
X.IR 
X.TP
X.IR 
X\ \ \ setenv \ DISPLAY \ `hostname`:0
X.TP
X.IR 
X\ \ \ setenv \ DISPLAY \ `txconn`
X.TP
X.IR 
Xfrom csh and related shells, or
X.TP
X.IR 
X.IR 
X\ \ \ export \ DISPLAY \ `hostname`:0
X.TP
X.IR 
X\ \ \ export \ DISPLAY=`txconn`
X.TP
X.IR 
Xfrom sh and related shells.  Later trsh calls will have this preset.
X.IR Txconn
Xbecomes a background daemon
Xonce it has successfully established the port.
X.TP
X.IR tmon
X.IR Tmon
Xperiodically queries the 
X.IR term
Xdaemon for information about the number of clients and the
Xdata flow-rate of the channels.
XIt updates its output on the terminal it is running in.
X.TP
X.IR tshutdown
X.IR Tshutdown
Xcloses all
X.IR term
Xclients and stops both the local and remote
X.IR term
Xservers.  Sometimes a crashed client will keep this from working.
XIn that case you can blast the
X.IR term
Xservers by typing Control-C to kill the local server, then
Xechoing 00000 to your modem device multiple times to kill the remote server.
X
X.IR Tshutdown 
Xwill take a '-h' argument to request the local term perform a hangup
Xon exit, or a '-n' argument to request no hangup.  The default is set
Xby the "hangup_on_exit" option in the termrc file.  Tshutdown will only
Xwork if the modem accepts +++AT commands.
X.TP
X.IR trdate/trdated
X.IR Trdate
Xis a time setting utility. It will read the time on the remote
Xsystem and set the local clock to the remote time. It attempts to take into
Xaccount the delay in getting the data across the link by adding half the
Xtime taken to get the info onto the time it receives. 
X.TP
X.IR 
XWhen run with a 'd' as the last character of the name, trdated will set the
Xtime every 5 minutes. It can thus be started in
X.IR rc.local
Xand run as a daemon. If it does not find a term connection it will ignore the error silently
Xso it can run when there is no term connection.
X.TP
X.IR 
X.IR trdate/trdated
Xmay only be used by root.
X.RS
X.TP
X.BR \-v
XVerbose mode. Tmon will output details as it goes.
X.TP
X.BR \-d\ delay
XChange delay. Only valid in daemon mode. Sets the delay between time
Xqueries to
X.IR delay
Xseconds. Default is 300 seconds (5 minutes).
X.RE
X
X
X.SH GLOBAL OPTIONS
XThe following options are accepted by all 
X.IR term 
Xclients
X.TP
X.BR \-S \ on
XSpecifies to connection is to a shared server.  (Default if set user or
Xgroup id.)
X.TP
X.BR \-S \ off
XSpecifies to connection is to a private server.
X.TP
X.BR \-c
XSpecifies a compressing link.  All clients 
Xuse compression by default.
X.TP
X.BR \-p \ <number>
XSpecifies priority for this link.  A client with higher priority will be able
Xto send its data faster than lower priority clients.  This may be changed in 
Xfuture releases.  
XThe priority of
X.IR trsh
Xdefaults to 10 and
X.IR tupload/tdownload
Xdefault to -5.  All other clients default to zero.  Valid numbers are between
X-20 and 20.
X.BR \-r
XSpecifies a raw link (no compression).
X.TP
X.BR \-t \ <server>
XSpecifies which term daemon socket to connect to (~/.term/socket<server>).
XThis is useful if you have specific socket names for connections to
Xspecific remote hosts, or if
Xyou have multiple terms using different serial connections.
X.TP
X.BR \-v
XVerbose.  See each client's listing for what information this will print.
X.TP
X.BR \-vv
XVery verbose.  See each client's listing for what information this will print.
X.TP
X.PP
X.SH EXAMPLES
XSome simple, contrived examples:
X.PP
X.IR 
X\ \ \ trsh
X.PP
XThis establishes an interactive shell on the remote machine.  The
Xconnection is maintained until you exit the remote shell.
X.PP
X.IR 
X\ \ \ trsh -s who
X.PP
Xprints out a list of current users of the remote machine.
X.PP
X.IR 
X\ \ \ ls -li | awk '{print $1, $5}' | trsh -s plot
X.PP
Xwill generate a scatter plot of file size vs inode.
XMost likely this would be run on the physically remote system to
Xproduce local graphical output about the files on the remote system.
X.PP
X.IR 
X\ \ \ tupload -vv -r lin-0.99.3.tar.Z --as lin993.tar.Z /new
X.PP
XThis will upload the local file 'lin-0.99.3.tar.Z' to the remote system
Xwith the name '/new/lin993.tar.Z'. It will resume an upload if
Xthere is an existing /new/lin993.tar.Z, and will write out the CPS
Xand bytes transferred every so often. It will not do compression on the way. 
X.PP
X.IR 
X\ \ \ tredir 6667 munagin.ee.mu.oz.au:6500 9017 17
X.PP
XThis will map any connections to port 6667 on your local host to port
X6500 on munagin.ee.mu.oz.au and any connections on your local host to port
X9017 to port 17 on the remote machine.
XSo if you do 'telnet 0 6667' locally, you will be
Xconnected to port 6500 on munagin, and if you do 'telnet 0 9017', you will
Xbe connected to port 17 on the remote machine.
X.PP 
XLet's say the physically remote machine, earlobe.mit.edu, is on
Xthe internet.
XYou can establish a port on earlobe which will allow anyone on the
Xinternet to telnet to your physically local, non-internet machine.
XOn the local machine you could type
X.PP
X.IR 
X\ \ \ trsh -s tredir 4000 23
X.PP
XAlternatively, if you already have an interactive shell on the remote
Xmachine you could just run the tredir command from that shell.
XIn either case, once the tredir daemon is running, users typing
X.PP
X.IR 
X\ \ \ telnet earlobe.mit.edu 4000
X.PP
Xfrom any internet host will get a login prompt from your physically
Xlocal machine.
X.SH ENVIRONMENT VARIABLES
X.TP
X.BR SHELL
XDefault shell for 
X.IR trsh.
X.TP 
X.BR DISPLAY
XUsed by 
X.IR txconn 
Xto determine which X server port to use.
X.TP
X.BR TERMDIR
XWhere to find the .term directory in private mode.  This directory will
Xcontain the socket used by all term clients.  The default is HOME.
X.TP
X.BR TERMSHARE
XWhere term runs from in shared mode.  The default is /usr/local/lib/term.
X.TP
X.PD 0
X
X.BR TERMMODE
XWhat mode term will attempt to use.
X.IP "" 16
X0 == private
X.IP "" 16
X1 == system shared
X.IP "" 16
X2 == user shared
X.PD
X.TP
X.BR TERMSERVER
XThis should specify the <server> name, if you used one.
X.SH BUGS
XIf the remote command for 'trsh -s <command>' doesn't consume its
Xinput fast enough, the channel can lose data.
X.IR Trsh 
Xbreaks the channel as soon as the local EOF is received, thus losing
Xany final output from the remote process.
X.IR Tmon
Xgives bogus output on some machines (e.g. NeXT).
X.SH SEE ALSO
X.IR term (1),
X.IR termtest (1),
X.IR term_setup (1),
X.IR linecheck (1).
X.SH AUTHOR
XMichael O'Reilly, michael@iinet.com.au
X.br
XBill C. Riemers, bcr@physics.purdue.edu, is temporarily maintaining term.
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/term_clients.1' &&
  chmod 0644 'term-2.2.5/term_clients.1' ||
  echo 'restore of term-2.2.5/term_clients.1 failed'
  shar_count="`wc -c < 'term-2.2.5/term_clients.1'`"
  test 13612 -eq "$shar_count" ||
    echo "term-2.2.5/term_clients.1: original size 13612, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/term_clients.c ==============
if test -f 'term-2.2.5/term_clients.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/term_clients.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/term_clients.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/term_clients.c' &&
X/*
X * This combines all term clients into one binary to save 
X * disk space for those with very small disk space quotas.
X *
X */
X
X#define I_STRING
X#include "includes.h"
X
Xint trdate(int,char **);
Xint tdownload(int,char **);
Xint tupload(int,char **);
Xint tudpredir(int,char **);
Xint tredir(int,char **);
Xint tmon(int,char **);
Xint tshutdown(int,char **);
Xint trsh(int,char **);
Xint txconn(int,char **);
X
Xint main(int argc, char *argv[])
X{
X  char *p,*q=NULL;
X
X  if(argv[0]) {
X
X    for(p = argv[0];p;p = strchr(p,'/')) q=p++;
X  
X    while(*q == '-' || *q == '/') ++q;
X  
X    if (!strcmp(q,"trdate")) 
X      exit(trdate(argc,argv));
X    else if (!strcmp(q,"trdated")) 
X      exit(trdate(argc,argv));
X    else if (!strcmp(q,"tdownload")) 
X      exit(tdownload(argc,argv));
X    else if (!strcmp(q,"tupload")) 
X      exit(tupload(argc,argv));
X    else if (!strcmp(q,"tudpredir")) 
X      exit(tudpredir(argc,argv));
X    else if (!strcmp(q,"tredir")) 
X      exit(tredir(argc,argv));
X    else if (!strcmp(q,"tmon")) 
X      exit(tmon(argc,argv));
X    else if (!strcmp(q,"tshutdown")) 
X      exit(tshutdown(argc,argv));
X    else if (!strcmp(q,"trsh")) 
X      exit(trsh(argc,argv));
X    else if (!strcmp(q,"txconn")) 
X      exit(txconn(argc,argv));
X  }
X  fprintf(stderr,"Unrecognized program name.\n");
X  exit(1);
X}
X  
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/term_clients.c' &&
  chmod 0644 'term-2.2.5/term_clients.c' ||
  echo 'restore of term-2.2.5/term_clients.c failed'
  shar_count="`wc -c < 'term-2.2.5/term_clients.c'`"
  test 1304 -eq "$shar_count" ||
    echo "term-2.2.5/term_clients.c: original size 1304, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/term_getopt.c ==============
if test -f 'term-2.2.5/term_getopt.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/term_getopt.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/term_getopt.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/term_getopt.c' &&
X/*
X * Copyright (c) 1987 Regents of the University of California.
X * All rights reserved.
X *
X * Redistributions and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *     This product includes software developed by the University of
X *     California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#if defined(LIBC_SCCS) && !defined(lint)
Xstatic char sccsid[] = "@(#)getopt.c   4.13 (Berkeley) 2/23/91";
X#endif /* LIBC_SCCS and not lint */
X
X#define I_STRING
X#include "includes.h"
X
X/* When redefining a system routine, we have to make sure to exactly match
X   any prototypes.  Linux prototypes getopt() with const arguments; other
X   systems probably do too.  Hopefully __STDC__ is close enough; if not,
X   add system-specific preprocessor changes. */
X
X#if __STDC__
X#define CONST const
X#else
X#define CONST
X#endif
X
X/*
X * get option letter from argument vector
X */
Xint    term_opterr = 1,             /* if error message should be printed */
X       term_optind = 1,             /* index into parent argv vector */
X       term_optopt;                 /* character checked for validity */
Xchar   *term_optarg;                /* argument associated with option */
X
X#define        BADCH   (int)'?'
X#define        EMSG    ""
X
Xint term_getopt(nargc, nargv, ostr)
X       int nargc;
X       char * CONST *nargv;
X       CONST char *ostr;
X{
X       static char *place = EMSG;              /* option letter processing */
X       register char *oli;                     /* option letter list index */
X       char *p;
X
X       if (!*place) {                          /* update scanning pointer */
X               if (term_optind >= nargc || *(place = nargv[term_optind]) != '-') {
X                       place = EMSG;
X                       return(EOF);
X               }
X               if (place[1] && *++place == '-') {      /* found "--" */
X                       ++term_optind;
X                       place = EMSG;
X                       return(EOF);
X               }
X       }                                       /* option letter okay? */
X       if ((term_optopt = (int)*place++) == (int)':' ||
X           !(oli = strchr(ostr, term_optopt))) {
X               /*
X                * if the user didn't specify '-' as an option,
X                * assume it means EOF.
X                */
X               if (term_optopt == (int)'-')
X                       return(EOF);
X               if (!*place)
X                       ++term_optind;
X               if (term_opterr) {
X                       if (!(p = strrchr(*nargv, '/')))
X                               p = *nargv;
X                       else
X                               ++p;
X                       (void)fprintf(stderr, "%s: illegal option -- %c\n",
X                           p, term_optopt);
X               }
X               return(BADCH);
X       }
X       if (*++oli != ':') {                    /* don't need argument */
X               term_optarg = NULL;
X               if (!*place)
X                       ++term_optind;
X       }
X       else {                                  /* need an argument */
X               if (*place)                     /* no white space */
X                       term_optarg = place;
X               else if (nargc <= ++term_optind) {   /* no arg */
X                       place = EMSG;
X                       if (!(p = strrchr(*nargv, '/')))
X                               p = *nargv;
X                       else
X                               ++p;
X                       if (term_opterr)
X                               (void)fprintf(stderr,
X                                   "%s: option requires an argument -- %c\n",
X                                   p, term_optopt);
X                       return(BADCH);
X               }
X               else                            /* white space */
X                       term_optarg = nargv[term_optind];
X               place = EMSG;
X               ++term_optind;
X       }
X       return(term_optopt);                         /* dump back option letter */
X}
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/term_getopt.c' &&
  chmod 0644 'term-2.2.5/term_getopt.c' ||
  echo 'restore of term-2.2.5/term_getopt.c failed'
  shar_count="`wc -c < 'term-2.2.5/term_getopt.c'`"
  test 5500 -eq "$shar_count" ||
    echo "term-2.2.5/term_getopt.c: original size 5500, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/term_main.h ==============
if test -f 'term-2.2.5/term_main.h' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/term_main.h (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/term_main.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/term_main.h' &&
X
X#include "client.h"
X
X#if defined(_AIX) || defined(sgi)
X#define SANITY(a) ((a) ? (void) 0 : (fprintf(stderr, "fatal: line %d file %s\n", \
X __LINE__, __FILE__), abort(), (void) 1))
X#else
X#define SANITY(a) ((a) ? 0 : (fprintf(stderr, "fatal: line %d file %s\n", \
X __LINE__, __FILE__), abort(),1)) /* '1' keeps Ultrix MIPS compiler happy */
X#endif
X
X/* #define BUFFER_SIZE     2048 Already defined in client.h */
X/* global junk */
X#define MAX_CLIENTS 	64
X#define N_PACKETS       32
X#define SWITCH		'@'
X
X#define MAX_TYPE	5 /* There are 5 different types of packets */
X/* these are: */
X/*	uncompress packet */
X/* 	compressed packet */
X/*      packed (sevenbit) packet */
X/*	ack packet */
X/*	super ack packet */
X
X/* main.c */
Xextern unsigned long current_time, packet_timeout, remote_term_version,
X  term_localaddr, term_remoteaddr;
X
Xextern char term_localhost[256], term_remotehost[256];
Xextern int
X	remote,
X	clients_waiting,
X        term_debug, 
X        rshtype,
X        window_size,
X        window_size_max,
X        write_noise,
X        byte_shift,
X        termerrno,
X        seven_bit_in,
X        seven_bit_out,
X        in_mask,
X        out_mask,
X        packet_len,
X	block_size,
X        max_cps,
X        auto_retrain,
X        stat_comp_in,
X        stat_comp_out,
X        stat_modem_in,
X        stat_modem_recv,
X        stat_modem_out,
X        stat_modem_ack,
X	savedeid,
X	share,
X        term_inc;
X
Xextern char escapes[], ignores[];
X
X#define T_SMART		1
X#define T_LOCAL         2
X#define T_RDFILE	4
X#define T_WRFILE	8
X
X#define T_UDP		16 /* tell term to use recvfrom_i_b and sendto_f_b instead of read_i_b etc */
X
X/* clients[x].udp_type.. tells the client what to do 
X * with the incoming/outgoing udp packets
X */
X
X#define UDP_RECADD 1
X#define UDP_RECKEEP 2
X#define UDP_SENDSTRP 4
X
X#define UDP_T_SENDSTRIPHDR 1   /* strip header before sendto()ing... */
X                               /* basically for the remote term... */
X                               /* for now we use it on both ends. I'd like to
X                                  use this for proper setting of host when recvfrom()'ing */
X#define UDP_T_SENDIGNOREHDR 2  /* ignore the address in the header when sendto()ing */
X#define UDP_T_RECADDHDR 4      /* add a header when receiving packets */
X
X/* RECADDHDR and SENDSTRIPHDR are there in case the termnet-compiled program wants to handle 
X * the header itself. eg: for correct assignment of address in recvfrom (coming soon :)
X */
X
X
X#define CL_CHILD        1
X#define CL_SOCKET       2
X#define CL_FILE         3
X#define CL_BOUND        4
X#if defined(STREAMS_PIPE) || defined(X_STREAMS_PIPE)
X#define CL_SPIPE	5
X#endif
X
Xextern struct Client {
X    struct Buffer in_buff,
X		out_buff,
X		in_msg,
X		out_msg;
X    int fd;			/* socket file descriptor. */
X    int priority;		/* How many packets may be queued */
X    int queue;
X    int cl_type;		/* What type of fd are we watching. */
X    int type;			/* dumb or smart */
X				/* This basically gets down to being */
X				/* remote or not, but Clients can */
X				/* lower their status. */
X    long dump_count;
X    int state;			/* one of */
X				/* not used */
X				/* alive, or closing down */
X				/* 5 = connection pending */
X    unsigned long timeout;	/* What time the connection will time out */
X    int compress;		/* does this client want compression? */
X    int pid;
X    int c_state;
X    un_char control[1024];
X    int c_len;
X    int number;
X    char name[20];
X
X
X    unsigned long udp_host;	/* address to send the next incoming packet to */
X    int udp_port;		/* in HOST format! must hton[sl] into struct sockaddr_in's */
X
X    int udp_type; 		/* what to do with incoming, outgoing packets */
X    int udp_size; 		/* size of outgoing udp packets */
X    int parent;			/* This is needed for udp sockets, so they  */
X				/* have some way of knowing when to close. */
X
X    struct sockaddr_in peername; /* This is where the socket is connected from */
X
X    } clients[];
X
Xextern int num_clients;
Xextern int do_shutdown;
Xextern struct Onetime {
X    int socket;
X    unsigned long timeout;
X    } onetime_term[MAX_CLIENTS];
X
X/* serial.c */
Xstruct Packet_out {
X    un_char data[262];
X    int type;		/* flag for compressed or not */
X    int len;
X    unsigned long timeout;	/* What time it will timeout */
X    int trans;
X    int *queue;
X    };
X
Xstruct Packet_in {
X    un_char data[262];
X    int type;
X    int len;
X    };
X
Xextern struct Packet_out p_out[N_PACKETS];
Xextern int p_out_s, p_out_e;
Xextern int p_out_num, p_mismatch;
X
Xextern struct Packet_in p_in[N_PACKETS];
Xextern int p_in_e;
Xextern int p_in_num;
X
Xextern struct Buffer serial_out,
X     serial_in;
X
Xextern void do_serial_in(void);
Xextern void do_serial_out(int );
Xextern void serial_init(void);
Xextern int get_client_byte(void);
Xextern char *term_server;
X
X#if 1
X#define noise(a) do_noise(a)
X#define alert(b) do_alert(b)
X#else
X#define noise(a)
X#define alert(a)
X#endif
X
X/* misc.c */
Xextern void update_time(void);
Xextern void do_debug(int lev, char *c);
X
Xextern void set_nonblock(int);
Xextern int set_block(int);
X#define log(a, b) debug(a, b)
X
Xextern void do_noise(int);
Xextern void do_alert(char *);
X
Xextern char ** rebuild_arg(char *);
X
X/* pty.c */
Xextern void pty_init(void);
Xextern void setup_term(int);
Xextern int open_pty(char *);
Xextern int open_socket(char *);
Xextern int pty_pid;
X/* compress.c */
Xint compress(un_char *, int, int);
Xint uncompress(un_char *data , int len , un_char *outpath);
Xint compress_init(void);
X
Xint write_from_buff(int, struct Buffer *, int size);
Xint read_into_buff(int, struct Buffer *, int size);
Xint add_to_buffer(struct Buffer *B, un_char);
Xint get_from_buffer(struct Buffer *);
Xint recvfrom_into_buff(struct Client *);
Xint sendto_from_buff(struct Client *); 
X
X/* system.c */
Xint open_system(char *);
X
X/* checksum.c */
Xunsigned short check_sum(un_char *d, int len, int mask);
Xunsigned short update_crc(unsigned short old, unsigned char c);
X
X/* meta.c */
Xint meta_state(int);
X
X/* sevenbit.c */
Xint e_2_s_put(un_char *out, un_char data, int key);
Xint s_2_e_buff(un_char *data, un_char *out, int len);
X
X/* utils.c */
Xchar *strerror(int errno);
Xchar *str_version(unsigned long int version);
Xunsigned short file_crc(char *fname, long nbytes);
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/term_main.h' &&
  chmod 0644 'term-2.2.5/term_main.h' ||
  echo 'restore of term-2.2.5/term_main.h failed'
  shar_count="`wc -c < 'term-2.2.5/term_main.h'`"
  test 6165 -eq "$shar_count" ||
    echo "term-2.2.5/term_main.h: original size 6165, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/term_herror.c ==============
if test -f 'term-2.2.5/term_herror.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/term_herror.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/term_herror.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/term_herror.c' &&
X/* 
XFrom metcalf@catfish.LCS.MIT.EDU  Mon Jun 20 10:11:21 1994
XReceived: from catfish.LCS.MIT.EDU (root@localhost)
X	by bohr.physics.purdue.edu (8.6.8.1/3.0-LD) with ESMTP
X	id KAA23719; Mon, 20 Jun 1994 10:11:20 -0500
XReceived: (from metcalf@localhost) by catfish.LCS.MIT.EDU (8.6.9/8.6.9) id LAA05423 for bcr@physics.purdue.edu; Mon, 20 Jun 1994 11:10:55 -0400
XDate: Mon, 20 Jun 1994 11:10:55 -0400
XFrom: Chris Metcalf <metcalf@catfish.LCS.MIT.EDU>
XMessage-Id: <199406201510.LAA05423@catfish.LCS.MIT.EDU>
XTo: bcr@physics.purdue.edu
XSubject: private : figured out "Term: gethostbyname: Error 0" msg
X
XThe right thing to do is call herror() instead of perror() after a failed
Xget*by*() call.  Not all systems have it though (e.g. SunOS 4.x and 5.x
Xand NeXT 2.1 don't; Linux, Ultrix, and HCX/UX all do).  You might try
Xusing the following definition and then using herror() instead.
X*/
X
X#define I_STRING
X#include "includes.h"
X
X
Xchar *term_strherror(int err)
X{
X	static char string[80];
X	switch (err) {
X	case 0:
X		strcpy(string, "Hostname lookup failed; no error reported");
X		break;
X#ifdef HOST_NOT_BOUND
X	case HOST_NOT_FOUND:
X		strcpy(string, "Host not found");
X		break;
X#endif
X#ifdef TRY_AGAIN
X	case TRY_AGAIN:
X		strcpy(string,
X		    "Non-authoritative `host not found', or server failed");
X		break;
X#endif
X#ifdef NO_RECOVERY
X	case NO_RECOVERY:
X		strcpy(string,
X		    "Non-recoverable hostname lookup error");
X		break;
X#endif
X#ifdef NO_DATA
X	case NO_DATA:
X		strcpy(string,
X		    "Valid name, no data record of requested type");
X		break;
X#endif
X	default:
X		sprintf(string, "Hostname lookup error %d", err);
X		break;
X	}
X	return string;
X}
X
X/*
X * Define herror() for systems known to need it.  Those include
X * SunOS 4.x, 5.x; NeXT 2.1.  Systems known not to need it include
X * Linux 1.x, Ultrix 4.4, and HCX/UX 5.1.
X *
X * Provision is made for pre-DNS systems as well.
X */
X
Xextern int h_errno;
X
Xvoid term_herror(char *msg)
X{
X	fprintf(stderr, "%s: %s\n", msg, term_strherror(h_errno));
X}
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/term_herror.c' &&
  chmod 0644 'term-2.2.5/term_herror.c' ||
  echo 'restore of term-2.2.5/term_herror.c failed'
  shar_count="`wc -c < 'term-2.2.5/term_herror.c'`"
  test 1982 -eq "$shar_count" ||
    echo "term-2.2.5/term_herror.c: original size 1982, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/term_putenv.c ==============
if test -f 'term-2.2.5/term_putenv.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/term_putenv.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/term_putenv.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/term_putenv.c' &&
X/*
X * Copyright (c) 1987 Regents of the University of California.
X * All rights reserved.
X *
X * Redistributions and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *	 notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *	 notice, this list of conditions and the following disclaimer in the
X *	 documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *	 must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *	 may be used to endorse or promote products derived from this software
X *	 without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#if defined(LIBC_SCCS) && !defined(lint)
Xstatic char sccsid[] = "@(#)getenv.c 5.8 (Berkeley) 2/23/91";
Xstatic char sccsid[] = "@(#)setenv.c 5.6 (Berkeley) 6/4/91";
Xstatic char sccsid[] = "@(#)putenv.c 5.4 (Berkeley) 2/23/91";
X#endif /* LIBC_SCCS and not lint */
X
X#define I_STRING
X#define I_TYPES
X#include "includes.h"
X
X
X/*
X * _findenv --
X *	Returns pointer to value associated with name, if any, else NULL.
X *	Sets offset to be the offset of the name/value combination in the
X *	environmental array, for use by setenv(3) and unsetenv(3).
X *	Explicitly removes '=' in argument name.
X *
X *	This routine *should* be a static; don't use it.
X */
Xstatic char * putenv_findenv(name, offset)
X	register char *name;
X	int *offset;
X{
X	extern char **environ;
X	register int len;
X	register char **P, *C;
X
X	for (C = name, len = 0; *C && *C != '='; ++C, ++len);
X	for (P = environ; *P; ++P)
X		if (!strncmp(*P, name, len))
X			if (*(C = *P + len) == '=') {
X				*offset = P - environ;
X				return(++C);
X			}
X	return(NULL);
X}
X
X/*
X * setenv --
X *	Set the value of the environmental variable "name" to be
X *	"value".  If rewrite is set, replace any current value.
X */
Xstatic int
Xputenv_setenv(name, value, rewrite)
X	register char *name;
X	register char *value;
X	int rewrite;
X{
X	extern char **environ;
X	static int alloced;			/* if allocated space before */
X	register char *C;
X	int l_value, offset;
X	char *_findenv();
X
X	if (*value == '=')			/* no `=' in value */
X		++value;
X	l_value = strlen(value);
X	if ((C = putenv_findenv(name, &offset))) {	/* find if already exist
X*/
X		if (!rewrite)
X			return (0);
X		if (strlen(C) >= l_value) {	/* old larger; copy over */
X			while ((*C++ = *value++));
X			return (0);
X		}
X	} else {					/* create new slot */
X		register int	cnt;
X		register char	**P;
X
X		for (P = environ, cnt = 0; *P; ++P, ++cnt);
X		if (alloced) {			/* just increase size */
X			environ = (char **)realloc((char *)environ,
X			    (size_t)(sizeof(char *) * (cnt + 2)));
X			if (!environ)
X				return (-1);
X		}
X		else {				/* get new space */
X			alloced = 1;		/* copy old entries into it */
X			P = (char **)malloc((size_t)(sizeof(char *) *
X			    (cnt + 2)));
X			if (!P)
X				return (-1);
X			memcpy(P, environ, cnt * sizeof(char *));
X			environ = P;
X		}
X		environ[cnt + 1] = NULL;
X		offset = cnt;
X	}
X	for (C = (char *)name; *C && *C != '='; ++C);	/* no `=' in name */
X	if (!(environ[offset] =			/* name + `=' + value */
X	    malloc((size_t)((int)(C - name) + l_value + 2))))
X		return (-1);
X	for (C = environ[offset]; (*C = *name++) && *C != '='; ++C)
X		;
X	for (*C++ = '='; (*C++ = *value++); )
X		;
X	return (0);
X}
X
Xint term_putenv(char *str) {
X	register char *p, *equal;
X	int rval;
X
X	if (!(p = malloc(strlen(str)+1)))
X		return(1);
X	strcpy(p, str);
X	if (!(equal = strchr(p, '='))) {
X		(void)free(p);
X		return(1);
X	}
X	*equal = '\0';
X	rval = putenv_setenv(p, equal + 1, 1);
X	(void)free(p);
X	return(rval);
X}
X
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/term_putenv.c' &&
  chmod 0644 'term-2.2.5/term_putenv.c' ||
  echo 'restore of term-2.2.5/term_putenv.c failed'
  shar_count="`wc -c < 'term-2.2.5/term_putenv.c'`"
  test 4684 -eq "$shar_count" ||
    echo "term-2.2.5/term_putenv.c: original size 4684, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/term_setup.1 ==============
if test -f 'term-2.2.5/term_setup.1' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/term_setup.1 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/term_setup.1 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/term_setup.1' &&
X.TH TERM_SETUP 1
X.SH NAME
Xlinecheck, termtest \- debugging tools for term
XB
X.SH SYNOPSIS
X.B linecheck 
X[ escape ... ] < /dev/tty?? >/dev/tty??
X.PP
X.B termtest
X[-1\ <program>] [-2\ <program>] [--local\ <option>]
X[--remote\ <option>] [<options>]
X.SH DESCRIPTION
XYou should perform two sets of tests before you ever try to run
X.IR term
Xitself.
XThe
X.IR linecheck
Xprogram performs a first-order test of the transparency of the link.
XThe
X.IR termtest
Xprogram lets you 
Xexercise 
X.IR term
Xand its clients locally by starting two
X.IR term
Xdaemons on the same system.
X.SH SEE ALSO
X.IR term (1),
X.IR termtest (1),
X.IR linecheck (1),
X.IR term_clients (1)
X.SH AUTHOR
XMichael O'Reilly, michael@iinet.com.au
X.br
XBill C. Riemers, bcr@physics.purdue.edu, is temporarily maintaining term.
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/term_setup.1' &&
  chmod 0644 'term-2.2.5/term_setup.1' ||
  echo 'restore of term-2.2.5/term_setup.1 failed'
  shar_count="`wc -c < 'term-2.2.5/term_setup.1'`"
  test 773 -eq "$shar_count" ||
    echo "term-2.2.5/term_setup.1: original size 773, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/term_spair.c ==============
if test -f 'term-2.2.5/term_spair.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/term_spair.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/term_spair.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/term_spair.c' &&
X#ifdef SVR3
X/*
X * This file defines the socketpair code for ISC unix.
X */
X
X#define I_ERRNO
X#define I_TYPES
X#define I_IOCTL
X#include "includes.h"
X
Xint term_socketpair(int domain,
X	   int type,
X	   int protocol,
X	   int fds[2])
X{
X  int d1, d2, nd1;
X  int status;
X  int flags;
X  struct sockaddr_in master;
X  struct sockaddr_in slave;
X  int mode;
X  int slavesz;
X
X  d1 = socket(domain, type, protocol);
X  if (d1 < 0)
X      return -1;
X  /*
X   * Now bind a name to the master socket.
X   */
X  master.sin_port = htons(9693);
X  master.sin_family = AF_INET;
X  master.sin_addr.s_addr = htonl(0x7f000001);
X
X  if (bind(d1, &master, sizeof(master)) < 0) {
X    perror("Bind failed for master socket to port 9693");
X    exit(1);
X  }
X
X  /*
X   * I now have both sockets open.  I need to set the O_NDELAY flag
X   * for the master so I can do a listen and then the connect from the
X   * slave.
X   */
X#ifdef DONTDELAY
X  flags = fcntl(d1, F_GETFL, 0);
X  if (flags < 0) {
X    status = errno;
X    close(d1);
X    errno = status;
X    return flags;
X  }
X
X  flags |= O_NDELAY;
X
X  if (fcntl(d1, F_SETFL, flags) < 0) {
X    perror("fcntl set flags failed");
X    return -1;
X  }
X#endif
X
X  status = listen(d1, 1);
X    
X  if (status == -1 && (errno != EAGAIN && errno != EINTR)) {
X    perror("listen failed");
X  }
X
X#ifdef DONTDELAY
X  flags &= ~O_NDELAY;
X  if (fcntl(d1, F_SETFL, flags) < 0) {
X    perror("fcntl set flags failed");
X    exit(1);
X  }
X#endif
X
X  d2 = socket(domain, type, protocol);
X  if (d2 < 0) {
X    status = errno;
X    close(d1);
X    errno = status;
X    return d2;
X  }
X
X  status = connect(d2, &master, sizeof(struct sockaddr_in));
X
X  if (status == -1) {
X    perror("Error connecting from slave to master");
X    return -1;
X  } 
X
X  slave = master;
X
X  nd1 = accept(d1, &slave, &slavesz);
X  if (nd1 == -1) {
X    perror("Error accepting connection from slave");
X    return -1;
X  }
X  /*
X   * At this point I should be connected on the two sockets.
X   */
X  close(d1);
X  fds[0] = nd1;
X  fds[1] = d2;
X  return 0;
X}
X
X#else /* keep ranlib from complaining */
Xint term_socketpair(int domain,
X	   int type,
X	   int protocol,
X	   int fds[2]) {return -1;}
X#endif
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/term_spair.c' &&
  chmod 0644 'term-2.2.5/term_spair.c' ||
  echo 'restore of term-2.2.5/term_spair.c failed'
  shar_count="`wc -c < 'term-2.2.5/term_spair.c'`"
  test 2127 -eq "$shar_count" ||
    echo "term-2.2.5/term_spair.c: original size 2127, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/terminal.c ==============
if test -f 'term-2.2.5/terminal.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/terminal.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/terminal.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/terminal.c' &&
X#define I_MEMORY
X#define I_TYPES
X#define I_IOCTL
X#define	I_TTY
X#include "includes.h"
X
X#ifndef CBAUD
X#define CBAUD (B0|B50|B75|B110|B150|B200|B300|B600|B1200|B1800|B2400|B4800|B9600|B19200|B38400);
X#endif
X
X#define ctrl(c) ((c)-'@')
X
Xvoid lose_ctty(void) {
X#ifdef USE_TIOCNOTTY
X  {
X    int slavefd;
X    if ((slavefd = open ("/dev/tty", O_RDWR, 0)) >= 0) {
X      ioctl (slavefd, TIOCNOTTY, (char *) 0);
X      close (slavefd);
X    }
X  }
X#endif
X#ifdef USE_SETSID
X  setsid();
X#endif
X#ifdef USE_SETPGRP
X#ifdef SYSV
X  setpgrp();
X#else
X  { int mypid;
X  mypid = getpid();
X  setpgrp(mypid, 0); }
X#endif
X#endif
X    
X#ifdef USE_BSDJOBS
X  { int mypid;
X  mypid = getpid();
X  tcsetpgrp(0, mypid); }
X#endif
X}
X
X#ifdef USE_TERMIOS
X
X#ifdef ultrix
X#define TCSETS TCSANOW
X#define TCGETS TCGETP
X#endif
X
Xstatic struct termios oldterm;
X
Xvoid terminal_save(int fd) {
X#ifdef USE_TCATTR
X  tcgetattr(fd, &oldterm);
X#else
X  ioctl( fd, TCGETS, &oldterm);
X#endif
X}
X
Xvoid terminal_raw(int fd) {
X  struct termios tempio;
X#ifdef USE_TCATTR
X  tcgetattr(fd, &tempio);
X#else
X  ioctl( fd, TCGETS, &tempio);
X#endif
X  tempio.c_iflag = 0;
X  tempio.c_oflag = 0;
X  tempio.c_lflag = 0;
X  tempio.c_cc[VMIN] = 1;
X  tempio.c_cc[VTIME] = 0;
X#ifdef USE_TCATTR
X  tcsetattr(fd, TCSANOW, &tempio);
X#else
X  ioctl( fd, TCSETS, &tempio);
X#endif
X}
X
Xvoid terminal_restore(int fd,int hangup) {
X#ifdef USE_TCATTR
X  tcsetattr(fd, TCSANOW, &oldterm);
X#else
X  ioctl( fd, TCSETS, &oldterm);
X#endif
X  if (hangup) {
X    struct termios disconnect;
X    memset(&disconnect,0, sizeof(struct termios));
X    disconnect.c_cflag = B0;
X#ifdef USE_TCATTR
X    tcsetattr(fd, TCSANOW, &disconnect);
X#else
X    ioctl( fd, TCSETS, &disconnect);
X#endif
X  }
X}
X
X#ifndef ECHOCTL
X#define ECHOCTL 0 /* not POSIX */
X#endif
X#ifndef ONCLR
X#define ONCLR 0
X#endif
X
X
Xvoid terminal_new(int fd) {
X  struct termios newterm;
X  newterm = oldterm;   /* hopefully sensible defaults */
X  newterm.c_iflag = BRKINT|IGNPAR|ICRNL|IXON|IXANY;
X  newterm.c_oflag = OPOST|ONLCR;
X#ifndef convex
X  newterm.c_cflag = B38400|CS8|CREAD|HUPCL;
X#else
X  newterm.c_cflag = CS8|CREAD|HUPCL;
X  newterm.c_tflag = _SETTFLAG|_SETWINSIZE;
X  newterm.c_ispeed = B38400;
X  newterm.c_ospeed = B38400;
X  newterm.c_winsize.ws_row = 24;
X  newterm.c_winsize.ws_col = 80;
X  newterm.c_winsize.ws_xpixel = 480;
X  newterm.c_winsize.ws_ypixel = 312;
X#endif
X  newterm.c_lflag = ISIG|ICANON|ECHO|ECHOE|ECHOCTL|IEXTEN;
X  newterm.c_cc[VINTR] = ctrl('C');
X  newterm.c_cc[VQUIT] = ctrl('\\');
X  newterm.c_cc[VERASE] = 127; /* ^? */
X  newterm.c_cc[VKILL] = ctrl('U');
X  newterm.c_cc[VEOF] = ctrl('D');
X#ifdef VSUSP
X  newterm.c_cc[VSUSP] = ctrl('Z');
X#endif
X#ifdef VREPRINT
X  newterm.c_cc[VREPRINT] = ctrl('R');
X#endif
X#ifdef VDISCARD
X  newterm.c_cc[VDISCARD] = ctrl('O');
X#endif
X#ifdef VSTOP
X  newterm.c_cc[VSTOP] = ctrl('S');
X#endif
X#ifdef VSTART
X  newterm.c_cc[VSTART] = ctrl('Q');
X#endif
X#ifdef VWERASE
X  newterm.c_cc[VWERASE] = ctrl('W');
X#endif
X#ifdef VLNEXT
X  newterm.c_cc[VLNEXT] = ctrl('V');
X#endif
X#ifdef USE_TCATTR
X  tcsetattr(fd, TCSANOW, &newterm);
X#else
X  ioctl( fd, TCSETS, &newterm);
X#endif
X}
X
X#else /* bsd */
X
Xstatic int o_ldisc;
Xstatic struct sgttyb o_ttyb;
Xstatic struct tchars o_tchars;
Xstatic int o_lmode;
Xstatic struct ltchars o_ltchars;
X
Xvoid terminal_save(int fd)
X{
X  ioctl(fd, TIOCGETD, &o_ldisc);
X  ioctl(fd, TIOCGETP, &o_ttyb);
X  ioctl(fd, TIOCGETC, &o_tchars);
X  ioctl(fd, TIOCLGET, &o_lmode);
X  ioctl(fd, TIOCGLTC, &o_ltchars);
X
X}
X
Xvoid terminal_restore(int fd,int hangup)
X{
X  ioctl(fd, TIOCSETD, &o_ldisc);
X  ioctl(fd, TIOCSETC, &o_tchars);
X  ioctl(fd, TIOCLSET, &o_lmode);
X  ioctl(fd, TIOCSLTC, &o_ltchars);
X  if (hangup) {
X    o_ttyb.sg_ispeed = B0;
X    o_ttyb.sg_ospeed = B0;
X  }
X  ioctl(fd, TIOCSETP, &o_ttyb);
X}
X
Xvoid terminal_raw(int fd)
X{
X  struct sgttyb m_ttyb;
X  struct tchars m_tchars;
X  struct ltchars m_ltchars;
X  int m_ldisc;
X  int m_lmode;
X
X  /* initialize structures */
X  ioctl(fd, TIOCGETP, &m_ttyb);
X  ioctl(fd, TIOCGETC, &m_tchars);
X  ioctl(fd, TIOCGLTC, &m_ltchars);
X
X  m_ldisc = NTTYDISC;
X  m_lmode = LLITOUT;
X
X  /* modify structures */
X
X/*  HSW 93/02/03, these shouldn't be set!
X  m_ttyb.sg_ispeed = B9600;
X  m_ttyb.sg_ospeed = B9600;
X*/
X
X  m_ttyb.sg_erase = -1;
X  m_ttyb.sg_kill = -1;
X  m_ttyb.sg_flags = RAW;
X
X  m_tchars.t_quitc = -1;
X
X  m_ltchars.t_suspc = -1;
X  m_ltchars.t_dsuspc = -1;
X  m_ltchars.t_flushc = -1;
X  m_ltchars.t_lnextc = -1;
X  
X  /* update terminal */
X  ioctl(fd, TIOCSETD, &m_ldisc);
X  ioctl(fd, TIOCSETP, &m_ttyb);
X  ioctl(fd, TIOCSETC, &m_tchars);
X  ioctl(fd, TIOCLSET, &m_lmode);
X  ioctl(fd, TIOCSLTC, &m_ltchars);
X
X}
X
Xvoid terminal_new(int fd)
X{
X  struct sgttyb m_ttyb;
X  struct tchars m_tchars;
X  struct ltchars m_ltchars;
X  int m_ldisc;
X  int m_lmode;
X
X  m_ldisc = NTTYDISC;
X  m_lmode = LCRTBS|LCRTERA|LCRTKIL|LCTLECH|LTOSTOP;
X
X  /* update sgttyb */
X  ioctl(fd, TIOCGETP, &m_ttyb);
X  m_ttyb.sg_flags = ECHO|CRMOD;
X  m_ttyb.sg_erase = 127; /* ^? */
X  m_ttyb.sg_kill = ctrl('U');
X
X  /* initialize tchars and ltchars */
X  m_tchars.t_intrc = ctrl('C');
X  m_tchars.t_quitc = ctrl('\\');
X  m_tchars.t_eofc = ctrl('D');
X  m_tchars.t_startc = ctrl('Q');
X  m_tchars.t_stopc = ctrl('S');
X  m_tchars.t_brkc = 255;       /* disable */
X  m_ltchars.t_werasc = ctrl('W');
X  m_ltchars.t_suspc = ctrl('Z');
X  m_ltchars.t_dsuspc = ctrl('Y');
X  m_ltchars.t_rprntc = ctrl('R');
X  m_ltchars.t_flushc = ctrl('O');
X  m_ltchars.t_lnextc = ctrl('V');
X  
X  /* update terminal */
X  ioctl(fd, TIOCSETD, &m_ldisc);
X  ioctl(fd, TIOCSETP, &m_ttyb);
X  ioctl(fd, TIOCSETC, &m_tchars);
X  ioctl(fd, TIOCSLTC, &m_ltchars);
X  ioctl(fd, TIOCLSET, &m_lmode);
X}
X#endif
X
X#ifndef B19200
X#define B19200 EXTA
X#endif
X#ifndef B38400
X#define B38400 EXTB
X#endif
X
Xunsigned long terminal_baud(int fd) {
X  int baud;
X#ifdef USE_TERMIOS
X  struct termios terminfo;
X#ifdef USE_TCATTR
X  tcgetattr(fd, &terminfo);
X#else
X  ioctl( fd, TCGETS, &terminfo);
X#endif
X  baud = terminfo.c_cflag & CBAUD;
X#else
X  ioctl(fd, TIOCGETP, &o_ttyb);
X  baud = o_ttyb.sg_ispeed < o_ttyb.sg_ospeed ? 
X      o_ttyb.sg_ispeed : o_ttyb.sg_ospeed;
X#endif
X
X  switch ( baud ) {
X  case B0:
X	return  0;
X	break;
X  case B50:
X	return  50;
X	break;
X  case B75:
X	return  75;
X	break;
X  case B110:
X	return  110;
X	break;
X  case B134:
X	return  134;
X	break;
X  case B150:
X	return  150;
X	break;
X  case B200:
X	return  200;
X	break;
X  case B300:
X	return  300;
X	break;
X  case B600:
X	return  600;
X	break;
X  case B1200:
X	return  1200;
X	break;
X  case B2400:
X	return  2400;
X	break;
X  case B4800:
X	return  4800;
X	break;
X  case B9600:
X	return  9600;
X	break;
X  case B19200:
X	return  19200;
X	break;
X  case B38400:
X	return  38400;
X	break;
X  default:
X	return  0;
X	break;
X  } 
X  return 2400;
X}
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/terminal.c' &&
  chmod 0644 'term-2.2.5/terminal.c' ||
  echo 'restore of term-2.2.5/terminal.c failed'
  shar_count="`wc -c < 'term-2.2.5/terminal.c'`"
  test 6614 -eq "$shar_count" ||
    echo "term-2.2.5/terminal.c: original size 6614, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/terminal.h ==============
if test -f 'term-2.2.5/terminal.h' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/terminal.h (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/terminal.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/terminal.h' &&
X
Xvoid lose_ctty(void);
Xvoid terminal_save(int);
Xvoid terminal_raw(int);
Xvoid terminal_restore(int,int);
Xvoid terminal_new(int);
Xunsigned long terminal_baud(int);
X
SHAR_EOF
  $shar_touch -am 1028144694 'term-2.2.5/terminal.h' &&
  chmod 0644 'term-2.2.5/terminal.h' ||
  echo 'restore of term-2.2.5/terminal.h failed'
  shar_count="`wc -c < 'term-2.2.5/terminal.h'`"
  test 163 -eq "$shar_count" ||
    echo "term-2.2.5/terminal.h: original size 163, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= term-2.2.5/termnet.c ==============
if test -f 'term-2.2.5/termnet.c' && test X"$1" != X"-c"; then
  echo 'x - skipping term-2.2.5/termnet.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting term-2.2.5/termnet.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'term-2.2.5/termnet.c' &&
X/* Most of the routines in this file are just quick hacks to get things
X * running. The general idea is that term is only used when the local
X * gethostbyname fails to find anything.  Many of these routines are just
X * quick hacks and can be greatly improved.
X */
X
X/* Everything that follows is an attempt to allow term to easier porting
X * of software to term.  The functions term_connect, term_rcmd, and 
X * term_gethostbyname are written such that ported routines will work
X * even with ordinary network connections.  Unfortunately, I haven't
X * figured out how to make term_bind network invisible yet.
X */
X
X#define I_IOCTL
X#define I_SYS
X#define I_GETOPT
X#define I_STAT
X#define I_SIGNAL
X#define I_STRING
X#define I_ARGS
X#define I_INET
X#define I_ERRNO
X#define I_CTYPE
X#include "includes.h"
X#include "client.h"
X
X#ifndef EOPNOTSUPP
X#define EOPNOTSUPP ~0
X#endif
X#ifndef ENOTCONN
X#define ENOTCONN EOPNOTSUPP
X#endif
X#ifndef EBADF
X#define EBADF ENOTCONN
X#endif
X
Xextern int use_term;
X
Xvoid get_term_localaddr(unsigned long);
Xvoid term_do_exit(void);
Xstruct sockaddr *str_to_sockaddr(char *, unsigned long);
Xchar *sockaddr_to_str(struct sockaddr *, int trans);
Xstruct hostent *host_lookup(char *,int,int,int,struct hostent *);
X
Xint term_debug = 0;
X
X#ifdef NO_LOOPBACK
Xint use_term = 1;
X#else
Xint use_term = -1;
X#endif
X
Xstatic int tmp_errno = 0;
Xstatic int Sock = -1;
X
X/* This is a way to disable termnet commands that aren't smart enough */
X/* to automatically determine if term commands should be used. */
Xstatic int remote_connect = -1;
X
X/* This is needed for term_getsockname. */
Xstruct sockinfo_type {
X  int sock;
X  int client;
X  int sockport;
X  int how;
X  struct sockaddr *udp_addr;
X};
X
Xstatic struct sockinfo_type sockinfo[MAX_CLIENTS];
Xstatic int udp_pending[MAX_CLIENTS];
Xstatic int pending_count=0;
X
Xstatic char term_error[1024];
X
X#ifndef USE_PROGNAME
X#define progname ""
X#define get_command() ""
X#else
Xstatic char *progname = NULL;
X
Xstatic char *get_command(void) {
X  int i=0;
X  char *cmdline = "";
X  extern char **environ;
X
X  progname = "";
X  if(environ) {
X    for (cmdline = *environ; cmdline && (i<2);)
X      i = (! *(--cmdline)) ? i + 1 : 0;
X    if (cmdline) 
X      for (progname = (cmdline += 2); cmdline = strchr(cmdline,'/');
X        progname = cmdline);
X  }
X  return progname;
X}
X#endif
X
Xstatic void print_err(int level) {
X  if ((term_debug & level) && term_error[0]) {
X    fprintf(stderr,"%s\n",term_error);
X    term_error[0] = 0;
X  }
X  if (level == 32768)
X    term_error[0] = 0;
X  errno = tmp_errno;
X  return;
X}
X
Xstatic struct hostent *str_to_hostent(char *addr){
X  static unsigned long int laddr=0;
X  static struct hostent hs;
X  static char host[258];
X  static char *caddr[2]={NULL,NULL};
X  static char *host_aliases[2]={NULL,NULL};
X
X  host_aliases[0]=(char *)hs.h_name;
X
X  hs.h_name=host;
X
X  sscanf(addr,"%lx %258s",&laddr,hs.h_name);
X  if(! laddr) return NULL;
X
X  laddr = htonl(laddr);
X  caddr[0]=(char *) &laddr;
X
X/* I'm using 0 as remote host. */
X
X  hs.h_aliases = host_aliases;
X  hs.h_addr_list = caddr;
X  hs.h_length = sizeof(unsigned long int);
X  hs.h_addrtype = AF_INET; 
X  return &hs;
X}
X
X
X/* To keep the lookups accurate, I need this.
X */
X
Xstatic void close_fd(int fd,int how){
X  int i, s, j;
X#if 1
X#endif
X
X  for(i=0;i<pending_count;i++) if(udp_pending[i] == fd) {
X    udp_pending[i] = -1;
X    if (i == pending_count + 1)
X      --pending_count;
X    else
X      break;
X  }
X
X  if (remote_term_version > 11862) {
X    if (Sock < 0)
X      Sock = socket_connect_server(-1,term_server);
X    s = Sock;
X  }else s = -1;
X
X
X  if(fd>=0)
X    for(i=0;i<MAX_CLIENTS;i++)
X      if (fd == sockinfo[i].sock) {
X
X#if STUPID_SHUTDOWN
X    if ((sockinfo[i].how  |= 3|(how + 1) ) == 3) {
X#endif
X      sockinfo[i].sock = -1;
X
X      if (s >= 0 && sockinfo[i].client >= 0) {
X        if (sockinfo[i].udp_addr != NULL) {
X          for(j=0;j<MAX_CLIENTS;j++)
X            if (sockinfo[j].udp_addr != NULL && sockinfo[j].sock >= 0)
X              if (!memcmp(sockinfo[i].udp_addr,
X                sockinfo[j].udp_addr,sizeof(struct sockaddr))) break;
X          if (j == MAX_CLIENTS) { 
X            if ((j = send_command(s, C_CLOSE, 1, "%d", sockinfo[i].client)) < 0) {
X              tmp_errno = -1;
X              sprintf(term_error, "Term: C_CLOSE 1 %d failed: %s",sockinfo[i].client,
X                command_result);
X              print_err(1);
X            }
X          }
X        }
X      }
X      if (sockinfo[i].udp_addr != NULL)
X        free(sockinfo[i].udp_addr);
X      sockinfo[i].udp_addr = NULL;
X      sockinfo[i].sockport = 0;
X      sockinfo[i].how = 0;
X#if STUPID_SHUTDOWN
X    }
X#endif
X  }
X}
X
X/* This is a client lookup for sockets necessary for term_accept 
X * and term_sendto
X */
X
Xstatic int store_sockinfo(int s, int client, struct sockaddr *udp_addr) {
X  static char term_clients[MAX_CLIENTS*4];
X  static int count = -1;
X  char *ptr,*nptr;
X  int i,k,port;
X
X  if (count < 0) {
X#if 0	/* This isn't necessary any more */
X    atexit(term_do_exit); 
X#endif 
X	/* Zero everything */
X    count=0;
X    for(i=0;i<MAX_CLIENTS;i++) {
X      sockinfo[i].sock = -1;
X      sockinfo[i].udp_addr = NULL;
X      sockinfo[i].sockport = 0;
X      sockinfo[i].how = 0;
X    }
X
X    /* Restore any client information
X	*
X	* TERMCLIENTS is of the form 
X	* 	"TERMCLIENTS=-m f0 c0 p0 s0 ... fN cN pN sN"
X	* where f0 is clients[].sock, c0 is clients[].client,
X	* p0 is port in clients[].udp_addr (0 if none)
X        * and s0 is socket name port in clients[].sockport
X	* m is the number of clients per file descriptor.
X	*/
X
X    if ((ptr = getenv("TERMCLIENTS"))) {
X      int n = 0, m = 3;
X      while(*ptr && n<MAX_CLIENTS) {
X        if (remote_connect < 0) {
X          use_term_command(PUBLIC);
X          remote_connect=1;
X        }
X        if (Sock < 0) 
X          if ((Sock=socket_connect_server(-1,term_server)) < 0) {
X            tmp_errno = -1;
X            sprintf(term_error, "Term 3: %s", command_result);
X            print_err(1);
X            remote_connect=0;
X            return MAX_CLIENTS;
X        }
X        pending_count=0;
X        sockinfo[n].sock = strtol(ptr,&nptr,10);
X	if (n == 1 && !(*nptr) && sockinfo[n].sock < 0) {
X          m = -sockinfo[n].sock;
X          sockinfo[n].sock = strtol(ptr,&nptr,10);
X        }
X	sockinfo[n].how  = 0;
X        if(!(*nptr) || m < 2) break;
X        sockinfo[n].client = strtol(nptr,&ptr,10);
X        nptr = ptr;
X        if(!(*nptr) || m < 3) break;
X        port = strtol(nptr,&ptr,10);
X        if(port) {
X          struct sockaddr_in addr_udp;
X
X          if (term_localaddr == INADDR_ANY)
X            get_term_localaddr(inet_addr("127.0.0.1"));
X          addr_udp.sin_addr.s_addr = htonl(term_localaddr);
X          addr_udp.sin_port = htons(port);
X          memcpy(sockinfo[n].udp_addr,&addr_udp,sizeof(udp_addr));
X        }
X        if (!(*nptr) || m < 4) break;
X        sockinfo[n].sockport = strtol(nptr,&ptr,10);
X        n++;
X      }
X    }
X  }
X  if (s < 0) return MAX_CLIENTS;
X
X  for(k=0;k<MAX_CLIENTS;k++)
X    if(sockinfo[k].sock<0||s == sockinfo[k].sock) break;
X  if(k==MAX_CLIENTS){
X    k = ++count % MAX_CLIENTS;
X    count = k;
X    close_fd(sockinfo[k].sock,2);
X    tmp_errno = -1;
X    sprintf(term_error,"Too many sockets open.  Killing one.");
X    print_err(1);
X  }
X  sockinfo[k].sock = s;
X  sockinfo[k].client = client;
X  sockinfo[k].how  = 0;
X  if (! udp_addr) {
X    sockinfo[k].udp_addr = NULL;
X  }else {
X    sockinfo[k].udp_addr = (struct sockaddr *)malloc(sizeof(struct sockaddr));
X    memcpy(sockinfo[k].udp_addr,udp_addr,sizeof(struct sockaddr));
X  }
X	/* Store sockinfo for the children */
X  strcpy(term_clients,"TERMCLIENTS= -4");
X  for(i=0;i<MAX_CLIENTS;i++) {
X    if(sockinfo[i].sock < 0) continue;
X    if (sockinfo[i].udp_addr != NULL) {
X      struct sockaddr_in *addr_in = (struct sockaddr_in *)&sockinfo[i].udp_addr;
X      sprintf(&term_clients[strlen(term_clients)]," %d %d %u %u",
X        sockinfo[i].sock,sockinfo[i].client,
X        ntohs(addr_in->sin_port), sockinfo[i].sockport);
X    }else {
X      sprintf(&term_clients[strlen(term_clients)]," %d %d 0 %u",
X        sockinfo[i].sock,sockinfo[i].client, sockinfo[i].sockport);
X    }
X  }
X  term_putenv(term_clients);
X
X  return k;
X}
X
Xstatic int term_udpsocket(int S) {
X  struct sockaddr udp_addr;
X  int s,i,client,len;
X  struct sockaddr_in *addr_in=NULL;
X
X  if (remote_connect < 0) {
X    remote_connect=use_term_command(PUBLIC);
X    store_sockinfo(-1,-1,NULL);
X  }
X
X  if (term_debug & 32768) {
X    tmp_errno = errno;
X    sprintf(term_error,"test term_udpsocket");
X    print_err(32768);
X  }
X
X  for(i=0;i<pending_count;i++) if(udp_pending[i] == S) {
X    udp_pending[i] = -1;
X    if (i == pending_count + 1)
X      --pending_count;
X    else
X      break;
X  }
X
X  if (i == pending_count) return MAX_CLIENTS;
X
X  if (Sock < 0) 
X    if ((Sock=socket_connect_server(-1,term_server)) < 0) {
X    tmp_errno = ~0;
X    sprintf(term_error, "Term 3: %s", command_result);
X    print_err(1);
X    return MAX_CLIENTS;
X  }
X
X  if ((s=duplicate_connect(-1,Sock)) < 0) {
X    tmp_errno = ~0;
X    sprintf(term_error,"Term: connection failed: %s",command_result);
X    print_err(1);
X    return MAX_CLIENTS;
X  }
X
X  if ((i=send_command(s, C_STATS, 1, "%d", -6)) < 0) {
X    tmp_errno = ~0;
X    sprintf(term_error,"Term: C_STATS -6 failed: %s",command_result);
X    print_err(1);
X    close(s);
X    return MAX_CLIENTS;
X  }
X  client = atoi(command_result);
X
X  if ((i=send_command(Sock, C_USOCK, 0, "%d %d", client,
X          (UDP_T_SENDSTRIPHDR | UDP_T_RECADDHDR))) < 0) {
X    tmp_errno = ~0;
X    sprintf(term_error,"Term: C_USOCK remote %d failed: %s",
X      client,command_result);
X    print_err(1);
X  }else if ((i=send_command(Sock, C_USOCK, 1, "%d %d", client,
SHAR_EOF
  : || echo 'restore of term-2.2.5/termnet.c failed'
fi
echo 'End of archive part 7'
echo 'File term-2.2.5/termnet.c is continued in part 8'
echo 8 > _sharseq.tmp
exit 0
