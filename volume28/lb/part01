Newsgroups: comp.sources.unix
From: deke@ceas.rochester.edu (Dikran Kassabian)
Subject: v28i035: lb - a load balancing interface to "rsh", V2.01, Part01/01
Message-id: <1.769104359.16983@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: deke@ceas.rochester.edu (Dikran Kassabian)
Posting-Number: Volume 28, Issue 35
Archive-Name: lb/part01

	LB is a load-balancing program.  It can check the current
	load on various machines on a LAN, and find the best candidate
	machine to accept a new job to it's run queue.  Additionally,
	it can send the job to that machine using rsh(1).

		Dikran Kassabian <deke@ceas.rochester.edu>

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  Makefile README INSTALL OTHER_SERVERS lb.conf lb.1 lb.5
#   args.c rsdclnt.c srvclnt.c st_sendrecv.c rsdclnt.h stats.h
#   config.h
# Wrapped by deke@harn on Fri Apr  8 15:01:43 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(2020 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#
X# Makefile for "lb", the load-balancer
X#
X# Original: ^Deke Kassabian 6/3/88,  
X# Changes: 3/07/89 -DK
X# 	   8/10/93 -TS and DK
X# 	   4/08/94 -DK
X#
X#
X####################################################################
X# -Begin standard configuration variables
X#
X# Pick a server.
X#
XSERVER=rstatd
X#SERVER=statsrv
X#
X#
X# Paths for lb binary, config file, and man pages.
X#
XBININSTALL=./bin
XCONFINSTALL=./conf
XMANINSTALL=./man
X#
X# Compiler options.
X#
XCFLAGS=   -O 
XLDFLAGS=  -s
X#
X# How to print man pages.
X#
X#PRINT=    ptroff -man
XPRINT=	  troff -t -man 
X#
X# -End standard configuration variables
X####################################################################
X
XSRCS=	  args.c rsdclnt.c srvclnt.c st_sendrecv.c rsdclnt.h stats.h config.h
XMANS=	  lb.1 lb.5
XOBJS_SRV= srvclnt.o st_sendrecv.o
XOBJS_RSD= rsdclnt.o args.o
XLIBS=     -lrpcsvc
X
Xall: lb
X
Xlb: lb.$(SERVER)
X	@echo "lb has been built for $(SERVER) server."
X
Xlb.rstatd: $(OBJS_RSD)
X	$(CC) $(CFLAGS) $(LDFLAGS) -o lb $(OBJS_RSD) $(LIBS)
X
Xlb.statsrv: $(OBJS_SRV)
X	$(CC) $(CFLAGS) $(LDFLAGS) -o lb $(OBJS_SRV)
X
X#
X# You may need to change the installation details, and you may want to
X# set other permissions than are used here by default.
X#
Xinstall:
X	cp lb $(BININSTALL)
X	cp lb.conf $(CONFINSTALL)
X	cp lb.1 $(MANINSTALL)/man1
X	cp lb.5 $(MANINSTALL)/man5
X	chmod a+rx $(BININSTALL)/lb
X	chmod a+r $(CONFINSTALL)/lb.conf
X	chmod a+r $(CONFINSTALL)/lb.conf
X	chmod a+r $(MANINSTALL)/man1/lb.1
X	chmod a+r $(MANINSTALL)/man5/lb.5
X
Xtags:
X	ctags *.c > tags
X
Xclean:
X	rm -f core *.o
X
Xspotless:
X	rm -f core lb *.o
X
Xlove:
X	@echo 'not war?'
X
Xjoke: 
X	@echo 'What do you want for nothing?'
X
Xshar: 
X	@shar Makefile README INSTALL OTHER_SERVERS lb.conf $(MANS) $(SRCS) >lb.shar
X	@chmod a+r lb.shar
X	@echo "SHAR file lb.shar created."
X
Xhardcopy:
X	lpr README INSTALL OTHER_SERVERS $(SRCS)
X	$(PRINT) $(MANS) | lpr -t
X
X# Dependencies
Xlbmain.o: 	lbmain.c stats.h config.h
Xst_sendrecv.o:	st_sendrecv.c stats.h config.h
Xrsdclnt.o:	rsdclnt.c config.h rsdclnt.h
Xargs.o:		args.c config.h rsdclnt.h
END_OF_FILE
if test 2020 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(3844 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X		LB - The Load Balancer (version 2.01)
X			by Dikran Kassabian
X
X		      University Of Rochester
X		Department of Electrical Engineering
X			  April 8, 1994
X_______________________________________________________________________
X
XWhat is LB?
X
X	LB is a load-balancing program.  It can check the current
X	load on various machines on a LAN, and find the best candidate
X	machine to accept a new job to it's run queue.  Additionally,
X	it can send the job to that machine using rsh(1).
X
X	LB works best in homogeneous environments, where each machine
X	has similar or identical file system layout.  Here at the
X	University of Rochester Department of Electrical Engineering,
X	we have nearly 70 Unix computers, which share home-directories
X	and local binaries.  When a user sitting at a small workstation
X	wants to run a compute intensive job, LB helps to find a machine
X	on the network that has a low load, knowing that that machine
X	will also have his/her home directory and required program.
X
XHow to install LB:
X
X	A separate file, called INSTALL, is included with detailed
X	installation notes, but briefly...
X
X	To install lb, unpack the shar file (hmm, I guess you've already
X	done that :-), decide which statistics server you want to use
X	(rstatd or statsrv) and make the two small adjustments to the
X	Makefile, then type "make".  The program 'lb' will be produced.
X	Then move 'lb' to an appropriate directory (like /usr/local/bin),
X	edit and install the configuration file, and you're ready to 
X	go.  The relevant man pages are included, and can be installed 
X	in your local man page directory.
X
XHow to use LB:
X
X	To use lb, just type 'lb <command-line>' at your prompt, where
X	<command line> is some shell command you might normally type
X	at your prompt.  LB will read a configuration file that tells
X	it about the candidate machines, select one, and then use rsh(1)
X	to run <command-line> on the specified machine.
X
X	See the man page for lb(1) for more information.
X
XThis version of lb has been tested in only a few environments.  It works on 
Xour Sun-3 and Sun-4 computers under SunOS 4.1.  It also works on our 68030
XNeXT Cubes under 1.0a OS.  Previous versions ran on our Vax 11/750 under 
XMt.Xinu BSD and on NeXT CUBES running NeXTStep 2.1 (but those machines have
Xsince been retired).  Beyond that I don't know.  If you port it to other 
Xoperating systems and hardware, send me the diffs so I can include them in 
Xthe next release (if there is one).
X
XMany thanks to Dave Curry (davy@riacs.edu), whose statsrv server can
Xbe used as an option to the rpc.rstatd server.  He was nice enough to let
Xme include some of his code with this package.  The files st_sendrecv.c
Xand stats.h are directly from his statsrv distribution.  Use your ARCHIE
Xservice to locate a copy of the statsrv daemon. I should point out, however,
Xthat the statsrv interface is included more to show that the load balancing 
Xconcept can be implemented with other servers than to suggest that the code 
Xsupporting statsrv is as fully supported as the rstatd code.  It isn't.
X
XThanks to the version 2 Beta testers, many of whom provided input including 
Xsuggestions for program behavior and even code fragments.  Special thanks to
XLan Gao <gao@ee.rochester.edu>, Roger Chaplin <keinstr!chaplin@uunet.uu.net>,
Xand Frank Greco <fgreco@shearson.com>, all of whom spent significant time and
Xeffort on lb and provided some of the most valuable feedback.
X
XIf you have comments/fixes/bug-reports/flames, send 'em to me at
Xdeke@ee.rochester.edu.  I'll make every effort to reply, and to address
Xyour concerns, but can't always guarantee that I can be quick about it.
XThere's also an lb-users mailing list.  Send requests to be added to the list
Xto lb-users-request@ee.rochester.edu, and items for distribution to
Xlb-users@ee.rochester.edu.
X
XGood luck with lb!  I hope you find it useful.
END_OF_FILE
if test 3844 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'INSTALL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'INSTALL'\"
else
echo shar: Extracting \"'INSTALL'\" \(2232 characters\)
sed "s/^X//" >'INSTALL' <<'END_OF_FILE'
X
X		LB - The Load Balancer (version 2.01)
X                by Dikran Kassabian and Tolga Soyata 
X
X		      University Of Rochester
X		Department of Electrical Engineering
X			  April 8, 1994
X
XINSTALLATION NOTES:
X
X
X1. CHOOSING A SERVER
X====================
XThe lb load balancer uses statistics gathered via connection with
Xservers on each of the candidate machines.  Two servers are "supported,"
Xthe SUN rstatd, and Dave Curry's statsrv.  The installer must see to it 
Xthat all candidate machines support the selected server program.  In an 
Xall SUN environment, rstatd is the better choice as it is faster and very 
Xefficient.  In other environments, it may be necessary to use the statsrv 
Xserver, which is public domain.  We have made *very little effort* to 
Xcontinue to support statsrv.  At this point it is little more than a 
Xdemonstration of the use of an alternative server to accomplish the basic 
Xtask.
X
X2. BUILDING THE PROGRAM
X=======================
XOnce a server is selected, the Makefile must be edited to reflect the 
Xchoice.  If rstatd is to be used, edit the Makefile definition for SERVER
Xto be 'SERVER=rstatd'.  If the statsrv server is to be used, make it
X'SERVER=statsrv'.  Check the defines in config.h, and choose the location
Xof the configuration file.  Remember that every machine that wants to
Xuse lb needs to be able to see that configuration file.  You may choose
Xto use multiple copies, or a single copy that all machines can see.  Once
Xthe Makefile and config.h are setup to your satisfaction, type 'make'.
XThe program 'lb' will be built.
X
X3. WRITING THE CONFIGURATION FILE
X=================================
XThe configuration file contains information on every machine on which lb
Xmay start jobs. See the man page lb(5) for details on its setup.
X
X
X4. INSTALLING THE FILES
X=======================
XInstall the program lb in a location within the path of the users requiring
Xit.  Good choices would include /usr/local/bin or /usr/new.  Then install
Xthe configuration file wherever the config.h file claimed it would be.  Again,
Xremember that every machine needs to have read access to this file.  Finally,
Xinstall the man pages lb(1) and lb(5) as appropriate.
X
XThat's all!
X
X
XDeke Kassabian, 3/8/91 and 8/10/93
END_OF_FILE
if test 2232 -ne `wc -c <'INSTALL'`; then
    echo shar: \"'INSTALL'\" unpacked with wrong size!
fi
# end of 'INSTALL'
fi
if test -f 'OTHER_SERVERS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'OTHER_SERVERS'\"
else
echo shar: Extracting \"'OTHER_SERVERS'\" \(1266 characters\)
sed "s/^X//" >'OTHER_SERVERS' <<'END_OF_FILE'
X
XWHAT?  No rstatd?  No statsrv?  Fear not.
X------------------------------------------
X
XLB is simple enough to modify for use with other servers.  This package
Xincludes client programs to talk to rstatd or statsrv, and these clients
Xcan be used as templates for others.
X
Xstatsrv is available from comp.sources.unix archive servers.  Use ARCHIE
Xto locate a copy.
X
X-------------------------------------------------------------------------
XFrom the SunOS rstatd manual page:
X
X  rstatd is a  server  which  returns  performance  statistics obtained  
X  from the kernel.  The rstatd daemon is normally invoked by inetd(8C).
X
X-------------------------------------------------------------------------
XThe opening paragraph from Dave Curry's statsrv README file:
X
X  This is a remote statistics server as described in RFC996, "Statistics
X  Server", D. L. Mills, February 1987.  With it, you can collect things
X  like load averages, number of users, uptime, and network statistics
X  from remote machines easily.  (David Curry, davy@riacs.edu)
X-------------------------------------------------------------------------
X
X^Deke Kassabian, deke@ceas.rochester.edu  or ur-valhalla!deke (+1 716-275-3106)
X     University of Rochester, College of Engineering, Rochester, NY 14627     
END_OF_FILE
if test 1266 -ne `wc -c <'OTHER_SERVERS'`; then
    echo shar: \"'OTHER_SERVERS'\" unpacked with wrong size!
fi
# end of 'OTHER_SERVERS'
fi
if test -f 'lb.conf' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lb.conf'\"
else
echo shar: Extracting \"'lb.conf'\" \(383 characters\)
sed "s/^X//" >'lb.conf' <<'END_OF_FILE'
X# lb.conf
X#
X# The format of this file is <machine> <sfactor> <limit>
X# where <machine> is a legal machine name
X#	<sfact>   is that machines selection factor
X#	<limit>   is the load limit for that machine
X#
X#  MACHINE      SFACT  LIMIT
X#--------------------------------------------------
Xsledge.ceas 	600 	6.0
Xharn.ceas 	500 	5.0
Xnova.ceas	400	6.0
Xnebula.ee	100	4.0
Xgalaxy.ee	100	2.5
END_OF_FILE
if test 383 -ne `wc -c <'lb.conf'`; then
    echo shar: \"'lb.conf'\" unpacked with wrong size!
fi
# end of 'lb.conf'
fi
if test -f 'lb.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lb.1'\"
else
echo shar: Extracting \"'lb.1'\" \(3051 characters\)
sed "s/^X//" >'lb.1' <<'END_OF_FILE'
X.tr ~ \ 
X.TH LB 1 "options
X.SH NAME
XLb \-  load balancer for homogeneous environment
X.SH SYNOPSIS
X.nf
X.BR "lb [ -v | -q ] [ -h ]
X	[ -t timeout ] [ -p 0.ppp ] [ -f numforks ] [ -c config-file ]
X      	[ -r remote-shell ] <command string>
X.PP
X.SH DESCRIPTION
X.fi
X.I lb
Xfinds the best machine in the environment on which to run a batch type
Xcompute task.  This is done by comparing load averages
Xand computing power for various machines, and selecting the machine
Xbest able to accept the compute task.
X.I lb
Xis especially useful in distributing compute intensive jobs among
Xthe many computers in a homogeneous environment.
X.sp
X.SH OPTIONS
XWith no options,
X.I lb
Xprints a one line output identifying
Xthe selected machine and the command being submitted.
X.sp
X.nf
X	-v	verbose mode:  causes an excessive amount of
X		information about the determination of the best
X		machine selection to be printed.
X
X	-q	quiet mode:  causes even the usual one line
X		output identifying the selected machine to be
X		eliminated.  The job will be sent to the remote
X		machine, but you will never be told which machine
X		was selected!
X
X  	-h 	output the help list
X
X  	-t nnn  time out after nnn seconds when collecting 
X		remote host statistics.
X
X  	-p 0.ppp once a machine with a selection factor of 0.ppp is
X  		detected, stop querying other machines. 
X
X  	-f nn   maximum allowed number of forks. 
X
X  	-c path selects hosts from an alternate config file.
X
X  	-r rsh  uses an alternate remote shell.
X
X.fi
X.SH EXAMPLES
X.nf
X.I lb
X.fi
X	This gives the output of lb -v, but executes no command
X.sp
X.nf
X.I lb fortune
X.fi
X	This executes "fortune" on the least loaded machine.
X.sp
X.nf
X.I lb -v foobar
X.fi
X	This executes "foobar" on the least loaded machine, and gives
Xverbose messages.
X.sp
X.nf
X.I lb -q minimos infile
X.fi
X	This executes "minimos infile" on the least loaded machine,
Xand gives no messages.
X.sp
X.nf
X.I lb 'spice<infile>outfile'
X.fi
X	This is an important example.  Here, a program called "spice" is
Xbeing run with redirected input and output. Anytime redirection is 
Xdesired in using
X.I lb,
Xthe portion using redirection must be quoted to avoid interpretation at
Xthe originating shell.  The quoted string in this example allows for the
Xredirection to take place on the remote machine.
X.sp
X.nf
X.SH FILES
X.fi
X.I lb
Xalso requires the configuration file
X.I lb.conf
Xwhich lists machines to be
Xconsidered, and some basic information about them.  See the manual
Xpage lb(5) for more on the configuration file.
X.nf
X.SH NOTES
XThis program is still under development.  Send 
Xdescriptions of problems and/or comments to deke@ee.rochester.edu
X(also ...!rochester!ur-valhalla!deke).
X.SH AUTHORS
X.nf
XDikran Kassabian,
XUniversity of Rochester Dept. of Electrical Engineering
XRochester, NY 14627 (716) 275-3106
Xdeke@ceas.rochester.edu
X.sp
XTolga Soyata
XUniversity of Rochester Dept. of Electrical Engineering
Xsoyata@ee.rochester.edu
X.sp
XSpecial thanks to Lan Gao (gao@ee.rochester.edu)
Xfor assistance and testing with version 2
X.SH "SEE ALSO"
Xrstatd(8), statsrv(8), w(1), uptime(1), lb(5)
END_OF_FILE
if test 3051 -ne `wc -c <'lb.1'`; then
    echo shar: \"'lb.1'\" unpacked with wrong size!
fi
# end of 'lb.1'
fi
if test -f 'lb.5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lb.5'\"
else
echo shar: Extracting \"'lb.5'\" \(2063 characters\)
sed "s/^X//" >'lb.5' <<'END_OF_FILE'
X.tr ~ \ 
X.TH LB 5 "limit
X.SH NAME
XLb.conf \-  load balancer configuration file for lb(1)
X.fi
X.SH DESCRIPTION
XThis file contains information about local machines recognized by
X.IR lb (1).
XThe format consists of single line entries with three fields. The
Xfields are
X.I machine-name,
X.I power-factor,
Xand
X.I load-limit.
X.sp
X.I machine-name
Xis a legal or recognized hostname which is to be a candidate for jobs
Xinitiated through the use of lb(1).  This machine must support the
Xstatistics server protocol used by lb(1).
X.sp
X.I power-factor
Xis a floating point value, and has meaning only by comparison to
Xthe power-factors of other machines.  The machines with the larger
Xpower-factors will be preferred to those with smaller power-factors.
X.sp
X.I load-limit
Xspecifies the load-average beyond which jobs should not be sent
Xto that machine.
X.sp
X.SH SAMPLE FILE
X.nf
X# lb.conf
X#
X# The format of this file is <machine> <sfactor> <limit>
X.ta .8i
X# where	<machine> is a legal machine name
X#	<sfactor> is that machines selection factor
X#	<limit>   is the load limit for that machine
X#
X.ta 2.2i 3.2i
X#  MACHINE	SFACTOR	LIMIT
Xbrahms.fubar.com	200	3.0
Xmozart.fubar.com	150	2.5
Xchopin.fubar.com	120	2.5
Xbach.fubar.com	100	1.5
X.sp
X.fi
XLines beginning with 
X.B # 
Xare comments.
X.sp
XIn this example, brahms.fubar.com is preferred to mozart.fubar.com, which
Xis preferred to chopin.fubar.com, if their loads are exactly equal.  In
Xpractice, the load average (number of jobs in the run queue over the last
Xminute) is compared to the load-limit and then divided by the power-factor,
Xfor each machine listed.  If the load average exceeds the load-limit, that
Xmachine will not be considered.  When all machines listed have been considered,
Xthe one with the smallest value of (load-average/power-factor) will be
Xselected.
X.sp
X.SH "SEE ALSO"
Xlb(1), w(1), uptime(1)
X.SH NOTES
XThere are limits to the line-length and the hostname length, which are
Xset in the file config.h when lb(1) is built.  By default, these are
X255 and 64 respectively, but may be tweaked at the installers discretion.
END_OF_FILE
if test 2063 -ne `wc -c <'lb.5'`; then
    echo shar: \"'lb.5'\" unpacked with wrong size!
fi
# end of 'lb.5'
fi
if test -f 'args.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'args.c'\"
else
echo shar: Extracting \"'args.c'\" \(4252 characters\)
sed "s/^X//" >'args.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1989-1994 University of Rochester
X * Department of Electrical Engineering
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that the above copyright notice and this paragraph are
X * duplicated in all such forms and that any documentation,
X * advertising materials, and other materials related to such
X * distribution and use acknowledge that the software was developed
X * at the University of Rochester.
X *
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#define ARGS_C
X#include <setjmp.h>
X#include <stdio.h>
X#include <limits.h>
X#include <floatingpoint.h>
X#include "config.h"
X#include "rsdclnt.h"
X#undef ARGS_C
X
Xchar *CommandLineOptions="hqvc:f:p:r:t:";
X
Xextern char *optarg;
Xextern int optind;
Xextern int opterr;
X
Xboolean process_args(argc, argv, envp)
Xint argc;
Xchar **argv;
Xchar **envp;
X{
X  int c;
X  boolean NoArgsErrorOccured=TRUE;
X  double d;
X
X  /* Assign proper initial values to command line arguments */
X  (void)strcpy(RemoteShell,RSH);
X  (void)strcpy(ConfigFile,CONFIGFILE);
X  TimeOut=TIMEOUT;
X  DesiredPower=-0.1;  /* Practically "check exhaustively" */
X  NumForks=MAXFORKS;
X  verbose_mode=TRUE;
X  quiet_mode=FALSE;
X
X
X /* Check arguments. */
X
X  if (argc == 1) {
X        command=0;                      /* no command to execute */
X        verbose_mode=1;                 /* verbose mode          */
X	return;
X  }
X
X /*
X  * if argc=1 then verbose=Y and command=NULL
X  * if argc>=2 check for flags:
X  *
X  *    -v             verbose (full output)
X  *
X  *    -q             quiet (don't output machine selection)
X  *    with no flags, only machine selection will be output
X  *    The above flags are mutually exclusive.  v overrides q
X  *
X  *    -h             output the switch list
X  *
X  *    -t nnnn        time out after nnnn seconds, overrides Timeout
X  *
X  *    -p 0.pppp      once a machine with a selection factor of 0.pppp is
X  *                   detected, stop querying other machines. 
X  *		      Overrides DesiredPower
X  *
X  *    -f nn          maximum allowed number of forks. Overrides NumForks
X  *
X  *    -c Path        Overrides ConfigFile
X  *
X  *    -r rsh         Remote shell to use. Overrides RemoteShell
X  *
X  *    Additional arguments are taken to be a command.  No sanity checking
X  *    will be done.  When a machine is selected, the command will be sent
X  *    to that machine as a shell command.
X  *
X  */
X
X  while( (c=getopt(argc, argv, CommandLineOptions)) != -1){
X    switch(c){
X    case 'c': /* Specify a configuration file other than default */
X              strcpy(ConfigFile,optarg);
X              break;
X    case 'f': /* Specify maximum allowed number of forks */
X              NumForks=atoi(optarg);
X              break;
X    case 'h': Help();
X              exit(0);
X    case 'p': /* Specify a desired power */
X              DesiredPower=atof(optarg);
X              break;
X    case 'q': if(!verbose_mode) quiet_mode=TRUE;
X              break;
X    case 'r': strcpy(RemoteShell,optarg);
X              break;
X    case 't': TimeOut=atoi(optarg);
X              break;
X    case 'v': verbose_mode=TRUE;
X              quiet_mode=FALSE;
X              break;
X    default:  NoArgsErrorOccured=FALSE;
X              break;
X    }
X  }
X  if(!NoArgsErrorOccured) DisplayUsage();
X  start=optind;
X  command=(argv[start]!=NULL);
X  return NoArgsErrorOccured;   /* TRUE means all args are legal */
X}
X
X
XHelp()
X{
X  DisplayUsage();
X  (void)printf("\n");
X  (void)printf("-c configfile   Configuration file to be used\n");
X  (void)printf("-f numforks     Maximum allowed number of forks\n");
X  (void)printf("-h              Display help (this message)\n");
X  (void)printf("-p power        Specify min desired power\n");
X  (void)printf("-q              Quiet mode. -v option overrides this\n");
X  (void)printf("-r rshfile      Specify an rsh binary file\n");
X  (void)printf("-t timeout      Timeout after `timeout' seconds. < 0 means infinity\n"); 
X  (void)printf("-v              Verbose mode. All possible output\n");
X  exit(0);
X}
X
X
XDisplayUsage()
X{
X  (void)printf("Usage: lb <options> <commmand>\n");
X}
END_OF_FILE
if test 4252 -ne `wc -c <'args.c'`; then
    echo shar: \"'args.c'\" unpacked with wrong size!
fi
# end of 'args.c'
fi
if test -f 'rsdclnt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rsdclnt.c'\"
else
echo shar: Extracting \"'rsdclnt.c'\" \(9175 characters\)
sed "s/^X//" >'rsdclnt.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1989-1994 University of Rochester
X * Department of Electrical Engineering
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that the above copyright notice and this paragraph are
X * duplicated in all such forms and that any documentation,
X * advertising materials, and other materials related to such
X * distribution and use acknowledge that the software was developed
X * at the University of Rochester.
X *
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X/*
X * rsdclnt.c  for the 'lb' load balancer 
X *   Revs 1.0-1.2 by
X *   -Deke Kassabian, University of Rochester College of Engineering
X *   ( deke@ee.rochester.edu )  (716) 275-3106
X *
X *   Rev 1.3
X *   -Tolga SOYATA,   University of Rochester Dept of EE
X *   ( soyata@ee.rochester.edu )  
X *
X */
X
X
X#define RSDCLNT_C
X#include <stdio.h>
X#include <rpc/rpc.h>
X#include <rpcsvc/rstat.h>
X#include <signal.h>
X#include <setjmp.h>
X#include "config.h"
X#include "rsdclnt.h"
X#undef RSDCLNT_C
X
X
Xmain(argc, argv, envp)
Xint argc;
Xchar *argv[];
Xchar *envp[];
X{
X  int a;
X
X  pname = *argv;		/* Name of this program  */
X  path=RemoteShell;
X  command=TRUE;			/* There is a command	 */
X  NumErrors=0;			/* No errors from children have been reported yet */
X  ProcessedMachines=0;
X  GivenCommands=0;
X  NumHosts=0;
X
X
X  /* Process command line arguments */
X  if(!process_args(argc,argv,envp)) exit(99);
X
X
X  if(command){
X	for(a=start ; a<argc ; a++){
X	    (void)strcat(cmd_exec," "); (void)strcat(cmd_exec,argv[a]);
X	}
X  }
X
X
X  /* get local machine's name and its load avg first */
X  (void)gethostname(best_host,MAXHOST);
X  (void)getstats(best_host,&lstats);
X  best_sfactor=loadavg(&lstats,0);
X
X  /* Copy local host name into LocalHost struc */
X  (void)strcpy(LocalHost.name,best_host);
X
X  /* Assume default values for limit and factor for the local host */
X  /* in case it is not in configuration file */
X  LocalHost.factor=100.0;
X  LocalHost.limit=6.0;
X
X
X  /* Read info for all the machines from the configuration file */
X  /* if there is info about the local host, read it in LocalHost struc also */
X  (void)read_configuration_file();
X
X  best_sfactor*=(100.0/LocalHost.factor);
X  /* If the local machine is powerful enough, run the job on it */
X  if(best_sfactor<=DesiredPower) goto HOST_SELECTED;
X
X
X  (void)pipe(reports);          /* Children report results thru this pipe */
X  (void)pipe(commands);         /* Parent issues commands thru this pipe */
X
X
X  /* Fork processes to query candidate hosts */
X  NumForks=min(NumForks,NumHosts);
X  (void)fork_children();
X
X
X  /* Check the child processes one by one exhaustively. Read the pipe */
X  if(verbose_mode){
X    (void)printf("\nHOST              FACTOR      LIMIT       Load avg    ");
X    (void)printf("Selection Factor\n");
X    (void)printf("------------------------------------------------------------------------------\n");
X  }
X
X
X  /* Now, give commands to children, evaluate their reports */
X  while(ProcessedMachines<NumHosts){
X	IssueNextCommand();
X	(void)read(reports[0],fentry,MAXLINE);
X
X	/* This is an error message if it starts with a pound sign */
X	if(fentry[0]=='#'){
X	  (void)strcpy(errors[NumErrors++],&fentry[1]);
X	  continue;
X	}
X
X	(void)sscanf(fentry,"%s %f %f %f",host,&factor,&limit,&load);
X	my_sfactor=100*(load/factor);
X	ProcessedMachines++;  /* One more machine is processed */
X
X	if(verbose_mode){
X	  if(load>limit){
X	    (void)printf("%-16s  %-10.2f  %-10.2f  ABOVE LIMIT\n",host,factor,limit);
X	  }else{
X	    (void)printf("%-16s  %-10.2f  %-10.2f  %-10.2f  %-10.2f\n",
X	           host,factor,limit,load,my_sfactor);
X	  }
X	}
X
X	if(best_sfactor>my_sfactor){
X	  best_sfactor=my_sfactor;
X	  (void)strcpy(best_host,host);
X	}
X
X	/* If this machine is powerful enough, run the job on it */
X	if(best_sfactor<=DesiredPower) break;
X
X  }      /* endwhile */
X
X
X  /* Kill all the forked processes */
X  (void)KillChildren();
X
X
XHOST_SELECTED:
X  /* Display the error messages */
X  if(verbose_mode){
X    (void)printf("\n");
X    for(a=0; a<NumErrors; a++) puts(errors[a]);
X    (void)printf("\nTotal number of hosts = %d\n",NumHosts);
X    (void)printf("Hosts checked         = %d\n\n",ProcessedMachines);
X    (void)printf("Selected host: <%s>     factor=<%.3f>\n\n",best_host,best_sfactor);
X  }
X
X
X  if(command){
X	/* If local host is selected as the best host */
X	if(!strcmp(best_host,LocalHost.name)){
X	  (void)printf("Executing on local host\n");
X	  /* execve("",&argv[start],envp); exit(0);*/
X	}
X	(void)sprintf(rcmd_exec,"(cd %s;%s)",getenv("PWD"),cmd_exec);
X
X	/* if(fork()) exit(0); /* Tun this in background */
X
X	if(!quiet_mode){ /* print if not quiet_mode */
X	  (void)printf("\nrsh %s %s &\n",best_host,rcmd_exec); 
X	}
X	(void)execle(path,path,best_host,rcmd_exec,(char *)0,envp); exit(0);
X	perror("");
X  }
Xexit(0);
X}
X
X
X
Xgetstats(hostname,lstats)
Xchar *hostname;
Xstruct statstime *lstats;
X{
Xint c;
Xchar b[MAXLINE];
X
X  c=rstat(hostname,lstats);	/* rstat seems to return:	    */
X				/*	0  on success		    */
X				/*	13 on hostname lookup fail  */
X				/*	14 on connection timeout    */
X				/*	15 on "rstat not supported" */
X  /*  I chose to generate my own error messages.  perror() didn't */
X  /*	give error messages I liked.  Switch back to perror if you  */
X  /*	care to.						    */
X
X  switch(c){
X  case 0:  /* no problema */
X           break;
X  case 13:
X           (void)sprintf(b,"#rstat error (%d): host <%s> is unknown",c,hostname);
X           (void)write(reports[1],b,MAXLINE);
X           break;
X  case 14:
X           (void)sprintf(b,"#rstat error (%d): host <%s> is down or unreachable",
X                   c,hostname);
X           (void)write(reports[1],b,MAXLINE);
X           break;
X  case 15:
X           (void)sprintf(b,"#rstat error (%d): host <%s> does not support protocol",
X                   c,hostname);
X           (void)write(reports[1],b,MAXLINE);
X           break;
X  default:
X           (void)sprintf(b,"#rstat error (%d): unknown error",c);
X           (void)write(reports[1],b,MAXLINE);
X           break;
X  }
X  return(c);
X}
X
X
X
XIssueNextCommand()
X{
X  /* If all commands are given, return */
X  if(GivenCommands>=NumHosts) return;
X  (void)sprintf(fentry,"%s %f %f\n",machines[GivenCommands].name,
X          machines[GivenCommands].factor,machines[GivenCommands].limit);
X  /* Give the next command to the children */
X  (void)write(commands[1],fentry,MAXLINE);
X  GivenCommands++;
X}
X
X
X
XIssueDieCommand()
X{
X  fentry[0]='!';
X  fentry[1]='\0';
X  (void)write(commands[1],fentry,MAXLINE);
X}
X
X
XKillChildren()
X{
X  int a;
X
X  for(a=0; a<NumForks; a++){
X    IssueDieCommand();
X  }
X}
X
X
X
X
X
X/* When the alarm goes off, this function is invoked */
X/* Children use this function to report to parent that this host is "down" */
Xend_inquiry()
X{
X  /* No respnse from the machine so far. Abort the process */
X  load=MAXFLOAT;
X  (void)sprintf(fentry,"%s %f %f %f\n",host,factor,limit,load);
X  /* Write these parameters to the pipe (report) */
X  (void)write(reports[1],fentry,MAXLINE);
X  /* Go to the start of the inquiry again to check another machine */
X  longjmp(JumpBuffer,1);
X}
X
X
X
X
Xmin(a,b)
Xint a,b;
X{
X  return (a<b) ? a:b;
X}
X
X
X
X
Xread_configuration_file()
X{
X  FILE *fd;
X
X  if((fd=fopen(ConfigFile,"r"))==0){
X	 (void)fprintf(stderr,"Error opening configuration file\n");
X	 exit(1);
X  }
X  while((fgets(fentry,MAXLINE,fd))!=NULL){
X	(void)sscanf(fentry,"%s %f %f",host,&factor,&limit);
X	if(fentry[0]=='#') continue; 	/*ignore comments*/
X	(void)strcpy(machines[NumHosts].name,host);
X	machines[NumHosts].factor=factor;
X	machines[NumHosts].limit=limit;
X	/* Check to see if this is the machine I logged on to */
X	if(!strcmp(machines[NumHosts].name,LocalHost.name)){
X	  /* Copy the local host info into LocalHost struc */
X	  LocalHost=machines[NumHosts];
X	  continue; /* Do not save a copy of it in machines struc */
X	}
X        NumHosts++;
X
X  }    /* endwhile */
X  (void)fclose(fd);
X}
X
X
X
X
Xfork_children()
X{
X  int a;
X
X  for(a=0; a<NumForks; a++){
X	switch(fork()){
X	case  0: /* child */
X	         if(setjmp(JumpBuffer)){
X	           /* Second time */
X	         }else{
X	           /* First time */
X	         }
X	         for(; ;){ /*forever*/
X	           /* (Re)Set the alarm */
X	           if(TimeOut>0){
X	             (void)alarm(TimeOut);
X	             (void)signal(SIGALRM,end_inquiry);
X	           }
X	           (void)read(commands[0],fentry,MAXLINE); /* Read next command */
X	           if(fentry[0]=='!')  exit(0);      /* "die" command */
X	           (void)sscanf(fentry,"%s %f %f",host,&factor,&limit);
X	           if(getstats(host,&lstats) !=0){
X	             load=MAXFLOAT;			/* skip this one */
X	           }else{
X	             load=loadavg(&lstats,0);	
X	           }
X
X	           (void)sprintf(fentry,"%s %f %f %f\n",host,factor,limit,load);
X                   /* Write these parameters to the pipe (report) */
X	           (void)write(reports[1],fentry,MAXLINE);
X	         }
X	case -1: /* could not fork */
X	         perror("fork");
X	         exit(2);
X	default: IssueNextCommand();
X		 /* parent goes to fork more or check all machines if done */
X	}
X  }
X}
END_OF_FILE
if test 9175 -ne `wc -c <'rsdclnt.c'`; then
    echo shar: \"'rsdclnt.c'\" unpacked with wrong size!
fi
# end of 'rsdclnt.c'
fi
if test -f 'srvclnt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'srvclnt.c'\"
else
echo shar: Extracting \"'srvclnt.c'\" \(5875 characters\)
sed "s/^X//" >'srvclnt.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1989, University of Rochester
X * Department of Electrical Engineering
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that the above copyright notice and this paragraph are
X * duplicated in all such forms and that any documentation,
X * advertising materials, and other materials related to such
X * distribution and use acknowledge that the software was developed
X * at the University of Rochester.
X *
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X/* srvclnt.c version 1.1  3/7/89
X * for the 'lb' load balancer - by Deke Kassabian
X *
X *   -Deke Kassabian, University of Rochester EE Department
X *   ( deke@ee.rochester.edu )  (716) 275-3106
X */
X
X#include <sys/param.h>
X#include <sys/socket.h>
X#include <netinet/in.h>
X#include <netdb.h>
X#include <stdio.h>
X#include <string.h>
X#include "stats.h"
X#include "config.h"
X
Xchar *pname;
Xshort	server = 0;			/* indicates we aren't server	*/
Xstruct	sockaddr_in sin;		/* address of remote host	*/
X
Xmain(argc, argv, envp)
Xint argc;
Xchar **argv;
Xchar **envp;
X{
X	FILE *fd,*fopen();
X
Xint start, 			/* where in the argv the command begins */
X    ppgrp,			/* parent process group			*/
X    command,			/* whether there is a command 		*/
X    verbose_mode, 		/* all possible output			*/
X    quiet_mode;			/* no output				*/
X
Xchar *path=RSH;
X
Xchar *dir;
Xchar *cmd_exec[MAXSHBUF],	/* command to execute (local)		*/
X     *rcmd_exec[MAXSHBUF],	/* command to execute (remote)		*/
X     dbuf[MAXSHBUF],		/* working directory placeholder	*/
X     host[MAXHOST],		/* hostname placeholder			*/
X     best_host[MAXHOST],	/* hostname placeholder			*/
X     fentry[MAXLINE];		/* file entry             		*/
X
Xfloat my_sfactor,
X      best_sfactor,
X      load,
X      factor,limit;		/* file variables			*/
X
X	int socktype;
X	register int s;
X	char buf[10240];
X	struct hostent *hp;
X	struct servent *sp;
X	char *servtype;
X	struct hostent *gethostbyname();
X	struct servent *getservbyname();
X
X	pname = *argv;			/* Name of this program  */
X
X	verbose_mode=0,quiet_mode=0;	/* Default is neither    */
X	best_sfactor=MAXFLOAT;	 	/* Practically infinity! */
X 	command=1;			/* There is a command	 */
X
X /* Check arguments. 
X  *
X  * if argc=1 then verbose=Y and command=NULL
X  * if argc>=2 check for flags:
X  *    -v=verbose (full output),  -q=quiet (don't output machine selection)
X  *    with no flags, only machine selection will be output
X  *    The above flags are mutually exclusive.  v overrides q
X  *
X  *    Additional arguments are taken to be a command.  No sanity checking
X  *    will be done.  When a machine is selected, the command will be run
X  *    on that machine
X  *
X  */
X
X if (argc == 1) {
X	command=0;			/* no command to execute */
X	verbose_mode=1;			/* verbose mode		 */
X	}
X else {
X     start=1;
X     if(!strcmp(argv[1],"-q")){
X      quiet_mode=1;			/* quiet mode - no output */
X      start=2;
X      if(argc == 2) exit(0);		/* No command, no output! */
X     } 
X     if(!strcmp(argv[1],"-v")){
X      verbose_mode=1;			/* verbose mode		 */
X      start=2;
X      if(argc == 2) command=0;		/* No command - verbose   */
X     } 
X }
X
X  if(command){
X	for( ; start<argc; start++){
X	    strcat(cmd_exec," "); strcat(cmd_exec,argv[start]);
X	}
X  }
X
X /* Open the config file */
X if((fd=fopen(CONFIGFILE,"r"))==0){
X	 fprintf(stderr,"Error opening configuration file ");
X	 exit(1);
X }
X
X /* Set up to use TCP stream sockets.  */
X	servtype = "tcp";
X	socktype = SOCK_STREAM;
X
X /* Look up the port the server lives on.  */
X if ((sp = getservbyname(SERVNAME, servtype)) == NULL) {
X	fprintf(stderr, "%s: %s/%s: service unknown.\n", 
X		pname, SERVNAME, servtype);
X	exit(1);
X	}
X
X /* Read the config file */
X	strcpy(best_host,"localhost");
X	while((fgets(fentry,MAXLINE,fd))!=NULL){
X	   sscanf(fentry,"%s %f %f",host,&factor,&limit);
X	   if(fentry[0]=='#') continue; /*ignore comments*/
X		
X	   if(verbose_mode)
X	     printf("\nHOST=%s\tFACTOR=%.2f\tLIMIT=%.2f\n",host,factor,limit);
X	   
X
X	   /* Look up the host's address.  */
X	   if ((hp = gethostbyname(host)) == NULL) {
X		fprintf(stderr, "%s: %s: host unknown.\n", pname, host);
X		exit(1);
X	   }
X	
X	   /* Get a socket. */
X	   if ((s = socket(AF_INET, socktype, 0)) < 0) {
X			error("socket");
X			exit(1);
X	   }
X
X		/* Build the server's address.  */
X		sin.sin_port = sp->s_port;
X		sin.sin_family = hp->h_addrtype;
X		bcopy(hp->h_addr, &sin.sin_addr, sizeof(sin.sin_addr));
X
X		/* connect to the remote host.  */
X		if (connect(s, &sin, sizeof(struct sockaddr_in)) < 0) {
X			/* if not quiet mode, print connect error */
X			error("connect");
X			/* can't reach this host, try the next */
X			continue;
X		}
X
X		/* make the request and grab the result */
X		st_send(s,"loadav");
X		st_recv(s,buf,sizeof(buf),"response");
X		sscanf(buf,"%f",&load);
X
X	        if( load > limit){
X	           if(verbose_mode)
X		      printf("Host %s is over defined limit\n",host);
X	           continue;
X	        }
X
X		my_sfactor=100*( load / factor );
X		if(verbose_mode){
X		  printf("Load avg=%.3f ",load);
X		  printf("Selection factor=%.2f\n",my_sfactor);
X		}
X		
X		if(best_sfactor>my_sfactor){
X			best_sfactor=my_sfactor;
X			strcpy(best_host,host);
X		}
X
X	} /*endwhile */
X
Xif(verbose_mode)
X   printf("Selected host: <%s> factor=<%.3f>\n",best_host,best_sfactor);
X
X    if(command){
X	    sprintf(rcmd_exec,"(cd %s;%s)",getwd(dbuf),cmd_exec);
X	    if(!quiet_mode){	/* print if not quiet_mode */
X	       printf("\nrsh %s %s &\n",best_host,rcmd_exec);
X	    }
X	    ppgrp = getpgrp(getppid());
X	    if (fork())
X		exit(0);
X	    if(setpgrp(getpid(), ppgrp)) 
X		perror("stepgrp");
X	    execle(path,path,best_host,rcmd_exec,(char *)0,envp); exit(0);
X	    perror("");
X     }
Xexit(0);
X}
X
Xerror(s)
X{
X	fprintf(stderr, "%s: ", pname); perror(s);
X}
END_OF_FILE
if test 5875 -ne `wc -c <'srvclnt.c'`; then
    echo shar: \"'srvclnt.c'\" unpacked with wrong size!
fi
# end of 'srvclnt.c'
fi
if test -f 'st_sendrecv.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'st_sendrecv.c'\"
else
echo shar: Extracting \"'st_sendrecv.c'\" \(1717 characters\)
sed "s/^X//" >'st_sendrecv.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char *RCSid = "$Header: /ecn1/src/ecn/statsrv/RCS/st_sendrecv.c,v 1.2 87/10/19 08:37:02 davy Exp $";
X#endif
X/*
X * st_sendrecv.c - stream send/recv functions
X *
X * David A. Curry
X * Purdue University
X * Engineering Computer Network
X * davy@riacs.edu (previously davy@intrepid.ecn.purdue.edu)
X * October, 1987
X *
X * $Log:	st_sendrecv.c,v $
X * Revision 1.2  87/10/19  08:37:02  davy
X * Fixed to catch end of file on socket.
X * 
X * Revision 1.1  87/10/17  21:01:46  davy
X * Initial revision
X * 
X */
X#include <sys/param.h>
X#include <sys/socket.h>
X#include <netinet/in.h>
X#include <syslog.h>
X#include <stdio.h>
X
X#include "stats.h"
X
Xextern char	*pname;
Xextern short	server;
X
X/*
X * st_send - send buf on the socket s.
X */
Xst_send(s, buf)
Xchar *buf;
Xint s;
X{
X	register int cnt;
X
X	/*
X	 * We want the length including the null.
X	 */
X	cnt = strlen(buf) + 1;
X
X	/*
X	 * Send the buffer.
X	 */
X	if (send(s, buf, cnt, 0) < 0) {
X		if (server)
X			syslog(LOG_ERR, "send: %m");
X		else
X			error("send");
X		exit(1);
X	}
X}
X
X/*
X * st_recv - receive data of maximum length cnt into the buffer buf on
X *	     socket s.  err describes what we're expecting for the error
X *	     message.
X */
Xst_recv(s, buf, cnt, err)
Xchar *buf, *err;
Xint s, cnt;
X{
X	char c;
X	register int n;
X
X	/*
X	 * Receive a character at a time up to a null.
X	 */
X	do {
X		if ((n = recv(s, &c, sizeof(char), 0)) < 0) {
X			if (server)
X				syslog(LOG_ERR, "recv: %m");
X			else
X				error("recv");
X			exit(1);
X		}
X
X		/*
X		 * End of file.
X		 */
X		if (n == 0)
X			exit(0);
X
X		if (--cnt < 0) {
X			if (server)
X				syslog(LOG_ERR, "%s too long", err);
X			else
X				fprintf(stderr, "%s: %s too long.\n", pname, err);
X			exit(1);
X		}
X
X		*buf++ = c;
X	} while (c != '\0');
X}
END_OF_FILE
if test 1717 -ne `wc -c <'st_sendrecv.c'`; then
    echo shar: \"'st_sendrecv.c'\" unpacked with wrong size!
fi
# end of 'st_sendrecv.c'
fi
if test -f 'rsdclnt.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rsdclnt.h'\"
else
echo shar: Extracting \"'rsdclnt.h'\" \(2854 characters\)
sed "s/^X//" >'rsdclnt.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1989-1994 University of Rochester
X * Department of Electrical Engineering
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that the above copyright notice and this paragraph are
X * duplicated in all such forms and that any documentation,
X * advertising materials, and other materials related to such
X * distribution and use acknowledge that the software was developed
X * at the University of Rochester.
X *
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X
X#ifdef RSDCLNT_C
X#define EXTERN
X#else
X#define EXTERN extern
X#endif
X 
X 
Xstruct machine{
X  char name[MAXHOST];               /* Name of the machine */
X  float factor,limit;               /* Power factor and the limit of the machine */
X} machines[NUMHOSTS];
X
X
X
XEXTERN int commands[2];             /* Parent process gives commands thru this pipe */
XEXTERN int reports[2];              /* Children report results thru this pipe */
XEXTERN int NumErrors;               /* The number of error messages     */
XEXTERN char errors[NUMHOSTS][MAXLINE];     /* Error messages will be kept here */
XEXTERN char ConfigFile[MAXLINE];    /* File that contains info for hosts */
XEXTERN char RemoteShell[MAXLINE];   /* File that contains binary for remote shell */
XEXTERN struct machine LocalHost;    /* Parameters of the local host */
XEXTERN unsigned TimeOut;            /* How many seconds to wait before time-out */
XEXTERN float DesiredPower;          /* Tolerable selection factor: -p switch */
XEXTERN int NumForks;                /* Max. number of allowed forks */
XEXTERN jmp_buf JumpBuffer;          /* Global jump buffer used to abort rstats */
X
X
XEXTERN struct statstime lstats;
X
X
XFILE *fopen();
Xchar *fgets();
Xint getstats();
Xint end_inquiry();
X
XEXTERN int start, 		/* where in the argv the command begins */
X    ppgrp,			/* parent process group			*/
X    command;			/* whether there is a command 		*/
X
XEXTERN boolean  verbose_mode,	/* all possible output			*/
X         quiet_mode;		/* no output				*/
X
XEXTERN int ProcessedMachines;   /* Total number of machines that are processed */
XEXTERN int GivenCommands;       /* Total number of commands given to children  */
XEXTERN int NumHosts;		/* Number of hosts to check                    */
X
X
XEXTERN char *path;
X
XEXTERN char *dir,*pname;
X
XEXTERN char cmd_exec[MAXSHBUF],/* command to execute (local)		*/
X     rcmd_exec[MAXSHBUF],	/* command to execute (remote)		*/
X     host[MAXHOST],		/* hostname placeholder			*/
X     best_host[MAXHOST],	/* hostname placeholder			*/
X     fentry[MAXLINE];		/* file buffer */
X
XEXTERN float my_sfactor,
X      best_sfactor,
X      factor, limit,		/* file variables			*/
X      load;
X
X#undef EXTERN
END_OF_FILE
if test 2854 -ne `wc -c <'rsdclnt.h'`; then
    echo shar: \"'rsdclnt.h'\" unpacked with wrong size!
fi
# end of 'rsdclnt.h'
fi
if test -f 'stats.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stats.h'\"
else
echo shar: Extracting \"'stats.h'\" \(951 characters\)
sed "s/^X//" >'stats.h' <<'END_OF_FILE'
X/*
X * $Header: /ecn1/src/ecn/statsrv/RCS/stats.h,v 1.2 87/12/17 14:54:27 davy Exp $
X *
X * stats.h - definitions for statistics server
X *
X * David A. Curry
X * Purdue University
X * Engineering Computer Network
X * davy@intrepid.ecn.purdue.edu
X * October, 1987
X *
X * $Log:	stats.h,v $
X * Revision 1.2  87/12/17  14:54:27  davy
X * Added defines for VMUNIX and KMEM.
X * 
X * Revision 1.1  87/10/17  21:01:03  davy
X * Initial revision
X * 
X */
X
X#define SERVNAME	"statsrv"	/* name of our service		*/
X#define MAXDGRAM	576		/* maximum size of a datagram	*/
X
X#define KMEM		"/dev/kmem"	/* path to kernel memory	*/
X
X#if vax || sun || gould || tahoe
X#define VMUNIX		"/vmunix"	/* path to kernel		*/
X#endif
X#if sequent
X#define VMUNIX		"/dynix"
X#endif
X
X/*
X * For 4.2BSD syslogs.
X */
X#ifndef LOG_DAEMON
X#define LOG_DAEMON	(3<<3)
X#endif
X
Xextern int st_send(), st_recv();	/* stream send/recv functions	*/
Xextern int dg_send(), dg_recv();	/* datagram send/recv functions	*/
END_OF_FILE
if test 951 -ne `wc -c <'stats.h'`; then
    echo shar: \"'stats.h'\" unpacked with wrong size!
fi
# end of 'stats.h'
fi
if test -f 'config.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config.h'\"
else
echo shar: Extracting \"'config.h'\" \(1657 characters\)
sed "s/^X//" >'config.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1989-1994 University of Rochester
X * Department of Electrical Engineering
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that the above copyright notice and this paragraph are
X * duplicated in all such forms and that any documentation,
X * advertising materials, and other materials related to such
X * distribution and use acknowledge that the software was developed
X * at the University of Rochester.
X *
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X
X#define	CONFIGFILE	"./lb.conf"
X#define	RSH		"/usr/ucb/rsh"
X
X#define loadavg(sp,n)  (((float) (sp)->avenrun[n]) / 256.0)
X
X#define MAXLINE		255		/* largest line in config file      */
X#define MAXSHBUF	10240		/* max size of shell buffer         */
X#define MAXHOST		64		/* longest allowable hostname       */
X#define MAXFNAME	255		/* max length of a file name        */
X#define NUMHOSTS	64		/* {Max} Number of hosts available  */
X
X/*
X * Optimum value for MAXFORKS is the maximum number of machines 
X * that are down, plus at least 1
X *
X */
X#define MAXFORKS	10		/* Max # of forks allowed */
X
X#define TIMEOUT		245		/* seconds to timeout */
X
X#if u3b || u3b5 || sun
X#define MAXFLOAT	((float)3.40282346638528860e+38)
X#endif
X
X#if pdp11 || vax
X#define MAXFLOAT	((float)1.701411733192644299e+38)
X#endif
X
X#ifndef MAXFLOAT
X#define MAXFLOAT	((float)1.701411733192644299e+38)
X#endif
X
X#ifndef FALSE
X#define FALSE		0
X#endif
X
X#ifndef TRUE
X#define TRUE		1
X#endif
X
Xtypedef int boolean;
END_OF_FILE
if test 1657 -ne `wc -c <'config.h'`; then
    echo shar: \"'config.h'\" unpacked with wrong size!
fi
# end of 'config.h'
fi
echo shar: End of shell archive.
exit 0
