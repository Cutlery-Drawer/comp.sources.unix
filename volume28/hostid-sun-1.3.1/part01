Newsgroups: comp.sources.unix
From: markh@vanbc.wimsey.com (Mark C. Henderson)
Subject: v28i136: hostid-sun-1.3.1 - change hostid on a Sun, V1.3.1, Part01/03
References: <1.783419175.2365@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: markh@vanbc.wimsey.com (Mark C. Henderson)
Posting-Number: Volume 28, Issue 136
Archive-Name: hostid-sun-1.3.1/part01

#!/bin/sh
# This is a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 08/24/1994 06:19 UTC by henderso@netcom
# Source directory /u1/henderso
#
# existing files will NOT be overwritten unless -c is specified
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#   5308 -rw------- hid-1.3.1/00README.FIRST
#  13171 -rw------- hid-1.3.1/INSTRUCTIONS
#   7466 -rw------- hid-1.3.1/chenet.c
#   2815 -rw------- hid-1.3.1/getobphostid.c
#   3055 -rw------- hid-1.3.1/hid.c
#   2049 -rw------- hid-1.3.1/hid_solaris2.c
#   1304 -rw------- hid-1.3.1/hostid-by-egid-modload/README
#   2536 -rw------- hid-1.3.1/hostid-by-egid-modload/kern_hostid.c
#    282 -rw------- hid-1.3.1/hostid-by-egid-modload/makefile
#   1197 -rw------- hid-1.3.1/hostid-by-egid-modload/sethostid.c
#     60 -rwx------ hid-1.3.1/hostid-by-egid-modload/sethostid.exec
#   2686 -rw------- hid-1.3.1/hostid-by-egid/README
#   1700 -rw------- hid-1.3.1/hostid-by-egid/kern_hostid.c
#   1085 -rw------- hid-1.3.1/hostid-by-egid/sethostid.c
#   3145 -rwx------ hid-1.3.1/newhostid
#   1289 -rwx------ hid-1.3.1/newhostid.old
#  11553 -rw------- hid-1.3.1/nvram.c
#   9273 -rw------- hid-1.3.1/nvram.info
#   7012 -rw------- hid-1.3.1/nvram_old.c
#   6378 -rw------- hid-1.3.1/sidump.c
#   3434 -rw------- hid-1.3.1/sidump_old.c
#   1121 -rw------- hid-1.3.1/hostid-by-egid-solaris2/sid.c
#   3998 -rw------- hid-1.3.1/hostid-by-egid-solaris2/sethostid.c
#    483 -rw------- hid-1.3.1/hostid-by-egid-solaris2/makefile
#   1730 -rw------- hid-1.3.1/hostid-by-egid-solaris2/README
#    141 -rw------- hid-1.3.1/run/makefile
#   1336 -rw------- hid-1.3.1/run/run.c
#   1726 -rw------- hid-1.3.1/run/README
#    767 -rw------- hid-1.3.1/sethostid-simple-4.1/README
#   1992 -rw------- hid-1.3.1/sethostid-simple-4.1/kern_hostid.c
#    282 -rw------- hid-1.3.1/sethostid-simple-4.1/makefile
#   1083 -rw------- hid-1.3.1/sethostid-simple-4.1/sethostid.c
#     60 -rwx------ hid-1.3.1/sethostid-simple-4.1/sethostid.exec
#   1792 -rw------- hid-1.3.1/changelog
#   1709 -rw------- hid-1.3.1/sethostid-simple-5.3/README
#    483 -rw------- hid-1.3.1/sethostid-simple-5.3/makefile
#   3237 -rw------- hid-1.3.1/sethostid-simple-5.3/sethostid.c
#   1086 -rw------- hid-1.3.1/sethostid-simple-5.3/sid.c
#
# ============= hid-1.3.1/00README.FIRST ==============
if test ! -d 'hid-1.3.1'; then
    echo 'x - creating directory hid-1.3.1'
    mkdir 'hid-1.3.1'
fi
if test -f 'hid-1.3.1/00README.FIRST' -a X"$1" != X"-c"; then
	echo 'x - skipping hid-1.3.1/00README.FIRST (File already exists)'
else
echo 'x - extracting hid-1.3.1/00README.FIRST (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'hid-1.3.1/00README.FIRST' &&
Version: 1.3.1
21 Aug 1994
X
Ever been up at 3am on Monday morning trying to move an essential 
application from one piece of hardware to another and been unable to 
do it because you'll need a new licence key from your vendor and they 
don't give them out at weird hours? Well, here's a solution that 
works in many cases. Basically it allows you to modify the value 
returned by gethostid/sysinfo for the hostid on Solaris 1.x and 2.3 
X
See the file INSTRUCTIONS for more details than provided here.
X
Note that there are examples which show how to load system calls via
modload into running kernels on Sun OS 4.1.x and 5.3. 
X
This kit contains scripts/programs to do this using four different
approaches. These are (pretty much in the order of severity and danger):
1. Use shared libraries to modify the value returned by gethostid/sysinfo
X   for a particular group of dynamically linked executables. Does not
X   work for statically linked executables.
X   newhostid, sidump.c  (Solaris 1.x and 2.3)
X   newhostid was contributed by Jean-Louis Faraut <jlf@sauma.essi.fr>
X
2. Modify the in-core image of the kernel so that all processes on a running 
X   Solaris system will see a different hostid via gethostid/sysinfo.
X   hid.c, hid_solaris2.c (Solaris 1.1 and 2.3), 
X   sethostid-simple-4.1, sethostid-simple-5.3
X
3. Build a new kernel on which certain processes running on a Solaris 1.x 
X   system will see a different hostid which can be set by a new
X      system call (well, really just the old sethostid system call) 
X   hostid-by-egid (Solaris 1.1 only).
X   Contributed by someone who wishes to remain anonymous
X
X   hostid-by-egid-modload - dynamically loadable version of the
X   above. Basically, it lets you load the new sethostid system call
X   without completely rebuilding your kernel. Based on the above
X   contribution.  
X
X   hostid-by-egid-solaris2 - version of this for Solaris 2.3
X
X   As an aside these might be useful to someone because they show
X   how to dynamically load new system calls into the kernel on 
X   Solaris 1.1 and 2.3.
X
4. Reprogram your NVRAM so that you really have changed your hostid.
X   nvram.c (Solaris 1.x only), nvram.info (instructions for
X                                           reprogramming from the monitor)
X   The other approaches just fake your OS into reporting a
X   different hostid via the standard system calls.  This approach is
X   much more dangerous, but you may have to resort to it if your
X   licence manager actually goes and fetches the IDPROM value (perhaps
X   through the OPENPROM interface, see getobphostid.c for a way of
X   doing this). In particular 1 and 2 can be undone very easily (reboot). 
X   Approach 3 can be undone by rebooting with one's old kernel.  The NVRAM 
X   modifier if it is abused or malfunctions can actually render your 
X   machine unbootable, even from CDROM. Read the comments in nvram.c and 
X   nvram.info before trying this. I don't generally recommend it.
X
------------------------------------
I'll try and maintain a copy of the latest version of this package
X  on ftp.netcom.com:/pub/henderso
X
Please don't use these program to steal software or to violate your
licence agreements with software vendors. The intended use is for
emergency situations where an application has to be moved from one
computer to another (e.g. in the event of a hardware malfunction) and
licence keys cannot be obtained quickly from the vendor or when your
NVRAM gets wiped out by some unfortunate accident.
X
USE AT YOUR OWN RISK.
X
nvram.c is particularly dangerous.  Read the comments and proceed with
extreme caution. If this program malfunctions or is misused you can get
your NVRAM into a state where you will no longer be able to boot Sun OS.
Unless you absolutely need to modify your NVRAM, I recommend going with
the approach in hid/hid_solaris2.  Reprogramming your NVRAM can be
useful when it gets wiped out for some reason. BE SURE TO WRITE DOWN
YOUR NVRAM INFO BEFORE YOU MODIFY IT.
X
Finally, if you want to communicate with me regarding this package,
and have privacy concerns, you can send me PGP encrypted messages. 
X
I'd also really appreciate receiving any bug reports, encrypted or 
not.
X
Here's my public key:
X
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: 2.7
X
mQCPAivJ3w4AAAEEAMyer3mwrEAfnY65s17lbIzDKEJBJX5m1rceauKEMM5A41+L
kUvNzdGvvaTxYgvlgQS5u7Q4Iv96BvTJUJHKUTxp+ueZjrZX5glY+T1JVQWSvlph
pJ5QWr4o90de/S4GOpYdKo8JFLfGymzUDTqtm1qxT4KJb+G97eI11LPFgBXjABEB
AAG0Jk1hcmsgQy4gSGVuZGVyc29uIDxtYXJraEB3aW1zZXkuYmMuY2E+iQBFAgUQ
LUwfpi4uv5+/eaLVAQHRDwF/esVjxWAUgDs9A2ATwggbH3cSa+XRq5z3lfnUV+Ws
UuF8lVXg3rwt99JmvGpc7oeRiQCVAgUQLUhKSuULSAGiySfVAQFFvwQAobXItWUp
W+b6GxyLm+yPNNx39MAA9/gqQDbCDiCWHkzN6oVF36uDdEIyIPY9GkpDoucfRzD5
1J1ZYNu5IPa8olvcDpRNe8+WjMhGDw/qgkMFhQUepzsPaUF/7zXnZcLMFIhxY+/9
Jh1chCl+1ABJps/NhlKm6qFk+wgjShuzeFaJAJQCBRAtEatyrXg6KCkPNT0BAVPT
A/dLK1yBmDhYaUcH7ZDWfo29+M9sN+tq1Woq0Ys9tLzoi72LCGrLGTOnQnx2Dvq6
6PMCQ/neu6efY+YWLVOIbiOqjXrF6VAdPi9T+EFJwLDx5S5THgPWtbwzOft7yAPs
HBGZ3Qbc79mg/kj00nx9fHuwNdxMWb51NwkgTC9QqJr1iQCVAgUQK8nffeI11LPF
gBXjAQHOpgP9F67ES+2iWyEEj3JU/k8lT2GAYmxrp2GiZ5yGgFFsMPDob5ZVLK+f
695hcgA6E4218FS/p+BiJlYcjyWazOl1U7g0HB0DvYcKi5s0PF+M8b+0tuD83Hb9
1ygePMmlgHe1+B5w4E1LJtnqcqlhAcLqdz/ZJ31qAVnFUppEALTx2gA=
=VLrB
-----END PGP PUBLIC KEY BLOCK-----
X
Mark Henderson <markh@wimsey.bc.ca>
19 Aug 1994
SHAR_EOF
chmod 0600 hid-1.3.1/00README.FIRST ||
echo 'restore of hid-1.3.1/00README.FIRST failed'
Wc_c="`wc -c < 'hid-1.3.1/00README.FIRST'`"
test 5308 -eq "$Wc_c" ||
	echo 'hid-1.3.1/00README.FIRST: original size 5308, current size' "$Wc_c"
fi
# ============= hid-1.3.1/INSTRUCTIONS ==============
if test -f 'hid-1.3.1/INSTRUCTIONS' -a X"$1" != X"-c"; then
	echo 'x - skipping hid-1.3.1/INSTRUCTIONS (File already exists)'
else
echo 'x - extracting hid-1.3.1/INSTRUCTIONS (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'hid-1.3.1/INSTRUCTIONS' &&
These programs are distributed in the hope that they will be useful,
but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose. You use
these programs at your own risk. The author disclaims responsibility for
any damages that might result from the use of these programs, even
if the damages result from negligence on the part of the author.
X
Please don't use these program to steal software. The intended use is 
for emergency situations where an application has to be moved from 
one computer to another (e.g. in the event of a hardware malfunction) 
and licence keys cannot be obtained quickly from the vendor or when
your NVRAM gets wiped out by some unfortunate accident.
X
Please send bug reports to Mark Henderson <markh@wimsey.bc.ca>
X
----------------------------------------------------------------------
I've included several programs which do different things. All other than
the nvram modifiers nvram.c (nvram_old.c) essentially spoof the 
operating system into believing the system has different hostid
than it really does.
X
Basically I'll break them down as follows:
1. hid.c, hid_solaris2.c, sethostid-simple-4.1, sethostid-simple-5.3
X   These modify the kernel so that a different hostid is returned by
X     gethostid and sysinfo.
X   The first two (hid.c, hid_solaris2.c) just patch a few bytes into
X     the kernel to achieve the desired effect.
X   sethostid-simple-4.1 and sethostid-simple-5.3 add a sethostid system
X     call to the kernel which takes one parameter (the desired hostid).
X
X   Limitations: 
X        1. All processes on the system will report the same hostid.
X        2. Clever programs can figure out that the kernel is reporting
X           a "fake" hostid. There are a couple of ways of validating
X           this. Two I know are: 
X                Solaris 2.3 only - look at _idprom in the kernel
X                Solaris 1.1 and 2.3 - use the openprom interface to 
X                    get the idprom property. (q.v. getobphostid.c)
X
2. hostid-by-egid-solaris2, hostid-by-egid-modload, hostid-by-egid, run
X    These modify the kernel so that a different hostid is returned by
X      gethostid and sysinfo if the process is a member of certain groups
X      or has egid in this set of groups.
X    This allows you to have multiple hostids on a single machine. For instance
X      process A which is in group 900, might see hostid 0x23000000 and process
X      B in group 901 might see hostid 0x80000000
X    run.c is a simple program which executes a command with a group added
X      to its membership list.
X
X    Limitations: as with the above clever programs can try and defeat you.
X
3. newhostid, sidump.c, sidump_old.c, newhostid.old
X    These spoof hostid using the LD_PRELOAD environment variable. Allows
X    a system to appear to have multiple hostids. You don't even need to 
X    have root access to do this.
X
X    Limitations: 
X        1. as with the above clever programs can try and defeat you.
X        2. only works for dynamically linked executables.
X
4. nvram.c, nvram_old.c, nvram.info
X    Instructions and software to modify the hostid in NVRAM for 
X    sun4m, sun4c. Really allows you to modify your hostid.
X
X    Limitations:
X         - You need to be very careful with this. In particular, you
X           can't just change your hostid to an arbitary value. Read 
X           the instructions carefully.
X
One comment about clever programs. You can often defeat the extended
hostid checking they might do. In particular you can spoof the openprom
ioctl interface with these techniques by writing a wrapper around the
system ioctl.
X
Applicability:
X
X
X                            4.1.x   4.1.x   5.3     Notes
X                            sun3    sun4    sun4
getobphostid.c               X       X       X
hid.c                                X       
hid_solaris2.c                               X
hostid-by-egid               X       X 
hostid-by-egid-modload       X       X
hostid-by-egid-solaris2                      X
newhostid                    X       X
nvram.c,chenet.c             X       X              sun3x, sun4c, sun4m only
nvram.info                   X       X       X
run                          X       X       X      for use with egid stuff
sethostid-simple-4.1         X       X
sethostid-simple-5.3                         X
sidump.c                     X       X
X
---
Now for some detailed instructions.
X
----------------------------------------------------------------------
X
hid.c (Solaris 1.x only)
- change hostid reported by Solaris 1.x/SUN OS 4.1.x gethostid
X
1. compile hid.c
X    e.g. cc -o hid hid.c
2. run hid with your desired hostid and it will output
X   a script to stdout that will change the value reported by
X   gethostid
X    e.g. for hostid b0b1fb0b  (hex)
X         ./hid b0b1fb0b >script.sh
X         sh script.sh
X
X    Unless your system security is terrible, you will have to run
X    script.sh as root.
X
X    or simply (as root)
X        ./hid b0b1fb0b | sh
X
3. Rebooting will undo this change, if you want to make it permanent,
X   you have two options
X   a. just place the script output by hid in your /etc/rc.local
X      file
X
X   the script will look something like:
X
X    #!/bin/sh
X    # this script sets the hostid to b0b1bb0b
X    adb -w -k /vmunix /dev/mem <<END
X    _gethostid+4/W 112c2c6e
X    _gethostid+8/W 9012230b
X    END
X
X    b. Modify hid so that the "/W" in the output is "?W" or just
X       modify the file I call script.sh above. This writes 
X       the changes to your /vmunix file instead of just to the in-core
X       kernel image.
X
X    Make a backup copy of your /vmunix before you try this.
X    
X    e.g.
X
X    #!/bin/sh
X    # modified output from "hid b0b1fb0b"
X    # this script modifies /vmunix so that gethostid always reports b0b1fb0b
X    adb -w -k /vmunix /dev/mem <<END
X    _gethostid+4?W 112c2c6e
X    _gethostid+8?W 9012230b
X    END
X   
X    Note that you always input the hostid in hexadecimal, without a leading
X    0x. hid doesn't do a sanity check on its parameter, so you need to
X    be careful about the exact form of this parameter.
X
X    There are some more technical details in the comment at the beginning
X    of hid.c
X
----------------------------------------------------------------------
X
hid_solaris2.c (Solaris 2.3 - I don't know about other 2.x versions)
- change hostid reported by Solaris 2.3 gethostid and sysinfo
X
1. Compile hid_solaris2.c to make the binary hid
X    gcc -o hid hid_solaris2.c
X    (or use another compiler)
X
2. run hid with your desired hostid and it will output
X   a script to stdout that will change the value reported by
X   gethostid
X    e.g. for hostid b0b1fb0b  (hex)
X         ./hid b0b1fb0b >script.sh
X         sh script.sh
X
X    Unless your system security is terrible, you will have to run
X    script.sh as root.
X
X    or simply (as root)
X        ./hid b0b1fb0b | sh
X
3. Rebooting will undo the change. If you want to make it "permanent",
X   i.e. have this new hostid every time your reboot, put the output
X   from hid in one of the system startup files.
X
----------------------------------------------------------------------
X
sidump.c (Solaris 2.3/1.x)
X
modify hostid reported by gethostid and sysinfo for Solaris 2.3 
X   dynamically linked non-setuid/setgid binaries. You do not need
X   to be root for this.
X
new for 0.8.8 - you can override the desired hostid on a per process
X  basis by setting the environment variable HID to the desired hostid
X  in hex - as usual - with no leading 0x
X  e.g. export HID=fedc1234   (ksh)
X       setenv HID "fedc1234" (csh)
X
Instructions:
X
Solaris 1.x
1. compile this program
X    cc -o sidump sidump.c  (or use gcc)
2. run it with the desired hostid as the first parameter and save the output
X    in a file with the extension .c 
X    ./sidump b0b1fb0b >foo.c
3. make foo.o from foo.c
X      gcc -fpic -c foo.c
X      ld foo.o  -assert pure-text -o foo.so
X   OR
X      cc -PIC -c foo.c
X      ld foo.o -assert pure-text -o foo.so
4. export LD_PRELOAD=$PWD/foo.so      (ksh)
X   setenv LD_PRELOAD $PWD/foo.so      (csh)
5. run the desired program
X
here's a sample session
feral> cc -o sidump sidump.c
feral> ./sidump b0b1fb0b >foo.c
feral> cc -PIC -c foo.c
feral> ld -assert pure-text foo.o -o foo.so
feral> export LD_PRELOAD=$PWD/foo.so
feral> lmhostid
feral> lmhostid - Copyright (C) 1989, 1991 Highland Software, Inc.
The FLEXlm host ID of this machine is "b0b1fb0b"
feral> export HID=72000000
feral> lmhostid
lmhostid - Copyright (C) 1989, 1991 Highland Software, Inc.
The FLEXlm host ID of this machine is "72000000"
X
--------------
Solaris 2.x
X
1. compile this program
X    gcc -DSOLARIS2 -o sidump sidump.c
2. run it with the desired hostid as the first parameter and save the output
X    in a file with the extension .c 
X    ./sidump b0b1fb0b >foo.c
3. make foo.o from foo.c
X      gcc -fpic -c foo.c
X      ld foo.o  -G -o foo.so
4. export LD_PRELOAD=$PWD/foo.so      (ksh)
X   setenv LD_PRELOAD $PWD/foo.so      (csh)
5. run the desired program
X
here's a sample session:
X
ratatosk> gcc -o sidump sidump.c
ratatosk> ./sidump b0b1fb0b >foo.c
ratatosk> gcc -fpic -c foo.c
ratatosk> ld foo.o  -G -o foo.so
ratatosk> export LD_PRELOAD=$PWD/foo.so
ratatosk> hostid
b0b1fb0b
ratatosk> lmhostid
lmhostid - Copyright (C) 1989, 1991 Highland Software, Inc.
The FLEXlm host ID of this machine is "b0b1fb0b"
ratatosk> export HID=72000000
ratatosk> lmhostid
lmhostid - Copyright (C) 1989, 1991 Highland Software, Inc.
The FLEXlm host ID of this machine is "72000000"
X
--
To undo this just unset LD_PRELOAD. This only effects processes
for which LD_PRELOAD points to the object you create.
X
X
---------------------------------------------------------------------
newhostid - Solaris 2.3 and Solaris 1.1
Again only for dynamically linked non setuid/setgid binaries.
X  Run a single command "with a different hostid"
X
Simply type
newhostid Base10Hostid command [args]
X
e.g.
for hostid 72000000 (Hex) type
newhostid 1912602624 command arg1 arg2 arg3 ...
X
An older version for Solaris 1.1 only is also provided in newhostid.old
the syntax for this one is slightly different, just
newhostid 72000000 command arg1 arg2 arg3 ...
to run command with hostid 72000000 (all in hex)
X
---------------------------------------------------------------------
X
nvram.c
get/change hostid in NVRAM -- Solaris 1.1 and Sun4c or Sun4m only
X
This program is still experimental. Dangerous and tricky stuff.  If you
are unwilling to experiment and clean up after disasters don't use it.
USE AT YOUR OWN RISK.  If this program malfunctions or it is misused,
you can get your Sun into a state where it will not boot, even from
CDROM. In particular, you should avoid changing the most significant
byte of your hostid which identifies your system type on many Sun
models.
X
1. Read the complete instructions before you proceed. You should
X   probably also read nvram.c
X
2. compile nvram
X   cc -o nvram nvram.c
X
2a. If you aren't already root, become root
X
3. Run nvram without any parameters.
If it fails with some bizarre error message, then your architecture
is not supported. If you don't mind hacking the kernel you can probably
hack in support for your architecture.  If you send me mods I'll fold
them in to the distribution.  
X
It should suggest a few adb commands to execute to make a kernel 
modification.
X
4. Run nvram again without any parameters.  It just prints out the
hostid and hw ethernet address.  Check this against the arp tables on
another machine or against the information displayed on boot. If it is
not correct, do not proceed with the next step.
X
5. now you can try and modify the hostid by running
nvram with the desired hostid as the second parameter (without 0x)
e.g.
nvram b0b1fb0b
X
6. Run the eeprom command suggested by the program.
X
7. reboot (and cross your fingers).
X
X
---------------------------------------------------------------------
hostid-by-egid
X
see hostid-by-egid/README. I've only tested this on a Sparc LX running
Solaris 1.1C
---------------------------------------------------------------------
hostid-by-egid-modload
X
This is similar to hostid-by-egid but you don't have to go off and 
completely recompile your kernel. It loads a new system call using 
modload. You can restore your system state with modunload.
X
see hostid-by-egid-modload/README. I've only tested this on a Sparc 
LX running Solaris 1.1C
X
---------------------------------------------------------------------
hostid-by-egid-solaris2
X
Version of hostid-by-egid-modload for Solaris 2.3
see hostid-by-egid-solaris2/README.
X
---------------------------------------------------------------------
sethostid-simple-4.1, sethostid-simple-5.3
see README files.
run is a convenience program which will run a command with a group id
in the range 900,...,909 added to its group list. For use with the
hostid-by-egid stuff. Works with both Solaris 1.1 and 2.3.
X
---------------------------------------------------------------------
X
nvram.info - this gives some information on modifying the NVRAM
from the Openprom monitor.
X
---------------------------------------------------------------------
run/run.c is useful with the hostid-by-egid* modules.
see run/README for details
SHAR_EOF
chmod 0600 hid-1.3.1/INSTRUCTIONS ||
echo 'restore of hid-1.3.1/INSTRUCTIONS failed'
Wc_c="`wc -c < 'hid-1.3.1/INSTRUCTIONS'`"
test 13171 -eq "$Wc_c" ||
	echo 'hid-1.3.1/INSTRUCTIONS: original size 13171, current size' "$Wc_c"
fi
# ============= hid-1.3.1/chenet.c ==============
if test -f 'hid-1.3.1/chenet.c' -a X"$1" != X"-c"; then
	echo 'x - skipping hid-1.3.1/chenet.c (File already exists)'
else
echo 'x - extracting hid-1.3.1/chenet.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'hid-1.3.1/chenet.c' &&
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <nlist.h>
X
X
/* 
get/change enet addr in NVRAM --
see the comments and instructions in nvram.c
USE AT YOUR OWN RISK
X
1. run chenet without any parameters, follow the instruction 
2. run chenet without any parameters again. It should spit out
X   your enet addr. Do not proceed if it doesn't spit out anything
X   sensible.
3. now run chenet to actually modify the NVRAM
X   e.g. chenet 08 00 20 fd fe fd
X
Placed in the public domain by the author - 1 July 1994
X
only tested on some sun4m architecture and sun4c architecture machines.
The kernel patches will be different for Sun4 and I don't have one to
play with.
X
If your particular machine is not supported, you may be able
to hack support for the machine into this program.
X
This program is still experimental. Dangerous and tricky stuff.
If you are unwilling to experiment and clean up after disasters
don't use it.  USE AT YOUR OWN RISK.  If this program malfunctions
or it is misused, you can get your Sun into a state where it will
not boot, even from CDROM.
X
*/
X
X
#define OFFSET1 017730       /* for Sun 4m, Sun OS 4.1.3 */
#define OFFSET2 03730     /* for Sun 4c, SUN OS 4.1.1 */
X
#define SANITY_CHECK    /* don't turn this off unless you need to. If this
X                           fails it generally means that the program won't
X                           work and very well may be destructive */
X
/* #define TEST        /* doesn't actually do mods if TEST is defined */
unsigned char buf[17];  /* larger than it needs to be */ 
X
/* offset table -- in ascending order of magnitude */
off_t offtab[2] = { OFFSET2, OFFSET1 };
#define nofftab  (sizeof(offtab) / sizeof(off_t))
off_t offset;
X
struct nlist nl[] = { "_mmeeprom" };
void check_eeprom_driver()
{
X    int kmem;
X    off_t where;
X    unsigned int kbuf[12];
X    if ((kmem = open("/dev/kmem", O_RDONLY)) < 0) {
X        fprintf(stderr, "cannot open /dev/kmem\n");
X        exit(1);
X    }
X    if (nlist("/vmunix", nl) < 0) {
X        fprintf(stderr, "cannot read namelist out of /vmunix\n");
X        exit(1);
X    }
X    if ((where = nl[0].n_value) == 0) {
X        fprintf(stderr, "unknown kernel variable _mmeeprom\n");
X        fprintf(stderr, 
X            "your kernel is strange - nvram modifier won't operate\n");
X        exit(1);
X    }
X    if (lseek(kmem, where, SEEK_SET) == (-1)) {
X        fprintf(stderr, "lseek on /dev/kmem failed\n");
X        fprintf(stderr, 
X            "your kernel is strange - nvram modifier won't operate\n");
X        exit(1);
X    }
X    if (read(kmem, (char *)&kbuf[0], 48) < 48) {
X        fprintf(stderr, "read from /dev/kmem failed\n");
X        fprintf(stderr, 
X            "your kernel is strange - nvram modifier won't operate\n");
X        exit(1);
X    }
X    close(kmem);
X    if (kbuf[1] == 0x80a6a7d8 && kbuf[10] == 0x80a6a7d8) {
X        fprintf(stderr, "please execute the following:\n");
X        fprintf(stderr, 
X            "adb -w -k /vmunix /dev/mem <<END\n_mmeeprom+4/W 80a6a7ff\n");
X        fprintf(stderr, "_mmeeprom+0x28/W 80a6a7ff\nEND\n");
X        exit(0);
X    }
X    if (kbuf[2] == 0x901223d8) {
X        fprintf(stderr, "please execute the following:\n");
X        fprintf(stderr, 
X            "adb -k -w /vmunix /dev/mem <<END\n_mmeeprom+8/W 901223ff\nEND\n");
X        exit(0);
X    }
X    if (kbuf[1] == 0x80a6a7ff && kbuf[10] == 0x80a6a7ff) {
X        fprintf(stderr, "your kernel looks good (sun4c)\n");
X    }
X    if (kbuf[2] == 0x901223ff) {
X        fprintf(stderr, "your kernel looks good (sun4m)\n");
X    }
}
X    
X
main(argc,argv)
int argc;
char *argv[];
{
X    int fd;
X    int i;
X    int j;
X    unsigned int new[6];
X    unsigned int acc;
X    int read_enet;
X    unsigned int hid_reported_by_gethostid = gethostid();
X
X    if (argc == 1) {
X        /* no args - just get enetaddr from prom */
X        read_enet = 1;
X    }
X    else if (argc == 7) {
X        read_enet = 0;
X        for (i=0;i<6;i++) {
X            sscanf(argv[i+1],"%x",&new[i]);
X            if (new[i] > 0xff) {
X                fprintf(stderr, "usage: %s [xx xx xx xx xx xx]\n",argv[0]);
X                fprintf(stderr, "  e.g. %s [8 0 20 7 19 4d]\n", argv[0]);
X                exit(1);
X            }
X        }
X    }
X    else {
X        fprintf(stderr, "usage: %s [xx xx xx xx xx xx]\n",argv[0]);
X        fprintf(stderr, "  e.g. %s [8 0 20 7 19 4d]\n", argv[0]);
X        exit(1);
X    }
X    check_eeprom_driver(); /* note: if you know what you are doing you might 
X                                want to comment this line out. */
X    if (read_enet) {
X        if ((fd = open("/dev/eeprom", O_RDONLY)) < 0) {
X            fprintf(stderr, "cannot open /dev/eeprom for read\n");
X            exit(1);
X        }
X    } 
X    else {
#ifdef TEST
X        if ((fd = open("/dev/eeprom", O_RDONLY)) < 0) {
X            fprintf(stderr, "cannot open /dev/eeprom for read\n");
X            exit(1);
X        }
#else
X        if ((fd = open("/dev/eeprom", O_RDWR)) < 0) {
X            fprintf(stderr, "cannot open /dev/eeprom for write\n");
X            exit(1);
X        }
#endif
X    }
X
X    offset = 0xffffffff;     /* dummy value */
X
X    for (j = 0; j < nofftab; j++) {
X        if (lseek(fd,offtab[j],SEEK_SET) < 0) { 
X            fprintf(stderr, "lseek failed for %o\n", offtab[j]);
X            continue;
X        }
X        if (read(fd,buf,16) < 16) {
X            fprintf(stderr, "read of /dev/eeprom failed for %o\n", offtab[j]);
X            continue;
X        }
#ifdef TEST
X        for (i=0; i<16; i++)
X            printf("%02x ", buf[i]);
X        printf("\n");
#endif
/* this will fail if you have modified the value returned by
X   gethostid by using one of the other programs in this package.
X   In that case I wouldn't disable this check, but restore your old 
X   gethostid behaviour or replace the gethostid call in this code 
X   with a reference to your "real" hostid. If your architecture 
X   is weird this should detect the problem and not try and
X   write into places we shouldn't. (remember the AT YOUR OWN RISK 
X   comment). 
X  */
X
X        for (acc = 0 , i=0; i<15; i++) acc^=buf[i];
X        if ((acc != buf[15]) 
X            || (buf[1] != (hid_reported_by_gethostid >> 24) )
X            || (buf[12] != ((hid_reported_by_gethostid >> 16) &0xff))
X            || (buf[13] != ((hid_reported_by_gethostid >> 8) &0xff))
X            || (buf[14] != (hid_reported_by_gethostid &0xff))) {
X            continue;
X        }
X        offset = offtab[j];
X        break;
X    }
X    if (offset == 0xffffffff) {
X        fprintf(stderr, "perhaps you have a weird kernel -- failed\n");
X        exit(1);
X    }
X    printf("current hostid = %02x%02x%02x%02x\n", 
X    buf[1], buf[12], buf[13], buf[14]);
X
X    printf("enetaddr       = %02x:%02x:%02x:%02x:%02x:%02x\n", 
X    buf[2], buf[3], buf[4], buf[5], buf[6], buf[7]);
X    if (!read_enet) {
X        if (lseek(fd,offset,SEEK_SET) < 0) { 
X            fprintf(stderr, "lseek failed\n");
X            exit(1);
X        }
X        for (i=0; i<6; i++) 
X            buf[i+2] = (unsigned char) new[i];
X
X        for (acc = 0 , i=0; i<15; i++) acc^=buf[i];
X        buf[15] = acc & 0xff;
#ifndef TEST
X        if (write(fd,buf,16) < 16) {
X            fprintf(stderr, "write failed\n");
X        }
#else
X    for (i=0; i<16; i++)
X        printf("%02x ", buf[i]);
X    printf("\n");
#endif
X    fprintf(stderr, "now please execute the following command\n");
X    fprintf(stderr, "/usr/etc/eeprom 'diag-switch?=false'\n");
X    }
X    close(fd);
}
X
SHAR_EOF
chmod 0600 hid-1.3.1/chenet.c ||
echo 'restore of hid-1.3.1/chenet.c failed'
Wc_c="`wc -c < 'hid-1.3.1/chenet.c'`"
test 7466 -eq "$Wc_c" ||
	echo 'hid-1.3.1/chenet.c: original size 7466, current size' "$Wc_c"
fi
# ============= hid-1.3.1/getobphostid.c ==============
if test -f 'hid-1.3.1/getobphostid.c' -a X"$1" != X"-c"; then
	echo 'x - skipping hid-1.3.1/getobphostid.c (File already exists)'
else
echo 'x - extracting hid-1.3.1/getobphostid.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'hid-1.3.1/getobphostid.c' &&
/* get idprom info via openprom interface - markh@wimsey.bc.ca 
X *   placed in the public domain by the author - 1 July 1994
X * N.B. the idprom info is actually in NVRAM, so the name is misleading
X *
X * define SOLARIS2 if you are compiling for SOLARIS2 
X * define TEST to include the very simple test driver
X * define DEBUG to produce copious output - including the complete idprom
X *    contents according to openprom 
X *
X * Of course, you need read permission to /dev/openprom to do this. It
X * appears that the default configuration on Solaris 1.x gives everyone
X * read permission, but on Solaris 2.3 you need to be root or in group 
X * sys.
X */
X
#include <fcntl.h>
#include <sys/types.h>
X
#if defined(TEST) || defined(DEBUG)
#include <stdio.h>
#endif
X
#ifdef SOLARIS2
#include <sys/openpromio.h>
#else
#include <sundev/openpromio.h>
#endif
X
X
/* 
X * getobphostid - gets hostid according to the openprom driver
X * returns 0 on failure 
X */
unsigned int getobphostid()
{
X    struct opio {
X       unsigned int size;
X       unsigned char arr[OPROMMAXPARAM];
X    } foo;
X    int fd,done = 0;
#ifdef DEBUG
X    int i;
#endif
X    if ((fd = open("/dev/openprom", O_RDONLY)) < 0) {
#ifdef DEBUG
X        perror("cannot open /dev/openprom");
#endif
X        return (0);
X    }
X    foo.size =  OPROMMAXPARAM;
X    bzero(&foo.arr[0],OPROMMAXPARAM);
X    if (ioctl(fd, OPROMNEXT, &foo) < 0) {
#ifdef DEBUG
X        perror("ioctl failed (OPROMNEXT)");
#endif
X        return(0);
X    }
X    foo.size =  OPROMMAXPARAM;
X    bzero(&foo.arr[0],OPROMMAXPARAM);
X    for (;!done;) {
X        foo.size =  OPROMMAXPARAM;
X        if (ioctl(fd, OPROMNXTPROP, &foo) < 0) {
#ifdef DEBUG
X            perror("ioctl failed (OPROMNXTPROP)");
#endif
X            return(0);
X        }
X        if (foo.size == 0)   /* not on list ! */
X            return 0;
X        if (strncmp(&foo.arr[0], "idprom", 6)) 
X            continue;
#ifdef DEBUG
X        printf("%s: ", &foo.arr[0]);
#endif
X        strcpy(&foo.arr[0],&foo.arr[0]);
X        foo.size=OPROMMAXPARAM;
X        if (ioctl(fd, OPROMGETPROP, &foo) < 0) {
#ifdef DEBUG
X            perror("ioctl failed (OPROMGETPROP)");
#endif
X            return(0);
X        }
#ifdef DEBUG
X        for (i=0;i<foo.size;i++) {
X            if (!(i%8))
X                printf("\n");
X            printf("%02x ",foo.arr[i] & 0xff);
X        }
X        printf("\n");
X        printf("hostid = %02x%02x%02x%02x\n", foo.arr[1], foo.arr[12],
X            foo.arr[13], foo.arr[14]);
X        printf("enet   = %02x:%02x:%02x:%02x:%02x:%02x\n", foo.arr[2],
X            foo.arr[3],foo.arr[4],foo.arr[5],foo.arr[6],foo.arr[7]);
#endif
X        done=1;
X    }   
X    close(fd);
X    return ((foo.arr[1] << 24)|(foo.arr[12] << 16)|(foo.arr[13] << 8)
X            |(foo.arr[14]));
}
#ifdef TEST
X
main()
{
X    printf("%08x\n", getobphostid());
}
#endif
SHAR_EOF
chmod 0600 hid-1.3.1/getobphostid.c ||
echo 'restore of hid-1.3.1/getobphostid.c failed'
Wc_c="`wc -c < 'hid-1.3.1/getobphostid.c'`"
test 2815 -eq "$Wc_c" ||
	echo 'hid-1.3.1/getobphostid.c: original size 2815, current size' "$Wc_c"
fi
# ============= hid-1.3.1/hid.c ==============
if test -f 'hid-1.3.1/hid.c' -a X"$1" != X"-c"; then
	echo 'x - skipping hid-1.3.1/hid.c (File already exists)'
else
echo 'x - extracting hid-1.3.1/hid.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'hid-1.3.1/hid.c' &&
/* 
X
change hostid reported by Solaris 1.x/SUN OS 4.1.x gethostid
run the script produced by this file 
X 
e.g. you could put the following script (produced by hid b0b1fb0b)
X   in /etc/rc.local
X
#!/bin/sh
# this script sets the hostid to b0b1bb0b
adb -w -k /vmunix /dev/mem <<END
_gethostid+4/W 112c2c6e
_gethostid+8/W 9012230b
END
X
to change the hostid to b0b1fb0b
X
Mark Henderson <markh@wimsey.bc.ca>
Placed in the public domain by the author - 3 June 1994
X
This program is distributed in the hope that it will be useful,
but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose. You use
this program at your own risk. The author disclaims responsibility for
any damages that might result from the use of this program, even
if they result from negligence on the part of the author.
X
Also, please don't use this program to steal software. The intended
use is for emergency situations where an application has to be moved from
one computer to another (e.g. in the event of a hardware malfunction)
and licence keys cannot be obtained quickly from the vendor. Many
vendors will not supply licence keys outside of business hours.
X
By way of explanation:
X
hid produces a script which, when executed on a Solaris 1.x machine
will change the value reported by gethostid to the desired value.  adb
is used to alter the in-core kernel image.  No changes are made to the
kernel file itself (/vmunix), so rebooting will undo any
modifications.  If you want to permanently change the value returned by
gethostid/sysinfo, one way to do this is to put the script output
by hid in /etc/rc.local
X
This overwrites two key instructions in the gethostid routine in the
memory image of the kernel (the kernel itself on disk is NOT modified)
X
the original instructions that are overwritten are
_gethostid+4:   call    _machineid
_gethostid+8:   nop
X
If you want the hostid
b0b1fb0b
hid outputs the script
X
adb -w -k /vmunix /dev/mem <<END
_gethostid+4/W 112c2c7e
_gethostid+8/W 9012230b
END
X
going to assembler
the new instructions are:
_gethostid+4:   sethi   %hi(0xb0b1f800), %o0
_gethostid+8:   or      %o0, 0x30b, %o0
X
basically 0x30b is the 10 rightmost bits of the desired
0xb0b1f800 is the 22 rightmost bits of the desired hostid
X
These two instructions set register o0 to the desired value, 
so it is as if machineid returned the desired hostid.
X
*/
X
X
#include <stdio.h>
main(argc,argv)
int argc;
char *argv[];
{
X    unsigned int hid;
X    unsigned int hi;
X    unsigned int low;
X
X    if (argc != 2) {
X        fprintf(stderr, "usage: %s hostid\n",argv[0]);
X        fprintf(stderr, "  e.g. %s b0b1fb0b\n", argv[0]);
X        exit(1);
X    }
X    sscanf(argv[1],"%08x",&hid);
X
X    hi = (hid & 0xfffffc00) >> 10;
X
X    printf("#!/bin/sh\n");
X    printf("# this script sets the hostid to %08x\n",hid);
X    printf("adb -w -k /vmunix /dev/mem <<END\n");
X    printf("_gethostid+4/W 11");
X    printf("%06x\n", hi);
X
X    low = hid & 0x3ff;
X    printf("_gethostid+8/W 90122");
X    printf("%03x\n",low);
X    printf("END\n");
}
SHAR_EOF
chmod 0600 hid-1.3.1/hid.c ||
echo 'restore of hid-1.3.1/hid.c failed'
Wc_c="`wc -c < 'hid-1.3.1/hid.c'`"
test 3055 -eq "$Wc_c" ||
	echo 'hid-1.3.1/hid.c: original size 3055, current size' "$Wc_c"
fi
# ============= hid-1.3.1/hid_solaris2.c ==============
if test -f 'hid-1.3.1/hid_solaris2.c' -a X"$1" != X"-c"; then
	echo 'x - skipping hid-1.3.1/hid_solaris2.c (File already exists)'
else
echo 'x - extracting hid-1.3.1/hid_solaris2.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'hid-1.3.1/hid_solaris2.c' &&
/* change the hostid reported by sysinfo and gethostid on Solaris 2.3
X   - run the script this produces on stdout to actually make the change. Note
X     that you must have adb installed to use this 
X
X    e.g. hid_solaris2 b0b1fb0b | sh -v
X
Mark Henderson <markh@wimsey.bc.ca>
Placed in the public domain by the author - 3 June 1994
X 
This program is distributed in the hope that it will be useful,
but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose. You use
this program at your own risk. The author disclaims responsibility for
any damages that might result from the use of this program, even
if they result from negligence on the part of the author.
X
Also, please don't use this program to steal software. The intended
use is for emergency situations where an application has to be moved from
one computer to another (e.g. in the event of a hardware malfunction)
and licence keys cannot be obtained quickly from the vendor. Many
vendors will not supply licence keys outside of business hours.
X
The hostid is stored in ASCII decimal form in the kernel variable
hw_serial. We simply change the in-core value of the string pointed
to by hw_serial.
X
*/
X
#include <stdio.h>
main(argc,argv)
int argc;
char *argv[];
{
X    unsigned int hid;
X    int i;
X    char obuf[15];
X    for (i=0; i<15; i++)
X        obuf[i] = '\0';
X
X    if (argc != 2) {
X        fprintf(stderr, "usage: %s hostid\n",argv[0]);
X        exit(1);
X    }
X    sscanf(argv[1],"%08x",&hid);
X    sprintf(obuf,"%u", hid);  /* should this be %010u ? */
X
X    printf("#!/bin/sh\n");
X    printf("# this script sets the hostid to %08x\n",hid);
X    printf("adb -w -k /kernel/unix /dev/mem <<END\n");
X    printf("hw_serial/W 0x");
X    for (i=0; i<4; i++)
X        printf("%02x", obuf[i]);
X    printf("\n");
X    printf("hw_serial+4/W 0x");
X    for (; i<8; i++)
X        printf("%02x", obuf[i]);
X    printf("\n");
X    printf("hw_serial+8/W 0x");
X    for (; i<12; i++)
X        printf("%02x", obuf[i]);
X    printf("\n");
X    printf("END\n");
}
SHAR_EOF
chmod 0600 hid-1.3.1/hid_solaris2.c ||
echo 'restore of hid-1.3.1/hid_solaris2.c failed'
Wc_c="`wc -c < 'hid-1.3.1/hid_solaris2.c'`"
test 2049 -eq "$Wc_c" ||
	echo 'hid-1.3.1/hid_solaris2.c: original size 2049, current size' "$Wc_c"
fi
# ============= hid-1.3.1/hostid-by-egid-modload/README ==============
if test ! -d 'hid-1.3.1/hostid-by-egid-modload'; then
    echo 'x - creating directory hid-1.3.1/hostid-by-egid-modload'
    mkdir 'hid-1.3.1/hostid-by-egid-modload'
fi
if test -f 'hid-1.3.1/hostid-by-egid-modload/README' -a X"$1" != X"-c"; then
	echo 'x - skipping hid-1.3.1/hostid-by-egid-modload/README (File already exists)'
else
echo 'x - extracting hid-1.3.1/hostid-by-egid-modload/README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'hid-1.3.1/hostid-by-egid-modload/README' &&
This is based, in part, upon an anonymous contribution. I've improved
it by making it loadable, so one does not have to build a new kernel.
You'll find the original contribution in ../hostid-by-egid
X
This will probably only work on versions of Sun OS later than 4.1.1.
Certainly there is no support for Solaris 5.x
X
to use this:
make load
make sethostid
./sethostid 0 72000000
X
which should modify the hostid for processes with gid 900.
X
You can remove the sethostid call by using modunload. You can check
whether or not it is currently installed with modstat.
X
X     This package check running process's effective gid and user's gid
to determine which hostid should be returned.  If the gid is between
900 to 909, the specified hostid will be returned.  Otherwise, the original
hostid will be returned.  Therefore, you can setgid the target checking
excutable file and it will get what you want when the gethostid system
call is called.  For example, we run '/bin/sethostid 0 12345678'.  All
running processes with gid 900 will get hostid as 12345678 rather than
the real hostid.  Remember the hostid above are all hexadecimal values.
X
N.B. sethostid.exec must be executable. Depending upon where you got
the distribution you might have to chmod +x it.
X
see ../run for a small utility for use with this.
SHAR_EOF
chmod 0600 hid-1.3.1/hostid-by-egid-modload/README ||
echo 'restore of hid-1.3.1/hostid-by-egid-modload/README failed'
Wc_c="`wc -c < 'hid-1.3.1/hostid-by-egid-modload/README'`"
test 1304 -eq "$Wc_c" ||
	echo 'hid-1.3.1/hostid-by-egid-modload/README: original size 1304, current size' "$Wc_c"
fi
# ============= hid-1.3.1/hostid-by-egid-modload/kern_hostid.c ==============
if test -f 'hid-1.3.1/hostid-by-egid-modload/kern_hostid.c' -a X"$1" != X"-c"; then
	echo 'x - skipping hid-1.3.1/hostid-by-egid-modload/kern_hostid.c (File already exists)'
else
echo 'x - extracting hid-1.3.1/hostid-by-egid-modload/kern_hostid.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'hid-1.3.1/hostid-by-egid-modload/kern_hostid.c' &&
/*
This program is distributed in the hope that it will be useful,
but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose. You use
this program at your own risk. The author disclaims responsibility for
any damages that might result from the use of this program, even
if they result from negligence on the part of the author.
X
Also, please don't use this program to steal software. The intended
use is for emergency situations where an application has to be moved from
one computer to another (e.g. in the event of a hardware malfunction)
and licence keys cannot be obtained quickly from the vendor. Many
vendors will not supply licence keys outside of business hours.
*/
X
#include <sys/param.h>
#include <sys/syscall.h>
#include <sys/systm.h>
#include <sys/user.h>
#include <sun/vddrv.h>
X
#define NHOSTID 10
X
static unsigned hostid[NHOSTID]={0};
X
int sethostid();
X
static struct sysent sethostid_sysent = { 2, sethostid } ;
X
static struct vdlsys vd = {
X  VDMAGIC_SYS, /* magic number */
X  "sethostid", /* name */
X  0, /* syscall number (filled in automagically) */
X  &sethostid_sysent /* description of syscall */
};
X
X
Gethostid()
{
X    unsigned machineid;
X    u_short gid;
X    int i;
X
X    gethostid();
X    machineid = u.u_r.r_val1;
X
X    gid = u.u_gid;
X    if (gid >= 900 && gid < 900+NHOSTID) {
X        u.u_r.r_val1 = hostid[gid-900] ? hostid[gid-900] : machineid;
X        return;
X    }
X
X    i = 0;
X    while (gid=u.u_groups[i++]) {
X        if (gid >= 900 && gid < 900+NHOSTID) {
X            u.u_r.r_val1 = hostid[gid-900] ? hostid[gid-900] : machineid;
X            return;
X        }
X    }
X    u.u_r.r_val1 = machineid;
X    return;
}
X
sethostid(uap)
X    register struct a {
X        int n;
X        unsigned hostid;
X    } *uap;
{
X    if (!suser()) {
X        u.u_error = EACCES;
X        return;
X    }
X
X    if ((uap->n >= NHOSTID )||(uap->n < 0)) {  
X        u.u_error = EINVAL;
X        return;
X    }
X
X    u.u_r.r_val1 = hostid[uap->n] = uap->hostid;
X    u.u_error = 0;
X    return;
}
X
X
sethostidinit(function_code, vdp, vdi, vds)
unsigned int function_code;
struct vddrv *vdp;
addr_t vdi;
struct vdstat *vds;
{
X  switch (function_code) {
X  case VDLOAD:
X    vdp->vdd_vdtab = (struct vdlinkage *)&vd;
X    sysent[SYS_gethostid].sy_narg = 2;
X    sysent[SYS_gethostid].sy_call = Gethostid;
X    return 0;
X  case VDUNLOAD:
X    sysent[SYS_gethostid].sy_narg = 2;
X    sysent[SYS_gethostid].sy_call = gethostid;
X    return 0;
X  case VDSTAT:
X    return 0;
X  default:
X    return EIO;
X  }
}
X
SHAR_EOF
chmod 0600 hid-1.3.1/hostid-by-egid-modload/kern_hostid.c ||
echo 'restore of hid-1.3.1/hostid-by-egid-modload/kern_hostid.c failed'
Wc_c="`wc -c < 'hid-1.3.1/hostid-by-egid-modload/kern_hostid.c'`"
test 2536 -eq "$Wc_c" ||
	echo 'hid-1.3.1/hostid-by-egid-modload/kern_hostid.c: original size 2536, current size' "$Wc_c"
fi
# ============= hid-1.3.1/hostid-by-egid-modload/makefile ==============
if test -f 'hid-1.3.1/hostid-by-egid-modload/makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping hid-1.3.1/hostid-by-egid-modload/makefile (File already exists)'
else
echo 'x - extracting hid-1.3.1/hostid-by-egid-modload/makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'hid-1.3.1/hostid-by-egid-modload/makefile' &&
CFLAGS = -DKERNEL
ASFLAGS = -P
X
load: kern_hostid.o
X	chmod +x sethostid.exec
X	/usr/etc/modload kern_hostid.o -v -entry _sethostidinit -exec sethostid.exec
X
sethostid: sethostid.o sethostid.h
X	cc -o sethostid -I. sethostid.c
X
clean:
X	rm -f core *.o sethostid kern_hostid sethostid.h
SHAR_EOF
chmod 0600 hid-1.3.1/hostid-by-egid-modload/makefile ||
echo 'restore of hid-1.3.1/hostid-by-egid-modload/makefile failed'
Wc_c="`wc -c < 'hid-1.3.1/hostid-by-egid-modload/makefile'`"
test 282 -eq "$Wc_c" ||
	echo 'hid-1.3.1/hostid-by-egid-modload/makefile: original size 282, current size' "$Wc_c"
fi
# ============= hid-1.3.1/hostid-by-egid-modload/sethostid.c ==============
if test -f 'hid-1.3.1/hostid-by-egid-modload/sethostid.c' -a X"$1" != X"-c"; then
	echo 'x - skipping hid-1.3.1/hostid-by-egid-modload/sethostid.c (File already exists)'
else
echo 'x - extracting hid-1.3.1/hostid-by-egid-modload/sethostid.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'hid-1.3.1/hostid-by-egid-modload/sethostid.c' &&
/*
This program is distributed in the hope that it will be useful,
but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose. You use
this program at your own risk. The author disclaims responsibility for
any damages that might result from the use of this program, even
if they result from negligence on the part of the author.
X
Also, please don't use this program to steal software. The intended
use is for emergency situations where an application has to be moved from
one computer to another (e.g. in the event of a hardware malfunction)
and licence keys cannot be obtained quickly from the vendor. Many
vendors will not supply licence keys outside of business hours.
*/
X
#include <stdio.h>
#include <sys/syscall.h>
#include <errno.h>
#include "sethostid.h"
X
main(argc, argv)
int argc;
char *argv[];
{
X  unsigned hostid;
X  int n;
X
X  if (argc<3) {
X    fprintf(stderr, "%s <n> <hostid>\n", argv[0]);
X    exit(1);
X  }
X  n=atoi(argv[1]);
X  sscanf(argv[2], "%x", &hostid);
X  fprintf(stderr, "will set hostid for group %d set to %08x\n", 900+n,hostid);
X  if (syscall(SYS_sethostid, n, hostid)==-1) {
X    perror(argv[0]);
X    exit(1);
X  }
}  
X
SHAR_EOF
chmod 0600 hid-1.3.1/hostid-by-egid-modload/sethostid.c ||
echo 'restore of hid-1.3.1/hostid-by-egid-modload/sethostid.c failed'
Wc_c="`wc -c < 'hid-1.3.1/hostid-by-egid-modload/sethostid.c'`"
test 1197 -eq "$Wc_c" ||
	echo 'hid-1.3.1/hostid-by-egid-modload/sethostid.c: original size 1197, current size' "$Wc_c"
fi
true || echo 'restore of hid-1.3.1/hostid-by-egid-modload/sethostid.exec failed'
echo End of part 1, continue with part 2
exit 0
