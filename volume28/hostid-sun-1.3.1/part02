Newsgroups: comp.sources.unix
From: markh@vanbc.wimsey.com (Mark C. Henderson)
Subject: v28i137: hostid-sun-1.3.1 - change hostid on a Sun, V1.3.1, Part02/03
References: <1.783419175.2365@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: markh@vanbc.wimsey.com (Mark C. Henderson)
Posting-Number: Volume 28, Issue 137
Archive-Name: hostid-sun-1.3.1/part02

#!/bin/sh
# This is part 02 of a multipart archive
# ============= hid-1.3.1/hostid-by-egid-modload/sethostid.exec ==============
if test ! -d 'hid-1.3.1'; then
    echo 'x - creating directory hid-1.3.1'
    mkdir 'hid-1.3.1'
fi
if test ! -d 'hid-1.3.1/hostid-by-egid-modload'; then
    echo 'x - creating directory hid-1.3.1/hostid-by-egid-modload'
    mkdir 'hid-1.3.1/hostid-by-egid-modload'
fi
if test -f 'hid-1.3.1/hostid-by-egid-modload/sethostid.exec' -a X"$1" != X"-c"; then
	echo 'x - skipping hid-1.3.1/hostid-by-egid-modload/sethostid.exec (File already exists)'
else
echo 'x - extracting hid-1.3.1/hostid-by-egid-modload/sethostid.exec (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'hid-1.3.1/hostid-by-egid-modload/sethostid.exec' &&
#!/bin/csh -f
echo "#define SYS_sethostid $3" > sethostid.h
SHAR_EOF
chmod 0700 hid-1.3.1/hostid-by-egid-modload/sethostid.exec ||
echo 'restore of hid-1.3.1/hostid-by-egid-modload/sethostid.exec failed'
Wc_c="`wc -c < 'hid-1.3.1/hostid-by-egid-modload/sethostid.exec'`"
test 60 -eq "$Wc_c" ||
	echo 'hid-1.3.1/hostid-by-egid-modload/sethostid.exec: original size 60, current size' "$Wc_c"
fi
# ============= hid-1.3.1/hostid-by-egid/README ==============
if test ! -d 'hid-1.3.1/hostid-by-egid'; then
    echo 'x - creating directory hid-1.3.1/hostid-by-egid'
    mkdir 'hid-1.3.1/hostid-by-egid'
fi
if test -f 'hid-1.3.1/hostid-by-egid/README' -a X"$1" != X"-c"; then
	echo 'x - skipping hid-1.3.1/hostid-by-egid/README (File already exists)'
else
echo 'x - extracting hid-1.3.1/hostid-by-egid/README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'hid-1.3.1/hostid-by-egid/README' &&
Contributed by someone who wishes to remain anonymous. 
X
I've made a couple of minor modifications. - markh@wimsey.bc.ca
X
This program is distributed in the hope that it will be useful,
but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose. You use
this program at your own risk. The author disclaims responsibility for
any damages that might result from the use of this program, even
if they result from negligence on the part of the author.
X
Also, please don't use this program to steal software. The intended
use is for emergency situations where an application has to be moved from
one computer to another (e.g. in the event of a hardware malfunction)
and licence keys cannot be obtained quickly from the vendor. Many
vendors will not supply licence keys outside of business hours.
X
--
X
X     Most commericial packages are bounded to machine hostid for protection.
This ID is built in PROM on Sun Sparc machine.  The purpose of this program
is to let you specify the hostid freely and you can run the commericial
programs on another machine with differnet machine hostid.  This package is
tested and works fine on SunOS 4.1.2, 4.1.3 and 4.1.3_U1.
X
INSTALLATION:
X
step 1.
X  Copy kern_hostid.c into /sys/os
X
step 2.
X  Add the following line in /sys/conf.common/files.cmn
X	os/kern_hostid.c	standard
X
step 3.
X  Replace gethostid declartion with Gethostid, and add the new declartion
of sethostid.  Change system call 143 into sethostid.  The modified version
of /sys/os/init_sysent.c should contain the following lines.
X
line 25:
int     Gethostid(),sethostname(),gethostname(),getpid();
line 32:
int	sethostid();
line 362:
X        2, Gethostid,                   /* 142 = gethostid */
X        2, sethostid,                   /* 143 = old sethostid */
X
step 4:
X  Configure your own kernel and rebuild it.  Install it in /vmunix and
reboot.
X
step 5:
X  Compile sethostid.c and install sethostid in /bin.
X
step 6:
X  Done.
X
USAGE:
X     This package check running process's effective gid and user's gid
to determine which hostid should be returned.  If the gid is between
900 to 909, the specified hostid will be returned.  Otherwise, the original
hostid will be returned.  Therefore, you can setgid the target checking
excutable file and it will get what you want when the gethostid system
call is called.  For example, we run '/bin/sethostid 0 12345678'.  All
running processes with gid 900 will get hostid as 12345678 rather than
the real hostid.  Remember the hostid above are all heximal value.
X     If you have any problem, try to see the source code.  No help is
provided.
X
see ../run for a small utility for use with this.
SHAR_EOF
chmod 0600 hid-1.3.1/hostid-by-egid/README ||
echo 'restore of hid-1.3.1/hostid-by-egid/README failed'
Wc_c="`wc -c < 'hid-1.3.1/hostid-by-egid/README'`"
test 2686 -eq "$Wc_c" ||
	echo 'hid-1.3.1/hostid-by-egid/README: original size 2686, current size' "$Wc_c"
fi
# ============= hid-1.3.1/hostid-by-egid/kern_hostid.c ==============
if test -f 'hid-1.3.1/hostid-by-egid/kern_hostid.c' -a X"$1" != X"-c"; then
	echo 'x - skipping hid-1.3.1/hostid-by-egid/kern_hostid.c (File already exists)'
else
echo 'x - extracting hid-1.3.1/hostid-by-egid/kern_hostid.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'hid-1.3.1/hostid-by-egid/kern_hostid.c' &&
/*
This program is distributed in the hope that it will be useful,
but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose. You use
this program at your own risk. The author disclaims responsibility for
any damages that might result from the use of this program, even
if they result from negligence on the part of the author.
X
Also, please don't use this program to steal software. The intended
use is for emergency situations where an application has to be moved from
one computer to another (e.g. in the event of a hardware malfunction)
and licence keys cannot be obtained quickly from the vendor. Many
vendors will not supply licence keys outside of business hours.
*/
X
#include <sys/user.h>
#define NHOSTID 10
X
static unsigned hostid[NHOSTID]={0};
X
Gethostid()
{
X    unsigned machineid;
X    u_short gid;
X    int i;
X
X    gethostid();
X    machineid = u.u_r.r_val1;
X
X    gid = u.u_gid;
X    if (gid >= 900 && gid < 900+NHOSTID) {
X        u.u_r.r_val1 = hostid[gid-900] ? hostid[gid-900] : machineid;
X        return;
X    }
X
X    i = 0;
X    while (gid=u.u_groups[i++]) {
X        if (gid >= 900 && gid < 900+NHOSTID) {
X            u.u_r.r_val1 = hostid[gid-900] ? hostid[gid-900] : machineid;
X            return;
X        }
X    }
X    u.u_r.r_val1 = machineid;
X    return;
}
X
sethostid(uap)
X    register struct a {
X        int n;
X        unsigned hostid;
X    } *uap;
{
X    if (!suser()) {
X        u.u_error = EACCES;
X        return;
X    }
X
X    if ((uap->n >= NHOSTID )||(uap->n < 0)) {  /* small change - markh */
X        u.u_error = EINVAL;
X        return;
X    }
X
X    u.u_r.r_val1 = hostid[uap->n] = uap->hostid;
X    u.u_error = 0;
X    return;
}
SHAR_EOF
chmod 0600 hid-1.3.1/hostid-by-egid/kern_hostid.c ||
echo 'restore of hid-1.3.1/hostid-by-egid/kern_hostid.c failed'
Wc_c="`wc -c < 'hid-1.3.1/hostid-by-egid/kern_hostid.c'`"
test 1700 -eq "$Wc_c" ||
	echo 'hid-1.3.1/hostid-by-egid/kern_hostid.c: original size 1700, current size' "$Wc_c"
fi
# ============= hid-1.3.1/hostid-by-egid/sethostid.c ==============
if test -f 'hid-1.3.1/hostid-by-egid/sethostid.c' -a X"$1" != X"-c"; then
	echo 'x - skipping hid-1.3.1/hostid-by-egid/sethostid.c (File already exists)'
else
echo 'x - extracting hid-1.3.1/hostid-by-egid/sethostid.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'hid-1.3.1/hostid-by-egid/sethostid.c' &&
/*
This program is distributed in the hope that it will be useful,
but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose. You use
this program at your own risk. The author disclaims responsibility for
any damages that might result from the use of this program, even
if they result from negligence on the part of the author.
X
Also, please don't use this program to steal software. The intended
use is for emergency situations where an application has to be moved from
one computer to another (e.g. in the event of a hardware malfunction)
and licence keys cannot be obtained quickly from the vendor. Many
vendors will not supply licence keys outside of business hours.
*/
X
#include <stdio.h>
#include <sys/syscall.h>
#include <errno.h>
X
main(argc, argv)
int argc;
char *argv[];
{
X  unsigned hostid;
X  int n;
X
X  if (argc<3) {
X    fprintf(stderr, "%s <n> <hostid>\n", argv[0]);
X    exit(1);
X  }
X  n=atoi(argv[1]);
X  sscanf(argv[2], "%x", &hostid);
X  if (syscall(143, n, hostid)==-1) {
X    perror(argv[0]);
X    exit(1);
X  }
}  
X
SHAR_EOF
chmod 0600 hid-1.3.1/hostid-by-egid/sethostid.c ||
echo 'restore of hid-1.3.1/hostid-by-egid/sethostid.c failed'
Wc_c="`wc -c < 'hid-1.3.1/hostid-by-egid/sethostid.c'`"
test 1085 -eq "$Wc_c" ||
	echo 'hid-1.3.1/hostid-by-egid/sethostid.c: original size 1085, current size' "$Wc_c"
fi
# ============= hid-1.3.1/newhostid ==============
if test -f 'hid-1.3.1/newhostid' -a X"$1" != X"-c"; then
	echo 'x - skipping hid-1.3.1/newhostid (File already exists)'
else
echo 'x - extracting hid-1.3.1/newhostid (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'hid-1.3.1/newhostid' &&
#!/bin/sh
#newhostid
#Author: Jean-Louis Faraut [jlf]
#Organization: Ecole Superieure en Sciences Informatiques 
#   (Universite de Nice Sophia-Antipolis)
#Address: Sophia-Antipolis (France)
#
# This program is distributed in the hope that it will be useful,
# but without any warranty; without even the implied warranty of
# merchantability or fitness for a particular purpose. You use
# this program at your own risk. The author disclaims responsibility for
# any damages that might result from the use of this program, even
# if they result from negligence on the part of the author.
# 
# Also, please don't use this program to steal software. The intended
# use is for emergency situations where an application has to be moved from
# one computer to another (e.g. in the event of a hardware malfunction)
# and licence keys cannot be obtained quickly from the vendor. Many
# vendors will not supply licence keys outside of business hours.
#
#run a Sun dynamically linked executable  with a new hostid
# - notes - only works on a Sun. Only tested under Solaris 2.3 and 1.[01]
#         - only works with dymanically linked executables.
#
# SunOS 5.x code is an alpha release (not fully tested)
# usage:
#   newhostid Base10Hostid command [args]
# On Solaris 1.x (Sun OS 4.1.x) you can also
#  newhostid 0x72000000 command
#   if you want to use hex
# Sun OS 5.x note:
# if it turns out that you need somewhat more complete sysinfo emulation
#  check out sidump.c
#Warning: The following file names are used by this script:
#/tmp/gethostid.{c,o,so}           -> if OS == SunOS 4.1.x
#/tmp/sysinfo.{c,c.head,c.tail,so} -> if OS == SunOS 5.x
#
#modify the following line to meet your site requirement
GCC=/opt/gnu/bin/gcc	#only required by SunOS 5.x
#
if [ $# -lt 2 ] 
then
X	echo 'Usage:newhostid hostid(base 10) command [args]'
X	exit 1
fi
X
case `/usr/bin/uname -s` in
X     SunOS) ;;
X     *) echo 'Only for SunOS. Sorry.'
X     exit 1 ;;
esac
X
case `/usr/bin/uname -r` in
X     4.1.*)
X     (cd /tmp
X     cat > gethostid.c <<!
X     gethostid()
X     {
X       return $1;
X       }
!
X       cc -c gethostid.c
X       ld gethostid.o -assert pure-text -o gethostid.so
X       rm gethostid.o gethostid.c
X       )
X
X       shift
X       LD_PRELOAD="/tmp/gethostid.so" $*
X       rm /tmp/gethostid.so
X     ;;
X
X     5.*)
X     (cd /tmp
X     # first part of program
X     STRLEN=`expr $1 : '.*'`
X     cat > sysinfo.c.head <<!
X     long sysinfo(command,buf,count)
X     int command; char *buf; long count;
X     {
!
X
X     # second part of program
X     touch sysinfo.c.tail
X     DOT=""
X     COUNT=0
X     while [ $COUNT -lt $STRLEN ]
X     do
X     	echo "  buf[$COUNT] = '`expr $1 : ${DOT}'\(.\)'`';" >> sysinfo.c.tail
X		DOT=${DOT}.
X			COUNT=`expr $COUNT + 1`
X
X			done
X			echo "buf[$COUNT] = 0;"  >> sysinfo.c.tail
X			cat >> sysinfo.c.tail <<!
X			  return 11l;
X			  }
!
X
X			  cat sysinfo.c.head sysinfo.c.tail > sysinfo.c
X			  rm sysinfo.c.head sysinfo.c.tail
X			  #debug: cat sysinfo.c
X			  $GCC -fpic -c sysinfo.c
X			  ld sysinfo.o  -G -o sysinfo.so
X			  rm sysinfo.o sysinfo.c
X			  )
X
X			  shift
X			  LD_PRELOAD=/tmp/sysinfo.so $*
X			  rm /tmp/sysinfo.so
X    ;;
X
esac
X
X
SHAR_EOF
chmod 0700 hid-1.3.1/newhostid ||
echo 'restore of hid-1.3.1/newhostid failed'
Wc_c="`wc -c < 'hid-1.3.1/newhostid'`"
test 3145 -eq "$Wc_c" ||
	echo 'hid-1.3.1/newhostid: original size 3145, current size' "$Wc_c"
fi
# ============= hid-1.3.1/newhostid.old ==============
if test -f 'hid-1.3.1/newhostid.old' -a X"$1" != X"-c"; then
	echo 'x - skipping hid-1.3.1/newhostid.old (File already exists)'
else
echo 'x - extracting hid-1.3.1/newhostid.old (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'hid-1.3.1/newhostid.old' &&
#!/bin/sh
#newhostid
#Solaris 1.x only
#Author: Jean-Louis Faraut [jlf]
#Organization: Ecole Superieure en Sciences Informatiques (Universite de Nice Sophia-Antipolis)
#Address: Sophia-Antipolis (France)
#run a command with a new hostid
#
# This program is distributed in the hope that it will be useful,
# but without any warranty; without even the implied warranty of
# merchantability or fitness for a particular purpose. You use
# this program at your own risk. The author disclaims responsibility for
# any damages that might result from the use of this program, even
# if they result from negligence on the part of the author.
# 
# Also, please don't use this program to steal software. The intended
# use is for emergency situations where an application has to be moved from
# one computer to another (e.g. in the event of a hardware malfunction)
# and licence keys cannot be obtained quickly from the vendor. Many
# vendors will not supply licence keys outside of business hours.
#
if [ $# -lt 2 ] 
then
X	echo Usage:newhostid hostid command [args]
X	exit 1
fi
(cd /tmp
cat > gethostid.c <<!
gethostid()
{
X  return 0x$1;
}
!
cc -c gethostid.c
ld gethostid.o -assert pure-text -o gethostid.so
rm gethostid.o gethostid.c
)
X
shift
LD_PRELOAD="/tmp/gethostid.so" $*
rm /tmp/gethostid.so
SHAR_EOF
chmod 0700 hid-1.3.1/newhostid.old ||
echo 'restore of hid-1.3.1/newhostid.old failed'
Wc_c="`wc -c < 'hid-1.3.1/newhostid.old'`"
test 1289 -eq "$Wc_c" ||
	echo 'hid-1.3.1/newhostid.old: original size 1289, current size' "$Wc_c"
fi
# ============= hid-1.3.1/nvram.c ==============
if test -f 'hid-1.3.1/nvram.c' -a X"$1" != X"-c"; then
	echo 'x - skipping hid-1.3.1/nvram.c (File already exists)'
else
echo 'x - extracting hid-1.3.1/nvram.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'hid-1.3.1/nvram.c' &&
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <nlist.h>
X
X
/* 
get/change hostid in NVRAM -- Solaris 1.1 only
X
Instructions:
X
1. Read this entire comment. Especially the warnings and disclaimers.
X
2. compile nvram
X   cc -o nvram nvram.c
X
3. Run nvram without any parameters.
If it fails with some bizarre error message, then your architecture
is not supported. If you don't mind hacking the kernel you can probably
hack in support for your architecture.  If you send me mods I'll fold
them in to the distribution.  It should suggest a few adb commands
to execute to make a kernel modification.
X
4. Run nvram again without any parameters.  It just prints out the
hostid and hw ethernet address.  Check this against the arp tables on
another machine or against to information displayed on boot. If it is
not correct, do not proceed with the next step.
X
5. now you can try and modify the hostid by running
nvram with the desired hostid as the second parameter (without 0x)
e.g.
nvram b0b1fb0b
X
6. Run the eeprom command suggested by the program.
---
X
Notes:
only tested on sun4m architecture and sun4c architecture. The
kernel patches will be different for Sun4 and I don't have one
to play with. 
X
you can actually do this on a sun3x machine (sun 3/80). Just remove the
stuff that tries to suggest and check for kernel patches
(check_eeprom_driver). The appropriate bytes are accessible directly
via /dev/eeprom. (Sun OS 4.1.1)
X
If your particular machine is not supported, you may be able
to hack support for the machine into this program.
X
This program is still experimental. Dangerous and tricky stuff.
If you are unwilling to experiment and clean up after disasters
don't use it.  USE AT YOUR OWN RISK.  If this program malfunctions
or it is misused, you can get your Sun into a state where it will
not boot, even from CDROM.
X
Running this might invalidate the overall EEPROM checksum. So after it
make some trivial change with the eeprom command (change the baud
rate on a serial port or something like that
e.g.
/usr/etc/eeprom diag-switch?=false
)
X
first you need to turn off the protection in the OS to keep
you from modifying /dev/eeprom locations after 017730 (or the other offset)
X
nvram will try and figure out what your kernel looks like and suggest
a change to execute using adb. 
X
If you don't care about technical details, follow the instructions below.
The commands will be one of the following:
sun4m machines 
adb -k -w /vmunix /dev/mem
_mmeeprom+8/W 901223ff
X
which changes
or      %o1, 0x3d8, %o1
to
or      %o1, 0x3ff, %o1
X
X
OR
(Sun4c)
X
adb -w /vmunix /dev/mem
_mmeeprom+4/W 80a6a7ff
_mmeeprom+0x28/W 80a6a7ff
which changes a couple of compare operations. 
X
Also be very careful choosing a new hostid.  The first byte of the
hostid identifies the type of system you are running. On modern Suns, OS
boot CDs depend on this information to get the correct architecture. If
you change it you may be reduced to poking around in NVRAM from the
monitor next time you have to boot from CD.
X
Here's a mapping of what gets read into buf (at OFFSET)
buf[0] = always 01?
buf[1] = system id/first byte of hostid.
buf[2] \
buf[3]  \
buf[4]   \  HW ethernet address (6 bytes)
buf[5]    /  
buf[6]  /
buf[7]/
buf[8],...,buf[11] = always 00?
buf[12] = second byte of hostid
buf[13] = third byte of hostid
buf[14] = fourth byte of hostid
buf[15] = checksum
X
the checksum is buf[0] ^ buf[1] ^ ... ^ buf[14]
i.e. it must be the case that the  xor of buf[0] through buf[15] is 0
X
X
Mark Henderson <markh@wimsey.bc.ca>
Placed in the public domain by the author - 23 June 1994
X
This program is distributed in the hope that it will be useful,
but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose. You use
this program at your own risk. The author disclaims responsibility for
any damages that might result from the use of this program, even
if they result from negligence on the part of the author.
X
Also, please don't use this program to steal software. The intended
use is for emergency situations where an application has to be moved from
one computer to another (e.g. in the event of a hardware malfunction)
and licence keys cannot be obtained quickly from the vendor. Many
vendors will not supply licence keys outside of business hours.
X
Sorry about all the legal BS, but given that use of this program is
dangerous and inexperienced people will use it, I don't have much choice
from both an ethical and legal point of view.
X
*/
X
X
#define OFFSET1 017730       /* for Sun 4m, Sun OS 4.1.3 */
#define OFFSET2 03730     /* for Sun 4c, SUN OS 4.1.1 */
X
#define SANITY_CHECK        /* don't turn this off unless you need to. If this
X                               fails it generally means that the program won't
X                               work and very well may be destructive */
X
/* #define TEST        /* doesn't actually do mods if TEST is defined */
unsigned char buf[17];  /* larger than it needs to be */ 
X
/* offset table -- in ascending order of magnitude */
off_t offtab[2] = { OFFSET2, OFFSET1 };
#define nofftab  (sizeof(offtab) / sizeof(off_t))
off_t offset;
X
struct nlist nl[] = { "_mmeeprom" };
void check_eeprom_driver()
{
X    int kmem;
X    off_t where;
X    unsigned int kbuf[12];
X    if ((kmem = open("/dev/kmem", O_RDONLY)) < 0) {
X        fprintf(stderr, "cannot open /dev/kmem\n");
X        exit(1);
X    }
X    fprintf(stderr,"nvram - Mark Henderson <markh@wimsey.bc.ca>\n");
X    fprintf(stderr,
X        "Placed in the public domain by the author - 23 June 1994\n\n");
X    fprintf(stderr,
X        "This program is distributed in the hope that it will be useful,\n");
X    fprintf(stderr,
X        "but without any warranty; without even the implied warranty of\n");
X    fprintf(stderr,
X        "merchantability or fitness for a particular purpose. You use\n");
X    fprintf(stderr,
X    "this program at your own risk. The author disclaims responsibility for\n");
X    fprintf(stderr,
X        "any damages that might result from the use of this program, even\n");
X    fprintf(stderr,
X        "if they result from negligence on the part of the author.\n");
X    fprintf(stderr, 
X        "Malfunction or misuse of this program can damage your computer.\n\n");
X    if (nlist("/vmunix", nl) < 0) {
X        fprintf(stderr, "cannot read namelist out of /vmunix\n");
X        exit(1);
X    }
X    if ((where = nl[0].n_value) == 0) {
X        fprintf(stderr, "unknown kernel variable _mmeeprom\n");
X        fprintf(stderr, 
X            "your kernel is strange - nvram modifier won't operate\n");
X        exit(1);
X    }
X    if (lseek(kmem, where, SEEK_SET) == (-1)) {
X        fprintf(stderr, "lseek on /dev/kmem failed\n");
X        fprintf(stderr, 
X            "your kernel is strange - nvram modifier won't operate\n");
X        exit(1);
X    }
X    if (read(kmem, (char *)&kbuf[0], 48) < 48) {
X        fprintf(stderr, "read from /dev/kmem failed\n");
X        fprintf(stderr, 
X            "your kernel is strange - nvram modifier won't operate\n");
X        exit(1);
X    }
X    close(kmem);
X    if (kbuf[1] == 0x80a6a7d8 && kbuf[10] == 0x80a6a7d8) {
X        fprintf(stderr, "please execute the following:\n");
X        fprintf(stderr, 
X            "adb -w -k /vmunix /dev/mem <<END\n_mmeeprom+4/W 80a6a7ff\n");
X        fprintf(stderr, "_mmeeprom+0x28/W 80a6a7ff\nEND\n");
X        exit(0);
X    }
X    if (kbuf[2] == 0x901223d8) {
X        fprintf(stderr, "please execute the following:\n");
X        fprintf(stderr, 
X            "adb -k -w /vmunix /dev/mem <<END\n_mmeeprom+8/W 901223ff\nEND\n");
X        exit(0);
X    }
X    if (kbuf[1] == 0x80a6a7ff && kbuf[10] == 0x80a6a7ff) {
X        fprintf(stderr, "your kernel looks good (sun4c)\n");
X    }
X    if (kbuf[2] == 0x901223ff) {
X        fprintf(stderr, "your kernel looks good (sun4m)\n");
X    }
}
X    
X
main(argc,argv)
int argc;
char *argv[];
{
X    unsigned int hid;
X    int fd;
X    int i;
X    int j;
X    unsigned int acc;
X    int read_hostid;
X    unsigned int hid_reported_by_gethostid = gethostid();
X
X    if (argc == 1) {
X        /* no args - just get hostid from prom */
X        read_hostid = 1;
X    }
X    else if (argc == 2) {
X        read_hostid = 0;
X        sscanf(argv[1],"%08x",&hid);
X    }
X    else {
X        fprintf(stderr, "usage: %s [hostid]\n",argv[0]);
X        fprintf(stderr, "  e.g. %s b0b1fb0b\n", argv[0]);
X        exit(1);
X    }
X    check_eeprom_driver(); /* note: if you know what you are doing you might 
X                                want to comment this line out. */
X    if (read_hostid) {
X        if ((fd = open("/dev/eeprom", O_RDONLY)) < 0) {
X            fprintf(stderr, "cannot open /dev/eeprom for read\n");
X            exit(1);
X        }
X    } 
X    else {
#ifdef TEST
X        if ((fd = open("/dev/eeprom", O_RDONLY)) < 0) {
X            fprintf(stderr, "cannot open /dev/eeprom for read\n");
X            exit(1);
X        }
#else
X        if ((fd = open("/dev/eeprom", O_RDWR)) < 0) {
X            fprintf(stderr, "cannot open /dev/eeprom for write\n");
X            exit(1);
X        }
#endif
X    }
X
X    offset = 0xffffffff;     /* dummy value */
X
X    for (j = 0; j < nofftab; j++) {
X        if (lseek(fd,offtab[j],SEEK_SET) < 0) { 
X            fprintf(stderr, "lseek failed for %o\n", offtab[j]);
X            continue;
X        }
X        if (read(fd,buf,16) < 16) {
X            fprintf(stderr, "read of /dev/eeprom failed for %o\n", offtab[j]);
X            continue;
X        }
#ifdef TEST
X        for (i=0; i<16; i++)
X            printf("%02x ", buf[i]);
X        printf("\n");
#endif
/* this will fail if you have modified the value returned by
X   gethostid by using one of the other programs in this package.
X   In that case I wouldn't disable this check, but restore your old 
X   gethostid behaviour or replace the gethostid call in this code 
X   with a reference to your "real" hostid. If your architecture 
X   is weird this should detect the problem and not try and
X   write into places we shouldn't. (remember the AT YOUR OWN RISK comment
X  */
X
X        for (acc = 0 , i=0; i<15; i++) acc^=buf[i];
X        if ((acc != buf[15]) 
X            || (buf[1] != (hid_reported_by_gethostid >> 24) )
X            || (buf[12] != ((hid_reported_by_gethostid >> 16) &0xff))
X            || (buf[13] != ((hid_reported_by_gethostid >> 8) &0xff))
X            || (buf[14] != (hid_reported_by_gethostid &0xff))) {
X            continue;
X        }
X        offset = offtab[j];
X        break;
X    }
X    if (offset == 0xffffffff) {
X        fprintf(stderr, "perhaps you have a weird kernel -- failed\n");
X        exit(1);
X    }
X    printf("current hostid = %02x%02x%02x%02x\n", 
X    buf[1], buf[12], buf[13], buf[14]);
X
X    /* may as well print this out */
X    printf("enetaddr       = %02x:%02x:%02x:%02x:%02x:%02x\n", 
X    buf[2], buf[3], buf[4], buf[5], buf[6], buf[7]);
X    if (!read_hostid) {
X        if (lseek(fd,offset,SEEK_SET) < 0) { 
X            fprintf(stderr, "lseek failed\n");
X            exit(1);
X        }
X
X        buf[1] = hid >> 24;
X        buf[12] = (hid >> 16) &0xff;
X        buf[13] = (hid >> 8) &0xff;
X        buf[14] = hid &0xff;
X        for (acc = 0 , i=0; i<15; i++) acc^=buf[i];
X        buf[15] = acc & 0xff;
#ifndef TEST
X        if (write(fd,buf,16) < 16) {
X            fprintf(stderr, "write failed\n");
X        }
#else
X    for (i=0; i<16; i++)
X        printf("%02x ", buf[i]);
X    printf("\n");
#endif
X    fprintf(stderr, "now please execute the following command\n");
X    fprintf(stderr, "/usr/etc/eeprom 'diag-switch?=false'\n");
X    }
X    close(fd);
}
X
SHAR_EOF
chmod 0600 hid-1.3.1/nvram.c ||
echo 'restore of hid-1.3.1/nvram.c failed'
Wc_c="`wc -c < 'hid-1.3.1/nvram.c'`"
test 11553 -eq "$Wc_c" ||
	echo 'hid-1.3.1/nvram.c: original size 11553, current size' "$Wc_c"
fi
# ============= hid-1.3.1/nvram.info ==============
if test -f 'hid-1.3.1/nvram.info' -a X"$1" != X"-c"; then
	echo 'x - skipping hid-1.3.1/nvram.info (File already exists)'
else
echo 'x - extracting hid-1.3.1/nvram.info (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'hid-1.3.1/nvram.info' &&
USE THIS AT YOUR OWN RISK. IF THIS INFORMATION IS ABUSED OR INCORRECT
YOU CAN RENDER YOUR COMPUTER UNBOOTABLE AND MY BET IS THAT SUN WILL
CHARGE A LOT OF MONEY TO FIX THE DAMAGE.
X
Be careful, mistakes can cost a lot.
X
The information in this document is distributed in the hope that 
it will be useful, but without any warranty; without even the 
implied warranty of merchantability or fitness for a particular 
purpose. You use this document at your own risk. The author 
disclaims responsibility for any damages that might result from the 
use of this document, even if they result from negligence or errors 
on the part of the author.
X
Placed in the public domain by the author - 21 Aug 1994
- Mark Henderson <markh@wimsey.bc.ca>
X
X
All numbers in here are in hex.
X
At the bottom of this file, there's also some information on the Sun
3/80.
X
Also look at the NVRAM FAQ. anon ftp from 
thor.ece.uc.edu:/pub/sun-faq/FAQs/eeprom-nvram.faq
X
Here's some information on changing the NVRAM from the Forth based Sun 
Openprom monitor. Consider this a beta release. Eventually I'll probably
submit it to the folks who put out the nvram faq, but for now this
is a seperate document. Also, there is the really nice nvram FAQ which
is posted to comp.sys.sun.hardware routinely.
X
As far as I know, this is only applicable to Sun4m and Sun4c class
machines.  If you have a copy of the Sun Openprom manual (you can get it
off the Solaris 2.3 answerbook), it might be handy to have that on hand
as a reference.
X
These steps are not the shorted path to getting this changed.  Take a
look at nvram.c if you are just interested in modifying your NVRAM
hostid, are running Sun OS 4.1.x and don't care about the details. This
information might also be useful in putting things back together if
nvram.c malfunctions.
X
Before doing anything else, write down a copy of the nvram "idprom" 
information. You can get it under Sun OS 4.1.x by running 
/usr/etc/devinfo -vp (on Solaris 2.x, /usr/sbin/prtconf -vp) or at 
the Openprom monitor prompt by typing the command
.idprom
(yes the "." is part of the command)
You'll need this information if the NVRAM gets screwed up and you need
to try and back out. Having it does not guarantee that you'll be able
to restore it, but life will be easier if you have it.
X
Step 1.
Determine the physical address of the NVRAM (in the case of Sun4m machines
I'm interested in the second page). If you're system is on this table you 
can probably just read it off the table and skip to step 2.
X
X                addr        space       arch
Sun ELC         02000000    obio        sun4c
SS2             02000000    obio        sun4c
Sun Classic     71201000    0           sun4m
Sun LX          71201000    0           sun4m
Sun SS20        f1201000    f           sun4m
Sun SS10-51     f1201000    f           sun4m
X
Thanks to weindlin@pcs.mot.com for supplying some of the data in 
this table.
X
Hopefully this table will get larger as people send me info.
X
If not, proceed as follows (you must be running Sun OS 4.1.x for this):
X
While Sun OS 4.1.x is running (and while the system is idle!!) do the 
following. Modify the instructions accordingly if you have some of 
the security features installed.
X
hold down the L1/Stop key and type a 
you will get a prompt which says
ok
X
For Sun4m machines:
type the command
fefff000 pgmap?
X
the output will list a physical address which might look like
f.f120.1000
X
the part before the first dot is the address space and the rest is
the actual address. This is the SS20 case from the above table.
X
Now type 
go
to resume Sun OS operation.
--
X
For Sun4c machines:
type the command
ffff8000 pgmap?
X
the physical address will probably list a space (in the ELC case the
address space is given as I/O) and an address (again for the ELC
02000000).
X
the monitor will want you to type in this address space as obio
later. The Sun Openprom manual also gives sbus and obmem as possible
address spaces.
X
Now type
go
to resume Sun OS operation.
--
X
At this point if you're really nice, you'll send me an Email message
with your Sun model and physical address/address space so I can add it 
to my table. Indicate whether or not you want me to give credit. Unless
you ask me not to, I'll credit you just below the table.
X
X
2. From this point on it doesn't matter what version of Solaris you
are running.
X
Shut down  your system (e.g. with /etc/halt)
X
3. Make sure you wrote down your original idprom info. You can 
get it by typing .idprom now. 
X
Figure out what your desired hostid and ethernet address are. Note that
you shouldn't change either the first hex byte of the hostid or the
first three bytes of the ethernet address. Doing so can cause problems.
X
4. Map the physical address determined above to address 0 using
the map-page command. The format of the command is:
X
<physical address>  <address space>  <map_to>  map-page
X
e.g. ELC     71201000    obio 0   map-page
X     SS20    f1201000    f    0   map-page
X     Classic 71201000    0    0   map-page
X
5. 
If you are on a Sun4c the virtual address of the idprom information is now 7d8
If you are on a Sun4m the virtual address of the idprom information is now fd8
X
type either
7d8 20 dump
for sun4c
or 
fd8 20 dump
for sun4m
X
as appropriate.
X
6. The information which starts at f/7d8 is as follows:
byte    contents
d8      01    - version number - always 01
d9      first byte of hostid (system type)
da-df   6 byte ethernet address (first three bytes are 08,00,20)
e0-e3   date of manufacture. Often all 0s
e4      second byte of hostid
e5      third byte of hostid
e6      fourth byte of hostid
e7      idprom checksum  - xor of contents of bytes d8-e6
X
Verify that the information the dump command spits out is consistent
with the above. If not, DO NOT PROCEED. 
X
7. Now you can make changes. Be very careful and be sure to recompute
the checksum after making changes. If you don't, you'll get nasty
warnings about an incorrect idprom checksum on boot. I'm know repeating
myself, but don't change the first byte of the hostid or the first three
bytes of the ethernet address. I'm told that the first byte of the
hostid is used to determine the architecture when booting from CDROM on
most current Sun models. If you alter the first three bytes of the
ethernet address you might get message which say that you have a
defective motherboard (but then I don't know of any other consequences
of changing this to some _reasonable_ value, especially avoid 
ff:ff:ff:ff:ff:ff !)
X
The openprom command to change a single byte is
X
<value> <addr> c!
e.g.
44 7dd c!
will change byte 7dd (virtual address) to 44.
X
7d8 20 dump      
or
fd8 20 dump
will give you a listing of this area of NVRAM.
X
X
8. Type reset at the ok prompt. You should then reboot with your new 
hostid/enet addr. 
X
---------------------------------------------------------------------
Here's a table which matches system models with the first byte of the
hostid. This is from a posting to comp.sys.sun.admin by
Andy.Behrens@coat.com
X
X    01  2/1x0
X    02  2/50
X    11  3/160
X    12  3/50
X    13  3/2x0
X    14  3/110
X    17  3/60
X    18  3/e
X    21  4/2x0
X    22  4/1x0
X    23  4/3x0
X    24  4/4x0
X    31  386i/150 or 386i/250
X    41  3/4x0
X    42  3/80
X    51  SPARCstation 1   (4/60)
X    52  SPARCstation IPC (4/40)
X    53  SPARCstation 1+  (4/65)
X    54  SPARCstation SLC (4/20)
X    55  SPARCstation 2   (4/75)
X    56  SPARCstation ELC (4/25)
X    57  SPARCstation IPX (4/50)
X    61  4/e
X    71  4/6x0   (670)
X    72  SPARCstation 10
X    80  SPARCclassic /or/ SPARC 5
X
X
X
---------------------------------------------------------------------
X
Quick steps to modify NVRAM IDPROM info on a Sun 3/80 (people have
to do this because of the usual battery problem, as with the sun4c
machines)
X
All numbers in hex. Tested with version 2.9 PROMS.
X
This may not be the most elegant procedure, but this should allow you
to modify the NVRAM IDPROM info on a sun 3/80.
X
Hit L1-A after you turn it on
X
comment: ^t is a command. Don't try control-T. Only tested with 2.9.2
PROMS.
X
> ^t fef04000
you'll get output which includes the following (samples included)
TIA entry = 33FA500
TIB entry = 33FB80A
PTE = 64000049
X
Write these values down!!
X
now change the TIA entry for fedfa000 to match the above
X
> m a fedfa000
TIA MAP FEDFA000 [...] ? 33FA500
X   hit control-D at next ? prompt
X
now change the TIB entry to match the above
X
> m b fedfa000
TIB MAP FEDFA000 [...] ? 33FB80A
X
now change the pagemap entry to match the above
> p fedfa000
PageMap FEDFA000 [...] ? 64000049
X
> o fedfa7d8
...
X
now enter new IDPROM values. You need to get the checksum right.
X
byte          contents
fedfa7d8      01    - version number - always 01
fedfa7d9      first byte of hostid (system type, 42 for sun 3/80)
fedfa7da-df   6 byte ethernet address (first three bytes are 08,00,20)
fedfa7e0-e3   date of manufacture. Often all 0s
fedfa7e4      second byte of hostid
fedfa7e5      third byte of hostid
fedfa7e6      fourth byte of hostid
fedfa7e7      idprom checksum  - xor of contents of bytes d8-e6
X
X
Note if you have SUN OS 4.1.1 booted (i.e. you're doing this for some other
reason than an IDPROM with invalid data), you can just write values into
fedfa7d8 ... fedfa7e7 with the o command. You don't need to do all the
mapping stuff.
SHAR_EOF
chmod 0600 hid-1.3.1/nvram.info ||
echo 'restore of hid-1.3.1/nvram.info failed'
Wc_c="`wc -c < 'hid-1.3.1/nvram.info'`"
test 9273 -eq "$Wc_c" ||
	echo 'hid-1.3.1/nvram.info: original size 9273, current size' "$Wc_c"
fi
# ============= hid-1.3.1/nvram_old.c ==============
if test -f 'hid-1.3.1/nvram_old.c' -a X"$1" != X"-c"; then
	echo 'x - skipping hid-1.3.1/nvram_old.c (File already exists)'
else
echo 'x - extracting hid-1.3.1/nvram_old.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'hid-1.3.1/nvram_old.c' &&
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
X
/* 
get/change hostid in NVRAM --
X
old version -- I should throw this away. Less friendly but perhaps
X  easier to modify for other types of machines.
X
only tested on sun4m architecture and sun4c architecture. The
kernel patches will be different for Sun4 and I don't have one
to play with. 
X
This program is still experimental. Dangerous and tricky stuff.
If you are unwilling to experiment and clean up after disasters
don't use it. hid is probably safer. USE AT YOUR OWN RISK.
X
Note the define OFFSET below!
X
running this will invalidate the overall NVRAM checksum. So after it
make some trivial change with the eeprom command (change the baud
rate on a serial port or something like that
e.g.
/usr/etc/eeprom diag-switch?=false
)
X
first you need to turn off the protection in the OS to keep
you from modifying /dev/eeprom locations after 017730 
use adb
adb -k -w /vmunix /dev/mem
_mmeeprom+8/W 901223ff
X
which changes
or      %o1, 0x3d8, %o1
to
or      %o1, 0x3ff, %o1
X
X
Unfortunately this change with adb to the eeprom device seems to depend
on the exact version of Sun OS you are running. Don't assume it will
work without looking around intelligently.
X
e.g. For SUN OS 4.1.1 on a Sun 4c you need to:
adb -w /vmunix /dev/mem
_mmeeprom+4/W 80a6a7ff
_mmeeprom+0x28/W 80a6a7ff
which changes a couple of compare operations. 
X
Also be very careful. The first byte of the hostid identifies the type 
of system you are running. On modern Suns OS boot CDs depend on this 
information to get the correct architecture. If you change it you may 
be reduced to poking around in NVRAM from the monitor next time you have
to boot from CD.
X
Here's a mapping of what gets read into buf (at OFFSET)
buf[0] = always 01?
buf[1] = system id/first byte of hostid.
buf[2] \
buf[3]  \
buf[4]   \  HW ethernet address (6 bytes)
buf[5]    /  
buf[6]  /
buf[7]/
buf[8],...,buf[11] = always 00?
buf[12] = second byte of hostid
buf[13] = third byte of hostid
buf[14] = fourth byte of hostid
buf[15] = checksum
X
the checksum is buf[0] ^ buf[1] ^ ... ^ buf[14]
i.e. it must be the case that the  xor of buf[0] through buf[15] is 0
X
Without any parameters, it reports the hostid from NVRAM. Otherwise it
changes it. 
X
Mark Henderson <markh@wimsey.bc.ca>
Placed in the public domain by the author - 23 June 1994
X
This program is distributed in the hope that it will be useful,
but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose. You use
this program at your own risk. The author disclaims responsibility for
any damages that might result from the use of this program, even
if they result from negligence on the part of the author.
X
Also, please don't use this program to steal software. The intended
use is for emergency situations where an application has to be moved from
one computer to another (e.g. in the event of a hardware malfunction)
and licence keys cannot be obtained quickly from the vendor. Many
vendors will not supply licence keys outside of business hours.
X
*/
X
X
#define OFFSET 017730       /* for Sun 4m, Sun OS 4.1.3 */
/* #define OFFSET 03730     /* for Sun 4c, SUN OS 4.1.1 */
X
#define SANITY_CHECK        /* don't turn this off unless you need to. If this
X                               fails it generally means that the program won't
X                               work and very well may be destructive */
X
#undef TEST         /* doesn't actually do mods if TEST is defined */
unsigned char buf[17]; 
X
main(argc,argv)
int argc;
char *argv[];
{
X    unsigned int hid;
X    int fd;
X    int i;
X    unsigned int acc;
X    int read_hostid;
X    unsigned int hid_reported_by_gethostid = gethostid();
X
X    if (argc == 1) {
X        /* no args - just get hostid from prom */
X        read_hostid = 1;
X    }
X    else if (argc == 2) {
X        read_hostid = 0;
X        sscanf(argv[1],"%08x",&hid);
X    }
X    else {
X        fprintf(stderr, "usage: %s [hostid]\n",argv[0]);
X        fprintf(stderr, "  e.g. %s b0b1fb0b\n", argv[0]);
X        exit(1);
X    }
X    if (read_hostid) {
X        if ((fd = open("/dev/eeprom", O_RDONLY)) < 0) {
X            fprintf(stderr, "cannot open /dev/eeprom for read\n");
X            exit(1);
X        }
X    } 
X    else {
#ifdef TEST
X        if ((fd = open("/dev/eeprom", O_RDONLY)) < 0) {
X            fprintf(stderr, "cannot open /dev/eeprom for read\n");
X            exit(1);
X        }
#else
X        if ((fd = open("/dev/eeprom", O_RDWR)) < 0) {
X            fprintf(stderr, "cannot open /dev/eeprom for read\n");
X            exit(1);
X        }
#endif
X    }
X
X    if (lseek(fd,OFFSET,SEEK_SET) < 0) { 
X        fprintf(stderr, "lseek failed\n");
X        exit(1);
X    }
X
X    if (read_hostid) {
X        if (read(fd,buf,16) < 16) {
X            fprintf(stderr, "read of /dev/eeprom failed\n");
X            exit(1);
X        }
X        printf("%02x%02x%02x%02x\n", buf[1], buf[12], buf[13], buf[14]);
X        for (acc = 0 , i=0; i<15; i++) acc^=buf[i];
X        if (acc != buf[15])  {
X            fprintf(stderr, "warning: ID CHKSUM INVALID\n");
X            fprintf(stderr,"^buf = %02x\n", acc & 0xff);
X            fprintf(stderr,"buf[15] = %02x\n", buf[15] & 0xff);
X        }
X    }
X    else {
#ifdef SANITY_CHECK 
/* this will fail if you have modified the value returned by
X   gethostid by using one of the other programs in this package.
X   In that case I wouldn't turn this off but restore your old 
X   gethostid behaviour or replace the gethostid call above with
X   a reference to your "real" hostid, if your architecture 
X   is weird this should detect the problem and not try and
X   write into places we shouldn't. */
X
X        if (read(fd,buf,16) < 16) {
X            fprintf(stderr, "read of /dev/eeprom failed\n");
X            exit(1);
X        }
#ifdef TEST
X        for (i=0; i<16; i++)
X            printf("%02x ", buf[i]);
X        printf("\n");
#endif
X        for (acc = 0 , i=0; i<15; i++) acc^=buf[i];
X        if ((acc != buf[15]) 
X            || (buf[1] != (hid_reported_by_gethostid >> 24) )
X            || (buf[12] != ((hid_reported_by_gethostid >> 16) &0xff))
X            || (buf[13] != ((hid_reported_by_gethostid >> 8) &0xff))
X            || (buf[14] != (hid_reported_by_gethostid &0xff))) {
X        
X            fprintf(stderr, "SANITY CHECK FAILED -- aborting\n");
X            fprintf(stderr, 
X                "perhaps the value of the define OFFSET is wrong\n");
X            exit(1);
X        }
X            
X        if (lseek(fd,OFFSET,SEEK_SET) < 0) { 
X            fprintf(stderr, "lseek failed\n");
X            exit(1);
X        }
X
#endif
X        buf[1] = hid >> 24;
X        buf[12] = (hid >> 16) &0xff;
X        buf[13] = (hid >> 8) &0xff;
X        buf[14] = hid &0xff;
X        for (acc = 0 , i=0; i<15; i++) acc^=buf[i];
X        buf[15] = acc & 0xff;
#ifndef TEST
X        if (write(fd,buf,16) < 16) {
X            fprintf(stderr, "write failed\n");
X        }
#else
X    for (i=0; i<16; i++)
X        printf("%02x ", buf[i]);
X    printf("\n");
X
#endif
X    }
X    close(fd);
}
X
SHAR_EOF
chmod 0600 hid-1.3.1/nvram_old.c ||
echo 'restore of hid-1.3.1/nvram_old.c failed'
Wc_c="`wc -c < 'hid-1.3.1/nvram_old.c'`"
test 7012 -eq "$Wc_c" ||
	echo 'hid-1.3.1/nvram_old.c: original size 7012, current size' "$Wc_c"
fi
true || echo 'restore of hid-1.3.1/sidump.c failed'
echo End of part 2, continue with part 3
exit 0
