Newsgroups: comp.sources.unix
From: tschudin@cui.unige.ch (Christian Tschudin)
Subject: v28i055: m0 - a messenger execution environment, Part05/12
References: <1.770917478.19277@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: tschudin@cui.unige.ch (Christian Tschudin)
Posting-Number: Volume 28, Issue 55
Archive-Name: m0/part05

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 12)."
# Contents:  interp.c l_elemnt.c l_proc.c o_arith.c o_ctrl.c o_type.c
# Wrapped by tschudin@cuisunf on Mon Jun  6 13:26:02 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'interp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'interp.c'\"
else
echo shar: Extracting \"'interp.c'\" \(7229 characters\)
sed "s/^X//" >'interp.c' <<'END_OF_FILE'
X/*
X	interp.c
X*/
X/*  Copyright (c) 1994 Christian F. Tschudin. All rights reserved.
X
X    Distributed under the terms of the GNU General Public License
X    version 2 of june 1991 as published by the Free Software
X    Foundation, Inc.
X
X		     This file is part of M0.
X
XM0 is distributed in the hope that it will be useful, but WITHOUT ANY
XWARRANTY.  No author or distributor accepts responsibility to anyone for
Xthe consequences of using it or for whether it serves any particular
Xpurpose or works at all, unless he says so in writing.  Refer to the GNU
XGeneral Public License for full details. 
X
XEveryone is granted permission to copy, modify and redistribute M0, but
Xonly under the conditions described in the GNU General Public License. 
XA copy of this license is supposed to have been given to you along with
XM0 so you can know your rights and responsibilities.  It should be in a
Xfile named LICENSE.  Among other things, the copyright notice and this
Xnotice must be preserved on all copies.  */
X
X#include "l_proto.h"
X#include "o_proto.h"
X
X
Xstatic retcode interpret();
Xstatic retcode schedule();
X
X
Xretcode
Xinit_interpreter(char *bin, char *lib)
X{
X	byteptr startup;
X	uint mlen;
X	byteptr mstr;
X	eindex m;
X	retcode rc;
X
X	startup = load_m0(bin, lib, "startup.m0");
X	if (!startup)
X		return ERR_IN_INIT;
X	mstr = make_msgr(startup,startup,strlen((char*)startup),0,0,&mlen);
X	m = str_import(0, mstr, mlen, mlen);
X	rc = new_proc(m, 0);
X	if (rc != OK)
X		return ERR_IN_INIT;
X	decref(0, m);
X	rc = run();
X	/* this initialisation process must terminate */
X	if (rc != OK || current != 0)
X		return ERR_IN_INIT;
X
X	return OK;
X}
X
X
Xint runable(void)
X{
X	return schedule() == OK;
X}
X
X
Xretcode
Xrun(void)
X{
X	eindex err_name, err_handler;
X	eindex ei;
X	retcode rc;
X	char *fn;
X
X	if (!current || current->state != S_RUNNING)
X		return IDLE;
X	for(;;) {
X		rc = interpret();
X		if (rc==YIELD_CPU || rc==OK) {
X			if (current->state == S_TERMINATED)
X				remove_proc(current);
X			return rc;
X		}
X		/* else we have an error condition */
X		if (rc == ERR_NOT_IN_HALTED) {
Xabort:
X			current->state = S_TERMINATED;
X			current->last_error = rc;
X#ifdef DEBUG
X			fn = unique_filename("abrt");
X			TRACE(0, printf("  ## abort: process %d dumped to file <%s>\n",
X							current->pid, fn))
X			TRACE(0, dump_process_to_file(fn, current))
X#endif
X			remove_proc(current);
X			return ABORT;
X		}
X		if (current->esp >= MAXESTACK)
X			goto abort;
X		if (dict_load(current, errorhandler_name, &err_handler) != OK)
X			goto abort;
X		if (rc == ERR_OSTACK_OVERFLOW || current->osp >= (MAXOSTACK-2)) {
X			ei = make_array(current, current->os, current->osp);
X			current->osp = 1;
X			current->os[0] = ei;
X			rc = ERR_OSTACK_OVERFLOW;
X		}
X
X		/*
X			at this place we should also deal with
X			an ESTACK_OVERFLOW error ...
X		*/
X
X		/* Push the error object and the name on the operand stack */
X		current->os[current->osp++] = current->err_element;
X		incref(current, current->err_element);
X		err_name = eaddr(current,err_name_array)->V.arr.a[rc];
X		current->os[current->osp++] = err_name;
X		incref(current, err_name);
X		/* Push the error handling routine on the exec stack */
X		ei = make_sub(current, err_handler, 0);
X		eattr(current,ei) |= A_EXECUTABLE;
X		current->es[current->esp++] = ei;
X	}
X}
X
X
Xstatic retcode
Xschedule()
X{
X	mproc p = current;
X	retcode rc;
X
X	if (!current)
X		return IDLE;
X	while ((p = p->next) != current)
X		if (p->state == S_RUNNING)
X			break;
X	if (p->state == S_RUNNING) {
X		current = p;
X		TRACE(1, printf("  ## current process is now %d\n", current->pid))
X		rc = OK;
X	} else {
X		TRACE(1, printf("  ## currently no active process\n"))
X		rc = IDLE;
X	}
X
X	return rc;
X}
X
X
Xstatic retcode
Xinterpret()
X{
X	eindex ei, e;
X	eptr ep;
X	uint len;
X	retcode rc;
X
Xpop_estack:
X	TRACE(5, printf("interpreter loop, pop_estack %d\n", current->esp))
X
X	if (current->esp == 0 ) {
X		current->state = S_TERMINATED;
X		return OK;
X	}
X	current->esp--;
X	ei = current->es[current->esp];
X
X	for (;;) {
X
X	TRACE(4, printf("top of interpreter loop: "))
X	TRACE(4, dump_element(stdout, current, ei))
X
X	    ep = eaddr(current,ei);
X	    if (!(epattr(ep)&A_EXECUTABLE)) {
X		/* push the element on the o-stack */
X		if (current->osp >= MAXOSTACK)
X			return ERR_OSTACK_OVERFLOW;
X		current->os[current->osp] = ei;
X		current->osp++;
X		goto pop_estack;
X	    }
X	    switch (eptype(ep)) {
X		case T_EMPTY:	/* returned on end-of-string */
X			decrefp(current, ei, ep);
X			goto pop_estack;
X		case T_ARRAY:
X			TRACE(5, printf("exec array %d: %d\n",
X							ei, (int) eplen(ep)))
X
X			if (eplen(ep) == 0) {
X				decrefp(current, ei, ep);
X				goto pop_estack;
X			}
X			e = array_get(current, ei, 0);
X			incref(current, e);
X			if (etype(current,e) == T_ARRAY) {
X				/* it must be a user defined procedure */
X				if (current->osp >= MAXOSTACK)
X					return ERR_OSTACK_OVERFLOW;
X				current->os[current->osp++] = e;
X				e = 0;
X			}
X			if (eplen(ep) == 1) {
X				decrefp(current, ei, ep);
X				if (!e)
X					goto pop_estack;
X				ei = e;
X				continue;
X			}
X			if ((epattr(ep)&A_SUB) && eprefcnt(ep) == 1) {
X				eplen(ep) -= 1;
X				ep->V.sub.offset += 1;
X			} else {
X				eindex i = make_sub(current, ei, 1);
X				if (!i) {
X					current->err_element = ei;
X					return ERR_OUT_OF_LOCALS;
X				}
X				eattr(current,i) |= epattr(ep) & A_EXECUTABLE;
X				decrefp(current, ei, ep);
X				ei = i;
X			}
X			if (e) {
X				current->es[current->esp++] = ei;
X				ei = e;
X			}
X			continue;
X		case T_STRING:
X			if (eplen(ep) == 0) {
X				decrefp(current, ei, ep);
X				goto pop_estack;
X			}
X			rc = str_gettoken(current, ei, &len, &e);
X			if (rc != OK ) {
X				current->err_element = ei;
X				return rc;
X			}
X			if (etype(current,e) == T_EMPTY) {
X				decref(current, e);
X				e = 0;
X			} else if (etype(current,e) == T_ARRAY) {
X				/* it must be a user defined procedure */
X				if (current->osp >= MAXOSTACK)
X					return ERR_OSTACK_OVERFLOW;
X				current->os[current->osp++] = e;
X				e = 0;
X			}
X
X			if (len == eplen(ep)) {
X				decrefp(current, ei, ep);
X				if (!e)
X					goto pop_estack;
X				ei = e;
X				continue;
X			}
X			if ((epattr(ep)&A_SUB) && eprefcnt(ep) == 1) {
X				ep->V.sub.offset += len;
X				eplen(ep) -= len;
X			} else {
X				eindex i = make_sub(current, ei, len);
X				if (!i) {
X					current->err_element = ei;
X					return ERR_OUT_OF_LOCALS;
X				}
X				decrefp(current, ei, ep);
X				ei = i;
X				eattr(current,ei) |= A_EXECUTABLE;
X			}
X
X			if (e) {
X				current->es[current->esp++] = ei;
X				ei = e;
X			}
X			continue;
X		case T_NAME:
X			TRACE(5, printf("interpreter: name resultion %d\n", ei))
X
X			if (dict_load(current, ei, &e) == OK) {
X				decrefp(current, ei, ep);
X				ep = eaddr(current,e);
X				if (eptype(ep)==T_ARRAY && (epattr(ep)&A_EXECUTABLE)) {
X					ei = make_sub(current, e, 0);
X					eattr(current,ei) |= A_EXECUTABLE;
X				} else {
X					ei = e;
X					incref(current,ei);
X				}
X				continue;
X			}
X			current->err_element = ei;
X			return ERR_UNDEFINED;
X		case T_PROC:
X			rc = (ep->V.pro.fct)();
X			TRACE(5,
Xprintf("interpreter proc: %d, rc=%d, e-top=%d\n", ei, rc, current->es[current->esp-1]))
X
X			if (rc == OK) {
X				decrefp(current, ei, ep);
X				goto pop_estack;
X			}
X			if (rc == YIELD_CPU) {
X				decrefp(current, ei, ep);
X			} else
X				current->err_element = ei;
X			return rc;
X		default:
X			current->err_element = ei;
X			return ERR_NOT_IMPLEMENTED;
X	    }
X	}
X}
X
X
END_OF_FILE
if test 7229 -ne `wc -c <'interp.c'`; then
    echo shar: \"'interp.c'\" unpacked with wrong size!
fi
# end of 'interp.c'
fi
if test -f 'l_elemnt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'l_elemnt.c'\"
else
echo shar: Extracting \"'l_elemnt.c'\" \(6970 characters\)
sed "s/^X//" >'l_elemnt.c' <<'END_OF_FILE'
X/*
X	l_elemnt.c
X*/
X/*  Copyright (c) 1994 Christian F. Tschudin. All rights reserved.
X
X    Distributed under the terms of the GNU General Public License
X    version 2 of june 1991 as published by the Free Software
X    Foundation, Inc.
X
X		     This file is part of M0.
X
XM0 is distributed in the hope that it will be useful, but WITHOUT ANY
XWARRANTY.  No author or distributor accepts responsibility to anyone for
Xthe consequences of using it or for whether it serves any particular
Xpurpose or works at all, unless he says so in writing.  Refer to the GNU
XGeneral Public License for full details. 
X
XEveryone is granted permission to copy, modify and redistribute M0, but
Xonly under the conditions described in the GNU General Public License. 
XA copy of this license is supposed to have been given to you along with
XM0 so you can know your rights and responsibilities.  It should be in a
Xfile named LICENSE.  Among other things, the copyright notice and this
Xnotice must be preserved on all copies.  */
X
X#include "l_proto.h"
X
X
Xchar *type_names[] = {
X	"empty",
X	"null",
X	"int",
X	"time",
X	"name",
X	"key",
X	"array",
X	"string",
X	"dict",
X	"oper",
X	"mark",
X	"queue",
X	"channel",
X};
X
X
Xstatic
Xget_element_entry(mproc p, eptr *ep)
X{
Xstatic	ushort next_pos;
X	int i;
X	eindex ei;
X
X	if (p) for (i = 0; i < MAXLOCALS; i++, next_pos++) {
X		register eptr base = p->local;
X		if (eptype(base+(next_pos % MAXLOCALS)) == T_EMPTY) {
X			ei = next_pos++ % MAXLOCALS;
X			*ep = base + ei;
X			return ei+1;
X		}
X	} else for (i = 0; i < MAXGLOBALS; i++, next_pos++)
X		if (eptype(global+(next_pos % MAXGLOBALS)) == T_EMPTY) {
X			ei = next_pos++ % MAXGLOBALS;
X			*ep = global + ei;
X			return -ei-1;
X		}
X	return 0;
X}
X
X
Xeindex
Xnew_element(mproc p, byte t)
X{
X	eptr ep;
X	eindex ei;
X
X	ei = get_element_entry(p, &ep);
X	if (!ei)
X		return 0;
X
X	memset((char*)ep, 0, sizeof(struct element_s));
X	eptype(ep) = t;
X	eprefcnt(ep) = 1;
X	epattr(ep) = A_ALL;
X
X	return ei;
X}
X
X
Xvoid
Xfree_element(mproc p, eindex ei)
X{
X	eptr ep = eaddr(p,ei);
X
X	if (!ei || eptype(ep)==T_EMPTY)
X		return;
X	if (epattr(ep)&A_SUB) {
X		eptype(ep) = T_EMPTY;
X		decref(p, ep->V.sub.e);
X		return;
X	}
X	if (epattr(ep)&A_FRAG) {
X		eptype(ep) = T_EMPTY;
X		decref(p, ep->V.fra.f[0]);
X		decref(p, ep->V.fra.f[1]);
X		return;
X	}
X
X	switch (eptype(ep)) {
X	   case T_ARRAY:	array_free(p, ei); return;
X	   case T_DICT:		dict_free(p, ei); return;
X	   case T_KEY:
X	   case T_NAME:		free_name(ei); return;
X	   case T_STRING:	free_string(p, ei); return;
X	   case T_QUEUE:	/* should never happen ... */
X	   case T_INT:		/* ... */
X	   default:		eptype(ep) = T_EMPTY; return;
X	}
X
X}
X
X
Xvoid
Xdecref(mproc p, eindex ei)
X{
X	eptr ep;
X	if (!ei)
X		return;
X	ep = eaddr(p, ei);
X	if (eptype(ep) == T_EMPTY)
X		return;
X	if (eprefcnt(ep) <= 0) {
X		fprintf(stderr, 
X		"  ## *** internal M0 error: negative ref count for %d\n", ei);
X		return;
X	}
X
X	TRACE(4, printf("decref of element %d, %d\n", ei, erefcnt(p,ei)))
X
X	eprefcnt(ep) -= 1;
X	if (eprefcnt(ep) == 0)
X		free_element(p,ei);
X}
X
X
Xeindex
Xmake_sub(mproc p, eindex ei, uint offset)
X{
X	eindex sub;
X	eptr ep = eaddr(p,ei), subp;
X
X	sub = new_element(p, eptype(ep));
X	if (!sub)
X		return 0;
X	subp = eaddr(p, sub);
X	switch (eptype(ep)) {
X	    case T_DICT:
X/*
X	printf("*** internal error: make_sub of a dict %d\n", ei);
X	this is ok for dict_loop
X*/
X	    case T_ARRAY:
X	    case T_STRING:
X	    case T_NAME:
X		eplen(subp) = eplen(ep) - offset;
X		epattr(subp) = epattr(ep) | A_SUB;
X		subp->V.sub.offset = offset;
X		subp->V.sub.e = ei;
X		eprefcnt(ep) += 1;
X		break;
X	    default: /* must be a `primitive' type */
X		memcpy(&subp->V, &(ep->V), sizeof(ep->V));
X		eprefcnt(subp) = 1;
X		break;
X	}
X
X	return sub;
X}
X
X
Xeindex make_global(mproc p, eindex ei)
X{
X	if (ei < 0) {	/* a global element, just increment the refcnt */
X		incref(p, ei);
X		return ei;
X	} else {
X		eindex *ip, r;
X		eptr ep = eaddr(p, ei);
X		byteptr s;
X		int i;
X
X		if (epattr(ep) & A_VISITED)
X			return 0;
X		switch (eptype(ep)) {
X		    case T_ARRAY:
X			epattr(ep) |= A_VISITED;
X			r = new_array(0, eplen(ep));
X			for (i=0; i < eplen(ep); i++) {
X				eindex z;
X				z = make_global(p, array_get(p, ei, i));
X				if (z)
X					array_put(0, r, i, z);
X			}
X			epattr(ep) &= ~A_VISITED;
X			break;
X		    case T_DICT:
X			epattr(ep) |= A_VISITED;
X			r = new_dict(0);
X			for (i=ep->V.dic.alen, ip=ep->V.dic.d; i>0; i--) {
X				eindex k, v; 
X				if (!*ip || *ip == DICT_DELETED) {
X					ip += 2;
X					continue;
X				}
X				k = make_global(p, *ip++);
X				v = make_global(p, *ip++);
X				if (k && v)
X					dict_def(0, r, k, v);
X				if (k) decref(0, k);
X				if (v) decref(0, v);
X			}
X			epattr(ep) &= ~A_VISITED;
X			break;
X		    case T_INT:
X			r = new_element(0, T_INT);
X			gaddr(r)->V.i = ep->V.i;
X			break;
X		    case T_KEY:
X		    case T_NAME:
X			/* it must be a sub type (otherwise its global) */
X			r = make_sub(0, desub(p, ei), 0);
X			epattr(gaddr(r)) = epattr(ep);
X			break;
X		    case T_STRING:
X			s = malloc(eplen(ep));
X			str_export(p, s, ei, 0, eplen(ep));
X			r = str_import(0, s, eplen(ep), eplen(ep));
X			break;
X		    default:
X			fprintf(stderr,
X		"internal error in make_global: unknown type %d, element %d\n",
X							eptype(ep), ei);
X			return 0;
X		}
X#define ATTRMASK	(A_ALL|A_EXECUTABLE)
X		epattr(gaddr(r)) = (epattr(ep)&ATTRMASK) |
X			      (epattr(gaddr(r)) & ~ATTRMASK);
X		return r;
X	}
X}
X
X
Xeindex
Xdesub(mproc p, eindex ei)
X{
X	while (eattr(p,ei)&A_SUB)
X		ei = eaddr(p,ei)->V.sub.e;
X
X	return ei;
X}
X
X
X/* tries to find one (global) reference cycle, and removes it */
Xvoid
Xremove_refcycles()
X{
X}
X
X
Xint
Xelement_equal(mproc p, eindex e1, eindex e2)
X{
X	eptr p1, p2;
X
X	p1 = eaddr(p,e1); p2 = eaddr(p,e2);
X	if (eptype(p1) != eptype(p2))
X		return 0;
X	switch(eptype(p1)){
X	    case T_NULL:
X		return 1;
X	    case T_INT:
X		return p1->V.i == p2->V.i ? 1 : 0;
X	    case T_TIME:
X		return time_eq(&p1->V.tim, &p2->V.tim) ? 1 : 0;
X	    case T_NAME:
X	    case T_KEY:
X		e1 = desub(p, e1);
X		e2 = desub(p, e2);
X	    case T_STRING:
X	    case T_ARRAY:
X	    case T_DICT:
X	    default:
X		return e1 == e2 ? 1 : 0;
X	}
X}
X
X
X/* Create a copy of an element and adjust the refcount of the old element.
X   If the old element had a refcount of 1, no copy is made.
X   In all cases are the access rights afterwards set to A_ALL.
X   Composite objects: only the composite object is copied - all the
X   member elements only have their refcount increased.
X
X*/
Xeindex
Xelement_copy(mproc p, eindex e1)
X{
X	retcode rc;
X	eptr p1 = eaddr(p, e1);
X
X	if (eprefcnt(p1) == 1 || e1 == null_val)
X		increfp(p1);
X	else {
X		eindex e2;
X		eptr p2;
X
X		e2 = get_element_entry(p, &p2);
X		if (!e2)
X			return 0;
X		memcpy((char*)p2, (char*)p1, sizeof(struct element_s));
X		eprefcnt(p2) = 1;
X		switch(eptype(p1)) {
X		    case T_STRING:
X			rc = str_copy(p, e1, p1, p2); break;
X		    case T_ARRAY:
X			rc = array_copy(p, e1, p1, p2); break;
X		    case T_DICT:
X			rc = dict_copy(p, e1, p1, p2); break;
X		    default:
X			rc = OK; break;
X		}
X		if (rc != OK) {
X			eptype(p2) = T_EMPTY;
X			return 0;
X		}
X		decrefp(p, e1, p1);
X		e1 = e2;
X		p1 = p2;
X	}
X
X	return e1;
X}
END_OF_FILE
if test 6970 -ne `wc -c <'l_elemnt.c'`; then
    echo shar: \"'l_elemnt.c'\" unpacked with wrong size!
fi
# end of 'l_elemnt.c'
fi
if test -f 'l_proc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'l_proc.c'\"
else
echo shar: Extracting \"'l_proc.c'\" \(7861 characters\)
sed "s/^X//" >'l_proc.c' <<'END_OF_FILE'
X/*
X	l_proc.c
X*/
X/*  Copyright (c) 1994 Christian F. Tschudin. All rights reserved.
X
X    Distributed under the terms of the GNU General Public License
X    version 2 of june 1991 as published by the Free Software
X    Foundation, Inc.
X
X		     This file is part of M0.
X
XM0 is distributed in the hope that it will be useful, but WITHOUT ANY
XWARRANTY.  No author or distributor accepts responsibility to anyone for
Xthe consequences of using it or for whether it serves any particular
Xpurpose or works at all, unless he says so in writing.  Refer to the GNU
XGeneral Public License for full details. 
X
XEveryone is granted permission to copy, modify and redistribute M0, but
Xonly under the conditions described in the GNU General Public License. 
XA copy of this license is supposed to have been given to you along with
XM0 so you can know your rights and responsibilities.  It should be in a
Xfile named LICENSE.  Among other things, the copyright notice and this
Xnotice must be preserved on all copies.  */
X
X#include "l_proto.h"
X
X
Xmproc current, time_queue;
X
Xstatic ushort next_pid;
X
X/* ------------------------------------------------------------------------ */
X
Xstatic retcode
Xtime_insert(mproc p, eindex t)
X{
X	eindex tout = new_element(p, T_TIME);
X	eptr ep = eaddr(p,tout);
X	struct time_s *tp = &(ep->V.tim);
X	mproc q;
X
X
X	memcpy(tp, &(eaddr(p,t)->V.tim), sizeof(struct time_s));
X	p->timeout = tout;
X
X	if (!time_queue) {
X		time_queue = p;
X		p->timelink = 0;
X		return OK;
X	}
X	if (time_gt(&(eaddr(time_queue,time_queue->timeout)->V.tim), tp)) {
X		p->timelink = time_queue;
X		time_queue = p;
X		return OK;
X	}
X	for (q = time_queue; q->timelink; q = q->timelink)
X		if (time_gt(&(eaddr(q,q->timeout)->V.tim), tp))
X			break;
X	p->timelink = q->timelink;
X	q->timelink = p;
X	return OK;
X}
X
X
Xstatic retcode
Xtime_remove(mproc p)
X{
X	struct time_s *tp;
X	mproc q;
X
X	decref(p, p->timeout);
X	p->timeout = 0;
X
X	if (time_queue == p)
X		time_queue = p->timelink;
X	else {
X		for (q = time_queue; q->timelink != p; q = q->timelink);
X		q->timelink = p->timelink;
X	}
X	p->timelink = 0;
X	return OK;
X}
X
X
X/* ----------------------------------------------------------------------
X   get_queue
X
X   increments the reference to the key only if a new queue is created
X   does NOT increment the refcnt of the queue!
X*/
Xstatic eindex
Xget_queue(eindex key)
X{
X	eindex q = dict_get(0, queuedict, key);
X
X	TRACE(5, printf("get_queue %d: queue key ref count after dict_get: %d\n", key, eprefcnt(gaddr(key))))
X
X	if (q)
X		return q;
X	q = new_element(0, T_QUEUE);
X	epattr(gaddr(q)) |= A_EXEC;
X	dict_def(0, queuedict, key, q);
X	decref(0, q);
X
X	return q;
X}
X
X
X/* ----------------------------------------------------------------------
X   queue_append
X
X*/
Xstatic retcode
Xqueue_append(mproc p, eindex qk)
X{
X	eindex q = get_queue(qk);
X	eptr qp = eaddr(p,q);
X
X	if ((epattr(qp)&A_EXEC) && qp->V.que.head == 0)
X		qp->V.que.head = p;
X	else {
X		if(!qp->V.que.tail)
X			qp->V.que.tail = p;
X		else {
X			mproc p2 = qp->V.que.tail;
X			while (p2->qtail)
X				p2 = p2->qtail;
X			p2->qtail = p;
X		}
X		p->state = S_BLOCKED;
X	}
X	eplen(qp) += 1;
X
X	p->qkey = qk;
X	incref(p, qk);
X
X
X	return OK;
X}
X
X
Xstatic retcode
Xqueue_remove(mproc p)
X{
X	eindex q = get_queue(p->qkey);
X	eptr pq = eaddr(p,q);
X	mproc p2;
X
X	TRACE(5, printf("queue_remove %d: queue key ref count after get_queue: %d\n", p->qkey, erefcnt(p,p->qkey)))
X
X	if (pq->V.que.head == p) {
X		if (epattr(pq)&A_EXEC) {
X			p2 = pq->V.que.tail;
X			pq->V.que.head = p2;
X			if (p2) {
X				pq->V.que.tail = p2->qtail;
X				p2->qtail = 0;
X				p2->state = S_RUNNING;
X				if (p2->timeout) {
X					time_remove(p2);
X					p2->os[p2->osp++] = new_element(p2, T_INT);
X				}
X			}
X		} else
X			pq->V.que.head = 0;
X	} else {
X		p2 = pq->V.que.tail;
X		if (p2 == p)
X			pq->V.que.tail = p->qtail;
X		else {
X			while (p2->qtail != p)
X				p2 = p2->qtail;
X			p2->qtail = p->qtail;
X		}
X	}
X	p->qtail = 0;
X	eplen(pq) -= 1;
X	if (eplen(pq)==0 && (epattr(pq)&A_EXEC))
X		dict_undef(0, queuedict, p->qkey);
X
X	TRACE(5, printf("queue_remove2 %d: queue key ref count after dict_undef: %d\n", p->qkey, erefcnt(p,p->qkey)))
X
X	decref(p, p->qkey);
X	p->qkey = 0;
X
X	p->state = S_RUNNING;
X	return OK;
X}
X
X
X/* msgr string must be global */
X
Xretcode
Xnew_proc(eindex msgrstr, eindex orig)
X{
X	eindex ud, qk, m = 0, c, d;
X	eptr ep, mp = gaddr(msgrstr);
X	mproc p = (mproc) calloc(1, sizeof(struct mproc_s));
X	retcode rc;
X
X	if (!p)
X		return ERR_MALLOC_FAILED;
X
X	if ((epattr(mp) & (A_SUB | A_FRAG)) || eprefcnt(mp) != 1) {
X		byteptr s = (byteptr) malloc(eplen(mp));
X		str_export(0, s, msgrstr, 0, eplen(mp));
X		m = msgrstr;
X		msgrstr = str_import(p, s, eplen(mp), eplen(mp));
X		mp = gaddr(msgrstr);
X	}
X
X	rc = decomp_msgr(p, msgrstr, &qk, &c, &d);
X	if (rc != OK) {
X		if (m)
X			decref(0, msgrstr);
X		free(p);
X		return rc;
X	}
X	TRACE(5, printf("new proc 1/ queue key ref count: %d\n", erefcnt(p,qk)))
X
X	p->last_error = OK;
X	p->state = S_RUNNING;
X
X	p->ds[p->dsp++] = systemdict;
X	incref(p, systemdict);
X	ud = p->ds[p->dsp++] = new_dict(p);	/* user dict */
X
X	dict_def(p, ud, msgr_name, msgrstr);
X	if (m)
X		decref(p, msgrstr);
X	dict_def(p, ud, code_name, c);
X	decref(p, c);
X	if (d) {
X		dict_def(p, ud, data_name, d);
X		decref(p, d);
X	} else
X		dict_def(p, ud, data_name, null_val);
X	dict_def(p, ud, orig_name, orig ? orig : null_val);
X
X	p->es[p->esp++] = msgr_start;
X	incref(p, msgr_start);
X
X	if (!current)
X		current = p->next = p->last = p;
X	else {
X		p->next = current;
X		p->last = current->last;
X		p->last->next = p;
X		current->last = p;
X	}
X
X	p->pid = next_pid++;
X	rc = enqueue(p, qk, 0);
X	decref(p, qk);
X
X	TRACE(5, printf("new proc 2/ queue key ref count: %d\n", erefcnt(p,qk)))
X	TRACE(1, printf("  ## new process %d\n", p->pid))
X
X	return rc;
X}
X
X
Xvoid
Xremove_proc(mproc p)
X{
X	eindex *ip;
X	eptr ep;
X	int i;
X
X
X	TRACE(1, printf("  ## removing process %d\n", p->pid))
X
X	if (p->qkey)
X		dequeue(p);
X	if (p->timeout)
X		time_remove(p);
X	if (p->err_element)
X		decref(p,p->err_element);
X	for (i=p->osp, ip=p->os; i > 0; i--, ip++)
X		decref(p, *ip);
X	for (i=p->dsp, ip=p->ds; i > 0; i--, ip++)
X		decref(p, *ip);
X	for (i=p->esp, ip=p->es; i > 0; i--, ip++)
X		decref(p, *ip);
X
X	for (i = 1, ep = p->local; i <= MAXLOCALS; i++, ep++)
X		if (eptype(ep) != T_EMPTY)
X			decref(p, i);
X
X	if (current == p && p->next == p)
X		current = 0;
X	else {
X		if (current == p)
X			current = p->next;
X		p->next->last = p->last;
X		p->last->next = p->next;
X	}
X	free(p);
X}
X
X
Xretcode
Xenqueue(mproc p, eindex qkey, eindex t)
X{
X	if (p->qkey)
X		dequeue(p);
X	queue_append(p, qkey);
X	if (p->state != S_BLOCKED)
X		return OK;
X
X	if (t)
X		time_insert(p, t);
X
X	return YIELD_CPU;
X}
X
X
Xvoid
Xdequeue(mproc p)
X{
X	TRACE(5, printf("dequeue %d: queue key ref count: %d\n", p->qkey, erefcnt(p,p->qkey)))
X
X	queue_remove(p);
X	if (p->timeout) {
X		time_remove(p);
X		p->os[p->osp++] = new_element(p, T_INT);
X		p->state = S_RUNNING;
X	}
X
X	return;
X}
X
X
Xvoid
Xtimeout(mproc p)
X{
X	eindex r = new_element(p, T_INT);
X
X	queue_remove(p);
X	time_remove(p);
X
X	eaddr(p,r)->V.i = 1;
X	p->os[p->osp++] = r;
X	p->state = S_RUNNING;
X
X	return;
X}
X
X
Xvoid
Xqueue_state(eindex qk, sint stopped)
X{
X	eindex q = get_queue(qk);
X	eptr qp= gaddr(q);
X/*
X	decref(0, qk);
X*/
X	if (stopped)
X		epattr(qp) &= ~A_EXEC;
X	else if (eplen(qp) == 0)
X		dict_undef(0, queuedict, qk);
X	else {
X		epattr(qp) |= A_EXEC;
X		if (!qp->V.que.head) {
X			mproc p = qp->V.que.tail;
X			qp->V.que.head = p;
X			qp->V.que.tail = p->qtail;
X			p->qtail = 0;
X			p->state = S_RUNNING;
X			if (p->timeout) {
X				time_remove(p);
X				p->os[p->osp++] = new_element(p, T_INT);
X			}
X		}
X	}
X	return;
X}
X
X
Xget_proc_stats(uint *active, uint *blocked, uint *timeout)
X{
X	mproc p = current;
X
X	*active = *blocked = *timeout = 0;
X
X	if (!current)
X		return 0;
X
X	do {
X		if (p->state == S_RUNNING)
X			*active +=1;
X		else if (p->state == S_BLOCKED)
X			*blocked += 1;
X		p = p->next;
X	} while (p != current);
X
X	for (p = time_queue; p; p = p->timelink)
X		*timeout += 1;
X
X
X	*blocked -= *timeout;
X
X	return 0;
X}
END_OF_FILE
if test 7861 -ne `wc -c <'l_proc.c'`; then
    echo shar: \"'l_proc.c'\" unpacked with wrong size!
fi
# end of 'l_proc.c'
fi
if test -f 'o_arith.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'o_arith.c'\"
else
echo shar: Extracting \"'o_arith.c'\" \(8125 characters\)
sed "s/^X//" >'o_arith.c' <<'END_OF_FILE'
X/*
X	o_arith.c
X*/
X/*  Copyright (c) 1994 Christian F. Tschudin. All rights reserved.
X
X    Distributed under the terms of the GNU General Public License
X    version 2 of june 1991 as published by the Free Software
X    Foundation, Inc.
X
X		     This file is part of M0.
X
XM0 is distributed in the hope that it will be useful, but WITHOUT ANY
XWARRANTY.  No author or distributor accepts responsibility to anyone for
Xthe consequences of using it or for whether it serves any particular
Xpurpose or works at all, unless he says so in writing.  Refer to the GNU
XGeneral Public License for full details. 
X
XEveryone is granted permission to copy, modify and redistribute M0, but
Xonly under the conditions described in the GNU General Public License. 
XA copy of this license is supposed to have been given to you along with
XM0 so you can know your rights and responsibilities.  It should be in a
Xfile named LICENSE.  Among other things, the copyright notice and this
Xnotice must be preserved on all copies.  */
X
X#include "l_proto.h"
X#include "o_proto.h"
X
X/* data types and possible operations:
X	array	array	+
X	string	string	+ > <
X	time	time	- > <
X	time	int	+ -
X		int	~
X	int	int	+ - * / < > | & ^ %
X	int	time	+
X		key	~
X	key	key	| & ^
X	any	any	=
X*/
X
X
X/* functions for integer types: */
X
Xstatic retcode divide(sint a, sint b, sint *r)
X	{ if (!b) return ERR_DIVISION_BY_ZERO; *r = a/b; return OK; }
Xstatic retcode mod(sint a, sint b, sint *r)
X	{ if (!b) return ERR_DIVISION_BY_ZERO; *r = a%b; return OK; }
Xstatic retcode mul(sint a, sint b, sint *r)	{ *r = a*b; return OK; }
X
X
Xstatic retcode
Xdo_binary(retcode (*fct)(sint a, sint b, sint *r))
X{	
X	eindex res;
X	sint v;
X	retcode rc;
X
X	load_2_args(a, b, ap, bp);
X
X	if (eptype(ap) != T_INT || eptype(bp) != T_INT)
X		return ERR_TYPE_CHECK;
X	rc = fct(ap->V.i, bp->V.i, &v);
X	if (rc != OK)
X		return rc;
X	res = new_element(current, T_INT);
X	eaddr(current, res)->V.i = v;
X
X	decrefp(current, a, ap);
X	decrefp(current, b, bp);
X	return_ok_result(2, res);
X}
X
X
Xretcode o_div()		{ return do_binary(divide); }
Xretcode o_mod()		{ return do_binary(mod); }
Xretcode o_mul()		{ return do_binary(mul); }
X
X
X/* ------------------------------------------------------------------------- */
X
Xretcode o_add()
X{
X	eindex res;
X	eptr rp;
X
X	load_2_args(e1, e2, p1, p2);
X
X	if (eptype(p1) == T_INT && eptype(p2) == T_INT) {
X		res = new_element(current, T_INT);
X		eaddr(current, res)->V.i = p1->V.i + p2->V.i;
X	} else if (eptype(p1) == T_STRING && eptype(p2) == T_STRING) {
X		res = new_element(current, T_STRING);
X		rp = eaddr(current, res);
X		epattr(rp) = A_FRAG | (A_ALL & epattr(p1) & epattr(p2));
X		rp->V.fra.f[0] = e1;
X		rp->V.fra.f[1] = e2;
X		eplen(rp) = eplen(p1)+eplen(p2);
X		increfp(p1);
X		increfp(p2);
X	} else if (eptype(p1) == T_ARRAY && eptype(p2) == T_ARRAY) {
X		int i, j;
X		res = new_array(current, eplen(p1)+eplen(p2));
X
X		for (i = 0; i < eplen(p1); i++)
X			array_put(current, res, i, array_get(current, e1, i));
X		for (i = 0, j = eplen(p1); i < eplen(p2); i++, j++)
X			array_put(current, res, j, array_get(current, e2, i));
X	} else if (eptype(p1) == T_TIME && eptype(p2) == T_INT)
X		res = time_addint(current, e1, p2->V.i);
X	else if (eptype(p1) == T_INT && eptype(p2) == T_TIME)
X		res = time_addint(current, e2, p1->V.i);
X	else
X		return ERR_TYPE_CHECK;
X
X	rp = eaddr(current, res);
X	if (eptype(rp) == T_STRING || eptype(rp) == T_ARRAY || eptype(rp) == T_TIME)
X		epattr(rp) &= ~A_ALL | (epattr(p1) & epattr(p2));
X
X	decrefp(current, e1, p1);
X	decrefp(current, e2, p2);
X	return_ok_result(2, res);
X}
X
X
Xretcode o_and()
X{
X	eindex res;
X
X	load_2_args(e1, e2, p1, p2);
X
X	if (eptype(p1) == T_INT && eptype(p2) == T_INT) {
X		res = new_element(current, T_INT);
X		eaddr(current, res)->V.i = p1->V.i & p2->V.i;
X	} else if (eptype(p1) == T_KEY && eptype(p2) == T_KEY) {
X		byteptr s = p2->V.nam.u.s;
X		byte k[8];
X		int i;
X		memcpy(k, (char*)(p1->V.nam.u.s), 8);
X		for (i = 0; i < 8; i++, s++)
X			k[i] &= *s;
X		res = key_add(k);
X	} else
X		return ERR_TYPE_CHECK;
X
X	decrefp(current, e1, p1);
X	decrefp(current, e2, p2);
X	return_ok_result(2, res);
X}
X
X
Xretcode o_eq()
X{
X	eindex e1, e2, ei;
X
X	if (current->osp < 2)
X		return ERR_STACK_UNDERFLOW;
X	e1 = current->os[current->osp-2];
X	e2 = current->os[current->osp-1];
X
X	ei = new_element(current, T_INT);
X	eaddr(current, ei)->V.i = element_equal(current, e1, e2);
X
X	decref(current, e1);
X	decref(current, e2);
X	return_ok_result(2, ei);
X}
X
X
Xretcode o_gt()
X{
X	int flag;
X	eindex res;
X
X	load_2_args(e1, e2, p1, p2);
X
X	if (eptype(p1) == T_INT && eptype(p2) == T_INT)
X		flag = p1->V.i > p2->V.i ? 1 : 0;
X	else if (eptype(p1) == T_TIME && eptype(p2) == T_TIME) {
X		if (!(epattr(p1) & epattr(p2) & A_READ))
X			return ERR_ACCESS_CHECK;
X		flag = time_gt(&(p1->V.tim), &(p2->V.tim));
X	} else if (eptype(p1) == T_STRING && eptype(p2) == T_STRING) {
X		if (!(epattr(p1) & epattr(p2) & A_READ))
X			return ERR_ACCESS_CHECK;
X		flag = str_gt(current, e1, e2);
X	} else
X		return ERR_TYPE_CHECK;
X
X	res = new_element(current, T_INT);
X	eaddr(current, res)->V.i = flag;
X	decrefp(current, e1, p1);
X	decrefp(current, e2, p2);
X	return_ok_result(2, res);
X}
X
X
Xretcode o_lt()
X{
X	int flag;
X	eindex res;
X
X	load_2_args(e1, e2, p1, p2);
X
X	if (eptype(p1) == T_INT && eptype(p2) == T_INT)
X		flag = p1->V.i < p2->V.i ? 1 : 0;
X	else if (eptype(p1) == T_TIME && eptype(p2) == T_TIME) {
X		if (!(epattr(p1) & epattr(p2) & A_READ))
X			return ERR_ACCESS_CHECK;
X		flag = time_gt(&(p2->V.tim), &(p1->V.tim));
X	} else if (eptype(p1) == T_STRING && eptype(p2) == T_STRING) {
X		if (!(epattr(p1) & epattr(p2) & A_READ))
X			return ERR_ACCESS_CHECK;
X		flag = str_gt(current, e2, e1);
X	} else
X		return ERR_TYPE_CHECK;
X
X	res = new_element(current, T_INT);
X	eaddr(current, res)->V.i = flag;
X	decrefp(current, e1, p1);
X	decrefp(current, e2, p2);
X	return_ok_result(2, res);
X}
X
X
Xretcode o_neg()
X{
X	eindex res;
X
X	load_1_arg(ei, ep);
X
X	if (eptype(ep) != T_INT)
X		return ERR_TYPE_CHECK;
X	res = new_element(current, T_INT);
X	eaddr(current, res)->V.i = - ep->V.i;
X	decrefp(current, ei, ep);
X
X	current->os[current->osp-1] = res;
X	return OK;
X}
X
X
Xretcode o_not()
X{
X	eindex res;
X
X	load_1_arg(e1, p1);
X
X	if (eptype(p1) == T_INT) {
X		res = new_element(current, T_INT);
X		eaddr(current, res)->V.i = ~(p1->V.i);
X	} else if (eptype(p1) == T_KEY) {
X		byteptr s = p1->V.nam.u.s;
X		byte k[8];
X		int i;
X		for (i = 0; i < 8; i++)
X			k[i] = ~*s;
X		res = key_add(k);
X	} else
X		return ERR_TYPE_CHECK;
X
X	decrefp(current, e1, p1);
X	return_ok_result(1, res);
X}
X
X
Xretcode o_or()
X{
X	eindex res;
X
X	load_2_args(e1, e2, p1, p2);
X
X	if (eptype(p1) == T_INT && eptype(p2) == T_INT) {
X		res = new_element(current, T_INT);
X		eaddr(current, res)->V.i = p1->V.i | p2->V.i;
X	} else if (eptype(p1) == T_KEY && eptype(p2) == T_KEY) {
X		byteptr s = p2->V.nam.u.s;
X		byte k[8];
X		int i;
X		memcpy(k, (char*)(p1->V.nam.u.s), 8);
X		for (i = 0; i < 8; i++, s++)
X			k[i] |= *s;
X		res = key_add(k);
X	} else
X		return ERR_TYPE_CHECK;
X
X	decrefp(current, e1, p1);
X	decrefp(current, e2, p2);
X	return_ok_result(2, res);
X}
X
X
Xretcode o_sub()
X{
X	eindex res;
X
X	load_2_args(e1, e2, p1, p2);
X
X	if (eptype(p1) == T_INT && eptype(p2) == T_INT) {
X		res = new_element(current, T_INT);
X		eaddr(current, res)->V.i = p1->V.i - p2->V.i;
X	} else if (eptype(p1) == T_TIME && eptype(p2) == T_TIME) {
X		if (!(epattr(p1) & epattr(p2) & A_READ))
X			return ERR_ACCESS_CHECK;
X		res = time_diff(current, e1, e2);
X	} else if (eptype(p1) == T_TIME && eptype(p2) == T_INT) {
X		if (!(epattr(p1) & A_READ))
X			return ERR_ACCESS_CHECK;
X		res = time_addint(current, e1, - p2->V.i);
X	} else
X		return ERR_TYPE_CHECK;
X
X	decrefp(current, e1, p1);
X	decrefp(current, e2, p2);
X	return_ok_result(2, res);
X}
X
X
Xretcode o_xor()
X{
X	eindex res;
X
X	load_2_args(e1, e2, p1, p2);
X
X	if (eptype(p1) == T_INT && eptype(p2) == T_INT) {
X		res = new_element(current, T_INT);
X		eaddr(current, res)->V.i = p1->V.i ^ p2->V.i;
X	} else if (eptype(p1) == T_KEY && eptype(p2) == T_KEY) {
X		byteptr s = p2->V.nam.u.s;
X		byte k[8];
X		int i;
X		memcpy(k, (char*)(p1->V.nam.u.s), 8);
X		for (i = 0; i < 8; i++, s++)
X			k[i] ^= *s;
X		res = key_add(k);
X	} else
X		return ERR_TYPE_CHECK;
X
X	decrefp(current, e1, p1);
X	decrefp(current, e2, p2);
X	return_ok_result(2, res);
X}
END_OF_FILE
if test 8125 -ne `wc -c <'o_arith.c'`; then
    echo shar: \"'o_arith.c'\" unpacked with wrong size!
fi
# end of 'o_arith.c'
fi
if test -f 'o_ctrl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'o_ctrl.c'\"
else
echo shar: Extracting \"'o_ctrl.c'\" \(8530 characters\)
sed "s/^X//" >'o_ctrl.c' <<'END_OF_FILE'
X/*
X	o_ctrl.c
X*/
X/*  Copyright (c) 1994 Christian F. Tschudin. All rights reserved.
X
X    Distributed under the terms of the GNU General Public License
X    version 2 of june 1991 as published by the Free Software
X    Foundation, Inc.
X
X		     This file is part of M0.
X
XM0 is distributed in the hope that it will be useful, but WITHOUT ANY
XWARRANTY.  No author or distributor accepts responsibility to anyone for
Xthe consequences of using it or for whether it serves any particular
Xpurpose or works at all, unless he says so in writing.  Refer to the GNU
XGeneral Public License for full details. 
X
XEveryone is granted permission to copy, modify and redistribute M0, but
Xonly under the conditions described in the GNU General Public License. 
XA copy of this license is supposed to have been given to you along with
XM0 so you can know your rights and responsibilities.  It should be in a
Xfile named LICENSE.  Among other things, the copyright notice and this
Xnotice must be preserved on all copies.  */
X
X
X#include "l_proto.h"
X#include "o_proto.h"
X
X
Xretcode
Xo_exec()
X{
X	load_1_arg(ei, ep);
X
X	if (eptype(ep) != T_ARRAY && eptype(ep) != T_STRING &&
X	    eptype(ep) != T_NAME && eptype(ep) != T_PROC)
X		return OK;
X
X	if (current->esp >= MAXESTACK)
X		return ERR_ESTACK_OVERFLOW;
X	if (!(epattr(ep) & A_EXEC))
X		return ERR_ACCESS_CHECK;
X	current->osp--;
X
X	if (!(epattr(ep)&A_EXECUTABLE)) {
X		eindex res = make_sub(current, ei, 0);
X		decrefp(current, ei, ep);
X		ei = res;
X		eattr(current,ei) |= A_EXECUTABLE;
X	}
X	current->es[current->esp++] = ei;
X
X	return OK;
X}
X
X
Xretcode
Xo_exit()
X{
X	sshort i, j;
X	eindex *ip;
X
X	if (current->esp == 0)
X		return ERR_NOT_IN_LOOP;
X	ip = current->es + current->esp - 1;
X	for (i=current->esp; i > 0; i--, ip--)
X		if (*ip == loop_mark || *ip == halt_mark)
X			break;
X	if (i == 0 || *ip == halt_mark)
X		return ERR_NOT_IN_LOOP;
X	i--;
X	for (j = current->esp - i; j > 0; j--)
X		decref(current, *ip++);
X	current->esp = i;
X
X	return OK;
X}
X
X
Xretcode
Xo_halt()
X{
X	eindex ei, *ip;
X	sshort i, j;
X	eptr ep;
X
X	if (current->esp == 0)
X		return ERR_NOT_IN_HALTED;
X	ip = current->es + current->esp - 1;
X	for (i=current->esp; i > 0; i--, ip--)
X		if (*ip == halt_mark)
X			break;
X	if (i == 0)
X		return ERR_NOT_IN_HALTED;
X	i--;
X	for (j = current->esp - i; j > 0; j--)
X		decref(current, *ip++);
X	current->esp = i;
X	ei = new_element(current, T_INT);
X	ep = eaddr(current,ei);
X	ep->V.i = 1;
X	current->es[current->esp++] = ei;
X
X	return OK;
X}
X
X
Xretcode
Xo_halted()
X{
X	if (current->osp < 1)
X		return ERR_STACK_UNDERFLOW;
X	if (current->esp+3 >= MAXESTACK)
X		return ERR_ESTACK_OVERFLOW;
X	current->es[current->esp++] = halt_mark;
X	incref(current,halt_mark);
X	current->es[current->esp++] = halted_proc;
X	incref(current,halted_proc);
X	return o_exec();
X}
X
X
Xretcode
Xthe_halted_proc()
X{
X	eindex ei;
X	eptr ep;
X
X	/* drop halt_mark */
X	decref(current, current->es[current->esp-1]);
X	ei = new_element(current, T_INT);
X	ep = eaddr(current,ei);
X	ep->V.i = 0;
X	current->es[current->esp-1] = ei;
X	return OK;
X}
X
X
Xretcode
Xo_ifelse()
X{
X	eindex ei;
X	eptr ep;
X	byte flag;
X
X	if (current->osp < 3)
X		return ERR_STACK_UNDERFLOW;
X	ei = current->os[current->osp-3];
X	ep = eaddr(current, ei);
X	if (eptype(ep)!=T_INT)
X		return ERR_TYPE_CHECK;
X	flag = ep->V.i != 0;
X	decref(current, ei);
X	if (flag) {
X		current->os[current->osp-3] = current->os[current->osp-2];
X		decref(current, current->os[current->osp-1]);
X	} else {
X		current->os[current->osp-3] = current->os[current->osp-1];
X		decref(current, current->os[current->osp-2]);
X	}
X	current->osp -= 2;
X	return o_exec();
X}
X
X
Xretcode
Xo_loop()
X{
X	eindex arg, cnt, proc, loop;
X	eptr ep;
X
X	if (current->osp < 2)
X		return ERR_STACK_UNDERFLOW;
X
X	proc = current->os[current->osp-1];
X	arg = current->os[current->osp-2];
X	ep = eaddr(current, arg);
X
X	switch (eptype(ep)) {
X	    case T_INT:
X		cnt = new_element(current, T_INT);
X		if (ep->V.i >= 0) 	/* store the upper limit in the length field */
X			elen(current,cnt) = ep->V.i + 1;
X		else
X			eaddr(current,cnt)->V.i = -1;
X		decref(current, arg);
X		loop = loop_iproc;
X		break;
X	    case T_ARRAY:
X		if (!(epattr(ep) & A_EXEC) || !(epattr(ep) & A_READ))
X			return ERR_ACCESS_CHECK;
X		cnt = make_sub(current, arg, 0);
X		decref(current, arg);
X		loop = loop_aproc;
X		break;
X	    case T_DICT:
X		if (!(epattr(ep) & A_EXEC) || !(epattr(ep) & A_READ))
X			return ERR_ACCESS_CHECK;
X		cnt = make_sub(current, arg, 0);
X		decref(current, arg);
X		loop = loop_dproc;
X		break;
X	    case T_STRING:
X		if (!(epattr(ep) & A_EXEC) || !(epattr(ep) & A_READ))
X			return ERR_ACCESS_CHECK;
X		cnt = make_sub(current, arg, 0);
X		decref(current, arg);
X		loop = loop_sproc;
X		break;
X	    default:
X		return ERR_TYPE_CHECK;
X	}
X	current->es[current->esp++] = loop_mark;
X	incref(current, loop_mark);
X	current->es[current->esp++] = cnt;
X	current->es[current->esp++] = proc;
X	current->es[current->esp++] = loop;
X	incref(current, loop);
X	current->osp -= 2;
X	return OK;
X}
X
X
Xretcode
Xthe_loop_iproc()
X{
X	eindex ei = current->es[current->esp-2];
X	eptr ep = eaddr(current,ei);
X
X	TRACE(5, printf("loop_int_proc %d/%d\n", (int) ep->V.i, (int) eplen(ep)))
X
X	if (eplen(ep))
X		ep->V.i += 1;
X	if (ep->V.i >= (sint) eplen(ep)) {	/* end of loop */
X		decref(current, current->es[current->esp-1]);
X		decref(current, current->es[current->esp-2]);
X		decref(current, current->es[current->esp-3]);
X		current->esp -= 3;
X		return OK;
X	}
X	if (eplen(ep)) {	/* counting loop: push the counter */
X		ei = new_element(current, T_INT);
X		eaddr(current, ei)->V.i = ep->V.i - 1;
X		current->os[current->osp++] = ei;
X	}
X	current->es[current->esp++] = loop_iproc;
X	incref(current, loop_iproc);
X	ei = current->es[current->esp-2];
X	ep = eaddr(current, ei);
X	if (eptype(ep) == T_STRING || eptype(ep) == T_ARRAY)
X		ei = make_sub(current, ei, 0);
X	else
X		increfp(ep);
X	current->es[current->esp++] = ei;
X
X	return OK;
X}
X
X
Xretcode
Xthe_loop_aproc()
X{
X	eindex ei = current->es[current->esp-2], topush;
X	eptr ep = eaddr(current,ei);
X
X	TRACE(5, printf("loop_arrray_proc %d\n", (int) ep->V.sub.e))
X
X	if (eplen(ep) == 0) {	/* end of loop */
X		decref(current, current->es[current->esp-1]);
X		decref(current, current->es[current->esp-2]);
X		decref(current, current->es[current->esp-3]);
X		current->esp -= 3;
X		return OK;
X	}
X	topush = array_get(current, ei, 0);
X	current->os[current->osp++] = topush;
X	incref(current, topush);
X	ep->V.sub.offset += 1;
X	eplen(ep) -= 1;
X
X	current->es[current->esp++] = loop_aproc;
X	incref(current, loop_aproc);
X
X	ei = current->es[current->esp-2];
X	ep = eaddr(current, ei);
X	if (eptype(ep) == T_STRING || eptype(ep) == T_ARRAY)
X		ei = make_sub(current, ei, 0);
X	else
X		increfp(ep);
X	current->es[current->esp++] = ei;
X
X	return OK;
X}
X
X
Xretcode
Xthe_loop_dproc()
X{
X	eindex ei = current->es[current->esp-2], di, *ip;
X	eptr ep = eaddr(current,ei), dp;
X
X	TRACE(5, printf("loop_dict_proc %d\n", (int) ep->V.sub.e))
X
X	di = ep->V.sub.e;
X	dp = eaddr(current, di);
X	ip = dp->V.dic.d + 2*ep->V.sub.offset;
X	while(ep->V.sub.offset < dp->V.dic.alen) {
X		if (!*ip || *ip == DICT_DELETED) {
X			ep->V.sub.offset += 1;
X			ip += 2;
X			continue;
X		}
X		current->os[current->osp++] = *ip;
X		incref(current, *ip);
X		current->os[current->osp++] = *(ip+1);
X		incref(current, *(ip+1));
X		ep->V.sub.offset += 1;
X		current->es[current->esp++] = loop_dproc;
X		incref(current, loop_dproc);
X
X		ei = current->es[current->esp-2];
X		ep = eaddr(current, ei);
X		if (eptype(ep) == T_STRING || eptype(ep) == T_ARRAY)
X			ei = make_sub(current, ei, 0);
X		else
X			increfp(ep);
X		current->es[current->esp++] = ei;
X
X		return OK;
X	}
X	/* end of loop */
X	decref(current, current->es[current->esp-1]);
X	decref(current, current->es[current->esp-2]);
X	decref(current, current->es[current->esp-3]);
X	current->esp -= 3;
X	return OK;
X}
X
X
Xretcode
Xthe_loop_sproc()
X{
X	eindex ei = current->es[current->esp-2], topush;
X	eptr ep = eaddr(current,ei);
X
X	TRACE(5, printf("loop_string_proc %d\n", (int) ep->V.sub.e))
X
X	if (eplen(ep) == 0) {	/* end of loop */
X		decref(current, current->es[current->esp-1]);
X		decref(current, current->es[current->esp-2]);
X		decref(current, current->es[current->esp-3]);
X		current->esp -= 3;
X		return OK;
X	}
X	topush = new_element(current, T_INT);
X	eaddr(current, topush)->V.i = str_get(current, ei, 0);
X	current->os[current->osp++] = topush;
X	ep->V.sub.offset += 1;
X	eplen(ep) -= 1;
X
X	current->es[current->esp++] = loop_sproc;
X	incref(current, loop_sproc);
X
X	ei = current->es[current->esp-2];
X	ep = eaddr(current, ei);
X	if (eptype(ep) == T_STRING || eptype(ep) == T_ARRAY)
X		ei = make_sub(current, ei, 0);
X	else
X		increfp(ep);
X	current->es[current->esp++] = ei;
X
X	return OK;
X}
X
END_OF_FILE
if test 8530 -ne `wc -c <'o_ctrl.c'`; then
    echo shar: \"'o_ctrl.c'\" unpacked with wrong size!
fi
# end of 'o_ctrl.c'
fi
if test -f 'o_type.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'o_type.c'\"
else
echo shar: Extracting \"'o_type.c'\" \(10318 characters\)
sed "s/^X//" >'o_type.c' <<'END_OF_FILE'
X/*
X	o_type.c
X*/
X/*  Copyright (c) 1994 Christian F. Tschudin. All rights reserved.
X
X    Distributed under the terms of the GNU General Public License
X    version 2 of june 1991 as published by the Free Software
X    Foundation, Inc.
X
X		     This file is part of M0.
X
XM0 is distributed in the hope that it will be useful, but WITHOUT ANY
XWARRANTY.  No author or distributor accepts responsibility to anyone for
Xthe consequences of using it or for whether it serves any particular
Xpurpose or works at all, unless he says so in writing.  Refer to the GNU
XGeneral Public License for full details. 
X
XEveryone is granted permission to copy, modify and redistribute M0, but
Xonly under the conditions described in the GNU General Public License. 
XA copy of this license is supposed to have been given to you along with
XM0 so you can know your rights and responsibilities.  It should be in a
Xfile named LICENSE.  Among other things, the copyright notice and this
Xnotice must be preserved on all copies.  */
X
X#include <time.h>
X#include <stdlib.h>
X
X#include "l_proto.h"
X#include "strbuf.h"
X#include "o_proto.h"
X
Xstatic retcode externalize(struct buf_s *bp, eindex ei, int in_proc);
X
X
Xretcode
Xo_type()
X{
X	eindex tname;
X	ushort t;
X
X	load_1_arg(ei, ep);
X
X	t = eptype(ep);
X	decrefp(current, ei, ep);
X
X	tname = eaddr(current,type_name_array)->V.arr.a[t];
X	current->os[current->osp-1] = tname;
X	incref(current, tname);
X
X	return OK;
X}
X
X
Xretcode
Xo_toarray()
X{
X	eindex res, e;
X
X	load_1_arg(ei, ep);
X
X	if (eptype(ep) == T_INT) {
X		int i;
X		long l = ep->V.i;
X
X		res = new_array(current, sizeof(long)*8);
X		for (i = 0; i < sizeof(long)*8; i++) {
X			e = new_element(current, T_INT);
X			eaddr(current, e)->V.i = 0x01 & l;
X			array_put(current, res, i, e);
X			l = l >> 1;
X		}
X	} else if (eptype(ep) == T_TIME) {
X		time_t sec = ep->V.tim.sec;
X		struct tm *t;
X
X		t = gmtime(&sec);	
X		res = new_array(current, 7);
X
X#define set_val(pos,s) \
X		e = new_element(current, T_INT); \
X		eaddr(current,e)->V.i = t->s; \
X		array_put(current, res, pos, e)
X
X		set_val(6, tm_year + 1900);
X		set_val(5, tm_mon);
X		set_val(4, tm_mday - 1);
X		set_val(3, tm_hour);
X		set_val(2, tm_min);
X		set_val(1, tm_sec);
X
X		e = new_element(current, T_INT);
X		eaddr(current, e)->V.i = ep->V.tim.usec;
X		array_put(current, res, 0, e);
X	} else
X		return ERR_TYPE_CHECK;
X
X	decrefp(current, ei, ep);
X	current->os[current->osp-1] = res;
X
X	return OK;
X}
X
X
Xretcode
Xo_toexecutable()
X{
X	eindex res;
X
X	load_1_arg(ei, ep);
X
X	if (eptype(ep) != T_ARRAY && eptype(ep) != T_NAME)
X		return ERR_TYPE_CHECK;
X	if (epattr(ep) & A_EXECUTABLE)
X		return OK;
X
X	if (eprefcnt(ep) == 1 ) {
X		epattr(ep) |= A_EXECUTABLE;
X		return OK;
X	}
X	if (eptype(ep) == T_ARRAY)
X		res = make_sub(current, ei, 0);
X	else
X		res = make_sub(current, desub(current, ei), 0);
X	eattr(current, res) |= A_EXECUTABLE;
X
X	decrefp(current, ei, ep);
X	current->os[current->osp-1] = res;
X
X	return OK;
X}
X
X
Xretcode
Xo_toextern()
X{
X	eindex ei;
X	struct buf_s b;
X	retcode rc;
X
X	if (current->osp == 0)
X		return ERR_STACK_UNDERFLOW;
X
X	ei = current->os[current->osp-1];
X
X	memset(&b, 0, sizeof(struct buf_s));
X	rc = externalize(&b, ei, 0);
X/*
X	remove_visited(ei);
X*/
X
X	if (rc != OK) {
X		buf_free(&b);
X		return rc;
X	}
X	decref(current, ei);
X	current->os[current->osp-1] = str_import(current, b.buf, b.len, b.alen);
X
X	return OK;
X}
X
X
Xretcode
Xo_toint()
X{
X	eindex res;
X
X	load_1_arg(ei, ep);
X
X	if (eptype(ep) == T_ARRAY) {
X		long l = 0;
X		int i;
X		eindex e;
X		eptr p;
X
X		if (eplen(ep) > 8*sizeof(long))
X			return ERR_RANGE_CHECK;
X		for (i = eplen(ep)-1; i >= 0; i--) {
X			e = array_get(current, ei, i);
X			p = eaddr(current,e);
X			if (eptype(p) != T_INT)
X				return ERR_TYPE_CHECK;
X			if (p->V.i < 0 || p->V.i > 1)
X				return ERR_RANGE_CHECK;
X			l = (l << 1) | p->V.i;
X		}
X		res = new_element(current, T_INT);
X		eaddr(current,res)->V.i = l;		
X	} else if (eptype(ep) == T_TIME) {
X		res = new_element(current, T_INT);
X		eaddr(current,res)->V.i = ep->V.tim.sec;
X	} else
X		return ERR_TYPE_CHECK;
X
X	decrefp(current, ei, ep);
X	current->os[current->osp-1] = res;
X
X	return OK;
X}
X
X
Xretcode
Xo_tokey()
X{
X	eindex res;
X	byte key[8];
X
X	load_1_arg(ei, ep);
X
X	if (eptype(ep) != T_STRING)
X		return ERR_TYPE_CHECK;
X	if (eplen(ep) != 8)
X		return ERR_RANGE_CHECK;
X	str_export(current, key, ei, 0, 8);
X	res = key_add(key);
X
X	decrefp(current, ei, ep);
X	current->os[current->osp-1] = res;
X
X	return OK;
X}
X
X
Xretcode
Xo_toliteral()
X{
X	eindex res;
X
X	load_1_arg(ei, ep);
X
X	if (eptype(ep) != T_ARRAY && eptype(ep) != T_NAME)
X		return ERR_TYPE_CHECK;
X	if (!(epattr(ep) & A_EXECUTABLE))
X		return OK;
X
X	if (eprefcnt(ep) == 1 ) {
X		epattr(ep) &= ~A_EXECUTABLE;
X		return OK;
X	}
X	if (eptype(ep) == T_ARRAY)
X		res = make_sub(current, ei, 0);
X	else
X		res = make_sub(current, desub(current, ei), 0);
X	eattr(current, res) &=~A_EXECUTABLE;
X
X	decrefp(current, ei, ep);
X	current->os[current->osp-1] = res;
X
X	return OK;
X}
X
X
Xretcode
Xo_tomsgr()
X{
X	eindex ei, k, c, d, r;
X	eptr ep;
X
X	if (current->osp == 0)
X		return ERR_STACK_UNDERFLOW;
X
X	ei = current->os[current->osp-1];
X	ep = eaddr(current,ei);
X
X	if (eptype(ep) != T_ARRAY)
X		return ERR_TYPE_CHECK;
X	if (eplen(ep) != 3)
X		return ERR_RANGE_CHECK;
X	k = array_get(current, ei, 0);
X	c = array_get(current, ei, 1);
X	d = array_get(current, ei, 2);
X	if (etype(current,k) != T_KEY ||
X	    etype(current,c) != T_STRING)
X		return ERR_RANGE_CHECK;
X	if (etype(current,d) == T_STRING)
X		r = make_msgr_str(current, k, c, d);
X	else if(etype(current,d) == T_NULL)
X		r = make_msgr_str(current, k, c, 0);
X	else
X		return ERR_RANGE_CHECK;
X
X	decref(current, ei);
X	current->os[current->osp-1] = r;
X
X	return OK;
X}
X
X
Xretcode
Xo_toname()
X{
X	eindex res;
X	byteptr n;
X
X	load_1_arg(ei, ep);
X
X	if (eptype(ep) != T_STRING)
X		return ERR_TYPE_CHECK;
X
X	n = malloc(eplen(ep));
X	str_export(current, n, ei, 0, eplen(ep));
X	res = name_add(n, eplen(ep), 0);
X	free((char*)n);
X
X	decrefp(current, ei, ep);
X	current->os[current->osp-1] = res;
X
X	return OK;
X}
X
X
Xretcode
Xo_tostring()
X{
X	byteptr s;
X	int len;
X
X	load_1_arg(ei, ep);
X
X	if (eptype(ep) == T_NAME || eptype(ep) == T_KEY) {
X		eindex e = desub(current,ei);
X		eptr p = eaddr(current, e);
X		len = eplen(p);
X		s = malloc(len);
X		if (len <= SHORTNAMELEN)
X			memcpy((char*)s, p->V.nam.u.n, len);
X		else
X			memcpy((char*)s, (char*)(p->V.nam.u.s), len);
X	} else if (eptype(ep) == T_TIME) {
X		time_t clock = ep->V.tim.sec;
X		char *t = ctime(&clock);
X		len = strlen(t) - 1;
X		s = malloc(len);
X		memcpy((char*)s, t, len);
X	} else
X		return ERR_TYPE_CHECK;
X
X	decrefp(current, ei, ep);
X	current->os[current->osp-1] = str_import(current, s, len, len);
X
X	return OK;
X}
X
X
Xretcode
Xo_totime()
X{
X	eindex res;
X
X	load_1_arg(ei, ep);
X
X	if (eptype(ep) != T_INT)
X		return ERR_TYPE_CHECK;
X	if (ep->V.i < 0)
X		return ERR_RANGE_CHECK;
X
X	res = new_element(current, T_TIME);
X	eaddr(current, res)->V.tim.sec = ep->V.i;
X
X	decrefp(current, ei, ep);
X	current->os[current->osp-1] = res;
X
X	return OK;
X}
X
X
X/* ------------------------------------------------------------------------- */
X
Xstatic retcode
Xexternalize(struct buf_s *bp, eindex ei, int in_proc)
X{
X	eptr ep = eaddr(current,ei), ep2;
X	byte local[32], c;
X	byteptr cp;
X	int i;
X	retcode rc;
X
X	if (epattr(ep) & A_VISITED)
X		return ERR_CIRCULAR_DATA;
X
X	switch (eptype(ep)) {
X	    case T_INT:
X		if (bp->last_char == DIGIT)
X			buf_add(bp, (byteptr)" ", 1);
X#ifdef __MSDOS__
X		sprintf((char*)local, "%ld", (ep->V.i) < 0 ? -ep->V.i : ep->V.i);
X#else
X		sprintf((char*)local, "%d", (ep->V.i) < 0 ? -ep->V.i : ep->V.i);
X#endif
X		buf_add(bp, local, strlen((char*)local));
X		if (ep->V.i < 0)
X			buf_add(bp, (byteptr)"N", 1);
X		break;
X	    case T_ARRAY:
X		epattr(ep) |= A_VISITED;
X		buf_add(bp, (byteptr)(epattr(ep)&A_EXECUTABLE?"{":"["), 1);
X		for (i=0; i < eplen(ep); i++) {
X			rc = externalize(bp, array_get(current, ei, i), 1);
X			if (rc != OK) {
X				epattr(ep) &= ~A_VISITED;
X				return rc;
X			}
X		}
X		buf_add(bp, (byteptr)(epattr(ep)&A_EXECUTABLE?"}":"]"), 1);
X		epattr(ep) &= ~A_VISITED;
X		break;
X	    case T_KEY:
X		cp = ep->V.nam.u.s;
X		sprintf((char*)local, "\\%02x%02x%02x%02x%02x%02x%02x%02x\\_ctk",
X			cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
X		buf_add(bp, local, strlen((char*)local));
Xexec_key:
X		if (epattr(ep) & A_EXECUTABLE) {
X			buf_add(bp, (byteptr)" _ctx", 5);
X			if (in_proc)
X				buf_add(bp, (byteptr)"!", 1);
X		}
X		break;
X	    case T_NAME:
X		ei = desub(current, ei);
X		ep2 = eaddr(current,ei);
X		c = ep2->V.nam.u.n[0];
X		if (eplen(ep)==1 && !islower(c) && isprint(c)) {
X			if (!in_proc || !(epattr(ep)&A_EXECUTABLE))
X				buf_add(bp, (byteptr)"'", 1);
X			buf_add(bp, ep2->V.nam.u.n, 1);
X		} else { /* not a self-delimiting identifier */
X			cp = eplen(ep) <= SHORTNAMELEN ?
X					ep2->V.nam.u.n : ep2->V.nam.u.s;
X			for (i=eplen(ep); i>0; i--, cp++)
X				if (!islower(*cp) && *cp != '_')
X					break;
X			cp = eplen(ep) <= SHORTNAMELEN ?
X					ep2->V.nam.u.n : ep2->V.nam.u.s;
X			if (i == 0) { /* lower case identifier */
X				if (!in_proc || !(epattr(ep)&A_EXECUTABLE))
X					buf_add(bp, (byteptr)"'", 1);
X				else if (bp->last_char == LOWER)
X					buf_add(bp, (byteptr)" ", 1);
X				buf_add(bp, cp, eplen(ep));
X			} else { /* non standard name */
X				buf_add(bp, (byteptr)"\"", 1);
X				for (i = eplen(ep); i > 0; i--, cp++) {
X					if (!isprint(*cp)) {
X						sprintf((char*)local, "\\x%02x", *cp);
X						buf_add(bp, local, strlen((char*)local));
X					} else if (*cp == '\"' || *cp == '\\') {
X						strcpy((char*)local, "\\x");
X						local[1] = *cp;
X						buf_add(bp, local, strlen((char*)local));
X					} else
X						buf_add(bp, cp, 1);
X				}
X				buf_add(bp, (byteptr)"\"_ctn", 5);
X				goto exec_key;
X			}
X		}
X		if (!in_proc && (epattr(ep) & A_EXECUTABLE)) {
X			if (bp->last_char == LOWER)
X				buf_add(bp, (byteptr)" ", 1);
X			buf_add(bp, (byteptr)"_ctx", 4);
X		}
X		break;
X	    case T_NULL:
X		if (bp->last_char == LOWER)
X			buf_add(bp, (byteptr)" ", 1);
X		buf_add(bp, (byteptr)"null", 4);
X		break;
X	    case T_STRING:
X		buf_add(bp, (byteptr)"\"", 1);
X		for (i = 0; i < eplen(ep); i++) {
X			c = str_get(current, ei, i);
X			if (!isprint(c)) {
X				sprintf((char*)local, "\\x%02x", c);
X				buf_add(bp, local, strlen((char*)local));
X			} else if (c == '\"' || c == '\\') {
X				strcpy((char*)local, "\\x");
X				local[1] = c;
X				buf_add(bp, local, strlen((char*)local));
X			} else
X				buf_add(bp, &c, 1);
X		}
X		buf_add(bp, (byteptr)"\"", 1);
X		break;
X	    default:
X		return ERR_NOT_IMPLEMENTED;
X	}
X	return OK;
X}
END_OF_FILE
if test 10318 -ne `wc -c <'o_type.c'`; then
    echo shar: \"'o_type.c'\" unpacked with wrong size!
fi
# end of 'o_type.c'
fi
echo shar: End of archive 5 \(of 12\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 12 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
