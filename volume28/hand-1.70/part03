Newsgroups: comp.sources.unix
From: perseant@u.washington.edu (Konrad Schroder)
Subject: v28i122: hand-1.70 - a bunch of fingers working together, Part03/03
References: <1.777869799.9794@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: perseant@u.washington.edu (Konrad Schroder)
Posting-Number: Volume 28, Issue 122
Archive-Name: hand-1.70/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 3)."
# Contents:  configure handsort.c main.c
# Wrapped by vixie@gw.home.vix.com on Thu Aug 25 19:55:18 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'configure' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'configure'\"
else
echo shar: Extracting \"'configure'\" \(24015 characters\)
sed "s/^X//" >'configure' <<'END_OF_FILE'
X#!/bin/sh
X# Guess values for system-dependent variables and create Makefiles.
X# Generated automatically using autoconf.
X# Copyright (C) 1991, 1992, 1993 Free Software Foundation, Inc.
X
X# This script is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation; either version 2, or (at your option)
X# any later version.
X
X# This script is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X
X# You should have received a copy of the GNU General Public License
X# along with this script; if not, write to the Free Software
X# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
X# Usage: configure [--srcdir=DIR] [--host=HOST] [--gas] [--nfp]
X#        [--prefix=PREFIX] [--exec-prefix=PREFIX] [--with-PACKAGE[=VALUE]]
X# Ignores all args except --srcdir, --prefix, --exec-prefix, and
X# --with-PACKAGE[=VALUE] unless this script has special code to handle it.
X
Xfor arg
Xdo
X  # Handle --exec-prefix with a space before the argument.
X  if test x$next_exec_prefix = xyes; then exec_prefix=$arg; next_exec_prefix=
X  # Handle --host with a space before the argument.
X  elif test x$next_host = xyes; then next_host=
X  # Handle --prefix with a space before the argument.
X  elif test x$next_prefix = xyes; then prefix=$arg; next_prefix=
X  # Handle --srcdir with a space before the argument.
X  elif test x$next_srcdir = xyes; then srcdir=$arg; next_srcdir=
X  else
X    case $arg in
X     # For backward compatibility, recognize -exec-prefix and --exec_prefix.
X     -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* | --exec=* | --exe=* | --ex=* | --e=*)
X	exec_prefix=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- | --exec | --exe | --ex | --e)
X	next_exec_prefix=yes ;;
X
X     -gas | --gas | --ga | --g) ;;
X
X     -host=* | --host=* | --hos=* | --ho=* | --h=*) ;;
X     -host | --host | --hos | --ho | --h)
X	next_host=yes ;;
X
X     -nfp | --nfp | --nf) ;;
X
X     -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
X	prefix=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
X	next_prefix=yes ;;
X
X     -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=* | --s=*)
X	srcdir=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -srcdir | --srcdir | --srcdi | --srcd | --src | --sr | --s)
X	next_srcdir=yes ;;
X
X     -with-* | --with-*)
X       package=`echo $arg|sed -e 's/-*with-//' -e 's/=.*//'`
X       # Reject names that aren't valid shell variable names.
X       if test -n "`echo $package| sed 's/[-a-zA-Z0-9_]//g'`"; then
X         echo "configure: $package: invalid package name" >&2; exit 1
X       fi
X       package=`echo $package| sed 's/-/_/g'`
X       case "$arg" in
X         *=*) val="`echo $arg|sed 's/[^=]*=//'`" ;;
X         *) val=1 ;;
X       esac
X       eval "with_$package='$val'" ;;
X
X     -v | -verbose | --verbose | --verbos | --verbo | --verb | --ver | --ve | --v)
X       verbose=yes ;;
X
X     *) ;;
X    esac
X  fi
Xdone
X
Xtrap 'rm -fr conftest* confdefs* core; exit 1' 1 3 15
Xtrap 'rm -f confdefs*' 0
X
X# NLS nuisances.
X# These must not be set unconditionally because not all systems understand
X# e.g. LANG=C (notably SCO).
Xif test "${LC_ALL+set}" = 'set' ; then LC_ALL=C; export LC_ALL; fi
Xif test "${LANG+set}"   = 'set' ; then LANG=C;   export LANG;   fi
X
Xrm -f conftest* confdefs.h
X> confdefs.h
Xcompile='${CC-cc} $CFLAGS conftest.c -o conftest $LIBS >/dev/null 2>&1'
X
X# A filename unique to this package, relative to the directory that
X# configure is in, which we can look for to find out if srcdir is correct.
Xunique_file=handtcp.c
X
X# Find the source files, if location was not specified.
Xif test -z "$srcdir"; then
X  srcdirdefaulted=yes
X  # Try the directory containing this script, then `..'.
X  prog=$0
X  confdir=`echo $prog|sed 's%/[^/][^/]*$%%'`
X  test "X$confdir" = "X$prog" && confdir=.
X  srcdir=$confdir
X  if test ! -r $srcdir/$unique_file; then
X    srcdir=..
X  fi
Xfi
Xif test ! -r $srcdir/$unique_file; then
X  if test x$srcdirdefaulted = xyes; then
X    echo "configure: Can not find sources in \`${confdir}' or \`..'." 1>&2
X  else
X    echo "configure: Can not find sources in \`${srcdir}'." 1>&2
X  fi
X  exit 1
Xfi
X# Preserve a srcdir of `.' to avoid automounter screwups with pwd.
X# But we can't avoid them for `..', to make subdirectories work.
Xcase $srcdir in
X  .|/*|~*) ;;
X  *) srcdir=`cd $srcdir; pwd` ;; # Make relative path absolute.
Xesac
X
X
X# Save the original args to write them into config.status later.
Xconfigure_args="$*"
X
Xif test -z "$CC"; then
X  # Extract the first word of `gcc', so it can be a program name with args.
X  set dummy gcc; word=$2
X  echo checking for $word
X  IFS="${IFS= 	}"; saveifs="$IFS"; IFS="${IFS}:"
X  for dir in $PATH; do
X    test -z "$dir" && dir=.
X    if test -f $dir/$word; then
X      CC="gcc"
X      break
X    fi
X  done
X  IFS="$saveifs"
Xfi
Xtest -z "$CC" && CC="cc"
Xtest -n "$CC" && test -n "$verbose" && echo "	setting CC to $CC"
X
X# Find out if we are using GNU C, under whatever name.
Xcat > conftest.c <<EOF
X#ifdef __GNUC__
X  yes
X#endif
XEOF
X${CC-cc} -E conftest.c > conftest.out 2>&1
Xif egrep yes conftest.out >/dev/null 2>&1; then
X  GCC=1 # For later tests.
Xfi
Xrm -f conftest*
X
Xecho checking how to run the C preprocessor
Xif test -z "$CPP"; then
X  # This must be in double quotes, not single quotes, because CPP may get
X  # substituted into the Makefile and ``${CC-cc}'' will simply confuse
X  # make.  It must be expanded now.
X  CPP="${CC-cc} -E"
X  cat > conftest.c <<EOF
X#include "confdefs.h"
X#include <stdio.h>
XSyntax Error
XEOF
Xerr=`eval "($CPP conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  :
Xelse
X  rm -rf conftest*
X  CPP=/lib/cpp
Xfi
Xrm -f conftest*
Xfi
Xtest ".${verbose}" != "." && echo "	setting CPP to $CPP"
X
Xecho checking for AIX
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X#ifdef _AIX
X  yes
X#endif
X
XEOF
Xeval "$CPP conftest.c > conftest.out 2>&1"
Xif egrep "yes" conftest.out >/dev/null 2>&1; then
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining _ALL_SOURCE"
Xecho "#define" _ALL_SOURCE 1 >> confdefs.h
XDEFS="$DEFS -D_ALL_SOURCE=1"
X}
X
X
Xfi
Xrm -f conftest*
X
X
XLIBS_save="${LIBS}"
XLIBS="${LIBS} -lseq"
Xhave_lib=""
Xecho checking for -lseq
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X
Xint main() { exit(0); }
Xint t() { main(); }
XEOF
Xif eval $compile; then
X  rm -rf conftest*
X  have_lib="1"
X
Xfi
Xrm -f conftest*
XLIBS="${LIBS_save}"
Xif test -n "${have_lib}"; then
X   :; LIBS="$LIBS -lseq"
Xelse
X   :; 
Xfi
X
X
XLIBS_save="${LIBS}"
XLIBS="${LIBS} -lsun"
Xhave_lib=""
Xecho checking for -lsun
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X
Xint main() { exit(0); }
Xint t() { main(); }
XEOF
Xif eval $compile; then
X  rm -rf conftest*
X  have_lib="1"
X
Xfi
Xrm -f conftest*
XLIBS="${LIBS_save}"
Xif test -n "${have_lib}"; then
X   :; LIBS="$LIBS -lsun"
Xelse
X   :; 
Xfi
X
X
Xecho checking for POSIXized ISC
Xif test -d /etc/conf/kconfig.d &&
X  grep _POSIX_VERSION /usr/include/sys/unistd.h >/dev/null 2>&1
Xthen
X  ISC=1 # If later tests want to check for ISC.
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining _POSIX_SOURCE"
Xecho "#define" _POSIX_SOURCE 1 >> confdefs.h
XDEFS="$DEFS -D_POSIX_SOURCE=1"
X}
X
X  if test -n "$GCC"; then
X    CC="$CC -posix"
X  else
X    CC="$CC -Xp"
X  fi
Xfi
X
X
X
Xecho checking for unistd.h
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X#include <unistd.h>
XEOF
Xerr=`eval "($CPP conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining HAVE_UNISTD_H"
Xecho "#define" HAVE_UNISTD_H 1 >> confdefs.h
XDEFS="$DEFS -DHAVE_UNISTD_H=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}HAVE_UNISTD_H\${SEDdB}HAVE_UNISTD_H\${SEDdC}1\${SEDdD}
X\${SEDuA}HAVE_UNISTD_H\${SEDuB}HAVE_UNISTD_H\${SEDuC}1\${SEDuD}
X\${SEDeA}HAVE_UNISTD_H\${SEDeB}HAVE_UNISTD_H\${SEDeC}1\${SEDeD}
X"
X}
X
X
Xfi
Xrm -f conftest*
X
Xfor hdr in stdlib.h string.h malloc.h
Xdo
Xtrhdr=HAVE_`echo $hdr | tr '[a-z]./' '[A-Z]__'`
Xecho checking for ${hdr}
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X#include <${hdr}>
XEOF
Xerr=`eval "($CPP conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining ${trhdr}"
Xecho "#define" ${trhdr} 1 >> confdefs.h
XDEFS="$DEFS -D${trhdr}=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}${trhdr}\${SEDdB}${trhdr}\${SEDdC}1\${SEDdD}
X\${SEDuA}${trhdr}\${SEDuB}${trhdr}\${SEDuC}1\${SEDuD}
X\${SEDeA}${trhdr}\${SEDeB}${trhdr}\${SEDeC}1\${SEDeD}
X"
X}
X
X
Xfi
Xrm -f conftest*
Xdone
X
Xecho checking for ANSI C header files
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X#include <stdlib.h>
X#include <stdarg.h>
X#include <string.h>
X#include <float.h>
XEOF
Xerr=`eval "($CPP conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  rm -rf conftest*
X  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
Xecho '#include "confdefs.h"
X#include <string.h>' > conftest.c
Xeval "$CPP conftest.c > conftest.out 2>&1"
Xif egrep "memchr" conftest.out >/dev/null 2>&1; then
X  rm -rf conftest*
X  # SGI's /bin/cc from Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X#include <ctype.h>
X#define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
X#define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
X#define XOR(e,f) (((e) && !(f)) || (!(e) && (f)))
Xint main () { int i; for (i = 0; i < 256; i++)
Xif (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);
Xexit (0); }
X
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining STDC_HEADERS"
Xecho "#define" STDC_HEADERS 1 >> confdefs.h
XDEFS="$DEFS -DSTDC_HEADERS=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}STDC_HEADERS\${SEDdB}STDC_HEADERS\${SEDdC}1\${SEDdD}
X\${SEDuA}STDC_HEADERS\${SEDuB}STDC_HEADERS\${SEDuC}1\${SEDuD}
X\${SEDeA}STDC_HEADERS\${SEDeB}STDC_HEADERS\${SEDeC}1\${SEDeD}
X"
X}
X
X
Xfi
Xrm -f conftest*
X
Xfi
Xrm -f conftest*
X
X
Xfi
Xrm -f conftest*
X
Xfor func in tzset strcasecmp strncasecmp difftime getdtablesize
Xdo
Xtrfunc=HAVE_`echo $func | tr '[a-z]' '[A-Z]'`
Xecho checking for ${func}
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X#include <ctype.h>
Xint main() { exit(0); }
Xint t() { 
X/* The GNU C library defines this for functions which it implements
X    to always fail with ENOSYS.  Some functions are actually named
X    something starting with __ and the normal name is an alias.  */
X#if defined (__stub_${func}) || defined (__stub___${func})
Xchoke me
X#else
X/* Override any gcc2 internal prototype to avoid an error.  */
Xextern char ${func}(); ${func}();
X#endif
X }
XEOF
Xif eval $compile; then
X  rm -rf conftest*
X  {
Xtest -n "$verbose" && \
Xecho "	defining ${trfunc}"
Xecho "#define" ${trfunc} 1 >> confdefs.h
XDEFS="$DEFS -D${trfunc}=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}${trfunc}\${SEDdB}${trfunc}\${SEDdC}1\${SEDdD}
X\${SEDuA}${trfunc}\${SEDuB}${trfunc}\${SEDuC}1\${SEDuD}
X\${SEDeA}${trfunc}\${SEDeB}${trfunc}\${SEDeC}1\${SEDeD}
X"
X}
X
X
Xfi
Xrm -f conftest*
Xdone
X
Xecho "checking for USER_PROCESS classification"
Xecho '#include "confdefs.h"
X#include <utmp.h>' > conftest.c
Xeval "$CPP conftest.c > conftest.out 2>&1"
Xif egrep "ut_type" conftest.out >/dev/null 2>&1; then
X  rm -rf conftest*
X  DEFS="$DEFS -DHAVE_USER_PROCESS=1"
X  SEDDEFS="${SEDDEFS}
X     \${SEDdA}HAVE_USER_PROCESS\${SEDdB}HAVE_USER_PROCESS\${SEDdC}1\${SEDdD}
X     \${SEDuA}HAVE_USER_PROCESS\${SEDuB}HAVE_USER_PROCESS\${SEDuC}1\${SEDuD}
X     \${SEDeA}HAVE_USER_PROCESS\${SEDeB}HAVE_USER_PROCESS\${SEDeC}1\${SEDeD}
X"
X
Xfi
Xrm -f conftest*
X
Xecho "checking return type of wait"
Xecho '#include "confdefs.h"
X#include <sys/wait.h>' > conftest.c
Xeval "$CPP conftest.c > conftest.out 2>&1"
Xif egrep "union wait" conftest.out >/dev/null 2>&1; then
X  rm -rf conftest*
X  DEFS="$DEFS -DUNION_WAIT=\"union wait\""
X  SEDDEFS="${SEDDEFS}
X     \${SEDdA}UNION_WAIT\${SEDdB}UNION_WAIT\${SEDdC}union wait\${SEDdD}
X     \${SEDuA}UNION_WAIT\${SEDuB}UNION_WAIT\${SEDuC}union wait\${SEDuD}
X     \${SEDeA}UNION_WAIT\${SEDeB}UNION_WAIT\${SEDeC}union wait\${SEDeD}
X"
X
Xelse
X  rm -rf conftest*
X  DEFS="$DEFS -DUNION_WAIT=\"int\""
X  SEDDEFS="${SEDDEFS}
X     \${SEDdA}UNION_WAIT\${SEDdB}UNION_WAIT\${SEDdC}int\${SEDdD}
X     \${SEDuA}UNION_WAIT\${SEDuB}UNION_WAIT\${SEDuC}int\${SEDuD}
X     \${SEDeA}UNION_WAIT\${SEDeB}UNION_WAIT\${SEDeC}int\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
XLIBS_save="${LIBS}"
XLIBS="${LIBS} -lsocket"
Xhave_lib=""
Xecho checking for -lsocket
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X
Xint main() { exit(0); }
Xint t() { main(); }
XEOF
Xif eval $compile; then
X  rm -rf conftest*
X  have_lib="1"
X
Xfi
Xrm -f conftest*
XLIBS="${LIBS_save}"
Xif test -n "${have_lib}"; then
X   :; LIBS="$LIBS -lsocket"
Xelse
X   :; 
Xfi
X
XLIBS_save="${LIBS}"
XLIBS="${LIBS} -linet"
Xhave_lib=""
Xecho checking for -linet
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X
Xint main() { exit(0); }
Xint t() { main(); }
XEOF
Xif eval $compile; then
X  rm -rf conftest*
X  have_lib="1"
X
Xfi
Xrm -f conftest*
XLIBS="${LIBS_save}"
Xif test -n "${have_lib}"; then
X   :; LIBS="$LIBS -linet"
Xelse
X   :; 
Xfi
X
XLIBS_save="${LIBS}"
XLIBS="${LIBS} -lnsl"
Xhave_lib=""
Xecho checking for -lnsl
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X
Xint main() { exit(0); }
Xint t() { main(); }
XEOF
Xif eval $compile; then
X  rm -rf conftest*
X  have_lib="1"
X
Xfi
Xrm -f conftest*
XLIBS="${LIBS_save}"
Xif test -n "${have_lib}"; then
X   :; LIBS="$LIBS -lnsl"
Xelse
X   :; 
Xfi
X
Xecho checking for return type of signal handlers
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X#include <sys/types.h>
X#include <signal.h>
X#ifdef signal
X#undef signal
X#endif
Xextern void (*signal ()) ();
Xint main() { exit(0); }
Xint t() { int i; }
XEOF
Xif eval $compile; then
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining" RETSIGTYPE to be void
Xecho "#define" RETSIGTYPE void >> confdefs.h
XDEFS="$DEFS -DRETSIGTYPE=void"
XSEDDEFS="${SEDDEFS}\${SEDdA}RETSIGTYPE\${SEDdB}RETSIGTYPE\${SEDdC}void\${SEDdD}
X\${SEDuA}RETSIGTYPE\${SEDuB}RETSIGTYPE\${SEDuC}void\${SEDuD}
X\${SEDeA}RETSIGTYPE\${SEDeB}RETSIGTYPE\${SEDeC}void\${SEDeD}
X"
X}
X
X
Xelse
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining" RETSIGTYPE to be int
Xecho "#define" RETSIGTYPE int >> confdefs.h
XDEFS="$DEFS -DRETSIGTYPE=int"
XSEDDEFS="${SEDDEFS}\${SEDdA}RETSIGTYPE\${SEDdB}RETSIGTYPE\${SEDdC}int\${SEDdD}
X\${SEDuA}RETSIGTYPE\${SEDuB}RETSIGTYPE\${SEDuC}int\${SEDuD}
X\${SEDeA}RETSIGTYPE\${SEDeB}RETSIGTYPE\${SEDeC}int\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
X
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X#include <stdio.h>
X/* If setvbuf has the reversed format, exit 0. */
Xmain () {
X  /* This call has the arguments reversed.
X     A reversed system may check and see that the address of main
X     is not _IOLBF, _IONBF, or _IOFBF, and return nonzero.  */
X  if (setvbuf(stdout, _IOLBF, (char *) main, BUFSIZ) != 0)
X    exit(1);
X  putc('\r', stdout);
X  exit(0);			/* Non-reversed systems segv here.  */
X}
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining SETVBUF_REVERSED"
Xecho "#define" SETVBUF_REVERSED 1 >> confdefs.h
XDEFS="$DEFS -DSETVBUF_REVERSED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SETVBUF_REVERSED\${SEDdB}SETVBUF_REVERSED\${SEDdC}1\${SEDdD}
X\${SEDuA}SETVBUF_REVERSED\${SEDuB}SETVBUF_REVERSED\${SEDuC}1\${SEDuD}
X\${SEDeA}SETVBUF_REVERSED\${SEDeB}SETVBUF_REVERSED\${SEDeC}1\${SEDeD}
X"
X}
X
X
Xfi
Xrm -f conftest*
Xrm -f core
X
Xprog='/* Ultrix mips cc rejects this.  */
Xtypedef int charset[2]; const charset x;
X/* SunOS 4.1.1 cc rejects this.  */
Xchar const *const *ccp;
Xchar **p;
X/* AIX XL C 1.02.0.0 rejects this.
X   It does not let you subtract one const X* pointer from another in an arm
X   of an if-expression whose if-part is not a constant expression */
Xconst char *g = "string";
Xccp = &g + (g ? g-g : 0);
X/* HPUX 7.0 cc rejects these. */
X++ccp;
Xp = (char**) ccp;
Xccp = (char const *const *) p;
X{ /* SCO 3.2v4 cc rejects this.  */
X  char *t;
X  char const *s = 0 ? (char *) 0 : (char const *) 0;
X
X  *t++ = 0;
X}
X{ /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
X  int x[] = {25,17};
X  const int *foo = &x[0];
X  ++foo;
X}
X{ /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
X  typedef const int *iptr;
X  iptr p = 0;
X  ++p;
X}
X{ /* AIX XL C 1.02.0.0 rejects this saying
X     "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
X  struct s { int j; const int *ap[3]; };
X  struct s *b; b->j = 5;
X}'
Xecho checking for lack of working const
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X
Xint main() { exit(0); }
Xint t() { $prog }
XEOF
Xif eval $compile; then
X  :
Xelse
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining" const to be empty
Xecho "#define" const  >> confdefs.h
XDEFS="$DEFS -Dconst="
XSEDDEFS="${SEDDEFS}\${SEDdA}const\${SEDdB}const\${SEDdC}\${SEDdD}
X\${SEDuA}const\${SEDuB}const\${SEDuC}\${SEDuD}
X\${SEDeA}const\${SEDeB}const\${SEDeC}\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
X
X# Make sure to not get the incompatible SysV /etc/install and
X# /usr/sbin/install, which might be in PATH before a BSD-like install,
X# or the SunOS /usr/etc/install directory, or the AIX /bin/install,
X# or the AFS install, which mishandles nonexistent args, or
X# /usr/ucb/install on SVR4, which tries to use the nonexistent group
X# `staff'.  On most BSDish systems install is in /usr/bin, not /usr/ucb
X# anyway.  Sigh.
Xif test "z${INSTALL}" = "z" ; then
X  echo checking for install
X  IFS="${IFS= 	}"; saveifs="$IFS"; IFS="${IFS}:"
X  for dir in $PATH; do
X    test -z "$dir" && dir=.
X    case $dir in
X    /etc|/usr/sbin|/usr/etc|/usr/afsws/bin|/usr/ucb) ;;
X    *)
X      if test -f $dir/installbsd; then
X	INSTALL="$dir/installbsd -c" # OSF1
X	INSTALL_PROGRAM='$(INSTALL)'
X	INSTALL_DATA='$(INSTALL) -m 644'
X	break
X      fi
X      if test -f $dir/install; then
X	if grep dspmsg $dir/install >/dev/null 2>&1; then
X	  : # AIX
X	else
X	  INSTALL="$dir/install -c"
X	  INSTALL_PROGRAM='$(INSTALL)'
X	  INSTALL_DATA='$(INSTALL) -m 644'
X	  break
X	fi
X      fi
X      ;;
X    esac
X  done
X  IFS="$saveifs"
Xfi
XINSTALL=${INSTALL-cp}
Xtest -n "$verbose" && echo "	setting INSTALL to $INSTALL"
XINSTALL_PROGRAM=${INSTALL_PROGRAM-'$(INSTALL)'}
Xtest -n "$verbose" && echo "	setting INSTALL_PROGRAM to $INSTALL_PROGRAM"
XINSTALL_DATA=${INSTALL_DATA-'$(INSTALL)'}
Xtest -n "$verbose" && echo "	setting INSTALL_DATA to $INSTALL_DATA"
X
X
X# Set default prefixes.
Xif test -n "$prefix"; then
X  test -z "$exec_prefix" && exec_prefix='${prefix}'
X  prsub="s%^prefix\\([ 	]*\\)=\\([ 	]*\\).*$%prefix\\1=\\2$prefix%"
Xfi
Xif test -n "$exec_prefix"; then
X  prsub="$prsub
Xs%^exec_prefix\\([ 	]*\\)=\\([ 	]*\\).*$%exec_prefix\\1=\\2$exec_prefix%"
Xfi
X# Quote sed substitution magic chars in DEFS.
Xcat >conftest.def <<EOF
X$DEFS
XEOF
Xescape_ampersand_and_backslash='s%[&\\]%\\&%g'
XDEFS=`sed "$escape_ampersand_and_backslash" <conftest.def`
Xrm -f conftest.def
X# Substitute for predefined variables.
X
Xtrap 'rm -f config.status; exit 1' 1 3 15
Xecho creating config.status
Xrm -f config.status
Xcat > config.status <<EOF
X#!/bin/sh
X# Generated automatically by configure.
X# Run this file to recreate the current configuration.
X# This directory was configured as follows,
X# on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
X#
X# $0 $configure_args
X
Xfor arg
Xdo
X  case "\$arg" in
X    -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
X    echo running \${CONFIG_SHELL-/bin/sh} $0 $configure_args
X    exec \${CONFIG_SHELL-/bin/sh} $0 $configure_args ;;
X    *) echo "Usage: config.status --recheck" 2>&1; exit 1 ;;
X  esac
Xdone
X
Xtrap 'rm -fr Makefile config.h conftest*; exit 1' 1 3 15
XCC='$CC'
XCPP='$CPP'
XINSTALL='$INSTALL'
XINSTALL_PROGRAM='$INSTALL_PROGRAM'
XINSTALL_DATA='$INSTALL_DATA'
XLIBS='$LIBS'
Xsrcdir='$srcdir'
Xprefix='$prefix'
Xexec_prefix='$exec_prefix'
Xprsub='$prsub'
Xextrasub='$extrasub'
XEOF
Xcat >> config.status <<\EOF
X
Xtop_srcdir=$srcdir
X
XCONFIG_FILES=${CONFIG_FILES-"Makefile"}
Xfor file in .. ${CONFIG_FILES}; do if test "x$file" != x..; then
X  srcdir=$top_srcdir
X  # Remove last slash and all that follows it.  Not all systems have dirname.
X  dir=`echo $file|sed 's%/[^/][^/]*$%%'`
X  if test "$dir" != "$file"; then
X    test "$top_srcdir" != . && srcdir=$top_srcdir/$dir
X    test ! -d $dir && mkdir $dir
X  fi
X  echo creating $file
X  rm -f $file
X  echo "# Generated automatically from `echo $file|sed 's|.*/||'`.in by configure." > $file
X  sed -e "
X$prsub
X$extrasub
Xs%@CC@%$CC%g
Xs%@CPP@%$CPP%g
Xs%@INSTALL@%$INSTALL%g
Xs%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g
Xs%@INSTALL_DATA@%$INSTALL_DATA%g
Xs%@LIBS@%$LIBS%g
Xs%@srcdir@%$srcdir%g
Xs%@DEFS@%-DHAVE_CONFIG_H%" $top_srcdir/${file}.in >> $file
Xfi; done
X
XCONFIG_HEADERS=${CONFIG_HEADERS-"config.h"}
Xfor file in .. ${CONFIG_HEADERS}; do if test "x$file" != x..; then
Xecho creating $file
X
X# These sed commands are put into SEDDEFS when defining a macro.
X# They are broken into pieces to make the sed script easier to manage.
X# They are passed to sed as "A NAME B NAME C VALUE D", where NAME
X# is the cpp macro being defined and VALUE is the value it is being given.
X# Each defining turns into a single global substitution command.
X#
X# SEDd sets the value in "#define NAME VALUE" lines.
XSEDdA='s@^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
XSEDdB='\([ 	][ 	]*\)[^ 	]*@\1#\2'
XSEDdC='\3'
XSEDdD='@g'
X# SEDu turns "#undef NAME" with trailing blanks into "#define NAME VALUE".
XSEDuA='s@^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
XSEDuB='\([ 	]\)@\1#\2define\3'
XSEDuC=' '
XSEDuD='\4@g'
X# SEDe turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
XSEDeA='s@^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
XSEDeB='$@\1#\2define\3'
XSEDeC=' '
XSEDeD='@g'
Xrm -f conftest.sed
XEOF
X# Turn off quoting long enough to insert the sed commands.
Xrm -f conftest.sh
Xcat > conftest.sh <<EOF
X$SEDDEFS
XEOF
X
X# Break up $SEDDEFS (now in conftest.sh) because some shells have a limit
X# on the size of here documents.
X
X# Maximum number of lines to put in a single here document.
Xmaxshlines=9
X
Xwhile :
Xdo
X  # wc gives bogus results for an empty file on some systems.
X  lines=`grep -c . conftest.sh`
X  if test -z "$lines" || test "$lines" -eq 0; then break; fi
X  rm -f conftest.s1 conftest.s2
X  sed ${maxshlines}q conftest.sh > conftest.s1 # Like head -20.
X  sed 1,${maxshlines}d conftest.sh > conftest.s2 # Like tail +21.
X  # Write a limited-size here document to append to conftest.sed.
X  echo 'cat >> conftest.sed <<CONFEOF' >> config.status
X  cat conftest.s1 >> config.status
X  echo 'CONFEOF' >> config.status
X  rm -f conftest.s1 conftest.sh
X  mv conftest.s2 conftest.sh
Xdone
Xrm -f conftest.sh
X
X# Now back to your regularly scheduled config.status.
Xcat >> config.status <<\EOF
X# This sed command replaces #undef's with comments.  This is necessary, for
X# example, in the case of _POSIX_SOURCE, which is predefined and required
X# on some systems where configure will not decide to define it in
X# config.h.
Xcat >> conftest.sed <<\CONFEOF
Xs,^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*,/* & */,
XCONFEOF
Xrm -f conftest.h
X# Break up the sed commands because old seds have small limits.
Xmaxsedlines=20
Xcp $top_srcdir/$file.in conftest.h1
Xwhile :
Xdo
X  lines=`grep -c . conftest.sed`
X  if test -z "$lines" || test "$lines" -eq 0; then break; fi
X  rm -f conftest.s1 conftest.s2 conftest.h2
X  sed ${maxsedlines}q conftest.sed > conftest.s1 # Like head -20.
X  sed 1,${maxsedlines}d conftest.sed > conftest.s2 # Like tail +21.
X  sed -f conftest.s1 < conftest.h1 > conftest.h2
X  rm -f conftest.s1 conftest.h1 conftest.sed
X  mv conftest.h2 conftest.h1
X  mv conftest.s2 conftest.sed
Xdone
Xrm -f conftest.sed conftest.h
Xecho "/* $file.  Generated automatically by configure.  */" > conftest.h
Xcat conftest.h1 >> conftest.h
Xrm -f conftest.h1
Xif cmp -s $file conftest.h 2>/dev/null; then
X  # The file exists and we would not be changing it.
X  echo "$file is unchanged"
X  rm -f conftest.h
Xelse
X  rm -f $file
X  mv conftest.h $file
Xfi
Xfi; done
X
X
X
Xexit 0
XEOF
Xchmod +x config.status
X${CONFIG_SHELL-/bin/sh} config.status
X
END_OF_FILE
if test 24015 -ne `wc -c <'configure'`; then
    echo shar: \"'configure'\" unpacked with wrong size!
fi
chmod +x 'configure'
# end of 'configure'
fi
if test -f 'handsort.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'handsort.c'\"
else
echo shar: Extracting \"'handsort.c'\" \(25195 characters\)
sed "s/^X//" >'handsort.c' <<'END_OF_FILE'
X/*
X * H A N D S O R T . C   -   --add and --del functions of hand, as well
X *                           as automatic sorting of the address file if
X *                           the usernames are out of order.
X */
X
X/*
X *   Copyright (C) 1992, 1993 Konrad Schroder.
X *
X *   This program is free software; you can redistribute it and/or modify
X *   it under the terms of the GNU General Public License as published by
X *   the Free Software Foundation; either version 1, or (at your option)
X *   any later version.
X *
X *   This program is distributed in the hope that it will be useful,
X *   but WITHOUT ANY WARRANTY; without even the implied warranty of
X *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *   GNU General Public License for more details.
X *
X *   You should have received a copy of the GNU General Public License
X *   along with this program; if not, write to the Free Software
X *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "hand.h"  /* needed here for ifdef's below */
X#include <stdio.h>
X#if HAVE_STDLIB_H
X# include <stdlib.h>
X#endif
X#include <ctype.h>
X#include <sys/types.h>
X#include <netinet/in.h>
X#include <arpa/inet.h>
X#include <netdb.h>
X#include <errno.h>
X#include <time.h>
X#include "handstr.h"
X#include "handtcp.h"
X#define MAXLLEN 1024
X
X#ifndef INADDR_NONE
X# define INADDR_NONE 0xffffffff
X#endif
X
Xstruct CL {
X               char line[ML];
X               char comm[MAXLLEN];
X          };
X
Xextern struct Option option;
Xextern struct File tmp[];
Xextern char *sys_errlist[];
Xextern int my_timezone;
X
Xint CLcomp(c1, c2)
X     const void *c1;
X     const void *c2;
X{
X     return strcasecmp((*(struct CL **)c1)->line,(*(struct CL **)c2)->line);
X}
X
Xint IPcomp(c1, c2)
X     const void *c1;
X     const void *c2;
X{
X     int c11,c12,c13,c14;
X     int c21,c22,c23,c24;
X     int ret_val;
X     struct CL *cl1, *cl2;
X
X     cl1 = *(struct CL **)c1;
X     cl2 = *(struct CL **)c2;
X
X     if(cl1->line[0]=='-' && (cl1->line[1]=='\n' || cl1->line[1]=='\0'))
X          c11=c12=c13=c14= -1;
X     else
X          sscanf(cl1->line,"%d.%d.%d.%d",&c11,&c12,&c13,&c14);
X
X     if(cl2->line[0]=='-' && (cl2->line[1]=='\n' || cl2->line[1]=='\0'))
X          c21=c22=c23=c24= -1;
X     else
X          sscanf(cl2->line,"%d.%d.%d.%d",&c21,&c22,&c23,&c24);
X
X     if(c11 != c21)
X          ret_val = (c11 - c21);
X     else if(c12 != c22)
X          ret_val = (c12 - c22);
X     else if(c13 != c23)
X          ret_val = (c13 - c23);
X     else if(c14 != c24)
X          ret_val = (c14 - c24);
X     else
X          ret_val = 0;
X
X     if(option.verbose>1)
X          printf("%d %d %d %d %c %d %d %d %d\n",
X		 c11,c12,c13,c14,
X		 (ret_val==0?'=':(ret_val>0?'>':'<')),
X		 c21,c22,c23,c24);
X     return ret_val;
X}
X
Xvoid warn_hyphens(argv)
X     char **argv;
X{
X     char **s;
X
X     if(argv==NULL)
X          return;
X     for(s=argv;*s!=NULL;s++)
X     {
X          if(**s=='-')
X          {
X               printf("hand: '%s' is being taken as a user or host name,\n",
X                      *s);
X               printf("hand: rather than as a flag.  Hope that's OK.\n");
X          }
X     }
X     return;
X}
X
Xvoid check_tty()
X{
X     if(!isatty(0))
X     {
X          printf("Sorry, you can't redirect output into this: it's interactive.\n");
X          exit(1);
X     }
X     return;
X}
X
Xint mv(ofile, nfile)
X     char *ofile;
X     char *nfile;
X{
X     FILE *ip, *op;
X     int c;
X
X     if((ip = fopen(ofile,"r"))==NULL)
X          return -1;
X     if((op = fopen(nfile,"w"))==NULL)
X          return -2;
X
X     while((c=getc(ip))!=EOF)
X          putc(c,op);
X     fclose(op);
X
X     unlink(ofile);
X}
X
Xint gettimezone(hp)
X     struct hname *hp;
X{
X     int i, diff, is_dst, is_pm, sd, hours, minutes;
X     FILE *sp;
X     char s[ML];
X     time_t *tp;
X     struct tm *tmp;
X
X     tp = (time_t *)malloc(sizeof(time_t));
X
X     if((sd = tcp_open(*hp, 13, 15))<0)
X          return -0xff;
X     sp = fdopen(sd, "r");
X     fgets(s,ML,sp);
X     fclose(sp);
X     close(sd);
X
X     if(option.verbose)
X          printf("%s said: %s",hp->ascii,s);
X
X     for(i=0;s[i] && s[i]!=':'; i++)
X          ;
X     for(;s[i]!=' ';i--)
X          ;
X     i++;
X
X     is_pm = (incasestr(s,"PM",i)>0);   /* stupid 12-hour computers */
X
X     /*
X      * s+i now points at a string of the form "xx:yy:zz foo bar".  We're
X      * interested in the xx:yy:zz part, specifically xx*60+yy.
X      */
X
X     sscanf(s+i,"%u:%u:", &hours, &minutes);
X     time(tp);
X     tmp = localtime(tp);
X     is_dst = (tmp->tm_isdst>0?1:0);
X     tmp = gmtime(tp);
X     diff = ((24 + hours - tmp->tm_hour - is_dst)*60
X             + (minutes - tmp->tm_min) + 30 )
X          / 60 - 24 + 12*is_pm;
X     if(diff>12)
X          diff=diff-24;
X
X     if(is_dst) /* major kluge: if we think it's DST, so do they. */
X          diff += 1;
X
X     if(option.verbose)
X          printf("%s's timezone is %d:00\n",hp->ascii,diff);
X
X     return diff;
X}
X
Xstruct CL *fgetcl(cl, n, ip)
X     struct CL *cl;
X     int n;
X     FILE *ip;
X{
X     char t[ML];
X
X     cl->line[0]=cl->comm[0]='\0';
X
X     if(fgets(cl->comm,n,ip)==NULL)
X          return NULL;
X     else if(cl->comm[0] != '#')
X     {
X          strcpy(cl->line,cl->comm);
X          cl->comm[0]='\0';
X          return cl;
X     }
X     else
X          do {
X               if(fgets(t,n,ip)==NULL)
X                    return cl;
X               else if(t[0]=='#')
X                    if(strlen(cl->comm)+strlen(t)<MAXLLEN)  /* truncates */
X                         strcat(cl->comm,t);                /* longer than */
X          } while(t[0]=='#');                               /* 1024 */
X     strcpy(cl->line,t);
X
X     return cl;
X}
X
Xint hsort(fn)
X     char *fn;
X{
X     int i,n, ret_val=0;
X     char tn[ML], s[ML];
X     FILE *ip, *op;
X     struct CL **coml, tc;
X
X     if((ip=fopen(fn,"r"))==NULL)
X     {
X          printf("Cannot open file %s\n",fn);
X          return -1;
X     }
X     do {
X          fgets(s,ML,ip);
X     } while(strcmp(s,"PSEUDONYM LIST\n"));
X     for(n=0;fgetcl(&tc, ML, ip)!=NULL;n++)
X          ;
X
X     coml=(struct CL **)malloc(n*sizeof(struct CL *));
X     for(i=0;i<n;i++)
X          coml[i]=(struct CL *)malloc(sizeof(struct CL));
X
X     rewind(ip);
X     tmpnam(tn);
X     op=fopen(tn,"w");
X     do {
X          fgets(s,ML,ip);
X          fputs(s,op);
X     } while(strcmp(s,"PSEUDONYM LIST\n"));
X     for(i=0;i<n;i++)
X          fgetcl(coml[i],ML,ip);
X     qsort(coml,n,sizeof(struct CL *),CLcomp);
X     for(i=0;i<n;i++)
X     {
X          if(coml[i]->comm[0]!='\0')
X               fputs(coml[i]->comm,op);
X          if(coml[i]->line[0]!='\0')
X          {
X               fputs(coml[i]->line,op);
X          }
X          else
X               ret_val++;
X          free(coml[i]);
X     }
X     fclose(ip);
X     fclose(op);
X     free(coml);
X
X     mv(tn,fn);
X
X     return ret_val;
X}
X
Xvoid del_many_users(fn)
X     char *fn;
X{
X     char s[ML];
X
X     check_tty();
X     for(;;)
X     {
X          printf("hand:del-user> ");
X          fflush(stdout);
X          if(fgets(s,ML,stdin)==NULL
X             || strcmp(s,".")==0)
X               break;
X          nonewlines(s);
X          deluser(s,fn,1);
X     }
X     putchar('\n');
X     return;
X}
X
Xvoid del_many_hosts(fn)
X     char *fn;
X{
X     char s[ML];
X
X     check_tty();
X     for(;;)
X     {
X          printf("hand:del-host> ");
X          fflush(stdout);
X          if(fgets(s,ML,stdin)==NULL
X             || strcmp(s,".")==0)
X               break;
X          nonewlines(s);
X          delhost(s,fn,1);
X     }
X     putchar('\n');
X     return;
X}
X
Xvoid add_many_users(fn)
X     char *fn;
X{
X     char s[ML];
X     char *t[3];
X     char *name, *nick;
X     char fmt[40];
X     FILE *fp;
X
X     /* don't you just love K&R C? */
X     strcpy(fmt,"%-20.20s %s\n");
X
X     check_tty();
X     printf("\nEnter a list of users, in the form\n\n\tlogin-name\tnickname\n\n");
X     printf("and a blank line to quit.  Typing \"?\" will give a summary\n");
X     printf("of the users listed so far.\n\n");
X     for(;;)
X     {
X          printf("hand:add-user> ");
X          fflush(stdout);
X          if(fgets(s,ML,stdin)==NULL
X             || strcmp(s,"\n")==0
X             || strcmp(s,".\n")==0)
X               break;
X          nonewlines(s);
X          if(strcmp(s,"?"))
X          {
X               t[0] = (char *)strtok(s," \t\n");
X               t[1] = t[0]+strlen(t[0])+1;
X               if(t[1][0]=='\0')
X               {
X                    t[1]=t[0];
X                    printf("You didn't give a nickname, so I'm assuming \"%s\"\n",
X                           t[0]);
X               }
X               t[2]=NULL;
X               adduser(t,fn,0);
X          }
X          else
X          {
X               fp = fopen(fn,"r");
X               while(fgets(s,ML,fp) && strcmp(s,"PSEUDONYM LIST\n"))
X                    ;
X               printf(fmt,"Login","Nickname");
X               printf(fmt,"--------","--------");
X               while(fgetl(s,ML,fp))
X               {
X                    nonewlines(s);
X                    for(name= &(s[0]);*name && !isspace(*name);name++)
X                         ;
X                    *name='\0';
X                    nick = ++name;
X                    name= &(s[0]);
X                    for(;*nick && isspace(*nick);nick++)
X                         ;
X                    printf(fmt,name,nick);
X               }
X               fclose(fp);
X          }
X     }
X     putchar('\n');
X     return;
X}
X
Xvoid add_many_hosts(fn)
X     char *fn;
X{
X     char s[ML];
X     char *t[3];
X     char *ip, *name, *timezone, *flags,*other;
X     char fmt[40];
X     FILE *fp;
X
X     /* I wish all C were ANSI C. */
X     strcpy(fmt,"%-15.15s %-15.15s %-4.4s %-8.8s %s\n");
X
X     check_tty();
X     printf("\nEnter a list of hosts, in the form\n\n\tcanonical-name\tnickname\n\n");
X     printf("and a blank line to quit.  Typing \"?\" will give a summary\n");
X     printf("of the hosts listed so far.\n\n");
X     for(;;)
X     {
X          printf("hand:add-host> ");
X          fflush(stdout);
X          if(fgets(s,ML,stdin)==NULL
X             || strcmp(s,"\n")==0
X             || strcmp(s,".\n")==0)
X               break;
X          nonewlines(s);
X          if(strcmp(s,"?"))
X          {
X               t[0] = (char *)strtok(s," \t\n");
X               t[1] = t[0]+strlen(t[0])+1;
X               lowercase(t[0]); /* for stupid resolvers */
X               if(t[1][0]=='\0')
X               {
X                    t[1]=NULL;
X                    printf("You didn't give a nickname, so I'm assuming \"%s\"\n",
X                           t[0]);
X               }
X               t[2]=NULL;
X               addhost(t,fn,1);
X          }
X          else
X          {
X               fp = fopen(fn,"r");
X               while(fgets(s,ML,fp) && strcmp(s,"HOST LIST\n"))
X                    ;
X               printf(fmt,"Canon","Nickname","Timezone","Flags","Misc");
X               printf(fmt,"---------------","----------------","--------","--------", "--------");
X               while(fgetl(s,ML,fp) && strcmp(s,"PSEUDONYM LIST\n"))
X               {
X                    ip = (char *)strtok(s,":\n");
X                    name = (char *)strtok(NULL,":\n");
X                    timezone = (char *)strtok(NULL,":\n");
X                    flags = (char *)strtok(NULL,":\n");
X                    other = (char *)strtok(NULL,":\n");
X                    printf(fmt,ip,name,timezone,flags,other);
X               }
X               fclose(fp);
X          }
X     }
X     putchar('\n');
X     return;
X}
X
Xint adduser(username, fn, be_quiet)
X     char **username;
X     char *fn;
X     int be_quiet;
X{
X     FILE *ip;
X     FILE *op;
X     char s[ML];
X
X     warn_hyphens(username);
X     if(*username==NULL)
X     {
X          add_many_users(fn);
X          return 0;
X     }
X     else if(username[1]==NULL)
X     {
X          if(!be_quiet)
X               printf("usage: hand --add-user <login_name> <nickname>\n");
X          return -1;
X     }
X
X     if((ip = fopen(fn,"r"))==NULL)
X     {
X          printf("hand: %s: %s\n",fn,sys_errlist[errno]);
X          return -1;
X     }
X     tmpnam(tmp[0].name);
X     tmp[0].fp = fopen(tmp[0].name,"w");
X
X     do {
X          fgets(s,ML,ip);
X          fputs(s,tmp[0].fp);
X     } while( strcmp(s,"PSEUDONYM LIST\n") );
X
X     fprintf(tmp[0].fp,"%-20s ",*username);
X     while(*++username!=NULL)
X     {
X          fputs(*username,tmp[0].fp);
X          if(*(username+1)==NULL)
X               fputc('\n',tmp[0].fp);
X          else
X               fputc(' ',tmp[0].fp);
X     }
X     while(fgets(s,ML,ip)!=NULL)
X          fputs(s,tmp[0].fp);
X     fclose(tmp[0].fp);
X     fclose(ip);
X
X     /* Now dump it all back into the original file */
X     ip = fopen(tmp[0].name,"r");
X     op = fopen(fn,"w");
X     while(fgets(s,ML,ip)!=NULL)
X          fputs(s,op);
X     fclose(ip);
X     fclose(op);
X     unlink(tmp[0].name);
X     tmp[0].name[0]='\0';
X
X     /* Sort the file, because now it's out of order */
X     hsort(fn);
X     return 0;
X}
X
Xint deluser(username, fn, be_quiet)
X     char *username;
X     char *fn;
X     int be_quiet;
X{
X     FILE *ip;
X     FILE *op;
X     char s[ML];
X     int counter=0;
X
X     if(username==NULL)
X     {
X          if(!be_quiet)
X               printf("--del-user whom?\n");
X          return -1;
X     }
X
X     if((ip = fopen(fn,"r"))==NULL)
X     {
X          printf("hand: %s: %s\n",fn,sys_errlist[errno]);
X          return -1;
X     }
X     tmpnam(tmp[0].name);
X     tmp[0].fp = fopen(tmp[0].name,"w");
X
X     do {
X          fgets(s,ML,ip);
X          fputs(s,tmp[0].fp);
X     } while( strcmp(s,"PSEUDONYM LIST\n") );
X
X     while(fgets(s,ML,ip)!=NULL)
X     {
X          if(strncasecmp(s,username,strlen(username))==0 &&
X             ( s[strlen(username)] == '@' ||
X             isspace(s[strlen(username)]) ) )
X          {
X               counter++;
X               printf("hand: removing line: %s",s);
X          }
X          else
X               fputs(s,tmp[0].fp);
X     }
X     if(!counter)
X          printf("No user found matching \"%s\"\n",username);
X     fclose(ip);
X     fclose(tmp[0].fp);
X
X     /* Now dump it all back into the original file */
X     ip = fopen(tmp[0].name,"r");
X     op = fopen(fn,"w");
X     while(fgets(s,ML,ip)!=NULL)
X          fputs(s,op);
X     fclose(ip);
X     fclose(op);
X     unlink(tmp[0].name);
X
X     /* No need to sort */
X
X     return 0;
X}
X
Xvoid checkhosts(fn, shutup)
X     char *fn;
X     int shutup;
X{
X     struct hname host, ihost;
X     struct hostent *hp;
X     int i, j, linec=0, new_timezone;
X     char s[ML], t[ML];
X     struct CL cl, **linep, *old_ip_address;
X     FILE *ip, *op;
X
X     ip = fopen(fn,"r");
X     tmpnam(tmp[0].name);
X     tmp[0].fp = fopen(tmp[0].name,"w");
X     
X     fgets(s,ML,ip);
X     if(strcmp(s,"HOST LIST\n"))
X     {
X          printf("hand: unknown file format: %s\n",fn);
X          fclose(ip);
X          fclose(tmp[0].fp);
X          unlink(tmp[0].name);
X          return;
X     }
X     fputs(s,tmp[0].fp);
X
X     while(fgets(s,ML,ip)!= NULL)
X     {
X          if(strcmp(s,"PSEUDONYM LIST\n")==0)
X               break;
X          while(isspace(s[strlen(s)-1]))
X               s[strlen(s)-1]='\0'; /* strip newline & white space */
X          if(s[0]=='#')
X          {
X               fprintf(tmp[0].fp,"%s\n",s);
X               continue;
X          }
X          else
X          {
X               t[0]='\0';
X               for(i=0;s[i]!='\0';i++)
X                    if(s[i]=='#' && s[i-1]!='\\')
X                    {
X                         strcpy(t,s+i);
X                         s[i]='\0';
X                         break;
X                    }
X               if(is_blank_str(s))
X               {
X                    fprintf(tmp[0].fp,"%s%s\n",s,t);
X                    continue;
X               }
X               host = hostname(s);
X               if(option.host<0)
X                    printf("fubar! %s",s);
X               ihost = host;
X
X               if(ihost.ascii[0]=='-')
X                    strcpy(ihost.dot,"-2.-2.-2.-2");
X
X               else if((hp = gethostbyname(ihost.ascii))==NULL)
X               {
X                    if(option.error==0 && !shutup)
X                         printf("warning: Address unknown: %s\n", ihost.ascii);
X               }
X               else
X               {
X                    sprintf(ihost.dot,"%u.%u.%u.%u",
X                            ((unsigned int)hp->h_addr[0])&255,
X                            ((unsigned int)hp->h_addr[1])&255,
X                            ((unsigned int)hp->h_addr[2])&255,
X                            ((unsigned int)hp->h_addr[3])&255);
X                    if(host.st==0 && strcmp(host.dot,ihost.dot))
X                    {
X                         if(option.fix==0)
X                         {
X                              printf("Warning: possibly incorrect IP address for %s\n",host.ascii);
X                              printf("         (%s instead of %s)\n",host.dot,ihost.dot);
X                         }
X                         else
X                         {
X                              printf("Warning: correcting IP address for %s\n",host.ascii);
X                              printf("         (%s for %s)\n",ihost.dot,host.dot);
X                              strcpy(host.dot,ihost.dot);
X                         }
X                    }
X                    else if(host.st) /* there is no decimal name */
X                    {
X                              strcpy(host.dot,ihost.dot);
X                    }
X               }
X          }
X          if((host.st==0 || hp != NULL) && host.ascii[0]!='-')
X          {
X               if(option.fix)
X               {
X                    new_timezone = gettimezone(&host);
X                    if(new_timezone==-0xff)
X                    {
X                         printf("Warning: cannot get timezone from %s\n",
X                                host.true);
X                    }
X                    else if(new_timezone!=host.timezone)
X                    {
X                         printf("Warning: correcting timezone for %s (%d instead of %d)\n",
X                                host.true,new_timezone,host.timezone);
X                         host.timezone=new_timezone;
X                    }
X               }
X               fprintf(tmp[0].fp,"%s:%s:%d:%s%s\n",
X                       host.dot,host.true,host.timezone,host.flags,t);
X          }
X          else if(host.ascii[0]=='-')
X               fputs("-\n",tmp[0].fp);
X          else if(host.ascii[0]!='\0')
X               printf("Warning: removing unknown machine: %s\n",host.ascii);
X     }
X     do {
X          fputs(s,tmp[0].fp);
X     } while(fgets(s,ML,ip)!=NULL);
X     fclose(ip);
X     fclose(tmp[0].fp);
X
X     tmp[0].fp = fopen(tmp[0].name,"r");
X     op = fopen(fn,"w");
X     fgets(s,ML,tmp[0].fp); /* HOST LIST */
X     while(fgetcl(&cl,ML,ip)!=NULL && strcmp(cl.line,"PSEUDONYM LIST\n"))
X          linec++;
X     rewind(tmp[0].fp);
X     fgets(s,ML,ip);        /* HOST LIST */
X
X     if(linec==0)
X	  printf("No hosts?!\n");
X     else if((linep = (struct CL **)malloc(linec*sizeof(struct CL *)))==NULL)
X     {
X          fprintf(stderr,"Malloc error: not enough memory!\n");
X          fclose(ip);
X          return;
X     }
X     for(i=0;i<linec;i++)
X     {
X          linep[i] = (struct CL *)malloc(sizeof(struct CL));
X          fgetcl(linep[i],ML,tmp[0].fp);
X     }
X     if(option.verbose>1)
X     {
X          for(i=0;i<linec;i++)
X               printf("%s",linep[i]->line);
X     }
X     if(linec)
X	  qsort(linep,linec,sizeof(struct CL *),IPcomp);
X     fputs("HOST LIST\n",op);
X
X     old_ip_address = &cl; /* just some old space */
X     strcpy(old_ip_address->line,"-2.-2.-2.-2"); /* impossible address */
X     for(i=0;i<linec;i++)
X     {
X          if(linep[i]->comm[0]!='\0')
X               fputs(linep[i]->comm,op);
X          if(IPcomp(&old_ip_address,&linep[i])==0)
X          {
X               printf("hand: deleting redundant host entry: %s",
X                    linep[i]->line);
X          }
X          else if(linep[i]->line[0]!='\0')
X               fputs(linep[i]->line,op);
X          strcpy(old_ip_address->line,linep[i]->line);
X          free(linep[i]);
X     }
X     free(linep);
X     while(fgets(s,ML,tmp[0].fp)!=NULL)
X          fputs(s,op);
X     fclose(tmp[0].fp);
X     fclose(op);
X     unlink(tmp[0].name);
X
X     return;
X}
X
Xint addhost(host, fn, be_quiet)
X     char **host;
X     char *fn;
X     int be_quiet;
X{
X     FILE *ip, *op;
X     struct hostent *hp;
X     char s[ML], host_ip[20];
X     struct hname hhost;
X
X     warn_hyphens(host);
X     if(*host==NULL)
X     {
X          add_many_hosts(fn);
X          return 0;
X     }
X
X     if(inet_addr(*host)==INADDR_NONE)
X     {
X          if((hp=gethostbyname(*host))==NULL && strcmp(*host,"-"))
X          {
X               printf("Error:  Address unknown: %s\n",*host);
X               return -1;
X          }
X          else if(strcmp(*host,"-")==0)
X          {
X               sprintf(host_ip,"-");
X               *host = "";
X          }
X          else
X          {
X               sprintf(host_ip,"%u.%u.%u.%u",
X                       ((unsigned int)hp->h_addr[0])&255,
X                       ((unsigned int)hp->h_addr[1])&255,
X                       ((unsigned int)hp->h_addr[2])&255,
X                       ((unsigned int)hp->h_addr[3])&255);
X               /*
X                * Newer systems define h_addr to h_addr_list[0];
X                * older ones don't have the latter.
X                */
X#ifdef h_addr
X               if(hp->h_addr_list[1]!=NULL)
X               {
X                    printf("Warning: %s has more than one address.\n",*host);
X                    printf("         using address %s.\n",host_ip);        
X               }
X#endif
X          }
X          if(*(host+1)!=NULL && *host[0]!='\0')
X               *host = host_ip;
X     }
X
X     if((ip = fopen(fn,"r"))==NULL)
X     {
X          printf("hand: %s: %s\n",fn,sys_errlist[errno]);
X          return -1;
X     }
X     tmpnam(tmp[0].name);
X     tmp[0].fp = fopen(tmp[0].name,"w");
X
X     while(fgets(s,ML,ip)!=NULL && strcmp(s,"PSEUDONYM LIST\n"))
X          fputs(s,tmp[0].fp);
X
X     strcpy(hhost.dot,host_ip);
X     strcpy(hhost.true,*host);
X     strcpy(hhost.ascii,*host);
X     hhost.st=0;
X     hhost.flags[0]='\0';
X     hhost.timezone=gettimezone(&hhost);
X     if(hhost.timezone==-0xff)
X     {
X          printf("Cannot get timezone from %s; assuming ours (%d:00)\n",
X                 hhost.true,my_timezone);
X          hhost.timezone=my_timezone;
X     }
X
X     if(host[1]==NULL)
X          fprintf(tmp[0].fp,"%s:%s",hhost.dot,hhost.true);
X     else
X     {
X          fprintf(tmp[0].fp,"%s:",*host++);
X          while(*host != NULL)
X          {
X               fputs(*host,tmp[0].fp);
X               if(*++host!=NULL)
X                    fputc(' ',tmp[0].fp);
X          }
X     }
X     fprintf(tmp[0].fp,":%d:%s\n",hhost.timezone,hhost.flags);
X
X     do {
X          fputs(s,tmp[0].fp);
X     } while(fgets(s,ML,ip)!=NULL);
X
X     fclose(ip);
X     fclose(tmp[0].fp);
X
X     mv(tmp[0].name,fn);
X
X     checkhosts(fn,be_quiet);
X     return 0;
X}
X
Xint delhost(host, fn, be_quiet)
X     char *host;
X     char *fn;
X     int be_quiet;
X{
X     FILE *ip, *op;
X     char s[ML];
X     struct hname ihost, thost;
X     struct hostent *hp;
X     int literal=0, counter=0, dot_l=0;
X
X     if(host==NULL)
X     {
X          if(!be_quiet)
X               printf("--del-host what?\n");
X          return -1;
X     }
X
X     ihost = hostname(host);
X     if(ihost.st!=0) /* no dotted-decimal name provided */
X     {
X          if((hp = gethostbyname(host))==NULL)
X          {
X               printf("Invalid address: %s; using literal search\n",host);
X               literal++;
X          }
X          else
X               sprintf(ihost.dot,"%u.%u.%u.%u",
X                       ((unsigned int)hp->h_addr[0])&255,
X                       ((unsigned int)hp->h_addr[1])&255,
X                       ((unsigned int)hp->h_addr[2])&255,
X                       ((unsigned int)hp->h_addr[3])&255);
X     }
X
X     if(!literal)
X          dot_l = strlen(ihost.dot);
X
X     if((ip = fopen(fn,"r"))==NULL)
X     {
X          printf("hand: %s: %s\n",fn,sys_errlist[errno]);
X          return -1;
X     }
X     tmpnam(tmp[0].name);
X     tmp[0].fp = fopen(tmp[0].name,"w");
X
X     while(fgets(s,ML,ip)!=NULL && strcmp(s,"PSEUDONYM LIST\n"))
X     {
X          thost=hostname(s);
X          if( (!literal && strcmp(thost.dot,ihost.dot)==0)
X             || (literal && incasestr(s,host,0)>=0))
X          {
X               counter++;
X               printf("hand: removing line: %s",s);
X          }
X          else
X               fputs(s,tmp[0].fp);
X     }
X     if(!counter)
X     {
X          printf("hand: no host %s; using literal search.\n",ihost.dot);
X          rewind(ip);
X          rewind(tmp[0].fp);
X          while(fgets(s,ML,ip)!=NULL && strcmp(s,"PSEUDONYM LIST\n"))
X          {
X               if(incasestr(s,host,0)>=0)
X               {
X                    counter++;
X                    printf("hand: removing line: %s",s);
X               }
X               else
X                    fputs(s,tmp[0].fp);
X          }
X     }
X     if(!counter)
X          printf("No host found matching \"%s\"\n",host);
X
X     do {
X          fputs(s,tmp[0].fp);
X     } while(fgets(s,ML,ip)!=NULL);
X
X     fclose(ip);
X     fclose(tmp[0].fp);
X
X     /* Now dump it all back into the original file */
X     ip = fopen(tmp[0].name,"r");
X     op = fopen(fn,"w");
X     while(fgets(s,ML,ip)!=NULL)
X          fputs(s,op);
X     fclose(ip);
X     fclose(op);
X     unlink(tmp[0].name);
X
X     /* No need to sort */
X
X     return 0;
X}
END_OF_FILE
if test 25195 -ne `wc -c <'handsort.c'`; then
    echo shar: \"'handsort.c'\" unpacked with wrong size!
fi
# end of 'handsort.c'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
echo shar: Extracting \"'main.c'\" \(29990 characters\)
sed "s/^X//" >'main.c' <<'END_OF_FILE'
X/*
X *  M A I N . C   -   Hand main module.
X *
X *  Hand  -  a bunch of fingers; determine whether your associates are
X *           logged in, on your own host or remotely.
X *
X */
X
X/*
X *   Copyright (C) 1992, 1993, 1994 Konrad Schroder.
X *
X *   This program is free software; you can redistribute it and/or modify
X *   it under the terms of the GNU General Public License as published by
X *   the Free Software Foundation; either version 1, or (at your option)
X *   any later version.
X *
X *   This program is distributed in the hope that it will be useful,
X *   but WITHOUT ANY WARRANTY; without even the implied warranty of
X *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *   GNU General Public License for more details.
X *
X *   You should have received a copy of the GNU General Public License
X *   along with this program; if not, write to the Free Software
X *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#ifndef lint
Xstatic char copyright[]=
X     "Copyright (C) 1992, 1993, 1994 Konrad Schroder.\nAll rights reserved.\n";
X#endif
X
X#include <netdb.h>
X#include <ctype.h>
X#include <errno.h>
X#include <setjmp.h>
X#include <signal.h>
X#include <sys/signal.h>
X#include <stdio.h>
X#include <time.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <sys/wait.h>
X#include <sys/file.h>
X#include <sys/param.h>
X#include "hand.h"       /* needed before ifdef's below */
X
X#if HAVE_UNISTD_H
X# include <unistd.h>
X#endif
X#if HAVE_STRING_H
X# include <string.h>
X#else
X# include <strings.h>
X#endif
X#if HAVE_MALLOC_H
X# include <malloc.h>
X#endif
X
X#include "parse.h"
X#include "handstr.h"
X#include "handtcp.h"
X
X#define PARENT 1
X#define CHILD 0
X
Xjmp_buf hither;
Xextern char *sys_errlist[],
X            program_name[];
Xint nofpeople=0,
X    athome,
X    ppid=0,
X    mypid=0,
X    nproc=0,
X    curnproc=0,
X    start_subsys,
X    is_dst,
X    my_timezone;
Xstruct Process *process;
Xstruct File tmp[4];
Xstruct Option option;
Xchar runninghost[64],
X     *tmpdir,
X     **global_argv,
X     **global_envv,
X     home[ML];
X
X/*
X * Clean up when the process gets an interrupt; interrupt all children,
X * and wait for them to terminate.
X */
X
Xvoid suicide(parent_or_child)
X     int parent_or_child;
X{
X     int i;
X     
X     for(i=0;i<2;i++)
X          if(tmp[i].name[0]!='\0' && access(tmp[i].name,0)==0)
X          {
X               if(tmp[i].fp!=NULL)
X                    fclose(tmp[i].fp);
X               unlink(tmp[i].name);
X          }
X     if(parent_or_child==PARENT)
X     {
X          if(tmp[2].name[0]!='\0' && access(tmp[2].name,0)==0)
X          { 
X               fclose(tmp[2].fp);
X               unlink(tmp[2].name);
X          }
X          exit(1);
X     }
X     else /* CHILD */
X          _exit(0);
X}
X
X/*
X * clean up after abort.
X */
Xvoid flush_dead_fetus()
X{
X     int i, st;
X     
X     if(option.footer == 0 && mypid==ppid)
X          printf("\n");
X     if(mypid==ppid) /* parent */
X     {
X          for(i=0;i<nproc;i++)
X               kill(SIGINT,process[i].pid);   /* kill the kid */
X          while(wait((UNION_WAIT *)&st)>=0)   /* wait for all children to die */
X          { }
X          suicide(PARENT);
X     }
X     else /* child */
X          suicide(CHILD);
X}
X
X/*
X * poor man's perror.
X */
X
Xvoid errout(calln, errn, filen)
X     char *calln;
X     char *errn;
X     char *filen;
X{
X     fprintf(stderr, "%s: %s", calln, errn);
X     if(strcasecmp(filen,"\0") != 0)
X          fprintf(stderr,": \"%s\"", filen);
X     fprintf(stderr, "\n");
X     return;
X}
X
X/*
X * testfork() calls fork() only if the bit option.fork is set.
X * Otherwise, it returns zero.
X * If fork() returns negative, indicating an error, an error message
X * is produced (unless option.error is set) and testfork() returns negative.
X */
X
Xint testfork(outp)
X     FILE *outp;
X{
X     int st, t_procn, i, siz;
X     struct User buf;
X     
X     if(!option.fork) /* no forking allowed */
X          return 0;
X     else /* forking allowed */
X     {
X          if(option.fork<=curnproc)
X          {
X               t_procn = wait((UNION_WAIT *)&st);
X               for(i=0;i<nproc;i++)
X                    if(process[i].pid==t_procn)
X                    {
X                         process[i].ret_val=st;
X                         if( (st>>8) >0 )
X                         {
X                              while(
X                                    (siz=read(process[i].pipe[0],(void *)&buf,
X                                              sizeof(buf))) > 0)
X                                   if(option.watch)
X                                   {
X                                        add_to_new_list((struct User *)&buf);
X                                   }
X                                   else
X                                   {
X                                        fprintf(outp,"%s",buf.line);
X/*                                      fwrite(buf,sizeof(char),siz,outp); */
X                                        fflush(outp);
X                                   }
X                              
X                         }
X                         close(process[i].pipe[0]);
X                         nofpeople += (st >> 8);
X                         break;
X                    }
X               curnproc--;
X          }
X          if((st=fork())<0 && !option.error)
X               fprintf(stderr,"fork #%d: failed with %s\n",
X                       nproc, sys_errlist[errno]);
X          return st;
X     }
X}
X
X/*
X * fgetl() reads lines using fgets() until it finds a "valid" line, i.e.
X * one which does not begin with '#', and is not totally blank.
X * It also removes comments beginning with '#', unless the '#' appears as
X * "\\#", and it removes all characters '\\' unless they appear as "\\\\".
X */
X
Xchar *fgetl(s, n, stream)
X     char *s;
X     int n;
X     FILE *stream;
X{
X     char t[ML], *st;
X     int i,j=0;
X     
X     do
X     {
X          st=fgets(t,n,stream);
X     } while(st!=NULL
X             && (t[0]=='#' || is_blank_str(t)));
X     if(st==NULL)
X     {
X          return st;
X     }
X     else
X     {
X          for(i=0; t[i]!='\0'; i++)
X          {
X               if(t[i]=='#')
X                    break;
X               else if(t[i]=='\\')
X               {
X                    i++;
X                    s[j]=t[i];
X                    j++;
X               }
X               else
X               {
X                    s[j]=t[i];
X                    j++;
X               }
X          }
X          s[j]='\0';
X     }
X     return s;
X}
X
X/*
X * abrt() is a dummy function that serves only to redirect
X * control to the right place after a signal.
X */
X
XRETSIGTYPE abrt(not_used)
X     int not_used;
X{
X     longjmp(hither,-1);
X     /*NOTREACHED*/
X     return;
X}
X
X/*
X * satis_host compares the "path" where with the host sys, and does primitive
X * pattern-matching to determine whether sys is an acceptible part of where.
X * It returns 1 if acceptible, 0 if not.
X */
X
Xint satis_host(where, sys)
X     char *where;
X     char *sys;
X{
X     char wh[ML];
X     int i,j;
X     
X     i=incasestr(where,",",0);
X     j=(where[i+1]=='!');
X     strncpy(wh,where+j,(i>=0 ? i : strlen(where)));
X     wh[(i>=0?i:strlen(where))] = '\0';
X     if(wh[0]=='\0')
X          return 1-j;        /* joeblow@! is a null entry */
X     else if(wh[0]=='*' && endcmp(sys,wh+1)==0)
X          return 1-j;
X     else if(strncasecmp(wh,sys,strlen(wh))==0)
X          return 1-j;
X     else if(i>=0)
X          return satis_host(where+i+1, sys);
X     else
X          return j;
X}
X
X/*
X * outstr() creates an output string, either fixed-format or a complete
X * sentence, from its last three arguments and stores it in its first argument.
X */
X
Xvoid outstr(s, host, user, friend)
X     char *s;
X     struct hname *host;
X     struct User *user;
X     struct Friend *friend;
X{
X     char idle_s[ML];
X     char his_host[ML];
X     char *t;
X     int login_time=0;
X     char days_of_week[28];
X
X     /* I wish all C were ANSI C... */
X     memcpy(days_of_week,"Sun\0Mon\0Tue\0Wed\0Thu\0Fri\0Sat\0",28);
X
X     if(option.watch)
X     {
X          sprintf(s,"%s@%s@%s\n",friend->true, friend->name, host->true);
X          return;
X     }
X
X     /*
X      * If his finger daemon gave us a host name, and the host flag is set,
X      * use that name instead of the one we fingered.
X      */
X     if((user->flags & HF_HOST) && option.host)
X     {
X          if((t=(char *)strchr(host->true,'.'))!=NULL)
X               sprintf(his_host,"%s%s",user->host,t);
X          else
X               strcpy(his_host,user->host);
X     }
X     else
X          strcpy(his_host,host->true);
X     /*
X      * Adjust for time zone, if the timezone flag is set.
X      */
X     if((user->flags & HF_WHEN) && option.timezone)
X     {
X          /* parse the time field */
X          if(strchr("SMTWFsmtwf",user->when[0]))
X          {
X               switch(user->when[1])
X               {
X                  case 'o':
X                    login_time += 1;
X                    break;
X                  case 'u':
X                    if(user->when[0]=='T' || user->when[0]=='t')
X                         login_time += 2;
X                    break;
X                  case 'e':
X                    login_time += 3;
X                    break;
X                  case 'h':
X                    login_time += 4;
X                    break;
X                  case 'r':
X                    login_time += 5;
X                    break;
X                  case 'a':
X                    login_time += 6;
X                    break;
X               }
X               login_time *= 24;
X               login_time += atoi(user->when + 4);
X               login_time -= host->timezone;
X               login_time += my_timezone;
X
X               if(login_time < 0)
X                    login_time += 7*24;
X               else if(login_time > 7*24)
X                    login_time -= 7*24;
X
X               sprintf(user->when,"%s %d%s",days_of_week+4*(login_time/24),
X                       login_time%24,strchr(user->when,':'));
X          }
X     }
X     if(option.fxfmt)
X     {
X          lowercase(user->what);
X          sprintf(s,
X                  "%-12.12s %-20.20s %-16.16s %-9.9s %-8.8s",
X                  friend->name, friend->true,
X                  his_host, user->when, user->what);
X          if(user->flags&HF_IDLE && user->idle)
X          {
X               if(user->idle>=60*24*7)
X                    sprintf(idle_s," %dw",user->idle/(60*24*7));
X               else if(user->idle>=60*24)
X                    sprintf(idle_s," %dd",user->idle/(60*24));
X               else if(user->idle>=60)
X                    sprintf(idle_s," %d:",user->idle/60);
X               else
X                    sprintf(idle_s," %d",user->idle);
X               strcat(s,idle_s);
X          }
X          if(user->flags & HF_TTY && strchr(user->tty,'*'))
X               strcat(s," *");
X          strcat(s,"\n");
X     }
X     else
X     {
X          switch(user->flags & (HF_WHAT|HF_WHEN))
X          {
X             case HF_WHAT: /* 1 - VMS */
X               sprintf(s,"%s (%s) is using %s on %s",friend->name,
X                       friend->true, user->what, his_host);
X               break;
X             case HF_WHEN:  /* 2 - Unix */
X               sprintf(s,"%s (%s) has been on %s since %s",friend->name,
X                       friend->true, his_host, user->when);
X               break;
X             case HF_WHAT|HF_WHEN: /* 3 - Never seen this one */
X               sprintf(s,
X                       "%s (%s) has been on %s since %s,\nand is presently using %s",
X                       friend->name, friend->true,
X                       his_host, user->when, user->what);
X               break;
X             default:
X               sprintf(s,"%s (%s) is on %s", friend->name, friend->true,
X                       his_host);
X          }
X          /*
X           * If the idle flag is set, create a verbal string in the form
X           * "but has been idle for n {weeks,days,hours,minutes}"
X           * and append it to the message.
X           */
X          if(user->flags&HF_IDLE && user->idle)
X          {
X               if(user->idle < 60)
X               {
X                    sprintf(idle_s,"%d minute",user->idle);
X                    if(user->idle>=2)
X                         strcat(idle_s, "s");
X               }
X               else if(user->idle < 24*60)
X               {
X                    sprintf(idle_s,"%d hour",user->idle/60);
X                    if(user->idle>=(2*60))
X                         strcat(idle_s, "s");
X               }
X               else if(user->idle < 7*24*60)
X               {
X                    sprintf(idle_s,"%d day",user->idle/(24*60));
X                    if(user->idle>=(2*24*60))
X                         strcat(idle_s, "s");
X               }
X               else
X               {
X                    sprintf(idle_s,"%d week",user->idle/(7*24*60));
X                    if(user->idle>=(2*7*24*60))
X                         strcat(idle_s, "s");
X               }
X               sprintf(s,"%s\n\tbut has been idle for %s",s,idle_s);
X               if(user->flags & HF_TTY && strchr(user->tty,'*'))
X                    sprintf(s,"%s\n\tand is refusing messages",s);
X          }
X          else
X          {
X               if(user->flags & HF_TTY && strchr(user->tty,'*'))
X                    sprintf(s,"%s\n\tbut is refusing messages",s);
X          }
X          strcat(s,".\n");
X     }
X     return;
X}
X
Xint separate(host, fn, userp, outfd)
X     struct hname *host;
X     char *fn;
X     struct User **userp;
X     int outfd;
X{
X     int i,j,k=0;
X     int oldidle=INT_MAX;
X     char f[ML], outs[ML], oldname[NMAX], *t;
X     FILE *ap;
X     struct User user, the_match;
X     struct Friend friend, oldfriend;
X
X     if((ap=fopen(fn,"r"))==NULL)
X     {
X          errout("separate",sys_errlist[errno],fn);
X          return -1;
X     }
X     outs[0]='\0';
X     friend.name[0]='@';
X     friend.name[1]='\0';
X     
X     while(strcmp(f,"PSEUDONYM LIST\n"))
X          fgetl(f,ML,ap);
X     
X     for(;;)
X     {
X          user = *userp[k];
X          
X          while(strcasecmp(user.name,friend.name)>0)
X          {
X               if(fgetl(f,ML,ap)==NULL)
X                    goto end_of_loop;
X               
X               i=0;
X               while(!isspace(f[i]) && f[i]!='@')
X               {
X                    friend.name[i]=f[i];
X                    i++;
X               }
X               friend.name[i]='\0';
X               
X               j=0;
X               if(f[i++]=='@')
X                    while(!isspace(f[i]))
X                         friend.where[j++]=f[i++];
X               friend.where[j]='\0';
X               
X               while(isspace(f[i]) && f[i]!='\n')
X                    i++;
X               
X               j=0;
X               while(f[i]!='\n')
X                    friend.true[j++]=f[i++];
X               friend.true[j]='\0';
X               
X               /* Multiple friends with the same login name */
X               /* WARNING: do not reference userp[k] after this  */
X               /* until k has been incremented--since k may well */
X               /* be -1 after this loop is finished.             */
X               if(k>0 && strcasecmp(userp[k-1]->name,friend.name)==0)
X               {
X                    k--;
X                    while(k>=0 && strcasecmp(userp[k]->name,friend.name)==0)
X                    {
X                         oldname[0]='\0';
X                         k--;
X                    }
X                    break;        /* don't read a new friend after this */
X               }
X          }
X          
X          if(strcasecmp(user.name,friend.name)==0 &&
X             satis_host(friend.where,host->ascii))
X          {
X               if(strcmp(oldname,friend.name) || !option.once_only)
X               {
X                    if(option.verbose>1)
X                         printf("%d: found %s\n",mypid,friend.name);
X                    strcpy(oldname,friend.name);
X                    if(oldidle<option.idle_max)
X                    {
X                         nofpeople++;
X
X                         hand_match_out(mypid,the_match,outfd);
X                    }
X                    oldidle=INT_MAX;
X                    outs[0]='\0';
X               }
X               if(user.idle<oldidle)
X               {
X                    oldfriend=friend;
X                    the_match = user;
X                    outstr(outs, host, &user, &friend);
X                    if(option.host && (user.flags & HF_HOST))
X                    {
X                         if((t=(char *)strchr(host->true,'.'))!=NULL)
X                              sprintf(the_match.host,"%s%s",user.host,t);
X                         else
X                              strcpy(the_match.host,user.host);
X                    }
X                    else
X                         strcpy(the_match.host,host->true);
X                    strcpy(the_match.line,outs);
X                    strcpy(the_match.true,friend.true);
X                    if((the_match.flags & HF_TTY)==0)
X                         the_match.tty[0]='\0';
X                    oldidle=user.idle;
X               }
X          }
X          k++;
X     }
X   end_of_loop:
X     if(outs[0]!='\0' && oldidle < option.idle_max)
X     {
X          nofpeople++;
X          if(option.verbose)
X          {
X               printf("%d - %.20s\n",mypid,the_match.line);
X               fflush(stdout);
X          }
X          hand_match_out(mypid,the_match,outfd);
X     }
X     for(k=0;userp[k]->name[0]!='|';k++)
X          free(userp[k]);
X     free(userp[k]);
X     free(userp);
X     
X     fclose(ap);
X     return 0;
X}
X
X/*
X * This is the "main" routine of hand.  It isn't the entry point for the
X * program--that's in the file handi.c--it just does the "hand things".
X * The idea is that each interface to hand gets to set up the options
X * itself, so for example an X interface would have its own main(), a
X * NeXTstep interface its own, a curses interface its own, etc.
X */
X
Xint h_main(nusr, wusr, fn, outp)
X     int nusr;
X     char *wusr;
X     char *fn;
X     FILE *outp;
X{
X     int i, k, st, procn, nlsys=0, siz, dead_pid;
X     int umbilicus, umb_proc;
X     char s[ML], header[ML], runningdot[ML];
X     FILE *dat;
X     time_t tym;
X     struct tm ltm, gtm;
X     struct hname host;
X     struct hostent *hp;
X     struct User **user, buf;
X     
X     nproc=curnproc=0;
X     ppid=getpid(); /* only the parent executes this instruction */
X     mypid=ppid;    /* and we need not know the pid of the shell */
X     runningdot[0]='\0';
X
X     /*
X      * Now, for each host in the (possibly temporary) address file, hand
X      * will fork (assuming option.fork is set), and the child will perform
X      * a finger-separate-output routine.
X      * If option.fork is not set, via the +no-fork option, the parent
X      * does performs each finger-separate-output routine in sequence.
X      */
X     
X     /*  Open the address file.  If it exists, count the number of hosts. */
X     
X     if((dat = fopen(fn,"r")) == NULL)
X     {
X          errout(program_name, sys_errlist[errno], fn);
X          exit(1);
X     }
X     fgetl(s,ML,dat);
X     if(strcmp(s,"HOST LIST\n") != 0)
X     {
X          errout(program_name, "incompatible file format", fn);
X          flush_dead_fetus();
X     }
X     nlsys=0;
X     while(fgetl(s,ML,dat)!=NULL)
X     {
X          nlsys++;
X          if(strcmp(s,"PSEUDONYM LIST\n")==0)
X               break;
X     }
X     
X     /* Construct the header, and print it to stdout if option.noheader==0 */
X     
X     if(option.header)
X     {    
X          if(option.version)
X               sprintf(header, "\nHand %s (%s) by Konrad Schroder    ", HAND_VERSION,
X                       DATE);
X          else
X               sprintf(header,"\nHand %s   by Konrad Schroder    ",HAND_VERSION);
X          if(option.fxfmt)
X          {
X               sprintf(header,
X                       "%s\n%-12.12s %-20.20s %-16.16s %-9.9s %-8.8s %-4.4s\n",
X                       header, "username", "truename", "hostname",
X                       "  since", "what", "idle");
X          }
X          else
X               strcat(header,"\n\n");
X          fputs(header,outp);
X     }
X     
X     /* allocate the space for the pid array; here the parent will
X        remember the pids of each child. */
X     
X     process = (struct Process *)malloc(nlsys*sizeof(struct Process));
X     
X     rewind(dat);
X     fgetl(s,ML,dat);   /* read the HOST LIST line again */
X     k=0;
X     while( fgetl(s,ML,dat)!=NULL && strcmp(s,"PSEUDONYM LIST\n")!=0 )
X     {
X          /*
X           * If option.localhost is set -- i.e. if the list of
X           * host names came from an extant file rather than
X           * off of the command line -- then keep track of the
X           * running host's IP address so that we don't run on
X           * it twice.
X           */
X          
X          if(option.localhost)
X               if(s[0]!='-')
X               {
X                    host = hostname(s);
X                    if(option.localhost
X                       && strcmp(host.dot,runningdot)==0)
X                         continue;
X               }
X               else
X               {
X                    hp = gethostbyname(runninghost);
X                    sprintf(runningdot,"%u.%u.%u.%u",
X                            abs((int)(unsigned char)hp->h_addr[0]),
X                            abs((int)(unsigned char)hp->h_addr[1]),
X                            abs((int)(unsigned char)hp->h_addr[2]),
X                            abs((int)(unsigned char)hp->h_addr[3]));
X               }
X          
X          if(option.fork)
X          {
X               if(pipe(process[nproc].pipe)<0)
X               {
X                    errout(program_name,sys_errlist[errno],"");
X                    flush_dead_fetus();
X               }
X          }
X          umb_proc = nproc;
X          while((procn=testfork(outp))<0)
X               sleep(1);
X          if(procn==0)
X          {
X               /*
X                * The child.
X                */
X               
X               if(option.fork)
X               {
X                    umbilicus = process[umb_proc].pipe[1];
X                    mypid=getpid();
X                    close(process[umb_proc].pipe[0]);
X                    
X                    if(setjmp(hither))
X                    {
X                         signal(SIGINT, SIG_IGN);
X                         signal(SIGHUP, SIG_IGN);
X                         flush_dead_fetus();
X                    }
X               }
X               else
X               {
X                    close(process[umb_proc].pipe[1]);
X                    umbilicus=1;
X               }
X               
X               signal(SIGINT, abrt); /* reinstated as promised */
X               signal(SIGHUP, abrt);
X               nonewlines(s);
X               
X               if(strcmp(s,"-")) /* not "at-home" */
X               {
X                    host = hostname(s);
X                    athome=0;
X                    if(host.flags[0])
X                    {
X                         /* re-parse args, with this host's args in between */
X                         set_defaults(fn);
X                         if(gethandopt(global_envv,fn,&tmp[2],&wusr,&nusr)<0)
X                         {
X                              printf("Died on envv.\n");
X                              exit(1);
X                         }
X                         if(gethandopt(strarg(global_argv,host.flags),fn,
X                                       &tmp[2],&wusr,&nusr)<0)
X                         {
X                              printf("Died on host.\n");
X                              exit(1);
X                         }
X                         if(gethandopt(global_argv, fn, &tmp[2],&wusr,&nusr)<0)
X                         {
X                              printf("Died on argv.\n");
X                              exit(1);
X                         }
X                    }
X               }
X               else
X               {
X                    strcpy(host.ascii,runninghost);
X                    strcpy(host.true,runninghost);
X                    host.timezone=my_timezone;
X                    host.st=1;
X                    if(option.fxfmt==0)
X                         truecase(host.true);
X                    athome=1;
X               }
X               if(host.st == -1)
X               {
X                    errout(fn,sys_errlist[errno],s);
X                    if(option.fork)
X                    {
X                         close(process[umb_proc].pipe[1]);
X                         suicide(CHILD);
X                    }
X               }
X#ifndef OS2
X               else if(athome)
X               {
X                    sprintf(*global_argv, "local_finger");
X                    if(option.what)
X                    {
X                         if(w_finger(&tmp[1],&tmp[0])<0)
X                         {
X                              if(option.fork)
X                              {
X                                   close(process[umb_proc].pipe[1]);
X                                   suicide(CHILD);
X                              }
X                         }
X                    }
X                    else
X                    {
X                         if((user=t_finger())==NULL)
X                         {
X                              if(option.fork)
X                              {
X                                   close(process[umb_proc].pipe[1]);
X                                   suicide(CHILD);
X                              }
X                         }
X                    }
X#endif
X               }
X               else
X               {
X                    sprintf(*global_argv, "@%s (hand)             ",host.ascii);
X                    /* allowance for no ascii name */
X                    if(host.ascii[0]=='\0')
X                    {
X                         printf("FUBAR!\n");
X                         strcpy(host.ascii,host.dot);
X                         strcpy(host.true,host.dot);
X                    }
X                    if(finger(host,option.timeout,&tmp[0])<0)
X                         if(option.fork)
X                         {
X                              close(process[umb_proc].pipe[1]);
X                              suicide(CHILD);
X                         }
X               }
X               /*
X                * Sort the finger output, separate occurrences of matches
X                * to the address file, and output any such matches.
X                */
X               
X               if(!athome || option.what)
X                    user=parse(&tmp[0]);
X               /* otherwise, we already have user from t_finger() */
X               if(user == NULL)
X               {
X                    if(option.fork && procn==0)
X                         suicide(CHILD);
X               }
X               else if(separate(&host, fn, user, umbilicus) < 0)
X                    if(option.fork)
X                         suicide(CHILD);
X               
X               if(option.fork)
X               {
X                    close(process[umb_proc].pipe[1]);
X                    _exit(nofpeople);
X               }
X          }
X          
X          /*
X           *  The parent.
X           */
X          
X          if(option.fork)
X          {
X               process[nproc].pid=procn;
X               process[nproc].ret_val=0;
X               close(process[nproc].pipe[1]);
X          }
X          nproc++;
X          curnproc++;
X     }
X     signal(SIGINT, abrt);  /* from SIG_IGN */
X     signal(SIGHUP, abrt);
X
X     fclose(dat);
X     
X     if(option.fork)
X     {
X          /*
X           * Collect the results from all of the children, while awaiting
X           * their deaths
X           */
X          nofpeople=0;
X          if(nproc)
X          {
X               for(i=0;i<nproc;i++)
X               {
X                    if( process[i].ret_val  && option.verbose>1)
X                    {
X                         printf("%d Already waited for process %d\n",
X                                mypid,process[i].pid);
X                    }
X               }
X               while((dead_pid=wait((UNION_WAIT *)&st))>0)
X               {
X                    for(i=0;i<nproc;i++)
X                    {
X                         if(process[i].pid==dead_pid)
X                         {
X                              if( (st>>8)>0 )
X                              {
X                                   while(
X                                         (siz=read(process[i].pipe[0],
X                                                   (void *)&buf,
X                                                   sizeof(buf))) > 0)
X                                        if(option.watch)
X                                        {
X                                             add_to_new_list((struct User *)&buf);
X                                        }
X                                        else
X                                        {
X                                             fprintf(outp,"%s",buf.line);
X/*                                       fwrite(buf,sizeof(char),siz,outp); */
X                                             fflush(outp);
X                                        }
X                              
X                              }
X                              nofpeople += (st >> 8);
X                              close(process[i].pipe[0]);
X                         }
X                    }
X               }
X          }
X     }
X     free(process); /* XXX */
X     if(option.watch)
X     {
X          difference();
X     }
X     if(nofpeople < 1 && option.fxfmt == 0 && option.watch==0)
X     {
X          if(nusr==0)
X               fputs("No one is logged in.\n",outp);
X          else if(nusr==1)
X          {
X               fprintf(outp,"%s is not logged in.\n",wusr);
X          }
X          else
X               fputs("They are not logged in.\n",outp);
X          fputs("Have a Nice Day.\n",outp);
X     }
X     if(option.footer)
X          fputc('\n',outp);
X     
X     if(tmp[2].name[0]!='\0' && !option.watch)
X          unlink(tmp[2].name);
X
X     /* BIG kluge -- should find out why these are still open. */
X     for(i=3;i<
X#ifdef HAVE_GETDTABLESIZE
X         getdtablesize()
X#else /* HAVE_GETDTABLESIZE */
X# ifdef OPEN_MAX
X         OPEN_MAX
X# else /* OPEN_MAX */
X         20
X# endif /* !defined OPEN_MAX */
X#endif /* !defined HAVE_GETDTABLESIZE */
X         ;i++)
X          close(i);
X
X     return 0;
X}
END_OF_FILE
if test 29990 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
fi
# end of 'main.c'
fi
echo shar: End of archive 3 \(of 3\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
