Newsgroups: comp.sources.unix
From: pmiller@bmr.gov.au (Peter Miller)
Subject: v28i108: cook - a file construction tool, V1.6, Part15/19
References: <1.775008949.28543@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: pmiller@bmr.gov.au (Peter Miller)
Posting-Number: Volume 28, Issue 108
Archive-Name: cook-1.6/part15

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 15 (of 19)."
# Contents:  cook/archive.c cook/lex.c cooktime/date.y
# Wrapped by vixie@gw.home.vix.com on Sat Jul 23 17:11:28 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'cook/archive.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/archive.c'\"
else
echo shar: Extracting \"'cook/archive.c'\" \(28331 characters\)
sed "s/^X//" >'cook/archive.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate archive files
X */
X
X#include <ctype.h>
X#include <stdio.h>
X#include <errno.h>
X#include <ac/ar.h>
X#include <ac/fcntl.h>
X#include <ac/stdlib.h>
X#include <ac/string.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <utime.h>
X#include <ac/unistd.h>
X
X#include <archive.h>
X#include <error.h>
X#include <fp.h>
X#include <mem.h>
X#include <trace.h>
X
X
Xstruct archive_file_ty;
X
Xtypedef struct method_ty method_ty;
Xstruct method_ty
X{
X	size_t	header_size;
X	int (*magic)_((struct archive_file_ty *));
X	int (*advance)_((struct archive_file_ty *));
X	int (*name_compare)_((struct archive_file_ty *, string_ty *));
X	int (*stat)_((struct archive_file_ty *, struct stat *));
X	int (*utime)_((struct archive_file_ty *, struct utimbuf *));
X	void (*close)_((struct archive_file_ty *));
X};
X
Xtypedef struct archive_file_ty archive_file_ty;
Xstruct archive_file_ty
X{
X	method_ty	*method;
X	int		fd;
X	long		start;
X	long		finish;
X	long		current;
X	void		*header;
X	size_t		header_size;
X	long		data;
X	long		size;
X	long		next;
X	char		*name_map;
X	long		name_map_len;
X};
X
X
X#ifndef AIAMAG
X
X
Xstatic int look_for_name_map _((archive_file_ty *, char *, size_t));
X
Xstatic int
Xlook_for_name_map(afp, name, len)
X	archive_file_ty	*afp;
X	char		*name;
X	size_t		len;
X{
X	int		nbytes;
X	char		*cp;
X	char		*ep;
X
X	if (afp->name_map)
X		return 0;
X	if
X	(
X		memcmp(name, "//", 2)
X	&&
X		memcmp(name, "ARFILENAMES/", 12)
X	)
X		return 0;
X	
X	/*
X	 * read the data
X	 */
X	afp->name_map_len = afp->size;
X	afp->name_map = mem_alloc(afp->size);
X	if (lseek(afp->fd, afp->data, SEEK_SET) == -1)
X		return -1;
X	nbytes = read(afp->fd, afp->name_map, afp->size);
X	if (nbytes < 0)
X		return -1;
X	if (nbytes != afp->size)
X	{
X		errno = EINVAL;
X		return -1;
X	}
X
X	/*
X	 * The names are terminated by newlines.
X	 * Replace the newlines wil NULs.
X	 */
X	ep = afp->name_map + afp->name_map_len;
X	for (cp = afp->name_map; cp < ep; ++cp)
X		if (*cp == '\n')
X			*cp = 0;
X	return 1;
X}
X
X
Xstatic int grope_name _((archive_file_ty *, char *, size_t, char **, size_t *,
X	int *));
X
Xstatic int
Xgrope_name(afp, hnam, hnamlen, name_p, len_p, trunc_p)
X	archive_file_ty	*afp;
X	char		*hnam;
X	size_t		hnamlen;
X	char		**name_p;
X	size_t		*len_p;
X	int		*trunc_p;
X{
X	char		*ep;
X
X	/*
X	 * see if it is in the name map
X	 */
X	if
X	(
X		afp->name_map
X	&&
X		(hnam[0] == ' ' || hnam[0] == '/')
X	&&
X		isdigit(hnam[1])
X	)
X	{
X		size_t		offset;
X
X		offset = atoi(hnam + 1);
X		if (offset >= afp->name_map_len)
X		{
X			errno = EINVAL;
X			return -1;
X		}
X		*name_p = afp->name_map + offset;
X		*len_p = strlen(*name_p);
X		*trunc_p = 0;
X		return 0;
X	}
X
X	/*
X	 * see of the name follows the header
X	 */
X	if (!memcmp(hnam, "#1/", 3) && isdigit(hnam[3]))
X	{
X		static char	*buf;
X		static size_t	bufmax;
X		size_t		buflen;
X		int		nbytes;
X
X		buflen = atoi(hnam + 3);
X		if (buflen > bufmax)
X		{
X			bufmax = buflen;
X			buf = mem_change_size(buf, bufmax);
X		}
X		nbytes = read(afp->fd, buf, buflen);
X		if (nbytes < 0)
X			return -1;
X		if (nbytes != nbytes)
X		{
X			errno = EINVAL;
X			return -1;
X		}
X		*name_p = buf;
X		*len_p = buflen;
X		*trunc_p = 0;
X
X		/*
X		 * adjust data address
X		 */
X		afp->data += nbytes;
X		afp->next = afp->data + afp->size;
X		if (afp->next & 1)
X			afp->next++;
X		return 0;
X	}
X
X	/*
X	 * see if there is a '/' terminator
X	 */
X	ep = memchr(hnam, '/', hnamlen);
X	if (ep)
X	{
X		*name_p = hnam;
X		*len_p = ep - hnam;
X		*trunc_p = (*len_p >= hnamlen - 2);
X		return 0;
X	}
X
X	/*
X	 * see if there is a ' ' terminator
X	 */
X	ep = memchr(hnam, ' ', hnamlen);
X	if (ep)
X	{
X		*name_p = hnam;
X		*len_p = ep - hnam;
X		*trunc_p = 0;
X		return 0;
X	}
X
X	/*
X	 * no terminator found,
X	 * length is whole field,
X	 * need to truncate
X	 */
X	*name_p = hnam;
X	*len_p = hnamlen;
X	*trunc_p = 1;
X	return 0;
X}
X
X
Xstatic int cmp_grope_name _((archive_file_ty *, string_ty *, char *, size_t));
X
Xstatic int
Xcmp_grope_name(afp, member, hnam, hnamlen)
X	archive_file_ty	*afp;
X	string_ty	*member;
X	char		*hnam;
X	size_t		hnamlen;
X{
X	char		*name;
X	size_t		len;
X	int		trunc;
X	int		flag;
X
X	flag = look_for_name_map(afp, hnam, hnamlen);
X	if (flag < 0)
X		return -1;
X	if (flag)
X		return 0;
X	if (grope_name(afp, hnam, hnamlen, &name, &len, &trunc))
X		return -1;
X
X	return
X	(
X		(trunc ? member->str_length >= len : member->str_length == len)
X	&&
X		!memcmp(member->str_text, name, len)
X	);
X}
X
X#endif /* !AIAMAG */
X#if (defined(SARMAG) && !PORT5AR) || defined(AIAMAG)
X
Xstatic long number _((char *, size_t len));
X
Xstatic long
Xnumber(s, len)
X	char		*s;
X	size_t		len;
X{
X	int		ndigits;
X	long		n;
X
X	while (len > 0 && isspace(*s))
X	{
X		--len;
X		++s;
X	}
X	ndigits = 0;
X	n = 0;
X	while (len > 0 && isdigit(*s))
X	{
X		n = n * 10 + *s - '0';
X		--len;
X		++s;
X		++ndigits;
X	}
X	if (!ndigits)
X		return -1;
X	while (len > 0 && isspace(*s))
X	{
X		--len;
X		++s;
X	}
X	if (len && *s)
X		return -1;
X	return n;
X}
X
X
Xstatic long octal _((char *, size_t len));
X
Xstatic long
Xoctal(s, len)
X	char		*s;
X	size_t		len;
X{
X	int		ndigits;
X	long		n;
X
X	while (len > 0 && isspace(*s))
X	{
X		--len;
X		++s;
X	}
X	ndigits = 0;
X	n = 0;
X	while (len > 0 && isdigit(*s) && *s != '8' && *s != '9')
X	{
X		n = n * 8 + *s - '0';
X		--len;
X		++s;
X		++ndigits;
X	}
X	if (!ndigits)
X		return -1;
X	while (len > 0 && isspace(*s))
X	{
X		--len;
X		++s;
X	}
X	if (len && *s)
X		return -1;
X	return n;
X}
X
X
Xstatic void numset _((char *, size_t, long));
X
Xstatic void
Xnumset(s, len, n)
X	char		*s;
X	size_t		len;
X	long		n;
X{
X	sprintf(s, "%ld", n);
X	while (len > 0 && *s)
X	{
X		++s;
X		--len;
X	}
X	while (len > 0)
X	{
X		*s++ = ' ';
X		--len;
X	}
X}
X
X
X#endif /* SARMAG || AIAMAG */
X#if PORT5AR
X
Xstatic int port5_magic _((archive_file_ty *));
X
Xstatic int
Xport5_magic(afp)
X	archive_file_ty	*afp;
X{
X	int		nbytes;
X	struct ar_hdr	magic;
X
X	nbytes = read(afp->fd, &magic, sizeof(magic));
X	if (nbytes < 0)
X		return -1;
X	if (nbytes != sizeof(magic) || memcmp(magic.ar_magic, ARMAG, SARMAG))
X	{
X		errno = EINVAL;
X		return -1;
X	}
X	afp->start = sizeof(magic);
X	return 0;
X}
X
X
Xstatic long b4r _((char *));
X
Xstatic long
Xb4r(cp)
X	char		*cp;
X{
X	return
X	(
X		((long)(unsigned char)cp[0] << 24)
X	||
X		((long)(unsigned char)cp[1] << 16)
X	||
X		((unsigned char)cp[2] << 8)
X	||
X		(unsigned char)cp[3]
X	);
X}
X
X
Xstatic void b4w _((char *, long));
X
Xstatic void
Xb4w(cp, n)
X	char		*cp;
X	long		n;
X{
X	cp[0] = n >> 24;
X	cp[1] = n >> 16;
X	cp[2] = n >> 8;
X	cp[3] = n;
X}
X
X
Xstatic int port5_advance _((archive_file_ty *));
X
Xstatic int
Xport5_advance(afp)
X	archive_file_ty	*afp;
X{
X	int		nbytes;
X	struct arf_hdr	*h;
X
X	h = afp->header;
X	assert(h);
X	nbytes = read(afp->fd, h, sizeof(*h));
X	if (nbytes < 0)
X		return -1;
X	if (nbytes == 0)
X	{
X		errno = ENOENT;
X		return -1;
X	}
X	if (nbytes != sizeof(*h))
X	{
X		broken:
X		errno = EINVAL;
X		return -1;
X	}
X
X	afp->size = b4r(h->arf_size);
X	if (afp->size < 0)
X		goto broken;
X	afp->data = afp->current + sizeof(*h);
X	afp->next = afp->data + afp->size;
X	if (afp->size & 1)
X		afp->next++;
X	return 0;
X}
X
X
Xstatic int port5_name_compare _((archive_file_ty *, string_ty *));
X
Xstatic int
Xport5_name_compare(afp, name)
X	archive_file_ty	*afp;
X	string_ty	*name;
X{
X	struct arf_hdr	*h;
X
X	h = afp->header;
X	assert(h);
X	return cmp_grope_name(afp, name, h->arf_name, sizeof(h->arf_name));
X}
X
X
Xstatic int port5_stat _((archive_file_ty *, struct stat *));
X
Xstatic int
Xport5_stat(afp, st)
X	archive_file_ty	*afp;
X	struct stat	*st;
X{
X	struct arf_hdr	*h;
X
X	h = afp->header;
X	assert(h);
X	st->st_mtime = b4r(h->arf_date);
X	st->st_atime = st->st_mtime;
X	st->st_ctime = st->st_mtime;
X	st->st_uid = b4r(h->arf_uid);
X	st->st_gid = b4r(h->arf_gid);
X	st->st_mode = b4r(h->arf_mode);
X	st->st_size = afp->size;
X	return 0;
X}
X
X
Xstatic int port5_utime _((archive_file_ty *, struct utimbuf *));
X
Xstatic int
Xport5_utime(afp, ut)
X	archive_file_ty	*afp;
X	struct utimbuf	*ut;
X{
X	struct arf_hdr	*h;
X	int		nbytes;
X	struct ar_hdr	fh;
X	struct stat	st;
X
X	/*
X	 * set this file entry
X	 */
X	h = afp->header;
X	assert(h);
X	b4w(h->arf_date, ut->modtime);
X	assert(b4r(h->arf_date) == ut->modtime);
X	nbytes = write(afp->fd, h, sizeof(*h));
X	if (nbytes < 0)
X		return -1;
X	if (nbytes != sizeof(*h))
X	{
X		errno = EIO;
X		return -1;
X	}
X
X	/*
X	 * must also set the file header
X	 */
X	if (fstat(afp->fd, &st))
X		return -1;
X	if (lseek(afp->fd, 0L, SEEK_SET) == -1)
X		return -1;
X	nbytes = read(afp->fd, &fh, sizeof(fh));
X	if (nbytes < 0)
X		return -1;
X	if (nbytes != sizeof(fh))
X	{
X		errno = EIO;
X		return -1;
X	}
X	b4w(fh.ar_date, st.st_mtime);
X	if (lseek(afp->fd, 0L, SEEK_SET) == -1)
X		return -1;
X	nbytes = write(afp->fd, &fh, sizeof(fh));
X	if (nbytes < 0)
X		return -1;
X	if (nbytes != sizeof(fh))
X	{
X		errno = EIO;
X		return -1;
X	}
X
X	/*
X	 * done
X	 */
X	return 0;
X}
X
X
Xstatic method_ty port5 =
X{
X	sizeof(struct arf_hdr),
X	port5_magic,
X	port5_advance,
X	port5_name_compare,
X	port5_stat,
X	port5_utime,
X	0, /* close */
X};
X
X#endif /* PORT5AR */
X#if defined(SARMAG) && !PORT5AR
X
Xstatic int standard_magic _((archive_file_ty *));
X
Xstatic int
Xstandard_magic(afp)
X	archive_file_ty	*afp;
X{
X	int		nbytes;
X	char		magic[SARMAG];
X
X	nbytes = read(afp->fd, magic, sizeof(magic));
X	if (nbytes < 0)
X		return -1;
X	if (nbytes != sizeof(magic) || memcmp(magic, ARMAG, sizeof(magic)))
X	{
X		errno = EINVAL;
X		return -1;
X	}
X	afp->start = sizeof(magic);
X	return 0;
X}
X
X
Xstatic int standard_advance _((archive_file_ty *));
X
Xstatic int
Xstandard_advance(afp)
X	archive_file_ty	*afp;
X{
X	int		nbytes;
X	struct ar_hdr	*h;
X
X	h = afp->header;
X	assert(h);
X	nbytes = read(afp->fd, h, sizeof(*h));
X	if (nbytes < 0)
X		return -1;
X	if (nbytes == 0)
X	{
X		errno = ENOENT;
X		return -1;
X	}
X	if (nbytes != sizeof(*h))
X	{
X		broken:
X		errno = EINVAL;
X		return -1;
X	}
X#ifdef ARFMAG
X	if (memcmp(h->ar_fmag, ARFMAG, sizeof(h->ar_fmag)))
X		goto broken;
X#endif
X
X	afp->size = number(h->ar_size, sizeof(h->ar_size));
X	if (afp->size < 0)
X		goto broken;
X	afp->data = afp->current + sizeof(*h);
X	afp->next = afp->data + afp->size;
X	if (afp->next & 1)
X		afp->next++;
X	return 0;
X}
X
X
Xstatic int standard_name_compare _((archive_file_ty *, string_ty *));
X
Xstatic int
Xstandard_name_compare(afp, name)
X	archive_file_ty	*afp;
X	string_ty	*name;
X{
X	struct ar_hdr	*h;
X
X	h = afp->header;
X	assert(h);
X	return cmp_grope_name(afp, name, h->ar_name, sizeof(h->ar_name));
X}
X
X
Xstatic int standard_stat _((archive_file_ty *, struct stat *));
X
Xstatic int
Xstandard_stat(afp, st)
X	archive_file_ty	*afp;
X	struct stat	*st;
X{
X	struct ar_hdr	*h;
X	long		value;
X
X	h = afp->header;
X	assert(h);
X	value = number(h->ar_date, sizeof(h->ar_date));
X	if (value < 0)
X	{
X		broken:
X		errno = EINVAL;
X		return -1;
X	}
X	st->st_mtime = value;
X	st->st_atime = value;
X	st->st_ctime = value;
X
X	value = number(h->ar_uid, sizeof(h->ar_uid));
X	if (value < 0)
X		goto broken;
X	st->st_uid = value;
X
X	value = octal(h->ar_mode, sizeof(h->ar_mode));
X	if (value < 0)
X		goto broken;
X	st->st_mode = value;
X
X	st->st_size = afp->size;
X	return 0;
X}
X
X
Xstatic int standard_utime _((archive_file_ty *, struct utimbuf *));
X
Xstatic int
Xstandard_utime(afp, ut)
X	archive_file_ty	*afp;
X	struct utimbuf	*ut;
X{
X	struct ar_hdr	*h;
X	int		nbytes;
X
X	h = afp->header;
X	assert(h);
X	numset(h->ar_date, sizeof(h->ar_date), ut->modtime);
X	assert(number(h->ar_date, sizeof(h->ar_date)) == ut->modtime);
X	nbytes = write(afp->fd, h, sizeof(*h));
X	if (nbytes < 0)
X		return -1;
X	if (nbytes != sizeof(*h))
X	{
X		errno = EIO;
X		return -1;
X	}
X	return 0;
X}
X
X
Xstatic method_ty standard =
X{
X	sizeof(struct ar_hdr),
X	standard_magic,
X	standard_advance,
X	standard_name_compare,
X	standard_stat,
X	standard_utime,
X	0, /* close */
X};
X
X#endif /* SARMAG && !PORT5AR */
X#ifdef AIAMAG
X
Xstatic int ai_magic _((archive_file_ty *));
X
Xstatic int
Xai_magic(afp)
X	archive_file_ty	*afp;
X{
X	FL_HDR		fh;
X	int		nbytes;
X
X	nbytes = read(afp->fd, &fh, FL_HSZ);
X	if (nbytes != FL_HSZ || memcmp(fh.fl_magic, AIAMAG, SAIAMAG))
X	{
X		broken:
X		errno = EINVAL;
X		return -1;
X	}
X	afp->start = number(fh.fl_fstmoff, sizeof(fh.fl_fstmoff));
X	if (afp->start < 0)
X		goto broken;
X	afp->finish = number(fh.fl_lstmoff, sizeof(fh.fl_fstmoff));
X	if (afp->start < 0)
X		goto broken;
X	return 0;
X}
X
X
Xstatic int ai_advance _((archive_file_ty *));
X
Xstatic int
Xai_advance(afp)
X	archive_file_ty	*afp;
X{
X	int		nbytes;
X	struct ar_hdr	*h;
X	int		h_len;
X	char		*name;
X	int		name_len;
X
X	if (afp->current == afp->finish)
X	{
X		errno = ENOENT;
X		return -1;
X	}
X
X	h = afp->header;
X	assert(h);
X	name = (char *)(h + 1);
X
X	h_len = AR_HDR_SIZE - sizeof(h->_ar_name);
X	nbytes = read(afp->fd, h, h_len);
X	if (nbytes < 0)
X		return -1;
X	/* end of file not valid here */
X	if (nbytes != h_len)
X	{
X		broken:
X		errno = EINVAL;
X		return -1;
X	}
X	name_len = number(h->ar_namlen, sizeof(h->ar_namlen));
X	if (name_len < 0 || name_len > 255)
X		goto broken;
X
X	nbytes = read(afp->fd, name, name_len);
X	if (nbytes < 0)
X		return -1;
X	if (nbytes != name_len)
X		goto broken;
X	name[name_len] = 0;
X
X	afp->data = afp->current + h_len + name_len + 2;
X	if (afp->data & 1)
X		afp->data++;
X	afp->size = number(h->ar_size, sizeof(h->ar_size));
X	if (afp->size < 0)
X		goto broken;
X	afp->next = number(h->ar_nxtmem, sizeof(h->ar_nxtmem));
X	if (afp->next < 0)
X		goto broken;
X	return 0;
X}
X
X
Xstatic int ai_name_compare _((archive_file_ty *, string_ty *));
X
Xstatic int
Xai_name_compare(afp, member)
X	archive_file_ty	*afp;
X	string_ty	*member;
X{
X	struct ar_hdr	*h;
X	char		*name;
X
X	h = afp->header;
X	assert(h);
X	name = (char *)(h + 1);
X	return !strcmp(member->str_text, name);
X}
X
X
Xstatic int ai_stat _((archive_file_ty *, struct stat *));
X
Xstatic int
Xai_stat(afp, st)
X	archive_file_ty	*afp;
X	struct stat	*st;
X{
X	struct ar_hdr	*h;
X	long		value;
X
X	h = afp->header;
X	assert(h);
X	value = number(h->ar_date, sizeof(h->ar_date));
X	if (value < 0)
X	{
X		broken:
X		errno = EINVAL;
X		return -1;
X	}
X	st->st_mtime = value;
X	st->st_atime = value;
X	st->st_ctime = value;
X
X	value = number(h->ar_uid, sizeof(h->ar_uid));
X	if (value < 0)
X		goto broken;
X	st->st_uid = value;
X
X	value = number(h->ar_gid, sizeof(h->ar_gid));
X	if (value < 0)
X		goto broken;
X	st->st_gid = value;
X
X	value = octal(h->ar_mode, sizeof(h->ar_mode));
X	if (value < 0)
X		goto broken;
X	st->st_mode = value;
X	st->st_size = afp->size;
X	return 0;
X}
X
X
Xstatic int ai_utime _((archive_file_ty *, struct utimbuf *));
X
Xstatic int
Xai_utime(afp, ut)
X	archive_file_ty	*afp;
X	struct utimbuf	*ut;
X{
X	struct ar_hdr	*h;
X	int		h_len;
X	int		nbytes;
X	struct stat	st;
X	FL_HDR		fh;
X
X	h = afp->header;
X	assert(h);
X	numset(h->ar_date, sizeof(h->ar_date), ut->modtime);
X	h_len = AR_HDR_SIZE - sizeof(h->_ar_name);
X	nbytes = write(afp->fd, h, h_len);
X	if (nbytes < 0)
X		return -1;
X	if (nbytes != h_len)
X	{
X		errno = EIO;
X		return -1;
X	}
X
X	/*
X	 * must also set the file header
X	 */
X	if (fstat(afp->fd, &st))
X		return -1;
X	if (lseek(afp->fd, 0L, SEEK_SET) == -1)
X		return -1;
X	nbytes = read(afp->fd, &fh, AR_HDR_SIZE);
X	if (nbytes < 0)
X		return -1;
X	if (nbytes != AR_HDR_SIZE)
X	{
X		errno = EIO;
X		return -1;
X	}
X	numset(fh.fl_date, sizeof(fh.fl_date), st.st_mtime);
X	if (lseek(afp->fd, 0L, SEEK_SET) == -1)
X		return -1;
X	nbytes = write(afp->fd, &fh, AR_HDR_SIZE);
X	if (nbytes < 0)
X		return -1;
X	if (nbytes != AR_HDR_SIZE)
X	{
X		errno = EIO;
X		return -1;
X	}
X
X	/*
X	 * success
X	 */
X	return 0;
X}
X
X
Xstatic method_ty ai =
X{
X	sizeof(struct ar_hdr) + 256,
X	ai_magic,
X	ai_advance,
X	ai_name_compare,
X	ai_stat,
X	ai_utime,
X	0, /* close */
X};
X
X#endif /* AIAMAG */
X#if defined(ARMAG) && !defined(SARMAG)
X
Xstatic int old_magic _((archive_file_ty *));
X
Xstatic int
Xold_magic(afp)
X	archive_file_ty	*afp;
X{
X#ifndef M_XENIX
X	int		magic;
X#else
X	unsigned short	magic;
X#endif
X	int		nbytes;
X
X	nbytes = read(afp->fd, &magic, sizeof(magic));
X	if (nbytes < 0)
X		return -1;
X	if (nbytes != sizeof(magic) || magic != ARMAG)
X	{
X		errno = EINVAL;
X		return -1;
X	}
X	afp->start = sizeof(magic);
X	return 0;
X}
X
X
Xstatic int old_advance _((archive_file_ty *));
X
Xstatic int
Xold_advance(afp)
X	archive_file_ty	*afp;
X{
X	struct ar_hdr	*h;
X	int		nbytes;
X
X	h = afp->header;
X	assert(h);
X	nbytes = read(afp->fd, h, sizeof(*h));
X	if (nbytes < 0)
X		return -1;
X	if (!nbytes)
X	{
X		errno = ENOENT;
X		return -1;
X	}
X	if (nbytes != sizeof(*h))
X	{
X		errno = EINVAL;
X		return -1;
X	}
X
X	/*
X	 * figure a few things
X	 */
X	afp->size = h->ar_size;
X	afp->data = afp->current + sizeof(*h);
X	afp->next = afp->data + afp->size;
X	if (afp->next & 1)
X		afp->next++;
X
X	/*
X	 * success
X	 */
X	return 0;
X}
X
X
Xstatic int old_name_compare _((archive_file_ty *, string_ty *));
X
Xstatic int
Xold_name_compare(afp, name)
X	archive_file_ty	*afp;
X	string_ty	*name;
X{
X	struct ar_hdr	*h;
X
X	h = afp->header;
X	assert(h);
X	return cmp_grope_name(afp, name, h->ar_name, sizeof(h->ar_name));
X}
X
X
Xstatic int old_stat _((archive_file_ty *, struct stat *));
X
Xstatic int
Xold_stat(afp, st)
X	archive_file_ty	*afp;
X	struct stat	*st;
X{
X	struct ar_hdr	*h;
X
X	h = afp->header;
X	assert(h);
X	st->st_atime = h->ar_date;
X	st->st_ctime = h->ar_date;
X	st->st_gid = h->ar_gid;
X	st->st_mode = h->ar_mode;
X	st->st_mtime = h->ar_date;
X	st->st_uid = h->ar_uid;
X	return 0;
X}
X
X
Xstatic int old_utime _((archive_file_ty *, struct utimbuf *));
X
Xstatic int
Xold_utime(afp, ut)
X	archive_file_ty	*afp;
X	struct utimbuf	*ut;
X{
X	struct ar_hdr	*h;
X	int		nbytes;
X
X	h = afp->header;
X	assert(h);
X	h->ar_date = ut->modtime;
X	nbytes = write(afp->fd, h, sizeof(*h));
X	if (nbytes < 0)
X		return -1;
X	if (nbytes != sizeof(*h))
X	{
X		errno = EIO;
X		return -1;
X	}
X	return 0;
X}
X
X
Xstatic method_ty old =
X{
X	sizeof(struct ar_hdr),
X	old_magic,
X	old_advance,
X	old_name_compare,
X	old_stat,
X	old_utime,
X	0, /* close */
X};
X
X#endif /* !SARMAG && !AIAMAG */
X
X
X/*
X * This is a table of all archive formats understood
X * by the <ar.h> system include file.
X */
Xstatic method_ty *table[] =
X{
X#if PORT5AR
X	&port5,
X#endif
X#if defined(SARMAG) && !PORT5AR
X	&standard,
X#endif
X#ifdef AIAMAG
X	&ai,
X#endif
X#if defined(ARMAG) && !defined(SARMAG)
X	&old,
X#endif
X	0
X};
X
Xstatic archive_file_ty *archive_file_open _((string_ty *, int));
X
Xstatic archive_file_ty *
Xarchive_file_open(path, mode)
X	string_ty	*path;
X	int		mode;
X{
X	int		fd;
X	int		err;
X	int		j;
X	archive_file_ty	*afp;
X
X	/*
X	 * open the file as specified
X	 */
X	trace(("archive_file_open(path = \"%s\", mode = %d)\n{\n"/*}*/, path->str_text, mode));
X	assert(mode == O_RDONLY || mode == O_RDWR);
X	trace(("open\n"));
X	fd = open(path->str_text, mode, 0666);
X	if (fd < 0)
X	{
X		afp = 0;
X		goto done;
X	}
X
X	trace(("alloc\n"));
X	afp = mem_alloc(sizeof(archive_file_ty));
X	afp->fd = fd;
X	afp->start = 0;
X	afp->finish = 0;
X	afp->current = 0;
X	afp->next = 0;
X	afp->header = 0;
X	afp->header_size = 0;
X	afp->name_map = 0;
X	afp->name_map_len = 0;
X
X	/*
X	 * see if we can understand this format
X	 */
X	for (j = 0; table[j]; ++j)
X	{
X		if (!table[j])
X		{
X			errno = EINVAL;
X			bomb:
X			err = errno;
X			close(afp->fd);
X			if (afp->header)
X				mem_free(afp->header);
X			mem_free(afp);
X			errno = err;
X			afp = 0;
X			goto done;
X		}
X		if (lseek(afp->fd, 0L, SEEK_SET) == -1)
X			goto bomb;
X		afp->method = table[j];
X		if (afp->method->header_size > afp->header_size)
X		{
X			afp->header_size = afp->method->header_size;
X			afp->header =
X				mem_change_size(afp->header, afp->header_size);
X		}
X		err = afp->method->magic(afp);
X		if (!err)
X			break;
X		if (err != EINVAL)
X			goto bomb;
X	}
X
X	/*
X	 * here for all exits
X	 */
X	done:
X	trace(("return %08lX; /* errno = %s */\n", (long)afp, strerror(errno)));
X	trace((/*{*/"}\n"));
X	return afp;
X}
X
X
Xstatic int archive_file_close _((archive_file_ty *));
X
Xstatic int
Xarchive_file_close(afp)
X	archive_file_ty	*afp;
X{
X	int		err;
X
X	trace(("archive_file_close(afp = %08lX)\n{\n"/*}*/, (long)afp));
X	if (afp->method->close)
X		afp->method->close(afp);
X	if (afp->header)
X		mem_free(afp->header);
X	if (afp->name_map)
X		mem_free(afp->name_map);
X	err = close(afp->fd);
X	mem_free(afp);
X	trace(("return %d;\n", err));
X	trace((/*{*/"}\n"));
X	return err;
X}
X
X
Xstatic int archive_file_stat _((archive_file_ty *, string_ty *, struct stat *));
X
Xstatic int
Xarchive_file_stat(afp, member, st)
X	archive_file_ty	*afp;
X	string_ty	*member;
X	struct stat	*st;
X{
X	int		result;
X	int		flag;
X
X	/*
X	 * walk each entry
X	 */
X	trace(("archive_file_stat(afp = %08lX, member = \"%s\")\n{\n"/*}*/,
X		(long)afp, member->str_text));
X	result = -1;
X	afp->current = afp->start;
X	for (;;)
X	{
X		/*
X		 * read the next entry in the archive
X		 */
X		if (lseek(afp->fd, afp->current, SEEK_SET) == -1)
X			goto done;
X		if (afp->method->advance(afp))
X			goto done;
X			
X		/*
X		 * see if it is the one we want
X		 */
X		flag = afp->method->name_compare(afp, member);
X		if (flag < 0)
X			goto done;
X		if (flag)
X			break;
X
X		/*
X		 * advance to next entry
X		 */
X		afp->current = afp->next;
X	}
X
X	/*
X	 * set the file stats
X	 */
X	trace(("found\n"));
X	memset(st, 0, sizeof(*st));
X	if (afp->method->stat(afp, st))
X		goto done;
X
X	/*
X	 * Because archive members are given the exact same mtime as
X	 * the input file, adjust this forward 1 second, so that the
X	 * archive member looks "younger" than the input file.
X	 */
X	st->st_mtime++;
X	trace(("mtime = %ld;\n", st->st_mtime));
X	result = 0;
X
X	/*
X	 * here for all exits
X	 */
X	done:
X	trace(("return %d;\n", result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
Xstatic int archive_file_utime _((archive_file_ty *, string_ty *,
X	struct utimbuf *));
X
Xstatic int
Xarchive_file_utime(afp, member, utp)
X	archive_file_ty	*afp;
X	string_ty	*member;
X	struct utimbuf	*utp;
X{
X	int		result;
X	int		flag;
X	struct utimbuf	ut;
X
X	/*
X	 * Because archive members are given the exact same mtime as
X	 * the input file, adjust this forward 1 second, so that the
X	 * archive member looks "younger" than the input file.
X	 */
X	trace(("archive_file_utime(afp = %08lX, member = \"%s\")\n{\n"/*}*/,
X		(long)afp, member->str_text));
X	ut.modtime = utp->modtime - 1;
X	ut.actime = utp->actime;
X
X	/*
X	 * walk each entry
X	 */
X	result = -1;
X	afp->current = afp->start;
X	for (;;)
X	{
X		/*
X		 * read the next entry in the archive
X		 */
X		if (lseek(afp->fd, afp->current, SEEK_SET) == -1)
X			goto done;
X		if (afp->method->advance(afp))
X			goto done;
X
X		/*
X		 * find the length of the member name
X		 */
X		flag = afp->method->name_compare(afp, member);
X		if (flag < 0)
X			goto done;
X		if (flag)
X			break;
X
X		/*
X		 * advance to next entry
X		 */
X		afp->current = afp->next;
X	}
X
X	/*
X	 * set the date in the header
X	 * and write it back
X	 */
X	if (lseek(afp->fd, afp->current, SEEK_SET) == -1)
X		goto done;
X	if (afp->method->utime(afp, &ut))
X		goto done;
X	result = 0;
X
X	/*
X	 * here for all exits
X	 */
X	done:
X	trace(("return %d;\n", result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
Xstatic int archive_file_fingerprint _((archive_file_ty *, string_ty *,
X	fingerprint_ty *, char *));
X
Xstatic int
Xarchive_file_fingerprint(afp, member, fp, buf)
X	archive_file_ty	*afp;
X	string_ty	*member;
X	fingerprint_ty	*fp;
X	char		*buf;
X{
X	int		result;
X	int		flag;
X	long		size;
X
X	/*
X	 * walk each entry
X	 */
X	trace(("archive_file_fngrprnt(afp = %08lX, member = \"%s\")\n{\n"/*}*/,
X		(long)afp, member->str_text));
X	result = -1;
X	afp->current = afp->start;
X	for (;;)
X	{
X		/*
X		 * read the next entry in the archive
X		 */
X		if (lseek(afp->fd, afp->current, SEEK_SET) == -1)
X			goto done;
X		if (afp->method->advance(afp))
X			goto done;
X
X		/*
X		 * is it the one we want
X		 */
X		flag = afp->method->name_compare(afp, member);
X		if (flag < 0)
X			goto done;
X		if (flag)
X			break;
X
X		/*
X		 * advance to next entry
X		 */
X		afp->current = afp->next;
X	}
X
X	/*
X	 * read this portion of the file
X	 * and generate the fingerprint
X	 */
X	size = afp->size;
X	if (lseek(afp->fd, afp->data, SEEK_SET) == -1)
X		goto done;
X	while (size > 0)
X	{
X		char	ibuf[1024];
X		int	len;
X		int	nbytes;
X
X		len = (size > sizeof(ibuf) ? sizeof(ibuf) : size);
X		nbytes = read(afp->fd, ibuf, len);
X		if (nbytes < 0)
X			goto done;
X		if (nbytes == 0)
X		{
X			errno = EINVAL;
X			goto done;
X		}
X		fingerprint_addn(fp, ibuf, nbytes);
X		size -= nbytes;
X	}
X	fingerprint_sum(fp, buf);
X	result = 0;
X
X	/*
X	 * here for all exits
X	 */
X	done:
X	trace(("return %d;\n", result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
Xstatic int archive_match _((string_ty *, string_ty **, string_ty **));
X
Xstatic int
Xarchive_match(name, path_p, member_p)
X	string_ty	*name;
X	string_ty	**path_p;
X	string_ty	**member_p;
X{
X	char		*s;
X	char		*p;
X	char		*mp;
X
X	s = name->str_text;
X	p = strchr(s, '('/*)*/);
X	if
X	(
X		!p
X	||
X		p == s
X	||
X		s[name->str_length - 1] != /*(*/')'
X	||
X		s[name->str_length - 2] == '/'
X	||
X		(p - s) == name->str_length - 2
X	)
X		return 0;
X	*path_p = str_n_from_c(s, p - s);
X	mp = strrchr(p, '/');
X	if (mp)
X		++mp;
X	else
X		mp = p + 1;
X	*member_p = str_n_from_c(mp, name->str_length - 1 - (mp - s));
X	return 1;
X}  
X
X
Xint
Xarchive_stat(name, st)
X	string_ty	*name;
X	struct stat	*st;
X{
X	string_ty	*path;
X	string_ty	*member;
X	archive_file_ty	*afp;
X	int		err;
X	int		result;
X
X	/*
X	 * extract path and member name
X	 */
X	trace(("archive_stat(name = \"%s\")\n{\n"/*}*/, name->str_text));
X	result = -1;
X	if (!archive_match(name, &path, &member))
X	{
X		/*
X		 * this gives the cleanest error handling
X		 * in cook/os.c and cook/stat.cache.c
X		 */
X		errno = ENOENT;
X		goto done;
X	}
X
X	/*
X	 * open the archive file
X	 */
X	trace(("open\n"));
X	afp = archive_file_open(path, O_RDONLY);
X	if (!afp)
X	{
X		str_free(member);
X		str_free(path);
X		goto done;
X	}
X
X	/*
X	 * read the relevant entry
X	 */
X	trace(("stat\n"));
X	if (archive_file_stat(afp, member, st))
X	{
X		err = errno;
X		archive_file_close(afp);
X		str_free(member);
X		str_free(path);
X		errno = err;
X		goto done;
X	}
X
X	/*
X	 * close the archive file
X	 */
X	trace(("close\n"));
X	str_free(member);
X	str_free(path);
X	if (archive_file_close(afp))
X		goto done;
X
X	/*
X	 * success
X	 */
X	trace(("success\n"));
X	result = 0;
X
X	/*
X	 * here for all exits
X	 */
X	done:
X	trace(("return %d; /* errno = %s */\n", result, strerror(errno)));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
Xint
Xarchive_utime(name, ut)
X	string_ty	*name;
X	struct utimbuf	*ut;
X{
X	string_ty	*path;
X	string_ty	*member;
X	archive_file_ty	*afp;
X	int		err;
X	int		result;
X
X	/*
X	 * extract path and member name
X	 */
X	trace(("archive_utime(name = \"%s\")\n{\n"/*}*/, name->str_text));
X	result = -1;
X	if (!archive_match(name, &path, &member))
X	{
X		/*
X		 * this gives the cleanest error handling
X		 * in cook/os.c and cook/stat.cache.c
X		 */
X		errno = ENOENT;
X		goto done;
X	}
X
X	/*
X	 * open the archive file
X	 */
X	afp = archive_file_open(path, O_RDWR);
X	if (!afp)
X	{
X		str_free(member);
X		str_free(path);
X		goto done;
X	}
X
X	/*
X	 * read the relevant entry
X	 */
X	if (archive_file_utime(afp, member, ut))
X	{
X		err = errno;
X		archive_file_close(afp);
X		str_free(member);
X		str_free(path);
X		errno = err;
X		goto done;
X	}
X
X	/*
X	 * close the archive file
X	 */
X	str_free(member);
X	str_free(path);
X	if (archive_file_close(afp))
X		goto done;
X
X	/*
X	 * success
X	 */
X	trace(("success\n"));
X	result = 0;
X
X	/*
X	 * here for all exits
X	 */
X	done:
X	trace(("return %d;\n", result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
Xint
Xarchive_fingerprint(fp, name, buf)
X	fingerprint_ty	*fp;
X	string_ty	*name;
X	char		*buf;
X{
X	string_ty	*path;
X	string_ty	*member;
X	archive_file_ty	*afp;
X	int		err;
X	int		result;
X
X	/*
X	 * extract path and member name
X	 */
X	trace(("archive_fingerprint(name = \"%s\")\n{\n"/*}*/, name->str_text));
X	result = -1;
X	if (!archive_match(name, &path, &member))
X	{
X		/*
X		 * this gives the cleanest error handling
X		 * in cook/os.c and cook/stat.cache.c
X		 */
X		errno = ENOENT;
X		goto done;
X	}
X
X	/*
X	 * open the archive file
X	 */
X	afp = archive_file_open(path, O_RDONLY);
X	if (!afp)
X	{
X		str_free(member);
X		str_free(path);
X		goto done;
X	}
X
X	/*
X	 * read the relevant entry
X	 */
X	if (archive_file_fingerprint(afp, member, fp, buf))
X	{
X		err = errno;
X		archive_file_close(afp);
X		str_free(member);
X		str_free(path);
X		errno = err;
X		goto done;
X	}
X
X	/*
X	 * close the archive file
X	 */
X	str_free(member);
X	str_free(path);
X	if (archive_file_close(afp))
X		goto done;
X
X	/*
X	 * success
X	 */
X	trace(("success\n"));
X	result = 0;
X
X	/*
X	 * here for all exits
X	 */
X	done:
X	trace(("return %d;\n", result));
X	trace((/*{*/"}\n"));
X	return result;
X}
END_OF_FILE
if test 28331 -ne `wc -c <'cook/archive.c'`; then
    echo shar: \"'cook/archive.c'\" unpacked with wrong size!
fi
# end of 'cook/archive.c'
fi
if test -f 'cook/lex.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/lex.c'\"
else
echo shar: Extracting \"'cook/lex.c'\" \(27982 characters\)
sed "s/^X//" >'cook/lex.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to perform lexical analysis on cookbooks
X *
X * This file contains the lexical analyser for the cookbook parser.
X * A known bug is that it processes # control lines even within comments.
X * Another bug is that comments vanish: they should be replaced by a single
X * space.
X */
X
X#include <ctype.h>
X#include <ac/stddef.h>
X#include <ac/string.h>
X#include <ac/stdlib.h>
X#include <stdio.h>
X
X#include <error.h>
X#include <expr.h>
X#include <hashline.h>
X#include <lex.h>
X#include <mem.h>
X#include <option.h>
X#include <s-v-arg.h>
X#include <stmt.h>
X#include <symtab.h>
X#include <trace.h>
X#include <word.h>
X#include <parse.gen.h>	/* must be last */
X#include <hashline.gen.h> /* must be last */
X
X
X/*
X * Meta types
X */
X#define NORMAL	1
X#define SLOSHED	2
X#define WHITE	3
X
X/*
X */
X#define BEFORE	(1<<0)
X#define AFTER	(1<<1)
X#define SINGLE	(1<<2)
X
X#define HASHLINE_ESCAPE ('#' ^ 0x80)
X#define UNQUOTED_WORD 32767
X#define EOLN 32766
X
X
Xtypedef struct meta_ty meta_ty;
Xstruct meta_ty
X{
X	int		m_type;		/* meta character "type" info	*/
X	int		m_char;		/* meta character actual value	*/
X	int		m_flag;		/* meta character flags		*/
X};
X
Xtypedef struct lex_ty lex_ty;
Xstruct lex_ty
X{
X	string_ty	*l_name;	/* name of file being analysed	*/
X	FILE		*l_file;	/* open file structure of the file */
X	int		l_line;		/* the line number we are up to	*/
X	meta_ty		l_mback;	/* backup for meta chars	*/
X	lex_ty		*l_chain;	/* file this one is an insert from */
X	short		l_bol;
X	wlist		pending_includes;
X};
X
Xtypedef struct stracc stracc;
Xstruct	stracc
X{
X	size_t		sa_max;		/* size of string accum buffer	*/
X	size_t		sa_len;		/* number of chars accumulated	*/
X	char		*sa_buf;	/* the string accum buffer	*/
X	int		sa_inuse;
X};
X
Xstatic	lex_ty		*root;		/* root of insert list		*/
Xstatic	stracc		saroot;		/* root of string accum list	*/
Xstatic	int		errcnt;		/* count of errors to date	*/
Xstatic	int		mode;		/* what lex mode we are in	*/
Xstatic	int		state;
Xstatic	int		passing;
Xstatic	int		catted;
Xstatic	symtab_ty	*parse_symtab;
Xstatic	symtab_ty	*hash_symtab;
X
X
X/*
X * NAME
X *	lex_initialize - look for keywords
X *
X * SYNOPSIS
X *	int lex_initialize(void);
X *
X * DESCRIPTION
X *	The lex_initialize function adds all the keywords to the symbol table.
X *
X * CAVEAT
X *	The keywords are intentionally case sensitive.
X *	Assumes that str_initialize has already been called.
X */
X
Xvoid
Xlex_initialize()
X{
X	typedef struct keyword_ty keyword_ty;
X	struct keyword_ty
X	{
X		char		*k_name;
X		int		k_token;
X	};
X
X	static keyword_ty parse_keyword[] =
X	{
X		{ ":",			COLON,			},
X		{ "=",			EQUALS,			},
X		{ "[",			LBRAK,			},
X		{ "]",			RBRAK,			},
X		{ "data",		DATA,			},
X		{ "else",		ELSE,			},
X		{ "fail",		FAIL,			},
X		{ "if",			IF,			},
X		{ "loop",		LOOP,			},
X		{ "set",		SET,			},
X		{ "then",		THEN,			},
X		{ "{"/*}*/,		LBRACE,			},
X		{ /*{*/"}",		RBRACE,			},
X		{ ";",			SEMICOLON,		},
X		{ "loopstop",		LOOPSTOP,		},
X		{ "unsetenv",		UNSETENV,		},
X	};
X	static keyword_ty hash_keyword[] =
X	{
X		{ "[",			LBRAK,			},
X		{ "]",			RBRAK,			},
X		{ "elif",		HASH_ELIF,		},
X		{ "else",		HASH_ELSE,		},
X		{ "endif",		HASH_ENDIF,		},
X		{ "if",			HASH_IF,		},
X		{ "ifdef",		HASH_IFDEF,		},
X		{ "ifndef",		HASH_IFNDEF,		},
X		{ "include",		HASH_INCLUDE,		},
X		{ "include-cooked",	HASH_INCLUDE_COOKED,	},
X		{ "include-cooked-nowarn", HASH_INCLUDE_COOKED2, },
X		{ "pragma",		HASH_PRAGMA,		},
X	};
X	keyword_ty	*kp;
X
X	trace(("init_reserved()\n{\n"/*}*/));
X	passing = 1;
X
X	if (!parse_symtab)
X		parse_symtab = symtab_alloc(SIZEOF(parse_keyword));
X	for (kp = parse_keyword; kp < ENDOF(parse_keyword); ++kp)
X	{
X		string_ty	*s;
X
X		s = str_from_c(kp->k_name);
X		symtab_assign(parse_symtab, s, &kp->k_token);
X		str_free(s);
X	}
X
X	if (!hash_symtab)
X		hash_symtab = symtab_alloc(SIZEOF(hash_keyword));
X	for (kp = hash_keyword; kp < ENDOF(hash_keyword); ++kp)
X	{
X		string_ty	*s;
X
X		s = str_from_c(kp->k_name);
X		symtab_assign(hash_symtab, s, &kp->k_token);
X		str_free(s);
X	}
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	lex_open - open a file for lexical analysis
X *
X * SYNOPSIS
X *	void lex_open(string_ty *filename);
X *
X * DESCRIPTION
X *	Lex_open opens a file for lexical analysis
X *	(it is also used to open include files).
X *
X * RETURNS
X *	void
X */
X
Xvoid
Xlex_open(filename)
X	string_ty	*filename;
X{
X	lex_ty		*new;
X
X	trace(("lex_open(filename = %08lX)\n{\n"/*}*/, filename));
X	trace_string(filename->str_text);
X	if (!root)
X		hashline_reset();
X	for (new = root; new; new = new->l_chain)
X	{
X		if (str_equal(filename, new->l_name))
X		{
X			lex_error("%S: recursive include", filename);
X			return;
X		}
X	}
X	new = mem_alloc_clear(sizeof(lex_ty));
X	new->l_name = str_copy(filename);
X	new->l_file = fopen(filename->str_text, "r");
X	if (!new->l_file)
X		nfatal("cookbook \"%S\"", filename);
X	new->l_line = 1;
X	new->l_bol = 1;
X	new->l_chain = root;
X	wl_zero(&new->pending_includes);
X	root = new;
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xlex_open_include(s)
X	string_ty	*s;
X{
X	assert(root);
X	wl_append(&root->pending_includes, s);
X}
X
X
X/*
X * NAME
X *	lex_close - closes a file which was open for lexical analysis
X *
X * SYNOPSIS
X *	void lex_close(void);
X *
X * DESCRIPTION
X *	Lex_close closes a file previously opened for lexical analysis.
X *
X * CAVEAT
X *	Lex_open must have been previously used to open the file.
X */
X
Xvoid
Xlex_close()
X{
X	lex_ty		*old;
X
X	trace(("lex_close()\n{\n"/*}*/));
X	assert(root);
X	old = root;
X	fclose(root->l_file);
X	root = old->l_chain;
X	if (!root && errcnt)
X		exit(1);
X	str_free(old->l_name);
X	wl_free(&old->pending_includes);
X	free(old);
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	illeof - conplain about an illegal end-of-file
X *
X * SYNOPSIS
X *	void illeof(void);
X *
X * DESCRIPTION
X *	Illeof is used to complain about illegal end-of-file.
X *	This may occu in several places.
X *
X * CAVEAT
X *	It does not return.
X */
X
Xstatic void illeof _((void));
X
Xstatic void
Xilleof()
X{
X	lex_error("unexpected end of file");
X	exit(1);
X}
X
X
X/*
X * NAME
X *	byte - get a byte from the input stream
X *
X * SYNOPSIS
X *	int byte(void);
X *
X * DESCRIPTION
X *	Byte return the next byte from the input stream, or EOF
X *	If the end of the outermost file is reached.
X *	It detechs the end of include files and closes them transparently.
X *
X * CAVEAT
X *	Lex_open must have been called previously.
X */
X
Xstatic int byte _((void));
X
Xstatic int
Xbyte()
X{
X	int		c;
X		
X	trace(("byte()\n{\n"/*}*/));
X	for (;;)
X	{
X		/*
X		 * leap into include file if possible
X		 */
X		assert(root);
X		if (root->pending_includes.wl_nwords)
X		{
X			string_ty	*fn;
X
X			fn = str_copy(root->pending_includes.wl_word[0]);
X			wl_delete(&root->pending_includes, fn);
X			lex_open(fn);
X			str_free(fn);
X			star();
X		}
X
X		/*
X		 * fetch the next input character
X		 */
X		c = fgetc(root->l_file);
X		if (c != EOF)
X			break;
X		if (ferror(root->l_file))
X			nfatal("read %S", root->l_name);
X		if (!root->l_chain)
X			break;
X		lex_close();
X	}
X	if (!isprint(c) && c != EOF && !strchr("\t\n\f", c))
X	{
X		lex_error("illegal '\\%o' character", (unsigned char)c);
X		c = ' ';
X	}
X	if (mode != LM_DATA && root->l_bol && c == '#')
X		c = HASHLINE_ESCAPE;
X	if (c == '\n')
X	{
X		root->l_bol = 1;
X		root->l_line++;
X	}
X	else
X	{
X		if (!strchr(" \t\f", c))
X			root->l_bol = 0;
X	}
X	trace_short(root->l_bol);
X	trace(("return '%c';\n", c));
X	trace((/*{*/"}\n"));
X	return c;
X}
X
X
X/*
X * NAME
X *	byte_undo - push back a character
X *
X * SYNOPSIS
X *	void byte_undo(int c);
X *
X * Description
X *	Byte_undo pushes a byte back onto the input stream.
X *
X * CAVEAT
X *	Only one byte may be pushed back at any one time.
X */
X
Xstatic void byte_undo _((int));
X
Xstatic void
Xbyte_undo(c)
X	int		c;
X{
X	trace(("byte_undo(c = '%c')\n{\n"/*}*/, c));
X	assert(root);
X	switch (c)
X	{
X	case EOF:
X		break;
X
X	case '\n':
X		root->l_line--;
X	default:
X		ungetc(c, root->l_file);
X		break;
X	}
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	sa_open - start accumulating a string.
X *
X * SYNOPSIS
X *	void sa_open(void);
X *
X * DESCRIPTION
X *	Sa_open begins accumulating a string for the lexical analyser.
X *	This allows virtually infinite length constructs within the
X *	lexical analyser.
X */
X
Xstatic void sa_open _((void));
X
Xstatic void
Xsa_open()
X{
X	trace(("sa_open()\n{\n"/*}*/));
X	assert(!saroot.sa_inuse);
X	saroot.sa_inuse = 1;
X	saroot.sa_len = 0;
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	sa_char - add a character to the accumulating string
X *
X * SYNOPSIS
X *	void sa_char(int c);
X *
X * DESCRIPTION
X *	Sa_char adds a character to the accumulating string.
X *
X * CAVEAT
X *	Sa_open must have been called previously.
X */
X
Xstatic void sa_char _((int));
X
Xstatic void
Xsa_char(c)
X	int		c;
X{
X	trace(("sa_char(c = '%c')\n{\n"/*}*/, c));
X	assert(saroot.sa_inuse);
X	if (saroot.sa_len >= saroot.sa_max)
X	{
X		saroot.sa_max += 128;
X		saroot.sa_buf = mem_change_size(saroot.sa_buf, saroot.sa_max);
X	}
X	saroot.sa_buf[saroot.sa_len++] = c;
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	sa_close - finish accumulating a string
X *
X * SYNOPSIS
X *	string_ty *sa_close(void);
X *
X * DESCRIPTION
X *	Sa_close finished accumulating a string and
X *	returns a pointer to the string in dynamic memory.
X *
X * CAVEAT
X *	Sa_open must have been called previously.
X *
X *	The value returned by this function is allocated in dynamic memory.
X *	It is the responsibility of the caller to ensure that it is freed when
X *	finished with, by a call to str_free().
X */
X
Xstatic string_ty *sa_close _((void));
X
Xstatic string_ty *
Xsa_close()
X{
X	string_ty	*val;
X
X	trace(("sa_close()\n{\n"/*}*/));
X	assert(saroot.sa_inuse);
X	val = str_n_from_c(saroot.sa_buf, saroot.sa_len);
X	saroot.sa_inuse = 0;
X	trace(("return %08lX;\n", val));
X	trace((/*{*/"}\n"));
X	return val;
X}
X
X
X/*
X * NAME
X *	sa_mark - mark place when accumulating a string
X *
X * SYNOPSIS
X *	size_t sa_mark(void);
X *
X * DESACRIPTION
X *	Sa_mark returns an indicator as to where the string being accumulated
X *	is up to.
X *
X * CAVEAT
X *	Sa_open must have been called previously.
X *	Do not use the returned value for anything other than passing to
X *	sa_goto as an argument.
X */
X
Xstatic size_t sa_mark _((void));
X
Xstatic size_t
Xsa_mark()
X{
X	assert(saroot.sa_inuse);
X	return (saroot.sa_len);
X}
X
X
X/*
X * NAME
X *	sa_goto - shorten the accumulated string
X *
X * SYNOPSIS
X *	void sa_goto(size_t mark);
X *
X * DESACRIPTION
X *	Sa_goto shotens the accumulating string to a point
X *	previously determined by sa_mark.
X *
X * CAVEAT
X *	Sa_open must have been called previously.
X *	The mark argument must have previously been returned by sa_mark,
X *	and sa_close not called in the interim.
X */
X
Xstatic void sa_goto _((size_t));
X
Xstatic void
Xsa_goto(n)
X	size_t		n;
X{
X	assert(saroot.sa_inuse);
X	assert(n <= saroot.sa_len);
X	saroot.sa_len = n;
X}
X
X
X/*
X * NAME
X *	meta_repn - mata_ty representation
X *
X * SYNOPSIS
X *	char *meta_repn(meta_ty*);
X *
X * DESCRIPTION
X *	The meta_repn function is used to produce a readable representation of
X *	a mata_ty value.
X *
X * RETURNS
X *	char* - a pointer to ta C string.
X *
X * CAVEAT
X *	This function is only available when the DEBUG symbol is #define'd.
X */
X
X#ifdef DEBUG
X
Xstatic char *meta_repn _((meta_ty *));
X
Xstatic char *
Xmeta_repn(val)
X	meta_ty		*val;
X{
X	static char *type[] =
X	{
X		"0",
X		"NORMAL",
X		"SLOSHED",
X		"WHITE",
X	};
X	static char *flag[] =
X	{
X		"0",
X		"BEFORE",
X		"AFTER",
X		"AFTER | BEFORE",
X		"SINGLE",
X		"SINGLE | BEFORE",
X		"SINGLE | AFTER",
X		"SINGLE | AFTER | BEFORE",
X	};
X	static char	buffer[100];
X	char		buf2[20];
X	char		buf3[10];
X
X	if (val->m_type >= 0 && val->m_type < SIZEOF(type))
X		strcpy(buf2, type[val->m_type]);
X	else
X		sprintf(buf2, "%d", val->m_type);
X	switch (val->m_char)
X	{
X	default:
X		if (isprint(val->m_char))
X		{
X			buf3[0] = val->m_char;
X			buf3[1] = 0;
X		}
X		else
X			sprintf(buf3, "\\%03o", (unsigned char)val->m_char);
X		break;
X
X	case '\'':
X	case '\\':
X		buf3[0] = '\\';
X		buf3[1] = val->m_char;
X		buf3[2] = 0;
X		break;
X	}
X	sprintf
X	(
X		buffer,
X		"{m_char = '%s', m_type = %s, m_flag = %s}",
X		buf3,
X		buf2,
X		flag[val->m_flag]
X	);
X	return buffer;
X}
X
X#endif
X
X
X/*
X * NAME
X *	meta - fetch and classify a character
X *
X * SYNOPSIS
X *	void meta(meta_ty*);
X *
X * DESCRIPTION
X *	Meta fetches and classifies a character from the input stream.
X *	The classification may be 'mode' dependent.
X *
X *	This is the point at which escaped newlines and comments are replaced
X *	by a single space.
X *
X * CAVEAT
X *	Lex_open must have been called previously.
X */
X
Xstatic void meta _((meta_ty *));
X
Xstatic void
Xmeta(val)
X	meta_ty		*val;
X{
X	trace(("meta(val = %08lX)\n{\n"/*}*/, val));
X	assert(root);
X	if (root->l_mback.m_type)
X	{
X		*val = root->l_mback;
X		root->l_mback.m_type = 0;
X	}
X	else
X	{
X		switch (val->m_char = byte())
X		{
X		default:
X			val->m_type = NORMAL;
X			val->m_flag = BEFORE | AFTER;
X			break;
X	
X		case EOF:
X			val->m_type = EOF;
X			val->m_flag = SINGLE;
X			break;
X	
X		case '=':
X		case ';':
X		case ':':
X		case '{'/*}*/:
X		case /*{*/'}':
X			switch (mode)
X			{
X			default:
X				val->m_type = NORMAL;
X				val->m_flag = SINGLE;
X				break;
X	
X			case LM_DATA:
X			case LM_SQUOTE:
X			case LM_DQUOTE:
X				val->m_type = NORMAL;
X				val->m_flag = BEFORE | AFTER;
X				break;
X			}
X			break;
X	
X		case '['/*]*/:
X			switch (mode)
X			{
X			default:
X				val->m_flag = BEFORE | SINGLE;
X				break;
X	
X			case LM_SQUOTE:
X			case LM_DQUOTE:
X				val->m_flag = BEFORE | AFTER;
X			}
X			val->m_type = NORMAL;
X				break;
X	
X		case /*[*/']':
X			val->m_type = NORMAL;
X			switch (mode)
X			{
X			default:
X				val->m_flag = AFTER | SINGLE;
X				break;
X	
X			case LM_DATA:
X			case LM_SQUOTE:
X			case LM_DQUOTE:
X				val->m_flag = BEFORE | AFTER;
X				break;
X			}
X			break;
X	
X		case ' ':
X		case '\t':
X		case '\n':
X		case '\f':
X			switch (mode)
X			{
X			default:
X				val->m_type = WHITE;
X				val->m_flag = SINGLE;
X				break;
X	
X			case LM_SQUOTE:
X			case LM_DQUOTE:
X			case LM_DATA:
X				val->m_type = NORMAL;
X				val->m_flag = BEFORE | AFTER;
X				break;
X			}
X			break;
X	
X		case '\\':
X			switch (val->m_char = byte())
X			{
X			case EOF:
X				illeof();
X	
X			case '\n':
X				val->m_char = ' ';
X				val->m_type = WHITE;
X				val->m_flag = SINGLE;
X				break;
X	
X			case '0':
X			case '1':
X			case '2':
X			case '3':
X			case '4':
X			case '5':
X			case '6':
X			case '7':
X				{
X					int	 count;
X					int	 c;
X	
X					c = val->m_char;
X					val->m_char = 0;
X					for (count = 0; count < 3; count++)
X					{
X						val->m_char = val->m_char * 8 + c - '0';
X						c = byte();
X						if (c < '0' || c > '7')
X						{
X							byte_undo(c);
X							break;
X						}
X					}
X					val->m_type = SLOSHED;
X					val->m_flag = BEFORE | AFTER;
X				}
X				break;
X	
X			default:
X				{
X					char	*cp;
X	
X					cp = strchr("b\bf\fn\nr\rt\t", val->m_char);
X					if (cp)
X						val->m_char = cp[1];
X					val->m_type = SLOSHED;
X					val->m_flag = BEFORE | AFTER;
X				}
X				break;
X			}
X			break;
X	
X		case '/':
X			switch (mode)
X			{
X			default:
X				{
X					int	 c;
X					int	 gate;
X					int	 count;
X	
X					if ((c = byte()) != '*')
X					{
X						byte_undo(c);
X						val->m_type = NORMAL;
X						val->m_flag = BEFORE | AFTER;
X						break;
X					}
X					gate = 0;
X					count = 1;
X					while (count)
X					{
X						switch (c = byte())
X						{
X						default:
X						case '\n':
X						case '\t':
X						case '\f':
X							gate = 0;
X							break;
X	
X						case EOF:
X							illeof();
X	
X						case '*':
X							if (gate == 1)
X							{
X								/*
X								 * nested comment start
X								 *
X								 * should a warning be issued?
X								 */
X								count++;
X								gate = 0;
X							}
X							else
X								gate = 2;
X							break;
X	
X						case '/':
X							if (gate == 2)
X							{
X								count--;
X								gate = 0;
X							}
X							else
X								gate = 1;
X							break;
X						}
X					}
X					val->m_char = ' ';
X					val->m_type = WHITE;
X					val->m_flag = SINGLE;
X				}
X				break;
X	
X			case LM_DATA:
X			case LM_SQUOTE:
X			case LM_DQUOTE:
X				val->m_type = NORMAL;
X				val->m_flag = BEFORE | AFTER;
X				break;
X			}
X			break;
X		}
X	}
X	trace(("*val = %s;\n", meta_repn(val)));
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	meta_undo - push back a character
X *
X * SYNOPSIS
X *	void meta_undo(meta_ty*);
X *
X * DESCRIPTION
X *	Meta_undo is used to temporarily push back a character
X *	from the input stream.
X *
X * CAVEAT
X *	Only one character may be pushed back at any one time.
X */
X
Xstatic void meta_undo _((meta_ty *));
X
Xstatic void
Xmeta_undo(val)
X	meta_ty		*val;
X{
X	assert(root);
X	assert(!root->l_mback.m_type);
X	root->l_mback = *val;
X}
X
X
X/*
X * NAME
X *	lex_error - print a file location specific error message
X *
X * SYNOPSIS
X *	void lex_error(char *s, ...);
X *
X * DESCRIPTION
X *	Lex_error prints a file location specific error message.
X *	If too many errors pass through here, cook will give up.
X */
X
Xvoid
Xlex_error(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	string_ty	*buffer;
X	va_list		ap;
X
X	sva_init(ap, s);
X	assert(root);
X	buffer = str_vformat(s, ap);
X	va_end(ap);
X	error("%S: %d: %S", root->l_name, root->l_line, buffer);
X	str_free(buffer);
X	if (++errcnt > 20)
X		fatal("%S: too many errors", root->l_name);
X	option_set_errors();
X}
X
X
X/*
X * NAME
X *	lex_warning - print a file location specific warning message
X *
X * SYNOPSIS
X *	void lex_warning(char *s, ...);
X *
X * DESCRIPTION
X *	Lex_warning prints a file location specific warning message.
X */
X
Xvoid
Xlex_warning(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	string_ty	*buffer;
X	va_list		ap;
X
X	assert(root);
X	sva_init(ap, s);
X	buffer = str_vformat(s, ap);
X	va_end(ap);
X	error("%S: %d: warning: %S", root->l_name, root->l_line, buffer);
X	str_free(buffer);
X}
X
X
X/*
X * NAME
X *	lex_mode - change the mode of lexical analysis
X *
X * SYNOPSIS
X *	int lex_mode(int n);
X *
X * DESCRIPTION
X *	Lex_mode changes the mode of lexical analysis to the one given,
X *	and returns the previous mode.
X *
X * CAVEAT
X *	Use the #define's in lex.h.
X */
X
Xint
Xlex_mode(n)
X	int		n;
X{
X	int		old;
X
X	old = mode;
X	mode = n;
X	return (old);
X}
X
X
X/*
X * NAME
X *	lex_trace - debug output
X *
X * SYNOPSIS
X *	void lex_trace(char *s, ...);
X *
X * DESCRIPTION
X *	The lex_trace function is used to format and output yyparse's trace
X *	output.  The printf's in yyparse are #define'd into lex_trace calls.
X *	Unfortunately yacc's designer did not take trace output redirection
X *	into account, to this function is a little tedious.
X *
X * RETURNS
X *	void
X *
X * CAVEAT
X *	This function is only available when the DEBUG symbol is #define'd.
X */
X
X#ifdef DEBUG
X
X/*VARARGS1*/
Xvoid
Xlex_trace(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	va_list		ap;
X	string_ty	*buffer;
X	char		*cp;
X	static char	line[1024];
X
X	sva_init(ap, s);
X	buffer = str_vformat(s, ap);
X	va_end(ap);
X	strcat(line, buffer->str_text);
X	str_free(buffer);
X	cp = line + strlen(line) - 1;
X	if (cp > line && *cp == '\n')
X	{
X		*cp = 0;
X		trace_printf("%S: %d: %s\n", root->l_name, root->l_line, line);
X		line[0] = 0;
X	}
X}
X
X
Xstatic char *mode_repn _((int));
X
Xstatic char *
Xmode_repn(n)
X	int	n;
X{
X	static char *name[] =
X	{
X		"NORMAL",
X		"DATA",
X		"SQUOTE",
X		"DQUOTE",
X	};
X	static char buffer[12];
X
X	if (n >= 0 && n < SIZEOF(name))
X		return name[n];
X	sprintf(buffer, "%d", n);
X	return buffer;
X}
X
X#endif
X
X
X/*
X * NAME
X *	tokenize - lexical analyser
X *
X * SYNOPSIS
X *	int tokenize(void);
X *
X * DESCRIPTION
X *	The tokenize functionm is used to partition the input stream into
X *	discreet tokens. 
X *
X * CAVEAT
X *	Lex_open must have been called previously.
X */
X
Xstatic int tokenize _((void));
X
Xstatic int
Xtokenize()
X{
X	meta_ty		c;
X	int		tok;
X	static meta_ty	last;
X	static int	dataended;
X
X	trace(("tokenize()\n{\n"/*}*/));
X	if (dataended)
X	{
X		dataended = 0;
X		tok = DATAEND;
X		goto ret;
X	}
X
X	if (!catted && (last.m_flag & AFTER))
X	{
X		/*
X		 * For parts of words in expressions which are abutted
X		 * together, the user is implying catenation of the strings.
X		 * This implied zero length token happens here.
X		 */
X		meta(&c);
X		meta_undo(&c);
X		if (c.m_flag & BEFORE)
X		{
X			catted = 1;
X			tok = CATENATE;
X			goto ret;
X		}
X	}
X	else
X		catted = 0;
X
X	for (;;)
X	{
X		int	 mark;
X
X		mark = 0;
X		meta(&c);
X		if (c.m_char == HASHLINE_ESCAPE)
X		{
X			state = 0;
X			last.m_flag = 0;
X			hashline();
X			state = 0;
X			last.m_flag = 0;
X			continue;
X		}
X		switch (c.m_type)
X		{
X		default:
X			fatal("illegal m_type %d (bug %d)", c.m_type, __LINE__);
X
X		case EOF:
X			tok = 0; /* by definition of yacc */
X			goto ret;
X
X		case NORMAL:
X		case SLOSHED:
X			{
X				int	 sloshed;
X
X				sloshed = 0;
X				sa_open();
X				if (state == 0)
X					mark = sa_mark();
X				for (;;)
X				{
X					trace
X					((
X							"%s: %d: state %d, mode %s;\n",
X						root->l_name->str_text,
X						root->l_line,
X						state,
X						mode_repn(mode)
X					));
X					sa_char(c.m_char);
X					if (c.m_type == SLOSHED)
X					{
X						sloshed = 1;
X						switch (state)
X						{
X						default:
X							state = 1;
X							break;
X
X						case 11:
X						case 12:
X							/* don't change state */
X							break;
X						}
X					}
X					else
X					{
X						switch (c.m_char)
X						{
X						default:
X							switch (state)
X							{
X							default:
X								state = 1;
X
X							case 11:
X							case 12:
X								break;
X							}
X							break;
X
X						case '\n':
X							switch (state)
X							{
X							case 9:
X							case 10:
X								sa_goto(mark);
X								parse_lval.lv_word = sa_close();
X								state = 0;
X								last.m_flag = 0; /* don't CAT after this */
X								dataended = DATAEND;
X								tok = WORD;
X								goto ret;
X
X							case 11:
X							case 12:
X								/* don't change state */
X								lex_error
X								(
X							      "newline in quote"
X								);
X								break;
X
X							default:
X								state = 0;
X								mark = sa_mark();
X								break;
X							}
X							break;
X
X						case '\'':
X							if (state != 12)
X							{
X								static		int		oldmode = LM_SQUOTE;
X
X								oldmode = lex_mode(oldmode);
X								sa_goto(sa_mark()-1);
X								state = ((state == 11) ? 1 : 11);
X								sloshed = 1;
X							}
X							break;
X
X						case '"':
X							if (state != 11)
X							{
X								static		int		oldmode = LM_DQUOTE;
X
X								oldmode = lex_mode(oldmode);
X								sa_goto(sa_mark()-1);
X								state = ((state == 12) ? 1 : 12);
X								sloshed = 1;
X							}
X							break;
X
X						case ' ':
X						case '\t':
X							switch (state)
X							{
X							default:
X								state = 1;
X								break;
X
X							case 0:
X							case 2:
X								state = 2;
X								break;
X
X							case 9:
X							case 10:
X								state = 10;
X								break;
X
X							case 11:
X							case 12:
X								break;
X							}
X							break;
X
X						case 'a':
X							switch (state)
X							{
X							default:
X								state = 1;
X								break;
X
X							case 3:
X							case 5:
X								state++;
X								break;
X
X							case 11:
X							case 12:
X								break;
X							}
X							break;
X
X						case 'd':
X							switch (state)
X							{
X							default:
X								state = 1;
X								break;
X
X							case 0:
X							case 2:
X								state = 3;
X								break;
X
X							case 8:
X								state = 9;
X								break;
X
X							case 11:
X							case 12:
X								break;
X							}
X							break;
X
X						case 'e':
X							switch (state)
X							{
X							default:
X								state = 1;
X								break;
X
X							case 6:
X								state = 7;
X								break;
X
X							case 11:
X							case 12:
X								break;
X							}
X							break;
X
X						case 'n':
X							switch (state)
X							{
X							default:
X								state = 1;
X								break;
X
X							case 7:
X								state = 8;
X								break;
X
X							case 11:
X							case 12:
X								break;
X							}
X							break;
X
X						case 't':
X							switch (state)
X							{
X							default:
X								state = 1;
X								break;
X
X							case 4:
X								state = 5;
X								break;
X
X							case 11:
X							case 12:
X								break;
X							}
X							break;
X						}
X					}
X					last = c;
X					if (last.m_flag & SINGLE)
X						break;
X					meta(&c);
X					if (c.m_flag & SINGLE)
X					{
X						meta_undo(&c);
X						break;
X					}
X				}
X				parse_lval.lv_word = sa_close();
X				if (sloshed)
X					tok = WORD;
X				else
X					tok = UNQUOTED_WORD;
X			}
X			goto ret;
X
X		case WHITE:
X			if (c.m_char == '\n')
X			{
X				last = c;
X				state = 0;
X				tok = EOLN;
X				goto ret;
X			}
X			state = 1;
X			break;
X		}
X	}
X
X	ret:
X	trace
X	((
X		"%S: %d: state %d, mode %s;\n",
X		root->l_name,
X		root->l_line,
X		state,
X		mode_repn(mode)
X	));
X	trace(("return %d;\n", tok));
X	trace((/*{*/"}\n"));
X	return tok;
X}
X
X
X/*
X * NAME
X *	lex_cur_file - name current file
X *
X * SYNOPSIS
X *	string_ty *lex_cur_file(void);
X *
X * DESCRIPTION
X *	The lex_cur_file function is used to get the name of the current
X *	file being analyzed by lex.
X *
X * RETURNS
X *	string_ty* - pointer to string with name in it
X *
X * CAVEAT
X *	Does not take a copy, so don't use str_free()
X */
X
Xstring_ty *
Xlex_cur_file()
X{
X	assert(root);
X	return root->l_name;
X}
X
X
Xint
Xlex_cur_line()
X{
X	assert(root);
X	return root->l_line;
X}
X
X
X/*
X * NAME
X *	parse_lex - lexer for parse.y
X *
X * SYNOPSIS
X *	int parse_lex(void);
X *
X * DESCRIPTION
X *	The parse_lex function is used to turn the tokens generated
X *	by tokenize into parse.y tokens.
X *
X * RETURNS
X *	int - the token number
X *
X * CAVEAT
X *	Intended solely for use by the yacc-generated compiler
X */
X
Xint
Xparse_lex()
X{
X	int		tok;
X	int		*data;
X
X	trace(("parse_lex()\n{\n"/*}*/));
X	for (;;)
X	{
X		tok = tokenize();
X		if (!passing)
X		{
X			if (!tok)
X			{
X				lex_error("unterminated conditional");
X				break;
X			}
X			if (tok == WORD || tok == UNQUOTED_WORD)
X				str_free(parse_lval.lv_word);
X			continue;
X		}
X		switch (tok)
X		{
X		case EOLN:
X			continue;
X
X		case UNQUOTED_WORD:
X			assert(parse_symtab);
X			data = symtab_query(parse_symtab, parse_lval.lv_word);
X			if (data)
X			{
X				tok = *data;
X				str_free(parse_lval.lv_word);
X				parse_lval.lv_word = 0;
X				if (tok == COLON)
X				{
X					parse_lval.lv_position.pos_name = str_copy(root->l_name);
X					parse_lval.lv_position.pos_line = root->l_line;
X				}
X				if (tok == DATA)
X				{
X					int	winged;
X					meta_ty	last;
X					meta_ty	c;
X	
X					/*
X					 * This is a special.  Gobble the rest
X					 * of the line before he starts sucking
X					 * in the program data.
X					 */
X					winged = 0;
X					for (;;)
X					{
X						meta(&c);
X						last = c;
X						switch (c.m_type)
X						{
X						default:
X							fatal
X							(
X						   "illegal m_type %d (bug %d)",
X								c.m_type,
X								__LINE__
X							);
X	
X						case EOF:
X							illeof();
X	
X						case NORMAL:
X						case SLOSHED:
X							if (!winged)
X							{
X								lex_error
X								(
X			       "the 'data' keyword must be the last on the line"
X								);
X								winged = 1;
X							}
X							continue;
X	
X						case WHITE:
X							if (c.m_char != '\n')
X								continue;
X							state = 0;
X							break;
X						}
X						break;
X					}
X					catted = 1;
X				}
X			}
X			else
X				tok = WORD;
X			break;
X		}
X		break;
X	}
X	trace(("return %d;\n", tok));
X	trace((/*{*/"}\n"));
X	return tok;
X}
X
X
X/*
X * NAME
X *	hashline_lex - lexer for hashline.y
X *
X * SYNOPSIS
X *	int hashline_lex(void);
X *
X * DESCRIPTION
X *	The hashline_lex function is used to turn the tokens generated
X *	by tokenize into hashline.y tokens.
X *
X * RETURNS
X *	int - the token number
X *
X * CAVEAT
X *	Intended solely for use by the yacc-generated compiler
X */
X
Xint
Xhashline_lex()
X{
X	int		tok;
X	int		*data;
X
X	trace(("hashline_lex()\n{\n"/*}*/));
X	tok = tokenize();
X	switch (tok)
X	{
X	case EOLN:
X		tok = 0;
X		break;
X
X	case UNQUOTED_WORD:
X		assert(hash_symtab);
X		data = symtab_query(hash_symtab, parse_lval.lv_word);
X		if (data)
X		{
X			tok = *data;
X			str_free(parse_lval.lv_word);
X			parse_lval.lv_word = 0;
X		}
X		else
X			tok = WORD;
X		break;
X	}
X	memcpy(&hashline_lval, &parse_lval, sizeof(hashline_lval));
X	trace(("return %d;\n", tok));
X	trace((/*{*/"}\n"));
X	return tok;
X}
X
X
Xvoid
Xlex_passing(n)
X	int		n;
X{
X	passing = n;
X}
END_OF_FILE
if test 27982 -ne `wc -c <'cook/lex.c'`; then
    echo shar: \"'cook/lex.c'\" unpacked with wrong size!
fi
# end of 'cook/lex.c'
fi
if test -f 'cooktime/date.y' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cooktime/date.y'\"
else
echo shar: Extracting \"'cooktime/date.y'\" \(27242 characters\)
sed "s/^X//" >'cooktime/date.y' <<'END_OF_FILE'
X/*
X * cook - file construction tool
X * Copyright (C) 1991, 1992, 1993, 1994 Peter Miller
X * All rights reserved.
X *	Peter Miller <pmiller@bmr.gov.au>
X *
X * This code is derived from code which is
X * Copyright (C) 1986 Steven M. Bellovin
X *	Steven Bellovin <smb@cs.unc.edu>
X *
X * MANIFEST: functions to parse dates
X */
X
X%token	AGO
X%token	COLON
X%token	COMMA
X%token	DAY
X%token	DAYZONE
X%token	ID
X%token	JUNK
X%token	MERIDIAN
X%token	MONTH
X%token	MUNIT
X%token	NUMBER
X%token	SLASH
X%token	SUNIT
X%token	UNIT
X%token	ZONE
X
X%{
X
X#include <stdio.h>
X#include <ac/stdlib.h>
X#include <ac/time.h>
X#include <ctype.h>
X#include <ac/string.h>
X
X#include <date.h>
X#include <str.h>
X#include <s-v-arg.h>
X#include <trace.h>
X
X#ifdef HAVE_FTIME
X#include <sys/timeb.h>
X#endif
X
X#define daysec (24L * 60L * 60L)
X
X#define AM 1
X#define PM 2
X
X#define DAYLIGHT 1
X#define STANDARD 2
X#define MAYBE    3
X
X#define MAX_ID_LENGTH 20
X
Xstatic	int	timeflag;
Xstatic	int	zoneflag;
Xstatic	int	dateflag;
Xstatic	int	dayflag;
Xstatic	int	relflag;
Xstatic	time_t	relsec;
Xstatic	time_t	relmonth;
Xstatic	int	hh;
Xstatic	int	mm;
Xstatic	int	ss;
Xstatic	int	merid;
Xstatic	int	day_light_flag;
Xstatic	int	dayord;
Xstatic	int	dayreq;
Xstatic	int	month;
Xstatic	int	day;
Xstatic	int	year;
Xstatic	int	ourzone;
Xstatic	char	*lptr;
Xextern	int	yylval;
Xextern	int	yydebug;
X
X
Xstatic int mdays[12] =
X{
X	31, 0, 31,  30, 31, 30,  31, 31, 30,  31, 30, 31
X};
X
X#define epoch 1970
X
Xint yyparse _((void)); /* forward */
X
X
X/*
X * NAME
X *	table - list of known names
X *
X * SYNOPSIS
X *	table_t table[];
X *
X * DESCRIPTION
X *	The table is used to hold the list of known names.
X *	This includes time zone names and days of the week, etc.
X *
X * CAVEAT
X *	It is in English.
X *	It is impossible to have a full list of time zones.
X */
X
Xtypedef struct table_t table_t;
Xstruct table_t
X{
X	char	*name;
X	int	type;
X	int	value;
X};
X
X#define HRMIN(a, b) ((a) * 60 + (b))
X
Xstatic table_t table[] =
X{
X	{ "a",		ZONE,		HRMIN(1, 0),	},
X	{ "a.c.s.s.t.",	DAYZONE,	-HRMIN(9, 30),	},
X	{ "a.c.s.t.",	ZONE,		-HRMIN(9, 30),	},
X	{ "a.d.t.",	DAYZONE,	HRMIN(4, 0),	},
X	{ "a.e.s.s.t.",	DAYZONE,	-HRMIN(10, 0),	},
X	{ "a.e.s.t.",	ZONE,		-HRMIN(10, 0),	},
X	{ "a.m.",	MERIDIAN,	AM,		},
X	{ "a.s.t.",	ZONE,		HRMIN(4, 0),	},
X	{ "a.w.s.t.",	ZONE,		-HRMIN(8, 0),	}, /* (no daylight time there,	I'm told */
X	{ "acsst",	DAYZONE,	-HRMIN(9, 30),	}, /* Australian Central Summer */
X	{ "acst",	ZONE,		-HRMIN(9, 30),	}, /* Australian Central Time */
X	{ "adt",	DAYZONE,	HRMIN(4, 0),	},
X	{ "aesst",	DAYZONE,	-HRMIN(10, 0),	}, /* Australian Eastern Summer Time */
X	{ "aest",	ZONE,		-HRMIN(10, 0),	}, /* Australian Eastern Time */
X	{ "ago",	AGO,		1,		},
X	{ "am",		MERIDIAN,	AM,		},
X	{ "apr",	MONTH,		4,		},
X	{ "apr.",	MONTH,		4,		},
X	{ "april",	MONTH,		4,		},
X	{ "ast",	ZONE,		HRMIN(4, 0),	},  /* Atlantic */
X	{ "aug",	MONTH,		8,		},
X	{ "aug.",	MONTH,		8,		},
X	{ "august",	MONTH,		8,		},
X	{ "awst",	ZONE,		-HRMIN(8, 0),	}, /* Australian Western Time */
X	{ "b",		ZONE,		HRMIN(2, 0),	},
X	{ "b.s.t.",	DAYZONE,	HRMIN(0, 0),	},
X	{ "bst",	DAYZONE,	HRMIN(0, 0),	}, /* British Summer Time */
X	{ "c",		ZONE,		HRMIN(3, 0),	},
X	{ "c.d.t.",	DAYZONE,	HRMIN(6, 0),	},
X	{ "c.s.t.",	ZONE,		HRMIN(6, 0),	},
X	{ "cdt",	DAYZONE,	HRMIN(6, 0),	},
X	{ "cst",	ZONE,		HRMIN(6, 0),	}, /* Central */
X	{ "d",		ZONE,		HRMIN(4, 0),	},
X	{ "day",	UNIT,		1 * 24 * 60,	},
X	{ "days",	UNIT,		1 * 24 * 60,	},
X	{ "dec",	MONTH,		12,		},
X	{ "dec.",	MONTH,		12,		},
X	{ "december",	MONTH,		12,		},
X	{ "e",		ZONE,		HRMIN(5, 0),	},
X	{ "e.d.t.",	DAYZONE,	HRMIN(5, 0),	},
X	{ "e.e.s.t.",	DAYZONE,	HRMIN(0, 0),	},
X	{ "e.e.t.",	ZONE,		HRMIN(0, 0),	},
X	{ "e.s.t.",	ZONE,		HRMIN(5, 0),	},
X	{ "edt",	DAYZONE,	HRMIN(5, 0),	},
X	{ "eest",	DAYZONE,	HRMIN(0, 0),	}, /* European Eastern Summer Time */
X	{ "eet",	ZONE,		HRMIN(0, 0),	}, /* European Eastern Time */
X	{ "eigth",	NUMBER,		8,		},
X	{ "eleventh",	NUMBER,		11,		},
X	{ "est",	ZONE,		HRMIN(5, 0),	}, /* Eastern */
X	{ "f",		ZONE,		HRMIN(6, 0),	},
X	{ "feb",	MONTH,		2,		},
X	{ "feb.",	MONTH,		2,		},
X	{ "february",	MONTH,		2,		},
X	{ "fifth",	NUMBER,		5,		},
X	{ "first",	NUMBER,		1,		},
X	{ "fortnight",	UNIT,		14 * 24 * 60,	},
X	{ "fortnights",	UNIT,		14 * 24 * 60,	},
X	{ "fourth",	NUMBER,		4,		},
X	{ "fri",	DAY,		5,		},
X	{ "fri.",	DAY,		5,		},
X	{ "friday",	DAY,		5,		},
X	{ "g",		ZONE,		HRMIN(7, 0),	},
X	{ "g.m.t.",	ZONE,		HRMIN(0, 0),	},
X	{ "gmt",	ZONE,		HRMIN(0, 0),	},
X	{ "h",		ZONE,		HRMIN(8, 0),	},
X	{ "h.d.t.",	DAYZONE,	HRMIN(10, 0),	},
X	{ "h.s.t.",	ZONE,		HRMIN(10, 0),	},
X	{ "hdt",	DAYZONE,	HRMIN(10, 0),	},
X	{ "hour",	UNIT,		60,		},
X	{ "hours",	UNIT,		60,		},
X	{ "hr",		UNIT,		60,		},
X	{ "hrs",	UNIT,		60,		},
X	{ "hst",	ZONE,		HRMIN(10, 0),	}, /* Hawaii */
X	{ "i",		ZONE,		HRMIN(9, 0),	},
X	{ "j.s.t.",	ZONE,		-HRMIN(9, 0),	}, /* Japan Standard Time */
X	{ "jan",	MONTH,		1,		},
X	{ "jan.",	MONTH,		1,		},
X	{ "january",	MONTH,		1,		},
X	{ "jst",	ZONE,		-HRMIN(9, 0),	}, /* Japan Standard Time */
X	{ "jul",	MONTH,		7,		},
X	{ "jul.",	MONTH,		7,		},
X	{ "july",	MONTH,		7,		},
X	{ "jun",	MONTH,		6,		},
X	{ "jun.",	MONTH,		6,		},
X	{ "june",	MONTH,		6,		},
X	{ "k",		ZONE,		HRMIN(10, 0),	},
X	{ "l",		ZONE,		HRMIN(11, 0),	},
X	{ "last",	NUMBER,		-1,		},
X	{ "m",		ZONE,		HRMIN(12, 0),	},
X	{ "m.d.t.",	DAYZONE,	HRMIN(7, 0),	},
X	{ "m.e.s.t.",	DAYZONE,	-HRMIN(1, 0),	},
X	{ "m.e.t.",	ZONE,		-HRMIN(1, 0),	},
X	{ "m.s.t.",	ZONE,		HRMIN(7, 0),	},
X	{ "mar",	MONTH,		3,		},
X	{ "mar.",	MONTH,		3,		},
X	{ "march",	MONTH,		3,		},
X	{ "may",	MONTH,		5,		},
X	{ "mdt",	DAYZONE,	HRMIN(7, 0),	},
X	{ "mest",	DAYZONE,	-HRMIN(1, 0),	}, /* Middle European Summer Time */
X	{ "met",	ZONE,		-HRMIN(1, 0),	}, /* Middle European Time */
X	{ "min",	UNIT,		1,		},
X	{ "mins",	UNIT,		1,		},
X	{ "minute",	UNIT,		1,		},
X	{ "minutes",	UNIT,		1,		},
X	{ "mon",	DAY,		1,		},
X	{ "mon.",	DAY,		1,		},
X	{ "monday",	DAY,		1,		},
X	{ "month",	MUNIT,		1,		},
X	{ "months",	MUNIT,		1,		},
X	{ "mst",	ZONE,		HRMIN(7, 0),	}, /* Mountain */
X	{ "n",		ZONE,		-HRMIN(1, 0),	},
X	{ "n.s.t.",	ZONE,		HRMIN(3, 30),	},
X	{ "next",	NUMBER,		2,		},
X	{ "ninth",	NUMBER,		9,		},
X	{ "nov",	MONTH,		11,		},
X	{ "nov.",	MONTH,		11,		},
X	{ "november",	MONTH,		11,		},
X	{ "now",	UNIT,		0,		},
X	{ "nst",	ZONE,		HRMIN(3, 30),	}, /* Newfoundland */
X	{ "o",		ZONE,		-HRMIN(2, 0),	},
X	{ "oct",	MONTH,		10,		},
X	{ "oct.",	MONTH,		10,		},
X	{ "october",	MONTH,		10,		},
X	{ "p",		ZONE,		-HRMIN(3, 0),	},
X	{ "p.d.t.",	DAYZONE,	HRMIN(8, 0),	},
X	{ "p.m.",	MERIDIAN,	PM,		},
X	{ "p.s.t.",	ZONE,		HRMIN(8, 0),	},
X	{ "pdt",	DAYZONE,	HRMIN(8, 0),	},
X	{ "pm",		MERIDIAN,	PM,		},
X	{ "pst",	ZONE,		HRMIN(8, 0),	}, /* Pacific */
X	{ "q",		ZONE,		-HRMIN(4, 0),	},
X	{ "r",		ZONE,		-HRMIN(5, 0),	},
X	{ "s",		ZONE,		-HRMIN(6, 0),	},
X	{ "sat",	DAY,		6,		},
X	{ "sat.",	DAY,		6,		},
X	{ "saturday",	DAY,		6,		},
X	{ "sec",	SUNIT,		1,		},
X	{ "second",	SUNIT,		1,		},
X	{ "seconds",	SUNIT,		1,		},
X	{ "secs",	SUNIT,		1,		},
X	{ "sep",	MONTH,		9,		},
X	{ "sep.",	MONTH,		9,		},
X	{ "sept",	MONTH,		9,		},
X	{ "sept.",	MONTH,		9,		},
X	{ "september",	MONTH,		9,		},
X	{ "seventh",	NUMBER,		7,		},
X	{ "sixth",	NUMBER,		6,		},
X	{ "sun",	DAY,		0,		},
X	{ "sun.",	DAY,		0,		},
X	{ "sunday",	DAY,		0,		},
X	{ "t",		ZONE,		-HRMIN(7, 0),	},
X	{ "tenth",	NUMBER,		10,		},
X	{ "third",	NUMBER,		3,		},
X	{ "this",	UNIT,		0,		},
X	{ "thu",	DAY,		4,		},
X	{ "thu.",	DAY,		4,		},
X	{ "thur",	DAY,		4,		},
X	{ "thur.",	DAY,		4,		},
X	{ "thurs",	DAY,		4,		},
X	{ "thurs.",	DAY,		4,		},
X	{ "thursday",	DAY,		4,		},
X	{ "today",	UNIT,		0,		},
X	{ "tomorrow",	UNIT,		1 * 24 * 60,	},
X	{ "tue",	DAY,		2,		},
X	{ "tue.",	DAY,		2,		},
X	{ "tues",	DAY,		2,		},
X	{ "tues.",	DAY,		2,		},
X	{ "tuesday",	DAY,		2,		},
X	{ "twelfth",	NUMBER,		12,		},
X	{ "u",		ZONE,		-HRMIN(8, 0),	},
X	{ "u.t.",	ZONE,		HRMIN(0, 0),	},
X	{ "ut",		ZONE,		HRMIN(0, 0),	},
X	{ "v",		ZONE,		-HRMIN(9, 0),	},
X	{ "w",		ZONE,		-HRMIN(10, 0),	},
X	{ "w.e.s.t.",	DAYZONE,	-HRMIN(2, 0),	},
X	{ "w.e.t.",	ZONE,		-HRMIN(2, 0),	},
X	{ "wed",	DAY,		3,		},
X	{ "wed.",	DAY,		3,		},
X	{ "wednes",	DAY,		3,		},
X	{ "wednes.",	DAY,		3,		},
X	{ "wednesday",	DAY,		3,		},
X	{ "week",	UNIT,		7 * 24 * 60,	},
X	{ "weeks",	UNIT,		7 * 24 * 60,	},
X	{ "west",	DAYZONE,	-HRMIN(2, 0),	}, /* Western European Summer Time */
X	{ "wet",	ZONE,		-HRMIN(2, 0),	}, /* Western European Time */
X	{ "x",		ZONE,		-HRMIN(11, 0),	},
X	{ "y",		ZONE,		-HRMIN(12, 0),	},
X	{ "y.d.t.",	DAYZONE,	HRMIN(9, 0),	},
X	{ "y.s.t.",	ZONE,		HRMIN(9, 0),	},
X	{ "ydt",	DAYZONE,	HRMIN(9, 0),	},
X	{ "year",	MUNIT,		12,		},
X	{ "years",	MUNIT,		12,		},
X	{ "yesterday",	UNIT,		-1*24*60,	},
X	{ "yst",	ZONE,		HRMIN(9, 0),	}, /* Yukon */
X	{ "z",		ZONE,		HRMIN(0, 0),	},
X};
X
X
X/*
X * NAME
X *	timeconv - convert a time
X *
X * SYNOPSIS
X *	time_t timeconv(int hh, int mm, int ss, int mer);
X *
X * DESCRIPTION
X *	The timeconv function is used to convert a time
X *	specified in hours minutes and seconds, into seconds past midnight.
X *
X * ARGUMENTS
X *	hh	hours, range depends on the meridian
X *	mm	minutes, 0..59
X *	ss	seconds, 0..59
X *	mer	meridian to use: AM, PM or 24
X *
X * RETURNS
X *	time_t; seconds past midnight; -1 on any error.
X */
X
Xstatic time_t timeconv _((int hh, int mm, int ss, int mer));
X
Xstatic time_t
Xtimeconv(hh, mm, ss, mer)
X	int	hh;
X	int	mm;
X	int	ss;
X	int	mer;
X{
X	time_t	result;
X
X	/*
X	 * perform sanity checks on input
X	 */
X	trace(("timeconv(hh = %d, mm = %d, ss = %d, mer = %d)\n{\n"/*}*/, hh, mm, ss, mer));
X	result = -1;
X	if (mm < 0 || mm > 59 || ss < 0 || ss > 59)
X		goto done;
X
X	/*
X	 * perform range checks depending on the meridian
X	 */
X	switch (mer)
X	{
X	case AM:
X		if (hh < 1 || hh > 12)
X			goto done;
X		if (hh == 12)
X			hh = 0;
X		break;
X
X	case PM:
X		if (hh < 1 || hh > 12)
X			goto done;
X		if (hh == 12)
X			hh = 0;
X		hh += 12;
X		break;
X
X	case 24:
X		if (hh < 0 || hh > 23)
X			goto done;
X		break;
X
X	default:
X		goto done;
X	}
X	result = ((hh * 60L + mm) * 60L + ss);
Xdone:
X	trace(("return %ld;\n", (long)result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	dateconv - convert a date
X *
X * SYNOPSIS
X *	time_t dateconv(int mm, int dd, int year, int h, int m, int s,
X *		int mer, int zone, int dayflag);
X *
X * DESCRIPTION
X *	The dateconv function may be used to convert a date after the
X *	date string has been taken apart by yyparse.
X *
X * ARGUMENTS
X *	mm	month number, in the range 1..12
X *	year	year number,  in several ranges:
X *		0..37 means 2000..2037
X *		70..99 means 1970..1999
X *		1970..2037 mean themselves.
X *	dd	day of month, in the range 1..max, where max varies for
X *		each month, as per the catchy jingle (except February,
X *		which is a monster).
X *	h	hours since midnight or meridian
X *	m	minutes past hour
X *	s	seconds past minute
X *	mer	meridian, AM or PM.
X *	zone	minutes correction for the time zone.
X *	dayflag	whether to use daylight savings: STANDARD, DAYLIGHT or MAYBE.
X *
X * RETURNS
X *	time_t; the time in seconds past Jan 1 0:00:00 1970 GMT, this will
X *	always be positive or zero; -1 is returned for any error.
X *
X * CAVEAT
X *	The date functions only work between 1970 and 2037,
X *	because 0 is Jan 1 00:00:00 1970 GMT
X *	and (2^31-1) is Jan 19 03:14:07 2038 GMT
X *	hence some if the weir magic number below.
X *
X *	Because -1 is used to represent errors, times before noon Jan 1 1970
X *	in places east of GMT can't always be represented.
X */
X
Xstatic time_t dateconv _((int mm, int dd, int year, int h, int m, int s,
X	int mer, int zone, int dayflag));
X
Xstatic time_t
Xdateconv(mm, dd, year, h, m, s, mer, zone, dayflag)
X	int	mm;
X	int	dd;
X	int	year;
X	int	h;
X	int	m;
X	int	s;
X	int	mer;
X	int	zone;
X	int	dayflag;
X{
X	time_t	result;
X	time_t	tod;
X	time_t	jdate;
X	int	i;
X
X	/*
X	 * make corrections for the year
X	 *
X	 * If it is 0..99, RFC822 says pick closest century.
X	 */
X	trace(("dateconv(mm = %d, dd = %d, year = %d, h = %d, m = %d, s = %d, mer = %d, zone = %d, dayflag = %d)\n{\n"/*}*/, mm, dd, year, h, m, s, mer, zone, dayflag));
X	result = -1;
X	if (year < 0)
X		year = -year;
X	if (year < 38)
X		year += 2000;
X	else if (year < 100)
X		year += 1900;
X
X	/*
X	 * correct February length once we know the year
X	 */
X	mdays[1] = 28 + (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));
X
X	/*
X	 * perform some sanity checks on the input
X	 */
X	if
X	(
X		year < epoch
X	||
X		year >= 2038
X	||
X		mm < 1
X	||
X		mm > 12
X	||
X		dd < 1
X	||
X		dd > mdays[--mm]
X	)
X		goto done;
X
X	/*
X	 * Determine the julian day number * of the dd-mm-yy given.
X	 * Turn it into seconds, and add in the time zone correction.
X	 */
X	jdate = dd - 1;
X        for (i = 0; i < mm; i++)
X		jdate += mdays[i];
X	for (i = epoch; i < year; i++)
X		jdate += 365 + (i % 4 == 0);
X	jdate *= daysec;
X	jdate += zone * 60L;
X
X	/*
X	 * Determine the time of day.
X	 * that is, seconds from midnight.
X	 * Add it into the julian date.
X	 */
X	tod = timeconv(h, m, s, mer);
X	if (tod < 0)
X		goto done;
X	jdate += tod;
X
X	/*
X	 * Perform daylight savings correction if necessary.
X	 * (This assumes 1 hour daylite savings, which is probably wrong.)
X	 */
X	if
X	(
X		dayflag == DAYLIGHT
X	||
X		(dayflag == MAYBE && localtime(&jdate)->tm_isdst)
X	)
X		jdate += -1 * 60 * 60;
X
X	/*
X	 * there you have it.
X	 */
X	result = jdate;
Xdone:
X	trace(("return %ld;\n", (long)result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	daylcorr
X *
X * SYNOPSIS
X *	time_t daylcorr(time_t future, time_t now);
X *
X * DESCRIPTION
X *	The daylcorr function is used to determine the difference in seconds
X *	between two times, taking daylight savings into account.
X *
X * ARGUMENTS
X *	future	- a later time
X *	now	- an earlier time
X *
X * RETURNS
X *	time_t; the difference in seconds
X *
X * CAVEAT
X *	Assumes daylight savings is alays an integral number of hours.
X *	This is wrong is Saudi Arabia (time zone changes during the day),
X *	and South Australia (half hour DLS).
X */
X
Xstatic time_t daylcorr _((time_t future, time_t now));
X
Xstatic time_t
Xdaylcorr(future, now)
X	time_t	future;
X	time_t	now;
X{
X	int	fdayl;
X	int	nowdayl;
X	time_t	result;
X
X	trace(("daylcorr(future = %ld, now = %ld)\n{\n"/*}*/, (long)future, (long)now));
X	nowdayl = (localtime(&now)->tm_hour + 1) % 24;
X	fdayl = (localtime(&future)->tm_hour + 1) % 24;
X	result = ((future - now) + 60L * 60L * (nowdayl - fdayl));
X	trace(("return %ld;\n", (long)result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	dayconv
X *
X * SYNOPSIS
X *	time_t dayconv(int ord, int day, time_t now);
X *
X * DESCRIPTION
X *	The dayconv function is used to convert a day-of-the-week into
X *	a meaningful time.
X *
X * ARGUMENTS
X *	ord	- the ord'th day from now
X *	day	- which day of the week
X *	now	- relative to this
X *
X * RETURNS
X *	time_t; time in seconds from epoch
X */
X
Xstatic time_t dayconv _((int ord, int day, time_t now));
X
Xstatic time_t
Xdayconv(ord, day, now)
X	int	ord;
X	int	day;
X	time_t	now;
X{
X	time_t	tod;
X	time_t	result;
X
X	trace(("dayconv(ord = %d, day = %d, now = %ld)\n{\n"/*}*/, ord, day, (long)now));
X	tod = now;
X	tod += daysec * ((day - localtime(&tod)->tm_wday + 7) % 7);
X	tod += 7 * daysec * (ord <= 0 ? ord : ord - 1);
X	result = daylcorr(tod, now);
X	trace(("return %ld;\n", (long)result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	monthadd
X *
X * SYNOPSIS
X *	time_t monthadd(time_t sdate, time_t relmonth);
X *
X * DESCRIPTION
X *	The monthadd function is used to add a given number of
X *	months to a specified time.
X *
X * ARGUMENTS
X *	sdate	- add the months to this
X *	relmonth - add this many months
X *
X * RETURNS
X *	time_t; seconds since the epoch
X */
X
Xstatic time_t monthadd _((time_t sdate, time_t relmonth));
X
Xstatic time_t
Xmonthadd(sdate, relmonth)
X	time_t	sdate;
X	time_t	relmonth;
X{
X	struct tm *ltime;
X	int	mm;
X	int	year;
X	time_t	result;
X
X	trace(("monthadd(sdate = %ld, relmonth = %ld)\n{\n"/*}*/, (long)sdate, (long)relmonth));
X	if (relmonth == 0)
X		result = 0;
X	else
X	{
X		ltime = localtime(&sdate);
X		mm = 12 * ltime->tm_year + ltime->tm_mon + relmonth;
X		year = mm / 12;
X		mm = mm % 12 + 1;
X		result = 
X			dateconv
X			(
X				mm,
X				ltime->tm_mday,
X				year,
X				ltime->tm_hour,
X				ltime->tm_min,
X				ltime->tm_sec,
X				24,
X				ourzone,
X				MAYBE
X			);
X		if (result >= 0)
X			result = daylcorr(result, sdate);
X	}
X	trace(("return %ld;\n", (long)result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	lookup - find name
X *
X * SYNOPSIS
X *	int lookup(char *id);
X *
X * DESCRIPTION
X *	The lookup function is used to find a token corresponding to
X *	a given name.
X *
X * ARGUMENTS
X *	id	- name to search for.  Assumes already downcased.
X *
X * RETURNS
X *	int; yacc token, ID if not found.
X */
X
Xstatic int lookup _((char *id));
X
Xstatic int
Xlookup(id)
X	char	*id;
X{
X	table_t	*tp;
X	int	min;
X	int	max;
X	int	mid;
X	int	cmp;
X	int	result;
X
X	/*
X	 * binary chop the table
X	 */
X	trace(("lookup(id = \"%s\")\n{\n"/*}*/, id));
X	result = ID;
X	min = 0;
X	max = SIZEOF(table) - 1;
X	while (min <= max)
X	{
X		mid = (min + max) / 2;
X		tp = table + mid;
X		cmp = strcmp(id, tp->name);
X		if (!cmp)
X		{
X			yylval = tp->value;
X			result = tp->type;
X			break;
X		}
X		if (cmp < 0)
X			max = mid - 1;
X		else
X			min = mid + 1;
X	}
X	trace(("return %d;\n", result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	yylex - lexical analyser
X *
X * SYNOPSIS
X *	int yylex(void);
X *
X * DESCRIPTION
X *	The yylex function is used to scan the input string
X *	and break it into discrete tokens.
X *
X * RETURNS
X *	int; the yacc token, 0 means the-end.
X */
X
Xstatic int yylex _((void));
X
Xstatic int
Xyylex()
X{
X	int	sign;
X	int	c;
X	char	*p;
X	char	idbuf[MAX_ID_LENGTH];
X	int	pcnt;
X	int	token;
X
X	trace(("yylex()\n{\n"/*}*/));
X	yylval = 0;
X	for (;;)
X	{
X		/*
X		 * get the next input character
X		 */
X		c = *lptr++;
X
X		/*
X		 * action depends on the character
X		 */
X		switch (c)
X		{
X		case 0:
X			token = 0;
X			lptr--;
X			break;
X
X		case ' ':
X		case '\t':
X			/*
X			 * ignore white space
X			 */
X			continue;
X
X		case ':':
X			token = COLON;
X			break;
X
X		case ',':
X			token = COMMA;
X			break;
X
X		case '/':
X			token = SLASH;
X			break;
X
X		case '-':
X			if (!isdigit(*lptr))
X			{
X				/*
X				 * ignore lonely '-'s
X				 */
X				continue;
X			}
X			sign = -1;
X			c = *lptr++;
X			goto number;
X
X		case '+':
X			if (!isdigit(*lptr))
X			{
X				token = c;
X				break;
X			}
X			sign = 1;
X			c = *lptr++;
X			goto number;
X
X		case '0': case '1': case '2': case '3': case '4':
X		case '5': case '6': case '7': case '8': case '9':
X			/*
X			 * numbers
X			 */
X			sign = 1;
X			number:
X			for (;;)
X			{
X				yylval = yylval * 10 + c - '0';
X				c = *lptr++;
X				switch (c)
X				{
X				case '0': case '1': case '2': case '3':
X				case '4': case '5': case '6': case '7':
X				case '8': case '9':
X					continue;
X				}
X				break;
X			}
X			yylval *= sign;
X			lptr--;
X			token = NUMBER;
X			break;
X		
X		case 'a': case 'b': case 'c': case 'd': case 'e':
X		case 'f': case 'g': case 'h': case 'i': case 'j':
X		case 'k': case 'l': case 'm': case 'n': case 'o':
X		case 'p': case 'q': case 'r': case 's': case 't':
X		case 'u': case 'v': case 'w': case 'x': case 'y': case 'z': 
X		case 'A': case 'B': case 'C': case 'D': case 'E':
X		case 'F': case 'G': case 'H': case 'I': case 'J':
X		case 'K': case 'L': case 'M': case 'N': case 'O':
X		case 'P': case 'Q': case 'R': case 'S': case 'T':
X		case 'U': case 'V': case 'W': case 'X': case 'Y': case 'Z': 
X			/*
X			 * name
X			 */
X			p = idbuf;
X			for (;;)
X			{
X				if (isupper(c))
X					c = tolower(c);
X				if (p < idbuf + sizeof(idbuf) - 1)
X					*p++ = c;
X				c = *lptr++;
X				switch (c)
X				{
X				case 'a': case 'b': case 'c': case 'd':
X				case 'e': case 'f': case 'g': case 'h':
X				case 'i': case 'j': case 'k': case 'l':
X				case 'm': case 'n': case 'o': case 'p':
X				case 'q': case 'r': case 's': case 't':
X				case 'u': case 'v': case 'w': case 'x':
X				case 'y': case 'z': 
X				case 'A': case 'B': case 'C': case 'D':
X				case 'E': case 'F': case 'G': case 'H':
X				case 'I': case 'J': case 'K': case 'L':
X				case 'M': case 'N': case 'O': case 'P':
X				case 'Q': case 'R': case 'S': case 'T':
X				case 'U': case 'V': case 'W': case 'X':
X				case 'Y': case 'Z': 
X				case '.':
X					continue;
X				}
X				break;
X			}
X			*p = 0;
X			lptr--;
X			token = lookup(idbuf);
X			break;
X		
X		case '('/*)*/:
X			/*
X			 * comment
X			 */
X			for (pcnt = 1; pcnt > 0; )
X			{
X				c = *lptr++;
X				switch (c)
X				{
X				case 0:
X					--lptr;
X					pcnt = 0;
X					break;
X				
X				case '('/*)*/:
X					pcnt++;
X					break;
X
X				case /*(*/')':
X					pcnt--;
X					break;
X				}
X			}
X			continue;
X
X		default:
X			/*
X			 * unrecognosed
X			 */
X			token = JUNK;
X			break;
X		}
X		break;
X	}
X	trace(("yylval = %d;\n", yylval));
X	trace(("return %d;\n", token));
X	trace((/*{*/"}\n"));
X	return token;
X}
X
X
X/*
X * NAME
X *	date_scan
X *
X * SYNOPSIS
X *	time_t date_scan(char *s);
X *
X * DESCRIPTION
X *	The date_scan function is used to scan a string and
X *	return a number of seconds since epoch.
X *
X * ARGUMENTS
X *	s	- string to scan
X *
X * RETURNS
X *	time_t; seconds to epoch, -1 on error.
X *
X * CAVEAT
X *	it isn't psychic
X */
X
Xtime_t
Xdate_scan(p)
X	char		*p;
X{
X#ifdef HAVE_FTIME
X	struct timeb	*now;
X	struct timeb	ftz;
X#else
X	time_t		now;
X#endif
X	struct tm	*lt;
X	time_t		result;
X	time_t		tod;
X
X	/*
X	 * find time zone info, if not given
X	 */
X	trace(("date_scan(p = \"%s\")\n{\n"/*}*/, p));
X	lptr = p;
X	/*
X	 * initialize things
X	 */
X#ifdef HAVE_FTIME
X	now = &ftz;
X	ftime(&ftz);
X	lt = localtime(&now->time);
X#else
X	time(&now);
X        lt = localtime(&now);
X#endif
X	year = lt->tm_year;
X	month = lt->tm_mon + 1;
X	day = lt->tm_mday;
X	relsec = 0;
X	relmonth = 0;
X	timeflag = 0;
X	zoneflag = 0;
X	dateflag = 0;
X	dayflag = 0;
X	relflag = 0;
X#ifdef HAVE_FTIME
X	ourzone = now->timezone;
X#else
X	ourzone = 0;
X#endif
X	day_light_flag = MAYBE;
X	hh = 0;
X	mm = 0;
X	ss = 0;
X	merid = 24;
X
X	/*
X	 * parse the string
X	 */
X#ifdef DEBUG
X	yydebug = trace_pretest_;
X#endif
X	trace(("yyparse()\n{\n"/*}*/));
X	result = yyparse();
X	trace((/*{*/"}\n"));
X	if (result)
X	{
X		result = -1;
X		goto done;
X	}
X
X	/*
X	 * sanity checks
X	 */
X	result = -1;
X	if (timeflag > 1 || zoneflag > 1 || dateflag > 1 || dayflag > 1)
X		goto done;
X
X	if (dateflag || timeflag || dayflag)
X	{
X		result =
X			dateconv
X			(
X				month,
X				day,
X				year,
X				hh,
X				mm,
X				ss,
X				merid,
X				ourzone,
X				day_light_flag
X			);
X		if (result < 0)
X			goto done;
X	}
X	else
X	{
X#ifdef HAVE_FTIME
X		result = now->time;
X#else
X		result = now;
X#endif
X		if (!relflag)
X		{
X			result -=
X				(
X					(lt->tm_hour * 60L + lt->tm_min * 60)
X				+
X					lt->tm_sec
X				);
X		}
X	}
X
X	result += relsec;
X	relsec = monthadd(result, relmonth);
X	if (relsec < 0)
X	{
X		result = -1;
X		goto done;
X	}
X	result += relsec;
X
X	if (dayflag && !dateflag)
X	{
X		tod = dayconv(dayord, dayreq, result);
X		result += tod;
X	}
X
X	/*
X	 * here for all exits
X	 */
Xdone:
X	trace(("return %ld;\n", (long)result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	date_string - build one
X *
X * SYNOPSIS
X *	char *date_string(time_t when);
X *
X * DESCRIPTION
X *	The date_string function may be used to construct a
X *	string from a given time in seconds.
X *
X *	The string will conform to the RFC822 standard,
X *	which states a definite preference for GMT dates.
X *
X * ARGUMENTS
X *	when	the time to be rendered.
X *
X * RETURNS
X *	Pointer to string containing rendered time.
X *	The contents of this string will remain undisturbed
X *	only until the next call to date_string.
X */
X
Xchar *
Xdate_string(when)
X	time_t		when;
X{
X	struct tm	*tm;
X	static char	buffer[32];
X
X	static char	*weekday_name[] =
X	{
X		"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
X	};
X
X	static char	*month_name[] =
X	{
X		"Jan", "Feb", "Mar", "Apr", "May", "Jun",
X		"Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
X	};
X
X	/*
X	 * break the given time down into components
X	 *	(RFC1036 likes GMT, remember)
X	 */
X	trace(("date_string(when = %ld)\n{\n"/*}*/, (long)when));
X	tm = gmtime(&when);
X
X	/*
X	 * build the date string
X	 */
X	sprintf
X	(
X		buffer,
X		"%s,%3d %s %2.2d %2.2d:%2.2d:%2.2d GMT",
X		weekday_name[tm->tm_wday],
X		tm->tm_mday,
X		month_name[tm->tm_mon],
X		tm->tm_year % 100,
X		tm->tm_hour,
X		tm->tm_min,
X		tm->tm_sec
X	);
X	trace(("return \"%s\";\n", buffer));
X	trace((/*{*/"}\n"));
X	return buffer;
X}
X
X
X/*
X * NAME
X *	yyerror
X *
X * SYNOPSIS
X *	void yyerror(char *);
X *
X * DESCRIPTION
X *	The yyerror function is invoked by yacc to report
X *	errors, but we just throw it away.
X *
X * ARGUMENTS
X *	s	- error to report
X */
X
Xstatic void yyerror _((char *));
X
Xstatic void
Xyyerror(s)
X	char	*s;
X{
X	trace(("yyerror(s = \"%s\")\n{\n"/*}*/, s));
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	yytrace - follow parser actions
X *
X * SYNOPSIS
X *	void yytrace(char *, ...);
X *
X * DESCRIPTION
X *	The yytrace function is used to print the various shifts
X *	and reductions, etc, done by the yacc-generated parser.
X *	lines are accumulated and printed whole,
X *	so as to avoid confusing the trace output.
X *
X * ARGUMENTS
X *	as for printf 
X *
X * CAVEAT
X *	only available when DEBUG is defined
X */
X
X#ifdef DEBUG
X#define YYDEBUG 1
X
X#define printf yytrace
X
Xstatic void yytrace _((char *, ...));
X
Xstatic void
Xyytrace(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	va_list		ap;
X	static char	line[1024];
X	string_ty	*buffer;
X	char		*cp;
X
X	sva_init(ap, s);
X	buffer = str_vformat(s, ap);
X	va_end(ap);
X	strcat(line, buffer->str_text);
X	str_free(buffer);
X	cp = line + strlen(line) - 1;
X	if (cp > line && *cp == '\n')
X	{
X		*cp = 0;
X		trace_printf("%s\n", line);
X		line[0] = 0;
X	}
X}
X
X#endif /* DEBUG */
X
X%}
X
X%%
X
Xtimedate
X	: /* empty */
X	| timedate item
X	;
X
Xitem
X	: TimeSpecification
X		{ timeflag++; }
X	| TimeZone
X		{ zoneflag++; }
X	| DateSpecification
X		{ dateflag++; }
X	| DayOfWeekSpecification
X		{ dayflag++; }
X	| RelativeSpecification
X		{ relflag++; }
X	| NumberSpecification
X	;
X
XNumberSpecification
X	: NUMBER
X		{
X			if (timeflag && dateflag && !relflag)
X				year = $1;
X			else
X			{
X				timeflag++;
X				hh = $1 / 100;
X				mm = $1 % 100;
X				ss = 0;
X				merid = 24;
X			}
X		}
X	;
X
XTimeSpecification
X	: NUMBER MERIDIAN
X		{
X			hh = $1;
X			mm = 0;
X			ss = 0;
X			merid = $2;
X		}
X	| NUMBER COLON NUMBER
X		{
X			hh = $1;
X			mm = $3;
X			merid = 24;
X		}
X	| NUMBER COLON NUMBER MERIDIAN
X		{
X			hh = $1;
X			mm = $3;
X			merid = $4;
X		}
X	| NUMBER COLON NUMBER NUMBER
X		{
X			hh = $1;
X			mm = $3;
X			merid = 24;
X			day_light_flag = STANDARD;
X			$4 = -$4;
X			ourzone = $4 % 100 + 60 * $4 / 100;
X		}
X	| NUMBER COLON NUMBER COLON NUMBER
X		{
X			hh = $1;
X			mm = $3;
X			ss = $5;
X			merid = 24;
X		}
X	| NUMBER COLON NUMBER COLON NUMBER MERIDIAN
X		{
X			hh = $1;
X			mm = $3;
X			ss = $5;
X			merid = $6;
X		}
X	| NUMBER COLON NUMBER COLON NUMBER NUMBER
X		{
X			hh = $1;
X			mm = $3;
X			ss = $5;
X			merid = 24;
X			day_light_flag = STANDARD;
X			$6 = -$6;
X			ourzone = $6 % 100 + 60 * $6 / 100;
X		}
X	;
X
XTimeZone
X	: ZONE
X		{
X			ourzone = $1;
X			day_light_flag = STANDARD;
X		}
X	| DAYZONE
X		{
X			ourzone = $1;
X			day_light_flag = DAYLIGHT;
X		}
X	;
X
XDayOfWeekSpecification
X	: DAY
X		{
X			dayord = 1;
X			dayreq = $1;
X		}
X	| DAY COMMA
X		{
X			dayord = 1;
X			dayreq = $1;
X		}
X	| NUMBER DAY
X		{
X			dayord = $1;
X			dayreq = $2;
X		}
X	;
X
XDateSpecification
X	: NUMBER SLASH NUMBER
X		{
X			month = $1;
X			day = $3;
X		}
X	| NUMBER SLASH NUMBER SLASH NUMBER
X		{
X			month = $1;
X			day = $3;
X			year = $5;
X		}
X	| MONTH NUMBER
X		{
X			month = $1;
X			day = $2;
X		}
X	| MONTH NUMBER COMMA NUMBER
X		{
X			month = $1;
X			day = $2;
X			year = $4;
X		}
X	| NUMBER MONTH
X		{
X			month = $2;
X			day = $1;
X		}
X	| NUMBER MONTH NUMBER
X		{
X			month = $2;
X			day = $1;
X			year = $3;
X		}
X	;
X
XRelativeSpecification
X	: NUMBER UNIT
X		{ relsec +=  60L * $1 * $2; }
X	| NUMBER MUNIT
X		{ relmonth += $1 * $2; }
X	| NUMBER SUNIT
X		{ relsec += $1; }
X	| UNIT
X		{ relsec +=  60L * $1; }
X	| MUNIT
X		{ relmonth += $1; }
X	| SUNIT
X		{ relsec++; }
X	| RelativeSpecification AGO
X		{
X			relsec = -relsec;
X			relmonth = -relmonth;
X		}
X	;
END_OF_FILE
if test 27242 -ne `wc -c <'cooktime/date.y'`; then
    echo shar: \"'cooktime/date.y'\" unpacked with wrong size!
fi
# end of 'cooktime/date.y'
fi
echo shar: End of archive 15 \(of 19\).
cp /dev/null ark15isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 19 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
