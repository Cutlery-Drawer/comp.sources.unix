Newsgroups: comp.sources.unix
From: pmiller@bmr.gov.au (Peter Miller)
Subject: v28i101: cook - a file construction tool, V1.6, Part08/19
References: <1.775008949.28543@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: pmiller@bmr.gov.au (Peter Miller)
Posting-Number: Volume 28, Issue 101
Archive-Name: cook-1.6/part08

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 8 (of 19)."
# Contents:  aux/Makefile.sh aux/README.man common/fp/crc32.c
#   common/word.c cook/builtin.c cook/builtin/boolean.c
#   cook/builtin/match.c cook/fngrprnt.y cook/id.c cook/listing.c
#   cook/option.c doc/intro2.so make2cook/gram.y man1/make2cook.1
#   test/00/t0046a.sh
# Wrapped by vixie@gw.home.vix.com on Sat Jul 23 17:11:24 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'aux/Makefile.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aux/Makefile.sh'\"
else
echo shar: Extracting \"'aux/Makefile.sh'\" \(5772 characters\)
sed "s/^X//" >'aux/Makefile.sh' <<'END_OF_FILE'
X#!/bin/sh
X#
X#	cook - file construction tool
X#	Copyright (C) 1990, 1991, 1992, 1993, 1994 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: shell script to generate Makefile file
X#
XALL="bin/c_incl bin/cook bin/cookfp bin/cooktime bin/find_libs \
Xbin/make2cook bin/roffpp"
Xcook_files=
Xc_incl_files=
Xfind_libs_files=
Xroffpp_files=
Xcooktime_files=
Xtxt2c_files="common/ansi.o common/arglex.o common/error.o common/mem.o \
Xcommon/mprintf.o common/str.o common/trace.o"
Xcookfp_files=
Xcommon=
Xtest_files=
Xclean_files="core y.tab.c y.tab.h bin/txt2c"
Xlib_files=
Xman_files=
Xmake2cook_files=
Xfor file in $*
Xdo
X	case $file in
X
X	cook/*.y)
X		stem=`echo $file | sed 's/\.y$//'`
X		clean_files="$clean_files ${stem}.gen.c ${stem}.gen.h \
X${stem}.gen.o"
X		cook_files="$cook_files ${stem}.gen.o"
X		;;
X
X	cook/*.c)
X		stem=`echo $file | sed 's/\.c$//'`
X		cook_files="$cook_files ${stem}.o"
X		clean_files="$clean_files ${stem}.o"
X		;;
X
X	make2cook/*.y)
X		stem=`echo $file | sed 's/.y$//'`
X		clean_files="$clean_files ${stem}.gen.c ${stem}.gen.h \
X${stem}.gen.o"
X		make2cook_files="$make2cook_files ${stem}.gen.o"
X		;;
X
X	make2cook/*.c)
X		stem=`echo $file | sed 's/.c$//'`
X		make2cook_files="$make2cook_files ${stem}.o"
X		clean_files="$clean_files ${stem}.o"
X		;;
X
X	c_incl/*.c)
X		stem=`echo $file | sed 's/.c$//'`
X		c_incl_files="$c_incl_files ${stem}.o"
X		clean_files="$clean_files ${stem}.o"
X		;;
X
X	find_libs/*.c)
X		stem=`echo $file | sed 's/.c$//'`
X		find_libs_files="$find_libs_files ${stem}.o"
X		clean_files="$clean_files ${stem}.o"
X		;;
X
X	roffpp/*.c)
X		stem=`echo $file | sed 's/.c$//'`
X		roffpp_files="$roffpp_files ${stem}.o"
X		clean_files="$clean_files ${stem}.o"
X		;;
X
X	cooktime/*.y)
X		stem=`echo $file | sed 's/.y$//'`
X		clean_files="$clean_files ${stem}.gen.c ${stem}.gen.h \
X${stem}.gen.o"
X		cooktime_files="$cooktime_files ${stem}.gen.o"
X		;;
X
X	cooktime/*.c)
X		stem=`echo $file | sed 's/.c$//'`
X		cooktime_files="$cooktime_files ${stem}.o"
X		clean_files="$clean_files ${stem}.o"
X		;;
X
X	txt2c/*.c)
X		stem=`echo $file | sed 's/.c$//'`
X		txt2c_files="$txt2c_files ${stem}.o"
X		clean_files="$clean_files ${stem}.o"
X		;;
X
X	cookfp/*.c)
X		stem=`echo $file | sed 's/.c$//'`
X		cookfp_files="$cookfp_files ${stem}.o"
X		clean_files="$clean_files ${stem}.o"
X		;;
X
X	common/*.c)
X		stem=`echo $file | sed 's/.c$//'`
X		common_files="$common_files ${stem}.o"
X		clean_files="$clean_files ${stem}.o"
X		;;
X
X	test/*/*)
X		root=`basename $file .sh`
X		test_files="$test_files ${root}"
X		;;
X
X	man1/*.1)
X		root=`basename $file .1`
X		man_files="$man_files $(mandir)/man1/$root.1"
X		clean_files="$clean_files man1/${root}.h"
X		;;
X
X	man1/*.so)
X		root=`basename $file .so`
X		clean_files="$clean_files man1/${root}.h"
X		;;
X
X	lib/*)
X		root=`basename $file`
X		lib_files="$lib_files $(libdir)/$root"
X		;;
X
X	*)
X		;;
X	esac
Xdone
X
Xecho ""
Xecho "CommonObj =" $common_files
X
Xecho ""
Xecho "common/lib.a: $(CommonObj)"
Xecho "	rm -f common/lib.a"
Xecho "	$(AR) qc common/lib.a $(CommonObj)"
Xecho "	$(RANLIB) common/lib.a"
X
Xecho ""
Xecho "bin:"
Xecho "	mkdir bin"
X
Xecho ""
Xecho "CookObj =" $cook_files
X
Xecho ""
Xecho "bin/cook: $(CookObj) common/lib.a bin"
Xecho "	$(CC) $(LDFLAGS) -o bin/cook $(CookObj) common/lib.a $(LIBS)"
X
Xecho ""
Xecho "Make2cookObj =" $make2cook_files
X
Xecho ""
Xecho "bin/make2cook: $(Make2cookObj) common/lib.a bin"
Xecho "	$(CC) $(LDFLAGS) -o bin/make2cook $(Make2cookObj) common/lib.a $(LIBS)"
X
Xecho ""
Xecho "CInclObj =" $c_incl_files
X
Xecho ""
Xecho "bin/c_incl: $(CInclObj) common/lib.a bin"
Xecho "	$(CC) $(LDFLAGS) -o bin/c_incl $(CInclObj) common/lib.a $(LIBS)"
X
Xecho ""
Xecho "FindLibsObj =" $find_libs_files
X
Xecho ""
Xecho "bin/find_libs: $(FindLibsObj) common/lib.a bin"
Xecho "	$(CC) $(LDFLAGS) -o bin/find_libs $(FindLibsObj) common/lib.a $(LIBS)"
X
Xecho ""
Xecho "RoffppObj =" $roffpp_files
X
Xecho ""
Xecho "bin/roffpp: $(RoffppObj) common/lib.a bin"
Xecho "	$(CC) $(LDFLAGS) -o bin/roffpp $(RoffppObj) common/lib.a $(LIBS)"
X
Xecho ""
Xecho "CooktimeObj =" $cooktime_files
X
Xecho ""
Xecho "bin/cooktime: $(CooktimeObj) common/lib.a bin"
Xecho "	$(CC) $(LDFLAGS) -o bin/cooktime $(CooktimeObj) common/lib.a $(LIBS)"
X
Xecho ""
Xecho "Txt2cObj =" $txt2c_files
X
Xecho ""
Xecho "bin/txt2c: $(Txt2cObj) bin"
Xecho "	$(CC) $(LDFLAGS) -o bin/txt2c $(Txt2cObj) $(LIBS)"
X
Xecho ""
Xecho "CookfpObj =" $cookfp_files
X
Xecho ""
Xecho "bin/cookfp: $(CookfpObj) common/lib.a bin"
Xecho "	$(CC) $(LDFLAGS) -o bin/cookfp $(CookfpObj) common/lib.a $(LIBS)"
X
Xecho ""
Xecho "sure:" $test_files
Xecho "	@echo Passed All Tests"
X
Xecho ""
Xecho "clean-obj:"
Xecho "	rm -f" $clean_files
X
Xecho ""
Xecho "clean: clean-obj"
Xecho "	rm -f" $ALL
X
Xecho ""
Xecho "distclean: clean"
Xecho "	rm -f Makefile common/config.h config.status"
X
Xecho ""
Xecho "$(libdir):"
Xecho "	-mkdir $(libdir)"
Xecho "	-chmod 755 $(libdir)"
X
XALLinst=
Xfor f in $ALL
Xdo
X	root=`basename $f`
X	ALLinst="$ALLinst $(bindir)/$root"
X
X	echo ""
X	echo "$(bindir)/$root: $f"
X	echo "	$(INSTALL_PROGRAM) $f $(bindir)/$root"
Xdone
X
Xecho ""
Xecho "install-bin:" $ALLinst
X
Xecho ""
Xecho "install-man:" $man_files
X
Xecho ""
Xecho "install-lib:" $lib_files
X
Xecho ""
Xecho "install: install-bin install-man install-lib"
X
Xexit 0
END_OF_FILE
if test 5772 -ne `wc -c <'aux/Makefile.sh'`; then
    echo shar: \"'aux/Makefile.sh'\" unpacked with wrong size!
fi
# end of 'aux/Makefile.sh'
fi
if test -f 'aux/README.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aux/README.man'\"
else
echo shar: Extracting \"'aux/README.man'\" \(6341 characters\)
sed "s/^X//" >'aux/README.man' <<'END_OF_FILE'
X'\" t
X.\"	cook - a file construction tool
X.\"	Copyright (C) 1992, 1993, 1994 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: source of the README file
X.\"
X.TH readme cook
X.so ../doc/version.so
X.hy 0
X.ad l
X.SH NAME
Xcook \- a file construction tool
X.SH DESCRIPTION
XPut simply,
Xthe
X.I cook
Xprogram is yet another make-oid.
X.PP
XThe
X.I cook
Xprogram is a tool for constructing files.
XIt is given a set of files to create,
Xand recipes of how to create them.
XIn any non-trivial program there will be
Xprerequisites to performing the actions necessary to
Xcreating any file,
Xsuch as include files.
XThe
X.I cook
Xprogram provides a mechanism to define these.
X.PP
XWhen a program is being developed or maintained,
Xthe programmer will typically change one file of several which
Xcomprise the program.
XThe
X.I cook
Xprogram examines the last-modified times of the files
Xto see when the prerequisites of a file have changed,
Ximplying that the file needs to be recreated as it is logically out of date.
X.PP
XThe
X.I cook
Xprogram also provides a facility for implicit recipes,
Xallowing users to specify how to form a file with a
Xgiven suffix from a file with a different suffix.
XFor example,
Xto create
X.IR filename .o
Xfrom
X.IR filename .c
X.br
X.ne 1i
X.SH NEW IN THIS RELEASE
XA number of features have been added to
X.I cook
Xwith this release.
XA few of them are detailed here:
X.so new.so
X.PP
XPlus the usual crop of bug fixes and tinkering.
XFor excruciating detail,
Xand also acknowlegements of those who generously sent me feedback,
Xplease see the
X.I aux/CHANGES.\*(v)
Xfile included in this distribution.
X.br
X.ne 1i
X.SH HISTORY
XThe
X.I cook
Xprogram was originally developed (starting in 1988)
Xbecause I was marooned on an operating system without
Xanything even vaguely resembling make(1).
XSince I had to write my own,
XI added a few improvements.
XWhen I finally escaped back to UNIX,
Xit took only two days to port
X.I cook
Xto SystemV.
XI have since deleted all code for that original operating system,
Xalthough clues to its identity are still present.
XThere is no prize for guessing what it was.
X.PP
XAfter I had
X.I cook
Xup on UNIX,
Xthe progress the world had made caught up with me.
XIt was gratifying that many of the
Xfeatures other make-oid authors had thought necessary were
Xeither already present,
Xor easily and seamlessly added.
X.br
X.ne 1i
X.SH ARCHIVE SITE
XThe latest version of
X.I cook
Xis available by anonymous ftp from:
X.RS 4m
X.TS
Xtab(;);
Xl l s
Xl l l.
XHost:;ftp.cse.nau.edu (134.114.64.70)
XDir:;/pub/Aegis
XFile:;README;# what is in this directory
XFile:;cook.\*(v).tar.gz;# the complete source
XFile:;cook.\*(v).patch.gz;# patch to take \*(w) to \*(v)
XFile:;cook.\*(v).ps.gz;# PostScript of the Manual
X.TE
X.RE
X.PP
XTo use anonymous ftp,
Xgive "anonymous" as the user name (omit the quotes)
Xand your email address as the password.
X.PP
XMy grateful thanks to Paul Balyoz <pab@ftp.cse.nau.edu>
Xfor his generosity in providing this archive space.
X.PP
XThis directory also contains a few other pieces of software written by me.
XPlease have a look if you are interested.
X.PP
XFor those of you without ftp,
XI recommend the use of an ftp-by-email server.
XHere is a list of a few (there are many more):
X.RS
X.nf
Xftpmail@decwrl.dec.com
Xftpmail@cs.uow.edu.au
X.fi
X.RE
X.PP
XIn general, you can get a help message about how to use each system
Xby sending email with a subject of "help"
Xand a message body containing just the word "help".
X.br
X.ne 1i
X.SH MAILING LIST
XA mailing list has been created so that users of
X.I cook
Xmay exchange ideas about how to use the
X.I cook
Xprogram.
XDiscussion may include,
Xbut is not limited to:
Xbugs, enhancements, and applications.
XThe list is not moderated.
X.PP
XThe address of the mailing list is
X.RS
X.ft CW
Xcook-users@bmr.gov.au
X.ft R
X.RE
X.PP
XTo subscribe to this mailing list,
Xsend an email message to \f(CWmajordomo@bmr.gov.au\fP with
Xa message body containing the single line
X.RS
X.ft CW
Xsubscribe cook-users
X.ft R
X.RE
XPlease note that \f(CWbmr.gov.au\fP is an Internet site,
Xso if you have an address which is not readily derived from
Xyour mail headers (majordomo is only a Perl program, after all)
Xyou will need to use a message of the form:
X.RS
X.ft CW
Xsubscribe cook-users \fIaddress\fP
X.ft R
X.RE
Xwhere \fIaddress\fP is an email address which
Xmakes sense from an Internet site.
X.PP
XThe software which handles this mailing list
X.if n CANNOT
X.if t .B cannot
Xsend you a copy of the
X.I cook
Xprogram.
XPlease use ftp or ftp-by-email, instead.
X.br
X.ne 1i
X.SH BUILDING COOK
XFull instructions for building the
X.I cook
Xprogram may be found in the
X.I BUILDING
Xfile included in this distribution.
X.br
X.ne 1i
X.SH COPYRIGHT
X.I cook
Xversion \*(v)
X.br
XCopyright
X.if t \(co
X.if n (C)
X1988, 1989, 1990, 1991, 1992, 1993, 1994 Peter Miller.
X.br
XAll rights reserved.
X.PP
XThis program is free software;
Xyou can redistribute it
Xand/or modify it under the terms of the GNU General Public
XLicense as published by the Free Software Foundation;
Xeither version 2 of the License,
Xor (at your option) any later version.
X.PP
XThis program is distributed in the hope that it will be useful,
Xbut WITHOUT ANY WARRANTY;
Xwithout even the implied
Xwarranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
XPURPOSE.
XSee the GNU General Public License for more details.
X.PP
XYou should have received a copy of the GNU General Public
XLicense along with this program; if not, write to the Free
XSoftware Foundation, Inc., 675 Mass Ave, Cambridge, MA
X02139, USA.
X.PP
XIt should be in the
X.I LICENSE
Xfile included with this distribution.
X.br
X.ne 1i
X.SH AUTHOR
X.TS
Xtab(;);
Xl l l.
XPeter Miller;UUCP;uunet!munnari!bmr.gov.au!pmiller
X\f(CW/\e/\e*\fP;Internet;pmiller@bmr.gov.au
X.TE
END_OF_FILE
if test 6341 -ne `wc -c <'aux/README.man'`; then
    echo shar: \"'aux/README.man'\" unpacked with wrong size!
fi
# end of 'aux/README.man'
fi
if test -f 'common/fp/crc32.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/fp/crc32.c'\"
else
echo shar: Extracting \"'common/fp/crc32.c'\" \(6705 characters\)
sed "s/^X//" >'common/fp/crc32.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate crc32 fingerprints
X *
X * Derived from code marked:
X *	a few improvements by DJB 930708
X *	nonreverse table included by DJB 930622
X *	interface mods by DJB 930529
X *	COPYRIGHT (C) 1986 Gary S. Brown.  You may use this program, or
X *	code or tables extracted from it, as desired without restriction.
X *	X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0
X *	polynomial $edb88320
X */
X
X#include <stdio.h>
X
X#include <fp/crc32.h>
X
X#define CRC32_HASH_LEN 4
X
Xtypedef struct crc32_ty crc32_ty;
Xstruct crc32_ty
X{
X	FINGERPRINT_BASE_CLASS
X	unsigned long	c;
X	unsigned char	len[8];
X};
X
X
Xstatic unsigned long crc_32_tab[] =
X{
X	0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
X	0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
X	0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd, 0x4c11db70, 0x48d0c6c7,
X	0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
X	0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3,
X	0x709f7b7a, 0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
X	0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58, 0xbaea46ef,
X	0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
X	0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb,
X	0xceb42022, 0xca753d95, 0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
X	0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,
X	0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
X	0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4,
X	0x0808d07d, 0x0cc9cdca, 0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
X	0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08,
X	0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
X	0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc,
X	0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
X	0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a, 0xe0b41de7, 0xe4750050,
X	0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
X	0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,
X	0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
X	0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb, 0x4f040d56, 0x4bc510e1,
X	0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
X	0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5,
X	0x3f9b762c, 0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
X	0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e, 0xf5ee4bb9,
X	0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
X	0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd,
X	0xcda1f604, 0xc960ebb3, 0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
X	0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,
X	0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
X	0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2,
X	0x470cdd2b, 0x43cdc09c, 0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
X	0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e,
X	0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
X	0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a,
X	0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
X	0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c, 0xe3a1cbc1, 0xe760d676,
X	0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
X	0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,
X	0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
X	0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
X};
X
X
Xstatic void reset _((crc32_ty *));
X
Xstatic void
Xreset(c)
X	crc32_ty	*c;
X{
X	c->c = 0;
X	c->len[0] = 0;
X	c->len[1] = 0;
X	c->len[2] = 0;
X	c->len[3] = 0;
X	c->len[4] = 0;
X	c->len[5] = 0;
X	c->len[6] = 0;
X	c->len[7] = 0;
X}
X
X
Xstatic void crc32_constructor _((fingerprint_ty *));
X
Xstatic void
Xcrc32_constructor(p)
X	fingerprint_ty	*p;
X{
X	crc32_ty	*c;
X
X	c = (crc32_ty *)p;
X	reset(c);
X}
X
X
Xstatic void crc32_destructor _((fingerprint_ty *));
X
Xstatic void
Xcrc32_destructor(p)
X	fingerprint_ty	*p;
X{
X}
X
X
Xstatic void crc32_addn _((fingerprint_ty *, unsigned char *, int));
X
Xstatic void
Xcrc32_addn(p, s, n)
X	fingerprint_ty	*p;
X	unsigned char	*s;
X	int		n;
X{
X	crc32_ty	*c;
X	unsigned long	x;
X	unsigned char	newc;
X	int		i;
X
X	c = (crc32_ty *)p;
X	i = n;
X	while (i >= 256)
X	{
X		if (!++c->len[1])
X			if (!++c->len[2])
X				if (!++c->len[3])
X					if (!++c->len[4])
X						if (!++c->len[5])
X							if (!++c->len[6])
X								++c->len[7];
X		i -= 256;
X	}
X	newc = i;
X	if ((c->len[0] += newc) < newc)
X		if (!++c->len[1])
X			if (!++c->len[2])
X				if (!++c->len[3])
X					if (!++c->len[4])
X						if (!++c->len[5])
X							if (!++c->len[6])
X								++c->len[7];
X	i = n;
X	x = c->c;
X	while (i--)
X		x = crc_32_tab[(int)((x >> 24) ^ *s++) & 0xff] ^ (x << 8);
X	c->c = x;
X}
X
X
Xstatic int crc32_hash _((fingerprint_ty *, unsigned char *));
X
Xstatic int
Xcrc32_hash(p, h)
X	fingerprint_ty	*p;
X	unsigned char	*h;
X{
X	crc32_ty	*c;
X	unsigned long	x;
X	unsigned char	len[8];
X	int		i;
X
X	c = (crc32_ty *)p;
X	for (i = 0; i < 8; ++i)
X		len[i] = c->len[i];
X	for (i = 7; i >= 0; --i)
X		if (len[i])
X			break;
X	crc32_addn(p, len, i + 1);
X	x = ~c->c;
X	h[0] = x & 255;
X	h[1] = (x >> 8) & 255;
X	h[2] = (x >> 16) & 255;
X	h[3] = (x >> 24) & 255;
X	reset(c);
X	return CRC32_HASH_LEN;
X}
X
X
Xstatic void crc32_sum _((fingerprint_ty *, char *));
X
Xstatic void
Xcrc32_sum(p, obuf)
X	fingerprint_ty	*p;
X	char		*obuf;
X{
X	unsigned char	h[CRC32_HASH_LEN];
X
X	crc32_hash(p, h);
X	sprintf
X	(
X		obuf,
X		"%10lu",
X		h[0] + 256L * (h[1] + 256L * (h[2] + 256L * h[3]))
X	);
X}
X
X
Xfingerprint_methods_ty fp_crc32 =
X{
X	sizeof(crc32_ty),
X	"crc32",
X	crc32_constructor,
X	crc32_destructor,
X	crc32_addn,
X	crc32_hash,
X	crc32_sum
X};
END_OF_FILE
if test 6705 -ne `wc -c <'common/fp/crc32.c'`; then
    echo shar: \"'common/fp/crc32.c'\" unpacked with wrong size!
fi
# end of 'common/fp/crc32.c'
fi
if test -f 'common/word.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/word.c'\"
else
echo shar: Extracting \"'common/word.c'\" \(7099 characters\)
sed "s/^X//" >'common/word.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate lists of strings
X *
X * This file contains routines for mainpulating words and word lists.
X * Much of the functionality of cook uses these routines.
X */
X
X#include <ctype.h>
X#include <ac/stddef.h>
X#include <ac/string.h>
X#include <ac/stdlib.h>
X#include <ac/time.h>
X
X#include <error.h>
X#include <main.h>
X#include <mem.h>
X#include <str.h>
X#include <word.h>
X
X
X/*
X * NAME
X *	wl_append - append to a word list
X *
X * SYNOPSIS
X *	void wl_append(wlist *wlp, string_ty *wp);
X *
X * DESCRIPTION
X *	Wl_append is used to append to a word list.
X *
X * CAVEAT
X *	The word being appended IS copied.
X */
X
Xvoid
Xwl_append(wlp, w)
X	wlist		*wlp;
X	string_ty	*w;
X{
X	size_t		nbytes;
X
X	assert(wlp);
X	assert(w);
X	nbytes = (wlp->wl_nwords + 1) * sizeof(string_ty *);
X	wlp->wl_word = mem_change_size(wlp->wl_word, nbytes);
X	wlp->wl_word[wlp->wl_nwords++] = str_copy(w);
X}
X
X
Xvoid
Xwl_prepend(wlp, w)
X	wlist		*wlp;
X	string_ty	*w;
X{
X	long		j;
X	size_t		nbytes;
X
X	assert(wlp);
X	assert(w);
X	wlp->wl_nwords++;
X	nbytes = wlp->wl_nwords * sizeof(string_ty *);
X	wlp->wl_word = mem_change_size(wlp->wl_word, nbytes);
X	for (j = wlp->wl_nwords - 1; j > 0; --j)
X		wlp->wl_word[j] = wlp->wl_word[j - 1];
X	wlp->wl_word[0] = str_copy(w);
X}
X
X
X/*
X * NAME
X *	wl_free - free a word list
X *
X * SYNOPSIS
X *	void wl_free(wlist *wlp);
X *
X * DESCRIPTION
X *	Wl_free is used to free the contents of a word list
X *	when it is finished with.
X *
X * CAVEAT
X *	It is assumed that the contents of the word list were all
X *	created using strdup() or similar, and grown using wl_append().
X */
X
Xvoid
Xwl_free(wlp)
X	wlist		*wlp;
X{
X	int		j;
X
X	for (j = 0; j < wlp->wl_nwords; j++)
X		str_free(wlp->wl_word[j]);
X	if (wlp->wl_nwords)
X		free(wlp->wl_word);
X	wlp->wl_nwords = 0;
X	wlp->wl_word = 0;
X}
X
X
X/*
X * NAME
X *	wl_member - word list membership
X *
X * SYNOPSIS
X *	int wl_member(wlist *wlp, string_ty *wp);
X *
X * DESCRIPTION
X *	Wl_member is used to determine if the given word is
X *	contained in the given word list.
X *
X * RETURNS
X *	A zero if the word is not in the list,
X *	and a non-zero if it is.
X */
X
Xint
Xwl_member(wlp, w)
X	wlist		*wlp;
X	string_ty	*w;
X{
X	int		j;
X
X	for (j = 0; j < wlp->wl_nwords; j++)
X		if (str_equal(wlp->wl_word[j], w))
X			return 1;
X	return 0;
X}
X
X
X/*
X * NAME
X *	wl_copy - copy a word list
X *
X * SYNOPSIS
X *	void wl_copy(wlist *to, wlist *from);
X *
X * DESCRIPTION
X *	Wl_copy is used to copy word lists.
X *
X * RETURNS
X *	A copy of the 'to' word list is placed in 'from'.
X *
X * CAVEAT
X *	It is the responsibility of the caller to ensure that the
X *	new word list is freed when finished with, by a call to wl_free().
X */
X
Xvoid
Xwl_copy(to, from)
X	wlist		*to;
X	wlist		*from;
X{
X	int		j;
X
X	wl_zero(to);
X	for (j = 0; j < from->wl_nwords; j++)
X		wl_append(to, str_copy(from->wl_word[j]));
X}
X
X
X/*
X * NAME
X *	wl2str - form a string from a word list
X *
X * SYNOPSIS
X *	string_ty *wl2str(wlist *wlp, int start, int stop, char *sep);
X *
X * DESCRIPTION
X *	Wl2str is used to form a string from a word list.
X *
X * RETURNS
X *	A pointer to the newly formed string in dynamic memory.
X *
X * CAVEAT
X *	It is the responsibility of the caller to ensure that the
X *	new string is freed when finished with, by a call to free().
X */
X
Xstring_ty *
Xwl2str(wl, start, stop, sep)
X	wlist		*wl;
X	int		start;
X	int		stop;
X	char		*sep;
X{
X	int		j;
X	static char	*tmp;
X	static size_t	tmplen;
X	size_t		length;
X	size_t		seplen;
X	char		*pos;
X	string_ty	*s;
X
X	if (!sep)
X		sep = " ";
X	seplen = strlen(sep);
X	length = 0;
X	for (j = start; j <= stop && j < wl->wl_nwords; j++)
X	{
X		s = wl->wl_word[j];
X		if (s->str_length)
X		{
X			if (length)
X				length += seplen;
X			length += s->str_length;
X		}
X	}
X
X	if (tmplen < length)
X	{
X		tmplen = length;
X		tmp = mem_change_size(tmp, tmplen);
X	}
X
X	pos = tmp;
X	for (j = start; j <= stop && j < wl->wl_nwords; j++)
X	{
X		s = wl->wl_word[j];
X		if (s->str_length)
X		{
X			if (pos != tmp)
X			{
X				memcpy(pos, sep, seplen);
X				pos += seplen;
X			}
X			memcpy(pos, s->str_text, s->str_length);
X			pos += s->str_length;
X		}
X	}
X
X	s = str_n_from_c(tmp, length);
X	return s;
X}
X
X
X/*
X * NAME
X *	str2wl - string to word list
X *
X * SYNOPSIS
X *	void str2wl(wlist *wlp, string_ty *s, char *sep, int ewhite);
X *
X * DESCRIPTION
X *	Str2wl is used to form a word list from a string.
X *	wlp	- where to put the word list
X *	s	- string to break
X *	sep	- separators, default to " " if 0 given
X *	ewhite	- supress extra white space around separators
X *
X * RETURNS
X *	The string is broken on spaces into words,
X *	using strndup() and wl_append().
X *
X * CAVEAT
X *	Quoting is not understood.
X */
X
Xvoid
Xstr2wl(slp, s, sep, ewhite)
X	wlist		*slp;
X	string_ty	*s;
X	char		*sep;
X	int		ewhite;
X{
X	char		*cp;
X	int		more;
X
X	if (!sep)
X	{
X		sep = " \t\n\f\r";
X		ewhite = 1;
X	}
X	wl_zero(slp);
X	cp = s->str_text;
X	more = 0;
X	while (*cp || more)
X	{
X		string_ty	*w;
X		char		*cp1;
X		char		*cp2;
X
X		if (ewhite)
X			while (isspace(*cp))
X				cp++;
X		if (!*cp && !more)
X			break;
X		more = 0;
X		cp1 = cp;
X		while (*cp && !strchr(sep, *cp))
X			cp++;
X		if (*cp)
X		{
X			cp2 = cp + 1;
X			more = 1;
X		}
X		else
X			cp2 = cp;
X		if (ewhite)
X			while (cp > cp1 && isspace(cp[-1]))
X				cp--;
X		w = str_n_from_c(cp1, cp - cp1);
X		wl_append(slp, w);
X		str_free(w);
X		cp = cp2;
X	}
X}
X
X
X/*
X * NAME
X *	wl_insert - a insert a word into a list
X *
X * SYNOPSIS
X *	void wl_insert(wlist *wlp, string_ty *wp);
X *
X * DESCRIPTION
X *	Wl_insert is similar to wl_append, however it does not
X *	append the word unless it is not already in the list.
X *
X * CAVEAT
X *	If the word is inserted it is copied.
X */
X
Xvoid
Xwl_append_unique(wlp, wp)
X	wlist		*wlp;
X	string_ty	*wp;
X{
X	int		j;
X
X	for (j = 0; j < wlp->wl_nwords; j++)
X		if (str_equal(wlp->wl_word[j], wp))
X			return;
X	wl_append(wlp, wp);
X}
X
X
X/*
X * NAME
X *	wl_delete - remove list member
X *
X * SYNOPSIS
X *	void wl_delete(wlist *wlp, string_ty *wp);
X *
X * DESCRIPTION
X *	The wl_delete function is used to delete a member of a word list.
X *
X * RETURNS
X *	void
X */
X
Xvoid
Xwl_delete(wlp, wp)
X	wlist		*wlp;
X	string_ty	*wp;
X{
X	int		j;
X	int		k;
X
X	for (j = 0; j < wlp->wl_nwords; ++j)
X	{
X		if (str_equal(wlp->wl_word[j], wp))
X		{
X			wlp->wl_nwords--;
X			for (k = j; k < wlp->wl_nwords; ++k)
X				wlp->wl_word[k] = wlp->wl_word[k + 1];
X			str_free(wp);
X			break;
X		}
X	}
X}
X
Xvoid
Xwl_zero(wlp)
X	wlist		*wlp;
X{
X	wlp->wl_nwords = 0;
X	wlp->wl_word = 0;
X}
END_OF_FILE
if test 7099 -ne `wc -c <'common/word.c'`; then
    echo shar: \"'common/word.c'\" unpacked with wrong size!
fi
# end of 'common/word.c'
fi
if test -f 'cook/builtin.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/builtin.c'\"
else
echo shar: Extracting \"'cook/builtin.c'\" \(5571 characters\)
sed "s/^X//" >'cook/builtin.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to access the builtin functions
X *
X * The builtin functions all append their results to the supplied
X * `result' word list.  The first word of the `args' word list
X * is the name of the function.
X *
X * all of the functions return 0 in success, or -1 on error.
X *
X * Only a limited set of functionality is candidate for builtin functions,
X * these are 
X *	- string manipulation [dirname, stringset, ect ]
X *	- environment manipulation [getenv(3), etc]
X *	- stat(3) related functions [exists, mtime, pathname, etc]
X *	- launching OS commands [execute, collect]
X * The above list is though to be exhaustive.
X *
X * Explicitly and forever excluded from being a builtin function
X * is anything which knows or understands the format of some secific 
X * class of files.
X *
X * Access to stdio(3) has been thought of, and explicitly avoided.
X * Mostly because a specialist program used through [collect]
X * will almost always be far faster.
X */
X
X#include <builtin.h>
X#include <builtin/addprefix.h>
X#include <builtin/addsuffix.h>
X#include <builtin/basename.h>
X#include <builtin/boolean.h>
X#include <builtin/collect.h>
X#include <builtin/cook.h>
X#include <builtin/defined.h>
X#include <builtin/execute.h>
X#include <builtin/exists.h>
X#include <builtin/filter_out.h>
X#include <builtin/find_command.h>
X#include <builtin/findstring.h>
X#include <builtin/getenv.h>
X#include <builtin/glob.h>
X#include <builtin/home.h>
X#include <builtin/join.h>
X#include <builtin/match.h>
X#include <builtin/opsys.h>
X#include <builtin/pathname.h>
X#include <builtin/split.h>
X#include <builtin/stringset.h>
X#include <builtin/strip.h>
X#include <builtin/subst.h>
X#include <builtin/suffix.h>
X#include <builtin/text.h>
X#include <builtin/unsplit.h>
X#include <builtin/word.h>
X#include <symtab.h>
X
X
Xtypedef struct func_ty func_ty;
Xstruct func_ty
X{
X	char	*f_name;
X	bifp	f_code;
X};
X
Xstatic symtab_ty *symtab;
X
X
X/*
X * NAME
X *	func - table of built-in functions
X *
X * SYNOPSIS
X *	func_ty func[];
X *
X * DESCRIPTION
X *	Func is a table of function names and pointers
X *	for the built-in functions of cook.
X */
X
Xstatic func_ty func[] =
X{
X	{ "addprefix",		builtin_addprefix,	},
X	{ "addsuffix",		builtin_addsuffix,	},
X	{ "and",		builtin_and,		},
X	{ "basename",		builtin_basename,	},
X	{ "cando",		builtin_cando,		},
X	{ "catenate",		builtin_catenate,	},
X	{ "collect",		builtin_collect,	},
X	{ "collect_lines",	builtin_collect,	},
X	{ "count",		builtin_count,		},
X	{ "defined",		builtin_defined,	},
X	{ "dir",		builtin_dir,		},
X	{ "dirname",		builtin_dir,		},
X	{ "downcase",		builtin_downcase,	},
X	{ "entryname",		builtin_entryname,	},
X	{ "execute",		builtin_execute,	},
X	{ "exists",		builtin_exists,		},
X	{ "filter",		builtin_match_mask,	},
X	{ "filter-out",		builtin_filter_out,	},
X	{ "filter_out",		builtin_filter_out,	},
X	{ "find_command",	builtin_find_command,	},
X	{ "findstring",		builtin_findstring,	},
X	{ "fromto",		builtin_fromto,		},
X	{ "getenv",		builtin_getenv,		},
X	{ "glob",		builtin_glob,		},
X	{ "head",		builtin_head,		},
X	{ "home",		builtin_home,		},
X	{ "if",			builtin_if,		},
X	{ "in",			builtin_in,		},
X	{ "join",		builtin_join,		},
X	{ "match",		builtin_match,		},
X	{ "match_mask",		builtin_match_mask,	},
X	{ "matches",		builtin_match,		},
X	{ "mtime",		builtin_mtime,		},
X	{ "not",		builtin_not,		},
X	{ "operating_system",	builtin_opsys,		},
X	{ "or",			builtin_or,		},
X	{ "os",			builtin_opsys,		},
X	{ "pathname",		builtin_pathname,	},
X	{ "patsubst",		builtin_fromto,		},
X	{ "prepost",		builtin_prepost,	},
X	{ "quote",		builtin_quote,		},
X	{ "resolve",		builtin_resolve,	},
X	{ "shell",		builtin_collect,	},
X	{ "sort",		builtin_sort,		},
X	{ "sort_newest",	builtin_sort_newest,	},
X	{ "split",		builtin_split,		},
X	{ "stringset",		builtin_stringset,	},
X	{ "strip",		builtin_strip,		},
X	{ "subst",		builtin_subst,		},
X	{ "suffix",		builtin_suffix,		},
X	{ "tail",		builtin_tail,		},
X	{ "unsplit",		builtin_unsplit,	},
X	{ "upcase",		builtin_upcase,		},
X	{ "uptodate",		builtin_uptodate,	},
X	{ "wildcard",		builtin_glob,		},
X	{ "word",		builtin_word,		},
X	{ "words",		builtin_count,		},
X};
X
X
X/*
X * NAME
X *	builtin_initialize - start up builtins
X *
X * SYNOPSIS
X *	void builtin_initialize(void);
X *
X * DESCRIPTION
X *	The builtin_initialize function is used to initialize the symbol table
X *	with the names and pointers to the builtin functions.
X *
X * CAVEAT
X *	This function must be called after the id_initialize function.
X */
X
Xvoid
Xbuiltin_initialize()
X{
X	func_ty		*fp;
X	string_ty	*s;
X
X	if (!symtab)
X		symtab = symtab_alloc(SIZEOF(func));
X	for (fp = func; fp < ENDOF(func); ++fp)
X	{
X		s = str_from_c(fp->f_name);
X		symtab_assign(symtab, s, fp->f_code);
X		str_free(s);
X	}
X}
X
X
Xbifp
Xbuiltin_search(name)
X	string_ty	*name;
X{
X	if (!symtab)
X		return 0;
X	return symtab_query(symtab, name);
X}
END_OF_FILE
if test 5571 -ne `wc -c <'cook/builtin.c'`; then
    echo shar: \"'cook/builtin.c'\" unpacked with wrong size!
fi
# end of 'cook/builtin.c'
fi
if test -f 'cook/builtin/boolean.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/builtin/boolean.c'\"
else
echo shar: Extracting \"'cook/builtin/boolean.c'\" \(7035 characters\)
sed "s/^X//" >'cook/builtin/boolean.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to implement the builtin functions
X *
X * The builtin function all append their results to the supplied
X * `result' word list.  The first word of the `args' word list
X * is the name of the function.
X *
X * all of the functions return 0 in success, or -1 on error.
X */
X
X#include <builtin/boolean.h>
X#include <error.h>
X#include <expr.h>
X
X
X/*
X * NAME
X *	builtin_if - conditional evaluation
X *
X * SYNOPSIS
X *	int builtin_if(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	Defined is a built-in function of if, described as follows:
X *	This function requires one or more arguments.
X *	The condition before the 'then' keyword is evaluated,
X *	if true, the words between the 'then' and the 'else' are the result,
X *	otherwise the words between the 'else' and the end are the value.
X *	The else is optional.
X *
X * RETURNS
X *	Appropriate things, see above.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X *
X *	'then' and 'else' cant be escaped, sorry.
X */
X
Xint
Xbuiltin_if(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X	int		cond;
X	static string_ty	*str_then;
X	static string_ty	*str_else;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	if (args->wl_nwords < 2)
X	{
X		expr_error
X		(
X			"%s: requires one or more arguments",
X			args->wl_word[0]->str_text
X		);
X		return -1;
X	}
X	cond = 0;
X	if (!str_then)
X		str_then = str_from_c("then");
X	if (!str_else)
X		str_else = str_from_c("else");
X	for
X	(
X		j = 1;
X		j < args->wl_nwords && !str_equal(str_then, args->wl_word[j]);
X		j++
X	)
X		cond |= str_bool(args->wl_word[j]);
X	if (j >= args->wl_nwords)
X	{
X		expr_error("%s: no 'then' word", args->wl_word[0]->str_text);
X		return -1;
X	}
X	j++;
X	if (cond)
X	{
X		while
X		(
X			j < args->wl_nwords
X		&&
X			!str_equal(str_else, args->wl_word[j])
X		)
X		{
X			wl_append(result, args->wl_word[j]);
X			j++;
X		}
X	}
X	else
X	{
X		while
X		(
X			j < args->wl_nwords
X		&&
X			!str_equal(str_else, args->wl_word[j])
X		)
X			j++;
X		if (j < args->wl_nwords)
X		{
X			j++;
X			while (j < args->wl_nwords)
X			{
X				wl_append(result, args->wl_word[j]);
X				++j;
X			}
X		}
X	}
X	return 0;
X}
X
X
X/*
X * NAME
X *	builtin_not - logical negation
X *
X * SYNOPSIS
X *	int builtin_not(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	Not is a built-in function of cook, described as follows:
X *	This function requires zero or more arguments,
X *	the value to be logically negated.
X *
X * RETURNS
X *	It returns "1" (true) if all of the arguments are "" (false), or there
X *	are no arguments; and returns "" (false) otherwise.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_not(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	for (j = 1; j < args->wl_nwords; j++)
X	{
X		if (str_bool(args->wl_word[j]))
X		{
X			wl_append(result, str_false);
X			return 0;
X		}
X	}
X	wl_append(result, str_true);
X	return 0;
X}
X
X
X/*
X * NAME
X *	builtin_and - logical conjunction
X *
X * SYNOPSIS
X *	int builtin_and(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	And is a built-in function of cook, described as follows:
X *	This function requires at least two arguments,
X *	upon which it forms a logical conjunction.
X *
X * RETURNS
X *	The value returned is "1" (true) if none of the arguments
X *	are "" (false), otherwise "" (false) is returned.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_and(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	if (args->wl_nwords < 3)
X	{
X		expr_error
X		(
X			"%s: requires at least two arguments",
X			args->wl_word[0]->str_text
X		);
X		return -1;
X	}
X	for (j = 1; j < args->wl_nwords; j++)
X	{
X		if (!str_bool(args->wl_word[j]))
X		{
X			wl_append(result, str_false);
X			return 0;
X		}
X	}
X	wl_append(result, str_true);
X	return 0;
X}
X
X
X/*
X * NAME
X *	builtin_or - logical disjunction
X *
X * SYNOPSIS
X *	int builtin_or(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	Or is a built-in function of cook, described as follows:
X *	This function requires at least two arguments,
X *	upon which it forms a logical disjunction.
X *
X * RETURNS
X *	The value returned is "1" (true) if any one of the arguments is
X *	not "" (false), otherwise "" (false) is returned.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_or(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	if (args->wl_nwords < 3)
X	{
X		expr_error
X		(
X			"%s: requires at least two arguments",
X			args->wl_word[0]->str_text
X		);
X		return -1;
X	}
X	for (j = 1; j < args->wl_nwords; j++)
X	{
X		if (str_bool(args->wl_word[j]))
X		{
X			wl_append(result, str_true);
X			return 0;
X		}
X	}
X	wl_append(result, str_false);
X	return 0;
X}
X
X
X/*
X * NAME
X *	builtin_in - test for set membership
X *
X * SYNOPSIS
X *	int builtin_in(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	In is a built-in function of cook, described as follows:
X *	This function requires one or more arguments.
X *
X * RETURNS
X *	A word list containg a single word: "1" (true) if the first argument
X *	is the same as any of the later ones; "" (false) if not.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_in(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	if (args->wl_nwords < 2)
X	{
X		expr_error
X		(
X			"%s: requires one or more arguments",
X			args->wl_word[0]->str_text
X		);
X		return -1;
X	}
X	for (j = 2; j < args->wl_nwords; j++)
X	{
X		if (str_equal(args->wl_word[1], args->wl_word[j]))
X		{
X			wl_append(result, str_true);
X			return 0;
X		}
X	}
X	wl_append(result, str_false);
X	return 0;
X}
END_OF_FILE
if test 7035 -ne `wc -c <'cook/builtin/boolean.c'`; then
    echo shar: \"'cook/builtin/boolean.c'\" unpacked with wrong size!
fi
# end of 'cook/builtin/boolean.c'
fi
if test -f 'cook/builtin/match.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/builtin/match.c'\"
else
echo shar: Extracting \"'cook/builtin/match.c'\" \(5452 characters\)
sed "s/^X//" >'cook/builtin/match.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to implement the builtin functions
X *
X * The builtin function all append their results to the supplied
X * `result' word list.  The first word of the `args' word list
X * is the name of the function.
X *
X * all of the functions return 0 in success, or -1 on error.
X *
X * Only a limited set of this are candidates for builtin functions,
X * these are 
X *	- string manipulation [dirname, stringset, ect ]
X *	- environment manipulation [getenv(3), etc]
X *	- stat(3) related functions [exists, mtime, pathname, etc]
X *	- launching OS commands [execute, collect]
X * The above list is though to be exhaustive.
X *
X * This explicitly and forever excluded from being a builtin function
X * is anything which known or understands the format of some secific 
X * class of files.
X *
X * Access to stdio(3) has been thought of, and explicitly avoided.
X * Mostly because a specialist program used through [collect]
X * will almost always be far faster.
X */
X
X#include <builtin/match.h>
X#include <error.h>
X#include <expr.h>
X#include <match.h>
X
X
X/*
X * NAME
X *	builtin_match - wildcard mapping
X *
X * SYNOPSIS
X *	int builtin_match(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	Fromto is a built-in function of cook, described as follows:
X *	This function requires at least two arguments.
X *	Fromto gives the user access to the wildcard transformations
X *	available to cook.
X *	The first argument is the "from" form,
X *	the second argument is the "to" form.
X *
X * RETURNS
X *	All other arguments are mapped from one to the other.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_match(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X	match_ty	*field;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	if (args->wl_nwords < 2)
X	{
X		expr_error
X		(
X			"%s: requires one or more arguments",
X			args->wl_word[0]->str_text
X		);
X		return -1;
X	}
X	for (j = 2; j < args->wl_nwords; j++)
X	{
X		field = match(args->wl_word[1], args->wl_word[j]);
X		if (field)
X		{
X			wl_append(result, str_true);
X			match_free(field);
X		}
X		else
X			wl_append(result, str_false);
X	}
X	return 0;
X}
X
X
X/*
X * NAME
X *	builtin_match - wildcard mapping
X *
X * SYNOPSIS
X *	int builtin_match(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	Fromto is a built-in function of cook, described as follows:
X *	This function requires at least two arguments.
X *	Fromto gives the user access to the wildcard transformations
X *	available to cook.
X *	The first argument is the "from" form,
X *	the second argument is the "to" form.
X *
X * RETURNS
X *	All other arguments are mapped from one to the other.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_match_mask(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X	match_ty	*field;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	if (args->wl_nwords < 2)
X	{
X		expr_error
X		(
X			"%s: requires one or more arguments",
X			args->wl_word[0]->str_text
X		);
X		return -1;
X	}
X	for (j = 2; j < args->wl_nwords; j++)
X	{
X		field = match(args->wl_word[1], args->wl_word[j]);
X		if (field)
X		{
X			wl_append(result, args->wl_word[j]);
X			match_free(field);
X		}
X	}
X	return 0;
X}
X
X
X/*
X * NAME
X *	builtin_fromto - wildcard mapping
X *
X * SYNOPSIS
X *	int builtin_fromto(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	Fromto is a built-in function of cook, described as follows:
X *	This function requires at least two arguments.
X *	Fromto gives the user access to the wildcard transformations
X *	available to cook.
X *	The first argument is the "from" form,
X *	the second argument is the "to" form.
X *
X * RETURNS
X *	All other arguments are mapped from one to the other.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_fromto(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X	match_ty	*field;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	if (args->wl_nwords < 3)
X	{
X		expr_error
X		(
X			"%s: requires at least two arguments",
X			args->wl_word[0]->str_text
X		);
X		return -1;
X	}
X	for (j = 3; j < args->wl_nwords; j++)
X	{
X		field = match(args->wl_word[1], args->wl_word[j]);
X		if (field)
X		{
X			string_ty	*s;
X
X			s = reconstruct(args->wl_word[2], field);
X			wl_append(result, s);
X			str_free(s);
X			match_free(field);
X		}
X		else
X			wl_append(result, args->wl_word[j]);
X	}
X	return 0;
X}
END_OF_FILE
if test 5452 -ne `wc -c <'cook/builtin/match.c'`; then
    echo shar: \"'cook/builtin/match.c'\" unpacked with wrong size!
fi
# end of 'cook/builtin/match.c'
fi
if test -f 'cook/fngrprnt.y' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/fngrprnt.y'\"
else
echo shar: Extracting \"'cook/fngrprnt.y'\" \(5403 characters\)
sed "s/^X//" >'cook/fngrprnt.y' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate the persistent fingerprint cache
X */
X
X%{
X#include <errno.h>
X#include <stdio.h>
X#include <ac/stdlib.h>
X#include <ac/unistd.h>
X
X#include <archive.h>
X#include <arglex.h>
X#include <error.h>
X#include <fngrprnt.h>
X#include <fngrprnt_lex.h>
X#include <fp/combined.h>
X#include <mem.h>
X#include <symtab.h>
X#include <trace.h>
X%}
X
X%token	STRING
X%token	JUNK
X%token	NUMBER
X%token	EQ
X%token	LB
X%token	RB
X
X%union
X{
X	string_ty	*lv_string;
X	long		lv_number;
X}
X
X%type	<lv_string>	STRING
X%type	<lv_number>	NUMBER
X
X%%
X
Xcache
X	: /* empty */
X	| cache entry
X	;
X
Xentry
X	: STRING EQ LB NUMBER NUMBER STRING RB
X		{
X			fp_ty	data;
X
X			data.oldest = $4;
X			data.newest = $5;
X			data.fingerprint = $6;
X			fp_assign($1, &data);
X			str_free($1);
X			str_free($6);
X		}
X	| STRING EQ LB NUMBER STRING RB
X		{
X			fp_ty	data;
X
X			data.oldest = $4;
X			data.newest = $4;
X			data.fingerprint = $5;
X			fp_assign($1, &data);
X			str_free($1);
X			str_free($5);
X		}
X	;
X
X%%
X
X
X
Xstatic symtab_ty *symtab;
Xstatic int	dirty;
Xstatic int	inited;
X
X
Xstatic void reap _((void *));
X
Xstatic void
Xreap(p)
X	void	*p;
X{
X	fp_ty	*fp;
X
X	trace(("reap(p = %08lX)\n{\n"/*}*/, (long)p));
X	fp = p;
X	str_free(fp->fingerprint);
X	mem_free(fp);
X	trace((/*{*/"}\n"));
X}
X
X
Xstatic char *fp_filename _((void));
X
Xstatic char *
Xfp_filename()
X{
X	static string_ty *s;
X
X	if (!s)
X		s = str_format(".%.10s.fp", progname);
X	return s->str_text;
X}
X
X
Xstatic void walk _((symtab_ty *, string_ty *, void *, void *));
X
Xstatic void
Xwalk(sp, key, p, arg)
X	symtab_ty	*sp;
X	string_ty	*key;
X	void		*p;
X	void		*arg;
X{
X	fp_ty		*data;
X	FILE		*fp;
X
X	trace(("walk(sp = %08lX, key = \"%s\", p = %08lX, arg = %08lX)\n{\n"/*}*/, (long)sp, key->str_text, (long)p, (long)arg));
X	data = p;
X	fp = arg;
X	if (data->oldest == data->newest)
X		fprintf
X		(
X			fp,
X			"\"%s\" = { %ld\n\"%s\" }\n",
X			key->str_text,
X			(long)data->newest,
X			data->fingerprint->str_text
X		);
X	else
X		fprintf
X		(
X			fp,
X			"\"%s\" = { %ld %ld\n\"%s\" }\n",
X			key->str_text,
X			(long)data->oldest,
X			(long)data->newest,
X			data->fingerprint->str_text
X		);
X	trace((/*{*/"}\n"));
X}
X
X
Xstatic void fp_close _((void));
X
Xstatic void
Xfp_close()
X{
X	char	*fn;
X	FILE	*fp;
X
X	if (!dirty)
X		return;
X	if (!inited)
X		return;
X	trace(("fp_close()\n{\n"/*}*/));
X	fn = fp_filename();
X	if (unlink(fn) && errno != ENOENT)
X		nerror("warning: unlink %s", fn);
X	trace(("open\n"));
X	fp = fopen(fn, "w");
X	if (!fp)
X		nfatal("open %s", fn);
X	trace(("walk\n"));
X	trace(("symtab = %08lX;\n", (long)symtab));
X	symtab_walk(symtab, walk, fp);
X	trace(("close\n"));
X	fflush(fp);
X	if (ferror(fp))
X	{
X		int	err;
X
X		err = errno;
X		unlink(fn); /* ignore error */
X		errno = err;
X		nfatal("write %s", fn);
X	}
X	fclose(fp);
X	dirty = 0;
X	trace((/*{*/"}\n"));
X}
X
X
Xstatic void init _((void));
X
Xstatic void
Xinit()
X{
X	int yyparse _((void));
X
X	if (inited)
X		return;
X	trace(("init()\n{\n"/*}*/));
X	inited = 1;
X	symtab = symtab_alloc(100);
X	symtab->reap = reap;
X	yylex_open(fp_filename());
X	yyparse();
X	yylex_close();
X	dirty = 0;
X	quit_handler(fp_close);
X	trace((/*{*/"}\n"));
X}
X
X
Xfp_ty *
Xfp_search(path)
X	string_ty	*path;
X{
X	fp_ty		*fp;
X
X	trace(("fp_search(path = \"%s\")\n{\n"/*}*/, path->str_text));
X	if (!inited)
X		init();
X	fp = symtab_query(symtab, path);
X	trace(("return %08lX;\n", (long)fp));
X	trace((/*{*/"}\n"));
X	return fp;
X}
X
X
Xvoid
Xfp_assign(path, fp)
X	string_ty	*path;
X	fp_ty		*fp;
X{
X	fp_ty		*data;
X
X	trace(("fp_assign(path = \"%s\", fp = %08lX)\n{\n"/*}*/,
X		path->str_text, (long)fp));
X	if (!inited)
X		init();
X	data = mem_alloc(sizeof(fp_ty));
X	data->oldest = fp->oldest;
X	data->newest = fp->newest;
X	data->fingerprint = str_copy(fp->fingerprint);
X	symtab_assign(symtab, path, data);
X	dirty = 1;
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xfp_delete(path)
X	string_ty	*path;
X{
X	if (!inited)
X		return;
X	trace(("fp_delete(path = \"%s\")\n{\n"/*}*/, path->str_text));
X	if (symtab_query(symtab, path))
X	{
X		symtab_delete(symtab, path);
X		dirty = 1;
X	}
X	trace((/*{*/"}\n"));
X}
X
X
Xstring_ty *
Xfp_fingerprint(path)
X	string_ty	*path;
X{
X	fingerprint_ty	*fp;
X	string_ty	*result;
X	int		err;
X	char		buffer[1000];
X
X	trace(("fp_fingerprint(path = \"%s\")\n{\n"/*}*/, path->str_text));
X	fp = fingerprint_new(&fp_combined);
X	err = fingerprint_file_sum(fp, path->str_text, buffer);
X	if (err && errno == ENOENT)
X		err = archive_fingerprint(fp, path, buffer);
X	if (err)
X	{
X		switch (errno)
X		{
X		case ENOTDIR:
X		case EISDIR:
X		case ENOENT:
X			break;
X
X		default:
X			nfatal("fingerprint \"%s\"", path->str_text);
X		}
X		result = 0;
X	}
X	else
X		result = str_from_c(buffer);
X	trace(("return \"%s\";\n", result ? result->str_text : ""));
X	trace((/*{*/"}\n"));
X	return result;
X}
END_OF_FILE
if test 5403 -ne `wc -c <'cook/fngrprnt.y'`; then
    echo shar: \"'cook/fngrprnt.y'\" unpacked with wrong size!
fi
# end of 'cook/fngrprnt.y'
fi
if test -f 'cook/id.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/id.c'\"
else
echo shar: Extracting \"'cook/id.c'\" \(5827 characters\)
sed "s/^X//" >'cook/id.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate the symbol table
X */
X
X#include <ac/stddef.h>
X#include <ac/stdlib.h>
X
X#include <error.h>
X#include <id.h>
X#include <mem.h>
X#include <option.h>
X#include <symtab.h>
X#include <version-stmp.h>
X#include <word.h>
X
Xstatic	symtab_ty	*symtab;
X	string_ty	*id_need;
X	string_ty	*id_younger;
X	string_ty	*id_target;
X	string_ty	*id_friend;
X	string_ty	*id_search_list;
X
X
Xstatic void reap _((void *));
X
Xstatic void
Xreap(p)
X	void	*p;
X{
X	wlist	*wlp;
X
X	wlp = p;
X	wl_free(wlp);
X	mem_free(wlp);
X}
X
X
Xstatic wlist *mem_copy_wlist _((wlist *));
X
Xstatic wlist *
Xmem_copy_wlist(wlp)
X	wlist	*wlp;
X{
X	wlist	*result;
X
X	result = mem_alloc(sizeof(wlist));
X	wl_copy(result, wlp);
X	return result;
X}
X
X
X/*
X * NAME
X *	id_initialize - start up symbol table
X *
X * SYNOPSIS
X *	void id_initialize(void);
X *
X * DESCRIPTION
X *	The id_initialize function is used to create the hash table.
X *
X * RETURNS
X *	void
X *
X * CAVEAT
X *	Assumes the str_initialize function has been called already.
X */
X
Xvoid
Xid_initialize()
X{
X	id_need = str_from_c("need");
X	id_younger = str_from_c("younger");
X	id_target = str_from_c("target");
X	id_friend = str_from_c("targets");
X	id_search_list = str_from_c("search_list");
X
X	id_reset();
X}
X
X
Xvoid
Xid_reset()
X{
X	wlist		wl;
X	string_ty	*s;
X
X	if (symtab)
X		symtab_free(symtab);
X	symtab = symtab_alloc(100);
X	symtab->reap = reap;
X
X	/*
X	 * set the "version" predefined variable
X	 */
X	wl_zero(&wl);
X	s = str_from_c(version_stamp());
X	wl_append(&wl, s);
X	str_free(s);
X	s = str_from_c("version");
X	id_assign(s, &wl);
X	str_free(s);
X	wl_free(&wl);
X
X	/*
X	 * set the "self" predefined variable
X	 */
X	s = str_from_c(progname);
X	wl_append(&wl, s);
X	str_free(s);
X	s = str_from_c("self");
X	id_assign(s, &wl);
X	str_free(s);
X	wl_free(&wl);
X
X#ifdef __STDC__
X	/*
X	 * This symbol is only defined if we have a conforming C
X	 * compiler.  This is support for the C recipes.
X	 */
X	wl_append(&wl, str_true);
X	s = str_from_c("__STDC__");
X	id_assign(s, &wl);
X	str_free(s);
X	wl_free(&wl);
X#endif
X	
X	/*
X	 * set the default search list
X	 * in the "search_list" predefined variable
X	 */
X	s = str_from_c(".");
X	wl_append(&wl, s);
X	str_free(s);
X	id_assign(id_search_list, &wl);
X	wl_free(&wl);
X}
X
X
X/*
X * NAME
X *	id_search - search for a variable
X *
X * SYNOPSIS
X *	int id_search(string_ty *name, wlist *value);
X *
X * DESCRIPTION
X *	Id_search is used to reference a variable.
X *
X * RETURNS
X *	If the variable has been defined, the function returns a non-zero value
X *	and the value is returned through the 'value' pointer.
X *	If the variable has not been defined, it returns zero,
X *	and 'value' is unaltered.
X *
X * CAVEAT
X *	The value returned from this function, when returned, is allocated
X *	in dynamic memory (it is a copy of the value remembered by this module).
X *	It is the responsibility of the caller to free it when finished with,
X *	by a wl_free() call.
X */
X
Xint
Xid_search(name, arg)
X	string_ty	*name;
X	wlist		*arg;
X{
X	wlist		*data;
X
X	assert(symtab);
X	data = symtab_query(symtab, name);
X	if (!data)
X		return 0;
X	wl_copy(arg, data);
X	return 1;
X}
X
X
X/*
X * NAME
X *	id_assign - assign a variable
X *
X * SYNOPSIS
X *	void id_assign(string_ty *name, id_class_ty class, ...);
X *
X * DESCRIPTION
X *	Id_assign is used to assign a value to a given variable.
X *
X * CAVEAT
X *	The name and value are copied by id_assign, so the user may
X *	modify or free them at a later date without affecting the
X *	variable.
X */
X
Xvoid
Xid_assign(name, arg)
X	string_ty	*name;
X	wlist		*arg;
X{
X	assert(symtab);
X	symtab_assign(symtab, name, mem_copy_wlist(arg));
X}
X
X
X/*
X * NAME
X *	id_assign_push - assign a variable, remembering old value
X *
X * SYNOPSIS
X *	void id_assign_push(string_ty *name, id_class_ty class, ...);
X *
X * DESCRIPTION
X *	Id_assign is used to assign a value to a given variable.
X *
X * CAVEAT
X *	The name and value are copied by id_assign, so the user may
X *	modify or free them at a later date without affecting the
X *	variable.
X */
X
Xvoid
Xid_assign_push(name, arg)
X	string_ty	*name;
X	wlist		*arg;
X{
X	assert(symtab);
X	symtab_assign_push(symtab, name, mem_copy_wlist(arg));
X}
X
X
X/*
X * NAME
X *	id_delete - delete a variable
X *
X * SYNOPSIS
X *	void id_delete(string_ty *name, id_class_ty class);
X *
X * DESCRIPTION
X *	Id_delete is used to delete variables.
X *
X * CAVEAT
X *	No complaint is made if the variable does not exist,
X *	since the user wanted it to not exist.
X */
X
Xvoid
Xid_delete(name)
X	string_ty	*name;
X{
X	assert(symtab);
X	symtab_delete(symtab, name);
X}
X
X
X/*
X * NAME
X *	id_dump - dump id table
X *
X * SYNOPSIS
X *	void id_dump(char *title, int mask);
X *
X * DESCRIPTION
X *	The id_dump function is used to dump the contents of the id table.
X *	The title will be used to indicate why the table was dumped.  The mask
X *	may be used to selectively dump the table, 0 means everything, bits
X *	correspond directly with ID_CLASS defines.
X *
X * RETURNS
X *	void
X *
X * CAVEAT
X *	This function is only available when symbol DEBUG is defined.
X */
X
X#ifdef DEBUG
X
Xvoid
Xid_dump(s)
X	char		*s;
X{
X	assert(symtab);
X	symtab_dump(symtab, s);
X}
X
X#endif
END_OF_FILE
if test 5827 -ne `wc -c <'cook/id.c'`; then
    echo shar: \"'cook/id.c'\" unpacked with wrong size!
fi
# end of 'cook/id.c'
fi
if test -f 'cook/listing.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/listing.c'\"
else
echo shar: Extracting \"'cook/listing.c'\" \(6005 characters\)
sed "s/^X//" >'cook/listing.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to open and close the listing file
X */
X
X#include <ac/stddef.h>
X#include <stdio.h>
X#include <ac/string.h>
X#include <ac/time.h>
X#include <signal.h>
X#include <ac/unistd.h>
X
X#include <error.h>
X#include <listing.h>
X#include <os.h>
X#include <option.h>
X#include <trace.h>
X
X
Xstatic int pid;
X
X
X#ifdef HAVE_GETPGRP
X#ifndef HAVE_TCGETPGRP
X
X#include <sys/termio.h>
X
Xint
Xtcgetpgrp(fd)
X	int		fd;
X{
X	int		result;
X
X#ifdef TIOCGETPGRP
X	if (ioctl(fd, TIOCGETPGRP, &result))
X		result = -1;
X#else
X#ifdef TIOCGPGRP
X	if (ioctl(fd, TIOCGPGRP, &result))
X		result = -1;
X#else
X	result = -1;
X#endif
X#endif
X	return result;
X}
X
X#endif /* !HAVE_TCGETPGRP */
X#endif /* HAVE_GETPGRP */
X
X
X/*
X * NAME
X *	background - test for backgroundness
X *
X * SYNOPSIS
X *	int background(void);
X *
X * DESCRIPTION
X *	The background function is used to determin e if the curent process is
X *	in the background.
X *
X * RETURNS
X *	int: zero if process is not in the background, nonzero if the process
X *	is in the background.
X *
X * CAVEAT
X *	This function has a huge chance of being wrong for your system.
X *	If you need to modify this function, please let the author know.
X */
X
Xstatic int background _((void));
X
Xstatic int
Xbackground()
X{
X	RETSIGTYPE (*x)_((int));
X
X	/*
X	 * csh changes the progess group of jobs.
X	 * you are a background job if the terminal is not
X	 * in your process group.
X	 */
X#ifdef HAVE_GETPGRP
X	if (getpgrp(CONF_getpgrp_arg) != tcgetpgrp(0))
X		return 1;
X#endif
X
X	/*
X	 * bourne shell tells you to ignore interrupts
X	 */
X	x = signal(SIGINT, SIG_IGN);
X	if (x == SIG_IGN)
X		return 1;
X	signal(SIGINT, x);
X
X	/*
X	 * must be forground
X	 */
X	return 0;
X}
X
X
X/*
X * NAME
X *	log_close - terminate logging
X *
X * SYNOPSIS
X *	void log_close(void);
X *
X * DESCRIPTION
X *	Log_close is used to terminate logging this session,
X *	and to close any como or comi files opened.
X *
X * CAVEAT
X *	Do not call any of the fatal error functions
X *	from this function.
X */
X
Xstatic void log_close _((void));
X
Xstatic void
Xlog_close()
X{
X	if (pid)
X	{
X		fclose(stdout);
X		fclose(stderr);
X		for (;;)
X		{
X			int who;
X			int status;
X
X			who = wait(&status);
X			if (who < 0 || who == pid)
X				break;
X		}
X		pid = 0;
X	}
X}
X
X
X/*
X * NAME
X *	log_open - start logging this session
X *
X * SYNOPSIS
X *	void log_open(void);
X *
X * DESCRIPTION
X *	Log_open is used to commence logging a cook session.
X */
X
Xvoid
Xlog_open()
X{
X	string_ty	*entryname;
X	string_ty	*dirname;
X	string_ty	*fullpath;
X	time_t		clock;
X	struct tm	*tm;
X
X	trace(("log_open()\n{\n"/*}*/));
X
X	/*
X	 * If we are logging the output to a file
X	 * and we are in the background,
X	 * don't send the output to the terminal.
X	 */
X	if (option_test(OPTION_LOGGING) && background())
X		option_set(OPTION_TERMINAL, OPTION_LEVEL_COMMAND_LINE, 0);
X
X	/*
X	 * redirect the output depending on the flags
X	 */
X	if (option_test(OPTION_LOGGING))
X	{
X		if (!option.o_logfile)
X			fatal("no list file specified");
X		if (option_test(OPTION_TERMINAL))
X		{
X			int	fd[2];
X			char	*cmd[3];
X
X			/*
X			 * list both to a file and to the terminal
X			 */
X			if (pipe(fd))
X				nfatal("pipe()");
X			switch (pid = fork())
X			{
X			case 0:
X					cmd[0] = "tee";
X					cmd[1] = option.o_logfile->str_text;
X					cmd[2] = 0;
X				close(fd[1]);
X				close(0);
X				if (dup(fd[0]) != 0)
X					fatal("dup was wrong");
X				close(fd[0]);
X				signal(SIGINT, SIG_IGN);
X				signal(SIGHUP, SIG_IGN);
X				signal(SIGTERM, SIG_IGN);
X				execvp(cmd[0], cmd);
X				fatal("%s not found", cmd[0]);
X
X			case -1:
X				nfatal("fork()");
X
X			default:
X				close(fd[0]);
X				close(1);
X				if (dup(fd[1]) != 1)
X					fatal("dup was wrong");
X				close(fd[1]);
X				break;
X			}
X		}
X		else
X		{
X			/* 
X			 * list only to a file
X			 */
X			if (!freopen(option.o_logfile->str_text, "w", stdout))
X				nfatal("%s", option.o_logfile->str_text);
X		}
X		/*
X		 * make sterr go to the same place as stdout
X		 *	[will this work if stdout is already closed?]
X		 */
X		close(2);
X		switch (dup(1))
X		{
X		case 0:
X			/* oops, stdin is was closed */
X			if (dup(1) != 2)
X				nfatal("dup");
X			close(0);
X			break;
X	
X		case 2:
X			break;
X	
X		default:
X			nfatal("dup");
X		}
X		time(&clock);
X		tm = localtime(&clock);
X		fullpath = 0;
X		entryname = 0;
X		dirname = 0;
X		fullpath = os_pathname(option.o_logfile);
X		if (!fullpath)
X			goto bomb;
X		entryname = os_entryname(fullpath);
X		if (!entryname)
X			goto bomb;
X		dirname = os_dirname(fullpath);
X		if (!dirname)
X			goto bomb;
X		fprintf
X		(
X			stderr,
X			"/* %s, %s, %3.3s %3.3s%3d %02d:%02d%5d */\n",
X			entryname->str_text,
X			dirname->str_text,
X			&("SunMonTueWedThuFriSat"[tm->tm_wday*3]),
X			&("JanFebMarAprMayJunJulAugSepOctNovDec"[tm->tm_mon*3]),
X			tm->tm_mday,
X			tm->tm_hour,
X			tm->tm_min,
X			1900+tm->tm_year
X		);
X	bomb:
X		if (fullpath)
X			str_free(fullpath);
X		if (entryname)
X			str_free(entryname);
X		if (dirname)
X			str_free(dirname);
X	}
X	else
X	{
X		if (option_test(OPTION_TERMINAL))
X		{
X			/*
X			 * list only to the terminal
X			 */
X		}
X		else
X		{
X			static char dev_null[] = "/dev/null";
X
X			/*
X			 * list neither to a file nor to the terminal
X			 */
X			if
X			(
X				!freopen(dev_null, "w", stdout)
X			||
X				!freopen(dev_null, "w", stderr)
X			)
X				nfatal("%s", dev_null);
X		}
X	}
X
X	quit_handler(log_close);
X	trace((/*{*/"}\n"));
X}
END_OF_FILE
if test 6005 -ne `wc -c <'cook/listing.c'`; then
    echo shar: \"'cook/listing.c'\" unpacked with wrong size!
fi
# end of 'cook/listing.c'
fi
if test -f 'cook/option.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/option.c'\"
else
echo shar: Extracting \"'cook/option.c'\" \(7023 characters\)
sed "s/^X//" >'cook/option.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manage command line options
X *
X * The options may be set at various levels.  The level with the highest
X * precedence which has actually been set is used to determine the option
X * value at any given time.
X *
X * Each level of an option is represented by 2 bits in the flag word.  One bit
X * is used to indicate that the option has been set for that level, the other
X * bit indicates the state.  Determining the least set bit in an expression is
X * cheap (x&-x) so highest priority is the lowest numbered level.
X *
X * The COOK enviroment variable is basically a replacement for the defaults,
X * so that users can change the default behaviour.  The command line overrides
X * almost everything.  The error level is the only level with higher
X * precedence than the command line, and it is used to prevent disasters
X * after parse errors or interrupts have happened.
X */
X
X#include <ctype.h>
X#include <ac/limits.h>
X#include <ac/stddef.h>
X#include <stdio.h>
X#include <ac/stdlib.h>
X#include <ac/string.h>
X#include <ac/time.h>
X
X#include <option.h>
X#include <error.h>
X#include <os.h>
X#include <mem.h>
X
X
Xoption_ty option;
X
X
X/*
X * NAME
X *	option_set - set an option
X *
X * SYNOPSIS
X *	void option_set(option_number_ty num, option_level_ty lvl, int state);
X *
X * DESCRIPTION
X *	The option_set function is used to set the given option at the given
X *	level to the given state.
X *
X * RETURNS
X *	void
X */
X
Xvoid
Xoption_set(o, level, state)
X	option_number_ty	o;
X	option_level_ty	level;
X	int		state;
X{
X	assert((int)o >= 0 && (int)o < (int)OPTION_max);
X	if (state)
X		option.o_flag[(size_t)o] |= 3 << (2 * (int)level);
X	else
X		option.o_flag[(size_t)o] |= 1 << (2 * (int)level);
X}
X
X
X/*
X * NAME
X *	option_already - see if an option is already set
X *
X * SYNOPSIS
X *	int option_already(option_number_ty num, option_level_ty lvl);
X *
X * DESCRIPTION
X *	The option_already function is used to test if a given option at a
X *	given level has been set.
X *
X * RETURNS
X *	int: zero if the option has not been set, nonzero if it has.
X */
X
Xint
Xoption_already(o, level)
X	option_number_ty	o;
X	option_level_ty	level;
X{
X	assert((int)o >= 0 && (int)o < (int)OPTION_max);
X	return ((option.o_flag[(size_t)o] >> (2 * (int)level)) & 1) != 0;
X}
X
X
X/*
X * NAME
X *	option_undo - remove option setting
X *
X * SYNOPSIS
X *	void option_undo(option_number_ty num, option_level_ty lvl);
X *
X * DESCRIPTION
X *	The option_undo function is used to is used to remove the option
X *	setting for the given option at the given level.
X *
X * RETURNS
X *	void
X */
X
Xvoid
Xoption_undo(o, level)
X	option_number_ty	o;
X	option_level_ty	level;
X{
X	assert((int)o >= 0 && (int)o < (int)OPTION_max);
X	option.o_flag[(size_t)o] &= ~(3 << (2 * (int)level));
X}
X
X
X/*
X * NAME
X *	option_undo_level - remove options settings
X *
X * SYNOPSIS
X *	void option_undo_level(option_level_ty lvl);
X *
X * DESCRIPTION
X *	The option_undo_level function is used to remove the settings for all
X *	options at a given level.
X *
X * RETURNS
X *	void
X */
X
Xvoid
Xoption_undo_level(level)
X	option_level_ty	level;
X{
X	int		o;
X
X	for (o = 0; o < (int)OPTION_max; ++o)
X		option_undo((option_number_ty)o, level);
X}
X
X
X/*
X * NAME
X *	option_test - test an option
X *
X * SYNOPSIS
X *	int option_test(option_number_ty num);
X *
X * DESCRIPTION
X *	The option_test function is used to test the setting of an option.
X *	The level of highest precedence which hash been set is used.
X *
X * RETURNS
X *	int: zero if the option is off, nonzero if the option is on.
X */
X
Xint
Xoption_test(o)
X	option_number_ty	o;
X{
X	unsigned	*op;
X	unsigned	mask;
X
X	assert((int)o >= 0 && (int)o < (int)OPTION_max);
X	op = &option.o_flag[(size_t)o];
X	mask = *op & 0x55555555;
X	mask &= -mask; /* get LSB */
X	return (*op & (mask << 1)) != 0;
X}
X
X
X/*
X * NAME
X *	option_tidy_up - mother hen
X *
X * SYNOPSIS
X *	void option_tidy_up(void);
X *
X * DESCRIPTION
X *	The option_tidy_up function is used to set a few defaults, and tidy up
X *	after the command line.
X *
X * RETURNS
X *	void
X *
X * CAVEAT
X *	Must be called after the command line has been parsed.
X */
X
Xvoid
Xoption_tidy_up()
X{
X	string_ty	*s;
X	string_ty	*s1;
X
X	/*
X	 * user's library
X	 */
X	s = os_accdir();
X	assert(s);
X	s1 = str_format("%S/.%s", s, progname);
X	str_free(s);
X	wl_append_unique(&option.o_search_path, s1);
X	str_free(s1);
X
X	/*
X	 * cook's library
X	 */
X	s = str_from_c(LIBDIR);
X	wl_append_unique(&option.o_search_path, s);
X	str_free(s);
X
X	if (!option.o_book)
X	{
X		static char *name[] =
X		{
X			".how.to.%s",
X			".howto.%s",
X			"how.to.%s",
X			"howto.%s",
X			"%s.file",
X			"%sfile",
X			".%s.rc",
X			".%src",
X		};
X		int	j;
X	
X		/*
X		 * A huge range of alternative default names is given.
X		 * The first found will be used.
X		 */
X		for (j = 0; j < SIZEOF(name); j++)
X		{
X			char	format[300];
X
X			strcpy(format, name[j]);
X			floop:
X			s = str_format(format, progname);
X			switch (os_exists(s))
X			{
X			case -1:
X				exit(1);
X
X			case 0:
X				str_free(s);
X				if (islower(format[0]))
X				{
X					format[0] = toupper(format[0]);
X					goto floop;
X				}
X				continue;
X
X			case 1:
X				option.o_book = s;
X				break;
X			}
X			break;
X		}
X	}
X
X	if (!option.o_logfile && option.o_book)
X	{
X		char		*sp;
X		char		*cp;
X
X		sp = option.o_book->str_text;
X		/* skip first char in case it's a '.' */
X		cp = strrchr(sp + 1, '.');
X		if (cp)
X			s = str_n_from_c(sp, cp - sp);
X		else
X			s = str_copy(option.o_book);
X		sp = (option_test(OPTION_CMDFILE) ? "sh" : "list");
X		option.o_logfile = str_format("%S.%s", s, sp);
X		str_free(s);
X	}
X
X	option_set(OPTION_ACTION, OPTION_LEVEL_DEFAULT, 1);
X	option_set(OPTION_LOGGING, OPTION_LEVEL_DEFAULT, 1);
X	option_set(OPTION_TERMINAL, OPTION_LEVEL_DEFAULT, 1);
X	option_set(OPTION_STRIP_DOT, OPTION_LEVEL_DEFAULT, 1);
X}
X
X
X/*
X * NAME
X *	option_set_errors - set error flags
X *
X * SYNOPSIS
X *	void option_set_errors(void);
X *
X * DESCRIPTION
X *	The option_set_errors function is used to set the appropriate options
X *	to prevent undesirable side effects when errors occur.
X *
X * RETURNS
X *	void
X */
X
Xvoid
Xoption_set_errors()
X{
X	option_set(OPTION_SILENT, OPTION_LEVEL_ERROR, 0);
X	option_set(OPTION_ACTION, OPTION_LEVEL_ERROR, 0);
X	option_set(OPTION_ERROK, OPTION_LEVEL_ERROR, 0);
X	option_set(OPTION_METER, OPTION_LEVEL_ERROR, 0);
X	option_set(OPTION_PERSEVERE, OPTION_LEVEL_ERROR, 0);
X}
END_OF_FILE
if test 7023 -ne `wc -c <'cook/option.c'`; then
    echo shar: \"'cook/option.c'\" unpacked with wrong size!
fi
# end of 'cook/option.c'
fi
if test -f 'doc/intro2.so' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/intro2.so'\"
else
echo shar: Extracting \"'doc/intro2.so'\" \(6857 characters\)
sed "s/^X//" >'doc/intro2.so' <<'END_OF_FILE'
X.\"
X.\"	cook - file construction tool
X.\"	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: Reference Manual, Cook from a Cookbook
X.\"	
X.H 1 "Cook from a Cookbook"
XThis chapter describes the contents and meaning of a cookbook,
Xa file which contains information
X.B cook
Xneeds to do its job.
XIt focuses on what a cookbook looks like,
Xand touches on a few areas of how 
X.B cook
Xworks does its job.
X.H 2 "What does Cook do?"
XThe basic building block for
X.B cook
Xis the concept of a
X.IR recipe .
XA recipe has three parts:
X.AL
X.LI
Xone or more files which the recipe constructs,
Xknown as the 
X.I targets
Xof the recipe
X.LI
Xzero or more files which are used by the recipe to construct the target,
Xknown as the
X.I ingredients
Xof the recipe
X.LI
Xone or more commands to execute which construct 
Xthe targets from the ingredients,
Xknown as the
X.I body
Xof the recipe.
X.LE
X.P
XWhen a number of recipes are given,
Xsome recipes may describe how to cook the ingredients of other recipes.
XWhen
X.B cook
Xis asked to construct a particular target it
Xautomatically determines the correct order to perform the 
Xrecipe bodies to cook the requested target.
X.P
X.B Cook 
Xwould not be especially useful if you had to give explicit recipes 
Xfor how to cook every little thing.
XAs a result,
X.B cook
Xhas the concept of an
X.I implicit
Xrecipe.
XAn implicit recipe is very similar to an explicit recipe,
Xexcept that the targets and ingredients of the recipe
Xare 
X.I patterns
Xto be matched to file names,
Xrather than explicit file names.
XThis means it is possible to write a recipe,
Xfor example
Xwhich constructs a files with a name ending in `\fB.o\fP' from a file 
Xof the same name, but ending in `\fB.c\fP' rather than `\fB.o\fP'.
X.P
XIn addition to recipes,
X.B cook
Xneeds to know
X.I when
Xto construct targets from ingredients.
X.B Cook
Xhas been designed to cook as little as possible.
X"As little as possible" is determined by examining when each file was last
Xmodified,
Xand only constructing targets when that are out of date with the ingredients.
X
X.H 3 "When is Cook useful?"
XFrom the above description, 
X.B cook
Xmay be described as a tool for maintaining consistency of sets of files.
X
X.H 3 "When is Cook not useful?"
XCook is not useful for maintaining consistency of sets of things
Xwhich are 
X.I within
Xfiles and thus
X.B cook
Xis unable to determine when they were modified.
XFor example,
X.B cook
Xis not useful for
Xmaintaining consistency of sets of records within a database.
X
X.H 2 "How do I tell Cook what to do?"
XSets of recipes are gathered together into cookbooks.
XWhen
X.B cook
Xis executed it looks for a cookbook of the name
X.I Howto.cook
Xin the current directory.
XIf you did not name a file to be constructed on the command line,
Xthe first target in the cookbook will be constructed.
X.P
XThe best way to understand how to write recipes is an example.
XIn this example, a  program,
X.IR prog ,
Xis composed of three files:
X.IR foo.c ,
X.I bar.c
Xand
X.IR baz.c .
XTo inform
X.B cook
Xof this,
Xthe cookbook
X.eB
X#include "c"
X
Xprog: foo.o bar.o baz.o
X    {
X	cc -o prog foo.o bar.o baz.o;
X    }
X.eE
Xis sufficient for 
X.I prog
Xto be constructed.
X.P
XThis cookbook has two parts.
XThe line
X.eB
X#include "c"
X.eE
Xtells
X.B cook
Xto refer to a system cookbook which tells it,
Xamong other things,
Xhow to construct a 
X.IB something .o
Xfile from a
X.IB something .c
Xfile.
X.P
XThe second part is a recipe.
XThe first line of this recipe
X.eB
Xprog: foo.o bar.o baz.o
X    ...
X.eE
Xnames the target,
X.IR prog ,
Xand the ingredients,
X.IR foo.o ,
X.I bar.o
Xand
X.IR baz.o .
X.P
XThe next three lines
X.eB
X\&...
X    {
X	cc -o prog foo.o bar.o baz.o;
X    }
X.eE
Xare the recipe body,
Xwhich consists of a single
X.IR cc (1)
Xcommand to be executed.
XRecipe bodies are always within
X.B {
Xcurly braces
X.BR } ,
Xand commands always end with a semicolon
X.RB ( ; ).
X.P
XThus,
Xto update
X.I prog
Xafter any of the source files have been edited,
Xit is only necessary to issue the command
X.eB
Xcook prog
X.eE
XThis could be simplified further,
Xbecause 
X.B cook
Xwill cook the targets of the first recipe by default;
Xin this case,
X.IR prog .
X.P
XThe power of cook becomes more apparent when include files are
Xconsidered.
XIf the files
X.I foo.c
Xand
X.I baz.c
Xinclude the file
X.IR defs.h ,
Xthis would automatically be detected by
X.BR cook .
XIf 
X.I defs.h
Xwere to be edited,
Xand
X.B cook
Xre-executed,
Xthis would cause 
X.B cook
Xto recompile
Xboth
X.I foo.c
Xand
X.IR baz.c ,
Xand relink 
X.IR prog.
X.H 3 "The common program case"
XThe above example may be simplified even further.
XIf the four files
X.IR foo.c ,
X.IR bar.c ,
X.IR baz.c
Xand
X.I defs.h
Xall resided in a directory with a path of
X.IR /some/where/prog ,
Xthe the 
X.I Howto.cook
Xfile in that directory need only contain
X.eB
X#include "c"
X#include "program"
X.eE
Xfor 
X.I prog
Xto be cooked.
XThis is because the "\f(CWprogram\fP" cookbook
Xlooks for all of the 
X.IB something .c
Xfiles in the current directory,
Xcompiles them all,
Xand links them into a program named after the current directory.
X.P
XThe default target in the "\f(CWprogram\fP" cookbook is called 
X.IR all .
XThe ingredient of
X.I all
Xis the program named after the current directory.
XTwo other targets are supplied by this cookbook:
X.VL 0.5i
X.LI clean
Xremoves all of the
X.IB something .o
Xfiles from the current directory.
X.LI clobber
Xremoves the program named after the current directory,
Xand also removes all of the
X.IB something .o
Xfiles from the current directory.
X.LE
X.H 2 "Creating a Cookbook"
XTo use 
X.B cook
Xyou will usually need to define a cookbook,
Xby creating a file,
Xusually called
X.I Howto.cook
Xin the current directory,
Xwith your favorite text editor.
X.P
XThis file has a specific format.
XThe format has been designed to be easy to learn,
Xeven for the casual user.
XMuch of the power of 
X.B cook
Xis contained in how it works,
Xwithout complicating the format of the cookbook.
X.P
XExample of what a cookbook looks like are scattered throughout this
Xdocument.
XThe following example is the entire cookbook for
X.B cook
Xitself.
X.eB
X#include "c"
X#include "yacc"
X#include "usr.local"
X#include "program"
X.eE
XAs you can see,
Xeven for a complex program like
X.B cook
Xthe cookbook is remarkably simple.
END_OF_FILE
if test 6857 -ne `wc -c <'doc/intro2.so'`; then
    echo shar: \"'doc/intro2.so'\" unpacked with wrong size!
fi
# end of 'doc/intro2.so'
fi
if test -f 'make2cook/gram.y' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'make2cook/gram.y'\"
else
echo shar: Extracting \"'make2cook/gram.y'\" \(5021 characters\)
sed "s/^X//" >'make2cook/gram.y' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to parse Makefiles
X */
X
X%{
X
X#include <stdio.h>
X
X#include <gram.h>
X#include <lex.h>
X#include <stmt/assign.h>
X#include <stmt/blank.h>
X#include <stmt/comment.h>
X#include <stmt/compound.h>
X#include <stmt/define.h>
X#include <stmt/if.h>
X#include <stmt/include.h>
X#include <stmt/rule.h>
X#include <stmt/vpath.h>
X#include <trace.h>
X
X#ifdef	DEBUG
X#define YYDEBUG 1
X#ifdef YYBISON
X#define fprintf yytrace2
X#else
X#define printf trace_where(__FILE__, __LINE__), yytrace
X#endif
Xextern int yydebug;
X#endif
X
X
Xvoid
Xgram(filename)
X	char		*filename;
X{
X	int yyparse _((void));
X
X	trace(("gram(filename = %08lX)\n{\n"/*}*/, (long)filename));
X	lex_open(filename);
X#if YYDEBUG
X	yydebug = trace_pretest_;
X#endif
X	yyparse();
X	lex_close();
X	trace((/*{*/"}\n"));
X}
X
X%}
X
X%token	COLON
X%token	COLON_COLON
X%token	COLON_EQUALS
X%token	COMMAND
X%token	COMMENT
X%token	DEFINE
X%token	ELSE
X%token	EMPTY
X%token	ENDDEF
X%token	ENDIF
X%token	EOLN
X%token	EQUALS
X%token	EXPORT
X%token	IF
X%token	INCLUDE
X%token	INCLUDE2
X%token	INCLUDE3
X%token	OVERRIDE
X%token	PLUS_EQUALS
X%token	UNEXPORT
X%token	VPATH
X%token	VPATH2
X%token	WORD
X
X
X%union
X{
X	blob_ty		*lv_line;
X	blob_list_ty	*lv_list;
X	stmt_ty		*lv_stmt;
X	int		lv_int;
X}
X
X%type <lv_line> COMMAND COMMENT IF if WORD
X%type <lv_stmt> stmt conditional rule stmts comment assignment
X%type <lv_stmt> include vpath
X%type <lv_int> assign_op rule_op
X%type <lv_list> word_list word_list_optional
X
X%%
X
Xmakefile
X	: stmts
X		{
X			int	j;
X			stmt_ty	*s;
X
X			stmt_regroup($1);
X
X			s = stmt_vpath_default();
X			if (s)
X				stmt_compound_append($1, s);
X
X			for (j = 0; ; ++j)
X			{
X				s = stmt_rule_default(j);
X				if (!s)
X					break;
X				stmt_compound_append($1, s);
X			}
X
X			for (j = 0; ; ++j)
X			{
X				s = stmt_assign_default($1);
X				if (!s)
X					break;
X				stmt_compound_prepend($1, s);
X			}
X
X			stmt_sort($1);
X			stmt_emit($1);
X			stmt_free($1);
X		}
X	;
X
Xstmts
X	: /* empty */
X		{
X			$$ = stmt_compound_alloc();
X		}
X	| stmts stmt
X		{
X			$$ = $1;
X			stmt_compound_append($$, $2);
X		}
X	;
X
Xstmt
X	: assignment
X		{ $$ = $1; }
X	| comment
X		{ $$ = $1; }
X	| rule
X		{ $$ = $1; }
X	| conditional
X		{ $$ = $1; }
X	| include
X		{ $$ = $1; }
X	| vpath
X		{ $$ = $1; }
X	| EOLN
X		{ $$ = stmt_blank_alloc(); }
X	| error EOLN
X		{ $$ = stmt_blank_alloc(); }
X	;
X
Xassignment
X	: WORD assign_op word_list_optional EOLN
X		{
X			$$ = stmt_assign_alloc(0, $1, $2, $3);
X		}
X	| OVERRIDE WORD assign_op word_list_optional EOLN
X		{
X			$$ = stmt_assign_alloc(1, $2, $3, $4);
X		}
X	;
X
Xassign_op
X	: EQUALS
X		{ $$ = stmt_assign_op_normal; }
X	| PLUS_EQUALS
X		{ $$ = stmt_assign_op_plus; }
X	| COLON_EQUALS
X		{ $$ = stmt_assign_op_colon; }
X	;
X
Xword_list
X	: WORD
X		{
X			$$ = blob_list_alloc();
X			blob_list_append($$, $1);
X		}
X	| word_list WORD
X		{
X			$$ = $1;
X			blob_list_append($$, $2);
X		}
X	;
X
Xword_list_optional
X	: /* empty */
X		{ $$ = blob_list_alloc(); }
X	| word_list
X		{ $$ = $1; }
X	;
X
Xrule
X	: word_list rule_op word_list_optional EOLN
X		{
X			$$ = stmt_rule_alloc($1, $2, $3, (blob_list_ty *)0);
X		}
X	| word_list rule_op word_list rule_op word_list_optional EOLN
X		{
X			$$ = stmt_rule_alloc($3, $4, $5, $1);
X		}
X	| rule COMMAND
X		{
X			$$ = $1;
X			stmt_rule_append($$, $2);
X		}
X	;
X
Xrule_op
X	: COLON
X		{ $$ = 1; }
X	| COLON_COLON
X		{ $$ = 2; }
X	;
X
Xconditional
X	: if stmts endif
X		{
X			$$ = stmt_if_alloc($1, $2, (stmt_ty *)0);
X		}
X	| if stmts else stmts endif
X		{
X			$$ = stmt_if_alloc($1, $2, $4);
X		}
X	;
X
Xif
X	: IF eoln
X		{ $$ = $1; }
X	;
X
Xeoln
X	: word_list_optional EOLN
X		{
X			if ($1->length)
X			{
X				blob_error
X				(
X					$1->list[0],
X					"garbage on end of line"
X				);
X			}
X			blob_list_free($1);
X		}
X	;
X
Xelse
X	: ELSE eoln
X	;
X
Xendif
X	: ENDIF eoln
X	;
X
Xcomment
X	: COMMENT
X		{
X			$$ = stmt_comment_alloc();
X			stmt_comment_append($$, $1);
X		}
X	| comment COMMENT
X		{
X			$$ = $1;
X			stmt_comment_append($$, $2);
X		}
X	;
X
Xinclude
X	: INCLUDE word_list EOLN
X		{ $$ = stmt_include_alloc($2, 1); }
X	| INCLUDE2 word_list EOLN
X		{ $$ = stmt_include_alloc($2, 2); }
X	| INCLUDE3 word_list EOLN
X		{ $$ = stmt_include_alloc($2, 3); }
X	;
X
Xvpath
X	: VPATH WORD word_list EOLN
X		{
X			blob_free($2);
X			stmt_vpath_remember1($3);
X			$$ = stmt_blank_alloc();
X		}
X	| VPATH2 assign_op word_list_optional EOLN
X		{
X			stmt_vpath_remember2($3);
X			$$ = stmt_blank_alloc();
X		}
X	;
END_OF_FILE
if test 5021 -ne `wc -c <'make2cook/gram.y'`; then
    echo shar: \"'make2cook/gram.y'\" unpacked with wrong size!
fi
# end of 'make2cook/gram.y'
fi
if test -f 'man1/make2cook.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man1/make2cook.1'\"
else
echo shar: Extracting \"'man1/make2cook.1'\" \(6546 characters\)
sed "s/^X//" >'man1/make2cook.1' <<'END_OF_FILE'
X'\" t
X.\"	cook - file construction tool
X.\"	Copyright (C) 1994 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: manual entry for the make2cook command
X.\"
X.TH make2cook 1
X.so z_name.so
X.ds n) make2cook
X.SH NAME
X\*(n) \- translate makefiles into cookbooks
X.SH SYNOPSIS
X.B \*(n)
X[
X.IR option \&...
X][
X.I infile
X[
X.I outfile
X]]
X.br
X.B \*(n)
X.B -Help
X.br
X.B \*(n)
X.B -VERSion
X.SH DESCRIPTION
XThe
X.I \*(n)
Xprogram is used to
Xtranslate
X.IR Makefile s
Xinto cookbooks.
XThis command is provided to ease the transition to using the
X.I cook
Xcommand.
X.PP
XIf no input file is named,
Xor the special name  ``-'' is used,
Xinput will be taken from the standard input.
XIf no output file is named,
Xor the special name  ``-'' is used,
Xoutput will be taken from the standard output.
X.SH SEMANTICS
XThere is no one-to-one semantic mapping between
X.I make
Xsemantics
Xand
X.I cook
Xsemantics,
Xso the results will probably need some manual editing.
X.PP
XThe functionality provided by classic
X.I make (1)
Ximplementations is accurately reproduced.
XExtensions,
Xsuch as those offered by GNU Make or BSD make,
Xare not always understood,
Xor are sometimes not reproduced identically.
X.PP
XThe following subsections enumerate a few of the things
Xwhich are understood and not understood.
XThey are probably not complete.
X.SS Understood
XThe
X.I cook
Xprogram requires variables to be defined before they are used,
Xwhereas
X.I make
Xwill default them to be empty.
XThis is understood,
Xand empty definitions are inserted as required.
X.PP
XMost of the builtin variables of GNU Make are understood.
X.PP
XBuiltin variables are defaulted from the environment,
Xif an environment variable of the same name is set.
X.PP
XThe GNU Make
X.I override
Xvariable assignment is understood.
X.PP
XThe GNU Make
X``+='' assignment is understood.
X.PP
XThe GNU Make
X``:='' variable assignment is understood.
X.PP
XTraditional make assignments are macros,
Xthey are expanded on use,
Xrather than on assignment.
XThe
X.I cook
Xprogram has only variables.
XAssignment statements are re-arranged to ensure the correct results
Xwhen variables are referenced.
X.PP
XSingle and double suffix rules are understood.
XThe .SUFFIXES rules are understood and honoured.
XHint: if you want to suppress the builtin-recipes,
Xuse a .SUFFIXES rule with no dependencies.
X.PP
XThe .PHONY rule is understood, and is translated into a
X.I "set forced"
Xflag in appropriate recipes,
Xexcept files from implicit recipes.
X.PP
XThe .PRECIOUS rule is understood, and is translated into a
X.I "set precious"
Xflag in the appropriate recipes,
Xexcept files from implicit recipes.
X.PP
XThe .DEFAULT rule is understood,
Xand is translated into an implicit recipe.
X.PP
XThe .IGNORE rule is understood, and is translated into a
X.I "set errok"
Xstatement.
X.PP
XThe .SILENT rule is understood, and is translated into a
X.I "set silent"
Xstatement.
X.PP
XMost GNU Make functions are understood.
XThe
X.I filter
Xand
X.I filter-out
Xfunctions only understand a single pattern.
XThe
X.I sort
Xfunction does not remove duplicates (wrap the
X.I stringset
Xfunction around it if you need this).
X.PP
XThe GNU Make
Xstatic pattern rules
Xare understood.
XThey are translated into recipe predicates.
X.PP
XThe GNU Make and BSD make
X.I include
Xvariants are understood.
X.PP
XThe bizarre irregularities surrounding archive files in automatic
Xvariables and suffix rules are understood, and translated into
Xconsistent readable recipes.
XThe
X.I make
Xsemantics are preserved.
X.PP
XThe BSD make
X.I \&.CURDIR
Xvariable is understood,
Xand translated to an equivalent expression.
XIt cannot be assigned to.
X.SS Not Understood
XThe
X.I cook
Xprogram tokenizes its input,
Xwhereas make does textual replacement.
XThe shennanigans required to construct
Xa make macro containing
Xa single space
Xare not understood.
XThe translation will result in a
X.I cook
Xvariable which is empty.
X.PP
XReferences to automatic variables within macro definitions
Xwill not work.
X.PP
XThe GNU Make
X.I define
Xis not understood.
X.PP
XThe GNU Make and BSD make
X.I if
Xvariants are not understood.
X.PP
XThe
XGNU Make
X.I foreach
Xfunction is not understood.
XThe GNU Make
X.I origin
Xfunction is not understood.
XThese have no
X.I cook
Xequivalents.
X.PP
XThe
X.IR archive (( member ))
Xnotation is not understood.
XThese semantics are not available from
X.IR cook .
X.PP
XThe following variables are not translated:
X.IR MAKE ,
X.IR MAKEFLAGS ,
X.IR MAKELEVEL ,
Xand
X.IR MAKEFILES .
XIf you wish to reproduce this functionality,
Xyou must edit the output.
X.PP
XMany variants of make can use builtin rules
Xto make the Makefile if it is absent.
X.I Cook
Xis unable to cook the cookbook if it is absent.
X.PP
XWildcards are not understood in targets or dependencies.
XIf you want this,
Xyou will have to edit the output to use the
X.I "[wildcard]"
Xfunction.
X.PP
XHome directory tildes (~) are not understood in targets and
Xdependencies.
XIf you want this, you will have to edit the output to use the
X.I "[home]"
Xfunction.
X.PP
XThe \f(CW-l\fP\f(CIhome\fP dependency is not understood to mean a
Xlibrary.
XIf you want this, you will have to edit the output to use the
X.IR "[collect findlibs -l" name "]"
Xfunction.
X.PP
XThe
X.I export
Xdirective is not understood.
X.PP
XThe
X.I unexport
Xdirective is not understood.
X.PP
XThe
X.I \&.EXPORT_ALL_VARIABLES
Xrule is not understood.
X.br
X.ne 1i
X.SH OPTIONS
XThe following options are understood:
X.TP 8n
X.B -Help
X.br
XProvide some help with using the
X.I make2cook
Xcommand.
X.TP 8n
X.B -History_Commands
X.br
XThis option causes
X.I make2cook
Xto include recipes for
X.I RCS
Xand
X.I SCCS
Xin the output.
X.TP 8n
X.B -Line_Numbers
X.br
XInsert line number directives into the output,
Xso that it is possible to tell where the lines came from.
XMost useful when debugging.
X.I \*(n)
Xprogram.
X.TP 8n
X.B -VERSion
X.br
XPrint the version of the
X.I \*(n)
Xprogram being executed.
X.PP
XAll other options will produce a diagnostic error.
X.so o__rules.so
X.so z_exit.so
X.so copyright.so
END_OF_FILE
if test 6546 -ne `wc -c <'man1/make2cook.1'`; then
    echo shar: \"'man1/make2cook.1'\" unpacked with wrong size!
fi
# end of 'man1/make2cook.1'
fi
if test -f 'test/00/t0046a.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test/00/t0046a.sh'\"
else
echo shar: Extracting \"'test/00/t0046a.sh'\" \(5641 characters\)
sed "s/^X//" >'test/00/t0046a.sh' <<'END_OF_FILE'
X#!/bin/sh
X#
X#	cook - file construction tool
X#	Copyright (C) 1994 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: Test the fingerprint functionality
X#
Xwork=/tmp/$$
XPAGER=cat
Xexport PAGER
Xumask 022
Xunset COOK
Xhere=`pwd`
Xif test $? -ne 0 ; then exit 1; fi
X
Xif test "$1" != "" ; then bin="$here/$1/bin"; else bin="$here/bin"; fi
X
Xfail()
X{
X	set +x
X	echo 'FAILED test of the fingerprint functionality' 1>&2
X	cd $here
X	rm -rf $work
X	exit 1
X}
Xpass()
X{
X	set +x
X	cd $here
X	rm -rf $work
X	exit 0
X}
Xtrap "fail" 1 2 3 15
X
Xmkdir $work
Xif test $? -ne 0 ; then exit 1; fi
Xcd $work
Xif test $? -ne 0 ; then fail; fi
X
X#
X# file to be chewed on
X#
Xcat > test.in << 'fubar'
Xhi
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.ok << 'fubar'
XJoXEhdflGxZdS89tDd5zpFx0JRJyX0k67EH0Jod7aet4hIjB.hGhon0veN0BZRfi058HZQ06U0JD
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
X$bin/cookfp < test.in > test.out
Xif test $? -ne 0 ; then fail; fi
X 
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.ok << 'fubar'
X1479881546        3
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
X$bin/cookfp -checksum < test.in > test.out
Xif test $? -ne 0 ; then fail; fi
X 
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.ok << 'fubar'
X764EFA883DDA1E11DB47671C4A3BBD9E
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
X$bin/cookfp -md < test.in > test.out
Xif test $? -ne 0 ; then fail; fi
X 
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.ok << 'fubar'
XADF394F6 55946D41 192DD655 3F028C7D 8D1838B6 136A947C 59DDAE07 D0A051A8
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
X$bin/cookfp -snefru < test.in > test.out
Xif test $? -ne 0 ; then fail; fi
X 
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X
X#
X# file to be chewed on
X#
Xcat > test.in << 'fubar'
X64f9001bfeddcdf67c8ff1e211d715148b8c18d3dddf881e6eab505688ced8e14914895969c56fd5
Xb7994f030fbcee3e3c26494021557e58e14b3fc22e5cf591dceff8ce092a1648be812936ff7b0c6a
Xd5251037afa448f17dafc95a1ea69c3fa417abe75890e423b0cb70c0c85025f7244d97e31ff3595f
Xc4ec639659181e17e635b477354e7dbf796f775366eb52cc77c3f99532e3a92780ccaed64e2be89d
X375bbd28ad1a3d052b1b42b316c44c714d54bfa8e57ddc7aec6d81445a71046bd822965087fc8f24
Xcbc60e09b6390366d9f76092d393a70b1d31a08a9cd971c95c1ef44586fab694fdb441658eaafcbe
X4bcac6ebfb7a94e55789d04efa13cf35236b8da94133f0006224261cf412f23be75e56a430022116
Xbaf17f1fd09872f9c1a3699cf1e802aa0dd145dc4fdce0938d8412f06cd0f3763de6b73d84ba737f
Xb43a30f244569f6900e4eacab58de3b0959113c8d62efee990861f83ced698742f793ceee8571c30
X483665d1ab07b031914c844f15bf3be82c3f2a9a9eb95fd492e7472d2297cc5bee5f27825377b562
Xdb8ebbcff961deddc59b5c601bd3910d26d206adb28514d85ecf6b527fea78bb504879aced34a884
X36e51d3c1753741d8c47caed9d0a40ef3145e221da27eb70df730ba3183c8789739ac0a69a58dfc6
X54b134c1ac3e242ecc4939027b2dda998f15bc0129fd38c727d5318f604aaff5f29c6818c38aa2ec
X1019d4c3a8fb936e20ed7b390b68611989a0906f1cc7829e9952ef4b850e9e8ccd063a9067002f8e
Xcfac8cb7eaa24b11988b4e6c46f066dfca7eec08c7bba664831d17bd63f575e69764350e47870d42
X026ca4a28167d58761b6adabaa6564d270da237b25e1c74aa1c901a00eb0a5da7670f74151c05aea
X933dfa320759ff1a56010ab85fdecb783f32edf8aebedbb939f8326dd20858c59b638be4a572c80a
X28e0a19f432099fc3a37c3cdbf95c585b392c12a6aa707d752f66a6112d483b196435b5e3e75802b
X3ba52b33a99f51a5bda1e15778c2e70cfcae7ce0d16022672affac4d4a5109470ab2b83a7a04e579
X340dfd80b916e922e29d5e9bf5624af44ca9d9af6bbd2cfee3b7f620c2746e075b42b9b6a06919bc
Xf0f2c40f72217ab514c19df3f3802daee094beb4a2101aff0529575d55cdb27ca33bddb26528b37d
X740c05dbe96a62c4407828466d30d706bbf48e2cbce2d3de049e37fa01b5e6342d886d8d7e5a2e7e
Xd741201306e90f97e45d3ebab8ad338613051b250c03535471c89b75c638fbd0197f11a1ef0f08fb
Xf844865138409563452f44435d464d5503d8764cb1b8d638a70bba2f94b3d210eb6692a7d409c2d9
X68838526a6db8a15751f6c98de769a88c9ee46681a82a3730896aa4942233681f62c55cb9f1c5404
Xf74fb15cc06e43126ffe5d728aa8678b337cd129
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.ok << 'fubar'
XqBidy0xYOJYudpCrAbOnH.h2sqZL.0J4bqQ04sjtuWpdKCIB2Zx:P5SiUm1TJySw0HonIo0pSd3I
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
X$bin/cookfp < test.in > test.out
Xif test $? -ne 0 ; then fail; fi
X 
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.ok << 'fubar'
X4084908062     2066
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
X$bin/cookfp -checksum < test.in > test.out
Xif test $? -ne 0 ; then fail; fi
X 
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.ok << 'fubar'
X6EF86FBFAC3674A2C9FBA415813F46B3
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
X$bin/cookfp -md < test.in > test.out
Xif test $? -ne 0 ; then fail; fi
X 
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.ok << 'fubar'
X9A1E964D 21DFDCDA 664499F1 42665FAD 86113627 35726F4A ABD85F4B 33356E1B
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
X$bin/cookfp -snefru < test.in > test.out
Xif test $? -ne 0 ; then fail; fi
X 
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X
X#
X# Only definite negatives are possible.
X# The functionality exercised by this test appears to work,
X# no other guarantees are made.
X#
Xpass
END_OF_FILE
if test 5641 -ne `wc -c <'test/00/t0046a.sh'`; then
    echo shar: \"'test/00/t0046a.sh'\" unpacked with wrong size!
fi
# end of 'test/00/t0046a.sh'
fi
echo shar: End of archive 8 \(of 19\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 19 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
