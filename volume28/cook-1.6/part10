Newsgroups: comp.sources.unix
From: pmiller@bmr.gov.au (Peter Miller)
Subject: v28i103: cook - a file construction tool, V1.6, Part10/19
References: <1.775008949.28543@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: pmiller@bmr.gov.au (Peter Miller)
Posting-Number: Volume 28, Issue 103
Archive-Name: cook-1.6/part10

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 10 (of 19)."
# Contents:  BUILDING aux/BUILDING.man c_incl/cache.c common/error.c
#   cook/builtin/text.c cook/parse.y doc/system.so make2cook/lex.c
#   man1/cook.1
# Wrapped by vixie@gw.home.vix.com on Sat Jul 23 17:11:25 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'BUILDING' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'BUILDING'\"
else
echo shar: Extracting \"'BUILDING'\" \(9862 characters\)
sed "s/^X//" >'BUILDING' <<'END_OF_FILE'
X
X
X
Xbuilding(cook)					   building(cook)
X
X
XNAME
X	cook - a file construction tool
X
XSPACE REQUIREMENTS
X	You will need about 5MB	to unpack and build the	cook
X	program.  Your milage may vary.
X
XSITE CONFIGURATION
X	The cook package is configured using the configure
X	program	included in this distribution.
X
X	The configure shell script attempts to guess correct
X	values for various system-dependent variables used during
X	compilation, and creates the Makefile and common/config.h
X	files.	It also	creates	a shell	script config.status that
X	you can	run in the future to recreate the current
X	configuration.
X
X	Normally, you just cd to the directory containing cook's
X	source code and	type
X		% ./configure
X		...lots	of output...
X		%
X	If you're using	csh on an old version of System	V, you
X	might need to type
X		% sh configure
X		...lots	of output...
X		%
X	instead	to prevent csh from trying to execute configure
X	itself.
X
X	Running	configure takes	a minute or two.  While	it is
X	running, it prints some	messages that tell what	it is
X	doing.	If you don't want to see the messages, run
X	configure with its standard output redirected to
X	/dev/null; for example,
X		% ./configure >	/dev/null
X		%
X
X	To compile the cook package in a different directory from
X	the one	containing the source code, you	must use a
X	version	of make	that supports the VPATH	variable, such as
X	GNU make.  cd to the directory where you want the object
X	files and executables to go and	run the	configure script.
X	configure automatically	checks for the source code in the
X	directory that configure is in and in ..  (the parent
X	directory).  If	for some reason	configure is not in the
X	source code directory that you are configuring,	then it
X	will report that it can't find the source code.	 In that
X	case, run configure with the option --srcdir=DIR, where
X	DIR is the directory that contains the source code.
X
X	By default, configure will arrange for the make	install
X	command	to install the cook package's files in
X
X
X
X								1
X
X
X
X
X
Xbuilding(cook)					   building(cook)
X
X
X	/usr/local/bin,	/usr/local/man,	etc.  You can specify an
X	installation prefix other than /usr/local by giving
X	configure the option --prefix=PATH.
X
X	You can	specify	separate installation prefixes for
X	architecture-specific files and	architecture-independent
X	files.	If you give configure the option --exec-
X	prefix=PATH the	cook package will use PATH as the prefix
X	for installing programs	and libraries.	Data files and
X	documentation will still use the regular prefix.
X	Normally, all files are	installed using	the same prefix.
X
X	configure ignores any other arguments that you give it.
X
X	On systems that	require	unusual	options	for compilation
X	or linking that	the cook package's configure script does
X	not know about,	you can	give configure initial values for
X	variables by setting them in the environment.  In Bourne-
X	compatible shells, you can do that on the command line
X	like this:
X		% CC='gcc -traditional'	LIBS=-lposix ./configure
X		...lots	of output...
X		%
X	Here are the make variables that you might want	to
X	override with environment variables when running
X	configure.
X
X	Variable: CC
X		C compiler program.  The default is cc.
X
X	Variable: INSTALL
X		Program	to use to install files.  The default is
X		install	if you have it,	cp otherwise.
X
X	Variable: LIBS
X		Libraries to link with,	in the form -lfoo -lbar.
X		The configure script will append to this, rather
X		than replace it.
X
X	If you need to do unusual things to compile the	package,
X	the author encourages you to figure out	how configure
X	could check whether to do them,	and mail diffs or
X	instructions to	the author so that they	can be included
X	in the next release.
X
XBUILDING COOK
X	All you	should need to do is use the
X		% make
X		...lots	of output...
X		%
X	command	and wait.  When	this finishes you should see a
X	directory called bin containing	eight files: c_incl,
X	cook, cookfp, cooktime,	find_libs, make2cook, roffpp and
X	txt2c.
X
X
X
X								2
X
X
X
X
X
Xbuilding(cook)					   building(cook)
X
X
X	cook	cook program is	a file construction tool, and may
X		invoke the following tools in some of its
X		recipes.
X
X	cookfp	The cookfp program is a	utility	distributed with
X		cook which calculates the fingerprints of files.
X		It uses	the same algorithm as the fingerprints
X		used by	cook itself.  For more information, see
X		cook(1)	and cookfp(1).
X
X	cooktime
X		The cooktime program is	a utility distributed
X		with cook which	allows the time-last-modified and
X		time-last-accessed stamps of files to be set to
X		specific times.	 For more information, see
X		cooktime(1).
X
X	c_incl	The c_incl program is a	utility	distributed with
X		cook which examines C files and	determines all
X		the files it includes directly and indirectly.
X		For more information, see c_incl(1).
X
X	find_libs
X		The find_libs program is a utility distributed
X		with cook which	tracks down the	names of library
X		files, given cc-style library options (-L and
X		-l).  For more information, see	find_libs(1).
X
X	roffpp	The roffpp program is a	utility	distributed with
X		cook which acts	as a proprocessor for *roff
X		files, removing	source (.so) directives.  It
X		accepts	include	search path command line options
X		just as	/lib/cpp does.	For more information, see
X		roffpp(1).
X
X	make2cook
X		The make2cook program is a utility to help
X		convert	Makefiles into cookbooks.  An exact 1:1
X		semantic mapping is not	possible, so some
X		addition editing is often required.
X
X	txt2c	The txt2c program is a utility used to build the
X		cook package; it is not	intended for general use
X		and should not be installed.
X
X	You can	remove the program binaries and	object files from
X	the source directory by	using the
X		% make clean
X		...lots	of output...
X		%
X	command.  To remove all	of thr above files, and	also
X	remove the Makefile and	common/config.h	and config.status
X	files, use the
X		% make distclean
X
X
X
X								3
X
X
X
X
X
Xbuilding(cook)					   building(cook)
X
X
X		...lots	of output...
X		%
X	command.
X
X	The file aux/configure.in is used to create configure by
X	a GNU program called autoconf.	You only need to know
X	this if	you want to regenerate configure using a newer
X	version	of autoconf.
X
XTESTING	COOK
X	The cook program comes with a test suite.  To run this
X	test suite, use	the command
X		% make sure
X		...lots	of output...
X		Passed All Tests
X		%
X
X	The tests take a few seconds each, with	a few very fast,
X	and a couple very slow,	but it varies greatly depending
X	on your	CPU.
X
X	If all went well, the message
X		Passed All Tests
X	should appear at the end of the	make.
X
XINSTALLING COOK
X	As explained in	the SITE CONFIGURATION section,	above,
X	the cook package is installed under the	/usr/local tree
X	by default.  Use the --prefix=PATH option to configure if
X	you want some other path.
X
X	All that is required to	install	the cook package is to
X	use the
X		% make install
X		...lots	of output...
X		%
X	command.  Control of the directories used may be found in
X	the first few lines of the Makefile file if you	want to
X	bypass the configure script.
X
XPRINTED	MANUALS
X	This distribution contains the sources to all of the
X	documentation for cook.	 The author used the GNU groff
X	package	and a postscript printer to prepare the
X	documentation.	If you do not have this	software, you
X	will need to substitute	commands appropriate to	your
X	site.
X
X	To print copies	of the README and BUILDING files, the
X	following commands may be used
X		% cd aux
X		% groff	-s -t -man *.man | lpr
X		% cd ..
X		%
X
X
X
X								4
X
X
X
X
X
Xbuilding(cook)					   building(cook)
X
X
X	This will produce about	4 pages.  The "-s" flag	means
X	preprocess with	soelim(1), and the "-t"	flag means
X	preprocess with	tbl(1).
X
X	To print copies	of the manual entries, the following
X	commands may be	used
X		% cd man1
X		% groff	-s -t -man *.1 | lpr
X		% cd ..
X		%
X	This will produce about	8 pages.  The "-s" flag	means
X	preprocess with	soelim(1), and the "-t"	flag means
X	preprocess with	tbl(1).
X
X	To print a copy	of the Reference Manual, the following
X	commands may be	used
X		% cd doc
X		% groff	-s -t -mm refman.t | lpr
X		% cd ..
X		%
X	This will produce about	35 pages.  The "-s" flag means
X	preprocess with	soelim(1), the "-t" flag means preprocess
X	with tbl(1).  Alternatively, you could get a PostScript
X	copy of	the Reference Manual from the archive site given
X	in the README file.
X
XGETTING	HELP
X	If you need assistance with the	cook program, please do
X	not hesitate to	contact	the author at
X		Peter Miller <pmiller@bmr.gov.au>
X	Any and	all feedback is	welcome.
X
X	When reporting problems, please	include	the version
X	number given by	the
X		% cook -version
X		cook version 1.6.D003
X		...warranty disclaimer...
X		%
X	command.  Please do not	send this example; run the
X	program	for the	exact version number.
X
X	In the common/main.h file, there is a define of	DEBUG in
X	comments.  If the comments are removed,	extensive
X	debugging is turned on.	 This causes some performance
X	loss, but performs much	run-time checking and adds the
X	-TRACIng command line option.
X
X	When the -TRACing option is followed by	one or more file
X	names, it turns	on execution traces in those source
X	files.	It is best to put this option on the end of the
X	command, so that the names of the files	to be traced are
X	not confused with any other filenames or strings on the
X	command	line.
X
X
X
X
X								5
X
X
X
X
X
Xbuilding(cook)					   building(cook)
X
X
XCOPYRIGHT
X	cook version 1.6
X	Copyright (C) 1988, 1989, 1990,	1991, 1992, 1993, 1994
X	Peter Miller.
X	All rights reserved.
X
X	The cook package is distributed	in the hope that it will
X	be useful, but WITHOUT ANY WARRANTY; without even the
X	implied	warranty of MERCHANTABILITY or FITNESS FOR A
X	PARTICULAR PURPOSE.  See the GNU General Public	License
X	for more details.
X
X	It should be in	the LICENSE file included with this
X	distribution.
X
XAUTHOR
X	Peter Miller   UUCP	  uunet!munnari!bmr.gov.au!pmiller
X	/\/\*	       Internet	  pmiller@bmr.gov.au
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X								6
X
X
END_OF_FILE
if test 9862 -ne `wc -c <'BUILDING'`; then
    echo shar: \"'BUILDING'\" unpacked with wrong size!
fi
# end of 'BUILDING'
fi
if test -f 'aux/BUILDING.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aux/BUILDING.man'\"
else
echo shar: Extracting \"'aux/BUILDING.man'\" \(11702 characters\)
sed "s/^X//" >'aux/BUILDING.man' <<'END_OF_FILE'
X'\" t
X.\"	cook - file construction tool
X.\"	Copyright (C) 1992, 1993, 1994 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: source of the BUILDING file
X.\"
X.TH building cook
X.so ../doc/version.so
X.if n .hy 0
X.if n .ad l
X.if n .nr IN 8n
X.SH NAME
Xcook \- a file construction tool
X.SH SPACE REQUIREMENTS
XYou will need about 5MB to unpack and build the
X.I cook
Xprogram.
XYour milage may vary.
X.br
X.ne 1i
X.SH SITE CONFIGURATION
XThe
X.B cook
Xpackage is configured using the
X.I configure
Xprogram included in this distribution.
X.PP
XThe
X.I configure
Xshell script attempts to guess correct values for
Xvarious system-dependent variables used during compilation,
Xand creates the
X.I Makefile
Xand
X.I common/config.h
Xfiles.
XIt also creates a shell script
X.I config.status
Xthat you can run in the future to recreate the current configuration.
X.PP
XNormally,
Xyou just
X.I cd
Xto the directory containing 
X.IR cook "'s"
Xsource code and type
X.RS
X.ft CW
X.nf
X\fB% \fP./configure
X\fI\&...lots of output...\fP
X\fB%\fP
X.fi
X.ft R
X.RE
XIf you're using
X.I csh
Xon an old version of System V,
Xyou might need to type
X.RS
X.ft CW
X.nf
X\fB% \fPsh configure
X\fI\&...lots of output...\fP
X\fB%\fP
X.fi
X.ft R
X.RE
Xinstead to prevent
X.I csh
Xfrom trying to execute
X.I configure
Xitself.
X.PP
XRunning
X.I configure
Xtakes a minute or two.
XWhile it is running,
Xit prints some messages that tell what it is doing.
XIf you don't want to see the messages,
Xrun
X.I configure
Xwith its standard output redirected to
X.IR /dev/null ;
Xfor example,
X.RS
X.FT CW
X.nf
X\fB% \fP./configure > /dev/null
X\bB%\fP
X.fi
X.ft R
X.RE
X.PP
XTo compile the
X.B cook
Xpackage in a different directory from the one
Xcontaining the source code,
Xyou must use a version of
X.I make
Xthat supports the
X.I VPATH variable,
Xsuch as
X.IR "GNU make" .
X.I cd
Xto the directory where you want the object files and executables to go and run
Xthe
X.I configure
Xscript.
X.I configure
Xautomatically checks for the source code in the directory that
X.I configure
Xis in and in
X.IR \&..
X(the parent directory).
XIf for some reason
X.I configure
Xis not in the source code directory that you are configuring,
Xthen it will report that it can't find the source code.
XIn that case,
Xrun
X.I configure
Xwith the option \f(CW--srcdir=\fP\fIDIR\fP,
Xwhere
X.I DIR
Xis the directory that contains the source code.
X.PP
XBy default,
X.I configure
Xwill arrange for the
X.I "make install"
Xcommand to install the
X.B cook
Xpackage's files in
X.IR /usr/local/bin ,
X.IR /usr/local/man ,
Xetc.
XYou can specify an installation prefix other than
X.I /usr/local
Xby giving
X.I configure
Xthe option \f(CW--prefix=\fP\fIPATH\fP.
X.PP
XYou can specify separate installation prefixes for
Xarchitecture-specific files and architecture-independent files.
XIf you give
X.I configure
Xthe option \f(CW--exec-prefix=\fP\fIPATH\fP
Xthe
X.B cook
Xpackage will use
X.I PATH
Xas the prefix for installing programs and libraries.
XData files and documentation will still use the regular prefix.
XNormally,
Xall files are installed using the same prefix.
X.PP
X.I configure
Xignores any other arguments that you give it.
X.PP
XOn systems that require unusual options for compilation or linking
Xthat the
X.I cook
Xpackage's
X.I configure
Xscript does not know about,
Xyou can give
X.I configure
Xinitial values for variables by setting them in the environment.
XIn Bourne-compatible shells,
Xyou can do that on the command line like this:
X.RS
X.ft CW
X.nf
X\fB% \fPCC='gcc -traditional' LIBS=-lposix ./configure
X\fI\&...lots of output...\fP
X\fB%\fP
X.fi
X.ft R
X.RE
XHere are the
X.I make
Xvariables that you might want to override with
Xenvironment variables when running
X.IR configure .
X.TP 8n
XVariable: CC
XC compiler program.
XThe default is
X.IR cc .
X.TP 8n
XVariable: INSTALL
XProgram to use to install files.
XThe default is
X.I install
Xif you have it,
X.I cp
Xotherwise.
X.TP 8n
XVariable: LIBS
XLibraries to link with,
Xin the form \f(CW-l\fP\fIfoo\fP \f(CW-l\fP\fIbar\fP.
XThe
X.I configure
Xscript will append to this,
Xrather than replace it.
X.PP
XIf you need to do unusual things to compile the package,
Xthe author encourages you to figure out how
X.I configure
Xcould check whether to do them,
Xand mail diffs or instructions to the author
Xso that they can be included in the next release.
X.br
X.ne 1i
X.SH BUILDING COOK
XAll you should need to do is use the
X.RS
X.ft CW
X.nf
X\fB% \fPmake
X\fI\&...lots of output...\fP
X\fB%\fP
X.fi
X.ft R
X.RE
Xcommand and wait.
XWhen this finishes you should see a directory called
X.I bin
Xcontaining eight files:
X.IR c_incl ,
X.IR cook ,
X.IR cookfp ,
X.IR cooktime ,
X.IR find_libs ,
X.IR make2cook ,
X.IR roffpp
Xand
X.IR txt2c .
X.TP 8n
X.B cook
X.The
X.I cook
Xprogram is a file construction tool,
Xand may invoke the following tools
Xin some of its recipes.
X.TP 8n
X.B cookfp
XThe
X.I cookfp
Xprogram is a utility distributed with
X.I cook
Xwhich calculates the fingerprints of files.
XIt uses the same algorithm as the fingerprints used by
X.I cook
Xitself.
XFor more information, see
X.IR cook (1)
Xand
X.IR cookfp (1).
X.TP 8n
X.B cooktime
XThe
X.I cooktime
Xprogram is a utility distributed with
X.I cook
Xwhich allows the time-last-modified and time-last-accessed
Xstamps of files to be set to specific times.
XFor more information, see
X.IR cooktime (1).
X.TP 8n
X.B c_incl
XThe
X.I c_incl
Xprogram is a utility distributed with
X.I cook
Xwhich examines C files and determines all the files it includes
Xdirectly and indirectly.
XFor more information, see
X.IR c_incl (1).
X.TP 8n
X.B find_libs
XThe
X.I find_libs
Xprogram is a utility distributed with
X.I cook
Xwhich tracks down the names of library files,
Xgiven cc-style library options (-L and -l).
XFor more information, see
X.IR find_libs (1).
X.TP 8n
X.B roffpp
XThe
X.I roffpp
Xprogram is a utility distributed with
X.I cook
Xwhich acts as a proprocessor for *roff
Xfiles,
Xremoving source (\&.so) directives.
XIt accepts include search path command line options
Xjust as \fI/lib/cpp\fP does.
XFor more information, see
X.IR roffpp (1).
X.TP 8n
X.B make2cook
XThe
X.I make2cook
Xprogram is a utility to help convert Makefiles into cookbooks.
XAn exact 1:1 semantic mapping is not possible,
Xso some addition editing is often required.
X.TP 8n
X.B txt2c
XThe
X.I txt2c
Xprogram is a utility used to build the
X.I cook
Xpackage;
Xit is not intended for general use and should not be installed.
X.PP
XYou can remove the program binaries and object files from the
Xsource directory by using the
X.RS
X.ft CW
X.nf
X\fB% \fPmake clean
X\fI\&...lots of output...\fP
X\fB%\fP
X.fi
X.ft R
X.RE
Xcommand.
XTo remove all of thr above files, and also remove the
X.I Makefile
Xand
X.I common/config.h
Xand
X.I config.status
Xfiles, use the
X.RS
X.ft CW
X.nf
X\fB% \fPmake distclean
X\fI\&...lots of output...\fP
X\fB%\fP
X.fi
X.ft R
X.RE
Xcommand.
X.PP
XThe file
X.I aux/configure.in
Xis used to create
X.I configure
Xby a GNU program called
X.IR autoconf .
XYou only need to know this if you want to regenerate
X.I configure
Xusing a newer version of
X.IR autoconf .
X.br
X.ne 1i
X.SH TESTING COOK
XThe
X.I cook
Xprogram comes with a test suite.
XTo run this test suite, use the command
X.RS
X.ft CW
X.nf
X\fB% \fPmake sure
X\fI\&...lots of output...\fP
X.if n \fBPassed All Tests\fP
X.if t \f(CBPassed All Tests\fP
X\fB%\fP
X.fi
X.ft R
X.RE
X.PP
XThe tests take a few seconds each,
Xwith a few very fast,
Xand a couple very slow,
Xbut it varies greatly depending on your CPU.
X.PP
XIf all went well, the message
X.RS
X.ft CW
XPassed All Tests
X.ft R
X.RE
Xshould appear at the end of the make.
X.br
X.ne 1i
X.SH INSTALLING COOK
XAs explained in the
X.I "SITE CONFIGURATION"
Xsection, above,
Xthe
X.I cook
Xpackage is installed under the
X.I /usr/local
Xtree by default.
XUse the \f(CW--prefix=\fP\fIPATH\fP option to
X.I configure
Xif you want some other path.
X.PP
XAll that is required to install the
X.I cook
Xpackage is to use the
X.RS
X.ft CW
X.nf
X\fB% \fPmake install
X\fI\&...lots of output...\fP
X\fB%\fP
X.fi
X.ft R
X.RE
Xcommand.
XControl of the directories used may be found in the first
Xfew lines of the
X.I Makefile
Xfile if you want to bypass the
X.I configure
Xscript.
X.br
X.ne 1i
X.SH PRINTED MANUALS
XThis distribution contains the sources to
Xall of the documentation for
X.IR cook .
XThe author used the GNU groff package
Xand a postscript printer to prepare the documentation.
XIf you do not have this software,
Xyou will need to substitute commands appropriate to your site.
X.PP
XTo print copies of the
X.I README
Xand
X.I BUILDING
Xfiles,
Xthe following commands may be used
X.RS
X.ft CW
X.nf
X\fB% \fPcd aux
X\fB% \fPgroff -s -t -man *.man | lpr
X\fB% \fPcd ..
X\fB%\fP
X.fi
X.ft R
X.RE
XThis will produce about 4 pages.
XThe "-s" flag means preprocess with
X.IR soelim (1),
Xand the "-t" flag means preprocess with
X.IR tbl (1).
X.PP
XTo print copies of the manual entries,
Xthe following commands may be used
X.RS
X.ft CW
X.nf
X\fB% \fPcd man1
X\fB% \fPgroff -s -t -man *.1 | lpr
X\fB% \fPcd ..
X\fB%\fP
X.fi
X.ft R
X.RE
XThis will produce about 8 pages.
XThe "-s" flag means preprocess with
X.IR soelim (1),
Xand the "-t" flag means preprocess with
X.IR tbl (1).
X.PP
XTo print a copy of the Reference Manual,
Xthe following commands may be used
X.RS
X.ft CW
X.nf
X\fB% \fPcd doc
X\fB% \fPgroff -s -t -mm refman.t | lpr
X\fB% \fPcd ..
X\fB%\fP
X.fi
X.ft R
X.RE
XThis will produce about 35 pages.
XThe "-s" flag means preprocess with
X.IR soelim (1),
Xthe "-t" flag means preprocess with
X.IR tbl (1).
XAlternatively,
Xyou could get a PostScript copy of the Reference Manual from the archive site
Xgiven in the
X.I README
Xfile.
X.br
X.ne 1i
X.SH GETTING HELP
XIf you need assistance with the
X.I cook
Xprogram,
Xplease do not hesitate to contact the author at
X.RS
X.ft CW
XPeter Miller <pmiller@bmr.gov.au>
X.ft R
X.RE
XAny and all feedback is welcome.
X.PP
XWhen reporting problems,
Xplease include the version number
Xgiven by the
X.RS
X.ft CW
X.nf
X\fB% \fPcook -version
X.if n \fBcook version\fP \fI\*(V)\fP
X.if t \f(CBcook version\fP \fI\*(V)\fP
X\fI\&...warranty disclaimer...\fP
X\fB%\fP
X.fi
X.ft R
X.RE
Xcommand.
XPlease do not send this example;
Xrun the program for the exact version number.
X.PP
XIn the
X.I common/main.h
Xfile, there is a define of
X.I DEBUG
Xin comments.
XIf the comments are removed,
Xextensive debugging is turned on.
XThis causes some performance loss,
Xbut performs much run-time checking
Xand adds the
X.B -TRACIng
Xcommand line option.
X.PP
XWhen the
X.B -TRACing
Xoption is followed by one or more file names,
Xit turns on execution traces in those source files.
XIt is best to put this option on the end of the command,
Xso that the names of the files to be traced are not confused
Xwith any other filenames or strings on the command line.
X.br
X.ne 2i
X.SH COPYRIGHT
X.I cook
Xversion \*(v)
X.br
XCopyright
X.if n (C)
X.if t \(co
X1988, 1989, 1990, 1991, 1992, 1993, 1994 Peter Miller.
X.br
XAll rights reserved.
X.PP
XThe
X.I cook
Xpackage is distributed in the hope that it will be useful,
Xbut WITHOUT ANY WARRANTY;
Xwithout even the implied warranty of MERCHANTABILITY or
XFITNESS FOR A PARTICULAR PURPOSE.
XSee the GNU General Public License for more details.
X.PP
XIt should be in the
X.I LICENSE
Xfile included with this distribution.
X.br
X.ne 1i
X.SH AUTHOR
X.TS
Xtab(;);
Xl l l.
XPeter Miller;UUCP;uunet!munnari!bmr.gov.au!pmiller
X\f(CW/\e/\e*\fP;Internet;pmiller@bmr.gov.au
X.TE
END_OF_FILE
if test 11702 -ne `wc -c <'aux/BUILDING.man'`; then
    echo shar: \"'aux/BUILDING.man'\" unpacked with wrong size!
fi
# end of 'aux/BUILDING.man'
fi
if test -f 'c_incl/cache.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'c_incl/cache.c'\"
else
echo shar: Extracting \"'c_incl/cache.c'\" \(10078 characters\)
sed "s/^X//" >'c_incl/cache.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate include file cache
X */
X
X#include <stdio.h>
X#include <ac/string.h>
X
X#include <arglex.h>
X#include <cache.h>
X#include <error.h>
X#include <mem.h>
X#include <os.h>
X#include <symtab.h>
X
X
Xstatic	int		need_to_write;
Xstatic	symtab_ty	*symtab;
X
X
Xstatic void reap _((void *));
X
Xstatic void
Xreap(p)
X	void		*p;
X{
X	cache_ty	*cp;
X
X	cp = p;
X	wl_free(&cp->ingredients);
X	mem_free(cp);
X}
X
X
X/*
X * NAME
X *	cache_initialize - start up cache
X *
X * SYNOPSIS
X *	void cache_initialize(void);
X *
X * DESCRIPTION
X *	The cache_initialize function is used to create the hash table.
X *
X * RETURNS
X *	void
X *
X * CAVEAT
X *	Assumes the str_initialize function has been called already.
X */
X
Xvoid
Xcache_initialize()
X{
X	symtab = symtab_alloc(100);
X	symtab->reap = reap;
X}
X
X
X/*
X * NAME
X *	cache_search - search for a variable
X *
X * SYNOPSIS
X *	int cache_search(string_ty *filename);
X *
X * DESCRIPTION
X *	The cache_search function is used to search for
X *	a filename in the cache.
X *
X * RETURNS
X *	If the variable has been defined, the function returns a non-zero value
X *	and the value is returned through the 'value' pointer.
X *	If the variable has not been defined, it returns zero,
X *	and 'value' is unaltered.
X *
X * CAVEAT
X *	The value returned from this function, when returned, is allocated
X *	in dynamic memory (it is a copy of the value remembered by this module).
X *	It is the responsibility of the caller to free it when finished with,
X *	by a wl_free() call.
X */
X
Xcache_ty *
Xcache_search(filename)
X	string_ty	*filename;
X{
X	cache_ty	*cp;
X
X	assert(symtab);
X	cp = symtab_query(symtab, filename);
X	if (!cp)
X	{
X		cp = mem_alloc(sizeof(cache_ty));
X		memset(&cp->st, 0, sizeof(cp->st));
X		wl_zero(&cp->ingredients);
X		symtab_assign(symtab, filename, cp);
X	}
X	return cp;
X}
X
X
X/*
X * NAME
X *	build_filename - for cache file
X *
X * SYNOPSIS
X *	void build_filename(char *buffer);
X *
X * DESCRIPTION
X *	The build_filename function is used to build
X *	the name of the cache file.
X *
X * ARGUMENTS
X *	buffer	- where to put the file name
X *
X * CAVEATS
X *	The cache file is in the current directory.
X */
X
Xstatic char *build_filename _((void));
X
Xstatic char *
Xbuild_filename()
X{
X	static string_ty *s;
X
X	if (!s)
X		s = str_format(".%.11src", progname);
X	return s->str_text;
X}
X
X
X/*
X * NAME
X *	fread_sane - a saner version of fread
X *
X * SYNOPSIS
X *	int fread_sane(FILE *fp, void *buf, size_t buflen);
X *
X * DESCRIPTION
X *	The fread_sane function is used to read from a standard stream.
X *
X * ARGUMENTS
X *	fp	- the stream to read from
X *	buf	- where to place the bytes read
X *	buflen	- number of bytes to read
X *
X * RETURNS
X *	0 on no error, -1 on any error
X *
X * CAVEATS
X *	This version considers it to be an error if end-of-file is reached.
X */
X
Xstatic int fread_sane _((FILE *, void *, size_t));
X
Xstatic int
Xfread_sane(fp, buf, buflen)
X	FILE		*fp;
X	void		*buf;
X	size_t		buflen;
X{
X	if (fread(buf, 1, buflen, fp) != buflen)
X		return -1;
X	return 0;
X}
X
X
X/*
X * NAME
X *	cache_read_string - read a string from a file
X *
X * SYNOPSIS
X *	string_ty *cache_read_string(FILE *fp));
X *
X * DESCRIPTION
X *	The cache_read_string function is used to read a string
X *	from a file.
X *
X * ARGUMENTS
X *	fp	- file to read string from
X *
X * RETURNS
X *	pointer to string if successful, 0 if not.
X *
X * CAVEATS
X *	Must be symmetric with cache_write string below.
X */
X
Xstatic string_ty *cache_read_string _((FILE *));
X
Xstatic string_ty *
Xcache_read_string(fp)
X	FILE		*fp;
X{
X	static size_t	buflen;
X	static char	*buf;
X	size_t		len;
X
X	if (fread_sane(fp, &len, sizeof(len)))
X		return 0;
X	if (len > buflen)
X	{
X		buflen = (len + 0xFF) & ~0xFF;
X		buf = mem_change_size(buf, buflen);
X	}
X	if (fread_sane(fp, buf, len))
X		return 0;
X	return str_n_from_c(buf, len);
X}
X
X
X/*
X * NAME
X *	cache_read_item - read a cache item from a file
X *
X * SYNOPSIS
X *	int cache_read_item(FILE *fp);
X *
X * DESCRIPTION
X *	The cache_read_item function is used to read an item from
X *	the cache file and installit into the cache.
X *
X * ARGUMENTS
X *	fp	- the file to read the item from
X *
X * RETURNS
X *	0 in success, -1 on any error
X *
X * CAVEATS
X *	Must be symmetric with cache_write_item below.
X */
X
Xstatic int cache_read_item _((FILE *));
X
Xstatic int
Xcache_read_item(fp)
X	FILE		*fp;
X{
X	string_ty	*s;
X	cache_ty	*cp;
X	size_t		nitems;
X	size_t		j;
X
X	s = cache_read_string(fp);
X	if (!s)
X		return -1;
X	cp = cache_search(s);
X	assert(cp);
X	if (fread_sane(fp, &cp->st, sizeof(cp->st)))
X		return -1;
X	if (fread_sane(fp, &nitems, sizeof(nitems)))
X		return -1;
X	for (j = 0; j < nitems; ++j)
X	{
X		s = cache_read_string(fp);
X		if (!s)
X			return -1;
X		wl_append_unique(&cp->ingredients, s);
X		str_free(s);
X	}
X	return 0;
X}
X
X
X/*
X * NAME
X *	cache_read - read the cache file into the cache
X *
X * SYNOPSIS
X *	void cache_read(void);
X *
X * DESCRIPTION
X *	The cache_read function is used to read the cache file into the cache.
X *
X * CAVEATS
X *	If the cache file is not there, it is as iff the cache file
X *	contained an image of an empty cache.  I.e. nothing happens,
X *	but it is not an error.
X */
X
Xvoid
Xcache_read()
X{
X	str_hash_ty	nitems;
X	str_hash_ty	j;
X	FILE		*fp;
X	char		*filename;
X
X	/*
X	 * open the cache file.
X	 * if it's not there, quietly slink away
X	 */
X	filename = build_filename();
X	if (!os_exists(filename))
X		return;
X	fp = fopen(filename, "rb");
X	if (!fp)
X	{
X		bomb:
X		nfatal("%s", filename);
X	}
X
X	/*
X	 * get the number of entries in the file
X	 */
X	if (fread_sane(fp, &nitems, sizeof(nitems)))
X		goto bomb;
X
X	/*
X	 * read each entry in the file
X	 */
X	for (j = 0; j < nitems; ++j)
X	{
X		if (cache_read_item(fp))
X			goto bomb;
X	}
X
X	/*
X	 * all done
X	 */
X	fclose(fp);
X}
X
X
X/*
X * NAME
X *	fwrite_sane - a saner version of fwrite
X *
X * SYNOPSIS
X *	int fwrite_sane(FILE *fp, void *buf, size_t buflen);
X *
X * DESCRIPTION
X *	The fwrite_sane function is used to write data to a file.
X *
X * ARGUMENTS
X *	fp	- file to write to
X *	buf	- pointer to data to write
X *	buflen	- number of bytes in data
X *
X * RETURNS
X *	0 on success, -1 on any error
X */
X
Xstatic int fwrite_sane _((FILE *, void *, size_t));
X
Xstatic int
Xfwrite_sane(fp, buf, buflen)
X	FILE		*fp;
X	void		*buf;
X	size_t		buflen;
X{
X	if (fwrite(buf, 1, buflen, fp) != buflen)
X		return -1;
X	return 0;
X}
X
X
X/*
X * NAME
X *	cache_write_string - write a string to a file
X *
X * SYNOPSIS
X *	int cache_write_string(FILE *fp, string_ty *s);
X *
X * DESCRIPTION
X *	The cache_write_string function is used to write a string to a file.
X *
X * ARGUMENTS
X *	fp	- file to write
X *	s	- string to be written
X *
X * RETURNS
X *	0 on success, -1 on any error
X *
X * CAVEATS
X *	Must be symmetric with cache_read_string above.
X */
X
Xstatic int cache_write_string _((FILE *, string_ty *));
X
Xstatic int
Xcache_write_string(fp, s)
X	FILE		*fp;
X	string_ty	*s;
X{
X	if (fwrite_sane(fp, &s->str_length, sizeof(s->str_length)))
X		return -1;
X	if (fwrite_sane(fp, s->str_text, s->str_length))
X		return -1;
X	return 0;
X}
X
X
X/*
X * NAME
X *	cache_write_item - write cache item to cache file
X *
X * SYNOPSIS
X *	int cache_write_item(FILE *fp, cache_ty *cp);
X *
X * DESCRIPTION
X *	The cache_write_item function is used to write a cache
X *	item to a cache  file.
X *
X * ARGUMENTS
X *	fp	- file to write
X *	cp	- pointer to cache item to write
X *
X * RETURNS
X *	0 on success, -1 on any error
X *
X * CAVEATS
X *	Must be symmetric with cache_read_item above.
X */
X
Xstatic int cache_write_item _((FILE *, string_ty *, cache_ty *));
X
Xstatic int
Xcache_write_item(fp, key, cp)
X	FILE		*fp;
X	string_ty	*key;
X	cache_ty	*cp;
X{
X	size_t		j;
X
X	if (cache_write_string(fp, key))
X		return -1;
X	if (fwrite_sane(fp, &cp->st, sizeof(cp->st)))
X		return -1;
X	if (fwrite_sane(fp, &cp->ingredients.wl_nwords, sizeof(cp->ingredients.wl_nwords)))
X		return -1;
X	for (j = 0; j < cp->ingredients.wl_nwords; ++j)
X		if (cache_write_string(fp, cp->ingredients.wl_word[j]))
X			return -1;
X	return 0;
X}
X
X
Xstatic void walk _((symtab_ty *, string_ty *, void *, void *));
X
Xstatic void
Xwalk(stp, key, data, arg)
X	symtab_ty	*stp;
X	string_ty	*key;
X	void		*data;
X	void		*arg;
X{
X	cache_ty	*cp;
X	FILE		*fp;
X
X	cp = data;
X	fp = arg;
X	cache_write_item(fp, key, cp);
X}
X
X
X/*
X * NAME
X *	cache_write - write cache to file
X *
X * SYNOPSIS
X *	void cache_write(void);
X *
X * DESCRIPTION
X *	The cache_write function is used to write the memory image
X *	of the cache into a disk file.
X *
X * CAVEATS
X *	The cache file is in the current directory.
X */
X
Xvoid
Xcache_write()
X{
X	FILE		*fp;
X	char		*filename;
X
X	/*
X	 * don't change the file if we don't have to
X	 */
X	if (!need_to_write)
X		return;
X	need_to_write = 0;
X
X	/*
X	 * open the cache file
X	 */
X	filename = build_filename();
X	fp = fopen(filename, "wb");
X	if (!fp)
X	{
X		bomb:
X		nfatal("%s", filename);
X	}
X
X	/*
X	 * write the number of entries to the file
X	 */
X	if (fwrite_sane(fp, &symtab->hash_load, sizeof(symtab->hash_load)))
X		goto bomb;
X
X	/*
X	 * write each cache entry to the file
X	 */
X	symtab_walk(symtab, walk, fp);
X	if (ferror(fp))
X		goto bomb;
X
X	/*
X	 * close the cache file
X	 */
X	if (fclose(fp))
X		goto bomb;
X}
X
X
X/*
X * NAME
X *	cache_update_notify - cache has changed
X *
X * SYNOPSIS
X *	void cache_update_nitify(void);
X *
X * DESCRIPTION
X *	The cache_update_notify function is called whenever the contents
X *	of the cache is changed.  This notifies the cache_write function
X *	that it needs to rewrite the cache file.
X */
X
Xvoid
Xcache_update_notify()
X{
X	need_to_write = 1;
X}
END_OF_FILE
if test 10078 -ne `wc -c <'c_incl/cache.c'`; then
    echo shar: \"'c_incl/cache.c'\" unpacked with wrong size!
fi
# end of 'c_incl/cache.c'
fi
if test -f 'common/error.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/error.c'\"
else
echo shar: Extracting \"'common/error.c'\" \(9981 characters\)
sed "s/^X//" >'common/error.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to report errors
X */
X
X#include <ctype.h>
X#include <errno.h>
X#include <ac/stddef.h>
X#include <stdio.h>
X#include <ac/stdlib.h>
X#include <ac/string.h>
X#include <ac/time.h>
X
X#include <arglex.h>
X#include <error.h>
X#include <mprintf.h>
X#include <s-v-arg.h>
X
X
X/*
X * NAME
X *	wrap - wrap s string over lines
X *
X * SYNOPSIS
X *	void wrap(char *);
X *
X * DESCRIPTION
X *	The wrap function is used to print error messages onto stderr
X *	wrapping ling lines.
X *
X * CAVEATS
X *	Line length is assumed to be 80 characters.
X */
X
X#define PAGE_WIDTH 79
X
Xstatic void wrap _((char *));
X
Xstatic void
Xwrap(s)
X	char	*s;
X{
X	static char escapes[] = "\rr\nn\ff\bb\tt";
X	char	tmp[PAGE_WIDTH + 2];
X	int	first_line;
X	char	*tp;
X	int	bomb_later;
X	
X	/*
X	 * Flush stdout so that errors are in sync with the output.
X	 * If you get an error doing this, whinge about it _after_ reporting
X	 * the originating error.  Also, clear the error on stdout to 
X	 * avoid getting caught in an infinite loop.
X	 */
X	star_eoln();
X	if (fflush(stdout) || ferror(stdout))
X	{
X		bomb_later = errno;
X		clearerr(stdout);
X	}
X	else
X		bomb_later = 0;
X
X	first_line = 1;
X	while (*s)
X	{
X		char	*ep;
X		int	ocol;
X
X		/*
X		 * Work out how many characters fit on the line.
X		 */
X		if (first_line)
X			ocol = strlen(progname) + 2;
X		else
X			ocol = 8;
X		for (ep = s; *ep; ++ep)
X		{
X			int	cw;
X			int	c;
X
X			c = (unsigned char)*ep;
X			if (isprint(c))
X				cw = 1 + (c == '\\');
X			else
X				cw = (strchr(escapes, c) ? 2 : 4);
X			if (ocol + cw > PAGE_WIDTH)
X				break;
X			ocol += cw;
X		}
X
X		/*
X		 * see if there is a better place to break the line
X		 */
X		if (*ep && *ep != ' ')
X		{
X			char	*mp;
X
X			for (mp = ep; mp > s; --mp)
X			{
X				if (strchr(" /", mp[-1]))
X				{
X					ep = mp;
X					break;
X				}
X			}
X		}
X
X		/*
X		 * ignore trailing blanks
X		 */
X		while (ep > s && ep[-1] == ' ')
X			ep--;
X		
X		/*
X		 * print the line
X		 */
X		if (first_line)
X			sprintf(tmp, "%s: ", progname);
X		else
X			strcpy(tmp, "\t");
X		tp = tmp + strlen(tmp);
X		while (s < ep)
X		{
X			int	c;
X
X			c = (unsigned char)*s++;
X			if (isprint(c))
X			{
X				if (c == '\\')
X					*tp++ = '\\';
X				*tp++ = c;
X			}
X			else
X			{
X				char	*esc;
X
X				esc = strchr(escapes, c);
X				if (esc)
X				{
X					*tp++ = '\\';
X					*tp++ = esc[1];
X				}
X				else
X				{
X					sprintf(tp, "\\%3.3o", c);
X					tp += strlen(tp);
X				}
X			}
X		}
X		*tp++ = '\n';
X		*tp = 0;
X		fputs(tmp, stderr);
X		if (ferror(stderr))
X			break;
X
X		/*
X		 * skip leading spaces for subsequent lines
X		 */
X		while (*s == ' ')
X			s++;
X		first_line = 0;
X	}
X	if (fflush(stderr) || ferror(stderr))
X	{
X		/* don't print why, there is no point! */
X		quit(1);
X	}
X	if (bomb_later)
X	{
X		errno = bomb_later;
X		nfatal("(stdout)");
X	}
X}
X
X
Xstatic void double_jeopardy _((void));
X
Xstatic void
Xdouble_jeopardy()
X{
X	char	buffer[200];
X
X	sprintf
X	(
X		buffer,
X		"while attempting to construct an error message: %s (fatal)",
X		strerror(errno)
X	);
X	wrap(buffer);
X	quit(1);
X}
X
X
Xstatic char *copy_a_string _((char *));
X
Xstatic char *
Xcopy_a_string(s)
X	char		*s;
X{
X	char		*cp;
X
X	errno = 0;
X	cp = malloc(strlen(s) + 1);
X	if (!cp)
X	{
X		if (!errno)
X			errno = ENOMEM;
X		double_jeopardy();
X	}
X	strcpy(cp, s);
X	return cp;
X}
X
X
X/*
X * NAME
X *	error - place a message on the error stream
X *
X * SYNOPSIS
X *	void error(char *s, ...);
X *
X * DESCRIPTION
X *	Error places a message on the error output stream.
X *	The first argument is a printf-like format string,
X *	optionally followed by other arguments.
X *	The message will be prefixed by the program name and a colon,
X *	and will be terminated with a newline, automatically.
X *
X * CAVEAT
X *	Things like "error(filename)" blow up if the filename
X *	contains a '%' character.
X */
X
Xvoid
Xerror(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	va_list		ap;
X	char		*msg;
X
X	sva_init(ap, s);
X	msg = vmprintf(s, ap);
X	va_end(ap);
X	if (!msg)
X		double_jeopardy();
X	wrap(msg);
X}
X
X
X/*
X * NAME
X *	nerror - place a system fault message on the error stream
X *
X * SYNOPSIS
X *	void nerror(char *s, ...);
X *
X * DESCRIPTION
X *	Nerror places a message on the error output stream.
X *	The first argument is a printf-like format string,
X *	optionally followed by other arguments.
X *	The message will be prefixed by the program name and a colon,
X *	and will be terminated with a text description of the error
X *	indicated by the 'errno' global variable, automatically.
X *
X * CAVEAT
X *	Things like "nerror(filename)" blow up if the filename
X *	contains a '%' character.
X */
X
X/*VARARGS1*/
Xvoid
Xnerror(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	va_list		ap;
X	int		n;
X	char		*msg;
X
X	n = errno;
X	sva_init(ap, s);
X	msg = vmprintf(s, ap);
X	va_end(ap);
X	if (!msg)
X		double_jeopardy();
X	msg = copy_a_string(msg);
X	error("%s: %s", msg, strerror(n));
X	free(msg);
X}
X
X
X/*
X * NAME
X *	nfatal - place a system fault message on the error stream and exit
X *
X * SYNOPSIS
X *	void nfatal(char *s, ...);
X *
X * DESCRIPTION
X *	Nfatal places a message on the error output stream and exits.
X *	The first argument is a printf-like format string,
X *	optionally followed by other arguments.
X *	The message will be prefixed by the program name and a colon,
X *	and will be terminated with a text description of the error
X *	indicated by the 'errno' global variable, automatically.
X *
X * CAVEAT
X *	Things like "nfatal(filename)" blow up if the filename
X *	contains a '%' character.
X *
X *	This function does NOT return.
X */
X
X/*VARARGS1*/
Xvoid
Xnfatal(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	va_list		ap;
X	int		n;
X	char		*msg;
X
X	n = errno;
X	sva_init(ap, s);
X	msg = vmprintf(s, ap);
X	va_end(ap);
X	if (!msg)
X		double_jeopardy();
X	msg = copy_a_string(msg);
X	error("%s: %s", msg, strerror(n));
X	free(msg);
X	quit(1);
X}
X
X
X/*
X * NAME
X *	fatal - place a message on the error stream and exit
X *
X * SYNOPSIS
X *	void fatal(char *s, ...);
X *
X * DESCRIPTION
X *	Fatal places a message on the error output stream and exits.
X *	The first argument is a printf-like format string,
X *	optionally followed by other arguments.
X *	The message will be prefixed by the program name and a colon,
X *	and will be terminated with a newline, automatically.
X *
X * CAVEAT
X *	Things like "error(filename)" blow up if the filename
X *	contains a '%' character.
X *
X *	This function does NOT return.
X */
X
Xvoid
Xfatal(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	va_list		ap;
X	char		*msg;
X
X	sva_init(ap, s);
X	msg = vmprintf(s, ap);
X	va_end(ap);
X	if (!msg)
X		double_jeopardy();
X	wrap(msg);
X	quit(1);
X}
X
X
X/*
X * NAME
X *	assert - make an assertion
X *
X * SYNOPSIS
X *	void assert(int condition);
X *
X * DESCRIPTION
X *	Assert is a handy tool for a programmer to guarantee the internal
X *	consistency of their program.  If "-DDEBUG" is specified on
X *	the compiler's command line, then assert will generate code to verify
X *	the assertios made. If no DEBUG is defined, assertions will generate
X *	no code.
X *
X * CAVEAT
X *	If the assertion fails, a fatal diagnostic is issued.
X *
X *	The #define's which control the compilation may be found in "error.h".
X *
X */
X
X#ifdef	DEBUG
X
Xvoid
Xcook_assert(c, s, file, line)
X	int	c;
X	char	*s;
X	char	*file;
X	int	line;
X{
X	if (c)
X		return;
X	error("%s: %d: assertion \"%s\" failed (bug)", file, line, s);
X	abort();
X}
X
X#endif /* DEBUG */
X
X
X/*
X * NAME
X *	quit_handler
X *
X * SYNOPSIS
X *	int quit_handler(quit_ty);
X *
X * DESCRIPTION
X *	The quit_handler function registers the function pointed to by func,
X *	to be called without arguments at normal program termination.
X */
X
Xstatic	quit_ty	quit_list[32];
Xstatic	int	quit_list_length;
X
Xvoid
Xquit_handler(f)
X	quit_ty	f;
X{
X	assert(quit_list_length < SIZEOF(quit_list));
X	quit_list[quit_list_length++] = f;
X}
X
X
X/*
X * NAME
X *	quit - leave program
X *
X * SYNOPSIS
X *	void quit(int status);
X *
X * DESCRIPTION
X *	The quit function causes normal program termination to occur.
X *
X *	First, all functions registered by the quit_handler function are
X *	called, in the reverse order of their registration.
X *
X *	Next, the program is terminated using the exit() function.
X *
X * CAVEAT
X *	The quit function never returns to its caller.
X */
X
Xvoid
Xquit(n)
X	int	n;
X{
X	star_eoln();
X	while (quit_list_length > 0)
X		(*quit_list[--quit_list_length])();
X	exit(n);
X}
X
X
Xstatic int	star_flag;
Xstatic int	star_col;
Xstatic time_t	star_time;
X
X
Xvoid
Xstar()
X{
X	time_t	now;
X
X	if (!star_flag)
X		return;
X	time(&now);
X	if (now < star_time)
X		return;
X	if (!star_col)
X	{
X		fprintf(stderr, "%s: ", progname);
X		star_col = strlen(progname) + 2;
X	}
X	fputc('*', stderr);
X	star_col++;
X	if (star_col >= PAGE_WIDTH)
X	{
X		fputc('\n', stderr);
X		star_col = 0;
X	}
X	fflush(stderr);
X	star_time = now + 1;
X}
X
X
Xvoid
Xstar_eoln()
X{
X	time_t		now;
X
X	if (!star_flag)
X		return;
X	if (star_col)
X	{
X		fputc('\n', stderr);
X		star_col = 0;
X		fflush(stderr);
X	}
X	time(&now);
X	star_time = now + 1;
X}
X
X
Xvoid
Xstar_sync()
X{
X	time_t		when;
X
X	if (!star_flag)
X		return;
X	assert(star_col == 0);
X	if (star_col)
X	{
X		fputc('\n', stderr);
X		star_col = 0;
X		fflush(stderr);
X	}
X	time(&when);
X	when += 5;
X	if (when > star_time)
X		star_time = when;
X}
X
X
Xstatic void star_quit_handler _((void));
X
Xstatic void
Xstar_quit_handler()
X{
X	star_flag = 0;
X	if (star_col)
X	{
X		fputc('\n', stderr);
X		star_col = 0;
X	}
X}
X
X
Xvoid
Xstar_enable()
X{
X	if (star_flag)
X		return;
X	star_flag = 1;
X	quit_handler(star_quit_handler);
X}
END_OF_FILE
if test 9981 -ne `wc -c <'common/error.c'`; then
    echo shar: \"'common/error.c'\" unpacked with wrong size!
fi
# end of 'common/error.c'
fi
if test -f 'cook/builtin/text.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/builtin/text.c'\"
else
echo shar: Extracting \"'cook/builtin/text.c'\" \(11012 characters\)
sed "s/^X//" >'cook/builtin/text.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to implement the builtin text functions
X *
X * The builtin functions all append their results to the supplied
X * `result' word list.  The first word of the `args' word list
X * is the name of the function.
X *
X * all of the functions return 0 in success, or -1 on error.
X */
X
X#include <ac/stdlib.h>
X#include <ac/string.h>
X
X#include <builtin/text.h>
X#include <error.h>
X#include <expr.h>
X#include <mem.h>
X
X
X/*
X * NAME
X *	builtin_upcase - upcase strings
X *
X * SYNOPSIS
X *	int builtin_upcase(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	Defined is a built-in function of cook, described as follows:
X *	This function requires one or more arguments,
X *	which will bu upcased.
X *
X * RETURNS
X *	It returns the arguments upcased.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_upcase(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	if (args->wl_nwords < 2)
X	{
X		expr_error
X		(
X			"%s: requires one or more arguments",
X			args->wl_word[0]->str_text
X		);
X		return -1;
X	}
X	for (j = 1; j < args->wl_nwords; j++)
X	{
X		string_ty *s;
X
X		s = str_upcase(args->wl_word[j]);
X		wl_append(result, s);
X		str_free(s);
X	}
X	return 0;
X}
X
X
X/*
X * NAME
X *	builtin_downcase - downcase strings
X *
X * SYNOPSIS
X *	int builtin_downcase(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	Defined is a built-in function of cook, described as follows:
X *	This function requires one or more arguments,
X *	which will bu downcased.
X *
X * RETURNS
X *	It returns the arguments downcased.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_downcase(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	if (args->wl_nwords < 2)
X	{
X		expr_error
X		(
X			"%s: requires one or more arguments",
X			args->wl_word[0]->str_text
X		);
X		return -1;
X	}
X	for (j = 1; j < args->wl_nwords; j++)
X	{
X		string_ty	*s;
X
X		s = str_downcase(args->wl_word[j]);
X		wl_append(result, s);
X		str_free(s);
X	}
X	return 0;
X}
X
X
X/*
X * NAME
X *	builtin_prepost - add prefix and suffix
X *
X * SYNOPSIS
X *	int builtin_prepost(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	Prepost is a built-in function of cook, described as follows:
X *	This function must have at least two arguments.
X *	The first argument is a prefix and the second argument is a suffix.
X *
X * RETURNS
X *	The resulting word list is the third and later arguments each given
X *	the prefix and suffix as defined by the first and second arguments.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_prepost(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	if (args->wl_nwords < 3)
X	{
X		expr_error
X		(
X			"%s: requires at least two arguments",
X			args->wl_word[0]->str_text
X		);
X		return -1;
X	}
X	for (j = 3; j < args->wl_nwords; j++)
X	{
X		string_ty	*s;
X
X		s =
X			str_cat_three
X			(
X				args->wl_word[1],
X				args->wl_word[j],
X				args->wl_word[2]
X			);
X		wl_append(result, s);
X		str_free(s);
X	}
X	return 0;
X}
X
X
X/*
X * NAME
X *	builtin_head - head of a wordlist
X *
X * SYNOPSIS
X *	int builtin_fromto(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	Head is a built-in function of cook, described as follows:
X *	This function requires zero or more arguments.
X *
X * RETURNS
X *	The wordlist returned is empty if there were no arguemnts,
X *	or the first argument if there were arguments.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_head(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	if (args->wl_nwords >= 2)
X		wl_append(result, args->wl_word[1]);
X	return 0;
X}
X
X
X/*
X * NAME
X *	builtin_tail - tail of a wordlist
X *
X * SYNOPSIS
X *	int builtin_tail(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	Tail is a built-in function of cook, described as follows:
X *	This function requires zero or more arguments.
X *
X * RETURNS
X *	The word list returned will be empty if
X *	there is less than two arguemnts,
X *	otherwise it will consist of the second and later arguments.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_tail(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	for (j = 2; j < args->wl_nwords; j++)
X		wl_append(result, args->wl_word[j]);
X	return 0;
X}
X
X
X/*
X * NAME
X *	builtin_catenate - catenate a wordlist
X *
X * SYNOPSIS
X *	int builtin_catenate(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	Catenate is a built-in function of cook, described as follows:
X *	This function requires zero or more arguments.
X *
X * RETURNS
X *	A word list containg zero words if there were no arguments,
X *	or a single word which is the catenation of the arguments.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_catenate(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X	static char	*tmp;
X	static size_t	tmplen;
X	size_t		length;
X	char		*pos;
X	string_ty	*s;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	if (args->wl_nwords < 2)
X		return 0;
X	if (args->wl_nwords == 2)
X	{
X		wl_append(result, args->wl_word[1]);
X		return 0;
X	}
X
X	length = 0;
X	for (j = 1; j < args->wl_nwords; j++)
X		length += args->wl_word[j]->str_length;
X	if (!tmp)
X	{
X		tmplen = length;
X		if (tmplen < 16)
X			tmplen = 16;
X		tmp = mem_alloc(tmplen);
X	}
X	else
X	{
X		if (tmplen < length)
X		{
X			tmplen = length;
X			tmp = mem_change_size(tmp, tmplen);
X		}
X	}
X	pos = tmp;
X	for (j = 1; j < args->wl_nwords; j++)
X	{
X		s = args->wl_word[j];
X		memcpy(pos, s->str_text, s->str_length);
X		pos += s->str_length;
X	}
X	s = str_n_from_c(tmp, length);
X	wl_append(result, s);
X	str_free(s);
X	return 0;
X}
X
X
X/*
X * NAME
X *	builtin_count - length of a word list
X *
X * SYNOPSIS
X *	int builtin_count(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	Count is a built-in function of cook, described as follows:
X *	This function requires zero or more arguments.
X *
X * RETURNS
X *	A word list containg a single word containing the (decimal)
X *	length of the argument list.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_count(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	string_ty	*s;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	s = str_format("%ld", args->wl_nwords - 1);
X	wl_append(result, s);
X	str_free(s);
X	return 0;
X}
X
X
X/*
X * NAME
X *	builtin_quote - quote the arguments
X *
X * SYNOPSIS
X *	int builtin_quote(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	The quote function is a built-in of cook, described as follows:
X *	This function requires one or more arguments.
X *
X * RETURNS
X *	A word list containing the values of the arguments
X *	surrounded by double quotes.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_quote(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X	static char	*tmp;
X	static size_t	tmp_len;
X	size_t		len;
X	char		*cp1;
X	char		*cp2;
X	char		*cp3;
X	string_ty	*s;
X	static char	special[] = "\bb\ff\nn\rr\tt";
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	for (j = 1; j < args->wl_nwords; ++j)
X	{
X		len = 2;
X		for (cp1 = args->wl_word[j]->str_text; *cp1; ++cp1)
X		{
X			if (*cp1 < ' ' || *cp1 > '~')
X			{
X				if (strchr(special, *cp1))
X					len += 2;
X				else
X					len += 4;
X			}
X			else
X			{
X				if (strchr("\"\\", *cp1))
X					++len;
X				++len;
X			}
X		}
X		if (len > tmp_len)
X		{
X			tmp_len = len;
X			tmp = mem_change_size(tmp, tmp_len);
X		}
X		cp2 = tmp;
X		*cp2++ = '"';
X		for (cp1 = args->wl_word[j]->str_text; *cp1; ++cp1)
X		{
X			if (*cp1 < ' ' || *cp1 > '~')
X			{
X				cp3 = strchr(special, *cp1);
X				if (cp3)
X				{
X					*cp2++ = '\\';
X					*cp2++= cp3[1];
X				}
X				else
X				{
X					*cp2++ = '\\';
X					*cp2++ = '0' + ((*cp1 >> 6) & 3);
X					*cp2++ = '0' + ((*cp1 >> 3) & 7);
X					*cp2++ = '0' + (*cp1 & 7);
X				}
X			}
X			else
X			{
X				if (strchr("\"\\", *cp1))
X					*cp2++ = '\\';
X				*cp2++ = *cp1;
X			}
X		}
X		*cp2 = '"';
X		s = str_n_from_c(tmp, len);
X		wl_append(result, s);
X		str_free(s);
X	}
X	return 0;
X}
X
X
X/*
X * NAME
X *	builtin_sort - sort the arguments
X *
X * SYNOPSIS
X *	int builtin_sort(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	The builtin_sort function is a built-in of cook, described as follows:
X *	sorts the arguments lexicagraphically.
X *	This function requires zero or more arguments.
X *
X * RETURNS
X *	A sorted word list.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xstatic int cmp _((const void *, const void *));
X
Xstatic int
Xcmp(va, vb)
X	const void	*va;
X	const void	*vb;
X{
X	string_ty	*a;
X	string_ty	*b;
X
X	a = *(string_ty **)va;
X	b = *(string_ty **)vb;
X	return strcmp(a->str_text, b->str_text);
X}
X
X
Xint
Xbuiltin_sort(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X	int		start;
X
X	assert(result);
X	assert(args);
X	switch (args->wl_nwords)
X	{
X	case 0:
X		assert(0);
X
X	case 1:
X		return 0;
X
X	case 2:
X		wl_append(result, args->wl_word[1]);
X		return 0;
X	}
X	start = result->wl_nwords;
X	for (j = 1; j < args->wl_nwords; ++j)
X		wl_append(result, args->wl_word[j]);
X	qsort
X	(
X		&result->wl_word[start],
X		args->wl_nwords - 1,
X		sizeof(result->wl_word[0]),
X		cmp
X	);
X	return 0;
X}
END_OF_FILE
if test 11012 -ne `wc -c <'cook/builtin/text.c'`; then
    echo shar: \"'cook/builtin/text.c'\" unpacked with wrong size!
fi
# end of 'cook/builtin/text.c'
fi
if test -f 'cook/parse.y' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/parse.y'\"
else
echo shar: Extracting \"'cook/parse.y'\" \(10064 characters\)
sed "s/^X//" >'cook/parse.y' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to parse cookbooks
X */
X
X%token	CATENATE
X%token	COLON
X%token	DATA
X%token	DATAEND
X%token	ELSE
X%token	EQUALS
X%token	FAIL
X%token	IF
X%token	LBRACE
X%token	LBRAK
X%token	LOOP
X%token	LOOPSTOP
X%token	RBRACE
X%token	RBRAK
X%token	SEMICOLON
X%token	SET
X%token	THEN
X%token	UNSETENV
X%token	WORD
X
X%right	ELSE
X%left	CATENATE
X
X%{
X#include <ac/stddef.h>
X#include <ac/stdlib.h>
X#include <stdio.h>
X
X#include <cook.h>
X#include <error.h>
X#include <expr.h>
X#include <lex.h>
X#include <mem.h>
X#include <option.h>
X#include <parse.h>
X#include <stmt.h>
X#include <symtab.h>
X#include <trace.h>
X#include <word.h>
X
X#ifdef	DEBUG
X#define YYDEBUG 1
X#define printf trace_where(__FILE__, __LINE__), lex_trace
Xextern int yydebug;
X#endif
X
Xstatic	stmt    *looptemp;
Xstatic symtab_ty *flags_symtab;
X
X
X/*
X *  NAME
X *      parse_initialize - start up parser
X *
X *  SYNOPSIS
X *      void parse_initialize(void);
X *
X *  DESCRIPTION
X *      The parse_initialize function is used to add the set clause names to
X *      the symbol table.
X *
X *  RETURNS
X *      void
X *
X *  CAVEAT
X *      Must be called after symbol table is initialized.
X *      Must be called before the parse function is used.
X */
X
Xvoid
Xparse_initialize()
X{
X	typedef struct table_ty table_ty;
X	struct table_ty
X	{
X		char	*t_name;
X		int	t_mask;
X	};
X
X	static table_ty table[] =
X	{
X		{ "clearstat",		RF_CLEARSTAT,		},
X		{ "noclearstat",	RF_CLEARSTAT_OFF,	},
X		{ "default",		RF_DEFAULT,		},
X		{ "nodefault",		RF_DEFAULT_OFF,		},
X		{ "errok",		RF_ERROK,		},
X		{ "noerrok",		RF_ERROK_OFF,		},
X		{ "fingerprint",	RF_FINGERPRINT,		},
X		{ "fingerprinting",	RF_FINGERPRINT,		},
X		{ "nofingerprint",	RF_FINGERPRINT_OFF,	},
X		{ "nofingerprinting",	RF_FINGERPRINT_OFF,	},
X		{ "force",		RF_FORCE,		},
X		{ "forced",		RF_FORCE,		},
X		{ "noforce",		RF_FORCE_OFF,		},
X		{ "noforced",		RF_FORCE_OFF,		},
X		{ "meter",		RF_METER,		},
X		{ "nometer",		RF_METER_OFF,		},
X		{ "precious",		RF_PRECIOUS,		},
X		{ "noprecious",		RF_PRECIOUS_OFF,	},
X		{ "silent",		RF_SILENT,		},
X		{ "nosilent",		RF_SILENT_OFF,		},
X		{ "stripdot",		RF_STRIPDOT,		},
X		{ "nostripdot",		RF_STRIPDOT_OFF,	},
X		{ "update",		RF_UPDATE,		},
X		{ "noupdate",		RF_UPDATE_OFF,		},
X	};
X
X	table_ty *tp;
X
X	trace(("parse_initialize()\n{\n"/*}*/));
X	if (!flags_symtab)
X		flags_symtab = symtab_alloc(SIZEOF(table));
X	for (tp = table; tp < ENDOF(table); ++tp)
X	{
X		string_ty *s;
X
X		s = str_from_c(tp->t_name);
X		symtab_assign(flags_symtab, s, &tp->t_mask);
X		str_free(s);
X	}
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X *  NAME
X *	parse - read and process a cookbook
X *
X *  SYNOPSIS
X *	void parse(string_ty *filename);
X *
X *  DESCRIPTION
X *	Parse reads and processes a cookbook.
X *
X *  CAVEAT
X *	If any errors are found, the user will be told,
X *	and this routine will not return.
X */
X
Xvoid
Xparse(filename)
X	string_ty *filename;
X{
X	int yyparse _((void)); /* forward */
X
X	trace(("parse(filename = %08lX)\n{\n"/*}*/, filename));
X	trace_string(filename->str_text);
X	lex_open(filename);
X#if YYDEBUG
X	yydebug = trace_pretest_;
X#endif
X	yyparse();
X	lex_close();
X	trace((/*{*/"}\n"));
X}
X
X#define yyerror lex_error
X
X%}
X
X%union
X{
X	expr		*lv_expr;
X	stmt		*lv_stmt;
X	elist		lv_elist;
X	string_ty	*lv_word;
X	int		lv_flag;
X	position	lv_position;
X}
X
X%type	<lv_stmt>	statement compound_statement statements
X%type	<lv_stmt>	command simple_command loop use_clause
X%type	<lv_elist>	elist exprs
X%type	<lv_word>	WORD
X%type	<lv_expr>	expr if_clause
X%type	<lv_flag>	set_clause data lbrak mult
X%type	<lv_position>	COLON
X
X%%
X
Xcook
X	: /* empty */
X	| cook statement
X		{
X			if (stmt_eval($2))
X				yyerror("statement failed");
X			stmt_free($2);
X		}
X	| cook error
X		{
X			lex_mode(LM_NORMAL);
X		}
X	;
X
Xstatement
X	: compound_statement
X		{
X			$$ = $1;
X		}
X	| UNSETENV exprs SEMICOLON
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_UNSETENV;
X			$$->s_cmd.c_args = $2;
X		}
X	| elist EQUALS exprs SEMICOLON
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_ASSIGN;
X			$$->s_assign.a_name = $1;
X			$$->s_assign.a_value = $3;
X		}
X	| elist COLON mult exprs set_clause if_clause compound_statement
X			use_clause
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_RECIPE;
X			$$->s_recipe.sr_target = $1;
X			$$->s_recipe.sr_position = $2;
X			$$->s_recipe.sr_multiple = $3;
X			$$->s_recipe.sr_need = $4;
X			el_zero(&$$->s_recipe.sr_need2);
X			$$->s_recipe.sr_flags = $5;
X			$$->s_recipe.sr_precondition = $6;
X			$$->s_recipe.sr_action = $7;
X			$$->s_recipe.sr_use_action = $8;
X		}
X	| elist COLON mult exprs COLON exprs set_clause if_clause
X			compound_statement use_clause
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_RECIPE;
X			$$->s_recipe.sr_target = $1;
X			$$->s_recipe.sr_position = $2;
X			$$->s_recipe.sr_multiple = $3;
X			$$->s_recipe.sr_need = $4;
X			$$->s_recipe.sr_need2 = $6;
X			$$->s_recipe.sr_flags = $7;
X			$$->s_recipe.sr_precondition = $8;
X			$$->s_recipe.sr_action = $9;
X			$$->s_recipe.sr_use_action = $10;
X			str_free($5.pos_name);
X		}
X	| elist COLON mult exprs set_clause if_clause SEMICOLON
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_RECIPE;
X			$$->s_recipe.sr_target = $1;
X			$$->s_recipe.sr_position = $2;
X			$$->s_recipe.sr_need = $4;
X			el_zero(&$$->s_recipe.sr_need2);
X			$$->s_recipe.sr_flags = $5;
X			$$->s_recipe.sr_precondition = $6;
X			$$->s_recipe.sr_action = 0;
X			$$->s_recipe.sr_use_action = 0;
X			$$->s_recipe.sr_multiple = $3;
X		}
X	;
X
Xmult
X	: /* empty */
X		{
X			$$ = 0;
X		}
X	| COLON
X		{
X			$$ = 1;
X			str_free($1.pos_name);
X		}
X	;
X
Xset_clause
X	: /* empty */
X		{
X			$$ = 0;
X		}
X	| SET exprs
X		{
X			int	j;
X			wlist	wl;
X
X			wl_zero(&wl);
X			if (el2wl(&wl, &$2))
X			{
X				/* error message already emitted */
X				wl_free(&wl);
X			}
X			el_free(&$2);
X			$$ = 0;
X			if (!wl.wl_nwords)
X				yyerror("set clause has no flags");
X			for (j = 0; j < wl.wl_nwords; ++j)
X			{
X				int	*data;
X
X				assert(flags_symtab);
X				data = symtab_query(flags_symtab, wl.wl_word[j]);
X				if (data)
X					$$ |= *data;
X				else
X				{
X					yyerror
X					(
X				   "set clause does not understand \"%s\" flag",
X						wl.wl_word[j]->str_text
X					);
X				}
X			}
X			wl_free(&wl);
X
X			if ((($$ & 0xAAAAAAAA) >> 1) & $$)
X				yyerror("may not set both a flag and its negative");
X		}
X	;
X
Xif_clause
X	: /* empty */
X		{
X			$$ = 0;
X		}
X	| IF expr
X		{
X			$$ = $2;
X		}
X	;
X
Xuse_clause
X	: /* empty */
X		{
X			$$ = 0;
X		}
X	| THEN compound_statement
X		{
X			$$ = $2;
X		}
X	;
X
Xstatement
X	: command
X		{
X			$$ = $1;
X		}
X	| IF expr THEN statement
X		%prec ELSE
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_IF;
X			$$->s_if.sif_cond = $2;
X			$$->s_if.sif_true = $4;
X			$$->s_if.sif_false = stmt_alloc();
X			$$->s_if.sif_false->s_op = OP_NOP;
X		}
X	| IF expr THEN statement ELSE statement
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_IF;
X			$$->s_if.sif_cond = $2;
X			$$->s_if.sif_true = $4;
X			$$->s_if.sif_false = $6;
X		}
X	| loop statement
X		{
X			$$ = looptemp;
X			looptemp = $1;
X			$$->s_op = OP_LOOP;
X			$$->s_loop = $2;
X		}
X	| LOOPSTOP SEMICOLON
X		{
X			$$ = stmt_alloc();
X			if (!looptemp)
X			{
X				yyerror("'loopstop' encountered outside a loop");
X				$$->s_op = OP_NOP;
X			}
X			else
X				$$->s_op = OP_LOOPSTOP;
X		}
X	| SET exprs SEMICOLON
X		{
X			int	j;
X			wlist   wl;
X
X			$$ = stmt_alloc();
X			$$->s_op = OP_SET;
X			$$->s_cmd.c_flags = 0;
X
X			wl_zero(&wl);
X			if (el2wl(&wl, &$2))
X			{
X				/* error message already emitted */
X				wl_free(&wl);
X			}
X			el_free(&$2);
X			if (!wl.wl_nwords)
X				yyerror("set statement has no flags");
X			for (j = 0; j < wl.wl_nwords; ++j)
X			{
X				int	*data;
X
X				assert(flags_symtab);
X				data = symtab_query(flags_symtab, wl.wl_word[j]);
X				if (data)
X					$$->s_cmd.c_flags |= *data;
X				else
X				{
X					yyerror
X					(
X				"set statement does not understand \"%s\" flag",
X						wl.wl_word[j]->str_text
X					);
X				}
X			}
X			wl_free(&wl);
X		}
X	| FAIL SEMICOLON
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_FAIL;
X		}
X	| FAIL WORD SEMICOLON
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_FAIL_DK;
X		}
X	| SEMICOLON
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_NOP;
X		}
X	;
X
Xloop
X	: LOOP
X		{
X			$$ = looptemp;
X			looptemp = stmt_alloc();
X		}
X	;
X
Xcompound_statement
X	: LBRACE statements RBRACE
X		{
X			$$ = $2;
X		}
X	;
X
Xstatements
X	: /* empty */
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_COMPOUND;
X		}
X	| statements statement
X		{
X			$$ = $1;
X			sl_append(&$$->s_list, $2);
X			stmt_free($2);
X		}
X	| statements error
X		{
X			$$ = $1;
X		}
X	;
X
Xelist
X	: expr
X		{
X			el_zero(&$$);
X			el_append(&$$, $1);
X			expr_free($1);
X		}
X	| elist expr
X		{
X			$$ = $1;
X			el_append(&$$, $2);
X			expr_free($2);
X		}
X	;
X
Xexprs
X	: /* empty */
X		{
X			el_zero(&$$);
X		}
X	| exprs expr
X		{
X			$$ = $1;
X			el_append(&$$, $2);
X			expr_free($2);
X		}
X	;
X
Xexpr
X	: WORD
X		{
X			$$ = expr_alloc();
X			$$->e_op = OP_WORD;
X			$$->e_word = $1;
X		}
X	| lbrak elist RBRAK
X		{
X			lex_mode($1);
X			$$ = expr_alloc();
X			$$->e_op = OP_FUNC;
X			$$->e_list = $2;
X		}
X	| expr CATENATE expr
X		{
X			$$ = expr_alloc();
X			$$->e_op = OP_CAT;
X			$$->e_left = $1;
X			$$->e_right = $3;
X		}
X	;
X
Xcommand
X	: simple_command
X		{
X			$$ = $1;
X		}
X	| simple_command data expr DATAEND
X		{
X			lex_mode($2);
X			$$ = $1;
X			$$->s_cmd.c_input = $3;
X		}
X	;
X
Xsimple_command
X	: elist set_clause SEMICOLON
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_COMMAND;
X			$$->s_cmd.c_args = $1;
X			$$->s_cmd.c_flags = $2;
X		}
X	;
X
Xdata
X	: DATA
X		{
X			$$ = lex_mode(LM_DATA);
X		}
X	;
X
Xlbrak
X	: LBRAK
X		{
X			$$ = lex_mode(LM_NORMAL);
X		}
X	;
END_OF_FILE
if test 10064 -ne `wc -c <'cook/parse.y'`; then
    echo shar: \"'cook/parse.y'\" unpacked with wrong size!
fi
# end of 'cook/parse.y'
fi
if test -f 'doc/system.so' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/system.so'\"
else
echo shar: Extracting \"'doc/system.so'\" \(10465 characters\)
sed "s/^X//" >'doc/system.so' <<'END_OF_FILE'
X.\"
X.\"	cook - file construction tool
X.\"	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: Reference Manual, Supplied Cookbooks
X.\"	
X.H 1 "Supplied Cookbooks"
XA number of cookbooks are supplied with 
X.BR cook .
XTo make use of one, a preprocessor directive of the form
X.eB
X#include "\f(CIwhichone\fP"
X.eE
Xmust appear the the start of your cookbook.
X.P
X.B Cook
Xdoes not have any "builtin" recipes.
XAll recipes are stored in text files,
Xso they are more easily read, understood, copied, hacked or corrected.
XThe supplied cookbooks live in the
X.I /usr/local/lib/cook
Xdirectory.
X.P
XYou may supply your own "system" recipes,
Xby placing cookbooks into a directory called
X.IR $HOME/.cook
Xor using the 
X.B -Include
Xcommand line option,
Xpossibly in your 
X.I $COOK
Xenvironment variable.
X.H 2 "as"
XThis cookbook defines how to use the assembler.
X.H 3 "recipes"
X.VL 1i
X.LI "%.o: %.s"
XConstruct object files from assembler source files.
X.LE
X.H 3 "variables"
X.VL 1i
X.LI as
XThe assembler command.
XNot altered if already defined.
X.LI as_flags
XOptions to pass the assembler command.
XNot altered if already defined.
XThe default is empty.
X.LI as_src
XAssembler source files in the current directory.
X.LI dot_src
XSource files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LI dot_obj
XObject files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LI dot_clean
XFiles which may be removed from the current directory in a clean target.
X.LE
X.H 2 "c"
XThis cookbook describes how to work with C files.
XInclude file dependencies are automatically determined.
X.H 3 "recipes"
X.VL 1i
X.LI "%.o: %.c"
XConstruct object files form C source files,
Xwith automatic include file dependency detection.
X.LI "%.ln: %.c"
XConstruct lint object files from C source files,
Xwith automatic include file dependency detection.
X.LE
X.H 3 "variables"
X.VL 1i
X.LI c_incl
XThe C include dependency sniffer command.
XNot altered if already defined.
X.LI cc
XThe C compiler command.
XNot altered if already defined.
X.LI lint
XThe lint command.
XNot altered if already defined.
X.LI cc_flags
XOptions to pass to the C compiler command.
XNot altered if already defined.
XThe default is "-O".
X.LI cc_include_flags
XOptions passed to the C compiler and c_incl
Xcontrolling include file searching.
XNot altered if already defined.
XThe default is empty.
X.LI cc_link_flags
XOptions passed to the C compiler when linking,
Xthese are typically library search paths and libraries.
XNot altered if already defined.
XThe default is empty.
X.LI cc_src
XC source files in the current directory.
X.LI dot_src
XSource files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LI dot_obj
XObject files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LI dot_clean
XFiles which may be removed from the current directory in a clean target.
X.LI dot_lint_obj
XLint object files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LE
X.H 2 "home"
XThis cookbook defined where certain directories are,
Xand some common uses of those directories,
Xrelative to $HOME.
X.H 3 "variables"
X.VL 1i
X.LI home
XThe current users' home directory.
X.LI bin
XThe directory to place program binaries into.
X.LI include
XThe directory to place include files into.
X.LI lib
XThe directory to place libraries into.
X.LI cc_include_flags
XThe [include] directory is appended to the search options.
X.LI cc_link_flags
XThe [lib] directory is appended to the search options.
X.LE
X.H 2 "lex"
XThis cookbook describes how to work with lex files.
X.H 3 "recipes"
X.VL 1i
X.LI "%.l: %.c"
XConstruct C source files from lex source files.
X.LE
X.H 3 "variables"
X.VL 1i
X.LI lex
XThe lex command.
XNot altered if already defined.
X.LI lex_flags
XOptions to pass to the lex command.
XNot altered if already defined.
XThe default is empty.
X.LI lex_src
XLex source files in the current directory.
X.LI dot_src
XSource files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LI dot_obj
XObject files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LI dot_clean
XFiles which may be removed from the current directory in a clean target.
X.LI dot_lint_obj
XLint object files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LE
X.H 2 "library"
XThis cookbook defines how to construct a library.
X.P
XIf an include file (or files) are defined for this library,
Xyou will have to append them to [install] in your
X.I Howto.cook
Xfile.
X.H 3 "variables"
X.VL 1i
X.LI all
Xtargets of the all recipe
X.LI install
Xtargets of the install recipe
X.LI me
XThe name of the library to be constructed.
XDefaults to the last component of the pathname of the current directory.
X.LI ar
XThe archive command.
X.LI install
Xtargets of the install command.
XOnly defined if the [lib] variable is defined.
X.LE
X.H 3 "recipes"
X.VL 1i
X.LI all
Xconstruct the targets defined in [all].
X.LI clean
Xremove the files named in [dot_clean].
X.LI clobber
Xremove the files name in [dot_clean] and [all].
X.LI install
XConstruct the files named in [install].
XOnly defined if the [lib] variable is defined.
X.LI uninstall
XRemove the files named in [install].
XOnly defined if the [lib] variable is defined.
X.LE
X.H 2 "print"
XThis cookbook is used to print files.
XIt will almost certainly need to be changed for every site.
X.H 3 "recipes"
X.VL 1i
X.LI "%.lw: %.ps"
XPrint a PostScript file.
X.LI "%.lp: %"
XPrint a text file.
X.LE
X.H 3 "variables"
X.VL 1i
X.LI lp
XThe print command.
XNot altered if already defined.
X.LI lp_flags
XOptions passed to the print command.
XNot altered if already defined.
XDefaults to empty.
X.LE
X.H 2 "program"
XThis cookbook defines how to construct a program.
X.P
XIf you program uses any libraries,
Xyou will have to append them to [cc_link_flags] in your
X.I Howto.cook
Xfile.
X.H 3 "variables"
X.VL 1i
X.LI all
XTargets of the all recipe.
X.LI install
Xtargets of the install recipe
X.LI me
XThe name of the program to be constructed.
XDefaults to the last component of the pathname of the current directory.
X.LI install
Xtargets of the install command.
X.LE
X.H 3 "recipes"
X.VL 1i 
X.LI all
XConstruct the targets named in [all].
X.LI clean
XRemove the files named in [dot_clean].
X.LI clobber
XRemove the files named in [dot_clean] and [all].
X.LI install
XConstruct the files named in [install].
XOnly defined if the [lib] variable is defined.
X.LI uninstall
XRemove the files named in [install].
XOnly defined if the [lib] variable is defined.
X.LE
X.H 2 "rcs"
XThis cookbook is used to extract files from RCS.
X.H 3 "recipes"
X.VL 1i
X.LI "%: RCS/%,v"
XExtract files from RCS.
X.LI "%: %,v"
XExtract files from RCS.
X.LE
X.H 3 "variables"
X.VL 1i
X.LI co
XThe RCS checkout command.
X.LI co_flags
XFlags for the co command, default to empty.
X.LE
X.H 2 "sccs"
XThis cookbook is used to extract files from SCCS.
X.H 3 "recipes"
X.VL 1i
X.LI "%: SCCS/s.%"
XExtract files from SCCS.
X.LI "%: s.%"
XExtract files from SCCS.
X.LE
X.H 3 "variables"
X.VL 1i
X.LI get
XThe SCCS get command.
X.LI get_flags
XFlags for the get command, default to empty.
X.LE
X.H 2 "text"
XThis cookbook is used to process text documents.
X.P
XInclude file dependencies are automatically detected.
XThe requirements for various preprocessors are automatically detected
X(eg eqn, tbl, pic, graf).
X.H 3 "recipes"
X.VL 1i
X.LI "%.ps: %.t"
XPostScript for generic *roff source.
X.LI "%: %.t"
XStraight text from *roff source.
X.LE
X.H 3 "variables"
X.VL 1i 
X.LI text_incl
XThe text_incl command (finds include dependencies).
XNot altered if already set.
X.LI text_roff
XThe text_roff command (finds preprocessor requirements).
XNot altered if already set.
X.LI roff_flags
XArguments passed to text_roff, and indirectly to the *roff program.
XNot altered if already set.
XDefaults to empty.
X.LE
X.H 2 "usr"
XThis cookbook defined where certain directories are,
Xrelative to /usr.
X.H 3 "variables"
X.VL 1i
X.LI bin
XThe directory to place program binaries into.
X.LI include
XThe directory to place include files into.
X.LI lib
XThe directory to place libraries into.
X.LE
X.H 2 "usr.local"
XThis cookbook defined where certain directories are,
Xand some common uses of those directories,
Xelative to /usr/local.
X .H 3 "variables"
X.VL 1i
X.LI bin
XThe directory to place program binaries into.
X.LI include
XThe directory to place include files into.
X.LI lib
XThe directory to place libraries into.
X.LI cc_include_flags
XThe [include] directory is added to the search options.
X.LI cc_link_flags
XThe [lib] directory is added to the search options.
X.LE
X.H 2 "yacc"
XThis cookbook describes how to use yacc.
X.P
XYou will have to add "-d" to the [yacc_flags] variable
Xif you want %.h files generated.
X.P
XIf a
X.I y.output
Xfile is constructed,
Xit will be moved to
X.IR %.list .
X.H 3 "recipes"
X.VL 1i
X.LI "%.c %.h: %.y"
XConstruct C source and header files from yacc source files.
XApplied if -d in [yacc_flags].
X.LI "%.c: %.y"
XConstruct C source files from yacc source files.
XApplied if -d not in [yacc_flags].
X.LE
X.H 3 "variables"
X.VL 1i
X.LI yacc_src
XYacc source files in the current directory.
X.LI dot_src
XSource files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LI dot_obj
XObject files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LI dot_clean
XFiles which may be removed from the current directory in a clean target.
X.LI dot_lint_obj
XLint object files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LE
X.H 2 "yacc_many"
XThis cookbook describes how to use yacc.
XThe difference with the "yacc" cookbook is that this cookbook
Xallows you to have more that one yacc generated parser in the same
Xprogram, by using the classic sed(1) hack of the output.
END_OF_FILE
if test 10465 -ne `wc -c <'doc/system.so'`; then
    echo shar: \"'doc/system.so'\" unpacked with wrong size!
fi
# end of 'doc/system.so'
fi
if test -f 'make2cook/lex.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'make2cook/lex.c'\"
else
echo shar: Extracting \"'make2cook/lex.c'\" \(11025 characters\)
sed "s/^X//" >'make2cook/lex.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to perform lexical analysis on Makefiles
X */
X
X#include <ctype.h>
X#include <stdio.h>
X#include <ac/string.h>
X
X#include <blob.h>
X#include <error.h>
X#include <lex.h>
X#include <mem.h>
X#include <s-v-arg.h>
X#include <stmt.h>
X#include <symtab.h>
X#include <trace.h>
X#include <gram.gen.h> /* must be last */
X
Xstatic string_ty *file_name;
Xstatic FILE	*input;
Xstatic long	line_number;
Xstatic int	error_count;
Xstatic int	bol;
Xstatic int	first;
Xstatic int	colon_special;
Xstatic int	within_define;
Xstatic long	sa_data_length;
Xstatic long	sa_data_max;
Xstatic char	*sa_data;
X
X
Xstatic void notify _((void));
X
Xstatic void
Xnotify()
X{
X	if (!file_name)
X		return;
X	if (++error_count >= 20)
X		fatal("%S: too many errors, bye!", file_name);
X}
X
X
Xvoid
Xlex_open(s)
X	char		*s;
X{
X	trace(("lex_open()\n{\n"/*}*/));
X	assert(!input);
X	blob_error_notify(notify);
X	if (s)
X	{
X		input = fopen(s, "r");
X		if (!input)
X			nfatal("%s", s);
X		file_name = str_from_c(s);
X	}
X	else
X	{
X		file_name = str_from_c("standard input");
X		input = stdin;
X	}
X	line_number = 1;
X	bol = 1;
X	first = 1;
X	colon_special = 1;
X	error_count = 0;
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xlex_close()
X{
X	trace(("lex_close()\n{\n"/*}*/));
X	assert(input);
X	if (error_count)
X	{
X		fatal
X		(
X			"%S: found %d fatal error%s",
X			file_name,
X			error_count,
X			(error_count == 1 ? "" : "s")
X		);
X	}
X	if (input != stdin)
X		fclose(input);
X	input = 0;
X	str_free(file_name);
X	file_name = 0;
X	line_number = 0;
X	bol = 0;
X	first = 0;
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xgram_error(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	va_list		ap;
X	string_ty	*buffer;
X	int		len;
X
X	sva_init(ap, s);
X	buffer = str_vformat(s, ap);
X	va_end(ap);
X	len = buffer->str_length;
X	while (len > 0 && isspace(buffer->str_text[len - 1]))
X		--len;
X	error("%S: %ld: %.*S", file_name, line_number, len, buffer);
X	str_free(buffer);
X	notify();
X}
X
X
Xstatic int byte _((void));
X
Xstatic int
Xbyte()
X{
X	int		c;
X
X	assert(input);
X	c = getc(input);
X	switch (c)
X	{
X	case EOF:
X		if (ferror(input))
X			nfatal("read %s", file_name->str_text);
X		bol = 1;
X		break;
X	
X	case '\n':
X		++line_number;
X		bol = 1;
X		first = 1;
X		colon_special = 1;
X		break;
X
X	case ' ':
X	case '\t':
X	case '\f':
X#if __STDC__ >= 1
X	case '\v':
X#endif
X		bol = 0;
X		break;
X
X	default:
X		bol = 0;
X		first = 0;
X		break;
X	}
X	return c;
X}
X
X
Xstatic void byte_undo _((int));
X
Xstatic void
Xbyte_undo(c)
X	int		c;
X{
X	switch (c)
X	{
X	case EOF:
X		break;
X
X	case '\n':
X		--line_number;
X		ungetc(c, input);
X		break;
X	
X	default:
X		ungetc(c, input);
X		break;
X	}
X}
X
X
X/*
X * NAME
X *	lex_trace - debug output
X *
X * SYNOPSIS
X *	void lex_trace(char *s, ...);
X *
X * DESCRIPTION
X *	The lex_trace function is used to format and output yyparse's trace
X *	output.  The printf's in yyparse are #define'd into lex_trace calls.
X *	Unfortunately yacc's designer did not take trace output redirection
X *	into account, to this function is a little tedious.
X *
X * RETURNS
X *	void
X *
X * CAVEAT
X *	This function is only available when the DEBUG symbol is #define'd.
X */
X
X#ifdef DEBUG
X
Xvoid
Xgram_trace(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	va_list		ap;
X	string_ty	*buffer;
X	char		*cp;
X	static char	line[1024];
X
X	sva_init(ap, s);
X	buffer = str_vformat(s, ap);
X	va_end(ap);
X	strcat(line, buffer->str_text);
X	str_free(buffer);
X	cp = line + strlen(line) - 1;
X	if (cp > line && *cp == '\n')
X	{
X		*cp = 0;
X		trace_printf
X		(
X			"%s: %ld: %s\n",
X			file_name->str_text,
X			line_number,
X			line
X		);
X		line[0] = 0;
X	}
X}
X
X
Xvoid
Xgram_trace2(garbage, s sva_last)
X	void		*garbage;
X	char		*s;
X	sva_last_decl
X{
X	va_list		ap;
X	string_ty	*buffer;
X	char		*cp;
X	static char	line[1024];
X
X	sva_init(ap, s);
X	buffer = str_vformat(s, ap);
X	va_end(ap);
X	strcat(line, buffer->str_text);
X	str_free(buffer);
X	cp = line + strlen(line) - 1;
X	if (cp > line && *cp == '\n')
X	{
X		*cp = 0;
X		error("%S: %ld: %s", file_name, line_number, line);
X		line[0] = 0;
X	}
X}
X
X#endif
X
X
Xstatic int reserved _((string_ty *s));
X
Xstatic int
Xreserved(s)
X	string_ty	*s;
X{
X	typedef struct table_ty table_ty;
X	struct table_ty
X	{
X		char	*name;
X		int	token;
X	};
X
X	static table_ty table[] =
X	{
X		{ "override",	OVERRIDE,	},
X		{ "include",	INCLUDE2,	},
X		{ "-include",	INCLUDE3,	},
X		{ ".include",	INCLUDE,	},
X		{ "vpath",	VPATH,		},
X		{ "VPATH",	VPATH2,		},
X		{ "ifdef",	IF,		},
X		{ "ifndef",	IF,		},
X		{ "ifeq",	IF,		},
X		{ "ifneq",	IF,		},
X		{ "else",	ELSE,		},
X		{ "endif",	ENDIF,		},
X		{ "endef",	ENDDEF,		},
X		{ "define",	DEFINE,		},
X		{ "export",	EXPORT,		},
X		{ "unexport",	UNEXPORT,	},
X	};
X
X	static symtab_ty *symtab;
X	int		*data;
X	string_ty	*name;
X	char		*cp;
X
X	if (!symtab)
X	{
X		table_ty	*tp;
X
X		symtab = symtab_alloc(SIZEOF(table));
X		for (tp = table; tp < ENDOF(table); ++tp)
X		{
X			name = str_from_c(tp->name);
X			symtab_assign(symtab, name, &tp->token);
X			str_free(name);
X		}
X	}
X
X	cp = strchr(s->str_text, '('/*)*/);
X	if (cp)
X	{
X		name = str_n_from_c(s->str_text, cp - s->str_text);
X		data = symtab_query(symtab, name);
X		str_free(name);
X	}
X	else
X		data = symtab_query(symtab, s);
X	if (data)
X		return *data;
X	return 0;
X}
X
X
Xstatic void sa_open _((void));
X
Xstatic void
Xsa_open()
X{
X	sa_data_length = 0;
X}
X
X
Xstatic string_ty *sa_close _((void));
X
Xstatic string_ty *
Xsa_close()
X{
X	string_ty	*s;
X
X	s = str_n_from_c(sa_data, sa_data_length);
X	sa_data_length = 0;
X	return s;
X}
X
X
Xstatic void sa_char _((int));
X
Xstatic void
Xsa_char(c)
X	int		c;
X{
X	if (sa_data_length >= sa_data_max)
X	{
X		sa_data_max = sa_data_max * 2 + 16;
X		sa_data = mem_change_size(sa_data, sa_data_max);
X	}
X	sa_data[sa_data_length++] = c;
X}
X
X
Xint
Xgram_lex()
X{
X	static char	*paren;
X	static long	paren_max;
X	long		paren_depth;
X	int		c;
X	long		linum;
X	int		bol_was;
X	int		first_was;
X	string_ty	*s;
X	int		token;
X
X	trace(("gram_lex()\n{\n"/*}*/));
X	for (;;)
X	{
X		linum = line_number;
X		bol_was = bol;
X		first_was = first;
X		c = byte();
X		switch (c)
X		{
X		case EOF:
X			token = 0;
X			goto done;
X
X		case '\t':
X			if (!bol_was || within_define)
X				continue;
X			sa_open();
X			for (;;)
X			{
X				c = byte();
X				switch (c)
X				{
X				case EOF:
X				case '\n':
X					break;
X
X				case '\\':
X					c = byte();
X					if (c == EOF)
X						break;
X					if (c == '\n')
X						sa_char(' ');
X					else
X					{
X						sa_char('\\');
X						sa_char(c);
X					}
X					continue;
X
X				case ' ':
X				case '\t':
X				case '\f':
X#if __STDC__ >= 1
X				case '\v':
X#endif
X					if (sa_data_length)
X						sa_char(c);
X					continue;
X
X				default:
X					sa_char(c);
X					continue;
X				}
X				break;
X			}
X			gram_lval.lv_line =
X				blob_alloc(sa_close(), file_name, linum);
X			token = COMMAND;
X			goto done;
X
X		case '#':
X			sa_open();
X			for (;;)
X			{
X				c = byte();
X				switch (c)
X				{
X				case EOF:
X				case '\n':
X					break;
X
X				case '#':
X					if (sa_data_length)
X						sa_char(c);
X					continue;
X
X				case ' ':
X				case '\t':
X				case '\f':
X#if __STDC__ >= 1
X				case '\v':
X#endif
X					if (sa_data_length)
X						sa_char(' ');
X					continue;
X
X				default:
X					sa_char(c);
X					continue;
X				}
X				break;
X			}
X			gram_lval.lv_line =
X				blob_alloc(sa_close(), file_name, linum);
X			if (!first_was)
X			{
X				blob_free(gram_lval.lv_line);
X				byte_undo('\n');
X				continue;
X			}
X			token = COMMENT;
X			goto done;
X
X		case ' ':
X		case '\f':
X#if __STDC__ >= 1
X		case '\v':
X#endif
X			break;
X
X		case '\n':
X			token = EOLN;
X			goto done;
X
X		case ';':
X			byte_undo('\t');
X			bol = 1;
X			first = 1;
X			colon_special = 1;
X			token = EOLN;
X			goto done;
X
X		case ':':
X			if (!colon_special)
X				goto normal;
X			c = byte();
X			if (c == ':')
X			{
X				token = COLON_COLON;
X				goto done;
X			}
X			if (c == '=')
X			{
X				token = COLON_EQUALS;
X				colon_special = 0;
X				goto done;
X			}
X			byte_undo(c);
X			token = COLON;
X			goto done;
X
X		case '=':
X			token = EQUALS;
X			colon_special = 0;
X			goto done;
X
X		case '\\':
X			c = byte();
X			if (c == '\n')
X				continue;
X			byte_undo(c);
X			c = '\\';
X			goto normal;
X
X		case '+':
X			c = byte();
X			if (c == '=')
X			{
X				token = PLUS_EQUALS;
X				colon_special = 0;
X				goto done;
X			}
X			byte_undo(c);
X			c = '+';
X			/* fall through... */
X		
X		default:
X			normal:
X			sa_open();
X			paren_depth = 0;
X			for (;;)
X			{
X				switch (c)
X				{
X				case '\\':
X					c = byte();
X					if (c == EOF)
X						c = '\\';
X					else if (c == '\n')
X						c = ' ';
X					sa_char(c);
X					c = byte();
X					continue;
X
X				case EOF:
X				case '\n':
X					break;
X
X				case ' ':
X				case '\t':
X				case '\f':
X#if __STDC__ >= 1
X				case '\v':
X#endif
X				case ';':
X					if (!within_define && !paren_depth)
X						break;
X					sa_char(c);
X					c = byte();
X					continue;
X
X				case ':':
X				case '=':
X					if
X					(
X						colon_special
X					&&
X						!within_define
X					&&
X						!paren_depth
X					)
X						break;
X					sa_char(c);
X					c = byte();
X					continue;
X
X				default:
X					sa_char(c);
X					c = byte();
X					continue;
X
X				case '('/*)*/:
X					sa_char(c);
X					if (paren_depth >= paren_max)
X					{
X						paren_max = paren_max * 2 + 16;
X						paren = mem_change_size(paren, paren_max);
X					}
X					paren[paren_depth++] = /*(*/')';
X					c = byte();
X					continue;
X				
X				case /*(*/')':
X				case /*{*/'}':
X					sa_char(c);
X					if
X					(
X						paren_depth
X					&&
X						c == paren[paren_depth - 1]
X					)
X						--paren_depth;
X					c = byte();
X					continue;
X
X				case '{'/*}*/:
X					sa_char(c);
X					if (paren_depth >= paren_max)
X					{
X						paren_max = paren_max * 2 + 16;
X						paren = mem_change_size(paren, paren_max);
X					}
X					paren[paren_depth++] = /*{*/'}';
X					c = byte();
X					continue;
X				}
X				break;
X			}
X			byte_undo(c);
X			s = sa_close();
X			if (first_was && (token = reserved(s)) != 0)
X			{
X				switch (token)
X				{
X				case DEFINE:
X					str_free(s);
X					++within_define;
X					break;
X				
X				case ENDDEF:
X					str_free(s);
X					--within_define;
X					break;
X
X				case IF:
X					gram_lval.lv_line =
X						blob_alloc(s, file_name, linum);
X					break;
X				
X				case VPATH:
X					colon_special = 0;
X					break;
X
X				default:
X					str_free(s);
X					break;
X				}
X				goto done;
X			}
X			gram_lval.lv_line = blob_alloc(s, file_name, linum);
X			token = WORD;
X			goto done;
X		}
X	}
X
X	/*
X	 * here for all exits
X	 */
X	done:
X#ifdef DEBUG
X	if (token == WORD || token == COMMENT || token == COMMAND)
X		trace(("text = \"%s\";\n", gram_lval.lv_line->text->str_text));
X#endif
X	trace(("return %d;\n", token));
X	trace((/*{*/"}\n"));
X	return token;
X}
END_OF_FILE
if test 11025 -ne `wc -c <'make2cook/lex.c'`; then
    echo shar: \"'make2cook/lex.c'\" unpacked with wrong size!
fi
# end of 'make2cook/lex.c'
fi
if test -f 'man1/cook.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man1/cook.1'\"
else
echo shar: Extracting \"'man1/cook.1'\" \(9531 characters\)
sed "s/^X//" >'man1/cook.1' <<'END_OF_FILE'
X'\" t
X.\"	cook - file construction tool
X.\"	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: manual entry for the cook command
X.\" 
X.TH COOK 1
X.so z_name.so
X.SH NAME
X\*(n) \- a file construction tool
X.SH SYNOPSIS
X.B \*(n)
X[
X.IR option ...
X][
X.IR filename ...
X]
X.br
X.B \*(n)
X.B -Help
X.br
X.B \*(n)
X.B -VERSion
X.SH DESCRIPTION
XThe
X.I \*(n)
Xprogram is a tool for constructing files.
XIt is given a set of files to create,
Xand instructions detailing how to construct them.
XIn any non-trivial program
Xthere will be prerequisites to performing
Xthe actions necessary to creating any file,
Xsuch as extraction from a source-control system.
XThe
X.I \*(n)
Xprogram provides a mechanism to define these.
X.PP
XWhen a program is being developed or maintained,
Xthe programmer will typically change one file of several
Xwhich comprise the program.
XThe
X.I \*(n)
Xprogram examines the last-modified times of the files to see when
Xthe prerequisites of a file have changed,
Ximplying that the file
Xneeds to be recreated as it is logically out of date.
X.PP
XThe
X.I \*(n)
Xprogram also provides a facility for implicit recipes,
Xallowing users to specify how to form a file with a given suffix from
Xa file with a different suffix.
XFor example,
Xto create
X.IB filename .o
Xfrom
X.IB filename .c
X.PP
XOptions and filenames may be arbitrarily mixed on the command line;
Xno processing is done until all options and filenames
Xon the command line have been scanned.
X.PP
XThe
X.I \*(n)
Xprogram will attempt to create the named files from the recipes
Xgiven to it.
XThe recipes are contained in a file called
X.I Howto.cook
Xin the currect directory.
XThis file may,
Xin turn,
Xinclude other files containing additional recipes.
X.PP
XIf no
X.IR filename s
Xare given on the command line
Xthe targets of the first recipe defined are cooked.
X.br
X.ne 1i
X.SH OPTIONS
XThe valid options for
X.I \*(n)
Xare listed below.
XAny other options
X(words on the command line beginning with `\fB-\fP')
Xwill cause a diagnostic message to be issued.
X.TP 8n
X.B -Action
X.br
XExecute the commands given in the recipes.
XThis is the default.
X.TP 8n
X.B -No_Action
X.br
XDo not execute the commands given in the recipes.
X.TP 8n
X\fB-Book\fP \fIfilename\fP
X.br
XTells \*(n) to used the named cookbook,
Xrather than the default ``Howto.cook'' file.
X.TP 8n
X.B -Continue
X.br
XIf cooking a target should fail,
Xcontinue with other recipes for which the
Xfailed target is not an ingredient,
Xdirectly or indirectly.
X.TP 8n
X.B -No_Continue
X.br
XIf cooking a target should fail,
X.I \*(n)
Xwill exit.
XThis is the default.
X.TP 8n
X.B -Errok
X.br
XWhen a command is executed,
Xthe exit code will be ignored.
X.TP 8n
X.B -No_Errok
X.br
XWhen a command is executed,
Xif the exit code is positive
Xit will be deemed to fail,
Xand thus the recipe containing it to have failed.
XThis is the default.
X.TP 8n
X.B -FingerPrint
X.br
XWhen
X.I cook
Xexamines a file to determine if it has changed,
Xit uses the last-modified time information available in the file system.
XThere are times when this is altered,
Xbut the file contents do not actually change.
XThe fingerprinting facility examines the file contents
Xwhen it appears to have changed,
Xand compares the old fingerprint against the present file contents.
X(See
X.IR cookfp (1)
Xfor a description of the fingerprinting algorithm.)
XIf the fingerprint did not change,
Xthe last-modified time in the file system is ignored.
XNote that this has implications if you
Xare in the habit of using the
X.IR touch (1)
Xcommand \- 
X.I cook
Xwill do nothing until you actually change the file.
X.TP 8n
X.B -No_FingerPrint
X.br
XDo not use fingerprints
Xto supplement the last-modified time file information.
XThis is the default.
X.TP 8n
X.B -Force
X.br
XAlways perform the actions of recipes,
Xirrespective of the last-modified times of any of the ingredients.
XThis option is useful if something beyond the scope of the cookbook
Xhas been modified;
Xfor example, a bug fix in a compiler.
X.TP 8n
X.B -No_Force
X.br
XPerform the actions of the recipes
Xif any of the ingredients are logically out of date.
XThis is the default.
X.TP 8n
X.B -Help
X.br
XProvide information about how to execute
X.I \*(n)
Xon 
X.IR stdout ,
Xand perform no other function.
X.TP 8n
X.BI -Include " filename"
X.br
XSearch the named directory before the standard places for
Xincluded cookbooks.
XEach directory so named will be scanned in the order given.
XThe standard places are
X.I $HOME/.cook
Xthen
X.IR /usr/local/lib/cook .
X.TP 8n
X.B -List
X.br
XCauses
X.I \*(n)
Xto automatically redirect the
X.I stdout
Xand
X.I stderr
Xof the session.
XOutput will continue to come to the terminal,
Xunless 
X.I \*(n)
Xis executing in the background.
XThe name of the file will be the name of the cookbook with any suffix
Xremoved and "\f(CW.list\fP" appended;
Xthis will usually be
X.IR Howto.list .
XThis is the default.
X.TP 8n
X.BI -List " filename"
X.br
XCauses 
X.I \*(n)
Xto automatically redirect the
X.I stdout 
Xand
X.I stderr
Xof the session into the named file.
XOutput will continue to come to the terminal,
Xunless 
X.I \*(n)
Xis executing in the background.
X.TP 8n
X.B -No_List
X.br
XNo automatic redirection of the output of the session will be made.
X.TP 8n
X.BI -No_List " filename"
X.br
XNo automatic redirection of the output of the session will be made,
Xhowever subsequent
X.B -List
Xoptions will default to listing to the named file.
X.TP 8n
X.B -Meter
X.br
XAfter each command is executed,
Xprint a summary of the command's CPU usage.
X.TP 8n
X.B -No_Meter
X.br
XDo not print a CPU usage summary after each command.
XThis is the default.
X.TP 8n
X.B -Precious
X.br
XWhen commands in the body of a recipe fail,
Xdo not delete the targets of the recipe.
X.TP 8n
X.B -No_Precious
X.br
XWhen commands in the body of a recipe fail,
Xdelete the targets of the recipe.
XThis is the default.
X.TP 8n
X.B -Silent
X.br
XDo not echo commands before they are executed.
X.TP 8n
X.B -No_Silent
X.br
XEcho commands before they are executed.
XThis is the default.
X.TP 8n
X.B -STar
X.br
XEmit an asterisk for each file found to be up-to-date,
Xor once a second, whichever is slowest.
X.TP 8n
X.B -No_STar
X.br
XDo not emit progress asterisks.
XThis is the default.
X.TP 8n
X.B -Strip_Dot
X.br
XRemove leading "./" from filenames before 
Xattempting to cook them;
Xapplies to all filenames and all recipes.
XThis is the default.
X.TP 8n
X.B -No_Strip_Dot
X.br
XLeave leading "./" on filenames while cooking.
X.TP 8n
X.B -Touch
X.br
XUpdate the last-modified times of the
Xtarget files,
Xrather than execute the actions bound to recipes.
XThis can be useful if you have made a modification to a file that
Xyou know will make a
Xsystem of files logically out of date,
Xbut has no significance;
Xfor example,
Xadding a comment to a widely used include file.
X.TP 8n
X.B -No_Touch
X.br
XExecute the actions bound to recipes,
Xrather than update the last-modified times of the target files.
XThis is the default.
X.TP 8n
X.B -TErminal
X.br
XWhen listing,
Xalso send the output stream to the terminal.
XThis is the default.
X.TP 8n
X.B -No_TErminal
X.br
XWhen listing,
Xdo not send the output to the terminal.
X.TP 8n
X.B -Update
X.br
XThis option causes
X.B cook
Xto check the last-modified time of the targets of recipes,
Xand updates them if necessary,
Xto make sure they are consistent with (younger than) the last-modified
Xtimes of the ingredients.
XThis results in more system calls,
Xand can slow things down on some systems.
X.TP 8n
X.B -No_Update
X.br
XDo not update the file last-modified times after performing
Xthe body of a recipe.
XThis is the default.
X.TP 8n
X.IB name = value
X.br
XAssign the
X.I value
Xto the named variable.
XThe value may contain spaces
Xif you can convince the shell to pass them through.
X.TP 8n
X.B -TRace
X.br
XTwo options are provided for
Xtracing the inferences
X.B \*(n) 
Xmakes when attempting to cook a target.
XThe
X.B -TRace
Xoption will cause
X.I \*(n)
Xwill emit copious amounts of information
Xabout the inferences it is making when cooking targets.
XThis option may be used when you think 
X.B \*(n)
Xis acting strangely,
Xor are just curious.
X.TP 8n
X.B -No_TRace
X.br
XThis option may be used to cause
X.I \*(n)
Xwill not emit information
Xabout the inferences it is making when cooking targets.
XThis is the default.
X.so o__rules.so
X.so z_exit.so
X.SH FILES
XThe following files are used by \fBcook\fP:
X.TP 8n
X\fIHowto.cook\fP
XThis file contains instructions to
X.I cook
Xfor how to construct files.
X.TP 8n
X\fI/usr/local/lib/cook\fP
XThis directory contains "system" cookbooks
Xfor various tools and activities.
X.TP 8n
X\fI.cook.fp\fP
XThis text file is used to remember fingerprints between invokations.
X.SH ENVIRONMENT VARIABLES
XThe following environment variables are used by \fBcook\fP:
X.TP
XCOOK
XMay be set to contain command-line options,
Xchanging the default behaviour of
X.IR cook .
XMay be overridden by the command line.
X.TP 8n
XPAGER
XUse to paginate the output of the
X.B -Help
Xand
X.B -VERSion
Xoptions.
XDefaults to
X.IR more (1)
Xif not set.
X.so copyright.so
END_OF_FILE
if test 9531 -ne `wc -c <'man1/cook.1'`; then
    echo shar: \"'man1/cook.1'\" unpacked with wrong size!
fi
# end of 'man1/cook.1'
fi
echo shar: End of archive 10 \(of 19\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 19 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
