Newsgroups: comp.sources.unix
From: pmiller@bmr.gov.au (Peter Miller)
Subject: v28i099: cook - a file construction tool, V1.6, Part06/19
References: <1.775008949.28543@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: pmiller@bmr.gov.au (Peter Miller)
Posting-Number: Volume 28, Issue 99
Archive-Name: cook-1.6/part06

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 19)."
# Contents:  aux/Makefi.file.sh aux/configure.in aux/new.1.5.so
#   common/config.h.in common/fp/cksum.c common/mem.c
#   cook/builtin/collect.c cook/builtin/execute.c cook/cook.h
#   cook/env.c cook/option.h cook/stmt.h doc/function/opsys.so
#   doc/match.so lib/c lib/library lib/yacc_many make2cook/emit.c
#   make2cook/main.c make2cook/stmt.c make2cook/stmt/comment.c
#   make2cook/stmt/if.c make2cook/stmt/include.c roffpp/main.c
#   test/00/t0038a.sh test/00/t0048a.sh test/00/t0050a.sh
#   test/00/t0065a.sh test/00/t0070a.sh test/00/t0071a.sh
#   test/00/t0077a.sh txt2c/main.c
# Wrapped by vixie@gw.home.vix.com on Sat Jul 23 17:11:22 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'aux/Makefi.file.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aux/Makefi.file.sh'\"
else
echo shar: Extracting \"'aux/Makefi.file.sh'\" \(3252 characters\)
sed "s/^X//" >'aux/Makefi.file.sh' <<'END_OF_FILE'
X#! /bin/sh
X#
X#	cook - file construction tool
X#	Copyright (C) 1990, 1991, 1992, 1993, 1994 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: shell script to generate Makefile fragment for each source file
X#
Xcase $# in
X2)
X	;;
X*)
X	echo "usage: $0 filename resolved-filename" 1>&2
X	exit 1
X	;;
Xesac
Xfile="$1"
Xrfn="$2"
X
Xcase $file in
X
X*/*.y)
X	root=`basename $file .y`
X	stem=`echo $file | sed 's/\.y$//'`
X	dir=`echo $file | sed 's|/.*||'`
X
X	case $file in
X	cook/parse.y)
X		numconf="1 shift/reduce"
X		;;
X	cooktime/date.y)
X		numconf="8 shift/reduce"
X		;;
X	make2cook/gram.y)
X		numconf="1 shift/reduce"
X		;;
X	*)
X		numconf="no"
X		;;
X	esac
X
X	echo ""
X	echo "${stem}.gen.c ${stem}.gen.h: $file"
X	echo "	@echo Expect $numconf conflicts:"
X	echo "	$(YACC) -d $file"
X	echo "	sed -e 's/[yY][yY]/${root}_/g' y.tab.c > ${stem}.gen.c"
X	echo "	sed -e 's/[yY][yY]/${root}_/g' y.tab.h > ${stem}.gen.h"
X	echo "	rm y.tab.c y.tab.h"
X
X	depfile=`echo $file | sed 's/\.y$/.gen.d/'`
X	if [ -r $depfile ]; then
X		dep=`sed -e '1d' -e '$d' -e 's_.arch]/__' $depfile`
X	else
X		depfile=`echo $rfn | sed 's/\.y$/.gen.d/'`
X		if [ -r $depfile ]; then
X			dep=`sed -e '1d' -e '$d' -e 's_.arch]/__' $depfile`
X		fi
X	fi
X
X	echo ""
X	echo "${stem}.gen.o: ${stem}.gen.c" $dep
X	echo "	$(CC) $(CFLAGS) -I$dir -Icommon -c ${stem}.gen.c"
X	echo "	mv ${root}.gen.o ${stem}.gen.o"
X	;;
X
X*/*.c)
X	root=`basename $file .c`
X	stem=`echo $file | sed 's/\.c$//'`
X	dir=`echo $file | sed 's|/.*||'`
X
X	depfile=`echo $file | sed 's/\.c$/.d/'`
X	if [ -r $depfile ]; then
X		dep=`sed -e '1d' -e '$d' -e 's_.arch]/__' $depfile`
X	else
X		depfile=`echo $rfn | sed 's/\.c$/.d/'`
X		if [ -r $depfile ]; then
X			dep=`sed -e '1d' -e '$d' -e 's_.arch]/__' $depfile`
X		fi
X	fi
X
X	if [ ${root} = option ]
X	then
X		libdir="-D'LIBDIR=\"$(libdir)\"'"
X	fi
X
X	echo ""
X	echo "${stem}.o: $file" $dep
X	echo "	$(CC) $(CFLAGS)" $libdir "-I$dir -Icommon -c $file"
X	echo "	mv ${root}.o ${stem}.o"
X	;;
X
Xman1/*.1)
X	root=`basename $file .1`
X	echo ""
X	echo "man1/$root.h: $file bin/txt2c"
X	echo "	bin/txt2c $file man1/$root.h"
X
X	echo ""
X	echo "$(mandir)/man1/$root.1: $file bin/roffpp"
X	echo "	bin/roffpp -Iman1 $file tmp"
X	echo "	$(INSTALL_DATA) tmp $(mandir)/man1/$root.1"
X	echo "	@rm tmp"
X	;;
X
Xman1/*.so)
X	root=`basename $file .so`
X	echo ""
X	echo "man1/$root.h: $file bin/txt2c"
X	echo "	bin/txt2c $file man1/$root.h"
X	;;
X
Xlib/*)
X	root=`basename $file`
X	echo ""
X	echo "$(libdir)/$root: $file $(libdir)"
X	echo "	$(INSTALL_DATA) $file $(libdir)/$root"
X	;;
X
Xtest/*/*)
X	root=`basename $file .sh`
X	echo ""
X	echo "$root: $file all"
X	echo "	$(SH) $file"
X	;;
X
X*)
X	;;
Xesac
Xexit 0
END_OF_FILE
if test 3252 -ne `wc -c <'aux/Makefi.file.sh'`; then
    echo shar: \"'aux/Makefi.file.sh'\" unpacked with wrong size!
fi
# end of 'aux/Makefi.file.sh'
fi
if test -f 'aux/configure.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aux/configure.in'\"
else
echo shar: Extracting \"'aux/configure.in'\" \(3278 characters\)
sed "s/^X//" >'aux/configure.in' <<'END_OF_FILE'
Xdnl
Xdnl	cook - file construction tool
Xdnl	Copyright (C) 1994 Peter Miller.
Xdnl	All rights reserved.
Xdnl
Xdnl	This program is free software; you can redistribute it and/or modify
Xdnl	it under the terms of the GNU General Public License as published by
Xdnl	the Free Software Foundation; either version 2 of the License, or
Xdnl	(at your option) any later version.
Xdnl
Xdnl	This program is distributed in the hope that it will be useful,
Xdnl	but WITHOUT ANY WARRANTY; without even the implied warranty of
Xdnl	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
Xdnl	GNU General Public License for more details.
Xdnl
Xdnl	You should have received a copy of the GNU General Public License
Xdnl	along with this program; if not, write to the Free Software
Xdnl	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
Xdnl
Xdnl MANIFEST: how to configure cook, input to the GNU autoconf program
Xdnl
XAC_INIT(common/patchlevel.h)
XAC_CONFIG_HEADER(common/config.h)
XAC_PROG_CC
XAC_PROG_CPP
X
Xdnl
Xdnl	Avoid the /usr/ucb/cc compiler, it screws up readdir,
Xdnl	some systems seem to have the ucb one early in the path.
Xdnl
Xdnl	ranlib is unneccessary, but setting it to : will
Xdnl	not work, so set it to echo.
Xdnl
Xdnl	This test must be before the stdarg test
Xdnl	and before AC_CONST
Xdnl
Xif test -z "$GCC" ; then
Xecho checking for Pyramid
XAC_PROGRAM_EGREP(yes,[#ifdef __pyrsoft
X  yes
X#endif],CC="/usr/ccs/bin/cc"
XRANLIB="echo no need to ranlib")
Xfi
X
XAC_PROG_INSTALL
XAC_PROG_YACC
XAC_PROG_RANLIB
XAC_AIX
XAC_MINIX
XAC_ISC_POSIX
XAC_SCO_INTL
X
Xdnl
Xdnl	Test to see if stdarg.h is available *and* works.
Xdnl
Xecho checking for working stdarg.h
XAC_TEST_PROGRAM([
X#include <stdarg.h>
Xchar *foo = "test";
X#if defined(__STDC__) && __STDC__
Xint test(char*,...);
X#endif
Xint test(fmt)char*fmt;{va_list ap;char*a;int x;
Xva_start(ap,fmt);a=va_arg(ap,char*);x=(a!=foo);va_end(ap);return x;}
Xint main(argc,argv)int argc;char**argv;{
Xexit(test("",foo));}]
X, AC_DEFINE(HAVE_STDARG_H))dnl
X
XAC_HAVE_HEADERS(stddef.h stdlib.h limits.h ar.h)
XAC_HAVE_HEADERS(string.h memory.h unistd.h fcntl.h)
XAC_DIR_HEADER
XAC_XENIX_DIR
XAC_RETSIGTYPE
XAC_SIZE_T
XAC_TIME_WITH_SYS_TIME
XAC_CONST
XAC_LONG_FILE_NAMES
XAC_HAVE_FUNCS(strerror getpgrp tcgetpgrp getrusage ftime)
X
Xdnl
Xdnl	This came from the GNU Make configure.in file.
Xdnl	It is only used by the make2cook command.
Xdnl
Xecho checking for location of SCCS get command
Xif test -f /usr/sccs/get; then
X  SCCS_GET=/usr/sccs/get
X  AC_DEFINE(SCCS_GET, "/usr/sccs/get")
Xelse
X  SCCS_GET=get
X  AC_DEFINE(SCCS_GET, "get")
Xfi
Xac_clean_files="$ac_clean_files s.conftest conftoast" # Remove these later.
X
Xdnl
Xdnl	Test to see if getpgrp() or getpgrp(0) should be used to
Xdnl	discover the process group of the current process.
Xdnl
Xecho checking for appropriate getpgrp argument
XAC_TEST_PROGRAM([
Xint main(argc, argv) int argc; char **argv; {
X#ifdef HAVE_GETPGRP
Xif (getpgrp(32767) == getpgrp(0)) exit(2);
X#endif
Xexit(0); }]
X, AC_DEFINE(CONF_getpgrp_arg, 0), AC_DEFINE(CONF_getpgrp_arg, []))dnl
X
Xdnl
Xdnl	Test to find a Bourne shell which understands functions
Xdnl
Xecho checking for a Bourne shell which understands functions
Xif test "z$SH" = "z"; then
X    if test -f /bin/sh5; then
X	SH=/bin/sh5
X    else
X	SH=/bin/sh
X    fi
Xfi
XAC_SUBST(SH)
XAC_DEFINE_UNQUOTED(CONF_SHELL, [\"$SH\"])
X
XAC_OUTPUT(Makefile)
END_OF_FILE
if test 3278 -ne `wc -c <'aux/configure.in'`; then
    echo shar: \"'aux/configure.in'\" unpacked with wrong size!
fi
# end of 'aux/configure.in'
fi
if test -f 'aux/new.1.5.so' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aux/new.1.5.so'\"
else
echo shar: Extracting \"'aux/new.1.5.so'\" \(2836 characters\)
sed "s/^X//" >'aux/new.1.5.so' <<'END_OF_FILE'
X.\"
X.\"	cook - file construction tool
X.\"	Copyright (C) 1994 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: document describing new 1.5 features
X.\"
X.PP
X.if t \(bu
X.if n *
XThe
X.I c_incl
Xprogram now correctly prints the names of absent include files,
Xcausing them to be cooked correctly in a greater number of cases.
X.PP
X.if t \(bu
X.if n *
XRecipes with no ingredients are now only
Xapplied if the target is absent.
XTo still use the previous behaviour,
Xuse the "set force" clause on the recipe.
X.PP
X.if t \(bu
X.if n *
XIt is now possible to supplement the last-modified time with a fingerprint,
Xso cook does even fewer unnecesary recompilations than before.
XPut the statement
X.RS
X.ft CW
Xset fingerprint;
X.ft R
X.RE
Xsomewhere near the top of your
X.I Howto.cook
Xfile for this to be the default for your project.
X.PP
X.if t \(bu
X.if n *
XThere is a new form of include directive:
X.RS
X.ft CW
X#include-cooked \fIfilename\fP...
X.ft R
X.RE
XWhen files are included in this way,
X.I cook
Xwill check to make sure they are up-to-date.
XIf not, they will be cooked,
Xand then
X.I cook
Xwill start again and re-read the cookbook.
XThis is most often used for maintaining include-dependency files.
X.PP
X.if t \(bu
X.if n *
X.B Cook
Xnow configured using a program called
X.IR configure ,
Xdistributed with the package.
XThe
X.I configure
Xprogram is generated by GNU Autoconf.
XSee the
X.I BUILDING
Xfile for more details.
X.PP
X.if t \(bu
X.if n *
XThe semantics of
X.I search_list
Xhave been improved.
XIt is now guaranteed that when ingredients change they
Xresult in targets earlier in the
X.I search_list
Xbeing updated.
X.PP
X.if t \(bu
X.if n *
XThere is now a
X.I make2cook
Xtranslator,
Xto translate
X.I Makefile
Xfiles into
X.I Howto.cook
Xfiles.
XMost of the GNU Make extensions are understood.
XThere is no exact semantic mapping between
X.I make
Xand
X.I cook,
Xso manual editing is sometimes required.
XSee
X.IR make2cook (1)
Xfor more information.
X.PP
X.if t \(bu
X.if n *
X.I Cook
Xnow understands archive member references,
Xin the same format as used by
X.IR make ,
Xet al.
XArchive member references benefit from stat caching and fingerprinting,
Xjust as normal files do.
END_OF_FILE
if test 2836 -ne `wc -c <'aux/new.1.5.so'`; then
    echo shar: \"'aux/new.1.5.so'\" unpacked with wrong size!
fi
# end of 'aux/new.1.5.so'
fi
if test -f 'common/config.h.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/config.h.in'\"
else
echo shar: Extracting \"'common/config.h.in'\" \(2738 characters\)
sed "s/^X//" >'common/config.h.in' <<'END_OF_FILE'
X/* common/config.h.in.  Generated automatically from aux/configure.in by autoheader.  */
X
X/* Define if on AIX 3.
X   System headers sometimes define this.
X   We just want to avoid a redefinition error message.  */
X#ifndef _ALL_SOURCE
X#undef _ALL_SOURCE
X#endif
X
X/* Define to empty if the keyword does not work.  */
X#undef const
X
X/* Define if you have dirent.h.  */
X#undef DIRENT
X
X/* Define if you support file names longer than 14 characters.  */
X#undef HAVE_LONG_FILE_NAMES
X
X/* Define if on MINIX.  */
X#undef _MINIX
X
X/* Define if you don't have dirent.h, but have ndir.h.  */
X#undef NDIR
X
X/* Define if the system does not provide POSIX.1 features except
X   with this defined.  */
X#undef _POSIX_1_SOURCE
X
X/* Define if you need to in order for stat and other things to work.  */
X#undef _POSIX_SOURCE
X
X/* Define as the return type of signal handlers (int or void).  */
X#undef RETSIGTYPE
X
X/* Define to `unsigned' if <sys/types.h> doesn't define.  */
X#undef size_t
X
X/* Define if you don't have dirent.h, but have sys/dir.h.  */
X#undef SYSDIR
X
X/* Define if you don't have dirent.h, but have sys/ndir.h.  */
X#undef SYSNDIR
X
X/* Define if you can safely include both <sys/time.h> and <time.h>.  */
X#undef TIME_WITH_SYS_TIME
X
X/* Define if the closedir function returns void instead of int.  */
X#undef VOID_CLOSEDIR
X
X/*
X * Define this symbol of your system has <stdarg.h> AND it works.
X */
X#undef HAVE_STDARG_H
X
X/*
X * Set this to a suitable argument for the getpgrp function to discover
X * the process group of the current process.
X */
X#define CONF_getpgrp_arg broken
X
X/*
X * Set this to be the absolute path of a Bourne shell
X * which understands functions.
X */
X#define CONF_SHELL "/bin/sh"
X
X/*
X * Define to the name of the SCCS `get' command.
X * (Used only by make2cook)
X */
X#undef SCCS_GET
X
X/* Define if you have ftime.  */
X#undef HAVE_FTIME
X
X/* Define if you have getpgrp.  */
X#undef HAVE_GETPGRP
X
X/* Define if you have getrusage.  */
X#undef HAVE_GETRUSAGE
X
X/* Define if you have strerror.  */
X#undef HAVE_STRERROR
X
X/* Define if you have tcgetpgrp.  */
X#undef HAVE_TCGETPGRP
X
X/* Define if you have the <ar.h> header file.  */
X#undef HAVE_AR_H
X
X/* Define if you have the <fcntl.h> header file.  */
X#undef HAVE_FCNTL_H
X
X/* Define if you have the <limits.h> header file.  */
X#undef HAVE_LIMITS_H
X
X/* Define if you have the <memory.h> header file.  */
X#undef HAVE_MEMORY_H
X
X/* Define if you have the <stddef.h> header file.  */
X#undef HAVE_STDDEF_H
X
X/* Define if you have the <stdlib.h> header file.  */
X#undef HAVE_STDLIB_H
X
X/* Define if you have the <string.h> header file.  */
X#undef HAVE_STRING_H
X
X/* Define if you have the <unistd.h> header file.  */
X#undef HAVE_UNISTD_H
X
X/* Define if you have the intl library (-lintl).  */
X#undef HAVE_LIBINTL
END_OF_FILE
if test 2738 -ne `wc -c <'common/config.h.in'`; then
    echo shar: \"'common/config.h.in'\" unpacked with wrong size!
fi
# end of 'common/config.h.in'
fi
if test -f 'common/fp/cksum.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/fp/cksum.c'\"
else
echo shar: Extracting \"'common/fp/cksum.c'\" \(2480 characters\)
sed "s/^X//" >'common/fp/cksum.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate POSIX cksum fingerprints
X */
X
X#include <fp/cksum.h>
X#include <fp/crc32.h>
X#include <fp/len.h>
X
Xtypedef struct cksum_ty cksum_ty;
Xstruct cksum_ty
X{
X	FINGERPRINT_BASE_CLASS
X	fingerprint_ty	*crc32;
X	fingerprint_ty	*len;
X};
X
X
Xstatic void cksum_constructor _((fingerprint_ty *));
X
Xstatic void
Xcksum_constructor(p)
X	fingerprint_ty	*p;
X{
X	cksum_ty	*f;
X
X	f = (cksum_ty *)p;
X	f->crc32 = fingerprint_new(&fp_crc32);
X	f->len = fingerprint_new(&fp_len);
X}
X
X
Xstatic void cksum_destructor _((fingerprint_ty *));
X
Xstatic void
Xcksum_destructor(p)
X	fingerprint_ty	*p;
X{
X	cksum_ty	*f;
X
X	f = (cksum_ty *)p;
X	fingerprint_delete(f->crc32);
X	fingerprint_delete(f->len);
X}
X
X
Xstatic void cksum_addn _((fingerprint_ty *, unsigned char *, int));
X
Xstatic void
Xcksum_addn(p, s, n)
X	fingerprint_ty	*p;
X	unsigned char	*s;
X	int		n;
X{
X	cksum_ty	*f;
X
X	f = (cksum_ty *)p;
X	fingerprint_addn(f->crc32, s, n);
X	fingerprint_addn(f->len, s, n);
X}
X
X
Xstatic int cksum_hash _((fingerprint_ty *, unsigned char *));
X
Xstatic int
Xcksum_hash(p, h)
X	fingerprint_ty	*p;
X	unsigned char	*h;
X{
X	cksum_ty	*f;
X	int		nbytes;
X	unsigned char	*obuf;
X
X	f = (cksum_ty *)p;
X	obuf = h;
X	nbytes = fingerprint_hash(f->crc32, h);
X	h += nbytes;
X	nbytes = fingerprint_hash(f->len, h);
X	h += nbytes;
X	return (h - obuf);
X}
X
X
Xstatic void cksum_sum _((fingerprint_ty *, char *));
X
Xstatic void
Xcksum_sum(p, s)
X	fingerprint_ty	*p;
X	char		*s;
X{
X	cksum_ty	*f;
X
X	f = (cksum_ty *)p;
X	fingerprint_sum(f->crc32, s);
X	s += strlen(s);
X	*s++ = ' ';
X	fingerprint_sum(f->len, s);
X}
X
X
Xfingerprint_methods_ty fp_cksum =
X{
X	sizeof(cksum_ty),
X	"cksum",
X	cksum_constructor,
X	cksum_destructor,
X	cksum_addn,
X	cksum_hash,
X	cksum_sum
X};
END_OF_FILE
if test 2480 -ne `wc -c <'common/fp/cksum.c'`; then
    echo shar: \"'common/fp/cksum.c'\" unpacked with wrong size!
fi
# end of 'common/fp/cksum.c'
fi
if test -f 'common/mem.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/mem.c'\"
else
echo shar: Extracting \"'common/mem.c'\" \(2996 characters\)
sed "s/^X//" >'common/mem.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate dynamic memory
X */
X
X#include <ac/stddef.h>
X#include <ac/string.h>
X#include <ac/stdlib.h>
X#include <errno.h>
X
X#include <mem.h>
X#include <error.h>
X
X
X/*
X * NAME
X *	memory_error - diagnostic
X *
X * SYNOPSIS
X *	void memory_error(void);
X *
X * DESCRIPTION
X *	The memory_error function is used to report fatal problems with the
X *	memory allocator.
X *
X * RETURNS
X *	The memory_error function does not return.
X */
X
Xstatic void memory_error _((void));
X
Xstatic void
Xmemory_error()
X{
X#ifdef DEBUG
X	nerror("memory allocator");
X	abort();
X#else
X	nfatal("memory allocator");
X#endif
X}
X
X
X/*
X * NAME
X *	mem_alloc - allocate and clear memory
X *
X * SYNOPSIS
X *	char *mem_alloc(size_t n);
X *
X * DESCRIPTION
X *	Mem_alloc uses malloc to allocate the required sized chunk of memory.
X *	If any error is returned from malloc() an fatal diagnostic is issued.
X *	The memory is zeroed befor it is returned.
X *
X * CAVEAT
X *	It is the responsibility of the caller to ensure that the space is
X *	freed when finished with, by a call to free().
X */
X
Xvoid *
Xmem_alloc(n)
X	size_t		n;
X{
X	void		*p;
X
X	if (n < 1)
X		n = 1;
X	errno = 0;
X	p = malloc(n);
X	if (!p)
X	{
X		if (!errno)
X			errno = ENOMEM;
X		memory_error();
X	}
X	return p;
X}
X
X
X/*
X * NAME
X *	mem_alloc_clear - allocate and clear memory
X *
X * SYNOPSIS
X *	char *mem_alloc_clear(size_t n);
X *
X * DESCRIPTION
X *	Mem_alloc_clear uses malloc to allocate the required sized chunk of memory.
X *	If any error is returned from malloc() an fatal diagnostic is issued.
X *	The memory is zeroed befor it is returned.
X *
X * CAVEAT
X *	It is the responsibility of the caller to ensure that the space is
X *	freed when finished with, by a call to free().
X */
X
Xvoid *
Xmem_alloc_clear(n)
X	size_t		n;
X{
X	void		*p;
X
X	p = mem_alloc(n);
X	memset(p, 0, n);
X	return p;
X}
X
X
Xvoid *
Xmem_change_size(p, n)
X	void		*p;
X	size_t		n;
X{
X	if (n < 1)
X		n = 1;
X	errno = 0;
X	if (!p)
X		p = malloc(n);
X	else
X		p = realloc(p, n);
X	if (!p)
X	{
X		if (!errno)
X			errno = ENOMEM;
X		memory_error();
X	}
X	return p;
X}
X
X
Xvoid
Xmem_free(p)
X	void		*p;
X{
X	free(p);
X}
X
X
Xchar *
Xmem_copy_string(s)
X	char		*s;
X{
X	char		*cp;
X
X	cp = mem_alloc(strlen(s) + 1);
X	strcpy(cp, s);
X	return cp;
X}
END_OF_FILE
if test 2996 -ne `wc -c <'common/mem.c'`; then
    echo shar: \"'common/mem.c'\" unpacked with wrong size!
fi
# end of 'common/mem.c'
fi
if test -f 'cook/builtin/collect.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/builtin/collect.c'\"
else
echo shar: Extracting \"'cook/builtin/collect.c'\" \(3433 characters\)
sed "s/^X//" >'cook/builtin/collect.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to implement the builtin collect functions
X *
X * The builtin function all append their results to the supplied
X * `result' word list.  The first word of the `args' word list
X * is the name of the function.
X *
X * all of the functions return 0 in success, or -1 on error.
X */
X
X#include <stdio.h>
X#include <ac/string.h>
X#include <errno.h>
X
X#include <builtin/collect.h>
X#include <error.h>
X#include <expr.h>
X#include <option.h>
X#include <os.h>
X
X
X/*
X * NAME
X *	builtin_collect - get output of a command
X *
X * SYNOPSIS
X *	int builtin_collect(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	Collect is a built-in function of cook, described as follows:
X *	This function requires one or more arguments.
X *
X * RETURNS
X *	A word list containing the values of the output lines of the
X *	program given in the arguments.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_collect(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	FILE		*fp;
X	string_ty	*s;
X	char		*delim;
X	int		status;
X	int		silent;
X	int		errok;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	if (args->wl_nwords < 2)
X	{
X		expr_error
X		(
X			"%s: requires one or more arguments",
X			args->wl_word[0]->str_text
X		);
X		return -1;
X	}
X	s = wl2str(args, 1, args->wl_nwords - 1, (char *)0);
X	option_set(OPTION_SILENT, OPTION_LEVEL_EXECUTE, 1);
X	option_set(OPTION_ERROK, OPTION_LEVEL_EXECUTE, 0);
X	silent = option_test(OPTION_SILENT);
X	errok = option_test(OPTION_ERROK);
X	if (!silent)
X		error("%s", s->str_text);
X	fp = popen(s->str_text, "r");
X	str_free(s);
X	if (!fp)
X	{
X		expr_error
X		(
X			"%s: %s",
X			args->wl_word[1]->str_text,
X			strerror(errno)
X		);
X		return -1;
X	}
X	delim = strchr(args->wl_word[0]->str_text, '_') ? "\n" : "\n \t\f";
X	for (;;)
X	{
X		char		buffer[1024];
X		char		*cp;
X		int		c;
X
X		for (;;)
X		{
X			c = fgetc(fp);
X			if (c == EOF || !strchr(delim, c))
X				break;
X		}
X		if (c == EOF)
X			break;
X		cp = buffer;
X		for (;;)
X		{
X			*cp++ = c;
X			c = fgetc(fp);
X			if (c == EOF || strchr(delim, c))
X				break;
X		}
X		s = str_n_from_c(buffer, cp - buffer);
X		wl_append(result, s);
X		str_free(s);
X		if (c == EOF)
X			break;
X	}
X	if (ferror(fp))
X	{
X		expr_error
X		(
X			"%s: %s",
X			args->wl_word[1]->str_text,
X			strerror(errno)
X		);
X		option_undo_level(OPTION_LEVEL_EXECUTE);
X		return -1;
X	}
X	if (!silent)
X		star_sync();
X	status = pclose(fp);
X	status = exit_status(args->wl_word[0]->str_text, status, errok);
X	option_undo_level(OPTION_LEVEL_EXECUTE);
X	if (status)
X		return -1;
X	return 0;
X}
END_OF_FILE
if test 3433 -ne `wc -c <'cook/builtin/collect.c'`; then
    echo shar: \"'cook/builtin/collect.c'\" unpacked with wrong size!
fi
# end of 'cook/builtin/collect.c'
fi
if test -f 'cook/builtin/execute.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/builtin/execute.c'\"
else
echo shar: Extracting \"'cook/builtin/execute.c'\" \(2671 characters\)
sed "s/^X//" >'cook/builtin/execute.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to implement the builtin execute function
X *
X * The builtin functions all append their results to the supplied
X * `result' word list.  The first word of the `args' word list
X * is the name of the function.
X *
X * all of the functions return 0 in success, or -1 on error.
X */
X
X#include <builtin/execute.h>
X#include <error.h>
X#include <expr.h>
X#include <option.h>
X#include <os.h>
X
X
X/*
X * NAME
X *	builtin_execute - execute a command
X *
X * SYNOPSIS
X *	int builtin_execute(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	Exec is a built-in function of cook, described as follows:
X *	This function requires at least one argument, and
X *	executes the command given by the arguments.
X *
X * RETURNS
X *	If the executed command returns an error code the resulting value
X *	is "" (false), otherwise it is "1" (true).
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_execute(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	wlist		wl;
X	int		j;
X	string_ty	*s;
X	int		silent;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	if (args->wl_nwords < 2)
X	{
X		expr_error
X		(
X			"%s: requires at least one argument",
X			args->wl_word[0]->str_text
X		);
X		return -1;
X	}
X	wl_zero(&wl);
X	for (j = 1; j < args->wl_nwords; j++)
X		wl_append(&wl, args->wl_word[j]);
X	option_set(OPTION_SILENT, OPTION_LEVEL_EXECUTE, 1);
X	silent = option_test(OPTION_SILENT);
X	if (!silent)
X	{
X		string_ty	*s;
X
X		s = wl2str(&wl, 0, wl.wl_nwords - 1, (char *)0);
X		error("%s", s->str_text);
X		str_free(s);
X	}
X	j = os_execute(&wl, (string_ty *)0, 0);
X	if (!silent)
X		star_sync();
X	option_undo_level(OPTION_LEVEL_EXECUTE);
X	wl_free(&wl);
X	if (j < 0)
X		return -1;
X	s = (j ? str_false : str_true);
X	wl_append(result, s);
X	return 0;
X}
END_OF_FILE
if test 2671 -ne `wc -c <'cook/builtin/execute.c'`; then
    echo shar: \"'cook/builtin/execute.c'\" unpacked with wrong size!
fi
# end of 'cook/builtin/execute.c'
fi
if test -f 'cook/cook.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/cook.h'\"
else
echo shar: Extracting \"'cook/cook.h'\" \(2857 characters\)
sed "s/^X//" >'cook/cook.h' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: interface definition for cook/cook.c
X */
X
X#ifndef COOK_H
X#define COOK_H
X
X#include <ac/time.h>
X
X#include <expr.h>
X#include <stmt.h>
X
Xextern int desist;
X
X
Xtypedef struct recipe recipe;
Xstruct	recipe
X{
X	wlist		r_target;
X	elist		r_need;
X	elist		r_need2;
X	int		r_flags;
X	stmt		*r_action;
X	stmt		*r_use_action;
X	int		r_tag;		/* for tracing and debugging */
X	expr		*r_precondition;
X	int		r_multiple;
X	int		inhibit;
X};
X
Xtypedef struct rlist rlist;
Xstruct	rlist
X{
X	size_t		rl_nrecipes;
X	recipe		*rl_recipe;
X};
X
Xextern	rlist	explicit;
Xextern	rlist	implicit;
X
X/*
X *  r_flags values
X */
X#define RF_CLEARSTAT		((unsigned long)1 <<  0)
X#define RF_CLEARSTAT_OFF	((unsigned long)1 <<  1)
X#define RF_DEFAULT		((unsigned long)1 <<  2)
X#define RF_DEFAULT_OFF		((unsigned long)1 <<  3)
X#define RF_ERROK		((unsigned long)1 <<  4)
X#define RF_ERROK_OFF		((unsigned long)1 <<  5)
X#define RF_FINGERPRINT		((unsigned long)1 <<  6)
X#define RF_FINGERPRINT_OFF	((unsigned long)1 <<  7)
X#define RF_FORCE		((unsigned long)1 <<  8)
X#define RF_FORCE_OFF		((unsigned long)1 <<  9)
X#define RF_METER		((unsigned long)1 << 10)
X#define RF_METER_OFF		((unsigned long)1 << 11)
X#define RF_PRECIOUS		((unsigned long)1 << 12)
X#define RF_PRECIOUS_OFF		((unsigned long)1 << 13)
X#define RF_SILENT		((unsigned long)1 << 14)
X#define RF_SILENT_OFF		((unsigned long)1 << 15)
X#define RF_UPDATE		((unsigned long)1 << 16)
X#define RF_UPDATE_OFF		((unsigned long)1 << 17)
X#define RF_STRIPDOT		((unsigned long)1 << 18)
X#define RF_STRIPDOT_OFF		((unsigned long)1 << 19)
X
Xint cook _((wlist *));
Xvoid rl_append _((rlist *, recipe *));
Xvoid cook_flags _((int, int));
Xint recipe_tag _((void));
Xint isit_uptodate _((string_ty *));
Xint cando _((string_ty *));
Xtime_t cook_mtime_oldest _((string_ty *path, long *depth_p));
Xtime_t cook_mtime_newest _((string_ty *path, long *depth_p));
Xint cook_mtime_resolve _((wlist *, wlist *, int));
X
Xvoid cook_auto _((wlist *));
Xint cook_auto_required _((void));
Xvoid cook_reset _((void));
Xvoid cook_find_default _((wlist *));
X
X#endif /* COOK_H */
END_OF_FILE
if test 2857 -ne `wc -c <'cook/cook.h'`; then
    echo shar: \"'cook/cook.h'\" unpacked with wrong size!
fi
# end of 'cook/cook.h'
fi
if test -f 'cook/env.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/env.c'\"
else
echo shar: Extracting \"'cook/env.c'\" \(3471 characters\)
sed "s/^X//" >'cook/env.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate environment variables
X */
X
X#include <ac/stddef.h>
X#include <ac/stdlib.h>
X#include <ac/string.h>
X
X#include <main.h>
X#include <env.h>
X#include <mem.h>
X#include <error.h>
X
X
Xextern	char	**environ;
Xstatic	size_t	nenvirons;
X
X
X/*
X * NAME
X *	env_initialize - start up environment
X *
X * SYNOPSIS
X *	void env_initialize(void);
X *
X * DESCRIPTION
X *	The env_initialize function is used to copy all of the environment
X *	variables into dynamic memory, so that they may be altered by the
X *	setenv and unsetenv commands.
X */
X
Xvoid
Xenv_initialize()
X{
X	int		j;
X	char	**old;
X
X	nenvirons = 0;
X	for (j = 0; environ[j]; ++j)
X		++nenvirons;
X	old = environ;
X	environ = mem_alloc((nenvirons + 1) * sizeof(char *));
X	for (j = 0; j < nenvirons; ++j)
X	{
X		char	*cp;
X		char	*was;
X
X		was = old[j];
X		cp = mem_alloc(strlen(was) + 1);
X		strcpy(cp, was);
X		environ[j] = cp;
X	}
X	environ[nenvirons] = 0;
X	env_set("SHELL", "/bin/sh");
X}
X
X
X/*
X * NAME
X *	setenv - set environment variable
X *
X * SYNOPSIS
X *	void setenv(char *name, char *value);
X *
X * DESCRIPTION
X *	The setenv function is used to set the given environment variable to
X *	the given value.
X *
X * CAVEAT
X *	Assumes that the env_initialize function has already been called.
X */
X
Xvoid
Xenv_set(name, value)
X	char		*name;
X	char		*value;
X{
X	size_t		name_len;
X	int		j;
X	char		*cp;
X
X	cp = 0;
X	name_len = strlen(name);
X	for (j = 0; j < nenvirons; ++j)
X	{
X		cp = environ[j];
X		assert(cp);
X		if
X		(
X			(cp[name_len] == '=' || !cp[name_len])
X		&&
X			!strncmp(cp, name, name_len)
X		)
X			break;
X	}
X	if (environ[j])
X	{
X		environ[j] = 0;
X		if (cp)
X			free(cp);
X	}
X	else
X	{
X		size_t	nbytes;
X
X		nbytes = (nenvirons + 2) * sizeof(char *);
X		environ = mem_change_size(environ, nbytes);
X		environ[++nenvirons] = 0;
X	}
X	cp = mem_alloc(name_len + strlen(value) + 2);
X	strcpy(cp, name);
X	cp[name_len] = '=';
X	strcpy(cp + name_len + 1, value);
X	environ[j] = cp;
X}
X
X
X/*
X * NAME
X *	unsetenv - remove environment variable
X *
X * SYNOPSIS
X *	void unsetenv(char *name);
X *
X * DESCRIPTION
X *	The unsetenv function is used to remove the named variable from the
X *	environment.
X *
X * RETURNS
X *	void
X *
X * CAVEAT
X *	Assumes that the env_initialize function has been called already.
X */
X
Xvoid
Xenv_unset(name)
X	char		*name;
X{
X	size_t		name_len;
X	int		j;
X	char		*cp;
X
X	name_len = strlen(name);
X	cp = 0;
X	for (j = 0; j < nenvirons; ++j)
X	{
X		cp = environ[j];
X		assert(cp);
X		if
X		(
X			(cp[name_len] == '=' || !cp[name_len])
X		&&
X			!strncmp(cp, name, name_len)
X		)
X			break;
X	}
X	if (!environ[j])
X		return;
X	environ[j] = 0;
X	if (cp)
X		free(cp);
X	--nenvirons;
X	for ( ; j < nenvirons; ++j)
X		environ[j] = environ[j + 1];
X}
END_OF_FILE
if test 3471 -ne `wc -c <'cook/env.c'`; then
    echo shar: \"'cook/env.c'\" unpacked with wrong size!
fi
# end of 'cook/env.c'
fi
if test -f 'cook/option.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/option.h'\"
else
echo shar: Extracting \"'cook/option.h'\" \(2819 characters\)
sed "s/^X//" >'cook/option.h' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: interface definition for cook/option.c
X */
X
X#ifndef OPTION_H
X#define OPTION_H
X
X#include <main.h>
X
X#include <str.h>
X#include <word.h>
X
X/*
X * option levels, highest to lowest
X * (room for 16 levels in a 32 bit unsigned)
X */
Xenum option_level_ty
X{
X	OPTION_LEVEL_ERROR,
X	OPTION_LEVEL_AUTO,
X	OPTION_LEVEL_COMMAND_LINE,
X	OPTION_LEVEL_EXECUTE,
X	OPTION_LEVEL_RECIPE,
X	OPTION_LEVEL_COOKBOOK,
X	OPTION_LEVEL_ENVIRONMENT,
X	OPTION_LEVEL_DEFAULT
X};
Xtypedef enum option_level_ty option_level_ty;
X
Xenum option_number_ty
X{
X	OPTION_PERSEVERE,	/* keep trying if have errors */
X	OPTION_SILENT,		/* do not echo any command */
X	OPTION_ERROK,		/* ignore error returns from commands */
X	OPTION_ACTION,		/* do not execute the command */
X	OPTION_TOUCH,		/* do not execute the command, just touch */
X	OPTION_FORCE,		/* always execute the commands */
X	OPTION_PRECIOUS,	/* do not delete failed targets */
X	OPTION_TERMINAL,	/* enable tty output when logging */
X	OPTION_TRACE,		/* emit tracing information */
X	OPTION_CMDFILE,		/* generate a command file */
X	OPTION_METER,		/* meter each command */
X	OPTION_LOGGING,
X	OPTION_BOOK,
X	OPTION_INVALIDATE_STAT_CACHE,
X	OPTION_STAR,		/* emit progress stars */
X	OPTION_FINGERPRINT,	/* remember file fingerprints */
X	OPTION_UPDATE,		/* update utime for consistency */
X	OPTION_STRIP_DOT,	/* strip leading ./ from paths */
X	OPTION_max
X};
Xtypedef enum option_number_ty option_number_ty;
X
Xtypedef struct option_ty option_ty;
Xstruct option_ty
X{
X	unsigned	o_flag[OPTION_max];
X	wlist		o_target;
X	string_ty	*o_book;
X	string_ty	*o_logfile;
X	wlist		o_search_path;
X	wlist		o_vardef;
X};
X
Xextern	option_ty	option;
Xextern	char		*progname;
X
Xint option_already _((option_number_ty, option_level_ty));
Xint option_test _((option_number_ty));
Xvoid option_set _((option_number_ty, option_level_ty, int));
Xvoid option_undo _((option_number_ty, option_level_ty));
Xvoid option_undo_level _((option_level_ty));
Xvoid option_set_errors _((void));
Xvoid option_tidy_up _((void));
X
X#endif /* OPTION_H */
END_OF_FILE
if test 2819 -ne `wc -c <'cook/option.h'`; then
    echo shar: \"'cook/option.h'\" unpacked with wrong size!
fi
# end of 'cook/option.h'
fi
if test -f 'cook/stmt.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/stmt.h'\"
else
echo shar: Extracting \"'cook/stmt.h'\" \(2635 characters\)
sed "s/^X//" >'cook/stmt.h' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: interface definition for cook/stmt.c
X */
X
X#ifndef STMT_H
X#define STMT_H
X
X#include <main.h>
X#include <str.h>
X#include <expr.h>
X
X/*
X * s_op values
X */
Xenum stmt_op_ty
X{
X	OP_ASSIGN = 1,
X	OP_COMMAND,
X	OP_COMPOUND,
X	OP_FAIL,
X	OP_FAIL_DK,
X	OP_IF,
X	OP_LOOP,
X	OP_LOOPSTOP,
X	OP_NOP,
X	OP_RECIPE,
X	OP_SET,
X	OP_TOUCH,
X	OP_UNSETENV
X};
Xtypedef enum stmt_op_ty stmt_op_ty;
X
Xtypedef struct assign assign;
Xstruct assign
X{
X	elist		a_name;
X	elist		a_value;
X};
X
Xtypedef struct slist slist;
Xstruct slist
X{
X	size_t		sl_nstmts;
X	struct stmt	**sl_stmt;
X};
X
Xtypedef struct srecipe srecipe;
Xstruct srecipe
X{
X	elist		sr_target;
X	elist		sr_need;
X	elist		sr_need2;
X	int		sr_flags;
X	struct stmt	*sr_action;
X	struct stmt	*sr_use_action;
X	position	sr_position;
X	expr		*sr_precondition;
X	int		sr_multiple;
X};
X
Xtypedef struct command command;
Xstruct command
X{
X	elist		c_args;
X	int		c_flags;
X	expr		*c_input;
X};
X
Xtypedef struct sif sif;
Xstruct sif
X{
X	expr		*sif_cond;
X	struct stmt	*sif_true;
X	struct stmt	*sif_false;
X};
X
Xtypedef struct stmt stmt;
Xstruct stmt
X{
X	stmt_op_ty	s_op;
X	long		s_references;
X	union
X	{
X		assign		s__assign;
X		command		s__cmd;
X		slist		s__list;
X		sif		s__if;
X		stmt		*s__loop;
X		srecipe		s__recipe;
X		expr		*s__include;
X	}
X		s__u;
X};
X#define s_assign	s__u.s__assign
X#define s_cmd		s__u.s__cmd
X#define s_if		s__u.s__if
X#define s_list		s__u.s__list
X#define s_loop		s__u.s__loop
X#define s_recipe	s__u.s__recipe
X#define s_include	s__u.s__include
X
X/*
X * return values for stmt_eval()
X */
X#define STMT_OK		0
X#define STMT_LSTOP	-1
X#define STMT_RET	-2
X#define STMT_ERROR	-3
X#define STMT_BACKTRACK -4
X
Xstmt *stmt_alloc _((void));
Xstmt *stmt_copy _((stmt *));
Xvoid stmt_free _((stmt *));
Xint stmt_eval _((stmt *));
Xvoid sl_append _((slist *, stmt *));
Xvoid sl_free _((slist *));
Xvoid sl_zero _((slist *));
X
X#endif /* STMT_H */
END_OF_FILE
if test 2635 -ne `wc -c <'cook/stmt.h'`; then
    echo shar: \"'cook/stmt.h'\" unpacked with wrong size!
fi
# end of 'cook/stmt.h'
fi
if test -f 'doc/function/opsys.so' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/function/opsys.so'\"
else
echo shar: Extracting \"'doc/function/opsys.so'\" \(2569 characters\)
sed "s/^X//" >'doc/function/opsys.so' <<'END_OF_FILE'
X.\"
X.\"	cook - file construction tool
X.\"	Copyright (C) 1990, 1991, 1992, 1993, 1994 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: Reference Manual, Built-In Functions, Operating_System
X.\"
X.H 2 "operating_system"
XThis function requires zero or more arguments.
XThe resulting wordlist contains the values of various attributes of
Xthe operating system, as named in the arguments.
XIf no attributes are named, "system" is assumed.
XBelow is a list of attributes:
X.VL 1i
X.LI system
XThe name of the operating system
X.B cook
Xpresently being run under.
XFor example:
Xif you were running on SunOS 4.1.3,
Xthis would return "\f(CWSunOS\fP".
X.LI release
XThe specific release of operating system, within name,
X.B cook
Xis presently being run under.
XFor example:
Xif you were running on SunOS 4.1.3,
Xthis would return "\f(CW4.1.3\fP".
X.LI version
XVersion information.
XFor SunOS 4.1.3, this would return the kernel build number,
Xfor other systems it is often the kernel patch release number.
X.LI machine
XThe name of the hardware
X.B cook
Xis presently running on.
XFor example:
XIf you were running on SunOS 4.1.3
Xthis would return "\f(CWsun4\fP" or similar.
X.LE
X.P
XThis function may be abbreviated to "os".
X.H 3 "Example"
XThis function is usually used to determine
Xthe architecture (either system or machine):
X.eB
Xarch=[os system]-[os release]-[os machine];
Xif [matches SunOS-4.1%1-sun4%2 [arch]] then
X	arch = sun4;
Xelse if [matches SunOS-5.%1-sun4%2 [arch]] then
X	arch = sun5;
Xelse if [matches SunOS-5.%1-i86pc [arch]] then
X	arch = sun5pc;
Xelse if [matches ConvexOS-%1-%2 [arch]] then
X	arch = convex;
Xelse
X	arch = unknown;
X.eE
X.H 3 "Caveat"
XThis function is implemented using the
X.IR uname (2)
Xsystem call.
XSome systems do not implement this correctly,
Xand therefore this function is less useful than it should be,
Xand needs the pattern match appropach used above.
END_OF_FILE
if test 2569 -ne `wc -c <'doc/function/opsys.so'`; then
    echo shar: \"'doc/function/opsys.so'\" unpacked with wrong size!
fi
# end of 'doc/function/opsys.so'
fi
if test -f 'doc/match.so' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/match.so'\"
else
echo shar: Extracting \"'doc/match.so'\" \(2574 characters\)
sed "s/^X//" >'doc/match.so' <<'END_OF_FILE'
X.\"
X.\"	cook - file construction tool
X.\"	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: Reference Manual, File name patterns
X.\"	
X.H 1 "File name patterns"
XThe tough part about designing a pattern matcher for something like cook is
Xthat the patterns must be reversible.
XThat is,
Xit must be possible to use
Xthe same string both as a pattern to be matched against and as a template
Xfor building a string once a pattern has matched.
XRather like the
Xdifference between the left and right sides of an editor search-and-replace
Xcommand in an editor using the same description for both the search pattern
Xand the replace template.
XThis is why classic regular expressions have not been used.
XThey tend to be slow to match, too.
X.P
XThis matcher has eleven match "fields",
Xreferenced as
X.B %
Xand
X.B %0
Xto
X.BR %9 .
XThe
X.B %
Xcharacter can be escaped as
X.B %% .
XThe
X.B %
Xand
X.B %1
Xto
X.B %9
Xforms match any character except
X.BR / .
XThe
X.B %0
Xform matches all characters,
Xbut must be either empty,
Xor have whole path components,
Xincluding the trailing
X.B /
Xon each component.
X.P
XA few examples will make this clearer:
X.TS
Xbox, center, tab(;);
Xl l.
Xstring;does not match
X_
X%.c;snot/fred.c
X%1/%2.c;etc/boo/fred.c
X.TE
X.TS
Xbox, center, tab(;);
Xl l lw(1.5i).
Xstring;matches;setting
X_
X%.c;fred.c;%="fred"
X%1/%2.c;snot/fred.c;T{
X%1="snot"
X.br
X%2="fred"
XT}
X%0%5.c;fred.c;T{
X%0="" 
X.br
X%5="fred"
XT}
X%0%6.c;snot/fred.c;T{
X%0="snot/" 
X.br
X%6="fred"
XT}
X%0%7.c;etc/boo/fred.c;T{
X%0="etc/boo/" 
X.br
X%7="fred"
XT}
X/usr/%1/%1%2/%3.%2%4;/usr/man/man1/fred.1x;T{
X%1="man"
X.br
X%2="1"
X.br
X%3="fred" 
X.br
X%4="x"
XT}
X.TE
X.P
XThe
X.B %0
Xbehaviour is designed to allow patterns to range over subtrees in a
Xcontrolled manner.
XNote that the use of this sort of pattern in a recipe
Xwill result in deeper searches than the naive recipe designer would expect.
END_OF_FILE
if test 2574 -ne `wc -c <'doc/match.so'`; then
    echo shar: \"'doc/match.so'\" unpacked with wrong size!
fi
# end of 'doc/match.so'
fi
if test -f 'lib/c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib/c'\"
else
echo shar: Extracting \"'lib/c'\" \(2858 characters\)
sed "s/^X//" >'lib/c' <<'END_OF_FILE'
X/*
X * NAME
X *	c - the C compiler cookbook
X *
X * DESCRIPTION
X *	This cookbook describes how to work with C files.
X *	Include file dependencies are automatically determined.
X *
X * RECIPES
X *	%.o: %.c	make object files form C source files
X *	%.ln: %.c	make lint object files from C source files
X *	
X * VARIABLES
X *	c_incl		The C indude dependency sniffer command.
X *			Not altered if already defined.
X *	cc		The C compiler command
X *			Not altered if already defined.
X *	lint		The lint command.
X *			Not altered if already defined.
X *	cc_flags	options to pass to the C compiler command
X *			Not altered if already defined.
X *			The default is "-O".
X *	cc_include_flags Options passed to the C compiler and c_incl
X *			controlling include file searching.
X *			Not altered if already defined.
X *			The default is empty.
X *	cc_link_flags	Options passed to the C compiler when linking,
X *			these are typically library search paths and libraries.
X *			Not altered if already defined.
X *			The default is empty.
X *	cc_src		C source files in the current directory.
X *	dot_src		Source files constructable in the current directory
X *			(unioned with existing setting, if necessary).
X *	dot_obj		Object files constructable in the current directory
X *			(unioned with existing setting, if necessary).
X *	dot_clean	Files which may be removed from the current directory
X *			in a clean target.			
X *	dot_lint_obj	Lint object files constructable in the current directory
X *			(unioned with existing setting, if necessary).
X *
X * MANIFEST: cookbook for using C
X */
X
X#pragma once
X
Xif [not [defined c_incl]] then
X	c_incl = [find_command c_incl];
Xif [not [defined cc]] then
X	cc = cc;
Xif [not [defined cc_flags]] then
X	cc_flags = -O;
Xif [not [defined cc_include_flags]] then
X	cc_include_flags = ;
Xif [not [defined cc_link_flags]] then
X	cc_link_flags = ;
Xif [not [defined lint]] then
X	lint = lint;
Xcc_src = [glob "*.c" ];
Xif [not [defined dot_src]] then
X	dot_src = ;
Xdot_src = [stringset [dot_src] [cc_src] - [fromto %.c %.s [cc_src]]];
Xif [not [defined dot_obj]] then
X	dot_obj = ;
Xdot_obj = [stringset [dot_obj] [fromto %.c %.o [cc_src]]];
Xif [not [defined dot_clean]] then
X	dot_clean = ;
Xdot_clean =
X	[stringset
X		[dot_clean]
X		[fromto %.c %.o [cc_src]]
X		[fromto %.c %.ln [cc_src]]
X		[fromto %.c %.s [cc_src]]
X	];
Xif [not [defined dot_lint_obj]] then
X	dot_lint_obj = ;
Xdot_lint_obj = [stringset [dot_lint_obj] [fromto %.c %.ln [cc_src]]];
X
X%.o: %.c
X{
X	[cc] [cc_include_flags] [cc_flags] -c [resolve %.c];
X}
X
X%.ln: %.c
X{
X	[lint] [cc_include_flags] [cc_flags] -c [resolve %.c];
X}
X
X/*
X * if the c_incl command is available, then check dependencies
X */
X#if [c_incl]
X
X%.d: %.c
X{
X	[c_incl] -nc -ns [cc_include_flags] [resolve %.c]
X		-prefix "'%.o %.ln %.d:'" -suffix "'set nodefault;'"
X		> [target];
X}
X
Xcc_dep_files = [fromto %.c %.d [cc_src]];
X#include-cooked [cc_dep_files]
X#endif
END_OF_FILE
if test 2858 -ne `wc -c <'lib/c'`; then
    echo shar: \"'lib/c'\" unpacked with wrong size!
fi
# end of 'lib/c'
fi
if test -f 'lib/library' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib/library'\"
else
echo shar: Extracting \"'lib/library'\" \(2534 characters\)
sed "s/^X//" >'lib/library' <<'END_OF_FILE'
X/*
X * NAME
X *	library - construct a library
X *
X * DESCRIPTION
X *	This cookbook defines how to construct a library.
X *
X *	If an include file (or files) are defined for this file,
X *	you will have to append them to [install] in your Howto.cook file.
X *
X * VARIABLES
X *	all		targets of the all recipe
X *	install		targets of the install recipe
X *	me		the name of the library to be constructed.
X *			Defaults to the last component of the pathname
X *			of the current directory.
X *	ar		The archive command.
X *	install		targets of the install command.
X *
X * RECIPES
X *	all:		construct the targets defined in [all].
X *	clean:		remove the files named in [dot_clean].
X *	clobber:	remove the files name in [dot_clean] and [all].
X *
X * If the [lib] variable is defined
X *	install:	construct the files named in [install].
X *	uninstall:	remove the files named in [install].
X *
X * MANIFEST: cookbook for constructing libraries
X */
X
X#pragma once
X
Xif [not [defined dot_obj]] then
X{
X    echo "The [dot_obj] variable is not set." set silent;
X    echo "You probably want to use the "c" cookbook" set silent;
X    echo "before you use the "library" cookbook." set silent;
X    fail;
X}
X
Xif [not [defined ar]] then
X    ar = [find_command ar];
Xif [not [defined ranlib]] then
X	ranlib = [find_command ranlib];
Xif [not [defined me]] then
X    me = [entryname [dir [pathname x]]];
X
Xall = lib[me].a;
Xif [defined dot_lint_obj] then
X    all = [all] llib-l[me].ln;
X
Xall: [all];
X
Xclean:
X    {
X	rm -f [dot_clean]
X	    set clearstat;
X    }
X
Xclobber: clean
X    {
X	rm -f [all]
X	    set clearstat;
X    }
X
Xif [defined lib] then
X{
X    if [not [defined install]] then
X        install = ;
X    install = [install] [lib]/lib[me].a;
X    if [defined dot_lint_obj] then
X	install = [install] [lib]/llib-l[me].ln;
X
X    [lib]/%: %
X        {
X            cp -p % [lib]/%;
X            chmod og-w [lib]/%;
X        }
X}
X
Xif [defined include] then
X{
X    if [not [defined install]] then
X        install = ;
X    install = [install] [include]/[me].h;
X
X    [include]/%: %
X        {
X            cp -p % [include]/%;
X            chmod og-w [include]/%;
X        }
X}
X
Xif [defined install] then
X{
X    install: [install];
X
X    uninstall:
X        {
X            rm -f [install]
X		set clearstat;
X        }
X}
X
X
Xlib[me].a: [dot_obj]
X    {
X	if [exists [target]] then
X	    rm -f [target]
X	        set clearstat;
X	[ar] r [target] [dot_obj];
X	if [ranlib] then
X		[ranlib] [target];
X    }
X
Xif [defined dot_lint_obj] then
X{
X    llib-l[me].ln: [dot_lint_obj]
X        {
X	    [lint] [dot_lint_obj] -o [me];
X        }
X}
END_OF_FILE
if test 2534 -ne `wc -c <'lib/library'`; then
    echo shar: \"'lib/library'\" unpacked with wrong size!
fi
# end of 'lib/library'
fi
if test -f 'lib/yacc_many' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib/yacc_many'\"
else
echo shar: Extracting \"'lib/yacc_many'\" \(2622 characters\)
sed "s/^X//" >'lib/yacc_many' <<'END_OF_FILE'
X/*
X * NAME
X *	yacc_many - how to use yacc several times in the same directory
X *
X * DESCRIPTION
X *	This cookbook describes how to use yacc.
X *	The difference with the "yacc" cookbook is that this cookbook
X *	allows you to have more that one yacc generated parser in the same
X *	program, by using the classic sed(1) hack of the output.
X *
X *	You will have to add "-d" to the [yacc_flags] variable
X *	if you want %.h files generated.
X *
X *	If a y.output file is constructed, it will be moved to %.list
X *
X * RECIPES
X *	%.c %.h: %.y	applied if -d in [yacc_flags]
X *	%.c: %.y	applied if -d not in [yacc_flags]
X *
X * VARIABLES
X *	yacc_src	Yacc source files in the current directory.
X *	dot_src		Source files constructable in the current directory
X *			(unioned with existing setting, if necessary).
X *	dot_obj		Object files constructable in the current directory
X *			(unioned with existing setting, if necessary).
X *	dot_clean	Files which may be removed from the current directory
X *			in a clean target.			
X *	dot_lint_obj	Lint object files constructable in the current directory
X *			(unioned with existing setting, if necessary).
X *
X * MANIFEST: cookbook for using yacc more than once in same program
X */
X
X#pragma once
X
X#include "c"
X
Xif [not [defined yacc]] then
X    yacc = yacc;
Xif [not [defined yacc_flags]] then
X    yacc_flags = ;
Xyacc_src = [glob *.y];
Xcc_src = [stringset [cc_src] - [fromto %.y %.c [yacc_src]]];
Xdot_src =
X    [stringset
X	    [dot_src] [yacc_src]
X	-
X	    [fromto %.y %.c [yacc_src]] [fromto %.y %.s [yacc_src]]
X    ];
Xdot_obj = [stringset [dot_obj] [fromto %.y %.o [yacc_src]]];
Xdot_clean =
X    [stringset
X	[dot_clean]
X	[fromto %.y %.o [yacc_src]]
X	[fromto %.y %.c [yacc_src]]
X	[fromto %.y %.list [yacc_src]]
X	[fromto %.y %.ln [yacc_src]]
X	[fromto %.y %.s [yacc_src]]
X	y.tab.c y.tab.h y.output
X    ];
Xdot_lint_obj = [stringset [dot_lint_obj] [fromto %.y %.ln [yacc_src]]];
X
X
X%.c %.h: %.y if [in -d [yacc_flags]]
X    {
X	if [exists %.list] then
X	    rm -f %.list
X		set clearstat;
X	if [exists y.output] then
X	    rm -f y.output
X		set clearstat;
X	[yacc] [yacc_flags] %.y;
X	sed -e \'s/\[yY\]\[yY\]/%_/g\' y.tab.c > %.c;
X	rm -f y.tab.c;
X	sed -e \'s/\[yY\]\[yY\]/%_/g\' y.tab.h > %.h;
X	rm -f y.tab.h;
X	if [exists y.output] then
X	    mv y.output %.list
X		set clearstat;
X    }
X
X%.c: %.y if [not [in -d [yacc_flags]]]
X    {
X	if [exists %.list] then
X	    rm -f %.list
X		set clearstat;
X	if [exists y.output] then
X	    rm -f y.output
X		set clearstat;
X	[yacc] [yacc_flags] %.y;
X	sed -e \'s/\[yY\]\[yY\]/%_/g\' y.tab.c > %.c;
X	rm -f y.tab.c;
X	if [exists y.output] then
X	    mv y.output %.list
X		set clearstat;
X    }
END_OF_FILE
if test 2622 -ne `wc -c <'lib/yacc_many'`; then
    echo shar: \"'lib/yacc_many'\" unpacked with wrong size!
fi
# end of 'lib/yacc_many'
fi
if test -f 'make2cook/emit.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'make2cook/emit.c'\"
else
echo shar: Extracting \"'make2cook/emit.c'\" \(2996 characters\)
sed "s/^X//" >'make2cook/emit.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to emit the result
X */
X
X#include <stdio.h>
X
X#include <emit.h>
X#include <error.h>
X
Xstatic string_ty *filename;
Xstatic FILE	*output;
Xint		emit_line_numbers;
Xint		col;
Xlong		old_ln;
Xstring_ty	*old_fn;
Xint		depth;
X
X
Xvoid
Xemit_open(s)
X	char		*s;
X{
X	assert(!output);
X	if (s)
X	{
X		output = fopen(s, "w");
X		if (!output)
X			nfatal("%s", s);
X		filename = str_from_c(s);
X	}
X	else
X	{
X		filename = str_from_c("standard output");
X		output = stdout;
X	}
X	col = 0;
X}
X
X
Xvoid
Xemit_close()
X{
X	assert(output);
X	emit_bol();
X	if (output != stdout && fclose(output))
X		nfatal("%s", filename->str_text);
X	str_free(filename);
X	filename = 0;
X	output = 0;
X	col = 0;
X}
X
X
Xvoid
Xemit_bol()
X{
X	if (col)
X		emit_char('\n');
X}
X
X
Xvoid
Xemit_char(c)
X	int		c;
X{
X	if (c != '\n' && !col && depth > 0)
X	{
X		int	j;
X
X		for (j = 0; j < depth; ++j)
X			putc('\t', output);
X	}
X	if (putc(c, output) == EOF)
X		nfatal("%s", filename->str_text);
X	if (c == '\n')
X	{
X		++old_ln;
X		col = 0;
X	}
X	else
X	{
X		++col;
X	}
X}
X
X
Xvoid
Xemit_str(s)
X	char		*s;
X{
X	while (*s)
X		emit_char(*s++);
X}
X
X
Xvoid
Xemit_string(s)
X	string_ty	*s;
X{
X	emit_str(s->str_text);
X}
X
X
Xvoid
Xemit_line_number(lino, fn)
X	long		lino;
X	string_ty	*fn;
X{
X	static string_ty *builtin;
X
X	assert(output);
X	if (!builtin)
X		builtin = str_from_c("builtin");
X	if (str_equal(fn, builtin))
X		return;
X	if (old_ln == lino && str_equal(old_fn, fn))
X		return;
X	
X	/*
X	 * for short distances in the same file,
X	 * just throw newlines
X	 */
X	if (str_equal(old_fn, fn) && lino > old_ln && lino - old_ln < 10)
X	{
X		while (old_ln < lino)
X			emit_char('\n');
X		return;
X	}
X
X	if (emit_line_numbers)
X	{
X		emit_bol();
X		fprintf(output, "#line %ld \"%s\"\n", lino, fn->str_text);
X		if (ferror(output))
X			nfatal("write %s", filename->str_text);
X	}
X	else if (!str_equal(old_fn, fn) || lino > (old_ln + !!col))
X	{
X		emit_bol();
X		emit_char('\n');
X	}
X
X	old_ln = lino;
X	if (old_fn)
X		str_free(old_fn);
X	old_fn = str_copy(fn);
X}
X
X
Xvoid
Xemit_set_file(fn)
X	string_ty	*fn;
X{
X	if (str_equal(old_fn, fn))
X		return;
X	emit_bol();
X	if (old_fn)
X	{
X		str_free(old_fn);
X		emit_char('\n');
X	}
X	old_fn = str_copy(fn);
X	old_ln = 32767;
X}
X
X
Xvoid
Xemit_indent_more()
X{
X	++depth;
X}
X
X
Xvoid
Xemit_indent_less()
X{
X	--depth;
X}
END_OF_FILE
if test 2996 -ne `wc -c <'make2cook/emit.c'`; then
    echo shar: \"'make2cook/emit.c'\" unpacked with wrong size!
fi
# end of 'make2cook/emit.c'
fi
if test -f 'make2cook/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'make2cook/main.c'\"
else
echo shar: Extracting \"'make2cook/main.c'\" \(3145 characters\)
sed "s/^X//" >'make2cook/main.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: operating system entry point
X */
X
X#include <stdio.h>
X
X#include <arglex.h>
X#include <emit.h>
X#include <error.h>
X#include <gram.h>
X#include <help.h>
X#include <stmt/rule.h>
X#include <trace.h>
X#include <version.h>
X
X
Xenum
X{
X	arglex_token_history_commands,
X	arglex_token_line_numbers
X};
X
Xstatic arglex_table_ty argtab[] =
X{
X	{ "-History_Commands", arglex_token_history_commands, },
X	{ "-Line_Numbers", arglex_token_line_numbers, },
X	{ 0, 0, }, /* end marker */
X};
X
X
Xstatic void usage _((void));
X
Xstatic void
Xusage()
X{
X	fprintf(stderr, "usage: %s [ <infile> [ <outfile> ]]\n", progname);
X	fprintf(stderr, "       %s -help\n", progname);
X	exit(1);
X}
X
X
Xstatic void main_help _((void));
X
Xstatic void
Xmain_help()
X{
X	static char *text[] =
X	{
X#include <../man1/make2cook.h>
X	};
X
X	help(text, SIZEOF(text), usage);
X}
X
X
Xint main _((int, char **));
X
Xint
Xmain(argc, argv)
X	int		argc;
X	char		**argv;
X{
X	char		*infile;
X	char		*outfile;
X
X	arglex_init(argc, argv, argtab);
X	str_initialize();
X	switch (arglex())
X	{
X	case arglex_token_help:
X		main_help();
X		exit(0);
X	
X	case arglex_token_version:
X		version();
X		exit(0);
X	
X	default:
X		break;
X	}
X
X	infile = 0;
X	outfile = 0;
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch (arglex_token)
X		{
X		default:
X			error
X			(
X				"misplaced \"%s\" command line option",
X				arglex_value.alv_string
X			);
X			usage();
X
X		case arglex_token_string:
X			if (!infile)
X				infile = arglex_value.alv_string;
X			else if (!outfile)
X				outfile = arglex_value.alv_string;
X			else
X			{
X				too_many_filenames:
X				fatal("too many filenames specified");
X			}
X			break;
X
X		case arglex_token_stdio:
X			if (!infile)
X				infile = "";
X			else if (!outfile)
X				outfile = "";
X			else
X				goto too_many_filenames;
X			break;
X
X		case arglex_token_history_commands:
X			++stmt_rule_default_history;
X			break;
X
X		case arglex_token_line_numbers:
X			++emit_line_numbers;
X			break;
X
X#ifdef DEBUG
X		case arglex_token_tracing:
X			if (arglex() != arglex_token_string)
X				fatal("-TRACIng requires one or more string arguments");
X			for (;;)
X			{
X				trace_enable(arglex_value.alv_string);
X				if (arglex() != arglex_token_string)
X					break;
X			}
X			continue;
X#endif
X		}
X		arglex();
X	}
X	if (infile && !*infile)
X		infile = 0;
X	if (outfile && !*outfile)
X		outfile = 0;
X
X	emit_open(outfile);
X	gram(infile);
X	emit_close();
X
X	exit(0);
X	return 0;
X}
END_OF_FILE
if test 3145 -ne `wc -c <'make2cook/main.c'`; then
    echo shar: \"'make2cook/main.c'\" unpacked with wrong size!
fi
# end of 'make2cook/main.c'
fi
if test -f 'make2cook/stmt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'make2cook/stmt.c'\"
else
echo shar: Extracting \"'make2cook/stmt.c'\" \(2472 characters\)
sed "s/^X//" >'make2cook/stmt.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate statements
X */
X
X#include <mem.h>
X#include <stmt.h>
X#include <trace.h>
X
X
Xstmt_ty *
Xstmt_alloc(mp)
X	stmt_method_ty	*mp;
X{
X	stmt_ty		*result;
X
X	trace(("stmt_alloc(mp = %08lX)\n{\n"/*}*/, (long)mp));
X	result = mem_alloc(mp->size);
X	result->method = mp;
X	result->white_space = 0;
X	wl_zero(&result->mdef);
X	wl_zero(&result->cdef);
X	wl_zero(&result->ref);
X	wl_zero(&result->rref);
X	if (mp->constructor)
X		mp->constructor(result);
X	trace(("return %08lX;\n", (long)result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
Xvoid
Xstmt_emit(sp)
X	stmt_ty		*sp;
X{
X	trace(("stmt_emit(sp = %08lX)\n{\n"/*}*/, (long)sp));
X	if (sp->method->emit)
X		sp->method->emit(sp);
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xstmt_free(sp)
X	stmt_ty		*sp;
X{
X	trace(("stmt_free(sp = %08lX)\n{\n"/*}*/, (long)sp));
X	if (sp->method->destructor)
X		sp->method->destructor(sp);
X	wl_free(&sp->mdef);
X	wl_free(&sp->cdef);
X	wl_free(&sp->ref);
X	wl_free(&sp->rref);
X	mem_free(sp);
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xstmt_variable_merge(parent, child)
X	stmt_ty		*parent;
X	stmt_ty		*child;
X{
X	size_t		j;
X
X	for (j = 0; j < child->mdef.wl_nwords; ++j)
X		wl_append_unique(&parent->mdef, child->mdef.wl_word[j]);
X	for (j = 0; j < child->cdef.wl_nwords; ++j)
X		wl_append_unique(&parent->cdef, child->cdef.wl_word[j]);
X	for (j = 0; j < child->ref.wl_nwords; ++j)
X		wl_append_unique(&parent->ref, child->ref.wl_word[j]);
X	for (j = 0; j < child->rref.wl_nwords; ++j)
X		wl_append_unique(&parent->rref, child->rref.wl_word[j]);
X}
X
X
Xvoid
Xstmt_regroup(sp)
X	stmt_ty		*sp;
X{
X	if (sp->method->regroup)
X		sp->method->regroup(sp);
X}
X
X
Xvoid
Xstmt_sort(sp)
X	stmt_ty		*sp;
X{
X	if (sp->method->sort)
X		sp->method->sort(sp);
X}
END_OF_FILE
if test 2472 -ne `wc -c <'make2cook/stmt.c'`; then
    echo shar: \"'make2cook/stmt.c'\" unpacked with wrong size!
fi
# end of 'make2cook/stmt.c'
fi
if test -f 'make2cook/stmt/comment.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'make2cook/stmt/comment.c'\"
else
echo shar: Extracting \"'make2cook/stmt/comment.c'\" \(3083 characters\)
sed "s/^X//" >'make2cook/stmt/comment.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate comment statements
X */
X
X#include <ctype.h>
X
X#include <emit.h>
X#include <mem.h>
X#include <stmt/comment.h>
X
Xtypedef struct stmt_comment_ty stmt_comment_ty;
Xstruct stmt_comment_ty
X{
X	STMT
X	blob_list_ty	*body;
X};
X
X
Xstatic void constructor _((stmt_ty *));
X
Xstatic void
Xconstructor(that)
X	stmt_ty		*that;
X{
X	stmt_comment_ty	*this;
X
X	this = (stmt_comment_ty *)that;
X	this->body = blob_list_alloc();
X}
X
X
Xstatic void destructor _((stmt_ty *));
X
Xstatic void
Xdestructor(that)
X	stmt_ty		*that;
X{
X	stmt_comment_ty	*this;
X
X	this = (stmt_comment_ty *)that;
X	blob_list_free(this->body);
X}
X
X
Xstatic int blank _((char *));
X
Xstatic int
Xblank(s)
X	char		*s;
X{
X	while (*s && isspace(*s))
X		++s;
X	while (*s == '#')
X		++s;
X	while (*s && isspace(*s))
X		++s;
X	return !*s;
X}
X
X
Xstatic void emit _((stmt_ty *));
X
Xstatic void
Xemit(that)
X	stmt_ty		*that;
X{
X	stmt_comment_ty	*this;
X	blob_list_ty	*blp;
X	long		min;
X	long		max;
X	long		j;
X
X	this = (stmt_comment_ty *)that;
X	blp = this->body;
X	if (!blp->length)
X		return;
X	for (min = 0; min < blp->length; ++min)
X		if (!blank(blp->list[min]->text->str_text))
X			break;
X	for (max = blp->length - 1; max >= 0; --max)
X		if (!blank(blp->list[max]->text->str_text))
X			break;
X	if (min > max)
X		return;
X	emit_line_number
X	(
X		blp->list[min]->line_number - 1,
X		blp->list[min]->file_name
X	);
X	emit_str("/*\n");
X	for (j = min; j <= max; ++j)
X	{
X		static string_ty *t1;
X		static string_ty *t2;
X		string_ty	*tmp;
X		char		*s;
X
X		if (!t1)
X		{
X			t1 = str_from_c("*/");
X			t2 = str_from_c("* /");
X		}
X		tmp = str_substitute(t1, t2, blp->list[j]->text);
X		s = tmp->str_text;
X		while (*s && isspace(*s))
X			++s;
X		while (*s == '#')
X			++s;
X		while (*s && isspace(*s))
X			++s;
X
X		emit_str(" *");
X		if (*s)
X		{
X			emit_char(' ');
X			emit_str(s);
X		}
X		emit_char('\n');
X		str_free(tmp);
X	}
X	emit_str(" */\n");
X}
X
X
Xstatic stmt_method_ty method =
X{
X	sizeof(stmt_comment_ty),
X	"comment",
X	constructor,
X	destructor,
X	emit,
X	0, /* regroup */
X	0, /* sort */
X};
X
X
Xstmt_ty *
Xstmt_comment_alloc()
X{
X	stmt_ty		*result;
X
X	result = stmt_alloc(&method);
X	result->white_space = 1;
X	return result;
X}
X
X
Xvoid
Xstmt_comment_append(that, lp)
X	stmt_ty		*that;
X	blob_ty		*lp;
X{
X	stmt_comment_ty	*this;
X
X	this = (stmt_comment_ty *)that;
X	blob_list_append(this->body, lp);
X}
END_OF_FILE
if test 3083 -ne `wc -c <'make2cook/stmt/comment.c'`; then
    echo shar: \"'make2cook/stmt/comment.c'\" unpacked with wrong size!
fi
# end of 'make2cook/stmt/comment.c'
fi
if test -f 'make2cook/stmt/if.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'make2cook/stmt/if.c'\"
else
echo shar: Extracting \"'make2cook/stmt/if.c'\" \(3042 characters\)
sed "s/^X//" >'make2cook/stmt/if.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate if statements
X */
X
X#include <ctype.h>
X
X#include <emit.h>
X#include <stmt/if.h>
X#include <variable.h>
X
Xtypedef struct stmt_if_ty stmt_if_ty;
Xstruct stmt_if_ty
X{
X	STMT
X	blob_list_ty	*condition;
X	stmt_ty		*then_clause;
X	stmt_ty		*else_clause;
X};
X
X
Xstatic void destructor _((stmt_ty *));
X
Xstatic void
Xdestructor(that)
X	stmt_ty		*that;
X{
X	stmt_if_ty	*this;
X
X	this = (stmt_if_ty *)that;
X	blob_list_free(this->condition);
X	stmt_free(this->then_clause);
X	if (this->else_clause)
X		stmt_free(this->else_clause);
X}
X
X
Xstatic void emit _((stmt_ty *));
X
Xstatic void
Xemit(that)
X	stmt_ty		*that;
X{
X	stmt_if_ty	*this;
X	size_t		j;
X
X	this = (stmt_if_ty *)that;
X	emit_line_number
X	(
X		this->condition->list[0]->line_number,
X		this->condition->list[0]->file_name
X	);
X	emit_str("#if");
X	for (j = 0; j < this->condition->length; ++j)
X	{
X		emit_char(' ');
X		emit_string(this->condition->list[j]->text);
X	}
X	emit_char('\n');
X
X	stmt_emit(this->then_clause);
X	emit_bol();
X
X	if (this->else_clause)
X	{
X		emit_str("#else\n");
X		stmt_emit(this->else_clause);
X		emit_bol();
X	}
X	emit_str("#endif\n");
X}
X
X
Xstatic void regroup _((stmt_ty *));
X
Xstatic void
Xregroup(that)
X	stmt_ty		*that;
X{
X	stmt_if_ty	*this;
X
X	this = (stmt_if_ty *)that;
X	stmt_regroup(this->then_clause);
X	if (this->else_clause)
X		stmt_regroup(this->else_clause);
X}
X
X
Xstatic void sort _((stmt_ty *));
X
Xstatic void
Xsort(that)
X	stmt_ty		*that;
X{
X	stmt_if_ty	*this;
X
X	this = (stmt_if_ty *)that;
X	stmt_sort(this->then_clause);
X	if (this->else_clause)
X		stmt_sort(this->else_clause);
X}
X
X
Xstatic stmt_method_ty method =
X{
X	sizeof(stmt_if_ty),
X	"if",
X	0, /* constructor */
X	destructor,
X	emit,
X	regroup,
X	sort,
X};
X
X
Xstmt_ty *
Xstmt_if_alloc(condition, then_clause, else_clause)
X	blob_ty		*condition;
X	stmt_ty		*then_clause;
X	stmt_ty		*else_clause;
X{
X	stmt_if_ty	*result;
X	blob_list_ty	*c2;
X
X	c2 = blob_list_alloc();
X	result = (stmt_if_ty *)stmt_alloc(&method);
X	variable_rename(condition, c2, &result->ref);
X	blob_free(condition);
X	result->condition = c2;
X	result->then_clause = then_clause;
X	result->else_clause = else_clause;
X
X	stmt_variable_merge((stmt_ty *)result, then_clause);
X	if (else_clause)
X		stmt_variable_merge((stmt_ty *)result, else_clause);
X	return (stmt_ty *)result;
X}
END_OF_FILE
if test 3042 -ne `wc -c <'make2cook/stmt/if.c'`; then
    echo shar: \"'make2cook/stmt/if.c'\" unpacked with wrong size!
fi
# end of 'make2cook/stmt/if.c'
fi
if test -f 'make2cook/stmt/include.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'make2cook/stmt/include.c'\"
else
echo shar: Extracting \"'make2cook/stmt/include.c'\" \(2793 characters\)
sed "s/^X//" >'make2cook/stmt/include.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate include statements
X */
X
X#include <ctype.h>
X#include <ac/string.h>
X
X#include <emit.h>
X#include <mem.h>
X#include <stmt/include.h>
X#include <variable.h>
X
Xtypedef struct stmt_include_ty stmt_include_ty;
Xstruct stmt_include_ty
X{
X	STMT
X	int		type;
X	blob_list_ty	*body;
X};
X
X
Xstatic void destructor _((stmt_ty *));
X
Xstatic void
Xdestructor(that)
X	stmt_ty		*that;
X{
X	stmt_include_ty	*this;
X
X	this = (stmt_include_ty *)that;
X	blob_list_free(this->body);
X}
X
X
Xstatic int wildchars _((blob_ty *));
X
Xstatic int
Xwildchars(s)
X	blob_ty		*s;
X{
X	char		*cp;
X
X	cp = s->text->str_text;
X	while (*cp)
X	{
X		if (strchr("?[*]", *cp))
X			return 1;
X		++cp;
X	}
X	return 0;
X}
X
X
Xstatic void emit _((stmt_ty *));
X
Xstatic void
Xemit(that)
X	stmt_ty		*that;
X{
X	stmt_include_ty	*this;
X	long		j;
X	int		wild;
X	int		wild2;
X
X	this = (stmt_include_ty *)that;
X	if (!this->body->length)
X		return;
X	emit_line_number
X	(
X		this->body->list[0]->line_number,
X		this->body->list[0]->file_name
X	);
X	wild = 0;
X	switch (this->type)
X	{
X	default:
X		emit_str("#include");
X		break;
X
X	case 2:
X		emit_str("#include-cooked");
X		wild = 1;
X		break;
X
X	case 3:
X		emit_str("#include-cooked-nowarn");
X		wild = 1;
X		break;
X	}
X	for (j = 0; j < this->body->length; ++j)
X	{
X		emit_char(' ');
X		wild2 = (wild && wildchars(this->body->list[j]));
X		if (wild2)
X			emit_str("[wildcard ");
X		emit_string(this->body->list[j]->text);
X		if (wild2)
X			emit_char(']');
X	}
X	emit_bol();
X}
X
X
Xstatic stmt_method_ty method =
X{
X	sizeof(stmt_include_ty),
X	"include",
X	0, /* constructor */
X	destructor,
X	emit,
X	0, /* regroup */
X	0, /* sort */
X};
X
X
Xstmt_ty *
Xstmt_include_alloc(body, type)
X	blob_list_ty	*body;
X	int		type;
X{
X	stmt_include_ty	*result;
X	blob_list_ty	*body2;
X	long		j;
X
X	result = (stmt_include_ty *)stmt_alloc(&method);
X	body2 = blob_list_alloc();
X	for (j = 0; j < body->length; ++j)
X		variable_rename(body->list[j], body2, &result->ref);
X	blob_list_free(body);
X	result->body = body2;
X	result->type = type;
X	return (stmt_ty *)result;
X}
END_OF_FILE
if test 2793 -ne `wc -c <'make2cook/stmt/include.c'`; then
    echo shar: \"'make2cook/stmt/include.c'\" unpacked with wrong size!
fi
# end of 'make2cook/stmt/include.c'
fi
if test -f 'roffpp/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'roffpp/main.c'\"
else
echo shar: Extracting \"'roffpp/main.c'\" \(3283 characters\)
sed "s/^X//" >'roffpp/main.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: operating system start point, and parse command line arguments
X */
X
X#include <stdio.h>
X#include <ac/stddef.h>
X#include <ac/string.h>
X#include <ac/stdlib.h>
X
X#include <arglex.h>
X#include <error.h>
X#include <help.h>
X#include <preprocess.h>
X#include <str.h>
X#include <trace.h>
X#include <version.h>
X
X
Xstatic void usage _((void));
X
Xstatic void
Xusage()
X{
X	fprintf(stderr, "usage: %s [ <option>... ][ <infile> [ <outfile> ]]\n", progname);
X	fprintf(stderr, "       %s -Help\n", progname);
X	fprintf(stderr, "       %s -VERSion\n", progname);
X	exit(1);
X}
X
X
Xstatic void main_help _((void));
X
Xstatic void
Xmain_help()
X{
X	static char *text[] =
X	{
X#include <../man1/roffpp.h>
X	};
X
X	help(text, SIZEOF(text), usage);
X}
X
X
Xenum
X{
X	arglex_token_include
X};
X
Xstatic arglex_table_ty argtab[] =
X{
X	{ "-\\I*",	(arglex_token_ty)arglex_token_include,	},
X	{ "-Include",	(arglex_token_ty)arglex_token_include,	},
X	{ 0, (arglex_token_ty)0, }, /* end marker */
X};
X
X
Xint main _((int, char **));
X
Xint
Xmain(argc, argv)
X	int	argc;
X	char	**argv;
X{
X	char	*infile;
X	char	*outfile;
X
X	arglex_init(argc, argv, argtab);
X	str_initialize();
X
X	switch (arglex())
X	{
X	case arglex_token_help:
X		main_help();
X		exit(0);
X
X	case arglex_token_version:
X		version();
X		exit(0);
X
X	default:
X		break;
X	}
X
X	infile = 0;
X	outfile = 0;
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch (arglex_token)
X		{
X		default:
X			error
X			(
X				"misplaced \"%s\" command line argument",
X				arglex_value.alv_string
X			);
X			usage();
X	
X		case arglex_token_string:
X			if (!infile)
X				infile = arglex_value.alv_string;
X			else if (!outfile)
X				outfile = arglex_value.alv_string;
X			else
X				fatal("too many file names specified");
X			break;
X	
X		case arglex_token_stdio:
X			if (!infile)
X				infile = "";
X			else if (!outfile)
X				outfile = "";
X			else
X				fatal("too many file names specified");
X			break;
X	
X		case arglex_token_include:
X			if (arglex() != arglex_token_string)
X				fatal("-Include requires a string argument");
X			preprocess_include(arglex_value.alv_string);
X			break;
X
X#ifdef DEBUG
X		case arglex_token_tracing:
X			if (arglex() != arglex_token_string)
X				fatal("-TRACIng requires ore or more string arguments");
X			for (;;)
X			{
X				trace_enable(arglex_value.alv_string);
X				if (arglex() != arglex_token_string);
X					break;
X			}
X			continue;
X#endif
X		}
X		arglex();
X	}
X	if (infile && !*infile)
X		infile = 0;
X	if (outfile && !*outfile)
X		outfile = 0;
X	preprocess(infile, outfile);
X	exit(0);
X	return 0;
X}
END_OF_FILE
if test 3283 -ne `wc -c <'roffpp/main.c'`; then
    echo shar: \"'roffpp/main.c'\" unpacked with wrong size!
fi
# end of 'roffpp/main.c'
fi
if test -f 'test/00/t0038a.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test/00/t0038a.sh'\"
else
echo shar: Extracting \"'test/00/t0038a.sh'\" \(2935 characters\)
sed "s/^X//" >'test/00/t0038a.sh' <<'END_OF_FILE'
X#!/bin/sh
X#
X#	cook - file construction tool
X#	Copyright (C) 1990, 1991, 1992, 1993, 1994 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: test roffpp functionality
X#
Xtmp=/tmp/$$
XPAGER=cat
Xexport PAGER
Xumask 022
Xunset COOK
Xhere=`pwd`
Xif test $? -ne 0 ; then exit 1; fi
X
Xif test "$1" != "" ; then bin="$here/$1/bin"; else bin="$here/bin"; fi
X
Xfail()
X{
X	echo 'FAILED test of roffpp command' 1>&2
X	cd $here
X	rm -rf $tmp
X	exit 1
X}
Xpass()
X{
X	cd $here
X	rm -rf $tmp
X	exit 0
X}
Xtrap "fail" 1 2 3 15
X
Xmkdir $tmp
Xmkdir $tmp/bloggs
Xcd $tmp
X
X#
X# test the plain-vanilla form
X#
Xcat > test.in << 'foobar'
Xtesting
X.so test2.in
Xline three
Xfoobar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test2.in << 'foobar'
Xone
Xtwo
Xthree
Xfoobar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.ok << 'foobar'
X.lf 1 test.in
Xtesting
X.lf 1 test2.in
Xone
Xtwo
Xthree
X.lf 3 test.in
Xline three
Xfoobar
Xif test $? -ne 0 ; then fail; fi
X
X$bin/roffpp test.in test.out
Xif test $? -ne 0 ; then fail; fi
X
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X
X#
X# test the .lf directive
X#
Xcat > test.in << 'foobar'
Xtesting
X.lf 47 granny-smith
XGranny Smith
X.so test2.in
Xline three
Xfoobar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test2.in << 'foobar'
Xone
Xtwo
Xthree
Xfoobar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.ok << 'foobar'
X.lf 1 test.in
Xtesting
X.lf 47 granny-smith
XGranny Smith
X.lf 1 test2.in
Xone
Xtwo
Xthree
X.lf 49 granny-smith
Xline three
Xfoobar
Xif test $? -ne 0 ; then fail; fi
X
X$bin/roffpp test.in test.out
Xif test $? -ne 0 ; then fail; fi
X
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X
X#
X# test the explicit include path form
X#
Xcat > test.in << 'foobar'
Xtesting
X.so test2.in
X.so ../test2.in
Xline four
Xfoobar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > bloggs/test2.in << 'foobar'
XBodgie Rent-a-Wreck
X-- free --
Xwith every 200 lb rotweiler sold
Xfoobar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.ok << 'foobar'
X.lf 1 test.in
Xtesting
X.lf 1 bloggs/test2.in
XBodgie Rent-a-Wreck
X-- free --
Xwith every 200 lb rotweiler sold
X.lf 3 test.in
X.lf 1 bloggs/../test2.in
Xone
Xtwo
Xthree
X.lf 4 test.in
Xline four
Xfoobar
Xif test $? -ne 0 ; then fail; fi
X
X$bin/roffpp -Ibloggs -I. test.in test.out
Xif test $? -ne 0 ; then fail; fi
X
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X
X# probably OK
Xpass
END_OF_FILE
if test 2935 -ne `wc -c <'test/00/t0038a.sh'`; then
    echo shar: \"'test/00/t0038a.sh'\" unpacked with wrong size!
fi
# end of 'test/00/t0038a.sh'
fi
if test -f 'test/00/t0048a.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test/00/t0048a.sh'\"
else
echo shar: Extracting \"'test/00/t0048a.sh'\" \(2477 characters\)
sed "s/^X//" >'test/00/t0048a.sh' <<'END_OF_FILE'
X#!/bin/sh
X#
X#	cook - file construction tool
X#	Copyright (C) 1994 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: Test the include-cooked functionality
X#
Xwork=/tmp/$$
XPAGER=cat
Xexport PAGER
Xumask 022
Xunset COOK
Xhere=`pwd`
Xif test $? -ne 0 ; then exit 1; fi
X
Xif test "$1" != "" ; then bin="$here/$1/bin"; else bin="$here/bin"; fi
X
Xfail()
X{
X	set +x
X	echo 'FAILED test of the include-cooked functionality' 1>&2
X	cd $here
X	rm -rf $work
X	exit 1
X}
Xpass()
X{
X	set +x
X	cd $here
X	rm -rf $work
X	exit 0
X}
Xtrap \"fail\" 1 2 3 15
X
Xmkdir $work
Xif test $? -ne 0 ; then exit 1; fi
Xcd $work
Xif test $? -ne 0 ; then fail; fi
X
XPATH=${bin}:${PATH}
Xexport PATH
X
X#
X# use clever C include dependencies
X#
Xcat > Howto.cook << 'fubar'
X
Xobj = [fromto %.c %.o [glob *.c]];
X
Xtest.out: test
X{
X	./test > test.out;
X}
X
X%.o: %.c
X{
X	cc -c %.c;
X}
X
X%.d: %.c
X{
X	c_incl -nc -ns -eia %.c -prefix "'%.o %.d: %.c'" -suffix "';'" > %.d;
X}
X
X#include-cooked [fromto %.o %.d [obj]]
X
Xtest: [obj]
X{
X	cc -o test [obj];
X}
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.c << 'fubar'
Xtest()
X{
X	printf("Hello, World!\n");
X}
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.h << 'fubar'
Xvoid test();
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > main.c << 'fubar'
X#include "test.h"
Xmain()
X{
X	test();
X	exit(0);
X}
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
Xcook -nl > /dev/null 2>&1
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.ok << 'fubar'
XHello, World!
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.ok << 'fubar'
Xmain.o main.d: main.c
Xtest.h
X;
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
Xdiff test.ok main.d
Xif test $? -ne 0 ; then fail; fi
X
X#
X# Only definite negatives are possible.
X# The functionality exercised by this test appears to work,
X# no other guarantees are made.
X#
Xpass
END_OF_FILE
if test 2477 -ne `wc -c <'test/00/t0048a.sh'`; then
    echo shar: \"'test/00/t0048a.sh'\" unpacked with wrong size!
fi
# end of 'test/00/t0048a.sh'
fi
if test -f 'test/00/t0050a.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test/00/t0050a.sh'\"
else
echo shar: Extracting \"'test/00/t0050a.sh'\" \(2606 characters\)
sed "s/^X//" >'test/00/t0050a.sh' <<'END_OF_FILE'
X#!/bin/sh
X#
X#	cook - file construction tool
X#	Copyright (C) 1994 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: Test the include-cooked functionality
X#
Xwork=/tmp/$$
XPAGER=cat
Xexport PAGER
Xumask 022
Xunset COOK
Xhere=`pwd`
Xif test $? -ne 0 ; then exit 1; fi
X
Xif test "$1" != "" ; then bin="$here/$1/bin"; else bin="$here/bin"; fi
X
Xfail()
X{
X	set +x
X	echo 'FAILED test of the include-cooked functionality' 1>&2
X	cd $here
X	rm -rf $work
X	exit 1
X}
Xpass()
X{
X	set +x
X	cd $here
X	rm -rf $work
X	exit 0
X}
Xtrap \"fail\" 1 2 3 15
X
Xmkdir $work
Xif test $? -ne 0 ; then exit 1; fi
Xcd $work
Xif test $? -ne 0 ; then fail; fi
X
XPATH=${bin}:${PATH}
Xexport PATH
X
X#
X# use clever C include dependencies
X#
Xcat > Howto.cook << 'fubar'
X
Xobj = [fromto %.c %.o [glob *.c]];
X
Xtest.out: test
X{
X	./test > test.out;
X}
X
X%.o: %.c
X{
X	cc -c %.c;
X}
X
X%.d: %.c
X{
X	c_incl -nc -ns -eia %.c -prefix "'%.o %.d: %.c'" -suffix "';'" > %.d;
X}
X
X#include-cooked [fromto %.o %.d [obj]]
X
Xtest: [obj]
X{
X	cc -o test [obj];
X}
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.c << 'fubar'
X#include "guts.h"
Xtest()
X{
X	printf("%s\n", GUTS);
X}
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.h << 'fubar'
Xvoid test();
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > guts.h << 'fubar'
X#define GUTS "wrong"
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > main.c << 'fubar'
X#include "test.h"
Xmain()
X{
X	test();
X	exit(0);
X}
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
Xsleep 1
X
Xcook -nl > /dev/null 2>&1
Xif test $? -ne 0 ; then fail; fi
X
X# let the clock tick over
Xsleep 2
X
Xcat > guts.h << 'fubar'
X#define GUTS "right"
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
Xcook -nl > /dev/null 2>&1
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.ok << 'fubar'
Xright
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X
X#
X# Only definite negatives are possible.
X# The functionality exercised by this test appears to work,
X# no other guarantees are made.
X#
Xpass
END_OF_FILE
if test 2606 -ne `wc -c <'test/00/t0050a.sh'`; then
    echo shar: \"'test/00/t0050a.sh'\" unpacked with wrong size!
fi
# end of 'test/00/t0050a.sh'
fi
if test -f 'test/00/t0065a.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test/00/t0065a.sh'\"
else
echo shar: Extracting \"'test/00/t0065a.sh'\" \(3038 characters\)
sed "s/^X//" >'test/00/t0065a.sh' <<'END_OF_FILE'
X#!/bin/sh
X#
X#	cook - file construction tool
X#	Copyright (C) 1994 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: Test the make2cook functionality
X#
Xwork=/tmp/$$
XPAGER=cat
Xexport PAGER
Xumask 022
Xunset COOK
Xhere=`pwd`
Xif test $? -ne 0 ; then exit 1; fi
X
Xif test "$1" != "" ; then bin="$here/$1/bin"; else bin="$here/bin"; fi
X
Xfail()
X{
X	set +x
X	echo 'FAILED test of the make2cook functionality' 1>&2
X	cd $here
X	rm -rf $work
X	exit 1
X}
Xpass()
X{
X	set +x
X	cd $here
X	rm -rf $work
X	exit 0
X}
Xtrap \"fail\" 1 2 3 15
X
Xmkdir $work
Xif test $? -ne 0 ; then exit 1; fi
Xcd $work
Xif test $? -ne 0 ; then fail; fi
X
X#
X# make2cook
X#
Xcat > test.in << 'fubar'
X#
X# zap the suffixes
X#
X.SUFFIXES:
X.SUFFIXES: .c .o
X.PHONY: test
X
X#
X# define some variables
X#
Xa = b
Xc := d e
Xc += f
X
X#
X# this is a test
X#
Xtest:
X	-@echo Hello, World
X
X.c.o:; $(CC) $(CFLAGS) -c $*.c
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.ok << 'fubar'
Xif [not [defined CPPFLAGS]] then
X	CPPFLAGS = [getenv CPPFLAGS];
Xif [not [defined TARGET_ARCH]] then
X	TARGET_ARCH = [getenv TARGET_ARCH];
Xif [not [defined LDFLAGS]] then
X	LDFLAGS = [getenv LDFLAGS];
Xif [not [defined CFLAGS]] then
X	CFLAGS = [getenv CFLAGS];
Xif [not [defined CC]] then
X{
X	CC = [getenv CC];
X	if [not [CC]] then
X		CC = cc;
X}
Xif [not [defined LINK.c]] then
X{
X	LINK.c = [getenv LINK.c];
X	if [not [LINK.c]] then
X		LINK.c = [CC] [CFLAGS] [CPPFLAGS] [LDFLAGS] [TARGET_ARCH];
X}
Xif [not [defined LDLIBS]] then
X	LDLIBS = [getenv LDLIBS];
Xif [not [defined LOADLIBES]] then
X	LOADLIBES = [getenv LOADLIBES];
Xif [not [defined LINK.o]] then
X{
X	LINK.o = [getenv LINK.o];
X	if [not [LINK.o]] then
X		LINK.o = [CC] [LDFLAGS] [TARGET_ARCH];
X}
X
X/*
X * zap the suffixes
X */
X
X
X
X
X/*
X * define some variables
X */
Xif [not [defined a]] then
X	a = b;
Xif [not [defined c]] then
X	c = d e;
Xc = [c] f;
X
X/*
X * this is a test
X */
Xtest:
X	set force
X{
X	echo Hello, World
X		set errok silent;
X}
X%.o: %.c
X{
X	[CC] [CFLAGS] -c %.c;
X}
X
X%: %.o
X{
X	[LINK.o] [resolve [need]] [LOADLIBES] [LDLIBS] -o [target];
X}
X%: %.c
X{
X	[LINK.c] [resolve [need]] [LOADLIBES] [LDLIBS] -o [target];
X}
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
X$bin/make2cook test.in test.out
Xif test $? -ne 0 ; then fail; fi
X
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X
X#
X# Only definite negatives are possible.
X# The functionality exercised by this test appears to work,
X# no other guarantees are made.
X#
Xpass
END_OF_FILE
if test 3038 -ne `wc -c <'test/00/t0065a.sh'`; then
    echo shar: \"'test/00/t0065a.sh'\" unpacked with wrong size!
fi
# end of 'test/00/t0065a.sh'
fi
if test -f 'test/00/t0070a.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test/00/t0070a.sh'\"
else
echo shar: Extracting \"'test/00/t0070a.sh'\" \(3260 characters\)
sed "s/^X//" >'test/00/t0070a.sh' <<'END_OF_FILE'
X#!/bin/sh
X#
X#	cook - file construction tool
X#	Copyright (C) 1994 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: Test the make2cook archive functionality
X#
Xwork=/tmp/$$
XPAGER=cat
Xexport PAGER
Xumask 022
Xunset COOK
Xhere=`pwd`
Xif test $? -ne 0 ; then exit 1; fi
X
Xif test "$1" != "" ; then bin="$here/$1/bin"; else bin="$here/bin"; fi
X
Xfail()
X{
X	set +x
X	echo 'FAILED test of the make2cook archive functionality' 1>&2
X	cd $here
X	rm -rf $work
X	exit 1
X}
Xpass()
X{
X	set +x
X	cd $here
X	rm -rf $work
X	exit 0
X}
Xtrap \"fail\" 1 2 3 15
X
Xmkdir $work
Xif test $? -ne 0 ; then exit 1; fi
Xcd $work
Xif test $? -ne 0 ; then fail; fi
X
X#
X# test the make2cook archive functionality
X#
Xcat > test.in << 'fubar'
X.SUFFIXES:
X.SUFFIXES: .a .o .c
Xfoo.a: foo.a(a.o) foo.a(b.o)
X	ranlib $@
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.ok << 'fubar'
Xif [not [defined ARFLAGS]] then
X{
X	ARFLAGS = [getenv ARFLAGS];
X	if [not [ARFLAGS]] then
X		ARFLAGS = rv;
X}
Xif [not [defined AR]] then
X{
X	AR = [getenv AR];
X	if [not [AR]] then
X		AR = ar;
X}
Xif [not [defined CPPFLAGS]] then
X	CPPFLAGS = [getenv CPPFLAGS];
Xif [not [defined CFLAGS]] then
X	CFLAGS = [getenv CFLAGS];
Xif [not [defined TARGET_ARCH]] then
X	TARGET_ARCH = [getenv TARGET_ARCH];
Xif [not [defined CC]] then
X{
X	CC = [getenv CC];
X	if [not [CC]] then
X		CC = cc;
X}
Xif [not [defined COMPILE.c]] then
X{
X	COMPILE.c = [getenv COMPILE.c];
X	if [not [COMPILE.c]] then
X		COMPILE.c = [CC] [CFLAGS] [CPPFLAGS] [TARGET_ARCH] -c;
X}
Xif [not [defined LDFLAGS]] then
X	LDFLAGS = [getenv LDFLAGS];
Xif [not [defined LINK.c]] then
X{
X	LINK.c = [getenv LINK.c];
X	if [not [LINK.c]] then
X		LINK.c = [CC] [CFLAGS] [CPPFLAGS] [LDFLAGS] [TARGET_ARCH];
X}
Xif [not [defined LDLIBS]] then
X	LDLIBS = [getenv LDLIBS];
Xif [not [defined LOADLIBES]] then
X	LOADLIBES = [getenv LOADLIBES];
Xif [not [defined LINK.o]] then
X{
X	LINK.o = [getenv LINK.o];
X	if [not [LINK.o]] then
X		LINK.o = [CC] [LDFLAGS] [TARGET_ARCH];
X}
X
Xfoo.a: foo.a(a.o) foo.a(b.o)
X{
X	ranlib [target];
X}
X
X%: %.o
X{
X	[LINK.o] [resolve [need]] [LOADLIBES] [LDLIBS] -o [target];
X}
X%: %.c
X{
X	[LINK.c] [resolve [need]] [LOADLIBES] [LDLIBS] -o [target];
X}
X%.o: %.c
X{
X	[COMPILE.c] [resolve [head [need]]];
X}
X%1.a(%.o): %.o
X{
X	[AR] [ARFLAGS] %1.a [resolve [head [need]]];
X}
X%1(%): %
X{
X	[AR] [ARFLAGS] %1 [resolve [head [need]]];
X}
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
X$bin/make2cook test.in test.out
Xif test $? -ne 0 ; then fail; fi
X
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X
X#
X# Only definite negatives are possible.
X# The functionality exercised by this test appears to work,
X# no other guarantees are made.
X#
Xpass
END_OF_FILE
if test 3260 -ne `wc -c <'test/00/t0070a.sh'`; then
    echo shar: \"'test/00/t0070a.sh'\" unpacked with wrong size!
fi
# end of 'test/00/t0070a.sh'
fi
if test -f 'test/00/t0071a.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test/00/t0071a.sh'\"
else
echo shar: Extracting \"'test/00/t0071a.sh'\" \(3247 characters\)
sed "s/^X//" >'test/00/t0071a.sh' <<'END_OF_FILE'
X#!/bin/sh
X#
X#	cook - file construction tool
X#	Copyright (C) 1994 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: Test the make2cook vpath functionality
X#
Xwork=/tmp/$$
XPAGER=cat
Xexport PAGER
Xumask 022
Xunset COOK
Xhere=`pwd`
Xif test $? -ne 0 ; then exit 1; fi
X
Xif test "$1" != "" ; then bin="$here/$1/bin"; else bin="$here/bin"; fi
X
Xfail()
X{
X	set +x
X	echo 'FAILED test of the make2cook vpath functionality' 1>&2
X	cd $here
X	rm -rf $work
X	exit 1
X}
Xpass()
X{
X	set +x
X	cd $here
X	rm -rf $work
X	exit 0
X}
Xtrap \"fail\" 1 2 3 15
X
Xmkdir $work
Xif test $? -ne 0 ; then exit 1; fi
Xcd $work
Xif test $? -ne 0 ; then fail; fi
X
X#
X# test the make2cook vpath functionality
X#
Xcat > test.in << 'fubar'
XVPATH = $(SRC)/nasal:$(SRC)/mucus
Xoverride SRC = $(HOME)/src
Xvpath %.o obj:old-obj
Xvpath % other:/junk
X.SUFFIXES:
X.SUFFIXES: .o .c
Xtest: foo
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
Xsed 's/X$//' > test.ok << 'fubar'
Xif [not [defined CPPFLAGS]] thenX
X	CPPFLAGS = [getenv CPPFLAGS];X
Xif [not [defined CFLAGS]] thenX
X	CFLAGS = [getenv CFLAGS];X
Xif [not [defined TARGET_ARCH]] thenX
X	TARGET_ARCH = [getenv TARGET_ARCH];X
Xif [not [defined CC]] thenX
X{X
X	CC = [getenv CC];X
X	if [not [CC]] thenX
X		CC = cc;X
X}X
Xif [not [defined COMPILE.c]] thenX
X{X
X	COMPILE.c = [getenv COMPILE.c];X
X	if [not [COMPILE.c]] thenX
X		COMPILE.c = [CC] [CFLAGS] [CPPFLAGS] [TARGET_ARCH] -c;X
X}X
Xif [not [defined LDFLAGS]] thenX
X	LDFLAGS = [getenv LDFLAGS];X
Xif [not [defined LINK.c]] thenX
X{X
X	LINK.c = [getenv LINK.c];X
X	if [not [LINK.c]] thenX
X		LINK.c = [CC] [CFLAGS] [CPPFLAGS] [LDFLAGS] [TARGET_ARCH];X
X}X
Xif [not [defined LDLIBS]] thenX
X	LDLIBS = [getenv LDLIBS];X
Xif [not [defined LOADLIBES]] thenX
X	LOADLIBES = [getenv LOADLIBES];X
Xif [not [defined LINK.o]] thenX
X{X
X	LINK.o = [getenv LINK.o];X
X	if [not [LINK.o]] thenX
X		LINK.o = [CC] [LDFLAGS] [TARGET_ARCH];X
X}X
Xif [not [defined HOME]] thenX
X	HOME = [getenv HOME];X
X#line 2 "test.in"X
XSRC = [HOME]/src;X
XX
XX
XX
XX
Xtest: foo;X
Xsearch_list = . X
X#line 3 "test.in"X
Xobj old-obj X
Xother /junk X
X#line 1 "test.in"X
X[SRC]/nasal [SRC]/mucus;X
XX
X%: %.oX
X{X
X	[LINK.o] [resolve [need]] [LOADLIBES] [LDLIBS] -o [target];X
X}X
X%: %.cX
X{X
X	[LINK.c] [resolve [need]] [LOADLIBES] [LDLIBS] -o [target];X
X}X
X%.o: %.cX
X{X
X	[COMPILE.c] [resolve [head [need]]];X
X}X
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
X$bin/make2cook test.in test.out -ln
Xif test $? -ne 0 ; then fail; fi
X
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X
X#
X# Only definite negatives are possible.
X# The functionality exercised by this test appears to work,
X# no other guarantees are made.
X#
Xpass
END_OF_FILE
if test 3247 -ne `wc -c <'test/00/t0071a.sh'`; then
    echo shar: \"'test/00/t0071a.sh'\" unpacked with wrong size!
fi
# end of 'test/00/t0071a.sh'
fi
if test -f 'test/00/t0077a.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test/00/t0077a.sh'\"
else
echo shar: Extracting \"'test/00/t0077a.sh'\" \(2618 characters\)
sed "s/^X//" >'test/00/t0077a.sh' <<'END_OF_FILE'
X#!/bin/sh
X#
X#	cook - file construction tool
X#	Copyright (C) 1994 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: Test the archive long name functionality
X#
Xwork=/tmp/$$
XPAGER=cat
Xexport PAGER
Xumask 022
Xunset COOK
Xhere=`pwd`
Xif test $? -ne 0 ; then exit 1; fi
X
Xif test "$1" != "" ; then bin="$here/$1/bin"; else bin="$here/bin"; fi
X
Xfail()
X{
X	set +x
X	echo 'FAILED test of the archive long name functionality' 1>&2
X	cd $here
X	rm -rf $work
X	exit 1
X}
Xpass()
X{
X	set +x
X	cd $here
X	rm -rf $work
X	exit 0
X}
Xtrap \"fail\" 1 2 3 15
X
Xmkdir $work
Xif test $? -ne 0 ; then exit 1; fi
Xcd $work
Xif test $? -ne 0 ; then fail; fi
X
X#
X# make sure this system understands the standard
X# text-based archive format
X#
Xar qc foo.a /dev/null
Xif test $? -ne 0 ; then fail; fi
Xsed '2,$d' < foo.a > foo.aa
Xif test $? -ne 0 ; then fail; fi
Xcat > foo.ok << 'fubar'
X!<arch>
Xfubar
Xif test $? -ne 0 ; then fail; fi
Xcmp foo.ok foo.aa
Xif test $? -ne 0 ; then
X	echo ""
X	echo "	This system does not understand the standard text-based"
X	echo "	archive file format.  This test passes by default."
X	echo ""
X	pass
Xfi
X
X#
X# test the archive long name functionality
X#
Xcat > Howto.cook << 'fubar'
Xtest: a(b) {}
X
X%1(%2): %2
X{
X	if [exists %1] then
X	{
X		echo "This should never happen."
X			set silent;
X		fail;
X	}
X	ar qc %1 %2;
X}
X
Xb:
X{
X	echo "This is a small file." > b;
X}
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
X$bin/cook -nl -silent
Xif test $? -ne 0 ; then fail; fi
X
X#
X# now mess with the archive to add a name index
X# and cook again - everything should be up-to-date
X#
Xcat > script << 'fubar'
X2t2
X2a
Xb
X.
X2s/^b./\/\//
X2s/22        /2         /
X4s/^b./\/0/
Xw
Xq
Xfubar
Xif test $? -ne 0 ; then fail; fi
Xed a < script > script.out 2>&1
Xif test $? -ne 0 ; then cat script.out; fail; fi
X
X$bin/cook -nl -silent
Xif test $? -ne 0 ; then fail; fi
X
X#
X# Only definite negatives are possible.
X# The functionality exercised by this test appears to work,
X# no other guarantees are made.
X#
Xpass
END_OF_FILE
if test 2618 -ne `wc -c <'test/00/t0077a.sh'`; then
    echo shar: \"'test/00/t0077a.sh'\" unpacked with wrong size!
fi
# end of 'test/00/t0077a.sh'
fi
if test -f 'txt2c/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'txt2c/main.c'\"
else
echo shar: Extracting \"'txt2c/main.c'\" \(2539 characters\)
sed "s/^X//" >'txt2c/main.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: operating system start-up point
X */
X
X#include <stdio.h>
X#include <ac/stdlib.h>
X
X#include <arglex.h>
X#include <error.h>
X#include <str.h>
X#include <trace.h>
X#include <txt2c.h>
X#include <version-stmp.h>
X
X
Xstatic void usage _((void));
X
Xstatic void
Xusage()
X{
X	fprintf
X	(
X		stderr,
X		"usage: %s [ <infile> [ <outfile> ]]\n",
X		progname
X	);
X	exit(1);
X}
X
X
Xstatic arglex_table_ty argtab[] =
X{
X	{ 0, (arglex_token_ty)0, }, /* end marker */
X};
X
X
Xint main _((int, char **));
X
Xint
Xmain(argc, argv)
X	int	argc;
X	char	**argv;
X{
X	char	*infile;
X	char	*outfile;
X
X	str_initialize();
X	arglex_init(argc, argv, argtab);
X	infile = 0;
X	outfile = 0;
X	arglex();
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch (arglex_token)
X		{
X		default:
X			error
X			(
X				"misplaced \"%s\" command line argument",
X				arglex_value.alv_string
X			);
X			usage();
X
X		case arglex_token_help:
X			fatal
X			(
X"This command is for constructing cook, it is not for general use.  \
XThe -Help option is therefore not supported for this command."
X			);
X
X		case arglex_token_string:
X			if (!infile)
X				infile = arglex_value.alv_string;
X			else if (!outfile)
X				outfile = arglex_value.alv_string;
X			else
X				fatal("too many file names specified");
X			break;
X
X		case arglex_token_stdio:
X			if (!infile)
X				infile = "";
X			else if (!outfile)
X				outfile = "";
X			else
X				fatal("too many file names specified");
X			break;
X
X#ifdef DEBUG
X		case arglex_token_tracing:
X			while (arglex() == arglex_token_string)
X				trace_enable(arglex_value.alv_string);
X			continue;
X#endif
X		}
X		arglex();
X	}
X	if (infile && !*infile)
X		infile = 0;
X	if (outfile && !*outfile)
X		outfile = 0;
X
X	txt2c(infile, outfile);
X	exit(0);
X	return 0;
X}
X
X
Xchar *
Xversion_stamp()
X{
X	return "!#$@&*!";
X}
END_OF_FILE
if test 2539 -ne `wc -c <'txt2c/main.c'`; then
    echo shar: \"'txt2c/main.c'\" unpacked with wrong size!
fi
# end of 'txt2c/main.c'
fi
echo shar: End of archive 6 \(of 19\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 19 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
