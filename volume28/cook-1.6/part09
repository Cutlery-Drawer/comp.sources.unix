Newsgroups: comp.sources.unix
From: pmiller@bmr.gov.au (Peter Miller)
Subject: v28i102: cook - a file construction tool, V1.6, Part09/19
References: <1.775008949.28543@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: pmiller@bmr.gov.au (Peter Miller)
Posting-Number: Volume 28, Issue 102
Archive-Name: cook-1.6/part09

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 9 (of 19)."
# Contents:  c_incl/main.c common/symtab.c common/trace.c
#   cook/builtin/cook.c cook/builtin/glob.c cook/stat.cache.c
#   doc/cmdline.so doc/how.so make2cook/stmt/assign.c
#   make2cook/variable.c roffpp/preprocess.c
# Wrapped by vixie@gw.home.vix.com on Sat Jul 23 17:11:24 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'c_incl/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'c_incl/main.c'\"
else
echo shar: Extracting \"'c_incl/main.c'\" \(7807 characters\)
sed "s/^X//" >'c_incl/main.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: operating system entry point, and command line argument parsing
X */
X
X#include <ac/stddef.h>
X#include <stdio.h>
X#include <ac/string.h>
X#include <ac/stdlib.h>
X
X#include <arglex.h>
X#include <cache.h>
X#include <error.h>
X#include <help.h>
X#include <main.h>
X#include <sniff.h>
X#include <str.h>
X#include <trace.h>
X#include <version.h>
X
X
Xstatic void usage _((void));
X
Xstatic void
Xusage()
X{
X	fprintf(stderr, "usage: %s [ <option>... ] <filename>\n", progname);
X	fprintf(stderr, "       %s -Help\n", progname);
X	fprintf(stderr, "       %s -VERsion\n", progname);
X	exit(1);
X}
X
X
Xstatic void c_incl_help _((void));
X
Xstatic void
Xc_incl_help()
X{
X	static char *text[] =
X	{
X#include <../man1/c_incl.h>
X	};
X
X	trace(("c_incl_help()\n{\n"/*}*/));
X	help(text, SIZEOF(text), usage);
X	trace((/*{*/"}\n"));
X}
X
X
Xenum
X{
X	arglex_token_absent_local_error,
X	arglex_token_absent_local_ignore,
X	arglex_token_absent_local_mention,
X	arglex_token_absent_program_error,
X	arglex_token_absent_program_ignore,
X	arglex_token_absent_system_error,
X	arglex_token_absent_system_ignore,
X	arglex_token_absent_system_mention,
X	arglex_token_include,
X	arglex_token_no_cache,
X	arglex_token_no_system,
X	arglex_token_lang_c,
X	arglex_token_lang_roff,
X	arglex_token_prefix,
X	arglex_token_suffix,
X	arglex_token_verbose
X};
X
Xstatic	arglex_table_ty	argtab[] =
X{
X	{
X		"-Absent",
X		(arglex_token_ty)arglex_token_absent_local_ignore,
X	},
X	{
X		"-Absent_Local_Error",
X		(arglex_token_ty)arglex_token_absent_local_error,
X	},
X	{
X		"-Absent_Local_Ignore",
X		(arglex_token_ty)arglex_token_absent_local_ignore,
X	},
X	{
X		"-Absent_Local_Mention",
X		(arglex_token_ty)arglex_token_absent_local_mention,
X	},
X	{
X		"-Absent_Program_Error",
X		(arglex_token_ty)arglex_token_absent_program_error,
X	},
X	{
X		"-Absent_Program_Ignore",
X		(arglex_token_ty)arglex_token_absent_program_ignore,
X	},
X	{
X		"-Absent_System_Error",
X		(arglex_token_ty)arglex_token_absent_system_error,
X	},
X	{
X		"-Absent_System_Ignore",
X		(arglex_token_ty)arglex_token_absent_system_ignore,
X	},
X	{
X		"-Absent_System_Mention",
X		(arglex_token_ty)arglex_token_absent_system_mention,
X	},
X	{
X		"-C",
X		(arglex_token_ty)arglex_token_lang_c,
X	},
X	{
X		"-Empty_If_Absent",
X		(arglex_token_ty)arglex_token_absent_program_ignore,
X	},
X	{
X		"-\\I*",
X		(arglex_token_ty)arglex_token_include,
X	},
X	{
X		"-Include",
X		(arglex_token_ty)arglex_token_include,
X	},
X	{
X		"-No_Cache",
X		(arglex_token_ty)arglex_token_no_cache,
X	},
X	{
X		"-No_System",
X		(arglex_token_ty)arglex_token_no_system,
X	},
X	{
X		"-PREfix",
X		(arglex_token_ty)arglex_token_prefix,
X	},
X	{
X		"-Roff",
X		(arglex_token_ty)arglex_token_lang_roff,
X	},
X	{
X		"-System_absent",
X		(arglex_token_ty)arglex_token_absent_system_ignore,
X	},
X	{
X		"-SUFfix",
X		(arglex_token_ty)arglex_token_suffix,
X	},
X	{
X		"-Verbose",
X		(arglex_token_ty)arglex_token_verbose,
X	},
X
X	/* end marker */
X	{ 0, (arglex_token_ty)0, },
X};
X
X
Xint main _((int, char **));
X
Xint
Xmain(argc, argv)
X	int		argc;
X	char		**argv;
X{
X	char		*source;
X	int		no_system;
X	int		no_cache;
X	sniff_ty	*language;
X
X	arglex_init(argc, argv, argtab);
X	str_initialize();
X	cache_initialize();
X	switch (arglex())
X	{
X	case arglex_token_help:
X		c_incl_help();
X		exit(0);
X
X	case arglex_token_version:
X		version();
X		exit(0);
X
X	default:
X		break;
X	}
X
X	source = 0;
X	no_system = 0;
X	no_cache = 0;
X	language = 0;
X	option.o_absent_local = -1;
X	option.o_absent_system = -1;
X	option.o_absent_program = -1;
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch(arglex_token)
X		{
X		default:
X			error
X			(
X				"misplaced \"%s\" command line argument",
X				arglex_value.alv_string
X			);
X			usage();
X
X		case arglex_token_string:
X			if (source)
X				fatal("too many filenames specified");
X			source = arglex_value.alv_string;
X			break;
X
X		case arglex_token_verbose:
X			if (option.o_verbose)
X			{
X				duplicate:
X				fatal
X				(
X					"duplicate \"%s\" option",
X					arglex_value.alv_string
X				);
X			}
X			++option.o_verbose;
X			break;
X
X		case arglex_token_absent_local_ignore:
X			if (option.o_absent_local != -1)
X				goto duplicate;
X			option.o_absent_local = absent_ignore;
X			break;
X
X		case arglex_token_absent_local_mention:
X			if (option.o_absent_local != -1)
X				goto duplicate;
X			option.o_absent_local = absent_mention;
X			break;
X
X		case arglex_token_absent_local_error:
X			if (option.o_absent_local != -1)
X				goto duplicate;
X			option.o_absent_local = absent_error;
X			break;
X
X		case arglex_token_absent_system_ignore:
X			if (option.o_absent_system != -1)
X				goto duplicate;
X			option.o_absent_system = absent_ignore;
X			break;
X
X		case arglex_token_absent_system_mention:
X			if (option.o_absent_system != -1)
X				goto duplicate;
X			option.o_absent_system = absent_mention;
X			break;
X
X		case arglex_token_absent_system_error:
X			if (option.o_absent_system != -1)
X				goto duplicate;
X			option.o_absent_system = absent_error;
X			break;
X
X		case arglex_token_absent_program_ignore:
X			if (option.o_absent_program != -1)
X				goto duplicate;
X			option.o_absent_program = absent_ignore;
X			break;
X
X		case arglex_token_absent_program_error:
X			if (option.o_absent_program != -1)
X				goto duplicate;
X			option.o_absent_program = absent_error;
X			break;
X
X		case arglex_token_include:
X			if (arglex() != arglex_token_string)
X				fatal("-Include requires a string argument");
X			sniff_include(arglex_value.alv_string);
X			break;
X
X		case arglex_token_no_system:
X			if (no_system)
X				goto duplicate;
X			no_system++;
X			break;
X
X		case arglex_token_no_cache:
X			if (no_cache)
X				goto duplicate;
X			no_cache++;
X			break;
X
X		case arglex_token_lang_c:
X			if (language)
X				goto duplicate;
X			language = &lang_c;
X			break;
X
X		case arglex_token_lang_roff:
X			if (language)
X				goto duplicate;
X			language = &lang_roff;
X			break;
X		
X		case arglex_token_prefix:
X			if (prefix)
X				goto duplicate;
X			if (arglex() != arglex_token_string)
X				usage();
X			prefix = arglex_value.alv_string;
X			break;
X		
X		case arglex_token_suffix:
X			if (suffix)
X				goto duplicate;
X			if (arglex() != arglex_token_string)
X				usage();
X			suffix = arglex_value.alv_string;
X			break;
X
X#ifdef DEBUG
X		case arglex_token_tracing:
X			if (arglex() != arglex_token_string)
X				fatal("-TRACIng requires one or more string arguments");
X			for (;;)
X			{
X				trace_enable(arglex_value.alv_string);
X				if (arglex() != arglex_token_string)
X					break;
X			}
X			continue;
X#endif
X		}
X		arglex();
X	}
X	if (option.o_absent_local == -1)
X		option.o_absent_local = absent_mention;
X	if (option.o_absent_system == -1)
X		option.o_absent_system = absent_ignore;
X	if (option.o_absent_program == -1)
X		option.o_absent_program = absent_error;
X	if (!source)
X		fatal("no input file specified");
X
X	/*
X	 * set the language to be used
X	 */
X	if (!language)
X		language = &lang_c;
X	sniff_language(language);
X
X	/*
X	 * apply any default or suffix search rules
X	 * or anything else defined by the language
X	 */
X	if (!no_system)
X		sniff_prepare();
X
X	/*
X	 * read and analyze the file
X	 */
X	if (!no_cache)
X		cache_read();
X	sniff(source);
X	if (!no_cache)
X		cache_write();
X	exit(0);
X	return 0;
X}
END_OF_FILE
if test 7807 -ne `wc -c <'c_incl/main.c'`; then
    echo shar: \"'c_incl/main.c'\" unpacked with wrong size!
fi
# end of 'c_incl/main.c'
fi
if test -f 'common/symtab.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/symtab.c'\"
else
echo shar: Extracting \"'common/symtab.c'\" \(9431 characters\)
sed "s/^X//" >'common/symtab.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate symbol tables
X */
X
X#include <error.h>
X#include <mem.h>
X#include <symtab.h>
X#include <trace.h>
X
X
Xsymtab_ty *
Xsymtab_alloc(size)
X	int		size;
X{
X	symtab_ty	*stp;
X	str_hash_ty	j;
X
X	trace(("symtab_alloc(size = %d)\n{\n"/*}*/, size));
X	stp = mem_alloc(sizeof(symtab_ty));
X	stp->chain = 0;
X	stp->reap = 0;
X	stp->hash_modulus = 1 << 2; /* MUST be a power of 2 */
X	while (stp->hash_modulus < size)
X		stp->hash_modulus <<= 1;
X	stp->hash_cutover = stp->hash_modulus;
X	stp->hash_split = stp->hash_modulus - stp->hash_cutover;
X	stp->hash_cutover_mask = stp->hash_cutover - 1;
X	stp->hash_cutover_split_mask = (stp->hash_cutover * 2) - 1;
X	stp->hash_load = 0;
X	stp->hash_table = mem_alloc(stp->hash_modulus * sizeof(symtab_row_ty *));
X	for (j = 0; j < stp->hash_modulus; ++j)
X		stp->hash_table[j] = 0;
X	trace(("return %08lX;\n", (long)stp));
X	trace((/*{*/"}\n"));
X	return stp;
X}
X
X
Xvoid
Xsymtab_free(stp)
X	symtab_ty	*stp;
X{
X	str_hash_ty	j;
X
X	trace(("symtab_free(stp = %08lX)\n{\n"/*}*/, (long)stp));
X	for (j = 0; j < stp->hash_modulus; ++j)
X	{
X		symtab_row_ty	**rpp;
X
X		rpp = &stp->hash_table[j];
X		while (*rpp)
X		{
X			symtab_row_ty	*rp;
X
X			rp = *rpp; 
X			*rpp = rp->overflow;
X			if (stp->reap)
X				stp->reap(rp->data);
X			str_free(rp->key);
X			mem_free(rp);
X		}
X	}
X	mem_free(stp->hash_table);
X	mem_free(stp);
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	split - reduce symbol table load
X *
X * SYNOPSIS
X *	void split(symtab_ty);
X *
X * DESCRIPTION
X *	The split function is used to split symbols in the bucket indicated by
X *	the split point.  The symbols are split between that bucket and the one
X *	after the current end of the table.
X *
X * CAVEAT
X *	It is only sensable to do this when the symbol table load exceeds some
X *	reasonable threshold.  A threshold of 80% is suggested.
X */
X
Xstatic void split _((symtab_ty *));
X
Xstatic void
Xsplit(stp)
X	symtab_ty	*stp;
X{
X	symtab_row_ty	*p;
X	symtab_row_ty	**ipp;
X	symtab_row_ty	*p2;
X	str_hash_ty	index;
X
X	/*
X	 * get the list to be split across buckets 
X	 */
X	trace(("split(stp = %08lX)\n{\n"/*}*/, (long)stp));
X	p = stp->hash_table[stp->hash_split];
X	stp->hash_table[stp->hash_split] = 0;
X
X	/*
X	 * increase the modulus by one
X	 */
X	stp->hash_modulus++;
X	stp->hash_table =
X		mem_change_size
X		(
X			stp->hash_table,
X			stp->hash_modulus * sizeof(symtab_row_ty *)
X		);
X	stp->hash_table[stp->hash_modulus - 1] = 0;
X	stp->hash_split = stp->hash_modulus - stp->hash_cutover;
X	if (stp->hash_split >= stp->hash_cutover)
X	{
X		stp->hash_cutover = stp->hash_modulus;
X		stp->hash_split = 0;
X		stp->hash_cutover_mask = stp->hash_cutover - 1;
X		stp->hash_cutover_split_mask = (stp->hash_cutover * 2) - 1;
X	}
X
X	/*
X	 * now redistribute the list elements
X	 *
X	 * It is important to preserve the order of the links because
X	 * they can be push-down stacks, and to simply add them to the
X	 * head of the list will reverse the order of the stack!
X	 */
X	while (p)
X	{
X		p2 = p;
X		p = p2->overflow;
X		p2->overflow = 0;
X
X		index = p2->key->str_hash & stp->hash_cutover_mask;
X		if (index < stp->hash_split)
X		{
X			index =
X				(
X					p2->key->str_hash
X				&
X					stp->hash_cutover_split_mask
X				);
X		}
X		for
X		(
X			ipp = &stp->hash_table[index];
X			*ipp;
X			ipp = &(*ipp)->overflow
X		)
X			;
X		*ipp = p2;
X	}
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	symtab_query - search for a variable
X *
X * SYNOPSIS
X *	int symtab_query(symtab_ty *, string_ty *key);
X *
X * DESCRIPTION
X *	The symtab_query function is used to reference a variable.
X *
X * RETURNS
X *	If the variable has been defined, the function returns a non-zero value
X *	and the value is returned through the 'value' pointer.
X *	If the variable has not been defined, it returns zero,
X *	and 'value' is unaltered.
X */
X
Xvoid *
Xsymtab_query(stp, key)
X	symtab_ty	*stp;
X	string_ty	*key;
X{
X	str_hash_ty	index;
X	symtab_row_ty	*p;
X	void		*result;
X
X	trace(("symtab_query(stp = %08lX, key = \"%s\")\n{\n"/*}*/,
X		(long)stp, key->str_text));
X	result = 0;
X	while (stp)
X	{
X		index = key->str_hash & stp->hash_cutover_mask;
X		if (index < stp->hash_split)
X			index = key->str_hash & stp->hash_cutover_split_mask;
X		for (p = stp->hash_table[index]; p; p = p->overflow)
X		{
X			if (str_equal(key, p->key))
X			{
X				result = p->data;
X				goto done;
X			}
X		}
X		stp = stp->chain;
X	}
X	done:
X	trace(("return %08lX;\n", (long)result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	symtab_assign - assign a variable
X *
X * SYNOPSIS
X *	void symtab_assign(symtab_ty *, string_ty *key, void *data);
X *
X * DESCRIPTION
X *	The symtab_assign function is used to assign
X *	a value to a given variable.
X *
X * CAVEAT
X *	The name is copied, the data is not.
X */
X
Xvoid
Xsymtab_assign(stp, key, data)
X	symtab_ty	*stp;
X	string_ty	*key;
X	void		*data;
X{
X	str_hash_ty	index;
X	symtab_row_ty	*p;
X
X	trace(("symtab_assign(stp = %08lX, key = \"%s\", data = %08lX)\n\
X{\n"/*}*/, (long)stp, key->str_text, (long)data));
X	index = key->str_hash & stp->hash_cutover_mask;
X	if (index < stp->hash_split)
X		index = key->str_hash & stp->hash_cutover_split_mask;
X
X	for (p = stp->hash_table[index]; p; p = p->overflow)
X	{
X		if (str_equal(key, p->key))
X		{
X			trace(("modify existing entry\n"));
X			if (stp->reap)
X				stp->reap(p->data);
X			p->data = data;
X			goto done;
X		}
X	}
X
X	trace(("new entry\n"));
X	p = mem_alloc(sizeof(symtab_row_ty));
X	p->key = str_copy(key);
X	p->overflow = stp->hash_table[index];
X	p->data = data;
X	stp->hash_table[index] = p;
X
X	stp->hash_load++;
X	while (stp->hash_load * 10 >= stp->hash_modulus * 8)
X		split(stp);
X	done:
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	symtab_assign_push - assign a variable
X *
X * SYNOPSIS
X *	void symtab_assign_push(symtab_ty *, string_ty *key, void *data);
X *
X * DESCRIPTION
X *	The symtab_assign function is used to assign
X *	a value to a given variable.
X *	Any previous value will be obscured until this one
X *	is deleted with symtab_delete.
X *
X * CAVEAT
X *	The name is copied, the data is not.
X */
X
Xvoid
Xsymtab_assign_push(stp, key, data)
X	symtab_ty	*stp;
X	string_ty	*key;
X	void		*data;
X{
X	str_hash_ty	index;
X	symtab_row_ty	*p;
X
X	trace(("symtab_assign_push(stp = %08lX, key = \"%s\", data = %08lX)\n\
X{\n"/*}*/, (long)stp, key->str_text, (long)data));
X	index = key->str_hash & stp->hash_cutover_mask;
X	if (index < stp->hash_split)
X		index = key->str_hash & stp->hash_cutover_split_mask;
X
X	p = mem_alloc(sizeof(symtab_row_ty));
X	p->key = str_copy(key);
X	p->overflow = stp->hash_table[index];
X	p->data = data;
X	stp->hash_table[index] = p;
X
X	stp->hash_load++;
X	while (stp->hash_load * 10 >= stp->hash_modulus * 8)
X		split(stp);
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	symtab_delete - delete a variable
X *
X * SYNOPSIS
X *	void symtab_delete(string_ty *name, symtab_class_ty class);
X *
X * DESCRIPTION
X *	The symtab_delete function is used to delete variables.
X *
X * CAVEAT
X *	The name is freed, the data is reaped.
X *	(By default, reap does nothing.)
X */
X
Xvoid
Xsymtab_delete(stp, key)
X	symtab_ty	*stp;
X	string_ty	*key;
X{
X	str_hash_ty	index;
X	symtab_row_ty	**pp;
X
X	trace(("symtab_delete(stp = %08lX, key = \"%s\")\n{\n"/*}*/,
X		(long)stp, key->str_text));
X	index = key->str_hash & stp->hash_cutover_mask;
X	if (index < stp->hash_split)
X		index = key->str_hash & stp->hash_cutover_split_mask;
X
X	pp = &stp->hash_table[index];
X	for (;;)
X	{
X		symtab_row_ty	*p;
X
X		p = *pp;
X		if (!p)
X			break;
X		if (str_equal(key, p->key))
X		{
X			if (stp->reap)
X				stp->reap(p->data);
X			str_free(p->key);
X			*pp = p->overflow;
X			mem_free(p);
X			stp->hash_load--;
X			break;
X		}
X		pp = &p->overflow;
X	}
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	symtab_dump - dump symbol table
X *
X * SYNOPSIS
X *	void symtab_dump(symtab_ty *stp, char *caption);
X *
X * DESCRIPTION
X *	The symtab_dump function is used to dump the contents of the
X *	symbol table.  The caption will be used to indicate why the
X *	symbol table was dumped.
X *
X * CAVEAT
X *	This function is only available when symbol DEBUG is defined.
X */
X
X#ifdef DEBUG
X
Xvoid
Xsymtab_dump(stp, caption)
X	symtab_ty	*stp;
X	char		*caption;
X{
X	int		j;
X	symtab_row_ty	*p;
X
X	error("symbol table %s = {", caption);
X	for (j = 0; j < stp->hash_modulus; ++j)
X	{
X		for (p = stp->hash_table[j]; p; p = p->overflow)
X		{
X			error
X			(
X				"key = \"%s\", data = %08lX",
X				p->key->str_text,
X				(long)p->data
X			);
X		}
X	}
X	error("}");
X}
X
X#endif
X
X
Xvoid
Xsymtab_walk(stp, func, arg)
X	symtab_ty	*stp;
X	void		(*func)_((symtab_ty *, string_ty *, void *, void *));
X	void		*arg;
X{
X	long		j;
X	symtab_row_ty	*rp;
X
X	trace(("symtab_walk(stp = %08lX)\n{\n"/*}*/, (long)stp));
X	for (j = 0; j < stp->hash_modulus; ++j)
X		for (rp = stp->hash_table[j]; rp; rp = rp->overflow)
X			func(stp, rp->key, rp->data, arg);
X	trace((/*{*/"}\n"));
X}
END_OF_FILE
if test 9431 -ne `wc -c <'common/symtab.c'`; then
    echo shar: \"'common/symtab.c'\" unpacked with wrong size!
fi
# end of 'common/symtab.c'
fi
if test -f 'common/trace.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/trace.c'\"
else
echo shar: Extracting \"'common/trace.c'\" \(7573 characters\)
sed "s/^X//" >'common/trace.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to report execution traces
X */
X
X#include <ac/stddef.h>
X#include <stdio.h>
X#include <ac/string.h>
X
X#include <error.h>
X#include <mem.h>
X#include <arglex.h>
X#include <s-v-arg.h>
X#include <str.h>
X#include <trace.h>
X
X
X#define INDENT 2
X#define PAGE_WIDTH 79
X
Xtypedef struct known_ty known_ty;
Xstruct known_ty
X{
X	string_ty	*filename;
X	int		flag;
X	int		*flag_p;
X	known_ty	*next;
X};
X
Xstatic	string_ty	*file_name;
Xstatic	int		line_number;
Xstatic	int		page_width;
Xstatic	known_ty	*known;
X
X
Xstatic string_ty *basename _((char *));
X
Xstatic string_ty *
Xbasename(file)
X	char		*file;
X{
X	char		*cp1;
X	char		*cp2;
X
X	cp1 = strrchr(file, '/');
X	if (cp1)
X		++cp1;
X	else
X		cp1 = file;
X	cp2 = strrchr(cp1, '.');
X	if (!cp2)
X		cp2 = cp1 + strlen(cp1);
X	if (cp2 > cp1 + 6)
X		return str_n_from_c(cp1, 6);
X	return str_n_from_c(cp1, cp2 - cp1);
X}
X
X
Xint
Xtrace_pretest(file, result)
X	char		*file;
X	int		*result;
X{
X	string_ty	*s;
X	known_ty	*kp;
X
X	s = basename(file);
X	for (kp = known; kp; kp = kp->next)
X	{
X		if (str_equal(s, kp->filename))
X		{
X			str_free(s);
X			break;
X		}
X	}
X	if (!kp)
X	{
X		kp = (known_ty *)mem_alloc(sizeof(known_ty));
X		kp->filename = s;
X		kp->next = known;
X		kp->flag = 2; /* disabled */
X		known = kp;
X	}
X	kp->flag_p = result;
X	*result = kp->flag;
X	return *result;
X}
X
X
Xvoid
Xtrace_where(file, line)
X	char		*file;
X	int		line;
X{
X	string_ty	*s;
X
X	/*
X	 * take new name fist, because will probably be same as last
X	 * thus saving a free and a malloc (which are slow)
X	 */
X	s = basename(file);
X	if (file_name)
X		str_free(file_name);
X	file_name = s;
X	line_number = line;
X}
X
X
Xstatic void trace_putchar _((int));
X
Xstatic void
Xtrace_putchar(c)
X	int		c;
X{
X	static int	depth;
X	static char	buffer[PAGE_WIDTH + 2];
X	static char	*cp;
X	static int	in_col;
X	static int	out_col;
X
X	if (!page_width)
X	{
X		page_width = PAGE_WIDTH - 24;
X		if (page_width < 8)
X			page_width = 8;
X	}
X	if (!cp)
X	{
X		strcpy(buffer, progname);
X		cp = buffer + strlen(buffer);
X		if (cp > buffer + 6)
X			cp = buffer + 6;
X		*cp++ = ':';
X		*cp++ = '\t';
X		strcpy(cp, file_name->str_text);
X		cp += file_name->str_length;
X		*cp++ = ':';
X		*cp++ = '\t';
X		sprintf(cp, "%d:\t", line_number);
X		cp += strlen(cp);
X		in_col = 0;
X		out_col = 0;
X	}
X	switch (c)
X	{
X	case '\n':
X		*cp++ = '\n';
X		*cp = 0;
X		fflush(stdout);
X		fputs(buffer, stderr);
X		fflush(stderr);
X		if (ferror(stderr))
X			nfatal("(stderr)");
X		cp = 0;
X		break;
X
X	case ' ':
X		if (out_col)
X			++in_col;
X		break;
X
X	case '\t':
X		if (out_col)
X			in_col = (in_col/INDENT + 1) * INDENT;
X		break;
X
X	case /*{*/'}':
X	case /*(*/')':
X	case /*[*/']':
X		if (depth > 0)
X		--depth;
X		/* fall through */
X
X	default:
X		if (!out_col)
X		{
X			if (c != '#')
X				/* modulo so never too long */
X				in_col = (INDENT * depth) % page_width;
X			else
X				in_col = 0;
X		}
X		if (in_col >= page_width)
X		{
X			trace_putchar('\n');
X			trace_putchar(c);
X			return;
X		}
X		while (((out_col + 8) & -8) <= in_col && out_col + 1 < in_col)
X		{
X			*cp++ = '\t';
X			out_col = (out_col + 8) & -8;
X		}
X		while (out_col < in_col)
X		{
X			*cp++ = ' ';
X			++out_col;
X		}
X		if (c == '{'/*}*/ || c == '('/*)*/ || c == '['/*]*/)
X			++depth;
X		*cp++ = c;
X		in_col++;
X		out_col++;
X		break;
X	}
X}
X
X
Xvoid
Xtrace_printf(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	string_ty	*buffer;
X	va_list		ap;
X
X	sva_init(ap, s);
X	buffer = str_vformat(s, ap);
X	va_end(ap);
X	for (s = buffer->str_text; *s; ++s)
X		trace_putchar(*s);
X	str_free(buffer);
X}
X
X
Xvoid
Xtrace_enable(file)
X	char		*file;
X{
X	string_ty	*s;
X	known_ty	*kp;
X
X	s = basename(file);
X	for (kp = known; kp; kp = kp->next)
X	{
X		if (str_equal(s, kp->filename))
X		{
X			str_free(s);
X			break;
X		}
X	}
X	if (!kp)
X	{
X		kp = (known_ty *)mem_alloc(sizeof(known_ty));
X		kp->filename = s;
X		kp->flag_p = 0;
X		kp->next = known;
X		known = kp;
X	}
X	kp->flag = 3; /* enabled */
X	if (kp->flag_p)
X		*kp->flag_p = kp->flag;
X}
X
X
Xvoid
Xtrace_char_real(name, vp)
X	char		*name;
X	char		*vp;
X{
X	trace_printf("%s = '", name);
X	if (*vp < ' ' || *vp > '~' || strchr("(){}[]", *vp))
X	{
X		char	*s;
X
X		s = strchr("\bb\nn\tt\rr\ff", *vp);
X		if (s)
X		{
X			trace_putchar('\\');
X			trace_putchar(s[1]);
X		}
X		else
X			trace_printf("\\%03o", (unsigned char)*vp);
X	}
X	else
X	{
X		if (strchr("'\\", *vp))
X			trace_putchar('\\');
X		trace_putchar(*vp);
X	}
X	trace_printf("'; /* 0x%02X, %d */\n", (unsigned char)*vp, *vp);
X}
X
X
Xvoid
Xtrace_char_unsigned_real(name, vp)
X	char		*name;
X	unsigned char	*vp;
X{
X	trace_printf("%s = '", name);
X	if (*vp < ' ' || *vp > '~' || strchr("(){}[]", *vp))
X	{
X		char	*s;
X
X		s = strchr("\bb\nn\tt\rr\ff", *vp);
X		if (s)
X		{
X			trace_putchar('\\');
X			trace_putchar(s[1]);
X		}
X		else
X			trace_printf("\\%03o", *vp);
X	}
X	else
X	{
X		if (strchr("'\\", *vp))
X			trace_putchar('\\');
X		trace_putchar(*vp);
X	}
X	trace_printf("'; /* 0x%02X, %d */\n", *vp, *vp);
X}
X
X
Xvoid
Xtrace_int_real(name, vp)
X	char		*name;
X	int		*vp;
X{
X	trace_printf("%s = %d;\n", name, *vp);
X}
X
X
Xvoid
Xtrace_int_unsigned_real(name, vp)
X	char		*name;
X	unsigned int	*vp;
X{
X	trace_printf("%s = %u;\n", name, *vp);
X}
X
X
Xvoid
Xtrace_long_real(name, vp)
X	char		*name;
X	long		*vp;
X{
X	trace_printf("%s = %ld;\n", name, *vp);
X}
X
X
Xvoid
Xtrace_long_unsigned_real(name, vp)
X	char		*name;
X	unsigned long	*vp;
X{
X	trace_printf("%s = %lu;\n", name, *vp);
X}
X
X
Xvoid
Xtrace_pointer_real(name, vptrptr)
X	char		*name;
X	void		*vptrptr;
X{
X	void		**ptr_ptr = vptrptr;
X	void		*ptr;
X
X	ptr = *ptr_ptr;
X	if (!ptr)
X		trace_printf("%s = NULL;\n", name);
X	else
X		trace_printf("%s = 0x%08lX;\n", name, ptr);
X}
X
X
Xvoid
Xtrace_short_real(name, vp)
X	char		*name;
X	short		*vp;
X{
X	trace_printf("%s = %hd;\n", name, *vp);
X}
X
X
Xvoid
Xtrace_short_unsigned_real(name, vp)
X	char		*name;
X	unsigned short	*vp;
X{
X	trace_printf("%s = %hu;\n", name, *vp);
X}
X
X
Xvoid
Xtrace_string_real(name, vp)
X	char		*name;
X	char		*vp;
X{
X	char		*s;
X	long		count;
X
X	trace_printf("%s = ", name);
X	if (!vp)
X	{
X		trace_printf("NULL;\n");
X		return;
X	}
X	trace_printf("\"");
X	count = 0;
X	for (s = vp; *s; ++s)
X	{
X		switch (*s)
X		{
X		case '('/*)*/:
X		case '['/*]*/:
X		case '{'/*}*/:
X			++count;
X			break;
X
X		case /*(*/')':
X		case /*[*/']':
X		case /*{*/'}':
X			--count;
X			break;
X		}
X	}
X	if (count > 0)
X		count = -count;
X	else
X		count = 0;
X	for (s = vp; *s; ++s)
X	{
X		int	c;
X
X		c = *s;
X		if (c < ' ' || c > '~')
X		{
X			char	*cp;
X
X			cp = strchr("\bb\ff\nn\rr\tt", c);
X			if (cp)
X				trace_printf("\\%c", cp[1]);
X			else
X			{
X				escape:
X				trace_printf("\\%03o", (unsigned char)c);
X			}
X		}
X		else
X		{
X			switch (c)
X			{
X			case '('/*)*/:
X			case '['/*]*/:
X			case '{'/*}*/:
X				++count;
X				if (count <= 0)
X					goto escape;
X				break;
X	
X			case /*(*/')':
X			case /*[*/']':
X			case /*{*/'}':
X				--count;
X				if (count < 0)
X					goto escape;
X				break;
X
X			case '\\':
X			case '"':
X				trace_printf("\\");
X				break;
X			}
X			trace_printf("%c", c);
X		}
X	}
X	trace_printf("\";\n");
X}
END_OF_FILE
if test 7573 -ne `wc -c <'common/trace.c'`; then
    echo shar: \"'common/trace.c'\" unpacked with wrong size!
fi
# end of 'common/trace.c'
fi
if test -f 'cook/builtin/cook.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/builtin/cook.c'\"
else
echo shar: Extracting \"'cook/builtin/cook.c'\" \(7686 characters\)
sed "s/^X//" >'cook/builtin/cook.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to implement the builtin functions
X *
X * The builtin function all append their results to the supplied
X * `result' word list.  The first word of the `args' word list
X * is the name of the function.
X *
X * all of the functions return 0 in success, or -1 on error.
X *
X * Only a limited set of this are candidates for builtin functions,
X * these are 
X *	- string manipulation [dirname, stringset, ect ]
X *	- environment manipulation [getenv(3), etc]
X *	- stat(3) related functions [exists, mtime, pathname, etc]
X *	- launching OS commands [execute, collect]
X * The above list is though to be exhaustive.
X *
X * This explicitly and forever excluded from being a builtin function
X * is anything which known or understands the format of some secific 
X * class of files.
X *
X * Access to stdio(3) has been thought of, and explicitly avoided.
X * Mostly because a specialist program used through [collect]
X * will almost always be far faster.
X */
X
X#include <ac/stdlib.h>
X
X#include <builtin/cook.h>
X#include <cook.h>
X#include <error.h>
X#include <expr.h>
X
X
X/*
X * NAME
X *	builtin_mtime - file last modified time
X *
X * SYNOPSIS
X *	int builtin_mtime(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	Defined is a built-in function of cook, described as follows:
X *	This function requires a single argument,
X *	the name of a file of which to get the last modified time.
X *
X * RETURNS
X *	It returns a string containing the last modified time
X *	(suitable for comparing with others) of the named file,
X *	and "" (false) if the files does not exist
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_mtime(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	if (args->wl_nwords < 2)
X	{
X		expr_error
X		(
X			"%s: requires one or more arguments",
X			args->wl_word[0]->str_text
X		);
X		return -1;
X	}
X	for (j = 1; j < args->wl_nwords; j++)
X	{
X		time_t		mtime;
X		long		depth;
X
X		mtime = cook_mtime_newest(args->wl_word[j], &depth);
X		if (mtime < 0)
X			return -1;
X		if (mtime == 0)
X			wl_append(result, str_false);
X		else
X		{
X			struct tm	*tm;
X			string_ty	*s;
X
X			tm = localtime(&mtime);
X			s =
X				str_format
X				(
X					"%02d%02d%02d%02d%02d%02d",
X					tm->tm_year,
X					tm->tm_mon+1,
X					tm->tm_mday,
X					tm->tm_hour,
X					tm->tm_min,
X					tm->tm_sec
X				);
X			wl_append(result, s);
X			str_free(s);
X		}
X	}
X	return 0;
X}
X
X
X/*
X * NAME
X *	builtin_resolve - resolve search path
X *
X * SYNOPSIS
X *	int builtin_resolve(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	The resolve function is a built-in of cook, described as follows:
X *	This builtin function is used to resolve file names when using
X *	the search_list variable to locate files.  This builtin
X *	function produces resolved file names as output.  This is
X *	useful when taking partial copies of a source to perform
X *	controlled updates.  The targets of recipes are always cooked
X *	into the current directory.
X *
X * RETURNS
X *	A word list containing the resolved names.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_resolve(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	return cook_mtime_resolve(result, args, 1);
X}
X
X
X/*
X * NAME
X *	builtin_sort_newest - sort the arguments
X *
X * SYNOPSIS
X *	int builtin_sort_newest(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	The sort_newest function is a built-in of cook, described as
X *	follows: sorts the arguments my their last-modified file times,
X *	youngest to oldest.
X *	This function requires zero or more arguments.
X *
X * RETURNS
X *	A sorted word list.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xstatic int cmp _((const void *, const void *));
X
Xstatic int
Xcmp(va, vb)
X	const void	*va;
X	const void	*vb;
X{
X	string_ty	*a;
X	string_ty	*b;
X	long		cmp;
X	long		da;
X	long		db;
X
X	a = *(string_ty **)va;
X	b = *(string_ty **)vb;
X	cmp = cook_mtime_newest(b, &db) - cook_mtime_newest(a, &da);
X	if (cmp == 0)
X		return 0;
X	return (cmp < 0 ? -1 : 1);
X}
X
X
Xint
Xbuiltin_sort_newest(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X	int		start;
X
X	assert(result);
X	assert(args);
X	switch (args->wl_nwords)
X	{
X	case 0:
X		assert(0);
X
X	case 1:
X		return 0;
X
X	case 2:
X		wl_append(result, args->wl_word[1]);
X		return 0;
X	}
X	start = result->wl_nwords;
X	for (j = 1; j < args->wl_nwords; ++j)
X		wl_append(result, args->wl_word[j]);
X	qsort
X	(
X		&result->wl_word[start],
X		args->wl_nwords - 1,
X		sizeof(result->wl_word[0]),
X		cmp
X	);
X	return 0;
X}
X
X
X/*
X * NAME
X *	builtin_cando - test if know how to cook given files
X *
X * SYNOPSIS
X *	int builtin_cando(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	The cando function is a built-in of cook, described as follows:
X *	returns true if all the arguments are known how to be cooked.
X *	This function requires one or more arguments.
X *
X * RETURNS
X *	A word list containing true ("1") if can do all arguments,
X *	or false ("") if one or more could not.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_cando(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X	int		ret;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	for (j = 1; j < args->wl_nwords; ++j)
X	{
X		ret = cando(args->wl_word[j]);
X		if (!ret)
X		{
X			wl_append(result, str_false);
X			return 0;
X		}
X	}
X	wl_append(result, str_true);
X	return 0;
X}
X
X
X/*
X * NAME
X *	builtin_uptodate - test if files are up to date
X *
X * SYNOPSIS
X *	int builtin_uptodate(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	The uptodate function is a built-in of cook, described as follows:
X *	returns true if all the arguments are up-to-date.
X *	Does not build them if they are not.
X *	This function requires one or more arguments.
X *
X * RETURNS
X *	A word list containing true ("1") if all arguments are up-to-date,
X *	or false ("") if one or more could not.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_uptodate(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X	int		ret;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	for (j = 1; j < args->wl_nwords; ++j)
X	{
X		ret = isit_uptodate(args->wl_word[j]);
X		if (ret < 0)
X			return -1;
X		if (!ret)
X		{
X			wl_append(result, str_false);
X			return 0;
X		}
X	}
X	wl_append(result, str_true);
X	return 0;
X}
END_OF_FILE
if test 7686 -ne `wc -c <'cook/builtin/cook.c'`; then
    echo shar: \"'cook/builtin/cook.c'\" unpacked with wrong size!
fi
# end of 'cook/builtin/cook.c'
fi
if test -f 'cook/builtin/glob.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/builtin/glob.c'\"
else
echo shar: Extracting \"'cook/builtin/glob.c'\" \(9294 characters\)
sed "s/^X//" >'cook/builtin/glob.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to perform shell-style file pattern matching
X */
X
X#include <ac/stddef.h>
X#include <string.h>
X#include <errno.h>
X#include <ac/stdlib.h>
X
X#include <ac/dirent.h>
X
X#include <builtin/glob.h>
X#include <trace.h>
X#include <mem.h>
X#include <error.h>
X
X
Xstatic	char	*original;
Xstatic	wlist	*where;
Xstatic	char	*tmp;
Xstatic	size_t	tmp_max;
Xstatic	size_t	tmp_len;
X
X
X/*
X * NAME
X *	tmp_char - append character
X *
X * SYNOPSIS
X *	void tmp_char(int c);
X *
X * DESCRIPTION
X *	The tmp_char function is used to append a character to the string being
X *	built by the builtin_glob function.
X *
X * RETURNS
X *	void
X */
X
Xstatic void tmp_char _((int));
X
Xstatic void
Xtmp_char(c)
X	int		c;
X{
X	if (tmp_len >= tmp_max)
X	{
X		tmp_max += 128;
X		tmp = mem_change_size(tmp, tmp_max);
X	}
X	tmp[tmp_len++] = c;
X}
X
X
X/*
X * NAME
X *	gmatch - match entryname pattern
X *
X * SYNOPSIS
X *	int gmatch(char *formal, char *formal_end, char *actual);
X *
X * DESCRIPTION
X *	The formal strings is used as a template to match the given actual
X *	string against.
X *
X *	The pattern elements understood are
X *	*	match zero or more of any character
X *	?	match any single character
X *	[^xxx]	match any single character not in the set given.
X *	[xxx]	match any single character not in the set given.
X *	        The - character is understood to be a range indicator.
X *	        If the ] character is the first of the set it is considered
X *	        as part of the set, not the terminator.
X *
X * RETURNS
X *	the gmatch function returns zero if they do not match,
X *	and nonzero if they do.  Returns -1 on error.
X *
X * CAVEAT
X *	This is a limited set of the sh(1) patterns.
X *	Assumes that the `original' global variable has been initialized, it is
X *	used for error reporting.
X */
X
Xstatic int gmatch _((char *, char *, char *));
X
Xstatic int
Xgmatch(formal, formal_end, actual)
X	char		*formal;
X	char		*formal_end;
X	char		*actual;
X{
X	char		*cp;
X	int		 result;
X
X	trace(("gmatch(formal = %08lX, formal_end = %08lX, actual = %08lX)\n{\n"/*}*/, formal, formal_end, actual));
X	while (formal < formal_end)
X	{
X		trace(("formal == \"%.*s\";\n", formal_end - formal, formal));
X		trace(("actual = \"%s\";\n", actual));
X		switch (*formal)
X		{
X		default:
X			if (*actual++ != *formal++)
X			{
X				result = 0;
X				goto ret;
X			}
X			break;
X
X		case '?':
X			if (!*actual++)
X			{
X				result = 0;
X				goto ret;
X			}
X			++formal;
X			break;
X
X		case '*':
X			cp = actual + strlen(actual);
X			++formal;
X			for (;;)
X			{
X				if (gmatch(formal, formal_end, cp))
X				{
X					result = 1;
X					goto ret;
X				}
X				--cp;
X				if (cp < actual)
X				{
X					result = 0;
X					goto ret;
X				}
X			}
X
X		case '[':
X			++formal;
X			if (*formal == '^')
X			{
X				++formal;
X				for (;;)
X				{
X					if (formal >= formal_end)
X					{
X						no_close:
X						error("pattern \"%s\" missing closing ']'", original);
X						result = -1;
X						goto ret;
X					}
X					/* note: this allows leading ']' elegantly */
X					if
X					(
X						formal_end >= formal + 3
X					&&
X						formal[1] == '-'
X					&&
X						formal[2] != ']'
X					)
X					{
X						char	c1;
X						char	c2;
X
X						c1 = formal[0];
X						c2 = formal[2];
X						formal += 3;
X						if
X						(
X							c1 <= c2
X						?
X							(c1 <= *actual && *actual <= c2)
X						:
X							(c2 <= *actual && *actual <= c1)
X						)
X						{
X							result = 0;
X							goto ret;
X						}
X					}
X					else
X					if (*actual == *formal++)
X					{
X						result = 0;
X						goto ret;
X					}
X					if (*formal == ']')
X						break;
X				}
X				++formal;
X			}
X			else
X			{
X				for (;;)
X				{
X					if (formal >= formal_end)
X						goto no_close;
X					/* note: this allows leading ']' elegantly */
X					trace(("formal == \"%.*s\";\n", formal_end - formal, formal));
X					trace(("actual = \"%s\";\n", actual));
X					if
X					(
X						formal_end >= formal + 3
X					&&
X						formal[1] == '-'
X					&&
X						formal[2] != ']'
X					)
X					{
X						char	c1;
X						char	c2;
X
X						c1 = formal[0];
X						c2 = formal[2];
X						formal += 3;
X						if
X						(
X							c1 <= c2
X						?
X							(c1 <= *actual && *actual <= c2)
X						:
X							(c2 <= *actual && *actual <= c1)
X						)
X							break;
X					}
X					else
X					if (*actual == *formal++)
X						break;
X					if (*formal == ']')
X					{
X						result = 0;
X						goto ret;
X					}
X				}
X				for (;;)
X				{
X					if (formal >= formal_end)
X						goto no_close;
X					trace(("formal == \"%.*s\";\n", formal_end - formal, formal));
X					trace(("actual = \"%s\";\n", actual));
X					if (*formal++ == ']')
X						break;
X				}
X			}
X			++actual;
X			break;
X		}
X	}
X	result = (*actual == 0);
X	ret:
X	trace(("return %d;\n", result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	globber - file name expander
X *
X * SYNOPSIS
X *	int globber(char *formal);
X *
X * DESCRIPTION
X *	The globber function is used to generate a list of file names from the
X *	given `formal' pattern.  Results are appended to the word list pointed
X *	to the global `where' variable.
X *
X * RETURNS
X *	int; 0 on success, -1 on error.
X *
X * CAVEAT
X *	Assumes that the `where' global variable has been initialized.
X */
X
Xstatic int globber _((char *));
X
Xstatic int
Xglobber(formal)
X	char		*formal;
X{
X	char		*formal_end;
X	char		*cp;
X	int		 retval;
X
X	trace(("globber(formal = %08lX)\n{\n"/*}*/, formal));
X	trace_string(formal);
X	retval = 0;
X	for (;;)
X	{
X		while (*formal == '/')
X			tmp_char(*formal++);
X		formal_end = strchr(formal, '/');
X		if (!formal_end)
X			formal_end = formal + strlen(formal);
X		for (cp = formal; cp < formal_end; ++cp)
X			if (strchr("[?*", *cp))
X				break;
X		if (cp >= formal_end)
X		{
X			/* nothing special */
X			trace(("ordinary = \"%.*s\"", formal_end - formal, formal));
X			for (cp = formal; cp < formal_end; ++cp)
X				tmp_char(*cp);
X			if (!*cp)
X			{
X				string_ty *s;
X
X				s = str_n_from_c(tmp, tmp_len);
X				wl_append(where, s);
X				str_free(s);
X				break;
X			}
X			formal = formal_end;
X		}
X		else
X		{
X			size_t		n;
X			DIR		*dp;
X			struct dirent	*dep;
X
X			/* need to expand wild characters */
X			trace(("expand = \"%.*s\"", formal_end - formal, formal));
X			n = tmp_len;
X			tmp_char(0);
X			dp = opendir(tmp[0] ? tmp : ".");
X			if (!dp)
X			{
X				if (errno == ENOTDIR)
X					break;
X				nerror("%s", tmp);
X				retval = -1;
X				goto ret;
X			}
X			tmp_len = n;
X			for (;;)
X			{
X				char	*np;
X
X				dep = readdir(dp);
X				if (!dep)
X					break;
X				np = dep->d_name;
X				if
X				(
X					np[0] == '.'
X				&&
X					(
X						!np[1]
X					||
X						(np[1] == '.' && !np[2])
X					)  
X				)
X					continue;
X				switch (gmatch(formal, formal_end, np))
X				{
X				case 0:
X					continue;
X
X				case -1:
X					retval = -1;
X					goto ret;
X				}
X				for (cp = np; *cp; ++cp)
X					tmp_char(*cp);
X				if (!*formal_end)
X				{
X					string_ty *s;
X
X					s = str_n_from_c(tmp, tmp_len);
X					wl_append(where, s);
X					str_free(s);
X				}
X				else
X				{
X					tmp_char('/');
X					if (globber(formal_end + 1))
X					{
X						closedir(dp);
X						retval = -1;
X						goto ret;
X					}
X				}
X				tmp_len = n;
X			}
X			closedir(dp);
X			break;
X		}
X	}
X	ret:
X	trace(("return %d;\n", retval));
X	trace((/*{*/"}\n"));
X	return retval;
X}
X
X
X/*
X * NAME
X *	cmp - compare strings
X *
X * SYNOPSIS
X *	int cmp(string_ty **, string_ty **);
X *
X * DESCRIPTION
X *	The cmp function is used to compare two strings.
X *
X * RETURNS
X *	int; <0 if a<b, 0 if a==b, >0 if a>b
X *
X * CAVEAT
X *	Intended for use by qsort.
X */
X
Xstatic int cmp _((const void *, const void *));
X
Xstatic int
Xcmp(va, vb)
X	const void	*va;
X	const void	*vb;
X{
X	string_ty	*a;
X	string_ty	*b;
X
X	a = *(string_ty **)va;
X	b = *(string_ty **)vb;
X	return strcmp(a->str_text, b->str_text);
X}
X
X
X/*
X * NAME
X *	builtin_glob - builtin function for expanding file names
X *
X * SYNOPSIS
X *	int builtin_glob(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	The builtin_glob function is used to implement the "glob" builtin
X *	function of cook to expand file name patterns.
X *
X * RETURNS
X *	int; 0 on success, -1 on any error
X *
X * CAVEAT
X *	This function is designed to be used as a "builtin" function.
X */
X
Xint
Xbuiltin_glob(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X	int		start;
X	int		retval;
X
X	trace(("glob(result = %08X, args = %08X)\n{\n"/*}*/, result, args));
X	retval = 0;
X	where = result;
X	for (j = 1; j < args->wl_nwords; ++j)
X	{
X		tmp_len = 0;
X		original = args->wl_word[j]->str_text;
X		start = result->wl_nwords;
X		if (globber(original))
X		{
X			retval = -1;
X			break;
X		}
X		qsort
X		(
X			result->wl_word + start,
X			result->wl_nwords - start,
X			sizeof(string_ty *),
X			cmp
X		);
X	}
X	trace(("return %d;\n", retval));
X	trace((/*{*/"}\n"));
X	return retval;
X}
END_OF_FILE
if test 9294 -ne `wc -c <'cook/builtin/glob.c'`; then
    echo shar: \"'cook/builtin/glob.c'\" unpacked with wrong size!
fi
# end of 'cook/builtin/glob.c'
fi
if test -f 'cook/stat.cache.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/stat.cache.c'\"
else
echo shar: Extracting \"'cook/stat.cache.c'\" \(8586 characters\)
sed "s/^X//" >'cook/stat.cache.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate the stat cache
X */
X
X#include <errno.h>
X#include <ac/string.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X
X#include <archive.h>
X#include <error.h>
X#include <fngrprnt.h>
X#include <mem.h>
X#include <option.h>
X#include <stat.cache.h>
X#include <symtab.h>
X#include <trace.h>
X
X
Xtypedef struct cache_ty cache_ty;
Xstruct cache_ty
X{
X	time_t	oldest;
X	time_t	newest;
X};
X
Xstatic symtab_ty *symtab;
X
X
Xstatic void init _((void));
X
Xstatic void
Xinit()
X{
X	trace(("init()\n{\n"/*}*/));
X	if (!symtab)
X	{
X		symtab = symtab_alloc(100);
X		symtab->reap = mem_free;
X	}
X	trace((/*{*/"}\n"));
X}
X
X
Xstatic cache_ty *mem_copy_cache _((cache_ty *));
X
Xstatic cache_ty *
Xmem_copy_cache(st)
X	cache_ty	*st;
X{
X	cache_ty	*result;
X
X	result = mem_alloc(sizeof(cache_ty));
X	*result = *st;
X	return result;
X}
X
X
X/*
X * NAME
X *	stat_cache - stat() with caching
X *
X * SYNOPSIS
X *	int stat_cache(string_ty *path, struct stat *result);
X *
X * DESCRIPTION
X *	The stat_cache function is used to perform the same as the stat()
X *	system function, but the results are cached to avoid too many probes
X *	into the file system.  Files which do not exist are indicated by
X *	filling the result structure with zeros.
X *
X * RETURNS
X *	int; -1 on error, 0 on success
X *
X * CAVEAT
X *	Errors, other than ENOENT, result in a fatal diagnostic.
X */
X
Xstatic int stat_cache _((string_ty *, cache_ty *));
X
Xstatic int
Xstat_cache(path, cp)
X	string_ty	*path;
X	cache_ty	*cp;
X{
X	cache_ty	*data;
X	int		err;
X	struct stat	st;
X
X	/*
X	 * if we have previously stat()ed this file,
X	 * return old information
X	 */
X	trace(("stat_cache(path = \"%s\")\n{\n"/*}*/, path->str_text));
X	if (!symtab)
X		init();
X	data = symtab_query(symtab, path);
X	if (data)
X	{
X		*cp = *data;
X		trace(("return 0;\n"));
X		trace((/*{*/"}\n"));
X		return 0;
X	}
X
X	/*
X	 * new file, perform stat() for the first time
X	 */
X	trace(("stat(\"%s\")\n", path->str_text));
X	err = stat(path->str_text, &st);
X	if (err && errno == ENOENT)
X		err = archive_stat(path, &st);
X	if (err)
X	{
X		switch (errno)
X		{
X		case ENOENT:
X		case ENOTDIR:
X			/*
X			 * ENOENT occurs when a path element does not exist
X			 * ENOTDIR occurs when a path element (except the last)
X			 *		is not a directory.
X			 * Either way, the file being "stat"ed does not exist.
X			 */
X			break;
X
X		default:
X			nerror("stat(\"%s\")", path->str_text);
X			trace(("return -1;\n"));
X			trace((/*{*/"}\n"));
X			return -1;
X		}
X
X		fp_delete(path);
X
X		cp->newest = 0;
X		cp->oldest = 0;
X	}
X	else
X	{
X		fp_ty	*fp;
X
X		/*
X		 * make sure the times of existing files
X		 * are always positive
X		 */
X		if (st.st_mtime < 1)
X			st.st_mtime = 1;
X		cp->oldest = st.st_mtime;
X		cp->newest = st.st_mtime;
X		
X		/*
X		 * see if we have its fingerprint on file
X		 */
X		if (option_test(OPTION_FINGERPRINT))
X		{
X			fp = fp_search(path);
X			if (fp)
X			{
X				/*
X				 * we have seen this file before
X				 */
X				if (fp->newest != cp->newest)
X				{
X					fp_ty	data;
X
X					/*
X					 * but it has changed
X					 * since we last saw it
X					 */
X					data.fingerprint = fp_fingerprint(path);
X					if (!data.fingerprint)
X						goto fp_not_useful;
X					if (str_equal(fp->fingerprint, data.fingerprint))
X					{
X						/*
X						 * the fingerprint is the same,
X						 * so give the oldest mtime
X						 * known
X						 */
X						data.oldest = fp->oldest;
X						data.newest = cp->newest;
X						cp->oldest = fp->oldest;
X						if (option_test(OPTION_TRACE))
X						{
X							struct tm	*tm;
X
X							tm = localtime(&data.newest);
X							error
X							(
X  "mtime(\"%s\") was %4d/%02d/%02d.%02d:%02d:%02d until fingerprinting (trace)",
X								path->str_text,
X							     1900 + tm->tm_year,
X								tm->tm_mon + 1,
X								tm->tm_mday,
X								tm->tm_hour,
X								tm->tm_min,
X								tm->tm_sec
X							);
X						}
X					}
X					else
X					{
X						/*
X						 * the fingerprint differs
X						 * do not lie about mtime
X						 */
X						data.oldest = cp->newest;
X						data.newest = cp->newest;
X					}
X					fp_assign(path, &data);
X					str_free(data.fingerprint);
X				}
X				else
X				{
X					/*
X					 * file not modified since last seen
X					 */
X					cp->oldest = fp->oldest;
X				}
X			}
X			else
X			{
X				fp_ty	data;
X
X				/*
X				 * never fingerprinted this file before
X				 */
X				data.oldest = cp->newest;
X				data.newest = cp->newest;
X				data.fingerprint = fp_fingerprint(path);
X				if (!data.fingerprint)
X				{
X					fp_not_useful:
X					fp_delete(path);
X				}
X				else
X				{
X					fp_assign(path, &data);
X					str_free(data.fingerprint);
X				}
X			}
X		}
X	}
X
X	/*
X	 * remember the stat information
X	 */
X	symtab_assign(symtab, path, mem_copy_cache(cp));
X	trace(("return 0;\n"));
X	trace((/*{*/"}\n"));
X	return 0;
X}
X
X
Xtime_t
Xstat_cache_newest(path)
X	string_ty	*path;
X{
X	cache_ty	cache;
X
X	if (stat_cache(path, &cache))
X		return -1;
X
X	/*
X	 * trace the last-modified time
X	 */
X	if (option_test(OPTION_TRACE))
X	{
X		if (!cache.newest)
X		{
X			error
X			(
X				"mtime(\"%s\") == ENOENT (trace)",
X				path->str_text
X			);
X		}
X		else
X		{
X			struct tm	*tm;
X			char		*relage;
X
X			relage = "";
X			if
X			(
X				option_test(OPTION_FINGERPRINT)
X			&&
X				cache.newest != cache.oldest
X			)
X				relage = "newest ";
X			tm = localtime(&cache.newest);
X			error
X			(
X		      "%smtime(\"%s\") == %4d/%02d/%02d.%02d:%02d:%02d (trace)",
X				relage,
X				path->str_text,
X				1900 + tm->tm_year,
X				tm->tm_mon + 1,
X				tm->tm_mday,
X				tm->tm_hour,
X				tm->tm_min,
X				tm->tm_sec
X			);
X		}
X	}
X	return cache.newest;
X}
X
X
Xtime_t
Xstat_cache_oldest(path)
X	string_ty	*path;
X{
X	cache_ty	cache;
X
X	if (stat_cache(path, &cache))
X		return -1;
X
X	/*
X	 * trace the last-modified time
X	 */
X	if (option_test(OPTION_TRACE))
X	{
X		if (!cache.oldest)
X		{
X			error
X			(
X				"mtime(\"%s\") == ENOENT (trace)",
X				path->str_text
X			);
X		}
X		else
X		{
X			struct tm	*tm;
X			char		*relage;
X
X			relage = "";
X			if
X			(
X				option_test(OPTION_FINGERPRINT)
X			&&
X				cache.newest != cache.oldest
X			)
X				relage = "oldest ";
X			tm = localtime(&cache.oldest);
X			error
X			(
X		      "%smtime(\"%s\") == %4d/%02d/%02d.%02d:%02d:%02d (trace)",
X				relage,
X				path->str_text,
X				1900 + tm->tm_year,
X				tm->tm_mon + 1,
X				tm->tm_mday,
X				tm->tm_hour,
X				tm->tm_min,
X				tm->tm_sec
X			);
X		}
X	}
X	return cache.oldest;
X}
X
X
Xvoid
Xstat_cache_set(path, when, fp2)
X	string_ty	*path;
X	time_t		when;
X	int		fp2;
X{
X	cache_ty	*data;
X	cache_ty	cache;
X
X	trace(("stat_cache_set(path = \"%s\")\n{\n"/*}*/, path->str_text));
X	if (!symtab)
X		init();
X	data = symtab_query(symtab, path);
X	if (data)
X	{
X		if (!data->oldest || !option_test(OPTION_FINGERPRINT))
X			data->oldest = when;
X		data->newest = when;
X	}
X	else
X	{
X		cache.oldest = when;
X		cache.newest = when;
X		symtab_assign(symtab, path, mem_copy_cache(&cache));
X		data = &cache;
X	}
X
X	/*
X	 * Update the fingerprint.
X	 * (Important not to lie here, the fp2 flags
X	 * says is immediately following a utime call.)
X	 */
X	if (fp2 && option_test(OPTION_FINGERPRINT))
X	{
X		fp_ty		*fp;
X
X		fp = fp_search(path);
X		if (fp)
X		{
X			fp_ty		data;
X
X			data.oldest = fp->oldest;
X			data.newest = when;
X			data.fingerprint = str_copy(fp->fingerprint);
X			fp_assign(path, &data);
X			str_free(data.fingerprint);
X		}
X	}
X
X	/*
X	 * emit a trace
X	 */
X	if (option_test(OPTION_TRACE))
X	{
X		struct tm	*tm;
X		char		*relage;
X
X		relage = "";
X		if
X		(
X			option_test(OPTION_FINGERPRINT)
X		&&
X			data->oldest != data->newest
X		)
X			relage = "newest ";
X		tm = localtime(&when);
X		error
X		(
X		       "%smtime(\"%s\") = %4d/%02d/%02d.%02d:%02d:%02d (trace)",
X			relage,
X			path->str_text,
X			1900 + tm->tm_year,
X			tm->tm_mon + 1,
X			tm->tm_mday,
X			tm->tm_hour,
X			tm->tm_min,
X			tm->tm_sec
X		);
X	}
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xstat_cache_clear(path)
X	string_ty	*path;
X{
X	trace(("stat_cache_clear(path =\"%s\")\n{\n"/*}*/, path->str_text));
X	if (!symtab)
X		init();
X	symtab_delete(symtab, path);
X	trace((/*{*/"}\n"));
X}
END_OF_FILE
if test 8586 -ne `wc -c <'cook/stat.cache.c'`; then
    echo shar: \"'cook/stat.cache.c'\" unpacked with wrong size!
fi
# end of 'cook/stat.cache.c'
fi
if test -f 'doc/cmdline.so' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/cmdline.so'\"
else
echo shar: Extracting \"'doc/cmdline.so'\" \(7309 characters\)
sed "s/^X//" >'doc/cmdline.so' <<'END_OF_FILE'
X.\"
X.\"	cook - file construction tool
X.\"	Copyright (C) 1990, 1991, 1992, 1993, 1994 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: Reference Manual, The Command Line
X.\"	
X.H 1 "The Command Line"
X.B Cook
Xmay be invoked from the
Xcommand line by a command of the form
X.DS
X.in +0.5i
X.fi
X.B cook
X[
X.IR option ...
X]
X[
X.IR filename ...
X]
X.in -0.5i
X.DE
XOptions and filenames may be arbitrarily mixed on the command line;
Xno processing is done until all options and filenames
Xon the command line have been scanned.
X.P
X.B Cook
Xwill attempt to create the named files from the recipes
Xgiven to it.
XThe recipes are contained in a file called
X.I Howto.cook
Xin the current directory.
XThis file may, in turn, include other files containing additional recipes.
X.P
XIf no
X.IR filename s
Xare given on the command line
Xthe targets of the first recipe defined are cooked.
X.H 2 "Options"
XThe valid options for
X.B cook
Xare listed below.
XAny other options
X(words on the command line beginning with `\fB-\fP')
Xwill cause a diagnostic message to be issued.
X.VL 1i
X.LI \fB-Action\fP
XExecute the commands given in the recipes.
XThis is the default.
X.LI \fB-No_Action\fP
XDo not execute the commands given in the recipes.
X.LI \fB-Continue\fP
XIf cooking a target should fail,
Xcontinue with other recipes for which the failed target is not an ingredient,
Xdirectly or indirectly.
X.LI \fB-No_Continue\fP
XIf cooking a target should fail,
X.B cook
Xwill exit.
XThis is the default.
X.LI \fB-Errok\fP
XWhen a command is executed,
Xthe exit code will be ignored.
X.LI \fB-No_Errok\fP
XWhen a command is executed,
Xif the exit code is positive
Xit will be deemed to fail,
Xand thus the recipe containing it to have failed.
XThis is the default.
X.LI \fB-FingerPrint\fP
XWhen
X.I cook
Xexamined a file to determine if it has changed,
Xit uses the last-modified time information available in the file system.
XThere are times when this is altered, but the file
Xcontents do not actually change.
XThe fingerprinting facility examines the file
Xwhen it appears to have changed,
Xand compares the old fingerprint against the present file contents.
XIf the fingerprint did not change,
Xthe last-modified time in the file system is ignored.
XNote that this has implications if you
Xare in the habit of using the
X.IR touch (1)
Xcommand \- 
X.I cook
Xwill do nothing
Xuntil you actually change the file.
X.LI \fB-No_FingerPrint\fP
X.br
XDo not use fingerprints
Xto supplement the last-modified time file information.
XThis is the default.
X.LI \fB-Force\fP
XAlways perform the actions of recipes,
Xirrespective of the last-modified times of any of the ingredients.
X.P
XThis option is useful if something beyond the scope of the cookbook
Xhas been modified;
Xfor example, a bug fix in a compiler.
X.LI \fB-No_Force\fP
XPerform the actions of the recipes
Xif any of the ingredients are logically out of date.
XThis is the default.
X.LI \fB-Help\fP
XProvide information about how to execute
X.B cook
Xon 
X.IR stdout ,
Xand perform no other function.
X.LI "\fB-Include\fP \fIfilename\fP"
X.br
XSearch the named directory before the standard places for
Xincluded cookbooks.
XEach directory so named will be scanned in the order given.
XThe standard places are
X.I $HOME/.cook
Xthen
X.IR /usr/local/lib/cook .
X.LI \fB-List\fP
XCauses
X.B cook
Xto automatically redirect the
X.I stdout
Xand
X.I stderr
Xof the session.
XOutput will continue to come to the terminal,
Xunless 
X.B cook
Xis executing in the background.
XThe name of the file will be the name of the cookbook with any suffix
Xremoved and "\f(CW.list\fP" appended;
Xthis will usually be
X.IR Howto.list .
XThis is the default.
X.LI "\fB-List\fP \fIfilename\fP"
XCauses 
X.B cook
Xto automatically redirect the
X.I stdout 
Xand
X.I stderr
Xof the session into the named file.
XOutput will continue to come to the terminal,
Xunless 
X.B cook
Xis executing in the background.
X.LI \fB-No_List\fP
XNo automatic redirection of the session of the session will be made.
X.LI "\fB-No_List\fP \fIfilename\fP"
X.br
XNo automatic redirection of the session of the session will be made,
Xhowever subsequent
X.B -List
Xoptions will default to listing to the named file.
X.LI \fB-Meter\fP
XAfter each command is executed,
Xprint a summary of the command's CPU usage.
X.LI \fB-No_Meter\fP
XDo not print a CPU usage summary after each command.
XThis is the default.
X.LI \fB-Precious\fP
XWhen commands in the body of a recipe fail,
Xno not delete the targets of the recipe.
X.LI \fB-No_Precious\fP
XWhen commands in the body of a recipe fail,
Xdelete the targets of the recipe.
XThis is the default.
X.LI \fB-Silent\fP
XDo not echo commands before they are executed.
X.LI \fB-No_Silent\fP
XEcho commands before they are executed.
XThis is the default.
X.LI \fB-TErminal\fP
XWhen listing,
Xalso send the output stream to the terminal.
XThis is the default.
X.LI \fB-No_TErminal\fP
XWhen listing,
Xdo not send the output to the terminal.
X.LI \fB-Touch\fP
XUpdate the last-modified times of the
Xtarget files,
Xrather than execute the actions bound to recipes.
X.P
XThis can be useful if you have made a modification to a file that
Xyou know will make a
Xsystem of files logically out of date,
Xbut has no significance;
Xfor example,
Xadding a comment to a widely used include file.
X.LI \fB-No_Touch\fP
XExecute the actions bound to recipes,
Xrather than update the last-modified times of the target files.
XThis is the default.
X.LI \fB-Update\fP
XThis option causes
X.B cook
Xto check the last-modified time of the targets of recipes,
Xand updates them if necessary,
Xto make sure they are consistent with (younger than) the last-modified
Xtimes of the ingredients.
XThis results in more system calls,
Xand can slow things down on some systems.
X.LI \fB-No_Update\fP
XDo not update the file last-modified times after performing
Xthe body of a recipe.
XThis is the default.
X.LI \fIname\fP\fB=\fP\fIvalue\fP
XAssign the
X.I value
Xto the named variable.
XThe value may contain spaces
Xif you can convince the shell to pass them through.
X.LE
X.P
XIn the above descriptions,
Xa shorter form is indicated by the uppercase letters;
Xfor example,
Xthe
X.B -No_Touch
Xoption may be abbreviated to
X.BR -nt .
X.B Cook
Xis case insensitive to the options,
Xso you may arbitrarily mix cases within the options.
X.P
XTwo options are provided for
Xtracing the inferences
X.B cook 
Xmakes when attempting to cook a target.
X.VL 1i
X.LI \fB-TRace\fP
X.B Cook
Xwill emit copious amounts of information
Xabout the inferences it is making when cooking targets.
XThis option may be used when you think 
X.B cook
Xis acting strangely,
Xor are just curious.
X.LI \fB-No_TRace\fP
X.B Cook
Xwill not emit information
Xabout the inferences it is making when cooking targets.
XThis is the default.
X.LE
END_OF_FILE
if test 7309 -ne `wc -c <'doc/cmdline.so'`; then
    echo shar: \"'doc/cmdline.so'\" unpacked with wrong size!
fi
# end of 'doc/cmdline.so'
fi
if test -f 'doc/how.so' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/how.so'\"
else
echo shar: Extracting \"'doc/how.so'\" \(8795 characters\)
sed "s/^X//" >'doc/how.so' <<'END_OF_FILE'
X.\"
X.\"	cook - file construction tool
X.\"	Copyright (C) 1990, 1991, 1992, 1993, 1994 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: Reference Manual, Actions when Cooking
X.\"	
X.H 1 "Actions when Cooking"
XThis section describes what 
X.B cook
Xdoes when you ask it to cook something.
X.P
X.B Cook
Xperforms the following actions in the order stated.
X.H 2 "Scan the COOK Environment Variable"
XThe
X.B COOK
Xenvironment variable is looked for.
XIf it is found,
Xit is treated as if it consisted of
X.B cook
Xcommand line arguments.
XOnly the
X.B -Help
Xoption is illegal.
XThis could result is very strange behaviour if used incorrectly.
X.P
XThis feature is supplied to override
X.BR cook 's
Xdefault with your own preferences.
X.H 2 "Scan the Command Line"
XThe command line is scanned 
Xas defined in chapter 3.
X.H 2 "Locate the Cookbook"
XThe current directory is scanned for the cookbook.
XNames which a cookbook may have include
X.TS
Xcenter, tab(;);
Xc c c.
Xhowto.cook;Howto.cook;.howto.cook
Xhow.to.cook;How.to.cook;.how.to.cook
Xcookfile;Cookfile;.cookrc
Xcook.file;Cook.file;.cook.rc
X.TE
XThe first so named file found in the current directory
Xwill be used.
XThe order of search is not defined.
XYou are strongly advised to have just 
X.I one
Xof these name forms in any directory.
XThe name
X.I Howto.cook
Xis the preferred form.
X.H 2 "Form the Listing Filename"
XThe listing file,
Xif not explicitly named in the environment variable or on the command line,
Xwill be the name of the cookbook,
Xwith any suffix removed and '\f(CW.list\fP' appended.
X.H 2 "Create the Listing file"
XThe listing file is created.
XIf 
X.B cook
Xis executing in the background,
Xor the
X.B -NoTTy
Xoption has been specified,
X.I stdout
Xand
X.I stderr
Xwill be redirected into the listing file.
XIf
X.B cook
Xis executing in the foreground,
Xand the
X.B -NoTTy
Xoption has not been specified,
X.I stdout
Xand 
X.I stderr
Xwill be redirected into
Xa pipe to a
X.IR tee (1)
Xcommand;
Xwhich will, in turn, copy the output into the named file.
X.P
XA heading line with the name of the file and the date,
Xis generated.
X.H 2 "Scan the Cookbook"
XWhen 
X.B cook
Xreads the cookbook it evaluates all of the statements it
Xfinds in it.
XUsually these statements instanciate recipes,
Xalthough other things are possible.
X.P
XRecipes contain statements that are not evaluated immediately,
Xbut which are remembered for later execution when cooking a target.
XThe meaning of a cookbook is defined in chapter X.
X.H 2 "Determine targets to cook"
XIf no target files are named on the command line,
Xthe targets of the first defined explicit or ingredients recipe.
XIt is an error if this is none.
X.H 2 "Cooking a Target"
XEach of the targets,
Xin the order given,
Xare cooked.
X.P
XTo cook a target
Xeach the following steps is performed in the order given:
X.AL
X.LI
X.B Cook
Xscans through the instanciated ingredients recipes
Xin the order they were defined.
XAll ingredients recipes with the target in their target list are used.
X.P
XIf a recipe is used,
Xthen any ingredients are recursively cooked.
XIf any of the ingredients are younger than the target,
Xall other explicit or implicit recipes with the same target will
Xbe deemed to be out of date.\*F
X.FS
XA target which does not exist yet is considered to be infinitely ancient,
Xand thus everything is younger than it.
X.FE
X.LI
X.B Cook
Xthen scans through the instanciated explicit recipes
Xin the order they were defined.
XAll explicit recipes with the target in their target list are used.
X.P
XIf a recipe is a used,
Xthe ingredients are recursively cooked.
XIf any ingredients are out of date
Xor the target does not yet exist
X(or the "forced" flag is set in the recipe's \fIset\fP clause)
Xthe recipe body will be performed.
XIf a recipe has no ingredients,
Xit will not be performed,
Xunless the target does not yet exist, or it is forced.
X.LI
XIf the target was not in the target list of any explicit recipe,
X.B cook
Xthen scans the instanciated implicit recipes
Xin the order they were defined.
X.P
XImplicit recipe targets and ingredients may contain a wildcard
Xcharacter (\fB%\fP),
Xwhich is why they are implicit.
XWhen expressions are evaluated into word lists in an implicit recipe,
Xany word containing the wildcard character (\fB%\fP) will be expanded
Xout by the current wildcard expansion.
X.P
XIf the target matches a pattern in the targets of an implicit recipe,
Xit is a candidate.
XEach ingredient of a candidate recipe is recursively cooked.
XIf any ingredient cannot be cooked,
Xthen the implicit recipe is not used.
XIf all ingredients can be cooked,
Xthen the implicit recipe is used.
X.P
XIf an implicit recipe is a used,
Xthe forced ingredients are recursively cooked.
XIt is an error if a forced ingredient cannot be constructed.
XAfter the forced ingredients are constructed,
Xthe recipe body is performed.
X.P
XOnly the first implicit recipe to get to this point is used.
XThe scan stops at this point.
X.LI
XIf the target is not the subject of any ingredients or explicit
Xrecipe,
Xand no implicit recipes can be applied,
Xthen two things can happen.
X.BL
X.LI
XIf the file exists, then it is up to date, or
X.LI
XIf the file does not exist then 
X.B cook
Xdoesn't know how.
X.LE
X.LE
X.P
XIf a command in the body of any recipe fail, 
X.B cook
Xwill not that body any further,
Xand will not perform the body of any recipe for which the target
Xof the failed actions was an ingredient,
Xdirectly or indirectly.
X.P
X.B Cook
Xwill trap recursive looping of targets.
X.BL
X.LI
XIf the file exists, the it is up to date, or
X.LI
XIf the file does not exist then 
X.B cook
Xdoesn't know how.
X.LE
X.H 2 "File Status"
X.B Cook
Xdetermines the time a file was last modified by asking the operating system.
XBecause this operation tents to be performed frequently,
X.B cook
Xmaintains a cache of this information,
Xrather than make redundant calls to the operating system.
XBecause this information is cached,
Xit is possible for
X.BR cook "'s"
Xmemory of a file's last-modified time
Xto become inconsuistent with the file's actual last-modified time.
XIn particular,
X.B cook
Xdoe \fInot\fP ask the operating system for the "new" last-modified time
Xof a recipe target once a recipe body is completed.
XCareful use of the \f(CWset clearstat\fP clause
Xwill generally prevent this.
XFor example,
Xthe following recipe needs to create a directory
Xwhen writing its output:
X.eB
Xbin/%: [%_obj]
X{
X	if [not [exists bin]] then
X		mkdir bin;
X	[cc] -o [target] [need];
X}
X.eE
XIf there were several programs being cooked,
Xe.g. \fIbin/foo\fP and \fIbin/bar\fP,
Xthe second time \fBcook\fP performed the recipe,
Xit would erronenously attempt to make the \fIbin\fP directory
Xa second time - contrary to the test.
XThis is because \fI[exists bin]\fP used the cache,
Xand nothing tells \fBcook\fP that the cache is now wrong.
XThe recipe should have been written
X.eB
Xbin/%: [%_obj]
X{
X	if [not [exists bin]] then
X		mkdir bin
X			set clearstat;
X	[cc] -o [target] [need];
X}
X.eE
Xwhich tells \fBcook\fP that it should remove any files
Xnamed in the \fImkdir\fP command from the cache.
X.P
XA second mechanism used by
X.B cook
Xto determine the last-modified times of files is
Xa file
X.IR fingerprint .
XThis is a cryptographically strong hash of the contents of a file.
XThe chances of two different files having the same fingerprint
Xis less than 1 in 2**200.
XIf \fBcook\fP notices that a file has changed,
Xbecause its last-modified time has changed,
Xa fingerprint is taken of the file
Xand compared with the remembered fingerprint.
XIf the fingerprints differ,
Xthe file is considered to be different.
XIf the fingerprints match,
Xthe file is considered not to have changed.
X.P
XThis description of fingerprints is somewhat simplified,
Xthe actual mechanics depends on remembering two
Xdifferent last-modified times,
Xas well as the fingerprint,
Xin a file called
X.I \&.cook.fp
Xin the current directory.
X.P
XFingerprinting can cause some surprises.
XFor example,
Xwhen you use the
X.IR touch (1)
Xcommand,
X.B cook
Xwill often fail to do anything,
Xand report instead that everything is up-to-date.
XThis is because the fingerprint has not changed.
XIn this situation,
Xeither remove the
X.I \&.cook.fp
Xfile,
Xor use the
X.B -No_FingerPrint
Xcommand line option.
END_OF_FILE
if test 8795 -ne `wc -c <'doc/how.so'`; then
    echo shar: \"'doc/how.so'\" unpacked with wrong size!
fi
# end of 'doc/how.so'
fi
if test -f 'make2cook/stmt/assign.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'make2cook/stmt/assign.c'\"
else
echo shar: Extracting \"'make2cook/stmt/assign.c'\" \(8589 characters\)
sed "s/^X//" >'make2cook/stmt/assign.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate assign statements
X */
X
X#include <emit.h>
X#include <stmt/assign.h>
X#include <symtab.h>
X#include <variable.h>
X
Xtypedef struct stmt_assign_ty stmt_assign_ty;
Xstruct stmt_assign_ty
X{
X	STMT
X	int		override;
X	blob_list_ty	*lhs;
X	int		op;
X	blob_list_ty	*rhs;
X	int		check_env;
X};
X
X
Xstatic void destructor _((stmt_ty *));
X
Xstatic void
Xdestructor(that)
X	stmt_ty		*that;
X{
X	stmt_assign_ty	*this;
X
X	this = (stmt_assign_ty *)that;
X	blob_list_free(this->lhs);
X	blob_list_free(this->rhs);
X}
X
X
Xstatic void emit _((stmt_ty *));
X
Xstatic void
Xemit(that)
X	stmt_ty		*that;
X{
X	stmt_assign_ty	*this;
X	long		j;
X
X	this = (stmt_assign_ty *)that;
X	if (this->op != stmt_assign_op_plus && !this->override)
X	{
X		emit_set_file(this->lhs->list[0]->file_name);
X		emit_str("if [not [defined ");
X		emit_string(this->lhs->list[0]->text);
X		emit_str("]] then\n");
X		if (this->check_env && !this->rhs->length)
X		{
X			this->check_env = 0;
X			blob_list_append
X			(
X				this->rhs,
X				blob_alloc
X				(
X					str_format
X					(
X						"[getenv %S]",
X						this->lhs->list[0]->text
X					),
X					this->lhs->list[0]->file_name,
X					this->lhs->list[0]->line_number
X				)
X			);
X		}
X		if (this->check_env)
X		{
X			emit_str("{\n"/*}*/);
X			emit_indent_more();
X			emit_string(this->lhs->list[0]->text);
X			emit_str(" = [getenv ");
X			emit_string(this->lhs->list[0]->text);
X			emit_str("];\n");
X			emit_str("if [not [");
X			emit_string(this->lhs->list[0]->text);
X			emit_str("]] then\n");
X		}
X		emit_indent_more();
X	}
X
X	blob_emit(this->lhs->list[0]);
X	emit_str(" =");
X	if (this->op == stmt_assign_op_plus)
X	{
X		emit_char(' ');
X		emit_char('[');
X		blob_emit(this->lhs->list[0]);
X		emit_char(']');
X	}
X	for (j = 0; j < this->rhs->length; ++j)
X	{
X		emit_char(' ');
X		blob_emit(this->rhs->list[j]);
X	}
X	if (!this->rhs->length)
X		emit_char(' ');
X	emit_str(";\n");
X
X	if (this->op != stmt_assign_op_plus && !this->override)
X	{
X		emit_indent_less();
X		if (this->check_env)
X		{
X			emit_indent_less();
X			emit_str(/*{*/"}\n");
X		}
X	}
X}
X
X
Xstatic stmt_method_ty method =
X{
X	sizeof(stmt_assign_ty),
X	"assign",
X	0, /* constructor */
X	destructor,
X	emit,
X};
X
X
Xstmt_ty *
Xstmt_assign_alloc(override, lhs, op, rhs)
X	int		override;
X	blob_ty		*lhs;
X	int		op;
X	blob_list_ty	*rhs;
X{
X	stmt_assign_ty	*this;
X	blob_list_ty	*lhs2;
X	blob_list_ty	*rhs2;
X	size_t		j;
X
X	this = (stmt_assign_ty *)stmt_alloc(&method);
X	if (op == stmt_assign_op_default)
X	{
X		this->check_env = 1;
X		op = stmt_assign_op_normal;
X	}
X	else
X		this->check_env = 0;
X
X	/*
X	 * turn the make names into cook names
X	 */
X	lhs2 = blob_list_alloc();
X	variable_rename(lhs, lhs2, &this->ref);
X	blob_free(lhs);
X	for (j = 0; j < lhs2->length; ++j)
X	{
X		if (op == stmt_assign_op_normal)
X			wl_append_unique(&this->mdef, lhs2->list[j]->text);
X		wl_append_unique(&this->cdef, lhs2->list[j]->text);
X		if (op == stmt_assign_op_plus)
X			wl_append_unique(&this->ref, lhs2->list[j]->text);
X	}
X	rhs2 = blob_list_alloc();
X	for (j = 0; j < rhs->length; ++j)
X		variable_rename(rhs->list[j], rhs2, &this->ref);
X	blob_list_free(rhs);
X
X	this->override = override;
X	this->lhs = lhs2;
X	this->op = op;
X	this->rhs = rhs2;
X
X	return (stmt_ty *)this;
X}
X
X
Xstatic stmt_ty *default_setting _((string_ty *));
X
Xstatic stmt_ty *
Xdefault_setting(name)
X	string_ty	*name;
X{
X	typedef struct table_ty table_ty;
X	struct table_ty
X	{
X		char	*name;
X		char	*value;
X	};
X
X	static table_ty table[] =
X	{
X		{ ".CURDIR", "$(pathname .)", },
X		{ "AR", "ar", },
X		{ "ARFLAGS", "rv", },
X		{ "AS", "as", },
X		{ "CC", "cc", },
X		{ "CXX", "g++", },
X		{ "CHECKOUT,v", "$(CO) $(COFLAGS)" },
X		{ "CO", "co", },
X		{ "CPP", "$(CC) -E", },
X#ifdef	CRAY
X		{ "CF77PPFLAGS", "-P", },
X		{ "CF77PP", "/lib/cpp", },
X		{ "CFT", "cft77", },
X		{ "CF", "cf77", },
X		{ "FC", "$(CF)", },
X#else	/* Not CRAY.  */
X#ifdef	_IBMR2
X		{ "FC", "xlf", },
X#else
X#ifdef	__convex__
X		{ "FC", "fc", },
X#else
X		{ "FC", "f77", },
X#endif /* __convex__ */
X#endif /* _IBMR2 */
X		/*
X		 * System V uses these, so explicit rules using them
X		 * should work.  However, there is no way to make
X		 * implicit rules use them and FC.
X		 */
X		{ "F77", "$(FC)", },
X		{ "F77FLAGS", "$(FFLAGS)", },
X#endif	/* Cray.  */
X		{ "GET", SCCS_GET, },
X		{ "LD", "ld", },
X		{ "LEX", "lex", },
X		{ "LINT", "lint", },
X		{ "M2C", "m2c", },
X#ifdef	pyr
X		{ "PC", "pascal", },
X#else
X#ifdef	CRAY
X		{ "PC", "PASCAL", },
X		{ "SEGLDR", "segldr", },
X#else
X		{ "PC", "pc", },
X#endif	/* CRAY.  */
X#endif	/* pyr.  */
X		{ "YACC", "yacc", },
X		{ "MAKEINFO", "makeinfo", },
X		{ "TEX", "tex", },
X		{ "TEXI2DVI", "texi2dvi", },
X		{ "WEAVE", "weave", },
X		{ "CWEAVE", "cweave", },
X		{ "TANGLE", "tangle", },
X		{ "CTANGLE", "ctangle", },
X		{ "RM", "rm -f", },
X		{ "LINK.o", "$(CC) $(LDFLAGS) $(TARGET_ARCH)", },
X		{
X			"COMPILE.c",
X			"$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
X		},
X		{
X			"LINK.c",
X			"$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
X		},
X		{
X			"COMPILE.cc",
X			"$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
X		},
X		{ "COMPILE.C", "$(COMPILE.cc)", },
X		{
X			"LINK.cc",
X		     "$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
X		},
X		{ "LINK.C", "$(LINK.cc)", },
X		{ "YACC.y", "$(YACC) $(YFLAGS)", },
X		{ "LEX.l", "$(LEX) $(LFLAGS) -t", },
X		{ "COMPILE.f", "$(FC) $(FFLAGS) $(TARGET_ARCH) -c", },
X		{ "LINK.f", "$(FC) $(FFLAGS) $(LDFLAGS) $(TARGET_ARCH)", },
X		{
X			"COMPILE.F",
X			"$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
X		},
X		{
X			"LINK.F",
X			"$(FC) $(FFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
X		},
X		{ "COMPILE.r", "$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -c", },
X		{
X			"LINK.r",
X			"$(FC) $(FFLAGS) $(RFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
X		},
X		{
X			"COMPILE.def",
X			"$(M2C) $(M2FLAGS) $(DEFFLAGS) $(TARGET_ARCH)",
X		},
X		{
X			"COMPILE.mod",
X			"$(M2C) $(M2FLAGS) $(MODFLAGS) $(TARGET_ARCH)",
X		},
X		{
X			"COMPILE.p",
X			"$(PC) $(PFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
X		},
X		{
X			"LINK.p",
X			"$(PC) $(PFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
X		},
X		{ "LINK.s", "$(CC) $(ASFLAGS) $(LDFLAGS) $(TARGET_MACH)", },
X		{ "COMPILE.s", "$(AS) $(ASFLAGS) $(TARGET_MACH)", },
X		{
X			"LINK.S",
X		       "$(CC) $(ASFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_MACH)",
X		},
X		{
X			"COMPILE.S",
X			"$(CC) $(ASFLAGS) $(CPPFLAGS) $(TARGET_MACH) -c",
X		},
X#if !defined(M_XENIX) || defined(__GNUC__)
X		{ "PREPROCESS.S", "$(CC) -E $(CPPFLAGS)", },
X#else	/* Xenix.  */
X		{ "PREPROCESS.S", "$(CC) -EP $(CPPFLAGS)", },
X#endif	/* Not Xenix.  */
X		{
X			"PREPROCESS.F",
X			"$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -F",
X		},
X		{
X			"PREPROCESS.r",
X			"$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -F",
X		},
X		{
X			"LINT.c",
X			"$(LINT) $(LINTFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
X		},
X	};
X
X	static symtab_ty *stp;
X	static string_ty *builtin;
X	string_ty	*data;
X	blob_ty		*lhs;
X	blob_list_ty	*rhs;
X	static long	linum;
X
X	if (!stp)
X	{
X		table_ty	*tp;
X
X		stp = symtab_alloc(SIZEOF(table));
X		for (tp = table; tp < ENDOF(table); ++tp)
X		{
X			string_ty	*s;
X
X			s = str_from_c(tp->name);
X			symtab_assign(stp, s, str_from_c(tp->value));
X			str_free(s);
X		}
X	}
X	++linum;
X	if (!builtin)
X		builtin = str_from_c("builtin");
X	lhs = blob_alloc(str_copy(name), builtin, linum); 
X	rhs = blob_list_alloc();
X	data = symtab_query(stp, name);
X	if (data)
X		blob_list_append(rhs, blob_alloc(str_copy(data), builtin, linum));
X	return stmt_assign_alloc(0, lhs, stmt_assign_op_default, rhs);
X}
X
X
Xstmt_ty *
Xstmt_assign_default(sp)
X	stmt_ty		*sp;
X{
X	size_t		j;
X
X	/*
X	 * find a symbol in ref not in cdef
X	 */
X	for (j = 0; j < sp->ref.wl_nwords; ++j)
X		if (!wl_member(&sp->cdef, sp->ref.wl_word[j]))
X			return default_setting(sp->ref.wl_word[j]);
X
X	/*
X	 * find a symbol in rref not in cdef
X	 */
X	for (j = 0; j < sp->rref.wl_nwords; ++j)
X		if (!wl_member(&sp->cdef, sp->rref.wl_word[j]))
X			return default_setting(sp->rref.wl_word[j]);
X
X	/*
X	 * no further definitions required
X	 */
X	return 0;
X}
END_OF_FILE
if test 8589 -ne `wc -c <'make2cook/stmt/assign.c'`; then
    echo shar: \"'make2cook/stmt/assign.c'\" unpacked with wrong size!
fi
# end of 'make2cook/stmt/assign.c'
fi
if test -f 'make2cook/variable.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'make2cook/variable.c'\"
else
echo shar: Extracting \"'make2cook/variable.c'\" \(7666 characters\)
sed "s/^X//" >'make2cook/variable.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate variables
X */
X
X#include <ctype.h>
X
X#include <error.h>
X#include <symtab.h>
X#include <trace.h>
X#include <vargram.h>
X#include <variable.h>
X#include <vargram.gen.h> /* must be last */
X
X
Xstatic blob_ty		*source;
Xstatic char		*lexpos;
Xstatic wlist		*reference;
Xstatic symtab_ty	*symtab;
Xstatic symtab_ty	*special;
Xstatic wlist		result;
X
X
Xstatic void init _((void));
X
Xstatic void
Xinit()
X{
X	typedef struct table_ty table_ty;
X	struct table_ty
X	{
X		char	*name;
X		char	*value;
X	};
X
X	static table_ty table[] =
X	{
X		{ "%",	"",					},
X		{ "%D",	"",					},
X		{ "%F",	"",					},
X		{ "*",	"%",					},
X		{ "*D",	"[dirname %]",				},
X		{ "*F",	"[entryname %]",			},
X		{ "<",	"[resolve [head [need]]]",		},
X		{ "<D",	"[dirname [resolve [head [need]]]]",	},
X		{ "<F",	"[entryname [resolve [head [need]]]]",	},
X		{ "?",	"[resolve [younger]]",			},
X		{ "?D",	"[dirname [resolve [younger]]]",	},
X		{ "?F",	"[entryname [resolve [younger]]]",	},
X		{ "@",	"[target]",				},
X		{ "@D",	"[dirname [target]]",			},
X		{ "@F",	"[entryname [target]]",			},
X		{ "^",	"[resolve [need]]",			},
X		{ "^D",	"[dirname [resolve [need]]]",		},
X		{ "^F",	"[entryname [resolve [need]]]",		},
X		{ "MAKE",	"[self]",			},
X		{ "MAKEFLAGS",	"[getenv [upcase [self]]]",	},
X		{ "VERSION",	"[version]",			},
X		{ "VPATH",	"[search_list]",		},
X	};
X
X	table_ty	*tp;
X	string_ty	*name;
X	string_ty	*value;
X
X	if (symtab)
X		return;
X	trace(("init()\n{\n"/*}*/));
X	symtab = symtab_alloc(SIZEOF(table));
X	for (tp = table; tp < ENDOF(table); ++tp)
X	{
X		name = str_from_c(tp->name);
X		value = str_from_c(tp->value);
X		symtab_assign(symtab, name, value);
X		str_free(name);
X	}
X	trace((/*{*/"}\n"));
X}
X
X
Xstring_ty *
Xvargram_lookup(name)
X	string_ty	*name;
X{
X	string_ty	*data;
X	string_ty	*result;
X
X	trace(("vargram_lookup(\"%s\")\n{\n"/*}*/, name->str_text));
X	assert(symtab);
X	data = 0;
X	if (special)
X		data = symtab_query(special, name);
X	if (!data)
X		data = symtab_query(symtab, name);
X	if (data)
X		result = str_copy(data);
X	else
X	{
X		wl_append_unique(reference, name);
X		result = str_format("[%S]", name);
X	}
X	trace(("return \"%s\";\n", result->str_text));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X#ifdef DEBUG
X
Xstatic char *unctrl _((int));
X
Xstatic char *
Xunctrl(c)
X	int		c;
X{
X	static char	buf[5];
X
X	if (c == '\n')
X		return "\\n";
X	if (c == '^' || c == '\\' || c == '\'')
X	{
X		buf[0] = '\\';
X		buf[1] = c;
X		buf[2] = 0;
X		return buf;
X	}
X	if (isprint(c))
X	{
X		buf[0] = c;
X		buf[1] = 0;
X		return buf;
X	}
X	c ^= 0x40;
X	if (isprint(c))
X	{
X		buf[0] = '^';
X		buf[1] = c;
X		buf[2] = 0;
X		return buf;
X	}
X	c ^= 0x40;
X	buf[0] = '\\';
X	buf[1] = '0' + ((c >> 6) & 3);
X	buf[2] = '0' + ((c >> 3) & 7);
X	buf[3] = '0' + (c & 7);
X	buf[4] = 0;
X	return buf;
X}
X
X#endif
X
X
Xint
Xvargram_lex()
X{
X	int		c;
X	int		len;
X	char		buf[5];
X	int		token;
X
X	trace(("vargram_lex()\n{\n"/*}*/));
X	len = 0;
X	c = (unsigned char)*lexpos++;
X	trace(("c = '%s';\n", unctrl(c)));
X	switch (c)
X	{
X	case 0:
X		--lexpos;
X		token = 0;
X		goto done;
X
X	case '$':
X		token = DOLLAR;
X		goto done;
X
X	case ':':
X		token = COLON;
X		goto done;
X
X	case '=':
X		token = EQU;
X		goto done;
X
X	case ',':
X		token = COMMA;
X		goto done;
X
X	case ' ':
X	case '\f':
X	case '\n':
X	case '\t':
X#if __STDC__ >= 1
X	case '\v':
X#endif
X		token = SPACE;
X		goto done;
X
X	case '(':
X		token = LP;
X		goto done;
X
X	case ')':
X		token = RP;
X		goto done;
X
X	case '{':
X		token = LB;
X		goto done;
X
X	case '}':
X		token = RB;
X		goto done;
X
X	case '\\':
X		c = (unsigned char)*lexpos++;
X		trace(("c = '%s';\n", unctrl(c)));
X		if (!c)
X		{
X			--lexpos;
X			c = '\\';
X		}
X		break;
X	}
X
X	len = 0;
X	switch (c)
X	{
X	case '\b':
X		buf[len++] = '\\';
X		buf[len++] = 'b';
X		break;
X
X	case '\f':
X		buf[len++] = '\\';
X		buf[len++] = 'f';
X		break;
X
X	case '\n':
X		buf[len++] = '\\';
X		buf[len++] = 'n';
X		break;
X
X	case '\t':
X		buf[len++] = '\\';
X		buf[len++] = 't';
X		break;
X
X#if __STDC__ >= 1
X	case '\v':
X		buf[len++] = '\\';
X		buf[len++] = 'v';
X		break;
X#endif
X
X	case ' ':
X	case ';':
X	case ':':
X	case '=':
X	case '"':
X	case '\'':
X	case '\\':
X	case '{'/*}*/:
X	case /*{*/'}':
X		buf[len++] = '\\';
X		buf[len++] = c;
X		break;
X
X	default:
X		if (!isprint(c))
X		{
X			buf[len++] = '\\';
X			if (isdigit(*lexpos) || (c & 0300))
X				buf[len++] = '0' + ((c >> 6) & 3);
X			if (isdigit(*lexpos) || (c & 0370))
X				buf[len++] = '0' + ((c >> 3) & 7);
X			buf[len++] = '0' + (c & 7);
X		}
X		else
X			buf[len++] = c;
X		break;
X	}
X	vargram_lval.lv_string = str_n_from_c(buf, len);
X	token = PLAIN;
X
X	done:
X	trace(("return %d;\n", token));
X	trace((/*{*/"}\n"));
X	return token;
X}
X
X
Xvoid
Xvargram_error(fmt sva_last)
X	char		*fmt;
X	sva_last_decl
X{
X	va_list		ap;
X	string_ty	*s;
X	int		len;
X
X	sva_init(ap, s);
X	s = str_vformat(fmt, ap);
X	va_end(ap);
X
X	len = s->str_length;
X	if (len > 0 && s->str_text[len - 1] == '\n')
X		--len;
X	blob_error(source, "variable reference %.*S", len, s);
X	str_free(s);
X}
X
X
Xvoid
Xvargram_result(s)
X	string_ty	*s;
X{
X	static string_ty *t1;
X	static string_ty *t2;
X	string_ty	*tmp;
X
X	trace(("vargram_result(\"%s\")\n{\n"/*}*/, s->str_text));
X	if (!s->str_length)
X	{
X		str_free(s);
X		s = str_from_c("\"\"");
X	}
X	if (!t1)
X	{
X		t1 = str_from_c("/*");
X		t2 = str_from_c("/\\*");
X	}
X	tmp = str_substitute(t1, t2, s);
X	str_free(s);
X	wl_append(&result, tmp);
X	str_free(tmp);
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xvariable_rename(in, out, ref)
X	blob_ty		*in;
X	blob_list_ty	*out;
X	wlist		*ref;
X{
X	size_t		j;
X
X	trace(("variable_rename(in = %08lX, out = %08lX, ref = %08lX)\n{\n"/*}*/, (long)in, (long)out, (long)ref));
X	trace_string(in->text->str_text);
X	init();
X	source = in;
X	lexpos = in->text->str_text;
X	reference = ref;
X	vargram_parse();
X	for (j = 0; j < result.wl_nwords; ++j)
X	{
X		blob_list_append
X		(
X			out,
X			blob_alloc
X			(
X				str_copy(result.wl_word[j]),
X				in->file_name,
X				in->line_number
X			)
X		);
X	}
X	wl_free(&result);
X	if (special)
X	{
X		symtab_free(special);
X		special = 0;
X	}
X	trace((/*{*/"}\n"));
X}
X
X
Xstatic void reap _((void *));
X
Xstatic void
Xreap(p)
X	void		*p;
X{
X	string_ty	*s;
X
X	s = p;
X	str_free(s);
X}
X
X
Xvoid
Xvariable_archive(target, member)
X	string_ty	*target;
X	string_ty	*member;
X{
X	string_ty	*name;
X	string_ty	*value;
X
X	assert(!special);
X	special = symtab_alloc(6);
X	special->reap = reap;
X
X	name = str_from_c("%");
X	value = str_copy(member);
X	symtab_assign(special, name, value);
X	str_free(name);
X
X	name = str_from_c("%D");
X	value = str_format("[dirname %S]", member);
X	symtab_assign(special, name, value);
X	str_free(name);
X
X	name = str_from_c("%F");
X	value = str_format("[entryname %S]", member);
X	symtab_assign(special, name, value);
X	str_free(name);
X
X	name = str_from_c("@");
X	value = str_copy(target);
X	symtab_assign(special, name, value);
X	str_free(name);
X
X	name = str_from_c("@D");
X	value = str_format("[dirname %S]", target);
X	symtab_assign(special, name, value);
X	str_free(name);
X
X	name = str_from_c("@F");
X	value = str_format("[entryname %S]", target);
X	symtab_assign(special, name, value);
X	str_free(name);
X}
END_OF_FILE
if test 7666 -ne `wc -c <'make2cook/variable.c'`; then
    echo shar: \"'make2cook/variable.c'\" unpacked with wrong size!
fi
# end of 'make2cook/variable.c'
fi
if test -f 'roffpp/preprocess.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'roffpp/preprocess.c'\"
else
echo shar: Extracting \"'roffpp/preprocess.c'\" \(8215 characters\)
sed "s/^X//" >'roffpp/preprocess.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to eliminate include files
X */
X
X#include <ctype.h>
X#include <stdio.h>
X#include <ac/stdlib.h>
X#include <ac/unistd.h>
X
X#include <error.h>
X#include <mem.h>
X#include <preprocess.h>
X#include <str.h>
X#include <trace.h>
X#include <word.h>
X
Xstatic	wlist	search;
Xstatic	char	*ofn;
Xstatic	FILE	*ofp;
X
X
X/*
X * NAME
X *	preprocess_include
X *
X * SYNOPSIS
X *	void preprocess_include(char *path);
X *
X * DESCRIPTION
X *	The preprocess_include function is used to append
X *	to the include search path.
X *
X * ARGUMENTS
X *	path	- path to append
X */
X
Xvoid
Xpreprocess_include(path)
X	char		*path;
X{
X	string_ty	*s;
X
X	trace(("preprocess_include(path = \"%s\")\n{\n"/*}*/, path));
X	s = str_from_c(path);
X	wl_append_unique(&search, s);
X	str_free(s);
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	source
X *
X * SYNOPSIS
X *	int source(char *line);
X *
X * DESCRIPTION
X *	The source function is used to test if a line of tect is
X *	a .so directive, and to insert the contents of the sourced
X *	file at this point.
X *
X * ARGUMENTS
X *	line	- pointer to line of text
X *
X * RETURNS
X *	int;	zero if is not a .so directive,
X *		non-zero if it is a .so directive
X */
X
Xstatic void scan _((string_ty *)); /* forward */
X
Xstatic int source _((char *));
X
Xstatic int
Xsource(line)
X	char		*line;
X{
X	string_ty	*filename;
X	size_t		j;
X	int		result;
X	char		*ep;
X	static string_ty *dot;
X
X	/*
X	 * see if this is a .so directive
X	 */
X	if (*line != '.')
X		return 0;
X	trace(("source(line = \"%s\")\n{\n"/*}*/, line));
X	result = 0;
X	line++;
X	while (isspace(*line))
X		line++;
X	if (line[0] != 's' || line[1] != 'o' || !isspace(line[2]))
X		goto ret;
X	line += 3;
X	while (isspace(*line))
X		line++;
X	if (!*line)
X		goto ret;
X
X	/*
X	 * find the end of the argument
X	 */
X	for (ep = line + 1; *ep && !isspace(*ep); ++ep)
X		;
X	filename = str_n_from_c(line, ep - line);
X
X	/*
X	 * no need to search when it's an absolute path
X	 */
X	if (*line == '/')
X	{
X		scan(filename);
X		str_free(filename);
X		result = 1;
X		goto ret;
X	}
X
X	/*
X	 * search for the name in the search list
X	 */
X	if (!dot)
X		dot = str_from_c(".");
X	for (j = 0; j < search.wl_nwords; ++j)
X	{
X		string_ty	*s;
X		string_ty	*dir;
X
X		dir = search.wl_word[j];
X		if (str_equal(dir, dot))
X			s = str_copy(filename);
X		else
X			s = str_format("%S/%S", dir, filename);
X		if (access(s->str_text, F_OK) == 0)
X		{
X			str_free(filename);
X			scan(s);
X			str_free(s);
X			result = 1;
X			goto ret;
X		}
X		str_free(s);
X	}
X	str_free(filename);
X
X	/*
X	 * let {ps,n,t,dit,pt}roff bomb later
X	 */
X	result = 0;
X
X	/*
X	 * here for all exits
X	 */
X	ret:
X	trace(("return %d;\n", result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X/*
X * NAME
X *	lf_directive
X *
X * SYNOPSIS
X *	int lf_directive(char *line, string_ty **ifn, long *lino);
X *
X * DESCRIPTION
X *	The lf_directive function is used to test if a line of text is
X *	a .lf directive, and to adjust the file position to this point.
X *
X * ARGUMENTS
X *	line	- pointer to line of text
X *	ifn	- file name (ptr) if needs changing
X *	lino	- line number (ptr) if needs changing
X *
X * RETURNS
X *	int;	zero if is not a .so directive,
X *		non-zero if it is a .so directive
X */
X
Xstatic int lf_directive _((char *line, string_ty **ifn, long *lino));
X
Xstatic int
Xlf_directive(line, ifn, lino)
X	char		*line;
X	string_ty	**ifn;
X	long		*lino;
X{
X	int		result;
X	long		n;
X	string_ty	*s;
X	char		*ep;
X
X	/*
X	 * see if this is a .so directive
X	 */
X	if (*line != '.')
X		return 0;
X	trace(("source(line = \"%s\")\n{\n"/*}*/, line));
X	result = 0;
X	line++;
X	while (isspace(*line))
X		line++;
X	if (line[0] != 'l' || line[1] != 'f' || !isspace(line[2]))
X		goto ret;
X	line += 3;
X	while (isspace(*line))
X		line++;
X	if (!*line)
X		goto ret;
X
X	/*
X	 * find the line number
X	 */
X	for (ep = line + 1; *ep && !isspace(*ep); ++ep)
X		;
X	s = str_n_from_c(line, ep - line);
X	n = atol(s->str_text);
X	str_free(s);
X	if (n <= 0)
X		goto ret;
X	*lino = n - 1;
X	result = 1;
X
X	/*
X	 * find the file name
X	 */
X	line = ep;
X	while (*line && isspace(*line))
X		line++;
X	if (!*line)
X		goto ret;
X	for (ep = line + 1; *ep && !isspace(*ep); ++ep)
X		;
X	s = str_n_from_c(line, ep - line);
X	if (*ifn)
X		str_free(*ifn);
X	*ifn = s;
X
X	/*
X	 * here for all exits
X	 */
X	ret:
X	trace(("return %d;\n", result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	resync
X *
X * SYNOPSOS
X *	void resync(FILE *fp, char *name, long line);
X *
X * DESCRIPTION
X *	The resync function is used to emit appropriate
X *	*roff requests to resynchronize the *roff engine
X *	to the correct file name and line numner,
X *	so that error messages, etc al, are meaningful.
X *
X * ARGUMENTS
X *	fp	- file stream to print on
X *	name	- name of input file
X *	line	- num number in the input file
X */
X
Xstatic void resync _((FILE *, string_ty *, long));
X
Xstatic void
Xresync(ofp, file, line)
X	FILE		*ofp;
X	string_ty	*file;
X	long		line;
X{
X	fprintf(ofp, ".lf %ld %s\n", line, file->str_text);
X}
X
X
X/*
X * NAME
X *	scan
X *
X * SYNOPSIS
X *	void scan(char *path);
X *
X * DESCRIPTION
X *	The scan function is used to can a file, copying its contents
X *	to the output, replacing .so directives with the contents of
X *	the included files.
X *
X * ARGUMENTS
X *	path	- name of file to scan
X */
X
Xstatic void scan _((string_ty *));
X
Xstatic void
Xscan(ifn)
X	string_ty	*ifn;
X{
X	FILE		*ifp;
X	size_t		pos;
X	static size_t	max;
X	static char	*line;
X	long		lino;
X	int		c;
X	string_ty	*ifn2;
X
X	trace(("scan(ifn = \"%s\")\n{\n"/*}*/, ifn ? ifn->str_text : "-"));
X	if (ifn)
X	{
X		ifp = fopen(ifn->str_text, "r");
X		if (!ifp)
X			nfatal("open \"%s\"", ifn->str_text);
X	}
X	else
X	{
X		ifn = str_from_c("(stdin)");
X		ifp = stdin;
X	}
X	ifn2 = str_copy(ifn);
X
X	lino = 1;
X	resync(ofp, ifn2, lino);
X
X	pos = 0;
X	for (;;)
X	{
X		if (pos >= max)
X		{
X			max += 100;
X			line = mem_change_size(line, max);
X		}
X		c = getc(ifp);
X		switch (c)
X		{
X		case EOF:
X			if (ferror(ifp))
X				nfatal("read \"%s\"", ifn->str_text);
X			if (!pos)
X				break;
X			/* fall through... */
X
X		case '\n':
X			line[pos] = 0;
X			if (source(line) || lf_directive(line, &ifn2, &lino))
X				resync(ofp, ifn2, lino + 1);
X			else
X			{
X				fputs(line, ofp);
X				putc('\n', ofp);
X			}
X			if (ferror(ofp))
X				nfatal("write \"%s\"", ofn);
X			lino++;
X			pos = 0;
X			continue;
X
X		default:
X			line[pos++] = c;
X			continue;
X		}
X		break;
X	}
X
X	if (ifp != stdin && fclose(ifp))
X		nfatal("close \"%s\"", ifn);
X	str_free(ifn2);
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	preprocess
X *
X * SYNOPSIS
X *	void preprocess(char *infile, char *outfile);
X *
X * DESCRIPTION
X *	The preprocess function is used to process an *roff file and
X *	eliminate the .so directives, replacing them with the contents
X *	of the included files.
X *
X * ARGUMENTS
X *	infile	- name of file to scan, NULL means stdin
X *	outfile	- name of file to hold result, NULL means stdout
X */
X
Xvoid
Xpreprocess(ifile, ofile)
X	char		*ifile;
X	char		*ofile;
X{
X	string_ty	*s;
X
X	/*
X	 * default the search path iff the user specified nothing
X	 */
X	trace(("preprocess(ifile = \"%s\", ofile = \"%s\")\n{\n"/*}*/,
X		ifile ? ifile : "-", ofile ? ofile : "-"));
X	if (!search.wl_nwords)
X		preprocess_include(".");
X
X	/*
X	 * open the output file
X	 */
X	if (ofile)
X	{
X		ofn = ofile;
X		ofp = fopen(ofn, "w");
X		if (!ofp)
X			nfatal("create \"%s\"", ofn);
X	}
X	else
X	{
X		ofn = "(stdout)";
X		ofp = stdout;
X	}
X
X	/*
X	 * scan the input
X	 */
X	if (ifile)
X		s = str_from_c(ifile);
X	else
X		s = 0;
X	scan(s);
X	if (s)
X		str_free(s);
X
X	/*
X	 * close up and go home
X	 */
X	if (ofp != stdout && fclose(ofp))
X		nfatal("close \"%s\"", ofn);
X	trace((/*{*/"}\n"));
X}
END_OF_FILE
if test 8215 -ne `wc -c <'roffpp/preprocess.c'`; then
    echo shar: \"'roffpp/preprocess.c'\" unpacked with wrong size!
fi
# end of 'roffpp/preprocess.c'
fi
echo shar: End of archive 9 \(of 19\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 19 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
