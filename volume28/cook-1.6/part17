Newsgroups: comp.sources.unix
From: pmiller@bmr.gov.au (Peter Miller)
Subject: v28i110: cook - a file construction tool, V1.6, Part17/19
References: <1.775008949.28543@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: pmiller@bmr.gov.au (Peter Miller)
Posting-Number: Volume 28, Issue 110
Archive-Name: cook-1.6/part17

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 17 (of 19)."
# Contents:  Makefile.in cook/cook.c
# Wrapped by vixie@gw.home.vix.com on Sat Jul 23 17:11:29 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.in'\"
else
echo shar: Extracting \"'Makefile.in'\" \(49736 characters\)
sed "s/^X//" >'Makefile.in' <<'END_OF_FILE'
X#
X#	cook - file construction tool
X#	Copyright (C) 1990, 1991, 1992, 1993, 1994 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: instructions to make, how to build the cook package
X#
X
X#
X# directory containing the source
X#
Xsrcdir = @srcdir@
XVPATH = @srcdir@
X
X#
X# the name of the install program to use
X#
XINSTALL = @INSTALL@
XINSTALL_PROGRAM = @INSTALL_PROGRAM@
XINSTALL_DATA = @INSTALL_DATA@
X
X#
X# the name of the compiler to use
X#
XCC = @CC@
X
X#
X# The compiler flags to use
X#
XCFLAGS = -O
X
X#
X# The linker flags to use
X#
XLDFLAGS = -s
X
X#
X# prefix for installation path
X#
Xprefix = /usr/local
Xexec_prefix = $(prefix)
X
X#
X# where to put the library directory
X#	(contains data, don't use exec_prefix)
X#
Xlibdir = $(prefix)/lib/cook
X
X#
X# where to put the executables
X#
Xbindir = $(exec_prefix)/bin
X
X#
X# where to put the manuals
X#
Xmandir = $(prefix)/man
X
X#
X# Which yacc to use
X#
XYACC = @YACC@
X
X#
X# extra libraries required for your system
X#
XLIBS = @LIBS@
X
X#
X# shell to use to run tests and commands
X#
XSH = @SH@
X
X#
X# command used to construct libraries
X#
XAR = ar
X
X#
X# program used to place index within libraries
X#
XRANLIB = @RANLIB@
X
X#
X# You should not need to alter anything below this point.
X#------------------------------------------------------------
X
Xall: bin/c_incl bin/cook bin/cookfp bin/cooktime bin/find_libs \
X	bin/make2cook bin/roffpp
X
Xc_incl/cache.o: c_incl/cache.c common/ac/string.h common/config.h \
X		common/arglex.h common/main.h c_incl/cache.h \
X		common/str.h common/ac/stddef.h common/s-v-arg.h \
X		common/word.h common/error.h common/mem.h c_incl/os.h \
X		common/symtab.h 
X	$(CC) $(CFLAGS) -Ic_incl -Icommon -c c_incl/cache.c
X	mv cache.o c_incl/cache.o
X
Xc_incl/lang_c.o: c_incl/lang_c.c common/ac/string.h common/config.h \
X		common/error.h common/main.h common/mem.h \
X		common/ac/stddef.h c_incl/sniff.h common/trace.h \
X		common/word.h common/str.h common/s-v-arg.h 
X	$(CC) $(CFLAGS) -Ic_incl -Icommon -c c_incl/lang_c.c
X	mv lang_c.o c_incl/lang_c.o
X
Xc_incl/lang_roff.o: c_incl/lang_roff.c common/ac/string.h \
X		common/config.h common/error.h common/main.h \
X		common/mem.h common/ac/stddef.h c_incl/sniff.h \
X		common/trace.h common/word.h common/str.h \
X		common/s-v-arg.h 
X	$(CC) $(CFLAGS) -Ic_incl -Icommon -c c_incl/lang_roff.c
X	mv lang_roff.o c_incl/lang_roff.o
X
Xc_incl/main.o: c_incl/main.c common/ac/stddef.h common/config.h \
X		common/ac/string.h common/ac/stdlib.h common/arglex.h \
X		common/main.h c_incl/cache.h common/str.h \
X		common/s-v-arg.h common/word.h common/error.h \
X		common/help.h c_incl/sniff.h common/trace.h \
X		common/version.h man1/c_incl.h 
X	$(CC) $(CFLAGS) -Ic_incl -Icommon -c c_incl/main.c
X	mv main.o c_incl/main.o
X
Xc_incl/os.o: c_incl/os.c common/error.h common/main.h c_incl/os.h
X	$(CC) $(CFLAGS) -Ic_incl -Icommon -c c_incl/os.c
X	mv os.o c_incl/os.o
X
Xc_incl/sniff.o: c_incl/sniff.c common/ac/stddef.h common/config.h \
X		common/ac/string.h c_incl/cache.h common/main.h \
X		common/str.h common/s-v-arg.h common/word.h \
X		common/error.h common/mem.h c_incl/os.h c_incl/sniff.h \
X		common/trace.h 
X	$(CC) $(CFLAGS) -Ic_incl -Icommon -c c_incl/sniff.c
X	mv sniff.o c_incl/sniff.o
X
Xcommon/ansi.o: common/ansi.c common/ac/stddef.h common/config.h \
X		common/ac/stdlib.h common/ac/string.h common/main.h 
X	$(CC) $(CFLAGS) -Icommon -Icommon -c common/ansi.c
X	mv ansi.o common/ansi.o
X
Xcommon/arglex.o: common/arglex.c common/ac/stddef.h common/config.h \
X		common/ac/stdlib.h common/ac/string.h common/main.h \
X		common/arglex.h common/error.h common/word.h \
X		common/str.h common/s-v-arg.h common/mem.h \
X		common/trace.h 
X	$(CC) $(CFLAGS) -Icommon -Icommon -c common/arglex.c
X	mv arglex.o common/arglex.o
X
Xcommon/error.o: common/error.c common/ac/stddef.h common/config.h \
X		common/ac/stdlib.h common/ac/string.h common/ac/time.h \
X		common/arglex.h common/main.h common/error.h \
X		common/mprintf.h common/s-v-arg.h 
X	$(CC) $(CFLAGS) -Icommon -Icommon -c common/error.c
X	mv error.o common/error.o
X
Xcommon/fp.o: common/fp.c common/ac/fcntl.h common/config.h \
X		common/ac/unistd.h common/fp.h common/main.h \
X		common/mem.h common/ac/stddef.h 
X	$(CC) $(CFLAGS) -Icommon -Icommon -c common/fp.c
X	mv fp.o common/fp.o
X
Xcommon/fp/cksum.o: common/fp/cksum.c common/fp/cksum.h common/fp.h \
X		common/main.h common/fp/crc32.h common/fp/len.h 
X	$(CC) $(CFLAGS) -Icommon -Icommon -c common/fp/cksum.c
X	mv cksum.o common/fp/cksum.o
X
Xcommon/fp/combined.o: common/fp/combined.c common/error.h common/main.h \
X		common/fp/combined.h common/fp.h common/fp/crc32.h \
X		common/fp/len.h common/fp/md5.h common/fp/snefru.h 
X	$(CC) $(CFLAGS) -Icommon -Icommon -c common/fp/combined.c
X	mv combined.o common/fp/combined.o
X
Xcommon/fp/crc32.o: common/fp/crc32.c common/fp/crc32.h common/fp.h \
X		common/main.h 
X	$(CC) $(CFLAGS) -Icommon -Icommon -c common/fp/crc32.c
X	mv crc32.o common/fp/crc32.o
X
Xcommon/fp/len.o: common/fp/len.c common/fp/len.h common/fp.h \
X		common/main.h 
X	$(CC) $(CFLAGS) -Icommon -Icommon -c common/fp/len.c
X	mv len.o common/fp/len.o
X
Xcommon/fp/md5.o: common/fp/md5.c common/fp/md5.h common/fp.h \
X		common/main.h 
X	$(CC) $(CFLAGS) -Icommon -Icommon -c common/fp/md5.c
X	mv md5.o common/fp/md5.o
X
Xcommon/fp/snefru.o: common/fp/snefru.c common/fp/snefru.h common/fp.h \
X		common/main.h 
X	$(CC) $(CFLAGS) -Icommon -Icommon -c common/fp/snefru.c
X	mv snefru.o common/fp/snefru.o
X
Xcommon/help.o: common/help.c common/ac/string.h common/config.h \
X		common/ac/stdlib.h common/ac/unistd.h common/arglex.h \
X		common/main.h common/error.h common/help.h common/mem.h \
X		common/ac/stddef.h common/version-stmp.h \
X		common/s-v-arg.h common/str.h common/trace.h \
X		man1/o__rules.h man1/z_exit.h 
X	$(CC) $(CFLAGS) -Icommon -Icommon -c common/help.c
X	mv help.o common/help.o
X
Xcommon/mem.o: common/mem.c common/ac/stddef.h common/config.h \
X		common/ac/string.h common/ac/stdlib.h common/mem.h \
X		common/main.h common/error.h 
X	$(CC) $(CFLAGS) -Icommon -Icommon -c common/mem.c
X	mv mem.o common/mem.o
X
Xcommon/mprintf.o: common/mprintf.c common/ac/stdlib.h common/config.h \
X		common/ac/string.h common/error.h common/main.h \
X		common/mprintf.h common/s-v-arg.h common/str.h \
X		common/ac/stddef.h 
X	$(CC) $(CFLAGS) -Icommon -Icommon -c common/mprintf.c
X	mv mprintf.o common/mprintf.o
X
Xcommon/str.o: common/str.c common/ac/stddef.h common/config.h \
X		common/ac/stdlib.h common/ac/string.h common/error.h \
X		common/main.h common/mem.h common/mprintf.h \
X		common/s-v-arg.h common/str.h 
X	$(CC) $(CFLAGS) -Icommon -Icommon -c common/str.c
X	mv str.o common/str.o
X
Xcommon/symtab.o: common/symtab.c common/error.h common/main.h \
X		common/mem.h common/ac/stddef.h common/config.h \
X		common/symtab.h common/str.h common/s-v-arg.h \
X		common/trace.h 
X	$(CC) $(CFLAGS) -Icommon -Icommon -c common/symtab.c
X	mv symtab.o common/symtab.o
X
Xcommon/trace.o: common/trace.c common/ac/stddef.h common/config.h \
X		common/ac/string.h common/error.h common/main.h \
X		common/mem.h common/arglex.h common/s-v-arg.h \
X		common/str.h common/trace.h 
X	$(CC) $(CFLAGS) -Icommon -Icommon -c common/trace.c
X	mv trace.o common/trace.o
X
Xcommon/version-stmp.o: common/version-stmp.c common/patchlevel.h \
X		common/version-stmp.h common/main.h 
X	$(CC) $(CFLAGS) -Icommon -Icommon -c common/version-stmp.c
X	mv version-stmp.o common/version-stmp.o
X
Xcommon/version.o: common/version.c common/ac/stdlib.h common/config.h \
X		common/arglex.h common/main.h common/error.h \
X		common/help.h common/str.h common/ac/stddef.h \
X		common/s-v-arg.h common/version.h 
X	$(CC) $(CFLAGS) -Icommon -Icommon -c common/version.c
X	mv version.o common/version.o
X
Xcommon/word.o: common/word.c common/ac/stddef.h common/config.h \
X		common/ac/string.h common/ac/stdlib.h common/ac/time.h \
X		common/error.h common/main.h common/mem.h common/str.h \
X		common/s-v-arg.h common/word.h 
X	$(CC) $(CFLAGS) -Icommon -Icommon -c common/word.c
X	mv word.o common/word.o
X
Xcook/archive.o: cook/archive.c common/ac/ar.h common/config.h \
X		common/ac/fcntl.h common/ac/stdlib.h common/ac/string.h \
X		common/ac/unistd.h cook/archive.h common/str.h \
X		common/ac/stddef.h common/main.h common/s-v-arg.h \
X		common/error.h common/fp.h common/mem.h common/trace.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/archive.c
X	mv archive.o cook/archive.o
X
Xcook/builtin.o: cook/builtin.c cook/builtin.h common/word.h \
X		common/str.h common/ac/stddef.h common/config.h \
X		common/main.h common/s-v-arg.h cook/builtin/addprefix.h \
X		cook/builtin/addsuffix.h cook/builtin/basename.h \
X		cook/builtin/boolean.h cook/builtin/collect.h \
X		cook/builtin/cook.h cook/builtin/defined.h \
X		cook/builtin/execute.h cook/builtin/exists.h \
X		cook/builtin/filter_out.h cook/builtin/find_command.h \
X		cook/builtin/findstring.h cook/builtin/getenv.h \
X		cook/builtin/glob.h cook/builtin/home.h \
X		cook/builtin/join.h cook/builtin/match.h \
X		cook/builtin/opsys.h cook/builtin/pathname.h \
X		cook/builtin/split.h cook/builtin/stringset.h \
X		cook/builtin/strip.h cook/builtin/subst.h \
X		cook/builtin/suffix.h cook/builtin/text.h \
X		cook/builtin/unsplit.h cook/builtin/word.h \
X		common/symtab.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin.c
X	mv builtin.o cook/builtin.o
X
Xcook/builtin/addprefix.o: cook/builtin/addprefix.c \
X		cook/builtin/addprefix.h common/word.h common/str.h \
X		common/ac/stddef.h common/config.h common/main.h \
X		common/s-v-arg.h cook/expr.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/addprefix.c
X	mv addprefix.o cook/builtin/addprefix.o
X
Xcook/builtin/addsuffix.o: cook/builtin/addsuffix.c \
X		cook/builtin/addsuffix.h common/word.h common/str.h \
X		common/ac/stddef.h common/config.h common/main.h \
X		common/s-v-arg.h cook/expr.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/addsuffix.c
X	mv addsuffix.o cook/builtin/addsuffix.o
X
Xcook/builtin/basename.o: cook/builtin/basename.c common/ac/string.h \
X		common/config.h cook/builtin/basename.h common/word.h \
X		common/str.h common/ac/stddef.h common/main.h \
X		common/s-v-arg.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/basename.c
X	mv basename.o cook/builtin/basename.o
X
Xcook/builtin/boolean.o: cook/builtin/boolean.c cook/builtin/boolean.h \
X		common/word.h common/str.h common/ac/stddef.h \
X		common/config.h common/main.h common/s-v-arg.h \
X		common/error.h cook/expr.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/boolean.c
X	mv boolean.o cook/builtin/boolean.o
X
Xcook/builtin/collect.o: cook/builtin/collect.c common/ac/string.h \
X		common/config.h cook/builtin/collect.h common/word.h \
X		common/str.h common/ac/stddef.h common/main.h \
X		common/s-v-arg.h common/error.h cook/expr.h \
X		cook/option.h cook/os.h common/ac/time.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/collect.c
X	mv collect.o cook/builtin/collect.o
X
Xcook/builtin/cook.o: cook/builtin/cook.c common/ac/stdlib.h \
X		common/config.h cook/builtin/cook.h common/word.h \
X		common/str.h common/ac/stddef.h common/main.h \
X		common/s-v-arg.h cook/cook.h common/ac/time.h \
X		cook/expr.h cook/stmt.h common/error.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/cook.c
X	mv cook.o cook/builtin/cook.o
X
Xcook/builtin/defined.o: cook/builtin/defined.c cook/builtin/defined.h \
X		common/word.h common/str.h common/ac/stddef.h \
X		common/config.h common/main.h common/s-v-arg.h \
X		common/error.h cook/expr.h cook/id.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/defined.c
X	mv defined.o cook/builtin/defined.o
X
Xcook/builtin/execute.o: cook/builtin/execute.c cook/builtin/execute.h \
X		common/word.h common/str.h common/ac/stddef.h \
X		common/config.h common/main.h common/s-v-arg.h \
X		common/error.h cook/expr.h cook/option.h cook/os.h \
X		common/ac/time.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/execute.c
X	mv execute.o cook/builtin/execute.o
X
Xcook/builtin/exists.o: cook/builtin/exists.c cook/builtin/exists.h \
X		common/word.h common/str.h common/ac/stddef.h \
X		common/config.h common/main.h common/s-v-arg.h \
X		common/error.h cook/expr.h cook/os.h common/ac/time.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/exists.c
X	mv exists.o cook/builtin/exists.o
X
Xcook/builtin/filter_out.o: cook/builtin/filter_out.c \
X		cook/builtin/filter_out.h common/word.h common/str.h \
X		common/ac/stddef.h common/config.h common/main.h \
X		common/s-v-arg.h common/error.h cook/expr.h \
X		cook/match.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/filter_out.c
X	mv filter_out.o cook/builtin/filter_out.o
X
Xcook/builtin/find_command.o: cook/builtin/find_command.c \
X		common/ac/stdlib.h common/config.h common/ac/string.h \
X		cook/builtin/find_command.h common/word.h common/str.h \
X		common/ac/stddef.h common/main.h common/s-v-arg.h \
X		common/error.h cook/expr.h cook/os.h common/ac/time.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/find_command.c
X	mv find_command.o cook/builtin/find_command.o
X
Xcook/builtin/findstring.o: cook/builtin/findstring.c \
X		cook/builtin/findstring.h common/word.h common/str.h \
X		common/ac/stddef.h common/config.h common/main.h \
X		common/s-v-arg.h cook/expr.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/findstring.c
X	mv findstring.o cook/builtin/findstring.o
X
Xcook/builtin/getenv.o: cook/builtin/getenv.c common/ac/stdlib.h \
X		common/config.h cook/builtin/getenv.h common/word.h \
X		common/str.h common/ac/stddef.h common/main.h \
X		common/s-v-arg.h common/error.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/getenv.c
X	mv getenv.o cook/builtin/getenv.o
X
Xcook/builtin/glob.o: cook/builtin/glob.c common/ac/stddef.h \
X		common/config.h common/ac/stdlib.h common/ac/dirent.h \
X		common/ac/unistd.h cook/builtin/glob.h common/word.h \
X		common/str.h common/main.h common/s-v-arg.h \
X		common/trace.h common/mem.h common/error.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/glob.c
X	mv glob.o cook/builtin/glob.o
X
Xcook/builtin/home.o: cook/builtin/home.c common/ac/stdlib.h \
X		common/config.h cook/builtin/home.h common/word.h \
X		common/str.h common/ac/stddef.h common/main.h \
X		common/s-v-arg.h common/error.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/home.c
X	mv home.o cook/builtin/home.o
X
Xcook/builtin/join.o: cook/builtin/join.c cook/builtin/join.h \
X		common/word.h common/str.h common/ac/stddef.h \
X		common/config.h common/main.h common/s-v-arg.h \
X		cook/expr.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/join.c
X	mv join.o cook/builtin/join.o
X
Xcook/builtin/match.o: cook/builtin/match.c cook/builtin/match.h \
X		common/word.h common/str.h common/ac/stddef.h \
X		common/config.h common/main.h common/s-v-arg.h \
X		common/error.h cook/expr.h cook/match.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/match.c
X	mv match.o cook/builtin/match.o
X
Xcook/builtin/opsys.o: cook/builtin/opsys.c cook/builtin/opsys.h \
X		common/word.h common/str.h common/ac/stddef.h \
X		common/config.h common/main.h common/s-v-arg.h \
X		common/error.h cook/expr.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/opsys.c
X	mv opsys.o cook/builtin/opsys.o
X
Xcook/builtin/pathname.o: cook/builtin/pathname.c \
X		cook/builtin/pathname.h common/word.h common/str.h \
X		common/ac/stddef.h common/config.h common/main.h \
X		common/s-v-arg.h common/error.h cook/expr.h cook/os.h \
X		common/ac/time.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/pathname.c
X	mv pathname.o cook/builtin/pathname.o
X
Xcook/builtin/split.o: cook/builtin/split.c cook/builtin/split.h \
X		common/word.h common/str.h common/ac/stddef.h \
X		common/config.h common/main.h common/s-v-arg.h \
X		cook/expr.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/split.c
X	mv split.o cook/builtin/split.o
X
Xcook/builtin/stringset.o: cook/builtin/stringset.c \
X		cook/builtin/stringset.h common/word.h common/str.h \
X		common/ac/stddef.h common/config.h common/main.h \
X		common/s-v-arg.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/stringset.c
X	mv stringset.o cook/builtin/stringset.o
X
Xcook/builtin/strip.o: cook/builtin/strip.c cook/builtin/strip.h \
X		common/word.h common/str.h common/ac/stddef.h \
X		common/config.h common/main.h common/s-v-arg.h \
X		common/mem.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/strip.c
X	mv strip.o cook/builtin/strip.o
X
Xcook/builtin/subst.o: cook/builtin/subst.c cook/builtin/subst.h \
X		common/word.h common/str.h common/ac/stddef.h \
X		common/config.h common/main.h common/s-v-arg.h \
X		cook/expr.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/subst.c
X	mv subst.o cook/builtin/subst.o
X
Xcook/builtin/suffix.o: cook/builtin/suffix.c common/ac/string.h \
X		common/config.h cook/builtin/suffix.h common/word.h \
X		common/str.h common/ac/stddef.h common/main.h \
X		common/s-v-arg.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/suffix.c
X	mv suffix.o cook/builtin/suffix.o
X
Xcook/builtin/text.o: cook/builtin/text.c common/ac/stdlib.h \
X		common/config.h common/ac/string.h cook/builtin/text.h \
X		common/word.h common/str.h common/ac/stddef.h \
X		common/main.h common/s-v-arg.h common/error.h \
X		cook/expr.h common/mem.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/text.c
X	mv text.o cook/builtin/text.o
X
Xcook/builtin/unsplit.o: cook/builtin/unsplit.c cook/builtin/unsplit.h \
X		common/word.h common/str.h common/ac/stddef.h \
X		common/config.h common/main.h common/s-v-arg.h \
X		cook/expr.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/unsplit.c
X	mv unsplit.o cook/builtin/unsplit.o
X
Xcook/builtin/word.o: cook/builtin/word.c cook/builtin/word.h \
X		common/word.h common/str.h common/ac/stddef.h \
X		common/config.h common/main.h common/s-v-arg.h \
X		cook/expr.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/builtin/word.c
X	mv word.o cook/builtin/word.o
X
Xcook/cook.o: cook/cook.c common/ac/stddef.h common/config.h \
X		common/ac/time.h cook/cook.h cook/expr.h common/str.h \
X		common/main.h common/s-v-arg.h common/word.h \
X		cook/stmt.h common/error.h cook/id.h cook/match.h \
X		common/mem.h cook/option.h cook/os.h common/symtab.h \
X		common/trace.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/cook.c
X	mv cook.o cook/cook.o
X
Xcook/env.o: cook/env.c common/ac/stddef.h common/config.h \
X		common/ac/stdlib.h common/ac/string.h common/main.h \
X		cook/env.h common/mem.h common/error.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/env.c
X	mv env.o cook/env.o
X
Xcook/expr.o: cook/expr.c common/ac/stddef.h common/config.h \
X		cook/builtin.h common/word.h common/str.h common/main.h \
X		common/s-v-arg.h cook/cook.h common/ac/time.h \
X		cook/expr.h cook/stmt.h common/error.h cook/id.h \
X		cook/lex.h cook/match.h common/mem.h cook/option.h \
X		common/trace.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/expr.c
X	mv expr.o cook/expr.o
X
Xcook/fngrprnt.gen.c cook/fngrprnt.gen.h: cook/fngrprnt.y
X	@echo Expect no conflicts:
X	$(YACC) -d cook/fngrprnt.y
X	sed -e 's/[yY][yY]/fngrprnt_/g' y.tab.c > cook/fngrprnt.gen.c
X	sed -e 's/[yY][yY]/fngrprnt_/g' y.tab.h > cook/fngrprnt.gen.h
X	rm y.tab.c y.tab.h
X
Xcook/fngrprnt.gen.o: cook/fngrprnt.gen.c common/ac/stdlib.h \
X		common/config.h common/ac/unistd.h cook/archive.h \
X		common/str.h common/ac/stddef.h common/main.h \
X		common/s-v-arg.h common/arglex.h common/error.h \
X		cook/fngrprnt.h common/ac/time.h cook/fngrprnt_lex.h \
X		common/fp/combined.h common/fp.h common/mem.h \
X		common/symtab.h common/trace.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/fngrprnt.gen.c
X	mv fngrprnt.gen.o cook/fngrprnt.gen.o
X
Xcook/fngrprnt_lex.o: cook/fngrprnt_lex.c common/error.h common/main.h \
X		cook/fngrprnt_lex.h common/str.h common/ac/stddef.h \
X		common/config.h common/s-v-arg.h cook/fngrprnt.gen.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/fngrprnt_lex.c
X	mv fngrprnt_lex.o cook/fngrprnt_lex.o
X
Xcook/hashline.gen.c cook/hashline.gen.h: cook/hashline.y
X	@echo Expect no conflicts:
X	$(YACC) -d cook/hashline.y
X	sed -e 's/[yY][yY]/hashline_/g' y.tab.c > cook/hashline.gen.c
X	sed -e 's/[yY][yY]/hashline_/g' y.tab.h > cook/hashline.gen.h
X	rm y.tab.c y.tab.h
X
Xcook/hashline.gen.o: cook/hashline.gen.c common/ac/stddef.h \
X		common/config.h common/ac/string.h common/ac/time.h \
X		common/ac/stdlib.h cook/cook.h cook/expr.h common/str.h \
X		common/main.h common/s-v-arg.h common/word.h \
X		cook/stmt.h common/error.h cook/hashline.h cook/lex.h \
X		common/mem.h cook/option.h cook/os.h common/trace.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/hashline.gen.c
X	mv hashline.gen.o cook/hashline.gen.o
X
Xcook/id.o: cook/id.c common/ac/stddef.h common/config.h \
X		common/ac/stdlib.h common/error.h common/main.h \
X		cook/id.h common/word.h common/str.h common/s-v-arg.h \
X		common/mem.h cook/option.h common/symtab.h \
X		common/version-stmp.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/id.c
X	mv id.o cook/id.o
X
Xcook/lex.o: cook/lex.c common/ac/stddef.h common/config.h \
X		common/ac/string.h common/ac/stdlib.h common/error.h \
X		common/main.h cook/expr.h common/str.h common/s-v-arg.h \
X		common/word.h cook/hashline.h cook/lex.h common/mem.h \
X		cook/option.h cook/stmt.h common/symtab.h \
X		common/trace.h cook/parse.gen.h cook/hashline.gen.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/lex.c
X	mv lex.o cook/lex.o
X
Xcook/listing.o: cook/listing.c common/ac/stddef.h common/config.h \
X		common/ac/string.h common/ac/time.h common/ac/unistd.h \
X		common/error.h common/main.h cook/listing.h cook/os.h \
X		common/str.h common/s-v-arg.h common/word.h \
X		cook/option.h common/trace.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/listing.c
X	mv listing.o cook/listing.o
X
Xcook/main.o: cook/main.c common/ac/stddef.h common/config.h \
X		common/ac/string.h common/ac/stdlib.h common/arglex.h \
X		common/main.h cook/builtin.h common/word.h common/str.h \
X		common/s-v-arg.h cook/cook.h common/ac/time.h \
X		cook/expr.h cook/stmt.h cook/env.h common/error.h \
X		common/help.h cook/id.h cook/lex.h cook/listing.h \
X		cook/option.h cook/parse.h common/trace.h \
X		common/version.h man1/cook.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/main.c
X	mv main.o cook/main.o
X
Xcook/match.o: cook/match.c common/ac/stddef.h common/config.h \
X		common/ac/string.h common/ac/stdlib.h common/main.h \
X		common/str.h common/s-v-arg.h cook/match.h \
X		common/word.h common/error.h common/mem.h \
X		common/trace.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/match.c
X	mv match.o cook/match.o
X
Xcook/option.o: cook/option.c common/ac/limits.h common/config.h \
X		common/ac/stddef.h common/ac/stdlib.h \
X		common/ac/string.h common/ac/time.h cook/option.h \
X		common/main.h common/str.h common/s-v-arg.h \
X		common/word.h common/error.h cook/os.h common/mem.h 
X	$(CC) $(CFLAGS) -D'LIBDIR="$(libdir)"' -Icook -Icommon -c cook/option.c
X	mv option.o cook/option.o
X
Xcook/os.o: cook/os.c common/ac/stddef.h common/config.h \
X		common/ac/string.h common/ac/stdlib.h \
X		common/ac/limits.h common/ac/time.h common/ac/unistd.h \
X		cook/archive.h common/str.h common/main.h \
X		common/s-v-arg.h common/error.h common/mem.h \
X		cook/option.h common/word.h cook/os.h cook/stat.cache.h \
X		common/trace.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/os.c
X	mv os.o cook/os.o
X
Xcook/parse.gen.c cook/parse.gen.h: cook/parse.y
X	@echo Expect 1 shift/reduce conflicts:
X	$(YACC) -d cook/parse.y
X	sed -e 's/[yY][yY]/parse_/g' y.tab.c > cook/parse.gen.c
X	sed -e 's/[yY][yY]/parse_/g' y.tab.h > cook/parse.gen.h
X	rm y.tab.c y.tab.h
X
Xcook/parse.gen.o: cook/parse.gen.c common/ac/stddef.h common/config.h \
X		common/ac/stdlib.h cook/cook.h common/ac/time.h \
X		cook/expr.h common/str.h common/main.h common/s-v-arg.h \
X		common/word.h cook/stmt.h common/error.h cook/lex.h \
X		common/mem.h cook/option.h cook/parse.h common/symtab.h \
X		common/trace.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/parse.gen.c
X	mv parse.gen.o cook/parse.gen.o
X
Xcook/stat.cache.o: cook/stat.cache.c common/ac/string.h common/config.h \
X		cook/archive.h common/str.h common/ac/stddef.h \
X		common/main.h common/s-v-arg.h common/error.h \
X		cook/fngrprnt.h common/ac/time.h common/mem.h \
X		cook/option.h common/word.h cook/stat.cache.h \
X		common/symtab.h common/trace.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/stat.cache.c
X	mv stat.cache.o cook/stat.cache.o
X
Xcook/stmt.o: cook/stmt.c common/ac/stddef.h common/config.h \
X		common/ac/string.h common/ac/time.h cook/cook.h \
X		cook/expr.h common/str.h common/main.h common/s-v-arg.h \
X		common/word.h cook/stmt.h cook/env.h common/error.h \
X		cook/id.h cook/match.h common/mem.h cook/option.h \
X		cook/os.h common/trace.h 
X	$(CC) $(CFLAGS) -Icook -Icommon -c cook/stmt.c
X	mv stmt.o cook/stmt.o
X
Xcookfp/main.o: cookfp/main.c common/ac/stdlib.h common/config.h \
X		common/arglex.h common/main.h common/error.h \
X		common/fp/cksum.h common/fp.h common/fp/combined.h \
X		common/fp/md5.h common/fp/snefru.h common/help.h \
X		common/version.h common/word.h common/str.h \
X		common/ac/stddef.h common/s-v-arg.h man1/cookfp.h 
X	$(CC) $(CFLAGS) -Icookfp -Icommon -c cookfp/main.c
X	mv main.o cookfp/main.o
X
Xcooktime/date.gen.c cooktime/date.gen.h: cooktime/date.y
X	@echo Expect 8 shift/reduce conflicts:
X	$(YACC) -d cooktime/date.y
X	sed -e 's/[yY][yY]/date_/g' y.tab.c > cooktime/date.gen.c
X	sed -e 's/[yY][yY]/date_/g' y.tab.h > cooktime/date.gen.h
X	rm y.tab.c y.tab.h
X
Xcooktime/date.gen.o: cooktime/date.gen.c common/ac/stdlib.h \
X		common/config.h common/ac/time.h common/ac/string.h \
X		cooktime/date.h common/main.h common/str.h \
X		common/ac/stddef.h common/s-v-arg.h common/trace.h 
X	$(CC) $(CFLAGS) -Icooktime -Icommon -c cooktime/date.gen.c
X	mv date.gen.o cooktime/date.gen.o
X
Xcooktime/main.o: cooktime/main.c common/ac/stddef.h common/config.h \
X		common/ac/string.h common/ac/stdlib.h common/arglex.h \
X		common/main.h cooktime/date.h common/ac/time.h \
X		common/error.h common/help.h common/str.h \
X		common/s-v-arg.h common/trace.h common/version.h \
X		common/word.h man1/cooktime.h 
X	$(CC) $(CFLAGS) -Icooktime -Icommon -c cooktime/main.c
X	mv main.o cooktime/main.o
X
Xfind_libs/main.o: find_libs/main.c common/ac/stddef.h common/config.h \
X		common/ac/string.h common/ac/stdlib.h common/arglex.h \
X		common/main.h common/error.h common/help.h common/mem.h \
X		find_libs/os.h common/str.h common/s-v-arg.h \
X		common/version.h man1/find_libs.h 
X	$(CC) $(CFLAGS) -Ifind_libs -Icommon -c find_libs/main.c
X	mv main.o find_libs/main.o
X
Xfind_libs/os.o: find_libs/os.c common/error.h common/main.h \
X		find_libs/os.h 
X	$(CC) $(CFLAGS) -Ifind_libs -Icommon -c find_libs/os.c
X	mv os.o find_libs/os.o
X
X$(libdir)/as: lib/as $(libdir)
X	$(INSTALL_DATA) lib/as $(libdir)/as
X
X$(libdir)/bison: lib/bison $(libdir)
X	$(INSTALL_DATA) lib/bison $(libdir)/bison
X
X$(libdir)/c: lib/c $(libdir)
X	$(INSTALL_DATA) lib/c $(libdir)/c
X
X$(libdir)/gcc: lib/gcc $(libdir)
X	$(INSTALL_DATA) lib/gcc $(libdir)/gcc
X
X$(libdir)/home: lib/home $(libdir)
X	$(INSTALL_DATA) lib/home $(libdir)/home
X
X$(libdir)/lex: lib/lex $(libdir)
X	$(INSTALL_DATA) lib/lex $(libdir)/lex
X
X$(libdir)/library: lib/library $(libdir)
X	$(INSTALL_DATA) lib/library $(libdir)/library
X
X$(libdir)/print: lib/print $(libdir)
X	$(INSTALL_DATA) lib/print $(libdir)/print
X
X$(libdir)/program: lib/program $(libdir)
X	$(INSTALL_DATA) lib/program $(libdir)/program
X
X$(libdir)/rcs: lib/rcs $(libdir)
X	$(INSTALL_DATA) lib/rcs $(libdir)/rcs
X
X$(libdir)/sccs: lib/sccs $(libdir)
X	$(INSTALL_DATA) lib/sccs $(libdir)/sccs
X
X$(libdir)/text: lib/text $(libdir)
X	$(INSTALL_DATA) lib/text $(libdir)/text
X
X$(libdir)/usr: lib/usr $(libdir)
X	$(INSTALL_DATA) lib/usr $(libdir)/usr
X
X$(libdir)/usr.local: lib/usr.local $(libdir)
X	$(INSTALL_DATA) lib/usr.local $(libdir)/usr.local
X
X$(libdir)/yacc: lib/yacc $(libdir)
X	$(INSTALL_DATA) lib/yacc $(libdir)/yacc
X
X$(libdir)/yacc_many: lib/yacc_many $(libdir)
X	$(INSTALL_DATA) lib/yacc_many $(libdir)/yacc_many
X
Xmake2cook/blob.o: make2cook/blob.c make2cook/blob.h common/str.h \
X		common/ac/stddef.h common/config.h common/main.h \
X		common/s-v-arg.h make2cook/emit.h common/error.h \
X		common/mem.h 
X	$(CC) $(CFLAGS) -Imake2cook -Icommon -c make2cook/blob.c
X	mv blob.o make2cook/blob.o
X
Xmake2cook/emit.o: make2cook/emit.c make2cook/emit.h common/str.h \
X		common/ac/stddef.h common/config.h common/main.h \
X		common/s-v-arg.h common/error.h 
X	$(CC) $(CFLAGS) -Imake2cook -Icommon -c make2cook/emit.c
X	mv emit.o make2cook/emit.o
X
Xmake2cook/gram.gen.c make2cook/gram.gen.h: make2cook/gram.y
X	@echo Expect 1 shift/reduce conflicts:
X	$(YACC) -d make2cook/gram.y
X	sed -e 's/[yY][yY]/gram_/g' y.tab.c > make2cook/gram.gen.c
X	sed -e 's/[yY][yY]/gram_/g' y.tab.h > make2cook/gram.gen.h
X	rm y.tab.c y.tab.h
X
Xmake2cook/gram.gen.o: make2cook/gram.gen.c make2cook/gram.h \
X		common/main.h make2cook/lex.h make2cook/stmt/assign.h \
X		make2cook/blob.h common/str.h common/ac/stddef.h \
X		common/config.h common/s-v-arg.h make2cook/stmt.h \
X		common/word.h make2cook/stmt/blank.h \
X		make2cook/stmt/comment.h make2cook/stmt/compound.h \
X		make2cook/stmt/define.h make2cook/stmt/if.h \
X		make2cook/stmt/include.h make2cook/stmt/rule.h \
X		make2cook/stmt/vpath.h common/trace.h 
X	$(CC) $(CFLAGS) -Imake2cook -Icommon -c make2cook/gram.gen.c
X	mv gram.gen.o make2cook/gram.gen.o
X
Xmake2cook/lex.o: make2cook/lex.c common/ac/string.h common/config.h \
X		make2cook/blob.h common/str.h common/ac/stddef.h \
X		common/main.h common/s-v-arg.h common/error.h \
X		make2cook/lex.h common/mem.h make2cook/stmt.h \
X		common/word.h common/symtab.h common/trace.h \
X		make2cook/gram.gen.h 
X	$(CC) $(CFLAGS) -Imake2cook -Icommon -c make2cook/lex.c
X	mv lex.o make2cook/lex.o
X
Xmake2cook/main.o: make2cook/main.c common/arglex.h common/main.h \
X		make2cook/emit.h common/str.h common/ac/stddef.h \
X		common/config.h common/s-v-arg.h common/error.h \
X		make2cook/gram.h common/help.h make2cook/stmt/rule.h \
X		make2cook/blob.h make2cook/stmt.h common/word.h \
X		common/trace.h common/version.h man1/make2cook.h 
X	$(CC) $(CFLAGS) -Imake2cook -Icommon -c make2cook/main.c
X	mv main.o make2cook/main.o
X
Xmake2cook/stmt.o: make2cook/stmt.c common/mem.h common/ac/stddef.h \
X		common/config.h common/main.h make2cook/stmt.h \
X		common/word.h common/str.h common/s-v-arg.h \
X		common/trace.h 
X	$(CC) $(CFLAGS) -Imake2cook -Icommon -c make2cook/stmt.c
X	mv stmt.o make2cook/stmt.o
X
Xmake2cook/stmt/assign.o: make2cook/stmt/assign.c make2cook/emit.h \
X		common/str.h common/ac/stddef.h common/config.h \
X		common/main.h common/s-v-arg.h make2cook/stmt/assign.h \
X		make2cook/blob.h make2cook/stmt.h common/word.h \
X		common/symtab.h make2cook/variable.h 
X	$(CC) $(CFLAGS) -Imake2cook -Icommon -c make2cook/stmt/assign.c
X	mv assign.o make2cook/stmt/assign.o
X
Xmake2cook/stmt/blank.o: make2cook/stmt/blank.c make2cook/stmt/blank.h \
X		make2cook/stmt.h common/ac/stddef.h common/config.h \
X		common/word.h common/str.h common/main.h \
X		common/s-v-arg.h 
X	$(CC) $(CFLAGS) -Imake2cook -Icommon -c make2cook/stmt/blank.c
X	mv blank.o make2cook/stmt/blank.o
X
Xmake2cook/stmt/comment.o: make2cook/stmt/comment.c make2cook/emit.h \
X		common/str.h common/ac/stddef.h common/config.h \
X		common/main.h common/s-v-arg.h common/mem.h \
X		make2cook/stmt/comment.h make2cook/blob.h \
X		make2cook/stmt.h common/word.h 
X	$(CC) $(CFLAGS) -Imake2cook -Icommon -c make2cook/stmt/comment.c
X	mv comment.o make2cook/stmt/comment.o
X
Xmake2cook/stmt/compound.o: make2cook/stmt/compound.c common/mem.h \
X		common/ac/stddef.h common/config.h common/main.h \
X		make2cook/stmt/compound.h make2cook/stmt.h \
X		common/word.h common/str.h common/s-v-arg.h 
X	$(CC) $(CFLAGS) -Imake2cook -Icommon -c make2cook/stmt/compound.c
X	mv compound.o make2cook/stmt/compound.o
X
Xmake2cook/stmt/define.o: make2cook/stmt/define.c make2cook/emit.h \
X		common/str.h common/ac/stddef.h common/config.h \
X		common/main.h common/s-v-arg.h common/mem.h \
X		make2cook/stmt/define.h make2cook/blob.h \
X		make2cook/stmt.h common/word.h 
X	$(CC) $(CFLAGS) -Imake2cook -Icommon -c make2cook/stmt/define.c
X	mv define.o make2cook/stmt/define.o
X
Xmake2cook/stmt/if.o: make2cook/stmt/if.c make2cook/emit.h common/str.h \
X		common/ac/stddef.h common/config.h common/main.h \
X		common/s-v-arg.h make2cook/stmt/if.h make2cook/blob.h \
X		make2cook/stmt.h common/word.h make2cook/variable.h 
X	$(CC) $(CFLAGS) -Imake2cook -Icommon -c make2cook/stmt/if.c
X	mv if.o make2cook/stmt/if.o
X
Xmake2cook/stmt/include.o: make2cook/stmt/include.c common/ac/string.h \
X		common/config.h make2cook/emit.h common/str.h \
X		common/ac/stddef.h common/main.h common/s-v-arg.h \
X		common/mem.h make2cook/stmt/include.h make2cook/stmt.h \
X		common/word.h make2cook/blob.h make2cook/variable.h 
X	$(CC) $(CFLAGS) -Imake2cook -Icommon -c make2cook/stmt/include.c
X	mv include.o make2cook/stmt/include.o
X
Xmake2cook/stmt/rule.o: make2cook/stmt/rule.c common/ac/string.h \
X		common/config.h make2cook/emit.h common/str.h \
X		common/ac/stddef.h common/main.h common/s-v-arg.h \
X		common/mem.h make2cook/stmt/rule.h make2cook/blob.h \
X		make2cook/stmt.h common/word.h make2cook/variable.h 
X	$(CC) $(CFLAGS) -Imake2cook -Icommon -c make2cook/stmt/rule.c
X	mv rule.o make2cook/stmt/rule.o
X
Xmake2cook/stmt/vpath.o: make2cook/stmt/vpath.c make2cook/stmt/assign.h \
X		make2cook/blob.h common/str.h common/ac/stddef.h \
X		common/config.h common/main.h common/s-v-arg.h \
X		make2cook/stmt.h common/word.h make2cook/stmt/vpath.h 
X	$(CC) $(CFLAGS) -Imake2cook -Icommon -c make2cook/stmt/vpath.c
X	mv vpath.o make2cook/stmt/vpath.o
X
Xmake2cook/vargram.gen.c make2cook/vargram.gen.h: make2cook/vargram.y
X	@echo Expect no conflicts:
X	$(YACC) -d make2cook/vargram.y
X	sed -e 's/[yY][yY]/vargram_/g' y.tab.c > make2cook/vargram.gen.c
X	sed -e 's/[yY][yY]/vargram_/g' y.tab.h > make2cook/vargram.gen.h
X	rm y.tab.c y.tab.h
X
Xmake2cook/vargram.gen.o: make2cook/vargram.gen.c common/ac/string.h \
X		common/config.h common/trace.h common/ac/stddef.h \
X		common/main.h make2cook/vargram.h make2cook/variable.h \
X		make2cook/blob.h common/str.h common/s-v-arg.h \
X		common/word.h 
X	$(CC) $(CFLAGS) -Imake2cook -Icommon -c make2cook/vargram.gen.c
X	mv vargram.gen.o make2cook/vargram.gen.o
X
Xmake2cook/variable.o: make2cook/variable.c common/error.h common/main.h \
X		common/symtab.h common/str.h common/ac/stddef.h \
X		common/config.h common/s-v-arg.h common/trace.h \
X		make2cook/vargram.h make2cook/variable.h \
X		make2cook/blob.h common/word.h make2cook/vargram.gen.h 
X	$(CC) $(CFLAGS) -Imake2cook -Icommon -c make2cook/variable.c
X	mv variable.o make2cook/variable.o
X
Xman1/c_incl.h: man1/c_incl.1 bin/txt2c
X	bin/txt2c man1/c_incl.1 man1/c_incl.h
X
X$(mandir)/man1/c_incl.1: man1/c_incl.1 bin/roffpp
X	bin/roffpp -Iman1 man1/c_incl.1 tmp
X	$(INSTALL_DATA) tmp $(mandir)/man1/c_incl.1
X	@rm tmp
X
Xman1/cook.h: man1/cook.1 bin/txt2c
X	bin/txt2c man1/cook.1 man1/cook.h
X
X$(mandir)/man1/cook.1: man1/cook.1 bin/roffpp
X	bin/roffpp -Iman1 man1/cook.1 tmp
X	$(INSTALL_DATA) tmp $(mandir)/man1/cook.1
X	@rm tmp
X
Xman1/cookfp.h: man1/cookfp.1 bin/txt2c
X	bin/txt2c man1/cookfp.1 man1/cookfp.h
X
X$(mandir)/man1/cookfp.1: man1/cookfp.1 bin/roffpp
X	bin/roffpp -Iman1 man1/cookfp.1 tmp
X	$(INSTALL_DATA) tmp $(mandir)/man1/cookfp.1
X	@rm tmp
X
Xman1/cooktime.h: man1/cooktime.1 bin/txt2c
X	bin/txt2c man1/cooktime.1 man1/cooktime.h
X
X$(mandir)/man1/cooktime.1: man1/cooktime.1 bin/roffpp
X	bin/roffpp -Iman1 man1/cooktime.1 tmp
X	$(INSTALL_DATA) tmp $(mandir)/man1/cooktime.1
X	@rm tmp
X
Xman1/copyright.h: man1/copyright.so bin/txt2c
X	bin/txt2c man1/copyright.so man1/copyright.h
X
Xman1/find_libs.h: man1/find_libs.1 bin/txt2c
X	bin/txt2c man1/find_libs.1 man1/find_libs.h
X
X$(mandir)/man1/find_libs.1: man1/find_libs.1 bin/roffpp
X	bin/roffpp -Iman1 man1/find_libs.1 tmp
X	$(INSTALL_DATA) tmp $(mandir)/man1/find_libs.1
X	@rm tmp
X
Xman1/make2cook.h: man1/make2cook.1 bin/txt2c
X	bin/txt2c man1/make2cook.1 man1/make2cook.h
X
X$(mandir)/man1/make2cook.1: man1/make2cook.1 bin/roffpp
X	bin/roffpp -Iman1 man1/make2cook.1 tmp
X	$(INSTALL_DATA) tmp $(mandir)/man1/make2cook.1
X	@rm tmp
X
Xman1/o__rules.h: man1/o__rules.so bin/txt2c
X	bin/txt2c man1/o__rules.so man1/o__rules.h
X
Xman1/roffpp.h: man1/roffpp.1 bin/txt2c
X	bin/txt2c man1/roffpp.1 man1/roffpp.h
X
X$(mandir)/man1/roffpp.1: man1/roffpp.1 bin/roffpp
X	bin/roffpp -Iman1 man1/roffpp.1 tmp
X	$(INSTALL_DATA) tmp $(mandir)/man1/roffpp.1
X	@rm tmp
X
Xman1/z_exit.h: man1/z_exit.so bin/txt2c
X	bin/txt2c man1/z_exit.so man1/z_exit.h
X
Xman1/z_name.h: man1/z_name.so bin/txt2c
X	bin/txt2c man1/z_name.so man1/z_name.h
X
Xroffpp/main.o: roffpp/main.c common/ac/stddef.h common/config.h \
X		common/ac/string.h common/ac/stdlib.h common/arglex.h \
X		common/main.h common/error.h common/help.h \
X		roffpp/preprocess.h common/str.h common/s-v-arg.h \
X		common/trace.h common/version.h man1/roffpp.h 
X	$(CC) $(CFLAGS) -Iroffpp -Icommon -c roffpp/main.c
X	mv main.o roffpp/main.o
X
Xroffpp/preprocess.o: roffpp/preprocess.c common/ac/stdlib.h \
X		common/config.h common/ac/unistd.h common/error.h \
X		common/main.h common/mem.h common/ac/stddef.h \
X		roffpp/preprocess.h common/str.h common/s-v-arg.h \
X		common/trace.h common/word.h 
X	$(CC) $(CFLAGS) -Iroffpp -Icommon -c roffpp/preprocess.c
X	mv preprocess.o roffpp/preprocess.o
X
Xt0001a: test/00/t0001a.sh all
X	$(SH) test/00/t0001a.sh
X
Xt0002a: test/00/t0002a.sh all
X	$(SH) test/00/t0002a.sh
X
Xt0003a: test/00/t0003a.sh all
X	$(SH) test/00/t0003a.sh
X
Xt0004a: test/00/t0004a.sh all
X	$(SH) test/00/t0004a.sh
X
Xt0005a: test/00/t0005a.sh all
X	$(SH) test/00/t0005a.sh
X
Xt0006a: test/00/t0006a.sh all
X	$(SH) test/00/t0006a.sh
X
Xt0007a: test/00/t0007a.sh all
X	$(SH) test/00/t0007a.sh
X
Xt0008a: test/00/t0008a.sh all
X	$(SH) test/00/t0008a.sh
X
Xt0009a: test/00/t0009a.sh all
X	$(SH) test/00/t0009a.sh
X
Xt0010a: test/00/t0010a.sh all
X	$(SH) test/00/t0010a.sh
X
Xt0011a: test/00/t0011a.sh all
X	$(SH) test/00/t0011a.sh
X
Xt0012a: test/00/t0012a.sh all
X	$(SH) test/00/t0012a.sh
X
Xt0013a: test/00/t0013a.sh all
X	$(SH) test/00/t0013a.sh
X
Xt0014a: test/00/t0014a.sh all
X	$(SH) test/00/t0014a.sh
X
Xt0015a: test/00/t0015a.sh all
X	$(SH) test/00/t0015a.sh
X
Xt0016a: test/00/t0016a.sh all
X	$(SH) test/00/t0016a.sh
X
Xt0017a: test/00/t0017a.sh all
X	$(SH) test/00/t0017a.sh
X
Xt0018a: test/00/t0018a.sh all
X	$(SH) test/00/t0018a.sh
X
Xt0019a: test/00/t0019a.sh all
X	$(SH) test/00/t0019a.sh
X
Xt0020a: test/00/t0020a.sh all
X	$(SH) test/00/t0020a.sh
X
Xt0021a: test/00/t0021a.sh all
X	$(SH) test/00/t0021a.sh
X
Xt0022a: test/00/t0022a.sh all
X	$(SH) test/00/t0022a.sh
X
Xt0023a: test/00/t0023a.sh all
X	$(SH) test/00/t0023a.sh
X
Xt0024a: test/00/t0024a.sh all
X	$(SH) test/00/t0024a.sh
X
Xt0025a: test/00/t0025a.sh all
X	$(SH) test/00/t0025a.sh
X
Xt0026a: test/00/t0026a.sh all
X	$(SH) test/00/t0026a.sh
X
Xt0027a: test/00/t0027a.sh all
X	$(SH) test/00/t0027a.sh
X
Xt0028a: test/00/t0028a.sh all
X	$(SH) test/00/t0028a.sh
X
Xt0029a: test/00/t0029a.sh all
X	$(SH) test/00/t0029a.sh
X
Xt0030a: test/00/t0030a.sh all
X	$(SH) test/00/t0030a.sh
X
Xt0031a: test/00/t0031a.sh all
X	$(SH) test/00/t0031a.sh
X
Xt0032a: test/00/t0032a.sh all
X	$(SH) test/00/t0032a.sh
X
Xt0033a: test/00/t0033a.sh all
X	$(SH) test/00/t0033a.sh
X
Xt0034a: test/00/t0034a.sh all
X	$(SH) test/00/t0034a.sh
X
Xt0035a: test/00/t0035a.sh all
X	$(SH) test/00/t0035a.sh
X
Xt0036a: test/00/t0036a.sh all
X	$(SH) test/00/t0036a.sh
X
Xt0037a: test/00/t0037a.sh all
X	$(SH) test/00/t0037a.sh
X
Xt0038a: test/00/t0038a.sh all
X	$(SH) test/00/t0038a.sh
X
Xt0039a: test/00/t0039a.sh all
X	$(SH) test/00/t0039a.sh
X
Xt0040a: test/00/t0040a.sh all
X	$(SH) test/00/t0040a.sh
X
Xt0041a: test/00/t0041a.sh all
X	$(SH) test/00/t0041a.sh
X
Xt0042a: test/00/t0042a.sh all
X	$(SH) test/00/t0042a.sh
X
Xt0043a: test/00/t0043a.sh all
X	$(SH) test/00/t0043a.sh
X
Xt0044a: test/00/t0044a.sh all
X	$(SH) test/00/t0044a.sh
X
Xt0045a: test/00/t0045a.sh all
X	$(SH) test/00/t0045a.sh
X
Xt0046a: test/00/t0046a.sh all
X	$(SH) test/00/t0046a.sh
X
Xt0047a: test/00/t0047a.sh all
X	$(SH) test/00/t0047a.sh
X
Xt0048a: test/00/t0048a.sh all
X	$(SH) test/00/t0048a.sh
X
Xt0049a: test/00/t0049a.sh all
X	$(SH) test/00/t0049a.sh
X
Xt0050a: test/00/t0050a.sh all
X	$(SH) test/00/t0050a.sh
X
Xt0051a: test/00/t0051a.sh all
X	$(SH) test/00/t0051a.sh
X
Xt0052a: test/00/t0052a.sh all
X	$(SH) test/00/t0052a.sh
X
Xt0053a: test/00/t0053a.sh all
X	$(SH) test/00/t0053a.sh
X
Xt0054a: test/00/t0054a.sh all
X	$(SH) test/00/t0054a.sh
X
Xt0055a: test/00/t0055a.sh all
X	$(SH) test/00/t0055a.sh
X
Xt0056a: test/00/t0056a.sh all
X	$(SH) test/00/t0056a.sh
X
Xt0057a: test/00/t0057a.sh all
X	$(SH) test/00/t0057a.sh
X
Xt0058a: test/00/t0058a.sh all
X	$(SH) test/00/t0058a.sh
X
Xt0059a: test/00/t0059a.sh all
X	$(SH) test/00/t0059a.sh
X
Xt0060a: test/00/t0060a.sh all
X	$(SH) test/00/t0060a.sh
X
Xt0061a: test/00/t0061a.sh all
X	$(SH) test/00/t0061a.sh
X
Xt0062a: test/00/t0062a.sh all
X	$(SH) test/00/t0062a.sh
X
Xt0063a: test/00/t0063a.sh all
X	$(SH) test/00/t0063a.sh
X
Xt0064a: test/00/t0064a.sh all
X	$(SH) test/00/t0064a.sh
X
Xt0065a: test/00/t0065a.sh all
X	$(SH) test/00/t0065a.sh
X
Xt0066a: test/00/t0066a.sh all
X	$(SH) test/00/t0066a.sh
X
Xt0067a: test/00/t0067a.sh all
X	$(SH) test/00/t0067a.sh
X
Xt0068a: test/00/t0068a.sh all
X	$(SH) test/00/t0068a.sh
X
Xt0069a: test/00/t0069a.sh all
X	$(SH) test/00/t0069a.sh
X
Xt0070a: test/00/t0070a.sh all
X	$(SH) test/00/t0070a.sh
X
Xt0071a: test/00/t0071a.sh all
X	$(SH) test/00/t0071a.sh
X
Xt0072a: test/00/t0072a.sh all
X	$(SH) test/00/t0072a.sh
X
Xt0073a: test/00/t0073a.sh all
X	$(SH) test/00/t0073a.sh
X
Xt0074a: test/00/t0074a.sh all
X	$(SH) test/00/t0074a.sh
X
Xt0075a: test/00/t0075a.sh all
X	$(SH) test/00/t0075a.sh
X
Xt0076a: test/00/t0076a.sh all
X	$(SH) test/00/t0076a.sh
X
Xt0077a: test/00/t0077a.sh all
X	$(SH) test/00/t0077a.sh
X
Xt0078a: test/00/t0078a.sh all
X	$(SH) test/00/t0078a.sh
X
Xt0079a: test/00/t0079a.sh all
X	$(SH) test/00/t0079a.sh
X
Xtxt2c/main.o: txt2c/main.c common/ac/stdlib.h common/config.h \
X		common/arglex.h common/main.h common/error.h \
X		common/str.h common/ac/stddef.h common/s-v-arg.h \
X		common/trace.h txt2c/txt2c.h common/version-stmp.h 
X	$(CC) $(CFLAGS) -Itxt2c -Icommon -c txt2c/main.c
X	mv main.o txt2c/main.o
X
Xtxt2c/txt2c.o: txt2c/txt2c.c common/error.h common/main.h txt2c/txt2c.h
X	$(CC) $(CFLAGS) -Itxt2c -Icommon -c txt2c/txt2c.c
X	mv txt2c.o txt2c/txt2c.o
X
XCommonObj = common/ansi.o common/arglex.o common/error.o common/fp.o \
X		common/fp/cksum.o common/fp/combined.o \
X		common/fp/crc32.o common/fp/len.o common/fp/md5.o \
X		common/fp/snefru.o common/help.o common/mem.o \
X		common/mprintf.o common/str.o common/symtab.o \
X		common/trace.o common/version-stmp.o common/version.o \
X		common/word.o 
X
Xcommon/lib.a: $(CommonObj)
X	rm -f common/lib.a
X	$(AR) qc common/lib.a $(CommonObj)
X	$(RANLIB) common/lib.a
X
Xbin:
X	mkdir bin
X
XCookObj = cook/archive.o cook/builtin.o cook/builtin/addprefix.o \
X		cook/builtin/addsuffix.o cook/builtin/basename.o \
X		cook/builtin/boolean.o cook/builtin/collect.o \
X		cook/builtin/cook.o cook/builtin/defined.o \
X		cook/builtin/execute.o cook/builtin/exists.o \
X		cook/builtin/filter_out.o cook/builtin/find_command.o \
X		cook/builtin/findstring.o cook/builtin/getenv.o \
X		cook/builtin/glob.o cook/builtin/home.o \
X		cook/builtin/join.o cook/builtin/match.o \
X		cook/builtin/opsys.o cook/builtin/pathname.o \
X		cook/builtin/split.o cook/builtin/stringset.o \
X		cook/builtin/strip.o cook/builtin/subst.o \
X		cook/builtin/suffix.o cook/builtin/text.o \
X		cook/builtin/unsplit.o cook/builtin/word.o cook/cook.o \
X		cook/env.o cook/expr.o cook/fngrprnt.gen.o \
X		cook/fngrprnt_lex.o cook/hashline.gen.o cook/id.o \
X		cook/lex.o cook/listing.o cook/main.o cook/match.o \
X		cook/option.o cook/os.o cook/parse.gen.o \
X		cook/stat.cache.o cook/stmt.o 
X
Xbin/cook: $(CookObj) common/lib.a bin
X	$(CC) $(LDFLAGS) -o bin/cook $(CookObj) common/lib.a $(LIBS)
X
XMake2cookObj = make2cook/blob.o make2cook/emit.o make2cook/gram.gen.o \
X		make2cook/lex.o make2cook/main.o make2cook/stmt.o \
X		make2cook/stmt/assign.o make2cook/stmt/blank.o \
X		make2cook/stmt/comment.o make2cook/stmt/compound.o \
X		make2cook/stmt/define.o make2cook/stmt/if.o \
X		make2cook/stmt/include.o make2cook/stmt/rule.o \
X		make2cook/stmt/vpath.o make2cook/vargram.gen.o \
X		make2cook/variable.o 
X
Xbin/make2cook: $(Make2cookObj) common/lib.a bin
X	$(CC) $(LDFLAGS) -o bin/make2cook $(Make2cookObj) common/lib.a $(LIBS)
X
XCInclObj = c_incl/cache.o c_incl/lang_c.o c_incl/lang_roff.o \
X		c_incl/main.o c_incl/os.o c_incl/sniff.o 
X
Xbin/c_incl: $(CInclObj) common/lib.a bin
X	$(CC) $(LDFLAGS) -o bin/c_incl $(CInclObj) common/lib.a $(LIBS)
X
XFindLibsObj = find_libs/main.o find_libs/os.o
X
Xbin/find_libs: $(FindLibsObj) common/lib.a bin
X	$(CC) $(LDFLAGS) -o bin/find_libs $(FindLibsObj) common/lib.a $(LIBS)
X
XRoffppObj = roffpp/main.o roffpp/preprocess.o
X
Xbin/roffpp: $(RoffppObj) common/lib.a bin
X	$(CC) $(LDFLAGS) -o bin/roffpp $(RoffppObj) common/lib.a $(LIBS)
X
XCooktimeObj = cooktime/date.gen.o cooktime/main.o
X
Xbin/cooktime: $(CooktimeObj) common/lib.a bin
X	$(CC) $(LDFLAGS) -o bin/cooktime $(CooktimeObj) common/lib.a $(LIBS)
X
XTxt2cObj = common/ansi.o common/arglex.o common/error.o common/mem.o \
X		common/mprintf.o common/str.o common/trace.o \
X		txt2c/main.o txt2c/txt2c.o 
X
Xbin/txt2c: $(Txt2cObj) bin
X	$(CC) $(LDFLAGS) -o bin/txt2c $(Txt2cObj) $(LIBS)
X
XCookfpObj = cookfp/main.o
X
Xbin/cookfp: $(CookfpObj) common/lib.a bin
X	$(CC) $(LDFLAGS) -o bin/cookfp $(CookfpObj) common/lib.a $(LIBS)
X
Xsure: t0001a t0002a t0003a t0004a t0005a t0006a t0007a t0008a t0009a \
X		t0010a t0011a t0012a t0013a t0014a t0015a t0016a t0017a \
X		t0018a t0019a t0020a t0021a t0022a t0023a t0024a t0025a \
X		t0026a t0027a t0028a t0029a t0030a t0031a t0032a t0033a \
X		t0034a t0035a t0036a t0037a t0038a t0039a t0040a t0041a \
X		t0042a t0043a t0044a t0045a t0046a t0047a t0048a t0049a \
X		t0050a t0051a t0052a t0053a t0054a t0055a t0056a t0057a \
X		t0058a t0059a t0060a t0061a t0062a t0063a t0064a t0065a \
X		t0066a t0067a t0068a t0069a t0070a t0071a t0072a t0073a \
X		t0074a t0075a t0076a t0077a t0078a t0079a 
X	@echo Passed All Tests
X
Xclean-obj:
X	rm -f core y.tab.c y.tab.h bin/txt2c c_incl/cache.o \
X		c_incl/lang_c.o c_incl/lang_roff.o c_incl/main.o \
X		c_incl/os.o c_incl/sniff.o common/ansi.o \
X		common/arglex.o common/error.o common/fp.o \
X		common/fp/cksum.o common/fp/combined.o \
X		common/fp/crc32.o common/fp/len.o common/fp/md5.o \
X		common/fp/snefru.o common/help.o common/mem.o \
X		common/mprintf.o common/str.o common/symtab.o \
X		common/trace.o common/version-stmp.o common/version.o \
X		common/word.o cook/archive.o cook/builtin.o \
X		cook/builtin/addprefix.o cook/builtin/addsuffix.o \
X		cook/builtin/basename.o cook/builtin/boolean.o \
X		cook/builtin/collect.o cook/builtin/cook.o \
X		cook/builtin/defined.o cook/builtin/execute.o \
X		cook/builtin/exists.o cook/builtin/filter_out.o \
X		cook/builtin/find_command.o cook/builtin/findstring.o \
X		cook/builtin/getenv.o cook/builtin/glob.o \
X		cook/builtin/home.o cook/builtin/join.o \
X		cook/builtin/match.o cook/builtin/opsys.o \
X		cook/builtin/pathname.o cook/builtin/split.o \
X		cook/builtin/stringset.o cook/builtin/strip.o \
X		cook/builtin/subst.o cook/builtin/suffix.o \
X		cook/builtin/text.o cook/builtin/unsplit.o \
X		cook/builtin/word.o cook/cook.o cook/env.o cook/expr.o \
X		cook/fngrprnt.gen.c cook/fngrprnt.gen.h \
X		cook/fngrprnt.gen.o cook/fngrprnt_lex.o \
X		cook/hashline.gen.c cook/hashline.gen.h \
X		cook/hashline.gen.o cook/id.o cook/lex.o cook/listing.o \
X		cook/main.o cook/match.o cook/option.o cook/os.o \
X		cook/parse.gen.c cook/parse.gen.h cook/parse.gen.o \
X		cook/stat.cache.o cook/stmt.o cookfp/main.o \
X		cooktime/date.gen.c cooktime/date.gen.h \
X		cooktime/date.gen.o cooktime/main.o find_libs/main.o \
X		find_libs/os.o make2cook/blob.o make2cook/emit.o \
X		make2cook/gram.gen.c make2cook/gram.gen.h \
X		make2cook/gram.gen.o make2cook/lex.o make2cook/main.o \
X		make2cook/stmt.o make2cook/stmt/assign.o \
X		make2cook/stmt/blank.o make2cook/stmt/comment.o \
X		make2cook/stmt/compound.o make2cook/stmt/define.o \
X		make2cook/stmt/if.o make2cook/stmt/include.o \
X		make2cook/stmt/rule.o make2cook/stmt/vpath.o \
X		make2cook/vargram.gen.c make2cook/vargram.gen.h \
X		make2cook/vargram.gen.o make2cook/variable.o \
X		man1/c_incl.h man1/cook.h man1/cookfp.h man1/cooktime.h \
X		man1/copyright.h man1/find_libs.h man1/make2cook.h \
X		man1/o__rules.h man1/roffpp.h man1/z_exit.h \
X		man1/z_name.h roffpp/main.o roffpp/preprocess.o \
X		txt2c/main.o txt2c/txt2c.o 
X
Xclean: clean-obj
X	rm -f bin/c_incl bin/cook bin/cookfp bin/cooktime bin/find_libs \
X		bin/make2cook bin/roffpp 
X
Xdistclean: clean
X	rm -f Makefile common/config.h config.status
X
X$(libdir):
X	-mkdir $(libdir)
X	-chmod 755 $(libdir)
X
X$(bindir)/c_incl: bin/c_incl
X	$(INSTALL_PROGRAM) bin/c_incl $(bindir)/c_incl
X
X$(bindir)/cook: bin/cook
X	$(INSTALL_PROGRAM) bin/cook $(bindir)/cook
X
X$(bindir)/cookfp: bin/cookfp
X	$(INSTALL_PROGRAM) bin/cookfp $(bindir)/cookfp
X
X$(bindir)/cooktime: bin/cooktime
X	$(INSTALL_PROGRAM) bin/cooktime $(bindir)/cooktime
X
X$(bindir)/find_libs: bin/find_libs
X	$(INSTALL_PROGRAM) bin/find_libs $(bindir)/find_libs
X
X$(bindir)/make2cook: bin/make2cook
X	$(INSTALL_PROGRAM) bin/make2cook $(bindir)/make2cook
X
X$(bindir)/roffpp: bin/roffpp
X	$(INSTALL_PROGRAM) bin/roffpp $(bindir)/roffpp
X
Xinstall-bin: $(bindir)/c_incl $(bindir)/cook $(bindir)/cookfp \
X		$(bindir)/cooktime $(bindir)/find_libs \
X		$(bindir)/make2cook $(bindir)/roffpp 
X
Xinstall-man: $(mandir)/man1/c_incl.1 $(mandir)/man1/cook.1 \
X		$(mandir)/man1/cookfp.1 $(mandir)/man1/cooktime.1 \
X		$(mandir)/man1/find_libs.1 $(mandir)/man1/make2cook.1 \
X		$(mandir)/man1/roffpp.1 
X
Xinstall-lib: $(libdir)/as $(libdir)/bison $(libdir)/c $(libdir)/gcc \
X		$(libdir)/home $(libdir)/lex $(libdir)/library \
X		$(libdir)/print $(libdir)/program $(libdir)/rcs \
X		$(libdir)/sccs $(libdir)/text $(libdir)/usr \
X		$(libdir)/usr.local $(libdir)/yacc $(libdir)/yacc_many 
X
Xinstall: install-bin install-man install-lib
END_OF_FILE
if test 49736 -ne `wc -c <'Makefile.in'`; then
    echo shar: \"'Makefile.in'\" unpacked with wrong size!
fi
# end of 'Makefile.in'
fi
if test -f 'cook/cook.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/cook.c'\"
else
echo shar: Extracting \"'cook/cook.c'\" \(42411 characters\)
sed "s/^X//" >'cook/cook.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to cook targets
X *
X * the kitchen
X *
X * This file contains the part of cook that actually decides which
X * recipes will be cooked.
X *
X * When cook has a target, cook performs the following actions in the order
X * given:
X *
X * 1.	Cook scans through the instanciated prerequisite recipes. All
X *	prerequisite recipes with the target in their target list are used.
X *
X *	If the recipe is used, any prerequisite files are recursively
X *	cooked, then if any of the prerequisite files were out of date, then
X *	all other explicit or implicit recipes with the same target will be
X *	deemed to be out of date.
X *
X * 2.	Cook then scans through the instanciated explicit recipes. All
X *	explicit recipes with the target in their target list are used.
X *
X *	If the recipe is used, any prerequisite files are recursively
X *	cooked, then if any prerequisites were out of date (including those
X *	of prerequisite recipes) then the actions bound to this recipe will
X *	be evaluated.
X *
X *	If there are no ingredients, then it is not out-of-date.  The
X *	body will be performed if (a) the target does not yet exist, or
X *	(b) the "force" flag is set, usually in the "set" clause of
X *	the recipe.
X *
X * 3.	If the target was not the subject of any explicit recipe, cook then
X *	scans the instanciated implicit recipes. Only first implicit recipe
X *	for which cook knows how to cook will be used.
X *
X *	Implicit recipe targets and prerequisites may contain a wilcard
X *	character (%), which is why they are implicit. If more than one
X *	wildcard character appears, only the last is considered the wilcard
X *	charcater.
X *
X *	If an implicit recipe is used, when expressions are evaluaded into
X *	word lists, any word containing the wildcard charcater (%) will be
X *	expanded out by the current wildcard expansion.
X *
X * 4.	If the target is not the subject of any prerequisite or explicit
X *	recipe, and no implicit recipes can be applied, then two things can
X *	happen.
X *		a. If the file exists, then it is up to date, or
X *		b. If the file does not exist then cook doesn't know how.
X *
X * If a command in the actions bound to any recipe fail, cook will not
X * evaluate those actions any further, and will not evaluate the actions
X * of any recipe for which the target of the failed actions was a
X * prerequisite.
X *
X * Cook will trap recursive looping of targets. If a recursion loop is
X * detected, then
X *	1. If the file exists, the it is up to date, or
X *	2. If the file does not exist then cook doesn't know how.
X */
X
X#include <ac/stddef.h>
X#include <stdio.h>
X#include <ac/time.h>
X#include <signal.h>
X
X#include <cook.h>
X#include <error.h>
X#include <id.h>
X#include <main.h>
X#include <match.h>
X#include <mem.h>
X#include <option.h>
X#include <os.h>
X#include <symtab.h>
X#include <trace.h>
X
X
X/*
X *  Cooker results.
X *  The better the result, the higher then number.
X */
Xenum cooker_result_ty
X{
X	COOK_DONTKNOW,
X	COOK_ERROR,
X	COOK_DONE,
X	COOK_DONE_UPTODATE,
X	COOK_UPTODATE,
X	COOK_BACKTRACK
X};
Xtypedef enum cooker_result_ty cooker_result_ty;
X
X
Xrlist		explicit;	/* the explicit recipes */
Xrlist		implicit;	/* the implicit recipes */
Xstatic int	max_tag;
Xint		desist;
Xstatic symtab_ty *already;
Xstatic wlist	cook_auto_list;
X
X
Xstatic cooker_result_ty *already_copy _((cooker_result_ty));
X
Xstatic cooker_result_ty *
Xalready_copy(n)
X	cooker_result_ty n;
X{
X	cooker_result_ty *result;
X
X	result = mem_alloc(sizeof(cooker_result_ty));
X	*result = n;
X	return result;
X}
X
X
Xstatic void already_assign _((string_ty *, cooker_result_ty));
X
Xstatic void
Xalready_assign(path, level)
X	string_ty	*path;
X	cooker_result_ty level;
X{
X	if (!already)
X	{
X		already = symtab_alloc(100);
X		already->reap = mem_free;
X	}
X	symtab_assign(already, path, already_copy(level));
X}
X
X
Xstatic int already_search _((string_ty *, cooker_result_ty *));
X
Xstatic int
Xalready_search(path, result)
X	string_ty	*path;
X	cooker_result_ty *result;
X{
X	cooker_result_ty *data;
X
X	if (!already)
X		return 0;
X	data = symtab_query(already, path);
X	if (!data)
X		return 0;
X	*result = *data;
X	return 1;
X}
X
X
Xstatic void already_delete _((string_ty *));
X
Xstatic void
Xalready_delete(path)
X	string_ty	*path;
X{
X	if (!already)
X		return;
X	symtab_delete(already, path);
X}
X
X
X/*
X * NAME
X *	interrupt - handle interrupts by signals
X *
X * SYNOPSIS
X *	void interrupt(int);
X *
X * DESCRIPTION
X *	The interrupt function is used to set the appropriate flags when an
X *	interrupt occurs.
X *
X * RETURNS
X *	void
X *
X * CAVEAT
X *	Don't use too extravagantly, because it just returns!
X */
X
Xstatic RETSIGTYPE interrupt _((int));
X
Xstatic RETSIGTYPE
Xinterrupt(n)
X	int		n;
X{
X	desist++;
X	error("interrupted by %s", signal_name(n));
X	option_set_errors();
X	signal(n, interrupt);
X}
X
X
X/*
X * NAME
X *	recipe_tag - make next one
X *
X * SYNOPSIS
X *	int recipe_tag(void);
X *
X * DESCRIPTION
X *	The recipe_tag function is used to generate successive recipe tages.
X *	Recipe tags are used during the -trace output to indicate which recipe
X *	is in use.  Recipes are not necessarily instanciated in the order in
X *	which they appear in the source file, hence the tagging.
X *
X * RETURNS
X *	int; unique tag
X */
X
Xint
Xrecipe_tag()
X{
X	return ++max_tag;
X}
X
X
X/*
X * NAME
X *	cook_status_name - give name of status
X *
X * SYNOPSIS
X *	char *cook_status_name(int);
X *
X * DESCRIPTION
X *	The cook_status_name function is used to map a cook status name into a
X *	more informative string equivalent of that status.
X *
X * RETURNS
X *	char *; pointer to C string.
X *
X * CAVEAT
X *	Do not pass the returned string to free().
X *	Do not alter the contents of the string pointed to by the return value.
X *	This function is obly available when synbol DEBUG is defined.
X *	Assumes that the argument will be a valid status value.
X */
X
X#ifdef DEBUG
X
Xstatic char *cook_status_name _((cooker_result_ty));
X
Xstatic char *
Xcook_status_name(n)
X	cooker_result_ty n;
X{
X	switch (n)
X	{
X	case COOK_DONTKNOW:
X		return "COOK_DONTKNOW";
X
X	case COOK_ERROR:
X		return "COOK_ERROR";
X
X	case COOK_DONE:
X		return "COOK_DONE";
X
X	case COOK_DONE_UPTODATE:
X		return "COOK_DONE_UPTODATE";
X
X	case COOK_UPTODATE:
X		return "COOK_UPTODATE";
X
X	case COOK_BACKTRACK:
X		return "COOK_BACKTRACK";
X	}
X	return "unknown (bug)";
X}
X
X#endif
X
Xstatic cooker_result_ty cooker _((string_ty *, int, int)); /* forward */
X
X
X/*
X * NAME
X *	cook_search_list
X *
X * SYNOPSIS
X *	cook_search_list(wlist *slp);
X *
X * DESCRIPTION
X *	The cook_search_list function is used to get the search list
X *	from the "search_list" variable.
X *
X *	Defaulting and clean-up are done here, also.
X *	If absent, defaults to ".".
X *	If the first element is not "." then it is inserted.
X *
X * ARGUMENTS
X *	slp - where to put the result
X */
X
Xstatic void cook_search_list _((wlist *slp));
X
Xstatic void
Xcook_search_list(slp)
X	wlist		*slp;
X{
X	string_ty	*s;
X
X	/*
X	 * make sure the variable exists
X	 */
X	trace(("cook_search_list()\n{\n"/*}*/));
X	if (!id_search(id_search_list, slp))
X	{
X		wl_zero(slp);
X		s = str_from_c(".");
X		wl_append(slp, s);
X		str_free(s);
X		id_assign(id_search_list, slp);
X	}
X
X	/*
X	 * make sure the search list isn't empty
X	 */
X	if (!slp->wl_nwords)
X	{
X		s = str_from_c(".");
X		wl_append(slp, s);
X		str_free(s);
X		id_assign(id_search_list, slp);
X	}
X
X	/*
X	 * make sure the search list has "." as the first element
X	 */
X	if
X	(
X		slp->wl_word[0]->str_text[0] != '.'
X	||
X		slp->wl_word[0]->str_text[1]
X	)
X	{
X		s = str_from_c(".");
X		wl_prepend(slp, s);
X		str_free(s);
X		id_assign(id_search_list, slp);
X	}
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	cook_mtime
X *
X * SYNOPSIS
X *	time_t cook_mtime(string_ty *path, long *depth_p);
X *
X * DESCRIPTION
X *	The cook_mtime function is used to scan the search path for
X *	a file to determine the last-modified time of the file.
X *
X * ARGUMENTS
X *	path	- file to get the mtime for
X *	depth_p	- where to put the depth
X *
X * RETURNS
X *	long; -1 on error, 0 if no such file, >0 for time
X *
X * CAVEAT
X *	The user must design recipes using the [resolve] function.
X */
X
Xtime_t
Xcook_mtime_oldest(path, depth_p)
X	string_ty	*path;
X	long		*depth_p;
X{
X	time_t		result;
X
X	trace(("cook_mtime_oldest(path = \"%s\")\n{\n"/*}*/, path->str_text));
X	if (path->str_text[0] == '/')
X		result = os_mtime_oldest(path);
X	else
X	{
X		wlist		sl;
X		long		j;
X
X		result = 0;
X		cook_search_list(&sl);
X		for (j = 0; j < sl.wl_nwords; ++j)
X		{
X			string_ty	*s1;
X			string_ty	*s2;
X			time_t		t;
X
X			s1 = sl.wl_word[j];
X			if (s1->str_text[0] == '.' && !s1->str_text[1])
X				s2 = str_copy(path);
X			else
X				s2 = str_format("%S/%S", s1, path);
X			t = os_mtime_oldest(s2);
X			str_free(s2);
X			if (t != 0)
X			{
X				result = t;
X				*depth_p = j;
X				break;
X			}
X		}
X		wl_free(&sl);
X	}
X	trace(("return %ld (%d);\n", (long)result, *depth_p));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
Xtime_t
Xcook_mtime_newest(path, depth_p)
X	string_ty	*path;
X	long		*depth_p;
X{
X	time_t		result;
X
X	trace(("cook_mtime_newest(path = \"%s\")\n{\n"/*}*/, path->str_text));
X	if (path->str_text[0] == '/')
X		result = os_mtime_newest(path);
X	else
X	{
X		wlist		sl;
X		long		j;
X
X		result = 0;
X		cook_search_list(&sl);
X		for (j = 0; j < sl.wl_nwords; ++j)
X		{
X			string_ty	*s1;
X			string_ty	*s2;
X			time_t		t;
X
X			s1 = sl.wl_word[j];
X			if (s1->str_text[0] == '.' && !s1->str_text[1])
X				s2 = str_copy(path);
X			else
X				s2 = str_format("%S/%S", s1, path);
X			t = os_mtime_newest(s2);
X			str_free(s2);
X			if (t != 0)
X			{
X				result = t;
X				*depth_p = j;
X				break;
X			}
X		}
X		wl_free(&sl);
X	}
X	trace(("return %ld (%d);\n", (long)result, *depth_p));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	cook_mtime_resolve
X *
X * SYNOPSIS
X *	int cook_mtime_resolve(wlist *output, wlist *input);
X *
X * DESCRIPTION
X *	The cook_mtime_resolve function is used to
X *	resolve the name used for a file in the search list.
X *
X *	It implements the "resolve" built-in function.
X *
X * ARGUMENTS
X *	input - the function arguments (0 is the func name)
X *	output - where to put the results
X *
X * RETURNS
X *	int; 0 on success, -1 on error
X *
X * CAVEAT
X *	The user must design rules using the [resolve] function.
X */
X
Xint
Xcook_mtime_resolve(output, input, start)
X	wlist		*output;
X	wlist		*input;
X	int		start;
X{
X	int		result;
X	long		j;
X	wlist		sl;
X
X	trace(("cook_mtime_resolve(input = %08lX, output = %08lX)\n{\n"/*}*/,
X		input, output));
X	cook_search_list(&sl);
X	result = 0;
X	for (j = start; j < input->wl_nwords; ++j)
X	{
X		string_ty	*arg;
X
X		arg = input->wl_word[j];
X		if (arg->str_text[0] == '/')
X			wl_append(output, arg);
X		else
X		{
X			int		done;
X			long		k;
X
X			done = 0;
X			for (k = 0; k < sl.wl_nwords; ++k)
X			{
X				string_ty	*s1;
X				string_ty	*s2;
X				time_t		t;
X
X				s1 = sl.wl_word[k];
X				if (s1->str_text[0] == '.' && !s1->str_text[1])
X					s2 = str_copy(arg);
X				else
X					s2 = str_format("%S/%S", s1, arg);
X				t = os_mtime_newest(s2);
X				if (t < 0)
X				{
X					result = -1;
X					str_free(s2);
X					break;
X				}
X				if (t > 0)
X				{
X					wl_append(output, s2);
X					str_free(s2);
X					done = 1;
X					break;
X				}
X				str_free(s2);
X			}
X			if (!done)
X				wl_append(output, arg);
X		}
X		if (result < 0)
X			break;
X	}
X	wl_free(&sl);
X	trace(("return %d;\n", result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
Xstatic void strip_dot _((string_ty **));
X
Xstatic void
Xstrip_dot(p)
X	string_ty	**p;
X{
X	char		*cp;
X	size_t		len;
X	string_ty	*tmp;
X
X	cp = (*p)->str_text;
X	len = (*p)->str_length;
X	while (len >= 3 && cp[0] == '.' && cp[1] == '/')
X	{
X		cp += 2;
X		len -= 2;
X	}
X	if (len == (*p)->str_length)
X		return;
X
X	tmp = str_n_from_c(cp, len);
X	str_free(*p);
X	*p = tmp;
X}
X
X
X/*
X * NAME
X *	chef - the bit that does the cooking
X *
X * SYNOPSIS
X *	int chef(string_ty *target, int dkwinge, recipe *rp,
X *		time_ty age, int forced, int build);
X *
X * DESCRIPTION
X *	The chef function is used to evaluate a recipe
X *	which has been determined by cooker() to be applicable.
X *
X * RETURNS
X *	The chef function returns an int; one of the cook status values.
X *
X * CAVEAT
X *	The `target' variable is assumed to have already been set.
X *	The match pattern is assumed to have been pushed already.
X *	The recipe flags apply to expression evaluations for ingredients, too.
X */
X
Xstatic cooker_result_ty chef _((string_ty *, int, recipe *, time_t, int, int,
X	time_t *, long *));
X
Xstatic cooker_result_ty
Xchef(target, dkwinge, rp, age, forced, build, worst_age_p, worst_depth_p)
X	string_ty	*target;
X	int		dkwinge;
X	recipe		*rp;
X	time_t		age;
X	int		forced;
X	int		build;
X	time_t		*worst_age_p;
X	long		*worst_depth_p;
X{
X	int		j;
X	int		k;
X	cooker_result_ty best;
X	char		*recipe_type_name;
X	wlist 		friends;
X	wlist		need;
X	wlist		younger;
X	match_ty	*field;
X	time_t		mtime;
X	time_t		*friends_mtime;
X	int		fp;
X	long		initial_depth;
X	long		depth;
X
X	trace(("chef(target = %08lX, dkwinge = %d, rp = %08lX, age = %ld, \
Xforced = %d, build = %d)\n{\n"/*}*/, target, dkwinge, rp, age, forced, build));
X	trace_string(target->str_text);
X	friends_mtime = 0;
X	fp = option_test(OPTION_FINGERPRINT);
X	wl_zero(&need);
X	wl_zero(&younger);
X	wl_zero(&friends);
X	field = match_top();
X	if (field)
X	{
X		wl_reconstruct(&friends, &rp->r_target, field);
X		recipe_type_name = "implicit";
X	}
X	else
X	{
X		wl_copy(&friends, &rp->r_target);
X		recipe_type_name = "explicit";
X	}
X	id_assign_push(id_friend, &friends);
X
X	/*
X	 * age should be set to the worst case of all the targets
X	 *
X	 * The depth of the target search should be less than or equal
X	 * to the depth of the worst (shallowest) ingredients search.
X	 * This is to guarantee that when ingredients change they
X	 * result in targets shallower in the path being updated.
X	 */
X	initial_depth = *worst_depth_p;
X	if (fp)
X		friends_mtime = mem_alloc(friends.wl_nwords * sizeof(time_t));
X	for (j = 0; j < friends.wl_nwords; ++j)
X	{
X		string_ty	*s;
X		time_t		age2;
X
X		s = friends.wl_word[j];
X		if (fp)
X		{
X			depth = *worst_depth_p;
X			age2 = cook_mtime_oldest(s, &depth);
X			if (age2 < 0)
X			{
X				best = COOK_ERROR;
X				goto ret;
X			}
X			friends_mtime[j] = age2;
X		}
X		depth = *worst_depth_p;
X		age2 = cook_mtime_newest(s, &depth);
X		if (age2 < 0)
X		{
X			best = COOK_ERROR;
X			goto ret;
X		}
X		if (depth > *worst_depth_p)
X		{
X			age2 = 0;
X			if (option_test(OPTION_TRACE))
X			{
X				error
X				(
X    "\"%s\" is out of date because an ingredients recipe was shallower (trace)",
X					target->str_text
X				);
X			}
X			forced = 1;
X		}
X		if (age2 < age)
X			age = age2;
X	}
X
X	/*
X	 * Flags apply to the precondition and to the ingredients evaluation.
X	 * That is why the grammar puts them first.
X	 */
X	cook_flags(rp->r_flags, OPTION_LEVEL_RECIPE);
X
X	/*
X	 * wander through the ingredients, seeing if we know how to cook them
X	 *	the first set is used to determine if to use this recipe
X	 *	the second set must be cookable
X	 */
X	if (*worst_age_p >= age)
X	{
X		if (option_test(OPTION_TRACE))
X		{
X			error
X			(
X      "\"%s\" is out of date because an ingredients recipe was younger (trace)",
X				target->str_text
X			);
X		}
X		forced = 1;
X	}
X	if (option_test(OPTION_FORCE))
X	{
X		if (option_test(OPTION_TRACE))
X		{
X			error
X			(
X "\"%s\" is out of date because the recipe has the \"forced\" flag set (trace)",
X				target->str_text
X			);
X		}
X		forced = 1;
X	}
X	best = COOK_UPTODATE;
X	trace(("check first ingredients\n"));
X	for (j = 0; j < rp->r_need.el_nexprs; ++j)
X	{
X		wlist	wl;
X
X		wl_zero(&wl);
X		if (expr_eval(&wl, rp->r_need.el_expr[j]))
X		{
X			wl_free(&wl);
X			best = COOK_ERROR;
X			goto ret;
X		}
X		for (k = 0; k < wl.wl_nwords; ++k)
X		{
X			string_ty	*target2;
X			cooker_result_ty best2;
X
X			if (option_test(OPTION_STRIP_DOT))
X				strip_dot(&wl.wl_word[k]);
X			target2 = wl.wl_word[k];
X			if (!os_legal_path(target2))
X			{
X				best = COOK_BACKTRACK;
X				wl_free(&wl);
X				goto ret;
X			}
X			wl_append_unique(&need, target2);
X			assert(rp->r_tag <= max_tag);
X			if (option_test(OPTION_TRACE))
X			{
X				error
X				(
X				     "\"%s\" %s \"%s\" by %s recipe %d (trace)",
X					target->str_text,
X					(dkwinge ? "requires" : "may require"),
X					target2->str_text,
X					recipe_type_name,
X					rp->r_tag
X				);
X			}
X			if (field)
X			{
X				match_ty	*inhibit;
X
X				/*
X				 * if any of the ingredients of an
X				 * implicit recipe match the targets of
X				 * that same recipe, inhibit the
X				 * recursive application the recipe.
X				 */
X				inhibit = wl_match(&rp->r_target, target2);
X				if (inhibit)
X				{
X					rp->inhibit = 1;
X					match_free(inhibit);
X				}
X			}
X			option_undo_level(OPTION_LEVEL_RECIPE);
X			best2 = cooker(target2, dkwinge, build);
X			cook_flags(rp->r_flags, OPTION_LEVEL_RECIPE);
X			rp->inhibit = 0;
X			if (best2 == COOK_DONTKNOW)
X				best2 = COOK_ERROR;
X			if (best2 < best)
X				best = best2;
X			switch (best2)
X			{
X			case COOK_BACKTRACK:
X				best = best2;
X				wl_free(&wl);
X				goto ret;
X
X			default:
X				if (!option_test(OPTION_PERSEVERE))
X				{
X					wl_free(&wl);
X					goto ret;
X				}
X				break;
X
X			case COOK_UPTODATE:
X			case COOK_DONE_UPTODATE:
X				depth = *worst_depth_p;
X				mtime = cook_mtime_oldest(target2, &depth);
X				if (mtime < 0)
X				{
X					wl_free(&wl);
X					best = COOK_ERROR;
X					goto ret;
X				}
X				if (mtime > *worst_age_p)
X					*worst_age_p = mtime;
X				if (depth < *worst_depth_p)
X					*worst_depth_p = depth;
X				if (mtime < age)
X					break;
X				if (option_test(OPTION_TRACE))
X				{
X					error
X					(
X		      "\"%s\" is out of date because \"%s\" is younger (trace)",
X						target->str_text,
X						target2->str_text
X					);
X				}
X				forced = 1;
X				wl_append_unique(&younger, target2);
X				break;
X
X			case COOK_DONE:
X				depth = *worst_depth_p;
X				mtime = cook_mtime_oldest(target2, &depth);
X				if (mtime < 0)
X				{
X					wl_free(&wl);
X					best = COOK_ERROR;
X					goto ret;
X				}
X				if (mtime > *worst_age_p)
X					*worst_age_p = mtime;
X				if (depth < *worst_depth_p)
X					*worst_depth_p = depth;
X				if (option_test(OPTION_TRACE))
X				{
X					error
X					(
X   "\"%s\" is out of date because \"%s\" was cooked and is now younger (trace)",
X						target->str_text,
X						target2->str_text
X					);
X				}
X				forced = 1;
X				wl_append_unique(&younger, target2);
X				break;
X			}
X		}
X		wl_free(&wl);
X	}
X	trace(("check second ingredients\n"));
X	for (j = 0; j < rp->r_need2.el_nexprs; ++j)
X	{
X		wlist		wl;
X
X		wl_zero(&wl);
X		if (expr_eval(&wl, rp->r_need2.el_expr[j]))
X		{
X			wl_free(&wl);
X			best = COOK_ERROR;
X			goto ret;
X		}
X		for (k = 0; k < wl.wl_nwords; ++k)
X		{
X			string_ty	*target2;
X			cooker_result_ty best2;
X
X			if (option_test(OPTION_STRIP_DOT))
X				strip_dot(&wl.wl_word[j]);
X			target2 = wl.wl_word[k];
X			if (!os_legal_path(target2))
X			{
X				best = COOK_BACKTRACK;
X				wl_free(&wl);
X				goto ret;
X			}
X			wl_append_unique(&need, target2);
X			if (option_test(OPTION_TRACE))
X			{
X				error
X				(
X			       "\"%s\" requires \"%s\" by %s recipe %d (trace)",
X					target->str_text,
X					target2->str_text,
X					recipe_type_name,
X					rp->r_tag
X				);
X			}
X			option_undo_level(OPTION_LEVEL_RECIPE);
X			best2 = cooker(target2, 1, build);
X			cook_flags(rp->r_flags, OPTION_LEVEL_RECIPE);
X			if (best2 == COOK_BACKTRACK || best2 == COOK_DONTKNOW)
X				best2 = COOK_ERROR;
X			if (best2 < best)
X				best = best2;
X			switch (best2)
X			{
X			default:
X				if (!option_test(OPTION_PERSEVERE))
X				{
X					wl_free(&wl);
X					goto ret;
X				}
X				break;
X
X			case COOK_UPTODATE:
X			case COOK_DONE_UPTODATE:
X				depth = *worst_depth_p;
X				mtime = cook_mtime_oldest(target2, &depth);
X				if (mtime < 0)
X				{
X					wl_free(&wl);
X					best = COOK_ERROR;
X					goto ret;
X				}
X				if (mtime > *worst_age_p)
X					*worst_age_p = mtime;
X				if (depth < *worst_depth_p)
X					*worst_depth_p = depth;
X				if (mtime < age)
X					break;
X				if (option_test(OPTION_TRACE))
X				{
X					error
X					(
X		      "\"%s\" is out of date because \"%s\" is younger (trace)",
X						target->str_text,
X						target2->str_text
X					);
X				}
X				forced = 1;
X				wl_append_unique(&younger, target2);
X				break;
X
X			case COOK_DONE:
X				depth = *worst_depth_p;
X				mtime = cook_mtime_oldest(target2, &depth);
X				if (mtime < 0)
X				{
X					wl_free(&wl);
X					best = COOK_ERROR;
X					goto ret;
X				}
X				if (mtime > *worst_age_p)
X					*worst_age_p = mtime;
X				if (depth < *worst_depth_p)
X					*worst_depth_p = depth;
X				if (option_test(OPTION_TRACE))
X				{
X					error
X					(
X   "\"%s\" is out of date because \"%s\" was cooked and is now younger (trace)",
X						target->str_text,
X						target2->str_text
X					);
X				}
X				forced = 1;
X				wl_append_unique(&younger, target2);
X				break;
X			}
X		}
X		wl_free(&wl);
X	}
X
X	/*
X	 * see if this recipe applies
X	 */
X	trace(("check precondition\n"));
X	if (rp->r_precondition)
X	{
X		int		result;
X
X		id_assign_push(id_need, &need);
X		id_assign_push(id_younger, &younger);
X		result = expr_eval_condition(rp->r_precondition);
X		id_delete(id_need);
X		id_delete(id_younger);
X		switch (result)
X		{
X		case -1:
X			best = COOK_ERROR;
X			goto ret;
X
X		case 0:
X			if (option_test(OPTION_TRACE))
X			{
X				error
X				(
X			 "\"%s\" precondition for %s recipe %d rejects (trace)",
X					target->str_text,
X					recipe_type_name,
X					rp->r_tag
X				);
X			}
X			best = COOK_BACKTRACK;
X			goto ret;
X		}
X	}
X
X	/*
X	 * if the target depth became lower,
X	 * rescan the targets to see if this implies out-of-date
X	 *
X	 * The depth of the target search should be less than or equal
X	 * to the depth of the worst (shallowest) ingredients search.
X	 * This is to guarantee that when ingredients change they
X	 * result in targets shallower in the path being updated.
X	 */
X	if (initial_depth != *worst_depth_p && !forced)
X	{
X		for (j = 0; j < friends.wl_nwords; ++j)
X		{
X			string_ty	*s;
X			time_t		age2;
X
X			s = friends.wl_word[j];
X			depth = *worst_depth_p;
X			age2 = cook_mtime_newest(s, &depth);
X			if (age2 < 0)
X			{
X				best = COOK_ERROR;
X				goto ret;
X			}
X			if (depth > *worst_depth_p)
X			{
X				if (option_test(OPTION_TRACE))
X				{
X					error
X					(
X	     "\"%s\" is out of date because an ingredient is shallower (trace)",
X						s->str_text
X					);
X				}
X				forced = 1;
X				break;
X			}
X		}
X	}
X
X	/*
X	 * See if we need to perform the actions attached to this recipe.
X	 */
X	if (forced && rp->r_action)
X	{
X		trace(("do recipe body\n"));
X		if (build)
X		{
X			if (option_test(OPTION_TOUCH))
X			{
X				for (k = 0; k < rp->r_target.wl_nwords; k++)
X				{
X					if (!option_test(OPTION_SILENT))
X					{
X						error
X						(
X							"touch %s",
X					       rp->r_target.wl_word[k]->str_text
X						);
X					}
X					if (os_touch(rp->r_target.wl_word[k]))
X						best = COOK_ERROR;
X					else
X						best = COOK_DONE;
X				}
X			}
X			else
X			{
X				int		result;
X
X				id_assign_push(id_need, &need);
X				id_assign_push(id_younger, &younger);
X				result = stmt_eval(rp->r_action);
X				id_delete(id_need);
X				id_delete(id_younger);
X				switch (result)
X				{
X				case STMT_BACKTRACK:
X					best = COOK_DONTKNOW;
X					break;
X
X				case STMT_OK:
X					best = COOK_DONE;
X					break;
X
X				case STMT_ERROR:
X					if (option_test(OPTION_ERROK))
X						best = COOK_DONE;
X					else
X						best = COOK_ERROR;
X					break;
X
X				default:
X					best = COOK_ERROR;
X					break;
X				}
X				if
X				(
X					best == COOK_ERROR
X				&&
X					!option_test(OPTION_PRECIOUS)
X				)
X				{
X					for (k = 0; k < friends.wl_nwords; k++)
X						os_delete(friends.wl_word[k]);
X				}
X			}
X		}
X		else
X			best = COOK_DONE;
X	}
X
X	/*
X	 * This recipe is being used, so
X	 * perform its 'use' action.
X	 *
X	 * Ignore the 'touch' option,
X	 * ignore the 'errok' option,
X	 * don't delete files on errors.
X	 */
X	if (rp->r_use_action && build)
X	{
X		int		result;
X
X		trace(("perform ``use'' clause\n"));
X		id_assign_push(id_need, &need);
X		id_assign_push(id_younger, &younger);
X		result = stmt_eval(rp->r_use_action);
X		id_delete(id_need);
X		id_delete(id_younger);
X		if (result != STMT_OK)
X			best = STMT_ERROR;
X	}
X
Xret:
X	option_undo_level(OPTION_LEVEL_RECIPE);
X	wl_free(&need);
X	wl_free(&younger);
X	if (best == COOK_DONE && rp->r_action && build)
X	{
X		mtime = *worst_age_p + 1;
X		if (fp)
X		{
X			/*
X			 * Update the times, and see if the pringerprint
X			 * changed.  If the fingerprint did not change
X			 * on any target, use the DONE_UPTODATE result,
X			 * not DONE.
X			 */
X			for (j = 0; j < friends.wl_nwords; ++j)
X			{
X				string_ty	*s;
X				time_t		t;
X
X				s = friends.wl_word[j];
X				os_clear_stat(s);
X				if (os_mtime_adjust(s, mtime))
X				{
X					best = COOK_ERROR;
X					continue;
X				}
X				if (friends_mtime[j] <= 0)
X				{
X					already_assign(s, COOK_DONE);
X					continue;
X				}
X				t = os_mtime_oldest(s);
X				if (t < 0)
X				{
X					best = COOK_ERROR;
X					continue;
X				}
X				if (t != friends_mtime[j])
X					already_assign(s, COOK_DONE);
X				else
X					already_assign(s, COOK_DONE_UPTODATE);
X			}
X			if (best != COOK_ERROR)
X				already_search(target, &best);
X		}
X		else
X		{
X			/*
X			 * update the times if it worked
X			 * and if it was not an ingredients recipe
X			 */
X			for (j = 0; j < friends.wl_nwords; j++)
X			{
X				string_ty	*s;
X
X				s = friends.wl_word[j];
X				if (os_mtime_adjust(s, mtime))
X					best = COOK_ERROR;
X				else
X					already_assign(s, COOK_DONE);
X			}
X		}
X	}
X	if
X	(
X		rp->r_action
X	&&
X		best != COOK_BACKTRACK
X	&&
X		best != COOK_DONE
X	)
X	{
X		for (j = 0; j < friends.wl_nwords; j++)
X			already_assign(friends.wl_word[j], best);
X	}
X	if (best == COOK_UPTODATE)
X		star();
X	wl_free(&friends);
X	id_delete(id_friend);
X	if (friends_mtime)
X		mem_free(friends_mtime);
X	trace(("return %s;\n", cook_status_name(best)));
X	trace((/*{*/"}\n"));
X	return best;
X}
X
X
X/*
X * NAME
X *	cooker - cook a target
X *
X * SYNOPSIS
X *	int cooker(string_ty *target, int dkwinge, int build);
X *
X * DESCRIPTION
X *	The cooker function is used to find and perform the actions required
X *	to bring the given target up-to-date.
X *
X * RETURNS
X *	The cook function returns int; one of the status return values
X *
X *	COOK_BACKTRACK	the given target was not possble, try something else
X *	COOK_UPTODATE	the given target required no action
X *	COOK_DONE_UPTODATE
X *			the given target required some action,
X *			but the results are identical to previous
X *	COOK_DONE	some action was performed to bring it up to date
X *	COOK_ERROR	an error was found when performing some action
X *	COOK_DONTKNOW	don't know how to cook the given target
X  */
X
Xstatic cooker_result_ty cooker _((string_ty *, int, int));
X
Xstatic cooker_result_ty
Xcooker(target, dkwinge, build)
X	string_ty	*target;	/* file which we want to cook */
X	int		dkwinge;	/* complain if don't know how to */
X	int		build;		/* build if true, EWOULDBUILD if not */
X{
X	time_t		age;		/* age of the target file */
X	int		j;		/* looping temporary */
X	cooker_result_ty best;		/* return status */
X	cooker_result_ty best2;
X	int		outofdate;
X	int		used_explicit_recipe;
X	int		used_ingredients_recipe;
X	int		used_implicit_recipe;
X	wlist		target_list;
X	time_t		worst_age;
X	long		worst_depth;
X
X	trace(("cooker(target = %08lX, dkwinge = %d, build = %d)\n{\n"/*}*/,
X		(long)target, dkwinge, build));
X	trace_string(target->str_text);
X	if (option_test(OPTION_STRIP_DOT))
X		strip_dot(&target);
X	wl_zero(&target_list);
X	wl_append(&target_list, target);
X	id_assign_push(id_target, &target_list);
X	wl_free(&target_list);
X	used_ingredients_recipe = 0;
X	used_explicit_recipe = 0;
X	used_implicit_recipe = 0;
X
X	/*
X	 * Check to see if this one has been cooked already.
X	 * It may have failed, too.  If it is currently being cooked
X	 * a value of COOK_BACKTRACK will be returned, this is to
X	 * trap recursive recipes.
X	 */
X	if (already_search(target, &best))
X	{
X		if (best == COOK_BACKTRACK)
X		{
X			error
X			(
X				"%s: subject of recipe infinite loop",
X				target->str_text
X			);
X			option_set_errors();
X			best = COOK_ERROR;
X		}
X		goto ret;
X	}
X
X	/*
X	 * add it to the "currently being cooked" list
X	 */
X	best = COOK_UPTODATE;
X	worst_depth = 32767;
X	age = cook_mtime_newest(target, &worst_depth);
X	if (age < 0)
X	{
X		best = COOK_ERROR;
X		goto ret;
X	}
X	best2 = COOK_BACKTRACK;
X	already_assign(target, best2);
X	worst_age = 0;
X
X	/*
X	 * Look for the named file in the recipes.
X	 * If it matches, cook its prerequisites.
X	 * It is an explicit recipe if there is any action attached to
X	 * any recipe targeting the named file.
X	 */
X	outofdate = !age || option_test(OPTION_FORCE);
X	trace(("outofdate = %d;\n", outofdate));
X
X	/*
X	 * Cook scans through the instanciated ingredients recipes.  All
X	 * ingredients recipes with the target in their target list are used.
X	 *
X	 * If the recipe is used, any prerequisite files are recursively
X	 * cooked, then if any of the prerequisite files were out of date, then
X	 * all other explicit or implicit recipes with the same target will be
X	 * deemed to be out of date.
X	 */
X	trace(("check for ingredients recipes\n"));
X	for (j = 0; j < explicit.rl_nrecipes; j++)
X	{
X		if (desist)
X		{
X			trace(("interrupted, desisting\n"));
X			best = COOK_ERROR;
X			goto ret;
X		}
X
X		if
X		(
X			explicit.rl_recipe[j].r_action
X		||
X			!wl_member(&explicit.rl_recipe[j].r_target, target)
X		)
X			best2 = COOK_BACKTRACK;
X		else
X		{
X			match_push((match_ty *)0);
X			best2 =
X				chef
X				(
X					target,
X					dkwinge,
X					&explicit.rl_recipe[j],
X					age,
X					outofdate,
X					build,
X					&worst_age,
X					&worst_depth
X				);
X			match_pop();
X		}
X		if (best2 == COOK_BACKTRACK)
X			continue;
X		used_ingredients_recipe = 1;
X		if (best2 < best)
X			best = best2;
X		if (best2 < COOK_DONE && !option_test(OPTION_PERSEVERE))
X			goto ret;
X	}
X	if (best == COOK_DONE)
X		outofdate = 1;
X	trace(("outofdate = %d;\n", outofdate));
X
X	/*
X	 * Cook then scans through the instanciated explicit recipes.
X	 * Keep looping until a single-colon recipe is met.
X	 *
X	 * If the recipe is used, any prerequisite files are recursively
X	 * cooked, then if any prerequisites were out of date (including those
X	 * of prerequisite recipes) then the actions bound to this recipe will
X	 * be evaluated.
X	 */
X	trace(("check explicit recipes\n"));
X	for (j = 0; j < explicit.rl_nrecipes; j++)
X	{
X		if (desist)
X		{
X			best = COOK_ERROR;
X			goto ret;
X		}
X
X		if
X		(
X			!explicit.rl_recipe[j].r_action
X		||
X			!wl_member(&explicit.rl_recipe[j].r_target, target)
X		)
X			best2 = COOK_BACKTRACK;
X		else
X		{
X			match_push((match_ty *)0);
X			best2 =
X				chef
X				(
X					target,
X					dkwinge,
X					&explicit.rl_recipe[j],
X					age,
X					outofdate,
X					build,
X					&worst_age,
X					&worst_depth
X				);
X			match_pop();
X		}
X		if (best2 == COOK_BACKTRACK)
X			continue;
X		used_explicit_recipe = 1;
X		if (best2 < best)
X			best = best2;
X		if (best2 < COOK_DONE && !option_test(OPTION_PERSEVERE))
X			goto ret;
X		if (!explicit.rl_recipe[j].r_multiple)
X			goto ret;
X	}
X	if (used_explicit_recipe)
X		goto ret;
X	trace(("outofdate = %d;\n", outofdate));
X
X	/*
X	 * None of the recipes specified an action,
X	 * although prerequisites may have been specified.
X	 * Check out the implicit recipes, instead.
X	 *
X	 * The tricky part is when going through several
X	 * layers of recipes.  If a cook of a prerequisite comes back
X	 * with BACKTRACK, then try something else.
X	 *
X	 * Only the first applicable implicit recipe is used.
X	 */
X	trace(("check implicit recipes\n"));
X	for (j = 0; j < implicit.rl_nrecipes; j++)
X	{
X		match_ty *mbuf;
X
X		if (desist)
X		{
X			best = COOK_ERROR;
X			goto ret;
X		}
X
X		if (implicit.rl_recipe[j].inhibit)
X			continue;
X		mbuf = wl_match(&implicit.rl_recipe[j].r_target, target);
X		if (mbuf)
X		{
X			match_push(mbuf);
X			best2 =
X				chef
X				(
X					target,
X					0,
X					&implicit.rl_recipe[j],
X					age,
X					outofdate,
X					build,
X					&worst_age,
X					&worst_depth
X				);
X			match_pop();
X			match_free(mbuf);
X		}
X		else
X			best2 = COOK_BACKTRACK;
X		if (best2 == COOK_BACKTRACK)
X			continue;
X		used_implicit_recipe = 1;
X		if (best2 < best)
X			best = best2;
X		if (!implicit.rl_recipe[j].r_multiple)
X			goto ret;
X	}
X	if (used_implicit_recipe)
X		goto ret;
X	trace(("outofdate = %d;\n", outofdate));
X
X	/*
X	 * None of the implicit recipes worked, either
X	 * (perhapse none applied)
X	 * so we don't know how to make this one.
X	 *
X	 * If it already exists, it must be up-to-date;
X	 * but if it doesn't exist, then we may want to backtrack.
X	 */
X	trace(("no recipe applied\n"));
X	if (age <= 0 && !used_ingredients_recipe)
X		best = (dkwinge ? COOK_DONTKNOW : COOK_BACKTRACK);
X	if (best != COOK_BACKTRACK)
X		already_assign(target, best);
X
Xret:
X	if (already_search(target, &best2) && best2 == COOK_BACKTRACK)
X		already_delete(target);
X	id_delete(id_target);
X	if (option_test(OPTION_TRACE))
X	{
X		char		*name;
X
X		switch (best)
X		{
X		case COOK_DONTKNOW:
X			name = "don't know how";
X			break;
X
X		case COOK_ERROR:
X			name = "error";
X			break;
X
X		case  COOK_DONE:
X			name = "done";
X			break;
X
X		case COOK_DONE_UPTODATE:
X			name = "done and found to be up to date";
X			break;
X
X		case COOK_UPTODATE:
X			name = "up to date";
X			break;
X
X		case COOK_BACKTRACK:
X			name = "backtracking";
X			break;
X		}
X		error("\"%s\" %s (trace)", target->str_text, name);
X	}
X	else
X	{
X		switch (best)
X		{
X		case COOK_DONTKNOW:
X			if (dkwinge)
X				error("%s: don't know how", target->str_text);
X			break;
X
X		case COOK_ERROR:
X			error
X			(
X				"%s: not done because of errors",
X				target->str_text
X			);
X			break;
X
X		default:
X			break;
X		}
X	}
X	trace(("return %s;\n", cook_status_name(best)));
X	trace((/*{*/"}\n"));
X	return best;
X}
X
X
X/*
X * NAME
X *	rl_append - append a recipe
X *
X * SYNOPSIS
X *	void el_append(rlist *rlp, recipe *rp);
X *
X * DESCRIPTION
X *	Rl_append is used to append a recipe to a recipe list.
X *
X * CAVEAT
X *	Recipes need to overwrite other recipes with
X *	identical target and prerequisite lists.
X */
X
Xvoid
Xrl_append(rlp, rp)
X	rlist		*rlp;
X	recipe		*rp;
X{
X	size_t		nbytes;
X	size_t		j;
X
X	trace(("rl_append(rlp = %08lX, rp = %08lX)\n{\n"/*}*/, rlp, rp));
X	assert(rlp);
X	assert(rp);
X	assert(!rlp->rl_nrecipes == !rlp->rl_recipe);
X	assert(rp->r_tag > 0 && rp->r_tag <= max_tag);
X
X	if (option_test(OPTION_STRIP_DOT))
X		for (j = 0; j < rp->r_target.wl_nwords; ++j)
X			strip_dot(&rp->r_target.wl_word[j]);
X	rp->inhibit = 0;
X
X	nbytes = (rlp->rl_nrecipes + 1) * sizeof(recipe);
X	rlp->rl_recipe = mem_change_size(rlp->rl_recipe, nbytes);
X	rlp->rl_recipe[rlp->rl_nrecipes++] = *rp;
X	trace((/*{*/"}\n"));
X}
X
X
Xstatic void recipe_free _((recipe *));
X
Xstatic void
Xrecipe_free(rp)
X	recipe	*rp;
X{
X	wl_free(&rp->r_target);
X	el_free(&rp->r_need);
X	el_free(&rp->r_need2);
X	if (rp->r_action)
X		stmt_free(rp->r_action);
X	if (rp->r_use_action)
X		stmt_free(rp->r_use_action);
X	if (rp->r_precondition)
X		expr_free(rp->r_precondition);
X}
X
X
Xstatic void rl_free _((rlist *));
X
Xstatic void
Xrl_free(rlp)
X	rlist		*rlp;
X{
X	long		j;
X
X	trace(("rl_free(rlp = %08lX)\n{\n"/*}*/, (long)rlp));
X	assert(rlp);
X	assert(!rlp->rl_nrecipes == !rlp->rl_recipe);
X	for (j = 0; j < rlp->rl_nrecipes; ++j)
X		recipe_free(&rlp->rl_recipe[j]);
X	if (rlp->rl_recipe)
X		mem_free(rlp->rl_recipe);
X	rlp->rl_recipe = 0;
X	rlp->rl_nrecipes = 0;
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	cook_flags - set them
X *
X * SYNOPSIS
X *	void cook_flags(int mask, option_levelk_ty level);
X *
X * DESCRIPTION
X *	The cook_flags function is used to take a flags variable and set the
X *	appropriate options at the given level.
X *
X * RETURNS
X *	void
X *
X * CAVEAT
X *	Use the option_undo_level function to remove the flag settings.
X */
X
Xvoid
Xcook_flags(mask, level)
X	int		mask;
X	int		level;
X{
X	trace(("cook_flags(mask = 0x%04X, level = %d)\n{\n"/*}*/, mask, level));
X	if (mask & RF_CLEARSTAT)
X		option_set(OPTION_INVALIDATE_STAT_CACHE, level, 1);
X	if (mask & RF_CLEARSTAT_OFF)
X		option_set(OPTION_INVALIDATE_STAT_CACHE, level, 0);
X	if (mask & RF_ERROK)
X		option_set(OPTION_ERROK, level, 1);
X	if (mask & RF_ERROK_OFF)
X		option_set(OPTION_ERROK, level, 0);
X	if (mask & RF_FINGERPRINT)
X		option_set(OPTION_FINGERPRINT, level, 1);
X	if (mask & RF_FINGERPRINT_OFF)
X		option_set(OPTION_FINGERPRINT, level, 0);
X	if (mask & RF_FORCE)
X		option_set(OPTION_FORCE, level, 1);
X	if (mask & RF_FORCE_OFF)
X		option_set(OPTION_FORCE, level, 0);
X	if (mask & RF_METER)
X		option_set(OPTION_METER, level, 1);
X	if (mask & RF_METER_OFF)
X		option_set(OPTION_METER, level, 0);
X	if (mask & RF_PRECIOUS)
X		option_set(OPTION_PRECIOUS, level, 1);
X	if (mask & RF_PRECIOUS_OFF)
X		option_set(OPTION_PRECIOUS, level, 0);
X	if (mask & RF_SILENT)
X		option_set(OPTION_SILENT, level, 1);
X	if (mask & RF_SILENT_OFF)
X		option_set(OPTION_SILENT, level, 0);
X	if (mask & RF_UPDATE)
X		option_set(OPTION_UPDATE, level, 1);
X	if (mask & RF_UPDATE_OFF)
X		option_set(OPTION_UPDATE, level, 0);
X	if (mask & RF_STRIPDOT)
X		option_set(OPTION_STRIP_DOT, level, 1);
X	if (mask & RF_STRIPDOT_OFF)
X		option_set(OPTION_STRIP_DOT, level, 0);
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	cook - construct files
X *
X * SYNOPSIS
X *	int cook(wlist *targets);
X *
X * DESCRIPTION
X *	The cook function is used to cook the given set of targets.
X *
X * RETURNS
X *	The cook function returns 0 if all of the targets cooked sucessfully,
X *	or 1 if there was any problem.
X *
X * CAVEAT
X *	This function must be called after evrything has been initialized,
X *	and the cookbook read in.
X */
X
Xint
Xcook(wlp)
X	wlist		*wlp;
X{
X	int		retval;
X	int		j;
X
X	/*
X	 * set interrupts to catch
X	 *
X	 * Note that tee(1) [see listing.c] must ignore them
X	 * for the generated messages to appear in the log file.
X	 */
X	trace(("cook(wlp = %08lX)\n{\n"/*}*/, wlp));
X	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
X		signal(SIGINT, interrupt);
X	if (signal(SIGHUP, SIG_IGN) != SIG_IGN)
X		signal(SIGHUP, interrupt);
X	if (signal(SIGTERM, SIG_IGN) != SIG_IGN)
X		signal(SIGTERM, interrupt);
X
X	/*
X	 * cook each of the targets
X	 */
X	retval = 0;
X	for (j = 0; j < wlp->wl_nwords; j++)
X	{
X		switch (cooker(wlp->wl_word[j], 1, 1))
X		{
X		case COOK_ERROR:
X		case COOK_DONTKNOW:
X		case COOK_BACKTRACK:
X			retval = 1;
X			break;
X
X		case COOK_UPTODATE:
X			error
X			(
X				"%s: already up to date",
X				wlp->wl_word[j]->str_text
X			);
X			break;
X
X		case COOK_DONE_UPTODATE:
X		case COOK_DONE:
X			break;
X		}
X		if (retval > 0 && !option_test(OPTION_PERSEVERE))
X			break;
X	}
X	trace(("return %d;\n", retval));
X	trace((/*{*/"}\n"));
X	return retval;
X}
X
X
X/*
X * NAME
X *	isit_uptodate - test construct files
X *
X * SYNOPSIS
X *	int isit_uptodate(string_ty *target);
X *
X * DESCRIPTION
X *	The isit_uptodate function is used test if the giben target
X *	is up to date.
X *
X * RETURNS
X *	The isit_uptodate function returns
X *		-1 if any error is encountered
X *		0 if not up to date, or don't know how
X *		1 if target is uptodate.
X *
X * CAVEAT
X *	This function must be called after everything has been initialized,
X *	and the cookbook read in.
X */
X
Xint
Xisit_uptodate(target)
X	string_ty	*target;
X{
X	int		retval;
X
X	/*
X	 * set interrupts to catch
X	 *
X	 * Note that tee(1) [see listing.c] must ignore them
X	 * for the generated messages to appear in the log file.
X	 */
X	trace(("isit_uptodate(target = %08lX)\n{\n"/*}*/, target));
X	trace_string(target->str_text);
X	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
X		signal(SIGINT, interrupt);
X	if (signal(SIGHUP, SIG_IGN) != SIG_IGN)
X		signal(SIGHUP, interrupt);
X	if (signal(SIGTERM, SIG_IGN) != SIG_IGN)
X		signal(SIGTERM, interrupt);
X
X	/*
X	 * cook the target
X	 */
X	switch (cooker(target, 0, 0))
X	{
X	default:
X		retval = -1;
X		break;
X
X	case COOK_UPTODATE:
X	case COOK_DONE_UPTODATE:
X		retval = 1;
X		break;
X
X	case COOK_DONE:
X	case COOK_DONTKNOW:
X		retval = 0;
X		break;
X	}
X	trace(("return %d;\n", retval));
X	trace((/*{*/"}\n"));
X	return retval;
X}
X
X
X/*
X * NAME
X *	cando - test construct files
X *
X * SYNOPSIS
X *	int cando(string_ty *target);
X *
X * DESCRIPTION
X *	The cando function is used to test if the given target is cookable.
X *
X * RETURNS
X *	The cando function returns
X *		-1 if any error was encountered
X *		0 if can't cook the target
X *		1 if can cook target
X *
X * CAVEAT
X *	This function must be called after everything has been initialized,
X *	and the cookbook read in.
X */
X
Xint
Xcando(target)
X	string_ty	*target;
X{
X	int		retval;
X
X	/*
X	 * set interrupts to catch
X	 *
X	 * Note that tee(1) [see listing.c] must ignore them
X	 * for the generated messages to appear in the log file.
X	 */
X	trace(("cando(target = %08lX)\n{\n"/*}*/, target));
X	trace_string(target->str_text);
X	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
X		signal(SIGINT, interrupt);
X	if (signal(SIGHUP, SIG_IGN) != SIG_IGN)
X		signal(SIGHUP, interrupt);
X	if (signal(SIGTERM, SIG_IGN) != SIG_IGN)
X		signal(SIGTERM, interrupt);
X
X	/*
X	 * cook the target
X	 */
X	switch (cooker(target, 0, 0))
X	{
X	default:
X		retval = -1;
X		break;
X
X	case COOK_DONTKNOW:
X		retval = 0;
X		break;
X
X	case COOK_UPTODATE:
X	case COOK_DONE_UPTODATE:
X	case COOK_DONE:
X		retval = 1;
X		break;
X	}
X	trace(("return %d;\n", retval));
X	trace((/*{*/"}\n"));
X	return retval;
X}
X
X
Xvoid
Xcook_auto(wlp)
X	wlist		*wlp;
X{
X	long		j;
X
X	for (j = 0; j < wlp->wl_nwords; ++j)
X	{
X		wl_append_unique(&cook_auto_list, wlp->wl_word[j]);
X	}
X}
X
X
Xint
Xcook_auto_required()
X{
X	int		result;
X	long		j;
X
X	result = 0;
X	option_set(OPTION_ACTION, OPTION_LEVEL_AUTO, 1);
X	option_set(OPTION_TOUCH, OPTION_LEVEL_AUTO, 0);
X	for (j = 0; j < cook_auto_list.wl_nwords; ++j)
X	{
X		int	status;
X
X		status = cooker(cook_auto_list.wl_word[j], 1, 1);
X		switch (status)
X		{
X		default:
X			result = -1;
X			break;
X
X		case COOK_UPTODATE:
X		case COOK_DONE_UPTODATE:
X			continue;
X
X		case COOK_DONE:
X			result = 1;
X			continue;
X		}
X		break;
X	}
X	option_undo(OPTION_ACTION, OPTION_LEVEL_AUTO);
X	option_undo(OPTION_TOUCH, OPTION_LEVEL_AUTO);
X	return result;
X}
X
X
Xvoid
Xcook_reset()
X{
X	wl_free(&cook_auto_list);
X	rl_free(&explicit);
X	rl_free(&implicit);
X	max_tag = 0;
X	if (already)
X	{
X		symtab_free(already);
X		already = 0;
X	}
X}
X
X
Xvoid
Xcook_find_default(wlp)
X	wlist		*wlp;
X{
X	size_t		j;
X	recipe		*rp;
X
X	/*
X	 * use the forst one
X	 * explicitly flagged default
X	 */
X	for (j = 0; j < explicit.rl_nrecipes; ++j)
X	{
X		rp = &explicit.rl_recipe[j];
X		if (rp->r_flags & RF_DEFAULT)
X		{
X			wl_copy(wlp, &rp->r_target);
X			return;
X		}
X	}
X
X	/*
X	 * use the first one
X	 * not flagged nodefault
X	 */
X	for (j = 0; j < explicit.rl_nrecipes; ++j)
X	{
X		rp = &explicit.rl_recipe[j];
X		if (!(rp->r_flags & RF_DEFAULT_OFF))
X		{
X			wl_copy(wlp, &rp->r_target);
X			return;
X		}
X	}
X
X	/*
X	 * fatal error otherwise
X	 */
X	fatal("no default target");
X}
END_OF_FILE
if test 42411 -ne `wc -c <'cook/cook.c'`; then
    echo shar: \"'cook/cook.c'\" unpacked with wrong size!
fi
# end of 'cook/cook.c'
fi
echo shar: End of archive 17 \(of 19\).
cp /dev/null ark17isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 19 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
