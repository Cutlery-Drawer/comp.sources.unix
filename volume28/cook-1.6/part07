Newsgroups: comp.sources.unix
From: pmiller@bmr.gov.au (Peter Miller)
Subject: v28i100: cook - a file construction tool, V1.6, Part07/19
References: <1.775008949.28543@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: pmiller@bmr.gov.au (Peter Miller)
Posting-Number: Volume 28, Issue 100
Archive-Name: cook-1.6/part07

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 19)."
# Contents:  c_incl/lang_c.c c_incl/lang_roff.c common/fp/combined.c
#   common/trace.h config cook/builtin/find_command.c
#   cook/builtin/opsys.c cook/builtin/pathname.c
#   cook/builtin/stringset.c cook/fngrprnt_lex.c cookfp/main.c
#   cooktime/main.c doc/glossary.so doc/intro1.so find_libs/main.c
#   make2cook/blob.c make2cook/stmt/compound.c make2cook/vargram.y
#   man1/c_incl.1 man1/cookfp.1 man1/roffpp.1 test/00/t0066a.sh
#   txt2c/txt2c.c
# Wrapped by vixie@gw.home.vix.com on Sat Jul 23 17:11:23 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'c_incl/lang_c.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'c_incl/lang_c.c'\"
else
echo shar: Extracting \"'c_incl/lang_c.c'\" \(4381 characters\)
sed "s/^X//" >'c_incl/lang_c.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to scan C language files
X */
X
X#include <ctype.h>
X#include <ac/string.h>
X
X#include <error.h>
X#include <mem.h>
X#include <sniff.h>
X#include <trace.h>
X#include <word.h>
X
X
X/*
X * NAME
X *	directive
X *
X * SYNOPSIS
X *	void directive(char *line, wlist *type1, wlist *type2);
X *
X * DESCRIPTION
X *	The directive function is used to scan a # control line for an
X *	include directive.  If one is found, the filename
X *	is resolved, and the path appended to the appropriate list.
X *
X * ARGUMENTS
X *	line	- the line of text from the program
X *	type1	- list of <filenames>
X *	type2	- list of "filenames"
X *
X * CAVEATS
X *	Just ignore anything we don't understand.
X */
X
Xstatic void directive _((char *s, wlist *type1, wlist *type2));
X
Xstatic void
Xdirective(s, type1, type2)
X	char		*s;
X	wlist		*type1;
X	wlist		*type2;
X{
X	int		right;
X	char		*filename;
X	string_ty	*path;
X
X	/*
X	 * see if it is a #include directive
X	 */
X	trace(("directive(s = \"%s\", type1 = %08lX, type2 = %08lX)\n{\n"/*}*/,
X		s, type1, type2));
X	assert(*s == '#');
X	s++;
X	while (isspace(*s))
X		++s;
X	if (memcmp(s, "include", 7))
X		goto done;
X	s += 7;
X	while (isspace(*s))
X		++s;
X
X	/*
X	 * figure which type
X	 */
X	switch (*s++)
X	{
X	default:
X		goto done;
X
X	case '"':
X		right = '"';
X		break;
X
X	case '<':
X		right = '>';
X		break;
X	}
X
X	/*
X	 * find the end of the filename
X	 *	(ignore anything on the end of the line)
X	 */
X	filename = s;
X	while (*s != right)
X	{
X		if (!*s)
X			goto done;
X		++s;
X	}
X
X	/*
X	 * extract the path
X	 */
X	if (s == filename)
X		goto done;
X	path = str_n_from_c(filename, s - filename);
X
X	/*
X	 * dispatch the path to the appropriate list
X	 */
X	if (right != '"')
X	{
X		trace(("type1 %s\n", path->str_text));
X		wl_append_unique(type1, path);
X	}
X	else
X	{
X		trace(("type2 %s\n", path->str_text));
X		wl_append_unique(type2, path);
X	}
X	str_free(path);
X
X	/*
X	 * here for all exits
X	 */
X	done:
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	lang_c_scan
X *
X * SYNOPSIS
X *	int lang_c_scan(FILE *fp, wlist *type1, wlist *type2);
X *
X * DESCRIPTION
X *	The lang_c_scan function is used to scan a file looking
X *	for nclude files.  It does not walk the children.
X *	The names of any include files encountered are appended
X *	to the appropriate list.
X *
X * ARGUMENTS
X *	fp	- file stream to scan
X *	type1	- list of <filenames>
X *	type2	- list of "filenames"
X *	
X * RETURNS
X *	int;	0 on success
X *		-1 on file errors
X */
X
Xstatic int lang_c_scan _((FILE *, wlist *, wlist *));
X
Xstatic int
Xlang_c_scan(fp, type1, type2)
X	FILE		*fp;
X	wlist		*type1;
X	wlist		*type2;
X{
X	size_t		pos;
X	size_t		max;
X	char		*line;
X	int		result;
X	int		c;
X	char		*cp;
X
X	trace(("lang_c_scan(fp = %08lX, type1 = %08lX, \
Xtype2 = %08lX)\n{\n"/*}*/, fp, type1, type2));
X	pos = 0;
X	max = 100;
X	line = mem_alloc(max);
X	result = 0;
X	for (;;)
X	{
X		if (pos >= max)
X		{
X			max += 80;
X			line = mem_change_size(line, max);
X		}
X		c = getc(fp);
X		switch (c)
X		{
X		case EOF:
X			if (ferror(fp))
X			{
X				result = -1;
X				break;
X			}
X			if (!pos)
X				break;
X			/* fall through... */
X
X		case '\n':
X			line[pos] = 0;
X			pos = 0;
X
X			/*
X			 * see if it is a hash line
X			 */
X			for (cp = line; isspace(*cp); ++cp)
X				;
X			if (*cp == '#')
X				directive(cp, type1, type2);
X			continue;
X
X		default:
X			line[pos++] = c;
X			continue;
X		}
X		break;
X	}
X	mem_free(line);
X	trace(("return %d;\n", result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
Xstatic void lang_c_prepare _((void));
X
Xstatic void
Xlang_c_prepare()
X{
X	trace(("lang_c_prepare()\n{\n"/*}*/));
X	sniff_include("/usr/include");
X	trace((/*{*/"}\n"));
X}
X
X
Xsniff_ty lang_c =
X{
X	lang_c_scan,
X	lang_c_prepare,
X};
END_OF_FILE
if test 4381 -ne `wc -c <'c_incl/lang_c.c'`; then
    echo shar: \"'c_incl/lang_c.c'\" unpacked with wrong size!
fi
# end of 'c_incl/lang_c.c'
fi
if test -f 'c_incl/lang_roff.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'c_incl/lang_roff.c'\"
else
echo shar: Extracting \"'c_incl/lang_roff.c'\" \(4028 characters\)
sed "s/^X//" >'c_incl/lang_roff.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to scan *roff source files
X */
X
X#include <ctype.h>
X#include <ac/string.h>
X
X#include <error.h>
X#include <mem.h>
X#include <sniff.h>
X#include <trace.h>
X#include <word.h>
X
X
X/*
X * NAME
X *	directive
X *
X * SYNOPSIS
X *	void directive(char *line, wlist *type1, wlist *type2);
X *
X * DESCRIPTION
X *	The directive function is used to scan a . line for an
X *	include directive.  If one is found, the filename
X *	is resolved, and the path appended to the appropriate list.
X *
X * ARGUMENTS
X *	line	- the line of text from the program
X *	type1	- list of <filenames>
X *	type2	- list of "filenames"
X *
X * CAVEATS
X *	Just ignore anything we don't understand.
X */
X
Xstatic void directive _((char *s, wlist *type1, wlist *type2));
X
Xstatic void
Xdirective(s, type1, type2)
X	char		*s;
X	wlist		*type1;
X	wlist		*type2;
X{
X	char		*filename;
X	string_ty	*path;
X
X	/*
X	 * see if it is a .so directive
X	 */
X	trace(("directive(s = \"%s\", type1 = %08lX, type2 = %08lX)\n{\n"/*}*/,
X		s, type1, type2));
X	assert(*s == '.');
X	s++;
X	while (isspace(*s))
X		++s;
X	if (memcmp(s, "so", 2))
X		goto done;
X	s += 2;
X	while (isspace(*s))
X		++s;
X	if (!*s)
X		goto done;
X
X	/*
X	 * find the end of the filename
X	 *	(ignore anything on the end of the line)
X	 */
X	filename = s;
X	while (*s && !isspace(*s))
X		++s;
X
X	/*
X	 * extract the path
X	 */
X	path = str_n_from_c(filename, s - filename);
X
X	/*
X	 * dispatch the path to the appropriate list
X	 */
X	wl_append_unique(type1, path);
X	str_free(path);
X
X	/*
X	 * here for all exits
X	 */
X	done:
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	lang_roff_scan
X *
X * SYNOPSIS
X *	int lang_roff_scan(FILE *fp, wlist *type1, wlist *type2);
X *
X * DESCRIPTION
X *	The lang_roff_scan function is used to scan a file looking
X *	for nclude files.  It does not walk the children.
X *	The names of any include files encountered are appended
X *	to the appropriate list.
X *
X * ARGUMENTS
X *	fp	- file stream to scan
X *	type1	- list of <filenames>
X *	type2	- list of "filenames"
X *	
X * RETURNS
X *	int;	0 on success
X *		-1 on file errors
X */
X
Xstatic int lang_roff_scan _((FILE *, wlist *, wlist *));
X
Xstatic int
Xlang_roff_scan(fp, type1, type2)
X	FILE		*fp;
X	wlist		*type1;
X	wlist		*type2;
X{
X	size_t		pos;
X	size_t		max;
X	char		*line;
X	int		result;
X	int		c;
X
X	trace(("lang_roff_scan(fp = %08lX, type1 = %08lX, \
Xtype2 = %08lX)\n{\n"/*}*/, fp, type1, type2));
X	pos = 0;
X	max = 100;
X	line = mem_alloc(max);
X	result = 0;
X	for (;;)
X	{
X		if (pos >= max)
X		{
X			max += 80;
X			line = mem_change_size(line, max);
X		}
X		c = getc(fp);
X		switch (c)
X		{
X		case EOF:
X			if (ferror(fp))
X			{
X				result = -1;
X				break;
X			}
X			if (!pos)
X				break;
X			/* fall through... */
X
X		case '\n':
X			line[pos] = 0;
X			pos = 0;
X
X			/*
X			 * see if it is a control line
X			 */
X			if (line[0] == '.')
X				directive(line, type1, type2);
X			continue;
X
X		default:
X			line[pos++] = c;
X			continue;
X		}
X		break;
X	}
X	mem_free(line);
X	trace(("return %d;\n", result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
Xstatic void lang_roff_prepare _((void));
X
Xstatic void
Xlang_roff_prepare()
X{
X	trace(("lang_roff_prepare()\n{\n"/*}*/));
X	if (sniff_include_count() == 0)
X		sniff_include(".");
X	trace((/*{*/"}\n"));
X}
X
X
Xsniff_ty lang_roff =
X{
X	lang_roff_scan,
X	lang_roff_prepare,
X};
END_OF_FILE
if test 4028 -ne `wc -c <'c_incl/lang_roff.c'`; then
    echo shar: \"'c_incl/lang_roff.c'\" unpacked with wrong size!
fi
# end of 'c_incl/lang_roff.c'
fi
if test -f 'common/fp/combined.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/fp/combined.c'\"
else
echo shar: Extracting \"'common/fp/combined.c'\" \(3732 characters\)
sed "s/^X//" >'common/fp/combined.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate combined fingerprints
X *
X * Derived from code marked:
X *	Daniel J. Bernstein, brnstnd@nyu.edu.
X *	930708: fprintfile 0.95. Public domain.
X *	930708: Added fingerprintfile_addn.
X *	930622: Split off fprintfmt.c.
X *	930601: Baseline, fprintfile 0.8. Public domain.
X *	No known patent problems.
X */
X
X#include <error.h>
X#include <fp/combined.h>
X#include <fp/crc32.h>
X#include <fp/len.h>
X#include <fp/md5.h>
X#include <fp/snefru.h>
X
Xtypedef struct combined_ty combined_ty;
Xstruct combined_ty
X{
X	FINGERPRINT_BASE_CLASS
X	fingerprint_ty	*snefru;
X	fingerprint_ty	*md5;
X	fingerprint_ty	*crc32;
X	fingerprint_ty	*len;
X};
X
X
Xstatic void combined_constructor _((fingerprint_ty *));
X
Xstatic void
Xcombined_constructor(p)
X	fingerprint_ty	*p;
X{
X	combined_ty	*f;
X
X	f = (combined_ty *)p;
X	f->snefru = fingerprint_new(&fp_snefru);
X	f->md5 = fingerprint_new(&fp_md5);
X	f->crc32 = fingerprint_new(&fp_crc32);
X	f->len = fingerprint_new(&fp_len);
X}
X
X
Xstatic void combined_destructor _((fingerprint_ty *));
X
Xstatic void
Xcombined_destructor(p)
X	fingerprint_ty	*p;
X{
X	combined_ty	*f;
X
X	f = (combined_ty *)p;
X	fingerprint_delete(f->snefru);
X	fingerprint_delete(f->md5);
X	fingerprint_delete(f->crc32);
X	fingerprint_delete(f->len);
X}
X
X
Xstatic void combined_addn _((fingerprint_ty *, unsigned char *, int));
X
Xstatic void
Xcombined_addn(p, s, n)
X	fingerprint_ty	*p;
X	unsigned char	*s;
X	int		n;
X{
X	combined_ty	*f;
X
X	f = (combined_ty *)p;
X	fingerprint_addn(f->snefru, s, n);
X	fingerprint_addn(f->md5, s, n);
X	fingerprint_addn(f->crc32, s, n);
X	fingerprint_addn(f->len, s, n);
X}
X
X
Xstatic int combined_hash _((fingerprint_ty *, unsigned char *));
X
Xstatic int
Xcombined_hash(p, h)
X	fingerprint_ty	*p;
X	unsigned char	*h;
X{
X	combined_ty	*f;
X	int		nbytes;
X	unsigned char	*obuf;
X
X	f = (combined_ty *)p;
X	obuf = h;
X	nbytes = fingerprint_hash(f->snefru, h);
X	h += nbytes;
X	nbytes = fingerprint_hash(f->md5, h);
X	h += nbytes;
X	nbytes = fingerprint_hash(f->crc32, h);
X	h += nbytes;
X	nbytes = fingerprint_hash(f->len, h);
X	h += nbytes;
X	return (h - obuf);
X}
X
X
Xstatic char base64sane[] =
X	"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ:.";
X
X
Xstatic void combined_sum _((fingerprint_ty *, char *));
X
Xstatic void
Xcombined_sum(p, s)
X	fingerprint_ty	*p;
X	char		*s;
X{
X	unsigned char	h[1024];
X	int		i;
X	unsigned long	x;
X	int		nbytes;
X
X	nbytes = combined_hash(p, h);
X	assert(nbytes == 57);
X
X	for (i = 0; i < 19; ++i)
X	{
X		x =
X			(
X				h[3 * i]
X			+
X					256L
X				*
X					(
X						h[3 * i + 1]
X					+
X						256L * h[3 * i + 2]
X					)
X			);
X		s[(12 * i) % 76] = base64sane[x & 63];
X		x /= 64;
X		s[(12 * i + 41) % 76] = base64sane[x & 63];
X		x /= 64;
X		s[(12 * i + 6) % 76] = base64sane[x & 63];
X		x /= 64;
X		s[(12 * i + 47) % 76] = base64sane[x & 63];
X	}
X	s[76] = 0;
X}
X
X
Xfingerprint_methods_ty fp_combined =
X{
X	sizeof(combined_ty),
X	"fingerprint",
X	combined_constructor,
X	combined_destructor,
X	combined_addn,
X	combined_hash,
X	combined_sum
X};
END_OF_FILE
if test 3732 -ne `wc -c <'common/fp/combined.c'`; then
    echo shar: \"'common/fp/combined.c'\" unpacked with wrong size!
fi
# end of 'common/fp/combined.c'
fi
if test -f 'common/trace.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/trace.h'\"
else
echo shar: Extracting \"'common/trace.h'\" \(4854 characters\)
sed "s/^X//" >'common/trace.h' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: interface definition for common/trace.c
X */
X
X#ifndef TRACE_H
X#define TRACE_H
X
X#include <ac/stddef.h>
X
X#include <main.h>
X
X#ifdef DEBUG
X#define trace_pretest_ \
X	(							\
X		(						\
X			trace_pretest_result			\
X		?						\
X			trace_pretest_result			\
X		:						\
X			trace_pretest(__FILE__, &trace_pretest_result) \
X		)						\
X	&							\
X		1						\
X	)
X#define trace_where_ trace_where(__FILE__, __LINE__)
X#define trace(x) (void)(trace_pretest_ && (trace_where_, trace_printf x, 0))
X#define trace_if() (trace_pretest_ && (trace_where_, 1))
X#else
X#define trace(x)
X#define trace_if() 0
X#endif
X
X/*
X * This variable is static to each file which
X * includes the "trace.h" file.
X * Tracing is file-by-file, but need only test this once.
X * Files will fail to trace if a trace call is executed in them
X * prior to a call to trace_enable turning it on.
X */
X#ifdef DEBUG
Xstatic int trace_pretest_result;
X#endif
X
Xint trace_pretest _((char *file, int *result));
Xvoid trace_where _((char *file, int line));
Xvoid trace_printf _((char *, ...));
Xvoid trace_enable _((char *));
X
X
X#if defined(__STDC__) || defined(__stdc__)
X#define trace_stringize(x) #x
X#else
X#define trace_stringize(x) "x"
X#endif
X
Xvoid trace_string_real _((char *, char *));
Xvoid trace_short_unsigned_real _((char *, unsigned short *));
Xvoid trace_short_real _((char *, short *));
Xvoid trace_pointer_real _((char *, void *));
Xvoid trace_long_unsigned_real _((char *, unsigned long *));
Xvoid trace_long_real _((char *, long *));
Xvoid trace_int_unsigned_real _((char *, unsigned *));
Xvoid trace_int_real _((char *, int *));
Xvoid trace_char_unsigned_real _((char *, unsigned char *));
Xvoid trace_char_real _((char *, char *));
X
X#ifdef DEBUG
X
X#define trace_char(x)						\
X	(void)							\
X	(							\
X		trace_pretest_					\
X	&&							\
X		(						\
X			trace_where_,				\
X			trace_char_real(trace_stringize(x), &x), \
X			0					\
X		)						\
X	)
X
X#define trace_char_unsigned(x)					\
X	(void)							\
X	(							\
X		trace_pretest_					\
X	&&							\
X		(						\
X			trace_where_,				\
X			trace_char_unsigned_real(trace_stringize(x), &x), \
X			0					\
X		)						\
X	)
X
X#define trace_int(x)						\
X	(void)							\
X	(							\
X		trace_pretest_					\
X	&&							\
X		(						\
X			trace_where_,				\
X			trace_int_real(trace_stringize(x), &x),	\
X			0					\
X		)						\
X	)
X
X#define trace_int_unsigned(x)					\
X	(void)							\
X	(							\
X		trace_pretest_					\
X	&&							\
X		(						\
X			trace_where_,				\
X			trace_int_unsigned_real(trace_stringize(x), &x), \
X			0					\
X		)						\
X	)
X
X#define trace_long(x)						\
X	(void)							\
X	(							\
X		trace_pretest_					\
X	&&							\
X		(						\
X			trace_where_,				\
X			trace_long_real(trace_stringize(x), &x), \
X			0					\
X		)						\
X	)
X
X#define trace_long_unsigned(x)					\
X	(void)							\
X	(							\
X		trace_pretest_					\
X	&&							\
X		(						\
X			trace_where_,				\
X			trace_long_unsigned_real(trace_stringize(x), &x), \
X			0					\
X		)						\
X	)
X
X#define trace_pointer(x)					\
X	(void)							\
X	(							\
X		trace_pretest_					\
X	&&							\
X		(						\
X			trace_where_,				\
X			trace_pointer_real(trace_stringize(x), &x), \
X			0					\
X		)						\
X	)
X
X#define trace_short(x)						\
X	(void)							\
X	(							\
X		trace_pretest_					\
X	&&							\
X		(						\
X			trace_where_,				\
X			trace_short_real(trace_stringize(x), &x), \
X			0					\
X		)						\
X	)
X
X#define trace_short_unsigned(x)					\
X	(void)							\
X	(							\
X		trace_pretest_					\
X	&&							\
X		(						\
X			trace_where_,				\
X			trace_short_unsigned_real(trace_stringize(x), &x), \
X			0					\
X		)						\
X	)
X
X#define trace_string(x)						\
X	(void)							\
X	(							\
X		trace_pretest_					\
X	&&							\
X		(						\
X			trace_where_,				\
X			trace_string_real(trace_stringize(x), x), \
X			0					\
X		)						\
X	)
X
X#else
X
X#define trace_char(x)
X#define trace_char_unsigned(x)
X#define trace_int(x)
X#define trace_int_unsigned(x)
X#define trace_long(x)
X#define trace_long_unsigned(x)
X#define trace_pointer(x)
X#define trace_short(x)
X#define trace_short_unsigned(x)
X#define trace_string(x)
X
X#endif
X
X#endif /* TRACE_H */
END_OF_FILE
if test 4854 -ne `wc -c <'common/trace.h'`; then
    echo shar: \"'common/trace.h'\" unpacked with wrong size!
fi
# end of 'common/trace.h'
fi
if test -f 'config' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config'\"
else
echo shar: Extracting \"'config'\" \(3896 characters\)
sed "s/^X//" >'config' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: instructions to aegis, per-project configuration
X */
X
X/*
X * how to build the project
X *	(actually, how to do an integration build)
X * mandatory
X */
Xbuild_command =
X	"cook -b ${source aux/Howto.cook} project=$project \
Xchange=$change version=$version arch=$arch -nl -st";
X
X/*
X * When do -Integrate_Begin, link the baseline to the integration directory,
X * rather than copying it.. This should be much faster.
X *
X * There is a gotcha: all the recipes in Howto.cook must unlink their targets
X * before re-creating them, otherwise the baseline will be trashed.
X */
Xlink_integration_directory = true;
X
X/*
X * create a new history
X * always executed as the project owner
X */
Xhistory_create_command =
X	"fhist ${b $history} -create -i $input -p ${d $history} -r";
X
X/*
X * get a file from history
X * may be executed by developers
X */
Xhistory_get_command =
X	"fhist ${b $history} -e '$edit' -o $output -p ${d $history}";
X
X/*
X * add a new change to the history
X * always executed as the project owner
X */
Xhistory_put_command =
X	"fhist ${b $history} -cu -i $input -p ${d $history} -r";
X
X/*
X * query the topmost edit of a history file
X * Result to be printed on stdout.
X * may be executed by developers
X */
Xhistory_query_command =
X	"fhist ${b $history} -l 0 -p ${d $history} -q";
X
X/*
X * difference of 2 files
X */
Xdiff_command =
X	"fcomp -w -s $original $input -o $output";
X
X/*
X * difference of 3 files
X */
Xdiff3_command =
X	"fmerge $original $mostRecent $input -o $output -c $input,C";
X
X/*
X * whenever files are added to or removed from the change,
X * execute the following command.
X */
Xchange_file_command = "rm -f .c_inclrc";
X
X/*
X * new file templates
X */
Xfile_template =
X[
X	{
X		pattern = [ "*.[cyl]" ];
X		body = "${read_file ${source aux/template/c abs}}";
X	},
X	{
X		pattern = [ "*.h" ];
X		body = "${read_file ${source aux/template/h abs}}";
X	},
X	{
X		pattern = [ "test/*/*.sh" ];
X		body = "${read_file ${source aux/template/test abs}}";
X	},
X	{
X		pattern = [ "*.sh" ];
X		body = "${read_file ${source aux/template/sh abs}}";
X	},
X	{
X		pattern = [ "*.man", "*.[12345678]" ];
X		body = "${read_file ${source aux/template/man abs}}";
X	},
X	{
X		pattern = [ "*.so", "*.ms", "*.me" ];
X		body = "${read_file ${source aux/template/ms abs}}";
X	},
X	{
X		pattern = [ "*" ];
X		body = "${read_file ${source aux/template/generic abs}}";
X	}
X];
X
X/*
X * Create a symbolic link to the baseline.
X * Note that Howto.cook now assumes its existence.
X */
Xdevelop_begin_command = "ln -s $baseline bl";
X
X/*
X * Remove these files before we start integrating, to ensure that they
X * will be rebuild containing the correct version information.
X */
Xintegrate_begin_command =
X	"rm -f .cook.fp common/patchlevel.h aux/new.so doc/version.so";
Xsymlink_exceptions = [ ".cook.fp", "common/patchlevel.h" ];
X
X/*
X * list of architectures on which each change must build and test
X */
Xarchitecture =
X[
X	{
X		name = "sun4";
X		pattern = "SunOS-4.1*-*-sun4*";
X	},
X	{
X		name = "sun5";
X		pattern = "SunOS-5.*-*-sun4*";
X	}
X];
X
X
X/*
X * how to run tests
X *	they need to know which arctitecture
X */
Xtest_command = "$shell $filename $arch";
END_OF_FILE
if test 3896 -ne `wc -c <'config'`; then
    echo shar: \"'config'\" unpacked with wrong size!
fi
# end of 'config'
fi
if test -f 'cook/builtin/find_command.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/builtin/find_command.c'\"
else
echo shar: Extracting \"'cook/builtin/find_command.c'\" \(3628 characters\)
sed "s/^X//" >'cook/builtin/find_command.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to implement the builtin functions
X *
X * The builtin function all append their results to the supplied
X * `result' word list.  The first word of the `args' word list
X * is the name of the function.
X *
X * all of the functions return 0 in success, or -1 on error.
X *
X * Only a limited set of this are candidates for builtin functions,
X * these are 
X *	- string manipulation [dirname, stringset, ect ]
X *	- environment manipulation [getenv(3), etc]
X *	- stat(3) related functions [exists, mtime, pathname, etc]
X *	- launching OS commands [execute, collect]
X * The above list is though to be exhaustive.
X *
X * This explicitly and forever excluded from being a builtin function
X * is anything which known or understands the format of some secific 
X * class of files.
X *
X * Access to stdio(3) has been thought of, and explicitly avoided.
X * Mostly because a specialist program used through [collect]
X * will almost always be far faster.
X */
X
X#include <ac/stdlib.h>
X#include <ac/string.h>
X
X#include <builtin/find_command.h>
X#include <error.h>
X#include <expr.h>
X#include <os.h>
X
X
X/*
X * NAME
X *	builtin_find_command - find pathname commands
X *
X * SYNOPSIS
X *	int builtin_find_command(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	Find_command is a built-in function of cook, described as follows:
X *	This function requires one or more arguments.
X *
X * RETURNS
X *	A word list containing the expanded pathname of the named commands
X *	given as arguments.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_find_command(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X	string_ty	*paths;
X	char		*cp;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	cp = getenv("PATH");
X	if (!cp || !*cp)
X	{
X		expr_error
X		(
X			"%s: PATH environment variable not set",
X			args->wl_word[0]->str_text
X		);
X		return -1;
X	}
X	paths = str_from_c(cp);
X	for (j = 1; j < args->wl_nwords; ++j)
X	{
X		string_ty	*s;
X		string_ty	*s2;
X
X		s = args->wl_word[j];
X		if (strchr(s->str_text, '/'))
X		{
X			if (os_exists(s))
X			{
X				s2 = os_pathname(s);
X				wl_append(result, s2);
X				str_free(s2);
X			}
X			else
X				wl_append(result, str_false);
X		}
X		else
X		{
X			string_ty	*f;
X			int		n;
X
X			for (n = 0; ; ++n)
X			{
X				f = str_field(paths, ':', n);
X				if (!f)
X				{
X					wl_append(result, str_false);
X					break;
X				}
X				s2 = str_format("%S/%S", f, s);
X				str_free(f);
X				switch (os_exists(s2))
X				{
X				case -1:
X					str_free(s2);
X					return -1;
X
X				case 0:
X					str_free(s2);
X					continue;
X
X				case 1:
X					f = os_pathname(s2);
X					str_free(s2);
X					wl_append(result, f);
X					str_free(f);
X					break;
X				}
X				break;
X			}
X		}
X	}
X	str_free(paths);
X	return 0;
X}
END_OF_FILE
if test 3628 -ne `wc -c <'cook/builtin/find_command.c'`; then
    echo shar: \"'cook/builtin/find_command.c'\" unpacked with wrong size!
fi
# end of 'cook/builtin/find_command.c'
fi
if test -f 'cook/builtin/opsys.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/builtin/opsys.c'\"
else
echo shar: Extracting \"'cook/builtin/opsys.c'\" \(3493 characters\)
sed "s/^X//" >'cook/builtin/opsys.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to implement the builtin os function
X *
X * The builtin functions all append their results to the supplied
X * `result' word list.  The first word of the `args' word list
X * is the name of the function.
X *
X * all of the functions return 0 in success, or -1 on error.
X */
X
X#include <sys/utsname.h>
X
X#include <builtin/opsys.h>
X#include <error.h>
X#include <expr.h>
X
X
X/*
X * NAME
X *	builtin_opsys - describe operating system
X *
X * SYNOPSIS
X *	int builtin_opsys(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	Operating_system is a built-in function of cook, described as follows:
X *	This function must have zero or more arguments.
X *
X * RETURNS
X *	The resulting wordlist contains the values of various
X *	attributes of the operating system, as named in the arguments.
X *	If no attributes are named "name" is assumed.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_opsys(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X	static string_ty *name;
X	static string_ty *machine;
X	static struct utsname uts;
X	static char	uts_defined;
X	static string_ty *system;
X	static string_ty *node;
X	static string_ty *release;
X	static string_ty *version;
X
X	if (!uts_defined)
X	{
X		uname(&uts);
X		uts_defined = 1;
X	}
X	if (!name)
X		name = str_from_c("name");
X	if (!system)
X		system = str_from_c("system");
X	if (!node)
X		node = str_from_c("node");
X	if (!release)
X		release = str_from_c("release");
X	if (!version)
X		version = str_from_c("version");
X	if (!machine)
X		machine = str_from_c("machine");
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	if (args->wl_nwords < 2)
X		wl_append(args, name);
X	for (j = 1; j < args->wl_nwords; j++)
X	{
X		string_ty	*x;
X
X		x = args->wl_word[j];
X		if (str_equal(name, x) || str_equal(system, x))
X		{
X			static string_ty *s;
X			if (!s)
X				s = str_from_c(uts.sysname);
X			wl_append(result, s);
X		}
X		else if (str_equal(node, x))
X		{
X			static string_ty *s;
X			if (!s)
X				s = str_from_c(uts.nodename);
X			wl_append(result, s);
X		}
X		else if (str_equal(release, x))
X		{
X			static string_ty *s;
X			if (!s)
X				s = str_from_c(uts.release);
X			wl_append(result, s);
X		}
X		else if (str_equal(version, x))
X		{
X			static string_ty *s;
X			if (!s)
X				s = str_from_c(uts.version);
X			wl_append(result, s);
X		}
X		else if (str_equal(machine, x))
X		{
X			static string_ty *s;
X			if (!s)
X				s = str_from_c(uts.machine);
X			wl_append(result, s);
X		}
X		else
X		{
X			expr_error
X			(
X				"%s: unknown \"%s\" attribute",
X				args->wl_word[0]->str_text,
X				x->str_text
X			);
X			return -1;
X		}
X	}
X	return 0;
X}
END_OF_FILE
if test 3493 -ne `wc -c <'cook/builtin/opsys.c'`; then
    echo shar: \"'cook/builtin/opsys.c'\" unpacked with wrong size!
fi
# end of 'cook/builtin/opsys.c'
fi
if test -f 'cook/builtin/pathname.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/builtin/pathname.c'\"
else
echo shar: Extracting \"'cook/builtin/pathname.c'\" \(4254 characters\)
sed "s/^X//" >'cook/builtin/pathname.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to implement the builtin pathname functions
X *
X * The builtin function all append their results to the supplied
X * `result' word list.  The first word of the `args' word list
X * is the name of the function.
X *
X * all of the functions return 0 in success, or -1 on error.
X */
X
X#include <builtin/pathname.h>
X#include <error.h>
X#include <expr.h>
X#include <os.h>
X
X
X/*
X * NAME
X *	builtin_dir - dir part
X *
X * SYNOPSIS
X *	int builtin_dir(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	"dir" is a built-in function of cook, described as follows:
X *	This function requires one or more arguments,
X *	the name of a files of which to get the dir parts.
X *
X * RETURNS
X *	It returns a string containing the directory parts
X *	of the named files.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_dir(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	if (args->wl_nwords < 2)
X	{
X		expr_error
X		(
X			"%s: requires one or more arguments",
X			args->wl_word[0]->str_text
X		);
X		return -1;
X	}
X	for (j = 1; j < args->wl_nwords; j++)
X	{
X		string_ty	*s;
X
X		s = os_dirname(args->wl_word[j]);
X		if (!s)
X			return -1;
X		wl_append(result, s);
X		str_free(s);
X	}
X	return 0;
X}
X
X
X/*
X * NAME
X *	builtin_entryname - entryname part
X *
X * SYNOPSIS
X *	int builtin_entryname(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	Defined is a built-in function of cook, described as follows:
X *	This function requires one or more arguments,
X *	the name of a files of which to get the entryname parts.
X *
X * RETURNS
X *	It returns a string containing the entryname parts
X *	of the named files.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_entryname(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	if (args->wl_nwords < 2)
X	{
X		expr_error
X		(
X			"%s: requires one or more arguments",
X			args->wl_word[0]->str_text
X		);
X		return -1;
X	}
X	for (j = 1; j < args->wl_nwords; j++)
X	{
X		string_ty	*s;
X
X		s = os_entryname(args->wl_word[j]);
X		if (!s)
X			return -1;
X		wl_append(result, s);
X		str_free(s);
X	}
X	return 0;
X}
X
X
X/*
X * NAME
X *	builtin_pathname - pathname part
X *
X * SYNOPSIS
X *	int builtin_pathname(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	Defined is a built-in function of cook, described as follows:
X *	This function requires one or more arguments,
X *	the name of a files of which to get the pathname parts.
X *
X * RETURNS
X *	It returns a string containing the pathname parts
X *	of the named files.
X *
X * CAVEAT
X *	The returned result is in dynamic memory.
X *	It is the responsibility of the caller to dispose of
X *	the result when it is finished, with a wl_free() call.
X */
X
Xint
Xbuiltin_pathname(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X
X	assert(result);
X	assert(args);
X	assert(args->wl_nwords);
X	if (args->wl_nwords < 2)
X	{
X		expr_error
X		(
X			"%s: requires one or more arguments",
X			args->wl_word[0]->str_text
X		);
X		return -1;
X	}
X	for (j = 1; j < args->wl_nwords; j++)
X	{
X		string_ty	*s;
X
X		s = os_pathname(args->wl_word[j]);
X		if (!s)
X			return -1;
X		wl_append(result, s);
X		str_free(s);
X	}
X	return 0;
X}
END_OF_FILE
if test 4254 -ne `wc -c <'cook/builtin/pathname.c'`; then
    echo shar: \"'cook/builtin/pathname.c'\" unpacked with wrong size!
fi
# end of 'cook/builtin/pathname.c'
fi
if test -f 'cook/builtin/stringset.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/builtin/stringset.c'\"
else
echo shar: Extracting \"'cook/builtin/stringset.c'\" \(3488 characters\)
sed "s/^X//" >'cook/builtin/stringset.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to implement the builtin stringset function
X *
X * The builtin functions all append their results to the supplied
X * `result' word list.  The first word of the `args' word list
X * is the name of the function.
X *
X * all of the functions return 0 in success, or -1 on error.
X */
X
X#include <builtin/stringset.h>
X
X
X#define STRINGSET_EOLN  1
X#define STRINGSET_WORD  2
X#define STRINGSET_MINUS 3
X#define STRINGSET_STAR  4
X
Xstatic wlist    stringset_args;
Xstatic size_t   stringset_pos;
Xstatic int      stringset_token;
Xstatic string_ty *stringset_token_value;
X
X
Xstatic void stringset_lex _((void));
X
Xstatic void
Xstringset_lex()
X{
X	static string_ty *minus;
X	static string_ty *star;
X
X	if (!minus)
X		minus = str_from_c("-");
X	if (!star)
X		star = str_from_c("*");
X	if (stringset_pos >= stringset_args.wl_nwords)
X	{
X		stringset_token_value = str_false;
X		stringset_token = STRINGSET_EOLN;
X		return;
X	}
X	stringset_token_value = stringset_args.wl_word[stringset_pos++];
X	if (str_equal(minus, stringset_token_value))
X	{
X		stringset_token = STRINGSET_MINUS;
X		return;
X	}
X	if (str_equal(star, stringset_token_value))
X	{
X		stringset_token = STRINGSET_STAR;
X		return;
X	}
X	stringset_token = STRINGSET_WORD;
X}
X
X
Xstatic int stringset_three _((wlist *));
X
Xstatic int
Xstringset_three(result)
X	wlist		*result;
X{
X	while (stringset_token == STRINGSET_WORD)
X	{
X		wl_append_unique(result, stringset_token_value);
X		stringset_lex();
X	}
X	return 0;
X}
X
X
Xstatic int stringset_two _((wlist *));
X
Xstatic int
Xstringset_two(result)
X	wlist		*result;
X{
X	if (stringset_three(result))
X		return -1;
X	while (stringset_token == STRINGSET_STAR)
X	{
X		wlist		lhs;
X		wlist		rhs;
X		int		j;
X		string_ty	*s;
X
X		stringset_lex();
X		wl_zero(&rhs);
X		if (stringset_three(&rhs))
X			return -1;
X		lhs = *result;
X		wl_zero(result);
X		for (j = 0; j < rhs.wl_nwords; ++j)
X		{
X			s = rhs.wl_word[j];
X			if (wl_member(&lhs, s))
X				wl_append_unique(result, s);
X		}
X		wl_free(&lhs);
X		wl_free(&rhs);
X	}
X	return 0;
X}
X
X
Xstatic int stringset_one _((wlist *));
X
Xstatic int
Xstringset_one(result)
X	wlist		*result;
X{
X	if (stringset_two(result))
X		return -1;
X	while (stringset_token == STRINGSET_MINUS)
X	{
X		wlist		wl;
X		int		j;
X
X		wl_zero(&wl);
X		stringset_lex();
X		if (stringset_two(&wl))
X			return -1;
X		for (j = 0; j < wl.wl_nwords; ++j)
X			wl_delete(result, wl.wl_word[j]);
X		wl_free(&wl);
X	}
X	return 0;
X}
X
X
Xint
Xbuiltin_stringset(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	wlist		wl;
X	int		j;
X
X	stringset_args = *args;
X	stringset_pos = 1;
X	stringset_lex();
X
X	wl_zero(&wl);
X	if (stringset_one(&wl))
X		return -1;
X	for (j = 0; j < wl.wl_nwords; ++j)
X		wl_append(result, wl.wl_word[j]);
X	wl_free(&wl);
X	return 0;
X}
END_OF_FILE
if test 3488 -ne `wc -c <'cook/builtin/stringset.c'`; then
    echo shar: \"'cook/builtin/stringset.c'\" unpacked with wrong size!
fi
# end of 'cook/builtin/stringset.c'
fi
if test -f 'cook/fngrprnt_lex.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/fngrprnt_lex.c'\"
else
echo shar: Extracting \"'cook/fngrprnt_lex.c'\" \(3572 characters\)
sed "s/^X//" >'cook/fngrprnt_lex.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to do lexical analysis on the fingerprint cache file
X */
X
X#include <ctype.h>
X#include <errno.h>
X#include <stdio.h>
X
X#include <error.h>
X#include <fngrprnt_lex.h>
X#include <str.h>
X#include <fngrprnt.gen.h> /* after str.h */
X
Xstatic char	*fn;
Xstatic FILE	*fp;
Xstatic int	nerr;
Xstatic long	linum;
X
X
Xvoid
Xfngrprnt_lex_open(s)
X	char	*s;
X{
X	fn = s;
X	fp = fopen(s, "r");
X	if (!fp)
X	{
X		if (errno != ENOENT)
X			nfatal("open %s", fn);
X	}
X	linum = 1;
X	nerr = 0;
X}
X
X
Xvoid
Xfngrprnt_lex_close()
X{
X	if (nerr)
X		fatal("%s: found %d error%s", fn, nerr, (nerr == 1 ? "" : "s"));
X	if (fp)
X		fclose(fp);
X	nerr = 0;
X	fn = 0;
X	fp = 0;
X	linum = 0;
X}
X
X
Xstatic int lex_getc _((void));
X
Xstatic int
Xlex_getc()
X{
X	int		c;
X
X	c = fgetc(fp);
X	switch (c)
X	{
X	case EOF:
X		if (ferror(fp))
X			nfatal("read %s", fn);
X		break;
X	
X	case '\n':
X		linum++;
X		break;
X	}
X	return c;
X}
X
X
Xstatic void lex_getc_undo _((int));
X
Xstatic void
Xlex_getc_undo(c)
X	int		c;
X{
X	switch (c)
X	{
X	case EOF:
X		break;
X
X	case '\n':
X		--linum;
X		/* fall through... */
X
X	default:
X		ungetc(c, fp);
X		break;
X	}
X}
X
X
Xint
Xfngrprnt_lex()
X{
X	int		c;
X	char		buffer[2000];
X	char		*cp;
X	long		n;
X
X	if (!fp)
X		return 0;
X	for (;;)
X	{
X		c = lex_getc();
X		switch (c)
X		{
X		case EOF:
X			return 0;
X
X		case '"':
X			cp = buffer;
X			for (;;)
X			{
X				c = lex_getc();
X				if (c == EOF || c == '\n')
X				{
X					unterm:
X					fngrprnt_error("unterminated string");
X					break;
X				}
X				if (c == '"')
X					break;
X				if (c == '\\')
X				{
X					c = lex_getc();
X					if (c == EOF || c == '\n')
X						goto unterm;
X					if (c != '"' && c != '\\')
X						fngrprnt_error("unknown '\\%c' escape", c);
X				}
X				if (cp < ENDOF(buffer))
X					*cp++ = c;
X			}
X			fngrprnt_lval.lv_string = str_n_from_c(buffer, cp - buffer);
X			return STRING;
X
X		case '0': case '1': case '2': case '3': case '4':
X		case '5': case '6': case '7': case '8': case '9': 
X			n = 0;
X			for (;;)
X			{
X				n = n * 10 + c - '0';
X				c = lex_getc();
X				switch (c)
X				{
X				case '0': case '1': case '2': case '3':
X				case '4': case '5': case '6': case '7':
X				case '8': case '9': 
X					continue;
X				
X				default:
X					break;
X				}
X				break;
X			}
X			lex_getc_undo(c);
X			fngrprnt_lval.lv_number = n;
X			return NUMBER;
X
X		case ' ':
X		case '\t':
X		case '\n':
X			break;
X
X		case '=':
X			return EQ;
X
X		case '{':
X			return LB;
X		
X		case '}':
X			return RB;
X
X		default:
X			return JUNK;
X		}
X	}
X}
X
X
Xvoid
Xfngrprnt_error(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	va_list		ap;
X	string_ty	*buffer;
X	int		len;
X
X	sva_init(ap, s);
X	buffer = str_vformat(s, ap);
X	len = buffer->str_length;
X	while (len > 0 && isspace(buffer->str_text[len - 1]))
X		--len;
X	va_end(ap);
X	error("%s: %ld: %.*S", fn, linum, len, buffer);
X	str_free(buffer);
X	if (++nerr >= 20)
X		fatal("%s: found %d errors", fn, nerr);
X}
END_OF_FILE
if test 3572 -ne `wc -c <'cook/fngrprnt_lex.c'`; then
    echo shar: \"'cook/fngrprnt_lex.c'\" unpacked with wrong size!
fi
# end of 'cook/fngrprnt_lex.c'
fi
if test -f 'cookfp/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cookfp/main.c'\"
else
echo shar: Extracting \"'cookfp/main.c'\" \(3782 characters\)
sed "s/^X//" >'cookfp/main.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: operating system start point, and command line argument parsing
X */
X
X#include <stdio.h>
X#include <ac/stdlib.h>
X
X#include <arglex.h>
X#include <error.h>
X#include <fp/cksum.h>
X#include <fp/cksum.h>
X#include <fp/combined.h>
X#include <fp/md5.h>
X#include <fp/snefru.h>
X#include <help.h>
X#include <version.h>
X#include <word.h>
X
X
Xenum
X{
X	arglex_token_cksum,
X	arglex_token_md5,
X	arglex_token_snefru
X};
X
Xstatic arglex_table_ty argtab[] =
X{
X	{ "-Snefru",		arglex_token_snefru,	},
X	{ "-Message_Digest",	arglex_token_md5,	},
X	{ "-Checksum",		arglex_token_cksum,	},
X	{ 0, 0, } /* end marker */
X};
X
X
Xstatic void usage _((void));
X
Xstatic void
Xusage()
X{
X	fprintf(stderr, "Usage: %s [ <option>... ][ <filename>... ]\n", progname);
X	fprintf(stderr, "       %s -Help\n", progname);
X	exit(1);
X}
X
X
Xstatic void main_help _((void));
X
Xstatic void
Xmain_help()
X{
X	static char *text[] =
X	{
X#include <../man1/cookfp.h>
X	};
X
X	help(text, SIZEOF(text), usage);
X}
X
X
Xint main _((int, char **));
X
Xint
Xmain(argc, argv)
X	int		argc;
X	char		**argv;
X{
X	string_ty	*minus;
X	wlist		file;
X	long		j;
X	fingerprint_methods_ty *method;
X	string_ty	*s;
X
X	arglex_init(argc, argv, argtab);
X	str_initialize();
X	switch (arglex())
X	{
X	case arglex_token_help:
X		main_help();
X		exit(0);
X	
X	case arglex_token_version:
X		version();
X		exit(0);
X	
X	default:
X		break;
X	}
X
X	method = 0;
X	wl_zero(&file);
X	minus = str_from_c("-");
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch (arglex_token)
X		{
X		default:
X			error
X			(
X				"misplaced \"%s\" command line argument",
X				arglex_value.alv_string
X			);
X			usage();
X
X		case arglex_token_snefru:
X			if (method)
X			{
X				too_many_methods:
X				error("too many methods specified");
X				usage();
X			}
X			method = &fp_snefru;
X			break;
X
X		case arglex_token_md5:
X			if (method)
X				goto too_many_methods;
X			method = &fp_md5;
X			break;
X
X		case arglex_token_cksum:
X			if (method)
X				goto too_many_methods;
X			method = &fp_cksum;
X			break;
X
X		case arglex_token_string:
X			s = str_from_c(arglex_value.alv_string);
X			wl_append(&file, s);
X			str_free(s);
X			break;
X
X		case arglex_token_stdio:
X			if (wl_member(&file, minus))
X			{
X				error("may only name stdin once");
X				usage();
X			}
X			wl_append(&file, minus);
X			break;
X		}
X		arglex();
X	}
X
X	/*
X	 * if no files named, read stdin
X	 */
X	if (!file.wl_nwords)
X		wl_append(&file, minus);
X
X	/*
X	 * by default, use the fp_combined class
X	 */
X	if (!method)
X		method = &fp_combined;
X
X	/*
X	 * read the named files
X	 */
X	for (j = 0; j < file.wl_nwords; ++j)
X	{
X		fingerprint_ty	*p;
X		char		buf[1000];
X
X		p = fingerprint_new(method);
X		s = file.wl_word[j];
X		if (str_equal(s, minus))
X		{
X			if (fingerprint_file_sum(p, (char *)0, buf))
X				nfatal("standard input");
X			printf("%s", buf);
X			if (file.wl_nwords != 1)
X				printf("\tstdin");
X			printf("\n");
X		}
X		else
X		{
X			if (fingerprint_file_sum(p, s->str_text, buf))
X				nfatal("%s", s->str_text);
X			printf("%s\t%s\n", buf, s->str_text);
X		}
X		fingerprint_delete(p);
X	}
X	exit(0);
X	return 0;
X}
END_OF_FILE
if test 3782 -ne `wc -c <'cookfp/main.c'`; then
    echo shar: \"'cookfp/main.c'\" unpacked with wrong size!
fi
# end of 'cookfp/main.c'
fi
if test -f 'cooktime/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cooktime/main.c'\"
else
echo shar: Extracting \"'cooktime/main.c'\" \(4724 characters\)
sed "s/^X//" >'cooktime/main.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: operating system start point, and parse command line arguments
X */
X
X#include <ac/stddef.h>
X#include <stdio.h>
X#include <ac/string.h>
X#include <ac/stdlib.h>
X
X#include <sys/types.h>
X#include <utime.h>
X#include <sys/stat.h>
X
X#include <arglex.h>
X#include <date.h>
X#include <error.h>
X#include <help.h>
X#include <main.h>
X#include <str.h>
X#include <trace.h>
X#include <version.h>
X#include <word.h>
X
X
Xstatic void usage _((void));
X
Xstatic void
Xusage()
X{
X	fprintf(stderr, "usage: %s [ <option>... ] <filename>\n", progname);
X	fprintf(stderr, "       %s -Help\n", progname);
X	fprintf(stderr, "       %s -VERsion\n", progname);
X	exit(1);
X}
X
X
Xstatic void main_help _((void));
X
Xstatic void
Xmain_help()
X{
X	static char *text[] =
X	{
X#include <../man1/cooktime.h>
X	};
X
X	trace(("c_incl_help()\n{\n"/*}*/));
X	help(text, SIZEOF(text), usage);
X	trace((/*{*/"}\n"));
X}
X
X
Xenum
X{
X	arglex_token_access,
X	arglex_token_modify,
X	arglex_token_report
X};
X
Xstatic	arglex_table_ty	argtab[] =
X{
X	{ "-Access",	(arglex_token_ty)arglex_token_access,	},
X	{ "-Modify",	(arglex_token_ty)arglex_token_modify,	},
X	{ "-Report",	(arglex_token_ty)arglex_token_report,	},
X	{ 0, (arglex_token_ty)0, }, /* end marker */
X};
X
X
Xint main _((int, char **));
X
Xint
Xmain(argc, argv)
X	int		argc;
X	char		**argv;
X{
X	wlist		filename;
X	string_ty	*s;
X	size_t		j;
X	int		mtime_set;
X	long		mtime;
X	int		atime_set;
X	long		atime;
X	int		report;
X
X	arglex_init(argc, argv, argtab);
X	str_initialize();
X	switch (arglex())
X	{
X	case arglex_token_help:
X		main_help();
X		exit(0);
X
X	case arglex_token_version:
X		version();
X		exit(0);
X
X	default:
X		break;
X	}
X
X	report = 0;
X	atime_set = 0;
X	atime = 0;
X	mtime_set = 0;
X	mtime = 0;
X	wl_zero(&filename);
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch(arglex_token)
X		{
X		default:
X			error
X			(
X				"misplaced \"%s\" command line argument",
X				arglex_value.alv_string
X			);
X			usage();
X
X		case arglex_token_string:
X			s = str_from_c(arglex_value.alv_string);
X			wl_append(&filename, s);
X			str_free(s);
X			break;
X
X		case arglex_token_report:
X			if (report)
X			{
X				duplicate:
X				fatal
X				(
X					"duplicate \"%s\" option",
X					arglex_value.alv_string
X				);
X			}
X			report++;
X			break;
X
X		case arglex_token_access:
X			if (atime_set)
X				goto duplicate;
X			if (arglex() != arglex_token_string)
X				fatal("-Access requires a string argument");
X			atime_set = 1;
X			atime = date_scan(arglex_value.alv_string);
X			if (atime < 0)
X				fatal
X				(
X					"the string \"%s\" is not a valid date",
X					arglex_value.alv_string
X				);
X			break;
X
X		case arglex_token_modify:
X			if (mtime_set)
X				goto duplicate;
X			if (arglex() != arglex_token_string)
X				fatal("-Modify requires a string argument");
X			mtime_set = 1;
X			mtime = date_scan(arglex_value.alv_string);
X			if (mtime < 0)
X				fatal
X				(
X					"the string \"%s\" is not a valid date",
X					arglex_value.alv_string
X				);
X			break;
X
X#ifdef DEBUG
X		case arglex_token_tracing:
X			if (arglex() != arglex_token_string)
X				fatal("-TRACIng requires one or more string arguments");
X			for (;;)
X			{
X				trace_enable(arglex_value.alv_string);
X				if (arglex() != arglex_token_string)
X					break;
X			}
X			continue;
X#endif
X		}
X		arglex();
X	}
X	if (!filename.wl_nwords)
X		fatal("no files named");
X	if (!report && !mtime_set && !atime_set)
X	{
X		mtime_set = 1;
X		mtime = date_scan("now");
X	}
X
X	for (j = 0; j < filename.wl_nwords; ++j)
X	{
X		struct stat	st;
X		struct utimbuf	ut;
X
X		s = filename.wl_word[j];
X		if (stat(s->str_text, &st))
X			nfatal("%s", s->str_text);
X		if (mtime_set)
X			ut.modtime = mtime;
X		else
X			ut.modtime = st.st_mtime;
X		if (atime_set)
X			ut.actime = atime;
X		else
X			ut.actime = st.st_atime;
X		if ((atime_set || mtime_set) && utime(s->str_text, &ut))
X			nfatal("%s", s->str_text);
X		if (report)
X		{
X			printf("%s\n", s->str_text);
X			printf("\taccess %s\n", date_string(ut.actime));
X			printf("\tmodify %s\n", date_string(ut.modtime));
X		}
X	}
X	exit(0);
X	return 0;
X}
END_OF_FILE
if test 4724 -ne `wc -c <'cooktime/main.c'`; then
    echo shar: \"'cooktime/main.c'\" unpacked with wrong size!
fi
# end of 'cooktime/main.c'
fi
if test -f 'doc/glossary.so' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/glossary.so'\"
else
echo shar: Extracting \"'doc/glossary.so'\" \(4821 characters\)
sed "s/^X//" >'doc/glossary.so' <<'END_OF_FILE'
X.\"
X.\"	cook - file construction tool
X.\"	Copyright (C) 1990, 1991, 1992, 1993, 1994 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: Reference Manual, Glosary
X.\"	
X.H 1 "Glossary"
XThis document employs a number of terms specific to
X.BR cook .
X.VL 1i
X.\"===============================================================
X.LI \fIbody\fR
XA set of statements, usually commands, to be performed
Xto
X.I cook
Xthe
X.IR target s
Xof a 
X.I recipe
Xafter the
X.IR ingredient s
Xexist.
X.\"===============================================================
X.LI \fIcommand\fR
XA command is a list of words to be passed to the
X.I "operating system"
Xto be executed.
X.\"===============================================================
X.LI \fIcook\fR
XWhen used as a verb,
Xrefers to the actions
X.B cook
Xwould
Xperform to create a
X.IR target ,
Xaccording to some
X.IR recipe .
X.\"===============================================================
X.LI \fIcookbook\fR
XA file containing input for
X.BR cook ,
Xusually 
X.IR recipe s.
X.\"===============================================================
X.LI "\fIexplicit recipe\fR"
XAn explicit recipe is one where the
X.IR target s
Xcontain no patterns.
XThat is, there are no percent ('\fB%\fP') characters in any of the
X.IR target s.
X.\"===============================================================
X.LI \fIfingerprint\fR
XA cryptographically strong hash of the contents of a file,
Xuse to determine if the file contents have changed.
X.\"===============================================================
X.LI \fIflag\fR
XA flag modifies the behaviour of a cook session,
X.I recipe
Xor command.
X.\"===============================================================
X.LI "\fIforced ingredient\fR"
XA files which must exist before a
X.I target
Xfile 
Xof an 
X.I "implicit recipe"
Xmay be cooked.
XThe inability to construct a forced ingredient
Xis an error.
X.\"===============================================================
X.LI \fIfunction\fP
XA function is an action applied to a word list.
X.\"===============================================================
X.LI \fIgate\fR
XA gate is a condition which allows the conditional application of
Xa
X.IR recipe .
X.\"===============================================================
X.LI "\fIimplicit recipe\fR"
XAn implicit recipe is a recipe with patterns in the
X.IR target s.
XThat is, there is a percent ('\fB%\fP') character in at least one of the
X.IR target s.
X.\"===============================================================
X.LI \fIingredient\fR
XA files which must exist before a
X.I target
Xfile may be cooked.
XIn an 
X.I "implicit recipe"
Xthe inability to construct of an ingredient
Xmeans that the
X.I recipe
Xwill not be applied.
XIn an explicit recipe
Xthe inability to construct an ingredient is an error.
X.\"===============================================================
X.LI "\fIlast-modified time\fR"
X.br
X\s-4UNIX\s0 imbues files with several attributes.
XOne of these is a time-stamp of when the file was last modified.
XUsually this is when the file was last written to.
X.\"===============================================================
X.LI \fIrecipe\fR
XA
X.I recipe
Xconsists of several parts.
X.AL
X.LI
XA set of
X.IR target s
Xto be cooked,
X.LI
XA set of ingredients of those
X.IR target s,
Xand
X.LI
XAn optional set of forced ingredients.
X.LI
XAn optional set of flags.
X.LI
XAn optional gate.
X.LI
XAn optional body .
X.LE
X.\"===============================================================
X.LI \fItarget\fR
XThe object of a
X.IR recipe ,
Xa thing which is cooked.
X.\"===============================================================
X.LI \fItouch\fR
XUNIX imbues files with several attributes.
XOne of these is a time-stamp of when the file was last modified.
XUsually this is when the file was last written to,
Xhowever it is possible to simply adjust this attribute,
Xrather than actually writing to the file;
Xthis is colloquially known as
X.IR touch ing
Xa file.
X.\"===============================================================
X.LI \fIvariable\fR
XA variable is a named place holder for a value.
XThe value may be changed.
X.\"===============================================================
X.LE
END_OF_FILE
if test 4821 -ne `wc -c <'doc/glossary.so'`; then
    echo shar: \"'doc/glossary.so'\" unpacked with wrong size!
fi
# end of 'doc/glossary.so'
fi
if test -f 'doc/intro1.so' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/intro1.so'\"
else
echo shar: Extracting \"'doc/intro1.so'\" \(4207 characters\)
sed "s/^X//" >'doc/intro1.so' <<'END_OF_FILE'
X.\"
X.\"	cook - file construction tool
X.\"	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: Reference Manual, Cook from the Outside
X.\"	
X.H 1 "Cook from the Outside"
XThis chapter is part of the tutorial on how to use the
X.B cook
Xprogram.
XIt focuses on how to use
X.BR cook ,
Xwithout needing to know how 
X.B cook
Xworks internally.
X.H 2 "What can cook do for me?"
XBy far the most common use of cook,
Xby experts and beginners alike,
Xis to issue the command
X.eB
Xcook
X.eE
Xand cook will consult its cookbook to see what needs to be done.
X.P
XIn general, 
X.B cook
Xis used to take a set of files and chew on them in some way to produce
Xanother set of files;
Xsuch as the source files for a program,
Xand how to turn them into the executable program file.
XIn order for 
X.B cook
Xto do anything useful, 
Xit nees to know what to do.
X"What to do" is contained in a file called
X.IR Howto.cook
Xin the same directory as the files it is going to work on.
XYou need to execute the  \f(CWcook\fP command in 
Xthe same directory as all of the files.
X.H 2 "What is cook doing?"
XThe
X.I Howto.cook
Xfile was written by the same person who wrote the source files.
XIt contains a set of recipes;
Xeach of which, among other things,
Xcontain commands for how to manipulate the files.
XThe
X.B cook
Xprogram echos each of the commands it is about to execute,
Xso that you can watch what it is doing as it goes.
X.P
XIf the
X.I Howto.cook
Xfile contained only commands,
Xyou would be better off using a shell script.
XIn addition to the commands is information telling 
X.B cook
Xwhich files need to be constructed before other files can be,
Xand from this information
X.B cook
Xdetermines the order in which to execute the commands.
XAlso,
X.B cook
Xexamines other information to determine which commands it need not do,
Xbecause the associated files are already up-to-date.
X.H 2 "What can cook always do?"
XIf you are in a directory with a
X.I Howto.cook
Xfile,
Xyou can expect a few common requests to work
X.VL 1.5i
X.LI "cook clobber"
XThis command can be expected to remove any files from the directory which
X.B cook
Xis able to reconstruct.
X.LI "cook all"
XThis is the default action,
Xand so can be obtained by a simple \f(CWcook\fP request.
XIt causes
X.B cook
Xto construct some specific file or set of files.
X.LI "cook clean"
XThis is similar to "cook clobber" above, 
Xbut it only removes intermediate files,
Xand not not the final file or files which "cook all" constructs.
X.LE
X.P
XIn addition to the above,
Xmany 
X.I Howto.cook 
Xfiles will also define
X.VL 1.5i
X.LI "cook install"
XIf a program or library or document is constructed in the directory,
Xthe this command will install it into the correct place in the
Xsystem.
X.LI "cook uninstall"
XThe reverse of the above,
Xit removes something from the system.
X.LE
X.H 2 "If something goes wrong"
XMost errors while 
X.B cook
Xis constructing file are caused by errors in the source files,
Xand not the 
X.I Howto.cook
Xfile.
XIn general,
Xyou can fix the problems in the source files,
Xand execute the
X.B cook
Xcommand again,
Xand 
X.B cook
Xwill resume from the command which incurred the error.
X.P
XTo help you while editing the files with the errors,
X.B cook
Xkeeps a listing file of all the commands it executed,
Xand any output of those commands,
Xin a file called
X.I Howto.list
Xin the current directory.
X.P
XYou may want 
X.B cook
Xto find all the errors it can before you do any editing,
Xdo do this,
Xuse the
X.B -Continue
Xoption (it may be abbreviated to 
X.B -c
Xfor convenience).
END_OF_FILE
if test 4207 -ne `wc -c <'doc/intro1.so'`; then
    echo shar: \"'doc/intro1.so'\" unpacked with wrong size!
fi
# end of 'doc/intro1.so'
fi
if test -f 'find_libs/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'find_libs/main.c'\"
else
echo shar: Extracting \"'find_libs/main.c'\" \(3901 characters\)
sed "s/^X//" >'find_libs/main.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: operating system start point, and parse command line options
X */
X
X#include <stdio.h>
X#include <ac/stddef.h>
X#include <ac/string.h>
X#include <ac/stdlib.h>
X
X#include <arglex.h>
X#include <error.h>
X#include <help.h>
X#include <mem.h>
X#include <os.h>
X#include <str.h>
X#include <version.h>
X
X
Xstatic void usage _((void));
X
Xstatic void
Xusage()
X{
X	fprintf(stderr, "usage: %s [ -L<path>... ] -l<name>...\n", progname);
X	fprintf(stderr, "       %s -Help\n", progname);
X	fprintf(stderr, "       %s -VERSion\n", progname);
X	exit(1);
X}
X
X
Xstatic void find_libs_help _((void));
X
Xstatic void
Xfind_libs_help()
X{
X	static char *text[] =
X	{
X#include <../man1/find_libs.h>
X	};
X
X	help(text, SIZEOF(text), usage);
X}
X
X
Xenum
X{
X	arglex_token_path,
X	arglex_token_search
X};
X
Xstatic arglex_table_ty argtab[] =
X{
X	{ "-\\L*",	(arglex_token_ty)arglex_token_path,	},
X	{ "-\\L",	(arglex_token_ty)arglex_token_path,	},
X	{ "-\\l*",	(arglex_token_ty)arglex_token_search,	},
X	{ "-\\l",	(arglex_token_ty)arglex_token_search,	},
X	{ 0, (arglex_token_ty)0, }, /* end marker */
X};
X
X
Xstatic char *copy_string _((char *));
X
Xstatic char *
Xcopy_string(s)
X	char	*s;
X{
X	char	*cp;
X
X	cp = mem_alloc(strlen(s) + 1);
X	strcpy(cp, s);
X	return cp;
X}
X
X
Xstatic void get_sys_libs _((int *, char **));
X
Xstatic void
Xget_sys_libs(nlibs, lib)
X	int	*nlibs;
X	char	**lib;
X{
X	char	*cp;
X	char	*start;
X
X	cp = getenv("LD_LIBRARY_PATH");
X	if (!cp)
X	{
X		lib[0] = "/usr/lib";
X		lib[1] = "/lib";
X		*nlibs = 2;
X		return;
X	}
X	*nlibs = 0;
X	start = cp;
X	for (;;)
X	{
X		if (!*cp || *cp == ':')
X		{
X			char	c;
X
X			c = *cp;
X			*cp = 0;
X			if (start < cp)
X				lib[(*nlibs)++] = copy_string(start);
X			*cp = c;
X			if (!c)
X				break;
X			start = cp + 1;
X		}
X		cp++;
X	}
X}
X
X
Xint main _((int, char **));
X
Xint
Xmain(argc, argv)
X	int	argc;
X	char	**argv;
X{
X	char	*path[1000];
X	int	npaths = 0;
X	int	k;
X	char	pathname[2000];
X	char	*syspath[100];
X	int	nsyspaths;
X
X	arglex_init(argc, argv, argtab);
X	str_initialize();
X
X	get_sys_libs(&nsyspaths, syspath);
X
X	switch (arglex())
X	{
X	case arglex_token_help:
X		find_libs_help();
X		exit(0);
X
X	case arglex_token_version:
X		version();
X		exit(0);
X
X	default:
X		break;
X	}
X
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch (arglex_token)
X		{
X		default:
X			error
X			(
X				"misplaced \"%s\" command line argument",
X				arglex_value.alv_string
X			);
X			usage();
X	
X		case arglex_token_search:
X			if (arglex() != arglex_token_string)
X				fatal("-l requires a string argument");
X			for (k = 0; k < nsyspaths; ++k)
X				path[npaths++] = syspath[k];
X			for (k = 0; k < npaths; ++k)
X			{
X				sprintf
X				(
X					pathname,
X					"%s/lib%s.a",
X					path[k],
X					arglex_value.alv_string
X				);
X				if (os_exists(pathname))
X				{
X					printf("%s\n", pathname);
X					break;
X				}
X			}
X			if (k >= npaths)
X			{
X				fatal
X				(
X					"library \"%s\" not found",
X					arglex_value.alv_string
X				);
X			}
X			npaths -= nsyspaths;
X			break;
X	
X		case arglex_token_path:
X			if (arglex() != arglex_token_string)
X				fatal("-L requires a string argument");
X			path[npaths++] = arglex_value.alv_string;
X			break;
X		}
X		arglex();
X	}
X	exit(0);
X	return 0;
X}
END_OF_FILE
if test 3901 -ne `wc -c <'find_libs/main.c'`; then
    echo shar: \"'find_libs/main.c'\" unpacked with wrong size!
fi
# end of 'find_libs/main.c'
fi
if test -f 'make2cook/blob.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'make2cook/blob.c'\"
else
echo shar: Extracting \"'make2cook/blob.c'\" \(3710 characters\)
sed "s/^X//" >'make2cook/blob.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate blobs
X */
X
X#include <blob.h>
X#include <emit.h>
X#include <error.h>
X#include <mem.h>
X#include <s-v-arg.h>
X
Xstatic blob_efunc notify;
X
X
Xblob_ty *
Xblob_alloc(text, file_name, line_number)
X	string_ty	*text;
X	string_ty	*file_name;
X	long		line_number;
X{
X	blob_ty		*this;
X
X	this = mem_alloc(sizeof(blob_ty));
X	this->reference_count = 1;
X	this->text = text;
X	this->file_name = str_copy(file_name);
X	this->line_number = line_number;
X	return this;
X}
X
X
Xvoid
Xblob_free(this)
X	blob_ty		*this;
X{
X	this->reference_count--;
X	if (this->reference_count > 0)
X		return;
X	assert(this->reference_count == 0);
X	str_free(this->text);
X	str_free(this->file_name);
X	mem_free(this);
X}
X
X
Xblob_ty *
Xblob_copy(this)
X	blob_ty		*this;
X{
X	this->reference_count++;
X	return this;
X}
X
X
Xvoid
Xblob_error_notify(func)
X	blob_efunc	func;
X{
X	notify = func;
X}
X
X
Xvoid
Xblob_error(bp, fmt sva_last)
X	blob_ty		*bp;
X	char		*fmt;
X	sva_last_decl
X{
X	string_ty	*buffer;
X	va_list		ap;
X
X	sva_init(ap, fmt);
X	buffer = str_vformat(fmt, ap);
X	va_end(ap);
X	error("%S: %ld: %S", bp->file_name, bp->line_number, buffer);
X	str_free(buffer);
X	if (notify)
X		notify();
X}
X
X
Xvoid
Xblob_warning(bp, fmt sva_last)
X	blob_ty		*bp;
X	char		*fmt;
X	sva_last_decl
X{
X	string_ty	*buffer;
X	va_list		ap;
X
X	sva_init(ap, fmt);
X	buffer = str_vformat(fmt, ap);
X	va_end(ap);
X	error("%S: %ld: warning: %S", bp->file_name, bp->line_number, buffer);
X	str_free(buffer);
X}
X
X
Xblob_list_ty *
Xblob_list_alloc()
X{
X	blob_list_ty	*lllp;
X
X	lllp = mem_alloc(sizeof(blob_list_ty));
X	lllp->length = 0;
X	lllp->maximum = 0;
X	lllp->list = 0;
X	return lllp;
X}
X
X
Xvoid
Xblob_list_free(lllp)
X	blob_list_ty	*lllp;
X{
X	long		j;
X
X	for (j = 0; j < lllp->length; ++j)
X		blob_free(lllp->list[j]);
X	if (lllp->list)
X		mem_free(lllp->list);
X	mem_free(lllp);
X}
X
X
Xvoid
Xblob_list_append(lllp, llp)
X	blob_list_ty	*lllp;
X	blob_ty		*llp;
X{
X	if (lllp->length >= lllp->maximum)
X	{
X		size_t		nbytes;
X
X		lllp->maximum = lllp->maximum * 2 + 8;
X		nbytes = lllp->maximum * sizeof(blob_ty *);
X		lllp->list = mem_change_size(lllp->list, nbytes);
X	}
X	lllp->list[lllp->length++] = llp;
X}
X
X
Xvoid
Xblob_list_prepend(lllp, llp)
X	blob_list_ty	*lllp;
X	blob_ty		*llp;
X{
X	size_t		j;
X
X	if (lllp->length >= lllp->maximum)
X	{
X		size_t		nbytes;
X
X		lllp->maximum = lllp->maximum * 2 + 8;
X		nbytes = lllp->maximum * sizeof(blob_ty *);
X		lllp->list = mem_change_size(lllp->list, nbytes);
X	}
X	for (j = lllp->length; j > 0; --j)
X		lllp->list[j] = lllp->list[j - 1];
X	lllp->length++;
X	lllp->list[0] = llp;
X}
X
X
Xvoid
Xblob_emit(bp)
X	blob_ty		*bp;
X{
X	emit_line_number(bp->line_number, bp->file_name);
X	emit_string(bp->text);
X}
X
X
Xvoid
Xblob_list_delete(blp, bp)
X	blob_list_ty	*blp;
X	blob_ty		*bp;
X{
X	size_t		j, k;
X
X	for (j = 0; j < blp->length; ++j)
X		if (blp->list[j] == bp)
X			break;
X	if (j >= blp->length)
X		return;
X	blob_free(blp->list[j]);
X	for (k = j + 1; k < blp->length; ++k)
X		blp->list[k - 1] = blp->list[k];
X	blp->length--;
X}
END_OF_FILE
if test 3710 -ne `wc -c <'make2cook/blob.c'`; then
    echo shar: \"'make2cook/blob.c'\" unpacked with wrong size!
fi
# end of 'make2cook/blob.c'
fi
if test -f 'make2cook/stmt/compound.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'make2cook/stmt/compound.c'\"
else
echo shar: Extracting \"'make2cook/stmt/compound.c'\" \(4582 characters\)
sed "s/^X//" >'make2cook/stmt/compound.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate compound statements
X */
X
X#include <mem.h>
X#include <stmt/compound.h>
X
Xtypedef struct stmt_compound_ty stmt_compound_ty;
Xstruct stmt_compound_ty
X{
X	STMT
X	size_t		nlines;
X	size_t		nlines_max;
X	stmt_ty		**line;
X};
X
X
Xstatic void constructor _((stmt_ty *));
X
Xstatic void
Xconstructor(that)
X	stmt_ty		*that;
X{
X	stmt_compound_ty *this;
X
X	this = (stmt_compound_ty *)that;
X	this->nlines = 0;
X	this->nlines_max = 0;
X	this->line = 0;
X}
X
X
Xstatic void destructor _((stmt_ty *));
X
Xstatic void
Xdestructor(that)
X	stmt_ty		*that;
X{
X	stmt_compound_ty	*this;
X	size_t		j;
X
X	this = (stmt_compound_ty *)that;
X	for (j = 0; j < this->nlines; ++j)
X		stmt_free(this->line[j]);
X	if (this->line)
X		mem_free(this->line);
X	this->nlines = 0;
X	this->nlines_max = 0;
X	this->line = 0;
X}
X
X
Xstatic void emit _((stmt_ty *));
X
Xstatic void
Xemit(that)
X	stmt_ty		*that;
X{
X	stmt_compound_ty *this;
X	size_t		j;
X
X	this = (stmt_compound_ty *)that;
X	if (this->nlines < 1)
X		return;
X	for (j = 0; j < this->nlines; ++j)
X		stmt_emit(this->line[j]);
X}
X
X
Xstatic void regroup _((stmt_ty *));
X
Xstatic void
Xregroup(that)
X	stmt_ty		*that;
X{
X	stmt_compound_ty *this;
X	stmt_ty		**line;
X	size_t		nlines;
X	size_t		j;
X
X	this = (stmt_compound_ty *)that;
X	line = this->line;
X	nlines = this->nlines;
X	this->line = 0;
X	this->nlines = 0;
X	this->nlines_max = 0;
X	for (j = 0; j < nlines; ++j)
X		stmt_regroup(line[j]);
X
X	j = 0;
X	while (j < nlines)
X	{
X		if (line[j]->white_space)
X		{
X			stmt_ty		*sp;
X
X			sp = stmt_compound_alloc();
X			stmt_compound_append(that, sp);
X			for (;;)
X			{
X				stmt_compound_append(sp, line[j]);
X				++j;
X				if (!line[j - 1]->white_space)
X					break;
X				if (j >= nlines)
X					break;
X			}
X		}
X		else
X		{
X			stmt_compound_append(that, line[j]);
X			++j;
X		}
X	}
X	if (line)
X		mem_free(line);
X}
X
X
Xstatic int intersect _((wlist *, wlist *));
X
Xstatic int
Xintersect(a, b)
X	wlist		*a;
X	wlist		*b;
X{
X	size_t		j;
X
X	for (j = 0; j < a->wl_nwords; ++j)
X		if (wl_member(b, a->wl_word[j]))
X			return 1;
X	return 0;
X}
X
X
Xstatic void sort _((stmt_ty *));
X
Xstatic void
Xsort(that)
X	stmt_ty		*that;
X{
X	stmt_compound_ty *this;
X	size_t		j;
X
X	this = (stmt_compound_ty *)that;
X
X	for (j = 0; j < this->nlines; ++j)
X		stmt_sort(this->line[j]);
X
X	j = 0;
X	while (j < this->nlines)
X	{
X		stmt_ty		*sp;
X		size_t		k, m;
X
X		sp = this->line[j];
X		if (!sp->mdef.wl_nwords)
X		{
X			++j;
X			continue;
X		}
X		for
X		(
X			k = 0;
X			k < j && !intersect(&this->line[k]->ref, &sp->mdef);
X			++k
X		)
X			;
X		if (k >= j)
X		{
X			++j;
X			continue;
X		}
X		for (m = j; m > k; --m)
X			this->line[m] = this->line[m - 1];
X		this->line[k] = sp;
X		j = 0;
X
X		/*
X		 * infinite loop possible:
X		 * assume this is a valid Makefile
X		 */
X	}
X}
X
X
Xstatic stmt_method_ty method =
X{
X	sizeof(stmt_compound_ty),
X	"compound",
X	constructor,
X	destructor,
X	emit,
X	regroup,
X	sort,
X};
X
X
Xstmt_ty *
Xstmt_compound_alloc()
X{
X	return stmt_alloc(&method);
X}
X
X
Xvoid
Xstmt_compound_prepend(that, lp)
X	stmt_ty		*that;
X	stmt_ty		*lp;
X{
X	stmt_compound_ty *this;
X	size_t		j;
X
X	this = (stmt_compound_ty *)that;
X	if (this->nlines >= this->nlines_max)
X	{
X		size_t		nbytes;
X
X		this->nlines_max = this->nlines_max * 2 + 4;
X		nbytes = this->nlines_max * sizeof(stmt_ty *);
X		this->line = mem_change_size(this->line, nbytes);
X	}
X	for (j = this->nlines; j > 0; --j)
X		this->line[j] = this->line[j - 1];
X	this->nlines++;
X	this->line[0] = lp;
X	stmt_variable_merge(that, lp);
X}
X
X
Xvoid
Xstmt_compound_append(that, lp)
X	stmt_ty		*that;
X	stmt_ty		*lp;
X{
X	stmt_compound_ty *this;
X
X	this = (stmt_compound_ty *)that;
X	if (this->nlines >= this->nlines_max)
X	{
X		size_t		nbytes;
X
X		this->nlines_max = this->nlines_max * 2 + 4;
X		nbytes = this->nlines_max * sizeof(stmt_ty *);
X		this->line = mem_change_size(this->line, nbytes);
X	}
X	this->line[this->nlines++] = lp;
X	stmt_variable_merge(that, lp);
X}
END_OF_FILE
if test 4582 -ne `wc -c <'make2cook/stmt/compound.c'`; then
    echo shar: \"'make2cook/stmt/compound.c'\" unpacked with wrong size!
fi
# end of 'make2cook/stmt/compound.c'
fi
if test -f 'make2cook/vargram.y' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'make2cook/vargram.y'\"
else
echo shar: Extracting \"'make2cook/vargram.y'\" \(4314 characters\)
sed "s/^X//" >'make2cook/vargram.y' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to parse variable references
X */
X
X%{
X
X#include <ac/string.h>
X
X#include <trace.h>
X#include <vargram.h>
X#include <variable.h>
X
X#ifdef	DEBUG
X#define YYDEBUG 1
Xextern int yydebug;
X#endif
X
X
Xstatic string_ty *patvar _((string_ty *, string_ty *, string_ty *));
X
Xstatic string_ty *
Xpatvar(name, from, to)
X	string_ty	*name;
X	string_ty	*from;
X	string_ty	*to;
X{
X	string_ty	*tmp;
X	string_ty	*result;
X
X	if (!strchr(from->str_text, '%'))
X	{
X		tmp = from;
X		from = str_format("%%%S", tmp);
X		str_free(tmp);
X	}
X	if (!strchr(to->str_text, '%'))
X	{
X		tmp = to;
X		to = str_format("%%%S", tmp);
X		str_free(tmp);
X	}
X	tmp = vargram_lookup(name);
X	str_free(name);
X	result = str_format("[patsubst %S %S %S]", from, to, tmp);
X	str_free(tmp);
X	str_free(from);
X	str_free(to);
X	return result;
X}
X
X%}
X
X%token	COLON
X%token	COMMA
X%token	DOLLAR
X%token	EQU
X%token	LB
X%token	LP
X%token	PLAIN
X%token	RB
X%token	RP
X%token	SPACE
X
X%union
X{
X	string_ty	*lv_string;
X	wlist		lv_list;
X}
X
X%type	<lv_string>	PLAIN var name csl gizzards plain ossl
X%type	<lv_string>	namec arg argc
X%type	<lv_list>	ssl
X
X%%
X
Xstrings
X	: dbg string
X	| strings SPACE string
X	;
X
Xdbg
X	: /* empty */
X		{
X#if YYDEBUG
X			yydebug = trace_pretest_;
X#endif
X		}
X	;
X
Xstring
X	: gizzards
X		{ vargram_result($1); }
X	| gizzards LP ssl RP
X		{
X			long		j;
X
X			for (j = 0; j < $3.wl_nwords; ++j)
X			{
X				vargram_result
X				(
X					str_format("%S(%S)", $1, $3.wl_word[j])
X				);
X			}
X			str_free($1);
X			wl_free(&$3);
X		}
X	;
X
Xgizzards
X	: var
X		{ $$ = $1; }
X	| plain
X		{ $$ = $1; }
X	| gizzards var
X		{
X			$$ = str_catenate($1, $2);
X			str_free($1);
X			str_free($2);
X		}
X	| gizzards plain
X		{
X			$$ = str_catenate($1, $2);
X			str_free($1);
X			str_free($2);
X		}
X	;
X
Xplain
X	: PLAIN
X		{ $$ = $1; }
X	| COLON
X		{ $$ = str_from_c("\\:"); }
X	| COMMA
X		{ $$ = str_from_c(","); }
X	| EQU
X		{ $$ = str_from_c("\\="); }
X	| LB
X		{ $$ = str_from_c("\\{"/*}*/); }
X	| RB
X		{ $$ = str_from_c(/*{*/"\\}"); }
X	| RP
X		{ $$ = str_from_c(/*(*/")"); }
X	;
X
Xvar
X	: DOLLAR DOLLAR
X		{ $$ = str_from_c("$"); }
X	| DOLLAR PLAIN
X		{
X			$$ = vargram_lookup($2);
X			str_free($2);
X		}
X	| DOLLAR LP name RP
X		{
X			$$ = vargram_lookup($3);
X			str_free($3);
X		}
X	| DOLLAR LB name RB
X		{
X			$$ = vargram_lookup($3);
X			str_free($3);
X		}
X	| DOLLAR LP name COLON name EQU name RP
X		{ $$ = patvar($3, $5, $7); }
X	| DOLLAR LB name COLON name EQU name RB
X		{ $$ = patvar($3, $5, $7); }
X	| DOLLAR LP name SPACE csl RP
X		{
X			$$ = str_format("[%S %S]", $3, $5);
X			str_free($3);
X			str_free($5);
X		}
X	| DOLLAR LB name SPACE csl RB
X		{
X			$$ = str_format("[%S %S]", $3, $5);
X			str_free($3);
X			str_free($5);
X		}
X	;
X
Xname
X	: namec
X		{ $$ = $1; }
X	| name namec
X		{
X			$$ = str_catenate($1, $2);
X			str_free($1);
X			str_free($2);
X		}
X	;
X
Xnamec
X	: PLAIN
X		{ $$ = $1; }
X	| COMMA
X		{ $$ = str_from_c(","); }
X	| var
X		{ $$ = $1; }
X	;
X
Xcsl
X	: ossl
X		{ $$ = $1; }
X	| csl comma ossl
X		{
X			$$ = str_format("%S %S", $1, $3);
X			str_free($1);
X			str_free($3);
X		}
X	;
X
Xossl
X	: /* empty */
X		{ $$ = str_from_c(""); }
X	| ssl
X		{
X			$$ = wl2str(&$1, 0, $1.wl_nwords - 1, (char *)0);
X			wl_free(&$1);
X		}
X	;
X
Xssl
X	: arg
X		{
X			wl_zero(&$$);
X			wl_append(&$$, $1);
X			str_free($1);
X		}
X	| ssl SPACE arg
X		{
X			$$ = $1;
X			wl_append(&$$, $3);
X			str_free($3);
X		}
X	;
X
Xarg
X	: argc
X		{ $$ = $1; }
X	| arg argc
X		{
X			$$ = str_catenate($1, $2);
X			str_free($1);
X			str_free($2);
X		}
X	;
X
Xargc
X	: PLAIN
X		{ $$ = $1; }
X	| EQU
X		{ $$ = str_from_c("\\="); }
X	| COLON
X		{ $$ = str_from_c("\\:"); }
X	| var
X		{ $$ = $1; }
X	;
X
Xcomma
X	: COMMA
X	| comma SPACE
X	;
END_OF_FILE
if test 4314 -ne `wc -c <'make2cook/vargram.y'`; then
    echo shar: \"'make2cook/vargram.y'\" unpacked with wrong size!
fi
# end of 'make2cook/vargram.y'
fi
if test -f 'man1/c_incl.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man1/c_incl.1'\"
else
echo shar: Extracting \"'man1/c_incl.1'\" \(4830 characters\)
sed "s/^X//" >'man1/c_incl.1' <<'END_OF_FILE'
X'\" t
X.\"	cook - file construction tool
X.\"	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: manual entry for c_incl
X.\" 
X.TH C_INCL 1
X.so z_name.so
X.ds n) c_incl
X.SH NAME
X\*(n) - determine dependencies
X.SH SYNOPSIS
X.B \*(n)
X[
X.IR option ...
X]
X.I filename
X.br
X.B \*(n)
X.B -Help
X.br
X.B \*(n)
X.B -VERSion
X.SH DESCRIPTION
XThe
X.I \*(n)
Xprogram
Xis used to traverse source files looking for include dependencies
Xsuitable for \f(CW[collect]\fPion by cook.
X.PP
XSeveral input languages are supported,
Xsee the options list for details.
X.br
X.ne 1i
X.SH OPTIONS
XThe following options are understood.
X.TP 8n
X.B -C
X.br
XThe source file is a C source file.
XIt is assumed that it will have the dependencies resolved
Xby the
X.IR cpp (1)
Xcommand.
XThe same include semantics as the
X.IR cpp (1)
Xcommand will be employed.
XThis is the default.
X.TP 8n
X.B -Roff
X.br
XThe source file is a *roff source file.
XIt is assumed that it will have the dependencies resolved
Xby the
X.IR roffpp (1)
Xcommand.
XThe same include semantics as the
X.IR roffpp (1)
Xcommand will be employed.
X.TP 8n
X.B -Verbose
X.br
XTell what is happening.
X.TP 8n
X.BI -I path
X.br
XSpecify include path, a la
X.IR cc (1).
X.TP 8n
X.B -Absent_Local_Ignore
X.br
XFor files included using a
X.I "#include ''filename.h''"
Xdirective,
Xignore the file if it cannot be found.
X.TP 8n
X.B -Absent_Local_Mention
X.br
XFor files included using a
X.I "#include ''filename.h''"
Xdirective,
Xprint the file name even if the file cannot be found.
XThis is the default (it probably needs to be built).
X.TP 8n
X.B -Absent_Local_Error
X.br
XFor files included using a
X.I "#include ''filename.h''"
Xdirective,
Xprint a fatal error if the file cannot be found.
X.TP 8n
X.B -Absent_System_Ignore
X.br
XFor files included with a
X.I "#include <filename.h>"
Xdirective,
Xignore the file if it cannot be found.
XThis is the default (it was probably ifdef'ed out).
X.TP 8n
X.B -Absent_System_Mention
X.br
XFor files included with a
X.I "#include <filename.h>"
Xdirective,
Xprint the file name even if the file cannot be found.
X.TP 8n
X.B -Absent_System_Error
X.br
XFor files included with a
X.I "#include <filename.h>"
Xdirective,
Xprint a fatal error if the file cannot be found.
X.TP 8n
X.B -Absent_Program_Ignore
X.br
XIf the file named on the command line cannot be found,
Xbehave as if the file were found, but was empty.
X.TP 8n
X.B -Absent_Program_Error
X.br
XIf the file named on the command line cannot be found,
Xprint a fatal error message.
XThis is the default.
X.TP 8n
X.B -Help
X.br
XGive information on how to use
X.IR \*(n) .
X.TP 8n
X.B -VERSion
X.br
XTell what version of
X.I \*(n)
Xis being run.
X.TP 8n
X.B -No_System
X.br
XDo not search the 
X.I /usr/include
Xdirectory.
XBy default this is searched last.
X.TP 8n
X.B -No_Cache
X.br
XThis option may be used to turn caching off.
X.TP 8n
X\fB-PREfix\fP \fIstring\fP
X.br
XThis option may be used to print a string
Xbefore any of the filenames are printed.
XIt will not be printed if no file names are printed.
X.TP 8n
X\fB-SUFfix\fP \fIstring\fP
X.br
XThis option may be used to print a string
Xafter all of the filenames are printed.
XIt will not be printed if no file names are printed.
X.PP
XAny other options will generate an error.
X.so o__rules.so
X.br
X.ne 1i
X.SH CACHING
XThe caching mechanism use by the
X.I \*(n)
Xprogram caches the results of searching files
Xfor include files (in a file called
X.I .\*(n)rc
Xin the current directory).
XThe cache is only refreshed when a file changes.
X.PP
XThe use of this cache has been shown to dramatically increase the
Xperformance of the
X.I \*(n)
Xprogram.
XTypically,
Xonly a small proportions files in a project change between builds,
Xresulting in a very high cache hit rate.
X.PP
XWhen using caching,
Xalways use the same command line options,
Xotherwise weird and wonderful things will happen.
X.PP
XThe
X.I .\*(n)rc
Xfile is a binary file.
XIf you wish to rebuild the cache,
Xsimply delete this file with the
X.IR rm (1)
Xcommand.
XBeing a binary file,
Xthe
X.I .\*(n)rc
Xfile is not portable across machines or operating systems,
Xso you will need to delete it when you move your sources.
XIt is a binary file for performance.
X.so z_exit.so
X.so copyright.so
END_OF_FILE
if test 4830 -ne `wc -c <'man1/c_incl.1'`; then
    echo shar: \"'man1/c_incl.1'\" unpacked with wrong size!
fi
# end of 'man1/c_incl.1'
fi
if test -f 'man1/cookfp.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man1/cookfp.1'\"
else
echo shar: Extracting \"'man1/cookfp.1'\" \(3717 characters\)
sed "s/^X//" >'man1/cookfp.1' <<'END_OF_FILE'
X'\" t
X.\"	cook - file construction tool
X.\"	Copyright (C) 1994 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: manual entry for the cookfp command
X.\"
X.TH cookfp 1
X.ds n) cookfp
X.SH NAME
X\*(n) \- calculate file fingerprint
X.SH SYNOPSIS
X.B \*(n)
X[
X.IR option \&...
X][
X.IR filename \&...
X]
X.br
X.B \*(n)
X.B -Help
X.br
X.B \*(n)
X.B -VERSion
X.SH DESCRIPTION
XThe
X.I \*(n)
Xprogram is used to
Xcalculate the fingerprints of files.
XA fingerprint is a hash of the contents of a file.
XThe default fingerprint is cryptographically strong,
Xso the probability of two different files having the
Xsame fingerprint is less than 1 in 2**200.
X.PP
XThe fingerprint is based on Dan Berstien <djb@silverton.berkeley.edu>
Xpublic domain fingerprint 0.50 beta package 930809,
Xposted to the alt.sources newsgroup.
XThis program produces identical results;
Xthe expected test results were generated using Dan's package.
X.PP
XThe
Xfingerprint is a base-64-sanely-encoded fingerprint of the input.
XImagine this fingerprint as something universal and permanent.
XA fingerprint is 76 characters long, containing the following:
X.TP 4n
X1.
XA Snefru-8 (version 2.5, 8 passes, 512->256) hash.
X(Derived from the Xerox Secure Hash Function.)
X.TP 4n
X2.
XAn MD5 hash, as per RFC 1321.
X(Derived from the RSADSI MD5 Message-Digest Algorithm.)
X.TP 4n
X3.
XA CRC checksum, as in the new cksum utility.
X.TP 4n
X4.
XLength modulo 2^40.
X.PP
XThe output format is not expected to be compatible with anything.
XHowever,
Xoptions are available to produce
Xthe purported output of Merkle's snefru program,
Xthe purported output of RSADSI's mddriver -x,
Xor the purported output of the POSIX cksum program.
X.PP
XIf no files are named as input,
Xthe standard input will be used.
XThe special file name ``-'' is understood to mean the standard input.
X.br
X.ne 1i
X.SH OPTIONS
XThe following options are understood:
X.TP 8n
X.B -Checksum
XPrint the CRC32 checksum and length of the named file(s).
X.TP 8n
X.B -Help
X.br
XProvide some help with using the
X.I \*(n)
Xprogram.
X.TP 8n
X.B -Message_Digest
XPrint the
XRSA Data Security, Inc. MD5 Message-Digest Algorithm
Xhash of the named file(s).
X.TP 8n
X.B -Snefru
XPrint the Snefru hash of the named file(s),
Xderived from the Xerox Secure Hash Function.
X.TP 8n
X.B -VERSion
X.br
XPrint the version of the
X.I \*(n)
Xprogram being executed.
X.PP
XAll other options will produce a diagnostic error.
X.so o__rules.so
X.so z_exit.so
X.so copyright.so
X.PP
XPortions of this program are derived from sources from other people,
Xsometimes with liberal copyrights, and sometimes in the public domain.
XThese include:
X.TP 8n
XDan Bernstien
XSee
X.I common/fp/README
Xfor details.
X.TP 8n
XGary S Brown.
XSee
X.I common/fp/crc32.c
Xfor details.
X.TP 8n
XRSA Data Security, Inc.
XSee
X.I common/fp/md5.c
Xfor details.
X.TP 8n
XXerox Corporation
XSee
X.I common/fp/snefru.c
Xfor details.
X.PP
XIn addition to the above copyright holders,
Xthere have been numerous authors and contributors,
Xsee the named files for details.
XFiles names are relative to the root of the
X.I cook
Xdistribution.
END_OF_FILE
if test 3717 -ne `wc -c <'man1/cookfp.1'`; then
    echo shar: \"'man1/cookfp.1'\" unpacked with wrong size!
fi
# end of 'man1/cookfp.1'
fi
if test -f 'man1/roffpp.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man1/roffpp.1'\"
else
echo shar: Extracting \"'man1/roffpp.1'\" \(3507 characters\)
sed "s/^X//" >'man1/roffpp.1' <<'END_OF_FILE'
X'\" t
X.\"	cook - file construction tool
X.\"	Copyright (C) 1991, 1992, 1993, 1994 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: manual entry for the roffpp command
X.\" 
X.TH ROFFPP 1
X.so z_name.so
X.ds n) roffpp
X.SH NAME
X\*(n) \- replace \&.so requests within *roff sources
X.SH SYNOPSIS
X.B \*(n)
X[
X.IR option ...
X][
X.I infile
X[
X.I outfile
X]]
X.br
X.B \*(n)
X.B -Help
X.br
X.B \*(n)
X.B -VERSion
X.SH DESCRIPTION
XThe
X.I \*(n)
Xcommand may be used to
Xcopies the input file to the output file,
Xincluding files named using
X.I \&.so
Xdirectives along the way,
Xand removing the
X.I \&.so
Xdirectives.
X.PP
XThis is useful when processing large multi-file documents
Xwith filters such as
X.IR tbl (1)
Xor
X.IR eqn (1)
Xwhich do not understand the
X.I .so
Xdirective.
XThe
X.I \&.nx
Xdirective is not understood.
XThe
X.I \*(n)
Xprogram is not a general *roff interpreter,
Xso many constructs will be beyond it,
Xfortunately, most of them have nothing to do with include files.
XInclude files which cannot be found,
Xprobably from uninterpreted *roff constructs,
Xif the files really does exist,
Xwill simply be passed through unchanged,
Xfor *roff to interpret at a later time.
X.PP
XThe
X.I \*(n)
Xprogram also allows the user to specify an include search path.
XThis allows, for example, common files to be kept in a central location.
X.PP
XOnly directives of the form
X.RS
X.B \&.so
X.I filename
X.RE
Xare processed.
XIf the directive is introduced using the single quote form,
Xor the dot is not the first character of the line,
Xthe directive will be ignored.
X.PP
XAny extra arguments on the line are ignored,
Xand quoting is not understood.
XAll characters are interpreted literally.
X.PP
XExamples of directives which will be ignored include
X.RS
X.nf
X\&'so /usr/lib/tmac/tmac.an
X\&.if n .so yuck
X.fi
X.RE
XThis list is not exhaustive.
X.PP
XThe special file name
X.RB ` \- '
Xon the command line
Xmeans the standard input or standard output,
Xas appropriate.
XFiles which are omitted are also assumed to be
Xthe standard input or standard output,
Xas appropriate.
X.PP
XThe output attempts to keep file names and line numbers in sync
Xby using the
X.B \&.lf
Xdirective.
XThe
X.B \&.lf
Xdirective is also understood as input.
XThis is compatible with
X.IR groff (1)
Xand the other GNU text utilities included in the groff package.
X.br
X.ne 1i
X.SH OPTIONS
XThe following options are understood.
X.TP 8n
X.BI -I path
X.br
XSpecify include path, a la
X.IR cc (1).
XInclude paths are searched in the order specified.
XThe include search path defaults to the current directory
Xif and only if the user does not specify any include search paths.
X.TP 8n
X.B -Help
X.br
XGive information on how to use
X.IR \*(n) .
X.TP 8n
X.B -VERSion
X.br
XTell what version of
X.I \*(n)
Xis being run.
X.PP
XAny other option will generate a diagnostic error.
X.so o__rules.so
X.so z_exit.so
X.so copyright.so
END_OF_FILE
if test 3507 -ne `wc -c <'man1/roffpp.1'`; then
    echo shar: \"'man1/roffpp.1'\" unpacked with wrong size!
fi
# end of 'man1/roffpp.1'
fi
if test -f 'test/00/t0066a.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test/00/t0066a.sh'\"
else
echo shar: Extracting \"'test/00/t0066a.sh'\" \(3471 characters\)
sed "s/^X//" >'test/00/t0066a.sh' <<'END_OF_FILE'
X#!/bin/sh
X#
X#	cook - file construction tool
X#	Copyright (C) 1994 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: Test the make2cook functionality
X#
Xwork=/tmp/$$
XPAGER=cat
Xexport PAGER
Xumask 022
Xunset COOK
Xhere=`pwd`
Xif test $? -ne 0 ; then exit 1; fi
X
Xif test "$1" != "" ; then bin="$here/$1/bin"; else bin="$here/bin"; fi
X
Xfail()
X{
X	set +x
X	echo 'FAILED test of the make2cook functionality' 1>&2
X	cd $here
X	rm -rf $work
X	exit 1
X}
Xpass()
X{
X	set +x
X	cd $here
X	rm -rf $work
X	exit 0
X}
Xtrap \"fail\" 1 2 3 15
X
Xmkdir $work
Xif test $? -ne 0 ; then exit 1; fi
Xcd $work
Xif test $? -ne 0 ; then fail; fi
X
X#
X# make2cook
X#
Xcat > test.in << 'fubar'
X.SUFFIXES:
X.SUFFIXES: .c .o
X#
X# set the C compiler to be gcc
X#
XCC = gcc
Xall: test
Xoverride GET = get
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.ok << 'fubar'
Xif [not [defined GFLAGS]] then
X	GFLAGS = [getenv GFLAGS];
Xif [not [defined COFLAGS]] then
X	COFLAGS = [getenv COFLAGS];
Xif [not [defined CO]] then
X{
X	CO = [getenv CO];
X	if [not [CO]] then
X		CO = co;
X}
Xif [not [defined CHECKOUT,v]] then
X{
X	CHECKOUT,v = [getenv CHECKOUT,v];
X	if [not [CHECKOUT,v]] then
X		CHECKOUT,v = [CO] [COFLAGS];
X}
Xif [not [defined CPPFLAGS]] then
X	CPPFLAGS = [getenv CPPFLAGS];
Xif [not [defined CFLAGS]] then
X	CFLAGS = [getenv CFLAGS];
Xif [not [defined TARGET_ARCH]] then
X	TARGET_ARCH = [getenv TARGET_ARCH];
X
X/*
X * set the C compiler to be gcc
X */
Xif [not [defined CC]] then
X	CC = gcc;
X
Xif [not [defined COMPILE.c]] then
X{
X	COMPILE.c = [getenv COMPILE.c];
X	if [not [COMPILE.c]] then
X		COMPILE.c = [CC] [CFLAGS] [CPPFLAGS] [TARGET_ARCH] -c;
X}
Xif [not [defined LDFLAGS]] then
X	LDFLAGS = [getenv LDFLAGS];
Xif [not [defined LINK.c]] then
X{
X	LINK.c = [getenv LINK.c];
X	if [not [LINK.c]] then
X		LINK.c = [CC] [CFLAGS] [CPPFLAGS] [LDFLAGS] [TARGET_ARCH];
X}
Xif [not [defined LDLIBS]] then
X	LDLIBS = [getenv LDLIBS];
Xif [not [defined LOADLIBES]] then
X	LOADLIBES = [getenv LOADLIBES];
Xif [not [defined LINK.o]] then
X{
X	LINK.o = [getenv LINK.o];
X	if [not [LINK.o]] then
X		LINK.o = [CC] [LDFLAGS] [TARGET_ARCH];
X}
X
Xall: test;
XGET = get;
X
X%: %.o
X{
X	[LINK.o] [resolve [need]] [LOADLIBES] [LDLIBS] -o [target];
X}
X%: %.c
X{
X	[LINK.c] [resolve [need]] [LOADLIBES] [LDLIBS] -o [target];
X}
X%.o: %.c
X{
X	[COMPILE.c] [resolve [head [need]]];
X}
X%: %,v
X{
X	[CHECKOUT,v] [resolve [need]] [target]
X		set notouch;
X}
X%: RCS/%,v
X{
X	[CHECKOUT,v] [resolve [need]] [target]
X		set notouch;
X}
X%: s.%
X{
X	[GET] [GFLAGS] [resolve [need]];
X}
X%: SCCS/s.%
X{
X	[GET] [GFLAGS] [resolve [need]];
X}
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
X$bin/make2cook test.in test.out -hc
Xif test $? -ne 0 ; then fail; fi
X
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X
X#
X# Only definite negatives are possible.
X# The functionality exercised by this test appears to work,
X# no other guarantees are made.
X#
Xpass
END_OF_FILE
if test 3471 -ne `wc -c <'test/00/t0066a.sh'`; then
    echo shar: \"'test/00/t0066a.sh'\" unpacked with wrong size!
fi
# end of 'test/00/t0066a.sh'
fi
if test -f 'txt2c/txt2c.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'txt2c/txt2c.c'\"
else
echo shar: Extracting \"'txt2c/txt2c.c'\" \(3544 characters\)
sed "s/^X//" >'txt2c/txt2c.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1993, 1994 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to turn text into C strings
X */
X
X#include <ctype.h>
X#include <stdio.h>
X
X#include <error.h>
X#include <txt2c.h>
X
X
Xstatic int readline _((FILE *, char *, char *, long));
X
Xstatic int
Xreadline(fp, fn, buf, buflen)
X	FILE	*fp;
X	char	*fn;
X	char	*buf;
X	long	buflen;
X{
X	char	*bp;
X	char	*ep;
X
X	bp = buf;
X	ep = buf + buflen - 1;
X	while (bp < ep)
X	{
X		int c = getc(fp);
X		if (c == EOF)
X		{
X			if (ferror(fp))
X				nfatal("read %s", fn);
X			if (bp == buf)
X				return 0;
X			break;
X		}
X		if (c == '\n')
X			break;
X		*bp++ = c;
X	}
X	*bp = 0;
X	return 1;
X}
X
X
Xstatic int comment _((char *));
X
Xstatic int
Xcomment(line)
X	char	*line;
X{
X	if (*line != '.' && *line != '\'')
X		return 0;
X	++line;
X	while (*line == ' ' || *line == '\t')
X		++line;
X	return (line[0] == '\\' && line[1] == '"');
X}
X
X
Xstatic int printable _((char *));
X
Xstatic int
Xprintable(line)
X	char	*line;
X{
X	while (*line)
X	{
X		if (!isprint(*line) && *line != '\t')
X			return 0;
X		++line;
X	}
X	return 1;
X}
X
X
Xstatic void print _((FILE *, char *, char *));
X
Xstatic void
Xprint(fp, fn, line)
X	FILE	*fp;
X	char	*fn;
X	char	*line;
X{
X	putc('"', fp);
X	while (*line)
X	{
X		int c = *line++;
X		switch (c)
X		{
X		case '\t':
X			fprintf(fp, "\\t");
X			break;
X
X		case '"':
X		case '\\':
X			putc('\\', fp);
X			putc(c, fp);
X			break;
X
X		default:
X			if (!isprint(c))
X				break;
X			putc(c, fp);
X			break;
X		}
X	}
X	fprintf(fp, "\",\n");
X	if (ferror(fp))
X		nfatal("write %s", fn);
X}
X
X
Xvoid
Xtxt2c(ifn, ofn)
X	char	*ifn;
X	char	*ofn;
X{
X	FILE	*ifp;
X	FILE	*ofp;
X	long	linum;
X	char	line[1000];
X	long	len;
X	long	nerrs;
X	long	olinum;
X
X	if (ifn)
X	{
X		ifp = fopen(ifn, "r");
X		if (!ifp)
X			nfatal("open %s", ifn);
X	}
X	else
X	{
X		ifp = stdin;
X		ifn = "standard input";
X	}
X
X	if (ofn)
X	{
X		ofp = fopen(ofn, "w");
X		if (!ofp)
X			nfatal("create %s", ofn);
X	}
X	else
X	{
X		ofp = stdout;
X		ofn = "standard output";
X	}
X
X	nerrs = 0;
X	linum = 0;
X	olinum = -1;
X	while (readline(ifp, ifn, line, sizeof(line)))
X	{
X		for (;;)
X		{
X			++linum;
X			len = strlen(line);
X			if (!len || line[len - 1] != '\\')
X				break;
X			--len;
X			if (!readline(ifp, ifn, line + len, sizeof(line) - len))
X				break;
X		}
X		if (comment(line))
X			continue;
X		if (!printable(line))
X		{
X			error
X			(
X				"%s: %ld: contains unprintable character",
X				ifn,
X				linum
X			);
X			++nerrs;
X			continue;
X		}
X		if (len > 72)
X		{
X			error
X			(
X				"%s: %ld: line too long (by %ld)",
X				ifn,
X				linum,
X				len - 72
X			);
X			++nerrs;
X		}
X		if (olinum != linum)
X		{
X			fprintf(ofp, "\".lf %ld \\\"%s\\\"\",\n", linum, ifn);
X			fprintf(ofp, "#line %ld \"%s\"\n", linum, ifn);
X			olinum = linum;
X		}
X		print(ofp, ofn, line);
X		++olinum;
X	}
X	if (nerrs)
X		fatal("found %ld error%s", nerrs, (nerrs == 1 ? "" : "s"));
X	if (fclose(ofp))
X		nfatal("write %s", ofn);
X	fclose(ifp);
X}
END_OF_FILE
if test 3544 -ne `wc -c <'txt2c/txt2c.c'`; then
    echo shar: \"'txt2c/txt2c.c'\" unpacked with wrong size!
fi
# end of 'txt2c/txt2c.c'
fi
echo shar: End of archive 7 \(of 19\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 19 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
