Newsgroups: comp.sources.unix
From: mcooper@usc.edu (Michael A. Cooper)
Subject: v28i077: sysinfo-2.1.2 - Show system information, V2.1.2, Part04/05
References: <1.772126523.28031@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: mcooper@usc.edu (Michael A. Cooper)
Posting-Number: Volume 28, Issue 77
Archive-Name: sysinfo-2.1.2/part04

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 5)."
# Contents:  info-sunos.c os-sunos4.c os-sunos5.c
# Wrapped by vixie@gw.home.vix.com on Mon Jun 20 08:33:21 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'info-sunos.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'info-sunos.c'\"
else
echo shar: Extracting \"'info-sunos.c'\" \(20858 characters\)
sed "s/^X//" >'info-sunos.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: info-sunos.c,v 1.58 1994/01/12 22:56:08 mcooper Exp mcooper $";
X#endif
X
X
X/*
X * SunOS specific device info
X */
X
X#include "defs.h"
X
X#include <sys/types.h>
X#include <sys/buf.h>
X#include <sys/mtio.h>
X
X/*
X * RomVec
X */
Xchar 				RomVecSYM[] = "_romp";
X
X/*
X * idprom
X */
Xchar 				IdpromSYM[] = "_idprom";
X
X#if	defined(HAVE_MAINBUS)
X/*
X * MainBus symbol
X */
Xchar 				MainBusSYM[] = "_mbdinit";
X#endif	/* HAVE_MAINBUS */
X
X#if	defined(HAVE_OPENPROM)
X/*
X * OpenPROM symbol
X */
Xchar 				OpenPROMSYM[] = "_top_devinfo";
X#endif	/* HAVE_OPENPROM */
X
X
X/*
X * Sun system model table
X *
X * Not all values are real machines.  What is found below is
X * extracted from /usr/include/{sun3,sun3x,sun4,sun4c,sun4m}/cpu.h.
X */
XNAMETAB ModelTab[] = {
X/*
X * Sun-3 CPU's
X */
X#ifdef CPU_SUN3_50
X    {  CPU_SUN3_50,	 	"3/50" },
X#endif
X#ifdef CPU_SUN3_60
X    {  CPU_SUN3_60,	 	"3/60" },
X#endif
X#ifdef CPU_SUN3_E
X    {  CPU_SUN3_E,	    	"3/Eurocard" },
X#endif
X#ifdef CPU_SUN3_110
X    {  CPU_SUN3_110,	    	"3/110" },
X#endif
X#ifdef CPU_SUN3_160
X    {  CPU_SUN3_160,	    	"3/100 Series" },
X#endif
X#ifdef CPU_SUN3_260
X    {  CPU_SUN3_260,	    	"3/200 Series" },
X#endif
X
X/*
X * Sun-3x CPU's
X */
X#ifdef CPU_SUN3X_80
X    {  CPU_SUN3X_80,		"3/80" },
X#endif
X#ifdef CPU_SUN3X_470
X    {  CPU_SUN3X_470,		"3/400 Series" },
X#endif
X
X/*
X * Sun-4c CPU's.
X */
X#ifdef CPU_SUN4C_05
X    {  CPU_SUN4C_05,		"4/05" },
X#endif
X#ifdef CPU_SUN4C_10
X    {  CPU_SUN4C_10,		"4/10" },
X#endif
X#ifdef CPU_SUN4C_20
X    {  CPU_SUN4C_20,		"4/20 (SPARCstation SLC)" },
X#endif
X/*
X * XXX The 4/25 and 4/30 are both ELC's depending on your OS
X */
X#ifdef CPU_SUN4C_25
X    {  CPU_SUN4C_25,		"4/25 (SPARCstation ELC)" },
X#endif
X#ifdef CPU_SUN4C_30
X    {  CPU_SUN4C_30,		"4/30 (SPARCstation ELC)" },
X#endif
X#ifdef CPU_SUN4C_32
X    {  CPU_SUN4C_32,		"4/32" },
X#endif
X#ifdef CPU_SUN4C_40
X    {  CPU_SUN4C_40,		"4/40 (SPARCstation IPC)" },
X#endif
X#ifdef CPU_SUN4C_45
X    {  CPU_SUN4C_45,		"4/45" },
X#endif
X#ifdef CPU_SUN4C_50
X    {  CPU_SUN4C_50,		"4/50 (SPARCstation IPX)" },
X#endif
X#ifdef CPU_SUN4C_60
X    {  CPU_SUN4C_60,		"4/60 (SPARCstation 1)" },
X#endif
X#ifdef CPU_SUN4C_65
X    {  CPU_SUN4C_65,		"4/65 (SPARCstation 1+)" },
X#endif
X#ifdef CPU_SUN4C_70
X    {  CPU_SUN4C_70,		"4/70" },
X#endif
X#ifdef CPU_SUN4C_75
X    {  CPU_SUN4C_75,		"4/75 (SPARCstation 2)" },
X#endif
X#ifdef CPU_SUN4C_80
X    {  CPU_SUN4C_80,		"4/80" },
X#endif
X#ifdef CPU_SUN4C_85
X    {  CPU_SUN4C_85,		"4/85" },
X#endif
X
X/*
X * Sun-4 CPU's
X */
X#ifdef CPU_SUN4_110
X    {  CPU_SUN4_110,	    	"4/110" },
X#endif
X#ifdef CPU_SUN4_260
X    {  CPU_SUN4_260,	    	"4/200 Series" },
X#endif
X#ifdef CPU_SUN4_330
X    {  CPU_SUN4_330,		"SPARCsystem 300" },
X#endif
X#ifdef CPU_SUN4_460	/* Sun changed the 4_460 to 4_470 in 4.1.1 */
X    {  CPU_SUN4_460,		"SPARCsystem 400" },
X#endif
X#ifdef CPU_SUN4_470
X    {  CPU_SUN4_470,		"SPARCsystem 400" },
X#endif
X
X/*
X * Sun-4m CPU's
X */
X#ifdef CPU_SUN4M_50
X    {  CPU_SUN4M_50,	    	"SPARCsystem 10" },
X#endif
X#ifdef CPU_SUN4M_40
X    {  CPU_SUN4M_40,	    	"SPARCsystem 4m/40" },	/* XXX ??? */
X#endif
X#ifdef CPU_SUN4M_60
X    {  CPU_SUN4M_60,	    	"SPARCsystem 600" },	/* SunOS 5.x */
X#endif
X#ifdef CPU_SUN4M_690
X    {  CPU_SUN4M_690,	    	"SPARCsystem 600" },	/* SunOS 4.x */
X#endif
X
X/*
X * Sun-4e CPU's.
X */
X#ifdef CPU_SUN4E_120
X    {  CPU_SUN4E_120,	    	"SPARCengine 1E" },
X#endif
X
X/*
X * Sun-4d CPU's.
X */
X#ifdef CPU_SUN4D
X    {  CPU_SUN4D,	    	"Sun4d" },	/* XXX ??? */
X#endif
X
X/*
X * Sun-386i CPU's
X */
X#ifdef CPU_SUN386_MB1
X    {  CPU_SUN386_MB1,		"386i (MB1)" },
X#endif
X#ifdef CPU_SUN386_150
X    /* The 386i/150 and 386i/250 are the same */
X    {  CPU_SUN386_150,		"386i" },
X#endif
X
X/*
X * Solbourne CPU's
X */
X#ifdef CPU_SERIES4_500
X    {  CPU_SERIES4_500,		"Series4/500" },
X#endif
X#ifdef CPU_SERIES4_600
X    {  CPU_SERIES4_600,		"Series4/600" },
X#endif
X#ifdef CPU_SERIES5_500
X    {  CPU_SERIES5_500,		"Series5/500" },
X#endif
X#ifdef CPU_SERIES5_600
X    {  CPU_SERIES5_600,		"Series5/600" },
X#endif
X#ifdef CPU_SERIES5_900
X    {  CPU_SERIES5_900,		"Series5/900" },
X#endif
X#ifdef CPU_SERIES5E_500
X    {  CPU_SERIES5E_500,	"Series5E/500" },
X#endif
X#ifdef CPU_SERIES5E_600
X    {  CPU_SERIES5E_600,	"Series5E/600" },
X#endif
X#ifdef CPU_SERIES5E_900
X    {  CPU_SERIES5E_900,	"Series5E/900" },
X#endif
X#ifdef CPU_SERIES6_500
X    {  CPU_SERIES6_500,		"Series6/500" },
X#endif
X#ifdef CPU_SERIES6_600
X    {  CPU_SERIES6_600,		"Series6/600" },
X#endif
X#ifdef CPU_SERIES6_900
X    {  CPU_SERIES6_900,		"Series6/900" },
X#endif
X
X/*
X * TadPole CPU's
X */
X#ifdef CPU_TAD_SPBK_S1
X    {  CPU_TAD_SPBK_S1,		"SPARCbook-1" },
X#endif
X
X    { 0 },
X};
X
X/*
X * Kernel Architecture table
X */
XNAMETAB KernArchTab[] = {
X#ifdef SUN386_ARCH
X    {  SUN386_ARCH,		"sun386" },
X#endif
X#ifdef SUN3_ARCH
X    {  SUN3_ARCH,		"sun3" },
X#endif
X#ifdef SUN3X_ARCH
X    {  SUN3X_ARCH,		"sun3x" },
X#endif
X#ifdef SUN4_ARCH
X    {  SUN4_ARCH,		"sun4" },
X#endif
X#ifdef SUN4C_ARCH
X    {  SUN4C_ARCH,		"sun4c" },
X#endif
X#ifdef SUN4D_ARCH
X    {  SUN4D_ARCH,		"sun4d" },
X#endif
X#ifdef SUN4E_ARCH
X    {  SUN4E_ARCH,		"sun4e" },
X#endif
X#ifdef SUN4M_ARCH
X    {  SUN4M_ARCH,		"sun4m" },
X#endif
X/*
X * Tadpole
X */
X#ifdef TAD_SPBK_ARCH
X    {  TAD_SPBK_ARCH,		"SPARCbook" },
X#endif
X/*
X * Solbourne
X */
X#ifdef CPU_TYPE_SERIES4
X    {  CPU_TYPE_SERIES4,	"Series4" },
X#endif
X#ifdef CPU_TYPE_SERIES5
X    {  CPU_TYPE_SERIES5,	"Series5" },
X#endif
X#ifdef CPU_TYPE_SERIES5E
X    {  CPU_TYPE_SERIES5E,	"Series5E" },
X#endif
X#ifdef CPU_TYPE_SERIES6
X    {  CPU_TYPE_SERIES6,	"Series6" },
X#endif
X#ifdef CPU_TYPE_KAP_M2
X    {  CPU_TYPE_KAP_M2,		"KAP_M2" },
X#endif
X    { 0 },
X};
X
X/*
X * Device Data Table
X *
X * Compares are done by the length of the string appearing in
X * the first columns.  Therefore, longer names must appear before
X * any shorter names that are not unique.  e.g. "lebuffer" needs to
X * be before "le".
X */
Xextern DEVICE *ProbeCDROMDrive();
Xextern DEVICE *ProbeSPDrive();
X
XDEVDATATAB DevDataTab[] = {
X    /*
X     * Network Interfaces
X     */
X    { "ie",
X	  "Intel 82586 LAN Co-Processor",	
X	  "10Mb/sec Ethernet",				
X	  ProbeNetif },
X    { "ei",
X	  "Solbourne IOASIC AMD Lance Am7990",	
X	  "10Mb/sec Ethernet",
X	  ProbeNetif },
X    { "le",
X	  "AMD Lance Am7990",
X	  "10Mb/sec Ethernet",
X	  ProbeNetif },
X    { "ne",
X	  "Interphase NC400",
X	  "10Mb/sec Ethernet",
X	  ProbeNetif },
X    { "fddi",
X	  "Sun FDDI/DX",
X	  "100Mb/sec dual-attach FDDI",
X	  ProbeNetif },
X    { "bf",
X	  "Sun/Bantam FDDI/S",
X	  "100Mb/sec single-attach FDDI",
X	  ProbeNetif },
X    /*
X     * Disk Drives
X     */
X    { "sd",		NULL,	NULL,	ProbeDiskDrive },
X    { "xd",		NULL,	NULL,	ProbeDiskDrive },
X    { "xl",		NULL,	NULL,	ProbeDiskDrive },
X    { "xy",		NULL,	NULL,	ProbeDiskDrive },
X    { "id",		NULL,	NULL,	ProbeDiskDrive },
X    { "sr",	    "CD-ROM",	NULL,	ProbeCDROMDrive },
X    { "fd",	    "Floppy",	NULL,	ProbeDiskDrive },
X    { "SUNW,fdtwo", "Floppy",	NULL,	ProbeDiskDrive },
X    /*
X     * More detailed descriptions of SCSI adapters
X     */
X    { "esp",
X	  "Generic SCSI interface",	NULL,	
X	  ProbeGeneric, DT_DISKCTLR },
X    { "sc",
X	  "Sun SCSI-2 host adapter",	NULL,	
X	  ProbeGeneric, DT_DISKCTLR },
X    { "si",
X	  "Sun SCSI-3 host adapter",	NULL,	
X	  ProbeGeneric, DT_DISKCTLR },
X    { "sm",
X	  "Sun SCSI-ESP host adapter",	NULL,	
X	  ProbeGeneric, DT_DISKCTLR },
X    { "se",
X	  "Sun SCSI-E host adapter",	NULL,	
X	  ProbeGeneric, DT_DISKCTLR },
X    { "sw",
X	  "Sun SCSI-Weird host adapter",NULL,	
X	  ProbeGeneric, DT_DISKCTLR },
X    /*
X     * Tape drives and tape controllers
X     */
X    { "st",
X	  "SCSI",		NULL,	
X	  ProbeTapeDrive, DT_TAPEDRIVE },
X    { "xtc",
X	  "Xylogics 472",	"1/2 inch tape controller", 
X	  ProbeGeneric, DT_TAPECTLR },
X    { "xt",
X	  "Fujitsu M2444",	"1/2 inch tape drive",	
X	  ProbeTapeDrive, DT_TAPEDRIVE },
X    /*
X     * Frame Buffers
X     */
X    { "bwone",		NULL,	NULL,	ProbeFrameBuffer },
X    { "bwtwo",		NULL,	NULL,	ProbeFrameBuffer },
X    { "cgone",		NULL,	NULL,	ProbeFrameBuffer },
X    { "cgtwo",		NULL,	NULL,	ProbeFrameBuffer },
X    { "cgthree",	NULL,	NULL,	ProbeFrameBuffer },
X    { "cgfour",		NULL,	NULL,	ProbeFrameBuffer },
X    { "cgsix",		NULL,	NULL,	ProbeFrameBuffer },
X    { "cgeight",	NULL,	NULL,	ProbeFrameBuffer },
X    { "cgnine",		NULL,	NULL,	ProbeFrameBuffer },
X    { "cgtwelve",	NULL,	NULL,	ProbeFrameBuffer },
X    { "gpone",		NULL,	NULL,	ProbeFrameBuffer },
X    { "gt",		NULL,	NULL,	ProbeFrameBuffer },
X    { "taac",		NULL,	NULL,	ProbeFrameBuffer },
X    { "vx",		NULL,	NULL,	ProbeFrameBuffer },
X    /*
X     * Bus types
X     */
X    { "vme",	"VME Bus",			NULL,ProbeGeneric,DT_BUS },
X    { "sbus",	"SBus",				NULL,ProbeGeneric,DT_BUS },
X    { "obio",	"On Board I/O",			NULL,ProbeGeneric,DT_BUS },
X    { "obmem",	"On Board Memory",		NULL,ProbeGeneric,DT_BUS },
X    { "iommu",	"I/O Memory Management Unit",	NULL,ProbeGeneric,DT_BUS },
X    /*
X     * Psuedo and Generic devices.
X     */
X    { OBP_SYSBOARD,	"System Board",	NULL,ProbeGeneric,DT_GENERIC },
X    { "sbi",		"SBus Interface",NULL,ProbeGeneric,DT_GENERIC },
X    { "bootbus",	"Boot Bus",	NULL,ProbeGeneric,DT_BUS },
X    { "cpu-unit",	"CPU Unit",	NULL,ProbeGeneric,DT_BUS },
X    { "io-unit",	"I/O Unit",	NULL,ProbeGeneric,DT_BUS },
X    { "mem-unit",	"Memory Unit",	NULL,ProbeGeneric,DT_BUS },
X    { "dma",		"DMA Driver",	NULL,ProbeGeneric,DT_GENERIC },
X    { "lebuffer", 	"Buffered LANCE Ethernet",	NULL,	
X	  				ProbeGeneric,	DT_GENERIC },
X    { "espdma",		"SCSI DMA",			NULL,	
X	  				ProbeGeneric,	DT_PSEUDO },
X    { "ledma",		"LANCE Ethernet DMA",		NULL,	
X					ProbeGeneric,	DT_PSEUDO },
X    { "openprom", 	"Open Boot PROM",		NULL,	
X					ProbeGeneric,	DT_PSEUDO },
X    { "pn",		"IPI Bus Connector",		NULL,
X					ProbeGeneric,	DT_GENERIC,DDT_LENCMP},
X    { "SUNW,pn",	"IPI Bus Connector",		NULL,
X					ProbeGeneric,	DT_GENERIC,DDT_LENCMP},
X    { "ipi3sc", 	"IPI-3 String Controller",	NULL,
X					ProbeGeneric,	DT_GENERIC },
X    /*
X     * Miscellaneous devices
X     */
X    { "audio",
X	  "AM79C30A DSC",	
X	  "telephone quality audio",
X	  ProbeGeneric, DT_GENERIC },
X    { "zs",
X	  "Zilog 8530",	
X	  "serial communications chip",
X	  ProbeGeneric, DT_GENERIC },
X    { "mti",
X	  "ALM-1 (Systech MTI-1600)",	
X	  "16-line terminal multiplexer",
X	  ProbeGeneric, DT_GENERIC },
X    { "mcp",
X	  "ALM-2 (Sun MCP/ALM)",	
X	  "16-line terminal multiplexer",
X	  ProbeGeneric, DT_GENERIC },
X    { "fpa",
X	  "Sun-3 FPA",	
X	  "Weitek-based floating point accelerator",
X	  ProbeGeneric, DT_GENERIC },
X    { "des",
X	  "AmZ8068 Data Ciphering Processor",
X	  "NBS Data Encryption Standard",
X	  ProbeGeneric, DT_GENERIC },
X    { "vpc",
X	  "Systech VPC-2200",	
X	  "Versatec & Centronics printer/plotter interface",
X	  ProbeGeneric, DT_GENERIC },
X    { "pp",
X	  "Parallel Port",
X	  "Centronics-compatible parallel printer port",
X	  ProbeGeneric, DT_GENERIC },
X    { "SUNW,bpp",
X	  "Sun Bidirectional Parallel Port",
X	  NULL,
X	  ProbeGeneric, DT_GENERIC },
X    { "SUNW,lpvi",
X	  "Sun Sbus Printer Card",
X	  "laser printer video interface",
X	  ProbeGeneric, DT_GENERIC },
X    { "SUNW,DBRIe",
X	  "Sun SpeakerBox & Dual Basic Rate ISDN",
X	  "ISDN and Multimedia Codec",
X	  ProbeGeneric, DT_GENERIC },
X    { "db",
X	  "Sun Dial Box",
X	  NULL,
X	  ProbeGeneric, DT_GENERIC },
X    { "pr",
X	  "PrestoServe",
X	  "file system accelerator",
X	  ProbeGeneric, DT_GENERIC },
X    /*
X     * Third Party devices
X     */
X    { "GNP,DEI",
X	  "GNP DEI Serial Expander",	
X	  "8 to 32 port terminal multiplexer",
X	  ProbeGeneric, DT_GENERIC },
X    /* 
X     * Tadpole devices
X     */
X    { "SPARCbook",	NULL,	NULL,	ProbeGeneric, 	DT_NONE, DDT_LENCMP },
X    { "nice",
X	  "NICE Ethernet Co-processor",
X	  "10Mb/sec Ethernet",
X	  ProbeNetif },
X    { "par",
X	  "Parallel Port",
X	  "Centronics-compatible parallel printer port", 
X	  ProbeGeneric, DT_GENERIC },
X    { "modem",
X	  NULL,
X	  "Hayes compatible modem",
X	  ProbeGeneric, DT_GENERIC },
X    { "mouse",
X	  NULL,
X	  "IBM compatible mouse",
X	  ProbeGeneric, DT_GENERIC },
X    { "urt",
X	  NULL,
X	  "serial communications chip",	
X	  ProbeGeneric, DT_GENERIC },
X    { "vga",	NULL,	NULL,		ProbeFrameBuffer },
X    { "PC8",	NULL,	"8-bit",	ProbeGeneric, DT_BUS, DDT_NOUNIT },
X    { "PC16",	NULL,	"16-bit",	ProbeGeneric, DT_BUS, DDT_NOUNIT },
X    /*
X     * Auspex devices
X     */
X    { "cpm",
X	  "Clearpoint VME memory",
X	  "Clearpoint VME memory board used as primary memory", 
X	  ProbeGeneric, DT_GENERIC },
X    { "apm",
X	  "Auspex Primary Memory",
X	  "Auspex VME memory board used as primary memory", 
X	  ProbeGeneric, DT_GENERIC },
X    { "aep",
X	  "Auspex Ethernet Processor",
X	  "Auspex Ethernet Processor board", 
X	  ProbeGeneric, DT_GENERIC },
X    { "ae",
X	  "Ethernet Processor Lance Am7990",
X	  "10MB/sec Ethernet", 
X	  ProbeNetif },
X    { "afp",
X	  "Auspex File Processor",
X	  "Auspex File Processor board", 
X	  ProbeGeneric, DT_GENERIC },
X    { "asp",
X	  "Auspex Storage Processor",
X	  "Auspex Storage Processor board", 
X	  ProbeGeneric, DT_GENERIC },
X    { "ad",	NULL,	NULL, ProbeSPDrive },
X    { 0 },
X};
X
X#if	defined(HAVE_OPENPROM)
X/*
X * Open Boot PROM device tables
X */
XDEVDATATAB OBPdevices[] = {
X    { "cpu",		NULL, NULL,	OBPprobeCPU },
X    { 0 },
X};
X
X/*
X * Types of CPUs.
X *
X * The first element of each entity is the clock speed (in Mhz) of the
X * processor.  That combined with the second element determines what
X * the actual type of processor module is present (described by the
X * third element).
X */
XNAMETAB CPUtypes[] = {
X    { 40,	"Cypress,CY605",	"Model 100 SPARCmodule" },
X    { 33,	"TI,TMS390Z50",		"SuperSPARC Model 20 SPARCmodule" },
X    { 36,	"TI,TMS390Z50",		"SuperSPARC Model 30 SPARCmodule" },
X    { 40,	"TI,TMS390Z50",		"SuperSPARC Model 40 SPARCmodule" },
X    { 40,	"TI,TMS390Z55",		"SuperSPARC Model 41 SPARCmodule" },
X    { 50,	"TI,TMS390Z55",		"SuperSPARC Model 51 SPARCmodule" },
X    { 0,	"TI,TMS390S10",		"microSPARC" },
X    { 0 },
X};
X
X/*
X * Table of OBP keywords that we want to provide a more
X * descriptive text for.
X */
XNAMETAB OBPinfo[] = {
X    { 0, "dblbuf",			"Double Buffered" },
X    { 0, "iocache?",			"I/O Cache" },
X    { 0, "mid",				"Module ID" },
X    { 0, "mmu-nctx",			"Number of MMU Contexts" },
X    { 0, "mmu-npmg",			"Number of MMU PMGs" },
X    { 0, "multiple-cable-i/f?",		"Multiple Cable Interface" },
X    { 0, "n-xdbus",			"Number of XDbus's" },
X    { 0, "ncaches",			"Number of Caches" },
X    { 0, "nmmus",			"Number of MMUs" },
X    { 0, "scsi-initiator-id",		"SCSI Initiator ID" },
X    { 0, "sparc-version",		"SPARC Version" },
X    { 0, "vac-linesize",		"Virtual Address Cache Line Size" },
X    { 0, "vac-size",			"Virtual Address Cache Size" },
X    { 0, "vac_hwflush",			"Virtual Address Cache HW Flush" },
X    { 0 },
X};
X#endif	/* HAVE_OPENPROM */
X
X/*
X * Table of known Disk Controllers for Suns and other machines running
X * SunOS.
X * XXX - Auspex doesn't define DKC_AUSPEX_SP in current releases,
X * so we'll forcibly define it here for now.  It will be defined as 99
X * in a future release.  Put it at the end of the table, so that if
X * somebody else also uses 99, they get seen first if this is built
X * for their machine.
X */
X#ifndef DKC_AUSPEX_SP
X#define	DKC_AUSPEX_SP	99
X#endif
X
XDKCTLRTAB DkCtlrTab[] = {
X/*
X * Sun
X */
X#if 	defined(DKC_XY450) && defined(XY_READ)
X    {  DKC_XY450,	"Xylogics 450/451 SMD",		XY_READ },
X#endif
X#if 	defined(DKC_ACB4000) && defined(SC_READ)
X    {  DKC_ACB4000,	"Adaptec ACB4000 SCSI",		SC_READ },
X#endif
X#if	defined(DKC_MD21) && defined(SC_READ)
X    {  DKC_MD21,	"Emulex MD21 SCSI",		SC_READ },
X#endif
X#if	defined(DKC_NCRFLOPPY) && defined(SC_READ)
X    {  DKC_NCRFLOPPY,	"NCR Floppy SCSI",		SC_READ },
X#endif
X#if	defined(DKC_XD7053) && defined(XD_READ)
X    {  DKC_XD7053,	"Xylogics 7053/753 SMD",	XD_READ },
X#endif
X#if	defined(DKC_SVx) && defined(XL_READ)
X    {  DKC_SVx,		"Xylogics SV-{67}8xx IPI",	XL_READ },
X#endif
X#if	defined(DKC_SMSFLOPPY) && defined(SC_READ)
X    {  DKC_SMSFLOPPY,	"SMS Floppy SCSI",		SC_READ },
X#endif
X#if	defined(DKC_SCSI_CCS) && defined(SC_READ)
X    {  DKC_SCSI_CCS,	"SCSI CCS",			SC_READ },
X#endif
X#if	defined(DKC_CCS) && defined(SC_READ)
X    {  DKC_CCS,		"CCS SCSI",			SC_READ },
X#endif
X#if	defined(DKC_NEC765)
X    {  DKC_NEC765,	"NEC 765 Floppy",		-1 },
X#endif
X#if	defined(DKC_INTEL82072)
X    {  DKC_INTEL82072,	"Intel 82072 Floppy",	 	-1 },
X#endif
X#if	defined(DKC_INTEL82077)
X    {  DKC_INTEL82077,	"Intel 82077 Floppy",	 	-1 },
X#endif
X#if	defined(DKC_PANTHER) && defined(IP_READ)
X    {  DKC_PANTHER,	"Sun ISP-80 (Panther) IPI-2",	IP_READ },
X#endif
X#if 	defined(DKC_CDROM)
X    {  DKC_CDROM,	"CDROM",			-1 },
X#endif
X#if 	defined(DKC_WDC2880)
X    {  DKC_WDC2880,	"WDC 2880",			-1 },
X#endif
X#if 	defined(DKC_DSD5215)
X    {  DKC_DSD5215,	"DSD 5215",			-1 },
X#endif
X#if 	defined(DKC_MD)
X    {  DKC_MD,		"Meta-Disk (Virtual Disk) Driver",		-1 },
X#endif
X#if 	defined(DKC_CDC_9057)
X    {  DKC_CDC_9057,	"CDC 9057-321 (CM-3) IPI String Controller",	-1 },
X#endif
X#if 	defined(DKC_FJ_M1060)
X    {  DKC_FJ_M1060,	"Fujitsu/Intellistor M1060 IPI-3 SC",		-1 },
X#endif
X
X/*
X * Solbourne
X */
X#if	defined(DKC_XD753_IPI) && defined(XD_READ)
X    {  DKC_XD753_IPI,	"Xylogics SV-{67}800 IPI",	XD_READ },
X#endif
X#if 	defined(DKC_IOASIC) && defined(SC_READ)
X    {  DKC_IOASIC,	"IOASIC SCSI",			SC_READ },
X#endif
X#if 	defined(DKC_RF3500) && defined(SC_READ)
X    {  DKC_RF3500,	"Ciprico RF-3500 SCSI",		SC_READ },
X#endif
X#if 	defined(DKC_VSCSI) && defined(SC_READ)
X    {  DKC_VSCSI,	"Interphase V/SCSI",		SC_READ },
X#endif
X
X/*
X * Tadpole
X */
X#if	defined(TADPOLE)
X    { 19,		"PC IDE",			IDE_READ },
X#endif	/* TADPOLE */
X
X/*
X * Auspex
X */
X#if	defined(DKC_AUSPEX_SP) && defined(SC_READ)
X    {  DKC_AUSPEX_SP,	"Auspex Storage Processor",	SC_READ },
X#endif
X    { 0 },
X};
X
X/*
X * Table of known Sun Frame Buffers
X */
XNAMETAB FBTab[] = {
X#ifdef FBTYPE_SUN2BW
X    {  FBTYPE_SUN2BW,		"Black & White memory",		"bwtwo" },
X#endif
X#ifdef FBTYPE_SUN2COLOR
X    {  FBTYPE_SUN2COLOR,	"Color Graphics w/rasterop", 	"cgtwo" },
X#endif
X#ifdef FBTYPE_SUN2GP
X    {  FBTYPE_SUN2GP,		"GS Graphics Processor", 	"cgtwelve" },
X#endif
X#ifdef FBTYPE_SUN5COLOR
X    {  FBTYPE_SUN5COLOR,	"Sun-386i 8-bit Accelerated Color", "cgsix" },
X#endif
X#ifdef FBTYPE_SUN3COLOR
X    {  FBTYPE_SUN3COLOR,	"8-bit Color",			"cgthree" },
X#endif
X#ifdef FBTYPE_MEMCOLOR
X    {  FBTYPE_MEMCOLOR,		"B&W memory overlay plane",	"bwtwo" },
X#endif
X#ifdef FBTYPE_SUN4COLOR
X    {  FBTYPE_SUN4COLOR,	"Color memory w/overlay",	"cgfour" },
X#endif
X#ifdef FBTYPE_SUNFAST_COLOR
X    {  FBTYPE_SUNFAST_COLOR,	"GX 8-bit Accelerated Color",	"cgsix" },
X#endif
X#ifdef FBTYPE_SUNROP_COLOR
X    {  FBTYPE_SUNROP_COLOR,	"24-bit Color w/rasterop",	"cgtwelve" },
X#endif
X#ifdef FBTYPE_SUNFB_VIDEO
X    {  FBTYPE_SUNFB_VIDEO,	"Video Mixing",			"sunfb_video"},
X#endif
X#ifdef FBTYPE_SUNGIFB
X    {  FBTYPE_SUNGIFB,		"Medical Imaging",		"sungifb" },
X#endif
X#ifdef FBTYPE_SUNGPLAS
X    {  FBTYPE_SUNGPLAS,		"Plasma Panel",			"sungplas" },
X#endif
X#ifdef FBTYPE_SUNGP3
X    {  FBTYPE_SUNGP3,		"24-bit Accelerated GPSI Color", "cgtwelve" },
X#endif
X#ifdef FBTYPE_SUNGT
X    {  FBTYPE_SUNGT,		"24-bit Color Graphics Accelerator", "gt" },
X#endif
X/*
X * Tadpole frame buffer's
X */
X#if	defined(TADPOLE)
X#ifdef FBTYPE_NOTSUN1
X    {  FBTYPE_NOTSUN1,		"VGA Graphics Card",		NULL },
X#endif
X#endif	/* TADPOLE */
X    { 0 },
X};
X
X/*
X * Magnetic Tape Info.
X *
X * This info is based on <sys/mtio.h>.  It would be nice to just
X * use that info, but not all systems have MT_TAPE_INFO.
X */
XNAMETAB MtInfo[] = {
X#ifdef MT_ISCPC
X    {  MT_ISCPC,		"TapeMaster 1/2-inch" },
X#endif
X#ifdef MT_ISXY
X    {  MT_ISXY,			"Xylogics 472 1/2-inch" },
X#endif
X#ifdef MT_ISAR
X    {  MT_ISAR,			"Archive QIC-11" },
X#endif
X#ifdef MT_ISSYSGEN11
X    {  MT_ISSYSGEN11,		"Sysgen QIC-11" },
X#endif
X#ifdef MT_ISSYSGEN
X    {  MT_ISSYSGEN,		"Sysgen QIC-24" },
X#endif
X#ifdef MT_ISMT02
X    {  MT_ISMT02,		"Emulex MT-02 QIC-24" },
X#endif
X#ifdef MT_ISVIPER1
X    {  MT_ISVIPER1,		"Archive QIC-150" },
X#endif
X#ifdef MT_ISWANGTEK1
X    {  MT_ISWANGTEK1,		"Wangtek QIC-150" },
X#endif
X#ifdef MT_ISKENNEDY
X    {  MT_ISKENNEDY,		"Kennedy 9612 1/2-inch" },
X#endif
X#ifdef MT_ISHP
X    {  MT_ISHP,			"HP 88780 1/2-inch" },
X#endif
X#ifdef MT_ISEXABYTE
X    {  MT_ISEXABYTE,		"Exabyte EXB-8200 8mm" },
X#endif
X#ifdef MT_ISEXB8500
X    {  MT_ISEXB8500,		"Exabyte EXB-8500 8mm" },
X#endif
X#ifdef MT_ISWANGDAT
X    {  MT_ISWANGDAT,		"WangDAT 3.81mm" },
X#endif
X#ifdef MT_ISWANGTHS
X    {  MT_ISWANGTHS,		"Wangtek 4mm RDAT" },
X#endif
X#ifdef MT_ISPHYTHON
X    {  MT_ISPHYTHON,		"Archive Python 4mm Helical Scan" },
X#endif
X    { 0 },
X};
X
X/*
X * Part information
X */
XPARTINFO PARTtable[] = {
X    { "SUNW,500-2015", "FSBE/S", 	"Fast SCSI Buffered Ethernet/Sbus", },
X    { "SUNW,500-1902", "DSBE/S", 	"Differential SCSI Buffered Ethernet/Sbus", },
X    { "SUNW,500-1869", "SBE/S",		"SCSI Buffered Ethernet/Sbus", },
X    { "SUNW,520-1511", "SPC",		"Sun Serial Parallel Controller", },
X    { 0 },
X};
END_OF_FILE
if test 20858 -ne `wc -c <'info-sunos.c'`; then
    echo shar: \"'info-sunos.c'\" unpacked with wrong size!
fi
# end of 'info-sunos.c'
fi
if test -f 'os-sunos4.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'os-sunos4.c'\"
else
echo shar: Extracting \"'os-sunos4.c'\" \(26814 characters\)
sed "s/^X//" >'os-sunos4.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: os-sunos4.c,v 1.15 1994/02/11 18:30:14 mcooper Exp mcooper $";
X#endif
X
X/*
X * SunOS 4.x specific routines
X */
X
X#include "defs.h"
X#include <nlist.h>
X#include <sys/stat.h>
X#include <sys/mtio.h>
X
X/*
X * Characters for disk partitions
X */
Xchar 			PartChars[] = "abcdefgh";
X
X/*
X * CPU (model) symbol
X */
Xchar 			CpuSYM[] = "_cpu";
X
X/*
X * Name of generic magnetic tape device.
X */
X#define MTNAME		"mt"
X
X/*
X * Generally used variables
X */
Xstatic kvm_t 		       *kd = NULL;
Xstatic struct stat 		StatBuf;
Xstatic DEVICE 		       *Device;
Xstatic char 			Buf[BUFSIZ];
Xextern char		        RomVecSYM[];
XNAMETAB			       *GetFBTab();
Xstatic int			OpenPROMTraverse();
X
X#if	defined(HAVE_MAINBUS)
X/*
X * Build a device tree by searching the MainBus
X */
X
X#define DV_SIZE	(sizeof(struct mb_device))
X#define DR_SIZE (sizeof(struct mb_driver))
Xextern char		 	MainBusSYM[];
X
X/*
X * Build device tree by looking at mainbus (mb) devices
X */
Xextern int BuildMainBus(TreePtr)
X    DEVICE 		       **TreePtr;
X{
X    static struct nlist		nlistbuf;
X    struct nlist	       *nlptr;
X    static struct mb_device 	Device;
X    static struct mb_driver 	Driver;
X    static char 		CtlrName[BUFSIZ], DevName[BUFSIZ];
X    static DEVDATA 		DevData;
X    u_long 			Addr, DeviceAddr;
X    DEVICE 		       *Dev;
X
X    /*
X     * Read table address from kernel
X     */
X    if (!(kd = KVMopen()))
X	return(-1);
X
X    if ((nlptr = KVMnlist(kd, MainBusSYM, &nlistbuf)) == NULL)
X	return(-1);
X
X    if (CheckNlist(nlptr))
X	return(-1);
X
X    /*
X     * Read each device table entry.  A NULL device.mb_driver
X     * indicates that we're at the end of the table.
X     */
X    for (DeviceAddr = nlptr->n_value; DeviceAddr; 
X	 DeviceAddr += DV_SIZE) {
X
X	/*
X	 * Read this device
X	 */
X	if (KVMread(kd, DeviceAddr, (char *) &Device, DV_SIZE, FALSE)) {
X	    if (Debug) 
X		Error("Cannot read mainbus device from address 0x%x.", 
X		      DeviceAddr);
X	    KVMclose(kd);
X	    return(-1);
X	}
X
X	/*
X	 * See if we're done.
X	 */
X	if (!Device.md_driver)
X	    break;
X
X	/*
X	 * Read the driver structure
X	 */
X	Addr = (u_long) Device.md_driver;
X	if (KVMread(kd, Addr, (char *) &Driver, DR_SIZE, FALSE)) {
X	    if (Debug) 
X		Error("Cannot read driver for mainbus address 0x%x.", Addr);
X	    continue;
X	}
X
X	/*
X	 * Get the device name
X	 */
X	if (Addr = (u_long) Driver.mdr_dname) {
X	    if (KVMread(kd, Addr, (char *) DevName, sizeof(DevName), TRUE)) {
X		if (Debug)
X		    Error("Cannot read device name from address 0x%x.", Addr);
X		continue;
X	    }
X	} else
X	    DevName[0] = C_NULL;
X
X	/*
X	 * Get the controller name
X	 * XXX - not if "Device.md_ctlr" is -1; work around botch
X	 * in current Auspex releases, where some boards (File Processor,
X	 * Primary Memory, etc.) have both a device and a controller name,
X	 * despite the fact that there's not both a controller and a
X	 * set of 1 or more devices.
X	 */
X	if ((Addr = (u_long) Driver.mdr_cname) && Device.md_ctlr != -1) {
X	    if (KVMread(kd, Addr, (char *) CtlrName, sizeof(CtlrName), TRUE)) {
X		if (Debug)
X		    Error("Cannot read controller name from address 0x%x.", 
X			  Addr);
X		continue;
X	    }
X	} else
X	    CtlrName[0] = C_NULL;
X
X	/* Make sure devdata is clean */
X	bzero(&DevData, sizeof(DEVDATA));
X
X	/* Set what we know */
X	if (DevName[0]) {
X	    DevData.dd_devname = strdup(DevName);
X	    DevData.dd_devunit = Device.md_unit;
X	}
X	if (CtlrName[0]) {
X	    DevData.dd_ctlrname = strdup(CtlrName);
X	    DevData.dd_ctlrunit = Device.md_ctlr;
X	}
X	/* 
X	 * Mainbus devices such, as SCSI targets, may not exist
X	 * but the controller reports them as present
X	 */
X	if (Device.md_alive)
X	    DevData.dd_flags |= DD_MAYBE_ALIVE;
X
X	if (Debug)
X	    printf("MainBus: Found \"%s\" (Unit %d) on \"%s\" (Unit %d) %s\n", 
X		   DevData.dd_devname, DevData.dd_devunit,
X		   DevData.dd_ctlrname, DevData.dd_ctlrunit,
X		   (DevData.dd_flags & DD_MAYBE_ALIVE) ? "[MAYBE-ALIVE]" : "");
X
X	/* Probe and add device */
X	if (Dev = ProbeDevice(&DevData, TreePtr))
X	    AddDevice(Dev, TreePtr);
X    }
X
X    KVMclose(kd);
X    return(0);
X}
X#endif	/* HAVE_MAINBUS */
X
X/*
X * Get disk info structure.
X */
Xstatic DKinfo *GETdk_info(d, file)
X    int 			d;
X    char 		       *file;
X{
X    static DKinfo 		dk_info;
X
X    if (ioctl(d, DKIOCINFO, &dk_info) < 0) {
X	if (Debug) Error("%s: DKIOCINFO: %s.", file, SYSERR);
X	return(NULL);
X    }
X
X    return(&dk_info);
X}
X
X/*
X * Get disk configuration structure.
X */
Xstatic DKconf *GETdk_conf(d, file, disktype)
X    int 			d;
X    char 		       *file;
X    int				disktype;
X{
X    static DKconf 		dk_conf;
X
X    if (disktype == DKT_CDROM) {
X	if (Debug) 
X	    Error("%s: Get CDROM disk configuration info is not supported.",
X		  file);
X	return((DKconf *) NULL);
X    }
X
X    if (ioctl(d, DKIOCGCONF, &dk_conf) < 0) {
X	if (Debug) Error("%s: DKIOCGCONF: %s.", file, SYSERR);
X	return((DKconf *) NULL);
X    }
X
X    return(&dk_conf);
X}
X
X/*
X * Get disk geometry structure.
X */
Xstatic DKgeom *GETdk_geom(d, file, disktype)
X    int 			d;
X    char 		       *file;
X    int				disktype;
X{
X    static DKgeom 		dk_geom;
X
X    if (disktype == DKT_CDROM) {
X	if (Debug) 
X	    Error("%s: Get CDROM disk geometry info is not supported.", file);
X	return((DKgeom *) NULL);
X    }
X
X    if (ioctl(d, DKIOCGGEOM, &dk_geom) < 0) {
X	if (Debug) Error("%s: DKIOCGGEOM: %s.", file, SYSERR);
X	return((DKgeom *) NULL);
X    }
X
X    return(&dk_geom);
X}
X
X/*
X * Get disk type structure.
X */
Xstatic DKtype *GETdk_type(d, file)
X    int 			d;
X    char 		       *file;
X{
X    static DKtype 		dk_type;
X
X    if (ioctl(d, DKIOCGTYPE, &dk_type) < 0) {
X	if (errno != ENOTTY)
X	    if (Debug) Error("%s: DKIOCGTYPE: %s.", file, SYSERR);
X	return(NULL);
X    }
X
X    return(&dk_type);
X}
X
X/*
X * Check the checksum of a disklabel.
X */
Xstatic int DkLblCheckSum(DkLabel)
X    DKlabel 		       *DkLabel;
X{
X    register short 	       *Ptr, Sum = 0;
X    register short 		Count;
X
X    Count = (sizeof (DKlabel)) / (sizeof (short));
X    Ptr = (short *)DkLabel;
X
X    /*
X     * Take the xor of all the half-words in the label.
X     */
X    while (Count--)
X	Sum ^= *Ptr++;
X
X    /*
X     * The total should be zero for a correct checksum
X     */
X    return(Sum);
X}
X
X/*
X * Get label information from label on disk.
X * The label is stored in the first sector of the disk.
X * We use the driver specific "read" flag with the DKIOCSCMD
X * ioctl to read the first sector.  There should be a special
X * ioctl to just read the label.
X */
Xstatic DKlabel *GETdk_label(d, file, dk_info, disktype)
X    int 			d;
X    char 		       *file;
X    DKinfo	 	       *dk_info;
X    int				disktype;
X{
X    struct dk_cmd 		dk_cmd;
X    static DKlabel	 	dk_label;
X    DKCTLRTAB	 	       *pct;
X
X    if (!file || !dk_info)
X	return((DKlabel *) NULL);
X
X    /*
X     * CDROM's don't support DKIOCSCMD and doing a DKIOCSCMD on
X     * a CDROM drive can sometimes crash a system.
X     */
X    if (disktype == DKT_CDROM) {
X	if (Debug) Error("%s: Reading CDROM labels is not supported.", file);
X	return((DKlabel *) NULL);
X    }
X
X    if (!(pct = GetDkCtlrTab((int) dk_info->dki_ctype))) {
X	Error("Controller type %d is unknown.", 
X	      dk_info->dki_ctype);
X	return((DKlabel *) NULL);
X    }
X
X    if (pct->ct_rdcmd < 0) {
X	if (Debug)
X	    Error("Read block on controller type \"%s\" is unsupported.",
X		  pct->ct_model);
X	return((DKlabel *) NULL);
X    }
X
X    bzero((char *) &dk_cmd, sizeof(dk_cmd));
X    dk_cmd.dkc_cmd = pct->ct_rdcmd;
X    dk_cmd.dkc_flags = DK_SILENT | DK_ISOLATE;
X    dk_cmd.dkc_blkno = (daddr_t)0;
X    dk_cmd.dkc_secnt = 1;
X    dk_cmd.dkc_bufaddr = (char *) &dk_label;
X    dk_cmd.dkc_buflen = SECSIZE;
X
X    if (ioctl(d, DKIOCSCMD, &dk_cmd) < 0) {
X	if (Debug) Error("%s: DKIOCSCMD: %s.", file, SYSERR);
X	return((DKlabel *) NULL);
X    }
X
X    if (dk_label.dkl_magic != DKL_MAGIC) {
X	Error("%s: Disk not labeled.", file);
X	return((DKlabel *) NULL);
X    }
X
X    if (DkLblCheckSum(&dk_label)) {
X	Error("%s: Bad label checksum.", file);
X	return((DKlabel *) NULL);
X    }
X
X    return(&dk_label);
X}
X
X/*
X * Get the name of a disk (i.e. sd0).
X */
Xstatic char *GetDiskName(name, dk_conf, dk_info)
X    char 		       *name;
X    DKconf 		       *dk_conf;
X    DKinfo 		       *dk_info;
X{
X    if (!dk_conf || !dk_info) {
X	if (name)
X	    return(name);
X	return((char *) NULL);
X    }
X
X#if	defined(DKI_HEXUNIT)
X    if (FLAGS_ON(dk_info->dki_flags, DKI_HEXUNIT))
X	(void) sprintf(Buf, "%s%3.3x", dk_conf->dkc_dname, dk_conf->dkc_unit);
X    else
X#endif 	/* DKI_HEXUNIT */
X	(void) sprintf(Buf, "%s%d", dk_conf->dkc_dname, dk_conf->dkc_unit);
X
X    return(strdup(Buf));
X}
X
X/*
X * Get the name of the controller for a disk.
X */
Xstatic char *GetDkCtlrName(dk_conf)
X    DKconf 		       *dk_conf;
X{
X    if (!dk_conf)
X	return((char *) NULL);
X
X    (void) sprintf(Buf, "%s%d", dk_conf->dkc_cname, dk_conf->dkc_cnum);
X
X    return(strdup(Buf));
X}
X
X/*
X * Get the disk controller model name from a disk.
X */
Xstatic char *GetDkCtlrModel(dk_info)
X    DKinfo	 	       *dk_info;
X{
X    DKCTLRTAB	 	       *pct;
X
X    if (!dk_info)
X	return((char *) NULL);
X
X    if (!(pct = GetDkCtlrTab(dk_info->dki_ctype)))
X	return(NULL);
X
X    return(pct->ct_model);
X}
X
X/*
X * Get a disk controller device from disk info.
X */
Xstatic DEVICE *GetDkCtlrDevice(DevData, dk_info, dk_conf)
X    DEVDATA 		       *DevData;
X    DKinfo	 	       *dk_info;
X    DKconf 		       *dk_conf;
X{
X    DEVICE 		       *MkMasterFromDevData();
X    DEVICE 		       *dkctlr;
X
X    if ((dkctlr = NewDevice(NULL)) == NULL)
X	return((DEVICE *) NULL);
X
X    bzero((char *) dkctlr, sizeof(*dkctlr));
X
X    dkctlr->dv_type = DT_DISKCTLR;
X
X    /*
X     * Get name of controller from devdata if available
X     */
X    if (DevData && DevData->dd_ctlrname)
X	dkctlr = MkMasterFromDevData(DevData);
X
X    if (dk_conf) {
X	if (!dkctlr->dv_name) {
X	    dkctlr->dv_name = GetDkCtlrName(dk_conf);
X	    dkctlr->dv_unit = dk_conf->dkc_cnum;
X	}
X	dkctlr->dv_addr = dk_conf->dkc_addr;
X	dkctlr->dv_prio = dk_conf->dkc_prio;
X	dkctlr->dv_vec = dk_conf->dkc_vec;
X    }
X
X    if (dk_info)
X	dkctlr->dv_model = GetDkCtlrModel(dk_info);
X
X    return(dkctlr);
X}
X
X/*
X * Get disk label info from the extracted dk_label info.
X */
Xstatic char *GetDiskLabel(dk_label)
X    DKlabel 		       *dk_label;
X{
X    register char 	       *cp;
X    char		       *label;
X
X    if (!dk_label)
X	return((char *) NULL);
X
X    label = strdup(dk_label->dkl_asciilabel);
X
X    /*
X     * The label normally has geometry information in it we don't want
X     * to see, so we trim out anything starting with " cyl".
X     */
X    for (cp = label; cp && *cp; ++cp)
X	if (*cp == ' ' && strncasecmp(cp, " cyl", 4) == 0)
X	    *cp = C_NULL;
X
X    return(label);
X}
X
X/*
X * Get filesystem mount info for a partition.
X */
Xstatic char *GetMountInfo(name, part)
X    char 		       *name;
X    char 		       *part;
X{
X    static FILE 	       *mountedFP = NULL;
X    static FILE 	       *mnttabFP = NULL;
X    struct mntent 	       *mntent;
X    char 		       *file;
X
X    if (!name)
X	return((char *) NULL);
X
X    file = GetCharFile(name, part);
X
X    /*
X     * First try currently mounted filesystems (/etc/mtab)
X     */
X    if (!mountedFP) {
X	if ((mountedFP = setmntent(MOUNTED, "r")) == NULL) {
X	    Error("%s: Cannot open for reading: %s.", MOUNTED, SYSERR);
X	    return(NULL);
X	}
X    } else
X	rewind(mountedFP);
X
X    while (mntent = getmntent(mountedFP))
X	if (mntent->mnt_fsname && EQ(mntent->mnt_fsname, file))
X	    return(mntent->mnt_dir);
X
X    /*
X     * Now try static information (/etc/fstab)
X     */
X    if (!mnttabFP) {
X	if ((mnttabFP = setmntent(MNTTAB, "r")) == NULL) {
X	    Error("%s: Cannot open for reading: %s.", MNTTAB, SYSERR);
X	    return(NULL);
X	}
X    } else
X	rewind(mnttabFP);
X
X    while (mntent = getmntent(mnttabFP))
X	if (mntent->mnt_fsname && EQ(mntent->mnt_fsname, file))
X	    return(mntent->mnt_dir);
X
X    return((char *) NULL);
X}
X
X/*
X * Extract the disk partition info from a disk.
X */
Xstatic DISKPART *ExtractDiskPart(name, part, dk_conf, dk_geom)
X    char 		       *name;
X    char 		       *part;
X    DKconf	 	       *dk_conf;
X    DKgeom	 	       *dk_geom;
X{
X    static DISKPART 		diskpart;
X    struct dk_map 		dk_map;
X    char 		       *file;
X    char 		       *p;
X    int 			d;
X
X    if (!name || !dk_conf || !dk_geom)
X	return((DISKPART *) NULL);
X
X    file = GetRawFile(name, part);
X
X    if (stat(file, &StatBuf) != 0) {
X	if (Debug) Error("%s: No such partition.", file);
X	return((DISKPART *) NULL);
X    }
X
X    if ((d = open(file, O_RDONLY)) < 0) {
X	if (Debug)
X	    Error("%s: Cannot open for read: %s.", file, SYSERR);
X	return((DISKPART *) NULL);
X    }
X
X    if (ioctl(d, DKIOCGPART, &dk_map) != 0) {
X	Error("%s: Cannot extract partition info: %s.", 
X		file, SYSERR);
X	return((DISKPART *) NULL);
X    }
X 
X    (void) close(d);
X
X    /*
X     * Skip empty partitions
X     */
X    if (!dk_map.dkl_nblk) {
X	if (Debug) Error("%s: partition has no size.", file);
X	return((DISKPART *) NULL);
X    }
X
X    bzero((char *) &diskpart, sizeof(DISKPART));
X
X    diskpart.dp_name = strdup(part);
X
X    if (p = GetMountInfo(name, part))
X	diskpart.dp_mnt = strdup(p);
X    /* 
X     * If this is the "b" partition on the root device, 
X     *  then assume it's swap 
X     */
X    else if (dk_conf->dkc_unit == 0 && strcmp(part, "b") == 0)
X	diskpart.dp_mnt = "swap";
X
X    diskpart.dp_stsect = dk_map.dkl_cylno *
X	(dk_geom->dkg_nhead * dk_geom->dkg_nsect);
X    diskpart.dp_nsect = dk_map.dkl_nblk;
X
X    return(&diskpart);
X}
X
X/*
X * Translate disk partition information from basic
X * extracted disk info.
X */
Xstatic DISKPART *GetDiskPart(name, dk_conf, dk_geom)
X    char 		       *name;
X    DKconf 		       *dk_conf;
X    DKgeom 		       *dk_geom;
X{
X    extern char 		PartChars[];
X    register DISKPART 	       *pdp, *dp;
X    register int 		i;
X    static char 		pname[2];
X    DISKPART 		       *base = NULL;
X
X    if (!name || !dk_conf || !dk_geom)
X	return((DISKPART *) NULL);
X
X    pname[1] = C_NULL;
X    for (i = 0; PartChars[i]; ++i) {
X	pname[0] = PartChars[i];
X	if (dp = ExtractDiskPart(name, pname, dk_conf, dk_geom)) {
X	    if (base) {
X		for (pdp = base; pdp && pdp->dp_nxt; pdp = pdp->dp_nxt);
X		pdp->dp_nxt = NewDiskPart(dp);
X	    } else {
X		base = NewDiskPart(dp);
X	    }
X	}
X    }
X
X    return(base);
X}
X
X/*
X * Convert all we've learned about a disk to a DEVICE.
X */
Xstatic DEVICE *DKtoDiskDrive(name, disktype, DevData,
X			     dk_info, dk_label, dk_conf, dk_geom, dk_type)
X    char 		       *name;
X    int				disktype;
X    DEVDATA 		       *DevData;
X    DKinfo	 	       *dk_info;
X    DKlabel	 	       *dk_label;
X    DKconf 		       *dk_conf;
X    DKgeom 		       *dk_geom;
X    DKtype 		       *dk_type;
X{
X    DEVICE 		       *Device, *dkctlr;
X    DISKDRIVE 		       *diskdrive;
X
X    if ((Device = NewDevice(NULL)) == NULL) {
X	Error("Cannot create new device entry.");
X	return((DEVICE *) NULL);
X    }
X
X    if ((dkctlr = NewDevice(NULL)) == NULL) {
X	Error("Cannot create new dkctlr device entry.");
X	return((DEVICE *) NULL);
X    }
X
X    if ((diskdrive = NewDiskDrive(NULL)) == NULL) {
X	Error("Cannot create new diskdrive entry.");
X	return((DEVICE *) NULL);
X    }
X
X    Device->dv_name 		= GetDiskName(name, dk_conf, dk_info);
X    Device->dv_type 		= DT_DISKDRIVE;
X    /*
X     * Only read partition info we we're going to print it later.
X     */
X    if (VL_ALL)
X	diskdrive->dd_part 	= GetDiskPart(name, dk_conf, dk_geom);
X    diskdrive->dd_label 	= GetDiskLabel(dk_label);
X    Device->dv_model 		= diskdrive->dd_label;
X
X    if (disktype == DKT_CDROM && diskdrive->dd_label == NULL)
X	Device->dv_model 	= "CD-ROM";
X	
X    if (dk_conf) {
X	diskdrive->dd_unit 	= dk_conf->dkc_unit;
X	diskdrive->dd_slave 	= dk_conf->dkc_slave;;
X    }
X    if (dk_geom) {
X	diskdrive->dd_dcyl 	= dk_geom->dkg_ncyl;
X	diskdrive->dd_pcyl 	= dk_geom->dkg_pcyl;
X	diskdrive->dd_acyl 	= dk_geom->dkg_acyl;
X	diskdrive->dd_heads 	= dk_geom->dkg_nhead;
X	diskdrive->dd_sect 	= dk_geom->dkg_nsect;
X	diskdrive->dd_apc 	= dk_geom->dkg_apc;
X	diskdrive->dd_rpm 	= dk_geom->dkg_rpm;
X	diskdrive->dd_intrlv 	= dk_geom->dkg_intrlv;
X    }
X    if (dk_type) {
X	diskdrive->dd_psect 	= dk_type->dkt_hsect;
X	diskdrive->dd_promrev 	= dk_type->dkt_promrev;
X    }
X    if (dk_info) {
X#if	defined(DKI_HEXUNIT)
X	if (FLAGS_ON(dk_info->dki_flags, DKI_HEXUNIT))
X	    diskdrive->dd_flags |= DF_HEXUNIT;
X#endif 	/* DKI_HEXUNIT */
X    }
X    diskdrive->dd_secsize 	= SECSIZE;
X
X    dkctlr 			= GetDkCtlrDevice(DevData, dk_info, dk_conf);
X
X    Device->dv_devspec 		= (caddr_t *) diskdrive;
X    Device->dv_master 		= dkctlr;
X
X    return(Device);
X}
X
X/*
X * Query and learn about a disk.
X */
Xextern DEVICE *ProbeDiskDriveGeneric(disktype, name, DevData, DevDataTab)
X    /*ARGSUSED*/
X    int				disktype;
X    char 		       *name;
X    DEVDATA 		       *DevData;
X    DEVDATATAB 	     	       *DevDataTab;
X{
X    DEVICE 		       *diskdevice;
X    DKinfo 		       *dk_info = NULL;
X    DKconf 		       *dk_conf = NULL;
X    DKtype 		       *dk_type = NULL;
X    DKlabel 		       *dk_label = NULL;
X    DKgeom 		       *dk_geom = NULL;
X    char 		       *rfile;
X    int 			d;
X
X    if (!name)
X	return((DEVICE *) NULL);
X
X#if	defined(HAVE_IPI)
X    /*
X     * XXX - Kludge for IPI "id" disks.
X     */
X    if (EQ(DevData->dd_devname, "id")) {
X	static char		Buf[BUFSIZ];
X
X	(void) sprintf(Buf, "%s%3.3x", 
X		       DevData->dd_devname, DevData->dd_devunit);
X	name = Buf;
X    }
X#endif	/* HAVE_IPI */
X
X    if (disktype == DKT_CDROM)
X	rfile = GetRawFile(name, NULL);
X    else {
X	if (stat(rfile = GetRawFile(name, NULL), &StatBuf) != 0)
X	    /*
X	     * Get the name of the whole disk raw device.
X	     */
X	    rfile = GetRawFile(name, "c");
X    }
X
X    if ((d = open(rfile, O_RDONLY)) < 0) {
X	if (Debug) Error("%s: Cannot open for reading: %s.", rfile, SYSERR);
X	/*
X	 * If we know for sure this drive is present and we
X	 * know something about it, then create a minimal device.
X	 */
X	if ((DevDataTab->ddt_model || DevDataTab->ddt_desc) &&
X	    FLAGS_ON(DevData->dd_flags, DD_IS_ALIVE)) {
X	    Device = NewDevice((DEVICE *) NULL);
X	    Device->dv_name = strdup(name);
X	    Device->dv_unit = DevData->dd_devunit;
X	    Device->dv_master = MkMasterFromDevData(DevData);
X	    Device->dv_type = DT_DISKDRIVE;
X	    Device->dv_model = DevDataTab->ddt_model;
X	    Device->dv_modeldesc = DevDataTab->ddt_desc;
X	    return(Device);
X	} else
X	    return((DEVICE *) NULL);
X    }
X
X    if ((dk_conf = GETdk_conf(d, rfile, disktype)) == NULL)
X	if (Debug) Error("%s: get dk_conf failed.", rfile);
X
X    if ((dk_info = GETdk_info(d, rfile)) == NULL)
X	if (Debug) Error("%s: get dk_info failed.", rfile);
X
X    if ((dk_geom = GETdk_geom(d, rfile, disktype)) == NULL)
X	if (Debug) Error("%s: get dk_geom failed.", rfile);
X
X    if ((dk_label = GETdk_label(d, rfile, dk_info, disktype)) == NULL)
X	if (Debug) Error("%s: get dk_label failed.", rfile);
X
X    /*
X     * Not all controllers support dk_type
X     */
X    dk_type = GETdk_type(d, rfile);
X
X    close(d);
X
X    if (!(diskdevice = DKtoDiskDrive(name, disktype, DevData,
X				     dk_info, dk_label, 
X				     dk_conf, dk_geom, dk_type))) {
X	Error("%s: Cannot convert diskdrive information.", name);
X	return((DEVICE *) NULL);
X    }
X
X    return(diskdevice);
X}
X
X/*
X * Probe normal disk drive by calling Generic probe routine.
X */
Xextern DEVICE *ProbeDiskDrive(name, DevData, DevDataTab)
X    char 		       *name;
X    DEVDATA 		       *DevData;
X    DEVDATATAB 	     	       *DevDataTab;
X{
X    return(ProbeDiskDriveGeneric(DKT_GENERIC, name, DevData, DevDataTab));
X}
X
X/*
X * Probe CDROM disk drive by calling Generic probe routine.
X */
Xextern DEVICE *ProbeCDROMDrive(name, DevData, DevDataTab)
X    char 		       *name;
X    DEVDATA 		       *DevData;
X    DEVDATATAB 	     	       *DevDataTab;
X{
X    return(ProbeDiskDriveGeneric(DKT_CDROM, name, DevData, DevDataTab));
X}
X
X/*
X * Probe a tape device
X * XXX - this loses if somebody's using the tape, as tapes are exclusive-open
X * devices, and our open will therefore fail.
X * This also loses if there's no tape in the drive, as the open will fail.
X * The above probably applies to most other flavors of UNIX.
X */
Xextern DEVICE *ProbeTapeDrive(name, DevData, DevDataTab)
X     /*ARGSUSED*/
X    char 		       *name;
X    DEVDATA 		       *DevData;
X    DEVDATATAB	 	       *DevDataTab;
X{
X    extern NAMETAB		MtInfo[];
X    DEVICE 		       *Device;
X    char 		       *file;
X    char 		       *model = NULL;
X    char			rfile[BUFSIZ];
X    static char 		Buf[BUFSIZ];
X    struct mtget 		mtget;
X    register int 		i;
X    int 			d;
X
X    /*
X     * Don't use GetRawFile; that'll just stick an "r" in front of the
X     * device name, meaning it'll return the rewind-on-close device.
X     * Somebody may have left the tape positioned somewhere other than
X     * at the BOT to, for example, write a dump there later in the
X     * evening; it'd be rather rude to reposition it out from under them.
X     *
X     * The above probably applies to most other flavors of UNIX.
X     */
X    if (!name)
X	file = NULL;
X    else {
X	(void) sprintf(rfile, "/dev/nr%s", name);
X	file = rfile;
X    }
X
X    if ((d = open(file, O_RDONLY)) < 0) {
X	if (Debug)
X	    Error("%s Cannot open for read: %s.", file, SYSERR);
X
X	/*
X	 * --RECURSE--
X	 * If we haven't tried the "mt" name yet, try it now
X	 */
X	if (strncmp(name, MTNAME, strlen(MTNAME)) != 0) {
X	    (void) sprintf(Buf, "%s%d", MTNAME, DevData->dd_devunit);
X	    Device = ProbeTapeDrive(Buf, DevData, DevDataTab);
X	    if (Device)
X		return(Device);
X	}
X
X	/*
X	 * If we know for sure this drive is present and we
X	 * know something about it, then create a minimal device.
X	 */
X	if ((DevDataTab->ddt_model || DevDataTab->ddt_desc) &&
X	    FLAGS_ON(DevData->dd_flags, DD_IS_ALIVE)) {
X	    Device = NewDevice((DEVICE *) NULL);
X	    /* 
X	     * Recreate name from devdata since we might have had to
X	     * call ourself with name "rmt?"
X	     */
X	    (void) sprintf(Buf, "%s%d", DevData->dd_devname, 
X			   DevData->dd_devunit);
X	    Device->dv_name = strdup(Buf);
X	    Device->dv_unit = DevData->dd_devunit;
X	    Device->dv_master = MkMasterFromDevData(DevData);
X	    Device->dv_type = DT_TAPEDRIVE;
X	    Device->dv_model = DevDataTab->ddt_model;
X	    Device->dv_modeldesc = DevDataTab->ddt_desc;
X	    return(Device);
X	} else
X	    return((DEVICE *) NULL);
X    }
X
X    if (ioctl(d, MTIOCGET, &mtget) != 0) {
X	Error("%s: Cannot extract tape status: %s.", file, SYSERR);
X	return((DEVICE *) NULL);
X    }
X
X    (void) close(d);
X
X    model = "unknown";
X
X    for (i = 0; MtInfo[i].name; ++i) {
X	if ((MtInfo[i].value == mtget.mt_type)) {
X	    model = MtInfo[i].name;
X	    break;
X	}
X    }
X
X    /*
X     * Create and set device info
X     */
X    Device = NewDevice(NULL);
X    Device->dv_name = strdup(name);
X    Device->dv_type = DT_TAPEDRIVE;
X    if (model)
X	Device->dv_model = model;
X    else
X	Device->dv_model = DevDataTab->ddt_model;
X    Device->dv_modeldesc = DevDataTab->ddt_desc;
X    Device->dv_unit = DevData->dd_devunit;
X    Device->dv_master = MkMasterFromDevData(DevData);
X
X    return(Device);
X}
X
X/*
X * Query and learn about a device attached to an Auspex Storage Processor.
X * They'll show up as "ad" in the Mainbus info structure, but that
X * merely reflects the way the slots are set up in the config file.
X * We need to find out what type of device it is at this particular
X * instant (it's subject to change - perhaps even while we're running,
X * but there's not a heck of a lot we can do about that).
X *
X * We do that by trying it as a CD-ROM first, then as a disk, then as
X * a tape; that loses if it's a tape and somebody's using it, but
X * tapes on most if not all UNIX systems can't be probed by us if
X * somebody's using it.
X * The reason why we try it first as a CD-ROM is that if the CD has a
X * partition table, the Auspex driver lets you open the partitions as
X * if it were a disk.
X */
Xextern DEVICE *ProbeSPDrive(name, DevData, DevDataTab)
X     /*ARGSUSED*/
X    char 		       *name;
X    DEVDATA 		       *DevData;
X    DEVDATATAB 	     	       *DevDataTab;
X{
X    DEVICE 		       *thedevice;
X    char			devname[BUFSIZ];
X
X    /*
X     * Try it first as a CD-ROM.
X     */
X    (void) sprintf(devname, "acd%d", DevData->dd_devunit);
X    DevData->dd_devname = "acd";
X    DevDataTab->ddt_model = "CD-ROM";
X    if (thedevice = ProbeCDROMDrive(devname, DevData, DevDataTab))
X	return(thedevice);
X
X    /*
X     * Not a CD-ROM.  Try a disk.
X     */
X    (void) sprintf(devname, "ad%d", DevData->dd_devunit);
X    DevData->dd_devname = "ad";
X    DevDataTab->ddt_model = NULL;
X    if (thedevice = ProbeDiskDrive(devname, DevData, DevDataTab))
X	return(thedevice);
X
X    /*
X     * Not a disk.  Try a tape.
X     */
X    (void) sprintf(devname, "ast%d", DevData->dd_devunit);
X    DevData->dd_devname = "ast";
X    if (thedevice = ProbeTapeDrive(devname, DevData, DevDataTab))
X	return(thedevice);
X
X    /*
X     * None of the above.  Who knows?
X     */
X    return((DEVICE *) NULL);
X}
X
X#if	defined(HAVE_SUNROMVEC)
X/*
X * Be backwards compatible with pre-4.1.2 code
X */
X#include <mon/sunromvec.h>
X#if	defined(OPENPROMS) && !(defined(ROMVEC_VERSION) && \
X				(ROMVEC_VERSION == 0 || ROMVEC_VERSION == 1))
X#define v_mon_id op_mon_id
X#endif
X#endif	/* HAVE_SUNROMVEC */
X
X/*
X * Get ROM Version number
X *
X * If "romp" is "defined" (in <mon/sunromvec.h>), then take that
X * as the address of the kernel pointer to "rom" (struct sunromvec).
X * Otherwise, nlist "romp" from the kernel.
X */
Xextern char *GetRomVer()
X{
X    static char			RomRev[16];
X    struct nlist	       *nlptr;
X#if	defined(HAVE_SUNROMVEC)
X    static struct sunromvec	Rom;
X    kvm_t		       *kd;
X#if	!defined(romp)
X    struct sunromvec	       *romp;
X
X    if (!(kd = KVMopen()))
X	return((char *) NULL);
X
X    if ((nlptr = KVMnlist(kd, RomVecSYM, (struct nlist *)NULL)) == NULL)
X	return((char *) NULL);
X
X    if (CheckNlist(nlptr))
X	return((char *) NULL);
X
X    /*
X     * Read the kernel pointer to the sunromvec structure.
X     */
X    if (KVMread(kd, (u_long) nlptr->n_value, (char *) &romp, 
X		sizeof(romp), FALSE)) {
X	if (Debug) Error("Cannot read sunromvec pointer from kernel.");
X	return((char *) NULL);
X    }
X
X#else	/* romp */
X
X    if (!(kd = KVMopen()))
X	return((char *) NULL);
X
X#endif	/* romp */
X
X    /*
X     * Read the sunromvec structure from the kernel
X     */
X    /*SUPPRESS 25*/
X    if (KVMread(kd, (u_long) romp, (char *) &Rom, 
X		sizeof(struct sunromvec), FALSE)) {
X	if (Debug) Error("Cannot read sunromvec from kernel.");
X	return((char *) NULL);
X    }
X
X#if	!defined(romp)
X
X    /*
X     * XXX Hardcoded values
X     */
X    (void) sprintf(RomRev, "%d.%d", Rom.v_mon_id >> 16, Rom.v_mon_id & 0xFFFF);
X
X#else	/* romp */
X
X    /*
X     * Read the version string from the address indicated by Rom.v_mon_id.
X     */
X    if (KVMread(kd, (u_long) Rom.v_mon_id, RomRev, sizeof(RomRev), TRUE)) {
X	if (Debug) Error("Cannot read rom revision from kernel.");
X	return((char *) NULL);
X    }
X#endif	/* romp */
X
X    KVMclose(kd);
X
X#endif	/* HAVE_SUNROMVEC */
X
X    return((RomRev[0]) ? RomRev : (char *) NULL);
X}
END_OF_FILE
if test 26814 -ne `wc -c <'os-sunos4.c'`; then
    echo shar: \"'os-sunos4.c'\" unpacked with wrong size!
fi
# end of 'os-sunos4.c'
fi
if test -f 'os-sunos5.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'os-sunos5.c'\"
else
echo shar: Extracting \"'os-sunos5.c'\" \(21524 characters\)
sed "s/^X//" >'os-sunos5.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: os-sunos5.c,v 1.22 1994/02/11 18:30:14 mcooper Exp mcooper $";
X#endif
X
X/*
X * SunOS 5.x specific routines
X */
X
X#include "defs.h"
X#include <nlist.h>
X#include <dirent.h>
X#include <sys/stat.h>
X
X/*
X * CPU (model) symbol
X */
Xchar 				CpuSYM[] = "_cputype";
Xstatic char			Buff[BUFSIZ];
XDEVICE			       *Device;
Xextern char		        RomVecSYM[];
Xstruct stat			StatBuf;
X
X/*
X * No such device for SunOS 5 right now
X */
Xextern DEVICE *ProbeSPDrive()
X{
X    return((DEVICE *)NULL);
X}
X
X/*
X * This routine is obsolete.
X */
Xextern DEVICE *ProbeCDROMDrive()
X{
X    return((DEVICE *)NULL);
X}
X
X/* 
X * Scan DevDir looking for a device file that matches 
X * DevData->dd_devnum.
X */
Xstatic char *GetDeviceFile(DevData, DevDir)
X    DEVDATA 		       *DevData;
X    char		       *DevDir;
X{
X    static DIR		       *dirp = NULL;
X    struct dirent	       *dirent;
X    static char			path[MAXPATHLEN];
X    static char			lastdir[MAXPATHLEN];
X
X    /* Don't bother trying if the devnum is 0 */
X    if (DevData->dd_devnum <= 0)
X	return((char *)NULL);
X
X    if (!dirp || !EQ(DevDir, lastdir)) {
X	if (!(dirp = opendir(DevDir))) {
X	    if (Debug) Error("Cannot open directory \"%s\": %s", 
X			     DevDir, SYSERR);
X	    return((char *)NULL);
X	}
X	(void) strcpy(lastdir, DevDir);
X    } else
X	rewinddir(dirp);
X
X    while (dirent = readdir(dirp)) {
X	if (EQ(dirent->d_name, ".") || EQ(dirent->d_name, ".."))
X	    continue;
X	
X	(void) sprintf(path, "%s/%s", DevDir, dirent->d_name);
X
X	if (stat(path, &StatBuf) < 0) {
X	    if (Debug) Error("Stat of %s failed: %s.", path, SYSERR);
X	    continue;
X	}
X
X#if	defined(DEBUG_VERBOSE)
X	if (Debug) printf("GetDeviceFile dev '%s' (%d) got '%s' (%d)\n",
X			  DevData->dd_devname, DevData->dd_devnum,
X			  path, StatBuf.st_rdev);
X#endif	/* DEBUG_VERBOSE */
X
X	if (StatBuf.st_rdev == DevData->dd_devnum)
X	    return(path);
X    }
X
X    return((char *)NULL);
X}
X
X/*
X * Probe a Tape Drive.
X */
Xextern DEVICE *ProbeTapeDrive(tapename, DevData, DevDataTab)
X    /*ARGSUSED*/
X    char 		       *tapename;
X    DEVDATA 		       *DevData;
X    DEVDATATAB	 	       *DevDataTab;
X{
X    extern NAMETAB		MtInfo[];
X    DEVICE 		       *Device;
X    char 		       *devfile;
X    char 		       *devname;
X    char 		       *model = NULL;
X    static char 		devfilen[BUFSIZ];
X    struct mtget 		mtget;
X    register int 		i;
X    register char	       *cp;
X    int 			fd;
X
X    if (!(devfile = GetDeviceFile(DevData, _PATH_DEV_RMT))) {
X	if (Debug) Error("Cannot find tape device for `%s'", tapename);
X	return((DEVICE *)NULL);
X    }
X
X    /* 
X     * Use devfile to get name of device.
X     * Takes something like "/dev/rmt/0l" and
X     * turns it into "rmt/0".
X     */
X    cp = devfile;
X    /* Skip over "/dev/" */
X    if (strlen(devfile) > 5 && EQN(devfile, "/dev/", 4))
X	cp += 5;
X    devname = cp;
X    if (cp = strrchr(devfile, '/')) {
X	++cp;
X	while (isdigit(*++cp));
X	if (*cp && !isdigit(*cp))
X	    *cp = C_NULL;
X    }
X
X    /* Use the no rewind file */
X    (void) sprintf(devfilen, "%sn", devfile);
X
X    if ((fd = open(devfilen, O_RDONLY)) < 0) {
X	if (Debug)
X	    Error("%s Cannot open for read: %s.", devfilen, SYSERR);
X
X	/*
X	 * If we know for sure this drive is present and we
X	 * know something about it, then create a minimal device.
X	 */
X	if ((DevDataTab->ddt_model || DevDataTab->ddt_desc) &&
X	    FLAGS_ON(DevData->dd_flags, DD_IS_ALIVE)) {
X	    Device 			= NewDevice((DEVICE *) NULL);
X	    Device->dv_name 		= strdup(devname);
X	    Device->dv_aname 		= strdup(tapename);
X	    Device->dv_unit 		= DevData->dd_devunit;
X	    Device->dv_master 		= MkMasterFromDevData(DevData);
X	    Device->dv_type 		= DT_TAPEDRIVE;
X	    Device->dv_nodeid		= DevData->dd_nodeid;
X	    Device->dv_model 		= DevDataTab->ddt_model;
X	    Device->dv_modeldesc	= DevDataTab->ddt_desc;
X	    return(Device);
X	} else
X	    return((DEVICE *) NULL);
X    }
X
X    if (ioctl(fd, MTIOCGET, &mtget) != 0) {
X	Error("%s: Cannot extract tape status: %s.", devname, SYSERR);
X	return((DEVICE *) NULL);
X    }
X
X    (void) close(fd);
X
X    model = "unknown";
X    for (i = 0; MtInfo[i].name; ++i) {
X	if ((MtInfo[i].value == mtget.mt_type)) {
X	    model = MtInfo[i].name;
X	    break;
X	}
X    }
X
X    /*
X     * Create and set device info
X     */
X    Device 			= NewDevice(NULL);
X    Device->dv_name 		= strdup(devname);
X    Device->dv_aname 		= strdup(tapename);
X    Device->dv_type 		= DT_TAPEDRIVE;
X    Device->dv_nodeid		= DevData->dd_nodeid;
X    if (model)
X	Device->dv_model 	= model;
X    else
X	Device->dv_model 	= DevDataTab->ddt_model;
X    Device->dv_unit 		= DevData->dd_devunit;
X    Device->dv_modeldesc 	= DevDataTab->ddt_desc;
X    Device->dv_master 		= MkMasterFromDevData(DevData);
X
X    return(Device);
X}
X
X/*
X * Get SVR4 style partition information
X */
XDKvtoc *GETvtoc(fd, devfile)
X    int				fd;
X    char		       *devfile;
X{
X    static DKvtoc 		vtoc;
X
X    if (ioctl(fd, DKIOCGVTOC, &vtoc) < 0) {
X	if (Debug) Error("%s: DKIOCGVTOC: %s.", devfile, SYSERR);
X	return((DKvtoc *)NULL);
X    }
X
X    return(&vtoc);
X}
X
X/*
X * Get controller information
X */
XDKcinfo *GETdk_cinfo(fd, devfile)
X    int				fd;
X    char		       *devfile;
X{
X    static DKcinfo 		dk_cinfo;
X
X    if (ioctl(fd, DKIOCINFO, &dk_cinfo) < 0) {
X	if (Debug) Error("%s: DKIOCINFO: %s.", devfile, SYSERR);
X	return((DKcinfo *)NULL);
X    }
X
X    return(&dk_cinfo);
X}
X
X/*
X * Get disk geometry
X */
XDKgeom *GETdk_geom(fd, devfile)
X    int				fd;
X    char		       *devfile;
X{
X    static DKgeom 		dk_geom;
X
X    if (ioctl(fd, DKIOCGGEOM, &dk_geom) < 0) {
X	if (Debug) Error("%s: DKIOCGGEOM: %s.", devfile, SYSERR);
X	return((DKgeom *)NULL);
X    }
X
X    return(&dk_geom);
X}
X
X/*
X * Get disk type structure.
X */
Xstatic DKtype *GETdk_type(fd, file)
X    int 			fd;
X    char 		       *file;
X{
X    static DKtype 		dk_type;
X
X    if (ioctl(fd, HDKIOCGTYPE, &dk_type) < 0) {
X	if (errno != ENOTTY)
X	    if (Debug) Error("%s: DKIOCGTYPE: %s.", file, SYSERR);
X	return(NULL);
X    }
X
X    return(&dk_type);
X}
X
X/*
X * Find mount point for a given device
X */
Xstatic char *GetMountInfo(devname, part)
X    char		       *devname;
X    char		       *part;
X{
X    static FILE 	       *mntFilePtr = NULL;
X    static FILE 	       *vfstabFilePtr = NULL;
X    struct mnttab 	        mnttab;
X    struct vfstab		vfstab;
X    static char			name[BUFSIZ];
X    static char			pathname[BUFSIZ];
X    register char	       *cp;
X
X    if (!devname || !part)
X	return((char *) NULL);
X
X    (void) sprintf(name, "%s%s", devname, part);
X
X    /*
X     * First try the current mount table
X     */
X    if (!mntFilePtr) {
X	if ((mntFilePtr = fopen(MNTTAB, "r")) == NULL) {
X	    Error("%s: Cannot open for reading: %s.", MNTTAB, SYSERR);
X	    return(NULL);
X	}
X    } else
X	rewind(mntFilePtr);
X
X    while (getmntent(mntFilePtr, &mnttab) == 0) {
X	if (!mnttab.mnt_special)
X	    continue;
X	if (cp = strrchr(mnttab.mnt_special, '/'))
X	    ++cp;
X	else
X	    cp = mnttab.mnt_special;
X	if (EQ(cp, name))
X	    return(strdup(mnttab.mnt_mountp));
X    }
X
X    /*
X     * Now try the static mount table, which may not reflect current reality.
X     */
X    if (!vfstabFilePtr) {
X	if ((vfstabFilePtr = fopen(VFSTAB, "r")) == NULL) {
X	    Error("%s: Cannot open for reading: %s.", VFSTAB, SYSERR);
X	    return(NULL);
X	}
X    } else
X	rewind(vfstabFilePtr);
X
X    (void) sprintf(pathname, "%s/%s", _PATH_DEV_DSK, name);
X
X    if (getvfsspec(vfstabFilePtr, &vfstab, pathname) == 0) {
X	if (EQ(vfstab.vfs_fstype, "swap"))
X	    return("swap");
X	else if (vfstab.vfs_mountp && !EQ(vfstab.vfs_mountp, "-"))
X	    return(strdup(vfstab.vfs_mountp));
X    }
X
X    return((char *) NULL);
X}
X
X/*
X * Translate disk partition information from basic
X * extracted disk info.
X */
Xstatic DISKPART *GetDiskPart(devname, dk_vtoc)
X    char 		       *devname;
X    DKvtoc 		       *dk_vtoc;
X{
X    register DISKPART 	       *pdp;
X    register ushort 		i;
X    static char 		pname[3];
X    DISKPART 		       *base = NULL;
X    DISKPART			diskpart;
X
X    if (!devname || !dk_vtoc)
X	return((DISKPART *) NULL);
X
X    pname[2] = C_NULL;
X    /*
X     * dk_vtoc->v_nparts is always 0 after the first time through
X     * here, so we use V_NUMPAR.
X     */
X    for (i = 0; i < V_NUMPAR; ++i) {
X	/* Skip partitions that have no size */
X	if (!dk_vtoc->v_part[i].p_size)
X	    continue;
X	(void) sprintf(pname, "s%d", i);
X	diskpart.dp_name = strdup(pname);
X	diskpart.dp_mnt = GetMountInfo(devname, pname);
X	diskpart.dp_stsect = dk_vtoc->v_part[i].p_start;
X	diskpart.dp_nsect = dk_vtoc->v_part[i].p_size;
X
X	if (base) {
X	    for (pdp = base; pdp && pdp->dp_nxt; pdp = pdp->dp_nxt);
X	    pdp->dp_nxt = NewDiskPart(&diskpart);
X	} else
X	    base = NewDiskPart(&diskpart);
X    }
X
X    return(base);
X}
X
X/*
X * Extract disk label
X */
Xstatic char *GetDiskLabel(dk_vtoc)
X    DKvtoc		       *dk_vtoc;
X{
X    register char	       *cp;
X    char		       *label;
X
X    if (!dk_vtoc)
X	return((char *)NULL);
X
X    label = strdup(dk_vtoc->v_asciilabel);
X
X    /*
X     * The label normally has geometry information in it we don't want
X     * to see, so we trim out anything starting with " cyl".
X     */
X    for (cp = label; cp && *cp; ++cp)
X	if (*cp == ' ' && strncasecmp(cp, " cyl", 4) == 0)
X	    *cp = C_NULL;
X
X    return(label);
X}
X
X/*
X * Get the name of the controller for a disk.
X */
Xstatic char *GetDkCtlrName(dk_cinfo)
X    DKcinfo 		       *dk_cinfo;
X{
X    if (!dk_cinfo)
X	return((char *) NULL);
X
X    (void) sprintf(Buff, "%s%d", dk_cinfo->dki_cname, dk_cinfo->dki_cnum);
X
X    return(strdup(Buff));
X}
X
X/*
X * Get the disk controller model name from a disk.
X */
Xstatic char *GetDkCtlrModel(dk_cinfo)
X    DKcinfo	 	       *dk_cinfo;
X{
X    DKCTLRTAB	 	       *pct;
X
X    if (!dk_cinfo)
X	return((char *) NULL);
X
X    if (!(pct = GetDkCtlrTab(dk_cinfo->dki_ctype)))
X	return(NULL);
X
X    return(pct->ct_model);
X}
X
X/*
X * Get a disk controller device from disk info.
X */
Xstatic DEVICE *GetDkCtlrDevice(DevData, dk_cinfo)
X    DEVDATA 		       *DevData;
X    DKcinfo	 	       *dk_cinfo;
X{
X    DEVICE 		       *MkMasterFromDevData();
X    DEVICE 		       *dkctlr;
X
X    if (!dk_cinfo)
X	return((DEVICE *) NULL);
X	
X    if ((dkctlr = NewDevice(NULL)) == NULL)
X	return((DEVICE *) NULL);
X
X    BZERO((char *) dkctlr, sizeof(*dkctlr));
X
X    dkctlr->dv_type = DT_DISKCTLR;
X
X    /*
X     * Get name of controller from devdata if available
X     */
X    if (DevData && DevData->dd_ctlrname)
X	dkctlr = MkMasterFromDevData(DevData);
X
X    if (!dkctlr->dv_name) {
X	dkctlr->dv_name = GetDkCtlrName(dk_cinfo);
X	dkctlr->dv_unit = dk_cinfo->dki_cnum;
X    }
X    dkctlr->dv_addr = dk_cinfo->dki_addr;
X    dkctlr->dv_prio = dk_cinfo->dki_prio;
X    dkctlr->dv_vec = dk_cinfo->dki_vec;
X    dkctlr->dv_model = GetDkCtlrModel(dk_cinfo);
X
X    return(dkctlr);
X}
X
X/*
X * Convert all we've learned about a disk to a DEVICE.
X */
Xstatic DEVICE *DKtoDiskDrive(devname, DevData,
X			     dk_vtoc, dk_cinfo, dk_geom, dk_type)
X    char 		       *devname;
X    DEVDATA 		       *DevData;
X    DKvtoc		       *dk_vtoc;
X    DKcinfo	 	       *dk_cinfo;
X    DKgeom 		       *dk_geom;
X    DKtype 		       *dk_type;
X{
X    DEVICE 		       *Device, *dkctlr;
X    DISKDRIVE 		       *diskdrive;
X    int				listcnt = 0;
X
X    if ((Device = NewDevice(NULL)) == NULL) {
X	Error("Cannot create new device entry.");
X	return((DEVICE *) NULL);
X    }
X
X    if ((dkctlr = NewDevice(NULL)) == NULL) {
X	Error("Cannot create new dkctlr device entry.");
X	return((DEVICE *) NULL);
X    }
X
X    if ((diskdrive = NewDiskDrive(NULL)) == NULL) {
X	Error("Cannot create new diskdrive entry.");
X	return((DEVICE *) NULL);
X    }
X
X    (void) sprintf(Buff, "%s%d", DevData->dd_devname, DevData->dd_devunit);
X    Device->dv_aname 		= strdup(Buff);
X    Device->dv_name 		= devname;
X    Device->dv_type 		= DT_DISKDRIVE;
X    Device->dv_nodeid 		= DevData->dd_nodeid;
X
X    /*
X     * Only read partition info we we're going to print it later.
X     */
X    if (VL_ALL)
X	diskdrive->dd_part 	= GetDiskPart(devname, dk_vtoc);
X    diskdrive->dd_label 	= GetDiskLabel(dk_vtoc);
X    Device->dv_model 		= diskdrive->dd_label;
X
X    if (dk_cinfo) {
X	diskdrive->dd_unit 	= dk_cinfo->dki_unit;
X	diskdrive->dd_slave 	= dk_cinfo->dki_slave;;
X    }
X    if (dk_geom) {
X	diskdrive->dd_dcyl 	= dk_geom->dkg_ncyl;
X	diskdrive->dd_pcyl 	= dk_geom->dkg_pcyl;
X	diskdrive->dd_acyl 	= dk_geom->dkg_acyl;
X	diskdrive->dd_heads 	= dk_geom->dkg_nhead;
X	diskdrive->dd_sect 	= dk_geom->dkg_nsect;
X	diskdrive->dd_apc 	= dk_geom->dkg_apc;
X	diskdrive->dd_rpm 	= dk_geom->dkg_rpm;
X	diskdrive->dd_intrlv 	= dk_geom->dkg_intrlv;
X    }
X    if (dk_type) {
X	diskdrive->dd_psect 	= dk_type->hdkt_hsect;
X	diskdrive->dd_promrev 	= dk_type->hdkt_promrev;
X    }
X    diskdrive->dd_secsize 	= dk_vtoc->v_sectorsz;
X
X    if (dk_vtoc->v_volume[0]) {
X	(void) sprintf(Buff, "Volume Name is \"%.*s\"", 
X		       sizeof(dk_vtoc->v_volume), dk_vtoc->v_volume);
X	AddDevDesc(Device, Buff, NULL, DA_APPEND);
X    }
X
X    dkctlr 			= GetDkCtlrDevice(DevData, dk_cinfo);
X
X    Device->dv_devspec 		= (caddr_t *) diskdrive;
X    Device->dv_master 		= dkctlr;
X
X    return(Device);
X}
X
X/*
X * Probe a disk drive
X */
Xextern DEVICE *ProbeDiskDrive(diskname, DevData, DevDataTab)
X    /*ARGSUSED*/
X    char 		       *diskname;
X    DEVDATA 		       *DevData;
X    DEVDATATAB 	     	       *DevDataTab;
X{
X    DEVICE 		       *diskdevice;
X    DKcinfo 		       *dk_cinfo;
X    DKgeom 		       *dk_geom;
X    DKtype 		       *dk_type;
X    DKvtoc 		       *dk_vtoc;
X    char		       *devfile;
X    char		       *devname;
X    char		       *cp;
X    int				Len;
X    int				fd;
X
X    if (!diskname)
X	return((DEVICE *)NULL);
X
X    if (!(devfile = GetDeviceFile(DevData, _PATH_DEV_RDSK))) {
X	if (Debug) Error("Cannot find disk device for `%s'.", diskname);
X	return((DEVICE *)NULL);
X    }
X
X    /* Use basename of device file for virtual disk device name */
X    devname = strdup(devfile);
X    if (cp = strrchr(devname, '/'))
X	devname = ++cp;
X    /* Zap slice part of name */
X    if (cp = strrchr(devname, 's'))
X	*cp = C_NULL;
X
X    /*
X     * Try opening the disk device.  Usually this will be the "s0" device.
X     * If that fails, and then try opening "s2".  Sometimes there's no "s0"
X     * partition, but there is an "s2".
X     */
X    fd = open(devfile, O_RDONLY);
X    if (fd < 0) {
X	Len = strlen(devfile);
X	if (devfile[Len-1] == '0') {
X	    devfile[Len-1] = '2';
X	    fd = open(devfile, O_RDONLY);
X	}
X    }
X    if (fd < 0) {
X	if (Debug) Error("%s: Cannot open for reading: %s.", devfile, SYSERR);
X	/*
X	 * If we know for sure this drive is present and we
X	 * know something about it, then create a minimal device.
X	 */
X	if ((DevDataTab->ddt_model || DevDataTab->ddt_desc) &&
X	    FLAGS_ON(DevData->dd_flags, DD_IS_ALIVE)) {
X	    Device = NewDevice((DEVICE *) NULL);
X	    Device->dv_name = strdup(devname);
X	    Device->dv_aname = strdup(diskname);
X	    Device->dv_unit = DevData->dd_devunit;
X	    Device->dv_master = MkMasterFromDevData(DevData);
X	    Device->dv_type = DT_DISKDRIVE;
X	    Device->dv_nodeid = DevData->dd_nodeid;
X	    Device->dv_model = DevDataTab->ddt_model;
X	    Device->dv_modeldesc = DevDataTab->ddt_model;
X	    return(Device);
X	} else
X	    return((DEVICE *) NULL);
X    }
X
X    if ((dk_vtoc = GETvtoc(fd, devfile)) == NULL)
X	if (Debug) Error("%s: get vtoc failed.", devfile);
X    if ((dk_cinfo = GETdk_cinfo(fd, devfile)) == NULL)
X	if (Debug) Error("%s: get dk_cinfo failed.", devfile);
X    if ((dk_geom = GETdk_geom(fd, devfile)) == NULL)
X	if (Debug) Error("%s: get dk_geom failed.", devfile);
X    if ((dk_type = GETdk_type(fd, devfile)) == NULL)
X	if (Debug) Error("%s: no dk_type info available.", devfile);
X
X    close(fd);
X
X    if (!(diskdevice = DKtoDiskDrive(devname, DevData,
X				     dk_vtoc, dk_cinfo, dk_geom, dk_type))) {
X	Error("%s: Cannot convert diskdrive information.", devname);
X	return((DEVICE *) NULL);
X    }
X
X    return(diskdevice);
X}
X
X/*
X * Get hostid
X */
Xlong gethostid()
X{
X    char 			buff[BUFSIZ];
X
X    sysinfo(SI_HW_SERIAL, buff, sizeof(buff));
X
X    return(atol(buff));
X}
X
X/*
X * Get system page size
X */
Xint getpagesize()
X{
X    long			siz;
X
X    if ((siz = sysconf(_SC_PAGESIZE)) == -1) {
X	Error("Cannot get pagesize from sysconf(): %s", SYSERR);
X	return(0);
X    }
X
X    return((int) siz);
X}
X
X#if	defined(HAVE_SUNROMVEC)
X#include <sys/comvec.h>
X#endif	/* HAVE_SUNROMVEC */
X
X/*
X * Get ROM Version number
X */
Xextern char *GetRomVer()
X{
X    static char			RomRev[32];
X#if	defined(HAVE_SUNROMVEC)
X    struct nlist	       *nlptr;
X    static union sunromvec	Rom;
X    kvm_t		       *kd;
X    union sunromvec	       *romp;
X
X    if (!(kd = KVMopen()))
X	return((char *) NULL);
X
X    if ((nlptr = KVMnlist(kd, RomVecSYM, (struct nlist *)NULL)) == NULL)
X	return((char *) NULL);
X
X    if (CheckNlist(nlptr))
X	return((char *) NULL);
X
X    /*
X     * Read the kernel pointer to the sunromvec structure.
X     */
X    if (KVMread(kd, (u_long) nlptr->n_value, (char *) &romp, 
X		sizeof(romp), FALSE)) {
X	if (Debug) Error("Cannot read sunromvec pointer from kernel.");
X	return((char *) NULL);
X    }
X
X    /*
X     * Read sunromvec from the kernel
X     */
X    if (KVMread(kd, (u_long) romp, (char *) &Rom, 
X		sizeof(union sunromvec), FALSE)) {
X	if (Debug) Error("Cannot read sunromvec from kernel.");
X	return((char *) NULL);
X    }
X
X    if (Rom.sunmon.v_mon_id) {
X	/*
X	 * Read the version string from the address indicated by v_mon_id.
X	 * Read 1 byte at a time until '\0' is encountered.
X	 */
X	if (KVMread(kd, (u_long) Rom.sunmon.v_mon_id, RomRev, 
X		    sizeof(RomRev), TRUE)) {
X	    if (Debug) Error("Cannot read sunmon rom revision from kernel.");
X	    return((char *) NULL);
X	}
X    }
X
X    if (Rom.obp.op_mon_id && !RomRev[0]) {
X	/*
X	 * XXX Hardcoded values
X	 */
X	(void) sprintf(RomRev, "%d.%d", 
X		       Rom.obp.op_mon_id >> 16, Rom.obp.op_mon_id & 0xFFFF);
X    }
X
X    KVMclose(kd);
X
X#endif	/* HAVE_SUNROMVEC */
X
X    return((RomRev[0]) ? RomRev : (char *) NULL);
X}
X
X/*
X * Get amount of physical memory
X */
Xextern int GetMemoryAmount()
X{
X    long			Amount;
X
X    /*
X     * sysmem() is an undocumented function that returns the
X     * amount of system (physical) memory in bytes.  It's in
X     * /usr/lib/libadm.a.  Discovered by reference in Sun
X     * PatchID 101050-01.
X     */
X    Amount = sysmem();
X    if (Amount < 0) {
X	if (Debug) Error("sysmem failed: %s", SYSERR);
X	return(-1);
X    }
X
X    return(DivRndUp((u_long) Amount, MBYTES));
X}
X
X/*
X * Get the system to detect all disk drives on the system. 
X * We only open the "s2" file for each device to avoid a
X * performance hit of opening every device file.
X */
Xstatic void DetectDisks()
X{
X    static DIR		       *DirPtr;
X    struct dirent	       *DirEnt;
X    static char			DevName[MAXPATHLEN];
X    static char			PathName[MAXPATHLEN];
X    static namelist_t	       *UsedList = NULL;
X    register char	       *cp;
X    int			        FileD;
X
X    if (!(DirPtr = opendir(_PATH_DEV_RDSK))) {
X	if (Debug) Error("Cannot open directory %s: %s.", 
X			 _PATH_DEV_RDSK, SYSERR);
X	return;
X    }
X
X    while (DirEnt = readdir(DirPtr)) {
X	if (EQ(DirEnt->d_name, ".") || EQ(DirEnt->d_name, ".."))
X	    continue;
X
X	(void) strcpy(DevName, DirEnt->d_name);
X	if (cp = strchr(DevName, 's'))
X	    *cp = C_NULL;
X	if (NameListFind(UsedList, DevName))
X	    continue;
X
X	/* 
X	 * Always use slice 2 which should always 
X	 * have a partition table.
X	 */
X	(void) sprintf(PathName, "%s/%ss2", _PATH_DEV_RDSK, DevName);
X	if ((FileD = open(PathName, O_RDONLY)) > 0)
X	    (void) close(FileD);
X	NameListAdd(&UsedList, DevName);
X    }
X
X    NameListFree(UsedList);
X    (void) closedir(DirPtr);
X}
X
X/*
X * Get the system to detect all tape drives on the system. 
X */
Xstatic void DetectTapes()
X{
X    static DIR		       *DirPtr;
X    struct dirent	       *DirEnt;
X    static char			DevName[MAXPATHLEN];
X    static char			PathName[MAXPATHLEN];
X    static namelist_t	       *UsedList = NULL;
X    register char	       *cp;
X    int			        FileD;
X
X    if (!(DirPtr = opendir(_PATH_DEV_RMT))) {
X	if (Debug) Error("Cannot open directory %s: %s.", 
X			 _PATH_DEV_RMT, SYSERR);
X	return;
X    }
X
X    while (DirEnt = readdir(DirPtr)) {
X	if (EQ(DirEnt->d_name, ".") || EQ(DirEnt->d_name, ".."))
X	    continue;
X
X	(void) strcpy(DevName, DirEnt->d_name);
X	for (cp = DevName; cp && isdigit(*cp); ++cp);
X	if (cp)
X	    *cp = C_NULL;
X	if (NameListFind(UsedList, DevName))
X	    continue;
X
X	/* 
X	 * Always use the "n" device to avoid rewinding the tape.
X	 */
X	(void) sprintf(PathName, "%s/%sn", _PATH_DEV_RMT, DevName);
X	if ((FileD = open(PathName, O_RDONLY)) > 0)
X	    (void) close(FileD);
X	NameListAdd(&UsedList, DevName);
X    }
X
X    NameListFree(UsedList);
X    (void) closedir(DirPtr);
X}
X
X/*
X * Get the system to detect the floppy disk drive.
X */
Xstatic int DetectFloppy()
X{
X    static char			DevName[MAXPATHLEN];
X    int				FileD;
X
X    (void) sprintf(DevName, "%s/rdiskette", _PATH_DEV);
X    if ((FileD = open(DevName, O_RDONLY)) > 0)
X	(void) close(FileD);
X}
X
X/*
X * The system does not "see" all devices until something attempts
X * to first use them.  These routines will cause the system to look
X * for and "see" certain devices that are not normally seen after
X * a system boot.
X */
Xextern void DetectDevices()
X{
X    DetectDisks();
X    DetectTapes();
X    DetectFloppy();
X}
X
X/*
X * There's no easy way to get this out of /kernel/unix so we
X * do the same thing the kernel does.
X */
Xextern char *GetKernelVersionStr()
X{
X    static char			Buff[BUFSIZ];
X    static struct utsname 	un;
X
X    if (uname(&un) == -1)
X	return((char *) NULL);
X
X    (void) sprintf(Buff, 
X	   "SunOS Release %s Version %s [UNIX(R) System V Release 4.0]",
X		   un.release, un.version);
X
X    return(Buff);
X}
END_OF_FILE
if test 21524 -ne `wc -c <'os-sunos5.c'`; then
    echo shar: \"'os-sunos5.c'\" unpacked with wrong size!
fi
# end of 'os-sunos5.c'
fi
echo shar: End of archive 4 \(of 5\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
