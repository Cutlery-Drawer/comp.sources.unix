Newsgroups: comp.sources.unix
From: mcooper@usc.edu (Michael A. Cooper)
Subject: v28i078: sysinfo-2.1.2 - Show system information, V2.1.2, Part05/05
References: <1.772126523.28031@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: mcooper@usc.edu (Michael A. Cooper)
Posting-Number: Volume 28, Issue 78
Archive-Name: sysinfo-2.1.2/part05

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 5)."
# Contents:  devices.c obp.c
# Wrapped by vixie@gw.home.vix.com on Mon Jun 20 08:33:21 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'devices.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'devices.c'\"
else
echo shar: Extracting \"'devices.c'\" \(28265 characters\)
sed "s/^X//" >'devices.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: devices.c,v 1.59 1994/01/12 22:56:08 mcooper Exp mcooper $";
X#endif
X
X/*
X * Device routines
X */
X
X#include <stdio.h>
X#include "defs.h"
X
Xstatic void PrintDiskdrive();
Xstatic void PrintFrameBuffer();
Xstatic void PrintNetIf();
Xstatic void PrintDevice();
Xstatic void PrintGeneric();
X
Xstruct devicetype {
X    int				 dt_dtype;	/* Device type */
X    char			*dt_desc;	/* Description */
X    void		       (*dt_prfunc)();	/* Print function */
X};
Xtypedef struct devicetype DEVTYPE;
X
XDEVTYPE DevTypes[] = {
X    { DT_GENERIC,	NULL,			PrintGeneric },
X    { DT_BUS,		"system bus",		PrintGeneric },
X    { DT_CPU,		"CPU",			PrintGeneric },
X    { DT_DISKCTLR,	"disk controller",	PrintGeneric },
X    { DT_DISKDRIVE,	"disk drive",		PrintDiskdrive },
X    { DT_FRAMEBUFFER,	"frame buffer",		PrintFrameBuffer },
X    { DT_KEYBOARD,	"Keyboard",		PrintGeneric },
X    { DT_NETIF,		"network interface",	PrintNetIf },
X    { DT_PSEUDO,	"pseudo device",	PrintGeneric },
X    { DT_TAPECTLR,	"tape controller",	PrintGeneric },
X    { DT_TAPEDRIVE,	"tape drive",		PrintGeneric },
X    { 0 },
X};
X
Xstatic float 			TotalDisk = 0;
XKEYTAB			       *DescInfo;
Xdevdesc_t	  	       *ddPtr;
Xextern int			OffSetAmt;
X
X/*
X * Add a device description to a device.
X */
Xint AddDevDesc(Device, Desc, Label, Action)
X    DEVICE		       *Device;
X    char		       *Desc;
X    char		       *Label;
X    int				Action;
X{
X    register devdesc_t	       *Ptr;
X    devdesc_t		       *New;
X
X    if (!Device || !Desc)
X	return(-1);
X
X    /*
X     * Check for duplicates
X     */
X    for (Ptr = Device->dv_desclist; Ptr; Ptr = Ptr->dd_next)
X	if (EQ(Ptr->dd_desc, Desc))
X	    return(-1);
X
X    /*
X     * Create new dev description
X     */
X    New = (devdesc_t *) xcalloc(sizeof(devdesc_t), 1);
X    New->dd_desc = strdup(Desc);
X    if (Label)
X	New->dd_label = strdup(Label);
X    if (Action & DA_PRIME)
X	New->dd_isprime = TRUE;	
X
X    /*
X     * Add to list
X     */
X    if (Device->dv_desclist) {
X	if (Action & DA_INSERT) {
X	    New->dd_next = Device->dv_desclist;
X	    Device->dv_desclist = New;
X	} else {
X	    for (Ptr = Device->dv_desclist; Ptr && Ptr->dd_next; 
X		 Ptr = Ptr->dd_next);
X	    Ptr->dd_next = New;
X	}
X    } else
X	Device->dv_desclist = New;
X
X    return(0);
X}
X
X/*
X * Get a device type.
X */
Xstatic DEVTYPE *GetDevType(Device)
X    DEVICE 		       *Device;
X{
X    register int 		i;
X
X    if (!Device)
X	return((DEVTYPE *) NULL);
X
X    for (i = 0; DevTypes[i].dt_prfunc; ++i)
X	if (DevTypes[i].dt_dtype == Device->dv_type)
X	    return(&DevTypes[i]);
X
X    return((DEVTYPE *) NULL);
X}
X
X/*
X * Get a nice size string
X */
Xextern char *GetSizeStr(Amt, Unit)
X    u_long			Amt;
X    u_long			Unit;
X{
X    static char			Buff[100];
X
X    Buff[0] = C_NULL;
X
X    if (Unit) {
X	if (Unit == GBYTES)
X	    (void) sprintf(Buff, "%d GB", Amt);
X	else if (Unit == MBYTES) {
X	    if (Amt > KBYTES)
X		(void) sprintf(Buff, "%.1f GB", (float) mbytes_to_gbytes(Amt));
X	    else
X		(void) sprintf(Buff, "%d MB", Amt);
X	} else if (Unit == KBYTES) {
X	    if (Amt > MBYTES)
X		(void) sprintf(Buff, "%.1f GB", (float) kbytes_to_gbytes(Amt));
X	    else if (Amt > KBYTES)
X		(void) sprintf(Buff, "%d MB", (u_long) kbytes_to_mbytes(Amt));
X	    else
X		(void) sprintf(Buff, "%d KB", Amt);
X	}
X    }
X
X    if (Buff[0] == C_NULL) {
X	if (Amt < KBYTES)
X	    (void) sprintf(Buff, "%d Bytes", Amt);
X	else if (Amt < MBYTES)
X	    (void) sprintf(Buff, "%d KB", (u_long) bytes_to_kbytes(Amt));
X	else if (Amt < GBYTES)
X	    (void) sprintf(Buff, "%d MB", (u_long) bytes_to_mbytes(Amt));
X	else
X	    (void) sprintf(Buff, "%.1f GB", (float) bytes_to_gbytes(Amt));
X    }
X
X    return(Buff);
X}
X
X/*
X * Print all device info
X */
Xextern void ShowDevices(MyInfo, SpecInfo)
X    SHOWINFO		       *MyInfo;
X    SHOWINFO		       *SpecInfo;	/* ARGSUSED */
X{
X    static DEVICE 	       *RootDev;
X
X#if	defined(sun)
X    if (BuildDevicesSunOS(&RootDev) != 0)
X	return;
X#endif	/* sun */
X
X#if	defined(ultrix)
X    if (BuildDevicesUltrix(&RootDev) != 0)
X	return;
X#endif	/* ultrix */
X
X#if	defined(NeXT)
X    if (BuildDevicesNeXT(&RootDev) != 0)
X	return;
X#endif	/* NeXT */
X
X#if	defined(_AIX)
X    if (BuildDevicesAIX(&RootDev) != 0)
X	return;
X#endif	/* _AIX */
X
X    if (!RootDev) {
X	if (Debug)
X	    printf("No devices were found.\n");
X	return;
X    }
X
X    printf("\n\n\t%s\n\n", MyInfo->Label);
X
X    TotalDisk = (float) 0;
X
X    PrintDevice(RootDev, 0);
X
X    if (VL_DESC && TotalDisk > (float) 0)
X	printf("\nTotal Disk Capacity is %s\n", 
X	       GetSizeStr((u_long) TotalDisk, MBYTES));
X}
X
X/*
X * --RECURSE--
X * Print info about a device.  Recursively calls itself for slaves and
X * next elements
X */
Xstatic void PrintDevice(Device, OffSet)
X    DEVICE 		       *Device;
X    int 			OffSet;
X{
X    DEVTYPE 		       *DevType;
X
X    /*
X     * If device->dv_name is not set, this is the root of the device tree
X     */
X
X    if (Device->dv_name) {
X	if (DevType = GetDevType(Device))
X	    (*DevType->dt_prfunc)(Device, DevType, OffSet);
X	else
X	    PrintGeneric(Device, DevType, OffSet);
X    }
X
X    /*
X     * Descend
X     */
X    if (Device->dv_slaves)
X	PrintDevice(Device->dv_slaves, (Device->dv_name) ? 
X		    OffSet+OffSetAmt : 0);
X
X    /*
X     * Traverse
X     */
X    if (Device->dv_nxt)
X	PrintDevice(Device->dv_nxt, (Device->dv_name) ? OffSet : 0);
X}
X
X/*
X * Print Off Set space
X */
Xstatic void PrOffSet(cnt)
X    int 			cnt;
X{
X    printf("%*s", cnt, "");
X}
X
X/*
X * Print a device label
X */
Xstatic void PrDevLabel(Name, OffSet)
X    char 		       *Name;
X    int 			OffSet;
X{
X    PrOffSet(OffSet);
X    if (VL_CONFIG)
X	printf("%*s%-18s:", OffSetAmt, "", Name);
X    else
X	printf("%*s%18s:", OffSetAmt, "", Name);
X}
X
Xchar *GetDescLabel(DevDesc)
X    devdesc_t		       *DevDesc;
X{
X    if (DevDesc && DevDesc->dd_label)
X	return(DevDesc->dd_label);
X    else
X	return("Description");
X}
X
X/*
X * Get the prime description of a device.
X */
Xextern char *PrimeDesc(Device)
X    DEVICE		       *Device;
X{
X    register devdesc_t	       *ddPtr;
X
X    if (!Device)
X	return((char *) NULL);
X
X    for (ddPtr = Device->dv_desclist; ddPtr; ddPtr = ddPtr->dd_next)
X	if (ddPtr->dd_isprime)
X	    return(ddPtr->dd_desc);
X
X    return((char *) NULL);
X}
X
X/*
X * Get a devdesc_t pointer to the prime description of a device.
X */
Xextern devdesc_t *PrimeDescPtr(Device)
X    DEVICE		       *Device;
X{
X    register devdesc_t	       *ddPtr;
X
X    if (!Device)
X	return((devdesc_t *) NULL);
X
X    for (ddPtr = Device->dv_desclist; ddPtr; ddPtr = ddPtr->dd_next)
X	if (ddPtr->dd_isprime)
X	    return(ddPtr);
X
X    return((devdesc_t *) NULL);
X}
X
X/*
X * Print general device information
X */
Xstatic void PrintDeviceInfo(Device, DevType, OffSet)
X    DEVICE 		       *Device;
X    DEVTYPE 		       *DevType;
X    int 			OffSet;
X{     
X    DEVTYPE 		       *mdt;
X    char		       *cp;
X
X    if (!Device->dv_name)
X	return;
X
X    if (VL_CONFIG) printf("\n");
X    PrOffSet(OffSet);
X    printf("%s", Device->dv_name);
X
X    if (Device->dv_aname)
X	printf(" (%s)", Device->dv_aname);
X    
X    if (Device->dv_model || Device->dv_modeldesc ||
X	(DevType && DevType->dt_desc)) {
X	printf(" is a");
X	if (Device->dv_model)
X	    printf(" \"%s\"", Device->dv_model);
X
X	if (Device->dv_modeldesc)
X	    printf(" %s", Device->dv_modeldesc);
X
X	if (DevType && DevType->dt_desc)
X	    printf(" %s", DevType->dt_desc);
X	else if (cp = PrimeDesc(Device))
X	    printf(" %s", cp);
X    } else if (cp = PrimeDesc(Device)) {
X	printf(" is a");
X	printf(" %s", cp);
X    }
X
X    if (Device->dv_name)
X	printf("\n");
X
X    if (VL_DESC || VL_CONFIG) {
X	if (Device->dv_desclist) {
X	    for (ddPtr = Device->dv_desclist; ddPtr; ddPtr = ddPtr->dd_next) {
X		PrDevLabel(GetDescLabel(ddPtr), OffSet);
X		printf(" %s\n", ddPtr->dd_desc);
X	    }
X	} else if ((mdt = GetDevType(Device)) && mdt && mdt->dt_desc) {
X	    PrDevLabel(GetDescLabel(NULL), OffSet);
X	    printf(" %s\n", mdt->dt_desc);
X	}
X
X	if (Device->dv_master && Device->dv_master->dv_name) {
X	    PrDevLabel(GetDescLabel(NULL), OffSet);
X	    if (Device->dv_master->dv_name)
X		printf(" Connected to %s", Device->dv_master->dv_name);
X	    else if (Device->dv_master->dv_model) {
X		printf(" Connected to %s", Device->dv_master->dv_model);
X		if (mdt = GetDevType(Device->dv_master))
X		    printf(" %s", mdt->dt_desc);
X	    }
X	    printf("\n");
X	}
X    }
X}
X
X/*
X * Print info about a generic device
X */
Xstatic void PrintGeneric(Device, DevType, OffSet)
X    DEVICE 		       *Device;
X    DEVTYPE 		       *DevType;
X    int 			OffSet;
X{
X    register DEVICE 	       *pd;
X
X    PrintDeviceInfo(Device, DevType, OffSet);
X
X    if (VL_CONFIG) {
X	if (Device->dv_unit >= 0 || Device->dv_addr >= 0 || 
X	    Device->dv_prio >= 0 || Device->dv_vec >= 0) {
X	    PrDevLabel("Configuration", OffSet);
X	    if (Device->dv_unit >= 0)
X		printf(" Unit %d", Device->dv_unit);
X	    if (Device->dv_addr >= 0)
X		printf(" Address 0x%x", Device->dv_addr);
X	    if (Device->dv_prio >= 0)
X		printf(" Priority %d", Device->dv_prio);
X	    if (Device->dv_vec >= 0)
X		printf(" Vector %d", Device->dv_vec);
X	    printf("\n");
X	}
X    }
X
X    if (VL_CONFIG) {
X	if (Device->dv_slaves && (Device->dv_name || Device->dv_model || 
X				  (DevType && DevType->dt_desc))) {
X	    PrDevLabel("Attached Device(s)", OffSet);
X	    for (pd = Device->dv_slaves; pd; pd = pd->dv_nxt)
X		printf(" %s", pd->dv_name);
X	    printf("\n");
X	}
X    }
X}
X
X/*
X * Print info about disk partitioning.
X */
Xstatic void PrintDiskPart(Disk, OffSet)
X    DISKDRIVE 		       *Disk;
X    int 			OffSet;
X{
X    register DISKPART 	       *pp;
X
X    printf("\n");
X    PrOffSet(OffSet);
X    printf("%40s\n", "Partition Information");
X
X    PrOffSet(OffSet);
X    printf("%10s %10s %10s %9s\n",
X	   "", "START", "NUMBER OF", "SIZE");
X
X    PrOffSet(OffSet);
X    printf("%10s %10s %10s %9s %s\n",
X	   "PART", "SECTOR", "SECTORS", "(MB)", "USAGE");
X
X    for (pp = Disk->dd_part; pp; pp = pp->dp_nxt) {
X	PrOffSet(OffSet);
X	printf("%10s %10d %10d %9.2f %s\n",
X	       pp->dp_name,
X	       pp->dp_stsect,
X	       pp->dp_nsect,
X	       bytes_to_mbytes(nsect_to_bytes(pp->dp_nsect, Disk->dd_secsize)),
X	       (pp->dp_mnt) ? pp->dp_mnt : ""
X	       );
X    }
X}
X
X/*
X * Get the capacity of a disk drive
X */
Xextern char *GetDiskSize(diskdrive)
X    DISKDRIVE		       *diskdrive;
X{
X    u_long			Amt = 0;
X
X    if (diskdrive->dd_dcyl && diskdrive->dd_sect && diskdrive->dd_heads) {
X	diskdrive->dd_size = (float) nsect_to_mbytes(diskdrive->dd_dcyl * 
X						     diskdrive->dd_sect * 
X						     diskdrive->dd_heads, 
X						     diskdrive->dd_secsize);
X
X	if (diskdrive->dd_size > 0)
X	    Amt = (u_long) diskdrive->dd_size;
X    }
X
X    if (Amt)
X	return(GetSizeStr(Amt, MBYTES));
X    else
X	return((char *) NULL);
X}
X
X/*
X * Print info about a disk device.
X */
Xstatic void PrintDiskdrive(Device, DevType, OffSet)
X    DEVICE 		       *Device;
X    DEVTYPE 		       *DevType;
X    int 			OffSet;
X{
X    static char			Buff[BUFSIZ];
X    char 			Buff2[BUFSIZ];
X    DISKDRIVE 		       *Disk = NULL;
X    char		       *DiskSize = NULL;
X
X    if (Device && Device->dv_devspec)
X	Disk = (DISKDRIVE *) Device->dv_devspec;
X
X    if (Disk && !Device->dv_modeldesc && (DiskSize = GetDiskSize(Disk)))
X	Device->dv_modeldesc = DiskSize;
X
X    if (!Disk)
X	return;
X
X    TotalDisk += Disk->dd_size;
X
X    if (VL_CONFIG) {
X	if (DiskSize) {
X	    (void) sprintf(Buff, "Capacity is %s", DiskSize);
X	    AddDevDesc(Device, Buff, NULL, DA_APPEND);
X	}
X
X	if (FLAGS_ON(Disk->dd_flags, DF_HEXUNIT))
X	    (void) sprintf(Buff, "Unit %.3x", Disk->dd_unit);
X	else
X	    (void) sprintf(Buff, "Unit %d", Disk->dd_unit);
X	(void) sprintf(Buff2, "  Slave %d", Disk->dd_slave);
X	(void) strcat(Buff, Buff2);
X	AddDevDesc(Device, Buff, "Configuration", DA_APPEND);
X
X	(void) sprintf(Buff, "RPM %d  APC %d  Interleave %d",
X		       Disk->dd_rpm, Disk->dd_apc, Disk->dd_intrlv);
X	AddDevDesc(Device, Buff, "Configuration", DA_APPEND);
X
X	if (Disk->dd_psect) {
X	    (void) sprintf(Buff, "Hard Sectors %d", Disk->dd_psect);
X	    AddDevDesc(Device, Buff, "Configuration", DA_APPEND);
X	}
X
X	if (Disk->dd_promrev) {
X	    (void) sprintf(Buff, "PROM Revision %d", Disk->dd_promrev);
X	    AddDevDesc(Device, Buff, "Configuration", DA_APPEND);
X	}
X
X	(void) sprintf(Buff, "Heads %d  Sectors/Track %d",
X		       Disk->dd_heads, Disk->dd_sect);
X	AddDevDesc(Device, Buff, "Geometry", DA_APPEND);
X
X	(void) sprintf(Buff, "Phys/Data/Alt Cylinders %d/%d/%d",
X		       Disk->dd_pcyl, Disk->dd_dcyl, Disk->dd_acyl);
X	AddDevDesc(Device, Buff, "Geometry", DA_APPEND);
X    }
X
X    PrintDeviceInfo(Device, DevType, OffSet);
X
X    if (VL_ALL && Disk->dd_part)
X	PrintDiskPart(Disk, OffSet);
X}
X
X/*
X * Print info about a frame buffer.
X */
Xstatic void PrintFrameBuffer(Device, DevType, OffSet)
X    DEVICE 		       *Device;
X    DEVTYPE 		       *DevType;
X    int 			OffSet;
X{
X    FRAMEBUFFER 	       *fb;
X    static char			Buff[BUFSIZ];
X
X    if (Device && Device->dv_devspec)
X	fb = (FRAMEBUFFER *) Device->dv_devspec;
X
X    if (!fb)
X	return;
X
X    if (VL_CONFIG) {
X	if (fb->fb_cmsize) {
X	    (void) sprintf(Buff, 
X			   "Color Map Size is %d", fb->fb_cmsize);
X	    AddDevDesc(Device, Buff, "Configuration", DA_INSERT);
X	}
X	if (fb->fb_vmsize) {
X	    (void) sprintf(Buff, "Video Memory %d KB", 
X			   (u_long) bytes_to_kbytes(fb->fb_vmsize));
X	    AddDevDesc(Device, Buff, "Configuration", DA_INSERT);
X	}
X	(void) sprintf(Buff, "%d KB  Height %d  Width %d  Depth %d-bit%s\n",
X		       (u_long) bytes_to_kbytes(fb->fb_size),
X		       fb->fb_height, fb->fb_width, fb->fb_depth,
X		       (fb->fb_depth == 1) ? "" : "s");
X	AddDevDesc(Device, Buff, "Screen Size", DA_INSERT);
X    }
X
X    PrintDeviceInfo(Device, DevType, OffSet);
X}
X
X/*
X * Print info about a network interface
X */
Xstatic void PrintNetIf(Device, DevType, OffSet)
X    DEVICE 		       *Device;
X    DEVTYPE 		       *DevType;
X    int 			OffSet;
X{
X    register NETIF	       *ni;
X
X    PrintDeviceInfo(Device, DevType, OffSet);
X
X    if (!Device->dv_devspec)
X	return;
X
X    if (VL_CONFIG) {
X	for (ni = (NETIF *) Device->dv_devspec; ni; ni = ni->ni_nxt) {
X	    if (ni->ni_typename) {
X		printf("\n");
X		PrDevLabel("Address Type", OffSet);
X		printf(" %s\n", ni->ni_typename);
X	    }
X
X	    if (ni->ni_hostaddr) {
X		PrDevLabel("Host Address", OffSet);
X		printf(" %-18s [%s]\n", ni->ni_hostaddr,
X		       (ni->ni_hostname) ? ni->ni_hostname : "<unknown>");
X	    }
X
X	    if (ni->ni_netaddr) {
X		PrDevLabel("Network Address", OffSet);
X		printf(" %-18s [%s]\n", ni->ni_netaddr, 
X		       (ni->ni_netname) ? ni->ni_netname : "<unknown>");
X	    }
X
X	    if (ni->ni_macaddr) {
X		PrDevLabel("Current MAC Addr", OffSet);
X		printf(" %-18s [%s]\n", ni->ni_macaddr,
X		       (ni->ni_macname && ni->ni_macname[0]) 
X		       ? ni->ni_macname : "<unknown>");
X	    }
X
X	    if (ni->ni_fmacaddr) {
X		PrDevLabel("Factory MAC Addr", OffSet);
X		printf(" %-18s [%s]\n", ni->ni_fmacaddr,
X		       (ni->ni_fmacname && ni->ni_fmacname[0]) 
X		       ? ni->ni_fmacname : "<unknown>");
X	    }
X	}
X    }
X}
X
X/*
X * --RECURSE--
X * Create a new DEVICE and optionally copy an old DEVICE.
X */
Xextern DEVICE *NewDevice(Old)
X    DEVICE 		       *Old;
X{
X    register DEVICE 	       *SlavePtr, *Slave;
X    DEVICE 		       *New = NULL;
X
X    New = (DEVICE *) xcalloc(1, sizeof(DEVICE));
X
X    /* Set int's to -1 */
X    New->dv_type = New->dv_unit = New->dv_addr = New->dv_prio = 
X	New->dv_vec = -1;
X
X    if (!Old)
X	return(New);
X
X    /* Bulk copy what we can */
X    BCOPY((char *) Old, (char *) New, sizeof(DEVICE));
X
X    New->dv_nxt = NULL;
X
X    /* Copy contents of pointers */
X    if (Old->dv_name)	New->dv_name = strdup(Old->dv_name);
X    if (Old->dv_model)	New->dv_model = strdup(Old->dv_model);
X    if (Old->dv_modeldesc) New->dv_modeldesc = strdup(Old->dv_modeldesc);
X    if (Old->dv_desclist) New->dv_desclist = Old->dv_desclist;
X
X    /* Copy Slave info */
X    for (Slave = Old->dv_slaves; Slave; Slave = Slave->dv_nxt) {
X	/* Find last slave */
X	for (SlavePtr = New->dv_slaves; SlavePtr && SlavePtr->dv_nxt; 
X	     SlavePtr = SlavePtr->dv_nxt);
X	/* Copy Old slave to last new slave device */
X	SlavePtr = NewDevice(Slave);
X    }
X
X    return(New);
X}
X
X/*
X * Create a new DISKPART and optionally copy an old DISKPART.
X */
Xextern DISKPART *NewDiskPart(Old)
X    DISKPART 		       *Old;
X{
X    DISKPART 		       *New = NULL;
X
X    New = (DISKPART *) xcalloc(1, sizeof(DISKPART));
X
X    if (!Old)
X	return(New);
X
X    /* Bulk copy what we can */
X    BCOPY((char *) Old, (char *) New, sizeof(DISKPART));
X
X    New->dp_nxt = NULL;
X
X    /* Copy contents of pointers */
X    if (Old->dp_name)	New->dp_name = strdup(Old->dp_name);
X    if (Old->dp_mnt)	New->dp_mnt = strdup(Old->dp_mnt);
X
X    return(New);
X}
X
X/*
X * --RECURSE--
X * Create a new DISKDRIVE and optionally copy an old DISKDRIVE.
X */
Xextern DISKDRIVE *NewDiskDrive(Old)
X    DISKDRIVE 		       *Old;
X{
X    register DISKPART 	       *dp, *pdp;
X    DISKDRIVE 		       *New = NULL;
X
X    New = (DISKDRIVE *) xcalloc(1, sizeof(DISKDRIVE));
X
X    if (!Old)
X	return(New);
X
X    /* Bulk copy what we can */
X    BCOPY((char *) Old, (char *) New, sizeof(DISKDRIVE));
X
X    New->dd_nxt = NULL;
X
X    /* Copy contents of pointers */
X    if (Old->dd_label)	New->dd_label = strdup(Old->dd_label);
X    if (Old->dd_ctlr) 	New->dd_ctlr = NewDevice(Old->dd_ctlr);
X
X    /* Copy partition info */
X    for (dp = Old->dd_part; dp; dp = dp->dp_nxt) {
X	/* Find last DISKPART */
X	for (pdp = New->dd_part; pdp && pdp->dp_nxt; pdp = pdp->dp_nxt);
X	/* Copy old DISKPART to last New DISKPART */
X	pdp = NewDiskPart(dp);
X    }
X
X    return(New);
X}
X
X/*
X * Create a new FRAMEBUFFER and optionally copy an old FRAMEBUFFER.
X */
Xextern FRAMEBUFFER *NewFrameBuffer(Old)
X    FRAMEBUFFER 	       *Old;
X{
X    FRAMEBUFFER 	       *New = NULL;
X
X    New = (FRAMEBUFFER *) xcalloc(1, sizeof(FRAMEBUFFER));
X
X    if (!Old)
X	return(New);
X
X    /* Bulk copy what we can */
X    BCOPY((char *) Old, (char *) New, sizeof(FRAMEBUFFER));
X
X    return(New);
X}
X
X/*
X * Create a new NETIF and optionally copy an old NETIF.
X */
Xextern NETIF *NewNetif(Old)
X    NETIF 		       *Old;
X{
X    NETIF 		       *New = NULL;
X
X    New = (NETIF *) xcalloc(1, sizeof(NETIF));
X
X    if (!Old)
X	return(New);
X
X    /* Copy */
X    New->ni_hostaddr = strdup(Old->ni_hostaddr);
X    New->ni_hostname = strdup(Old->ni_hostname);
X    New->ni_macaddr = strdup(Old->ni_macaddr);
X    New->ni_macname = strdup(Old->ni_macname);
X    New->ni_netaddr = strdup(Old->ni_netaddr);
X    New->ni_netname = strdup(Old->ni_netname);
X
X    return(New);
X}
X
X/*
X * --RECURSE--
X * Find device named "name" in tree "treeptr".
X * This function recursively calls itself looking for 
X * the device "name".
X */
Xextern DEVICE *FindDeviceByName(Name, TreePtr)
X    char 		       *Name;
X    DEVICE 		       *TreePtr;
X{
X    DEVICE 		       *Ptr;
X
X    if (!Name || !TreePtr)
X	return((DEVICE *) NULL);
X
X    if (TreePtr->dv_name && Name && EQ(TreePtr->dv_name, Name))
X	return(TreePtr);
X
X    if (TreePtr->dv_slaves)
X	if (Ptr = FindDeviceByName(Name, TreePtr->dv_slaves))
X	    return(Ptr);
X
X    if (TreePtr->dv_nxt)
X	if (Ptr = FindDeviceByName(Name, TreePtr->dv_nxt))
X	    return(Ptr);
X
X    return((DEVICE *) NULL);
X}
X
X/*
X * --RECURSE--
X * Find device with node id of "NodeID" in tree "treeptr".
X * This function recursively calls itself.
X */
Xextern DEVICE *FindDeviceByNodeID(NodeID, TreePtr)
X    OBPnodeid_t			NodeID;
X    DEVICE 		       *TreePtr;
X{
X    DEVICE 		       *Ptr;
X
X    if (NodeID == 0 || !TreePtr)
X	return((DEVICE *) NULL);
X
X    if (TreePtr->dv_nodeid && TreePtr->dv_nodeid == NodeID)
X	return(TreePtr);
X
X    if (TreePtr->dv_slaves)
X	if (Ptr = FindDeviceByNodeID(NodeID, TreePtr->dv_slaves))
X	    return(Ptr);
X
X    if (TreePtr->dv_nxt)
X	if (Ptr = FindDeviceByNodeID(NodeID, TreePtr->dv_nxt))
X	    return(Ptr);
X
X    return((DEVICE *) NULL);
X}
X
X/*
X * Check to see if device's dev1 and dev2 are consistant.
X * If there is a discrepancy between the two due to one
X * device not having it's value set, then set it to the
X * other device's value.  Basically this "fills in the blanks".
X */
Xstatic void CheckDevice(Dev1, Dev2)
X     DEVICE 		       *Dev1;
X     DEVICE 		       *Dev2;
X{
X#define CHECK(a,b) \
X    if (a != b) { \
X	if (a) \
X	    b = a; \
X	else if (b) \
X	    a = b; \
X    }
X
X    CHECK(Dev1->dv_type, 	Dev2->dv_type);
X    CHECK(Dev1->dv_model, 	Dev2->dv_model);
X    CHECK(Dev1->dv_modeldesc, 	Dev2->dv_modeldesc);
X    CHECK(Dev1->dv_desclist, 	Dev2->dv_desclist);
X    CHECK(Dev1->dv_unit, 	Dev2->dv_unit);
X    CHECK(Dev1->dv_addr, 	Dev2->dv_addr);
X    CHECK(Dev1->dv_prio, 	Dev2->dv_prio);
X    CHECK(Dev1->dv_vec, 	Dev2->dv_vec);
X    CHECK(Dev1->dv_devspec, 	Dev2->dv_devspec);
X    CHECK(Dev1->dv_master, 	Dev2->dv_master);
X    CHECK(Dev1->dv_nodeid, 	Dev2->dv_nodeid);
X
X#undef CHECK
X}
X
X/*
X * --RECURSE--
X * Add a device to a device list.
X */
Xextern int AddDevice(Device, TreePtr)
X    DEVICE 		       *Device;
X    DEVICE 		      **TreePtr;
X{
X    register DEVICE 	       *master = NULL, *mp = NULL;
X    DEVICE		       *fdev;
X
X    if (!Device || !TreePtr) {
X	Error("Invalid parameter passed to AddDevice()");
X	return(-1);
X    }
X
X    /*
X     * Make sure device hasn't already been added
X     */
X    if ((fdev = FindDeviceByName(Device->dv_name, *TreePtr)) ||
X	(fdev = FindDeviceByNodeID(Device->dv_nodeid, *TreePtr))) {
X	if (Debug) 
X	    printf("AddDevice: Device '%s' already exists; master = '%s'\n",
X		   Device->dv_name, (master) ? master->dv_name : "?");
X	/*
X	 * Assume that the new device has more/better info than the
X	 * existing device.
X	 */
X	if (Device->dv_model)
X	    fdev->dv_model = Device->dv_model;
X	if (Device->dv_modeldesc)
X	    fdev->dv_modeldesc = Device->dv_modeldesc;
X	if (Device->dv_desclist)
X	    fdev->dv_desclist = Device->dv_desclist;
X	return(-1);
X    }
X
X    if (Device->dv_name)
X	Device->dv_name = strdup(Device->dv_name);
X
X    /*
X     * If the device has a master, find the master device.
X     * If one doesn't exist in the tree, then add it by recursively
X     * calling this function.
X     */
X    if (Device->dv_master) {
X	if (*TreePtr) {
X	    master = FindDeviceByNodeID(Device->dv_master->dv_nodeid,*TreePtr);
X	    if (!master)
X		master = FindDeviceByName(Device->dv_master->dv_name,*TreePtr);
X	    if (master && EQ(master->dv_name, Device->dv_master->dv_name))
X		/* Check and fix any differences in info between master's */
X		CheckDevice(master, Device->dv_master);
X	} else
X	    master = NULL;
X	if (!master) {
X	    if (AddDevice(Device->dv_master, TreePtr) != 0) {
X		if (Debug) Error("Cannot add master '%s' to device tree.", 
X				 Device->dv_name);
X		return(-1);
X	    }
X	    master = Device->dv_master;
X	}
X    } else {
X	if (!*TreePtr)
X	    *TreePtr = NewDevice((DEVICE *)NULL);
X	master = *TreePtr;
X    }
X
X    if (master->dv_name)
X	master->dv_name = strdup(master->dv_name);
X
X    if (master->dv_slaves) {
X	/* Add to existing list of slaves */
X	for (mp = master->dv_slaves; mp && mp->dv_nxt; mp = mp->dv_nxt);
X	mp->dv_nxt = Device;
X    } else
X	/* Create first slave */
X	master->dv_slaves = Device;
X
X    return(0);
X}
X
X/*
X * Get device data tab entry for "name"
X */
Xextern DEVDATATAB *GetDevDataTab(Name)
X    char 		       *Name;
X{
X    extern DEVDATATAB 	 	DevDataTab[];
X    register int 		i;
X
X    if (!Name)
X	return((DEVDATATAB *) NULL);
X
X    for (i = 0; DevDataTab[i].ddt_name; ++i)
X	if (DevDataTab[i].ddt_flags & DDT_LENCMP) {
X	    if (EQN(Name, DevDataTab[i].ddt_name, 
X		    strlen(DevDataTab[i].ddt_name)))
X		return(&DevDataTab[i]);
X	} else {
X	    if (EQ(Name, DevDataTab[i].ddt_name)) 
X		return(&DevDataTab[i]);
X	}
X
X    return((DEVDATATAB *) NULL);
X}
X
X/*
X * Create a device entry for a generic device
X */
Xextern DEVICE *ProbeGeneric(Name, DevData, DevDataTab)
X     /*ARGSUSED*/
X    char 		       *Name;
X    DEVDATA 		       *DevData;
X    DEVDATATAB	 	       *DevDataTab;
X{
X    DEVICE		       *Device;
X
X    /*
X     * DT_GENERIC devices MUST be marked alive to proceed
X     */
X    if (DevDataTab->ddt_type == DT_GENERIC && 
X	!(FLAGS_ON(DevData->dd_flags, DD_IS_ALIVE) ||
X	  FLAGS_ON(DevData->dd_flags, DD_MAYBE_ALIVE)))
X	return((DEVICE *) NULL);
X
X    Device = NewDevice((DEVICE *) NULL);
X    if (Name)
X	Device->dv_name = strdup(Name);
X    else
X	Device->dv_name = strdup(MkDevName(DevData->dd_devname, 
X					   DevData->dd_devunit,
X					   DevDataTab->ddt_type,
X					   DevDataTab->ddt_flags));
X    Device->dv_type = DevDataTab->ddt_type;
X    Device->dv_model = DevDataTab->ddt_model;
X    Device->dv_unit = DevData->dd_devunit;
X    Device->dv_nodeid = DevData->dd_nodeid;
X    Device->dv_modeldesc = DevDataTab->ddt_desc;
X    Device->dv_master = MkMasterFromDevData(DevData);
X
X    return(Device);
X}
X
X/*
X * Search for and call an appropriate probe function for this 
X * device
X */
Xextern DEVICE *ProbeDevice(DevData, TreePtr)
X    DEVDATA 		       *DevData;
X    DEVICE 		      **TreePtr;
X{
X    register DEVDATATAB        *pddt;
X    register char 	       *Name = NULL;
X    DEVICE 		       *ProbeUnknown();
X
X    if (pddt = GetDevDataTab(DevData->dd_devname)) {
X	if ((*pddt->ddt_probe) == NULL) {
X	    if (Debug) printf("Device %s doesn't have a probe routine.\n",
X			      pddt->ddt_name);
X	    return((DEVICE *) NULL);
X	}
X
X	Name = MkDevName(DevData->dd_devname, DevData->dd_devunit,
X			 pddt->ddt_type, pddt->ddt_flags);
X	if (FindDeviceByName(Name, *TreePtr)) {
X	    if (Debug) printf("Device %s already exists.\n", Name);
X	    return((DEVICE *) NULL);
X	}
X	return((*pddt->ddt_probe)(Name, DevData, pddt));
X    }
X
X    /*
X     * The device is unknown to us.  If it's definetly alive,
X     * return a minimal device entry for it.  If it's not alive,
X     * ignore it.
X     */
X    if (DoPrintUnknown && DevData->dd_devname && 
X	FLAGS_ON(DevData->dd_flags, DD_IS_ALIVE))
X	return(ProbeUnknown(Name, DevData));
X
X    if (Debug)
X	printf("Device `%s' is not defined.\n", ARG(DevData->dd_devname));
X
X    return((DEVICE *) NULL);
X}
X
X
X/*
X * Make a master device from a DevData controller
X */
Xextern DEVICE *MkMasterFromDevData(DevData)
X    DEVDATA 		       *DevData;
X{
X    register DEVICE 	       *Device = NULL;
X    register DEVDATATAB        *ddt;
X    int 			type = 0;
X    int 			flags = 0;
X
X    if (DevData->dd_ctlrname) {
X	Device = NewDevice(NULL);
X	if (ddt = GetDevDataTab(DevData->dd_ctlrname)) {
X	    type = ddt->ddt_type;
X	    flags = ddt->ddt_flags;
X	    Device->dv_model = ddt->ddt_model;
X	    Device->dv_modeldesc = ddt->ddt_desc;
X	}
X	Device->dv_name = MkDevName(DevData->dd_ctlrname,
X				    DevData->dd_ctlrunit, 
X				    type, flags);
X    }
X
X    return(Device);
X}
X
X/*
X * Make the file name of the raw device
X */
Xextern char *GetRawFile(Name, Part)
X    char 		       *Name;
X    char 		       *Part;
X{
X    static char 		rfile[BUFSIZ];
X
X    if (!Name)
X	return((char *) NULL);
X
X    (void) sprintf(rfile, "/dev/r%s%s", Name, (Part) ? Part : "");
X
X    return(rfile);
X}
X
X/*
X * Make the file name of the character device
X */
Xextern char *GetCharFile(Name, Part)
X    char 		       *Name;
X    char 		       *Part;
X{
X    static char 		file[BUFSIZ];
X
X    if (!Name)
X	return((char *) NULL);
X
X    (void) sprintf(file, "/dev/%s%s", Name, (Part) ? Part : "");
X
X    return(file);
X}
X
X/*
X * Make device name
X */
Xextern char *MkDevName(Name, Unit, Type, DdtFlags)
X    char 		       *Name;
X    int 			Unit;
X    int 			Type;
X    int 			DdtFlags;
X{
X    static char			Buf[BUFSIZ];
X
X    /*
X     * Don't attach unit number if this is a pseudo device.
X     */
X    if (Unit < 0 || Type == DT_PSEUDO || Type == DT_NONE || 
X	(DdtFlags & DDT_NOUNIT))
X	sprintf(Buf, "%s", Name);
X    else
X	sprintf(Buf, "%s%d", Name, Unit);
X
X    return(strdup(Buf));
X}
X
X/*
X * Create a minimal device type for an unknown device.
X */
Xextern DEVICE *ProbeUnknown(Name, DevData)
X    /*ARGSUSED*/
X    char 		       *Name;
X    DEVDATA 		       *DevData;
X{
X    DEVICE		       *Device;
X
X    Device = NewDevice((DEVICE *) NULL);
X    Device->dv_name = strdup(MkDevName(DevData->dd_devname, 
X				       DevData->dd_devunit,
X				       -1, 0));
X    Device->dv_type = DT_GENERIC;
X    Device->dv_unit = DevData->dd_devunit;
X    Device->dv_nodeid = DevData->dd_nodeid;
X    AddDevDesc(Device, "unknown device type", NULL, DA_APPEND);
X    Device->dv_master = MkMasterFromDevData(DevData);
X
X    return(Device);
X}
X
X/*
X * Make a nice looking frequency string.
X */
Xextern char *FreqStr(freq)
X    u_long			freq;
X{
X    static char			buff[BUFSIZ];
X
X    if (freq > MHERTZ)
X	(void) sprintf(buff, "%d MHz", freq / MHERTZ);
X    else
X	(void) sprintf(buff, "%d Hz", freq);
X
X    return(buff);
X}
END_OF_FILE
if test 28265 -ne `wc -c <'devices.c'`; then
    echo shar: \"'devices.c'\" unpacked with wrong size!
fi
# end of 'devices.c'
fi
if test -f 'obp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'obp.c'\"
else
echo shar: Extracting \"'obp.c'\" \(33301 characters\)
sed "s/^X//" >'obp.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: obp.c,v 1.30 1994/02/11 19:03:33 mcooper Exp mcooper $";
X#endif
X
X/*
X * Open Boot PROM (OBP) routines
X */
X
X#include "defs.h"
X#include <nlist.h>
X
X#if	defined(HAVE_OPENPROM)
X
X#if SUNOS == 5
X#	include <sys/openprom.h>
X#	include <sys/ddi.h>
X#	include <sys/sunddi.h>
X#	include <sys/ddi_impldefs.h>
X#	define DEVI_CHILD(dev)		dev->devi_child
X#	define DEVI_SIBLING(dev)	dev->devi_sibling
X#	define DEVI_UNIT(dev)		dev->devi_instance
X#	define DEVI_NODEID(dev)		dev->devi_nodeid
X#	define DEVI_EXISTS(dev)		(dev->devi_addr && dev->devi_ops)
X#else
X#	include <sun/openprom.h>
X#	define DEVI_CHILD(dev)		dev->devi_slaves
X#	define DEVI_SIBLING(dev)	dev->devi_next
X#	define DEVI_UNIT(dev)		dev->devi_unit
X#	define DEVI_NODEID(dev)		0 /* No such member */
X#	define DEVI_EXISTS(dev)		dev->devi_driver
X#endif	/* SUNOS == 5 */
X
X#define OBP_IS_BOOL(tp)		(tp->obpt_key[strlen(tp->obpt_key)-1] == '?' \
X				 || tp->obpt_value[0] == C_NULL)
X/*
X * OBPio_t is used to do I/O with openprom.
X */
Xtypedef union {
X    char			opio_buff[OPROMMAXPARAM];
X    struct openpromio		opio_oprom;
X} OBPio_t;
X
X/*
X * OBPtable_t is used to store properties for OBP node.
X */
Xtypedef struct _obptable {
X    char		        obpt_key[OPROMMAXPARAM];
X    char		        obpt_value[OPROMMAXPARAM];
X    struct _obptable	       *obpt_next;
X} OBPtable_t;
X
X/*
X * Various declarations
X */
Xextern char		 	OpenPROMSYM[];
Xtypedef struct dev_info		MYdev_info_t;
Xstatic int 			OBPKtraverse();
Xstatic kvm_t		       *kd = NULL;
Xstatic long			CpuClockFreq = 0;
X
X/*
X * Get the root (top) node from the OBP.
X */
Xstatic MYdev_info_t *OBPKgetRoot()
X{
X    static struct nlist		nlistbuf;
X    struct nlist	       *nlptr;
X    static MYdev_info_t	 	Root, *PtrRoot;
X    u_long 			Addr;
X
X    if (!kd)
X	if (!(kd = KVMopen()))
X	    return((MYdev_info_t *) NULL);
X
X    if ((nlptr = KVMnlist(kd, OpenPROMSYM, &nlistbuf)) == NULL)
X	return((MYdev_info_t *) NULL);
X
X    if (CheckNlist(nlptr))
X	return((MYdev_info_t *) NULL);
X
X    /*
X     * Read pointer to "top_devinfo" from kernel
X     */
X    Addr = nlptr->n_value;
X    if (KVMread(kd, Addr, (char *) &PtrRoot, 
X		sizeof(struct dev_info *), FALSE)) {
X	if (Debug) Error("Cannot read openprom devinfo pointer from kernel");
X	return((MYdev_info_t *) NULL);
X    }
X
X    if (KVMread(kd, (u_long)PtrRoot, (char *)&Root, 
X		sizeof(MYdev_info_t), FALSE)) {
X	if (Debug) Error("Cannot read openprom devinfo root from kernel");
X	return((MYdev_info_t *) NULL);
X    }
X
X    return(&Root);
X}
X
X/*
X * Build device tree by reading the Open Boot PROM from the kernel.
X */
Xstatic int OBPKbuild(TreePtr)
X    DEVICE 		      **TreePtr;
X{
X    MYdev_info_t	       *Root;
X
X    if (!(Root = OBPKgetRoot()))
X	return(-1);
X
X    return(OBPKtraverse(Root, NULL, TreePtr));
X}
X
X/*
X * Cleanup an OBP node name.
X */
Xextern char *OBPcleanName(Name, FullClean)
X    char		       *Name;
X    int				FullClean;
X{
X    register char	       *cp;
X    register char	       *end;
X    register int		len;
X    static char			buff[BUFSIZ];
X    char		       *shortman;
X
X    if (!Name || !Name[0])
X	return((char *) NULL);
X
X    (void) strcpy(buff, Name);
X
X    /*
X     * Remove all trailing spaces
X     */
X    end = &buff[strlen(buff)-1];
X    for (cp = end; cp > &buff[0] && *cp == ' '; --cp);
X    if (cp != end && cp && *++cp == ' ')
X	*cp = C_NULL;
X
X    if (FullClean) {
X	/*
X	 * Change '-' to ' '
X	 * Change '_' to '/' (for SunOS 5.x)
X	 */
X	for (cp = &buff[0]; cp && *cp; ++cp) {
X	    if (*cp == '-')
X		*cp = ' ';
X	    else if (*cp == '_')
X		*cp = '/';
X	}
X
X	/*
X	 * Skip over initial wording up to ','.  e.g. "SUNW,4/25" -> "4/25".
X	 */
X	if (cp = index(buff, ','))
X	    ++cp;
X	else
X	    cp = buff;
X    } else
X	cp = buff;
X
X    /*
X     * Remove manufacturer part of name.
X     * If shortman is "Sun" and Name is "Sun 4/25",
X     * change Name to "4/25".
X     */
X    if (shortman = GetManShort()) {
X	len = strlen(shortman);
X	if (EQN(cp, shortman, len) && strlen(cp) > len+2 && cp[len] == ' ') {
X	    cp += strlen(shortman);
X	    while (cp && *cp && *cp == ' ')
X		++cp;
X	}
X    }
X
X    return(strdup(cp));
X}
X
X/*
X * Check an OpenPROM device.
X */
Xstatic int OBPKcheckDevice(DevInfo, Parent, TreePtr)
X    MYdev_info_t		*DevInfo;
X    MYdev_info_t		*Parent;
X    DEVICE 		       **TreePtr;
X{
X    static DEVDATA 		 DevData;
X    DEVICE 			*Device;	
X
X    /* Make sure devdata is clean */
X    BZERO(&DevData, sizeof(DEVDATA));
X    DevData.dd_devunit 		= -1;
X    DevData.dd_slave 		= -1;
X    DevData.dd_ctlrunit 	= -1;
X    DevData.dd_devnum 		= -1;
X
X    /* Set what we know */
X    if (DevInfo && DEVI_NODEID(DevInfo) != -1)
X	DevData.dd_nodeid = DEVI_NODEID(DevInfo);
X
X    if (DevInfo && DevInfo->devi_name && DevInfo->devi_name[0]) {
X	DevData.dd_devname = OBPcleanName(DevInfo->devi_name, FALSE);
X	/*
X	 * If we have a parent, we're not the ROOT node.
X	 * Otherwise we are the ROOT node.
X	 * If so, we set the unit number to -1
X	 * to avoid a bug in SunOS 4.x.
X	 */
X	if (Parent)
X	    DevData.dd_devunit = DEVI_UNIT(DevInfo);
X	else
X	    DEVI_UNIT(DevInfo) = -1;
X    }
X    if (Parent && Parent->devi_name && Parent->devi_name[0]) {
X	DevData.dd_ctlrname = OBPcleanName(Parent->devi_name, FALSE);
X	DevData.dd_ctlrunit = DEVI_UNIT(Parent);
X    }
X    /* 
X     * OpenPROM nodes that have a driver ALWAYS exist.
X     * Some nodes may exist, without a driver, however.
X     */
X    if (DEVI_EXISTS(DevInfo))
X	DevData.dd_flags |= DD_IS_ALIVE;
X
X#if	SUNOS == 5
X    /*
X     * Get device number
X     */
X    if (DevInfo->devi_minor) {
X	static struct ddi_minor_data	minor;
X
X	if (KVMread(kd, (u_long) DevInfo->devi_minor, (char *) &minor,
X		    sizeof(struct ddi_minor_data), FALSE) == 0 &&
X	    minor.type == DDM_MINOR)
X	    DevData.dd_devnum = minor.ddm_dev;
X    }
X#endif	/* SUNOS == 5 */
X
X    if (Debug) {
X	printf("OPENPROM: Found \"%s\" Node %d (Unit %d Dev %d) ",
X	       ARG(DevData.dd_devname), DevInfo->devi_nodeid,
X	       DevData.dd_devunit, DevData.dd_devnum);
X	printf("on \"%s\" (Unit %d)%s\n",
X	       ARG(DevData.dd_ctlrname), DevData.dd_ctlrunit,
X	       (DevData.dd_flags & DD_IS_ALIVE) ? " [ALIVE]" : "");
X    }
X
X#if	SUNOS == 4
X    /*
X     * XXX Avoid hanging SLC & ELC machines which don't have floppy disks.
X     */
X    if (DevData.dd_devname && EQ(DevData.dd_devname, "fd")) {
X#if	defined(CPU_SUN4C_20)
X	if (CpuType == CPU_SUN4C_20) return;
X#endif	/* CPU_SUN4C_20 */
X#if	defined(CPU_SUN4C_25)
X	if (CpuType == CPU_SUN4C_25) return;
X#endif	/* CPU_SUN4C_25 */
X#if	defined(CPU_SUN4C_30)
X	if (CpuType == CPU_SUN4C_30) return;
X#endif	/* CPU_SUN4C_30 */
X    }
X#endif	/* SUNOS == 4 */
X
X    /* Probe and add device */
X    if (TreePtr && (Device = (DEVICE *) ProbeDevice(&DevData, TreePtr)))
X	AddDevice(Device, TreePtr);
X}
X
X/*
X * Recursively traverse and descend the OpenPROM devinfo tree.
X */
Xstatic int OBPKtraverse(DevPtr, Parent, TreePtr)
X    MYdev_info_t		*DevPtr;
X    MYdev_info_t		*Parent;
X    DEVICE 		       **TreePtr;
X{
X    static char 		 Name[BUFSIZ];
X    MYdev_info_t		*Ptr;
X
X    /*
X     * If node name is a valid pointer, read the name from kernel space
X     * and call probe routine to handle checking the device.
X     */
X    if (DevPtr->devi_name) {
X	if (KVMread(kd, (u_long) DevPtr->devi_name, (char *) Name, 
X		    sizeof(Name), TRUE)) {
X	    if (Debug) Error("Cannot read openprom device name.");
X	    Name[0] = C_NULL;
X	} else {
X	    DevPtr->devi_name = (char *) strdup(Name);
X	    OBPKcheckDevice(DevPtr, Parent, TreePtr);
X	}
X    }
X
X    /*
X     * If this node has children, read the child data from kernel space
X     * and DESCEND.
X     */
X    if (DEVI_CHILD(DevPtr)) {
X	Ptr = (MYdev_info_t *) xcalloc(1, sizeof(MYdev_info_t));
X	if (KVMread(kd, (u_long) DEVI_CHILD(DevPtr), (char *) Ptr,
X		    sizeof(MYdev_info_t), FALSE)) {
X	    Error("Cannot read openprom slave data for %s.", Name);
X	} else {
X	    DEVI_CHILD(DevPtr) = (MYdev_info_t *) Ptr;
X	    OBPKtraverse(DEVI_CHILD(DevPtr), DevPtr, TreePtr);
X	}
X    }
X
X    /*
X     * If this node has a sibling, read the sibling data from kernel space
X     * and TRAVERSE.
X     */
X    if (DEVI_SIBLING(DevPtr)) {
X	Ptr = (MYdev_info_t *) xcalloc(1, sizeof(MYdev_info_t));
X	if (KVMread(kd, (u_long) DEVI_SIBLING(DevPtr), (char *) Ptr,
X		    sizeof(MYdev_info_t), FALSE)) {
X	    Error("Cannot read openprom next data for %s.", Name);
X	} else {
X	    DEVI_SIBLING(DevPtr) = (MYdev_info_t *) Ptr;
X	    OBPKtraverse(DEVI_SIBLING(DevPtr), Parent, TreePtr);
X	}
X    }
X
X    return(0);
X}
X
X/*
X * Get next OBP node id using "what" as what to get.
X */
Xstatic OBPnodeid_t OBPIOnext(NodeID, obp_fd, What)
X    OBPnodeid_t		        NodeID;
X    int				obp_fd;
X    int				What;
X{
X    OBPio_t			opio;
X    struct openpromio	       *op;
X    int			       *idptr;
X
X    op = &(opio.opio_oprom);
X    idptr = (OBPnodeid_t *) (op->oprom_array);
X    BZERO(opio.opio_buff, sizeof(opio.opio_buff));
X    *idptr = NodeID;
X    op->oprom_size = sizeof(opio.opio_buff);
X
X    if (ioctl(obp_fd, What, op) < 0) {
X	if (Debug) Error("OBP ioctl %s failed: %s.", 
X			 (What == OPROMNEXT) ? "OPROMNEXT" : "OPROMCHILD", 
X			 SYSERR);
X	return(0);
X    }
X
X    return(*((OBPnodeid_t *)op->oprom_array));
X}
X
X/*
X * Determine if opvalue is a string or not.
X */
Xstatic int IsString(opvalue, opsize)
X    char		       *opvalue;
X    int				opsize;
X{
X    register int		i;
X
X    for (i = 0; i < opsize - 1; ++i) {
X	if (opvalue[i] == C_NULL)
X	    return(0);
X	if (iscntrl(opvalue[i]) || !isascii(opvalue[i]))
X	    return(0);
X    }
X
X    return(1);
X}
X
Xstatic char *GetLongValStr(String)
X    char		       *String;
X{
X    static char			buff[BUFSIZ];
X    long			lval;
X    long		       *lptr;
X    long			nval;
X
X    lval = strtol(String, (char **)NULL, 0);
X    lptr = (long *) &String[0];
X    nval = *lptr;
X    (void) sprintf(buff, "%u", (u_long) nval);
X
X    return(buff);
X}
X
X/*
X * Decode an OBP value into a printable string.
X */
Xstatic char *OBPdecodeval(opvalue, opsize)
X    char		       *opvalue;
X    int				opsize;
X{
X    static char			buff[BUFSIZ];
X    static char			buff2[2];
X    register int		i;
X
X    if (opsize == 0 || !opvalue)
X	return((char *) NULL);
X
X    if (IsString(opvalue, opsize)) {
X	(void) strcpy(buff, opvalue);
X	return(buff);
X    } else {
X	if (opsize > 4) {
X	    (void) strcpy(buff, "0x");
X	    for (i = 0; i < opsize; ++i) {
X		if (i > 0 && ((i % 4) == 0))
X		    (void) strcat(buff, ".0x");
X		(void) sprintf(buff2, "%02x", opvalue[i] & 0xff);
X		(void) strcat(buff, buff2);
X	    }
X	} else
X	    (void) strcpy(buff, GetLongValStr(opvalue));
X	return(buff);
X    }
X}
X
X/*
X * Get the property value of propname from the OBP.
X */
Xstatic char *OBPgetpropval(propname, obp_fd)
X    char		       *propname;
X    int				obp_fd;
X{
X    static OBPio_t		opio;
X    struct openpromio	       *op;
X
X    op = &(opio.opio_oprom);
X    op->oprom_size = sizeof(opio.opio_buff);
X    (void) strcpy(op->oprom_array, propname);
X
X    if (ioctl(obp_fd, OPROMGETPROP, op) < 0) {
X	if (Debug) Error("OBP ioctl OPROMGETPROP failed for '%s': %s.", 
X			 propname, SYSERR);
X	return((char *)NULL);
X    }
X
X    if (op->oprom_size == -1) {
X	if (Debug) Error("OBP no data available for '%s'.", propname);
X	return((char *)NULL);
X    }
X
X    /*
X     * op->oprom_array points at opio.opio_buff where the results
X     * really live.
X     */
X    return(OBPdecodeval(op->oprom_array, op->oprom_size));
X}
X
X/*
X * Create and copy a OBPtable_t
X */
Xstatic OBPtable_t *CopyOBPtable(old)
X    OBPtable_t	       *old;
X{
X    OBPtable_t	       *new;
X
X    new = (OBPtable_t *) xmalloc(sizeof(OBPtable_t));
X    BCOPY((char *)old, (char *)new, sizeof(OBPtable_t));
X
X    return(new);
X}
X
X/*
X * Get all OBP properteries for the current OBP node and return
X * a table of the results.
X */
Xstatic OBPtable_t *OBPIOgetproptab(obp_fd)
X    int				obp_fd;
X{
X    static OBPio_t		opio;
X    struct openpromio	       *op;
X    static OBPtable_t	       *OBPtable = NULL;
X    static OBPtable_t		tab;
X    register OBPtable_t        *tptr, *tabptr;
X    register char	       *cp;
X    register int		found;
X
X    op = &(opio.opio_oprom);
X    BZERO(opio.opio_buff, sizeof(opio.opio_buff));
X
X    /*
X     * Mark all previously allocated table entries as available
X     */
X    if (OBPtable)
X	for (tptr = OBPtable; tptr; tptr = tptr->obpt_next)
X	    tptr->obpt_key[0] = tptr->obpt_value[0] = C_NULL;
X
X    for ( ; ; ) {
X	/*
X	 * Get next property
X	 */
X	op->oprom_size = sizeof(opio.opio_buff);
X	if (ioctl(obp_fd, OPROMNXTPROP, op) < 0) {
X	    if (Debug) Error("OBP ioctl OPROMNXTPROP failed: %s.", SYSERR);
X	    return((OBPtable_t *) NULL);
X	}
X
X	/*
X	 * We're done
X	 */
X	if (!op->oprom_size)
X	    break;
X
X	if (op->oprom_size >= sizeof(tab.obpt_key)) {
X	    if (Debug) Error("Openprom key \"%s\" too large for buffer.",
X			     op->oprom_array);
X	    continue;
X	}
X	(void) strcpy(tab.obpt_key, op->oprom_array);
X	tab.obpt_value[0] = C_NULL;
X
X	/*
X	 * Get the property value
X	 */
X	if (cp = OBPgetpropval(op->oprom_array, obp_fd)) {
X	    if (strlen(cp) >= sizeof(tab.obpt_value)) {
X		if (Debug) Error("Openprom value \"%s\" too large for buffer.",
X				 cp);
X		continue;
X	    }
X	    (void) strcpy(tab.obpt_value, cp);
X	}
X
X	/*
X	 * Add this entry to the linked list.
X	 * We try to use all previously allocated members of the linked
X	 * list.  If none are available, we create a new member and add
X	 * it to the list.  Allocated, but unused members have empty
X	 * obpt_key and obpt_value strings.
X	 */
X	tab.obpt_next = NULL;
X	if (OBPtable) {
X	    for (tptr = OBPtable, found = FALSE; 
X		 tptr && tptr->obpt_next && !found;
X		 tptr = tptr->obpt_next) {
X
X		/*
X		 * See if this is an unused, but allocated entry
X		 */
X		if (tptr->obpt_key[0] == C_NULL &&
X		    tptr->obpt_value[0] == C_NULL) {
X		    tab.obpt_next = tptr->obpt_next;
X		    BCOPY((char *) &tab, (char *) tptr, sizeof(tab));
X		    found = TRUE;
X		}
X	    }
X	    /*
X	     * If we didn't find an unused entry slot, then create a new one
X	     */
X	    if (!found)
X		tptr->obpt_next = CopyOBPtable(&tab);
X	} else
X	    OBPtable = CopyOBPtable(&tab);
X    }
X
X    return(OBPtable);
X}
X
X/*
X * Get OBP device data tab entry for "name"
X */
Xextern DEVDATATAB *OBPGetDevDataTab(Name)
X    char 		       *Name;
X{
X    extern DEVDATATAB 	 	OBPdevices[];
X    register int 		i;
X
X    for (i = 0; OBPdevices[i].ddt_name; ++i)
X	if (OBPdevices[i].ddt_flags & DDT_LENCMP) {
X	    if (EQN(Name, OBPdevices[i].ddt_name, 
X		    strlen(OBPdevices[i].ddt_name)))
X		return(&OBPdevices[i]);
X	} else {
X	    if (EQ(Name, OBPdevices[i].ddt_name)) 
X		return(&OBPdevices[i]);
X	}
X
X    return((DEVDATATAB *) NULL);
X}
X
X/*
X * Get the CPU model.
X *
X * The model is based upon the type of CPU and the clock frequency
X * of the CPU.
X */
Xstatic char *OBPgetCPUmodel(cputype, OBPtable, clockfreqptr)
X    char		       *cputype;
X    OBPtable_t		       *OBPtable;
X    long		       *clockfreqptr;
X{
X    register OBPtable_t	       *tptr;
X    long 			clockfreq = 0;
X    register int		i;
X    extern NAMETAB		CPUtypes[];
X    static char			Buff[BUFSIZ];
X
X    /*
X     * See if this node has it's own clock frequency
X     */
X    for (tptr = OBPtable; tptr; tptr = tptr->obpt_next) {
X	if (!tptr->obpt_key[0])
X	    break;
X
X	if (EQ(tptr->obpt_key, OBPK_CLOCKFREQ))
X	    clockfreq = strtol(tptr->obpt_value, (char **)NULL, 0);
X    }
X
X    /*
X     * No individual clock frequency, so we use the "global"
X     * clock freqency that (hopefully) was set earlier.
X     */
X    if (!clockfreq)
X	clockfreq = CpuClockFreq;
X
X    /*
X     * Set the frequency we're using so our caller can use it.
X     */
X    if (clockfreq && clockfreqptr)
X	*clockfreqptr = clockfreq;
X
X    /*
X     * Scan the CPU types table looking for an entry that has
X     * the same type name and the same clock frequency.
X     */
X    for (i = 0; CPUtypes[i].name; ++i)
X	if (EQ(CPUtypes[i].name, cputype)) {
X	    if (CPUtypes[i].value == 0) {
X		(void) sprintf(Buff, "%s %s", 
X			       FreqStr(clockfreq), CPUtypes[i].valuestr);
X		return(strdup(Buff));
X	    } else if ((clockfreq / MHERTZ) == CPUtypes[i].value)
X		return(CPUtypes[i].valuestr);
X	}
X
X    return((char *)NULL);
X}
X
X/*
X * Expand and OBP key string into something more easily read.
X */
Xstatic char *OBPexpandKey(string)
X    char		       *string;
X{
X    register char	       *cp;
X    register int		len;
X    static char			buff[BUFSIZ];
X
X    if (!string)
X	return((char *)NULL);
X
X    (void) strcpy(buff, string);
X
X    /* Capitolize first letter */
X    buff[0] = toupper(buff[0]);
X
X    for (cp = &buff[0]; cp && *cp; ++cp) {
X	if (*cp == '-' || *cp == '_') {
X	    *cp++ = ' ';
X	    if (*cp)
X		*cp = toupper(*cp);
X	}
X    }
X
X    /* Remove ending '?' */
X    len = strlen(buff);
X    if (buff[len-1] == '?')
X	buff[len-1] = C_NULL;
X
X    return(buff);
X}
X
X/*
X * Get a nice informative string describing OBPtab information.
X */
Xstatic char *OBPgetOBPinfo(OBPtab)
X    OBPtable_t		       *OBPtab;
X{
X    register int		i;
X    extern NAMETAB		OBPinfo[];
X    static char			buff[BUFSIZ];
X    char		       *FoundKey = NULL;
X
X    buff[0] = C_NULL;
X
X    /*
X     * Try to see if this is one of the types of OBP info
X     * that we want to use a more descriptive text than
X     * the key itself.
X     */
X    for (i = 0; OBPinfo[i].name && !FoundKey; ++i)
X	if (EQ(OBPinfo[i].name, OBPtab->obpt_key))
X	    FoundKey = OBPinfo[i].valuestr;
X
X    if (!FoundKey)
X	FoundKey = OBPexpandKey(OBPtab->obpt_key);
X
X    if (OBP_IS_BOOL(OBPtab))
X	(void) strcat(buff, "Has ");
X    (void) strcat(buff, FoundKey);
X    if (!OBP_IS_BOOL(OBPtab)) {
X	(void) strcat(buff, " is ");
X	if (EQ(OBPtab->obpt_key, OBPK_CLOCKFREQ))
X	    (void) strcat(buff, FreqStr(strtol(OBPtab->obpt_value,
X					       (char **)NULL, 0)));
X	else
X	    (void) strcat(buff, OBPtab->obpt_value);
X    }
X
X    return(buff);
X}
X
X/*
X * Fix an OBP node name to be compatable with the
X * conventions used in SunOS 5.x.
X *
X * i.e. All '/' characters are mapped to '_'.
X */
Xstatic char *OBPfixNodeName(string)
X    char		       *string;
X{
X    register char	       *cp;
X    static char			buff[BUFSIZ];
X
X    (void) strcpy(buff, string);
X    cp = buff;
X    while (cp = index(cp, '/'))
X	*cp++ = '_';
X
X    return(buff);
X}
X
X/*
X * Get (make) name of a CPU
X */
Xextern char *GetCpuName(ncpus, cpuid)
X    int			       *ncpus;
X    int				cpuid;
X{
X    static char			buff[BUFSIZ];
X
X    (void) sprintf(buff, "cpu%d", (cpuid >= 0) ? cpuid : (*ncpus)++);
X
X    return(buff);
X}
X
X/*
X * Probe a CPU using OBP info.
X */
Xextern DEVICE *OBPprobeCPU(NodeID, ParentID, OBPtable, TreePtr)
X    OBPnodeid_t			NodeID;
X    OBPnodeid_t			ParentID;
X    OBPtable_t		       *OBPtable;
X    DEVICE		      **TreePtr;
X{
X    register OBPtable_t	       *tptr;
X    DEVICE		       *Device;
X    DEVICE		       *fdev;
X    register char	       *cp;
X    register int		i;
X    static char			buff[BUFSIZ];
X    static int			ncpus = 0;
X    int				cpuid = -1;
X    char		       *cpumodel = NULL;
X    long			clockfreq = 0;
X
X    if (!(Device = NewDevice(NULL)))
X	return((DEVICE *)NULL);
X
X    if (Debug) {
X	(void) sprintf(buff, "Node ID is %d", NodeID);
X	AddDevDesc(Device, buff, NULL, DA_APPEND);
X    }
X
X    for (tptr = OBPtable; tptr; tptr = tptr->obpt_next) {
X	if (!tptr->obpt_key[0])
X	    break;
X
X	/*
X	 * See if this is the CPU type
X	 */
X	if (EQ(OBPK_NAME, tptr->obpt_key)) {
X	    cpumodel = tptr->obpt_value;
X	    Device->dv_model = OBPgetCPUmodel(cpumodel, OBPtable, &clockfreq);
X	    continue;
X	} else if (EQ(tptr->obpt_key, OBPK_CPUID))
X	    cpuid = (int) strtol(tptr->obpt_value, (char **)NULL, 0);
X	else if (EQ(tptr->obpt_key, OBPK_DEVTYPE) ||
X		 EQ(tptr->obpt_key, OBPK_CLOCKFREQ))
X	    continue;
X
X	AddDevDesc(Device, OBPgetOBPinfo(tptr), NULL, DA_APPEND);
X    }
X
X    if (cpumodel) {
X	if (clockfreq)
X	    (void) sprintf(buff, "%s %s", FreqStr(clockfreq), cpumodel);
X	else
X	    (void) strcpy(buff, cpumodel);
X	AddDevDesc(Device, buff, NULL, DA_INSERT|DA_PRIME);
X	/*
X	 * This must be an unknown type of CPU
X	 */
X	if (!Device->dv_model)
X	    Device->dv_model = PrimeDesc(Device);
X    }
X
X    Device->dv_type = DT_CPU;
X    Device->dv_nodeid = NodeID;
X    if (cp = GetCpuName(&ncpus, cpuid))
X	Device->dv_name = strdup(cp);
X
X    /*
X     * If no device by our name exists try to find a device
X     * with a name which matches our CPU Model.  This should
X     * be the root device node.  If so, make our device name
X     * match the root device node name, so AddDevice() will 
X     * add our info to the root device node later.
X     */
X    if (TreePtr && *TreePtr &&
X	!FindDeviceByName(Device->dv_name, *TreePtr)) {
X
X	fdev = FindDeviceByName(cpumodel, *TreePtr);
X	if (!fdev) {
X	    if (Debug) printf("Cannot find CPU device <%s>\n", cpumodel);
X	    cp = OBPfixNodeName(cpumodel);
X	    if (!EQ(cp, cpumodel))
X		fdev = FindDeviceByName(cp, *TreePtr);
X	} else
X	    if (Debug) printf("Found CPU device <%s>\n", cpumodel);
X	if (fdev && !fdev->dv_master)
X	    Device->dv_name = fdev->dv_name;
X    }
X
X    return(Device);
X}
X
X/*
X * Get part description information using a model (part) name.
X */
Xextern PARTINFO *GetPartInfo(PartName)
X    char		       *PartName;
X{
X    extern PARTINFO		PARTtable[];
X    register int		i;
X    register char	       *cp;
X
X    for (i = 0; PARTtable[i].pt_part; ++i) {
X	if (EQN(PARTtable[i].pt_part, PartName, strlen(PARTtable[i].pt_part)))
X	    return(&PARTtable[i]);
X	/* Try it without the manufacturer part of part name */
X	if ((cp = index(PARTtable[i].pt_part, ',')) && 
X	    EQN(++cp, PartName, strlen(cp)))
X	    return(&PARTtable[i]);
X    }
X
X    return((PARTINFO *) NULL);
X}
X
X/*
X * This is for the SPARCcenter 2000 and SPARCserver 1000.
X *
X * If this device has a board number, then we make a "fake"
X * device called OBP_SYSBOARD that we insert in between the
X * Device and it's logical/current Master.
X */
Xstatic void OBPsetBoard(Device, BoardNum, TreePtr)
X    DEVICE		       *Device;
X    int				BoardNum;
X    DEVICE		      **TreePtr;
X{
X    static char			BoardName[BUFSIZ];
X    register DEVICE	       *DevPtr;
X    register DEVICE	       *SaveDev;
X    register DEVICE	       *LastDev;
X    register DEVICE	       *OldMaster = NULL;
X    register DEVICE	       *Master = NULL;
X    DEVDATATAB		       *DevData = NULL;
X
X    if (BoardNum < 0 || !Device)
X	return;
X
X    (void) sprintf(BoardName, "%s%d", OBP_SYSBOARD, BoardNum);
X
X    /*
X     * Find the Old Master
X     */
X    if (Device->dv_master) {
X	OldMaster = FindDeviceByNodeID(Device->dv_master->dv_nodeid, 
X				       *TreePtr);
X	if (!OldMaster)
X	    OldMaster = FindDeviceByName(Device->dv_master->dv_name, 
X					 *TreePtr);
X    }
X
X    /*
X     * If the Master (sysboard) device doesn't exit, create one.
X     */
X    if (!(Master = FindDeviceByName(BoardName, *TreePtr))) {
X	Master = NewDevice(NULL);
X	Master->dv_name = strdup(BoardName);
X	Master->dv_unit = BoardNum;
X	if (DevData = GetDevDataTab(OBP_SYSBOARD)) {
X	    Master->dv_model = DevData->ddt_model;
X	    Master->dv_modeldesc = DevData->ddt_desc;
X	    Master->dv_type = DevData->ddt_type;
X	}
X	if (OldMaster) {
X	    Master->dv_mastername = OldMaster->dv_name;
X	    Master->dv_master = OldMaster;
X	}
X	AddDevice(Master, TreePtr);
X    }
X
X    /*
X     * Insert sysboard between Device and it's logical Master.
X     */
X    if (OldMaster) {
X	Master->dv_master = OldMaster;
X
X	/*
X	 * Find Device in OldMaster and remove it.
X	 */
X	SaveDev = NULL;
X	for (DevPtr = OldMaster->dv_slaves, LastDev = DevPtr; DevPtr; 
X	     LastDev = DevPtr, DevPtr = DevPtr->dv_nxt) {
X
X	    if (!EQ(DevPtr->dv_name, Device->dv_name))
X		continue;
X
X	    SaveDev = DevPtr;
X	    LastDev->dv_nxt = DevPtr->dv_nxt;
X	    break;
X	}
X
X	/*
X	 * Add SaveDev back to new Master
X	 */
X	SaveDev->dv_nxt = NULL;
X	if (Master->dv_slaves) {
X	    for (DevPtr = Master->dv_slaves; DevPtr && DevPtr->dv_nxt;
X		 DevPtr = DevPtr->dv_nxt);
X	    DevPtr->dv_nxt = SaveDev;
X	} else
X	    Master->dv_slaves = SaveDev;
X    }
X
X    /*
X     * Update Device
X     */
X    if (Master) {
X	Device->dv_mastername = Master->dv_name;
X	Device->dv_master = Master;
X    }
X}
X
X/*
X * Decode memory string into number of MBYTES.
X */
Xstatic int OBPGetMemSize(MemStr)
X    char		       *MemStr;
X{
X    register char	       *cp;
X    char		       *MemBuff;
X    u_long			Amt = 0;
X
X    if (strchr(MemStr, '.')) {
X	MemBuff = strdup(MemStr);
X	for (cp = strtok(MemBuff, "."); cp; cp = strtok((char *)NULL, "."))
X	    Amt += strtol(cp, (char **) NULL, 0);
X	(void) free(MemBuff);
X    } else
X	Amt = strtol(MemStr, (char **) NULL, 0);
X
X    return(Amt / MBYTES);
X}
X
X/*
X * Decode memory string into memory groups and add as a dev description.
X */
Xstatic void OBPSetMemGrps(Device, MemStr)
X    DEVICE		       *Device;
X    char		       *MemStr;
X{
X    static char			Buff[BUFSIZ];
X    char			Str[100];
X    register char	       *cp;
X    char		       *MemBuff;
X    int				GrpNum = 0;
X
X    if (!strchr(MemStr, '.'))
X	return;
X
X    Buff[0] = C_NULL;
X    MemBuff = strdup(MemStr);
X    for (cp = strtok(MemBuff, "."); cp; cp = strtok((char *)NULL, ".")) {
X	(void) sprintf(Str, "#%d=%s", GrpNum++, 
X		       GetSizeStr(strtol(cp, (char **) NULL, 0), BYTES));
X	if (Buff[0] == C_NULL)
X	    strcpy(Buff, Str);
X	else {
X	    strcat(Buff, ", ");
X	    strcat(Buff, Str);
X	}
X    }
X    (void) free(MemBuff);
X
X    AddDevDesc(Device, Buff, "Memory Groups", DA_APPEND);
X}
X
X/*
X * Probe an unknown entity using OBP.
X */
Xextern DEVICE *OBPprobeUnknown(NodeID, ParentID, OBPtable, TreePtr)
X    OBPnodeid_t			NodeID;
X    OBPnodeid_t			ParentID;
X    OBPtable_t		       *OBPtable;
X    DEVICE		      **TreePtr;
X{
X    register OBPtable_t	       *tptr;
X    DEVICE		       *Device = NULL;
X    register char	      **cpp;
X    static char			buff[BUFSIZ];
X    int				DevID = -1;
X    int				BoardNum = -1;
X    char		       *NodeName = NULL;
X    char		       *Part = NULL;
X    PARTINFO		       *PartInfo = NULL;
X    int				MemSize = 0;
X
X    /*
X     * First see if we can find this device by it's OBP node ID
X     */
X    if (NodeID && TreePtr)
X	Device = FindDeviceByNodeID(NodeID, *TreePtr);
X
X    for (tptr = OBPtable; tptr; tptr = tptr->obpt_next) {
X	if (!tptr->obpt_key[0])
X	    break;
X
X	if (EQ(OBPK_NAME, tptr->obpt_key))
X	    NodeName = tptr->obpt_value;
X    }
X
X    /*
X     * Try to find the device by name.   This usually only
X     * works for the root "system" node and a few others.
X     */
X    if (!Device && NodeName && TreePtr)
X	Device = FindDeviceByName(NodeName, *TreePtr);
X
X    /*
X     * Didn't find it.
X     */
X    if (!Device)
X	return((DEVICE *)NULL);
X
X    /*
X     * Get descriptive and other info
X     */
X    for (tptr = OBPtable; tptr; tptr = tptr->obpt_next) {
X	if (!tptr->obpt_key[0])
X	    break;
X
X	/*
X	 * Skip these
X	 */
X	if (EQ(tptr->obpt_key, OBPK_NAME))
X	    continue;
X	else if (EQ(tptr->obpt_key, OBPK_MODEL))
X	    Part = tptr->obpt_value;
X	else if (EQ(tptr->obpt_key, OBPK_BOARD))
X	    BoardNum = strtol(tptr->obpt_value, (char **) NULL, 0);
X	else if (EQ(tptr->obpt_key, OBPK_DEVICEID))
X	    DevID = strtol(tptr->obpt_value, (char **) NULL, 0);
X	else if (EQ(tptr->obpt_key, OBPK_SIZE) && 
X		 EQ(NodeName, OBPK_MEMUNIT)) {
X	    MemSize = OBPGetMemSize(tptr->obpt_value);
X	    OBPSetMemGrps(Device, tptr->obpt_value);
X	} else if (EQ(tptr->obpt_key, OBPK_KEYBOARD))
X	    Device->dv_slaves = ProbeKbd((DEVICE **)NULL);
X
X	AddDevDesc(Device, OBPgetOBPinfo(tptr), NULL, DA_APPEND);
X    }
X
X    /*
X     * Handle special cases
X     */
X    if (MemSize && Device->dv_model) {
X	(void) sprintf(buff, "%d MB %s", MemSize, Device->dv_model);
X	Device->dv_model = strdup(buff);
X    }
X    if (BoardNum >= 0)
X	OBPsetBoard(Device, BoardNum, TreePtr);
X
X    /*
X     * Add information to existing Device.
X     */
X
X    if (Part) {
X	PartInfo = GetPartInfo(Part);
X	if (PartInfo) {
X	    Device->dv_model = PartInfo->pt_name;
X	    AddDevDesc(Device, PartInfo->pt_desc, NULL, DA_INSERT|DA_PRIME);
X	} else if (Device->dv_model) {
X	    (void) sprintf(buff, "%s (%s)", Device->dv_model, Part);
X	    Device->dv_model = strdup(buff);
X	} else
X	    Device->dv_model = strdup(Part);
X    }
X
X    return((DEVICE *)NULL);
X}
X
X/*
X * Check over an OBP node.
X */
Xstatic char *OBPIOcheckNode(NodeID, obp_fd, ParentName, ParentID, TreePtr)
X    OBPnodeid_t			NodeID;
X    int				obp_fd;
X    char		       *ParentName;
X    OBPnodeid_t			ParentID;
X    DEVICE		      **TreePtr;
X{
X    OBPtable_t		       *OBPtable;
X    register OBPtable_t	       *tptr;
X    static int			first = TRUE;
X    static char			MyName[BUFSIZ];
X    static char			buff[BUFSIZ];
X    DEVDATATAB		       *devtab = NULL;
X    DEVICE		       *device = NULL;
X    DEVICE		       *master = NULL;
X
X    /*
X     * Get all the properties for the current node.
X     */
X    if (!(OBPtable = OBPIOgetproptab(obp_fd)))
X	return((char *)NULL);
X
X    /*
X     * Iterate over all the properties looking for interesting properties
X     * or until we find the device type.  If the device type is one which
X     * we found in our probe list, go ahead and probe it.
X     */
X    MyName[0] = C_NULL;
X    for (tptr = OBPtable; tptr; tptr = tptr->obpt_next) {
X	/*
X	 * Have we reached the end of the valid list?
X	 */
X	if (!tptr->obpt_key[0])
X	    break;
X
X	if (Debug) printf("OBPcheckNode: NodeID %d <%s> = <%s> (0x%x)\n",
X			  NodeID,
X			  tptr->obpt_key, tptr->obpt_value,
X			  atol(tptr->obpt_value));
X
X	/*
X	 * If this is the first node and this property is the Clock Frequency
X	 * then save it for later use by the individual CPUs.
X	 */
X	if (first && !CpuClockFreq && EQ(tptr->obpt_key, OBPK_CLOCKFREQ))
X	    CpuClockFreq = strtol(tptr->obpt_value, (char **)NULL, 0);
X
X	if (EQ(tptr->obpt_key, OBPK_DEVTYPE))
X	    devtab = OBPGetDevDataTab(tptr->obpt_value);
X
X	if (EQ(tptr->obpt_key, OBPK_NAME) && tptr->obpt_value[0])
X	    (void) strcpy(MyName, tptr->obpt_value);
X    }
X
X    if (devtab)
X	device = (*devtab->ddt_probe)(NodeID, ParentID, OBPtable, TreePtr);
X
X    if (!device)
X	device = OBPprobeUnknown(NodeID, ParentID, OBPtable, TreePtr);
X
X    if (device) {
X	/*
X	 * Find or create of Master
X	 */
X	if (!device->dv_master) {
X	    master = FindDeviceByNodeID(ParentID, *TreePtr);
X	    if (!master && ParentName) {
X		master = NewDevice(NULL);
X		master->dv_name = strdup(ParentName);
X		master->dv_nodeid = ParentID;
X	    }
X	    device->dv_master = master;
X	}
X	device->dv_nodeid = NodeID;
X	AddDevice(device, TreePtr);
X    }
X
X    first = FALSE;
X
X    return((device) ? device->dv_name : ((MyName[0]) ? MyName : (char *)NULL));
X}
X
X/*
X * Traverse OBP I/O nodes
X */
Xstatic int OBPIOtraverse(NodeID, obp_fd, ParentName, ParentID, TreePtr)
X    OBPnodeid_t		        NodeID;
X    int				obp_fd;
X    char		       *ParentName;
X    OBPnodeid_t		        ParentID;
X    DEVICE		      **TreePtr;
X{
X    OBPnodeid_t		        NewID;
X    char		       *MyName;
X    char		       *cp;
X
X    if (cp = OBPIOcheckNode(NodeID, obp_fd, ParentName, ParentID, TreePtr))
X	MyName = strdup(cp);
X
X    if (NewID = OBPIOnext(NodeID, obp_fd, OPROMCHILD))
X	OBPIOtraverse(NewID, obp_fd, MyName, NodeID, TreePtr);
X
X    if (NewID = OBPIOnext(NodeID, obp_fd, OPROMNEXT))
X	OBPIOtraverse(NewID, obp_fd, ParentName, ParentID, TreePtr);
X
X    return(0);
X}
X
X/*
X * Build devices based on what we find using raw I/O calls
X * to the OBP.
X */
Xstatic int OBPIObuild(TreePtr)
X    DEVICE		      **TreePtr;
X{
X    int				obp_fd;
X    int				status;
X
X    /*
X     * Note: Only one process at a time can open _PATH_OPENPROM.
X     */
X    if ((obp_fd = open(_PATH_OPENPROM, O_RDONLY)) < 0) {
X	if (Debug) Error("Cannot open \"%s\": %s.", _PATH_OPENPROM, SYSERR);
X	return(-1);
X    }
X
X    status = OBPIOtraverse(OBPIOnext((OBPnodeid_t) 0, obp_fd, OPROMNEXT),
X			   obp_fd, (char *)NULL, 0, TreePtr);
X    (void) close(obp_fd);
X
X    return(status);
X}
X
X/*
X * Find and build devices based on what we find from the OBP
X * both from the kernel and the OPENPROM itself.
X */
Xextern int BuildOpenPROM(TreePtr)
X    DEVICE		      **TreePtr;
X{
X    int				found = 1;
X
X    if (OBPKbuild(TreePtr) == 0)
X	found = 0;
X
X    if (OBPIObuild(TreePtr) == 0)
X	found = 0;
X
X    return(found);
X}
X
X/*
X * Get the CPU type by reading and returning the name of the
X * root (top) OBP node from the kernel.
X */
Xstatic char *OBPKgetCpuType()
X{
X    MYdev_info_t	       *Root;
X    static char			Name[BUFSIZ];
X
X    if (!(Root = OBPKgetRoot()))
X	return((char *) NULL);
X    
X    if (!Root->devi_name) {
X	if (Debug) Error("OBP Root node does not have a name.");
X	return((char *) NULL);
X    }
X
X    /*
X     * Read the name from kernel space.
X     */
X    if (KVMread(kd, (u_long) Root->devi_name, (char *) Name, 
X		sizeof(Name), TRUE)) {
X	if (Debug) Error("Cannot read OBP root device name.");
X	return((char *) NULL);
X    }
X
X    if (Name && *Name)
X	return(Name);
X    else
X	return((char *) NULL);
X}
X
X/*
X * Get system model type from OBP directly.
X */
Xstatic char *OBPIOgetCpuType()
X{
X    int				obp_fd;
X    char		       *Name;
X
X    /*
X     * Note: Only one process at a time can open _PATH_OPENPROM.
X     */
X    if ((obp_fd = open(_PATH_OPENPROM, O_RDONLY)) < 0) {
X	if (Debug) Error("Cannot open \"%s\": %s.", _PATH_OPENPROM, SYSERR);
X	return((char *) NULL);
X    }
X
X    Name = OBPIOcheckNode(OBPIOnext((OBPnodeid_t) 0, obp_fd, OPROMNEXT),
X			  obp_fd, (char *) NULL, (OBPnodeid_t) 0, 
X			  (DEVICE *) NULL);
X
X    (void) close(obp_fd);
X
X    return(Name);
X}
X
X/*
X * Get system CPU type from OBP.
X */
Xextern char *OBPGetCpuType()
X{
X    char		       *Name;
X
X    /*
X     * First try getting it from the kernel, if that
X     * fails, then query the OBP directly.
X     */
X    Name = OBPKgetCpuType();
X    if (!Name)
X	Name = OBPIOgetCpuType();
X
X    if (Name)
X	return(OBPcleanName(Name, TRUE));
X    else
X	return((char *) NULL);
X}
X
X#endif	/* HAVE_OPENPROM */
END_OF_FILE
if test 33301 -ne `wc -c <'obp.c'`; then
    echo shar: \"'obp.c'\" unpacked with wrong size!
fi
# end of 'obp.c'
fi
echo shar: End of archive 5 \(of 5\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
