Newsgroups: comp.sources.unix
From: mcooper@usc.edu (Michael A. Cooper)
Subject: v28i076: sysinfo-2.1.2 - Show system information, V2.1.2, Part03/05
References: <1.772126523.28031@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: mcooper@usc.edu (Michael A. Cooper)
Posting-Number: Volume 28, Issue 76
Archive-Name: sysinfo-2.1.2/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 5)."
# Contents:  ChangeLog defs.h netif.c os-aix.c os-ultrix.c sysinfo.c
# Wrapped by vixie@gw.home.vix.com on Mon Jun 20 08:33:21 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'ChangeLog' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ChangeLog'\"
else
echo shar: Extracting \"'ChangeLog'\" \(14094 characters\)
sed "s/^X//" >'ChangeLog' <<'END_OF_FILE'
XThu Feb 17 19:00:08 1994  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Version 2.1.2
X
X	* Update list of RS/6000 model types.  <pack@acd.ucar.edu>
X
X	* Use host_info() to get number of CPUs for NeXTStep.
X
X	* Fix ostype to identify NeXTStep 3.x hosts more portable.
X
XFri Feb 11 10:31:53 1994  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Version 2.1.1
X
X	* Show memory grouping layout for those Sun OpenBoot PROM hosts
X	with such a OBP variable.
X
X	* Fix KVMread() to read only up to '\0' for string values in order
X	to avoid reading invalid memory pages which can cause Solaris 2.x
X	systems to panic.
X
XMon Jan 24 17:57:54 1994  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Version 2.1 released.
X
XSun Jan  9 13:05:01 1994  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Change sunos[45] get mount info code to first check current
X	mount info files, and then the static info in /etc/{vfstab,fstab}.
X
XSat Jan  8 20:21:13 1994  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Make device description lists (dv_desclist) dynamic and remove
X	dv_desc. 
X
XTue Dec 28 15:06:53 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Add GetSizeStr() routine to uniformly show sizes and change
X	physical and virtual memory routines to use it.
X
X	* Fix problem with total disk and disk capacity sizes being
X	reported incorrectly.
X
XThu Dec 23 15:16:19 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Add support for "metasysinfo" as TOP (William LeFebvre) does
X	per a suggesting by Marty Leisner <leisner@sdsp.mc.xerox.com>.
X
XMon Dec 20 14:21:29 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* If +terse and -version, then only show version number.
X
X	* Change "SuperSPARC Model 50 SPARCmodule" to be "SuperSPARC Model
X	51 SPARCmodule".
X
X	* For Sun OBP: If the CPU type is unknown, use the OBP info to
X	construct a name.
X
X	* Don't get geometry info for CDROM's under SUNOS4 since the info
X	returned by the CDROM driver is bogus.
X
X	* Add support for determining type of keyboard on Sun's.  Code is
X	based on xkeycaps by Jamie Zawinski (jwz@lucid.com).
X
XFri Dec 17 18:38:36 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Use "_cpu" instead of "_cpusw" for Ultrix.
X	ro@TechFak.Uni-Bielefeld.DE (Rainer Orth)
X
X	* Add support for determining virtual memory for Ultrix.
X	ro@TechFak.Uni-Bielefeld.DE (Rainer Orth)
X
X	* Fix spelling error "SCSI Initiator ID".
X
X	* Define HAVE_UNAME and HAVE_KERNELVERSION for os-ultrix.h.
X	(zins@forwiss.uni-erlangen.de)
X
X	* Change Makefile to support ${MAKE} variable in calls to sub-makes.
X
XThu Dec 16 14:17:13 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Show number of CPUs on system using sysconf(_SC_NPROCESSORS_CONF).
X
X	* Add support for print "*UNSUPPORTED*" with -debug for
X	unsupported features.
X
XWed Dec 15 15:37:21 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Version 2.0.7
X
X	* Remove support for Alliant's.
X
X	* Run system commands as userid of user who runs sysinfo instead
X	of root.
X
X	* Fix problem with AIX not seeing catalogs due to security fix in
X	2.0.6.
X
X	* Integrate disk configuration information with normal device
X	description list (dv_desclist).
X
X	* Fix printing of disk volume name under SunOS 5.
X
X	* Show size of disk drives on main description line.
X
X	* Use execve() instead of system() to execute commands.
X
XWed Nov 10 14:47:09 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Version 2.0.6
X
X	* Fix HUGE GAPING security hole.
X
XFri Oct 15 16:27:10 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Version 2.0.5
X
X	* Add support for getting SunOS 5 "Kernel Version" string.
X
X	* Make test of failure of uname be a test for -1 instead of != 0
X	to fix SunOS 5 problem.
X
XWed Oct 13 14:34:10 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Version 2.0.4
X
X	* SunOS 4.*: Avoid possibly hanging SLC and ELC machines by
X	not probing Floppy Disk devices which are not supported on
X	those machines.
X
X	* Add Sun CPUtype for "SuperSPARC Model 40 SPARCmodule".
X
X	* SunOS 4.*: Don't attempt DKIOCGCONF and DKIOCSCMD ioctl's on
X	CDROM's.  These ioctl's sometimes can cause a system crash due
X	to bugs in the CDROM (sr) driver.
X
XMon Sep 20 11:28:30 1993  Michael A. Cooper  (mcooper@zeelbezuz.usc.edu)
X
X	* Version 2.0.3
X
X	* Add support for NeXTStep 3.1 on NeXT computers.
X
XWed Jul 28 12:26:08 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Version 2.0.2
X
XTue Jul  6 17:57:28 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Add support for getting SunOS 5 to detect devices that are not
X	"seen" by SunOS until something attempts to use them.  This is 
X	especially true of tape drives and such.
X
XFri Jul  2 16:39:51 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Fix "union sunromvec" from "struct sunromvec" (sunos5).
X
XWed Jun 16 16:08:25 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Version 2.0.1
X
X	* If an open of a disk device fails, try opening it using the "s2"
X	device name since there just may not be an partition "s0" for
X	that disk.  [SunOS 5.x specific]
X
XWed Jun  9 17:36:09 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Version 2.0
X
XTue Jun  8 11:15:46 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* If OBP kernel lookup of system model fails, query OBP directly.
X	This is necessary because the root nexus for sun4d hosts under
X	SunOS 5.2 hosts is empty.
X
X	* SunOS 5.x get physical memory now works correctly.
X
X	* Cleanup physical and virtual memory functions.
X
XSun Jun  6 15:44:54 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Version 2.0alpha4
X
X	* Add support for determining amount of virtual memory.
X
XFri May 14 13:51:01 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Version 2.0alpha3
X
X	* Properly decode OBP mem-unit memory sizes.
X
X	* Handle OBP int values which have a size of > 4.
X
X	* Fix NULL deref bugs.
X
XTue Apr 20 20:05:32 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Version 2.0alpha2
X
X	* Update CPU types for DEC VAX and MIPS machines running Ultrix.
X
X	* Add support for inserting "fake" system board (sysboard) device
X	entries into device tree to simulate real system boards found
X	in SPARCcenter-2000 and SPARCserver-1000 machines.
X
XFri Apr 16 16:40:55 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Version 2.0alpha.1
X
X	* Cleanup names of OBP device nodes.
X
X	* Add -offset option to set number of spaces to offset dev info.
X
X	* Add support for determining part information based on the
X	"model" value obtained from the OBP.
X
XThu Apr 15 11:12:45 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Version 2.0alpha
X
X	* Get System Model from PROM (OBP only) if unable to determine
X	model type from kernel variable.
X
X	* Add +/-useprom to enabling getting System Model from PROM.
X
XWed Apr 14 15:29:21 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Add support for getting System Model on Sun's directly from
X	OBP since the kernel doesn't contain this information for
X	newer systems like the SPARCclassic and SPARCcenter 2000.
X
X	* Add support for getting MAC address info using DLPI.
X
XTue Apr 13 16:09:46 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Rename kvm.c to kvmlib.c and KVM.c to kvm.c
X
X	* Add support for getting info from OBP and assigning it for
X	almost any existing device.
X
XMon Apr 12 18:53:11 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Add support for getting information from Open Boot PROM (OBP).
X	This includes support for determining information about the type
X	of CPU(s) on a system.
X
X	* When adding devices, assume it's better to override older
X	information for existing devices.
X
XFri Apr  9 13:01:05 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Add support for getting serial number from idprom on Suns.
X
XThu Apr  8 18:15:28 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Move MAC code to macinfo.c
X
X	* Add network interface support for SunOS 5.x.
X
XMon Apr  5 13:46:52 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Flush stdout before Error().
X
XSun Apr  4 13:27:23 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Add frame buffer support for getting monitor info from sunos.
X
X	* Add SunOS 5.x frame buffer support.
X
X	* Add SunOS 5.x tape drive support.
X
X	* Add SunOS 5.x disk device support.
X
X	* Misc major cleanup of os-sunos4.c.
X
X	* Recombine SunOS 4.x generic disk and CDROM support.
X
X	* No longer need to hardcode Open Boot PROM root node info in
X	info-sunos.c.
X
XSat Apr  3 17:07:14 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Shift partition info left 10 spaces.
X
X	* Print alt dev name if present.
X
XFri Apr  2 16:04:57 1993  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Use sysinfo() system call to get manufacturer info if available.
X
XThu Feb 11 13:47:25 1993  Michael A. Cooper  (mcooper@crucis.usc.edu)
X
X	* Don't print PATCHLEVEL for -version if == 0.
X
X	* General porting cleanups and re-org of files and functions.
X
X	* Support for Solaris 2.x (General Info only).
X
XSat Dec 12 15:11:45 1992  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Version 1.1.0.
X
X	* Update support for Tadpole SPARCbook-1.
X
X	* Add support to MkDevName() to indicate no unit number in the
X	DevDataTab entry.
X
X	* If a device has a NULL probe routine, ignore it.
X
XTue Dec  1 20:20:57 1992  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Change order of DEVDATATAB to make it more readable.
X
X	* Print dv_desc for devices without a DevTypes entry.
X
X	* Add DT_CPU type to DevTypes.
X
X	* Add "GNP,DEI" as a sun device.
X
X	* Enable "unknown" mode by default.
X
XSun Nov 29 17:16:54 1992  Michael A. Cooper  (mcooper@nerf)
X
X	* Add support for looking up Vital Product Data (VPD) from ODM
X	under AIX.
X
X	* Replace device->dv_desc[23] with **dv_desclist.
X
XMon Nov 23 14:53:17 1992  Michael A. Cooper  (mcooper@nerf)
X
X	* New, cleaner interface to KVM and nlist functions.
X
X	* Under AIX, get amount of real memory from ODM CuAt.
X
X	* Under AIX, get system model using the ODM CuAt data.
X
XFri Nov 20 20:33:41 1992  Michael A. Cooper  (mcooper@nerf)
X
X	* Fix DevDataTab comparison problem with DDT_LENCMP devices.
X
X	* If device unit number is < 0, don't append to device name.
X
X	* Add support for looking up devices under AIX 3.x on the RS6000's.
X
X	* Add more description fields.
X
XMon Nov 16 13:42:40 1992  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Version 1.0.8
X
X	* Add TI,TMS Sun CPU type.
X
X	* Make CPU entries DT_NONE to avoid adding unit number to name.
X
XThu Nov 12 11:13:36 1992  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Version 1.0.7
X
X	* Remove extraneous ":" from many of the #ifdef's.
X
X	* Add declaration of OpenPROMTraverse().
X
X	* Fix declaration of UsageString() in options.c.
X
XMon Nov  9 12:43:51 1992  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Version 1.0.6
X
XWed Oct 28 14:27:27 1992  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Add DKC_INTEL82077 from SunOS 4.1.3.
X
XThu Oct  1 15:56:12 1992  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Add SPARCsystem 10 and SunOS 4.1.3 items.
X
XWed Aug 12 21:49:42 1992  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Version 1.0.5
X
X	* Change typical device info line from "Device <...> ." to just be
X	"<...>" for clarity/brevity.  Also no longer show Sun OpenPROM
X	system model names as "pseudo devices".
X
XThu Aug  6 19:23:09 1992  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Change OS Name of "Concentrix 2800" to be "Concentrix-2800"
X	and "NeXT Mach" to be "NeXTStep".
X
XFri Jul 31 13:33:17 1992  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Change lookup of device table entries from a string length
X	compare to a normal non-length compare.  This means devices
X	named something like "scr" won't be mistaken for "sc".
X
XChanges for Version 1.0.3:
XFri Jul 24 15:05:47 1992  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Add Sun device entries for "bf" and SCSI host adapters.
X
XMon Jul 13 13:15:04 1992  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Change /etc/cpumodel.name to /etc/sysmodel and document this in
X	the man page.
X
XThu Jul  9 16:22:45 1992  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Defining NEED_ETHER_ADDR will make things work under Ultrix 4.[01].
X
XChanges for Version 1.0.2:
XWed Jul  8 09:55:10 1992  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Update Makefile.sunos4 to make things easier for 4.0.3 users.
X
X	* Change Ultrix model name 5000/300 to be 5000/200 and changed
X	DS_MAXINE to be the 5000/20.
X
XChanges for Version 1.0.1:
XTue Jul  7 15:27:11 1992  Michael A. Cooper  (mcooper@acamar.usc.edu)
X
X	* Add customized Makefile's for each of the major supported OS's.
X
X	* Add wrapper macro for nlist declarations to make the NeXT 2.*
X	cc (gcc) compiler happy.  Fix courtesy of Andreas Stolcke 
X	<stolcke@ICSI.Berkeley.EDU>.
X
X	* Add support for Xylogics SV-{6,7}8xx IPI controller for Suns
X	from Rainer Orth (ro@TechFak.Uni-Bielefeld.DE).
X
X	* Add changes from Guy Harris:
X	Added an entry for the SPARCengine 1E (6U Eurocard based on the
X	SPARCstation 1; there are also SS2-based and, coming up, SS10-based
X	SPARCengines, although they're not VME cards).
X 
X 	Changed the description of the FPA from "Wietek FPA" to "Sun-3 FPA" (it
X	uses Weitek - not "Wietek" chips, but it's a Sun product), and expanded
X	the extra description to note that it's Weitek-based.
X	 
X	Added support for various devices on Auspex systems (which required
X	adding a hack to get around a botch in the "mb_device" table in our
X	current drivers for some of those devices).
X 
X 	Separated disks from CD-ROMS, giving each its own probe routine; the
X	disk probe routine will, if a CD-ROM in the drive happens to have a
X	label (as some Sun CD-ROMs do, and as the Auspex system software
X	distribution CD-ROM does), act as if the label is something it should
X	report (it shouldn't; for example, it should report the disk as a
X	CD-ROM, not whatever glop appears in the label).
X 
X 	Fixed "ProbeTapeDrive()" to use the no-rewind device, so that it doesn't
X	run the risk of rewinding the tape out from under somebody.
X 
X 	Put comments at the front of the probe routines for tapes and CD-ROMs to
X	indicate that they may fail even if the device exists - i.e., if there's
X	no medium in the drive, or if somebody's using the tape drive;
X	unfortunately, I don't know of a good fix for that problem.
END_OF_FILE
if test 14094 -ne `wc -c <'ChangeLog'`; then
    echo shar: \"'ChangeLog'\" unpacked with wrong size!
fi
# end of 'ChangeLog'
fi
if test -f 'defs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'defs.h'\"
else
echo shar: Extracting \"'defs.h'\" \(13947 characters\)
sed "s/^X//" >'defs.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X/*
X * $Id: defs.h,v 1.74 1994/02/11 18:55:30 mcooper Exp mcooper $
X */
X
X#ifndef __sysinfo_defs__
X#define __sysinfo_defs__ 
X
X#include <stdio.h>
X#include "os.h"
X#include "options.h"		/* Need to include options.h before errno.h */
X#include <errno.h>
X#include "version.h"
X#include "config.h"
X
X#if defined(HAVE_UNAME)
X#	include <sys/utsname.h>
X#endif	/* HAVE_UNAME */
X#if defined(HAVE_SYSINFO)
X#	include <sys/systeminfo.h>
X#endif	/* HAVE_SYSINFO */
X
X#if defined(NEED_KVM)
X#	include "kvm.h"
X#else
X#if defined(HAVE_KVM)
X#	include <kvm.h>
X#endif	/* HAVE_KVM */
X#endif	/* NEED_KVM */
X
X#if	defined(HAVE_MEMSET)
X#	define BCOPY(a,b,s)	memcpy(b,a,s)
X#	define BZERO(a,s)	memset(a,0,s)
X#else
X#	define BCOPY(a,b,s)	bcopy(a,b,s)
X#	define BZERO(a,b)	bzero(a,b)
X#endif	/* HAVE_MEMSET */
X#if	defined(HAVE_STRCHR)
X#	define index		strchr
X#	define rindex		strrchr
X#endif	/* HAVE_STRCHR */
X
X/*
X * File containing our CPU model name.  Overrides all other methods
X * for determing model name.
X */
X#if !defined(MODELFILE)
X#	define MODELFILE	"/etc/sysmodel"
X#endif
X
X/*
X * System call failure value
X */
X#if !defined(SYSFAIL)
X#	define SYSFAIL		-1
X#endif
X
X#define C_NULL			'\0'
X
X/*
X * System error numbers and message strings
X */
Xextern int errno;
X#if defined(SYSERR)
X#	undef SYSERR
X#endif
X#define SYSERR			strerror(errno)
X
X#if !defined(MAXHOSTNAMLEN)
X#	define MAXHOSTNAMLEN 	256
X#endif
X
X#define MHERTZ			1000000			/* MegaHertz */
X#define BYTES			1			/* Bytes */
X#define KBYTES			1024			/* Kilobytes */
X#define MBYTES			1048576			/* Megabytes */
X#define GBYTES			1073741824		/* Gigabytes */
X
X/*
X * Misc macros
X */
X#define EQ(a,b)			(strcasecmp(a,b)==0)
X#define EQN(a,b,n)		(strncasecmp(a,b,n)==0)
X#define ARG(s)			((s) ? s : "<null>")
X
X/*
X * CheckNlist() breaks in a variety of ways on
X * various OS's.
X */
X#if !defined(BROKEN_NLIST_CHECK)
X#	define CheckNlist(p) 	_CheckNlist(p)
X#else
X#	define CheckNlist(p) 	0
X#endif
X
X/*
X * Get nlist n_name
X */
X#if defined(__MACH__)
X#	define GetNlName(n)	(n.n_un.n_name)
X#	define GetNlNamePtr(n)	(n->n_un.n_name)
X#else
X#	define GetNlName(n)	(n.n_name)
X#	define GetNlNamePtr(n)	(n->n_name)
X#endif	/* __MACH__ */
X
X/*
X * Conversion macros
X */
X#define bytes_to_gbytes(n)	( (float) n / (float) GBYTES )
X#define bytes_to_mbytes(n)	( (float) n / (float) MBYTES )
X#define bytes_to_kbytes(n)	( (float) (n / KBYTES) )
X#define mbytes_to_bytes(n)	( (float) ( (float) n * MBYTES ) )
X#define kbytes_to_mbytes(n)	( (float) ( (float) n / KBYTES ) )
X#define kbytes_to_gbytes(n)	( (float) ( (float) n / MBYTES ) )
X#define mbytes_to_gbytes(n)	( (float) ( (float) n / KBYTES ) )
X#define nsect_to_bytes(n,s)  	( (( (float) n) / (float) (1024 / s)) * KBYTES)
X#define nsect_to_mbytes(n,s)  	( (( (float) n) / (float) (1024 / s)) / KBYTES)
X
X/*
X * Are flags f set in b?
X */
X#define FLAGS_ON(b,f)		((b != 0) && (b & f))
X
X/*
X * Verbosity levels
X */
X#define L_BRIEF			0x01		/* Briefest */
X#define L_GENERAL		0x02		/* General verbosity */
X#define L_DESC			0x04		/* Description info */
X#define L_CONFIG		0x10		/* Configuratin info */
X#define L_DEBUG			0x20		/* Debug info */
X#define L_ALL (L_BRIEF|L_GENERAL|L_DESC|L_CONFIG)
X/*
X * Verbosity macros
X */
X#define VL_BRIEF		(Level & L_BRIEF)
X#define VL_GENERAL		(Level & L_GENERAL)
X#define VL_DESC			(Level & L_DESC)
X#define VL_CONFIG		(Level & L_CONFIG)
X#define VL_ALL			(Level == L_ALL)
X#define VL_DEBUG		(Level & L_DEBUG)
X
X/*
X * OBP node ID type
X */
Xtypedef int			OBPnodeid_t;
X
X/*
X * Name list
X */
Xstruct _namelist {
X    char		       *nl_name;
X    struct _namelist	       *nl_next;
X};
Xtypedef struct _namelist namelist_t;
X
X/*
X * Show info
X */
Xtypedef struct {
X    int				Type;
X    char		       *Name;
X    char		       *Label;
X    void		      (*ShowFunc)();
X    char		     *(*GetFunc)();
X    int			       *OptCompat;
X    int				Enable;
X} SHOWINFO;
X
X/*
X * ShowInfo types (ShowInfo.Type)
X */
X#define S_GEN			1		/* General info */
X#define S_DEV			2		/* Device info */
X
X/*
X * Device description
X */
Xstruct _devdesc_t {
X    char	       *dd_label;		/* Label of description */
X    char	       *dd_desc;		/* Description */
X    int			dd_isprime;		/* Is primary description */
X    struct _devdesc_t  *dd_next;		/* Pointer to next entry */
X};
Xtypedef struct _devdesc_t devdesc_t;
X/*
X * Description Action
X */
X#define DA_APPEND	0x01			/* Append entry */
X#define DA_INSERT	0x02			/* Insert entry */
X#define DA_PRIME	0x10			/* Indicate primary */
X
X/*
X * Main Device information
X *
X * Used after device info has been obtained 
X */
Xstruct _device {
X    char		*dv_name;		/* Name (e.g. cgtwo0) */
X    char		*dv_aname;		/* Alt name */
X    char	       **dv_files;		/* Device files */
X    int			 dv_type;		/* Device type (eg DT_TAPE) */
X    char		*dv_model;		/* Model */
X    char		*dv_modeldesc;		/* Model Specific Description*/
X    devdesc_t		*dv_desclist;		/* Device Description */
X    int			 dv_unit;		/* Unit number */
X    int			 dv_addr;		/* Address */
X    int			 dv_prio;		/* Priority */
X    int			 dv_vec;		/* Vector */
X    int			 dv_nodeid;		/* ID of this node */
X    char		*dv_mastername;		/* Name of master */
X    caddr_t		*dv_devspec;		/* Device specific info */
X    struct _device	*dv_master;		/* Device controller */
X    struct _device	*dv_slaves;		/* Devices on this device */
X    struct _device	*dv_nxt;		/* Pointer to next device */
X};
Xtypedef struct _device DEVICE;
X
X/*
X * Device types (DEVICE.dv_type)
X */
X#define DT_NONE			 1		/* Sort of ignore */
X#define DT_GENERIC		 2		/* Generic Device */
X#define DT_DISKDRIVE		 3		/* Disk Drive */
X#define DT_DISKCTLR		 4		/* Disk Controller */
X#define DT_TAPEDRIVE		 5		/* Tape Drive */
X#define DT_TAPECTLR		 6		/* Tape Controller */
X#define DT_FRAMEBUFFER		 7		/* Frame Buffer */
X#define DT_NETIF		 8		/* Network Interface */
X#define DT_BUS			 9		/* System Bus */
X#define DT_PSEUDO		10		/* Pseudo Device */
X#define DT_CPU			11		/* CPU */
X#define DT_MEMORY		12		/* Memory */
X#define DT_KEYBOARD		13		/* Keyboard */
X
X/*
X * Disk type
X */
X#define DKT_GENERIC		1		/* Generic disk */
X#define DKT_CDROM		2		/* CD-ROM */
X
X/*
X * Disk Partition information.
X */
Xstruct _diskpart {
X    char		*dp_name;		/* Partition name */
X    char		*dp_mnt;		/* Mount information */
X    int			 dp_stsect;		/* Starting sector */
X    int			 dp_nsect;		/* Number of sectors */
X    struct _diskpart	*dp_nxt;		/* Pointer to next DISKPART */
X};
Xtypedef struct _diskpart DISKPART;
X
X/*
X * Disk Drive specific data
X */
Xstruct _diskdrive {
X    char		*dd_label;		/* Disk label */
X    int			 dd_unit;		/* Unit number */
X    int			 dd_slave;		/* Slave number */
X    int			 dd_dcyl;		/* # data cylinders */
X    int			 dd_pcyl;		/* # physical cylinders */
X    int			 dd_acyl;		/* # alternate cylinders */
X    int			 dd_heads;		/* Number of heads */
X    int			 dd_sect;		/* Number of sectors */
X    int			 dd_psect;		/* Number of physical sector */
X    int			 dd_promrev;		/* PROM Revision */
X    int			 dd_apc;		/* Alternates / Cyl (SCSI) */
X    int			 dd_rpm;		/* Revolutions Per Minute */
X    int			 dd_intrlv;		/* Interleave factor */
X    int			 dd_secsize;		/* Size of Sector (bytes) */
X    float		 dd_size;		/* Size of disk in bytes */
X    int			 dd_flags;		/* Info flags */
X    DEVICE		*dd_ctlr;		/* Controller disk is on */
X    struct _diskpart	*dd_part;		/* Partition information */
X    struct _diskdrive	*dd_nxt;		/* Pointer to next disk */
X};
Xtypedef struct _diskdrive DISKDRIVE;
X
X/*
X * Disk Flags (DISKDRIVE.dd_flags)
X */
X#define DF_HEXUNIT	0x01			/* Unit is prt 3 hex digits */
X
X/*
X * Generic Name/Value table
X */
Xtypedef struct {
X    int			value;			/* Value field */
X    char       	       *name;			/* Corresponding name */
X    char       	       *valuestr;		/* Value string field */
X} NAMETAB;
X
X/*
X * Generic Key/Value table
X */
Xtypedef struct {
X    long		kt_lvalue;		/* Long value field */
X    char       	       *kt_key;			/* Corresponding name */
X    char       	       *kt_svalue;		/* Value string field */
X} KEYTAB;
X
X/*
X * Part information
X */
Xtypedef struct {
X    char       	       *pt_part;		/* Part number/string */
X    char       	       *pt_name;		/* Part name */
X    char       	       *pt_desc;		/* Part description */
X} PARTINFO;
X
X/*
X * Disk Controller Table
X */
Xtypedef struct {
X    u_short		 ct_ctype;		/* Ctlr type index */
X    char		*ct_model;		/* Ctlr model name */
X    int			 ct_rdcmd;		/* Read command flag */
X} DKCTLRTAB;
X
X/*
X * FrameBuffer specific data
X */
Xtypedef struct {
X    int			 fb_height;		/* Height (in pixels) */
X    int			 fb_width;		/* Width (in pixels) */
X    int			 fb_depth;		/* Depth (bits/pixel) */
X    u_long		 fb_size;		/* Total size (in bytes) */
X    u_long		 fb_vmsize;		/* Video memory (in bytes) */
X    int			 fb_cmsize;		/* Color Map Size (#entries) */
X} FRAMEBUFFER;
X
X/*
X * Network Interface specific data
X */
Xstruct _netif {
X    char		*ni_typename;		/* Name of address type */
X    char		*ni_hostaddr;		/* Host address */
X    char		*ni_hostname;		/* Host name */
X    char		*ni_macaddr;		/* Current MAC address */
X    char		*ni_macname;		/* Current MAC name */
X    char		*ni_fmacaddr;		/* Factory MAC address */
X    char		*ni_fmacname;		/* Factory MAC name */
X    char		*ni_netaddr;		/* Network address */
X    char		*ni_netname;		/* Network name */
X    struct _netif	*ni_nxt;		/* Pointer to next element */
X};
Xtypedef struct _netif NETIF;
X
X/*
X * Address family table
X */
Xtypedef struct {
X    int			af_type;		/* Type value */
X    char	       *af_name;		/* Name value */
X    NETIF	     *(*af_getnetif)();		/* Function to get netif */
X} AFTAB;
X
X/*
X * Basic device data
X *
X * Used when searching for initial list of devices
X */
Xtypedef struct {
X    char		*dd_devname;		/* Name of device */
X    int			 dd_devunit;		/* Device specific unit # */
X    int			 dd_slave;		/* Slave number */
X    dev_t		 dd_devnum;		/* Device number */
X    char		*dd_ctlrname;		/* Name of Controller */
X    int			 dd_ctlrunit;		/* Controller # */
X    int			 dd_flags;		/* Device flags */
X    int			 dd_nodeid;		/* ID of this node */
X} DEVDATA;
X
X/*
X * Flags for DEVDATA.dd_flags
X */
X#define DD_MAYBE_ALIVE	0x1			/* Device may be alive */
X#define DD_IS_ALIVE	0x2			/* Device is alive */
X
X/*
X * Device Data Table structure
X */
Xtypedef struct {
X    char		*ddt_name;		/* Name of device */
X    char		*ddt_model;		/* Model */
X    char		*ddt_desc;		/* Description */
X    DEVICE	      *(*ddt_probe)();		/* Probe device */
X    int			 ddt_type;		/* Type of device */
X    int			 ddt_flags;		/* Flags */
X} DEVDATATAB;
X
X/*
X * Flags for DEVDATATAB.ddt_flags
X */
X#define DDT_LENCMP	0x1			/* Compare by length */
X#define DDT_NOUNIT	0x2			/* No unit number */
X
X/*
X * Declarations
X */
Xextern int 			DoPrintUnknown;
Xextern int 			Debug;
Xextern int 			Level;
Xextern int 			Terse;
Xextern int 			UseProm;
Xextern char 		       *UnSupported;
X
Xchar 			       *index();
Xchar		 	       *rindex();
Xchar 			       *strdup();
Xchar 			       *strcat();
Xchar 			       *strtok();
X
Xchar			       *itoa();
Xchar	 		       *xmalloc();
Xchar	 		       *xrealloc();
Xchar	 		       *xcalloc();
X
Xextern DEVDATATAB	       *GetDevDataTab();
Xextern DEVICE	 	       *NewDevice();
Xextern DEVICE	 	       *OBPprobeCPU();
Xextern DEVICE	 	       *ProbeDiskDrive();
Xextern DEVICE	 	       *ProbeFrameBuffer();
Xextern DEVICE	 	       *ProbeGeneric();
Xextern DEVICE	 	       *ProbeKbd();
Xextern DEVICE	 	       *ProbeNetif();
Xextern DEVICE	 	       *ProbeTapeDrive();
Xextern DEVICE 		       *FindDeviceByName();
Xextern DEVICE 		       *FindDeviceByNodeID();
Xextern DEVICE 		       *MkMasterFromDevData();
Xextern DEVICE 		       *ProbeDevice();
Xextern DEVICE 		       *ProbeUnknown();
Xextern DISKDRIVE               *NewDiskDrive();
Xextern DISKPART  	       *NewDiskPart();
Xextern DKCTLRTAB 	       *GetDkCtlrTab();
Xextern FRAMEBUFFER 	       *NewFrameBuffer();
Xextern NAMETAB	 	       *GetFBTab();
Xextern NETIF	 	       *NewNetif();
Xextern PARTINFO	 	       *GetPartInfo();
Xextern char		       *FreqStr();
Xextern char		       *GetCpuName();
Xextern char		       *GetHostName();
Xextern char		       *GetKernArch();
Xextern char		       *GetKernArchName();
Xextern char		       *GetKernelVersionStr();
Xextern char		       *GetModelName();
Xextern char		       *GetNameTabName();
Xextern char		       *GetOSNameStr();
Xextern char		       *GetOSVersionStr();
Xextern char		       *GetSerialNoStr();
Xextern char		       *GetSizeStr();
Xextern char		       *MkDevName();
Xextern char		       *OBPGetCpuType();
Xextern char		       *RunCmds();
Xextern char		       *RunTestFiles();
Xextern char	 	       *GetMemoryFromPhysmem();
Xextern char	 	       *MkDevName();
Xextern char 		       *GetAppArch();	
Xextern char 		       *GetCPU();
Xextern char 		       *GetCharFile();
Xextern char 		       *GetDiskCapacity();
Xextern char 		       *GetHostAddrs();
Xextern char 		       *GetHostAliases();
Xextern char 		       *GetHostID();
Xextern char 		       *GetKernelVersion();
Xextern char 		       *GetMan();
Xextern char 		       *GetManLong();
Xextern char 		       *GetManShort();
Xextern char 		       *GetMemory();
Xextern char 		       *GetModel();
Xextern char 		       *GetNumCPU();
Xextern char 		       *GetOSName();
Xextern char 		       *GetOSVersion();
Xextern char 		       *GetRawFile();
Xextern char 		       *GetRomVer();
Xextern char 		       *GetSerialNo();
Xextern char 		       *GetVirtMem();
Xextern char 		       *PrimeDesc();
Xextern devdesc_t	       *PrimeDescPtr();
Xextern int		        AddDevice();
Xextern void			Error();
Xextern void		        SetMacInfo();
Xextern void		        ShowDevices();
Xextern void 		        DetectDevices();
Xextern void 		        ShowGeneral();
X
Xextern namelist_t	       *NameListFind();
Xextern void 		        NameListAdd();
Xextern void 		        NameListFree();
X
X#if	defined(HAVE_KVM)
Xextern kvm_t 		       *KVMopen();
Xextern void			KVMclose();
Xextern int			KVMread();
Xextern struct nlist	       *KVMnlist();
X#endif	/* HAVE_KVM */
X
X#endif /* __sysinfo_defs__ */
END_OF_FILE
if test 13947 -ne `wc -c <'defs.h'`; then
    echo shar: \"'defs.h'\" unpacked with wrong size!
fi
# end of 'defs.h'
fi
if test -f 'netif.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'netif.c'\"
else
echo shar: Extracting \"'netif.c'\" \(11340 characters\)
sed "s/^X//" >'netif.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: netif.c,v 1.28 1994/02/11 18:30:14 mcooper Exp mcooper $";
X#endif
X
X
X/*
X * Portions of code found in this file are based on the 4.3BSD 
X * netstat(8) program.
X */
X
X/*
X * Network Interface routines
X */
X
X#include <stdio.h>
X#include "os.h"
X
X#include <fcntl.h>
X#include <nlist.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#if	defined(NEED_SOCKIO)
X#include <sys/sockio.h>
X#endif	/* NEED_SOCKIO */
X#include <sys/param.h>
X#include <sys/errno.h>
X#include <net/if.h>
X#include <netinet/in.h>
X#include <netinet/in_var.h>
X#include <netinet/if_ether.h>
X#include <netdb.h>
X
X#include "defs.h"
X
X#if	GETNETIF_TYPE == GETNETIF_IFNET
X/*
X * Network Interface symbol
X */
Xchar 				NetifSYM[] = "_ifnet";
X#endif	/* GETNETIF_IFNET */
X
X/*
X * Interface Address union
X */
Xunion {
X    struct ifaddr 	ifaddr;
X    struct in_ifaddr 	in_ifaddr;
X} 				ifaddress;
X
X/*
X * Create a DEVICE for a network interface.
X */
Xstatic DEVICE *CreateNetif(FullName, IfNet, DevData, DevDataTab)
X    char		       *FullName;
X    struct ifnet               *IfNet;
X    DEVDATA		       *DevData;
X    DEVDATATAB		       *DevDataTab;
X{
X    DEVICE		       *dev;
X
X    dev = NewDevice(NULL);
X
X    dev->dv_name 	= strdup(FullName);
X    dev->dv_type 	= DT_NETIF;
X    dev->dv_nodeid 	= DevData->dd_nodeid;
X    dev->dv_unit 	= IfNet->if_unit;
X    dev->dv_master 	= MkMasterFromDevData(DevData);
X
X#if	defined(HAVE_IF_VERSION)
X    if (IfNet->if_version && IfNet->if_version[0])
X	dev->dv_model 	= strdup(IfNet->if_version);
X    else
X#endif	/* HAVE_IF_VERSION */
X	dev->dv_model 	= DevDataTab->ddt_model;
X
X    dev->dv_modeldesc = DevDataTab->ddt_desc;
X
X    return(dev);
X}
X
X/*
X * Return the netent of the network whose address is given.
X * The address is assumed to be that of a net or subnet, not a host.
X */
Xstatic struct netent *GetNet(inaddr, mask)
X    u_long 			inaddr;
X    u_long 			mask;
X{
X    u_long 			net;
X    register u_long 		i, netaddr;
X    int 			subnetshift;
X    static struct in_addr 	in_addr;
X
X    if (in_addr.s_addr = ntohl(inaddr)) {
X	i = in_addr.s_addr;
X	if (mask == 0) {
X	    if (IN_CLASSA(i)) {
X		mask = IN_CLASSA_NET;
X		subnetshift = 8;
X	    } else if (IN_CLASSB(i)) {
X		mask = IN_CLASSB_NET;
X		subnetshift = 8;
X	    } else {
X		mask = IN_CLASSC_NET;
X		subnetshift = 4;
X	    }
X	    /*
X	     * If there are more bits than the standard mask
X	     * would suggest, subnets must be in use.
X	     * Guess at the subnet mask, assuming reasonable
X	     * width subnet fields.
X	     */
X	    while (in_addr.s_addr &~ mask)
X		mask = (long)mask >> subnetshift;
X	}
X	net = in_addr.s_addr & mask;
X	while ((mask & 1) == 0)
X	    mask >>= 1, net >>= 1;
X	netaddr = net;
X    } else {
X	netaddr = inaddr;
X    }
X
X    return(getnetbyaddr(netaddr, AF_INET));
X}
X
X/*
X * Get NETIF for an Internet address
X */
Xextern NETIF *GetNetifINET(aftab, hostaddr, maskaddr)
X    AFTAB		       *aftab;
X    struct sockaddr_in	       *hostaddr;
X    struct sockaddr_in	       *maskaddr;
X{
X    struct in_addr		in_addr;
X    struct netent 	       *np;
X    struct hostent 	       *hp;
X    struct sockaddr_in 	       *sin;
X    char		       *inet_ntoa();
X    NETIF		       *ni;
X
X    ni = NewNetif(NULL);
X
X    if (hostaddr && maskaddr) {
X	np = GetNet(htonl(hostaddr->sin_addr.s_addr), 
X		    htonl(maskaddr->sin_addr.s_addr));
X	in_addr.s_addr = ntohl(hostaddr->sin_addr.s_addr & 
X			       maskaddr->sin_addr.s_addr);
X	ni->ni_netaddr = strdup(inet_ntoa(in_addr));
X	sin = hostaddr;
X    } else {
X	np = GetNet(htonl(ifaddress.in_ifaddr.ia_subnet), 
X		    ifaddress.in_ifaddr.ia_subnetmask);
X	in_addr.s_addr = ntohl(ifaddress.in_ifaddr.ia_subnet);
X	ni->ni_netaddr = strdup(inet_ntoa(in_addr));
X	sin = (struct sockaddr_in *) &ifaddress.in_ifaddr.ia_addr;
X    }
X
X    ni->ni_hostaddr = strdup(inet_ntoa(sin->sin_addr));
X    hp = gethostbyaddr((char *) &(sin->sin_addr),
X		       sizeof(struct in_addr), AF_INET);
X
X    if (hp)
X	ni->ni_hostname = strdup(hp->h_name);
X
X    if (np)
X	ni->ni_netname = strdup(np->n_name);
X	    
X    if (aftab)
X	ni->ni_typename = aftab->af_name;
X
X    return(ni);
X}
X
X/*
X * Get NETIF for an unknown address type
X */
Xextern NETIF *GetNetifUnknown(aftab)
X    AFTAB		       *aftab;
X{
X    NETIF		       *ni = NULL;
X
X    ni = NewNetif(NULL);
X    ni->ni_hostaddr = "<unknown>";
X    if (aftab)
X	ni->ni_typename = aftab->af_name;
X
X    return(ni);
X}
X
X/*
X * Get an Address Family table entry
X */
Xstatic AFTAB *GetAFTab(type)
X    int				type;
X{
X    extern AFTAB		AFTab[];
X    register int		i;
X
X    for (i = 0; AFTab[i].af_name; ++i)
X	if (AFTab[i].af_type == type)
X	    return(&AFTab[i]);
X
X    return((AFTAB *) NULL);
X}
X
X#if	GETNETIF_TYPE == GETNETIF_IFNET
X/*
X * Get a linked list of NETIF's for each address starting at 'startaddr'.
X */
Xstatic NETIF *GetNetifAddrs(kd, startaddr, FullName, Device)
X    kvm_t		       *kd;
X    off_t			startaddr;
X    char		       *FullName;
X    DEVICE		       *Device;
X{
X    u_long			addr;
X    NETIF		       *base = NULL;
X    register NETIF	       *ni, *pni;
X    AFTAB		       *paftab;
X
X    for (addr = startaddr; addr; addr = (u_long) ifaddress.ifaddr.ifa_next) {
X	/*
X	 * Read the ifaddr structure from kernel space
X	 */
X	if (KVMread(kd, addr, (char *) &ifaddress, sizeof(ifaddress), FALSE)) {
X	    Error("cannot read if address");
X	    continue;
X	}
X
X	/*
X	 * Now get and call the Address Family specific routine
X	 * to extract a NETIF.
X	 */
X	if (paftab = GetAFTab(ifaddress.ifaddr.ifa_addr.sa_family)) {
X	    if (ni = (*paftab->af_getnetif)(paftab, NULL, NULL))
X		SetMacInfo(FullName, ni, Device);
X	} else {
X	    if (Debug) Error("Address family %d is not defined.", 
X			     ifaddress.ifaddr.ifa_addr.sa_family);
X	    continue;
X	}
X
X	/*
X	 * Add the new NETIF to the base of the linked list.
X	 */
X	if (base) {
X	    for (pni = base; pni && pni->ni_nxt; pni = pni->ni_nxt);
X	    pni->ni_nxt = ni;
X	} else {
X	    base = ni;
X	}
X    }
X
X    return(base);
X}
X
X/*
X * Query/find network interface devices and add them to devicelist
X */
Xextern DEVICE *ProbeNetif(name, DevData, DevDataTab)
X    char 		       *name;
X    DEVDATA 		       *DevData;
X    DEVDATATAB	 	       *DevDataTab;
X{
X    DEVICE 		       *dev = NULL;
X    static struct ifnet         ifnet;
X    static char 		ifname[16], FullName[17];
X    static struct nlist	        nlBuff;
X    struct nlist	       *nlptr;
X    register char	       *p;
X    u_long 		        ifnetaddr;
X    kvm_t 		       *kd;
X
X    if (Debug) printf("ProbeNetif() '%s'\n", name);
X
X    if (!(kd = KVMopen()))
X	return((DEVICE *) NULL);
X
X    /*
X     * XXX - The unused "nlBuff" is required to avoid a nextstep gcc bug.
X     */
X    if ((nlptr = KVMnlist(kd, NetifSYM, &nlBuff)) == NULL)
X	return((DEVICE *) NULL);
X
X    if (CheckNlist(nlptr))
X	return((DEVICE *) NULL);
X
X    /*
X     * Read address of ifnet structure from kernel space
X     */
X    if (KVMread(kd, nlptr->n_value, (char *) &ifnetaddr, 
X		sizeof(ifnetaddr), FALSE)) {
X	if (Debug) Error("kvm_read ifnetaddr failed");
X	KVMclose(kd);
X	return((DEVICE *) NULL);
X    }
X
X    /*
X     * Read and then check each ifnet entry we found.
X     */
X    for (; ifnetaddr; ifnetaddr = (off_t) ifnet.if_next) {
X	/*
X	 * Read the ifnet structure
X	 */
X	if (KVMread(kd, ifnetaddr, (char *)&ifnet, sizeof(ifnet), FALSE)) {
X	    if (Debug) Error("kvm_read ifnetaddr ifnet failed");
X	    continue;
X	}
X
X	/*
X	 * Read if_name from kernel space
X	 */
X	if (KVMread(kd, (u_long)ifnet.if_name, ifname, sizeof(ifname), TRUE)) {
X	    if (Debug) Error("kvm_read ifname failed");
X	    continue;
X	}
X
X	/*
X	 * Copy if_name to 'FullName' and add unit number
X	 */
X	(void) sprintf(FullName, "%s%d", ifname, ifnet.if_unit);
X
X	/*
X	 * Check to see if this is the interface we want.
X	 */
X	if (!EQ(FullName, name))
X	    continue;
X
X	/*
X	 * Create and set device
X	 */
X	dev = CreateNetif(FullName, &ifnet, DevData, DevDataTab);
X
X	/*
X	 * Get and set address info
X	 */
X	if (ifnet.if_addrlist) {
X	    NETIF 	       *ni;
X
X	    if (ni = GetNetifAddrs(kd, (off_t) ifnet.if_addrlist, 
X				   FullName, dev))
X		dev->dv_devspec = (caddr_t *) ni;
X	}
X    }
X
X    KVMclose(kd);
X
X    return(dev);
X}
X#endif	/* GETNETIF_IFNET */
X
X#if	GETNETIF_TYPE == GETNETIF_IFCONF
X/*
X * Set network address data.
X */
Xstatic int SetNetifAddrs(ifname, sock, hostaddr, maskaddr)
X    char		       *ifname;
X    int				sock;
X    struct sockaddr_in	       *hostaddr;
X    struct sockaddr_in	       *maskaddr;
X{
X    struct ifreq		ifr;
X
X    (void) strcpy(ifr.ifr_name, ifname);
X
X    /*
X     * Get address info
X     */
X    if (ioctl(sock, SIOCGIFADDR, (char *) &ifr) < 0) {
X	if (Debug) Error("%s: ioctl SIOCGIFADDR failed: %s.", ifname, SYSERR);
X	return(-1);
X    }
X    BCOPY((char *)&ifr.ifr_addr, (char *)hostaddr, sizeof(struct sockaddr_in));
X
X    /*
X     * Get the network mask
X     */
X    if (ioctl(sock, SIOCGIFNETMASK, (char *) &ifr) < 0) {
X	if (Debug) Error("%s: ioctl SIOCGIFNETMASK failed: %s.", 
X			 ifname, SYSERR);
X	return(-1);
X    }
X    BCOPY((char *)&ifr.ifr_addr, (char *)maskaddr, sizeof(struct sockaddr_in));
X
X    return(0);
X}
X
X/*
X * Query/find network interface devices and add them to devicelist
X */
Xextern DEVICE *ProbeNetif(name, DevData, DevDataTab)
X    char 		       *name;
X    DEVDATA 		       *DevData;
X    DEVDATATAB	 	       *DevDataTab;
X{
X    DEVICE 		       *dev = NULL;
X    NETIF	 	       *ni;
X    struct ifreq	       *ifreq;
X    static struct ifconf	ifconf;
X    static struct sockaddr_in	hostaddr;
X    static struct sockaddr_in	maskaddr;
X    static char			reqbuf[BUFSIZ];
X    static char			buff[BUFSIZ];
X    static int			sock = -1;
X    register int		n;
X    AFTAB		       *paftab;
X
X    if (Debug) printf("ProbeNetif() '%s'\n", name);
X
X    if (sock < 0) {
X	/*
X	 * Get list of all interfaces
X	 */
X	ifconf.ifc_len = sizeof(reqbuf);
X	ifconf.ifc_buf = reqbuf;
X
X	if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
X	    if (Debug) Error("Cannot create socket: %s.", SYSERR);
X	    return((DEVICE *)NULL);
X	}
X
X	if (ioctl(sock, SIOCGIFCONF, (char *) &ifconf) < 0) {
X	    if (Debug) Error("%s: ioctl SIOCGIFCONF failed: %s.", name,SYSERR);
X	    return((DEVICE *)NULL);
X	}
X    }
X
X    /*
X     * Iterate over all known interfaces
X     */
X    for (ifreq = ifconf.ifc_req, n = ifconf.ifc_len/sizeof(struct ifreq);
X	 --n >= 0; ifreq++) {
X
X	/*
X	 * Check to see if this is the interface we want.
X	 */
X	if (!EQ(name, ifreq->ifr_name))
X	    continue;
X
X	/*
X	 * Create and set device
X	 */
X	dev 		= NewDevice(NULL);
X	dev->dv_name 	= strdup(ifreq->ifr_name);
X	dev->dv_type 	= DT_NETIF;
X	dev->dv_nodeid 	= DevData->dd_nodeid;
X	dev->dv_unit 	= DevData->dd_devunit;
X	dev->dv_master 	= MkMasterFromDevData(DevData);
X	dev->dv_model 	= DevDataTab->ddt_model;
X	dev->dv_modeldesc = DevDataTab->ddt_desc;
X
X	/*
X	 * Set address info
X	 */
X	if (SetNetifAddrs(ifreq->ifr_name, sock, &hostaddr, &maskaddr) == 0) {
X	    /*
X	     * Now get and call the Address Family specific routine
X	     * to extract a NETIF.
X	     */
X	    if (paftab = GetAFTab(hostaddr.sin_family)) {
X		if (ni = (*paftab->af_getnetif)(paftab, &hostaddr, 
X						&maskaddr)) {
X		    SetMacInfo(name, ni, dev);
X		    dev->dv_devspec = (caddr_t *) ni;
X		}
X	    } else
X		if (Debug) Error("Address family %d is not defined.", 
X				 hostaddr.sin_family);
X	}
X
X	return(dev);
X    }
X
X    return((DEVICE *)NULL);
X}
X#endif	/* GETNETIF_IFCONF */
END_OF_FILE
if test 11340 -ne `wc -c <'netif.c'`; then
    echo shar: \"'netif.c'\" unpacked with wrong size!
fi
# end of 'netif.c'
fi
if test -f 'os-aix.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'os-aix.c'\"
else
echo shar: Extracting \"'os-aix.c'\" \(14808 characters\)
sed "s/^X//" >'os-aix.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: os-aix.c,v 1.22 1994/01/12 22:56:08 mcooper Exp mcooper $";
X#endif
X
X/*
X * AIX specific functions
X */
X
X#include "defs.h"
X#include <nl_types.h>
X#include <locale.h>
X
X
X/*
X * Get ODM Error string.
X */
Xstatic char *odmerror()
X{
X    static char odmerrstr[BUFSIZ];
X
X    if (odm_err_msg(odmerrno, &odmerrstr) != 0)
X	(void) sprintf(odmerrstr, "unknown ODM error %d", odmerrno);
X
X    return(odmerrstr);
X}
X
X/*
X * Get the value of attribute 'Attr' with name 'Name' 
X * from the Custom Attribute ODM.
X */
Xstatic char *GetAttrVal(Name, Attr)
X    char		       *Name;
X    char		       *Attr;
X{
X    static struct CuAt		CuAt;
X    static char			buff[BUFSIZ];
X    char		       *errstr = NULL;
X    int				ret;
X
X    if (odm_initialize() == -1) {
X	Error("ODM initialize failed: %s", odmerror());
X	return(-1);
X    }
X
X    (void) sprintf(buff, "attribute = '%s' and name = '%s'", Attr, Name);
X
X    ret = (int) odm_get_obj(CuAt_CLASS, buff, &CuAt, ODM_FIRST);
X    if (ret == -1)
X	errstr = odmerror();
X    else if (ret == 0)
X	errstr = "No entry found";
X
X    if (errstr) {
X	if (Debug) Error("ODM get \"%s\" from \"%s\" failed: %s",
X			 buff, CuAt_CLASS[0].classname, errstr);
X	return((char *) NULL);
X    }
X
X    return((CuAt.value[0]) ? CuAt.value : (char *) NULL);
X}
X
X/*
X * Get the PvDv ODM entry with the criteria 'Criteria'.
X */
Xstatic struct PdDv *GetPdDv(Criteria)
X    char		       *Criteria;
X{
X    static struct PdDv		PdDv;
X    char		       *errstr = NULL;
X    int				ret;
X
X    if (odm_initialize() == -1) {
X	Error("ODM initialize failed: %s", odmerror());
X	return((struct PdDv *) NULL);
X    }
X
X    ret = (int) odm_get_obj(PdDv_CLASS, Criteria, &PdDv, ODM_FIRST);
X    if (ret == -1)
X	errstr = odmerror();
X    else if (ret == 0)
X	errstr = "No entry found";
X
X    if (errstr) {
X	if (Debug) Error("ODM get \"%s\" from \"%s\" failed: %s",
X			 Criteria, PdDv_CLASS[0].classname, errstr);
X	return((struct PdDv *) NULL);
X    }
X
X    return(&PdDv);
X}
X
X/* 
X * Clean up a VPD string.  Remove initial non alpha-numeric characters
X * as well as any trailing white space.
X */
Xstatic char *CleanVPD(string)
X    char		       *string;
X{
X    register char	       *cp, *end;
X
X    while (string && *string && !isalnum(*string))
X	++string;
X
X    cp = end = &string[strlen(string) - 1];
X
X    while (cp && *cp && isspace(*cp))
X	--cp;
X
X    if (cp != end)
X	*(cp+1) = C_NULL;
X
X    return(string);
X}
X
X/*
X * Find the VPD info entry for "string".  Return a vpdinfo_t
X * entry for the matching entry and set it's "value" correctly.
X */
Xstatic vpdinfo_t *GetVPDinfo(string)
X    char		       *string;
X{
X    extern vpdinfo_t		VPDinfo[];
X    static char			buff[BUFSIZ];
X    static vpdinfo_t		vpdinfo;
X    register int		i;
X
X    for (i = 0; VPDinfo[i].code; ++i) {
X	if (strncasecmp(string, VPDinfo[i].code, strlen(VPDinfo[i].code)))
X	    continue;
X
X	vpdinfo.code = VPDinfo[i].code;
X	vpdinfo.title = VPDinfo[i].title;
X	/*
X	 * The "value" portion of "string" starts after the "code" portion.
X	 * CleanVPD() is harmful, so we need to pass it a private copy.
X	 */
X	(void) strcpy(buff, string + strlen(VPDinfo[i].code));
X	vpdinfo.value = CleanVPD(buff);
X
X	return(&vpdinfo);
X    }
X
X    if (Debug)
X	printf("Unknown VPD info \"%s\".\n", string);
X
X    return((vpdinfo_t *) NULL);
X}
X
X/*
X * Given a VPD string "vpdstr", decode it into a list of strings.
X */
Xstatic int DecodeVPD(Device, vpdstr)
X    DEVICE		       *Device;
X    char		       *vpdstr;
X{
X    static char			buff[BUFSIZ];
X    char		       *myvpdstr;
X    register char	       *cp;
X    vpdinfo_t		       *vpdinfo;
X
X    if (!vpdstr)
X	return(-1);
X
X    /* strtok() is destructive */
X    myvpdstr = strdup(vpdstr);
X
X    /*
X     * Each field in "vpdstr" is seperated by a "*", followed by
X     * the code for the field and it's value.  Looks something like:
X     *
X     *		*TM 19445*MF IBM
X     */
X    for (cp = strtok(myvpdstr, "*"); cp; cp = strtok((char *)NULL, "*")) {
X	if (!(vpdinfo = GetVPDinfo(cp)))
X	    continue;
X
X	(void) sprintf(buff, "%s is %s", vpdinfo->title, vpdinfo->value);
X	AddDevDesc(Device, buff, NULL, DA_APPEND);
X    }
X
X    if (myvpdstr)
X	(void) free(myvpdstr);
X
X    return(0);
X}
X
X/*
X * Get and decode the Vital Product Data informatin for device "Name".
X */
Xstatic int GetVPD(Device)
X    DEVICE		       *Device;
X{
X    static struct CuVPD		cuvpd;
X    static char			buff[BUFSIZ];
X    int 			ret;
X
X    if (odm_initialize() == -1) {
X	Error("ODM initialize failed: %s", odmerror());
X	return(-1);
X    }
X
X    (void) sprintf(buff, "name=%s", Device->dv_name);
X    ret = (int) odm_get_obj(CuVPD_CLASS, buff, &cuvpd, ODM_FIRST);
X    if (ret == -1) {
X	if (Debug)
X	    Error("ODM get VPD object for \"%s\" failed: %s", 
X		  Device->dv_name, odmerror());
X	return(-1);
X    } else if (ret == 0) {
X	if (Debug) 
X	    Error("No VPD information for \"%s\".", Device->dv_name);
X	return(-1);
X    }
X
X    if (Debug)
X	printf("VPD: name = '%s' type = %d VPD = '%s'\n", 
X	       cuvpd.name, cuvpd.vpd_type, cuvpd.vpd);
X
X    return(DecodeVPD(Device, cuvpd.vpd));
X}
X
X/*
X * Get the system model name.
X */
Xextern char *GetModelName()
X{
X    extern NAMETAB		ModelTab[];
X    register char	       *val, *cp;
X    register int		i, type;
X
X    if ((val = GetAttrVal(NN_SYS0, AT_MODELCODE)) == NULL) {
X	if (Debug) Error("Cannot get \"%s\" for \"%s\" from ODM.",
X			 AT_MODELCODE, NN_SYS0);
X	return((char *) NULL);
X    }
X
X    type = (int) strtol(val, NULL, 0);
X
X    if (Debug)
X	printf("System type = 0x%x\n", type);
X
X    for (i = 0; ModelTab[i].name; ++i)
X	if (type == ModelTab[i].value)
X	    return(ModelTab[i].name);
X
X    if (Debug)
X	Error("system model/type 0x%x is unknown.", type);
X
X    return((char *) NULL);
X}
X
X/*
X * Get kernel version string.
X */
Xextern char *GetKernelVersionStr()
X{
X    return(UnSupported);
X}
X
X/*
X * Get amount of physical memory from the ODM CuAt data.
X */
Xextern int GetMemoryAmount()
X{
X    register char	       *val;
X    register int		amtval;
X
X    if ((val = GetAttrVal(NN_SYS0, AT_REALMEM)) == NULL) {
X	if (Debug) Error("Cannot get \"%s\" for \"%s\" from ODM.",
X			 AT_REALMEM, NN_SYS0);
X	return((char *) NULL);
X    }
X
X    amtval = (int) strtol(val, NULL, 0);
X    return(DivRndUp(amtval, KBYTES));
X}
X
X/*
X * Get system serial number
X */
Xextern char *GetSerialNoStr()
X{
X    return(UnSupported);
X}
X
X/*
X * Get version of OS
X */
Xextern char *GetOSVersionStr()
X{
X    return(UnSupported);
X}
X
X/*
X * Get ROM Version
X */
Xextern char *GetRomVer()
X{
X    return(UnSupported);
X}
X
X/*
X * Take a device name, remove and then return the unit number.
X * e.g. Take "hdisk0", remove "0", and then return 0.
X */
Xstatic int GetUnit(Name)
X    char		       *Name;
X{
X    int				unit;
X    register char	       *cp;
X
X    for (cp = Name; cp && *cp; ++cp)
X	if (isdigit(*cp)) {
X	    unit = (int) atoi(cp);
X	    *cp = C_NULL;
X	    return(unit);
X	}
X
X    return(-1);
X}
X
X/*
X * Get the location information from CuDvPtr.
X */
Xstatic char *GetLocation(CuDvPtr)
X    struct CuDv		       *CuDvPtr;
X{
X    static char			buff[BUFSIZ];
X
X    if (CuDvPtr->location[0]) {
X	(void) sprintf(buff, "Location is %s", CuDvPtr->location);
X	return(buff);
X    }
X
X    return((char *) NULL);
X}
X
X/*
X * Get Class information.
X */
Xstatic char *GetClassInfo(CuDvPtr)
X    struct CuDv		       *CuDvPtr;
X{
X    static char			buff[BUFSIZ];
X
X    if (CuDvPtr->PdDvLn_Lvalue[0]) {
X	(void) sprintf(buff, "Class/SubClass/Type is %s", 
X		       CuDvPtr->PdDvLn_Lvalue);
X	return(buff);
X    }
X
X    return((char *) NULL);
X}
X
X/*
X * Set the description informatin for Device.
X */
Xstatic void SetDescript(Device, CuDvPtr)
X    DEVICE		       *Device;
X    struct CuDv		       *CuDvPtr;
X{
X    AddDevDesc(Device, GetLocation(CuDvPtr), NULL, DA_APPEND);
X    AddDevDesc(Device, GetClassInfo(CuDvPtr), NULL, DA_APPEND);
X    GetVPD(Device);
X}
X
X/*
X * Special routine to get memory information.
X */
Xextern DEVICE *ProbeMemory(Name, DevData, DevDataTab, CuDvPtr, PdDvPtr)
X    /*ARGSUSED*/
X    char 		       *Name;
X    DEVDATA 		       *DevData;
X    DEVDATATAB 	     	       *DevDataTab;
X    struct CuDv		       *CuDvPtr;
X    struct PdDv		       *PdDvPtr;
X{
X    DEVICE 		       *device;
X    char		       *devname;
X    char		       *cp;
X    char			buff[BUFSIZ];
X
X    if ((cp = GetAttrVal(Name, AT_SIZE)) == NULL)
X	return((DEVICE *) NULL);
X
X    device = NewDevice((DEVICE *) NULL);
X
X    (void) sprintf(buff, "%s MB Memory Card", cp);
X    device->dv_model = strdup(buff);
X
X    device->dv_name = Name;
X    device->dv_unit = DevData->dd_devunit;
X    device->dv_master = MkMasterFromDevData(DevData);
X    device->dv_type = DT_MEMORY;
X    SetDescript(device, CuDvPtr);
X
X    return(device);
X}
X
X/*
X * Get description information
X */
Xstatic char *GetDescript(CuDvPtr, PdDvPtr)
X    struct CuDv		       *CuDvPtr;
X    struct PdDv		       *PdDvPtr;
X{
X    static char			buff[BUFSIZ];
X    static char			lastcat[BUFSIZ];
X    static nl_catd		catd;
X    char		       *msg = NULL;
X    char		       *cp;
X
X    if (!PdDvPtr->catalog[0])
X	return((char *) NULL);
X
X    /* 
X     * Reuse open catalog if it's the same as the last time 
X     */
X    if ((int) catd <= 0 || !lastcat[0] || strcmp(PdDvPtr->catalog, lastcat)) {
X	if ((int) catd > 0)
X	    (void) catclose(catd);
X
X	if ((int) catd == 0) {
X	    /*
X	     * First time stuff.
X	     */
X
X	    if (putenv(ENV_NLSPATH) != 0)
X		if (Debug) Error("Cannot set environment $NLSPATH.");
X
X	    /*
X	     * If our LANG is "C", then set to our default in order to
X	     * avoid a bug in AIX that fails to find any catalogs in 
X	     * this case.
X	     */
X	    cp = getenv("LANG");
X	    if (!cp || (cp && EQ(cp, "C"))) {
X		(void) sprintf(buff, "LANG=%s", DEFAULT_LANG);
X		if (putenv(strdup(buff)) != 0)
X		    if (Debug) Error("Cannot set environment %s.", buff);
X		buff[0] = C_NULL;
X	    }
X	    (void) setlocale(LC_ALL, "");
X	}
X
X	catd = catopen(PdDvPtr->catalog, 0);
X	if ((int) catd <= 0)
X	    if (Debug) Error("Catalog open of \"%s\" failed: %s.",
X			     PdDvPtr->catalog, SYSERR);
X    }
X
X    /*
X     * Retrieve the message from the catalog
X     */
X    if ((int) catd > 0) {
X	msg = catgets(catd, PdDvPtr->setno, PdDvPtr->msgno, buff);
X	/* Save catalog name */
X	(void) strcpy(lastcat, PdDvPtr->catalog);
X    }
X
X    return((msg && *msg) ? msg : (char *) NULL);
X}
X
X/*
X * General routine to get device information from ODM.
X */
Xextern DEVICE *ProbeODM(DevData, TreePtr, CuDvPtr)
X    /*ARGSUSED*/
X    DEVDATA 		       *DevData;
X    DEVICE 		      **TreePtr;
X    struct CuDv		       *CuDvPtr;
X{
X    register DEVDATATAB        *pddt;
X    DEVICE 		       *device;
X    char		       *devname;
X    char		       *desc;
X    char		       *cp;
X    static char			buff[BUFSIZ];
X    struct PdDv		       *PdDvPtr;
X
X    devname = MkDevName(DevData->dd_devname, DevData->dd_devunit, 0, 0);
X    if (FindDeviceByName(devname, *TreePtr)) {
X	if (Debug) printf("Device %s already exists.\n", devname);
X	return((DEVICE *) NULL);
X    }
X
X    if (CuDvPtr->PdDvLn_Lvalue[0]) {
X	(void) sprintf(buff, "uniquetype='%s'", CuDvPtr->PdDvLn_Lvalue);
X	PdDvPtr = GetPdDv(buff);
X    } else {
X	if (Debug) Error("No PdDv link value for '%s'.", devname);
X	return((char *) NULL);
X    }
X
X    /*
X     * If we can't get the description for this device, then
X     * use the device specific probe routine if one is defined.
X     */
X    if ((desc = GetDescript(CuDvPtr, PdDvPtr)) == (char *) NULL) {
X	if ((pddt = GetDevDataTab(DevData->dd_devname)) && pddt->ddt_probe)
X	    return((*pddt->ddt_probe)(devname, DevData, pddt, 
X				      CuDvPtr, PdDvPtr));
X	else {
X	    if (Debug) 
X		Error("No description found for '%s'.", devname);
X	    return((DEVICE *) NULL);
X	}
X    }
X
X    device = NewDevice((DEVICE *) NULL);
X
X    device->dv_name = devname;
X    device->dv_unit = DevData->dd_devunit;
X    device->dv_master = MkMasterFromDevData(DevData);
X    device->dv_type = DT_GENERIC;
X    device->dv_model = strdup(desc);
X    SetDescript(device, CuDvPtr);
X
X    return(device);
X}
X
X/*
X * Build device tree by looking at the Object Database Manager (ODM)
X */
Xstatic int BuildODM(TreePtr)
X    DEVICE 		      **TreePtr;
X{
X    static struct CuDv		CuDv;
X    extern struct Class		CuDv_CLASS[];
X    static DEVDATA 		DevData;
X    DEVICE 		       *Dev;
X    int 			op, ret;
X
X    if (odm_initialize() == -1) {
X	Error("ODM initialize failed: %s", odmerror());
X	return(-1);
X    }
X
X    for (op = ODM_FIRST; ; op = ODM_NEXT) {
X	/*
X	 * Retrieve the object from ODM.
X	 */
X	ret = (int) odm_get_obj(CuDv_CLASS, (char *)NULL, &CuDv, op);
X	if (ret == -1) {
X	    if (Debug) Error("ODM get object \"%s\" failed: %s", 
X			     CuDv_CLASS[0].classname, odmerror());
X	    return(-1);
X	} else if (ret == 0)
X	    /*
X	     * We're done
X	     */
X	    break;
X
X	if (CuDv.status != AVAILABLE) {
X	    if (Debug) printf("Device \"%s\" is not available.\n", CuDv.name);
X	    continue;
X	}
X
X	/*
X	 * This should never happen
X	 */
X	if (CuDv.name[0] == C_NULL)
X	    continue;
X
X	/* Make sure devdata is clean */
X	bzero(&DevData, sizeof(DEVDATA));
X
X	/* Set what we know */
X	DevData.dd_devname = strdup(CuDv.name);
X	DevData.dd_devunit = GetUnit(DevData.dd_devname);
X	if (CuDv.parent[0]) {
X	    DevData.dd_ctlrname = strdup(CuDv.parent);
X	    DevData.dd_ctlrunit = GetUnit(DevData.dd_ctlrname);
X	}
X	DevData.dd_flags |= DD_IS_ALIVE;
X
X	if (Debug)
X	    printf("ODM: Found '%s' parent '%s' location '%s' uniq = '%s'\n",
X		   CuDv.name, CuDv.parent, CuDv.location, CuDv.PdDvLn_Lvalue);
X
X	/* Probe and add device */
X	if (Dev = ProbeODM(&DevData, TreePtr, &CuDv))
X	    AddDevice(Dev, TreePtr);
X    }
X
X    if (odm_terminate() != 0)
X	if (Debug) Error("ODM Terminate did not succeed.");
X
X    return(0);
X}
X
X/*
X * Build device tree using TreePtr.
X * Calls bus and method specific functions to
X * search for devices.
X */
Xextern int BuildDevicesAIX(TreePtr)
X    DEVICE 		       **TreePtr;
X{
X    int 			 Found = 1;
X
X    if (BuildODM(TreePtr) == 0)
X	Found = 0;
X
X    return(Found);
X}
X
X#include <sys/vminfo.h>
X
Xstatic char			QueryStr[] = 
X    "value = 'paging' and attribute = 'type'";
X
Xextern off_t
XGetVirtMemAmount()
X{
X    struct CuAt		       *CuAtPtr;
X    struct objlistinfo		ObjListInfo;
X    register int		i;
X    static char			DevName[BUFSIZ];
X    static struct pginfo	pginfo;
X    off_t			Amount = 0;
X
X    odm_initialize();
X    odm_set_path(_PATH_ODM);
X
X    CuAtPtr = get_CuAt_list(CuAt_CLASS, QueryStr, &ObjListInfo, 20, 1);
X    if ((int)CuAtPtr == -1) {
X	if (Debug) Error("get_CuAt_list paging info failed: %s.", SYSERR);
X	odm_terminate();
X	return(0);
X    }
X
X    for (i = 0; i < ObjListInfo.num; ++i) {
X	(void) sprintf(DevName, "/dev/%s", CuAtPtr->name);
X
X	if (swapqry(DevName, &pginfo) == -1) {
X	    if (Debug) Error("swapqry %s failed: %s.", DevName, SYSERR);
X	    continue;
X	}
X
X	Amount += (off_t) ( (pginfo.size * getpagesize() ) / KBYTES );
X    }
X
X    odm_terminate();
X
X    return(Amount);
X}
END_OF_FILE
if test 14808 -ne `wc -c <'os-aix.c'`; then
    echo shar: \"'os-aix.c'\" unpacked with wrong size!
fi
# end of 'os-aix.c'
fi
if test -f 'os-ultrix.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'os-ultrix.c'\"
else
echo shar: Extracting \"'os-ultrix.c'\" \(15694 characters\)
sed "s/^X//" >'os-ultrix.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: os-ultrix.c,v 1.30 1994/02/11 18:30:14 mcooper Exp mcooper $";
X#endif
X
X/*
X * Ultrix specific functions
X */
X
X#include "defs.h"
X#include <fcntl.h>
X#include <nlist.h>
X#include <fstab.h>
X#include <sys/types.h>
X#include <sys/param.h>
X#include <sys/fs.h>
X#include <sys/ioctl.h>
X#include <sys/buf.h>
X#include <sys/stat.h>
X
X#include <machine/cpuconf.h>
X
X#include <sys/devio.h>
X#include <sys/mtio.h>
X
X#include "info-ultrix.h"
X
X#if	defined(HAVE_UBA)
X/*
X * UBA (UniBus Adapter) specific code
X */
X#include <io/uba/ubavar.h>
X
X/*
X * Probe specific structure
X */
Xstruct _probespec {
X    struct uba_device		*uba_device;
X};
Xtypedef struct _probespec PROBESPEC;
X
X#define DV_SIZE		(sizeof(struct uba_device))
X#define CR_SIZE		(sizeof(struct uba_ctlr))
X
X/*
X * Build a device tree by searching Unibus Adapters
X */
Xstatic int BuildUBA(TreePtr)
X    DEVICE 		      **TreePtr;
X{
X    extern char		 	UniBusSYM[];
X    static struct nlist		nlistbuf;
X    struct nlist	       *nlptr;
X    static struct uba_device 	Device;
X    static struct uba_ctlr 	Ctlr;
X    static char 		CtlrName[BUFSIZ], DevName[BUFSIZ];
X    u_long 			Addr, DeviceAddr;
X    static DEVDATA 		DevData;
X    static PROBESPEC		ProbeSpec;
X    DEVICE 		       *dev;
X    kvm_t		       *kd;
X    int 			cnum;
X
X    /*
X     * Read table address from kernel
X     */
X    if (!(kd = KVMopen()))
X	return(-1);
X
X    if ((nlptr = KVMnlist(kd, UniBusSYM, &nlistbuf)) == NULL)
X	return(-1);
X
X    if (CheckNlist(nlptr))
X	return(-1);
X
X    /*
X     * Read each device table entry.  A NULL device.ui_driver
X     * indicates that we're at the end of the table.
X     */
X    for (DeviceAddr = nlptr->n_value; DeviceAddr; 
X	 DeviceAddr += DV_SIZE) {
X
X	/*
X	 * Read this device
X	 */
X	if (KVMread(kd, DeviceAddr, (char *) &Device, DV_SIZE, FALSE)) {
X	    if (Debug) 
X		Error("Cannot read unibus device from address 0x%x.", 
X		      DeviceAddr);
X	    KVMclose(kd);
X	    return(-1);
X	}
X
X	/*
X	 * See if we're done.
X	 */
X	if (!Device.ui_driver)
X	    break;
X
X	/*
X	 * Get the device name
X	 */
X	DevName[0] = C_NULL;
X	if (Addr = (u_long) Device.ui_devname) {
X	    if (KVMread(kd, Addr, (char *) DevName, sizeof(DevName), TRUE)) {
X		if (Debug)
X		    Error("Cannot read device name from address 0x%x.", Addr);
X		continue;
X	    }
X	}
X
X	/*
X	 * Get the controller info
X	 */
X	CtlrName[0] = C_NULL;
X	cnum = -1;
X	if (Addr = (u_long) Device.ui_mi) {
X	    if (KVMread(kd, Addr, (char *) &Ctlr, CR_SIZE, FALSE)) {
X		if (Debug) 
X		    Error("Cannot read controller from address 0x%x.", Addr);
X	    } else {
X		/*
X		 * Get the controller name
X		 */
X		if (Addr = (u_long) Ctlr.um_ctlrname) {
X		    if (KVMread(kd, Addr, CtlrName, sizeof(CtlrName), TRUE)) {
X			if (Debug)
X			    Error(
X		  "Cannot read controller name from driver address 0x%x.",
X				  Addr);
X			continue;
X		    }
X		}
X		cnum = Ctlr.um_ctlr;
X	    }
X	}
X
X	if (Debug)
X	    printf("build_unibus(): Found '%s' on '%s'.\n", DevName, CtlrName);
X
X	/* Make sure devdata is clean */
X	bzero(&DevData, sizeof(DEVDATA));
X
X	/* Set what we know */
X	if (DevName[0]) {
X	    DevData.dd_devname = strdup(DevName);
X	    DevData.dd_devunit = Device.ui_unit;
X	}
X	if (CtlrName[0]) {
X	    DevData.dd_ctlrname = strdup(CtlrName);
X	    DevData.dd_ctlrunit = cnum;
X	}
X
X	/* 
X	 * Unibus devices should always exist.
X	 */
X	if (Device.ui_alive)
X	    DevData.dd_flags |= DD_IS_ALIVE;
X
X	ProbeSpec.uba_device = &Device;
X
X	/* Probe and add device */
X	if (dev = (DEVICE *) ProbeDevice(&DevData, TreePtr, &ProbeSpec))
X	    AddDevice(dev, TreePtr);
X    }
X
X    KVMclose(kd);
X
X    return(0);
X}
X#endif	/* HAVE_UBA */
X
X/*
X * Build list of Ultrix devices
X */
Xextern int BuildDevicesUltrix(TreePtr)
X    DEVICE 		      **TreePtr;
X{
X    int				Found = 1;
X
X#if	defined(HAVE_UBA)
X    if (BuildUBA(TreePtr) == 0)
X	Found = 0;
X#endif	/* HAVE_UBA */
X
X    return(Found);
X}
X
X/*
X * Get Device Info structure from device.
X */
Xstatic struct devget *GETdevget(File, FileD)
X    char		       *File;
X    int 			FileD;
X{
X    static struct devget 	devget;
X
X    if (ioctl(FileD, DEVIOCGET, &devget) == SYSFAIL) {
X	if (Debug) Error("%s: ioctl DEVIOCGET failed: %s.", File, SYSERR);
X	return((struct devget *) NULL);
X    }
X
X    return(&devget);
X}
X
X/*
X * Get Device Geometry structure from device.
X */
Xstatic DEVGEOMST *GETdevgeom(File, FileD)
X    char		       *File;
X    int 			FileD;
X{
X    static DEVGEOMST 		devgeom;
X
X    if (ioctl(FileD, DEVGETGEOM, &devgeom) == SYSFAIL) {
X	if (Debug) Error("%s: ioctl DEVGETGEOM failed: %s.", File, SYSERR);
X	return((DEVGEOMST *) NULL);
X    }
X
X    return(&devgeom);
X}
X
X/*
X * Lookup a category type.
X */
Xstatic char *GetCategory(val)
X    int				val;
X{
X    extern NAMETAB	        Categorys[];
X    register int 		i;
X
X    for (i = 0; Categorys[i].name; ++i)
X	if (val == Categorys[i].value)
X	    return(Categorys[i].name);
X
X    return((char *) NULL);
X}
X
X/*
X * Convert a 'devget' to a 'device'.
X */
Xstatic DEVICE *devgetToDEVICE(DevGet, DevData, ProbeSpec)
X    struct devget	       *DevGet;
X    DEVDATA		       *DevData;
X    PROBESPEC		       *ProbeSpec;
X{
X    DEVICE		       *Device;
X
X    if (!(Device = NewDevice(NULL)))
X	return(Device);
X
X    Device->dv_name	= strdup(MkDevName(DevData->dd_devname,
X					   DevData->dd_devunit, 0, 0));
X    Device->dv_model	= strdup(DevGet->device);
X    Device->dv_unit	= DevGet->unit_num;
X    AddDevDesc(Device, GetCategory(DevGet->category), 
X	       NULL, DA_INSERT|DA_PRIME);
X
X    /*
X     * Set master/controller info
X     */
X    if (Device->dv_master = MkMasterFromDevData(DevData))
X	Device->dv_master->dv_model = strdup(DevGet->interface);
X
X    return(Device);
X}
X
X/*
X * Check a device by trying to perform a devget on it.
X */
Xstatic struct devget *CheckDevice(File)
X    char		       *File;
X{
X    struct devget	       *DevGet;
X    int				d;
X
X    if ((d = open(File, O_RDONLY|O_NDELAY)) < 0) {
X	if (Debug) Error("%s: Cannot open: %s.", File, SYSERR);
X	return((struct devget *) NULL);
X    }
X
X    /*
X     * Get generic device info
X     */
X    if (!(DevGet = GETdevget(File, d))) {
X	if (Debug) Error("%s: GETdevget failed.", File);
X	close(d);
X	return((struct devget *) NULL);
X    }
X
X    close(d);
X
X    return(DevGet);
X}
X
X/*
X * Retrieve disk partition information from a device file.
X */
Xstatic struct pt *ExtractDiskPart(File)
X    char		       *File;
X{
X    static struct pt		pt;
X    int				d;
X
X    if ((d = open(File, O_RDONLY|O_NDELAY)) < 0) {
X	if (Debug) Error("%s: open failed: %s.", File, SYSERR);
X	return((struct pt *) NULL);
X    }
X
X    if (ioctl(d, DIOCGETPT, &pt) < 0) {
X	if (Debug) Error("%s: ioctl DIOCGETPT failed: %s.", File, SYSERR);
X	close(d);
X	return((struct pt *) NULL);
X    }
X
X    close(d);
X
X    return(&pt);
X}
X
X/*
X * Get the mount point for a filesystem.
X */
Xstatic char *GetMountInfo(Name, Part)
X    char		       *Name;
X    char		       *Part;
X{
X    char		       *File;
X    struct fstab	       *fstab;
X
X    File = GetCharFile(Name, Part);
X    if (fstab = getfsspec(File)) {
X	if (strcmp(fstab->fs_type, FSTAB_SW) == 0)
X	    return("swap");
X	return(fstab->fs_file);
X    }
X
X    return((char *) NULL);
X}
X
X/*
X * Get the partition information for a disk device.
X */
Xextern DISKPART *
XGetDiskPart(Name, Device)
X    char 		       *Name;
X    DEVICE		       *Device;
X{
X    static DISKPART	        diskpart;
X    static char			Buf[BUFSIZ], part[2];
X    register DISKPART	       *pdp, *dp;
X    register char	       *p;
X    DISKPART		       *base = NULL;
X    struct pt		       *pt;
X    register int		i;
X
X    /*
X     * First get the partition info.
X     */
X    (void) sprintf(Buf, "/dev/r%sa", Name);
X    if (!(pt = ExtractDiskPart(Buf)))
X	return((DISKPART *) NULL);
X
X    part[1] = C_NULL;
X
X    /*
X     * Now deal with each partition.
X     */
X    for (i = 0; i < MAX_DISK_PARTS; ++i) {
X	/* Ignore partitions that have no size */
X	if (!pt->pt_part[i].pi_nblocks)
X	    continue;
X
X	part[0] = 'a' + i;
X
X	/* Make a clean slate */
X	bzero((char *) &diskpart, sizeof(DISKPART));
X
X	/* Fill in what we know */
X	diskpart.dp_name = strdup(part);
X	diskpart.dp_stsect = pt->pt_part[i].pi_blkoff;
X	diskpart.dp_nsect = pt->pt_part[i].pi_nblocks;
X
X	/* 
X	 * Get the mount point name.
X	 * If this is the "b" partition on the 
X	 * root device, then assume it's swap 
X	 */
X	if (p = GetMountInfo(Name, part))
X	    diskpart.dp_mnt = strdup(p);
X	else if (Device->dv_unit == 0 && strcmp(part, "b") == 0)
X	    diskpart.dp_mnt = "swap";
X
X	/*
X	 * Add this partition to the linked list.
X	 */
X	if (base) {
X	    for (pdp = base; pdp && pdp->dp_nxt; pdp = pdp->dp_nxt);
X	    pdp->dp_nxt = NewDiskPart(&diskpart);
X	} else
X	    base = NewDiskPart(&diskpart);
X    }
X
X    return(base);
X}
X
X/*
X * Probe a disk drive
X */
Xextern DEVICE *ProbeDiskDrive(Name, DevData, DevDataTab, ProbeSpec)
X    char		       *Name;
X    DEVDATA		       *DevData;
X    DEVDATATAB		       *DevDataTab;
X    PROBESPEC		       *ProbeSpec;
X{
X    DEVICE		       *Device;
X    DISKDRIVE		       *DiskDrive;
X    DEVGEOMST		       *DevGeom;
X    struct devget	       *DevGet;
X    char		       *File;
X    devdesc_t		       *ddPtr;
X    int				Desc;
X
X    if (!Name)
X	return((DEVICE *) NULL);
X
X    File = GetRawFile(Name, "c");
X    if ((Desc = open(File, O_RDONLY|O_NDELAY)) < 0) {
X	if (Debug) Error("%s: open failed: %s.", File, SYSERR);
X	/*
X	 * If we know for sure this drive is present and we
X	 * know something about it, then create a minimal device.
X	 */
X	if ((DevDataTab->ddt_model || DevDataTab->ddt_desc) &&
X	    FLAGS_ON(DevData->dd_flags, DD_IS_ALIVE)) {
X	    Device = NewDevice((DEVICE *) NULL);
X	    Device->dv_name = strdup(Name);
X	    Device->dv_unit = DevData->dd_devunit;
X	    Device->dv_master = MkMasterFromDevData(DevData);
X	    Device->dv_type = DT_DISKDRIVE;
X	    Device->dv_model = DevDataTab->ddt_model;
X	    Device->dv_modeldesc = DevDataTab->ddt_desc;
X	    return(Device);
X	} else
X	    return((DEVICE *) NULL);
X    }
X
X    /*
X     * Get generic device info
X     */
X    if (!(DevGet = GETdevget(File, Desc))) {
X	if (Debug) Error("%s: GETdevget failed.", File);
X	close(Desc);
X	return((DEVICE *) NULL);
X    }
X
X    /*
X     * Get geometry of device
X     */
X    if (!(DevGeom = GETdevgeom(File, Desc))) {
X	if (Debug) Error("%s: get_geomst failed.", File);
X    }
X
X    close(Desc);
X
X    /*
X     * Convert devget info to a device struct
X     */
X    if (!(Device = devgetToDEVICE(DevGet, DevData, ProbeSpec))) {
X	if (Debug) Error("%s: Cannot convert devget to device.");
X	return((DEVICE *) NULL);
X    }
X
X    /*
X     * Disks should be on disk controllers.
X     */
X    if (Device->dv_master)
X	Device->dv_master->dv_type = DT_DISKCTLR;
X
X    /*
X     * Set the disk drive specific info
X     */
X
X    if ((DiskDrive = NewDiskDrive(NULL)) == NULL) {
X	Error("Cannot create new diskdrive entry.");
X	return((DEVICE *) NULL);
X    }
X
X    Device->dv_type 		= DT_DISKDRIVE;
X    if (DevGet->device)
X	DiskDrive->dd_label 	= strdup(DevGet->device);
X
X    /*
X     * Convert Geometry
X     */
X    if (DevGeom) {
X	/*
X	 * If this is a removable device, indicate so.
X	 */
X	if (FLAGS_ON(DevGeom->geom_info.attributes, DEVGEOM_REMOVE)) {
X	    if ((ddPtr = PrimeDescPtr(Device)) && ddPtr->dd_desc) {
X		char Buf[BUFSIZ];
X
X		(void) sprintf(Buf, "Removable %s", ddPtr->dd_desc);
X		(void) free(ddPtr->dd_desc);
X		ddPtr->dd_desc = strdup(Buf);
X	    } else
X		AddDevDesc(Device, "Removable disk drive", 
X			   NULL, DA_INSERT|DA_PRIME);
X	}
X
X	DiskDrive->dd_unit 	= DevGet->unit_num;
X	DiskDrive->dd_slave 	= DevGet->slave_num;
X	DiskDrive->dd_part 	= GetDiskPart(Name, Device);
X	DiskDrive->dd_dcyl 	= DevGeom->geom_info.ncylinders;
X	DiskDrive->dd_heads 	= DevGeom->geom_info.ntracks;
X	DiskDrive->dd_sect 	= DevGeom->geom_info.nsectors;
X	DiskDrive->dd_secsize 	= SECSIZE;
X    }
X    Device->dv_devspec = (caddr_t *) DiskDrive;
X
X    return(Device);
X}
X
X/*
X * Lookup info about a tape drive.
X */
Xstatic char *GetTapeInfo(Flag)
X    int				Flag;
X{
X    extern NAMETAB		TapeInfo[];
X    static char			Buf[BUFSIZ];
X    register int		i;
X
X    if (!Flag)
X	return((char *) NULL);
X
X    Buf[0] = C_NULL;
X
X    /*
X     * Values are flag bits and are appended together.
X     */
X    for (i = 0; TapeInfo[i].name; i++) {
X	if (Flag & TapeInfo[i].value) {
X	    if (Buf[0]) {
X		(void) strcat(Buf, ", ");
X		(void) strcat(Buf, TapeInfo[i].name);
X	    } else
X		(void) strcpy(Buf, TapeInfo[i].name);
X	}
X    }
X
X    return(Buf);
X}
X
X/*
X * Probe a tape drive
X */
Xextern DEVICE *ProbeTapeDrive(Name, DevData, DevDataTab, ProbeSpec)
X    char		       *Name;
X    DEVDATA		       *DevData;
X    DEVDATATAB		       *DevDataTab;
X    PROBESPEC		       *ProbeSpec;
X{
X    struct devget	       *DevGet;
X    DEVICE		       *Device;
X    char		       *File;
X    char		       *p;
X    char		        Buf[BUFSIZ];
X    devdesc_t		       *ddPtr;
X    register int		i;
X
X    /*
X     * XXX Kludge Alert! ! !
X     *
X     * Ultrix tape device files are numbered independently of actual
X     * unit number.  Additionally, not all tape devices support the same
X     * set of minor devices types, so we can't look at the minor device 
X     * number.  
X     *
X     * The code below will open(), ioctl(), close() all tape
X     * devices between 0 and MAXTAPES until a matching unit number is found.
X     * This means that on systems with lots of tape drives, this can be 
X     * very slow.
X     */
X    for (i = 0; i < MAXTAPES; ++i) {
X	(void) sprintf(Buf, "/dev/nrmt%dh", i);
X	if ((DevGet = CheckDevice(Buf)) && 
X	    (DevGet->unit_num == DevData->dd_devunit))
X	    break;
X    }
X
X    if (!DevGet) {
X	if (Debug) Error("%s: Cannot find device file.", Name);
X	return((DEVICE *) NULL);
X    }
X
X    /*
X     * Convert devget info to a device struct
X     */
X    if (!(Device = devgetToDEVICE(DevGet, DevData, ProbeSpec))) {
X	if (Debug) Error("%s: Cannot convert devget to device.");
X	return((DEVICE *) NULL);
X    }
X
X    /*
X     * Set our device type
X     */
X    Device->dv_type = DT_TAPEDRIVE;
X
X    /*
X     * Get and add Tape Info
X     */
X    if (p = GetTapeInfo(DevGet->category_stat)) {
X	if ((ddPtr = PrimeDescPtr(Device)) && ddPtr->dd_desc) {
X	    (void) sprintf(Buf, "%s %s", p, ddPtr->dd_desc);
X	    (void) free(ddPtr->dd_desc);
X	    ddPtr->dd_desc = strdup(Buf);
X	} else
X	    AddDevDesc(Device, p, NULL, DA_INSERT|DA_PRIME);
X    }
X
X    /*
X     * Tapes should be on tape controllers.
X     */
X    if (Device->dv_master)
X	Device->dv_master->dv_type = DT_TAPECTLR;
X
X    return(Device);
X}
X
X/*
X * Get the system model name.  Ultrix keeps the cpu type in a global
X * variable cpu.  The cpu types are defined in <machine/cpuconf.h>.
X */
Xextern char *GetModelName()
X{
X    extern NAMETAB		ModelTab[];
X    struct nlist	       *nlptr;
X    extern char			CpuSYM[];
X    int				Cpu;
X    register int		i;
X    kvm_t		       *kd;
X
X    if (!(kd = KVMopen()))
X	return((char *) NULL);
X
X    if ((nlptr = KVMnlist(kd, CpuSYM, (struct nlist *)NULL)) == NULL)
X	return((char *) NULL);
X
X    if (CheckNlist(nlptr))
X	return((char *) NULL);
X
X    if (KVMread(kd, (u_long) nlptr->n_value, (char *) &Cpu,
X		sizeof(int), FALSE)) {
X	if (Debug) Error("Cannot read cpu from kernel.");
X	return((char *) NULL);
X    }
X
X    KVMclose(kd);
X
X    for (i = 0; ModelTab[i].name; ++i)
X	if (ModelTab[i].value == Cpu)
X	    return(ModelTab[i].name);
X
X    if (Debug)
X	printf("system model/type %d is unknown.\n", Cpu);
X
X    return((char *) NULL);
X}
X
X/*
X * Get kernel version string from kernel symbol "version".
X */
Xextern char *GetKernelVersionStr()
X{
X    return(UnSupported);
X}
X
X/*
X * Get system serial number
X */
Xextern char *GetSerialNoStr()
X{
X    return(UnSupported);
X}
X
X/*
X * Get version of OS
X */
Xextern char *GetOSVersionStr()
X{
X    return(UnSupported);
X}
X
X/*
X * Get ROM Version
X */
Xextern char *GetRomVer()
X{
X    return(UnSupported);
X}
END_OF_FILE
if test 15694 -ne `wc -c <'os-ultrix.c'`; then
    echo shar: \"'os-ultrix.c'\" unpacked with wrong size!
fi
# end of 'os-ultrix.c'
fi
if test -f 'sysinfo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sysinfo.c'\"
else
echo shar: Extracting \"'sysinfo.c'\" \(18319 characters\)
sed "s/^X//" >'sysinfo.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: sysinfo.c,v 1.67 1994/01/12 22:56:08 mcooper Exp mcooper $";
X#endif
X
X/*
X * Display System Information
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <netinet/in.h>
X#include <arpa/inet.h>
X#include <netdb.h>
X
X#include "defs.h"
X
X/*
X * Local declarations
X */
Xint 				DoPrintAll = TRUE;
Xint 				DoPrintUnknown = FALSE;
Xint 				DoPrintVersion = FALSE;
Xint 				Level = L_BRIEF;
Xint 				Terse = FALSE;
Xint 				Debug = 0;
Xint 				UseProm = 0;
Xint 				OffSetAmt = 4;
Xchar 			       *ShowStr = NULL;
Xchar 			       *LevelStr = NULL;
Xchar 			       *ListStr = NULL;
Xchar 			       *UnSupported = NULL;
Xchar			      **Environ = NULL;
X
X#if	defined(OPTION_COMPAT)
X/*
X * Old options here for backwards compatibility
X */
Xint				DoPrintCPU = FALSE;
Xint				DoPrintAppArch = FALSE;
Xint				DoPrintHostID = FALSE;
Xint				DoPrintHostName = FALSE;
Xint				DoPrintHostAlias = FALSE;
Xint				DoPrintHostAddrs = FALSE;
Xint				DoPrintKernArch = FALSE;
Xint				DoPrintKernVer = FALSE;
Xint				DoPrintMan = FALSE;
Xint				DoPrintModel = FALSE;
Xint				DoPrintMemory = FALSE;
Xint				DoPrintVirtMem = FALSE;
Xint				DoPrintOSName = FALSE;
Xint				DoPrintOSVer = FALSE;
Xint				DoPrintSerialNo = FALSE;
X#endif	/* OPTION_COMPAT */
X
X/*
X * Command line options table.
X */
XOptionDescRec Opts[] = {
X    {"+all", 	NoArg,		OptBool, 	__ &DoPrintAll,		"1",
X	 NULL,	"Print all information"},
X    {"-all", 	NoArg,		OptBool, 	__ &DoPrintAll,		"0",
X	 NULL,	"Don't print all information"},
X    {"-level",	SepArg,		OptStr, 	__ &LevelStr,		NULL,
X	 "<see \"-list level\">",	"Level names"},
X    {"-list",	SepArg,		OptStr, 	__ &ListStr,		"-",
X	 "level,show",	"List information about values"},
X    {"-offset",	SepArg,		OptInt, 	__ &OffSetAmt,		NULL,
X	 "<amount>",	"Number of spaces to offset device info"},
X    {"-show",	SepArg,		OptStr, 	__ &ShowStr,		NULL,
X	 "<see \"-list show\">",	"Show names"},
X    {"+terse", 	NoArg,		OptBool, 	__ &Terse,		"1",
X	 NULL,	"Print info in terse format"},
X    {"-terse", 	NoArg,		OptBool, 	__ &Terse,		"0",
X	 NULL,	"Don't print info in terse format"},
X    {"+unknown",NoArg,		OptBool, 	__ &DoPrintUnknown,	"1",
X	 NULL,	"Print unknown devices"},
X    {"-unknown",NoArg,		OptBool, 	__ &DoPrintUnknown,	"0",
X	 NULL,	"Don't print unknown devices"},
X    {"+useprom",NoArg,		OptBool, 	__ &UseProm,		"1",
X	 NULL,	"Use PROM values"},
X    {"-useprom",NoArg,		OptBool, 	__ &UseProm,		"0",
X	 NULL,	"Don't use PROM values"},
X    {"-version",NoArg,		OptBool, 	__ &DoPrintVersion,	"1",
X	 NULL,	"Print version of this program" },
X    {"-debug",ArgHidden|SepArg,	OptInt, 	__ &Debug,		"1",
X	 NULL,	"Enable debugging"},
X#if	defined(OPTION_COMPAT)
X    {"+cpu", 	NoArg|ArgHidden,OptBool,__ &DoPrintCPU,		"1" },
X    {"-cpu", 	NoArg|ArgHidden,OptBool,__ &DoPrintCPU,		"0" },
X    {"+arch", 	NoArg|ArgHidden,OptBool,__ &DoPrintAppArch,	"1" },
X    {"-arch", 	NoArg|ArgHidden,OptBool,__ &DoPrintAppArch,	"0" },
X    {"+hostid",	NoArg|ArgHidden,OptBool,__ &DoPrintHostID,	"1" },
X    {"-hostid",	NoArg|ArgHidden,OptBool,__ &DoPrintHostID,	"0" },
X    {"+hostname",NoArg|ArgHidden,OptBool,__ &DoPrintHostName,	"1" },
X    {"-hostname",NoArg|ArgHidden,OptBool,__ &DoPrintHostName,	"0" },
X    {"+hostaliases",NoArg|ArgHidden,OptBool,__ &DoPrintHostAlias,"1" },
X    {"-hostaliases",NoArg|ArgHidden,OptBool,__ &DoPrintHostAlias,"0" },
X    {"+hostaddrs",NoArg|ArgHidden,OptBool,__ &DoPrintHostAddrs,	"1" },
X    {"-hostaddrs",NoArg|ArgHidden,OptBool,__ &DoPrintHostAddrs,	"0" },
X    {"+karch", 	NoArg|ArgHidden,OptBool,__ &DoPrintKernArch,	"1" },
X    {"-karch", 	NoArg|ArgHidden,OptBool,__ &DoPrintKernArch,	"0" },
X    {"+kernver",NoArg|ArgHidden,OptBool,__ &DoPrintKernVer,	"1" },
X    {"-kernver",NoArg|ArgHidden,OptBool,__ &DoPrintKernVer,	"0" },
X    {"+man", 	NoArg|ArgHidden,OptBool,__ &DoPrintMan,		"1" },
X    {"-man", 	NoArg|ArgHidden,OptBool,__ &DoPrintMan,		"0" },
X    {"+model", 	NoArg|ArgHidden,OptBool,__ &DoPrintModel,	"1" },
X    {"-model", 	NoArg|ArgHidden,OptBool,__ &DoPrintModel,	"0" },
X    {"+memory",	NoArg|ArgHidden,OptBool,__ &DoPrintMemory,	"1" },
X    {"-memory",	NoArg|ArgHidden,OptBool,__ &DoPrintMemory,	"0" },
X    {"+virtmem",NoArg|ArgHidden,OptBool,__ &DoPrintVirtMem,	"1" },
X    {"-virtmem",NoArg|ArgHidden,OptBool,__ &DoPrintVirtMem,	"0" },
X    {"+osname",	NoArg|ArgHidden,OptBool,__ &DoPrintOSName,	"1" },
X    {"-osname",	NoArg|ArgHidden,OptBool,__ &DoPrintOSName,	"0" },
X    {"+osvers",	NoArg|ArgHidden,OptBool,__ &DoPrintOSVer,	"1" },
X    {"-osvers",	NoArg|ArgHidden,OptBool,__ &DoPrintOSVer,	"0" },
X    {"+serial",	NoArg|ArgHidden,OptBool,__ &DoPrintSerialNo,	"1" },
X    {"-serial",	NoArg|ArgHidden,OptBool,__ &DoPrintSerialNo,	"0" },
X#endif	/* OPTION_COMPAT */
X};
X
X/*
X * Option compatibility support
X */
X#if	defined(OPTION_COMPAT)
Xstatic void			SetOptionCompat();
X#define OptCom(v) v
X#else
X#define OptCom(v) 0
X#endif
X
XSHOWINFO ShowInfo[] = {
X    { S_GEN, "general",	"GENERAL INFORMATION",	ShowGeneral },
X    { S_GEN, "hostname",	"Host Name",		NULL, GetHostName,
X						OptCom(&DoPrintHostName) },
X    { S_GEN, "hostaliases",	"Host Aliases",		NULL, GetHostAliases,
X						OptCom(&DoPrintHostAlias) },
X    { S_GEN, "hostaddrs",	"Host Address(es)",	NULL, GetHostAddrs,
X						OptCom(&DoPrintHostAddrs) },
X    { S_GEN, "hostid",		"Host ID",		NULL, GetHostID,
X						OptCom(&DoPrintHostID) },
X    { S_GEN, "serial",		"Serial Number",	NULL, GetSerialNo,
X						OptCom(&DoPrintSerialNo) },
X    { S_GEN, "man",		"Manufacturer",		NULL, GetMan,
X						OptCom(&DoPrintMan) },
X    { S_GEN, "model",		"System Model",		NULL, GetModel,
X						OptCom(&DoPrintModel) },
X    { S_GEN, "memory",		"Main Memory",		NULL, GetMemory,
X						OptCom(&DoPrintMemory) },
X    { S_GEN, "virtmem",		"Virtual Memory",	NULL, GetVirtMem,
X						OptCom(&DoPrintVirtMem) },
X    { S_GEN, "romver",		"ROM Version",		NULL, GetRomVer },
X    { S_GEN, "cpu",		"CPU Type",		NULL, GetCPU,
X						OptCom(&DoPrintCPU) },
X    { S_GEN, "numcpu",		"Number of CPUs",	NULL, GetNumCPU,
X						OptCom(&DoPrintCPU) },
X    { S_GEN, "arch",		"App Architecture",	NULL, GetAppArch,
X						OptCom(&DoPrintAppArch) },
X    { S_GEN, "karch",		"Kernel Architecture",	NULL, GetKernArch,
X						OptCom(&DoPrintKernArch) },
X    { S_GEN, "osname",		"OS Name",		NULL, GetOSName,
X						OptCom(&DoPrintOSName) },
X    { S_GEN, "osvers",		"OS Version",		NULL, GetOSVersion,
X						OptCom(&DoPrintOSVer) },
X    { S_GEN, "kernver",		"Kernel Version",	NULL, GetKernelVersion,
X						OptCom(&DoPrintKernVer) },
X    { S_DEV, "devices",	"DEVICE INFORMATION",	ShowDevices },
X    { 0 },
X};
X
X/*
X * Values and names of levels
X */
XNAMETAB LevelNames[] = {
X    { L_BRIEF,		"brief" },
X    { L_GENERAL,	"general" },
X    { L_DESC,		"descriptions" },
X    { L_CONFIG,		"config" },
X    { L_ALL,		"all" },
X    { L_DEBUG,		"debug" },
X    { 0 },
X};
X
X/*
X * List table
X */
Xstruct listtab {
X    char		       *Name;
X    char		       *Desc;
X    void		      (*Func)();
X};
Xtypedef struct listtab LISTTAB;
X
Xstatic void			List();
Xstatic void			ListLevel();
Xstatic void			ListShow();
X
XLISTTAB ListTab[] = {
X    { "level",		"Values for -level option",	ListLevel },
X    { "show",		"Values for -show option",	ListShow },
X    { 0 },
X};
X
X/*
X * Print a label and an argument
X */
Xstatic void PrintLabel(Lbl, Str)
X     char 		       *Lbl;
X     char 		       *Str;
X{
X    if (!Terse)
X	printf("%-*s: ", 20, Lbl);
X    printf("%s\n", (Str && *Str) ? Str : "");
X}
X
X/*
X * Print general info
X */
Xextern void ShowGeneral(MyInfo, SpecInfo)
X    SHOWINFO		       *MyInfo;
X    SHOWINFO		       *SpecInfo;
X{
X    register int		i;
X    int				ShowAll = TRUE;
X
X    /*
X     * Do a specific info item
X     */
X    if (SpecInfo) {
X	PrintLabel(SpecInfo->Label, (*SpecInfo->GetFunc)());
X	SpecInfo->Enable = FALSE;
X	return;
X    }
X
X    /*
X     * See if we are going to show all items
X     */
X    if (!DoPrintAll)
X	for (i = 0; ShowInfo[i].Name; i++)
X	    if (ShowInfo[i].Type == MyInfo->Type && 
X		ShowInfo[i].GetFunc && !ShowInfo[i].Enable) {
X		ShowAll = FALSE;
X		break;
X	    }
X
X    if (MyInfo && (DoPrintAll || ShowAll || MyInfo->Enable))
X	printf("\n\n\t%s\n\n", MyInfo->Label);
X
X    /*
X     * Print each enabled item of our type
X     */
X    for (i = 0; ShowInfo[i].Name; i++)
X	if ((ShowInfo[i].Type == MyInfo->Type) &&
X	    (ShowInfo[i].Enable || MyInfo->Enable) && ShowInfo[i].GetFunc) {
X	    PrintLabel(ShowInfo[i].Label, (*ShowInfo[i].GetFunc)());
X	    ShowInfo[i].Enable = FALSE;
X	}
X
X    if (MyInfo)
X	MyInfo->Enable = FALSE;
X}
X
X/*
X * List Show values
X */
Xstatic void ListShow()
X{
X    register int		i;
X
X    printf(
X	"The following values may be specified with the \"-show\" option:\n");
X    printf("\t%-20s %s\n", "VALUE", "DESCRIPTION");
X
X    for (i = 0; ShowInfo[i].Name; i++)
X	printf("\t%-20s %s%s\n",
X	       ShowInfo[i].Name,
X	       (ShowInfo[i].ShowFunc) ? "Show all " : "",
X	       ShowInfo[i].Label
X	       );
X}
X
X/*
X * List Level values
X */
Xstatic void ListLevel()
X{
X    register int		i;
X
X    printf(
X	"The following values may be specified with the \"-level\" option:\n");
X    printf("\t%-20s\n", "VALUE");
X
X    for (i = 0; LevelNames[i].name; i++) {
X	printf("\t%s\n", LevelNames[i].name);
X    }
X}
X
X/*
X * List list values
X */
Xstatic void ListList()
X{
X    register int		i;
X
X    printf(
X	"The following values may be specified with the \"-list\" option:\n");
X    printf("\t%-20s %s\n", "VALUE", "DESCRIPTION");
X
X    for (i = 0; ListTab[i].Name; i++) {
X	printf("\t%-20s %s\n",
X	       ListTab[i].Name,
X	       ListTab[i].Desc
X	       );
X    }
X}
X
X/*
X * List information about each word found in Str.
X */
Xstatic void List(Str)
X    char		       *Str;
X{
X    register int		i;
X    char		       *Word;
X    int				Found;
X
X    if (EQ(Str, "-")) {
X	ListList();
X	return;
X    }
X
X    for (Word = strtok(Str, ","); Word; Word = strtok((char *)NULL, ",")) {
X	for (i = 0, Found = FALSE; ListTab[i].Name && !Found; i++)
X	    if (EQ(Word, ListTab[i].Name)) {
X		Found = TRUE;
X		(*ListTab[i].Func)();
X	    }
X
X	if (!Found) {
X	    Error("The word \"%s\" is invalid.", Word);
X	    ListList();
X	    return;
X	}
X    }
X}
X
X/*
X * Get argument number "arg" from "str".
X */
Xstatic char *GetArg(Str, ArgNum)
X    char 		       *Str;
X    int 			ArgNum;
X{
X    register char 	       *p, *start = NULL;
X    register int 		c;
X
X    for (c = 1, p = Str; p && *p; ++c) {
X	/* set start of word */
X	start = p; 
X
X	/* skip over word */
X	while (p && *p && *p != ' ' && *p != '\t' && *p != '\n')
X	    ++p;
X
X	/* is this what we want? */
X	if (c == ArgNum) {
X	    if (p) *p = C_NULL;
X	    break;
X	}
X
X	/* skip white space */
X	while (*p == ' ' || *p == '\t')
X	    ++p;
X    }
X
X    return(start);
X}
X
X/*
X * Convert integer to ASCII
X */
Xchar *itoa(Num)
X    int 			Num;
X{
X    static char 		Buf[BUFSIZ];
X
X    (void) sprintf(Buf, "%d", Num);
X
X    return(Buf);
X}
X
X/*
X * Get our hostname
X */
Xextern char *GetHostName()
X{
X    static char 		Buf[MAXHOSTNAMLEN+1];
X
X    gethostname(Buf, sizeof(Buf));
X
X    return((Buf[0]) ? Buf : (char *) NULL);
X}
X
X/*
X * Get aliases for this hostname
X *
X * Note that this won't work on most systems if your
X * gethostbyname() call gets its info from DNS since
X * DNS does not provide this funtionality.
X */
Xextern char *GetHostAliases()
X{
X    static char 		Buf[BUFSIZ];
X    struct hostent 	       *hp;
X    register char	      **pp;
X    char 		       *HName;
X
X    if ((HName = GetHostName()) == NULL)
X	return((char *) NULL);
X
X    if ((hp = gethostbyname(HName)) == NULL) {
X	Error("Cannot find lookup host info for \"%s\": %s", HName, SYSERR);
X	return((char *) NULL);
X    }
X
X    for (pp = hp->h_aliases, Buf[0] = C_NULL; pp && *pp; ++pp) {
X	(void) strcat(Buf, *pp);
X	(void) strcat(Buf, " ");
X    }
X
X    return((Buf[0]) ? Buf : (char *) NULL);
X}
X
X/*
X * Get addresses for this host
X */
Xextern char *GetHostAddrs()
X{
X    static char 		Buf[BUFSIZ];
X    struct hostent 	       *hp;
X    register char	      **pp;
X    char 		       *HName;
X
X    if ((HName = GetHostName()) == NULL)
X	return((char *) NULL);
X
X    if ((hp = gethostbyname(HName)) == NULL) {
X	Error("Cannot find lookup host info for \"%s\": %s", HName, SYSERR);
X	return((char *) NULL);
X    }
X
X    for (pp = hp->h_addr_list, Buf[0] = C_NULL; pp && *pp; ++pp) {
X	if (hp->h_addrtype == AF_INET) {
X	    (void) strcat(Buf, (char *) inet_ntoa(*(struct in_addr *)*pp));
X	    (void) strcat(Buf, " ");
X	}
X    }
X
X    return((Buf[0]) ? Buf : (char *) NULL);
X}
X
X/*
X * Get system model
X */
Xextern char *GetModel()
X{
X    int 			Len;
X    FILE 		       *fd;
X    char 			Buf[BUFSIZ];
X    char		       *GetModelName();
X#if	defined(MODEL_COMMAND)
X    extern char 	       *ModelCommand[];
X#endif	/* MODEL_COMMAND */
X
X    /*
X     * Use model file if it exists.
X     */
X    if ((fd = fopen(MODELFILE, "r")) != NULL) {
X	fgets(Buf, sizeof(Buf), fd);
X	Len = strlen(Buf);
X	if (Buf[Len-1] == '\n') 
X	    Buf[Len-1] = C_NULL;
X	return(Buf);
X    }
X
X    /*
X     * If a command to get model name has been defined, try it.
X     */
X#if	defined(MODEL_COMMAND)
X    if (p = RunCmds(ModelCommand, FALSE))
X	return(p);
X#endif	/* MODEL_COMMAND */
X
X    /*
X     * Use a method specific to this OS
X     */
X    return(GetModelName());
X}
X
X/*
X * Get host ID
X */
Xextern char *GetHostID()
X{
X    static char 		Buf[100];
X
X    (void) sprintf(Buf, "%08x", gethostid());
X
X    return(Buf);
X}
X
X/*
X * Get system serial number
X */
Xextern char *GetSerialNo()
X{
X    return(GetSerialNoStr());
X}
X
X/*
X * Print error message
X */
X#if	defined(HAVE_VARARGS)
X#include <varargs.h>
X/*
X * Varargs version of Error()
X */
Xextern void Error(va_alist)
X    va_dcl
X{
X    va_list 			args;
X    char 		       *fmt;
X    extern char 	       *ProgramName;
X
X    (void) fflush(stdout);
X    (void) fprintf(stderr, "%s: ", ProgramName);
X    va_start(args);
X    fmt = (char *) va_arg(args, char *);
X    (void) vfprintf(stderr, fmt, args);
X    va_end(args);
X    (void) fprintf(stderr, "\n");
X}
X#else
X/*
X * Non-Varargs version of Error()
X */
Xextern void Error(fmt, a1, a2, a3, a4, a5, a6)
X    char 		       *fmt;
X{
X    extern char 	       *ProgramName;
X
X    (void) fflush(stdout);
X    (void) fprintf(stderr, "%s: ", ProgramName);
X    (void) fprintf(stderr, fmt, a1, a2, a3, a4, a5, a6);
X    (void) fprintf(stderr, "\n");
X}
X#endif 	/* !HAVE_VARARGS */
X
X/*
X * Parse and set the level keyword list
X */
Xstatic int ParseLevel(Str)
X    char		       *Str;
X{
X    register int		i;
X    char		       *Word;
X    int				Found;
X
X    /*
X     * Check each word in the LevelNames table
X     */
X    for (Word = strtok(Str, ","); Word; Word = strtok((char *)NULL, ",")) {
X	for (i = 0, Found = FALSE; LevelNames[i].name && !Found; i++) {
X	    if (strncasecmp(Word, LevelNames[i].name, strlen(Word)) == 0) {
X		Level |= LevelNames[i].value;
X		Found = TRUE;
X	    }
X	}
X	if (!Found) {
X	    Error("The word \"%s\" is not a valid verbosity level.", Word);
X	    return(-1);
X	}
X    }
X
X    return(0);
X}
X
X/*
X * Parse and set the showinfo items
X */
Xstatic int ParseShow(Str)
X    char		       *Str;
X{
X    register int		x;
X    char		       *Word;
X    int				Found;
X
X    /*
X     * Check each word.
X     */
X    for (Word = strtok(Str, ","); Word; Word = strtok((char *)NULL, ",")) {
X	/*
X	 * Search the ShowInfo entries for a match.
X	 */
X	for (x = 0, Found = FALSE; !Found && ShowInfo[x].Name; x++)
X	    if (EQ(Word, ShowInfo[x].Name)) {
X		ShowInfo[x].Enable = TRUE;
X		DoPrintAll = FALSE;
X		Found = TRUE;
X	    }
X
X	if (!Found) {
X	    Error("The word \"%s\" is not valid.", Word);
X	    ListShow();
X	    return(-1);
X	}
X    }
X
X    return(0);
X}
X
X/*
X * Front end to calloc()
X */
Xchar *xcalloc(nele, esize)
X    int 			nele;
X    int 			esize;
X{
X    char 		       *p, *calloc();
X
X    if ((p = calloc(nele, esize)) == NULL) {
X	Error("calloc(%d, %d) failed.", nele, esize);
X	exit(1);
X    }
X
X    return(p);
X}
X
Xchar *xmalloc(size)
X    int				size;
X{
X    char		       *newptr, *malloc();
X
X    if (!(newptr = malloc(size))) {
X	Error("malloc size %d failed: %s", size, SYSERR);
X	exit(1);
X    }
X
X    return(newptr);
X}
X
Xchar *xrealloc(ptr, size)
X    char		       *ptr;
X    int				size;
X{
X    char		       *newptr, *realloc();
X
X    if (!(newptr = realloc(ptr, size))) {
X	Error("realloc 0x%x size %d failed: %s", ptr, size, SYSERR);
X	exit(1);
X    }
X
X    return(newptr);
X}
X
X#if	defined(OPTION_COMPAT)
X/*
X * Set option compatibility
X */
Xstatic void SetOptionCompat()
X{
X    register int		i;
X
X    /*
X     * For every OptCompat that's TRUE, enable the real value
X     */
X    for (i = 0; ShowInfo[i].Name; i++) 
X	if (ShowInfo[i].OptCompat && *ShowInfo[i].OptCompat) {
X	    ShowInfo[i].Enable = TRUE;
X	    /*
X	     * These is also part of the old behavior
X	     */
X	    DoPrintAll = FALSE;
X	    Terse = TRUE;
X	}
X
X}
X#endif	/* OPTION_COMPAT */
X
X/*
X * The beginning
X */
Xmain(Argc, Argv, Envp)
X    int 			Argc;
X    char 		      **Argv;
X    char 		      **Envp;
X{
X    register int		i;
X
X    Environ = Envp;
X
X    if (ParseOptions(Opts, Num_Opts(Opts), Argc, Argv) < 0)
X	    exit(1);
X
X    UnSupported = (Debug) ? "**UNSUPPORTED**" : (char *)NULL;
X
X    /*
X     * Show version info
X     */
X    if (DoPrintVersion) {
X	if (!Terse)
X	    printf("Sysinfo version ");
X	if (PATCHLEVEL)
X	    printf("%s.%d\n", VERSION_STR, PATCHLEVEL);
X	else
X	    printf("%s\n", VERSION_STR, PATCHLEVEL);
X	exit(0);
X    }
X 
X    /*
X     * Do any list commands and exit
X     */
X    if (ListStr) {
X	List(ListStr);
X	exit(0);
X    }
X
X#if	defined(OPTION_COMPAT)
X    SetOptionCompat();
X#endif
X
X    /*
X     * Set verbosity strings
X     */
X    if (LevelStr && ParseLevel(LevelStr))
X	exit(1);
X
X    if (ShowStr && ParseShow(ShowStr))
X	exit(1);
X
X    /*
X     * Run down the main topics
X     */
X    for (i = 0; ShowInfo[i].Name; i++) {
X	if (!(DoPrintAll || ShowInfo[i].Enable))
X	    continue;
X
X	if (ShowInfo[i].ShowFunc) {
X	    /*
X	     * The item has a show function
X	     */
X	    (*ShowInfo[i].ShowFunc)(&ShowInfo[i], NULL);
X	} else {
X	    register int	x;
X	    int			Found;
X
X	    /*
X	     * Search for and call a search function for this type of item
X	     */
X	    for (x = 0, Found = FALSE; !Found && ShowInfo[x].Name; x++)
X		if ((ShowInfo[x].Type == ShowInfo[i].Type) &&
X		    ShowInfo[x].ShowFunc) {
X		    Found = TRUE;
X		    (*ShowInfo[x].ShowFunc)(&ShowInfo[x], &ShowInfo[i]);
X		}
X	    if (!Found) {
X		Error("No show function exists for \"%s\".", 
X		      ShowInfo[i].Name);
X		exit(1);
X	    }
X	}
X    }
X
X    exit(0);
X}
END_OF_FILE
if test 18319 -ne `wc -c <'sysinfo.c'`; then
    echo shar: \"'sysinfo.c'\" unpacked with wrong size!
fi
# end of 'sysinfo.c'
fi
echo shar: End of archive 3 \(of 5\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
