Newsgroups: comp.sources.unix
From: mcooper@usc.edu (Michael A. Cooper)
Subject: v28i075: sysinfo-2.1.2 - Show system information, V2.1.2, Part02/05
References: <1.772126523.28031@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: mcooper@usc.edu (Michael A. Cooper)
Posting-Number: Volume 28, Issue 75
Archive-Name: sysinfo-2.1.2/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 5)."
# Contents:  Makefile dlpi.c info-ultrix.c kbd-sun.c macinfo.c
#   options.c os-next.c os-sunos.c run.c setenv.c sysinfo.man
# Wrapped by vixie@gw.home.vix.com on Mon Jun 20 08:33:20 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(6271 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#
X# Copyright (c) 1992-1993 Michael A. Cooper.
X# This software may be freely distributed provided it is not sold for 
X# profit and the author is credited appropriately.
X#
X# $Id: Makefile,v 1.31 1994/01/12 22:46:01 mcooper Exp mcooper $
X#
X# Sysinfo Makefile
X#
X# To compile, just run "make".  This should automatically figure out
X# your OS type.
X#
X
X#
X# Location of your Kernel specific directory.
X# This is usually only for SunOS 4.x.  If you don't have
X# one, set this to nothing.
X#
X#KVMDIR		= /usr/kvm
XKVMDIR		=
X
X#
X# The bin directory that user's will run the program from.
X# For systems with a $(KVMDIR) (above), a symlink will be put 
X# in $(BIN) pointing to $(KVMDIR)/sysinfo.  On systems without 
X# a $(KVMDIR), the program will be copied to $(BIN).
X#
X# A good place is something like /usr/local/bin.
X#
XBIN 		= /usr/local/bin
X
X#
X# Directory to install man page in.
X#
XMAN 		= /usr/local/man/man1
X
X#
X# Installation options
X#
X# Sysinfo needs to be able to read your unix image (/vmunix usually),
X# /dev/kmem, and device files in /dev for things like disk drives and tapes.
X# Under SunOS, /dev/kmem is owned by group "kmem", but the disk files
X# (e.g. /dev/rsd0a) are owned by group "operator".  Therefor, you usually
X# can't make setgid to a group, but need it setuid root.
X#
X# You should set INSTALLMODE and INSTALLOWN appropriately to allow sysinfo 
X# to read everything it needs to.  Try running "sysinfo -debug" to find out 
X# the special files it reads.
X#
XINSTALLMODE	= -m 4555
XINSTALLOWN 	= -o root -g wheel
XINSTALLOPTS 	= $(INSTALLMODE) $(INSTALLOWN)
XINSTALLPROG	= install
X
X###########################################################################
X#
X# 	END OF NORMAL SITE CONFIGURATION
X#
X###########################################################################
X
X#
X# The make program to use
X#
XMAKE		= make
X
X#
X# The name of the kvm library to use.
X# For SunOS this should be "-lkvm".  If you don't have one, add
X# "kvmlib.o" to MISSINGFILES below and leave LIBKVM blank.
X#
XLIBKVM		= -lkvm
X
X#
X# SunOS 4.0, 4.0.1, and 4.0.3 requires using the System V cc and libc
X# in order to get uname().  Enable the two lines below if your OS is one
X# of these.
X#
X#CC		= gcc
XLIBS 		=
X
X#
X# Defines
X#
XDEFINES		=
X
X#
X# Optimization or debugging flag
X#
XOPT		= -g
X
X#
X# Include directories
X#
XINCLUDES	= -I.
X
XCFLAGS 		= ${OPT} ${INCLUDES} ${DEFINES}
X
XNetIf-Files	= netif.o info-netif.o
XEnv-Files	= getenv.o putenv.o setenv.o
X
X#
X# OS Specific Files
X#
XAIX-OS-Files	= os-aix.o info-aix.o
XMach-OS-Files	= os-mach.o info-mach.o
XNeXT-OS-Files	= os-next.o info-next.o ${Mach-OS-Files} ${NetIf-Files} \
X			${Env-Files}
XSunOS-OS-Files	= os-sunos.o info-sunos.o kbd-sun.o obp.o ${NetIf-Files}
XSunOS4-OS-Files	= os-sunos4.o ${SunOS-OS-Files}
XSunOS5-OS-Files	= os-sunos5.o dlpi.o ${SunOS-OS-Files}
XUltrix-OS-Files	= os-ultrix.o info-ultrix.o ${NetIf-Files}
X
X#
X# Select the OS specific files to compile
X#
XOSFILES		=
X
X#
X# Missing files
X#
X# List of files of things your system may not have.
X#
XMISSINGFILES	=
X
XBASE 		= sysinfo
XPROG 		= ${BASE}
XOBJS 		= ${BASE}.o devices.o memory.o run.o run-data.o kvm.o \
X			options.o virtmem.o getosver.o getosname.o getcpu.o \
X			getarch.o getkernver.o getman.o macinfo.o namelist.o \
X			${MISSINGFILES} ${OSFILES}
X
X#
X# Default
X#
Xdefault:
X	@ostype="`./ostype`"; \
X	case "$${ostype}" in \
X	aix3*)		target=aix3;; \
X	nextstep2*)	target=nextstep2;; \
X	nextstep3*)	target=nextstep3;; \
X	sunos4*)	target=sunos4;; \
X	sunos5*)	target=sunos5;; \
X	ultrix4*)	target=ultrix4;; \
X	*) \
X		echo "You OS type ($$ostype) is not supported."; \
X		exit 1; \
X	esac; \
X	$(MAKE) $${target}
X
Xall: ${PROG}
X
X${PROG}: ${OBJS}
X	${CC} ${CFLAGS} -o $@ ${OBJS} ${LIBS} ${LIBKVM}
X
Xinstall: ${PROG}
X	@if [ "$(KVMDIR)" ]; then \
X		echo "$(INSTALLPROG) -c ${INSTALLOPTS} ${PROG} $(KVMDIR)/${BASE}"; \
X		$(INSTALLPROG) -c ${INSTALLOPTS} ${PROG} $(KVMDIR)/${BASE}; \
X		echo "cd ${BIN} && rm -f ${BASE} && ln -s $(KVMDIR)/${BASE} ${BASE}"; \
X		(cd ${BIN} && rm -f ${BASE} && ln -s $(KVMDIR)/${BASE} ${BASE}); \
X	else \
X		echo $(INSTALLPROG) -c ${INSTALLOPTS} ${PROG} ${BIN}/${BASE}; \
X		$(INSTALLPROG) -c ${INSTALLOPTS} ${PROG} ${BIN}/${BASE}; \
X	fi
X
X#
X# See the file "metasysinfo" for more information on "installmeta".
X#
Xinstallmeta: $(PROG)
X	$(INSTALLPROG) -c -m 555 $(INSTALLOWN) metasysinfo $(BIN)/$(BASE)
X	@$(INSTALLPROG) -c $(INSTALLOPTS) $(PROG) \
X			$(BIN)/$(BASE)-`uname -m`-`uname -r`; \
X		echo $(INSTALLPROG) -c $(INSTALLOPTS) $(PROG) \
X			$(BIN)/$(BASE)-`uname -m`-`uname -r`
X
Xinstall.man: ${BASE}.man
X	$(INSTALLPROG) -c -m 444 -o bin -g bin ${BASE}.man ${MAN}/${BASE}.1
X
Xinstall.compat:
X	$(INSTALLPROG) -c -m 555 -o bin -g bin cpumodel.sh /usr/lsd/etc/cpumodel
X	rm -f $MAN/${BASE}.8 $MAN/cpumodel.1
X	(cd /usr/usc/bin; rm -f sysinfo; ln -s ${BIN}/sysinfo)
X
Xclean:
X	rm -f *.o ${PROG} *~ *% \#* core a.out sysinfo.tar sysinfo.tar.Z
X
X${OBJS}: os.h defs.h
X
X#
X# OS targets
X#
X
X#
X# SunOS 4.x (Solaris 1.x)
X#
Xsunos4 solaris1:
X	@echo "Making SunOS 4.x ${BASE} ... "; \
X	$(MAKE)	KVMDIR="$(KVMDIR)" \
X		LIBKVM=-lkvm \
X		LIBS="" \
X		DEFINES="-DSUNOS=4 -D`/bin/arch -k`" \
X		OSFILES="${SunOS4-OS-Files}" \
X		MISSINGFILES="strcasecmp.o strdup.o strerror.o" \
X		all
X
X#
X# SunOS 5.x (Solaris 2.x)
X#
Xsunos5 solaris2:
X	@echo "Making SunOS 5.x ${BASE} ... "; \
X	$(MAKE)	KVMDIR="" \
X		LIBKVM=-lkvm \
X		LIBS="-lsocket -lnsl -lelf -ladm" \
X		DEFINES=-DSUNOS=5 \
X		OSFILES="${SunOS5-OS-Files}" \
X		MISSINGFILES="setreuid.o" \
X		all
X
X#
X# AIX 3.x for RS/6000
X#
Xaix3:
X	@echo "Making AIX ${BASE} ... "; \
X	$(MAKE)	KVMDIR="" \
X		LIBKVM="" \
X		LIBS="-lodm -lcfg" \
X		DEFINES="" \
X		OSFILES="${AIX-OS-Files}" \
X		MISSINGFILES="strdup.o kvmlib.o" \
X		all
X
X#
X# Ultrix 4.x
X#
Xultrix4:
X	@echo "Making Ultrix ${BASE} ... "; \
X	$(MAKE)	KVMDIR="" \
X		LIBKVM="" \
X		LIBS="" \
X		DEFINES="" \
X		OSFILES="${Ultrix-OS-Files}" \
X		MISSINGFILES="strdup.o kvmlib.o" \
X		all
X
X#
X# NeXTStep 2.x
X#
Xnext2 nextstep2:
X	@echo "Making NeXTStep 2.x ${BASE} ... "; \
X	$(MAKE)	KVMDIR="" \
X		LIBKVM="" \
X		LIBS="" \
X		DEFINES="-DNEXTSTEP=2" \
X		OSFILES="${NeXT-OS-Files}" \
X		MISSINGFILES="strdup.o kvmlib.o" \
X		all
X
X#
X# NeXTStep 3.x
X#
Xnext3 nextstep3:
X	@echo "Making NeXTStep 3.x ${BASE} ... "; \
X	$(MAKE)	KVMDIR="" \
X		LIBKVM="" \
X		LIBS="" \
X		DEFINES="-DNEXTSTEP=3" \
X		OSFILES="${NeXT-OS-Files}" \
X		MISSINGFILES="strdup.o kvmlib.o" \
X		all
END_OF_FILE
if test 6271 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'dlpi.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dlpi.c'\"
else
echo shar: Extracting \"'dlpi.c'\" \(6101 characters\)
sed "s/^X//" >'dlpi.c' <<'END_OF_FILE'
X/*
X * The code contained in this file is from Neal Nuckolls's (Sun Internet
X * Engineering) DLPI "test" kit.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: dlpi.c,v 1.3 1994/01/12 22:56:08 mcooper Exp mcooper $";
X#endif
X
X/*
X * Common (shared) DLPI test routines.
X * Mostly pretty boring boilerplate sorta stuff.
X * These can be split into individual library routines later
X * but it's just convenient to keep them in a single file
X * while they're being developed.
X *
X * Not supported:
X *   Connection Oriented stuff
X *   QOS stuff
X */
X
X
X#include "defs.h"
X
X#if	defined(HAVE_DLPI)
X
X#include	<sys/types.h>
X#include	<sys/stream.h>
X#include	<sys/stropts.h>
X#include	<sys/dlpi.h>
X#include	<sys/signal.h>
X#include	<stdio.h>
X#include	<string.h>
X#include	"dlpi.h"
X
Xdlattachreq(fd, ppa)
Xint	fd;
Xu_long	ppa;
X{
X	dl_attach_req_t	attach_req;
X	struct	strbuf	ctl;
X	int	flags;
X
X	attach_req.dl_primitive = DL_ATTACH_REQ;
X	attach_req.dl_ppa = ppa;
X
X	ctl.maxlen = 0;
X	ctl.len = sizeof (attach_req);
X	ctl.buf = (char *) &attach_req;
X
X	flags = 0;
X
X	if (putmsg(fd, &ctl, (struct strbuf*) NULL, flags) < 0)
X		if (Debug) Error("dlattachreq:  putmsg");
X}
X
Xdlphysaddrreq(fd, addrtype)
Xint	fd;
Xu_long	addrtype;
X{
X	dl_phys_addr_req_t	phys_addr_req;
X	struct	strbuf	ctl;
X	int	flags;
X
X	phys_addr_req.dl_primitive = DL_PHYS_ADDR_REQ;
X	phys_addr_req.dl_addr_type = addrtype;
X
X	ctl.maxlen = 0;
X	ctl.len = sizeof (phys_addr_req);
X	ctl.buf = (char *) &phys_addr_req;
X
X	flags = 0;
X
X	if (putmsg(fd, &ctl, (struct strbuf*) NULL, flags) < 0)
X		if (Debug) Error("dlphysaddrreq:  putmsg");
X}
X
Xdldetachreq(fd)
Xint	fd;
X{
X	dl_detach_req_t	detach_req;
X	struct	strbuf	ctl;
X	int	flags;
X
X	detach_req.dl_primitive = DL_DETACH_REQ;
X
X	ctl.maxlen = 0;
X	ctl.len = sizeof (detach_req);
X	ctl.buf = (char *) &detach_req;
X
X	flags = 0;
X
X	if (putmsg(fd, &ctl, (struct strbuf*) NULL, flags) < 0)
X		if (Debug) Error("dldetachreq:  putmsg");
X}
X
Xdlbindreq(fd, sap, max_conind, service_mode, conn_mgmt, xidtest)
Xint	fd;
Xu_long	sap;
Xu_long	max_conind;
Xu_long	service_mode;
Xu_long	conn_mgmt;
Xu_long	xidtest;
X{
X	dl_bind_req_t	bind_req;
X	struct	strbuf	ctl;
X	int	flags;
X
X	bind_req.dl_primitive = DL_BIND_REQ;
X	bind_req.dl_sap = sap;
X	bind_req.dl_max_conind = max_conind;
X	bind_req.dl_service_mode = service_mode;
X	bind_req.dl_conn_mgmt = conn_mgmt;
X	bind_req.dl_xidtest_flg = xidtest;
X
X	ctl.maxlen = 0;
X	ctl.len = sizeof (bind_req);
X	ctl.buf = (char *) &bind_req;
X
X	flags = 0;
X
X	if (putmsg(fd, &ctl, (struct strbuf*) NULL, flags) < 0)
X		if (Debug) Error("dlbindreq:  putmsg");
X}
X
Xdlunbindreq(fd)
Xint	fd;
X{
X	dl_unbind_req_t	unbind_req;
X	struct	strbuf	ctl;
X	int	flags;
X
X	unbind_req.dl_primitive = DL_UNBIND_REQ;
X
X	ctl.maxlen = 0;
X	ctl.len = sizeof (unbind_req);
X	ctl.buf = (char *) &unbind_req;
X
X	flags = 0;
X
X	if (putmsg(fd, &ctl, (struct strbuf*) NULL, flags) < 0)
X		if (Debug) Error("dlunbindreq:  putmsg");
X}
X
Xdlokack(fd, bufp)
Xint	fd;
Xchar	*bufp;
X{
X	union	DL_primitives	*dlp;
X	struct	strbuf	ctl;
X	int	flags;
X
X	ctl.maxlen = MAXDLBUF;
X	ctl.len = 0;
X	ctl.buf = bufp;
X
X	strgetmsg(fd, &ctl, (struct strbuf*)NULL, &flags, "dlokack");
X
X	dlp = (union DL_primitives *) ctl.buf;
X
X	expecting(DL_OK_ACK, dlp);
X
X	if (ctl.len < sizeof (dl_ok_ack_t))
X		if (Debug) Error("dlokack:  response ctl.len too short:  %d", ctl.len);
X
X	if (flags != RS_HIPRI)
X		if (Debug) Error("dlokack:  DL_OK_ACK was not M_PCPROTO");
X
X	if (ctl.len < sizeof (dl_ok_ack_t))
X		if (Debug) Error("dlokack:  short response ctl.len:  %d", ctl.len);
X}
X
Xdlbindack(fd, bufp)
Xint	fd;
Xchar	*bufp;
X{
X	union	DL_primitives	*dlp;
X	struct	strbuf	ctl;
X	int	flags;
X
X	ctl.maxlen = MAXDLBUF;
X	ctl.len = 0;
X	ctl.buf = bufp;
X
X	strgetmsg(fd, &ctl, (struct strbuf*)NULL, &flags, "dlbindack");
X
X	dlp = (union DL_primitives *) ctl.buf;
X
X	expecting(DL_BIND_ACK, dlp);
X
X	if (flags != RS_HIPRI)
X		if (Debug) Error("dlbindack:  DL_OK_ACK was not M_PCPROTO");
X
X	if (ctl.len < sizeof (dl_bind_ack_t))
X		if (Debug) Error("dlbindack:  short response ctl.len:  %d", ctl.len);
X}
X
Xdlphysaddrack(fd, bufp)
Xint	fd;
Xchar	*bufp;
X{
X	union	DL_primitives	*dlp;
X	struct	strbuf	ctl;
X	int	flags;
X
X	ctl.maxlen = MAXDLBUF;
X	ctl.len = 0;
X	ctl.buf = bufp;
X
X	strgetmsg(fd, &ctl, (struct strbuf*)NULL, &flags, "dlphysaddrack");
X
X	dlp = (union DL_primitives *) ctl.buf;
X
X	expecting(DL_PHYS_ADDR_ACK, dlp);
X
X	if (flags != RS_HIPRI)
X		if (Debug) Error("dlbindack:  DL_OK_ACK was not M_PCPROTO");
X
X	if (ctl.len < sizeof (dl_phys_addr_ack_t))
X		if (Debug) Error("dlphysaddrack:  short response ctl.len:  %d", ctl.len);
X}
X
Xstatic void
Xmysigalrm()
X{
X	Error("sigalrm:  TIMEOUT");
X	exit(1);
X}
X
Xstrgetmsg(fd, ctlp, datap, flagsp, caller)
Xint	fd;
Xstruct	strbuf	*ctlp, *datap;
Xint	*flagsp;
Xchar	*caller;
X{
X	int	rc;
X	static	char	errmsg[80];
X
X	/*
X	 * Start timer.
X	 */
X	(void) signal(SIGALRM, mysigalrm);
X	if (alarm(MAXWAIT) < 0) {
X		(void) sprintf(errmsg, "%s:  alarm", caller);
X		if (Debug) Error(errmsg);
X	}
X
X	/*
X	 * Set flags argument and issue getmsg().
X	 */
X	*flagsp = 0;
X	if ((rc = getmsg(fd, ctlp, datap, flagsp)) < 0) {
X		(void) sprintf(errmsg, "%s:  getmsg", caller);
X		if (Debug) Error(errmsg);
X	}
X
X	/*
X	 * Stop timer.
X	 */
X	if (alarm(0) < 0) {
X		(void) sprintf(errmsg, "%s:  alarm", caller);
X		if (Debug) Error(errmsg);
X	}
X
X	/*
X	 * Check for MOREDATA and/or MORECTL.
X	 */
X	if ((rc & (MORECTL | MOREDATA)) == (MORECTL | MOREDATA))
X		if (Debug) Error("%s:  MORECTL|MOREDATA", caller);
X	if (rc & MORECTL)
X		if (Debug) Error("%s:  MORECTL", caller);
X	if (rc & MOREDATA)
X		if (Debug) Error("%s:  MOREDATA", caller);
X
X	/*
X	 * Check for at least sizeof (long) control data portion.
X	 */
X	if (ctlp->len < sizeof (long))
X		if (Debug) Error("getmsg:  control portion length < sizeof (long):  %d", ctlp->len);
X}
X
Xexpecting(prim, dlp)
Xint	prim;
Xunion	DL_primitives	*dlp;
X{
X	if (dlp->dl_primitive != (u_long)prim)
X	    if (Debug) Error("DLPI: expected %d got %d", prim,
X			     dlp->dl_primitive);
X}
X
X/*
X * Return string.
X */
Xaddrtostring(addr, length, s)
Xu_char	*addr;
Xu_long	length;
Xu_char	*s;
X{
X	int	i;
X
X	for (i = 0; i < length; i++) {
X		(void) sprintf((char*) s, "%x:", addr[i] & 0xff);
X		s = s + strlen((char*)s);
X	}
X	if (length)
X		*(--s) = '\0';
X}
X
X#endif	/* HAVE_DLPI */
END_OF_FILE
if test 6101 -ne `wc -c <'dlpi.c'`; then
    echo shar: \"'dlpi.c'\" unpacked with wrong size!
fi
# end of 'dlpi.c'
fi
if test -f 'info-ultrix.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'info-ultrix.c'\"
else
echo shar: Extracting \"'info-ultrix.c'\" \(7777 characters\)
sed "s/^X//" >'info-ultrix.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: info-ultrix.c,v 1.16 1994/01/12 22:56:08 mcooper Exp mcooper $";
X#endif
X
X/*
X * Ultrix related information
X */
X
X#include "defs.h"
X
X#include <machine/cpuconf.h>
X
X#if	defined(HAVE_PACKETFILTER)
X#include <sys/time.h>
X#include <net/pfilt.h>
X#endif	/* HAVE_PACKETFILTER */
X
X#include <sys/devio.h>
X
X/*
X * CPU type symbol
X */
Xchar				CpuSYM[] = "_cpu";
X
X#if	defined(HAVE_UBA)
X/*
X * UniBus name list
X */
Xchar				UniBusSYM[] = "_ubdinit";
X#endif	/* HAVE_UBA */
X
X/*
X * Device Data Table
X *
X * Compares are done by the length of the string appearing in
X * the first columns.  Therefore, longer names must appear before
X * any shorter names that are not unique.  e.g. "lebuffer" needs to
X * be before "le".
X */
XDEVDATATAB DevDataTab[] = {
X    /*
X     * Disk Drives
X     */
X    { "fd",		NULL,	NULL,	ProbeDiskDrive },
X    { "ra",		NULL,	NULL,	ProbeDiskDrive },
X    { "rz",		NULL,	NULL,	ProbeDiskDrive },
X    /*
X     * Tape Drives
X     */
X    { "mu",		NULL,	NULL,	ProbeTapeDrive },
X    { "stc",		NULL,	NULL,	ProbeTapeDrive },
X    { "tms",		NULL,	NULL,	ProbeTapeDrive },
X    { "ts",		NULL,	NULL,	ProbeTapeDrive },
X    { "tu",		NULL,	NULL,	ProbeTapeDrive },
X    { "tz",		NULL,	NULL,	ProbeTapeDrive },
X    /*
X     * Network Interfaces
X     */
X    { "ln",  	"LANCE Ethernet",	"10Mb/sec Ethernet",	ProbeNetif },
X    { "de",  	"DEC Ethernet",		"10Mb/sec Ethernet",	ProbeNetif },
X    { "ni",  	"DEC Ethernet",		"10Mb/sec Ethernet",	ProbeNetif },
X    { "qe",  	"DEQNA/DELQA Ethernet",	"10Mb/sec Ethernet",	ProbeNetif },
X    { "ne",  	"Second Generation Ethernet","10Mb/sec Ethernet", ProbeNetif },
X    { "xna",  	"DEBNI/DEMNA Ethernet",	"10Mb/sec Ethernet",	ProbeNetif },
X    { "fza",  	"DEFZA FDDI",		"100Mb/sec FDDI",	ProbeNetif },
X    /*
X     * I don't know anything about Ultrix frame buffers
X     */
X    { "cfb",	NULL,  "Color Frame Buffer",			ProbeGeneric },
X    { "pm", 	NULL,  "Graphics Device",			ProbeGeneric },
X    { "px", 	NULL,  "Graphics Device",			ProbeGeneric },
X    { "ga", 	NULL,  "Graphics Device",			ProbeGeneric },
X    { "gq", 	NULL,  "Graphics Device",			ProbeGeneric },
X    { "fb", 	NULL,  "Graphics Device",			ProbeGeneric },
X    /*
X     * Desktop interconnect.
X     */
X    { "dti",	NULL,	"Desktop Interconnect",			ProbeGeneric },
X    /*
X     * Parallel card.
X     */
X    { "pp",
X	  "TC-100",		"parallel card",
X	  ProbeGeneric, DT_GENERIC },
X    /*
X     * PrestoServe card (untested).
X     */
X    { "presto",	
X	  "PrestoServe",	"NFS accelerator card",	
X	  ProbeGeneric, DT_GENERIC },
X    /*
X     * Serial line controllers
X     */
X    { "dc",	
X	  NULL,	"4-port serial line controller",	
X	  ProbeGeneric, DT_GENERIC },
X    { "mdc",	
X	  "DS5100",	"4-port serial line controller",	
X	  ProbeGeneric, DT_GENERIC },
X    { "scc",	
X	  "SCC",	"2-port serial line controller",	
X	  ProbeGeneric, DT_GENERIC },
X    { "cxa",	
X	  "CXA16",	"16-line serial communications interface",	
X	  ProbeGeneric, DT_GENERIC },
X    { "cxy",	
X	  "CXY08",	"8-line serial communications interface",	
X	  ProbeGeneric, DT_GENERIC },
X    { "dhv",	
X	  "DHV11",	"8-line serial communications interface",	
X	  ProbeGeneric, DT_GENERIC },
X    { "dmb",	
X	  "DMB32",	"8-line serial communications interface",	
X	  ProbeGeneric, DT_GENERIC },
X    { "dhq",	
X	  "DHQ11",	"8-line serial communications interface",	
X	  ProbeGeneric, DT_GENERIC },
X    { 0 },
X};
X
X/*
X * Models of DEC machines as defined in <machine/cpuconf.h>
X *
X * XXX We really need to get the number of CPUs in each machine
X * to more closely identify what machine it is.
X */
XNAMETAB ModelTab[] = {
X#ifdef VAX_780
X    {  VAX_780,		"VAX-11/78x" },		/* 780, 785 */
X#endif
X#ifdef VAX_750
X    {  VAX_750,		"VAX-11/750" },
X#endif
X#ifdef VAX_730
X    {  VAX_730,		"VAX-11/730" },
X#endif
X#ifdef VAX_8600
X    {  VAX_8600,	"VAX-86x0" },		/* 8600, 8650 */
X#endif
X#ifdef VAX_8200
X    {  VAX_8200,	"VAX-8[23]x0" },	/* 8200, 8250, 8300, 8350 */
X#endif
X#ifdef VAX_8800
X    {  VAX_8800,	"VAX-8[578]x0" },	/* 8500, 8550, 8700, 8800 */
X#endif
X#ifdef MVAX_I
X    {  MVAX_I,		"MicroVAX-I" },
X#endif
X#ifdef MVAX_II
X    {  MVAX_II,		"MicroVAX-II" },
X#endif
X#ifdef V_VAX
X    {  V_VAX,		"Virtual VAX" },	/* This can't be real 	*/
X#endif
X#ifdef VAX_3600
X    {  VAX_3600,	"VAX-3[26]00" },	/* Mayfair I		*/
X#endif
X#ifdef VAX_6200
X    {  VAX_6200,	"VAX-6[23]00" },	/* CVAX/Calypso		*/
X#endif
X#ifdef VAX_3400
X    {  VAX_3400,	"VAX-3[34]00" },	/* Mayfair II		*/
X#endif
X#ifdef C_VAXSTAR
X    {  C_VAXSTAR,	"VAX-3100" },		/* PVAX			*/
X#endif
X#ifdef VAX_60
X    {  VAX_60,		"VAX-35x0" },		/* Firefox		*/
X#endif
X#ifdef VAX_3900
X    {  VAX_3900,	"VAX-3[89]00" },	/* Mayfair III		*/
X#endif
X#ifdef DS_3100
X    {  DS_3100,		"DECsystem-[23]100" },	/* PMAX			*/
X#endif
X#ifdef VAX_8820
X    {  VAX_8820,	"VAX-88[234]0" },	/* SID for Polarstar	*/
X#endif
X#ifdef DS_5400
X    {  DS_5400,		"DECsystem-5400" },	/* MIPSfair		*/
X#endif
X#ifdef DS_5800
X    {  DS_5800,		"DECsystem-5800" },	/* ISIS			*/
X#endif
X#ifdef DS_5000
X    {  DS_5000,		"DECsystem-5000/200" },	/* 3MAX			*/
X#endif
X#ifdef DS_CMAX
X    {  DS_CMAX,		"DECsystem-CMAX" },
X#endif
X#ifdef VAX_6400
X    {  VAX_6400,	"VAX-6[45]00" },	/* RIGEL/Calypso	*/
X#endif
X#ifdef VAXSTAR
X    {  VAXSTAR,		"VAXstation-2000" },
X#endif
X#ifdef DS_5500
X    {  DS_5500,		"DECsystem-5500" },	/* MIPSFAIR-2		*/
X#endif
X#ifdef DS_5100
X    {  DS_5100,		"DECsystem-5100" },	/* MIPSMATE		*/
X#endif
X#ifdef VAX_9000
X    {  VAX_9000,	"VAX-9000" },		/* VAX9000		*/
X#endif
X#ifdef DS_5000_100
X    {  DS_5000_100,	"DECsystem-5000/100" },	/* 3MIN			*/
X#endif
X#ifdef DS_5000_300
X    {  DS_5000_300,	"DECsystem-5000/240" },	/* 3MAX+		*/
X#endif
X#ifdef DS_MAXINE
X    {  DS_MAXINE,	"DECsystem-5000/20" },	/* MAXine		*/
X#endif
X    {  0 },
X};
X
X/*
X * Tape info as defined in <sys/devio.h>.
X */
XNAMETAB TapeInfo[] = {
X#ifdef DEV_800BPI
X    {  DEV_800BPI,	"800 bpi density" },
X#endif
X#ifdef DEV_1600BPI
X    {  DEV_1600BPI,	"1600 bpi density" },
X#endif
X#ifdef DEV_6250BPI
X    {  DEV_6250BPI,	"6250 bpi density" },
X#endif
X#ifdef DEV_6666BPI
X    {  DEV_6666BPI,	"6666 bpi density" },
X#endif
X#ifdef DEV_10240BPI
X    {  DEV_10240BPI,	"10240 bpi density" },
X#endif
X#ifdef DEV_38000BPI
X    {  DEV_38000BPI,	"38000 bpi density" },
X#endif
X#ifdef DEV_LOADER
X    {  DEV_LOADER,	"media loader present" },
X#endif
X#ifdef DEV_38000_CP
X    {  DEV_38000_CP,	"38000 bpi compacted density" },
X#endif
X#ifdef DEV_76000BPI
X    {  DEV_76000BPI,	"76000 bpi density" },
X#endif
X#ifdef DEV_76000_CP
X    {  DEV_76000_CP,	"76000 bpi compacted density" },
X#endif
X#ifdef DEV_8000_BPI
X    {  DEV_8000_BPI,	"QIC-24 9 track" },
X#endif
X#ifdef DEV_10000_BPI
X    {  DEV_10000_BPI,	"QIC-120 15trk and QIC-150 18trk" },
X#endif
X#ifdef DEV_16000_BPI
X    {  DEV_16000_BPI,	"QIC-320/525 26 track" },
X#endif
X#ifdef DEV_61000_BPI
X    {  DEV_61000_BPI,	"4mm tape cartridge" },
X#endif
X#ifdef DEV_54000_BPI
X    {  DEV_54000_BPI,	"8mm tape cartridge" },
X#endif
X    { 0 },
X};
X
X/*
X * Category types as defined in <sys/devio.h>
X */
XNAMETAB Categorys[] = {
X#ifdef DEV_TAPE
X    {  DEV_TAPE,	"Tape drive" },
X#endif
X#ifdef DEV_DISK
X    {  DEV_DISK,	"Disk drive" },
X#endif
X#ifdef DEV_TERMINAL
X    {  DEV_TERMINAL,	"Terminal" },
X#endif
X#ifdef DEV_PRINTER
X    {  DEV_PRINTER,	"Printer" },
X#endif
X#ifdef DEV_SPECIAL
X    {  DEV_SPECIAL,	"Special" },
X#endif
X    {  0 },
X};
X
X/*
X * Network types table as defined in <net/pfilt.h>
X */
XNAMETAB NetTypes[] = {
X#ifdef ENDT_3MB
X    {  ENDT_3MB,	"3Mb/sec Ethernet" },
X#endif
X#ifdef ENDT_BS3MB
X    {  ENDT_BS3MB,	"Byte Swapped 3Mb/sec Ethernet" },
X#endif
X#ifdef ENDT_10MB
X    {  ENDT_10MB,	"10Mb/sec Ethernet" },
X#endif
X#ifdef ENDT_FDDI
X    {  ENDT_FDDI,	"100Mb/sec FDDI" },
X#endif
X    {  0 },
X};
END_OF_FILE
if test 7777 -ne `wc -c <'info-ultrix.c'`; then
    echo shar: \"'info-ultrix.c'\" unpacked with wrong size!
fi
# end of 'info-ultrix.c'
fi
if test -f 'kbd-sun.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'kbd-sun.c'\"
else
echo shar: Extracting \"'kbd-sun.c'\" \(4744 characters\)
sed "s/^X//" >'kbd-sun.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char *RCSid = "$Id: kbd-sun.c,v 1.5 1994/01/12 22:56:08 mcooper Exp mcooper $";
X#endif
X
X/*
X * The code contained in this file is based on xkeycaps by 
X * Jamie Zawinski <jwz@lucid.com>.  It is been modified slightly
X * for use with sysinfo.
X */
X
X/* xkeycaps, Copyright (c) 1991, 1992, 1993 Jamie Zawinski <jwz@lucid.com>
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation.  No representations are made about the suitability of this
X * software for any purpose.  It is provided "as is" without express or 
X * implied warranty.
X */
X
X/* SunOS-specific stuff: if we're on console, we can query the keyboard
X   hardware directly to find out what kind it is.  I would have just put
X   this code in guess.c, but vuid_event.h defines a `struct keyboard' 
X   that conflicts with our own...
X */
X
X#include "defs.h"
X
X#if __STDC__
X#include <stdlib.h>
X#include <unistd.h>
Xextern char *strdup (const char *);
X#endif
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <string.h>
X#include <sys/time.h>
X#include <sys/stream.h>
X#include <sys/stropts.h>
X#include <sys/fcntl.h>
X#include <sys/ioctl.h>
X#if	defined(SVR4) || (defined(SUNOS) && SUNOS == 5)
X#include <sys/vuid_event.h>
X#include <sys/kbio.h>
X#include <sys/kbd.h>
X#else
X#include <sundev/vuid_event.h>
X#include <sundev/kbio.h>
X#include <sundev/kbd.h>
X#endif
X
X#define KBD_DEVICE		"/dev/kbd"
X
Xchar *
Xxkeycaps_guess_local_keyboard_type ()
X{
X  int type = -1, layout = 0;
X  int kbdfd;
X
X  if ((kbdfd = open (KBD_DEVICE, O_WRONLY)) <= 0) {
X      if (Debug) Error("Cannot open %s: %s.", KBD_DEVICE, SYSERR);
X      return 0;
X  }
X  if (ioctl (kbdfd, KIOCTYPE, &type) == -1)
X    {
X      if (Debug) Error("ioctl KIOCTYPE of %s failed: %s.", KBD_DEVICE, SYSERR);
X      close (kbdfd);
X      return 0;
X    }
X  if (ioctl (kbdfd, KIOCLAYOUT, &layout) == -1)
X      if (Debug) Error("ioctl KIOCLAYOUT of %s failed: %s.",KBD_DEVICE,SYSERR);
X  close (kbdfd);
X
X  switch (type) {
X  case -1:	  return 0;
X  case KB_ASCII:  return "Generic ASCII Terminal";	/* Ascii terminal */
X  case KB_KLUNK:  return "MS103SD32-2";	/* Micro Switch 103SD32-2 */
X  case KB_VT100:  return "Sun VT100";	/* Keytronics VT100 compatible */
X  case KB_VT220:  return "Sun VT220";	/* vt220 Emulation */
X  case KB_VT220I: return "Sun VT220i";	/* International vt220 Emulation */
X  case KB_SUN2:   return "Sun Type-2";
X  case KB_SUN3:   return "Sun Type-3";
X  case KB_SUN4:
X    switch (layout) {
X    case  0: return "Sun Type-4"; /* Part 320-1005-02 REV A. */
X    case  1: return "Sun Type-4"; /* Part 320-1005-01 REV B.  Seems identical... */
X    case 33: return "Sun Type-5 PC";
X    case 34: return "Sun Type-5 Unix";
X    case 35: return "Sun Type-5 French";
X    case 36: return "Sun Type-5 Danish";
X    case 37: return "Sun Type-5 German";
X    case 38: return "Sun Type-5 Italian";
X    case 39: return "Sun Type-5 Dutch";
X    case 40: return "Sun Type-5 Norwegian";
X    case 41: return "Sun Type-5 Portuguese";
X    case 42: return "Sun Type-5 Spanish";
X    case 43: return "Sun Type-5 Swedish/Finnish";
X    case 44: return "Sun Type-5 Swiss/French";
X    case 45: return "Sun Type-5 Swiss/German";
X    case 46: return "Sun Type-5 UK";
X    case 47: return "Sun Type-5 Korean";
X    case 48: return "Sun Type-5 Taiwanese";
X    case 49: return "Sun Type-5 Nihon-go";
X    default:
X      {
X	char buf [255];
X	sprintf (buf, "Sun Type-4 Layout %d", layout);
X	return strdup (buf);
X      }
X    }
X  default:
X    {
X      char buf [255];
X      if (layout)
X	sprintf (buf, "Sun Type-%d Layout %d", type, layout);
X      else
X	sprintf (buf, "Sun Type-%d", type);
X      return strdup (buf);
X    }
X  }
X}
X
X/*
X * Keyboard Probe routine.
X */
Xextern DEVICE *ProbeKbd(TreePtr)
X    DEVICE		      **TreePtr;
X{
X    DEVICE		       *DevPtr;
X    DEVICE		       *KbdDev;
X    static char		       *KbdType = NULL;
X
X    /*
X     * If we've already been called, return now.
X     */
X    if (KbdType)
X	return((DEVICE *) NULL);
X
X    KbdType = xkeycaps_guess_local_keyboard_type();
X    if (!KbdType)
X	return((DEVICE *) NULL);
X
X    if (!(KbdDev = NewDevice(NULL))) {
X	Error("Cannot create new kbd device.");
X	return((DEVICE *) NULL);
X    }
X
X    KbdDev->dv_name = "kbd";
X    KbdDev->dv_type = DT_KEYBOARD;
X    KbdDev->dv_model = KbdType;
X
X    if (TreePtr) {
X	DevPtr = *TreePtr;
X	/*
X	 * Set device master to be the top node if the top node
X	 * has no peers.
X	 */
X	if (!DevPtr->dv_name &&
X	    DevPtr->dv_slaves && !DevPtr->dv_slaves->dv_nxt)
X	    KbdDev->dv_master = DevPtr->dv_slaves;
X    }
X
X    return(KbdDev);
X}
END_OF_FILE
if test 4744 -ne `wc -c <'kbd-sun.c'`; then
    echo shar: \"'kbd-sun.c'\" unpacked with wrong size!
fi
# end of 'kbd-sun.c'
fi
if test -f 'macinfo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'macinfo.c'\"
else
echo shar: Extracting \"'macinfo.c'\" \(6204 characters\)
sed "s/^X//" >'macinfo.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: macinfo.c,v 1.6 1994/01/12 22:56:08 mcooper Exp mcooper $";
X#endif
X
X/*
X * Media Access Control (MAC) info routines
X */
X
X#include "defs.h"
X
X#if	GETMAC_TYPE == GETMAC_NIT
X
X#include <sys/time.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <net/if.h>
X#include <net/nit_if.h>
X
X/*
X * Find and set the MAC info using the Network Interface Tap (NIT)
X */
Xextern void SetMacInfo(DevName, NetIf)
X    char 		       *DevName;
X    NETIF 		       *NetIf;
X{
X    register struct sockaddr   *SockAddr;
X    struct ifreq 	        ifreq;
X    char 		       *ether_ntoa(), Buf[MAXHOSTNAMLEN+1];
X    int 		        Desc;
X
X    if (!NetIf)
X	return;
X
X    if ((Desc = open("/dev/nit", O_RDONLY)) == SYSFAIL) {
X	if (Debug) Error("open /dev/nit failed");
X	return;
X    }
X
X    /*
X     * Bind to NIT for DevName
X     */
X    strncpy(ifreq.ifr_name, DevName, sizeof ifreq.ifr_name);
X    if (ioctl(Desc, NIOCBIND, (caddr_t) &ifreq) < 0) {
X	if (Debug) Error("ioctl:  NIOCBIND");
X	return;
X    }
X
X    /*
X     * Get address
X     */
X    if (ioctl(Desc, SIOCGIFADDR, (caddr_t)&ifreq) < 0) {
X	if (Debug) Error("ioctl (SIOCGIFADDR)");
X	return;
X    }
X
X    (void) close(Desc);
X
X    SockAddr = (struct sockaddr *)&ifreq.ifr_addr;
X    NetIf->ni_macaddr = strdup(ether_ntoa((struct ether_addr *) 
X					  SockAddr->sa_data));
X
X    if (ether_ntohost(Buf, (struct ether_addr *) SockAddr->sa_data) == 0)
X	NetIf->ni_macname = strdup(Buf);
X}
X#endif	/* HAVE_NIT */
X
X#if	GETMAC_TYPE == GETMAC_DLPI
X
X#include <sys/time.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <net/if.h>
X#include <sys/dlpi.h>
X#include <netinet/in.h>
X#include <netinet/if_ether.h>
X#include "dlpi.h"
X
X/*
X * Find and set the MAC info using the Data Link Provider Interface (DLPI)
X */
Xextern void SetMacInfo(DevName, NetIf, Device)
X    char 		       *DevName;
X    NETIF 		       *NetIf;
X    DEVICE		       *Device;
X{
X    char 		        buff[MAXHOSTNAMLEN+1];
X    int 		        fd;
X    long			dlbuf[MAXDLBUF];
X    static char			devname[MAXPATHLEN];
X    static struct ether_addr	ether_addr;
X    register char	       *cp;
X    union DL_primitives	       *dlp;
X    u_char			addr[MAXDLADDR];
X
X    if (!NetIf)
X	return;
X
X    dlp = (union DL_primitives *) dlbuf;
X    (void) sprintf(devname, "%s/%s", _PATH_DEV, DevName);
X    /*
X     * Remove unit part of name from the device name.
X     */
X    if (cp = rindex(devname, '/')) {
X	++cp;
X	while (!isdigit(*cp) && ++cp);
X	if (isdigit(*cp))
X	    *cp = C_NULL;
X    }
X
X    if ((fd = open(devname, O_RDWR)) == SYSFAIL) {
X	if (Debug) Error("Cannot open %s: %s.", devname, SYSERR);
X	return;
X    }
X
X    /*
X     * Setup
X     */
X    dlattachreq(fd, Device->dv_unit);
X    dlokack(fd, dlbuf);
X    dlbindreq(fd, 0, 0, DL_CLDLS, 0, 0);
X    dlbindack(fd, dlbuf);
X
X    /*
X     * Get current physical address
X     */
X    dlphysaddrreq(fd, DL_CURR_PHYS_ADDR);
X    dlphysaddrack(fd, dlbuf);
X
X    addrtostring(OFFADDR(dlp, dlp->physaddr_ack.dl_addr_offset),
X		 dlp->physaddr_ack.dl_addr_length, addr);
X
X    NetIf->ni_macaddr = strdup(addr);
X
X    BCOPY((char *) OFFADDR(dlp, dlp->physaddr_ack.dl_addr_offset), 
X	  (char *) ether_addr.ether_addr_octet, 
X	  dlp->physaddr_ack.dl_addr_length);
X    if (ether_ntohost(buff, &ether_addr) == 0)
X	NetIf->ni_macname = strdup(buff);
X
X    /*
X     * Get factory physical address
X     */
X    dlphysaddrreq(fd, DL_FACT_PHYS_ADDR);
X    dlphysaddrack(fd, dlbuf);
X
X    addrtostring(OFFADDR(dlp, dlp->physaddr_ack.dl_addr_offset),
X		 dlp->physaddr_ack.dl_addr_length, addr);
X
X    NetIf->ni_fmacaddr = strdup(addr);
X
X    BCOPY((char *) OFFADDR(dlp, dlp->physaddr_ack.dl_addr_offset), 
X	  (char *) ether_addr.ether_addr_octet, 
X	  dlp->physaddr_ack.dl_addr_length);
X    if (ether_ntohost(buff, &ether_addr) == 0)
X	NetIf->ni_fmacname = strdup(buff);
X
X    /*
X     * We're done
X     */
X    dlunbindreq(fd);
X    dldetachreq(fd);
X    (void) close(fd);
X}
X#endif	/* HAVE_DLPI */
X
X#if	defined(HAVE_PACKETFILTER)
X
X#include <sys/time.h>
X#include <net/pfilt.h>
X
X#include <fcntl.h>
X#include <sys/socket.h>
X#include <net/if.h>
X#include <netinet/in.h>
X#include <netinet/if_ether.h>
X
X#if	defined(NEED_ETHER_ADDR)
X/*
X * This didn't appear in <netinet/if_ether.h> until Ultrix 4.2 (4.1?)
X */
Xstruct ether_addr {
X	u_char	ether_addr_octet[6];
X};
X#endif	/* NEED_ETHER_ADDR */
X
X/*
X * Get network type information
X */
Xstatic char *GetNetType(type)
X    int				type;
X{
X    extern NAMETAB		NetTypes[];
X    register int		i;
X
X    for (i = 0; NetTypes[i].name; i++)
X	if (NetTypes[i].value == type)
X	    return(NetTypes[i].name);
X
X    return((char *) NULL);
X}
X
X/*
X * Find and set the MAC info using the Packet Filter
X */
Xextern void SetMacInfo(DevName, Netif, Device)
X     char 		       *DevName;
X     NETIF 		       *Netif;
X     DEVICE		       *Device;
X{
X    struct endevp		endevp;
X    struct ether_addr		ether_addr;
X    char 		       *ether_ntoa(), HostBuf[MAXHOSTNAMLEN+1];
X    char 		       *p;
X    int 		        Desc;
X
X    if (!DevName || !Netif)
X	return;
X
X    /*
X     * Open this device using the packet filter
X     */
X    if ((Desc = pfopen(DevName, O_RDONLY)) < 0) {
X	if (Debug) Error("pfopen %s failed: %s.", DevName, SYSERR);
X	return;
X    }
X
X    /*
X     * Retrieve info
X     */
X    if (ioctl(Desc, EIOCDEVP, &endevp) < 0) {
X	if (Debug) Error("ioctl EIOCDEVP of %s failed: %s.", DevName, SYSERR);
X	return;
X    }
X
X    close(Desc);
X
X    /*
X     * Convert address into ethers(5) format
X     */
X    BCOPY((char *) endevp.end_addr,
X	  (char *) ether_addr.ether_addr_octet,
X	  endevp.end_addr_len);
X
X    /*
X     * Set what we now know.
X     */
X    if (p = ether_ntoa(&ether_addr))
X	Netif->ni_macaddr = strdup(p);
X
X    if (ether_ntohost(HostBuf, &ether_addr) == 0)
X	Netif->ni_macname = strdup(HostBuf);
X
X    if (Device && (p = GetNetType(endevp.end_dev_type)))
X	AddDevDesc(Device, p, NULL, DA_INSERT|DA_PRIME);
X}
X#endif	/* HAVE_PACKETFILTER */
X
X#if	!defined(GETMAC_TYPE)
Xextern void SetMacInfo(DevName, NetIf)
X    /*ARGSUSED*/
X    char 		       *DevName;
X    NETIF 		       *NetIf;
X{
X    /* Do Nothing */
X}
X#endif	/* !GETMAC_TYPE */
END_OF_FILE
if test 6204 -ne `wc -c <'macinfo.c'`; then
    echo shar: \"'macinfo.c'\" unpacked with wrong size!
fi
# end of 'macinfo.c'
fi
if test -f 'options.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'options.c'\"
else
echo shar: Extracting \"'options.c'\" \(10034 characters\)
sed "s/^X//" >'options.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1990 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/lib/libuscgen/RCS/options.c,v 1.18 1993/10/13 00:18:05 mcooper Exp $";
X#endif
X
X/*
X * Functions to parse options.
X */
X
X#if	defined(HAVE_OSCONFIG_H)
X#include "osconfig.h"
X#else
X#ifdef HAVE_VARARGS
X#include <varargs.h>
X#endif	/* HAVE_VARARGS */
X#endif	/* HAVE_OSCONFIG_H */
X#include "options.h"
X
Xchar *OptionChars = "-+";	/* Default option switching characters */
Xchar *ProgramName = NULL;	/* Name of this program */
Xstatic char *UsageString();
Xstatic int isopt();
Xstatic int suppress_help_msg = 0;
X
X/*
X * ParseOptions - Parse options found in argv using "options".
X *		  Returns the number of options parsed if there
X *		  were no errors.  Returns -1 if an error occurs.
X */
Xint ParseOptions(options, num_options, argc, argv)
X     OptionDescRec *options;
X     int num_options;
X     int argc;
X     char **argv;
X{
X    OptionDescRec *opt;
X    register int x;
X    char *p;
X
X    if (ProgramName == NULL)
X	ProgramName = argv[0];
X
X#ifdef OPTION_DEBUG
X    (void) printf("Option list is:\n");
X    for (x = 0; x < num_options; ++x) {
X	opt = &options[x];
X	(void) printf("%s\n", opt->option);
X    }
X
X    (void) printf("Arguments (%d):", argc);
X    for (x = 0; x < argc; ++x) {
X	(void) printf(" %s", argv[x]);
X    }
X    (void) printf("\n");
X#endif /* OPTION_DEBUG */
X
X    for (x = 1; x < argc; ++x) {
X	if (strcmp(HELPSTR, argv[x]) == 0) {
X	    HelpOptions(options, num_options, (char **)NULL);
X	    exit(0);
X	}
X
X	opt = FindOption(options, num_options, argv[x]);
X	if (opt == NULL) {
X	    if (isopt(argv[x])) { /* this was suppose to be an option */
X		UsageOptions(options, num_options, argv[x]);
X		return(-1);
X	    } else { /* must be end of options */
X		break;
X	    }
X	}
X
X	if (opt->flags & NoArg) {
X	    if (!(*opt->cvtarg)(opt, opt->value, FALSE)) {
X		UsageOptions(options, num_options, opt->option);
X		return(-1);
X	    }
X	} else if (opt->flags & IsArg) {
X	    if (!(*opt->cvtarg)(opt, opt->option, FALSE)) {
X		UsageOptions(options, num_options, opt->option);
X		return(-1);
X	    }
X	} else if ((opt->flags & StickyArg) && (opt->flags & SepArg)) {
X	    p = (char *) &argv[x][strlen(opt->option)];
X	    if (!*p) {		/*** SepArg ***/
X		if (x + 1 >= argc || isopt(argv[x+1])) {
X		    if (opt->value == (caddr_t) NULL) {
X			UserError("%s: Option requires an argument.", argv[x]);
X			UsageOptions(options, num_options, opt->option);
X			return(-1);
X		    }
X		    p = opt->value;
X		} else {
X		    p = argv[++x];
X		}
X	    }
X	    if (!(*opt->cvtarg)(opt, p, TRUE)) {
X		UsageOptions(options, num_options, opt->option);
X		return(-1);
X	    }
X	} else if (opt->flags & StickyArg) {
X	    p = (char *) &argv[x][strlen(opt->option)];
X	    if (!*p) {
X		if (opt->value == (caddr_t) NULL) {
X		    UserError("%s: Option requires an argument.", argv[x]);
X		    UsageOptions(options, num_options, opt->option);
X		    return(-1);
X		} else {
X		    p = opt->value;
X		}
X	    }
X	    if (!(*opt->cvtarg)(opt, p, TRUE)) {
X		UsageOptions(options, num_options, opt->option);
X		return(-1);
X	    }
X	} else if (opt->flags & SepArg) {
X	    if (x + 1 >= argc || isopt(argv[x+1])) {
X		if (opt->value == (caddr_t) NULL) {
X		    UserError("%s: Option requires an argument.", argv[x]);
X		    UsageOptions(options, num_options, opt->option);
X		    return(-1);
X		} else {
X		    p = opt->value;
X		}
X	    } else {
X		p = argv[++x];
X	    }
X	    if (!(*opt->cvtarg)(opt, p, TRUE)) {
X		UsageOptions(options, num_options, opt->option);
X		return(-1);
X	    }
X	} else if (opt->flags & SkipArg) {
X	    x += 2;
X	} else if (opt->flags & SkipLine) {
X	    return(x);
X	} else if (opt->flags & SkipNArgs) {
X	    if (opt->value) {
X		x += atoi(opt->value);
X	    } else {
X		UserError("Internal Error: No 'value' set for SkipNArgs.");
X		return(-1);
X	    }
X	} else {
X	    UserError("Internal Error: Unknown argument type for option '%s'.",
X		     opt->option);
X	    return(-1);
X	}
X    }
X
X    return(x);
X}
X
X/*
X * FindOption - Find "option" in "options".  Returns NULL if not found.
X */
XOptionDescRec *FindOption(options, num_options, option)
X     OptionDescRec *options;
X     int num_options;
X     char *option;
X{
X    OptionDescRec *opt;
X    register int x;
X
X    for (x = 0; x < num_options; ++x) {
X	opt = &options[x];
X	if (opt->flags & StickyArg) {
X	    if (strncmp(option, opt->option, strlen(opt->option)) == 0)
X		return(opt);
X	} else {
X	    if (strncmp(option, opt->option, strlen(option)) == 0)
X		return(opt);
X	}
X    }
X
X    return(NULL);
X}
X
X/*
X * isopt - Is "str" an option string?  Compare first char of str against
X *	   list of option switch characters.  Returns TRUE if it is an option.
X */
Xstatic int isopt(str)
X     char *str;
X{
X    register char *p;
X
X    for (p = OptionChars; p && *p; ++p) {
X	if (*str == *p) {
X	    return(TRUE);
X	}
X    }
X
X    return(FALSE);
X}
X
X/*
X * UsageOptions - Print a usage message based on "options".
X */
Xvoid UsageOptions(options, num_opts, badOption)
X     OptionDescRec *options;
X     int num_opts;
X     char *badOption;
X{
X    OptionDescRec *opt;
X    char *optstr;
X    register int x;
X    int col, len;
X
X    if (badOption) 
X	(void) fprintf (stderr, "%s:  bad command line option \"%s\"\r\n\n",
X			ProgramName, badOption);
X
X    (void) fprintf (stderr, "usage:  %s", ProgramName);
X    col = 8 + strlen(ProgramName);
X    for (x = 0; x < num_opts; x++) {
X	opt = &options[x];
X	if (opt->flags & ArgHidden)
X	    continue;
X	optstr = UsageString(opt);
X	len = strlen(optstr) + 3;	/* space [ string ] */
X	if (col + len > 79) {
X	    (void) fprintf (stderr, "\r\n   ");  /* 3 spaces */
X	    col = 3;
X	}
X	(void) fprintf (stderr, " [%s]", optstr);
X	col += len;
X    }
X
X    if (suppress_help_msg)
X	(void) fprintf(stderr, "\r\n\n");
X    else
X	(void) fprintf(stderr, 
X		       "\r\n\nType \"%s %s\" for a full description.\r\n\n",
X		       ProgramName, HELPSTR);
X}
X
X/*
X * HelpOptions - Print a nice help/usage message based on options.
X */
Xvoid HelpOptions(options, num_opts, message)
X     OptionDescRec *options;
X     int num_opts;
X     char **message;
X{
X    OptionDescRec *opt;
X    register int x;
X    char **cpp;
X
X    suppress_help_msg = 1;
X    UsageOptions(options, num_opts, (char *)NULL);
X    suppress_help_msg = 0;
X
X    (void) fprintf (stderr, "where options include:\n");
X    for (x = 0; x < num_opts; x++) {
X	opt = &options[x];
X	if (opt->flags & ArgHidden)
X	    continue;
X	(void) fprintf (stderr, "    %-28s %s\n", UsageString(opt), 
X		 (opt->desc) ? opt->desc : "");
X	if (opt->value && opt->cvtarg != OptBool)
X	    (void) fprintf (stderr, "    %-28s [ Default value is %s ]\n", 
X			    "", opt->value);
X    }
X
X    if (message) {
X	(void) putc ('\n', stderr);
X	for (cpp = message; *cpp; cpp++) {
X	    (void) fputs (*cpp, stderr);
X	    (void) putc ('\n', stderr);
X	}
X	(void) putc ('\n', stderr);
X    }
X}
X
XOptBool(opt, value, docopy)
X     OptionDescRec *opt;
X     caddr_t value;
X     int docopy; /*ARGSUSED*/
X{
X    char *vpp;
X
X    *(int *) opt->valp = (int) strtol(value, &vpp, 0);
X    if (*vpp) {
X	UserError("Invalid integer argument for '%s'.", opt->option);
X	return(FALSE);
X    } else {
X	return(TRUE);
X    }
X}
X
XOptInt(opt, value, docopy)
X     OptionDescRec *opt;
X     caddr_t value;
X     int docopy; /*ARGSUSED*/
X{
X    char *vpp;
X
X    *(int *) opt->valp = (int) strtol(value, &vpp, 0);
X    if (*vpp) {
X	UserError("Invalid integer argument for '%s'.", opt->option);
X	return(FALSE);
X    } else {
X	return(TRUE);
X    }
X}
X
XOptShort(opt, value, docopy)
X     OptionDescRec *opt;
X     caddr_t value;
X     int docopy; /*ARGSUSED*/
X{
X    char *vpp;
X
X    *(short *) opt->valp = (short) strtol(value, &vpp, 0);
X    if (*vpp) {
X	UserError("Invalid integer argument for '%s'.", opt->option);
X	return(FALSE);
X    } else {
X	return(TRUE);
X    }
X}
X
XOptLong(opt, value, docopy)
X     OptionDescRec *opt;
X     caddr_t value;
X     int docopy; /*ARGSUSED*/
X{
X    char *vpp;
X
X    *(long *) opt->valp = (long) strtol(value, &vpp, 0);
X    if (*vpp) {
X	UserError("Invalid integer argument for '%s'.", opt->option);
X	return(FALSE);
X    } else {
X	return(TRUE);
X    }
X}
X
XOptStr(opt, value, docopy)
X     OptionDescRec *opt;
X     caddr_t value;
X     int docopy;
X{
X    char *p;
X
X    if (docopy) {
X	if ((p = (char *) malloc((unsigned)strlen(value)+1)) == NULL) {
X	    UserError("Cannot malloc memory: %s", SYSERR);
X	    return(FALSE);
X	}
X	(void) strcpy(p, value);
X    } else {
X	p = value;
X    }
X
X    *(char **) opt->valp = p;
X
X    return(TRUE);
X}
X
Xstatic char *UsageString(opt)
X     OptionDescRec *opt;
X{
X    static char buf[BUFSIZ], buf2[BUFSIZ];
X
X    (void) sprintf(buf, opt->option);
X    (void) strcpy(buf2, "");
X    if (opt->usage) {
X	(void) sprintf(buf2, "%s%s%s%s",
X		       ((opt->flags & StickyArg) && 
X			!((opt->flags & StickyArg) && (opt->flags & SepArg))) 
X		       ? "" : " ",
X		       (opt->value) ? "[" : "",
X		       opt->usage,
X		       (opt->value) ? "]" : ""
X		       );
X    }
X    (void) strcat(buf, buf2);
X
X    return(buf);
X}
X
X/*
X * UserError - Print a user error.
X */
X#if	defined(ARG_TYPE) && ARG_TYPE == ARG_STDARG
Xvoid UserError(char *fmt, ...)
X{
X    va_list args;
X
X    if (ProgramName)
X	(void) fprintf(stderr, "%s: ", ProgramName);
X
X    va_start(args, fmt);
X    (void) vfprintf(stderr, fmt, args);
X    va_end(args);
X
X    (void) fprintf(stderr, "\n");
X}
X#endif	/* ARG_STDARG */
X#if	(defined(ARG_TYPE) && ARG_TYPE == ARG_VARARGS) || defined(HAVE_VARARGS)
Xvoid UserError(va_alist)
X    va_dcl
X{
X    va_list args;
X    char *fmt;
X
X    va_start(args);
X    if (ProgramName)
X	(void) fprintf(stderr, "%s: ", ProgramName);
X    fmt = (char *) va_arg(args, char *);
X    (void) vfprintf(stderr, fmt, args);
X    va_end(args);
X    (void) fprintf(stderr, "\n");
X}
X#endif	/* ARG_VARARGS */
X#if	!defined(ARG_TYPE) && !defined(HAVE_VARARGS)
Xvoid UserError(fmt, a1, a2, a3, a4, a5, a6)
X    char *fmt;
X{
X    if (ProgramName)
X	(void) fprintf(stderr, "%s: ", ProgramName);
X    (void) fprintf(stderr, fmt, a1, a2, a3, a4, a5, a6);
X    (void) fprintf(stderr, "\n");
X}
X#endif	/* !ARG_TYPE */
END_OF_FILE
if test 10034 -ne `wc -c <'options.c'`; then
    echo shar: \"'options.c'\" unpacked with wrong size!
fi
# end of 'options.c'
fi
if test -f 'os-next.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'os-next.c'\"
else
echo shar: Extracting \"'os-next.c'\" \(10934 characters\)
sed "s/^X//" >'os-next.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: os-next.c,v 1.22 1994/02/11 18:30:14 mcooper Exp mcooper $";
X#endif
X
X
X/*
X * NeXT specific functions
X */
X
X#include "defs.h"
X
X#include <nlist.h>
X#include <mntent.h>
X#if	NEXTSTEP >= 3
X#include <bsd/dev/disk.h>
X#if	defined(mc68k)
X#include <bsd/dev/m68k/busvar.h>
X#endif	/* mc68k */
X#else	/* NEXTSTEP < 3 */
X#include <nextdev/disk.h>
X#include <nextdev/busvar.h>
X#endif	/* NEXTSTEP >= 3 */
X
X#define DV_SIZE		(sizeof(struct bus_device))
X#define DR_SIZE		(sizeof(struct bus_driver))
X#define CR_SIZE		(sizeof(struct bus_ctrl))
X
X/*
X * Build a device tree by searching NeXTBus
X */
Xstatic int BuildNeXTBus(TreePtr)
X    DEVICE 		      **TreePtr;
X{
X    extern char		 	NeXTBusSYM[];
X    struct nlist	       *nlptr;
X    static struct nlist		nlistbuf;
X    static struct bus_device 	Device;
X    static struct bus_driver 	Driver;
X    static struct bus_ctrl 	Ctlr;
X    static char 		CtlrName[BUFSIZ], DevName[BUFSIZ];
X    u_long 			Addr, DeviceAddr;
X    static DEVDATA 		DevData;
X    DEVICE 		       *Dev;
X    kvm_t		       *kd;
X
X    /*
X     * Read table address from kernel
X     */
X    if (!(kd = KVMopen()))
X	return(-1);
X
X    if ((nlptr = KVMnlist(kd, NeXTBusSYM, &nlistbuf)) == NULL)
X	return(-1);
X
X    if (CheckNlist(nlptr))
X	return(-1);
X
X    /*
X     * Read each device table entry.  A NULL device.bd_driver
X     * indicates that we're at the end of the table.
X     */
X    for (DeviceAddr = nlptr->n_value; DeviceAddr; 
X	 DeviceAddr += DV_SIZE) {
X
X	/*
X	 * Read this device
X	 */
X	if (KVMread(kd, DeviceAddr, (char *) &Device, DV_SIZE), FALSE) {
X	    if (Debug) 
X		Error("Cannot read NeXTbus device from address 0x%x.", 
X		      DeviceAddr);
X	    KVMclose(kd);
X	    return(-1);
X	}
X
X	/*
X	 * See if we're done.
X	 */
X	if (!Device.bd_driver)
X	    break;
X
X	/*
X	 * Get the device name
X	 */
X	DevName[0] = C_NULL;
X	if (Addr = (u_long) Device.bd_name) {
X	    if (KVMread(kd, Addr, (char *) DevName, sizeof(DevName), TRUE)) {
X		if (Debug)
X		    Error("Cannot read device name from address 0x%x.", Addr);
X		continue;
X	    }
X	}
X
X	/*
X	 * Get the controller info
X	 */
X	CtlrName[0] = C_NULL;
X	/*
X	 * First read the controller structure in
X	 */
X	if (Addr = (u_long) Device.bd_bc) {
X	    if (KVMread(kd, Addr, (char *) &Ctlr, CR_SIZE, FALSE)) {
X		if (Debug) 
X		    Error("Cannot read controller from address 0x%x.", Addr);
X	    } else if (Addr = (u_long) Ctlr.bc_driver) {
X		/*
X		 * Get the controller driver
X		 */
X		if (KVMread(kd, Addr, (char *) &Driver, DR_SIZE, FALSE)) {
X		    if (Debug)
X			Error(
X			    "Cannot read controller driver from address 0x%x.",
X			      Addr);
X		    continue;
X		}
X		/*
X		 * Read the name of the controller from the driver
X		 */
X		if (!(Addr = (u_long) Driver.br_cname)) {
X		    if (Debug)
X			Error("No name for controller at address 0x%x.",
X			      Ctlr.bc_driver);
X		    continue;
X		}
X		if (KVMread(kd, Addr, CtlrName, sizeof(CtlrName), TRUE)) {
X		    if (Debug)
X			Error("Read controller name failed (address 0x%x).",
X			      Addr);
X		    continue;
X		}
X	    }
X	}
X
X	if (Debug)
X	    printf("NeXTbus: Found '%s' on '%s'.\n", DevName, CtlrName);
X
X	/* Make sure devdata is clean */
X	bzero(&DevData, sizeof(DEVDATA));
X
X	/* Set what we know */
X	if (DevName[0]) {
X	    DevData.dd_devname = strdup(DevName);
X	    DevData.dd_devunit = Device.bd_unit;
X	    DevData.dd_slave = Device.bd_slave;
X	}
X	if (CtlrName[0]) {
X	    DevData.dd_ctlrname = strdup(CtlrName);
X	    DevData.dd_ctlrunit = Ctlr.bc_ctrl;
X	}
X
X	/* 
X	 * NeXTbus devices should always exist.
X	 */
X	if (Device.bd_alive)
X	    DevData.dd_flags |= DD_IS_ALIVE;
X
X	/* Probe and add device */
X	if (Dev = (DEVICE *) ProbeDevice(&DevData, TreePtr, NULL))
X	    AddDevice(Dev, TreePtr);
X    }
X
X    KVMclose(kd);
X
X    return(0);
X}
X
X/*
X * Build list of NeXT devices
X */
Xextern int BuildDevicesNeXT(TreePtr)
X    DEVICE 		      **TreePtr;
X{
X    int				Found = 1;
X
X    if (BuildNeXTBus(TreePtr) == 0)
X	Found = 0;
X
X    return(Found);
X}
X
X/*
X * Get the system model name.  NeXT keeps the system type
X * in a kernel variable called machine_type.
X * The system types are defined in <next/scr.h>.
X */
Xextern char *GetModelName()
X{
X    static struct nlist		nlBuff;
X    struct nlist	       *nlptr;
X    extern NAMETAB		ModelTab[];
X    extern char			MachineTypeSYM[];
X    u_char			MachineType;
X    register int		i;
X    kvm_t		       *kd;
X
X    if (!(kd = KVMopen()))
X	return((char *) NULL);
X
X    /*
X     * The "nlBuff" is necessary as a workaround to a GCC bug.
X     */
X    if ((nlptr = KVMnlist(kd, MachineTypeSYM, &nlBuff)) == NULL)
X	return((char *) NULL);
X
X    if (CheckNlist(nlptr))
X	return((char *) NULL);
X
X    if (KVMread(kd, (u_long) nlptr->n_value, 
X		(char *) &MachineType, sizeof(MachineType), FALSE)) {
X	if (Debug) Error("Cannot read \"%s\" from kernel.", MachineTypeSYM);
X	return((char *) NULL);
X    }
X
X    KVMclose(kd);
X
X    for (i = 0; ModelTab[i].name; ++i)
X	if (ModelTab[i].value == MachineType)
X	    return(ModelTab[i].name);
X
X    if (Debug)
X	printf("system model/type %d is unknown.\n", MachineType);
X
X    return((char *) NULL);
X}
X
X/*
X * Get application architecture name using Mach HostInfo method.
X */
Xextern char *GetAppArchName()
X{
X    char		       *GetAppArchFromHostInfo();
X
X    return(GetAppArchFromHostInfo());
X}
X
X/*
X * Get kernel architecture name using Mach HostInfo method.
X */
Xextern char *GetKernArchName()
X{
X    char		       *GetKernArchFromHostInfo();
X
X    return(GetKernArchFromHostInfo());
X}
X
X/*
X * Get system serial number
X */
Xextern char *GetSerialNoStr()
X{
X    return(UnSupported);
X}
X
X/*
X * Get OS version using Mach HostInfo method.
X */
Xextern char *GetOSVersionStr()
X{
X    char		       *GetOSVersionFromHostInfo();
X
X    return(GetOSVersionFromHostInfo());
X}
X
X/*
X * Get filesystem mount info for a partition.
X */
Xstatic char *GetMountInfo(Name, Part)
X    char 		       *Name;
X    char 		       *Part;
X{
X    FILE 		       *mf;
X    struct mntent 	       *mntent;
X    char 		       *file;
X
X    if (!Name)
X	return((char *) NULL);
X
X    file = GetCharFile(Name, Part);
X
X    if ((mf = setmntent(MNTTAB, "r")) == NULL) {
X	Error("%s: Cannot open for reading: %s.", MNTTAB, SYSERR);
X	return(NULL);
X    }
X
X    while (mntent = getmntent(mf)) {
X	if (strcmp(mntent->mnt_fsname, file) == 0)
X	    break;
X    }
X
X    endmntent(mf);
X
X    return((mntent) ? mntent->mnt_dir : (char *) NULL);
X}
X
X/*
X * Get disk partition information
X */
Xstatic DISKPART *GetDiskPart(Name, DiskLabel)
X    char		       *Name;
X    struct disk_label	       *DiskLabel;
X{
X    register int		i;
X    register DISKPART	       *Ptr;
X    DISKPART		       *Base = NULL;
X    DISKPART			DiskPart;
X    static char			Part[2];
X    register char	       *p;
X
X    Part[1] = C_NULL;
X
X    /*
X     * Now handle each partition
X     */
X    for (i = 0; i < NPART; i++) {
X	/* Ingore partitins that have no size */
X	if (DiskLabel->dl_dt.d_partitions[i].p_size <= 0)
X	    continue;
X
X	Part[0] = 'a' + i;
X
X	/* Make a clean slate */
X	bzero((char *) &DiskPart, sizeof(DISKPART));
X
X	/* Fill in the blanks */
X	DiskPart.dp_name = strdup(Part);
X	DiskPart.dp_stsect = DiskLabel->dl_dt.d_partitions[i].p_base;
X	DiskPart.dp_nsect = DiskLabel->dl_dt.d_partitions[i].p_size;
X
X	/* 
X	 * Get the mount point name.
X	 */
X	if (p = GetMountInfo(Name, Part))
X	    DiskPart.dp_mnt = strdup(p);
X
X	/*
X	 * Add this partition to the linked list.
X	 */
X	if (Base) {
X	    for (Ptr = Base; Ptr && Ptr->dp_nxt; Ptr = Ptr->dp_nxt);
X	    Ptr->dp_nxt = NewDiskPart(&DiskPart);
X	} else {
X	    Base = NewDiskPart(&DiskPart);
X	}
X    }
X
X    return(Base);
X}
X
X/*
X * Convert disk info into a DEVICE entry.
X */
Xstatic DEVICE *diskToDiskDrive(Name, DevData, DevDataTab, DiskLabel, DriveInfo)
X    char		       *Name;
X    DEVDATA		       *DevData;
X    DEVDATATAB		       *DevDataTab;
X    struct disk_label	       *DiskLabel;
X    struct drive_info	       *DriveInfo;
X{
X    DEVICE		       *Device;
X    DISKDRIVE		       *DiskDrive;
X    static char 		Buf[BUFSIZ];
X
X    if ((Device = NewDevice(NULL)) == NULL) {
X	Error("Cannot create new device entry.");
X	return((DEVICE *) NULL);
X    }
X
X    if ((DiskDrive = NewDiskDrive(NULL)) == NULL) {
X	Error("Cannot create new diskdrive entry.");
X	return((DEVICE *) NULL);
X    }
X
X    Device->dv_name 		= strdup(Name);
X    Device->dv_type 		= DT_DISKDRIVE;
X    DiskDrive->dd_label 	= strdup(DriveInfo->di_name);
X    Device->dv_model 		= DiskDrive->dd_label;
X    DiskDrive->dd_unit 		= DevData->dd_devunit;
X    DiskDrive->dd_slave 	= DevData->dd_slave;
X    DiskDrive->dd_dcyl 		= DiskLabel->dl_ncyl;
X    DiskDrive->dd_heads 	= DiskLabel->dl_ntrack;
X    DiskDrive->dd_sect 		= DiskLabel->dl_nsect;
X    DiskDrive->dd_apc 		= DiskLabel->dl_ngroups;
X    DiskDrive->dd_rpm 		= DiskLabel->dl_rpm;
X    DiskDrive->dd_secsize 	= DiskLabel->dl_secsize;
X    /*
X     * Only get partition info we we're going to print it later.
X     */
X    if (VL_ALL)
X	DiskDrive->dd_part 	= GetDiskPart(Name, DiskLabel);
X
X    Device->dv_devspec 		= (caddr_t *) DiskDrive;
X    Device->dv_master 		= MkMasterFromDevData(DevData);
X
X    return(Device);
X}
X
X/*
X * Query and learn about a disk.
X */
Xextern DEVICE *ProbeDiskDrive(Name, DevData, DevDataTab)
X    /*ARGSUSED*/
X    char 		       *Name;
X    DEVDATA 		       *DevData;
X    DEVDATATAB 	     	       *DevDataTab;
X{
X    static struct disk_label    DiskLabel;
X    static struct drive_info 	DriveInfo;
X    int				Desc;
X    char		       *File;
X    DEVICE		       *Device;
X
X    File = GetRawFile(Name, "a");
X
X    if ((Desc = open(File, O_RDONLY|O_NDELAY)) < 0) {
X	if (Debug) Error("%s: Cannot open for read: %s.", File, SYSERR);
X	/*
X	 * If we know for sure this drive is present and we
X	 * know something about it, then create a minimal device.
X	 */
X	if ((DevDataTab->ddt_model || DevDataTab->ddt_desc) &&
X	    FLAGS_ON(DevData->dd_flags, DD_IS_ALIVE)) {
X	    Device = NewDevice((DEVICE *) NULL);
X	    Device->dv_name = strdup(Name);
X	    Device->dv_unit = DevData->dd_devunit;
X	    Device->dv_master = MkMasterFromDevData(DevData);
X	    Device->dv_type = DT_DISKDRIVE;
X	    Device->dv_model = DevDataTab->ddt_model;
X	    AddDevDesc(Device, DevDataTab->ddt_desc, NULL, DA_INSERT|DA_PRIME);
X	    return(Device);
X	} else
X	    return((DEVICE *) NULL);
X    }
X
X    /*
X     * Read disk label
X     */
X    if (ioctl(Desc, DKIOCGLABEL, &DiskLabel) < 0) {
X	if (Debug) Error("%s: DKIOCGLABEL: %s.", File, SYSERR);
X	return((DEVICE *) NULL);
X    }
X
X    /*
X     * Read drive info
X     */
X    if (ioctl(Desc, DKIOCINFO, &DriveInfo) < 0) {
X	if (Debug) Error("%s: DKIOCINFO: %s.", File, SYSERR);
X	return((DEVICE *) NULL);
X    }
X
X    close(Desc);
X
X    if (!(Device = diskToDiskDrive(Name, DevData, DevDataTab, 
X				   &DiskLabel, &DriveInfo))) {
X	Error("%s: Cannot convert diskdrive info.", Name);
X	return((DEVICE *) NULL);
X    }
X
X    return(Device);
X}
X
X/*
X * Get ROM Version
X */
Xextern char *GetRomVer()
X{
X    return(UnSupported);
X}
END_OF_FILE
if test 10934 -ne `wc -c <'os-next.c'`; then
    echo shar: \"'os-next.c'\" unpacked with wrong size!
fi
# end of 'os-next.c'
fi
if test -f 'os-sunos.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'os-sunos.c'\"
else
echo shar: Extracting \"'os-sunos.c'\" \(11015 characters\)
sed "s/^X//" >'os-sunos.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: os-sunos.c,v 1.57 1994/02/11 18:30:14 mcooper Exp mcooper $";
X#endif
X
X/*
X * General SunOS specific routines
X */
X
X#include "defs.h"
X
X#include <nlist.h>
X#include <sys/stat.h>
X
X/*
X * Name of frame buffer "indirect" device.
X */
X#define FBDEVICE		"fb"
X
X#if	SUNOS == 5
X#include "os-sunos5.h"
X#else
X#include "os-sunos4.h"
X#endif	/* SUNOS == 5 */
X
Xstruct stat			StatBuf;
Xcputype_t			CpuType = 0;
Xstatic DEVICE 		       *Device;
Xstatic char 			Buf[BUFSIZ];
Xkvm_t		       	       *kd;
Xextern char		        CpuSYM[];
Xextern char		        IdpromSYM[];
X
X/*
X * Build miscellaneous device tree
X */
Xextern int BuildMisc(TreePtr)
X    DEVICE		      **TreePtr;
X{
X    DEVICE		       *ProbeKbd();
X    int				Found = 1;
X
X    if (Device = ProbeKbd(TreePtr)) {
X	AddDevice(Device, TreePtr);
X	Found = 0;
X    }
X
X    return(Found);
X}
X
X/*
X * Build device tree using TreePtr.
X * Calls bus and method specific functions to
X * search for devices.
X */
Xextern int BuildDevicesSunOS(TreePtr)
X    DEVICE 		       **TreePtr;
X{
X    int 			 Found = 1;
X
X#if	SUNOS >= 5
X    DetectDevices();
X#endif
X
X#if	defined(HAVE_OPENPROM)
X    if (BuildOpenPROM(TreePtr) == 0)
X	Found = 0;
X#endif	/* HAVE_OPENPROM */
X
X#if	defined(HAVE_MAINBUS)
X    if (BuildMainBus(TreePtr) == 0)
X	Found = 0;
X#endif	/* HAVE_MAINBUS */
X
X    if (BuildMisc(TreePtr) == 0)
X	Found = 0;
X
X    return(Found);
X}
X
X/*
X * Scan the Disk Controller table looking for
X * a specific type.
X */
Xextern DKCTLRTAB *GetDkCtlrTab(DkCtrlType)
X    int 			DkCtrlType;
X{
X    extern DKCTLRTAB 		DkCtlrTab[];
X    register int 		i;
X
X    for (i = 0; DkCtlrTab[i].ct_model; ++i) {
X	if (DkCtrlType == DkCtlrTab[i].ct_ctype)
X	    return(&DkCtlrTab[i]);
X    }
X
X    return((DKCTLRTAB *) NULL);
X}
X
X/*
X * Scan the Frame Buffer table looking for 
X * a specific fb type.
X */
Xextern NAMETAB *GetFBTab(FBType)
X    int 			FBType;
X{
X    extern NAMETAB 		FBTab[];
X    register int 		i;
X
X    for (i = 0; FBTab[i].name; ++i) {
X	if (FBType == FBTab[i].value)
X	    return(&FBTab[i]);
X    }
X
X    return((NAMETAB *) NULL);
X}
X
X/*
X * Get the cpu type from the kernel
X */
Xcputype_t GetCpuType()
X{
X    struct nlist	       *nlptr;
X    kvm_t		       *kd;
X    cputype_t			cpu;
X
X    if (!(kd = KVMopen()))
X	return(-1);
X
X    if ((nlptr = KVMnlist(kd, CpuSYM, (struct nlist *)NULL)) == NULL)
X	return(-1);
X
X    if (CheckNlist(nlptr))
X	return(-1);
X
X    if (KVMread(kd, (u_long) nlptr->n_value, (char *) &cpu, 
X		sizeof(cpu), FALSE)) {
X	if (Debug) Error("Cannot read cpu type from kernel.");
X	return(-1);
X    }
X
X    KVMclose(kd);
X
X    return(cpu);
X}
X
X/*
X * Determine our cpu model name.
X *
X * We first try to find the "cpu" or "cputype" symbol in the kernel.
X * If that's not present or is of an unknown value, we use the OBP
X * root node name.
X */
Xextern char *GetModelName()
X{
X    extern NAMETAB 		ModelTab[];
X    register int 		i;
X    register char	       *cp = NULL;
X    register char	       *Name = NULL;
X
X    if (CpuType <= 0 && !UseProm)
X	CpuType = GetCpuType();
X
X    if (CpuType > 0 && !UseProm)
X	for (i = 0; ModelTab[i].name; ++i)
X	    if (CpuType == ModelTab[i].value) {
X		Name = ModelTab[i].name;
X		break;
X	    }
X
X#if	defined(HAVE_OPENPROM)
X    /*
X     * SunOS no longer identifies individual machines by the "cputype"
X     * symbol in the kernel.  Instead, the root OBP node name is used.
X     * This started with the SPARCclassic, LX, and SPARCcenter 2000.
X     */
X    if (!Name || UseProm)
X	if (cp = OBPGetCpuType())
X	    Name = strdup(cp);
X#endif	/* HAVE_OPENPROM */
X
X    if (Debug) printf("CPU = 0x%x  Name = <%s>\n", CpuType, ARG(Name));
X
X    return(Name);
X}
X
X#if 	defined(CPU_ARCH) /* Sun */
X#define	ARCH_MASK CPU_ARCH
X#endif	/* CPU_ARCH */
X#if 	defined(CPU_TYPE) /* Solbourne */
X#define ARCH_MASK CPU_TYPE
X#endif	/* CPU_TYPE */
X/*
X * Determine our kernel architecture name from our hostid.
X */
Xextern char *GetKernArchName()
X{
X#if	defined(ARCH_MASK)
X    extern NAMETAB 		KernArchTab[];
X    register int 		i;
X
X    if (!CpuType)
X	if ((CpuType = GetCpuType()) < 0)
X	    return((char *) NULL);
X
X    for (i = 0; KernArchTab[i].name; ++i)
X	if ((CpuType & ARCH_MASK) == KernArchTab[i].value)
X	    return(KernArchTab[i].name);
X
X    if (Debug)
X	Error("Kernel Arch 0x%x not defined; Cpu = 0x%x Mask = 0x%x", 
X	      CpuType & ARCH_MASK, CpuType, ARCH_MASK);
X#endif	/* ARCH_MASK */
X
X    return((char *) NULL);
X}
X
X#if	defined(HAVE_IDPROM)
X/*
X * Get system serial number
X */
Xstatic struct idprom *GetIDPROM()
X{
X    static struct idprom	idprom;
X    struct nlist	       *nlptr;
X    kvm_t		       *kd;
X
X    if (!(kd = KVMopen()))
X	return((struct idprom *)NULL);
X
X    if ((nlptr = KVMnlist(kd, IdpromSYM, (struct nlist *)NULL)) == NULL)
X	return((struct idprom *)NULL);
X
X    if (CheckNlist(nlptr))
X	return((struct idprom *)NULL);
X
X    if (KVMread(kd, (u_long) nlptr->n_value, (char *) &idprom, 
X		sizeof(idprom), FALSE)) {
X	if (Debug) Error("Cannot read \"%s\" from kernel.", IdpromSYM);
X	return((struct idprom *)NULL);
X    }
X
X    KVMclose(kd);
X
X    return(&idprom);
X}
X#endif	/* HAVE_IDPROM */
X
X/*
X * Get system serial number
X */
Xextern char *GetSerialNoStr()
X{
X    static char			buff[BUFSIZ];
X#if	defined(HAVE_IDPROM)
X    struct idprom	       *idprom;
X
X    if (!(idprom = GetIDPROM()))
X	return((char *)NULL);
X
X    /*
X     * id_format is not set correctly under SunOS 4.x
X     */
X    if (idprom->id_format != IDFORM_1)
X	if (Debug) Error("Warning: IDPROM format (%d) is incorrect.",
X			 idprom->id_format);
X
X    (void) sprintf(buff, "%d", idprom->id_serial);
X
X#endif	/* HAVE_IDPROM */
X    return((buff[0]) ? buff : (char *)NULL);
X}
X
X/*
X * Get version of OS
X */
Xextern char *GetOSVersionStr()
X{
X    return(UnSupported);
X}
X
X/*
X * Probe a FrameBuffer.
X */
Xextern DEVICE *ProbeFrameBuffer(fbname, DevData, DevDataTab)
X    char 		       *fbname;
X    DEVDATA 		       *DevData;
X    DEVDATATAB	 	       *DevDataTab;
X{
X#if	defined(FBIOMONINFO)
X    struct mon_info		mon_info;
X#endif	/* FBIOMONINFO */
X#if	defined(FBIOGXINFO)
X    struct cg6_info 		cg6_info;
X#endif	/* FBIOGXINFO */
X    struct fbgattr		fbgattr;
X    DEVICE 		       *fbdevice;
X    FRAMEBUFFER 	       *fb;
X    NAMETAB 		       *fbtab;
X    char 		       *file;
X    static char			filebuff[MAXPATHLEN];
X    static char			buff[BUFSIZ], buff2[BUFSIZ];
X    int 			desc;
X    register int		i;
X
X    if (!fbname)
X	return((DEVICE *) NULL);
X
X    if (Debug)
X	printf("ProbeFrameBuffer '%s'\n", fbname);
X
X#if	SUNOS == 5
X    if (EQ(fbname, FBDEVICE))
X	(void) sprintf(filebuff, "%s/%s", _PATH_DEV, fbname);
X    else
X	(void) sprintf(filebuff, "%s/%s", _PATH_DEV_FBS, fbname);
X    file = filebuff;
X#else
X    file = GetCharFile(fbname, NULL);
X#endif	/* SUNOS == 5 */
X
X    /*
X     * Check the device file.  If the stat fails because
X     * the device doesn't exist, trying the default framebuffer
X     * device /dev/fb.
X     */
X    if (stat(file, &StatBuf) != 0) {
X	if (errno == ENOENT && !EQ(fbname, FBDEVICE)) {
X	    if (Debug) 
X		Error("Framebuffer device `%s' does not exist.  Trying `%s'.",
X		      fbname, FBDEVICE);
X	    return(ProbeFrameBuffer(FBDEVICE, DevData, DevDataTab));
X	}
X    }
X
X    if ((desc = open(file, O_RDONLY)) < 0) {
X	if (Debug) Error("%s: Cannot open for reading: %s.", file, SYSERR);
X	return((DEVICE *) NULL);
X    }
X
X    /*
X     * Get real fb attributes
X     */
X    if (ioctl(desc, FBIOGATTR, &fbgattr) != 0) {
X	if (Debug) Error("%s: FBIOGATTR failed: %s.", file, SYSERR);
X	if (ioctl(desc, FBIOGTYPE, &fbgattr.fbtype) != 0) {
X	    if (Debug) Error("%s: FBIOGTYPE failed: %s.", file, SYSERR);
X	    return((DEVICE *) NULL);
X	}
X    }
X
X    /*
X     * We're committed to try
X     */
X    if (!(fb = NewFrameBuffer(NULL))) {
X	Error("Cannot create new frame buffer.");
X	return((DEVICE *) NULL);
X    }
X
X    if (!(fbdevice = NewDevice(NULL))) {
X	Error("Cannot create new frame buffer device entry.");
X	return((DEVICE *) NULL);
X    }
X
X#if	defined(FBIOGXINFO)
X    /*
X     * GX (cgsix) info
X     */
X    if (ioctl(desc, FBIOGXINFO, &cg6_info) == 0) {
X	(void) sprintf(buff, "SBus Slot %d, Revision %d",
X		       cg6_info.slot, cg6_info.boardrev);
X	if (cg6_info.hdb_capable)
X	    (void) strcat(buff, ", double buffered");
X	else
X	    (void) strcat(buff, ", single buffered");
X	AddDevDesc(fbdevice, buff, NULL, DA_APPEND);
X	if (cg6_info.vmsize)
X	    fb->fb_vmsize 	= mbytes_to_bytes(cg6_info.vmsize);
X    } else
X	if (Debug) Error("%s: FBIOGXINFO failed: %s.", file, SYSERR);
X#endif 	/* FBIOGXINFO */
X
X#if	defined(FBIOMONINFO)
X    /*
X     * Monitor info
X     */
X    if (ioctl(desc, FBIOMONINFO, &mon_info) == 0) {
X	(void) sprintf(buff, "Pixel Frequency is %s", 
X		       FreqStr(mon_info.pixfreq));
X	AddDevDesc(fbdevice, buff, "Monitor", DA_APPEND);
X
X	(void) sprintf(buff, "Horizontal Frequency is %s",
X		       FreqStr(mon_info.hfreq));
X	AddDevDesc(fbdevice, buff, "Monitor", DA_APPEND);
X
X	(void) sprintf(buff, "Vertical Frequency is %s",
X		       FreqStr(mon_info.vfreq));
X	AddDevDesc(fbdevice, buff, "Monitor", DA_APPEND);
X
X	(void) sprintf(buff, "Horizontal Sync is %d pixels", mon_info.hsync);
X	AddDevDesc(fbdevice, buff, "Monitor", DA_APPEND);
X
X	(void) sprintf(buff, "Vertical Sync is %d scanlines", mon_info.vsync);
X	AddDevDesc(fbdevice, buff, "Monitor", DA_APPEND);
X    } else
X	if (Debug) Error("%s: FBIOMONINFO failed: %s.", file, SYSERR);
X#endif	/* FBIOMONINFO */
X
X    /*
X     * We're done doing ioctl()'s
X     */
X    close(desc);
X
X    /*
X     * Find out what type of fb this is.
X     */
X    if (fbtab = GetFBTab(fbgattr.fbtype.fb_type)) {
X	if (fbtab->valuestr) {
X	    (void) sprintf(buff, "%s (%s)", fbtab->name, fbtab->valuestr); 
X	    fbdevice->dv_model		= strdup(buff);
X	} else
X	    fbdevice->dv_model 		= fbtab->name;
X    } else {
X	Error("Device `%s' is an unknown type (%d) of frame buffer.",
X	      fbname, fbgattr.fbtype.fb_type);
X	fbdevice->dv_model 		= "UNKNOWN";
X    }
X
X#if	defined(FB_ATTR_NEMUTYPES)
X    /*
X     * See if this fb emulates other fb's.
X     */
X    buff[0] = C_NULL;
X    for (i = 0; i < FB_ATTR_NEMUTYPES && fbgattr.emu_types[i] >= 0; ++i)
X	if (fbgattr.emu_types[i] != fbgattr.fbtype.fb_type &&
X	    (fbtab = GetFBTab(fbgattr.emu_types[i]))) {
X	    if (buff[0])
X		(void) strcat(buff, ", ");
X	    (void) strcat(buff,
X			  (fbtab->valuestr) ? fbtab->valuestr : fbtab->name);
X	}
X    if (buff[0]) {
X	(void) sprintf(buff2, "Emulates %s", buff);
X	AddDevDesc(fbdevice, buff2, NULL, DA_APPEND);
X    }
X#endif	/* FB_ATTR_NEMUTYPES */
X
X    /*
X     * Put things together
X     */
X    fbdevice->dv_name 			= fbname;
X    fbdevice->dv_type 			= DT_FRAMEBUFFER;
X    fbdevice->dv_nodeid			= DevData->dd_nodeid;
X    fbdevice->dv_devspec 		= (caddr_t *) fb;
X
X    fb->fb_height 			= fbgattr.fbtype.fb_height;
X    fb->fb_width 			= fbgattr.fbtype.fb_width;
X    fb->fb_depth 			= fbgattr.fbtype.fb_depth;
X    fb->fb_size 			= fbgattr.fbtype.fb_size;
X    fb->fb_cmsize 			= fbgattr.fbtype.fb_cmsize;
X
X    fbdevice->dv_master 		= MkMasterFromDevData(DevData);
X
X    return(fbdevice);
X}
END_OF_FILE
if test 11015 -ne `wc -c <'os-sunos.c'`; then
    echo shar: \"'os-sunos.c'\" unpacked with wrong size!
fi
# end of 'os-sunos.c'
fi
if test -f 'run.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'run.c'\"
else
echo shar: Extracting \"'run.c'\" \(5718 characters\)
sed "s/^X//" >'run.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: run.c,v 1.12 1994/01/12 22:56:08 mcooper Exp mcooper $";
X#endif
X
X/*
X * Things related to running system commands.
X */
X
X#include "defs.h"
X
Xextern char		       *AppArchCmds[];
Xextern char		       *KernArchCmds[];
Xextern char		       *ArchFiles[];
Xextern char		       *CPUFiles[];
Xextern char		      **Environ;
X
Xuid_t				SavedUserID;
X
X/*
X * Set our User ID.
X */
Xint SetUserID(RealUID, EffectUID)
X    uid_t			RealUID;
X    uid_t			EffectUID;
X{
X    if (Debug) printf("SetUserID(%d, %d) current: ruid=%d euid=%d\n", 
X		      RealUID, EffectUID, getuid(), geteuid());
X
X    if (setreuid(RealUID, EffectUID) == -1) {
X	if (Debug) Error("setreuid to %d, %d failed: %s", 
X			 RealUID, EffectUID, SYSERR);
X	return(-1);
X    }
X
X    if (Debug) printf("SetUserID(%d, %d) new: ruid=%d euid=%d\n",
X		      RealUID, EffectUID, getuid(), geteuid());
X
X    return(0);
X}
X
X/*
X * Set environment variable "Key" to be "Value".
X */
Xint SetEnv(Key, Value)
X    char		       *Key;
X    char		       *Value;
X{
X    static char			Buff[BUFSIZ];
X
X    (void) sprintf(Buff, "%s=%s", Key, (Value) ? Value : "");
X    if (putenv(strdup(Buff)) != 0) {
X	if (Debug) Error("putenv(%s) failed.", Buff);
X	return(-1);
X    }
X
X    return(0);
X}
X
X/*
X * Initialize environment before executing external command.
X */
Xint ExecInit(WithPrivs)
X    int				WithPrivs;
X{
X    static int			First = TRUE;
X    register char	      **PtrPtr;
X
X    if (First) {
X	First = FALSE;
X	SavedUserID = (uid_t) -1;
X	/*
X	 * Remove environment variables considered to be a security risk.
X	 */
X	for (PtrPtr = Environ; PtrPtr && *PtrPtr; ++PtrPtr) {
X	    if (EQN(*PtrPtr, "IFS=", 4)) {
X		if (SetEnv("IFS", NULL) < 0)
X		    return(-1);
X	    } else if (EQN(*PtrPtr, "LD_", 3)) {
X		if (SetEnv(*PtrPtr, NULL) < 0)
X		    return(-1);
X	    }
X	}
X    }
X
X    /*
X     * Only change user ID if we're setuid root (uid==0).
X     */
X    if (!WithPrivs && (geteuid() == 0) && ((SavedUserID = getuid()) != 0))
X	if (SetUserID(0, SavedUserID) == -1)
X	    return(-1);
X
X    return(0);
X}
X
X/*
X * Reset things after executing external command.
X */
Xint ExecEnd(WithPrivs)
X    int				WithPrivs;
X{
X    if (SetUserID(SavedUserID, 0) == -1)
X	return(-1);
X}
X
X/*
X * Run a list of commands (found in cmds) and return command output.
X */
Xextern char *RunCmds(Cmds, WithPrivs)
X    char 		      **Cmds;
X    int				WithPrivs;
X{
X    static char			Buf[BUFSIZ];
X    int 			l;
X    int				Done = 0;
X    FILE 		       *pf;
X    register char 	       *p;
X    char 		      **Cmd;
X
X    if (ExecInit(WithPrivs) != 0)
X	    return((char *)NULL);
X
X    Buf[0] = C_NULL;
X    for (Cmd = Cmds; Cmd != NULL && *Cmd != NULL && !Done; ++Cmd) {
X	/*
X	 * If this command has any args, nuke them for the access() test.
X	 */
X	strcpy(Buf, *Cmd);
X	p = index(Buf, ' ');
X	if (p != NULL)
X	    *p = C_NULL;
X
X	if (access(Buf, X_OK) != 0)
X	    continue;
X
X	if (Debug) printf("RunCmd '%s' %s Privs\n", 
X			  *Cmd, (WithPrivs) ? "With" : "Without");
X
X	if ((pf = popen(*Cmd, "r")) == NULL)
X	    continue;
X	if (fgets(Buf, sizeof(Buf), pf) == NULL) {
X	    pclose(pf);
X	    continue;
X	}
X	pclose(pf);
X
X	l = strlen(Buf);
X	if (Buf[l-1] == '\n') 
X	    Buf[l-1] = C_NULL;
X
X	Done = TRUE;
X    }
X 
X    if (ExecEnd(WithPrivs) != 0)
X	    return((char *)NULL);
X
X    return((Buf[0]) ? Buf : (char *)NULL);
X}
X
X/*
X * Wait for a given process to exit and return
X * that processes exit status.
X */
X#if	WAIT_TYPE == WAIT_WAITPID
Xint WaitForProc(ProcID)
X    pid_t			ProcID;
X{
X    pid_t			RetProcID;
X    waitarg_t			ProcStatus;
X
X    RetProcID = waitpid(ProcID, &ProcStatus, 0);
X
X    if (RetProcID == ProcID)
X	return(WEXITSTATUS(ProcStatus));
X    else
X	return(-1);
X}
X#endif	/* WAIT_WAITPID */
X#if	WAIT_TYPE == WAIT_WAIT4
Xint WaitForProc(ProcID)
X    pid_t			ProcID;
X{
X    pid_t			RetProcID;
X    waitarg_t			ProcStatus;
X
X    RetProcID = wait4(ProcID, &ProcStatus, 0, NULL);
X
X    if (RetProcID == ProcID)
X	return(WAITEXITSTATUS(ProcStatus));
X    else
X	return(-1);
X}
X#endif	/* WAIT_WAIT4 */
X
X/*
X * Execute a command with given arguments.
X */
Xint Execute(Cmd, Argv, Env, WithPrivs)
X    char		       *Cmd;
X    char		      **Argv;
X    char		      **Env;
X    int				WithPrivs;
X{
X    pid_t			ProcID;
X
X    if (access(Cmd, X_OK) != 0)
X	return(-1);
X
X    if (Debug) printf("Execute '%s' %s Privs\n", 
X		      Cmd, (WithPrivs) ? "With" : "Without");
X
X    if (ProcID < 0) {
X	Error("Fork failed: %s", SYSERR);
X	return(-1);
X    } else if (ProcID == 0) {
X	/*
X	 * Child
X	 */
X	ExecInit(WithPrivs);
X	execve(Cmd, Argv, Env);
X	Error("Execve \"%s\" failed: %s", Cmd, SYSERR);
X	exit(127);
X    } else {
X	/*
X	 * Parent
X	 */
X	return(WaitForProc(ProcID));
X    }
X}
X
X/*
X * Run a list of test files.  Each test file is run and if the
X * exit status is 0, we return the basename of the command.
X * e.g. If "/bin/vax" exists and returns status 0, return string "vax".
X */
Xextern char *RunTestFiles(Cmds)
X    char 		      **Cmds;
X{
X    char 		      **Cmd;
X    register char	       *p;
X    static char			Buf[BUFSIZ];
X
X    for (Cmd = Cmds; Cmd != NULL && *Cmd != NULL; ++Cmd) {
X	/*
X	 * If this command has any args, nuke them for the access() test.
X	 */
X	strcpy(Buf, *Cmd);
X	p = index(Buf, ' ');
X	if (p != NULL)
X	    *p = C_NULL;
X
X	if (access(Buf, X_OK) != 0)
X	    continue;
X
X	/*
X	 * Execute the command with a NULL environment for security
X	 * reasons.
X	 */
X	if (Execute(*Cmd, (char **)NULL, (char **)NULL, 0) != 0)
X	    continue;
X
X	/*
X	 * The name of this architecture is the last part of the Cmd name.
X	 */
X	strcpy(Buf, *Cmd);
X	p = rindex(Buf, '/');
X	if (p != NULL)
X	    ++p;
X	return(p);
X    }
X
X    return(NULL);
X}
X
END_OF_FILE
if test 5718 -ne `wc -c <'run.c'`; then
    echo shar: \"'run.c'\" unpacked with wrong size!
fi
# end of 'run.c'
fi
if test -f 'setenv.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'setenv.c'\"
else
echo shar: Extracting \"'setenv.c'\" \(3887 characters\)
sed "s/^X//" >'setenv.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1987 Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#if defined(LIBC_SCCS) && !defined(lint)
Xstatic char sccsid[] = "@(#)setenv.c	5.6 (Berkeley) 6/4/91";
X#endif /* LIBC_SCCS and not lint */
X
X#include <stddef.h>
X#include <stdlib.h>
X#include <string.h>
X
X/*
X * setenv --
X *	Set the value of the environmental variable "name" to be
X *	"value".  If rewrite is set, replace any current value.
X */
Xsetenv(name, value, rewrite)
X	register const char *name;
X	register const char *value;
X	int rewrite;
X{
X	extern char **environ;
X	static int alloced;			/* if allocated space before */
X	register char *C;
X	int l_value, offset;
X	char *_findenv();
X
X	if (*value == '=')			/* no `=' in value */
X		++value;
X	l_value = strlen(value);
X	if ((C = _findenv(name, &offset))) {	/* find if already exists */
X		if (!rewrite)
X			return (0);
X		if (strlen(C) >= l_value) {	/* old larger; copy over */
X			while (*C++ = *value++);
X			return (0);
X		}
X	} else {					/* create new slot */
X		register int	cnt;
X		register char	**P;
X
X		for (P = environ, cnt = 0; *P; ++P, ++cnt);
X		if (alloced) {			/* just increase size */
X			environ = (char **)realloc((char *)environ,
X			    (size_t)(sizeof(char *) * (cnt + 2)));
X			if (!environ)
X				return (-1);
X		}
X		else {				/* get new space */
X			alloced = 1;		/* copy old entries into it */
X			P = (char **)malloc((size_t)(sizeof(char *) *
X			    (cnt + 2)));
X			if (!P)
X				return (-1);
X			bcopy(environ, P, cnt * sizeof(char *));
X			environ = P;
X		}
X		environ[cnt + 1] = NULL;
X		offset = cnt;
X	}
X	for (C = (char *)name; *C && *C != '='; ++C);	/* no `=' in name */
X	if (!(environ[offset] =			/* name + `=' + value */
X	    malloc((size_t)((int)(C - name) + l_value + 2))))
X		return (-1);
X	for (C = environ[offset]; (*C = *name++) && *C != '='; ++C)
X		;
X	for (*C++ = '='; *C++ = *value++; )
X		;
X	return (0);
X}
X
X/*
X * unsetenv(name) --
X *	Delete environmental variable "name".
X */
Xvoid
Xunsetenv(name)
X	const char	*name;
X{
X	extern char **environ;
X	register char **P;
X	int offset;
X
X	while (_findenv(name, &offset))		/* if set multiple times */
X		for (P = &environ[offset];; ++P)
X			if (!(*P = *(P + 1)))
X				break;
X}
END_OF_FILE
if test 3887 -ne `wc -c <'setenv.c'`; then
    echo shar: \"'setenv.c'\" unpacked with wrong size!
fi
# end of 'setenv.c'
fi
if test -f 'sysinfo.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sysinfo.man'\"
else
echo shar: Extracting \"'sysinfo.man'\" \(5250 characters\)
sed "s/^X//" >'sysinfo.man' <<'END_OF_FILE'
X.\"
X.\" Copyright (c) 1992-1993 Michael A. Cooper.
X.\" This software may be freely distributed provided it is not sold for 
X.\" profit and the author is credited appropriately.
X.\"
X.\" $Header: /src/common/usc/bin/sysinfo/RCS/sysinfo.man,v 1.19 1993/07/02 23:49:20 mcooper Exp mcooper $
X.\" 
X.TH SYSINFO 1 "16 April 1993"
X.ds ]W USC-UCS
X.SH NAME
Xsysinfo \- Display system information
X.SH SYNOPSIS
Xsysinfo
X[
X.B +|\-all
X] 
X[
X.B \-debug
X]
X[
X.B \-level
X.I level1,level2,...
X]
X[
X.B \-offset 
X.I amount
X]
X[
X.B \-show
X.I item1,item2,...
X] 
X[
X.B +|\-terse
X] 
X[
X.B +|\-unknown
X] 
X[
X.B +|\-useprom
X] 
X.br
X.sp
Xsysinfo 
X.B \-list
X[
X.B level|show
X]
X.br
X.sp
Xsysinfo 
X.B \-version
X.SH DESCRIPTION
X.I Sysinfo
Xdisplays certain pieces of system information for the current host.
XBy default, 
X.I sysinfo
Xdisplays all system information it knows about in verbose mode.
XThis includes:
X.IP *
XHost name
X.IP *
XHost name aliases
X.IP *
XHost network addresses
X.IP *
XHost ID
X.IP *
XSystem serial number
X.IP *
XManufacturer of the system's hardware
X.IP *
XCPU model name
X.IP *
XCPU type
X.IP *
XApplication architecture
X.IP *
XKernel architecture
X.IP *
XAmount of main memory
X.IP *
XOperating system name
X.IP *
XOperating system version
X.IP *
XKernel version
X.IP *
XA variety of information about devices.
X.PP
XBy default,
X.B sysinfo
Xwill display most info items it knows about.
XSpecific items may be exclusively shown by using the
X.B \-show
Xoption and specifying a comma seperated list of items.
X.PP
XIf the file
X.I /etc/sysmodel
Xexists, the first line of the file is read and used as the
Xsystem model name.
X.SH OPTIONS
X.IP "\fB+|-all\fP"
XEnable (\fB+all\fP) or disable (\fB\-all\fP) displaying all known information.
XThis option is enabled by default.
X.IP "\fB\-debug\fR"
XEnable debugging messages.
XThis includes printing all error messages that are normally
Xnot shown.
X.IP "\fB\-level \fIlevels\fR"
XSet the show level.
X.I levels
Xis a comma seperated list of values used to determine what
Xlevels of information will be displayed.
XUse the
X.B "\-list level"
Xoption to get a list of valid 
X.I levels.
X.IP "\fB\-list [ level|show ]\fR"
XList all the possible values that may be used with an option.
XSpecifying
X.B "\-list show"
Xwill list possible values for use with the
X.B \-show
Xoption.
XSpecifying
X.B "\-list level"
Xwill list possible values for use with the
X.B \-level
Xoption.
X.IP "\fB\-offset \fIamount\fR"
XSet the number of spaces to offset (indent) when printing
Xdevice information.
X.IP "\fB\-show \fIitem1,item2,...\fR"
XShow information only about each comma seperated item.
XA current list of valid item names can be determined by using the
X.B "\-list show"
Xoption.
X.IP "\fB+|-terse\fP"
XEnable (\fB+terse\fP) or disable (\fB\-terse\fP) showing items in
Xterse format.
XWhen enabled this 
Xusually means that the field label for each item is not displayed.
XThis option is disabled by default.
X.IP "\fB+|-unknown\fP"
XEnable (\fB+unknown\fP) or disable (\fB\-unknown\fP) showing devices
Xthat appear to be present on the system, but are not "known" to sysinfo.
XThis option is enabled by default.
X.IP "\fB+|-useprom\fP"
XEnable (\fB+useprom\fP) or disable (\fB\-useprom\fP) using values
Xobtained from the system PROM instead of intepreting values obtained
Xdirectly from the kernel.
XCertain values are normally obtained by looking up a variable in
Xthe kernel and checking the result against a table of values compiled
Xinto 
X.B sysinfo.
XBy enabling this option, 
X.B sysinfo
Xwill attempt to obtain certain values from the system PROM.
XThis support is currently limited to the
X.B "System Model"
Xvalue.
XSupport is also limited to those machines which support such
Xa system PROM.
X.IP "\fB-version\fP"
XShow version
Xinformation for
X.I sysinfo.
X.SH AUTHOR
XMichael A. Cooper, 
X.br
XUniversity Computing Services, 
X.br
XUniversity of Southern California.
X.br
Xmcooper@usc.edu
X.SH FILES
X.sp
X/etc/sysmodel	\- Explicitly set the CPU model name
X.SH SEE ALSO
Xgethostid(2), gethostname(2), gethostbyname(3)
X.SH DIAGNOSTICS
X.IP "\fI%x: Unknown CPU type.\fP"
XThe CPU model for the current host could not be determined.
X.IP "(unknown)"
XInformation could not be determined for this item.
X.SH BUGS
X.PP
XNot all operating systems support interfaces to various pieces of
Xinformation that sysinfo supports.
X.PP
XSome devices, mostly devices that use 
Xremovable media such as
Xtape drives and floppy disks, are only indicated (shown) as
Xpresent if media is loaded in the device and it's on-line.
XThis occurs because the OS does not provide a software
Xinterface to query the device when media is not loaded.
X.PP
X.B SunOS 
Xallows only one process at a time to have
X.B /dev/openprom
Xopen.
XThis may result in certain pieces of information 
Xnot always showing up consistantly.  When in doubt,
Xenable debugging
X.B (\-debug).
X.PP
XThe 
X.B "Serial Number"
Xfield when run under
X.B SunOS
Xwill show the serial number as obtained from the system's
X.B IDPROM.
XThis serial number has no correspondence with the system serial
Xnumber that appears on the back of your machine.
X.PP
XUnder
X.B SunOS
Xthere is no way to tell the difference between an MC68020 (like the
X3/60) and MC68030 (like the 3/80)
Xbased machine.
X.PP
XUnder 
X.B Ultrix
Xit's virtually impossible to determine the actual
X.B "System Model"
Xfor 
X.B VAX
Xand 
X.B "DEC MIPS"
Xbased machines.
END_OF_FILE
if test 5250 -ne `wc -c <'sysinfo.man'`; then
    echo shar: \"'sysinfo.man'\" unpacked with wrong size!
fi
# end of 'sysinfo.man'
fi
echo shar: End of archive 2 \(of 5\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
