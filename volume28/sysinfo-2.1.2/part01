Newsgroups: comp.sources.unix
From: mcooper@usc.edu (Michael A. Cooper)
Subject: v28i074: sysinfo-2.1.2 - Show system information, V2.1.2, Part01/05
Message-id: <1.772126523.28031@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: mcooper@usc.edu (Michael A. Cooper)
Posting-Number: Volume 28, Issue 74
Archive-Name: sysinfo-2.1.2/part01

Sysinfo is a program which shows various pieces of information about a
system.  The original version was written to simply determine the model name
of a system for use in /etc/motd.  It also supported a few other pieces of
information that were simple to obtain, but the method used to obtain the
information on various different OS's varied.  The current version shows
many different "general" bits of system information as well as fairly
detailed information on system devices such as disk drives, frame buffers,
tape drives, and many others.  A lot of the information sysinfo displays is
difficult, if not impossible, to determine by normal OS commands and/or
files after boot time on many OS's.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 5)."
# Contents:  MANIFEST README config-data.h config.h dlpi.h getarch.c
#   getcpu.c getenv.c getkernver.c getman.c getosname.c getosver.c
#   info-aix.c info-mach.c info-netif.c info-next.c info-sunos.h
#   info-ultrix.h kvm.c kvm.h kvmlib.c memory.c metasysinfo namelist.c
#   options.h os-aix.h os-mach.c os-next.h os-sunos4.h os-sunos5.h
#   os-ultrix.h os.h ostype putenv.c run-data.c setreuid.c
#   strcasecmp.c strdup.c strerror.c version.h virtmem.c
# Wrapped by vixie@gw.home.vix.com on Mon Jun 20 08:33:20 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(2049 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X ChangeLog                  3	
X MANIFEST                   1	
X Makefile                   2	
X README                     1	
X config-data.h              1	
X config.h                   1	
X defs.h                     3	
X devices.c                  5	
X dlpi.c                     2	
X dlpi.h                     1	
X getarch.c                  1	
X getcpu.c                   1	
X getenv.c                   1	
X getkernver.c               1	
X getman.c                   1	
X getosname.c                1	
X getosver.c                 1	
X info-aix.c                 1	
X info-mach.c                1	
X info-netif.c               1	
X info-next.c                1	
X info-sunos.c               4	
X info-sunos.h               1	
X info-ultrix.c              2	
X info-ultrix.h              1	
X kbd-sun.c                  2	
X kvm.c                      1	
X kvm.h                      1	
X kvmlib.c                   1	
X macinfo.c                  2	
X memory.c                   1	
X metasysinfo                1	
X namelist.c                 1	
X netif.c                    3	
X obp.c                      5	
X options.c                  2	
X options.h                  1	
X os-aix.c                   3	
X os-aix.h                   1	
X os-mach.c                  1	
X os-next.c                  2	
X os-next.h                  1	
X os-sunos.c                 2	
X os-sunos4.c                4	
X os-sunos4.h                1	
X os-sunos5.c                4	
X os-sunos5.h                1	
X os-ultrix.c                3	
X os-ultrix.h                1	
X os.h                       1	
X ostype                     1	
X putenv.c                   1	
X run-data.c                 1	
X run.c                      2	
X setenv.c                   2	
X setreuid.c                 1	
X strcasecmp.c               1	
X strdup.c                   1	
X strerror.c                 1	
X sysinfo.c                  3	
X sysinfo.man                2	
X version.h                  1	
X virtmem.c                  1	
END_OF_FILE
if test 2049 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(6967 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X
X			     SYSINFO 2.1
X
X			  Michael A. Cooper
X	       Research, Development, and Systems Group
X		    University Computing Services
X		  University of Southern California
X			   mcooper@usc.edu
X
X			       CHANGES
X
XChanges Since Version 2.0
X
XThe major changes between version 2.0 and 2.1 include showing the
Xnumber of CPU's on systems supporting sysconf(_SC_NPROCESSORS_CONF)
X(currently Solaris 2.2 and later) and showing the type of keyboard
Xpresent for Sun systems.  Also, when running external programs,
Xsysinfo now sets the effective uid to the user running sysinfo and
Xuses execve() directly, instead of calling system().
X
XSysinfo should also be much more reliable on SunOS 4.1.x machines.  A
Xnumber of problems in SunOS 4.1.x exist that cause system crashes that
Xearlier versions of SYSINFO tweaked.  Mostly these problems have to do
Xwith CDROM's and floppy disk drives.
X
XThe Alliant and Sun-386i platforms have also been dropped starting with
Xversion 2.1.  This is due to those platforms being phased out here at USC.
X
XChanges Since Version 1.x
X
XThe major changes since version 1.x include adding support for getting
Xdevice information from the Open Boot PROM (OBP) on Sun-like machines
Xand support for SunOS 5.x (Solaris 2.x).  The OBP interface provides
Xmore information than ever.  The OBP interface also gives sysinfo the
Xability to provide detailed information on what types of CPUs are
Xavailable.
X
XSunOS 5.x comes with a number of features which makes SYSINFO much
Xmore portable across different manufacturer's hardware running SunOS
X5.x.  This includes the ability to determine the label on a disk drive
Xin a device driver independent fashion.  This ability alone should
Xeliminate most of the problems with SYSINFO causing certain systems
Xwith certain system configurations to crash.  (Which I still maintain
Xis the fault of SunOS and not SYSINFO.)  The OBP kernel interface in
XSunOS 5.x also adds the ability to associate nodes found by looking
Xthrough the kernel with those nodes found by querying the OBP
Xdirectly.  This means SYSINFO can extract and assign much more
Xinformation found by direct OBP queries than is possible with SunOS
X4.x.
X
XSee the file "ChangeLog" for a complete list of changes.
X
X			 GENERAL INFORMATION
X
XSysinfo is a program which shows various pieces of information about a
Xsystem.  The original version was written to simply determine the
Xmodel name of a system for use in /etc/motd.  It also supported a few
Xother pieces of information that were simple to obtain, but the method
Xused to obtain the information on various different OS's varied.  The
Xcurrent version shows many different "general" bits of system
Xinformation as well as fairly detailed information on system devices
Xsuch as disk drives, frame buffers, tape drives, and many others.  A
Xlot of the information sysinfo displays is difficult, if not
Ximpossible, to determine by normal OS commands and/or files after boot
Xtime on many OS's.
X
XMost of the OS specific information was determined by groveling
X/usr/include/{sys,machine,*dev}/*.h files, section 4 man pages, and
Xreverse engineering the output from various commands like devinfo
X(SunOS) and using the trace(2) facility.  Some of the network (netif)
Xcode was inspired by the sources to the 4.3BSD netstat and ifconfig
Xcommands.
X
XSUPPORTTED PLATFORMS
X
XSysinfo has been tested on the platforms listed below.  Porting to
Xother BSD based Unix's is fairly straight-forward.
X
X	Sun-3			SunOS 4.1.1
X	Sun-4/SPARC		SunOS 4.1.3, Solaris 2.3
X	SPARCbook-1		Solaris 1.0.1 SPARCbook Version A.3, B
X	Solbourne Series5E	OS/MP 4.1A
X	DEC MIPS		Ultrix 4.2A
X	NeXT MC680x0		NeXTStep 3.1
X	IBM RS/6000		AIX 3.2
X
X
XINSTALLATION
X
X1) Read the comments in "Makefile" and make any necessary changes.
X
X2) Run "make".  If you have multiple kernel architectures (kvm's) 
X   for the same OS (like for SunOS 4.x), you must compile and install sysinfo
X   for each kernel arch.  Currently, this is only required for SunOS 4.x.
X   It is _NOT_ required for Solaris 2.x/SunOS 5.x.
X
X3) To install the sysinfo program, you can either use "make installmeta" 
X   (read the file "metasysinfo" for details) or you can run "make install".
X
X4) Run "make install.man" to install the man page.
X
XBUG FIXES
X
XPlease send bug fixes, suggestions, and comments to mcooper@usc.edu.
X
XWHERE TO GET IT
X
XThe latest/greatest version of sysinfo is available via anonymous ftp
Xon usc.edu in "/pub/sysinfo".
X
XPLATFORM SPECIFIC NOTES
X
XThe following are notes regarding specific platforms:
X
XSunOS 4.x
X	SYSINFO should be compiled for each kernel architecture machine
X	you wish to run it on.  This is only needed for SunOS 4.x.  It
X	is _NOT_ required for Solaris 2.x/SunOS 5.x.  (SYSINFO is
X	normally installed into /usr/kvm and symlinked into something like 
X	/usr/local/bin.)  This is necessary if you wish to be able to get 
X	the PROM version information.  The SunOS 4.x interface to the PROM 
X	information does not permit having one binary that can determine the 
X	PROM information on all the different kernel architectures.  This 
X	interface problem is fixed in Solaris 2.x/SunOS 5.x.
X
X	Your kernel must have NIT (Network Interface Tap) compiled into it
X	in order to determine the Ethernet MAC address under SunOS 4.x.
X
XSolaris 2.x/SunOS 5.x
X	Unlike SunOS 4.x, you only need one SYSINFO binary for each Solaris 
X	2.x release.  You do not need one for each kernel architecture.  
X	i.e. SYSINFO compiled under Solaris 2.2 on a SPARC machine will 
X	run on any Solaris 2.2 SPARC machine of any kernel architecture.
X
X	Under Solaris 2.2 FCS on sun4d hosts (like the SPARCcenter-2000), the
X	kernel has an empty value for the system "root nexus".  This means
X	that you will not see a proper device tree on such systems.
X	Various nodes will not be attached where they should be.
X	This bug cropped up between Solaris 2.2 ER2 and FCS and is suppose
X	to be fixed in Solaris 2.3
X
XUltrix	Your kernel must have the PF (Packet Filter) compiled into it
X	in order to determine the Ethernet MAC address.
X
X	Determining the System Model on VAX and MIPS machines is very
X	difficult.  You can get a pretty good idea on most, but not
X	all VAX and MIPS machines by determining the number of CPUs
X	in a machine.  You really need to know the clock speed of the
X	CPUs to get a good idea.  Unfortuntely, I have neither the time
X	nor the equipment to work on this.
X
XNeXT	Network address info for network interfaces is not working.  There
X	is currently no debugger that works with GCC 2.0 so I haven't spent
X	time on this.
X
XAIX	When looking up device information, SYSINFO uses the AIX "National 
X	Language Catalogs".  This means that your $LANG environment 
X	variable must be set correctly.  If it is not, SYSINFO may fail 
X	to find most device information.
X
XOTHER KNOWN PROBLEMS
X
XSPARCbook "id" DISKS
X	The label on "id" disks on the SPARCbook-1 cannot be read.  This
X	appears to be because the definition of IDE_READ in 
X	<taddev/ide_drvr_def.h> is incorrect.  This bug is present in
X	Solaris 1.0.1 Rev A.
END_OF_FILE
if test 6967 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'config-data.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config-data.h'\"
else
echo shar: Extracting \"'config-data.h'\" \(794 characters\)
sed "s/^X//" >'config-data.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X/*
X * $Id: config-data.h,v 1.5 1994/01/12 22:56:08 mcooper Exp mcooper $
X */
X
X#ifndef __config_data_h__
X#define __config_data_h__
X
X/*
X * Get Network InterFaces
X */
X#define GETNETIF_IFNET		1
X#define GETNETIF_IFCONF		2
X
X/*
X * Get MAC Info
X */
X#define GETMAC_NIT		1
X#define GETMAC_PACKETFILTER	2
X#define GETMAC_DLPI		3
X
X/*
X * Physical Memory
X */
X#define PHYSMEM_PHYSMEM		1
X#define PHYSMEM_OSSPEC		2
X
X/*
X * Virtual Memory
X */
X#define VIRTMEM_ANONINFO	1
X#define VIRTMEM_OSSPEC		2
X#define VIRTMEM_NSWAP		3
X
X/*
X * Type of wait() system call
X */
X#define WAIT_WAITPID		1
X#define WAIT_WAIT4		2
X
X#endif /* __config_data_h__ */
END_OF_FILE
if test 794 -ne `wc -c <'config-data.h'`; then
    echo shar: \"'config-data.h'\" unpacked with wrong size!
fi
# end of 'config-data.h'
fi
if test -f 'config.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config.h'\"
else
echo shar: Extracting \"'config.h'\" \(1501 characters\)
sed "s/^X//" >'config.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X/*
X * $Id: config.h,v 1.4 1994/01/12 22:56:08 mcooper Exp mcooper $
X */
X
X#ifndef __config_h__
X#define __config_h__
X
X#include "config-data.h"
X
X/*
X * Get MAC Info
X */
X#if	!defined(GETMAC_TYPE) && defined(HAVE_DLPI)
X#define GETMAC_TYPE		GETMAC_DLPI
X#endif
X#if	!defined(GETMAC_TYPE) && defined(HAVE_NIT)
X#define GETMAC_TYPE		GETMAC_NIT
X#endif
X#if	!defined(GETMAC_TYPE) && defined(HAVE_PACKETFILTER)
X#define GETMAC_TYPE		GETMAC_PACKETFILTER
X#endif
X
X/*
X * Get Network InterFaces
X */
X#if	!defined(GETNETIF_TYPE) && defined(HAVE_IFNET)
X#define GETNETIF_TYPE		GETNETIF_IFNET
X#endif
X#if	!defined(GETNETIF_TYPE) && defined(SIOCGIFCONF)
X#define GETNETIF_TYPE		GETNETIF_IFCONF		
X#endif
X
X/*
X * Virtual Memory
X */
X#if	!defined(VIRTMEM_TYPE) && defined(HAVE_ANONINFO)
X#define VIRTMEM_TYPE		VIRTMEM_ANONINFO
X#endif
X
X/*
X * Physical Memory
X */
X#if	!defined(PHYSMEM_TYPE) && defined(HAVE_PHYSMEM)
X#define PHYSMEM_TYPE		PHYSMEM_PHYSMEM
X#endif
X
X/*
X * Wait type
X */
X#if	!defined(WAIT_TYPE) && defined(HAVE_WAITPID)
X#include <sys/wait.h>
X#define WAIT_TYPE		WAIT_WAITPID
X#endif
X#if	!defined(WAIT_TYPE) && defined(HAVE_WAIT4)
X#include <sys/wait.h>
X#define WAIT_TYPE		WAIT_WAIT4
X#ifdef WEXITSTATUS
X#define WAITEXITSTATUS(s)	WEXITSTATUS(s.w_status)
X#else
X#define WAITEXITSTATUS(s)	s.w_status
X#endif	/* WEXITSTATUS */
X#endif
X
X#endif /* __config_h__ */
END_OF_FILE
if test 1501 -ne `wc -c <'config.h'`; then
    echo shar: \"'config.h'\" unpacked with wrong size!
fi
# end of 'config.h'
fi
if test -f 'dlpi.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dlpi.h'\"
else
echo shar: Extracting \"'dlpi.h'\" \(678 characters\)
sed "s/^X//" >'dlpi.h' <<'END_OF_FILE'
X/*
X * $Id: dlpi.h,v 1.2 1994/01/12 22:56:08 mcooper Exp mcooper $
X *
X * The code contained in this file is from Neal Nuckolls's (Sun Internet
X * Engineering) DLPI "test" kit.
X */
X
X/*
X * Common DLPI Test Suite header file
X *
X */
X
X/*
X * Maximum control/data buffer size (in long's !!) for getmsg().
X */
X#define		MAXDLBUF	8192
X
X/*
X * Maximum number of seconds we'll wait for any
X * particular DLPI acknowledgment from the provider
X * after issuing a request.
X */
X#define		MAXWAIT		15
X
X/*
X * Maximum address buffer length.
X */
X#define		MAXDLADDR	1024
X
X
X/*
X * Handy macro.
X */
X#define		OFFADDR(s, n)	(u_char*)((char*)(s) + (int)(n))
X
X/*
X * externs go here
X */
Xextern	void	sigalrm();
END_OF_FILE
if test 678 -ne `wc -c <'dlpi.h'`; then
    echo shar: \"'dlpi.h'\" unpacked with wrong size!
fi
# end of 'dlpi.h'
fi
if test -f 'getarch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getarch.c'\"
else
echo shar: Extracting \"'getarch.c'\" \(2641 characters\)
sed "s/^X//" >'getarch.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: getarch.c,v 1.3 1994/01/12 22:56:08 mcooper Exp mcooper $";
X#endif
X
X/*
X * Get architecture information
X */
X
X#include "defs.h"
X
Xextern char		       *AppArchCmds[];
Xextern char		       *KernArchCmds[];
Xextern char		       *ArchFiles[];
X
X#if	defined(HAVE_SYSINFO)
X/*
X * Get kernel arch using sysinfo() system call.
X */
Xstatic char *GetKernArchFromSysinfo()
X{
X    static char			buff[BUFSIZ];
X
X    if (buff[0])
X	return(buff);
X
X    if (sysinfo(SI_MACHINE, buff, sizeof(buff)) < 0)
X	return((char *) NULL);
X
X    return(buff);
X}
X
X/*
X * Get application arch using sysinfo() system call.
X */
Xstatic char *GetAppArchFromSysinfo()
X{
X    static char			buff[BUFSIZ];
X
X    if (buff[0])
X	return(buff);
X
X    if (sysinfo(SI_ARCHITECTURE, buff, sizeof(buff)) < 0)
X	return((char *) NULL);
X
X    return(buff);
X}
X#endif	/* HAVE_SYSINFO */
X
X/*
X * Get application architecture.
X */
Xextern char *GetAppArch()
X{
X    static char		       *arch = NULL;
X
X    if (arch)
X	return(arch);
X
X#if	defined(ARCH_TYPE)
X    /*
X     * Use predefined name if present.
X     */
X    if (!arch)
X	return(ARCH_TYPE);
X#endif	/* ARCH_TYPE */
X
X#if	defined(HAVE_SYSINFO)
X    /*
X     * Use sysinfo() method
X     */
X    if (arch = GetAppArchFromSysinfo())
X	return(arch);
X#endif	/* HAVE_SYSINFO */
X
X#if	defined(HAVE_AARCHNAME)
X    /*
X     * Use OS specific method
X     */
X    if (arch = (char *) GetAppArchName())
X	return(arch);
X#endif	/* HAVE_AARCHNAME */
X
X    /*
X     * Try running App Arch commands
X     */
X    if (arch = RunCmds(AppArchCmds, FALSE))
X	return(arch);
X
X    /*
X     * Try testing Architecture files
X     */
X    if (arch = RunTestFiles(ArchFiles))
X	return(arch);
X
X    return(arch);
X}
X
X/*
X * Get kernel architecture
X */
Xextern char *GetKernArch()
X{
X    char 		       *arch = NULL;
X
X#if	defined(KARCH_TYPE)
X    /*
X     * If there's a predefined KArch name, use it.
X     */
X    if (!arch)
X	return(KARCH_TYPE);
X#endif	/* KARCH_TYPE */
X
X#if	defined(HAVE_SYSINFO)
X    if (arch = GetKernArchFromSysinfo())
X	return(arch);
X#endif	/* HAVE_SYSINFO */
X
X#if	defined(HAVE_KARCHNAME)
X    /*
X     * Try OS specific method
X     */
X    if (arch = GetKernArchName())
X	return(arch);
X#endif	/* HAVE_KARCHNAME */
X
X    /*
X     * Try running the KArch test commands
X     */
X    if (arch = RunCmds(KernArchCmds, FALSE))
X	return(arch);
X
X    /*
X     * We're desperate, so try using the Application Architecture
X     */
X    if (arch = GetAppArch())
X	return(arch);
X
X    return((char *) NULL);
X}
X
END_OF_FILE
if test 2641 -ne `wc -c <'getarch.c'`; then
    echo shar: \"'getarch.c'\" unpacked with wrong size!
fi
# end of 'getarch.c'
fi
if test -f 'getcpu.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getcpu.c'\"
else
echo shar: Extracting \"'getcpu.c'\" \(1892 characters\)
sed "s/^X//" >'getcpu.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: getcpu.c,v 1.5 1994/02/18 03:41:55 mcooper Exp mcooper $";
X#endif
X
X/*
X * Get cpu type information
X */
X
X#include "defs.h"
X
X#if	defined(HAVE_SYSINFO)
X/*
X * Get cpu type using sysinfo() system call.
X */
Xstatic char *GetCpuTypeFromSysinfo()
X{
X    static char			buff[BUFSIZ];
X
X    if (buff[0])
X	return(buff);
X
X    if (sysinfo(SI_ARCHITECTURE, buff, sizeof(buff)) < 0)
X	return((char *) NULL);
X
X    return(buff);
X}
X#endif	/* HAVE_SYSINFO */
X
X/*
X * Get CPU type
X */
Xextern char *GetCPU()
X{
X    static char		       *cpu = NULL;
X    extern char		       *CPUFiles[];
X    extern char		       *AppArchCmds[];
X
X    if (cpu)
X	return(cpu);
X
X#if	defined(CPU_NAME)
X    if (!cpu)
X	cpu = CPU_NAME;
X#endif	/* CPU_NAME */
X
X#if	defined(HAVE_SYSINFO)
X    /*
X     * Try the system sysinfo() call
X     */
X    if (!cpu)
X	cpu = GetCpuTypeFromSysinfo();
X#endif	/* HAVE_SYSINFO */
X
X#if	defined(HAVE_HOST_INFO)
X    /*
X     * Try the Mach method.
X     * This should be in os-mach.c, but this is the only
X     * OS specific case so far.
X     */
X    if (!cpu)
X	cpu = (char *) GetCpuTypeFromHostInfo();
X#endif 	/* HAVE_HOST_INFO */
X
X    if (!cpu) {
X	cpu = RunTestFiles(CPUFiles);
X
X	/*
X	 * If that didn't work, try the architecture commands.
X	 */
X	if (!cpu)
X	    cpu = RunCmds(AppArchCmds, FALSE);
X    }
X
X    return(cpu);
X}
X
X/*
X * Get number of CPU's
X */
Xextern char *GetNumCPU()
X{
X    int				Num = -1;
X
X#if	defined(_SC_NPROCESSORS_CONF)
X    if (Num < 0)
X	Num = (int) sysconf(_SC_NPROCESSORS_CONF);
X#endif	/* _SC_NPROCESSORS_CONF */
X
X#if	defined(HAVE_HOST_INFO)
X    if (Num < 0)
X	Num = GetNumCpuFromHostInfo();
X#endif	/* HAVE_HOST_INFO */
X
X    if (Num > 0)
X	return(itoa(Num));
X    else
X	return(UnSupported);
X}
END_OF_FILE
if test 1892 -ne `wc -c <'getcpu.c'`; then
    echo shar: \"'getcpu.c'\" unpacked with wrong size!
fi
# end of 'getcpu.c'
fi
if test -f 'getenv.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getenv.c'\"
else
echo shar: Extracting \"'getenv.c'\" \(3015 characters\)
sed "s/^X//" >'getenv.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1987 Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#if defined(LIBC_SCCS) && !defined(lint)
Xstatic char sccsid[] = "@(#)getenv.c	5.8 (Berkeley) 2/23/91";
Xstatic char rcsid[] = "$Id: getenv.c,v 1.3 1994/01/12 22:56:08 mcooper Exp mcooper $";
X#endif /* LIBC_SCCS and not lint */
X
X#include <stdlib.h>
X#include <stddef.h>
X#include <string.h>
X
X#if	defined(notdef)
X/*
X * getenv --
X *	Returns ptr to value associated with name, if any, else NULL.
X */
Xchar *
Xgetenv(name)
X	const char *name;
X{
X	int offset;
X	char *_findenv();
X
X	return(_findenv(name, &offset));
X}
X#endif	/* notdef */
X
X/*
X * _findenv --
X *	Returns pointer to value associated with name, if any, else NULL.
X *	Sets offset to be the offset of the name/value combination in the
X *	environmental array, for use by setenv(3) and unsetenv(3).
X *	Explicitly removes '=' in argument name.
X *
X *	This routine *should* be a static; don't use it.
X */
Xchar *
X_findenv(name, offset)
X	register char *name;
X	int *offset;
X{
X	extern char **environ;
X	register int len;
X	register char **P, *C;
X
X	for (C = name, len = 0; *C && *C != '='; ++C, ++len);
X	for (P = environ; *P; ++P)
X		if (!strncmp(*P, name, len))
X			if (*(C = *P + len) == '=') {
X				*offset = P - environ;
X				return(++C);
X			}
X	return(NULL);
X}
END_OF_FILE
if test 3015 -ne `wc -c <'getenv.c'`; then
    echo shar: \"'getenv.c'\" unpacked with wrong size!
fi
# end of 'getenv.c'
fi
if test -f 'getkernver.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getkernver.c'\"
else
echo shar: Extracting \"'getkernver.c'\" \(1881 characters\)
sed "s/^X//" >'getkernver.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: getkernver.c,v 1.16 1994/02/11 18:30:14 mcooper Exp mcooper $";
X#endif
X
X
X/*
X * Kernel related functions.
X */
X
X#include "defs.h"
X
X#if	defined(HAVE_KERNELVERSION)
X#include <fcntl.h>
X#include <nlist.h>
X
X#if !defined(VERSION_SYM)
X#	define VERSION_SYM 	"_version"
X#endif
X
X/*
X * Get kernel version string by reading the
X * symbol "version" from the kernel.
X */
Xstatic char *GetKernelVersionFromVersion()
X{
X    struct nlist	       *nlptr;
X    static struct nlist	        nlbuff;
X    static char			Buf[BUFSIZ];
X    register char	       *p;
X    kvm_t		       *kd;
X
X    if (kd = KVMopen()) {
X	/*
X	 * Using "nlbuff" is necessary to avoid a sun386i SunOS 4.0.1 bug.
X	 */
X	if ((nlptr = KVMnlist(kd, VERSION_SYM, &nlbuff)) == NULL)
X	    return((char *) NULL);
X
X	if (CheckNlist(nlptr))
X	    return((char *) NULL);
X
X	if (KVMread(kd, nlptr->n_value, (char *) Buf, sizeof(Buf), TRUE)) {
X	    if (Debug) Error("Read of \"%s\" from kernel failed.",
X			     VERSION_SYM);
X	    Buf[0] = C_NULL;
X	}
X    }
X
X    if (kd)
X	KVMclose(kd);
X
X#if	defined(KERNSTR_END)
X    /*
X     * Truncate extraneous info
X     */
X    if (Buf[0])
X	if ((p = index(Buf, KERNSTR_END)) != NULL)
X	    *p = C_NULL;
X#endif	/* KERNSTR_END */
X
X    return( (Buf[0]) ? Buf : (char *) NULL);
X}
X#endif	/* HAVE_KERNELVERSION */
X
X/*
X * Get kernel version string
X */
Xextern char *GetKernelVersion()
X{
X    static char		       *str = NULL;
X
X    if (str)
X	return(str);
X
X#if	defined(HAVE_KERNELVERSION)
X    if (!str)
X	str = GetKernelVersionFromVersion();
X#endif	/* HAVE_KERNELVERSION */
X
X#if	defined(HAVE_KERNELVERSION_OSSPEC)
X    if (!str)
X	str = GetKernelVersionStr();
X#endif	/* HAVE_KERNELVERSION_OSSPEC */
X
X    return(str);
X}
X
END_OF_FILE
if test 1881 -ne `wc -c <'getkernver.c'`; then
    echo shar: \"'getkernver.c'\" unpacked with wrong size!
fi
# end of 'getkernver.c'
fi
if test -f 'getman.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getman.c'\"
else
echo shar: Extracting \"'getman.c'\" \(1724 characters\)
sed "s/^X//" >'getman.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: getman.c,v 1.3 1994/01/12 22:56:08 mcooper Exp mcooper $";
X#endif
X
X/*
X
X * Get architecture information
X */
X
X#include "defs.h"
X
X/*
X * Get the short manufacturer name
X */
Xextern char *GetManShort()
X{
X    static char			buff[BUFSIZ];
X    char		       *cp;
X
X    buff[0] = C_NULL;
X#if	defined(MAN_SHORT)
X    if (!buff[0])
X	(void) strcpy(buff, MAN_SHORT);
X#endif	/* MAN_SHORT */
X
X#if	defined(HAVE_SYSINFO)
X    if (!buff[0]) {
X	if (sysinfo(SI_HW_PROVIDER, buff, sizeof(buff)) < 0)
X	    Error("sysinfo SI_HW_PROVIDER failed.");
X	else {
X	    if (cp = index(buff, '_'))
X		*cp = C_NULL;
X	}
X    }
X#endif	/* HAVE_SYSINFO */
X
X    return((buff[0]) ? buff : (char *)NULL);
X}
X
X/*
X * Get the long manufacturer name
X */
Xextern char *GetManLong()
X{
X    static char			buff[BUFSIZ];
X    register char	       *cp;
X
X    buff[0] = C_NULL;
X#if	defined(MAN_LONG)
X    if (!buff[0])
X	(void) strcpy(buff, MAN_LONG);
X#endif	/* MAN_LONG */
X
X#if	defined(HAVE_SYSINFO)
X    if (!buff[0]) {
X	if (sysinfo(SI_HW_PROVIDER, buff, sizeof(buff)) < 0)
X	    Error("sysinfo SI_HW_PROVIDER failed.");
X	else {
X	    cp = buff;
X	    while (cp && (cp = index(cp, '_')))
X		*cp++ = ' ';
X	}
X    }
X#endif	/* HAVE_SYSINFO */
X
X    return((buff[0]) ? buff : (char *)NULL);
X}
X
X/*
X * Get the manufacturer info.
X */
Xextern char *GetMan()
X{
X    char 		       *ms, *ml;
X    static char 		Buf[BUFSIZ];
X
X    ms = GetManShort();
X    ml = GetManLong();
X
X    if (!Terse)
X	(void) sprintf(Buf, "%s (%s)", ms, ml);
X    else
X	(void) sprintf(Buf, "%s", ms);
X
X    return(Buf);
X}
X
END_OF_FILE
if test 1724 -ne `wc -c <'getman.c'`; then
    echo shar: \"'getman.c'\" unpacked with wrong size!
fi
# end of 'getman.c'
fi
if test -f 'getosname.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getosname.c'\"
else
echo shar: Extracting \"'getosname.c'\" \(1329 characters\)
sed "s/^X//" >'getosname.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: getosname.c,v 1.4 1994/01/12 22:56:08 mcooper Exp mcooper $";
X#endif
X
X/*
X * Get OS name information
X */
X
X#include "defs.h"
X
X#if	defined(HAVE_SYSINFO)
X/*
X * Get OS name using sysinfo() system call.
X */
Xstatic char *GetOSNameFromSysinfo()
X{
X    static char			buff[BUFSIZ];
X
X    if (buff[0])
X	return(buff);
X
X    if (sysinfo(SI_SYSNAME, buff, sizeof(buff)) < 0)
X	return((char *) NULL);
X
X    return(buff);
X}
X#endif	/* HAVE_SYSINFO */
X
X#if	defined(HAVE_UNAME)
X/*
X * Get name of OS using uname()
X */
Xstatic char *GetOSNameFromUname()
X{
X    static struct utsname 	un;
X
X    if (uname(&un) == -1)
X	return((char *) NULL);
X    else
X	return(un.sysname);
X}
X#endif	/* HAVE_UNAME */
X
X/*
X * Get Operating System name.
X */
Xextern char *GetOSName()
X{
X    static char		       *osname = NULL;
X
X    if (osname)
X	return(osname);
X
X#if	defined(OS_NAME)
X    if (!osname)
X	osname = OS_NAME;
X#endif	/* OS_NAME */
X
X#if	defined(HAVE_SYSINFO)
X    if (!osname)
X	osname = GetOSNameFromSysinfo();
X#endif	/* HAVE_SYSINFO */
X
X#if	defined(HAVE_UNAME)
X    if (!osname)
X	osname = GetOSNameFromUname();
X#endif	/* HAVE_UNAME */
X
X    return(osname);
X}
X
END_OF_FILE
if test 1329 -ne `wc -c <'getosname.c'`; then
    echo shar: \"'getosname.c'\" unpacked with wrong size!
fi
# end of 'getosname.c'
fi
if test -f 'getosver.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getosver.c'\"
else
echo shar: Extracting \"'getosver.c'\" \(2598 characters\)
sed "s/^X//" >'getosver.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: getosver.c,v 1.6 1994/02/18 03:32:26 mcooper Exp mcooper $";
X#endif
X
X/*
X * Get OS version information
X */
X
X#include "defs.h"
X
X#if	defined(HAVE_UNAME)
X/*
X * Get OS version number using uname()
X */
Xstatic char *GetOSVersionFromUname()
X{
X    static char			Buf[BUFSIZ];
X    struct utsname 		un;
X
X    if (uname(&un) == -1)
X	return((char *) NULL);
X
X    /*
X     * Vendors don't all do the same thing for storing
X     * version numbers via uname().
X     */
X#if	defined(UNAME_REL_VER_COMB)
X    (void) sprintf(Buf, "%s.%s", un.version, un.release);
X#else
X    (void) sprintf(Buf, "%s", un.release);
X#endif 	/* UNAME_REL_VER_COMB */
X
X    return(Buf);
X}
X#endif	/* HAVE_UNAME */
X
X#if	defined(OSVERS_FROM_KERNVER)
X/*
X * Get OS version by reading an a specific argument out of
X * the kernel version string.
X */
Xextern char *
XGetOSVersionFromKernVer()
X{
X    static char			Buf[BUFSIZ];
X    register char	       *cp;
X    register int		i;
X
X    if (!(cp = GetKernelVersion()))
X	return(UnSupported);
X
X    (void) strcpy(Buf, cp);
X    for (cp = strtok(Buf, " "), i = 0; cp && i != OSVERS_FROM_KERNVER-1; 
X	 cp = strtok((char *)NULL, " "), ++i);
X    (void) strcpy(Buf, cp);
X    if ((cp = index(Buf, ':')) != NULL)
X	*cp = C_NULL;
X
X    return(Buf);
X}
X#endif	/* OSVERS_FROM_KERNVER */
X
X#if	defined(HAVE_SYSINFO)
X/*
X * Get OS version using sysinfo() system call.
X */
Xstatic char *GetOSVersionFromSysinfo()
X{
X    static char			buff[BUFSIZ];
X
X    if (buff[0])
X	return(buff);
X
X    if (sysinfo(SI_RELEASE, buff, sizeof(buff)) < 0)
X	return((char *) NULL);
X
X    return(buff);
X}
X#endif	/* HAVE_SYSINFO */
X
X/*
X * Get Operating System version
X */
Xextern char *GetOSVersion()
X{
X    static char		       *osver = NULL;
X    char 		       *Str;
X    char 		       *p;
X
X    if (osver)
X	return(osver);
X
X#if	defined(OS_VERSION)
X    if (!osver)
X	osver = OS_VERSION;
X#endif	/* OS_VERSION */
X
X#if	defined(HAVE_SYSINFO)
X    if (!osver)
X	osver = GetOSVersionFromSysinfo();
X#endif	/* HAVE_SYSINFO */
X
X#if	defined(OSVERS_FROM_KERNVER)
X    if (!osver)
X	osver = GetOSVersionFromKernVer();
X#endif	/* OSVERS_FROM_KERNVER */
X
X#if	defined(HAVE_UNAME)
X    if (!osver)
X	osver = GetOSVersionFromUname();
X#endif	/* HAVE_UNAME */
X
X    if (!osver)
X	osver = GetOSVersionStr();
X
X    if (osver)
X	/*
X	 * Zap "*-PL*".
X	 */
X	if (*osver && ((p = rindex(osver, '-')) != NULL) && 
X	    (strncmp(p, "-PL", 3) == 0))
X	    *p = C_NULL;
X
X    return(osver);
X}
END_OF_FILE
if test 2598 -ne `wc -c <'getosver.c'`; then
    echo shar: \"'getosver.c'\" unpacked with wrong size!
fi
# end of 'getosver.c'
fi
if test -f 'info-aix.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'info-aix.c'\"
else
echo shar: Extracting \"'info-aix.c'\" \(2340 characters\)
sed "s/^X//" >'info-aix.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: info-aix.c,v 1.9 1994/02/18 03:53:17 mcooper Exp mcooper $";
X#endif
X
X
X/*
X * AIX related information
X */
X
X#include <stdio.h>
X#include "defs.h"
X
X/*
X * These values were gleamed from a copy of the
X * AIXpert magazine.
X */
XNAMETAB ModelTab[] = {
X    { 0x0043, 	"RS/6000 M20 (7008)" },
X    { 0x0041, 	"RS/6000 220 (7011)" },
X    { 0x0045, 	"RS/6000 220 (7011)" },
X    { 0x0031, 	"RS/6000 320 (7012)" },
X    { 0x0035, 	"RS/6000 320H (7012)" },
X    { 0x0037, 	"RS/6000 340 (7012)" },
X    { 0x0038, 	"RS/6000 350 (7012)" },
X    { 0x0077, 	"RS/6000 355 (7012)" },
X    { 0x0076, 	"RS/6000 36[05]" },
X    { 0x0075, 	"RS/6000 37[05]" },
X    { 0x0030, 	"RS/6000 520 (7013)" },
X    { 0x0034, 	"RS/6000 520H (7013)" },
X    { 0x0010, 	"RS/6000 530 (7013) or 730 (7016)" },
X    { 0x0018, 	"RS/6000 530H (7013)" },
X    { 0x0014, 	"RS/6000 540 (7013)" },
X    { 0x001C, 	"RS/6000 550 (7013)" },
X    { 0x005C, 	"RS/6000 560 (7013)" },
X    { 0x0067, 	"RS/6000 570 (7013)" },
X    { 0x0400, 	"RS/6000 590 (7013)" },         /* should be 70 */
X    { 0x0020, 	"RS/6000 930 (7015)" },
X    { 0x002E, 	"RS/6000 950 (7015)" },
X    { 0x0102, 	"RS/6000 970 or 970B (7015)" }, /* should be 63 */
X    { 0x0064, 	"RS/6000 980 or 980B (7015)" },
X    { 0 },
X};
X
X/*
X * Device Data Table
X *
X * Only devices that don't have full descriptions in the device catalog
X * file, should be listed here.
X */
Xextern DEVICE *ProbeMemory();
X
XDEVDATATAB DevDataTab[] = {
X    { "mem",		DT_MEMORY,	NULL,	NULL,	ProbeMemory },
X    {  0 },
X};
X
X/*
X * Vital Product Data definetions.
X */
Xvpdinfo_t VPDinfo[] = {
X    { "DL",	"Drawer Level" },
X    { "EC",	"EC Level" },
X    { "FC",	"Feature Code" },
X    { "FN",	"FRU Number" },
X    { "LL",	"Loadable ROM Level" },
X    { "MF",	"Manufacturer" },
X    { "PC",	"Processor Component" },
X    { "PI",	"Processor ID" },
X    { "PN",	"Part Number" },
X    { "RL",	"ROM Level" },
X    { "RN",	"Rack Name" },
X    { "SL",	"Slot Location" },
X    { "SN",	"Serial Number" },
X    { "SZ",	"Size" },
X    { "TM",	"Model" },
X#if 0	/* We don't care about these */
X    { "Z0",	"Processor Chip" },
X    { "Z3",	"SIMM Product definition" },
X#endif
X    { 0 },
X};
END_OF_FILE
if test 2340 -ne `wc -c <'info-aix.c'`; then
    echo shar: \"'info-aix.c'\" unpacked with wrong size!
fi
# end of 'info-aix.c'
fi
if test -f 'info-mach.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'info-mach.c'\"
else
echo shar: Extracting \"'info-mach.c'\" \(3601 characters\)
sed "s/^X//" >'info-mach.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: info-mach.c,v 1.6 1994/01/12 22:56:08 mcooper Exp mcooper $";
X#endif
X
X/*
X * Mach specific information
X */
X
X#include "defs.h"
X
X/*
X * Table of system models
X */
XNAMETAB ModelTabMach[] = {
X#if	defined(vax)
X#ifdef CPU_SUBTYPE_VAX780
X    {  CPU_SUBTYPE_VAX780,		"VAX-11/780" },
X#endif
X#ifdef CPU_SUBTYPE_VAX785
X    {  CPU_SUBTYPE_VAX785,		"VAX-11/785" },
X#endif
X#ifdef CPU_SUBTYPE_VAX750
X    {  CPU_SUBTYPE_VAX750,		"VAX-11/750" },
X#endif
X#ifdef CPU_SUBTYPE_VAX730
X    {  CPU_SUBTYPE_VAX730,		"VAX-11/730" },
X#endif
X#ifdef CPU_SUBTYPE_UVAXI
X    {  CPU_SUBTYPE_UVAXI,		"MicroVAX-I" },
X#endif
X#ifdef CPU_SUBTYPE_UVAXII
X    {  CPU_SUBTYPE_UVAXII,		"MicroVAX-II" },
X#endif
X#ifdef CPU_SUBTYPE_VAX8200
X    {  CPU_SUBTYPE_VAX8200,		"VAX-8200" },
X#endif
X#ifdef CPU_SUBTYPE_VAX8500
X    {  CPU_SUBTYPE_VAX8500,		"VAX-8500" },
X#endif
X#ifdef CPU_SUBTYPE_VAX8600
X    {  CPU_SUBTYPE_VAX8600,		"VAX-8600" },
X#endif
X#ifdef CPU_SUBTYPE_VAX8650
X    {  CPU_SUBTYPE_VAX8650,		"VAX-8650" },
X#endif
X#ifdef CPU_SUBTYPE_VAX8800
X    {  CPU_SUBTYPE_VAX8800,		"VAX-8800" },
X#endif
X#ifdef CPU_SUBTYPE_UVAXIII
X    {  CPU_SUBTYPE_UVAXIII,		"MicroVAX-III" },
X#endif
X#endif	/* vax */
X#if	defined(ibm)
X#ifdef CPU_SUBTYPE_RT_PC
X    {  CPU_SUBTYPE_RT_PC,		"RT/PC" },
X#endif
X#ifdef CPU_SUBTYPE_RT_APC
X    {  CPU_SUBTYPE_RT_APC,		"RT/APC" },
X#endif
X#ifdef CPU_SUBTYPE_RT_135
X    {  CPU_SUBTYPE_RT_135,		"RT/135" },
X#endif
X#endif	/* ibm */
X#if	defined(mips)
X#ifdef CPU_SUBTYPE_MIPS_R2300
X    {  CPU_SUBTYPE_MIPS_R2300,		"MIPS R2300" },
X#endif
X#ifdef CPU_SUBTYPE_MIPS_R2600
X    {  CPU_SUBTYPE_MIPS_R2600,		"MIPS R2600" },
X#endif
X#ifdef CPU_SUBTYPE_MIPS_R2800
X    {  CPU_SUBTYPE_MIPS_R2800,		"MIPS R2800" },
X#endif
X#ifdef CPU_SUBTYPE_MIPS_R2000a
X    {  CPU_SUBTYPE_MIPS_R2000a,		"MIPS R2000a" },
X#endif
X#endif	/* mips */
X#if	defined(mc68k)
X#ifdef CPU_SUBTYPE_MC68030
X    {  CPU_SUBTYPE_MC68030,		"MC68030" },
X#endif
X#ifdef CPU_SUBTYPE_MC68040
X    {  CPU_SUBTYPE_MC68040,		"MC68040" },
X#endif
X#endif	/* mc68k */
X#if	defined(hp)
X#ifdef CPU_SUBTYPE_HPPA_825
X    {  CPU_SUBTYPE_HPPA_825,		"9000/825" },
X#endif
X#ifdef CPU_SUBTYPE_HPPA_835
X    {  CPU_SUBTYPE_HPPA_835,		"9000/835" },
X#endif
X#ifdef CPU_SUBTYPE_HPPA_840
X    {  CPU_SUBTYPE_HPPA_840,		"9000/840" },
X#endif
X#ifdef CPU_SUBTYPE_HPPA_850
X    {  CPU_SUBTYPE_HPPA_850,		"9000/850" },
X#endif
X#ifdef CPU_SUBTYPE_HPPA_855
X    {  CPU_SUBTYPE_HPPA_855,		"9000/855" },
X#endif
X#endif	/* hp */
X#if	defined(sun)
X#ifdef CPU_SUBTYPE_SUN4_260
X    {  CPU_SUBTYPE_SUN4_260,		"4/200" },
X#endif
X#ifdef CPU_SUBTYPE_SUN4_110
X    {  CPU_SUBTYPE_SUN4_110,		"4/110" },
X#endif
X#endif	/* sun */
X    {  0 },
X};
X
X/*
X * Table of CPU Types
X */
XNAMETAB CpuTypeTab[] = {
X#ifdef CPU_TYPE_VAX
X    {  CPU_TYPE_VAX,			"VAX" },
X#endif
X#ifdef CPU_TYPE_ROMP
X    {  CPU_TYPE_ROMP,			"ROMP" },
X#endif
X#ifdef CPU_TYPE_NS32032
X    {  CPU_TYPE_NS32032,		"NS32032" },
X#endif
X#ifdef CPU_TYPE_NS32332
X    {  CPU_TYPE_NS32332,		"NS32332" },
X#endif
X#ifdef CPU_TYPE_MC680x0
X    {  CPU_TYPE_MC680x0,		"MC680X0" },
X#endif
X#ifdef CPU_TYPE_I386
X    {  CPU_TYPE_I386,			"i386" },
X#endif
X#ifdef CPU_TYPE_NS32532
X    {  CPU_TYPE_NS32532,		"NS32532" },
X#endif
X#ifdef CPU_TYPE_HPPA
X    {  CPU_TYPE_HPPA,			"HPPA" },
X#endif
X#ifdef CPU_TYPE_ARM
X    {  CPU_TYPE_ARM,			"ARM" },
X#endif
X#ifdef CPU_TYPE_MC88000
X    {  CPU_TYPE_MC88000,		"MC88000" },
X#endif
X#ifdef CPU_TYPE_SPARC
X    {  CPU_TYPE_SPARC,			"SPARC" },
X#endif
X    {  0 },
X};
END_OF_FILE
if test 3601 -ne `wc -c <'info-mach.c'`; then
    echo shar: \"'info-mach.c'\" unpacked with wrong size!
fi
# end of 'info-mach.c'
fi
if test -f 'info-netif.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'info-netif.c'\"
else
echo shar: Extracting \"'info-netif.c'\" \(1893 characters\)
sed "s/^X//" >'info-netif.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X#ifndef lint
Xstatic char *RCSid = "$Id: info-netif.c,v 1.5 1994/01/12 22:56:08 mcooper Exp mcooper $";
X#endif
X
X/*
X * This file contains information specific to network interfaces that
X * will need periodic updating.
X */
X
X#include "defs.h"
X#include <sys/types.h>
X#include <sys/socket.h>
X
X/*
X * Address family table
X */
XNETIF *GetNetifINET();
XNETIF *GetNetifUnknown();
X
XAFTAB AFTab[] = {
X#ifdef AF_INET
X    {  AF_INET,		"Internet",		GetNetifINET },
X#endif
X#ifdef AF_UNSPEC
X    {  AF_UNSPEC,	"Unspecified",		GetNetifUnknown },
X#endif
X#ifdef AF_DECnet
X    {  AF_DECnet,	"DECnet",		GetNetifUnknown },
X#endif
X#ifdef AF_LAT
X    {  AF_LAT,		"LAT",			GetNetifUnknown },
X#endif
X#ifdef AF_GOSIP
X    {  AF_GOSIP,	"GOSIP",		GetNetifUnknown },
X#endif
X#ifdef AF_PUP
X    {  AF_PUP,		"PUP",			GetNetifUnknown },
X#endif
X#ifdef AF_CHAOS
X    {  AF_CHAOS,	"CHAOS",		GetNetifUnknown },
X#endif
X#ifdef AF_NS
X    {  AF_NS,		"XEROX NS",		GetNetifUnknown },
X#endif
X#ifdef AF_NBS
X    {  AF_NBS,		"NBS",			GetNetifUnknown },
X#endif
X#ifdef AF_ECMA
X    {  AF_ECMA,		"ECMA",			GetNetifUnknown },
X#endif
X#ifdef AF_DATAKIT
X    {  AF_DATAKIT,	"DATAKIT",		GetNetifUnknown },
X#endif
X#ifdef AF_CCITT
X    {  AF_CCITT,	"CCITT",		GetNetifUnknown },
X#endif
X#ifdef AF_LYLINK
X    {  AF_LYLINK,	"LYLINK",		GetNetifUnknown },
X#endif
X#ifdef AF_APPLETALK
X    {  AF_APPLETALK,	"APPLETALK",		GetNetifUnknown },
X#endif
X#ifdef AF_BSC
X    {  AF_BSC,		"BSC",			GetNetifUnknown },
X#endif
X#ifdef AF_DSS
X    {  AF_DSS,		"DSS",			GetNetifUnknown },
X#endif
X#ifdef AF_OSI
X    {  AF_OSI,		"OSI",			GetNetifUnknown },
X#endif
X#ifdef AF_NETMAN
X    {  AF_NETMAN,	"NETMAN",		GetNetifUnknown },
X#endif
X#ifdef AF_X25
X    {  AF_X25,		"X25",			GetNetifUnknown },
X#endif
X    {  0 },
X};
X
END_OF_FILE
if test 1893 -ne `wc -c <'info-netif.c'`; then
    echo shar: \"'info-netif.c'\" unpacked with wrong size!
fi
# end of 'info-netif.c'
fi
if test -f 'info-next.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'info-next.c'\"
else
echo shar: Extracting \"'info-next.c'\" \(1788 characters\)
sed "s/^X//" >'info-next.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: info-next.c,v 1.11 1994/01/12 22:56:08 mcooper Exp mcooper $";
X#endif
X
X
X/*
X * NeXT related information
X */
X
X#include "defs.h"
X
X/*
X * Kernel variable containing model number.
X */
Xchar				MachineTypeSYM[] = "_machine_type";
X
X/*
X * Kernel symbol for the device table
X */
Xchar				NeXTBusSYM[] = "_bus_dinit";
X
X/*
X * The NeXT_* defines below are from <next/scr.h> which is
X * present in NeXTStep 2.x, but missing in 3.x.
X */
X#define NeXT_CUBE       0
X#define NeXT_WARP9      1
X#define NeXT_X15        2
X#define NeXT_WARP9C     3
X
XNAMETAB ModelTab[] = {
X#ifdef NeXT_CUBE
X    {  NeXT_CUBE, 	"NeXTCube (MC68030)" },
X#endif
X#ifdef NeXT_WARP9
X    {  NeXT_WARP9,	"NeXTStation" },
X#endif
X#ifdef NeXT_X15
X    {  NeXT_X15,	"NeXTCube (MC68040)" },
X#endif
X#ifdef NeXT_WARP9C
X    {  NeXT_WARP9C,	"NeXTWarp9C" },
X#endif
X    {  0 },
X};
X
X/*
X * Device Data Table
X */
XDEVDATATAB DevDataTab[] = {
X    { "sc",	NULL,	"SCSI Controller", 		NULL },
X    { "odc",	NULL,	"Optical Disk Controller", 	NULL },
X    { "fdc",	NULL,	"Floppy Disk Controller", 	NULL },
X    { "sd",	NULL,	NULL,				ProbeDiskDrive },
X    { "od",	NULL,	NULL,				ProbeDiskDrive },
X    { "fd",	NULL,	NULL,				ProbeDiskDrive },
X    { "en",	"EtherNet Interface","10Mb/sec Ethernet",ProbeNetif },
X    { "dsp",	NULL,	"Digital Signal Processor", 	ProbeGeneric },
X    { "np",	NULL,	"NeXT Printer",		 	ProbeGeneric },
X    /*
X     * These devices are usually indicated as present, but may only
X     * exist as device drivers so we ignore them.
X     */
X    { "sg",	NULL,	NULL,				NULL },
X    { "sound",	NULL,	NULL,				NULL },
X    {  0 },
X};
END_OF_FILE
if test 1788 -ne `wc -c <'info-next.c'`; then
    echo shar: \"'info-next.c'\" unpacked with wrong size!
fi
# end of 'info-next.c'
fi
if test -f 'info-sunos.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'info-sunos.h'\"
else
echo shar: Extracting \"'info-sunos.h'\" \(909 characters\)
sed "s/^X//" >'info-sunos.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X/*
X * $Id: info-sunos.h,v 1.8 1994/01/12 22:56:08 mcooper Exp mcooper $
X */
X
X#ifndef __info_sunos_h__
X#define __info_sunos_h__
X
X#define _PATH_OPENPROM		"/dev/openprom"
X
X/*
X * OBP keywords
X */
X#define OBPK_BOARD		"board#"
X#define OBPK_CLOCKFREQ		"clock-frequency"
X#define OBPK_CPUID		"cpu-id"
X#define OBPK_DEVICEID		"device-id"
X#define OBPK_DEVTYPE		"device_type"
X#define OBPK_KEYBOARD		"keyboard"
X#define OBPK_MEMUNIT		"mem-unit"
X#define OBPK_MODEL		"model"
X#define OBPK_NAME		"name"
X#define OBPK_SIZE		"size"
X
X#define OBP_SYSBOARD		"sysboard"
X
X/*
X * Cpu Type information
X */
X#if	SUNOS == 5
Xtypedef short			cputype_t;
X#else
Xtypedef int			cputype_t;
X#endif	/* SUNOS == 5 */
Xextern cputype_t		CpuType;
X
X#endif	/* __info_sunos_h__ */
END_OF_FILE
if test 909 -ne `wc -c <'info-sunos.h'`; then
    echo shar: \"'info-sunos.h'\" unpacked with wrong size!
fi
# end of 'info-sunos.h'
fi
if test -f 'info-ultrix.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'info-ultrix.h'\"
else
echo shar: Extracting \"'info-ultrix.h'\" \(416 characters\)
sed "s/^X//" >'info-ultrix.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X/*
X * $Id: info-ultrix.h,v 1.5 1994/01/12 22:56:08 mcooper Exp mcooper $
X */
X
X
X/*
X * Maximium number of tape drives that Ultrix supports
X */
X#define MAXTAPES		32
X
X/*
X * Maximium number of partitions per disk
X */
X#define MAX_DISK_PARTS		8
END_OF_FILE
if test 416 -ne `wc -c <'info-ultrix.h'`; then
    echo shar: \"'info-ultrix.h'\" unpacked with wrong size!
fi
# end of 'info-ultrix.h'
fi
if test -f 'kvm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'kvm.c'\"
else
echo shar: Extracting \"'kvm.c'\" \(3422 characters\)
sed "s/^X//" >'kvm.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X#ifndef lint
Xstatic char *RCSid = "$Id: kvm.c,v 1.23 1994/02/11 18:30:14 mcooper Exp mcooper $";
X#endif
X
X/*
X * Frontend functions for kvm_*() functions
X *
X * It is assumed we HAVE_NLIST if we HAVE_KVM.
X */
X
X#include <stdio.h>
X#include "defs.h"
X
X#if	defined(HAVE_KVM)
X
X#include "defs.h"
X#include <fcntl.h>
X#if	defined(HAVE_NLIST)
X#	include <nlist.h>
X#endif	/* HAVE_NLIST */
X
X/*
X * Perform a kvm_close().  Really just here to be compatible.
X */
Xextern void KVMclose(kd)
X    kvm_t 		       *kd;
X{
X    if (kd)
X	(void) kvm_close(kd);
X}
X
X/*
X * Perform a kvm_open().
X */
Xextern kvm_t *KVMopen()
X{
X    kvm_t 		       *kd = NULL;
X    extern char 	       *ProgramName;
X
X    if ((kd = kvm_open((char *)NULL, (char *)NULL, (char *)NULL, O_RDONLY,
X		       ProgramName)) == NULL) {
X	if (Debug) Error("kvm_open failed: %s.", SYSERR);
X	return((kvm_t *) NULL);
X    }
X
X    return(kd);
X}
X
X#if	defined(HAVE_NLIST)
X
X#if	defined(__MACH__)
X#define		NL_NAME(p)	p->n_un.n_name
X#else
X#define		NL_NAME(p)	p->n_name
X#endif	/* __MACH__ */
X
X/*
X * Perform an nlist on "kd" looking for "Symbol".
X * If NlistPtr is not NULL, use it for storage.
X * Return the a pointer to the found nlist structure.
X */
Xextern struct nlist *KVMnlist(kd, Symbol, NlistPtr)
X    kvm_t		       *kd;
X    char		       *Symbol;
X    struct nlist	       *NlistPtr;
X{
X    static struct nlist		nlistbuf;
X    struct nlist	       *nlptr;
X
X    if (NlistPtr)
X	nlptr = NlistPtr;
X    else {
X	BZERO((char *) &nlistbuf, sizeof(nlistbuf));
X	nlptr = &nlistbuf;
X    }
X
X#if	defined(COFF) || defined(ELF)
X    /*
X     * Skip over initial '_'
X     */
X    if (*Symbol == '_')
X	NL_NAME(nlptr) = Symbol + 1;
X    else
X#endif
X	NL_NAME(nlptr) = Symbol;
X
X    if (kvm_nlist(kd, nlptr) != 0) {
X	if (Debug) Error("kvm_nlist name \"%s\" failed: %s.", 
X			 NL_NAME(nlptr), SYSERR);
X	KVMclose(kd);
X	return((struct nlist *) NULL);
X    }
X
X    return(nlptr);
X}
X#endif	/* HAVE_NLIST */
X
X/*
X * Perform a kvm_read().
X *
X * If IsString is TRUE, read 1 byte at a time until '\0' or
X * NumBytes is reached.  Otherwise, do a single read of the
X * of size NumBytes.
X *
X * The 1 byte at a time reads are necessary in order to avoid
X * reading invalid memory pages.
X */
Xextern int KVMread(kd, Addr, Buf, NumBytes, IsString)
X    kvm_t 		       *kd;
X    u_long	 		Addr;
X    char 		       *Buf;
X    unsigned 		        NumBytes;
X    int				IsString;
X{
X    int				Count;
X    char		       *Ptr;
X
X    if (!kd)
X	return(-1);
X
X    if (IsString) {
X	Ptr = Buf;
X	do {
X	    if (kvm_read(kd, Addr++, Ptr, 1) != 1) {
X		if (Debug) Error("kvm_read failed prematurely: %s.", SYSERR);
X		return(-1);
X	    }
X	} while (Ptr < &Buf[NumBytes-1] && *Ptr++);
X	*Ptr = C_NULL;
X    } else {
X	if ((Count = kvm_read(kd, Addr, Buf, NumBytes)) != NumBytes) {
X	    if (Debug) Error("kvm_read failed (expected %d, got %d): %s.", 
X			     NumBytes, Count, SYSERR);
X	    return(-1);
X	}
X    }
X
X    return(0);
X}
X
X/*
X * Check to see if PtrNL is valid.
X */
Xextern int _CheckNlist(PtrNL)
X    struct nlist	       *PtrNL;
X{
X    /*
X     * Should use n_type, but that's not set
X     * correctly on some OS's.
X     */
X    if (!PtrNL || !PtrNL->n_value) {
X	if (Debug) Error("Kernel symbol \"%s\" not found.", 
X			 GetNlNamePtr(PtrNL));
X	return(-1);
X    }
X
X    return(0);
X}
X
X#endif /* HAVE_KVM */
END_OF_FILE
if test 3422 -ne `wc -c <'kvm.c'`; then
    echo shar: \"'kvm.c'\" unpacked with wrong size!
fi
# end of 'kvm.c'
fi
if test -f 'kvm.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'kvm.h'\"
else
echo shar: Extracting \"'kvm.h'\" \(378 characters\)
sed "s/^X//" >'kvm.h' <<'END_OF_FILE'
X#ifndef __kvm_h__
X#define __kvm_h__
X/*
X * $Id: kvm.h,v 1.5 1994/01/12 22:56:08 mcooper Exp mcooper $
X */
X
Xstruct _kvmd {
X    int			kmemd;
X    char	       *namelist;
X    char	       *vmfile;
X};
Xtypedef struct _kvmd kvm_t;
X
Xextern kvm_t	       *kvm_open();
Xextern int		kvm_close();
Xextern int		kvm_nlist();
Xextern int		kvm_read();
Xextern int		kvm_write();
X
X#endif /* __kvm_h__ */
END_OF_FILE
if test 378 -ne `wc -c <'kvm.h'`; then
    echo shar: \"'kvm.h'\" unpacked with wrong size!
fi
# end of 'kvm.h'
fi
if test -f 'kvmlib.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'kvmlib.c'\"
else
echo shar: Extracting \"'kvmlib.c'\" \(3204 characters\)
sed "s/^X//" >'kvmlib.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: kvmlib.c,v 1.15 1994/01/12 22:56:08 mcooper Exp mcooper $";
X#endif
X
X#include "os.h"
X
X#if defined(NEED_KVM)
X
X#include <stdio.h>
X#include <sys/errno.h>
X#include "kvm.h"
X
X#ifndef SYSFAIL
X#define SYSFAIL -1
X#endif
X
X#if defined(DEBUG) && !defined(SYSERR)
Xextern int errno;
Xextern char sys_errlist[];
X#define SYSERR sys_errlist[errno]
X#endif
X
Xchar *strdup();
X
X#if	!defined(NAMELIST)
X#define NAMELIST	"/vmunix"
X#endif	/* NAMELIST */
X#define MEMFILE		"/dev/mem"
X#define KMEMFILE	"/dev/kmem"
X
X/*
X * Close things down.
X */
Xextern int kvm_close(kd)
X    kvm_t 		       *kd;
X{
X    if (!kd)
X	return(-1);
X
X    if (kd->kmemd)
X	close(kd->kmemd);
X    if (kd->namelist)
X	free(kd->namelist);
X    if (kd->vmfile)
X	free(kd->vmfile);
X
X    free(kd);
X
X    return(0);
X}
X
X/*
X * Open things up.
X */
Xextern kvm_t *kvm_open(NameList, CoreFile, SwapFile, Flag, ErrStr)
X    char 		       *NameList;
X    char 		       *CoreFile;
X    char 		       *SwapFile;
X    int 			Flag;
X    char 		       *ErrStr;
X{
X    kvm_t *kd;
X
X    if ((kd = (kvm_t *) malloc(sizeof(kvm_t))) == NULL) {
X#ifdef DEBUG
X	fprintf(stderr, "kvm_open() malloc %d bytes failed!\n", sizeof(kvm_t));
X#endif
X	return((kvm_t *) NULL);
X    }
X
X    if (NameList)
X	kd->namelist = strdup(NameList);
X    else
X	kd->namelist = strdup(NAMELIST);
X
X    if (CoreFile)
X	kd->vmfile = strdup(CoreFile);
X    else
X	kd->vmfile = strdup(KMEMFILE);
X
X    if ((kd->kmemd = open(kd->vmfile, Flag, 0)) == SYSFAIL) {
X#ifdef DEBUG
X	fprintf(stderr, "kvm_open() open '%s' failed: %s.\n", kd->vmfile, 
X		SYSERR);
X#endif
X	return((kvm_t *) NULL);
X    }
X
X    return(kd);
X}
X
X/*
X * KVM read function
X */
Xextern int kvm_read(kd, Addr, Buf, NBytes)
X     kvm_t 		       *kd;
X     unsigned long 		Addr;
X     char 		       *Buf;
X     unsigned 			NBytes;
X{
X    unsigned 			ret;
X
X    if (!kd) {
X#ifdef DEBUG
X	fprintf(stderr, "kvm_read(): invalid kd param.\n");
X#endif
X	return(SYSFAIL);
X    }
X
X    if (lseek(kd->kmemd, Addr, 0) == SYSFAIL) {
X#ifdef DEBUG
X	fprintf(stderr, "kvm_read(): lseek failed (desc %d addr 0x%x): %s.\n",
X		kd->kmemd, Addr, SYSERR);
X#endif
X	return(SYSFAIL);
X    }
X
X    if ((ret = read(kd->kmemd, Buf, NBytes)) != NBytes) {
X#ifdef DEBUG
X	fprintf(stderr, 
X		"kvm_read(): read failed (desc %d buf 0x%x size %d): %s.\n",
X		kd->kmemd, Buf, NBytes, SYSERR);
X#endif
X	return(SYSFAIL);
X    }
X
X    return(ret);
X}
X
X/*
X * KVM write function
X */
Xextern int kvm_write(kd, Addr, Buf, NBytes)
X     kvm_t 		       *kd;
X     unsigned long 		Addr;
X     char 		       *Buf;
X     unsigned 			NBytes;
X{
X    unsigned 			ret;
X
X    if (!kd) {
X	return(SYSFAIL);
X    }
X
X    if (lseek(kd->kmemd, Addr, 0) == SYSFAIL) {
X	return(SYSFAIL);
X    }
X
X    if ((ret = write(kd->kmemd, Buf, NBytes)) != NBytes) {
X	return(SYSFAIL);
X    }
X
X    return(ret);
X}
X
X/*
X * Perform an nlist()
X */
X#if	defined(HAVE_NLIST)
Xextern int kvm_nlist(kd, nl)
X     kvm_t 		       *kd;
X     struct nlist 	       *nl;
X{
X    if (!kd)
X	return(SYSFAIL);
X
X    return(nlist(kd->namelist, nl));
X}
X#endif	/* HAVE_NLIST */
X
X#endif /* NEED_KVM */
END_OF_FILE
if test 3204 -ne `wc -c <'kvmlib.c'`; then
    echo shar: \"'kvmlib.c'\" unpacked with wrong size!
fi
# end of 'kvmlib.c'
fi
if test -f 'memory.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'memory.c'\"
else
echo shar: Extracting \"'memory.c'\" \(2164 characters\)
sed "s/^X//" >'memory.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: memory.c,v 1.18 1994/02/11 18:30:14 mcooper Exp mcooper $";
X#endif
X
X
X/*
X * Memory related functions.
X */
X
X#include "defs.h"
X
X/*
X * Divide and Round Up
X */
Xextern int DivRndUp(Num, Div)
X    unsigned long 		Num;
X    unsigned long 		Div;
X{
X    int 			i;
X
X    i = Num / Div;
X
X    return((Num % Div) ? i+1 : i);
X}
X
X#if	PHYSMEM_TYPE == PHYSMEM_PHYSMEM
X
X#include <fcntl.h>
X#include <nlist.h>
X
X#if	!defined(PHYSMEM_SYM)
X#	define PHYSMEM_SYM	"_physmem"
X#endif	/* PHYSMEM_SYM */
X#if	!defined(GETPAGESIZE)
X#	define GETPAGESIZE() 	getpagesize()
X#endif	/* GETPAGESIZE */
X
X/*
X * Common method of determining amount of physical memory in a
X * BSD Unix machine.
X *
X * Get memory by reading the variable "physmem" from the kernel
X * and the system page size.
X */ 
Xstatic int GetMemoryAmount()
X{
X    struct nlist	       *nlptr;
X    unsigned long 		Bytes;
X    int		 		Amount = -1;
X    kvm_t		       *kd;
X    int				physmem;
X
X    if (kd = KVMopen()) {
X	if ((nlptr = KVMnlist(kd, PHYSMEM_SYM, (struct nlist *)NULL)) == NULL)
X	    return(-1);
X
X	if (CheckNlist(nlptr))
X	    return(-1);
X
X	if (KVMread(kd, nlptr->n_value, (char *)&physmem, 
X		    sizeof(physmem), FALSE) >= 0) {
X	    /*
X	     * Could use ctob() instead of "Page Size * Num Pages",
X	     * but this is more portable.
X	     */
X	    Bytes = (unsigned long) (GETPAGESIZE() * physmem);
X	    if (Debug)
X		printf("Bytes = %d physmem = %d pagesize = %d\n", 
X		       Bytes, physmem, GETPAGESIZE());
X	    Amount = DivRndUp(Bytes, MBYTES);
X	}
X    }
X
X    if (kd)
X	KVMclose(kd);
X
X    return(Amount);
X}
X#endif	/* PHYSMEM_PHYSMEM */
X
X#if	!defined(PHYSMEM_TYPE)
Xstatic int GetMemoryAmount()
X{
X    return(0);
X}
X#endif	/* !PHYSMEM_TYPE */
X
X/*
X * Get amount of physical memory
X */
Xextern char *GetMemory()
X{
X    static char			Buff[BUFSIZ];
X    int				Amount;
X
X    Amount = GetMemoryAmount();
X    if (Amount > 0) {
X	(void) sprintf(Buff, "%s", GetSizeStr(Amount, MBYTES));
X	return(Buff);
X    }
X
X    return((char *) NULL);
X}
END_OF_FILE
if test 2164 -ne `wc -c <'memory.c'`; then
    echo shar: \"'memory.c'\" unpacked with wrong size!
fi
# end of 'memory.c'
fi
if test -f 'metasysinfo' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'metasysinfo'\"
else
echo shar: Extracting \"'metasysinfo'\" \(1561 characters\)
sed "s/^X//" >'metasysinfo' <<'END_OF_FILE'
X#! /bin/sh
X#
X# $Header: /src/common/usc/bin/sysinfo/RCS/metasysinfo,v 1.1 1993/12/23 23:15:14 mcooper Exp mcooper $
X#
X# This script is borrowed from TOP, by William LeBebvre (phil@eecs.nwu.edu).
X#
X# Sysinfo is very sensitive to differences in the kernel, so much so that an
X# executable created on one sub-architecture may not work on others.  It
X# is also quite common for a minor OS revision to require recompilation of
X# sysinfo.  Both of these problems are especially prevalent for SunOS 4.*.  For
X# example, a sysinfo executable made under SunOS 4.1.1 will not run correctly
X# under SunOS 4.1.2, and vice versa.  "metasysinfo" attempts to solve this
X# problem by choosing one of several possible sysinfo executables to run then
X# executing it.
X#
X# To use metasysinfo your operating system needs to have the command "uname"
X# as part of the standard OS release.  MAKE SURE IT DOES before proceeding.
X# It will try to execute the command "sysinfo-`uname -m`-`uname -r`"  For 
X# example, on a sparcstation 1 running SunOS 4.1.1, it will try to run
X# "sysinfo-sun4c-4.1.1".
X#
X# INSTALLATION is easy.  Just compile sysinfo as normal.  Then use the command
X# "make metainstall" (on the same machine!) instead of the usual.  "make"
X# will insure that this shell script is installed correctly then will install
X# the most recently made sysinfo executable with the correct name.  Remember:
X# you will need to "make clean" and "make metainstall" on every different
X# combination of sub-architecture and OS version that you have.
X#
Xexec $0-`uname -m`-`uname -r` "$@"
END_OF_FILE
if test 1561 -ne `wc -c <'metasysinfo'`; then
    echo shar: \"'metasysinfo'\" unpacked with wrong size!
fi
chmod +x 'metasysinfo'
# end of 'metasysinfo'
fi
if test -f 'namelist.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'namelist.c'\"
else
echo shar: Extracting \"'namelist.c'\" \(1226 characters\)
sed "s/^X//" >'namelist.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: namelist.c,v 1.3 1994/01/12 22:56:08 mcooper Exp mcooper $";
X#endif
X
X/*
X * Name list routines.
X */
X
X#include "defs.h"
X
Xextern namelist_t *NameListFind(List, Name)
X    namelist_t		       *List;
X    char		       *Name;
X{
X    register namelist_t	       *Ptr;
X
X    for (Ptr = List; Ptr; Ptr = Ptr->nl_next) 
X	if (EQ(Ptr->nl_name, Name))
X	    return(Ptr);
X
X    return((namelist_t *) NULL);
X}
X
Xextern void NameListAdd(List, Name)
X    namelist_t		      **List;
X    char		       *Name;
X{
X    register namelist_t	       *Ptr;
X    
X    Ptr = (namelist_t *) xmalloc(sizeof(namelist_t));
X    Ptr->nl_name = strdup(Name);
X    Ptr->nl_next = (namelist_t *) NULL;
X
X    if (List && *List)
X	Ptr->nl_next = *List;
X
X    *List = Ptr;
X}
X
Xextern void NameListFree(List)
X    namelist_t		       *List;
X{
X    register namelist_t	       *Ptr;
X    register namelist_t	       *LastPtr;
X
X    for (Ptr = List; Ptr; ) {
X	if (Ptr->nl_name)
X	    (void) free(Ptr->nl_name);
X	LastPtr = Ptr;
X	Ptr = Ptr->nl_next;
X	(void) free(LastPtr);
X    }
X}
END_OF_FILE
if test 1226 -ne `wc -c <'namelist.c'`; then
    echo shar: \"'namelist.c'\" unpacked with wrong size!
fi
# end of 'namelist.c'
fi
if test -f 'options.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'options.h'\"
else
echo shar: Extracting \"'options.h'\" \(2139 characters\)
sed "s/^X//" >'options.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1990 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X/*
X * $Header: /src/common/usc/lib/libuscgen/RCS/options.h,v 1.10 1993/10/13 00:05:38 mcooper Exp $
X */
X
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/errno.h>
X
X#define Num_Opts(o)	(sizeof(o)/sizeof(OptionDescRec))
X#define HELPSTR		"-help"
X#define __		(caddr_t)
X
X#ifndef SYSERR
X#define SYSERR		sys_errlist[errno]
X#endif
X#ifndef TRUE
X#define TRUE	1
X#endif
X#ifndef FALSE
X#define FALSE	0
X#endif
X
X/*
X * Values for OptionDescRec.flags.
X */
X#define NoArg		0x001	/* No argument for this option.  Use
X				   OptionDescRec.value. */
X#define IsArg		0x002	/* Value is the option string itself */
X#define SepArg		0x004	/* Value is in next argument in argv */
X#define StickyArg	0x008	/* Value is characters immediately following 
X				   option */
X#define SkipArg		0x010	/* Ignore this option and the next argument in 
X				   argv */
X#define SkipLine	0x020	/* Ignore this option and the rest of argv */
X#define SkipNArgs	0x040	/* Ignore this option and the next 
X				   OptionDescRes.value arguments in argv */
X#define ArgHidden	0x080	/* Don't show in usage or help messages */
X
X/*
X * Option description record.
X */
Xtypedef struct {
X    char	*option;		/* Option string in argv	    */
X    int		 flags;			/* Flag bits			    */
X    int		(*cvtarg)();		/* Function to convert argument     */
X    caddr_t	 valp;			/* Variable to set		    */
X    caddr_t	 value;			/* Default value to provide	    */
X    char	*usage;			/* Usage message		    */
X    char	*desc;			/* Description message		    */
X} OptionDescRec, *OptionDescList;
X
XOptionDescRec  *FindOption();
Xint 		OptBool();
Xint 		OptInt();
Xint 		OptLong();
Xint 		OptShort();
Xint 		OptStr();
Xint 		ParseOptions();
Xvoid 		HelpOptions();
Xvoid 		UsageOptions();
X#if	defined(ARG_TYPE) && ARG_TYPE == ARG_STDARG
Xvoid 		UserError(char *fmt, ...);
X#else	/* !ARG_STDARG */
Xvoid 		UserError();
X#endif	/* ARG_STDARG */
X
Xextern char *OptionChars;
Xextern int errno;
Xextern char *sys_errlist[];
Xextern long strtol();
Xextern char *strcpy();
END_OF_FILE
if test 2139 -ne `wc -c <'options.h'`; then
    echo shar: \"'options.h'\" unpacked with wrong size!
fi
# end of 'options.h'
fi
if test -f 'os-aix.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'os-aix.h'\"
else
echo shar: Extracting \"'os-aix.h'\" \(1650 characters\)
sed "s/^X//" >'os-aix.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X/*
X * $Id: os-aix.h,v 1.6 1994/01/12 22:56:08 mcooper Exp mcooper $
X */
X
X#ifndef __os_aix_h__
X#define __os_aix_h__
X
X/*
X * IBM AIX
X */
X
X#include <sys/file.h>
X#include <sys/cfgdb.h>
X#include <sys/cfgodm.h>
X
X#define MAN_SHORT		"IBM"
X#define MAN_LONG		"International Business Machines Corporation"
X#ifdef _IBMR2
X#	define CPU_NAME		"rios"
X#endif
X#define ARCH_TYPE		"rs6000"
X#define KARCH_TYPE		ARCH_TYPE
X#define HAVE_VARARGS
X#define HAVE_NLIST
X#define HAVE_UNAME
X#define HAVE_WAITPID
X#define UNAME_REL_VER_COMB
X#define NEED_KVM
X#define VIRTMEM_TYPE		VIRTMEM_OSSPEC
X#define PHYSMEM_TYPE		PHYSMEM_OSSPEC
X#define _PATH_ODM		"/etc/objrepos"
X#define NAMELIST		"/unix"
X
X/*
X * Directories where the catalog files of devices reside.
X * The file is usually called "devices.cat" and can be
X * found in "/usr/lib/methods" as well as "/usr/lib/nls/msg/%L"
X * The former usually contains a later version than the latter.
X */
X#define ENV_NLSPATH \
X"NLSPATH=/usr/lib/methods/%N:/usr/lib/nls/msg/%L/%N:/usr/lib/nls/msg/prime/%N"
X
X/*
X * Name of default national language ($LANG)
X */
X#define DEFAULT_LANG	"En_US"
X
X/*
X * Node Name
X */
X#define NN_SYS0		"sys0"
X
X/*
X * Attribute strings
X */
X#define AT_SIZE		"size"
X#define AT_MODELCODE	"modelcode"
X#define AT_REALMEM	"realmem"
X
X/*
X * Vital Product Data Information
X */
Xstruct _vpdinfo {
X    char		       *code;
X    char		       *title;
X    char		       *value;
X};
Xtypedef struct _vpdinfo vpdinfo_t;
X
Xtypedef int			waitarg_t;
X
X#endif	/* __aix_h__ */
END_OF_FILE
if test 1650 -ne `wc -c <'os-aix.h'`; then
    echo shar: \"'os-aix.h'\" unpacked with wrong size!
fi
# end of 'os-aix.h'
fi
if test -f 'os-mach.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'os-mach.c'\"
else
echo shar: Extracting \"'os-mach.c'\" \(3430 characters\)
sed "s/^X//" >'os-mach.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: os-mach.c,v 1.10 1994/02/18 03:41:55 mcooper Exp mcooper $";
X#endif
X
X/*
X * Mach specific functions
X */
X
X#include "defs.h"
X
X#if	defined(HAVE_HOST_INFO)
X
X#if	defined(NEXTSTEP) && NEXTSTEP < 3
X#include <sys/host_info.h>
X#else
X#include <mach/host_info.h>
X#endif
X
X/*
X * Use the host_info() call to obtain type of CPU.
X */
Xextern char *GetCpuTypeFromHostInfo()
X{
X    extern NAMETAB 		CpuTypeTab[];
X    struct host_basic_info 	basic_info;
X    unsigned int 		count = HOST_BASIC_INFO_COUNT;
X    register int 		i;
X
X    if (host_info(host_self(), HOST_BASIC_INFO, 
X		  (host_info_t) &basic_info, &count) != KERN_SUCCESS) {
X	return((char *)NULL);
X    }
X
X    for (i = 0; CpuTypeTab[i].name; ++i) {
X	if (CpuTypeTab[i].value == basic_info.cpu_type)
X	    return(CpuTypeTab[i].name);
X    }
X
X    return((char *) NULL);
X}
X
X/*
X * Use the host_info() call to obtain the model of CPU.
X */
Xextern char *GetModelFromHostInfo()
X{
X    extern NAMETAB 		ModelTabMach[];
X    struct host_basic_info 	basic_info;
X    unsigned int 		count = HOST_BASIC_INFO_COUNT;
X    register int 		i;
X
X    if (host_info(host_self(), HOST_BASIC_INFO, 
X		  (host_info_t) &basic_info, &count) != KERN_SUCCESS) {
X	return((char *)NULL);
X    }
X
X    for (i = 0; ModelTabMach[i].name; ++i) {
X	if (ModelTabMach[i].value == basic_info.cpu_subtype)
X	    return(ModelTabMach[i].name);
X    }
X
X    return((char *) NULL);
X}
X
X/*
X * Get our application architecture name.
X */
Xextern char *GetAppArchFromHostInfo()
X{
X    return(GetCpuTypeFromHostInfo());
X}
X
X/*
X * Get our kernel architecture name.
X */
Xextern char *GetKernArchFromHostInfo()
X{
X    return(GetCpuTypeFromHostInfo());
X}
X
X/*
X * Get amount of memory.
X */
Xextern int GetMemoryAmount()
X{
X    struct host_basic_info 	BasicInfo;
X    unsigned int 		count = HOST_BASIC_INFO_COUNT;
X    int				Amount = -1;
X
X    if (host_info(host_self(), HOST_BASIC_INFO, 
X		  (host_info_t) &BasicInfo, &count) == KERN_SUCCESS)
X	Amount = BasicInfo.memory_size / MBYTES;
X
X    return(Amount);
X}
X
X/*
X * Get kernel version string.
X */
Xextern char *GetKernelVersionFromHostInfo()
X{
X    static char 		Version[BUFSIZ];
X    register char 	       *p;
X
X    Version[0] = C_NULL;
X    if (host_kernel_version(host_self(), Version) != KERN_SUCCESS) {
X	if (Debug) Error("host_kernel_version() failed: %s.", SYSERR);
X    }
X
X#if	defined(KERNSTR_END)
X    if (Version[0])
X	if ((p = index(Version, KERNSTR_END)) != NULL)
X	    *p = C_NULL;
X#endif	/* KERNSTR_END */
X
X    return((Version[0]) ? Version : (char *) NULL);
X}
X
X/*
X * Get OS version
X */
Xextern char *GetOSVersionFromHostInfo()
X{
X    static char			Buf[BUFSIZ];
X    struct machine_info 	Info;
X
X    if (xxx_host_info(host_self(), (machine_info_t) &Info) == KERN_SUCCESS) {
X	(void) sprintf(Buf, "%d.%d", Info.major_version, Info.minor_version);
X	return(Buf);
X    }
X
X    return((char *) NULL);
X}
X
X/*
X * Use the host_info() call to obtain the number of CPU's.
X */
Xextern int GetNumCpuFromHostInfo()
X{
X    struct host_basic_info 	basic_info;
X    unsigned int 		count = HOST_BASIC_INFO_COUNT;
X    register int 		i;
X
X    if (host_info(host_self(), HOST_BASIC_INFO, 
X		  (host_info_t) &basic_info, &count) != KERN_SUCCESS) {
X	return(-1);
X    }
X
X    return(basic_info.avail_cpus);
X}
X
X
X#endif	/* HAVE_HOST_INFO */
END_OF_FILE
if test 3430 -ne `wc -c <'os-mach.c'`; then
    echo shar: \"'os-mach.c'\" unpacked with wrong size!
fi
# end of 'os-mach.c'
fi
if test -f 'os-next.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'os-next.h'\"
else
echo shar: Extracting \"'os-next.h'\" \(1049 characters\)
sed "s/^X//" >'os-next.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X/*
X * $Id: os-next.h,v 1.11 1994/02/18 03:32:10 mcooper Exp mcooper $
X */
X
X#ifndef __os_next_h__
X#define __os_next_h__
X
X/*
X * NeXT
X */
X
X#include <sys/file.h>
X#if	NEXTSTEP >= 3
X#include <mach/mach_host.h>
X#else
X#include <kern/mach_host.h>
X#endif	/* NEXTSTEP >= 3 */
X
X#define MAN_SHORT		"NeXT"
X#define MAN_LONG		"NeXT Computer"
X#define OS_NAME			"NeXTStep"
X#define HAVE_VARARGS
X#define HAVE_HOST_INFO
X#define HAVE_KARCHNAME
X#define HAVE_AARCHNAME
X#define HAVE_NLIST
X#define HAVE_IFNET
X#define HAVE_KERNELVERSION
X#define HAVE_WAIT4
X#define NEED_KVM
X#define KERNSTR_END		';'
X#define OSVERS_FROM_KERNVER	3	/* uname doesn't report correct info */
X#if !defined(mc68k)
X#	define mc68k
X#endif
X#define PHYSMEM_TYPE		PHYSMEM_OSSPEC
X#define NAMELIST		"/mach"
X
X/*
X * Things we lack
X */
X#include <sys/wait.h>
Xtypedef union wait		waitarg_t;
Xtypedef int			pid_t;
X
X#endif	/* __next_h__ */
END_OF_FILE
if test 1049 -ne `wc -c <'os-next.h'`; then
    echo shar: \"'os-next.h'\" unpacked with wrong size!
fi
# end of 'os-next.h'
fi
if test -f 'os-sunos4.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'os-sunos4.h'\"
else
echo shar: Extracting \"'os-sunos4.h'\" \(2875 characters\)
sed "s/^X//" >'os-sunos4.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1993 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X/*
X * $Header: /src/common/usc/bin/sysinfo/RCS/os-sunos4.h,v 1.9 1993/12/16 02:55:36 mcooper Exp $
X */
X
X#ifndef __os_sunos4_h__
X#define __os_sunos4_h__
X
X/*
X * SunOS 4.x
X */
X
X#include <stdio.h>
X#include <mntent.h>
X#include <sys/types.h>
X#include <sys/param.h>
X#include <sys/file.h>
X#include <machine/cpu.h>
X#include <mon/idprom.h>
X#include <sun/dkio.h>
X#include <sun/dklabel.h>
X#include <sun/fbio.h>
X#include "info-sunos.h"
X
X/*
X * What manufacturer is this?
X */
X#if defined(TAD_SPBK_ARCH)
X#	define MAN_SHORT	"Tadpole"
X#	define MAN_LONG		"Tadpole Technology Inc"
X#	define TADPOLE
X#else
X#if defined(CPU_TYPE_SERIES4) || defined(CPU_TYPE_SERIES5) || \
X    	   defined(CPU_TYPE_SERIES5E) || defined(CPU_TYPE_SERIES6)
X#	define MAN_SHORT	"Solbourne"
X#	define MAN_LONG		"Solbourne Computer Corporation"
X#	define SOLBOURNE
X#else
X#	define MAN_SHORT	"Sun"
X#	define MAN_LONG		"Sun Microsystems Incorporated"
X#	define HAVE_SUNROMVEC
X#endif
X#endif
X
X#if defined(mc68020)
X#	define ARCH_TYPE 	"sun3"
X#	define HAVE_MAINBUS
X#endif
X#if defined(sparc)
X#	define ARCH_TYPE 	"sun4"
X#	if !defined(TADPOLE) && !defined(SOLBOURNE) && !defined(SUN4E_ARCH)
X#		define HAVE_IPI
X#	endif
X#	if !defined(TADPOLE)
X#		define HAVE_MAINBUS
X#	endif
X#endif
X#if defined(i386)
X#	define ARCH_TYPE 	"sun386"
X#	define HAVE_MAINBUS
X#endif
X#if defined(OPENPROMS)
X#	define HAVE_OPENPROM
X#endif
X#if !defined(SOLBOURNE)
X#	define HAVE_IDPROM
X#endif
X#define NEED_SOCKIO
X#define HAVE_VARARGS
X#define HAVE_UNAME
X#define HAVE_KVM
X#define HAVE_NLIST
X#define HAVE_NIT
X#define HAVE_ANONINFO
X#define HAVE_KARCHNAME
X#define HAVE_KERNELVERSION
X#define HAVE_PHYSMEM
X#define HAVE_WAITPID
X#if !defined(SECSIZE)
X#	define SECSIZE	512		/* Size of a disk sector */
X#endif
X#define KERNSTR_END	'\n'
X/*
X * This is to get around an error on Sun386i's in <sun386/cpu.h>
X */
X#if defined(SUN386_ARCH) && !defined(I386_ARCH)
X#define I386_ARCH SUN386_ARCH
X#endif
X
X#include <sys/buf.h>
X
X#if 	defined(TADPOLE)
X#	include <taddev/ide_drvr_def.h>
X#else	/* !TADPOLE */
X#	if 	defined(HAVE_IPI)
X#		include <sundev/ipvar.h>
X#	endif 	/* HAVE_IPI */
X#	if	defined(XYLOGICS_IPI)
X#		include <sundev/xlreg.h>
X#		include <sundev/xlextensions.h>
X#	endif	/* XYLOGICS_IPI */
X#	include <sundev/xdreg.h>
X#	include <sundev/xyreg.h>
X#	include <sundev/scsi.h>
X#	if 	defined(i386)
X#		include <sundev/sdreg.h>
X#	endif
X#endif	/* TADPOLE */
X
X#if defined(HAVE_MAINBUS)
X#	include <sundev/mbvar.h>
X#endif
X
X#if defined(HAVE_OPENPROM)
X#	include <sundev/openpromio.h>
X#endif
X
X/*
X * Types
X */
Xtypedef int			waitarg_t;
Xtypedef struct dk_conf		DKconf;
Xtypedef struct dk_geom		DKgeom;
Xtypedef struct dk_info		DKinfo;
Xtypedef struct dk_label		DKlabel;
Xtypedef struct dk_type		DKtype;
X
X#endif	/* __os_sunos4_h__ */
END_OF_FILE
if test 2875 -ne `wc -c <'os-sunos4.h'`; then
    echo shar: \"'os-sunos4.h'\" unpacked with wrong size!
fi
# end of 'os-sunos4.h'
fi
if test -f 'os-sunos5.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'os-sunos5.h'\"
else
echo shar: Extracting \"'os-sunos5.h'\" \(1881 characters\)
sed "s/^X//" >'os-sunos5.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1993 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X/*
X * $Header: /src/common/usc/bin/sysinfo/RCS/os-sunos5.h,v 1.14 1994/01/12 00:15:49 mcooper Exp $
X */
X
X#ifndef __os_sunos5_h__
X#define __os_sunos5_h__
X
X/*
X * SunOS 5.x
X */
X
X#include <stdio.h>
X#include <unistd.h>
X#include <sys/fcntl.h>
X#include <sys/param.h>
X#include <sys/file.h>
X#include <sys/cpu.h>
X#include <sys/systeminfo.h>
X#include <sys/idprom.h>
X#include <sys/fbio.h>
X#include <sys/mtio.h>
X#include <sys/dkio.h>
X#include <sys/hdio.h>
X#include <sys/vtoc.h>
X#include <sys/mnttab.h>
X#include <sys/vfstab.h>
X#include "info-sunos.h"
X
X#if	!defined(SUNOS)
X#define SUNOS 		5
X#endif	/* SUNOS */
X
X#if	!defined(ELF)
X#define ELF 		1
X#endif	/* ELF */
X
X/*
X * What manufacturer is this?
X */
X#if defined(TAD_SPBK_ARCH)
X#	define TADPOLE
X#else
X#if defined(CPU_TYPE_SERIES4) || defined(CPU_TYPE_SERIES5) || \
X    	   defined(CPU_TYPE_SERIES5E) || defined(CPU_TYPE_SERIES6)
X#	define SOLBOURNE
X#else
X#	define HAVE_SUNROMVEC
X#endif
X#endif
X
X#define HAVE_ANONINFO
X#define HAVE_DLPI
X#define HAVE_IDPROM
X#define HAVE_KERNELVERSION_OSSPEC
X#define HAVE_KVM
X#define HAVE_MEMSET
X#define HAVE_NLIST
X#define HAVE_OPENPROM
X#define HAVE_STRCHR
X#define HAVE_SYSINFO
X#define HAVE_UNAME
X#define HAVE_VARARGS
X#define HAVE_WAITPID
X#define NEED_SOCKIO
X#define PHYSMEM_TYPE		PHYSMEM_OSSPEC
X
X/*
X * Paths
X */
X#define _PATH_DEV		"/dev"
X#define _PATH_DEV_DSK		"/dev/dsk"
X#define _PATH_DEV_FBS		"/dev/fbs"
X#define _PATH_DEV_RDSK		"/dev/rdsk"
X#define _PATH_DEV_RMT		"/dev/rmt"
X
X#if defined(HAVE_OPENPROM)
X#	include <sys/openpromio.h>
X#endif
X
X/*
X * Types
X */
Xtypedef int			waitarg_t;
Xtypedef struct vtoc		DKvtoc;
Xtypedef struct dk_cinfo		DKcinfo;
Xtypedef struct dk_geom		DKgeom;
Xtypedef struct hdk_type		DKtype;
X
X#endif	/* __os_sunos5_h__ */
END_OF_FILE
if test 1881 -ne `wc -c <'os-sunos5.h'`; then
    echo shar: \"'os-sunos5.h'\" unpacked with wrong size!
fi
# end of 'os-sunos5.h'
fi
if test -f 'os-ultrix.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'os-ultrix.h'\"
else
echo shar: Extracting \"'os-ultrix.h'\" \(1052 characters\)
sed "s/^X//" >'os-ultrix.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X/*
X * $Id: os-ultrix.h,v 1.8 1994/01/12 22:56:08 mcooper Exp mcooper $
X */
X
X#ifndef __os_ultrix_h__
X#define __os_ultrix_h__
X
X/*
X * DEC Ultrix
X */
X
X#include <unistd.h>
X#include <fcntl.h>
X
X#define MAN_SHORT		"DEC"
X#define MAN_LONG		"Digital Equipment Corporation"
X#define HAVE_UNAME
X#define HAVE_VARARGS
X#define HAVE_UBA
X#define HAVE_IF_VERSION
X#define HAVE_PACKETFILTER
X#define HAVE_NLIST
X#define HAVE_IFNET
X#define HAVE_PHYSMEM
X#define HAVE_WAITPID
X#define NEED_KVM
X#define KERNSTR_END		'\n'
X#define HAVE_KERNELVERSION
X#define VIRTMEM_TYPE		VIRTMEM_NSWAP
X
X#if !defined(SECSIZE)
X#	define SECSIZE		512		/* Size of a disk sector */
X#endif
X
X/*
X * Maximium number of tape drives that Ultrix supports
X */
X#define MAXTAPES		32
X
X/*
X * Maximium number of partitions per disk
X */
X#define MAX_DISK_PARTS		8
X
X/*
X * Types
X */
Xtypedef union wait		waitarg_t;
X
X#endif	/* __os_ultrix_h__ */
END_OF_FILE
if test 1052 -ne `wc -c <'os-ultrix.h'`; then
    echo shar: \"'os-ultrix.h'\" unpacked with wrong size!
fi
# end of 'os-ultrix.h'
fi
if test -f 'os.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'os.h'\"
else
echo shar: Extracting \"'os.h'\" \(826 characters\)
sed "s/^X//" >'os.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X/*
X * $Id: os.h,v 1.4 1994/01/12 22:56:08 mcooper Exp mcooper $
X */
X
X#ifndef __sysinfo_system__
X#define __sysinfo_system__
X
X/*
X * System dependent information
X */
X
X#if defined(sun)
X#	if SUNOS == 5 || defined(__svr4__)
X#		include "os-sunos5.h"
X#	else
X#		include "os-sunos4.h"
X#	endif
X#endif /* sun */
X
X#if defined(ultrix) || defined(vax)
X#	include "os-ultrix.h"
X#endif /* ultrix || vax */
X
X#if defined(NeXT)
X#	include "os-next.h"
X#endif /* NeXT */
X
X#if defined(_AIX)
X#	include "os-aix.h"
X#endif /* _AIX */
X
X/*
X * Everything depends on HAVE_KVM
X */
X#if	defined(NEED_KVM) && !defined(HAVE_KVM)
X#define HAVE_KVM
X#endif
X
X#endif /* __sysinfo_system__ */
END_OF_FILE
if test 826 -ne `wc -c <'os.h'`; then
    echo shar: \"'os.h'\" unpacked with wrong size!
fi
# end of 'os.h'
fi
if test -f 'ostype' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ostype'\"
else
echo shar: Extracting \"'ostype'\" \(1290 characters\)
sed "s/^X//" >'ostype' <<'END_OF_FILE'
X#!/bin/sh
X#
X# Copyright (c) 1992-1993 Michael A. Cooper.
X# This software may be freely distributed provided it is not sold for 
X# profit and the author is credited appropriately.
X#
X# $Header: /src/common/usc/bin/sysinfo/RCS/ostype,v 1.5 1994/02/18 02:59:54 mcooper Exp mcooper $
X#
X# Determine type of OS
X#
X
X#
X# Find uname program.
X#
Xif [ -f /usr/bin/uname ]; then
X	unameprog=/usr/bin/uname
Xelif [ -f /bin/uname ]; then
X	unameprog=/bin/uname
Xfi
X
X#
X# Determine our OS name if we can.
X#
Xif [ "${unameprog}" ]; then
X	osname="`${unameprog} -s`"
Xfi
X
X#
X# Try stupid file checks
X#
Xif [ -z "${osname}" ]; then
X	if [ -d /NextApps ]; then
X		if [ -f /usr/bin/hostinfo ]; then
X			mver="`/usr/bin/hostinfo | grep -i 'next mach' | awk '{print $3}' | sed -e 's/\..*//'`"
X			osname="nextstep${mver}"
X		else
X			osname="nextstep2"
X		fi
X	elif [ -d /usr/alliant ]; then
X		osname="concentrix"
X	else
X		echo "Unable to determine your OS type.";
X		exit 1;
X	fi
Xfi
X
Xosname="`echo ${osname} | tr '[A-Z]' '[a-z]'`"
X
X#
X# Get OS Version
X#
Xcase "${osname}" in
Xsunos|ultrix|hp-ux)
X	if [ -z "${unameprog}" ]; then
X		echo "No uname program found."
X		exit 1
X	fi
X	osver="`${unameprog} -r`"
X	;;
Xaix)
X	osver="`${unameprog} -v`"
X	;;
Xconcentrix)
X	# We don't care what the os version is
X	osver=""
X	;;
Xesac
X
Xecho "${osname}${osver}"
END_OF_FILE
if test 1290 -ne `wc -c <'ostype'`; then
    echo shar: \"'ostype'\" unpacked with wrong size!
fi
chmod +x 'ostype'
# end of 'ostype'
fi
if test -f 'putenv.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'putenv.c'\"
else
echo shar: Extracting \"'putenv.c'\" \(2355 characters\)
sed "s/^X//" >'putenv.c' <<'END_OF_FILE'
X/*-
X * Copyright (c) 1988 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#if defined(LIBC_SCCS) && !defined(lint)
Xstatic char sccsid[] = "@(#)putenv.c	5.4 (Berkeley) 2/23/91";
Xstatic char rcsid[] = "$Id: putenv.c,v 1.2 1994/01/12 22:45:04 mcooper Exp $";
X#endif /* LIBC_SCCS and not lint */
X
X#include <stdlib.h>
X#include <string.h>
X
Xint
Xputenv(str)
X	const char *str;
X{
X	register char *p, *equal;
X	int rval;
X
X	if (!(p = (char *)strdup(str)))
X		return(1);
X	if (!(equal = index(p, '='))) {
X		(void)free(p);
X		return(1);
X	}
X	*equal = '\0';
X	rval = setenv(p, equal + 1, 1);
X	(void)free(p);
X	return(rval);
X}
END_OF_FILE
if test 2355 -ne `wc -c <'putenv.c'`; then
    echo shar: \"'putenv.c'\" unpacked with wrong size!
fi
# end of 'putenv.c'
fi
if test -f 'run-data.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'run-data.c'\"
else
echo shar: Extracting \"'run-data.c'\" \(1615 characters\)
sed "s/^X//" >'run-data.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: run-data.c,v 1.2 1994/01/12 22:56:08 mcooper Exp mcooper $";
X#endif
X
X/*
X * Data for "run" commands.
X */
X
X#include "defs.h"
X
X/*
X * Specific command to determine our model name.
X */
X#if	defined(MODEL_COMMAND)
Xchar *ModelCommand[] = { MODEL_COMMAND, NULL };
X#endif	/* MODEL_COMMAND */
X
X/*
X * Application architecture commands.  
X * These commands should print the system's application architecture.
X */
Xchar *AppArchCmds[] = { 
X    "/bin/arch", 
X    "/bin/mach", 
X    "/bin/machine", 
X    NULL };
X
X/*
X * Kernel architecture commands.  
X * These commands should print the system's kernel architecture.
X */
Xchar *KernArchCmds[] = { 
X    "/bin/arch -k", 
X    "/bin/mach",
X    "/bin/machine", 
X    NULL };
X
X/*
X * Architecture test files.
X * Each test file is run and if the exit status is 0, 
X * the basename of the command is the name of the system architecture. 
X */
Xchar *ArchFiles[] = { 
X    "/bin/alliant", 
X    "/bin/vax", 
X    "/bin/sun", 
X    NULL };
X
X/*
X * CPU type test files.
X * Each test file is run and if the exit status is 0, 
X * the basename of the command is the name of the system CPU type. 
X */
Xchar *CPUFiles[] = { 
X	"/bin/sparc",
X	"/bin/mc68010",
X	"/bin/mc68020",
X	"/bin/mc68030",
X	"/bin/mc68040",
X	"/bin/m68k",
X	"/bin/vax",
X	"/bin/alliant",
X	"/bin/i386", 
X	"/bin/i860", 
X	"/bin/iAPX286",
X	"/bin/pdp11",
X	"/bin/u370",
X	"/bin/u3b15",
X	"/bin/u3b2",
X	"/bin/u3b5",
X	"/bin/u3b",
X	NULL };
END_OF_FILE
if test 1615 -ne `wc -c <'run-data.c'`; then
    echo shar: \"'run-data.c'\" unpacked with wrong size!
fi
# end of 'run-data.c'
fi
if test -f 'setreuid.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'setreuid.c'\"
else
echo shar: Extracting \"'setreuid.c'\" \(653 characters\)
sed "s/^X//" >'setreuid.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: setreuid.c,v 1.2 1994/01/12 22:56:08 mcooper Exp mcooper $";
X#endif
X
X/*
X * Things related to running system commands.
X */
X
X#include "defs.h"
X
X/*
X * Set real and effective user ID.
X */
Xint setreuid(RealUID, EffectUID)
X    uid_t			RealUID;
X    uid_t			EffectUID;
X{
X    if (RealUID != (uid_t) -1)
X	if (setuid(RealUID) < 0)
X	    return(-1);
X
X    if (EffectUID != (uid_t) -1)
X	if (seteuid(EffectUID) < 0)
X	    return(-1);
X
X    return(0);
X}
END_OF_FILE
if test 653 -ne `wc -c <'setreuid.c'`; then
    echo shar: \"'setreuid.c'\" unpacked with wrong size!
fi
# end of 'setreuid.c'
fi
if test -f 'strcasecmp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'strcasecmp.c'\"
else
echo shar: Extracting \"'strcasecmp.c'\" \(3242 characters\)
sed "s/^X//" >'strcasecmp.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/lib/libgen/RCS/strcasecmp.c,v 1.3 1989/10/26 19:13:06 mcooper Exp mcooper $";
X#endif
X
X/*
X * $Log: strcasecmp.c,v $
X * Revision 1.3  1989/10/26  19:13:06  mcooper
X * This is the BSD version.
X *
X */
X
X#ifndef lint
Xstatic char sccsid[] = "@(#)strcasecmp.c 1.1 89/05/19 SMI"; /* from UCB 1.3 8/3/87 */
X#endif
X
X/*
X * Copyright (c) 1987 Regents of the University of California.
X * All rights reserved.  The Berkeley software License Agreement
X * specifies the terms and conditions for redistribution.
X */
X
X/*
X * This array is designed for mapping upper and lower case letter
X * together for a case independent comparison.  The mappings are
X * based upon ascii character sequences.
X */
Xstatic char charmap[] = {
X	'\000', '\001', '\002', '\003', '\004', '\005', '\006', '\007',
X	'\010', '\011', '\012', '\013', '\014', '\015', '\016', '\017',
X	'\020', '\021', '\022', '\023', '\024', '\025', '\026', '\027',
X	'\030', '\031', '\032', '\033', '\034', '\035', '\036', '\037',
X	'\040', '\041', '\042', '\043', '\044', '\045', '\046', '\047',
X	'\050', '\051', '\052', '\053', '\054', '\055', '\056', '\057',
X	'\060', '\061', '\062', '\063', '\064', '\065', '\066', '\067',
X	'\070', '\071', '\072', '\073', '\074', '\075', '\076', '\077',
X	'\100', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
X	'\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
X	'\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
X	'\170', '\171', '\172', '\133', '\134', '\135', '\136', '\137',
X	'\140', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
X	'\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
X	'\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
X	'\170', '\171', '\172', '\173', '\174', '\175', '\176', '\177',
X	'\200', '\201', '\202', '\203', '\204', '\205', '\206', '\207',
X	'\210', '\211', '\212', '\213', '\214', '\215', '\216', '\217',
X	'\220', '\221', '\222', '\223', '\224', '\225', '\226', '\227',
X	'\230', '\231', '\232', '\233', '\234', '\235', '\236', '\237',
X	'\240', '\241', '\242', '\243', '\244', '\245', '\246', '\247',
X	'\250', '\251', '\252', '\253', '\254', '\255', '\256', '\257',
X	'\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267',
X	'\270', '\271', '\272', '\273', '\274', '\275', '\276', '\277',
X	'\300', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
X	'\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
X	'\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
X	'\370', '\371', '\372', '\333', '\334', '\335', '\336', '\337',
X	'\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
X	'\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
X	'\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
X	'\370', '\371', '\372', '\373', '\374', '\375', '\376', '\377',
X};
X
Xstrcasecmp(s1, s2)
X	register char *s1, *s2;
X{
X	register char *cm = charmap;
X
X	while (cm[*s1] == cm[*s2++])
X		if (*s1++ == '\0')
X			return(0);
X	return(cm[*s1] - cm[*--s2]);
X}
X
Xstrncasecmp(s1, s2, n)
X	register char *s1, *s2;
X	register int n;
X{
X	register char *cm = charmap;
X
X	while (--n >= 0 && cm[*s1] == cm[*s2++])
X		if (*s1++ == '\0')
X			return(0);
X	return(n < 0 ? 0 : cm[*s1] - cm[*--s2]);
X}
END_OF_FILE
if test 3242 -ne `wc -c <'strcasecmp.c'`; then
    echo shar: \"'strcasecmp.c'\" unpacked with wrong size!
fi
# end of 'strcasecmp.c'
fi
if test -f 'strdup.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'strdup.c'\"
else
echo shar: Extracting \"'strdup.c'\" \(622 characters\)
sed "s/^X//" >'strdup.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/lib/libgen/RCS/strdup.c,v 1.2 1992/04/16 01:28:02 mcooper Exp mcooper $";
X#endif
X
X/*
X * $Log: strdup.c,v $
X * Revision 1.2  1992/04/16  01:28:02  mcooper
X * Some de-linting.
X *
X * Revision 1.1  1992/03/21  02:48:11  mcooper
X * Initial revision
X *
X */
X
X
X#include <stdio.h>
X
X/*
X * Most systems don't have this (yet)
X */
Xchar *strdup(str)
X     char *str;
X{
X    char 		       *p;
X    extern char		       *malloc();
X    extern char		       *strcpy();
X
X    if ((p = malloc(strlen(str)+1)) == NULL)
X	return((char *) NULL);
X
X    (void) strcpy(p, str);
X
X    return(p);
X}
END_OF_FILE
if test 622 -ne `wc -c <'strdup.c'`; then
    echo shar: \"'strdup.c'\" unpacked with wrong size!
fi
# end of 'strdup.c'
fi
if test -f 'strerror.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'strerror.c'\"
else
echo shar: Extracting \"'strerror.c'\" \(621 characters\)
sed "s/^X//" >'strerror.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/lib/libgen/RCS/strerror.c,v 1.1 1992/03/21 02:48:11 mcooper Exp mcooper $";
X#endif
X
X/*
X * $Log: strerror.c,v $
X * Revision 1.1  1992/03/21  02:48:11  mcooper
X * Initial revision
X *
X */
X
X#include <stdio.h>
X#include <sys/errno.h>
X
X/*
X * Return string for system error number "Num".
X */
Xchar *strerror(Num)
X     int			Num;
X{
X    extern int 			sys_nerr;
X    extern char 	       *sys_errlist[];
X    static char 		Unknown[100];
X
X    if (Num < 0 || Num > sys_nerr) {
X	(void) sprintf(Unknown, "Error %d", Num);
X	return(Unknown);
X    } else
X	return(sys_errlist[Num]);
X}
END_OF_FILE
if test 621 -ne `wc -c <'strerror.c'`; then
    echo shar: \"'strerror.c'\" unpacked with wrong size!
fi
# end of 'strerror.c'
fi
if test -f 'version.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'version.h'\"
else
echo shar: Extracting \"'version.h'\" \(185 characters\)
sed "s/^X//" >'version.h' <<'END_OF_FILE'
X/*
X * $Id: version.h,v 1.24 1994/02/18 03:54:43 mcooper Exp mcooper $
X *
X * Version information
X */
X
X/*
X * Version of this program
X */
X#define VERSION_STR		"2.1"
X
X#define PATCHLEVEL		2
END_OF_FILE
if test 185 -ne `wc -c <'version.h'`; then
    echo shar: \"'version.h'\" unpacked with wrong size!
fi
# end of 'version.h'
fi
if test -f 'virtmem.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'virtmem.c'\"
else
echo shar: Extracting \"'virtmem.c'\" \(2232 characters\)
sed "s/^X//" >'virtmem.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992-1994 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Id: virtmem.c,v 1.7 1994/02/11 18:30:14 mcooper Exp mcooper $";
X#endif
X
X
X/*
X * Virtual Memory related functions.
X */
X
X#include "defs.h"
X
X#if	VIRTMEM_TYPE == VIRTMEM_ANONINFO
X
X#include <nlist.h>
X#include <vm/anon.h>
X
Xstatic char			AnonInfoSYM[] = "_anoninfo";
X
Xstatic off_t
XGetVirtMemAmount()
X{
X    kvm_t		       *kd;
X    static struct anoninfo	AnonInfo;
X    off_t			Amount = 0;
X    struct nlist	       *nlPtr;
X
X    if (kd = KVMopen()) {
X	if ((nlPtr = KVMnlist(kd, AnonInfoSYM, (struct nlist *)NULL)) == NULL)
X	    return(0);
X
X	if (CheckNlist(nlPtr))
X	    return(0);
X
X	if (KVMread(kd, nlPtr->n_value, (char *) &AnonInfo, 
X		    sizeof(AnonInfo), FALSE) >= 0)
X	    Amount = (off_t) (AnonInfo.ani_free + AnonInfo.ani_resv);
X
X	if (Amount)
X	    Amount = (Amount * getpagesize()) / KBYTES;
X
X	KVMclose(kd);
X    }
X
X    return(Amount);
X}
X#endif	/* VIRTMEM_TYPE == VIRTMEM_ANONINFO */
X
X#if	VIRTMEM_TYPE == VIRTMEM_NSWAP
X
X#include <nlist.h>
X
X#if	!defined(NSWAP_SIZE)
X#define NSWAP_SIZE		512
X#endif	/* NSWAP_SIZE */
Xstatic char			NswapSYM[] = "_nswap";
X
Xstatic off_t
XGetVirtMemAmount()
X{
X    kvm_t		       *kd;
X    int				Nswap;
X    off_t			Amount = 0;
X    struct nlist	       *nlPtr;
X
X    if (kd = KVMopen()) {
X	if ((nlPtr = KVMnlist(kd, NswapSYM, (struct nlist *)NULL)) == NULL)
X	    return(0);
X
X	if (CheckNlist(nlPtr))
X	    return(0);
X
X	if (KVMread(kd, nlPtr->n_value, (char *) &Nswap,
X		    sizeof(Nswap), FALSE) >= 0)
X	    Amount = Nswap;
X
X	Amount /= KBYTES / NSWAP_SIZE;
X
X	KVMclose(kd);
X    }
X
X    return(Amount);
X}
X#endif	/* VIRTMEM_TYPE == VIRTMEM_NSWAP */
X
X#if	!defined(VIRTMEM_TYPE)
Xstatic off_t
XGetVirtMemAmount()
X{
X    return(0);
X}
X#endif	/* !VIRTMEM_TYPE */
X
X/*
X * Get Virtual Memory string
X */
Xextern char *
XGetVirtMem()
X{
X    static char			Buff[BUFSIZ];
X    off_t			Amount;
X
X    /*
X     * GetVirtMemAmount() should always return Amount in kilobytes
X     */
X    Amount = GetVirtMemAmount();
X    if (Amount == 0)
X	return(UnSupported);
X
X    (void) sprintf(Buff, "%s", GetSizeStr(Amount, KBYTES));
X
X    return(Buff);
X}
END_OF_FILE
if test 2232 -ne `wc -c <'virtmem.c'`; then
    echo shar: \"'virtmem.c'\" unpacked with wrong size!
fi
# end of 'virtmem.c'
fi
echo shar: End of archive 1 \(of 5\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
