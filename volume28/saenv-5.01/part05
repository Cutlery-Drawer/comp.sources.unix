Newsgroups: comp.sources.unix
From: rca@queernet.org (Bob Arnold)
Subject: v28i151: saenv-5.01 - SysAd Environment (OS_Research/Backup) Suite, Part05/07
References: <1.784011877.15815@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: rca@queernet.org (Bob Arnold)
Posting-Number: Volume 28, Issue 151
Archive-Name: saenv-5.01/part05

#!/bin/sh
# this is saenv.05 (part 5 of saenv5.01)
# do not concatenate these parts, unpack them in order with /bin/sh
# file src/backup/.profile continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 5; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping src/backup/.profile'
else
echo 'x - continuing file src/backup/.profile'
sed 's/^X//' << 'SHAR_EOF' >> 'src/backup/.profile' &&
X# standard Data Center .profile for backup accounts forced to use sh
X# 07/20/92, rca
X
X# note that .profile is only used by "sh" login shells so there's
X# no need to test for this, unlike .cshrc for csh.
X
X# we always want the path
Xp="`grep '^PATH=' /etc/saenv | sed -e 's/[ 	].*/:./'`"
Xif test -n "$p" ; then
X	eval $p
Xelse
X	PATH=/bin:/etc:/usr/bin:/usr/etc:/sbin:/usr/sbin:/usr/ccs/bin:/usr/lbin:/usr/local/bin:.
Xfi
Xexport PATH
X
X# get $OPER for backup script
Xif test -f .getoper.sh ; then
X	. ./.getoper.sh
X	# say if backups have to be done as root
X	if test `ls -l backup 2> /dev/null  | grep -c '^...x'` -eq 1 ; then
X		echo ""
X		echo "Backups on `uname -n` must be done as root."
X		echo ""
X	fi
Xfi
X
Xls()	{ /bin/ls -FC $* ; }
Xdec()	{ stty echoe || stty crt ; stty intr '^c' ; stty erase '^?' ; }
SHAR_EOF
echo 'File src/backup/.profile is complete' &&
chmod 0644 src/backup/.profile ||
echo 'restore of src/backup/.profile failed'
Wc_c="`wc -c < 'src/backup/.profile'`"
test 795 -eq "$Wc_c" ||
	echo 'src/backup/.profile: original size 795, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= src/backup/linst-alldisks ==============
if test -f 'src/backup/linst-alldisks' -a X"$1" != X"-c"; then
	echo 'x - skipping src/backup/linst-alldisks (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting src/backup/linst-alldisks (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'src/backup/linst-alldisks' &&
X:
X# linst-alldisks - local install backup script - written by Bob Arnold
X#
X# "inst-alldisks" on $SAHOST supplies this script with necessary files
X# and then calls this script.  We report on success or failure of installation.
X# Basic strategy is for inst-alldisks to copy this script
X# and necessary files to the remote host, and then run this script
X# on the remote machine.
X
X. /etc/dist/sahead		# do this always
X
X# go to installation directory created by inst-alldisks and get any
X# site-wide definitions
Xtdir=/tmp/ialld
Xcd $tdir
Xtest -f ./bkp.site && . ./bkp.site
X
X## Change these three in the master 'bkp.site' on $SAHOST if you want
Xbkpuid=${bkpuid-194}		# backup's default user id at your site
Xchkaixdev=${chkaixdev-false}	# no warning about AIX 3.X video drives
Xperm=${perm-755}		# set to 4755 if you want it to be setuid
Xbhdir=${bhdir-/home/backup}	# default home directory
Xdevdata=bkp.media		# media device data file
XUSAGE="usage: $pr [-verbose] [backup_home_dir]"	# usage string
X
Xumask 002
X
X# process command args
Xwhile test $# -gt 0 ; do
X	case $1 in
X	-v*)	set -x ;;
X	/*)	bhomearg=$1 ;;
X	*)	echo "$USAGE" ; exit 1 ;;
X	esac
X	shift
Xdone
X
X## Deal with 'backup' account issues.  Generally speaking, if we already have
X## a backup account, we leave it alone.  That means we don't touch the 'backup'
X## entry in /etc/passwd, nor move the home directory, even if the user
X## spec'ed a different home directory on the command line.
X## If necessary, install backup entry in /etc/passwd and create home directory
X
Xpwent=`grep "^backup:[^:]*:$bkpuid:" /etc/passwd | sed -e '1q'`
X
X# get home directory from a) /etc/passwd, b) command arg, or c) default $bhdir
Xif test -n "$pwent" ; then
X	phome=`echo "$pwent" | awk -F: '{print $6}'`
X	# if we got a home arg and it doesn't agree with /etc/passwd
X	if test -n "$bhomearg" -a "$bhomearg" != "$phome" ; then
X		echo "$pr: You specified home directory '$bhomearg'."
X		echo "$pr: The home directory in $HOST:/etc/passwd is '$phome'"
X		echo "$pr: Please change backup's home directory in $HOST:/etc/passwd"
X		echo "$pr: and try again."
X		exit 1
X	fi
X	bhdir=$phome
Xelif test -n "$bhomearg" ; then
X	bhdir=$bhomearg
Xelse
X	bhdir=$bhdir
Xfi
X
X## make home directory if necessary
Xif test -n "$bhdir" -a ! -d "$bhdir" ; then
X	$DTGTBIN/mkpath $bhdir
X	if test $? -ne 0 ; then
X		echo "$pr: Could not make home directory '$bhdir'" 1>&2
X		exit 1
X	fi
Xfi
X
X## make sure home directory isn't NFS'd from elsewhere
X# The 'not a file system' is to handle AT&T's SVR3.2.1 df which complains
X# but exits with status 0.
X# AIX 2.2.1 does a similar thing with 'Cannot find file system'
Xdf=`df $bhdir 2> /dev/null | egrep 'not a file system|Cannot find file system'`
Xif test $? -eq 0 -o -z "$df" ; then
X	: do nothing because the system cannot help us answer this question
Xelif echo "$df" | egrep '^/dev/|^/adj/[^ 	]*dev/|\(/dev/.*\):' > /dev/null ; then
X	: we are on a local filesystem, so do nothing
Xelse
X	echo "$pr: backup's home directory is on an NFS filesystem" 1>&2
X	echo "$df"
X	exit 1
Xfi
X
X## make sure we can create files in backup's homedir
Xtouch $bhdir/junk
Xif test $? -ne 0 ; then
X	echo "$pr: Cannot create files in home directory '$bhdir'" 1>&2
X	exit 1
Xfi
Xrm -f $bhdir/junk
X
Xif test -z "$pwent" ; then
X	#if we're using dump, set up group stuff properly
X	if test -z "$DUMP_P" ; then
X		# make sure we define $newent
X		newent=`cat newent.$SAHOST`
X	else
X		# get machine's operator group ...
X		opgrp=`sed -n -e 's/^operator:[^:]*:\([0-9][0-9]*\):.*/\1/p' /etc/group`
X		case "$opgrp" in
X		[1-9]|[1-9][0-9]*)
X			# got one so put it in backup's passwd entry
X			newent="`awk -F: 'BEGIN {OFS=":"} /^backup:/ {print $1,$2,$3,'$opgrp',$5,$6,$7}' pwent.$SAHOST`"
X		;;
X		*)
X			# didn't get one, so create one using $bkpuid which
X			# is our fallback
X			echo "operator:*:$bkpuid:" >> /etc/group
X			newent=`cat newent.$SAHOST`
X		;;
X		esac
X	fi
X	# handle home directory and login shell
X	if test -n "$CSH_P" ; then
X		homeshell=$bhdir:$CSH_P
X	else
X		homeshell=$bhdir:/bin/sh
X	fi
X	newent=`echo "$newent" | sed -e "s,[^:]*:[^:]*\$,$homeshell,"`
X	# now we can add the passwd entry for the backup account
X	echo "$newent" >> /etc/passwd
X	if test $MKPW_B = true ; then
X		rm -f /etc/passwd.dir /etc/passwd.pag
X		mkpasswd /etc/passwd
X	fi
X	# If /etc/shadow exists, try to deal by running pwconv, an SVR[34] tool.
X	# If pwconv doesn't exist, no harm done; and if it does exist, great.
X	# We don't want to willy-nilly run pwconv, because it will create
X	# an /etc/shadow where none existed before.
X	# Try it in a subshell to filter out any "pwconv: not found" (or such)
X	# messages from the shell, and then put any other shell/pwconv output
X	# back on stderr where it belongs.
X	test -f /etc/shadow && ( pwconv ) 2>&1 | grep -v '[Nn]ot found' 1>&2
Xfi
X
X## figure out exactly what we're going to install - depends on several factors
X# deal with source file and name of installed version
X# make some assumptions here, which we'll change as needed
Xsource=backup
Xinstall=backup
Xcase "$SUIDSCRIPT_S" in
X\#!/bin/sh)
X	case "$OS_S$OSLEVEL_S" in
X	# This pyramid OS supports SUID scripts only for UID's < 100, which
X	# the OS research tool can't reasonably be designed to figure out
X	# Ditto for HP-UX8.00 it seems.
X	OSx512MDNI*|HP-UX8.0*)	test $bkpuid -ge 100 && perm=755 ;;
X	*)			: do nothing since we are OK ;;
X	esac
X;;
X\:)
X	source=backup.colon
X	echo : > $source
X	cat backup >> $source
X;;
X'')
X	case "$SUIDWRAP_B" in
X	true)
X		install=backup.sh
X		# the x and eval are to strip the double quotes from
X		# the '#define SCRIPT_P "/home/backup/backup.sh"'
X		# in backup.c
X		x=`awk '/\#define SCRIPT_P/ {print $3}' backup.c`
X		if test "`eval echo $x`" != $bhdir/$install ; then
X			sed -e '/SCRIPT_P/s,".*","'$bhdir/$install'",' backup.c > nbackup.c
X			mv nbackup.c backup.c
X		fi
X		cc backup.c
X	;;
X	*)
X		perm=755
X		# if we don't support binary setuid wrappers, and
X		#    we don't support #! interpretation, and
X		#    we do have a path to csh, then
X		#	the backup account will have a csh, and the
X		#	system will assume that the 'alldisks' script is a
X		#	csh-script because of the leading '#'.  We have to
X		#	prevent this by prepending a ':' at the start of the
X		#	alldisks script.
X		case "$INTERP_B$CSH_P" in
X		false/*)
X			source=backup.colon
X			echo : > $source
X			cat backup >> $source
X		;;
X		esac
X	;;
X	esac
X;;
Xesac
X
X## test for an "sh" bug first encountered under HP-UX 3.10, where a
X## sourced file becomes $0.  Since alldisks sources sahead, if it trips over
X## this bug "pr" gets set to "sahead", when it should say "backup" :-(
X## we hack around it if necessary
Xecho ':
X. /etc/dist/sahead
Xecho $pr' > chk_sh_source
Xchmod +x chk_sh_source
Xif test `./chk_sh_source` != "chk_sh_source" ; then
X	# you'd think you'd be able to edit $source in place using "ed",
X	# but noooooo, ed is busted under HP-UX 3.10 too, so it's easiest to
X	# do this with awk
X	awk '{print} ; /^\. \/etc\/dist\/sahead/ {print "pr=backup	# linst-alldisks: hack because '"$OS_S $OSLEVEL_S"' sh \".\" bug renames $0"}' $source > $source.hack
X	source=$source.hack
Xfi
X
X## prepare $bhdir to receive new stuff
Xcd $bhdir
X#rm -f $devdata		# remove local $devdata file - uncomment as necessary
X## save old backup script if it exists
Xif test -f $install ; then
X	# get old version number
X	oldversion=`grep '^version=' $install | sed -e 's/^version=\([1-9]*\.[0-9][0-9]\).*/\1/'`
X	# if that doesn't work, punt
X	if test -z "$oldversion" ; then
X		oldversion="old"
X	fi
X	mv $install $install.$oldversion
Xfi
X
X## ok, we're finally ready to install new stuff
Xcd $tdir
Xmv $devdata bkp.site $DTGT
Xmv backup.dd $bhdir
Xmv $source $bhdir/$install
Xif test -f a.out ; then
X	mv a.out $bhdir/backup
X	if test -f $bhdir/backup.c ; then
X		mv $bhdir/backup.c $bhdir/backup.c.$oldversion
X	fi
X	cp backup.c $bhdir
Xfi
Xif test -n "$CSH_P" ; then
X	mv bkp.opers .getoper.csh .cshrc   $bhdir
Xelse
X	mv bkp.opers .getoper.sh  .profile $bhdir
Xfi
X# in case the user wants to use Vixie-cron 2.1 on Linux
Xo="$OS_S$OSLEVEL_S"
Xcase "$o" in
XLinux*)
X	cp backup.mailto $bhdir
X;;
Xesac
X
X## permissions and ownership
Xcd $bhdir
Xchown backup . .??* bkp.opers*
Xchown root   backup $install $DTGT/$devdata
Xchmod $perm  backup $install
Xchmod 644    $DTGT/$devdata bkp.opers*
X
X## for DG/UX, we need to put entries in /etc/dumptab in case we end up
X## using "dump2"
Xcase "$o" in
Xdgux*)
X	egrep '^dat	' /etc/dumptab > /dev/null
X	if test $? -ne 0 ; then
X		echo "$pr: $o: Putting 'dat' entry in /etc/dumptab for 'dump2'"
X		echo "dat		16		2000M	# entry by $pr" >> /etc/dumptab
X	fi
X;;
XAIX3.*)
X	if test "$chkaixdev" = true ; then
X		echo ""
X		echo "$pr: $o: Check block size of any video devices on $HOST."
X		echo "$pr: $o: AIX 3.X video drives come blocked at 512bytes/1024byte"
X		echo "$pr: $o: block, so they can use only half the tape capacity."
X		echo "$pr: $o: For a video drive called '/dev/rmt0', use 'rmt0':"
X		echo "$pr: $o: To Check:  'lsattr -l rmt0 -a block_size -E'"
X		echo "$pr: $o: To Fix:    'chdev  -l rmt0 -a block_size=1024'"
X		echo "$pr: $o: To Break:  'chdev  -l rmt0 -a block_size=512'"
X	fi
X;;
Xesac
X
X## show user the results
Xcase "$install" in
X	backup)		ls -l $bhdir/backup ;;
X	backup.sh)	ls -l $bhdir/backup $bhdir/backup.sh ;;
Xesac
X
X# cleanup installation stuff
Xtest -d $tdir && rm -rf $tdir
SHAR_EOF
chmod 0755 src/backup/linst-alldisks ||
echo 'restore of src/backup/linst-alldisks failed'
Wc_c="`wc -c < 'src/backup/linst-alldisks'`"
test 9202 -eq "$Wc_c" ||
	echo 'src/backup/linst-alldisks: original size 9202, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= src/backup/backup ==============
if test -f 'src/backup/backup' -a X"$1" != X"-c"; then
	echo 'x - skipping src/backup/backup (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting src/backup/backup (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'src/backup/backup' &&
X#!/bin/sh
X# cannot put ":" as first line, setuid sh scripts are unsupported on some hosts
X
X################################################################################
X# This is the famous "alldisks" backup script.  It is justly renowned for
X# its good design and great utility.  It has saved many users much time,
X# hassle, and money.
X#
X#		Bob Arnold (rca@ingres.com)
X#
X# For a usage message, say "backup help".
X#
X# Can be run out of cron with an entry in root's or backup's crontab, e.g.:
X# 00 22 * * * /home/backup/backup full alldisks video0 cron 2>&1 | Mail yourself
X#
X# See the README file for
X#	Installation instructions
X#	Script outline
X#	Variable naming conventions
X#	Discussions of design issues
X#	How to add a new command arg
X#	Revision history
X#	Need/Want feature list
X################################################################################
X
X# have to get this done right away, in case we are writing to STDOUT;
X# use filedescriptor 8 here because we use 9 elsewhere (and more commonly too)
Xif echo " $* " | egrep ' file - ' > /dev/null ; then
X	if echo " $* " | egrep ' (full|incr|tincr) ' > /dev/null ; then
X		exec 8>&1
X		exec 1> /dev/tty
X	elif echo " $* " | egrep ' get ' > /dev/null ; then
X		exec 8>&0
X		exec 0> /dev/tty
X	fi
Xfi
X
X## initial stuff
Xversion=5.01					# Mon Aug  1 16:15:10 PDT 1994
X# home directory
Xhdir=`awk -F: '/^backup:/ {print $6}' /etc/passwd`
X# we need exactly one backup account
Xif test `echo "$hdir" | wc -w` -ne 1 ; then
X	grep '^backup:' /etc/passwd
X	echo "$pr: There should be only one backup account in /etc/passwd; please fix.  Quitting."
X	exit 1
X# and we need backup's home directory
Xelif test ! -d "$hdir" ; then
X	echo "$pr: Home directory for 'backup' doesn't exist!  Quitting."
X	exit 1
Xfi
Xcd $hdir					# go to ~backup
X. /etc/dist/sahead				# MUST source sahead
Xtest -f $DTGT/bkp.site && . $DTGT/bkp.site	# get any site-wide definitions
Xtest -f $hdir/bkp.host && . $hdir/bkp.host	# get host-specific definitions
Xumask ${umask-007}				# so world can't read output
Xexec 9>&1					# FD 9 is copy of STDOUT
X# if there is a local backup script use that instead (but not recursively!)
Xcase $pr in
X$pr.local)
X	echo "$pr: Running $pr $*"
X;;
X$pr)
X	if test -f ./$pr.local ; then
X		echo "WARNING: using backup.local $*"
X		echo "Please REPORT THIS to the proper authorities!"
X		./backup.local $*
X		exit $?
X	fi
X;;
Xesac
X# trap - simply cleanup on exit
Xtrap ":                             ; /bin/rm -f \$rmlist ; exit  " 0
X# trap - if interrupted, log, cleanup and die
Xtrap "echo $pr: Interrupted. Quitting. | tee -a \$workdir/\$report ; /bin/rm -f \$rmlist ; exit 1" 1 2 3 15
X
X# set variables, including defaults
Xdate="`date`"		# save startup date for report and $workdir name
Xstartdir=`pwd`		# save startup directory
Xcmdargs=$*		# save command arguments for later use
Xmode=			# command arg	mode (help|examples|usage|full|incr|get|verify|devcheck)
Xfs=			# command arg	filesystem to be backed up or gotten
Xmedia=			# command arg	media type (dir|file|null) or media alias in $devdata ([host:]cartN|datN|tapeN|tkN|videoN)
X# [opt] command options - default assumptions (shown in alphabetical order)
Xcheck=true		# [opt]	assume we do the device checks
Xcron=false		# [opt]	assume we are not running from cron
Xdemo=false		# [opt]	assume not a script demo
Xextravol=		# [opt] assume unspecified # of extra vols in backup set
Xfsbkp=true		# [opt] assume /fsname is a real filesystem
Xfitguess=true		# [opt] assume we guess whether backups will fit
X#header=${header-false}	# [opt] assume we don't put headers on onedisk backups
Xheader=false		# don't put headers on onedisk backups
Xjoke=${joke-true}	# [opt]	assume we do cpio joke if using cpio
Xlabelq=true		# [opt] assume we ask $OPER to check paper label
Xoptlk=${optlk-false}	# [opt] assume optional lock not set (always lock for cpio)
Xlistf=			# [opt] assume no listfile with filesystems to backup
Xmail=${mail-true}	# [opt]	assume we mail reports to $rptto
Xmhost=			# [opt]	assume host with media device is local
Xoffline=${offline-true}	# [opt]	assume we take media offline
Xprobq=true		# [opt] assume we ask if backup failed
Xshowdd=false		# [opt]	assume backup.dd doesn't show dd command
Xupdate=true		# [opt]	assume we update dumpdates/$bdatef
Xautoverify=true		# [opt] assume user wants as much automation as possible
Xtargetarg=false		# [opt] assume user doesn't spec restore target
Xverifytoo=false		# [opt] assume user doesn't want to verify this backup
X# end of [opt] default assumptions
Xbprog=			# backup program (cpio vs. dump)
Xdlevel=			# dump level (0|5)
Xincr=${incr-5}		# dump incremental level
Xtest_incr=9		# dump incremental level for testing
Xmtype=			# type of media, based on "$media" media alias
Xmistape=true		# media is a tape; set to false iff mtype is (dir|file)
Xoplist=$hdir/bkp.opers	# master file containing list of known operators
Xoplistloc=$oplist.loc	# local file containing local operators
XOPER=$OPER		# OPER is already set in environment, we hope
Xdate4=`echo $date \
X| awk '{ m["Jan"]=1 ; m["Feb"]=2 ; m["Mar"]=3 ; m["Apr"]=4 ; m["May"]=5 ; m["Jun"]=6 ; m["Jul"]=7 ; m["Aug"]=8 ; m["Sep"]=9 ; m["Oct"]=10 ; m["Nov"]=11 ; m["Dec"]=12 ; printf "%02d%02d\n", m[$2],$3}'`
Xdate7=`echo $date | awk '{printf "%d%s%02d\n", $6%100,$2,$3}'`	# 7-char date
Xtime6=`echo $date | awk '{print $4}' | sed -e 's/://g'`		# 6-char time
Xnobkp=$hdir/bkp.donot	# local list of filesystems *NOT* to backup
Xnofm=$hdir/bkp.nofm	# do not backup when doing full multi-volume backups
Xbdatef=$hdir/cpiodates	# like dumpdates but we use it to log cpio backups
Xprobsent=$hdir/probsent	# when we tried to report backup probs; cleared if fixed
Xlockf=$hdir/LOCK	# lock file used by pony:/backupd.disk and cpio backups
Xbdd=$hdir/backup.dd	# reliable script wrapper for (possibly remote) dd
Xnobkptmp=bkp.donot.tmp	# version of $nobkp massaged for "egrep -v"
Xlistftmp=bkp.listf.tmp	# version of $listf massaged for "egrep"
Xdevdata=bkp.media	# file for cart|dat|tape|tk|video device data
Xdft1=bkp.dft1		# "df" output, stage 1 (just get it)
Xdft2=bkp.dft2		# "df" output, stage 2 (SysV to BSD format conversion)
Xdft3=bkp.dft3		# "df" output, stage 3 (stripping unwanted filesystems)
Xdfout=bkp.dfout		# "df" output, final; lists filesystems on multifs tapes
Xdflocal=bkp.dflocal	# "df" output, lists all valid local filesystems
Xbreport=bkp.rpt		# backup mode report file (early version put in header)
Xgvreport=gv.rpt		# "get" or "verify" report file
Xfailrpt=bkp.fail	# operator's reported reason for backup failure
Xfirstblist=bkp.firstb	# list of first backups on each tape
X# the next six files are only created if we're doing a cpio backup
Xflist=bkp.flist		# files to be backed up
Xfiltert1=bkp.filtert1	# files not to back up, stage 1
Xfilter=bkp.filter	# files not to back up, (mounted subdirs + $nobkp)
Xtopfilter=bkp.topfilter	# files at top of $fs that we don't want to give to find
Xtoplist=bkp.topout	# files at top of $fs that we do want to give to find
Xtouchf=/tmp/bkp.newer$$	# find files newer than $touchf for cpio incremental
Xfalseprob=bkp.falseprob	# list of known false backup problems, used via fgrep
Xproblist=bkp.problist	# list of known backup problems, used via fgrep
Xprobsend=bkp.probsend	# send reports of problems with these filesystems
Xstatlist=bkp.statlist	# list of exit statuses for dump/cpio
Xstatprob=bkp.statprob	# list of problem exit statuses for dump/cpio
Xtarhead=bkp.tarhead	# tar header archive for alldisks archives using dump
Xvolmap=bkp.volmap	# map of volumes to filesystems
Xdatecpio=		# set later: SysV date of start of actual cpio
Xhfstat=			# exit status's of dd'ing tar/cpio header file on media
Xexpire=${expire-21}	# remove log dirs more than $expire days old
Xbadmedia=false		# later set to true if operator spec's a bad media type
Xbadrewdev=false		# later set to true if $devdata has bad rewind device
Xbadnorewdev=false	# later set to true if $devdata has bad norewind device
Xmtestf1=/tmp/bkpt1.$$	# media test file 1, has unique info, created on the fly
Xmtestf2=/tmp/bkpt2.$$	# media test file 2, has unique info, created on the fly
Xmtestf3=/tmp/bkpt3.$$	# media test file 3, output file compared to $mtestf[12]
Xmtestf4=/tmp/bkpt4.$$	# media test file 3, output file compared to $mtestf[12]
Xmtestobs=5k		# media test output (write) block size (cart/dat/video >= 1k, 3B15 tape <= 5k, most video/cart/tape devices work with 10k)
Xmtestibs=		# media test input  (read)  block size (set later - depends on $bprog and $multi)
Xpass=/tmp/bkp.pas$time6	# passes info from "| while" subshell to this shell
Xibs=512			# dd option used by cpio backups (guess no "B" or "C")
Xobs=5120		# dd option used by cpio backups (guess no "B" or "C")
Xfileskip=0		# in "get" mode, assume it's a onedisk backup
Xmaxvol=20		# in "get" mode, max number of volumes in backup set
Xonline=''		# used to make sure the media is on line
Xfirstvol=''		# used to make sure we didn't leave vol 1 on by mistake
Xvlist=/tmp/bkp.vlist	# in "verify" mode, output from "restore tfv ..."
Xwhodid=/tmp/bkp.whodid	# in "get/verify" modes, $OPER from original backup
Xprobto=${probto-root}	# who do we send problems to (redefined by $PROBTO)
Xrptto=${rptto-$STASH}	# who do we send reports to
X# get info from sysadmin environment file /etc/saenv
Xlhost=$HOST		# local hostname
Xrsh=$RSH_C		# remote shell command
Xepre="$ECHOPRE"		# echo's no-newline prefix
Xesuf="$ECHOSUF"		# echo's no-newline suffix
X# removal list for cleanup
Xrmlist="$lockf $nobkptmp $mtestf1 $mtestf2 $mtestf3 $mtestf4"
Xfstablist="checklist filesystems fstab vfstab"
X## first major initialization chunk ends here
X
X###############################################################################
X
X## define character strings and macros which may be used repeatedly.
X##
X## A macro is a single-quoted or double-quoted string which contains
X## shellscript code.  To use a macro, simply "eval" it.  When eval'ing a
X## a macro, it may be unquoted or double-quoted.  How you write the macro's
X## shellscript code depends on whether or not you intend to double-quote
X## it when you invoke it.
X##	a) eval $MACRO
X##		* newlines are not preserved in the code, so ...
X##		* the macro can't have comments (except at the very end), and
X##		* the macro must have semicolons at the end of each command
X##	b) eval "$MACRO"
X##		* newlines are preserved in the code, so ...
X##		* the macro may contain comments
X##		* the macro does not need semicolons at the end of each command
X## The reason for the difference is that newlines are preserved by eval when
X## eval'ing a double-quoted string, whereas newlines are not preserved
X## when eval'ing an unquoted macro.
X##
X## To embed a single quote (') into a single-quoted macro string, you have
X## to do something like the following:
X## MACRO='echo foo'"\'"'bar' ; eval "$MACRO" ; eval $MACRO
X## which would produce the following output:
X## foo'bar
X## foo'bar
X## The key to producing the singlequote output is the ("\'") part of the macro.
X## Note that this works whether or not you invoke the macro with doublequotes.
X
X# USAGE - usage message
XUSAGE="
Xusage:
Xbackup help
Xbackup examples
Xbackup usage
Xbackup level       /fsname                                  [host:]media [opts]
X       <full|incr> </fsname|alldisks|listN|unlisted>        [host:]media [opts]
Xbackup get    get_mode                                      [host:]media [opts]
X       get    <onedisk|listdisks|/fsname>                   [host:]media [opts]
Xbackup verify verify_mode                                   [host:]media [opts]
X       verify <onedisk|listdisks|/fsname|alldisks|lastdisk> [host:]media [opts]
Xbackup devcheck                                             [host:]media [opts]
Xbackup devcheck             [host:]<mtype>,/dev/<rewind>,/dev/<norewind> [opts]
X
XPlease use 'backup usage' and/or 'backup examples' to get more info."
X
X# USAGE_LONG - more info on usage
XUSAGE_LONG="$USAGE
Xmodes:		help, examples, usage, full, incr, get, verify, devcheck
Xmedia:		media = 'media alias' for various 'media types'; for example
X		cartN, datN, nullN, tapeN, tkN, or videoN,
X		where 'N' = unit number.
X		See '$devdata' for valid media hosts and media aliases.
X		'[host:]null', '[host:]file <filename>', and
X		'[host:]dir <dirname>' are also valid.
X		In devcheck mode, media can be an alias or real device names.
Xget_modes:	'listdisks' and '/fsname' get_modes imply we are restoring
X		from a multifilesystem backup
Xverify_modes:	'alldisks', 'listdisks', '/fsname', and 'lastdisk' imply
X		we are verifying filesystem(s) on a multifilesystem backup
Xmtype:		media type: cart, dat, tape, tk, or video
X
Xdir [host:]dirname	<dirname> is a directory of onedisk/alldisks archives
Xfile [host:]filename	<filename> is an ordinary file, not a tape device
X
Xopts (all options work with all modes, except as noted):
XE [ /fsname [cont] ] ...
X		get/verify: 'E' = number of *extra* volumes in backup set
X		For example a three-tape backup set has '2' extra volumes.
X		Specify '0' extra volumes if a backup has only one tape.
X		'/fsname ...' = first filesystem on each extra volume
X		'cont' = if that filesystem was continued from previous volume
X		'/fsname' can be 'unknown', but this is strongly discouraged
Xcpio		forces usage of cpio even if a version of BSD dump is available
Xcron		handle running from cron (by setting OPER=cron)
Xdemo		echo's media work without actually doing it
Xentire		get: restore entire archive
Xfifo		DG's dump2 can use fifo for answering queries
Xfsfalse		/fsname is not a filesystem - used to back up directories
Xheader		put a header file even on a onedisk backup tape (not implemented)
Xinteractive	get: do interarctive restore of archive (unsupported for cpio)
Xlist <listfile>	backup filesystems in <listfile>
XlistN		backup filesystems in $hdir/bkp.listN 
Xlock		set optional lock (mandatory lock set regardless for cpio work)
Xnoall		sets all 'no' options shown below
Xnoauto		verify: turn off autoverify mode
Xnocheck		skips the normal check of the rewind and norewind devices
Xnofitguess	skips the normal guess whether an alldisks will fit on media
Xnojoke		skips the normal cpio joke
Xnolabelq	skips the normal get/verify question to check info against label
Xnomail		skips the normal mailing of reports to $rptto
Xnooffline	skips the normal taking media offline
Xnoprobq		skips the normal question re did the backup fail or not
Xnotcont		get/verify: this filesystem is not continued on next volume
Xnoupdate	skips the normal update of /etc/dumpdates or ~backup/cpiodates
Xshowdd		tell backup.dd to show 'dd' commands
Xskip S		get/verify: skip 'S' number of tapefiles on this volume
Xtarget <dir>	get: put restoration tree into specified target directory"
X
XEXAMPLES="
XTypical backup commands are:
Xbackup full alldisks video0     # done perhaps one day each week
Xbackup incr alldisks video0     # done perhaps four days each week
Xbackup full /home dat0		# local onedisk backup of /home to dat0 drive
Xbackup full /home friend:cart0  # network onedisk backup to cart0 on 'friend'
X
XA typical onedisk backup/verify sequence might be:
Xbackup full /home cart0 nooffline	# make the 'onedisk' backup of /home
Xbackup verify onedisk cart0		# verify the 'onedisk' archive of /home
X
XA typical multi-filesystem backup/verify sequence might be:
Xbackup full alldisks video0 nooffline	# do alldisks backup, leave tape in
Xbackup verify alldisks video0		# verify all archives, eject tape
X
XOr, alternatively, you could do:
Xbackup full alldisks video0 verifytoo	# do alldisks backup and verify it too
X
XGet/Verification can ask lots of questions.  Many of them you can answer
Xin advance on the command line.  For example, you can tell 'alldisks' the
Xnumber of 'extra' volumes and the name of the first filesystem on each
Xextra volume:
X        a) an alldisks tape set with only one tape:
X                backup verify lastdisk dat0 0
X        b) an alldisks tape set with three tapes, telling alldisks the
X        names of the first filesystems on extra tape 2 and extra tape 3
X                backup verify lastdisk video5 2 /fs1_tape2 /fs1_tape3
X        c) same as example 'b)', but showing what to do if the first
X        filesystem on extra tape 2 is continued from the first tape;
X        notice the word 'cont' on the command line:
X                backup verify lastdisk video1 2 /fs1_tape2 cont /fs1_tape3
X
XAutoverification is turned on unless it is possible the archive we are
Xverifying could span multiple tapes, as in example 'c)' above.
X
XIf you need to recover a few files, or even an entire filesystem:
Xbackup get onedisk cart0        # get files from a onedisk backup
Xbackup get listdisks video5     # get files from an alldisks backup
Xbackup get /usr friend:dat1     # network get of /usr from an alldisks backup
X
XIf you know all the answers to questions asked in 'verify' mode:
Xbackup verify /home friend:dat0 2 /fs1_t2 /fs1_t3
X
XDitto for 'get' mode, if we have an alldisks backup with one extra tape:
Xbackup get /fsname friend:cart1 1 /fs1_t2 interactive target <target_dir>
X"
X
X# READ - if we are running from cron, it is impossible (and nonsensical)
X# to do a "read" from a terminal.  Obviously if the user does something
X# from cron so that dump/cpio/restore require a read from a tty there's
X# nothing we can do about that.  But we can keep alldisks from doing a
X# tty read.  This macro is used where appropriate.
X#
X# Note the final read is left to the user to decide what to read.  Therefore,
X# the last line of this macro *must* say "read<SPACE><SINGLE_QUOTE>".
XREAD='
Xif test "$cron" = true ; then
X	{
X		echo ''		# probably we need a newline to keep it pretty
X		echo "$pr: I need input from a terminal but I am running from cron."
X		echo "$pr: Quitting."
X	} | tee -a $workdir/$report
X	exit 1
Xfi
Xread '
X
X# KNOWNPROBS - used (via fgrep -f $problist) to check for messages similar to:
X# "DUMP: Can't open /etc/fstab for dump table information."	(This happens if /etc/fstab does not exist, and since dump can't read the dump table (dumpdates) then it does a backup from the epoch)
X# "DUMP: Cannot open /dev/rrf1a"	(check perms on device)
X# "DUMP: do you want to abort"		(dump may have been interrupted)
X# "DUMP: bread: (THIS SHOULD NOT HAPPEN)(dump got a block read error)
X# "DUMP: (This should not happen)bread from /dev/rrf4c [block 975706]: count=2048, got=-1" (SunOS 4.1.2)
X# "DUMP: read error! sector 49310 of /dev/rdsk/c0t1d0s6" (Solaris 2.3 ufsdump got a block read error)
X# "DUMP: can't create child: Resource temporarily unavailable" (Solaris 2.3 ufsdump for some unknown reason)
X# "DUMP: SIGSEGV()  ABORTING!"		(too many bread errors: SunOS 4.x)
X# "Lost connection to remote host."	(network connection died mysteriously)
X# "remotehost: Connection timed out"	(network connection never established)
X# "DUMP: The ENTIRE dump is aborted."	(various reasons ...)
X# "dump: The ENTIRE dump is aborted"	(various reasons under DEC_OSF/1 ...)
X# "/etc/dtmp: Permission denied"	(probably ran as "backup", not "root")
X# "/etc/dumpdates: Permission denied"	(dump/rdump couldn't read/write dumpdates on HP-UX)
X# "/etc/dump: Not found"		(or similar: /etc/saenv has bad DUMP_P entry)
X# "$pr: Backup of '$fs' ABORTED, need more room in /usr/tmp."	(like it says)
X# "$pr: Backup of '$fs' volume $fsvoln ABORTED."	(probably hit EOT or bad tape)
X# "dd: write error"	(check write protected, EOT, or bad tape)
X# "Permission denied."	(can happen in middle of alldisks to remote host)
X#
X#		See also $KNOWNFALSEPROBS !!
X#
X# We create $problist this way, rather than distribute it, because this
X# way we can maintain comments with the list of known problems.
XKNOWNPROBS="DUMP: Cannot open
XDUMP: Can't open /etc/fstab for dump table information.
XDUMP: can't create child:
X abort
X ABORT
Xbread
XConnection
Xconnection
Xdd: read error
Xdd: write error
X Not found
X not found
Xpermission denied
XPermission denied
Xread error"
X
X# KNOWNFALSEPROBS - some versions put out misleading messages, which we
X# may look like problems but really are not problems.
X# KNOWNPROBS - used (via fgrep -f $falseprob) to check for messages like:
X# Unfortunately, Pyramid's SVR4 also puts out the following error message:
X# UFSDUMP: NEEDS ATTENTION: Do you want to restart?: ("yes" or "no")
X# UFSDUMP: This tape will rewind.  After it is rewound,
X# UFSDUMP: replace the tape and this dump volume will be rewritten,
X# UFSDUMP: or abort and restart the dump, specifying correct tape capacity.
X# notice::::::^^^^^ the word abort here is misleading
XKNOWNFALSEPROBS="DUMP: or abort and restart the dump,"
X
X# QUOTEDQ - the letter 'q' quoted in single quotes, needed by EXITQ and BREAKQ
X# You would think there'd be an easier way, but there's not.
XQUOTEDQ="'q'"
X
X# SQUOTE - A single quote suitable for being echo'ed by a macro
X# may need to be used like MACRO='echo "$pr: Can${SQUOTE}t do something" ;'
XSQUOTE="'"
X
X# EXITQ - Does user want to quit/exit program?
XEXITQ='
Xecho $epre "$pr: Enter $QUOTEDQ to quit, anything else to continue: "$esuf
Xeval "$READ" ans
Xcase $ans in
X[qQ]*)	echo "$pr: OK, will quit.  Bye." ; exit ;;
Xesac
X'
X
X# BREAKQ - break out of current loop?
X# This is tricky.  For starters, we have to ask the user this question
X# but we can't read from standard in since dd may be reading from there.
X# But we still want to read from the terminal so we read from
X# /dev/tty and close the input with awk.  Then, getting the quoting
X# and variable evaluation correct is a bit of a mess too.
X# Last, we say we are quitting but we do actually do a 'break', not an 'exit'.
XBREAKQ='
Xecho $epre "$pr: Enter $QUOTEDQ to quit, anything else to continue: "$esuf
Xans=`awk '"'{print ; exit}'"' < /dev/tty`
Xcase $ans in
X[qQ]*)	echo "$pr: OK, will quit.  Bye." ; break ;;
Xesac
X'
X
X# CHECKQ - double check with the operator to see if they really want to do
XCHECKQ='
X	while : ; do
X		echo $epre "$pr: $checkq [yn] "$esuf
X		eval "$READ" ans
X		case "$ans" in
X		y*|Y*)	echo "$pr: OK, just checking.  Will do."   ; break ;;
X		n*|N*)	echo "$pr: OK, we won'"'"'t do one.  Bye." ; exit ;;
X		*)	echo "$pr: Answer '"'y' or 'n'"'." ; continue ;;
X		esac
X	done
X'
X
X# MREADYQ - Is the media ready?
XMREADYQ='
Xecho $epre "$pr: Press <RETURN> when the $media is on line: "$esuf
Xeval "$READ" gaba_gaba_hey
X'
X
X# define awk script to look at backup reports
XBRPT_AWK='
X# output format
XBEGIN {
X	# set up printf formats for the label
X	topbottom="\t\t+---------------------------------------+\n"
X	label="\t\t| %-9s %-11s NA of NA        |\n\t\t| %-21s %s %02d-%s-%s |\n"
X}
X# get filesystem arg
X$1 == "#Invocation:" {
X	print "\t" $0
X	for (i=2; i<=NF; i++)
X		if ($i ~ /\/|alldisk|list[0-9]/) {
X			fs=$i
X		} else if ($i ~ /list/) {
X			fs=sprintf("list=%s", $(i+1))
X		}
X}
X# get alldisks backup script version
X$1 == "#Version:" {
X	version=$2
X}
X# get date info
X$1 == "#Start" {
X	weekday=$3; month=$4; day=$5; time=$6; tzone=$7; year=$8
X}
X$1 == "#Workdir:" {
X	print "\t" $0
X}
X# get other info
X/^[^\#]/ {
X	lhost=$1; mhost=$2; mode=$3; media=$4; mdev=$5; multi=$6; OPER=$7;
X}
X# print label info
XEND {
X	printf("\tOPER=\t     %s\n", OPER)
X	if (length(version)) {print "\tversion=" version}
X	print "\tlabel="
X	printf(topbottom)
X	if (mhost != lhost) {printf("\t\t| Remote Host: %-24s |\n", mhost)}
X	printf(label, lhost, mode, fs, weekday, day, month, year)
X	printf(topbottom)
X	print OPER > "'"$whodid"'"
X}
X'
X
X# report original command line invocation, check against label
X# note - report_p is path to report file we're trying to check.
XLABELQ='
X# our parent may have already done this
Xif test -z "$parent" ; then
X	if test $labelq = true ; then
X		echo "$pr: Operator $OPER - Check this info against the label on the $media:"
X	else
X		echo "$pr: Operater $OPER - Skipping label check:"
X	fi
X	awk "$BRPT_AWK" $report_p
X	if test $labelq = true ; then
X		eval "$EXITQ"
X	fi
Xfi
X'
X
X# SHOWDD shows user what's happening with dd commands if showdd is true
XSHOWDD='
Xtest "$showdd" = true && echo $pr showdd:'
X
X# REW macro rewinds the media, if appropriate
XREW='
Xcase $mtype in
Xdir|file|null)
X	: nothing to rewind
X;;
X*)
X	if test -n "$mt" ; then
X		echo "$mt $rewdev rewind" >> $workdir/$report
X		$mt $rewdev rewind
X	else
X		eval $SHOWDD Rewind $media
X		echo "$bdd if=$rewdev of=/dev/null count=1 bs=$mtestibs 2> /dev/null" >> $workdir/$report
X		$bdd if=$rewdev of=/dev/null count=1 bs=$mtestibs 2> /dev/null
X	fi
X	if test $? -ne 0 ; then
X		echo "$pr: The $media rewind is acting strangely."
X		echo "$pr: Please look at the $media drive."
X		echo $epre "$pr: Press <RETURN> after the $media is rewound: "$esuf
X		eval "$READ" axis_bold_as_love
X	fi
X;;
Xesac
X'
X
X# OFFLINE macro rewinds media and tries to take it offline if necessary
XOFFLINE='
Xeval "$REW"
Xif test $? -eq 0 -a -n "$mt" -a $offline = true ; then
X	echo "$pr: Taking the $media offline."
X	echo "$mt $rewdev offline" >> $workdir/$report
X	# DG SVR4 "mt" uses "unload" instead of "offline".  Their "offline"
X	# command is a noop.
X	# NCR SVR4 and Tandem NonStop-UX 4.0:
X	# "mt" does not support the "offline" command even though
X	# their mt(1) man page says it does.  The "unload" command does not
X	# work either.
X	case "$VENDOR_S$OS_S$OSLEVEL_S" in
X	*dgux5.4R2.*)		$mt $rewdev unload ;;
X	*NonStop-UX*|NCR*)	: do nothing ;;
X	*)			$mt $rewdev offline ;;
X	esac
Xfi
X'
X
X# CHKMEDIA - suggests fixes for media read/write problems
XCHKMEDIA='
Xecho "$pr: -> Is the drive on line?"
Xecho "$pr: -> If $mhost:$media has a tape switch, is it set to $mhost?"
Xecho "$pr: -> Does cycling power on the drive help?"
Xecho "$pr: -> Does cleaning the drive help?"
Xecho "$pr: -> Are the cables to the drive OK?"
Xecho "$pr: -> Is someone else really using the drive (check with '"'"'ps $PSALL_K'"'"')?"
Xecho "$pr: -> Is the tape broken?"
Xecho "$pr: -> Does the drive have a fault light?"
Xecho "$pr: -> Does rebooting the machine help?"
Xecho "$pr: Please fix the problem."
X'
X
X# CHKMWRITE - reports media write problem and suggests fixes.
XCHKMWRITE='
Xecho "$pr: Can'"'"'t write to the $media.  Check:"
Xecho "$pr: -> Is the $media write-protected?"
Xcase $mtype$OS_S$OSLEVEL_S in
XcartAIX3*)	echo "$pr: -> Is the $media a '"'"'3M 6150'"'"'?" ;;
Xcart*)		echo "$pr: -> Is the $media 12,500ftpi-compatible?" ;;
Xesac
Xeval "$CHKMEDIA"
X'
X
X# CHKMREAD - reports media read problem and suggests fixes.
XCHKMREAD='
Xecho "$pr: Can'"'"'t read from drive $media.  Check:"
Xeval "$CHKMEDIA"
X'
X
X# MAILRPT - if we're sending $report to $rptto, do it
XMAILRPT='
Xtest $mail = true && $MAILER -s $report,$lhost $rptto < $workdir/$report
X'
X
X# PROBTO - define who we send problems reports to
XPROBTO='
X# if mode is get or verify, ask if we want to send problem report
X# else send problem report automatically
Xcase "$mode$OS_S" in
Xget*|verify*)	probto="ct-3@$SAHOST"  ;;
X*ULTRIX)	probto="ct-16@$SAHOST" ;;
X*)		probto="ct-12@$SAHOST" ;;
Xesac
X'
X
X# LNFSTABLIST - link fstab list from parent
XLNFSTABLIST='
X	# for multi-fstype OS such
X	# as NonStop-UX
X	for f in $fstablist ; do
X		ln ../$f . 2> /dev/null
X	done
X'
X
X# SKIP2ARCHIVE - position tape on correct archive for get or verify
XSKIP2ARCHIVE='
X# The code tries to handle the case when we do not know which volume
X# the backup is on, based on the assumption that hitting EOT will
X# generate a message of some sort.  If this assumption is wrong, there is
X# no possibility of developing a successful strategy.  Another assumption
X# is that an incomplete dump at EOT is successfully skipped by mt "fsf".
X# True/false/NA values for both assumptions are shown below:
X#
X#		"fsf" works
X#	EOT	for partial
X#	message	dump		hardware		attached to
X#	-------	---------------	-----------------------	-----------------
X#	true	true		E8200 Sun		Sun 4/690
X#	false	NA		E8500 MicroTechnologies	Sun 4/380
X#
X# make sure tape is been rewound after getting the tar
X# header file - needed for slow rewind on video drives
Xeval "$REW"
Xcurdir=`pwd`
Xcd $workdir
Xif test $mtype = dir -o $mtype = file ; then
X	fileskip=0
X	echo	"#skipcmd: mtype $mtype - nothing to skip" >> $report
Xelif test -n "$mt" ; then
X	echo	"#skipcmd: $mt $norewdev fsf 1 2>&1 | tee err.mt | wc -l" >> $report
Xelse
X	echo	"#skipcmd: $bdd if=$norewdev of=/dev/null bs=$mtestibs 2>&1 | tee -a err.dd" >> $report
Xfi
Xn=0		# number of tapefiles we have successfully skipped
Xwhile test $n -lt $fileskip ; do
X	# try to skip a file:
X	# if we have mt
X	if test -n "$mt" ; then
X		# we hope that mt will report errors,
X		# which the subshell will put to
X		# standard out or standard error
X		echo "$pr: $mt $norewdev fsf 1 2>&1 | tee err.skip | wc -l"
X		skipstat=` $mt $norewdev fsf 1 2>&1 | tee err.skip | wc -l`
X	# else we have to emulate mt somehow
X	else
X		eval $SHOWDD Use dd to forward-skip-file
X		echo "$bdd if=$norewdev of=/dev/null bs=$mtestibs 2>&1 | tee -a err.skip"
X		$bdd       if=$norewdev of=/dev/null bs=$mtestibs 2>&1 | tee -a err.skip
X		skipstat=$?
X	fi
X	# mt commands for HP-UX dat drives return 2-3 seconds before the tape
X	# actually finishes positioning itself
X	case $OS_S$mtype in
X	HP-UXdat)	sleep 4 ;;
X	esac
X	# if we skipped a file
X	if test $skipstat -eq 0 ; then
X		n=`expr $n + 1`
X		echo "$pr: Skipped $n of $fileskip $media files." | tee -a $report
X	# else we ran off the end of the media or hit a bad spot (we assume
X	# we hit EOT, and pretty much ignore the bad spot possibility)
X	else
X		# try to take the tape offline in background while we
X		# do a bit of work
X		eval "$OFFLINE" &
X		cat err.skip | tee -a $report
X		echo "$pr: Error skipping `expr $n + 1` of $fileskip $media files." | tee -a $report
X		echo "$pr: Time to make some guesses:"
X		echo "$pr: Guess: We hit End-Of-Tape (but it could be a bad spot on the $mtype)."
X		echo "$pr: Guess: It was not on volume $onvol."
X		echo "$pr: Guess: The last media file we skipped on volume $onvol"
X		echo "$pr: was an incomplete archive."
X		# do some calcs now ...
X		onvol=`expr $onvol + 1`			# is it on next volume?
X		x=`awk "NR==$n {print \\$NF}" $dfout`	# 1st fs on next volume
X		n=`expr $n - 1`				# for incomplete archive
X		fileskip=`expr $fileskip - $n`		# recalc $fileskip
X		n=0					# reset "skipped" count
X		# record new guesses and report to operator
X		echo "#fs=$fs bkpn=$bkpn onvol=$onvol fileskip=$fileskip" >> $report
X		echo "$pr: Guess: We have to skip $fileskip file(s) on volume $onvol"
X		echo "$pr: to position the $media at the backup of $fs."
X		echo "$pr: Guess: The first filesystem on volume $onvol is $x"
X		echo "$pr: Please WRITE '\''Guess:$x'\'' ON VOLUME $onvol."
X		eval "$EXITQ"
X		echo "$pr: Please mount volume $onvol."
X		# wait for offline attempt to complete
X		wait
X		eval "$MREADYQ"
X	fi
Xdone
Xcase $mtype in
Xdir|file)	: do nothing ;;
X*)		echo "$pr: We have positioned the $media." ;;
Xesac
Xcd $curdir
X'
X
X# DO_GETCORE - the core of the DO_GET macro
X# This macro needs definitions for $getlist, $rans, $rmode, and $rout
XDO_GETCORE='
X	# must redefine getcore every time because
X	# 	1) $rmode can change in the middle of the script for a verify
X	#	2) $restore can change for Tandem
X	# $getlist is provided because
X	#	1) someday we may figure out how to do a selective/interactive
X	#	   cpio restore
X	#	2) when verifying using restore, the extraction phase needs it
X	case $mhost in
X	$lhost)	mhostdev=$mdev        ;;
X	*)	mhostdev=$mhost:$mdev ;;
X	esac
X	rkey=$rmode$roptkey
X	cpiocore="cpio -idum$ckey $getlist"
X	case $bprog$mhost/$OS_S in
X	cpio$lhost/*)	getcore="                      $cpiocore < $mdev" ;;
X	cpio*/*)	getcore="$bdd if=$mdev bs=5k | $cpiocore        " ;;
X	*/DEC_OSF/1)	getcore="$restore -f $mhostdev     -$rkey $ropts" ;;
X	*/*)		getcore="$restore $DRMINUS$rkey $mhostdev $ropts" ;;
X	esac
X	case $bprog in
X	cpio)	getcmd="$getcore" ;;
X	*)	getcmd="$rans $getcore $getlist $rout" ;;
X	esac
X	eval echo \""$pr: $getcmd"\" | tee -a $workdir/$report
X	eval "$getcmd"
X	getstat=$?
X	echo "getstat=$getstat" >> $workdir/$report
X'
X
X# DO_GET - things we always do when getting something from an archive
XDO_GET='
X	# special code for  NonStop-UX4.0 which has both
X	# vxfs and ufs filesystem types.
X	case "$OS_S$OSLEVEL_S" in
X	NonStop-UX4.0)
X		# if we are trying to verify a onedisk backup
X		if test ! -f $workdir/vfstab ; then
X			: do nothing, but pray we have the correct restore
X		# else try to determine the correct restore from vfstab;
X		# we should have vfstab if we are doing an alldisks
X		# verify, or if our parent is an alldisks verify
X		else
X			fstype=`awk "/^#/ {next} ; \\$3 == \"$fs\" {print \\$4}" $workdir/vfstab`
X			case $fstype in
X			ufs)	restore=$RESTOR_P ;;
X			vxfs)	restore=/sbin/vxrestore ;;
X			esac
X		fi
X	;;
X	esac
X	eval "$DO_GETCORE"
X	# and more special code ...
X	case "$OS_S$OSLEVEL_S" in
X	# else we guessed wrong about the correct restore program so
X	# try the other one
X	NonStop-UX4.0)
X		# Both ufsrestore and vxrestore under NonStop-UX4.0 use 31
X		# exit status for a successful table listing (but why?)
X		# and 32 for failure
X		case $getstat in
X		# we were lucky and the "ufsrestore" guess was correct
X		31)
X			: so do nothing
X		;;
X		# we were unlucky so try the other one
X		32)
X			case $RESTOR_P in
X			*/vx*)	restore=$RESTOR_P ;;
X			*/ufs*)	restore=/sbin/vxrestore ;;
X			esac
X			# we should not have to reposition the tape,
X			# since this is a onedisk backup
X			eval "$DO_GETCORE"
X		;;
X		esac
X	;;
X	esac
X'
X
X# EGREPF - egrep -f
X# if there are too many filesystems listed in the fsfilters or lists,
X# egrep -f <fsfilter|list> may cause egrep to croak:
X# egrep: regular expression too long
X# $EGREPF macro needs:
X#	egrepff		egrep pattern file	must exist
X#	egrepfi		egrep input file	can be null or real file(s)
X#	egrepfo		egrep output file	can be null or a real file
X#	egrepfr		egrep '-v' flag		can be null or '-v'
X# The 'eval' and $outcode are required since some OS (Pyramid's OSx and
X# DEC's Ultrix) don't handle 'eval "$EGREPF" > some_output_file' kindly.
X# The 'cat' commands are to work around a NonStop-UX4.0 bug in "egrep -f"
X# ('egrep -f $egrepff somefile' breaks :-( ) and to allow $egrepfi to have
X# more than one file
XEGREPF='
X	case "$egrepfo" in
X	"")	outcode="" ;;
X	*)	outcode=">> $egrepfo" ;;
X	esac
X	echo oh_blah_dee_oh_blah_dah \
X	| egrep -f $egrepff 2>&1 \
X	| egrep "egrep: regular expression too long" > /dev/null
X	# if we do not have the problem, life is easy
X	if test $? -ne 0 ; then
X		cat $egrepfi | eval egrep $egrepfv -f $egrepff $outcode
X	# else we have to deal with it
X	else
X		split -5 $egrepff egrepf.
X		# if -v, do egreps in a pipeline
X		case $egrepfv in
X		-v)
X			for i in egrepf.* ; do
X				if test -z "$egrepcmd" ; then
X					egrepcmd="egrep -v -f $i"
X				else
X					egrepcmd="$egrepcmd | egrep -v -f $i"
X				fi
X			done
X			cat $egrepfi | eval $egrepcmd $outcode
X		;;
X		# if not -v, grep through each split file in turn
X		"")
X			for i in egrepf.* ; do
X				cat $egrepfi | eval egrep -f $i $outcode
X			done
X		;;
X		*)
X			echo "$pr: EGREPF macro: egrepfv must be empty or -v."
X			exit 1
X		;;
X		esac
X		rm egrepf.*
X	fi
X'
X
X# FSNNPLUS1 - increment $fsnn
XFSNNPLUS1='
Xfsnn=`expr $fsnn + 1`
X# make sure $fsnn is two digits (need for later sorting)
Xcase $fsnn in
X[0-9])	fsnn=0$fsnn ;;
X*)	fsnn=$fsnn ;;
Xesac
X'
X
X# MDEV - need to reassign $mdev if we're a dir or file
XMDEV='
Xcase $mtype$diskfile$multi in
Xdir-false|file-false)	mdev="-" ;;
Xdir*false|file*false)	mdev=$mdevbase ;;
Xdir-true|file-true)	echo "$pr: Cannot do alldisks to STDOUT" ; exit 1 ;;
Xdir*true|file*true)	mdev=$mdevbase.$fsnn ;;
Xesac
X'
X
X# GVRPT_ED - ed script to edit get/verify output from restore
X# the "1kx" is as close as I can find to a no-op in ed, inserted to make
X# the substitutions look prettier
X# we want to add newlines for typical "restore" output like
X#	restore ><SPACE>
X#	Specify next volume #:<SPACE>
X#	set owner/mode for '.'? [yn]<SPACE>
X#	continue? [yn]<SPACE>
X#	Directories already exist, set modes anyway? [yn]	# Solaris 2.1
X#	then enter volume name (default: /dev/rast4)		# Dynix/ptx
X# to make $gvreport more readable
X# These regular expressions will also work for "ufsrestore > " and such.
XGVRPT_ED='1kx
Xg/restore > /s//&\
X/g
Xg/? \[[yn]*\]* */s//&\
X/g
Xg/[sS]et owner\/mode for .... \[[yn]*\]* */s//&\
X/g
Xg/[dD]irectories already exist, set modes anyway? \[[yn]*\] */s//&\
X/g
Xg/[sS]pecify next volume \#: /s//&\
X/g
Xg/then enter volume name .*/s//&\
X/g
Xw
Xq
X'
X
X###############################################################################
X
X# source the site-defined post-definition macro here, immediately after
X# defining initial simple variables and MACROs, and before we start
X# getting other information from the command line
Xeval "$DOPOSTDEFS"
X
X## report version number
Xecho "$pr: 'alldisks' backup script, version $version"
X
X## get invocation (command line) options
X# options can be in any order since they're unique
X# more option checking happens later
X# getmode is actually used for "verify" mode too
Xtest -n "$cmdargs" && set $cmdargs
Xwhile test $# -gt 0 ; do
X	case $1 in
X	## examples/help/usage modes
X	examples)
X		echo "$EXAMPLES"
X		exit 0
X	;;
X	help)
X		echo "$USAGE"
X		exit 0
X	;;
X	usage)
X		echo "$USAGE_LONG"
X		exit 0
X	;;
X	## backup/get/verify/devcheck modes
X	f|full)
X		mode=full
X	;;
X	i|inc*)
X		mode=incr
X	;;
X	t|tinc*)
X		mode=tincr
X	;;
X	get)
X		mode=get
X	;;
X	verify)
X		mode=verify
X	;;
X	devcheck)
X		mode=devcheck
X		case "$2" in
X		# media spec'ed as [host:]<mtype>,/dev/<rewind>,/dev/<norewind>
X		*,*/dev/*,/dev/*)
X			media=devnames
X			mhost=`   expr $2 : '\(..*\):.*' \| $lhost`
X			mtype=`   expr $2 : '.*:\(..*\),.*,.*' \| $2 : '\(..*\),.*,.*'`
X			rewdev=`  expr $2 : '.*,/dev/\(..*\),.*'`
X			norewdev=`expr $2 : '.*,.*,/dev/\(..*\)'`
X			shift
X		;;
X		esac
X	;;
X	## valid as both getmodes and backup modes
X	/*)
X		multi=false
X		getmode=knownfs
X		fs=$1
X	;;
X	alldisk*)
X		multi=true
X		getmode=alldisks
X		multitype=alldisks
X	;;
X	## valid only as backup modes
X	list)
X		shift
X		multi=true
X		case "$1" in
X		'')	echo "$pr: No list file specified." ; echo "$USAGE" ; exit 1 ;;
X		/*)	listf=$1 ;;
X		*)	listf=$startdir/$1 ;;
X		esac
X		multitype=list
X	;;
X	list[0-9]*)
X		multi=true
X		listf=$hdir/bkp.$1
X		multitype=list
X	;;
X	unlisted)
X		multi=true
X		multitype=unlisted
X	;;
X	## valid only as getmodes
X	lastdisk)
X		multi=false
X		getmode=lastdisk
X	;;
X	listdisk*)
X		multi=false
X		getmode=listdisks
X	;;
X	onedisk)
X		multi=false
X		getmode=onedisk
X	;;
X	## media aliases and hosts
X	null|cart*|dat*|tape*|tk*|video*)
X		marg=$1
X		media=$1
X		mhost=$lhost
X	;;
X	*:null|*:cart*|*:dat*|*:tape*|*:tk*|*:video*|*:/dev/*,/dev/*)
X		marg=$1
X		media=`expr $1 : '.*:\(.*\)'`
X		mhost=`expr $1 : '\(.*\):.*'`
X	;;
X	dir|file)
X		marg=$1
X		media=$1
X		mhost=$lhost
X		mistape=false
X		offline=false
X		shift
X		diskfile=$1
X		#case $diskfile in "-") probq=false ;; esac
X	;;
X	*:dir|*:file)
X		marg=$1
X		media=`expr $1 : '.*:\(.*\)'`
X		mhost=`expr $1 : '\(.*\):.*'`
X		offline=false
X		shift
X		diskfile=$1
X	;;
X	## options
X	d|demo)
X		echo "$pr demo: media commands will be echoed, not done."
X		demo=true
X	;;
X	cpio)
X		bprog=cpio	# use cpio even if BSD dump is available
X		cpioarg=$1
X	;;
X	cron)
X		cron=true
X		probq=false
X		OPER=cron
X	;;
X	entire)
X		entire=true
X	;;
X	header)
X		#header=true
X		header=false
X		echo "$pr: NOTE: header option not implemented yet"
X	;;
X	interactive)
X		entire=false
X	;;
X	fifo)
X		opfifo="O $hdir/bkp.opfifo"	# dump2's output fifo option
X	;;
X	fsfalse)
X		fsbkp=false	# we're backing up an ordinary file/directory
X	;;
X	lock)
X		optlk=true
X	;;
X	noall)
X		autoverify=false
X		check=false
X		fitguess=false
X		joke=false
X		labelq=false
X		mail=false
X		offline=false
X		probq=false
X		update=false
X	;;
X	noauto)
X		autoverify=false
X		autoarg=$1
X	;;
X	nocheck)
X		check=false
X	;;
X	nofitguess)
X		fitguess=false
X	;;
X	nojoke)
X		joke=false
X	;;
X	nolabelq)
X		labelq=false
X	;;
X	nomail)
X		mail=false
X		mailarg=nomail
X	;;
X	nooffline)
X		offline=false
X	;;
X	noprobq)
X		probq=false
X	;;
X	noupdate)
X		update=false
X	;;
X	notcont)
X		cont2next=false
X	;;
X	showdd)
X		showdd=true
X		BDDSHOW=true
X		export BDDSHOW
X		showddarg=$1
X	;;
X	skip)
X		shift
X		fileskip="$1"
X		getmode=knownskip
X		labelq=false
X	;;
X	target)
X		shift
X		target="$1"
X		targetarg=true
X	;;
X	verifytoo|verify2)
X		verifytoo=true
X	;;
X	[0-9]|[12][0-9])
X		extravol=$1
X		nvol=`expr $extravol + 1`
X		n=$extravol
X		while test $n -gt 0 ; do
X			case "$2" in
X			/*|unknown)
X				shift
X				firstfslist="$firstfslist $1"
X				case "$2" in
X				cont*)
X					shift
X					# use "cont" as canonical spelling
X					firstfslist="$firstfslist cont"
X				;;
X				esac
X				n=`expr $n - 1`
X			;;
X			*)
X				break
X			;;
X			esac
X		done
X	;;
X	[01][0-9][0123][0-9].*[a-z])
X		parent=$1
X		offline=false
X		joke=false
X		labelq=false
X	;;
X	*)
X		echo "$pr: Option '$1' not understood.  Quitting."
X		echo "$USAGE"
X		exit 1
X	;;
X	esac
X	shift
Xdone
X# pass these args to any child backup processes, for example:
X# when a backup does a "verifytoo"
X# when a "verify alldisks" does a "verify onedisk"
Xchildargs="$cpioarg $showddarg $autoarg $mailarg"
X
X## make sure we know who is doing this backup ('cron' option sets $OPER to
X## cron, otherwise we hope to get it from our environment)
Xfor f in $oplist $oplistloc ; do
X	test -f $f && opfiles="$opfiles $f"
Xdone
Xwhile test "$OPER" = "" -o "$OPER" = '??' -o -z "`egrep '^'$OPER'[ 	]|^'$OPER'$' $opfiles`" ; do
X	echo "$pr: I don't know who you are."
X	echo $epre "$pr: Please enter your initials: "$esuf
X	eval "$READ" OPER
X	# break out of here if we know who $OPER is
X	egrep "^$OPER[ 	]|^$OPER\$" $opfiles > /dev/null && break
X	# otherwise try to find out
X	while : ; do
X		echo "$pr: I don't know who '$OPER' is."
X		echo $epre "$pr: Do you wish to be added as a backup operator? [yn] "$esuf
X		eval "$READ" ans
X		case $ans in
X		[nN]*)			
X			break 2
X		;;
X		[yY]*)
X			echo $epre "$pr: Enter your login name: "$esuf
X			eval "$READ" login
X			case $login in
X			*' '*|[A-Z0-9]*)
X				echo "$pr: Invalid login name '$login'"
X				continue
X			;;
X			[a-z]*)
X				: do nothing since we seem to be ok
X			;;
X			*)
X				echo "$pr: Invalid login name '$login'"
X				continue
X			;;
X			esac
X			echo $epre "$pr: Enter your Full Name: "$esuf
X			eval "$READ" name
X			echo "$OPER	$login		$name" >> $oplist
X			break 2
X		;;
X		esac
X	done
Xdone
Xoperlogin=`grep "^$OPER[ 	]" $opfiles | awk '{print $2; exit}'`
Xexport OPER	# in case we do verifytoo or this is a 'verify alldisks'
X
X## if backups have to be done as root, make sure the operator is su'd
Xif test `ls -l $0 2>&- | grep -c '^...x'` -eq 1 ; then
X	# find out effective user id - this is a guessing game but the
X	# following rule seems best: whoami > id > $USER > $LOGNAME
X	whoami=`( whoami ) 2> /dev/null`
X	id=`( id | sed -e 's/).*//' -e 's/.*(//' ) 2> /dev/null`
X	for arg in whoami id USER LOGNAME ; do
X		eval "test -n \"\$$arg\" && result=\$$arg && break"
X	done
X	case $result in
X	*root)	: we are root so we are OK ;;
X	*)	echo "$pr: Backups on $lhost must be done as root." ; exit 1 ;;
X	esac
Xfi
X
X## check mode specs and make some early decisions
Xcase "$mode" in
X'')
X	echo "$pr: 'mode' was not specified.  Valid modes are:"
X	echo "$pr: 'help', 'full', 'incr', 'get', 'verify', or 'devcheck'."
X	echo "$USAGE"
X	exit 1
X;;
Xfull|incr|tincr)
X	report=$breport
X	if test -z "$multi" ; then
X		echo "$pr: 'filesystem' was not specified.  Valid filesystems are:"
X		echo "$pr: '/fsname', 'alldisks', 'listN', 'list listfile', or 'unlisted'."
X		echo "$USAGE"
X		exit 1
X	fi
X;;
Xget|verify)
X	report=$gvreport
X	if test -z "$getmode" ; then
X		echo "$pr: 'getmode' was not specified.  Valid getmodes are:"
X		echo "$pr: 'onedisk', 'listdisks', '/fsname', 'lastdisk', or alldisks'."
X		echo "$USAGE"
X		exit 1
X	fi
X;;
Xdevcheck)
X	: nothing special needs to be done here
X;;
X*)
X	echo "$pr: Do not understand mode '$mode'."
X	echo "$USAGE"
X	exit 1
X;;
Xesac
X
X## double check on a couple of unusual possible requests
X# if the operator says to do an incremental of just one filesystem, verify it.
Xcase $mode$multi in
X*incrfalse)
X	checkq="Do you REALLY want to run an INCREMENTAL on '$fs'?"
X	eval "$CHECKQ"
X;;
X# if the operator specified a full alldisks but there are list files present
Xfulltrue)
X	if test "$multitype" = alldisks -a "`echo bkp.list[0-9]*`" != "bkp.list[0-9]*" ; then
X		echo "$pr: There are list files in backup's home directory,"
X		echo "$pr: so we are probably managing tape usage for full"
X		echo "$pr: backups of $lhost with a 'list1/unlisted' scheme."
X		ls -l bkp.list[0-9]*
X		checkq="Are you SURE you want to do a 'full alldisks'?"
X		eval "$CHECKQ"
X	fi
X;;
Xesac
X
X## check media stuff
X# select device data file
Xif test -f $hdir/$devdata ; then
X	devdata=$hdir/$devdata
X	echo "$pr: WARNING: using '$devdata' for device data."
Xelif test -f $DTGT/$devdata ; then
X	devdata=$DTGT/$devdata
Xelse
X	echo "$pr: No '$devdata' in '$DTGT' or '$hdir'.  Quitting."
Xfi
X# see if $mhost and $media are ok; note: a host may have no valid local media
Xmtype=`expr "$media" : '\([^0-9]*\)'`
Xmdata=`egrep "^$mhost[ 	]+$media[ 	]" $devdata`
Xcase "$mtype" in
X# if operator didn't specify media
X'')
X	echo "$pr: 'media' was not specified."
X	badmedia=true
X;;
X# if $mtype is null, no more validation needed since we always have /dev/null
Xnull)
X	: do nothing
X	mistape=false
X;;
X# $mtype is dir or file, so we are writing or reading a file, not a tape device
Xdir|file)
X	# make sure we're doing the right thing
X	case "$mode" in
X	devcheck)
X		echo "$pr: 'devcheck' mode not supported for 'file' archives.  Quitting."
X		exit 1
X	;;
X	get|verify)
X		case $diskfile$multi in
X		-true)	echo "$pr: Cannot read alldisks from STDIN" ; exit 1 ;;
X		esac
X	;;
X	# some kind of backup
X	*)
X		case $diskfile$multi in
X		-true)	echo "$pr: Cannot write alldisks to STDOUT" ; exit 1 ;;
X		esac
X	;;
X	esac
X;;
X# $mtype is devnames, so make sure we are in devcheck mode
Xdevnames)
X	if test "$mode" != devcheck ; then
X		echo "$pr: Cannot specify device names except in devcheck mode."
X		badmedia=true
X	fi
X;;
X# $mtype is dat or video, so we only need to see if $media is valid
Xdat|video)
X	if test -z "$mdata" ; then
X		echo "$pr: '$media' is not a valid media for host '$mhost'"
X		badmedia=true
X	fi
X;;
X# $mtype isn't null, dat or video, so see if $media is valid, and also
X# make sure we don't do a full multi-filesystem backup to non-video/dat media
X*)
X	if test -z "$mdata" ; then
X		echo "$pr: '$media' is not a valid media for host '$mhost'"
X		badmedia=true
X	elif test "$mode" = full -a "$multi" = true -a "$fitguess" = true ; then
X		echo "$pr: A 'full alldisks' will not fit on a '$mtype'."
X		badmedia=true
X	fi
X;;
Xesac
Xif test "$badmedia" = true ; then
X	# print devices available on the media host and quit
X	vmedia=`egrep "^$mhost[ 	]" $devdata | awk '{print $2}'`
X	vmedia=`echo $vmedia`		# strip newlines
X	if test -n "vmedia" ; then
X		echo "$pr: $mhost has these media: '$vmedia'."
X	fi
X	echo "$pr: Look at '$devdata' for a list of valid"
X	echo "$pr: media hosts and their devices."
X	echo "$pr: Quitting."
X	exit 1
Xfi
X# now that media info is ok, get info from $devdata by way of $mdata
X# for dir, file, null, and devnames, obs of 5120 is arbitrary,
X# maxocount of 100000 blocks is very arbitrary, and we pick 330000
X# for backup program options because it's our biggest valid "$bopt"
Xcase $mtype in
Xdir|file|null)
X	set $mhost $mtype xx 100000 null null 330000
X;;
Xdevnames)
X	set $mhost $mtype xx 100000 $rewdev $norewdev
X;;
X*)
X	set $mdata
X;;
Xesac
Xreserved=$3		# document that we don't use this field since 4.22
Xmaxocount=$4		# maximum number of output blocks per tape
Xrewdev=/dev/$5		# name of rewind device we're using
Xnorewdev=/dev/$6	# name of no-rewind device we're using
X# should say "shift 6" here but CCI's BSD "sh" doesn't like it
Xshift ; shift ; shift ; shift ; shift ; shift
Xbopts="$*"		# backup program (cpio/dump) options, if any
X# if $media is null, check with user, and set variables
Xif test $media = null ; then
X	echo "$pr: WARNING!!! media is '$media' !!!"
X	echo "$pr: This backup will be USELESS !!!"
X	eval "$EXITQ"
X	update=false
X	offline=false
Xfi
X# if we're skipping media checks and we haven't already checked it, then
Xif test $check != true -a -z "$parent" ; then
X	echo "$pr: WARNING: You are skipping media checks !!!"
X	echo "$pr: You had better know what YOU are doing !!!"
X	eval "$EXITQ"
Xfi
X
X###### Handle some real strange problems
Xcase $mlocal$multi$OS_S in
X# This shouldn't be a problem, but it is, so we'd better not even try this:
XfalsefalseAIX)
X	echo "$pr: AIX network cpio onedisk backups *don't* work."
X	echo "$pr: FYI, this is mysterious, because, so far as we know:"
X	echo "$pr: 1) AIX network cpio multi-filesystem backups *do* work."
X	echo "$pr: 2) Both onedisk and multi-filesystem network cpio backups"
X	echo "$pr: for other UNIXs *do* work."
X	echo "$pr: The problem is that the archive is missing the first 88k or"
X	echo "$pr: so of the archive.  It is unknown why this happens."
X	exit 1
X;;
Xesac
X# This is a real problem:
Xcase $mlocal$multi$mistape$OS_S$OSLEVEL_S$rewdev in
Xfalsetruetruedgux5.4*/dev/rmt/*)
X	echo "$pr: WARNING: Under dgux 5.4, if a multi-filesystem network"
X	echo "$pr: backup to a '/dev/rmt' device uses more than one tape,"
X	echo "$pr: and it looks like it works beautifully, BE AWARE:"
X	echo "$pr: the filesystem which is split accross two tapes may be"
X	echo "$pr: missing 50 blocks (or so) of buffered data which the remote"
X	echo "$pr: system was unable to write to its tape drive when it hit"
X	echo "$pr: physical EOT (end of tape)."
X	echo "$pr: You can try setting up and using a pseudo mag tape"
X	echo "$pr: '/dev/pmt' device on $lhost instead."
X	eval "$EXITQ"
X;;
Xesac
X
X# now that our mode has been set, we can make sure we don't conflict
X# with another currently running backup/get/verify
Xif test -f $lockf -a $mode != devcheck -a -z "$parent" ; then
X	echo "$pr: A conflicting cpio backup/get/verify seems to be in progress."
X	cat $lockf
X	echo "$pr: Check with 'ps $PSALL_K'.  Quitting."
X	# take the lock file out of $rmlist before exiting!
X	rmlist=`echo $rmlist | sed -e "s,$lockf ,,"`
X	exit
Xfi
X
X# See if we know how many extra volumes are in the backup set.
X# This only makes sense if we're doing a get or verify.
Xif test -n "$extravol" ; then
X	case $mode in
X	get|verify)	: we are ok but do we do not have to do anything ;;
X	*)		echo "$USAGE" ; exit 1 ;;
X	esac
Xfi
X
X# if user specified a restore target on the command line, make sure we're
X# in "get" mode and that they really did specify *some* target (which we'll
X# check out more thoroughly later).
Xif test "$targetarg" = true ; then
X	case $mode in
X	get)
X		if test -z "$target" ; then
X			echo "$pr: Target directory not specified.  Quitting."
X			echo "$USAGE"
X			exit 1
X		fi
X	;;
X	*)
X		echo "$pr: 'target <dir>' only valid for 'get' mode.  Quitting."
X		echo "$USAGE"
X		exit 1
X	;;
X	esac
Xfi
X
X# if user specified a listfile on the command line, make sure it exists
X# and has something in it.
Xif test -n "$listf" ; then
X	if test ! -f $listf ; then
X		echo "$pr: No such listfile '$listf'.  Quitting."
X		exit 1
X	elif test ! -s $listf ; then
X		echo "$pr: Listfile '$listf' is empty.  Quitting."
X		exit 1
X	fi
Xfi
X
X## we've checked as much command syntax as we can without making a working
X## directory, but we need one now.
X# It's name has a short form "$wdir" and long form "$workdir".
X# It's "$wdir" name is based on the
X# a) date, b) mode, and c) onedisk vs. multi-filesystem archive.
X# "g" for get, "f" for full, "i" for incremental, "t" for test_incremental,
X# and "v" for verify;
X# "m" for multi-filesystem (alldisks), "o" for onedisk
Xcase "$mode$multi" in
Xdevcheck*)	wdir=$date4.${time6}d  ;;
Xget*)		wdir=$date4.${time6}g  ;;
Xverifytrue)	wdir=$date4.${time6}vm ;;
Xverify*)	wdir=$date4.${time6}vo ;;
Xfulltrue)	wdir=$date4.${time6}fm ;;
Xincrtrue)	wdir=$date4.${time6}im ;;
Xtincrtrue)	wdir=$date4.${time6}tm ;;
Xfull*)		wdir=$date4.${time6}fo ;;
Xincr*)		wdir=$date4.${time6}io ;;
Xtincr*)		wdir=$date4.${time6}to ;;
Xesac
Xcase "$parent" in
X'')	workdir=$hdir/$wdir ;;
X*)	workdir=$hdir/$parent/$wdir ;;
Xesac
X# make sure creation of $workdir succeeds, because if it doesn't the
X# filesystem is probably full, and we can end up with a truncated bkp.donot
X# among other disasters.
Xmkdir $workdir
Xif test $? -ne 0 ; then
X	echo "$pr: Could not make '$workdir'."
X	echo "$pr: The filesystem holding backup's home directory is probably full."
X	echo "$pr: Quitting."
X	exit 1
Xfi
Xcd $workdir
X
X## sample "df" outputs - needed if we're doing a backup
X#
X## normal BSD output
X# Filesystem            kbytes    used   avail capacity  Mounted on
X# /dev/xd0a              15720    4564    9584    32%    /
X#
X## System V output (including "/adj" multi-cpu concept from 3B4000 (bigbird))
X# /         (/dev/dsk/c0t7d0s0):        0 blocks    51134 i-nodes
X# /adj      (/dev/adj        ):    32568 blocks     4582 i-nodes
X# /proc     (/proc           ):        0 blocks      859 i-nodes
X# /adj/pe96/dev (/adj/pe96/dev/icfs):      179 blocks      413 i-nodes
X# /install/62 (/adj/pe96/dev/dsk/c0t4d0s0):   328800 blocks    61126 i-nodes
X#
X## AIX 2.2.1: output with "/native" NFS-ish concept.  Note 7 fields.
X# Device             Mounted on            total     free  used     ifree  used
X# /dev/hd0           /                     38684     8144   78%      9297    7%
X# /                  /native               38684     8144   78%      9297    7%
X#
X## AIX 3.1:  Note 7 fields but mountpoint is the last field as it should be.
X# Filesystem    Total KB    free %used   iused %iused Mounted on
X# /dev/hd4         40960    1128   97%    1245    12% /
X# /dev/hd2        376832   47336   87%    7852     8% /usr
X#
X## TI Sys V 3.2.1: Note *two* colons:
X#/                   (/dev/dsk/sys:root):           1726 blocks     2139 i-nodes
X#/pipe               (/dev/dsk/sys:pipe):            989 blocks      452 i-nodes
X#/usr                (/dev/dsk/sys:usr):            1357 blocks     5925 i-nodes
X#/install/62/supp    (/dev/dsk/dsk2:supp):         91011 blocks    36947 i-nodes
X#
X## IRIX 3.3.2: note /debug which is not a real filesystem
X# Filesystem                 Type  blocks     use   avail %use  Mounted on
X# /dev/root                   efs   31360   26001    5359  83%  /
X# /dev/usr                    efs 1860180 1132421  727759  61%  /usr
X# /debug                      dbg  143936   12344  131592   9%  /debug
X#
X## NonStop-UX 4.0 "df" doesn't show filesystem type so we have to look it
X## up in /etc/vfstab or use "df -n".
X## NonStop-UX 4.0 "df -k -l"
X# abalone 125# df -k -l
X# filesystem         kbytes   used     avail    capacity  mounted on
X# /dev/vol/root      65536    56069    9467     86%       /
X# /proc              0        0        0         0%       /proc
X# /dev/fd            0        0        0         0%       /dev/fd
X# /config            0        0        0         0%       /config
X# /dev/vol/usr       256000   195626   60374    76%       /usr
X# /dev/dsk/sc1d3s10  282933   149152   133781   53%       /install/64
X## NonStop-UX 4.0 "df -n"
X# abalone 126# df -n
X# /                  : vxfs
X# /proc              : proc
X# /dev/fd            : fdfs
X# /config            : cfs
X# /usr               : vxfs
X# /install/64        : ufs
X# abalone 127#
X## NonStop-UX 4.0 end of "df" outputs
X#
X## END of "df" sample outputs
X
X# if we are doing a backup of one or more filesystems, then
X# get df output and make sure our bkp.donot file excludes strange filesystems
X# else take care of a few other little things
Xcase $mode$fsbkp in
Xdevcheck*|get*|verify*)
X	: do nothing special
X;;
Xfullfalse)
X	if test ! -d $fs ; then
X		echo "$pr: $fs is not a directory.  Quitting."
X		exit 1
X	fi
X	devlist=$fs
X;;
X*false)
X	echo "$pr: Incrementals OK for filesystems only.  Quitting."
X	exit 1
X;;
Xfull*|incr*|tincr*)
X	## get list of valid filesystems for backup.
X	# see sample "df" outputs above
X	# We use "df" because its output is more similar across OS platforms
X	# than "mount" and Sys V mount doesn't always show the root filesystem.
X	# Unfortunately, df can hang waiting for info from an NFS filesystem.
X	# "df > $dft1 & ; sleep 5 ; ..." isn't a workaround because in that
X	# usage "df" won't put out any info until it completes.
X	# Oh, well, there's no good answer yet, except on some machines
X	# where "df" has a filesystem type key
X	if test "$OS_S" = NonStop-UX ; then
X		dfargs="-l"
X	elif test -n "$DFFSTYPE_K" -a -n "$LOCFSTYPE_S" ; then
X		dfargs="$DFFSTYPE_K $LOCFSTYPE_S"
X	else
X		dfargs=""
X	fi
X	df $dfargs | egrep '/dev/' > $dft1
X
X	# if we have SysV df output
X	if egrep '\):' $dft1 > /dev/null ; then
X		sed -e 's/(/ /' -e 's/):/ /' $dft1 | awk '{printf "%-16s %6d %s %6d %s %s\n",$2,$3,$4,$5,$6,$1}' > $dft2
X	# else if we're AIX 2.2.1
X	elif awk '{print $2}' $dft1 | grep / > /dev/null ; then
X		egrep '/dev/' $dft1                | awk '{printf "%-16s %6d %6d %4s %6d %4s %s\n",$1,$3,$4,$5,$6,$7,$2}' > $dft2
X	# else we're normal BSD or AIX 3.1
X	else
X		cp $dft1 $dft2
X	fi
X
X	# Some operating systems have filesystems we never want to back up
X	case "$OS_S$OSLEVEL_S" in
X	AIX2.2.1|IRIX3*|NonStop-UX4.0)
X		case "$OS_S$OSLEVEL_S" in
X		AIX2.2.1)	bumfs=/native ;;
X		IRIX3*)		bumfs=/debug ;;
X		NonStop-UX4.0)	bumfs=/config ;;
X		esac
X		if test ! -f $nobkp ; then
X			echo $bumfs > $nobkp
X		elif egrep $bumfs $nobkp > /dev/null ; then
X			: do nothing we are already protected
X		else
X			echo $bumfs >> $nobkp
X			sort -u -o $nobkp $nobkp
X		fi
X	;;
X	esac
X
X	## We have three filters for filesystems which we may not want
X	## to back up.  Two of them are config files, and the third we
X	## implement in code.
X	#
X	# filesystem filters:
X	# a) $nobkp, lists filesystems we never want to back up, and we make
X	#	sure it includes the following filesystems (see $bumfs above)
X	#	For AIX 2.2.1, don't back up /native (see above)
X	#	For IRIX 3.*, don't back up /debug
X	#	For NonStop-UX, don't back up /config
X	#	Otherwise, $nobkp is configured by the user
X	# b) $nofm, lists filesystems we never want to do full multivolume
X	# backups on (i.e. we don't do full alldisks with).  Typically
X	# this file might list 1Gig filesystems which we want to do
X	# seperate full onedisk backups on.
X	# c) don't backup /cdrom/unnamed_cdrom, /cdrom*, /export/swap, /proc,
X	# /tmp, or NFS filesystems
X	#
X	## We also may have some number of listfiles (e.g. bkp.list0) to check
X	## valid formats.  The format for the listfiles is the same as the
X	## filesystem filter files.
X	#
X	# NOTE:
X	# we must carefully delimit filesystem name for egrep, both here and
X	# in $nobkptmp.
X	# The regular expression must include '[<SPACE><TAB>]/fsname<DOLLAR>'
X	# This example would prevent backing up a /scratch filesystem:
X	# [ 	]/scratch$
X
X	# massage config file filesystem filters into $nobkptmp, if we
X	# have them and want to use them;
X	# also massage $listf into $listftmp if necessary
X	rm -f $nobkptmp $listftmp
X	case $mode$multi in
X	fulltrue)	fsfilters="$nobkp $nofm" ;;
X	*)		fsfilters="$nobkp" ;;
X	esac
X	case "$multitype" in
X	unlisted)
X		cd $hdir
X		listfiles=`echo bkp.list[0-9]*`
X		if test "$listfiles" != "bkp.list[0-9]*" ; then
X			# sed strips comments and blank lines in $listfiles
X			sed -e 's/[ 	]*\#.*//' -e '/^[ 	]*$/d' $listfiles > $workdir/bkp.listed
X			fsfilters="$fsfilters $workdir/bkp.listed"
X		fi
X		cd $workdir
X	;;
X	esac
X	for ff in $fsfilters $listf ; do
X		if test -f $ff ; then
X			## make sure $ff is in correct format
X			# assume leading blanks, trailing blanks, and blank
X			# lines are benign, and quietly fix them if present
X			sed -e 's/^[ 	]*//' -e 's/[ 	]*$//' -e '/^$/d' $ff > $ff.t
X			if test `wc -c < $ff.t` -lt `wc -c < $ff` ; then
X				mv $ff.t $ff
X			fi
X			# strip comments, then see if $ff.t1 has any
X			# real data left
X			sed -e 's/[ 	]*\#.*//' -e '/^[ 	]*$/d' $ff > $ff.t1
X			if test ! -s $ff.t1 ; then
X				case $ff in
X				*/bkp.donot|*/bkp.nofm)
X					echo "$pr: WARNING - '$ff' is empty or has only comments; please fix or remove; continuing ..." | tee -a $failrpt
X					continue
X				;;
X				*)
X					echo "$pr: Listfile '$ff' is empty.  Quitting." | tee -a $failrpt
X					exit 1
X				;;
X				esac
X			fi
X			# check for common mistakes: putting device name
X			# instead of mount point.
X			if egrep '^/(adj/.*)*dev/' $ff > /dev/null ; then
X				echo "$pr: '$ff' contains device names"
X				echo "$pr: instead of mount points.  Quitting."
X				exit 1
X			fi
X			## make sure $nobkptmp is in correct format, with a
X			# [<SPACE><TAB>]filesystemname<DOLLAR>	(for dump)
X			# [<SPACE><TAB>]directoryname<DOLLAR>	(for cpio)
X			sed -n -e 's,^\(/[a-zA-Z0-9_/\.\+-]*\)$,[ 	]\1$,p' $ff.t1 > $ff.t
X			nlinesorig=`wc -l < $ff.t1`
X			nlinestmp=` wc -l < $ff.t`
X			# if the number of lines in $ff.t1 and $ff.t
X			# are unequal, create failure report and quit.
X			if test $nlinesorig -eq $nlinestmp ; then
X				case $ff in
X				*/bkp.donot|*/bkp.nofm|*/bkp.listed)
X					cat $ff.t >> $nobkptmp
X				;;
X				*)
X					cat $ff.t >> $listftmp
X				;;
X				esac
X			else
X				exec 1> $failrpt
X				echo ""
X				echo "$pr: '$ff' is not in correct format."
X				echo "$pr: '$ff' must list one filesystem per line"
X				echo "$pr: (although comments beginning with '#' are OK)"
X				echo "$pr: Please fix '$ff'.  Quitting."
X				exec 1>&9
X				cat $failrpt
X				exit 1
X			fi
X			rm -f $ff.t1 $ff.t
X		fi
X	done
X
X	# strip unwanted filesystems, now that we have $nobkptmp
X	# "/adj/.*dev/" selects Sys V devices, e.g. /adj/pe96/dev/ on 3B4000's
X	# "/cdrom" is for SunOS's read only CDROM
X	# "/cdrom/unnamed_cdrom" is for Solaris's 2.2+ read only CDROM
X	# "/export/swap", "/proc", and "/tmp" are scratch so we don't care
X	#
X	# first egrep strips filesystems we never want
X	# "if" subshell strips any filesystems in $nobkptmp if it exists
X	# second egrep selects info on devices
X	egrep -v '[ 	]/(cdrom.*|export/swap|proc|tmp)$' $dft2 \
X	| if test ! -s $nobkptmp ; then
X		cat
X	else
X		# $egrepff, $egrepfi, $egrepfo, and $egrepfv for $EGREPF
X		egrepff=$nobkptmp
X		egrepfi=""
X		egrepfo=""
X		egrepfv="-v"
X		eval "$EGREPF"
X	fi \
X	| egrep '^/dev/|^/adj/.*dev/' > $dft3
X
X	# put /, /usr, and /var *first*
X	# (In alldisks versions before 3.00, / and /usr were last.)
X	# (From alldisks versions 3.00 thru 4.46, / and /usr were first.)
X	# (Since alldisks version 4.47, /, /usr, and /var are first.)
X	egrep    '[ 	]/$'			$dft3 >  $dfout
X	egrep    '[ 	]/usr$'			$dft3 >> $dfout
X	egrep    '[ 	]/var$'			$dft3 >> $dfout
X	egrep -v '[ 	](/|/usr|/var)$'	$dft3 >> $dfout
X
X	# select filesystems from $listf
X	if test -n "$listf" ; then
X		mv $dfout $dflocal
X		# $egrepff, $egrepfi, $egrepfo, and $egrepfv for $EGREPF
X		egrepff=$listftmp
X		egrepfi=$dflocal
X		egrepfo=$dfout
X		egrepfv=""
X		eval "$EGREPF"
X	fi
X
X	if test ! -s $dfout ; then
X		echo "$pr: '$dfout' is empty.  Something is wrong."
X		echo "$pr: Quitting."
X		exit 1
X	fi
X
X	## get list of actual filesystem devices - necessary because
X	## a) 4.1BSD dump matches 1st *similar* pattern, not real thing
X	## b) NCR SVR4 does not look up mount point in /etc/vfstab
X	# if $fs wasn't specified then we're doing an alldisks backup
X	if test -z "$fs" ; then
X		devlist=`awk '{print $1}' $dfout`
X	# else $fs was specified, so check its validity
X	else
X		# if $fs is in $dfout we're cool
X		devlist=`egrep "[ 	]$fs\$" $dfout | awk '{print $1}'`
X		if test -z "$devlist" ; then
X			# maybe $fs is in $nobkp (and hence in $dft2 but not $dfout)
X			devlist=`egrep "[ 	]$fs\$" $dft2 | awk '{print $1}'`
X			if test -n "$devlist" ; then
X				echo "$pr: Filesystem '$lhost:$fs' is not usually backed up."
X				eval "$EXITQ"
X			# else we really aren't a mounted filesystem
X			else
X				echo "$pr: Bad filesystem name '$fs'"
X				exit 1
X			fi
X		fi
X	fi
X;;
Xesac
X
Xecho "$pr: Your command looks AOK to me.  Thanks."
X
X# build local and remote commands (no dd command since we're using $bdd script)
Xcase $mhost in
X$lhost)	mlocal=true ;;		# the media is local
X*)	mlocal=false ;;		# the media is remote
Xesac
Xif test $mlocal = true ; then
X	cmp="cmp"
X	ls="ls"
X	mt="mt"
X	rm="rm"
X	tar="tar"
Xelif test -z "$rsh" ; then
X	echo "$pr: \$RSH_C is not set in /etc/saenv:"
X	grep '^RSH_C=' /etc/saenv
X	echo "$pr: Quitting."
X	exit 1
X# "date" output is same on BSD, SunOS, SysV, NCROS, UTS, AIX, Solaris, SVR4
X#elif test `$rsh $mhost date 2> /dev/null | wc -w` -ne 6 ; then
Xelif $rsh $mhost date > /dev/null 2>&1 ; then
X	cmp="$rsh $mhost cmp"
X	ls="$rsh $mhost ls"
X	mt="$rsh $mhost mt"
X	rm="$rsh $mhost rm"
X	tar="$rsh $mhost tar"
Xelse
X	echo "$pr: $rsh $mhost date"
X	$rsh $mhost date
X	echo "$pr: 'root' on $lhost does not have permission to run"
X	echo "$pr: remote shell commands at media host $mhost.  Check:"
X	echo "$pr: -> Make sure '$lhost root' is in /.rhosts on $mhost."
X	echo "$pr: -> Make sure '$lhost' has a valid entry in /etc/hosts on $mhost."
X	echo "$pr: Quitting."
X	exit
Xfi
X
X## make sure backup.dd script is usable
X# export environment variables needed by backup.dd
XMHOST=$mhost
XLHOST=$lhost
Xexport MHOST LHOST RSH_C
X# if we haven't tested it already, do so now
Xif test -z "$parent" ; then
X	eval $SHOWDD Make sure $bdd script is usable
X	echo "$pr: you should never see this" | $bdd of=/dev/null 2> err.dd
X	if test $? -ne 0 ; then
X		cat err.dd
X		echo "$pr: '$bdd' is not usable for some reason.  Quitting."
X		exit 1
X	fi
Xfi
Xrm -f err.dd
X
X# build mt command if mt exists
Xif test $mhost = $lhost ; then
X	mtkey="$MT_K"
Xelse
X	mtkey="`$rsh $mhost grep 'MT_K=' /etc/saenv | sed -n -e '/^MT_K=/s/^MT_K=\([^ 	]*\)[ 	].*/\1/p'`"
Xfi
Xcase "$mtkey" in
X'')	mt='' ;;		# mt command does not exist on media host
X*)	mt="$mt $mtkey" ;;	# mt command does exist on media host
Xesac
X
X## figure out which backup/get program(s) we're using
X# if the user specified cpio on the command line
Xif test "$bprog" = cpio ; then
X	restore=cpio
X# else if we're on Dynix Sequent using a video drive
Xelif test -n "$HDUMP_P" -a $mtype = video ; then
X	bprog=$HDUMP_P
X	restore=$RESTOR_P
X# else if we have BSD dump by some name
Xelif test -n "$DUMP_P" ; then
X	bprog=$DUMP_P
X	restore=$RESTOR_P
X# else we're using cpio
Xelse
X	bprog=cpio
X	restore=cpio
Xfi
Xif test $mhost != $lhost ; then
X	# set remote dump/restore if bprog is "dump"
X	case $bprog in
X	*dump*)
X		# set remote dump - warn and die if unavailable
X		case $bprog in
X		$HDUMP_P)	bprog=$HRDUMP_P ;;	# Dynix "hdump/hrdump"
X		*)		bprog=$RDUMP_P ;;	# normal "dump/rdump"
X		esac
X		if test -z "$bprog" ; then
X			echo "$pr: Remote dump unavailable on '$lhost' (see \$RDUMP_P in /etc/saenv)."
X			echo "$pr: Cannot do dumps over net from '$lhost'."
X			echo "$pr: Try 'cpio' option to do network cpio backups."
X			exit 1
X		fi
X		# set remote restore - warn and die if unavailable
X		if test -n "$RRESTOR_P" ; then
X			restore=$RRESTOR_P
X		else
X			echo "$pr: Remote restore unavailable on '$lhost' (see \$RRESTOR_P in /etc/saenv)."
X			echo "$pr: Cannot do restores over net from '$lhost'."
X			echo "$pr: Try 'cpio' option to do network cpio restores."
X			exit 1
X		fi
X	;;
X	esac
Xfi
X# header program
Xcase $bprog in
Xcpio)	headprog=cpio ;;	# header archive is cpio format
X*dump*)	headprog=tar ;;		# header archive is tar format
Xesac
X# lock out other cpio backups/gets/verifies, or lock if we're asked to
Xif test $bprog = cpio -o $optlk = true ; then
X	echo "$pr: LOCK: PID=$$, $workdir, $pr $cmdargs" > $lockf
Xfi
X# other initial stuff - if we're updating make sure we can
Xcase $update$bprog in
X*cpio)
X	# if this is a bad (but real) joke
X	if test $joke = true -a $mode != devcheck ; then
X		echo "$pr: We are using cpio - help!"
X		echo "$pr: Oh, I'm feeling sick ... "
X		echo $epre "$pr:   cough, "$esuf
X		sleep 1
X		echo $epre " choke . . . "$esuf
X		sleep 1
X		echo "gagghhhhh"
X		echo "$pr: (THUD)."
X		echo ''
X		sleep 2
X		echo "$pr: Bones: He's dead, Jim."
X		sleep 2
X		echo ''
X		echo "$pr: Spock: Correction - he's braindead."
X		echo ''
X		sleep 2
X		echo "$pr: Kirk: Well then, Bones, thanks to the miracle of"
X		echo "$pr: the alldisks script, we can still do the backup."
X		echo "$pr: Carry on."
X		echo ''
X	fi
X;;
Xtrue*dump*)
X	# make sure /etc/dumpdates exists
X	if test ! -f /etc/dumpdates ; then
X		echo "$pr: /etc/dumpdates does not exist, creating /etc/dumpdates."
X		echo "$pr: We do this because some versions of BSD dump abort if"
X		echo "$pr: /etc/dumpdates doesn't exist."
X		echo "$pr: This is probably the first time BSD dump has been used on $lhost."
X		touch /etc/dumpdates
X		echo "$pr: `ls -l$LSGROUP_K /etc/dumpdates`"
X		echo "$pr: We're OK now, continuing with the backup."
X	fi
X
X	# Make a feeble effort to make sure dump can read and write dumpdates.
X	# We test to see if the script can read and write dumpdates, and
X	# act accordingly.  However, that doesn't tell us what dump/rdump
X	# will do when we call it.  Unfortunately, this is the best we can do.
X	# Even using "dump W" to test readability won't reliably produce
X	# useful results, because under HP-UX 8.00 (and probably many other
X	# UNIXs), if "dump W" is called from a setuid root script, it can read
X	# /etc/dumpdates even if permissions are 000.
X	if test ! -r /etc/dumpdates -o ! -w /etc/dumpdates ; then
X		touch /etc/dumpdates
X		echo "$pr: `ls -l$LSGROUP_K /etc/dumpdates`" | tee -a $workdir/$report
X		echo chmod u+rw /etc/dumpdates | tee -a $workdir/$report
X		chmod u+rw /etc/dumpdates
X	fi
X	# quit if we weren't able to fix it
X	if test ! -r /etc/dumpdates -o ! -w /etc/dumpdates ; then
X		echo "$pr: `ls -l$LSGROUP_K /etc/dumpdates`" | tee -a $workdir/$report
X		echo "$pr: Cannot read/write /etc/dumpdates.  Quitting."
X		exit 1
X	fi
X
X	# HACK4HPUX8 is from $site; it may make dumpdates 664 group operator
X	eval "$HACK4HPUX8"
X;;
Xesac
X
X# now that $bprog and $restore are set, turn off actual backup work
X# for demonstrations
Xif test $demo = true ; then
X	bprog="echo $pr demo: $bprog"		# echo backup command
X	restore="echo $pr demo: $restore"	# echo get command
X	mt="echo $pr demo: $mt"			# echo mt command
X	# dd command is tricky, so tailor it wherever it is used
Xfi
X
X# decide whether we're using a file, dir, rewind device, norewind device
X# mdevbase wouldn't be needed if we were only supporting tape devices,
X# but since we're supporting alldisks to disk files, we'll be reasigning
X# mdev based on $mdevbase.
Xif   test $mtype = dir ; then
X	if   test $mode = get -o $mode = verify ; then
X		# a parent could be like either "0206.164423fm"
X		# or "0206.164423fm/0206.164448vm"
X		if test -n "$parent" ; then
X			# $parenttop is roughly the opposite of basename $parent
X			parenttop=`echo $parent | sed -e 's/\/.*//'`
X			mdevbase=$diskfile/$parenttop
X		# or we have no parent, and we assume the directory has
X		# files from only one backup
X		else
X			cd $diskfile
X			mdevbase=$diskfile/`echo [01][0-9][0123][0-9].*[a-z].[0-9][0-9] | sed -e 's/ .*$//' -e 's/\.[0-9][0-9]$//'`
X			cd $workdir
X		fi
X	else
X		mdevbase=$diskfile/$wdir
X	fi
Xelif test $mtype = file ; then
X	mdevbase=$diskfile
Xelif test $mode = get -o $mode = verify ; then
X	mdevbase=$rewdev
Xelif test "$multi" = false ; then
X	mdevbase=$rewdev
Xelse
X	mdevbase=$norewdev
Xfi
Xmdev=$mdevbase
X
X## deal with cpio/dump/restore keys and options
X# if the backup/get/verify program is cpio
Xcase $bprog in
Xcpio)
X	# check $maxocount
X	case $maxocount in
X	[1-9][0-9]*)
X		: do nothing
X	;;
X	*)
X		echo "$pr: Maximum output blocks for $mhost:$media in"
X		echo "$pr: $devdata is '$maxocount'.  Quitting."
X		exit 1
X	;;
X	esac
X	# get cpio key and cpio options
X	# Commercial UNIXs predetermine the output format, and we use
X	# the "c" portable header option key.
X	# Noncommercial UNIXs often use GNU cpio which has format choices.
X	# GNU cpio version 2.3 defaults to an old "bin" format which limits the
X	# largest inode number to 65534 (2**16) :-(  The "-Hnewc" specifies
X	# the new portable SVR4 header but conflicts with the "c" key.
X	# cphk means "cpio portable header key"
X	case $OS_S in
X	Linux)	cphk=''  ; cformat='-Hnewc' ;;
X	*)	cphk='c' ; cformat=''       ;;
X	esac
X	ckey="$cphk"
X	copt="$cformat"
X	for i in $bopts ; do
X		# see comments in the NOTES file about making
X		# "cpio ... | dd ... " work, given possible problems with
X		# cpio output block size, pipesize, dd's ibs and obs, and
X		# the device driver for the output device; also the size
X		# $RSH_C on both hosts can handle if were doing a backup
X		# over the net.
X		# $cpioobs	cpio's output blocksize
X		# $ckey		cpio key (ckey=C$obs || ckey=B)
X		# $obs		from $devdata
X		# based on pipesize from $SAHOST:$SABIN/getpipesize
X		case $i in
X		C)
X			ckey=${ckey}C$obs	# cpio block size is $obs
X			ibs=$obs		# easiest if they match
X		;;
X		DAT1|DAT2|E82|E85|QIC*|TK50|TK70)
X			continue		# this info for humans only
X		;;
X# TI Sys V can't read multiple cpio archives put on with their -T option
X#		T)
X#			ckey=${ckey}T		# write portable cpio archives on TI's
X#		;;
X		*)
X			if test $mistape = true ; then
X				echo "$pr: dump option '$i' in '$devdata' ignored."
X			fi
X		;;
X		esac
X	done
X	# if $ckey doesn't include "C" then
X	if echo "$ckey" | grep -v C > /dev/null ; then
X		ckey=B$ckey
X		ibs=5120		# make dd ibs match
X	fi
X;;
X# $bprog is BSD dump/restore (by some name)
X# we build the dump command line here.  It's also convenient to build
X# most (not all) of the restore key.  We'll need to finish the
X# job later if we're really doing a get, by asking the user whether
X# to do an interactive restore or to restore the entire dump.
X*dump*)
X	# set dump level
X	case $mode in
X	full)	dlevel=0 ;;
X	incr)	dlevel=$incr ;;
X	tincr)	dlevel=$test_incr ;;
X	esac
X	# if we're not supposed to update or we're dumping to the bit-bucket
X	if test $update != true -o $media = null ; then
X		updkey=		# don't update /etc/dumpdates
X	else
X		updkey=u	# update /etc/dumpdates
X	fi
X	# figure out restore opts key, restore opts, dump key, and dump opts
X	# we have to deal with DEC_OSF/1 strangeness here for roptkey, since the
X	# roptkey can't have an "f" in it because rrestore's command syntax is:
X	# /usr/sbin/rrestore -f host:/device -$rmode$roptkey $ropts
X	# According to the manual page DEC_OSF/1 doesn't mess with the
X	# syntax for local restore's, but this works too:
X	# /usr/sbin/restore  -f      /device -$rmode$roptkey $ropts
X	case "$OS_S" in
X	DEC_OSF/1)	roptkey='' ;;
X	*)		roptkey=f  ;;
X	esac
X	dkey=$dlevel${updkey}f
X	dopts=''			# dump options based on $dkey and $bopts
X	d2mtype=''			# DG dump2's media type option
X	d2stats=''			# DG dump2's statistics report option
X
X	# modify the keys according to dump/restore options, if any
X	for i in $bopts ; do
X		case $i in
X		# "-d" (density in BPI)
X		# 1600, 3200 and 6250 for 9tracks
X		# 6670 for tk50's
X		# ???? for tk70's
X		# 1000 for QIC11/QIC24/QIC150 carts,
X		# 23000 for MIPS 120M carts
X		# 141000 for auspex 8500 exabytes
X		1000|1600|3200|6250|6670|23000|141000)
X			dkey=${dkey}d
X		;;
X		# "-t" (tracks: cartridge only)
X		# 4 for QIC11, 9 for QIC24, 18 for QIC150
X		4|9|18)
X			dkey=${dkey}t
X		;;
X		# "-b" (blocking factor: either 512 characters or
X		# 1024 characters per tape block depending on the OS)
X		# 126 for videos on suns, 346 for video on DYNIX,
X		# 100 for auspex 8500 exabytes,
X		# else any even two-digit number
X		100|126|346|[1-9][02468])
X			dkey=${dkey}$DRB_K		# tapeblock size ...
X			roptkey=${roptkey}$DRB_K	#     was specified ...
X			if test -n "$DRB_K" ; then
X				ropts="$ropts $i"	#             and is $i
X			else
X				echo "$pr: Blocksize '$i' in $devdata"
X				echo "$pf: ignored, because this OS does not support it."
X			fi
X		;;
X		# "-s" (size in feet)
X		# 11500 for auspex 8500 exabytes
X		# 70000 for dats
X		# 165000 for Exabyte 8200s
X		# 330000 for Exabyte 8500s
X		# any other three- or four-digit number ending in "00" or "25"
X		# (see $mdev for why)
X		11500|70000|165000|330000|[1-9][02][05]|[1-9][0-9][02][05])
X			dkey=${dkey}s		# size was specified
X		;;
X		# "c" for Sun cartridge drives
X		# "C" for Bull cartridge drives
X		c|C)
X			# only need to change dump key not restore key for suns
X			dkey=${dkey}$i		# cart was specified (suns)
X			continue		# so $i isn't put in $dopts
X		;;
X		M)
X			d2mtype="$i $mtype"	# dump2's mediatype key and arg
X			continue		# so $i isn't put in $dopts
X		;;
X		s)
X			d2stats=s		# dump2's statistics key
X			continue		# so $i isn't put in $dopts
X		;;
X		DAT1|DAT2|E82|E85|QIC*|TK50|TK70)
X			continue		# this info for humans only
X		;;
X		*)
X			echo "$pr: I do not understand $bprog option '$i' in '$devdata'"
X			echo "$pr: Quitting."
X			exit 1
X		;;
X		esac
X		dopts="$dopts $i"
X	done
X
X	# Dec's OSF/1 version of dump/rdump automatically ejects the tape
X	# after the dump is done, unless you put the "N" in the dump key.
X	case "$OS_S" in
X	DEC_OSF/1)	dkey=${dkey}N ;;
X	esac
X
X	# build backup command for local vs. remote media
X	# $DRMINUS is for Bull OS, ICL, and other weirdos
X	# dump2 code is for DG's dump2
X	case $bprog in
X	*dump2)
X		test -n "$opfifo"  && d2opts="$d2opts $DRMINUS$opfifo"
X		test -n "$d2mtype" && d2opts="$d2opts $DRMINUS$d2mtype"
X		test -n "$d2stats" && d2opts="$d2opts $DRMINUS$d2stats"
X	;;
X	*)
X		if test -n "$opfifo$d2mtype$d2stats" ; then
X			echo "$pr: Data General 'dump2' arguments '$opfifo$d2mtype$d2stats' in '$devdata'"
X			echo "$pr: do not work on non-DG machines.  Quitting."
X			exit 1
X		fi
X	;;
X	esac
X	case $mhost$diskfile in
X	$lhost-)
X		# the "sleep" is to give the shell time to open b.$fsnn.out
X		bcmd='$bprog $DRMINUS$dkey        $mdev $dopts $d2opts $fsdev 1>&8 2> b.$fsnn.out & bpid=$! ; sleep 2 ; tail -f b.$fsnn.out & tailpid=$!'
X	;;
X	*-)
X		echo "$pr: Cannot dump to standard out on remote host."
X		exit 1
X	;;
X	$lhost*)
X		bcmd='$bprog $DRMINUS$dkey        $mdev $dopts $d2opts $fsdev 2>&1 | tee -i b.$fsnn.out'
X	;;
X	*)
X		bcmd='$bprog $DRMINUS$dkey $mhost:$mdev $dopts $d2opts $fsdev 2>&1 | tee -i b.$fsnn.out'
X	;;
X	esac
X;;
Xesac
X
X###############################################################################
X## Device testing
X## if $demo is false, $check is true, and $mtype isn't dir, file or null ; then
X##	case $mode in
X##	get|verify)
X##		verify read of rewind device
X##	;;
X##	full|incr|tincr|devcheck)
X##		verify write to rewind *and* norewind devices
X##	;;
X##	esac
X## endif
X## The actual test code is written to avoid indenting more than one level
X
X## First, make sure rewind and norewind devices are block/character
SHAR_EOF
true || echo 'restore of src/backup/backup failed'
fi
echo 'End of saenv5.01 part 5'
echo 'File src/backup/backup is continued in part 6'
echo 6 > _shar_seq_.tmp
exit 0
