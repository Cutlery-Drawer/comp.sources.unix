Newsgroups: comp.sources.unix
From: rca@queernet.org (Bob Arnold)
Subject: v28i152: saenv-5.01 - SysAd Environment (OS_Research/Backup) Suite, Part06/07
References: <1.784011877.15815@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: rca@queernet.org (Bob Arnold)
Posting-Number: Volume 28, Issue 152
Archive-Name: saenv-5.01/part06

#!/bin/sh
# this is saenv.06 (part 6 of saenv5.01)
# do not concatenate these parts, unpack them in order with /bin/sh
# file src/backup/backup continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 6; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping src/backup/backup'
else
echo 'x - continuing file src/backup/backup'
sed 's/^X//' << 'SHAR_EOF' >> 'src/backup/backup' &&
X## special files (trust symlinks).
X## (But don't do it if $mtype is dir or file.)
X# The "ls -l" writes to standard error if $rewdev doesn't exist,
X# so "wc -l" gives 0.  This trickiness is needed because we may be
X# dealing with a remote machine.  Remote shell (rsh) reports success
X# if it had permission to run a command on the remote box, and doesn't
X# care if the command itself works or not.  Also, we assume symbolic
X# links are cool because it's really hard to verify them, especially on
X# remote boxes.  That's why we egrep for '^[bcl]'.
Xif test $mtype != dir -a $mtype != file -a `$ls -l   $rewdev | egrep -c '^[bcl]'` -ne 1 ; then
X	badrewdev=true
X	echo "$pr: No device node for rewind device '$rewdev'"     >> $failrpt
Xfi
Xif test $mtype != dir -a $mtype != file -a `$ls -l $norewdev | egrep -c '^[bcl]'` -ne 1 ; then
X	badnorewdev=true
X	echo "$pr: No device node for norewind device '$norewdev'" >> $failrpt
Xfi
Xif test "$badrewdev" = true -o "$badnorewdev" = true ; then
X	echo "$pr: Media data file '$devdata' is wrong." >> $failrpt
X	echo "$pr: Notify a UNIX System Administrator IMMEDIATELY ! ! !" >> $failrpt
X	cat $failrpt
X	exit 1
Xfi
X
X## Second, set up media test block sizes and test files on the media host.
X## Do before all real media tests.
Xcase $bprog$multi in
Xcpio*)
X	mtestibs=10b	# header file is cpio, backup is cpio
X;;
X*dump*true)
X	mtestibs=20b	# header file is tar
X;;
X*dump*)
X	mtestibs=63k	# backup is dump, so choose max dump blocksize
X	# deal here with special weird mtestibs requirements:
X	# Bull's B.O.S. can't read more than 60k from a cart
X	# DYNIX and DYNIX/ptx can't read more than 32k from "xt" devices;
X	# we could get down to that level, but this ought to be good enough.
X	case "$OS_S" in
X	B.O.S.)			mtestibs=60k ;;
X	DYNIX|DYNIX/ptx)	mtestibs=32k ;;
X	esac
X;;
Xesac
X# For media test files, we can't just use /etc/passwd and /etc/group
X# because the test files must be modulus 512 in size for cartridge drives
X# (a hardware limitation).  We also need test files to be modulus 10k for
X# some video units (we don't know why, but 1k is too small).  On the
X# other hand 5k is the max on AT&T 3B5 (coyote), maybe because its
X# pipesize is so strange (6144 characters).  So, we create the first and
X# second test files on the fly.  All media test files should be in a
X# world writeable directory, not $workdir, because we may have to create
X# it on a remote machine.
X#
X# We need test files for rewind/norewind device testing and also for
X# tape testing for cpio backups.
Xcase $mode in
Xdevcheck|full|incr|tincr)
X	eval $SHOWDD Create two test files
X	echo "script: '$pr', mtestf1 '$mtestf1'; workdir '$lhost:$workdir'" \
X	| $bdd of=$mtestf1 bs=$mtestobs conv=sync 2> /dev/null
X	echo "script: '$pr', mtestf2 '$mtestf2'; workdir '$lhost:$workdir'" \
X	| $bdd of=$mtestf2 bs=$mtestobs conv=sync 2> /dev/null
X;;
Xesac
X
X## Third, if we're doing a get/verify, make sure we can read the rewind device
X## (But check other stuff if $mtype is dir or file)
Xwhile test $demo = false -a $check = true -a \( $mode = get -o $mode = verify \) -a $mtype != null ; do
X	# if we're reading from file or directory, we have simple tests;
X	# if it's null we don't do anything
X	case "$mtype" in
X	dir)
X		if test ! -d $diskfile ; then
X			if test $? -ne 0 ; then
X				echo "$pr: Cannot read $mtype $diskfile.  Quitting."
X				exit 1
X			fi
X		fi
X	;;
X	file)
X		if test ! -f $diskfile ; then
X			if test $? -ne 0 ; then
X				echo "$pr: Cannot read $mtype $diskfile.  Quitting."
X				exit 1
X			fi
X		fi
X	;;
X	esac
X	if test -z "$parent" -a $mtype != file -a $mtype != dir ; then
X		eval $SHOWDD Make sure we can read the rewind device
X		$bdd if=$rewdev of=/dev/null count=1 bs=$mtestibs 2> err.dd
X		if test $? -eq 0 ; then
X			rm -f err.dd
X		else
X			cat err.dd
X			eval "$CHKMREAD"
X			eval "$EXITQ"
X			continue
X		fi
X	fi
X	break
Xdone
X
X## Fourth, if we're making a backup or doing a devcheck, we check both
X## the rewind and norewind device names from $devdata.  This is so important
X## that we do it whether or not we'll end up using the norewind device.
X## (But check other stuff if $mtype is dir, file, or null)
X#
X# Later on, if it's a cart and we're using cpio, we'll need to test the
X# cart to make sure that we can write large amounts of data to it.
X# Oddly enough, low density (low "ftpi" (frame tracks per inch)) carts
X# work with high density drives if we're only writing a block or two.
X# This is strange, but I've tested it pretty extensively in 150M and
X# 120M cartridge drives using carts of 8000, 10000, and 12500 ftpi.
X# We only have to worry about this if it's cpio because BSD dump takes
X# care of this kind of problem for us.
X#
X# We only intend to do this code once, but we have to use a "while"
X# so we can "break" out of it if $rewdev is wrong.
Xwhile test $demo = false -a $check = true -a \( $mode = full -o $mode = incr -o $mode = tincr -o $mode = devcheck \) ; do
X
X	# if we're writing to a file or directory, we have simple tests;
X	# if it's null we don't do anything
X	case "$mtype" in
X	dir)
X		if test ! -d $diskfile ; then
X			mkdir $diskfile
X			if test $? -ne 0 ; then
X				echo "$pr: Cannot create $mtype $diskfile.  Quitting."
X				exit 1
X			fi
X		fi
X		break
X	;;
X	file)
X		if test $diskfile != "-" -a ! -f $diskfile ; then
X			echo "$pr: can we create $diskfile" > $diskfile
X			if test $? -ne 0 ; then
X				echo "$pr: Cannot create $mtype $diskfile.  Quitting."
X				exit 1
X			fi
X		fi
X		break
X	;;
X	null)
X		break
X	;;
X	esac
X
X	## First, make sure we can write to the rewind device - the operator may
X	## have forgotten to put the drive on line or left off the write ring.
X	$rm -f $mtestf3			# just to make sure
X	while : ; do
X		# write 1st file, rewind media
X		eval $SHOWDD Make sure we can write to the rewind device
X		$bdd if=$mtestf1 of=$rewdev bs=$mtestobs 2> err.dd
X		bddstat=$?
X		recout=`   egrep records err.dd | awk     'NR == 2 {print $1}'`
X		if test $bddstat -eq 0 -a "$recout" = "1+0" ; then
X			rm -f err.dd
X			break
X		else
X			cat err.dd
X			eval "$CHKMWRITE"
X			eval "$EXITQ"
X		fi
X	done
X
X	## Second, make sure the rewind device name is really a rewind device.
X	# Write 1st file, rewind media, then read it back out.  The count=40
X	# prevents humungous read from accidental norewind device, which
X	# could mean writing to and possibly filling up the filesystem
X	# containing $mtestf3.
X	eval $SHOWDD Make sure rewind device name really does a rewind
X	$bdd if=$mtestf1 of=$rewdev   bs=$mtestobs          2> /dev/null
X	$bdd if=$rewdev  of=$mtestf3  bs=$mtestobs count=40 2> err.dd
X	bddstat=$?
X	recin=`   egrep records err.dd | awk     'NR == 1 {print $1}'`
X	# if we got a bad read from the media
X	if test $bddstat -ne 0 -o "$recin" != "1+0" ; then
X
X		exec 1> $failrpt
X		echo "$pr: Expected '$bdd' status '0'; got status '$bddstat'."
X		echo "$pr: Expected '1+0 records in/out'; got:"
X		cat err.dd
X		echo "$pr: This may be a real HARDWARE problem."
X		exec 1>&9
X		cat $failrpt
X		eval "$CHKMREAD"
X		echo "$pr: Quitting."
X		exit 1
X	fi
X	rm -f err.dd
X	# input should be identical to output
X	if test `$cmp $mtestf1 $mtestf3 2>&1 | wc -l` -gt 0 ; then
X		badrewdev=true
X		$cmp $mtestf1 $mtestf3 >> $failrpt
X		echo "$pr: '$mhost:$rewdev' is supposed to be a rewind device but is NOT." >> $failrpt
X		break	# can't reliably test the norewind device now
X	fi
X
X	## Third and last, verify the norewind device is a norewind device.
X	# The structure here is OK since we just verified the rewind device.
X	# put first file on media, don't rewind
X	# put different file on media, rewind it
X	# read first file back out, rewind media
X	eval $SHOWDD Make sure norewind device name really does not rewind
X	$bdd if=$mtestf1 of=$norewdev bs=$mtestobs          2> /dev/null
X	$bdd if=$mtestf2 of=$rewdev   bs=$mtestobs          2> /dev/null
X	$bdd if=$rewdev  of=$mtestf3  bs=$mtestobs          2> /dev/null
X	# input should be identical to output
X	if test `$cmp $mtestf1 $mtestf3 2>&1 | wc -l` -gt 0 ; then
X		badnorewdev=true
X		$cmp $mtestf1 $mtestf3 >> $failrpt
X		# check for possible reasons
X		if test `$cmp $mtestf2 $mtestf3 2>&1 | wc -l` -eq 0 ; then
X			echo "$pr: GACK! The so-called norewind device actually rewinds the $media!" >> $failrpt
X		fi
X		echo "$pr: '$mhost:$norewdev' is supposed to be a norewind device but is NOT." >> $failrpt
X	fi
X
X	break	# defense! we only want to do this code once.
Xdone
X
X## Fifth - evaluate and report results of device testing
X# (note: keep media test files for later)
Xif test "$badrewdev" = true -o "$badnorewdev" = true ; then
X	echo "$pr: Media data file '$devdata' is wrong." >> $failrpt
X	echo "$pr: Notify a UNIX System Administrator IMMEDIATELY ! ! !" >> $failrpt
X	cat $failrpt
X	exit 1
Xfi
X
X## Sixth and last - clean up and quit if we were asked only to check the media
Xcase $mode in
Xdevcheck)
X	echo "$pr devcheck: The rewind device:   '$rewdev' and"
X	echo "$pr devcheck: the norewind device: '$norewdev'"
X	echo "$pr devcheck: on media host $mhost PASS the devcheck tests."
X	exit 0
X;;
Xesac
X
X###############################################################################
X
X## start the report
Xcd $workdir
Xexec 1> $report
Xecho "#Invocation: $pr $cmdargs"
Xecho "#Version:    $version"
Xecho "#Start time: $date"
Xecho "#Workdir:    $wdir"
Xecho "#Dev Data:   $devdata"
Xecho "#lhost	mhost	mode	media	mdevbase	multi	OPER	voln	hfstat"
X# print variables (note $hfstat isn't set since the header file hasn't
X# been put on the media yet)
Xecho "$lhost	$mhost	$mode	$media	$mdevbase	$multi	$OPER	$voln	${hfstat-NA}"
Xexec 1>&9
X
X## OK!  Ready to *make* the backup or *get/verify* files from the backup!
Xcase $mode in
Xfull|incr|tincr)
X
X	# show operator our assumptions
X	echo ""
X	echo $pr:
X	echo "backup	media	media			media		backup"
X	echo "level	host	alias	workdir		device		program"
X	echo "-------	-------	-------	-------------	---------------	-----------"
X	echo "$mode	$mhost	$media	$wdir	$mdevbase	$bprog"
X	echo ""
X	echo "$pr: About to backup:"
X	case $multi$fsbkp in
X	*false)	echo "$devlist	(directory, not a filesystem)" ;;
X	true*)	awk '			{print $1 "	(" $NF ")" }' $dfout ;;
X	*)	awk '$1 == "'$devlist'"	{print $1 "	(" $NF ")" }' $dfout ;;
X	esac
X	echo ""
X
X	# later on, if we're doing a cpio onedisk backup to a cart, we'll
X	# need this $mtestf4 for every cart
X	if test $bprog = cpio -a $mdev = $rewdev -a $mtype = cart ; then
X		# create 150k test file - do it in 50k
X		# chunks because many machines can't
X		# do it all at once
X		eval $SHOWDD Create 150k test file for carts
X		echo "$pr: $workdir 150k $mtestf4" | $bdd of=$mtestf4 bs=50k conv=sync        2> err.dd
X		echo "$pr: $workdir 150k $mtestf4" | $bdd of=$mtestf4 bs=50k conv=sync seek=1 2> err.dd
X		echo "$pr: $workdir 150k $mtestf4" | $bdd of=$mtestf4 bs=50k conv=sync seek=2 2> err.dd
X		# show user if it's not 150k
X		$ls -l $mtestf4 | grep -v ' 153600 '
X	fi
X
X	## do the backup
X	fsnn=00			# 2-digit filesystem number
X	# put the list of known problems into $problist and
X	# list of known not_problems into $falseprob for later check
X	echo "$KNOWNPROBS" > $problist
X	echo "$KNOWNFALSEPROBS" > $falseprob
X	# start the exit status list
X	echo '#bstat	devname		fsname	known_errors' > $statlist
X	# if multi-volume backup or it's a onedisk but we're putting on a
X	# header anyway, put tar/cpio header file onto media;
X	# the header is tar if we're using dump, cpio if we're using cpio;
X	# the header includes $dfout, $report, all scripts, and any/all
X	# config files ($hdir/bkp.media overrides $DTGT/bkp.media)
X	#if test $multi = true -o $header = true ; then
X	if test $multi = true ; then
X		# put required files in $workdir
X		# we must make sure we have local paths, not absolute paths
X		x="$dfout $report $pr `basename $bdd` bkp.media"
X		ln ../$pr .
X		cp $bdd   .
X		cp $devdata bkp.media
X		case "$multitype" in
X		list)
X			# so we always have the standard name 'bkp.listf'
X			bnlistf=`basename $listf`
X			cp $listf $bnlistf
X			ln $bnlistf bkp.listf
X		;;
X		esac
X		cp    ../bkp.donot . 2> /dev/null && x="$x bkp.donot"
X		cp    ../bkp.host  . 2> /dev/null && x="$x bkp.host"
X		test -f  bkp.listed               && x="$x bkp.listed"
X		test -f  bkp.listf                && x="$x bkp.listf"
X		cp    ../bkp.media . 2> /dev/null && x="$x bkp.media"
X		cp    ../bkp.nofm  . 2> /dev/null && x="$x bkp.nofm"
X		cp $DTGT/bkp.site  . 2> /dev/null && x="$x bkp.site" 
X		test -n "$bnlistf"                && x="$x $bnlistf"
X		# added because NonStop-UX and other OS have multiple
X		# filesystem types and it's often documented in these files
X		for f in $fstablist ; do
X			cp /etc/$f . 2> /dev/null && x="$x $f"
X		done
X		headlist="$x"
X		if test $bprog = cpio ; then
X			echo "$pr: ================================backup>>> alldisks_header (cpio)"
X		else
X			echo "$pr: ================================backup>>> alldisks_header (tar)"
X		fi
X		# make absolutely sure the header gets on the media - don't
X		# continue until it does
X
X		eval "$MDEV"
X		while : ; do
X			# each case has 3 lines
X			#	1) echo commented command line to $report
X			#	2) echo command line to screen
X			#	3) do or "demo" the command (prettified by ";:")
X			eval $SHOWDD Put alldisks header on $mhost:$media using $bdd
X			case $bprog$demo in
X			cpiotrue)
X				echo         \#find $headlist -print "| { cpio -o$ckey $copt" '2> err.head ; echo $? > stat.head ; } | {' $bdd of=$mdev obs=5k  2> err.dd '; echo $? > stat.dd ; }' >> $report
X				echo           find $headlist -print "| { cpio -o$ckey $copt" '2> err.head ; echo $? > stat.head ; } | {' $bdd of=$mdev obs=5k  2> err.dd '; echo $? > stat.dd ; }'
X				echo $pr: demo find $headlist -print "| { cpio -o$ckey $copt" '2> err.head ; echo $? > stat.head ; } | {' $bdd of=$mdev obs=5k  2> err.dd '; echo $? > stat.dd ; }'
X			;;
X			cpio*)
X				echo         \#find $headlist -print "| { cpio -o$ckey $copt" '2> err.head ; echo $? > stat.head ; } | {' $bdd of=$mdev obs=5k  2> err.dd '; echo $? > stat.dd ; }' >> $report
X				echo           find $headlist -print "| { cpio -o$ckey $copt" '2> err.head ; echo $? > stat.head ; } | {' $bdd of=$mdev obs=5k  2> err.dd '; echo $? > stat.dd ; }'
X				: ;            find $headlist -print  | { cpio -o$ckey $copt   2> err.head ; echo $? > stat.head ; } | {  $bdd of=$mdev obs=5k  2> err.dd  ; echo $? > stat.dd ; }
X			;;
X			*dump*true)
X				echo         \#\{ tar cfb - 20 $headlist 2> err.head '; echo $? > stat.head ; }               | {' $bdd of=$mdev obs=10k 2> err.dd '; echo $? > stat.dd ; }' >> $report
X				echo           \{ tar cfb - 20 $headlist 2> err.head '; echo $? > stat.head ; }               | {' $bdd of=$mdev obs=10k 2> err.dd '; echo $? > stat.dd ; }'
X				echo $pr: demo \{ tar cfb - 20 $headlist 2> err.head '; echo $? > stat.head ; }               | {' $bdd of=$mdev obs=10k 2> err.dd '; echo $? > stat.dd ; }'
X			;;
X			*dump*)
X				echo         \#\{ tar cfb $tarhead 20 $headlist 2> err.head '; echo $? > stat.head ; }               ; {' cat $tarhead | $bdd of=$mdev obs=10k 2> err.dd '; echo $? > stat.dd ; }' >> $report
X				echo           \{ tar cfb $tarhead 20 $headlist 2> err.head '; echo $? > stat.head ; }               ; {' cat $tarhead | $bdd of=$mdev obs=10k 2> err.dd '; echo $? > stat.dd ; }'
X				: ;             { tar cfb $tarhead 20 $headlist 2> err.head  ; echo $? > stat.head ; }               ; {  cat $tarhead | $bdd of=$mdev obs=10k 2> err.dd  ; echo $? > stat.dd ; }
X#				{ tar cfb $tarfile 20 $headlist 2> err.head  ; echo $? > stat.head ; }               ; {  $bdd if=$tarfile of=$mdev obs=20b 2> err.dd  ; echo $? > stat.dd ; }
X			;;
X			esac
X			cat err.head err.dd | tee -a $report
X			hfstat=`cat stat.head``cat stat.dd`
X			# if the disk holding $bhdir fills up, $hfstat could
X			# be a null string, and "sh" treats a null string
X			# as numerically equal to zero, so test carefully
X			if test -z "$hfstat" ; then
X				echo "$pr: The disk holding $bhdir"
X				echo "$pr: is probably full."
X				df $bhdir	# works on most newer UNIX's
X				echo "$pr: Please consult a UNIX sysadmin."
X				echo "$pr: Quitting."
X				exit 1
X			# else if $hfstat is "00" we are ok
X			elif test "$hfstat" -eq 0 ; then
X				break
X			# else we've got a problem
X			else
X				echo "$pr: Something went wrong with putting the $headprog header archive"
X				echo "$pr: on the $media.  Check:"
X				eval "$CHKMWRITE"
X				eval "$EXITQ"
X			fi
X		done
X	fi
X
X	# put backups on tape, and keep track of which filesystems are on
X	# which tapes
X	voln=1			# volume number of cart/dat/tape/tk/video
X	sumrecin=0		# sum of dd output records for cpio archives
X	obleft=$maxocount	# number of output blocks left on media
X	nearend=false		# are we so near the end of the media that
X				# we have to change tapes
X	echo $sumrecin $obleft > $pass	# initialize $pass
X	/bin/rm -f $firstblist
X	for fsdev in $devlist ; do
X		eval "$FSNNPLUS1"
X		eval "$MDEV"
X		case $fsbkp in
X		# occasionally we back up a directory
X		false)
X			fs=$fsdev
X		;;
X		# but normally we're backing up a filesystem
X		*)
X			# get $fs from $dft2 - if we're backing up a filesystem
X			# listed in $nobkp, $fs will be in $dft2 but not $dfout
X			fs=`egrep "^$fsdev[ 	]" $dft2 | awk '{print $NF}'`
X		;;
X		esac
X		echo "$pr: ================================backup>>> $fs"
X
X		# if we're using some version of dump
X		case $bprog in
X		*dump*)
X			# special code for  NonStop-UX4.0 which has both
X			# vxfs and ufs filesystem types: choose which dump
X			# to use ufsdump or vxdump.
X			case "$OS_S$OSLEVEL_S" in
X			NonStop-UX4.0)
X				fstype=`awk '/^#/ {next} ; $3 == "'$fs'" {print $4}' /etc/vfstab`
X				case $fstype in
X				ufs)	bprog=$DUMP_P ;;
X				vxfs)	bprog=/sbin/vxdump ;;
X				esac
X			;;
X			esac
X			# echo the backup command - trickier than you'd think!!
X			# we need the x=`echo ...` to get the desired evaluation
X			# the first sed expression compresses whitespace to one
X			# space, the second one puts a backquote in front
X			# of every single shell-special character we might see
X			# in $bcmd, the third puts single quotes around $! in
X			# case we are dumping to standard out
X			x=`echo $bcmd | sed -e 's/[ 	][ 	]*/ /g' -e 's/[&;|>]/\\\\&/g' -e "s/\$\!/'\$\!'/"`
X			eval echo "$pr: $x"
X			eval echo "\#bcmd: $x" \>\> $report
X 
X			# if we're rdumping to a disk file on another host
X			# then make sure it exists, since SunOS, Solaris,
X			# and perhaps other rdump's seem to require the
X			# file to exist before it can open the file for
X			# writing the dump archive.
X			case $bprog$mtype in
X			*dump*file|*dump*dir)
X				if test $mhost != $lhost ; then
X					$rsh $mhost touch $mdev
X				fi
X			;;
X			esac
X
X			# now do it for real (but sync twice first just in case)
X			sync ; sync
X			# if we were dumping to a tape or diskfile
X			if test -z "$diskfile" -o "$diskfile" != "-" ; then
X				eval $bcmd		# do dump in forground
X				eval bstat$fsnn=$?	# get exit status
X			# else we're dumping to standard out
X			else
X				eval $bcmd		# do dump in background
X				wait $bpid		# wait for it
X				eval bstat$fsnn=$?	# exit status from wait
X				echo $epre "$pr: Killing 'tail' on b.$fsnn.out: "$esuf
X				kill -9 $tailpid 2> /dev/null	# kill tail
X			fi
X			# If we couldn't read/write dumpdates, then fix,
X			# report, and break out of filesystem loop.  If
X			# it happened when trying to update dumpdates,
X			# this is the best we can do because dump has
X			# already written the entire archive before
X			# trying the update.  We might handle this earlier
X			# with $HACK4HPUX8, but probably not.
X			updateprob=`egrep '/etc/dumpdates: Permission denied' b.$fsnn.out`
X			if test -n "$updateprob" ; then
X				echo "$pr: There were permissions problems reading or writing /etc/dumpdates."
X				echo "$pr: Permissions were (using 'ls -l /etc/dumpdates'):"
X				echo "$pr: `ls -l$LSGROUP_K /etc/dumpdates`" | tee -a $workdir/$report
X				chmod 664 /etc/dumpdates
X				chgrp operator /etc/dumpdates
X				echo "$pr: Fixed permissions are now:"
X				echo "$pr: `ls -l$LSGROUP_K /etc/dumpdates`" | tee -a $workdir/$report
X				echo "$pr: Try the backup again - it should work next time."
X				# break out of loop so we can do postprocessing
X				break
X			fi
X			# If we couldn't read the actual device we're dumping,
X			# then fix and try the dump again.  This strategy works
X			# because we know dump hasn't moved the tape.
X			permprob=`egrep '[cC]annot open' b.$fsnn.out`
X			if test -n "$permprob" ; then
X				# actual device dumped is often raw device, but
X				# can be block device under some configurations
X				# like DGUX with disk-spanning filesystems
X				actualdev=`echo $permprob | awk '{print $NF}'`
X				if test -n "`echo $actualdev | egrep '^/dev/[-a-zA-Z0-9_:/]*$'`" ; then
X					echo "$pr: NOTE: There were permissions problems reading the actual device."
X					echo "$pr: Permissions were (using 'ls -l$LSGROUP_K $actualdev'):"
X					echo "$pr: `ls -l$LSGROUP_K $actualdev`" | tee -a $workdir/$report
X					chgrp operator $actualdev
X					chmod g+r $actualdev
X					echo "$pr: Fixed permissions are now:"
X					echo "$pr: `ls -l$LSGROUP_K $actualdev`" | tee -a $workdir/$report
X					echo "$pr: Trying the dump again."
X					mv b.$fsnn.out b.$fsnn.out.prob
X					sync ; sync
X					eval $bcmd
X					eval bstat$fsnn=$?
X				fi
X			fi
X		# else we're using cpio - much trickier than dump/rdump
X		;;
X		cpio)
X			# There's a ton of stuff to do here as a frontend
X			# to cpio.  As much as possible, we basically have
X			# to do everything that BSD dump does.
X
X			## The first BIG problem is to generate a list of files
X			# for $fs *only*.  This list has to exclude any
X			# filesystem mounted on top of the one we're backing
X			# up, e.g. we exclude "/usr" if we're backing up "/".
X			# We also exclude anything in $nobkp if it exists.
X			# Once the list is generated we can basically do:
X			# "cd $fs ; find $top $stayinfs $newer | fgrep -v -f $filter"
X			# This requires adding a leading "X" and trailing "/" in
X			# each dir/fs name.
X
X			# First, build $filter to screen mounted subdirs
X			# and anything relevant in $nobkp from list.
X			# We're trying to create list of *excluded* stuff here.
X			# Use $dft2, not $dfout, since it has all filesystems.
X			cd $workdir
X			case "$fs$fsbkp" in
X			# we're backing up the root filesystem
X			/true)
X				# egrep -v filters root, awk appends "/"
X				egrep -v "^$fsdev[ 	]" $dft2 \
X				| awk '{print $NF"/"}' > $filtert1
X				if test -r $nobkp ; then
X					cat $nobkp >> $filtert1
X				fi
X				# AIX 3.2 cpio does "exit 2" if it sees devices,
X				# AIX 3.[01] cpio does "exit 0" but complains
X				# if it sees devices,
X				case "$OS_S" in
X				AIX)	echo /dev >> $filtert1 ;;
X				esac
X				# sed substitutes leading "X" and trailing "/"
X				sed -e 's,^/,X,' -e 's,[^/]$,&/,' $filtert1 > $filter
X			;;
X			# we're backing up some other filesystem
X			*true)
X				# awk appends "/", egrep matches for $fs,
X				# next egrep -v filters $fs itself
X				# Second egrep can't be grep because
X				# a bug in AIX 2.2.1 grep -v yields a
X				# newline when its input is empty!
X				# Bummer because Ultrix 2.0 egrep -v
X				# has the same bug.
X				awk '{print $NF"/"}' $dft2 \
X				| egrep    "^${fs}/" \
X				| egrep -v "^${fs}/$" > $filtert1
X				if test -r $nobkp ; then
X					# sed appends "/", egrep matches $fs
X					# egrep -v filters $fs itself
X					sed -e 's,$,/,' $nobkp \
X					| egrep    "^$fs/" \
X					| egrep -v "^$fs/$" >> $filtert1
X				fi
X				# sed substitutes "X" for $fs"/"
X				sed -e "s,^$fs/,X," $filtert1 > $filter
X			;;
X			# $fs isn't a filesystem so create an empty $filter
X			*)
X				> $filter
X			;;
X			esac
X
X			# Second, put list of files at the top level of $fs
X			# in $top
X			#
X			# sneaky: .?* matches because ".." always exists
X			# Pray there aren't too many files at top level of $fs.
X			# (This could be made slightly more efficient, but
X			# save that for later.)
X			# Anyway, take our first cut at $top:
X			top=`cd $fs ; echo .?* * | sed -e 's/\.\.//'`
X			# if $filter has real stuff in it then use it to
X			# strip mounted filesystems from $top.
X			if test -s $filter ; then
X				# Create $topfilter: the sed removes two-plus
X				# level subdirs (with two slashes) since it's
X				# too hard to deal with filtering those,
X				# and changes trailing "/" to "X" for fgrep
X				# which doesn't support metacharacters
X				sed -e '/\/.*\//d' -e 's,^.\(.*\)/$,X\1X,' $filter > $topfilter
X				# Needed the following "if test ..." to
X				# deal with HP-UX's fgrep -v, which fails if
X				# handed a null filter file.  But what the
X				# heck, this is smarter anyway.
X				if test -s $topfilter ; then
X					# "for" echo's X${i}X thru fgrep filter
X					# thru sed to strip "X"s through
X					# awk to merge back into one line
X					for i in $top ; do echo X${i}X ; done \
X					| fgrep -v -f $topfilter \
X					| sed -e 's/^X\(.*\)X$/\1/' \
X					| awk '{printf "%s ", $1}' > $toplist
X					top=`cat $toplist`
X				fi
X			fi
X
X			# Third, start $flist (list of files to be backed up).
X			# Begin with hard-coded paths for $report and $flist;
X			# we have to do this for ease of cpio file restoration.
X			# Unfortunately, this means that we can only run one
X			# backup at a time.
X			echo "$pr: generating list of files to put in cpio archive for $fs"
X			echo /usr/tmp/$report	>  $flist
X			echo /usr/tmp/$flist	>> $flist
X
X			# Fourth, put list of files we're backing up into $flist
X			# If we're doing an incremental of $fs, find out when
X			# its last successful full backup was.
X			newer=''
X			if test $mode = incr ; then
X				lastfull=`grep '^full[ 	].*[ 	]'$fs'[ 	]*$' $bdatef | awk '{print $2}'`
X				if test -n "$lastfull" ; then
X					touch $lastfull $touchf
X					if test $? -ne 0 -o ! -f $touchf ; then
X						echo "$pr: Something went wrong with creating the touch file.  Quitting."
X						exit 1
X					fi
X					newer="-newer $touchf"
X				fi
X			fi
X			# try to force "find" to stay in the filesystem
X			# use $FINDXDEV_S if we have it, else try "FINDFSTYPE_S"
X			if   test -n "$FINDXDEV_S"   ; then
X				stayinfs=$FINDXDEV_S
X			elif test -n "$FINDFSTYPE_S" ; then
X				stayinfs=$FINDFSTYPE_S
X			else
X				stayinfs=''
X			fi
X			cd $fs
X			# get the start date of this backup
X			# we'd like datecpio to be able to set to the nearest
X			# second, unfortunately although date can report it
X			# that way Sys V touch can't set it that way.  Drat.
X			datecpio=`date '+%m%d%H%M%y%t%a %h %d %H:%M 19%y'`
X			# ideally we'd sort the output from find, but it
X			# could be too big for sort to handle which would
X			# be a bummer.
X			# At last, we can use $top and $filter to generate
X			# flist:
X			if test -s $workdir/$filter ; then
X				# sed's add and strip an "X" for fgrep filter
X				find $top $stayinfs $newer -print | sed -e 's/^/X/' | fgrep -v -f $workdir/$filter | sed -e 's/^X//' >> $workdir/$flist
X			else
X				find $top $stayinfs $newer -print >> $workdir/$flist
X			fi
X			rm -f $touchf
X
X			# Fifth and last, put $report and $flist into /usr/tmp
X			# where we're planning to back them up *first*!
X			# just in case we can save some space, try to hardlink
X			# them to /usr/tmp - don't want to archive a symlink!
X			# Remove them from /usr/tmp to prep for link attempt.
X			echo "#cpio archive of '$fs' filesystem" >> $workdir/$report
X			rm -f /usr/tmp/$flist /usr/tmp/$report
X			ln    $workdir/$flist $workdir/$report /usr/tmp 2> /dev/null \
X			|| cp $workdir/$flist $workdir/$report /usr/tmp
X			# need to do this because /usr/tmp may not have enough room for $flist
X			if test $? -ne 0 ; then
X				echo "$pr: 'cp $workdir/$flist /usr/tmp' failed" | tee -a $workdir/b.$fsnn.out
X				echo "$pr: Backup of '$fs' ABORTED, need more room in /usr/tmp." | tee -a $workdir/$b.$fsnn.out
X				break
X			fi
X
X			## The second BIG problem is that our backup may not
X			# fit on the media.  So we have to pipe the cpio into
X			# a while loop which manages the process of changing
X			# tapes and writing the archive onto the media.
X			fsvoln=1	# volume number for cpio archive of *this* filesystem
X			recinint=	# dd records in (integer truncation)
X			recoutint=	# dd records out (integer truncation)
X			# get info from initialization or "| while" loop
X			set `cat $pass`
X			sumrecin=$1
X			obleft=$2
X			## if earlier cpio archives filled up most of the
X			# current volume, change the media.
X			# "100" is an arbitrary small number
X			if test $obleft -lt 100 ; then
X				# we use nearend later when tracking the
X				# number of volumes in the backup
X				nearend=true
X				voln=`expr $voln + 1`
X				sumrecin=0
X				obleft=$maxocount
X				eval "$REW"
X				echo "$pr: Please put in $media volume $voln"
X				eval "$BREAKQ"
X			fi
X			cd $fs
X			# have to use a file to record cpio and dd exit status
X			# This is weird: "{ date ; x=$? ; } ; echo $x" works
X			# but "{ date ; x=$? ; } | cat ; echo $x" fails
X			# We'll break out of the while when we're done or if
X			# the user says to quit
X			echo "$pr: dd'ing archive of '$fs' onto filesystem volume $fsvoln"
X			echo "$pr: { cpio -o$ckey $copt < /usr/tmp/$flist 2> $workdir/err.cpio ; echo \$? > $workdir/stat.cpio ; } \\"
X			echo "$pr: | while : ; do"
X			{ cpio -o$ckey $copt < /usr/tmp/$flist 2> $workdir/err.cpio ; echo $? > $workdir/stat.cpio ; } \
X			| while : ; do
X				cd $workdir
X				## but do some initial media checking first
X				# if we're not an alldisks then it's OK for us
X				# to check media for write protection or
X				# other problems.
X				# If we *are* doing an alldisks, it would still
X				# be OK to check if we're at the beginning
X				# of a tape, but since I don't know what
X				# happens when cpio hits EOT there's no way
X				# to test for this (yet).
X				if test $mdev = $rewdev ; then
X					eval $SHOWDD Make sure we can write to this volume
X					$bdd if=$mtestf1 bs=$obs of=$rewdev count=1  2> err.dd
X					if test $? -ne 0 ; then
X						cat err.dd | tee -a b.$fsnn.out
X						eval "$CHKMWRITE"
X						eval "$BREAKQ"
X						# continue if we don't break out
X						continue
X					fi
X				fi
X
X				# if it's a cart, test it for density (ftpi)
X				# compatibility.  We do this by trying to write
X				# thirty blocks to the cart.  If this fails
X				# we have a problem.  Empirical tests show that
X				# it will fail within eighteen blocks (and
X				# more often with fourteen or even seven),
X				# but we'll write thirty just to make sure.
X				# Also, only do this if it's a onedisk.
X				# We may never get here but if we do this
X				# test is very important.
X				if test $mtype = cart -a $mdev = $rewdev ; then
X					# write it to cart (use conv=sync in
X					# case we fill up /tmp so it's not 150k)
X					eval $SHOWDD Try to write 150k test file to $media to check density
X					$bdd if=$mtestf4 bs=$obs of=$rewdev count=30 conv=sync 2> err.dd
X					if test $? -ne 0 ; then
X						cat err.dd | tee -a b.$fsnn.out
X						echo "$pr: Your $mtype is incompatible with"
X						echo "$pr: the density of drive $mhost:$media."
X						echo "$pr: Replace your $mtype with a 12,500ftpi $mtype."
X						eval "$BREAKQ"
X						# continue if we don't break out
X						continue
X					fi
X				fi
X
X				## ok, now we're finally putting the cpio
X				## archive on the media
X				icount=`expr $obleft \* $obs / $ibs`
X				# if we're writing to a local archive
X				if test $MHOST = $LHOST ; then
X					echo "$pr:		$bdd of=$mdev ibs=$ibs obs=$obs count=$icount 2> err.dd"
X					eval $SHOWDD Putting archive on this volume
X					$bdd of=$mdev ibs=$ibs obs=$obs count=$icount 2> err.dd
X					bddstat=$?
X				# else we're doing backup over the net
X				# we have to split up archive into 1k blocks
X				# before sending it over the net
X				else
X					realmhost=$MHOST
X					eval $SHOWDD Putting archive on this volume,
X					eval $SHOWDD using one to split and the other to join
X					echo "$pr:		{   MHOST=$LHOST     ; $bdd          ibs=5k obs=1k   count=$icount 2> err.split ; echo \$? > stat.split ; } \\"
X					echo "$pr:		| { MHOST=$realmhost ; $bdd of=$mdev ibs=1k obs=$obs               2> err.join  ; echo \$? > stat.join  ; }"
X					{   MHOST=$LHOST     ; $bdd          ibs=5k obs=1k   count=$icount 2> err.split ; echo $? > stat.split ; } \
X					| { MHOST=$realmhost ; $bdd of=$mdev ibs=1k obs=$obs               2> err.join  ; echo $? > stat.join  ; }
X					splitstat=`cat stat.split`
X					joinstat=`cat stat.join`
X					bddstat=$splitstat$joinstat
X					# try to ignore data from split
X					grep 'records in'  err.split >  err.dd
X					grep 'records out' err.join  >> err.dd
X				fi
X				# pass info to parent shell
X				echo $bddstat > stat.dd
X				cat err.dd >> b.$fsnn.out
X				echo $fs volume $fsvoln dd status: $bddstat >> b.$fsnn.out
X				# the semicolon in the awk shouldn't be needed,
X				# but the AIX 3.1 version requires it
X				recinint=` awk -F+ '$2 ~ /records in/  && $1 ~ /^[0-9][0-9]*$/ {x=$1} ; END {if (x == "") x=0 ; print x}' err.dd`
X				recoutint=`awk -F+ '$2 ~ /records out/ && $1 ~ /^[0-9][0-9]*$/ {x=$1} ; END {if (x == "") x=0 ; print x}' err.dd`
X				rm -f err.dd
X				# if we had a problem or this filesystem is done
X				if test $bddstat -ne 0 -o $recoutint -ne $obleft ; then
X					sumrecin=`expr $sumrecin + $recinint`
X					# if we had a problem with this
X					# filesystem, change the media
X					if test $bddstat -ne 0 ; then
X						obleft=0	# force change
X					# else we're ok
X					else
X						# this is a holdover from when we supported different block sizes,
X						# but it could be simplified to:
X						# obleft=`expr $maxocount - $sumrecin`
X						obleft=`expr $maxocount - \( $sumrecin \* $ibs / $obs \)`
X					fi
X					# pass info from this "| while"
X					# subshell to its parent
X					echo $sumrecin $obleft > $pass
X					if test $bddstat -eq 0 ; then
X						break
X					else
X						errs='err.split err.join err.dd'
X						for err in $errs ; do
X							if test -f $err ; then
X								echo $err
X								cat $err
X							fi
X						done
X						echo "$pr: Backup of '$fs' volume $fsvoln ABORTED." | tee -a b.$fsnn.out
X						# exit of "| while" subshell
X						# should abort only this
X						# filesystem
X						exit 1
X					fi
X				# else we need to change volumes for this filesystem
X				else
X					sumrecin=0
X					obleft=$maxocount
X					# pass info from this "| while"
X					# subshell to its parent
X					echo $sumrecin $obleft > $pass
X					# make sure the media gets rewound
X					eval "$REW"
X					fsvoln=`expr $fsvoln + 1`
X					# emulate dump's "Change Volumes" message
X					echo "$pr: Change Volumes: put in filesystem '$fs' volume $fsvoln" | tee -a b.$fsnn.out
X					eval "$BREAKQ"
X				fi
X			done
X			# end of "| while" loop
X			echo "$pr: done"
X			# attempt to put cpio archive on $media is done.
X
X			## finish up the work for this cpio archive
X			cd $workdir
X			# show the user cpio's message if any
X			cat err.cpio
X			cat err.cpio >> b.$fsnn.out
X			cpiostat=`cat stat.cpio`
X			# The AIX 3.2 version of cpio has several "features"
X			# 1) it won't back up special files or FIFOs (named
X			# pipes); when asked to do so it exits with
X			# status "2" and says something like:
X			#	cpio: special file <ingres/log/ingres_log> not archived
X			# 2) if cpio is asked to back up a file which doesn't
X			# exist, it exits with status "2" and says roughly:
X			#	< tmp/Ex20006 > ?
X			# (Other versions of cpio complain about missing files
X			# but still exit with status 0.)
X			# If these are the only problem in the logs, we can
X			# safely "lie" about the exit status of the cpio
X			# process.  Lines we don't worry about in err.cpio
X			# under AIX 3.x look like this:
X			#	cpio: special file <ingres/log/ingres_log> not archived
X			#	< tmp/Ex20006 > ?
X			#	cpio: 0511-025 Cannot get information about /ingres/data/default/replicatedb/aaaaabgn.t00
X			#	10 blocks
X			# Hopefully, err.cpio includes only lines we don't
X			# worry about.
X			case $OS_S$cpiostat in
X			AIX2)
X				nlines=`wc -l < err.cpio`
X				nottoworry=`egrep -c '^[0-9]* blocks$|special file' err.cpio`
X				missingfiles=`awk '
X					/^< .+ > \?$/ {print $2}
X					/cpio: .*special file <.+> not archived/ {print substr($4,2,length($4)-2)}
X					/cpio: .*Cannot get information about / {print $NF}'
X				' err.cpio`
X				# make sure any supposedly missing files
X				# are really missing
X				x=0
X				if test -n "$missingfiles" ; then
X					cd $fs
X					for f in $missingfiles ; do
X						test ! -f $f && x=`expr $x + 1`
X					done
X					cd $workdir
X				fi
X				nottoworry=`expr $nottoworry + $x`
X				if test $nlines -eq $nottoworry ; then
X					cpiostat=0
X				fi
X			;;
X			esac
X			echo $fs cpio status: $cpiostat >> b.$fsnn.out
X			cpiostat=$cpiostat`cat stat.dd`
X			rm -f err.cpio
X			eval bstat$fsnn=$cpiostat
X			# if cpio is successful and we're updating
X			if test $cpiostat -eq 0 -a $update = true ; then
X				if test -f $bdatef ; then
X					# the sed is a tad clumsy because $fs
X					# has slashes in it
X					sed -e 's,^'$mode'[ 	].*[ 	]'$fs'[ 	]*$,,' -e '/^[ 	]*$/d' $bdatef > $bdatef.tmp
X				fi
X				echo "$mode	$datecpio	$fs" >> $bdatef.tmp
X				sort +7 -8 +0 -1 $bdatef.tmp > $bdatef
X				rm -f $bdatef.tmp
X			fi
X		;;
X		esac
X
X		## Kevin Malloy put this in - I suppose it's needed
X		if test "$OS_S" = dgux ; then
X			sleep 60
X		fi
X
X		## warn about known problems in this backup (see $KNOWNPROBS
X		## and $KNOWNFALSEPROBS)
X		bprogerr="`fgrep -f $problist b.$fsnn.out | fgrep -v -f $falseprob`"
X		test -n "$bprogerr" && bprogerr="	$bprogerr"
X		eval echo \""\$bstat$fsnn	$fsdev	$fs$bprogerr"\" \>\> $statlist
X
X		## report on first backups on each tape as we go along
X		# We don't care about media write errors on the first
X		# backup since that only means the tape was bad or
X		# too short.  The operator just restarts these, which
X		# doesn't add a new volume to the set.
X		if test $fsnn -eq 1 ; then
X			echo "Volume '$voln': First backup is $fs" >> $firstblist
X		# else if this backup is a dump and it got media write errors,
X		# then it started in the middle of the media and had to be
X		# restarted with a new volume.  It's important to get
X		# dump's "write error" message right.
X		# Some message types (with samples from the listed OS):
X		# Pyramid OSx, Ultrix 2.0/3.0, SunOS 3.2:
X		# 	DUMP: Write error on tape 4
X		# CCI SysV, Gould UTS 2.1a, Pyramid OSx, Seguent DYNIX:
X		# 	DUMP: Tape write error on tape 1
X		# 4.3BSD, CCI BSD, Mt. Xinu BSD, SunOS 4.X:
X		# 	DUMP: Tape write error 277 feet into tape 4
X		# 	DUMP: Write error on tape 1
X		# Bull B.O.S. 02.00:
X		#	FSDUMP: Tape write error 815 feet into tape 1
X		# SVR4 variants from NCR and ???:
X		#	UFSDUMP: ?????
X		# SVR4 variants from Pyramid:
X		#	UFSDUMP: Tape write error: EOT (end of tape) encountered 419 feet into tape1
X		# DG/UX says
X		#	write: No space left on device
X		#	Error writing tape: Address already in use
X		# but notice that it does *not* say "DUMP: whatever".
X		# We rely on this.
X		# cpio - don't know what this looks like, maybe we avoid anyway
X		elif egrep 'DUMP:.* [Ww]rite error:* .* tape *[1-9]' b.$fsnn.out > /dev/null ; then
X			voln=`expr $voln + 1`
X			echo "Volume '$voln': First backup is $fs" >> $firstblist
X		# else we are doing a cpio alldisks backup and we got so close
X		# to the end of the media that we had to prompt for a new one
X		# before this cpio archive could start
X		elif test "$nearend" = true ; then
X			echo "Volume '$voln': First backup is $fs" >> $firstblist
X			nearend=false
X		fi
X		# else do nothing - this backup started in the middle
X		# of the media but did not run out room.
X
X		## Did this backup take more than one volume?  In other
X		## words, was it continued onto the next tape?
X		# This can happen if:
X		# a) we're doing a onedisk backup that won't fit on one tape
X		# b) we're doing an alldisks backup using cpio
X		# c) we're doing an alldisks backup using a version of dump
X		# that knows how to handle EOT (e.g. DG's "dump2" and
X		# Solaris 2.X "ufsdump")
X		# d) we're doing an incremental alldisks backup, and an
X		# incremental of one of the filesystems is too big to fit
X		# on one tape
X		#
X		# The key is to look for the following messages in
X		# the b.$fsnn.out file:
X		# This alldisks script says "Change Volumes",
X		# SunOS 4.0.3 and Solaris 2.2 say "Change Volumes" too,
X		# OSF from DEC says "Change Cartridges",
X		# DG's "dump2" says "dump2: Time to change tapes." - dump2
X		# does this even when it hits EOT on a video drive when using
X		# using the -M option - gads!
X		# Solaris 2.2 ufsdump says:
X		# DUMP: End-of-tape detected
X		# DUMP: Change Volumes: Mount volume #N
X		# All others say "Change Tapes." when it's time to start the
X		# next tape.
X		#
X		# Unfortunately, some versions of dump say "Change Tapes"
X		# when they are rewriting the volume, too:
X		# ULTRIX V3.1 dump gets a -SIGTERM, it says
X		#	DUMP: SIGTERM()  try rewriting
X		#	DUMP: Rewriting attempted as response to unknown signal.
X		#	DUMP: Change Tapes: Mount tape #1
X		#
X		# Pyramid's OSx "dump" says:
X		#	DUMP: Tape write error on tape 1
X		#	.....
X		#	DUMP: replace the faulty tape with a new one;
X		#	DUMP: this dump volume will be rewritten.
X		#	DUMP: Change Tapes: Mount tape #1
X		#
X		# Pyramid's SVR4 OSx "ufsdump" says:
X		#	UFSDUMP: Tape write error: EOT (end of tape) encountered 419 feet into tape1
X		#	UFSDUMP: NEEDS ATTENTION: Do you want to restart?: ("yes" or "no")
X		#	UFSDUMP: This tape will rewind.  After it is rewound,
X		#	UFSDUMP: replace the tape and this dump volume will be rewritten,
X		#	UFSDUMP: or abort and restart the dump, specifying correct tape capacity.
X		#	UFSDUMP: Closing tape device
X		# Note that if it hits premature EOT,
X		# it never says   "Change Tapes: Mount tape #1",
X		# but it does say "Change Tapes: Mount tape #2" (and 3, 4, ...)
X		# and it also says "will be rewritten"
X
X		# So, we have to get rather tricky.
X		x=`egrep -c 'Change Tapes|Change Volumes|Change Cartridges|change tapes' b.$fsnn.out`
X		y=`egrep -c 'try rewriting|will be rewritten' b.$fsnn.out`
X		z=`egrep -c 'Mount tape #1' b.$fsnn.out`
X		if test $y -eq 1 -a $z -eq 0 ; then
X			y=0
X		fi
X		x=`expr $x - $y`
X		while test $x -gt 0 ; do
X			voln=`expr $voln + 1`
X			x=`expr $x - 1`
X			echo "Volume '$voln': First backup is $fs (continued)" >> $firstblist
X		done
X	done
X	## finished with writing backup to media!!
X
X	## do $REW/$OFFLINE as soon as loop finishes so user doesn't
X	## have to wait
X	# if we're verifying this backup, rewind now, take it offline
X	# after the verify completes
X	if test $verifytoo = true ; then
X		eval "$REW" 
X	# else do $OFFLINE work in "/" in case user wants to
X	# umount a filesystem we may have just backed up
X	# and do it in background so operator doesn't have to wait as long
X	else
X		cd /		
X		eval "$OFFLINE" &
X	fi
X	cd $workdir		# now finish up in $workdir
X	echo "Volume '$voln': Last volume." >> $firstblist
X	rm -f $pass
X
X	## generate report for mailing to $rptto.  Report to include:
X	# put standard out in $report
X	exec 1>> $report
X	echo "#lhost	mhost	mode	media	mdevbase	multi	OPER	voln	hfstat"
X	# print variables (if $hfstat is set use it else substitute "NA")
X	echo "$lhost	$mhost	$mode	$media	$mdevbase	$multi	$OPER	$voln	${hfstat-NA}"
X	cat $statlist $firstblist
X	if test -s $nobkptmp ; then
X		sed -e 's/^\[[	 ]*\]\(.*\)\$/#Not backed up: \1/' $nobkptmp
X	fi
X	echo "#End time:   `date`"
X	exec 1>&9
X
X	## mail semi-final backup report to $rptto
X	eval "$MAILRPT"
X
X	## get operator info - known problems and operator report
X	# Give BIG warning message if we had problems (see $KNOWNPROBS)
X	# exit status 0 or 1 are OK for dump, but exit status 1 bad for cpio
X	awk '
X		BEGIN {bprog="'$bprog'"} # get $bprog
X		$0 ~ /^\#bstat/ {next}	# skip header if any
X		NF != 3 {print; next}	# we have known problems
X		$1 >  1 {print; next}	# exit status > 1 always bad
X		$1 == 1 && bprog ~ /cpio/ {print; next}	# status 1 bad for cpio
X	' $statlist > $statprob
X	# if we have no problems, clean up
X	if test ! -s $statprob ; then
X		rm -f $statprob $probsent
X	# else report them if we have to
X	else
X		# foreach problem filesystem
X		grep '^[0-9][0-9]*	' $statprob \
X		| while read probstat probfs probdir probdes ; do
X			# if the problem has been reported
X			if test -f $probsent && egrep "	$probfs	" $probsent ; then
X				: do nothing - we already tried to report it
X			# else get ready to report it now
X			else
X				echo "$wdir	$probstat	$probfs	$probdir	$probdes" | tee -a $probsend
X				# "DUMP: read error! sector 49310 of /dev/rdsk/c0t1d0s6" (Solaris 2.3 ufsdump got a block read error)
X				if egrep "$probfs.*(bread|read error!)" $statprob > /dev/null ; then
X					echo "$pr: WARNING!  Block read errors found!"
X					echo "$pr: Block read errors could mean either:"
X					echo "$pr: a) The disk has hard errors - a real bummer."
X					echo "$pr:    Check system logs with dmesg/messages/uerf/hdelogger/errpt/whatever."
X					echo "$pr: b) The disk is ok but the filesystem is corrupt,"
X					echo "$pr:    e.g. an inode is pointing at impossibly large block numbers."
X					echo "$pr:    Fix by umount'ing and fsck'ing the filesystem."
X					echo "$pr:"
X				fi | tee -a $probsend
X			fi
X		done
X		# tell operator
X		echo ''
X		echo "$pr: WARNING! The backup report shows big PROBLEMS:"
X		cat $statprob
X		echo "$pr: Please REPORT THIS to na-system !!!"
X		eval "$EXITQ"
X	fi
X
X	## finish report at last
X	if test -f $failrpt ; then
X		exec 1>> $report
X		echo "Operator '$OPER' reported that this backup failed for the following reason:"
X		cat $failrpt
X		echo ""		# make sure there's a newline
X		echo "End of Operator failure report."
X		exec 1>&9
X	fi
X	# report generation done, so put standard out back on the tty
X
X	## finish
X	if test $verifytoo != true ; then
X		echo "$pr: This backup is done."
X	else
X		echo "$pr: This backup is done; will start 'verifytoo'."
X		# if we just made a multi-volume tape set, try to take the
X		# tape offline and then tell the operator to put the
X		# first tape in the drive
X		case $mistape$voln in
X		true[2-9]|true[1-9][0-9])
X			eval "$OFFLINE"
X			echo "$pr: This backup took $voln tapes."
X			echo "$pr: Before we begin the 'verifytoo', please put"
X			echo "$pr: volume '1' of this alldisks tape set into $media."
X			eval "$MREADYQ"
X		;;
X		esac
X		extravol=`expr $voln - 1`
X		case "$multi" in
X		false)	vfsarg=onedisk ;;
X		true)	vfsarg=alldisks ;;
X		esac
X		vcmd="./$pr verify $vfsarg $marg $diskfile $extravol $wdir $childargs nomail"
X		echo ''
X		echo $vcmd | tee -a $report
X		echo ''
X		cd $hdir
X		$vcmd
X		cd $workdir
X		echo "#VerToo end: `date`" >> $report
X		# take it offline in background so user doesn't have to wait
X		eval "$OFFLINE" &
X	fi
X;;
X
X## do get or verify if that's what we're doing
Xget|verify)
X
X	## onvol by definition is "1" if it's a onedisk backup, even
X	## if the backup spanned tapes (as in a 9track backup);
X	## otherwise we set it later
X	if test $mode = verify -a $getmode = onedisk ; then
X		onvol=1
X	fi
X
X	## get number of volumes (in most cases we care but some we don't):
X	## $mode    type	do_we_care_about_$nvol_and_$onvol
X	## get	    onedisk	no_and_no: we're not autoverifying
X	## get	    alldisks	yes_and_yes: we need positioning
X	## verify   onedisk	yes_and_yes: to autoverify if we can
X	## verify   alldisks	yes_and_yes: we need positioning
X	## So, "$nvol" can be null if we're doing a get from a onedisk backup;
X	#
X	# if it's a get from a onedisk, we don't really care but user may
X	# have specified so why not?
X	if test $mode = get -a $getmode = onedisk ; then
X		nvol=$nvol
X	# else we care, so try to figure it out ...
X	# if we're getting from disk file(s), we don't really have
X	# any tapes but we need to act as if it's all on one tape
X	elif test $mtype = file -o $mtype = dir ; then
X		nvol=1
X	# else if it's a onedisk, assume it will always fit on a video tape
X	elif test $getmode = onedisk -a $mtype = video ; then
X		nvol=1
X	# else we've got to find out the number of volumes/tapes and the 
X	# name of the first filesystem on each volume/tape
X	else
X		# for any cpio backup or an alldisks backup, we need to know:
X		# while test $bprog = cpio -o $getmode = knownfs -o $getmode = listdisks -o $getmode = lastdisk -o $getmode = alldisks ; do
X		# for any onedisk or alldisks backup
X		while : ; do
X			if test -n "$nvol" ; then
X				echo "$pr: This backup set has '$nvol' volume(s)."
X			else
X				echo "$pr: How many volumes are in this backup set?"
X				echo $epre "$pr: Enter the number: "$esuf
X				eval "$READ" nvol
X			fi
X			# validate $nvol
X			if test "$nvol" -lt 1 -o "$nvol" -gt $maxvol ; then
X				echo "$pr: '$nvol' can't be correct.  Try again."
X				nvol=''
X				continue
X			else
X				extravol=`expr $nvol - 1`
X				break
X			fi
X		done
X	fi
X	# if $nvol isn't set, then we don't need to know
X	case "$nvol\X$mtype" in
X	*file|*dir)	x="$nvol (mtype=$mtype)" ;;
X	X*)		x=NA ;;
X	*)		x=$nvol ;;
X	esac
X	echo "#volumes in backup set: $x" >> $report
X
X	# if we think we're getting from a multi-filesystem backup, then
X	# extract the header archive and get positioning info
X	case $getmode in
X	knownfs|knownskip|listdisks|lastdisk|alldisks)
X		# If this is a multi-fs backup we need to extract from the
X		# tar/cpio header file, or get the necessary info from the
X		# parent directory.
X		#
X		# If we are extracting from media, make absolutely sure it
X		# succeeds, and don't continue until it does.  This is the
X		# second time we've actually tried to read from the media.
X		fsnn=00
X		eval "$MDEV"
X		cd $workdir
X		while : ; do
X			# Do tar/cpio extraction (or get $dfout from the parent)
X			# The count for the "dd" below is to make sure that
X			# we don't read a huge file if we aren't reading a
X			# header archive, which should be less than 200k.
X			case $bprog$showdd$mhost in
X			cpio*)		: ;;
X			*false*)	: ;;
X			*true$lhost)	: ;;
X			*true*)		eval $SHOWDD Get alldisks header from $mhost:$media ;;
X			esac
X			case $parent-$bprog$demo$mhost in
X			# parent is a backup called with "verifytoo"
X			*[fit]?-*)		eval "$LNFSTABLIST" ; ln ../$dfout ../$breport            . ;;
X			# parent is ordinary verify
X			*[a-z]-*)		eval "$LNFSTABLIST" ; ln ../$dfout ../$breport ../$volmap . ;;
X			# the eight choices have no parent, i.e. this an
X			# ordinary verify
X			*cpiotrue$lhost)	echo "$pr demo: cpio -ium$ckey < $mdev" ;;
X			*cpio*$lhost)		: ;		cpio -ium$ckey < $mdev  ;;
X			*cpiotrue*)		echo "$pr demo: $bdd if=$mdev bs=5k 2\> /dev/null \| cpio -ium$ckey" ;;
X			*cpio*)			: ;		$bdd if=$mdev bs=5k 2>  /dev/null  | cpio -ium$ckey  ;;
X			*true$lhost)		echo "$pr demo: tar xf $mdev" ;;
X			*$lhost)		: ;		tar xf $mdev  ;;
X			*true*)			echo "$pr demo: $bdd if=$mdev bs=10k count=20 2\> /dev/null \| tar xf -" ;;
X			*)			: ;		$bdd if=$mdev bs=10k count=20 2>  /dev/null  | tar xf -  ;;
X			esac
X			hfstat=$?
X			# if we had no problems getting $dfout
X			# note that SunOS 4.1.2 tar exits ok when it reads
X			# a dump - very strange!
X			if test "$hfstat" -eq 0 -a -s $dfout ; then
X				break
X			else
X				echo "$pr: We had some trouble extracting the header archive from the $media."
X				echo "$pr: Doing some investigating ..."
X				if test ! -s $dfout ; then
X					echo "$pr: Filesystem list '$dfout' was not extracted."
X					echo "$pr: Extracting the header archive failed.  Check:"
X					echo "$pr: -> Is the $media a 'onedisk' backup (not an 'alldisks')?"
X					eval "$CHKMEDIA"
X					echo "$pr: Quitting."
X					exit 1
X				else
X					echo "$pr: Filesystem list '$dfout' was extracted - ok so far ..."
X					echo "$pr: Doing simple checks on '$dfout' ..."
X					# $dfout should have same number of words on each line
X					isit1=`awk '{print NF}' $dfout | sort -n -u | wc -l`
X					# last line should end in a newline
X					od -c $dfout | tail -2 | grep '\\n *$' > /dev/null
X					if test $isit1 -eq 1 -a $? = 0 ; then
X						echo "$pr: Filesystem list '$dfout' looks OK to me."
X					else
X						echo "$pr: Filesystem list '$dfout' is probably mangled."
X					fi
X					echo "$pr: YOU check it out.  If YOU think it looks mangled, type 'q' to quit."
X					cat $dfout
X					eval "$EXITQ"
X					break
X				fi
X			fi
X		done
X
X		# try to get positioning info from the old backup working
X		# directory - not implemented yet.
X		#bworkdir=$hdir/`awk '/#Workdir:/ {print $2}' $brpt` > /dev/null
X		#gotrpt=false
X		#if test -s $bworkdir/*rpt ; then
X		#	:
X		#	# this won't work right now since there aren't any with
X		#	# reports in the proper format yet
X		#fi
X		# Getting positioning from old logs isn't working yet
X		gotrpt=false
X		if test $gotrpt = false ; then
X			if test -z "$firstfslist" ; then
X				dofirstfslist=false
X			else
X				# trim any spaces from $firstfslist
X				dofirstfslist=true
X				set $firstfslist
X				firstfslist="$*"
X				echo "$pr: firstfslist='$firstfslist'"
X			fi
X			firstfs1=`awk 'NR == 1 {print $NF ; exit}' $dfout`
X			echo "$pr: Volume '1': First backup is $firstfs1"
X			echo      "Volume '1': First backup is $firstfs1" > $firstblist
X			n=2
X			while test -n "$nvol" -a $n -le "$nvol" -a $mtype != file -a $mtype != dir ; do
X				if test -n "$1" -a $dofirstfslist = true ; then
X					fs1=$1
X				else
X					echo "$pr: What is the first filsystem on alldisks volume '$n'?"
X					echo $epre "$pr: Enter filesystem name (or 'unknown'): "$esuf
X					eval "$READ" fs1
X				fi
X				case $fs1 in
X				"")
X					continue
X				;;
X				un*)
X					echo "$pr: The first filesystem on volume '$n' is UNKNOWN !!?!??  AARRGGHH !!!"
X					if test -s $whodid ; then
X						initials=`cat $whodid`
X						#x=`grep "^$initials[ 	]" $oplist | sed -e 's/^[^ 	]*[ 	]*//'`
X						x=`sed -n -e "/^$initials[ 	][ 	]*[^ 	]*[ 	]*/s///p" $oplist`
X					fi
X					if test -n "$x" ; then
X						echo "$pr: You must now severely scold '$x', who made this backup."
X					elif test -n "$initials" ; then
X						echo "$pr: You must now severely scold '$initials', who made this backup."
X					else
X						echo "$pr: You must now severely scold the person who made this backup."
X					fi
X					echo "$pr: They should have written this information on the tape label!!"
X					echo "$pr: I can not reliably position the $media at the correct archive."
X					echo "$pr: Maybe you'll get REALLY lucky ..."
X					echo "$pr: Volume '$n': First backup is unknown"
X					echo      "Volume '$n': First backup is unknown" >> $firstblist
X					n=`expr $n + 1`
X					eval "$EXITQ"
X				;;
X				/*)
X					# if it's a valid filesystem
X					if egrep "[ 	]$fs1\$" $dfout > /dev/null ; then
X						# DG's "dump2" and at least
X						# one other vendor can continue
X						# a dump when it hits EOT, so
X						# was this archive continued
X						# *from_the_previous* volume?
X						# (note this has nothing to do
X						# with $cont2next variable,
X						# which says whether or not an
X						# archive was continued
X						# *to_the_next* volume)
X						while : ; do
X							contstr=''
X							if test -z "$1" -o $dofirstfslist != true ; then
X								echo $epre "$pr: Was $fs1 continued from the previous volume? [yn] "$esuf
X								eval "$READ" yesno
X							elif test "$2" = cont ; then
X								yesno=y
X								shift
X								shift
X							else
X								yesno=n
X								shift
X							fi
X							case $yesno in
X							[yY]*)	contstr=' (continued)' ;;
X							[nN]*)	: ;;
X							*)	continue ;;
X							esac
X							break
X						done
X						echo "$pr: Volume '$n': First backup is $fs1$contstr"
X						echo      "Volume '$n': First backup is $fs1$contstr" >> $firstblist
X						n=`expr $n + 1`
X					else
X						dofirstfslist=false
X						echo "$pr: Could not find '$fs1' in $dfout."
X						echo "$pr: Here are the available filesystems:"
X						cat $dfout
X					fi
X				;;
X				*)
X					dofirstfslist=false
X					echo "$pr: Filesystem names must begin with a '/'."
X				;;
X				esac
X			done
X			cat $firstblist >> $report
X
X			# Now we have list of first filesystems, so
X			# we can build filesystem-tape map.
X			# The trick is to build two somewhat independently
X			# processed lists: a) $* for each volume, and
X			# b) $f from $dfout which lists all the filesystems
X			# The $volinc stuff is to handle our best guess at
X			# which volume filesystems are on when we've got
X			# 'unknown' first filesystems
X			# A rather elegant solution, yes indeed; now if
X			# only we could explain it more clearly :-)
X			echo "1	alldisks_header" > $volmap
X			n=0
X			volinc=1
X			# This simple awk code works everywhere but
X			# Solaris 2.1 and 2.2: "awk '{print $6 $7}'"
X			# Because it coredumps if there are less than 7 fields
X			# on the first input line for Solaris 2.[12], we've
X			# had to replace it with equivalent awk code in
X			# the following statement:
X			set `awk '{printf("%s%s\n", $6, $7)}' $firstblist`
X			for f in `awk '{print $NF}' $dfout` ; do
X				if test "$f" = "$1" ; then
X					n=`expr $n + $volinc`
X					echo "$n	$f" >> $volmap
X					shift
X					volinc=1
X					while test "$1" = unknown ; do
X						shift
X						volinc=`expr $volinc + 1`
X					done
X				elif test "$f(continued)" = "$1" ; then
X					echo "$n	$f" >> $volmap
X					n=`expr $n + $volinc`
X					echo "$n	$f(continued)" >> $volmap
X					shift
X					volinc=1
X					while test "$1" = unknown ; do
X						shift
X						volinc=`expr $volinc + 1`
X					done
X				else
X					echo "$n	$f" >> $volmap
X				fi
X			done
X		fi
X	esac
X
X	# if we are doing get/verify of a single filesystem from an alldisks
X	# tape set we have a lot of work to do to select the filesystem
X	# and position the media there.  This includes setting $onvol for
X	# verify onedisk, and much more stuff if we're looking at an alldisks
X	case $getmode in
X	knownfs|listdisks|lastdisk)
X
X		# can check the media contents vs. label if it's an alldisks
X		if test -z "$parent" ; then
X			report_p=$breport
X			eval "$LABELQ"
X		fi
X
X		## determine the filesystem to get
X		# if the user requested a specific filesystem
X		case $getmode in
X		knownfs)
X			# verify the filesystem, being very careful with egrep
X			# remember, the regular expression must be
X			# [<SPACE><TAB>]$fs<DOLLAR>
X			if egrep "[ 	]$fs\$" $dfout > /dev/null ; then
X				echo "$pr: Good news - '$fs' is in this backup set."
X			else
X				getmode=listdisks
X				echo "$pr: '$fs' was not put on this backup $media."
X			fi
X		;;
X		lastdisk)
X			fs=`tail -1 $dfout | awk '{print $NF}'`
X			if test -n "$fs" ; then
X				getmode=knownfs
X				echo "$pr: Last filesystem is '$fs'"
X			else
X				getmode=listdisks
X				echo "$pr: Attempt to pick last filesystem failed."
X			fi
X		;;
X		esac
X		while test $getmode = listdisks ; do
X			echo ''
X			echo "$pr: Backups were made of these disks:"
X			cat $dfout
X			echo "$pr: What is the filesystem you want to $mode?"
X			echo $epre "$pr: Enter the filesystem (or 'q' to quit): "$esuf
X			eval "$READ" ans
X			case $ans in
X			[qQ]*)
X				echo "$pr: OK, will quit.  Bye."
X				exit
X			;;
X			/*)
X				# verify the filesystem, being very careful with egrep
X				if egrep "[ 	]$ans\$" $dfout > /dev/null ; then
X					getmode=knownfs
X					fs=$ans
X				else
X					egrep "[ 	]$ans\$" $dfout
X					echo "$pr: Could not find '$ans' in $dfout."
X				fi
X			;;
X			*)
X				echo "$pr: Try again."
X			;;
X			esac
X		done
X
X		# if user didn't tell us which volume the backup is on
X		# and how many files to skip, then calculate it
X		mapent=`egrep    "[ 	]$fs\$" $volmap`
X		onvol=`echo $mapent | sed -e 's/[ 	].*//'`
X		thisvolmap=`egrep "^$onvol[ 	]" $volmap`
X		bkpn=`echo "$thisvolmap" | egrep -n "[ 	]$fs\$" | sed -e 's/:.*//'`
X		filen=`echo "$thisvolmap" | egrep -n "[ 	]$fs\$" | sed -e 's/:.*//'`
X		fileskip=`expr $filen - 1`
X		# if the filesystem we want is the first one on $onvol
X		nextvol=`expr $onvol + 1`
X		if egrep "[ 	]$fs\$" $firstblist > /dev/null ; then
X			: do nothing - we know we are ok
X		# else if there is a next volume and its first
X		# filesystem is unknown, then the filesystem we want
X		# could be on $onvol or the next one (or the next ...)
X		elif egrep "'$nextvol':.*[ 	]unknown" $firstblist > /dev/null ; then
X			echo ""
X			echo "$pr: Since the first filesystem on volume '$nextvol' is 'unknown', it is"
X			echo "$pr: impossible to determine exactly which volume $fs is on."
X			echo "$pr: It could be on volume '$onvol' or '$nextvol',"
X			echo "$pr: but there is no way to know for sure."
X			echo "$pr: We will have to start with volume '$onvol'"
X			echo "$pr: and skip '$fileskip' files until we reach the backup for '$fs'."
X			echo "$pr: If necessary, I will ask you to change ${media}'s."
X			echo "$pr: This is the best we can do.  If $fs is on volume '$onvol',"
X			echo "$pr: this scheme will work; if not the odds are really bad."
X			eval "$EXITQ"
X		fi
X
X		bkpn=`grep -v '[ 	](alldisks_header|\(continued\))$' $volmap | egrep -n "[ 	]$fs\$" | sed -e 's/:.*//'`
X		echo "#fs=$fs bkpn=$bkpn onvol=$onvol fileskip=$fileskip" >> $report
X		echo ''
X		if test $getmode = knownskip ; then
X			echo "$pr: We have to skip $fileskip file(s) on volume $onvol"
X		else
X			echo "$pr: We have to skip $fileskip file(s) on this volume"
X		fi
X		echo "$pr: to position the $media at the backup of $fs."
X		case $bkpn in
X		[0-9])	fsnn=0$bkpn ;;
X		*)	fsnn=$bkpn ;;
X		esac
X		eval "$MDEV"
X		if test $onvol -gt 1 ; then
X			# prompt operator for $onvol approval
X			eval "$OFFLINE"
X			echo "$pr: Please mount volume $onvol."
X			eval "$MREADYQ"
X			# Make sure the new volume is online
X			while : ; do
X				# tell user what we're doing if $SHOWDD is true
X				eval $SHOWDD Make sure $media is on line
X				# try to read media, using $mtestibs - if
X				# the read fails then it's not on line.
X				if test "$mhost" = "$lhost" ; then
X					$bdd if=$rewdev bs=$mtestibs count=1 of=/dev/null 2> /dev/null && online=true
X				else
X					online=`$bdd if=$rewdev bs=$mtestibs count=1 of=/dev/null '2> /dev/null && echo true' | grep '^true$'`
X				fi
X				if test "$online" = true ; then
X					break
X				else
X					eval "$CHKMREAD"
X					eval "$EXITQ"
X				fi
X			done
X			# At this point, we'd also like to make sure the
X			# operator didn't leave the first volume in the drive,
X			# but it's too much work:
X			# tar doesn't mind if it reads a dump, and
X			# we have no guarantee the beginning of $onvol
X			# is the start of a dump or cpio archive.
X			# We'd have to do something like extract the
X			# header archive again, and see if we succeed.
X		fi
X	;;
X	esac
X
X	# position the media if we have to
X	case $getmode in
X	knownfs|knownskip|listdisks|lastdisk)
X		case $mtype in
X		dir|file)	: do nothing ;;
X		*)		echo '' ; echo "$pr: Positioning $media.  This may take a while." ;;
X		esac
X		eval "$SKIP2ARCHIVE"
X	;;
X	esac
X
X	# OK!  We've now done any necessary work to choose a filesystem
X	# and position the media.
X	# So we can set "$fsproxy" here, which we'll use in reports and when
X	# we tell the user whether we think a verify attempt PASSED or FAILED.
X	case $getmode in
X	onedisk)	fsproxy='(onedisk)' ;;
X	alldisks)	fsproxy='(alldisks)' ;;
X	*)		fsproxy=$fs ;;
X	esac
X
X	# If we're doing a get (as opposed to a verify), do we do an
X	# interactive restore or do we restore the entire dump?
X	rmode=NA	# in case we're doing a verify not a get
X	while test $mode = get -a -z "$entire" ; do
X		echo "$pr: Do you want to do an interactive restore, or"
X		echo "$pr: do you want to restore the entire dump/cpio archive?"
X		echo "$pr: NOTE - restoring the entire archive may restore"
X		echo "$pr: MASSIVE amounts of data."
X		echo $epre "$pr: Enter 'i' for interactive, 'e' for entire [ie]: "$esuf
X
X		eval "$READ" rmode
X		case $rmode in
X		[iI]*)
X			while : ; do
X				echo "$pr: You chose an interactive restore."
X				echo $epre "$pr: Is this OK? [y(n)]: "$esuf
X				eval "$READ" ans
X				case $ans in
X				[yY]*)	entire=false ; break ;;
X				*)	continue 2 ;;
X				esac
X			done
X		;;
X		[eE]*)
X			while : ; do
X				echo "$pr: You chose to restore the entire archive."
X				echo $epre "$pr: Is this OK? [y(n)]: "$esuf
X				eval "$READ" ans
X				case $ans in
X				[yY]*)	entire=true ; break ;;
X				*)	continue 2 ;;
X				esac
X			done
X		;;
X		*)
X			continue
X		;;
X		esac
X	done
X	if test $mode = get ; then
X		case $entire in
X		true)
X			rmode=r
X			getlist=''
X			echo "$pr: You chose to restore the entire archive."
X		;;
X		false)
X			if test $bprog != cpio ; then
X				rmode=i
X				echo "$pr: You chose an interactive restore."
X			else
X				echo "$pr: I don't know how to do an interactive cpio restore."
X				echo "$pr: If you exit here by entering $QUOTEDQ, I will leave"
X				echo "$pr: the $media in its current position.  Or you can choose"
X				echo "$pr: to restore the entire cpio archive by entering anything else."
X				eval "$EXITQ"
X			fi
X		;;
X		esac
X	fi
X
X	# Make the user choose the target directory they really want to
X	# restore_to / be_in.  If we're doing a verify, do the extraction
X	# into a subdirectory of $workdir so we don't run into name conflicts.
X	# This avoids trouble in the case where the last file in the archive
X	# is called something like "./backup/1213.183147im/b.03.out"
X	# which would cause problems because we may have just extracted
X	# the "backup" script from an alldisks tar header archive.
X	echo ''
X	case $mode$getmode in
X	get*)
X		echo "$pr: We are almost ready to try to 'get' your file restoration going."
X		test -z "$target" && target=$startdir
X	;;
X	verifyalldisks)
X		: do nothing
X	;;
X	verify*)
X		echo "$pr: We are almost ready to try to begin your verification."
X		test -z "$target" && target=$workdir/extract && mkdir $target
X	;;
X	esac
X	while test $mode$getmode != verifyalldisks ; do
X		echo "$pr: What is the target directory for the RESTORATION TREE?"
X		if test $mode = verify -a $autoverify = true ; then
X			echo "$pr autoverify: Assume target:"
X			echo "$pr autoverify: '$target'"
X			testdir=$target
X		elif test "$targetarg" = true ; then
X			echo "$pr: Restoration target directory specified:"
X			echo "$pr: '$target'."
X			testdir=$target
X		else
X			echo $epre "$pr: Enter the name ($target): "$esuf
X			eval "$READ" ans
X			case $ans in
X			'')	testdir=$target ;;
X			*)	testdir=$ans ;;
X			esac
X		fi
X		# if $testdir isn't a directory, make sure we ask for target
X		if test ! -d "$testdir" ; then
X			echo "$pr: '$testdir' is not a directory.  Try again."
X			targetarg=false
X			continue
X		# else make sure we can create files in $testdir
X		# should be able to use "touch" here but Ultrix 2.0 and 3.0
X		# touch is buggy
X		elif echo "$pr: (workdir=$workdir) - can we put files in $testdir?" > $testdir/bkp.get.junk ; then
X			rm -f $testdir/bkp.get.junk
X			if test $autoverify = true -o $targetarg = true ; then
X				: do not ask about target
X			else
X				echo "$pr: Put restoration tree in target directory"
X				echo $epre "$pr: '$testdir'? [y(n)] "$esuf
X				eval "$READ" ans
X				case $ans in
X				[yY]*)	: do nothing - fall through to break ;;
X				*)	continue ;;
X				esac
X			fi
X			target=$testdir
X			cd $target
X			break
X		else
X			targetarg=false
X			echo "$pr: Cannot create files in '$testdir'.  Check:"
X			echo "$pr: -> Is '$testdir' on an NFS filesystem (check with 'df')?"
X			echo "$pr:    (If so, try another directory.)"
X			echo "$pr: -> Does '$testdir' have write permission?"
X			ls -ld $testdir
X			echo "$pr:    (If not, try another directory or try 'chmod u+w $testdir'.)"
X		fi
X	done
X
X	echo "#get/verify filesystem '$fsproxy', restore mode '$rmode' into target directory '$target'" >> $workdir/$report
X
X	## At last! start restore or verify!
X	umask 0
X	if test $getmode = knownfs -o $getmode = listdisks ; then
X		echo "$pr: About to read the backup of '$fs' (we hope)."
X	fi
X	case $mode in
X	get)
X		echo "$pr: Starting 'get' process." | tee -a $workdir/$report
X
X		# $getlist, $rans, $rmode, $rout for $DO_GET
X		getlist=""
X		rans=""
X		rmode="$rmode"
X		rout="2>&1 | tee -a $workdir/$report"
X		eval "$DO_GET"
X	;;
X	verify)
X		## See verify strategy comments in the README
X		## cpio archive: get $breport and $flist
X		## dump archive: get name of last file on the desired filesystem
X
X		# $getlist, $rans, $rmode, $rout for $DO_GET
X		case $bprog in
X		cpio)	getlist="/usr/tmp/$breport /usr/tmp/$flist" ;;
X		*)	getlist="" ;;
X		esac
X		rans="echo 1 |"
X		rmode="tv"
X		rout="> $vlist 2>&1"
X	esac
X
X	case $mode$getmode in
X	verifyalldisks)
X		report_p=$workdir/$breport
X		eval "$LABELQ"
X		fsnn=00
X		voln=1
X		while test $voln -le $nvol ; do
X			if test $voln -gt 1 -a $mtype != file -a $mtype != dir ; then
X				eval "$OFFLINE"
X				echo ""
X				echo "$pr: Finished verification of all the filesystems on volume '`expr $voln - 1`'."
X				echo "$pr: Please make sure volume '$voln' is in the $media drive."
X				eval "$MREADYQ"
X			fi
X			fslist=`awk '$1 == '$voln' {print $2 $3}' $workdir/$volmap`
X			fileskip=0	# initialize fileskip
X			for fs in $fslist ; do
X				## don't verify alldisks header
X				## or continued archives
X				case $fs in
X				*'(continued)'|alldisks_header)
X					fileskip=`expr $fileskip + 1`
X					continue
X				;;
X				esac
X				## increment two digit filesystem counter
X				eval "$FSNNPLUS1"
X				## handle backups in files on disk (uses $fsnn)
X				eval "$MDEV"
X				case $mtype in
X				dir|file)	diskfile=$mdev ;;
X				*)		diskfile='' ;;
X				esac
X				## handle filesystems continued onto next volume
X				# we know this filesystem wasn't continued
X				# (see also similar code for setting $do_auto)
X				# if the media is a disk file
X				if test $mtype = file -o $mtype = dir ; then
X					notcont=notcont
X				# else if this is the last volume
X				elif test $voln -eq $nvol ; then
X					notcont=notcont
X				# else if the first filesystem on the next
X				# volume is unknown
X				elif grep "'`expr $voln + 1`': .* unknown$" $firstblist > /dev/null ; then
X					notcont=''
X				# else if this filesystem *was* continued
X				elif grep " $fs (continued)" $firstblist > /dev/null ; then
X					notcont=''
X				# else this filesystem was *not* continued
X				else
X					notcont=notcont
X				fi
X				# tell child verify about its parent directory
X				case "$parent" in
X				'')	child=$wdir ;;
X				*)	child=$parent/$wdir ;;
X				esac
X				# tell child verify about
X				case $marg in
X				*dir)	childmarg=`echo $marg | sed -e 's/dir$/file/'` ;;
X				*)	childmarg=$marg
X				esac
X				# add "nomail" to child args if it isn't
X				# already set
X				case " $childargs " in
X				*" nomail "*)	: do nothing ;;
X				*)		childargs="$childargs nomail" ;;
X				esac
X				## OK, we're ready to issue the command!
X				echo ''
X				echo "$pr: ================================backup>>> verify $fs"
X
X				vcmd="./$pr verify $fs $childmarg $diskfile $extravol $child skip $fileskip $notcont $childargs"
X				echo "$pr: $vcmd"
X				curdir=`pwd`
X				cd $hdir
X				eval $vcmd
X				cd $curdir
X				fileskip=`expr $fileskip + 1`
X			done
X			voln=`expr $voln + 1`
X		done
X		echo "$pr: ================================backup>>> verify alldisks done"
X	;;
X	verify*)
X		case $bprog in
X		cpio)
X			echo "$pr: Getting '$getlist' from cpio archive." | tee -a $workdir/$report
X		;;
X		*dump*)
X			echo "$pr: Getting name of last file in archive." | tee -a $workdir/$report
X			echo "$pr: IGNORE the 'Specify next volume #:' question."
X		;;
X		esac
X		eval "$DO_GET"
X
X		# save the list of files we found
X		case $bprog in
X		cpio)	cp /usr/tmp/$flist $workdir ;;
X		*dump*)	cp $vlist          $workdir ;;
X		esac
X
X		# we put problems we find in $workdir/$failrpt
X		case $bprog in
X		cpio)
X			# simple checks
X			if test $getstat -ne 0 ; then
X				echo "$pr: cpio had problems reading archive, exited with status '$getstat'" >> $workdir/$failrpt
X			fi
X			for f in $breport $flist ; do
X				if test ! -s /usr/tmp/$f ; then
X					echo "$pr: Extraction of '/usr/tmp/$f' failed." >> $workdir/$failrpt
X				else
X					if test `wc -l < /usr/tmp/$f` -lt 2 ; then
X						wc -l /usr/tmp/$f >> $workdir/$failrpt
X						echo "$pr: '/usr/tmp/$f' should have at least 2 lines." >> $workdir/$failrpt
X					fi
X				fi
X			done
X			# if we're OK
X			if test ! -f $workdir/$failrpt ; then
X				echo "$pr: Extraction succeeded." | tee -a $workdir/$report
X				ls -l $getlist
X				# if it's a onedisk archive
X				# and we haven't already checked the label
X				# and it's a real tape
X				# and our parent didn't already do it,
X				# we need to check media contents vs. label here
X				if test $getmode = onedisk -a $mtype != dir -a $mtype != file -a -z "$parent" ; then
X					report_p=/usr/tmp/$breport
X					eval "$LABELQ"
X				fi
X			fi
X			rm -f $getlist
X		;;
X		*dump*)
X			## get last file in dump
X			# if nothing was dumped, we should get:
X			# '. is not on tape'	most versions of restore
X			# '. is not on volume'	SunOS 4.1.2, others?
X			x=`egrep '\. is not on (tape|volume)' $vlist  | sed 1q`
X			if test -n "$x" ; then
X				lastfile="$x"
X			# else get lastfile (usually a "leaf" but maybe a "dir")
X			else
X				lastfile=`grep '^leaf' $vlist | sort +1n -2 | tail -1 | awk '{print $NF}'`
X				# if there are only directories, e.g. it's
X				# a brand new filesystem with only lost+found
X				if test -z "$lastfile" ; then
X					lastfile=`grep '^dir'  $vlist | sort +1n -2 | tail -1 | awk '{print $NF}'`
X				fi
X			fi
X
X			## We decide an archive is OK if it looks like a
X			## "normal" empty archive, e.g. ". is not on tape"
X			## Known failures go in $workdir/$failrpt
X			case $lastfile in
X			# we have a problem
X			'')
X				# show any error messages from 'restore t'
X				echo "$pr: Error messages from 'restore t':"
X				tail -20 $vlist | tee -a $workdir/$failrpt
X				echo "$pr: Something went wrong with choosing the last file on the archive." | tee -a $workdir/$failrpt
X
X			;;
X			# nothing was dumped - a common incremental situation
X			# but wrong for a full dump.
X			'. is not on '*)
X				echo ''
X				echo "$pr: The 'restore tf ...' says '$lastfile', so nothing was dumped." | tee -a $workdir/$report
X				# if we can't check further
X				if test $getmode = onedisk ; then
X					# just give message
X					echo "$pr: Please check the tape label."
X					while : ; do
X						echo "$pr: Is this a full or incremental backup tape?"
X						echo $epre "$pr: Enter 'f' for full, 'i' for incremental: "$esuf
X						eval "$READ" ans
X						case $ans in
X						[fF]*)	bkp_was=full ; break ;;
X						[iI]*)	bkp_was=incr ; break ;;
X						esac
X					done
X				# else check this ourselves!
X				else
X					if grep '^#Invocation:.* incr.*' $workdir/$breport > /dev/null 2>&1 ; then
X						bkp_was=incr
X					else
X						bkp_was=full
X					fi
X				fi
X				if test $bkp_was = incr ; then
X					echo "$pr: This is a common incremental situation." | tee -a $workdir/$report
X				else
X					echo "$pr: This is wrong for a full dump." >> $workdir/$failrpt
X				fi
X			;;
X			# we have a real file name, so try to get it
X			*)
X				echo ''
X				echo "$pr: The last file in the archive is '$lastfile'."
X				case $mtype in
X				dir|file)	: do nothing ;;
X				*)		echo '' ; echo "$pr: Repositioning the $media again; Please wait." ;;
X				esac
X				eval "$SKIP2ARCHIVE"
X
X				## Q: if autoverify==true, can we really do it?
X				## A: if and only if one of these is true
X				##    * the entire archive is on the same tape
X				##    * it's a file
X				##    * it's a group of files in a directory
X				## (see also similar code for setting $notcont)
X				#
X				# if we aren't doing autoverify
X				if test $autoverify != true ; then
X					do_auto=false
X				# else we can handle disk files
X				elif test $mtype = file -o $mtype = dir ; then
X					do_auto=true
X				# else if there's more than one volume for
X				# a onedisk verify
X				elif test $getmode = onedisk -a $nvol -gt 1 ; then
X					do_auto=false
X				# else if we were told that this filesystem
X				# wasn't continued onto the next volume,
X				# we can handle it
X				elif test "$cont2next" = false ; then
X					do_auto=true
X				# else if our archive is on the last volume
X				# of the set, we can handle it
X				elif test $onvol = $nvol ; then
X					do_auto=true
X				# else if this filesystem is continued, it will
X				# say "... $fs (continued)" in $firstblist
X				elif grep " $fs (continued)" $firstblist > /dev/null ; then
X					do_auto=false
X					echo "$pr autoverify: Filesystem '$fs' is split over multiple volumes."
X					echo "$pr autoverify: Cannot actually autoverify '$fs'."
X					echo "$pr autoverify: Doing normal verify of '$fs'."
X					eval "$EXITQ"
X				# else if the operator didn't know the name of
X				# the first filesystem the next tape, punt.
X				elif sed -n -e "`expr $onvol + 1`p" $firstblist | grep ' unknown$' > /dev/null ; then
X					do_auto=false
X					echo "$pr autoverify: The first filesystem on the next volume is 'unknown', so"
X					echo "$pr autoverify: '$fs' might be split over multiple volumes."
X					echo "$pr autoverify: Cannot actually autoverify '$fs'."
X					echo "$pr autoverify: Doing normal verify of '$fs'."
X					eval "$EXITQ"
X				# else so far as we can tell this filesystem
X				# is on only one volume
X				else
X					do_auto=true
X				fi
X
X				# now try to get the last file in the archive
X				# echo's are for typical questions listed in
X				# comments on $GVRPT_ED
X				echo "$pr: Extracting into '`pwd`'" | tee -a $workdir/$report
X				case $do_auto in
X				true)	echo "$pr: IGNORE the 'Specify next volume #:' question." ;;
X				false)	echo "$pr: ANSWER the 'Specify next volume #:' question." ;;
X				esac
X
X				# $getlist, $rans, $rmode, $rout for $DO_GET
X				getlist="$lastfile"
X				case $do_auto in
X				true)	rans="{ echo 1 ; echo n ; } |" ;;
X				false)	rans="" ;;
X				esac
X				rmode="xv"
X				rout="2>&1 | tee -a $workdir/$report"
X				eval "$DO_GET"
X
X				# did we pass or not?
X				echo ''
X				pwd | tee -a $workdir/$report
X				lsout="`ls -ld $lastfile      2> /dev/null`"
X				lserr="`ls -ld $lastfile 2>&1  > /dev/null`"
X				if test -n "$lsout" ; then
X					echo "$lsout" | tee -a $workdir/$report
X				else
X					echo "$lserr" >> $workdir/$failrpt
X				fi
X			;;
X			esac
X		;;
X		esac
X	;;
X	esac
X
X	## take tape offline and finish get/verify report and send to $rptto
X	# if this backup/verify was called by a parent backup/verify
X	if test -n "$parent" ; then
X		# simply rewind tape
X		eval "$REW"
X	else
X		# else take the tape offline (if $offline is true)
X		# do $OFFLINE work in "/" in case user wants to
X		# wants to umount a filesystem we may have just restored;
X		# also run it in background so user doesn't have to wait
X		cd /		
X		eval "$OFFLINE" &
X	fi
X	cd $workdir		# finish up in $workdir
X	case $OS_S in
X	Linux)	edsilent_k=-s ;;
X	*)	edsilent_k=- ;;
X	esac
X	echo "$GVRPT_ED" | ed $edsilent_k $report
X	if   test $mode = verify -a -f $failrpt ; then
X		cat $failrpt
X		echo "$pr: Verify of '$fsproxy' FAILED."
X	elif test $mode = verify -a $multi != true ; then
X		echo "$pr: Verify of '$fsproxy' PASSED."
X	elif test $mode = verify -a $multi = true ; then
X		egrep 'PASSED|FAILED' $report
X		if grep FAILED $report > /dev/null ; then
X			echo "$pr: Verify of '$fsproxy' FAILED."
X		else
X			echo "$pr: Verify of '$fsproxy' PASSED."
X		fi
X	elif test -f $failrpt ; then
X		cat $failrpt
X	else
X		: no failure and not verify mode so do nothing
X	fi \
X	| tee -a $report
X	enddate=`date`
X	echo "#End time:   $enddate" >> $report
X	if test -n "$parent" ; then
X		grep "$pr: Verify of " $report >> ../$report
X		echo "#Verify end: $enddate" >> ../$report
X		eval "$MAILRPT"
X	fi
X;;
Xesac
X
X## Final cleanup
Xcd $workdir
Xecho ''
X# while we're sending mail and there was a problem we need to report, and
X# we don't have a parent backup/verify, send $report to $propbto
X# (the while loop gives us something to break out of if we're doing a verify)
Xeval "$PROBTO"		# figure out who we're supposed to send problems to
Xwhile test $mail = true -a -n "$probto" -a \( -s $probsend -o -s $failrpt \) -a -z "$parent" ; do
X	while echo $mode | egrep 'get|verify' > /dev/null ; do
X		echo $epre "$pr: Do you want to send a '$mode' problem report to $probto? [yn] "$esuf
X		eval "$READ" ans
X		case $ans in
X		[yY]*)	echo "$pr: OK, will do." ; break ;;
X		[nN]*)	break 2	;;
X		*)	continue ;;
X		esac
X	done
X	mailerr=mail.err	# save stdout and stderr from $MAILER errors
X	{
X		# show real operator login for any automated processer scripts
X		echo "%login=$operlogin"
X		# report *new* problem filesystems if there are any
X		case $mode in full|incr|tincr) echo 'NEW problem filesystem(s) BEGIN:' ;; esac
X		test -f $probsend && cat $probsend
X		case $mode in full|incr|tincr) echo 'NEW problem filesystem(s) END.'   ;; esac
X		echo ''
X		cat $report
X		# if we're doing a get or verify, we may have extracted a
X		# backup report file from the media
X		echo ''
X		case $mode in
X		get|verify)
X			if test -f $breport ; then
X				echo "Sending extracted backup report:"
X				cat $breport
X			else
X				echo "No extracted backup report to send."
X			fi
X		;;
X		esac
X	} \
X	| $MAILER -s "backup $mode failed $lhost:~backup/$wdir" $probto > $mailerr 2>&1
X	# if we detect a mailer failure
X	if test $? -ne 0 -o -f dead.letter -o -s $mailerr ; then
X		echo "$pr: WARNING: The mailer '$MAILER' had"
X		echo "$pr: problems sending a failure report!!!"
X		test -s $mailerr && cat $mailerr
X	# else
X	else
X		# record the fact that we've tried to report this problem
X		test -f $probsend && cat $probsend >> $probsent
X		# make sure $probsent is readable by backup account
X		chmod 644 $probsent
X	fi
X	# make sure we break out
X	break
Xdone
X
X# if we just completed a backup, ask if they want to report problems
X# and tell the user how to label any tapes
Xcase $mode in
Xfull|incr|tincr)
X	echo ''
X	while test $probq = true ; do
X		echo $epre "$pr: Do you want to report any problems with this backup? [yn] "$esuf
X		eval "$READ" ans
X		case "$ans" in
X		[yY]*)
X			echo "$pr: Enter reason for failure.  Type as many lines as you want."
X			echo "$pr: Then type '<ctrl>D' when you are done:"
X			cat >> $failrpt
X			echo "$pr: Thank you."
X			break
X		;;
X		[nN]*)
X			echo "$pr: No failure will be reported.  Thank you."
X			break
X		;;
X		*)	
X			echo "$pr: Answer 'y' or 'n'."
X			continue
X		;;
X		esac
X	done
X	case $mtype in
X	dir|file)
X		: no labels for a disk file or directory
X	;;
X	null)
X		# no labels for null archive, but we should remind user
X		echo ''
X		echo "$pr: WARNING! media is '$media' !!!"
X		echo "$pr: NO BACKUP WAS MADE !!!"
X	;;
X	*)
X		echo "$pr: Please label the backup $media(s) as shown below."
X		cat $firstblist
X	;;
X	esac
X;;
Xesac
X# if we're not a child verify
Xif test -z "$parent" ; then
X	echo "$pr: We're done.  Thanks!  Bye!"
Xfi
Xchown backup . `echo * | sed -e "s/$pr //" -e "s/$pr\$//"`
X# Silently expire any old work directories if we're doing a backup.
X# Don't do this if we are doing a get or verify, since we may be on a machine
X# that has a monthly backup schedule, and we may not want to have these old
X# work dirs disappear.
Xcase $mode in
Xfull|incr|tincr)
X	cd $hdir
X	# Toss stderr from subshell so operator doesn't see
X	# the background PID for the "find".
X	# Toss stdout from the subshell so operator doesn't see
X	# "Sending output to 'nohup.out'" from nohup
X	(
X		# Must nohup "find" and do it in background so it can continue
X		# after script exits.  Throw out stderr since
X		# "[01][0-9][0123][0-9].*" won't exist on new alldisks hosts.
X		nohup find [01][0-9][0123][0-9].* -type d -mtime +$expire -exec /bin/rm -rf '{}' \; 2> /dev/null &
X
X	) > /dev/null 2>&1
X	# we don't care about nohup.out - sleep 3 seconds to let previous
X	# nohup create nohup.out before we blow it away
X	( sleep 3 ; rm -f nohup.out & ) > /dev/null 2>&1
X;;
Xesac
X
X## Th-th-th-that's all, folks!
SHAR_EOF
echo 'File src/backup/backup is complete' &&
chmod 0755 src/backup/backup ||
echo 'restore of src/backup/backup failed'
Wc_c="`wc -c < 'src/backup/backup'`"
test 158749 -eq "$Wc_c" ||
	echo 'src/backup/backup: original size 158749, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= src/backup/bkp.site ==============
if test -f 'src/backup/bkp.site' -a X"$1" != X"-c"; then
	echo 'x - skipping src/backup/bkp.site (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting src/backup/bkp.site (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'src/backup/bkp.site' &&
X:
X# This is "bkp.site", a configuration file sourced by
X# the 'alldisks' backup script.  Remember - it is Bourne shell "sh" code.
X# If you break it, it will break 'alldisks' in a more or less serious fashion.
X#
X# You should read through bkp.site carefully, making changes depending on what
X# you'd like to see at your site.
X#
X# You will probably leave most of this unchanged.  However, you may want
X# to do something about the PROBTO macro.  If you have HP-UX 8.0 at your
X# site, you may want to consider uncommenting the HACK4HPUX8 macro.
X#
X# If you leave everything unchanged, then you actually don't need to install
X# this file.  Whatever you do, you can change your mind later and re-install
X# or de-install it as appropriate.
X#
X# Some of the parameters set here are actually MACROs.  MACROs are
X# single-quoted or double-quoted strings containing Bourne shell code.
X# They are used by eval'ing them within double-quotes, like this:
X#	eval "$MACRO"
X# MACROs are often used where we might use Bourne shell functions if
X# they existed everywhere.
X#
X# Variables with "CAPITAL" letters are used throughout these scripts to
X# designate several different types:
X# 	1) System environment variables (e.g. $PATH)
X#	2) sahead/saenv variables (e.g. $STASH and $RSH_C)
X#	3) simple strings (e.g. $USAGE)
X#	4) macros (e.g. $PROBTO)
X#
X# Variables with "lowercase" letters are used throughout these scripts to
X# designate simple local (unexported) variables.
X#
X# bkp.site has simple variables followed by MACROs.
X
X# ============================================================================
X##
X##		Simple Variables for 'inst-alldisks' and 'linst-alldisks'
X##
X## These four simple variables ($bhdir, $bkpuid, $chkaixdev, $perm) are
X## only used by 'inst-alldisks' and/or 'linst-alldisks'.  All the other
X## variables and MACROs are only used by the alldisks script itself,
X## and are listed in alphabetical order.
X
X## bhdir
X# Default home directory for backup account
X#
X# Change and uncomment if you want it to be something else
X# bhdir=/home/backup	# (default /home/backup)
X
X## bkpuid
X# Default UID for backup account
X#
X# Uncomment and pick a UID which doesn't conflict with other UIDs at your site.
X# bkpuid=194		# (default 194)
X
X## chkaixdev
X# Default is for 'linst-alldisks' not to warn about AIX video drives using
X# only half the tape capacity.
X#
X# chkaixdev=true	# warn about AIX 3.X video drives
X# chkaixdev=false	# no warning about AIX 3.X video drives (default)
X
X## perm
X# Try to install the backup script as setuid or not setuid.
X# Setuid scripts aren't supported everywhere, so this is only what we try
X# to do if $perm is set to 4755.
X#
X# Uncomment one of these
X# perm=755		# not setuid root (default)
X# perm=4755		# setuid root
X
X# ============================================================================
X##
X##		Simple Variables for 'alldisks' Backup Script
X##
X## These simple variables below are only used by the alldisks script itself
X## and are listed in alphabetical order.
X
X## $expire
X# How long should we keep old log directories?  We'll remove anything
X# over $expire days old.  Backup home directories on cpio machines
X# are typically larger than ones which use BSD dump, but experience
X# shows that keeping them 21 days will add roughly 0.5Meg to 2Meg
X# to backup's home directory.
X#
X# Uncomment and pick some positive integer
X# expire=21		# (default 21)
X
X## $incr
X# Incremental dump level (alldisks cpio backups only understand level "full"
X# and level "incr")
X# In general, it is recommended that you do a full backup of each filesystem
X# once per week, and an incremental backup of each filesystem on the
X# other days.
X#
X# Uncomment and pick some integer between 1 and 9
X# incr=5		# (default 5)
X
X## $joke
X# Try it, you'll like it!  (or hate it!)
X#
X# Uncomment one of these lines:
X# joke=true		# do cpio joke if using cpio (default)
X# joke=false		# don't do cpio joke
X
X## $mail
X# Do we send backup/get/verify reports to $rptto and problem reports to
X# $probto?  (See also $rptto below)
X#
X# Uncomment one of these lines:
X# mail=true		# send reports to $rptto (default)
X# mail=false		# don't send reports to $rptto
X
X## $probto
X# Who do we send problems to?  (See also $PROBTO macro below)
X#
X# Uncomment this line and enter a list of valid mail recipients
X# probto="acct1 acct2"	# (default root)
X
X## $rptto
X# Who do we send backup/get/verify to?  (See also $mail above)
X#
X# Uncomment this line and enter a list of valid mail recipients
X# rptto="$STASH"	# (default "$STASH")
X
X## $offline
X# Some sites don't like to leave tapes ejected when the backups are done.
X# If ejected, tapes are more vulnerable to dust or being hit.  On the
X# other hand, some drives take a long time to eject a tape and having
X# 'alldisks' do it for you will save a lot of time.
X#
X# Uncomment one of these lines:
X# offline=true		# take tape offline when done (default)
X# offline=false		# don't take tape offline when done
X
X# ============================================================================
X##
X##		MACROS
X##
X
X## HACK4HPUX8 - work around HP-UX 8.0 dump/rdump bug
X# Make sure /etc/dumpdates is 664, group operator.
X# Best if readable by world, because HP-UX 8.00 may foil us otherwise.
X# Besides, it probably can't hurt if ordinary users can read it.
X# HP-UX 8.00 has a bug where "dump" called from a setuid script
X# can read a 660 dumpdates but "rdump" can't, even though they are
X# the same binary!
X#
X# If you have this bug, and you want to work around it, and don't
X# mind opening permissions up a bit, you can try uncommenting the 4 lines
X# below.  They just chmod/chgrp the dang file, and hope that does
X# the trick.  Note: later on in the script, similar code will be called
X# *and the script will exit* if we actually trip over the bug with
X# the first failed dump/rdump.  That's because the dump has not
X# been properly logged (but hopefully all following dumps will be).
X#
X#HACK4HPUX8='
X#chmod 664 /etc/dumpdates
X#chgrp operator /etc/dumpdates
SHAR_EOF
true || echo 'restore of src/backup/bkp.site failed'
fi
echo 'End of saenv5.01 part 6'
echo 'File src/backup/bkp.site is continued in part 7'
echo 7 > _shar_seq_.tmp
exit 0
