Newsgroups: comp.sources.unix
From: rca@queernet.org (Bob Arnold)
Subject: v28i150: saenv-5.01 - SysAd Environment (OS_Research/Backup) Suite, Part04/07
References: <1.784011877.15815@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: rca@queernet.org (Bob Arnold)
Posting-Number: Volume 28, Issue 150
Archive-Name: saenv-5.01/part04

#!/bin/sh
# this is saenv.04 (part 4 of saenv5.01)
# do not concatenate these parts, unpack them in order with /bin/sh
# file src/backup/doc/alld.features continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 4; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping src/backup/doc/alld.features'
else
echo 'x - continuing file src/backup/doc/alld.features'
sed 's/^X//' << 'SHAR_EOF' >> 'src/backup/doc/alld.features' &&
X		Notes on alldisks, dump, and cpio		p. 1 of 2
X
XBSD "dump" command syntax and example:
X	dump <key> <options> <filesystem> 
X	dump 0ufbsd /dev/nrmt2h 10 2200 6250 /dev/rra3g
X
XBSD "dump" design features:
X1)  Backs up entire filesystem
X2)  Backs up *only* entire filesystem
X3)  Can do levels 0-9 (we use "0" for fulls and "5" for incrementals)
X4)  Handles multi-volume archives
X5)  Makes sure each volume is writable before attempting write
X6)  Handles EOT well (by asking operator to restart the current dump volume)
X7)  Puts list of files it *intends* to back up at head of dump archive
X8)  Archive can be restored anywhere since data is stored w/ *relative* paths
X9)  User interface is good
X10) All messages from "dump" actually *say* that they are from dump
X11) Reports exit status (0=successful, 1=startup errors, 3=abort/failure)
X12) Logs time and level of successful backups (in /etc/dumpdates file) ("u" key)
X13) It is robust
X14) It has a great interactive user interface for file recovery called "restore"
X15) Filesystem does not have to be mounted to back it up
X16) Understands both (raw) filesystem names and mount points (from /etc/fstab)
X17) Handles writing archive to another machine over the net
X
XBSD "dump" problems:
X1)  Archive does not store info on how the filesystem is currently mounted
X2)  Older versions don't look up mount point in /etc/fstab carefully enough
X3)  Under SunOS 4.x (and some others?) "dump" runs as your realuid, so
X    the "backup" account must be in a group which can read the raw device
X
X=============================================================================
X
XAT&T "cpio" command syntax and examples:
X	cpio -o[aBcv]				# cpio "output" mode
X	cpio -i[bBcdfmrsStuv6] [patterns]	# cpio "input" mode
X	cpio -p[adlmuv] [directory]		# cpio "pass" (one-pass) mode
X	cd /usr ; find . -print | cpio -ocB > /dev/rmt8
X	cd $target ; cpio -icBudm [patterns] < /dev/rmt8
X	mkdir $todir ; cd $fromdir ; find . -print | cpio -pudm $todir
X
XAT&T "cpio" features:
X1)  Backs up directories, not filesystems
X2)  Accepts unlimited list of input files for archiving
X
XAT&T "cpio" problems:
X1)  Backs up directories, not filesystems
X2)  List of input files must be read from standard in
X3)  Archive can only be written to standard out
X4)  Older versions don't handle multi-volume archives at all, and newer
X    versions don't handle multi-volume archives well
X5)  Does not put header file at beginning of archive
X6)  Does not handle putting archives on a remote machine
X7)  Updates access times of files it reads
X8)  About a hundred more problems that you don't want to hear about ...
X
X
X		Notes on alldisks, dump, and cpio		p. 2 of 2
X
XHere are examples of the 'alldisks' backup script command syntax:
X	backup help
X	backup examples
X	backup full   /usr/rti       cart1
X	backup incr   alldisks       cheeta:tape
X	backup get    onedisk        dat0
X	backup get    listdisks      tape0
X	backup verify /m/collie/home poodle:video
X	backup verify lastdisk       video2
X	backup verify alldisks       dat0
X	backup devcheck              video1
X	backup devcheck              video,/dev/rmt0,/dev/nrmt0
X
XFeatures of the 'alldisks' backup script:
X1)  Backs up *only* entire machines, or ...
X2)  Backs up *only* entire filesystem, even for cpio backups
X3)  Can do levels "full" or "incremental", even for cpio backups
X4)  Handles multi-volume archives, even for cpio backups
X5)  Makes sure each volume is writable before attempting write for cpio backups
X6)  Handles EOT well (uh, thanks to "dump"; cpio alldisks doesn't handle EOT
X    but luckily we can avoid actually hitting EOT by specifying the number
X    of 5k blocks for the drive in bkp.media)
X7)  Puts list of filesystems it *intends* to backup (and other info too) at
X    head of multi-filesystem archive
X8)  Archive can be restored to any host with the same OS (thanks to "dump"
X    and careful use of cpio)
X9)  User interface is good
X10) All messages from "backup" actually *say* that they are from backup
X11) Reports exit status of dump/restore/cpio
X12) Logs time and level of all backups, even unsuccessful ones:
X	each successful "dump" backup logged in /etc/dumpdates
X	each successful "cpio" backup logged in ~backup/cpiodates
X	all backups logged in ~backup/$workdir/*
X13) It is relatively robust, even when using cpio
X14) It has its own great interactive user front end for file recovery
X	makes sure user set up is OK before starting "restore"
X	makes sure user set up is OK before starting "cpio -icB < /dev/whatever"
X	(entire cpio restore only; interactive cpio restore does not exist)
X15) Backs up all mounted filesystems (except those listed in ~backup/bkp.donot)
X16) Understands *only* mounted filesystems
X17) Uses config file (/etc/dist/bkp.media) which is distributed to all boxes
X18) Verifies rewind and no-rewind device names in bkp.media for every backup
X19) Checks cartridge tapes for correct "ftpi" density
X20) Warns the user about known problems
X21) Tries to send mail to specified email address in the event of *some*
X    known and *any* user-reported failures (this has often notified support
X    staff that there are problems before the users discover them)
X22) Tells the user the name of the first filesystem on each volume
X23) Rewinds the media and takes it offline (where possible)
X24) The script sources /etc/dist/sahead, which sources /etc/saenv
X25) Works on a wide variety of UNIX's (1st release 17 hosts, now >100 hosts)
X26) The code is available, mostly readable, well-maintained, & heavily commented
X27) Has saved major labor, media, and storage costs
X28) Does all this even when using cpio
X29) Uses dump when it can (regardless of what it is called), and cpio if it must
X30) Can verify the archive is readable
SHAR_EOF
echo 'File src/backup/doc/alld.features is complete' &&
chmod 0644 src/backup/doc/alld.features ||
echo 'restore of src/backup/doc/alld.features failed'
Wc_c="`wc -c < 'src/backup/doc/alld.features'`"
test 5703 -eq "$Wc_c" ||
	echo 'src/backup/doc/alld.features: original size 5703, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= src/backup/doc/alld.q ==============
if test -f 'src/backup/doc/alld.q' -a X"$1" != X"-c"; then
	echo 'x - skipping src/backup/doc/alld.q (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting src/backup/doc/alld.q (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'src/backup/doc/alld.q' &&
X
X			Questions About 'alldisks'		p. 1 of 1
X
X1) How do I tell if a tape is good?
XAns: you can't, not really, not without an awful lot of work and
Xunderstanding of exactly how the tapes were made.  It's usually
Xeasier to do the backup again if you have any questions.  Of course
Xdoing it again will also be pointless if you know that some problem
Xwill happen again next time.
X
X2) Does this bread error message from dump mean there was a problem?
X	DUMP: bread: (THIS SHOULD NOT HAPPEN) . . . 
X(maybe?) followed by
X	DUMP: do you want to continue? (yes/no)".
XAns: Yes.  This is a "block read" error, and it means that "dump" had a
Xproblem reading the disk, usually due to a bad block on the disk.
XObviously this *should* never happen.  If you get this kind of error
Xmessage while making a dump, there's no harm in continuing with the
Xbackup, but you shouldn't put too much faith in the resulting tape
Xeither.  If you have the time to deal with it, great, but otherwise
Xthere's no harm in punting and falling back on the previous known
Xsuccessful backups.
X
XIn general, if you get a *read* error of any sort from a disk,
Xthat will mean the dump is not completely trustworthy.  This problem
Xshould be reported.
X
X3) What if I get a read error from a filesystem while making an
Xalldisks backup?
XAns: Then the dump of that filesystem won't be completely trustworthy.
XHowever, other dumps on the alldisks tape(s) may be just fine.  In that
Xcase, you can trust some dumps in the alldisks backup, but not others.
X
X4) Does these write error messages mean there was a problem?
X# Pyramid(dragon), Ultrix 2.0/3.0:
X#       DUMP: Write error on tape 4
X# CCI(camel), Gould(gopher), Pyramid(dragon), Sequent(salmon):
X#       DUMP: Tape write error on tape 1
X# 4.3BSD(cobra), CCI(llama), Mt. Xinu(moose), Sun(ewok):
X#       DUMP: Tape write error 277 feet into tape 4
XFollowed by:
XDUMP: Do you want to restart? (yes/no)"
XAns: Yes, "dump" thought there was a problem with writing to the tape.
XAnd, you should always say "yes" to restart the tape.
X
X5) So, just what caused the "Tape write error", anyhow?
XAns: There are three possible answers:
XAns 1) "dump" thinks the tape was longer than it really is.  Obviously
Xyou'll get this problem if you put in a 600 foot 9track tape.  A much
Xrarer cause is that some parameter is wrong in /etc/dist/bkp.media, e.g.
Xsuppose the 9track tape length is specified as "2700" feet.  The fix in
Xeither case is obvious (but make sure the *master* bkp.media gets fixed too.)
XAns 2) The tape really has a bad spot in it.  The solution here is to
Xput in a new tape (but you were going to do that anyway, right?).
XAns 3) The tape is an alldisks tape, and it did a bunch of successful
Xdumps to this tape before the current dump started.  That almost filled
Xup the tape, and when this dump got going it didn't have as much room
Xas it thought it did.  Remember, when a dump starts, it always thinks
Xthat it's at the beginning of the tape.  dump has never heard of an
Xalldisks backup.  Solve this by putting in a new tape, too.
X
X6) Do I ever have to lie to the alldisks script?
XNo.  Always tell it the truth.  But you do sometimes have to lie to the
Xrestore program if you are doing an interactive restore using
X"backup get /fsname [host:]media"
XRemember, the BSD restore program has never heard of an alldisks archive.
XIt always thinks it is starting to read a BSD dump at the beginning of a
Xtape.  So if you are reading a dump in the middle of an alldisks tape
Xset, you should always say "1<return>" when restore asks you to
X"Specify next volume #:".  You have to lie to restore no matter which
Xalldisks volume you are trying to read.
SHAR_EOF
chmod 0644 src/backup/doc/alld.q ||
echo 'restore of src/backup/doc/alld.q failed'
Wc_c="`wc -c < 'src/backup/doc/alld.q'`"
test 3637 -eq "$Wc_c" ||
	echo 'src/backup/doc/alld.q: original size 3637, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= src/backup/doc/gen.restore.q ==============
if test -f 'src/backup/doc/gen.restore.q' -a X"$1" != X"-c"; then
	echo 'x - skipping src/backup/doc/gen.restore.q (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting src/backup/doc/gen.restore.q (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'src/backup/doc/gen.restore.q' &&
X
X		Generic Questions About Restoring Files		p. 1 of 10
X		Bob Arnold (rca@ingres.com)
X		Tue May  1 1990, revised Apr  8 1992
X
XIn general, there is a list of questions that the user should be able
Xto help you with.  The more they can tell you, the easier and faster it
Xwill be to get it back for them.  If they can't tell you what you need
Xto know, you'll have to figure it out as best you can.
X
Xa) A list of files/directories/filesystems to be recovered
Xb) Which are they?  files? directories? filesystems?
Xc) What filesystem did the data really lived on?	# Basically, what tapes
Xd) What machine did the data really lived on?		# should I get this
Xe) When was the last good version modified?		# data back from?
Xf) How much disk space did it take up?		# Will it fit back on the disk?
Xg) Where should the data be restored to?	# often back where it came from
Xh) Who should own the data?			# usually the original owner
X
X(If this list is incomplete, consult lylace's checklist.)
X
XMy suggestion: Call the user.  email is good for documenting the original
Xrequest, and it's good for listing filenames - items a) and b) above.
XThat way, the user can't say "I told you file 'x'" when they didn't.
XBut it's not very good for making sure you have the real goods on
Xquestions c) through h).  Conversation is best to make sure that they will
Xtell you as much as they can.  Ask probing questions if need be, e.g.
X"Is 'x' a directory or a file?"
X
XIn sum - dig up as much info as you can.  Talking with the user makes
Xthem apreciate how much work it is to help them out.  Talking with them
Xlet's them really know that someone is handling their request.  It's the
Xfastest way to clarify unclear requests.  It's easier to talk than
Xtyping email.  It's often the only way to get the info you really
Xneed.  Last, the user can't really be expected to know, much less tell
Xyou in their original request, all the info you need to help them out.
XMany of them really don't have a clue how much research is involved and
Xshouldn't be expected to.
X
XWith the information from a) through f), you should be able to find out:
Xi) which full and/or incremental backups their data might be on
Xj) when they were made
X
XArmed with this info, you can call the user again, tell them this info,
Xand figure out:
Xk) Will the most recent full do the trick, or do I need to restore from the
Xlatest incremental, or do I need both the full *and* the latest incremental?
X
XLast, you should find out from them
Xl) Is there a current version of their data currently on line?
Xm) If so, do they care about it?
Xn) If they care about it, is the real path to it the same as the data they
Xwant to have recovered?
Xo) If they don't care about it, can you remove it or write over it (destroy
Xit) with the version you're about to get from backups for them?
X
XOne occasionally handy question to ask them:
Xp) How much work would it take for them to recreate the lost data if
Xyou can't find it on backups?
X
X		Generic Questions About Restoring Files		p. 2 of 10
X
X		Common Problems and Research Methods:
X
X1) What if the user can't tell you very much?
XAns: They at least have to know the names of the files/directories they want
Xback.  They also should be able to tell you how they accessed them.  Like
Xdid they do a "cd such-and-such-dir ; vi screwed.up.file", or something.
XWith whatever info you get from them, you can become root on that machine
Xand try to duplicate their access methods.
X
X2) Suppose they only know what the file is called on some machine?
XAns: Log into that machine, and try to find the directory the data
Xused to live *in* (i.e. what was the parent directory for the data)
Xbefore they trashed or removed it.  Then, there are two handy methods:
X# df .		# df of ".", i.e. report "disk free" space in my current dir.
X		# This is the easiest way but it only works on BSD systems
X# df ; pwd	# do a "df" to list mounted filesystems, and "pwd" to figure
X		# out what your real current directory is, and hence which
X		# filesystem your current directory is in.
X
XThis may show you that the file is really an NFS filesystem.
X"/dev/" filesystems are local - they really live on the machine.
X"host:" filesystems really live on "host" - note the colon (:) character.
XIf it's really an NFS filesystem, you'll have to log into the remote
Xhost and look around.
Xk9 651# df
XFilesystem            kbytes    used   avail capacity  Mounted on
X/dev/xd0a              15720    8489    5659    60%    /
X/dev/xd0g              71615   62150    2303    96%    /usr
X/dev/xd0h             444433       9  399980     0%    /install
X/dev/xd1h             472833  277110  148439    65%    /home
X/dev/xd1a              15720      44   14104     0%    /tmp
X/dev/xd1g              43215       9   38884     0%    /usr/var
Xhound:/fe12           799669  698484   21218    97%    /m/hound/fe12
Xmoose:/usr/manuals    140488  118785    7654    94%    /m/moose/usr/manuals
Xmoth:/usr/local/icon  988508  860342   29315    97%    /usr/local/icon
Xmoth:/usr/local/src   988508  860342   29315    97%    /usr/local/src
X
XFor example, if someone tells you that they lost a file from k9 called
X/m/hound/fe12/important, then you'll have to log onto hound and look
Xfor it in /fe12 (on hound).
X
XIt will also be useful to figure out the complete path to the data's
Xparent directory.  Once again pwd comes in handy.
Xk9 652# pwd
X/home/k9/rti/sys/rca
X
X		Generic Questions About Restoring Files		p. 3 of 10
X
X3) What about symbolic links?
XHard linked files have to be in the same filesystem.  Unlike hard links,
Xsymbolic links can point from one filesystem into another.  Example:
X
Xk9 653# ls -l /usr/rti
Xlrwxrwxrwx  1 root           12 Dec 22 14:52 /usr/rti -> /home/k9/rti
X
XThat's why is it's a good idea to "cd parentdir ; df ." to find out the
Xfilesystem where the lost data really lived.  For example, let's say
Xthat Bob Arnold, who's login name is "rca", lost a file in his home
Xdirectory called "important".  You would become root on k9 somehow, and
Xthen:
X
Xk9 654# cd ~rca		# rca's home directory is the "parentdir"
Xk9 655# ls important	# see if some version of the file is there
Ximportant not found	# it's not
Xk9 656# df .		# df of the filesystem containing my current directory
XFilesystem            kbytes    used   avail capacity  Mounted on
X/dev/xd1h             472833  277117  148432    65%    /home
Xk9 657# pwd		# get the real full path to my current directory
X/home/k9/rti/sys/rca
X
XThis would show you need the apropriate backup of the k9:/home filesystem.
X
X4) When was a certain filesystem backed up?  And was it a full or an
Xincremental?
XAns: Unfortunately there are two places to look for this info.
XOn machines that have BSD's "dump" program (all BSD-based machines and
Xeven a few System V machines like camel and the HP's), you can look in
X/etc/dumpdates for the device name of the filesystem in question.
XGoing back to the example of k9:~rca/important, we already know that
Xrca's home directory really lives in the /home filesystem, and that
Xthe partition/device currently mounted as /home is /dev/xd1h.  Check this:
X
Xk9 658# egrep /dev/rxd1h /etc/dumpdates	# note the extra "r" for raw device
X/dev/rxd1h       0 Thu Feb 15 02:24:42 1990
X/dev/rxd1h       5 Wed Feb 21 05:59:18 1990
X
XLook in the second column, which is where the dump level is recorded by dump.
XA level 0 is a full, and a level 5 is an incremental.
X
XOne catch - dumpdates does not contain a history of all successful dumps.
XIt only records the last successful dump for each filesystem for each level.
XIf there were also successful level 5's of k9:/dev/rxd1h on the Monday and
XTuesday before Feb 21, that won't be recorded there.
X
XSo the second place to look for this info is in backup's home directory.
XThat's where you have to look if the machine is a System V box and it
Xdoesn't have BSD dump.  The procedure (let's say on raccoon) is
X# csh					# root's login shell on raccoon is "sh"
Xraccoon# cd ~backup			# now cd to backup's home directory
Xraccoon# grep /usr/rti cpiodates	# and look for /usr/rti in cpiodates
Xfull    0406171292      Mon Apr 06 17:12 1992   /usr/rti
Xincr    0407180392      Tue Apr 07 18:03 1992   /usr/rti
X
X
X		Generic Questions About Restoring Files		p. 4 of 10
X
X5) Suppose the user doesn't know when the latest "good" version is?
XAns: Then the user is probably a ninny.  Unfortunately, this also means
Xthat you may have to start with the most recent backup, and work your way
Xback in time through older and older backups until you find something
Xthat will make the user happy.  This is a good time to ask them how
Xmuch work it would be to recreate the file from scratch.
X
X6) Where do you restore the data to?
XAns: That depends on whether it will it fit where the user wants it?
XRe where the user wants it, sometimes they don't mind if you clobber the
Xcurrent (possibly mangled) version, sometimes they do.  It's simpler if
Xthey don't care about whatever current version might be on line.  Let's
Xlet that go for a minute, and look at whether it will fit.
X
XItems f) and b) above are attempts to get at that question.  Sometimes
Xthe user will say that it was a simple little file.  Sometimes they'll
Xsay it was a huge directory, or (rarely) even a whole filesystem.
XSometimes they'll even know how big it was.  This is why it's a good idea
Xto call the user - it makes a big difference if their data was 1Meg or 100Meg.
XEven a ballpark estimate is helpful.
X
XIf it's a directory, it's probably not tiny.  Maybe it's only small, maybe
Xit's big.  Filesystems come in all sizes, too.  A reasonable guess can often
Xbe made by looking at the current system.
X
XThen you have to figure out whether there's space where they want it.
XAgain, "df" comes in handy since it tells you how much space is free.
XBut remember:
X	o	BSD "df" tells you the answer in kilobytes (1024char/block)
X	o	System V "df" reports in 512character blocks.  
X	o	1Meg = 1024 "BSD blocks"
X	o	1Meg = 2048 "SysV blocks"
X
XBack to k9:
Xk9 659# df .		# df of my current directory
XFilesystem            kbytes    used   avail capacity  Mounted on
X/dev/xd1h             472833  277117  148432    65%    /home
X
XIn this example, it would be pretty surprising if ~rca/important didn't fit
Xin k9:/home.
X
XIf the user does have a current version on line, maybe it's about the
Xsame size as the version your going to recover from backups.  In that
Xcase you can use the "cd current_version_dir ; du -s ." to get the
Xdisk usage summary of that directory.  "du -s" can take a while if
Xthe directory in question has lots of subdirectories in it.
X
Xk9 660# cd ~rca ; du -s .
X124	.	# this means that "." occupies 124k
X
XAgain, BSD and SysV report in different units (1k and 0.5k respectively).
X
X
X		Generic Questions About Restoring Files		p. 5 of 10
X
X			A Simple Research Example:
X
XLet's say the user sends a request like:
X
X	Please restore the file "~rca/stat_rpt/Nov89" which I accidentally
X	removed from my account on k9.  My home directory is in the
X	/home filesystem on k9.  I haven't touched the file since I wrote
X	my report back in November.  Call me at x2819 if you have any
X	questions.  Thanx!
X
X			Bob
X
XWhat questions does this answer?  (This is left as an exercise for the reader.)
XHere's a list of all the questions:
X
Xa) A list of files/directories/filesystems to be recovered
Xb) Which are they?  files? directories? filesystems?
Xc) What filesystem did the data really lived on?	# Basically, what tapes
Xd) What machine did the data really lived on?		# should I get this
Xe) When was the last good version modified?		# data back from?
Xf) How much disk space did it take up?		# Will it fit back on the disk?
Xg) Where should the data be restored to?	# often back where it came from
Xh) Who should own the data?			# usually the original owner
Xi) which full and/or incremental backups their data might be on
Xj) when they were made
Xk) Will the most recent full do the trick, or do I need to restore from the
Xlatest incremental, or do I need both the full *and* the latest incremental?
Xl) Is there a current version of their data currently on line?
Xm) If so, do they care about it?
Xn) If they care about it, is the real path to it the same as the data they
Xwant to have recovered?
Xo) If they don't care about it, can you remove it or write over it (destroy
Xit) with the version you're about to get from backups for them?
Xp) How much work would it take for them to recreate the lost data if
Xyou can't find it on backups?
X
XOnce these questions are answered, you grab the appropriate tapes and get
Xthe file back for him.  What, you want to know how?  Well, that's in the
Xnext section.
X
X		Generic Questions About Restoring Files		p. 6 of 10
X
X			Actual File Restores:
X
X		Simple Full (i.e., "onedisk") "dump"s:
X
XTo recover lost data from a simple "onedisk" "dump" tape, do:
X
X1) Get all the research done that we've talked about - questions a) thru p)
Xabove.  This includes the directory that you're going to put the data in.
X
X2) Get the appropriate dump tape(s) from the tape racks or offsite storage
Xor wherever.
X
X3) load the first tape of the dump into the tape drive.
X
X4) become root (via login or "su") on the machine that you're restoring data to.
X
X5) Figure out, using /etc/dist/backup.media, which machine has the tape
Xdrive that you're going to use.  The drive obviously has to be of the same
Xtype and density that the tape was made in.  Hopefully, you'll be able to
Xuse a drive on the machine you're restoring the data to; if not, use one
Xon a compatible remote machine.  It's usually (but not always) possible
Xto use the same machine and drive that the tape was written on.
X
X6) If it's a multi-volume dump (that's *different* from a multi-volume
Xalldisks backup), decide what is the fastest way to get your file(s).
XDo you want to work from the first volume towards the last, or the
Xlast volume towards the first?  Either method will work, but usually
Xone will be faster than the other, depending on how many files you
Xactually are getting off the dump tape.  Here's the general rule:
X
X	o	if you're getting only a few files, work last to first
X	o	if you're getting lots of files, work first to last
X
XWhy?  Because every UNIX file has an "inode" (Index Node) number associated
Xwith it.  The dump knows the inode number, and puts files on tape in
Xascending inode order.  When restore looks at the first file on a dump
Xvolume, it can tell whether the file is somewhere farther along in the
Xdump or not.  If it's farther along, restore keeps reading the tape;
Xif not, it asks you to choose another volume.
X
XWhat if you only want one file and its inode number is, say 132?  Is it
Xfaster to work first to last or vice-versa, and does this follow the rule
Xor is it an exception?  (To anticipate a bit, restore tells you file inode
Xnumbers if you toggle "verbose" on at the "restore > " prompt.)
X
X7) Figure out whether you'll use "restore" or "rrestore" (remote restore).
X	o	if the tape drive is on the local machine, use /etc/restore
X	o	if the tape drive is on a remote machine, use /etc/rrestore
X
X"rrestore" is usually used like this:
X	rrestore if host:/dev/tapename
X
X		Generic Questions About Restoring Files		p. 7 of 10
X
X8) Issue the following commands (let's say we're restoring from the
Xsimple example of getting k9:~rca/stat_rpt/Nov89 for "rca".):
Xk9 661# egrep k9 /etc/dist/backup.media	# figure out the "rewind" device name
Xk9      cart    xx      xx      rmt8            nrmt8           c
Xk9 662# cd /tmp				# building the restoration tree here
Xk9 663# pwd				# make sure the *csh* is really there
X/tmp					# yup, the csh is where we want it
Xk9 664# ls /home			# I'm about to demonstrate a point
X beagle/      export/      k9/          lost+found/
Xk9 665# /etc/restore if /dev/rmt8	# "i" for interractive restore
Xrestore > pwd				# pwd on the *tape* - proof positive!
X/					# we're in the root of this dump !!!
Xrestore > ls				# list all the files in the current dir
X.:					# . is the current dir on the *tape*
Xbeagle/	export/	k9/	lost+found/	# notice there isn't a "/home"
Xrestore > cd k9/rti/rca			# going down three levels at once - wow
Xrestore > pwd				# pwd - proving the point again
X/k9/rti/rca				# note no "/home" !!!
Xrestore > cd stat_rep			# oops - a typo
X./stat_rep is not on volume		# so very true
Xrestore > cd stat_rpt			# try again - this time fer sure
Xrestore > ls Nov89			# is it on this dump tape?
X Nov89					# Bingo!
Xrestore > add Nov89			# add Nov89 to the extraction list
Xrestore > ls Nov89			# is it marked for extraction?
X*Nov89					# the asterisk (*) means yes.
Xrestore > extract			# the extraction list is OK - do it
XYou have not read any volumes yet.	# well, this is virtually true
XUnless you know which volume your file(s) are on you should start
Xwith the last volume and work towards the first.
XSpecify next volume #: 2^M		# start with last volume
XMount volume 2
Xthen enter volume name (default: /dev/rmt8) ^M
XYou have read volumes: 2
XSpecify next volume #: 1^M		# work towards first volume
XMount volume 1
Xthen enter volume name (default: /dev/rmt8) ^M
X(sometimes various information appears)
Xchange owner/mode for '.'? no^M		# 	Always answer NO !!!!
Xrestore > help				# list available commands
XAvailable commands are:
X	ls [arg] - list directory
X	cd arg - change directory
X	pwd - print current directory
X	add [arg] - add `arg' to list of files to be extracted
X	delete [arg] - delete `arg' from list of files to be extracted
X	extract - extract requested files
X	setmodes - set modes of requested directories
X	quit - immediately exit program
X	what - list dump header information
X	verbose - toggle verbose flag (useful with ``ls'')
X	help or `?' - print this list
XIf no `arg' is supplied, the current directory is used
Xrestore > what				# gee, this is new, and great!
XDump   date: Wed Feb 21 22:24:47 1990
XDumped from: Wed Dec 31 16:00:00 1969
Xrestore > quit				# we're done with the restore, but ...
Xk9 666#					# the work isn't quite finished
X
X		Generic Questions About Restoring Files		p. 8 of 10
X
X8) continued from previous page
Xk9 666# ls -l /tmp/k9/rti/sys/rca/stat_rpt/Nov89
X-rw-r--r--  1 rca          2860 Nov 29 12:42 /tmp/k9/rti/sys/rca/stat_rpt/Nov89
Xk9 667# mv !$ ~rca/stat_rpt		# move the file
Xmv /tmp/k9/rti/sys/rca/stat_rpt/Nov89 ~rca/stat_rpt
Xk9 668# ls -l ~rca/stat_rpt/Nov89	# now root owns it
X-rw-r--r--  1 root         2860 Nov 29 12:42 /usr/rti/sys/rca/stat_rpt/Nov89
Xk9 669# chown rca !$			# chown rca "last arg on last command"
Xchown rca ~rca/stat_rpt/Nov89
Xk9 670# ls -l !$			# ls -l "last arg on last command"
Xls -l ~rca/stat_rpt/Nov89
X-rw-r--r--  1 rca          2860 Nov 29 12:42 /usr/rti/sys/rca/stat_rpt/Nov89
X
XNow we're done.  "rca" owns the file and it's where it belongs.
X
XIf command number 662 had said "cd /home" instead of "cd /tmp", e.g.
Xk9 662# cd /home			# building the restoration tree here
Xthen we wouldn't have had to go through the extra work shown in
Xcommands 666 through 670.  Why not (left to an exercise for the reader)?
X
X9) Let the user know that the file(s) are restored.
X
X		Generic Questions About Restoring Files		p. 9 of 10
X
X		Restore From "alldisks" Backup:
X
XThe big deal here is that you've got more than one dump on the tape(s).
XSo the big question is - which dump is the right one?  And once
Xyou know that, how do you position the tape at the right dump?
X
X>>>>>	This is why it is critical that the operator write
X>>>>>	down the first filesystem on every alldisks backup volume.
X
XHere are the current command syntaxes for my "alldisks" backup script:
Xbackup: 'alldisks' backup script, version 4.23
X
Xusage:
Xbackup level       /fsname                              [host:]media [opts]
X       <full|incr> </fsname|alldisks>                   [host:]media [opts]
Xbackup get         get_mode                             [host:]media [opts]
X       get         <onedisk|listdisks|/fsname>          [host:]media [opts]
Xbackup verify      verify_mode                          [host:]media [opts]
X       verify      <onedisk|listdisks|/fsname|lastdisk> [host:]media [opts]
Xmedia:		cart, dat, null, tape, tk50, or video
X		See '/etc/dist/backup.media' for valid hosts and media
Xopts (all opts work with all modes):
Xcpio		forces usage of cpio even if a version BSD dump is available
Xcron		handle running from cron (by setting OPER=cron)
Xdemo		echo's media work without actually doing it
Xfsfalse		/fsname is not a filesystem - used for directory backups
Xnoall		sets nocheck, nofailq, nofitguess, nojoke, nooffline, noupdate
Xnocheck		skips the normal check of the rewind and and norewind devices
Xnofailq		skips the normal question re did the backup fail or not
Xnofitguess	skips the normal guess whether an alldisks will fit on media
Xnojoke		skips the normal cpio joke
Xnomail		skips the normal mailing of reports to dc-stash@k9 or na-opers
Xnooffline	skips the normal taking media offline
Xnoupdate	skips the normal update of /etc/dumpdates or ~backup/cpiodates
Xshowdd		tell backup.dd to show 'dd' commands
X
XThe easiest way to get a restore going from an alldisks backup is:
Xk9 664# backup get listdisks tape
X
XWhat a "backup get" does for you:
X1) My script always says "backup" when it's giving you info or asking
Xyou a question.  All other questions and prompts come from "restore".
X
X2) It will ask you several questions.  Life is much easier if you know
Xthe answers.  On multivolume alldisk backups, one question can only be
Xanswered by reading the info which the operator wrote, by hand, on the
Xtape label.
X
X		Generic Questions About Restoring Files		p. 10 of 10
X
X3) Since we have to get the startup directory correct, before starting
Xany restore, it makes sure you deal with the question.
Xbackup: Your are now in this directory: '/usr/rti/sys/backup'.
Xbackup: The complete paths to the files you select will be rebuilt
Xbackup: by 'restore', starting downward from here.
Xbackup: Enter the directory you want to REBUILD the RESTORATION TREE into.
Xbackup: (Press <return> if '/usr/rti/sys/backup' is OK with you):
X
X4) It will position the tape at the correct dump for you, if you follow
Xany instructions my script gives you.
X
X5) It will then invoke restore for you.  It's up to you from there.
XBut remember, as far as restore is concerned, it started at the beginning
Xof the tape on the first dump volume.  restore has no idea that the dump
Xit's about to read is in the middle of the tape.  In this case, you
Xalways want to work first to last, since you started in the middle of
Xthe tape.  The alldisks script can't handle repositioning the tape again.
SHAR_EOF
chmod 0644 src/backup/doc/gen.restore.q ||
echo 'restore of src/backup/doc/gen.restore.q failed'
Wc_c="`wc -c < 'src/backup/doc/gen.restore.q'`"
test 22366 -eq "$Wc_c" ||
	echo 'src/backup/doc/gen.restore.q: original size 22366, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= src/backup/doc/alld.prob ==============
if test -f 'src/backup/doc/alld.prob' -a X"$1" != X"-c"; then
	echo 'x - skipping src/backup/doc/alld.prob (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting src/backup/doc/alld.prob (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'src/backup/doc/alld.prob' &&
XFile:		alld.prob
XAuthor:		Bob Arnold
XLast Modified:	Oct  5 1994
XPurpose:	List some known problems with the alldisks backup system
X
XIn the five years that ASK/Ingres has been using 'alldisks', and since
Xits public release to comp.sources.unix and alt.sources in June 1994,
Xthe system has undergone great changes and feature additions.  It has
Xbeen used on on well over 100 UNIXs and their available tape drives in
Xvarious OS / tape drive combinations at various sites.  While it continues
Xto receive daily real life production usage, and much effort has gone into
Xmaking it both more robust and more usable, there is no guarantee that
Xthis current public release will work as well as desired on yours.  Use
Xat your own risk.
X
XIn spite of the development work and daily production uses, there are a
Xnumber of known weaknesses and problems with the 'alldisks' backup
Xscript and its supporting tools.  This 'alld.prob' file is an attempt to
Xlist them, but the list may not be complete or up to date.
X
XWeaknesses:
X
X* Although the tools to install the backup account handle things in a
Xgeneral way fairly well, they are not as strong as they might be.
XFor one thing, the choice of location for the backup account's home
Xdirectory is probably not useful everywhere.  However, once a suitable
Xbackup account and home directory are created, things work fine.
XAlso, the tools don't handle shadow password files, nor do
Xthey cope with NIS environments.
X
X* Lots of stuff is recorded in the log directories, which is good,
Xand helpful in debugging any problems.  However, the format of the
Xlog files themselves are not as well thought out as they might be.
X
X* There is no support for stackers yet, but that should be coming shortly.
X
X* There is only minimal support for automated backup scheduling, available
Xfrom a "cron" near you :-)
X
X* Only one level of incrementals is supported.
X
X* There is no support for doing network backups as anyone but root.
XThis is not a problem at for sites where all the machines to be backed
Xup have local tape drives, but that may not be true at your site.
X
X* There is no support for interactive restores from cpio archives.
X
X* There is no support for restores over the net from cpio archives.
X
X* For cpio backups, although the script tries to avoid this, it is
Xpossible for the "find" command (which is used to build the list of
Xfiles for cpio to backup) to descend NFS hierarchies.
X
X* There is no support for putting a header archive on onedisk archives
X(except through list files).  Some sites might find this desirable.
X
X* Better generation of "df" outputs would be desirable.  We only want
X"df" output for local filesystems, and we'd like it to look like the
XBSD-style output too.  A multi-filesystem tape puts its "bkp.dfout"
Xfile in the tar/cpio header archive, but if it is a SVR[023] output
Xformat you actually can't tell how much data is on the tape.
X
X* The 'alldisks' script tries to clean up "old" log directories.  This
Xworks better on some systems than others.
X
X* The 'alldisks' and the 'saenv' toolsets have been tested on only one
Xnon-commercial UNIX, namely Linux 1.0.9.  This is a problem I would
Xlike to rectify.
X
X* The shell code is fairly readable, I hope.  One large drawback is that
Xthe backup script itself it contains no functions, because it is
Xmeant to work on systems that don't support Bourne shell functions.
XThis means lots of indenting which looks ugly.  However, in the place
Xof functions, macros are eval'ed.
X
XProblems working in specific environments:
X
X* AIX 3.X onedisk backups don't work across the net for reasons unknown.
X
X* 'alldisks' uses cpio to backup under AIX 3.X.  However, IBM supports
Xits own "backup" program, which its manual page says can be used to
Xcreate archives in "dump" format.  Also, a cpio archive is not
Xsufficient to backup a root volume group - "MakeSysB" seems to be the
Xpreferred method to do that.  Since AIX 3.X defaults to putting all
Xdisks in the root volume group at OS install time, this can lead to
Xproblems managing tape usage.  Restoring a cpio backup of the root or
X/usr filesystem after a disk crash or massive corruption of either
Xfilesystem is problematical.
X
X* SunOS "dump" does a setuid(getuid()) before opening the filesystem
X  being dumped, which has permissions implications.  See other docs ...
X
X* Any SVR4-derived version of "dump" which asks for a continuation tape if
X  it hits physical EOT may have a problem when doing multi-filesystem backups
X  over the net.  See other docs ...
X
X* Bull's B.O.S. version of "dump" does something strange which prevents
X  doing an alldisks backup to cart.
X
X* Vixie-cron 2.1, as installed on Linux 1.0.9, has a problem connecting
X  input/output through pipes.  If you are automating backups via cron
X  under this configuration, you will want to use the "backup.mailto" script.
SHAR_EOF
chmod 0664 src/backup/doc/alld.prob ||
echo 'restore of src/backup/doc/alld.prob failed'
Wc_c="`wc -c < 'src/backup/doc/alld.prob'`"
test 4817 -eq "$Wc_c" ||
	echo 'src/backup/doc/alld.prob: original size 4817, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= src/backup/doc/alld.notes ==============
if test -f 'src/backup/doc/alld.notes' -a X"$1" != X"-c"; then
	echo 'x - skipping src/backup/doc/alld.notes (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting src/backup/doc/alld.notes (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'src/backup/doc/alld.notes' &&
XName:		alld.notes
XAuthor:		Bob Arnold
XLast modified:	Oct  5 1994
X
X
XInstall 'alldisks' backup script on one host by:
X	inst-alldisks host
XInstall 'alldisks' backup script on many hosts by:
X	rrun -l inst-alldisks host1 host2 host3 ...
X	rrun -l inst-alldisks alldiskshosts
X
XFiles:
X.cshrc		standard .cshrc   for "backup" account ; sources .getoper.csh
X.getoper.csh	csh script to figure out who is logging in as "backup"
X.getoper.sh	sh  script to figure out who is logging in as "backup"
X.profile	standard .profile for "backup" account ; sources .getoper.sh
XNOTES		this file
Xbackup		master 'alldisks' backup script
Xbackup.c	C program which can be setuid
Xbackup.dd	script wrapper for dd to give reliable output and exit status
Xbackup.*???	various versions of the backup script and related programs
Xbkp.opers	list of operators initials
Xbkp.host	host-specific backup behavior configuration file
Xbkp.media	master site-wide list of media hosts and their devices
Xbkp.nofm	host-specific list    of filesystems not to backup on full multi-filesystem backups
Xbkp.site	master site-wide alldisks behavior configuration file
Xgen.bkp.media	generates a sample bkp.media entry based on user input
Xlinst-alldisks*	DO NOT use this script directly; see "Install" notes above
X
X##############################################################################
XBrief outline of this alldisks script:
X". /etc/dist/sahead", initialize variables and stuff
Xreport version, get and verify command args, get who is running it ($OPER)
Xif we're doing a backup create "bkp.dfout" and verify requested filesystem
Xtell user "command looks AOK", do more initialization
Xif we're using dump, build dump/restore command line $bcmd
Xif "demo" was spec'd, turn off actual media work
Xcheck rewind/norewind devices in "backup.media" (unless we don't need to)
Xif we're doing a backup
X	start report
X	if we're backing up more than one filesystem, put tar (we have dump) or cpio (we have cpio) header file on tape
X	fsnn=00 ; voln=1 ; sumrecin=0 ; obleft=$maxocount ; echo $sumrecin $obleft > pass=/tmp/bkp.pas$time6
X	for all filesystems ; do
X		if we're using dump
X			eval $bcmd | tee b.$fsnn.out ; fsnn++
X		else
X			get start date of this cpio backup for "cpiodates"
X			put list of files in this fs in "/usr/tmp/bkp.flist"
X			if $pass says there's not much room left on media prompt for new one
X			{ cpio -oc$ckey < /usr/tmp/$flist 2> $workdir/err.cpio ; echo $? > $workdir/stat.cpio ; } \
X			| while : ; do
X				echo "$pf: dd'ing archive of '$fs' onto filesystem volume '$fsvoln'"
X				is new volume writeable, correct density, etc?
X				$bdd of=$mdev ibs=$ibs obs=$obs count=$icount 2> err.dd
X				$bddstat=$?
X				cat err.dd >> b.$fsnn.out
X				if there's room on this $media echo $sumrecin $obleft > $pass
X				else sumrecin=0 ; obleft=$maxocount ; echo "Change Volumes" >> b.$fsnn.out ; fsvoln++ ; get new $media from $OPER
X			done
X			cat err.cpio >> b.$fsnn.out
X			if cpio went OK then update "cpiodates"
X		fi
X		figure out whether $OPER had to change volumes >> "bkp.firstb"
X	done
X	rewind/offline media now so user doesn't have to wait
X	finish $report "bkp.rpt"
X	if verifytoo is true, verify it and take it offline
Xelse we're doing a "get" (i.e. a restore) or a "verify"
X	if we doing a 'verify onedisk' set $onvol=1 by definition
X	if we're not doing a 'get onedisk' set $nvol
X	case $getmode in knownfs|listdisks|lastdisk|alldisks)
X		make sure we extract header, or link to parent
X		if we can't find position from old logs and user didn't spec a skip
X			get info from user or command line for $firstblist
X			build $volmap
X	case $getmode in knownfs|listdisks|lastdisk)
X		figure out (ask if we have to) which filesystem we want
X		figure out where it is on the media (set $onvol $fileskip)
X		if it isn't on vol. 1, ask $OPER to mount correct volume
X	case $getmode in knownfs|knownskip|listdisks|lastdisk)
X		position media at requested filesystem
X	if doing get, ask "interactive" vs "entire" restore, if not spec'd (interactive cpio restore not implemented)
X	determine target directory for restore work; cd $target
X	case $mode in
X	get)	get $fs
X	verify) set $getcmd
X	esac
X	case $mode$getmode in
X	verifyalldisks)
X		for each volume $nvol
X			for each fs in $dfout on $voln
X				backup verify $fs $marg $diskfile $extravol $child skip $fileskip $notcont $optlist
X	verify*)
X		case $bprog in
X		cpio)	get $getlist
X		*dump*)	get name of last file in archive
X		esac
X		save list of files we found
X		case $bprog in
X		cpio)	if we got $getlist PASS else FAIL
X		*dump*)	if dump is empty or we can reposition tape and extract last file PASS else FAIL
X		esac
X	esac
X	rewind/offline the media; finish get/verify report
Xfi
Xif there were problems try to send mail to $probto
Xif we did a backup
X	ask $OPER "$pr: Do you want to report a problem (yes|no)?" >> $failrpt
X	show operator how to label tapes (if any)
Xfinal cleanup and exit
X
X##############################################################################
X
Xabbreviation conventions for variable names, with examples
Xb	backup		"bstat"		means	"backup (exit) status"
Xd	dump		"dkey"		means	"dump key"
Xf	file		"lockf"		means	"lock file"
Xl	local		"lhost"		means	"local host"
Xm	media		"mtype"		means	"media type"
Xn	number		"voln"		means	"volume number"
Xq	question	"noprobq"	means	"no problem question"
Xv	verify		"vcmd"		means	"verify command"
Xgv	get/verify	"gvreport"	means	"get/verify report"
Xpr	program		"pr"		means	"program"
Xfs	filesystem	"fsdev"		means	"filesystem device"
Xbkp	backup		"bkpn"		means	"backup number"
Xdev	device		"mdev"		means	"media device"
Xcmd	command		"bcmd"		means	"backup command"
Xdir	directory	"hdir"		means	"home directory"
Xrew	rewind		"rewdev"	means	"rewind device"
Xrpt	report		"failrpt"	means	"failure report"
Xvol	volume		"nvol"		means	"number of volumes"
Xprob	problem		"probfs"	means	"problem filesystem"
Xprog	program		"bprog"		means	"backup program
Xstat	status		"bstat"		means	"backup program's exit status"
X
X##############################################################################
X
XOwnership/permission issues:
X
XRestores always have to be done as root, whether we're using dump/restore
Xor cpio, because restore and cpio have to be run by root to chown
Xthe restored files.
X
XBackups, on the other hand, have several possibilities.  SunOS 'dump'
Xhas an unusual behavior - it does a setuid(getuid()) so it runs with
Xyour real uid not your effective uid.  This means that under some
Xuid/login/su conditions, group read permission is required on the
Xraw filesystem device so dump can read it.
X
Xdump/restore:
X						SunOS		oper
X						forces	group	knows	remote
Xscript owner/	rawdev owner/			640	read	root	host
Xgroup/perms	group/perms	login/su	rawdev	rawdev	passwd	trusts
X-------------	-------------	-------------	------	------	------	------
X*root/wheel/755	root/wheel/600	root/root	no	no	yes	root
Xroot/wheel/755	root/oper/640	backup/backup	yes	yes	no	backup
Xroot/wheel/755	root/wheel/600	backup/root	yes	yes	yes	root
Xroot/wheel/4755	root/wheel/600	backup/root	yes	yes	yes	root
Xroot/wheel/2755	root/wheel/640	backup/backup	yes	yes	no	backup
X
Xcpio:
X						SunOs		oper
X						forces	group	knows	remote
Xscript owner/	rawdev owner/			640	read	root	host
Xgroup/perms	group/perms	login/su	rawdev	rawdev	passwd	trusts
X-------------	-------------	-------------	------	------	------	------
X*root/wheel/755	root/wheel/600	root/root	no	no	yes	root
Xroot/wheel/755	root/wheel/600	backup/root	no	no	yes	root
Xroot/wheel/4755	root/wheel/600	backup/backup	no	no	yes	root
X
X* This tools for installing 'alldisks' assume this scheme:
Xroot/wheel/755	root/wheel/600	root/root	no	no	yes	root
X
XNote that setuid shell scripts are not supported everywhere.  In some cases
Xthis can be overcome by having a setuid binary call the shellscript, but
Xthis is also not supported everywhere.  In other cases, setuid shellscripts
Xare only supported for UID's under 100.
X
XSome versions of dump/restore also support doing network backups as
Xother users, like this: "dump 0f backup@remote:/dev/whatever /filesystem".
X
XThere are alternatives to having the operator know the root password.
XVarious tools are available on the net to allow ordinary users to do
Xwork which would normally require root access.
X
X##############################################################################
X
XTo use compression or not to use compression:
X
XArguments for compression:
X1) Compression saves space, which may save tape mounts.
XIf you can save tape mounts, you will be able to reduce media costs.
X2) If you want to automate backups, this may help you do that because
Xyou may not have to change tapes if you compress the data.
X3) Using tape drive hardware compression means you can read/write data faster.
X
XArguments against compression:
X1) If a compressed tape developes a bad spot, the data after the bad
Xspot become unreadable because the decompression algorithms may depend
Xon the missing data.  If a non-compressed tape develops a bad spot,
Xthat bad spot will be unreadable but it should be possible (perhaps
Xwith some extra work) to recover the data from the rest of the tape.
X2) Compressed data may not be readable on another tape drive.
X
XThe alldisks script doesn't have any special hooks for compression.
XHowever, the number of 5k blocks a compression device can hold is
Xobviously bigger than a non-compression tape drive.  If you use a
Xcompression tape drive, its "# of 5k blocks per tape" field of the
Xbkp.media file would have to be tailored to account for this.
X
X##############################################################################
X
XI chose an "alldisks" design instead of a "system" design for
Xthe backups which use cpio.  The reasoning is this:
X
XAn "alldisks" tape looks like this:
X|| cpio_header | cpio1 | cpio2 | cpio............... ||
X
X	OR
X
XA "system" tape looks like this:
X|| one____________giant___________cpio______archive__||
X
XIn order of importance (#1 is MOST important):
X1) Reliability of backup: alldisks wins because if one of the cpio
Xarchives fails the rest may work and you still have useful data.
X2) Ease of restoring selected files (remember they have to be specified
Xon the "cpio -i ..." command line): alldisks wins because the list of
Xfiles will take fewer characters on the command line.
X3) Ease of figuring out which files to select: system wins because there
Xis only one "ontape" file to look at and it's at the beginning of the first
Xvolume (each cpio archive contains a "timestamp" and "ontape" file).
X4) Ease of positioning the tape at the desired files (one-volume backups):
Xsystem wins.
X5) Ease of positioning the tape at the desired files (multi-volume backups):
Xalldisks wins.
X6) Ease of writing the cpio version: system wins.
X7) Common command line syntax: alldisks wins.
X
XOverall, the winner is alldisks.  We'll put multiple cpio archives on
Xthe media, with a cpio header file similar to the tar header file for
Xalldisks backups which use BSD dump.
X
X##############################################################################
X
X'dd' behaviour notes:
Xdd provides lots of control over input blocks (using "conv=sync" and
X"count="), but no direct control over output blocks (except for "obs=").
Xa) the default block size is often "1b", but not always
Xb) conv=sync pads input blocks to the input block size
Xc) "count=" only counts input blocks, never output blocks
X
XWhy we need $sumrecin:
XWe could try to just use $obleft; after all the main point is how many
Xoutput blocks are left on the media.  However, the way it is used,
Xa) $sumrecin avoids truncation error with "expr"
Xb) $sumrecin is required anyway to track records_in within "| while" loop
Xbecause of how dd counts input blocks
X
XReasons for creating a dd wrapper script:
XThe problem is that it's impossible really to figure out whether a
Xremote dd command has exited successfully.  Simple tricks are complicated
Xby the fact that dd's output isn't the same on all platforms, and
Xby the use of dd in a pipeline.  To take care of this whole mess
Xcan't really be done using a macro, so we have to build a script.
XOne big advantage of doing this is that the backup.dd script can
Xbe counted on to give consistent output, which means I can eliminate
Xa lot of error checking code in the alldisks script itself.
X
XData capacities and sustained data transfer rates for various types 
Xof tape drives, *without compression*:
X					sustained
X	inter-	tape		capac-	transfer
Xtype	face	model	length	ity	rate (k/sec)
X------	------	------	------	---------------------------
X9track	pertec		2400'	150M	 500-750 (625/768/...)
X9track	scsi		2400'	150M	 500-750
Xdat	hpib		60m	1.3G	 183
Xdat	scsi		60m	1.3G	 183
Xdat	scsi		90m	2.0G	 183
X8200	scsi		112m	2.0G	 246
X8500	scsi		112m	5.0G	 500
Xqic11	scsi		600'	 25M
Xqic24	scsi		600'	 42M
Xqic60	scsi		600'	 60M
Xqic120	scsi		600'	120M	  90
Xqic150	scsi	DC600A	600'	150M	 112
Xqic250	scsi		1020'	250M	
Xqic320	scsi	DC6320	620'	320M	 200?
Xqic525	scsi	DC6525	1020'	525M	 240
Xqic555m	scsi			580M	 200
Xqic1000	scsi			1.2G	 300
Xqic1350	scsi			1.3G	 300
Xqic2gb	scsi			2.5G	 300
X3480	scsi		 	220M	1500
X
XSpecial requirements for DG's DG/UX SVR4:
X1) "dump2" oddities:
X* It takes "-flag arg" options in addition to the traditional dump key method.
X* It doesn't report a "Phase III" or "Phase IV" when writing to the media.
X* It supports operator input via named pipes (the -O flag), and other input.
X* It says "change tapes" (lower case 'c' and 't').
X* The first field of /etc/dumpdates is free form, not fixed width.
X* It handles EOT for cart and video drives, simply asking for the next tape!!!
X  However, if it hits EOT while doing network backups using remote /dev/rmt
X  devices, the /etc/rmt on the remote host will quietly drop a 50block buffer
X  which dump2 on the local host sent to be written to the /dev/rmt tape drive.
X2) Network backups which hit EOT should use no-cache "pmt" pseudo tape drives
XThese act like they work great when writing to "rmt" devices on the remote
Xmachine, but when you go to restore the data you will probably discover
Xthat "50 blocks" or so of data have been lost out of the middle of the dump.
XThe reason is that /etc/rmt on the remote host buffers data, and when it
Xhits EOT, it has nowhere to put the cache and drops it on the floor.
XIn the meantime, /etc/rmt also tells "dump2" that it has hit EOT, so
X"dump2" simply asks the operator to change tapes.  The solution is to
Xuse local, *un-cached*, pseudo tape devices (/dev/pmt/*), which are
Xconfigurable on the local host's /etc/pmttapetab file; these devices
Xare not truly local, but it looks like it to the local machine because
Xit has the /dev/pmt devices.  You must use "N" in the cache filed.
X3) Local backups using 'alldisks' to a local DAT drive require the addition
Xof a "dat" entry to /etc/dumptab; this is taken care of by the installation
Xscripts, but note that it does assume the DAT is a 2Gig device.
X
XTandem's NonStop-UX 4.0 oddities:
XIt has two filesystem types, ufs and vxfs, which use ufsdump/vxfsdump
Xand ufsrestore/vxrestore respectively.  See also the section in this
Xfile on restore's exit status.
X
XIBM AIX 3.X RS/6000 Exabytes:
X1) To list the available tape drives:
X	lsdev -C -H -c tape
X2) To list the effective attributes of a tape drive:
X	lsattr -E -l rmt0
X3) An even better listing is given by mt's "status" command:
X	mt -f /dev/rmt0.1 status
X4) To fix the blocksize of an Exabyte or QIC drive:
XAIX 3.X assumes a blocksize of 512bytes for Exabytes and cart drives
Xattached to RS/6000s.  Since an Exabyte's natural blocksize is 1024bytes,
Xthis has the unhappy effect of limiting the tape capacity to half of what
Xit ought to be.  The fix is to do something like the following, as root,
Xfor each tape drive on the AIX box:
X	chdev -l rmt0 -a block_size=1024
X
XThoughts about writing and reading header archive
XWriting:
XWe'd like tar to force fully blocked writes to standard out.
XThis is useful when we're writing to a pipeline where blocking may not be
Xmaintained, because we may be able to reconstruct it on the other end.
XSome UNIXs (e.g. Ultrix) use the 'B' key to do this.  Other UNIXs will allow
Xthe ordinary "b" key, but do not actually block to standard out.
XStill others (e.g. Pyramid SVR4) gripe about the "b" key when used
Xwith standard out.
Xcase $mhost in
X$lhost)	use tar blocked to local drive ;;
X*)		use tar blocked if possible to standard out \
X		| ddsplit obs=1b \
X		| if test $PIPESIZE_on_mediahost -ge tarblocksize ; then
X			attempt to force blocks to tarbs
X			ddjoin ibs=1b obs=$tarbs
X			| ddjoin ibs=$tarbs conv=sync of=$dev
X		else
X			attempt to force blocks to 1k instead
X			ddjoin ibs=1b obs=1k \
X			| ddjoin ibs=1k     conv=sync of=$dev
X		fi
X;;
Xesac
X
XReading:
XWe have no guarantees about the blocking of the tar archive we're trying
Xto read.  We also don't know whether it was written using tar or tar piped
Xto dd.  On local 9track tapes, this is no big deal, because tar will
Xtry to figure it out itself and many versions can handle partial blocks
Xat the end.  For local carts we can try 20b; then 2b.
X
XVerify strategy:
Xdump archives:
X	a) get list of files on media using "restore tvf ..."
X	b) figure out last file by picking the one with the largest inode
X	c) then extract it "restore xf ... <file>"
X	If the last file is successfully extracted then we have read the
X	entire dump and we assume all is well.  Special	cases like empty
X	dumps and no files (just directories) are also handled.
Xcpio archives:
X	Until version 4.26 we tried to use the same strategy as with dump.
X	We extracted "bkp.rpt" (so we could check the cpio archive against
X	the tape label) and "bkp.flist" (so we could determine the last
X	file and read the entire archive in an attempt to get it).
X	Unfortunately, because of the way cpio works, this extraction
X	forced a reading of the entire cpio archive anyway.  So trying
X	to get the last file meant reading it again - yuk!  So now we just
X	a) extract "bkp.rpt" and "bkp.flist" (which reads the entire archive)
X	b) check "bkp.rpt" against the tape label
X	If both files are extracted and the tape label checks ok then we
X	assume all is well.
Xalldisks archives (using dump or cpio):
X	a) extract the tar/cpio header archive
X	b) check "bkp.rpt" against the tape label
X	c) choose one of the filesystems to verify
X	d) do a filesystem verify (using restore or cpio as appropriate)
X
XVerify Alldisks dump strategy:
XThis is what we do:
X	for each archive ; do
X		backup verify $fs [host:]media nooffline
X	done
XThe following idea was considered but rejected:
X	skip header archive
X	for each tape ; do
X		for each archive get name of last file
X		rewind tape
X		for each archive pass if backup is empty or we can extract last file
X	done
XThe advantage would be that you could read each archive on each tape
Xserially, without repositioning the tape each time.
XThe disadvantage is that it's not guaranteed to work.  There is no
Xguarantee where "restore tf" or "restore xf" leaves the tape.  If an
Xarchive is teensy weensy, restore could position the tape at the
Xbeginning of the next archive.  Or it could leave itself in the middle
Xor end of the current archive.  Each vendors probably implements this
Xstuff differently, and may even have different strategies for different
Xtape drive types.  
X
XVerify Alldisks cpio strategy:
XMuch easier than dump (for once) - simply skip the header archive and then
Xdo "cpio -i $getlist < $mdev", and pray the vendor's version of cpio knows
Xwhat to do if an archive is continued on the next tape.
X
XExit status from restore and "cpio -[io]"
Xrestore		1	physical problem reading tape
Xrestore		1	reads tar archive from stdin
Xrestore		1	reads cpio archive from stdin
Xrestore x	1	file not in archive (SunOS 4.1.2), but see OSx ...
Xrestore x	0	file not in archive (OSx512MDNI 5.1a-910507c)
Xrestore t	31	success on NonStop-UX 4.0 ufsrestore/vxrestore
Xrestore t	32	failure on NonStop-UX 4.0 ufsrestore/vxrestore
Xcpio -i		2	wants to read 2nd tape but is too stupid to do it
Xcpio -i		2	archive is not cpio archive
Xcpio -o		2	could not archive one or more files in input file list
Xcpio -o		141	output through pipe closed prematurely
X
X##############################################################################
SHAR_EOF
chmod 0664 src/backup/doc/alld.notes ||
echo 'restore of src/backup/doc/alld.notes failed'
Wc_c="`wc -c < 'src/backup/doc/alld.notes'`"
test 20023 -eq "$Wc_c" ||
	echo 'src/backup/doc/alld.notes: original size 20023, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= src/backup/doc/alld.history ==============
if test -f 'src/backup/doc/alld.history' -a X"$1" != X"-c"; then
	echo 'x - skipping src/backup/doc/alld.history (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting src/backup/doc/alld.history (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'src/backup/doc/alld.history' &&
XName:		alld.history
XAuthor:		Bob Arnold
XLast modified:	Oct 11 1994
X
XThis is a history of the alldisks backup toolset.  The description is
Xsummarized *very* briefly for the script prior to its release as
X'alldisks 5.00' to comp.sources.unix and alt.sources in June 1994.
XEnhancements since that time are chronicled in more detail.
X
X1.00	Dec 16 1988	First Release!!!  Can back up multiple filesystems
X	on one tape using BSD dump!!!
X2.00	Mar  6 1989	"get" mode added to retrieve data from backups!!!
X3.00	Sep  4 1990	Can do cpio backups!!!
X4.00	Mar 19 1991	verify mode!!!
X4.46	May 13 1993 (really an alpha alldisks 5.00):
X	add "backup verify alldisks" - COOL!!
X	add "backup <level> <fsname|alldisks> <media> verifytoo"
X	add "skip S" get/verify opt to skip "S" number of files
X	add "noauto" verify opt says don't automate verification
X	add "notcont" get/verify opt to say archive isn't continued on next vol
X	add "dir" media type so we can do a backup to files in a directory
X	add "file" media type so we can do a backup to file(s)
X	add "bkp.site" site configuration file
X	add "bkp.host" host-specific config file to set permanent host behaviors
X5.00	June 17 1994	complete "backup verify alldisks" audit passes!
X			released to comp.sources.unix and alt.sources!
X5.01	Aug  1 1994 - mostly changes for Linux
Xdone	for Linux (GNU cpio): new vars $copt, $cphk, $cformat
Xdone	for Linux (GNU cpio), copy (not link) $flist and $report to /usr/tmp
Xdone	fix possessive "it's" in comments - should be "its" (no apostrophe)
Xdone	define mistape=false for null $mtype
Xdone	new backup.mailto script to work around problems with Vixie-cron 2.1
Xdone	sample entry for Linux in bkp.media, and other improvements in bkp.media
Xdone	gen.bkp.media script now generates entries for other hosts
Xdone	improvements in the README and various supporting files in the "doc" dir
SHAR_EOF
chmod 0644 src/backup/doc/alld.history ||
echo 'restore of src/backup/doc/alld.history failed'
Wc_c="`wc -c < 'src/backup/doc/alld.history'`"
test 1844 -eq "$Wc_c" ||
	echo 'src/backup/doc/alld.history: original size 1844, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= src/backup/README ==============
if test -f 'src/backup/README' -a X"$1" != X"-c"; then
	echo 'x - skipping src/backup/README (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting src/backup/README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'src/backup/README' &&
X
X	Intro To The Famous 'alldisks' UNIX Backup Script	p. 1 of 7
X
XSo, you want to do backups on your machine?  Great!  Welcome to the
X'alldisks' backup script.  It has saved many users much time, hassle,
Xand money.
X
XThis "Intro" is also "The Manual".  Please read it.
X
XWhy is 'alldisks' so great?  Well, there are tons of reasons, a few of
Xwhich are listed here:
X1) It can put backups of multiple filesystems onto one tape.
X2) It can help restore files from one-filesystem (AKA 'onedisk') or
Xmulti-filesystem tapes.
X3) It can verify backup tapes.
X4) It works on scads of UNIX boxes with all sorts of OS/HW combinations.
X5) It uses the vendor-supplied 'dump/restore' utilities where possible,
Xbecause these are much better than cpio, tar, pax, fric/frec, bru, or
Xany other directory-based backup utility which might come from the
Xvendor.  However, if dump/restore aren't available it will use cpio
X(and it tries to work around as many of cpio's shortcomings as possible).
X6) It can handle backups over the net and multiple tapes, even when
Xusing cpio (backups over the net are discouraged because of the massive
Xnetwork traffic they generate).
X7) It reports any problems it detects, so you find out about them in
Xa timely fashion.
X
XThe name of the 'alldisks' script is "backup".  We speak of it as 'alldisks'
Xbecause you most often use it with a command something like this:
X
X	backup full alldisks video0
X
XFor a complete usage message, just say:
X
X	backup help
X
XHow do I install it?
XHere are the installation instructions.  Presumably you have already
Xfollowed the instructions in the README file at the top directory of
Xthis suite, which describe how to install the 'saenv' toolset, edit
Xthe necessary config files, and create a backup account, all on your
Xmaster sysadmin host $SAHOST.  Once all this is done, all you need to do is:
X1) Make sure you are in the $SAHOME directory on $SAHOST, and run
X	./bin/inst-alldisks $SAHOST
Xto install the 'alldisks' backup toolset on your master sysadmin machine.
X2) You can install the 'alldisks' toolset on other hosts just by creating
Xa backup account on the <host> (you don't have to do this if /home/backup
Xis OK with you, or you redefine $bhdir in "bkp.site") and then doing
Xone of the following.
X	If the 'saenv' toolset has not been installed on your target host, do:
X		./bin/inst-suite <host>
X	If the 'saenv' toolset has been installed on your target host, do:
X		./bin/inst-alldisks <host>
Xfor each host you want to install it on.  That's it!
X
X	Intro To The Famous 'alldisks' UNIX Backup Script	p. 2 of 7
X
XWhere does it live?
XIn backup's home directory on each machine.  If backup's home directory is
X"/home/backup", then the script itself is called "/home/backup/backup".
X
XHow do I use it?
X1) Log in to your machine as 'backup'.  Enter your initials when asked.
X2) Issue the backup command.  Say "backup help" for a complete list of options.
XTypical backup commands are:
X	backup full alldisks video0	# done perhaps one day each week
X	backup incr alldisks video0	# done perhaps four days each week
X	backup full /home friend:cart0	# network backup to cart0 on 'friend'
XThat's all!
X
XWhy should I label the backup tapes?
XBecause you will forget what's on them if you don't label them.
XBesides, your coworkers may need them when you aren't available.
X
XWhat information belongs on a proper tape label?
X1) hostname of the system being backed up
X2) name of filesystem (e.g. /usr or 'alldisks')
X3) date backup was made
X4) backup level (e.g. full or incremental)
X5) tape number (e.g. "tape 1 of 3", "tape 2 of 3", etc.)
X6) name of media host (in case the backup was done over the net to another box)
X7) For alldisks tapes, which have several filesystems on each tape, you *must*
Xnote the name of the first filesystem on each tape.  This is easy: the backup
Xscript tells you this info when it's done.  You will be very unhappy and have
Xa hard time retrieving data if this info is not written on your alldisks
Xtape labels.
X8) If a filesystem backup is continued onto another tape, this *must* be noted.
X
XHow do I take care of my tapes?
XTapes can be damaged by cold, heat, moisture, impact, magnets, and time.
XStore them in a cool dry safe place.  Keep them away from paper clip holders,
Xvacuum cleaners, disk drives, and magnetic desk toys.  Well-cared for tapes can
Xlast several years, but a tape can go bad for unexplained reasons at any time.
X
XCan I use 'alldisks' to archive only one filesystem?
XYes - that's called a "onedisk" archive.  You would say something like:
X	backup full /home cart0
X
XWhat does a "onedisk" tape look like?
XIt's a simple dump (or cpio) archive of the filesystem.
X
XWhat does an "alldisks" tape look like?
XIf BSD dump is available it looks like this:
X	|| tar_header  | dump1 | dump2 | dump............... ||
XIf BSD dump is not available it looks like this:
X	|| cpio_header | cpio1 | cpio2 | cpio............... ||
XThe tar/cpio header contains a list of all the filesystems in the
Xalldisks backup tape set, and other useful info for debugging purposes.
X
X	Intro To The Famous 'alldisks' UNIX Backup Script	p. 3 of 7
X
XWhat are all the files in backup's home directory?
X.cshrc		standard backup account .cshrc
X.profile	standard backup account .profile
X.getoper.csh	asks for your personal login name when you log in as backup
X.getoper.sh	asks for your personal login name when you log in as backup
Xbackup		'alldisks' script (or maybe a setuid binary to call backup.sh)
Xbackup.dd	"dd" wrapper to handle network dd's and non-standard dd messages
Xbackup.N.NN	old backup scripts - the "N.NN" part is their version number
Xbackup.c	C code for setuid binary wrapper to call backup.sh
Xbackup.sh	'alldisks' script if it is called it from a setuid binary
Xcpiodates	logs cpio backups (like /etc/dumpdates for BSD dump)
Xprobsent	tracks problems alldisks has *tried* to email to DC calltrack
Xbkp.donot	lists filesystems on this host which we never back up
Xbkp.listN	list(s) of filesystems: used with 'backup <level> listN <media>'
Xbkp.nofm	lists filesystems which we don't put on full alldisks backups
Xbkp.opers	lists operators at your site
X
XAnd what are all the subdirectories?
XEach time the alldisks script is run, it creates a working directory called
X"mmdd.HHMMSSmt".  The names are basically date-stamps, but they also describe
Xthe "mode" and "type" of backup made:
X	The modes are the basic alldisks modes: f=full, i=incr, g=get, v=verify
X	The types are o=onedisk and m=multifilesystem(alldisks)
X
XSo what are all the files in the subdirectories?
XThere are lots of them, and you normally don't have to think about them.
XIf you do, you probably will care most about these:
Xb.NN.out	saves dump/cpio output for each filesystem
Xbkp.dfout	list of filesystems that could go on an alldisks tape
Xbkp.rpt		report on the backup
Xbkp.fail	known failures, if detected, are listed here
Xbkp.probsend	notes problems we should report if it hasn't already been done
X
XAre there any other important files?
XYes.  There are three (or possibly four):
X1) 'alldisks' uses a list of media devices called 'bkp.media'.
XThe master version is maintained by your friendly local syadmins.
XA local copy of the master is kept on your machine, in /etc/dist/bkp.media.
XIf you are planning to use a tape drive attached to your box,
Xthe master bkp.media must contain info about it.  Alternatively, you can
Xcreate your own local bkp.media in backup's home directory - 'alldisks'
Xwill use that one instead if it exists.
X2) /etc/dist/sahead is sourced by 'alldisks' and can't run without it.
X3) /etc/saenv is a research report specific to your machine.  It is
Xalso sourced by 'alldisks' and can't run without it.
X4) /etc/dist/bkp.site describes alldisks behaviour at your entire site.
XIt is possible that you will like the defaults listed in it; if so it
Xdoes not need to be distributed to /etc/dist on each machine.
X
XIf I wanted to automate my backups, could I?
XYes, *if* your backups will all fit on one tape.  In root's crontab file
Xfor your system, you could put two entries that looked something like this:
X0 20 * * 5   /home/backup/backup full alldisks video0 cron 2>&1 | Mail root you
X0 20 * * 1-4 /home/backup/backup incr alldisks video0 cron 2>&1 | Mail root you
XThis would do a full backup on Friday evening at 8pm, and incremental
Xbackups Monday-Thursday at 8pm.  NOTE - You have to remember to change
Xthe tapes yourself!
X
X	Intro To The Famous 'alldisks' UNIX Backup Script	p. 4 of 7
X
XHow do I know if my backups are any good?
XThere are several methods.  The more work you want to do, the more
Xthoroughly you can check your backups.  In order of easy to hard:
X1) Look at the output from the backup.  No complaints is probably good
Xnews, but there are no guarantees.  The 'alldisks' script knows about
Xcertain failures, and makes an effort to report them.  However, it can't
Xpossibly know about all types of possible failures.
X2) Check "bkp.rpt" and "b.NN.out" files in the working directory for errors.
X3) Run 'backup verify /fsname [host:]media' for selected filesystems on an
Xalldisks backup.
X4) Run 'backup verify alldisks [host:]media' for alldisks tapes,
Xand 'backup verify onedisk [host:]media' for onedisk backups.
XVerifying an alldisks backup can take more than twice as long as making it did.
X
XA typical onedisk backup/verify sequence might be:
X	backup full /home cart0		# make the 'onedisk' backup of /home
X	backup verify onedisk cart0	# verify the backup
X
XA typical multi-filesystem backup/verify sequence might be:
X	backup full alldisks video0	# make the multi-filesystem backup
X	backup verify alldisks video0	# verify all filesystem archives, or
X	backup verify listdisks video0	# choose only one filesystem to verify
X
XWhen doing a "get" or "verify", I have to wait for alldisks to ask
Xlots of questions.  Is there an easier way?
XYes - the number of "extra" volumes and the name of the first filesystem
Xon each extra volume can be specified on the command line.
X        a) an alldisks tape set with only 1 tape:
X                backup verify lastdisk dat0 0
X        b) an alldisks tape set with three tapes, telling alldisks the
X        names of the first filesystems on extra tape 2 and extra tape 3
X                backup verify lastdisk video5 2 /fs1_tape2 /fs1_tape3
X        c) same as example "b)", but showing what to do if the first
X        filesystem on extra tape 2 is continued from the first tape;
X        notice the word "cont" on the command line:
X                backup verify lastdisk video1 2 /fs1_tape2 cont /fs1_tape3
XOther questions can also be answered in advance on the command line;
Xdo a "backup help" to see all the options.
X
XWhen doing a "verify", can I just get it going and come back a while later
Xto find out how it went?
XYes, but only if you specify the number of "extra" volumes and the name of the
Xfirst filesystem on each extra volume.  At that point, alldisks goes into
X"autoverify" mode.  You won't have to answer any other questions unless the
Xfilesystem you are verifying is not on the first tape.
X
X	Intro To The Famous 'alldisks' UNIX Backup Script	p. 5 of 7
X
XCan alldisks do network backups?
XSure.  But Be Aware:
X1) Backups of hosts *outside* the machine room using tape drives *in* the
Xmachine room are disallowed because hosts in the machine room do not trust
Xmachines outside the machine room.
X2) Backups *between* subnets are *very* strongly discouraged.
X3) If you insist on cratering your own subnet, you may do so until someone
Xcomplains.  You'll need to find a friendly workstation owner with a tape drive
Xand a similar OS.  Your host must be listed in your friend's /etc/hosts.equiv,
Xand your friend must remove /etc/dist/hosts.equiv.  For SunOS, the target host
Xmust also have a 'backup' account.
XA backup over the net to a cartridge drive on a friendly host might look
Xlike this:
X	backup full /home friend:cart0	# network backup to cart on 'friend'
X
XOK, I had a small disaster and I want to get a few of my files back.  Thank
Xgoodness I have backup tapes!  Brilliant!  Now what do I do?
XSimple:
X	backup get onedisk dat1		# get files from a onedisk backup
X	backup get listdisks dat1	# get files from an alldisks backup
XThe alldisks script is a front end for BSD "restore" (which reads archives
Xmade by BSD "dump") and "cpio".  The script will position the tape at the
Xcorrect archive for you, and get some key information from you before starting
Xrestore or cpio.  Naturally, you'll need to know how to use these programs
Xto take full advantage of them.  Luckily, restore in interactive mode is
Xpretty cool and also has a 'help' command.  Unfortunately, if you're stuck
Xusing cpio, you've got a much bigger problem because cpio doesn't have an
Xinteractive mode.
X
XOh, no!  My disaster turns out to be much bigger than I thought.  It turns
Xout my disk is fried and I had to have it replaced and newfs'd.  I have to
Xrestore an entire filesystem!  Now I'm *really* glad I made backups.  How
Xdo I get an entire filesystem?
XSame answer as above:
X	backup get onedisk cart0	# get files from a onedisk backup
X	backup get listdisks video5	# get files from an alldisks backup
X	backup get /usr friend:dat1	# network get of /usr from alldisks set
X
XGee, "backup get" sure asks me lots of questions.  Is there any way to
Xjust start it up and have it do the right thing?
XSure (but you do have to know all the answers :-) in advance:
X	backup get /fsname friend:dat1 0 interactive target <target_dir>
XDitto for verify, if we have an alldisks backup with two extra tapes:
X	backup verify /home friend:dat0 2 /fs1_t2 /fs1_t3
XThe "/fs1_t2" is the name of the first filesystem on the second tape,
Xand "/fs1_t3" is the name of the first filesystem on the third tape.
X
X
X	Intro To The Famous 'alldisks' UNIX Backup Script	p. 6 of 7
X
XCould you explain more about the filesystem lists which can be used to
Xmanage tape usage?  Which ones work, and when?
XSure.  Let's review for a moment:
Xbkp.donot     lists filesystems we never back up
Xbkp.listN     list(s) of filesystems: used with 'backup <level> listN <media>'
Xbkp.nofm      lists filesystems we don't put on full multi-filesystem backups
X* The two files "bkp.donot" and "bkp.nofm" are always honored, by all
Xthree types of multi-filesystem backups: alldisks, listed, and unlisted.
XAny filesystem listed in bkp.donot will never be backed up; any filesystem
Xlisted in bkp.nofm will left be off of any full multi-filesystem backup.
X* About bkp.listN, these files will typically be named "bkp.list1",
X"bkp.list2", and so on.  Like bkp.donot and bkp.nofm, they belong in backup's
Xhome directory.  An alldisks backup doesn't care whether or not a filesystem
Xis listed in a bkp.listN file.
X* Using a "onedisk/alldisks" tape management scheme:
XIf a machine has too much data to fit onto one tape, you may want to use
Xthis scheme to back up your filesystems.  The idea is to put one or more
Xbig filesystems in bkp.nofm.  A full alldisks backup will not put those
Xfilesystems on the alldisks tape.  Then you would back up each of those
Xfilesystems onto seperate onedisk tapes.
X* Using a "listN/unlisted" scheme:
XHowever, if one of your machines has more data than can fit on one tape,
Xand you have the luxury of two available tape drives, you might want to
Xgo to a "listN/unlisted" scheme.  Let's say you have two Exabyte 8500 5Gig
Xdrives and 8Gig of data to back up, you might want to list half of your
Xfilesystems in bkp.list1, and leave the rest unlisted to be backed up when
Xyou do you do "backup ... unlisted ...".  For example, you might say:
X      backup full list1 video0        # uses the bkp.list1 file
X      backup full unlisted video1     # excludes filesystems in bkp.list1
XIf you do go to this scheme, it is strongly recommended that you
Xdeliberately leave some filesystems out of the bkp.listN files so that
Xa "backup ... unlisted ..." will catch them.  If you hardcode all of
Xyour filesystems into the bkp.listN files and never do a "backup ...
Xunlisted ...", you run the risk that someday you will add another
Xfilesystem to your machine and forget to add it to the bkp.listN files;
Xthen your new filesystem won't be backed up.  A good rule of thumb might
Xbe to leave the root, /var, and /usr filesystems to be caught by your
X"unlisted" backups.
X
X	Intro To The Famous 'alldisks' UNIX Backup Script	p. 7 of 7
X
XWhat else should I read?
XWe recommend that you read:
X1) The output from "backup help" to see all command-line features and options
X2) The output from "backup examples" to see some examples
X3) The "README.PROB" file in this directory
X4) The attached documents in the "doc" directory with more miscellaneous info:
X	alld.features (old, so it doesn't include newer features)
X	alld.notes
X	alld.prob
X	alld.q
X	gen.restore.q
X5) Man pages for your OS: dump(8), restore(1), tar(1), cpio(1), dd(1)
X6) 'alldisks' itself:  The comments throughout the script contain big
Xhelpful info.  At over 150k of fairly heavily commented code, the script
Xis a great learning experience for the somewhat knowledgable shell coder.
X7) "If You've Seen One UNIX, You've Seen Them All", Bob Arnold,
XLarge Installation Systems Administration V Conference Proceedings,
XUSENIX, 1991.
X8) "Torture-testing Backup and Archive Programs: Things You
XOught to Know But Probably Would Rather Not", Elizabeth Zwicky,
XLarge Installation Systems Administration V Conference
XProceedings, USENIX, 1991.
X9) "Issues with Online Backups", Steve Shumway, Large Installation
XSystems Administration V Conference Proceedings, USENIX, 1991.
SHAR_EOF
chmod 0644 src/backup/README ||
echo 'restore of src/backup/README failed'
Wc_c="`wc -c < 'src/backup/README'`"
test 17406 -eq "$Wc_c" ||
	echo 'src/backup/README: original size 17406, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= src/backup/.cshrc ==============
if test -f 'src/backup/.cshrc' -a X"$1" != X"-c"; then
	echo 'x - skipping src/backup/.cshrc (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting src/backup/.cshrc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'src/backup/.cshrc' &&
X## Standard Data Center .cshrc for user, root and backup accounts
X## 3/10/94, rca
X
X## Warning - this does NOT work on SCO, because SCO's csh reverses the
X## sense of "||" and "&&".
X
X## we always want the path, so try to get it from /etc/saenv
X# if we don't have system administration environment research report
Xif ( ! -r /etc/saenv || -z /etc/saenv ) then
X	set host=''
X	set arch=''
X	set mailer=''
X	set path=(/usr/ucb /bin /etc /usr/bin /usr/etc /sbin /usr/sbin /usr/5bin /usr/local/bin /usr/lbin)
X# else get info from it
Xelse
X	set path=(/usr/ucb /bin /etc /usr/bin /usr/etc /sbin /usr/sbin /usr/5bin /usr/local/bin /usr/lbin)
X	# delete non-PATH lines, strip PATH= and comments, change ":" to
X	# "<SPACE>";
X	# the only way to quote a "!" in csh is with a backslash, and we
X	# need a second one for the subshell
X	# delete /etc/dist/bin now, but if we're root put it back
X	set path=(`sed -e '/^PATH=/\\!d' -e 's/^PATH=//' -e 's/[ 	].*//' -e 's/:/ /g' -e 's,/etc/dist/bin,,' /etc/saenv`)
X	set arch=`sed -n -e 's/^ARCH_S=\([^ 	]*\)[	].*/\1/p' /etc/saenv`
X	set host=`sed -n -e 's/^HOST=\([^ 	]*\)[	].*/\1/p' /etc/saenv`
X	set mailer=`sed -n -e 's/^MAILER=\([^ 	]*\)[	].*/\1/p' /etc/saenv`
Xendif
X# in case $host is null after attempt to get it from /etc/saenv
Xif ( "$host" == "" ) then
X	# The sed is needed because SCO's csh's thinks "||" means "and",
X	# and we want unqualified hostnames
X	set host=`(hostname || uname -n ) | sed -e 's/\..*//p' -e '1q'`
Xendif
X# in case $mailer is null after attempt to get it from /etc/saenv
Xif ( "$mailer" == "" ) then
X	# most common around here
X	set mailer=Mail
Xendif
X# in case $path is null after attempt to get it from /etc/saenv
Xif ( "$path" == "" ) then
X	set path=(/usr/ucb /bin /etc /usr/bin /usr/etc /sbin /usr/sbin /usr/5bin /usr/local/bin /usr/lbin)
Xendif
X# add X11R4 to the path - needed even for non-interactive X11 tools
X# like .mwmrc which use the path from .cshrc
Xif ( "$arch" != "" && -d /usr/local/X11R4/bin/$arch ) then
X	set path=($path /usr/local/X11R4/bin/$arch)
X	if ( "$host" != "" ) then
X		set display=$host
X	else
X		set display=unix
X	endif
X	setenv	DISPLAY ${display}:0.0
X	if ($?LD_LIBRARY_PATH) then
X		setenv	LD_LIBRARY_PATH	${LD_LIBRARY_PATH}:/usr/local/X11R4/lib/$arch
X	else
X		setenv	LD_LIBRARY_PATH	/lib:/usr/lib:/usr/local/X11R4/lib/$arch
X	endif
Xendif
X# add openwin to the path if we have it
Xif ( -d /usr/openwin/bin ) then
X	set path=(/usr/openwin/bin $path)
X	setenv	OPENWINHOME	/usr/openwin
Xendif
X
X## if we have an interactive shell
Xif ( $?prompt ) then
X
X	## find out who we are, if we can
X	set whouser=''
X	set whologname=''
X	set whoami=''
X	# $USER is BSD
X	if ( $?USER ) then
X		set whouser=$USER
X	endif
X	# LOGNAME is SysV
X	if ( $?LOGNAME ) then
X		set whologname=$LOGNAME
X	endif
X	# if both of these are empty then we really need $whoami
X	if ( "$whouser" == "" || "$whologname" == "" ) then
X		# In csh we can't quote "!" except with backslashes, and we
X		# need two of them because of the subshell.
X		# We need the Bourne shell so we can toss any standard error
X		# from the "who am i", which can occur under HP-UX with C2
X		# security if the shell isn't attached to a tty.
X		set whoami=`sh -c 'who am i 2> /dev/null' | sed -e 's/[ 	].*//' -e 's/^.*\\!//'`
X	endif
X
X	## see if we're root or not
X	set amroot=0		# assume we're an ordinary user ...
X	set promptchar='>'	# with an ordinary prompt
X	touch /tmp/.cshrc$$
X	if ( `ls -l /tmp/.cshrc$$ | egrep root | wc -l` ) then
X		set amroot=1
X		set promptchar='#'
X	endif
X	rm -f /tmp/.cshrc$$
X	# if we're root add /etc/dist/bin to path and handle preferred shells
X	if ( $amroot ) then
X		set path=($path /etc/dist/bin)
X	# else add "~/bin" and "." to the path
X	else
X		# add ~/bin if it exists
X		if ( -d ~/bin ) set path=($path ~/bin )
X		# add "." (current directory) to the path; put it last 
X		set path=($path .)
X	endif
X
X	# deal with terminal stuff here
X	if ( $?TERM ) then
X		# if $TERM == network or dumb, then we guess that we're coming
X		# in from a terminal server or some unix box which doesn't
X		# know about its serial lines
X		if ( $TERM == network || $TERM == unknown || $TERM == dumb ) then
X			setenv  TERM    vt100
X		endif
X		# HP xterm weirdness
X		set x=`egrep "^OS_S=HP-UX[ 	]" /etc/saenv >& /dev/null`
X		if ( $TERM == "xterm" && $#x ) then
X			/usr/bin/X11/resize > /tmp/$$
X			source /tmp/$$
X			rm /tmp/$$
X		endif
X	endif
X
X	## Finally we can get on with all this normal stuff!
X	# set shell variables
X	set	history=100			# remember 100 commands
X	set	ignoreeof			# no <CTRL>D
X	set	autologout=0			# turn off HP-UX autologout
X	set	prompt="$host \!$promptchar "	# set prompt
X	set	filec				# set file completion
X	# set environment variables
X	setenv	SHELL	/bin/csh
X	setenv	EXINIT	"se ai redraw magic shell=$SHELL terse nowarn sm"
X	setenv	MANPATH	/usr/local/man:/usr/man
X	setenv	EDITOR	vi
X	# useful command aliases
X	alias	a	alias
X	alias	c	clear
X	alias	d	dirs
X	alias	dec	"(stty intr '^c' erase '^?' ; stty susp '^z' ; stty echoe ; stty crt) >& /dev/null"
X	alias	h	history
X	alias	hm	"history | more"
X	alias	j	jobs -l
X	alias	ls	ls -FC
X	alias	m	$mailer
X	alias	mail	$mailer
X	alias	resize	'eval `/usr/bin/X11/resize`'	# for HP-UX xterms
X	alias	so	source
X	alias	z	suspend
X
X	## get local .cshrc if any
X	set local=~/.cshrc.$host
X	if ( -o $local && -r $local && -f $local && ! -z $local ) source $local
X
X	## for backup account
X	set getop=.getoper.csh
X	if ( -o $getop && -r $getop && -f $getop && ! -z $getop ) then
X		set path=(~backup $path)
X		source $getop
X		# say whether backups have to be done as root
X		if ( `ls -l backup | egrep -c '^...x'` ) then
X			echo ""
X			echo "Backups on $host must be done as root."
X			echo ""
X		endif
X	endif
X
X	## finish up
X	unset arch host	mailer		# from /etc/saenv
X	unset local			# for .cshrc.$host
X	unset getop			# for .getoper.csh for backup account
X	unset display			# for X11
X	unset x				# misc
X	unset amroot promptchar		# root stuff
X	unset whologname whouser whoami	# who we are
X	unset echo verbose		# defense against debugging
Xendif
SHAR_EOF
chmod 0644 src/backup/.cshrc ||
echo 'restore of src/backup/.cshrc failed'
Wc_c="`wc -c < 'src/backup/.cshrc'`"
test 5952 -eq "$Wc_c" ||
	echo 'src/backup/.cshrc: original size 5952, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= src/backup/.getoper.csh ==============
if test -f 'src/backup/.getoper.csh' -a X"$1" != X"-c"; then
	echo 'x - skipping src/backup/.getoper.csh (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting src/backup/.getoper.csh (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'src/backup/.getoper.csh' &&
X#!/bin/csh
X# .getoper.csh is used to set up environment for backup operators
Xecho ""
Xwhile (1)
X	echo -n "Please enter your intials: "
X	set oper=$<
X	if ( "$oper" == "" ) continue
X	foreach f ( bkp.opers bkp.opers.loc )
X		if ( -f $f ) then
X			# each part of the regular expression has to be quoted
X			# seperately, since the csh wants to interpret
X			# "$oper[ 	]" as a csh variable similar
X			# to $argv[2], say.
X			if ( `grep -c "^$oper""[ 	]" $f` ) then
X				setenv OPER $oper
X				unset oper
X				break
X			endif
X		endif
X	end
X	if ($?OPER) break
X	echo "I don't know who $oper is."
X	echo -n "Do you wish to be added as a backup operator? "
X	set ans=$<
X	if ( "$ans" == "y" || "$ans" == "Y" || "$ans" == "yes" || "$ans" == "YES" )  then
X		echo -n "Enter your personal login name: "
X		set operlogin=$<
X		echo -n "Enter your Full Name: "
X		setenv OPER $oper
X		echo "$OPER	$operlogin		$<" >> $HOME/bkp.opers
X		unset oper
X		unset operlogin
X		break
X	endif
X	setenv OPER '??'
X	break
Xend
Xset prompt="$OPER.backup@$prompt"
SHAR_EOF
chmod 0644 src/backup/.getoper.csh ||
echo 'restore of src/backup/.getoper.csh failed'
Wc_c="`wc -c < 'src/backup/.getoper.csh'`"
test 1007 -eq "$Wc_c" ||
	echo 'src/backup/.getoper.csh: original size 1007, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= src/backup/.getoper.sh ==============
if test -f 'src/backup/.getoper.sh' -a X"$1" != X"-c"; then
	echo 'x - skipping src/backup/.getoper.sh (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting src/backup/.getoper.sh (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'src/backup/.getoper.sh' &&
X:
X# .getoper.sh is used to set up environment for backup operators
Xecho ""
Xwhile : ; do
X	echo "Please enter your intials:" "\c"
X	read OPER
X	test -z "$OPER" && continue
X	grep "^$OPER[ 	]" bkp.opers > /dev/null && export OPER && break
X	echo "I don't know who $OPER is."
X	echo "Do you wish to be added as a backup operator?" "\c"
X	read ans
X	case $ans in
X	[yY]*)
X		echo "Enter your personal login name:" "\c"
X		read login
X		echo "Enter your Full Name:" "\c"
X		read name
X		echo "$OPER	$login		$name" >> bkp.opers
X		break
X	;;
X	esac
X	OPER='??'
X	export OPER
X	break
Xdone
XPS1="$OPER.backup@`uname -n` \$ "
SHAR_EOF
chmod 0644 src/backup/.getoper.sh ||
echo 'restore of src/backup/.getoper.sh failed'
Wc_c="`wc -c < 'src/backup/.getoper.sh'`"
test 596 -eq "$Wc_c" ||
	echo 'src/backup/.getoper.sh: original size 596, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= src/backup/.profile ==============
if test -f 'src/backup/.profile' -a X"$1" != X"-c"; then
	echo 'x - skipping src/backup/.profile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting src/backup/.profile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'src/backup/.profile' &&
X:
SHAR_EOF
true || echo 'restore of src/backup/.profile failed'
fi
echo 'End of saenv5.01 part 4'
echo 'File src/backup/.profile is continued in part 5'
echo 5 > _shar_seq_.tmp
exit 0
