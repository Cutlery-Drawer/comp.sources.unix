Newsgroups: comp.sources.unix
From: kinch@julian.uwo.ca (Dave Kinchlea)
Subject: v28i210: saudi - provide a syslog audit of 'su' users, Part01/01
Message-id: <1.789895212.28878@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: kinch@julian.uwo.ca (Dave Kinchlea)
Posting-Number: Volume 28, Issue 210
Archive-Name: saudi/part01

	suadi is simply script(1) modified to perform authentication as well
as to do logging to the SYSLOGD rather than to a file. Some code from su(1)
has also been borrowed (specifically the code to implement the `su -'
command --- this provides a complete login environment as opposed to a
modified user environment; ie: $HOME == ~root).

[ i added a leading "*" to the supplied saudi.passwd file's live entry. --vix ]

#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	README
#	BEWARE
#	Makefile
#	VERSIONS
#	suadi.c
#	suadi.h
#	suadi.man
#	suadi.passwd
# This archive created: Thu Jan 12 01:47:03 1995
export PATH; PATH=/bin:$PATH
echo shar: extracting "'README'" '(4767 characters)'
if test -f 'README'
then
	echo shar: will not over-write existing file "'README'"
else
cat << \SHAR_EOF > 'README'
 $Author: kinch $
 $Date: 1994/09/27 15:30:59 $
 $Id: README,v 1.8 1994/09/27 15:30:59 kinch Exp kinch $
 $Source: /usr/internal/dst/kinch/src/suadi/RCS/README,v $
 $Locker: kinch $

Original work August 1994 by Dave Kinchlea <kinch@julian.uwo.ca> Kudos
to Reg Quinton <reggers@julian.uwo.ca> for the idea and his help in
implementing this on the various platforms.

  Copyright (c) 1994 The University of Western Ontario.  All rights
  reserved.  Redistribution is permitted provided that this notice is
  preserved and that due credit is given to the authors as well as The
  University of Western Ontario. 

	Please send any modifications/bug fixes/requests/kudos or
complaints to: kinch@julian.uwo.ca

		SU AUDIT: README

	As more and more systems get added to a computer network, more
and more people are needed to administer the network. From time to
time, each of these people will need some form of root access to
perform their duties. The standard command to do this, /bin/su, has
three flaws that this program (suadi) addresses:

	1) /bin/su requires that the user invoking it know the `root'
password; It is felt that knowledge of the `root' password should be
limited to as few people as possible (for justification of this
statment, refer to the document:"UNIX Policies and Procedures Manual"
available on-line (on ITS systems) from: ~ftp/doc/unix-policy.[ps|text]).

	2) Many flavours of UNIX only allow members of the `wheel'
group to su to root, unfortunately this cannot be relied upon on a
truly heterogeneous network (like the one ITS administers) nor is that
`policy' right for all environments;

	3) /bin/su has no facility to audit its use, beyond a single
entry in a log file (usually SYSLOG). It is desirable to monitor
(especially new and/or vendor supplied) users who are working with
root privileges. The desire to monitor does not necessarily stem from
an inherent distrust of users, rather out of a desire to ensure that
users are performing tasks that require root access in as safe and
secure an environment as possible as well as for as short a time as
possible.


	There does not exist such a tool as of this writing (at least,
one has not been heard of locally) and so suadi has been designed for
the task. The intention is to provide a database of users who are
allowed to gain root access (using the standard passwd file syntax and
semantics) each with their own password. If the user who invokes suadi
is in the database, they will be prompted for a password and if the
authentication process passes, the user will be given a *standard*
root shell and *all actions performed as root will be logged to
SYSLOG*.


	suadi is simply script(1) modified to perform authentication
as well as to do logging to the SYSLOGD rather than to a file. Some
code from su(1) has also been borrowed (specifically the code to
implement the `su -' command --- this provides a complete login
environment as opposed to a modified user environment; ie: $HOME ==
~root).

	The modifications to log to SYSLOGD are simple and portable
across all systems (via the syslog() system function) as is the modifications
to provide authentication. In fact, the only BSD vs SYSV problems are
with pseudo ttys and controlling terminals.

	*NOTE*: suadi should not be thought of as a `secure' su
alternative.  The auditing being done can *very* easily be defeated.
If you do not trust the people using suadi, they should not have
access to it!


	suadi.h contains many customizable values (default file names,
buffer sizes etc) and MUST BE edited (at least reviewed) before
compiling.


Files in this distribution:
BEWARE:		This file describes problems/concerns both past and present
Makefile:	A makefile for many machines
README:		This file
VERSIONS:	(slightly) edited output from rlog suadi.c suadi.h
suadi.c:	C source code for suadi, if I did things right you
	shouldn't need to make any modifications to this file (unless you are
	porting to a new architecture, of course).
suadi.h:	This should probably be suadi.config.h as there more
	options in here than ls itself ;-(
suadi.man:	Standard nroff man page
suadi.passwd:	passwd stub, this file will not allow any access.


TO DO:
	It might be a good idea to check to see that both the invoking
user AND the -u user are allowed access, currently (94/09/01) only the
-u user (which IS the invoking user by default) is checked. --- -u
user option removed as just a bad idea. (94/09/30)

	Get controlling terminal to work on SYSV. --- DONE. (94/09/02 -kinch)

	Find/fix problem with EPIX 1.4.3 and apparent ICANNON
behaviour --- DONE (94/11/14 -kinch)

	Find/fix problem with AIX and lost processes. --- DONE (I
think ;-() (94/11/15)

	Add ability to su user (instead of su root)

	Get people to use it, hmmmmmmmmm.

SHAR_EOF
fi # end of overwriting check
echo shar: extracting "'BEWARE'" '(3682 characters)'
if test -f 'BEWARE'
then
	echo shar: will not over-write existing file "'BEWARE'"
else
cat << \SHAR_EOF > 'BEWARE'
 $Author: kinch $
 $Id: BEWARE,v 1.7 1994/10/04 16:30:16 kinch Exp kinch $
 $Source: /usr/internal/dst/kinch/src/suadi/RCS/BEWARE,v $
 $Locker: kinch $

Original work August 1994 by Dave Kinchlea <kinch@julian.uwo.ca>

  Copyright (c) 1994 The University of Western Ontario.  All rights
  reserved.  Redistribution is permitted provided that this notice is
  preserved and that due credit is given to the authors as well as The
  University of Western Ontario.


	SU AUDIT: BEWARE

There are a few things to be concerned about with respect to
suadi:

1) By necessity, suadi is a setuid program. This, in itself, if
not too much of a concern as the intention of the program is to
provide root access ;-(

2) SYSLOGD must be given `records' to log, this means that suadi
*must* do some internal buffering of input to ensure proper records
are logged. One MUST be sure that the buffer is large enough. Most
shells read input one character at a time (CBREAK mode) and so there
is not always a predefined line length limit to use and there is very
little control with respect to the output arbitrary programs can
generate. Experience has shown that syslog lines of large lengths can
confuse SYSLOGD, as such all records should be limited to a size of
MAX_SYSLOG_LEN (see suadi.h) and multiple records should be
used when appropriate (each `record' is a newline terminated string)

3) As with script, absolutely NO filtering of input is done. As such,
many of the lines written to SYSLOG will appear to contain garbage
when in fact they contain terminal control characters (wrt prompts)
and line editing control characters (typically backspace/delete
characters). There is no known way to remove these characters while at
the same time guaranteeing that the important information is logged.
This behaviour is identical to the way that script(1) works.

4) This code works on BSD and SYSV systems. IT IS IMPERATIVE that one
of BSD or SYSV be defined for compilation. There is a check in suadi.h
to insure this, it uses the #error pre-processing macro. Not all
compilers can deal with this (specifically, pre-ansi compilers).

5) The pseudo tty interface is different for each environment. The
relevant code is in getmaster() and getslave(). 

6) Controlling terminals are handled differently for SYSV and BSD.

7) Termios is used over termio when possible. You CAN'T tell from
suadi.c which code is being used, look at suadi.h

8) the MIPS compiler (umips 1.4.3) is confused with this code. We
speculate that there is a library mismatch but have not been able to
track it down as yet. The long and the short of this is that the
master process will *not* stop cannonical processing. This can be
confusing to the user but otherwise does not seriously effect the use
of suadi. We have decided that it is not worth the extra effort to get
this to work with the mips machine.

8a) This has been fixed, in EP/IX 1.4.3 the OPOST mode bit in termio
does not seem to be honoured, it is necessary to completely clear
rtt.cc_oflags. 

9) NOTE: suadi should not be thought of as a `secure' su alternative.
The auditing being done can *very* easily be defeated. If you do not
trust the people using suadi, they should not have access to it!

10) AIX 3.2.5 seems to  have a race condition in the code where the
process doing the logging tries to read from the shell's pipe before
teh shell is ready to write. The logging process would then die but
the shell wouldn't realize it. A kludge around this has been put
in. Just BEFORE the call to dooutput() a sleep(SLEEPTIME) is called
(SLEEPTIME is defined in suadi.h). I suspect that this time
could/should be tweaked depending on how busy your system is.
SHAR_EOF
fi # end of overwriting check
echo shar: extracting "'Makefile'" '(4520 characters)'
if test -f 'Makefile'
then
	echo shar: will not over-write existing file "'Makefile'"
else
cat << \SHAR_EOF > 'Makefile'
# Makefile for suadi
#
# $Author: kinch $
# $Id: Makefile,v 1.15 1994/11/14 21:05:29 kinch Exp $
# $Source: /usr/internal/dst/kinch/src/suadi/RCS/Makefile,v $
# $Locker:  $
#
# Build and install things in the right places.
#
# Original work August 1994 by Dave Kinchlea <kinch@julian.uwo.ca>
#
#  Copyright (c) 1994 The University of Western Ontario.  All rights
#  reserved.  Redistribution is permitted provided that this notice is
#  preserved and that due credit is given to the authors as well as The
#  University of Western Ontario.
#
#  Start of Configuration Section

SHELL=  	/bin/sh
ENVIRONMENT=	SYSV
OLD=		/usr/local/old
BIN=		/usr/local/bin
MANEXT=		8
MAN=		/usr/local/man/man${MANEXT}
DIRS=		$(MAN) $(BIN)
PROG=		suadi
SRCS=		$(PROG).c $(PROG).passwd $(PROG).h
HDRS=		$(PROG).h
OBJS=		$(PROG).o 
GET=		co

# When testing I often do 'make FUNCTION= OPTIMIZE=-g' to skip my 
# setuid code and build something I can trace with dbx

FUNCTION= 	-DSETUID
OPTIMIZE=	-O ${FUNCTION}
debug=		0

# This assumes a BSD version of install, use 'make INSTALL=... install' to
# use your version of BSD install. If you don't know how to do that you

INSTALL=	install

# End of Global Configuration section.

all:	
	@echo "You must pick a platform, there is NO default"
	@echo "Choose from: $(SYSTEMS)"
	@echo "Or create your own!"

# To get things out of RCS

$(SRCS):;	$(GET) $@

# To make an object from source (it is assumed that there is a 
# corresponding header file for each source )

$(OBJS):   $(PROG).c $(PROG).h
	$(CC) $(CFLAGS) $(OPTIMIZE) -Ddebug=$(debug) -c $(PROG).c -D$(ENVIRONMENT)

# Make the image(s)

$(PROG): $(OBJS) Makefile
	$(CC) $(CFLAGS) $(OPTIMIZE) -o $(PROG) -D$(ENVIRONMENT) \
		$(LDFLAGS) $(OBJS) $(LOCAL_OBJS) $(LIBS) 
	
# Make some directories

$(DIRS):
	umask 022; mkdir -p $@

# Install things in the right places
#         the program, setuid (remove setuid bit on old executable)
#         the passwd database, readable only by root
#         the man page
# this assumes a ucb compatible install

install: $(DIRS) $(SRCS) 
	-mv $(BIN)/$(PROG) $(OLD)
	-chmod 0755 $(OLD)/$(PROG)
	$(INSTALL) -s -c -m 4755 -o root $(PROG) $(BIN)
	-mv $(MAN)/$(PROG).$(MANEXT) $(OLD)
	$(INSTALL) -c -m 644 $(PROG).man $(MAN)/$(PROG).$(MANEXT)
	@echo You need a /etc/suadi.passwd file.

# And clean up after yourself. Assume *~ are emacs backup files and
#     #*# files are emacs automatic backups.

clean:
	$(RM) *.o $(PROG) *~ \#*\#

# The following are supported enviornments
SYSTEMS=	sunos, solaris, aix, irix, epix
# This seems to work:
# [2:05pm suncon] uname -a
# SunOS suncon.cc 4.1.3_U1 1 sun4c
# [2:05pm suncon] date
# Thu Sep 22 14:05:45 EDT 1994

sunos:
	make ENVIRONMENT=BSD \
	     CC=gcc \
	     CFLAGS="-ansi -fwritable-strings \
		     -DNO_PWD_PROTO -DNO_GETPASS_PROTO \
		     -DNO_STRERROR ${CFLAGS}" \
	     OPTIMIZE="$(OPTIMIZE)" debug=$(debug) \
	     LIBS="" \
	     LDFLAGS="-static" \
	     $(PROG)

# This seems to work:
# [2:21pm falcon] uname -a
# SunOS falcon.ccs.uwo.ca 5.3 Generic_Patch sun4m sparc
# [2:21pm falcon] date
# Thu Sep 22 14:21:53 EDT 1994

solaris:
	make ENVIRONMENT=SYSV \
	     CC=gcc \
	     CFLAGS="-ansi -fwritable-strings\
		     -DHAS_CRYPT_H -DNO_GETPASS_PROTO ${CFLAGS}" \
	     OPTIMIZE="$(OPTIMIZE)" debug=$(debug) \
	     LIBS="" \
	     LDFLAGS="" $(PROG)

# This one works now:
# [1:54pm julian] uname -a 
# julian.uwo.ca julian.uwo.ca 1.4.3 UMIPS mips
# [1:54pm julian] date 
# Mon Oct  3 13:54:37 EDT 1994
#
# NOTE: There is still a problem with ICANNON being
# mistakenly on with the EPIX environment, but 
# this works acceptably well for now.

epix:
	make ENVIRONMENT=BSD \
	     CC=/usr/bin/cc2.20 \
	     CFLAGS="-systype bsd43 \
		     -D__mips__ \
		     -DNO_PWD_PROTO \
		     -DNO_STRERROR \
		     -DNO_TCGETATTR \
		     -DNO_WAITPID \
		     -DNO_GETPASS_PROTO ${CFLAGS}" \
	     OPTIMIZE="$(OPTIMIZE)" debug=$(debug) \
	     LIBS=""\
	     LDFLAGS="" \
	     $(PROG)
#
#  This seems to work:
# [12:11pm xia] uname -a
# AIX xia 2 3 000065074100
# [12:11pm xia] date
# Tue Oct  4 12:12:01 EDT 1994

aix:
	make ENVIRONMENT=BSD \
	     CC=xlc langlvl=extended \
	     CFLAGS="${CFLAGS} -DNO_PWD_QUOTA \
		     -D__aix__ -D_ALL_SOURCE \
		     -DNO_FGETPWENT" \
	     OPTIMIZE="$(OPTIMIZE)" debug=$(debug) \
	     LIBS="-lbsd" \
	     LDFLAGS="" \
	     $(PROG)
irix:
	make ENVIRONMENT=SYSV \
	     CC=cc \
	     CFLAGS="-xansi ${CFLAGS}" \
	     OPTIMIZE="$(OPTIMIZE)" debug=$(debug) \
	     LIBS="" \
	     LDFLAGS="" \
	     $(PROG)
SHAR_EOF
fi # end of overwriting check
echo shar: extracting "'VERSIONS'" '(11289 characters)'
if test -f 'VERSIONS'
then
	echo shar: will not over-write existing file "'VERSIONS'"
else
cat << \SHAR_EOF > 'VERSIONS'

RCS file: RCS/suadi.c,v
Working file: suadi.c
head: 1.16
branch:
locks: strict
access list:
	kinch
	reggers
symbolic names:
comment leader: " * "
keyword substitution: kv
total revisions: 16;	selected revisions: 16
description:
As more and more systems get added to a computer network, more and
more people are needed to administer the network. From time to time,
each of these people will need some form of root access to perform
their duties. The standard command to do this, /bin/su, has three flaws
that this program ($ROOTAUDIT) addresses:

1) /bin/su requires that the user invoking it know the `root'
password; It is felt that knowledge of the `root' password should be
limited to as few people as possible (for justification of this
statment, refer to the document:"UNIX Policies and Procedures Manual"
available online (on ITS systems) from:
~ftp/doc/unix-policy.[ps|text]).

2) Many flavours of UNIX do not allow non-members of the `wheel' group
to su to root, unfortunately this cannot be relied upon on a truly
heterogenous network (like the one ITS administers);

3) /bin/su has no facility to audit its use, beyond a single entry in
a log file (usually SYSLOG). It is desirable to monitor (especially
new) users who are working with root privileges. The desire to monitor
does not necessarily stem from an inherent distrust of users, rather
out of a desire to ensure that users are performing tasks that require
root access in as safe and secure an environment as possible as well
as for as short a time as possible.

There does not exist such a tool as of this writing (at least, one has
not been heard of locally) and so $ROOTAUDIT has been designed for the
task. The intention is to provide a database of users who are allowed
to gain root access (using the standard passwd file syntax and
semantics) each with their own password. If the user who envokes
$ROOTAUDIT is in the database, they will be prompted for a password
and if the authentication process passes, the user will be given a
*standard* root shell and *all actions performed as root will be
logged to SYSLOG*.


$ROOTAUDIT is simply script(1) modified to perform authentication as
well as to do logging to the SYSLOGD rather than to a file. Some code
from su(1) has also been borrowed (specifically the code to implement
the `su -' command --- this provides a complete login environment as
opposed to a modified user environment; ie: $HOME == ~root).

The modifications to log to SYSLOGD are simple and portable across all
systems (via the syslog() system function). The modifications for
authentication, however, are somewhat more complicated.

There are currently two distinct procedural methods for retrieving
passwords and password information from files other than /etc/passwd.
These are: fgetpwent() and setpwfile(). The easier method is the
setpwfile() call which simply tells the process which file to use for
all subsequent [get|set]pw*() functions. While fgetpwent() is not at all
difficult to use, there is no easy way to hide its use. That is, the
code is significantly different for the two approaches.

While some mixed universe environments (ie: EP/IX, SunOS 4.1.x)
provide both calls, fgetpwent() is the only function available on all
platforms (and the only one likely to found on future environments).
It is, therefore, the approach used by $ROOTAUDIT.
----------------------------
revision 1.16
date: 1994/11/14 18:33:24;  author: kinch;  state: Exp;  lines: +11 -8
On AIX there is an apparent race-condition in which the reader of the
new shell tries too quickly to read and fails, the new shell process has
no way of knowing this occured and seems lost (but is still active and most
likely with setuid(0) privs!). I put a sleep(SLEEPTIME) just before the call
to dooutput() hoping to allow enough time for doshell() to complete. Seems
to work (SLEEPTIME is defined in suadi.h)
----------------------------
revision 1.15
date: 1994/11/14 15:21:39;  author: kinch;  state: Exp;  lines: +6 -6
Changed to sections to get mips  RAW mode to work. fixtty(): added
line to remove all Output processing (shouldn't be necessary if not OPOST
but apparently it is on mips

Changed logic on doinput routine to stop on >= 0 instead of > 0

this fixes mips problems, haven't tested it on other platforms yet

kinch
----------------------------
revision 1.14
date: 1994/10/04 15:40:45;  author: kinch;  state: Exp;  lines: +12 -4
Added NO_FGETPWENT CPP macro to deal with machines that dont
have fgetpwent(FILE *) and, instead, need to use setpwfile(char *).
Currently, this is the case solely for AIX
----------------------------
revision 1.13
date: 1994/09/27 15:30:59;  author: kinch;  state: Exp;  lines: +12 -8
Added Copyright notice
----------------------------
revision 1.12
date: 1994/09/27 15:07:21;  author: kinch;  state: Exp;  lines: +15 -15
Wrapped all syslog(LOG_DEBUG) statements around if (debug) conditionals
which will be optimized away at compile time if debug=0
This was done at Reg's request.
----------------------------
revision 1.11
date: 1994/09/27 13:55:02;  author: kinch;  state: Exp;  lines: +10 -20
Cleaned up rootpwd initialization, I just didn't like the looks of
what I had done. Moved initialization to suadi.h, compile time initialization
The code is slightly easier to follow.
----------------------------
revision 1.10
date: 1994/09/26 20:46:29;  author: kinch;  state: Exp;  lines: +9 -9
Just changed some pointer magic, solaris is much pickyer than sunos
----------------------------
revision 1.9
date: 1994/09/26 19:38:12;  author: kinch;  state: Exp;  lines: +55 -12
Fixes to make the setuid stuff work properly. Added new static variables
in doshell() for putenv() calls, added proper checking for root information
in authorize_user() (information now found in authfilenm, or use
ROOT* defines.
----------------------------
revision 1.8
date: 1994/09/22 17:57:01;  author: reggers;  state: Exp;  lines: +7 -7
god damn mips
----------------------------
revision 1.7
date: 1994/09/22 17:52:09;  author: reggers;  state: Exp;  lines: +34 -24
BSD has setenv, SYSV has putenv. Pulled out fancy stuff where we pass
a user name. Will add some of that back but use it to go to that user
not to authenticate by that user.
----------------------------
revision 1.6
date: 1994/09/22 14:23:05;  author: kinch;  state: Exp;  lines: +14 -13
Cleaned up comments
Ready for release?
----------------------------
revision 1.5
date: 1994/09/21 13:34:33;  author: kinch;  state: Exp;  lines: +63 -29
Just added the rcs constants (Author, Id and Locked)
----------------------------
revision 1.4
date: 1994/09/02 18:47:55;  author: kinch;  state: Exp;  lines: +1 -1
Moved setpgrp() call to BEFORE open(slavepty) call in getslave(),
this allows for a controlling terminal.
----------------------------
revision 1.3
date: 1994/09/02 18:00:30;  author: kinch;  state: Exp;  lines: +66 -39
Added putenv() call to set $HOME,
Added syslog support: if debug LOG_LOCAL3|LOG_PID|LOG_DEBUG
else LOG_AUTH|LOG_PID|LOG_INFO  configurable using the
SYSLOG_FACILITY SYSLOG_OPTIONS and SYSLOG_PRIORITY defines

Added strcpy(username,Getlogin()) to save static user
information returned (Irix 5.2 share static area amongst
getpwuid and fgetpwent functions)

DEBUG statements now send to syslog(LOG_DEBUG), no
files now opened.
----------------------------
revision 1.2
date: 1994/09/01 16:41:52;  author: kinch;  state: Exp;  lines: +32 -11
Set ISIG flag on master (ignore signals), prevents user from killing
the process accidentally.

Added setuid code (in doshell)
----------------------------
revision 1.1
date: 1994/08/31 19:48:20;  author: kinch;  state: Exp;
Initial revision
=============================================================================

RCS file: RCS/suadi.h,v
Working file: suadi.h
head: 1.15
branch:
locks: strict
access list:
	kinch
	reggers
symbolic names:
comment leader: " * "
keyword substitution: kv
total revisions: 15;	selected revisions: 15
description:
Main header file for rootaudit, most arch dependant configurations
should go in this file.
----------------------------
revision 1.15
date: 1995/01/12 06:38:39;  author: kinch;  state: Exp;  lines: +23 -10
No changes, just prettying it up for submission to  the world. kinch
----------------------------
revision 1.14
date: 1994/11/14 18:36:04;  author: kinch;  state: Exp;  lines: +9 -1
Added SLEEPTIME to (an already defined) #ifdef __aix__ group, initiall set
to 3 (seconds). For info on this, either look at comment in suadi.h or read
rlog from suadi.c (or look at BEWARE file).
----------------------------
revision 1.13
date: 1994/10/04 16:15:57;  author: kinch;  state: Exp;  lines: +12 -4
Added check for aix and sys/ioctl (for struct winsize),
added check for aix to NOT include comment and quota fields of
struct passwd (not supported for AIX).
----------------------------
revision 1.12
date: 1994/09/27 15:30:59;  author: kinch;  state: Exp;  lines: +6 -1
Added Copyright notice
----------------------------
revision 1.11
date: 1994/09/27 13:55:02;  author: kinch;  state: Exp;  lines: +23 -14
Cleaned up rootpwd initialization, I just didn't like the looks of
what I had done. Moved initialization to suadi.h, compile time initialization
The code is slightly easier to follow.
----------------------------
revision 1.10
date: 1994/09/26 20:47:31;  author: kinch;  state: Exp;  lines: +3 -3
DEBUG statement refferred to old (and outdated) fdebug FILE pointer,
it has been changed to the more appropriate stderr.
----------------------------
revision 1.9
date: 1994/09/26 19:51:06;  author: kinch;  state: Exp;  lines: +3 -3
Whoops, left debug on. That is not the way we want it.
----------------------------
revision 1.8
date: 1994/09/26 19:36:54;  author: kinch;  state: Exp;  lines: +12 -5
 Added new global variables: rootname, rootdir and rootshell
 Added new CPP macros: ROOTNAME, ROOTDIR, ROOTUID, ROOTGID and ROOTSHELL
This is just to make the setuid stuff work (reading from authfilenm)
----------------------------
revision 1.7
date: 1994/09/22 17:53:11;  author: reggers;  state: Exp;  lines: +6 -6
debug error.
----------------------------
revision 1.6
date: 1994/09/22 16:28:34;  author: reggers;  state: Exp;  lines: +48 -21
some faulty logic on LOG_FACILITY
----------------------------
revision 1.5
date: 1994/09/22 14:28:32;  author: kinch;  state: Exp;  lines: +18 -13
Cleaned up comments, added SUADI_H macro (for future)
Ready for Release?
----------------------------
revision 1.4
date: 1994/09/21 13:34:33;  author: kinch;  state: Exp;  lines: +31 -10
Just added the rcs constants (Author, Id and Locked)
----------------------------
revision 1.3
date: 1994/09/02 18:00:30;  author: kinch;  state: Exp;  lines: +45 -4
Added NO_STRERROR define for machines that do not have this
function (define strerror(x) sys_errlist[x])

Created defines: SYSLOG_FACILITY, SYSLOG_OPTIONS and `
SYSLOG_PRIORITY for configurable syslog calls.
----------------------------
revision 1.2
date: 1994/09/01 16:41:52;  author: kinch;  state: Exp;  lines: +1 -0
Turned on debug as default (until stable)

----------------------------
revision 1.1
date: 1994/08/31 19:48:20;  author: kinch;  state: Exp;
Initial revision
=============================================================================
SHAR_EOF
fi # end of overwriting check
echo shar: extracting "'suadi.c'" '(13366 characters)'
if test -f 'suadi.c'
then
	echo shar: will not over-write existing file "'suadi.c'"
else
cat << \SHAR_EOF > 'suadi.c'
/*
  $Author: kinch $
  $Date: 1994/11/14 18:33:24 $
  $Id: suadi.c,v 1.16 1994/11/14 18:33:24 kinch Exp $
  $Source: /usr/internal/dst/kinch/src/suadi/RCS/suadi.c,v $
  $Locker:  $

  Original work August 1994 by Dave Kinchlea <kinch@julian.uwo.ca>

  Copyright (c) 1994 The University of Western Ontario.  All rights
  reserved.  Redistribution is permitted provided that this notice is
  preserved and that due credit is given to the authors as well as The
  University of Western Ontario.

  It should be no surprise that much of this code is stolen from:

  Copyright (c) 1980 Regents of the University of California.
  All rights reserved.  The Berkeley software License Agreement
  specifies the terms and conditions for redistribution.
*/

#ifndef lint
     static char copyright[] =
            "@(#) Copyright (c) 1980 Regents of the University of California.\n\
 All rights reserved.\n";
     static char sccsid[] = "@(#)script.c	5.4 (Berkeley) 11/13/85";
/* script 5..4 is the base for suadi */
     static char rcsid[] = "$Id: suadi.c,v 1.16 1994/11/14 18:33:24 kinch Exp $";
#endif  /* not lint */

#include "suadi.h"

main(int argc, char *argv[])
{
	extern char *optarg;
	extern int optind;
	int ch;
	
	strcpy(progname,argv[0]);
	while ((ch = getopt(argc, argv, "q")) != EOF)
		switch((char)ch) {
		case 'q':    /* Quite Mode */
		  qflg++;
		  break;
		case '?':
		default:
		  USAGE;
		  exit(1);
		}
	argc -= optind;
	argv += optind;

	/* Initialize syslog */

	openlog(progname,SYSLOG_OPTIONS,SYSLOG_FACILITY);
	setlogmask(LOG_UPTO(SYSLOG_PRIORITY));

	/* Who is this? (needed for authentication) */

	strcpy(username,Getlogin());
	user = username;
	  
	if (user == NULL) {
	  syslog(LOG_NOTICE,"Unknown user attempting access");
	  fprintf(stderr,"I can't figure out who you are, quitting\n");
	  USAGE;
	  exit(BAD_USER);
	}
	
	/* Before we do anything else, authenticate the user */

	if ((ch=authenticate_user((const char*)user))!= SUCCESS) {
	  fprintf(stderr,"Oops .. cannot authenticate!\n");
	  exit(ch);
	}

	    /* Ok, This person IS authenticated, let syslog know. */
	tvec = time((time_t *)0);
	syslog(LOG_INFO,"Successful attempt, %s (as %s) on %s at %s",
	       Getlogin(), user, ttyname(2),ctime(&tvec));

	getmaster();
	fixtty();

	(void) signal(SIGCHLD, finish);
	(void) signal(SIGBUS, finish);
	(void) signal(SIGSEGV, finish);
	child = fork();
	if (child < 0) {
	        syslog(LOG_ERR,"fork: %s",strerror(errno));
		perror("fork");
		fail();
	}
	if (child == 0) {
		subchild = child = fork();
		if (child < 0) {
		        syslog(LOG_ERR,"fork: %s",strerror(errno));
			perror("fork");
			fail();
		}
		if (child) {
		  /* This is the second process, it reads
		     input from master pipe (fed by starting process), outputs it
		     to */
#ifdef __aix__
		  sleep(SLEEPTIME);
#endif
		  dooutput();
		} else {
		  doshell();
		}
	}
	/* If here, we are the starting process. All our job is IPC for the
	   other two processes.*/
	doinput();
}

void
doinput(void)
{
	char ibuf[BUFSIZE];
	int cc;
	(void) close(1);  /* probably unnecessary, but no harm done */
	while ((cc = read(0, ibuf, BUFSIZE)) >= 0)
		(void) write(master, ibuf, cc);
	done();
}

void
finish(int dummy)
{
  int status; /* We can get away with this, because we dont care about status */
  
#ifdef NO_WAITPID
  int pid,die=0;
  while ((pid = wait(&status, WNOHANG, 0)) > 0)
    if (pid == child)
      die = 1;
  
  if (die)
    done();
#else
  if (waitpid(child,(int *)&status, WNOHANG) == child) 
    done();
#endif
  if (debug) syslog(LOG_DEBUG,"Caught Signal\n");
}

void
dooutput(void)
{
  char obuf[BUFSIZE+1];
  int cc;
  
  (void) close(0);
  tvec = time((time_t *)0);
  
  if (debug) syslog(LOG_DEBUG,"In dooutput");
  for (;;) {
    cc = read(master, obuf,sizeof(obuf));
    if (cc < 0) {
      if (debug) syslog(LOG_DEBUG,"EOF read on master, bye bye");
      break;
    } else if (cc > 0) {
      (void) write(1, obuf, cc);
      logit(obuf,cc); 
    }       /* else (cc > 0) */
  }             /* for (;;) */
  done();
}

void
  doshell(void)
{
  /* The following MUST be static (according to putenv, probably not really 
     a concern as this function is never left, still ...) */
  static char roothome[NAME_MAX];   
  static char rootuser[NAME_MAX];   
  static char rootlog[NAME_MAX];   
  static char rootshell[NAME_MAX];   

  if (debug) syslog(LOG_DEBUG,"In doshell\n");

  (void) close(master);
  getslave();
  if (dup2(slave, 0)<0){
    syslog(LOG_ERR,"Dup2, stdin: %s",strerror(errno));
    perror("Dup2, stdin");
    fail();
  }
  if (dup2(slave, 1)<0){
    syslog(LOG_ERR,"Dup2, stdout: %s",strerror(errno));
    perror("Dup2, stdout");
    fail();
  }
  if (dup2(slave, 2)<0){
    syslog(LOG_ERR,"Dup2, stderr: %s",strerror(errno));
    perror("Dup2, stderr");
    fail();
  }
  (void) close(slave);
  if (debug) syslog(LOG_DEBUG,"About to change identity");
#ifdef SETUID
  if (setuid(rootpwd.pw_uid) < 0) {
    syslog(LOG_ERR,"setuid failed: %s",strerror(errno));
    perror("suadi: setuid");
    fail();
  }
  if (setgid(rootpwd.pw_gid) < 0) {
    syslog(LOG_ERR,"setgfid failed: %s",strerror(errno));
    perror("suadi: setgid fail");
    fail();
  }
  if (initgroups(user,rootpwd.pw_gid) < 0) {
    fprintf(stderr,"suadi: initgroups failed\n");
    syslog(LOG_ERR,"initgroups failed");
    fail();
  }
#endif

  /* Ensure all users have same environment */
#ifdef __mips__
  setenv("HOME",rootpwd.pw_dir,1);
  setenv("USER",rootpwd.pw_name,1);
  setenv("LOGNAME",rootpwd.pw_name,1);
  setenv("SHELL",rootpwd.pw_shell,1);
#else
  sprintf(roothome,"HOME=%s",rootpwd.pw_dir);
  putenv(roothome);    
  sprintf(rootuser,"USER=%s",rootpwd.pw_name);
  putenv(rootuser);    
  sprintf(rootlog,"LOGNAME=%s",rootpwd.pw_name);
  putenv(rootlog);    
  sprintf(rootshell,"SHELL=%s",rootpwd.pw_shell);
  putenv(rootshell);    
#endif
  closelog();  /* finally, close the syslog file so that the shell doesn't accidentally use it */
  execl(rootpwd.pw_shell, rootpwd.pw_shell, "-i", 0);
  /* If here, execl failed. We have to be verbose because the initialization of syslog has been removed. */
  syslog(LOG_ERR|SYSLOG_FACILITY,"%s: exec of shell failed: %s",progname,strerror(errno));
  perror(rootpwd.pw_shell);
  fail();
}

void
fixtty(void)
{
  struct termios rtt;
  
  if (debug) syslog(LOG_DEBUG,"In fixtty");
  rtt = tt; /* tt holds Master attributes */
  rtt.c_lflag = LFLAG;
  rtt.c_oflag = LFLAG;
  rtt.c_cc[VMIN] = MIN_CHAR_NUM;
  rtt.c_cc[VTIME] = MIN_CHAR_TIME;
#ifdef NO_TCGETATTR
  (void) ioctl(0,TCSETA,&rtt);
#else
  (void) tcsetattr(0,TCSAFLUSH,&rtt);
#endif
  if (debug) syslog(LOG_DEBUG,"Out fixtty");
}

void 
fail(void)
{
  syslog(LOG_ERR,"Failure");
	(void) kill(0, SIGTERM);
	done();
}

void
done(void)
{

	if (subchild) {
		tvec = time((time_t *)0);
		syslog(LOG_INFO,"\nfinished on %s", ctime(&tvec));
		(void) close(master);
		(void) fflush(stderr);
	} else {
#ifdef NO_TCGETATTR
	        (void) ioctl(0,TCSETA,(char *) &tt);
#else
		(void) tcsetattr(0, TCSAFLUSH, &tt);
#endif
	}
	closelog();
	exit(0);
}

void
getmaster(void)
{

#ifdef SYSV
          extern char *ptsname(int);

          if ((master = open("/dev/ptmx", O_RDWR)) == -1) {   /* open master */
	    syslog(LOG_ERR,"Can't open master pty");
	    perror("Can't open master pty");
	    fail();
	  }
          if (grantpt(master)) {                      /* change permission ofslave */
	    syslog(LOG_ERR,"Can't grant pty");
	    perror("Can't grant pty");
	    fail();
	  }
          if (unlockpt(master)) {                     /* unlock slave */
	    syslog(LOG_ERR,"Can't unlock pty");
	    perror("Can't unlock pty");
	    fail();
	  }
          if ((slavename = ptsname(master)) == NULL) {          /* get name of slave */
	    syslog(LOG_ERR,"ptsname fail, (this shouldn't happen)");
	    perror("ptsname fail (this shouldn't happen)");
	    fail();
	  }
	  (void)tcgetattr(0,&tt);
	  (void)ioctl(0,TIOCGWINSZ,(char *)&win);
	  return;
#else      /* The BSD way */
	char *pty, *bank, *cp;
	struct stat stb;

	pty = &line[strlen("/dev/ptyp")];
	for (bank = "pqrstuvwxyz"; *bank; bank++) {
		line[strlen("/dev/pty")] = *bank;
		*pty = '0';
		if (stat(line, &stb) < 0)
			break;
		for (cp = "0123456789abcdef"; *cp; cp++) {
			*pty = *cp;
			master = open(line, O_RDWR);
			if (master >= 0) {
				char *tp = &line[strlen("/dev/")];
				int ok;

				/* verify slave side is usable */
				*tp = 't';
				ok = access(line, R_OK|W_OK) == 0;
				*tp = 'p';
				if (ok) {
#ifdef NO_TCGETATTR
				  (void) ioctl(0,TCGETA,(char *)&tt);
#else
				  (void) tcgetattr(0,&tt);
#endif
				  (void) ioctl(0, TIOCGWINSZ, (char *)&win);
				  if (debug) syslog(LOG_DEBUG,"Successful Out getmaster");
				  return;
				}
				(void) close(master);
			      } else {
				if (debug) syslog(LOG_DEBUG,"Open of pty fail, %s: %s",line,strerror(errno));
				if (debug) perror(line);
			      }
		      }
	      }
	  syslog(LOG_ERR,"Out of pty's\n");
	  fprintf(stderr, "Out of pty's\n");
	  fail();
#endif
}

void
getslave(void)
{
	int t;
if (debug) syslog(LOG_DEBUG,"In getslave\n");
#ifdef SYSV
        (void) setpgrp();
	if ((slave = open(slavename, O_RDWR)) == -1) {    /* open slave */
	  syslog(LOG_ERR,"%s: %s",slavename,strerror(errno));
	  perror(slavename);
	  fail();
	}
	(void)ioctl(slave, I_PUSH, "ptem");        /* push ptem */
	(void)ioctl(slave, I_PUSH, "ldterm");      /* push ldterm */
#else
	t = open("/dev/tty", O_RDWR);
	if (t >= 0) {
		if (ioctl(t, TIOCNOTTY, (char *)0) == -1) {
		  syslog(LOG_ERR,"IOCTL, No controlling terminal: %s",strerror(errno));
		  perror("IOCTL, No controlling terminal");
		}
		(void) close(t);
		if (debug) syslog(LOG_DEBUG,"Closed /dev/tty\n");
	}

	line[strlen("/dev/")] = 't';
	slave = open(line, O_RDWR);
	if (slave < 0) {
	        syslog(LOG_ERR,"%s: %s",line,strerror(errno));
		perror(line);
		fail();
	}
#endif

#ifdef NO_TCGETATTR
	(void) ioctl(slave,TCSETA,(char *)&tt);
#else
	(void) tcsetattr(slave,TCSAFLUSH,&tt);
#endif
	(void) ioctl(slave, TIOCSWINSZ, (char *)&win);
#ifdef TIOCSCTTY
	(void) ioctl(slave, TIOCSCTTY, 0);

	
#endif /*TIOCSCTTY */

	if (debug) syslog(LOG_DEBUG,"Done getslave");
}

int
authenticate_user(const char *user)
{
/*
   The authentication is not based on /etc/passwd, rather on a specific file
   for this program. The filename is: AUTHFILE (suadi.h).


   As the passwd file is not /bin/passwd, we cannot use getpwent* family, 
instead we use the fgetpwent() function.
*/

  FILE    *authfileptr;
  char   *password;
  struct passwd *authpwd;
  int fd;
  

#ifdef NO_FGETPWENT
#define fgetpwent(x) getpwent()
  setpwfile(authfilenm);
#else
  if ((authfileptr = fopen(authfilenm,"r")) == NULL) {
    syslog(LOG_ERR,"Authentication file open failed:%s",strerror(errno));
    perror(authfilenm);
    return(SYSFAIL);
  }
#endif
  /* We assume that the root entry in authfilenm will be the first entry, 
     and so if the user entry is found first, there IS not root entry.
     The test (below) will be if rootpwd.pw_name != NULL), so we ensure
     that this is the default. */
  
  rootpwd.pw_name = NULL;
  

  while ((authpwd = fgetpwent(authfileptr)) != NULL) {
    if (!strcmp(authpwd->pw_name,user)) break;
    if (!strcmp(authpwd->pw_name,ROOTNAME)) {
      /* We must make explicit copies, the info gets overwritten
	 the next call through. */
      strcpy(rootdir,authpwd->pw_dir);  
      strcpy(rootshell,authpwd->pw_shell); 
      rootpwd.pw_name = ROOTNAME; 
      rootpwd.pw_dir  = rootdir;
      rootpwd.pw_shell = rootshell;
      rootpwd.pw_uid = authpwd->pw_uid;
      rootpwd.pw_gid = authpwd->pw_gid;
    }
  }

#ifndef NO_FGETPWENT
  (void)fclose(authfileptr);
#endif

  if (authpwd) {
#ifdef __mips__
    fd = open("/dev/tty",O_RDWR);
    if (fd < 0) {
      perror("Can't open /dev/tty");
      syslog(LOG_ERR,"Can't open /dev/tty:%s",strerror(errno));
      return(SYSFAIL);
    }
#endif

    password = getpass("Password:");
    if (strcmp(authpwd->pw_passwd,crypt(password,authpwd->pw_passwd)) != 0) {
      tvec = time((time_t *)0);
      syslog(LOG_INFO,"Bad Password, %s (as %s) on %s at %s",
	     Getlogin(),user,ttyname(2), ctime(&tvec));
      return(BAD_PASS);
    }
  } else {
    fprintf(stderr,"%s is not authorized to use %s\n",user,progname);
    tvec = time((time_t *)0);
    syslog(LOG_ALERT,"Unauthorized attempt: %s (as %s) on %s at %s",
	   Getlogin(),user,ttyname(2),ctime(&tvec));
    return(BAD_USER);
  }
  /* If we got here, we have a authenticated user. If rootpwd.pw_name is NULL
     then a root entry was not found in the authfilenm. */
  if (! (rootpwd.pw_name)) {
    rootpwd.pw_name = ROOTNAME;
  }
  
  return(SUCCESS);
}

void 
logit(char *inbuf, int incnt)
{
/* Log all IO to syslog, this must be buffered to:
        a) prevent long lines,
	b) ensure reasonable formating

   This function has no return value as there does not seem
   any point in telling the process that something failed 
   (it may well be a good idea to send mail to root that syslog
   appears down, later ...)
*/

  static char buffer[MAX_SYSLOG_LEN];
  static int cnt=0;

  for (;incnt>0;incnt--,inbuf++,cnt++) {
    buffer[cnt] = *inbuf;
    if (*inbuf == '\n' || cnt==MAX_SYSLOG_LEN) {
      buffer[cnt+1] = '\0';
      syslog(LOG_INFO,"%s",buffer);
      cnt = -1; /* This insures that cnt will be zero for start of next loop */
    } 
  }
}

SHAR_EOF
fi # end of overwriting check
echo shar: extracting "'suadi.h'" '(6809 characters)'
if test -f 'suadi.h'
then
	echo shar: will not over-write existing file "'suadi.h'"
else
cat << \SHAR_EOF > 'suadi.h'
/*
  $Author: kinch $
  $Id: suadi.h,v 1.15 1995/01/12 06:38:39 kinch Exp $
  $Source: /usr/internal/dst/kinch/src/suadi/RCS/suadi.h,v $
  $Locker:  $

  Original work August 1994 by Dave Kinchlea <kinch@julian.uwo.ca>
  with Kudos to Reg Quinton <reggers@julian.uwo.ca> for the original
  idea and much help along the way.

  Copyright (c) 1994 The University of Western Ontario.  All rights
  reserved.  Redistribution is permitted provided that this notice is
  preserved and that due credit is given to the authors as well as The
  University of Western Ontario.

  This is the suadi header file. Any and all architectural modifications 
  should be made in this file (if at all possible) or better yet
  with 'make CFLAGS=-DVAR=value'.

*/

#ifndef SUADI_H
#define SUADI_H

#define USAGE fprintf(stderr, "usage: %s [-q] [file]\n\
\t-q: Be quite about all but serious errors\n\
progname)


/* All too often, there is a necessity to differentiate between system v and 
   bsd environments. There is no standard way to determine this, we EXPECT
   one of -DSYSV or -DBSD to be included, we will barf otherwise. 

NOTE: Not all compilers can deal with the #error preprocessor symbol */

#ifndef   SYSV 
#ifndef   BSD
#error "One of SYSV or BSD must be defined"
#endif /* SYSV */
#endif /* BSD */

/* GCC defines __STRICT_ANSI__, __STDC__ is the proper way to do this */

#ifdef __STRICT_ANSI__
#ifndef __STDC__
#define __STDC__
#endif
#endif

/* Necessary Include files */

#include <stdio.h>
#ifndef __mips__
#include <unistd.h>
#endif
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#ifdef __mips__
#include <posix/sys/termios.h>
#else
#include <termios.h>
#endif
#include <pwd.h>
#include <syslog.h>
#include <sys/file.h>
#include <fcntl.h>
#include <time.h>
#include <sys/wait.h>
#include <errno.h>

#ifdef SYSV
#include <sys/stropts.h>     /* This is the streams stuff for SYSV pty */
#endif

#ifdef __aix__
#include <sys/ioctl.h>
#define SLEEPTIME 3    /* time in seconds to sleep: This is necessary to subvert
			  a bad timing bug shown (so far) only in AIX 3.2.5 systems
			  The suspicion is that the code in dooutput() which is
			  simply a while read >= 0 returns -1 because the other
			  end of the pipe is not setup yet. You may have to adjust
			  SLEEPTIME depending on how busy your system is (how many
			  failed pseudo tty lookups). */
			  
#endif

#ifdef HAS_CRYPT_H
#include <crypt.h>
#else
#define NO_CRYPT_PROTO
#endif

/* Helpful macros for output */

#ifndef	debug
#define debug 0 /* (non-zero is on) */
#endif

/* Because of use of debug, this will be optimized out by even the
   dumbest of compilers */

#define DEBUG(x) if(debug) \
	{if(fprintf(stderr,"%s\n",x) != EOF) \
	   fflush(stderr); else perror("DEBUG");}

#define NOISE(x) if (!qflg) {x;}

/* Useful CONSTANTS */

#define MAX_SYSLOG_LEN 256 /* Allow room for syslog formating */

/* Allow for a different AUTHFILE to be given at compile time, else
use one in current directory if being compiled with debug (its easier
that way) */

#ifndef AUTHFILE
#if debug == 0
#define AUTHFILE "/etc/suadi.passwd"
#else
#define AUTHFILE "suadi.passwd"
#endif  /* ifdef debug */
#endif  /* ifndef AUTHFILE */

/* BUFSIZ is a system constant, we use BUFSIZE so you can freely change it */

#define BUFSIZE BUFSIZ

/* TTY modes */

#ifndef LFLAG
#define LFLAG 0     /* We want RAW mode */
#endif 
#ifndef MIN_CHAR_NUM
#define MIN_CHAR_NUM 1 /* minimum number of characters to read (stdin) */
#endif 
#ifndef MIN_CHAR_TIME
#define MIN_CHAR_TIME 10 /* Intercharacter timeout value */
#endif

/* The following are for syslog calls. If debug is defined, the
   default syslog values are LOG_LOCAL3:LOG_DEBUG:(LOG_PID|LOG_NOWAIT) if
   debug is not defined, the default values are:
   LOG_AUTH:LOG_INFO:(LOG_PID|LOG_NOWAIT). These can, of course, be
   changed at compile time via appropriate -D statements. */

#ifndef SYSLOG_FACILITY
#if debug == 0
#define SYSLOG_FACILITY LOG_AUTH
#else
#define SYSLOG_FACILITY LOG_LOCAL3
#endif /* ifdef debug */
#endif /* ifndef SYSLOG_FACILITY */

#ifndef SYSLOG_OPTIONS
#define SYSLOG_OPTIONS LOG_PID|LOG_NOWAIT
#endif

#ifndef SYSLOG_PRIORITY
#ifdef debug
#define SYSLOG_PRIORITY LOG_DEBUG
#else
#define SYSLOG_PRIORTIY LOG_INFO
#endif  /* ifdef debug */
#endif   /* ifndef SYSLOG_PRIORITY */


/* Some older systems don't have strerror but usually provide sys_errlist */

#ifdef NO_STRERROR
extern char *sys_errlist[];
extern int sys_nerr;
#define strerror(x) (sys_nerr >= errno? sys_errlist[x] : "Unknown error number")
#endif

/* Return Values */

#define TRUE 1
#define FALSE 0
#define SUCCESS  0
#define BAD_PASS 1
#define BAD_USER 2
#define SYSFAIL  3
#ifndef NAME_MAX
#define NAME_MAX 256   /* Max number of characters in a program name */
#endif

/* default root uid, gid, shell and directory, 
   overrriden by entry in AUTHFILE */

#define ROOTUID   0
#define ROOTGID   0
#define ROOTNAME  "root"
#define ROOTSHELL "/bin/sh"
#define ROOTDIR   "/"

/* GLOBAL variable section -- ugg */

/* This is the default root password entry, in case root is not found
   in the authfilenm. 
 { name, pass, uid, gid, quota, comment, gecos, dir, shell } */

struct  passwd rootpwd = { 
  ROOTNAME, "", ROOTUID, ROOTGID,
#ifndef NO_PWD_QUOTA
 0, "", 
#endif
"", ROOTDIR, ROOTSHELL
  }; 

/* We need the following in case a root entry IS found in authfilenm. */

char    rootdir[NAME_MAX]=ROOTDIR, rootshell[NAME_MAX]=ROOTSHELL;

char    *user=NULL;
char    progname[NAME_MAX];
char    username[NAME_MAX];      /* Needed by some to store getpwuid() information */
char	line[12] = "/dev/ptyXX";   /* Old ugly way of getting a pty */
char    *authfilenm = AUTHFILE;
int	master=0;
int	slave=0;
int	child=0;
int	subchild=0;
int	qflg=0;    /* aflg == append qflg == quiet */
struct	termios tt;
struct	winsize win;

#ifdef SYSV
          char *slavename;
#endif
time_t tvec;


/* Function Prototype declaration section */


#if !defined __STDC__ && !defined __mips__
#define void
#else
void doinput(void);
void finish(int);
void dooutput(void);
void doshell(void);
void fixtty(void);
void fail(void);
void done(void);
void getmaster(void);
void getslave(void);
int authenticate_user(const char *);
void logit(char *,int);

#ifdef NO_PWD_PROTO
struct passwd *fgetpwent(FILE *);
#endif

#ifdef NO_GETPASS_PROTO
char *getpass(const char *);
#endif

#ifdef NO_CRYPT_PROTO
char *crypt(const char *, const char *);
#endif

#endif /*__STDC__ && __mips__*/

/* Dont get too confused here, getpwuid returns a struct passwd *, 
   I am simply using that pointer to get at the login name. */

#define Getlogin() (getpwuid(getuid()))->pw_name  

#ifdef __mips__
struct passwd *getpwuid(struct passwd *);
struct passwd *getuid(void);
#endif

#endif /* SUADI_H */
SHAR_EOF
fi # end of overwriting check
echo shar: extracting "'suadi.man'" '(1359 characters)'
if test -f 'suadi.man'
then
	echo shar: will not over-write existing file "'suadi.man'"
else
cat << \SHAR_EOF > 'suadi.man'
.\" $Author: reggers $
.\" $Date: 1994/09/22 15:23:12 $
.\" $Id: suadi.man,v 1.4 1994/09/22 15:23:12 reggers Exp $
.\" $Source: /usr/src/usr.local/security/suadi/RCS/suadi.man,v $
.\" $Locker:  $
.\"
.\" Original work August 1994 by Dave Kinchlea <kinch@julian.uwo.ca>
.\"
.TH SUADI 8 "1 September 1994"
.SH NAME
suadi \- Allow and audit root access
.SH SYNOPSIS
.B suadi \%[\-q] \%[ user]
.br
.SH DESCRIPTION
.PP
.I Suadi
is a program that combines the functionality of 
.I su(1)
and 
.I script(1).
The user who invokes this program is checked against a database
(stored in 
.B /etc/passwd
format), authenticated via
.I passwd(1)
semantics using
.I crypt(3) 
and
then given a root shell or a shell for the user specified.
Anything returned to the terminal is logged via 
.IR syslog(3) .
The results, of course, should be monitored.
.SH OPTIONS
.TP
.BR \-q 
Quite mode this options turns off all output but errors.
.SH FILES
.TP
.B /etc/suadi.passwd 
A 
.I passwd(5)
style file containing all users who are allowed to use suadi. Each should
have a unique and non trivial password.
.SH BUGS
.PP
Any bugs found should be communicated to the author.
.SH SEE ALSO
.IR script(1) , 
.IR su(1) ,
.IR passwd(1) ,
.IR passwd(5) .
.SH AUTHOR
.PP
Dave Kinchlea <kinch@julian.uwo.ca>. Information Technology Services,
The University of Western Ontario. September 1994.


SHAR_EOF
fi # end of overwriting check
echo shar: extracting "'suadi.passwd'" '(154 characters)'
if test -f 'suadi.passwd'
then
	echo shar: will not over-write existing file "'suadi.passwd'"
else
cat << \SHAR_EOF > 'suadi.passwd'
root:NOLOGIN:0:1:Julian System Account,,,:/:/bin/tcsh
kinch:*twJUz8nC0/w1k:677:147:Dave Kinchlea,NatSci-101,6631,4611097:/usr/internal/dst/kinch:/bin/tcsh
SHAR_EOF
fi # end of overwriting check
#	End of shell archive
exit 0
