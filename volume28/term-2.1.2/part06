Newsgroups: comp.sources.unix
From: bcr@physics.purdue.edu (Bill C. Riemers)
Subject: v28i163: term-2.1.2 - slip-like functionality for a pair of UNIX hosts, Part06/06
References: <1.784076477.10661@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: bcr@physics.purdue.edu (Bill C. Riemers)
Posting-Number: Volume 28, Issue 163
Archive-Name: term-2.1.2/part06

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  BUGS CREDITS FAQ SCO.CHANGES TERMRC TODO checksum.c
#   client.h config.h debug.h includes.h jump/README.jump-updating
#   jump/jump.funcs jump/jump.params lib.h meta.c misc.c old/INTERNALS
# Wrapped by vixie@gw.home.vix.com on Sat Nov  5 14:58:36 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 6 (of 6)."'
if test -f 'BUGS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'BUGS'\"
else
  echo shar: Extracting \"'BUGS'\" \(140 characters\)
  sed "s/^X//" >'BUGS' <<'END_OF_FILE'
X
XOK, here are the known bugs in the alpha release:
X  1.  There is no clean way to abort tdownload...
X
X                                Bill
X
END_OF_FILE
  if test 140 -ne `wc -c <'BUGS'`; then
    echo shar: \"'BUGS'\" unpacked with wrong size!
  fi
  # end of 'BUGS'
fi
if test -f 'CREDITS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'CREDITS'\"
else
  echo shar: Extracting \"'CREDITS'\" \(2909 characters\)
  sed "s/^X//" >'CREDITS' <<'END_OF_FILE'
XI hope you like the program. It couldn't have been written without the
Xsupport and feed-back from a rather large number of ppl. 
X
XI tried the patience of my girlfriend sorely, and am very grateful
Xfor the support provided by the following ppl. This is by no means a
Xcomplete list, just the highlights. If I have missed someone, please
Xlet me know.
X
X	Michael. (oreillym@tartarus.uwa.edu.au).
X	(now michael@iinet.com.au)
X
XBill C. Riemers (bcr@physics.purdue.edu)
X	Stuck my fingers in everywhere and hacked term all to pieces.
X	You are using the remains of it right now.
X	Also added TitanOS support and termnet.
X
XDavid Wexelblat (dwex@mtgzfs3.att.com)
X	Write the extensive mods for SYSV support.
X
XDavid Dawes (dawes@physics.su.oz.au)
X	Debugged the above. 
X
XHugh Secker-Walker (hugh@ear.mit.edu)
X	Wrote NeXT support.
X
XWerner Almesberger (almesber@nessie.cs.id.ethz.ch)
X	Wrote SGI support
X
XJohn Hendrickson (hendrick@andrews.edu)
X	Wrote the original tredir client!
X	Write the tmon client too.
X	
XCroutons (crunchy!croutons@dartmouth.edu)
X	Most of the makefile.
X	The argument handling for trsh
X	The compression-per-channel as opposed to global.
X
XJeff Grills (jefftep@cs.utexas.edu)
X	Wrote the new upload. Also had many valuable ideas for
X	term internals. Also pushed me into cleaning up a lot of
X	things I had been too lazy to do.
X
XRick Sladkey (jsr@world.std.com)
X	Write termftp.
X	Fixed C_SOCKET to work with dotted decimal addresses.
X
Xgtaylor (gtaylor@Jade.Tufts.EDU)
X	Wrote the bulk of the manual pages.
X
Xssd@nevets.oau.org (Steven S. Dick)
X	Sent me the CRC routine in checksum.c
X
X<tema@snakemail.hut.fi>
X	Wrote the HPUX support.
X
Xhlu@eecs.wsu.edu (H.J. Lu)
X	Improved and extended the HPUX support.
X
Xjohnsonm@stolaf.edu (Michael K Johnson)
X	Edited the TERMRC file to work.
X
XTeemu Rantanen <tvr@cs.hut.fi>
X	Wrote the code to handle re-sizing of trsh windows.
X	
Xarumble@extro.ucc.su.oz.au
Xjason@sorokin.anu.edu.au
X	General support and suggestions and lots of little things
X	too numerous to mention.
X	
Xdlogue@Starbase.NeoSoft.COM (Dan Logue)
X	Added BSDI support.
X
Xuknf@rz.uni-karlsruhe.de (Olaf Titz)
X	Wrote tshutdown.c, and other stuff.  See old/Blurb for more details
X
XDerek Atkins <warlord@MIT.EDU>
X	C_GETHOSTNAME
X	C_GETPEERNAME
X	C_GETSOCKNAME
X
XStephen J. Roznowski <sjr@zombie.ncsc.mil>
X	Added NetBSD support.
X
XBOONE BARRY EDWARD <boone@a.cs.okstate.edu>
X	Added Dynix/ptx support
X
XChris Metcalf <metcalf@lcs.mit.edu>
X	Too many patches to even keep track, configure, Makefile.in, 
X        term_herror, ...  Oh yea, and lots of spilling corrections. :-)
X
XDavor Jadrijevic <davor%emard.uucp@ds5000.irb.hr>
X	Original shared library.
X
XDanny Gasparovski <u923168@student.canberra.edu.au>
X	Added UDP support.
X
XBrian Campbell <brianc@qnx.com>
X	Added QNX support.
X
XAmi Fischman <a540ami@pic.ucla.edu>
X	Added ISC (SVR3.2 clone) support
X
XAnyone I have left out (and there will be a fair few), please mail me,
Xand tell me.
X
END_OF_FILE
  if test 2909 -ne `wc -c <'CREDITS'`; then
    echo shar: \"'CREDITS'\" unpacked with wrong size!
  fi
  # end of 'CREDITS'
fi
if test -f 'FAQ' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'FAQ'\"
else
  echo shar: Extracting \"'FAQ'\" \(3854 characters\)
  sed "s/^X//" >'FAQ' <<'END_OF_FILE'
X1) Term doesn't work! Why not??!!
X
X	This is one of the most tremendously useful questions I have
Xever been asked. You will notice that it contains all the pertinent
Xinformation I might want to know, like what version of term they are
Xusing, and exactly what the symptoms are, and what machine they are
Xrunning it on, and what they have tried, etc etc. However here are a
Xfew things to try before mailing me with details. :)
X
X	a) Create a ~/.term/termrc file at both ends with the two
Xlines "escape 0-31" and "escape 128-159" in it. Then try term. If this
Xworks, try shortening the ranges as much as possible. Experience
Xindicates that most people will be able to get away with either
Xnothing, or "escape 17" and "escape 19", or escaping 17, 19, 145 and
X147. 
X
X	b) If 'a' doesn't work, it's possible that you have a
Xseven-bit line. Try using a termrc with the two lines "sevenbit"
Xand "escape 0-31" in it. It is important to know that the termrc at
Xeach end must have 'sevenbit' in it.
X	
X	If you do need to mail me please include as much of the following
Xlist as is relevant:
X		Term version(s):
X		Remote system:
X		Local system:
X		Local modem type & UART type:
X		Remote modem type & UART type, if known:
X		A detailed description of the problem.
X		A description of what you have tried.
X		A transcript of the problem, if possible.
X		Code that produces the problem, if possible.
X		A patch to fix it, if you know the solution.
X
X2) Term doesn't run as fast as it should. Why not??
X
X	Several ways to speed up term. Here are the most common...
X	a) Escape as few characters as possible. Escaping 32 characters will
Xcut thru-put by about 12-15%.
X
X	b) If you escape a character on one end, add a corresponding 'ignore'
Xon the other. I.e. if you 'escape 17' on the remote end, put a 'ignore 17'
Xon the local end.
X
X3) 'txconn' doesn't seem to work.
X
X	a) Make sure you have 'xhost +' on both machines.
X
X	b) X windows take awhile to open; be patient.
X
X	c) Make sure you are running txconn on your remote machine, not your
Xlocal machine.
X
X	d) The syntax of txconn for term 2.X is slightly different than 
X	   from term 1.X.  Be sure to read the manual page.
X
X        e) Try instead "tredir 6009 6000"
X
X4) X windows take a long time to open, and then run very slowly.
X
X	a) Try picking up a copy of sxpc from sunsite.unc.edu.  Don't ask
Xme how to install it; I've never used it.
X
X	b) Try compiling your favorite X applications on your home machine.
XFor applications like xarchie, this is a big win.
X
X	c) X11R6 will contain its own compression protocol, so don't expect
X'sxpc' to be incorporated into term.
X
X5) Trsh just hangs when I execute it.
X
X	Trsh is an endless source of problems.
X
X	a) Try using something simple like:
X
X	       	trsh -s echo trsh works in simple mode
X
X	If this works, then you can use "trsh" with the "-s" option.  Try
Xdefining NO_PTYEXEC in config.h and recompile.
X
X	b) Try using telnet instead.  i.e. Do once "tredir 4023 23".  Then
Xyou should be able to connect with the command "telnet localhost 4023".  If
Xthis works, you may wish to recompile telnet with the instructions in 
XREADME.porting, so you don't have to do the tredir command every time you
Xestablish a term connection.  Also, you can compile rlogin, so you don't have
Xto login every time.
X
X6) Is there a term mailing list?  Yes there is; it is a channel of
Xthe linux-activists stuff.  Try mailing:
X
X  echo X-Mn-Admin: join term | mail linux-activists-request@niksula.hut.fi
X
XA help file is available upon request from the same address.
X
X7) I get a : gethostbyname: ...  error when term starts.  Why?
X
X	This means that your `hostname` is not set properly set.  Term will
Xstill work despite this error, but won't automatically recognize your hostname.
X
X8) Where should I post term problems, questions, etc?
X
X	Try posting to comp.protocols.misc and cross-posting to
Xcomp.os.linux.help.
X
X
END_OF_FILE
  if test 3854 -ne `wc -c <'FAQ'`; then
    echo shar: \"'FAQ'\" unpacked with wrong size!
  fi
  # end of 'FAQ'
fi
if test -f 'SCO.CHANGES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'SCO.CHANGES'\"
else
  echo shar: Extracting \"'SCO.CHANGES'\" \(2844 characters\)
  sed "s/^X//" >'SCO.CHANGES' <<'END_OF_FILE'
XHere is a description of the changes I've made to term for use on SCO 
XUNIX.  There is a suggested change to the term protocol below.
X
X1. SCO UNIX does not support UNIX domain sockets.  The UNIX domain
X   sockets used for the term server/client communications have
X   been replaced with either TCP/IP sockets or streams pipes.
X
X   a) TCP/IP sockets.  These are enabled by defining NO_UNIX_DOMAIN
X      and not defining STREAMS_PIPE.  The server establishes a socket
X      and writes the port number to $HOME/.term/socket.  Clients
X      read that file to get the port number, and then connect to
X      that port on localhost.
X
X   b) Streams pipes are enabled by setting defining both NO_UNIX_DOMAIN
X      and STREAMS_PIPE.  This uses the SCO X server IPC connection
X      protocol to connect.  The server opens /dev/X#S (where # is
X      the display number).  Clients open /dev/X#R and write a dummy
X      byte to initiate a connection.  The server then creates an
X      appropriate streams pipe (/dev/spx) and sends the file 
X      descriptor to the client.  (See spipe.c)
X
X      Creating a named streams pipe requires root access on SCO.  In
X      order to avoid that, term is prepared to "borrow" an X server
X      local connection.  If you set TERM_BORROWED_DISPLAY_NUMBER to
X      an integer, the server and clients will use that X server
X      local connection as their IPC channel.  (The variable must
X      be set for both the server and the clients).  If the variable
X      is not set, the TCP/IP method will be used.
X
X2) SCO UNIX uses streams pipes to talk to the X server.  (See above
X   for a brief description of the protocol).  Rather than replace the
X   code in the term server that opens a UNIX domain socket, I extended
X   the protocol with a C_X_SERVER request.  This request causes the
X   remote term server to establish a connection to its X server
X   (as specified by its DISPLAY variable).
X
X   Note that this makes SCO term software incompatible (with respect
X   to txconn) with other versions, since the other end will either send
X   the wrong request (C_SOCKET rather than C_X_SERVER) or the other
X   term server won't recognise C_X_SERVER).
X
X   I would like to suggest that you modify your protocol so that xconn
X   always sends C_X_SERVER, and all term servers react to that by
X   setting up the appropriate connection.  It also seems to me most
X   sensible that the DISPLAY variable for the term server connecting
X   to the X server should drive which X server to connect to.  I
X   haven't done this, the code for ifdef'd under X_STREAMS_PIPE.
X
X
X3) Much of the code in spipe.c is borrowed from SCO's X server or X client
X   library.  It is freely redistributable as long as the copyright notice
X   remains intact (see spipe.c for details).  Don't yell at us if it doesn't
X   work.
X
XTom Kelly
Xtom@sco.com
X3 April 1994
END_OF_FILE
  if test 2844 -ne `wc -c <'SCO.CHANGES'`; then
    echo shar: \"'SCO.CHANGES'\" unpacked with wrong size!
  fi
  # end of 'SCO.CHANGES'
fi
if test -f 'TERMRC' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'TERMRC'\"
else
  echo shar: Extracting \"'TERMRC'\" \(6577 characters\)
  sed "s/^X//" >'TERMRC' <<'END_OF_FILE'
X#From johnsonm@stolaf.edu Sun Dec 13 05:07:38 1992
X#Updated by metcalf@lcs.mit.edu Nov 28 1993
X#Updated yet again and again...
X
X# This file should either be ~/.term/termrc for a user's settings, or
X# /etc/termrc for the system's default.
X
X#All blank lines, and lines beginning with a '#' are ignored.
X#All command words must be in lowercase.
X#valid lines are... 
X
X##############################################################################
X# ALWAYS REQUIRED OPTIONS !!!!
X#   If you don't use these options you will have problems!
X##############################################################################
X
Xremote
X# THIS MUST BE USED ON ONE END ONLY!!!! 
X# i.e. comment this out on one end. [-r]
X
X#baudrate 38400
X# Sets the baudrate. Actually used to limit the maximum
X# number of characters sent per second.
X# valid numbers are anything >= 300. Default varies. [-s INT]
X# For rates greater than 115200 use a value of 0.
X# Standard values: 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
X
X#############################################################################
X# COMMUNICATION SETTINGS
X#  Adjusting these settings will probably greatly improve your transmission
X#  speeds.  You will probably have to adjust some of these just to get a
X#  working connection.
X#############################################################################
X
Xtimeout 200
X# sets the length of time to wait before retransmitting a 
X# packet. If using a large window size, then increase this
X# value. A smaller window sizes merits a smaller timeout 
X# value. If getting too many re-transmits, then increase.
X# measured in 1/20th's of a second.   
X# Allowed 1-10000, default 70 (3.5 sec). [-t INT]
X
X#escape 158
X# tells term never to transmit character with decimal number 158.  Use the 
X# output of linecheck to find out what to put here.  Valid numbers are
X# anything between 0 and 255.  Any character escaped on one end must be
X# ignored on the other.
X
Xescape 0-31
Xescape 128-159
X# the above are some handy escapes that will cause most lines to work.
X# but they are very inefficient (they escape 25% of all bytes sent!!!)
X# so try and escape as few as possible.
X
Xignore 0-31
Xignore 128-159
X# Silently strip these characters from the input stream.  See escape.
X
X#window 3
X# Set the maximum number of packets that can be outstanding the large the
X# value, the better your maximum possible transmission speed, but if it is
X# too large, it will take a long to recover from timeout errors!  Allowed
X# values are 1-16.  The default is based on your baudrate. [-w]
X
Xshift 224
X# Sets a 'shift' value. This number is XOR'ed with all bytes before they
X# are sent and dramatically reduces the # of escape characters sent.  Typically
X# numbers between 224 and 255 give the best results.
X
Xsevenbit on
X# If we are running on a 7 bit line; off by default. [-a]
X
X#seven_in on
X# If your incoming line is seven bit.
X# Note that these are symmetric. If you have seven_in on one end, you MUST
X# have seven_out on the other.
X
X#seven_out on
X# If your outgoing line is seven bit. "seven_in" and "seven_out" together
X# are the same as "sevenbit".
X
X#stopbits 2
X# Adjust this to give you the correct transmission speed.
X# Standard values: 2, 1, 0.5, 0  (default 1)
X
X#compress off
X# To turn off compression.  If you have a compressing modem it is not desirable
X# to have term compressing your data.  (default on)  Each client may be set
X# on or off with '-c off/on'.
X
X#############################################################################
X# OPTIONS TO KEEP OTHERS FROM ACCESSING YOUR DATA/ACCOUNT
X#  These allow you to control the security level used by term.
X#############################################################################
X
X#denyrsh on
X# Disallow execution of shell on this end. (default off)
X
X#chroot '/usr/users/oreillym'
X# Perform a chroot() to the specified path, just before entering main loop.
X# This option is ignored if term is started by anybody except root.
X
X#share on
X# This controls whether other users my access the term socket by setting
X# the TERMMODE and TERMSHARE environmental variables, and using SUID -or-
X# SGID programs.  [-S on/off]
X
X
X#############################################################################
X# CUSTOMIZATION OPTIONS
X#  These allow you to customize how term works for you! 
X#############################################################################
X
X#chdir '/usr/users/oreillym'
X# Make the default directory usr/users/oreillym (my home dir).
X
X#login on
X# To specify you don't want "trsh" to default with a login shell.  (default off)
X
X#noise on
X# Turn on printing of line noise and warnings.  Off by default. [-n on/off]
X
X#quiet 1
X# Set the "quietness level", zero by default.  This is equivalent to
X# -q, but only takes effect after reading the termrc, so it has no effect
X# on the initial messages printed before reading termrc. 
X
Xterminate 'NO CARRIER'
X# sets a string that will cause term to exit.  ('00000' by default)
X# This must be at least 5 characters long, to avoid accidently 
X# terminations.
X
X#shell 'tredir 4119 dirac:119 4000 23'
X# This specifies some command you want to be given as soon as you execute your
X# first term command.  Normally this should be a script name or set of commands.
X
X# You can specify a log file on the command line with "-l PATH"
X# You can override using stdin/stdout by specifying a device as "-v PATH"
X# You can specify a debugging level with "-d INTEGER"
X
X#######################################################################
X# You probably won't need any of the following options, but they do help
X# solve some uncommon problems!
X#######################################################################
X
X#blocksize 512
X# Set the maximum size block that can be written to your modem at once.
X# Typical values are 256, 512, or unlimited.  (default 512)  You probably
X# don't need to change this.
X
Xcollisions on
X# Use this if you get lots of timeout errors only when transmitting and 
X# receiving at the same time.  (default off)
X
X#flowcontrol 500
X# Tell term to generate control-Q's every now and then
X# used in case your terminal server understands flow control
X# and things will accidently turn it off. i.e. line noise
X# sends a control-S.  Off (= 0) by default; must be nonnegative. [-f INT]
X
X#increment 20
X# This controls how many times a second term tries to send data.  Normally
X# 20 is fine, but for very high speed connections you may need to decrease
X# this.
X
X#packetsize 256
X# This is the maximum size packet term will use.  (default 256)  You probably 
X# won't need to adjust this.
X
END_OF_FILE
  if test 6577 -ne `wc -c <'TERMRC'`; then
    echo shar: \"'TERMRC'\" unpacked with wrong size!
  fi
  # end of 'TERMRC'
fi
if test -f 'TODO' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'TODO'\"
else
  echo shar: Extracting \"'TODO'\" \(3160 characters\)
  sed "s/^X//" >'TODO' <<'END_OF_FILE'
Xdone : Fix linecheck to be asymmetric. Also to check chars < 32.
Xdone : Skip bad pty slaves.
Xdone : Fix seven bit support
Xdone : Xconn needs to read DISPLAY properly. 
Xdone : Put in SGI patches. 
Xdone : Write a credits file. 
Xdone : X-windows is apparently dying again. Don't know why. Have to find out.
Xdone : upload occasionally has files go missing. Look into it.
Xdone : wait3 instead of waitpid. 
Xdone : Fix rsystem. Term hangs if you run it without an argument. 
Xdone : Catch signals and do a graceful clean-up. 
Xdone : Fix C_PORT and C_SOCKET so that errors get caught properly instead of just
X       hanging. Fix C_PTYEXEC as well. 
Xdone : Fix #include <termios.h>.Only be done if we are really using termios
Xdone : Add an 'ignore' array, and clean-up the escape array. Add ranges maybe??
Xdone : Fix #include <stdlib.h> unistd, and malloc.h. Make a generic #define to turn
X       them off.
Xdone : Fix byte-order for C_PORT.
Xdone : trsh going into a heavy load will hang (race condition in pty.c)
X	Fix upload to
Xdone :	a) use one arg. 
Xdone :	b) Do resumption! Resume upload a file. 
Xdone :	c) maybe write a download?? : sort of 
Xdone : Cut out all the 2400 baud limiters
Xdone : Fix rsh to exit properly when shell exits. Clean up exit messages.
Xdone : NNIGN. This will basically involve detecting and passing on read/write's of
X       zero length.
Xdone : Check out the Sun implementation. It still doesn't work reliably.
X
Xpending : Fix timeouts!!! Something is going badly wrong with them. Timeout
Xpending :  should maybe be dependent on number of outstanding packets??
X
Xdone : Fix terminal handling when doing remote-->linux rsh.
X
Xdone : Put in maximum packet size as a command line option.  As a termrc option.
X
Xdone : Fix possible race condition with a client starting up at both ends
X       at the same time. (they will both get the same client number. Bad.)
X
Xdone : Integrate linecheck/linerem into term.c
X
Xdone : Write a tdownload.
X
Xdone : Write a getting-started guide for newbies.
X
Xdone : Write an FAQ list too!!! Could cull Mail/received for this.
X
Xdone : Preserving time/date stamping with upload?
X
Xpending : Write a ping to generate every character.
X
Xdone : Add a mechanism for propagating environment variables.
X
Xpending : A mechanism for handling hangup. what it would involve.
X          1) Term going into background on a HUP, not exiting.
X          2) when term starts up, it should check for a backgrounded term to
X          foreground. 
X          3) There has to be a supervisor program that will watch the modem line.
X
Xpending : trsh sets a TERMSERVER for it's new shells.
Xdone : trsh should pass the 'TERM' env variable.
X
Xpending : fix tredir to take a config file.
X
Xdone : Write a UDP redirector for those crazy sods that want to mount an NFS
X       partition over term.. 
X
Xscrapped : Get the NFS mounts working now.
X
Xpending : Get PC-NFS mounts working over term.
Xpending : Pass client information cross exec() commands.
Xpending : Find and fix whatever is causing tdownload to terminate early.
Xpending : Get inetd to work, with socket address passing
Xpending : Find an easy way to share a term connection between multiple machines
X
END_OF_FILE
  if test 3160 -ne `wc -c <'TODO'`; then
    echo shar: \"'TODO'\" unpacked with wrong size!
  fi
  # end of 'TODO'
fi
if test -f 'checksum.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'checksum.c'\"
else
  echo shar: Extracting \"'checksum.c'\" \(4561 characters\)
  sed "s/^X//" >'checksum.c' <<'END_OF_FILE'
X/*
XFrom alfred!nevets!ssd@osceola.cs.ucf.edu Sun Dec 13 14:25:07 1992
XReturn-Path: <alfred!nevets!ssd@osceola.cs.ucf.edu>
XReceived: from osceola.cs.ucf.edu by tartarus.uwa.edu.au (5.65c/SMI-4.1)
X	id AA01410; Sun, 13 Dec 1992 14:24:59 +0800
XReceived: from alfred.UUCP by osceola.cs.ucf.edu (4.1/1.34)
X	id AA17217; Sun, 13 Dec 92 01:23:58 EST
XReceived: by alfred.oau.org (/\==/\ Smail3.1.28.1 #28.1)
X	id <m0n0mW0-00009iC@alfred.oau.org>; Sun, 13 Dec 92 01:09 EST
XReceived: by nevets.oau.org (Smail3.1.28.1 #2)
X	id m0n0mJs-0000OhC; Sun, 13 Dec 92 00:56 EST
XMessage-Id: <m0n0mJs-0000OhC@nevets.oau.org>
XFrom: ssd@nevets.oau.org (Steven S. Dick)
XDate: Sun, 13 Dec 1992 00:56:47 EST
XX-Mailer: Mail User's Shell (7.2.4 2/2/92)
XTo: oreillym
XSubject: term checksum stuff
XStatus: OR
X
XI've got some old code to do checksums...
XWould you like me to just send you this code as I have it?
X
XIf I get around to it (I've got 4 other projects going), I am thinking
Xof possibly modifying tupload to use this to verify the files when it
Xfinishes...especially to verify that it is identical on both ends before
Xit starts appending.
X
XAlso, I've had problems with the checksum stuff.
XOccasionally, I get a really bad blast of line noise that gets by
Xthe checksums, and then the compression routines core dump on bad data.
XIt would be nice to have better error checking in this respect.
X
XThe checksum routines I have are table driven...
X
X[heck, the thing is 3k, I'll just include it here.]
X
X        Steve
X
X-----------------------
X crc - list length and checksum		Author: Johan W. Stevenson */
X
X/* crctab calculated by Mark G. Mendel, Network Systems Corporation */
Xstatic unsigned short crctab[256] = {
X	0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,
X	0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,
X	0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,
X	0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,
X	0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
X	0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,
X	0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,
X	0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,
X	0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
X	0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,
X	0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,
X	0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
X	0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,
X	0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,
X	0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,
X	0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,
X	0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,
X	0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
X	0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,
X	0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,
X	0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,
X	0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
X	0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,
X	0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,
X	0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,
X	0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,
X	0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
X	0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,
X	0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,
X	0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,
X	0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
X	0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0
X};
X
X/*
X * updcrc macro derived from article Copyright (C) 1986 Stephen Satchell. 
X *  NOTE: First argument must be in range 0 to 255.
X *        Second argument is referenced twice.
X * 
X * Programmers may incorporate any or all code into their programs, 
X * giving proper credit within the source. Publication of the 
X * source routines is permitted so long as proper credit is given 
X * to Stephen Satchell, Satchell Evaluations and Chuck Forsberg, 
X * Omen Technology.
X */
X
X#define updcrc(cp, crc) ( crctab[((crc >> 8) & 255)] ^ (crc << 8) ^ cp)
X
Xint check_sum(unsigned char *d, int len, int mask)
X{
X  unsigned short crc = 0;
X  while (len-->0)
X    crc = updcrc(((*d++) & mask), crc);
X
X  return (int) crc;
X}
X
Xunsigned short update_crc(unsigned short old, unsigned char c)
X{
X  return updcrc(c, old);
X}
X
X
END_OF_FILE
  if test 4561 -ne `wc -c <'checksum.c'`; then
    echo shar: \"'checksum.c'\" unpacked with wrong size!
  fi
  # end of 'checksum.c'
fi
if test -f 'client.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'client.h'\"
else
  echo shar: Extracting \"'client.h'\" \(5605 characters\)
  sed "s/^X//" >'client.h' <<'END_OF_FILE'
X#ifndef CLIENT_H
X#define CLIENT_H
X#include "config.h"
X#include "terminal.h"
X
X#ifndef un_char
X#define un_char unsigned char
X#endif
X
Xstruct Buffer {
X    un_char * data;
X    int start, end;
X    int size;
X    int alloced;
X    };
X
X#define C_SWITCH        '@'
X#define PUBLIC  0
X#define PRIVILEGED 1
X
X/* Client commands.  If you need to reserve a something for a patch you
X * are working on, let me know.  If we run out, we can start going to
X * two character commands for less common commands.  If you don't absolutely
X * need to add something don't as this breaks forward compatibility. 
X * (forcing people to upgrade...)
X *
X *   (bcr@physics.purdue.edu)
X */
X
X/* First the obsolete switches */
X#define C_WAIT		'\0'	/* This is just a delay */
X#define C_PRIORITY_OLD  'B'	/* Raise/lower the priority of this */
X				/* client. */
X#define C_NAME_OLD      'G'	/* Set the name of this client. Only */
X				/* used by C_STATS. */
X#define C_RESIZE_OLD    'H'	/* For handling SIGWINCH */
X#define C_DUMP_OLD      'L'	/* Go dumb for the next 'n' bytes. */
X#define C_CLIENTNUM     'I'	/* Not used. Obsolete. */
X
X/* Now the current ones */
X
X#define C_OPEN		'1'	/* Open a file a file for uploading */
X				/* without truncating it. */
X#define	C_CLOSE		'2'	/* Close a connection. */
X#define C_EXEC		'3'	/* Not used/implemented. */
X#define C_PTYEXEC	'4'	/* Fork() a shell attached to a pty. */
X#define C_DUMB		'5'	/* Go dumb. Escape all '@' received, */
X				/* so no commands are processed. */
X#define C_UPLOAD	'6'	/* Open a file for writing, creating */
X				/* it if it doesn't exist, truncating */
X				/* it if it does. */
X#define C_DOWNLOAD	'7'	/* Open a file for reading. */
X#define C_UNLINK	'Z'	/* Delete a file */
X#define C_SOCKET        '8'	/* Connect to a unix-domain socket. */
X#define C_PUTENV        '9'	/* Puts an environmental variable */
X#define C_PORT          'A'	/* Connect to a TCP/IP port on the */
X				/* specified host, and port number. */
X#define C_PRIORITY      'd'	/* Raise/lower the priority of this */
X				/* client. */
X#define C_COMPRESS	'C'  	/* note, i jumped B :) (croutons). */
X				/* Turn compression on or off. */
X#define C_STAT          'D'	/* Get information on a remote file. */
X#define C_SEEK          'E'	/* Execute an lseek() on the remote */
X				/* file descriptor. Assumes the remote */
X				/* is a file handle, and not a socket. */
X#define C_STATS         'F'	/* Get information on various parts of */
X				/* term.  */
X#define C_NAME          'g'	/* Set the name of this client. Only */
X				/* used by C_STATS. */
X#define C_RESIZE        'h'	/* For handling SIGWINCH */
X#define C_BIND          'J'	/* Bind a remote socket. */
X#define C_ACCEPT        'K'	/* Accept a connection from a remotely */
X				/* bound sockets. */
X#define C_DUMP          'l'	/* Go dumb for the next 'n' bytes. */
X#define C_CLCLOSE       'M'     /* Close the remote fd when the */
X				/* buffers have been emptied. */
X#define C_QUIT          'N'	/* Shutdown term. */
X#define C_CHMOD		'O'	/* Change the mode of a file */
X#define C_BINDN         'U'     /* Bind a remote unspecified socket. -ot */
X#define C_BINDS         'S'     /* Allow connects one time only from a tcpip */
X                                /* socket... */
X#define C_UBIND         'T'     /* Bind a UDP socket */
X#define C_USOCK         'V'     /* Create a UDP socket */
X#define C_UDPSET        'W'     /* set UDP parameters */
X#define C_X_SERVER	'X'	/* Open connection to X server */
X
X#define C_GETSOCKNAME   'a'     /* Get the sockaddr */
X#define C_GETPEERNAME   'b'     /* Get the peername */
X#define C_GETHOSTNAME   'c'     /* Get the hostname */
X
X/* Return status */
X
X#define I_FAIL		'a'
X#define I_CLOSE		'b'
X#define I_EXIT		'c'
X#define I_OK		'd'
X#define I_NA		'X'
X
X#define HEADER_SIZE 6
X
X/* Prototypes */
X
Xint read_into_buff(int fd, struct Buffer *, int);
Xint write_from_buff(int fd, struct Buffer *, int);
Xint write_from_buff_async(int fd, struct Buffer *, int);
X
X
Xvoid set_share_mode(int, int);
Xint socket_connect_server(int,char *);
Xint connect_server(char *);
X
Xvoid set_nonblock(int);
Xint set_block(int);
X
Xvoid set_ttyraw(int);
Xvoid set_ttynormal(int);
X
Xtypedef int (*Callback) ( char, char *);
X
Xint client_options(int argc, char *argv[], char *myopts, Callback callback);
X
X#ifdef USE_VARARGS
Xint send_command();
X#else
Xint send_command(int, int, int, char *, ...);
X#endif
X
Xchar * build_arg(char**);
Xextern int priority;
Xextern int verbose;
X
Xint open_unix(char *);
Xint connect_unix(int,char *);
Xint bind_tcp( unsigned int );
Xint bind_unix(char *);
Xint use_term_command(int);
Xvoid do_select_loop(int, int, int);
Xextern char *term_server;
X
Xextern char *command_result;
X
Xint eaccess(char *pathname, int mode);
X
Xvoid do_connect(int num, int *svs, int (*get_server)(int n)); /* -ot */
X
Xchar *get_term_path(char **);
X
Xint term_putenv(char *);
X
Xvoid term_do_exit(void);
X#if 0
Xint term_getpeername(int, struct sockaddr *, int *);
Xint term_getsockname(int, struct sockaddr *, int *);
Xint term_bind(int, struct sockaddr *, int);
Xint term_accept(int, struct sockaddr *, int *);
Xint term_connect(int, struct sockaddr *, int);
Xint term_recvfrom( int, char *, int, int, struct sockaddr *, int *);
Xint term_sendto(int, void *, int, unsigned int, struct sockaddr *, int); 
Xint term_gethostname(char *, size_t);
X#endif
Xint term_shutdown(int, int);
Xint term_close(int);
Xint term_listen(int, int);
Xint term_socket(int, int, int);
Xint term_rcmd(char **, unsigned short, char *, char *, char *, int *);
Xint term_fork(void);
Xint term_vfork(void);
Xint term_recv(int, char *, int, int);
Xstruct hostent *term_gethostbyname(char *);
Xvoid term_exit(int);
X
X#endif
X
END_OF_FILE
  if test 5605 -ne `wc -c <'client.h'`; then
    echo shar: \"'client.h'\" unpacked with wrong size!
  fi
  # end of 'client.h'
fi
if test -f 'config.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config.h'\"
else
  echo shar: Extracting \"'config.h'\" \(5626 characters\)
  sed "s/^X//" >'config.h' <<'END_OF_FILE'
X/*
X *
X * USE_IOCTL use ioctl() to set non-blocked io instead of fcntl()
X *
X * USE_SETSID use setsid() to become process leader
X *
X * USE_TIOCSCTTY use ioctl() to acquire a controlling terminal
X *
X * USE_TERMIOS uses the termios struct to control terminals.
X *   Comment this out if you want to use sgtty instead.
X * 
X * ERR_BLOCK sets the errno that is returned for an operation
X * that blocked.
X *
X * USE_VHANGUP says to run vhangup() on the new ptys.
X *
X * USE_TCATTR uses tc{get/set}attr() instead of ioctl's to set
X * termios.
X *
X * USE_SIGWINCH tells trsh to watch for SIGWINCH. Only define it if
X * your system supports it.
X *
X * USE_WINCHKILL if you sigwinch is broken, and doesn't send the
X * signal when the window size gets changed.
X *
X * USE_HERROR specifies that herror() should be used, not term_herror().
X *
X * USE_CONNBLOCK this specifies that term may block waiting for a
X * a connection.
X *
X * USE_WAITPID use waitpid() instead of wait3()
X *
X * USE_ONEXIT use onexit instead of atexit()
X *
X * USE_NOEOF when a client is closing, don't wait for an EOF in the stream.
X *
X * NO_ATEXIT don't use either
X */
X
X	/* First we do simple, OS specific rules */
X
X#ifdef linux
X#define USE_SIGWINCH
X#define USE_SETSID
X#define USE_TERMIOS
X#define USE_VHANGUP
X#define USE_HERROR 
X#define ERR_BLOCK  EAGAIN
X/* #define USE_BSDJOBS */
X#endif
X
X 
X#ifdef ISC
X#ifndef SYSV
X# define SYSV
X#endif
X#define USE_SETSID
X#define USE_TERMIOS
X#define USE_TCATTR
X#define USE_WINCHKILL
X#define USE_WAITPID
X#define ERR_BLOCK EAGAIN
X#define NO_VFORK
X#ifndef NO_UNIX_DOMAIN
X#define NO_UNIX_DOMAIN
X#endif
X#define NO_ATEXIT
X#define _XOPEN_SOURCE
X#endif /* ISC */
X
X#ifdef DYNIXPTX
X#ifndef SYSV
X#  define SYSV
X#endif
X#define HAS_PSEUDO
X#define USE_WAITPID
X#define USE_SIGWINCH
X#define USE_TERMIOS
X#define USE_TCATTR
X#define USE_STIME
X#define ERR_BLOCK EAGAIN
X#define USE_SETPGRP
X#ifndef I_TIME
X# define I_TIME
X#endif
X#ifndef I_TYPES
X#define I_TYPES
X#endif
X#endif
X
X#ifdef SVR4
X#ifndef SYSV
X# define SYSV
X#endif
X#define USE_WAITPID
X#define USE_SIGWINCH
X#define USE_SETSID
X#define USE_TERMIOS
X#define USE_TCATTR
X#define ERR_BLOCK  EAGAIN
X#endif
X
X#ifdef SCO
X#ifndef SYSV
X#define SYSV
X#endif
X#define USE_IOCTL
X#define USE_SETSID
X#define USE_TERMIOS
X#define USE_TCATTR
X#define USE_WINCHKILL
X#define ERR_BLOCK EAGAIN
X#define STREAMS_PIPE
X#define X_STREAMS_PIPE
X#ifndef NO_UNIX_DOMAIN
X#define NO_UNIX_DOMAIN
X#endif
X#endif
X
X#ifdef ultrix
X#define USE_IOCTL
X#define USE_SIGWINCH
X#define USE_TIOCNOTTY
X#define USE_VHANGUP
X#define USE_TERMIOS
X#define USE_HERROR
X#define ERR_BLOCK EWOULDBLOCK
X#endif
X
X#ifdef NeXT
X#define USE_IOCTL
X#define USE_VHANGUP
X#define USE_TCATTR
X#define USE_SIGWINCH
X#define USE_TIOCNOTTY
X#define ERR_BLOCK EWOULDBLOCK
X#ifndef I_TYPES
X#define I_TYPES
X#endif
X#endif
X
X#ifdef BSDI
X#define USE_TCATTR
X#define ERR_BLOCK EWOULDBLOCK
X#define USE_TIOCNOTTY
X#endif
X
X#ifdef __MACHTEN__
X#define USE_VHANGUP
X#define USE_HERROR
X#define USE_SIGWINCH
X#define ERR_BLOCK  EAGAIN
X#endif
X 
X#if defined(__hpux) 
X#define USE_SIGWINCH
X#define USE_TERMIOS
X#define USE_TCATTR
X#define USE_NOEOF
X#define USE_SETSID
X#define ERR_BLOCK EAGAIN
X#endif
X
X#ifdef _AIX
X#define USE_SIGWINCH
X#define USE_TERMIOS
X#define USE_TCATTR
X#define ERR_BLOCK EAGAIN
X#define USE_SETPGRP
X#define USE_TIOCNOTTY
X#endif
X
X#ifdef sgi
X#define	USE_SETSID
X#define	USE_VHANGUP
X#define	USE_TERMIOS
X#define	USE_TCATTR
X#define ERR_BLOCK EAGAIN
X#endif
X
X#ifdef __QNX__
X#define NO_STRERROR
X#define USE_WAITPID
X#define USE_HERROR 
X#define USE_SIGWINCH
X#define USE_TCATTR
X#define USE_TERMIOS
X#define USE_TTYNAME
X#define USE_SPAWN
X#define USE_NOEOF
X#define ERR_BLOCK      EAGAIN
X#endif
X
X#ifdef titan
X#define NO_PTYEXEC
X#define USE_VARARGS
X#define	USE_SETIDS
X#define NO_SIGWINCH
X#define NO_ATEXIT
X#endif
X
X#ifdef IRIX
X#define NO_SIGWINCH
X#define NO_VFORK
X#endif
X
X#ifdef __NetBSD__
X#define USE_TERMIOS
X#define USE_TCATTR
X#define ERR_BLOCK EWOULDBLOCK
X#define USE_SETPGRP
X#endif
X
X#if defined(___386BSD___) || defined(__386BSD__)
X#define USE_TCATTR
X#define ERR_BLOCK EWOULDBLOCK
X#define USE_SETPGRP
X#endif
X
X#if defined(__OSF1__)  || defined(__OSF__) || defined(__osf__)
X#define USE_TCATTR
X#define ERR_BLOCK EWOULDBLOCK
X#define USE_SETSID
X#define USE_TIOCSCTTY
X#define USE_SIGWINCH
X#define NO_VHANGUP
X#endif
X
X	/* Now the more complicated stuff */
X
X#if defined(__convex__) && !defined(convex)
X#define convex
X#endif
X
X#ifndef SVR4
X#if defined(sun) || defined(convex)
X#define USE_TERMIOS
X#define USE_TCATTR
X#define ERR_BLOCK EAGAIN
X#ifndef NO_VHANGUP
X#define USE_VHANGUP
X#endif
X#ifndef NO_SIGWINCH
X#define USE_SIGWINCH
X#endif
X#if defined(sun)
X#define HAS_SETSID
X#define USE_STRERROR
X#define USE_WINCHKILL
X#define USE_ONEXIT
X#define USE_SETPGRP
X#else
X#define USE_SETSID
X#endif
X#endif
X#endif /* SVR4 */
X
X#if defined(BSD) && !defined(BSDI)
X#define USE_TCATTR
X#define USE_SETPGRP
X#define ERR_BLOCK EWOULDBLOCK
X#endif
X
X#if defined(BSD) && !defined(NO_SIGWINCH)
X#define USE_SIGWINCH
X#endif
X
X#ifdef hcx
X#ifdef att_universe
X#define USE_VHANGUP
X#define USE_TERMIOS
X#define USE_TCATTR
X#else /* ucb_universe */
X#define NO_VSPRINTF
X#endif
X#define USE_SETSID
X#define ERR_BLOCK EAGAIN
X#define USE_HERROR
X#define USE_SIGWINCH
X#endif
X
X#if !defined(NO_UNIX_DOMAIN) && defined(TERM_NFS_DIR)
X# define NO_UNIX_DOMAIN
X#endif
X
X#if !defined(ERR_BLOCK) /* if no OS defined */
X/* 
X#error "Need to define an OS" 
XUltrix MIPS compiler chokes on this, even though ERR_BLOCK is defined!
X*/
X"Compilation directive: You need to define an OS"
X
X/* If your OS isn't defined you need to work out which of the above defines */
X/* you need and build and entry for it. Please send me the diff if you do so */
X/* I am oreillym@tartarus.uwa.edu.au */
X#endif
X
END_OF_FILE
  if test 5626 -ne `wc -c <'config.h'`; then
    echo shar: \"'config.h'\" unpacked with wrong size!
  fi
  # end of 'config.h'
fi
if test -f 'debug.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'debug.h'\"
else
  echo shar: Extracting \"'debug.h'\" \(780 characters\)
  sed "s/^X//" >'debug.h' <<'END_OF_FILE'
X#define NOTIFY \
X    (write_noise < 2) ? 0 : fprintf
X
X#define WARNING \
X    (!(write_noise)) ? 0 : fprintf
X
X#define DEBUG_STATE \
X    (!(term_debug & 1)) ? 0 : fprintf
X
X#define DEBUG_MAIN \
X     (!(term_debug & 2)) ? 0 : fprintf
X
X#define DEBUG_SER \
X      (!(term_debug &8)) ? 0 :fprintf
X
X
X#define DEBUG_CHECK \
X       (!(term_debug & 16)) ? 0 : fprintf
X
X#define DEBUG_PED \
X	(!(term_debug & 32)) ? 0 : fprintf
X
X#define DEBUG_FP (!(term_debug & 64)) ? 0 : fprintf
X
X#define DEBUG_LINK \
X	 (!(term_debug & 128)) ? 0 : fprintf
X
X#define DEBUG_LL \
X         (!(term_debug & 256)) ? 0 : fprintf
X
X#define DEBUG_C \
X         (!(term_debug & 512)) ? 0 : fprintf
X
X#define DEBUG_SEV \
X         (!(term_debug & 1024)) ? 0 : fprintf
X
X#define DEBUG_UDP \
X	(!(term_debug & 2048)) ? 0 : fprintf
X
END_OF_FILE
  if test 780 -ne `wc -c <'debug.h'`; then
    echo shar: \"'debug.h'\" unpacked with wrong size!
  fi
  # end of 'debug.h'
fi
if test -f 'includes.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'includes.h'\"
else
  echo shar: Extracting \"'includes.h'\" \(5332 characters\)
  sed "s/^X//" >'includes.h' <<'END_OF_FILE'
X
X/*
X**
X*/
X
X#include "term.h"
X
X	/* This is just to help track what is always being included */
X#ifndef I_ALWAYS
X# define I_ALWAYS
X#endif
X
X#ifndef I_TYPES
X# if defined(I_SYS) || defined(I_SOCKET) || defined(I_UTIME)
X#  define I_TYPES
X# endif
X#endif
X
X#ifndef I_TIME
X# ifdef I_SYS
X#  define I_TIME
X# endif
X#endif
X
X	/* This helps avoid conflicts when using libtermnet.a */
X#if defined(I_ERRNO)
X# include <errno.h>
X#endif
X
X#ifdef I_CTYPE
X# include <ctype.h>
X#endif
X
X#ifdef I_TYPES
X# ifndef titan
X#  include <sys/types.h>
X#  ifdef ISC
X#   include <sys/bsdtypes.h>
X#   include <net/errno.h>
X#  endif /* ISC */
X# else
X#  include <types.h>
X# endif
X#endif
X
X#ifdef I_IOCTL
X# if !defined(I_TTY) || !defined(sun) || defined(SVR4)
X#  include <sys/ioctl.h>
X# endif
X# if defined(SVR4)
X#  include <sys/filio.h>		/* FIONREAD */
X# endif
X# include <fcntl.h>
X# ifndef FD_CLOEXEC
X#  define FD_CLOEXEC 1
X# endif
X#endif
X
X#ifdef I_STRING
X# include <string.h>
X#endif
X
X#ifdef I_SOCKET
X# if !defined(NO_UNIX_DOMAIN)
X#  include <sys/un.h>
X# endif
X# include <netinet/in.h>
X# include <netdb.h>
X# include <sys/socket.h>
X# ifdef SYSV
X#  include <sys/utsname.h>
X# endif
X# ifdef SVR4
X   int accept(int, struct sockaddr *, int *);
X   int bind(int, struct sockaddr *, int);
X   int connect(int, struct sockaddr *, int);
X   int listen(int, int);
X   int socket(int, int, int);
X   int socketpair(int, int, int, int[]);
X# endif
X# ifdef SVR3
X#  define socketpair term_socketpair
X# endif
X# ifndef NO_UNIX_DOMAIN
X#  define S_Pipe(soc) socketpair(AF_UNIX, SOCK_STREAM, 0, soc) 
X# else
X#  ifndef SCO
X#   define S_Pipe(soc) socketpair(AF_INET, SOCK_STREAM, 0, soc)
X#  else
X#   define S_Pipe(soc) s_pipe(soc)
X#  endif
X# endif
X#endif
X
X#ifdef I_GETOPT
X  int term_getopt(int argc, char *argv[], char *optstring);
X  extern char *term_optarg;
X  extern int term_optind, term_opterr, term_optopt;
X#endif
X
X#ifdef I_TTY
X# ifdef USE_TERMIOS
X#   include <termios.h>
X# else
X#  include <sgtty.h>
X# endif
X#endif
X
X
X#ifdef I_ALWAYS
X# include <stdio.h>
X# ifndef titan
X#  include <stdlib.h>
X# else
X   extern char *getenv(char *name);
X#  include <malloc.h>
X# endif /* titan */
X# ifndef NeXT
X#  include <unistd.h>
X# endif
X# if defined(ultrix) || defined(NeXT)
X#  include <sys/file.h>
X# endif
X# ifndef R_OK
X#  define R_OK 4
X# endif
X# ifndef W_OK
X#  define W_OK 2
X# endif
X# ifndef X_OK
X#  define X_OK 1
X# endif
X# ifndef IXANY
X#  define IXANY 0
X# endif
X# if !defined(ONLCR) && defined(__QNX__)
X#  define ONLCR OPOST
X# endif
X# ifndef STDIN_FILENO
X#  define STDIN_FILENO 0
X# endif
X# ifndef USE_HERROR
X#  define herror term_herror
Xvoid term_herror(char *);
X# endif
X# ifdef NO_VFORK
X#  define vfork fork
X# endif
X# ifdef USE_ONEXIT
X#  define atexit(procp) on_exit(procp, 0)
X# endif
X# ifdef NO_ATEXIT
X#  define atexit(procp) while(0)
X# endif
X#endif
X
X#ifdef I_SIGNAL
X# include <signal.h>
X# ifndef SIGWINCH
X#  define SIGWINCH SIGWINDOW 
X# endif
X#endif
X
X#ifdef I_TIMES
X# include <sys/times.h>
X#endif
X
X#ifdef I_SYS
X# if defined (_AIX) || defined(__QNX__) || defined(DYNIXPTX)
X#  include <sys/select.h>
X# endif
X# if defined(DYNIXPTX) || defined(SVR4)
X   int select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
X# endif
X#endif
X
X#ifdef I_TIME
X# include <sys/time.h>
X# ifdef USE_STIME
X#  define gettime(a) get_process_stats(a,getpid(),0,0)
X#  define settime(a) stime(a)
X# else
X#  ifdef SVR4
X    int gettimeofday(struct timeval *);
X#   define gettime gettimeofday
X#   define settime settimeofday
X#  else
X#   define gettime(a) gettimeofday((a), (struct timezone *)0)
X#   define settime(a) settimeofday((a), (struct timezone *)0)
X#  endif
X# endif
X#endif
X
X#ifdef I_UTIME
X# if !defined(titan) && !defined(NeXT)
X#  include <utime.h>
X# else
X          struct    utimbuf        {
X               time_t      actime; /* access time */
X               time_t      modtime;/* modification time */
X          };
X# endif
X#endif
X
X
X#ifdef I_ARGS
X# ifndef NO_VSPRINTF
X#  ifndef USE_VARARGS
X#   include <stdarg.h>
X#  else /* USE_VARARGS */
X#   include <varargs.h>
X#  endif /* USE_VARARGS */
X# else /* NO_VSPRINTF */
X#  define va_alist a1,a2,a3,a4,a5,a6,a7,a8,a9
X#  define va_dcl long a1,a2,a3,a4,a5,a6,a7,a8,a9;
X#  define vsprintf(buf,fmt,v) sprintf((buf),(fmt),a1,a2,a3,a4,a5,a6,a7,a8,a9)
X#  define va_list int
X#  define va_start(v)
X#  define va_end(v)
X#  define USE_VARARGS
X# endif /* NO_VSPRINTF */
X#endif /* I_ARGS */
X
X#ifdef I_INET
X# include <arpa/inet.h>
X#endif
X
X#ifdef I_PARAM
X# include <sys/param.h>
X#endif
X
X#ifdef I_MEMORY
X# ifndef convex
X#  include <memory.h>
X# endif
X#endif
X
X#ifdef I_PWD
X# include <pwd.h>
X#endif
X
X#ifdef I_PROCESS
X# ifdef __QNX__
X#  include <process.h>
X# endif
X#endif
X
X#ifdef I_WAIT
X# include <sys/wait.h>
X#endif
X
X#ifdef I_STROPT
X# if defined(SCO) || defined(SYSV) || defined(SVR3)
X#  include <stropts.h>
X# endif
X#endif
X
X#ifdef I_POLL
X# ifdef SVR3
X#   include <poll.h>
X# endif
X#endif
X
X#ifdef I_STREAM
X# include <sys/stream.h>
X#endif
X
X#ifdef I_STAT
X# include <sys/stat.h>
X# ifndef S_ISREG
X#  define S_ISREG(a) (((a) & S_IFMT) == S_IFREG)
X#  define S_ISDIR(a) (((a) & S_IFMT) == S_IFDIR)
X# endif
X#endif
X
X#ifdef I_LIMITS
X# include <limits.h> 
X# include <sys/param.h> 
X# ifndef _POSIX_PIPE_BUF
X#  define _POSIX_PIPE_BUF 512
X# endif
X# ifndef PIPE_BUF
X#  define PIPE_BUF 4096
X# endif
X# define PIPE_BUFFER ((PIPE_BUF<30720&&PIPE_BUF>0)?PIPE_BUF:30720)
X# ifndef PATH_MAX
X#  define PATH_MAX 1024
X# endif
X#endif
X
X
END_OF_FILE
  if test 5332 -ne `wc -c <'includes.h'`; then
    echo shar: \"'includes.h'\" unpacked with wrong size!
  fi
  # end of 'includes.h'
fi
if test -f 'jump/README.jump-updating' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jump/README.jump-updating'\"
else
  echo shar: Extracting \"'jump/README.jump-updating'\" \(1499 characters\)
  sed "s/^X//" >'jump/README.jump-updating' <<'END_OF_FILE'
X--------------------------------------------------------------------
XJUMP.LOG
X
XIt is created in case new symbols appear in the module processed
Xby jumpas. 
X
XNEW SYMBOLS
X
XThese are the symbols jumpas sees that exist in source, but not
Xin jump.vars, neither jump.funcs.
X
XWHAT IF MAKE PROCESS IS ABORTED
X
XIf there are errors while compiling fresh code with new symbols
X(this is possible with high probability), then jumpas should not
Xbe run after the compilation with errors. 
X
XHowever, even if there are no errors, you might have done an unwanted
Xmake process, and jump.log can be appended with unwanted new symbols,
Xso duplicates are possible and there is not an easy way to prevent
Xdouble makings. The real solution would be jumpas that takes care
Xof duplicates, but the present one seems it doesn't.
X
XIn both cases, safe side is to delete jump.log before each re-makings,
Xregardless of the fact that jump.log, in its present contents might
Xhave useful entries. It's better to loose some time for making if
Xsome symbols are missing than to contaminate jump.* files.
X
XSAFE METHOD
X
XAfter you are satisfied with your code, delete jump/jump.log, then
Xcreate empty one by touching it and run make jump-update twice.
XFirst time, a complete new jump.log has the chance to appear, and
Xsecond jump-update will see if jump.log has appeared and will do the
Xright thing in the second pass.
X
XDavor Jadrijevic <davor%emard.uucp@ds5000.irb.hr>
X--------------------------------------------------------------------
X
END_OF_FILE
  if test 1499 -ne `wc -c <'jump/README.jump-updating'`; then
    echo shar: \"'jump/README.jump-updating'\" unpacked with wrong size!
  fi
  # end of 'jump/README.jump-updating'
fi
if test -f 'jump/jump.funcs' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jump/jump.funcs'\"
else
  echo shar: Extracting \"'jump/jump.funcs'\" \(3730 characters\)
  sed "s/^X//" >'jump/jump.funcs' <<'END_OF_FILE'
X00000000 T _build_arg           libtermnet       client 
X00000000 T _client_options      libtermnet       client 
X00000000 T _connect_server      libtermnet       client 
X00000000 T _send_command        libtermnet       client 
X00000000 T _socket_connect_server libtermnet       client 
X00000000 T _use_term_command    libtermnet       client
X00000000 T _do_connect          libtermnet       connect 
X00000000 T _add_to_buffer       libtermnet       lib 
X00000000 T _eaccess             libtermnet       lib 
X00000000 T _get_from_buffer     libtermnet       lib 
X00000000 T _get_term_path       libtermnet       lib
X00000000 T _make_sockaddr       libtermnet       lib
X00000000 T _read_into_buff      libtermnet       lib 
X00000000 T _recvfrom_into_buff  libtermnet       lib
X00000000 T _sendto_from_buff    libtermnet       lib
X00000000 T _set_block           libtermnet       lib 
X00000000 T _set_nonblock        libtermnet       lib 
X00000000 T _set_share_mode      libtermnet       lib 
X00000000 T _sockaddr_to_sstr    libtermnet       lib
X00000000 T _sockaddr_to_str     libtermnet       lib
X00000000 T _str_to_sockaddr     libtermnet       lib
X00000000 T _sstr_to_sockaddr    libtermnet       lib
X00000000 T _str_version         libtermnet       lib 
X00000000 T _strerror            libtermnet       lib 
X00000000 T _write_from_buff     libtermnet       lib 
X00000000 T _term_getopt         libtermnet       term_getopt 
X00000000 T _term_herror         libtermnet       term_herror
X00000000 T _lose_ctty           libtermnet       terminal 
X00000000 T _terminal_baud       libtermnet       terminal
X00000000 T _terminal_new        libtermnet       terminal 
X00000000 T _terminal_raw        libtermnet       terminal 
X00000000 T _terminal_restore    libtermnet       terminal 
X00000000 T _terminal_save       libtermnet       terminal 
X00000000 T _term_accept         libtermnet       termnet 
X00000000 T _term_bind           libtermnet       termnet 
X00000000 T _term_close          libtermnet       termnet 
X00000000 T _term_connect        libtermnet       termnet 
X00000000 T _term_dup            libtermnet       termnet
X00000000 T _term_dup2           libtermnet       termnet
X00000000 T _term_fcntl          libtermnet       termnet
X00000000 T _term_fork           libtermnet       termnet 
X00000000 T _term_gethostbyaddr  libtermnet       termnet 
X00000000 T _term_gethostbyname  libtermnet       termnet 
X00000000 T _term_gethostname    libtermnet       termnet
X00000000 T _term_getpeername    libtermnet       termnet 
X00000000 T _term_getsockname    libtermnet       termnet 
X00000000 T _term_listen         libtermnet       termnet 
X00000000 T _term_rcmd           libtermnet       termnet 
X00000000 T _term_recv           libtermnet       termnet
X00000000 T _term_recvfrom       libtermnet       termnet
X00000000 T _term_send           libtermnet       termnet
X00000000 T _term_sendto         libtermnet       termnet
X00000000 T _term_shutdown       libtermnet       termnet 
X00000000 T _term_socket         libtermnet       termnet
X00000000 T _term_vfork          libtermnet       termnet 
X00000000 T _s_pipe              libtermnet       spipe
X00000000 T _do_select_loop      libtermnet       select 
X00000000 T _bind_tcp            libtermnet       socket 
X00000000 T _bind_unix           libtermnet       socket 
X00000000 T _connect_unix        libtermnet       socket 
X00000000 T _open_unix           libtermnet       socket 
X00000000 T _write_from_buff_async libtermnet     lib
X00000000 T _term_putenv         libtermnet       term_putenv
X00000000 T _term_strherror      libtermnet     term_herror
X00000000 T _get_term_localaddr  libtermnet     lib
X00000000 T _term_socketpair     libtermnet     term_spair
END_OF_FILE
  if test 3730 -ne `wc -c <'jump/jump.funcs'`; then
    echo shar: \"'jump/jump.funcs'\" unpacked with wrong size!
  fi
  # end of 'jump/jump.funcs'
fi
if test -f 'jump/jump.params' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jump/jump.params'\"
else
  echo shar: Extracting \"'jump/jump.params'\" \(93 characters\)
  sed "s/^X//" >'jump/jump.params' <<'END_OF_FILE'
XName=libtermnet
XText=0x66000000
XData=0x00000000
XJump=0x00001000
XGOT=0x00004000
XVersion=2.1.2
END_OF_FILE
  if test 93 -ne `wc -c <'jump/jump.params'`; then
    echo shar: \"'jump/jump.params'\" unpacked with wrong size!
  fi
  # end of 'jump/jump.params'
fi
if test -f 'lib.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.h'\"
else
  echo shar: Extracting \"'lib.h'\" \(502 characters\)
  sed "s/^X//" >'lib.h' <<'END_OF_FILE'
X
X#include "terminal.h"
X
Xint read_into_buff(int fd, char *b, int *s, int *e, int size);
Xint recv_into_msg(int fd, char *b, int *s, int *e, int size);
Xint write_from_buff(int fd, char *b, int *s, int *e, int size);
X
Xint do_write_from_buff(int fd, char *b, int *s, int *e, int size);
X
Xvoid set_share_mode(int, int);
Xint connect_server(char *);
X
Xvoid set_nonblock(int);
Xint set_block(int);
X
Xvoid set_ttyraw(int);
Xvoid set_ttynormal(int);
X
Xvoid lib_init(int *argc, char *argv[]);
X
Xextern char *term_server;
END_OF_FILE
  if test 502 -ne `wc -c <'lib.h'`; then
    echo shar: \"'lib.h'\" unpacked with wrong size!
  fi
  # end of 'lib.h'
fi
if test -f 'meta.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'meta.c'\"
else
  echo shar: Extracting \"'meta.c'\" \(659 characters\)
  sed "s/^X//" >'meta.c' <<'END_OF_FILE'
X#include "includes.h"
X#include "debug.h"
X
Xextern char * term_server;
X				/* This file is intended to be the */
X				/* replacement for checkline, and */
X				/* linerem. This should be able to */
X				/* work out which character */
X				/* combinations are getting eaten, and */
X				/* set up a termrc file accordingly. */
X
Xint meta_state(int i) 
X{
X  static int state = 0;
X
X/*  static char control[10];*/
X  switch (state) {
X  case 0:
X    /* We wait for start of packet processes. */
X    if (i != 'E') return 1;
X    state = 1;
X    break;
X  case 1:			/* We got an E, now receive a number */
X    
X    return 0;			/* return to normal processing. */
X  }
X  return 0;
X}
END_OF_FILE
  if test 659 -ne `wc -c <'meta.c'`; then
    echo shar: \"'meta.c'\" unpacked with wrong size!
  fi
  # end of 'meta.c'
fi
if test -f 'misc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc.c'\"
else
  echo shar: Extracting \"'misc.c'\" \(3454 characters\)
  sed "s/^X//" >'misc.c' <<'END_OF_FILE'
X#define I_IOCTL
X#define I_SYS
X#define	I_TTY
X#define I_SIGNAL
X#define I_LIMITS
X#define I_CTYPE
X#include "includes.h"
X#include "debug.h"
X
X
Xextern char breakout_string[256];
X
Xvoid update_time(void) {
X  struct timeval t;
X  extern int bytes_left;
X  unsigned long old_time = current_time;
X  
X  gettime(&t);
X  current_time = ((unsigned long)t.tv_sec) * (unsigned long)term_inc + 
X		(unsigned long)(t.tv_usec / (1000000 / (unsigned long)term_inc));
X  if (max_cps) {
X    bytes_left += ((current_time - old_time) * max_cps) / term_inc;
X    if (bytes_left > block_size) bytes_left = block_size;
X  }else {
X    bytes_left = block_size;
X  }
X  if (bytes_left < 0) bytes_left = 0;/* sanity check */
X}
X
Xvoid do_debug(int level, char *c) {
X/*  fprintf(stderr, "%s\n", c); */
X  return;
X}
X
Xvoid do_noise(int a) {
X  static int count=0;
X  extern int modem_noise;
X
X  if (modem_noise) modem_noise++;
X
X	/* This routine tries to print things out in a readable format */
X	/* without ever outputting the breakout string or upper case on */
X	/* the remote machine. */
X  if (!write_noise && !do_shutdown) return;
X  a ^= byte_shift;
X
X  if (do_shutdown) {
X    fprintf(stderr, "%c",a);
X  }else if ((a != '\b' && a != '\t' && a != '\n' &&
X      a != '\r' && a < ' ') || a > 127) {
X    fprintf(stderr, "<%u>", a);
X    count = 0;
X  }else if ( !remote ) {
X    fprintf(stderr, "%c",a);
X  }else {
X    a = tolower(a);
X    if (a != breakout_string[count]) {
X      count = 0;
X      fprintf(stderr, "%c", a);
X    }else if ( count++ > 4 || escapes[a]) {
X      if ( a != toupper(a) && a >= 'A' && a < 'A'+MAX_TYPE)
X        fprintf(stderr, "%c", toupper(a));
X      else 
X        fprintf(stderr, "<%d>", a);
X      count = 0;
X    }else { 
X       fprintf(stderr, "%c", a);
X    }
X  }
X}
X
Xvoid do_alert(char *s) {
X  if (remote) return;
X  fprintf(stderr, "%s", s);
X}
X
X/* rebuild the arg list
X * compliment to build_arg()
X *
X * by: croutons
X * 
X * mallocs the array that is returned.
X * see build_arg() for other assumptions.
X */
Xchar ** rebuild_arg(char * f)
X{
X	int i,s;
X	static char ** a;
X
X        if (a) free(a);
X	DEBUG_FP(stderr,"%s:rebuild :%s:\n", term_server, f);
X	if ( ! f || !f[0]) return NULL;
X	for ( s = 0, i = 2; '\0' != f[s]; s++ ) { 
X/*		if ( '\xff' == f[s] ) { Ultrix MIPS compiler chokes on this */
X		if ( '\377' == f[s] ) {
X			i++;
X		}
X	}
X	if ( NULL == ( a = (char**) malloc(i*sizeof(char*)) ) ) {
X		return NULL;
X	}
X	a[0]=f;
X	for ( s = i = 0; '\0' != f[s]; s++ ) {
X/*		if ( '\xff' == f[s] ) { */
X		if ( '\377' == f[s] ) {
X			f[s] = '\0';
X			a[++i] = &f[s+1];
X		}
X	}
X	a[i] = NULL;
X	return a;
X}
X
X#ifdef USE_SIGWINCH
Xvoid do_resize(int number, int rows, int cols, int ypixels, int xpixels)
X{
X  int i;
X#ifdef USE_WINCHKILL
X  int pg;
X#endif
X
X  for (i=0; i < MAX_CLIENTS; i++)
X    {
X      if (clients[i].fd >= 0 && clients[i].number == number)
X	{
X#ifdef TIOCSWINSZ
X	  struct winsize ws;
X
X	  ws.ws_row = rows;
X	  ws.ws_col = cols;
X	  ws.ws_ypixel = ypixels;
X	  ws.ws_xpixel = xpixels;
X	  ioctl(clients[i].fd, TIOCSWINSZ, &ws);
X#else
X#ifdef TIOCSSIZE
X	  struct ttysize ts;
X
X	  ts.ts_lines = rows;
X	  ts.ts_cols = cols;
X	  ts.ts_yyy = ypixels;
X	  ts.ts_xxx = xpixels;
X	  ioctl(clients[i].fd, TIOCSSIZE, &ts);
X#endif
X#endif
X
X#ifdef USE_WINCHKILL
X#ifdef SYSV
X	  pg = getpgid(clients[i].pid);
X	  if (pg > 0)
X	      kill(pg, SIGWINCH);
X#else
X	  pg = getpgrp(clients[i].pid);
X	  if (pg > 0)
X	      killpg(pg, SIGWINCH);
X#endif
X#endif	/* USE_WINCHKILL */
X	}
X    }
X
X    return;
X}
X#endif /* USE_SIGWINCH */
X
END_OF_FILE
  if test 3454 -ne `wc -c <'misc.c'`; then
    echo shar: \"'misc.c'\" unpacked with wrong size!
  fi
  # end of 'misc.c'
fi
if test -f 'old/INTERNALS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'old/INTERNALS'\"
else
  echo shar: Extracting \"'old/INTERNALS'\" \(2313 characters\)
  sed "s/^X//" >'old/INTERNALS' <<'END_OF_FILE'
XA quick run down of the internal structure.
X
Xmain.c:
X	main() Just sets things up. Opens socket, and set terminal
X		to non-blocking. calls main_loop();
X
X	main_loop() program sits here until exit.
X		Runs in a loop doing select().
X		calls do_serial_out() to set data to modem.
X		do_link_out() to queue packets.
X		update_time() to maintain 1/20th second clock.
X		do_serial_in() to build packets from raw serial.
X		
X
Xserial.c
X	do_serial_out(). Runs down the list of queued packets looking for
X		one to send. Picks the one that has been waiting the longest
X		for an ack.
X	do_serial_in(). a FSM, that builds packets from serial. Tries
X		to find a header, then uses header to get length of packet
X		and reads in that packet. calls get_serial() which may	
X		return -1 if there is nothing in serial in buffer.
X
X	do_ack(). Takes an outgoing packet of the queue. It has been acked.
X		
X	send_ack(). We correctly received a packet, so send an ack.
X
X	check_sum() is not a good one. Someone write a better one. :)
X
Xlink.c:
X	do_link_out(). Builds a packet if there is space on the queue.
X		calls get_data() to build the packets.
X
X	do_link_in(). Takes a packet of the in queue, uncompress it if
X		necessary, and gives it to put_data().
X
X	get_data(). Call get_client_byte until we have a full packet, or
X		have run out of data, and then (optionally) compress it.
X	
X	do_control(). Handle control messages. This routine handle only
X		remote control messages. I.e. messages sent from the other
X		end.
X
X	get_next_client() returns the struct for the next client ready to 
X		give data.
X
X	get_client_data returns the next byte from the client.
X
X	put_client_data() handles control messages calling do_control(), and
X		puts non-control data in client buffer.
X
X	
X	get_client_byte() returns the next bytes from the client. handles
X		local control messages. Handles stream switching. Yet another
X		finite state machine...
X
X	
X	put_data(). Put data to clients. Handles stream switching, switch
X		char escaping, and thats about it. calls put_client_data()
X		to send actual data or client control messages.
X
X	
X		
X
X	
XProtocols:
XClosing down.
X	state is 1 while running.
X	if an error on read or write occurs then state goes to 2.
X	then when buffer is empty, a C_CLOSE is sent, and state goes
X	to 3.
X
X	if a C_CLOSE is received, then state goes to 3.
X	
END_OF_FILE
  if test 2313 -ne `wc -c <'old/INTERNALS'`; then
    echo shar: \"'old/INTERNALS'\" unpacked with wrong size!
  fi
  # end of 'old/INTERNALS'
fi
echo shar: End of archive 6 \(of 6\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
