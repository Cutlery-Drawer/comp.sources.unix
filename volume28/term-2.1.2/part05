Newsgroups: comp.sources.unix
From: bcr@physics.purdue.edu (Bill C. Riemers)
Subject: v28i162: term-2.1.2 - slip-like functionality for a pair of UNIX hosts, Part05/06
References: <1.784076477.10661@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: bcr@physics.purdue.edu (Bill C. Riemers)
Posting-Number: Volume 28, Issue 162
Archive-Name: term-2.1.2/part05

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  INSTALL Makefile.in client.c compress.c configure
#   download.c jump/size.nm linecheck.c
# Wrapped by vixie@gw.home.vix.com on Sat Nov  5 14:58:35 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 5 (of 6)."'
if test -f 'INSTALL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'INSTALL'\"
else
  echo shar: Extracting \"'INSTALL'\" \(8686 characters\)
  sed "s/^X//" >'INSTALL' <<'END_OF_FILE'
XInstallation Guide to Term
X==========================
X
XThe quick way to install term is as follows:
X
X   If you have access to root:
X	% ./configure --root
X	% make
X	% su -c 'make install installman'
X   otherwise,
X        % ./configure --user
X	% make install installman
X
XFor group-shared or user-shared, replace "install" with "share" in the 
X"make install installman" command.  If term is your only network connection
Xthen also add "installnet" to your make command.  Here is the command I run:
X
X	% ./configure --root;make;su -c 'make installnet installman'
X
X
XFor more detailed information, read on.
X
X
XConfigure
X---------
X
XThe "configure" tool is responsible for generating a Makefile from the
Xsupplied Makefile.in.  In theory, you shouldn't have to modify either 
Xone to support most standard installations.
X
X"configure" attempts to autodetect the type of system it is running on,
Xby examining the output of "uname", "arch", or tcsh's $HOSTTYPE, or by
Xperforming other OS-specific tests.  If this doesn't work for you for
Xsome reason, you will need to specify the name of the OS on the command
Xline to "configure".  Currently configurable systems are:
X
X      aix            IBM AIX
X      bsdi           BSDi
X     *convex         C220 ConvexOS 11.0
X      dynixptx       Dynix/PTX
X     *hcx            HCX/UX 5.1
X      hpux           HP/UX
X      irix           Irix
X     *linux          Linux 1.0, 1.1
X     *machten        MachTen
X      mips           MIPS
X      netbsd         NetBSD
X     *next           NeXT 2.1, 3.0
X     *osf1           OSF/1
X      sco            SCO Unix
X      sgi            SGI
X     *sol2           Solaris 2.x aka SunOS 5.x
X     *sun            Solaris 1.x aka SunOS 4.x
X      svr4           SVR4
X     *titan          Titan/OS
X     *ultrix         Ultrix 4.x
X
XSystems known to autodetect are marked with a *.  If your system does not
Xautodetect, and you can come up with some unique way of identifying it,
Xplease send in a patch.  Systems that have at least successfully run
Xterm via "./test" are listed below along with the version of term:
X
X     MIPS Ultrix 4.4, gcc 2.5.8 (term 2.1.0)
X     SunOS 4.1.3, gcc 2.5.8 (term 2.1.0)
X     SunOS 5.3, gcc 2.5.6 (term 2.1.0)
X     Linux 1.1.x, gcc 2.5.8 (term 2.1.0)
X     NeXT 2.1, cc (term 2.1.0)
X     Alpha OSF/1 V2.0, gcc 2.5.8 (term 2.1.0)
X     HCX/UX 5.1, cc (term 2.1.0)
X
Xconfigure can be used to build the binary in a directory separate from
Xthe source.  The easiest way to do this is to cd to the build directory
Xand invoke configure with the full path to the source directory, e.g.
X/usr/src/local/term/configure.  configure will generate a Makefile
Xthat looks for the source in that directory using the VPATH mechanism
X(supported by GNU make and various commercial makes).  If for some reason
Xyou need to explicitly specify the source directory, you may use the
X--srcdir option of configure.
X
Xconfigure by default will ask you if you can install as root.  If so,
Xit will default to installing into /usr/local (and using group sharing
Xif you select shared mode).  If not, configure will generate a default
XMakefile that will install term into your home directory and configure
Xit for user sharing (if you select shared mode).  You may specify 
X--root or --user on the command line to avoid the question.
X
XThe --prefix option to configure can be used to specify a different target
Xdestination.  A standard layout with lib, bin, and man directories at that
Xpoint is assumed.  If you prefer to specify a non-standard arrangement,
Xyou can use the --mandir, --bindir, --libdir, and --sharedir arguments
Xto provide the paths to the directories you would like to install into.
X
XFinally, configure accepts --shlib and --static options to enable
Xor disable creating and using a dynamic libtermnet library on those
Xplatforms that support such libraries (currently Linux, NetBSD and SunOS
X4.x support is provided).  By default, under Linux, installing with
X--root will get dynamic libraries, and with --user will not (since
Xshared libraries require LD_LIBRARY_PATH to be set if installed by a
Xuser).  NetBSD and SunOS 4.x will default to shared libraries either way.
X
XAfter configure is run, it creates a "config.status" file in the build
Xdirectory.  This file can be executed to reconfigure the Makefile if
Xthe Makefile.in file is changed.  GNU make will do this automatically
Xwhen you type "make", if necessary.
X
XNote that if your .term directory is mounted over NFS, you will need to
Xedit the Makefile.in to add -DTERM_NFS_DIR to CFLAGS.  Or even better,
Xuse user share-mode, and link ~/term/tmp to a directory that is not
XNFS mounted like /usr/tmp or /tmp.
X
XIf you need to change either configure or Makefile.in for any other
Xreason, see if you can abstract the changes out into a form similar
Xto that used elsewhere and send in a patch.
X
X
XLinux Shared Library Notes
X--------------------------
X
XYou will need to have the Linux tools-2.11 toolset or newer installed
Xto build the default Linux shared library version.  The current version
Xis available from sunsite.unc.edu:/pub/Linux/gcc/src/tools-2.15.tar.gz.
XIf you don't want to be bothered, use configure --static to build static
Xversions of the tools (as was done with term 1.18 and earlier versions).
X
XIf you are building for Linux with shared libraries, and wish to try
Xtesting a new set of binaries before installing them, you will have
Xto do a "make install-shlib" as root after the "make", or the binaries
Xwill either not find the shared library, or use the previous version
Xif you have such installed.
X
XIf you would like to hack on the term code, and don't know anything
Xabout shared libraries, you can either just use --static and rely on
Xthe maintainer to fold your changes in with dynamic library support,
Xor you can do it yourself with the following brief guide.  (The best
Xthing to do is to read the tools doc/README.ps file, which explains
Xin detail the what, how, and why of shared libraries.)
X
XIf you don't add any new functions or data, and don't make any of the
Xglobal variables larger (e.g. expanding arrays), the dynamic library
Xconfiguration won't change.  You are happy; don't read any further.
X
XIf you do add new functions or data, you will do `make' and get:
X
X    *** WARNING: ./jump/jump.log exists!
X
Xor some similar message.  The jump.log file in the jump directory contains
Xnew symbols (functions or data) that have to be integrated into the
Xshared library configuration files before you can rebuild the library.
X
XLook at the jump.log file.  If all the new entries are marked with " T "
X(that is, functions), you are in luck.  Just append the file to 
Xjump.funcs, make clean, and try again.
X
XIf there are some non-T symbols, these represent data.  You will need
Xto convert the initial field full of zeros into a hexadecimal value
Xcorresponding to the largest you think that variable will ever be.
XMost globals are ints, which take four bytes (see the existing jump.vars
Xfile for an example).  For arrays (like com_result), you need to decide
Xif the array is likely to grow in the future, and pick some reasonable
Xupper bound value to put in the initial field to represent the array's
Xsize in bytes.  If you're not sure what the current size of a variable
Xis, do a `nm -n' on the object file to get a listing of the symbols
Xand their addresses.  "C" (common, or bss) symbols simply list their
Xsize in the address field, so that's easy.  For "D" symbols, you need to
Xsubtract the address of your symbol from that of the following "D" symbol
Xto get the size (if there is no following symbol, you're on your own).
XOnce you've updated all the size fields, add the relevant lines to the
Xjump.vars file.  (Note that we didn't mention the size for "T" symbols
Xin the previous paragraph.  That was on purpose; the size field for "T"
Xsymbols isn't used.)
X
XIf all of this seems a little confusing, you should probably read through
Xthe tools documentation to get the bigger picture.  Shared libraries
Xare the most confusing part of building code for Linux (although they
Xare more efficient than shared libraries in use on other platforms).
X
XFor the dll buff, the termnet library is using addresses 0x66000000
Xthrough 0x660fffff.  The jump table size limit is 0x1000, and the global
Xdata size 0x4000.  The version number corresponds to the fields of the
XVERSION variable; thus for VERSION 11854, the library version is 1.18.54.
XWe hope to keep libraries backwards compatible; if for some reason
Xwe have to bump the library major version before bumping term's major
Xversion number, we will stop keeping a close correspondence with VERSION.
X
X
X(Installation guide written by Chris Metcalf <metcalf@lcs.mit.edu>;
Xbugs to Bill Riemers <bcr@physics.purdue.edu.)
END_OF_FILE
  if test 8686 -ne `wc -c <'INSTALL'`; then
    echo shar: \"'INSTALL'\" unpacked with wrong size!
  fi
  # end of 'INSTALL'
fi
if test -f 'Makefile.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.in'\"
else
  echo shar: Extracting \"'Makefile.in'\" \(19578 characters\)
  sed "s/^X//" >'Makefile.in' <<'END_OF_FILE'
X#
X# Term program makefile for @OS@ 
X# valid targets are:
X#	all term linecheck test tags clean install installshare realclean ... 
X
XSRCDIR=@srcdir@
XVPATH=@srcdir@
X
XSHELL=/bin/sh
X# Note: If you change the version #, you must "make realclean"
XVERSION_MAJOR = 2
XVERSION_MINOR = 1
XPATCH_LEVEL   = 2
XPATCH_NAME    = .2
XVERSION_NUM   = @version_num@
X
XCC=@cc@
XCPP=@cpp@
X
X# -DTERM_NFS_DIR is needed if your .term directory is mounted with NFS.
X
XCFLAGS = @debugflags@ @osflags@ -DSHAREDIR='"$(SHAREDIR)"' \
X	-DVERSION=$(VERSION_NUM)
X 
XAR		= @ar@
XRANLIB		= @ranlib@
XAS		= as
XCHGRP		= chgrp term
XCHMOD		= chmod
XCP		= cp
XLN		= ln 
XRM		= rm -f
XRMDIR		= rmdir
XMKDIR		= mkdir
XMV		= mv
XNM		= nm
XSED		= sed
XSHAREDIR	= @sharedir@
XBINDIR		= @bindir@
XLIBDIR		= @libdir@
XMANDIR		= @mandir@
XOSLIBS		= @libs@
XLIBS		= $(TERMNETLIB) $(OSLIBS) $(OSLINK)
XOSLINK		= @oslink@
XLINKFLAGS	= @linkflags@
XUSRTMP		= /usr/tmp
X
X#
X# Change this if yours is different.
X#
XCURSES= -ltermcap
X
X#if static=any    TERMNETDEP=libtermnet.a
X#if static=any    TERMNETLIB=$(TERMNETDEP)
X#if shlib=linux   TERMNETDEP=shared/libtermnet.sa
X#if shlib=linux   TERMNETLIB=$(TERMNETDEP)
X#if shlib=sun     TERMNETDEP=libtermnet.so.$(VERSION_MAJOR).$(VERSION_MINOR)
X#if shlib=sun     TERMNETLIB=-L. -L$(LIBDIR) -ltermnet
X#if shlib=netbsd  TERMNETDEP=libtermnet.so.$(VERSION_MAJOR).$(VERSION_MINOR)
X#if shlib=netbsd  TERMNETLIB=-L. -L$(LIBDIR) -ltermnet
X
XTERMOBJS=main.o serial.o misc.o link.o pty.o compress.o \
X		checksum.o meta.o statistics.o sevenbit.o 
X
XCLIENTOBJS=lib.o client.o termnet.o terminal.o select.o socket.o connect.o \
X		spipe.o term_getopt.o term_putenv.o term_herror.o \
X		term_spair.o
X
XMANPAGES=term.1 term_clients.1 term_setup.1
X
X#if root LINKS = trdated
X#if root LINK_FROM = trdate
X#if root CLIENTS = tdownload tudpredir tmon tshutdown \
X#if root 	trsh tupload tredir txconn trdate
X
X#if !root #if shlib=any LINKS = trdated
X#if !root #if shlib=any LINK_FROM = trdate
X#if !root #if shlib=any CLIENTS = tdownload tudpredir tmon tshutdown \
X#if !root #if shlib=any 	trsh tupload tredir txconn trdate
X
X#if !root #if static=any LINKS = tdownload tupload tmon txconn \
X#if !root #if static=any 	 tudpredir tredir tshutdown trdate trdated
X#if !root #if static=any LINK_FROM = trsh
X#if !root #if static=any CLIENTS = $(LINK_FROM)
X
XPROGS=term $(CLIENTS) linecheck
X
X#if root TRSHOBJS = trshell.o
X#if !root #if shlib=any TRSHOBJS = trshell.o
X#if !root #if static=any TRSHOBJS = term_clients.o trdate.o download.o \
X#if !root #if static=any 	upload.o udpredir.o redir.o tmon.o shutdown.o \
X#if !root #if static=any 	trshell.o xconn.o 
XTESTOBJS 	= test.o
X
Xall: libtermnet.a $(PROGS)
X
Xinstall: all @install_shlib@
X	if [ ! -d $(BINDIR) ] ; then $(MKDIR) $(BINDIR); else true; fi 
X	-cd $(BINDIR); $(RM) $(LINKS)
X	-cd $(BINDIR); for i in $(PROGS) $(LINKS); do \
X		if [ -f $$i ]; then $(MV) $$i $$i.old ; fi ; \
X	done
X	for i in $(PROGS); do \
X		$(CP) $$i $(BINDIR)/. ; \
X		strip $(BINDIR)/$$i ; \
X		$(CHMOD) 755 $(BINDIR)/$$i ; \
X	done
X	-cd $(BINDIR); for i in $(LINKS); do \
X		$(LN) -s ./$(LINK_FROM) $$i ; \
X	done
X	-cd $(BINDIR); for i in $(PROGS); do \
X		if [ -f $$i.old ]; then $(RM) $$i.old ; fi ; \
X	done
X	if [ ! -d $(LIBDIR) ] ; then $(MKDIR) $(LIBDIR); else true; fi
X	$(CP) ./libtermnet.a $(LIBDIR)
X	-cd $(LIBDIR);$(RANLIB) libtermnet.a
X
Xinstallnet: install
X	if [ ! -d $(SHAREDIR) ] ; then $(MKDIR) $(SHAREDIR); else true; fi
X	echo "# This file activates full term networking" > $(SHAREDIR)/termnet
X
Xinstallshare share: install
X	cd $(BINDIR) ; \
X	for i in $(PROGS) ; do \
X#if root		$(CHGRP) $$i ; \
X		$(CHMOD) @setid@ $$i ; \
X	done
X	if [ ! -d $(SHAREDIR) ] ; then $(MKDIR) $(SHAREDIR); else true; fi 
X#if !root	$(CHMOD) 0755 $(SHAREDIR)
X#if !root	if [ ! -d $(SHAREDIR)/tmp ] ; then $(MKDIR) $(SHAREDIR)/tmp; else true; fi 
X#if !root	-$(CHMOD) 755 $(SHAREDIR)/tmp ; \
X#if root	$(CHGRP) $(SHAREDIR)
X#if root	$(CHMOD) 0775 $(SHAREDIR)
X#if root	-if [ -d $(SHAREDIR)/tmp ] ; then \
X#if root		$(MV) $(SHAREDIR)/tmp $(SHAREDIR)/tmp.old ; \
X#if root		$(RM) -r $(SHAREDIR)/tmp.old ; \
X#if root	else true; fi
X#if root	-$(LN) -s $(USRTMP) $(SHAREDIR)/tmp
X	-if [ ! -d $(SHAREDIR)/.term ]; then \
X		 $(LN) -s $(SHAREDIR)/term/private $(SHAREDIR)/.term ; \
X	else true; fi
X
Xinstallman: $(MANPAGES)
X	if [ ! -d $(MANDIR) ]; then $(MKDIR) $(MANDIR); else true; fi
X	cd $(SRCDIR); for i in *.1; do \
X		$(CP) $$i $(MANDIR)/.; \
X	done
X	for i in $(CLIENTS) $(LINKS); do \
X		echo ".so man1/term_clients.1" > $(MANDIR)/$$i.1; \
X	done
X
X# The next two targets are only used by GNU Make, as far as I know.
X# They automatically rebuild Makefile and config.status when necessary.
X
XMakefile: config.status Makefile.in
X	./config.status
X
Xconfig.status: configure
X	./configure
X
X#-----------------------------------------------------------------
X# if your make complains about not know how to make .o files, you
X# may need to uncomment following two lines.. (for gnu make).
X#%.o: %.c
X#	$(CC) $(CFLAGS) -c $< -o $@
X#     --- or following 5 lines ------
X#.SUFFIXES
X#.SUFFIXES:  .o .c
X#
X#.c.o:
X#	$(CC) $(CFLAGS) -c $< -o $@
X#-----------------------------------------------------------------
X
Xlibtermnet.a: $(CLIENTOBJS)
X	$(RM) libtermnet.a
X	$(AR) libtermnet.a $(CLIENTOBJS)
X	$(RANLIB) libtermnet.a
X
Xtest: $(TESTOBJS)
X	$(CC) $(LINKFLAGS) $(NOPAG) -o test $(TESTOBJS) $(OSLIBS)
X#if !root #if static=any 	$(RM) $(LINKS)
X#if !root #if static=any 	for i in $(LINKS); do \
X#if !root #if static=any 		$(LN) -s ./$(LINK_FROM) $$i ; \
X#if !root #if static=any 	done
X
Xterm: $(TERMNETDEP) $(TERMOBJS) 
X	$(CC) $(LINKFLAGS) -o term $(TERMOBJS) $(LIBS)
X
Xtrsh: $(TERMNETDEP) $(TRSHOBJS)
X	$(CC) $(LINKFLAGS) $(NOPAG) -o trsh $(TRSHOBJS) $(CURSES) $(LIBS)
X
Xtupload: $(TERMNETDEP) upload.o
X	$(CC) $(LINKFLAGS) $(NOPAG) -o tupload upload.o $(LIBS)
X
Xtdownload: $(TERMNETDEP) download.o
X	$(CC) $(LINKFLAGS) $(NOPAG) -o tdownload download.o $(LIBS)
X
Xtredir: $(TERMNETDEP) redir.o
X	$(CC) $(LINKFLAGS) $(NOPAG) -o tredir redir.o $(LIBS)
X
Xtudpredir: $(TERMNETDEP) udpredir.o
X	$(CC) $(LINKFLAGS) $(NOPAG) -o tudpredir udpredir.o $(LIBS)
X
Xtxconn: $(TERMNETDEP) xconn.o
X	$(CC) $(LINKFLAGS) $(NOPAG) -o txconn xconn.o $(LIBS)
X
Xtshutdown: $(TERMNETDEP) shutdown.o
X	$(CC) $(LINKFLAGS) $(NOPAG) -o tshutdown shutdown.o $(LIBS)
X
Xtmon: $(TERMNETDEP) tmon.o
X	$(CC) $(LINKFLAGS) $(NOPAG) -o tmon tmon.o $(CURSES) $(LIBS)
X
Xtrdate: $(TERMNETDEP) trdate.o
X	$(CC) $(LINKFLAGS) $(NOPAG) -o trdate trdate.o $(CURSES) $(LIBS)
X
Xlinecheck: $(TERMNETDEP) linecheck.o
X	$(CC) $(LINKFLAGS) $(NOPAG) -o linecheck linecheck.o $(LIBS)
X
Xtags:
X	etags *.h *.c
X
X
Xclean:
X	$(RM) *.o lib*.a lib*.sa lib*.so.* core compress.debug *.out *~ 
X#if shlib=linux 	$(RM) shared/* $(SRCDIR)/jump/_*
X#if shlib=sun   	$(RM) shared/*
X#if shlib=netbsd	$(RM) shared/*
X
Xrealclean: clean
X	$(RM) $(PROGS) $(LINKS) test 1 TAGS tags
X	-$(RM) *.log
X#if shlib=linux 	$(RM) -r shared $(SRCDIR)/jump/jump.import
X#if shlib=sun   	$(RM) -r shared
X#if shlib=netbsd 	$(RM) -r shared
X
X
X# depend dep:
X#	$(SED) '/\#\#\# Dependencies/q' < Makefile.rules > tmp_make
X#	for i in $(SRCDIR)/*.c ;do $(CPP) -MM $$i;done >> tmp_make
X#	$(MV) tmp_make Makefile.rules
X
X#if shlib=any   LDCONFIG	= @ldconfig@
X#if shlib=any   # This text is all the @OS@ specific shared library stuff
X
X#if shlib=linux DLLBIN  = @dllbin@
X#if shlib=linux DLLAS   = @dllas@
X#if shlib=linux MKIMAGE	= $(DLLBIN)mkimage -f
X#if shlib=linux MKSTUBS	= $(DLLBIN)mkstubs
X#if shlib=linux GETVARS	= $(DLLBIN)getvars
X#if shlib=linux GETFUNCS = $(DLLBIN)getfuncs
X#if shlib=linux GETSIZE = $(DLLBIN)getsize
X#if shlib=linux VERIFY	= $(DLLBIN)verify-shlib
X#if shlib=linux 
X#if shlib=linux VERSION=$(VERSION_MAJOR).$(VERSION_MINOR).$(PATCH_LEVEL)
X#if shlib=linux # When you change the following #'s you need to increase the
X#if shlib=linux # major version # of the library.  I really don't care about
X#if shlib=linux # lookup table speeds, so I made these large defaults.
X#if shlib=linux ADDRESS=0x66000000
X#if shlib=linux JUMPSIZE=0x1000    # allows 1000 functions.
X#if shlib=linux GOTSIZE=0x4000     # allows 16k (16 x 1024 arrays) of variables
X#if shlib=linux JUMP_DIR=@abs_srcdir@/jump
X#if shlib=linux JUMP_LIB=libtermnet
X#if shlib=linux NOPAG=-N -s
X#if shlib=linux
X#if shlib=linux $(CLIENTOBJS): $(SRCDIR)/jump/jump.import
X#if shlib=linux 	@if [ ! -d shared ] ; then $(MKDIR) shared ; else true ; fi
X#if shlib=linux 	$(CC) -S $(CFLAGS) $(SRCDIR)/$*.c
X#if shlib=linux 	$(AS) -o $*.o $*.s
X#if shlib=linux 	cd shared; JUMP_DIR=$(JUMP_DIR) JUMP_LIB=$(JUMP_LIB) \
X#if shlib=linux 		$(DLLAS) -o $*.o ../$*.s
X#if shlib=linux 	$(RM) $*.s
X#if shlib=linux
X#if shlib=linux $(SRCDIR)/jump/jump.import: /usr/lib/libc.sa
X#if shlib=linux 	$(NM) --no-cplus -o /usr/lib/libc.sa | \
X#if shlib=linux 		$(SED) -n '/__GOT__/s/__GOT_//p' > $(JUMP_DIR)/jump.import
X#if shlib=linux
X#if shlib=linux shared/libtermnet.so.$(VERSION): $(CLIENTOBJS)
X#if shlib=linux 	@if [ -f $(JUMP_DIR)/jump.log ]; then \
X#if shlib=linux 		echo "*** WARNING: $(JUMP_DIR)/jump.log exists!" >&2; \
X#if shlib=linux			echo ">>> HINT: Running 'make jump-update' without interruption" >&2; \
X#if shlib=linux			echo ">>>       may be easier than manually updating " >&2; \
X#if shlib=linux 		exit 1; \
X#if shlib=linux 	fi
X#if shlib=linux 	cd shared; JUMP_DIR=$(JUMP_DIR) $(MKIMAGE) \
X#if shlib=linux 		-l libtermnet -v $(VERSION) -a $(ADDRESS) -j $(JUMPSIZE) \
X#if shlib=linux 		-g $(GOTSIZE) -- $(CLIENTOBJS) `gcc -print-libgcc-file-name` -lc
X#if shlib=linux 	cd shared; cp libtermnet.so.$(VERSION) libtermnet.so.$(VERSION).new
X#if shlib=linux 	cd shared; mv libtermnet.so.$(VERSION).new libtermnet.so.$(VERSION)
X#if shlib=linux
X#if shlib=linux
X#if shlib=linux shared/libtermnet.sa: shared/libtermnet.so.$(VERSION)
X#if shlib=linux 	cd shared; JUMP_DIR=$(JUMP_DIR) $(MKSTUBS) \
X#if shlib=linux 		-l libtermnet -v $(VERSION) -a $(ADDRESS) -j $(JUMPSIZE) \
X#if shlib=linux 		-g $(GOTSIZE) -- libtermnet
X#if shlib=linux	
X#if shlib=linux install-shlib: shared/libtermnet.sa shared/libtermnet.so.$(VERSION)
X#if shlib=linux 	if [ ! -d $(LIBDIR) ] ; then $(MKDIR) $(LIBDIR); else true; fi
X#if shlib=linux 	$(CP) -pf shared/libtermnet.sa shared/libtermnet.so.$(VERSION) \
X#if shlib=linux 		$(LIBDIR)/.
X#if shlib=linux #if root 	$(LDCONFIG)
X#if shlib=linux #if !root	$(LN) -sf libtermnet.so.$(VERSION) $(LIBDIR)/libtermnet.so.$(VERSION_MAJOR)
X#if shlib=linux #if !root 	@echo "In order for your term binaries to work you will need to" >&2
X#if shlib=linux #if !root 	@echo "add export LD_LIBRARY_PATH='$(LIBDIR)' to your ~/.profile" >&2
X#if shlib=linux #if !root 	@echo "and add setenv LD_LIBRARY_PATH '$(LIBDIR)' to your ~/.login" >&2
X#if shlib=linux #if !root 	@echo "Then logout, and login again." >&2
X#if shlib=linux 
X#if shlib=linux # jump-update by Davor Jadrijevic, <davor%emard.uucp@ds5000.irb.hr>
X#if shlib=linux # modified by Bill C. Riemers to use $(JUMP_DIR).new
X#if shlib=linux
X#if shlib=linux jump-update: $(JUMP_DIR)/jump.log
X#if shlib=linux 	$(RM) -r $(JUMP_DIR).new
X#if shlib=linux 	$(CP) -a $(JUMP_DIR) $(JUMP_DIR).new
X#if shlib=linux 	cat $(JUMP_DIR).new/jump.vars >> $(JUMP_DIR).new/jump.funcs
X#if shlib=linux 	cat $(JUMP_DIR).new/jump.log >> $(JUMP_DIR).new/jump.funcs
X#if shlib=linux 	$(MV) $(JUMP_DIR).new/jump.funcs $(JUMP_DIR).new/jump.log
X#if shlib=linux 	cd $(JUMP_DIR).new; JUMP_DIR=$(JUMP_DIR).new $(GETVARS)
X#if shlib=linux 	cd $(JUMP_DIR).new; JUMP_DIR=$(JUMP_DIR).new $(GETFUNCS)
X#if shlib=linux 	$(RM) $(JUMP_DIR).new/jump.log $(JUMP_DIR).new/*.s
X#if shlib=linux  	$(MAKE) JUMP_DIR=$(JUMP_DIR).new clean $(CLIENTOBJS)
X#if shlib=linux 	cd $(JUMP_DIR).new; JUMP_DIR=$(JUMP_DIR).new $(GETSIZE) > \
X#if shlib=linux 		jump.vars.min; 
X#if shlib=linux		if [ ! -s $(JUMP_DIR).new/jump.funcs ] ; then \
X#if shlib=linux 		echo "Error updating jump/jump.funcs"; exit 1; \
X#if shlib=linux		elif [ `wc -l < $(JUMP_DIR).new/jump.funcs` -lt \
X#if shlib=linux 		`wc -l < $(JUMP_DIR)/jump.funcs` ] ; then \
X#if shlib=linux 		echo "Error updating jump/jump.funcs"; exit 1; \
X#if shlib=linux 	fi;
X#if shlib=linux		if [ ! -s $(JUMP_DIR).new/jump.vars ] ; then \
X#if shlib=linux 		echo "Error updating jump/jump.vars"; false; \
X#if shlib=linux		elif [ `wc -l < $(JUMP_DIR).new/jump.vars` -lt \
X#if shlib=linux			`wc -l < $(JUMP_DIR)/jump.vars` ] ; then \
X#if shlib=linux 		echo "Error updating jump/jump.vars"; false; \
X#if shlib=linux 	fi;
X#if shlib=linux		$(CP) -f $(JUMP_DIR).new/* $(JUMP_DIR)/.
X#if shlib=linux 	$(RM) -r $(JUMP_DIR).new $(JUMP_DIR)/jump.log
X#if shlib=linux		@if [ -s $(JUMP_DIR).new/jump.vars.min ] ; then \
X#if shlib=linux 		echo ">>> HINT: 'jump/jump.vars.min' is generated." >&2; \
X#if shlib=linux 		echo ">>> HINT: Extend it if needed and overwrite 'jump/jump.vars'" >&2; \
X#if shlib=linux 		echo ">>> HINT: Then 'make' again" >&2; \
X#if shlib=linux 	else \
X#if shlib=linux 		$(RM) $(JUMP_DIR)/jump.vars.min; \
X#if shlib=linux 	fi
X#if shlib=linux 
X
X#if shlib=sun   # If you want to use /usr/lang/acc instead, use -pic not -fpic
X#if shlib=sun
X#if shlib=sun   VERSION=$(VERSION_MAJOR).$(VERSION_MINOR)
X#if shlib=sun
X#if shlib=sun   libtermnet.so.$(VERSION): $(CLIENTOBJS)
X#if shlib=sun   	cd shared; ld -assert pure-text $(CLIENTOBJS)
X#if shlib=sun   	mv shared/a.out libtermnet.so.$(VERSION)
X#if shlib=sun 
X#if shlib=sun   shlib: libtermnet.so.$(VERSION)
X#if shlib=sun 
X#if shlib=sun   $(CLIENTOBJS):
X#if shlib=sun   	@if [ ! -d shared ]; then $(MKDIR) shared; else true; fi
X#if shlib=sun   	$(CC) -c $(CFLAGS) $(SRCDIR)/$*.c
X#if shlib=sun   	$(CC) -fpic -o shared/$*.o -c $(CFLAGS) $(SRCDIR)/$*.c
X#if shlib=sun
X#if shlib=sun   install-shlib: libtermnet.so.$(VERSION)
X#if shlib=sun   	if [ ! -d $(LIBDIR) ]; then $(MKDIR) $(LIBDIR); else true; fi
X#if shlib=sun    	$(RM) $(LIBDIR)/libtermnet.so.$(VERSION)
X#if shlib=sun    	$(CP) libtermnet.so.$(VERSION) $(LIBDIR)/.
X#if shlib=sun   #if root 	$(LDCONFIG)
X
X#if shlib=netbsd  VERSION=$(VERSION_MAJOR).$(VERSION_MINOR)
X#if shlib=netbsd
X#if shlib=netbsd  libtermnet.so.$(VERSION): $(CLIENTOBJS)
X#if shlib=netbsd	cd shared; ld -Bshareable -Bforcearchive $(CLIENTOBJS)
X#if shlib=netbsd	mv shared/a.out libtermnet.so.$(VERSION)
X#if shlib=netbsd
X#if shlib=netbsd  shlib: libtermnet.so.$(VERSION)
X#if shlib=netbsd
X#if shlib=netbsd  $(CLIENTOBJS):
X#if shlib=netbsd	@if [ ! -d shared ]; then $(MKDIR) shared; fi
X#if shlib=netbsd	$(CC) -c $(CFLAGS) $(SRCDIR)/$*.c
X#if shlib=netbsd	$(CC) -fpic -o shared/$*.o -c $(CFLAGS) $(SRCDIR)/$*.c
X#if shlib=netbsd
X#if shlib=netbsd  install-shlib: libtermnet.so.$(VERSION)
X#if shlib=netbsd 	if [ ! -d $(LIBDIR) ] ; then $(MKDIR) $(LIBDIR); else true; fi
X#if shlib=netbsd 	$(RM) $(LIBDIR)/libtermnet.so.$(VERSION)
X#if shlib=netbsd 	$(CP) libtermnet.so.$(VERSION) $(LIBDIR)/.
X#if shlib=netbsd  #if root 	$(LDCONFIG)
X
X#
X# The following targets are mostly for my personal use. I use them to 
X# update the version of term when I am developing.
X#
X
XVERSION_NAME = term-$(VERSION_MAJOR).$(VERSION_MINOR)$(PATCH_NAME)
XARCHIVE = /usr/local/src/term.old/$(VERSION_NAME)
XALPHA_DIR = /opt/ftp/pub/bcr/term/ALPHA
XBETA_DIR = /opt/ftp/pub/bcr/term
X
Xdistclean: realclean
X	$(RM) config.status Makefile
X	-$(RM) `find . -name \*.orig`
X	-$(RM) `find . -name \*.rej`
X
Xrcs_extract:
X	-co -q`expr $(VERSION_MAJOR) \* 100 + $(VERSION_MINOR)`.$(PATCH_LEVEL) \
X	  `find . -name \*,v -print | sed 's/,v$$//'`
X	$(CHMOD) ugo+x configure
X
Xrcs_purge: rcs_extract
X	rcs -o`expr $(VERSION_MAJOR) \* 100 + $(VERSION_MINOR)`.$(PATCH_LEVEL) \
X	  `find . -name \*,v -print | sed 's/,v$$//'`
X
Xrcs_ver: distclean rcs_extract
X	rcs -U `find . -name \*,v -print`
X	yes|tr y .|ci -f`expr $(VERSION_MAJOR) \* 100 + $(VERSION_MINOR)`.$(PATCH_LEVEL) \
X	  -n`echo term-$(VERSION_MAJOR).$(VERSION_MINOR)$(PATCH_NAME)|tr . _` \
X	  `find . -type f -not -name \*,v -not -name \*.gz -print`
X	co -q`expr $(VERSION_MAJOR) \* 100 + $(VERSION_MINOR)`.$(PATCH_LEVEL) \
X	  `find . -name \*,v -print | sed 's/,v$$//'`
X	$(CHMOD) ugo+x configure
X
Xrcs_tar: distclean rcs_extract
X	$(RM) /tmp/$(VERSION_NAME)
X	$(LN) -s `pwd` /tmp/$(VERSION_NAME)
X	cd /tmp ; \
X	  find $(VERSION_NAME) -follow -type f -not -name \*,v -print | \
X	  sort -u | tar Tcvvfz - $(ARCHIVE).tar.gz
X
Xrcs_patch: distclean rcs_extract
X	$(RM) /tmp/$(VERSION_NAME)
X	$(LN) -s `pwd` /tmp/$(VERSION_NAME)
X	cd /tmp; version_name=$(VERSION_NAME); rcsdiff \
X	  -u -r`expr $(VERSION_MAJOR) \* 100 + $(VERSION_MINOR)`.`expr $(PATCH_LEVEL) - 1` \
X	  `find $$version_name -follow -type f -not -name \*,v -not -name \*.gz -print` \
X	  | gzip -c > $(ARCHIVE).patch.gz
X	if [ $(PATCH_LEVEL) -le 50 ] ; then \
X		$(CP) $(ARCHIVE).patch.gz $(SRCDIR)/patches/. ; \
X	else true; fi
X
Xrcs_update: rcs_ver rcs_tar rcs_patch
X	$(RM) /tmp/$(VERSION_NAME)
X	$(LN) -s `pwd` /tmp/$(VERSION_NAME)
X	cd /tmp; if [ $(PATCH_LEVEL) -gt 50 ] ; then \
X	  tupload -fvv $(ARCHIVE).*.gz $(ALPHA_DIR) ; \
X	else \
X	  tupload -fvv $(ARCHIVE).*.gz $(BETA_DIR) ; \
X	fi
X
Xrcs_remote: rcs_tar
X	$(RM) /tmp/$(VERSION_NAME)
X	$(LN) -s `pwd` /tmp/$(VERSION_NAME)
X	cd /tmp; tupload -fvv $(ARCHIVE).tar.gz /tmp
X	trsh -s 'cd /tmp;zcat $(VERSION_NAME).tar.gz|tar xvvf -'
X	trsh -s 'cd /tmp/$(VERSION_NAME);./configure --user;make install'
X
Xrcs_spell: distclean rcs_extract
X	ispell -p $(HOME)/.term_dict `find . -type f -not -name \*,v -not -name \*.gz`
X
Xdummy:
X
Xchecksum.o : checksum.c 
Xclient.o : client.c includes.h term.h config.h client.h terminal.h 
Xcompress.o : compress.c includes.h term.h config.h client.h terminal.h debug.h 
Xconnect.o : connect.c includes.h term.h config.h client.h terminal.h 
Xlib.o : lib.c includes.h term.h config.h client.h terminal.h debug.h 
Xlinecheck.o : linecheck.c includes.h term.h config.h client.h terminal.h 
Xlink.o : link.c includes.h term.h config.h client.h terminal.h debug.h 
Xmain.o : main.c includes.h term.h config.h client.h terminal.h debug.h 
Xmeta.o : meta.c includes.h term.h config.h client.h terminal.h debug.h 
Xmisc.o : misc.c includes.h term.h config.h client.h terminal.h debug.h 
Xpty.o : pty.c includes.h term.h config.h client.h terminal.h debug.h 
Xredir.o : redir.c includes.h term.h config.h client.h terminal.h 
Xudpredir.o : udpredir.c includes.h term.h config.h client.h terminal.h 
Xselect.o : select.c includes.h term.h config.h client.h terminal.h 
Xserial.o : serial.c includes.h term.h config.h client.h terminal.h debug.h 
Xserver.o : server.c includes.h term.h config.h client.h terminal.h 
Xsevenbit.o : sevenbit.c includes.h term.h config.h client.h terminal.h debug.h 
Xshutdown.o : shutdown.c includes.h term.h config.h client.h terminal.h 
Xsocket.o : socket.c includes.h term.h config.h client.h terminal.h 
Xspipe.o : spipe.c includes.h term.h config.h client.h terminal.h
Xstatistics.o : statistics.c includes.h term.h config.h client.h terminal.h 
Xtclient.o : tclient.c includes.h term.h config.h client.h terminal.h 
Xterm_getopt.o : term_getopt.c includes.h term.h config.h client.h terminal.h 
Xterm_herror.o : term_herror.c includes.h term.h config.h client.h terminal.h 
Xterm_putenv.o : term_putenv.c includes.h term.h config.h client.h terminal.h 
Xterm_spair.o : term_spair.c includes.h term.h config.h client.h terminal.h 
Xterminal.o : terminal.c includes.h term.h config.h client.h terminal.h 
Xtermnet.o : termnet.c includes.h term.h config.h client.h terminal.h 
Xtest.o : test.c includes.h term.h config.h client.h terminal.h 
Xtmon.o : tmon.c includes.h term.h config.h client.h terminal.h 
Xtrdate.o : trdate.c includes.h term.h config.h client.h terminal.h 
Xtrshell.o : trshell.c includes.h term.h config.h client.h terminal.h 
Xupload.o : upload.c includes.h term.h config.h client.h terminal.h 
Xdownload.o : download.c includes.h term.h config.h client.h terminal.h 
Xxconn.o : xconn.c includes.h term.h config.h client.h terminal.h
X 
END_OF_FILE
  if test 19578 -ne `wc -c <'Makefile.in'`; then
    echo shar: \"'Makefile.in'\" unpacked with wrong size!
  fi
  # end of 'Makefile.in'
fi
if test -f 'client.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'client.c'\"
else
  echo shar: Extracting \"'client.c'\" \(10981 characters\)
  sed "s/^X//" >'client.c' <<'END_OF_FILE'
X#define I_IOCTL
X#define I_SYS
X#define I_GETOPT
X#define I_SOCKET
X#define I_STAT
X#define I_SIGNAL
X#define I_STRING
X#define I_ARGS
X#define I_INET
X#include "includes.h"
X
X#include "client.h"
X
Xchar *term_server = "";
X
Xint lcompression = -1;		/* defaults. */
Xint rcompression = -1;
Xint verbose = 0;
Xint priority = 0;
Xchar com_result[1024];
Xchar *command_result=NULL;
Xint savedeid     = -1;
Xlong unsigned remote_term_version = 0;
Xlong unsigned term_localaddr = INADDR_ANY;
Xlong unsigned term_remoteaddr = INADDR_ANY;
Xchar term_localhost[256];
Xchar term_remotehost[256];
X
Xstatic int try_connect_server(int S,char *server) {
X  char *path;
X  char *ptr=NULL;
X  int s;
X 
X  if (!server) server = "";
X
X  if (share) {
X
X    if (savedeid >= 0) {
X      if (share == 2)
X        setuid(savedeid);
X      else
X        setgid(savedeid);
X    }
X    do {
X      if ((path = get_term_path(&ptr))) {
X        strcat(path,"/tmp/private");
X        strcat(path,server);
X        if (eaccess(path, getuid() ? (X_OK | R_OK) : 0) >= 0) break;
X      }else break;
X    } while ( ptr );
X#ifdef _POSIX_SAVED_IDS
X    if(share == 2)
X      setuid(getuid());
X    else
X      setgid(getgid());
X#endif /* _POSIX_SAVED_IDS */
X  }else{
X    do {
X      if ((path = get_term_path(&ptr))) {
X        strcat(path,"/.term");
X        if (access(path, X_OK | R_OK | W_OK) >= 0) break;
X      }else break;
X    } while ( ptr );
X  };
X  if (!path) {
X    sprintf(com_result, "XX%cCan't find term directory.", I_NA);
X    return -1;
X  }
X  if (!share) 
X    sprintf(&path[strlen(path)],"/socket%s", server);
X  else
X    strcat(&path[strlen(path)],"/socket");
X
X				/* Try and connect to term. */
X#ifdef _POSIX_SAVED_IDS
X  if (savedeid >= 0)
X    if (share == 2)
X      setuid(savedeid);
X    else
X      setgid(savedeid);
X#endif /* _POSIX_SAVED_IDS */
X  s = connect_unix(S,path);
X#ifdef _POSIX_SAVED_IDS
X  if (share == 2)
X    setuid(getuid());
X  else
X    setgid(getgid());
X#endif /* _POSIX_SAVED_IDS */
X
X  if(s<0){
X    sprintf(com_result,"XX%cFailed to connect to term socket '%s'",I_NA,path);
X    return -1;
X  };
X
X  if (!remote_term_version) {
X    memset(term_remotehost,0,sizeof(term_remotehost));
X    strcpy(term_remotehost,"remotehost");
X    if (send_command(s, C_STATS, 1, "%d", -10) >= 0) 
X      sscanf(command_result,"VERSION %lu %lx %s",&remote_term_version,
X        &term_remoteaddr, term_remotehost);
X    if (! remote_term_version) {
X      send_command(s, C_STATS, 0, "%d", -1);	/* This is a dummy command */
X      if (send_command(s, C_STATS, 1, "%d", -10) >= 0) 
X        sscanf(command_result,"VERSION %lu %lx %s",&remote_term_version,
X          &term_remoteaddr, term_remotehost);
X      if (! remote_term_version)  
X        remote_term_version = 10800;
X    }
X  }
X  if (term_remoteaddr == INADDR_ANY)
X     term_remoteaddr = ntohl(inet_addr("127.0.0.254"));
X
X  if ( lcompression >=0)
X    send_command(s, C_COMPRESS, 1, "%d", lcompression);
X  if (rcompression >= 0) 
X    send_command(s, C_COMPRESS, 0, "%d", rcompression);
X
X  if (priority) {
X    send_command(s, C_PRIORITY, 1, "%d", priority);
X    send_command(s, C_PRIORITY, 0, "%d", priority);
X  }
X
X  return s;
X}
X
X				/* parse all the options, and then */
X				/* return the first unused argument. */
Xint client_options(int argc, char *argv[], char *myopts, Callback callback)
X{
X  int c, i;
X  char args[200];
X
X  command_result = &com_result[3];
X
X  /* make sure we get all the args to pass to getopt */
X  if (getenv("TERMSERVER"))
X    term_server = getenv("TERMSERVER");
X
X
X  strcpy(args, "t:crp:S:");
X  strcat(args, myopts);
X
X  while ((c = term_getopt(argc, argv, args))!=EOF) {
X    switch(c) {
X    case 't':
X      term_server = term_optarg;	
X      break;
X    case 'c': /* for compression */
X      lcompression = 1;
X      rcompression = 1;
X      break;
X    case 'r': /* for raw, no compression */
X      lcompression = 0;
X      rcompression = 0;
X      break;
X    case 'p':
X      priority = atoi(term_optarg);
X      fprintf(stderr, "Changing priority to %d\n", priority);
X      break;
X    case 'v':
X      verbose++;
X      break;
X    case 'S':
X      if ( !(i = atoi(term_optarg) ? atoi(term_optarg) : !strcmp(term_optarg,"on"))) 
X        share = 0;
X      else
X        share = (share == 1) ? 1 : 2;
X      break;
X    case '?':
X      sprintf(com_result,"XX%c'?' is an illegal for some unknown reason",I_NA);
X      return -1;
X    default:
X      if ( (callback == NULL) || ( callback(c, term_optarg) == -1 ) )
X	{
X	  sprintf(com_result, "XX%cUnrecognized option '%s'",I_NA,
X            argv[term_optind]);
X	  return -1; 
X	}
X      break;
X    }
X  }
X  return term_optind;
X}
X				/* Send a command to the Term */
X				/* process.*/ 
X#ifdef USE_VARARGS
Xint send_command(sock , comm, local , fmt, va_alist)
Xint sock , comm, local;
Xchar *fmt;
Xva_dcl {
X#else
Xint send_command(int sock, int comm, int local, char *fmt, ...) {
X#endif
X  char buff[1024];
X  va_list v;
X  unsigned long version;
X  int i, blocking;
X  char old = 0;
X#ifdef USE_VARARGS
X  va_start(v);
X#else
X  va_start(v, fmt);
X#endif
X				/* A command follows.. */
X  buff[0] = C_SWITCH;
X				/* Is it for the local term? or the */
X				/* remote term? */
X  if (local)
X    buff[1] = C_SWITCH - 1;
X  else
X    buff[1] = C_SWITCH - 2;
X
X  if (old)
X    old = com_result[3];
X  else
X    old = I_NA;
X
X  sprintf(com_result,"XX%cUnsupported term option", I_NA);
X  command_result = &com_result[3];
X
X  if (comm == C_WAIT) {
X    comm = C_STATS;
X    if (old == I_OK || old == I_FAIL) return 0;
X  }
X
X  if (local) 
X    version = VERSION;
X  else
X    version = remote_term_version;
X
X	/* Here I support older versions */
X  switch (comm) {
X  case C_DUMP:
X    if (version < 20000)
X      comm = C_DUMP_OLD ;
X    break; 
X  case C_NAME:
X    if (version < 20000)
X      comm = C_NAME_OLD;
X    break; 
X  case C_PRIORITY:
X    if (version < 20000)
X      comm = C_PRIORITY_OLD ;
X    break; 
X  case C_RESIZE:
X    if (version < 20000) 
X      comm = C_RESIZE_OLD ;
X    break; 
X  case C_X_SERVER:
X    if (version < 11500)
X      comm = C_SOCKET;
X    break;
X  case C_GETPEERNAME:
X  case C_GETSOCKNAME:
X    if (version < 11714)
X      return -1;
X    break;
X  case C_UBIND:
X  case C_UDPSET:
X  case C_USOCK:
X    if (version < 20000) 
X      return -1;
X    break;
X  case C_PUTENV:
X    if (version < 20000) 
X      return -1;
X    break;
X  case C_CLIENTNUM:
X    return -1;
X    break; 
X  case C_CHMOD:
X    if (version < 20055)
X      return -1;
X    break;
X  case C_DOWNLOAD:
X    if (version < 20058)
X      return -1;
X    break;
X  }
X
X				/* Set the command in. */
X  buff[2] = comm;
X  if (fmt)
X    vsprintf(buff+3, fmt, v);
X  else
X    buff[3] = 0;
X
X  va_end(v);
X
X  switch (comm) {
X  case C_GETHOSTNAME:
X    if (! buff[3] || !strcmp(&buff[3],"remotehost") 
X        || !strcmp(&buff[3],term_remotehost)) {
X      if (version > 20053 || version < 11714) { 
X        sprintf(com_result,"XX%c%lx %s", I_NA,
X          term_remoteaddr, term_remotehost);
X        return 0;
X      }
X    }else if (version < 11714) return -1;
X    break;
X  }
X
X  blocking = set_block(sock);
X				/* Ok. Buff holds the entire command. */
X				/* Lets do the damned thing.. */
X  sprintf(com_result,"XX%cWrite error", I_NA);
X  if (write(sock, buff, strlen(buff)+1) < 0)
X    return -1;
X
X  memset(com_result,0,sizeof(com_result));
X  sprintf(com_result,"XX%cno result forthcoming", I_NA);
X				/* If the command is C_DUMB, then no */
X				/* reply will be forthcoming. */
X  switch (comm) {
X  case C_CLCLOSE:
X  case C_CLOSE:
X  case C_CHMOD:
X  case C_DUMB:
X  case C_QUIT:
X  case C_DUMP:
X  case C_PUTENV:
X  case C_NAME:
X  case C_PRIORITY:
X  case C_RESIZE:
X    return 1;
X  }
X
X  i = 0;
X  do {
X    read(sock, &com_result[i], 1);
X  } while (com_result[i++]);
X
X  if (!blocking) set_nonblock(sock);
X
X  if (com_result[2] != I_OK)
X    return -1;
X/*  printf("command return was (%d)%s", i, com_result);*/
X  return 1;
X}
X
X
X/* This is a short routine to allow the user to try to connect a socket
X * to term.  If a negative file descriptor is supplied, a new socket 
X * will be created.
X */
X
Xint socket_connect_server(int S,char *server) {
X  int s = -1;
X
X  sprintf(com_result,"XX%cNo error reported", I_NA);
X  command_result = &com_result[3];
X
X  set_share_mode(0,share);
X	/* If "share" is still undecided, I try both shared and unshared. */
X  if(share==-1){
X    set_share_mode(0,1);
X    s=try_connect_server(S,server);
X    if ( s < 0 ) {
X      set_share_mode(0,2);
X      s=try_connect_server(S,server);
X      if ( s < 0 ) share = 0;
X    }
X  };
X  if ( s < 0 ) 
X    s=try_connect_server(S,server);
X  if ( s < 0 )
X    return -1;
X  return s;
X}
X
X/* This is a short routine to allow the user to try to connect to a term
X * server.  The main difference between this and socket_connect_server with
X * a negative file descriptor, is this routine will never return if the
X * connection attempt fails.
X */
X
Xint connect_server(char *server) {
X  int s = -1;
X
X  sprintf(com_result,"XX%cNo error reported", I_NA);
X  command_result = &com_result[3];
X
X  set_share_mode(0,share);
X	/* If "share" is still undecided, I try both shared and unshared. */
X  if (share == -1){
X    set_share_mode(0,1);
X    s = try_connect_server(-1,server);
X    if (s < 0) {
X      set_share_mode(0,2);
X      s = try_connect_server(-1,server);
X      if (s < 0) share = 0;
X    }
X  };
X  if (s < 0) s = try_connect_server(-1,server);
X  if (s < 0) exit(1);
X  return s;
X}
X
X
X/* build_arg: build a string from char ** argv to be passed 
X * to C_EXEC family. 
X *
X * by: croutons
X *
X * Notes:
X *  returns a pointer to malloced space.
X *  takes a null pointer as the end of the array of char*.
X *  assumes null terminated strings. (for using string(3))
X *  returns NULL on error.
X *
X *  we assume '\377' is ok for the new terminator
X */
Xchar *build_arg( char **arg )
X{
X	int i, s;
X	static char *f = NULL;
X        char *term = NULL;
X
X        if (f) free(f);
X	if (! arg) return NULL;
X        if (*arg == NULL) return NULL;
X
X	for (s = i = 0; NULL != arg[i]; i++) s += strlen(arg[i]);
X
X        if (remote_term_version >= 11715) {
X          term = getenv("TERM");
X          if (term != NULL)
X            s += strlen(term) + strlen("-DTERM=") + 1;
X        }
X        s += i + 2;
X
X	if ( NULL == (f = (char *)malloc( s * sizeof(char) ) ) ) 
X		return NULL;
X
X		/* This passes the terminal type */
X
X        if (term != NULL) 
X          sprintf(f,"-DTERM=%s%c",term,'\377');
X        else
X          f[0] = '\0';
X
X 	for ( i = 0; NULL != arg[i]; i++ ) {	
X		strcat(f,arg[i]);
X                strcat(f,"\377");
X        }
X
X	return f;
X}
X
Xint use_term_command(int type) {
X  char *ptr=NULL;
X  char *path;
X  static int use_term = -1;
X
X  switch (type) {
X  case PUBLIC:
X#ifdef _POSIX_SAVED_IDS
X    if (savedeid < 0) 
X      set_share_mode(0,share);
X#endif
X     break;
X  case PRIVILEGED:
X  default:
X    set_share_mode(1,share);
X    break;
X  }
X
X  if (use_term >= 0) return use_term;
X  if (getenv("TERMMODE")) return (use_term=1);
X  do {
X    if ((path = get_term_path(&ptr))) {
X      strcat(path,"/termnet");
X      strcat(path,term_server);
X      if (access(path, 0) >= 0) break;
X    }else break;
X  }while (ptr);
X  return (use_term = (path != NULL));
X}
X
END_OF_FILE
  if test 10981 -ne `wc -c <'client.c'`; then
    echo shar: \"'client.c'\" unpacked with wrong size!
  fi
  # end of 'client.c'
fi
if test -f 'compress.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'compress.c'\"
else
  echo shar: Extracting \"'compress.c'\" \(11982 characters\)
  sed "s/^X//" >'compress.c' <<'END_OF_FILE'
X/*
X** Copyright Michael O'Reilly. All rights reserved.
X*/
X#include "includes.h"
X#include "debug.h"
X				/* Following used for debugging. */
X#if 0
X#define ASSERT(a) \
X	((a) ? 0: abort() )
X#else
X#define ASSERT(a)
X#endif
X
X#define BYTE_WIDTH_OUT	tok_byte_width_out
X#define BYTE_MASK_OUT	tok_byte_mask_out
X
X#define BYTE_MASK_IN	tok_byte_mask_in
X#define BYTE_WIDTH_IN	tok_byte_width_in
X
Xint tok_byte_mask_out = 255,
X  tok_byte_width_out = 8;
Xint tok_byte_mask_in = 255,
X  tok_byte_width_in = 8;
X
Xint stat_comp_in = 0,
X  stat_comp_out = 0,
X  stat_uncomp_in = 0,
X  stat_uncomp_out = 0;
X/*
X** token 256 is reserved to signal that dict clearing should take place.
X** token 257 is reserved for future use.
X**
X** the max token size is 16 bits.
X*/
X
X#define DICT_SIZE  8192
X#define DICT_CLEAR_2 4096
X#define DICT_CLEAR_2_TSIZE 13
X
X/* #define DEBUG **/
X
Xtypedef struct node {
X    short   ch;			/* character for this node */
X    struct node *next_node;	/* Pointer to the next link on this node. */
X    struct node *child;		/* Pointer to a child of this node. */
X    int     len;		/* You tell me.  */
X    int     num;		/* token number for this node */
X}                   NODE;
X
X#ifdef DEBUG
XFILE * stdprn = 0;
X#endif
X#if 0
Xextern  void * malloc (int);
Xextern  void * realloc (char *, int);
X#endif
X
Xvoid clear_table (NODE *, int);
Xint  uncomp_dict[DICT_SIZE][2];
XNODE comp_dict = {
X    0, 0, 0, 0, 0
X};
X
Xstatic int  c_token_mask,
X            c_token_bits,
X            unc_token_bits,
X            unc_token_mask,
X
X            comp_table_size,
X            uncomp_table_size;
Xstatic int  stack[1024];
X
Xstatic int  stk_ptr = 0;
Xint compress_init (void) {
X    int     i;
X    if (comp_dict.child) {
X	for (i = 0; i < 256; ++i)
X	    clear_table (&(comp_dict.child[i]), 255);
X    }
X    else
X	comp_dict.child = (NODE *) malloc (256 * sizeof (NODE));
X    comp_dict.len = 256;
X    comp_dict.ch = 0;
X    comp_dict.num = 0;
X    comp_dict.next_node = 0;	/* Only one NODE in this node. */
X    for (i = 0; i < 256; ++i) {
X	uncomp_dict[i][0] = comp_dict.child[i].ch = i;
X	uncomp_dict[i][1] = -1;
X
X	comp_dict.child[i].num = i;
X	comp_dict.child[i].child = NULL;
X	comp_dict.child[i].len = 0;
X	comp_dict.child[i].next_node = &comp_dict.child[i+1];
X    }
X    comp_dict.child[255].next_node = (NODE *) 0;
X
X    comp_table_size = 258;
X    uncomp_table_size = 258;
X
X    c_token_bits = 9;
X    c_token_mask = 511;
X    unc_token_bits = 9;
X    unc_token_mask = 511;
X
X#ifdef DEBUG
X    if (!stdprn) stdprn = fopen ("compress.debug", "w");
X    setbuf(stdprn , 0);
X    fprintf(stdprn,"init\n");
X#endif
X    return 1;
X}
X
Xvoid compress_shut (void) {
X#ifdef DEBUG
X    fclose (stdprn);
X#endif
X}
X
X/* gets size bits from starting from bit 'curr' in the bit stream data */
X
Xunsigned int    get_token (un_char *data, int *curr, int max_size) {
X    unsigned long   ret;
X    int     byte,
X            bit,
X            read = 0,
X            tmp;
X    byte = *curr / BYTE_WIDTH_IN;
X    bit = *curr % BYTE_WIDTH_IN;
X    ret = 0;
X    while (read < unc_token_bits && byte < max_size) {
X	ret += ((int)(data[byte++] & BYTE_MASK_IN) >> bit) << read;
X	tmp = BYTE_WIDTH_IN - bit;
X	read += tmp;
X	bit = 0;
X    }
X    ret = ret & unc_token_mask;
X    *curr += unc_token_bits;
X    DEBUG_C(stderr, "%s:c_got: %ld\n", term_server, ret);
X    return (unsigned int) ret;
X}
X
Xvoid put_token (un_char *data, int *curr, unsigned int ch) {
X    int     byte,
X            bit;
X    DEBUG_C(stderr, "%s:c_put: %d\n", term_server, ch);
X    byte = *curr / BYTE_WIDTH_OUT;
X    bit = *curr % BYTE_WIDTH_OUT;
X    ch = ch & c_token_mask;
X    while (ch) {
X	data[byte] |= (ch&BYTE_MASK_OUT) << bit;
X	ch = ch >> (BYTE_WIDTH_OUT - bit);
X	bit = 0;
X	++byte;
X    }
X    *curr += c_token_bits;
X}
X
X/* Add a node to the list of free node's */
XNODE * node_list = NULL;
Xvoid free_node (n)
XNODE * n;
X{
X    n -> next_node = node_list;
X    node_list = n;
X}
X
X/* Take a node of the list of free nodes, creating more nodes if there */
X/* aren't enough to spare.. */
XNODE * get_node (void) {
X    NODE * n;
X    if (!node_list) {
X	n = (NODE *) malloc (sizeof (*n));
X	if (!n) abort();	/* fatal */
X	return n;
X    }
X    n = node_list;
X    node_list = node_list -> next_node;
X    return n;
X}
X
X/* Free this node, and any nodes pointed to by this node. */
Xvoid free_nodes(NODE *t) {
X    if (!t) return;
X    if (t->child) free_nodes(t->child);
X    if (t->next_node) free_nodes(t->next_node);
X    free_node(t);
X    }
X
X/* Clear all nodes larger than 'limit' */
X/* The compression dictionary is a tree , built from a list of lists. */
X /* The tree is a 1-256 tree. (each node can have up to 256 children). */
X /* This is implemented as each node being a list of child pointers. */
X /* Each node has a l for the child node, and an n pointer for the */
X /* next node on this level. */
X
X/* Thus, searching the tree consists of running down the 'n' list */
X /* until the first character is matched, and then following the 'l' */
X /* link. Then running down the 'n' again, and so on. */
Xvoid clear_table (dict, limit)
XNODE * dict;
Xint     limit;
X{
X    NODE * t, *t1, *tmp;
X    /* If we have no dictionary do nothing. */
X    if (!dict)
X	return;
X				/* This is fairly messy. We run across */
X				/* the current node, and build a list */
X				/* of all the nodes we still want. One */
X				/* of the properties of the tree we */
X				/* take advantage of that that all */
X				/* lower nodes are guaranteed to */
X				/* higher token numbers. */
X    tmp = 0;
X    for (t = dict -> child; t;)	/* Run across the current tree node. */
X	if (t -> num > limit) {	/* If this node is too large... */
X	    t1 = t;		/* remember current node, */
X	    t = t->next_node;	/* move loop pointer to next one */
X	    t1->next_node = 0;	/* and free just the one we had. */
X	    free_nodes(t1);
X	    }
X	else {
X	    clear_table (t, limit); /* Ok. Recurse through and look */
X				    /* through the lower levels. */
X	    t1 = t->next_node;	/* Move to next node,  */
X	    t->next_node = tmp;	/* and put the current node on the */
X				/* list of nodes to remember. */
X	    tmp = t;
X	    t = t1;
X	    }
X
X    dict->child = tmp;		/* ok. We built the list, now store it. */
X}
X
Xint     compress (un_char *outpath, int maxlen, int prefix) {
X  int     out_fd = 0;
X  int     suffix;
X  int     max_bytes = 2048;	/* If you have better than 2048:maxlen */
X				/* compression your packet size will be */
X				/* smaller than maxlen. */
X  char    *kludge;
X  NODE * prfix, *pt;
X  int     i,
X  lim;
X  extern int stat_rare_out;
X
X  if ((prefix) < 0)		/* Get a byte if we can. */
X    return 0;			/* we can't, so we managed to compress */
X				/* zero bytes..  */
X
X  ++stat_comp_in;
X  prfix = &comp_dict.child[prefix]; /* Move to right point in dictionary.. */
X  
X  kludge = (char *) outpath;	/* this relies on 4 byte int's */
X  for (i = 0; i < 260; ++i)	/* clear the output buffer (need to do */
X				/* this, as the token out routines use */
X				/* OR'ing). Assumes the buffer can */
X				/* hold 260 characters. Thanks to */
X				/* Janne Sinkkonen for pointing this */
X				/* out. *blush*  */
X    kludge[i] = 0;
X  
X  
X  if (comp_table_size >= DICT_SIZE - 2) { /* if table is full. */
X#if 0
X    fprintf(stderr, "Clearing dict table\n");
X#endif
X    for (i = 0; i < 256; ++i)
X      clear_table (&(comp_dict.child[i]), DICT_CLEAR_2 - 1);
X    comp_table_size = DICT_CLEAR_2;
X    put_token (outpath, &out_fd, 256); /* Clear table. */
X    c_token_mask = 511;
X    c_token_bits = 9;
X  }
X  lim = (maxlen - 4) * BYTE_WIDTH_OUT; /* The maximum number of bits to */
X				/* output. */
X  
X#ifdef DEBUG
X  fprintf(stdprn, "Setting lim to %d\n", lim);
X#endif
X  while (out_fd < lim && max_bytes >= 0) { /* while we have output less then */
X				/* 'lim' bits. */
X    suffix = get_client_byte(); /* get the next byte. */
X    --max_bytes;
X    ++stat_comp_in;
X    ++stat_rare_out;
X
X    DEBUG_C(stderr, "%s:got byte == %d\n", term_server, suffix);
X
X    if (suffix < 0)		/* We has nothing left to compress so exit. */
X      break;
X    suffix &= 255;		/* Make it 8 bits. Not needed */
X				/* theoretically, but.. */
X    for (pt = prfix -> child; pt; pt = pt -> next_node)
X      if (pt -> ch == suffix)
X	break;
X    
X    if (pt) {			/* found */
X#ifdef DEBUG
X      fprintf(stdprn, " found\n");
X#endif
X      prfix = pt;		/* Just remember new prefix. */
X    }
X    else {			/* Ok. We have no token for this */
X				/* sequence, so we make a new token */
X				/* for it. */
X      if (comp_table_size < DICT_SIZE - 1) { /* if the dict isn't */
X					     /* full.. */
X	pt = get_node ();	/* Get a new node.. */
X	pt -> next_node = prfix -> child; /* and put it into tree. */
X	prfix -> child = pt;
X	pt -> ch = suffix;
X	pt -> child = NULL;	/* No child strings. */
X	pt -> num = comp_table_size++; /* Set the token number. */
X      }
X				/* Seeing as we are using explicit */
X				/* signaling to increase the token */
X				/* size, we might as well put it off */
X				/* for as long as we can. */
X      while (prfix->num > c_token_mask) { /* do we need to increase token */
X				/* size?? */
X	put_token(outpath, &out_fd, 257);
X	c_token_mask = (c_token_mask <<1) + 1;
X	c_token_bits ++;
X      }
X
X      put_token (outpath, &out_fd, (unsigned) prfix -> num); /* we output the */
X						  /* token as well. */
X      prfix = &comp_dict.child[suffix]; /* and init prfix to the new value. */
X    }
X  }
X
X  while (prfix->num > c_token_mask) { /* Just in case we need to increase */
X    put_token(outpath, &out_fd, 257); /* the token size. */
X    c_token_mask = (c_token_mask <<1) + 1;
X    c_token_bits ++;
X  }
X  put_token (outpath, &out_fd, (unsigned) prfix -> num); /* Put the last token we */
X					      /* had out. */
X  stat_comp_out += (out_fd+BYTE_WIDTH_OUT - 1) / BYTE_WIDTH_OUT;
X  return out_fd;
X}
X
Xint uncompress(un_char *data, int len, un_char *outpath) {
Xint out_fd = 0, in_fd = 0;
Xstatic int token, oldtoken, newtoken, finaltoken;
Xint size;
Xstatic int started = 0;
X
X#ifdef DEBUG
X	fprintf(stdprn, "Uncompress\n");
X#endif
X	if (uncomp_dict == NULL) return -1;
X	stk_ptr = in_fd = out_fd = 0;
X	size = len * BYTE_WIDTH_IN ;
X	if (!started) {
X	        ASSERT(in_fd == 0);
X		token = get_token(data , &in_fd, len);
X		oldtoken= token;
X		finaltoken = token;
X		outpath[out_fd++]= token;
X#ifdef DEBUG
X		fprintf(stdprn, "[%d]", token);
X#endif
X		}
X
X	if (started == 0) started = 2;
X	else started = 1;
X#ifdef DEBUG
X	fprintf(stdprn, "Uncompress 1\n");
X#endif
X	while (in_fd + unc_token_bits <= size) {
X        	token = get_token(data, &in_fd, len);
X		ASSERT(in_fd <= size);
X#ifdef DEBUG
X	fprintf(stdprn, "new token == %d\n", token);
X#endif
X		if (token == 256) {
X			uncomp_table_size = DICT_CLEAR_2;
X			unc_token_bits = 9;
X			unc_token_mask = 511;
X			continue;
X			}
X		else if (token == 257) { /* increase token size by one bit. */
X			unc_token_bits ++;
X			unc_token_mask <<=1;
X			++unc_token_mask;
X			continue;
X			}
X		newtoken = token;
X
X		if (uncomp_table_size <= newtoken) {
X			stack[stk_ptr ++ ] = finaltoken;
X			ASSERT(stk_ptr > 0);
X			ASSERT(stk_ptr < 1024);
X#ifdef DEBUG
X		fprintf(stdprn, "[%d]", finaltoken);
X#endif
X			token = oldtoken;
X			}
X		while (uncomp_dict[token][1]>=0) {
X		  stack[stk_ptr++] = uncomp_dict[token][1];
X		  ASSERT(stk_ptr < 1024);
X		  ASSERT(stk_ptr > 0);
X		  token = uncomp_dict[token][0];
X		}
X		
X		outpath[out_fd++] = token;
X		ASSERT(out_fd < 2048);
X		ASSERT(out_fd > 0);
X#ifdef DEBUG
X		fprintf(stdprn, "[ %d]", token);
X#endif
X		finaltoken = token;
X		while (stk_ptr) {
X		  outpath[out_fd++] = stack[--stk_ptr];
X		  ASSERT(out_fd < 2048);
X		  ASSERT(out_fd > 0);
X			ASSERT(stk_ptr >= 0);
X#ifdef DEBUG
X			fprintf(stdprn, "[%d]", stack[stk_ptr]);
X#endif
X			}
X		ASSERT(uncomp_table_size < (DICT_SIZE + 1));
X		if (uncomp_table_size <DICT_SIZE) {
X/*		        if (oldtoken == token) abort(); */
X			uncomp_dict[uncomp_table_size][0] = oldtoken;
X			uncomp_dict[uncomp_table_size][1] = token;
X
X
X#ifdef DEBUG
X			fprintf(stdprn, "Adding %d %d to table as %d\n", oldtoken, token, uncomp_table_size);
X#endif
X			if (started ==1 ) started = 2;
X			else ++uncomp_table_size;
X			}
X		oldtoken = newtoken;
X		}
X	return out_fd;
X	}
X
X
END_OF_FILE
  if test 11982 -ne `wc -c <'compress.c'`; then
    echo shar: \"'compress.c'\" unpacked with wrong size!
  fi
  # end of 'compress.c'
fi
if test -f 'configure' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'configure'\"
else
  echo shar: Extracting \"'configure'\" \(11400 characters\)
  sed "s/^X//" >'configure' <<'END_OF_FILE'
X#!/bin/sh
X# Simple configure script for term.  No feature detection is done; we just
X# figure out which OS we are using and modify the Makefile appropriately.
X#
X# The argument parsing and srcdir code are modified Gnu autoconf output.
X# That puts this script under GPL, but there is no configure.in to 
X# distribute along with it; so it goes.
X#
X# Chris Metcalf, June 1994
X# Modified June 1994, bcr@physics.purdue.edu
X
Xprefix=unknown
Xsrcdir=unknown
Xbindir=unknown
Xlibdir=unknown
Xmandir=unknown
Xshlib=unknown
Xsharedir=unknown
Xis_root=unknown
X
X# Figure out how to echo without newline
Xif [ x"`echo -n`" = x-n ]; then
X       echo_n=
X       echo_c='\c'
Xelse
X       echo_n=-n
X       echo_c=
Xfi
X
X
Xfor arg
Xdo
X  # 	Handle arguments with a space
X  if [ x$next_prefix = xyes ] ; then prefix=$arg; next_prefix=
X  elif [ x$next_srcdir = xyes ] ; then srcdir=$arg; next_srcdir=
X  elif [ x$next_mandir = xyes ] ; then mandir=$arg; next_mandir=
X  elif [ x$next_bindir = xyes ] ; then bindir=$arg; next_bindir=
X  elif [ x$next_libdir = xyes ] ; then libdir=$arg; next_libdir=
X  elif [ x$next_sharedir = xyes ] ; then sharedir=$arg; next_sharedir=
X  else
X    case $arg in
X     -prefix=* | --prefix=*)
X	prefix=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -p | -prefix | --prefix)
X	next_prefix=yes ;;
X
X     -srcdir=* | --srcdir=*)
X	srcdir=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -s | -srcdir | --srcdir)
X	next_srcdir=yes ;;
X
X     -mandir=* | --mandir=*)
X	mandir=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -m | -mandir | --mandir)
X	next_mandir=yes ;;
X
X     -bindir=* | --bindir=*)
X	bindir=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -b | -bindir | --bindir)
X	next_bindir=yes ;;
X
X     -libdir=* | --libdir=*)
X	libdir=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -l | -libdir | --libdir)
X	next_libdir=yes ;;
X
X     -sharedir=* | --sharedir=*)
X	sharedir=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -S | -sharedir | --sharedir)
X	next_sharedir=yes ;;
X
X     -u | -user | --user)
X       is_root=no ;;
X
X     -r | -root | --root)
X       is_root=yes ;;
X
X     -h | -usage | --usage | -help | --help)
X       echo 'Usage: configure [<OS Type>] [-user] [-root] [-prefix=/usr/local]'
X       echo '                 [-mandir=$prefix/man/man1] [-bindir=$prefix/bin]'
X       echo '                 [-libdir=$prefix/lib] [-sharedir=$libdir/term]'
X       echo '                 [-shlib] [-static] [-verbose]'
X       echo '                 [-usage]'
X       exit 0 ;;
X
X     -v | -verbose | --verbose)
X       verbose=yes ;;
X
X     -shlib | --shlib)
X       shlib=yes ;;
X
X     -static | --static)
X       shlib=no ;;
X
X     *) OS=$arg ;;
X    esac
X  fi
Xdone
X
X
X# A filename unique to this package, relative to the directory that
X# configure is in, which we can look for to find out if srcdir is correct.
Xunique_file=term_putenv.c
X
X# Find the source files, if location was not specified.
Xif [ "x$srcdir" = xunknown ] ; then
X  srcdirdefaulted=yes
X  # Try the directory containing this script, then `..'.
X  prog=$0
X  confdir=`echo $prog|sed 's%/[^/][^/]*$%%'`
X  [ "X$confdir" = "X$prog" ] && confdir=.
X  srcdir=$confdir
X  if [ ! -r $srcdir/$unique_file -a ! -r "$srcdir/$unique_file",v ]; then
X    srcdir=..
X  fi
Xfi
X
Xif [ ! -r $srcdir/$unique_file -a ! -r "$srcdir/$unique_file",v ] ; then
X  if [ x$srcdirdefaulted = xyes ] ; then
X    echo "configure: Can not find sources in \`${confdir}' or \`..'." 1>&2
X  else
X    echo "configure: Can not find sources in \`${srcdir}'." 1>&2
X  fi
X  exit 1
Xfi
X
X# Preserve a srcdir of `.' to avoid automounter screwups with pwd.
X# But we can't avoid them for `..', to make subdirectories work.
Xcase $srcdir in
X  .|/*|~*) ;;
X  *) srcdir=`cd $srcdir; pwd` ;; # Make relative path absolute.
Xesac
X
X# If you cd and need to find the srcdir
Xabs_srcdir=`cd $srcdir; pwd`
X
Xif [ x$is_root = xunknown ] ; then
X  if [ -w /etc/passwd ] ; then
X    is_root=yes  
X  elif [ x$USER = xroot ] ; then
X    is_root=yes 
X  elif [ x$LOGNAME = xroot ] ; then
X    is_root=yes
X  else 
X    ans=
X    while [ x$ans != xy -a x$ans != xn ] ; do  
X      echo $echo_n "Can you install as root? (y/n) $echo_c"
X      read ans
X    done
X    if [ x$ans = xy ] ; then
X      is_root=yes
X    else
X      is_root=no
X    fi
X  fi
Xfi
X  
Xif [ x$is_root = xyes ] ; then
X  setid=g+s
X  if [ x$prefix = xunknown ] ; then prefix=/usr/local ; fi
X  if [ x$libdir = xunknown ] ; then libdir=$prefix/lib ; fi
X  if [ x$sharedir = xunknown ] ; then sharedir=$libdir/term ; fi
Xelse
X  setid=u+s
X  if [ x$prefix = xunknown ] ; then prefix=$HOME ; fi
X  if [ x$sharedir = xunknown ] ; then sharedir=$prefix/term ; fi
X  if [ x$libdir = xunknown ] ; then libdir=$prefix/term ; fi
Xfi
Xif [ x$bindir = xunknown ] ; then bindir=$prefix/bin ; fi
Xif [ x$mandir = xunknown ] ; then mandir=$prefix/man/man1 ; fi
X
XCC='gcc -Wall'
XCPP='$(CC) -E'
XDEBUGFLAGS='-O'
Xif [ -f /usr/bin/ranlib -o -f /bin/ranlib -o -f /usr/ucb/ranlib ]; then
X  AR='ar rc'
X  RANLIB='ranlib'
Xelse
X  AR='ar rcs'
X  RANLIB='echo'
Xfi
X
X# If no OS type provided yet, try to guess
X
X# Probably the best thing to check is uname, so we try that first.	
Xif [ "x$OS" = x -a \( -f /bin/uname -o -f /usr/bin/uname \) ]; then
X	OS=`uname` 
Xfi
X# Next we will try arch.
Xif [ "x$OS" = x -a \( -f /bin/arch -o -f /usr/bin/arch \) ]; then
X	OS=`arch`
Xfi
X# What about bash, if we're running it?
Xif [ "x$OS" = x -a x$HOSTTYPE != x ]; then
X	OS=$HOSTTYPE
Xfi
X# Or running bash, if we're not running it?
Xif [ "x$OS" = x -a \( -f /bin/bash -o -f /usr/bin/bash \) ]; then
X	OS=`bash -c 'echo $HOSTTYPE'` 
Xfi
X# Finally we can try "tcsh".
Xif [ "x$OS" = x -a \( -f /bin/tcsh -o -f /usr/bin/tcsh \) ]; then
X	OS=`tcsh -c 'echo $HOSTTYPE'` 
Xfi
X# OK, try filesystem-specific things.
Xif [ "x$OS" = x -a -d /NextApps ]; then
X	OS=next
Xfi
X# Give up
Xif [ "x$OS" = x ]; then
X	echo "Can't guess OS; use 'configure os-name'" >&2
X	exit 1
Xfi
X
X# Normalize the OS type
X#
Xcase "$OS" in
XLinux | i386-linux)	OS=linux ;;
XTitanOS)	OS=titan ;;
XNetBSD)		OS=netbsd ;;
XSunOS)		case `uname -r` in
X		4.*)	OS=sun ;;
X		5.*)	OS=sol2 ;;
X		*)	echo "Unknown Sun OS release!" >&2; exit 1 ;;
X		esac ;;
Xsol21)          OS=sol2 ;;      # compatibility with older term releases
XULTRIX)		OS=ultrix ;;
XIRIX)		OS=irix ;;
XNeXT)		OS=next ;;
XCX/UX)		OS=hcx ;;
Xaix370 | aixESA | rtpc | AIX)	OS=aix ;;
Xbsd386)		OS=bsdi ;;
Xsco386)		OS=sco ;;
Xvistra800)	OS=svr4 ;;
Xptx)		OS=dynixptx ;;
Xiris3d | iris4d)	OS=sgi ;;
XOSF1)		OS=osf1 ;;
Xm68k)           if [ "x$MACHTEN" != x ]; then OS=machten; fi ;;
XConvexOS)	OS=convex ;;
XHP-UX)		OS=hpux ;;
XISC)            OS=isc ;;
X
Xesac
X
X# set OS specific options
X#
Xcase $OS in
X
Xsgi | convex | mips)	;;
X
Xosf1)		CC="gcc -Wall -Wno-implicit" ;;
X
Xlinux)		if [ $shlib = unknown ]; then shlib=$is_root; fi
X		if [ $shlib = yes ]; then 
X			if [ -x /usr/bin/jumpas ]; then
X				DLLAS=jumpas
X				DLLBIN=
X			elif [ -x /usr/dll/jump/as ]; then
X				DLLAS=/usr/dll/jump/as
X				DLLBIN=/usr/dll/bin/
X			else
X				echo "You need dll tools 2.11 or greater for"
X				echo "dynamic libraries.  Using static instead."
X				shlib=no
X			fi
X		fi
X		if [ $shlib = yes ]; then
X		  ARCH_VARS="-e 's,@dllas@,$DLLAS,' -e 's,@dllbin@,$DLLBIN,'"
X		fi ;;
X
Xmachten)	CC="gcc" ;;
X
Xbsdi)		CPP="cc -E" CC=cc
X		OSFLAGS="-funsigned-char -DBSDI" ;;
X
Xtitan) 		CC="cc -43" ;;
X
Xaix)		OSFLAGS="-D_BSD" OSLINK="-lbsd" CC="xlc -D_ALL_SOURCE" ;;
X
Xnetbsd)		if [ $shlib = unknown ]; then shlib=yes; fi ;;
X
Xsun)		CC="gcc -Wall -Wno-implicit"
X		if [ $shlib = unknown ]; then shlib=yes; fi ;;
X
Xsol2)		OSFLAGS="-DSVR4" LIBS="-lsocket -lnsl" ;;
X
Xultrix)		CC="gcc -Wall -Wno-implicit -Dultrix" ;;
X
Xirix)		OSFLAGS="-DIRIX" ;;
X
Xnext)		CPP="cc -E" CC=cc OSFLAGS="-funsigned-char" ;;
X
X# if this doesn't work try c89 instead of cc.
Xhpux)		CC="cc -Aa" OSLINK=" -s" OSFLAGS="-D_HPUX_SOURCE" ;;
X
Xisc)            CC="gcc -posix" DEBUGFLAGS="-g" OSFLAGS="-DISC -DNO_UNIX_DOMAIN -DSVR3 -D_SYSV3"
X		LIBS="-linet -lpt -lcposix " ;;
X
Xsvr4)		OSFLAGS="-funsigned-char -m486 -DSVR4" LIBS="-lsocket -lnsl" ;;
X
Xsco)		OSFLAGS="-DSCO -DSVR3 -DNO_UNIX_DOMAIN"
X		LIBS="-lsocket -lpt" CC=cc DEBUGFLAGS=-g ;;
X
Xdynixptx)	CC="cc -DDYNIXPTX" CPP="cc -E" 
X		LIBS="-lsocket -linet -lnsl -lseq" ;;
X
X# The HCX/UX 5.1 cc does not understand ANSI C.  To convert the term source
X# to K&R on the fly, "unproto" must be compiled and the generated "cpp" 
X# binary placed in some directory, specified below with UNPROTO.  This lets the 
X# hcx cc be passed de-ANSIfied C code.  "unproto" can be found in archives 
X# for comp.sources.misc, volume 27, issue 85.
X#
Xhcx)		if [ "x$UNPROTO" = x ]; then
X		  UNPROTO=/path/to/unproto/dir
X	        fi
X	        if [ ! -f "$UNPROTO"/cpp ]; then
X	          echo "hcx: can't find $UNPROTO/cpp.  Please either edit" >&2
X	          echo " configure or setenv UNPROTO before running it." >&2
X	          exit 1
X	  	fi
X		CC="cc -B$UNPROTO/ -tp"
X		CPP=$UNPROTO/cpp ;;
X
X*)		echo "Couldn't find rules for $OS; try 'configure os-name'"
X		exit 1 ;;
X
Xesac
X
Xif [ $is_root = no ] ; then
X	who_prefix='!root'
Xelse
X	who_prefix='root'
Xfi
X
Xif [ $shlib = yes ]; then
X	lib_prefix='shlib'
X	install_shlib=install-shlib
X	if [ -f /usr/sbin/ldconfig ]; then
X		ldconfig=/usr/sbin/ldconfig
X	elif [ -f /usr/etc/ldconfig ]; then
X		ldconfig=/usr/etc/ldconfig
X	elif [ -f /usr/bin/ldconfig ]; then
X		ldconfig=/usr/bin/ldconfig
X	elif [ -f /sbin/ldconfig ]; then
X		ldconfig=/sbin/ldconfig
X	elif [ -f /etc/ldconfig ]; then
X		ldconfig=/etc/ldconfig
X	elif [ -f /bin/ldconfig ]; then
X		ldconfig=/bin/ldconfig
X	else
X		echo "Can't find ldconfig."
X		echo "ldconfig must be in root's PATH at install time."
X		ldconfig=ldconfig
X	fi
Xelse
X	lib_prefix='static'
X	install_shlib=
X	ldconfig=this_should_never_be_used
X	if [ $is_root = no ] ; then
X		CC="$CC -DONE_CLIENT"
X	fi
Xfi
X
Xrm -f config.status
Xecho "#!/bin/sh" > config.status
Xcat >> config.status << FOO
Xrm -f Makefile
Xif [ ! -f $srcdir/Makefile.in ] ; then
X  co $srcdir/Makefile.in
Xfi
X
Xeval \`sed -n -e 's/  *//g' -e '/^VERSION_MAJOR=/p' -e '/^VERSION_MINOR=/p' \\
X    -e '/^PATCH_LEVEL=/p' $srcdir/Makefile.in\`
XVERSION_MINOR=\`expr \( \$VERSION_MINOR + 100 \) : '.\(..\)'\`
XPATCH_LEVEL=\`expr \( \$PATCH_LEVEL + 100 \) : '.\(..\)'\`
XVERSION_NUM=\$VERSION_MAJOR\$VERSION_MINOR\$PATCH_LEVEL
X
Xsed -e "s,@version_num@,\$VERSION_NUM," \\
X    -e 's,@srcdir@,$srcdir,' \\
X    -e 's,@abs_srcdir@,$abs_srcdir,' \\
X    -e 's,@cc@,$CC,' \\
X    -e 's,@cpp@,$CPP,' \\
X    -e 's,@ar@,$AR,' \\
X    -e 's,@OS@,$OS,' \\
X    -e 's,@ranlib@,$RANLIB,' \\
X    -e 's,@setid@,$setid,' \\
X    -e 's,@libs@,$LIBS,' \\
X    -e 's,@osflags@,$OSFLAGS,' \\
X    -e 's,@libdir@,$libdir,' \\
X    -e 's,@debugflags@,$DEBUGFLAGS,' \\
X    -e 's,@linkflags@,$LINKFLAGS,' \\
X    -e 's,@oslink@,$OSLINK,' \\
X    -e 's,@bindir@,$bindir,' \\
X    -e 's,@mandir@,$mandir,' \\
X    -e 's,@sharedir@,$sharedir,' \\
X    -e 's,@ldconfig@,$ldconfig,' \\
X    -e 's,@install_shlib@,$install_shlib,' \\
X    -e 's,^# *if  *$who_prefix *,,' \\
X    -e 's,^# *if  *$lib_prefix=$OS *,,' \\
X    -e 's,^# *if  *$lib_prefix=any *,,' \\
X    -e 's,^# *if  *$who_prefix *,,' \\
X    $ARCH_VARS \\
X    -e 's,^ *$,,' \\
X    -e '/^# *if /d' \\
X    < $srcdir/Makefile.in > Makefile
XFOO
Xchmod +x config.status
X./config.status
X
Xecho "term configured to build on $OS and install in $prefix"
X
Xif [ $shlib = no ]; then
X	echo "use of dynamic term libraries suppressed"
Xfi
X
Xif [ $shlib = yes ]; then
X	cat << FOO
X
X  Note that if you want to test the binaries before doing a full
X  install, you may need to run "make install-shlib" first as root
X  so that they are able to find the correct dynamic libraries.
X
XFOO
Xfi
END_OF_FILE
  if test 11400 -ne `wc -c <'configure'`; then
    echo shar: \"'configure'\" unpacked with wrong size!
  fi
  # end of 'configure'
fi
if test -f 'download.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'download.c'\"
else
  echo shar: Extracting \"'download.c'\" \(13433 characters\)
  sed "s/^X//" >'download.c' <<'END_OF_FILE'
X/*
X * A client for term. Taken from upload.c sources by Chris Metcalf
X * (metcalf@lcs.mit.edu).
X */
X
X#define I_IOCTL
X#define I_STRING
X#define I_STAT
X#define I_TIME
X#define I_UTIME
X#define I_TYPES
X#define DEBUG
X
X#include "includes.h"
X#include "client.h"
X
X#ifdef ONE_CLIENT
X# define main tdownload
X#else
Xint term_debug = 0;
X#endif
Xint download_force = 0;
X
Xint download_unlinkmode = 0;
Xint download_literal_filename = 0;
X
Xstruct stat st;
X
X/*---------------------------------------------------------------------------*/
X
Xstatic int local_options ( char opt, char *optarg )
X{
X  switch(opt)
X  {
X  case 'f' :
X    download_force = 1;
X    break;
X  case 'q' :
X    verbose = 0;
X    break;
X  case 'u':
X    download_unlinkmode = 1;
X    break;
X  case 'l':
X    download_literal_filename = 1;
X    break;
X  default:
X    return -1;
X  }
X  return 0;
X}
X/*---------------------------------------------------------------------------*/
X
X#define CPS_WINDOW 10		/* about ten seconds */
X
Xdouble download_delta_timeval(struct timeval *a, struct timeval *b)
X{
X  return (a->tv_sec + a->tv_usec/1000000.0) - 
X         (b->tv_sec + b->tv_usec/1000000.0);
X}
X
Xint main(int argc, char *argv[])
X{
X				/* From client.c */
X  extern int lcompression, rcompression;
X				/* locals for upload. */
X  struct Buffer buffer;
X  char *cutpath, *file, *local, path[255], filename[255];
X  int term, fd, first, i;
X  int filesent, j=0;
X  long ret, remote_size, local_size;
X  long bytesrecvd, total_bytesrecvd;
X  long atime, mtime;
X  double cps = 0;
X  struct timeval total_starttime, total_stoptime, starttime, lasttime, nowtime;
X  double etime;
X  double recent_cpsbytes[CPS_WINDOW], recent_etime[CPS_WINDOW];
X  int cps_count, read_size;
X  int bufsiz = BUFSIZ;
X  int type, perms;
X  struct utimbuf utb;
X  char *remote_unlink = NULL;
X
X  term = -1;
X  fd = -1;
X  first = -1;
X  priority = -5; /* The scale is -20 to 20 with higher being better */
X  verbose = 1;
X  bytesrecvd = 0;
X  total_bytesrecvd = 0;
X  gettime(&total_starttime);
X  filesent = 0;
X  path[0] = '\0';
X  lcompression = rcompression = 0;
X  buffer.start = buffer.end = buffer.size = buffer.alloced = 0;
X  buffer.data = NULL;
X  
X  /* Handle the options. We use the standard client argument handling */
X  /* to do this. Options peculiar to upload are 'f' for force, q for */
X  /* quiet, and v for verbose, u for unlink */
X  if ( ((first = client_options(argc,argv,"fquvl",local_options)) == -1)
X      || (first >= argc) ) {
X    fprintf(stderr, 
X	    "Usage: download [-f] [-q] [-u] [-v] [-r] [-c] [-p <num>] <file>"
X	    " [... <file>] [local dir]\n"); 
X    exit(1);
X  }
X
X  use_term_command(PRIVILEGED);
X
X				/* Make sure the buffer is non-zero in */
X				/* size. */
X  add_to_buffer(&buffer, 0);
X  get_from_buffer(&buffer);
X
X  /* check the last arg to see if it's a dir, and if so,  */
X  /* that's where we put the received files. */
X  if (first < argc && stat(argv[argc-1], &st) == 0 && S_ISDIR(st.st_mode)) {
X    strcpy(path, argv[--argc]);
X    if ( ! (i = strlen(path))) {
X      fprintf(stderr, "\tFatal. Zero length path passed.\n");
X      exit(1);
X    }
X    if ( path[i - 1] != '/' ) {
X      path[i] = '/';
X      path[i+1] = '\0';
X    }
X  }
X
X  /* should check here for a file to send.  enforce command line. */
X  /*   or, maybe no args should mean take from stdin. */
X  /*   but then, what's the output file name? -q */
X
X  while ( first < argc ) {
X
X    /* reopen term connection for next file */
X    if (term >= 0)
X      close(term);
X    if ((term = socket_connect_server(-1, term_server)) < 0) {
X      fprintf(stderr,"Term: %s\n", command_result);
X      exit(1);
X    }
X
X    /* close the output file if it was left open (it shouldn't be) */
X    if (fd > 0) {
X      close(fd);
X      fd = -1;
X    }
X
X    /* delete the last file if it was transferred successfully */
X    if (remote_unlink) {
X      if (send_command(term, C_UNLINK, 0, "%s", remote_unlink) < 0) {
X        fprintf(stderr,"\tUnable to remove sent file\n");
X        j=1;
X      } else
X        fprintf(stderr,"\tSent file removed.\n");
X      remote_unlink = NULL;
X    }
X
X    /* get the filename to receive.*/
X    file = argv[first++];
X
X    if ( (first+1 < argc) && (strcmp(argv[first],"-as") == 0) ) {
X      local = argv[first+1];
X      first += 2;
X    }
X    else {
X      /* leave the filename alone */
X      local = file;
X      
X      /* remove the pathname for the outgoing file */
X      if (!download_literal_filename) {
X          for ( cutpath = local; *cutpath; cutpath++ )
X              if ( ( *cutpath == '/' ) && ( *(cutpath+1) ) )
X                  local = cutpath + 1;
X      }
X    }
X    
X    /* prepend the specified path, if there is one. */
X    if ( *path ) {
X      strcpy(filename, path);
X      strcat(filename, local);
X      local = filename;
X    }
X
X    if ( verbose > 0 )
X      if ( file == local )
X	fprintf(stderr, "receiving %s\n",file);
X      else
X	fprintf(stderr, "receiving %s as %s\n", file, local );
X    
X    /* use stdout if requested */
X    fd = -1;
X    if ( !strcmp(local, "-") ) 
X      fd = 1;
X
X    /* get some info on the remote file. We need to know the file */
X    /* size at the very least. */
X    remote_size = 0;
X    if (send_command(term, C_STAT, 0, "%s", file) >= 0) {
X      if (sscanf(command_result, "%ld %d", &remote_size, &type) < 2) {
X	   fprintf(stderr, "\tSkipped : can't stat %s: %s\n", file,
X		command_result);
X	   j=1;
X	   continue;
X      }
X      if (type != 0) {
X	   fprintf(stderr, "\tSkipped : %s is not a regular file\n", file);
X	   j=1;
X	   continue;
X      }
X    }else {
X      fprintf(stderr, "\tSkipped : can't open remote file\n");
X      j=1;
X      continue;
X    }
X
X    /* see if the file exists to be resumed (but don't resume to stdout,
X       even if it's pointing to a file). */
X    local_size = 0;
X    if (fd != 1) {
X      if (stat(local, &st) == 0) {
X        if (download_force) {
X          /* Try to make sure we can download to the file.  If we can */
X          /* chmod it, we are certain to succeed.  If not, perhaps we have */
X          /* write access as group or other; try to truncate.  If that */
X          /* fails too, unlink it, and hope we can create a new file below. */
X          if (chmod(local, 0600) != 0)
X            if ((fd = open(local, O_WRONLY|O_TRUNC)) > 0)
X              close(fd);
X            else
X              (void) unlink(local);
X          fprintf(stderr, "\tWarning, overwriting file\n");
X        }
X        else {
X          if (st.st_mode & 0777) {
X            fprintf(stderr, "\tSkipping, local file is not mode 0\n");
X            j=1;
X            continue;
X          }
X          if (chmod(local, 0600)) {
X            fprintf(stderr, "\tSkipping, can't change file mode to 0600\n");
X            j=1;
X            continue;
X          }
X          local_size = st.st_size;
X          if (local_size == remote_size) {
X	    fprintf(stderr,"\tSkipping, local file is same size as remote\n");
X	    continue;
X	  }
X	  
X	  /* local file is larger than remote file. Skip this as well.*/ 
X	  if (local_size > remote_size) {
X	    fprintf(stderr,"\tSkipping, local file is larger than remote\n");
X            j=1;
X	    continue;
X	  }
X
X	  fprintf(stderr, "\tAttempting to restart download from %ld\n",
X		  local_size);
X        }
X      }
X    }
X
X    if (fd != 1) {
X      if (local_size == 0) 
X        fd = open(local, O_WRONLY|O_CREAT|O_TRUNC, 0666);
X      else
X        fd = open(local, O_WRONLY|O_APPEND, 0666);
X      if (chmod(local, 0)) {
X        fprintf(stderr, "\tSkipped : can't change local file mode to 0\n");
X        j=1;
X        continue;
X      }
X    }
X    if (fd < 0) {
X      fprintf(stderr, "\tSkipped : can't open local file\n");
X      j=1;
X      continue;
X    }
X
X    /* get some info on the remote file. We need to know the file */
X    /* size at the very least. */
X    remote_size = 0;
X    if (send_command(term, C_DOWNLOAD, 0, "%ld\n%s", local_size, file) < 0) {
X      fprintf(stderr,"\tSkipped : Couldn't open remote file, %s\n",
X		command_result);
X      j=1;
X      continue;
X    }else {
X      long now;
X      now = time(NULL);
X      atime = mtime = 0;
X      perms = -1;
X      if (sscanf(command_result, "%ld %d %*d %ld %ld %o", &remote_size,
X		&type, &atime, &mtime, &perms) < 2) {
X	   fprintf(stderr, "\tSkipped : can't stat %s: %s\n", file,
X		command_result);
X	   j=1;
X           send_command(term, C_CLOSE, 0, 0);
X	   continue;
X      }
X      atime += (long)now;
X      mtime += (long)now;
X    }
X
X    /* receive the file over the socket. */
X    if (verbose > 1) {
X      gettime(&starttime);
X      lasttime = starttime;
X    }
X    bytesrecvd = 0;
X    cps_count = 0;
X    for (i = 0; i < CPS_WINDOW; ++i) {
X      recent_cpsbytes[i] = 0;
X      recent_etime[i] = 0;
X    }
X    filesent++;
X    if (verbose > 2) {
X      if (remote_size)
X        fprintf(stderr, "\r\t%ld of %ld (0%%)   ", local_size, remote_size);
X      else
X        fprintf(stderr, "\r\t%ld  ", local_size);
X    }
X    do {
X      read_size = bufsiz;
X      if (verbose > 2 && (local_size%bufsiz))	/* after restarting download */
X        read_size = bufsiz - (local_size%bufsiz);
X      if (read_size > remote_size-local_size)	/* at end of file */
X        read_size = remote_size-local_size;
X      if (buffer.size < read_size) {
X	ret = (long)(read_into_buff(term, &buffer, read_size-buffer.size)); 
X	if (ret < 0) break;
X	if (ret > 0 && buffer.size < read_size) continue;
X      }
X      if (buffer.size == 0)
X        break;
X      else {
X	ret = (long) write_from_buff(fd, &buffer, 0);
X	if (ret <= 0 && termerrno) {
X	  fprintf(stderr, "\tError writing to file. Aborting..\n");
X	  break;
X        }
X
X	bytesrecvd += ret;
X	total_bytesrecvd += ret;
X	local_size += ret;
X      }
X
X      if ( (verbose > 2)) {
X
X	/* Each CPS value is placed in a
X	   CPS_WINDOW-sized buffer and the average of the buffer is
X	   used as the CPS value.  */
X
X	gettime(&nowtime);
X	etime = download_delta_timeval(&nowtime, &lasttime);
X
X        lasttime = nowtime;
X	recent_cpsbytes[cps_count] = ret;
X	recent_etime[cps_count] = etime;
X	if (++cps_count >= CPS_WINDOW)
X	  cps_count = 0;
X        for (i = 0, cps = 0, etime = 0; i < CPS_WINDOW; ++i) {
X          cps += recent_cpsbytes[i];
X          etime += recent_etime[i];
X        }
X        if (etime > 0)
X          cps /= etime;
X        else
X          cps = 0;
X
X        /* Adjust bufsiz so we see about one report per second */
X        while (bufsiz < cps/2 && local_size%(2*bufsiz) == 0)
X          bufsiz *= 2;
X        while (bufsiz > cps*2)
X          bufsiz /= 2;
X
X	if (remote_size) {
X          long perc;
X
X	  perc = (local_size*100) / remote_size;
X	  if (cps)
X	    fprintf(stderr, "\r\t%ld of %ld (%ld%%), current CPS %.0f. ETA: %.1f TT: %.1f   ",
X	          local_size, remote_size, perc, 
X	          cps, (remote_size-local_size)/cps, 
X	          remote_size/cps);
X	  else
X	    fprintf(stderr, "\r\t%ld of %ld (%ld%%)   ", 
X	          local_size, remote_size, perc);
X	}
X	else {
X	  if (cps)
X	    fprintf(stderr, "\r\t%ld, current CPS %.0f. ", local_size, cps );
X	  else
X	    fprintf(stderr, "\r\t%ld  ", local_size);
X        }
X      }
X    } while (local_size < remote_size); 
X
X    /* close the file */
X    if (fd != 1) {
X      close(fd);
X      fd = -1;
X    }
X
X    /* give them cps ratings */
X    if (verbose > 1) {
X      gettime(&nowtime);
X      etime = download_delta_timeval(&nowtime, &starttime);
X      if (etime == 0)
X        etime = 0.01;	/* VERY uncommon with gettimeofday() */
X      if ( verbose > 2)
X	fprintf(stderr, "\r");
X      fprintf(stderr, "\t%ld bytes received in %.1f seconds; overall CPS = %.0f           \n",
X	      bytesrecvd, etime, bytesrecvd/etime );
X    }
X
X    /* check the remote file after send */
X    if (fd == 1) {
X      if (bytesrecvd == remote_size) {
X	if (download_unlinkmode)
X	  remote_unlink = file;
X      } else {
X        fprintf(stderr,
X         	"\tCount of bytes received is different from remote size!\n");
X        j=1;
X      }
X    } else {
X      int err = 0;
X      if (stat(local, &st)) {
X        fprintf(stderr, "\tCan't stat local file after download!\n");
X        err=j=1;
X      }
X      if (st.st_size != remote_size) {
X        fprintf(stderr, "\tLocal file is a different size from remote after"
X	    " download!\n");
X        err=j=1;
X      }
X      utb.actime = atime;
X      utb.modtime = mtime;
X      if (utime(local, &utb)) {
X        fprintf(stderr, "\tCan't set correct times on file after download!\n");
X        err=j=1;
X      }
X      if (perms != -1 && chmod(local, perms)) {
X        fprintf(stderr, "\tCan't set permission on file after download!\n");
X        err=j=1;
X      }
X      if (!err && download_unlinkmode)
X        remote_unlink = file;
X    }
X  }
X
X  /* delete the last file if it was transferred successfully... painful */
X  if (remote_unlink) {
X    /* reopen term connection to do deletion */
X    if (term >= 0)
X      close(term);
X    if ((term = socket_connect_server(-1, term_server)) < 0) {
X      fprintf(stderr,"Term: %s\n", command_result);
X      exit(1);
X    }
X    if (send_command(term, C_UNLINK, 0, "%s", remote_unlink) < 0) {
X      fprintf(stderr,"\tUnable to remove sent file\n");
X      j=1;
X    } else
X      fprintf(stderr,"\tSent file removed.\n");
X    remote_unlink = NULL;
X  }
X
X  /* give them global cps rating */
X  if ( (verbose > 1) && (filesent > 1) ) {
X    gettime(&total_stoptime);
X    etime = download_delta_timeval(&total_stoptime, &total_starttime);
X    if (etime == 0)
X      etime = 0.01;
X    fprintf(stderr, "%ld total bytes received in %.1f seconds; overall CPS %.0f\n",
X      total_bytesrecvd, etime, cps); 
X  }
X
X  exit(j);
X}
END_OF_FILE
  if test 13433 -ne `wc -c <'download.c'`; then
    echo shar: \"'download.c'\" unpacked with wrong size!
  fi
  # end of 'download.c'
fi
if test -f 'jump/size.nm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jump/size.nm'\"
else
  echo shar: Extracting \"'jump/size.nm'\" \(505 characters\)
  sed "s/^X//" >'jump/size.nm' <<'END_OF_FILE'
X00000000 T _share
X00000004 T _termerrno
X00000008 T _com_result
X00000408 T _command_result
X0000040c T _lcompression
X00000410 T _priority
X00000414 T _rcompression
X00000418 T _remote_term_version
X0000041c T _savedeid
X00000420 T _term_server
X00000424 T _term_optarg
X00000428 T _term_opterr
X0000042c T _term_optind
X00000430 T _term_optopt
X00000434 T _term_debug
X00000438 T _term_localaddr
X0000043c T _term_remoteaddr
X00000440 T _term_localhost
X00000540 T _term_remotehost
X00000640 T _verbose
X00000644 T __done
END_OF_FILE
  if test 505 -ne `wc -c <'jump/size.nm'`; then
    echo shar: \"'jump/size.nm'\" unpacked with wrong size!
  fi
  # end of 'jump/size.nm'
fi
if test -f 'linecheck.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'linecheck.c'\"
else
  echo shar: Extracting \"'linecheck.c'\" \(8800 characters\)
  sed "s/^X//" >'linecheck.c' <<'END_OF_FILE'
X#define I_STRING
X#define I_CTYPE
X#define I_SIGNAL
X#include "includes.h"
X
X#include "terminal.h"
X
X/*
X initially written by Michael O'Reilly
X rewritten by jeff grills (jefftep@cs.utexas.edu)
X
X to use, run remotely like:   linecheck remote.out
X             locally:         linecheck stderr < /dev/modem > /dev/modem
X
X linecheck's first argument must be the name of a file to write the information
X into.  if you specify "stderr," then the output is written to the standard error
X stream, as normal.  this is what you prefer to do on your local machine so you can
X watch it work.  on the remote machine, you need to specify a file to record this
X information in.
X
X you can tell linecheck not to test certain chars by listing their decimal number
X on the command line.  for instance, if you know flow-control will get eaten,
X you can use "linecheck stderr 17 19", and it won't test those chars.  this is also
X useful for testing a set of escape sequences, to make sure it makes your line
X clean.
X
X if it says something needs escaped, that means it didn't get through okay
X this time. if you get an invalid packet printed, it means the packet wasn't
X sent by the linecheck on the other side, and may either be line static,
X or some very braindead terminal response to a (possibly series) of characters
X to what was printed over the line.  in this case, it's your responsibility
X to determine which, and escape the previously sent char if needed.  There is
X no way this program can identity a braindead terminal server from line static,
X so this is the way it has to be.
X
X if, for some reason, you get stuck out in lala land, and can't kill the program,
X try typing "00000".  That should kill it, and restore your terminal.
X
X It'll print "### sending char" and "### received valid".  Don't worry if these
X two number are out of sync.  That's fine.  Just worry, on either side, if you
X get some "Invalid packet: " lines.  Look at them closely, and see if it's line
X static, or a real problem.
X
X At the end, it'll print out a summary of what it thinks you should escape.
X This just means these chars didn't get received correctly this time.  Again,
X if line static munched something, some of these may be valid. 
X
X *** IF *** your terminal server generates extra responses for odd chars,
X then you may not be told to escape something, but need to anyway.  This will
X be evident from a "Invalid packet: " on the local side, after attempting to
X send a character.  Again, it may be line static. You have to make the call.
X
X if you're running it locally in a xterm, I suggest you turn on window logging.
X
X if you have problems with this program, and want me to look at it, mail me
X *both* the local and remote output, and label them appropriately.
X*/
X
X/* -------------------------------------------------- */
X
X#define START_AT 0
X#define STOP_AT  256
X
X#define START      'A'
X#define STOP       'B'
X#define END_PACKET 'C'
X#define XON        '\021'
X#define DONE       "done"
X#define RDONE      "rdone"
X#define SLEEP      1
X#define TRIES      1
X#define BUMS       1
X
X#define BUFFSIZE  200
X
X/* -------------------------------------------------- */
X
Xunsigned char buff[BUFFSIZE];
X
Xint valid[STOP_AT+1], skip[STOP_AT], pid, debugging;
X
X/* -------------------------------------------------- */
X
Xvoid sig_int(int x) {
X	if (pid)
X		kill(pid, SIGINT);
X	exit(-1);
X}
X
X/* -------------------------------------------------- */
X
Xvoid debug(unsigned char *s)
X{
X  while (*s) {
X		/* boy, there are some screwed up isprint()s out there */
X    if ( isprint(*s) && (*s < 128) )
X      fprintf(stderr, "%c", *(s++));
X    else      
X      fprintf(stderr, "<%d>", (int) *(s++));
X  }
X  fprintf(stderr, "\n");
X}
X
X/* -------------------------------------------------- */
X
Xint mgets(unsigned char *buff, int len)
X{
X  unsigned char ch;
X  int i, zcount;
X  
X  i = 0;
X  zcount = 0;
X  
X  while(1) {
X		read(STDIN_FILENO, &ch, 1);
X
X		/* check if we get five 0's and abort */
X		if ( ch == '0' ) {
X			if (++zcount == 5) {
X				kill(pid, SIGINT);
X				terminal_restore(0);
X				exit(0);
X			}
X		}
X		else
X			zcount = 0;
X		
X		/* handle next char */
X		if (ch == '\n')
X
X			/* check if this is really inside the packet */
X			if ( (i == 4) && (buff[0] == '1') && (buff[1] == '0') && (buff[2] == ' ') &&
X					(buff[3] == START) )
X				buff[i++] = ch;
X			else {
X				buff[i] = '\0';
X				return i;
X			}
X
X		else {
X			/* store this char in the buffer */
X			buff[i++] = ch;
X			
X			/* don't let packet overflow */
X			if ( (i+1) == len) {
X			  buff[i] = '\0';
X				return i;
X			}
X		}
X	}
X}
X
X/* -------------------------------------------------- */
X
Xvoid handshake()
X{
X  int i;
X
X	fprintf(stderr, "Handshaking\n");
X
X	printf("\n%c\n", START);
X	i = 0;
X	while ( ! i ) { 
X		mgets(buff, BUFFSIZE);
X
X		if ( (buff[0] == START) && (buff[1] == '\0') ) {
X			i = 1;
X			printf("\n%c\n", STOP);
X		}
X		else
X			if ( (buff[0] == STOP) && (buff[1] == '\0') )
X				i = 1;
X			else
X				if (buff[0] != '\0' ) { 
X					fprintf(stderr, "unexpected packet: ");
X					debug(buff);
X				}
X	}
X	
X	fprintf(stderr, "Handshaking successful\n");
X}
X
X/* -------------------------------------------------- */
X
Xvoid skipchars(char **s)
X{
X	while(*s) {
X		skip[atoi(*(s++))] = 1;
X	}
X}
X
X/* -------------------------------------------------- */
X
Xvoid bum(char *s)
X{
X  int i;
X	for (i=0; i<BUMS; i++) { 
X		if ( s == NULL )
X			printf("\n");
X		else
X			printf("\n%s\n", s);
X		sleep(SLEEP);
X	}
X}
X
X/* -------------------------------------------------- */
X
Xvoid check(unsigned char *s)
X{
X  int k;
X  unsigned char *t;
X  t = s;
X
X	if (debugging) {
X		fprintf(stderr, "incoming packet: ");
X		debug(t);
X	}
X
X	/* convert int to number */
X	k = 0;
X	while ( isdigit(*s) )
X		k = (k * 10) + (*(s++) - '0');
X
X	/* verify this is a valid packet */
X	if ( (s[0] == ' ') && (s[1] == START) && (s[2] == (unsigned char)k) && (s[3] == STOP) ) {
X		fprintf(stderr, "%3d received valid\n", k);
X		valid[k] = 1;
X	}
X	else {
X		if (debugging)
X			fprintf(stderr, "was invalid packet\n");
X		else {
X			fprintf(stderr, "invalid packet: ");
X			debug(t);
X		}
X	}
X}
X
X/* -------------------------------------------------- */
X
Xvoid do_reads()
X{
X	int ldone, rdone;
X
X	ldone = 0;
X	rdone = 0;
X
X	while ( (!ldone) || (!rdone) ) {
X
X		/* get a non-empty line */
X		while( !mgets(buff, BUFFSIZE) );
X		
X		/* see if they are done sending test packets */
X		if (strcmp((char *)buff,DONE) == 0) {
X			rdone = 1;
X			bum(RDONE);
X		}
X		else
X			/* see if we are done sending packets to them */
X			if (strcmp((char *)buff,RDONE) == 0)
X				ldone = 1;
X			else
X				check(buff);
X	}
X}
X
X/* -------------------------------------------------- */
X
Xvoid do_writes()
X{
X	int i, k;
X
X  /* test all the chars */
X  for (i = START_AT; i < STOP_AT; i++ ) {
X
X		/* don't send chars we are told to skip */
X    if ( skip[i] )
X      continue;
X		
X    fprintf(stderr, "%3d sending char\n", i);
X
X    /* attempt to send this char across, in a cute little packet */
X		for (k=0; k < TRIES; k++) { 
X
X			if ( !skip[(int)XON] )
X				printf("\n%d %c%c%c%c%c\n", i, START, (unsigned char)i, STOP, XON, END_PACKET );
X			else
X				printf("\n%d %c%c%c%c\n", i, START, (unsigned char)i, STOP, END_PACKET );
X			
X			bum(NULL);
X		}
X	}
X
X  bum(DONE);
X}
X
X/* -------------------------------------------------- */
X
Xvoid print_esc(void)
X{
X  int i, j;
X
X  /* make printing at the end easier by making it more generic */
X	valid[STOP_AT] = 1;
X
X  /* print out the valid list */
X  j = -1;
X	fprintf(stderr, "\n");
X  for (i = START_AT; i <= STOP_AT; i++)
X		if ( valid[i] && (j != -1) )
X		{
X			if ((j <= 128) && (i == STOP_AT))
X			{
X				fprintf(stderr, "sevenbit\n");
X				if ( j < 127 )
X					fprintf(stderr, "escape %d-%d\n", j, 127);
X				if ( j == 127 )
X					fprintf(stderr, "escape 127\n");
X			}
X			else
X				if (j == (i-1))
X					fprintf(stderr, "escape %d\n", j);
X				else
X					fprintf(stderr, "escape %d-%d\n", j, i-1);
X			j = -1;
X		}
X		else
X			if ( (!valid[i]) && (j == -1) )
X				j = i; 
X}
X
X/* -------------------------------------------------- */
X
Xint main(int argc, char **argv)
X{
X	int i;
X
X	pid = 0;
X	debugging = 0;
X
X	argv++;
X	argc--;
X	if (!argc) {
X		fprintf(stderr, "need output filename\n");
X		exit(-2);
X	}
X
X	if (strcmp("-d",*argv) == 0) {
X		debugging = 1;
X		argc--;
X		argv++;
X		if (!argc) {
X			fprintf(stderr, "need output filename\n");
X			exit(-2);
X		}
X	}
X
X	/* check the output file */
X	if (strcmp("stderr",*argv) && strcmp("-",*argv))
X		freopen(*argv, "w", stderr);
X	argc--;
X	argv++;
X
X  /* nothing has gotten through okay yet */	
X  for (i = START_AT; i < STOP_AT; i++) {
X		valid[i] = 0;
X		skip[i] = 0;
X	}
X
X  skipchars(argv);
X
X	signal(SIGINT, sig_int);
X
X	terminal_save(0);
X	terminal_raw(0);
X
X  setbuf(stdout,NULL);
X  setbuf(stderr,NULL);
X	
X  handshake();
X
X	/* parent should be reader to remain in control */
X	if ((pid = fork())) {
X		do_reads();
X	}	
X	else {
X		do_writes();
X		exit(0);
X	}	
X
X  print_esc();
X	terminal_restore(0);
X  exit(0);
X}
X
END_OF_FILE
  if test 8800 -ne `wc -c <'linecheck.c'`; then
    echo shar: \"'linecheck.c'\" unpacked with wrong size!
  fi
  # end of 'linecheck.c'
fi
echo shar: End of archive 5 \(of 6\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
