Newsgroups: comp.sources.unix
From: bcr@physics.purdue.edu (Bill C. Riemers)
Subject: v28i158: term-2.1.2 - slip-like functionality for a pair of UNIX hosts, Part01/06
Message-id: <1.784076477.10661@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: bcr@physics.purdue.edu (Bill C. Riemers)
Posting-Number: Volume 28, Issue 158
Archive-Name: term-2.1.2/part01

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  README MANIFEST README.porting README.security Term.HOWTO
#   connect.c jump/jump.undefs old
# Wrapped by vixie@gw.home.vix.com on Sat Nov  5 14:58:29 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 6)."'
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(15124 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
XPLEASE READ THE FILE "README.security" for important information!
X
X------------------------------------------------------------------------
X			   Term. version 1.11
X
X	      Copyright (c) 1992,1993,1994 Michael O'Reilly
X		  All Rights Reserved
X
X    This program is free software; you can redistribute it and/or modify
X    it under the terms of the GNU General Public License as published by
X    the Free Software Foundation; either version 1, or (at your option)
X    any later version.
X
X    This program is distributed in the hope that it will be useful,
X    but WITHOUT ANY WARRANTY; without even the implied warranty of
X    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X    GNU General Public License for more details.
X
X    You should have received a copy of the GNU General Public License
X    along with this program; if not, write to the Free Software
X    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
X-------------------------------------------------------------------------------
X
X--> Read the 'CHANGES' file as this will be more up to date than this
Xreadme.
X
X--> Please read this entire file if you have any problems.
X
X*********************************************************************
X--> Please don't send me e-mail telling me you liked it! My mailbox
Xoverfloweth! Postcards on the other hand are most welcome. 
X
X	Michael O'Reilly
X	192 Nicholson Rd
X	Subiaco 6008
X	Perth, Western Australia
X	Australia
X	
XI guess this makes this postcardware.....
X*********************************************************************
X
X---> For a sample ~/.term/termrc file see TERMRC
X
XTerm is a program to implement a slip-like connection between 2 *NIX
Xmachines. It isn't sl/ip. It runs entirely in user mode. It requires no
Xkernel support on either end, and no root access on either end. It is
Xbuilt to run over a modem to connect a non-internet machine with an
Xinternet machine. If this is your situation, and you don't have
Xslip/ppp then term is for you.  If you do have slip/ppp, then you
Xshould probably use it instead.
X
XTerm is run at both ends, and does multiplexing, error correction, and
Xcompression across the serial link between them. Designed to be as
Xefficient as possible, and have good response time, even over slow
Xmodems. (I run it over a 2400 baud modem). [ Well, I used to. Roll on
X14.4! M - 7/1/94]
X
XNote that it behaves the same from both ends. A user on either machine
Xcan connect to the other.
X
XThe term program runs as a server. A UNIX-domain socket is opened and
Xbound to support communication between client processes and the
Xserver.
X
XSee 'old/PROTOCOL.unix' for the protocol used by clients.  
XSee 'old/PROTOCOL.serial' for the protocol used across the serial link.  ( Be
Xwarned that they are out of date. If in doubt, read the source :)
X
XThese six clients are the most useful:
X
X    trsh
X	Runs a shell on the remote end. Like a normal login.  (Similar
X        to "rsh" without the need to specify a hostname.)
X    tupload <local file> -as <remote file>
X	Uploads a file. takes the name of the local file and the optional
X	arg is the name of the remote file.  This is a bit more robust than
X        "rcp", but at the price of not allowing you to specify a different
X        host or username.
X    txconn
X	Hangs around in the background waiting for X connections. re-directs
X	them to the local X server. Intended to be run on the remote machine.
X    tredir
X	Lets you alias a port on one system to another. I.e. 'tredir 4000 23'
X	run on host 'a' means that anyone telneting to port 4000 on 'a',
X	will get a login prompt of machine 'b'.
X    tshutdown
X	Terminates term.
X
X
X[More up to date information is available in HOWTO.term]
X
XBy default the program assumes that your modem can transmit data at the
Xsame speed as your computer's serial port connection to the modem.  To
Xset the proper rate run term as:
X	'term -s9600'
Xfor a 9600 baud modem.  Alternatively try :
X	'setenv BAUDRATE 9600'
Xor specifying:
X	baudrate 9600
Xin your termrc. The baudrate determines how fast term will try
Xto send data to the modem. I.e. if BAUDRATE is 9600, it will only
Xattempt to send 9600 bits per second to the modem.  However, the best
Xway to specify transmission rates is to write a termrc file.
X
XTerm reads the ~/.term/termrc file if it exists, so you can
Xpermanently set this stuff.  A system default termrc file may be
Xnamed /etc/termrc.
X
XLook in the file TERMRC.
X
XTo terminate a term session use the command "tshutdown".  If that
Xdoesn't work, either end will exit if it gets five zeros.  (i.e.
X"00000")  This means that if "tshutdown" fails you can kill the
Xlocal end, and then type '000000' into your comm program or
X'echo 0000000 > /dev/modem'.
X	
X----------------------------------------------------------
XHow to use txconn: (and term for that matter)
X
XLogin to your remote machine.
Xrun
X	"term -r"
X
XBreak back to your Linux prompt. I.e if you are running xcomm or
Xsomething similar then type control-A, x (to break back to xcomm
Xprompt). Then run term with stdin/stdout connected to the modem. 
X
XIn xcomm I type
X	"$ term"
XAlternatively you could exit your comms program altogether and run
X	"term < /dev/ttys1 > /dev/ttys1" from the shell prompt.
X		(assuming that /dev/ttys1 is your modem port).
X		Makes certain your comms program ISN'T running if you
X		try the above, as it will fight with term if it is.
X		
XThen run 'trsh' from a shell prompt. (I generally run xcomm and term
Xon tty8, and then switch to tty7 to run trsh. You may find it handy to
Xhave a entry in /etc/passwd looking like...
X	remote::0:0::/root:/usr/local/bin/trsh 
Xas this then enables you to login to your remote machine by logging in
Xas 'remote').
X
XThis should give you (in about 2 seconds) a shell on your remote
Xmachine. At this point the error correction/compression is on. You can
Xgo to another tty to run another trsh giving you multiple shells etc.
X
X
XNone of the above needs X-windows to run.
X------------------------------------------ 
X
XTo run txconn:
X  Make sure you are running X-windows. txconn will
Xassume you have x-windows running.
X
XAfter running 'trsh', type
Xif you are running tcsh, or csh:
X	"setenv DISPLAY `hostname`:0 ; setenv DISPLAY `txconn`" for csh/tcsh 
Xotherwise, if you are running 'sh' , or 'ksh':
X	"export DISPLAY=`hostname`:0 ; export DISPLAY=`txconn`"
Xon the trsh. (i.e. run txconn on your remote machine).
XIt should exit immediately. (This is because it starts a process in the 
Xbackground).
X
XHere, `hostname` returns the hostname of your REMOTE machine. (i.e. the
Xmachine you ran txconn on. To make that very clear. The local machine
Xis the machine you are typing on, the remote is the one at the other
Xend of the modem link. Run txconn on the remote machine. hostname is
Xset to be the name of your remote machine. DON'T use the hostname of
Xyour local machine).
X
XThen you can run any x-windows program on your remote machine, and it
Xshould appear on your screen.
X
X
XThings that can go wrong compiling..
X[See INSTALL for more up to date information.]
X
X1) configure complains about your OS not being define.  You'll have
X   to either edit the configure script, or find an OS that is "close
X   enough".
X
X2) config.h gives a message about the OS being undefined. 
X	config.h sets up a list of #define's based on what OS you are
X	compiling on. Please (if you can) write support for your OS, and
X	mail me the patches so I can support it. If you can't mail me
X	with details of you machine, and I will see what I can do.
X
XIf things go wrong, make sure you run the local end with the '-n on' flag.
XThis won't help, but it can give you some clues as to what's going
Xwrong. 
X
XThings that can go wrong:
X1) term giving message like
X	": timed out at 60 trans 4"
X    This should be read as "A packet got no acknowledgment even though it
X	has been waiting for 60/20th's of a second, so it is being 
X	re-transmitted for the 4th time."
X
X     These errors are normal. Line noise etc will cause packets to be
X	lost and retransmitting is the way they are recovered.
X
X     Times when it isn't normal:
X	a) Constantly re-transmitting i.e the last number just keeps
X	going up. This indicated one of 
X	    i) The remote term has died. Shouldn't happen.
X	   ii) The line is not an 8 bit line.
X		You can check this by running the linecheck program.
X	
X		Look up 'sevenbit' in TERMRC or term(1) if you have a
X		sevenbit line. 
X	  iii) Line noise has sent a XOFF character and your terminal
X		server has treated it is a quench signal. You
X		shouldn't be using software flow control with term.
X		turn if off if you can. Look up the -f option in OPTIONS
X		or 'flowcontrol' in TERMRC or term(1).
X	b) Any retransmissions on an error correcting modem.
X	    Any of the above, and
X	   iv) The BAUDRATE is set too high. Too much data is being
X		buffered by the operating system.
X        c) Term tells you to an old packet has been received and to raise
X           your timeout.
X            v) If this happens rarely, just ignore it.  If it happens a lot,
X               then you should follow this advice and raise your timeout to
X               a higher #.  
X        d) Lots of errors when you run multiple tasks at once.
X	   vi) Try "collisions on" in your termrc files, to tell term to lower
X               its transmission rate when receiving data.
X		
X2) Term not doing anything. Everything hangs.
X	i) The clients can't talk to the term socket.  Look at client.c.
X	ii) I have stuffed up and left a bug in a released version.
X	iii) The line is really dirty and it is eating one of the characters
X	term is using. See linecheck below.
X	iv) Mail me with LOTS of details.
X3) Term constantly giving you the prompt from your remote machine.
X	You have run the remote term in the background. Don't do this.
X4) Trsh hangs after you have typed a few keystrokes.
X	You have a dirty line. A terminal server or something like
X	that is eating some characters. Run linecheck. See
X	term_setup.1 for more information. See TERMRC for more information. See
X	below for more information.
X5) Term works fine, but if you have tredir's running, and you
X	login from the other end, all the tredirs exit.
X
X	This is because you are missing the 'remote' keyword. You need
X	"remote" on ONE end only. This keyword should go in your
X	~/.term/termrc file. Alternatively run ONE term with the '-r' flag,
X	as was shown in the example above.
X
X------------
XUSAGE OF linecheck.c
X
X[ this is probably out of date. Check the start of the linecheck.c
Xfile. M - 7/1/94]
X
X initially written by Michael O'Reilly
X *seriously* bashed about by by quarters
X hell, I wonder if diff would find more than 5 matching lines anymore...
X jefftep@cs.utexas.edu
X jeff grills
X
X
XWithout term running do the following. (i.e. on a bare serial line.
XNothing but your comms program is running.)
Xif you use a csh type shell (csh, or tcsh), then run /bin/sh before
Xyou do the following
X run remotely like:      linecheck 2> remote.output
X             locally:    linecheck < /dev/modem > /dev/modem 2> local.output 
X	
X
X if it says something needs escaped, that means it didn't get through okay
X this time. if you get an invalid packet printed, it means the packet wasn't
X sent by the linecheck on the other side, and may either be line static,
X or some very braindead terminal response to a (possibly series) of characters
X to what was printed over the line.  in this case, it's your responsibility
X to determine which, and escape the previously sent char if needed.  There is
X no way this program can identity a braindead terminal server from line static,
X so this is the way it has to be.
X
X if, for some reason, you get stuck out in lala land, and can't kill
X the program, try typing "^jexit^j".  That should kill it, and restore
X your terminal.   
X
X It'll print "### sending char" and "### received valid".  Don't worry if these
X two number are out of sync.  That's fine.  Just worry, on either side, if you
X get some "Invalid packet: " lines.  Look at them closely, and see if it's line
X static, or a real problem.
X
X At the end, it'll print out a summary of what it thinks you should escape.
X This just means these chars didn't get received correctly this time.  Again,
X if line static munched something, some of these may be valid. 
X
X To actually escape them, you have to put them into your termrc file.
X So if it said to escape 0-31, then on the OTHER end from the one that
X printed it, you add the line 'escape 0-31' to your ~/.term/termrc file.
X Please note that the local.output file contains the characters that
X should be escaped on the REMOTE end, and vice versa. See TERMRC and
X term(1) for more on escaping characters.
X
X *** IF *** your terminal server generates extra responses for odd chars,
X then you may not be told to escape something, but need to anyway.  This will
X be evident from a "Invalid packet: " on the local side, after attempting to
X send a character.  Again, it may be line static. You have to make the call.
X
X if you're running it locally in a xterm, I suggest you turn on logging.
X
X if you have problems with this program, and want me to look at it, mail me
X *both* the local and remote output, and label them appropriately.
X
Xprogrammers notes:
X
X hopefully, soon, I'll add the ability to skip chars to this program,
X so you can test out the escapes you want.
X
X maybe do a fork() and process the two sides independently, so it never hangs.
X would cause minor quitting problems, but may be worth it.
X
XAny problems, feel free to mail me. Any patches, bug fixes, etc are
XVERY welcome.
X
XMichael (oreillym@tartarus.uwa.edu.au);
X
XP.S.
XBill Riemers (bcr@physics.purdue.edu) is temporarily maintaining this code,
Xoriginally written by Michael O'Reilly (oreillym@tartarus.uwa.edu.au).
X
X----------
X
XFrom michael@iinet.com.au  Tue Jul 19 22:33:54 1994
XFrom: michael@iinet.com.au (Michael O'Reilly)
XSubject: I saw...
X
Xterm 202 go past today. Looks just beautiful. :)
X
XGiven the awesome mods you've made, it's probably a good idea to
Xchange the docs to mention, term, original written by me, now
Xfixed, beautified, made useful, and supported by you.
X
XMichael
X
X-----------
X
XHmm, really most of the credit should go to the people listed in CREDITS.
XSome of these people have probably done a lot more with term development
Xthan I have.  :-)
X
XOriginally I started using term because it was the only option for multi-
Xtasking over a modem without remote root support.  At this point I think
Xit is quite competitive with SLIP and PPP. 
X
XPro's:
X        - Often times term is faster.
X        - Term gives you true firewall security.  Users can only access 
X          network commands you explicitly allow with a SUID or SGID command.
X          And you will never be sprayed, or have to worry about network
X          users ports you have redirected!
X        - No root support required.
X
XCon's:  
X        - Programs have to be compiled with term support to work.
X	- Not everything works.  Programs like "ping" which normally
X          must be SUID root never will work.  Although "rsh" type commands
X	  are already an exception to this rule.
X        - "fet" term's equivalent of "dip" isn't nearly as smart as "dip".
X        - It is doubtful NFS mounts over term will ever be supported.
X
END_OF_FILE
  if test 15124 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
  echo shar: Extracting \"'MANIFEST'\" \(1414 characters\)
  sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X----------------------------------------------------------
XREADME                     1	
XMANIFEST                   1	This shipping list
XBUGS                       6	
XCHANGES                    3	
XCOPYING                    4	
XCREDITS                    6	
XFAQ                        6	
XINSTALL                    5	
XMakefile.in                5	
XREADME.porting             1	
XREADME.security            1	
XSCO.CHANGES                6	
XTERMRC                     6	
XTODO                       6	
XTerm.HOWTO                 1	
Xchecksum.c                 6	
Xclient.c                   5	
Xclient.h                   6	
Xcompress.c                 5	
Xconfig.h                   6	
Xconfigure                  5	
Xconnect.c                  1	
Xdebug.h                    6	
Xdownload.c                 5	
Xincludes.h                 6	
Xjump/README.jump-updating  6	
Xjump/jump.funcs            6	
Xjump/jump.ignore           4	
Xjump/jump.params           6	
Xjump/jump.undefs           1	
Xjump/jump.vars             3	
Xjump/size.nm               5	
Xlib.c                      4	
Xlib.h                      6	
Xlinecheck.c                5	
Xlink.c                     4	
Xmain.c                     3	
Xmeta.c                     6	
Xmisc.c                     6	
Xold                        1	(Directory)
Xold/Blurb                  2	
Xold/INTERNALS              6	
Xold/Protocol.gz.uu         2	
END_OF_FILE
  if test 1414 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
  fi
  # end of 'MANIFEST'
fi
if test -f 'README.porting' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README.porting'\"
else
  echo shar: Extracting \"'README.porting'\" \(2437 characters\)
  sed "s/^X//" >'README.porting' <<'END_OF_FILE'
XWHAT IS THIS?
X~~~~~~~~~~~~~
XI've added in the following routines to make porting easier:
X   term_gethostbyname()
X   term_connect()
X   term_rcmd()
X   term_bind()
X   term_getsockname()
X   term_listen()
X   term_accept()
X   term_shutdown()
X   term_close()
X   .
X   .
X   .
X
XAt the end if this file I've included instructions for using these new routines
XI've tried to make it so "term" binaries will be usable for users of other
Xnetworking software as well.  Sometime in the future, users might be able to
Xmodified their shared libraries instead of recompiling everything.  For now
Xthis is still sometime off in the distant future.
X
XFor programs that were ported back in the days of client.a, you can still
Xrecompile them for use with newer versions of term simply by changing the
Xclient.a reference to libtermnet.a
X
XPORTING OF SOFTWARE:
X~~~~~~~~~~~~~~~~~~~~
XHere is the new simplified porting procedure.
X
XIf installed in /usr/local by root:
X
X  1. Add to the compile flags "-include /usr/local/include/termnet.h"
X  2. Add to the library list "-ltermnet"
X
XIf installed in your home directory:
X
X  1. Add to the compile flags "-include ~/term/termnet.h"
X  2. Add to the library list "-L ~/term -ltermnet"
X
XThat should do it!!!  If you are using term in "shared" mode, you'll need:
X
XAs root:
X
X  chgrp term <filenames>
X  chmod g+s <filenames>
X
XAs an ordinary user:
X
X  chmod u+s <filenames>
X
XSome commands like "rlogin" will be privileged.  i.e. Only the person who
Xstarted "term" and "root" may use privileged commands.
X
X
XSome term commands will be "term" transparent and only use term when there
Xis not another option.  Some common examples are:
X	telnet, ftp, ...
X
XOthers require an external flag to tell them it is all right to use term.  These
Xprograms include:
X	xarchie, fsp, ytalk, ...
X
XYou can either flag these programs to use term by setting the environmental
Xvariable TERMMODE as specified in README.security, or running "make installnet".
XEventually the "termnet" file created will contain special networking
Xinstructions, but for now only its existence is checked.
X
XIf you add an ethernet connection, you can then simply remove the "termnet"
Xfile and continue to use the same binaries!
X
X
XPORTING CAVEAT:
X~~~~~~~~~~~~~~~~
X
XThe termnet functions don't always act exactly like real networking code.
XStill needed:
X - To deal with duplicated socket descriptors.
X - To gracefully deal with binds to privileged ports and other misc. problems.
X
END_OF_FILE
  if test 2437 -ne `wc -c <'README.porting'`; then
    echo shar: \"'README.porting'\" unpacked with wrong size!
  fi
  # end of 'README.porting'
fi
if test -f 'README.security' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README.security'\"
else
  echo shar: Extracting \"'README.security'\" \(5733 characters\)
  sed "s/^X//" >'README.security' <<'END_OF_FILE'
XWHAT IS THIS?
X~~~~~~~~~~~~~
XShared term allows other users to use the same term connection you are using.
XBy environment variables you can disable/enable shared features.
X
XYou only need to install shared term on the end that you have users
Xwho want a shared term connection.  However for new commands to work,
Xboth ends should be running the same term version #.
X
XOK, the following instructions allow you to share your term connection without
Xallowing other users direct access to either the account on which term
Xwas started, or the remote *NIX account.  ("chroot", and "denyrsh" just don't
Xcut it if users are clever with tupload, or willing to compile their
Xown clients.)
X
XIf you don't want to use the shared term features, skip the following
Xsection of this file.  Just type follow the instructions in INSTALL.
X
X
XTERM MODES
X~~~~~~~~~~
X
XThere are two basic ways you can install term for sharing.  The safest, most
Xsecure method is as root create a "term" group which contains no members.  Then
Xas root, install "term" as a SGID program.  If this option is not possible, 
Xthen you can install term as a SUID program by installing as an ordinary user.
X
XHere is a table that lists the differences:
X
XChmod	$TERMMODE	$TERMDIR -or-	Default		Connection
XType			$TERMSHARE			Owner	Users
X-------	---------------	---------------	---------------	------- ----------------
Xu+s	2 (Shared)	neither		$HOME/term	You	Anyone
Xu+s	0 (Private)	$TERMDIR	$HOME		Anyone	Connection Owner
Xg+s	1 (Shared)	$TERMSHARE	/usr/local/lib/term	Anyone	Anyone
Xg+s	0 (Private)	$TERMDIR	$HOME		Anyone	Connection Owner
X-	0 (Private)	$TERMDIR	$HOME		Anyone	Anyone
X
X
XTo install shared term, do the following:
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X
X1) (IF YOU ARE ROOT!)  Create a "term" group with no members
X   by adding the following line in /etc/group:
X
X   term::16:root
X
X   If 16 is already used by something else, choose an unused GID.
X
X
X2) Follow the instructions in INSTALL for making and installing your binaries.
X
X3) To start "term" SHARED mode use:
X
X   IF term was installed by ROOT:
X     With csh or tcsh:
X       setenv TERMMODE 1
X     With bash use:
X       export TERMMODE=1
X   otherwise
X     With csh or tcsh:
X       setenv TERMMODE 2
X     With bash use:
X       export TERMMODE=2
X
X   NOTE!!!  All users who want to take advantage of the shared term 
X   connection should set the above environment variable.
X
X
X4) To start clients compiled with term117 or earlier in shared mode.
X
X   With TERMMODE=1:
X     With csh or tcsh:
X        setenv TERMDIR /usr/local/lib/term
X     With bash use:
X        export TERMDIR=/usr/local/lib/term
X   With TERMMODE=2:
X     With csh or tcsh
X	setenv TERMDIR $HOME/term
X     With bash use:
X        export TERMDIR=$HOME/term
X
X   NOTE!!!  All users who want to take advantage of the shared term 
X   connection should set the above variables.
X
X5) To run in PRIVATE MODE: 
X
X   With csh/tcsh:
X       setenv TERMMODE 0
X   With bash:
X       export TERMMODE=0
X
X6) If you have multiple modems, then you can have more than one connection
X   at a time.  To specify which connection to use you must start term
X   with a server name.  i.e.
X
X       nohup term -v /dev/modem1 -l /tmp/logfile1 Connection1 &
X       nohup term -v /dev/modem2 -l /tmp/logfile2 Connection2 &
X
X   then users should set the variable TERMSERVER to the connection name
X   they want to use.  i.e.
X
X       setenv TERMSERVER Connection1
X
X   for csh, tcsh, and etc.,  or
X
X       export TERMSERVER=Connection1
X
X   for bash, sh, ksh, and etc.
X
X
XPRIVILEGED COMMANDS:
X~~~~~~~~~~~~~~~~~~~~
X
XThe primary differences between the sharable and the unsharable commands are:
X  - Sharable commands are SGID (set group id) programs if installed by root
X    or SUID (set user id) programs if installed by an ordinary user.
X  - The shared "term" directory is controlled by $TERMSHARE instead of
X    $TERMDIR
X
XSome programs, even though they may be SUID or SGID, will still only be usable
Xby the owner of the term-connection and root.  These are known as privileged
Xcommands.  The following clients are privileged.
X
X  tupload, trsh, tshutdown
X
XThe other term clients:
X
X  tmon, txconn, tredir
X
Xare available by anyone who can execute the binaries.
X
XIf you port program using termnet.h, anything that uses rcmd() will also
Xbe privileged.  Here is a listing of some of these programs:
X
X  rlogin, rsh, rcp
X
XHere are some non-privileged programs:
X
X  finger, whois, talk, telnet, xarchie, xgopher, ytalk
X
XBasically, if it allows the user to access an account without a password it
Xwill be privileged.
X
X
XHOW TO MAKE A COMMAND SHARED
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X
XIf you want to make a term command such as termftp or termtelnet shared,
Xthen do the following, which sets shared group permissions:
X
X  IF YOU ARE ROOT:
X	chgrp term binary-file
X	chmod g+s binary-file
X  IF YOU ARE AN ORDINARY USER:
X        chmod u+s binary-file
X
X
XSECURITY TEST
X~~~~~~~~~~~~~
X
XIf you are the first to port a program, it would probably pay to double
Xcheck its security when in shared mode.
X
XTo test the command try to fork a shell with the command "id".  If "id"
Xreports:
X   '... egid=16(term) ...' 
Xthen you have a security hole.
X
XAlso try to overwrite other peoples' files, or create files where you
Xdon't have write permission.
X
XHere is an example of how I tested "ftp":
X
X% ftp localhost
XConnected to localhost.
X220 k9 FTP server (Linux k9 1.0.9 #5 Tue Jun 7 12:52:00 EST 1994 i486) ready.
XName (localhost:bcr): bcr
XPassword (localhost:bcr): 
X331 Password required for bcr.
X230 User bcr logged in.
XRemote system type is UNIX.
XUsing binary mode to transfer files.
Xftp> !id
Xuid=501(bcr) gid=100(users) groups=100(users)
X
XIn this case, this is my user id and group id, so "ftp" passes the test and
Xthis command is safe.
X
END_OF_FILE
  if test 5733 -ne `wc -c <'README.security'`; then
    echo shar: \"'README.security'\" unpacked with wrong size!
  fi
  # end of 'README.security'
fi
if test -f 'Term.HOWTO' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Term.HOWTO'\"
else
  echo shar: Extracting \"'Term.HOWTO'\" \(55203 characters\)
  sed "s/^X//" >'Term.HOWTO' <<'END_OF_FILE'
X  term HOWTO
X  Bill Reynolds bill@goshawk.lanl.gov, Patrick Reijnen
X  patrickr@cs.kun.nl
X  September 3, 1994
X
X  1.  Introduction
X
X
X  1.1.  About This Document
X
X
X
X  This HOWTO attempts to clear up some of the confusion of using term,
X  Michael O'Reilly's remarkable program that allows you to multiplex
X  your serial line and set up a network connection.  By and
X  large, the documents that come with term are quite good, and this
X  HOWTO is not intended to replace them. The intent of this document is
X  to give some background on how term works and detail the steps in
X  getting some of the more common networking services working under
X  term. I should emphasize that this document does not cover everything
X  there is to know about term. After reading it, you should read the
X  term manpages, since they include information not contained here.
X
X
X  1.2.  What is term?
X
X  term is a program, written by Michael O'Reilly (michael@iinet.com.au),
X  that is run over a serial line to allow multiple connections to
X  operate concurrently - i.e. you can be downloading a file over your
X  modem while working on a (different) remote system via the same modem
X  connection. term can also be used to open up X client windows over a
X  serial connection.  Through the tredir utility and the tudpredir
X  utility in term versions 2.0.x, term can provide many of the
X  ``traditional'' network services: mail, news, ftp, telnet, xarchie,
X  etc.  In a sense, term is very much like other serial protocols such
X  as SLIP or PPP. term's advantage is that it can be run entirely from
X  user space, requiring neither kernel support nor support from system
X  or network administrators.
X
X
X  2.  How term works
X
X  2.1.  Nomenclature
X
X
X  I am assuming you are dialing up a system through some sort of
X  terminal server. I use the terms ``local'' and ``remote'' to refer to
X  the home and network connected systems respectively (unless I use them
X  to mean something else :-).
X
X  term provides the local machine, which has no network connection, but
X  is connected via a serial line to a remote machine which is in turn
X  connected to a network, with network services. Let's look at how a
X  machine with a ``traditional'' network connection provides these
X  services. First the user invokes a program, like ftp or telnet, that
X  requests a network service. What these program do is make a system
X  call requesting network services. The operating system then obtains
X  these services via its network interface (e.g. it sends and receives
X  packets over the ethernet). SLIP and PPP do exactly this, by
X  converting your modem line into a network interface, which is in
X  principle no different from an ethernet. The downside of this is that
X  these protocols make the modem-connected machine part of the network,
X  just like any other machine. This entails all the administrative
X  burdens associated with being a network node (more actually, since the
X  modem link must also be administered).
X
X  In the absence of a network connection like SLIP or PPP, what does one
X  typically do? Well, you dial up your network connected machine, read
X  your mail, your news etc, if you need a file, you first transfer it to
X  the remote machine and then download it to your local machine using
X  kermit or some other communication program. This is a bit of a pain,
X  especially since you can only really do one thing at a time that uses
X  your modem link.  The idea behind term is basically to automate and
X  multiplex this process. term is invoked on both the local and remote
X  machines, and the two processes communicate with one another over the
X  modem line. When you need a network service, you make a request to the
X  local term daemon, which forwards the request to the term daemon on
X  the remote, network-connected, machine. The result is then returned
X  over the modem line.
X
X
X
X  To be more concrete, say you want to retrieve a file by ftp.  First
X  you need a version of ftp that can speak to term. You invoke this
X  termftp as you do a regular ftp, say termftp nethost.gov, but this
X  special version makes its network request to the local term daemon
X  instead of the kernel. The local term forwards this request, over the
X  modem line, to the remote term, which opens an ftp connection to
X  nethost.gov, and transmits the data back over the modem link. term is
X  smart enough to have many different things going on at once, so you
X  can have several different network sessions using the same modem link,
X  e.g. you can be logged into another distant host via termtelnet while
X  the termftp transfer is going on.
X
X  If this is too abstract (or unclear) do not worry; the important piece
X  of information to get out of this section is that there are two copies
X  of term running, one on each end of the modem link.
X
X
X  3.  Setting Things Up
X
X
X  3.1.  Build term
X
X
X  When you are lucky, this should just involve a make. Most probably
X  however, you need to do more. Due to new features in newer versions of
X  term (sharing, configure) it is now a bit more complicated to create
X  obtain your term binary. A couple of ways can now be followed to
X  obtain your binary.
X
X  To cover all these ways term can be build I will split this section
X  into three parts:
X
X
X  1. Build term upto version 1.15
X
X  2. Build term, versions 1.16 upto 1.19
X
X  3. Build term, versions 2.0.0 and higher
X
X
X  3.1.1.  Build term upto version 1.15
X
X
X  For these versions of term building should invoke no more than the
X  commands
X
X
X  make DO=install OS-type
X  make installman
X
X  You will find term, its clients and the manual pages nicely built and
X  installed and ready for use after this.
X
X  The only thing you may want to do is changing some of the paths in
X  the Makefile or changing some of the compiler flags.
X
X
X  3.1.2.  Build term, versions 1.16 upto 1.19
X
X
X  Starting with version 1.16 the concept of sharing the term connection
X  with other users has entered term. With this concept built in also the
X  ways of building term are extended.
X
X  To build term you can now choose one of the following ways:
X
X
X  1. You are an ordinary user (no root access) and you do not want to
X     share the term connection with other users.
X
X     As user who does not want to share the term connection with other
X     users you should do the following to build term:
X
X
X     make DO=install OS-type
X     make installman
X
X
X
X  After this term, its clients and the manual pages are built and
X  installed.
X
X  2. You are an ordinary user (no root access) and you want to share the
X     term connection with other users.
X
X     As user who wants to share the term connection you should do the
X     following:
X
X
X     make DO=installshare USERSHARE=$HOME/term OS-type
X     make installman
X
X
X
X  After this term, its clients and the manual pages are built and
X  installed.
X
X  Furthermore, you will have a directory $HOME/term with permissions
X  drwxrwxr-x
X
X  3. You are root and you do not want to share the term connection with
X     other users.
X
X     As root who does not want the term connection be shareable you
X     should do the following to build term:
X
X
X     make DO=install OS-type
X     make installman
X
X
X
X  After this term, its clients and the manual pages are built and
X  installed.
X
X
X  4. You are root and want to make the term connection shareable.
X
X     Create a term group with no member by adding the following line in
X     /etc/group:
X
X
X     term::16:root
X
X
X
X  or any other unused GID than 16 when 16 is already in use.
X
X  Now do
X
X
X  make DO=installshare OS-type
X  make installman
X
X
X
X  After this term, its clients and the manual pages are built and
X  installed.
X
X  Furthermore, you now have a directory called /usr/local/lib/term
X  (default) owned by group term and with permissions drwxrwxr-x
X
X
X  3.1.3.  Build term, versions 2.0.0 and higher
X
X
X  For term versions 2.0.0 and higher there are many ways to build the
X  term binary and the clients. All of these can be done both by root and
X  by ordinary user:
X
X
X  1. Build term in private mode without full term networking
X
X  2. Build term in private mode with full term networking
X
X  3. Build term in shared mode without full term networking
X
X  4. Build term in shared mode with full term networking
X
X  In these versions of term also the configure concept is used.  When
X  configure is run it checks on what operating system you are trying to
X  install term, whether the source directory is available or not and if
X  any runtime options are set. According to the things found configure
X  then creates a Makefile using Makefile.in which is provided in the
X  term package.
X
X  Two of the more important options to configure are --root and --user
X  which state whether term will be installed by root or an ordinary
X  user.
X
X
X  3.1.3.1.  Build term in private mode without full term networking
X
X
X  To build term this way you need to execute the following commands
X  (both for root and ordinary user):
X
X
X  make install installman
X
X
X
X  This builds the binaries and installs these binaries and the manual
X  pages.
X
X
X  3.1.3.2.  Build term in private mode with full term networking.
X
X
X  To build term this way you need to execute the following commands
X  (both for root and ordinary user):
X
X
X  make installnet installman
X
X
X
X  This builds the binaries and installs these binaries and the manual
X  pages.
X
X
X  3.1.3.3.  Build term in shared mode without full term networking
X
X
X  To build term this way you need to execute the following commands
X  (both for root and ordinary user):
X
X
X  make share installman
X
X
X
X  This builds the binaries and installs these binaries and the manual
X  pages.
X
X
X  3.1.3.4.  Build term in shared mode with full term networking
X
X
X  To build term this way you need to execute the following commands
X  (both for root and ordinary user):
X
X
X  make share installnet installman
X
X
X
X  This builds the binaries and installs these binaries and the manual
X  pages.
X
X
X  3.2.  Setting environment variables
X
X
X  term knows a couple of environment variables which can be set by
X  users. The first three of these I will explain are
X
X
X  o  TERMDIR
X
X  o  TERMSHARE
X
X  o  TERMMODE
X
X  By setting these variables you can control the way term is run.
X
X  For term versions upto 1.15 only the variable TERMDIR is important
X  (these versions do not know the shared mode). For these versions
X  TERMDIR should be set as follows:
X
X
X  setenv TERMDIR $HOME     (csh or tcsh)
X  export TERMDIR=$HOME     (bash)
X
X
X
X  Starting with version 1.16 term also knows the variables TERMSHARE and
X  TERMMODE. With these variables term can be told to run in private mode
X  or in shared mode. I will explain how to set the variables for private
X  mode and shared mode.
X
X
X  1. Running term in private mode can be done setting the variables
X     TERMDIR and TERMMODE in the following way:
X
X     For csh or tcsh
X
X     setenv TERMDIR $HOME
X     setenv TERMMODE 0
X
X
X
X  For bash
X
X  export TERMDIR=$HOME
X  export TERMMODE=0
X
X
X
X  2. When you want to use term in shared mode there are two ways of
X     setting the variables:
X
X
X     a. When term is installed as a SUID program only TERMMODE has to be
X        set (?? README in the term package).
X
X
X        setenv TERMMODE 'number'    (csh or tcsh)
X        export TERMMODE='number'    (bash)
X
X
X
X     For 'number' you have to enter 1 when you are using one of the term
X     versions 1.16 upto 1.19 and 2 when you are using term version 2.0.0
X     or higher.
X
X     b. When term is installed as a SGID program the variables have to
X        be set in the following way:
X
X        For csh or tcsh
X
X        setenv TERMMODE 1
X        setenv TERMDIR /usr/local/lib/term
X        setenv TERMSHARE $TERMDIR
X
X
X
X     For bash
X
X     export TERMMODE=1
X     export TERMDIR=/usr/local/lib/term
X     export TERMSHARE=$TERMDIR
X
X
X     Setting the variables this way makes it possible to start old
X     clients (clients linked to an older version of client.a) in shared
X     mode.
X
X  Starting with version 2.0.0 term also knows the variable TERMSERVER.
X  You need to set this variable when you have multiple modems and you
X  have more than one connection at a time. To specify which connection to
X  use, you must start term with a server name:
X
X
X  nohup term -v /dev/modem1 Connection1 &
X  nohup term -v /dev/modem2 Connection2 &
X
X
X
X  Users should then set the variable TERMSERVER to the connection name
X  they want to use:
X
X
X  setenv TERMSERVER Connection1   (csh or tcsh)
X  export TERMSERVER=Connection2   (bash)
X
X
X
X
X  3.3.  Test term
X
X
X
X  Do a make test to build term's test daemon. Test works by running two
X  copies of term on your system, a ``local'' and a ``remote'' copy. Both
X  of these will read your termrc, so you can adjust their behaviour.
X  Run test as ./test  so as to avoid your system's test. You should now
X  be able to do a trsh and a tupload (try
X   tupload ./term /usr/tmp - you should get a copy of the term  binary
X  in /usr/tmp ). The local term's output should show up in local.log,
X  the remote's in remote.log.   You can start term up with a -d255 flag
X  to enable debugging output to be written to these files, or enable
X  debugging in your termrc.
X
X
X  3.4.  Make a Transparent Link
X
X
X  Presumably, you can establish a modem connection between your local
X  and remote hosts. Typically, your dialing into some kind of terminal
X  server and connecting to your remote host from there. You are also
X  using some kind of terminal software, such as kermit or seyon to talk
X  to your modem (the examples in this document will use kermit, since
X  that is what its author uses). If you are having trouble with your
X  modem, or your terminal software, take a look at the Serial-HOWTO,
X  that should help you out.
X
X  Having established your link, you want to make it as transparent as
X  possible.  Check the commands on the terminal server (help or ? will
X  usually get you started). Go for the 8 bit options whenever possible.
X  This may mean changing the way you log in to a system, e.g. if the
X  server uses rlogin, you may have to use it and give it the -8 flag to
X  make it transparent.  Especially watch out for xon/xoff flow control,
X  you do not want that, try to enable rts/cts (hardware) flow control.
X  You may need to check your modem docs to learn how to configure it to
X  do 8-bit rts/cts communications.
X
X
X
X
X  3.5.  Run linecheck
X
X
X  linecheck is program that is supplied with term.  It checks the
X  transparency of a link, providing configuration information that term
X  needs to run correctly.  linecheck will send each of the 256 possible
X  eight bit characters over the link and verify that each was
X  transmitted successfully. term needs to be configured to deal with
X  characters that cannot be transmitted over the link, and linecheck
X  determines what characters these are. You use linecheck after you've
X  established as transparent a modem link as possible. To run linecheck,
X  do the following
X
X
X  1. On the remote system, run linecheck linecheck.log.
X
X  2. Escape back to your local system and suspend your comm program (^Z
X     under kermit) (otherwise it will steal characters from linecheck).
X
X  3. On the local system run linecheck linecheck.log > /dev/modem <
X     /dev/modem.
X
X  When linecheck is done, you will find a set of numbers at the bottom
X  of the linecheck.log files. These should be escaped in the termrc at
X  the other end of the link. For example, on my system, my local
X  linecheck.log said nothing and my remote linecheck.log said to escape
X  29 and 157.  Therefore, my local termrc escapes these characters and
X  my remote termrc escapes nothing. If I escape a character on one end,
X  I have to also ignore it on the other, so, in this example, I shall
X  have to ignore 29 and 157 on my remote system.
X
X  If linecheck hangs, try using
X
X
X  linecheck linecheck.log 17 19 > /dev/modem < /dev/modem
X
X
X
X  this will escape your xon/xoff (flow control) characters, which will
X  hang your line if you have got software flow control. If this solves
X  the hanging problems, you will want to escape /ignore 17/19 in both
X  termrc's. If your terminal server has other daemonic characters that
X  will shut it down, try running linecheck with those characters
X  escaped, as above. You can spot these characters if linecheck hangs.
X  If this is the case, kill it, then look in the logfiles. The last
X  characters transmitted are likely to be the culprits. Try it again
X  with these characters escaped.
X
X  In summary, my local termrc has the lines
X
X
X  escape 29
X  escape 157
X
X
X  and my remote termrc has the lines
X
X
X  ignore 29
X  ignore 157
X
X
X  since my remote linecheck.log said to escape 29 and 157.
X
X
X
X  3.6.  Try Running term
X
X
X  Log into the remote system, making the link as transparent as possible
X  (if you have not already).  Fire up term on the remote end.  I use the
X  following:
X
X  exec term -l $HOME/tlog -s 38400 -c off -w 10 -t 150.
X
X  Let's run down each option one by one (note that I could just as
X  easily have put these options in my termrc. I did it this way because
X  it saves editing a file while getting term set up).
X
X  exec means to destroy your current shell, running the given program in
X  its place.  I exec things because I do not intend to use my login
X  shell again, so it is just wasting memory. If you are debugging the
X  link and can reliably kill the remote term, you might not want to do
X  an exec.
X
X  -l $HOME/tlog. This logs errors to the file tlog in my home directory.
X  Very useful for debugging. No reason not to do this.
X
X  -s 38400 : I have got a 14400 baud modem, with compression.  For
X  optimal compression ratios, I want to be able to push bits down the
X  pipe as fast as possible. For a slower modem, you should use something
X  lower.  Note that if you have a slower machine with 16450 uart on your
X  serial port, high baudrates can cause data loss by overloading the
X  chip on your serial port. term will recover from this, but if you see
X  a lot of error messages in your log file, (or get overrun warnings
X  from linux kernel versions 0.99pl15 and up) you again might want to
X  lower this number.
X
X  -c off : This turns data compression off. I have got a compressing
X  modem, and I do not want to compress things twice.
X
X  -w 10 -t 150 : Again, these are options to optimize my fast modem
X  link.  I have set my window to 10 and my timeout to 150. This is per
X  the recommendation in the term_setup man page.
X
X  Escape back to your local machine and suspend your comm program (^Z
X  under kermit). You do not want it running while term is running,
X  because it will fight with term over the serial port. If you can
X  convince your modem to not hang up when you exit your comm program
X  (when it toggles DTR), you could just exit the program at this point.
X
X  Now run term locally. I use:
X
X  term -r -c off -l $HOME/tlog -s 38400 -w 10 -t 150 < /dev/modem >
X  /dev/modem &
X
X
X  The only option here that is different from the other end is the -r
X  option. You need this on one end, otherwise term clients will
X  spontaneously die on you. I need to tell term where the modem is, so I
X  point both standard input and output at /dev/modem (that is what the <
X  and > do). I also run it in the background, so I can use this screen
X  for something else if I want to.
X
X  term should work now :-). Try a trsh, and see what happens. If you
X  hang, or your link seems slow, take a look at your tlog on each end.
X  Are you getting timeouts or error messages? If so, then you have
X  configured something incorrectly. Try again (after you have finished
X  reading this :-). Note that the connection won't seem blazingly fast,
X  especially if you are using compression - it will be a little jumpy.
X  The real speed comes in during file transfer and the like.
X
X  3.7.  Terminate your term connection
X
X
X  Most certain, after you have done a lot of work using term, you want
X  to finish your work and bring your term connection down. For this to
X  be realized there are three ways:
X
X
X  1. Kill the term programs on both sides of the connection. This is the
X     least recommended way of terminating your connection
X
X  2. A better way is to execute the following command locally:
X
X
X     echo '00000' > /dev/modem
X
X
X
X  This will nicely terminate your term connection. It will work for all
X  version of term. Make sure that the sequence of zeros contains at
X  least five zeros.
X
X  3. Starting with version 1.14 there is the program tshutdown (actually
X     for version 1.14 it is available as a patch, for newer versions it
X     is in the package). Executing tshutdown nicely terminates your term
X     connection.
X
X
X  3.8.  Gotchas to Watch Out For
X
X
X  If your .term or term directory is mounted with NFS you need to set
X  the flag -DTERM_NFS_DIR in the CFLAGS line of the Makefile. Alas, for
X  the author this flag causes a compile error when term 1.19 is compiled
X  on a machine running sunOS 4.*.
X
X  Are you running the right binary? term has been updated quite a lot,
X  and many systems have different versions of the programs floating
X  around. Make sure you are using the right version. Note that this
X  applies to linecheck too. You can use bash's type -a or the whereis
X  command to find which program is being run.  term versions after 1.11
X  should print out their version number when they start up.  (Although
X  version 1.14 claims to be 1.12.  Sigh.)
X
X  Do you have the right termrc? Depending of the version of term you are
X  running and the way you installed term (being root or user) this file
X  has to be in one of the following directories: /usr/local/lib/term,
X  $HOME/.term or $HOME. Some systems have pre-installed termrc's, make
X  sure they are gone before you set things up. If you are running things
X  as root, lookout for /.term. term creates files (sockets actually)
X  while it is running, so it has its own directory, $HOME/.term, where
X  the file termrc goes (note, there is no leading dot in termrc!).
X
X  With newer versions of term the structure of the directory tree under
X  /usr/local/lib/term has changed a couple of times. If you are not
X  aware of this, it can cause all kinds of error messages. The best
X  thing to do is to delete the directory tree under /usr/local/lib/term
X  (save your termrc) and then install your new term version. This way,
X  you avoid the struggle with a messed up directory tree.
X
X  Once you have got term running, you might want to try to get things
X  optimized. A good way to measure the speed of your link is to run tmon
X  in one window while up/downloading a file in another. Try both (big)
X  text files and compressed files, the plain text should go a factor of
X  two-ish faster than the compressed files.  The parameters you want to
X  fiddle with are compression (-c), windows (-w), timeout (-t) and
X  retrain (-A.  Watch out with the retrain parameter. I got a
X  performance decrease of 80% to 90% compared to running term without
X  the retrain parameter. It is not clear if this is a bug in term
X  version 1.19, the version I am running and if this problem exists only
X  with term version 1.19.
X
X
X  Compression: you want this on if you do not have a compressing modem.
X  If you do have such a modem, turn compression off, otherwise you will
X  be compressing things twice, which typically increases the amount of
X  data transmitted. Compressing modems are ones that use the MNP-5 or
X  V42.bis protocols. Check your modem documentation and the message when
X  your modem connects.
X
X  Windows: this is the number of chunks of data, or packets, that term
X  will let go over the line before it gets an acknowledgment (or ack)
X  from the remote term. For fast modems, increasing this can be a win,
X  for slower links this can overwhelm the remote end.
X
X  Timeout: the time term will wait for an ack. If you have increased
X  windows, and you are getting timeouts in your logfile, try increasing
X  this.
X
X  For 14400/V42.bis, I use -c off -w 10 -t 150. I typically get around
X  1700 cps on compressed files and 3500 cps on ascii files using
X  tupload.
X
X
X  4.  term clients
X
X
X  term provides several default clients. They include trsh, tmon,
X  tupload, tredir, txconn and in newer versions trdate, trdated and from
X  version 2.0.0 tudpredir. This section will deal with trsh, tmon,
X  tupload, trdate and trdated.  The others each have their own section.
X  No term client will work until you have established a term link.
X
X  tmon is a simple utility to monitor the statistics of your link.  It
X  prints a time histogram of characters transmitted and received. It is
X  invoked simply as tmon. Since around version 1.11, tmon has had a bug
X  that causes some information to be garbled. Send me mail if you'd like
X  a patch to fix this.
X
X  trsh is similar to rsh. Without arguments, it spawns an interactive
X  shell on the remote system (i.e. it logs you in).  trsh is one of the
X  primary means of accessing the remote end of the link via term. If
X  given an argument, trsh executes that argument as a command on the
X  remote system. For example trsh ls would give you a listing of the
X  files in your home directory on the remote system.
X
X  tupload is the term's basic file transfer program. It will transfer a
X  file, given as its first argument, to the opposite end of the link. By
X  default, the files will be put in the same directory that you invoked
X  term from on the other side. To put files in another directory, give
X  its name as a second argument to tupload. For example, if I want to
X  put a copy of the file term114.tar.gz in /usr/tmp on the remote
X  system, I would type tupload term114.tar.gz /usr/tmp. There is no
X  client to do a download - to download files, trsh to the remote system
X  and do a tupload.
X
X  trdate is a time setting utility. it reads the time on the remote
X  machine and sets the local clock to the remote time. It must be run as
X  root.
X
X  trdated is the daemon version of trdate. When it is started in
X  rc.local it is run as daemon in which case it updates the time every 5
X  minutes. Even when there is no term connection, this daemon will start
X  up when set in the rc.local. Once a term connection is created it
X  starts updating the time.
X
X
X  5.  X and term
X
X
X  term allows users to open up X windows on the local machine from
X  clients that are running on a machine on the network. This is done by
X  using the txconn client. txconn is executed on the remote, network-
X  connected machine, it is invoked simply as txconn. It goes into the
X  background and returns a number on the standard output, this number is
X  the display number that clients should use to access the X server on
X  the local machine. An example should make this clear.  I am logged in,
X  via trsh, to my remote term host, named foo. On foo, I do the
X  following
X
X
X
X  foo$ txconn
X  Xconn bound to screen 10
X  :10
X  foo$
X
X
X
X  Now, on any host that I wish to run an X client, that is to display on
X  my local machine's X server, I do setenv DISPLAY foo:10 (for bash you
X  should use export DISPLAY=foo:10). In some cases it can furthermore be
X  necessary to do a xhost + foo on your local machine. Now when I start
X  the client, it will try to connect to screen 10 on machine foo, but
X  txconn is listening to this screen, and will forward all X protocol
X  packets via term to the X server on the local host - i.e. the window
X  will open up on your local machine.
X
X  It is possible to go the other way - run a client on your local
X  machine and have it open up a window on a remote machine on the
X  network, however we will defer explaining this until after we have
X  discussed tredir.
X
X  txconn is not terribly secure, anyone can connect to your local server
X  via term and perform all sorts of mischief. If you are worried about
X  this sort of thing, it might be a good idea to consider using xauth to
X  authorize your connections. Consult the xauth man page.
X
X  The X protocol is not very efficient, it wastes some bandwidth. This
X  is usually not a problem over an ethernet, but can be murder over a
X  modem. X11R6 is supposed to introduce a low bandwidth version of the X
X  protocol, LBX. However, this is not of much use, since R6 has not been
X  released at the time of this writing. There is a utility named sxpc
X  which compresses the X protocol, improving response over serial lines.
X  sxpc includes a write-up on how to get it working with term, and is
X  recommended. The sxpc package also explains how to use xauth, so it is
X  doubly recommended.
X
X
X  6.  tredir
X
X
X  tredir is one of term's most powerful utilities, allowing most
X  important network services to be performed over a term link. Before we
X  explain how to use tredir, it is necessary to give some background on
X  network services. We have talked about network services before, but we
X  have not said exactly what they are. Services are just that - services
X  that are provided by the network. Examples of services include telnet,
X  which provides logins between machines, the File Transfer Protocol,
X  ftp, which transfers files between machines, and smtp, the Simple Mail
X  Transfer Protocol, which is used whenever you send electronic mail.
X  Each network service has a port number associated with it.  The
X  mapping of port numbers to services is given in the file
X  /etc/services. This file should be the same on all internet-connected
X  machines.
X
X  How are these services invoked? Each networked machine runs a daemon
X  called inetd, which listens for attempts to connect to the network
X  ports. These requests can come from either the network or the local
X  machine. A network service is obtained by connecting to a particular
X  inetd port.  When a network request is made, inetd knows exactly which
X  service is involved by the port number that request is made on.  If
X  inetd is configured to do so, it then provides the relevant service to
X  the requesting connection. inetd's configuration is given by the file
X  /etc/inetd.conf, which has a list of the services that inetd provides.
X  For more information, see the man pages for inetd and inetd.conf.
X
X  You can communicate directly with network services by using telnet
X  (n.b. not termtelnet). For example, to talk to the sendmail, (or smtp)
X  daemon on machine machine_name, you can do a telnet machine_name smtp,
X  or telnet machine_name 25, (since 25 is the number assigned to smtp in
X  /etc/services). You should get a polite greeting from the daemon on
X  the remote machine. This is a very useful trick for debugging network
X  problems and checking ports redirected with tredir (see below).
X
X  tredir works very much like inetd. It runs in the background as a
X  daemon, listening to the network ports, waiting for a request. When a
X  request for a service is made, instead of providing that service, as
X  inetd does, tredir forwards the request over the term link to the
X  remote term, which makes the request over the network, returning the
X  result back over the link to the local client. tredir can forward the
X  request to any machine on the network, but by default sends it to the
X  machine on the other end of the term link.  tredir ``redirects''
X  network services over the term link (hence the name ``tredir'').
X
X  An example should make this clear. Let's redirect a local port to the
X  telnet port on the remote machine. To do this we would do tredir 2023
X  23.  Now, anyone who connects to port 2023 on the local machine will
X  be redirected to port 23 (telnet) on the remote machine.  Here's an
X  example session, the local machine is mymachine.modem.home and the
X  remote machine is netsun.
X
X
X
X  $ tredir 2023 23
X  Redirecting 2023 to 23
X  $ telnet localhost 2023
X  Trying 127.0.0.1...
X  Connected to mymachine.modem.home
X  Escape character is '^]'.
X
X
X  SunOS UNIX (netsun)
X  login:
X
X
X
X  This example is actually quite useful. If I were instead to do the
X  tredir on netsun, I could then telnet in to mymachine from the
X  network, simply by connecting to the redirected port on the networked
X  machine (using telnet) - i.e. telnet netsun 2023.
X
X  The general principle in using tredir is to redirect the desired
X  service to a machine on the network. Our next example will allow us to
X  read news on the local machine over our term link from a news server
X  on the network. News is provided by the nntp service, port number 119.
X  All decent news readers allow you to specify what port number they
X  will use, either via a configuration file or an environment variable.
X  Let's specify this local port to be 2119. Now, let's say that our news
X  server is news.domain.org. We will redirect port 2119 to port 119 on
X  news.domain.org, we will then tell our news reading software that the
X  nntp server is located at port 2119 on the local host (??). Since this
X  will depend on the news reader that you use, I will just test the link
X  with telnet instead of firing up a news reader:
X
X
X  $ tredir 2119 news.domain.org:119
X  Redirecting 2119 to news.domain.org:119
X  $ telnet localhost 2119
X  Trying 127.0.0.1...
X  Connected to mymachine.modem.home.
X  Escape character is '^]'.
X  200 news.domain.org InterNetNews NNRP server INN 1.4 07-Dec-41 ready
X  (posting ok).
X
X
X
X  If you can get this far, all you have to do is configure your news
X  reader to be able to read news via term. (n.b., if you read news like
X  this, be sure that in all your posts you set a Reply-To: header to an
X  network email address that you can be reached at, otherwise people who
X  want to get in touch with you will be sending mail to whatever (wrong)
X  data your newsreader puts in the From: header).
X
X
X  6.1.  tredir can bite!
X
X
X  The astute reader, after reading the last example will be wondering
X  why port 2119 was redirected to port 119 - since newsreaders default
X  to port 119, why could not I do a tredir 119 news.domain.org:119 and
X  skip the newsreader configuration? The answer is that all ports
X  numbered less than 1024 are ``reserved ports'', and only the superuser
X  can listen on them. If one is willing to take a security risk and make
X  tredir an suid program, or run tredir as root, then one can redirect
X  reserve ports and avoid the  of renaming services.
X
X  Another problem with using reserved ports is that inetd is often
X  already listening to these ports, and only one program at time can
X  listen to a port. In order to use such a port, you must change
X  inetd.conf so that inetd no longer listens on the port you want to
X  redirect. This is most easily done by commenting out the line with the
X  offending service by putting a # character at the beginning of the
X  line. The superuser must then send inetd a HUP signal (kill -1 inetd-
X  pid) to get it to reread its configuration.
X
X  All of the services we have been discussing so far are TCP
X  (Transmission Control Protocol) services. TCP is just a protocol for
X  sending packets (data) over a net. term versions upto 1.19 only
X  support TCP. Starting with version 2.0.0 term also supports UDP (User
X  Datagram Protocol). This makes things like NFS and archie available
X  over a term link.
X
X
X  6.2.  Stupid tredir tricks
X
X
X  In this section we will describe some of the more common uses for
X  tredir. We have already described how to redirect nntp and telnet
X  services, here we will give some more complicated examples.
X  6.2.1.  X windows
X
X
X  In a previous section, we described how to get an X client running on
X  the network to open a window on your home machine using txconn. The
X  same technique could be used on your home machine to display a client
X  on the machine at the remote end of your term link.  But how does one
X  display an X client on a network machine that is not the remote end?
X  The answer lies in knowing that X uses a particular network service
X  just like the other programs we have been discussing. An X server
X  listens for network request on a port whose number is given by the
X  formula  port = 6000 + display number, e.g. an X server managing
X  screen 0 on a machine would listen to port 6000, if it were managing
X  screen 2, it would listen on port 6002.  When you set your DISPLAY
X  environment variable to xmachine:n, your X clients will try to connect
X  to port 6000 +n on xmachine.
X
X  We can use this to trick X clients on your local machine to open up
X  windows on remote displays. Let's say I want to open up an xterm,
X  running on my local machine, on display 0 of machine xmachine, which
X  is running some place on the network.  I first pick a local display
X  number, say 2 (do not use 0, since that is what your local X server
X  will be using). I will map this display to display 0 on xmachine. In
X  terms of ports, this means I want to redirect the local port 6002 to
X  the remote port 6000.  I do the following
X
X
X
X  $ tredir 6002 xmachine:6000
X  $ setenv DISPLAY localhost:2
X  $ xterm
X
X
X
X
X  This should open up an xterm on machine xmachine.  Note that I set the
X  DISPLAY to localhost:2. This is because X clients will sometimes use
X  unix domain sockets instead of internet domain sockets, at their own
X  option, when connecting to a local display, if DISPLAY is set to :2.
X  localhost:2  says to use a tcp connection.
X
X  Note that as far as xmachine is concerned, the X request is coming
X  from the machine on the remote end of your term link (remotemachine) -
X  so if you need to authorize the connection, you should either do an
X  xhost + remotemachine on xmachine or use xauth to update the
X  .Xauthority file on your local machine for display number 2, using the
X  key from xmachine.
X
X  Again, to speed up X connections, you can use the program sxpc, which
X  includes an explanation of how to use tredir to establish the link and
X  authorize it using xauth.
X
X
X  6.2.2.  Mail with term
X
X
X  Well, you asked for it. Electronic mail has the justifiable reputation
X  of being one of the most difficult things to get working right on a
X  UNIX system. To really get term working correctly with mail means that
X  you have to understand how mail works, which is beyond the scope of
X  this document. To learn more about mail, you should consult a book on
X  UNIX system administration and/or the comp.mail.misc FAQ, available
X  for anonymous ftp on rtfm.mit.edu in pub/usenet/comp.mail.misc. There
X  are also currently two packages available for anonymous ftp on
X  sunsite.unc.edu that will help you get mail running under term - they
X  are term.mailerd+smail by Byron A. Jeff and the BCRMailHandlerXXX by
X  Bill C. Riemers.
X
X  That being said, we will give a thumbnail description of how mail
X  works.  There are two parts to getting mail running, sending messages
X  and receiving messages. We will begin with sending messages from your
X  local box to the network.
X
X  There are two classes of mail programs. The first is the mail user
X  agent (MUA). MUA's help you read, compose and send messages. Examples
X  of MUA's are elm, pine, Mail and vm.  MUA's do not really do any
X  networking, they just put the messages together - the real work of
X  sending mail is done by the second class of mail programs, the mail
X  transfer agents (MTA's). These are invoked by the MUA's. They take the
X  message, decide where to send it by looking at the address, and then
X  actually deliver it over the network.
X
X  The two most common MTA's on Linux systems are sendmail and smail. The
X  basic idea is to get your MTA to connect to another MTA running on a
X  machine on the net that will know what to do with your message. This
X  is done by redirecting a local port to the smtp port on the net
X  machine. You then have to tell you MTA to take any message it does not
X  know what to do with and send it out over the redirected port on your
X  local machine to the MTA on the remote machine, which will then route
X  your message to its correct destination.
X
X  How do we do this using smail?  We first redirect a port to the smtp
X  port on the network mail machine (mailhost):
X
X  tredir XXXX mailhost:25
X
X  here XXXX is the port number that the smail on the localhost will
X  connect to (note that I have to give this port a name in my
X  /etc/services to get smail to recognize it).  smail has several
X  configuration files that usually live in /usr/local/lib/smail.  The
X  ones we care about are config, routers and transports. Note that I am
X  assuming you have already got smail configured correctly for local
X  mail - delivery to files and pipes and such.  Again, consult the
X  documentation if you do not.
X
X  In the file config, we put the following definition:
X
X
X  smart_path=localhost
X
X
X
X  localhost is the machine that smail connects to when it does not know
X  what to do with a message.
X
X  In routers we put
X
X
X
X  smart_host:
X  driver=smarthost,
X  transport=termsmtp;
X  path = localhost
X
X
X
X  In transports we put
X
X
X
X
X
X  termsmtp:        driver=tcpsmtp,
X          inet,
X          return_path,
X          remove_header="From",
X          append_header="From: YOUR_NET_ADDRESS",
X          -received,
X          -max_addrs, -max_chars;
X          service=YOUR_SMTP_SERVICE,
X
X
X
X  In the above, the header lines change the From header in all your
X  outgoing mail to the address, YOUR_NET_ADDRESS, which is the network
X  address you want mail for sent. If more than one user is going to be
X  using your term link, you will have to do something more fancy, like
X  keep a database of local user's network addresses and insert these in
X  the From: headers.
X
X  The service line is the name of the local portnumber that you have
X  redirected to the smtp port on the network connected machine. On my
X  version of smail, I cannot just set this to a number, I have to set it
X  to a name, like ``foo'', and then define ``foo'' in my /etc/services
X  to be the number of my redirected port. If you use an suid tredir and
X  just redirect the smtp port (25), you do not need to define this.
X
X  This should be enough to get you going. If you decide to use sendmail,
X  the principles are the same but the details differ.  Ronald Florence
X  (ron@mlfarm.com) told me that the stock Sun sendmail will not send
X  multiple queued messages over a redirected port; BSD sendmail 8.6.9
X  works fine.  He made the following changes to sendmail.cf to get it
X  working with term. In his case, the default sendmail port (25) is used
X  for SMTP traffic over a local ethernet, so Internet mail is forwarded
X  to a redirected TCP port.
X
X
X  #
X  #Create the termsmtp mailer, which sends mail via a re-directed TCP port
X  #
X  Mtermsmtp,P=[TCP], F=mDFMuCXe, S=22, R=22, A=TCP $h PORTNUMBER
X
X
X
X  Here, PORTNUMBER is the number of the redirected port on the local
X  machine. This should be an unused port over 2000. We next tell
X  sendmail to which machine to connect to, and set termsmtp as the
X  default mailer.
X
X
X  #
X  # major relay mailer
X  #
X  DMtermsmtp
X  #
X  # major relay host: use the $M mailer to send mail to other domains
X  #
X  DR HOSTNAME
X  CR HOSTNAME
X
X
X
X  Here HOSTNAME is the name of your local host (does localhost work?).
X  The last entry goes under Rule 0 to forward Internet mail.
X
X
X
X
X  # Pass other valid names up the ladder to our forwarder
X  R$*<@$*.$+>$*           $#$M    $@$R $:$1<@$2.$3>$4     user@any.domain
X
X
X
X  When the term connection is established to the Internet host, run the
X  following commands on the local machine.
X
X
X  tredir PORTNUMBER internet.host:25
X  /usr/lib/sendmail -q
X
X
X
X  We now turn to receiving electronic mail using term. We will assume
X  that mail is sent to your account on the network machine mailhost. The
X  simplest solution is to just use trsh or termtelnet to log on to
X  mailhost and read your mail on there.  However, it is also possible to
X  have your mail automatically downloaded to your local machine. One way
X  to do this is to use the Post Office Protocol, (POP).  POP was
X  designed for exactly this purpose: to deliver mail to machines that
X  have intermittent network connections. To use POP, you must have a POP
X  server installed on mailhost. Assuming that you do, you can then use a
X  POP client to download your mail every few minutes. This is done, as
X  you might expect, using tredir. The POP service is 110 (note that
X  there is an older protocol, POP-2, which uses port 109; in this
X  document we describe POP-3, which is the latest version of POP). There
X  are several POP clients available. One, written using the script
X  language perl is pop-perl-1.X, written by William Perry and maintained
X  by myself - it can be found on sunsite in /pub/Linux/system/Mail.
X
X  To use POP, you redirect a local port to port 110 on mailhost and
X  configure your client to retrieve your mail from localhost using the
X  local port. As an example, we will assume that there is a POP server
X  running on mailhost. We will redirect the local port 2110, and fire up
X  the pop-perl client:
X
X
X  $ tredir 2110 mailhost:110
X  Redirecting 2110 to mailhost:110
X  $ pop
X  Username: bill
X  Password: <enter your password for mailhost>
X  Pop Host: localhost
X  Pop Port: 2110
X  Starting popmail daemon for bill
X
X
X
X
X  If you do not have a POP server available, the BCRMailHandler package
X  has a program to download your mail over a term link to your local
X  machine. I have not used it, but anyone who has is welcome to comment.
X
X
X
X  7.  Automating Things
X
X
X
X  Now that you know how to get all of your network services over term,
X  it would be nice to set things up so your link is set up and
X  configured automatically. There are basically an infinite number of
X  ways of doing this, depending on what comm program you use and how you
X  log in to your remote system.
X
X  One program, that I have not used, but I have heard is quite nice, is
X  fet: a front end for term. It is designed to log you into a remote
X  system and fire up term and all your tredir's.  Any comments on fet
X  would be most welcome.
X
X  I shall now give an example of a set of commands that use kermit to
X  log into the remote system and then performs all of the term
X  initializations. Obviously, if you use these examples, you will have
X  to modify them for your own login procedures.
X
X  The command which is actually invoked is the shell script knet, given
X  by:
X
X
X
X
X  #!/bin/sh
X  /usr/bin/kermit -y $HOME/.kerm_term > $HOME/klog < /dev/null 2>& 1
X  exec $HOME/bin/tstart >> $HOME/klog 2>& 1
X
X
X
X  The script .kerm_term is given by:
X
X
X
X  pause 2
X  # The number you want to dial
X  output atdtXXXXXXX \13
X  # Login to the terminal server
X  input 145 {name: }
X  output MYNAME \13
X  input 3 {word: }
X  output MYPASSWORD \13
X  input 5 {xyplex>}
X  # Make the line transparent
X  output term telnet-t \13
X  output term stopb 1 \13
X  # Connect to the remote host
X  output telnet remotehost.somedomain.org \13
X  input 10 {ogin: }
X  output MYOTHERNAME \13
X  input 3 word:
X  output MYOTHERPASSWORD \13
X  pause 5
X  # Fire up term on the remote host
X  output exec term -s 38400 -l $HOME/tlog -w 10 -t 150  \13
X  ! /usr/bin/term -r -l $HOME/tlog -s 38400 -c off -w 10 -t 150 < /dev/modem > /dev/modem &
X  # Open other clients here
X  suspend
X  !killall -KILL term
X
X
X
X  and finally, the script tstart which fires up the term clients is
X  given by
X
X
X
X
X
X
X
X
X
X
X  #!/bin/sh
X  #
X  # This lets mail get out, can read news here, can pick up my mail here
X  #
X  /usr/local/bin/tredir 2025 25 2119 newshost:119 2110 pophost:110
X  #
X  # So I can open up Xwindows here
X  #
X  /usr/local/bin/trsh -s txconn
X  #
X  # So I will receive mail....
X  #
X  /usr/local/bin/pop
X  #
X  # Clean out the queue, in case of boo-boos
X  #
X  /usr/bin/runq
X  #
X  # Done now
X  #
X  echo ^G^G > /dev/console
X
X
X
X  When finally you want to close the connection, you resume and
X  terminate kermit. The last line of the script kills the local term and
X  returns the system in its initial state.
X
X  ( Note of the author: instead of doing '!killall -KILL term', I think
X  it should be possible just to do '!tshutdown'. This should also work?)
X
X  As I said, there are zillions of ways to do this, these are just meant
X  as examples to get you started.
X
X
X  8.  Other programs and term
X
X
X  A number of programs can already be used in combination with term. To
X  become these programs there are two possibilities:
X
X
X  1. Use ready made binaries.
X
X  2. Port and compile the sources.
X
X
X  8.1.  Use ready made binaries
X
X
X  Some programs are modified to work with term. They include telnet,
X  (nc)ftp, Mosaic and many others. Binaries of these programs can be
X  found on sunsite.unc.edu in /pub/Linux/apps/comm/termstuff and in
X  /pub/Linux/apps/comm/term/term/extra.
X
X  Most of these programs are compiled form term 1.17 or earlier. They
X  should, however, still work with the newer versions of term as
X  explained earlier.
X
X
X
X  9.  Term speed table
X
X
X  Thanks to Bill McCarthy we now have a table with term speed
X  information for different modems, term versions and connection
X  conditions. Its purpose is to give new and experienced user some idea
X  what other folks are using and the results they are getting.
X
X
X
X                                  LINUX TERM CHART 8/14/94
X
X
X       |___modem speed/make___|___line speed__|__avg cps__|__high__|__term ver_|
X       | 1)  USR SP 14.4      |   9600        |  950      |  963   | 1.1.7     |
X       | 2)  USR SP 14.4      |  14400        | 1376      |  n/a   | 1.18p06   |
X       | 3)  Zoom 2400        |   2400        |  220      |  230   | 1.19      |
X       | 4)  Boca V.32bis 14  |  57600        | 1400      |  n/a   | 1.01/09?  |
X       | 5)  Viva 14.4        |  14400        | 1300      |  n/a   | 1.16      |
X       | 6)  USR SP 14.4      |  14400+       | 1550      | 1680   | 1.19      |
X       | 7)  Intel 14.4 Fax   |  14400        | 1400      | 1650   | 2.0.4     |
X       | 8)  cable tv hookup  |  57600        | 1500      | 1800   | 1.18p06   |
X       | 9)  Twincom 144/DFi  |  57600        | 1500      | 4000?  | 2.0.4     |
X       | 10) USR SP 14.4      |  14400        | 1200      | 1500   | 1.08      |
X       | 11) cable tv hookup  |  19200        | 1300      | 1800   | 1.1.9     |
X       |-----------------------------------------------------------------------|
X
X       +Command flags/termrc settings:
X
X       1) default escapes   2) window 5       3) baudrate 2400    4) n/a
X          baudrate 9600        timeout 200       window 3
X          window 10                              noise on
X          timeout 150
X
X       5) compress off      6) baudrate 19200  7) ignore 19+17    8) compress off
X          window 10            compress on        window 4           escape 0, 13,
X          timeout 150                             timeout 90         16-19, 255
X          baudrate 38400                                             baudrate 0
X                                                                     shift 224
X                                                                     flowcrtl 500
X                                                                     window 10
X                                                                     timeout 70
X                                                                     retrain on
X                                                                     breakout 24
X       9) compress off     10) compress off      11) baudrate 19200
X          baudrate 57600       baudrate 38400        compress on
X          window 10            escape 17, 19         shift 224
X          timeout 200          remote                escape 0, 13 16-17
X          noise on                                   19, 255
X          share on                                   window 10
X          remote                                     timeout 40
X
X       Escaping characters on one site also implies ignoring them on the other site.
X
X
X
X
X
X  10.  Term clients used in the world
X
X
X  Below a list of application running with term is given. I am not
X  stating that this list is complete so any completion is welcome. As
X  far as possible I will present the site and directory where the
X  application can be found (all to my knowledge). When I state
X  sunsite.unc.edu as place to find the application I mean that you can
X  find it in one of the following two directories:
X
X
X  1. /pub/Linux/apps/comm/termstuff
X
X  2. /pub/Linux/apps/comm/term/term/extra
X
X  Here we go :-)
X
X
X
X       tupload             term package
X       trsh                term package
X       tmon                term package
X       tredir              term package
X       tudpredir           term package (versions 2.0.0 and higher)
X       txconn              term package
X       trdate(d)           term package
X       tshutdown           term package
X       libtermnet          term package
X       termftp
X       ncftp               sunsite.unc.edu
X       fsp                 sunsite.unc.edu
X       lynx                sunsite.unc.edu
X       Mosaic              sunsite.unc.edu:/pub/Linux/system/Network/Info-systems
X       chimera
X       finger              sunsite.unc.edu
X       rlogin
X       tin                 sunsite.unc.edu
X       slurp               sunsite.unc.edu
X       xgopher
X       gopher              sunsite.unc.edu
X       xboard              sunsite.unc.edu
X       ircII               sunsite.unc.edu
X       whois               sunsite.unc.edu
X       xwebster            sunsite.unc.edu
X       termtelnet          sunsite.unc.edu
X       term.mailerd+smail  sunsite.unc.edu
X       BCRMailHandlerXXX   bohr.physics.purdue.edu:/pub/bcr/term
X       sxpc                ftp.x.org:/R5contrib
X       xarchie             (compiled by some one, term version 2.0.x)
X       archie              (compiled by some one, term version 2.0.x)
X
X
X
X
X
X  11.  Things to remember
X
X
X  In this section I try to present you a list of usefull ftp addresses,
X  URL's etc. where you can find software and information about term.
X
X  ftp:
X
X  sunsite.unc.edu:/pub/Linux/apps/comm/term/<whole-directory-tree>
X  sunsite.unc.edu:/pub/Linux/apps/comm/termstuff
X  sunsite.unc.edu:/pub/Linux/docs/HOWTO
X  bohr.physics.purdue.edu:/pub/bcr/term
X
X
X
X  URL:
X
X  http://sunsite.unc.edu/mdw/HOWTO/Term-HOWTO.html
X  http://zeus.cs.kun.nl:4080/term-howto/Term-HOWTO.html
X
X
X
X  netnews:
X
X  comp.os.linux.announce           announce of new Term-HOWTO
X  comp.os.linux.help               ask your questions about term here
X  comp.os.linux.misc               or here
X
X
X
X  When you start asking questions on netnews please make sure that you
X  present people in the groups as much information as they need to solve
X  your problem (term version number, way you set up your connection
X  etc.). At this moment many term versions are in use and all have their
X  specific and common problems. Therefore, when you want a useful answer
X  at least state the version of term you are using. Otherwise, in some
X  cases only wild guesses are possible to help you save your problems.
X
X
X  12.  Other Stuff
X
X
X  Some things that might be included:
X
X
X  o  libtermnet.a
X
X  o  Suggestions
X
X  Anyways, if you have comments, criticisms, suggestions, or anything
X  else to say about this document, please fire away. As Bill Reynolds is
X  very busy at this moment I, Patrick Reijnen, have taken over the the
X  authorship of the Term-HOWTO. I can (currently) be reached at
X  patrickr@sci.kun.nl or patrickr@cs.kun.nl.
X
X
X  13.  Acks
X
X  Thanks go to a lot of people. First and foremost to Michael O'Reilly
X  and all the developers of term, who have provided us with such a great
X  tool. I would also like to thanks everyone who gave feedback and
X  contributed to this HOWTO, they include Ronald Florence, Tom Payerle,
X  Bill C. Riemers, Hugh Secker-Walker, Matt Welsh, Bill McCarthy, Sergio
X  and everybody forgotten to mention.
END_OF_FILE
  if test 55203 -ne `wc -c <'Term.HOWTO'`; then
    echo shar: \"'Term.HOWTO'\" unpacked with wrong size!
  fi
  # end of 'Term.HOWTO'
fi
if test -f 'connect.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'connect.c'\"
else
  echo shar: Extracting \"'connect.c'\" \(4701 characters\)
  sed "s/^X//" >'connect.c' <<'END_OF_FILE'
X#define I_ERRNO
X#define I_SYS
X#define I_IOCTL
X#define I_STRING
X#define I_SOCKET
X#define I_SIGNAL
X#include "includes.h"
X
Xtypedef struct {
X  int client; 
X  int server;
X  struct Buffer from;
X  struct Buffer to;
X} Con;
X
Xstatic void sig_ignore(int dummy) {
X  signal(SIGPIPE, sig_ignore);
X}
X
Xvoid do_connect(int num, int *svs, int (*get_server)(int n)) {
X  int max, num_cons = 0;
X  int serv, j;
X#if defined(STREAMS_PIPE) || defined(X_STREAMS_PIPE)
X  int dumb;
X#endif
X  Con *cons = 0;
X
X  serv = connect_server(term_server);
X  if (serv < 0) {
X    fprintf(stderr, "Couldn't contact term server.\n");
X    exit(1);
X  }
X
X  if ((j=fork()) < 0) 
X    exit(1);
X  else if (j)
X    exit(0);
X
X  signal(SIGPIPE, sig_ignore);
X
X  close(0);
X  close(1);
X  close(2);
X  lose_ctty();
X  chdir("/");
X  
X  for (max = 0; max < num;++max)
X    set_nonblock(svs[max]);
X
X  while (1) {
X    fd_set in, out, except;
X    Con *c;
X    int i, ret, loop;
X    
X    FD_ZERO(&in);
X    FD_ZERO(&out);
X    FD_ZERO(&except);
X    max = -1;
X    for (i = 0; i < num;++i) {
X      FD_SET(svs[i], &in);
X      if (max < svs[i]) max = svs[i];
X    }
X
X    FD_SET(serv, &except);
X    FD_SET(serv, &in);
X    if (serv > max) max = serv;
X    
X				/* Ok. Build a list of all the sockets */
X				/* we want to look at.. */
X    for (i = 0, c = cons; i < num_cons;++i, ++c) {
X      if (c->client >= 0) {	/* If this socket can we read and */
X				/* written..  */
X	if (c->to.size) {	/* If there is something to go to it */
X				/* then select for writing. */
X	  FD_SET(c->client, &out);
X	  if (c->client > max) max = c->client;
X	} else if (c->server >=0) { /* Else select for more data if we can. */
X	  FD_SET(c->server, &in);
X	  if (c->server > max) max = c->server;
X	} else {		/* ok there was nothing in the buffer, */
X				/* and we couldn't get anymore , so */
X				/* just close. */
X	  close(c->client);
X	  c->client = -1;
X	}
X      }
X      if (c->server >= 0) {
X	if (c->from.size) {
X	  FD_SET(c->server, &out);
X	  if (c->server > max) max = c->server;
X	} else if (c->client >=0) {
X	  FD_SET(c->client, &in);
X	  if (c->client > max) max = c->client;
X	} else {
X	  close(c->server);
X	  c->server = -1;
X	}
X      }				/* if if server >=0 */
X    }				/* Of for() */
X
X    select(max+1, &in, &out, &except, 0);
X
X				/* Check for term going away... */
X    if (FD_ISSET(serv, &except) || FD_ISSET(serv, &in)) {
X				/* Ok. Critical . Close every thing.*/
X      exit(0);
X    }
X    for (loop = 0; loop < num;++loop)
X      if (FD_ISSET(svs[loop], &in)) { /* new connection */
X#if defined(UNIX_SOCKET) && !defined(NO_UNIX_DOMAIN) && !defined(NFS_MOUNT)
X	struct sockaddr_un dum;
X#else
X	struct sockaddr_in dum;
X#endif
X	int sdum = sizeof(dum),i ;
X	for (i = 0; i < num_cons;i ++)
X	  if (cons[i].server < 0 && cons[i].client < 0) break;
X        if(i>MAX_CLIENTS) continue;
X
X	if (i >= num_cons) {
X	  if (!cons)
X	    cons = (Con *) malloc(sizeof(Con));
X	  else
X	    cons = (Con *) realloc((char *) cons, (num_cons + 1) *
X				   sizeof(Con)); 
X	  memset(&cons[(i = num_cons++)],0,sizeof(Con));
X	}
X	c = &cons[i];
X#if defined(STREAMS_PIPE) || defined(X_STREAMS_PIPE)
X	c->client = CheckClientConnection(svs[loop]);
X	if (c->client != -2) {		/* we have a streams pipe */
X		if (c->client == -1) {
X			fprintf(stderr, "can't add client\n");
X			continue;
X		} /* fall through to after "accept" */
X	} else	/* not a streams pipe */
X#endif
X	c->client = accept(svs[loop], (struct sockaddr *) &dum, &sdum);
X	
X	if ((c->server = get_server(loop)) <0) {
X	  perror("Couldn't open term");
X	  close(c->client);
X	  continue;
X	}
X	
X	set_nonblock(c->server);
X	set_nonblock(c->client);
X
X	
X	c->to.size = c->to.start = c->to.end = 0;
X	c->from.size = c->from.start = c->from.end = 0;
X
X	add_to_buffer(&c->to, 0);
X	get_from_buffer(&c->to);
X	add_to_buffer(&c->from, 0);
X	get_from_buffer(&c->from);
X
X      }
X    
X    for (i = 0, c = cons; i < num_cons;++i, ++c) {
X      if (c->client < 0) continue;
X      if (FD_ISSET(c->client,&in))
X	ret = read_into_buff(c->client, &c->from, 0);
X      else if (FD_ISSET(c->client, &out))
X	ret = write_from_buff(c->client, &c->to, 0);
X      else continue;
X				/* Handle possible error condition */
X      if (ret <=0 && termerrno) {
X				/* an error has occurred or a stream */
X				/* has closed. Close connection. NYF*/
X	close(c->client);
X	c->client = -1;
X	continue;
X      }
X    }
X
X    for (i = 0, c = cons; i < num_cons;++i, ++c) {
X      if (c->server < 0) continue;
X      if (FD_ISSET(c->server, &out)) 
X	ret = write_from_buff(c->server, &c->from, 0);
X      else if (FD_ISSET(c->server, &in))
X	ret = read_into_buff(c->server, &c->to, 0);
X      else continue;
X				/* Handle possible error condition */
X      if (ret<=0 && termerrno) {
X	close(c->server);
X	c->server = -1;
X      }
X    }
X  }
X}
X
END_OF_FILE
  if test 4701 -ne `wc -c <'connect.c'`; then
    echo shar: \"'connect.c'\" unpacked with wrong size!
  fi
  # end of 'connect.c'
fi
if test -f 'jump/jump.undefs' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jump/jump.undefs'\"
else
  echo shar: Extracting \"'jump/jump.undefs'\" \(33 characters\)
  sed "s/^X//" >'jump/jump.undefs' <<'END_OF_FILE'
X6600e060 D __NEEDS_SHRLIB_libc_4
END_OF_FILE
  if test 33 -ne `wc -c <'jump/jump.undefs'`; then
    echo shar: \"'jump/jump.undefs'\" unpacked with wrong size!
  fi
  # end of 'jump/jump.undefs'
fi
if test ! -d 'old' ; then
    echo shar: Creating directory \"'old'\"
    mkdir 'old'
fi
echo shar: End of archive 1 \(of 6\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
