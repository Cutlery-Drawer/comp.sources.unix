Newsgroups: comp.sources.unix
From: bcr@physics.purdue.edu (Bill C. Riemers)
Subject: v28i160: term-2.1.2 - slip-like functionality for a pair of UNIX hosts, Part03/06
References: <1.784076477.10661@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: bcr@physics.purdue.edu (Bill C. Riemers)
Posting-Number: Volume 28, Issue 160
Archive-Name: term-2.1.2/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  CHANGES jump/jump.vars main.c
# Wrapped by vixie@gw.home.vix.com on Sat Nov  5 14:58:30 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 3 (of 6)."'
if test -f 'CHANGES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'CHANGES'\"
else
  echo shar: Extracting \"'CHANGES'\" \(50384 characters\)
  sed "s/^X//" >'CHANGES' <<'END_OF_FILE'
XFixes to 2.1
X  - Various tdownload fixes submitted by Chris Metcalf.
X
X
X2.0 -> 2.1
X  - Added Chris Metcalf's tdownload
X  - Applied Olaf's tmon "patch"
X  - Switched to UNIXLIKE priority by default  (we'll find out if this is
X    reasonable)  If things are sluggish this release, we'll have to switch
X    back.
X  - Gave higher priority to small packets.
X  - Corrected client # used in term_connect() with udp sockets
X  - More error messages, clean-up.  term_herror() split to include
X    a term_strherror()
X  - Added hostname passing with the version #'s to help reduce client startup
X    times.
X  - Made term_send() call term_sendto() so udp messages are always handled
X    correctly.
X  - Hopefully fixed trsh not to have Broken pipe errors, and early closings.
X  - Tupload will now copy file permissions and time stamps.  While uploading
X    a now file, it will have permissions 000 to keep others from trying to
X    read the file.
X  - C_OPEN, C_UPLOAD, and C_DOWNLOAD have been merged...  
X  - C_DOWNLOAD will now return C_STAT information, and then proceed to dump
X    the file.  Since in many case C_DOWNLOAD was closing early, it will 
X    no longer close at the EOF.
X  - TERMCLIENTS is created to pass sockinfo to term children.
X  - Added 2.0.5 and 2.0.6 fixes
X  - Added Chris Metcalf's tupload and tdownload patches
X  - Modified configure to work with rcs version control
X  - Added Ami Fischman's patch for ISC support (SVR3.2 clone)
X  - Added Chris Metcalf's patches for:
X     -floating stopbits
X     -new dll path
X     -tshutdown hangup feature
X  - Fixed term_connect() problem with udp connections
X  - Changed static clients to the same binary to help with disk quotas
X  - Automated my version updating procedure in Makefile.in
X  - Added a check for ERR_BLOCK for non-blocking connect.  I know this is
X    needed for TitanOS and suspect it is needed for a few other OS's too.
X  - Tdownload patched to use mode 0 for while downloading
X
X2.0 -> fixes
X  - "<= 20000" corrected to "< 20000" and printing of version # corrected
X  - Several minor Makefile.in fixes.
X  - reading of DISPLAY corrected in txconn
X  - Corrected putenv to be term_putenv to avoid malloc() problems
X  - Eliminated the compiler warning at the end of udpredir.c
X  - jump-update doesn't seem to work, so I've commented it out.
X  - put escape checking back in do_ignore
X  - To avoid prototype problems, I explicitly changed the getopt stuff to
X    term_getopt.
X  - Explicitly changed all free(x) commands to if(x)free(x) to avoid SunOS
X    problems with NULL pointers
X  - Minor makefile patch to handle non-existent directories properly
X  - Removed "strcasecmp()" commands I accidently left in.
X  - CPU fix for trdated, and minor fix to sendto_from_buff() 
X  - Another attempt to fix the breakout_string to work with a shift value
X  - Fixed term_connect udp problem
X  - Limited PIPE_BUF to 30k to avoid AIX problems, thanks to Joerg Passenberg
X 
Xpre-2.0 -> 2.0 changes:
X	- tmon's priority raise to 15
X	- baudrate checking added for bsd systems
X	- RC_OPTIONS was too large
X	- The sockinfo array is now always initialized first in termnet 
X	  functions.
X	- Very large "udp" messages may be truncated if necessary.  This
X	  should speed things up a bit.
X	- hpux config fix, end seteuid setegid replaced to setuid and setgid.
X
X1.19	This is really 1.18pl07 renamed.  This should be considered Gamma, and
X	is the final release of the version 1 series.
X
XNOTE:	Just to really confuse things, pre-1.19 will now become
X	pre-2.00, and what would have been 1.18pl07 will be 1.19.
X	As an undesired side-effect all previous alpha versions will now
X        be broken.
X
Xpre-1.19 fixes:
X	- version # fix
X	- C_PORT fixed
X	- fixed QNX implementation
X	- included MachTen config options
X	- patch to pty.c to fix SCO and hopefully sol2
X	- recvfrom patch to prevent problems when multiple messages arrive
X	  at the same time.
X	- Problems installing static libs fixed
X	- Problems with missing initializations in recvfrom, sendto and link.c
X          fixed
X	- Corrected "terminate" to work with a shift value
X	- Corrected a core dump problem in link.c from gethostbyname() failures
X	- More pty.c fixes from Chris Metcalf
X	- Minor patch so udp doesn't bomb when term_bind() fails, but the
X	  program continues anyways.  (Or term_bind() is never called.)
X	- Corrected most of the clients to report an error when they can't
X	  connect to a socket.
X	- Two minor SCO fixes.
X	- Another minor udp fix, and a rewind_buffer fix.
X	- Fix to share/non-share support so things should work correctly
X	  without TERMMODE in most cases.
X	- Added convex c-series supercomputer patch thanks to
X          daveg <gillam@zeppelin.convex.com>.
X	- Added Chris Metcalf's tupload patch
X	- Added Danny Gasparovski's tudpredir with a small patch
X	- Final documentation changes and upload fix, "termnet" fix.
X
X1.18 -> pre-1.19
X - UDP support added thanks to:
X 	 Danny Gasparovski <u923168@student.canberra.edu.au>
X - Shared library support:
X	Davor  Jadrijevic <davor%emard.uucp@ds5000.irb.h> wrote the original
X	shared library support.  Most of his code was replaced when we switched
X	from a Makefile to a Makefile.in format, but he is still the one who
X	got things started.
X
X	Shared library Support for:
X		Linux	==> Chris Metcalf, and Davor Jadrijevic
X		SunOS	==> Chris Metcalf
X        	NetBSD	==> Sorry I lost your name & address.
X
X - New configure script and Makefile.in thanks to Chris Metcalf
X - New functions:
X	term_herror	==> Chris Metcalf
X        udp related stuff ==> Danny Gasparovski 
X - New OS support:
X 	QNX 		==> Brian Campbell <brianc@qnx.com> 
X - Termrc options/changes:
X	o "quiet", "packetsize" thanks to Chris Metcalf
X	o Added "blocksize", "increment", "shell", "stopbits" 
X	o Eliminated "retrain" and "nonblock"
X - Client changes:
X	o Patches to improve the accuracy of tupload's progress report and
X	  transmission speed thanks to Chris Metcalf
X	o More information added to "tmon" 's output.
X	o Exit status fixes
X	o txconn now accepts the default display as an argument
X	o txconn now returns the full display name.
X - Config options/macros changes:
X	SHAREDIR	==> Should always be defined
X        USERSHARE	==> Eliminated
X	PRIVILEGED_MODE	==> Eliminated
X	PUBLIC_MODE	==> Eliminated
X	NON_CONNBLOCK	==> Replaced with the reverse USE_CONNBLOCK
X - Serial changes:
X	o Use the detected the serial baudrate on non-BSD systems instead of
X          2400 as the default.
X	o Default stop_bits value changed from 2 to 1 which is really now
X	  treated as a half stop bit.
X	o New blocksize variables to help keep term from creating serial
X	  overruns when writing too much to the modem at once.
X	o Maximum packet size option for those who need it.
X	o Collisions option added for those who have problems sending and
X	  receiving at the same time.
X - Transmission protocol fixes:
X	o Rewind buffer added so term can recover better from errors.
X	o More meaningful transmission error messages.
X        o The breakout string will no longer be echo-ed or sent in a packet
X	  un-escaped until term has accepted it as a legitimate shutdown
X	  command.  Also uppercase letters are not echoed as lowercase on the
X	  remote.
X	o A breakout string instead of a breakout character is used so you
X	  can set something like 'NO CARRIER' to terminate your term server.
X	o The maximum packet size has been increased from 253 to 256
X - Command protocol fixes/changes:
X	o Several functions corrected to return a status or not to return
X	  a status.
X	o Commands like C_CLOSE now accept a client #.
X	o send_command() will no longer wait for commands that previously
X	  always returned I_OK
X	o send_command() will switch from non-blocking IO to blocking IO and
X	  back again when necessary.
X 	o Added C_PUTENV so C_EXEC clients can inherit "txconn"'s redirected
X          display.
X - Internal fixes/changes:
X        o The 1/20th of a second update time is changeable with the increments
X	  rc option.
X	o Changed to a primary variable of max_cps instead of baudrate
X	  and changed baudrate to an unsigned long.
X	o Eliminated some of the arbitrary sizes by introducing I_LIMITS
X	o Switch back to using INADDR_ANY when binding to ports.
X	o read_into_buff will now do reallocations, so BUFF_INC_SIZE was 
X	  replaced with PIPE_BUF
X	o Added a MAX_BUFF size of 32727 to help prevent allocation errors.
X	o Round-robin priority between -20 and 20 is now used for term clients.
X	o Default to use non-blocking connections.
X	o General clean-up of the ring buffer code.
X 	o Thanks to neumann@watson.ibm.com (Gustaf Neumann) who found the txconn
X	  tredir bug was that cons[] elements were not being initialized.
X	o pty.c re-organized and modified with QNX support
X - Termnet fixes:
X	o termnet will test for the file "/etc/termnet" or the environment
X	  variable "TERMMODE" before trying to use full term support.
X	o security bug fixed in term_rcmd()
X	o several new functions added, and atexit() is used to insure term
X	  clients are closed.
X 	o New addressing:  127.0.0.254 == "remotehost"
X
X1.18 Fixes
X - str_version modified to allow patch level releases like this.
X - replaced #include with #define for the first three lines in linecheck.c
X - added 'A' to the argument list for getopt in main.c
X - fixed term_rcmd to use "remotehost"
X - At Stephen J. Roznowski's prompting fixed upload.c and C_STAT to use
X   correct variable types for file sizes and permissions.
X - Following fixes by Chris Metcalf:
X    o separate ULTRIX target for INSTALL="install -c"; and ULTRIX for magic
X      uname-based auto install.
X    o next definition change to use putenv.o not putenv.c as an object
X    o else true; added to Makefile
X    o link.c --> some (char *) casts to keep next happy
X    o lib.c --> changed %.2lu to %02lu
X    o various manual page fixes
X - Hopefully fixed bind_tcp not to fail even if /etc/hosts is wrong.    
X - cleaned up tupload's final report.
X - correct a bug in termnet.c that occasionally caused loss of data during
X   connections.
X - Same fix for term_rcmd, and a security problem fix in term_rcmd
X - Added IRIX definition  (I know this is new, not a fix...)
X - Fixed a problem with USERSHARE causing segmentation faults. again
X - Added Chris Metcalf's fix to fix a buffer overflow problem.
X - Fixed TERMSHARE and TERMDIR path parsing.
X - Added BOONE BARRY EDWARDS for for Dynix/ptx 
X - Split open_pty in an attempt to make it more readable
X - A little more cleaning of include files.
X - Added 'terminate' to the termrc options, so I can specify 'NO CARRIER' to
X   terminate my term connection instead of '00000'.
X
X1.17 - 1.18 (bcr@physics.purdue.edu)
X - Fixed "aix"'s Makefile definition.
X - Fixed a serious problem with "trsh".
X - Extensively cleaned up the include files, and eliminated seteuid and
X   references to USE_SETGID
X - Modified build_args() and term_rcmd() to pass terminal type.
X - Changed BUFF_INC_SIZE to 2048 from 1024.  This seems to speedup tupload.
X - Changed TR: to ETA: in upload.c
X o Applied patches:
X    DYNIX/PTX support	BOONE BARRY EDWARD <boone@a.cs.okstate.edu>
X    NetBSD patches	Stephen J. Roznowski <sjr@zombie.ncsc.mil>
X
X o Added the following termrc options:
X    "login on/off"	default "on"	replaces -DLOGIN_SHELL
X    "delay #"		default 20000	reduces CPU usage
X    "stopbits #"	default 2	allows correct computation of
X					transmission speed
X    "nonblock on/off"	default on	allows users to deactivate
X					non-blocking IO
X    "retrain on/off"	default off	Tells term to try to adjust timeout
X					and window size values.  Takes about	
X					50k-100k to reach optimal values.
X 
X o Added the following files:
X    putenv.c		Only need if your system libraries doesn't have it.
X    term_getopt.c	Always used so options are parsed the same for all OS's.
X    trdate.c		Allows trdate and trdated (thanks to Kevin Lentin) to pass
X			remote system time.
X
X o Rewrote:
X    read_rc()		It's now easier to add new options, and inline comments
X			always work.  
X    term_getsockname()		Now uses C_GETSOCKNAME
X    term_gethostbyname()	Now uses C_GETHOSTNAME
X
X o Fixed:
X    C_GETSOCKNAME	Didn't work with term117
X    C_GETPEERNAME	Didn't work with term117
X    shared versions	If you have _POSIX_SAVED_IDS, term will be much more
X			secure now.
X
X o Added define options:
X    TERM_NFS_DIR	for those using term directory's on NFS mounted
X			directories.
X    N_PACKETS		adjust if you need window sizes greater than 16.
X
X o Added features:
X    Environmental variable passing 	Modified: C_EXEC and C_PTYEXEC
X    Version # passing.			Pre-term117o versions are assumed
X					to be term108.
X    "remotehost"			Short for the other machine's name.
X					i.e. "telnet remotehost"
X 
X1.16 - 1.17 (bcr@physics.purdue.edu)
X - More changes to the TERMIOS stuff
X - Added socket address passing with C_ACCEPT.
X - Added patches suggested by chengb@craft.camp.clarkson.edu (Bruce) for AIX
X - Added the patch by Chris Metcalf to:
X  o  support for both "universe" models under HCX/UX; this allowed me to
X     bag the "universe ucb" I put in the Makefile, and take out the 
X     restrictive comment in config.h under hcx.  Term seems to compile
X     fine under both versions.  I ifdef'ed out the initial "Remote: term"
X     message under hcx since this makes it hang when running under "test".
X
X  o  Portability to NeXT 2.1, which doesn't have S_IXUSR and S_IXGRP.
X
X  o  reworked support for the hideous terminal_new() crock (all my fault).
X     The whole static struct termios thing is a tremendous lose.
X     Different  disagree about field placement (e.g. c_line, and
X     the VFOO fields of c_cc) and name of symbolic constants to use
X     (e.g. values for c_line).  The right thing to do is to pull in
X     the oldterm as the default, then update the fields you actually
X     know about to good values.  I also finally did the right thing
X     and added the equivalent support for the BSD model.  Note that I
X     also change ECHOCTL to be 0 if it's undefined, since some other
X     random hex value is likely to correspond to some unwanted tty mode.
X     (The #ifdef Next stuff disappeared, but I don't think "Next" is
X     defined on the NeXT anyway, just "NeXT".)
X
X  o  I added an ultrix target in the Makefile (just like OSF/1 or SGI).
X     I also changed SHAREDIR to be under /usr/local, along with the rest
X     of the default directories; although people will probably change
X     these to match their local structure anyway, it ought to be consistent.
X
X  o  A bunch of changes to make the -Wall compile cleanly under Linux.
X     These include %d vs. %ld to match argument size, variable
X     initialization where gcc doesn't realize the variable can't really
X     be used uninitialized, adding parentheses around && and ||, removing
X     variables and function calls that aren't used, and adding includes
X     (either explicitly or by forcing I_IOCTL) to prototype functions.
X     It turns out you don't want to include <sys/ioctl.h> as well as
X     the termios stuff on SunOS 4.x, so I explicitly checked for that.
X
X  o  Changes to allow term to compile with the HCX/UX C compiler.  
X     Constructs like "=-" and "=+" used to be synonymous with "-="
X     and "+=", and the HCX/UX compiler warns about them and then does
X     the wrong thing.  So I added whitespace around the "=" to fix it.
X     (I also did two other minor portability mods:  I changed "index"
X     to "strchr" in termnet.c for consistency, and replaced "strdup"
X     with "malloc/strcpy" to avoid requiring it to be in the library.)
X
X  - Added Derek Atkins patch for C_GETHOSTNAME, C_GETSOCKNAME, and
X    C_GETPEERNAME
X  - wrote translation functions str_to_sockaddr(), str_to_hostent(),
X    hostent_to_str(), sockaddr_to_str() and modified routines to use
X    these.
X  - Modified term_gethostname() to use C_GETHOSTNAME
X  - Modified term_connect() not to expect special address #'s for 
X    remote hosts. 
X  - Added term_gethostbyaddr()
X  - Corrected term_accept() to do C_DUMB...  
X
X1.15 - 1.16 (bcr@physics.purdue.edu)
X - added the NO_PTYEXEC option so trsh now works without the '-s' option
X   when connecting to TitanOS
X - Modified Makefile to include TitanOS.
X - Modified Makefile to have the rule "installshare" and other minor
X   changes needed for shared support.
X - Modified main.c and client.c to handle shared mode
X - Modified anyplace I saw an exec or a open to swap userid (if possible).
X - Modified clients for setuid and setgid security.
X - term_gethostbyname, term_connect, and term_rcmd added to client.c
X - modified client.h to reflect these changes.
X - fixed trshell.c to default to "rlogin localhost".
X - Added additional functions term_bind, term_accept, term_close, term_shutdown
X - Added the command C_BINDS to allow AF_INET sockets to connect to a UNIX
X   domain socket.
X - Modified C_BINDN to work for non-zero port #'s.
X - Moved the new networking stuff into termnet.h and termnet.c
X - Renamed the global "debug" to "term_debug" to avoid conflicts.
X - Fixed? N_FTP problem.
X - Added BSDI support.
X - Raised the default MAX_CLIENTS to 64
X
X1.14 --> 1.15
X	
X	Non-blocking connections. Now only the one client hangs when
X	doing a slow TCP connect, instead of all of them. Thanks to
X	Steven Grimm (koreth@hyperion.com)
X
X	Finally got SCO support in. Many thanks to Tom Kelly (tom@ancilla.uucp)
X		for patches, and considerable patience.
X	This introduces a major protocol change, that will break txconn
X	if both ends are not upgraded. xconn will now send C_X_SERVER instead
X	of C_SOCKET. So unless you term server understands this, it will
X	break.
X
X	added Term.HOWTO. Thanks to Bill Reynolds
X
X	added tmon fixes. thanks to The Crouton Man
X		 (crunchy!croutons@dartmouth.edu)
X
X	Fixed cast in pty.c for AIX and other sensitive compilers.
X
X	Fixed bug in BSD pty handling. If master was available, and slave
X	wasn't, term went into infinite loop.
X
X	Removed various warnings from pty.c
X	Removed some automatic initialization because it seems
X	there are a lot of brain-dead of compilers out there still.
X	
X	Lots of nice stuff from Chris Metcalf <metcalf@catfish.lcs.mit.edu>
X	among them:
X		support for HCX/UX 5.1
X		removed various warnings.
X		changed open_pty() to use preset default, not terms
X		initial settings. This will cure termios problems when
X		term was run from seyon or some such.
X		various fixes to docs.
X
X	
X1.13 --> 1.14
X
XHopefully fixed compile errors for NeXTSTEP on intel..
X
XChdir fixed. Thanks to Tom May (ftom@netcom.com)
X
XCompiles mostly clean on suns again. Thanks to lot of people telling me
X	it was broken. :)
X
XMore osf1 support from Craig I Hagen. (hagen%opine@cs.umass.edu)
X
XMacro correct. This fixes problems with tredir + termftp. Thanks
X	to Rick Sladkey (jrs@world.std.com)
X
XFixed login_shell. thanks again to Rick Sladkey.
X
XPlease send me a postcard.. (read README) :)
X
X1.12 --> 1.13
X
XBug in tredir w.r.t. buffering fixed. Was causing segv's. Thanks to
X	Glenn (glenn@physics.su.oz.au)
X
X1.11 --> 1.12
X
XBug in pty handling fixed. If opening a master pty succeeded, but opening
Xthe slave failed, then term wouldn't search the rest of the bank, and would
Xjust skip to the beginning of the next bank. Only applies to BSD style
Xptys.
X
XBugfix for hpux support. thanks Carlo Kid <carlo@sg.tn.tudelft.nl>
X
XNetBSD support from "Stephen J. Roznowski" <sjr@zombie.ncsc.mil>.
X
XSol23 support improved. Thanks to
X	Michael.Bender@Eng.Sun.COM (Duke of Canterbury).
X
XTitanOS support added. Fixed baudrate = 0 problem.
Xadded amount of data transmitted into tmon report.
Xcorrected baudrate=0 problem with tmon by introducing variable scale.
X	Above all thanks to "Bill C. Riemers" <bcr@physics.purdue.edu>
X
XUpdated README file. Major change is:
X	Don't send me E-mail to say you liked term!
X	It's nice, but my mailbox is pretty full.
X	Send me a postcard instead. That's MUCH nicer, and it will
X	impress my girlfriend! ;-) See README for address.
X
X1.10 --> 1.11
X
XNew linecheck!. Many many thanks to Jeff.
XTake a look at the beginning of linecheck.c for instructions.
X
XSome more stats added to upload. Thanks to platt@coos.dartmouth.edu
X
Xfixed tredir, txconn. They were broken by the new(ish) dynamic buffers.
X
Xsupport for AIX. thanks to Scott logan (silogan@vnet.ibm.com)
X	1.10  --> 1.10-sil
X	Added USE_TIOCNOTTY to AIX defs in config.h.
X	Added real AIX-style pty handling in pty.c.
X	Fixed redir.c and xconn.c to pay attention to command line
X	options like -t. 
X	Fixed test.c to run one side of the test pair with "-r".
X	If you compile with -DLOGIN_SHELL, trsh starts a login shell
X	by default. 
X
XBug w.r.t unixware select() fixed.
X
XRe-wrote makefile to get rid of all the system specific makefiles.
X
X1.0.9 --> 1.10
X
Xfixed realloc() for suns. *sigh*. realloc(0, n) fails on a sun.
X
Xreplaced fprintf() with debug_ll().
X
Xfixed language in a few places.
X
Xcorrection: alpha/osf1 support is by Craig I. Hagen, not marius hancu.
XMy mistake. apologies.
X
XBug introduced into upload fixed. Was causing all transfers to fail
Xleaving zero length files.
X
XDelay that was inadvertently left in removed. There was a 1/10th of
Xsecond delay in the main loop, resulting is awful thruput on v.high
Xspeed lines.
X
XIf the baudrate is set to 0 (i.e. -s0 ) then rate limit is not done.
XThis is useful on higher speed links. The normal window/timeout
Xmechanism is more than good enough on links > 9600.
X
XPs. This is not a version of term. See 109 release notes. I'm not sure
Xquite what it IS, but is definitely isn't a version. :-)
X
XAdded the delay back in, but made it smaller. It drops the CPU time used
Xby an order of magnitude....
X
X1.0.8 --> 1.0.9
X	
X3 fixes by Kay Roemer. Term will now close some files that it wasn't
Xbefore, read buffered data from a child that has exited, and close the
Xright sockets for children.
X
XAlpha/osf1 support from Marius Hancu
X
XPrevent compressing more than 2K of data into a single packet.
X
XThe biggy. Preventing data overruns. People using TCP connections that
Xhave very compressible data can now work in peace. Term previously used
Xfixed size buffers. Now it uses dynamic buffers. This means that if a
Xclient is a bit slow in reading data from term, term will increase the
Xbuffer size instead of throwing away data. On the down size, term's
Xmemory usage is now theoretically unlimited. This should fix most if
Xnot all of the problems people had with X over term. I finally got
Xbitten by this once too often.
X
XTHIS is DEFINITELY the last version of term. I hope.
X
X1.0.7 --> 1.0.8
X
XWell, I did what I swore not to. Here's a new version of term.
X
XFixed a bug relating to overflow on a timer variable. Caused term to
Xstop working sometime on Oct 26th.... *blush*. Jeff and I found this
Xat the same time (probably along with a LOT of other people.. :), and
XI used jeff's patch. (cleaner than mine).
X
XMerged in olaf's patches. Olaf, I've managed to delete your email.
XPlease mail me again.
X
XSee 'Blurb' for olaf's changes.
X
XI suppose I'll have to support this bloody version too! argh!!!!. :)
X
X--------------------------------------------------
X
X
X
X
XAt this point, you start at the end of the file and read backwards..
XI started adding new information to the top, instead of the bottom.
X
X---------------------------------------------------
X0.3--> 0.4
X	Fixed upload to make the optional arg really optional.
X	Fixed main.c to NOT cat the file arg to the socket name.
X0.4--> 0.5
X	Added baudrate option + env variable.
X	Xconn now checks the DISPLAY variable to know what display
X	to use.
X
X	Fixed bug in xconn relating to printf.
X	Fixed main.c. Was using wrong lower bound for baudrate.
X		Thanks to Someone who's name escapes me. mail me again
X		please.
X0.5--> 0.5.1
X	Silly bug in strncmp() in main.c
X0.5.1.--> 0.5.2
X	Fixed a few out of date docs.
X0.5.2.--> 0.5.3
X	The argument parsing got improved a lot.
X	Thanks to M. Saggaf.
X0.5.3 --> 0.6
X	Xconn got modified to use an INET socket instead of a UNIX
X	socket. This means you can run term on one machine, and use x apps on
X	another.
X	
X0.6 --> 0.6.1
X	I wrote a Q&D hack to see how the serial line performs.
X	
X	Consists of checkline.c and linerem.c (for local and remote
X	ends). See readme for details.
X0.6.1-->0.6.2
X	Fixed up pty.c a bit more. Hopefully it should the child proc
X	should be able to lose the controlling term on a sun now. :(
X	There was a damned silly bug. I had forgotten to #include config.h
X
X	Fixed xconn to properly print the display it was connecting to.
X	Fixed xconn to look at DISPLAY if it existed and use that for the
X		display number.
X	Fixed up sun stuff a bit (EAGAIN instead of EWOULDBLOCK).
X
X	Fixed up terminal.c to set VMIN and VTIME
X0.6.2 -> 0.6.3
X	Added a ~/.term/termrc 
X	Should be able to set everything from the termrc file, including
X	escaped characters. See TERMRC for format.
X
X	Beware, it isn't tested. :) Also, at the moment, it assumes that
X	adding 32 to an escaped character, won't produce another escaped 
X	character.
X
X	Two new features. a -f option tell term to generate control-Q's 
X	( in case line noise generates a control-S ).
X
X	In a termrc you can specify a 'shift'. This simply get XOR'ed with
X	all character before they are sent, and after they are received. The
X	purpose being to map a lesser used range on characters down to 0-32
X	(which are all escaped). I use 224 (0xE0). Haven't measured the 
X	speed up. But histogram of characters received shows a drop in the
X	number of escapes sent.
X0.6.3 --> 0.6.4
X	I was forgetting to close the file descriptor used to read the termrc
X	file.
X0.6.4 --> 0.6.5
X	A goddam silly bug. was doing if(strcmp) instead of if (!strcmp)
X	SIGH!!!!!!!!!
X0.6.5 --> 0.6.6
X	Another silly one. Wasn't escaping characters properly.
X0.6.6 --> 0.6.7
X	Changes the way the input window was worked out. Hopefully it
X	fixed some bugs reported by some ppl.
X0.6.7 --> 0.7.0
X	Re-wrote the compression tree handling. Hopefully a lot clearer, 
X	and understandable. Hopefully less bugs too. 
X
X	Fixed a few of the include files to remove warnings.
X	Fixed a a bug in upload.c Was doing i == 0, instead of i =0.
X	Fixed a bug in test.c had arguments in wrong order. Thanks to 
X	fjh?? for pointing this out.
X	
X	Fixed serial.c so that five 0's will exit term regard less of what
X	the byte_shift is set to.
X	
X0.7.0 --> 0.7.1
X	Added support for SGI. Thanks to 'warwick' harvey.
X
X	Fixed xconn to properly look at DISPLAY, search for the first
X	unused display. The way to run it now is...
X	"setenv DISPLAY=`xconn`"
X
X	Reduced window size to 2. Don't THINK it will adversely affect
X	throughput but haven't extensively tested it.
X
X0.7.1 --> 0.7.2
X	Added options to configure both the window size, and the packet
X	timeout values. Changed the default window size up to 3. A size of
X	2 at 2400 baud introduces too much latency into keystrokes.
X
X	Added an option to toggle transmit forcing. Forcing is now off by
X	default. Not tested properly.
X	
X	Added the -w , -t flags.
X0.7.2 --> 0.7.3
X	Fixed bug in xconn relating to searching for unused display.
X	Added the -n flag. See OPTION, and TERMRC for details. See also	
X	the source. :)
X
X	Cleaned up some more prototypes. Compiles are now cleaner.
X0.7.3 --> 0.7.4
X	Added handling of escaped characters that produce another char
X	that should be escaped.
X0.7.4 --> 0.7.5
X	Fixed noise echoing to remove byte shifting.
X	Tried to write some BSD terminal handling. Someone who has BSD want
X	to test this??
X
X	The famous compression bug found!!!! The all-singing-all-dancing-
X	wonder is gone! Many many thanks to Janne Sinkkonen (sinkkone@
X	cc.helsinki.fi) for this. I was clearing 300 bytes , on a 256 byte
X	buffer. :(
X0.7.5 --> 0.7.6
X	More prototype fixes.
X	Removed the call to abs() in link.c (convex does have it apparently)
X	
X	Fixed checkline.c to send an XON after every character (so it doesn't
X	'freeze'), and increased rate to 16 characters per second instead of 
X	1.
X
X	There is a new client 'redir'. Usage is 'redir <server port> <remote
X	port>'. So you can do 'redir 23 4000' and then everyone who
X	telnet's to port 4000 on your remote machine, will get connected
X	to telnetd on your local machine.
X0.7.6 --> 0.7.7
X	Fixed a bug in main.c. Fudge_flow was supposed to be a counter
X	limit, not a flag.
X0.7.7 --> 0.7.8
X	Fixed makefile. 'make test' make the wrong file.
X
X	Changed the way error handling was done. Added in LL
X	read/write debugging.
X	
X	Added support for ranges in termrc. i.e. 'escape 0-32' should
X	work. Not extensively tested.
X	
X	Lots of structural changes internal to term.
X
X	Missing break; in main.c -n was broken. fixed now.
X	
X	An incredibly stupid bug in serial.c fixed. I was using && instead of 
X	||. Resulted in the retransmission being brain-dead. *SIGH!!!!!*
X	Resulted in the packet window being as full as possible instead of
X	the reverse.
X
X	Changed the algorithm used to decide re-transmission. Now it will
X	never timeout a packet before the 'timeout' value.
X
X	Will not write out an error message for any line of the ~/.term/termrc
X	file that it doesn't recognize.
X
X	Redir can now redirect to a host. I.e.
X	'redir 119 my.news.server:119' on the linux box, lets you treat your
X	linux box as an NNTP server. Thanks to Rick Sladkey.
X
X	Renamed all the clients to get a 't' in front.
X	term --> term
X	rsh --> trshell
X	upload --> tupload
X	xconn --> txconn
X	rsystem --> trcmd
X	redir --> tredir
X
X0.7.8 --> 0.8.0
X	
X	Replaced waitpid() with wait3().
X
X	Added support for NeXT
X	Added support for AIX
X	Added (partial) support for BSD
X	
X	Thanks to crunchy!croutons@dartmouth.edu we have support
X	for individually compressed streams. I.e. you can be uploading
X	a file with no compression, while running a shell who's output does
X	get compressed. 
X
X	Added priorities for streams.
X
X	Vastly improved response time with multiple streams (I hope.. ).
X	Achieved by checking for new clients ready more often. The old scheme
X	was to take data from a client until it had none left before looking
X	for a new client. Now it looks for a new client at the beginning of
X	every packet. This is what it should have been doing anyway. 
X
X	
X	Re-wrote the client option handling. Now all clients take 4 arguments
X	-t <server> 	Tries to connect to the socket ~/.term/socket<server>
X		Default is "". Useful only if you are running multiple
X		terms (over multiple serial connections).
X
X	-r	Turns off compression for this link.
X	-c	Turns on compression for this link. 
X		the above two options affect compression both ways. The
X		capacity is there to only compress one-way. Tell me if you
X		want this?
X
X	-p <number> Changes the priority of the link to <number>. Default
X		is zero. tshell has a default of 2.
X		tupload has a default of -2.
X
X	The priority is currently absolute. i.e. if a there is a client with 
X	a high priority with data to send, then no client with a lower priority
X	will send until the higher has finished. This probably needs improve-
X	ing.
X
X0.8.0 --> 0.8.1
X	Redid all the #include files. Simplified (hopefully), and consider-
X	ably easier to port.
X
X	Fixed a bug in link.c. Was very silly. It could end up switching
X	channels in the middle of a control sequence.
X
X	Added signal handling for kill signals and segv's.
X
X0.8.1 --> 0.8.2
X
X	Fixed another silly bug in 'tredir' client. Was introduced in version
X	0.8.0
X
X	Fixed bug in makefile. Had missed a few places that were using
X	the old names of the clients.
X
X	Fixed bug in xconn.c Was using wrong filename for the X-window
X	unix-domain socket.
X
X	Added some more debugging calls. -d64 should be fairly informative
X	for control information now.
X
X	Added quick+dirty 7 bit support. run term with '-a' on both ends to 
X	use it (a == seven. maybe.). Or put "sevenbit" in your 
X	~/.term/termrc file.
X	WARNING!!!!!! It is very rudimentary. In particular, unless you send 
X	everything compressed, then it will strip the top bit of it. i.e. 
X	uploading file when not using compression with corrupt them.
X	WARNING 2!!!!!. It is in no way tested. Mail me how it goes..
X
X	Makefile got extensively re-written. Thanks to croutons (again :).
X
X0.8.2 --> 0.8.3
X	0.8.2 was basically pretty stuffed try again.
X
X	Fixed bug in compress.c (introduced in 0.8.2).
X	Fixed a few minor bugs in link.c relating to put_client_data being
X	called with an uninitialized structure.
X
X	Hopefully fixed the bug with things not exiting when they quit.
X	Really fixed the above bug. Telnet through a redir will now exit
X	properly. (was a bug related to the changed format for control 
X	sequences. Read PROTOCOL.unix for details).
X	
X	Brought PROTOCOL.unix up to date. 
X
X0.8.3 --> 0.8.4
X	Fixed prototype spelling error in link.c
X
X	Tried to fix trcmd. Does anyone use this??
X	
X	Fixed a few race conditions WRT control messages. Was clearing
X	buffers at some in-appropriate points. Should fix the multiple
X	upload bugs.
X	
X	Fixed get_next_client so that clients with the same priority share
X	the line equally.
X
X0.8.4 --> 0.8.5
X	Fixed the bug that was corrupting X windows streams.
X
X	Fixed a (potential) bug in redir.c (Same one as xconn.c).
X
X	Removed the trcmd client.
X
X	Renamed the trshell client to be 'trsh'.
X0.8.5 --> 0.8.6
X	Removed the C_SYSTEM command, and associated files.
X	
X	Fixed a bug in xconn.c WRT searching for an unused display.
X
X	Thanks to croutons again, trsh now takes multiple arguments happily.
X	commands like 'echo this is a multiple argument command' should work
X	just fine.
X
X	Wrote a CREDITS file. Anyone I have missed please mail me.
X
X	Applied Rick Sladkey's changes so that C_SOCKET will work with
X	a dotted decimal address.
X0.8.6 --> 0.9.0
X	Removed 7 occurrences of dubious language.
X
X	Fixed pty.c to test for more ptys. Thanks to Rick sladkey for
X	pointing this out. It now tests pty{p,q,r,s,t,u,v,w,x,y,z} if this
X	isn't enough, let me know, and I will fix it for more.
X
X	Went and implemented return codes for all commands. This means that
X	you shouldn't get any 'hangs' when attempting to use non-existent
X	ports and other such oddities. This also changes the command protocol
X	which means you have to upgrade both ends, and all your clients to use
X	it.
X
X	tupload will now do recovery. If you try to upload a file that
X	already exists on the remote end, then term will seek to then end of
X	the file, and to the equivalent position on the remote file, and start
X	uploading from there. Not fully tested.
X	
X	
X	
X0.9.0 --> 0.9.1
X	Write a minimal 'tstat' client. It currently just tells the
X	compression ratio's that the local and remote ends have achieved.
X
X	
X	Write a Q&D strerror() for sun's. It is in lib.c
X
X	
X	Fixed a small bug in lib.c. Was doing if t<0 && !t ...
X
X	
X0.9.1 --> 0.9.2	
X	We finally have some genuine man pages! Thanks very much to gtaylor
X	(see CREDITS file).
X
X	Added support for HPUX.
X
X	Added in a new checksum routine. This one is a genuine CRC.
X	
X	Started to merge checkline into term proper.
X
X	Changed most things to use unsigned chars. Should fix a few problems
X	on sun's.
X
X	Eliminated a race condition in pty.c
X0.9.2 --> 0.9.3
X	Fixed a small bug in man pages.
X
X	Updated the README file.
X
X0.9.3 --> 0.9.4
X	Updated the escaping mechanism. It is now dependent on the direction
X	of the link. There are 3 new termrc commands.
X	
X	"escape" now simply tells term never to transmit that character.
X	"ignore" tells term to silently strip that character from the
X		input stream. I.e. if your modem uses software flow control
X		use "ignore 17" and "ignore 19".
X	"seven_in" tells term that the remote end is seven 7 bit tokens.
X	"seven_out" tells term to transmit seven bit tokens.
X
X
X	So in the unlikely event that you have a seven bit link TO to remote 
X	host, and an 8 bit link FROM the host. Lets say that it chews all
X	control characters and 126. The 8 bit link is clean. No characters
X	get chewed.
X	Your local termrc should look
X	like..
X		seven_out
X		escape 0-31
X		escape 126
X	and the remote termrc.
X		seven_in
X		ignore 0-31
X		ignore 126
X		
X
X	"sevenbit" now is the same as doing both "seven_in" and "seven_out".
X	
X0.9.4 --> 0.9.5
X	Fixed silly bug WRT seven bit mode. Was sending packet that
X	were too long.
X
X	Added (a little) more into to tstat client.
X
X0.9.5 --> 0.9.6
X	Added an error check to tredir, to check for errors in binding the
X	local socket.
X
X	Fixed the sevenbit support a bit. It was still possible for
X	term to try to generate packets longer than 127 bytes.
X0.9.6 --> 0.9.7
X	Fixed compression for seven bit mode.
X	
X0.9.7 --> 0.9.8
X	Added more information to C_STATS
X	
X	Change client.c to include varargs.h for a sun. Mail me if this is
X	wrong.
X
X	Changed 'server' to be 'term_server' to avoid (potential) conflict
X	when linked with other programs.
X
X	Fixed a problem in client.h whereby un_char might not have been 
X	defined.
X
X	Fixed the man pages WRT tredir %d %s:%d.
X	
X	Added tmon client. Fixed a few minor bugs in the same.
X	
X	Extensive internal changes. Everything now uses the Buffer struct,
X	and all the oddball buffer routines have been cleaned up. Also,
X	partial support for bound sockets has been added.
X
X	Added support for SIGWINCH. Written by Teemu Rantanen, cleaned
X	up slightly by me. Doesn't (yet) handle on-the-fly resizes.
X
X	
X0.9.8 --> 0.9.9
X	Fixed an include file bug in trshell.c Wasn't #include'ing signal.h
X
X	Implemented a remote bind protocol. See the two new sever commands 
X	C_BIND, and C_ACCEPT. 
X
X	Fixed some more char/un_char conflicts.
X
X	Fixed tmon.c (wasn't including sys/time.h).
X
X	A new and improved version of tmon is included. This one is
X	much more accurate.
X	
X0.9.9 --> 0.9.9a
X	Fixed a HZ in tmon. Should compile most places now.
X
X	Half fixed a bug relating tmon.c. It works, but there is still a 
X	race condition. The problem is if two clients start at opposite ends
X	at the same time, they will get the same number. This is bad.
X
X	(Hopefully) fixed SGI support.
X
X	Tried to fix a condition relating to EWOULDBLOCK. (Could people
X	please try and let me know how to reproduce a bug if they see it!?)
X
X
X99b
X	
X	Fixed all the check_client() stuff. Should exit more cleanly now.
X	*cross fingers*.
X99c
X	Improved the Makefile, so there is only one reference to the compiler.
X
X	Fixed the select(). It now passed the number of fd's to check, not
X	just 64.
X
X	Added support for varargs.h. varargs is used instead of stdargs
X	if the #define USE_VARARGS is defined.
X
X	Fixed spelling of 'compiling' in README file. (Thanks to 
X	cfs@nir.gatech.edu [Charles Stevens]).
X
X	Changed xconn.c to do a little more error checking.
X
X	Improved the README to be a little clearer.
X099d
X	Documented the commands in client.h
X
X	Added a C_DUMP command. usage is C_DUMP %d, meaning to go dumb for
X	the next %d bytes. See protocol.unix.
X
X	Removed the C_CLIENTNUM, and replace it with a C_STATS sub-function.
X
X	Documented all the new commands in PROTOCOL.unix. Happy now 
X	Quarters? :)
X
X	Added in Jeff Grills new upload.
X
X	Fixed tmon to remove all references to termio{s} from it.
X	Added calls to terminal_raw() so that any key will immediately exit
X	it. Read the key before exiting to ensure it doesn't get read 
X	by the shell.
X
X	Fixed JG's new upload so that it uses C_DUMP, instead of opening
X	a new connection for each file. Added a C_STAT at the end to ensure
X	that tupload doesn't exit before the entire file is there.
X	
X	Fixed read_into_buff to take the size. (needed for new upload).
X	
X099e
X	Fixed a few bugs in upload.
X	
X099f
X
X	various bug fixes and code clean-up. (read: I can't remember what
X	I changed. :)
X	
X	Added a bit of sanity checking in link.c:get_client_data();
X099g
X	More sanity checking in read_into_buff/write_from_buff();
X	Added a bit more information to tmon.
X
X	Extended C_STAT to read file types and permissions.
X	
X	Re-wrote much of xconn.c to be more robust, and smaller.
X
X	Re-wrote xconn a bit more, and redir as well. Moves the bulk
X	of the (common) code to connect.c.
X099h
X	Updated PROTOCOL.unix
X
X	Added S_IFREG, and S_IFDIR to link.c for those machines
X	that don't have them. (i.e. F****** suns!).
X
X	Changed the dependencies to NOT include the system header files.
X
X	Tried to get term to compile nicely on a 386BSD. 
X	Fixed Makefile.{sun,sgi} to include connect.c
X
X	Fixed xconn to print out the display number it is using.
X	export DISPLAY=`txconn` should now work.
X
X	Made tredir move itself into the background automatically. No longer
X	need to invoke it with 'tredir ... &'.
X
X	Replaced a few 'char' with 'un_char's. There was one in serial.c
X	that was screwing compilers that used signed chars.
X
X	Upgraded upload to match Jeff Grills. The new upload
X	has lots of features that aren't yet documented. 
X
X	Improved pty.c and general hpux support. Thanks to H.J. Lu
X
X	Re-wrote bits and pieces of upload to suit myself. Made gratuitous
X	changes to the formatting on the way.
X099i
X
X	Removed the automatic escaping of characters < 32.
X	Now escapes NO characters be default. BEWARE!!!!!!
X	If this causes you problems, a quick fix is to add
X	'escape 0-31' to your ~/.term/termrc file. This improved
X	my CPS rate by some 12% just up escape 30 instead of 32 characters.
X
X	Added a signal() to ignore SIGPIPE's. This was what was killing
X	term at in-opportune times.
X
X	Fixed a bug in C_STAT relating to permissions.
X
X	Made tupload use no compression by default. If you want to 
X	upload something and have it be compressed over the link, you
X	will have to use 'upload -c ...'. Term can't handle compressing
X	stuff that is already compressed.
X
X	Txconn, and Tredir will now only run when term is running, and will
X	exit when term exits. Tell me how you feel about this change.
X
X099j
X
X	Tried to clean up shell exiting.
X
X	Fixed up the pty.c code. It was checking for the wrong ptys
X	first. The patches hpux had broken ptys for other machines.
X
X099k
X
X	Prevented term from sending five '0' itself accidently, and
X	killing the remote term as a result.  	Moved the detection
X
X	Fixed S_ISREG's in link.c for machines that are missing them.
X	Was defining the wrong thing.
X
X	Ripped out the prevention of term sending five zeros. I had 
X	made a mistake. Term only interprets the five zeros if they
X	are line noise. Instead, add a 'breakout' option to termrc.
X	This sets the character to watch for.
X
X	Fixed the sig_child handling a bit more. Shells should exit
X	cleanly now...
X
X	Improved the sigwinch handling for sun's. Sun's are broken.
X	I am getting a VERY low opinion of suns....
X
X099l
X
X	Fixed a minor bug in link.c that caused upload to hang. It only
X	showed up when there was a '@' in a byte, on a 2047 byte
X	boundary.
X099m
X	
X	Changed the sample TERMRC to be a real sample.
X
X	Fixed tmon to not core-dump is there is no compression.
X
X	Changed checkline to start from 0 instead of 32 (to fit in
X	with removing the automatic escaping of 0-31)
X
X	Jeff Grills improved upload some more. Added a progress indicator.
X	Now to write download.......
X
X	Default timeout is now 3.5 seconds instead of 2.5 (i.e. timeout 70)
X	This is to make it work by default with slower modems.
X
X	Added lots of support for people with multiple term's on the 
X	same machine. Now if you run 'term home' it will try and read
X	~/.term/termrc and then ~/.term/termrc.home. It is ok for one
X	or both of them not to exist.
X
X	If the TERMSERVER environment variable is set, then clients will
X	act as if they had been invoked with '-t $TERMSERVER' and try to
X	connect to that server. i.e. if you run 'term home', then doing
X	"export TERMSERVER=home" will cause all clients to use the 'home'
X	server.
X
X	Added the 'chdir' option to termrc. 'chdir <directory>' will cause
X	term to try and chdir to that directory on startup. This will 
X	cause all relative file references to be relative to that directory.
X
X	Fixed PROTOCOL.unix. Removed the C_EXEC entry as it is obsolete.
X
X	Had a go at improving the robustness of checkline/linerem. Made them
X	work asymmetrically.
X
X	Improved the pty handling. It now checks to make sure both the
X	master and slave can be opened before committing itself. This lets 
X	it handle ptys that are left in a dud state.
X	
X	Fixed a bug in serial.c. The byte_shift was resulting in corrupted
X	bytes in seven_bit mode if byte_shift was > 127.
X
X	Implemented byte stuffing. In seven_bit mode, term now stuffs
X	7 eight bit bytes into 8 seven bit bytes. It doesn't check if
X	the stuffing is needed tho. :( It should only stuff if the top
X	bit is being used, but it stuffs all raw characters. Ppl can
X	live with this for now.
X
X	Added a CPS to the upload -vv display.
X
X	Fixed a minor bug in upload.c relating to -vv display. (CPS was
X	-ve and too high ).
X
X	Added a few patches to support AIX. Minor stuff.
X
X	Fixed a bug with response which resulted in results being sent to
X	the wrong end.
X
X099n
X
X	Updated the CREDITS file. Re-wrote the introduction blurb.
X
X	Added sevenbit.o to Makefile.{sun,sgi}. An oversight.
X
X	Fixed a little bit of AIX support.
X
X	Fixed the sevenbit byte stuffing.
X
X	upload has a few bug fixes. The CPS bug is fixed. There is 	
X	a '-u' flag. This will erase the file after a successful upload. 
X	source file pathnames are now truncated. use '-as' to override this.
X	Note that you need to use a '--' before the first filename if
X	you want to use -as. i.e. 'tupload -f -r -vv -- local.file -as
X		remote.file'.
X
X	Extensively revised the man pages.
X
X	Checkline/linerem got re-written by Jeff Grills. Try them and see
X	what they say about your line.
X
X099o
X
X	checkline/linerem replaced by linecheck. MANY thanks to Jeff Grills.
X
X	Got rid of the 'Clearing Dict table' messages.
X
X	Fixed a bug relating to connections getting closed before the buffers
X	were flushed. 
X
X	Deleted the checkline/linerem programs and associated man pages.
X	
X	Fixed a few minor bits in linecheck. Stuffed up all the formatting
X	to suit me and my editor.
X
X	Placed term under Gnu Copyleft. Changed README to suit. Added
X	a copy of the GNU copyleft.
X
X	Removed some more debugging information from main.c the 'client gave this:..'
X	and 'select: ..' warnings are now gone.
X
X	Make tredir/txconn ignore SIGPIPE signals. These were causing it
X	to exit when clients exited in a hurry without letting tredir
X	know about it.
X
X	Changed redir, and xconn to have the capability to redir multiple
X	ports in the one redir. If anyone wants to play with writing 
X	a user interface, feel free. :). do_connect() now takes an
X	array of ports to watch.
X
X	Re-wrote the checkline/linerem section of the README to be about
X	linecheck. Edited the information jeff sent to be more readable for novices.
X099p
X
X	There was a race condition that occurred when a remote client, and
X	a local client started up at the same time. To fix, edit your
X	~/.term/termrc file on ONE end, and add the line 'remote' to it.
X	This should ensure lines like 'trsh -- tupload -f -c -v o' will work.
X	
X	Makefile fixed to generate 'linecheck' not 'check'.
X
X	More debugging information got lost. This time the perror("accept");
X
X	Installed a new(er) version of linecheck. Thanks again to Jeff.
X	Fixed the dependencies in the Makefile for linecheck.
X	
X099q
X
X	Fixed a bug in upload. It wasn't closing files after it had
X	uploaded them.
X
X	Added -l option. Does the same as redirecting stderr. Just for ppl
X	with braindead shells.
X
X	Made term use only stdin, instead of stdin/out. I.e. term will try
X	to write to stdin to write to the modem. This should normally be ok.
X
X	Added the -1 option. If used, term will use stdout as the
X	modem, instead of stdin.
X
X	Added -v option. Usage is '-v<filename>'. Set the modem device.
X	i.e. run as 'term -v/dev/ttys1' to use /dev/ttys1 as the modem.
X	Warning!!! For forward compatibility do NOT use more than one
X	-v.
X	
X	Properly fixed upload, and added a C_CLCLOSE command for clients.
X	Interested ppl can see link.c.
X
X	Fixed a bug in send_command() that was resulting in dud command_result 
X	returns.
X
X	Re-wrote the error reporting in link.c. Replace do_return with the two
X	routines ret_ok(), and ret_fail().
X
Xterm 1.0.0.
X
X	YES!!!! at last!
X
X	Patched in Jeff's linecheck patches.
X
X	Fixed 2 bugs relating to upload.
X
X	released 1.0.0
X
X	NOTE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
X	ALL FUTURE RELEASED WILL BE NAMED "SLAP"
X
X	There will not be another version of term. It has been re-named
X	"slap" (for serial line access protocol).
X
Xterm 1.0.1
X
X	Re-wrote the stdin/out handling as it was causing problems
X	on the NeXT.
X
X	Fixed a small bug in upload relating to uploading a file
X	from stdin.
X
X	Note! The above implies there will be no work done on term.
X	This is just to say that bugs will be fixed as they appear, but
X	term will get no new features. All my efforts will now go into
X	Slap.
X1.0.2
X	Fixed a mistype in terminal.c Had in mypid; instead of int.
X	Thanks to warwick for this.
X
X	Added code to define STDIN_FILENO in linecheck.c if it wasn't
X	already defined.
X
X	Fixed the Makefile.sun for linecheck. Oversight.
X
X1.0.3
X	Fixed the problems with term hanging on Sun's. Turns out it
X	is a dogey sun select(), and a missing continue in my source.
X	Thanks VERY much to one David E Wexelblat.
X
X1.0.4
X	Changed the way term worked for non-vhangup cases.
X
X	Merged in Hugh Secker-Walker's patches to support NeXT boxes.
X	
X	Merged in support for SGI machines.
X
X	Added makefiles for mips, and next machines. Thanks again to Hugh.
X1.0.5
X	Added SVR4 support.
X
X	Tried to fix up a bug in xconn and tredir
X
X1.0.5.a 
X	[ by Hugh Secker-Walker, for NeXTstep, not part of Michael's release ]
X	
X	At Michael's suggestion to fix a bug with high-speed links, changed
X	link.c line 94 from  'if (p_in[.... '  to  'while (p_in[....'.
X
X	Added README.NeXT, README.MIPS, select.c.mips, upload.c.mips.
X
X1.0.5.b
X	[ by Felix A. Lugo, E-mail: Felix_A_Lugo@ATT.COM ]
X
X	Added Solaris 2.1 support.
X
X	Fixed problems with do_resize (misc.c) and added support for pixel
X	window sizing (misc.c, link.c, trshell.c).
X
X	Fixed problem with restoring tty settings after abnormal exits and
X	re-enabled SIGINT and SIGQUIT.
X
X1.0.6
X	Merged in changes as per above, and released as 1.0.6
X
X1.0.6.a
X	[ by Hugh Secker-Walker, hugh@mit.edu ]
X	
X	Trsh accepts -s option for a simple connection, i.e. no pty on
X	remote end using C_EXEC.  Also, trsh restores terminal when killed.
X
X	In link.c, support for C_EXEC, to run a command using /bin/sh -c, 
X	and no pty.  This for the -s option of trsh.
X
X	In pty.c, fixed use of pipe used to confirm that child exec'ed.
X	Unresolved problems remain (on NeXT) with printf in child
X	hanging.  (This latter was not a problem until the pipe bug
X	was fixed so that the parent (term) really waits.)
X	Also, added open_socket() for support of C_EXEC.
X
X	In term.1, term_clients.1, and term_setup.1, numerous editorial
X	changes and additions.
X	Merged in changes as per above, and released as 1.0.6
X
X
X1.0.7
X	Fixed Makefile.sun to look for linecheck.c instead of checkline.c
X	
X	Fixed misc.c to NOT put out literal bell's (dunno about you but I 
X	hate the noise). 
X
X	(all above due to jeff grills.)
X	
X	See above list of change by Hugh as 1.0.6a
END_OF_FILE
  if test 50384 -ne `wc -c <'CHANGES'`; then
    echo shar: \"'CHANGES'\" unpacked with wrong size!
  fi
  # end of 'CHANGES'
fi
if test -f 'jump/jump.vars' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jump/jump.vars'\"
else
  echo shar: Extracting \"'jump/jump.vars'\" \(1034 characters\)
  sed "s/^X//" >'jump/jump.vars' <<'END_OF_FILE'
X00000004 D _share               libtermnet lib 
X00000004 D _termerrno           libtermnet lib 
X00000400 C _com_result          libtermnet client 
X00000004 C _command_result      libtermnet client 
X00000004 D _lcompression        libtermnet client 
X00000004 D _priority            libtermnet client 
X00000004 D _rcompression        libtermnet client 
X00000004 D _remote_term_version libtermnet client 
X00000004 D _savedeid            libtermnet client 
X00000004 D _term_server         libtermnet client 
X00000004 C _term_optarg         libtermnet term_getopt 
X00000004 D _term_opterr         libtermnet term_getopt 
X00000004 D _term_optind         libtermnet term_getopt 
X00000004 C _term_optopt         libtermnet term_getopt 
X00000004 D _term_debug          libtermnet termnet 
X00000004 D _term_localaddr      libtermnet client
X00000004 D _term_remoteaddr     libtermnet client
X00000100 C _term_localhost      libtermnet client
X00000100 C _term_remotehost     libtermnet client
X00000004 D _verbose             libtermnet     client
END_OF_FILE
  if test 1034 -ne `wc -c <'jump/jump.vars'`; then
    echo shar: \"'jump/jump.vars'\" unpacked with wrong size!
  fi
  # end of 'jump/jump.vars'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
  echo shar: Extracting \"'main.c'\" \(36204 characters\)
  sed "s/^X//" >'main.c' <<'END_OF_FILE'
X#define I_SYS
X#define I_ERRNO
X#define I_GETOPT
X#define I_STRING
X#define I_SOCKET
X#define I_IOCTL
X#define I_STAT
X#define I_SIGNAL
X#define I_TIME
X#define I_WAIT
X#define I_CTYPE
X#define I_LIMITS
X#define I_INET
X#include "includes.h"
X
X#include "debug.h"
X
X/*
X *
X * main file. Calls everything else. ;)
X * 
X * basically consists of select() and then calls things based on the select().
X *
X */
X/*------------------------------------------------------------------------*/
X
X#define INFINITE_BAUD 115200	/* Nothing is really unlimited.  This should */
X				/* be the maximum baudrate you could achieve */
X				/* when running with baudrate = 0.  As you */
X				/* We need some sort of limit so baudrate 0 */
X				/* doesn't use 30-40% of the cpu time. */
X				/* Note: This # is really just accurate to */
X				/* an order of magnitude. */
X
X/* truly global vars. Used everywhere. */
Xunsigned long current_time = 0;
Xint do_shutdown	 = 0;
Xint term_debug = 0;
Xint compressing = 1;
Xint onetime_term_socket = -1;
X/*------------------------------------------------------------------------*/
X/* Various global variables. Note that most of these vars are local to    */
X/* this file. Where possible (i.e. where it doesn't impinge on efficiency) */
X/* this is enforced */
Xint remote = 0;
X
Xstruct Client clients[MAX_CLIENTS];
Xint num_clients = 0;
Xunsigned long baudrate = 1;
Xint max_cps = 0;
Xint auto_retrain = 0; /* Don't automatically adjust timing values */
Xint bytes_left = _POSIX_PIPE_BUF; /* bytes available to send now.. */
Xint fudge_flow = 0; /* should we generate periodic control-Q's */
Xint byte_shift = 0; /* So we can map less frequently uses section down to */
X                    /* 0-32 */
Xint window_size_max = -1; /* This will automatically be adjusted */
X
Xint window_size = 1; /* Don't change this */
Xunsigned long packet_timeout = 70; /* wait 3.5 seconds for a packet to time out */
Xint write_noise = 0; /* whether we should print out all the the serial stuff */
X				/* we get that we don't understand.. */
X
Xint seven_bit_in = 0;		/* Are we on a line that ignores the */
X				/* top bit. */
Xfloat stop_bits = 1;		/* # of stop bits being used */
Xstatic long unsigned delay = 20000;
X				/* This is a 20000 micro-second delay to decrease */ 
X				/* cpu usage. */
Xstatic int collisions = 0;	/* Use this if you have problems with data */
X				/* Collisions */
Xint term_inc = 20;		/* This is the # of times / second term will */
X				/* attempt to send data */
Xint in_mask = 255;
Xint seven_bit_out = 0;
Xint out_mask = 255;
Xint block_size = -1;		/* This is the size of block the serial devices uses */
Xint packet_len = -1;
Xint breakout_char = '0';
Xchar breakout_string[256];
Xstatic int quiet = 0, rc_quiet = 0;
Xint user_share = -1;
Xint modem_noise = -1;
Xstatic int hangup_on_exit = 0;	/* tell local modem to hang up on exit */
Xstatic int explicit_hangup = 1;	/* local modem needs ath0 after +++ to hangup */
X
Xint stat_modem_in = 0,
X  stat_modem_recv = 0,
X  stat_modem_out = 0,
X  stat_modem_ack = 0,
X  stat_cooked_in = 0,
X  stat_cooked_out = 0,
X  stat_rare_out = 0;
X
Xchar *share_p = NULL;
Xchar *home_p = NULL;
X
Xint rshtype = 0;  /* Default to allow rsh and use login shell_command */
X
Xstatic char ownroot[256] = "";
Xstatic char shell_command[256] = "";
Xchar escapes[256];
Xchar ignores[256];
X
Xint modem_in = 0, modem_out = 1;
X/*------------------------------------------------------------------------*/
X/* module function prototypes */
X
Xvoid get_term_localaddr(unsigned long);
Xvoid read_int_type(int *o, char *c);
Xvoid var_init(void);
Xvoid main_loop(int);
Xvoid main_init(void);
Xvoid do_link_in(void);
Xvoid do_link_out(void);
Xvoid clear_buffers(struct Client *cl);
X/*------------------------------------------------------------------------*/
X/* main. */
X
Xvoid read_int_type(int *o, char *c) {
X
X	/* This reads an integer with "on" == 1, "off" == 0, and default == 1 */
X
X  if (isdigit(*c))
X    *o = atoi(c);
X  else
X    *o = !!strncmp(c, "off", 3);
X}
X        
Xvoid var_init(void) {
X
X  get_term_localaddr(inet_addr("127.0.0.1"));
X  memset(term_remotehost, 0, sizeof(term_remotehost));
X  strcpy(term_remotehost,"remotehost");
X
X  if (fudge_flow < 0)
X    fudge_flow = 0;
X  if (byte_shift < 0 || byte_shift > 255)
X    byte_shift = 0;
X  if (packet_timeout < 10 || packet_timeout > 1000){
X    fprintf(stderr, "Invalid timeout value (%lu).\r\n", packet_timeout);
X    auto_retrain = 1;
X    packet_timeout = 70;
X  }
X
X  if (strlen(breakout_string) < 5) 
X    sprintf(breakout_string,"%c%c%c%c%c",
X      breakout_char,breakout_char,breakout_char,breakout_char,breakout_char);
X
X  if ( seven_bit_out ) {
X    extern int tok_byte_mask_out, tok_byte_width_out;
X    out_mask = 127;
X    tok_byte_mask_out = 127;
X    tok_byte_width_out = 7;
X  }
X
X  if (seven_bit_in) {
X    extern int tok_byte_mask_in, tok_byte_width_in;
X    in_mask = 127;
X    tok_byte_mask_in = 127;
X    tok_byte_width_in = 7;
X  }
X
X  if (baudrate == 1) {
X    baudrate = terminal_baud(modem_out);
X  }else if (baudrate < 300 && baudrate) {
X    baudrate = 300;
X    fprintf(stderr, "baudrate set too low. Reset to 300\r\n");
X  }else if (baudrate >= INFINITE_BAUD) 
X    baudrate = 0;
X
X  max_cps = baudrate ? (2 * baudrate) /
X    (unsigned long) ((int)(0.5 + 2 * stop_bits) + (seven_bit_out ? 14 : 16))
X    : 0;  /* avoiding round-off problems */
X
X  if ( block_size < 0) block_size = (max_cps) ? 512 : PIPE_BUFFER;
X  if ( block_size < 127 || block_size > PIPE_BUFFER ) {
X    fprintf(stderr, "Invalid packet length %d (must be 1..%d) resetting to %d\n",
X      block_size, PIPE_BUFFER, 512);
X    block_size = 512;
X  }
X  if (max_cps && block_size > max_cps) block_size = max_cps;
X
X  if (packet_len < 0) 
X    packet_len = out_mask + 1;
X  else if (packet_len < 1 || packet_len > out_mask+1) {
X    packet_len = out_mask + 1;
X    fprintf(stderr, "packetsize has to be 1..%d.  Reset to %d\r\n", 
X      packet_len, packet_len);
X  }
X
X
X  if ( !max_cps ) 
X    term_inc = INFINITE_BAUD / (unsigned long) block_size;
X  
X  if ( term_inc < 20 ) term_inc = 20;
X  if ( delay > 400000 / (unsigned long) term_inc)
X    delay = 400000 / (unsigned long) term_inc;
X
X  if (window_size_max < 0 ) {
X    window_size_max = 2 + (max_cps / 199);
X    if (window_size_max >= N_PACKETS / 2 || window_size_max < 3)
X      window_size_max = (N_PACKETS / 2) - 1;
X  }else if (window_size_max > N_PACKETS / 2 ) {
X    fprintf(stderr, "Invalid window size %d\r\n", window_size_max);
X     window_size_max = (N_PACKETS / 2) - 1;
X  }else if (window_size_max < 2) {
X    fprintf(stderr, "Invalid window size %d\r\n", window_size_max);
X    window_size_max = 2;
X  }
X  if (write_noise && write_noise < quiet + 1) write_noise += quiet;
X  if (modem_noise < 0) 
X    modem_noise = remote;
X}
X
Xvoid main_init(void) {
X  int i;
X
X  for (i = 0; i < MAX_CLIENTS;++i) {
X    clients[i].fd = -1;
X    clients[i].state = -1;
X    clients[i].in_buff.data = NULL;
X    clients[i].out_buff.data = NULL;
X    clients[i].in_buff.alloced = 0;
X    clients[i].out_buff.alloced = 0;
X  }
X}
X				/* In case of sudden death, do some */
X				/* minimal clean up. */
Xvoid sig_quit(int dummy) {
X  set_block(0);
X  set_block(1);
X  terminal_restore(0);
X  terminal_restore(1);
X  set_block(modem_in);
X  set_block(modem_out);
X  exit(0);
X}
X				/* Drop a core. */
Xvoid sig_core(int dummy) {
X  set_block(0);
X  set_block(1);
X  terminal_restore(0);
X  terminal_restore(1);
X  set_block(modem_in);
X  set_block(modem_out);
X  abort();
X}
X				/* We ignore this signal. There was */
X				/* some problem with it on linux. A */
X				/* bit odd, and I can't track it down. */
X				/* I suspect it is a bad shell_command. So we */
X				/* just ignore it. */
Xvoid sig_ignore(int dummy) {
X  signal(SIGALRM, sig_ignore);
X  signal(SIGPIPE, sig_ignore);
X}
X
Xvoid sig_child(int dummy) {
X  int p, i;
X#ifdef USE_WAITPID
X  int stat_loc;
X
X  p = waitpid((pid_t)-1, &stat_loc, WNOHANG);
X#else
X  p = wait3(0, WNOHANG, 0);
X#endif /* SVR4 */
X#ifndef SYSV
X  signal(SIGCHLD, sig_child);
X#endif /* SYSV */
X
X  if (p < 1) return;
X  DEBUG_MAIN(stderr, "%s:sig child kicked\n", term_server);
X  for (i = 0; i < MAX_CLIENTS;++i) {
X    if (clients[i].pid == p && clients[i].state > 0) {
X#ifdef USE_NOEOF /* ++kay: let term read until EOF */
X      clients[i].state = 2;
X#endif
X      return;
X    }
X  }
X  /* Hmm. child that we don't know about died!?!?! */
X  if (dummy)
X    dummy = 0;
X}
X
Xvoid read_rc(char *p) {
X  FILE *f = NULL;
X  char *file = NULL, *ptr = NULL;
X  static int Chdir[256];
X  static int seven_bit=0, login_type = 0;
X#define INT_TYPE 1
X#define CHAR_TYPE 2
X#define RANGE_TYPE 3
X#define LONG_TYPE 4
X#define FLOAT_TYPE 5
X  static char int_type=INT_TYPE, char_type=CHAR_TYPE, range_type=RANGE_TYPE,
X	long_type=LONG_TYPE, float_type=FLOAT_TYPE;
X#define RC_OPTIONS_SIZE 90
X  int m, n;
X  static char *rc_options[RC_OPTIONS_SIZE] = {
X	"compress",	& int_type,	(char *) &compressing,
X	"breakout",	& int_type,	(char *) &breakout_char,
X	"remote",	& int_type,	(char *) &remote,
X	"chdir",	& char_type,	(char *) Chdir,
X	"escape",	& range_type,	(char *) escapes,
X	"ignore",	& range_type,	(char *) ignores,
X	"baudrate",	& long_type,	(char *) &baudrate,
X	"retrain",	& int_type,	(char *) &auto_retrain,
X	"shift",	& int_type,	(char *) &byte_shift,
X	"window",	& int_type,	(char *) &window_size_max,
X	"timeout",	& int_type,	(char *) &packet_timeout,
X	"noise",	& int_type,	(char *) &write_noise,	
X	"sevenbit",	& int_type,	(char *) &seven_bit,	
X	"seven_out",	& int_type,	(char *) &seven_bit_out,
X	"seven_in",	& int_type,	(char *) &seven_bit_in,
X	"flowcontrol",	& int_type,	(char *) &fudge_flow,
X	"login",	& int_type,	(char *) &login_type,	
X	"denyrsh",	& int_type,	(char *) &rshtype,
X	"chroot",	& char_type,	(char *) ownroot,
X	"collisions",	& int_type,	(char *) &collisions,
X	"increment",	& long_type,	(char *) &term_inc,
X	"stopbits",	& float_type,	(char *) &stop_bits,
X	"quiet",	& int_type,	(char *) &rc_quiet,
X	"share",	& int_type,	(char *) &user_share,
X	"shell",	& char_type,	(char *) shell_command,
X	"blocksize",	& int_type,	(char *) &block_size,
X	"packetsize",	& int_type,	(char *) &packet_len,
X	"terminate",	& char_type,	(char *) breakout_string,
X	"hangup_on_exit", & int_type,	(char *) &hangup_on_exit,
X	"explicit_hangup", & int_type,	(char *) &explicit_hangup
X      };
X
X#define DEFAULT_PATH "/usr/local/lib/term:/usr/lib/term:/usr/etc:/etc" 
X
X  set_share_mode(0,share);
X  if(share == -1){
X    share = (getgid() != getegid());
X    set_share_mode(0,share);
X  }
X
X  setuid(geteuid());
X  if (share != 1)
X    setgid(getgid());
X  else if (savedeid >= 0)
X    setgid(savedeid);
X
X  do {
X    if ((file = get_term_path(&ptr))) {
X      if(share != 1) 
X        strcat(file, "/.term");
X      strcat(file, "/termrc");
X      if (p != NULL) if ( p[0] )
X        sprintf(&file[strlen(file)], ".%s",p);
X      if (! eaccess(file, R_OK)) break;
X    }else break;
X  } while ( ptr );
X
X  if (file) {
X    if (!quiet) 
X      fprintf(stderr,"Reading file:  %s\r\n",file);
X    f = fopen(file, "r");
X  }
X
X#ifdef _POSIX_SAVED_IDS
X  if (share) {
X    if(share == 2) 
X      setuid(getuid());
X    else
X      setgid(getgid());
X  }
X#endif
X  if (!file || !f) return;
X
X  if (! quiet) quiet = rc_quiet;  
X  Chdir[0] = '\0';
X  while (!feof(f)) {
X    char line[256];
X
X    fgets(line,	256,	f);
X				/* skip blank lines + comments. */
X    if (!line[0] || line[0] == '\n' || line[0] == '#')
X      continue;
X			
X
X    for(m = 0;m < RC_OPTIONS_SIZE;m += 3)
X      if ((n = strlen((char *) rc_options[m])) < strlen(line))
X        if (! strncmp((char *) rc_options[m], line, n)  
X            && isspace(line[n])) {
X
X      while (isspace(line[++n]));
X 
X      switch ( (int) *rc_options[m+1] ){
X        case CHAR_TYPE:
X        {
X          int i, quote=0;
X          if (  line[n] == '\47' ||
X                line[n] == '"' ) {
X            quote = line[n++];
X            for(i=0;i<256 && line[n] != quote && line[n];++i,++n){
X              if ( (rc_options[m+2][i] = line[n]) == '\\' && line[n+1] )
X                rc_options[m+2][i] = line[++n];
X            };
X          }else {
X            for(i=0;i<256 && ! isspace(line[n]) && line[n];++i,++n){
X              if ( (rc_options[m+2][i] = line[n]) == '\\' && line[n+1] )
X                rc_options[m+2][i] = line[++n];
X            };
X          };
X          rc_options[m+2][i] = 0;
X          break;
X        }
X        case RANGE_TYPE:
X        {
X          char *p;
X          int i,j;
X      
X          if(strchr(&line[n],'#'))
X            *strchr(&line[n],'#') = '\0';
X          i = atoi(&line[n]);	/* get the number following. */
X          if (i < 0 || i > 255) {	/* check for sanity. */
X            fprintf(stderr, "Invalid escape/ignore %d in termrc\n", i);
X            continue;
X          }
X          if ((p = strchr(&line[n], '-')) != NULL) { /* See if this is a */
X  					     /* range.. */
X            while (isspace(*++p));	/* skip whitespace. Note that it */
X				/* automatically skips the '-'. */
X            j = atoi(p);		/* if it is, then get the second number. */
X            if (j < 0 || j > 255) {	/* sanity check again. */
X              fprintf(stderr, "Invalid range limit %d in termrc\n", j);
X              continue;
X            }
X            for (;i != j; i = (i+1) & 255) /* Ok. mark all the characters */
X				/* in the range as being escaped. */
X              rc_options[m+2][i] = '\1';   
X          }
X          else rc_options[m+2][i] = '\1';	/* else just set the one character as */
X				/* to be escaped. */
X          break;
X        }
X
X        case INT_TYPE:
X          read_int_type((int *) rc_options[m+2],&line[n]);
X          break;
X        case LONG_TYPE:
X	{
X	  if(strchr(&line[n],'#'))
X	    *strchr(&line[n],'#') = '\0';
X	  sscanf(&line[n],"%lu",(unsigned long *) rc_options[m+2]); 
X          break;
X        }
X        case FLOAT_TYPE:
X	{
X	  if(strchr(&line[n],'#'))
X	    *strchr(&line[n],'#') = '\0';
X	  sscanf(&line[n],"%f",(float *) rc_options[m+2]); 
X          break;
X        }
X      };
X      break;	
X    };
X    if (m == RC_OPTIONS_SIZE){
X      if(! strncmp("remote",line,6)){
X         remote = 1;
X      }else{
X        fprintf(stderr, "Unrecognized line in %s\r\n",file);
X        fprintf(stderr, "\t%s\r\n",line);
X      }
X    }
X  }
X  if(f != NULL) fclose(f);
X
X  if (Chdir[0] != '\0')
X    chdir((char *) Chdir);
X
X  if(seven_bit){
X    seven_bit_in = 1;
X    seven_bit_out = 1;
X  }
X
X  if (! login_type && !rshtype)
X    rshtype = -1;
X
X  if (!user_share) {
X    share = 0;
X    savedeid = -1;
X  }else if (user_share > 0) {
X    share = (share == 1) ? 1 : 2;
X  };
X
X#if 0 /* Useful for debugging */
X  for(m = 0;m < RC_OPTIONS_SIZE;m += 3)
X    switch ( (int) *rc_options[m+1] ){
X    case INT_TYPE:
X    {
X      int *o;
X      o = (int *) rc_options[m+2];
X      fprintf(stderr,"%s %d\r\n",rc_options[m],*o);
X      break;
X    }
X  }
X#endif
X}
X
X#define GETOPT_OPTS "Aac:d:f:l:n:ors:t:v:w:P:S:q"
X
Xint main(int argc, char *argv[]) 
X{
X  
X  int s, c, i;
X  char *ptr=NULL, *path=NULL;
X  int umask_old;
X
X  breakout_string[0] = 0;
X  term_opterr = 0;
X  while ((c = term_getopt (argc, argv, GETOPT_OPTS)) != EOF) 
X    switch(c) {
X    case 'S':
X      read_int_type(&user_share,term_optarg);
X      if (!user_share) share=0;
X      break;
X    case 'q':
X      ++quiet;
X      break;
X  }; term_optind = 1;
X
X  if (quiet <= 1)
X    fprintf(stderr, "Term version: %s\r\n",str_version(VERSION));
X
X  /* initialize character escaping. */
X  for (i = 0; i < 256;i++) {
X    ignores[i] = 0;
X    escapes[i] = 0;
X  }
X
X  escapes['^'] = 1;
X
X  main_init();
X
X  if (!term_server) {
X    term_server=getenv("TERMSERVER");
X    if (!term_server) term_server = "";
X  }
X
X  /* read in the termrc file. */
X  read_rc(0);
X
X  if(share > 0)
X    fprintf(stderr, "Using shared mode.\r\n");
X
X  /* then check env variables. */
X  setbuf(stderr, 0);
X  if (getenv("BAUDRATE")) 
X    sscanf(getenv("BAUDRATE"),"%lu",&baudrate);
X
X  /* Then check command line options */
X  /*
X    The code to parse the command line was written by the
X    one and only Muhammad Saggaf. If you have any question
X    about Linux, networking, Unix, or life in general, 
X    don't ask him mate! :). Chances are he doesn't know the 
X    answer.
X    */
X  
X  term_opterr = 0;
X  
X  while ((c = term_getopt (argc, argv, GETOPT_OPTS)) !=EOF)
X    switch(c) {
X    case 'A':
X      auto_retrain = 1;
X      break;
X    case 'a':
X      {
X	extern int tok_byte_mask_out, tok_byte_width_out,
X	  tok_byte_mask_in, tok_byte_width_in;
X	tok_byte_mask_out = tok_byte_mask_in = 127;
X	tok_byte_width_out = tok_byte_width_in = 7;
X
X	seven_bit_in = seven_bit_out = 1;
X	in_mask = out_mask = 127;
X	break;
X      }
X    case 'f': 
X      read_int_type(&fudge_flow,term_optarg);
X      break;
X    case 'l':
X      i = open(term_optarg, O_RDWR | O_CREAT | O_TRUNC, 0644);
X      if (i < 0) {
X	perror("open");
X	fprintf(stderr, "Unable to open log file %s\r\n", term_optarg);
X	break;
X      }else {
X        modem_noise = 0;
X      }
X      if (i != 2) {
X	close(2);		/* Just to make sure.. */
X	dup2(i, 2);
X	close(i);
X      }
X      break;
X    case 'r': remote = 1; break;
X    case 't':
X      sscanf(term_optarg,"%lu",&packet_timeout);
X      break;
X    case 'v':
X
X				/* add a device to the list. */
X      i = open(term_optarg, O_RDWR);
X      if (i < 0) {
X	perror("open");
X	fprintf(stderr,"Unable to open modem device %s\r\n", term_optarg);
X	break;
X      }
X      if(modem_in>=0) close(modem_in);
X      if(modem_out>=0) close(modem_out);
X      modem_in = i;
X      modem_out = i;
X      break;
X    case 'w':
X      read_int_type(&window_size_max,term_optarg);
X      break;
X    case 'd': 
X      read_int_type(&term_debug,term_optarg);
X      fprintf(stderr, "Debugging = %x\n", term_debug);
X      break;
X    case 'c':
X      read_int_type(&compressing,term_optarg);
X      break;
X    case 'n':
X      read_int_type(&write_noise,term_optarg);
X      break;
X    case 's':
X      sscanf(term_optarg,"%lu",&baudrate);
X      break;
X    case 'q':
X    case 'S':
X      break;
X    default:
X      fprintf(stderr, "unrecognized or incomplete argument '%s'. Exiting\r\n",  argv[term_optind-1]);
X      exit(-1);
X    }
X  
X  if (term_optind < argc)
X    term_server = argv[term_optind];
X  
X  for (s = 0; s < MAX_CLIENTS;++s) {
X    clients[s].fd = -1;
X  }
X
X				/* Read in a specific termrc. */
X  if (term_server[0])
X    read_rc(term_server);
X
X  if (!share) {
X    do {
X      if ((path = get_term_path(&ptr))) {
X        strcat(path,"/.term");
X        if (access(path, X_OK | R_OK | W_OK) < 0) continue;
X        if (chmod(path,0700)  < 0) {
X          if (!quiet) 
X            fprintf(stderr,"Can't set permissions on %s to 0700\r\n",
X              path);
X          continue;
X        }
X        break;
X      }else break;
X    } while ( ptr );
X    if (! path) {
X      fprintf(stderr, "Failed to find any of:\r\n");
X      ptr = NULL;
X      do {
X        if ((path = get_term_path(&ptr))) {
X          strcat(path,"/.term");
X          fprintf(stderr,"\t%s\r\n",path);
X        }else break;
X      } while ( ptr );
X      exit(1);
X    }
X    strcat(path,"/socket");
X    strcat(path,term_server);
X  }else{
X    if (savedeid >= 0){ 
X      if (share == 2)
X        setuid(savedeid);
X      else
X        setgid(savedeid);
X    }
X
X/* set the protection to be explicitly what I define below */
X    umask_old=umask(0);
X
X    do {
X      if ((path = get_term_path(&ptr))) {
X        if (eaccess(path, getuid() ? (X_OK | R_OK) : 0) < 0) continue;
X        break;
X      }else break;
X    } while ( ptr );
X    if (! path) {
X      fprintf(stderr, "Failed to find any of:\r\n");
X      ptr = NULL;
X      do {
X        if ((path = get_term_path(&ptr))) {
X          fprintf(stderr,"\t%s\r\n",path);
X        }else break;
X      } while ( ptr );
X      exit(1);
X    }
X
X/* Create a link to "." as ".term" for backwards compatibility */
X
X    i=strlen(path);
X    strcat(path,"/.term");
X    if (eaccess(path, X_OK | R_OK ) < 0) 
X      symlink("./tmp/private",path);
X    path[i]='\0';
X
X/* If the needed directories don't exist, create them */
X    strcat(path,"/tmp");
X    mkdir(path,0777);
X
X/* Make sure we can access the directory */
X
X    if (eaccess(path, getuid() ?  (X_OK | W_OK | R_OK) : 0) < 0) 
X      if (chmod(path,0777) < 0) {
X
X      fprintf(stderr, "Can't read, write, &/or execute %s\r\n",
X        path);
X      exit(1);
X    }
X
X/* It seems that the protection on sock_unix is ignored, so we need a 
X   a make a subdirectory, that only term can see. */
X
X    strcat(path,"/private");
X    strcat(path,term_server);
X
X/* Remove any old sockets */
X    i=strlen(path);
X    strcat(path,"/socket");
X    unlink(path);
X    path[i]='\0';
X
X/* Remove and recreate the private directory, so we can be sure we can see it */
X    rmdir(path);
X    if (share == 2) {
X      mkdir(path, 0700|S_ISUID);
X      chmod(path, 0700|S_ISUID);
X    }else {
X      mkdir(path, 0770|S_ISGID);
X      chmod(path, 0770|S_ISGID);
X    };
X  
X/* Finally make sure we can access the directory */
X
X    if (eaccess(path, getuid() ? (X_OK | W_OK | R_OK) : 0) < 0) {
X      fprintf(stderr, "Can't read, write, &/or execute %s\r\n",
X        path);
X      exit(1);
X    }
X
X    strcat(path,"/socket");
X
X/* Restore the mask to what the user wants to use with tupload. */
X    umask(umask_old);
X  }
X
X/* It doesn't hurt to unlink twice ... */  
X  unlink(path);
X  if ((s = bind_unix(path)) < 0) 
X    exit(1);
X
X  setuid(getuid());
X  setgid(getgid());
X
X  /* init modules */
X 
X  var_init();
X  serial_init();
X  compress_init();
X  update_time();
X  
X#ifdef SYSV
X  sigset(SIGCHLD, sig_child);
X#else
X  signal(SIGCHLD, sig_child);
X#endif /* SYSV */
X  signal(SIGHUP, sig_quit);
X  signal(SIGPIPE, sig_ignore);
X  signal(SIGINT, sig_quit);
X  signal(SIGQUIT, sig_quit);
X  signal(SIGIOT, sig_core);
X  signal(SIGSEGV, sig_core);
X  signal(SIGALRM, sig_ignore);
X
X  terminal_save(0);
X  set_nonblock(s);
X  set_nonblock(modem_in);
X  set_nonblock(modem_out);
X  terminal_raw(modem_in);
X  terminal_raw(modem_out);
X
X  if (ownroot[0]) {
X    if (!chroot(ownroot)) {
X      perror("chroot");
X      if (rshtype > 0) {
X        fprintf(stderr, "Your chroot failed.  Exiting rather than risking invasion\n");
X        exit(1);
X      }
X    }
X  }else if (rshtype > 0) {
X    if (!quiet) 
X      fprintf(stderr,"Warning, you have done denyrsh without chroot()!\n");
X  }
X  
X  main_loop(s);
X
X  set_block(modem_in);
X  set_block(modem_out);
X  terminal_restore(0);
X  terminal_restore(1);
X
X  set_block(s);
X
X  /* with C_QUIT 2 or if hangup_on_exit and not C_QUIT 1 */
X  if (!remote && (do_shutdown==2 || (hangup_on_exit && do_shutdown!=1))) {
X    sleep(2);	/* one second may not be enough */
X    write(modem_out, "+++", 3);
X    sleep(2);
X    if (explicit_hangup) 
X      write(modem_out, "ath0\r", 5);
X  }
X  exit(0);
X}
X
X/*-----------------------------------------------------------------------*/
Xvoid check_client(int cl, int ret) {
X  DEBUG_MAIN(stderr, "%s: termerrno == %d\n", term_server, termerrno);
X  if (!termerrno) return;
X  if (clients[cl].state == 3 ) {
X    DEBUG_FP(stderr, "%s:truncating out_buff\n", term_server);
X    clients[cl].out_buff.size = 0;
X    clients[cl].out_buff.start = clients[cl].out_buff.end;
X    return;
X  }
X#if 0
X  if (ret < 0)
X    perror("client gave this");
X#endif
X				/* Ok. Close the descriptor. */
X  if(clients[cl].fd >= 0) close(clients[cl].fd);
X  clients[cl].fd = -1;
X				/* And go to state 2. */
X  clients[cl].state = 2;
X}
X
Xint new_client(int fd) {
X  int j;
X
X  for (j = remote; j < MAX_CLIENTS;j += 2)
X    if (clients[j].fd < 0 && clients[j].state < 0) break;
X
X  if (j == MAX_CLIENTS) return -1; /* not maximum clients */
X
X  DEBUG_FP(stderr, "%s: new client %d.\n", term_server, j);
X  
X  clear_buffers(&clients[j]);
X
X  clients[j].fd = fd;
X  clients[j].type = T_SMART | T_RDFILE | T_WRFILE;
X  clients[j].udp_type = 0; 
X  clients[j].udp_size = 0; 
X  clients[j].dump_count = 0;
X  clients[j].cl_type = CL_SOCKET;
X  clients[j].compress = compressing;
X  clients[j].state = 1;
X  clients[j].c_state = 0;
X  clients[j].number = j;
X  clients[j].priority = 0;
X  clients[j].queue = 0;
X  clients[j].name[0] = 0;
X  clients[j].parent = -1;
X  set_nonblock(fd);
X  return j;
X}
X/*------------------------------------------------------------------------*/
X/* Main loop. Hangs around waiting for things to get ready, and calls to  */
X/* appropriate routines. 						  */
X
Xvoid main_loop(int socket) {
X  struct timeval timeout;
X  fd_set reads, writes, excepts;
X  int i, j, k, empty = 1, csocket = -1, bytes_received = 0, script_fd = -1;
X  int max = 0;
X
X  while (!do_shutdown) {
X
X/* If the serial out buffer is empty, try and put something in it */
X    if (bytes_left > 0 && serial_out.size < bytes_left) {
X      DEBUG_SER(stderr, "%s: doing serial out\n",
X	       term_server);
X      do_serial_out(0);
X      if (!serial_out.size)
X	do_link_out();
X      if (!serial_out.size) 
X	do_serial_out(0);
X      DEBUG_SER(stderr, "%s:  serial out size %d\n",
X	       term_server, serial_out.size);
X    }
X
X/* Set up client stuff */
X/* We select to read if: */
X/*	The input buffer is empty */
X/* We select to write if: */
X/*      The output buffer is not empty */
X/*      We're waiting for a connection to complete (state == 5) */
X
X    FD_ZERO(&reads);
X    FD_ZERO(&writes);
X    FD_ZERO(&excepts);
X    
X    if (p_in_num && empty)
X      do_link_in();
X    
X    for (i = 0; i < MAX_CLIENTS;++i) {
X				/* If it's closing down, and the */
X				/* buffers are empty, then kill it. */
X      if ((clients[i].state == 3 || clients[i].state == 4) &&
X	  (clients[i].type & T_UDP ||
X           (!clients[i].in_buff.size && !clients[i].out_buff.size ))) {
X        int l;
X
X	DEBUG_FP(stderr, "%s:real close %d %d %d\n", term_server , i,
X		 clients[i].state, clients[i].fd);
X        for(l=0;l<MAX_CLIENTS;++l)
X          if(clients[l].parent == i && clients[l].state == 1 )
X            clients[l].state = 3;
X	if (clients[i].fd > 0) close(clients[i].fd);
X	clients[i].fd = -1;
X	if (clients[i].state == 3)
X	  clients[i].state = -1; 
X	else clients[i].state = 1;
X	continue;
X      }
X				/* If it's a file, we don't need to */
X				/* select() on it. */
X      if (clients[i].cl_type == CL_FILE) continue;
X      if (clients[i].fd < 0) continue; /* If it's not a file, and */
X				       /* there is no fd, then no */
X				       /* select(). */
X      if (clients[i].in_buff.size < 2 * packet_len &&
X            (clients[i].type & T_RDFILE) && clients[i].state == 1) {
X	FD_SET(clients[i].fd, &reads);
X      }
X      if ((clients[i].out_buff.size && (clients[i].type & T_WRFILE)) ||
X	  (clients[i].state == 5)) {
X	FD_SET(clients[i].fd, &writes);
X      }
X      FD_SET(clients[i].fd, &excepts);
X      if (max < clients[i].fd) max = clients[i].fd;
X    }
X    
X/* Select for socket and modem */
X/* We select read for socket if we aren't at the maximum number */
X/* of clients */
X    if (num_clients < MAX_CLIENTS) {
X      FD_SET(socket, &reads);
X      if (max < socket) max = socket;
X      if(onetime_term_socket >=0){
X        FD_SET(onetime_term_socket, &reads);
X        if (max < onetime_term_socket) max = onetime_term_socket;
X      };
X    }
X
X/* We select for read on the modem if the serial in buffer is empty */
X    if (!serial_in.size) {
X      FD_SET(modem_in, &reads);
X      if (max < modem_in) max = modem_in;
X    }
X
X/* Now if there is anything in the serial out buffer, select for writing */
X
X    if (serial_out.size && bytes_left > 0) {
X      DEBUG_SER(stderr, "%s: dso: fd set\n",
X	       term_server);
X      FD_SET(modem_out, &writes);
X      if (max < modem_out) max = modem_out;
X    }
X
X/* We need to call the script from the main loop, since we want term up */
X/* and running first. To avoid sending data too soon, the script won't run */
X/* until the first term command has been sent by the user. This may cause */
X/* some confusion, if for example the script is 'txconn' and the first */
X/* command is 'trsh -s xterm', but I can't think of a way to avoid this. */
X
X    if (shell_command[0] && remote_term_version) { 
X      script_fd = open_socket(shell_command); 
X        set_nonblock(script_fd);
X      shell_command[0] = 0;
X    }
X    if (script_fd >= 0) 
X      FD_SET(script_fd, &writes);
X
X				/* This is only for my own purposes. */
X
X/* This is intended as a short delay to help decrease CPU usage. */
X    timeout.tv_sec = 0;
X    timeout.tv_usec = (unsigned long int) delay;
X    select(0, NULL, NULL, NULL, &timeout);
X
X/* Set the timeout value for select(). */
X    timeout.tv_sec = 0;
X    timeout.tv_usec = 500000; /* 0.5 seconds */
X
X/* do select() */	
X    if (select(max+1, &reads, &writes, &excepts, &timeout) < 0) {
X				/* This is perfectly normal. Things */
X				/* that send signals will cause select */
X				/* to exit with an error. */
X#if 0
X      perror("select");
X#endif
X      continue;
X    }	
X
X/* Update current_time. This is maintained in 20th s of a second */
X    update_time();
X
X/* start checking to see what's ready and what's not */
X
X/* See if it is just the script */
X
X    if (script_fd >= 0 && FD_ISSET(script_fd, &reads)) {
X      memset(shell_command,0,sizeof(shell_command));
X      j = read(script_fd, &shell_command[1], sizeof(shell_command)-1);
X      if ( j <= 0 && errno != ERR_BLOCK) {
X        close(script_fd);
X        script_fd = -1;
X      }else {   /* I copy this exactly to stderr */
X        if (write_noise < 2) fwrite(&shell_command[1],j,sizeof(char),stderr);
X      }
X    }
X
X/* Can we read from modem  ?? */
X    bytes_received = 0;
X    if (!serial_in.size && FD_ISSET(modem_in , &reads)) {
X      j = read_into_buff(modem_in, &serial_in, 0);
X      if ( j < 0 && errno != ERR_BLOCK) {
X	perror("read from modem");
X	return;
X      }
X      else{
X        stat_modem_in += j;
X        if (collisions) bytes_received = j;
X      }
X    }
X
X/* Now we process any new data before writing out to the modem. */
X
X    if (serial_in.size) 
X      do_serial_in();
X
X/* test for new client */
X
X    for(k=0;k<2;k++){
X      switch (k){
X        case 0:
X          csocket = onetime_term_socket;
X          break;
X        case 1:
X        default:
X          csocket = socket;
X          break;
X      };
X      if(csocket<0) continue;
X      if (FD_ISSET(csocket, &reads)) { /* try for a connect. */
X
X        struct sockaddr_in addr_in;
X
X#if defined(STREAMS_PIPE) || defined(X_STREAMS_PIPE)
X 	i = CheckClientConnection(csocket);
X	if (i != -2) {			/* we have a streams pipe */
X		if (i == -1) {
X			fprintf(stderr, "can't add client\n");
X			continue;
X		} /* else fall through to add new client after "accept ..." */
X	} else 		/* not a streams pipe */
X#endif
X        {
X          int din = sizeof(addr_in);
X          if ((i = accept(csocket , (struct sockaddr *) &addr_in, &din)) >= 0) {
X            if (addr_in.sin_family == AF_INET) {
X              if (addr_in.sin_addr.s_addr != htonl(term_localaddr)
X                  && addr_in.sin_addr.s_addr != INADDR_ANY 
X                  && addr_in.sin_addr.s_addr != inet_addr("127.0.0.1") ) {
X                close(i);
X                i = -1;
X                DEBUG_FP(stderr,"%s: rejected connection from %s\n",
X                  term_server, inet_ntoa(addr_in.sin_addr));
X              }else {
X                DEBUG_FP(stderr,"%s: accepted connection %d from %s\n",
X                  term_server, i, inet_ntoa(addr_in.sin_addr));
X              }
X            }else {
X              DEBUG_FP(stderr,"%s: accept connection from unix domain\n",
X                term_server);
X            } 
X          }
X        }
X        if (!k) {
X	  int on=1;
X          onetime_term_socket = -1;
X          close(csocket);
X	  setsockopt(i, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on));
X        }
X        
X        if (i >= 0) { /* a new client */
X	  if((j = new_client(i)) < 0) 
X            close(i);
X        }
X        else if (termerrno != 1) {
X#if 0
X	  perror("accept");
X#endif
X        }
X      }
X    };
X
X/* test for data being read from clients */
X    for (i = 0; i < MAX_CLIENTS;++i) {
X      if (clients[i].fd < 0) continue;
X      if (clients[i].in_buff.size >= 2*packet_len) continue;
X      switch (clients[i].cl_type) {
X      case CL_CHILD:		/* fall through */
X      case CL_SOCKET:		/* fall through */
X#if defined(STREAMS_PIPE) || defined(X_STREAMS_PIPE)
X      case CL_SPIPE:
X#endif
X	if (!FD_ISSET(clients[i].fd, &reads) &&
X	    !FD_ISSET(clients[i].fd, &excepts))
X	  continue;
X				/* Fall through. */
X	if (!(clients[i].type & T_RDFILE)) continue;
X        if (clients[i].type & T_UDP)
X          j = recvfrom_into_buff(&clients[i]);
X        else
X	  j = read_into_buff(clients[i].fd, &clients[i].in_buff, 0); 
X	DEBUG_FP(stderr, "%s:read %d bytes from client %d\n",
X		 term_server , j, i);
X				/* Did this client start sending?? */
X	DEBUG_FP(stderr, "%s:j %d, inf_buff.size %d\n",
X		 term_server , j, clients[i].in_buff.size);
X
X				/* Hmmm. Something errored. Lets take */
X				/* a look... */
X	if (j <= 0)
X	  check_client(i, j);
X	if (termerrno == 1)
X	  check_client(i, j);
X	break;
X      case CL_FILE:
X	if (!(clients[i].type & T_RDFILE)) continue;
X	if (! clients[i].dump_count) {
X          close(clients[i].fd);
X          clients[i].fd = -1;
X          clients[i].cl_type = CL_SOCKET;
X          clients[i].type = T_RDFILE | T_WRFILE;
X          clients[i].state = 1;
X          continue;
X        }
X	j = read_into_buff(clients[i].fd, &clients[i].in_buff,
X          (clients[i].dump_count > 32767) ? 32767 
X          : (int) clients[i].dump_count); 
X	DEBUG_FP(stderr, "%s:read %d bytes from file client %d\n",
X		 term_server , j, i);
X	DEBUG_FP(stderr, "%s:j %d, inf_buff.size %d\n",
X		 term_server , j, clients[i].in_buff.size);
X	if (j <= 0)
X	  check_client(i, j);
X	if (termerrno == 1) termerrno = 0;
X	break;
X      case CL_BOUND:
X	if (!FD_ISSET(clients[i].fd, &reads)) continue;
X	{
X	  un_char num[10]; int k;
X				/* We have an accept ready... */
X	  clients[i].type &= ~T_RDFILE; /* Don't try reading it until */
X				/* the accept is done. */
X	  sprintf((char *) num, "%d", i);
X	  for (k =0 ;num[k];++k)
X	    add_to_buffer(&clients[i].in_buff, num[k]);
X	  add_to_buffer(&clients[i].in_buff, 0);
X	}
X	break;
X      }
X    } /* for clients loop */
X    
X#ifndef USE_CONNBLOCK
X/* Test pending connections. */
X    for (i = 0; i < MAX_CLIENTS; ++i) {
X      if (clients[i].state == 5) {
X	char	dummy;
X
X	if (FD_ISSET(clients[i].fd, &writes)) {
X          void ret_ok(struct Client *, int);
X
X	  ret_ok(&clients[i], 0);	/* safe to call from here? */
X	  clients[i].state = 1;
X	}
X	else if (read(clients[i].fd, &dummy, 0) < 0) {
X	  void ret_fail(struct Client *, int, int, char *);
X	  switch (errno) {
X          case ERR_BLOCK:
X	  case ENOTCONN:	/* no status, but maybe timed out */
X	    if (current_time >= clients[i].timeout) {
X	      errno = ETIMEDOUT;
X	      ret_fail(&clients[i], 0, 1, "connect() timed out");
X	      perror("async connect()");
X	      clients[i].state = 2;
X	    }
X	    break;
X	  default:
X	    ret_fail(&clients[i], 0, 1, "connect() timed out");
X	    perror("async connect()");
X	    clients[i].state = 2;
X	    break;
X	  }
X	}
X      }
X    }
X#endif
X
X/* test for data being sent to clients */
X    empty = 1;
X    for (i = 0; i < MAX_CLIENTS;++i) {
X      if (clients[i].fd < 0) continue;
X      if (!clients[i].out_buff.size) continue;
X      if (clients[i].type & T_UDP &&
X        clients[i].out_buff.size < clients[i].udp_size ) continue;
X      switch (clients[i].cl_type) {
X      case CL_CHILD:
X      case CL_SOCKET:
X#if defined(STREAMS_PIPE) || defined(X_STREAMS_PIPE)
X      case CL_SPIPE:
X#endif
X	if  (!FD_ISSET(clients[i].fd, &writes)) continue;
X      case CL_FILE:
X	if (!(clients[i].type & T_WRFILE)) continue;
X				/* something there! :) */
X        if (clients[i].type & T_UDP) {
X          j = sendto_from_buff(&clients[i]);
X          if (!j) break;
X        }else
X  	  j = write_from_buff(clients[i].fd, &clients[i].out_buff,0);
X	DEBUG_FP(stderr, "%s:write %d bytes to client %d\n", 
X		 term_server, j, i);
X	if (j <= 0)
X	  check_client(i, j);
X	else stat_cooked_in += j;
X	break;
X      case CL_BOUND:
X	break;
X      }				/* switch */
X    }				/* for clients loop */
X    
X/* Ok. Can we write to modem ??? */
X    if (FD_ISSET(modem_out, &writes) && bytes_left > 0) {
X      
X      int t = bytes_left;
X      if (t > serial_out.size)
X	t = serial_out.size;
X      if (t > block_size)
X        t = block_size;
X      DEBUG_SER(stderr, "%s: dso: write from buff\n",
X	       term_server);
X      j = write_from_buff(modem_out, &serial_out, t);
X      if (j < 1 && termerrno != 1) {
X	errno = termerrno - 1;
X	perror("write to modem");
X	return;
X      }else {
X	stat_modem_out += j;
X        bytes_left -= j + bytes_received + (modem_noise ? modem_noise - 1 : 0);
X      }
X    }
X
X  } /* while loop */
X
X  if (script_fd >= 0) close(script_fd);
X 
X} /* function */
X
END_OF_FILE
  if test 36204 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
  fi
  # end of 'main.c'
fi
echo shar: End of archive 3 \(of 6\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
