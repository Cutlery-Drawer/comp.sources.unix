Newsgroups: comp.sources.unix
From: mikew@gopher.dosli.govt.nz (Mike Williams)
Subject: v28i134: ckpasswd - a password checker, Part01/01
Message-id: <1.782722071.12936@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: mikew@gopher.dosli.govt.nz (Mike Williams)
Posting-Number: Volume 28, Issue 134
Archive-Name: ckpasswd/part01

#!/bin/sh
# This is a shell archive.  Save it in a file, remove anything before
# this line, and then unpack it by entering "sh file".  Note, it may
# create directories; files and directories will be owned by you and
# have default permissions.
#
# This archive contains:
#
#	README
#	INSTALL
#	Makefile
#	ckpasswd
#	ckpasswd.8
#	bloomer
#	bloomer.8
#	ckpasswd.conf.proto
#	mpasswd
#
echo x - README
sed 's/^X//' >README << 'END-of-README'
X
X		      ckpasswd - a password checker
X
X			       Mike Williams
X		   Dept. of Land and Survey Information
X				New Zealand
X		       <mikew@gopher.dosli.govt.nz>
X
X			      21 October 1994
X
X
Xckpasswd is a utility that will check the "safety" of a candidate password.
XIt is NOT (by itself) a passwd(1) replacement, as it does none of the work
Xof updating the /etc/passwd file, etc. (but see mpasswd, below).
X
Xckpasswd is designed to be invoked by a passwd(1) replacement to check the
Xusers candidate password.  The candidate password is read from standard
Xinput.  If ckpasswd determines that the password is bad, it returns an
Xexplanation of why on stdout.  The calling program is expected to reject
Xthe candidate password, possibly displaying the explanation and prompting
Xthe user for another password.  If the password is okay, ckpasswd just
Xexits with no output.
X
XFEATURES
X--------
X
X  * Highly configurable.
X  * Written in perl for easy customisation.
X  * Does not need to run setuid to root.
X
X  * Can access a variety of dictionary types to check for bad passwords:
X      - plain ASCII sorted file
X      - case-folded sorted file (sorted with "sort -f")
X      - DBM database
X      - "Bloom filter" hash file
X      - ispell(1) dictionary
X
X  * Checks for password which may be based on real-world information about
X    the user, including:
X      - dates
X      - phone numbers
X      - number plates
X      - username
X      - user's full name
X      - user's initials
X
X  * Checks for simple transformations of words, including:
X      - mixing case
X      - pre-pending or appending digits/whitespace/punctuation
X      - doubling & reflecting, eg. "blahblah", "blahhalb"
X
X  * Checks for
X      - alphabetic sequences
X      - QWERTY sequences
X      - host names
X
XWHY A SEPARATE PROGRAM?
X-----------------------
X
XWhy put the password checking functionality in a separate program rather
Xthan (say) a C library?  Well, the main reason is that I wanted to write
Xckpasswd in perl, to make it more portable, flexible, powerful,
Xmaintainable, etc etc.
X
XHowever, I didn't want to implement the entire functionality of passwd(1)
Xin perl, for several reasons:
X
X  * Implementing passwd(1) in perl may be less secure.  Security could be
X    compromised if an attacker was able to alter any of:
X      - the passwd(1) script itself;
X      - perl libraries included by the script;
X      - the perl binary.
X    As passwd(1) must run as root, I was not prepared to take the risk.
X
X  * On some systems (like mine) passwd(1) may need to do various things
X    that are not easily accomplished in perl.  For instance:
X      - update an alternate authorisation database (eg. shadow passwords);
X      - update the NIS passwd database;
X      - update a BIND/Hesiod passwd database.
X
XFrom a security point of view, the risk is greatly reduced as ckpasswd need
Xnot run set-uid to root.  In fact, the passwd(1) program could
Xseteuid("nobody") before invoking ckpasswd.  There is still the danger of
Xan attacker modifying ckpasswd to somehow record password choices, but this
Xis not any worse that the risk of same attacker replacing /bin/passwd!
X
XImplementing ckpasswd as a standalone program also makes it easier to upgrade,
Xtest and or invoke from other systems that need password checking
Xfunctionality. 
X
XA SIMPLE PASSWD(1) WRAPPER
X--------------------------
X
XIncluded is a simple wrapper around /bin/passwd that will make use of
Xckpasswd.  mpasswd opens a pseudo-terminal, where it invokes /bin/passwd.
XReplies to the "new password" prompt are checked using ckpasswd before
Xbeing passed on to the /bin/passwd process.
X
XVERSION 1.0
X-----------
X
XNote that this is the first time I've released ckpasswd.  You have been
Xwarned!  Bug reports, suggestions and feedback are welcome, although I hope
Xthat it won't need too much more development.
X
XEnjoy!
XMike W.
END-of-README
echo x - INSTALL
sed 's/^X//' >INSTALL << 'END-of-INSTALL'
X
X			    Installing ckpasswd
X			    -------------------
X
X  * Pre-requistites:
X
X	perl is essential
X	ispell is recommended
X	a keen mind is handy
X
X  * Edit the Makefile to alter the desired install location.
X  * Run "make install".
X
X  * Create/aquire word dictionaries as desired.  A good native-language
X    dictionary (eg. an ispell dictionary) may cover most of your
X    requirements, but you should really get hold of some other wordlists,
X    covering areas such as:
X
X      - popular culture (TV, movies, etc.)
X      - common names
X      - literary references
X      - computer jargon
X
X    A good source for word-lists is:
X
X      ftp://coast.cs.purdue.edu/pub/dict/
X
X    I suggest creating Bloom-filter dictionaries using the bloomer(8)
X    utility provided.  You could even save space by loading a number of
X    lists into one Bloom-filter.
X
X  * Copy the installed ckpasswd.conf.proto to ckpasswd.conf, and modify as
X    desired.  See the ckpasswd(8) manpage for help.
X
X  * Install a passwd(1) replacement of your choice.  Modify as necessary to
X    use ckpasswd.  The mpasswd script supplied is a simple wrapper around
X    /bin/passwd ... I install it as /usr/local/bin/passwd.
END-of-INSTALL
echo x - Makefile
sed 's/^X//' >Makefile << 'END-of-Makefile'
X## $Id: Makefile,v 1.1 1994/10/21 03:33:23 mikew Exp $
X## ========================================================================
X## Makefile -- Makefile to ease installation of ckpasswd
X## Author          : Mike Williams <mikew@gopher.dosli.govt.nz>
X## ========================================================================
X
XSHELL = /bin/sh
X
Xprefix = /usr/local
X
Xlibdir = $(prefix)/lib
Xmanext = 8
Xmandir = $(prefix)/man/man$(manext)
X
Xall: 
Xclean:
X
Xinstall: ckpasswd bloomer ckpasswd.conf.proto
X	-@[ -d $(libdir) ] || mkdir $(libdir)
X	cp -f ckpasswd bloomer ckpasswd.conf.proto $(libdir)
X
Xinstall.man: ckpasswd.8 bloomer.8
X	-@[ -d $(mandir) ] || mkdir $(mandir)
X	cp -f ckpasswd.8 $(mandir)/ckpasswd.$(manext)
X	cp -f bloomer.8 $(mandir)/bloomer.$(manext)
X
X
XARCHIVE = ckpasswd-1.0
XMANIFEST = \
X  README INSTALL Makefile \
X  ckpasswd ckpasswd.8 bloomer bloomer.8 \
X  ckpasswd.conf.proto mpasswd
X
Xtar: $(MANIFEST)
X	rm -rf $(ARCHIVE)
X	mkdir $(ARCHIVE)
X	ln $(MANIFEST) $(ARCHIVE)
X	tar cf - $(ARCHIVE) > $(ARCHIVE).tar
X	rm -rf $(ARCHIVE)
X
Xshar: $(MANIFEST)
X	shar $(MANIFEST) > $(ARCHIVE).shar
END-of-Makefile
echo x - ckpasswd
sed 's/^X//' >ckpasswd << 'END-of-ckpasswd'
X#!/usr/local/bin/perl
X## $Id: ckpasswd,v 1.23 1994/10/20 23:54:52 mikew Exp $
X## ========================================================================
X## ckpasswd -- Password checker
X## Author          : Mike Williams <mikew@gopher.dosli.govt.nz>
X## ========================================================================
X
X# Copyright (C) 1994 Mike Williams
X# 
X# This program is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation; either version 2 of the License, or
X# (at your option) any later version.
X# 
X# This program is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X
X# ckpasswd is a utility that will check the "safety" of a candidate
X# password.  If is found to be "bad", ckpasswd explains why.
X#
X# Basically, ckpasswd screens candidate passwords against one or more
X# bad-password dictionaries.  It checks not only the word itself, but also
X# various transformations of the word (ala cracklib).  A number of
X# different dictionary formats are recognised, including sorted & unsorted
X# ASCII files, dbm databases, ispell dictionaries and Bloom-filter hash
X# tables.
X
X#--- Includes -------------------------------------------------------------
X
Xrequire 'syscall.ph';
Xrequire 'getopts.pl';
Xrequire 'shellwords.pl';
Xrequire 'open2.pl';
Xrequire 'look.pl';
X
X#--- Configuration --------------------------------------------------------
X
X$MINLENGTH = 6;
X$ISPELL = '/usr/local/bin/ispell';
X
X$LIBDIR = '/usr/local/lib/ckpasswd';
X$default_config = "$LIBDIR/ckpasswd.conf";
X
X@transformers =
X    ('strip',
X     'downcase',
X     'deNumberPlate',
X#     'unprefix',
X#     'unsuffix',
X#     'unsuffix_e',
X     'unrepeat',
X     'unreflect',
X     'reverse',
X     'capitalise',
X     );
X
X#--- Parse options --------------------------------------------------------
X
X$usage = "usage: ckpasswd\n";
X
X&Getopts('C:v');
Xdie ($usage) if (@ARGV);
X
X($opt_C = $default_config) if (!$opt_C && -e $default_config);
Xif ($opt_C) {
X    &readConfig($opt_C);
X} else {
X    @dictionaries = ('/usr/dict/words');
X    $dictionaryType{'/usr/dict/words'} = 'sorted-f';
X    $dictionaryDesc{'/usr/dict/words'} = 
X	'it matches a word from /usr/dict/words';
X}
X
X#--- Initialisation -------------------------------------------------------
X
Xchdir ($LIBDIR) || warn "can't cd to '$LIBDIR': $!\n";
X
X# Get user information
X$user = getlogin unless $user;
Xif ($user) {
X    ($user,$passwd,$uid,$gid,$quota,$comment,$gcos,$home,$shell)
X	= getpwnam($user);
X} else {
X    ($user,$passwd,$uid,$gid,$quota,$comment,$gcos,$home,$shell)
X	= getpwuid($<);
X}
Xdie "can't get user info" unless $user;
X
X# @names are all the words from the gcos field
X$names = $gcos;
X$names =~ s/,.*//;		# strip punctuation
X$names =~ s/^\s+//;		# remove leading blanks
X@names = split(' ', $names);
X
X# $names_re matches any word in @names which has at least 3 characters
X$names_re = (@names 
X	     ? '(' . join('|', grep (length($_) > 2, @names)) . ')'
X	     : '^$');
X
X# $initials_re matches concatenation of first letters of @names
X$initials_re = ((@names >= 3)
X	     ? '(' . join('', grep ($_ = substr($_,0,1), @names)) . ')'
X	     : '^$');
X
X# Initialise dictionary packages
Xfor $pkg ('lsearch', 'bsearch', 'bloom', 'dbm', 'ispell') {
X    eval "&${pkg}'init";
X}
X
X#--- Inhibit core dumps ---------------------------------------------------
X
X# Leaving a core dump around could be a security problem (as it will
X# probably contain the user's password).  So, we catch the signals which
X# normally produce core dumps, and exit gracefully.
X
Xfor $sig ('QUIT', 'ILL', 'TRAP', 'IOT', 'EMT',
X	  'FPE', 'BUS', 'SEGV', 'SYS') {
X    $SIG{$sig} = 'sigexit';
X}
X
Xsub sigexit {
X    warn "\ncaught fatal signal - no core dump\n";
X    exit 99;
X}
X
X#--- Read & check password ------------------------------------------------
X
Xchop ($_ = <STDIN>);
Xif ($reason = &badpw($_)) {
X    print "$reason\n";
X    exit 1;
X}
Xexit 0;
X
X#--- Debugging ------------------------------------------------------------
X
Xsub trace 
X{
X    print STDERR (@_) if ($opt_v);
X}
X
X#--- Read config file -----------------------------------------------------
X
Xsub readConfig
X{
X    local ($config) = @_;
X
X    &trace ("reading config file '$config'\n");
X
X    open (CONFIG, "< $config") || do {
X	warn "ckpasswd: error opening $config: $!\n";
X	return ();
X    };
X
X    while (<CONFIG>) {
X	chop;
X	while (/\\$/) {		# handle continuation lines
X	    chop;
X	    ($_ .= <CONFIG>) || last;
X	    chop;
X	}
X	s/#.*//;		# ignore comments
X	next if /^\s*$/;	# skip blank lines
X	if (/^\s*define\s/) {
X	    local ($header, $var, $val) = &shellwords($_);
X	    eval "\$$var = '$val'";
X	} elsif (/^\s*dict\s/) {
X	    local ($header, $dict, $type, $desc) = &shellwords($_);
X	    if (!$type) {
X		warn "ckpasswd: $config:$.: no type specified\n";
X		next;
X	    }
X	    @dictionaries = grep ($_ ne $dict, @dictionaries);
X	    push (@dictionaries, $dict);
X	    $dictionaryType{$dict} = $type;
X	    $dictionaryDesc{$dict} = $desc;
X	} elsif (/^\s*reject\s/) {
X	    local ($header, $pattern, $desc) = &shellwords($_);
X	    $badpats{$pattern} = $desc;
X	}
X    }
X    
X    close (CONFIG);
X}
X
X#--- Password checking ----------------------------------------------------
X
Xsub badpw
X# Check PASSWORD for safety.  It it is determined to be bad, return a
X# string explaining why.
X{
X    local ($_) = @_;
X    local ($reason);
X
X    # Check against hard-coded bad patterns
X    study;
X    return "it was blank!" if (/^\s*$/);
X    return "please use at least $MINLENGTH characters"
X	if (length($_) < $MINLENGTH);
X    return "it looks like a date"
X	if (m:^\d{1,2}[/-]\d{1,2}[/-]\d{2,4}$: ||
X	    (($mo) = /^\d+ *([a-zA-Z]{3,}) *\d+$/) &&
X	    ($mo =~ /^(jan|feb|mar|apr|may|jun)/i ||
X	     $mo =~ /^(jul|aug|sep|oct|nov|dec)/i) );
X    return "it looks like a phone number"
X	if (/\d\d\d[ -]?\d[ -]?\d\d\d$/);
X    return "it looks like a license plate"
X	if (/^[a-z]{2} ?\d{2,5}$/i);
X
X    # Check against user information in /etc/passwd
X    return "it contains your username" if (/$user/i);
X    return "it contains part of your name" if (/$names_re/i);
X    return "it contains your initials" if (/$initials_re/i);
X
X    # Check against patterns from config file
X    while (($pattern, $reason) = each %badpats) {
X	return $reason if (/$pattern/);
X    }
X
X    # Try looking it up
X    return $reason if ($reason = &lookup($_));
X
X    # Try munging it various ways, and doing a lookup
X    if (@descs = &transformLookup($_, @transformers)) {
X	local ($reason) = pop(@descs);
X	local ($last_desc) = pop(@descs);
X	local ($desc) = 
X	    join (",\n  and ",
X		  (@descs ? join(",\n      ", @descs) : ()), 
X		  $last_desc);
X	return "after $desc,\n$reason";
X    }
X
X    # Well, it must be okay
X    ();
X}
X
X#--- Dictionary lookup ----------------------------------------------------
X
Xsub lookup
X# Lookup PASSWORD in all dictionaries, returning explanation if found.  
X# Use list of TRANSFORMATIONS applied to PASSWORD to veto lookup, if
X# required.
X{    
X    local ($_, @transformations) = @_;
X
X    return $lookup{$_} if (defined ($lookup{$_}));
X    
X    &trace ("  lookup '$_'\n");
X
X    # Misc other checks
X    return ($lookup{$_} = "it's an alphabetic sequence")
X	if (&alphabeticP ($_));
X    return ($lookup{$_} = "it looks like a QWERTY keyboard sequence")
X	if (&qwertySequenceP ($_));
X    return ($lookup{$_} = "it's the name of a host")
X	if (@info = gethostbyname($_));
X
X    # Check against dictionaries
X    local ($type, $desc);
X    for $dict (@dictionaries) {
X	$type = $dictionaryType{$dict};
X	$desc = $dictionaryDesc{$dict};
X	if ($type eq 'random' || $type eq 'unsorted') {
X	    return ($lookup{$_} = $desc) if (&lsearch'find($dict,$_));
X	} elsif ($type eq 'sorted') {
X	    return ($lookup{$_} = $desc) if (&bsearch'find($dict,$_));
X	} elsif ($type eq 'sorted-f') {
X	    return ($lookup{$_} = $desc) if (&bsearch'find($dict,$_,1));
X	} elsif ($type eq 'bloom') {
X	    return ($lookup{$_} = $desc) if (&bloom'find($dict,$_));
X	} elsif ($type eq 'dbm') {
X	    return ($lookup{$_} = $desc) if (&dbmdict'find($dict,$_));
X	} elsif ($type eq 'ispell') {
X	    return ($lookup{$_} = $desc) if (&ispell'find($dict,$_));
X	} else {
X	    warn "ckpasswd: invalid dictionary type $type ('$dict')\n";
X	}
X    }
X
X    # Well it must be okay
X    $lookup{$_} = 0;
X}
X
Xsub alphabeticP
X# Return true if ARG is an alphabetic sequence
X{
X    local ($_) = @_;
X    local (@chars) = unpack ('C*', $_);
X    local ($diff);
X    for $i (0 .. $#chars-1) {
X	$diff = $chars[$i+1] - $chars[$i];
X	return () if ($diff > 1 || $diff < -1);
X    }
X    return 1;
X}
X
Xsub qwertySequenceP
X# Return true if ARG is a QWERTY keyboard sequence
X{
X    local ($_) = @_;
X    tr/A-Z/a-z/;
X    tr/qwertyuiop[]{}asdfghjkl;\':\"zxcvbnm,.\/<>?/a-lkla-kjka-jhij/;
X    tr/1234567890\-=/a-l/;
X    tr/!@#\$%^&*()_+/a-l/;
X    &alphabeticP ($_);
X}
X
X#--- Transformation driver ------------------------------------------------
X
Xsub transformLookup
X{
X    local ($_, @transformers) = @_;
X    local ($trans, $munged, $desc, $found, @descs);
X
X    ($trans = shift @transformers) || return ();
X    if ((($munged, $desc) = &$trans ($_)) && ($munged ne $_)) {
X	&trace ("  $trans: '$_' -> '$munged'\n");
X	return ($desc, $found) if ($found = &lookup($munged, $trans));
X	return ($desc, @descs) 
X	    if (@descs = &transformLookup($munged,@transformers));
X    }
X    &transformLookup($_,@transformers);
X}
X
X#--- Transformations ------------------------------------------------------
X
Xsub strip {			# strip leading/trailing 
X    local ($_) = @_;		#   whitespace/digit/punctuation
X
X    return ($_, 'stripping leading whitespace') if (s/^\s+//);
X    return ($_, 'stripping trailing whitespace') if (s/\s+$//);
X
X    return ($_, 'stripping leading digit') if (s/^\d//);
X    return ($_, 'stripping trailing digit') if (s/\d$//);
X
X    local ($punc) = '!"#$%&\'()\*+,-./:;<=>?[\\]^_`{|}~';
X    return ($_, 'stripping leading punctuation') if (s/^[$punc]//);
X    return ($_, 'stripping trailing punctuation') if (s/[$punc]$//);
X
X    ();
X}
X
Xsub downcase {			# convert to lowercase
X    local ($_) = @_;
X    tr/A-Z/a-z/ || return (); 
X    ($_, 'converting to lowercase');
X}
X
Xsub deNumberPlate {		# convert digits to characters
X    local ($_) = @_;
X    study;
X    s/1/i/g; 
X    s/2/to/g; 
X    s/3/e/g;
X    s/4/for/g;
X    s/8/ate/g;
X    s/0/o/g;
X    ($_, 'de-numberplatifying');
X}
X
Xsub reverse {			# invert word
X    local ($_) = @_;
X    $_ = reverse $_;
X    ($_, 'reversing');
X}
X
Xsub unprefix {			# remove common prefixes
X    local ($_) = @_;
X    study;
X    (s/^over-?// ||
X     s/^under-?// ||
X     s/^un-?// ||
X     s/^de-?// ||
X     s/^re-?// ||
X     return ());
X    ($_, 'removing a common prefix');
X}
X
Xsub unsuffix {			# remove common suffixes
X    local ($_) = @_;
X    study;
X    (s/ies$/y/ ||
X     s/s$// ||
X     s/ed$// ||
X     s/er$// ||
X     s/ly$// ||
X     s/ing$// ||
X     s/able$// ||
X     return ());
X    ($_, 'removing a common suffix');
X}
X
Xsub unsuffix_e {		# replace common suffixes with 'e'
X    local ($_) = @_;
X    study;
X    (s/es$/e/ ||
X     s/ed$/e/ ||
X     s/er$/e/ ||
X     s/ing$/e/ ||
X     s/able$/e/ ||
X     s/tion$/te/ ||
X     return ());
X    ($_, 'removing a common suffix');
X}
X
Xsub unrepeat {			# undo repetition, eg. "blahblah"
X    local ($_) = @_;
X    study;
X    s/^(..+)\1\1\1/\1/ || s/^(..+)\1\1/\1/ || s/^(..+)\1/\1/
X	|| return ();
X    ($_, 'removing repeated character sequence');
X}
X
Xsub halve {
X    local ($_) = @_;
X    local ($len) = length($_);
X    local ($half) = int($len/2);
X    (substr ($_, 0, $len-$half), substr ($_, $half));
X}
X
Xsub unreflect {			# collapse palindromes, eg. "baddab"
X    local ($_) = @_;
X    local ($head, $tail) = &halve($_);
X    return ($head, 'removing reflected character sequence')
X	if ($head eq reverse($tail));
X    ();
X}
X
Xsub capitalise {		# capitalise
X    local ($_) = @_;
X    (substr ($_,0,1) =~ tr/a-z/A-Z/) || return (); 
X    ($_, 'capitalising');
X}
X
X#==========================================================================
X#=== Bloom filter =========================================================
X
Xpackage bloom;
X
X#--- Check word -----------------------------------------------------------
X
Xsub find
X# Return true if word is present in bloom filter
X{
X    local ($filter, $word) = @_;
X    local ($variant);
X    &open ($filter, $filter) unless (defined ($VARIANTS{$filter}));
X    for $variant (1 .. $VARIANTS{$filter}) {
X	&getBit( $filter, &hash($SIZE{$filter},$word,$variant) ) || return ();
X    }
X    return 1;
X}
X
X#--- Open bloom filter ----------------------------------------------------
X
Xsub init {
X    $HSIZE = 8;			# Size of filter-file header
X    $MAGIC = 'BF1';		# Magic-string
X}
X
Xsub open
X{
X    local ($fh, $filter) = @_;
X
X    # Read header
X    open ($fh, "< $filter") || do {
X	warn "ckpasswd: error opening $filter: $!\n";
X	return ();
X    };
X    seek ($fh, 0, 0);
X    local ($buffer);
X    sysread ($fh, $buffer, $HSIZE) || do {
X	warn "ckpasswd: error reading $filter: $!\n";
X	return ();
X    };
X    (substr($buffer,0,3) eq $MAGIC) || do {
X	warn "ckpasswd: bad magic number in $filter\n";
X	return ();
X    };
X    ($VARIANTS{$fh}) = unpack ('C', substr($buffer,3,1));
X    ($SIZE{$fh})     = unpack ('N', substr($buffer,4,4));
X
X    $fh;
X}
X
X#--- Hash function --------------------------------------------------------
X
Xsub rotl
X# Rotate BYTE left N bits
X{
X    local ($byte, $n) = @_;
X    $byte = int($byte << ($n % 8));
X    ((($byte) & 0xff00) >> 8) | (($byte) & 0xff);
X}
X
Xsub maxShift
X# Determine maximum amount of shift for a given hash SIZE
X{
X    local ($size) = @_;
X    return $MAXSHIFT{$size} if defined ($MAXSHIFT{$size});
X    local ($maxShift);
X    for ($maxShift = 1; (1 << $maxShift) < $size; $maxShift++) {};
X    $MAXSHIFT{$fh} = $maxShift;
X}
X
Xsub hash
X# Hash STR in hash table of given SIZE, using specified hash function VARIANT
X{
X    local ($size, $str, $variant) = @_;
X    defined($variant) || ($variant = 1);
X    local ($hashval, $shift);
X    local ($shift_inc) = 8 - int($variant / 8);
X    local ($maxShift) = &maxShift($size);
X
X    for $char (unpack('C*', $str)) {
X	$char = &rotl ($char, $variant);  # Rotate the character $variant bits
X	$hashval += ($char << $shift);	  # Shift it over, and add to hashval
X	$shift += $shift_inc;		  # Determine the shift for next time
X	$shift %= $maxShift;
X    }
X    ($hashval % $size);
X}
X
X#--- Access functions -----------------------------------------------------
X
Xsub lseek
X{
X    local ($fh, $byte) = @_;
X    syscall (&main'SYS_lseek, fileno($fh), $byte, 0);
X}
X
Xsub getBit
X{
X    local ($fh, $bit) = @_;
X    local ($offset, $relbit) = (int($bit/8)+$HSIZE, ($bit%8));
X
X    local ($byte);
X    &lseek ($fh, $offset); sysread ($fh, $byte, 1);
X    vec($byte,$relbit,1);
X}
X
X#==========================================================================
X#=== Linear search ========================================================
X
Xpackage lsearch;
X
Xsub find 
X# Search unsorted DICTIONARY and return true if WORD is present.  
X{
X    local ($dictionary, $word) = @_;
X
X    open (DICT, "<$dictionary") || do {
X	warn "ckpasswd: error opening $dictionary: $!\n";
X	return ();
X    };
X    local ($_);
X    while (<DICT>) {
X	chop;
X 	if ($_ eq $word) {
X	    close(DICT);
X	    return 1;
X	}
X    }
X    close(DICT);
X    ();
X}
X
X#==========================================================================
X#=== Binary search ========================================================
X
Xpackage bsearch;
X
Xsub find 
X# Search sorted DICTIONARY and return true if WORD is present.  
X# Assume case was ignored for sorting if CASEFOLD is true.
X{
X    local ($dictionary, $word, $fold) = @_;
X
X    # Open dictionary
X    unless ($opened{$dictionary}) {
X	open ($dictionary, "<$dictionary") || do {
X	    warn "ckpasswd: error opening $dictionary: $!\n";
X	    return ();
X	};
X	$opened{$dictionary}++;
X    }
X
X    # Search for word
X    local ($_);
X    &main'look ($dictionary, $word, 0, $fold);
X    chop ($_ = <$dictionary>);
X
X    $_ eq $word;
X}
X
X#==========================================================================
X#=== DBM search ===========================================================
X
Xpackage dbmdict;
X
Xsub find 
X# Search dbm-file DICTIONARY and return true if WORD is present
X{
X    local ($dictionary, $word) = @_;
X    local (%dict);
X
X    (-e "$dictionary.dir") || do {
X	warn "ckpasswd: dbm file $dictionary does not exist\n";
X	return ();
X    };
X    (dbmopen (%dict, $dictionary, 0644)) || do {
X	warn "ckpasswd: error opening $dictionary: $!\n";
X	return ();
X    };
X    local ($found) = $dict{"$word\0"};
X    dbmclose (%dict);
X    defined($found);
X}
X
X#==========================================================================
X#=== ispell lookup ========================================================
X
Xpackage ispell;
X
Xsub find 
X# Feed word to ispell, and return true if word is spelled correctly.
X{
X    local ($dictionary, $word) = @_;
X
X    # Only check real words
X    return () unless ($word =~ /^[A-Za-z]+$/); 
X
X    # Open ispell connection
X    local ($IN, $OUT, $_);
X    $IN = "IN_$dictionary";
X    $OUT = "OUT_$dictionary";
X    unless ($opened{$dictionary}) {
X	eval {
X	    &main'open2 ($OUT, $IN, $main'ISPELL, '-ald', $dictionary);
X	};
X	die "\nerror invoking ispell\n$@" if ($@);
X	select ((select($IN), $| = 1)[0]);
X	$_ = <$OUT>;		# Skip startup message
X	$opened{$dictionary} = 1;
X    }
X	
X    # Print word and get reply
X    print $IN "$word\n";
X    chop ($_ = <$OUT>); <$OUT>;
X    /^\*/ || /^\+/;
X}
X
X##=== END of ckpasswd =====================================================
END-of-ckpasswd
echo x - ckpasswd.8
sed 's/^X//' >ckpasswd.8 << 'END-of-ckpasswd.8'
X.\" -*- nroff -*-
X.de M           \" man page reference
X\\fI\\$1\\fR\\|(\\$2)\\$3
X..
X.TH ckpasswd 8 DOSLI
X.SH Name
Xckpasswd \- a password checker
X.SH Syntax
X.B /usr/local/lib/ckpasswd/ckpasswd 
X[
X\fB-C \fIconfig-file\fR
X]
X[
X\fB-v\fR
X]
X
X.SH Description
X
X\fBckpasswd\fR is a utility that will check the "safety" of a candidate
Xpassword.  It is NOT (by itself) a passwd(1) replacement, as it does none
Xof the work of updating the /etc/passwd file.
X
X\fBckpasswd\fR is designed to be invoked by a passwd(1) replacement or
Xwrapper to check the users candidate password.  The candidate password is
Xread from standard input.  If \fBckpasswd\fR determines that the password
Xis bad, it returns an explanation of why on stdout.  The calling program is
Xexpected to reject the candidate password, possibly displaying the
Xexplanation and prompting the user for another password.  If the password
Xis okay, \fBckpasswd\fR just exits with no output.
X
X.SH Operation
X
X\fBckpasswd\fR first checks the candidate password against a number of
Xpatterns.  It will reject the password if:
X
X.nf
X  \- it is too short
X  \- it looks like a date, a number-plate or a phone-number
X  \- it contains the user's username or initials
X  \- it contains part of the user's full name 
X  \- it matches a locally-defined bad pattern
X.fi
X
X\fBckpasswd\fR then checks for simplistic passwords, ie. those that:
X
X.nf
X  \- match an alphabetic sequence
X  \- match a sequence of adjacent keys on a QWERTY keyboard
X  \- match the name of a known host
X.fi
X
XNext, \fBckpasswd\fR checks the candidate password against a number of
Xdictionaries.  Finally, a number of transformations are applied to the
Xcandidate password, and the checks for simple passwords and dictionary
Xlookups are performed again on the transformed candidates.
X
X.SH Configuration
X
XA configuration file may be used to tailor the behaviour of \fBckpasswd\fR.
XBy default \fBckpasswd\fR reads "/usr/local/lib/ckpasswd/ckpasswd.conf"; an
Xalternate config file may be specified using the \fB-C\fR option.
X
XThe MINLENGTH parameter defines the minimum length of a password (default
X6).  It can be altered using the "define" keyword, eg.
X
X.EX 1c
Xdefine MINLENGTH 8
X.EE
X
XThe LIBDIR parameter controls where \fBckpasswd\fR looks for data files
Xsuch as dictionaries (default "/usr/local/lib/ckpasswd").  It can also be
Xset using "define", eg.
X
X.EX 1c
Xdefine LIBDIR /mnt/share/lib/dict
X.EE
X
XAdditional "bad password" patterns may be introduced using the "reject"
Xkeyword.  The syntax is:
X
X.Ds
X    \fBreject\fR  \fIpattern\fR   \fIdescription\fR
X.De
X
XThe \fIpattern\fR is a perl(1) regular expression.  The \fIdescription\fR
Xis used when a candidate password matches the \fIpattern\fR, to explain why
Xthe password was rejected, so it should be phrased as a comment about "the
Xcandidate password".  If \fIpattern\fR or \fIdescription\fR contain
Xwhitespace characters, they should be enclosed in single- or double-quotes.
X
XFor example, to disallow lowercase-only passwords, use the following entry:
X
X.EX 1c
Xreject ^[a-z]+$	  "it's all lowercase -- too simple"
X.EE
X
XDictionaries are specified using the "dict" keyword.  The syntax is:
X
X.Ds
X    \fBdict\fR  \fIdict-file\fR  \fIformat\fR    \fIdescription\fR
X.De
X
X\fIdict-file\fR is a path-name relative to LIBDIR, which specifies where
Xthe dictionary can be found.  The \fIdescription\fR is used as previously
Xexplained.  The \fIformat\fR parameter determines the dictionary type;
Xsupported values are:
X
X.TP
Xrandom
XAn unsorted ASCII file of words, one per line.
X
X.TP
Xsorted
XAn ASCII file, sorted in exact alphabetic order.
X
X.TP
Xsorted-f
XAn ASCII file, sorted with case-folding (using 'sort -f').  This is the
Xusual format of the file "/usr/dict/words", as found on some Unix systems. 
X
X.TP
Xbloom 
XA Bloom-filter hash-table.  A Bloom-filter is a probablistic
Xword-membership checker, implemented as a large bitmap.
X
X.TP
Xdbm
XA dbm(1) database file, with the words as keys.
X
X.TP
Xispell
XAn ispell(1) dictionary.  Note that use of ispell dictionaries requires
Xthat ispell(1) be installed! 
X
X.SH Options
X
X.TP
X\fB-C \fIconfig-file\fR
XUse the specified \fIconfig-file\fR rather than the default.
X
X.TP
X\fB\-v\fR
X(Verbose).  Log debugging information to stderr.
X
X.SH See Also
X.M passwd 1 ,
X.M bloomer 8 ,
X.M ispell 1
X
X.SH Author
XMike Williams <mikew@gopher.dosli.govt.nz>
END-of-ckpasswd.8
echo x - bloomer
sed 's/^X//' >bloomer << 'END-of-bloomer'
X#!/usr/local/bin/perl
X## $Id: bloomer,v 1.10 1994/10/20 23:54:31 mikew Exp $
X## ========================================================================
X## bloomer -- Bloom-filter maintenance/lookup
X## Author          : Mike Williams <mikew@gopher.dosli.govt.nz>
X## ========================================================================
X
X# Copyright (C) 1994 Mike Williams
X# 
X# This program is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation; either version 2 of the License, or
X# (at your option) any later version.
X# 
X# This program is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X
X# bloomer maintains and does lookups on a Bloom-filter, which is a
X# probablistic word-membership checker, implemented as a large bitmap.
X# 
X# When loading words into the filter, each word is hashed using a number of
X# independant hash-functions, generating a number of discrete values.  Each
X# of these is used as an index into the bitmap, and the corresponding bits
X# are set.
X# 
X# To perform a lookup, the candidate word is hashed using the same hash-
X# functions, and the corresponding locations in the bitmap are checked.  If
X# any of the bits are false, we can be sure the candidate word wasn't
X# present in the original word-list.  If all bits are set, it is assumed
X# that the word was (probably) present.
X# 
X# The accuracy of the Bloom-filter depends on the size of the bitmap, the
X# number of hash-functions used, and the number of words entered into the
X# filter.  To be more concrete, if
X# 
X#   h = number of hash-functions
X#   N = bitmap (hash table) size
X#   w = number of words entered
X#   u = proportion of bits left unset
X#   b = probability of a "bogus" hit
X#   
X# then	u = (1 - (h/N)) ^ w		
X#  and 	b = (1 - u) ^ h
X# 
X# eg. let h = 8		(8 hash functions)
X#         N = 524280 	(64k bitmap)
X#         w = 24474	(/usr/dict/words, 200k)
X#         
X#    then u = 0.7212
X#         b = 0.000131	(ie. 0.1% chance of a bogus hit)
X
X#=== Usage ================================================================
X
X# bloomer -n <filter> <size> <var>
X#   Creates a new Bloom-filter file <filter>, using parameters <size> for
X#   size of filter, and <var> for number of hash functions to use.  The
X#   <size> parameters may be specified with the suffix "k", in which case
X#   it specifies a file-size rather than a bitmap-size.
X
X# bloomer -a <filter> 	
X#   Reads words from stdin and inserts them into the Bloom-filter file
X#   <filter>.  Words are echoed as they are added.  With the "-v" option,
X#   hash values for the words are printed as well.
X
X# bloomer <filter> 	
X#   Reads words from stdin, echoing the ones that are matched by the filter
X#   to stdout.  With the "-v" option, hash values for the words are printed
X#   as well.
X
X# bloomer -i <filter> 	
X#   Shows info about the Bloom-filter file <filter>, showing the <size> and
X#   <var> parameters it was created with, and calculating the percentage of
X#   bits set in the filter.  With the "-v" option, it also prints each
X#   bitmap location that is set.
X
X$usage = <<EOF;
Xusage: bloomer [-v] -n <filter> <size> <nvar> 	create a new filter
X       bloomer [-v] -a <filter> 		add words from STDIN
X       bloomer [-v] [-t] <filter> 		test words from STDIN
X       bloomer [-v] -i <filter> 		show info
XEOF
X
Xrequire 'syscall.ph';
Xrequire 'getopts.pl';
X&Getopts('naivt') || die "$usage";
X
X#=== Initialisation =======================================================
X
X$HSIZE = 8;			# Size (in bytes) of filter-file header
X$MAGIC = 'BF1';			# Magic-string
X
Xif ($opt_t) {			# Test mode
X
X    die $usage unless (@ARGV == 2);
X    ($SIZE, $VARIANTS) = @ARGV;
X
X    if ($SIZE =~ /^([0-9]+)k$/i) {
X	$SIZE = ((int($1) * 1024) - $HSIZE) * 8;
X    }
X
X} elsif ($opt_n) {		# New file
X
X    die $usage unless (@ARGV == 3);
X    ($filter, $SIZE, $VARIANTS) = @ARGV;
X
X    if ($SIZE =~ /^([0-9]+)k$/i) {
X	$SIZE = ((int($1) * 1024) - $HSIZE) * 8;
X    }
X
X    # Create filter file
X    unlink($filter);
X    open (FILTER, "+> $filter") || die "$!";
X
X    # Write header
X    substr($buffer,0,3) = $MAGIC;
X    substr($buffer,3,1) = pack ('C', $VARIANTS);
X    substr($buffer,4,4) = pack ('N', $SIZE);
X    syswrite (FILTER, $buffer, $HSIZE) || die "$!";
X
X    # Quit unless -a or -i are specified
X    exit(0) unless ($opt_a || $opt_i);
X    
X} else {			# Open existing file
X
X    die $usage unless (@ARGV == 1);
X    ($filter) = @ARGV;
X    die "$filter: no such file\n" unless (-f $filter);
X    if ($opt_a) {
X	open (FILTER, "+>> $filter") || die "$!";
X    } else {
X	open (FILTER, "< $filter") || die "$!";
X    }
X    seek (FILTER, 0, 0);
X    sysread (FILTER, $buffer, $HSIZE) || die "$!";
X    die "bad magic number if file $filter"
X	unless (substr($buffer,0,3) eq $MAGIC);
X    ($VARIANTS) = unpack ('C', substr($buffer,3,1));
X    ($SIZE)     = unpack ('N', substr($buffer,4,4));
X
X}
X
X#=== Hash function ========================================================
X
X# Determine maximum shift amount
Xfor ($maxShift = 1; (1 << $maxShift) < $SIZE; $maxShift++) {};
X
Xsub rotl
X{
X    local ($byte, $n) = @_;
X    $byte = int($byte << ($n % 8));
X    ((($byte) & 0xff00) >> 8) | (($byte) & 0xff);
X}
X
Xsub hash 
X{
X    local ($str, $variant) = @_;
X
X    defined($variant) || ($variant = 1);
X
X    local ($hashval);
X
X    local ($shift) = 0;
X    local ($shift_inc) = 8 - int($variant / 8);
X
X    for $char (unpack('C*', $str)) {
X
X	# Rotate the character $variant bits
X	$char = &rotl ($char, $variant);
X
X	# Shift it over, and add to hashval
X	$hashval += ($char << $shift);
X
X	# Determine the shift for next time
X	$shift += $shift_inc;
X	$shift %= $maxShift;
X
X    }
X 
X    ($hashval % $SIZE);
X}
X
X#=== Set/get values =======================================================
X
Xsub lseek
X{
X    local ($byte) = @_;
X    syscall (&SYS_lseek, fileno(FILTER), $byte, 0);
X}
X
Xsub setBit
X{
X    local ($bit) = @_;
X    local ($offset, $relbit) = (int($bit/8)+$HSIZE, ($bit%8));
X
X    local ($byte);
X    &lseek ($offset); sysread (FILTER, $byte, 1);
X    vec($byte,$relbit,1) = 1;
X    &lseek ($offset); syswrite (FILTER, $byte, 1);
X}
X
Xsub getBit
X{
X    local ($bit) = @_;
X    local ($offset, $relbit) = (int($bit/8)+$HSIZE, ($bit%8));
X
X    local ($byte);
X    &lseek ($offset); sysread (FILTER, $byte, 1);
X    vec($byte,$relbit,1);
X}
X
X#=== Main loop ============================================================
X
X$| = 1;
X
Xlocal ($found);
X
Xif ($opt_i) {
X    print "SIZE = $SIZE; VARIANTS = $VARIANTS\n";
X    seek (FILTER, 0, 0);
X    read (FILTER, $byte, $HSIZE);
X    while (read (FILTER, $byte, 1)) {
X	for $bit (0 .. 7) {
X	    if (vec($byte,$bit,1)) {
X		printf ("%6d\n", $offset*8+$bit) if ($opt_v);
X		$hits++;
X	    }
X	}
X	$offset++;
X    }
X    printf ("filter is %.2f%% full\n", 100*$hits/$SIZE);
X} else {
X  word:
X    while (<STDIN>) {
X	chop;
X	s/#.*//;		# ignore comments
X	next if /^\s*$/;	# skip blank lines
X	@hash = ();
X	for $variant (1 .. $VARIANTS) {
X	    $hash = &hash($_, $variant);
X	    push (@hash, $hash);
X	    if ($opt_a) {
X		&setBit($hash);
X	    } elsif (!$opt_t) {
X		if ($opt_v && !-t STDIN && -t STDERR) {
X		    print STDERR "$_             \r";
X		}
X		&getBit($hash) || next word;
X	    }
X	}
X	print "$_";
X	print "\t", join (',', @hash) if ($opt_t || $opt_v);
X	print "\n";
X    }
X}
X
X##=== END of bloomer ======================================================
END-of-bloomer
echo x - bloomer.8
sed 's/^X//' >bloomer.8 << 'END-of-bloomer.8'
X.\" -*- nroff -*-
X.de M           \" man page reference
X\\fI\\$1\\fR\\|(\\$2)\\$3
X..
X.TH bloomer 8 DOSLI
X
X.SH Name
Xbloomer \- Bloom-filter maintenance utility
X
X.SH Syntax
X
X.nf
X\fBbloomer\fR [\fB-b\fR] \fB-n\fR \fIfilter\fR \fIsize\fR \fInvar\fR
X\fBbloomer\fR [\fB-b\fR] \fB-a\fR \fIfilter\fR
X\fBbloomer\fR [\fB-b\fR] \fIfilter\fR
X\fBbloomer\fR [\fB-b\fR] \fB-i\fR \fIfilter\fR
X.fi
X
X.SH Description
X
X\fBbloomer\fR maintains and does lookups on a Bloom-filter, which is a
Xprobablistic word-membership checker, implemented as a large bitmap.
X
XWhen loading words into the filter, each word is hashed using a number of
Xindependant hash-functions, generating a number of discrete values.  Each
Xof these is used as an index into the bitmap, and the corresponding bits
Xare set.
X
X
XTo perform a lookup, the candidate word is hashed using the same hash-
Xfunctions, and the corresponding locations in the bitmap are checked.  If
Xany of the bits are false, we can be sure the candidate word wasn't
Xpresent in the original word-list.  If all bits are set, it is assumed
Xthat the word was (probably) present.
X
XThe accuracy of the Bloom-filter depends on the size of the bitmap, the
Xnumber of hash-functions used, and the number of words entered into the
Xfilter.  To be more concrete, if
X
X.nf
X  h = number of hash-functions
X  N = bitmap (hash table) size
X  w = number of words entered
X  u = proportion of bits left unset
X  b = probability of a "bogus" hit
X
Xthen    u = (1 - (h/N)) ^ w		
X and    b = (1 - u) ^ h
X.fi  
X
XWith no arguments, \fBbloomer\fR reads words from stdin, echoing the ones
Xthat are matched by the filter to stdout.  With the "-v" option, hash
Xvalues for the words are printed as well.
X
X.SH Options
X
X.TP
X.B -n
XCreates a new Bloom-filter file \fIfilter\fR, using parameters \fIsize\fR
Xfor size of filter, and \fIvar\fR for number of hash functions to use.  The
X\fIsize\fR parameters may be specified in kilobytes with the suffix "k", in
Xwhich case it specifies a file-size rather than a bitmap-size (ie. header
Xsize is subtracted).
X
X.TP
X.B -a
XReads words from stdin and inserts them into the Bloom-filter file
X\fIfilter\fR.  Words are echoed as they are added.  With the "-v" option,
Xhash values for the words are printed as well.
X
X.TP
X.B -i
XShows info about the Bloom-filter file \fIfilter\fR, showing the \fIsize\fR and
X\fIvar\fR parameters it was created with, and calculating the percentage of
Xbits set in the filter.  With the "-v" option, it also prints each
Xbitmap location that is set.
X
X.TP
X.B -v
X(Verbose).  Print extra information.
X
X.SH See Also
X.M ckpasswd 8
X
X.SH Author
XMike Williams <mikew@gopher.dosli.govt.nz>
END-of-bloomer.8
echo x - ckpasswd.conf.proto
sed 's/^X//' >ckpasswd.conf.proto << 'END-of-ckpasswd.conf.proto'
X
X# Require at least 6 characters
Xdefine MINLENGTH 6
X
X# Dictionaries
Xdefine LIBDIR /home/mikew/Work/Security/DOSLI
Xdict	/usr/local/lib/english.hash \
X			ispell "ispell recognises it as an English word"
X#dict	/usr/dict/words	sorted-f	"it appears in /usr/dict/words"
X
X# Bad patterns
Xreject  ^[a-z]+$		"it's all lowercase -- too simple"
Xreject  ^[a-z]+$		"it's all-numeric -- very boring"
Xreject	'\\e\\[' 		"function keys aren't portable"
END-of-ckpasswd.conf.proto
echo x - mpasswd
sed 's/^X//' >mpasswd << 'END-of-mpasswd'
X#!/usr/local/bin/perl
X## $Id: mpasswd,v 1.7 1994/10/21 02:58:44 mikew Exp $
X## ========================================================================
X## mpasswd -- /bin/passwd wrapper
X## Author          : Mike Williams <mikew@gopher.dosli.govt.nz>
X## ========================================================================
X
Xrequire 'chat2.pl';
Xrequire 'open2.pl';
X
X#--- Initialisation -------------------------------------------------------
X
X$checkpw = "/usr/local/lib/ckpasswd/ckpasswd";
X$greeting = undef;
X
X#--- Inhibit core dumps ---------------------------------------------------
X
X# Leaving a core dump around could be a security problem (as it will
X# probably contain the user's password).  So, we catch the signals which
X# normally produce core dumps, and exit gracefully.
X
Xfor $sig ('QUIT', 'ILL', 'TRAP', 'IOT', 'EMT',
X	  'FPE', 'BUS', 'SEGV', 'SYS') {
X    $SIG{$sig} = 'sigexit';
X}
X
Xsub sigexit {
X    warn "\ncaught fatal signal - no core dump\n";
X    exit 99;
X}
X
X#--- Talk to /bin/passwd --------------------------------------------------
X
Xprint $greeting if $greeting;
X
X$passwd = &chat'open_proc("/bin/passwd", @ARGV);
X
Xsystem ('stty', '-echo');
X
Xexpect:
Xfor (;;) {
X    $val = &chat'expect
X	($passwd, 10,
X	 'ew password: ', q[	# "New password" prompt
X	     $prompt = $`.$&;
X	     while ($_ = &getpw($prompt)) {  
X		 last unless ($reason = &checkpw($_));
X		 print "\n\n  Sorry, that's not a good password:\n";
X		 $* = 1; $reason =~ s/^/    /g; $* = 0;
X		 print "$reason\n";
X	     }
X	     &chat'print ($passwd, "$_\n");
X	 ],
X	 '.*\n' , q{		# messages
X	     $_ = $&; 
X	     print;
X	 },    
X	 ': ', q{		# other prompts ("Old password", "Verify")
X	     $prompt = $`.$&;
X	     $_ = &getpw($prompt);
X	     &chat'print ($passwd, "$_\n");
X	 },
X	 EOF, q{		# End of file
X	     last expect;
X	 },
X	 TIMEOUT, q{		# timeout (shouldn't happen)
X	     die "timed out\n";
X	 },
X	 );
X}
X
Xsystem ('stty', 'echo');
X
X#--- Prompt for password --------------------------------------------------
X
Xsub getpw {
X    local ($prompt) = @_;
X    local ($_);
X    print $prompt;
X    chop ($_ = <STDIN>);
X    $_;
X}
X
X#--- Check safety of passwd -----------------------------------------------
X
Xsub checkpw {
X    local ($password) = @_;
X    local (*IN, *OUT);
X    local ($pid, $reply, $_);
X    eval {
X	$pid = &open2 (OUT, IN, $checkpw);
X    };
X    die "\nerror invoking password checker\n$@" if ($@);
X    print IN "$password\n";
X    close (IN);
X    while (<OUT>) {
X	$reply .= $_;
X    }
X    close (OUT);
X    waitpid ($pid, 0);
X    $reply;
X}
X
X##=== END of mpasswd ======================================================
END-of-mpasswd
exit
