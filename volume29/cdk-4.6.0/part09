Newsgroups: comp.sources.unix
From: glover@credit.erin.utoronto.ca (Mike Glover)
Subject: v29i082: cdk - curses development kit, V4.6.0, Part09/09
References: <1.821493023.9103@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: glover@credit.erin.utoronto.ca (Mike Glover)
Posting-Number: Volume 29, Issue 82
Archive-Name: cdk-4.6.0/part09

#!/bin/sh
# This is `part09' (part 9 of a multipart archive).
# Do not concatenate these parts, unpack them in order with `/bin/sh'.
# File `cdk-4.6.0/COPYING' is being continued...
#
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  echo 'WARNING: not restoring timestamps.  Consider getting and'
  echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if test ! -r _sharseq.tmp; then
  echo 'Please unpack part 1 first!'
  exit 1
fi
shar_sequence=`cat _sharseq.tmp`
if test "$shar_sequence" != 9; then
  echo "Please unpack part $shar_sequence next!"
  exit 1
fi
if test ! -f _sharnew.tmp; then
  echo 'x - still skipping cdk-4.6.0/COPYING'
else
  echo 'x - continuing file cdk-4.6.0/COPYING'
  sed 's/^X//' << 'SHAR_EOF' >> 'cdk-4.6.0/COPYING' &&
Xintegrity of the free software distribution system, which is
Ximplemented by public license practices.  Many people have made
Xgenerous contributions to the wide range of software distributed
Xthrough that system in reliance on consistent application of that
Xsystem; it is up to the author/donor to decide if he or she is willing
Xto distribute software through any other system and a licensee cannot
Ximpose that choice.
X
XThis section is intended to make thoroughly clear what is believed to
Xbe a consequence of the rest of this License.
X
X  8. If the distribution and/or use of the Program is restricted in
Xcertain countries either by patents or by copyrighted interfaces, the
Xoriginal copyright holder who places the Program under this License
Xmay add an explicit geographical distribution limitation excluding
Xthose countries, so that distribution is permitted only in or among
Xcountries not thus excluded.  In such case, this License incorporates
Xthe limitation as if written in the body of this License.
X
X  9. The Free Software Foundation may publish revised and/or new versions
Xof the General Public License from time to time.  Such new versions will
Xbe similar in spirit to the present version, but may differ in detail to
Xaddress new problems or concerns.
X
XEach version is given a distinguishing version number.  If the Program
Xspecifies a version number of this License which applies to it and "any
Xlater version", you have the option of following the terms and conditions
Xeither of that version or of any later version published by the Free
XSoftware Foundation.  If the Program does not specify a version number of
Xthis License, you may choose any version ever published by the Free Software
XFoundation.
X
X  10. If you wish to incorporate parts of the Program into other free
Xprograms whose distribution conditions are different, write to the author
Xto ask for permission.  For software which is copyrighted by the Free
XSoftware Foundation, write to the Free Software Foundation; we sometimes
Xmake exceptions for this.  Our decision will be guided by the two goals
Xof preserving the free status of all derivatives of our free software and
Xof promoting the sharing and reuse of software generally.
X
X			    NO WARRANTY
X
X  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
XFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
XOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
XPROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
XOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
XMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
XTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
XPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
XREPAIR OR CORRECTION.
X
X  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
XWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
XREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
XINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
XOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
XTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
XYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
XPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
XPOSSIBILITY OF SUCH DAMAGES.
X
X		     END OF TERMS AND CONDITIONS
X
X	Appendix: How to Apply These Terms to Your New Programs
X
X  If you develop a new program, and you want it to be of the greatest
Xpossible use to the public, the best way to achieve this is to make it
Xfree software which everyone can redistribute and change under these terms.
X
X  To do so, attach the following notices to the program.  It is safest
Xto attach them to the start of each source file to most effectively
Xconvey the exclusion of warranty; and each file should have at least
Xthe "copyright" line and a pointer to where the full notice is found.
X
X    <one line to give the program's name and a brief idea of what it does.>
X    Copyright (C) 19yy  <name of author>
X
X    This program is free software; you can redistribute it and/or modify
X    it under the terms of the GNU General Public License as published by
X    the Free Software Foundation; either version 2 of the License, or
X    (at your option) any later version.
X
X    This program is distributed in the hope that it will be useful,
X    but WITHOUT ANY WARRANTY; without even the implied warranty of
X    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X    GNU General Public License for more details.
X
X    You should have received a copy of the GNU General Public License
X    along with this program; if not, write to the Free Software
X    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
XAlso add information on how to contact you by electronic and paper mail.
X
XIf the program is interactive, make it output a short notice like this
Xwhen it starts in an interactive mode:
X
X    Gnomovision version 69, Copyright (C) 19yy name of author
X    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
X    This is free software, and you are welcome to redistribute it
X    under certain conditions; type `show c' for details.
X
XThe hypothetical commands `show w' and `show c' should show the appropriate
Xparts of the General Public License.  Of course, the commands you use may
Xbe called something other than `show w' and `show c'; they could even be
Xmouse-clicks or menu items--whatever suits your program.
X
XYou should also get your employer (if you work as a programmer) or your
Xschool, if any, to sign a "copyright disclaimer" for the program, if
Xnecessary.  Here is a sample; alter the names:
X
X  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
X  `Gnomovision' (which makes passes at compilers) written by James Hacker.
X
X  <signature of Ty Coon>, 1 April 1989
X  Ty Coon, President of Vice
X
XThis General Public License does not permit incorporating your program into
Xproprietary programs.  If your program is a subroutine library, you may
Xconsider it more useful to permit linking proprietary applications with the
Xlibrary.  If this is what you want to do, use the GNU Library General
XPublic License instead of this License.
SHAR_EOF
  echo 'File cdk-4.6.0/COPYING is complete' &&
  $shar_touch -am 1229121195 'cdk-4.6.0/COPYING' &&
  chmod 0444 'cdk-4.6.0/COPYING' ||
  echo 'restore of cdk-4.6.0/COPYING failed'
  shar_count="`wc -c < 'cdk-4.6.0/COPYING'`"
  test 20399 -eq "$shar_count" ||
    echo "cdk-4.6.0/COPYING: original size 20399, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk-4.6.0/cdk.h ==============
if test -f 'cdk-4.6.0/cdk.h' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk-4.6.0/cdk.h (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk-4.6.0/cdk.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk-4.6.0/cdk.h' &&
X#ifndef CDK_H
X#define CDK_H
X
X/*
X * $Author: glover $
X * $Date: 1995/12/23 22:55:50 $
X * $Revision: 1.132 $
X */
X
X#ifdef NCURSES
X#include <ncurses/curses.h>
X#else
X#include <curses.h>
X#endif
X#include <stdlib.h>
X#include <string.h>
X#include <ctype.h>
X#include <unistd.h>
X#include <dirent.h>
X#include <time.h>
X#include <errno.h>
X#include <pwd.h>
X#include <grp.h>
X#include <sys/stat.h>
X#include <sys/types.h>
X#include "curdefs.h"
X
X/*
X * =========================================================
X * 	Delcare Global Generic Defines and Typedefs
X * =========================================================
X */
Xtypedef enum	{
X			vENTRY,
X			vMENTRY,
X			vLABEL,
X			vSCROLL,
X			vDIALOG,
X			vSCALE,
X			vMARQUEE,
X			vMENU,
X			vMATRIX,
X			vHISTOGRAM,
X			vSELECTION,
X			vVIEWER,
X			vGRAPH,
X			vRADIO,
X			vTEMPLATE,
X			vSWINDOW,
X			vITEMLIST,
X			vFSELECT
X		} EObjectType;
Xtypedef enum	{
X			vCHAR,
X			vHCHAR,
X			vINT,
X			vHINT,
X			vMIXED,
X			vHMIXED,
X			vUCHAR,
X			vLCHAR,
X			vUHCHAR,
X			vLHCHAR,
X			vUMIXED,
X			vLMIXED,
X			vUHMIXED,
X			vLHMIXED,
X			vVIEWONLY
X		} EDisplayType;
Xtypedef enum	{
X			vNONE,
X			vPERCENT,
X			vFRACTION,
X			vREAL
X		} EHistogramDisplayType;
Xtypedef enum	{
X			vPLOT,
X			vLINE
X		} EGraphDisplayType;
Xtypedef int boolean;
X
X#define	LEFT		9000
X#define	RIGHT		9001
X#define	CENTER		9002
X#define	TOP		9003
X#define	BOTTOM		9004
X#define	HORIZONTAL	9005
X#define	VERTICAL	9006
X#define	FULL		9007
X
X#define NONE		0
X#define ROW		1
X#define COL		2
X
X#define	BOX		1
X#define	NOBOX		0
X
X#define	DIFF(a,b)	(abs(a-b))
X#define	MAX(a,b)	(a > b ? a : b)
X#define	MIN(a,b)	(a < b ? a : b)
X#define	HALF(a)		(a>>1)
X
X/* Define the GLOBAL DEBUG FILEHANBDLE	*/
XFILE	*CDKDEBUG;
X
X/*
X * This is for the Cdk Screen object.
X */
X#define MAXOBJECTS	30
Xstruct _screen_st {
X   WINDOW	*window;
X   void		*object[MAXOBJECTS];
X   EObjectType	cdktype[MAXOBJECTS];
X   int		objectCount;
X};
Xtypedef struct _screen_st CDKSCREEN;
X
X/*
X * This is for the key bindings.
X */
X#define MAXBINDINGS	300
X#define	MAXARGS		100
Xtypedef void (*BINDFN) (EObjectType cdktype, void *object, void *clientData);
X
X/*
X * =========================================================
X * 	Delcare Global Generic Prototypes
X * =========================================================
X */
Xvoid Beep();
Xvoid alignxy   (WINDOW *window,
X		int *xpos, int *ypos,
X		int boxWidth, int boxHeight);
Xvoid alignlabel (char *label, int lplace, int fieldwidth, int *boxWidth, int *boxHeight, int *labelxoffset, int *labelyoffset, int *fieldxoffset, int *fieldyoffset);
Xvoid drawScrollItem  (WINDOW *win, char *item, int woffset, int voffset, int hoffset, int width, chtype attr);
Xchar *substring (char *string, int start, int width);
Xint justifyMessage (int fieldWidth, char *mesg, int justify);
Xint justifyString (int fieldWidth, int mesglen, int justify);
Xint readFile (char *filename, char **info, int maxlines);
Xvoid popUpMessage (CDKSCREEN *win, char **mesg, int count);
Xvoid quickSort (char *list[], int left, int right);
Xvoid swapIndex (char *list[], int i, int j);
X
X/*
X * =========================================================
X * 	Delcare Debugging Routines.
X * =========================================================
X */
XFILE *startCDKDebug(char *filename);
Xvoid writeCDKDebugMessage (FILE *fd, char *filename, char *function, int line, char *message);
Xvoid stopCDKDebug (FILE *fd);
X
X/*
X * =========================================================
X * 	Delcare String Handling Routines.
X * =========================================================
X */
Xvoid freeChar (char *string);
Xvoid freeChtype (chtype *string);
Xvoid cleanChar (char *string, int length, char character);
Xvoid cleanChtype (chtype *string, int length, chtype character);
Xchar *chtype2Char (chtype *string);
Xchtype *char2Chtype (char *string, int *length, int *align);
Xchtype *copyChtype (chtype *string);
Xchar *copyChar (char *string);
Xint chlen (chtype *string);
X
X/*
X * =========================================================
X * 	These functions are 'private' functions which
X * 	take care of screen objects and refreshing.
X * =========================================================
X */
XCDKSCREEN *initCDKScreen (WINDOW *window);
Xvoid initCDKColor();
Xvoid registerCDKObject (CDKSCREEN *screen, EObjectType cdktype, void *object);
Xvoid unregisterCDKObject (EObjectType cdktype, void *object);
Xvoid raiseCDKObject (EObjectType cdktype, void *object);
Xvoid lowerCDKObject (EObjectType cdktype, void *object);
Xvoid refreshCDKScreen (CDKSCREEN *screen);
Xvoid eraseCDKScreen (CDKSCREEN *screen);
Xvoid destroyCDKScreen (CDKSCREEN *screen);
Xvoid debugCDKScreen (CDKSCREEN *screen, char *mesg);
Xvoid endCDK();
X
X/*
X * =========================================================
X * 	These functions are 'private' functions which
X * 	take care of object key bindings.
X * =========================================================
X */
Xvoid bindCDKObject (EObjectType cdktype,
X			void *object, chtype key, BINDFN function, void *data);
Xvoid unbindCDKObject (EObjectType cdktype, void *object, chtype key);
Xint checkCDKObjectBind (EObjectType cdktype, void *object, chtype key);
Xvoid cleanCDKObjectBindings (EObjectType cdktype, void *object);
Xint mapChtype ( chtype key );
X
X/*
X * =========================================================
X * 	Declare Drawing routines.
X * =========================================================
X */
Xvoid boxWindow (WINDOW *window, chtype attr);
Xvoid drawLine (WINDOW *window,
X		int startx, int starty, int endx, int endy, chtype line);
Xvoid writeChar (WINDOW *window,
X		int xpos, int ypos, char *string,
X		int align, int start, int len);
Xvoid writeCharAttrib (WINDOW *window,
X		int xpos, int ypos, char *string,
X		chtype attr, int align, int start, int len);
Xvoid writeChtype (WINDOW *window,
X			int xpos, int ypos, chtype *string,
X			int align, int start, int len);
Xvoid writeChtypeAttrib (WINDOW *window,
X			int xpos, int ypos, chtype *string,
X			chtype attr, int align, int start, int len);
Xvoid attrbox (WINDOW *window,
X		chtype tlc, chtype trc,
X		chtype blc, chtype brc,
X		chtype hor, chtype vert,
X		chtype type);
Xvoid drawShadow (WINDOW *window);
X
X/* REMOVE ME LATER	*/
Xvoid printattr         (WINDOW *window, int xpos, int ypos, int align, chtype attr, char *mesg);
X
X/*
X * =========================================================
X * 	Declare Label Field Prototypes and Defines
X * =========================================================
X */
X#define	MAXLABELROWS	300
Xstruct _label_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowwin;
X   chtype	*info[MAXLABELROWS];
X   int		infolen[MAXLABELROWS];
X   int		infopos[MAXLABELROWS];
X   int		width;
X   int		xpos;
X   int		ypos;
X   int		rows;
X   boolean	box;
X   boolean	shadow;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X};
Xtypedef struct _label_st CDKLABEL;
XCDKLABEL *newCDKLabel (CDKSCREEN *screen, int xPos, int yPos,
X			char **mesg, int rows,
X			boolean box, boolean shadow);
Xvoid drawCDKLabel (CDKLABEL *label, boolean box);
Xvoid eraseCDKLabel (CDKLABEL *label);
Xvoid destroyCDKLabel (CDKLABEL *label);
Xchar waitCDKLabel (CDKLABEL *label, char key);
X
X/*
X * ===============================================================
X *	Declare Single-Line Entry Field Prototypes and Defines
X * ===============================================================
X */
Xstruct _entry_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowwin;
X   WINDOW	*labelwin;
X   chtype	*label;
X   int		labelpos;
X   int		labellen;
X   WINDOW	*field;
X   chtype	fieldattr;
X   int		fieldwidth;
X   char		*info;
X   int		totalwidth;
X   int		screencol;
X   int		leftchar;
X   int		min;
X   int		max;
X   EDisplayType	disptype;
X   boolean	box;
X   boolean	shadow;
X   chtype	filler;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X   void	*	callbackfn;
X};
Xtypedef struct _entry_st CDKENTRY;
Xtypedef void (*ENTRYCB) (CDKENTRY *entry, chtype character);
XCDKENTRY *newCDKEntry (CDKSCREEN *cdkscreen,
X			int xpos, int ypos, int lpos,
X			char *label, 
X			chtype fieldAttrib, chtype filler,
X			EDisplayType disptype,
X			int fieldWidth, int min, int max,
X			ENTRYCB X, boolean box, boolean shadow);
Xchar *activateCDKEntry (CDKENTRY *entry);
Xvoid setCDKEntry (CDKENTRY *entry, char *value, int min, int max, boolean box);
Xvoid drawCDKEntry (CDKENTRY *entry, boolean box);
Xvoid eraseCDKEntry (CDKENTRY *entry);
Xvoid cleanCDKEntry (CDKENTRY *entry);
Xvoid destroyCDKEntry (CDKENTRY *entry);
Xvoid CDKEntryCallBack (CDKENTRY *entry, chtype character);
Xvoid drawCDKEntryField (CDKENTRY *entry);
X
X/*
X * =============================================================
X *	Declare Muli-Line Entry Field Prototypes and Defines
X * =============================================================
X */
Xstruct _mentry_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowwin;
X   WINDOW	*labelwin;
X   WINDOW	*field;
X   chtype	*label;
X   int		labellen;
X   int		labelpos;
X   chtype	fieldattr;
X   int		fieldwidth;
X   char		*info;
X   int		totalwidth;
X   int		rows;
X   int		currentrow;
X   int		currentcol;
X   int		toprow;
X   EDisplayType	disptype;
X   int 		min;
X   int 		logical;
X   boolean	box;
X   boolean	shadow;
X   chtype	filler;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X   void	*	callbackfn;
X};
Xtypedef struct _mentry_st CDKMENTRY;
Xtypedef	void (*MENTRYCB) (CDKMENTRY *mentry, chtype character);
XCDKMENTRY *newCDKMentry (CDKSCREEN *cdkscreen,
X				int xpos, int ypos, int lpos,
X				char *label,
X				chtype fieldattr, chtype filler,
X				EDisplayType disptype,
X				int fieldwidth, int fieldrows,
X				int logicalrows, int min,
X				MENTRYCB X, boolean box, boolean shadow);
Xchar *activateCDKMentry (CDKMENTRY *entry);
Xvoid setCDKMentry (CDKMENTRY *mentry, char *value, int min, boolean box);
Xvoid drawCDKMentry (CDKMENTRY *mentry, boolean box);
Xvoid eraseCDKMentry (CDKMENTRY *mentry);
Xvoid cleanCDKMentry (CDKMENTRY *mentry);
Xvoid destroyCDKMentry (CDKMENTRY *mentry);
Xvoid redrawCDKMentry (CDKMENTRY *mentry);
Xvoid CDKMentryCallBack (CDKMENTRY *entry, chtype character);
X
X/*
X * =========================================================
X * 	Declare Scrolling List Prototypes and Defines
X * =========================================================
X */
X#define MAXITEMS	2000
X#define MAXVIEWSIZE	25
Xstruct _scroll_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowwin;
X   chtype	*title;
X   int		titlepos;
X   int		titlelen;
X   int		titleadj;
X   chtype	*item[MAXITEMS];
X   int		itempos[MAXITEMS];
X   int		itemlen[MAXITEMS];
X   int		maxTopItem;
X   int		maxLeftChar;
X   int		leftChar;
X   int		lastItem;
X   int		currentTop;
X   int		currentItem;
X   int		currentHigh;
X   int		listSize;
X   int		boxWidth;
X   int		boxHeight;
X   int		viewSize;
X   boolean	box;
X   boolean	shadow;
X   chtype	titlehighlight;
X   chtype	highlight;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X};
X#define	NUMBERS		TRUE
X#define	NONUMBERS	FALSE
Xtypedef struct _scroll_st CDKSCROLL;
XCDKSCROLL *newCDKScroll(CDKSCREEN *cdkscreen,
X				int xpos, int ypos, int height, int width,
X				char *title,
X				char **scrollItems, int items, boolean numbers,
X				chtype highlight, boolean box, boolean shadow);
Xint  activateCDKScroll (CDKSCROLL *scroll);
Xvoid setCDKScroll (CDKSCROLL *scroll, char **scrollItems, int listSize,
X			boolean numbers, chtype highlight, boolean box);
Xvoid drawCDKScroll (CDKSCROLL *scroll, boolean box);
Xvoid eraseCDKScroll (CDKSCROLL *scroll);
Xvoid destroyCDKScroll (CDKSCROLL *scroll);
Xvoid createCDKScrollItemList (CDKSCROLL *scroll, boolean numbers,
X				char **list, int listSize);
X
X/*
X * =========================================================
X * 	Declare Dialog Box Prototypes and Defines
X * =========================================================
X */
X#define	MAXDIALOGROWS		50
X#define	MAXDIALOGBUTTONS	25
X#define	MINDIALOGWIDTH		10
Xstruct _dialogBox_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowwin;
X   chtype	*info[MAXDIALOGROWS];
X   int		infolen[MAXDIALOGROWS];
X   int		infopos[MAXDIALOGROWS];
X   chtype	*buttonlabel[MAXDIALOGBUTTONS];
X   int		buttonlen[MAXDIALOGROWS];
X   int		buttonpos[MAXDIALOGROWS];
X   int		messageRows;
X   int		buttonCount;
X   int		currentButton;
X   int		boxWidth;
X   int		boxHeight;
X   boolean	separator;
X   boolean	box;
X   boolean	shadow;
X   chtype	highlight;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X};
Xtypedef struct _dialogBox_st CDKDIALOG;
XCDKDIALOG *newCDKDialog (CDKSCREEN *cdkscreen,
X				int xPos, int yPos,
X				char **message, int Rows,
X				char **buttons, int buttonCount,
X				chtype highlight,
X				boolean separator, boolean box, boolean shadow);
Xint activateCDKDialog (CDKDIALOG *dialog);
Xvoid setCDKDialog (CDKDIALOG *dialog, chtype highlight,
X			boolean separator, boolean box);
Xvoid drawCDKDialogButton (CDKDIALOG *dialog, int button,
X				boolean box, chtype active, chtype highlight);
Xvoid drawCDKDialog (CDKDIALOG *dialog, boolean box);
Xvoid eraseCDKDialog (CDKDIALOG *dialog);
Xvoid destroyCDKDialog (CDKDIALOG *dialog);
Xvoid redrawCDKDialogButtons (CDKDIALOG *dialog);
X
X/*
X * =========================================================
X * 	Declare Scale Box Prototypes and Defines
X * =========================================================
X */
Xstruct _scale_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowwin;
X   WINDOW	*fieldwin;
X   WINDOW	*labelwin;
X   chtype	*label;
X   int		labellen;
X   int		labelpos;
X   int		fieldwidth;
X   chtype	fieldattr;
X   int		low;
X   int		high;
X   int		current;
X   int		inc;
X   int		fastinc;
X   boolean	box;
X   boolean	shadow;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X};
Xtypedef struct _scale_st CDKSCALE;
XCDKSCALE *newCDKScale (CDKSCREEN *cdkscreen,
X			int xpos, int ypos, int lpos,
X			char *label, chtype fieldattr, int fieldwidth,
X			int start, int low, int high, int inc, int fastinc,
X			boolean box, boolean shadow);
Xint activateCDKScale (CDKSCALE *scale);
Xvoid setCDKScale (CDKSCALE *scale, int low, int high, int value, boolean box);
Xvoid drawCDKScale (CDKSCALE *scale, boolean box);
Xvoid eraseCDKScale (CDKSCALE *scale);
Xvoid destroyCDKScale (CDKSCALE *scale);
X
X/*
X * =========================================================
X * 	Declare Marquee Prototypes and Defines
X * =========================================================
X */
Xstruct _marquee_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowwin;
X   int		active;
X   int		width;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   boolean	box;
X   boolean	shadow;
X};
Xtypedef struct _marquee_st CDKMARQUEE;
XCDKMARQUEE *newCDKMarquee (CDKSCREEN *cdkscreen, int xpos, int ypos,
X				int width, boolean shadow);
Xint activateCDKMarquee (CDKMARQUEE *marquee, char *message,
X				int delay, int repeat, boolean box);
Xvoid drawCDKMarquee (CDKMARQUEE *marquee, boolean box);
Xvoid eraseCDKMarquee (CDKMARQUEE *marquee);
Xvoid destroyCDKMarquee (CDKMARQUEE *marquee);
X
X/*
X * =========================================================
X * 	Declare Menu Prototypes and Defines
X * =========================================================
X */
X#define MAXMENUITEMS	30
X#define MAXSUBITEMS	98
Xstruct _menu_st {
X   WINDOW	*parent;
X   WINDOW	*pullwin[MAXMENUITEMS];
X   WINDOW	*titlewin[MAXMENUITEMS];
X   chtype	*title[MAXMENUITEMS];
X   int		titlelen[MAXMENUITEMS];
X   chtype	*sublist[MAXMENUITEMS][MAXSUBITEMS];
X   int		sublistlen[MAXMENUITEMS][MAXSUBITEMS];
X   int		subsize[MAXMENUITEMS];
X   int		menuitems;
X   chtype	titleattr;
X   chtype	subtitleattr;
X   int		currentTitle;
X   int		currentSubtitle;
X   int		lastTitle;
X   int		lastSubtitle;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X};
Xtypedef struct _menu_st CDKMENU;
XCDKMENU *newCDKMenu (CDKSCREEN *cdkscreen,
X			char *menulist[MAXMENUITEMS][MAXSUBITEMS],
X			int menuitems,
X			int *subsize,
X			int *menuloc,
X			chtype titleattr,
X			chtype subtitleattr);
Xint activateCDKMenu (CDKMENU *menu);
Xvoid setCDKMenu (CDKMENU *menu,
X			int menuitem, int submenuitem,
X			chtype titlehighlight, chtype subtitlehighlight);
Xvoid drawCDKMenu (CDKMENU *menu);
Xvoid drawCDKMenuTitles (CDKMENU *menu);
Xvoid drawCDKMenuSubwin (CDKMENU *menu);
Xvoid eraseCDKMenu (CDKMENU *menu);
Xvoid eraseCDKMenuSubwin (CDKMENU *menu);
Xvoid destroyCDKMenu (CDKMENU *menu);
Xvoid cleanUpMenu (CDKMENU *menu);
X
X/*
X * =========================================================
X * 	Declare Matrix Prototypes and Defines
X * =========================================================
X */
X#define	MAXMATRIXROWS	1000
X#define	MAXMATRIXCOLS	1000
Xstruct _matrix_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowwin;
X   WINDOW	*cell[MAXMATRIXROWS][MAXMATRIXCOLS];
X   char		*info[MAXMATRIXROWS][MAXMATRIXCOLS];
X   int		rows;
X   int		cols;
X   int		vrows;
X   int		vcols;
X   int		colwidths[MAXMATRIXCOLS];
X   int		colvalues[MAXMATRIXCOLS];
X   chtype	*coltitle[MAXMATRIXCOLS];
X   int		coltitlelen[MAXMATRIXROWS];
X   int		coltitlepos[MAXMATRIXROWS];
X   int		maxct;
X   chtype	*rowtitle[MAXMATRIXROWS];
X   int		rowtitlelen[MAXMATRIXROWS];
X   int		rowtitlepos[MAXMATRIXROWS];
X   int		maxrt;
X   int		rowspace;
X   int		colspace;
X   int		row;
X   int		col;
X   int		crow;
X   int		ccol;
X   int		trow;
X   int		lcol;
X   int		oldcrow;
X   int		oldccol;
X   int		oldvrow;
X   int		oldvcol;
X   boolean	boxMatrix;
X   boolean	boxCell;
X   boolean	shadow;
X   chtype	highlight;
X   int		dominant;
X   chtype	filler;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X   void	*	callbackfn;
X};
Xtypedef struct _matrix_st CDKMATRIX;
Xtypedef void (*MATRIXCB) (CDKMATRIX *matrix, chtype input);
XCDKMATRIX *newCDKMatrix (CDKSCREEN *cdkscreen,
X				int xpos, int ypos,
X				int rows, int cols,
X				int vrows, int vcols,
X				char **rowtitles,
X				char **coltitles,
X				int *colwidths, int *coltypes,
X				int rowspace, int colspace, chtype filler,
X				int dominantAttrib, MATRIXCB X,
X				boolean boxMatrix, boolean boxCell,
X				boolean shadow);
Xvoid activateCDKMatrix (CDKMATRIX *matrix);
Xvoid setCDKMatrix (CDKMATRIX *matrix,
X			char *info[MAXMATRIXROWS][MAXMATRIXCOLS],
X			int rows, int *subSize);
Xvoid drawCDKMatrix (CDKMATRIX *matrix, boolean box);
Xvoid eraseCDKMatrix (CDKMATRIX *matrix);
Xvoid cleanCDKMatrix (CDKMATRIX *matrix);
Xint moveToCDKMatrixCell (CDKMATRIX *matrix, int newrow, int newcol);
Xvoid destroyCDKMatrix (CDKMATRIX *matrix);
Xvoid drawCDKMatrixCell (CDKMATRIX *matrix,
X			int srow, int scol, int vrow, int vcol,
X			chtype attr, boolean box);
Xvoid CDKMatrixCallBack (CDKMATRIX *matrix, chtype input);
Xvoid highlightCDKMatrixCell (CDKMATRIX *matrix);
Xint jumpToCell (CDKMATRIX *matrix);
X
X/*
X * =========================================================
X * 	Declare Histogram Prototypes and Defines
X * =========================================================
X */
Xstruct _histogram_st {
X   WINDOW			*parent;
X   WINDOW			*win;
X   WINDOW			*shadowwin;
X   WINDOW 			*labelwin;
X   chtype			*label;
X   int				labellen;
X   char				*statschar;
X   char				*lowchar;
X   char				*highchar;
X   chtype			filler;
X   chtype			labelattr;
X   float			percent;
X   int				height;
X   int				width;
X   int 				orient;
X   int				statspos;
X   int				statsattr;
X   EHistogramDisplayType	viewtype;
X   int				high;
X   int				low;
X   int				value;
X   int				chars;
X   int				lowx,	lowy;
X   int				highx,	highy;
X   int				labelx,	labely;
X   int				statsx,	statsy;
X   int				histx,	histy;
X   boolean			box;
X   boolean			shadow;
X   CDKSCREEN			*screen;
X   int				screenIndex;
X};
Xtypedef struct _histogram_st CDKHISTOGRAM;
XCDKHISTOGRAM *newCDKHistogram (CDKSCREEN *cdkscreen,
X				int xpos, int ypos, int lpos,
X				int height, int width, int orient,
X				char *label, boolean box, boolean shadow);
Xvoid setCDKHistogram (CDKHISTOGRAM *histogram,
X			EHistogramDisplayType viewtype,
X			int statspos, chtype statsattr,
X			int low, int high, int value,
X			chtype filler, boolean box);
Xvoid drawCDKHistogram (CDKHISTOGRAM *histogram, boolean box);
Xvoid eraseCDKHistogram (CDKHISTOGRAM *histogram);
Xvoid destroyCDKHistogram (CDKHISTOGRAM *histogram);
X
X/*
X * =========================================================
X * 	Declare Selection List Prototypes and Defines
X * =========================================================
X */
X#define	MAXCHOICES	100
Xstruct _selection_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowwin;
X   chtype	*title;
X   int		titlepos;
X   int		titlelen;
X   int		titleadj;
X   chtype	*item[MAXITEMS];
X   int		itemlen[MAXITEMS];
X   int		itempos[MAXITEMS];
X   chtype	*choice[MAXCHOICES];
X   int		choicelen[MAXCHOICES];
X   int		choiceCount;
X   int		maxchoicelen;
X   int		selections[MAXITEMS];
X   int		maxTopItem;
X   int		maxLeftChar;
X   int		leftChar;
X   int		lastItem;
X   int		currentTop;
X   int		currentHigh;
X   int		currentItem;
X   int		listSize;
X   int		boxWidth;
X   int		boxHeight;
X   int		viewSize;
X   boolean	box;
X   boolean	shadow;
X   chtype	highlight;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X};
Xtypedef struct _selection_st CDKSELECTION;
XCDKSELECTION *newCDKSelection (CDKSCREEN *cdkscreen,
X				int xpos, int ypos, int height, int width,
X				char *title,
X				char **list, int listSize,
X				char **choices, int choiceSize,
X				chtype highlight,
X				boolean box, boolean shadow);
Xvoid activateCDKSelection (CDKSELECTION *selection);
Xvoid drawCDKSelection (CDKSELECTION *selection, boolean box);
Xvoid eraseCDKSelection (CDKSELECTION *selection);
Xvoid destroyCDKSelection (CDKSELECTION *selection);
Xvoid drawCDKSelectionList (CDKSELECTION *selection);
Xvoid setCDKSelection (CDKSELECTION *selection, chtype highlight,
X			int *defChoices, boolean box);
X
X/*
X * =========================================================
X * 	Declare Viewer List Prototypes and Defines
X * =========================================================
X */
X#define	MAXLINES	10000
X#define	MAXBUTTONS	50
Xstruct _viewer_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowwin;
X   chtype	*button[MAXBUTTONS];
X   int		buttonlen[MAXBUTTONS];
X   int		buttonpos[MAXBUTTONS];
X   int		buttonCount;
X   chtype	buttonHighlight;
X   chtype	*info[MAXLINES];
X   int		infolen[MAXLINES];
X   int		infopos[MAXLINES];
X   chtype	*title;
X   int		titlelen;
X   int		titlepos;
X   int		infoSize;
X   int		boxHeight;
X   int		boxWidth;
X   int		viewSize;
X   int		currentTop;
X   int		currentButton;
X   int		leftChar;
X   int		length;
X   int		maxLeftChar;
X   int		maxTopLine;
X   int		characters;
X   boolean	interpret;
X   boolean	box;
X   boolean	shadow;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X};
Xtypedef struct _viewer_st CDKVIEWER;
XCDKVIEWER *newCDKViewer (CDKSCREEN *cdkscreen,
X				int xpos, int ypos,
X				int height, int width,
X				char **buttons, int buttonCount,
X				boolean box, boolean shadow);
Xint activateCDKViewer (CDKVIEWER *viewer,
X			char *title, 
X			char **info, int infoSize,
X			chtype buttonHighlight,
X			boolean interpret, boolean box);
Xint manageCDKViewer (CDKVIEWER *viewer);
Xvoid setCDKViewer (CDKVIEWER *viewer, chtype buttonHighlight, boolean box);
Xvoid drawCDKViewer (CDKVIEWER *viewer, int boolean);
Xvoid eraseCDKViewer (CDKVIEWER *viewer);
Xvoid destroyCDKViewer (CDKVIEWER *viewer);
X
X/*
X * =========================================================
X * 	Declare Graph Prototypes and Defines
X * =========================================================
X */
Xstruct _graph_st {
X   WINDOW		*parent;
X   WINDOW		*win;
X   WINDOW		*shadowwin;
X   chtype		*title;
X   chtype		*graphchar;
X   int			titlepos;
X   int			titlelen;
X   boolean		box;
X   boolean		shadow;
X   int			boxHeight;
X   int			boxWidth;
X   chtype		*xtitle;
X   int			xtitlepos;
X   int			xtitlelen;
X   int			values[MAXLINES];
X   int			count;
X   int			minx;
X   int			maxx;
X   int			xscale;
X   int			txpos;
X   chtype		*ytitle;
X   int			ytitlepos;
X   int			ytitlelen;
X   int			yscale;
X   int			typos;
X   EGraphDisplayType	displayType;
X   CDKSCREEN		*screen;
X   int			screenIndex;
X};
Xtypedef struct _graph_st CDKGRAPH;
XCDKGRAPH *newCDKGraph (CDKSCREEN *cdkscreen,
X			int xpos, int ypos, int height, int width,
X			char *title, char *xtitle, char *ytitle);
Xint setCDKGraph (CDKGRAPH *graph, 
X			int *values, int count, char *graphchar,
X			boolean startAtZero,
X			EGraphDisplayType displayType);
Xvoid drawCDKGraph (CDKGRAPH *graph, boolean box);
Xvoid eraseCDKGraph (CDKGRAPH *graph);
Xvoid destroyCDKGraph (CDKGRAPH *graph);
X
X/*
X * =========================================================
X * 	Declare Radio Button Prototypes and Defines
X * =========================================================
X */
Xstruct _radio_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowwin;
X   chtype	*title;
X   int		titlelen;
X   int		titlepos;
X   chtype	*item[MAXITEMS];
X   int		itemlen[MAXITEMS];
X   int		itempos[MAXITEMS];
X   int		titleadj;
X   chtype	choiceChar;
X   int		maxLeftChar;
X   int		widestItem;
X   int		leftChar;
X   int		selectedItem;
X   int		currentTop;
X   int		currentItem;
X   int		currentHigh;
X   int		listSize;
X   int		lastItem;
X   int		maxTopItem;
X   int		boxWidth;
X   int		boxHeight;
X   int		viewSize;
X   int		defItem;
X   boolean	box;
X   boolean	shadow;
X   chtype	highlight;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X};
Xtypedef struct _radio_st CDKRADIO;
XCDKRADIO *newCDKRadio (CDKSCREEN *cdkscreen,
X			int xpos, int ypos, int height, int width,
X			char *title, char **mesg, int items,
X			chtype choiceChar, int defItem,
X			chtype highlight, boolean box, boolean shadow);
Xint activateCDKRadio (CDKRADIO *radio);
Xvoid setCDKRadio (CDKRADIO *radio, chtype highlight,
X			chtype choiceChar, boolean box);
Xvoid drawCDKRadio (CDKRADIO *radio, boolean box);
Xvoid eraseCDKRadio (CDKRADIO *radio);
Xvoid destroyCDKRadio (CDKRADIO *radio);
X
X/*
X * =========================================================
X * 	       Declare Template Object....
X * =========================================================
X */
Xstruct _template_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowwin;
X   WINDOW	*labelwin;
X   chtype	*label;
X   chtype	*overlay;
X   chtype	overlayattr;
X   char 	*plate;
X   char		*info;
X   int		labellen;
X   int		overlaylen;
X   int		labelpos;
X   int		fieldwidth;
X   int		platePos;
X   int		screenPos;
X   int		infoPos;
X   chtype	labelattr;
X   chtype	fieldattr;
X   WINDOW	*field;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   boolean	box;
X   boolean	shadow;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X   void	*	callbackfn;
X};
Xtypedef struct _template_st CDKTEMPLATE;
Xtypedef void (*TEMPLATECB) (CDKTEMPLATE *template, chtype input);
XCDKTEMPLATE *newCDKTemplate (CDKSCREEN *cdkscreen,
X				int xpos, int ypos, int lpos,
X				char *label, char *plate, char *overlay,
X				TEMPLATECB X,
X				boolean box, boolean shadow);
Xchar *activateCDKTemplate (CDKTEMPLATE *template);
Xvoid setCDKTemplate (CDKTEMPLATE *template, char *value, boolean box);
Xvoid drawCDKTemplate (CDKTEMPLATE *template, boolean box);
Xvoid eraseCDKTemplate (CDKTEMPLATE *template);
Xvoid cleanCDKTemplate (CDKTEMPLATE *template);
Xchar *mixCDKTemplate (CDKTEMPLATE *template);
Xchar *unmixCDKTemplate (CDKTEMPLATE *template, char *string);
Xvoid destroyCDKTemplate (CDKTEMPLATE *template);
Xvoid CDKTemplateCallBack (CDKTEMPLATE *template, chtype input);
X
X/*
X * =========================================================
X * 	       Declare Scrolling Window Object....
X * =========================================================
X */
Xstruct _swindow_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowwin;
X   chtype	*info[MAXLINES];
X   int		infopos[MAXLINES];
X   int		infolen[MAXLINES];
X   chtype	*title;
X   int		titlepos;
X   int		titlelen;
X   int		titleadj;
X   int		itemCount;
X   int		boxHeight;
X   int		boxWidth;
X   int		viewSize;
X   int		maxTopLine;
X   int		currentTop;
X   int		leftChar;
X   int		maxLeftChar;
X   int		widestLine;
X   int		saveLines;
X   boolean	box;
X   boolean	shadow;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X};
Xtypedef struct _swindow_st CDKSWINDOW;
Xtypedef void (*SWINDOWCB) (CDKSWINDOW *swindow, chtype input);
XCDKSWINDOW *newCDKSwindow (CDKSCREEN *cdkscreen,
X				int xpos, int ypos, int height, int width,
X				char *title,
X				int saveLines,
X				boolean box, boolean shadow);
Xvoid activateCDKSwindow	(CDKSWINDOW *swindow);
Xvoid setCDKSwindow (CDKSWINDOW *swindow, char **info,
X			int lines, boolean box);
Xvoid getCDKSwindow (CDKSWINDOW *swindow, char **info);
Xvoid drawCDKSwindow (CDKSWINDOW *swindow, boolean box);
Xvoid eraseCDKSwindow (CDKSWINDOW *swindow);
Xvoid cleanCDKSwindow (CDKSWINDOW *swindow);
Xvoid addCDKSwindow (CDKSWINDOW *swindow, char *info, int insertPos);
Xvoid trimCDKSwindow (CDKSWINDOW *swindow, int start, int finish);
Xvoid destroyCDKSwindow (CDKSWINDOW *swindow);
X
X/*
X * =========================================================
X * 	       Declare Item List Widget
X * =========================================================
X */
Xstruct _itemlist_st {
X   CDKSCREEN	*screen;
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowwin;
X   WINDOW	*labelwin;
X   chtype	*label;
X   int		labelpos;
X   int		labellen;
X   WINDOW	*fieldwin;
X   int		fieldWidth;
X   chtype	*item[MAXITEMS];
X   int		itempos[MAXITEMS];
X   int		itemlen[MAXITEMS];
X   int		itemCount;
X   int		currentItem;
X   int		defaultItem;
X   boolean	box;
X   boolean	shadow;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X};
Xtypedef struct _itemlist_st CDKITEMLIST;
XCDKITEMLIST *newCDKItemlist (CDKSCREEN *cdkscreen,
X				int xpos, int ypos,
X				int lpos, char *label,
X				char **itemlist, int count, int defaultItem,
X				boolean box, boolean shadow);
Xint activateCDKItemlist (CDKITEMLIST *itemlist);
Xvoid setCDKItemlist (CDKITEMLIST *itemlist, char **list, int count,
X			int current, boolean box);
Xvoid drawCDKItemlist (CDKITEMLIST *itemlist, boolean box);
Xvoid drawCDKItemlistField (CDKITEMLIST *itemlist);
Xvoid eraseCDKItemlist (CDKITEMLIST *itemlist);
Xvoid destroyCDKItemlist	(CDKITEMLIST *itemlist);
X
X/*
X * =========================================================
X *             Declare File Selector Widget
X * =========================================================
X */
Xstruct _fileselector_st {
X   CDKSCREEN	*screen;
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowwin;
X   CDKLABEL	*title;
X   CDKENTRY	*filename;
X   CDKSCROLL	*filelist;
X   char		*dirContents[MAXITEMS];
X   int		fileCounter;
X   char 	*pwd;
X   char		*pathname;
X   int		xpos;
X   int		ypos;
X   int		height;
X   int		width;
X   chtype	fieldAttribute;
X   chtype	fillerCharacter;
X   chtype	highlight;
X   char		*dirAttribute;
X   char		*fileAttribute;
X   char		*linkAttribute;
X   char		*sockAttribute;
X   boolean	box;
X   boolean	shadow;
X   int		screenIndex;
X};
Xtypedef struct _fileselector_st CDKFSELECT;
XCDKFSELECT *newCDKFselect (CDKSCREEN *cdkscreen,
X				int xpos, int ypos,
X				int height, int width, 
X				chtype fieldAttribute, chtype fillerChar,
X				chtype highlight,
X				char *dirAttributes, char *fileAttributes,
X				char *linkAttribute, char *sockAttribute,
X				boolean box, boolean shadow);
Xchar *activateCDKFselect (CDKFSELECT *fselect);
Xvoid setCDKFselect (CDKFSELECT *fselect,
X			char *directory,
X			chtype fieldAttribute, chtype fillerChar,
X			chtype highlight,
X			char *dirAttribute, char *fileAttribute,
X			char *linkAttribute, char *sockAttribute,
X			boolean box);
Xvoid drawCDKFselect (CDKFSELECT *fselect, boolean box);
Xvoid eraseCDKFselect (CDKFSELECT *fselect);
Xvoid destroyCDKFselect (CDKFSELECT *fselect);
X
X/*
X * =========================================================
X *             Declare Canvas Widget
X * =========================================================
X */
X#define	MAXCANVASHEIGHT	300
Xstruct _canvas_st {
X   CDKSCREEN	*screen;
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowwin;
X   chtype	*characters[MAXCANVASHEIGHT];
X   boolean	box;
X   boolean	shadow;
X   int		screenIndex;
X};
Xtypedef struct _canvas_st CDKCANVAS;
XCDKCANVAS *newCDKCanvas (CDKSCREEN *cdkscreen,
X				int xpos, int ypos,
X				int height, int width, 
X				boolean box, boolean shadow);
Xvoid drawCDKCanvas (CDKCANVAS *canvas, boolean box);
Xvoid drawlineCDKCanvas (CDKCANVAS *canvas,
X			int startXpos, int startYpos,
X			int enxXpos, int endYpos);
Xvoid drawboxCDKCanvas (CDKCANVAS *canvas,
X			int leftXpos, int leftYpos,
X			int height, int width);
Xvoid destroyCDKCanvas (CDKCANVAS *canvas);
X#endif
SHAR_EOF
  $shar_touch -am 1229121195 'cdk-4.6.0/cdk.h' &&
  chmod 0400 'cdk-4.6.0/cdk.h' ||
  echo 'restore of cdk-4.6.0/cdk.h failed'
  shar_count="`wc -c < 'cdk-4.6.0/cdk.h'`"
  test 32493 -eq "$shar_count" ||
    echo "cdk-4.6.0/cdk.h: original size 32493, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk-4.6.0/curdefs.h ==============
if test -f 'cdk-4.6.0/curdefs.h' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk-4.6.0/curdefs.h (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk-4.6.0/curdefs.h (binary)'
  sed 's/^X//' << 'SHAR_EOF' > _sharuue.tmp &&
Xbegin 600 cdk-4.6.0/curdefs.h
XM(VEF;F1E9B!#55)$149?2`HC9&5F:6YE($-54D1%1E]("@HO*@H@*B`D075T
XM:&]R.B!G;&]V97(@)`H@*B`D1&%T93H@,3DY-2\Q,B\Q,"`P,CHQ,#HR-"`D
XM"B`J("12979I<VEO;CH@,2XQ-R`D"B`J+PH*+RH*("H@5&AI<R!H96%D97(@
XM9FEL92!I<R!F;W(@;6%C:&EN97,@=VET:&]U="!A(&9U;&P@8W5R<V5S(&1E
XM9FEN:71I;VXN"B`J+PH*(VEF9&5F($Y/0TA465!%"G1Y<&5D968@=6YS:6=N
XM960@;&]N9R`@8VAT>7!E.PHC96YD:68*"B-I9FYD968)0T1+7U)%1E)%4T@*
XM(V1E9FEN90E#1$M?4D5&4D532`DG#"<)+RH@2V5Y('5S960@=&\@<F5F<F5S
XM:"!T:&4@<V-R965N+@DJ+PHC96YD:68*(VEF;F1E9@E#1$M?4$%35$4*(V1E
XM9FEN90E#1$M?4$%35$4))Q`G"2\J($ME>2!U<V5D(&9O<B!P87-T:6YG+@D)
XM*B\*(V5N9&EF"B-I9FYD968)0T1+7T-/4%D*(V1E9FEN90E#1$M?0T]060DG
XM%"<)+RH@2V5Y('5S960@9F]R('1A:VEN9R!C;W!I97,N"0DJ+PHC96YD:68*
XM(VEF;F1E9@E#1$M?15)!4T4*(V1E9FEN90E#1$M?15)!4T4))P4G"2\J($ME
XM>2!U<V5D(&9O<B!E<F%S96EN9R!F:65L9',N"2HO"B-E;F1I9@HC:69N9&5F
XM"4-$2U]#550*(V1E9FEN90E#1$M?0U54"0DG"R<)+RH@2V5Y('5S960@9F]R
XM(&-U='1I;F<N"0DJ+PHC96YD:68*(VEF;F1E9@E#1$M?3D585`HC9&5F:6YE
XM"4-$2U].15A4"2<.)PDO*B!5<V5D(&9O<B!S=VET8VAI;F<@8F5T=V5E;B!#
XM9&L@;V)J96-T<PDJ+PHC96YD:68*(VEF;F1E9@E#1$M?5$535`HC9&5F:6YE
XM"4-$2U]415-4"2?P)PHC96YD:68*(VEF;F1E9@E!7TY/05144DE""B-D969I
XM;F4)05].3T%45%))0@DM,0DO*B!.;R!A='1R:6)U=&5S('=A;G1E9"X@3&5A
XM=F4@87,@:7,N"2HO"B-E;F1I9@H*(VEF;F1E9@E34$%#10HC9&5F:6YE"5-0
XM04-%"0DG("<*(V5N9&EF"B-I9FYD968@1$5,151%"B-D969I;F4@1$5,151%
XM"0DG7#$W-R<)+RH@1&5L971E(&ME>0D)"0DJ+PHC96YD:68*(VEF;F1E9@E4
XM04(*(V1E9FEN90E404()"2=<="<)+RH@5&%B(&ME>2X)"0D)*B\*(V5N9&EF
XM"B-I9FYD968)2T597T530PHC9&5F:6YE"4M%65]%4T,)"2<;)PDO*B!%<V-A
XM<&4@2V5Y+@D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4D5455)."B-D969I
XM;F4@2T597U)%5%523@DG7#`Q,B<)+RH@4F5T=7)N(&ME>0D)"0DJ+PHC96YD
XM:68*(VEF;F1E9B!+15E?5$%""B-D969I;F4@2T597U1!0@D))UQT)PDO*B!4
XM86(@:V5Y"0D)"2HO"B-E;F1I9@HC:69N9&5F($M%65]!,0HC9&5F:6YE($M%
XM65]!,0D),#4S-`DO*B!5<'!E<B!L969T(&]F(&ME>7!A9`D)"2HO"B-E;F1I
XM9@HC:69N9&5F($M%65]!,PHC9&5F:6YE($M%65]!,PD),#4S-0DO*B!5<'!E
XM<B!R:6=H="!O9B!K97EP860)"2HO"B-E;F1I9@HC:69N9&5F($M%65]",@HC
XM9&5F:6YE($M%65]",@D),#4S-@DO*B!#96YT97(@;V8@:V5Y<&%D"0D)*B\*
XM(V5N9&EF"B-I9FYD968@2T597T,Q"B-D969I;F4@2T597T,Q"0DP-3,W"2\J
XM($QO=V5R(&QE9G0@;V8@:V5Y<&%D"0D)*B\*(V5N9&EF"B-I9FYD968@2T59
XM7T,S"B-D969I;F4@2T597T,S"0DP-30P"2\J($QO=V5R(')I9VAT(&]F(&ME
XM>7!A9`D)*B\*(V5N9&EF"B-I9FYD968@2T597T)404(*(V1E9FEN92!+15E?
XM0E1!0@DP-30Q"2\J($)A8VL@=&%B(&ME>0D)"0DJ+PHC96YD:68*(VEF;F1E
XM9B!+15E?0D5'"B-D969I;F4@2T597T)%1PD),#4T,@DO*B!B96<H:6YN:6YG
XM*2!K97D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?0T%.0T5,"B-D969I;F4@
XM2T597T-!3D-%3`DP-30S"2\J(&-A;F-E;"!K97D)"0D)*B\*(V5N9&EF"B-I
XM9FYD968@2T597T-,3U-%"B-D969I;F4@2T597T-,3U-%"3`U-#0)+RH@8VQO
XM<V4@:V5Y"0D)"2HO"B-E;F1I9@HC:69N9&5F($M%65]#3TU-04Y$"B-D969I
XM;F4@2T597T-/34U!3D0),#4T-0DO*B!C;60@*&-O;6UA;F0I(&ME>0D)"2HO
XM"B-E;F1I9@HC:69N9&5F($M%65]#3U!9"B-D969I;F4@2T597T-/4%D),#4T
XM-@DO*B!C;W!Y(&ME>0D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?0U)%051%
XM"B-D969I;F4@2T597T-214%410DP-30W"2\J(&-R96%T92!K97D)"0D)*B\*
XM(V5N9&EF"B-I9FYD968@2T597T5.1`HC9&5F:6YE($M%65]%3D0)"3`U-3`)
XM+RH@96YD(&ME>0D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?15A)5`HC9&5F
XM:6YE($M%65]%6$E4"3`U-3$)+RH@97AI="!K97D)"0D)*B\*(V5N9&EF"B-I
XM9FYD968@2T597T9)3D0*(V1E9FEN92!+15E?1DE.1`DP-34R"2\J(&9I;F0@
XM:V5Y"0D)"2HO"B-E;F1I9@HC:69N9&5F($M%65](14Q0"B-D969I;F4@2T59
XM7TA%3%`),#4U,PDO*B!H96QP(&ME>0D)"0DJ+PHC96YD:68*(VEF;F1E9B!+
XM15E?34%22PHC9&5F:6YE($M%65]-05)+"3`U-30)+RH@;6%R:R!K97D)"0D)
XM*B\*(V5N9&EF"B-I9FYD968@2T597TU%4U-!1T4*(V1E9FEN92!+15E?3453
XM4T%'10DP-34U"2\J(&UE<W-A9V4@:V5Y"0D)"2HO"B-E;F1I9@HC:69N9&5F
XM($M%65]-3U9%"B-D969I;F4@2T597TU/5D4),#4U-@DO*B!M;W9E(&ME>0D)
XM"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?3D585`HC9&5F:6YE($M%65].15A4
XM"3`U-3<)+RH@;F5X="!O8FIE8W0@:V5Y"0D)*B\*(V5N9&EF"B-I9FYD968@
XM2T597T]014X*(V1E9FEN92!+15E?3U!%3@DP-38P"2\J(&]P96X@:V5Y"0D)
XM"2HO"B-E;F1I9@HC:69N9&5F($M%65]/4%1)3TY3"B-D969I;F4@2T597T]0
XM5$E/3E,),#4V,0DO*B!O<'1I;VYS(&ME>0D)"0DJ+PHC96YD:68*(VEF;F1E
XM9B!+15E?4%)%5DE/55,*(V1E9FEN92!+15E?4%)%5DE/55,),#4V,@DO*B!P
XM<F5V:6]U<R!O8FIE8W0@:V5Y"0D)*B\*(V5N9&EF"B-I9FYD968@2T597U)%
XM1$\*(V1E9FEN92!+15E?4D5$3PDP-38S"2\J(')E9&\@:V5Y"0D)"2HO"B-E
XM;F1I9@HC:69N9&5F($M%65]2149%4D5.0T4*(V1E9FEN92!+15E?4D5&15)%
XM3D-%"3`U-C0)+RH@<F5F*&5R96YC92D@:V5Y"0D)*B\*(V5N9&EF"B-I9FYD
XM968@2T597U)%1E)%4T@*(V1E9FEN92!+15E?4D5&4D532`DP-38U"2\J(')E
XM9G)E<V@@:V5Y"0D)"2HO"B-E;F1I9@HC:69N9&5F($M%65]215!,04-%"B-D
XM969I;F4@2T597U)%4$Q!0T4),#4V-@DO*B!R97!L86-E(&ME>0D)"0DJ+PHC
XM96YD:68*(VEF;F1E9B!+15E?4D535$%25`HC9&5F:6YE($M%65]215-405)4
XM"3`U-C<)+RH@<F5S=&%R="!K97D)"0D)*B\*(V5N9&EF"B-I9FYD968@2T59
XM7U)%4U5-10HC9&5F:6YE($M%65]215-5344),#4W,`DO*B!R97-U;64@:V5Y
XM"0D)"2HO"B-E;F1I9@HC:69N9&5F($M%65]3059%"B-D969I;F4@2T597U-!
XM5D4),#4W,0DO*B!S879E(&ME>0D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?
XM4T)%1PHC9&5F:6YE($M%65]30D5'"3`U-S()+RH@<VAI9G1E9"!B96=I;FYI
XM;F<@:V5Y"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4T-!3D-%3`HC9&5F:6YE
XM($M%65]30T%.0T5,"3`U-S,)+RH@<VAI9G1E9"!C86YC96P@:V5Y"0D)*B\*
XM(V5N9&EF"B-I9FYD968@2T597U-#3TU-04Y$"B-D969I;F4@2T597U-#3TU-
XM04Y$"3`U-S0)+RH@<VAI9G1E9"!C;VUM86YD(&ME>0D)"2HO"B-E;F1I9@HC
XM:69N9&5F($M%65]30T]060HC9&5F:6YE($M%65]30T]060DP-3<U"2\J('-H
XM:69T960@8V]P>2!K97D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4T-214%4
XM10HC9&5F:6YE($M%65]30U)%051%"3`U-S8)+RH@<VAI9G1E9"!C<F5A=&4@
XM:V5Y"0D)*B\*(V5N9&EF"B-I9FYD968@2T597U-$0PHC9&5F:6YE($M%65]3
XM1$,)"3`U-S<)+RH@<VAI9G1E9"!D96QE=&4@8VAA<B!K97D)"2HO"B-E;F1I
XM9@HC:69N9&5F($M%65]31$P*(V1E9FEN92!+15E?4T1,"0DP-C`P"2\J('-H
XM:69T960@9&5L971E(&QI;F4@:V5Y"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?
XM4T5,14-4"B-D969I;F4@2T597U-%3$5#5`DP-C`Q"2\J('-E;&5C="!K97D)
XM"0D)*B\*(V5N9&EF"B-I9FYD968@2T597U-%3D0*(V1E9FEN92!+15E?4T5.
XM1`DP-C`R"2\J('-H:69T960@96YD(&ME>0D)"2HO"B-E;F1I9@HC:69N9&5F
XM($M%65]314],"B-D969I;F4@2T597U-%3TP),#8P,PDO*B!S:&EF=&5D(&-L
XM96%R(&QI;F4@:V5Y"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4T58250*(V1E
XM9FEN92!+15E?4T58250),#8P-`DO*B!S:&EF=&5D(&5X:70@:V5Y"0D)*B\*
XM(V5N9&EF"B-I9FYD968@2T597U-&24Y$"B-D969I;F4@2T597U-&24Y$"3`V
XM,#4)+RH@<VAI9G1E9"!F:6YD(&ME>0D)"2HO"B-E;F1I9@HC:69N9&5F($M%
XM65]32$5,4`HC9&5F:6YE($M%65]32$5,4`DP-C`V"2\J('-H:69T960@:&5L
XM<"!K97D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4TA/344*(V1E9FEN92!+
XM15E?4TA/344),#8P-PDO*B!S:&EF=&5D(&AO;64@:V5Y"0D)*B\*(V5N9&EF
XM"B-I9FYD968@2T597U-)0PHC9&5F:6YE($M%65]324,)"3`V,3`)+RH@<VAI
XM9G1E9"!I;G!U="!K97D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4TQ%1E0*
XM(V1E9FEN92!+15E?4TQ%1E0),#8Q,0DO*B!S:&EF=&5D(&QE9G0@87)R;W<@
XM:V5Y"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4TU%4U-!1T4*(V1E9FEN92!+
XM15E?4TU%4U-!1T4),#8Q,@DO*B!S:&EF=&5D(&UE<W-A9V4@:V5Y"0D)*B\*
XM(V5N9&EF"B-I9FYD968@2T597U--3U9%"B-D969I;F4@2T597U--3U9%"3`V
XM,3,)+RH@<VAI9G1E9"!M;W9E(&ME>0D)"2HO"B-E;F1I9@HC:69N9&5F($M%
XM65]33D585`HC9&5F:6YE($M%65]33D585`DP-C$T"2\J('-H:69T960@;F5X
XM="!K97D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4T]05$E/3E,*(V1E9FEN
XM92!+15E?4T]05$E/3E,),#8Q-0DO*B!S:&EF=&5D(&]P=&EO;G,@:V5Y"0D)
XM*B\*(V5N9&EF"B-I9FYD968@2T597U-04D5624]54PHC9&5F:6YE($M%65]3
XM4%)%5DE/55,),#8Q-@DO*B!S:&EF=&5D('!R978@:V5Y"0D)*B\*(V5N9&EF
XM"B-I9FYD968@2T597U-04DE.5`HC9&5F:6YE($M%65]34%))3E0),#8Q-PDO
XM*B!S:&EF=&5D('!R:6YT(&ME>0D)"2HO"B-E;F1I9@HC:69N9&5F($M%65]3
XM4D5$3PHC9&5F:6YE($M%65]34D5$3PDP-C(P"2\J('-H:69T960@<F5D;R!K
XM97D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4U)%4$Q!0T4*(V1E9FEN92!+
XM15E?4U)%4$Q!0T4),#8R,0DO*B!S:&EF=&5D(')E<&QA8V4@:V5Y"0D)*B\*
XM(V5N9&EF"B-I9FYD968@2T597U-224=(5`HC9&5F:6YE($M%65]34DE'2%0)
XM,#8R,@DO*B!S:&EF=&5D(')I9VAT(&%R<F]W"0D)*B\*(V5N9&EF"B-I9FYD
XM968@2T597U-24U5-10HC9&5F:6YE($M%65]34E-5344),#8R,PDO*B!S:&EF
XM=&5D(')E<W5M92!K97D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4U-!5D4*
XM(V1E9FEN92!+15E?4U-!5D4),#8R-`DO*B!S:&EF=&5D('-A=F4@:V5Y"0D)
XM*B\*(V5N9&EF"B-I9FYD968@2T597U-355-014Y$"B-D969I;F4@2T597U-3
XM55-014Y$"3`V,C4)+RH@<VAI9G1E9"!S=7-P96YD(&ME>0D)"2HO"B-E;F1I
XM9@HC:69N9&5F($M%65]354Y$3PHC9&5F:6YE($M%65]354Y$3PDP-C(V"2\J
XM('-H:69T960@=6YD;R!K97D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4U53
XM4$5.1`HC9&5F:6YE($M%65]355-014Y$"3`V,C<)+RH@<W5S<&5N9"!K97D)
XM"0D)*B\*(V5N9&EF"B-I9FYD968@2T597U5.1$\*(V1E9FEN92!+15E?54Y$
XM3PDP-C,P"2\J('5N9&\@:V5Y"0D)"2HO"B-E;F1I9@HC:69N9&5F($M%65]-
XM05@*(V1E9FEN92!+15E?34%8"0DP-S<W"2\J($UA>&EM=6T@8W5R<V5S(&ME
XM>0D)"2HO"B-E;F1I9@HC:69N9&5F($%?05144DE"551%4PHC9&5F:6YE($%?
XM05144DE"551%4R`@("`P>&9F9F9F9C`P"B-E;F1I9@HC:69N9&5F($%?3D]2
XM34%,"B-D969I;F4@05].3U)-04P@("`@("`@(#!X,#`P,#`P,#`*(V5N9&EF
XM"B-I9FYD968@05]35$%.1$]55`HC9&5F:6YE($%?4U1!3D1/550@("`@("`P
XM>#`P,#$P,#`P"B-E;F1I9@HC:69N9&5F($%?54Y$15),24Y%"B-D969I;F4@
XM05]53D1%4DQ)3D4@("`@(#!X,#`P,C`P,#`*(V5N9&EF"B-I9FYD968@05]2
XM159%4E-%"B-D969I;F4@05]2159%4E-%("`@("`@(#!X,#`P-#`P,#`*(V5N
XM9&EF"B-I9FYD968@05]"3$E.2PHC9&5F:6YE($%?0DQ)3DL@("`@("`@("`P
XM>#`P,#@P,#`P"B-E;F1I9@HC:69N9&5F($%?1$E-"B-D969I;F4@05]$24T@
XM("`@("`@("`@(#!X,#`Q,#`P,#`*(V5N9&EF"B-I9FYD968@05]"3TQ$"B-D
XM969I;F4@05]"3TQ$("`@("`@("`@(#!X,#`R,#`P,#`*(V5N9&EF"B-I9FYD
XM968@05]!3%1#2$%24T54"B-D969I;F4@05]!3%1#2$%24T54("`@(#!X,#`T
XM,#`P,#`*(V5N9&EF"B-I9FYD968@05])3E9)4PHC9&5F:6YE($%?24Y625,@
XM("`@("`@("`P>#`P.#`P,#`P"B-E;F1I9@HC:69N9&5F($%?4%)/5$5#5`HC
XM9&5F:6YE($%?4%)/5$5#5"`@("`@("`P>#`Q,#`P,#`P"B-E;F1I9@HC:69N
XM9&5F($%?0TA!4E1%6%0*(V1E9FEN92!!7T-(05)415A4("`@("`@,'@P,#`P
XM,#!F9@HC96YD:68*(VEF;F1E9B!!7T-/3$]2"B-D969I;F4@05]#3TQ/4B`@
XM("`@("`@(#!X,#`P,&9F,#`*(V5N9&EF"B-I9FYD968@2T597TU)3@HC9&5F
XM:6YE($M%65]-24X)"3`T,#$)+RH@36EN:6UU;2!C=7)S97,@:V5Y"0D)*B\*
XM(V5N9&EF"B-I9FYD968@2T597T)214%+"B-D969I;F4@2T597T)214%+("`@
XM("`@(#`T,#$)+RH@8G)E86L@:V5Y("AU;G)E;&EA8FQE*0D)*B\*(V5N9&EF
XM"B-I9FYD968@2T597T1/5TX*(V1E9FEN92!+15E?1$]73B`@("`@("`@,#0P
XM,@DO*B!4:&4@9F]U<B!A<G)O=R!K97ES("XN+@D)*B\*(V5N9&EF"B-I9FYD
XM968@2T597U50"B-D969I;F4@2T597U50("`@("`@("`@(#`T,#,*(V5N9&EF
XM"B-I9FYD968@2T597TQ%1E0*(V1E9FEN92!+15E?3$5&5"`@("`@("`@,#0P
XM-`HC96YD:68*(VEF;F1E9B!+15E?4DE'2%0*(V1E9FEN92!+15E?4DE'2%0@
XM("`@("`@,#0P-0DO*B`N+BX@*B\*(V5N9&EF"B-I9FYD968@2T597TA/344*
XM(V1E9FEN92!+15E?2$]-12`@("`@("`@,#0P-@DO*B!(;VUE(&ME>2`H=7!W
XM87)D*VQE9G0@87)R;W<I"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?0D%#2U-0
XM04-%"B-D969I;F4@2T597T)!0TM34$%#12`@(#`T,#<)+RH@8F%C:W-P86-E
XM("AU;G)E;&EA8FQE*0D)*B\*(V5N9&EF"B-I9FYD968@2T597T8P"B-D969I
XM;F4@2T597T8P("`@("`@("`@(#`T,3`)+RH@1G5N8W1I;VX@:V5Y<RX@(%-P
XM86-E(&9O<B`V-`D)*B\*(V5N9&EF"B-I9FYD968@2T597T8Q"B-D969I;F4@
XM2T597T8Q("`@("`@("`@(#`T,3$*(V5N9&EF"B-I9FYD968@2T597T8R"B-D
XM969I;F4@2T597T8R("`@("`@("`@(#`T,3(*(V5N9&EF"B-I9FYD968@2T59
XM7T8S"B-D969I;F4@2T597T8S("`@("`@("`@(#`T,3,*(V5N9&EF"B-I9FYD
XM968@2T597T8T"B-D969I;F4@2T597T8T("`@("`@("`@(#`T,30*(V5N9&EF
XM"B-I9FYD968@2T597T8U"B-D969I;F4@2T597T8U("`@("`@("`@(#`T,34*
XM(V5N9&EF"B-I9FYD968@2T597T8V"B-D969I;F4@2T597T8V("`@("`@("`@
XM(#`T,38*(V5N9&EF"B-I9FYD968@2T597T8W"B-D969I;F4@2T597T8W("`@
XM("`@("`@(#`T,3<*(V5N9&EF"B-I9FYD968@2T597T8X"B-D969I;F4@2T59
XM7T8X("`@("`@("`@(#`T,3@*(V5N9&EF"B-I9FYD968@2T597T8Y"B-D969I
XM;F4@2T597T8Y("`@("`@("`@(#`T,3D*(V5N9&EF"B-I9FYD968@2T597T8Q
XM,`HC9&5F:6YE($M%65]&,3`)"3`T,C`*(V5N9&EF"B-I9FYD968@2T597T8Q
XM,0HC9&5F:6YE($M%65]&,3$)"3`T,C$*(V5N9&EF"B-I9FYD968@2T597T8Q
XM,@HC9&5F:6YE($M%65]&,3()"3`T,C(*(V5N9&EF"B-I9FYD968@2T597T1,
XM"B-D969I;F4@2T597T1,("`@("`@("`@(#`U,3`)+RH@1&5L971E(&QI;F4)
XM"0D)*B\*(V5N9&EF"B-I9FYD968@2T597TE,"B-D969I;F4@2T597TE,("`@
XM("`@("`@(#`U,3$)+RH@26YS97)T(&QI;F4)"0D)*B\*(V5N9&EF"B-I9FYD
XM968@2T597T1#"B-D969I;F4@2T597T1#("`@("`@("`@(#`U,3()+RH@1&5L
XM971E(&-H87)A8W1E<@D)"2HO"B-E;F1I9@HC:69N9&5F($M%65])0PHC9&5F
XM:6YE($M%65])0R`@("`@("`@("`P-3$S"2\J($EN<V5R="!C:&%R(&]R(&5N
XM=&5R(&EN<V5R="!M;V1E"2HO"B-E;F1I9@HC:69N9&5F($M%65]%24,*(V1E
XM9FEN92!+15E?14E#("`@("`@("`@,#4Q-`DO*B!%>&ET(&EN<V5R="!C:&%R
XM(&UO9&4)"2HO"B-E;F1I9@HC:69N9&5F($M%65]#3$5!4@HC9&5F:6YE($M%
XM65]#3$5!4B`@("`@("`P-3$U"2\J($-L96%R('-C<F5E;@D)"0DJ+PHC96YD
XM:68*(VEF;F1E9B!+15E?14]3"B-D969I;F4@2T597T5/4R`@("`@("`@(#`U
XM,38)+RH@0VQE87(@=&\@96YD(&]F('-C<F5E;@D)*B\*(V5N9&EF"B-I9FYD
XM968@2T597T5/3`HC9&5F:6YE($M%65]%3TP@("`@("`@("`P-3$W"2\J($-L
XM96%R('1O(&5N9"!O9B!L:6YE"0D)*B\*(V5N9&EF"B-I9FYD968@2T597U-&
XM"B-D969I;F4@2T597U-&("`@("`@("`@(#`U,C`)+RH@4V-R;VQL(#$@;&EN
XM92!F;W)W87)D"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4U(*(V1E9FEN92!+
XM15E?4U(@("`@("`@("`@,#4R,0DO*B!38W)O;&P@,2!L:6YE(&)A8VMW87)D
XM<R`H<F5V97)S92D)*B\*(V5N9&EF"B-I9FYD968@2T597TY004=%"B-D969I
XM;F4@2T597TY004=%("`@("`@(#`U,C()+RH@3F5X="!P86=E"0D)"2HO"B-E
XM;F1I9@HC:69N9&5F($M%65]04$%'10HC9&5F:6YE($M%65]04$%'12`@("`@
XM("`P-3(S"2\J(%!R979I;W5S('!A9V4)"0DJ+PHC96YD:68*(VEF;F1E9B!+
XM15E?4U1!0@HC9&5F:6YE($M%65]35$%"("`@("`@("`P-3(T"2\J(%-E="!T
XM86()"0D)*B\*(V5N9&EF"B-I9FYD968@2T597T-404(*(V1E9FEN92!+15E?
XM0U1!0B`@("`@("`@,#4R-0DO*B!#;&5A<B!T86()"0D)*B\*(V5N9&EF"B-I
XM9FYD968@2T597T-!5$%""B-D969I;F4@2T597T-!5$%"("`@("`@(#`U,C8)
XM+RH@0VQE87(@86QL('1A8G,)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?14Y4
XM15(*(V1E9FEN92!+15E?14Y415(@("`@("`@,#4R-PDO*B!%;G1E<B!O<B!S
XM96YD("AU;G)E;&EA8FQE*0D)*B\*(V5N9&EF"B-I9FYD968@2T597U-215-%
XM5`HC9&5F:6YE($M%65]34D53150@("`@("`P-3,P"2\J('-O9G0@*'!A<G1I
XM86PI(')E<V5T("AU;G)E;&EA8FQE*0DJ+PHC96YD:68*(VEF;F1E9B!+15E?
XM4D53150*(V1E9FEN92!+15E?4D53150@("`@("`@,#4S,0DO*B!R97-E="!O
XM<B!H87)D(')E<V5T("AU;G)E;&EA8FQE*0DJ+PHC96YD:68*(VEF;F1E9B!+
XM15E?4%))3E0*(V1E9FEN92!+15E?4%))3E0@("`@("`@,#4S,@DO*B!P<FEN
XM="!O<B!C;W!Y"0D)*B\*(V5N9&EF"B-I9FYD968@2T597TQ,"B-D969I;F4@
XM2T597TQ,("`@("`@("`@(#`U,S,)+RH@:&]M92!D;W=N(&]R(&)O='1O;2`H
XM;&]W97(@;&5F="D)*B\*(V5N9&EF"@HO*@H@*B!3;VUE('-Y<W1E;7,@*&QI
XM:V4@04E8(#XZ?"`I(&1O;B=T(&AA=F4@<')E9&5F:6YE9"!I=&5M<PH@*B!L
XM:6ME($%#4U\J('-O($D@:&%V92!T;R`G9F%K92<@=&AE;2!H97)E+@HJ+PHC
XM:69N9&5F($%#4U](3$E.10HC9&5F:6YE"4%#4U](3$E.10DG+2<*(V5N9&EF
XM"B-I9FYD968@04-37U9,24Y%"B-D969I;F4)04-37U9,24Y%"2=\)PHC96YD
XM:68*(VEF;F1E9B!!0U-?54Q#3U).15(*(V1E9FEN90E!0U-?54Q#3U).15()
XM)RLG"B-E;F1I9@HC:69N9&5F($%#4U]54D-/4DY%4@HC9&5F:6YE"4%#4U]5
XM4D-/4DY%4@DG*R<*(V5N9&EF"B-I9FYD968@04-37TQ,0T]23D52"B-D969I
XM;F4)04-37TQ,0T]23D52"2<K)PHC96YD:68*(VEF;F1E9B!!0U-?3%)#3U).
XM15(*(V1E9FEN90E!0U-?3%)#3U).15())RLG"B-E;F1I9@HC:69N9&5F($%#
XM4U],5$5%"B-D969I;F4)04-37TQ4144))RLG"B-E;F1I9@HC:69N9&5F($%#
XM4U]25$5%"B-D969I;F4)04-37U)4144))RLG"B-E;F1I9@HC:69N9&5F($%#
XM4U]45$5%"B-D969I;F4)04-37U14144))RLG"B-E;F1I9@HC:69N9&5F($%#
XM4U]"5$5%"B-D969I;F4)04-37T)4144))RLG"B-E;F1I9@HC:69N9&5F($%#
XM4U]03%53"B-D969I;F4)04-37U!,55,))RLG"B-E;F1I9@HC96YD:68@+RH@
X,0U521$5&7T@@*B\*
X`
Xend
SHAR_EOF
  echo 'uudecoding file cdk-4.6.0/curdefs.h' &&
  uudecode _sharuue.tmp < _sharuue.tmp && rm -f _sharuue.tmp &&
  $shar_touch -am 1229121195 'cdk-4.6.0/curdefs.h' &&
  chmod 0400 'cdk-4.6.0/curdefs.h' ||
  echo 'restore of cdk-4.6.0/curdefs.h failed'
  shar_count="`wc -c < 'cdk-4.6.0/curdefs.h'`"
  test 10047 -eq "$shar_count" ||
    echo "cdk-4.6.0/curdefs.h: original size 10047, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk-4.6.0/Makefile ==============
if test -f 'cdk-4.6.0/Makefile' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk-4.6.0/Makefile (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk-4.6.0/Makefile (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk-4.6.0/Makefile' &&
X#
X# This is the makefile for the CDK library. Uncomment the machine/os
X# type which best suits your machine.
X#
X
X# Set up some global variables.
XCDKLIB	= libcdk.a
XCDKSLIB	= libcdk.so.1
XVERSION	= 4.6.0
X
X# Set up directory paths.
XMANDIR		= ./man
XEXAMDIR		= ./examples
XRELDIR		= ./cdk$(VERSION)
XINST_ROOTDIR	= /home/glover/local
XINST_LIBDIR	= $(INST_ROOTDIR)/lib
XINST_INCDIR	= $(INST_ROOTDIR)/include
XINST_MANDIR	= $(INST_ROOTDIR)/man
XINST_SRCDIR	= $(INST_ROOTDIR)/src
X
X# Linux
XCC	= gcc 
XINCPATH = -I/usr/local/include/ncurses -I/usr/local/include
XLIBPATH = -L/usr/local/lib -L. 
XLINKLIB = $(LIBPATH) -lncurses
XSHARED	= -fPIC
XSLINK	= -shared -Wl,-soname,$(CDKSLIB)
XCFLAGS	= $(INCPATH) -g -Wall -DLINUX -DCOLOR -DWINCHBUG
X
X# SUN
X#CC	= gcc 
X#INCPATH = -I/usr/5include
X#LIBPATH = -L/usr/5lib -L/usr/lib
X#LINKLIB = $(LIBPATH) -lcurses -ltermcap
X#CFLAGS	= $(INCPATH)  -g -DSUN
X
X# SOLARIS
X#CC	= cc 
X#INCPATH = 
X#LIBPATH = -L/usr/ccs/lib
X#LINKLIB = $(LIBPATH) -lcurses -ltermcap
X#SLINK	= -G
X#CFLAGS	= $(INCPATH) -g -DSOLARIS -DNOBZERO -DNOUSLEEP -DNODYNALLOC
X#SFLAGS	= -Fpic
X
X# AIX
X#CC	= cc 
X#INCPATH	=  
X#LIBPATH	=  
X#LINKLIB	= $(LIBPATH) -lcurses -ltermcap 
X#CFLAGS	= $(INCPATH) -g -qlanglvl=ansi -DAIX -DNODYNALLOC
X
X# HP-UX
X#CC	= c89
X#INCPATH	=  
X#LIBPATH	=  
X#LINKLIB	= $(LIBPATH) -lcurses
X#CFLAGS	= $(INCPATH) -g -Aa -DHPUX -D_HPUX_SOURCE -DNODYNALLOC _DNOCHTYPE
X
X###############################################################
X#          Do Not change anything under this line.            #
X###############################################################
X
X# Create the file lists.
XCDKHDR		= cdk.h curdefs.h
XCDKWIDGETS	= dialog.c draw.c entry.c graph.c fselect.c \
X			histogram.c itemlist.c label.c marquee.c \
X			matrix.c mentry.c menu.c radio.c \
X			scale.c scroll.c selection.c \
X			swindow.c template.c viewer.c
XCDKSRC		= cdk.c cdkscreen.c binding.c debug.c $(CDKWIDGETS)
XCDKOBJS		= $(CDKSRC:.c=.o)
XCDKEXAM		= $(CDKWIDGETS:.c=_ex.c) subwindow_ex.c
XCDKMAN		= $(CDKWIDGETS:.c=.3x) cdk.3x screen.3x binding.3x display.3x
XCDKDOCS		= BUGS EXPANDING INSTALL NOTES README TODO VERSION COPYING
X
X# Create the compile information for the executables.
Xtst: tst.o
X	$(CC) $(CFLAGS) -o tst tst.o $(CDKLIB) $(LINKLIB)
X
Xstst: tst.o
X	$(CC) $(CFLAGS) -o stst tst.o $(CDKSLIB).0 $(LINKLIB)
X
Xlib: $(CDKOBJS)
X	@ar r $(CDKLIB) $(CDKOBJS)
X	@ranlib $(CDKLIB)
X
X# Standard library directive.
Xcdklib $(CDKLIB):
X	@$(MAKE) clean
X	$(CC) $(CFLAGS) -c $(CDKSRC)
X	@ar r $(CDKLIB) $(CDKOBJS)
X	@ranlib $(CDKLIB)
X
X# Shared library directive.
Xcdkslib $(CDKSLIB):
X	@$(MAKE) clean
X	$(CC) $(CFLAGS) $(SFLAGS) -c $(CDKSRC)
X	$(CC) $(SLINK) -o $(CDKSLIB).0 $(CDKOBJS)
X
X# Install the library and realted files.
Xinstall:
X	@$(MAKE) instman
X	@$(MAKE) instsrc
X	@$(MAKE) instlib
X	@echo "Installation done.";
X
X# Install the manual pages.
Xinstman:
X	@if [ ! -d $(INST_MANDIR) ] ; then \
X	   echo "The man directory $(INST_MANDIR) does not exist. Exiting..."; \
X	   exit; \
X	fi;
X	@if [ ! -d $(INST_MANDIR)/man3x ]; then \
X	   echo "Making directory $(INST_MANDIR)/man3x ... "; \
X	   mkdir $(INST_MANDIR)/man3x ; \
X	fi;
X	@echo "Installing manual pages...";
X	@(cd $(MANDIR); for i in $(CDKMAN); do \
X	   echo "	$(INST_MANDIR)/man3x/cdk_$$i"; \
X	   rm -f $(INST_MANDIR)/man3x/cdk_$$i; \
X	   cp $$i $(INST_MANDIR)/man3x/cdk_$$i; \
X	done)
X
X# Install the source and release documents.
Xinstsrc:
X	@if [ ! -d $(INST_SRCDIR) ]; then \
X	   echo "The source directory $(INST_SRCDIR) does not exist. Exiting..."; \
X	   exit; \
X	fi;
X	@if [ ! -d $(INST_SRCDIR)/cdk ]; then \
X	   echo "Making directory $(INST_SRCDIR)/cdk ... "; \
X	   mkdir $(INST_SRCDIR)/cdk; \
X	fi;
X	@echo "Installing source example files...";
X	@(cd $(EXAMDIR); for i in $(CDKEXAM); do \
X	   echo "	$(INST_SRCDIR)/cdk/$$i" ; \
X	   rm -f $(INST_SRCDIR)/cdk/$$i; \
X	   cp $$i $(INST_SRCDIR)/cdk/$$i; \
X	done)
X	@echo "Installing release documents...";
X	@for i in $(CDKDOCS) ; do \
X	   echo "	$(INST_SRCDIR)/cdk/$$i"; \
X	   rm -f $(INST_SRCDIR)/cdk/$$i; \
X	   cp $$i $(INST_SRCDIR)/cdk/$$i; \
X	done
X
X# Install the libraries and header files.
Xinstlib:
X	@if [ -f $(CDKLIB) ] ; then \
X	   echo "Cdk library installed to $(INST_LIBDIR)/$(CDKLIB)"; \
X	   echo "Installing file $(INST_LIBDIR)/$(CDKLIB)"; \
X	   cp $(CDKLIB) $(INST_LIBDIR)/$(CDKLIB); \
X	fi
X	@if [ -f $(CDKSLIB) ] ; then \
X	   echo "Cdk shared library installed to $(INST_LIBDIR)/$(CDKLIB)"; \
X	   echo "Installing file $(INST_LIBDIR)/$(CDKSLIB).0"; \
X	   cp $(CDKSLIB).0 $(INST_LIBDIR)/$(CDKSLIB).0; \
X	fi
X	@echo "Installing file $(INST_INCDIR)/cdk.h";
X	@rm -f $(INST_INCDIR)/cdk.h
X	@cp cdk.h $(INST_INCDIR)
X	@echo "Installing file $(INST_INCDIR)/curdefs.h";
X	@rm -f $(INST_INCDIR)/curdefs.h
X	@cp curdefs.h $(INST_INCDIR)
X
Xclean:
X	rm -f *.o core tst stst $(CDKLIB) $(CDKSLIB).0
X
Xupdate:
X	@co $(CDKSRC) $(CDKHDR) $(CDKDOCS)
X	@(cd examples; co $(CDKEXAM))
X	@(cd man; co $(CDKMAN))
X
Xrelease:
X	@$(MAKE) update
X	@rm -rf $(RELDIR) $(RELDIR).tgz
X	@mkdir $(RELDIR)
X	@mkdir $(RELDIR)/examples
X	@mkdir $(RELDIR)/man
X	@for i in $(CDKSRC) $(CDKDOCS) $(CDKHDR); do \
X	   cp $$i $(RELDIR); \
X	done
X	@for i in $(CDKMAN); do \
X	   cp $(MANDIR)/$$i $(RELDIR)/man ; \
X	done
X	@for i in $(CDKEXAM); do \
X	   cp $(EXAMDIR)/$$i $(RELDIR)/examples ; \
X	done
X	@cp Makefile $(RELDIR)
X	@tar cvfz $(RELDIR).tgz $(RELDIR)
X	@rm -rf $(RELDIR)
SHAR_EOF
  $shar_touch -am 1229121195 'cdk-4.6.0/Makefile' &&
  chmod 0400 'cdk-4.6.0/Makefile' ||
  echo 'restore of cdk-4.6.0/Makefile failed'
  shar_count="`wc -c < 'cdk-4.6.0/Makefile'`"
  test 5267 -eq "$shar_count" ||
    echo "cdk-4.6.0/Makefile: original size 5267, current size $shar_count"
  rm -f _sharnew.tmp
fi
rm -f _sharseq.tmp
echo 'You have unpacked the last part'
exit 0
