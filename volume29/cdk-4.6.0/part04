Newsgroups: comp.sources.unix
From: glover@credit.erin.utoronto.ca (Mike Glover)
Subject: v29i077: cdk - curses development kit, V4.6.0, Part04/09
References: <1.821493023.9103@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: glover@credit.erin.utoronto.ca (Mike Glover)
Posting-Number: Volume 29, Issue 77
Archive-Name: cdk-4.6.0/part04

#!/bin/sh
# This is `part04' (part 4 of a multipart archive).
# Do not concatenate these parts, unpack them in order with `/bin/sh'.
# File `cdk-4.6.0/cdkscreen.c' is being continued...
#
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  echo 'WARNING: not restoring timestamps.  Consider getting and'
  echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if test ! -r _sharseq.tmp; then
  echo 'Please unpack part 1 first!'
  exit 1
fi
shar_sequence=`cat _sharseq.tmp`
if test "$shar_sequence" != 4; then
  echo "Please unpack part $shar_sequence next!"
  exit 1
fi
if test ! -f _sharnew.tmp; then
  echo 'x - still skipping cdk-4.6.0/cdkscreen.c'
else
  echo 'x - continuing file cdk-4.6.0/cdkscreen.c'
  sed 's/^X//' << 'SHAR_EOF' >> 'cdk-4.6.0/cdkscreen.c' &&
X      ((CDKENTRY *)object)->screenIndex			= toppos;
X      ((CDKENTRY *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKENTRY *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMENTRY)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKMENTRY *)object)->screen->objectCount;
X      swapobject	= ((CDKMENTRY *)object)->screen->object[toppos];
X      swaptype		= ((CDKMENTRY *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMENTRY *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMENTRY *)object)->screenIndex		= toppos;
X      ((CDKMENTRY *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMENTRY *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSCROLL)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKSCROLL *)object)->screen->objectCount;
X      swapobject	= ((CDKSCROLL *)object)->screen->object[toppos];
X      swaptype		= ((CDKSCROLL *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSCROLL *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSCROLL *)object)->screenIndex		= toppos;
X      ((CDKSCROLL *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSCROLL *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vDIALOG)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKDIALOG *)object)->screen->objectCount;
X      swapobject	= ((CDKDIALOG *)object)->screen->object[toppos];
X      swaptype		= ((CDKDIALOG *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKDIALOG *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKDIALOG *)object)->screenIndex		= toppos;
X      ((CDKDIALOG *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKDIALOG *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSCALE)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKSCALE *)object)->screen->objectCount;
X      swapobject	= ((CDKSCALE *)object)->screen->object[toppos];
X      swaptype		= ((CDKSCALE *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSCALE *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSCALE *)object)->screenIndex			= toppos;
X      ((CDKSCALE *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSCALE *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMARQUEE)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKMARQUEE *)object)->screen->objectCount;
X      swapobject	= ((CDKMARQUEE *)object)->screen->object[toppos];
X      swaptype		= ((CDKMARQUEE *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMARQUEE *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMARQUEE *)object)->screenIndex		= toppos;
X      ((CDKMARQUEE *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMARQUEE *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMENU)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKMENU *)object)->screen->objectCount;
X      swapobject	= ((CDKMENU *)object)->screen->object[toppos];
X      swaptype		= ((CDKMENU *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMENU *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMENU *)object)->screenIndex			= toppos;
X      ((CDKMENU *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMENU *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMATRIX)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKMATRIX *)object)->screen->objectCount;
X      swapobject	= ((CDKMATRIX *)object)->screen->object[toppos];
X      swaptype		= ((CDKMATRIX *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMATRIX *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMATRIX *)object)->screenIndex		= toppos;
X      ((CDKMATRIX *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMATRIX *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vHISTOGRAM)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKHISTOGRAM *)object)->screen->objectCount;
X      swapobject	= ((CDKHISTOGRAM *)object)->screen->object[toppos];
X      swaptype		= ((CDKHISTOGRAM *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKHISTOGRAM *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKHISTOGRAM *)object)->screenIndex		= toppos;
X      ((CDKHISTOGRAM *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKHISTOGRAM *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSELECTION)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKSELECTION *)object)->screen->objectCount;
X      swapobject	= ((CDKSELECTION *)object)->screen->object[toppos];
X      swaptype		= ((CDKSELECTION *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSELECTION *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSELECTION *)object)->screenIndex		= toppos;
X      ((CDKSELECTION *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSELECTION *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vVIEWER)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKVIEWER *)object)->screen->objectCount;
X      swapobject	= ((CDKVIEWER *)object)->screen->object[toppos];
X      swaptype		= ((CDKVIEWER *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKVIEWER *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKVIEWER *)object)->screenIndex		= toppos;
X      ((CDKVIEWER *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKVIEWER *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vGRAPH)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKGRAPH *)object)->screen->objectCount;
X      swapobject	= ((CDKGRAPH *)object)->screen->object[toppos];
X      swaptype		= ((CDKGRAPH *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKGRAPH *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKGRAPH *)object)->screenIndex			= toppos;
X      ((CDKGRAPH *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKGRAPH *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vRADIO)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKRADIO *)object)->screen->objectCount;
X      swapobject	= ((CDKRADIO *)object)->screen->object[toppos];
X      swaptype		= ((CDKRADIO *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKRADIO *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKRADIO *)object)->screenIndex			= toppos;
X      ((CDKRADIO *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKRADIO *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vTEMPLATE)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKTEMPLATE *)object)->screen->objectCount;
X      swapobject	= ((CDKTEMPLATE *)object)->screen->object[toppos];
X      swaptype		= ((CDKTEMPLATE *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKTEMPLATE *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKTEMPLATE *)object)->screenIndex		= toppos;
X      ((CDKTEMPLATE *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKTEMPLATE *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSWINDOW)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKSWINDOW *)object)->screen->objectCount;
X      swapobject	= ((CDKSWINDOW *)object)->screen->object[toppos];
X      swaptype		= ((CDKSWINDOW *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSWINDOW *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSWINDOW *)object)->screenIndex		= toppos;
X      ((CDKSWINDOW *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSWINDOW *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKITEMLIST *)object)->screen->objectCount;
X      swapobject	= ((CDKITEMLIST *)object)->screen->object[toppos];
X      swaptype		= ((CDKITEMLIST *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKITEMLIST *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKITEMLIST *)object)->screenIndex		= toppos;
X      ((CDKITEMLIST *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKITEMLIST *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKFSELECT *)object)->screen->objectCount;
X      swapobject	= ((CDKFSELECT *)object)->screen->object[toppos];
X      swaptype		= ((CDKFSELECT *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKFSELECT *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKFSELECT *)object)->screenIndex		= toppos;
X      ((CDKFSELECT *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKFSELECT *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   
X   /* OK, Lets swap 'em....						*/
X   if (swaptype == vLABEL)
X   {
X      ((CDKLABEL *)object)->screenIndex			= swapindex;
X      ((CDKLABEL *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKLABEL *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vENTRY)
X   {
X      ((CDKENTRY *)object)->screenIndex			= swapindex;
X      ((CDKENTRY *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKENTRY *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMENTRY)
X   {
X      ((CDKMENTRY *)object)->screenIndex		= swapindex;
X      ((CDKMENTRY *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKMENTRY *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSCROLL)
X   {
X      ((CDKSCROLL *)object)->screenIndex		= swapindex;
X      ((CDKSCROLL *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKSCROLL *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vDIALOG)
X   {
X      ((CDKDIALOG *)object)->screenIndex		= swapindex;
X      ((CDKDIALOG *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKDIALOG *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSCALE)
X   {
X      ((CDKSCALE *)object)->screenIndex			= swapindex;
X      ((CDKSCALE *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKSCALE *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMARQUEE)
X   {
X      ((CDKMARQUEE *)object)->screenIndex			= swapindex;
X      ((CDKMARQUEE *)object)->screen->object[swapindex]		= swapobject;
X      ((CDKMARQUEE *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMENU)
X   {
X      ((CDKMENU *)object)->screenIndex			= swapindex;
X      ((CDKMENU *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKMENU *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMATRIX)
X   {
X      ((CDKMATRIX *)object)->screenIndex		= swapindex;
X      ((CDKMATRIX *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKMATRIX *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vHISTOGRAM)
X   {
X      ((CDKHISTOGRAM *)object)->screenIndex			= swapindex;
X      ((CDKHISTOGRAM *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKHISTOGRAM *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSELECTION)
X   {
X      ((CDKSELECTION *)object)->screenIndex			= swapindex;
X      ((CDKSELECTION *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKSELECTION *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vVIEWER)
X   {
X      ((CDKVIEWER *)object)->screenIndex		= swapindex;
X      ((CDKVIEWER *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKVIEWER *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vGRAPH)
X   {
X      ((CDKGRAPH *)object)->screenIndex			= swapindex;
X      ((CDKGRAPH *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKGRAPH *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vRADIO)
X   {
X      ((CDKRADIO *)object)->screenIndex			= swapindex;
X      ((CDKRADIO *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKRADIO *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vTEMPLATE)
X   {
X      ((CDKTEMPLATE *)object)->screenIndex			= swapindex;
X      ((CDKTEMPLATE *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKTEMPLATE *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSWINDOW)
X   {
X      ((CDKSWINDOW *)object)->screenIndex			= swapindex;
X      ((CDKSWINDOW *)object)->screen->object[swapindex]		= swapobject;
X      ((CDKSWINDOW *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vITEMLIST)
X   {
X      ((CDKITEMLIST *)object)->screenIndex			= swapindex;
X      ((CDKITEMLIST *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKITEMLIST *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vFSELECT)
X   {
X      ((CDKFSELECT *)object)->screenIndex			= swapindex;
X      ((CDKFSELECT *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKFSELECT *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X}
X   
X/*
X * This 'lowers' an object.
X*/
Xvoid lowerCDKObject (EObjectType cdktype, void *object)
X{
X   /* Declare some vars.						*/
X   void *swapobject	= (void *)NULL;
X   int toppos		= 0;
X   int swapindex	= -1;
X   EObjectType swaptype;
X
X   /* Should never dereference a void * pointer.			*/
X   if (cdktype == vLABEL)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKLABEL *)object)->screen->object[toppos];
X      swaptype		= ((CDKLABEL *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKLABEL *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKLABEL *)object)->screenIndex			= toppos;
X      ((CDKLABEL *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKLABEL *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vENTRY)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKENTRY *)object)->screen->object[toppos];
X      swaptype		= ((CDKENTRY *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKENTRY *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKENTRY *)object)->screenIndex			= toppos;
X      ((CDKENTRY *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKENTRY *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMENTRY)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKMENTRY *)object)->screen->object[toppos];
X      swaptype		= ((CDKMENTRY *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMENTRY *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMENTRY *)object)->screenIndex		= toppos;
X      ((CDKMENTRY *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMENTRY *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSCROLL)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKSCROLL *)object)->screen->object[toppos];
X      swaptype		= ((CDKSCROLL *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSCROLL *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSCROLL *)object)->screenIndex		= toppos;
X      ((CDKSCROLL *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSCROLL *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vDIALOG)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKDIALOG *)object)->screen->object[toppos];
X      swaptype		= ((CDKDIALOG *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKDIALOG *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKDIALOG *)object)->screenIndex		= toppos;
X      ((CDKDIALOG *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKDIALOG *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSCALE)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKSCALE *)object)->screen->object[toppos];
X      swaptype		= ((CDKSCALE *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSCALE *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSCALE *)object)->screenIndex			= toppos;
X      ((CDKSCALE *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSCALE *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMARQUEE)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKMARQUEE *)object)->screen->object[toppos];
X      swaptype		= ((CDKMARQUEE *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMARQUEE *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMARQUEE *)object)->screenIndex		= toppos;
X      ((CDKMARQUEE *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMARQUEE *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMENU)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKMENU *)object)->screen->object[toppos];
X      swaptype		= ((CDKMENU *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMENU *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMENU *)object)->screenIndex			= toppos;
X      ((CDKMENU *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMENU *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMATRIX)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKMATRIX *)object)->screen->object[toppos];
X      swaptype		= ((CDKMATRIX *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMATRIX *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMATRIX *)object)->screenIndex		= toppos;
X      ((CDKMATRIX *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMATRIX *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vHISTOGRAM)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKHISTOGRAM *)object)->screen->object[toppos];
X      swaptype		= ((CDKHISTOGRAM *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKHISTOGRAM *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKHISTOGRAM *)object)->screenIndex		= toppos;
X      ((CDKHISTOGRAM *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKHISTOGRAM *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSELECTION)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKSELECTION *)object)->screen->object[toppos];
X      swaptype		= ((CDKSELECTION *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSELECTION *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSELECTION *)object)->screenIndex		= toppos;
X      ((CDKSELECTION *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSELECTION *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vVIEWER)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKVIEWER *)object)->screen->object[toppos];
X      swaptype		= ((CDKVIEWER *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKVIEWER *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKVIEWER *)object)->screenIndex		= toppos;
X      ((CDKVIEWER *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKVIEWER *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vGRAPH)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKGRAPH *)object)->screen->object[toppos];
X      swaptype		= ((CDKGRAPH *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKGRAPH *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKGRAPH *)object)->screenIndex			= toppos;
X      ((CDKGRAPH *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKGRAPH *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vRADIO)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKRADIO *)object)->screen->object[toppos];
X      swaptype		= ((CDKRADIO *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKRADIO *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKRADIO *)object)->screenIndex			= toppos;
X      ((CDKRADIO *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKRADIO *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vTEMPLATE)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKTEMPLATE *)object)->screen->object[toppos];
X      swaptype		= ((CDKTEMPLATE *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKTEMPLATE *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKTEMPLATE *)object)->screenIndex		= toppos;
X      ((CDKTEMPLATE *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKTEMPLATE *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSWINDOW)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKSWINDOW *)object)->screen->object[toppos];
X      swaptype		= ((CDKSWINDOW *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSWINDOW *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSWINDOW *)object)->screenIndex		= toppos;
X      ((CDKSWINDOW *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSWINDOW *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKITEMLIST *)object)->screen->object[toppos];
X      swaptype		= ((CDKITEMLIST *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKITEMLIST *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKITEMLIST *)object)->screenIndex		= toppos;
X      ((CDKITEMLIST *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKITEMLIST *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vFSELECT)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKFSELECT *)object)->screen->object[toppos];
X      swaptype		= ((CDKFSELECT *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKFSELECT *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKFSELECT *)object)->screenIndex		= toppos;
X      ((CDKFSELECT *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKFSELECT *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   
X   /* OK, Lets swap 'em....						*/
X   if (swaptype == vLABEL)
X   {
X      ((CDKLABEL *)object)->screenIndex			= swapindex;
X      ((CDKLABEL *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKLABEL *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vENTRY)
X   {
X      ((CDKENTRY *)object)->screenIndex			= swapindex;
X      ((CDKENTRY *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKENTRY *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMENTRY)
X   {
X      ((CDKMENTRY *)object)->screenIndex		= swapindex;
X      ((CDKMENTRY *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKMENTRY *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSCROLL)
X   {
X      ((CDKSCROLL *)object)->screenIndex		= swapindex;
X      ((CDKSCROLL *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKSCROLL *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vDIALOG)
X   {
X      ((CDKDIALOG *)object)->screenIndex		= swapindex;
X      ((CDKDIALOG *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKDIALOG *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSCALE)
X   {
X      ((CDKSCALE *)object)->screenIndex			= swapindex;
X      ((CDKSCALE *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKSCALE *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMARQUEE)
X   {
X      ((CDKMARQUEE *)object)->screenIndex			= swapindex;
X      ((CDKMARQUEE *)object)->screen->object[swapindex]		= swapobject;
X      ((CDKMARQUEE *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMENU)
X   {
X      ((CDKMENU *)object)->screenIndex			= swapindex;
X      ((CDKMENU *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKMENU *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMATRIX)
X   {
X      ((CDKMATRIX *)object)->screenIndex		= swapindex;
X      ((CDKMATRIX *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKMATRIX *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vHISTOGRAM)
X   {
X      ((CDKHISTOGRAM *)object)->screenIndex			= swapindex;
X      ((CDKHISTOGRAM *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKHISTOGRAM *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSELECTION)
X   {
X      ((CDKSELECTION *)object)->screenIndex			= swapindex;
X      ((CDKSELECTION *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKSELECTION *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vVIEWER)
X   {
X      ((CDKVIEWER *)object)->screenIndex		= swapindex;
X      ((CDKVIEWER *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKVIEWER *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vGRAPH)
X   {
X      ((CDKGRAPH *)object)->screenIndex			= swapindex;
X      ((CDKGRAPH *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKGRAPH *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vRADIO)
X   {
X      ((CDKRADIO *)object)->screenIndex			= swapindex;
X      ((CDKRADIO *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKRADIO *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vTEMPLATE)
X   {
X      ((CDKTEMPLATE *)object)->screenIndex			= swapindex;
X      ((CDKTEMPLATE *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKTEMPLATE *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSWINDOW)
X   {
X      ((CDKSWINDOW *)object)->screenIndex			= swapindex;
X      ((CDKSWINDOW *)object)->screen->object[swapindex]		= swapobject;
X      ((CDKSWINDOW *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vITEMLIST)
X   {
X      ((CDKITEMLIST *)object)->screenIndex			= swapindex;
X      ((CDKITEMLIST *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKITEMLIST *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vFSELECT)
X   {
X      ((CDKFSELECT *)object)->screenIndex			= swapindex;
X      ((CDKFSELECT *)object)->screen->object[swapindex]		= swapobject;
X      ((CDKFSELECT *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X}
X
X/*
X * This refreshes all the objects in the screen.
X */
Xvoid refreshCDKScreen (CDKSCREEN *cdkscreen)
X{
X   int objectCount 	= cdkscreen->objectCount;
X   int x;
X
X   /* We just call the drawObject function...	*/
X   for (x=0; x < objectCount; x++)
X   {
X      if (cdkscreen->cdktype[x] == vLABEL)
X      {
X         CDKLABEL *label	= (CDKLABEL *)(cdkscreen->object[x]);
X         drawCDKLabel (label, label->box);
X      }
X      else if (cdkscreen->cdktype[x] == vENTRY)
X      {
X         CDKENTRY *entry	= (CDKENTRY *)(cdkscreen->object[x]);
X         drawCDKEntry (entry, entry->box);
X      }
X      else if (cdkscreen->cdktype[x] == vMENTRY)
X      {
X         CDKMENTRY *mentry	= (CDKMENTRY *)(cdkscreen->object[x]);
X         drawCDKMentry (mentry, mentry->box);
X      }
X      else if (cdkscreen->cdktype[x] == vSCROLL)
X      {
X         CDKSCROLL *scroll	= (CDKSCROLL *)(cdkscreen->object[x]);
X         drawCDKScroll (scroll, scroll->box);
X      }
X      else if (cdkscreen->cdktype[x] == vDIALOG)
X      {
X         CDKDIALOG *dialog	= (CDKDIALOG *)(cdkscreen->object[x]);
X         drawCDKDialog (dialog, dialog->box);
X      }
X      else if (cdkscreen->cdktype[x] == vSCALE)
X      {
X         CDKSCALE *scale	= (CDKSCALE *)(cdkscreen->object[x]);
X         drawCDKScale (scale, scale->box);
X      }
X      else if (cdkscreen->cdktype[x] == vMARQUEE)
X      {
X         CDKMARQUEE *marquee	= (CDKMARQUEE *)(cdkscreen->object[x]);
X         drawCDKMarquee (marquee, marquee->box);
X      }
X      else if (cdkscreen->cdktype[x] == vMENU)
X      {
X         CDKMENU *menu	= (CDKMENU *)(cdkscreen->object[x]);
X         drawCDKMenu (menu);
X      }
X      else if (cdkscreen->cdktype[x] == vMATRIX)
X      {
X         CDKMATRIX *matrix	= (CDKMATRIX *)(cdkscreen->object[x]);
X         drawCDKMatrix (matrix, matrix->boxMatrix);
X      }
X      else if (cdkscreen->cdktype[x] == vHISTOGRAM)
X      {
X         CDKHISTOGRAM *histogram	= (CDKHISTOGRAM *)(cdkscreen->object[x]);
X         drawCDKHistogram (histogram, histogram->box);
X      }
X      else if (cdkscreen->cdktype[x] == vSELECTION)
X      {
X         CDKSELECTION *selection	= (CDKSELECTION *)(cdkscreen->object[x]);
X         drawCDKSelection (selection, selection->box);
X      }
X      else if (cdkscreen->cdktype[x] == vVIEWER)
X      {
X         CDKVIEWER *viewer	= (CDKVIEWER *)(cdkscreen->object[x]);
X         drawCDKViewer (viewer, viewer->box);
X      }
X      else if (cdkscreen->cdktype[x] == vGRAPH)
X      {
X         CDKGRAPH *graph	= (CDKGRAPH *)(cdkscreen->object[x]);
X         drawCDKGraph (graph, graph->box);
X      }
X      else if (cdkscreen->cdktype[x] == vRADIO)
X      {
X         CDKRADIO *radio	= (CDKRADIO *)(cdkscreen->object[x]);
X         drawCDKRadio (radio, radio->box);
X      }
X      else if (cdkscreen->cdktype[x] == vTEMPLATE)
X      {
X         CDKTEMPLATE *template	= (CDKTEMPLATE *)(cdkscreen->object[x]);
X         drawCDKTemplate (template, template->box);
X      }
X      else if (cdkscreen->cdktype[x] == vSWINDOW)
X      {
X         CDKSWINDOW *swindow	= (CDKSWINDOW *)(cdkscreen->object[x]);
X         drawCDKSwindow (swindow, swindow->box);
X      }
X      else if (cdkscreen->cdktype[x] == vITEMLIST)
X      {
X         CDKITEMLIST *itemlist	= (CDKITEMLIST *)(cdkscreen->object[x]);
X         drawCDKItemlist (itemlist, itemlist->box);
X      }
X      else if (cdkscreen->cdktype[x] == vFSELECT)
X      {
X         CDKFSELECT *fselect	= (CDKFSELECT *)(cdkscreen->object[x]);
X         drawCDKFselect (fselect, fselect->box);
X      }
X   }
X
X   /* Refresh the screen.			*/
X   wrefresh (cdkscreen->window);
X}
X
X/*
X * This clears all the objects in the screen.
X */
Xvoid eraseCDKScreen (CDKSCREEN *cdkscreen)
X{
X   int objectCount 	= cdkscreen->objectCount;
X   int x;
X
X   /* We just call the drawObject function...	*/
X   for (x=0; x < objectCount; x++)
X   {
X      if (cdkscreen->cdktype[x] == vLABEL)
X      {
X         eraseCDKLabel ((CDKLABEL *)(cdkscreen->object[x]));
X      }
X      else if (cdkscreen->cdktype[x] == vENTRY)
X      {
X         eraseCDKEntry ((CDKENTRY *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vMENTRY)
X      {
X         eraseCDKMentry ((CDKMENTRY *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vSCROLL)
X      {
X         eraseCDKScroll ((CDKSCROLL *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vDIALOG)
X      {
X         eraseCDKDialog ((CDKDIALOG *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vSCALE)
X      {
X         eraseCDKScale ((CDKSCALE *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vMARQUEE)
X      {
X         eraseCDKMarquee ((CDKMARQUEE *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vMENU)
X      {
X         eraseCDKMenu ((CDKMENU *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vMATRIX)
X      {
X         eraseCDKMatrix ((CDKMATRIX *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vHISTOGRAM)
X      {
X         eraseCDKHistogram ((CDKHISTOGRAM *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vSELECTION)
X      {
X         eraseCDKSelection ((CDKSELECTION *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vVIEWER)
X      {
X         eraseCDKViewer ((CDKVIEWER *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vGRAPH)
X      {
X         eraseCDKGraph ((CDKGRAPH *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vRADIO)
X      {
X         eraseCDKRadio ((CDKRADIO *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vTEMPLATE)
X      {
X         eraseCDKTemplate ((CDKTEMPLATE *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vSWINDOW)
X      {
X         eraseCDKSwindow ((CDKSWINDOW *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vITEMLIST)
X      {
X         eraseCDKItemlist ((CDKITEMLIST *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vFSELECT)
X      {
X         eraseCDKFselect ((CDKFSELECT *)cdkscreen->object[x]);
X      }
X   }
X
X   /* Refresh the screen.			*/
X   wrefresh (cdkscreen->window);
X}
X
X/*
X * This destroys a CDK screen.
X */
Xvoid destroyCDKScreen (CDKSCREEN *screen)
X{
X   free (screen);
X}
X
X/*
X * This is added to remain consistent.
X */
Xvoid endCDK()
X{
X   /* Turn echoing back on...		*/
X   echo();
X
X   /* Turn off cbreak...		*/
X   nocbreak();
X
X   /* End the curses windows...		*/
X   endwin();
X}
X
X/*
X * This is for pure diagnostics. Really should be taken out
X * at some point in time.
X */
Xvoid debugCDKScreen (CDKSCREEN *screen, char *mesg)
X{
X   char *objects[]	= {"ENTRY", "MENTRY", "LABEL", "SCROLL", "DIALOG", "ARRAY", "SCALE", "MARQUEE", "MENU", "MATRIX", "HISTOGRAM", "SELECTION", "VIEWER", "GRAPH", "RADIO", "TEMPLATE", "SWINDOW"};
X   int count		= screen->objectCount;
X   int x;
X
X   for (x=0; x < count ; x++)
X   {
X      printf ("CDK Object[%d] : Type: %s\n", x, objects[screen->cdktype[x]]);
X   }
X}
SHAR_EOF
  echo 'File cdk-4.6.0/cdkscreen.c is complete' &&
  $shar_touch -am 1229121095 'cdk-4.6.0/cdkscreen.c' &&
  chmod 0400 'cdk-4.6.0/cdkscreen.c' ||
  echo 'restore of cdk-4.6.0/cdkscreen.c failed'
  shar_count="`wc -c < 'cdk-4.6.0/cdkscreen.c'`"
  test 43192 -eq "$shar_count" ||
    echo "cdk-4.6.0/cdkscreen.c: original size 43192, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk-4.6.0/binding.c ==============
if test -f 'cdk-4.6.0/binding.c' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk-4.6.0/binding.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk-4.6.0/binding.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk-4.6.0/binding.c' &&
X#include "cdk.h"
X
X/*
X * $Author: glover $
X * $Date: 1995/12/10 19:13:47 $
X * $Revision: 1.16 $
X */
X
X/*
X * This inserts a binding.
X */
Xvoid bindCDKObject (EObjectType cdktype, void *object, chtype key, BINDFN function, void * data)
X{
X   int index	= mapChtype (key);
X
X   /* Since dereferencing a void pointer is a no-no, we have to cast	*/
X   /* our pointer correctly.						*/
X   if (cdktype == vENTRY)
X   {
X      ((CDKENTRY *)object)->bindFunction[index]		= function;
X      ((CDKENTRY *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vMENTRY)
X   {
X      ((CDKMENTRY *)object)->bindFunction[index]	= function;
X      ((CDKMENTRY *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vSCROLL)
X   {
X      ((CDKSCROLL *)object)->bindFunction[index]	= function;
X      ((CDKSCROLL *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vDIALOG)
X   {
X      ((CDKDIALOG *)object)->bindFunction[index]	= function;
X      ((CDKDIALOG *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vSCALE)
X   {
X      ((CDKSCALE *)object)->bindFunction[index]		= function;
X      ((CDKSCALE *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vMENU)
X   {
X      ((CDKMENU *)object)->bindFunction[index]		= function;
X      ((CDKMENU *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vMATRIX)
X   {
X      ((CDKMATRIX *)object)->bindFunction[index]	= function;
X      ((CDKMATRIX *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vSELECTION)
X   {
X      ((CDKSELECTION *)object)->bindFunction[index]	= function;
X      ((CDKSELECTION *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vVIEWER)
X   {
X      ((CDKVIEWER *)object)->bindFunction[index]	= function;
X      ((CDKVIEWER *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vRADIO)
X   {
X      ((CDKRADIO *)object)->bindFunction[index]		= function;
X      ((CDKRADIO *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vTEMPLATE)
X   {
X      ((CDKTEMPLATE *)object)->bindFunction[index]	= function;
X      ((CDKTEMPLATE *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vSWINDOW)
X   {
X      ((CDKSWINDOW *)object)->bindFunction[index]	= function;
X      ((CDKSWINDOW *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      ((CDKITEMLIST *)object)->bindFunction[index]	= function;
X      ((CDKITEMLIST *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vFSELECT)
X   {
X      bindCDKObject (vENTRY, ((CDKFSELECT *)object)->filename, key, function, data);
X      bindCDKObject (vSCROLL, ((CDKFSELECT *)object)->filelist, key, function, data);
X   }
X}
X
X/*
X * This removes a binding on an object.
X */
Xvoid unbindCDKObject (EObjectType cdktype, void *object, chtype key)
X{
X   int index	= mapChtype(key);
X
X   /* Since dereferencing a void pointer is a no-no, we have to cast	*/
X   /* our pointer correctly.						*/
X   if (cdktype == vENTRY)
X   {
X      ((CDKENTRY *)object)->bindFunction[index]		= (BINDFN)NULL;
X      ((CDKENTRY *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vMENTRY)
X   {
X      ((CDKMENTRY *)object)->bindFunction[index]	= (BINDFN)NULL;
X      ((CDKMENTRY *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vSCROLL)
X   {
X      ((CDKSCROLL *)object)->bindFunction[index]	= (BINDFN)NULL;
X      ((CDKSCROLL *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vDIALOG)
X   {
X      ((CDKDIALOG *)object)->bindFunction[index]	= (BINDFN)NULL;
X      ((CDKDIALOG *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vSCALE)
X   {
X      ((CDKSCALE *)object)->bindFunction[index]		= (BINDFN)NULL;
X      ((CDKSCALE *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vMENU)
X   {
X      ((CDKMENU *)object)->bindFunction[index]		= (BINDFN)NULL;
X      ((CDKMENU *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vMATRIX)
X   {
X      ((CDKMATRIX *)object)->bindFunction[index]	= (BINDFN)NULL;
X      ((CDKMATRIX *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vSELECTION)
X   {
X      ((CDKSELECTION *)object)->bindFunction[index]	= (BINDFN)NULL;
X      ((CDKSELECTION *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vVIEWER)
X   {
X      ((CDKVIEWER *)object)->bindFunction[index]	= (BINDFN)NULL;
X      ((CDKVIEWER *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vRADIO)
X   {
X      ((CDKRADIO *)object)->bindFunction[index]		= (BINDFN)NULL;
X      ((CDKRADIO *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vTEMPLATE)
X   {
X      ((CDKTEMPLATE *)object)->bindFunction[index]	= (BINDFN)NULL;
X      ((CDKTEMPLATE *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vSWINDOW)
X   {
X      ((CDKSWINDOW *)object)->bindFunction[index]	= (BINDFN)NULL;
X      ((CDKSWINDOW *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      ((CDKITEMLIST *)object)->bindFunction[index]	= (BINDFN)NULL;
X      ((CDKITEMLIST *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vFSELECT)
X   {
X      unbindCDKObject (vENTRY, ((CDKFSELECT *)object)->filename, key);
X      unbindCDKObject (vSCROLL, ((CDKFSELECT *)object)->filelist, key);
X   }
X}
X
X/*
X * This sets all the bindings for the given objects.
X */
Xvoid cleanCDKObjectBindings (EObjectType cdktype, void *object)
X{
X   /* Since dereferencing a void pointer is a no-no, we have to cast	*/
X   /* our pointer correctly.						*/
X   if (cdktype == vENTRY)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKENTRY *)object)->bindFunction[x]		= (BINDFN)NULL;
X         ((CDKENTRY *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vMENTRY)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKMENTRY *)object)->bindFunction[x]		= (BINDFN)NULL;
X         ((CDKMENTRY *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vSCROLL)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKSCROLL *)object)->bindFunction[x]		= (BINDFN)NULL;
X         ((CDKSCROLL *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vDIALOG)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKDIALOG *)object)->bindFunction[x]		= (BINDFN)NULL;
X         ((CDKDIALOG *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vSCALE)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKSCALE *)object)->bindFunction[x]		= (BINDFN)NULL;
X         ((CDKSCALE *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vMENU)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKMENU *)object)->bindFunction[x]		= (BINDFN)NULL;
X         ((CDKMENU *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vMATRIX)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKMATRIX *)object)->bindFunction[x]		= (BINDFN)NULL;
X         ((CDKMATRIX *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vSELECTION)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKSELECTION *)object)->bindFunction[x]	= (BINDFN)NULL;
X         ((CDKSELECTION *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vVIEWER)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKVIEWER *)object)->bindFunction[x]		= (BINDFN)NULL;
X         ((CDKVIEWER *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vRADIO)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKRADIO *)object)->bindFunction[x]		= (BINDFN)NULL;
X         ((CDKRADIO *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vTEMPLATE)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKTEMPLATE *)object)->bindFunction[x]	= (BINDFN)NULL;
X         ((CDKTEMPLATE *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vSWINDOW)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKSWINDOW *)object)->bindFunction[x]	= (BINDFN)NULL;
X         ((CDKSWINDOW *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKITEMLIST *)object)->bindFunction[x]	= (BINDFN)NULL;
X         ((CDKITEMLIST *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vFSELECT)
X   {
X      cleanCDKObjectBindings (vENTRY, ((CDKFSELECT *)object)->filename);
X      cleanCDKObjectBindings (vSCROLL, ((CDKFSELECT *)object)->filelist);
X   }
X}
X
X/*
X * This checks to see iof the binding for the key exists. If it does then it
X * runs the command and returns a TRUE. If it doesn't it returns a FALSE. This
X * way we can 'overwrite' coded in bindings.
X */
Xint checkCDKObjectBind (EObjectType cdktype, void *object, chtype key)
X{
X   int index	= mapChtype (key);
X
X   /* Since dereferencing a void pointer is a no-no, we have to cast	*/
X   /* our pointer correctly.						*/
X   if (cdktype == vENTRY)
X   {
X      if ( ((CDKENTRY *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= (BINDFN) ((CDKENTRY *)object)->bindFunction[index];
X         void * data		= (void *) ((CDKENTRY *)object)->bindData[index];
X         function (vENTRY, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vMENTRY)
X   {
X      if ( ((CDKMENTRY *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKMENTRY *)object)->bindFunction[index];
X         void * data		= ((CDKMENTRY *)object)->bindData[index];
X         function (vMENTRY, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vSCROLL)
X   {
X      if ( ((CDKSCROLL *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKSCROLL *)object)->bindFunction[index];
X         void * data		= ((CDKSCROLL *)object)->bindData[index];
X         function (vSCROLL, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vDIALOG)
X   {
X      if ( ((CDKDIALOG *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKDIALOG *)object)->bindFunction[index];
X         void * data		= ((CDKDIALOG *)object)->bindData[index];
X         function (vDIALOG, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vSCALE)
X   {
X      if ( ((CDKSCALE *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKSCALE *)object)->bindFunction[index];
X         void * data		= ((CDKSCALE *)object)->bindData[index];
X         function (vSCALE, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vMENU)
X   {
X      if ( ((CDKMENU *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKMENU *)object)->bindFunction[index];
X         void * data		= ((CDKMENU *)object)->bindData[index];
X         function (vMENU, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vMATRIX)
X   {
X      if ( ((CDKMATRIX *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKMATRIX *)object)->bindFunction[index];
X         void * data		= ((CDKMATRIX *)object)->bindData[index];
X         function (vMATRIX, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vSELECTION)
X   {
X      if ( ((CDKSELECTION *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKSELECTION *)object)->bindFunction[index];
X         void * data		= ((CDKSELECTION *)object)->bindData[index];
X         function (vSELECTION, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vVIEWER)
X   {
X      if ( ((CDKVIEWER *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKVIEWER *)object)->bindFunction[index];
X         void * data		= ((CDKVIEWER *)object)->bindData[index];
X         function (vVIEWER, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vRADIO)
X   {
X      if ( ((CDKRADIO *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKRADIO *)object)->bindFunction[index];
X         void * data		= ((CDKRADIO *)object)->bindData[index];
X         function (vRADIO, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vTEMPLATE)
X   {
X      if ( ((CDKTEMPLATE *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKTEMPLATE *)object)->bindFunction[index];
X         void * data		= ((CDKTEMPLATE *)object)->bindData[index];
X         function (vTEMPLATE, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vSWINDOW)
X   {
X      if ( ((CDKSWINDOW *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKSWINDOW *)object)->bindFunction[index];
X         void * data		= ((CDKSWINDOW *)object)->bindData[index];
X         function (vSWINDOW, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      if ( ((CDKITEMLIST *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKITEMLIST *)object)->bindFunction[index];
X         void * data		= ((CDKITEMLIST *)object)->bindData[index];
X         function (vITEMLIST, object, data);
X         return (TRUE);
X      }
X   }
X   return (FALSE);
X}
X
X/*
X * This translates non ascii characters like KEY_UP to an 'equivalent'
X * ascii value.
X */
Xint mapChtype (chtype key)
X{
X   if (key == KEY_UP)
X   {
X       return (257);
X   }
X   else if (key == KEY_DOWN)
X   {
X       return (258);
X   }
X   else if (key == KEY_LEFT)
X   {
X       return (259);
X   }
X   else if (key == KEY_RIGHT)
X   {
X       return (260);
X   }
X   else if (key == KEY_NPAGE)
X   {
X       return (261);
X   }
X   else if (key == KEY_PPAGE)
X   {
X       return (262);
X   }
X   else if (key == KEY_HOME)
X   {
X       return (263);
X   }
X   else if (key == KEY_END)
X   {
X       return (264);
X   }
X   else if (key == KEY_F0)
X   {
X       return (265);
X   }
X   else if (key == KEY_F1)
X   {
X       return (266);
X   }
X   else if (key == KEY_F2)
X   {
X       return (267);
X   }
X   else if (key == KEY_F3)
X   {
X       return (268);
X   }
X   else if (key == KEY_F4)
X   {
X       return (269);
X   }
X   else if (key == KEY_F5)
X   {
X       return (270);
X   }
X   else if (key == KEY_F6)
X   {
X       return (271);
X   }
X   else if (key == KEY_F7)
X   {
X       return (272);
X   }
X   else if (key == KEY_A1)
X   {
X       return (273);
X   }
X   else if (key == KEY_A3)
X   {
X       return (274);
X   }
X   else if (key == KEY_B2)
X   {
X       return (275);
X   }
X   else if (key == KEY_C1)
X   {
X       return (276);
X   }
X   else if (key == KEY_C3)
X   {
X       return (277);
X   }
X   else if (key == KEY_ESC)
X   {
X       return (278);
X   }
X   else 
X   {
X      return ( (char) key );
X   }
X}
SHAR_EOF
  $shar_touch -am 1229121095 'cdk-4.6.0/binding.c' &&
  chmod 0400 'cdk-4.6.0/binding.c' ||
  echo 'restore of cdk-4.6.0/binding.c failed'
  shar_count="`wc -c < 'cdk-4.6.0/binding.c'`"
  test 15040 -eq "$shar_count" ||
    echo "cdk-4.6.0/binding.c: original size 15040, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk-4.6.0/debug.c ==============
if test -f 'cdk-4.6.0/debug.c' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk-4.6.0/debug.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk-4.6.0/debug.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk-4.6.0/debug.c' &&
X#include "cdk.h"
X
X/*
X * $Author: glover $
X * $Date: 1995/12/10 02:12:36 $
X * $Revision: 1.5 $
X */
X
X/*
X * This starts debugging for CDK.
X */
XFILE *startCDKDebug (char *filename)
X{
X   char *defFile	= "cdkdebug.log";
X
X   /* Check if the filename is NULL.		*/
X   if (filename == (char *)NULL)
X   {
X      filename = defFile;
X   }
X
X   /* Try to open the file.			*/
X   return ( fopen (filename, "w") );
X}
X
X/*
X * This writes a message to the debug file.
X */
Xvoid writeCDKDebugMessage (FILE *fd, char *filename, char *function, int line, char *message)
X{
X   /* Print the message as long as the file descr. is not NULL.	*/
X   if (fd != NULL)
X   {
X      fprintf (fd, "%s::%s (Line %d) %s\n", filename, function, line, message);
X   }
X}
X
X/*
X * This turns off the debugging for CDK.
X */
Xvoid stopCDKDebug (FILE *fd)
X{
X   if (fd != NULL)
X   {
X      fclose (fd);
X   }
X}
SHAR_EOF
  $shar_touch -am 1229121095 'cdk-4.6.0/debug.c' &&
  chmod 0400 'cdk-4.6.0/debug.c' ||
  echo 'restore of cdk-4.6.0/debug.c failed'
  shar_count="`wc -c < 'cdk-4.6.0/debug.c'`"
  test 854 -eq "$shar_count" ||
    echo "cdk-4.6.0/debug.c: original size 854, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk-4.6.0/dialog.c ==============
if test -f 'cdk-4.6.0/dialog.c' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk-4.6.0/dialog.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk-4.6.0/dialog.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk-4.6.0/dialog.c' &&
X#include "cdk.h"
X
X/*
X * $Author: glover $
X * $Date: 1995/12/14 06:19:52 $
X * $Revision: 1.20 $
X */
X
X/*
X * This function creates a dialog widget.
X */
XCDKDIALOG *newCDKDialog( CDKSCREEN *cdkscreen, int xplace, int yplace, char **mesg, int rows, char **buttonlabel, int buttonCount, chtype highlight, boolean separator, boolean box, boolean shadow)
X{
X   /* Declare local variables.						*/
X   CDKDIALOG *dialog	= (CDKDIALOG *)malloc (sizeof (CDKDIALOG));
X   int boxWidth		= MINDIALOGWIDTH;
X   int boxHeight	= rows + 3 + separator;
X   int maxmessagewidth	= -1;
X   int buttonwidth	= 0;
X   int xpos		= xplace;
X   int ypos		= yplace;
X   int temp		= 0;
X   int buttonadj	= 0;
X   int x		= 0;
X
X   /* Translate the char * message to a chtype *			*/
X   for (x=0; x < rows; x++)
X   {
X      dialog->info[x]	= char2Chtype (mesg[x], &dialog->infolen[x], &dialog->infopos[x]);
X      maxmessagewidth	= MAX(maxmessagewidth, dialog->infolen[x]);
X   }
X
X   /* Translate the button label char * to a chtype *			*/
X   for (x = 0; x < buttonCount; x++)
X   {
X      dialog->buttonlabel[x]	= char2Chtype (buttonlabel[x], &dialog->buttonlen[x], &temp);
X      buttonwidth		+= dialog->buttonlen[x] + 1;
X   }
X   buttonwidth--;
X
X   /* Determine the final dimensions of the box.			*/
X   boxWidth	= MAX(boxWidth, maxmessagewidth);
X   boxWidth	= MAX(boxWidth, buttonwidth);
X   boxWidth	= boxWidth + 4;
X
X   /* Now we have to readjust the x and y positions			*/
X   alignxy (cdkscreen->window, &xpos, &ypos, boxWidth, boxHeight);
X
X   /* Set up the dialog box attributes.					*/
X   dialog->parent		= cdkscreen->window;
X   dialog->win			= newwin (boxHeight, boxWidth, ypos, xpos);
X   dialog->shadowwin		= (WINDOW *)NULL;
X   dialog->buttonCount		= buttonCount;
X   dialog->currentButton	= 0;
X   dialog->messageRows		= rows;
X   dialog->boxHeight		= boxHeight;
X   dialog->boxWidth		= boxWidth;
X   dialog->highlight		= highlight;
X   dialog->separator		= separator;
X   dialog->box			= box;
X   dialog->shadow		= shadow;
X
X   /* If we couldn't create the window, we should return a NULL value.	*/
X   if (dialog->win == (WINDOW *)NULL)
X   {
X      /* Couldn't create the window. Clean up used memory.		*/
X      for (x=0; x < dialog->messageRows ; x++)
X      {
X         freeChtype (dialog->info[x]);
X      }
X      for (x=0; x < dialog->buttonCount; x++)
X      {
X         freeChtype (dialog->buttonlabel[x]);
X      }
X
X      /* Remove the memory used by the dialog pointer.			*/
X      free (dialog);
X
X      /* Return a NULL dialog box.					*/
X      return ( (CDKDIALOG *)NULL );
X   }
X
X   /* Find the button positions.					*/
X   buttonadj		= ((int)((boxWidth-buttonwidth)/2));
X   for (x = 0; x < buttonCount; x++)
X   {
X      dialog->buttonpos[x]	= buttonadj;
X      buttonadj			= buttonadj + dialog->buttonlen[x] + 1;
X   }
X
X   /* Create the string alignments.					*/
X   for (x=0; x < rows; x++)
X   {
X      dialog->infopos[x]	= justifyString (boxWidth, dialog->infolen[x], dialog->infopos[x]);
X   }
X
X   /* Was there a shadow???						*/
X   if (shadow)
X   {
X      dialog->shadowwin		= newwin (boxHeight, boxWidth, ypos+1, xpos+1);
X   }
X
X   /* Let them use escape keys.						*/
X   keypad (dialog->win, TRUE);
X
X   /* Empty the key bindings.						*/
X   cleanCDKObjectBindings (vDIALOG, dialog);
X
X   /* Register this baby.						*/
X   registerCDKObject (cdkscreen, vDIALOG, dialog);
X
X   /* Return the dialog box pointer.					*/
X   return (dialog);
X}
X
X/*
X * This lets the user select the button.
X */
Xint activateCDKDialog (CDKDIALOG *dialog)
X{
X   /* Declare local variables.						*/
X   int firstbutton	= 0;
X   int lastbutton	= dialog->buttonCount - 1;
X   chtype input		= (chtype)NULL;
X
X   /* Draw the dialog box.						*/
X   drawCDKDialog (dialog, dialog->box);
X
X   /* Lets move to the first button					*/
X   writeChtypeAttrib (dialog->win,
X			dialog->buttonpos[dialog->currentButton],
X			dialog->boxHeight-2,
X			dialog->buttonlabel[dialog->currentButton],
X			dialog->highlight,
X			HORIZONTAL,
X			0, dialog->buttonlen[dialog->currentButton]);
X   wrefresh (dialog->win);
X
X   /* Turn off the cursor.						*/
X   curs_set (0);
X
X   /* Lets start taking the input.					*/
X   for (;;)
X   {
X      input = wgetch (dialog->win);
X
X      /* Check for a key binding...					*/
X      if (! checkCDKObjectBind (vDIALOG, dialog, input))
X      {
X         switch (input)
X         {
X            case KEY_LEFT :
X                 dialog->currentButton	= (dialog->currentButton == firstbutton ? lastbutton : dialog->currentButton-1);
X                 break;
X
X            case KEY_RIGHT : case KEY_TAB : case ' ' :
X                 dialog->currentButton	= (dialog->currentButton == lastbutton ? firstbutton : dialog->currentButton+1);
X                 break;
X
X            case KEY_UP : case KEY_DOWN :
X                 Beep();
X                 break;
X
X            case CDK_REFRESH :
X                 refreshCDKScreen (dialog->screen);
X                 break;
X
X            case KEY_RETURN : case CDK_NEXT :
X                 curs_set(1);
X                 return (dialog->currentButton);
X                 break;
X
X         default :
X            break;
X         }
X      }
X
X      /* Redraw the buttons.						*/
X      redrawCDKDialogButtons (dialog);
X      wrefresh (dialog->win);
X   }
X}
X
X/*
X * This function draws the dialog widget.
X */
Xvoid drawCDKDialog (CDKDIALOG *dialog, boolean Box)
X{
X   /* Declare local variables.						*/
X   int x	= 0;
X
X   /* Erase the dialog widget from the screen.				*/
X   eraseCDKDialog (dialog);
X
X   /* Is there a shadow???						*/
X   if (dialog->shadow)
X   {
X      drawShadow (dialog->shadowwin);
X   }
X
X   /* Box the widget if they asked.					*/
X   if (Box)
X   {
X      box (dialog->win, ACS_VLINE, ACS_HLINE);
X   }
X
X   /* Draw in the message.						*/
X   for (x=0; x < dialog->messageRows; x++)
X   {
X      writeChtype (dialog->win,
X			dialog->infopos[x],
X			x+1,
X			dialog->info[x],
X			HORIZONTAL,
X			0, dialog->infolen[x]);
X   }
X
X   /* Draw in the buttons.						*/
X   redrawCDKDialogButtons (dialog);
X   wrefresh (dialog->win);
X}
X
X/*
X * This function destroys the dialog widget.
X */
Xvoid destroyCDKDialog (CDKDIALOG *dialog)
X{
X   /* Declare local variables.						*/
X   int x	= 0;
X
X   /* Erase the object.							*/
X   eraseCDKDialog (dialog);
X
X   /* Clean up the char pointers.					*/
X   for (x=0; x < dialog->messageRows ; x++)
X   {
X      freeChtype (dialog->info[x]);
X   }
X   for (x=0; x < dialog->buttonCount; x++)
X   {
X      freeChtype (dialog->buttonlabel[x]);
X   }
X
X   /* Clean up the windows.						*/
X   delwin (dialog->win);
X   if (dialog->shadow)
X   {
X      delwin (dialog->shadowwin);
X   }
X
X   /* Unregister this object.						*/
X   unregisterCDKObject (vDIALOG, dialog);
X
X   /* Finish cleaning up.						*/
X   free (dialog);
X}
X
X/*
X * This function erases the dialog widget from the screen.
X */
Xvoid eraseCDKDialog (CDKDIALOG *dialog)
X{
X   /* Erase the main window.						*/
X   werase (dialog->win);
X   wrefresh (dialog->win);
X
X   /* Do we need to erase the shadow???					*/
X   if (dialog->shadow)
X   {
X      werase (dialog->shadowwin);
X      wrefresh (dialog->shadowwin);
X   }
X}
X
X/*
X * This sets attributes of the dialog box.
X */
Xvoid setCDKDialog (CDKDIALOG *dialog, chtype highlight, boolean separator, boolean box)
X{
X   dialog->highlight	= highlight;
X   dialog->separator	= separator;
X   dialog->box		= box;
X}
X
X/*
X * This redraws the dialog buttons and trhe separation line.
X */
Xvoid redrawCDKDialogButtons (CDKDIALOG *dialog)
X{
X   /* Declare local variables.						*/
X   int x;
X
X   for (x=0; x < dialog->buttonCount; x++)
X   {
X      writeChtype (dialog->win,
X			dialog->buttonpos[x],
X			dialog->boxHeight-2,
X			dialog->buttonlabel[x],
X			HORIZONTAL,
X			0, dialog->buttonlen[x]);
X   }
X   writeChtypeAttrib (dialog->win,
X		dialog->buttonpos[dialog->currentButton],
X		dialog->boxHeight-2,
X		dialog->buttonlabel[dialog->currentButton],
X		dialog->highlight,
X		HORIZONTAL,
X		0, dialog->buttonlen[dialog->currentButton]);
X
X   /* Draw the separation line.						*/
X   if (dialog->separator)
X   {
X      for (x=1; x < dialog->boxWidth-1; x++)
X      {
X         mvwaddch (dialog->win, dialog->boxHeight-3, x, ACS_HLINE);
X      }
X      mvwaddch (dialog->win, dialog->boxHeight-3, 0, ACS_LTEE);
X      mvwaddch (dialog->win, dialog->boxHeight-3, dialog->win->_maxx, ACS_RTEE);
X   }
X}
SHAR_EOF
  $shar_touch -am 1229121095 'cdk-4.6.0/dialog.c' &&
  chmod 0400 'cdk-4.6.0/dialog.c' ||
  echo 'restore of cdk-4.6.0/dialog.c failed'
  shar_count="`wc -c < 'cdk-4.6.0/dialog.c'`"
  test 8211 -eq "$shar_count" ||
    echo "cdk-4.6.0/dialog.c: original size 8211, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk-4.6.0/draw.c ==============
if test -f 'cdk-4.6.0/draw.c' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk-4.6.0/draw.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk-4.6.0/draw.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk-4.6.0/draw.c' &&
X#include "cdk.h"
X
X/*
X * $Author: glover $
X * $Date: 1995/12/16 17:23:24 $
X * $Revision: 1.13 $
X */
X
X/*
X * This sets up a basic set of color pairs. These can be redefined
X * if wanted...
X */
Xvoid initCDKColor ()
X{
X#ifdef COLOR
X   /* Declare local variables.					*/
X   int color[]	= {
X			COLOR_WHITE,	COLOR_RED,	COLOR_GREEN,
X			COLOR_YELLOW,	COLOR_BLUE,	COLOR_MAGENTA,
X			COLOR_CYAN,	COLOR_BLACK
X		};
X   int pair	= 1;
X   int x, y;
X
X   /* Start color first.					*/
X   start_color();
X  
X   /* Create the color pairs.					*/
X   for (x=0; x < 8; x++)
X   {
X      for (y=0; y < 8; y++)
X      {
X         init_pair (pair++, color[x], color[y]);
X      }
X   }
X#endif
X}
X
X/*
X * This prints out a box around a window with attributes
X */
Xvoid boxWindow (WINDOW *window, chtype attr)
X{
X   /* Set some variables.					*/
X   int tlx	= 0;
X   int tly	= 0;
X   int brx	= window->_maxx - 1;
X   int bry	= window->_maxy;
X   int x, y;
X
X   /* Draw horizontal lines 					*/
X   for (x=tlx; x<=brx;x++) 
X   {
X       mvwaddch(window, tly, x, ACS_HLINE | attr);
X       mvwaddch(window, bry, x, ACS_HLINE | attr);
X    }
X
X   /* Draw vertical lines 					*/
X   for (y=tly; y<=bry;y++) 
X   {
X       mvwaddch(window, y, tlx, ACS_VLINE | attr);
X       mvwaddch(window, y, brx, ACS_VLINE | attr);
X    }
X
X   /* Draw in the corners */
X   mvwaddch(window, tly, tlx, ACS_ULCORNER | attr);
X   mvwaddch(window, tly, brx, ACS_URCORNER | attr);
X   mvwaddch(window, bry, tlx, ACS_LLCORNER | attr);
X   mvwaddch(window, bry, brx, ACS_LRCORNER | attr);
X   wrefresh(window);
X}
X
X/*
X * This draws a box with attributes and lets the user define
X * each element of the box.
X */
Xvoid attrbox (WINDOW *win, chtype tlc, chtype trc, chtype blc, chtype brc, chtype horz, chtype vert, chtype attr)
X{
X   /* Set the coordinates.	*/
X   int x1		= 0;
X   int y1		= 0;
X#ifdef COLOR
X   int y2		= win->_maxy;
X   int x2		= win->_maxx;
X#else
X   int y2		= win->_maxy - 1;
X   int x2		= win->_maxx - 1;
X#endif
X   int x, y;
X
X   /* Draw horizontal lines.	*/
X   for (x=x1; x<=x2;x++) 
X   {
X       mvwaddch(win, y1, x, horz | attr);
X       mvwaddch(win, y2, x, horz | attr);
X    }
X
X   /* Draw vertical lines.	*/
X   for (y=y1; y<=y2;y++) 
X   {
X       mvwaddch(win, y, x1, vert | attr);
X       mvwaddch(win, y, x2, vert | attr);
X    }
X
X   /* Draw in the corners.	*/
X   mvwaddch(win, y1, x1, tlc | attr);
X   mvwaddch(win, y1, x2, trc | attr);
X   mvwaddch(win, y2, x1, blc | attr);
X   mvwaddch(win, y2, x2, brc | attr);
X   wrefresh(win);
X}
X
X/*
X * This draws a line on the given window. (odd angle lines not working yet)
X */
Xvoid drawLine  (WINDOW *window, int startx, int starty, int endx, int endy, chtype line)
X{
X   /* De=clare some local vars.	*/
X   int xdiff	= endx - startx;
X   int ydiff	= endy - starty;
X   int x	= 0;
X   int y	= 0;
X
X   /* Determine if we are drawing a horizontal or vertical line.	*/
X   if ( ydiff == 0)
X   {
X      /* Horizontal line.      <--------- X -------->			*/
X      for (x=0; x < xdiff ; x++)
X      {
X         mvwaddch (window, starty, startx + x, line);
X      }
X   }
X   else if (xdiff == 0)
X   {
X      /* Vertical line.							*/
X      for (y=0; y < ydiff ; y++)
X      {
X         mvwaddch (window, starty + y, startx, line);
X      }
X   }
X   else
X   {
X      /* We need to determine the angle of the line.	*/
X      int height	= xdiff;
X      int width		= ydiff;
X      int xratio	= (height > width ? 1 : (width / height));
X      int yratio	= (width > height ? (width / height) : 1);
X      int xadj		= 0;
X      int yadj		= 0;
X  
X      /* Set the vars.	*/
X      x	= startx;
X      y	= starty;
X      while (x != endx && y != endy)
X      {
X
X         /* Add the char to the window.		*/
X         mvwaddch (window, y, x, line);
X
X         /* Make the x and y adjustments.	*/
X         if (xadj != xratio)
X         {
X            x	= (xdiff < 0 ? x-1 : x+1);
X            xadj++;
X         }
X         else
X         {
X            xadj	= 0;
X         }
X         if (yadj != yratio)
X         {
X            y	= (ydiff < 0 ? y-1 : y+1);
X            yadj++;
X         }
X         else
X         {
X            yadj	= 0;
X         }
X      }
X   }
X}
X
X/*
X * This draws a shadow around a window.
X */
Xvoid drawShadow (WINDOW *shadowwin)
X{
X   /* Declare local variables.					*/
X   int x		= 0;
X
X   /* Draw the line on the bottom.				*/
X   for (x=1; x <= shadowwin->_maxx; x++)
X   {
X      mvwaddch (shadowwin, shadowwin->_maxy, x, ACS_HLINE | A_DIM);
X   }
X
X   /* Draw the line on the right.				*/
X   for (x=0; x < shadowwin->_maxy; x++)
X   {
X      mvwaddch (shadowwin, x, shadowwin->_maxx, ACS_VLINE |A_DIM);
X   }
X   mvwaddch (shadowwin, 0, shadowwin->_maxx, ACS_URCORNER | A_DIM);
X   mvwaddch (shadowwin, shadowwin->_maxy, 0, ACS_LLCORNER | A_DIM);
X   mvwaddch (shadowwin, shadowwin->_maxy, shadowwin->_maxx, ACS_LRCORNER | A_DIM);
X   wrefresh (shadowwin);
X}
X
X/*
X * This writes out a char * string with no attributes.
X */
Xvoid writeChar (WINDOW *window, int xpos, int ypos, char *string, int align, int start, int end)
X{
X   /* Declare local variables.					*/
X   int display		= end - start;
X   int x		= 0;
X
X   /* Check the alignment of the message.			*/
X   if (align == HORIZONTAL)
X   { 
X      display		= MIN(display,window->_maxx-1);
X      for (x=0; x < display ; x++)
X      {
X         /* Draw the message on a horizontal axis.		*/
X         mvwaddch (window, ypos, xpos+x, string[x+start] | A_NORMAL);
X      }
X   }
X   else
X   {
X      /* Draw the message on a vertical axis.			*/
X      display		= MIN(display,window->_maxy-1);
X      for (x=0; x < display ; x++)
X      {
X         mvwaddch (window, ypos+x, xpos, string[x+start] | A_NORMAL);
X      }
X   }
X}
X
X/*
X * This writes out a char * string with attributes.
X */
Xvoid writeCharAttrib (WINDOW *window, int xpos, int ypos, char *string, chtype attr, int align, int start, int end)
X{
X   /* Declare local variables.					*/
X   int display		= end - start;
X   int x		= 0;
X
X   /* Check the alignment of the message.			*/
X   if (align == HORIZONTAL)
X   { 
X      /* Draw the message on a horizontal axis.			*/
X      display		= MIN(display,window->_maxx-1);
X      for (x=0; x < display ; x++)
X      {
X         mvwaddch (window, ypos, xpos+x, string[x+start] | attr);
X      }
X   }
X   else
X   {
X      /* Draw the message on a vertical axis.			*/
X      display		= MIN(display,window->_maxy-1);
X      for (x=0; x < display ; x++)
X      {
X         mvwaddch (window, ypos+x, xpos, string[x+start] | attr);
X      }
X   }
X}
X
X/*
X * This writes out a chtype * string.
X */
Xvoid writeChtype (WINDOW *window, int xpos, int ypos, chtype *string, int align, int start, int end)
X{
X   /* Declare local variables.					*/
X   int diff		= 0;
X   int display		= 0;
X   int x		= 0;
X
X   /* Determine how much we need to display.			*/
X   if ( end >= start)
X   {
X      diff	= end - start;
X   }
X
X   /* Check the alignment of the message.			*/
X   if (align == HORIZONTAL)
X   {
X      /* Draw the message on a horizontal axis. 		*/
X      display		= MIN(diff,window->_maxx-1);
X      for (x=0; x < display; x++)
X      {
X         mvwaddch (window, ypos, xpos+x, string[x+start]);
X      }
X   }
X   else
X   {
X      /* Draw the message on a vertical axis.			*/
X      display		= MIN(diff,window->_maxy-1);
X      for (x=0; x < display; x++)
X      {
X         mvwaddch (window, ypos+x, xpos, string[x+start]);
X      }
X   }
X}
X
X/*
X * This writes out a chtype * string forcing the chtype string
X * to be printed out with the given attributes instead.
X */
Xvoid writeChtypeAttrib (WINDOW *window, int xpos, int ypos, chtype *string, chtype attr, int align, int start, int end)
X{
X   /* Declare local variables.					*/
X   int diff		= 0;
X   int display		= 0;
X   int x		= 0;
X   chtype plain;
X
X   /* Determine how much we need to display.			*/
X   if ( end >= start)
X   {
X      diff	= end - start;
X   }
X
X   /* Check the alignment of the message.			*/
X   if (align == HORIZONTAL)
X   {
X      /* Draw the message on a horizontal axis. 		*/
X      display		= MIN(diff,window->_maxx-1);
X      for (x=0; x < display; x++)
X      {
X         plain	= string[x+start] & A_CHARTEXT;
X         mvwaddch (window, ypos, xpos+x, plain | attr);
X      }
X   }
X   else
X   {
X      /* Draw the message on a vertical axis.			*/
X      display		= MIN(diff,window->_maxy-1);
X      for (x=0; x < display; x++)
X      {
X         plain	= string[x+start] & A_CHARTEXT;
X         mvwaddch (window, ypos+x, xpos, plain | attr);
X      }
X   }
X}
X
X/*
X * This pops up a message.
X */
Xvoid popUpMessage (CDKSCREEN *screen, char **mesg, int count)
X{
X   /* Declare local variables.					*/
X   CDKLABEL	*popup;
X
X   /* Create the label.						*/
X   popup	= newCDKLabel (screen, CENTER, CENTER,
X		mesg, count, TRUE, FALSE);
X
X   /* Draw it... wait ... kill it.				*/
X   drawCDKLabel (popup, TRUE);
X   wgetch (popup->win);
X   destroyCDKLabel (popup);
X
X   /* Clean the screen.						*/
X   refreshCDKScreen (screen);
X}
SHAR_EOF
  $shar_touch -am 1229121095 'cdk-4.6.0/draw.c' &&
  chmod 0400 'cdk-4.6.0/draw.c' ||
  echo 'restore of cdk-4.6.0/draw.c failed'
  shar_count="`wc -c < 'cdk-4.6.0/draw.c'`"
  test 8755 -eq "$shar_count" ||
    echo "cdk-4.6.0/draw.c: original size 8755, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk-4.6.0/entry.c ==============
if test -f 'cdk-4.6.0/entry.c' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk-4.6.0/entry.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk-4.6.0/entry.c (binary)'
  sed 's/^X//' << 'SHAR_EOF' > _sharuue.tmp &&
Xbegin 600 cdk-4.6.0/entry.c
XM(VEN8VQU9&4@(F-D:RYH(@H*+RH*("H@)$%U=&AO<CH@;6EK96<@)`H@*B`D
XM1&%T93H@,3DY-2\Q,B\Q-"`Q-3HT-3HT-"`D"B`J("12979I<VEO;CH@,2XX
XM-"`D"B`J+PH*+RH*("H@5&AI<R!C<F5A=&5S(&$@<&]I;G1E<B!T;R!A;B!E
XM;G1R>2!W:61G970N"B`J+PI#1$M%3E1262`J;F5W0T1+16YT<GD@*$-$2U-#
XM4D5%3B`J8V1K<V-R965N+"!I;G0@>'!L86-E+"!I;G0@>7!L86-E+"!I;G0@
XM;'!L86-E+"!C:&%R("IL86)E;"P@8VAT>7!E(&9I96QD871T<BP@8VAT>7!E
XM(&9I;&QE<BP@141I<W!L87E4>7!E(&1I<W!T>7!E+"!I;G0@9FEE;&17:61T
XM:"P@:6YT(&UI;BP@:6YT(&UA>"P@14Y44EE#0B!E;G1R>4-A;&Q"86-K+"!B
XM;V]L96%N(&)O>"P@8F]O;&5A;B!S:&%D;W<I"GL*("`@+RH@4V5T('5P('-O
XM;64@=F%R:6%B;&5S+@D)"0D)"2HO"B`@($-$2T5.5%)9("IE;G1R>0D]("A#
XM1$M%3E1262`J*6UA;&QO8R`H<VEZ96]F("A#1$M%3E1262DI.PH@("!C:&%R
XM("IP;&%I;FQA8F5L"3T@*&-H87(@*BE.54Q,.PH@("!I;G0@8F]X=VED=&@)
XM"3T@,#L*("`@:6YT(&)O>&AE:6=H=`D](#,["B`@(&EN="!X<&]S"0D]('AP
XM;&%C93L*("`@:6YT('EP;W,)"3T@>7!L86-E.PH@("!I;G0@;&%B96QX;V9F
XM<V5T"3T@,#L*("`@:6YT(&QA8F5L>6]F9G-E=`D](#`["B`@(&EN="!F:65L
XM9'AO9F9S970)/2`P.PH@("!I;G0@9FEE;&1Y;V9F<V5T"3T@,#L*("`@:6YT
XM('1E;7`)"3T@,#L*"B`@("\J(%1R86YS;&%T92!T:&4@;&%B96P@8VAA<B`J
XM<&]I;G1E<B!T;R!A(&-H='EP92!P;VEN=&5R+@D)*B\*("`@96YT<GDM/FQA
XM8F5L"0D](&-H87(R0VAT>7!E("AL86)E;"P@)F5N=')Y+3YL86)E;&QE;BP@
XM)G1E;7`I.PH@("!P;&%I;FQA8F5L"0D](&-H='EP93)#:&%R("AE;G1R>2T^
XM;&%B96PI.PH*("`@+RH@061J=7-T('1H92!O9F9S970@=F%L=65S(&=I=F5N
XM('1H92!L;V-A=&EO;B!O9B!T:&4@;&%B96PN"0DJ+PH@("!A;&EG;FQA8F5L
XM("AP;&%I;FQA8F5L+"!L<&QA8V4L(&9I96QD5VED=&@L("9B;WAW:61T:"P@
XM)F)O>&AE:6=H="P@)FQA8F5L>&]F9G-E="P@)FQA8F5L>6]F9G-E="P@)F9I
XM96QD>&]F9G-E="P@)F9I96QD>6]F9G-E="D["B`@(&9R965#:&%R("AP;&%I
XM;FQA8F5L*3L*("`@"B`@("\J(%)E:G5S=&EF>2!T:&4@>"!A;F0@>2!P;W-I
XM=&EO;G,@:68@=V4@;F5E9"!T;RX)"0DJ+PH@("!A;&EG;GAY("AC9&MS8W)E
XM96XM/G=I;F1O=RP@)GAP;W,L("9Y<&]S+"!B;WAW:61T:"P@8F]X:&5I9VAT
XM*3L*"B`@("\J($UA:V4@=&AE(&QA8F5L('=I;F1O=RX)"0D)"0DJ+PH@("!E
XM;G1R>2T^=VEN(#T@;F5W=VEN("AB;WAH96EG:'0L(&)O>'=I9'1H+"!Y<&]S
XM+"!X<&]S*3L*"B`@("\J($ES('1H92!W:6YD;W<@3E5,3"`_/S\)"0D)"0DJ
XM+PH@("!I9B`H96YT<GDM/G=I;B`]/2`H5TE.1$]7("HI3E5,3"D*("`@>PH@
XM("`@("`O*B!#;&5A;B!U<"!T:&4@<&]I;G1E<G,N"0D)"0D)*B\*("`@("`@
XM9G)E94-H='EP92`H96YT<GDM/FQA8F5L*3L*("`@("`@9G)E92`H96YT<GDI
XM.PH@("`@("`*("`@("`@+RH@17AI="!W:71H($Y53$PN"0D)"0D)*B\*("`@
XM("`@<F5T=7)N("@@*$-$2T5.5%)9("HI3E5,3"`I.PH@("!]"@H@("`O*B!-
XM86ME('1H92!F:65L9"!W:6YD;W<N"0D)"0D)*B\*("`@96YT<GDM/F9I96QD
XM"0D]('-U8G=I;B`H8V1K<V-R965N+3YW:6YD;W<L(#$L(&9I96QD5VED=&@L
XM('EP;W,K9FEE;&1Y;V9F<V5T+"!X<&]S*V9I96QD>&]F9G-E="D["B`@(&5N
XM=')Y+3YL86)E;'=I;@D]('-U8G=I;B`H8V1K<V-R965N+3YW:6YD;W<L(#$L
XM(&5N=')Y+3YL86)E;&QE;BLQ+"!Y<&]S*VQA8F5L>6]F9G-E="P@>'!O<RML
XM86)E;'AO9F9S970I.PH@("!K97EP860@*&5N=')Y+3YF:65L9"P@5%)512D[
XM"@H@("`O*B!-86ME(')O;VT@9F]R('1H92!I;F9O(&-H87(@*B!P;VEN=&5R
XM+@D)"0DJ+PH@("!E;G1R>2T^:6YF;PD)/2`H8VAA<B`J*6UA;&QO8R`H<VEZ
XM96]F*&-H87(I("H@*&UA>"LS*2D["B`@(&-L96%N0VAA<B`H96YT<GDM/FEN
XM9F\L(&UA>"LS+"`G7#`G*3L*"B`@("\J(%-E="!U<"!T:&4@<F5S="!O9B!T
XM:&4@<W1R=6-T=7)E+@D)"0D)*B\*("`@96YT<GDM/G!A<F5N=`D](&-D:W-C
XM<F5E;BT^=VEN9&]W.PH@("!E;G1R>2T^<VAA9&]W=VEN"3T@*%=)3D1/5R`J
XM*4Y53$P["B`@(&5N=')Y+3YT;W1A;'=I9'1H"3T@,#L*("`@96YT<GDM/F9I
XM96QD871T<@D](&9I96QD871T<CL*("`@96YT<GDM/F9I96QD=VED=&@)/2!F
XM:65L9%=I9'1H.PH@("!E;G1R>2T^9FEL;&5R"3T@9FEL;&5R.PH@("!E;G1R
XM>2T^8F]X"0D](&)O>#L*("`@96YT<GDM/G-H861O=PD]('-H861O=SL*("`@
XM96YT<GDM/G-C<F5E;F-O;`D](#`["B`@(&5N=')Y+3YL969T8VAA<@D](#`[
XM"B`@(&5N=')Y+3YM:6X)"3T@;6EN.PH@("!E;G1R>2T^;6%X"0D](&UA>#L*
XM("`@96YT<GDM/F1I<W!T>7!E"3T@9&ES<'1Y<&4["B`@(&5N=')Y+3YC86QL
XM8F%C:V9N"3T@*'9O:60@*BEE;G1R>4-A;&Q"86-K.PH*("`@+RH@1&\@=V4@
XM=V%N="!A('-H861O=S\_/PD)"0D)"2HO"B`@(&EF("AS:&%D;W<I"B`@('L*
XM("`@("`@96YT<GDM/G-H861O=W=I;B`](&YE=W=I;B`H8F]X:&5I9VAT+"!B
XM;WAW:61T:"P@>7!O<RLQ+"!X<&]S*S$I.PH@("!]"@H@("`O*B!#;&5A;B!T
XM:&4@:V5Y(&)I;F1I;F=S+@D)"0D)"2HO"B`@(&-L96%N0T1+3V)J96-T0FEN
XM9&EN9W,@*'9%3E1262P@96YT<GDI.PH*("`@+RH@4F5G:7-T97(@=&AI<R!B
XM86)Y+B`@("`@("`@("`@("`@(`D)"0DJ+PH@("!R96=I<W1E<D-$2T]B:F5C
XM="`H8V1K<V-R965N+"!V14Y44EDL(&5N=')Y*3L*"B`@("\J(%)E='5R;B!T
XM:&4@<&]I;G1E<B!T;R!T:&4@<W1R=6-T=7)E"0D)"2HO"B`@(')E='5R;B`H
XM96YT<GDI.PI]"@HO*B`*("H@5&AI<R!M96%N<R!Y;W4@=V%N="!T;R!U<V4@
XM=&AE(&=I=F5N(&5N=')Y(&9I96QD+B!)="!T86ME<R!I;G!U=`H@*B!F<F]M
XM('1H92!K97EB;V%R9"P@86YD('=H96X@:71S(&1O;F4L(&ET(&9I;&QS('1H
XM92!E;G1R>2!I;F9O"B`J(&5L96UE;G0@;V8@=&AE('-T<G5C='5R92!W:71H
XM('=H870@=V%S('1Y<&5D+@H@*B\*8VAA<B`J86-T:79A=&5#1$M%;G1R>2`H
XM0T1+14Y44ED@*F5N=')Y*0I["B`@("\J($1E8VQA<F4@;&]C86P@=F%R:6%B
XM;&5S+@D)"0D)"2HO"B`@(&EN="!T96UP"0D](#`["B`@(&EN="!X"0D](#`[
XM"B`@(&-H='EP92!I;G!U=#L*"B`@("\J($%D9"!T:&4@9FEL;&5R(&-H87)A
XM8W1E<B!O;B!T:&4@96YD(&]F('1H92!I;F9O+@D)"2HO"B`@(&5N=')Y+3YI
XM;F9O6RAI;G0I<W1R;&5N*&5N=')Y+3YI;F9O*5T@/2!E;G1R>2T^9FEL;&5R
XM.PH*("`@+RH@1')A=R!T:&4@=VED9V5T+@D)"0D)"0DJ+PH@("!D<F%W0T1+
XM16YT<GD@*&5N=')Y+"!E;G1R>2T^8F]X*3L*"B`@("\J($QE=',@9V5T('1H
XM92!T>7!E9"!I;F9O+@D)"0D)"2HO"B`@(&9O<B`H.SLI"B`@('L*("`@("`@
XM+RH@1V5T('1H92!I;G!U="!F<F]M('1H92!U<V5R+@D)"0D)*B\*("`@("`@
XM:6YP=70@/2!W9V5T8V@@*&5N=')Y+3YF:65L9"D["@H@("`@("`O*B!#:&5C
XM:R!A('!R961E9FEN960@8FEN9&EN9RXN+@D)"0D)*B\*("`@("`@:68@*"`A
XM(&-H96-K0T1+3V)J96-T0FEN9"`H=D5.5%)9+"!E;G1R>2P@:6YP=70I("D*
XM("`@("`@>PH@("`@("`@("!S=VET8V@@*&EN<'5T*0H@("`@("`@("!["B`@
XM("`@("`@("`@(&-A<V4@2T597U50(#H@8V%S92!+15E?1$]73B`Z"B`@("`@
XM("`@("`@("`@("`@0F5E<"@I.PH@("`@("`@("`@("`@("`@(&)R96%K.PH@
XM("`*("`@("`@("`@("`@8V%S92!+15E?3$5&5"`Z"B`@("`@("`@("`@("`@
XM("`@:68@*&5N=')Y+3YS8W)E96YC;VP@/3T@,"D*("`@("`@("`@("`@("`@
XM("!["B`@("`@("`@("`@("`@("`@("`@:68@*&5N=')Y+3YL969T8VAA<B`]
XM/2`P*0H@("`@("`@("`@("`@("`@("`@('L*("`@("`@("`@("`@("`@("`@
XM("`@("!"965P*"D["B`@("`@("`@("`@("`@("`@("`@?0H@("`@("`@("`@
XM("`@("`@("`@(&5L<V4*("`@("`@("`@("`@("`@("`@("!["B`@("`@("`@
XM("`@("`@("`@("`@("`@+RH@4V-R;VQL(&QE9G0N"2HO"B`@("`@("`@("`@
XM("`@("`@("`@("`@96YT<GDM/FQE9G1C:&%R+2T["B`@("`@("`@("`@("`@
XM("`@("`@("`@=&5M<"`]("AI;G0I<W1R;&5N*&5N=')Y+3YI;F9O*3L*("`@
XM("`@("`@("`@("`@("`@("`@("!F;W(@*'@],#L@>"`\('1E;7`[('@K*RD*
XM("`@("`@("`@("`@("`@("`@("`@("!["B`@("`@("`@("`@("`@("`@("`@
XM("`@("`@:68@*"`H96YT<GDM/FQE9G1C:&%R("L@>"D@/"!T96UP*0H@("`@
XM("`@("`@("`@("`@("`@("`@("`@('L*("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("!M=G=A9&1C:"`H96YT<GDM/F9I96QD+"`P+"!X+"!E;G1R>2T^
XM:6YF;UME;G1R>2T^;&5F=&-H87(K>%T@?"!E;G1R>2T^9FEE;&1A='1R*3L*
XM("`@("`@("`@("`@("`@("`@("`@("`@("!]"B`@("`@("`@("`@("`@("`@
XM("`@("`@("`@96QS90H@("`@("`@("`@("`@("`@("`@("`@("`@('L*("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("!M=G=A9&1C:"`H96YT<GDM/F9I
XM96QD+"`P+"!X+"!E;G1R>2T^9FEL;&5R*3L*("`@("`@("`@("`@("`@("`@
XM("`@("`@("!]"B`@("`@("`@("`@("`@("`@("`@("`@?0H@("`@("`@("`@
XM("`@("`@("`@("`@('=M;W9E("AE;G1R>2T^9FEE;&0L(#`L(#`I.PH@("`@
XM("`@("`@("`@("`@("`@("`@('=R969R97-H("AE;G1R>2T^9FEE;&0I.PH@
XM("`@("`@("`@("`@("`@("`@('T*("`@("`@("`@("`@("`@("!]"B`@("`@
XM("`@("`@("`@("`@96QS90H@("`@("`@("`@("`@("`@('L*("`@("`@("`@
XM("`@("`@("`@("`O*B!-;W9E(&QE9G0N"2HO"B`@("`@("`@("`@("`@("`@
XM("`@=VUO=F4@*&5N=')Y+3YF:65L9"P@,"P@+2UE;G1R>2T^<V-R965N8V]L
XM*3L*("`@("`@("`@("`@("`@("`@("!W<F5F<F5S:"`H96YT<GDM/F9I96QD
XM*3L*("`@("`@("`@("`@("`@("!]"B`@("`@("`@("`@("`@("`@8G)E86L[
XM"B`@(`H@("`@("`@("`@("!C87-E($M%65]224=(5"`Z"B`@("`@("`@("`@
XM("`@("`@:68@*&5N=')Y+3YS8W)E96YC;VP@/3T@96YT<GDM/F9I96QD=VED
XM=&@M,2D*("`@("`@("`@("`@("`@("!["B`@("`@("`@("`@("`@("`@("`@
XM=&5M<"`]("AI;G0I<W1R;&5N("AE;G1R>2T^:6YF;RD["B`@("`@("`@("`@
XM("`@("`@("`@:68@*"`H96YT<GDM/FQE9G1C:&%R("L@96YT<GDM/G-C<F5E
XM;F-O;"LQ*2`]/2!T96UP*0H@("`@("`@("`@("`@("`@("`@('L*("`@("`@
XM("`@("`@("`@("`@("`@("!"965P*"D["B`@("`@("`@("`@("`@("`@("`@
XM?0H@("`@("`@("`@("`@("`@("`@(&5L<V4*("`@("`@("`@("`@("`@("`@
XM("!["B`@("`@("`@("`@("`@("`@("`@("`@+RH@4V-R;VQL('1O('1H92!R
XM:6=H=`D)"0DJ+PH@("`@("`@("`@("`@("`@("`@("`@(&5N=')Y+3YL969T
XM8VAA<BLK.PH@("`@("`@("`@("`@("`@("`@("`@('1E;7`@/2`H:6YT*7-T
XM<FQE;BAE;G1R>2T^:6YF;RD["B`@("`@("`@("`@("`@("`@("`@("`@9F]R
XM("AX/3`[('@@/"!T96UP.R!X*RLI"B`@("`@("`@("`@("`@("`@("`@("`@
XM>PH@("`@("`@("`@("`@("`@("`@("`@("`@(&EF("@@*&5N=')Y+3YL969T
XM8VAA<B`K('@I(#P@=&5M<"D*("`@("`@("`@("`@("`@("`@("`@("`@("![
XM"B`@("`@("`@("`@("`@("`@("`@("`@("`@("`@;79W861D8V@@*&5N=')Y
XM+3YF:65L9"P@,"P@>"P@96YT<GDM/FEN9F];96YT<GDM/FQE9G1C:&%R*WA=
XM('P@96YT<GDM/F9I96QD871T<BD["B`@("`@("`@("`@("`@("`@("`@("`@
XM("`@?0H@("`@("`@("`@("`@("`@("`@("`@("`@(&5L<V4*("`@("`@("`@
XM("`@("`@("`@("`@("`@("!["B`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@;79W861D8V@@*&5N=')Y+3YF:65L9"P@,"P@96YT<GDM/FQE9G1C:&%R
XM("L@>"P@96YT<GDM/F9I;&QE<BD["B`@("`@("`@("`@("`@("`@("`@("`@
XM("`@?0H@("`@("`@("`@("`@("`@("`@("`@('T*("`@("`@("`@("`@("`@
XM("`@("`@("!W;6]V92`H96YT<GDM/F9I96QD+"`P+"!E;G1R>2T^<V-R965N
XM8V]L*3L*("`@("`@("`@("`@("`@("`@("`@("!W<F5F<F5S:"`H96YT<GDM
XM/F9I96QD*3L*("`@("`@("`@("`@("`@("`@("!]"B`@("`@("`@("`@("`@
XM("`@?0H@("`@("`@("`@("`@("`@(&5L<V4*("`@("`@("`@("`@("`@("![
XM"B`@("`@("`@("`@("`@("`@("`@+RH@36]V92!R:6=H="X)"0D)"2HO"B`@
XM("`@("`@("`@("`@("`@("`@=&5M<"`]("AI;G0I<W1R;&5N("AE;G1R>2T^
XM:6YF;RD["B`@("`@("`@("`@("`@("`@("`@:68@*"`H96YT<GDM/FQE9G1C
XM:&%R("L@96YT<GDM/G-C<F5E;F-O;"`K(#$I(#T]('1E;7`I"B`@("`@("`@
XM("`@("`@("`@("`@>PH@("`@("`@("`@("`@("`@("`@("`@($)E97`H*3L*
XM("`@("`@("`@("`@("`@("`@("!]"B`@("`@("`@("`@("`@("`@("`@96QS
XM90H@("`@("`@("`@("`@("`@("`@('L*("`@("`@("`@("`@("`@("`@("`@
XM("!W;6]V92`H96YT<GDM/F9I96QD+"`P+"`K*V5N=')Y+3YS8W)E96YC;VPI
XM.PH@("`@("`@("`@("`@("`@("`@('T*("`@("`@("`@("`@("`@("`@("!W
XM<F5F<F5S:"`H96YT<GDM/F9I96QD*3L*("`@("`@("`@("`@("`@("!]"B`@
XM("`@("`@("`@("`@("`@8G)E86L["B`@(`H@("`@("`@("`@("!C87-E($1%
XM3$5412`Z"B`@("`@("`@("`@("`@("`@:68@*&5N=')Y+3YD:7-P='EP92`]
XM/2!V5DE%5T].3%DI"B`@("`@("`@("`@("`@("`@>PH@("`@("`@("`@("`@
XM("`@("`@($)E97`H*3L*("`@("`@("`@("`@("`@("!]"B`@("`@("`@("`@
XM("`@("`@96QS90H@("`@("`@("`@("`@("`@('L*("`@("`@("`@("`@("`@
XM("`@("`O*B!'970@=&AE(&QE;F=T:"!O9B!T:&4@=VED9V5T(&EN9F]R;6%T
XM:6]N+@DJ+PH@("`@("`@("`@("`@("`@("`@(&EN="!I;F9O3&5N9W1H(#T@
XM*&EN="ES=')L96X@*&5N=')Y+3YI;F9O*3L*"B`@("`@("`@("`@("`@("`@
XM("`@:68@*"`H96YT<GDM/FQE9G1C:&%R("L@96YT<GDM/G-C<F5E;F-O;"`K
XM(#$I(#P@:6YF;TQE;F=T:"D*("`@("`@("`@("`@("`@("`@("!["B`@("`@
XM("`@("`@("`@("`@("`@("`@+RH@5V4@87)E(&1E;&5T96EN9R!F<F]M(&EN
XM<VED92!T:&4@<W1R:6YG+@DJ+PH@("`@("`@("`@("`@("`@("`@("`@(&EN
XM="!C=7)R4&]S(#T@96YT<GDM/G-C<F5E;F-O;"ME;G1R>2T^;&5F=&-H87([
XM"B`@("`@("`@("`@("`@("`@("`@("`@9F]R("AX/6-U<G)0;W,[('@@/"!I
XM;F9O3&5N9W1H.R!X*RLI"B`@("`@("`@("`@("`@("`@("`@("`@>PH@("`@
XM("`@("`@("`@("`@("`@("`@("`@(&5N=')Y+3YI;F9O6WA=(#T@96YT<GDM
XM/FEN9F];>"LQ73L*("`@("`@("`@("`@("`@("`@("`@("!]"B`@("`@("`@
XM("`@("`@("`@("`@("`@96YT<GDM/FEN9F];:6YF;TQE;F=T:%T@/2`G7#`G
XM.PH@("`*("`@("`@("`@("`@("`@("`@("`@("`O*B!5<&1A=&4@=&AE('-C
XM<F5E;BX)"0D)*B\*("`@("`@("`@("`@("`@("`@("`@("!I9B`H96YT<GDM
XM/G-C<F5E;F-O;"`^(#`I"B`@("`@("`@("`@("`@("`@("`@("`@>PH@("`@
XM("`@("`@("`@("`@("`@("`@("`@(&UV=V1E;&-H("AE;G1R>2T^9FEE;&0L
XM(#`L("TM96YT<GDM/G-C<F5E;F-O;"D["B`@("`@("`@("`@("`@("`@("`@
XM("`@?0H@("`@("`@("`@("`@("`@("`@("`@(&5L<V4*("`@("`@("`@("`@
XM("`@("`@("`@("!["B`@("`@("`@("`@("`@("`@("`@("`@("`@;79W9&5L
XM8V@@*&5N=')Y+3YF:65L9"P@,"P@96YT<GDM/G-C<F5E;F-O;"D["B`@("`@
XM("`@("`@("`@("`@("`@("`@?0H@("`@("`@("`@("`@("`@("`@("`@(&EF
XM("@@*&EN="ES=')L96X@*&5N=')Y+3YI;F9O*2TQ("T@96YT<GDM/FQE9G1C
XM:&%R(#X@96YT<GDM/F9I96QD=VED=&@M,2D*("`@("`@("`@("`@("`@("`@
XM("`@("!["B`@("`@("`@("`@("`@("`@("`@("`@("`@;79W861D8V@@*&5N
XM=')Y+3YF:65L9"P@,"P@96YT<GDM/F9I96QD=VED=&@M,2P@96YT<GDM/FEN
XM9F];96YT<GDM/FQE9G1C:&%R*V5N=')Y+3YF:65L9'=I9'1H+3%=('P@96YT
XM<GDM/F9I96QD871T<BD["B`@("`@("`@("`@("`@("`@("`@("`@?0H@("`@
XM("`@("`@("`@("`@("`@("`@(&5L<V4*("`@("`@("`@("`@("`@("`@("`@
XM("!["B`@("`@("`@("`@("`@("`@("`@("`@("`@;79W861D8V@@*&5N=')Y
XM+3YF:65L9"P@,"P@96YT<GDM/F9I96QD=VED=&@M,2P@96YT<GDM/F9I;&QE
XM<BD["B`@("`@("`@("`@("`@("`@("`@("`@?0H@("`@("`@("`@("`@("`@
XM("`@("`@('=M;W9E("AE;G1R>2T^9FEE;&0L(#`L(&5N=')Y+3YS8W)E96YC
XM;VPI.PH@("`@("`@("`@("`@("`@("`@("`@('=R969R97-H("AE;G1R>2T^
XM9FEE;&0I.PH@("`@("`@("`@("`@("`@("`@('T*("`@("`@("`@("`@("`@
XM("`@("!E;'-E"B`@("`@("`@("`@("`@("`@("`@>PH@("`@("`@("`@("`@
XM("`@("`@("`@("\J(%=E(&%R92!D96QE=&EN9R!F<F]M('1H92!E;F0@;V8@
XM=&AE('-T<FEN9RX)*B\*("`@("`@("`@("`@("`@("`@("`@("!I;G0@:6YF
XM;TQE;F=T:"`]("AI;G0I<W1R;&5N("AE;G1R>2T^:6YF;RD["B`@("`@("`@
XM("`@("`@("`@("`@("`@:68@*&EN9F],96YG=&@@/B`Q*0H@("`@("`@("`@
XM("`@("`@("`@("`@('L*("`@("`@("`@("`@("`@("`@("`@("`@("!I;G0@
XM<W`@/2`H96YT<GDM/FQE9G1C:&%R(#X@,"`_(#$@.B`P*3L*"B`@("`@("`@
XM("`@("`@("`@("`@("`@("`@+RH@57!D871E('1H92!C:&%R86-T97(@<&]I
XM;G1E<BX)"2HO"B`@("`@("`@("`@("`@("`@("`@("`@("`@96YT<GDM/FEN
XM9F];:6YF;TQE;F=T:"TQ72`]("=<,"<["B`@("`@("`@("`@("`@("`@("`@
XM("`@("`@96YT<GDM/FEN9F];:6YF;TQE;F=T:"TR72`](&5N=')Y+3YF:6QL
XM97(@?"!E;G1R>2T^9FEE;&1A='1R.PH*("`@("`@("`@("`@("`@("`@("`@
XM("`@("`O*B!5<&1A=&4@=&AE('-C<F5E;BX)"0D)*B\*("`@("`@("`@("`@
XM("`@("`@("`@("`@("!I9B`H96YT<GDM/G-C<F5E;F-O;"`]/2!S<"D*("`@
XM("`@("`@("`@("`@("`@("`@("`@("!["B`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@+RH@36%K92!S=7)E('=E(&-A;B!S;VUE=&AI;F<@=&\@9&5L
XM971E+@DJ+PH@("`@("`@("`@("`@("`@("`@("`@("`@("`@(&EN9F],96YG
XM=&@@/2`H:6YT*7-T<FQE;BAE;G1R>2T^:6YF;RD["B`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@:68@*"!I;F9O3&5N9W1H(#X@,"`I"B`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@>PH@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("\J(%=E(&YE960@=&\@861J=7-T('1H92!F:65L9"!I;F9O
XM"2HO"B`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@:68@*&EN9F],
XM96YG=&@@/B!E;G1R>2T^9FEE;&1W:61T:"D*("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("!["B`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@+RH@5&AE(&9I96QD(&EN9F]R;6%T:6]N(&ES(&QA<F=E<B!T:&%N
XM('1H92!F:65L9"X)*B\*("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("!E;G1R>2T^;&5F=&-H87(@/2`H:6YF;TQE;F=T:"`M(&5N=')Y+3YF
XM:65L9'=I9'1H*3L*("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("!E;G1R>2T^<V-R965N8V]L(#T@96YT<GDM/F9I96QD=VED=&@M,3L*("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@("!]"B`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@96QS90H@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@('L*("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`O*B!4:&4@9FEE;&0@:6YF;W)M871I;VX@:7,@<VUA;&QE<B!T:&%N('1H
XM92!F:65L9"X)*B\*("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("!E;G1R>2T^;&5F=&-H87(@/2`P.PH@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@(&5N=')Y+3YS8W)E96YC;VP@/2!I;F9O3&5N9W1H+3$[
XM"B`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@?0H*("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`O*B!2961R87<@=&AE(&9I96QD+@D)
XM"0D)*B\*("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("!D<F%W0T1+
XM16YT<GE&:65L9"`H96YT<GDI.PH@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@('T*("`@("`@("`@("`@("`@("`@("`@("`@("`@("!E;'-E"B`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@>PH@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@($)E97`H*3L*("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("!]"B`@("`@("`@("`@("`@("`@("`@("`@("`@?0H@("`@("`@("`@
XM("`@("`@("`@("`@("`@(&5L<V4*("`@("`@("`@("`@("`@("`@("`@("`@
XM("!["B`@("`@("`@("`@("`@("`@("`@("`@("`@("`@+RH@57!D871E('1H
XM92!S8W)E96XN"0DJ+PH@("`@("`@("`@("`@("`@("`@("`@("`@("`@(&UV
XM=V1E;&-H("AE;G1R>2T^9FEE;&0L(#`L("TM96YT<GDM/G-C<F5E;F-O;"D[
XM"B`@("`@("`@("`@("`@("`@("`@("`@("`@("`@;79W861D8V@@*&5N=')Y
XM+3YF:65L9"P@,"P@96YT<GDM/F9I96QD=VED=&@M,2P@96YT<GDM/F9I;&QE
XM<BD["B`@("`@("`@("`@("`@("`@("`@("`@("`@("`@=VUO=F4@*&5N=')Y
XM+3YF:65L9"P@,"P@96YT<GDM/G-C<F5E;F-O;"D["B`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@=W)E9G)E<V@@*&5N=')Y+3YF:65L9"D["B`@("`@
XM("`@("`@("`@("`@("`@("`@("`@?0H@("`@("`@("`@("`@("`@("`@("`@
XM('T*("`@("`@("`@("`@("`@("`@("`@("!E;'-E"B`@("`@("`@("`@("`@
XM("`@("`@("`@>PH@("`@("`@("`@("`@("`@("`@("`@("`@($)E97`H*3L*
XM("`@("`@("`@("`@("`@("`@("`@("!]"B`@("`@("`@("`@("`@("`@("`@
XM?0H@("`@("`@("`@("`@("`@('T*("`@("`@("`@("`@("`@("!B<F5A:SL*
XM("`@"B`@("`@("`@("`@(&-A<V4@2T597U)%5%523B`Z(&-A<V4@2T597U1!
XM0B`Z(&-A<V4@0T1+7TY%6%0@.@H@("`@("`@("`@("`@("`@(&EF("@H:6YT
XM*7-T<FQE;B`H96YT<GDM/FEN9F\I(#X](&5N=')Y+3YM:6XI"B`@("`@("`@
XM("`@("`@("`@>PH@("`@("`@("`@("`@("`@("`@(&5N=')Y+3YI;F9O6RAI
XM;G0I<W1R;&5N*&5N=')Y+3YI;F9O*2TQ72`]("=<,"<["B`@("`@("`@("`@
XM("`@("`@("`@<F5T=7)N("AE;G1R>2T^:6YF;RD["B`@("`@("`@("`@("`@
XM("`@?0H@("`@("`@("`@("`@("`@(&5L<V4*("`@("`@("`@("`@("`@("![
XM"B`@("`@("`@("`@("`@("`@("`@0F5E<"@I.PH@("`@("`@("`@("`@("`@
XM('T*("`@("`@("`@("`@("`@("!B<F5A:SL*("`@"B`@("`@("`@("`@(&-A
XM<V4@0T1+7U)%1E)%4T@@.@H@("`@("`@("`@("`@("`@(')E9G)E<VA#1$M3
XM8W)E96X@*&5N=')Y+3YS8W)E96XI.PH@("`@("`@("`@("`@("`@(&)R96%K
XM.PH@("`*("`@("`@("`@("`@9&5F875L="`Z"B`@("`@("`@("`@("`@("`@
XM*"A%3E1264-"*65N=')Y+3YC86QL8F%C:V9N*2AE;G1R>2P@:6YP=70I.PH@
XM("`@("`@("`@("`@("`@(&)R96%K.PH@("`@("`@("!]"B`@("`@('T*("`@
XM?0I]"@HO*@H@*B!4:&ES(&ES(&$@9V5N97)I8R!C:&%R86-T97(@<&%R<V5R
XM(&9O<B!T:&4@96YT<GD@9FEE;&0N($ET(&ES('5S960@87,@82`*("H@8V%L
XM;&)A8VL@9G5N8W1I;VXL('-O(&%N>2!P97)S;VYA;"!M;V1I9FEC871I;VYS
XM(&-A;B!B92!M861E(&)Y(&-R96%T:6YG"B`J(&$@;F5W(&9U;F-T:6]N(&%N
XM9"!C86QL:6YG('1H92!A8W1I=F%T:6]N('=I=&@@:71S(&YA;64N"B`J+PIV
XM;VED($-$2T5N=')Y0V%L;$)A8VL@*$-$2T5.5%)9("IE;G1R>2P@8VAT>7!E
XM(&-H87)A8W1E<BD*>PH@("`O*B!$96-L87)E(&QO8V%L('9A<FEA8FQE<RX)
XM"0D)"0DJ+PH@("!C:&%R"7!L86EN8VAA<@D]("AC:&%R86-T97(@)B!!7T-(
XM05)415A4*3L*("`@:6YT('1E;7`L('@["@H@("`O*B!3=&%R="!C:&5C:VEN
XM9R!T:&4@:6YP=70N"0D)"0D)*B\*("`@:68@*&5N=')Y+3YD:7-P='EP92`]
XM/2!V24Y4("8F("%I<V1I9VET*'!L86EN8VAA<BD@*0H@("!["B`@("`@($)E
XM97`H*3L*("`@?0H@("!E;'-E(&EF("@@*`EE;G1R>2T^9&ES<'1Y<&4@/3T@
XM=D-(05(@?'P@96YT<GDM/F1I<W!T>7!E(#T]('950TA!4B!\?"!<"@D)96YT
XM<GDM/F1I<W!T>7!E(#T]('9,0TA!4B!\?"!E;G1R>2T^9&ES<'1Y<&4@/3T@
XM=E5(0TA!4B!\?"!<"@D)96YT<GDM/F1I<W!T>7!E(#T]('9,2$-(05(I("8F
XM(&ES9&EG:70H<&QA:6YC:&%R*2D*("`@>PH@("`@("!"965P*"D["B`@('T*
XM("`@96QS92!I9B`H96YT<GDM/F1I<W!T>7!E(#T]('9624573TY,62D*("`@
XM>PH@("`@("!"965P*"D["B`@('T*("`@96QS92`*("`@>PH@("`@("!I9B`H
XM("AI;G0I<W1R;&5N("AE;G1R>2T^:6YF;RD@/3T@96YT<GDM/FUA>"`I"B`@
XM("`@('L*("`@("`@("`@0F5E<"@I.PH@("`@("!]"B`@("`@(&5L<V4*("`@
XM("`@>PH@("`@("`@("`O*B!792!W:6QL(&UA:V4@86YY(&%D:G5S=&UE;G1S
XM('1O('1H92!C87-E(&]F('1H92!C:&%R86-T97(N"2HO"B`@("`@("`@(&EF
XM("@@*`EE;G1R>2T^9&ES<'1Y<&4@/3T@=E5#2$%2('Q\(&5N=')Y+3YD:7-P
XM='EP92`]/2!V54A#2$%2('Q\(%P*"0EE;G1R>2T^9&ES<'1Y<&4@/3T@=E5-
XM25A%1"!\?"!E;G1R>2T^9&ES<'1Y<&4@/3T@=E5(34E8140I("!<"@D))B8@
XM(6ES9&EG:70H<&QA:6YC:&%R*2`I"B`@("`@("`@('L*("`@("`@("`@("`@
XM<&QA:6YC:&%R(#T@=&]U<'!E<B`H<&QA:6YC:&%R*3L*("`@("`@("`@?0H@
XM("`@("`@("!E;'-E(&EF("@@*`EE;G1R>2T^9&ES<'1Y<&4@/3T@=DQ#2$%2
XM('Q\(&5N=')Y+3YD:7-P='EP92`]/2!V3$A#2$%2('Q\(%P*"0D)96YT<GDM
XM/F1I<W!T>7!E(#T]('9,34E8140@?'P@96YT<GDM/F1I<W!T>7!E(#T]('9,
XM2$U)6$5$*2`F)B!<"@D)"2%I<V1I9VET*'!L86EN8VAA<BD@*0H@("`@("`@
SHAR_EOF
  : || echo 'restore of cdk-4.6.0/entry.c failed'
fi
echo 'End of archive part 4'
echo 'File cdk-4.6.0/entry.c is continued in part 5'
echo 5 > _sharseq.tmp
exit 0
