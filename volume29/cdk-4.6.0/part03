Newsgroups: comp.sources.unix
From: glover@credit.erin.utoronto.ca (Mike Glover)
Subject: v29i076: cdk - curses development kit, V4.6.0, Part03/09
References: <1.821493023.9103@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: glover@credit.erin.utoronto.ca (Mike Glover)
Posting-Number: Volume 29, Issue 76
Archive-Name: cdk-4.6.0/part03

#!/bin/sh
# This is `part03' (part 3 of a multipart archive).
# Do not concatenate these parts, unpack them in order with `/bin/sh'.
# File `cdk-4.6.0/man/scroll.3x' is being continued...
#
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  echo 'WARNING: not restoring timestamps.  Consider getting and'
  echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if test ! -r _sharseq.tmp; then
  echo 'Please unpack part 1 first!'
  exit 1
fi
shar_sequence=`cat _sharseq.tmp`
if test "$shar_sequence" != 3; then
  echo "Please unpack part $shar_sequence next!"
  exit 1
fi
if test ! -f _sharnew.tmp; then
  echo 'x - still skipping cdk-4.6.0/man/scroll.3x'
else
  echo 'x - continuing file cdk-4.6.0/man/scroll.3x'
  sed 's/^X//' << 'SHAR_EOF' >> '_sharuue.tmp' &&
XM+@I$;W=N($%R<F]W("!396QE8W1S('1H92!N97AT(&ET96T@9&]W;B!I;B!T
XM:&4@;&ES="X*4')E=B!086=E("`@36]V97,@;VYE('!A9V4@8F%C:W=A<F1S
XM+@I#=')L+4(@("`@("!-;W9E<R!O;F4@<&%G92!B86-K=V%R9',N"DYE>'0@
XM4&%G92`@($UO=F5S(&]N92!P86=E(&9O<G=A<F1S+@I#=')L+48@("`@("!-
XM;W9E<R!O;F4@<&%G92!F;W)W87)D<RX*9R`@("`@("`@("`@36]V97,@=&\@
XM=&AE(&9I<G-T(&5L96UE;G0@:6X@=&AE(&QI<W0N"C$@("`@("`@("`@($UO
XM=F5S('1O('1H92!F:7)S="!E;&5M96YT(&EN('1H92!L:7-T+@I'("`@("`@
XM("`@("!-;W9E<R!T;R!T:&4@;&%S="!E;&5M96YT(&EN('1H92!L:7-T+@HD
XM("`@("`@("`@("!3:&EF=',@=&AE('=H;VQE(&QI<W0@=&\@=&AE(&9A<B!R
XM:6=H="X*?"`@("`@("`@("`@4VAI9G1S('1H92!W:&]L92!L:7-T('1O('1H
XM92!F87(@;&5F="X*4F5T=7)N("`@("`@17AI=',@=&AE('-C<F]L;&EN9R!L
XM:7-T(&%N9"!R971U<FYS(&%N(&EN=&5G97(*("`@("`@("`@("`@<F5P<F5S
XM96YT:6YG('1H92!C=7)R96YT;'D@<V5L96-T960@:71E;2X*5&%B("`@("`@
XM("`@17AI=',@=&AE('-C<F]L;&EN9R!L:7-T(&%N9"!R971U<FYS(&%N(&EN
XM=&5G97(*("`@("`@("`@("`@<F5P<F5S96YT:6YG('1H92!C=7)R96YT;'D@
XM<V5L96-T960@:71E;2X*0W1R;"U.("`@("`@17AI=',@=&AE('-C<F]L;&EN
XM9R!L:7-T(&%N9"!R971U<FYS(&%N(&EN=&5G97(*("`@("`@("`@("`@<F5P
XM<F5S96YT:6YG('1H92!C=7)R96YT;'D@<V5L96-T960@:71E;2X*0W1R;"U2
XM("`@("`@4F5F<F5S:&5S('1H92!S8W)E96XN"BYF:0HN4T@@4T5%($%,4T\*
XM+D)2(&-D:R`H,U@I+`HN0E(@8V1K7W-C<F5E;B`H,U@I+`HN0E(@8V1K7V1I
XM<W!L87D@*#-8*2P*+D)2(&-D:U]B:6YD:6YG("@S6"D*+E-(($Y/5$53"BY0
XM4`I4:&4@:&5A9&5R(&9I;&4@7&8T/&-D:RYH/EQF,2!A=71O;6%T:6-A;&QY
XM(&EN8VQU9&5S('1H92!H96%D97(@9FEL97,*7&8T/&-U<G-E<RYH/EQF,2P@
XM7&8T/'-T9&QI8BYH/EQF,2P@7&8T/'-T<FEN9RYH/EQF,2P@7&8T/&-T>7!E
XM+F@^7&8Q+`I<9C0\=6YI<W1D+F@^7&8Q+"!<9C0\9&ER96YT+F@^7&8Q+"!<
XM9C0\=&EM92YH/EQF,2P@7&8T/&5R<FYO+F@^7&8Q+`I<9C0\<'=D+F@^7&8Q
XM+"!<9C0\9W)P+F@^7&8Q+"!<9C0\<WES+W-T870N:#Y<9C$L(&%N9"!<9C0\
XM<WES+W1Y<&5S+F@^7&8Q+@I4:&4@7&8T/&-U<G-E<RYH/EQF,2!H96%D97(@
XM9FEL92!I;F-L=61E<R!<9C0\<W1D:6\N:#Y<9C$@86YD(%QF-#QU;F-T<FPN
XM:#Y<9C$N"BY04`I)9B!Y;W4@:&%V92!<9C1N8W5R<V5S7&8Q(&EN<W1A;&QE
XM9"!O;B!Y;W5R(&UA8VAI;F4@861D("U$3D-54E-%4R!T;R!T:&4@"F-O;7!I
XM;&4@;&EN92!T;R!I;F-L=61E('1H92!N8W5R<V5S(&AE861E<B!F:6QE<R!I
X(;G-T96%D+@IT
X`
Xend
SHAR_EOF
  echo 'File cdk-4.6.0/man/scroll.3x is complete' &&
  echo 'uudecoding file cdk-4.6.0/man/scroll.3x' &&
  uudecode _sharuue.tmp < _sharuue.tmp && rm -f _sharuue.tmp &&
  $shar_touch -am 1229121195 'cdk-4.6.0/man/scroll.3x' &&
  chmod 0400 'cdk-4.6.0/man/scroll.3x' ||
  echo 'restore of cdk-4.6.0/man/scroll.3x failed'
  shar_count="`wc -c < 'cdk-4.6.0/man/scroll.3x'`"
  test 6578 -eq "$shar_count" ||
    echo "cdk-4.6.0/man/scroll.3x: original size 6578, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk-4.6.0/man/selection.3x ==============
if test -f 'cdk-4.6.0/man/selection.3x' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk-4.6.0/man/selection.3x (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk-4.6.0/man/selection.3x (binary)'
  sed 's/^X//' << 'SHAR_EOF' > _sharuue.tmp &&
Xbegin 600 cdk-4.6.0/man/selection.3x
XM+F1E($ET"BYB<@HN:64@7%QN*"XD/CTS("YN92!<7"0S"BYE;"`N;F4@,PHN
XM25`@(EQ<)#$B(%Q<)#(*+BX*+E1((&-D:U]S96QE8W1I;VX@,U@@(C`U($1E
XM8R`Q.3DU(@HN4T@@3D%-10IN97=#1$M396QE8W1I;VXL(&%C=&EV871E0T1+
XM4V5L96-T:6]N+"!S971#1$M396QE8W1I;VXL(&1R87=#1$M396QE8W1I;VXL
XM(&5R87-E0T1+4V5L96-T:6]N+`ID97-T<F]Y0T1+4V5L96-T:6]N(%PM($-R
XM96%T97,@82!M86YA9V5D(&-U<G-E<R!S96QE8W1I;VX@;&ES="!W:61G970N
XM"BY32"!364Y/4%-)4PHN3%`*+D(@8V,*+E))(");("(@(F9L86<B("(@7'PN
XM7'PN7'PN(%T@(B`B9FEL92(@(B!<?"Y<?"Y<?"XB"BY"(%PM;&-D:PHN4DD@
XM(EL@(B`B;&EB<F%R>2(@(B!<?"Y<?"Y<?"X@72(*+DQ0"B-I;F-L=61E(#QC
XM9&LN:#X*+DQ0"BY"22`B0T1+4T5,14-424].("IN97=#1$M396QE8W1I;VX@
XM*$-$2U-#4D5%3B`J(B`B8V1K<V-R965N(BP*+D))(")I;G0@(B`B>'!O<R(L
XM"BY"22`B:6YT("(@(GEP;W,B+`HN0DD@(FEN="`B(")H96EG:'0B+`HN0DD@
XM(FEN="`B(")W:61T:"(L"BY"22`B8VAA<B`J(B`B=&ET;&4B+`HN0DD@(F-H
XM87(@*BHB(")S96QE8W1I;VY,:7-T(BP*+D))(")I;G0@(B`B<V5L96-T:6]N
XM3&ES=$QE;F=T:"(L"BY"22`B8VAA<B`J*B(@(F-H;VEC94QI<W0B+`HN0DD@
XM(FEN="`B(")C:&]I8V5,:7-T3&5N9W1H(BP*+D))(")C:'1Y<&4@(B`B:&EG
XM:&QI9VAT(BP*+D))(")B;V]L96%N("(@(F)O>"(L"BY"22`B8F]O;&5A;B`B
XM(")S:&%D;W<B*3L*+DQ0"BY"22`B=F]I9"!A8W1I=F%T94-$2U-E;&5C=&EO
XM;B`H0T1+4T5,14-424].("HB(")S96QE8W1I;VXB*3L*+DQ0"BY"22`B=F]I
XM9"!S971#1$M396QE8W1I;VX@*$-$2U-%3$5#5$E/3B`J(B`B<V5L96-T:6]N
XM(BP*+D))(")C:'1Y<&4@(B`B:&EG:&QI9VAT(BP*+D))(")C:'1Y<&4@(B`B
XM8VAO:6-E0VAA<F%C=&5R(BP*+D))(")B;V]L96%N("(@(F)O>"(I.PHN3%`*
XM+D))(")V;VED(&1R87=#1$M396QE8W1I;VX@*$-$2U-%3$5#5$E/3B`J(B`B
XM<V5L96-T:6]N(BP*+D))(")B;V]L96%N("(@(F)O>"(I.PHN3%`*+D))(")V
XM;VED(&5R87-E0T1+4V5L96-T:6]N("A#1$M314Q%0U1)3TX@*B(@(G-E;&5C
XM=&EO;B(I.PHN3%`*+D))(")V;VED(&1E<W1R;WE#1$M396QE8W1I;VX@*$-$
XM2U-%3$5#5$E/3B`J(B`B<V5L96-T:6]N(BD["BY,4`HN0DD@(G9O:60@8FEN
XM9$-$2T]B:F5C="`H14]B:F5C=%1Y<&4@(B`B=VED9V5T5'EP92(L"BY"22`B
XM=F]I9"`J(B`B;V)J96-T(BP*+D))(")C:'1Y<&4@(B`B:V5Y(BP*+D))(")"
XM24Y$1DX@(B`B9G5N8W1I;VXB+`HN0DD@(G9O:60@*B(@(F1A=&$B*3L*+E-(
XM($1%4T-225!424]."E1H92!#9&L@<V5L96-T:6]N('=I9&=E="!C<F5A=&5S
XM(&$@<V5L96-T:6]N(&QI<W0N(%1H92!F;VQL;W=I;F<@87)E(&9U;F-T:6]N
XM<R!W:&EC:"`*8W)E871E(&]R(&UA;FEP=6QA=&4@=&AE($-D:R!S96QE8W1I
XM;VX@8F]X('=I9&=E="X*+DE0(")#1$M314Q%0U1)3TX@*FYE=T-$2U-E;&5C
XM=&EO;B`H7&8R<V-R965N7&8Q+"!<9C)X<&]S7&8Q+"!<9C)Y<&]S7&8Q+"!<
XM9C)H96EG:'1<9C$L(%QF,G=I9'1H7&8Q+"!<9C)T:71L95QF,2P@7&8R<V5L
XM96-T:6]N3&ES=%QF,2P@7&8R<V5L96-T:6]N3&ES=$QE;F=T:%QF,2P@7&8R
XM8VAO:6-E3&ES=%QF,2P@7&8R8VAO:6-E3&ES=$QE;F=T:%QF,2P@7&8R:&EG
XM:&QI9VAT7&8Q+"!<9C)B;WA<9C$L(%QF,G-H861O=UQF,2D[(B`S"E1H:7,@
XM9G5N8W1I;VX@8V%L;"!C<F5A=&5S(&$@<&]I;G1E<B!T;R!A;B!S96QE8W1I
XM;VX@=VED9V5T+B!4:&4@<&%R86UE=&5R"EQF,G-C<F5E;EQF,2!I<R!O9B!T
XM>7!E($-$2U-#4D5%3BX@5&AE('!A<F%M971E<B!<9C)X<&]S7&8Q(&-O;G1R
XM;VQS('1H92!P;&%C96UE;G0*;V8@=&AE(&]B:F5C="!A;&]N9R!T:&4@:&]R
XM:7IO;G1A;"!A>&ES.R!W:&EC:"!M96%N<R!I="!C86X@=&%K92!A;B!I;G1E
XM9V5R('9A;'5E"F]R('1H92!P<F5D969I;F5D('9A;'5E<R!O9B!<9C1,1494
XM7&8Q+"!<9C1224=(5%QF,2P@86YD(%QF-$-%3E1%4EQF,2X@5&AE"G!A<F%M
XM971E<B!<9C)Y<&]S7&8Q(&-O;G1R;VQS('1H92!P;&%C96UE;G0@;V8@=&AE
XM(&]B:F5C="!A;&]N9R!T:&4@=F5R=&EC86P*87AI<R!W:&EC:"!M96%N<R!I
XM="!C86X@86-C97!T(&%N(&EN=&5G97(@=F%L=64@;W(@82!P<F5D969I;F5D
XM('9A;'5E(&]F(`I<9C143U!<9C$L(%QF-$)/5%1/35QF,2P@86YD(%QF-$-%
XM3E1%4EQF,2X@5&AE('!A<F%M971E<G,@7&8R:&5I9VAT7&8Q(&%N9`I<9C)W
XM:61T:%QF,2!S=&%T92!H;W<@=&%L;"!A;F0@=VED92!T:&4@<V5L96-T:6]N
XM('=I;F1O=R!I<R!T;R!B92X@5&AE('!A<F%M971E<@I<9C)T:71L95QF,2!I
XM<R!T:&4@=&ET;&4@;V8@=&AE('-E;&5C=&EO;B!L:7-T+B!4:&4@<&%R86UE
XM=&5R(%QF,G-E;&5C=&EO;DQI<W1<9C$*:7,@=&AE(&QI<W0@;V8@:71E;7,@
XM=&\@8F4@9&ES<&QA>65D(&EN('1H92!S96QE8W1I;VX@;&ES=#L@7&8R<V5L
XM96-T:6]N3&ES=$QE;F=T:%QF,0II<R!T:&4@;G5M8F5R(&]F(&5L96UE;G1S
XM(&EN('1H92!G:79E;B!L:7-T+B!4:&4@7&8R8VAO:6-E3&ES=%QF,2!P87)A
XM;65T97(@:7,@=&AE"FQI<W0@;V8@8VAO:6-E<R!T:&%T('=I;&P@8F4@<V5L
XM96-T960@=VAE;B!T:&4@=7-E<B!P<F5S<V5S('1H92!S<&%C92!B87(["EQF
XM,F-H;VEC94QI<W1,96YG=&A<9C$@:7,@=&AE(&QE;F=T:"!O9B!T:&ES(&QI
XM<W0N(%1H92!<9C)H:6=H;&EG:'1<9C$@<&%R86UE=&5R"G-P96-I9FEE<R!T
XM:&4@9&ES<&QA>2!A='1R:6)U=&4@;V8@=&AE(&-U<G)E;G1L>2!S96QE8W1E
XM9"!I=&5M+B!4:&4@7&8R8F]X7&8Q(`IP87)A;65T97(@<W1A=&5S('=H971H
XM97(@=&AE('=I9&=E="!W:6QL(&)E(&1R87=N('=I=&@@82!B;W@@87)O=6YD
XM(&ET(&]R(&YO="X*5&AE(%QF,G-H861O=UQF,2!P87)A;65T97(@86-C97!T
XM<R!A(&)O;VQE86X@=F%L=64@=&\@='5R;B!T:&4@<VAA9&]W(&]N(&]R(&]F
XM9@IA<F]U;F0@=&AI<R!W:61G970N($EF('1H92!W:61G970@8V]U;&0@;F]T
XM(&)E(&-R96%T960@=&AE;B!A($Y53$P@<&]I;G1E<B!I<PIR971U<FYE9"X*
XM+DE0(")V;VED(&%C=&EV871E0T1+4V5L96-T:6]N("A<9C)S96QE8W1I;VY<
XM9C$I.R(@,PI4:&ES(&9U;F-T:6]N(&%C=&EV871E<R!T:&4@<V5L96-T:6]N
XM('=I9&=E="!A;F0@;&5T<R!T:&4@=7-E<B!I;G1E<F%C="!W:71H('1H90IW
XM:61G970N(%1H92!O;FQY('!A<F%M971E<B!T:&ES(&9U;F-T:6]N(')E<75I
XM<F5S(&ES('1H92!<9C)S96QE8W1I;VY<9C$@=VED9V5T"G!O:6YT97(N(%1H
XM:7,@9G5N8W1I;VX@<F5T=7)N<R!N;W1H:6YG+B!4;R!G970@=&AE(&EN9F]R
XM;6%T:6]N(&9R;VT@=&AE('-E;&5C=&EO;@IL:7-T(&-H96-K('1H92!V86QU
XM92!O9B!T:&4@7&8T<V5L96-T:6]N<UQF,2!E;&5M96YT(&]F('1H92!S96QE
XM8W1I;VX@;V)J96-T+@HN25`@(G9O:60@<V5T0T1+4V5L96-T:6]N("A<9C)S
XM96QE8W1I;VY<9C$L(%QF,FAI9VAL:6=H=%QF,2P@7&8R8VAO:6-E0VAA<F%C
XM=&5R7&8Q+"!<9C)B;WA<9C$I.R(@,PI4:&ES(&9U;F-T:6]N(&QE=',@=&AE
XM('!R;V=R86UM97(@;6]D:69Y(&-E<G1A:6X@96QE;65N=',@;V8@86X@86QR
XM96%D>2!D969I;F5D"G-E;&5C=&EO;B!W:61G970N(%1H92!P87)A;65T97(@
XM;F%M97,@8V]R<F5S<&]N9"!T;R!T:&4@<V%M92!P87)A;65T97(@;F%M97,@
XM;&ES=&5D"FEN('1H92!<9C1N97=#1$M396QE8W1I;VY<9C$@9G5N8W1I;VXN
XM"BY)4"`B=F]I9"!D<F%W0T1+4V5L96-T:6]N*%QF,G-E;&5C=&EO;EQF,2P@
XM7&8R8F]X7&8Q*3LB(#,*5&AI<R!F=6YC=&EO;B!D<F%W<R!T:&4@<V5L96-T
XM:6]N('=I9&=E="!O;B!T:&4@<V-R965N+B!4:&4@7&8R8F]X7&8Q(&]P=&EO
XM;B`*9')A=W,@=&AE('=I9&=E="!W:71H(&]R('=I=&AO=70@82!B;W@N"BY)
XM4"`B=F]I9"!E<F%S94-$2U-E;&5C=&EO;B`H7&8R<V5L96-T:6]N7&8Q*3LB
XM(#,*5&AI<R!F=6YC=&EO;B!R96UO=F5S('1H92!W:61G970@9G)O;2!T:&4@
XM<V-R965N+B!4:&ES(&1O97,@7&8T3D]47&8Q(&1E<W1R;WD*=&AE('=I9&=E
XM="X*+DE0(")V;VED(&1E<W1R;WE#1$M396QE8W1I;VX@*%QF,G-E;&5C=&EO
XM;EQF,2D[(B`S"E1H:7,@9G5N8W1I;VX@<F5M;W9E<R!T:&4@=VED9V5T(&9R
XM;VT@=&AE('-C<F5E;B!A;F0@9G)E97,@=7`@86YY(&UE;6]R>2!T:&4*;V)J
XM96-T(&UA>2!B92!U<VEN9RX*+DE0(")V;VED(&)I;F1#1$M/8FIE8W0@*%QF
XM,G=I9&=E=%1Y<&5<9C$L(%QF,F]B:F5C=%QF,2P@7&8R:V5Y7&8Q+"!<9C)F
XM=6YC=&EO;EQF,2P@7&8R9&%T85QF,2D[(B`S"E1H:7,@9G5N8W1I;VX@86QL
XM;W=S('1H92!U<V5R('1O(&-R96%T92!S<&5C:6%L(&ME>2!B:6YD:6YG<RX@
XM5&AE(%QF,G=I9&=E=%1Y<&5<9C$*<&%R86UE=&5R(&ES(&$@9&5F:6YE9"!T
XM>7!E('=H:6-H('-T871E<R!W:&%T($-D:R!O8FIE8W0@='EP92!I<R!B96EN
XM9R!U<V5D+@I4;R!L96%R;B!M;W)E(&%B;W5T('1H92!T>7!E(%QF-$5/8FIE
XM8W14>7!E7&8Q(')E860@=&AE(%QF,F-D:U]B:6YD:6YG7&8Q(&UA;G5A;`IP
XM86=E+B!4:&4@7&8R;V)J96-T7&8Q('!A<F%M971E<B!I<R!T:&4@<&]I;G1E
XM<B!T;R!T:&4@=VED9V5T(&]B:F5C="X@5&AE"EQF,FME>5QF,2!I<R!T:&4@
XM8VAA<F%C=&5R('1O(&)I;F0N(%1H92!<9C)F=6YC=&EO;EQF,2!I<R!T:&4@
XM9G5N8W1I;VX@='EP92X@5&\*;&5A<FX@;6]R92!A8F]U="!T:&4@:V5Y(&)I
XM;F1I;F<@8V%L;&)A8VL@9G5N8W1I;VX@='EP97,@<F5A9"!T:&4@7&8T8V1K
XM7V)I;F1I;F=<9C$*;6%N=6%L('!A9V4N(%1H92!L87-T('!A<F%M971E<B!<
XM9C)D871A7&8Q(&ES(&$@<&]I;G1E<B!T;R!A;GD@9&%T82!T:&%T(&YE961S
XM"G1O(&=E="!P87-S960@=&\@=&AE(&-A;&QB86-K(&9U;F-T:6]N+@HN4T@@
XM2T59($))3D1)3D=3"E=H96X@=&AE('=I9&=E="!I<R!A8W1I=F%T960@=&AE
XM<F4@87)E('-E=F5R86P@9&5F875L="!K97D@8FEN9&EN9W,@=VAI8V@@=VEL
XM;`IH96QP('1H92!U<V5R(&5N=&5R(&]R(&UA;FEP=6QA=&4@=&AE(&EN9F]R
XM;6%T:6]N('%U:6-K;'DN(%1H92!F;VQL;W=I;F<@=&%B;&4*;W5T;&EN97,@
XM=&AE(&ME>7,@86YD('1H96ER(&%C=&EO;G,@9F]R('1H:7,@=VED9V5T+@HN
XM3%`*+FYF"EQF,DME>2`@("`@("`@("!!8W1I;VY<9C$*3&5F="!!<G)O=R`@
XM4VAI9G1S('1H92!W:&]L92!L:7-T(&QE9G0@;VYE(&-H87)A8W1E<BX*4FEG
XM:'0@07)R;W<@4VAI9G1S('1H92!W:&]L92!L:7-T(')I9VAT(&]N92!C:&%R
XM86-T97(N"E5P($%R<F]W("`@(%-E;&5C=',@=&AE(&YE>'0@:71E;2!U<"!I
XM;B!T:&4@;&ES="X*1&]W;B!!<G)O=R`@4V5L96-T<R!T:&4@;F5X="!I=&5M
XM(&1O=VX@:6X@=&AE(&QI<W0N"E-P86-E("`@("`@($-Y8VQE<R!T;R!T:&4@
XM;F5X="!C:&]I8V4@;VX@=&AE(&-U<G)E;G0@:71E;2X*4')E=B!086=E("`@
XM36]V97,@;VYE('!A9V4@8F%C:W=A<F1S+@I#=')L+4(@("`@("!-;W9E<R!O
XM;F4@<&%G92!B86-K=V%R9',N"DYE>'0@4&%G92`@($UO=F5S(&]N92!P86=E
XM(&9O<G=A<F1S+@I#=')L+48@("`@("!-;W9E<R!O;F4@<&%G92!F;W)W87)D
XM<RX*9R`@("`@("`@("`@36]V97,@=&\@=&AE(&9I<G-T(&5L96UE;G0@:6X@
XM=&AE(&QI<W0N"C$@("`@("`@("`@($UO=F5S('1O('1H92!F:7)S="!E;&5M
XM96YT(&EN('1H92!L:7-T+@I'("`@("`@("`@("!-;W9E<R!T;R!T:&4@;&%S
XM="!E;&5M96YT(&EN('1H92!L:7-T+@HD("`@("`@("`@("!3:&EF=',@=&AE
XM('=H;VQE(&QI<W0@=&\@=&AE(&9A<B!R:6=H="X*?"`@("`@("`@("`@4VAI
XM9G1S('1H92!W:&]L92!L:7-T('1O('1H92!F87(@;&5F="X*4F5T=7)N("`@
XM("`@17AI=',@=&AE('-E;&5C=&EO;B!L:7-T(&%N9"!R971U<FYS(&%N(&EN
XM=&5G97(*("`@("`@("`@("`@<F5P<F5S96YT:6YG('1H92!C=7)R96YT;'D@
XM<V5L96-T960@:71E;2X*5&%B("`@("`@("`@17AI=',@=&AE('-E;&5C=&EO
XM;B!L:7-T(&%N9"!R971U<FYS(&%N(&EN=&5G97(*("`@("`@("`@("`@<F5P
XM<F5S96YT:6YG('1H92!C=7)R96YT;'D@<V5L96-T960@:71E;2X*0W1R;"U.
XM("`@("`@17AI=',@=&AE('-E;&5C=&EO;B!L:7-T(&%N9"!R971U<FYS(&%N
XM(&EN=&5G97(*("`@("`@("`@("`@<F5P<F5S96YT:6YG('1H92!C=7)R96YT
XM;'D@<V5L96-T960@:71E;2X*0W1R;"U2("`@("`@4F5F<F5S:&5S('1H92!S
XM8W)E96XN"BYF:0HN4T@@4T5%($%,4T\*+D)2(&-D:R`H,U@I+`HN0E(@8V1K
XM7W-C<F5E;B`H,U@I+`HN0E(@8V1K7V1I<W!L87D@*#-8*2P*+D)2(&-D:U]B
XM:6YD:6YG("@S6"D*+E-(($Y/5$53"BY04`I4:&4@:&5A9&5R(&9I;&4@7&8T
XM/&-D:RYH/EQF,2!A=71O;6%T:6-A;&QY(&EN8VQU9&5S('1H92!H96%D97(@
XM9FEL97,*7&8T/&-U<G-E<RYH/EQF,2P@7&8T/'-T9&QI8BYH/EQF,2P@7&8T
XM/'-T<FEN9RYH/EQF,2P@7&8T/&-T>7!E+F@^7&8Q+`I<9C0\=6YI<W1D+F@^
XM7&8Q+"!<9C0\9&ER96YT+F@^7&8Q+"!<9C0\=&EM92YH/EQF,2P@7&8T/&5R
XM<FYO+F@^7&8Q+`I<9C0\<'=D+F@^7&8Q+"!<9C0\9W)P+F@^7&8Q+"!<9C0\
XM<WES+W-T870N:#Y<9C$L(&%N9"!<9C0\<WES+W1Y<&5S+F@^7&8Q+@I4:&4@
XM7&8T/&-U<G-E<RYH/EQF,2!H96%D97(@9FEL92!I;F-L=61E<R!<9C0\<W1D
XM:6\N:#Y<9C$@86YD(%QF-#QU;F-T<FPN:#Y<9C$N"BY04`I)9B!Y;W4@:&%V
XM92!<9C1N8W5R<V5S7&8Q(&EN<W1A;&QE9"!O;B!Y;W5R(&UA8VAI;F4@861D
XM("U$3D-54E-%4R!T;R!T:&4@"F-O;7!I;&4@;&EN92!T;R!I;F-L=61E('1H
X@92!N8W5R<V5S(&AE861E<B!F:6QE<R!I;G-T96%D+@IT
X`
Xend
SHAR_EOF
  echo 'uudecoding file cdk-4.6.0/man/selection.3x' &&
  uudecode _sharuue.tmp < _sharuue.tmp && rm -f _sharuue.tmp &&
  $shar_touch -am 1229121195 'cdk-4.6.0/man/selection.3x' &&
  chmod 0400 'cdk-4.6.0/man/selection.3x' ||
  echo 'restore of cdk-4.6.0/man/selection.3x failed'
  shar_count="`wc -c < 'cdk-4.6.0/man/selection.3x'`"
  test 6872 -eq "$shar_count" ||
    echo "cdk-4.6.0/man/selection.3x: original size 6872, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk-4.6.0/man/swindow.3x ==============
if test -f 'cdk-4.6.0/man/swindow.3x' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk-4.6.0/man/swindow.3x (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk-4.6.0/man/swindow.3x (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk-4.6.0/man/swindow.3x' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH cdk_swindow 3X "05 Dec 1995"
X.SH NAME
XnewCDKSwindow, activateCDKSwindow, setCDKSwindow, drawCDKSwindow, eraseCDKSwindow, 
XcleanCDKSwindow, addCDKSwindow, trimCDKSwindow, destroyCDKSwindow \- 
XCreates a managed curses swindow widget.
X.SH SYNOPSIS
X.LP
X.B cc
X.RI "[ " "flag" " \|.\|.\|. ] " "file" " \|.\|.\|."
X.B \-lcdk
X.RI "[ " "library" " \|.\|.\|. ]"
X.LP
X#include <cdk.h>
X.LP
X.BI "CDKSWINDOW *newCDKSwindow (CDKSCREEN *" "cdkscreen",
X.BI "int " "xpos",
X.BI "int " "ypos",
X.BI "int " "height",
X.BI "int " "width",
X.BI "char *" "title",
X.BI "int " "saveLines",
X.BI "boolean " "box",
X.BI "boolean " "shadow");
X.LP
X.BI "void activateCDKSwindow (CDKSWINDOW *" "swindow");
X.LP
X.BI "void setCDKSwindow (CDKSWINDOW *" "swindow",
X.BI "char **" "info",
X.BI "int " "lines",
X.BI "boolean " "box");
X.LP
X.BI "void drawCDKSwindow (CDKSWINDOW *" "swindow",
X.BI "boolean " "box");
X.LP
X.BI "void eraseCDKSwindow (CDKSWINDOW *" "swindow");
X.LP
X.BI "void cleanCDKSwindow (CDKSWINDOW *" "swindow");
X.LP
X.BI "void addCDKSwindow (CDKSWINDOW *" "swindow",
X.BI "char *" "info",
X.BI "int " "insertPosition");
X.LP
X.BI "void trimCDKSwindow (CDKSWINDOW *" "swindow",
X.BI "int " "start",
X.BI "int " "finish");
X.LP
X.BI "void destroyCDKSwindow (CDKSWINDOW *" "swindow");
X.LP
X.BI "void bindCDKObject (EObjectType " "widgetType",
X.BI "void *" "object",
X.BI "chtype " "key",
X.BI "BINDFN " "function",
X.BI "void *" "data");
X.SH DESCRIPTION
XThe Cdk scrolling window widget creates a widget which can be used to display
Xmessages. The following are functions which create or manipulate the Cdk swindow
Xbox widget.
X.IP "CDKSWINDOW *newCDKSwindow (\f2screen\f1, \f2xpos\f1, \f2ypos\f1, \f2height\f1, \f2width\f1, \f2title\f1, \f2saveLines\f1, \f2box\f1);
XThis function call creates a pointer to an swindow widget. The parameter
X\f2screen\f1 is of type CDKSCREEN. The parameter \f2xpos\f1 controls the placement
Xof the object along the horizontal axis; which means it can take an integer value
Xor the predefined values of \f4LEFT\f1, \f4RIGHT\f1, and \f4CENTER\f1. The
Xparameter \f2ypos\f1 controls the placement of the object along the vertical
Xaxis which means it can accept an integer value or a predefined value of 
X\f4TOP\f1, \f4BOTTOM\f1, and \f4CENTER\f1. The parameters \f2height\f1 and
X\f2width\f1 are the height and the width of the window respectively. The
X\f2title\f1 parameter is the title of the scrolling window. The parameter
X\f2saveLines\f1 is the number of lines to save before throwing information
Xaway. The \f2box\f1 parameter states whether the widget will
Xbe drawn with a box around it or not. The \f2shadow\f1 parameter accepts a 
Xboolean value to turn the shadow on or off around this widget. If the widget
Xcould not be created then a NULL pointer is returned.
X.IP "void activateCDKSwindow (\f2swindow\f1);" 3
XThis function activates the swindow widget and lets the user interact with the
Xwidget. The only parameter this function requires is the \f2swindow\f1 widget
Xpointer. This function returns nothing.
X.IP "void setCDKSwindow (\f2swindow\f1, \f2info\f1, \f2lines\f1, \f2box\f1);" 3
XThis function lets the programmer modify certain elements of an already defined
Xswindow widget. The parameter \f2info\f1 is a \f4char **\f1 of the information
Xto set in the scrolling window; \f2lines\f1 is the number of lines being added.
XThe other parameter names correspond to the same parameter names listed in the 
X\f4newCDKSwindow\f1 function.
X.IP "void drawCDKSwindow(\f2swindow\f1, \f2box\f1);" 3
XThis function draws the swindow widget on the screen. The \f2box\f1 option 
Xdraws the widget with or without a box.
X.IP "void eraseCDKSwindow (\f2swindow\f1);" 3
XThis function removes the widget from the screen. This does \f4NOT\f1 destroy
Xthe widget.
X.IP "void cleanCDKSwindow (\f2swindow\f1);" 3
XThis function clears the information from the window.
X.IP "void addCDKSwindow (\f2swindow\f1, \f2info\f1, \f2insertPosition\f1);" 3
XThis function adds information to a defined scrolling window. The information
Xis supplied by the \2info\f1 parameter. The information is immediately added
Xto the scrolling window. The position of the new information is governed by
Xthe value of the parameter \f2insertPosition\f1. This parameter can accept
Xtwo values: \f4TOP\f1 or \f4BOTTOM\f1.
X.IP "void trimCDKSwindow (\f2swindow\f1, \f2start\f1, \f2end\f1);" 3
XThis function removes information from the scrolling window. The parameters
X\f2start\f1 and \f2end\f1 state where to start cutting from and where to stop.
X.IP "void destroyCDKSwindow (\f2swindow\f1);" 3
XThis function removes the widget from the screen and frees up any memory the
Xobject may be using.
X.IP "void bindCDKObject (\f2widgetType\f1, \f2object\f1, \f2key\f1, \f2function\f1, \f2data\f1);" 3
XThis function allows the user to create special key bindings. The \f2widgetType\f1
Xparameter is a defined type which states what Cdk object type is being used.
XTo learn more about the type \f4EObjectType\f1 read the \f2cdk_binding\f1 manual
Xpage. The \f2object\f1 parameter is the pointer to the widget object. The
X\f2key\f1 is the character to bind. The \f2function\f1 is the function type. To
Xlearn more about the key binding callback function types read the \f4cdk_binding\f1
Xmanual page. The last parameter \f2data\f1 is a pointer to any data that needs
Xto get passed to the callback function.
X.SH KEY BINDINGS
XWhen the widget is activated there are several default key bindings which will
Xhelp the user enter or manipulate the information quickly. The following table
Xoutlines the keys and their actions for this widget.
X.LP
X.nf
X\f2Key          Action\f1
XLeft Arrow  Scrolls the window left one character.
XRight Arrow Scrolls the window right one character.
XUp Arrow    Scrolls the window up one line.
XDown Arrow  Scrolls the window up down line.
XPrev Page   Scrolls the window backwards one page.
XCtrl-B      Scrolls the window backwards one page.
Xb           Scrolls the window backwards one page.
XB           Scrolls the window backwards one page.
XNext Page   Scrolls the window forwards one page.
XCtrl-F      Scrolls the window forwards one page.
XSpace       Scrolls the window forwards one page.
Xf           Scrolls the window forwards one page.
XF           Scrolls the window forwards one page.
XHome        Moves the whole list to the far left character.
X|           Moves the whole list to the far left character.
XEnd         Moves the whole list to the far right character.
X$           Moves the whole list to the far right character.
Xg           Moves to the top of the scrolling window.
X1           Moves to the top of the scrolling window.
XG           Moves to the bottom of the scrolling window.
XL           Moves half the distance to the end of the file.
Xl           Moves half the distance to the top of the file.
XReturn      Exits the widget.
XTab         Exits the widget.
XCtrl-N      Exits the widget.
XCtrl-R      Refreshes the screen.
X.fi
X.SH SEE ALSO
X.BR cdk (3X),
X.BR cdk_screen (3X),
X.BR cdk_display (3X),
X.BR cdk_binding (3X)
X.SH NOTES
X.PP
XThe header file \f4<cdk.h>\f1 automatically includes the header files
X\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
X\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
X\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
XThe \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
X.PP
XIf you have \f4ncurses\f1 installed on your machine add -DNCURSES to the 
Xcompile line to include the ncurses header files instead.
SHAR_EOF
  $shar_touch -am 1229121195 'cdk-4.6.0/man/swindow.3x' &&
  chmod 0400 'cdk-4.6.0/man/swindow.3x' ||
  echo 'restore of cdk-4.6.0/man/swindow.3x failed'
  shar_count="`wc -c < 'cdk-4.6.0/man/swindow.3x'`"
  test 7553 -eq "$shar_count" ||
    echo "cdk-4.6.0/man/swindow.3x: original size 7553, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk-4.6.0/man/template.3x ==============
if test -f 'cdk-4.6.0/man/template.3x' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk-4.6.0/man/template.3x (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk-4.6.0/man/template.3x (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk-4.6.0/man/template.3x' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH cdk_template 3X "05 Dec 1995"
X.SH NAME
XnewCDKTemplate, activateCDKTemplate, setCDKTemplate, drawCDKTemplate, eraseCDKTemplate, 
XcleanCDKTemplate, mixCDKTemplate, unmixCDKTemplate, destroyCDKTemplate \-
XCreates a managed curses template widget.
X.SH SYNOPSIS
X.LP
X.B cc
X.RI "[ " "flag" " \|.\|.\|. ] " "file" " \|.\|.\|."
X.B \-lcdk
X.RI "[ " "library" " \|.\|.\|. ]"
X.LP
X#include <cdk.h>
X.LP
X.BI "CDKTEMPLATE *newCDKTemplate (CDKSCREEN *" "cdkscreen",
X.BI "int " "xpos",
X.BI "int " "ypos",
X.BI "int " "lpos",
X.BI "char *" "label",
X.BI "char *" "plate",
X.BI "char *" "overlay",
X.BI "TEMPLATECB " "callbackFunction",
X.BI "boolean " "box",
X.BI "boolean " "shadow");
X.LP
X.BI "char *activateCDKTemplate (CDKTEMPLATE *" "template");
X.LP
X.BI "void setCDKTemplate (CDKTEMPLATE *" "template",
X.BI "char *" "value",
X.BI "boolean " "box");
X.LP
X.BI "void drawCDKTemplate (CDKTEMPLATE *" "template",
X.BI "boolean " "box");
X.LP
X.BI "void eraseCDKTemplate (CDKTEMPLATE *" "template");
X.LP
X.BI "void cleanCDKTemplate (CDKTEMPLATE *" "template");
X.LP
X.BI "char *mixCDKTemplate (CDKTEMPLATE *" "template");
X.LP
X.BI "char *unmixCDKTemplate (CDKTEMPLATE *" "template");
X.LP
X.BI "void destroyCDKTemplate (CDKTEMPLATE *" "template");
X.LP
X.BI "void bindCDKObject (EObjectType " "widgetType",
X.BI "void *" "object",
X.BI "chtype " "key",
X.BI "BINDFN " "function",
X.BI "void *" "data");
X.SH DESCRIPTION
XThe Cdk template widget creates a template widget which allows a user to type 
Xinformation into an entry field with a preset field format. Typical uses for
Xthis widget would be a date field or a time field. The following are functions
Xwhich create or manipulate the Cdk template box widget.
X
X.IP "CDKTEMPLATE *newCDKTemplate (\f2screen\f1, \f2xpos\f1, \f2ypos\f1, \f2lpos\f1, \f2label\f1, \f2plate\f1, \f2overlay\f1, \f2callbackFunction\f1, \f2box\f1, \f2shadow\f1);" 3
XThis function call creates a pointer to an template widget. The parameter
X\f2screen\f1 is of type CDKSCREEN. The parameter \f2xpos\f1 controls the placement
Xof the object along the horizontal axis; which means it can take an integer value
Xor the predefined values of \f4LEFT\f1, \f4RIGHT\f1, and \f4CENTER\f1. The
Xparameter \f2ypos\f1 controls the placement of the object along the vertical
Xaxis which means it can accept an integer value or a predefined value of 
X\f4TOP\f1, \f4BOTTOM\f1, and \f4CENTER\f1. The parameter \f2lpos\f1 controls
Xwhere the label is to be set. It can take an integer value or one of the 
Xpredefined values: \f4TOP\f1, \f4BOTTOM\f1, \f4LEFT\f1, \f4RIGHT\f1, and 
X\f4CENTER\f1. The \f2label\f1 parameter is the string which will be displayed
Xin the label of the template field. The \f2plate\f1 parameter defines what
Xcharacter is allowed at what position in the template field. This is done
Xby creating a character plate by using special format character to tell the
Xtemplate widget what type of character is allowed where in the template widget.
XThe following table lists all of the current format types.
X.LP
X.nf 
X\f2Plate Character   Effect\f1
X#                 Accepts an integer value.
XA                 Accepts an alphabetic value.
XC                 Accepts an alphabetic value. Automatically
X                  converts the character to upper case.
Xc                 Accepts an alphabetic value. Automatically
X                  converts the character to lower case.
XM                 Accepts alphanumeric characters.
XX                 Accepts alphanumeric characters. Automatically
X                  converts the character to upper case.
Xx                 Accepts alphanumeric characters. Automatically
X                  converts the character to upper case.
XAnything else     Ignored and assumed a non edit-able position.
X.fi
X.IP "" 3
XThe \f2overlay\f1 parameter is the overlay of the template field. If the field
Xneeded some sort of overlay, this parameter supplies this. A date field could
Xhave YY/MM/DD, the overlay parameter would display YY/MM/DD on an empty template
Xfield. The \f2callBackFunction\f1 is where the use can swap out the key 
Xprocessing element of the widget. If the programmer feels they need to re-map 
Xall, or most, or the key bindings of the entry field, write a function of type
X\f4TEMPLATECB\f1 and call the entry widget using this function instead of the 
Xdefault. The current default function is \f4CDKTemplateCallBack\f1. The \f2box\f1 
Xparameter states whether the widget will be drawn with a box around it or not.
XThe \f2shadow\f1 parameter accepts a boolean value to turn the shadow on or off
Xaround this widget. The \f2box\f1 parameter states whether the widget will
Xbe drawn with a box around it or not. The \f2shadow\f1 parameter accepts a 
Xboolean value to turn the shadow on or off around this widget. If the widget
Xcould not be created then a NULL pointer is returned.
X.IP "char *activateCDKTemplate (\f2template\f1);" 3
XThis function activates the template widget and lets the user interact with the
Xwidget. The only parameter this function requires is the \f2template\f1 widget
Xpointer. This function returns a \f4char *\f1 of the information which was typed in
Xthe field.
X.IP "void setCDKTemplate (\f2template\f1, \f2value\f1, \f2box\f1);" 3
XThis function lets the programmer modify certain elements of an already defined
Xtemplate widget. The parameter names correspond to the same parameter names listed
Xin the \f4newCDKTemplate\f1 function.
X.IP "void drawCDKTemplate(\f2template\f1, \f2box\f1);" 3
XThis function draws the template widget on the screen. The \f2box\f1 option 
Xdraws the widget with or without a box.
X.IP "void eraseCDKTemplate (\f2template\f1);" 3
XThis function removes the widget from the screen. This does \f4NOT\f1 destroy
Xthe widget.
X.IP "void cleanCDKTemplate (\f2template\f1);" 3
XThis function clears the information from the field.
X.IP "char *mixCDKTemplate (\f2template\f1);" 3
XThis function returns a \f4char *\f1 pointer to the field value and the 
Xoverlay.
X.IP "char *unmixCDKTemplate (\f2template\f1);" 3
XThis function returns a \f4char *\f1 pointer to the field value without any
Xoverlay characters.
X.IP "void destroyCDKTemplate (\f2template\f1);" 3
XThis function removes the widget from the screen and frees up any memory the
Xobject may be using.
X.IP "void bindCDKObject (\f2widgetType\f1, \f2object\f1, \f2key\f1, \f2function\f1, \f2data\f1);" 3
XThis function allows the user to create special key bindings. The \f2widgetType\f1
Xparameter is a defined type which states what Cdk object type is being used.
XTo learn more about the type \f4EObjectType\f1 read the \f2cdk_binding\f1 manual
Xpage. The \f2object\f1 parameter is the pointer to the widget object. The
X\f2key\f1 is the character to bind. The \f2function\f1 is the function type. To
Xlearn more about the key binding callback function types read the \f4cdk_binding\f1
Xmanual page. The last parameter \f2data\f1 is a pointer to any data that needs
Xto get passed to the callback function.
X.SH KEY BINDINGS
XWhen the widget is activated there are several default key bindings which will
Xhelp the user enter or manipulate the information quickly. The following table
Xoutlines the keys and their actions for this widget.
X.LP
X.nf
X\f2Key          Action\f1
XDelete      Deletes the character to the left of the cursor.
XBackspace   Deletes the character to the left of the cursor.
XReturn      Exits the widget and returns a char * representing
X            the information which was typed into the field.
XTab         Exits the widget and returns a char * representing
X            the information which was typed into the field.
XCtrl-N      Exits the widget and returns a char * representing
X            the information which was typed into the field.
XCtrl-R      Refreshes the screen.
X.fi
X.SH SEE ALSO
X.BR cdk (3X),
X.BR cdk_screen (3X),
X.BR cdk_display (3X),
X.BR cdk_binding (3X)
X.SH NOTES
X.PP
XThe header file \f4<cdk.h>\f1 automatically includes the header files
X\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
X\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
X\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
XThe \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
X.PP
XIf you have \f4ncurses\f1 installed on your machine add -DNCURSES to the 
Xcompile line to include the ncurses header files instead.
SHAR_EOF
  $shar_touch -am 1229121195 'cdk-4.6.0/man/template.3x' &&
  chmod 0400 'cdk-4.6.0/man/template.3x' ||
  echo 'restore of cdk-4.6.0/man/template.3x failed'
  shar_count="`wc -c < 'cdk-4.6.0/man/template.3x'`"
  test 8356 -eq "$shar_count" ||
    echo "cdk-4.6.0/man/template.3x: original size 8356, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk-4.6.0/man/viewer.3x ==============
if test -f 'cdk-4.6.0/man/viewer.3x' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk-4.6.0/man/viewer.3x (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk-4.6.0/man/viewer.3x (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk-4.6.0/man/viewer.3x' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH cdk_viewer 3X "05 Dec 1995"
X.SH NAME
XnewCDKViewer, activateCDKViewer, manageCDKViewer, setCDKViewer, drawCDKViewer,
XeraseCDKViewer, destroyCDKViewer \- Creates a managed curses viewer list widget.
X.SH SYNOPSIS
X.LP
X.B cc
X.RI "[ " "flag" " \|.\|.\|. ] " "file" " \|.\|.\|."
X.B \-lcdk
X.RI "[ " "library" " \|.\|.\|. ]"
X.LP
X#include <cdk.h>
X.LP
X.BI "CDKVIEWER *newCDKViewer (CDKSCREEN *" "cdkscreen",
X.BI "int " "xpos",
X.BI "int " "ypos",
X.BI "int " "height",
X.BI "int " "width",
X.BI "char **" "buttonList",
X.BI "int " "buttonCount",
X.BI "boolean " "box",
X.BI "boolean " "shadow");
X.LP
X.BI "int activateCDKViewer (CDKVIEWER *" "viewer",
X.BI "char *" "title",
X.BI "char **" "info",
X.BI "int " "infoSize",
X.BI "chtype " "buttonAttribute",
X.BI "boolean " "interpret",
X.BI "boolean " "box");
X.LP
X.BI "int manageCDKViewer (CDKVIEWER *" "viewer");
X.LP
X.BI "void setCDKViewer (CDKVIEWER *" "viewer",
X.BI "int " "buttonAttribute",
X.BI "boolean " "box");
X.LP
X.BI "void drawCDKViewer (CDKVIEWER *" "viewer",
X.BI "boolean " "box");
X.LP
X.BI "void eraseCDKViewer (CDKVIEWER *" "viewer");
X.LP
X.BI "void destroyCDKViewer (CDKVIEWER *" "viewer");
X.LP
X.BI "void bindCDKObject (EObjectType " "widgetType",
X.BI "void *" "object",
X.BI "chtype " "key",
X.BI "BINDFN " "function",
X.BI "void *" "data");
X.SH DESCRIPTION
XThe Cdk viewer widget creates a file viewer widget. This widget allows a user to
Xinteract with a file. It does \f4NOT\f1 allow editing, this is view only. The
Xfollowing are functions which create or manipulate the Cdk viewer list widget.
X.nf
X.IP "CDKVIEWER *newCDKViewer (\f2screen\f1, \f2xpos\f1, \f2ypos\f1, \f2height\f1, \f2width\f1, \f2buttons\f1, \f2buttonCount\f1, \f2box\f1, \f2shadow\f1);" 3
X.fi
X.IP "" 3
XThis function call creates a pointer to a viewer widget. The parameter
X\f2screen\f1 is of type CDKSCREEN. The parameter \f2xpos\f1 controls the
Xplacement of the object along the horizontal axis; which means it can take an 
Xinteger value or the predefined values of \f4LEFT\f1, \f4RIGHT\f1, and
X\f4CENTER\f1. The parameter \f2ypos\f1 controls the placement of the object 
Xalong the vertical axis which means it can accept an integer value or a 
Xpredefined value of \f4TOP\f1, \f4BOTTOM\f1, and \f4CENTER\f1. The parameters
X\f2height\f1 and \f2width\f1 state how tall and wide the viewer window is to be.
XThe \f2buttons\f1 is an array of the button labels which are to be attached to
Xthe viewer on the bottom; \f2buttonCount\f1 tells the viewer how many buttons
Xthere are. The \f2box\f1 parameter states whether the widget will be drawn with
Xa box around it or not. The \f2shadow\f1 parameter accepts a boolean value to
Xturn the shadow on or off around this widget. If the widget could not be created
Xthen a NULL pointer is returned.
X.IP "int activateCDKViewer (\f2viewer\f1, \f2title\f1, \f2info\f1, \f2infoSize\f1, \f2buttonAttribute\f1, \f2interpret\f1, \f2box\f1);" 3
XThis is the only activate function in Cdk which actually takes parameters to 
Xdictate the personality of the widget. Since this is a complex widget, this was
Xthe only way to do it. The parameter \f2title\f1 is the title to be displayed on
Xthe top of the viewer. The parameter \f2info\f1 is the information to display,
Xwhile \f2infoSize\f1 states how many rows there are in the \f2info\f1 array.
XThe parameter \f2buttonAttribute\f1 states the attribute of the current
Xhighlighted button. The boolean parameter \f2interpret\f1 tells the viewer to 
Xinterpret the contents of \f2info\f1 for Cdk display command, or not. The
Xparameters \f2box\f1 and \f2shadow\f1 are the same as in the function
Xdescription of \f4newCDKViewer\f1.
X.IP "int manageCDKViewer (\f2viewer\f1);" 3
XThis function allows the programmer to 'reactivate' an already defined and
Xactivated viewer widget. If for some reason the programmer needs to leave an
Xactive viewer widget, calling this function will reactivate the widget without
Xhaving to send in a lot of parameters. The viewer will resume where it left off.
X.IP "void setCDKViewer (\f2viewer\f1, \f2buttonAttribute\f1, \f2box\f1);" 3
XThis function lets the programmer modify certain elements of an already defined
Xviewer widget. The parameter names correspond to the same parameter names listed
Xin the \f4newCDKViewer\f1 function.
X.IP "void drawCDKViewer(\f2viewer\f1, \f2box\f1);" 3
XThis function draws the viewer widget on the screen. The \f2box\f1 option 
Xdraws the widget with or without a box.
X.IP "void eraseCDKViewer (\f2viewer\f1);" 3
XThis function removes the widget from the screen. This does \f4NOT\f1 destroy
Xthe widget.
X.IP "void destroyCDKViewer (\f2viewer\f1);" 3
XThis function removes the widget from the screen and frees up any memory the
Xobject may be using.
X.IP "void bindCDKObject (\f2widgetType\f1, \f2object\f1, \f2key\f1, \f2function\f1, \f2data\f1);" 3
XThis function allows the user to create special key bindings. The \f2widgetType\f1
Xparameter is a defined type which states what Cdk object type is being used.
XTo learn more about the type \f4EObjectType\f1 read the \f2cdk_binding\f1 manual
Xpage. The \f2object\f1 parameter is the pointer to the widget object. The
X\f2key\f1 is the character to bind. The \f2function\f1 is the function type. To
Xlearn more about the key binding callback function types read the \f4cdk_binding\f1
Xmanual page. The last parameter \f2data\f1 is a pointer to any data that needs
Xto get passed to the callback function.
X.SH KEY BINDINGS
XWhen the widget is activated there are several default key bindings which will
Xhelp the user enter or manipulate the information quickly. The following table
Xoutlines the keys and their actions for this widget.
X.LP
X.nf
X\f2Key          Action\f1
XLeft Arrow  Shifts the contents of the viewer one character left.
XRight Arrow Shifts the contents of the viewer one character left
XUp Arrow    Scrolls the contents of the viewer one line up.
XDown Arrow  Scrolls the contents of the viewer one line up.
XPrev Page   Moves one page backwards.
XCtrl-B      Moves one page backwards.
XB           Moves one page backwards.
Xb           Moves one page backwards.
XNext Page   Moves one page forwards.
XCtrl-F      Moves one page forwards.
XSpace       Moves one page forwards.
XF           Moves one page forwards.
Xf           Moves one page forwards.
XHome        Shifts the whole list to the far left.
X|           Shifts the whole list to the far left.
XEnd         Shifts the whole list to the far right
X$           Shifts the whole list to the far right.
Xg           Moves to the first line in the viewer.
X1           Moves to the first line in the viewer.
XG           Moves to the last line in the viewer.
XL           Moves half the distance to the end of the viewer.
Xl           Moves half the distance to the top of the viewer.
X?           Searches up for a pattern.
X/           Searches down for a pattern.
Xn           Repeats last search.
X:           Jumps to a given line.
Xi           Displays file statistics.
Xs           Displays file statistics.
XReturn      Exits the viewer list and returns an integer
X            representing the currently selected button.
XCtrl-N      Exits the viewer list and returns an integer
X            representing the currently selected button.
XCtrl-R      Refreshes the screen.
X.fi
X.SH SEE ALSO
X.BR cdk (3X),
X.BR cdk_screen (3X),
X.BR cdk_display (3X),
X.BR cdk_binding (3X)
X.SH NOTES
X.PP
XThe header file \f4<cdk.h>\f1 automatically includes the header files
X\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
X\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
X\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
XThe \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
X.PP
XIf you have \f4ncurses\f1 installed on your machine add -DNCURSES to the 
Xcompile line to include the ncurses header files instead.
SHAR_EOF
  $shar_touch -am 1229121195 'cdk-4.6.0/man/viewer.3x' &&
  chmod 0400 'cdk-4.6.0/man/viewer.3x' ||
  echo 'restore of cdk-4.6.0/man/viewer.3x failed'
  shar_count="`wc -c < 'cdk-4.6.0/man/viewer.3x'`"
  test 7865 -eq "$shar_count" ||
    echo "cdk-4.6.0/man/viewer.3x: original size 7865, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk-4.6.0/man/cdk.3x ==============
if test -f 'cdk-4.6.0/man/cdk.3x' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk-4.6.0/man/cdk.3x (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk-4.6.0/man/cdk.3x (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk-4.6.0/man/cdk.3x' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH Cdk 3X "05 Dec 1995"
X.SH NAME
X   Cdk - \f2Curses Development Kit\f1
X.LP
X.SH SYNOPSIS
X.LP
X.B cc
X.RI "[ " "flag" " \|.\|.\|. ] " "file" " \|.\|.\|."
X.B \-lcdk
X.RI "[ " "library" " \|.\|.\|. ]"
X.LP
X#include <cdk.h>
X.LP
XCdk provides functions to use a large number of predefined
Xcurses widgets. To use the Cdk widgets the header file \f4cdk.h\f1 must be 
Xincluded the source.
X.LP
XThe widgets available from Cdk are listed below.
X
X.nf
X\f2Widget Type                 Manual Page Name\f1
XEntry Field                 cdk_entry (3X)
XMultiple Line Entry Field   cdk_mentry (3X)
XLabel                       cdk_label (3X)
XScrolling List              cdk_scroll (3X)
XDialog                      cdk_dialog (3X)
XNumeric Scale               cdk_scale (3X)
XMarquee                     cdk_marquee (3X)
XPulldown Menu               cdk_menu (3X)
XMatrix                      cdk_matrix (3X)
XHistogram                   cdk_histogram (3X)
XScrolling Selection List    cdk_selection (3X)
XFile Viewer                 cdk_viewer (3X)
XGraph                       cdk_graph (3X)
XRadio List                  cdk_radio (3X)
XTemplate                    cdk_template (3X)
XScrolling Window            cdk_swindow (3X)
XItem List                   cdk_itemlist (3X)
X
XThe rest of the manual pages are
X\f2Manual Page Name            Description\f1
Xcdk_screen (3X)             Demonstrates the use of screens  
X                            within Cdk.
Xcdk_binding (3X)            Outlines how to create user definable
X                            key bindings.
Xcdk_display (3X)            Shows how to add special display
X                            attributes, colors, and justification
X                            into a widget.
Xcdk_draw (3X)               Outlines the basic draw capabilities of
X                            Cdk.
X.fi
X
X.SH DESCRIPTION
XCdk is a library of functions which allow a programmer to quickly create a 
Xfull screen interactive program with little ease. The Cdk widgets support the 
Xfollowing features:
X.It "\(bu Ncurses library." 5
XInstead of using the standard curses library, Cdk can take advantage of the
Xcolors that ncurses provides. To learn how to take advantage of Cdk's color
Xcapabilities, read the \f4cdk_display\f1 manual page.
X.PP
X.It "\(bu Key Bindings." 5
XIndividual keys can be overridden with a callback. The callback is setup using
Xthe \f4bindCDKObject\f1 function. To learn more about this read the
X\f4cdk_binding\f1 manual page.
X.PP
X.It "\(bu Special Display Formats" 5
XThere are special character format commands that can be inserted into any 
Xstring in Cdk and the contents will get mapped to a \f4chtype\f1 (see the
Xcurses manual page) with character attributes. This allows the programmer to 
Xinsert format types on each character if they wish.
X.PP
X.It "\(bu The Ability To Build Predefined Screens" 5
XWidgets can be associated to any given screen. If there is more than one 
Xscreen defined, then Cdk has the ability to "flip" from one screen to another
Xwith ease. See the \f4cdk_screen\f1 manual page for more details.
X.PP
X
X.SH SEE ALSO
X.BR cdk (3X),
X.BR cdk_screen (3X),
X.BR cdk_display (3X),
X.BR cdk_binding (3X)
X.SH NOTES
X.PP
XThe header file \f4<cdk.h>\f1 automatically includes the header files
X\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
X\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
X\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
XThe \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
X.PP
XIf you have \f4ncurses\f1 installed on your machine add -DNCURSES to the 
Xcompile line to include the ncurses header files instead.
SHAR_EOF
  $shar_touch -am 1229121195 'cdk-4.6.0/man/cdk.3x' &&
  chmod 0400 'cdk-4.6.0/man/cdk.3x' ||
  echo 'restore of cdk-4.6.0/man/cdk.3x failed'
  shar_count="`wc -c < 'cdk-4.6.0/man/cdk.3x'`"
  test 3709 -eq "$shar_count" ||
    echo "cdk-4.6.0/man/cdk.3x: original size 3709, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk-4.6.0/man/screen.3x ==============
if test -f 'cdk-4.6.0/man/screen.3x' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk-4.6.0/man/screen.3x (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk-4.6.0/man/screen.3x (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk-4.6.0/man/screen.3x' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH cdk_screen 3X "05 Dec 1995"
X.SH NAME
XinitCDKScreen, initCDKColor, registerCDKObject, unregisterCDKObject,
XraiseCDKObject, lowerCDKObject, refreshCDKScreen, eraseCDKScreen,
XdestroyCDKScreen, endCDK - Cdk Screen and Widget Manipulation Functions
X.SH SYNOPSIS
X.LP
X.B cc
X.RI "[ " "flag" " \|.\|.\|. ] " "file" " \|.\|.\|."
X.B \-lcdk
X.RI "[ " "library" " \|.\|.\|. ]"
X.LP
X#include <cdk.h>
X.LP
X.BI "CDKSCREEN *initCDKScreen (WINDOW *" "cursesWindow ");
X.LP
X.BI "void initCDKColor ()";
X.LP
X.BI "void registerCDKObject (CDKSCREEN *" "screen ",
X.BI "EObjectType " "widgetType ",
X.BI "void *" "object");
X.LP
X.BI "void unregisterCDKObject(EObjectType " "widgetType ",
X.BI "void *" "object");
X.LP
X.BI "void raiseCDKObject(EObjectType " "widgetType ",
X.BI "void *" "object");
X.LP
X.BI "void lowerCDKObject(EObjectType " "widgetType ",
X.BI "void *" "object");
X.LP
X.BI "void refreshCDKScreen(CDKSCREEN *" "screen");
X.LP
X.BI "void eraseCDKScreen(CDKSCREEN *" "screen");
X.LP
X.BI "void destroyCDKScreen(CDKSCREEN *" "screen");
X.LP
X.BI "void endCDK()";
X.LP
X.SH DESCRIPTION
XOne of the features of Cdk is that it will manage all of the widgets for you.
XThese functions perform some of the management of the widgets in a screen. The
Xfollowing outline each function and it's purpose.
X.IP "CDKSCREEN *initCDKScreen (\f2cursesWindow\f1);" 3
XThis function takes a \f4WINDOW *\f1 (\f2cursesWindow\f1) and returns a pointer to
Xa \f2CDKSCREEN *\f1. Since all of the widgets take a \f2CDKSCREEN\f1 pointer as
Xa first argument, this is also one of the first calls made. This also starts 
Xcurses, so no curses calls have to be made when using Cdk.
X.IP "void initCDKColor ()" 3
XThis call starts the Cdk color capabilities. It defines 64 color pairs each
Xof which is accessible using the COLOR_PAIR macro. If you do not have color
Xsupport, this function call makes no difference.
X.IP "void registerCDKObject (\f2screen\f1, \f2widgetType\f1, \f2object\f1);" 3
XThis function is called automatically when a widget is created. If for some
Xreason an object does get unregistered, by calling \f4unregisterCDKObject\f1, the
Xwidget can be registered again by calling this function. The \f2widgetType\f1
Xparameter states what Cdk widget type this object is. The \f2object\f1 parameter
Xis a void pointer to the object.
X.IP "void unregisterCDKObject (\f2cdktype\f1, \f2object\f1);" 3
XThis function removes the widget from the screen. This does \f4NOT\f1 destroy the
Xobject, it mearly removes the widget from any further refreshes by the function
X\f4refreshCDKScreen\f1. The \f2widgetType\f1 parameter states what Cdk widget 
Xtype this object is. The \f2object\f1 parameter is a void pointer to the object.
X.IP "void raiseCDKObject (\f2cdktype\f1, \f2object\f1);" 3
XThis function raises the widget to the top of the screen. If there are any 
Xwidgets which overlap the given object when a refresh is done, calling this
Xfunction has the effect of raiding the object so no other widgets obstruct 
Xit. The \f2widgetType\f1 parameter states what Cdk widget type this object is.
XThe \f2object\f1 parameter is a void pointer to the object.
X.IP "void lowerCDKObject (\f2cdktype\f1, \f2object\f1);" 3
XThis function has the opposite effect of the \f4raiseCDKObject\f1 function
Xcall.
X.IP "void refreshCDKScreen (\f2screen\f1);" 3
XThis function redraws all of the widgets which are currently associated to the
Xgiven screen.
X.IP "void eraseCDKScreen (\f2screen\f1);" 3
XThis function erases all of the widgets which are currently associated to the
Xgiven screen. This does \f4NOT\f1 destroy the widgets.
X.IP "void destroyCDKScreen (\f2screen\f1);" 3
XThis function destroys any memory allocated by the Cdk screen pointer.
X.IP "void endCDK();" 3
XThis function shuts down curses.
X.SH SEE ALSO
X.BR cdk (3X),
X.BR cdk_display (3X),
X.BR cdk_binding (3X)
X.SH NOTES
X.PP
XThe header file \f4<cdk.h>\f1 automatically includes the header files
X\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
X\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
X\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
XThe \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
X.PP
XIf you have \f4ncurses\f1 installed on your machine add -DNCURSES to the 
Xcompile line to include the ncurses header files instead.
SHAR_EOF
  $shar_touch -am 1229121195 'cdk-4.6.0/man/screen.3x' &&
  chmod 0400 'cdk-4.6.0/man/screen.3x' ||
  echo 'restore of cdk-4.6.0/man/screen.3x failed'
  shar_count="`wc -c < 'cdk-4.6.0/man/screen.3x'`"
  test 4367 -eq "$shar_count" ||
    echo "cdk-4.6.0/man/screen.3x: original size 4367, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk-4.6.0/man/binding.3x ==============
if test -f 'cdk-4.6.0/man/binding.3x' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk-4.6.0/man/binding.3x (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk-4.6.0/man/binding.3x (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk-4.6.0/man/binding.3x' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH cdk_display 3X "05 Dec 1995"
X.SH NAME
XbindCDKObject, unbindCDKObject, checkCDKObjectBind, cleanCDKObjectBindings -
X\f2Curses Development Kit\f1 Character Binding Capabilities.
X.LP
X.SH SYNOPSIS
X.LP
X.B cc
X.RI "[ " "flag" " \|.\|.\|. ] " "file" " \|.\|.\|."
X.B \-lcdk
X.RI "[ " "library" " \|.\|.\|. ]"
X.LP
X#include <cdk.h>
X.LP
X.BI "void bindCDKObject (EObjectType" "cdkType",
X.BI "void *" "object",
X.BI "chtype " "key",
X.BI "BINDFN " "function",
X.BI "void *" "data");
X.LP
X.BI "void unbindCDKObject (EObjectType " "cdkType",
X.BI "void *" "object",
X.BI "chtype " "key");
X.LP
X.BI "void checkCDKObjectBind (EObjectType " "cdkType",
X.BI "void *" "object",
X.BI "chtype " "key");
X.LP
X.BI "void cleanCDKObjectBindings (EObjectType " "cdkType",
X.BI "void *" "object");
X.LP
X.SH DESCRIPTION
XCdk has the ability to create user definable key bindings. This ability makes
XCdk more dynamic and usable for a wide variety of tasks. The following section
Xoutlines the binding functions, their use, and their purpose.
X.IP "void bindCDKObject (\f2cdkType\f1, \f2object\f1, \f2key\f1, \f2function\f1, \f2data\f1);" 3
XThis function creates a key binding between a specific Cdk widget (\f2object\f1)
Xgiven key (\f2key\f1). The parameter \f2cdkType\f1 is of type \f4EObjectType\f1
Xwhich is one of the following values.
X.LP
X.nf
X\f2EObjectType Value   Corresponding Widget         Widget Manual Page\f1
XvENTRY              Entry Widget                 cdk_entry (3X)
XvMENTRY             Multiple Line Entry Widget   cdk_mentry (3X)
XvLABEL              Label Widget                 cdk_label (3X)
XvSCROLL             Scrolling List Widget        cdk_scroll (3X)
XvDIALOG             Dialog Widget                cdk_dialog (3X)
XvSCALE              Numeric Scale Widget         cdk_scale (3X)
XvMARQUEE            Marquee Widget               cdk_marquee (3X)
XvMENU               Menu Widget                  cdk_menu (3X)
XvMATRIX             Matrix Widget                cdk_matrix (3X)
XvHISTOGRAM          Histogram Widget             cdk_histogram (3X)
XvSELECTION          Selection List Widget        cdk_selection (3X)
XvVIEWER             Viewer Widget                cdk_viewer (3X)
XvGRAPH              Graph Widget                 cdk_graph (3X)
XvRADIO              Radio List Widget            cdk_radio (3X)
XvTEMPLATE           Templated Entry Widget       cdk_template (3X)
XvSWINDOW            Scrolling Window Widget      cdk_swindow (3X)
XvITEMLIST           Item List Widget             cdk_itemlist (3X)
X.fi
X.IP "" 3
XThe parameter \f2function\f1 is of type \f4BINDFN\f1 which has the following
Xprototype:
X.LP
X\f4void function (EObjectType cdktype, void *object, void *clientData);\f1
X.LP
XThe parameter \f2data\f1 is a \f4void *\f1 pointer to whatever data the callback
Xfunction may need.
X.IP "void unbindCDKObject (\f2cdkType\f1, \f2object\f1, \f2key\f1);" 3
XThis function removes a specific binding to an object. The parameter names are
Xthe same as the description of the function \f4bindCDKObject\f1.
X.IP "int checkCDKObjectBind (\f2cdkType\f1, \f2object\f1, \f2key\f1);" 3
XThis function returns an integer value stating whether the key \f2key\f1 has
Xbeen bound to the given widget, \f2object\f1.
X.IP "void cleanCDKObjectBindings (\f2cdkType\f1, \f2object\f1);" 3
XThis function removes all user defined key bindings from the given widget.
X.SH SEE ALSO
X.BR cdk (3X),
X.BR cdk_screen (3X),
X.BR cdk_display (3X)
X.SH NOTES
XThe header file \f4<cdk.h>\f1 automatically includes the header files
X\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
X\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
X\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
XThe \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
SHAR_EOF
  $shar_touch -am 1229121195 'cdk-4.6.0/man/binding.3x' &&
  chmod 0400 'cdk-4.6.0/man/binding.3x' ||
  echo 'restore of cdk-4.6.0/man/binding.3x failed'
  shar_count="`wc -c < 'cdk-4.6.0/man/binding.3x'`"
  test 3832 -eq "$shar_count" ||
    echo "cdk-4.6.0/man/binding.3x: original size 3832, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk-4.6.0/man/display.3x ==============
if test -f 'cdk-4.6.0/man/display.3x' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk-4.6.0/man/display.3x (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk-4.6.0/man/display.3x (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk-4.6.0/man/display.3x' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH cdk_display 3X "05 Dec 1995"
X.SH NAME
X   Cdk - \f2Curses Development Kit\f1 Display Capabilities.
X.LP
X.SH SYNOPSIS
XCdk has a number of predefined display types which need explaining. This
Xmanual page will explain all of the display types and how to use them. The
Xfollowing lists which display types will be outlined in this manual page.
X.It "\(bu How To Use Colors" 5
X.It "\(bu How To Use Different Character Attributes" 5
X.It "\(bu How To Justify Strings" 5
X.SH DESCRIPTION
XCdk has special formatting commands which can be included in any string which
Xadd highlights, justification, or even colors to a basic string. This manual
Xpage outlines and demonstrates how they work. 
X.IP "\f2How To Use Colors\f1" 3
XCdk has the capability to display colors in almost every string type displayed
Xin a Cdk widget. To turn on colors, the function \f4initCDKColor\f1 has to be
Xcalled. When this function is called 64 color pairs are created. Normally the
Xcolor pairs are accessed via the COLOR_PAIR macro. You can still do this, but
Xcreating a string with multiple colors get terribly difficult. That is why
Xthe color commands were created. The color settings are stored directly in the
Xstring and when the widget is created or activated, the string is converted
Xto take advantage of any color commands in the string. To turn on a color pair
Xinsert </XX> into the string; where \f4XX\f1 is a numeric value from 0 to 64.
XColor pair 0 is the standard default color pair for the screen. To turn off a
Xcolor pair use the format command <!XX> where \f4XX\f1 is a numeric value from
X0 to 64. The following code segment demonstrates the use of the color commands.
X.LP
X.nf
X\f4--------------------------------------------------------------\f1
X#include <cdk.h>
X
Xvoid main()
X{
X   CDKSCREEN	*cdkscreen;
X   WINDOW	*cursesWindow;
X   CDKLABEL	*demo;
X   char		*mesg[4];
X
X   /* Initialize the Cdk screen.	*/
X   cursesWindow = initscr();
X   cdkscreen = initCDKScreen(cursesWindow);
X
X   /* Set the labels up.		*/
X   mesg[0] = "</1>This line should have a yellow foreground and a blue background.<!1>";
X   mesg[1] = "</2>This line should have a white  foreground and a blue background.<!2>";
X   mesg[2] = "</3>This line should have a yellow foreground and a red  background.<!3>";
X   mesg[3] = "<C>This line should be set to whatever the screen default is.";
X
X   /* Declare the labels.	*/
X   demo	= newCDKLabel (cdkscreen, CENTER, CENTER, mesg, 4, TRUE, TRUE);
X
X   /* Draw the label		*/
X   drawCDKLabel ( demo, TRUE );
X   waitCDKLabel (demo, ' ');
X
X   /* Clean up			*/
X   destroyCDKLabel (demo);
X   destroyCDKScreen (cdkscreen);
X   endCDK();
X   exit (0);
X}
X.fi
X\f4--------------------------------------------------------------\f1
X.IP "" 3
XThis example uses the color pair 5 (which is white on blue) for the label to
Xthe entry widget.
X.IP "\f2How To Use Different Character Attributes\f1" 3
XCdk also provides attribute commands which allow different character attributes
Xto be displayed in a Cdk widget. To use a character attribute the format command
Xis </X> where \f4X\f1 is one of several command characters. To turn a attribute 
Xoff use the command <!X>. The following table outlines the command characters
Xand what they mean.
X.LP
X.nf 
X\f2Command Character      Character Attribute\f1
XB                      Bold 
XU                      Underline
XK                      Blink
XR                      Reverse
XS                      Standout
XD                      Dim
XN                      Normal
X.fi
X.IP "" 3
XThe following code segment demonstrates the use of character display attributes.
X.nf
X\f4--------------------------------------------------------------\f1
X#include <cdk.h>
X
Xvoid main()
X{
X   CDKSCREEN	*cdkscreen;
X   CDKLABEL	*demo;
X   char		*mesg[4];
X
X   /* Initialize the Cdk screen.	*/
X   cdkscreen = initCDKScreen( initscr() );
X
X   /* Set the labels up.		*/
X   mesg[0] = "</B/1>This line should have a yellow foreground and a blue background.<!1>";
X   mesg[1] = "</U/2>This line should have a white  foreground and a blue background.<!2>";
X   mesg[2] = "</K/3>This line should have a yellow foreground and a red  background.<!3>";
X   mesg[3] = "<C>This line should be set to whatever the screen default is.";
X
X   /* Declare the labels.	*/
X   demo	= newCDKLabel (cdkscreen, CENTER, CENTER, mesg, 4, TRUE, TRUE);
X
X   /* Draw the label		*/
X   drawCDKLabel ( demo, TRUE );
X   waitCDKLabel (demo, ' ');
X
X   /* Clean up			*/
X   destroyCDKLabel (demo);
X   destroyCDKScreen (cdkscreen);
X   endCDK();
X   exit (0);
X}
X\f4--------------------------------------------------------------\f1
X.fi
X.IP "" 3
XNotice that color commands and format commands can be mixed inside the same
Xformat marker. The above example underlines the label marker, which is set to
Xcolor pair number 5.
X.IP "How To Justify Strings" 3
XThe last format marker which can be used are justification commands. Justification
Xcommands can left justify, right justify, or center a string of text. To use a
Xjustification format in a string the command <X> is used. The following table
Xlists all of the format commands available.
X.LP
X.nf 
X\f2Justification Command    Action.\f1
X<L>                      Left Justified. Default if not stated.
X<C>                      Centered text.
X<R>                      Right justified.
X<I=X>                    Bullet. X is the bullet string to use.
X.fi
X.IP "" 3
XThe following code segment demonstrates how to use the justification commands
Xin a Cdk widget.
X\f4--------------------------------------------------------------\f1
X#include <cdk.h>
X
Xvoid main()
X{
X   CDKSCREEN	*cdkscreen;
X   CDKLABEL	*demo;
X   char		*mesg[4];
X
X   /* Initialize the Cdk screen.	*/
X   cdkscreen = initCDKScreen( initscr() );
X
X   /* Set the labels up.		*/
X   mesg[0] = "<R></B/1>This line should have a yellow foreground and a blue background.<!1>";
X   mesg[1] = "</U/2>This line should have a white  foreground and a blue background.<!2>";
X   mesg[2] = "<I=+>This is a bullet.";
X   mesg[3] = "<C>This line should be set to whatever the screen default is.";
X
X   /* Declare the labels.	*/
X   demo	= newCDKLabel (cdkscreen, CENTER, CENTER, mesg, 4, TRUE, TRUE);
X
X   /* Draw the label		*/
X   drawCDKLabel ( demo, TRUE );
X   waitCDKLabel (demo, ' ');
X
X   /* Clean up			*/
X   destroyCDKLabel (demo);
X   destroyCDKScreen (cdkscreen);
X   endCDK();
X   exit (0);
X}
X.fi
X\f4--------------------------------------------------------------\f1
XThe bullet format command can take either a single character or a string.
XThe bullet in the the above example would look like
X.LP
X   \f4+\f1 This is a bullet.
X.LP
Xbut if we were to use the command
X.LP
X<I=***>This is a bullet.
X.LP
Xinstead it would look like
X.LP
X   \f4***\f1 This is a bullet.
X
X.SH SEE ALSO
X.BR cdk (3X),
X.BR cdk_screen (3X),
X.BR cdk_binding (3X)
X.SH NOTES
XThe header file \f4<cdk.h>\f1 automatically includes the header files
X\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
X\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
X\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
XThe \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
SHAR_EOF
  $shar_touch -am 1229121195 'cdk-4.6.0/man/display.3x' &&
  chmod 0400 'cdk-4.6.0/man/display.3x' ||
  echo 'restore of cdk-4.6.0/man/display.3x failed'
  shar_count="`wc -c < 'cdk-4.6.0/man/display.3x'`"
  test 7178 -eq "$shar_count" ||
    echo "cdk-4.6.0/man/display.3x: original size 7178, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk-4.6.0/cdk.c ==============
if test -f 'cdk-4.6.0/cdk.c' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk-4.6.0/cdk.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk-4.6.0/cdk.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk-4.6.0/cdk.c' &&
X#include "cdk.h"
X
X/*
X * $Author: glover $
X * $Date: 1995/12/10 18:38:39 $
X * $Revision: 1.90 $
X */
X
X/* This beeps then flushes the stdout stream.			*/
Xvoid Beep()
X{
X   beep();
X   fflush (stdout);
X}
X
X/* This is my 'own' version of bzero.				*/
Xvoid cleanChar (char *s, int len, char character)
X{
X   int x;
X   for (x=0; x < len; x++)
X   {
X      s[x] = character;
X   }
X   s[--x] = '\0';
X}
Xvoid cleanChtype (chtype *s, int len, chtype character)
X{
X   int x;
X   for (x=0; x < len; x++)
X   {
X      s[x] = character;
X   }
X   s[--x] = '\0';
X}
X
X/*
X * This takes an x and y position and realigns the values iff they sent in
X * values like CENTER, LEFT, RIGHT, ...
X */
Xvoid alignxy (WINDOW *window, int *xpos, int *ypos, int boxwidth, int boxheight)
X{
X   /* Justify the X position, if we need to.			*/
X   if ((*xpos) == LEFT)
X   {
X      (*xpos) = window->_begy + 1;
X   }
X   else if ((*xpos) == RIGHT)
X   {
X      (*xpos) = (window->_maxx - boxwidth) + window->_begy - 1;
X   }
X   else if ((*xpos) == CENTER)
X   {
X      (*xpos) = (int)(((window->_maxx)-boxwidth) / 2) + window->_begy;
X   }
X   else
X   {
X      /* If we have gone out of bounds, then readjust.		*/
X      if ( ((*xpos) + boxwidth) > window->_maxx)
X      {
X         (*xpos) = (window->_maxx - boxwidth);
X      }
X      else if ( (*xpos) < 0 )
X      {
X         (*xpos) = window->_begy + 1;
X      }
X   }
X
X   /* Justify the Y position, if we need to.			*/
X   if ((*ypos) == TOP)
X   {
X      (*ypos) = window->_begx + 1;
X   }
X   else if ((*ypos) == BOTTOM)
X   {
X      (*ypos) = (window->_maxy) - boxheight + window->_begx - 1;
X   }
X   else if ((*ypos) == CENTER)
X   {
X      (*ypos) = (int)((window->_maxy - boxheight) / 2) + window->_begx;
X   }
X   else
X   {
X      /* If we have gone out of bounds, then readjust		*/
X      if ( ((*ypos) + boxheight) > window->_maxy)
X      {
X         (*ypos) = (window->_maxy - boxheight);
X      }
X      else if ( (*ypos) < 0 )
X      {
X         (*ypos) = window->_begx + 1;
X      }
X   }
X}
X
X/*
X * This creates the x and y offset values given the location and size of the
X * given label for the object.
X */
Xvoid alignlabel (char *label, int lplace, int fieldwidth, int *boxwidth, int *boxheight, int *labelxoffset, int *labelyoffset, int *fieldxoffset, int *fieldyoffset)
X{
X   /* Declare local variables.					*/
X   int labelLength	= strlen (label);
X
X   /* Set the offset values.					*/
X   if (lplace == LEFT)
X   { 
X      (*boxwidth)	= fieldwidth + labelLength + 3;
X      (*labelxoffset)	= 1;
X      (*labelyoffset)	= 1;
X      (*fieldxoffset)	= labelLength + 2;
X      (*fieldyoffset)	= 1;
X   }
X   else if (lplace == RIGHT)
X   {
X      (*boxwidth)	= fieldwidth + labelLength + 3;
X      (*labelxoffset)	= ((*boxwidth) - labelLength - 1);
X      (*labelyoffset)	= 1;
X      (*fieldxoffset)	= 1;
X      (*fieldyoffset)	= 1;
X   }
X   else if (lplace == TOP)
X   {
X      (*boxwidth)	= (fieldwidth < labelLength ? labelLength : fieldwidth);
X      (*boxwidth)	+= 3;
X      (*boxheight)	= (*boxheight) + 1;
X      (*labelxoffset)	= (int) (((*boxwidth)-labelLength)/2);
X      (*labelyoffset)	= 1;
X      (*fieldyoffset)	= 2;
X      (*fieldxoffset)	= 1;
X   }
X   else if (lplace == BOTTOM)
X   {
X      (*boxwidth)	= (fieldwidth < labelLength ? labelLength : fieldwidth) + 3;
X      (*boxheight)	= (*boxheight) + 1;
X      (*labelxoffset)	= (int) (((*boxwidth)-labelLength)/2);
X      (*labelyoffset)	= (*boxheight)-2;
X      (*fieldxoffset)	= 1;
X      (*fieldyoffset)	= 1;
X   }
X   else
X   {
X     /*
X      * Give me something I don't understand and I 
X      * will choose a default for you ie: LEFT
X      */
X      (*boxwidth)	= fieldwidth + labelLength + 3;
X      (*labelxoffset)	= 1;
X      (*labelyoffset)	= 1;
X      (*fieldxoffset)	= labelLength + 2;
X      (*fieldyoffset)	= 1;
X   }
X}
X
X/*
X * This takes a string, a field width and a justifycation type
X * and returns the justifcation adjustment to make, to fill
X * the justification requirement.
X */
Xint justifyMessage (int width, char *mesg, int justify)
X{
X   int mesglen	= strlen (mesg);
X
X   /* Make sure the message isn't longer than the width.	*/
X   /* If it is, return 0.					*/
X   if (mesglen >= width)
X   {
X      return (0);
X   }
X
X   /* Try to justify the message.				*/
X   if (justify == LEFT)
X   {
X      return (1);
X   }
X   else if (justify == RIGHT)
X   {
X      return ( (width - mesglen));
X   }
X   else if (justify == CENTER)
X   {
X      return ( (int)((width - mesglen) / 2) );
X   }
X   else
X   {
X      return ( justify );
X   }
X}
Xint justifyString (int boxWidth, int mesgLength, int justify)
X{
X   /* Make sure the message isn't longer than the width.	*/
X   /* If it is, return 1.					*/
X   if (mesgLength >= boxWidth)
X   {
X      return (1);
X   }
X
X   /* Try to justify the message.				*/
X   if (justify == LEFT)
X   {
X      return (1);
X   }
X   else if (justify == RIGHT)
X   {
X      return ( (boxWidth - mesgLength - 1) );
X   }
X   else if (justify == CENTER)
X   {
X      return ( (int)((boxWidth - mesgLength) / 2) );
X   }
X   else
X   {
X      return ( justify );
X   }
X}
X
X/*
X * This returns a substring of the given string.
X */
Xchar *substring(char *string, int start, int width)
X{
X   char *newstring	= (char *)NULL;
X   int mesglen		= (strlen (string));
X   int y		= 0;
X   int x		= 0;
X   int lastchar		= 0;
X
X   if (start > mesglen)
X   {
X      return ( newstring );
X   }
X
X   newstring	= (char *)malloc (sizeof (char) * (width+3));
X   cleanChar (newstring, width+3, '\0');
X   if ( (start+width) > mesglen)
X   {
X      lastchar = mesglen;
X   }
X   else
X   {
X      lastchar = width + start;
X   }
X
X   for (x=start; x<=lastchar; x++)
X   {
X      newstring[y++] = string[x];
X   }
X   return ( newstring );
X}
X
X/*
X * This frees a string if it is not null. This is a safety
X * measure. Some compilers let you free a null string. I
X * don't like that idea.
X */
Xvoid freeChar (char *string)
X{
X   if (string != (char *)NULL)
X   {
X      free (string);
X   }
X}
Xvoid freeChtype (chtype *string)
X{
X   if (string != (chtype *)NULL)
X   {
X      free (string);
X   }
X}
X
X/*
X * This performs a safe copy of a string. This means it adds the NULL
X * terminator on the end of the string.
X */
Xchar *copyChar (char *original)
X{
X   /* Declare local variables.					*/
X   char *newstring;
X   int len	= strlen (original);
X
X   /* Create the new string.					*/
X   newstring	= (char *)malloc (sizeof(char) * (len+3));
X   cleanChar (newstring, len+3, '\0');
X
X   /* Copy from one to the other...				*/
X   strcpy (newstring, original);
X
X   /* Return the new string.					*/
X   return (newstring);
X}
Xchtype *copyChtype (chtype *original)
X{
X   /* Declare local variables.					*/
X   chtype *newstring;
X   int len	= chlen (original);
X   int x;
X
X   /* Create the new string.					*/
X   newstring	= (chtype *)malloc (sizeof(chtype) * (len+4));
X   cleanChtype (newstring, len+3, '\0');
X 
X   /* Copy from one to the other...				*/
X   for (x=0; x < len; x++)
X   {
X      newstring[x]	= original[x];
X   }
X
X   /* Return the new string.					*/
X   return (newstring);
X}
X
X
X/*
X * This draws a line in a scrolling list or a selection list.
X */
Xvoid drawScrollItem (WINDOW *win, char *item, int woffset, int hoffset, int voffset, int width, chtype attr)
X{
X   char *tmp = substring(item, voffset, width);
X   if (tmp != (char *)NULL)
X   {
X      printattr (win, hoffset, woffset, HORIZONTAL, attr, tmp);
X      free (tmp);
X   }
X}
X
X/*
X * This reads a file and sticks it into the char ** provided.
X */
Xint readFile (char *filename, char **array, int maxlines)
X{
X   FILE	*fd;
X   char temp[515];
X   int	lines	= 0;
X
X   /* Clean out temp...						*/
X   cleanChar (temp, 514, '\0');
X
X   /* Can we open the file?					*/
X   if ( (fd = fopen (filename, "r")) == NULL)
X   {
X      return (0);
X   }
X                                                                                
X   /* Start reading the file in.				*/
X   while ( (fgets (temp, 512, fd) != (char *)NULL) && lines < maxlines)
X   {
X      int len		= strlen(temp);
X      temp[len]		= '\0';
X      array[lines]	= copyChar (temp);
X      lines++;
X   }
X   fclose (fd);
X
X   /* Clean up and return.					*/
X   array[lines]		= "";
X   return (lines);
X}
X
X/*
X * This function takes a character string, full of format markers
X * and translates them into a chtype * array. This is better suited
X * to curses, because curses uses chtype almost exclusively
X */
Xchtype *char2Chtype (char *string, int *to, int *align)
X{
X   chtype *newstring	= (chtype *)NULL;
X   chtype attrib	= A_NORMAL;
X   int insideMarker	= FALSE;
X   int start		= 0;
X   int from		= 0;
X   int pair		= 0;
X   int x 		= 3;
X   int len		= 0;
X   char temp[5];
X
X   /* Is the string NULL???					*/
X   if ( string == (char *)NULL)
X   {
X      return ( (chtype *)NULL );
X   }
X
X   /* Get the length of the string.				*/
X   len		= strlen(string);
X
X   /* Set up some default values...				*/
X   (*to)		= 0;
X   (*align)		= LEFT;
X   temp[0]		= '\0';
X   pair			= 0;
X
X   /* Lets make sure the string isn't null.			*/
X   if (string == (char *)NULL)
X   {
X      return ( newstring );
X   }
X
X   /* Lets make some room for the chtype string...		*/
X   newstring		= (chtype *)malloc (sizeof(chtype) * (len+4));
X   cleanChtype (newstring, len+4, '\0');
X
X   /* Look for an alignment marker.				*/
X   if (string[0] == '<' && string[1] == 'C' && string[2] == '>')
X   {
X      (*align)	= CENTER;
X      start	= 3;
X   }
X   else if (string[0] == '<' && string[1] == 'R' && string[2] == '>')
X   {
X      (*align)	= RIGHT;
X      start	= 3;
X   }
X   else if (string[0] == '<' && string[1] == 'L' && string[2] == '>')
X   {
X      (*align)	= LEFT;
X      start	= 3;
X   }
X   else if (string[0] == '<' && string[1] == 'T' && string[2] == '>')
X   {
X      (*align)	= TOP;
X      start	= 3;
X   }
X   else if (string[0] == '<' && string[1] == 'B' && string[2] == '>')
X   {
X      (*align)	= BOTTOM;
X      start	= 3;
X   }
X   else if (string[0] == '<' && string[1] == 'I' && string[2] == '=')
X   {
X      /* Set the item index value in the string.		*/
X      newstring[0] = ' '; newstring[1] = ' '; newstring[2] = ' ';
X
X      /* Pull out the bullet marker.				*/
X      while (string[x] != '>')
X      {
X         newstring[x] = string[x] | A_BOLD;
X         x++;
X      }
X      newstring[x++] = ' ';
X
X      /* Set the alignment variables.				*/
X      (*align)	= LEFT;
X      start	= x;
X      (*to)	= x;
X   }
X      
X   /* Set the format marker boolean to false.			*/
X   insideMarker	= FALSE;
X
X   /* Start parsing the character string...			*/
X   for (from=start; from < len; from++)
X   {
X      /* Are we inside a format marker???			*/
X      if ( ! insideMarker )
X      {
X         if (string[from] == '<' && string[from+1] == '/')
X         {
X            insideMarker = 1;
X         }
X         else if (string[from] == '<' && string[from+1] == '!')
X         {
X            insideMarker = 1;
X         }
X         else if (string[from] == '\\' && string[from+1] == '<')
X         {
X            from++;
X            newstring[(*to)++]	= string[from++] | attrib;
X         }
X         else
X         {
X            newstring[(*to)++]	= string[from] | attrib;
X         }
X      }
X      else
X      {
X         /* We are in the format marker.			*/
X         if (string[from] == '>')
X         {
X            insideMarker = 0;
X         }
X         else if (string[from] == '/' && string[from+1] == 'B')
X         {
X            attrib	= attrib | A_BOLD;
X            from++;
X         }
X         else if (string[from] == '!' && string[from+1] == 'B')
X         {
X            attrib	= attrib & (~A_BOLD);
X            from++;
X         }
X         else if (string[from] == '/' && string[from+1] == 'U')
X         {
X            attrib	= attrib | A_UNDERLINE;
X            from++;
X         }
X         else if (string[from] == '!' && string[from+1] == 'U')
X         {
X            attrib	= attrib & (~A_UNDERLINE);
X            from++;
X         }
X         else if (string[from] == '/' && string[from+1] == 'S')
X         {
X            attrib	= attrib | A_STANDOUT;
X            from++;
X         }
X         else if (string[from] == '!' && string[from+1] == 'S')
X         {
X            attrib	= attrib & (~A_STANDOUT);
X            from++;
X         }
X         else if (string[from] == '/' && string[from+1] == 'R')
X         {
X            attrib	= attrib | A_REVERSE;
X            from++;
X         }
X         else if (string[from] == '!' && string[from+1] == 'R')
X         {
X            attrib	= attrib & (~A_REVERSE);
X            from++;
X         }
X         else if (string[from] == '/' && string[from+1] == 'K')
X         {
X            attrib	= attrib | A_BLINK;
X            from++;
X         }
X         else if (string[from] == '!' && string[from+1] == 'K')
X         {
X            attrib	= attrib & (~A_BLINK);
X            from++;
X         }
X         else if (string[from] == '/' && string[from+1] == 'D')
X         {
X            attrib	= attrib | A_DIM;
X            from++;
X         }
X         else if (string[from] == '!' && string[from+1] == 'D')
X         {
X            attrib	= attrib & (~A_DIM);
X            from++;
X         }
X         else if (string[from] == '/' && string[from+1] == 'L')
X         {
X            /* Since this is a link, we need to create */
X#ifdef COLOR
X            attrib	= attrib | A_UNDERLINE | COLOR_PAIR(5);
X#else
X            attrib	= attrib | A_UNDERLINE;
X#endif
X            from++;
X         }
X         else if (string[from] == '!' && string[from+1] == 'L')
X         {
X#ifdef COLOR
X            attrib	= attrib & (~A_UNDERLINE) & (~COLOR_PAIR(5));
X#else
X            attrib	= attrib & (~A_UNDERLINE);
X#endif
X            from++;
X         }
X         else if (string[from] == '/' && isdigit(string[from+1]) && isdigit(string[from+2]) )
X         {
X#ifdef COLOR
X            sprintf (temp, "%c%c", string[from+1],string[from+2]);
X            pair	= atoi(temp);
X            attrib	= attrib | COLOR_PAIR(pair);
X#else
X            from += 2;
X#endif
X         }
X         else if (string[from] == '!' && isdigit(string[from+1]) && isdigit(string[from+2]) )
X         {
X#ifdef COLOR
X            sprintf (temp, "%c%c", string[from+1],string[from+2]);
X            pair	= atoi(temp);
X            attrib	= attrib & (~COLOR_PAIR(pair) );
X#else
X            from += 2;
X#endif
X         }
X         else if (string[from] == '/' && isdigit(string[from+1]) )
X         {
X#ifdef COLOR
X            pair	= string[++from] - '0';
X            attrib	= attrib | COLOR_PAIR(pair);
X#else
X            from++;
X#endif
X         }
X         else if (string[from] == '!' && isdigit(string[from+1]) )
X         {
X#ifdef COLOR
X            pair	= string[++from] - '0';
X            attrib	= attrib & (~COLOR_PAIR(pair) );
X#else
X            from++;
X#endif
X         }
X      }
X   }
X
X   /* Return the new string...					*/
X   return ( newstring );
X}
X
X/*
X * This determines the length of a chtype string
X */
Xint chlen (chtype *string)
X{
X   /* Declare local variables.					*/
X   int x	= 0;
X   while (string[x++] != '\0');
X   return ( (x-1) );
X}
X
X/*
X * This returns a pointer to char * of a chtype *
X */
Xchar *chtype2Char (chtype *string)
X{
X   /* Declare local variables.					*/
X   char *newstring;
X   int len = 0;
X   int x;
X
X   /* Is the string NULL???					*/
X   if ( string == (chtype *)NULL)
X   {
X      return ( (char *)NULL );
X   }
X
X   /* Get the length of the string.				*/
X   len = chlen(string);
X
X   /* Make the new string.					*/
X   newstring	= (char *)malloc (sizeof (char) * (len+1));
X   cleanChar (newstring, len+1, '\0');
X
X   /* Start translating...					*/
X   for (x=0; x < len; x++)
X   {
X      newstring[x]	= string[x] & A_CHARTEXT;
X   }
X
X   /* Force a NULL character on the end of the string.		*/
X   newstring[len] = (char)NULL;
X
X   /* Return it.						*/
X   return (newstring);
X}
X
Xvoid printattr (WINDOW *window, int xpos, int ypos, int align, chtype attr, char *mesg)
X{
X   int x;
X
X   /* Check the alignment of the message.	*/
X   if (align == VERTICAL)
X   { 
X      int mesgLength = ( (int)strlen (mesg) <= window->_maxy ? (int)strlen (mesg) : window->_maxy);
X
X      /* Draw the message on a vertical axis.	*/
X      for (x=0; x < mesgLength ; x++)
X      {
X         if (attr == A_NOATTRIB)
X         {
X            mvwaddch (window, xpos+x, ypos, mesg[x]);
X         }
X         else
X         {
X            mvwaddch (window, xpos+x, ypos, mesg[x] | attr);
X         }
X      }
X   }
X   else
X   {
X      int mesgLength = ((int)strlen (mesg) <= window->_maxx ? (int)strlen (mesg) : window->_maxx);
X
X      /* Draw the message on a horizontal axis. (default)	*/
X      for (x=0; x < mesgLength ; x++)
X      {
X         if (attr == A_NOATTRIB)
X         {
X            mvwaddch (window, xpos, ypos+x, mesg[x]);
X         }
X         else
X         {
X            mvwaddch (window, xpos, ypos+x, mesg[x] | attr);
X         }
X      }
X   }
X}
X
X/*
X * This swaps two elements in an array.
X */
Xvoid swapIndex (char *list[], int i, int j)
X{
X   char *temp;
X   temp = list[i];
X   list[i] = list[j];
X   list[j] = temp;
X}
X
X/*
X * This function is a quick sort alg which sort an array of
X * char *. I wanted to use to stdlib qsort, but couldn't get the
X * thing to work, so I wrote my own. I'll use qsort if I can get
X * it to work.
X */
Xvoid quickSort (char *list[], int left, int right)
X{
X   int i, last;
X
X   /* If there are fewer than 2 elements, return.	*/
X   if (left >= right)
X   {
X      return;
X   }
X
X   swapIndex (list, left, (left+right)/2);
X   last = left;
X   
X   for (i=left+1; i <= right; i++)
X   {
X      if (strcmp (list[i], list[left]) < 0)
X      {
X         swapIndex (list, ++last, i);
X      }
X   }
X
X   swapIndex (list, left, last);
X   quickSort (list, left, last-1);
X   quickSort (list, last+1, right);
X}
SHAR_EOF
  $shar_touch -am 1229121095 'cdk-4.6.0/cdk.c' &&
  chmod 0400 'cdk-4.6.0/cdk.c' ||
  echo 'restore of cdk-4.6.0/cdk.c failed'
  shar_count="`wc -c < 'cdk-4.6.0/cdk.c'`"
  test 17381 -eq "$shar_count" ||
    echo "cdk-4.6.0/cdk.c: original size 17381, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk-4.6.0/cdkscreen.c ==============
if test -f 'cdk-4.6.0/cdkscreen.c' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk-4.6.0/cdkscreen.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk-4.6.0/cdkscreen.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk-4.6.0/cdkscreen.c' &&
X#include "cdk.h"
X
X/*
X * $Author: glover $
X * $Date: 1995/12/10 18:38:39 $
X * $Revision: 1.33 $
X */
X
X/*
X * This creates a new CDK screen.
X */
XCDKSCREEN *initCDKScreen(WINDOW *window)
X{
X   CDKSCREEN	*screen		= (CDKSCREEN *)malloc (sizeof (CDKSCREEN));
X   screen->objectCount		= 0;
X   screen->window		= window;
X
X   /* Set up basic curses settings.		*/
X   noecho();
X   cbreak();
X
X   /* OK, we are done.				*/
X   return (screen);
X}
X
X/*
X * This registers a CDK object with a screen.
X */
Xvoid registerCDKObject (CDKSCREEN *screen, EObjectType cdktype, void *object)
X{
X   /* Set some basic vars.						*/
X   int objectNumber				= screen->objectCount;
X   screen->object[objectNumber]			= (void *)object;
X
X   /* Since dereferencing a void pointer is a no-no, we have to cast	*/
X   /* our pointer correctly.						*/
X   if (cdktype == vLABEL)
X   {
X      ((CDKLABEL *)object)->screenIndex		= objectNumber;
X      ((CDKLABEL *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vLABEL;
X   }
X   else if (cdktype == vENTRY)
X   {
X      ((CDKENTRY *)object)->screenIndex		= objectNumber;
X      ((CDKENTRY *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vENTRY;
X   }
X   else if (cdktype == vMENTRY)
X   {
X      ((CDKMENTRY *)object)->screenIndex	= objectNumber;
X      ((CDKMENTRY *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vMENTRY;
X   }
X   else if (cdktype == vSCROLL)
X   {
X      ((CDKSCROLL *)object)->screenIndex	= objectNumber;
X      ((CDKSCROLL *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vSCROLL;
X   }
X   else if (cdktype == vDIALOG)
X   {
X      ((CDKDIALOG *)object)->screenIndex	= objectNumber;
X      ((CDKDIALOG *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vDIALOG;
X   }
X   else if (cdktype == vSCALE)
X   {
X      ((CDKSCALE *)object)->screenIndex		= objectNumber;
X      ((CDKSCALE *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vSCALE;
X   }
X   else if (cdktype == vMARQUEE)
X   {
X      ((CDKMARQUEE *)object)->screenIndex	= objectNumber;
X      ((CDKMARQUEE *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vMARQUEE;
X   }
X   else if (cdktype == vMENU)
X   {
X      ((CDKMENU *)object)->screenIndex		= objectNumber;
X      ((CDKMENU *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vMENU;
X   }
X   else if (cdktype == vMATRIX)
X   {
X      ((CDKMATRIX *)object)->screenIndex	= objectNumber;
X      ((CDKMATRIX *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vMATRIX;
X   }
X   else if (cdktype == vHISTOGRAM)
X   {
X      ((CDKHISTOGRAM *)object)->screenIndex	= objectNumber;
X      ((CDKHISTOGRAM *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vHISTOGRAM;
X   }
X   else if (cdktype == vSELECTION)
X   {
X      ((CDKSELECTION *)object)->screenIndex	= objectNumber;
X      ((CDKSELECTION *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vSELECTION;
X   }
X   else if (cdktype == vVIEWER)
X   {
X      ((CDKVIEWER *)object)->screenIndex	= objectNumber;
X      ((CDKVIEWER *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vVIEWER;
X   }
X   else if (cdktype == vGRAPH)
X   {
X      ((CDKGRAPH *)object)->screenIndex		= objectNumber;
X      ((CDKGRAPH *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vGRAPH;
X   }
X   else if (cdktype == vRADIO)
X   {
X      ((CDKRADIO *)object)->screenIndex		= objectNumber;
X      ((CDKRADIO *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vRADIO;
X   }
X   else if (cdktype == vTEMPLATE)
X   {
X      ((CDKTEMPLATE *)object)->screenIndex	= objectNumber;
X      ((CDKTEMPLATE *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vTEMPLATE;
X   }
X   else if (cdktype == vSWINDOW)
X   {
X      ((CDKSWINDOW *)object)->screenIndex	= objectNumber;
X      ((CDKSWINDOW *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vSWINDOW;
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      ((CDKITEMLIST *)object)->screenIndex	= objectNumber;
X      ((CDKITEMLIST *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vITEMLIST;
X   }
X   else if (cdktype == vFSELECT)
X   {
X      ((CDKFSELECT *)object)->screenIndex	= objectNumber;
X      ((CDKFSELECT *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vFSELECT;
X   }
X
X   /* Don't forget to inc the count.					*/
X   screen->objectCount++;
X}
X
X/*
X * This removes an object from the CDK screen.
X */
Xvoid unregisterCDKObject (EObjectType cdktype, void *object)
X{
X   /* Declare some vars.						*/
X   CDKSCREEN *screen;
X   char *type;
X   int screenSize, index, x;
X
X   /* Since dereferencing a void pointer is a no-no, we have to cast	*/
X   /* our pointer correctly.						*/
X   if (cdktype == vLABEL)
X   {
X      screen		= ((CDKLABEL *)object)->screen;
X      index		= ((CDKLABEL *)object)->screenIndex;
X      type		= "Label";
X   }
X   else if (cdktype == vENTRY)
X   {
X      screen		= ((CDKENTRY *)object)->screen;
X      index		= ((CDKENTRY *)object)->screenIndex;
X      type		= "Entry";
X   }
X   else if (cdktype == vMENTRY)
X   {
X      screen		= ((CDKMENTRY *)object)->screen;
X      index		= ((CDKMENTRY *)object)->screenIndex;
X      type		= "MEntry";
X   }
X   else if (cdktype == vSCROLL)
X   {
X      screen		= ((CDKSCROLL *)object)->screen;
X      index		= ((CDKSCROLL *)object)->screenIndex;
X      type		= "Scroll";
X   }
X   else if (cdktype == vDIALOG)
X   {
X      screen		= ((CDKDIALOG *)object)->screen;
X      index		= ((CDKDIALOG *)object)->screenIndex;
X      type		= "Dialog";
X   }
X   else if (cdktype == vSCALE)
X   {
X      screen		= ((CDKSCALE *)object)->screen;
X      index		= ((CDKSCALE *)object)->screenIndex;
X      type		= "Scale";
X   }
X   else if (cdktype == vMARQUEE)
X   {
X      screen		= ((CDKMARQUEE *)object)->screen;
X      index		= ((CDKMARQUEE *)object)->screenIndex;
X      type		= "Marquee";
X   }
X   else if (cdktype == vMENU)
X   {
X      screen		= ((CDKMENU *)object)->screen;
X      index		= ((CDKMENU *)object)->screenIndex;
X      type		= "Menu";
X   }
X   else if (cdktype == vMATRIX)
X   {
X      screen		= ((CDKMATRIX *)object)->screen;
X      index		= ((CDKMATRIX *)object)->screenIndex;
X      type		= "Matrix";
X   }
X   else if (cdktype == vHISTOGRAM)
X   {
X      screen		= ((CDKHISTOGRAM *)object)->screen;
X      index		= ((CDKHISTOGRAM *)object)->screenIndex;
X      type		= "Histogram";
X   }
X   else if (cdktype == vSELECTION)
X   {
X      screen		= ((CDKSELECTION *)object)->screen;
X      index		= ((CDKSELECTION *)object)->screenIndex;
X      type		= "Selection";
X   }
X   else if (cdktype == vVIEWER)
X   {
X      screen		= ((CDKVIEWER *)object)->screen;
X      index		= ((CDKVIEWER *)object)->screenIndex;
X      type		= "Viewer";
X   }
X   else if (cdktype == vGRAPH)
X   {
X      screen		= ((CDKGRAPH *)object)->screen;
X      index		= ((CDKGRAPH *)object)->screenIndex;
X      type		= "Graph";
X   }
X   else if (cdktype == vRADIO)
X   {
X      screen		= ((CDKRADIO *)object)->screen;
X      index		= ((CDKRADIO *)object)->screenIndex;
X      type		= "Radio";
X   }
X   else if (cdktype == vTEMPLATE)
X   {
X      screen		= ((CDKTEMPLATE *)object)->screen;
X      index		= ((CDKTEMPLATE *)object)->screenIndex;
X      type		= "Template";
X   }
X   else if (cdktype == vSWINDOW)
X   {
X      screen		= ((CDKSWINDOW *)object)->screen;
X      index		= ((CDKSWINDOW *)object)->screenIndex;
X      type		= "SWindow";
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      screen		= ((CDKITEMLIST *)object)->screen;
X      index		= ((CDKITEMLIST *)object)->screenIndex;
X      type		= "Itemlist";
X   }
X   else if (cdktype == vFSELECT)
X   {
X      screen		= ((CDKFSELECT *)object)->screen;
X      index		= ((CDKFSELECT *)object)->screenIndex;
X      type		= "File Selector";
X   }
X
X   /* Set the screenSize.		*/
X   screenSize	= screen->objectCount - 1;
X
X   /* If this is the last object -1 then this is the last. If not	*/
X   /* we have to shuffle all the other objects to the left.		*/
X   x = index;
X   for (x=index; x < screenSize; x++)
X   {
X      screen->object[x]		= screen->object[x+1];
X      screen->cdktype[x]	= screen->cdktype[x+1];
X   }
X   screen->object[x]		= (void *)NULL;
X   screen->cdktype[x]		= 0;
X   screen->objectCount--;
X}
X
X/*
X * This 'brings' a CDK object to the top of the stack.
X */
Xvoid raiseCDKObject (EObjectType cdktype, void *object)
X{
X   /* Declare some vars.						*/
X   void *swapobject	= (void *)NULL;
X   int toppos		= -1;
X   int swapindex	= -1;
X   EObjectType swaptype;
X
X   /* Should never dereference a void * pointer.			*/
X   if (cdktype == vLABEL)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKLABEL *)object)->screen->objectCount - 1;
X      swapobject	= (void *)((CDKLABEL *)object)->screen->object[toppos];
X      swaptype		= ((CDKLABEL *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKLABEL *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKLABEL *)object)->screenIndex			= toppos;
X      ((CDKLABEL *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKLABEL *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vENTRY)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKENTRY *)object)->screen->objectCount;
X      swapobject	= ((CDKENTRY *)object)->screen->object[toppos];
X      swaptype		= ((CDKENTRY *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKENTRY *)object)->screenIndex;
X
X      /* Set the new info...						*/
SHAR_EOF
  : || echo 'restore of cdk-4.6.0/cdkscreen.c failed'
fi
echo 'End of archive part 3'
echo 'File cdk-4.6.0/cdkscreen.c is continued in part 4'
echo 4 > _sharseq.tmp
exit 0
