Newsgroups: comp.sources.unix
From: wolf@prosun.first.gmd.de (Wolfgang Koehler)
Subject: v29i058: grafix-1.2 - a C++ library for easy X11 GUI apps, Part04/05
References: <1.817847834.9257@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: wolf@prosun.first.gmd.de (Wolfgang Koehler)
Posting-Number: Volume 29, Issue 58
Archive-Name: grafix-1.2/part04

#!/bin/sh
# This is part 04 of Grafix
# ============= gccinc/rx.h ==============
if test ! -d 'gccinc'; then
    echo 'x - creating directory gccinc'
    mkdir 'gccinc'
fi
if test -f 'gccinc/rx.h' -a X"$1" != X"-c"; then
	echo 'x - skipping gccinc/rx.h (File already exists)'
else
echo 'x - extracting gccinc/rx.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'gccinc/rx.h' &&
#if !defined(_RX_H) || defined(RX_WANT_SE_DEFS)
#define _RX_H
X
/*	Copyright (C) 1992, 1993 Free Software Foundation, Inc.
X
This file is part of the librx library.
X
Librx is free software; you can redistribute it and/or modify it under
the terms of the GNU Library General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
X
Librx is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.
X
You should have received a copy of the GNU Library General Public
License along with this software; see the file COPYING.LIB.  If not,
write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA
02139, USA.  */
/*  t. lord	Wed Sep 23 18:20:57 1992	*/
X
X
X
X
#include <features.h>
X
#if RX_WANT_SE_DEFS != 1
__BEGIN_DECLS
#endif
X
#ifndef RX_WANT_SE_DEFS
X
/* This page: Bitsets */
X
#ifndef RX_subset
typedef unsigned int RX_subset;
#define RX_subset_bits	(32)
#define RX_subset_mask	(RX_subset_bits - 1)
#endif
X
typedef RX_subset * rx_Bitset;
X
#ifdef __STDC__
typedef void (*rx_bitset_iterator) (void *, int member_index);
#else
typedef void (*rx_bitset_iterator) ();
#endif
X
#define rx_bitset_subset(N)  ((N) / RX_subset_bits)
#define rx_bitset_subset_val(B,N)  ((B)[rx_bitset_subset(N)])
#define RX_bitset_access(B,N,OP) \
X  ((B)[rx_bitset_subset(N)] OP rx_subset_singletons[(N) & RX_subset_mask])
#define RX_bitset_member(B,N)   RX_bitset_access(B, N, &)
#define RX_bitset_enjoin(B,N)   RX_bitset_access(B, N, |=)
#define RX_bitset_remove(B,N)   RX_bitset_access(B, N, &= ~)
#define RX_bitset_toggle(B,N)   RX_bitset_access(B, N, ^= )
#define rx_bitset_numb_subsets(N) (((N) + RX_subset_bits - 1) / RX_subset_bits)
#define rx_sizeof_bitset(N)	(rx_bitset_numb_subsets(N) * sizeof(RX_subset))
X
X
X
/* This page: Splay trees. */
X
#ifdef __STDC__
typedef int (*rx_sp_comparer) (void * a, void * b);
#else
typedef int (*rx_sp_comparer) ();
#endif
X
struct rx_sp_node 
{
X  void * key;
X  void * data;
X  struct rx_sp_node * kids[2];
};
X
#ifdef __STDC__
typedef void (*rx_sp_key_data_freer) (struct rx_sp_node *);
#else
typedef void (*rx_sp_key_data_freer) ();
#endif
X
X
/* giant inflatable hash trees */
X
struct rx_hash_item
{
X  struct rx_hash_item * next_same_hash;
X  struct rx_hash * table;
X  unsigned long hash;
X  void * data;
X  void * binding;
};
X
struct rx_hash
{
X  struct rx_hash * parent;
X  int refs;
X  struct rx_hash * children[13];
X  struct rx_hash_item * buckets [13];
X  int bucket_size [13];
};
X
struct rx_hash_rules;
X
#ifdef __STDC__
/* should return like == */
typedef int (*rx_hash_eq)(void *, void *);
typedef struct rx_hash * (*rx_alloc_hash)(struct rx_hash_rules *);
typedef void (*rx_free_hash)(struct rx_hash *,
X			    struct rx_hash_rules *);
typedef struct rx_hash_item * (*rx_alloc_hash_item)(struct rx_hash_rules *,
X						    void *);
typedef void (*rx_free_hash_item)(struct rx_hash_item *,
X				 struct rx_hash_rules *);
#else
typedef int (*rx_hash_eq)();
typedef struct rx_hash * (*rx_alloc_hash)();
typedef void (*rx_free_hash)();
typedef struct rx_hash_item * (*rx_alloc_hash_item)();
typedef void (*rx_free_hash_item)();
#endif
X
struct rx_hash_rules
{
X  rx_hash_eq eq;
X  rx_alloc_hash hash_alloc;
X  rx_free_hash free_hash;
X  rx_alloc_hash_item hash_item_alloc;
X  rx_free_hash_item free_hash_item;
};
X
X
X
/* Matchers decide what to do by examining a series of these.
X * Instruction types are described below.
X */
struct rx_inx 
{
X  void * inx;
X  void * data;
X  void * data_2;
X  void * fnord;
};
X
/* Struct RX holds a compiled regular expression - that is, an nfa ready to be
X * converted on demand to a more efficient nfa.  This is for the low level interface.
X * The high-level interface incloses this in a `struct re_pattern_buffer'.
X */
struct rx_cache;
#ifdef __STDC__
struct rx_se_list;
struct rx;
typedef int (*rx_se_list_order) (struct rx *,
X				 struct rx_se_list *, struct rx_se_list *);
#else
typedef int (*rx_se_list_order) ();
#endif
X
struct rx_superset;
X
struct rx
{
X  int rx_id;		/* Every edition numbered and signed by eclose_nfa. */
X
X  struct rx_cache * cache;  /* Where superstates come from */
X
X  /* Every regex defines the size of its own character set. */
X  int local_cset_size;
X
X  void * buffer;		/* Malloced memory for the nfa. */
X  unsigned long allocated;	/* Size of that memory. */
X
X  /* How much buffer space to save for external uses.  After compilation,
X   * this space will be available at (buffer + allocated - reserved)
X   */
X  unsigned long reserved;
X
X  /* --------- The remaining fields are for internal use only. --------- */
X  /* --------- But! they should be initialized to 0.	       --------- */
X  /* NODEC is the number of nodes in the NFA with non-epsilon
X   * orx transitions. 
X   */
X  int nodec;
X
X  /* EPSNODEC is the number of nodes with only epsilon (orx) transitions. */
X  int epsnodec;
X
X  /* The sum of NODEC & EPSNODEC is the total number of states in the
X   * compiled NFA.
X   */
X
X  /* side_effect_progs temporarily holds a tree of side effect lists. */
X  struct rx_hash se_list_memo;
X
X  /* A memo for sets of states in the possible_future lists of an nfa: */
X  struct rx_hash set_list_memo;
X
X  /* The instruction table is indexed by the enum of instructions defined in 
X   * rxrun.h.  The values in the table are used to fill in the `inx'
X   * slot of instruction frames (see rxrun.h).
X   */
X  void ** instruction_table;
X  struct rx_nfa_state *nfa_states;
X  struct rx_nfa_state *start;
X
X  /* This orders the search through super-nfa paths. */
X  rx_se_list_order se_list_cmp;
X
X  struct rx_superset * start_set;
};
X
/* An RX NFA may contain epsilon edges labeled with side effects.
X * These side effects represent match actions that can not normally be
X * defined in a `pure' NFA; for example, recording the location at
X * which a paren is crossed in a register structure.  
X *
X * A matcher is supposed to find a particular path
X * through the NFA (such as leftmost-longest), and then to execute the
X * side effects along that path.  Operationally, the space of paths is
X * searched and side effects are carried out incrementally, and with
X * backtracking.
X *
X * As the NFA is manipulated during matching sets of side effects.
X * Simple lists are used to hold side effect lists. 
X */
X
typedef void * rx_side_effect;
X
struct rx_se_list
{
X  rx_side_effect car;
X  struct rx_se_list * cdr;
};
X
X
X
/* Struct rexp_node holds an expression tree that represents a regexp.
X * In this expression tree, every node has a type, and some parameters
X * appropriate to that type.
X */
X
enum rexp_node_type
{
X  r_cset,			/* Match from a character set. `a' or `[a-z]'*/
X  r_concat,			/* Concat two regexps.   `ab' */
X  r_alternate,			/* Choose one of two regexps. `a\|b' */
X  r_opt,			/* Optional regexp. `a?' */
X  r_star,			/* Repeated regexp. `a*' */
X  r_2phase_star,		/* hard to explain */
X  r_side_effect,		/* Matches the empty string, but
X				 * implies that a side effect must
X				 * take place.  These nodes are used
X				 * by the parser to implement parens,
X				 * backreferences etc.
X				 */
X
X  r_data			/* R_DATA is soley for the convenience
X				 * of parsers or other rexp
X				 * transformers that want to
X				 * (temporarily) introduce new node
X				 * types in rexp structures.  These
X				 * must be eliminated
X			    	 * by the time build_nfa is called.
X			  	 */
};
X
struct rexp_node
{
X  enum rexp_node_type type;
X  union
X  {
X    rx_Bitset cset;
X    rx_side_effect side_effect;
X    struct
X      {
X	struct rexp_node *left;
X	struct rexp_node *right;
X      } pair;
X    void * data;
X  } params;
};
X
X
X
/* This defines the structure of the NFA into which rexps are compiled. */
X
struct rx_nfa_state
{
X  int id;		
X  struct rx_nfa_edge *edges;
X  struct rx_possible_future *futures;
X  unsigned int is_final:1;
X  unsigned int is_start:1;
X  unsigned int eclosure_needed:1;
X  struct rx_nfa_state *next;
X  unsigned int mark:1;
};
X
enum rx_nfa_etype
{
X  ne_cset,
X  ne_epsilon,
X  ne_side_effect		/* A special kind of epsilon. */
};
X
struct rx_nfa_edge
{
X  struct rx_nfa_edge *next;
X  enum rx_nfa_etype type;
X  struct rx_nfa_state *dest;
X  union
X  {
X    rx_Bitset cset;
X    rx_side_effect side_effect;
X  } params;
};
X
struct rx_nfa_state_set
{
X  struct rx_nfa_state * car;
X  struct rx_nfa_state_set * cdr;
};
X
struct rx_possible_future
{
X  struct rx_possible_future *next;
X  struct rx_se_list * effects;
X  struct rx_nfa_state_set * destset;
};
X
X
X
enum rx_opcode
{
X  /* 
X   * BACKTRACK_POINT is invoked when a transition results in more
X   * than one possible future.
X   *
X   * There is one occurence of this instruction per transition_class
X   * structure; that occurence is only ever executed if the 
X   * transition_class contains a list of more than 1 edge.
X   */
X  rx_backtrack_point = 0,	/* data is (struct transition_class *) */
X
X  /* 
X   * RX_DO_SIDE_EFFECTS evaluates the side effects of an epsilon path.
X   * There is one occurence of this instruction per rx_distinct_future.
X   * This instruction is skipped if a rx_distinct_future has no side effects.
X   */
X  rx_do_side_effects = rx_backtrack_point + 1,
X  /* data is (struct rx_distinct_future *) */
X
X  /* 
X   * RX_CACHE_MISS instructions are stored in rx_distinct_futures whose
X   * destination superstate has been reclaimed (or was never built).
X   * It recomputes the destination superstate.
X   * RX_CACHE_MISS is also stored in a superstate transition table before
X   * any of its edges have been built.
X   */
X  rx_cache_miss = rx_do_side_effects + 1,
X  /* data is (struct rx_distinct_future *) */
X
X  /* 
X   * RX_NEXT_CHAR is called to consume the next character and take the
X   * corresponding transition.  This is the only instruction that uses 
X   * the DATA field of the instruction frame instead of DATA_2.
X   * (see EXPLORE_FUTURE in regex.c).
X   */
X  rx_next_char = rx_cache_miss + 1, /* data is (struct superstate *) */
X
X  /* RX_BACKTRACK indicates that a transition fails.
X   */
X  rx_backtrack = rx_next_char + 1, /* no data */
X
X  /* 
X   * RX_ERROR_INX is stored only in places that should never be executed.
X   */
X  rx_error_inx = rx_backtrack + 1, /* Not supposed to occur. */
X
X  rx_num_instructions = rx_error_inx + 1
};
X
/* An id_instruction_table holds the values stored in instruction
X * frames.  The table is indexed by the enums declared above.
X */
extern void * rx_id_instruction_table[rx_num_instructions];
X
#if 0				/* Already declared way above. */
/*  If the instruction is `rx_next_char' then data is valid.  Otherwise it's 0
X *  and data_2 is valid.
X */
struct rx_inx 
{
X  void * inx;
X  void * data;
X  void * data_2;
};
#endif
X
X
#ifndef RX_TAIL_ARRAY
#define RX_TAIL_ARRAY  1
#endif
X
/* A superstate corresponds to a set of nfa states.  Those sets are
X * represented by STRUCT RX_SUPERSET.  The constructors
X * guarantee that only one (shared) structure is created for a given set.
X */
struct rx_superset
{
X  int refs;
X  struct rx_nfa_state * car;	/* May or may not be a valid addr. */
X  int id;			/* == car->id for the initial value of *car */
X  struct rx_superset * cdr;	/* May be NULL or a live or semifreed super*/
X
X  /* If the corresponding superstate exists: */
X  struct rx_superstate * superstate;
X
X  /* If this is a starting state (as built by re_search_2)
X   * this points to the `struct rx'.  The memory for these objects
X   * is typed -- so even after they are freed it is safe to look
X   * at this field (to check, in fact, if this was freed.)
X   */
X  struct rx * starts_for;
X
X  struct rx_hash_item hash_item;
};
X
#define rx_protect_superset(RX,CON) (++(CON)->refs)
X
/* Every character occurs in at most one super edge per super-state.
X * But, that edge might have more than one option, indicating a point
X * of non-determinism. 
X */
struct rx_super_edge
{
X  struct rx_super_edge *next;
X  struct rx_inx rx_backtrack_frame;
X  int cset_size;
X  rx_Bitset cset;
X  struct rx_distinct_future *options;
};
X
/* A superstate is a set of nfa states (RX_SUPERSET) along
X * with a transition table.  Superstates are built on demand and reclaimed
X * without warning.  To protect a superstate, use LOCK_SUPERSTATE.
X *
X * Joe Keane thought of calling these superstates and several people
X * have commented on what a good name it is for what they do. 
X */
struct rx_superstate
{
X  int rx_id;
X  int locks;
X  struct rx_superstate * next_recyclable;
X  struct rx_superstate * prev_recyclable;
X  struct rx_distinct_future * transition_refs;
X  struct rx_superset * contents;
X  struct rx_super_edge * edges;
X  int is_semifree;
X  int trans_size;
X  struct rx_inx transitions[RX_TAIL_ARRAY]; /* cset sized */
};
X
struct rx_distinct_future
{
X  struct rx_distinct_future * next_same_super_edge[2];
X  struct rx_distinct_future * next_same_dest;
X  struct rx_distinct_future * prev_same_dest;
X  struct rx_superstate * present;	/* source state */
X  struct rx_superstate * future;	/* destination state */
X  struct rx_super_edge * edge;
X  struct rx_inx future_frame;
X  struct rx_inx side_effects_frame;
X  struct rx_se_list * effects;
};
X
#define rx_lock_superstate(R,S)  ((S)->locks++)
#define rx_unlock_superstate(R,S) (--(S)->locks)
X
X
/* This page destined for rx.h */
X
struct rx_blocklist
{
X  struct rx_blocklist * next;
X  int bytes;
};
X
struct rx_freelist
{
X  struct rx_freelist * next;
};
X
struct rx_cache;
X
#ifdef __STDC__
typedef void (*rx_morecore_fn)(struct rx_cache *);
#else
typedef void (*rx_morecore_fn)();
#endif
X
/* You use this to control the allocation of superstate data 
X * during matching.  Most of it should be initialized to 0.
X *
X * A MORECORE function is necessary.  It should allocate
X * a new block of memory or return 0.
X * A default that uses malloc is called `rx_morecore'.
X *
X * The number of SUPERSTATES_ALLOWED indirectly limits how much memory
X * the system will try to allocate.  The default is 128.  Batch style
X * applications that are very regexp intensive should use as high a number
X * as possible without thrashing.
X * 
X * The LOCAL_CSET_SIZE is the number of characters in a character set.
X * It is therefore the number of entries in a superstate transition table.
X * Generally, it should be 256.  If your character set has 16 bits, 
X * it is better to translate your regexps into equivalent 8 bit patterns.
X */
X
struct rx_cache
{
X  struct rx_hash_rules superset_hash_rules;
X
X  /* Objects are allocated by incrementing a pointer that 
X   * scans across rx_blocklists.
X   */
X  struct rx_blocklist * memory;
X  struct rx_blocklist * memory_pos;
X  int bytes_left;
X  char * memory_addr;
X  rx_morecore_fn morecore;
X
X  /* Freelists. */
X  struct rx_freelist * free_superstates;
X  struct rx_freelist * free_transition_classes;
X  struct rx_freelist * free_discernable_futures;
X  struct rx_freelist * free_supersets;
X  struct rx_freelist * free_hash;
X
X  /* Two sets of superstates -- those that are semifreed, and those
X   * that are being used.
X   */
X  struct rx_superstate * lru_superstate;
X  struct rx_superstate * semifree_superstate;
X
X  struct rx_superset * empty_superset;
X
X  int superstates;
X  int semifree_superstates;
X  int hits;
X  int misses;
X  int superstates_allowed;
X
X  int local_cset_size;
X  void ** instruction_table;
X
X  struct rx_hash superset_table;
};
X
X
X
/* The lowest-level search function supports arbitrarily fragmented
X * strings and (optionally) suspendable/resumable searches.
X *
X * Callers have to provide a few hooks.
X */
X
#ifndef __GNUC__
#ifdef __STDC__
#define __const__ const
#else
#define __const__
#endif
#endif
X
/* This holds a matcher position */
struct rx_string_position
{
X  __const__ unsigned char * pos;	/* The current pos. */
X  __const__ unsigned char * string; /* The current string burst. */
X  __const__ unsigned char * end;	/* First invalid position >= POS. */
X  int offset;			/* Integer address of the current burst. */
X  int size;			/* Current string's size. */
X  int search_direction;		/* 1 or -1 */
X  int search_end;		/* First position to not try. */
};
X
X
enum rx_get_burst_return
{
X  rx_get_burst_continuation,
X  rx_get_burst_error,
X  rx_get_burst_ok,
X  rx_get_burst_no_more
};
X
X
/* A call to get burst should make POS valid.  It might be invalid
X * if the STRING field doesn't point to a burst that actually
X * contains POS.
X *
X * GET_BURST should take a clue from SEARCH_DIRECTION (1 or -1) as to
X * whether or not to pad to the left.  Padding to the right is always
X * appropriate, but need not go past the point indicated by STOP.
X *
X * If a continuation is returned, then the reentering call to
X * a search function will retry the get_burst.
X */
X
#ifdef __STDC__
typedef enum rx_get_burst_return
X  (*rx_get_burst_fn) (struct rx_string_position * pos,
X		      void * app_closure,
X		      int stop);
X					       
#else
typedef enum rx_get_burst_return (*rx_get_burst_fn) ();
#endif
X
X
enum rx_back_check_return
{
X  rx_back_check_continuation,
X  rx_back_check_error,
X  rx_back_check_pass,
X  rx_back_check_fail
};
X
/* Back_check should advance the position it is passed 
X * over rparen - lparen characters and return pass iff
X * the characters starting at POS match those indexed
X * by [LPAREN..RPAREN].
X *
X * If a continuation is returned, then the reentering call to
X * a search function will retry the back_check.
X */
X
#ifdef __STDC__
typedef enum rx_back_check_return
X  (*rx_back_check_fn) (struct rx_string_position * pos,
X		       int lparen,
X		       int rparen,
X		       unsigned char * translate,
X		       void * app_closure,
X		       int stop);
X					       
#else
typedef enum rx_back_check_return (*rx_back_check_fn) ();
#endif
X
X
X
X
/* A call to fetch_char should return the character at POS or POS + 1.
X * Returning continuations here isn't supported.  OFFSET is either 0 or 1
X * and indicates which characters is desired.
X */
X
#ifdef __STDC__
typedef int (*rx_fetch_char_fn) (struct rx_string_position * pos,
X				 int offset,
X				 void * app_closure,
X				 int stop);
#else
typedef int (*rx_fetch_char_fn) ();
#endif
X
X
enum rx_search_return
{
X  rx_search_continuation = -4,
X  rx_search_error = -3,
X  rx_search_soft_fail = -2,	/* failed by running out of string */
X  rx_search_fail = -1		/* failed only by reaching failure states */
X  /* return values >= 0 indicate the position of a successful match */
};
X
X
X
X
X
X
/* regex.h
X * 
X * The remaining declarations replace regex.h.
X */
X
/* This is an array of error messages corresponding to the error codes.
X */
extern __const__ char *re_error_msg[];
X
/* If any error codes are removed, changed, or added, update the
X   `re_error_msg' table in regex.c.  */
typedef enum
{
X  REG_NOERROR = 0,	/* Success.  */
X  REG_NOMATCH,		/* Didn't find a match (for regexec).  */
X
X  /* POSIX regcomp return error codes.  (In the order listed in the
X     standard.)  */
X  REG_BADPAT,		/* Invalid pattern.  */
X  REG_ECOLLATE,		/* Not implemented.  */
X  REG_ECTYPE,		/* Invalid character class name.  */
X  REG_EESCAPE,		/* Trailing backslash.  */
X  REG_ESUBREG,		/* Invalid back reference.  */
X  REG_EBRACK,		/* Unmatched left bracket.  */
X  REG_EPAREN,		/* Parenthesis imbalance.  */ 
X  REG_EBRACE,		/* Unmatched \{.  */
X  REG_BADBR,		/* Invalid contents of \{\}.  */
X  REG_ERANGE,		/* Invalid range end.  */
X  REG_ESPACE,		/* Ran out of memory.  */
X  REG_BADRPT,		/* No preceding re for repetition op.  */
X
X  /* Error codes we've added.  */
X  REG_EEND,		/* Premature end.  */
X  REG_ESIZE,		/* Compiled pattern bigger than 2^16 bytes.  */
X  REG_ERPAREN		/* Unmatched ) or \); not returned from regcomp.  */
} reg_errcode_t;
X
/* The regex.c support, as a client of rx, defines a set of possible
X * side effects that can be added to the edge lables of nfa edges.
X * Here is the list of sidef effects in use.
X */
X
enum re_side_effects
{
#define RX_WANT_SE_DEFS 1
#undef RX_DEF_SE
#undef RX_DEF_CPLX_SE
#define RX_DEF_SE(IDEM, NAME, VALUE)	      NAME VALUE,
#define RX_DEF_CPLX_SE(IDEM, NAME, VALUE)     NAME VALUE,
#include "rx.h"
#undef RX_DEF_SE
#undef RX_DEF_CPLX_SE
#undef RX_WANT_SE_DEFS
X   re_floogle_flap = 65533
};
X
/* These hold paramaters for the kinds of side effects that are possible
X * in the supported pattern languages.  These include things like the 
X * numeric bounds of {} operators and the index of paren registers for 
X * subexpression measurement or backreferencing.
X */
struct re_se_params
{
X  enum re_side_effects se;
X  int op1;
X  int op2;
};
X
typedef unsigned reg_syntax_t;
X
struct re_pattern_buffer
{
X  struct rx rx;
X  reg_syntax_t syntax;		/* See below for syntax bit definitions. */
X
X  unsigned int no_sub:1;	/* If set, don't  return register offsets. */
X  unsigned int not_bol:1;	/* If set, the anchors ('^' and '$') don't */
X  unsigned int not_eol:1;	/*     match at the ends of the string.  */  
X  unsigned int newline_anchor:1;/* If true, an anchor at a newline matches.*/
X  unsigned int least_subs:1;	/* If set, and returning registers, return
X				 * as few values as possible.  Only 
X				 * backreferenced groups and group 0 (the whole
X				 * match) will be returned.
X				 */
X
X  /* If true, this says that the matcher should keep registers on its
X   * backtracking stack.  For many patterns, we can easily determine that
X   * this isn't necessary.
X   */
X  unsigned int match_regs_on_stack:1;
X  unsigned int search_regs_on_stack:1;
X
X  /* is_anchored and begbuf_only are filled in by rx_compile. */
X  unsigned int is_anchored:1;	/* Anchorded by ^? */
X  unsigned int begbuf_only:1;	/* Anchored to char position 0? */
X
X  
X  /* If REGS_UNALLOCATED, allocate space in the `regs' structure
X   * for `max (RE_NREGS, re_nsub + 1)' groups.
X   * If REGS_REALLOCATE, reallocate space if necessary.
X   * If REGS_FIXED, use what's there.  
X   */
#define REGS_UNALLOCATED 0
#define REGS_REALLOCATE 1
#define REGS_FIXED 2
X  unsigned int regs_allocated:2;
X
X  
X  /* Either a translate table to apply to all characters before
X   * comparing them, or zero for no translation.  The translation
X   * is applied to a pattern when it is compiled and to a string
X   * when it is matched.
X   */
X  unsigned char * translate;
X
X  /* If this is a valid pointer, it tells rx not to store the extents of 
X   * certain subexpressions (those corresponding to non-zero entries).
X   * Passing 0x1 is the same as passing an array of all ones.  Passing 0x0
X   * is the same as passing an array of all zeros.
X   * The array should contain as many entries as their are subexps in the 
X   * regexp.
X   */
X  char * syntax_parens;
X
X	/* Number of subexpressions found by the compiler.  */
X  size_t re_nsub;
X
X  void * buffer;		/* Malloced memory for the nfa. */
X  unsigned long allocated;	/* Size of that memory. */
X
X  /* Pointer to a fastmap, if any, otherwise zero.  re_search uses
X   * the fastmap, if there is one, to skip over impossible
X   * starting points for matches.  */
X  char *fastmap;
X
X  unsigned int fastmap_accurate:1; /* These three are internal. */
X  unsigned int can_match_empty:1;  
X  struct rx_nfa_state * start;	/* The nfa starting state. */
X
X  /* This is the list of iterator bounds for {lo,hi} constructs.
X   * The memory pointed to is part of the rx->buffer.
X   */
X  struct re_se_params *se_params;
X
X  /* This is a bitset representation of the fastmap.
X   * This is a true fastmap that already takes the translate
X   * table into account.
X   */
X  rx_Bitset fastset;
};
X
/* Type for byte offsets within the string.  POSIX mandates this.  */
typedef int regoff_t;
X
/* This is the structure we store register match data in.  See
X   regex.texinfo for a full description of what registers match.  */
struct re_registers
{
X  unsigned num_regs;
X  regoff_t *start;
X  regoff_t *end;
};
X
typedef struct re_pattern_buffer regex_t;
X
/* POSIX specification for registers.  Aside from the different names than
X   `re_registers', POSIX uses an array of structures, instead of a
X   structure of arrays.  */
typedef struct
{
X  regoff_t rm_so;  /* Byte offset from string's start to substring's start.  */
X  regoff_t rm_eo;  /* Byte offset from string's start to substring's end.  */
} regmatch_t;
X
X
/* The following bits are used to determine the regexp syntax we
X   recognize.  The set/not-set meanings are chosen so that Emacs syntax
X   remains the value 0.  The bits are given in alphabetical order, and
X   the definitions shifted by one from the previous bit; thus, when we
X   add or remove a bit, only one other definition need change.  */
X
/* If this bit is not set, then \ inside a bracket expression is literal.
X   If set, then such a \ quotes the following character.  */
#define RE_BACKSLASH_ESCAPE_IN_LISTS (1)
X
/* If this bit is not set, then + and ? are operators, and \+ and \? are
X     literals. 
X   If set, then \+ and \? are operators and + and ? are literals.  */
#define RE_BK_PLUS_QM (RE_BACKSLASH_ESCAPE_IN_LISTS << 1)
X
/* If this bit is set, then character classes are supported.  They are:
X     [:alpha:], [:upper:], [:lower:],  [:digit:], [:alnum:], [:xdigit:],
X     [:space:], [:print:], [:punct:], [:graph:], and [:cntrl:].
X   If not set, then character classes are not supported.  */
#define RE_CHAR_CLASSES (RE_BK_PLUS_QM << 1)
X
/* If this bit is set, then ^ and $ are always anchors (outside bracket
X     expressions, of course).
X   If this bit is not set, then it depends:
X        ^  is an anchor if it is at the beginning of a regular
X           expression or after an open-group or an alternation operator;
X        $  is an anchor if it is at the end of a regular expression, or
X           before a close-group or an alternation operator.  
X
X   This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because
X   POSIX draft 11.2 says that * etc. in leading positions is undefined.
X   We already implemented a previous draft which made those constructs
X   invalid, though, so we haven't changed the code back.  */
#define RE_CONTEXT_INDEP_ANCHORS (RE_CHAR_CLASSES << 1)
X
/* If this bit is set, then special characters are always special
X     regardless of where they are in the pattern.
X   If this bit is not set, then special characters are special only in
X     some contexts; otherwise they are ordinary.  Specifically, 
X     * + ? and intervals are only special when not after the beginning,
X     open-group, or alternation operator.  */
#define RE_CONTEXT_INDEP_OPS (RE_CONTEXT_INDEP_ANCHORS << 1)
X
/* If this bit is set, then *, +, ?, and { cannot be first in an re or
X     immediately after an alternation or begin-group operator.  */
#define RE_CONTEXT_INVALID_OPS (RE_CONTEXT_INDEP_OPS << 1)
X
/* If this bit is set, then . matches newline.
X   If not set, then it doesn't.  */
#define RE_DOT_NEWLINE (RE_CONTEXT_INVALID_OPS << 1)
X
/* If this bit is set, then . doesn't match NUL.
X   If not set, then it does.  */
#define RE_DOT_NOT_NULL (RE_DOT_NEWLINE << 1)
X
/* If this bit is set, nonmatching lists [^...] do not match newline.
X   If not set, they do.  */
#define RE_HAT_LISTS_NOT_NEWLINE (RE_DOT_NOT_NULL << 1)
X
/* If this bit is set, either \{...\} or {...} defines an
X     interval, depending on RE_NO_BK_BRACES. 
X   If not set, \{, \}, {, and } are literals.  */
#define RE_INTERVALS (RE_HAT_LISTS_NOT_NEWLINE << 1)
X
/* If this bit is set, +, ? and | aren't recognized as operators.
X   If not set, they are.  */
#define RE_LIMITED_OPS (RE_INTERVALS << 1)
X
/* If this bit is set, newline is an alternation operator.
X   If not set, newline is literal.  */
#define RE_NEWLINE_ALT (RE_LIMITED_OPS << 1)
X
/* If this bit is set, then `{...}' defines an interval, and \{ and \}
X     are literals.
X  If not set, then `\{...\}' defines an interval.  */
#define RE_NO_BK_BRACES (RE_NEWLINE_ALT << 1)
X
/* If this bit is set, (...) defines a group, and \( and \) are literals.
X   If not set, \(...\) defines a group, and ( and ) are literals.  */
#define RE_NO_BK_PARENS (RE_NO_BK_BRACES << 1)
X
/* If this bit is set, then \<digit> matches <digit>.
X   If not set, then \<digit> is a back-reference.  */
#define RE_NO_BK_REFS (RE_NO_BK_PARENS << 1)
X
/* If this bit is set, then | is an alternation operator, and \| is literal. 
X   If not set, then \| is an alternation operator, and | is literal.  */
#define RE_NO_BK_VBAR (RE_NO_BK_REFS << 1)
X
/* If this bit is set, then an ending range point collating higher
X     than the starting range point, as in [z-a], is invalid.
X   If not set, then when ending range point collates higher than the
X     starting range point, the range is ignored.  */
#define RE_NO_EMPTY_RANGES (RE_NO_BK_VBAR << 1)
X
/* If this bit is set, then an unmatched ) is ordinary.
X   If not set, then an unmatched ) is invalid.  */
#define RE_UNMATCHED_RIGHT_PAREN_ORD (RE_NO_EMPTY_RANGES << 1)
X
/* If this bit is set, do not process the GNU regex operators.
X   IF not set, then the GNU regex operators are recognized. */
#define RE_NO_GNU_OPS (RE_UNMATCHED_RIGHT_PAREN_ORD << 1)
X 
/* This global variable defines the particular regexp syntax to use (for
X   some interfaces).  When a regexp is compiled, the syntax used is
X   stored in the pattern buffer, so changing this does not affect
X   already-compiled regexps.  */
extern reg_syntax_t re_syntax_options;
X
/* Define combinations of the above bits for the standard possibilities.
X   (The [[[ comments delimit what gets put into the Texinfo file, so
X   don't delete them!)  */ 
/* [[[begin syntaxes]]] */
#define RE_SYNTAX_EMACS 0
X
#define RE_SYNTAX_AWK							\
X  (RE_BACKSLASH_ESCAPE_IN_LISTS | RE_DOT_NOT_NULL			\
X   | RE_NO_BK_PARENS            | RE_NO_BK_REFS				\
X   | RE_NO_BK_VBAR              | RE_NO_EMPTY_RANGES			\
X   | RE_UNMATCHED_RIGHT_PAREN_ORD)
X
#define RE_SYNTAX_POSIX_AWK 						\
X  (RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS)
X
#define RE_SYNTAX_GREP							\
X  (RE_BK_PLUS_QM              | RE_CHAR_CLASSES				\
X   | RE_HAT_LISTS_NOT_NEWLINE | RE_INTERVALS				\
X   | RE_NEWLINE_ALT)
X
#define RE_SYNTAX_EGREP							\
X  (RE_CHAR_CLASSES        | RE_CONTEXT_INDEP_ANCHORS			\
X   | RE_CONTEXT_INDEP_OPS | RE_HAT_LISTS_NOT_NEWLINE			\
X   | RE_NEWLINE_ALT       | RE_NO_BK_PARENS				\
X   | RE_NO_BK_VBAR)
X
#define RE_SYNTAX_POSIX_EGREP						\
X  (RE_SYNTAX_EGREP | RE_INTERVALS | RE_NO_BK_BRACES)
X
#define RE_SYNTAX_SED RE_SYNTAX_POSIX_BASIC
X
/* Syntax bits common to both basic and extended POSIX regex syntax.  */
#define _RE_SYNTAX_POSIX_COMMON						\
X  (RE_CHAR_CLASSES | RE_DOT_NEWLINE      | RE_DOT_NOT_NULL		\
X   | RE_INTERVALS  | RE_NO_EMPTY_RANGES)
X
#define RE_SYNTAX_POSIX_BASIC						\
X  (_RE_SYNTAX_POSIX_COMMON | RE_BK_PLUS_QM)
X
/* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes
X   RE_LIMITED_OPS, i.e., \? \+ \| are not recognized.  Actually, this
X   isn't minimal, since other operators, such as \`, aren't disabled.  */
#define RE_SYNTAX_POSIX_MINIMAL_BASIC					\
X  (_RE_SYNTAX_POSIX_COMMON | RE_LIMITED_OPS)
X
#define RE_SYNTAX_POSIX_EXTENDED					\
X  (_RE_SYNTAX_POSIX_COMMON | RE_CONTEXT_INDEP_ANCHORS			\
X   | RE_CONTEXT_INDEP_OPS  | RE_NO_BK_BRACES				\
X   | RE_NO_BK_PARENS       | RE_NO_BK_VBAR				\
X   | RE_UNMATCHED_RIGHT_PAREN_ORD)
X
/* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INVALID_OPS
X   replaces RE_CONTEXT_INDEP_OPS and RE_NO_BK_REFS is added.  */
#define RE_SYNTAX_POSIX_MINIMAL_EXTENDED				\
X  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS			\
X   | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES				\
X   | RE_NO_BK_PARENS        | RE_NO_BK_REFS				\
X   | RE_NO_BK_VBAR	    | RE_UNMATCHED_RIGHT_PAREN_ORD)
/* [[[end syntaxes]]] */
X
/* Maximum number of duplicates an interval can allow.  Some systems
X   (erroneously) define this in other header files, but we want our
X   value, so remove any previous define.  */
#ifdef RE_DUP_MAX
#undef RE_DUP_MAX
#endif
#define RE_DUP_MAX ((1 << 15) - 1) 
X
X
X
/* POSIX `cflags' bits (i.e., information for `regcomp').  */
X
/* If this bit is set, then use extended regular expression syntax.
X   If not set, then use basic regular expression syntax.  */
#define REG_EXTENDED 1
X
/* If this bit is set, then ignore case when matching.
X   If not set, then case is significant.  */
#define REG_ICASE (REG_EXTENDED << 1)
X 
/* If this bit is set, then anchors do not match at newline
X     characters in the string.
X   If not set, then anchors do match at newlines.  */
#define REG_NEWLINE (REG_ICASE << 1)
X
/* If this bit is set, then report only success or fail in regexec.
X   If not set, then returns differ between not matching and errors.  */
#define REG_NOSUB (REG_NEWLINE << 1)
X
X
/* POSIX `eflags' bits (i.e., information for regexec).  */
X
/* If this bit is set, then the beginning-of-line operator doesn't match
X     the beginning of the string (presumably because it's not the
X     beginning of a line).
X   If not set, then the beginning-of-line operator does match the
X     beginning of the string.  */
#define REG_NOTBOL 1
X
/* Like REG_NOTBOL, except for the end-of-line.  */
#define REG_NOTEOL (1 << 1)
X
/* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,
X * `re_match_2' returns information about at least this many registers
X * the first time a `regs' structure is passed. 
X *
X * Also, this is the greatest number of backreferenced subexpressions
X * allowed in a pattern being matched without caller-supplied registers.
X */
#ifndef RE_NREGS
#define RE_NREGS 30
#endif
X
extern int rx_cache_bound;
extern char rx_version_string[];
X
X
X
#ifdef RX_WANT_RX_DEFS
X
/* This is decls to the interesting subsystems and lower layers
X * of rx.  Everything which doesn't have a public counterpart in 
X * regex.c is declared here.
X */
X
X
#ifdef __STDC__
typedef void (*rx_hash_freefn) (struct rx_hash_item * it);
#else /* ndef __STDC__ */
typedef void (*rx_hash_freefn) ();
#endif /* ndef __STDC__ */
X
X
X
X
#ifdef __STDC__
RX_DECL int rx_bitset_is_equal (int size, rx_Bitset a, rx_Bitset b);
RX_DECL int rx_bitset_is_subset (int size, rx_Bitset a, rx_Bitset b);
RX_DECL int rx_bitset_empty (int size, rx_Bitset set);
RX_DECL void rx_bitset_null (int size, rx_Bitset b);
RX_DECL void rx_bitset_universe (int size, rx_Bitset b);
RX_DECL void rx_bitset_complement (int size, rx_Bitset b);
RX_DECL void rx_bitset_assign (int size, rx_Bitset a, rx_Bitset b);
RX_DECL void rx_bitset_union (int size, rx_Bitset a, rx_Bitset b);
RX_DECL void rx_bitset_intersection (int size,
X				     rx_Bitset a, rx_Bitset b);
RX_DECL void rx_bitset_difference (int size, rx_Bitset a, rx_Bitset b);
RX_DECL void rx_bitset_revdifference (int size,
X				      rx_Bitset a, rx_Bitset b);
RX_DECL void rx_bitset_xor (int size, rx_Bitset a, rx_Bitset b);
RX_DECL unsigned long rx_bitset_hash (int size, rx_Bitset b);
RX_DECL struct rx_hash_item * rx_hash_find (struct rx_hash * table,
X					    unsigned long hash,
X					    void * value,
X					    struct rx_hash_rules * rules);
RX_DECL struct rx_hash_item * rx_hash_store (struct rx_hash * table,
X					     unsigned long hash,
X					     void * value,
X					     struct rx_hash_rules * rules);
RX_DECL void rx_hash_free (struct rx_hash_item * it, struct rx_hash_rules * rules);
RX_DECL void rx_free_hash_table (struct rx_hash * tab, rx_hash_freefn freefn,
X				 struct rx_hash_rules * rules);
RX_DECL rx_Bitset rx_cset (struct rx *rx);
RX_DECL rx_Bitset rx_copy_cset (struct rx *rx, rx_Bitset a);
RX_DECL void rx_free_cset (struct rx * rx, rx_Bitset c);
RX_DECL struct rexp_node * rexp_node (struct rx *rx,
X				      enum rexp_node_type type);
RX_DECL struct rexp_node * rx_mk_r_cset (struct rx * rx,
X					 rx_Bitset b);
RX_DECL struct rexp_node * rx_mk_r_concat (struct rx * rx,
X					   struct rexp_node * a,
X					   struct rexp_node * b);
RX_DECL struct rexp_node * rx_mk_r_alternate (struct rx * rx,
X					      struct rexp_node * a,
X					      struct rexp_node * b);
RX_DECL struct rexp_node * rx_mk_r_opt (struct rx * rx,
X					struct rexp_node * a);
RX_DECL struct rexp_node * rx_mk_r_star (struct rx * rx,
X					 struct rexp_node * a);
RX_DECL struct rexp_node * rx_mk_r_2phase_star (struct rx * rx,
X						struct rexp_node * a,
X						struct rexp_node * b);
RX_DECL struct rexp_node * rx_mk_r_side_effect (struct rx * rx,
X						rx_side_effect a);
RX_DECL struct rexp_node * rx_mk_r_data  (struct rx * rx,
X					  void * a);
RX_DECL void rx_free_rexp (struct rx * rx, struct rexp_node * node);
RX_DECL struct rexp_node * rx_copy_rexp (struct rx *rx,
X					 struct rexp_node *node);
RX_DECL struct rx_nfa_state * rx_nfa_state (struct rx *rx);
RX_DECL void rx_free_nfa_state (struct rx_nfa_state * n);
RX_DECL struct rx_nfa_state * rx_id_to_nfa_state (struct rx * rx,
X						  int id);
RX_DECL struct rx_nfa_edge * rx_nfa_edge (struct rx *rx,
X					  enum rx_nfa_etype type,
X					  struct rx_nfa_state *start,
X					  struct rx_nfa_state *dest);
RX_DECL void rx_free_nfa_edge (struct rx_nfa_edge * e);
RX_DECL void rx_free_nfa (struct rx *rx);
RX_DECL int rx_build_nfa (struct rx *rx,
X			  struct rexp_node *rexp,
X			  struct rx_nfa_state **start,
X			  struct rx_nfa_state **end);
RX_DECL void rx_name_nfa_states (struct rx *rx);
RX_DECL int rx_eclose_nfa (struct rx *rx);
RX_DECL void rx_delete_epsilon_transitions (struct rx *rx);
RX_DECL int rx_compactify_nfa (struct rx *rx,
X			       void **mem, unsigned long *size);
RX_DECL void rx_release_superset (struct rx *rx,
X				  struct rx_superset *set);
RX_DECL struct rx_superset * rx_superset_cons (struct rx * rx,
X					       struct rx_nfa_state *car, struct rx_superset *cdr);
RX_DECL struct rx_superset * rx_superstate_eclosure_union
X  (struct rx * rx, struct rx_superset *set, struct rx_nfa_state_set *ecl);
RX_DECL struct rx_superstate * rx_superstate (struct rx *rx,
X					      struct rx_superset *set);
RX_DECL struct rx_inx * rx_handle_cache_miss
X  (struct rx *rx, struct rx_superstate *super, unsigned char chr, void *data);
RX_DECL reg_errcode_t rx_compile (__const__ char *pattern, int size,
X				  reg_syntax_t syntax,
X				  struct re_pattern_buffer * rxb);
RX_DECL void rx_blow_up_fastmap (struct re_pattern_buffer * rxb);
#else /* STDC */
RX_DECL int rx_bitset_is_equal ();
RX_DECL int rx_bitset_is_subset ();
RX_DECL int rx_bitset_empty ();
RX_DECL void rx_bitset_null ();
RX_DECL void rx_bitset_universe ();
RX_DECL void rx_bitset_complement ();
RX_DECL void rx_bitset_assign ();
RX_DECL void rx_bitset_union ();
RX_DECL void rx_bitset_intersection ();
RX_DECL void rx_bitset_difference ();
RX_DECL void rx_bitset_revdifference ();
RX_DECL void rx_bitset_xor ();
RX_DECL unsigned long rx_bitset_hash ();
RX_DECL struct rx_hash_item * rx_hash_find ();
RX_DECL struct rx_hash_item * rx_hash_store ();
RX_DECL void rx_hash_free ();
RX_DECL void rx_free_hash_table ();
RX_DECL rx_Bitset rx_cset ();
RX_DECL rx_Bitset rx_copy_cset ();
RX_DECL void rx_free_cset ();
RX_DECL struct rexp_node * rexp_node ();
RX_DECL struct rexp_node * rx_mk_r_cset ();
RX_DECL struct rexp_node * rx_mk_r_concat ();
RX_DECL struct rexp_node * rx_mk_r_alternate ();
RX_DECL struct rexp_node * rx_mk_r_opt ();
RX_DECL struct rexp_node * rx_mk_r_star ();
RX_DECL struct rexp_node * rx_mk_r_2phase_star ();
RX_DECL struct rexp_node * rx_mk_r_side_effect ();
RX_DECL struct rexp_node * rx_mk_r_data  ();
RX_DECL void rx_free_rexp ();
RX_DECL struct rexp_node * rx_copy_rexp ();
RX_DECL struct rx_nfa_state * rx_nfa_state ();
RX_DECL void rx_free_nfa_state ();
RX_DECL struct rx_nfa_state * rx_id_to_nfa_state ();
RX_DECL struct rx_nfa_edge * rx_nfa_edge ();
RX_DECL void rx_free_nfa_edge ();
RX_DECL void rx_free_nfa ();
RX_DECL int rx_build_nfa ();
RX_DECL void rx_name_nfa_states ();
RX_DECL int rx_eclose_nfa ();
RX_DECL void rx_delete_epsilon_transitions ();
RX_DECL int rx_compactify_nfa ();
RX_DECL void rx_release_superset ();
RX_DECL struct rx_superset * rx_superset_cons ();
RX_DECL struct rx_superset * rx_superstate_eclosure_union ();
RX_DECL struct rx_superstate * rx_superstate ();
RX_DECL struct rx_inx * rx_handle_cache_miss ();
RX_DECL reg_errcode_t rx_compile ();
RX_DECL void rx_blow_up_fastmap ();
#endif /* STDC */
X
X
#endif /* RX_WANT_RX_DEFS */
X
X
X
#ifdef __STDC__
extern int re_search_2 (struct re_pattern_buffer *rxb,
X			__const__ char * string1, int size1,
X			__const__ char * string2, int size2,
X			int startpos, int range,
X			struct re_registers *regs,
X			int stop);
extern int re_search (struct re_pattern_buffer * rxb, __const__ char *string,
X		      int size, int startpos, int range,
X		      struct re_registers *regs);
extern int re_match_2 (struct re_pattern_buffer * rxb,
X		       __const__ char * string1, int size1,
X		       __const__ char * string2, int size2,
X		       int pos, struct re_registers *regs, int stop);
extern int re_match (struct re_pattern_buffer * rxb,
X		     __const__ char * string,
X		     int size, int pos,
X		     struct re_registers *regs);
extern reg_syntax_t re_set_syntax (reg_syntax_t syntax);
extern void re_set_registers (struct re_pattern_buffer *bufp,
X			      struct re_registers *regs,
X			      unsigned num_regs,
X			      regoff_t * starts, regoff_t * ends);
extern __const__ char * re_compile_pattern (__const__ char *pattern,
X					int length,
X					struct re_pattern_buffer * rxb);
extern int re_compile_fastmap (struct re_pattern_buffer * rxb);
extern char * re_comp (__const__ char *s);
extern int re_exec (__const__ char *s);
extern int regcomp (regex_t * preg, __const__ char * pattern, int cflags);
extern int regexec (__const__ regex_t *preg, __const__ char *string,
X		    size_t nmatch, regmatch_t pmatch[],
X		    int eflags);
extern size_t regerror (int errcode, __const__ regex_t *preg,
X			char *errbuf, size_t errbuf_size);
extern void regfree (regex_t *preg);
X
#else /* STDC */
extern int re_search_2 ();
extern int re_search ();
extern int re_match_2 ();
extern int re_match ();
extern reg_syntax_t re_set_syntax ();
extern void re_set_registers ();
extern __const__ char * re_compile_pattern ();
extern int re_compile_fastmap ();
extern char * re_comp ();
extern int re_exec ();
extern int regcomp ();
extern int regexec ();
extern size_t regerror ();
extern void regfree ();
X
#endif /* STDC */
X
X
X
#ifdef RX_WANT_RX_DEFS
X
struct rx_counter_frame
{
X  int tag;
X  int val;
X  struct rx_counter_frame * inherited_from; /* If this is a copy. */
X  struct rx_counter_frame * cdr;
};
X
struct rx_backtrack_frame
{
X  char * counter_stack_sp;
X
X  /* A frame is used to save the matchers state when it crosses a 
X   * backtracking point.  The `stk_' fields correspond to variables
X   * in re_search_2 (just strip off thes `stk_').  They are documented
X   * tere.
X   */
X  struct rx_superstate * stk_super;
X  unsigned int stk_c;
X  struct rx_string_position stk_test_pos;
X  int stk_last_l;
X  int stk_last_r;
X  int stk_test_ret;
X
X  /* This is the list of options left to explore at the backtrack
X   * point for which this frame was created. 
X   */
X  struct rx_distinct_future * df;
X  struct rx_distinct_future * first_df;
X
#ifdef RX_DEBUG
X   int stk_line_no;
#endif
};
X
struct rx_stack_chunk
{
X  struct rx_stack_chunk * next_chunk;
X  int bytes_left;
X  char * sp;
};
X
enum rx_outer_entry
{
X  rx_outer_start,
X  rx_outer_fastmap,
X  rx_outer_test,
X  rx_outer_restore_pos
};
X
enum rx_fastmap_return
{
X  rx_fastmap_continuation,
X  rx_fastmap_error,
X  rx_fastmap_ok,
X  rx_fastmap_fail
};
X
enum rx_fastmap_entry
{
X  rx_fastmap_start,
X  rx_fastmap_string_break
};
X
enum rx_test_return
{
X  rx_test_continuation,
X  rx_test_error,
X  rx_test_fail,
X  rx_test_ok
};
X
enum rx_test_internal_return
{
X  rx_test_internal_error,
X  rx_test_found_first,
X  rx_test_line_finished
};
X
enum rx_test_match_entry
{
X  rx_test_start,
X  rx_test_cache_hit_loop,
X  rx_test_backreference_check,
X  rx_test_backtrack_return
};
X
struct rx_search_state
{
X  /* Two groups of registers are kept.  The group with the register state
X   * of the current test match, and the group that holds the state at the end
X   * of the best known match, if any.
X   *
X   * For some patterns, there may also be registers saved on the stack.
X   */
X  unsigned num_regs;		/* Includes an element for register zero. */
X  regoff_t * lparen;		/* scratch space for register returns */
X  regoff_t * rparen;
X  regoff_t * best_lpspace;	/* in case the user doesn't want these */
X  regoff_t * best_rpspace;	/* values, we still need space to store
X				 * them.  Normally, this memoryis unused
X				 * and the space pointed to by REGS is 
X				 * used instead.
X				 */
X  
X  int last_l;			/* Highest index of a valid lparen. */
X  int last_r;			/* It's dual. */
X  
X  int * best_lparen;		/* This contains the best known register */
X  int * best_rparen;		/* assignments. 
X				 * This may point to the same mem as
X				 * best_lpspace, or it might point to memory
X				 * passed by the caller.
X				 */
X  int best_last_l;		/* best_last_l:best_lparen::last_l:lparen */
X  int best_last_r;
X
X
X  unsigned char * translate;  
X
X  struct rx_string_position outer_pos;
X
X  struct rx_superstate * start_super;
X  int nfa_choice;
X  int first_found;		/* If true, return after finding any match. */
X  int ret_val;
X
X  /* For continuations... */
X  enum rx_outer_entry outer_search_resume_pt;
X  struct re_pattern_buffer * saved_rxb;
X  int saved_startpos;
X  int saved_range;
X  int saved_stop;
X  int saved_total_size;
X  rx_get_burst_fn saved_get_burst;
X  rx_back_check_fn saved_back_check;
X  struct re_registers * saved_regs;
X  
X  /**
X   ** state for fastmap
X   **/
X  char * fastmap;
X  int fastmap_chr;
X  int fastmap_val;
X
X  /* for continuations in the fastmap procedure: */
X  enum rx_fastmap_entry fastmap_resume_pt;
X
X  /**
X   ** state for test_match 
X   **/
X
X  /* The current superNFA position of the matcher. */
X  struct rx_superstate * super;
X  
X  /* The matcher interprets a series of instruction frames.
X   * This is the `instruction counter' for the interpretation.
X   */
X  struct rx_inx * ifr;
X  
X  /* We insert a ghost character in the string to prime
X   * the nfa.  test_pos.pos, test_pos.str_half, and test_pos.end_half
X   * keep track of the test-match position and string-half.
X   */
X  unsigned char c;
X  
X  /* Position within the string. */
X  struct rx_string_position test_pos;
X
X  struct rx_stack_chunk * counter_stack;
X  struct rx_stack_chunk * backtrack_stack;
X  int backtrack_frame_bytes;
X  int chunk_bytes;
X  struct rx_stack_chunk * free_chunks;
X
X  /* To return from this function, set test_ret and 
X   * `goto test_do_return'.
X   *
X   * Possible return values are:
X   *     1   --- end of string while the superNFA is still going
X   *     0   --- internal error (out of memory)
X   *	-1   --- search completed by reaching the superNFA fail state
X   *    -2   --- a match was found, maybe not the longest.
X   *
X   * When the search is complete (-1), best_last_r indicates whether
X   * a match was found.
X   *
X   * -2 is return only if search_state.first_found is non-zero.
X   *
X   * if search_state.first_found is non-zero, a return of -1 indicates no match,
X   * otherwise, best_last_r has to be checked.
X   */
X  int test_ret;
X
X  int could_have_continued;
X  
#ifdef RX_DEBUG
X  int backtrack_depth;
X  /* There is a search tree with every node as set of deterministic
X   * transitions in the super nfa.  For every branch of a 
X   * backtrack point is an edge in the tree.
X   * This counts up a pre-order of nodes in that tree.
X   * It's saved on the search stack and printed when debugging. 
X   */
X  int line_no;
X  int lines_found;
#endif
X
X
X  /* For continuations within the match tester */
X  enum rx_test_match_entry test_match_resume_pt;
X  struct rx_inx * saved_next_tr_table;
X  struct rx_inx * saved_this_tr_table;
X  int saved_reg;
X  struct rx_backtrack_frame * saved_bf;
X  
};
X
X
extern char rx_slowmap[];
extern unsigned char rx_id_translation[];
X
static __inline__ void
init_fastmap (rxb, search_state)
X     struct re_pattern_buffer * rxb;
X     struct rx_search_state * search_state;
{
X  search_state->fastmap = (rxb->fastmap
X			   ? (char *)rxb->fastmap
X			   : (char *)rx_slowmap);
X  /* Update the fastmap now if not correct already. 
X   * When the regexp was compiled, the fastmap was computed
X   * and stored in a bitset.  This expands the bitset into a
X   * character array containing 1s and 0s.
X   */
X  if ((search_state->fastmap == rxb->fastmap) && !rxb->fastmap_accurate)
X    rx_blow_up_fastmap (rxb);
X  search_state->fastmap_chr = -1;
X  search_state->fastmap_val = 0;
X  search_state->fastmap_resume_pt = rx_fastmap_start;
}
X
static __inline__ void
uninit_fastmap (rxb, search_state)
X     struct re_pattern_buffer * rxb;
X     struct rx_search_state * search_state;
{
X  /* Unset the fastmap sentinel */
X  if (search_state->fastmap_chr >= 0)
X    search_state->fastmap[search_state->fastmap_chr]
X      = search_state->fastmap_val;
}
X
static __inline__ int
fastmap_search (rxb, stop, get_burst, app_closure, search_state)
X     struct re_pattern_buffer * rxb;
X     int stop;
X     rx_get_burst_fn get_burst;
X     void * app_closure;
X     struct rx_search_state * search_state;
{
X  enum rx_fastmap_entry pc;
X
X  if (0)
X    {
X    return_continuation:
X      search_state->fastmap_resume_pt = pc;
X      return rx_fastmap_continuation;
X    }
X
X  pc = search_state->fastmap_resume_pt;
X
X  switch (pc)
X    {
X    case rx_fastmap_start:
X    init_fastmap_sentinal:
X      /* For the sake of fast fastmapping, set a sentinal in the fastmap.
X       * This sentinal will trap the fastmap loop when it reaches the last
X       * valid character in a string half.
X       *
X       * This must be reset when the fastmap/search loop crosses a string 
X       * boundry, and before returning to the caller.  So sometimes,
X       * the fastmap loop is restarted with `continue', othertimes by
X       * `goto init_fastmap_sentinal'.
X       */
X      if (search_state->outer_pos.size)
X	{
X	  search_state->fastmap_chr = ((search_state->outer_pos.search_direction == 1)
X				       ? *(search_state->outer_pos.end - 1)
X				       : *search_state->outer_pos.string);
X	  search_state->fastmap_val
X	    = search_state->fastmap[search_state->fastmap_chr];
X	  search_state->fastmap[search_state->fastmap_chr] = 1;
X	}
X      else
X	{
X	  search_state->fastmap_chr = -1;
X	  search_state->fastmap_val = 0;
X	}
X      
X      if (search_state->outer_pos.pos >= search_state->outer_pos.end)
X	goto fastmap_hit_bound;
X      else
X	{
X	  if (search_state->outer_pos.search_direction == 1)
X	    {
X	      if (search_state->fastmap_val)
X		{
X		  for (;;)
X		    {
X		      while (!search_state->fastmap[*search_state->outer_pos.pos])
X			++search_state->outer_pos.pos;
X		      return rx_fastmap_ok;
X		    }
X		}
X	      else
X		{
X		  for (;;)
X		    {
X		      while (!search_state->fastmap[*search_state->outer_pos.pos])
X			++search_state->outer_pos.pos;
X		      if (*search_state->outer_pos.pos != search_state->fastmap_chr)
X			return rx_fastmap_ok;
X		      else 
X			{
X			  ++search_state->outer_pos.pos;
X			  if (search_state->outer_pos.pos == search_state->outer_pos.end)
X			    goto fastmap_hit_bound;
X			}
X		    }
X		}
X	    }
X	  else
X	    {
X	      __const__ unsigned char * bound;
X	      bound = search_state->outer_pos.string - 1;
X	      if (search_state->fastmap_val)
X		{
X		  for (;;)
X		    {
X		      while (!search_state->fastmap[*search_state->outer_pos.pos])
X			--search_state->outer_pos.pos;
X		      return rx_fastmap_ok;
X		    }
X		}
X	      else
X		{
X		  for (;;)
X		    {
X		      while (!search_state->fastmap[*search_state->outer_pos.pos])
X			--search_state->outer_pos.pos;
X		      if ((*search_state->outer_pos.pos != search_state->fastmap_chr) || search_state->fastmap_val)
X			return rx_fastmap_ok;
X		      else 
X			{
X			  --search_state->outer_pos.pos;
X			  if (search_state->outer_pos.pos == bound)
X			    goto fastmap_hit_bound;
X			}
X		    }
X		}
X	    }
X	}
X      
X    case rx_fastmap_string_break:
X    fastmap_hit_bound:
X      {
X	/* If we hit a bound, it may be time to fetch another burst
X	 * of string, or it may be time to return a continuation to 
X 	 * the caller, or it might be time to fail.
X	 */
X
X	int burst_state;
X	burst_state = get_burst (&search_state->outer_pos, app_closure, stop);
X	switch (burst_state)
X	  {
X	  case rx_get_burst_continuation:
X	    {
X	      pc = rx_fastmap_string_break;
X	      goto return_continuation;
X	    }
X	  case rx_get_burst_error:
X	    return rx_fastmap_error;
X	  case rx_get_burst_ok:
X	    goto init_fastmap_sentinal;
X	  case rx_get_burst_no_more:
X	    /* ...not a string split, simply no more string. 
X	     *
X	     * When searching backward, running out of string
X	     * is reason to quit.
X	     *
X	     * When searching forward, we allow the possibility
X	     * of an (empty) match after the last character in the
X	     * virtual string.  So, fall through to the matcher
X	     */
X	    return (  (search_state->outer_pos.search_direction == 1)
X		    ? rx_fastmap_ok
X		    : rx_fastmap_fail);
X	  }
X      }
X    }
X
}
X
X
X
#ifdef emacs
/* The `emacs' switch turns on certain matching commands
X * that make sense only in Emacs. 
X */
#include "config.h"
#include "lisp.h"
#include "buffer.h"
#include "syntax.h"
/* Emacs uses `NULL' as a predicate.  */
#undef NULL
#else  /* not emacs */
/* Setting RX_MEMDBUG is useful if you have dbmalloc.  Maybe with similar
X * packages too.
X */
#ifdef RX_MEMDBUG
#include <malloc.h>
#else /* not RX_RX_MEMDBUG */
X
/* We used to test for `BSTRING' here, but only GCC and Emacs define
X * `BSTRING', as far as I know, and neither of them use this code.  
X */
#if HAVE_STRING_H || STDC_HEADERS
#include <string.h>
X
#ifndef bcmp
#define bcmp(s1, s2, n)	memcmp ((s1), (s2), (n))
#endif
X
#ifndef bcopy
#define bcopy(s, d, n)	memcpy ((d), (s), (n))
#endif
X
#ifndef bzero
#define bzero(s, n)	memset ((s), 0, (n))
#endif
X
#else /*  HAVE_STRING_H || STDC_HEADERS */
#include <strings.h>
#endif   /* not RX_MEMDBUG */
X
#ifdef STDC_HEADERS
#include <stdlib.h>
#else /* not STDC_HEADERS */
char *malloc ();
char *realloc ();
#endif /* not STDC_HEADERS */
X
#endif /* not emacs */
X
X
X
/* Define the syntax basics for \<, \>, etc.
X * This must be nonzero for the wordchar and notwordchar pattern
X * commands in re_match_2.
X */
#ifndef Sword 
#define Sword 1
#endif
X
/* How many characters in the character set.  */
#define CHAR_SET_SIZE (1 << CHARBITS)
#define SYNTAX(c) re_syntax_table[c]
RX_DECL char re_syntax_table[CHAR_SET_SIZE];
X
#endif /* not emacs */
X
X
/* Test if at very beginning or at very end of the virtual concatenation
X *  of `string1' and `string2'.  If only one string, it's `string2'.  
X */
X
#define AT_STRINGS_BEG() \
X  (   -1		 \
X   == ((search_state.test_pos.pos - search_state.test_pos.string) \
X       + search_state.test_pos.offset))
X
#define AT_STRINGS_END() \
X  (   (total_size - 1)	 \
X   == ((search_state.test_pos.pos - search_state.test_pos.string) \
X       + search_state.test_pos.offset))
X
X
/* Test if POS + 1 points to a character which is word-constituent.  We have
X * two special cases to check for: if past the end of string1, look at
X * the first character in string2; and if before the beginning of
X * string2, look at the last character in string1.
X *
X * Assumes `string1' exists, so use in conjunction with AT_STRINGS_BEG ().  
X */
#define LETTER_P(POS,OFF)						\
X  (   SYNTAX (fetch_char(POS, OFF, app_closure, stop))			\
X   == Sword)
X
/* Test if the character at D and the one after D differ with respect
X * to being word-constituent.  
X */
#define AT_WORD_BOUNDARY(d)						\
X  (AT_STRINGS_BEG () || AT_STRINGS_END () || LETTER_P (d,0) != LETTER_P (d, 1))
X
X
#ifdef RX_SUPPORT_CONTINUATIONS
#define RX_STACK_ALLOC(BYTES) malloc(BYTES)
#define RX_STACK_FREE(MEM) free(MEM)
#else
#define RX_STACK_ALLOC(BYTES) alloca(BYTES)
#define RX_STACK_FREE(MEM) \
X      ((struct rx_stack_chunk *)MEM)->next_chunk = search_state.free_chunks; \
X      search_state.free_chunks = ((struct rx_stack_chunk *)MEM);
X
#endif
X
#define PUSH(CHUNK_VAR,BYTES)   \
X  if (!CHUNK_VAR || (CHUNK_VAR->bytes_left < (BYTES)))  \
X    {					\
X      struct rx_stack_chunk * new_chunk;	\
X      if (search_state.free_chunks)			\
X	{				\
X	  new_chunk = search_state.free_chunks;	\
X	  search_state.free_chunks = search_state.free_chunks->next_chunk; \
X	}				\
X      else				\
X	{				\
X	  new_chunk = (struct rx_stack_chunk *)RX_STACK_ALLOC(search_state.chunk_bytes); \
X	  if (!new_chunk)		\
X	    {				\
X	      search_state.ret_val = 0;		\
X	      goto test_do_return;	\
X	    }				\
X	}				\
X      new_chunk->sp = (char *)new_chunk + sizeof (struct rx_stack_chunk); \
X      new_chunk->bytes_left = (search_state.chunk_bytes \
X			       - (BYTES) \
X			       - sizeof (struct rx_stack_chunk)); \
X      new_chunk->next_chunk = CHUNK_VAR; \
X      CHUNK_VAR = new_chunk;		\
X    } \
X  else \
X    (CHUNK_VAR->sp += (BYTES)), (CHUNK_VAR->bytes_left -= (BYTES))
X
#define POP(CHUNK_VAR,BYTES) \
X  if (CHUNK_VAR->sp == ((char *)CHUNK_VAR + sizeof(*CHUNK_VAR))) \
X    { \
X      struct rx_stack_chunk * new_chunk = CHUNK_VAR->next_chunk; \
X      RX_STACK_FREE(CHUNK_VAR); \
X      CHUNK_VAR = new_chunk; \
X    } \
X  else \
X    (CHUNK_VAR->sp -= BYTES), (CHUNK_VAR->bytes_left += BYTES)
X
X
X
#define SRCH_TRANSLATE(C)  search_state.translate[(unsigned char) (C)]
X
X
X
X
#ifdef __STDC__
RX_DECL __inline__ int
rx_search  (struct re_pattern_buffer * rxb,
X	    int startpos,
X	    int range,
X	    int stop,
X	    int total_size,
X	    rx_get_burst_fn get_burst,
X	    rx_back_check_fn back_check,
X	    rx_fetch_char_fn fetch_char,
X	    void * app_closure,
X	    struct re_registers * regs,
X	    struct rx_search_state * resume_state,
X	    struct rx_search_state * save_state)
#else
RX_DECL __inline__ int
rx_search  (rxb, startpos, range, stop, total_size,
X	    get_burst, back_check, fetch_char,
X	    app_closure, regs, resume_state, save_state)
X     struct re_pattern_buffer * rxb;
X     int startpos;
X     int range;
X     int stop;
X     int total_size;
X     rx_get_burst_fn get_burst;
X     rx_back_check_fn back_check;
X     rx_fetch_char_fn fetch_char;
X     void * app_closure;
X     struct re_registers * regs;
X     struct rx_search_state * resume_state;
X     struct rx_search_state * save_state;
#endif
{
X  int pc;
X  int test_state;
X  struct rx_search_state search_state;
X
X  if (!resume_state)
X    pc = rx_outer_start;
X  else
X    {
X      search_state = *resume_state;
X      regs = search_state.saved_regs;
X      rxb = search_state.saved_rxb;
X      startpos = search_state.saved_startpos;
X      range = search_state.saved_range;
X      stop = search_state.saved_stop;
X      total_size = search_state.saved_total_size;
X      get_burst = search_state.saved_get_burst;
X      back_check = search_state.saved_back_check;
X      pc = search_state.outer_search_resume_pt;
X      if (0)
X	{
X	return_continuation:
X	  if (save_state)
X	    {
X	      *save_state = search_state;
X	      save_state->saved_regs = regs;
X	      save_state->saved_rxb = rxb;
X	      save_state->saved_startpos = startpos;
X	      save_state->saved_range = range;
X	      save_state->saved_stop = stop;
X	      save_state->saved_total_size = total_size;
X	      save_state->saved_get_burst = get_burst;
X	      save_state->saved_back_check = back_check;
X	      save_state->outer_search_resume_pt = pc;
X	    }
X	  return rx_search_continuation;
X	}
X    }
X
X  switch (pc)
X    {
X    case rx_outer_start:
X      search_state.ret_val = rx_search_fail;
X      (  search_state.lparen
X       = search_state.rparen
X       = search_state.best_lpspace
X       = search_state.best_rpspace
X       = 0);
X      
X      /* figure the number of registers we may need for use in backreferences.
X       * the number here includes an element for register zero.  
X       */
X      search_state.num_regs = rxb->re_nsub + 1;
X      
X      
X      /* check for out-of-range startpos.  */
X      if ((startpos < 0) || (startpos > total_size))
X	return rx_search_fail;
X      
X      /* fix up range if it might eventually take us outside the string. */
X      {
X	int endpos;
X	endpos = startpos + range;
X	if (endpos < -1)
X	  range = (-1 - startpos);
X	else if (endpos > total_size)
X	  range = total_size - startpos;
X      }
X      
X      /* if the search isn't to be a backwards one, don't waste time in a
X       * long search for a pattern that says it is anchored.
X       */
X      if (rxb->begbuf_only && (range > 0))
X	{
X	  if (startpos > 0)
X	    return rx_search_fail;
X	  else
X	    range = 1;
X	}
X      
X      /* decide whether to use internal or user-provided reg buffers. */
X      if (!regs || rxb->no_sub)
X	{
X	  search_state.best_lpspace =
X	    (regoff_t *)REGEX_ALLOCATE (search_state.num_regs * sizeof(regoff_t));
X	  search_state.best_rpspace =
X	    (regoff_t *)REGEX_ALLOCATE (search_state.num_regs * sizeof(regoff_t));
X	  search_state.best_lparen = search_state.best_lpspace;
X	  search_state.best_rparen = search_state.best_rpspace;
X	}
X      else
X	{	
X	  /* have the register data arrays been allocated?  */
X	  if (rxb->regs_allocated == REGS_UNALLOCATED)
X	    { /* no.  so allocate them with malloc.  we need one
X		 extra element beyond `search_state.num_regs' for the `-1' marker
X		 gnu code uses.  */
X	      regs->num_regs = MAX (RE_NREGS, rxb->re_nsub + 1);
X	      regs->start = ((regoff_t *)
X			     malloc (regs->num_regs * sizeof ( regoff_t)));
X	      regs->end = ((regoff_t *)
X			   malloc (regs->num_regs * sizeof ( regoff_t)));
X	      if (regs->start == 0 || regs->end == 0)
X		return rx_search_error;
X	      rxb->regs_allocated = REGS_REALLOCATE;
X	    }
X	  else if (rxb->regs_allocated == REGS_REALLOCATE)
X	    { /* yes.  if we need more elements than were already
X		 allocated, reallocate them.  if we need fewer, just
X		 leave it alone.  */
X	      if (regs->num_regs < search_state.num_regs + 1)
X		{
X		  regs->num_regs = search_state.num_regs + 1;
X		  regs->start = ((regoff_t *)
X				 realloc (regs->start,
X					  regs->num_regs * sizeof (regoff_t)));
X		  regs->end = ((regoff_t *)
X			       realloc (regs->end,
X					regs->num_regs * sizeof ( regoff_t)));
X		  if (regs->start == 0 || regs->end == 0)
X		    return rx_search_error;
X		}
X	    }
X	  else if (rxb->regs_allocated != REGS_FIXED)
X	    return rx_search_error;
X	  
X	  if (regs->num_regs < search_state.num_regs + 1)
X	    {
X	      search_state.best_lpspace =
X		((regoff_t *)
X		 REGEX_ALLOCATE (search_state.num_regs * sizeof(regoff_t)));
X	      search_state.best_rpspace =
X		((regoff_t *)
X		 REGEX_ALLOCATE (search_state.num_regs * sizeof(regoff_t)));
X	      search_state.best_lparen = search_state.best_lpspace;
X	      search_state.best_rparen = search_state.best_rpspace;
X	    }
X	  else
X	    {
X	      search_state.best_lparen = regs->start;
X	      search_state.best_rparen = regs->end;
X	    }
X	}
X      
X      search_state.lparen =
X	(regoff_t *) REGEX_ALLOCATE (search_state.num_regs * sizeof(regoff_t));
X      search_state.rparen =
X	(regoff_t *) REGEX_ALLOCATE (search_state.num_regs * sizeof(regoff_t)); 
X      
X      if (! (   search_state.best_rparen
X	     && search_state.best_lparen
X	     && search_state.lparen && search_state.rparen))
X	return rx_search_error;
X      
X      search_state.best_last_l = search_state.best_last_r = -1;
X      
X      search_state.translate = (rxb->translate
X				? rxb->translate
X				: rx_id_translation);
X      
X      
X      
X      /*
X       * two nfa's were compiled.  
X       * `0' is complete.
X       * `1' faster but gets registers wrong and ends too soon.
X       */
X      search_state.nfa_choice = (regs && !rxb->least_subs) ? '\0' : '\1';
X      
X      /* we have the option to look for the best match or the first
X       * one we can find.  if the user isn't asking for register information,
X       * we don't need to find the best match.
X       */
X      search_state.first_found = !regs;
X      
X      if (range >= 0)
X	{
X	  search_state.outer_pos.search_end = MIN (total_size, startpos + range) + 1;
X	  search_state.outer_pos.search_direction = 1;
X	}
X      else
X	{
X	  search_state.outer_pos.search_end = MAX(-1, startpos + range);
X	  search_state.outer_pos.search_direction = -1;
X	}
X      
X      /* the vacuous search always turns up nothing. */
X      if ((search_state.outer_pos.search_direction == 1)
X	  ? (startpos > search_state.outer_pos.search_end)
X	  : (startpos < search_state.outer_pos.search_end))
X	return rx_search_fail;
X      
X      /* now we build the starting state of the supernfa. */
X      {
X	struct rx_superset * start_contents;
X	struct rx_nfa_state_set * start_nfa_set;
X	
X	/* we presume here that the nfa start state has only one
X	 * possible future with no side effects.  
X	 */
X	start_nfa_set = rxb->start->futures->destset;
X	if (   rxb->rx.start_set
X	    && (rxb->rx.start_set->starts_for == &rxb->rx))
X	  start_contents = rxb->rx.start_set;
X	else
X	  {
X	    start_contents =
X	      rx_superstate_eclosure_union (&rxb->rx,
X					    rx_superset_cons (&rxb->rx, 0, 0),
X					    start_nfa_set);
X	    
X	    if (!start_contents)
X	      return rx_search_fail;
X	    
X	    start_contents->starts_for = &rxb->rx;
X	    rxb->rx.start_set = start_contents;
X	  }
X	if (   start_contents->superstate
X	    && (start_contents->superstate->rx_id == rxb->rx.rx_id))
X	  {
X	    search_state.start_super = start_contents->superstate;
X	    rx_lock_superstate (&rxb->rx, search_state.start_super);
X	  }
X	else
X	  {
X	    rx_protect_superset (&rxb->rx, start_contents);
X	    
X	    search_state.start_super = rx_superstate (&rxb->rx, start_contents);
X	    if (!search_state.start_super)
X	      return rx_search_fail;
X	    rx_lock_superstate (&rxb->rx, search_state.start_super);
X	    rx_release_superset (&rxb->rx, start_contents);
X	  }
X      }
X      
X      
X	
X      (  search_state.outer_pos.string
X       = search_state.outer_pos.end
X       = 0);
X
X      search_state.outer_pos.offset = 0;
X      search_state.outer_pos.size = 0;
X      search_state.outer_pos.pos = (unsigned char *)startpos;
X      init_fastmap (rxb, &search_state);
X
X      search_state.fastmap_resume_pt = rx_fastmap_start;
X    case rx_outer_fastmap:
X      /* do { */
X    pseudo_do:
X      {
X	{
X	  int fastmap_state;
X	  fastmap_state = fastmap_search (rxb, stop, get_burst, app_closure,
X					  &search_state);
X	  switch (fastmap_state)
X	    {
X	    case rx_fastmap_continuation:
X	      pc = rx_outer_fastmap;
X	      goto return_continuation;
X	    case rx_fastmap_fail:
X	      goto finish;
X	    case rx_fastmap_ok:
X	      break;
X	    }
X	}
X	
X	/* now the fastmap loop has brought us to a plausible 
X	 * starting point for a match.  so, it's time to run the
X	 * nfa and see if a match occured.
X	 */
X	startpos = (  search_state.outer_pos.pos
X		    - search_state.outer_pos.string
X		    + search_state.outer_pos.offset);
X	if (startpos == search_state.outer_pos.search_end)
X	  goto finish;
X      }
X
X      search_state.test_match_resume_pt = rx_test_start;
X      /* do interrupted for entry point... */
X    case rx_outer_test:
X      /* ...do continued */
X      {
X	goto test_match;
X      test_returns_to_search:
X	switch (test_state)
X	  {
X	  case rx_test_continuation:
X	    pc = rx_outer_test;
X	    goto return_continuation;
X	  case rx_test_error:
X	    search_state.ret_val = rx_search_error;
X	    goto finish;
X	  case rx_test_fail:
X	    break;
X	  case rx_test_ok:
X	    goto finish;
X	  }
X	search_state.outer_pos.pos += search_state.outer_pos.search_direction;
X	startpos += search_state.outer_pos.search_direction;
X      }
X      /* do interrupted for entry point... */
X    case rx_outer_restore_pos:
X      {
X	int x;
X	x = get_burst (&search_state.outer_pos, app_closure, stop);
X	switch (x)
X	  {
X	  case rx_get_burst_continuation:
X	    pc = rx_outer_restore_pos;
X	    goto return_continuation;
X	  case rx_get_burst_error:
X	    search_state.ret_val = rx_search_error;
X	    goto finish;
X	  case rx_get_burst_no_more:
X	    goto finish;
X	  case rx_get_burst_ok:
X	    break;
X	  }
X      } /* } while (...see below...) */
X      if ((search_state.outer_pos.search_direction == 1)
X	  ? (startpos < search_state.outer_pos.search_end)
X	  : (startpos > search_state.outer_pos.search_end))
X	goto pseudo_do;
X
X	
X    finish:
X      uninit_fastmap (rxb, &search_state);
X      if (search_state.start_super)
X	rx_unlock_superstate (&rxb->rx, search_state.start_super);
X      
#ifdef regex_malloc
X      if (search_state.lparen) free (search_state.lparen);
X      if (search_state.rparen) free (search_state.rparen);
X      if (search_state.best_lpspace) free (search_state.best_lpspace);
X      if (search_state.best_rpspace) free (search_state.best_rpspace);
#endif
X      return search_state.ret_val;
X    }
X
X
X test_match:
X  {
X    enum rx_test_match_entry test_pc;
X    int inx;
X    test_pc = search_state.test_match_resume_pt;
X    if (test_pc == rx_test_start)
X      {
#ifdef RX_DEBUG
X	search_state.backtrack_depth = 0;
#endif
X	search_state.last_l = search_state.last_r = 0;
X	search_state.lparen[0] = startpos;
X	search_state.super = search_state.start_super;
X	search_state.c = search_state.nfa_choice;
X	search_state.test_pos.pos = search_state.outer_pos.pos - 1;    
X	search_state.test_pos.string = search_state.outer_pos.string;
X	search_state.test_pos.end = search_state.outer_pos.end;
X	search_state.test_pos.offset = search_state.outer_pos.offset;
X	search_state.test_pos.size = search_state.outer_pos.size;
X	search_state.test_pos.search_direction = 1;
X	search_state.counter_stack = 0;
X	search_state.backtrack_stack = 0;
X	search_state.backtrack_frame_bytes =
X	  (sizeof (struct rx_backtrack_frame)
X	   + (rxb->match_regs_on_stack
X	      ? sizeof (regoff_t) * (search_state.num_regs + 1) * 2
X	      : 0));
X	search_state.chunk_bytes = search_state.backtrack_frame_bytes * 64;
X	search_state.free_chunks = 0;
X	search_state.test_ret = rx_test_line_finished;
X	search_state.could_have_continued = 0;
X      }  
X    /* This is while (1)...except that the body of the loop is interrupted 
X     * by some alternative entry points.
X     */
X  pseudo_while_1:
X    switch (test_pc)
X      {
X      case rx_test_cache_hit_loop:
X	goto resume_continuation_1;
X      case rx_test_backreference_check:
X	goto resume_continuation_2;
X      case rx_test_backtrack_return:
X	goto resume_continuation_3;
X      case rx_test_start:
#ifdef RX_DEBUG
X	/* There is a search tree with every node as set of deterministic
X	 * transitions in the super nfa.  For every branch of a 
X	 * backtrack point is an edge in the tree.
X	 * This counts up a pre-order of nodes in that tree.
X	 * It's saved on the search stack and printed when debugging. 
X	 */
X	search_state.line_no = 0;
X	search_state.lines_found = 0;
#endif
X	
X      top_of_cycle:
X	/* A superstate is basicly a transition table, indexed by 
X	 * characters from the string being tested, and containing 
X	 * RX_INX (`instruction frame') structures.
X	 */
X	search_state.ifr = &search_state.super->transitions [search_state.c];
X	
X      recurse_test_match:
X	/* This is the point to which control is sent when the
X	 * test matcher `recurses'.  Before jumping here, some variables
X	 * need to be saved on the stack and the next instruction frame
X	 * has to be computed.
X	 */
X	
X      restart:
X	/* Some instructions don't advance the matcher, but just
X	 * carry out some side effects and fetch a new instruction.
X	 * To dispatch that new instruction, `goto restart'.
X	 */
X	
X	{
X	  struct rx_inx * next_tr_table;
X	  struct rx_inx * this_tr_table;
X	  /* The fastest route through the loop is when the instruction 
X	   * is RX_NEXT_CHAR.  This case is detected when SEARCH_STATE.IFR->DATA
X	   * is non-zero.  In that case, it points to the next
X	   * superstate. 
X	   *
X	   * This allows us to not bother fetching the bytecode.
X	   */
X	  next_tr_table = (struct rx_inx *)search_state.ifr->data;
X	  this_tr_table = search_state.super->transitions;
X	  while (next_tr_table)
X	    {
#ifdef RX_DEBUG
X	      if (rx_debug_trace)
X		{
X		  struct rx_superset * setp;
X		  
X		  fprintf (stderr, "%d %d>> re_next_char @ %d (%d)",
X			   search_state.line_no,
X			   search_state.backtrack_depth,
X			   (search_state.test_pos.pos - search_state.test_pos.string
X			    + search_state.test_pos.offset), search_state.c);
X		  
X		  search_state.super =
X		    ((struct rx_superstate *)
X		     ((char *)this_tr_table
X		      - ((unsigned long)
X			 ((struct rx_superstate *)0)->transitions)));
X		  
X		  setp = search_state.super->contents;
X		  fprintf (stderr, "   superstet (rx=%d, &=%x: ",
X			   rxb->rx.rx_id, setp);
X		  while (setp)
X		    {
X		      fprintf (stderr, "%d ", setp->id);
X		      setp = setp->cdr;
X		    }
X		  fprintf (stderr, "\n");
X		}
#endif
X	      this_tr_table = next_tr_table;
X	      ++search_state.test_pos.pos;
X	      if (search_state.test_pos.pos == search_state.test_pos.end)
X		{
X		  int burst_state;
X		try_burst_1:
X		  burst_state = get_burst (&search_state.test_pos,
X					   app_closure, stop);
X		  switch (burst_state)
X		    {
X		    case rx_get_burst_continuation:
X		      search_state.saved_this_tr_table = this_tr_table;
X		      search_state.saved_next_tr_table = next_tr_table;
X		      test_pc = rx_test_cache_hit_loop;
X		      goto test_return_continuation;
X		      
X		    resume_continuation_1:
X		      /* Continuation one jumps here to do its work: */
X		      search_state.saved_this_tr_table = this_tr_table;
X		      search_state.saved_next_tr_table = next_tr_table;
X		      goto try_burst_1;
X		      
X		    case rx_get_burst_ok:
X		      /* get_burst succeeded...keep going */
X		      break;
X		      
X		    case rx_get_burst_no_more:
X		      search_state.test_ret = rx_test_line_finished;
X		      search_state.could_have_continued = 1;
X		      goto test_do_return;
X		      
X		    case rx_get_burst_error:
X		      /* An error... */
X		      search_state.test_ret = rx_test_internal_error;
X		      goto test_do_return;
X		    }
X		}
X	      search_state.c = *search_state.test_pos.pos;
X	      search_state.ifr = this_tr_table + search_state.c;
X	      next_tr_table = (struct rx_inx *)search_state.ifr->data;
X	    } /* Fast loop through cached transition tables */
X	  
X	  /* Here when we ran out of cached next-char transitions. 
X	   * So, it will be necessary to do a more expensive
X	   * dispatch on the current instruction.  The superstate
X	   * pointer is allowed to become invalid during next-char
X	   * transitions -- now we must bring it up to date.
X	   */
X	  search_state.super =
X	    ((struct rx_superstate *)
X	     ((char *)this_tr_table
X	      - ((unsigned long)
X		 ((struct rx_superstate *)0)->transitions)));
X	}
X	
X	/* We've encountered an instruction other than next-char.
X	 * Dispatch that instruction:
X	 */
X	inx = (int)search_state.ifr->inx;
#ifdef RX_DEBUG
X	if (rx_debug_trace)
X	  {
X	    struct rx_superset * setp = search_state.super->contents;
X	    
X	    fprintf (stderr, "%d %d>> %s @ %d (%d)", search_state.line_no,
X		     search_state.backtrack_depth,
X		     inx_names[inx],
X		     (search_state.test_pos.pos - search_state.test_pos.string
X		      + (test_pos.half == 0 ? 0 : size1)), search_state.c);
X	    
X	    fprintf (stderr, "   superstet (rx=%d, &=%x: ",
X		     rxb->rx.rx_id, setp);
X	    while (setp)
X	      {
X		fprintf (stderr, "%d ", setp->id);
X		setp = setp->cdr;
X	      }
X	    fprintf (stderr, "\n");
X	  }
#endif
X	switch ((enum rx_opcode)inx)
X	  {
X	  case rx_do_side_effects:
X	    
X	    /*  RX_DO_SIDE_EFFECTS occurs when we cross epsilon 
X	     *  edges associated with parentheses, backreferencing, etc.
X	     */
X	    {
X	      struct rx_distinct_future * df =
X		(struct rx_distinct_future *)search_state.ifr->data_2;
X	      struct rx_se_list * el = df->effects;
X	      /* Side effects come in lists.  This walks down
X	       * a list, dispatching.
X	       */
X	      while (el)
X		{
X		  long effect;
X		  effect = (long)el->car;
X		  if (effect < 0)
X		    {
#ifdef RX_DEBUG
X		      if (rx_debug_trace)
X			{
X			  struct rx_superset * setp = search_state.super->contents;
X			  
X			  fprintf (stderr, "....%d %d>> %s\n", search_state.line_no,
X				   search_state.backtrack_depth,
X				   efnames[-effect]);
X			}
#endif
X		      switch ((enum re_side_effects) effect)
X
X			{
X			case re_se_pushback:
X			  search_state.ifr = &df->future_frame;
X			  if (!search_state.ifr->data)
X			    {
X			      struct rx_superstate * sup;
X			      sup = search_state.super;
X			      rx_lock_superstate (rx, sup);
X			      if (!rx_handle_cache_miss (&rxb->rx,
X							 search_state.super,
X							 search_state.c,
X							 (search_state.ifr
X							  ->data_2)))
X				{
X				  rx_unlock_superstate (rx, sup);
X				  search_state.test_ret = rx_test_internal_error;
X				  goto test_do_return;
X				}
X			      rx_unlock_superstate (rx, sup);
X			    }
X			  /* --search_state.test_pos.pos; */
X			  search_state.c = 't';
X			  search_state.super
X			    = ((struct rx_superstate *)
X			       ((char *)search_state.ifr->data
X				- (long)(((struct rx_superstate *)0)
X					 ->transitions)));
X			  goto top_of_cycle;
X			  break;
X			case re_se_push0:
X			  {
X			    struct rx_counter_frame * old_cf
X			      = (search_state.counter_stack
X				 ? ((struct rx_counter_frame *)
X				    search_state.counter_stack->sp)
X				 : 0);
X			    struct rx_counter_frame * cf;
X			    PUSH (search_state.counter_stack,
X				  sizeof (struct rx_counter_frame));
X			    cf = ((struct rx_counter_frame *)
X				  search_state.counter_stack->sp);
X			    cf->tag = re_se_iter;
X			    cf->val = 0;
X			    cf->inherited_from = 0;
X			    cf->cdr = old_cf;
X			    break;
X			  }
X			case re_se_fail:
X			  goto test_do_return;
X			case re_se_begbuf:
X			  if (!AT_STRINGS_BEG ())
X			    goto test_do_return;
X			  break;
X			case re_se_endbuf:
X			  if (!AT_STRINGS_END ())
X			    goto test_do_return;
X			  break;
X			case re_se_wordbeg:
X			  if (   LETTER_P (&search_state.test_pos, 1)
X			      && (   AT_STRINGS_BEG()
X				  || !LETTER_P (&search_state.test_pos, 0)))
X			    break;
X			  else
X			    goto test_do_return;
X			case re_se_wordend:
X			  if (   !AT_STRINGS_BEG ()
X			      && LETTER_P (&search_state.test_pos, 0)
X			      && (AT_STRINGS_END ()
X				  || !LETTER_P (&search_state.test_pos, 1)))
X			    break;
X			  else
X			    goto test_do_return;
X			case re_se_wordbound:
X			  if (AT_WORD_BOUNDARY (&search_state.test_pos))
X			    break;
X			  else
X			    goto test_do_return;
X			case re_se_notwordbound:
X			  if (!AT_WORD_BOUNDARY (&search_state.test_pos))
X			    break;
X			  else
X			    goto test_do_return;
X			case re_se_hat:
X			  if (AT_STRINGS_BEG ())
X			    {
X			      if (rxb->not_bol)
X				goto test_do_return;
X			      else
X				break;
X			    }
X			  else
X			    {
X			      char pos_c = *search_state.test_pos.pos;
X			      if (   (SRCH_TRANSLATE (pos_c)
X				      == SRCH_TRANSLATE('\n'))
X				  && rxb->newline_anchor)
X				break;
X			      else
X				goto test_do_return;
X			    }
X			case re_se_dollar:
X			  if (AT_STRINGS_END ())
X			    {
X			      if (rxb->not_eol)
X				goto test_do_return;
X			      else
X				break;
X			    }
X			  else
X			    {
X			      if (   (   SRCH_TRANSLATE (fetch_char
X						    (&search_state.test_pos, 1,
X						     app_closure, stop))
X				      == SRCH_TRANSLATE ('\n'))
X				  && rxb->newline_anchor)
X				break;
X			      else
X				goto test_do_return;
X			    }
X			  
X			case re_se_try:
X			  /* This is the first side effect in every
X			   * expression.
X			   *
X			   *  FOR NO GOOD REASON...get rid of it...
X			   */
X			  break;
X			  
X			case re_se_pushpos:
X			  {
X			    int urhere =
X			      ((int)(search_state.test_pos.pos
X				     - search_state.test_pos.string)
X			       + search_state.test_pos.offset);
X			    struct rx_counter_frame * old_cf
X			      = (search_state.counter_stack
X				 ? ((struct rx_counter_frame *)
X				    search_state.counter_stack->sp)
X				 : 0);
X			    struct rx_counter_frame * cf;
X			    PUSH(search_state.counter_stack,
X				 sizeof (struct rx_counter_frame));
X			    cf = ((struct rx_counter_frame *)
X				  search_state.counter_stack->sp);
X			    cf->tag = re_se_pushpos;
X			    cf->val = urhere;
X			    cf->inherited_from = 0;
X			    cf->cdr = old_cf;
X			    break;
X			  }
X			  
X			case re_se_chkpos:
X			  {
X			    int urhere =
X			      ((int)(search_state.test_pos.pos
X				     - search_state.test_pos.string)
X			       + search_state.test_pos.offset);
X			    struct rx_counter_frame * cf
X			      = ((struct rx_counter_frame *)
X				 search_state.counter_stack->sp);
X			    if (cf->val == urhere)
X			      goto test_do_return;
X			    cf->val = urhere;
X			    break;
X			  }
X			  break;
X			  
X			case re_se_poppos:
X			  POP(search_state.counter_stack,
X			      sizeof (struct rx_counter_frame));
X			  break;
X			  
X			  
X			case re_se_at_dot:
X			case re_se_syntax:
X			case re_se_not_syntax:
#ifdef emacs
X			  this release lacks emacs support;
X			  (coming soon);
#endif
X			  break;
X			case re_se_win:
X			case re_se_lparen:
X			case re_se_rparen:
X			case re_se_backref:
X			case re_se_iter:
X			case re_se_end_iter:
X			case re_se_tv:
X			case re_floogle_flap:
X			  search_state.ret_val = 0;
X			  goto test_do_return;
X			}
X		    }
X		  else
X		    {
#ifdef RX_DEBUG
X		      if (rx_debug_trace)
X			fprintf (stderr, "....%d %d>> %s %d %d\n", search_state.line_no,
X				 search_state.backtrack_depth,
X				 efnames2[rxb->se_params [effect].se],
X				 rxb->se_params [effect].op1,
X				 rxb->se_params [effect].op2);
#endif
X		      switch (rxb->se_params [effect].se)
X			{
X			case re_se_win:
X			  /* This side effect indicates that we've 
X			   * found a match, though not necessarily the 
X			   * best match.  This is a fancy assignment to 
X			   * register 0 unless the caller didn't 
X			   * care about registers.  In which case,
X			   * this stops the match.
X			   */
X			  {
X			    int urhere =
X			      ((int)(search_state.test_pos.pos
X				     - search_state.test_pos.string)
X			       + search_state.test_pos.offset);
X			    
X			    if (   (search_state.best_last_r < 0)
X				|| (urhere + 1 > search_state.best_rparen[0]))
X			      {
X				/* Record the best known and keep
X				 * looking.
X				 */
X				int x;
X				for (x = 0; x <= search_state.last_l; ++x)
X				  search_state.best_lparen[x] = search_state.lparen[x];
X				search_state.best_last_l = search_state.last_l;
X				for (x = 0; x <= search_state.last_r; ++x)
X				  search_state.best_rparen[x] = search_state.rparen[x];
X				search_state.best_rparen[0] = urhere + 1;
X				search_state.best_last_r = search_state.last_r;
X			      }
X			    /* If we're not reporting the match-length 
X			     * or other register info, we need look no
X			     * further.
X			     */
X			    if (search_state.first_found)
X			      {
X				search_state.test_ret = rx_test_found_first;
X				goto test_do_return;
X			      }
X			  }
X			  break;
X			case re_se_lparen:
X			  {
X			    int urhere =
X			      ((int)(search_state.test_pos.pos
X				     - search_state.test_pos.string)
X			       + search_state.test_pos.offset);
X			    
X			    int reg = rxb->se_params [effect].op1;
#if 0
X			    if (reg > search_state.last_l)
#endif
X			      {
X				search_state.lparen[reg] = urhere + 1;
X				/* In addition to making this assignment,
X				 * we now know that lower numbered regs
X				 * that haven't already been assigned,
X				 * won't be.  We make sure they're
X				 * filled with -1, so they can be
X				 * recognized as unassigned.
X				 */
X				if (search_state.last_l < reg)
X				  while (++search_state.last_l < reg)
X				    search_state.lparen[search_state.last_l] = -1;
X			      }
X			    break;
X			  }
X			  
X			case re_se_rparen:
X			  {
X			    int urhere =
X			      ((int)(search_state.test_pos.pos
X				     - search_state.test_pos.string)
X			       + search_state.test_pos.offset);
X			    int reg = rxb->se_params [effect].op1;
X			    search_state.rparen[reg] = urhere + 1;
X			    if (search_state.last_r < reg)
X			      {
X				while (++search_state.last_r < reg)
X				  search_state.rparen[search_state.last_r]
X				    = -1;
X			      }
X			    break;
X			  }
X			  
X			case re_se_backref:
X			  {
X			    int reg = rxb->se_params [effect].op1;
X			    if (   reg > search_state.last_r
X				|| search_state.rparen[reg] < 0)
X			      goto test_do_return;
X			    
X			    {
X			      int backref_status;
X			    check_backreference:
X			      backref_status
X				= back_check (&search_state.test_pos,
X					      search_state.lparen[reg],
X					      search_state.rparen[reg],
X					      search_state.translate,
X					      app_closure,
X					      stop);
X			      switch (backref_status)
X				{
X				case rx_back_check_continuation:
X				  search_state.saved_reg = reg;
X				  test_pc = rx_test_backreference_check;
X				  goto test_return_continuation;
X				resume_continuation_2:
X				  reg = search_state.saved_reg;
X				  goto check_backreference;
X				case rx_back_check_fail:
X				  /* Fail */
X				  goto test_do_return;
X				case rx_back_check_pass:
X				  /* pass --
X				   * test_pos now advanced to last
X				   * char matched by backref
X				   */
X				  break;
X				}
X			    }
X			    break;
X			  }
X			case re_se_iter:
X			  {
X			    struct rx_counter_frame * csp
X			      = ((struct rx_counter_frame *)
X				 search_state.counter_stack->sp);
X			    if (csp->val == rxb->se_params[effect].op2)
X			      goto test_do_return;
X			    else
X			      ++csp->val;
X			    break;
X			  }
X			case re_se_end_iter:
X			  {
X			    struct rx_counter_frame * csp
X			      = ((struct rx_counter_frame *)
X				 search_state.counter_stack->sp);
X			    if (csp->val < rxb->se_params[effect].op1)
X			      goto test_do_return;
X			    else
X			      {
X				struct rx_counter_frame * source = csp;
X				while (source->inherited_from)
X				  source = source->inherited_from;
X				if (!source || !source->cdr)
X				  {
X				    POP(search_state.counter_stack,
X					sizeof(struct rx_counter_frame));
X				  }
X				else
X				  {
X				    source = source->cdr;
X				    csp->val = source->val;
X				    csp->tag = source->tag;
X				    csp->cdr = 0;
X				    csp->inherited_from = source;
X				  }
X			      }
X			    break;
X			  }
X			case re_se_tv:
X			  /* is a noop */
X			  break;
X			case re_se_try:
X			case re_se_pushback:
X			case re_se_push0:
X			case re_se_pushpos:
X			case re_se_chkpos:
X			case re_se_poppos:
X			case re_se_at_dot:
X			case re_se_syntax:
X			case re_se_not_syntax:
X			case re_se_begbuf:
X			case re_se_hat:
X			case re_se_wordbeg:
X			case re_se_wordbound:
X			case re_se_notwordbound:
X			case re_se_wordend:
X			case re_se_endbuf:
X			case re_se_dollar:
X			case re_se_fail:
X			case re_floogle_flap:
X			  search_state.ret_val = 0;
X			  goto test_do_return;
X			}
X		    }
X		  el = el->cdr;
X		}
X	      /* Now the side effects are done,
X	       * so get the next instruction.
X	       * and move on.
X	       */
X	      search_state.ifr = &df->future_frame;
X	      goto restart;
X	    }
X	    
X	  case rx_backtrack_point:
X	    {
X	      /* A backtrack point indicates that we've reached a
X	       * non-determinism in the superstate NFA.  This is a
X	       * loop that exhaustively searches the possibilities.
X	       *
X	       * A backtracking strategy is used.  We keep track of what
X	       * registers are valid so we can erase side effects.
X	       *
X	       * First, make sure there is some stack space to hold 
X	       * our state.
X	       */
X	      
X	      struct rx_backtrack_frame * bf;
X	      
X	      PUSH(search_state.backtrack_stack,
X		   search_state.backtrack_frame_bytes);
#ifdef RX_DEBUG
X	      ++search_state.backtrack_depth;
#endif
X	      
X	      bf = ((struct rx_backtrack_frame *)
X		    search_state.backtrack_stack->sp);
X	      {
X		bf->stk_super = search_state.super;
X		/* We prevent the current superstate from being
X		 * deleted from the superstate cache.
X		 */
X		rx_lock_superstate (&rxb->rx, search_state.super);
#ifdef RX_DEBUG
X		bf->stk_search_state.line_no = search_state.line_no;
#endif
X		bf->stk_c = search_state.c;
X		bf->stk_test_pos = search_state.test_pos;
X		bf->stk_last_l = search_state.last_l;
X		bf->stk_last_r = search_state.last_r;
X		bf->df = ((struct rx_super_edge *)
X			  search_state.ifr->data_2)->options;
X		bf->first_df = bf->df;
X		bf->counter_stack_sp = (search_state.counter_stack
X					? search_state.counter_stack->sp
X					: 0);
X		bf->stk_test_ret = search_state.test_ret;
X		if (rxb->match_regs_on_stack)
X		  {
X		    int x;
X		    regoff_t * stk =
X		      (regoff_t *)((char *)bf + sizeof (*bf));
X		    for (x = 0; x <= search_state.last_l; ++x)
X		      stk[x] = search_state.lparen[x];
X		    stk += x;
X		    for (x = 0; x <= search_state.last_r; ++x)
X		      stk[x] = search_state.rparen[x];
X		  }
X	      }
X	      
X	      /* Here is a while loop whose body is mainly a function
X	       * call and some code to handle a return from that
X	       * function.
X	       *
X	       * From here on for the rest of `case backtrack_point' it
X	       * is unsafe to assume that the search_state copies of 
X	       * variables saved on the backtracking stack are valid
X	       * -- so read their values from the backtracking stack.
X	       *
X	       * This lets us use one generation fewer stack saves in
X	       * the call-graph of a search.
X	       */
X	      
X	    while_non_det_options:
#ifdef RX_DEBUG
X	      ++search_state.lines_found;
X	      if (rx_debug_trace)
X		fprintf (stderr, "@@@ %d calls %d @@@\n",
X			 search_state.line_no, search_state.lines_found);
X	      
X	      search_state.line_no = search_state.lines_found;
#endif
X	      
X	      if (bf->df->next_same_super_edge[0] == bf->first_df)
X		{
X		  /* This is a tail-call optimization -- we don't recurse
X		   * for the last of the possible futures.
X		   */
X		  search_state.ifr = (bf->df->effects
X				      ? &bf->df->side_effects_frame
X				      : &bf->df->future_frame);
X		  
X		  rx_unlock_superstate (&rxb->rx, search_state.super);
X		  POP(search_state.backtrack_stack,
X		      search_state.backtrack_frame_bytes);
#ifdef RX_DEBUG
X		  --search_state.backtrack_depth;
#endif
X		  goto restart;
X		}
X	      else
X		{
X		  if (search_state.counter_stack)
X		    {
X		      struct rx_counter_frame * old_cf
X			= ((struct rx_counter_frame *)search_state.counter_stack->sp);
X		      struct rx_counter_frame * cf;
X		      PUSH(search_state.counter_stack, sizeof (struct rx_counter_frame));
X		      cf = ((struct rx_counter_frame *)search_state.counter_stack->sp);
X		      cf->tag = old_cf->tag;
X		      cf->val = old_cf->val;
X		      cf->inherited_from = old_cf;
X		      cf->cdr = 0;
X		    }			
X		  /* `Call' this test-match block */
X		  search_state.ifr = (bf->df->effects
X				      ? &bf->df->side_effects_frame
X				      : &bf->df->future_frame);
X		  goto recurse_test_match;
X		}
X	      
X	      /* Returns in this block are accomplished by
X	       * goto test_do_return.  There are two cases.
X	       * If there is some search-stack left,
X	       * then it is a return from a `recursive' call.
X	       * If there is no search-stack left, then
X	       * we should return to the fastmap/search loop.
X	       */
X	      
X	    test_do_return:
X	      
X	      if (!search_state.backtrack_stack)
X		{
#ifdef RX_DEBUG
X		  if (rx_debug_trace)
X		    fprintf (stderr, "!!! %d bails returning %d !!!\n",
X			     search_state.line_no, search_state.test_ret);
#endif
X		  
X		  /* No more search-stack -- this test is done. */
X		  if (search_state.test_ret)
X		    goto return_from_test_match;
X		  else
X		    goto error_in_testing_match;
X		}
X	      
X	      /* Returning from a recursive call to 
X	       * the test match block:
X	       */
X	      
X	      bf = ((struct rx_backtrack_frame *)
X		    search_state.backtrack_stack->sp);
#ifdef RX_DEBUG
X	      if (rx_debug_trace)
X		fprintf (stderr, "+++ %d returns %d (to %d)+++\n",
X			 search_state.line_no,
X			 search_state.test_ret,
X			 bf->stk_search_state.line_no);
#endif
X	      
X	      while (search_state.counter_stack
X		     && (!bf->counter_stack_sp
X			 || (bf->counter_stack_sp
X			     != search_state.counter_stack->sp)))
X		{
X		  POP(search_state.counter_stack,
X		      sizeof (struct rx_counter_frame));
X		}
X	      
X	      if (search_state.test_ret == rx_test_error)
X		{
X		  POP (search_state.backtrack_stack,
X		       search_state.backtrack_frame_bytes);
X		  goto test_do_return;
X		}
X	      
X	      /* If a non-longest match was found and that is good 
X	       * enough, return immediately.
X	       */
X	      if (   (search_state.test_ret == rx_test_found_first)
X		  && search_state.first_found)
X		{
X		  rx_unlock_superstate (&rxb->rx, bf->stk_super);
X		  POP (search_state.backtrack_stack,
X		       search_state.backtrack_frame_bytes);
X		  goto test_do_return;
X		}
X	      
X	      search_state.test_ret = bf->stk_test_ret;
X	      search_state.last_l = bf->stk_last_l;
X	      search_state.last_r = bf->stk_last_r;
X	      bf->df = bf->df->next_same_super_edge[0];
X	      search_state.super = bf->stk_super;
X	      search_state.c = bf->stk_c;
#ifdef RX_DEBUG
X	      search_state.line_no = bf->stk_search_state.line_no;
#endif
X	      
X	      if (rxb->match_regs_on_stack)
X		{
X		  int x;
X		  regoff_t * stk =
X		    (regoff_t *)((char *)bf + sizeof (*bf));
X		  for (x = 0; x <= search_state.last_l; ++x)
X		    search_state.lparen[x] = stk[x];
X		  stk += x;
X		  for (x = 0; x <= search_state.last_r; ++x)
X		    search_state.rparen[x] = stk[x];
X		}
X	      
X	      {
X		int x;
X	      try_burst_2:
X		x = get_burst (&bf->stk_test_pos, app_closure, stop);
X		switch (x)
X		  {
X		  case rx_get_burst_continuation:
X		    search_state.saved_bf = bf;
X		    test_pc = rx_test_backtrack_return;
X		    goto test_return_continuation;
X		  resume_continuation_3:
X		    bf = search_state.saved_bf;
X		    goto try_burst_2;
X		  case rx_get_burst_no_more:
X		    /* Since we've been here before, it is some kind of
X		     * error that we can't return.
X		     */
X		  case rx_get_burst_error:
X		    search_state.test_ret = rx_test_internal_error;
X		    goto test_do_return;
X		  case rx_get_burst_ok:
X		    break;
X		  }
X	      }
X	      search_state.test_pos = bf->stk_test_pos;
X	      goto while_non_det_options;
X	    }
X	    
X	    
X	  case rx_cache_miss:
X	    /* Because the superstate NFA is lazily constructed,
X	     * and in fact may erode from underneath us, we sometimes
X	     * have to construct the next instruction from the hard way.
X	     * This invokes one step in the lazy-conversion.
X	     */
X	    search_state.ifr = rx_handle_cache_miss (&rxb->rx,
X						     search_state.super,
X						     search_state.c,
X						     search_state.ifr->data_2);
X	    if (!search_state.ifr)
X	      {
X		search_state.test_ret = rx_test_internal_error;
X		goto test_do_return;
X	      }
X	    goto restart;
X	    
X	  case rx_backtrack:
X	    /* RX_BACKTRACK means that we've reached the empty
X	     * superstate, indicating that match can't succeed
X	     * from this point.
X	     */
X	    goto test_do_return;
X	    
X	  case rx_next_char:
X	  case rx_error_inx:
X	  case rx_num_instructions:
X	    search_state.ret_val = 0;
X	    goto test_do_return;
X	  }
X	goto pseudo_while_1;
X      }
X    
X    /* Healthy exits from the test-match loop do a 
X     * `goto return_from_test_match'   On the other hand, 
X     * we might end up here.
X     */
X  error_in_testing_match:
X    test_state = rx_test_error;
X    goto test_returns_to_search;
X    
X    /***** fastmap/search loop body
X     *	      considering the results testing for a match
X     */
X    
X  return_from_test_match:
X    
X    if (search_state.best_last_l >= 0)
X      {
X	if (regs && (regs->start != search_state.best_lparen))
X	  {
X	    bcopy (search_state.best_lparen, regs->start,
X		   regs->num_regs * sizeof (int));
X	    bcopy (search_state.best_rparen, regs->end,
X		   regs->num_regs * sizeof (int));
X	  }
X	if (regs && !rxb->no_sub)
X	  {
X	    int q;
X	    int bound = (regs->num_regs > search_state.num_regs
X			 ? regs->num_regs
X			 : search_state.num_regs);
X	    regoff_t * s = regs->start;
X	    regoff_t * e = regs->end;
X	    for (q = search_state.best_last_l + 1;  q < bound; ++q)
X	      s[q] = e[q] = -1;
X	  }
X	search_state.ret_val = search_state.best_lparen[0];
X	test_state = rx_test_ok;
X	goto test_returns_to_search;
X      }
X    else
X      {
X	test_state = rx_test_fail;
X	goto test_returns_to_search;
X      }
X    
X  test_return_continuation:
X    search_state.test_match_resume_pt = test_pc;
X    test_state = rx_test_continuation;
X    goto test_returns_to_search;
X  }
}
X
X
X
#endif /* RX_WANT_RX_DEFS */
X
X
X
#else /* RX_WANT_SE_DEFS */
X  /* Integers are used to represent side effects.
X   *
X   * Simple side effects are given negative integer names by these enums.
X   * 
X   * Non-negative names are reserved for complex effects.
X   *
X   * Complex effects are those that take arguments.  For example, 
X   * a register assignment associated with a group is complex because
X   * it requires an argument to tell which group is being matched.
X   * 
X   * The integer name of a complex effect is an index into rxb->se_params.
X   */
X 
X  RX_DEF_SE(1, re_se_try, = -1)		/* Epsilon from start state */
X
X  RX_DEF_SE(0, re_se_pushback, = re_se_try - 1)
X  RX_DEF_SE(0, re_se_push0, = re_se_pushback -1)
X  RX_DEF_SE(0, re_se_pushpos, = re_se_push0 - 1)
X  RX_DEF_SE(0, re_se_chkpos, = re_se_pushpos -1)
X  RX_DEF_SE(0, re_se_poppos, = re_se_chkpos - 1)
X
X  RX_DEF_SE(1, re_se_at_dot, = re_se_poppos - 1)	/* Emacs only */
X  RX_DEF_SE(0, re_se_syntax, = re_se_at_dot - 1) /* Emacs only */
X  RX_DEF_SE(0, re_se_not_syntax, = re_se_syntax - 1) /* Emacs only */
X
X  RX_DEF_SE(1, re_se_begbuf, = re_se_not_syntax - 1) /* match beginning of buffer */
X  RX_DEF_SE(1, re_se_hat, = re_se_begbuf - 1) /* match beginning of line */
X
X  RX_DEF_SE(1, re_se_wordbeg, = re_se_hat - 1) 
X  RX_DEF_SE(1, re_se_wordbound, = re_se_wordbeg - 1)
X  RX_DEF_SE(1, re_se_notwordbound, = re_se_wordbound - 1)
X
X  RX_DEF_SE(1, re_se_wordend, = re_se_notwordbound - 1)
X  RX_DEF_SE(1, re_se_endbuf, = re_se_wordend - 1)
X
X  /* This fails except at the end of a line. 
X   * It deserves to go here since it is typicly one of the last steps 
X   * in a match.
X   */
X  RX_DEF_SE(1, re_se_dollar, = re_se_endbuf - 1)
X
X  /* Simple effects: */
X  RX_DEF_SE(1, re_se_fail, = re_se_dollar - 1)
X
X  /* Complex effects.  These are used in the 'se' field of 
X   * a struct re_se_params.  Indexes into the se array
X   * are stored as instructions on nfa edges.
X   */
X  RX_DEF_CPLX_SE(1, re_se_win, = 0)
X  RX_DEF_CPLX_SE(1, re_se_lparen, = re_se_win + 1)
X  RX_DEF_CPLX_SE(1, re_se_rparen, = re_se_lparen + 1)
X  RX_DEF_CPLX_SE(0, re_se_backref, = re_se_rparen + 1)
X  RX_DEF_CPLX_SE(0, re_se_iter, = re_se_backref + 1) 
X  RX_DEF_CPLX_SE(0, re_se_end_iter, = re_se_iter + 1)
X  RX_DEF_CPLX_SE(0, re_se_tv, = re_se_end_iter + 1)
X
#endif
X
#if RX_WANT_SE_DEFS != 1
__END_DECLS
#endif
X
#endif
SHAR_EOF
chmod 0644 gccinc/rx.h ||
echo 'restore of gccinc/rx.h failed'
Wc_c="`wc -c < 'gccinc/rx.h'`"
test 97336 -eq "$Wc_c" ||
	echo 'gccinc/rx.h: original size 97336, current size' "$Wc_c"
fi
true || echo 'restore of gccinc/sys/cdefs.h failed'
echo End of part 4, continue with part 5
exit 0
