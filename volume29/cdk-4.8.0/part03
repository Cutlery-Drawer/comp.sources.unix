Newsgroups: comp.sources.unix
From: glover@credit.erin.utoronto.ca (Mike Glover)
Subject: v29i098: cdk-4.8.0 - Curses Development Kit, V4.8.0, Part03/06
References: <1.839541522.22466@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: glover@credit.erin.utoronto.ca (Mike Glover)
Posting-Number: Volume 29, Issue 98
Archive-Name: cdk-4.8.0/part03

#!/bin/sh
# This is `cdk_.03' (part 3 of a multipart archive).
# Do not concatenate these parts, unpack them in order with `/bin/sh'.
# File `cdk4.8.0/man/slider.3' is being continued...
#
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  echo 'WARNING: not restoring timestamps.  Consider getting and'
  echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if test ! -r _sharseq.tmp; then
  echo 'Please unpack part 1 first!'
  exit 1
fi
shar_sequence=`cat _sharseq.tmp`
if test "$shar_sequence" != 3; then
  echo "Please unpack part $shar_sequence next!"
  exit 1
fi
if test ! -f _sharnew.tmp; then
  echo 'x - still skipping cdk4.8.0/man/slider.3'
else
  echo 'x - continuing file cdk4.8.0/man/slider.3'
  sed 's/^X//' << 'SHAR_EOF' >> '_sharuue.tmp' &&
M='5R92!M96UB97(@7&8T97AI=%1Y<&5<9C$@=VEL;"!B92!S970@=&\@7&8T
M=D530T%015](251<9C$N($%N>2!O=&AE<@IC:&%R86-T97(@:6YJ96-T960@
M:6YT;R!T:&4@=VED9V5T('=I;&P@<V5T('1H92!S=')U8W1U<F4@;65M8F5R
M"EQF-&5X:714>7!E7&8Q('1O(%QF-'9%05),65]%6$E47&8Q(&%N9"!T:&4@
M9G5N8W1I;VX@=VEL;"!R971U<FX@+3$N"BY210H*=F]I9"!S971#1$M3;&ED
M97(@*$-$2U-,241%4B`J7&8R<VQI9&5R7&8Q+"!I;G0@7&8R=F%L=65<9C$L
M(&EN="!<9C)M:6YI;75M3&5N9W1H7&8Q+"!I;G0@7&8R;6%X:6UU;4QE;F=T
M:%QF,2P@8F]O;&5A;B!<9C)B;WA<9C$I.PHN4E,@,PI4:&ES(&9U;F-T:6]N
M(&QE=',@=&AE('!R;V=R86UM97(@;6]D:69Y(&-E<G1A:6X@96QE;65N=',@
M;V8@86X@86QR96%D>2`*9&5F:6YE9"!S;&ED97(@=VED9V5T+B!4:&4@<&%R
M86UE=&5R(&YA;65S(&-O<G)E<W!O;F0@=&\@=&AE('-A;64@<&%R86UE=&5R
M(`IN86UE<R!L:7-T960@:6X@=&AE(%QF-&YE=T-$2U-L:61E<EQF,2!F=6YC
M=&EO;BX*+E)%"@IV;VED(&1R87=#1$M3;&ED97(@*$-$2U-,241%4B`J7&8R
M<VQI9&5R7&8Q+"!B;V]L96%N(%QF,F)O>%QF,2D["BY24R`S"E1H:7,@9G5N
M8W1I;VX@9')A=W,@=&AE('-L:61E<B!W:61G970@;VX@=&AE('-C<F5E;BX@
M5&AE(%QF,F)O>%QF,2!O<'1I;VX@"F1R87=S('1H92!W:61G970@=VET:"!O
M<B!W:71H;W5T(&$@8F]X+@HN4D4*"G9O:60@97)A<V5#1$M3;&ED97(@*$-$
M2U-,241%4B`J7&8R<VQI9&5R7&8Q*3L*+E)3(#,*5&AI<R!F=6YC=&EO;B!R
M96UO=F5S('1H92!W:61G970@9G)O;2!T:&4@<V-R965N+B!4:&ES(&1O97,@
M7&8T3D]47&8Q(&1E<W1R;WD*=&AE('=I9&=E="X*+E)%"@IV;VED(&1E<W1R
M;WE#1$M3;&ED97(@*$-$2U-,241%4B`J7&8R<VQI9&5R7&8Q*3L*+E)3(#,*
M5&AI<R!F=6YC=&EO;B!R96UO=F5S('1H92!W:61G970@9G)O;2!T:&4@<V-R
M965N(&%N9"!F<F5E<R!U<"!A;GD@;65M;W)Y('1H90IO8FIE8W0@;6%Y(&)E
M('5S:6YG+@HN4D4*"G9O:60@<V5T0T1+4VQI9&5R4')E4')O8V5S<R`H0T1+
M4TQ)1$52("I<9C)S;&ED97)<9C$L(%!23T-%4U-&3B!<9C)F=6YC=&EO;EQF
M,2P@=F]I9"`J7&8R9&%T85QF,2D["BY24R`S"E1H:7,@9G5N8W1I;VX@86QL
M;W=S('1H92!U<V5R('1O(&AA=F4@=&AE('=I9&=E="!C86QL(&$@9G5N8W1I
M;VX@869T97(@82!K97D*:7,@:&ET(&%N9"!B969O<F4@=&AE(&ME>2!I<R!A
M<'!L:65D('1O('1H92!W:61G970N(%1H92!P87)A;65T97(@7&8R9G5N8W1I
M;VY<9C$*:68@;V8@='EP92!<9C104D]#15-31DY<9C$N(%1H92!P87)A;65T
M97(@7&8R9&%T85QF,2!I<R!A('!O:6YT97(@=&\@"EQF-'9O:61<9C$N(%1O
M(&QE87)N(&UO<F4@86)O=70@<')E+7!R;V-E<W-I;F<@<F5A9"!T:&4@7&8T
M8V1K7W!R;V-E<W-<9C$*;6%N=6%L('!A9V4N"BY210H@"G9O:60@<V5T0T1+
M4VQI9&5R4&]S=%!R;V-E<W,@*$-$2U-,241%4B`J7&8R<VQI9&5R7&8Q+"!0
M4D]#15-31DX@7&8R9G5N8W1I;VY<9C$L('9O:60@*EQF,F1A=&%<9C$I.PHN
M4E,@,PI4:&ES(&9U;F-T:6]N(&%L;&]W<R!T:&4@=7-E<B!T;R!H879E('1H
M92!W:61G970@8V%L;"!A(&9U;F-T:6]N(&%F=&5R('1H90IK97D@:&%S(&)E
M96X@87!P;&EE9"!T;R!T:&4@=VED9V5T+B`@5&AE('!A<F%M971E<B!<9C)F
M=6YC=&EO;EQF,2!I9B!O9B!T>7!E"EQF-%!23T-%4U-&3EQF,2X@5&AE('!A
M<F%M971E<B!<9C)D871A7&8Q(&ES(&$@<&]I;G1E<B!T;R!<9C1V;VED7&8Q
M+B!4;PIL96%R;B!M;W)E(&%B;W5T('!O<W0M<')O8V5S<VEN9R!R96%D('1H
M92!<9C1C9&M?<')O8V5S<UQF,2!M86YU86P@<&%G92X*+E)%"@IV;VED(&)I
M;F1#1$M/8FIE8W0@*$5/8FIE8W14>7!E(%QF,G=I9&=E=%1Y<&5<9C$L('9O
M:60@*EQF,F]B:F5C=%QF,2P@8VAA<B!<9C)K97E<9C$L($))3D1&3B!<9C)F
M=6YC=&EO;EQF,2P@=F]I9"`J7&8R9&%T85QF,2D["BY24R`S"E1H:7,@9G5N
M8W1I;VX@86QL;W=S('1H92!U<V5R('1O(&-R96%T92!S<&5C:6%L(&ME>2!B
M:6YD:6YG<RX@5&AE(`I<9C)W:61G9714>7!E7&8Q('!A<F%M971E<B!I<R!A
M(&1E9FEN960@='EP92!W:&EC:"!S=&%T97,@=VAA="!#9&L@;V)J96-T(`IT
M>7!E(&ES(&)E:6YG('5S960N("!4;R!L96%R;B!M;W)E(&%B;W5T('1H92!T
M>7!E(%QF-$5/8FIE8W14>7!E7&8Q(')E860@"G1H92!<9C)C9&M?8FEN9&EN
M9UQF,2!M86YU86P@<&%G92X@5&AE(%QF,F]B:F5C=%QF,2!P87)A;65T97(@
M:7,@=&AE('!O:6YT97(*=&\@=&AE('=I9&=E="!O8FIE8W0N(%1H92!<9C)K
M97E<9C$@:7,@=&AE(&-H87)A8W1E<B!T;R!B:6YD+B!4:&4@"EQF,F9U;F-T
M:6]N7&8Q(&ES('1H92!F=6YC=&EO;B!T>7!E+B!4;R!L96%R;B!M;W)E(&%B
M;W5T('1H92!K97D@8FEN9&EN9R`*8V%L;&)A8VL@9G5N8W1I;VX@='EP97,@
M<F5A9"!T:&4@7&8T8V1K7V)I;F1I;F=<9C$@;6%N=6%L('!A9V4N(%1H92!L
M87-T(`IP87)A;65T97(@7&8R9&%T85QF,2!I<R!A('!O:6YT97(@=&\@86YY
M(&1A=&$@=&AA="!N965D<R!T;R!G970@<&%S<V5D('1O(`IT:&4@8V%L;&)A
M8VL@9G5N8W1I;VXN"BY210H*+E-(($M%62!"24Y$24Y'4PI7:&5N('1H92!W
M:61G970@:7,@86-T:79A=&5D('1H97)E(&%R92!S979E<F%L(&1E9F%U;'0@
M:V5Y(&)I;F1I;F=S('=H:6-H('=I;&P*:&5L<"!T:&4@=7-E<B!E;G1E<B!O
M<B!M86YI<'5L871E('1H92!I;F9O<FUA=&EO;B!Q=6EC:VQY+B!4:&4@9F]L
M;&]W:6YG('1A8FQE"F]U=&QI;F5S('1H92!K97ES(&%N9"!T:&5I<B!A8W1I
M;VYS(&9O<B!T:&ES('=I9&=E="X*+DQ0"BYN9@HN4E,@,PI<9C)+97D@("`@
M("`@("!!8W1I;VY<9C$*3&5F="!!<G)O=R`@1&5C<F5M96YT<R!T:&4@=F%L
M=64@:6X@=&AE(&9I96QD"B`@("`@("`@("`@(&)Y('1H92!N;W)M86P@9&5C
M<F5M96YT('9A;'5E+@I$;W=N($%R<F]W("!$96-R96UE;G1S('1H92!V86QU
M92!I;B!T:&4@9FEE;&0*("`@("`@("`@("`@8GD@=&AE(&YO<FUA;"!D96-R
M96UE;G0@=F%L=64N"F0@("`@("`@("`@($1E8W)E;65N=',@=&AE('9A;'5E
M(&EN('1H92!F:65L9`H@("`@("`@("`@("!B>2!T:&4@;F]R;6%L(&1E8W)E
M;65N="!V86QU92X*+2`@("`@("`@("`@1&5C<F5M96YT<R!T:&4@=F%L=64@
M:6X@=&AE(&9I96QD"B`@("`@("`@("`@(&)Y('1H92!N;W)M86P@9&5C<F5M
M96YT('9A;'5E+@I2:6=H="!!<G)O=R!);F-R96UE;G1S('1H92!V86QU92!I
M;B!T:&4@9FEE;&0*("`@("`@("`@("`@8GD@=&AE(&YO<FUA;"!I;F-R96UE
M;G0@=F%L=64N"E5P($%R<F]W("`@($EN8W)E;65N=',@=&AE('9A;'5E(&EN
M('1H92!F:65L9`H@("`@("`@("`@("!B>2!T:&4@;F]R;6%L(&EN8W)E;65N
M="!V86QU92X*=2`@("`@("`@("`@26YC<F5M96YT<R!T:&4@=F%L=64@:6X@
M=&AE(&9I96QD"B`@("`@("`@("`@(&)Y('1H92!N;W)M86P@:6YC<F5M96YT
M('9A;'5E+@HK("`@("`@("`@("!);F-R96UE;G1S('1H92!V86QU92!I;B!T
M:&4@9FEE;&0*("`@("`@("`@("`@8GD@=&AE(&YO<FUA;"!I;F-R96UE;G0@
M=F%L=64N"E!R978@4&%G92`@($1E8W)E;65N=',@=&AE('9A;'5E(&EN('1H
M92!F:65L9`H@("`@("`@("`@("!B>2!T:&4@86-C96QE<F%T960@9&5C<F5M
M96YT('9A;'5E+@I5("`@("`@("`@("!$96-R96UE;G1S('1H92!V86QU92!I
M;B!T:&4@9FEE;&0*("`@("`@("`@("`@8GD@=&AE(&%C8V5L97)A=&5D(&1E
M8W)E;65N="!V86QU92X*0W1R;"U"("`@("`@1&5C<F5M96YT<R!T:&4@=F%L
M=64@:6X@=&AE(&9I96QD"B`@("`@("`@("`@(&)Y('1H92!A8V-E;&5R871E
M9"!D96-R96UE;G0@=F%L=64N"DYE>'0@4&%G92`@($EN8W)E;65N=',@=&AE
M('9A;'5E(&EN('1H92!F:65L9`H@("`@("`@("`@("!B>2!T:&4@86-C96QE
M<F%T960@:6YC<F5M96YT('9A;'5E+@I$("`@("`@("`@("!);F-R96UE;G1S
M('1H92!V86QU92!I;B!T:&4@9FEE;&0*("`@("`@("`@("`@8GD@=&AE(&%C
M8V5L97)A=&5D(&EN8W)E;65N="!V86QU92X*0W1R;"U&("`@("`@26YC<F5M
M96YT<R!T:&4@=F%L=64@:6X@=&AE(&9I96QD"B`@("`@("`@("`@(&)Y('1H
M92!A8V-E;&5R871E9"!I;F-R96UE;G0@=F%L=64N"DAO;64@("`@("`@(%-E
M=',@=&AE('9A;'5E('1O('1H92!L;W<@=F%L=64N"F<@("`@("`@("`@(%-E
M=',@=&AE('9A;'5E('1O('1H92!L;W<@=F%L=64N"C`@("`@("`@("`@(%-E
M=',@=&AE('9A;'5E('1O('1H92!L;W<@=F%L=64N"D5N9"`@("`@("`@(%-E
M=',@=&AE('9A;'5E('1O('1H92!H:6=H('9A;'5E+@I'("`@("`@("`@("!3
M971S('1H92!V86QU92!T;R!T:&4@:&EG:"!V86QU92X*)"`@("`@("`@("`@
M4V5T<R!T:&4@=F%L=64@=&\@=&AE(&AI9V@@=F%L=64N"E)E='5R;B`@("`@
M($5X:71S('1H92!W:61G970@86YD(')E='5R;G,@86X*("`@("`@("`@("`@
M:6YT96=E<B!V86QU92!R97!R97-E;G1I;F<@=&AE"B`@("`@("`@("`@(&-U
M<G)E;G0@=F%L=64N(%1H:7,@86QS;R!S971S('1H90H@("`@("`@("`@("!S
M=')U8W1U<F4@;65M8F5R(%QF-&5X:714>7!E7&8Q(&EN"B`@("`@("`@("`@
M('1H92!W:61G970@<&]I;G1E<B!T;R!T:&4@=F%L=64@;V8*("`@("`@("`@
M("`@7&8T=DY/4DU!3%QF,2X*5&%B("`@("`@("`@17AI=',@=&AE('=I9&=E
M="!A;F0@<F5T=7)N<R!A;@H@("`@("`@("`@("!I;G1E9V5R('9A;'5E(')E
M<')E<V5N=&EN9R!T:&4*("`@("`@("`@("`@8W5R<F5N="!V86QU92X@5&AI
M<R!A;'-O('-E=',@=&AE"B`@("`@("`@("`@('-T<G5C='5R92!M96UB97(@
M7&8T97AI=%1Y<&5<9C$@:6X*("`@("`@("`@("`@=&AE('=I9&=E="!P;VEN
M=&5R('1O('1H92!V86QU92!O9@H@("`@("`@("`@("!<9C1V3D]234%,7&8Q
M+@I%<V-A<&4@("`@("!%>&ET<R!T:&4@=VED9V5T(&%N9"!R971U<FYS("TQ
M+@H@("`@("`@("`@("!4:&ES(&%L<V\@<V5T<R!T:&4@<W1R=6-T=7)E(&UE
M;6)E<@H@("`@("`@("`@("!<9C1E>&ET5'EP95QF,2!I;B!T:&4@=VED9V5T
M('!O:6YT97(*("`@("`@("`@("`@=&\@=&AE('9A;'5E(&]F(%QF-'9%4T-!
M4$5?2$E47&8Q+@I#=')L+5(@("`@("!2969R97-H97,@=&AE('-C<F5E;BX*
M+E)%"BYF:0HN4T@@4T5%($%,4T\*+D)2(&-D:R`H,RDL"BY"4B!C9&M?8FEN
M9&EN9R`H,RDL"BY"4B!C9&M?9&ES<&QA>2`H,RDL"BY"4B!C9&M?<V-R965N
M("@S*0HN4T@@3D]415,*+E!0"E1H92!H96%D97(@9FEL92!<9C0\8V1K+F@^
M7&8Q(&%U=&]M871I8V%L;'D@:6YC;'5D97,@=&AE(&AE861E<B!F:6QE<PI<
M9C0\8W5R<V5S+F@^7&8Q+"!<9C0\<W1D;&EB+F@^7&8Q+"!<9C0\<W1R:6YG
M+F@^7&8Q+"!<9C0\8W1Y<&4N:#Y<9C$L"EQF-#QU;FES=&0N:#Y<9C$L(%QF
M-#QD:7)E;G0N:#Y<9C$L(%QF-#QT:6UE+F@^7&8Q+"!<9C0\97)R;F\N:#Y<
M9C$L"EQF-#QP=V0N:#Y<9C$L(%QF-#QG<G`N:#Y<9C$L(%QF-#QS>7,O<W1A
M="YH/EQF,2P@86YD(%QF-#QS>7,O='EP97,N:#Y<9C$N"E1H92!<9C0\8W5R
M<V5S+F@^7&8Q(&AE861E<B!F:6QE(&EN8VQU9&5S(%QF-#QS=&1I;RYH/EQF
M,2!A;F0@7&8T/'5N8W1R;"YH/EQF,2X*+E!0"DEF('EO=2!H879E(%QF-$YC
M=7)S97-<9C$@:6YS=&%L;&5D(&]N('EO=7(@;6%C:&EN92!A9&0@+41.0U52
M4T53('1O('1H92`*8V]M<&EL92!L:6YE('1O(&EN8VQU9&4@=&AE($YC=7)S
997,@:&5A9&5R(&9I;&5S(&EN<W1E860N"G1O
`
end
SHAR_EOF
  echo 'File cdk4.8.0/man/slider.3 is complete' &&
  echo 'uudecoding file cdk4.8.0/man/slider.3' &&
  uudecode _sharuue.tmp < _sharuue.tmp && rm -f _sharuue..tmp &&
  $shar_touch -am 0709111596 'cdk4.8.0/man/slider.3' &&
  chmod 0444 'cdk4.8.0/man/slider.3' ||
  echo 'restore of cdk4.8.0/man/slider.3 failed'
  shar_count="`wc -c < 'cdk4.8.0/man/slider.3'`"
  test 11140 -eq "$shar_count" ||
    echo "cdk4.8.0/man/slider.3: original size 11140, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk4.8.0/man/swindow.3 ==============
if test -f 'cdk4.8.0/man/swindow.3' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk4.8.0/man/swindow.3 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk4.8.0/man/swindow.3 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk4.8.0/man/swindow.3' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH cdk_swindow 3 "02 July 1996"
X.SH NAME
newCDKSwindow, activateCDKSwindow, injectCDKSwindow, setCDKSwindow,
drawCDKSwindow, eraseCDKSwindow, cleanCDKSwindow, addCDKSwindow, 
execCDKSwindow, trimCDKSwindow, saveCDKSwindowInformation,
loadCDKSwindowInformation, dumpCDKSwindow, destroyCDKSwindow,
setCDKSwindowPreProcess, setCDKSwindowPostProcess \- Creates a 
managed curses swindow widget.
X.SH SYNOPSIS
X.LP
X.B cc
X.RI "[ " "flag" " \|.\|.\|. ] " "file" " \|.\|.\|."
X.B \-lcdk
X.RI "[ " "library" " \|.\|.\|. ]"
X.LP
#include <cdk.h>
X.LP
X.BI "CDKSWINDOW *newCDKSwindow (CDKSCREEN *" "cdkscreen",
X.BI "int " "xpos",
X.BI "int " "ypos",
X.BI "int " "height",
X.BI "int " "width",
X.BI "char *" "title",
X.BI "int " "saveLines",
X.BI "boolean " "box",
X.BI "boolean " "shadow");
X.LP
X.BI "void activateCDKSwindow (CDKSWINDOW *" "swindow",
X.BI "chtype * " "actions");
X.LP
X.BI "int injectCDKSwindow (CDKSWINDOW *" "swindow",
X.BI "chtype " "input");
X.LP
X.BI "void setCDKSwindow (CDKSWINDOW *" "swindow",
X.BI "char **" "info",
X.BI "int " "lines",
X.BI "boolean " "box");
X.LP
X.BI "void drawCDKSwindow (CDKSWINDOW *" "swindow",
X.BI "boolean " "box");
X.LP
X.BI "void eraseCDKSwindow (CDKSWINDOW *" "swindow");
X.LP
X.BI "void cleanCDKSwindow (CDKSWINDOW *" "swindow");
X.LP
X.BI "void addCDKSwindow (CDKSWINDOW *" "swindow",
X.BI "char *" "info",
X.BI "int " "insertPosition");
X.LP
X.BI "int execCDKSwindow (CDKSWINDOW *" "swindow",
X.BI "char * " "command",
X.BI "int " "insertPosition");
X.LP
X.BI "void trimCDKSwindow (CDKSWINDOW *" "swindow",
X.BI "int " "start",
X.BI "int " "finish");
X.LP
X.BI "void saveCDKSwindowInformation (CDKSWINDOW *" "swindow");
X.LP
X.BI "void loadCDKSwindowInformation (CDKSWINDOW *" "swindow");
X.LP
X.BI "void dumpCDKSwindow (CDKSWINDOW *" "swindow",
X.BI "char *" "filename");
X.LP
X.BI "void destroyCDKSwindow (CDKSWINDOW *" "swindow");
X.LP
X.BI "void setCDKSwindowPreProcess (CDKSWINDOW *" "swindow",
X.BI "PROCESSFN " "callback",
X.BI "void * " "data");
X.LP
X.BI "void setCDKSwindowPostProcess (CDKSWINDOW *" "swindow",
X.BI "PROCESSFN " "callback",
X.BI "void * " "data");
X.LP
X.BI "void bindCDKObject (EObjectType " "widgetType",
X.BI "void *" "object",
X.BI "chtype " "key",
X.BI "BINDFN " "function",
X.BI "void *" "data");
X.SH DESCRIPTION
The Cdk scrolling window widget creates a widget which can be used to display
messages. The following are functions which create or manipulate the Cdk 
swindow box widget.
X
X.SH AVAILABLE FUNCTIONS
CDKSWINDOW *newCDKSwindow (CDKSCREEN *\f2screen\f1, int \f2xpos\f1, int \f2ypos\f1, int \f2height\f1, int \f2width\f1, char *\f2title\f1, int \f2saveLines\f1, boolean \f2box\f1);
X.RS 3
This function creates a pointer to a swindow widget. The \f2screen\f1 parameter
is the screen you wish this widget to be placed in. The parameter \f2xpos\f1
controls the placement of the object along the horizontal axis. This parameter
can accept an integer value or one of the pre-defined values of \f4LEFT\f1,
\f4RIGHT\f1, and \f4CENTER\f1. The parameter \f2ypos\f1 controls the placement
of the object along the vertical axis. This parameter can accept an integer 
value or one of the pre-defined values of \f4TOP\f1, \f4BOTTOM\f1, and \f4CENTER\f1.
The parameters \f2height\f1 and \f2width\f1 are the height and the width of the
window respectively. The \f2title\f1 parameter is the title of the scrolling window.
The parameter \f2saveLines\f1 is the number of lines to save before throwing
information away. The \f2box\f1 parameter states whether the widget will
be drawn with a box around it or not. The \f2shadow\f1 parameter accepts a 
boolean value to turn the shadow on or off around this widget. If the widget
could not be created then a \f4NULL\f1 pointer is returned.
X.RE
X
int activateCDKSwindow (CDKSWINDOW *\f2swindow\f1, chtype *\f2actions\f1);
X.RS 3
This function activates the swindow widget and lets the user interact with the
widget. The parameter \f2swindow\f1 is a pointer to a non-NULL swindow widget.
If the \f2actions\f1 parameter is passed with a non-NULL value, the characters
in the array will be injected into the widget. To activate the widget
interactively pass in a \f4NULL\f1 pointer for \f2actions\f1. If the character
entered into this widget is \f4RETURN\f1 or \f4TAB\f1 then this function will
return 1.  It will also set the structure member \f4exitType\f1 to \f4vNORMAL\f1.
If the character entered into this widget was \f4ESCAPE\f1 then the widget will
return a value of -1 and the structure member \f4exitType\f1 will be set to
\f4vESCAPE_HIT\f1.
X.RE
X
void injectCDKSwindow (CDKSWINDOW *\f2swindow\f1, chtype \f2character\f1);
X.RS 3
This function injects a single character into the widget. The parameter 
\f2swindow\f1 is a pointer to a non-NULL swindow widget. The parameter 
\f2character\f1 is the character to inject into the widget. If the character 
injected into this widget was \f4RETURN\f1 then the character injected into
this widget is \f4RETURN\f1 or \f4TAB\f1 then this function will return 1. It
will also set the structure member \f4exitType\f1 to \f4vNORMAL\f1. If the 
character entered into this widget was \f4ESCAPE\f1 then the widget will return
a value of -1 and the structure member \f4exitType\f1 will be set to
\f4vESCAPE_HIT\f1. Any other character injected into the widget will set the 
structure member \f4exitType\f1 to \f4vEARLY_EXIT\f1 and the function will 
return -1.
X.RE
X
void setCDKSwindow (CDKSWINDOW *\f2swindow\f1, char **\f2info\f1, int \f2lines\f1, boolean \f2box\f1);
X.RS 3
This function lets the programmer modify certain elements of an already defined
swindow widget. The parameter \f2info\f1 is a \f4char **\f1 of the information
to set in the scrolling window; \f2lines\f1 is the number of lines being added.
The other parameter names correspond to the same parameter names listed in the 
\f4newCDKSwindow\f1 function.
X.RE
X
void drawCDKSwindow (CDKSWINDOW *\f2swindow\f1, boolean \f2box\f1);
X.RS 3
This function draws the swindow widget on the screen. The \f2box\f1 option 
draws the widget with or without a box.
X.RE
X
void eraseCDKSwindow (CDKSWINDOW *\f2swindow\f1);
X.RS 3
This function removes the widget from the screen. This does \f4NOT\f1 destroy
the widget.
X.RE 
X
void cleanCDKSwindow (CDKSWINDOW *\f2swindow\f1);
X.RS 3
This function clears the information from the window.
X.RE
X
void addCDKSwindow (CDKSWINDOW *\f2swindow\f1, char *\f2info\f1, int \f2insertPosition\f1);
X.RS 3
This function adds information to a defined scrolling window. The information
is supplied by the \f2info\f1 parameter. The information is immediately added
to the scrolling window. The position of the new information is governed by
the value of the parameter \f2insertPosition\f1. This parameter can accept
two values: \f4TOP\f1 or \f4BOTTOM\f1.
X.RE
X
void execCDKSwindow (CDKSWINDOW *\f2swindow\f1, char *\f2command\f1, int \f2insertPosition\f1);
X.RS 3
This function allows the user to execute a shell command and have the output
of the shell command direct itself to the scrolling window. The \f2command\f1
parameter is the command to execute while \f2insertPosition\f1 is where the
output is to insert itself within the scrolling window.
X.RE
X
void trimCDKSwindow (CDKSWINDOW *\f2swindow\f1, int \f2start\f1, int \f2end\f1);
X.RS 3
This function removes information from the scrolling window. The parameters
\f2start\f1 and \f2end\f1 state where to start cutting from and where to stop.
The first element in the scrolling window starts at index 0.
X.RE
X
void saveCDKSwindowInformation (CDKSWINDOW *\f2swindow\f1)
X.RS 3
This function allows the user to save the contents of the scrolling window
into a file. This function is interactive, and will ask for a filename.
X.RE
X
void loadCDKSwindowInformation (CDKSWINDOW *\f2swindow\f1)
X.RS 3
This function allows the user to load the contents of a file into the 
scrolling window. This function is interactive, and will ask for a filename.
X.RE
X
int dumpCDKSwindowInformation (CDKSWINDOW *\f2swindow\f1, char *\f2filename\f1)
X.RS 3
This function saves the contents of the scrolling window into the file
specified by the \f2filename\f1 parameter. It returns -1 on failure,
and the number of lines saved if the dump was successful.
X.RE
X
void destroyCDKSwindow (CDKSWINDOW *\f2swindow\f1);
X.RS 3
This function removes the widget from the screen and frees up any memory the
object may be using.
X.RE
X
void setCDKSwindowPreProcess (CDKSWINDOW *\f2swindow\f1, PROCESSFN \f2function\f1, void *\f2data\f1);
X.RS 3
This function allows the user to have the widget call a function after a key
is hit and before the key is applied to the widget. The parameter \f2function\f1
if of type \f4PROCESSFN\f1. The parameter \f2data\f1 is a pointer to 
\f4void\f1. To learn more about pre-processing read the \f4cdk_process\f1
manual page.
X.RE
X 
void setCDKSwindowPostProcess (CDKSWINDOW *\f2swindow\f1, PROCESSFN \f2function\f1, void *\f2data\f1);
X.RS 3
This function allows the user to have the widget call a function after the
key has been applied to the widget.  The parameter \f2function\f1 if of type
\f4PROCESSFN\f1. The parameter \f2data\f1 is a pointer to \f4void\f1. To
learn more about post-processing read the \f4cdk_process\f1 manual page.
X.RE
X
void bindCDKObject (EObjectType \f2widgetType\f1, void *\f2object\f1, char \f2key\f1, BINDFN \f2function\f1, void *\f2data\f1);
X.RS 3
This function allows the user to create special key bindings. The 
\f2widgetType\f1 parameter is a defined type which states what Cdk object 
type is being used.  To learn more about the type \f4EObjectType\f1 read 
the \f4cdk_binding\f1 manual page. The \f2object\f1 parameter is the pointer
to the widget object. The \f2key\f1 is the character to bind. The 
\f2function\f1 is the function type. To learn more about the key binding 
callback function types read the \f4cdk_binding\f1 manual page. The last 
parameter \f2data\f1 is a pointer to any data that needs to get passed to 
the callback function.
X.RE
X.SH KEY BINDINGS
When the widget is activated there are several default key bindings which will
help the user enter or manipulate the information quickly. The following table
outlines the keys and their actions for this widget.
X.LP
X.nf
X.RS 3
\f2Key          Action\f1
Left Arrow  Scrolls the window left one character.
Right Arrow Scrolls the window right one character.
Up Arrow    Scrolls the window up one line.
Down Arrow  Scrolls the window up down line.
Prev Page   Scrolls the window backwards one page.
Ctrl-B      Scrolls the window backwards one page.
b           Scrolls the window backwards one page.
B           Scrolls the window backwards one page.
Next Page   Scrolls the window forwards one page.
Ctrl-F      Scrolls the window forwards one page.
Space       Scrolls the window forwards one page.
f           Scrolls the window forwards one page.
F           Scrolls the window forwards one page.
Home        Moves the whole list to the far left character.
|           Moves the whole list to the far left character.
End         Moves the whole list to the far right character.
$           Moves the whole list to the far right character.
g           Moves to the top of the scrolling window.
1           Moves to the top of the scrolling window.
G           Moves to the bottom of the scrolling window.
l           Loads a file into the scrolling window.
L           Loads a file into the scrolling window.
s           Saves the contents of the scrolling window into a file.
S           Saves the contents of the scrolling window into a file.
Return      Exits the widget and returns 1. This also sets
X            the structure member \f4exitType\f1 in the widget
X            pointer to the value of \f4vNORMAL\f1.
Tab         Exits the widget and returns 1. This also sets
X            the structure member \f4exitType\f1 in the widget
X            pointer to the value of \f4vNORMAL\f1.
Escape      Exits the widget and returns -1. This also sets
X            the structure member \f4exitType\f1 in the widget
X            pointer to the value of \f4vESCAPE_HIT\f1.
Ctrl-L      Refreshes the screen.
X.RE
X.fi
X.SH SEE ALSO
X.BR cdk (3),
X.BR cdk_binding (3),
X.BR cdk_display (3),
X.BR cdk_screen (3)
X.SH NOTES
X.PP
The header file \f4<cdk.h>\f1 automatically includes the header files
\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
The \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
X.PP
If you have \f4Ncurses\f1 installed on your machine add -DNCURSES to the 
compile line to include the Ncurses header files instead.
SHAR_EOF
  $shar_touch -am 0709111596 'cdk4.8.0/man/swindow.3' &&
  chmod 0444 'cdk4.8.0/man/swindow.3' ||
  echo 'restore of cdk4.8.0/man/swindow.3 failed'
  shar_count="`wc -c < 'cdk4.8.0/man/swindow.3'`"
  test 12691 -eq "$shar_count" ||
    echo "cdk4.8.0/man/swindow.3: original size 12691, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk4.8.0/man/template.3 ==============
if test -f 'cdk4.8.0/man/template.3' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk4.8.0/man/template.3 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk4.8.0/man/template.3 (binary)'
  sed 's/^X//' << 'SHAR_EOF' > _sharuue.tmp &&
begin 600 cdk4.8.0/man/template.3
M+F1E($ET"BYB<@HN:64@7%QN*"XD/CTS("YN92!<7"0S"BYE;"`N;F4@,PHN
M25`@(EQ<)#$B(%Q<)#(*+BX*+E1((&-D:U]T96UP;&%T92`S("(P-2!$96,@
M,3DY-2(*+E-(($Y!344*;F5W0T1+5&5M<&QA=&4L(&%C=&EV871E0T1+5&5M
M<&QA=&4L(&EN:F5C=$-$2U1E;7!L871E+"!S971#1$M496UP;&%T92P*<V5T
M0T1+5&5M<&QA=&5#0BP@9')A=T-$2U1E;7!L871E+"!E<F%S94-$2U1E;7!L
M871E+"!C;&5A;D-$2U1E;7!L871E+"`*;6EX0T1+5&5M<&QA=&4L('5N;6EX
M0T1+5&5M<&QA=&4L(&1E<W1R;WE#1$M496UP;&%T92P@<V5T0T1+5&5M<&QA
M=&50<F50<F]C97-S+`IS971#1$M496UP;&%T95!O<W10<F]C97-S(%PM($-R
M96%T97,@82!M86YA9V5D(&-U<G-E<R!T96UP;&%T92`*=VED9V5T+@HN4T@@
M4UE.3U!325,*+DQ0"BY"(&-C"BY222`B6R`B(")F;&%G(B`B(%Q\+EQ\+EQ\
M+B!=("(@(F9I;&4B("(@7'PN7'PN7'PN(@HN0B!<+6QC9&L*+E))(");("(@
M(FQI8G)A<GDB("(@7'PN7'PN7'PN(%TB"BY,4`HC:6YC;'5D92`\8V1K+F@^
M"BY,4`HN0DD@(D-$2U1%35!,051%("IN97=#1$M496UP;&%T92`H0T1+4T-2
M145.("HB(")C9&MS8W)E96XB+`HN0DD@(FEN="`B(")X<&]S(BP*+D))(")I
M;G0@(B`B>7!O<R(L"BY"22`B:6YT("(@(FQP;W,B+`HN0DD@(F-H87(@*B(@
M(FQA8F5L(BP*+D))(")C:&%R("HB(")P;&%T92(L"BY"22`B8VAA<B`J(B`B
M;W9E<FQA>2(L"BY"22`B8F]O;&5A;B`B(")B;W@B+`HN0DD@(F)O;VQE86X@
M(B`B<VAA9&]W(BD["BY,4`HN0DD@(F-H87(@*F%C=&EV871E0T1+5&5M<&QA
M=&4@*$-$2U1%35!,051%("HB(")T96UP;&%T92(L"BY"22`B8VAT>7!E("H@
M(B`B86-T:6]N<R(I.PHN3%`*+D))(")C:&%R("II;FIE8W1#1$M496UP;&%T
M92`H0T1+5$5-4$Q!5$4@*B(@(G1E;7!L871E(BP*+D))(")C:'1Y<&4@(B`B
M:6YP=70B*3L*+DQ0"BY"22`B=F]I9"!S971#1$M496UP;&%T92`H0T1+5$5-
M4$Q!5$4@*B(@(G1E;7!L871E(BP*+D))(")C:&%R("HB(")V86QU92(L"BY"
M22`B8F]O;&5A;B`B(")B;W@B*3L*+DQ0"BY"22`B=F]I9"!S971#1$M496UP
M;&%T94-"("A#1$M414U03$%412`J(B`B=&5M<&QA=&4B+`HN0DD@(E1%35!,
M051%0T(@(B`B8V%L;&)A8VM&=6YC=&EO;B(I.PHN3%`*+D))(")V;VED(&1R
M87=#1$M496UP;&%T92`H0T1+5$5-4$Q!5$4@*B(@(G1E;7!L871E(BP*+D))
M(")B;V]L96%N("(@(F)O>"(I.PHN3%`*+D))(")V;VED(&5R87-E0T1+5&5M
M<&QA=&4@*$-$2U1%35!,051%("HB(")T96UP;&%T92(I.PHN3%`*+D))(")V
M;VED(&-L96%N0T1+5&5M<&QA=&4@*$-$2U1%35!,051%("HB(")T96UP;&%T
M92(I.PHN3%`*+D))(")C:&%R("IM:7A#1$M496UP;&%T92`H0T1+5$5-4$Q!
M5$4@*B(@(G1E;7!L871E(BD["BY,4`HN0DD@(F-H87(@*G5N;6EX0T1+5&5M
M<&QA=&4@*$-$2U1%35!,051%("HB(")T96UP;&%T92(I.PHN3%`*+D))(")V
M;VED(&1E<W1R;WE#1$M496UP;&%T92`H0T1+5$5-4$Q!5$4@*B(@(G1E;7!L
M871E(BD["BY,4`HN0DD@(G9O:60@<V5T0T1+5&5M<&QA=&50<F50<F]C97-S
M("A#1$M414U03$%412`J(B`B=&5M<&QA=&4B+`HN0DD@(E!23T-%4U-&3B`B
M(")C86QL8F%C:R(L"BY"22`B=F]I9"`J("(@(F1A=&$B*3L*+DQ0"BY"22`B
M=F]I9"!S971#1$M496UP;&%T95!O<W10<F]C97-S("A#1$M414U03$%412`J
M(B`B=&5M<&QA=&4B+`HN0DD@(E!23T-%4U-&3B`B(")C86QL8F%C:R(L"BY"
M22`B=F]I9"`J("(@(F1A=&$B*3L*+DQ0"BY"22`B=F]I9"!B:6YD0T1+3V)J
M96-T("A%3V)J96-T5'EP92`B(")W:61G9714>7!E(BP*+D))(")V;VED("HB
M(")O8FIE8W0B+`HN0DD@(F-H='EP92`B(")K97DB+`HN0DD@(D))3D1&3B`B
M(")F=6YC=&EO;B(L"BY"22`B=F]I9"`J(B`B9&%T82(I.PHN4T@@1$530U))
M4%1)3TX*5&AE($-D:R!T96UP;&%T92!W:61G970@8W)E871E<R!A('1E;7!L
M871E('=I9&=E="!W:&EC:"!A;&QO=W,@82!U<V5R('1O('1Y<&4@"FEN9F]R
M;6%T:6]N(&EN=&\@86X@96YT<GD@9FEE;&0@=VET:"!A('!R92US970@9FEE
M;&0@9F]R;6%T+B!4>7!I8V%L('5S97,@9F]R"G1H:7,@=VED9V5T('=O=6QD
M(&)E(&$@9&%T92!F:65L9"!O<B!A('1I;64@9FEE;&0N(%1H92!F;VQL;W=I
M;F<@87)E(&9U;F-T:6]N<PIW:&EC:"!C<F5A=&4@;W(@;6%N:7!U;&%T92!T
M:&4@0V1K('1E;7!L871E(&)O>"!W:61G970N"@HN4T@@059!24Q!0DQ%($95
M3D-424].4PI#1$M414U03$%412`J;F5W0T1+5&5M<&QA=&4@*$-$2U-#4D5%
M3B`J7&8R<V-R965N7&8Q+"!I;G0@7&8R>'!O<UQF,2P@:6YT(%QF,GEP;W-<
M9C$L(&EN="!<9C)L<&]S7&8Q+"!C:&%R("I<9C)L86)E;%QF,2P@8VAA<B`J
M7&8R<&QA=&5<9C$L(&-H87(@*EQF,F]V97)L87E<9C$L(&)O;VQE86X@7&8R
M8F]X7&8Q+"!B;V]L96%N(%QF,G-H861O=UQF,2D["BY24R`S"E1H:7,@9G5N
M8W1I;VX@8W)E871E<R!A('!O:6YT97(@=&\@82!T96UP;&%T92!W:61G970N
M(%1H92!<9C)S8W)E96Y<9C$@<&%R86UE=&5R"FES('1H92!S8W)E96X@>6]U
M('=I<V@@=&AI<R!W:61G970@=&\@8F4@<&QA8V5D(&EN+B!4:&4@<&%R86UE
M=&5R(%QF,GAP;W-<9C$*8V]N=')O;',@=&AE('!L86-E;65N="!O9B!T:&4@
M;V)J96-T(&%L;VYG('1H92!H;W)I>F]N=&%L(&%X:7,N(%1H:7,@<&%R86UE
M=&5R"F-A;B!A8V-E<'0@86X@:6YT96=E<B!V86QU92!O<B!O;F4@;V8@=&AE
M('!R92UD969I;F5D('9A;'5E<R!O9B!<9C1,14947&8Q+`I<9C1224=(5%QF
M,2P@86YD(%QF-$-%3E1%4EQF,2X@5&AE('!A<F%M971E<B!<9C)Y<&]S7&8Q
M(&-O;G1R;VQS('1H92!P;&%C96UE;G0*;V8@=&AE(&]B:F5C="!A;&]N9R!T
M:&4@=F5R=&EC86P@87AI<RX@5&AI<R!P87)A;65T97(@8V%N(&%C8V5P="!A
M;B!I;G1E9V5R(`IV86QU92!O<B!O;F4@;V8@=&AE('!R92UD969I;F5D('9A
M;'5E<R!O9B!<9C143U!<9C$L(%QF-$)/5%1/35QF,2P@86YD(%QF-$-%3E1%
M4EQF,2X*5&AE('!A<F%M971E<B!<9C)L<&]S7&8Q(&-O;G1R;VQS('=H97)E
M('1H92!L86)E;"!I<R!T;R!B92!S970N($ET(&-A;B!T86ME(&%N(`II;G1E
M9V5R('9A;'5E(&]R(&]N92!O9B!T:&4@<')E+61E9FEN960@=F%L=65S.B!<
M9C143U!<9C$L(%QF-$)/5%1/35QF,2P@"EQF-$Q%1E1<9C$L(%QF-%))1TA4
M7&8Q+"!A;F0@7&8T0T5.5$527&8Q+B!4:&4@7&8R;&%B96Q<9C$@<&%R86UE
M=&5R(&ES('1H92`*<W1R:6YG('=H:6-H('=I;&P@8F4@9&ES<&QA>65D(&EN
M('1H92!L86)E;"!O9B!T:&4@=&5M<&QA=&4@9FEE;&0N(%1H92`*7&8R<&QA
M=&5<9C$@<&%R86UE=&5R(&1E9FEN97,@=VAA="!C:&%R86-T97(@:7,@86QL
M;W=E9"!A="!W:&%T('!O<VET:6]N(`II;B!T:&4@=&5M<&QA=&4@9FEE;&0N
M(%1H:7,@:7,@9&]N92!B>2!C<F5A=&EN9R!A(&-H87)A8W1E<B!P;&%T92!B
M>2!U<VEN9R`*<W!E8VEA;"!F;W)M870@8VAA<F%C=&5R('1O('1E;&P@=&AE
M('1E;7!L871E('=I9&=E="!W:&%T('1Y<&4@;V8@8VAA<F%C=&5R(`II<R!A
M;&QO=V5D('=H97)E(&EN('1H92!T96UP;&%T92!W:61G970N("!4:&4@9F]L
M;&]W:6YG('1A8FQE(&QI<W1S(&%L;"!O9@IT:&4@8W5R<F5N="!F;W)M870@
M='EP97,N"BY,4`HN;F8@"BY24R`S"EQF,E!L871E7T-H87)A8W1E<B`@($5F
M9F5C=%QF,0HC("`@("`@("`@("`@("`@("!!8V-E<'1S(&%N(&EN=&5G97(@
M=F%L=64N"D$@("`@("`@("`@("`@("`@($%C8V5P=',@86X@86QP:&%B971I
M8R!V86QU92X*0R`@("`@("`@("`@("`@("`@06-C97!T<R!A;B!A;'!H86)E
M=&EC('9A;'5E+B!!=71O;6%T:6-A;&QY"B`@("`@("`@("`@("`@("`@(&-O
M;G9E<G1S('1H92!C:&%R86-T97(@=&\@=7!P97(@8V%S92X*8R`@("`@("`@
M("`@("`@("`@06-C97!T<R!A;B!A;'!H86)E=&EC('9A;'5E+B!!=71O;6%T
M:6-A;&QY"B`@("`@("`@("`@("`@("`@(&-O;G9E<G1S('1H92!C:&%R86-T
M97(@=&\@;&]W97(@8V%S92X*32`@("`@("`@("`@("`@("`@06-C97!T<R!A
M;'!H86YU;65R:6,@8VAA<F%C=&5R<RX*6"`@("`@("`@("`@("`@("`@06-C
M97!T<R!A;'!H86YU;65R:6,@8VAA<F%C=&5R<RX@075T;VUA=&EC86QL>0H@
M("`@("`@("`@("`@("`@("!C;VYV97)T<R!T:&4@8VAA<F%C=&5R('1O('5P
M<&5R(&-A<V4N"G@@("`@("`@("`@("`@("`@($%C8V5P=',@86QP:&%N=6UE
M<FEC(&-H87)A8W1E<G,N($%U=&]M871I8V%L;'D*("`@("`@("`@("`@("`@
M("`@8V]N=F5R=',@=&AE(&-H87)A8W1E<B!T;R!U<'!E<B!C87-E+@I!;GET
M:&EN9R!E;'-E("`@("!)9VYO<F5D(&%N9"!A<W-U;65D(&$@;F]N+65D:71A
M8FQE('!O<VET:6]N+@HN9FD*+E)%"BY,4`I4:&4@7&8R;W9E<FQA>5QF,2!P
M87)A;65T97(@:7,@=&AE(&]V97)L87D@;V8@=&AE('1E;7!L871E(&9I96QD
M+B!)9B!T:&4@9FEE;&0*;F5E9&5D('-O;64@<V]R="!O9B!O=F5R;&%Y+"!T
M:&ES('!A<F%M971E<B!S=7!P;&EE<R!T:&ES+B!!(&1A=&4@9FEE;&0@8V]U
M;&0*:&%V92!962]-32]$1"P@=&AE(&]V97)L87D@<&%R86UE=&5R('=O=6QD
M(&1I<W!L87D@65DO34TO1$0@;VX@86X@96UP='D@=&5M<&QA=&4*9FEE;&0N
M("!4:&4@7&8R8F]X7&8Q('!A<F%M971E<B!S=&%T97,@=VAE=&AE<B!T:&4@
M=VED9V5T('=I;&P@8F4@9')A=VX@=VET:"!A(`IB;W@@87)O=6YD(&ET(&]R
M(&YO="X@5&AE(%QF,G-H861O=UQF,2!P87)A;65T97(@86-C97!T<R!A(&)O
M;VQE86X@=F%L=64@=&\@"G1U<FX@=&AE('-H861O=R!O;B!O<B!O9F8@87)O
M=6YD('1H:7,@=VED9V5T+B!4:&4@7&8R8F]X7&8Q('!A<F%M971E<B!S=&%T
M97,@"G=H971H97(@=&AE('=I9&=E="!W:6QL(&)E(&1R87=N('=I=&@@82!B
M;W@@87)O=6YD(&ET(&]R(&YO="X@5&AE(%QF,G-H861O=UQF,2`*<&%R86UE
M=&5R(&%C8V5P=',@82!B;V]L96%N('9A;'5E('1O('1U<FX@=&AE('-H861O
M=R!O;B!O<B!O9F8@87)O=6YD('1H:7,@"G=I9&=E="X@268@=&AE('=I9&=E
M="!C;W5L9"!N;W0@8F4@8W)E871E9"!T:&5N(&$@7&8T3E5,3%QF,2!P;VEN
M=&5R(&ES(')E='5R;F5D+@HN4D4*"F-H87(@*F%C=&EV871E0T1+5&5M<&QA
M=&4@*$-$2U1%35!,051%("I<9C)T96UP;&%T95QF,2P@8VAT>7!E("I<9C)A
M8W1I;VYS7&8Q*3L*+E)3(#,*5&AI<R!F=6YC=&EO;B!A8W1I=F%T97,@=&AE
M('1E;7!L871E('=I9&=E="!A;F0@;&5T<R!T:&4@=7-E<B!I;G1E<F%C="!W
M:71H('1H90IW:61G970N(%1H92!P87)A;65T97(@7&8R=&5M<&QA=&5<9C$@
M:7,@82!P;VEN=&5R('1O(&$@;F]N+4Y53$P@=&5M<&QA=&4@=VED9V5T+@I)
M9B!T:&4@7&8R86-T:6]N<UQF,2!P87)A;65T97(@:7,@<&%S<V5D('=I=&@@
M82!N;VXM3E5,3"!V86QU92P@=&AE(&-H87)A8W1E<G,*:6X@=&AE(&%R<F%Y
M('=I;&P@8F4@:6YJ96-T960@:6YT;R!T:&4@=VED9V5T+B!4;R!A8W1I=F%T
M92!T:&4@=VED9V5T"FEN=&5R86-T:79E;'D@<&%S<R!I;B!A(%QF-$Y53$Q<
M9C$@<&]I;G1E<B!F;W(@7&8R86-T:6]N<UQF,2X@268@=&AE(&-H87)A8W1E
M<B!E;G1E<F5D"FEN=&\@=&AI<R!W:61G970@:7,@7&8T4D5455).7&8Q(&]R
M(%QF-%1!0EQF,2!T:&5N('1H:7,@9G5N8W1I;VX@=VEL;"!R971U<FX@"F$@
M7&8T8VAA<B`J7&8Q(')E<')E<V5N=&EN9R!T:&4@:6YF;W)M871I;VX@='EP
M960@:6YT;R!T:&4@=VED9V5T(&%N9"!T:&4@"G-T<G5C='5R92!M96UB97(@
M7&8T97AI=%1Y<&5<9C$@=VEL;"!B92!S970@=&\@7&8T=DY/4DU!3%QF,2X@
M268@=&AE(&-H87)A8W1E<@IE;G1E<F5D('=A<R!<9C1%4T-!4$5<9C$@=&AE
M;B!T:&4@9G5N8W1I;VX@=VEL;"!R971U<FYS(%QF-$Y53$Q<9C$@<&]I;G1E
M<B!A;F0@"G1H92!S=')U8W1U<F4@;65M8F5R(%QF-&5X:714>7!E7&8Q(&ES
M('-E="!T;R!<9C1V15-#05!%7TA)5%QF,2X*+E)%"@IC:&%R("II;FIE8W1#
M1$M496UP;&%T92`H0T1+5$5-4$Q!5$4@*EQF,G1E;7!L871E7&8Q+"!C:'1Y
M<&4@7&8R8VAA<F%C=&5R7&8Q*3L*+E)3(#,*5&AI<R!F=6YC=&EO;B!I;FIE
M8W1S(&$@<VEN9VQE(&-H87)A8W1E<B!I;G1O('1H92!W:61G970N(%1H92!P
M87)A;65T97(@"EQF,G1E;7!L871E7&8Q(&ES(&$@<&]I;G1E<B!T;R!A(&YO
M;BU.54Q,('1E;7!L871E+B!4:&4@<&%R86UE=&5R(`I<9C)C:&%R86-T97)<
M9C$@:7,@=&AE(&-H87)A8W1E<B!T;R!I;FIE8W0@:6YT;R!T:&4@=VED9V5T
M+B!)9B!T:&4@8VAA<F%C=&5R(`II;FIE8W1E9"!I;G1O('1H:7,@=VED9V5T
M('=A<R!<9C1215154DY<9C$@;W(@7&8T5$%"7&8Q('1H96X@=&AI<R!F=6YC
M=&EO;B!W:6QL"G)E='5R;B!A(%QF-&-H87(@*EQF,2!R97!R97-E;G1I;F<@
M=&AE(&EN9F]R;6%T:6]N('1Y<&5D(&EN=&\@=&AE('=I9&=E="!A;F0@=&AE
M(`IS=')U8W1U<F4@;65M8F5R(%QF-&5X:714>7!E7&8Q('=I;&P@8F4@<V5T
M('1O(%QF-'9.3U)-04Q<9C$N($EF('1H92!C:&%R86-T97(*96YT97)E9"!W
M87,@7&8T15-#05!%7&8Q('1H96X@=&AE(&9U;F-T:6]N('=I;&P@<F5T=7)N
M<R!<9C1.54Q,7&8Q('!O:6YT97(@86YD(`IT:&4@<W1R=6-T=7)E(&UE;6)E
M<B!<9C1E>&ET5'EP95QF,2!I<R!S970@=&\@7&8T=D530T%015](251<9C$N
M($%N>2!O=&AE<B`*8VAA<F%C=&5R(&EN:F5C=&5D(&EN=&\@=&AE('=I9&=E
M="!W:6QL('-E="!T:&4@<W1R=6-T=7)E(&UE;6)E<B!<9C1E>&ET5'EP95QF
M,2`*=&\@7&8T=D5!4DQ97T58251<9C$@86YD('1H92!F=6YC=&EO;B!W:6QL
M(')E='5R;B!A(%QF-$Y53$Q<9C$@<&]I;G1E<BX*+E)%"@IV;VED('-E=$-$
M2U1E;7!L871E("A#1$M414U03$%412`J7&8R=&5M<&QA=&5<9C$L(&-H87(@
M*EQF,G9A;'5E7&8Q+"!B;V]L96%N(%QF,F)O>%QF,2D["BY24R`S"E1H:7,@
M9G5N8W1I;VX@;&5T<R!T:&4@<')O9W)A;6UE<B!M;V1I9GD@8V5R=&%I;B!E
M;&5M96YT<R!O9B!A;B!A;')E861Y(&1E9FEN960*=&5M<&QA=&4@=VED9V5T
M+B!4:&4@<&%R86UE=&5R(&YA;65S(&-O<G)E<W!O;F0@=&\@=&AE('-A;64@
M<&%R86UE=&5R(&YA;65S(`IL:7-T960@:6X@=&AE(%QF-&YE=T-$2U1E;7!L
M871E7&8Q(&9U;F-T:6]N+@HN4D4*"G9O:60@<V5T0T1+5&5M<&QA=&5#0B`H
M0T1+5$5-4$Q!5$4@*EQF,G1E;7!L871E7&8Q+"!414U03$%414-"(%QF,F-A
M;&QB86-K1G5N8W1I;VY<9C$I.PHN4E,@,PI4:&ES(&9U;F-T:6]N(&%L;&]W
M<R!T:&4@<')O9W)A;6UE<B!T;R!S970@82!D:69F97)E;G0@=VED9V5T(&EN
M<'5T(&AA;F1L97(N"E1H92!P87)A;65T97(@7&8R8V%L;&)A8VM&=6YC=&EO
M;EQF,2!I<R!O9B!T>7!E(%QF-%1%35!,051%0T)<9C$N(%1H92!C=7)R96YT
M"F1E9F%U;'0@9G5N8W1I;VX@:7,@7&8T0T1+5&5M<&QA=&5#86QL0F%C:UQF
M,2X*+E)%"@IV;VED(&1R87=#1$M496UP;&%T92`H0T1+5$5-4$Q!5$4@*EQF
M,G1E;7!L871E7&8Q+"!B;V]L96%N(%QF,F)O>%QF,2D["BY24R`S"E1H:7,@
M9G5N8W1I;VX@9')A=W,@=&AE('1E;7!L871E('=I9&=E="!O;B!T:&4@<V-R
M965N+B!4:&4@7&8R8F]X7&8Q(&]P=&EO;B`*9')A=W,@=&AE('=I9&=E="!W
M:71H(&]R('=I=&AO=70@82!B;W@N"BY210H*=F]I9"!E<F%S94-$2U1E;7!L
M871E("A#1$M414U03$%412`J7&8R=&5M<&QA=&5<9C$I.PHN4E,@,PI4:&ES
M(&9U;F-T:6]N(')E;6]V97,@=&AE('=I9&=E="!F<F]M('1H92!S8W)E96XN
M(%1H:7,@9&]E<R!<9C1.3U1<9C$@9&5S=')O>0IT:&4@=VED9V5T+@HN4D4*
M"G9O:60@8VQE86Y#1$M496UP;&%T92`H0T1+5$5-4$Q!5$4@*EQF,G1E;7!L
M871E7&8Q*3L*+E)3(#,*5&AI<R!F=6YC=&EO;B!C;&5A<G,@=&AE(&EN9F]R
M;6%T:6]N(&9R;VT@=&AE(&9I96QD+@HN4D4*"F-H87(@*FUI>$-$2U1E;7!L
M871E("A#1$M414U03$%412`J7&8R=&5M<&QA=&5<9C$I.PHN4E,@,PI4:&ES
M(&9U;F-T:6]N(')E='5R;G,@82!<9C1C:&%R("I<9C$@<&]I;G1E<B!T;R!T
M:&4@9FEE;&0@=F%L=64@86YD('1H92`*<&QA=&4N"BY210H*8VAA<B`J=6YM
M:7A#1$M496UP;&%T92`H0T1+5$5-4$Q!5$4@*EQF,G1E;7!L871E7&8Q*3L*
M+E)3(#,*5&AI<R!F=6YC=&EO;B!R971U<FYS(&$@7&8T8VAA<B`J7&8Q('!O
M:6YT97(@=&\@=&AE(&9I96QD('9A;'5E('=I=&AO=70@86YY"G!L871E(&-H
M87)A8W1E<G,N"BY210H*=F]I9"!D97-T<F]Y0T1+5&5M<&QA=&4@*$-$2U1%
M35!,051%("I<9C)T96UP;&%T95QF,2D["BY24R`S"E1H:7,@9G5N8W1I;VX@
M<F5M;W9E<R!T:&4@=VED9V5T(&9R;VT@=&AE('-C<F5E;B!A;F0@9G)E97,@
M=7`@86YY(&UE;6]R>2!T:&4*;V)J96-T(&UA>2!B92!U<VEN9RX*+E)%"@IV
M;VED('-E=$-$2U1E;7!L871E4')E4')O8V5S<R`H0T1+5$5-4$Q!5$4@*EQF
M,G1E;7!L871E7&8Q+"!04D]#15-31DX@7&8R9G5N8W1I;VY<9C$L('9O:60@
M*EQF,F1A=&%<9C$I.PHN4E,@,PI4:&ES(&9U;F-T:6]N(&%L;&]W<R!T:&4@
M=7-E<B!T;R!H879E('1H92!W:61G970@8V%L;"!A(&9U;F-T:6]N(&%F=&5R
M(&$@:V5Y"FES(&AI="!A;F0@8F5F;W)E('1H92!K97D@:7,@87!P;&EE9"!T
M;R!T:&4@=VED9V5T+B!4:&4@<&%R86UE=&5R(%QF,F9U;F-T:6]N7&8Q"FEF
M(&]F('1Y<&4@7&8T4%)/0T534T9.7&8Q+B!4:&4@<&%R86UE=&5R(%QF,F1A
M=&%<9C$@:7,@82!P;VEN=&5R('1O(`I<9C1V;VED7&8Q+B!4;R!L96%R;B!M
M;W)E(&%B;W5T('!R92UP<F]C97-S:6YG(')E860@=&AE(%QF-&-D:U]P<F]C
M97-S7&8Q"FUA;G5A;"!P86=E+@HN4D4*(`IV;VED('-E=$-$2U1E;7!L871E
M4&]S=%!R;V-E<W,@*$-$2U1%35!,051%("I<9C)T96UP;&%T95QF,2P@4%)/
M0T534T9.(%QF,F9U;F-T:6]N7&8Q+"!V;VED("I<9C)D871A7&8Q*3L*+E)3
M(#,*5&AI<R!F=6YC=&EO;B!A;&QO=W,@=&AE('5S97(@=&\@:&%V92!T:&4@
M=VED9V5T(&-A;&P@82!F=6YC=&EO;B!A9G1E<B!T:&4*:V5Y(&AA<R!B965N
M(&%P<&QI960@=&\@=&AE('=I9&=E="X@(%1H92!P87)A;65T97(@7&8R9G5N
M8W1I;VY<9C$@:68@;V8@='EP90I<9C104D]#15-31DY<9C$N(%1H92!P87)A
M;65T97(@7&8R9&%T85QF,2!I<R!A('!O:6YT97(@=&\@7&8T=F]I9%QF,2X@
M5&\*;&5A<FX@;6]R92!A8F]U="!P;W-T+7!R;V-E<W-I;F<@<F5A9"!T:&4@
M7&8T8V1K7W!R;V-E<W-<9C$@;6%N=6%L('!A9V4N"BY210H*=F]I9"!B:6YD
M0T1+3V)J96-T("A%3V)J96-T5'EP92!<9C)W:61G9714>7!E7&8Q+"!V;VED
M("I<9C)O8FIE8W1<9C$L(&-H87(@7&8R:V5Y7&8Q+"!"24Y$1DX@7&8R9G5N
M8W1I;VY<9C$L('9O:60@*EQF,F1A=&%<9C$I.PHN4E,@,PI4:&ES(&9U;F-T
M:6]N(&%L;&]W<R!T:&4@=7-E<B!T;R!C<F5A=&4@<W!E8VEA;"!K97D@8FEN
M9&EN9W,N(%1H92`*7&8R=VED9V5T5'EP95QF,2!P87)A;65T97(@:7,@82!D
M969I;F5D('1Y<&4@=VAI8V@@<W1A=&5S('=H870@0V1K(&]B:F5C="`*='EP
M92!I<R!B96EN9R!U<V5D+B`@5&\@;&5A<FX@;6]R92!A8F]U="!T:&4@='EP
M92!<9C1%3V)J96-T5'EP95QF,2!R96%D('1H92`*7&8T8V1K7V)I;F1I;F=<
M9C$@;6%N=6%L('!A9V4N(%1H92!<9C)O8FIE8W1<9C$@<&%R86UE=&5R(&ES
M('1H92!P;VEN=&5R('1O(`IT:&4@=VED9V5T(&]B:F5C="X@5&AE(%QF,FME
M>5QF,2!I<R!T:&4@8VAA<F%C=&5R('1O(&)I;F0N(%1H92!<9C)F=6YC=&EO
M;EQF,2`*:7,@=&AE(&9U;F-T:6]N('1Y<&4N(%1O(&QE87)N(&UO<F4@86)O
M=70@=&AE(&ME>2!B:6YD:6YG(&-A;&QB86-K(&9U;F-T:6]N(`IT>7!E<R!R
M96%D('1H92!<9C1C9&M?8FEN9&EN9UQF,2!M86YU86P@<&%G92X@5&AE(&QA
M<W0@<&%R86UE=&5R(%QF,F1A=&%<9C$@"FES(&$@<&]I;G1E<B!T;R!A;GD@
M9&%T82!T:&%T(&YE961S('1O(&=E="!P87-S960@=&\@=&AE(&-A;&QB86-K
M(&9U;F-T:6]N+@HN4D4*"BY32"!+15D@0DE.1$E.1U,*5VAE;B!T:&4@=VED
M9V5T(&ES(&%C=&EV871E9"!T:&5R92!A<F4@<V5V97)A;"!D969A=6QT(&ME
M>2!B:6YD:6YG<R!W:&EC:"!W:6QL"FAE;'`@=&AE('5S97(@96YT97(@;W(@
M;6%N:7!U;&%T92!T:&4@:6YF;W)M871I;VX@<75I8VML>2X@5&AE(&9O;&QO
M=VEN9R!T86)L90IO=71L:6YE<R!T:&4@:V5Y<R!A;F0@=&AE:7(@86-T:6]N
M<R!F;W(@=&AI<R!W:61G970N"BY,4`HN;F8*+E)3(#,*7&8R2V5Y("`@("`@
M("`@($%C=&EO;EQF,0I$96QE=&4@("`@("!$96QE=&5S('1H92!C:&%R86-T
M97(@=&\@=&AE(&QE9G0@;V8@=&AE(&-U<G-O<BX*0F%C:W-P86-E("`@1&5L
M971E<R!T:&4@8VAA<F%C=&5R('1O('1H92!L969T(&]F('1H92!C=7)S;W(N
M"D-T<FPM4"`@("`@(%!A<W1E<R!W:&%T979E<B!I<R!I;B!T:&4@<&%S=&4@
M8G5F9F5R+"!I;G1O('1H92!W:61G970N"D-T<FPM2R`@("`@($-U=',@=&AE
M(&-O;G1E;G1S(&9R;VT@=&AE('=I9&=E="!A;F0@<V%V97,@82!C;W!Y(&EN
M(`H@("`@("`@("`@("!T:&4@<&%S=&4@8G5F9F5R+@I#=')L+50@("`@("!#
M;W!I97,@=&AE(&-O;G1E;G1S(&]F('1H92!W:61G970@:6YT;R!T:&4@<&%S
M=&4@8G5F9F5R+@I#=')L+44@("`@("!%<F%S97,@=&AE(&-O;G1E;G1S(&]F
M('1H92!W:61G970N"E)E='5R;B`@("`@($5X:71S('1H92!W:61G970@86YD
M(')E='5R;G,@82!<9C1C:&%R("I<9C$@<F5P<F5S96YT:6YG"B`@("`@("`@
M("`@('1H92!I;F9O<FUA=&EO;B!W:&EC:"!W87,@='EP960@:6YT;R!T:&4@
M9FEE;&0N($ET(&%L<V\*("`@("`@("`@("`@<V5T<R!T:&4@<W1R=6-T=7)E
M(&UE;6)E<B!<9C1E>&ET5'EP95QF,2!I;B!T:&4@=VED9V5T"B`@("`@("`@
M("`@('!O:6YT97(@=&\@7&8T=DY/4DU!3%QF,2X*5&%B("`@("`@("`@17AI
M=',@=&AE('=I9&=E="!A;F0@<F5T=7)N<R!A(%QF-&-H87(@*EQF,2!R97!R
M97-E;G1I;F<*("`@("`@("`@("`@=&AE(&EN9F]R;6%T:6]N('=H:6-H('=A
M<R!T>7!E9"!I;G1O('1H92!F:65L9"X@270@86QS;PH@("`@("`@("`@("!S
M971S('1H92!S=')U8W1U<F4@;65M8F5R(%QF-&5X:714>7!E7&8Q(&EN('1H
M92!W:61G970*("`@("`@("`@("`@<&]I;G1E<B!T;R!<9C1V3D]234%,7&8Q
M+@I%<V-A<&4@("`@("!%>&ET<R!T:&4@=VED9V5T(&%N9"!R971U<FYS(&$@
M7&8T3E5,3%QF,2!P;VEN=&5R+B!)="!A;'-O"B`@("`@("`@("`@('-E=',@
M=&AE('-T<G5C='5R92!M96UB97(@7&8T97AI=%1Y<&5<9C$@:6X@=&AE('=I
M9&=E="!P;VEN=&5R"B`@("`@("`@("`@('1O('1H92!V86QU92!O9B!<9C1V
M15-#05!%7TA)5%QF,2X*0W1R;"U,("`@("`@4F5F<F5S:&5S('1H92!S8W)E
M96XN"BY212`*+F9I"BY32"!3144@04Q33PHN0E(@8V1K("@S*2P*+D)2(&-D
M:U]B:6YD:6YG("@S*2P*+D)2(&-D:U]D:7-P;&%Y("@S*2P*+D)2(&-D:U]S
M8W)E96X@*#,I"BY32"!.3U1%4PHN4%`*5&AE(&AE861E<B!F:6QE(%QF-#QC
M9&LN:#Y<9C$@875T;VUA=&EC86QL>2!I;F-L=61E<R!T:&4@:&5A9&5R(&9I
M;&5S"EQF-#QC=7)S97,N:#Y<9C$L(%QF-#QS=&1L:6(N:#Y<9C$L(%QF-#QS
M=')I;F<N:#Y<9C$L(%QF-#QC='EP92YH/EQF,2P*7&8T/'5N:7-T9"YH/EQF
M,2P@7&8T/&1I<F5N="YH/EQF,2P@7&8T/'1I;64N:#Y<9C$L(%QF-#QE<G)N
M;RYH/EQF,2P*7&8T/'!W9"YH/EQF,2P@7&8T/&=R<"YH/EQF,2P@7&8T/'-Y
M<R]S=&%T+F@^7&8Q+"!A;F0@7&8T/'-Y<R]T>7!E<RYH/EQF,2X*5&AE(%QF
M-#QC=7)S97,N:#Y<9C$@:&5A9&5R(&9I;&4@:6YC;'5D97,@7&8T/'-T9&EO
M+F@^7&8Q(&%N9"!<9C0\=6YC=')L+F@^7&8Q+@HN4%`*268@>6]U(&AA=F4@
M7&8T3F-U<G-E<UQF,2!I;G-T86QL960@;VX@>6]U<B!M86-H:6YE(&%D9"`M
M1$Y#55)315,@=&\@=&AE(`IC;VUP:6QE(&QI;F4@=&\@:6YC;'5D92!T:&4@
>3F-U<G-E<R!H96%D97(@9FEL97,@:6YS=&5A9"X*
`
end
SHAR_EOF
  echo 'uudecoding file cdk4.8.0/man/template.3' &&
  uudecode _sharuue.tmp < _sharuue.tmp && rm -f _sharuue.tmp &&
  $shar_touch -am 0709111596 'cdk4.8.0/man/template.3' &&
  chmod 0444 'cdk4.8.0/man/template.3' ||
  echo 'restore of cdk4.8.0/man/template.3 failed'
  shar_count="`wc -c < 'cdk4.8.0/man/template.3'`"
  test 11955 -eq "$shar_count" ||
    echo "cdk4.8.0/man/template.3: original size 11955, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk4.8.0/man/viewer.3 ==============
if test -f 'cdk4.8.0/man/viewer.3' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk4.8.0/man/viewer.3 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk4.8.0/man/viewer.3 (binary)'
  sed 's/^X//' << 'SHAR_EOF' > _sharuue.tmp &&
begin 600 cdk4.8.0/man/viewer.3
M+F1E($ET"BYB<@HN:64@7%QN*"XD/CTS("YN92!<7"0S"BYE;"`N;F4@,PHN
M25`@(EQ<)#$B(%Q<)#(*+BX*+E1((&-D:U]V:65W97(@,U@@(C`U($1E8R`Q
M.3DU(@HN4T@@3D%-10IN97=#1$M6:65W97(L(&%C=&EV871E0T1+5FEE=V5R
M+"!S971#1$M6:65W97(L(&1R87=#1$M6:65W97(L(&5R87-E0T1+5FEE=V5R
M+`ID97-T<F]Y0T1+5FEE=V5R(%PM($-R96%T97,@82!M86YA9V5D(&-U<G-E
M<R!V:65W97(@;&ES="!W:61G970N"BY32"!364Y/4%-)4PHN3%`*+D(@8V,*
M+E))(");("(@(F9L86<B("(@7'PN7'PN7'PN(%T@(B`B9FEL92(@(B!<?"Y<
M?"Y<?"XB"BY"(%PM;&-D:PHN4DD@(EL@(B`B;&EB<F%R>2(@(B!<?"Y<?"Y<
M?"X@72(*+DQ0"B-I;F-L=61E(#QC9&LN:#X*+DQ0"BY"22`B0T1+5DE%5T52
M("IN97=#1$M6:65W97(@*$-$2U-#4D5%3B`J(B`B8V1K<V-R965N(BP*+D))
M(")I;G0@(B`B>'!O<R(L"BY"22`B:6YT("(@(GEP;W,B+`HN0DD@(FEN="`B
M(")H96EG:'0B+`HN0DD@(FEN="`B(")W:61T:"(L"BY"22`B8VAA<B`J*B(@
M(F)U='1O;DQI<W0B+`HN0DD@(FEN="`B(")B=71T;VY#;W5N="(L"BY"22`B
M8VAT>7!E("(@(F)U='1O;DAI9VAL:6=H="(L"BY"22`B8F]O;&5A;B`B(")B
M;W@B+`HN0DD@(F)O;VQE86X@(B`B<VAA9&]W(BD["BY,4`HN0DD@(FEN="!A
M8W1I=F%T94-$2U9I97=E<B`H0T1+5DE%5T52("HB(")V:65W97(B*3L*+DQ0
M"BY"22`B=F]I9"!S971#1$M6:65W97(@*$-$2U9)15=%4B`J(B`B=FEE=V5R
M(BP*+D))(")C:&%R("HB(")T:71L92(L"BY"22`B8VAA<B`J*B(@(FEN9F\B
M+`HN0DD@(FEN="`B(")I;F9O4VEZ92(L"BY"22`B8VAT>7!E("(@(F)U='1O
M;D%T=')I8G5T92(L"BY"22`B8F]O;&5A;B`B(")I;G1E<G!R970B+`HN0DD@
M(F)O;VQE86X@(B`B8F]X(BD["BY,4`HN0DD@(G9O:60@9')A=T-$2U9I97=E
M<B`H0T1+5DE%5T52("HB(")V:65W97(B+`HN0DD@(F)O;VQE86X@(B`B8F]X
M(BD["BY,4`HN0DD@(G9O:60@97)A<V5#1$M6:65W97(@*$-$2U9)15=%4B`J
M(B`B=FEE=V5R(BD["BY,4`HN0DD@(G9O:60@9&5S=')O>4-$2U9I97=E<B`H
M0T1+5DE%5T52("HB(")V:65W97(B*3L*+DQ0"BY"22`B=F]I9"!B:6YD0T1+
M3V)J96-T("A%3V)J96-T5'EP92`B(")W:61G9714>7!E(BP*+D))(")V;VED
M("HB(")O8FIE8W0B+`HN0DD@(F-H='EP92`B(")K97DB+`HN0DD@(D))3D1&
M3B`B(")F=6YC=&EO;B(L"BY"22`B=F]I9"`J(B`B9&%T82(I.PHN4T@@1$53
M0U))4%1)3TX*5&AE($-D:R!V:65W97(@=VED9V5T(&-R96%T97,@82!F:6QE
M('9I97=E<B!W:61G970N(%1H:7,@=VED9V5T(&%L;&]W<R!A('5S97(@"G1O
M(&EN=&5R86-T('=I=&@@82!F:6QE+B!)="!D;V5S(%QF-$Y/5%QF,2!A;&QO
M=R!E9&ET:6YG+"!T:&ES(&ES('9I97<@;VYL>2X@"E1H92!F;VQL;W=I;F<@
M87)E(&9U;F-T:6]N<R!W:&EC:"!C<F5A=&4@;W(@;6%N:7!U;&%T92!T:&4@
M0V1K('9I97=E<B!L:7-T(`IW:61G970N"@HN4T@@059!24Q!0DQ%($953D-4
M24].4PI#1$M6245715(@*FYE=T-$2U9I97=E<B`H0T1+4T-2145.("I<9C)S
M8W)E96Y<9C$L(&EN="!<9C)X<&]S7&8Q+"!I;G0@7&8R>7!O<UQF,2P@:6YT
M(%QF,FAE:6=H=%QF,2P@:6YT(%QF,G=I9'1H7&8Q+"!C:&%R("HJ7&8R8G5T
M=&]N<UQF,2P@:6YT(%QF,F)U='1O;D-O=6YT7&8Q+"!C:'1Y<&4@7&8R8G5T
M=&]N2&EG:&QI9VAT7&8Q+"!B;V]L96%N(%QF,F)O>%QF,2P@8F]O;&5A;B!<
M9C)S:&%D;W=<9C$I.PHN4E,@,PI4:&ES(&9U;F-T:6]N(&-R96%T97,@82!P
M;VEN=&5R('1O(&$@=FEE=V5R('=I9&=E="X@5&AE(%QF,G-C<F5E;EQF,2!P
M87)A;65T97(*:7,@=&AE('-C<F5E;B!Y;W4@=VES:"!T:&ES('=I9&=E="!T
M;R!B92!P;&%C960@:6XN(%1H92!P87)A;65T97(@7&8R>'!O<UQF,0IC;VYT
M<F]L<R!T:&4@<&QA8V5M96YT(&]F('1H92!O8FIE8W0@86QO;F<@=&AE(&AO
M<FEZ;VYT86P@87AI<RX@5&AI<R!P87)A;65T97(*8V%N(&%C8V5P="!A;B!I
M;G1E9V5R('9A;'5E(&]R(&]N92!O9B!T:&4@<')E+61E9FEN960@=F%L=65S
M(&]F(%QF-$Q%1E1<9C$L"EQF-%))1TA47&8Q+"!A;F0@7&8T0T5.5$527&8Q
M+B!4:&4@<&%R86UE=&5R(%QF,GEP;W-<9C$@8V]N=')O;',@=&AE('!L86-E
M;65N=`IO9B!T:&4@;V)J96-T(&%L;VYG('1H92!V97)T:6-A;"!A>&ES+B!4
M:&ES('!A<F%M971E<B!C86X@86-C97!T(&%N(&EN=&5G97(@"G9A;'5E(&]R
M(&]N92!O9B!T:&4@<')E+61E9FEN960@=F%L=65S(&]F(%QF-%1/4%QF,2P@
M7&8T0D]45$]-7&8Q+"!A;F0@7&8T0T5.5$527&8Q+@I4:&4@<&%R86UE=&5R
M<R!<9C)H96EG:'1<9C$@86YD(%QF,G=I9'1H7&8Q('-T871E(&AO=R!T86QL
M(&%N9"!W:61E('1H92!V:65W97(*=VEN9&]W(&ES('1O(&)E+B`@5&AE(%QF
M,F)U='1O;G-<9C$@:7,@86X@87)R87D@;V8@=&AE(&)U='1O;B!L86)E;',@
M=VAI8V@@87)E"G1O(&)E(&%T=&%C:&5D('1O('1H92!V:65W97(@;VX@=&AE
M(&)O='1O;3L@7&8R8G5T=&]N0V]U;G1<9C$@=&5L;',@=&AE('9I97=E<@IH
M;W<@;6%N>2!B=71T;VYS('1H97)E(&%R92X@5&AE('!A<F%M971E<B!<9C)B
M=71T;VY(:6=H;&EG:'1<9C$@:7,@=&AE(&AI9VAL:6=H=`IA='1R:6)U=&4@
M;V8@=&AE(&-U<G)E;G1L>2!S96QE8W1E9"!B=71T;VXN(%1H92!<9C)B;WA<
M9C$@<&%R86UE=&5R('-T871E<PIW:&5T:&5R('1H92!W:61G970@=VEL;"!B
M92!D<F%W;B!W:71H(&$@8F]X(&%R;W5N9"!I="!O<B!N;W0N(%1H92!<9C)S
M:&%D;W=<9C$*<&%R86UE=&5R(&%C8V5P=',@82!B;V]L96%N('9A;'5E('1O
M('1U<FX@=&AE('-H861O=R!O;B!O<B!O9F8@87)O=6YD('1H:7,@=VED9V5T
M+@I)9B!T:&4@=VED9V5T(&-O=6QD(&YO="!B92!C<F5A=&5D('1H96X@82!<
M9C1.54Q,7&8Q('!O:6YT97(@:7,@<F5T=7)N960N"BY210H*:6YT(&%C=&EV
M871E0T1+5FEE=V5R("A#1$M6245715(@*EQF,G9I97=E<EQF,2D["BY24R`S
M"E1H:7,@9G5N8W1I;VX@86-T:79A=&5S('1H92!V:65W97(@=VED9V5T(&%N
M9"!L971S('1H92!U<V5R(&EN=&5R86-T('=I=&@@=&AE"G=I9&=E="X@5&AE
M('!A<F%M971E<B!<9C)V:65W97)<9C$@:7,@82!P;VEN=&5R('1O(&$@;F]N
M+4Y53$P@=FEE=V5R('=I9&=E="X*268@=&AE(%QF,F%C=&EO;G-<9C$@<&%R
M86UE=&5R(&ES('!A<W-E9"!W:71H(&$@;F]N+4Y53$P@=F%L=64L('1H92!C
M:&%R86-T97)S"FEN('1H92!A<G)A>2!W:6QL(&)E(&EN:F5C=&5D(&EN=&\@
M=&AE('=I9&=E="X@5&\@86-T:79A=&4@=&AE('=I9&=E=`II;G1E<F%C=&EV
M96QY('!A<W,@:6X@82!<9C1.54Q,7&8Q('!O:6YT97(@9F]R(%QF,F%C=&EO
M;G-<9C$N($EF('1H92!C:&%R86-T97(@96YT97)E9`II;G1O('1H:7,@=VED
M9V5T(&ES(%QF-%)%5%523EQF,2!T:&5N('1H:7,@9G5N8W1I;VX@=VEL;"!R
M971U<FX@82!V86QU92!F<F]M"C`@=&\@=&AE(&YU;6)E<B!O9B!B=71T;VYS
M("TQ+"!R97!R97-E;G1I;F<@=&AE(&)U='1O;B!S96QE8W1E9"X@270@=VEL
M;"!A;'-O"G-E="!T:&4@<W1R=6-T=7)E(&UE;6)E<B!<9C1E>&ET5'EP95QF
M,2!T;R!<9C1V3D]234%,7&8Q+B!)9B!T:&4@8VAA<F%C=&5R"F5N=&5R960@
M:6YT;R!T:&ES('=I9&=E="!W87,@7&8T15-#05!%7&8Q('1H96X@=&AE('=I
M9&=E="!W:6QL(')E='5R;@IA('9A;'5E(&]F("TQ(&%N9"!T:&4@<W1R=6-T
M=7)E(&UE;6)E<B!<9C1E>&ET5'EP95QF,2!W:6QL(&)E('-E="!T;PI<9C1V
M15-#05!%7TA)5%QF,2X*+E)%"@IV;VED('-E=$-$2U9I97=E<B`H0T1+5DE%
M5T52("I<9C)V:65W97)<9C$L(&-H87(@*EQF,G1I=&QE7&8Q+"!C:&%R("HJ
M7&8R:6YF;UQF,2P@:6YT(%QF,FEN9F]3:7IE7&8Q+"!C:'1Y<&4@7&8R8G5T
M=&]N071T<FEB=71E7&8Q+"!B;V]L96%N(%QF,FEN=&5R<')E=%QF,2P@8F]O
M;&5A;B!<9C)B;WA<9C$I.PHN4E,@,PI4:&ES(&9U;F-T:6]N(&QE=',@=&AE
M('!R;V=R86UM97(@;6]D:69Y(&-E<G1A:6X@96QE;65N=',@;V8@86X@86QR
M96%D>2!D969I;F5D"G9I97=E<B!W:61G970N(%1H92!P87)A;65T97(@7&8R
M=&ET;&5<9C$@:7,@=&AE('1I=&QE('1O(&)E(&1I<W!L87EE9"!O;@IT:&4@
M=&]P(&]F('1H92!V:65W97(N(%1H92!P87)A;65T97(@7&8R:6YF;UQF,2!I
M<R!T:&4@:6YF;W)M871I;VX@=&\@9&ES<&QA>2P*=VAI;&4@7&8R:6YF;U-I
M>F5<9C$@<W1A=&5S(&AO=R!M86YY(')O=W,@=&AE<F4@87)E(&EN('1H92!<
M9C)I;F9O7&8Q(&%R<F%Y+@I4:&4@<&%R86UE=&5R(%QF,F)U='1O;D%T=')I
M8G5T95QF,2!S=&%T97,@=&AE(&%T=')I8G5T92!O9B!T:&4@8W5R<F5N=`IH
M:6=H;&EG:'1E9"!B=71T;VXN(%1H92!B;V]L96%N('!A<F%M971E<B!<9C)I
M;G1E<G!R971<9C$@=&5L;',@=&AE('9I97=E<B!T;R`*:6YT97)P<F5T('1H
M92!C;VYT96YT<R!O9B!<9C)I;F9O7&8Q(&9O<B!#9&L@9&ES<&QA>2!C;VUM
M86YD+"!O<B!N;W0N(%1H90IP87)A;65T97)S(%QF,F)O>%QF,2!A;F0@7&8R
M<VAA9&]W7&8Q(&%R92!T:&4@<V%M92!A<R!I;B!T:&4@9G5N8W1I;VX*9&5S
M8W)I<'1I;VX@;V8@7&8T;F5W0T1+5FEE=V5R7&8Q+@HN4D4*"G9O:60@9')A
M=T-$2U9I97=E<B`H0T1+5DE%5T52("I<9C)V:65W97)<9C$L(&)O;VQE86X@
M7&8R8F]X7&8Q*3L*+E)3(#,*5&AI<R!F=6YC=&EO;B!D<F%W<R!T:&4@=FEE
M=V5R('=I9&=E="!O;B!T:&4@<V-R965N+B!4:&4@7&8R8F]X7&8Q(&]P=&EO
M;B`*9')A=W,@=&AE('=I9&=E="!W:71H(&]R('=I=&AO=70@82!B;W@N"BY2
M10H*=F]I9"!E<F%S94-$2U9I97=E<B`H0T1+5DE%5T52("I<9C)V:65W97)<
M9C$I.PHN4E,@,PI4:&ES(&9U;F-T:6]N(')E;6]V97,@=&AE('=I9&=E="!F
M<F]M('1H92!S8W)E96XN(%1H:7,@9&]E<R!<9C1.3U1<9C$@9&5S=')O>0IT
M:&4@=VED9V5T+@HN4D4*"G9O:60@9&5S=')O>4-$2U9I97=E<B`H0T1+5DE%
M5T52("I<9C)V:65W97)<9C$I.PHN4E,@,PI4:&ES(&9U;F-T:6]N(')E;6]V
M97,@=&AE('=I9&=E="!F<F]M('1H92!S8W)E96X@86YD(&9R965S('5P(&%N
M>2!M96UO<GD@=&AE"F]B:F5C="!M87D@8F4@=7-I;F<N"BY210H*=F]I9"!B
M:6YD0T1+3V)J96-T("A%3V)J96-T5'EP92!<9C)W:61G9714>7!E7&8Q+"!V
M;VED("I<9C)O8FIE8W1<9C$L(&-H87(@7&8R:V5Y7&8Q+"!"24Y$1DX@7&8R
M9G5N8W1I;VY<9C$L('9O:60@*EQF,F1A=&%<9C$I.PHN4E,@,PI4:&ES(&9U
M;F-T:6]N(&%L;&]W<R!T:&4@=7-E<B!T;R!C<F5A=&4@<W!E8VEA;"!K97D@
M8FEN9&EN9W,N(%1H92`*7&8R=VED9V5T5'EP95QF,2!P87)A;65T97(@:7,@
M82!D969I;F5D('1Y<&4@=VAI8V@@<W1A=&5S('=H870@0V1K(&]B:F5C="`*
M='EP92!I<R!B96EN9R!U<V5D+B`@5&\@;&5A<FX@;6]R92!A8F]U="!T:&4@
M='EP92!<9C1%3V)J96-T5'EP95QF,2!R96%D(`IT:&4@7&8T8V1K7V)I;F1I
M;F=<9C$@;6%N=6%L('!A9V4N(%1H92!<9C)O8FIE8W1<9C$@<&%R86UE=&5R
M(&ES('1H92!P;VEN=&5R(`IT;R!T:&4@=VED9V5T(&]B:F5C="X@5&AE(%QF
M,FME>5QF,2!I<R!T:&4@8VAA<F%C=&5R('1O(&)I;F0N(%1H92`*7&8R9G5N
M8W1I;VY<9C$@:7,@=&AE(&9U;F-T:6]N('1Y<&4N(%1O(&QE87)N(&UO<F4@
M86)O=70@=&AE(&ME>2!B:6YD:6YG(`IC86QL+6)A8VL@9G5N8W1I;VX@='EP
M97,@<F5A9"!T:&4@7&8T8V1K7V)I;F1I;F=<9C$@;6%N=6%L('!A9V4N(%1H
M92!L87-T(`IP87)A;65T97(@7&8R9&%T85QF,2!I<R!A('!O:6YT97(@=&\@
M86YY(&1A=&$@=&AA="!N965D<R!T;R!G970@<&%S<V5D('1O(`IT:&4@8V%L
M;"UB86-K(&9U;F-T:6]N+@HN4D4*+E-(($M%62!"24Y$24Y'4PI7:&5N('1H
M92!W:61G970@:7,@86-T:79A=&5D('1H97)E(&%R92!S979E<F%L(&1E9F%U
M;'0@:V5Y(&)I;F1I;F=S('=H:6-H('=I;&P*:&5L<"!T:&4@=7-E<B!E;G1E
M<B!O<B!M86YI<'5L871E('1H92!I;F9O<FUA=&EO;B!Q=6EC:VQY+B!4:&4@
M9F]L;&]W:6YG('1A8FQE"F]U=&QI;F5S('1H92!K97ES(&%N9"!T:&5I<B!A
M8W1I;VYS(&9O<B!T:&ES('=I9&=E="X*+DQ0"BYN9@HN4E,@,PI<9C)+97D@
M("`@("`@("`@06-T:6]N7&8Q"DQE9G0@07)R;W<@(%-H:69T<R!T:&4@8V]N
M=&5N=',@;V8@=&AE"B`@("`@("`@("`@('9I97=E<B!O;F4@8VAA<F%C=&5R
M(&QE9G0N"E)I9VAT($%R<F]W(%-H:69T<R!T:&4@8V]N=&5N=',@;V8@=&AE
M"B`@("`@("`@("`@('9I97=E<B!O;F4@8VAA<F%C=&5R(&QE9G0*57`@07)R
M;W<@("`@4V-R;VQL<R!T:&4@8V]N=&5N=',@;V8@=&AE"B`@("`@("`@("`@
M('9I97=E<B!O;F4@;&EN92!U<"X*1&]W;B!!<G)O=R`@4V-R;VQL<R!T:&4@
M8V]N=&5N=',@;V8@=&AE"B`@("`@("`@("`@('9I97=E<B!O;F4@;&EN92!U
M<"X*4')E=B!086=E("`@36]V97,@;VYE('!A9V4@8F%C:W=A<F1S+@I#=')L
M+4(@("`@("!-;W9E<R!O;F4@<&%G92!B86-K=V%R9',N"D(@("`@("`@("`@
M($UO=F5S(&]N92!P86=E(&)A8VMW87)D<RX*8B`@("`@("`@("`@36]V97,@
M;VYE('!A9V4@8F%C:W=A<F1S+@I.97AT(%!A9V4@("!-;W9E<R!O;F4@<&%G
M92!F;W)W87)D<RX*0W1R;"U&("`@("`@36]V97,@;VYE('!A9V4@9F]R=V%R
M9',N"E-P86-E("`@("`@($UO=F5S(&]N92!P86=E(&9O<G=A<F1S+@I&("`@
M("`@("`@("!-;W9E<R!O;F4@<&%G92!F;W)W87)D<RX*9B`@("`@("`@("`@
M36]V97,@;VYE('!A9V4@9F]R=V%R9',N"DAO;64@("`@("`@(%-H:69T<R!T
M:&4@=VAO;&4@;&ES="!T;PH@("`@("`@("`@("!T:&4@9F%R(&QE9G0N"GP@
M("`@("`@("`@(%-H:69T<R!T:&4@=VAO;&4@;&ES="!T;PH@("`@("`@("`@
M("!T:&4@9F%R(&QE9G0N"D5N9"`@("`@("`@(%-H:69T<R!T:&4@=VAO;&4@
M;&ES="!T;PH@("`@("`@("`@("!T:&4@9F%R(')I9VAT"B0@("`@("`@("`@
M(%-H:69T<R!T:&4@=VAO;&4@;&ES="!T;PH@("`@("`@("`@("!T:&4@9F%R
M(')I9VAT+@IG("`@("`@("`@("!-;W9E<R!T;R!T:&4@9FER<W0@;&EN90H@
M("`@("`@("`@("!I;B!T:&4@=FEE=V5R+@HQ("`@("`@("`@("!-;W9E<R!T
M;R!T:&4@9FER<W0@;&EN90H@("`@("`@("`@("!I;B!T:&4@=FEE=V5R+@I'
M("`@("`@("`@("!-;W9E<R!T;R!T:&4@;&%S="!L:6YE"B`@("`@("`@("`@
M(&EN('1H92!V:65W97(N"DP@("`@("`@("`@($UO=F5S(&AA;&8@=&AE(&1I
M<W1A;F-E"B`@("`@("`@("`@('1O('1H92!E;F0@;V8@=&AE('9I97=E<BX*
M;"`@("`@("`@("`@36]V97,@:&%L9B!T:&4@9&ES=&%N8V4*("`@("`@("`@
M("`@=&\@=&AE('1O<"!O9B!T:&4@=FEE=V5R+@H_("`@("`@("`@("!396%R
M8VAE<R!U<"!F;W(@82!P871T97)N+@HO("`@("`@("`@("!396%R8VAE<R!D
M;W=N(&9O<B!A('!A='1E<FXN"FX@("`@("`@("`@(%)E<&5A=',@;&%S="!S
M96%R8V@N"CH@("`@("`@("`@($IU;7!S('1O(&$@9VEV96X@;&EN92X*:2`@
M("`@("`@("`@1&ES<&QA>7,@9FEL92!S=&%T:7-T:6-S+@IS("`@("`@("`@
M("!$:7-P;&%Y<R!F:6QE('-T871I<W1I8W,N"E1A8B`@("`@("`@(%-W:71C
M:&5S(&)U='1O;G,N"E)E='5R;B`@("`@($5X:71S('1H92!W:61G970@86YD
M(')E='5R;G,*("`@("`@("`@("`@86X@:6YT96=E<B!V86QU92!R97!R97-E
M;G1I;F<*("`@("`@("`@("`@=VAI8V@@8G5T=&]N('=A<R!S96QE8W1E9"X@
M5&AI<PH@("`@("`@("`@("!A;'-O('-E=',@=&AE('-T<G5C='5R92!M96UB
M97(*("`@("`@("`@("`@7&8T97AI=%1Y<&5<9C$@:6X@=&AE('=I9&=E="!P
M;VEN=&5R"B`@("`@("`@("`@('1O('1H92!V86QU92!O9B!<9C1V3D]234%,
M7&8Q+@I%<V-A<&4@("`@("!%>&ET<R!T:&4@=VED9V5T(&%N9"!R971U<FYS
M("TQ+@H@("`@("`@("`@("!4:&ES(&%L<V\@<V5T<R!T:&4@<W1R=6-T=7)E
M"B`@("`@("`@("`@(&UE;6)E<B!<9C1E>&ET5'EP95QF,2!I;B!T:&4*("`@
M("`@("`@("`@=VED9V5T('!O:6YT97(@=&\@=&AE('9A;'5E(&]F(`H@("`@
M("`@("`@("!<9C1V15-#05!%7TA)5%QF,2X*0W1R;"U,("`@("`@4F5F<F5S
M:&5S('1H92!S8W)E96XN"BY210HN9FD*+E-((%-%12!!3%-/"BY"4B!C9&L@
M*#-8*2P*+D)2(&-D:U]B:6YD:6YG("@S6"DL"BY"4B!C9&M?9&ES<&QA>2`H
M,U@I+`HN0E(@8V1K7W-C<F5E;B`H,U@I"BY32"!.3U1%4PHN4%`*5&AE(&AE
M861E<B!F:6QE(%QF-#QC9&LN:#Y<9C$@875T;VUA=&EC86QL>2!I;F-L=61E
M<R!T:&4@:&5A9&5R(&9I;&5S"EQF-#QC=7)S97,N:#Y<9C$L(%QF-#QS=&1L
M:6(N:#Y<9C$L(%QF-#QS=')I;F<N:#Y<9C$L(%QF-#QC='EP92YH/EQF,2P*
M7&8T/'5N:7-T9"YH/EQF,2P@7&8T/&1I<F5N="YH/EQF,2P@7&8T/'1I;64N
M:#Y<9C$L(%QF-#QE<G)N;RYH/EQF,2P*7&8T/'!W9"YH/EQF,2P@7&8T/&=R
M<"YH/EQF,2P@7&8T/'-Y<R]S=&%T+F@^7&8Q+"!A;F0@7&8T/'-Y<R]T>7!E
M<RYH/EQF,2X*5&AE(%QF-#QC=7)S97,N:#Y<9C$@:&5A9&5R(&9I;&4@:6YC
M;'5D97,@7&8T/'-T9&EO+F@^7&8Q(&%N9"!<9C0\=6YC=')L+F@^7&8Q+@HN
M4%`*268@>6]U(&AA=F4@7&8T3F-U<G-E<UQF,2!I;G-T86QL960@;VX@>6]U
M<B!M86-H:6YE(&%D9"`M1$Y#55)315,@=&\@=&AE(`IC;VUP:6QE(&QI;F4@
M=&\@:6YC;'5D92!T:&4@3F-U<G-E<R!H96%D97(@9FEL97,@:6YS=&5A9"X*
`
end
SHAR_EOF
  echo 'uudecoding file cdk4.8.0/man/viewer.3' &&
  uudecode _sharuue.tmp < _sharuue.tmp && rm -f _sharuue.tmp &&
  $shar_touch -am 0709111596 'cdk4.8.0/man/viewer.3' &&
  chmod 0444 'cdk4.8.0/man/viewer.3' ||
  echo 'restore of cdk4.8.0/man/viewer.3 failed'
  shar_count="`wc -c < 'cdk4.8.0/man/viewer.3'`"
  test 8730 -eq "$shar_count" ||
    echo "cdk4.8.0/man/viewer.3: original size 8730, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk4.8.0/man/cdk.3 ==============
if test -f 'cdk4.8.0/man/cdk.3' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk4.8.0/man/cdk.3 (file already exists)'
  rm -f _sharnew..tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk4.8.0/man/cdk.3 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk4.8.0/man/cdk.3' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH Cdk 3 "05 Dec 1995"
X.SH NAME
X   Cdk - \f2Curses Development Kit\f1
X.LP
X.SH SYNOPSIS
X.LP
X.B cc
X.RI "[ " "flag" " \|.\|.\|. ] " "file" " \|.\|.\|."
X.B \-lcdk
X.RI "[ " "library" " \|.\|.\|. ]"
X.LP
#include <cdk.h>
X.LP
Cdk provides functions to use a large number of pre-defined
curses widgets. To use the Cdk widgets the header file \f4cdk.h\f1 must be 
included in the source.
X.LP
The widgets available from Cdk are listed below.
X
X.RS 3
X.nf
\f2Widget_Type                 Manual_Page_Name\f1
Alphalist                   cdk_alphalist (3)
Calendar                    cdk_calendar (3)
Dialog                      cdk_dialog (3)
Entry Field                 cdk_entry (3)
File Viewer                 cdk_viewer (3)
Graph                       cdk_graph (3)
Histogram                   cdk_histogram (3)
Item List                   cdk_itemlist (3)
Label                       cdk_label (3)
Marquee                     cdk_marquee (3)
Matrix                      cdk_matrix (3)
Multiple Line Entry Field   cdk_mentry (3)
Numeric Scale               cdk_scale (3)
Numeric Slider              cdk_slider (3)
Pulldown Menu               cdk_menu (3)
Radio List                  cdk_radio (3)
Scrolling List              cdk_scroll (3)
Scrolling Selection List    cdk_selection (3)
Scrolling Window            cdk_swindow (3)
Numeric Slider              cdk_slider (3)
Template                    cdk_template (3)
X.RE
X
The rest of the manual pages are
X.RS 3
\f2Manual_Page_Name            Description\f1
cdk_binding (3)             Outlines how to create user
X                            definable key bindings.
cdk_display (3)             Shows how to add special display
X                            attributes, colors, and justification
X                            into a widget.
cdk_draw (3)                Outlines the basic drawing 
X                            capabilities of Cdk.
cdk_screen (3)              Demonstrates the use of screens  
X                            within Cdk.
cdk_misc (3)                Outlines miscellaneous functions
X                            provided with the Cdk library.
cdk_process (3)             Demonstrates the use of the pre 
X                            and post process function class.
X.RE
X.fi
X
X.SH DESCRIPTION
Cdk is a library of functions which allow a programmer to quickly create a 
full screen interactive program with ease. The Cdk widgets support the 
following features:
X.It "\(bu Ncurses library." 5
Instead of using the standard curses library, Cdk can take advantage of the
colors that Ncurses provides. To learn how to take advantage of Cdk's color
capabilities, read the \f4cdk_display\f1 manual page.
X.PP
X.It "\(bu Key Bindings." 5
Individual keys can be overridden with a call-back. The call-back is set up using
the \f4bindCDKObject\f1 function. To learn more about this read the
\f4cdk_binding\f1 manual page.
X.PP
X.It "\(bu Pre and Post Processing." 5
Certain widgets allow the user to trap a character before and after the 
character has been applied to the widget. This allows programmers to 'filter'
character input. To learn more about this read the \f4cdk_process\f1 manual
page.
X.PP
X.It "\(bu Self Test Widgets." 5
With the use of the inject function class and the activate function, 
programmers can have the widgets test themselves. This allows the programmer
to perform automated tests on a final program.
X.PP
X.It "\(bu Special Display Formats" 5
There are special character format commands that can be inserted into any 
string in Cdk and the contents will get mapped to a \f4chtype\f1 (see the
curses manual page) with character attributes. This allows the programmer to 
insert format types on each character if they wish.
X.PP
X.It "\(bu The Ability To Build Predefined Screens" 5
Widgets can be associated to any given screen. If there is more than one 
screen defined, then Cdk has the ability to "flip" from one screen to another
with ease. See the \f4cdk_screen\f1 manual page for more details.
X.PP
X
X.SH STANDARD WIDGET BEHAVIOR
All of the widgets have a member of the structure called \f4exitType\f1. This
member states how the widget exited. There are three values in which to check
for, they are as follows:
X.nf
X.RS 3
X
\f2Value            Meaning\f1
vNORMAL          This means the widget exited normally. This 
X                 value is set when the widget is given the 
X                 characters TAB or RETURN.
vEARLY_EXIT      This means the widget exited early. This value
X                 is set when characters are injected into the 
X                 widget via the injectCDKXXX function and the 
X                 character injected does not exit the widget.
X                 (ie: TAB or RETURN)
vESCAPE_HIT      This value states the user hit ESCAPE to 
X                 leave the widget.
vNEVER_ACTIVATED This is the initial state of the value. This 
X                 means that the widget has not been activated.
X
X.SH SEE ALSO
X.BR cdk (3),
X.BR cdk_binding (3),
X.BR cdk_display (3),
X.BR cdk_screen (3)
X.SH NOTES
X.PP
The header file \f4<cdk.h>\f1 automatically includes the header files
\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
The \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
X.PP
If you have \f4Ncurses\f1 installed on your machine add -DNCURSES to the 
compile line to include the Ncurses header files instead.
SHAR_EOF
  $shar_touch -am 0709111596 'cdk4.8.0/man/cdk.3' &&
  chmod 0444 'cdk4.8.0/man/cdk.3' ||
  echo 'restore of cdk4.8.0/man/cdk.3 failed'
  shar_count="`wc -c < 'cdk4.8.0/man/cdk.3'`"
  test 5563 -eq "$shar_count" ||
    echo "cdk4.8.0/man/cdk.3: original size 5563, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk4.8.0/man/screen.3 ==============
if test -f 'cdk4.8.0/man/screen.3' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk4.8.0/man/screen.3 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk4.8.0/man/screen.3 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk4.8.0/man/screen.3' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH cdk_screen 3X "05 Dec 1995"
X.SH NAME
initCDKScreen, initCDKColor, registerCDKObject, unregisterCDKObject,
raiseCDKObject, lowerCDKObject, refreshCDKScreen, eraseCDKScreen,
destroyCDKScreen, endCDK - Cdk Screen and Widget Manipulation Functions
X.SH SYNOPSIS
X.LP
X.B cc
X.RI "[ " "flag" " \|.\|.\|. ] " "file" " \|.\|.\|."
X.B \-lcdk
X.RI "[ " "library" " \|.\|.\|. ]"
X.LP
#include <cdk.h>
X.LP
X.BI "CDKSCREEN *initCDKScreen (WINDOW *" "cursesWindow ");
X.LP
X.BI "void initCDKColor ()";
X.LP
X.BI "void registerCDKObject (CDKSCREEN *" "screen ",
X.BI "EObjectType " "widgetType ",
X.BI "void *" "object");
X.LP
X.BI "void unregisterCDKObject(EObjectType " "widgetType ",
X.BI "void *" "object");
X.LP
X.BI "void raiseCDKObject(EObjectType " "widgetType ",
X.BI "void *" "object");
X.LP
X.BI "void lowerCDKObject(EObjectType " "widgetType ",
X.BI "void *" "object");
X.LP
X.BI "void refreshCDKScreen(CDKSCREEN *" "screen");
X.LP
X.BI "void eraseCDKScreen(CDKSCREEN *" "screen");
X.LP
X.BI "void destroyCDKScreen(CDKSCREEN *" "screen");
X.LP
X.BI "void endCDK()";
X.LP
X.SH DESCRIPTION
One of the features of Cdk is that it will manage all of the widgets for you.
These functions perform some of the management of the widgets in a screen. The
following outline each function and it's purpose.
X
X.SH AVAILABLE FUNCTIONS
CDKSCREEN *initCDKScreen (WINDOW *\f2cursesWindow\f1);
X.RS 3
This function takes a \f4WINDOW *\f1 (\f2cursesWindow\f1) and returns a 
pointer to a \f4CDKSCREEN *\f1. Since all of the widgets take a 
\f4CDKSCREEN\f1 pointer as a first argument, this is also one of the first 
calls made. This also starts curses, so no curses initialization calls have 
to be made when using Cdk.
X.RE
X
void initCDKColor ();
X.RS 3
This call starts the Cdk color capabilities. It defines 64 color pairs each
of which is accessible using the COLOR_PAIR macro. If you do not have color
support, this function call makes no difference.
X.RE
X
void registerCDKObject (CDKSCREEN *\f2screen\f1, EObjectType \f2widgetType\f1, void *\f2object\f1);
X.RS 3
This function is called automatically when a widget is created. If for some
reason an object does get unregistered, by calling \f4unregisterCDKObject\f1, 
the widget can be registered again by calling this function. The 
\f2widgetType\f1 parameter states what Cdk widget type this object is. The 
\f2object\f1 parameter is a void pointer to the object.
X.RE
X
void unregisterCDKObject (EObjectType \f2cdktype\f1, void *\f2object\f1);
X.RS 3
This function removes the widget from the screen. This does \f4NOT\f1 destroy 
the object, it removes the widget from any further refreshes by the function
\f4refreshCDKScreen\f1. The \f2widgetType\f1 parameter states what Cdk widget
type this object is. The \f2object\f1 parameter is a void pointer to the 
object.
X.RE
X
void raiseCDKObject (EObjectType \f2cdktype\f1, void *\f2object\f1);
X.RS 3
This function raises the widget to the top of the screen. If there are any 
widgets which overlap the given object when a refresh is done, calling this
function has the effect of raiding the object so no other widgets obstruct 
it. The \f2widgetType\f1 parameter states what Cdk widget type this object is.
The \f2object\f1 parameter is a void pointer to the object.
X.RE
X
void lowerCDKObject (EObjectType \f2cdktype\f1, void *\f2object\f1);
X.RS
This function has the opposite effect of the \f4raiseCDKObject\f1 function
call.
X.RE
X
void refreshCDKScreen (CDKSCREEN *\f2screen\f1);
X.RS 3
This function redraws all of the widgets which are currently associated to the
given screen.
X.RE
X
void eraseCDKScreen (CDKSCREEN *\f2screen\f1);
X.RS 3
This function erases all of the widgets which are currently associated to the
given screen. This does \f4NOT\f1 destroy the widgets.
X.RE
X
void destroyCDKScreen (CDKSCREEN *\f2screen\f1);
X.RS 3
This function destroys any memory allocated by the Cdk screen pointer.
X.RE
X
void endCDK();
X.RS 3
This function cleans up any memory created by starting Cdk and shuts down 
curses.
X.RE
X.SH SEE ALSO
X.BR cdk (3X),
X.BR cdk_binding (3X),
X.BR cdk_display (3X)
X.SH NOTES
X.PP
The header file \f4<cdk.h>\f1 automatically includes the header files
\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
The \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
X.PP
If you have \f4Ncurses\f1 installed on your machine add -DNCURSES to the 
compile line to include the Ncurses header files instead.
SHAR_EOF
  $shar_touch -am 0709111596 'cdk4.8.0/man/screen.3' &&
  chmod 0444 'cdk4.8.0/man/screen.3' ||
  echo 'restore of cdk4.8.0/man/screen.3 failed'
  shar_count="`wc -c < 'cdk4.8.0/man/screen.3'`"
  test 4609 -eq "$shar_count" ||
    echo "cdk4.8.0/man/screen.3: original size 4609, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk4.8.0/man/binding.3 ==============
if test -f 'cdk4.8.0/man/binding.3' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk4.8.0/man/binding.3 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk4.8.0/man/binding.3 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk4.8.0/man/binding.3' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH cdk_display 3 "05 Dec 1995"
X.SH NAME
bindCDKObject, unbindCDKObject, checkCDKObjectBind, cleanCDKObjectBindings -
\f2Curses Development Kit\f1 Character Binding Capabilities.
X.LP
X.SH SYNOPSIS
X.LP
X.B cc
X.RI "[ " "flag" " \|.\|.\|. ] " "file" " \|.\|.\|."
X.B \-lcdk
X.RI "[ " "library" " \|.\|.\|. ]"
X.LP
#include <cdk.h>
X.LP
X.BI "void bindCDKObject (EObjectType" "cdkType",
X.BI "void *" "object",
X.BI "chtype " "key",
X.BI "BINDFN " "function",
X.BI "void *" "data");
X.LP
X.BI "void unbindCDKObject (EObjectType " "cdkType",
X.BI "void *" "object",
X.BI "chtype " "key");
X.LP
X.BI "void checkCDKObjectBind (EObjectType " "cdkType",
X.BI "void *" "object",
X.BI "chtype " "key");
X.LP
X.BI "void cleanCDKObjectBindings (EObjectType " "cdkType",
X.BI "void *" "object");
X.LP
X.SH DESCRIPTION
Cdk has the ability to create user definable key bindings. This ability makes
Cdk more dynamic and usable for a wide variety of tasks. The following section
outlines the binding functions, their use, and their purpose.
X
void bindCDKObject (EObjectType \f2cdkType\f1, void *\f2object\f1, chtype \f2key\f1, BINDFN \f2function\f1, void *\f2data\f1);
X.RS 3
This function creates a key binding between a specific Cdk widget (\f2object\f1)
given key (\f2key\f1). The parameter \f2cdkType\f1 is of type \f4EObjectType\f1
which is one of the following values.
X.LP
X.nf
\f2EObjectType_Value   Corresponding_Widget         Widget_Manual_Page\f1
vALPHALIST          Alphalist Widget             cdk_alphalist (3)
vCALENDAR           Calendar Widget              cdk_calendar (3)
vDIALOG             Dialog Widget                cdk_dialog (3)
vENTRY              Entry Widget                 cdk_entry (3)
vFSELECT            File Selector Widget         cdk_fselect (3)
vGRAPH              Graph Widget                 cdk_graph (3)
vHISTOGRAM          Histogram Widget             cdk_histogram (3)
vITEMLIST           Item List Widget             cdk_itemlist (3)
vLABEL              Label Widget                 cdk_label (3)
vMARQUEE            Marquee Widget               cdk_marquee (3)
vMATRIX             Matrix Widget                cdk_matrix (3)
vMENTRY             Multiple Line Entry Widget   cdk_mentry (3)
vMENU               Menu Widget                  cdk_menu (3)
vRADIO              Radio List Widget            cdk_radio (3)
vSCALE              Numeric Scale Widget         cdk_scale (3)
vSCROLL             Scrolling List Widget        cdk_scroll (3)
vSELECTION          Selection List Widget        cdk_selection (3)
vSLIDER             Slider Widget                cdk_slider (3)
vSWINDOW            Scrolling Window Widget      cdk_swindow (3)
vTEMPLATE           Template Entry Widget        cdk_template (3)
vVIEWER             Viewer Widget                cdk_viewer (3)
X.fi
X.RS 3
The parameter \f2function\f1 is of type \f4BINDFN\f1 which has the following
prototype:
X.RE
X
X.ce
\f4void function (EObjectType cdktype, void *object, void *clientData);\f1
X
X.RS 3
The parameter \f2data\f1 is a \f4void *\f1 pointer to whatever data the call-back
function may need.
X.RE 
X
void unbindCDKObject (EObjectType \f2cdkType\f1, void *\f2object\f1, chtype \f2key\f1);
X.RS 3
This function removes a specific binding to an object. The parameter names are
the same as the description of the function \f4bindCDKObject\f1.
X.RE
X
int checkCDKObjectBind (EObjectType \f2cdkType\f1, void *\f2object\f1, chtype \f2key\f1);
X.RS 3
This function returns an integer value stating whether the key \f2key\f1 has
been bound to the given widget, \f2object\f1.
X.RE
X
void cleanCDKObjectBindings (EObjectType \f2cdkType\f1, void *\f2object\f1);
X.RS 3
This function removes all user defined key bindings from the given widget.
X.RE
X
X.SH EXAMPLE
To help demonstrate how to use the key bindings I will demonstrate a simple
dialog box widget with help for each button. The following code segment creates
a dialog box and a call-back function named \f4dialogHelpCB\f1.
X.LP
X.nf
X.ce
\f4________________________________________\f1
X.LP
#include "cdk.h"
X
void dialogHelpCB (EObjectType cdktype, void *object, void *clientData)
{
X   CDKDIALOG *dialog = (CDKDIALOG *)object;
X   char *mesg[5];
X
X   /* Check which button we are on.		*/
X   if (dialog->currentButton == 0)
X   {
X      mesg[0] = "<C></U>Help for </U>Who<!U>.";
X      mesg[1] = "<C>When this button is picked the name of the current";
X      mesg[2] = "<C>user is displayed on the screen in a pop-up window.";
X      popupLabel (dialog->screen, mesg, 3);
X   }
X   else if (dialog->currentButton == 1)
X   {
X      mesg[0] = "<C></U>Help for </U>Time<!U>.";
X      mesg[1] = "<C>When this button is picked the current time is";
X      mesg[2] = "<C>displayed on the screen in a pop-up window.";
X      popupLabel (dialog->screen, mesg, 3);
X   }
X   else if (dialog->currentButton == 2)
X   {
X      mesg[0] = "<C></U>Help for </U>Date<!U>.";
X      mesg[1] = "<C>When this button is picked the current date is";
X      mesg[2] = "<C>displayed on the screen in a pop-up window.";
X      popupLabel (dialog->screen, mesg, 3);
X   }
X   else if (dialog->currentButton == 3)
X   {
X      mesg[0] = "<C></U>Help for </U>Quit<!U>.";
X      mesg[1] = "<C>When this button is picked the dialog box is exited.";
X      popupLabel (dialog->screen, mesg, 2);
X   }
}
X
void main()
{
X   /* Declare variables.			*/
X   CDKSCREEN	*cdkscreen;
X   CDKDIALOG	*question;
X   WINDOW	*cursesWin;
X   char		*buttons[40];
X   char		*message[40], *info[5], *loginName;
X   char		temp[256];
X   int		selection;
X   int		x;
X   time_t	clck;
X   struct tm	*currentTime;
X
X   /* Set up CDK 				*/ 
X   cursesWin = initscr();
X   cdkscreen = initCDKScreen (cursesWin);
X
X   /* Start color.              		*/
X   initCDKColor();
X
X   /* Set up the dialog box.			*/
X   message[0] = "<C></U>Simple Command Interface";
X   message[1] = "Pick the command you wish to run.";
X   message[2] = "<C>Press </R>?<!R> for help.";
X   buttons[0] = "Who";
X   buttons[1] = "Time";
X   buttons[2] = "Date";
X   buttons[3] = "Quit";
X
X   /* Create the dialog box.			*/
X   question	= newCDKDialog (cdkscreen, CENTER, CENTER,
X				message, 3, buttons, 4, A_REVERSE,
X				TRUE, TRUE, FALSE);
X
X   /* Check if we got a null value back.	*/
X   if (question == (CDKDIALOG *)NULL)
X   {
X      destroyCDKScreen (cdkscreen);
X
X      /* End curses...				*/
X      endCDK();
X
X      /* Spit out a message.			*/
X      printf ("Oops. Can't seem to create the dialog box. Is the window too small?\n");
X      exit (1);
X   }
X
X   /* Create the key binding.			*/
X   bindCDKObject (vDIALOG, question, '?', dialogHelpCB, NULL);
X
X   /* Activate the dialog box.			*/
X   selection = 0;
X   while (selection != 3)
X   {
X      /* Get the users button selection.	*/
X      selection = activateCDKDialog (question, (chtype *)NULL);
X
X      /* Check the results.			*/
X      if (selection == 0)
X      {
X         /* Get the users login name.		*/
X         info[0] = "<C>     </U>Login Name<!U>     ";
X         loginName = getlogin();
X         if (loginName == (char *)NULL)
X         {
X            info[1] = "<C></R>Unknown";
X         }
X         else
X         {
X             sprintf (temp, "<C><%s>", loginName); info[1] = strdup (temp);
X         }
X         popupLabel (question->screen, info, 2);
X         free (info[1]);
X      }
X      else if (selection == 1)
X      {
X         /* Print out the time.			*/
X         time(&clck);
X         currentTime = localtime(&clck);
X         sprintf (temp, "<C>%d:%d:%d", currentTime->tm_hour,
X					currentTime->tm_min,
X					currentTime->tm_sec);
X         info[0] = "<C>   </U>Current Time<!U>   ";
X         info[1] = strdup (temp);
X         popupLabel (question->screen, info, 2);
X         free (info[1]);
X      }
X      else if (selection == 2)
X      {
X         /* Print out the date.			*/
X         time(&clck);
X         currentTime = localtime(&clck);
X         sprintf (temp, "<C>%d/%d/%d", currentTime->tm_mday,
X					currentTime->tm_mon,
X					currentTime->tm_year);
X         info[0] = "<C>   </U>Current Date<!U>   ";
X         info[1] = strdup (temp);
X         popupLabel (question->screen, info, 2);
X         free (info[1]);
X      }
X   }
X
X   /* Clean up					*/
X   destroyCDKDialog (question);
X   destroyCDKScreen (cdkscreen);
X   endCDK();
X   delwin (cursesWin);
}
X.fi
X.ce
\f4________________________________________\f1
X
X.SH SEE ALSO
X.BR cdk (3),
X.BR cdk_display (3),
X.BR cdk_screen (3)
X.SH NOTES
The header file \f4<cdk.h>\f1 automatically includes the header files
\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
The \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
SHAR_EOF
  $shar_touch -am 0709111596 'cdk4.8.0/man/binding.3' &&
  chmod 0444 'cdk4.8.0/man/binding.3' ||
  echo 'restore of cdk4.8.0/man/binding.3 failed'
  shar_count="`wc -c < 'cdk4.8.0/man/binding.3'`"
  test 8742 -eq "$shar_count" ||
    echo "cdk4.8.0/man/binding.3: original size 8742, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk4.8.0/man/display.3 ==============
if test -f 'cdk4.8.0/man/display.3' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk4.8.0/man/display.3 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk4.8.0/man/display.3 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk4.8.0/man/display.3' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH cdk_display 3X "05 Dec 1995"
X.SH NAME
X   Cdk - \f2Curses Development Kit\f1 Display Capabilities.
X.LP
X.SH SYNOPSIS
Cdk has a number of pre-defined display types which need explaining. This
manual page will explain all of the display types and how to use them. The
following lists which display types will be outlined in this manual page.
X.It "\(bu How To Use Colors" 5
X.It "\(bu How To Use Different Character Attributes" 5
X.It "\(bu How To Justify Strings" 5
X.It "\(bu How To Use Special Drawing Characters" 5
X.SH DESCRIPTION
Cdk has special formatting commands which can be included in any string which
add highlights, justification, or even colors to a basic string. This manual
page outlines and demonstrates how they work. 
X.PP
\f2How To Use Colors\f1
X.RS 3
Cdk has the capability to display colors in almost every string type displayed
in a Cdk widget. To turn on colors, the function \f4initCDKColor\f1 has to be
called. When this function is called 64 color pairs are created. Normally the
color pairs are accessed via the COLOR_PAIR macro. You can still do this, but
creating a string with multiple colors gets terribly difficult. That is why
the color commands were created. The color setting are stored directly in the
string and when the widget is created or activated, the string is converted
to take advantage of any color commands in the string. To turn on a color pair
insert </XX> into the string; where \f4XX\f1 is a numeric value from 0 to 64.
Color pair 0 is the standard default color pair for the screen. To turn off a
color pair use the format command <!XX> where \f4XX\f1 is a numeric value from
0 to 64. The following code segment demonstrates the use of the color commands.
X.LP
X.nf
X.ce
\f4----------------------------------------\f1
#include <cdk.h>
X
void main()
{
X   CDKSCREEN	*cdkscreen;
X   CDKLABEL	*demo;
X   WINDOW 	*screen;
X   char		*mesg[4];
X
X   /* Initialize the Cdk screen.	*/
X   screen = initscr();
X   cdkscreen = initCDKScreen (screen);
X
X   /* Set the labels up.		*/
X   mesg[0] = "</1>This line should have a yellow foreground and a blue background.<!1>";
X   mesg[1] = "</2>This line should have a white  foreground and a blue background.<!2>";
X   mesg[2] = "</3>This line should have a yellow foreground and a red  background.<!3>";
X   mesg[3] = "<C>This line should be set to whatever the screen default is.";
X
X   /* Declare the labels.	*/
X   demo	= newCDKLabel (cdkscreen, CENTER, CENTER, mesg, 4, TRUE, TRUE);
X
X   /* Draw the label		*/
X   drawCDKLabel (demo, TRUE);
X   waitCDKLabel (demo, ' ');
X
X   /* Clean up			*/
X   destroyCDKLabel (demo);
X   destroyCDKScreen (cdkscreen);
X   endCDK();
X   exit (0);
}
X.fi
X.ce
\f4----------------------------------------\f1
This example uses the color pair 5 (which is white on blue) for the label to
the entry widget.
X.RE
X.PP
\f2How To Use Different Character Attributes\f1
X.RS 3
Cdk also provides attribute commands which allow different character attributes
to be displayed in a Cdk widget. To use a character attribute the format command
is </X> where \f4X\f1 is one of several command characters. To turn a attribute 
off use the command <!X>. The following table outlines the command characters
and what they mean.
X.LP
X.nf 
X.RS 3
\f2Command_Character      Character_Attribute\f1
B                      Bold 
U                      Underline
K                      Blink
R                      Reverse
S                      Standout
D                      Dim
N                      Normal
X.fi
X.RE
X
The following code segment demonstrates the use of character display attributes.
X.nf
X.ce 
\f4----------------------------------------\f1
#include <cdk.h>
X
void main()
{
X   CDKSCREEN	*cdkscreen;
X   CDKLABEL	*demo;
X   WINDOW	*screen;
X   char		*mesg[4];
X
X   /* Initialize the Cdk screen.	*/
X   screen = initscr();
X   cdkscreen = initCDKScreen (screen);
X
X   /* Set the labels up.		*/
X   mesg[0] = "</B/1>This line should have a yellow foreground and a blue background.<!1>";
X   mesg[1] = "</U/2>This line should have a white  foreground and a blue background.<!2>";
X   mesg[2] = "</K/3>This line should have a yellow foreground and a red  background.<!3>";
X   mesg[3] = "<C>This line should be set to whatever the screen default is.";
X
X   /* Declare the labels.	*/
X   demo	= newCDKLabel (cdkscreen, CENTER, CENTER, mesg, 4, TRUE, TRUE);
X
X   /* Draw the label		*/
X   drawCDKLabel (demo, TRUE);
X   waitCDKLabel (demo, ' ');
X
X   /* Clean up			*/
X   destroyCDKLabel (demo);
X   destroyCDKScreen (cdkscreen);
X   endCDK();
X   exit (0);
}
X.ce
\f4----------------------------------------\f1
X.fi
Notice that color commands and format commands can be mixed inside the same
format marker. The above example underlines the label marker, which also sets
color pair number 5.
X.RE
X.PP
\f2How To Justify Strings\f1
X.RS 3
Justification commands can left justify, right justify, or center a string of 
text. To use a justification format in a string the command <X> is used. The 
following table lists all of the format commands available.
X.LP
X.nf
X.RS 3
\f2Justification_Command    Action.\f1
<L>                      Left Justified. Default if not stated.
<C>                      Centered text.
<R>                      Right justified.
<I=X>                    Indent the line X characters.
<B=X>                    Bullet. X is the bullet string to use.
<F=X>                    Links in a file where X is the filename. 
X                         Currently only works with the viewer 
X                         widget.
X.fi
X.RE
X.fi
X
The following code segment demonstrates how to use the justification commands
in a Cdk widget.
X.ce
\f4----------------------------------------\f1
X.nf
#include <cdk.h>
X
void main()
{
X   CDKSCREEN	*cdkscreen;
X   CDKLABEL	*demo;
X   WINDOW	*screen;
X   char		*mesg[4];
X
X   /* Initialize the Cdk screen.	*/
X   screen = initscr();
X   cdkscreen = initCDKScreen (screen);
X
X   /* Set the labels up.		*/
X   mesg[0] = "<R></B/1>This line should have a yellow foreground and a blue background.<!1>";
X   mesg[1] = "</U/2>This line should have a white  foreground and a blue background.<!2>";
X   mesg[2] = "<B=+>This is a bullet.";
X   mesg[3] = "<I=10>This is indented 10 characters.";
X   mesg[4] = "<C>This line should be set to whatever the screen default is.";
X
X   /* Declare the labels.	*/
X   demo	= newCDKLabel (cdkscreen, CENTER, CENTER, mesg, 5, TRUE, TRUE);
X
X   /* Draw the label		*/
X   drawCDKLabel (demo, TRUE);
X   waitCDKLabel (demo, ' ');
X
X   /* Clean up			*/
X   destroyCDKLabel (demo);
X   destroyCDKScreen (cdkscreen);
X   endCDK();
X   exit (0);
}
X.fi
X.ce
\f4----------------------------------------\f1
The bullet format command can take either a single character or a string.
The bullet in the the above example would look like
X.RS 3
\f4+\f1 This is a bullet.
X.RE
but if we were to use the following command instead
X.ce
<B=***>This is a bullet.
it would look like
X.RS 3
\f4***\f1 This is a bullet.
X.RE
X
The only restriction that a format command has is that it must be at the
beginning of the string.
X.RE
X.PP
\f2How To Use Special Drawing Characters\f1
X.RS 3
Cdk has a set of special drawing characters which can be inserted into any
ASCII file. In order to use a special character the format command <#XXX>
is used. The following table lists all of the special character commands
available.
X.LP
X.RS 3
X.nf 
\f2Special_Character   Character\f1
<#UL>               Upper Left Corner
<#UR>               Upper Right Corner
<#LL>               Lower Left Corner
<#LR>               Lower Right Corner
<#LT>               Left Tee
<#RT>               Right Tee
<#TT>               Top Tee
<#BT>               Bottom Tee
<#HL>               Horizontal Line
<#VL>               Vertical Line
<#PL>               Plus Sign
<#PM>               Plus/Minus Sign
<#DG>               Degree Sign
<#CB>               Checker Board
<#DI>               Diamond
<#BU>               Bullet
X.RE
X.fi
X.LP
The character formats can be repeated using an optional numeric repeat value.
To repeat a character add (XXX) to the end of the character format. The 
following example, draws 10 horizontal lines.
X.LP
<#HL(10)>
X.LP
The following code segment draws a box within a label window.
X.ce
\f4----------------------------------------\f1
X.nf
#include "cdk.h"
X
void main()
{
X   /* Declare variables.	*/
X   CDKSCREEN	*cdkscreen;
X   CDKLABEL	*demo;
X   WINDOW 	*cursesWin;
X   char		*mesg[4];
X
X   /* Set up CDK 		*/ 
X   cursesWin = initscr();
X   cdkscreen = initCDKScreen (cursesWin);
X
X   /* Start CDK Colors		*/
X   initCDKColor();
X
X   /* Set the labels up.	*/
X   mesg[0] = "<C><#UL><#HL(25)><#UR>";
X   mesg[1] = "<C><#VL></R>This text should be boxed.<!R><#VL>";
X   mesg[2] = "<C><#LL><#HL(25)><#LR>";
X   mesg[3] = "<C>While this is not.";
X
X   /* Declare the labels.	*/
X   demo	= newCDKLabel (cdkscreen, CENTER, CENTER, mesg, 4, TRUE, TRUE);
X
X   /* Is the label NULL???	*/
X   if (demo == (CDKLABEL *)NULL)
X   {
X      /* Clean up the memory.	*/
X      destroyCDKScreen (cdkscreen);
X
X      /* End curses...		*/
X      endCDK();
X
X      /* Spit out a message.	*/
X      printf ("Oops. Can't seem to create the label. Is the window too small?\n");
X      exit (1);
X   }
X
X   /* Draw the CDK screen.	*/
X   refreshCDKScreen (cdkscreen);
X   waitCDKLabel (demo, ' ');
X
X   /* Clean up			*/
X   destroyCDKLabel (demo);
X   destroyCDKScreen (cdkscreen);
X   delwin (cursesWin);
X   endCDK();
X   exit (0);
}
X.fi
X.ce
\f4----------------------------------------\f1
X.LP
Notice that drawn text can also be justified.
X.LP
X.SH SEE ALSO
X.BR cdk (3X),
X.BR cdk_binding (3X),
X.BR cdk_screen (3X)
X.SH NOTES
The header file \f4<cdk.h>\f1 automatically includes the header files
\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
The \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
SHAR_EOF
  $shar_touch -am 0709111596 'cdk4.8.0/man/display.3' &&
  chmod 0444 'cdk4.8.0/man/display.3' ||
  echo 'restore of cdk4.8.0/man/display.3 failed'
  shar_count="`wc -c < 'cdk4.8.0/man/display.3'`"
  test 9965 -eq "$shar_count" ||
    echo "cdk4.8.0/man/display.3: original size 9965, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk4.8.0/man/misc.3 ==============
if test -f 'cdk4.8.0/man/misc.3' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk4.8.0/man/misc.3 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk4.8.0/man/misc.3 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk4.8.0/man/misc.3' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH cdk_misc 3X "28 June 1996"
X.SH NAME
X   Cdk - \f2Curses Development Kit\f1 Miscellaneous Routines
X.LP
X.SH SYNOPSIS
X.LP
X.B cc
X.RI "[ " "flag" " \|.\|.\|. ] " "file" " \|.\|.\|."
X.B \-lcdk
X.RI "[ " "library" " \|.\|.\|. ]"
X.LP
#include <cdk.h>
X.LP
X.BI "void Beep()" "";
X.LP
X.BI "char * baseName (char *" "pathname");
X.LP
X.BI "chtype * char2Chtype (char *" "string",
X.BI "int *" "length",
X.BI "int *" "align");
X.LP
X.BI "int chlen (chtype *" "string");
X.LP
X.BI "char *chtype2Char (chtype *" "string");
X.LP
X.BI "void cleanChar (char *" "string",
X.BI "int " "length",
X.BI "char " "character");
X.LP
X.BI "void cleanChtype (chtype *" "string",
X.BI "int " "length",
X.BI "chtype " "character");
X.LP
X.BI "char *copyChar (char *" "string");
X.LP
X.BI "chtype *copyChtype (chtype *" "string");
X.LP
X.BI "void freeChar (char *" "string");
X.LP
X.BI "void freeChtype (chtype *" "string");
X.LP
X.BI "int getDirectoryContents (char *" "directory",
X.BI "char **" "list",
X.BI "int " "maxListSize");
X.LP
X.BI "int intlen (int " "value");
X.LP
X.BI "int mode2Char (char *" "string",
X.BI "mode_t " "fileMode");
X.LP
X.BI "int popupDialog (CDKSCREEN *" "screen",
X.BI "char **" "mesg",
X.BI "int " "mesgCount",
X.BI "char **" "buttons",
X.BI "int " "buttonCount");
X.LP
X.BI "void popupLabel (CDKSCREEN *" "win",
X.BI "char **" "mesg",
X.BI "int " "count");
X.LP
X.BI "void quickSort (char **", "list",
X.BI "int " "left",
X.BI "int " "right");
X.LP
X.BI "int readFile (char *" "filename",
X.BI "char **" "info",
X.BI "int " "maxlines");
X.LP
X.BI "int searchList (char **" "list",
X.BI "int " "listSize",
X.BI "char *" "pattern");
X.LP
X.BI "void stripWhiteSpace (EStripType " "stripType",
X.BI "char *" "string");
X.LP
X.BI "int splitString (char *" "string",
X.BI "char **" "items",
X.BI "char " "splitChar");
X.LP
X.SH DESCRIPTION
The functions provided in this manual page are miscellaneous functions 
which may be required when using the Cdk widget set.
X
X.SH AVAILABLE FUNCTIONS
void Beep();
X.RS 3
This function makes an audible beep. The difference between this one and
the \f4beep\f1 function in the curses library is this one flushes the STDOUT
stream.
X.RE
X
char *baseName (char *\f2pathname\f1);
X.RS 3
This function returns a pointer to the first character of the filename in
the given pathname.
X.RE
X
chtype *char2Chtype (char *\f2string\f1, int *\f2length\f1, int *\f2align\f1);
X.RS 3
This function takes a string in the form of "</X/Y>Blah Blah" and returns
a chtype * of the correct type. The \f2length\f1 parameter is the length of
the chtype * and the \f2align\f1 parameter contains justification information.
X.RE
X
int chlen (chtype *\f2string\f1);
X.RS 3
This function returns the length of the chtype * given.
X.RE
X
char *chtype2Char (chtype *\f2string\f1);
X.RS 3
This function takes a chtype * and returns the equivalent char *.
X.RE
X
void cleanChar (char *\f2string\f1, int \f2length\f1, char \f2character\f1);
X.RS 3
This function is analogous to \f4bzero\f1 or \f4memcopy\f1. The \f2length\f1
parameter states how many characters to write, and \f2character\f1 is the
character which will be written.
X.RE
X
void cleanChtype (chtype *\f2string\f1, int \f2length\f1, chtype \f2character\f1);
X.RS 3
This function is analogous to \f4bzero\f1 or \f4memcopy\f1. The \f2length\f1
parameter states how many characters to write, and \f2character\f1 is the
character which will be written.
X.RE
X
char *copyChar (char *\f2string\f1);
X.RS 3
This function copies the string passed in. It is safer than \f4strdup\f1 because
it checks to see if the string is NULL before copying, and it forces a NULL
character on the end of the string after the copy is complete.
X.RE
X
chtype *copyChtype (chtype *\f2string\f1);
X.RS 3
This function copies the string passed in. It is safer than \f4strdup\f1 because
it checks to see if the string is NULL before copying, and it forces a NULL
character on the end of the string after the copy is complete.
X.RE
X
void freeChar (char *\f2string\f1);
X.RS 3
This function is safer to use than \f4free\f1. It checks to see if the string
is NULL before trying to free the string.
X.RE
X
void freeChtype (chtype *\f2string\f1);
X.RS 3
This function is safer to use than \f4free\f1. It checks to see if the string
is NULL before trying to free the string.
X.RE
X
int getDirectoryContents (char *\f2directory\f1, char **\f2list\f1, int \f2maxListSize\f1);
X.RS 3
This function opens and reads the contents of the given directory. It fills
the array \f2list\f1 with the sorted contents of the directory, and the parameter
\f2maxListSize\f1 states how many entries the array can hold. This function returns
the number of files read. If the directory could not be opened then it returns
a value of -1.
X.RE
X
int intlen (int \f2value\f1);
X.RS 3
This function returns the length of an integer value.
X.RE
X
int mode2Char (char *\f2string\f1, mode_t \f2fileMode\f1);
X.RS 3
This function takes the file-mode in the \f2fileMode\f1 parameter and returns
the octal equivalent. The \f2string\f1 parameter is a character string
of the permissions. (The string looks like the permissions of a file when the
command ls -l has been run on the file.)
X.RE
X
int popupDialog (CDKSCREEN *\f2screen\f1, char **\f2mesg\f1, int \f2mesgCount\f1, char **\f2buttons\f1, int \f2buttonCount\f1);
X.RS 3
This function creates a quick pop-up dialog box. Pass in the message in the
\f2mesg\f1 parameter, the size of the message in the \f2mesgCount\f1 parameter,
the button labels in the \f2buttons\f1 parameter and the number of buttons in
the \f2buttonCount\f1 parameter. The dialog box will be centered on the screen.
X.RE
X
void popupLabel (CDKSCREEN *\f2win\f1, char **\f2mesg\f1, int \f2count\f1);
X.RS 3
This function creates a quick pop-up label widget. The message and the size of
the message are passed in via the \f2mesg\f1 and \f2count\f1 parameters respectively.
The label widget will wait until the user hits a character and will be centered
on the screen.
X.RE
X
void quickSort (char **\f2list\f1, int \f2left\f1, int \f2right\f1);
X.RS 3
This function performs a quick sort of the given list. The list will be sorted
alphabetically in increasing order.
X.RE
X
int readFile (char *\f2filename\f1, char **\f2info\f1, int \f2maxlines\f1);
X.RS 3
This function reads the contents of the given file and stores the contents
in the \f2info\f1 parameter. The \f2maxlines\f1 parameter states how many lines
can be stored in the \f2info\f1 array. This function returns the number of lines
read if the file could be opened, -1 otherwise.
X.RE
X
int searchList (char **\f2list\f1, int \f2listSize\f1, char *\f2pattern\f1);
X.RS 3
This function searches the array \f2list\f1 checking to see if each element 
in the array starts with the given \f2pattern\f1. This function returns the
index of the first match or -1 if it can't find one.
X.RE
X
void stripWhiteSpace (EStripType \f2stripType\f1, char *\f2string\f1);
X.RS 3
This function strips the leading/trailing white space off of the given
string. The parameter \f2stripType\f1 takes the following values.
X.LP
X.RS 3
X.nf 
\f2Strip_Type      Result\f1
vFRONT          This tells the function to remove
X                all of the white space from the 
X                front of the given string.
vBACK           This tells the function to remove 
X                all of the white space from the 
X                back of the given string.
vBOTH           This tells the function to remove 
X                all of the white space from both 
X                the front and the back of the given
X                string.
X.fi
X.RE
X.RE
X
int splitString (char *\f2string\f1, char **\f2items\f1, char \f2splitChar\f1);
X.RS 3
This function splits the given \f2string\f1 into parts based on the split 
character in \f2splitChar\f1. The array \f2items\f1 will contain each individual
segment. The value returned is the number of segments created from the given
string.
X.RE
X
X.SH SEE ALSO
X.BR cdk (3X),
X.BR cdk_screen (3X),
X.BR cdk_display (3X),
X.BR cdk_binding (3X)
X.SH NOTES
X.PP
The header file \f4<cdk.h>\f1 automatically includes the header files
\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
The \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
X.PP
If you have \f4Ncurses\f1 installed on your machine add -DNCURSES to the 
compile line to include the Ncurses header files instead.
SHAR_EOF
  $shar_touch -am 0709111596 'cdk4.8.0/man/misc.3' &&
  chmod 0444 'cdk4.8.0/man/misc.3' ||
  echo 'restore of cdk4.8.0/man/misc.3 failed'
  shar_count="`wc -c < 'cdk4.8.0/man/misc.3'`"
  test 8484 -eq "$shar_count" ||
    echo "cdk4.8.0/man/misc.3: original size 8484, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk4.8.0/draw.c ==============
if test -f 'cdk4.8.0/draw.c' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk4.8.0/draw.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk4.8.0/draw.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk4.8.0/draw.c' &&
#include "cdk.h"
X
/*
X * $Author: glover $
X * $Date: 1996/07/03 18:32:50 $
X * $Revision: 1.20 $
X */
X
/*
X * This sets up a basic set of color pairs. These can be redefined
X * if wanted...
X */
void initCDKColor ()
{
#ifdef COLOR
X   /* Declare local variables.					*/
X   int color[]	= {
X			COLOR_WHITE,	COLOR_RED,	COLOR_GREEN,
X			COLOR_YELLOW,	COLOR_BLUE,	COLOR_MAGENTA,
X			COLOR_CYAN,	COLOR_BLACK
X		};
X   int pair	= 1;
X   int x, y;
X
X   /* Start color first.					*/
X   start_color();
X  
X   /* Create the color pairs.					*/
X   for (x=0; x < 8; x++)
X   {
X      for (y=0; y < 8; y++)
X      {
X         init_pair (pair++, color[x], color[y]);
X      }
X   }
#endif
}
X
/*
X * This prints out a box around a window with attributes
X */
void boxWindow (WINDOW *window, chtype attr)
{
X   /* Set some variables.					*/
X   int tlx	= 0;
X   int tly	= 0;
X   int brx	= window->_maxx - 1;
X   int bry	= window->_maxy;
X   int x, y;
X
X   /* Draw horizontal lines 					*/
X   for (x=tlx; x<=brx;x++) 
X   {
X       mvwaddch(window, tly, x, ACS_HLINE | attr);
X       mvwaddch(window, bry, x, ACS_HLINE | attr);
X    }
X
X   /* Draw vertical lines 					*/
X   for (y=tly; y<=bry;y++) 
X   {
X       mvwaddch(window, y, tlx, ACS_VLINE | attr);
X       mvwaddch(window, y, brx, ACS_VLINE | attr);
X    }
X
X   /* Draw in the corners */
X   mvwaddch(window, tly, tlx, ACS_ULCORNER | attr);
X   mvwaddch(window, tly, brx, ACS_URCORNER | attr);
X   mvwaddch(window, bry, tlx, ACS_LLCORNER | attr);
X   mvwaddch(window, bry, brx, ACS_LRCORNER | attr);
X   wrefresh(window);
}
X
/*
X * This draws a box with attributes and lets the user define
X * each element of the box.
X */
void attrbox (WINDOW *win, chtype tlc, chtype trc, chtype blc, chtype brc, chtype horz, chtype vert, chtype attr)
{
X   /* Set the coordinates.	*/
X   int x1		= 0;
X   int y1		= 0;
#ifdef OLDCURSES
X   int y2		= win->_maxy;
X   int x2		= win->_maxx;
#else
X   int y2		= win->_maxy - 1;
X   int x2		= win->_maxx - 1;
#endif
X   int x, y;
X
X   /* Draw horizontal lines.	*/
X   for (x=x1; x<=x2;x++) 
X   {
X       mvwaddch(win, y1, x, horz | attr);
X       mvwaddch(win, y2, x, horz | attr);
X    }
X
X   /* Draw vertical lines.	*/
X   for (y=y1; y<=y2;y++) 
X   {
X       mvwaddch(win, y, x1, vert | attr);
X       mvwaddch(win, y, x2, vert | attr);
X    }
X
X   /* Draw in the corners.	*/
X   mvwaddch(win, y1, x1, tlc | attr);
X   mvwaddch(win, y1, x2, trc | attr);
X   mvwaddch(win, y2, x1, blc | attr);
X   mvwaddch(win, y2, x2, brc | attr);
X   wrefresh(win);
}
X
/*
X * This draws a line on the given window. (odd angle lines not working yet)
X */
void drawLine  (WINDOW *window, int startx, int starty, int endx, int endy, chtype line)
{
X   /* De=clare some local vars.	*/
X   int xdiff	= endx - startx;
X   int ydiff	= endy - starty;
X   int x	= 0;
X   int y	= 0;
X
X   /* Determine if we are drawing a horizontal or vertical line.	*/
X   if ( ydiff == 0)
X   {
X      /* Horizontal line.      <--------- X -------->			*/
X      for (x=0; x < xdiff ; x++)
X      {
X         mvwaddch (window, starty, startx + x, line);
X      }
X   }
X   else if (xdiff == 0)
X   {
X      /* Vertical line.							*/
X      for (y=0; y < ydiff ; y++)
X      {
X         mvwaddch (window, starty + y, startx, line);
X      }
X   }
X   else
X   {
X      /* We need to determine the angle of the line.	*/
X      int height	= xdiff;
X      int width		= ydiff;
X      int xratio	= (height > width ? 1 : (width / height));
X      int yratio	= (width > height ? (width / height) : 1);
X      int xadj		= 0;
X      int yadj		= 0;
X  
X      /* Set the vars.	*/
X      x	= startx;
X      y	= starty;
X      while (x != endx && y != endy)
X      {
X
X         /* Add the char to the window.		*/
X         mvwaddch (window, y, x, line);
X
X         /* Make the x and y adjustments.	*/
X         if (xadj != xratio)
X         {
X            x	= (xdiff < 0 ? x-1 : x+1);
X            xadj++;
X         }
X         else
X         {
X            xadj	= 0;
X         }
X         if (yadj != yratio)
X         {
X            y	= (ydiff < 0 ? y-1 : y+1);
X            yadj++;
X         }
X         else
X         {
X            yadj	= 0;
X         }
X      }
X   }
}
X
/*
X * This draws a shadow around a window.
X */
void drawShadow (WINDOW *shadowwin)
{
X   /* Declare local variables.					*/
X   int x		= 0;
X
X   /* Draw the line on the bottom.				*/
X   for (x=1; x <= shadowwin->_maxx; x++)
X   {
X      mvwaddch (shadowwin, shadowwin->_maxy, x, ACS_HLINE | A_DIM);
X   }
X
X   /* Draw the line on the right.				*/
X   for (x=0; x < shadowwin->_maxy; x++)
X   {
X      mvwaddch (shadowwin, x, shadowwin->_maxx, ACS_VLINE |A_DIM);
X   }
X   mvwaddch (shadowwin, 0, shadowwin->_maxx, ACS_URCORNER | A_DIM);
X   mvwaddch (shadowwin, shadowwin->_maxy, 0, ACS_LLCORNER | A_DIM);
X   mvwaddch (shadowwin, shadowwin->_maxy, shadowwin->_maxx, ACS_LRCORNER | A_DIM);
X   wrefresh (shadowwin);
}
X
/*
X * This writes out a char * string with no attributes.
X */
void writeChar (WINDOW *window, int xpos, int ypos, char *string, int align, int start, int end)
{
X   /* Declare local variables.					*/
X   int display		= end - start;
X   int x		= 0;
X
X   /* Check the alignment of the message.			*/
X   if (align == HORIZONTAL)
X   { 
X      display = MINIMUM(display,window->_maxx-1);
X      for (x=0; x < display ; x++)
X      {
X         /* Draw the message on a horizontal axis.		*/
X         mvwaddch (window, ypos, xpos+x, string[x+start] | A_NORMAL);
X      }
X   }
X   else
X   {
X      /* Draw the message on a vertical axis.			*/
X      display = MINIMUM(display,window->_maxy-1);
X      for (x=0; x < display ; x++)
X      {
X         mvwaddch (window, ypos+x, xpos, string[x+start] | A_NORMAL);
X      }
X   }
}
X
/*
X * This writes out a char * string with attributes.
X */
void writeCharAttrib (WINDOW *window, int xpos, int ypos, char *string, chtype attr, int align, int start, int end)
{
X   /* Declare local variables.					*/
X   int display		= end - start;
X   int x		= 0;
X
X   /* Check the alignment of the message.			*/
X   if (align == HORIZONTAL)
X   { 
X      /* Draw the message on a horizontal axis.			*/
X      display		= MINIMUM(display,window->_maxx-1);
X      for (x=0; x < display ; x++)
X      {
X         mvwaddch (window, ypos, xpos+x, string[x+start] | attr);
X      }
X   }
X   else
X   {
X      /* Draw the message on a vertical axis.			*/
X      display		= MINIMUM(display,window->_maxy-1);
X      for (x=0; x < display ; x++)
X      {
X         mvwaddch (window, ypos+x, xpos, string[x+start] | attr);
X      }
X   }
}
X
/*
X * This writes out a chtype * string.
X */
void writeChtype (WINDOW *window, int xpos, int ypos, chtype *string, int align, int start, int end)
{
X   /* Declare local variables.					*/
X   int diff		= 0;
X   int display		= 0;
X   int x		= 0;
X
X   /* Determine how much we need to display.			*/
X   if ( end >= start)
X   {
X      diff	= end - start;
X   }
X
X   /* Check the alignment of the message.			*/
X   if (align == HORIZONTAL)
X   {
X      /* Draw the message on a horizontal axis. 		*/
X      display		= MINIMUM(diff,window->_maxx-1);
X      for (x=0; x < display; x++)
X      {
X         mvwaddch (window, ypos, xpos+x, string[x+start]);
X      }
X   }
X   else
X   {
X      /* Draw the message on a vertical axis.			*/
X      display		= MINIMUM(diff,window->_maxy-1);
X      for (x=0; x < display; x++)
X      {
X         mvwaddch (window, ypos+x, xpos, string[x+start]);
X      }
X   }
}
X
/*
X * This writes out a chtype * string forcing the chtype string
X * to be printed out with the given attributes instead.
X */
void writeChtypeAttrib (WINDOW *window, int xpos, int ypos, chtype *string, chtype attr, int align, int start, int end)
{
X   /* Declare local variables.					*/
X   int diff		= 0;
X   int display		= 0;
X   int x		= 0;
X   chtype plain;
X
X   /* Determine how much we need to display.			*/
X   if ( end >= start)
X   {
X      diff	= end - start;
X   }
X
X   /* Check the alignment of the message.			*/
X   if (align == HORIZONTAL)
X   {
X      /* Draw the message on a horizontal axis. 		*/
X      display		= MINIMUM(diff,window->_maxx-1);
X      for (x=0; x < display; x++)
X      {
X         plain	= string[x+start] & A_CHARTEXT;
X         mvwaddch (window, ypos, xpos+x, plain | attr);
X      }
X   }
X   else
X   {
X      /* Draw the message on a vertical axis.			*/
X      display		= MINIMUM(diff,window->_maxy-1);
X      for (x=0; x < display; x++)
X      {
X         plain	= string[x+start] & A_CHARTEXT;
X         mvwaddch (window, ypos+x, xpos, plain | attr);
X      }
X   }
}
X
/*
X * This pops up a message.
X */
void popupLabel (CDKSCREEN *screen, char **mesg, int count)
{
X   /* Declare local variables.					*/
X   CDKLABEL	*popup;
X
X   /* Create the label.						*/
X   popup = newCDKLabel (screen, CENTER, CENTER, mesg, count, TRUE, FALSE);
X
X   /* Draw it on the screen.					*/
X   drawCDKLabel (popup, TRUE);
X
X   /* Wait for some input.					*/
X   keypad (popup->win, TRUE);
X   wgetch (popup->win);
X
X   /* Kill it.							*/
X   destroyCDKLabel (popup);
X
X   /* Clean the screen.						*/
X   refreshCDKScreen (screen);
}
X
/*
X * This pops up a dialog box.
X */
int popupDialog (CDKSCREEN *screen, char **mesg, int mesgCount, char **buttons, int buttonCount)
{
X   /* Declare local variables.					*/
X   CDKDIALOG	*popup;
X   int choice;
X
X   /* Create the dialog box.					*/
X   popup = newCDKDialog (screen, CENTER, CENTER,
X				mesg, mesgCount, buttons, buttonCount,
X				A_REVERSE, TRUE, TRUE, FALSE);
X
X   choice = activateCDKDialog (popup, NULL);
X   destroyCDKDialog (popup);
X   return choice;
}
SHAR_EOF
  $shar_touch -am 0709111596 'cdk4.8.0/draw.c' &&
  chmod 0444 'cdk4.8.0/draw.c' ||
  echo 'restore of cdk4.8.0/draw.c failed'
  shar_count="`wc -c < 'cdk4.8.0/draw.c'`"
  test 9340 -eq "$shar_count" ||
    echo "cdk4.8.0/draw.c: original size 9340, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk4.8.0/cdk.c ==============
if test -f 'cdk4.8.0/cdk.c' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk4.8.0/cdk.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk4.8.0/cdk.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk4.8.0/cdk.c' &&
#include "cdk.h"
X
/*
X * $Author: glover $
X * $Date: 1996/07/05 14:30:45 $
X * $Revision: 1.120 $
X */
X
/*
X * As much as I hate to do this, I need to define a global char * pointer.
X * This is for the injectCDKXXX routines which return a char * type. Since
X * returning a NULL pointer is acceptable, this is the only other solution.
X */
char *GCdkObjects[] = {"ENTRY", "MENTRY", "LABEL", "SCROLL", "DIALOG", \
X			"SCALE", "MARQUEE", "MENU", "MATRIX", "HISTOGRAM", \
X			"SELECTION", "VIEWER", "GRAPH", "RADIO", "TEMPLATE", \
X			"SWINDOW", "ITEMLIST", "FSELECT", "SLIDER", \
X			"ALPHALIST", "CALENDAR"};
char *GPasteBuffer = (char *)NULL;
X
/* This beeps then flushes the stdout stream.			*/
void Beep()
{
X   beep();
X   fflush (stdout);
}
X
/* This is my 'own' version of bzero.				*/
void cleanChar (char *s, int len, char character)
{
X   int x;
X   for (x=0; x < len; x++)
X   {
X      s[x] = character;
X   }
X   s[--x] = '\0';
}
void cleanChtype (chtype *s, int len, chtype character)
{
X   int x;
X   for (x=0; x < len; x++)
X   {
X      s[x] = character;
X   }
X   s[--x] = '\0';
}
X
/*
X * This takes an x and y position and realigns the values iff they sent in
X * values like CENTER, LEFT, RIGHT, ...
X */
void alignxy (WINDOW *window, int *xpos, int *ypos, int boxwidth, int boxheight)
{
X   /* Justify the X position, if we need to.			*/
X   if ((*xpos) == LEFT)
X   {
X      (*xpos) = window->_begy + 1;
X   }
X   else if ((*xpos) == RIGHT)
X   {
X      (*xpos) = (window->_maxx - boxwidth) + window->_begy - 1;
X   }
X   else if ((*xpos) == CENTER)
X   {
X      (*xpos) = (int)(((window->_maxx)-boxwidth) / 2) + window->_begy;
X   }
X   else
X   {
X      /* If we have gone out of bounds, then readjust.		*/
X      if (((*xpos) + boxwidth) > window->_maxx)
X      {
X         (*xpos) = (window->_maxx - boxwidth);
X      }
X      else if ((*xpos) < 0)
X      {
X         (*xpos) = window->_begy + 1;
X      }
X   }
X
X   /* Justify the Y position, if we need to.			*/
X   if ((*ypos) == TOP)
X   {
X      (*ypos) = window->_begx + 1;
X   }
X   else if ((*ypos) == BOTTOM)
X   {
X      (*ypos) = (window->_maxy) - boxheight + window->_begx - 1;
X   }
X   else if ((*ypos) == CENTER)
X   {
X      (*ypos) = (int)((window->_maxy - boxheight) / 2) + window->_begx;
X   }
X   else
X   {
X      /* If we have gone out of bounds, then readjust		*/
X      if (((*ypos) + boxheight) > window->_maxy)
X      {
X         (*ypos) = (window->_maxy - boxheight);
X      }
X      else if ((*ypos) < 0)
X      {
X         (*ypos) = window->_begx + 1;
X      }
X   }
}
X
/*
X * This creates the x and y offset values given the location and size of the
X * given label for the object.
X */
void alignlabel (char *label, int lplace, int fieldwidth, int *boxwidth, int *boxheight, int *labelxoffset, int *labelyoffset, int *fieldxoffset, int *fieldyoffset)
{
X   /* Declare local variables.					*/
X   int labelLength = (int)strlen (label);
X
X   /* Set the offset values.					*/
X   if (lplace == LEFT)
X   { 
X      (*boxwidth)	= fieldwidth + labelLength + 3;
X      (*labelxoffset)	= 1;
X      (*labelyoffset)	= 1;
X      (*fieldxoffset)	= labelLength + 2;
X      (*fieldyoffset)	= 1;
X   }
X   else if (lplace == RIGHT)
X   {
X      (*boxwidth)	= fieldwidth + labelLength + 3;
X      (*labelxoffset)	= ((*boxwidth) - labelLength - 1);
X      (*labelyoffset)	= 1;
X      (*fieldxoffset)	= 1;
X      (*fieldyoffset)	= 1;
X   }
X   else if (lplace == TOP)
X   {
X      (*boxwidth)	= (fieldwidth < labelLength ? labelLength : fieldwidth);
X      (*boxwidth)	+= 3;
X      (*boxheight)	= (*boxheight) + 1;
X      (*labelxoffset)	= (int) (((*boxwidth)-labelLength)/2);
X      (*labelyoffset)	= 1;
X      (*fieldyoffset)	= 2;
X      (*fieldxoffset)	= 1;
X   }
X   else if (lplace == BOTTOM)
X   {
X      (*boxwidth)	= (fieldwidth < labelLength ? labelLength : fieldwidth) + 3;
X      (*boxheight)	= (*boxheight) + 1;
X      (*labelxoffset)	= (int) (((*boxwidth)-labelLength)/2);
X      (*labelyoffset)	= (*boxheight)-2;
X      (*fieldxoffset)	= 1;
X      (*fieldyoffset)	= 1;
X   }
X   else
X   {
X     /*
X      * Give me something I don't understand and I 
X      * will choose a default for you ie: LEFT
X      */
X      (*boxwidth)	= fieldwidth + labelLength + 3;
X      (*labelxoffset)	= 1;
X      (*labelyoffset)	= 1;
X      (*fieldxoffset)	= labelLength + 2;
X      (*fieldyoffset)	= 1;
X   }
}
X
/*
X * This takes a string, a field width and a justifycation type
X * and returns the justifcation adjustment to make, to fill
X * the justification requirement.
X */
int justifyMessage (int width, char *mesg, int justify)
{
X   int mesglen = (int)strlen (mesg);
X
X   /* Make sure the message isn't longer than the width.	*/
X   /* If it is, return 0.					*/
X   if (mesglen >= width)
X   {
X      return (0);
X   }
X
X   /* Try to justify the message.				*/
X   if (justify == LEFT)
X   {
X      return (1);
X   }
X   else if (justify == RIGHT)
X   {
X      return ((width - mesglen));
X   }
X   else if (justify == CENTER)
X   {
X      return ((int)((width - mesglen) / 2));
X   }
X   else
X   {
X      return (justify);
X   }
}
int justifyString (int boxWidth, int mesgLength, int justify)
{
X   /* Make sure the message isn't longer than the width.	*/
X   /* If it is, return 1.					*/
X   if (mesgLength >= boxWidth)
X   {
X      return (1);
X   }
X
X   /* Try to justify the message.				*/
X   if (justify == LEFT)
X   {
X      return (1);
X   }
X   else if (justify == RIGHT)
X   {
X      return ((boxWidth - mesgLength - 1));
X   }
X   else if (justify == CENTER)
X   {
X      return ((int)((boxWidth - mesgLength) / 2));
X   }
X   else
X   {
X      return (justify);
X   }
}
X
/*
X * This returns a substring of the given string.
X */
char *substring(char *string, int start, int width)
{
X   char *newstring	= (char *)NULL;
X   int mesglen		= (strlen (string));
X   int y		= 0;
X   int x		= 0;
X   int lastchar		= 0;
X
X   if (start > mesglen)
X   {
X      return (newstring);
X   }
X
X   newstring	= (char *)malloc (sizeof (char) * (width+3));
X   cleanChar (newstring, width+3, '\0');
X   if ((start+width) > mesglen)
X   {
X      lastchar = mesglen;
X   }
X   else
X   {
X      lastchar = width + start;
X   }
X
X   for (x=start; x<=lastchar; x++)
X   {
X      newstring[y++] = string[x];
X   }
X   return (newstring);
}
X
/*
X * This frees a string if it is not null. This is a safety
X * measure. Some compilers let you free a null string. I
X * don't like that idea.
X */
void freeChar (char *string)
{
X   if (string != (char *)NULL)
X   {
X      free (string);
X   }
}
void freeChtype (chtype *string)
{
X   if (string != (chtype *)NULL)
X   {
X      free (string);
X   }
}
X
/*
X * This performs a safe copy of a string. This means it adds the NULL
X * terminator on the end of the string.
X */
char *copyChar (char *original)
{
X   /* Declare local variables.					*/
X   char *newstring;
X   int len;
X
X   /* Make sure the string is not NULL.				*/
X   if (original == (char *)NULL)
X   {
X      return (char *)NULL;
X   }
X
X   /* Create the new string.					*/
X   len		= (int)strlen (original);
X   newstring	= (char *)malloc (sizeof(char) * (len+3));
X   cleanChar (newstring, len+3, '\0');
X
X   /* Copy from one to the other...				*/
X   strcpy (newstring, original);
X
X   /* Return the new string.					*/
X   return (newstring);
}
chtype *copyChtype (chtype *original)
{
X   /* Declare local variables.					*/
X   chtype *newstring;
X   int len, x;
X
X   /* Make sure the string is not NULL.				*/
X   if (original == (chtype *)NULL)
X   {
X      return (chtype *)NULL;
X   }
X
X   /* Create the new string.					*/
X   len		= chlen (original);
X   newstring	= (chtype *)malloc (sizeof(chtype) * (len+4));
X   cleanChtype (newstring, len+3, '\0');
X 
X   /* Copy from one to the other...				*/
X   for (x=0; x < len; x++)
X   {
X      newstring[x]	= original[x];
X   }
X
X   /* Return the new string.					*/
X   return (newstring);
}
X
X
/*
X * This draws a line in a scrolling list or a selection list.
X */
void drawScrollItem (WINDOW *win, char *item, int woffset, int hoffset, int voffset, int width, chtype attr)
{
X   char *tmp = substring(item, voffset, width);
X   if (tmp != (char *)NULL)
X   {
X      printattr (win, hoffset, woffset, HORIZONTAL, attr, tmp);
X      free (tmp);
X   }
}
X
/*
X * This reads a file and sticks it into the char ** provided.
X */
int readFile (char *filename, char **array, int maxlines)
{
X   FILE	*fd;
X   char temp[515];
X   int	lines	= 0;
X
X   /* Clean out temp...						*/
X   cleanChar (temp, 514, '\0');
X
X   /* Can we open the file?					*/
X   if ((fd = fopen (filename, "r")) == NULL)
X   {
X      return (-1);
X   }
X                                                                                
X   /* Start reading the file in.				*/
X   while ((fgets (temp, 512, fd) != (char *)NULL) && lines < maxlines)
X   {
X      int len		= (int)strlen(temp);
X      temp[len-1]	= '\0';
X      array[lines]	= copyChar (temp);
X      lines++;
X   }
X   fclose (fd);
X
X   /* Clean up and return.					*/
X   array[lines] = "";
X   return (lines);
}
X
/*
X * This function takes a character string, full of format markers
X * and translates them into a chtype * array. This is better suited
X * to curses, because curses uses chtype almost exclusively
X */
chtype *char2Chtype (char *string, int *to, int *align)
{
X   chtype attrib	= A_NORMAL;
X   int insideMarker	= FALSE;
X   int start		= 0;
X   int from		= 0;
X   int pair		= 0;
X   int x 		= 3;
X   int len		= 0;
X   chtype newstring[500], lastChar;
X   char temp[50];
X   int adjust;
X
X   /* Is the string NULL???					*/
X   if (string == (char *)NULL)
X   {
X      return ((chtype *)NULL);
X   }
X
X   /* Get the length of the string.				*/
X   len = (int)strlen(string);
X
X   /* Set up some default values...				*/
X   (*to)		= 0;
X   (*align)		= LEFT;
X   temp[0]		= '\0';
X   pair			= 0;
X
X   /* Lets make some room for the chtype string...		*/
X   cleanChtype (newstring, 500, '\0');
X
X   /* Look for an alignment marker.				*/
X   if (string[0] == '<' && string[1] == 'C' && string[2] == '>')
X   {
X      (*align)	= CENTER;
X      start	= 3;
X   }
X   else if (string[0] == '<' && string[1] == 'R' && string[2] == '>')
X   {
X      (*align)	= RIGHT;
X      start	= 3;
X   }
X   else if (string[0] == '<' && string[1] == 'L' && string[2] == '>')
X   {
X      (*align)	= LEFT;
X      start	= 3;
X   }
X   else if (string[0] == '<' && string[1] == 'B' && string[2] == '=')
X   {
X      /* Set the item index value in the string.		*/
X      newstring[0] = ' '; newstring[1] = ' '; newstring[2] = ' ';
X
X      /* Pull out the bullet marker.				*/
X      while (string[x] != '>')
X      {
X         newstring[x] = string[x] | A_BOLD;
X         x++;
X      }
X      newstring[x++] = ' ';
X
X      /* Set the alignment variables.				*/
X      (*align)	= LEFT;
X      start	= x;
X      (*to)	= x;
X   }
X   else if (string[0] == '<' && string[1] == 'I' && string[2] == '=')
X   {
X      cleanChar (temp, 49, '\0');
X      from=2;
X      x=0;
X
X      /* Strip out the number.					*/
X      while (string[++from] != '>')
X      {
X         if (isdigit(string[from]))
X         {
X            temp[x++] = string[from];
X         }
X      }
X
X      /* Set the alignment variables.				*/
X      (*align)	= LEFT;
X      start	= x + 4;
X      
X      /* Add on the spaces.					*/
X      adjust = atoi (temp);
X      for (x=0; x < adjust; x++)
X      {
X         newstring[(*to)++] = ' ';
X      }
X   }
X      
X   /* Set the format marker boolean to false.			*/
X   insideMarker	= FALSE;
X
X   /* Start parsing the character string...			*/
X   for (from=start; from < len; from++)
X   {
X      /* Are we inside a format marker???			*/
X      if (! insideMarker)
X      {
X         if (string[from] == '<' && string[from+1] == '/')
X         {
X            insideMarker = 1;
X         }
X         else if (string[from] == '<' && string[from+1] == '!')
X         {
X            insideMarker = 2;
X         }
X         else if (string[from] == '<' && string[from+1] == '#')
X         {
X            insideMarker = 3;
X         }
X         else if (string[from] == '\\' && string[from+1] == '<')
X         {
X            from++;
X            newstring[(*to)++]	= string[from++] | attrib;
X         }
X         else if (string[from] == '\t')
X         {
X            for (x=0; x < 8; x++)
X            {
X               newstring[(*to)++] = ' ';
X            }
X         }
X         else
X         {
X            newstring[(*to)++]	= string[from] | attrib;
X         }
X      }
X      else
X      {
X         /* We are in the format marker.			*/
X         if (string[from] == '>')
X         {
X            insideMarker = 0;
X         }
X         else if (string[from] == '#')
X         {
X            lastChar = (chtype)NULL;
X            if (string[from+1] == 'L' && string[from+2] == 'L')
X            {
X               newstring[(*to)++] = ACS_LLCORNER | attrib;
X               lastChar = ACS_LLCORNER;
X               from += 2;
X            }
X            else if (string[from+1] == 'L' && string[from+2] == 'R')
X            {
X               newstring[(*to)++] = ACS_LRCORNER | attrib;
X               lastChar = ACS_LRCORNER;
X               from += 2;
X            }
X            else if (string[from+1] == 'U' && string[from+2] == 'R')
X            {
X               newstring[(*to)++] = ACS_URCORNER | attrib;
X               lastChar = ACS_URCORNER;
X               from += 2;
X            }
X            else if (string[from+1] == 'U' && string[from+2] == 'L')
X            {
X               newstring[(*to)++] = ACS_ULCORNER | attrib;
X               lastChar = ACS_ULCORNER;
X               from += 2;
X            }
X            else if (string[from+1] == 'R' && string[from+2] == 'T')
X            {
X               newstring[(*to)++] = ACS_RTEE | attrib;
X               lastChar = ACS_RTEE;
X               from += 2;
X            }
X            else if (string[from+1] == 'L' && string[from+2] == 'T')
X            {
X               newstring[(*to)++] = ACS_LTEE | attrib;
X               lastChar = ACS_LTEE;
X               from += 2;
X            }
X            else if (string[from+1] == 'B' && string[from+2] == 'T')
X            {
X               newstring[(*to)++] = ACS_BTEE | attrib;
X               lastChar = ACS_BTEE;
X               from += 2;
X            }
X            else if (string[from+1] == 'T' && string[from+2] == 'T')
X            {
X               newstring[(*to)++] = ACS_TTEE | attrib;
X               lastChar = ACS_TTEE;
X               from += 2;
X            }
X            else if (string[from+1] == 'H' && string[from+2] == 'L')
X            {
X               newstring[(*to)++] = ACS_HLINE | attrib;
X               lastChar = ACS_HLINE;
X               from += 2;
X            }
X            else if (string[from+1] == 'V' && string[from+2] == 'L')
X            {
X               newstring[(*to)++] = ACS_VLINE | attrib;
X               lastChar = ACS_VLINE;
X               from += 2;
X            }
X            else if (string[from+1] == 'P' && string[from+2] == 'L')
X            {
X               newstring[(*to)++] = ACS_PLUS | attrib;
X               lastChar = ACS_PLUS;
X               from += 2;
X            }
X            else if (string[from+1] == 'D' && string[from+2] == 'I')
X            {
X               newstring[(*to)++] = ACS_DIAMOND | attrib;
X               lastChar = ACS_DIAMOND;
X               from += 2;
X            }
X            else if (string[from+1] == 'C' && string[from+2] == 'B')
X            {
X               newstring[(*to)++] = ACS_CKBOARD | attrib;
X               lastChar = ACS_CKBOARD;
X               from += 2;
X            }
X            else if (string[from+1] == 'D' && string[from+2] == 'G')
X            {
X               newstring[(*to)++] = ACS_DEGREE | attrib;
X               lastChar = ACS_DEGREE;
X               from += 2;
X            }
X            else if (string[from+1] == 'P' && string[from+2] == 'M')
X            {
X               newstring[(*to)++] = ACS_PLMINUS | attrib;
X               lastChar = ACS_PLMINUS;
X               from += 2;
X            }
X            else if (string[from+1] == 'B' && string[from+2] == 'U')
X            {
X               newstring[(*to)++] = ACS_BULLET | attrib;
X               lastChar = ACS_BULLET;
X               from += 2;
X            }
X            else if (string[from+1] == 'S' && string[from+2] == '1')
X            {
X               newstring[(*to)++] = ACS_S1 | attrib;
X               lastChar = ACS_S1;
X               from += 2;
X            }
X            else if (string[from+1] == 'S' && string[from+2] == '9')
X            {
X               newstring[(*to)++] = ACS_S9 | attrib;
X               lastChar = ACS_S9;
X               from += 2;
X            }
X
X            /* Check for a possible numeric modifier.		*/
X            if (string[from+1] == '(' && lastChar != (chtype)NULL)
X            {
X               /* Set up some variables.			*/
X               cleanChar (temp, 49, '\0');
X               from++;
X               x=0;
X
X               /* Strip out the number.				*/
X               while (string[++from] != ')')
X               {
X                  if (isdigit(string[from]))
X                  {
X                     temp[x++] = string[from];
X                  }
X               }
X
X               /* Convert the number.				*/
X               if (x != 0)
X               {
X                  adjust = atoi (temp);
X                  for (x=0; x < adjust; x++)
X                  {
X                     newstring[(*to)++] = lastChar | attrib;
X                  }
X               }
X            }
X         }
X         else if (string[from] == '/' && string[from+1] == 'B')
X         {
X            attrib	= attrib | A_BOLD;
X            from++;
X         }
X         else if (string[from] == '!' && string[from+1] == 'B')
X         {
X            attrib	= attrib & (~A_BOLD);
X            from++;
X         }
X         else if (string[from] == '/' && string[from+1] == 'U')
X         {
X            attrib	= attrib | A_UNDERLINE;
X            from++;
X         }
X         else if (string[from] == '!' && string[from+1] == 'U')
X         {
X            attrib	= attrib & (~A_UNDERLINE);
X            from++;
X         }
X         else if (string[from] == '/' && string[from+1] == 'S')
X         {
X            attrib	= attrib | A_STANDOUT;
X            from++;
X         }
X         else if (string[from] == '!' && string[from+1] == 'S')
X         {
X            attrib	= attrib & (~A_STANDOUT);
X            from++;
X         }
X         else if (string[from] == '/' && string[from+1] == 'R')
X         {
X            attrib	= attrib | A_REVERSE;
X            from++;
X         }
X         else if (string[from] == '!' && string[from+1] == 'R')
X         {
X            attrib	= attrib & (~A_REVERSE);
X            from++;
X         }
X         else if (string[from] == '/' && string[from+1] == 'K')
X         {
X            attrib	= attrib | A_BLINK;
X            from++;
X         }
X         else if (string[from] == '!' && string[from+1] == 'K')
X         {
X            attrib	= attrib & (~A_BLINK);
X            from++;
X         }
X         else if (string[from] == '/' && string[from+1] == 'D')
X         {
X            attrib	= attrib | A_DIM;
X            from++;
X         }
X         else if (string[from] == '!' && string[from+1] == 'D')
X         {
X            attrib	= attrib & (~A_DIM);
X            from++;
X         }
X         else if (string[from] == '/' && isdigit(string[from+1]) && isdigit(string[from+2]))
X         {
#ifdef COLOR
X            sprintf (temp, "%c%c", string[from+1],string[from+2]);
X            pair	= atoi(temp);
X            attrib	= attrib | COLOR_PAIR(pair);
#else
X            from += 2;
#endif
X         }
X         else if (string[from] == '!' && isdigit(string[from+1]) && isdigit(string[from+2]))
X         {
#ifdef COLOR
X            sprintf (temp, "%c%c", string[from+1],string[from+2]);
X            pair	= atoi(temp);
X            attrib	= attrib & (~COLOR_PAIR(pair));
#else
X            from += 2;
#endif
X         }
X         else if (string[from] == '/' && isdigit(string[from+1]))
X         {
#ifdef COLOR
X            pair	= string[++from] - '0';
X            attrib	= attrib | COLOR_PAIR(pair);
#else
X            from++;
#endif
X         }
X         else if (string[from] == '!' && isdigit(string[from+1]))
X         {
#ifdef COLOR
X            pair	= string[++from] - '0';
X            attrib	= attrib & (~COLOR_PAIR(pair));
#else
X            from++;
#endif
X         }
X      }
X   }
X
X   /*
X    * If there are no characters, put the attribute into the
X    * the first character of the array.
X    */
X   if (chlen(newstring) == 0)
X   {
X      newstring[0] = attrib;
X   }
X
X   /* Return the new string...					*/
X   return (copyChtype (newstring));
}
X
/*
X * This determines the length of a chtype string
X */
int chlen (chtype *string)
{
X   /* Declare local variables.					*/
X   int x	= 0;
X
X   /* Make sure we wern't given a NULL string.			*/
X   if (string == (chtype *)NULL)
X   {
X      return (0);
X   }
X
X   /* Find out how long this string is.				*/
X   while (string[x++] != (chtype)'\0');
X   return ((x-1));
}
X
/*
X * This returns a pointer to char * of a chtype *
X */
char *chtype2Char (chtype *string)
{
X   /* Declare local variables.					*/
X   char *newstring;
X   int len = 0;
X   int x;
X
X   /* Is the string NULL???					*/
X   if (string == (chtype *)NULL)
X   {
X      return ((char *)NULL);
X   }
X
X   /* Get the length of the string.				*/
X   len = chlen(string);
X
X   /* Make the new string.					*/
X   newstring	= (char *)malloc (sizeof (char) * (len+1));
X   cleanChar (newstring, len+1, '\0');
X
X   /* Start translating...					*/
X   for (x=0; x < len; x++)
X   {
X      newstring[x]	= string[x] & A_CHARTEXT;
X   }
X
X   /* Force a NULL character on the end of the string.		*/
X   newstring[len] = (char)NULL;
X
X   /* Return it.						*/
X   return (newstring);
}
X
void printattr (WINDOW *window, int xpos, int ypos, int align, chtype attr, char *mesg)
{
X   int x;
X
X   /* Check the alignment of the message.	*/
X   if (align == VERTICAL)
X   { 
X      int mesgLength = ((int)strlen (mesg) <= window->_maxy ? (int)strlen (mesg) : window->_maxy);
X
X      /* Draw the message on a vertical axis.	*/
X      for (x=0; x < mesgLength ; x++)
X      {
X         if (attr == A_NORMAL)
X         {
X            mvwaddch (window, xpos+x, ypos, mesg[x]);
X         }
X         else
X         {
X            mvwaddch (window, xpos+x, ypos, mesg[x] | attr);
X         }
X      }
X   }
X   else
X   {
X      int mesgLength = ((int)strlen (mesg) <= window->_maxx ? (int)strlen (mesg) : window->_maxx);
X
X      /* Draw the message on a horizontal axis. (default)	*/
X      for (x=0; x < mesgLength ; x++)
X      {
X         if (attr == A_NORMAL)
X         {
X            mvwaddch (window, xpos, ypos+x, mesg[x]);
X         }
X         else
X         {
X            mvwaddch (window, xpos, ypos+x, mesg[x] | attr);
X         }
X      }
X   }
}
X
/*
X * This swaps two elements in an array.
X */
void swapIndex (char *list[], int i, int j)
{
X   char *temp;
X   temp = list[i];
X   list[i] = list[j];
X   list[j] = temp;
}
X
/*
X * This function is a quick sort alg which sort an array of
X * char *. I wanted to use to stdlib qsort, but couldn't get the
X * thing to work, so I wrote my own. I'll use qsort if I can get
X * it to work.
X */
void quickSort (char *list[], int left, int right)
{
X   int i, last;
X
X   /* If there are fewer than 2 elements, return.	*/
X   if (left >= right)
X   {
X      return;
X   }
X
X   swapIndex (list, left, (left+right)/2);
X   last = left;
X   
X   for (i=left+1; i <= right; i++)
X   {
X      if (strcmp (list[i], list[left]) < 0)
X      {
X         swapIndex (list, ++last, i);
X      }
X   }
X
X   swapIndex (list, left, last);
X   quickSort (list, left, last-1);
X   quickSort (list, last+1, right);
}
X
/*
X * This strips white space off of the given string.
X */
void stripWhiteSpace (EStripType stripType, char *string)
{
X   /* Declare local variables.					*/
X   int stringLength = 0;
X   int alphaChar = 0;
X   int x = 0;
X   
X   /* Make sure the string is not NULL.				*/
X   if (string == (char *)NULL)
X   {
X      return;
X   }
X
X   /* Get the length of the string.				*/
X   stringLength = (int)strlen(string);
X
X   /* Strip the white space from the front.			*/
X   if (stripType == vFRONT || stripType == vBOTH)
X   {
X      /* Find the first non-whitespace character.		*/
X      while (string[alphaChar] == ' ' || string[alphaChar] == '\t')
X      {
X         alphaChar++;
X      }
X
X      /* Trim off the white space.				*/
X      if (alphaChar != stringLength)
X      {
X         for (x=0; x < (stringLength-alphaChar); x++)
X         {
X            string[x] = string[x+alphaChar];
X         }
X         string[stringLength-alphaChar] = '\0';
X      }
X      else
X      {
X         /* Set the string to zero.				*/
X         string = (char *)memset (string, 0, stringLength);
X      }
X   }
X
X   /* Get the length of the string.				*/
X   stringLength = (int)strlen(string)-1;
X
X   /* Strip the space from behind if it was asked for.		*/
X   if (stripType == vBACK || stripType == vBOTH)
X   {
X      /* Find the first non-whitespace character.		*/
X      while (string[stringLength] == ' ' || string[stringLength] == '\t')
X      {
X         string[stringLength--] = '\0';
X      }
X   }
}
X
/*
X * This splits a string into X parts given the split character.
X */
int splitString (char *string, char *items[], char splitChar)
{
X   /* Declare local variables.					*/
X   char temp[100];
X   int stringLength = 0;
X   int chunks = 0;
X   int pos = 0;
X   int x;
X
X   /* Check if the given string is NULL.			*/
X   if (string == (char *)NULL)
X   {
X      return (0);
X   }
X
X   /* Get the length of the string.				*/
X   stringLength = (int)strlen (string);
X
X   /* Zero out the temp string.					*/
X   cleanChar (temp, 100, '\0');
X
X   /* Start looking for the string.				*/
X   for (x=0; x < stringLength; x++)
X   {
X      if (string[x] == splitChar)
X      {
X         /* Copy the string into the array.			*/
X         items[chunks++] = strdup (temp);
X
X         /* Zero out the temp string.				*/
X         cleanChar (temp, 100, '\0');
X
X         /* Reset the position counter.				*/
X         pos = 0;
X      }
X      else
X      {
X         temp[pos++] = string[x];
X      }
X   }
X
X   /* Don't forget the last one.				*/
X   items[chunks++] = strdup (temp);
X   return chunks;
}
X
/*
X * This function takes a mode_t type and creates a string represntation
X * of the permission mode. 
X */
int mode2Char (char *string, mode_t mode)
{
X   /* Declare local variables.					*/
X   int permissions = 0;
X
X   /* Clean the string.						*/
X   cleanChar (string, 11, '-');
X   string[11] = '\0';
X
X   /* Determine the file type.					*/
X   if (S_ISLNK (mode))
X   {
X      string[0] = 'l';
X   }
X   else if (S_ISSOCK (mode))
X   {
X      string[0] = '@';
X   }
X   else if (S_ISREG(mode))
X   {
X      string[0] = '-';
X   }
X   else if (S_ISDIR(mode))
X   {
X      string[0] = 'd';
X   }
X   else if (S_ISCHR(mode))
X   {
X      string[0] = 'c';
X   }
X   else if (S_ISBLK(mode))
X   {
X      string[0] = 'b';
X   }
X   else if (S_ISFIFO(mode))
X   {
X      string[0] = '&';
X   }
X   else
X   {
X      return -1;
X   }
X
X   /* Readable by owner?					*/
X   if ((mode&S_IRUSR) != 0)
X   {
X      string[1] = 'r';
X      permissions += 400;
X   }
X
X   /* Writable by owner?					*/
X   if ((mode & S_IWUSR) != 0)
X   {
X      string[2] = 'w';
X      permissions += 200;
X   }
X
X   /* Executable by owner?					*/
X   if ((mode & S_IXUSR) != 0)
X   {
X      string[3] = 'x';
X      permissions += 100;
X   }
X
X   /* Readable by group?					*/
X   if ((mode & S_IRGRP) != 0)
X   {
X      string[4] = 'r';
X      permissions += 40;
X   }
X
X   /* Writable by group?					*/
X   if ((mode & S_IWGRP) != 0)
X   {
X      string[5] = 'w';
X      permissions += 20;
X   }
X
X   /* Executable by group?					*/
X   if ((mode & S_IXGRP) != 0)
X   {
X      string[6] = 'x';
X      permissions += 10;
X   }
X
X   /* Readable by other?					*/
X   if ((mode & S_IROTH) != 0)
X   {
X      string[7] = 'r';
X      permissions += 4;
X   }
X
X   /* Writable by other?					*/
X   if ((mode & S_IWOTH) != 0)
X   {
X      string[8] = 'w';
X      permissions += 2;
X   }
X
X   /* Executable by other?					*/
X   if ((mode & S_IXOTH) != 0)
X   {
X      string[9] = 'x';
X      permissions += 1;
X   }
X
X   /* Check for suid.						*/
X   if ((mode & S_ISUID) != 0)
X   {
X      string[3] = 's';
X      permissions += 4000;
X   }
X
X   /* Check for sgid.						*/
X   if ((mode & S_ISGID) != 0)
X   {
X      string[6] = 's';
X      permissions += 2000;
X   }
X
X   /* Check for sticky bit.					*/
X   if ((mode & S_ISVTX) != 0)
X   {
X      string[0] = 't';
X      permissions += 1000;
X   }
X
X   /* Check for unusual permissions.				*/
X   if (((mode & S_IXUSR) == 0) &&
X	((mode & S_IXGRP) == 0) &&
X	((mode & S_IXOTH) == 0) &&
X	(mode & S_ISUID) != 0)
X   {
X      string[3] = 'S';
X   }
X
X   return permissions;
}
X
/*
X * This returns the length of the integer.
X */
int intlen (int value)
{
X   int len = log10 (value) + 1;
X   return len;
}
X
/*
X * This opens the current directory and reads the contents.
X */
int getDirectoryContents (char *directory, char **list, int maxListSize)
{
X   /* Declare local variables.						*/
X   struct dirent *dirStruct;
X   int counter = 0;
X   DIR *dp;
X
X   /* Open the directory.						*/
X   dp = opendir (directory);
X
X   /* Could we open the directory?					*/
X   if (dp == NULL)
X   {
X      return -1;
X   }
X
X   /* Read the directory.						*/
X   while ((dirStruct = readdir (dp)) != NULL)
X   {
X      if (counter <= maxListSize)
X      {
X         list[counter++] = copyChar (dirStruct->d_name);
X      }
X   }
X
X   /* Close the directory.						*/
X   closedir (dp);
X
X   /* Sort the info.							*/
X   quickSort (list, 0, counter-1);
X
X   /* Return the number of files in the directory.			*/
X   return counter;
}
X
/* 
X * This looks for a subset of a word in the given list.
X */
int searchList (char **list, int listSize, char *pattern)
{
X   /* Declare local variables.						*/
X   int len	= (int)strlen (pattern);
X   int index	= -1;
X   int x, ret;
X
X   for (x=0; x < listSize; x++)
X   {
X      /* Do a string compare.						*/
X      ret = strncmp (list[x], pattern, len);
X      if (ret < 0)
X      {
X         index = ret;
X      }
X      else if (ret > 0)
X      {
X         return index;
X      }
X      else
X      {
X         return x;
X      }
X   }
X   return -1;
}
X
/*
X * This function checks to see if a link has been requested.
X */
int checkForLink (char *line, char *filename)
{
X   int len	= (int)strlen (line);
X   int fPos	= 0;
X   int x	= 3;
X
X   if (line[0] == '<' && line[1] == 'F' && line[2] == '=')
X   {
X      /* Strip out the filename.					*/
X      while (x < len)
X      {
X         if (line[x] == '>')
X         {
X            break;
X         }
X         filename[fPos++] = line[x++];
X      }
X      filename[fPos] = '\0';
X      return 1;
X   }
X   return 0;
}
X
/*
X * This strips out the filename from the pathname.
X */
char *baseName (char *pathname)
{
X   char *pos = rindex (pathname, '/');
X   pos++;
X   return pos;
}
SHAR_EOF
  $shar_touch -am 0709111596 'cdk4.8.0/cdk.c' &&
  chmod 0444 'cdk4.8.0/cdk.c' ||
  echo 'restore of cdk4.8.0/cdk.c failed'
  shar_count="`wc -c < 'cdk4.8.0/cdk.c'`"
  test 30354 -eq "$shar_count" ||
    echo "cdk4.8.0/cdk.c: original size 30354, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk4.8.0/cdkscreen.c ==============
if test -f 'cdk4.8.0/cdkscreen.c' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk4.8.0/cdkscreen.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk4.8.0/cdkscreen.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk4.8.0/cdkscreen.c' &&
#include "cdk.h"
X
/*
X * $Author: glover $
X * $Date: 1996/07/03 16:53:02 $
X * $Revision: 1.46 $
X */
extern char *GCdkObjects[];
X
/*
X * This creates a new CDK screen.
X */
CDKSCREEN *initCDKScreen(WINDOW *window)
{
X   CDKSCREEN *screen	= (CDKSCREEN *)malloc (sizeof(CDKSCREEN));
X   int x;
X
X   /* Set up basic curses settings.		*/
X   noecho();
X   cbreak();
X
X   /* Initialize the CDKSCREEN pointer.		*/
X   screen->objectCount	= 0;
X   screen->window	= window;
X   for (x=0; x < MAXOBJECTS; x++)
X   {
X      screen->object[x] = (void *)NULL;
X      screen->cdktype[x] = vNULL;
X   }
X
X   /* OK, we are done.				*/
X   return (screen);
}
X
/*
X * This registers a CDK object with a screen.
X */
void registerCDKObject (CDKSCREEN *screen, EObjectType cdktype, void *object)
{
X   /* Set some basic vars.						*/
X   int objectNumber			= screen->objectCount;
X   screen->object[objectNumber]		= (void *)object;
X
X   /* Since dereferencing a void pointer is a no-no, we have to cast	*/
X   /* our pointer correctly.						*/
X   if (cdktype == vLABEL)
X   {
X      ((CDKLABEL *)object)->screenIndex		= objectNumber;
X      ((CDKLABEL *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vLABEL;
X   }
X   else if (cdktype == vENTRY)
X   {
X      ((CDKENTRY *)object)->screenIndex		= objectNumber;
X      ((CDKENTRY *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vENTRY;
X   }
X   else if (cdktype == vMENTRY)
X   {
X      ((CDKMENTRY *)object)->screenIndex	= objectNumber;
X      ((CDKMENTRY *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vMENTRY;
X   }
X   else if (cdktype == vSCROLL)
X   {
X      ((CDKSCROLL *)object)->screenIndex	= objectNumber;
X      ((CDKSCROLL *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vSCROLL;
X   }
X   else if (cdktype == vDIALOG)
X   {
X      ((CDKDIALOG *)object)->screenIndex	= objectNumber;
X      ((CDKDIALOG *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vDIALOG;
X   }
X   else if (cdktype == vSCALE)
X   {
X      ((CDKSCALE *)object)->screenIndex		= objectNumber;
X      ((CDKSCALE *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vSCALE;
X   }
X   else if (cdktype == vMARQUEE)
X   {
X      ((CDKMARQUEE *)object)->screenIndex	= objectNumber;
X      ((CDKMARQUEE *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vMARQUEE;
X   }
X   else if (cdktype == vMENU)
X   {
X      ((CDKMENU *)object)->screenIndex		= objectNumber;
X      ((CDKMENU *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vMENU;
X   }
X   else if (cdktype == vMATRIX)
X   {
X      ((CDKMATRIX *)object)->screenIndex	= objectNumber;
X      ((CDKMATRIX *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vMATRIX;
X   }
X   else if (cdktype == vHISTOGRAM)
X   {
X      ((CDKHISTOGRAM *)object)->screenIndex	= objectNumber;
X      ((CDKHISTOGRAM *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vHISTOGRAM;
X   }
X   else if (cdktype == vSELECTION)
X   {
X      ((CDKSELECTION *)object)->screenIndex	= objectNumber;
X      ((CDKSELECTION *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vSELECTION;
X   }
X   else if (cdktype == vVIEWER)
X   {
X      ((CDKVIEWER *)object)->screenIndex	= objectNumber;
X      ((CDKVIEWER *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vVIEWER;
X   }
X   else if (cdktype == vGRAPH)
X   {
X      ((CDKGRAPH *)object)->screenIndex		= objectNumber;
X      ((CDKGRAPH *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vGRAPH;
X   }
X   else if (cdktype == vRADIO)
X   {
X      ((CDKRADIO *)object)->screenIndex		= objectNumber;
X      ((CDKRADIO *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vRADIO;
X   }
X   else if (cdktype == vTEMPLATE)
X   {
X      CDKTEMPLATE *template			= (CDKTEMPLATE *)object;
X      template->screenIndex			= objectNumber;
X      template->screen				= screen;
X      screen->cdktype[objectNumber]		= vTEMPLATE;
X   }
X   else if (cdktype == vSWINDOW)
X   {
X      ((CDKSWINDOW *)object)->screenIndex	= objectNumber;
X      ((CDKSWINDOW *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vSWINDOW;
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      ((CDKITEMLIST *)object)->screenIndex	= objectNumber;
X      ((CDKITEMLIST *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vITEMLIST;
X   }
X   else if (cdktype == vFSELECT)
X   {
X      ((CDKFSELECT *)object)->screenIndex	= objectNumber;
X      ((CDKFSELECT *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vFSELECT;
X   }
X   else if (cdktype == vSLIDER)
X   {
X      ((CDKSLIDER *)object)->screenIndex	= objectNumber;
X      ((CDKSLIDER *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vSLIDER;
X   }
X   else if (cdktype == vALPHALIST)
X   {
X      ((CDKALPHALIST *)object)->screenIndex	= objectNumber;
X      ((CDKALPHALIST *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vALPHALIST;
X   }
X   else if (cdktype == vCALENDAR)
X   {
X      ((CDKCALENDAR *)object)->screenIndex	= objectNumber;
X      ((CDKCALENDAR *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vCALENDAR;
X   }
X   else
X   {
X      return;
X   }
X
X   /* Don't forget to inc the count.					*/
X   screen->objectCount++;
}
X
/*
X * This removes an object from the CDK screen.
X */
void unregisterCDKObject (EObjectType cdktype, void *object)
{
X   /* Declare some vars.						*/
X   CDKSCREEN *screen;
X   int screenSize, index, x;
X   char *type;
X
X   /* Since dereferencing a void pointer is a no-no, we have to cast	*/
X   /* our pointer correctly.						*/
X   if (cdktype == vLABEL)
X   {
X      screen		= ((CDKLABEL *)object)->screen;
X      index		= ((CDKLABEL *)object)->screenIndex;
X      type		= "Label";
X   }
X   else if (cdktype == vENTRY)
X   {
X      screen		= ((CDKENTRY *)object)->screen;
X      index		= ((CDKENTRY *)object)->screenIndex;
X      type		= "Entry";
X   }
X   else if (cdktype == vMENTRY)
X   {
X      screen		= ((CDKMENTRY *)object)->screen;
X      index		= ((CDKMENTRY *)object)->screenIndex;
X      type		= "MEntry";
X   }
X   else if (cdktype == vSCROLL)
X   {
X      screen		= ((CDKSCROLL *)object)->screen;
X      index		= ((CDKSCROLL *)object)->screenIndex;
X      type		= "Scroll";
X   }
X   else if (cdktype == vDIALOG)
X   {
X      screen		= ((CDKDIALOG *)object)->screen;
X      index		= ((CDKDIALOG *)object)->screenIndex;
X      type		= "Dialog";
X   }
X   else if (cdktype == vSCALE)
X   {
X      screen		= ((CDKSCALE *)object)->screen;
X      index		= ((CDKSCALE *)object)->screenIndex;
X      type		= "Scale";
X   }
X   else if (cdktype == vMARQUEE)
X   {
X      screen		= ((CDKMARQUEE *)object)->screen;
X      index		= ((CDKMARQUEE *)object)->screenIndex;
X      type		= "Marquee";
X   }
X   else if (cdktype == vMENU)
X   {
X      screen		= ((CDKMENU *)object)->screen;
X      index		= ((CDKMENU *)object)->screenIndex;
X      type		= "Menu";
X   }
X   else if (cdktype == vMATRIX)
X   {
X      screen		= ((CDKMATRIX *)object)->screen;
X      index		= ((CDKMATRIX *)object)->screenIndex;
X      type		= "Matrix";
X   }
X   else if (cdktype == vHISTOGRAM)
X   {
X      screen		= ((CDKHISTOGRAM *)object)->screen;
X      index		= ((CDKHISTOGRAM *)object)->screenIndex;
X      type		= "Histogram";
X   }
X   else if (cdktype == vSELECTION)
X   {
X      screen		= ((CDKSELECTION *)object)->screen;
X      index		= ((CDKSELECTION *)object)->screenIndex;
X      type		= "Selection";
X   }
X   else if (cdktype == vVIEWER)
X   {
X      screen		= ((CDKVIEWER *)object)->screen;
X      index		= ((CDKVIEWER *)object)->screenIndex;
X      type		= "Viewer";
X   }
X   else if (cdktype == vGRAPH)
X   {
X      screen		= ((CDKGRAPH *)object)->screen;
X      index		= ((CDKGRAPH *)object)->screenIndex;
X      type		= "Graph";
X   }
X   else if (cdktype == vRADIO)
X   {
X      screen		= ((CDKRADIO *)object)->screen;
X      index		= ((CDKRADIO *)object)->screenIndex;
X      type		= "Radio";
X   }
X   else if (cdktype == vTEMPLATE)
X   {
X      screen		= ((CDKTEMPLATE *)object)->screen;
X      index		= ((CDKTEMPLATE *)object)->screenIndex;
X      type		= "Template";
X   }
X   else if (cdktype == vSWINDOW)
X   {
X      screen		= ((CDKSWINDOW *)object)->screen;
X      index		= ((CDKSWINDOW *)object)->screenIndex;
X      type		= "SWindow";
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      screen		= ((CDKITEMLIST *)object)->screen;
X      index		= ((CDKITEMLIST *)object)->screenIndex;
X      type		= "Itemlist";
X   }
X   else if (cdktype == vFSELECT)
X   {
X      screen		= ((CDKFSELECT *)object)->screen;
X      index		= ((CDKFSELECT *)object)->screenIndex;
X      type		= "File Selector";
X   }
X   else if (cdktype == vSLIDER)
X   {
X      screen		= ((CDKSLIDER *)object)->screen;
X      index		= ((CDKSLIDER *)object)->screenIndex;
X      type		= "Slider";
X   }
X   else if (cdktype == vALPHALIST)
X   {
X      screen		= ((CDKALPHALIST *)object)->screen;
X      index		= ((CDKALPHALIST *)object)->screenIndex;
X      type		= "Alphabetic List";
X   }
X   else if (cdktype == vCALENDAR)
X   {
X      screen		= ((CDKCALENDAR *)object)->screen;
X      index		= ((CDKCALENDAR *)object)->screenIndex;
X      type		= "Calendar";
X   }
X   else
X   {
X      return;
X   }
X
X   /* Set the screenSize.		*/
X   screenSize = screen->objectCount - 1;
X
X   /* If this is the last object -1 then this is the last. If not	*/
X   /* we have to shuffle all the other objects to the left.		*/
X   for (x=index; x < screenSize; x++)
X   {
X      screen->object[x]		= screen->object[x+1];
X      screen->cdktype[x]	= screen->cdktype[x+1];
X   }
X   screen->object[x]		= (void *)NULL;
X   screen->cdktype[x]		= 0;
X   screen->objectCount--;
}
X
/*
X * This 'brings' a CDK object to the top of the stack.
X */
void raiseCDKObject (EObjectType cdktype, void *object)
{
X   /* Declare some vars.						*/
X   void *swapobject	= (void *)NULL;
X   int toppos		= -1;
X   int swapindex	= -1;
X   EObjectType swaptype;
X
X   /* Should never dereference a void * pointer.			*/
X   if (cdktype == vLABEL)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKLABEL *)object)->screen->objectCount - 1;
X      swapobject	= (void *)((CDKLABEL *)object)->screen->object[toppos];
X      swaptype		= ((CDKLABEL *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKLABEL *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKLABEL *)object)->screenIndex			= toppos;
X      ((CDKLABEL *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKLABEL *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vENTRY)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKENTRY *)object)->screen->objectCount;
X      swapobject	= ((CDKENTRY *)object)->screen->object[toppos];
X      swaptype		= ((CDKENTRY *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKENTRY *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKENTRY *)object)->screenIndex			= toppos;
X      ((CDKENTRY *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKENTRY *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMENTRY)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKMENTRY *)object)->screen->objectCount;
X      swapobject	= ((CDKMENTRY *)object)->screen->object[toppos];
X      swaptype		= ((CDKMENTRY *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMENTRY *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMENTRY *)object)->screenIndex		= toppos;
X      ((CDKMENTRY *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMENTRY *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSCROLL)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKSCROLL *)object)->screen->objectCount;
X      swapobject	= ((CDKSCROLL *)object)->screen->object[toppos];
X      swaptype		= ((CDKSCROLL *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSCROLL *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSCROLL *)object)->screenIndex		= toppos;
X      ((CDKSCROLL *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSCROLL *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vDIALOG)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKDIALOG *)object)->screen->objectCount;
X      swapobject	= ((CDKDIALOG *)object)->screen->object[toppos];
X      swaptype		= ((CDKDIALOG *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKDIALOG *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKDIALOG *)object)->screenIndex		= toppos;
X      ((CDKDIALOG *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKDIALOG *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSCALE)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKSCALE *)object)->screen->objectCount;
X      swapobject	= ((CDKSCALE *)object)->screen->object[toppos];
X      swaptype		= ((CDKSCALE *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSCALE *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSCALE *)object)->screenIndex			= toppos;
X      ((CDKSCALE *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSCALE *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMARQUEE)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKMARQUEE *)object)->screen->objectCount;
X      swapobject	= ((CDKMARQUEE *)object)->screen->object[toppos];
X      swaptype		= ((CDKMARQUEE *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMARQUEE *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMARQUEE *)object)->screenIndex		= toppos;
X      ((CDKMARQUEE *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMARQUEE *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMENU)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKMENU *)object)->screen->objectCount;
X      swapobject	= ((CDKMENU *)object)->screen->object[toppos];
X      swaptype		= ((CDKMENU *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMENU *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMENU *)object)->screenIndex			= toppos;
X      ((CDKMENU *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMENU *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMATRIX)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKMATRIX *)object)->screen->objectCount;
X      swapobject	= ((CDKMATRIX *)object)->screen->object[toppos];
X      swaptype		= ((CDKMATRIX *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMATRIX *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMATRIX *)object)->screenIndex		= toppos;
X      ((CDKMATRIX *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMATRIX *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vHISTOGRAM)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKHISTOGRAM *)object)->screen->objectCount;
X      swapobject	= ((CDKHISTOGRAM *)object)->screen->object[toppos];
X      swaptype		= ((CDKHISTOGRAM *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKHISTOGRAM *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKHISTOGRAM *)object)->screenIndex		= toppos;
X      ((CDKHISTOGRAM *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKHISTOGRAM *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSELECTION)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKSELECTION *)object)->screen->objectCount;
X      swapobject	= ((CDKSELECTION *)object)->screen->object[toppos];
X      swaptype		= ((CDKSELECTION *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSELECTION *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSELECTION *)object)->screenIndex		= toppos;
X      ((CDKSELECTION *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSELECTION *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vVIEWER)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKVIEWER *)object)->screen->objectCount;
X      swapobject	= ((CDKVIEWER *)object)->screen->object[toppos];
X      swaptype		= ((CDKVIEWER *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKVIEWER *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKVIEWER *)object)->screenIndex		= toppos;
X      ((CDKVIEWER *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKVIEWER *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vGRAPH)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKGRAPH *)object)->screen->objectCount;
X      swapobject	= ((CDKGRAPH *)object)->screen->object[toppos];
X      swaptype		= ((CDKGRAPH *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKGRAPH *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKGRAPH *)object)->screenIndex			= toppos;
X      ((CDKGRAPH *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKGRAPH *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vRADIO)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKRADIO *)object)->screen->objectCount;
X      swapobject	= ((CDKRADIO *)object)->screen->object[toppos];
X      swaptype		= ((CDKRADIO *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKRADIO *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKRADIO *)object)->screenIndex			= toppos;
X      ((CDKRADIO *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKRADIO *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vTEMPLATE)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKTEMPLATE *)object)->screen->objectCount;
X      swapobject	= ((CDKTEMPLATE *)object)->screen->object[toppos];
X      swaptype		= ((CDKTEMPLATE *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKTEMPLATE *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKTEMPLATE *)object)->screenIndex		= toppos;
X      ((CDKTEMPLATE *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKTEMPLATE *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSWINDOW)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKSWINDOW *)object)->screen->objectCount;
X      swapobject	= ((CDKSWINDOW *)object)->screen->object[toppos];
X      swaptype		= ((CDKSWINDOW *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSWINDOW *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSWINDOW *)object)->screenIndex		= toppos;
X      ((CDKSWINDOW *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSWINDOW *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKITEMLIST *)object)->screen->objectCount;
X      swapobject	= ((CDKITEMLIST *)object)->screen->object[toppos];
X      swaptype		= ((CDKITEMLIST *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKITEMLIST *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKITEMLIST *)object)->screenIndex		= toppos;
X      ((CDKITEMLIST *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKITEMLIST *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vFSELECT)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKFSELECT *)object)->screen->objectCount;
X      swapobject	= ((CDKFSELECT *)object)->screen->object[toppos];
X      swaptype		= ((CDKFSELECT *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKFSELECT *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKFSELECT *)object)->screenIndex		= toppos;
X      ((CDKFSELECT *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKFSELECT *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSLIDER)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKSLIDER *)object)->screen->objectCount;
X      swapobject	= ((CDKSLIDER *)object)->screen->object[toppos];
X      swaptype		= ((CDKSLIDER *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSLIDER *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSLIDER *)object)->screenIndex		= toppos;
X      ((CDKSLIDER *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSLIDER *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vALPHALIST)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKALPHALIST *)object)->screen->objectCount;
X      swapobject	= ((CDKALPHALIST *)object)->screen->object[toppos];
X      swaptype		= ((CDKALPHALIST *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKALPHALIST *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKALPHALIST *)object)->screenIndex		= toppos;
X      ((CDKALPHALIST *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKALPHALIST *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vCALENDAR)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKCALENDAR *)object)->screen->objectCount;
X      swapobject	= ((CDKCALENDAR *)object)->screen->object[toppos];
X      swaptype		= ((CDKCALENDAR *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKCALENDAR *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKCALENDAR *)object)->screenIndex		= toppos;
X      ((CDKCALENDAR *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKCALENDAR *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else
X   {
X      return;
X   }
X   
X   /* OK, Lets swap 'em....						*/
X   if (swaptype == vLABEL)
X   {
X      ((CDKLABEL *)object)->screenIndex			= swapindex;
X      ((CDKLABEL *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKLABEL *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vENTRY)
X   {
X      ((CDKENTRY *)object)->screenIndex			= swapindex;
X      ((CDKENTRY *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKENTRY *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMENTRY)
X   {
X      ((CDKMENTRY *)object)->screenIndex		= swapindex;
X      ((CDKMENTRY *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKMENTRY *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSCROLL)
X   {
X      ((CDKSCROLL *)object)->screenIndex		= swapindex;
X      ((CDKSCROLL *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKSCROLL *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vDIALOG)
X   {
X      ((CDKDIALOG *)object)->screenIndex		= swapindex;
X      ((CDKDIALOG *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKDIALOG *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSCALE)
X   {
X      ((CDKSCALE *)object)->screenIndex			= swapindex;
X      ((CDKSCALE *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKSCALE *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMARQUEE)
X   {
X      ((CDKMARQUEE *)object)->screenIndex			= swapindex;
X      ((CDKMARQUEE *)object)->screen->object[swapindex]		= swapobject;
X      ((CDKMARQUEE *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMENU)
X   {
X      ((CDKMENU *)object)->screenIndex			= swapindex;
X      ((CDKMENU *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKMENU *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMATRIX)
X   {
X      ((CDKMATRIX *)object)->screenIndex		= swapindex;
X      ((CDKMATRIX *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKMATRIX *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vHISTOGRAM)
X   {
X      ((CDKHISTOGRAM *)object)->screenIndex			= swapindex;
X      ((CDKHISTOGRAM *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKHISTOGRAM *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSELECTION)
X   {
X      ((CDKSELECTION *)object)->screenIndex			= swapindex;
X      ((CDKSELECTION *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKSELECTION *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vVIEWER)
X   {
X      ((CDKVIEWER *)object)->screenIndex		= swapindex;
X      ((CDKVIEWER *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKVIEWER *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vGRAPH)
X   {
X      ((CDKGRAPH *)object)->screenIndex			= swapindex;
X      ((CDKGRAPH *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKGRAPH *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vRADIO)
X   {
X      ((CDKRADIO *)object)->screenIndex			= swapindex;
X      ((CDKRADIO *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKRADIO *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vTEMPLATE)
X   {
X      ((CDKTEMPLATE *)object)->screenIndex			= swapindex;
X      ((CDKTEMPLATE *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKTEMPLATE *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSWINDOW)
X   {
X      ((CDKSWINDOW *)object)->screenIndex			= swapindex;
X      ((CDKSWINDOW *)object)->screen->object[swapindex]		= swapobject;
X      ((CDKSWINDOW *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vITEMLIST)
X   {
X      ((CDKITEMLIST *)object)->screenIndex			= swapindex;
X      ((CDKITEMLIST *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKITEMLIST *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vFSELECT)
X   {
X      ((CDKFSELECT *)object)->screenIndex			= swapindex;
X      ((CDKFSELECT *)object)->screen->object[swapindex]		= swapobject;
X      ((CDKFSELECT *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSLIDER)
X   {
X      ((CDKSLIDER *)object)->screenIndex			= swapindex;
X      ((CDKSLIDER *)object)->screen->object[swapindex]		= swapobject;
X      ((CDKSLIDER *)object)->screen->cdktype[swapindex]		= swaptype;
X   }
X   else if (swaptype == vALPHALIST)
X   {
X      ((CDKALPHALIST *)object)->screenIndex			= swapindex;
X      ((CDKALPHALIST *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKALPHALIST *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vCALENDAR)
X   {
X      ((CDKCALENDAR *)object)->screenIndex			= swapindex;
X      ((CDKCALENDAR *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKCALENDAR *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
}
X   
/*
X * This 'lowers' an object.
*/
void lowerCDKObject (EObjectType cdktype, void *object)
{
X   /* Declare some vars.						*/
X   void *swapobject	= (void *)NULL;
X   int toppos		= 0;
X   int swapindex	= -1;
X   EObjectType swaptype;
X
X   /* Should never dereference a void * pointer.			*/
X   if (cdktype == vLABEL)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKLABEL *)object)->screen->object[toppos];
X      swaptype		= ((CDKLABEL *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKLABEL *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKLABEL *)object)->screenIndex			= toppos;
X      ((CDKLABEL *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKLABEL *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vENTRY)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKENTRY *)object)->screen->object[toppos];
X      swaptype		= ((CDKENTRY *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKENTRY *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKENTRY *)object)->screenIndex			= toppos;
X      ((CDKENTRY *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKENTRY *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMENTRY)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKMENTRY *)object)->screen->object[toppos];
X      swaptype		= ((CDKMENTRY *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMENTRY *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMENTRY *)object)->screenIndex		= toppos;
X      ((CDKMENTRY *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMENTRY *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSCROLL)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKSCROLL *)object)->screen->object[toppos];
X      swaptype		= ((CDKSCROLL *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSCROLL *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSCROLL *)object)->screenIndex		= toppos;
X      ((CDKSCROLL *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSCROLL *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vDIALOG)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKDIALOG *)object)->screen->object[toppos];
X      swaptype		= ((CDKDIALOG *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKDIALOG *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKDIALOG *)object)->screenIndex		= toppos;
X      ((CDKDIALOG *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKDIALOG *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSCALE)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKSCALE *)object)->screen->object[toppos];
X      swaptype		= ((CDKSCALE *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSCALE *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSCALE *)object)->screenIndex			= toppos;
X      ((CDKSCALE *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSCALE *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMARQUEE)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKMARQUEE *)object)->screen->object[toppos];
X      swaptype		= ((CDKMARQUEE *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMARQUEE *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMARQUEE *)object)->screenIndex		= toppos;
X      ((CDKMARQUEE *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMARQUEE *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMENU)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKMENU *)object)->screen->object[toppos];
X      swaptype		= ((CDKMENU *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMENU *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMENU *)object)->screenIndex			= toppos;
X      ((CDKMENU *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMENU *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMATRIX)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKMATRIX *)object)->screen->object[toppos];
X      swaptype		= ((CDKMATRIX *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMATRIX *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMATRIX *)object)->screenIndex		= toppos;
X      ((CDKMATRIX *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMATRIX *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vHISTOGRAM)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKHISTOGRAM *)object)->screen->object[toppos];
X      swaptype		= ((CDKHISTOGRAM *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKHISTOGRAM *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKHISTOGRAM *)object)->screenIndex		= toppos;
X      ((CDKHISTOGRAM *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKHISTOGRAM *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSELECTION)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKSELECTION *)object)->screen->object[toppos];
X      swaptype		= ((CDKSELECTION *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSELECTION *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSELECTION *)object)->screenIndex		= toppos;
X      ((CDKSELECTION *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSELECTION *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vVIEWER)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKVIEWER *)object)->screen->object[toppos];
X      swaptype		= ((CDKVIEWER *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKVIEWER *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKVIEWER *)object)->screenIndex		= toppos;
X      ((CDKVIEWER *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKVIEWER *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vGRAPH)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKGRAPH *)object)->screen->object[toppos];
X      swaptype		= ((CDKGRAPH *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKGRAPH *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKGRAPH *)object)->screenIndex			= toppos;
X      ((CDKGRAPH *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKGRAPH *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vRADIO)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKRADIO *)object)->screen->object[toppos];
X      swaptype		= ((CDKRADIO *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKRADIO *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKRADIO *)object)->screenIndex			= toppos;
X      ((CDKRADIO *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKRADIO *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vTEMPLATE)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKTEMPLATE *)object)->screen->object[toppos];
X      swaptype		= ((CDKTEMPLATE *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKTEMPLATE *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKTEMPLATE *)object)->screenIndex		= toppos;
X      ((CDKTEMPLATE *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKTEMPLATE *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSWINDOW)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKSWINDOW *)object)->screen->object[toppos];
X      swaptype		= ((CDKSWINDOW *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSWINDOW *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSWINDOW *)object)->screenIndex		= toppos;
X      ((CDKSWINDOW *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSWINDOW *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKITEMLIST *)object)->screen->object[toppos];
X      swaptype		= ((CDKITEMLIST *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKITEMLIST *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKITEMLIST *)object)->screenIndex		= toppos;
X      ((CDKITEMLIST *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKITEMLIST *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vFSELECT)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKFSELECT *)object)->screen->object[toppos];
X      swaptype		= ((CDKFSELECT *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKFSELECT *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKFSELECT *)object)->screenIndex		= toppos;
X      ((CDKFSELECT *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKFSELECT *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSLIDER)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKSLIDER *)object)->screen->object[toppos];
X      swaptype		= ((CDKSLIDER *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSLIDER *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSLIDER *)object)->screenIndex		= toppos;
X      ((CDKSLIDER *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSLIDER *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vALPHALIST)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKALPHALIST *)object)->screen->object[toppos];
X      swaptype		= ((CDKALPHALIST *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKALPHALIST *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKALPHALIST *)object)->screenIndex		= toppos;
X      ((CDKALPHALIST *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKALPHALIST *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vCALENDAR)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKCALENDAR *)object)->screen->object[toppos];
X      swaptype		= ((CDKCALENDAR *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKCALENDAR *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKCALENDAR *)object)->screenIndex		= toppos;
X      ((CDKCALENDAR *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKCALENDAR *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else
X   {
X      return;
X   }
X   
X   /* OK, Lets swap 'em....						*/
X   if (swaptype == vLABEL)
X   {
X      ((CDKLABEL *)object)->screenIndex			= swapindex;
X      ((CDKLABEL *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKLABEL *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vENTRY)
X   {
X      ((CDKENTRY *)object)->screenIndex			= swapindex;
X      ((CDKENTRY *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKENTRY *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMENTRY)
X   {
X      ((CDKMENTRY *)object)->screenIndex		= swapindex;
X      ((CDKMENTRY *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKMENTRY *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSCROLL)
X   {
X      ((CDKSCROLL *)object)->screenIndex		= swapindex;
X      ((CDKSCROLL *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKSCROLL *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vDIALOG)
X   {
X      ((CDKDIALOG *)object)->screenIndex		= swapindex;
X      ((CDKDIALOG *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKDIALOG *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSCALE)
X   {
X      ((CDKSCALE *)object)->screenIndex			= swapindex;
X      ((CDKSCALE *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKSCALE *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMARQUEE)
X   {
X      ((CDKMARQUEE *)object)->screenIndex			= swapindex;
X      ((CDKMARQUEE *)object)->screen->object[swapindex]		= swapobject;
X      ((CDKMARQUEE *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMENU)
X   {
X      ((CDKMENU *)object)->screenIndex			= swapindex;
X      ((CDKMENU *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKMENU *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMATRIX)
X   {
X      ((CDKMATRIX *)object)->screenIndex		= swapindex;
X      ((CDKMATRIX *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKMATRIX *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vHISTOGRAM)
X   {
X      ((CDKHISTOGRAM *)object)->screenIndex			= swapindex;
X      ((CDKHISTOGRAM *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKHISTOGRAM *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSELECTION)
X   {
X      ((CDKSELECTION *)object)->screenIndex			= swapindex;
X      ((CDKSELECTION *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKSELECTION *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vVIEWER)
X   {
X      ((CDKVIEWER *)object)->screenIndex		= swapindex;
X      ((CDKVIEWER *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKVIEWER *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vGRAPH)
X   {
X      ((CDKGRAPH *)object)->screenIndex			= swapindex;
X      ((CDKGRAPH *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKGRAPH *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vRADIO)
X   {
X      ((CDKRADIO *)object)->screenIndex			= swapindex;
X      ((CDKRADIO *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKRADIO *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vTEMPLATE)
X   {
X      ((CDKTEMPLATE *)object)->screenIndex			= swapindex;
X      ((CDKTEMPLATE *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKTEMPLATE *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSWINDOW)
X   {
X      ((CDKSWINDOW *)object)->screenIndex			= swapindex;
X      ((CDKSWINDOW *)object)->screen->object[swapindex]		= swapobject;
X      ((CDKSWINDOW *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vITEMLIST)
X   {
X      ((CDKITEMLIST *)object)->screenIndex			= swapindex;
X      ((CDKITEMLIST *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKITEMLIST *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vFSELECT)
X   {
X      ((CDKFSELECT *)object)->screenIndex			= swapindex;
X      ((CDKFSELECT *)object)->screen->object[swapindex]		= swapobject;
X      ((CDKFSELECT *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSLIDER)
X   {
X      ((CDKSLIDER *)object)->screenIndex			= swapindex;
X      ((CDKSLIDER *)object)->screen->object[swapindex]		= swapobject;
X      ((CDKSLIDER *)object)->screen->cdktype[swapindex]		= swaptype;
X   }
X   else if (swaptype == vALPHALIST)
X   {
X      ((CDKALPHALIST *)object)->screenIndex			= swapindex;
X      ((CDKALPHALIST *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKALPHALIST *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vCALENDAR)
X   {
X      ((CDKCALENDAR *)object)->screenIndex			= swapindex;
X      ((CDKCALENDAR *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKCALENDAR *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
}
X
/*
X * This refreshes all the objects in the screen.
X */
void refreshCDKScreen (CDKSCREEN *cdkscreen)
{
X   int objectCount = cdkscreen->objectCount;
X   int x;
X
X   /* Refresh the screen.			*/
X   wrefresh (cdkscreen->window);
X
X   /* We just call the drawObject function...	*/
X   for (x=0; x < objectCount; x++)
X   {
X      if (cdkscreen->cdktype[x] == vLABEL)
X      {
X         CDKLABEL *label = (CDKLABEL *)(cdkscreen->object[x]);
X         drawCDKLabel (label, label->box);
X      }
X      else if (cdkscreen->cdktype[x] == vENTRY)
X      {
X         CDKENTRY *entry = (CDKENTRY *)(cdkscreen->object[x]);
X         drawCDKEntry (entry, entry->box);
X      }
X      else if (cdkscreen->cdktype[x] == vMENTRY)
X      {
X         CDKMENTRY *mentry = (CDKMENTRY *)(cdkscreen->object[x]);
X         drawCDKMentry (mentry, mentry->box);
X      }
X      else if (cdkscreen->cdktype[x] == vSCROLL)
X      {
X         CDKSCROLL *scroll = (CDKSCROLL *)(cdkscreen->object[x]);
X         drawCDKScroll (scroll, scroll->box);
X      }
X      else if (cdkscreen->cdktype[x] == vDIALOG)
X      {
X         CDKDIALOG *dialog = (CDKDIALOG *)(cdkscreen->object[x]);
X         drawCDKDialog (dialog, dialog->box);
X      }
X      else if (cdkscreen->cdktype[x] == vSCALE)
X      {
X         CDKSCALE *scale = (CDKSCALE *)(cdkscreen->object[x]);
X         drawCDKScale (scale, scale->box);
X      }
X      else if (cdkscreen->cdktype[x] == vMARQUEE)
X      {
X         CDKMARQUEE *marquee = (CDKMARQUEE *)(cdkscreen->object[x]);
X         drawCDKMarquee (marquee, marquee->box);
X      }
X      else if (cdkscreen->cdktype[x] == vMENU)
X      {
X         CDKMENU *menu = (CDKMENU *)(cdkscreen->object[x]);
X         drawCDKMenu (menu);
X      }
X      else if (cdkscreen->cdktype[x] == vMATRIX)
X      {
X         CDKMATRIX *matrix = (CDKMATRIX *)(cdkscreen->object[x]);
X         drawCDKMatrix (matrix, matrix->boxMatrix);
X      }
X      else if (cdkscreen->cdktype[x] == vHISTOGRAM)
X      {
X         CDKHISTOGRAM *histogram = (CDKHISTOGRAM *)(cdkscreen->object[x]);
X         drawCDKHistogram (histogram, histogram->box);
X      }
X      else if (cdkscreen->cdktype[x] == vSELECTION)
X      {
X         CDKSELECTION *selection = (CDKSELECTION *)(cdkscreen->object[x]);
X         drawCDKSelection (selection, selection->box);
X      }
X      else if (cdkscreen->cdktype[x] == vVIEWER)
X      {
X         CDKVIEWER *viewer = (CDKVIEWER *)(cdkscreen->object[x]);
X         drawCDKViewer (viewer, viewer->box);
X      }
X      else if (cdkscreen->cdktype[x] == vGRAPH)
X      {
X         CDKGRAPH *graph = (CDKGRAPH *)(cdkscreen->object[x]);
X         drawCDKGraph (graph, graph->box);
X      }
X      else if (cdkscreen->cdktype[x] == vRADIO)
X      {
X         CDKRADIO *radio = (CDKRADIO *)(cdkscreen->object[x]);
X         drawCDKRadio (radio, radio->box);
X      }
X      else if (cdkscreen->cdktype[x] == vTEMPLATE)
X      {
X         CDKTEMPLATE *template = (CDKTEMPLATE *)(cdkscreen->object[x]);
X         drawCDKTemplate (template, template->box);
X      }
X      else if (cdkscreen->cdktype[x] == vSWINDOW)
X      {
X         CDKSWINDOW *swindow = (CDKSWINDOW *)(cdkscreen->object[x]);
X         drawCDKSwindow (swindow, swindow->box);
X      }
X      else if (cdkscreen->cdktype[x] == vITEMLIST)
X      {
X         CDKITEMLIST *itemlist = (CDKITEMLIST *)(cdkscreen->object[x]);
X         drawCDKItemlist (itemlist, itemlist->box);
X      }
X      else if (cdkscreen->cdktype[x] == vFSELECT)
X      {
X         CDKFSELECT *fselect = (CDKFSELECT *)(cdkscreen->object[x]);
X         drawCDKFselect (fselect, fselect->box);
X      }
X      else if (cdkscreen->cdktype[x] == vSLIDER)
X      {
X         CDKSLIDER *slider = (CDKSLIDER *)(cdkscreen->object[x]);
X         drawCDKSlider (slider, slider->box);
X      }
X      else if (cdkscreen->cdktype[x] == vALPHALIST)
X      {
X         CDKALPHALIST *alphalist = (CDKALPHALIST *)(cdkscreen->object[x]);
X         drawCDKAlphalist (alphalist, alphalist->box);
X      }
X      else if (cdkscreen->cdktype[x] == vCALENDAR)
X      {
X         CDKCALENDAR *calendar = (CDKCALENDAR *)(cdkscreen->object[x]);
X         drawCDKCalendar (calendar, calendar->box);
X      }
X   }
}
X
/*
X * This clears all the objects in the screen.
X */
void eraseCDKScreen (CDKSCREEN *cdkscreen)
{
X   int objectCount 	= cdkscreen->objectCount;
X   int x;
X
X   /* We just call the drawObject function...	*/
X   for (x=0; x < objectCount; x++)
X   {
X      if (cdkscreen->cdktype[x] == vLABEL)
X      {
X         eraseCDKLabel ((CDKLABEL *)(cdkscreen->object[x]));
X      }
X      else if (cdkscreen->cdktype[x] == vENTRY)
X      {
X         eraseCDKEntry ((CDKENTRY *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vMENTRY)
X      {
X         eraseCDKMentry ((CDKMENTRY *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vSCROLL)
X      {
X         eraseCDKScroll ((CDKSCROLL *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vDIALOG)
X      {
X         eraseCDKDialog ((CDKDIALOG *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vSCALE)
X      {
X         eraseCDKScale ((CDKSCALE *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vMARQUEE)
X      {
X         eraseCDKMarquee ((CDKMARQUEE *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vMENU)
X      {
X         eraseCDKMenu ((CDKMENU *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vMATRIX)
X      {
X         eraseCDKMatrix ((CDKMATRIX *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vHISTOGRAM)
X      {
X         eraseCDKHistogram ((CDKHISTOGRAM *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vSELECTION)
X      {
X         eraseCDKSelection ((CDKSELECTION *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vVIEWER)
X      {
X         eraseCDKViewer ((CDKVIEWER *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vGRAPH)
X      {
X         eraseCDKGraph ((CDKGRAPH *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vRADIO)
X      {
X         eraseCDKRadio ((CDKRADIO *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vTEMPLATE)
X      {
X         eraseCDKTemplate ((CDKTEMPLATE *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vSWINDOW)
X      {
X         eraseCDKSwindow ((CDKSWINDOW *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vITEMLIST)
X      {
X         eraseCDKItemlist ((CDKITEMLIST *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vFSELECT)
X      {
X         eraseCDKFselect ((CDKFSELECT *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vSLIDER)
X      {
X         eraseCDKSlider ((CDKSLIDER *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vALPHALIST)
X      {
X         eraseCDKAlphalist ((CDKALPHALIST *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vCALENDAR)
X      {
X         eraseCDKCalendar ((CDKCALENDAR *)cdkscreen->object[x]);
X      }
X   }
X
X   /* Refresh the screen.			*/
X   wrefresh (cdkscreen->window);
}
X
/*
X * This destroys a CDK screen.
X */
void destroyCDKScreen (CDKSCREEN *screen)
{
X   free (screen);
}
X
/*
X * This is added to remain consistent.
X */
void endCDK()
{
X   /* Turn echoing back on...		*/
X   echo();
X
X   /* Turn off cbreak...		*/
X   nocbreak();
X
X   /* End the curses windows...		*/
X   endwin();
X
#ifdef XCURSES
X   XCursesExit();
#endif
}
X
/*
X * This is for pure diagnostics. Really should be taken out
X * at some point in time.
X */
void debugCDKScreen (CDKSCREEN *screen, char *mesg)
{
X   int count = screen->objectCount;
X   int x;
X
X   printf ("\nScreen Object Count: %d\n", count);
X   printf ("Message: %s\n", mesg);
X   for (x=0; x < count ; x++)
X   {
X      printf ("CDK Object[%d] : Type: %s\n", x, GCdkObjects[screen->cdktype[x]]);
X   }
}
SHAR_EOF
  $shar_touch -am 0709111596 'cdk4.8.0/cdkscreen.c' &&
  chmod 0444 'cdk4.8.0/cdkscreen.c' ||
  echo 'restore of cdk4.8.0/cdkscreen.c failed'
  shar_count="`wc -c < 'cdk4.8.0/cdkscreen.c'`"
  test 50203 -eq "$shar_count" ||
    echo "cdk4.8.0/cdkscreen.c: original size 50203, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk4.8.0/binding.c ==============
if test -f 'cdk4.8.0/binding.c' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk4.8.0/binding.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk4.8.0/binding.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk4.8.0/binding.c' &&
#include "cdk.h"
X
/*
X * $Author: glover $
X * $Date: 1996/06/24 16:00:29 $
X * $Revision: 1.22 $
X */
X
/*
X * This inserts a binding.
X */
void bindCDKObject (EObjectType cdktype, void *object, chtype key, BINDFN function, void * data)
{
X   int index	= mapChtype (key);
X
X   /* Since dereferencing a void pointer is a no-no, we have to cast	*/
X   /* our pointer correctly.						*/
X   if (cdktype == vENTRY)
X   {
X      ((CDKENTRY *)object)->bindFunction[index]		= function;
X      ((CDKENTRY *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vMENTRY)
X   {
X      ((CDKMENTRY *)object)->bindFunction[index]	= function;
X      ((CDKMENTRY *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vSCROLL)
X   {
X      ((CDKSCROLL *)object)->bindFunction[index]	= function;
X      ((CDKSCROLL *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vDIALOG)
X   {
X      ((CDKDIALOG *)object)->bindFunction[index]	= function;
X      ((CDKDIALOG *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vSCALE)
X   {
X      ((CDKSCALE *)object)->bindFunction[index]		= function;
X      ((CDKSCALE *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vMENU)
X   {
X      ((CDKMENU *)object)->bindFunction[index]		= function;
X      ((CDKMENU *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vMATRIX)
X   {
X      ((CDKMATRIX *)object)->bindFunction[index]	= function;
X      ((CDKMATRIX *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vSELECTION)
X   {
X      ((CDKSELECTION *)object)->bindFunction[index]	= function;
X      ((CDKSELECTION *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vVIEWER)
X   {
X      ((CDKVIEWER *)object)->bindFunction[index]	= function;
X      ((CDKVIEWER *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vRADIO)
X   {
X      ((CDKRADIO *)object)->bindFunction[index]		= function;
X      ((CDKRADIO *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vTEMPLATE)
X   {
X      ((CDKTEMPLATE *)object)->bindFunction[index]	= function;
X      ((CDKTEMPLATE *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vSWINDOW)
X   {
X      ((CDKSWINDOW *)object)->bindFunction[index]	= function;
X      ((CDKSWINDOW *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      ((CDKITEMLIST *)object)->bindFunction[index]	= function;
X      ((CDKITEMLIST *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vSLIDER)
X   {
X      ((CDKSLIDER *)object)->bindFunction[index]	= function;
X      ((CDKSLIDER *)object)->bindData[index]		= data;
X   }
X   else if (cdktype == vFSELECT)
X   {
X      bindCDKObject (vENTRY, ((CDKFSELECT *)object)->entryField, key, function, data);
X   }
X   else if (cdktype == vALPHALIST)
X   {
X      bindCDKObject (vENTRY, ((CDKALPHALIST *)object)->entryField, key, function, data);
X   }
X   else if (cdktype == vCALENDAR)
X   {
X      ((CDKCALENDAR *)object)->bindFunction[index]	= function;
X      ((CDKCALENDAR *)object)->bindData[index]		= data;
X   }
}
X
/*
X * This removes a binding on an object.
X */
void unbindCDKObject (EObjectType cdktype, void *object, chtype key)
{
X   int index	= mapChtype(key);
X
X   /* Since dereferencing a void pointer is a no-no, we have to cast	*/
X   /* our pointer correctly.						*/
X   if (cdktype == vENTRY)
X   {
X      ((CDKENTRY *)object)->bindFunction[index]		= (BINDFN)NULL;
X      ((CDKENTRY *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vMENTRY)
X   {
X      ((CDKMENTRY *)object)->bindFunction[index]	= (BINDFN)NULL;
X      ((CDKMENTRY *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vSCROLL)
X   {
X      ((CDKSCROLL *)object)->bindFunction[index]	= (BINDFN)NULL;
X      ((CDKSCROLL *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vDIALOG)
X   {
X      ((CDKDIALOG *)object)->bindFunction[index]	= (BINDFN)NULL;
X      ((CDKDIALOG *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vSCALE)
X   {
X      ((CDKSCALE *)object)->bindFunction[index]		= (BINDFN)NULL;
X      ((CDKSCALE *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vMENU)
X   {
X      ((CDKMENU *)object)->bindFunction[index]		= (BINDFN)NULL;
X      ((CDKMENU *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vMATRIX)
X   {
X      ((CDKMATRIX *)object)->bindFunction[index]	= (BINDFN)NULL;
X      ((CDKMATRIX *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vSELECTION)
X   {
X      ((CDKSELECTION *)object)->bindFunction[index]	= (BINDFN)NULL;
X      ((CDKSELECTION *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vVIEWER)
X   {
X      ((CDKVIEWER *)object)->bindFunction[index]	= (BINDFN)NULL;
X      ((CDKVIEWER *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vRADIO)
X   {
X      ((CDKRADIO *)object)->bindFunction[index]		= (BINDFN)NULL;
X      ((CDKRADIO *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vTEMPLATE)
X   {
X      ((CDKTEMPLATE *)object)->bindFunction[index]	= (BINDFN)NULL;
X      ((CDKTEMPLATE *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vSWINDOW)
X   {
X      ((CDKSWINDOW *)object)->bindFunction[index]	= (BINDFN)NULL;
X      ((CDKSWINDOW *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      ((CDKITEMLIST *)object)->bindFunction[index]	= (BINDFN)NULL;
X      ((CDKITEMLIST *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vSLIDER)
X   {
X      ((CDKSLIDER *)object)->bindFunction[index]	= (BINDFN)NULL;
X      ((CDKSLIDER *)object)->bindData[index]		= (void *)NULL;
X   }
X   else if (cdktype == vFSELECT)
X   {
X      unbindCDKObject (vENTRY, ((CDKFSELECT *)object)->entryField, key);
X   }
X   else if (cdktype == vALPHALIST)
X   {
X      unbindCDKObject (vENTRY, ((CDKALPHALIST *)object)->entryField, key);
X   }
X   else if (cdktype == vCALENDAR)
X   {
X      ((CDKCALENDAR *)object)->bindFunction[index]	= (BINDFN)NULL;
X      ((CDKCALENDAR *)object)->bindData[index]		= (void *)NULL;
X   }
}
X
/*
X * This sets all the bindings for the given objects.
X */
void cleanCDKObjectBindings (EObjectType cdktype, void *object)
{
X   /* Since dereferencing a void pointer is a no-no, we have to cast	*/
X   /* our pointer correctly.						*/
X   if (cdktype == vENTRY)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKENTRY *)object)->bindFunction[x]		= (BINDFN)NULL;
X         ((CDKENTRY *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vMENTRY)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKMENTRY *)object)->bindFunction[x]		= (BINDFN)NULL;
X         ((CDKMENTRY *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vSCROLL)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKSCROLL *)object)->bindFunction[x]		= (BINDFN)NULL;
X         ((CDKSCROLL *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vDIALOG)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKDIALOG *)object)->bindFunction[x]		= (BINDFN)NULL;
X         ((CDKDIALOG *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vSCALE)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKSCALE *)object)->bindFunction[x]		= (BINDFN)NULL;
X         ((CDKSCALE *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vMENU)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKMENU *)object)->bindFunction[x]		= (BINDFN)NULL;
X         ((CDKMENU *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vMATRIX)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKMATRIX *)object)->bindFunction[x]		= (BINDFN)NULL;
X         ((CDKMATRIX *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vSELECTION)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKSELECTION *)object)->bindFunction[x]	= (BINDFN)NULL;
X         ((CDKSELECTION *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vVIEWER)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKVIEWER *)object)->bindFunction[x]		= (BINDFN)NULL;
X         ((CDKVIEWER *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vRADIO)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKRADIO *)object)->bindFunction[x]		= (BINDFN)NULL;
X         ((CDKRADIO *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vTEMPLATE)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKTEMPLATE *)object)->bindFunction[x]	= (BINDFN)NULL;
X         ((CDKTEMPLATE *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vSWINDOW)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKSWINDOW *)object)->bindFunction[x]	= (BINDFN)NULL;
X         ((CDKSWINDOW *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKITEMLIST *)object)->bindFunction[x]	= (BINDFN)NULL;
X         ((CDKITEMLIST *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vSLIDER)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKSLIDER *)object)->bindFunction[x]		= (BINDFN)NULL;
X         ((CDKSLIDER *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
X   else if (cdktype == vFSELECT)
X   {
X      cleanCDKObjectBindings (vENTRY, ((CDKFSELECT *)object)->entryField);
X      cleanCDKObjectBindings (vSCROLL, ((CDKFSELECT *)object)->scrollField);
X   }
X   else if (cdktype == vALPHALIST)
X   {
X      cleanCDKObjectBindings (vENTRY, ((CDKALPHALIST *)object)->entryField);
X      cleanCDKObjectBindings (vSCROLL, ((CDKALPHALIST *)object)->scrollField);
X   }
X   else if (cdktype == vCALENDAR)
X   {
X      int x;
X      for (x=0; x < MAXBINDINGS; x++)
X      {
X         ((CDKCALENDAR *)object)->bindFunction[x]	= (BINDFN)NULL;
X         ((CDKCALENDAR *)object)->bindData[x]		= (void *)NULL;
X      }
X   }
}
X
/*
X * This checks to see iof the binding for the key exists. If it does then it
X * runs the command and returns a TRUE. If it doesn't it returns a FALSE. This
X * way we can 'overwrite' coded in bindings.
X */
int checkCDKObjectBind (EObjectType cdktype, void *object, chtype key)
{
X   int index	= mapChtype (key);
X
X   /* Since dereferencing a void pointer is a no-no, we have to cast	*/
X   /* our pointer correctly.						*/
X   if (cdktype == vENTRY)
X   {
X      if ( ((CDKENTRY *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= (BINDFN) ((CDKENTRY *)object)->bindFunction[index];
X         void * data		= (void *) ((CDKENTRY *)object)->bindData[index];
X         function (vENTRY, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vMENTRY)
X   {
X      if ( ((CDKMENTRY *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKMENTRY *)object)->bindFunction[index];
X         void * data		= ((CDKMENTRY *)object)->bindData[index];
X         function (vMENTRY, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vSCROLL)
X   {
X      if ( ((CDKSCROLL *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKSCROLL *)object)->bindFunction[index];
X         void * data		= ((CDKSCROLL *)object)->bindData[index];
X         function (vSCROLL, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vDIALOG)
X   {
X      if ( ((CDKDIALOG *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKDIALOG *)object)->bindFunction[index];
X         void * data		= ((CDKDIALOG *)object)->bindData[index];
X         function (vDIALOG, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vSCALE)
X   {
X      if ( ((CDKSCALE *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKSCALE *)object)->bindFunction[index];
X         void * data		= ((CDKSCALE *)object)->bindData[index];
X         function (vSCALE, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vMENU)
X   {
X      if ( ((CDKMENU *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKMENU *)object)->bindFunction[index];
X         void * data		= ((CDKMENU *)object)->bindData[index];
X         function (vMENU, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vMATRIX)
X   {
X      if ( ((CDKMATRIX *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKMATRIX *)object)->bindFunction[index];
X         void * data		= ((CDKMATRIX *)object)->bindData[index];
X         function (vMATRIX, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vSELECTION)
X   {
X      if ( ((CDKSELECTION *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKSELECTION *)object)->bindFunction[index];
X         void * data		= ((CDKSELECTION *)object)->bindData[index];
X         function (vSELECTION, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vVIEWER)
X   {
X      if ( ((CDKVIEWER *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKVIEWER *)object)->bindFunction[index];
X         void * data		= ((CDKVIEWER *)object)->bindData[index];
X         function (vVIEWER, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vRADIO)
X   {
X      if ( ((CDKRADIO *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKRADIO *)object)->bindFunction[index];
X         void * data		= ((CDKRADIO *)object)->bindData[index];
X         function (vRADIO, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vTEMPLATE)
X   {
X      if ( ((CDKTEMPLATE *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKTEMPLATE *)object)->bindFunction[index];
X         void * data		= ((CDKTEMPLATE *)object)->bindData[index];
X         function (vTEMPLATE, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vSWINDOW)
X   {
X      if ( ((CDKSWINDOW *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKSWINDOW *)object)->bindFunction[index];
X         void * data		= ((CDKSWINDOW *)object)->bindData[index];
X         function (vSWINDOW, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      if ( ((CDKITEMLIST *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKITEMLIST *)object)->bindFunction[index];
X         void * data		= ((CDKITEMLIST *)object)->bindData[index];
X         function (vITEMLIST, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vSLIDER)
X   {
X      if ( ((CDKSLIDER *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKSLIDER *)object)->bindFunction[index];
X         void * data		= ((CDKSLIDER *)object)->bindData[index];
X         function (vSLIDER, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vALPHALIST)
X   {
X      if ( ((CDKALPHALIST *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKALPHALIST *)object)->bindFunction[index];
X         void * data		= ((CDKALPHALIST *)object)->bindData[index];
X         function (vALPHALIST, object, data);
X         return (TRUE);
X      }
X   }
X   else if (cdktype == vCALENDAR)
X   {
X      if ( ((CDKCALENDAR *)object)->bindFunction[index] != (BINDFN) NULL )
X      {
X         BINDFN function	= ((CDKCALENDAR *)object)->bindFunction[index];
X         void * data		= ((CDKCALENDAR *)object)->bindData[index];
X         function (vCALENDAR, object, data);
X         return (TRUE);
X      }
X   }
X   return (FALSE);
}
X
/*
X * This translates non ascii characters like KEY_UP to an 'equivalent'
X * ascii value.
X */
int mapChtype (chtype key)
{
X   if (key == KEY_UP)
X   {
X       return (257);
X   }
X   else if (key == KEY_DOWN)
X   {
X       return (258);
X   }
X   else if (key == KEY_LEFT)
X   {
X       return (259);
X   }
X   else if (key == KEY_RIGHT)
X   {
X       return (260);
X   }
X   else if (key == KEY_NPAGE)
X   {
X       return (261);
X   }
X   else if (key == KEY_PPAGE)
X   {
X       return (262);
X   }
X   else if (key == KEY_HOME)
X   {
X       return (263);
X   }
X   else if (key == KEY_END)
X   {
X       return (264);
X   }
X   else if (key == KEY_F0)
X   {
X       return (265);
X   }
X   else if (key == KEY_F1)
X   {
X       return (266);
X   }
X   else if (key == KEY_F2)
X   {
X       return (267);
X   }
X   else if (key == KEY_F3)
X   {
X       return (268);
X   }
X   else if (key == KEY_F4)
X   {
X       return (269);
X   }
X   else if (key == KEY_F5)
X   {
X       return (270);
X   }
X   else if (key == KEY_F6)
X   {
X       return (271);
X   }
X   else if (key == KEY_F7)
X   {
X       return (272);
X   }
X   else if (key == KEY_A1)
X   {
X       return (273);
X   }
X   else if (key == KEY_A3)
X   {
X       return (274);
X   }
X   else if (key == KEY_B2)
X   {
X       return (275);
X   }
X   else if (key == KEY_C1)
X   {
X       return (276);
X   }
X   else if (key == KEY_C3)
X   {
X       return (277);
X   }
X   else if (key == KEY_ESC)
X   {
X       return (278);
X   }
X   else 
X   {
X      return ( (char) key );
X   }
}
SHAR_EOF
  $shar_touch -am 0709111596 'cdk4.8.0/binding.c' &&
  chmod 0444 'cdk4.8.0/binding.c' ||
  echo 'restore of cdk4.8.0/binding.c failed'
  shar_count="`wc -c < 'cdk4.8.0/binding.c'`"
  test 17509 -eq "$shar_count" ||
    echo "cdk4.8.0/binding.c: original size 17509, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk4.8.0/debug.c ==============
if test -f 'cdk4.8.0/debug.c' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk4.8.0/debug.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk4.8.0/debug.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdk4.8.0/debug.c' &&
#include "cdk.h"
X
/*
X * $Author: glover $
X * $Date: 1995/12/10 02:12:36 $
X * $Revision: 1.5 $
X */
X
/*
X * This starts debugging for CDK.
X */
FILE *startCDKDebug (char *filename)
{
X   char *defFile	= "cdkdebug.log";
X
X   /* Check if the filename is NULL.		*/
X   if (filename == (char *)NULL)
X   {
X      filename = defFile;
X   }
X
X   /* Try to open the file.			*/
X   return ( fopen (filename, "w") );
}
X
/*
X * This writes a message to the debug file.
X */
void writeCDKDebugMessage (FILE *fd, char *filename, char *function, int line, char *message)
{
X   /* Print the message as long as the file descr. is not NULL.	*/
X   if (fd != NULL)
X   {
X      fprintf (fd, "%s::%s (Line %d) %s\n", filename, function, line, message);
X   }
}
X
/*
X * This turns off the debugging for CDK.
X */
void stopCDKDebug (FILE *fd)
{
X   if (fd != NULL)
X   {
X      fclose (fd);
X   }
}
SHAR_EOF
  $shar_touch -am 0709111596 'cdk4.8.0/debug.c' &&
  chmod 0444 'cdk4.8.0/debug.c' ||
  echo 'restore of cdk4.8.0/debug.c failed'
  shar_count="`wc -c < 'cdk4.8.0/debug.c'`"
  test 854 -eq "$shar_count" ||
    echo "cdk4.8.0/debug.c: original size 854, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdk4.8.0/alphalist.c ==============
if test -f 'cdk4.8.0/alphalist.c' && test X"$1" != X"-c"; then
  echo 'x - skipping cdk4.8.0/alphalist.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdk4.8.0/alphalist.c (binary)'
  sed 's/^X//' << 'SHAR_EOF' > _sharuue.tmp &&
begin 600 cdk4.8.0/alphalist.c
SHAR_EOF
  : || echo 'restore of cdk4.8.0/alphalist.c failed'
fi
echo 'End of archive part 3'
echo 'File cdk4.8.0/alphalist.c is continued in part 4'
echo 4 > _sharseq.tmp
exit 0
