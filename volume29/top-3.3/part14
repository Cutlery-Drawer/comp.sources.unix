Newsgroups: comp.sources.unix
From: lefebvre@athens.dis.anl.gov (William LeFebvre)
Subject: v29i014: top-3.3 - top users display, V3.3, Part14/16
References: <1.801816033.16454@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: lefebvre@athens.dis.anl.gov (William LeFebvre)
Posting-Number: Volume 29, Issue 14
Archive-Name: top-3.3/part14

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 14 (of 16)."
# Contents:  Changes machine/m_freebsd20.c
# Wrapped by lefebvre@athens on Thu Mar  2 11:39:43 1995
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Changes' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Changes'\"
else
echo shar: Extracting \"'Changes'\" \(22408 characters\)
sed "s/^X//" >'Changes' <<'END_OF_FILE'
XThu Mar  2 1995 - wnl (3.3 RELEASE)
X	Added module netbsd10 and renamed netbsd to netbsd08.  Changed
X	Configure so that it does not use an initial default module name.
X	Made other compatability fixes to Configure.  Added comments to
X	decosf1 concerning optimizer bug.  Other documentation changes.
X	Added use of "prime.c" to Configure script.
X
XTue Feb  7 1995 - wnl (3.3beta6)
X	Still one more beta....
X	Fixes for sunos5 2.4 gcc core dump (it was an alignment problem).
X	Fixed and improvements for decosf1 (including use of format_k
X	for proper SIZEcolumn formatting).  Added modules freebsd20 and
X	ncr3000.
X
XThu Feb  2 1995 - wnl (3.3beta5)
X	One more beta....
X	Fixed a few bugs in the sunos5 port pertaining to casting and
X	very large memory counts.  Added "ifndef HAVE_GETOPT" to getopt.c
X	to provide for conditional compilation of the getopt function.
X	Those systems that have getopt in libc can add -DHAVE_GETOPT to
X	the CFLAGS line in the module to prevent the function from being
X	compiled.  Added sunos54 module to accomodate SunOS 5.4
X	peculiarities.  Added module for aux3.1.
X
XWed Jan  4 1995 - wnl (3.3beta4)
X	This is really taking too long......sigh.
X	Fixed SIGWINCH handling	once and for all.  It now remembers the
X        number of processes you	want displayed even thru window resizes.
X	Fixed buffer conflict in utils.c (itoa and itoa7).
X        Lots of small improvements to the various modules were made over
X	the past month: too numberous to list here.  SunOS 5 module made
X	more secure thru use of seteuid calls (other SVR4 modules should
X	be modified similarly).  One final MP fix to sunos5, too.  Module
X	for decosf1 was modified to accomodate V3.0.
X
XMon Apr 18 1994 - wnl (3.3beta3)
X	I think I finally got a sunos5 module that will work on MP
X	machines.  Fixed cpu states figure in osmp41a so that 
X	percentages never exceed 100%.  Added shell script "install"
X	since Unix vendors can't seem to make up their minds on what
X	options they want to use for the one that comes with the OS.
X	Added netbsd modules from Christos.  Fixed lots of other little
X	things over the past few months that I have long since forgotten.
X
XWed Dec 15 1993 - wnl (3.3beta2)
X	Added module patches from various users:  hpux9, sunos5.
X	Fixed bug with batch mode (screen_width wasn't getting set).
X	Changes to accomodate 64 bit machines.
X	Fixed some bugs in command parsing ("renice 19 " did something
X	unexpected).
X
XMon Aug 30 1993 - wnl (3.3beta)
X	Added lots of little patches from various users.
X	Added routines to utils.c for intelligent formatting of kilobytes
X	and time.  These are intended to be used in the modules when
X	formatting a process line.  Added code to "summary_format" in
X	display.c to do intelligent formatting of memory quantities.
X	Redid display.c to allow for varying line widths and dynamic
X	reallocation of the screen buffer.
X	Added a SIGWINCH handler to top.c!
X	Added a constant, MAX_COLS, to top.h which defines the absolute
X	widest line we will ever allow.  Changed allocations of "char fmt"
X	in all machine modules to use this constant rather than an abitrary
X	number.
X
XFri Aug 13 1993 - wnl (3.3)
X	Changed return value definition of time-related functions in top.c,
X	display.c, and m_ultrix4.c to time_t (stuart@coral.cs.jcu.edu.au).
X	Fixed bug in display.c: line_update when start != 0.
X
XWed Aug  4 1993 - wnl (3.2 release)
X	Changes to Configure from Paul Vixie.  Added modules for hpux9 and
X	bsd386.
X
XTue Jul 13 1993 - wnl (3.1 release)
X	More small changes and minor bug fixes.  Brought bsd44 up to date
X	and added a module for svr4.2.  Changed shar packaging to use Rich
X	Salz's cshar stuff.
X
XWed Jul  7 1993 - wnl (3.1BETA)
X	More changes and bug fixes to Configure.  Applied some other
X	minor bug fixes and suggestions from the beta testers.  Added
X	the "metatop" shell script and the "installmeta" rule to the
X	Makefile to make handling multiple machine models and OS versions
X	easier.  Added INSTALL and FAQ files.
X
XTue May 18 1993 - wnl (3.1BETA)
X	Changed Configure to be compatible with most SVR4 environments
X	(differing output from "ls -lg").  Also changed Configure,
X	Makefile.X, etc., to look for module files in the subdirectory
X	"machine" (thanks to Christos Zoulas).
X
XTue Apr 20 1993 - wnl (3.1BETA)
X	Changed both occurences of "ls -1" in Configure to "ls".  This
X	SHOULD produce the same result, and has the advantage that it
X	doesn't produce an error on a system 5 machine.  Integrated other
X	changes recommended in the first round of beta testing.
X
XWed Mar 10 1993 - wnl (3.1BETA)
X	MAJOR CHANGE:  I have added a required function to all machine
X	dependent modules, called proc_owner.  It takes a pid as an argument
X	and returns the uid of the process's owner.  Such capability is 
X	necessary for top to run securely as a set-uid program, something
X	that is needed for SVR4 implementations to read /proc.  I have
X	retrofitted all modules except dgux with this function, but was
X	not able to test most of them.  Top should now run securely as
X	a setuid program.  Added 386bsd and sunos5 modules.  Added sunos4mp
X	module for MP Suns.
X
XSat Feb 20 1993 - wnl (3.1ALPHA)
X	Modified top.c and commands.c to compile correctly on System V
X	derived Unixes (especially SVR4), but in a way that doesn't rely
X	on an oracle-like declaration (that is, I don't use "ifdef SYSV").
X	Fixed some bugs in "Configure" and "getans".  Added inspection of
X	env variable "TOP" for options, and made -I default to showing
X	idle processes.  Added "u" command to change username restriction
X	on the fly.  Created shell script "suntop" for poor multi-version
X	SunOS folks (like myself).
X
XWed Jun  3 1992 - wnl (3.0)
X	"max_topn" wasn't being used everywhere it was supposed to be
X	in top.c.  Many cosmetic changes, including copyright notices in
X	all the .c files.  Version number is now handled by version.c and
X	reflects the current patchlevel (which is initially set to 0).
X	Changed Configure and Makefile to allow configurable variables for
X	certain commands:  shell, cc, awk, install.  Updated README and
X	Porting.  Ready to release to the world!
X
XMon May 18 1992 - wnl (2.9BETA)
X	Added modules provided by Christos Zoulas.  Replaced screen.c
X	with one modified by Christos and that will appropriately select
X	and handle the sgtty, termio, or termios system.  Integrated many
X	other changes recommended by Christos.  Fixed (I hope) the "-b"
X	batch mode display bug.  Had to change loadavg to load_avg to avoid
X	a conflict with 4.4BSD.  
X
XMon Apr 27 1992 - wnl (2.8BETA)
X	Added modules provided by Daniel Trinkle.  Added patchlevel.h,
X	but the patch level is not yet reflected in the version number.
X	Cleaned up m_sunos4.c a little.
X
XWed Apr 22 1992 - wnl (2.8BETA)
X	Major internal reorganization.  All of the system dependent stuff
X	is now really and truly separated from everything else.  The
X	system dependent functions are contained in a separate .c file
X	called a "module".  The Configure script knows how to find and
X	set up these modules, but the human installer still needs to tell
X	Configure which module to use (no automagic determination of 
X	machine type---sorry).  Added -U option to specify one user's
X	processes, but there is no corresponding command...yet.  Other
X	changes and improvements too numerous to mention here.  Currently
X	there are only two modules:  sunos4 and umax.  But after this beta
X	release is sent around, I expect more to be written.  I just hope
X	that the machine-dependent abstractions don't need to change in
X	the process.
X
XThu Mar 26 1992 - wnl (2.7BETA)
X	Beta release with minimal architecture support.  Updated README
X	and added a first cut at a Porting guide.  Added ioctl TIOCGWINSZ
X	code from top2.5+ (courtesy of David MacKenzie).  I didn't even
X	try porting the Ultrix support since I don't have access to an
X	Ultrix machine.
X
XFri Oct 11 1991 - wnl (2.6)
X	This version was not widely released.  It contained many changes.
X	Here are the major ones:
X
X	Put in Vixie's idle process hack.
X
X	Enhanced type field in new_message to handle delayed messages.
X
X	Changed u_process to automatically adjust for varying lines of
X	output.  Management of screenbuf should now be completely contained
X	in display.c.  Removed now extraneous code from CMD_number[12]
X	portion of command switch in top.c.  This was the stuff that dealt
X	with zeroing out lines in screenbuf.
X
X	Finally made it all work correctly on a 386i.  Problems I had to
X	overcome: kvm_nlist doesn't return 0 on success as advertised (it
X	returns 1 instead); the results of a kvm_nlist are different
X	(n_type can be zero even for a symbol that exists).
X
X	Serious rearrangement for processor dependent stuff.  All nlists
X	are now in separate files with the suffix ".nlist".  Most machine
X	specific code is in "machine.c" surrounded by appropriate ifdefs---
X	the goal is to eventually have all machine specific code in this
X	file.  Managed to find a way to detect SunOS 4.x at compile-time:
X	this is contained in the include file "sun.h".  Completely changed
X	the memory display line for SunOS 4.x---it now displays a far
X	more appropriate report.
X
X	Created the shell script "Configure" to aid in the configuration
X	step.
X
X	Fixed a bug in init_termcap:  it will now tolerate an environment
X	which does not have TERM defined (thanks to Sam Horrocks for
X	pointing this out).
X
XTue Aug  9 1988 - wnl (2.5)
X	Added changes to make top work under version 4.0 of the Sun
X	operating system.  Changes were provided by Scott Alexander of the
X	University of Pennsylvania.  Thanks!  Compile with "-Dsunos4" to
X	get them.  Virtual memory statistics are not readily accessible
X	under 4.0, so they don't show up in the output.
X
XThu Jul 31 1987 - wnl (2.4)
X	Fixed a problem with the 4.0 Pyramid code.  The label "cp_time"
X	doesn't exist in the 4.0 kernel anymore.  I think the code Carl
X	sent me wants "percpu" instead.  That is what I am using and it
X	appears to work.  375 code is still untested (at least by me).
X	Also picked a great deal of lint out of the source.  Lint now only
X	complains about a very few nitpicky things (there are far too many
X	calls to "printf" to put a "(void)" in front of!), at least under
X	SunOS.
X
XTue Jul 28 1987 - wnl (2.4a)
X	Added changes for a Symmetrics Computer Systems s/375 machine.
X	Changes were provided by Paul Vixie.  Thanks!  According to Mr.
X	Vixie:  "These changes were not made at, by, or for SCS proper.
X	SCS would probably be interested in them, but so far only the
X	users' group has them.  They were made in February, 1987, to
X	version 2.1 of the program, by Paul Vixie
X	(dual!ptsfa!vixie!paul@ucbvax.Berkeley.EDU)."  His changes were
X	integrated into version 2.3 to make version 2.4.
X
X	The SCS peculiarities are summarized in Changes.scs.
X
XTue Jun  9 1987 - wnl (2.3 for real)
X	Changed the includes for the extra code Carl sent me to only
X	compile on Version 4.0 Pyramid machines.  This makes top still
X	compilable on pre-4.0 Pyramids.  Specifically, this code is only
X	compiled when both "pyr" and "CPUFOUND" are defined.
X
XWed Jun  3 1987 - wnl (2.3 with Pyramid additions)
X	It's been a month and I still haven't done anything about
X	distributing this version.  However, Carl Gutekunst from Pyramid
X	has sent me some extra patches for some of the Pyramid code.  I
X	just added those and will make them part of 2.3.  This fixes the
X	following Pyramid problems:  adds the inclusion of <sys/systm.h>,
X	uses the correct size for getting the kernel value _ccpu (this bug
X	affected the Vax version as well), sums the elements of the percpu
X	array to calculate a cp_time value (for OSx 4.0).
X
XFri May  1 1987 - wnl (2.3)
X	I have finally finished all the changes for better support of
X	oddbal terminals.  Added the low-level routine "clear_eol" which
X	makes handling terminals without "ce" easy:  it uses spaces
X	instead.  All direct uses of "clear_line" outside of screen.c have
X	been changed to use this primitive.  A terminal with "os" is now
X	handled in such that all situations that need overwriting are
X	completely avoided (including several commands).  This required
X	some changes to the way commands are translated into action (in
X	"top.c").  Made several important changes to display.c to prevent
X	overflowing of any of the fields.  Specifically, more than 99
X	total processes and a cpu state that reaches 100%.  Had to make a
X	small change to two casts in top.c, because the Sun 3.2 compiler
X	was giving warnings on them.  Added the "-q" option which lets
X	root run top at a nice of -20 (in case he thinks he really needs it).
X
XTue Dec 30 1986 - wnl (2.2)
X	I think I fixed a bug reported by Julian Onions at Nottingham.
X	Occasionally, top will core dump when the sprintf in either
X	i_process or u_process overflows due to an exceptionally
X	unrealistic time value.  I think it highly unlikely that top can
X	get a bad proc structure (although I suppose it is possible), but
X	the process time is read from the user structure, and that can
X	sometimes be part garbage.  So, "get_ucpu" checks the value it
X	returns to make sure its formatted form will not overflow the
X	sprintf.  If this doesn't fix the bug, then more drastic measures
X	will be necessary.  I plan to make this version the official
X	"top 2.2".  [[ This version was never distributed very widely. ]]
X
XTue Dec  2 1986 - wnl (2.2c)
X	Added to top.c the notion of a "failed command".  When a command
X	produces a message (on the message line), an update does not
X	follow it.  Before, the message was written and a new display was
X	shown---purposefully not overwriting the message.  But the
X	improvements to handle overstriking terminals and terminals
X	without "ce" clear the screen before every display, which would
X	erase the message.  Now, the message is displayed and top waits
X	another full time interval before updating the display.  This
X	works much better all around.
X
XMon Nov 24 1986 - wnl (2.2b)
X	Created a new file, utils.c, and made appropriate changes to
X	Makefile.  This new file holds all utility functions that can and
X	may be used by more than one "module".  Improved i_memory and
X	u_memory (display.c) so that screen updates for the values
X	displayed are only changed when necessary.  Also made the line
X	look better:  the last fixes made for a rather ugly display.
X	Added the locally defined constant "LoadMax" and added code to
X	top.c to send the cursor home after a space command is entered if
X	the load average is higher than "LoadMax".  This provides visual
X	feedback on loaded systems.
X
XMon Nov  3 1986 - wnl (2.2a)
X	Widened the format for memory usage so that it can display 5
X	digits.  This makes that line look a little ugly---maybe I'll fix
X	that later.  Screen handling now understands "os" and a missing
X	"ce".  It treats them identically:  clear the screen between each
X	display.  Screen handling code now uses "cd" when appropriate
X	(i.e.:  when user has shortened the screen).  Made i_loadave clear
X	then screen and took out most of the explicit calls to "clear" in
X	top.c.  This method is cleaner, especially in conjunction with
X	"os" handling.  Added preprocessor variable "RANDOM_PW" for
X	systems that access the passwd file randomly (Sun's yp and 4.3).
X	With "RANDOM_PW" set, "getpwuid" is used instead of "getpwnam",
X	but uid->username mappings are still hashed internally (because
X	that is still faster than going to disk).
X
XMon Oct  6 1986 - wnl (2.1)
X	A bug with the kill command was pointed out by "dciem!tim"---
X	specifying a signal by name did not work correctly.  This bug has
X	been fixed with a simple change to commands.c.  Another bug made
X	the cpu state percentages incorrect the first time they were
X	displayed.  This bug has also been fixed (changed top.c).
X
XThu Sep  4 1986 - wnl (2.0, at last)
X	This is the version that will (hopefully) get released to the
X	world as top 2.0.
X	Added the "r" and "k" commands for renice and kill, respectively.
X	This required adding a way to handle system call errors, and the
X	addition of the "e" command.  Help screen and manual page were
X	changed to reflect this change.  Changed all "#ifdef SUN" directives
X	to "#ifdef sun", and changed all "#ifdef PYRAMID" directives to
X	"#ifdef pyr".  As much as I hate those choices of preprocessor
X	names (they too easily conflict with real variable names), it does
X	make automatic compilation possible---people don't have to change
X	the Makefile anymore for specific machines.  The manual page was
X	changed to automatically incorporate the defaults as set in the
X	Makefile (including an infinite value for TOPN) and the way the
X	manual page is generated by the Makefile was changed to make
X	maintenance of this information automatic.
X
XMon Jul 28 1986 - wnl (still pre 2.0)
X	Real close now.  I put in a new definition for the macro "pagetok"
X	that does an explicit shift of a constant expression involving
X	PGSHIFT.  Appropriate checks are made if PGSHIFT is to small.
X	"pagetok" is now used exclusively everywhere to convert kernel
X	clicks to kilobytes.  I added a full blown interactive mode with
X	the ability to change some of the runtime parameters (how many to
X	display, time delay, etc.) while top is running.  I also
X	incorporated a few ideas from the net:  control characters in the
X	command name are replaced with '?'; the '-S' option makes the
X	swapper and pager visible; options have been added to control the
X	number of displays produced (this makes it easier to make
X	performance snapshots with top).  I have also added the notion of
X	"infinite" values for number of processes and number of displays.
X	I fixed a long-standing bug in the uid to username mapping code
X	that was only aggravated on the pyramids:  it was an ill-defined
X	expression (akin to i = i++).  I tweaked the proc_compar routine
X	for qsort slightly so that stopped processes were more likely to
X	show up.  Manual page was updated to reflect all changes
X	noticeable to the user.
X
XTue Jul  1 1986 - wnl (pre 2.0 -- 1.9999?)
X	In the process of major revamping on the way to version 2.0.
X	I have completely done away with curses by adding my own screen
X	management routines in a separate file (screen.c).  The rationale
X	for this is that top knows a whole lot more about what is and is
X	not redundant on the screen and can compare simple integer values
X	where curses would have to compare strings.  This has turned out
X	to be a very big win speed-wise.  The proc_compar routine for
X	sorting has been rewritten to include several more keys.  I
X	decided this was necessary when I noticed that the "top" process
X	itself kept disappearing off the top 10 list on a Sun-3.  All the
X	processes had the same percentage (0%) and the sort wasn't really
X	doing anything worthwhile.  I changed the expression that computes
X	memory usage to use the ctob macro instead of just assuming that
X	pages were 512 bytes.  More work still needs to be done before
X	this version is usable.  I changed options-processing to use
X	getopt and added appropriate incantations to the Makefile.
X
XWed Feb 20 1985 - wnl (still 1.8)
X	Put in the ifdef FOUR_ONE statements to make top still compilable
X	on a 4.1 system.  Apparently, there are some users out there that
X	need this functionality.  Oh well.  I don't guarantee any of it,
X	since I can't test it.  Made appropriate changes to README and
X	final installation related changes to Makefile.
X
XSat Feb  2 1985 - wnl (1.8)
X	Removed all the ifdef FOUR_TWO statements and made "top" into a
X	4.2 only program.  If someone really wants to still run it on 4.1,
X	then they can do all the work.  We don't have a 4.1 machine
X	anymore, so I don't even know if the thing still works under 4.1.
X	Cleaned up the Makefile and the README.  Added installation rules
X	to the Makefile, as requested by several sites.  Fixed a very
X	obscure divide-by-zero bug.  Added a second "key" to the qsort
X	comparison function (proc_compar) so that comparisons are based on
X	cpu ticks if the percentages are equal (provided by Jonathon
X	Feiber at Sun).
X
XTue Dec 11 1984 - wnl (1.7)
X	Added the virtual and real memory status line to the header area
X	(provided by Jonathon Feiber at Sun)
X
XTue Nov 20 1984 - wnl (1.6)
X	Added an "exit" if sbrk's fail.  Added changes from Jonathon
X	Feiber at Sun:  ifdef SUN to make top work on Suns (they don't use
X	doubles in the proc structure), register declarations, check for
X	getting a user structure that has disappeared since the proc array
X	was read (it used to die, now it just shows the process as swapped).
X
XTue Nov 13 1984 - wnl (1.5)
X	If the number of displayable processes ("active_procs") was less
X	than the number of requested processes ("topn"), top would
X	segmentation fault.  This bug has been fixed.  Thanks to Prentiss
X	Riddle at ut-sally for pointing out the existence of this bug.
X
XTue Oct 23 1984 - wnl (1.4)
X	Finally fixed the hash table bug that caused processes owned by
X	root to sometimes appear with either no name or a different name
X	that had UID 0 (such as "operator").  Removed all the ifdef DEBUG
X	blocks to make top ready for distribution to the real world.
X
XSun Apr  8 1984 - wnl (still 1.3)
X	Made some slight changes to the display format.  It now looks more
X	aesthetically pleasing.  Added some preprocessor constants so that
X	the two defaults (number of processes and seconds of delay) easier
X	to change.
X
XThu Apr  5 1984 - wnl (1.3)
X	Changed the order in which things are done at initialization time.
X	This way, if an error occurs before starting the main loop, curses
X	will never get started.  Also changed other error handlers so that
X	endwin() is called before any flavor of exit.  Specifying a number
X	of processes that is more than the screen can handle is no longer
X	fatal.  It displays a warning message and pretends the user
X	specified the maximum for the screen.  Finally cured all the TSTP
X	blues (well, almost all).  I removed my TSTP handler and convinced
X	the system to always use the one that curses sets up.  Turns out
X	that "sleep" was stepping all over it during a pause.  So, I don't
X	use sleep anymore.  The only problem that remains with it now is
X	redrawing the old display before updating it after a pause.
X
XTue Apr  3 1984 - wnl (from 1.0 to 1.2)
X	I changed the format of the TIME column from just "seconds" to
X	"minutes:seconds".  I also made pausing work correctly.  Screen
X	redraws with an up to date display.  For compatibility with 4.2, I
X	changed the name of the "zero" function to "bzero".  The makefile
X	has been altered to handle versions for 4.1 and 4.2, and README
X	has been updated to reflect these recent changes.
END_OF_FILE
if test 22408 -ne `wc -c <'Changes'`; then
    echo shar: \"'Changes'\" unpacked with wrong size!
fi
# end of 'Changes'
fi
if test -f 'machine/m_freebsd20.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machine/m_freebsd20.c'\"
else
echo shar: Extracting \"'machine/m_freebsd20.c'\" \(21760 characters\)
sed "s/^X//" >'machine/m_freebsd20.c' <<'END_OF_FILE'
X/*
X * top - a top users display for Unix
X *
X * SYNOPSIS:  For a FreeBSD-2.0 (4.4BSD) system
X *	      Note process resident sizes could be wrong, but ps shows
X *	      zero for them too..
X *
X * DESCRIPTION:
X * Originally written for BSD4.4 system by Christos Zoulas.
X * Ported to FreeBSD 2.0 by Steven Wallace && Wolfram Schneider
X *
X * This is the machine-dependent module for FreeBSD 2.0
X * Works for:
X *	FreeBSD 2.0
X *
X * LIBS: -lkvm
X *
X * AUTHOR:  Christos Zoulas <christos@ee.cornell.edu>
X *          Steven Wallace  <swallace@freebsd.org>
X *          Wolfram Schneider <wosch@cs.tu-berlin.de>
X *
X * $Id: machine.c,v 1.5 1995/01/06 02:04:39 swallace Exp $
X */
X
X
X
X#define LASTPID      /**/  /* use last pid, compiler depended */
X/* #define LASTPID_FIXED /**/ 
X#define VM_REAL      /**/  /* use the same values as vmstat -s */
X#define USE_SWAP     /**/  /* use swap usage (pstat -s), 
X                              need to much cpu time */
X/* #define DEBUG 1      /**/
X
X#include <sys/types.h>
X#include <sys/signal.h>
X#include <sys/param.h>
X
X#include "os.h"
X#include <stdio.h>
X#include <nlist.h>
X#include <math.h>
X#include <kvm.h>
X#include <sys/errno.h>
X#include <sys/sysctl.h>
X#include <sys/dir.h>
X#include <sys/dkstat.h>
X#include <sys/file.h>
X#include <sys/time.h>
X
X#ifdef USE_SWAP
X#include <stdlib.h>
X#include <sys/rlist.h>
X#include <sys/conf.h>
X#endif
X
Xstatic int check_nlist __P((struct nlist *));
Xstatic int getkval __P((unsigned long, int *, int, char *));
Xextern char* printable __P((char *));
X
X#include "top.h"
X#include "machine.h"
X
X
X/* get_process_info passes back a handle.  This is what it looks like: */
X
Xstruct handle
X{
X    struct kinfo_proc **next_proc;	/* points to next valid proc pointer */
X    int remaining;		/* number of pointers remaining */
X};
X
X/* declarations for load_avg */
X#include "loadavg.h"
X
X#define PP(pp, field) ((pp)->kp_proc . field)
X#define EP(pp, field) ((pp)->kp_eproc . field)
X#define VP(pp, field) ((pp)->kp_eproc.e_vm . field)
X
X/* define what weighted cpu is.  */
X#define weighted_cpu(pct, pp) (PP((pp), p_swtime) == 0 ? 0.0 : \
X			 ((pct) / (1.0 - exp(PP((pp), p_swtime) * logcpu))))
X
X/* what we consider to be process size: */
X#define PROCSIZE(pp) (VP((pp), vm_tsize) + VP((pp), vm_dsize) + VP((pp), vm_ssize))
X
X/* definitions for indices in the nlist array */
X
X
Xstatic struct nlist nlst[] = {
X#define X_CCPU		0
X    { "_ccpu" },		/* 0 */
X#define X_CP_TIME	1
X    { "_cp_time" },		/* 1 */
X#define X_HZ		2
X    { "_hz" },		        /* 2 */
X#define X_STATHZ	3
X    { "_stathz" },		/* 3 */
X#define X_AVENRUN	4
X    { "_averunnable" },		/* 4 */
X#ifdef USE_SWAP
X#define VM_SWAPLIST	5
X	{ "_swaplist" },/* list of free swap areas */
X#define VM_SWDEVT	6
X	{ "_swdevt" },	/* list of swap devices and sizes */
X#define VM_NSWAP	7
X	{ "_nswap" },	/* size of largest swap device */
X#define VM_NSWDEV	8
X	{ "_nswdev" },	/* number of swap devices */
X#define VM_DMMAX	9
X	{ "_dmmax" },	/* maximum size of a swap block */
X#endif
X#ifdef VM_REAL
X#ifdef USE_SWAP
X#define X_CNT           10
X#else
X#define X_CNT           5
X#endif
X    { "_cnt" },		        /* struct vmmeter cnt */
X#endif
X
X#ifdef LASTPID
X#if (defined USE_SWAP && defined VM_REAL)
X#define X_LASTPID	11
X#elif (defined VM_REAL)
X#define X_LASTPID	6
X#else
X#define X_LASTPID       5
X#endif
X#ifdef LASTPID_FIXED
X    { "_nextpid" },		
X#else
X    { "_nextpid.178" },		/* lastpid, compiler depended 
X				 * should be changed 
X				 * in /sys/kern/kern_fork.c */
X#endif
X#endif
X
X    { 0 }
X};
X
X/*
X *  These definitions control the format of the per-process area
X */
X
Xstatic char header[] =
X  "  PID X        PRI NICE   SIZE   RES STATE   TIME   WCPU    CPU COMMAND";
X/* 0123456   -- field to fill in starts at header+6 */
X#define UNAME_START 6
X
X#define Proc_format \
X	"%5d %-8.8s %3d %4d%7s %5s %-5s%7s %5.2f%% %5.2f%% %.14s"
X
X
X/* process state names for the "STATE" column of the display */
X/* the extra nulls in the string "run" are for adding a slash and
X   the processor number when needed */
X
Xchar *state_abbrev[] =
X{
X    "", "start", "run\0\0\0", "sleep", "stop", "zomb", "WAIT"
X};
X
X
Xstatic kvm_t *kd;
X
X/* values that we stash away in _init and use in later routines */
X
Xstatic double logcpu;
X
X/* these are retrieved from the kernel in _init */
X
Xstatic          long hz;
Xstatic load_avg  ccpu;
X
X/* these are offsets obtained via nlist and used in the get_ functions */
X
Xstatic unsigned long cp_time_offset;
Xstatic unsigned long avenrun_offset;
X#ifdef LASTPID
Xstatic unsigned long lastpid_offset;
Xstatic long lastpid;
X#endif
X#ifdef VM_REAL
Xstatic unsigned long cnt_offset;
Xstatic long cnt;
X#endif
X/* these are for calculating cpu state percentages */
X
Xstatic long cp_time[CPUSTATES];
Xstatic long cp_old[CPUSTATES];
Xstatic long cp_diff[CPUSTATES];
X
X/* these are for detailing the process states */
X
Xint process_states[7];
Xchar *procstatenames[] = {
X    "", " starting, ", " running, ", " sleeping, ", " stopped, ",
X    " zombie, ", " ABANDONED, ",
X    NULL
X};
X
X/* these are for detailing the cpu states */
X
Xint cpu_states[CPUSTATES];
Xchar *cpustatenames[] = {
X    "user", "nice", "system", "interrupt", "idle", NULL
X};
X
X/* these are for detailing the memory statistics */
X
Xint memory_stats[8];
Xchar *memorynames[] = {
X#ifndef VM_REAL
X    "Real: ", "K/", "K ", "Virt: ", "K/",
X    "K ", "Free: ", "K", NULL
X#else
X#if 0
X    "K Act ", "K Inact ", "K Wired ", "K Free ", "% Swap, ",
X    "K/", "K SWIO", 
X#else
X    "K Act ", "K Inact ", "K Wired ", "K Free ", "% Swap, ",
X    "Kin ", "Kout", 
X#endif
X    NULL
X#endif
X};
X
X/* these are for keeping track of the proc array */
X
Xstatic int nproc;
Xstatic int onproc = -1;
Xstatic int pref_len;
Xstatic struct kinfo_proc *pbase;
Xstatic struct kinfo_proc **pref;
X
X/* these are for getting the memory statistics */
X
Xstatic int pageshift;		/* log base 2 of the pagesize */
X
X/* define pagetok in terms of pageshift */
X
X#define pagetok(size) ((size) << pageshift)
X
X/* useful externals */
Xlong percentages();
X
Xint
Xmachine_init(statics)
X
Xstruct statics *statics;
X
X{
X    register int i = 0;
X    register int pagesize;
X
X    if ((kd = kvm_open(NULL, NULL, NULL, O_RDONLY, "kvm_open")) == NULL)
X	return -1;
X
X
X    /* get the list of symbols we want to access in the kernel */
X    (void) kvm_nlist(kd, nlst);
X    if (nlst[0].n_type == 0)
X    {
X	fprintf(stderr, "top: nlist failed\n");
X	return(-1);
X    }
X
X    /* make sure they were all found */
X    if (i > 0 && check_nlist(nlst) > 0)
X    {
X	return(-1);
X    }
X
X    /* get the symbol values out of kmem */
X    (void) getkval(nlst[X_STATHZ].n_value, (int *)(&hz), sizeof(hz), "!");
X    if (!hz) {
X	(void) getkval(nlst[X_HZ].n_value, (int *)(&hz), sizeof(hz),
X		       nlst[X_HZ].n_name);
X    }
X
X
X#if (defined DEBUG)
X    fprintf(stderr, "Hertz: %d\n", hz); 
X#endif
X
X    (void) getkval(nlst[X_CCPU].n_value,   (int *)(&ccpu),	sizeof(ccpu),
X	    nlst[X_CCPU].n_name);
X
X    /* stash away certain offsets for later use */
X    cp_time_offset = nlst[X_CP_TIME].n_value;
X    avenrun_offset = nlst[X_AVENRUN].n_value;
X#ifdef LASTPID
X    lastpid_offset =  nlst[X_LASTPID].n_value;
X#endif
X#ifdef VM_REAL
X    cnt_offset = nlst[X_CNT].n_value;
X#endif
X
X    /* this is used in calculating WCPU -- calculate it ahead of time */
X    logcpu = log(loaddouble(ccpu));
X
X    pbase = NULL;
X    pref = NULL;
X    nproc = 0;
X    onproc = -1;
X    /* get the page size with "getpagesize" and calculate pageshift from it */
X    pagesize = getpagesize();
X    pageshift = 0;
X    while (pagesize > 1)
X    {
X	pageshift++;
X	pagesize >>= 1;
X    }
X
X    /* we only need the amount of log(2)1024 for our conversion */
X    pageshift -= LOG1024;
X
X    /* fill in the statics information */
X    statics->procstate_names = procstatenames;
X    statics->cpustate_names = cpustatenames;
X    statics->memory_names = memorynames;
X
X    /* all done! */
X    return(0);
X}
X
Xchar *format_header(uname_field)
X
Xregister char *uname_field;
X
X{
X    register char *ptr;
X
X    ptr = header + UNAME_START;
X    while (*uname_field != '\0')
X    {
X	*ptr++ = *uname_field++;
X    }
X
X    return(header);
X}
X
Xstatic int swappgsin = -1;
Xstatic int swappgsout = -1;
Xextern struct timeval timeout;
X
Xvoid
Xget_system_info(si)
X
Xstruct system_info *si;
X
X{
X    long total;
X    load_avg avenrun[3];
X
X    /* get the cp_time array */
X    (void) getkval(cp_time_offset, (int *)cp_time, sizeof(cp_time),
X		   nlst[X_CP_TIME].n_name);
X    (void) getkval(avenrun_offset, (int *)avenrun, sizeof(avenrun),
X		   nlst[X_AVENRUN].n_name);
X
X#ifdef LASTPID
X    (void) getkval(lastpid_offset, (int *)(&lastpid), sizeof(lastpid),
X		   "!");
X#endif
X
X    /* convert load averages to doubles */
X    {
X	register int i;
X	register double *infoloadp;
X	load_avg *avenrunp;
X
X#ifdef notyet
X	struct loadavg sysload;
X	int size;
X	getkerninfo(KINFO_LOADAVG, &sysload, &size, 0);
X#endif
X
X	infoloadp = si->load_avg;
X	avenrunp = avenrun;
X	for (i = 0; i < 3; i++)
X	{
X#ifdef notyet
X	    *infoloadp++ = ((double) sysload.ldavg[i]) / sysload.fscale;
X#endif
X	    *infoloadp++ = loaddouble(*avenrunp++);
X	}
X    }
X
X    /* convert cp_time counts to percentages */
X    total = percentages(CPUSTATES, cpu_states, cp_time, cp_old, cp_diff);
X
X    /* sum memory statistics */
X    {
X
X#ifndef VM_REAL
X	struct vmtotal total;
X	int size = sizeof(total);
X	static int mib[] = { CTL_VM, VM_METER };
X
X	/* get total -- systemwide main memory usage structure */
X	if (sysctl(mib, 2, &total, &size, NULL, 0) < 0) {
X	    (void) fprintf(stderr, "top: sysctl failed: %s\n", strerror(errno));
X	    bzero(&total, sizeof(total));
X	}
X	/* convert memory stats to Kbytes */
X	memory_stats[0] = -1;
X	memory_stats[1] = pagetok(total.t_arm);
X	memory_stats[2] = pagetok(total.t_rm);
X	memory_stats[3] = -1;
X	memory_stats[4] = pagetok(total.t_avm);
X	memory_stats[5] = pagetok(total.t_vm);
X	memory_stats[6] = -1;
X	memory_stats[7] = pagetok(total.t_free);
X    }
X#else
X	struct vmmeter sum;
X	static unsigned int swap_delay = 0;
X
X        (void) getkval(cnt_offset, (int *)(&sum), sizeof(sum),
X		   "_cnt");
X
X	/* convert memory stats to Kbytes */
X	memory_stats[0] = pagetok(sum.v_active_count);
X	memory_stats[1] = pagetok(sum.v_inactive_count);
X	memory_stats[2] = pagetok(sum.v_wire_count);
X	memory_stats[3] = pagetok(sum.v_free_count);
X
X        if (swappgsin < 0) {
X	    memory_stats[5] = 0;
X	    memory_stats[6] = 0;
X	} else {
X	    memory_stats[5] = pagetok(((sum.v_swappgsin - swappgsin)));
X	    memory_stats[6] = pagetok(((sum.v_swappgsout - swappgsout)));
X	}
X        swappgsin = sum.v_swappgsin;
X	swappgsout = sum.v_swappgsout;
X
X#ifdef USE_SWAP
X        if ((memory_stats[5] > 0 || memory_stats[6]) > 0 || swap_delay == 0) {
X	    memory_stats[4] = swapmode();
X	}
X        swap_delay++;
X#else
X        memory_stats[4] = 0;
X#endif
X
X
X	memory_stats[7] = -1;
X    }
X#endif
X    /* set arrays and strings */
X    si->cpustates = cpu_states;
X    si->memory = memory_stats;
X#ifdef LASTPID
X    if(lastpid > 0) {
X	si->last_pid = lastpid;
X    } else {
X	si->last_pid = -1;
X    }
X#else
X    si->last_pid = -1;
X#endif
X
X}
X
Xstatic struct handle handle;
X
Xcaddr_t get_process_info(si, sel, compare)
X
Xstruct system_info *si;
Xstruct process_select *sel;
Xint (*compare)();
X
X{
X    register int i;
X    register int total_procs;
X    register int active_procs;
X    register struct kinfo_proc **prefp;
X    register struct kinfo_proc *pp;
X
X    /* these are copied out of sel for speed */
X    int show_idle;
X    int show_system;
X    int show_uid;
X    int show_command;
X
X    
X    pbase = kvm_getprocs(kd, KERN_PROC_ALL, 0, &nproc);
X    if (nproc > onproc)
X	pref = (struct kinfo_proc **) realloc(pref, sizeof(struct kinfo_proc *)
X		* (onproc = nproc));
X    if (pref == NULL || pbase == NULL) {
X	(void) fprintf(stderr, "top: Out of memory.\n");
X	quit(23);
X    }
X    /* get a pointer to the states summary array */
X    si->procstates = process_states;
X
X    /* set up flags which define what we are going to select */
X    show_idle = sel->idle;
X    show_system = sel->system;
X    show_uid = sel->uid != -1;
X    show_command = sel->command != NULL;
X
X    /* count up process states and get pointers to interesting procs */
X    total_procs = 0;
X    active_procs = 0;
X    memset((char *)process_states, 0, sizeof(process_states));
X    prefp = pref;
X    for (pp = pbase, i = 0; i < nproc; pp++, i++)
X    {
X	/*
X	 *  Place pointers to each valid proc structure in pref[].
X	 *  Process slots that are actually in use have a non-zero
X	 *  status field.  Processes with P_SYSTEM set are system
X	 *  processes---these get ignored unless show_sysprocs is set.
X	 */
X	if (PP(pp, p_stat) != 0 &&
X	    (show_system || ((PP(pp, p_flag) & P_SYSTEM) == 0)))
X	{
X	    total_procs++;
X	    process_states[(unsigned char) PP(pp, p_stat)]++;
X	    if ((PP(pp, p_stat) != SZOMB) &&
X		(show_idle || (PP(pp, p_pctcpu) != 0) || 
X		 (PP(pp, p_stat) == SRUN)) &&
X		(!show_uid || EP(pp, e_pcred.p_ruid) == (uid_t)sel->uid))
X	    {
X		*prefp++ = pp;
X		active_procs++;
X	    }
X	}
X    }
X
X    /* if requested, sort the "interesting" processes */
X    if (compare != NULL)
X    {
X	qsort((char *)pref, active_procs, sizeof(struct kinfo_proc *), compare);
X    }
X
X    /* remember active and total counts */
X    si->p_total = total_procs;
X    si->p_active = pref_len = active_procs;
X
X    /* pass back a handle */
X    handle.next_proc = pref;
X    handle.remaining = active_procs;
X    return((caddr_t)&handle);
X}
X
Xchar fmt[128];		/* static area where result is built */
X
Xchar *format_next_process(handle, get_userid)
X
Xcaddr_t handle;
Xchar *(*get_userid)();
X
X{
X    register struct kinfo_proc *pp;
X    register long cputime;
X    register double pct;
X    struct handle *hp;
X
X    /* find and remember the next proc structure */
X    hp = (struct handle *)handle;
X    pp = *(hp->next_proc++);
X    hp->remaining--;
X    
X
X    /* get the process's user struct and set cputime */
X    if ((PP(pp, p_flag) & P_INMEM) == 0) {
X	/*
X	 * Print swapped processes as <pname>
X	 */
X	char *comm = PP(pp, p_comm);
X#define COMSIZ sizeof(PP(pp, p_comm))
X	char buf[COMSIZ];
X	(void) strncpy(buf, comm, COMSIZ);
X	comm[0] = '<';
X	(void) strncpy(&comm[1], buf, COMSIZ - 2);
X	comm[COMSIZ - 2] = '\0';
X	(void) strncat(comm, ">", COMSIZ - 1);
X	comm[COMSIZ - 1] = '\0';
X    }
X
X#if 0
X    /* This does not produce the correct results */
X    cputime = PP(pp, p_uticks) + PP(pp, p_sticks) + PP(pp, p_iticks);
X#endif
X    cputime = PP(pp, p_rtime).tv_sec;	/* This does not count interrupts */
X
X    /* calculate the base for cpu percentages */
X    pct = pctdouble(PP(pp, p_pctcpu));
X
X    /* format this entry */
X    sprintf(fmt,
X	    Proc_format,
X	    PP(pp, p_pid),
X	    (*get_userid)(EP(pp, e_pcred.p_ruid)),
X	    PP(pp, p_priority) - PZERO,
X	    PP(pp, p_nice) - NZERO,
X	    format_k(pagetok(PROCSIZE(pp))),
X	    format_k(pagetok(VP(pp, vm_rssize))),
X	    state_abbrev[(unsigned char) PP(pp, p_stat)],
X	    format_time(cputime),
X	    10000.0 * weighted_cpu(pct, pp) / hz,
X	    10000.0 * pct / hz,
X	    printable(PP(pp, p_comm)));
X
X    /* return the result */
X    return(fmt);
X}
X
X
X/*
X * check_nlist(nlst) - checks the nlist to see if any symbols were not
X *		found.  For every symbol that was not found, a one-line
X *		message is printed to stderr.  The routine returns the
X *		number of symbols NOT found.
X */
X
Xstatic int check_nlist(nlst)
X
Xregister struct nlist *nlst;
X
X{
X    register int i;
X
X    /* check to see if we got ALL the symbols we requested */
X    /* this will write one line to stderr for every symbol not found */
X
X    i = 0;
X    while (nlst->n_name != NULL)
X    {
X	if (nlst->n_type == 0)
X	{
X	    /* this one wasn't found */
X	    (void) fprintf(stderr, "kernel: no symbol named `%s'\n",
X			   nlst->n_name);
X	    i = 1;
X	}
X	nlst++;
X    }
X
X    return(i);
X}
X
X
X/*
X *  getkval(offset, ptr, size, refstr) - get a value out of the kernel.
X *	"offset" is the byte offset into the kernel for the desired value,
X *  	"ptr" points to a buffer into which the value is retrieved,
X *  	"size" is the size of the buffer (and the object to retrieve),
X *  	"refstr" is a reference string used when printing error meessages,
X *	    if "refstr" starts with a '!', then a failure on read will not
X *  	    be fatal (this may seem like a silly way to do things, but I
X *  	    really didn't want the overhead of another argument).
X *  	
X */
X
Xstatic int getkval(offset, ptr, size, refstr)
X
Xunsigned long offset;
Xint *ptr;
Xint size;
Xchar *refstr;
X
X{
X    if (kvm_read(kd, offset, (char *) ptr, size) != size)
X    {
X	if (*refstr == '!')
X	{
X	    return(0);
X	}
X	else
X	{
X	    fprintf(stderr, "top: kvm_read for %s: %s\n",
X		refstr, strerror(errno));
X	    quit(23);
X	}
X    }
X    return(1);
X}
X    
X/* comparison routine for qsort */
X
X/*
X *  proc_compare - comparison function for "qsort"
X *	Compares the resource consumption of two processes using five
X *  	distinct keys.  The keys (in descending order of importance) are:
X *  	percent cpu, cpu ticks, state, resident set size, total virtual
X *  	memory usage.  The process states are ordered as follows (from least
X *  	to most important):  WAIT, zombie, sleep, stop, start, run.  The
X *  	array declaration below maps a process state index into a number
X *  	that reflects this ordering.
X */
X
Xstatic unsigned char sorted_state[] =
X{
X    0,	/* not used		*/
X    3,	/* sleep		*/
X    1,	/* ABANDONED (WAIT)	*/
X    6,	/* run			*/
X    5,	/* start		*/
X    2,	/* zombie		*/
X    4	/* stop			*/
X};
X 
Xint
Xproc_compare(pp1, pp2)
X
Xstruct proc **pp1;
Xstruct proc **pp2;
X
X{
X    register struct kinfo_proc *p1;
X    register struct kinfo_proc *p2;
X    register int result;
X    register pctcpu lresult;
X
X    /* remove one level of indirection */
X    p1 = *(struct kinfo_proc **) pp1;
X    p2 = *(struct kinfo_proc **) pp2;
X
X    /* compare percent cpu (pctcpu) */
X    if ((lresult = PP(p2, p_pctcpu) - PP(p1, p_pctcpu)) == 0)
X    {
X	/* use cpticks to break the tie */
X	if ((result = PP(p2, p_cpticks) - PP(p1, p_cpticks)) == 0)
X	{
X	    /* use process state to break the tie */
X	    if ((result = sorted_state[(unsigned char) PP(p2, p_stat)] -
X			  sorted_state[(unsigned char) PP(p1, p_stat)])  == 0)
X	    {
X		/* use priority to break the tie */
X		if ((result = PP(p2, p_priority) - PP(p1, p_priority)) == 0)
X		{
X		    /* use resident set size (rssize) to break the tie */
X		    if ((result = VP(p2, vm_rssize) - VP(p1, vm_rssize)) == 0)
X		    {
X			/* use total memory to break the tie */
X			result = PROCSIZE(p2) - PROCSIZE(p1);
X		    }
X		}
X	    }
X	}
X    }
X    else
X    {
X	result = lresult < 0 ? -1 : 1;
X    }
X
X    return(result);
X}
X
X
X/*
X * proc_owner(pid) - returns the uid that owns process "pid", or -1 if
X *		the process does not exist.
X *		It is EXTREMLY IMPORTANT that this function work correctly.
X *		If top runs setuid root (as in SVR4), then this function
X *		is the only thing that stands in the way of a serious
X *		security problem.  It validates requests for the "kill"
X *		and "renice" commands.
X */
X
Xint proc_owner(pid)
X
Xint pid;
X
X{
X    register int cnt;
X    register struct kinfo_proc **prefp;
X    register struct kinfo_proc *pp;
X
X    prefp = pref;
X    cnt = pref_len;
X    while (--cnt >= 0)
X    {
X	pp = *prefp++;	
X	if (PP(pp, p_pid) == (pid_t)pid)
X	{
X	    return((int)EP(pp, e_pcred.p_ruid));
X	}
X    }
X    return(-1);
X}
X
X
X#ifdef USE_SWAP
X/*
X * swapmode is based on a program called swapinfo written
X * by Kevin Lahey <kml@rokkaku.atl.ga.us>.
X */
X
X#define	SVAR(var) __STRING(var)	/* to force expansion */
X#define	KGET(idx, var)							\
X	KGET1(idx, &var, sizeof(var), SVAR(var))
X#define	KGET1(idx, p, s, msg)						\
X	KGET2(nlst[idx].n_value, p, s, msg)
X#define	KGET2(addr, p, s, msg)						\
X	if (kvm_read(kd, (u_long)(addr), p, s) != s)			\
X		warnx("cannot read %s: %s", msg, kvm_geterr(kd))
X#define	KGETRET(addr, p, s, msg)					\
X	if (kvm_read(kd, (u_long)(addr), p, s) != s) {			\
X		warnx("cannot read %s: %s", msg, kvm_geterr(kd));	\
X		return (0);						\
X	}
X
X
Xint
Xswapmode()
X{
X	char *header;
X	int hlen, nswap, nswdev, dmmax;
X	int i, div, avail, nfree, npfree, used;
X	struct swdevt *sw;
X	long blocksize, *perdev;
X	struct rlist head;
X	struct rlist *swaplist;
X
X	KGET(VM_NSWAP, nswap);
X	KGET(VM_NSWDEV, nswdev);
X	KGET(VM_DMMAX, dmmax);
X	KGET(VM_SWAPLIST, swaplist);
X	if ((sw = (struct swdevt *)malloc(nswdev * sizeof(*sw))) == NULL ||
X	    (perdev = (long *)malloc(nswdev * sizeof(*perdev))) == NULL)
X		err(1, "malloc");
X	KGET1(VM_SWDEVT, sw, nswdev * sizeof(*sw), "swdevt");
X
X	/* Count up swap space. */
X	nfree = 0;
X	memset(perdev, 0, nswdev * sizeof(*perdev));
X	while (swaplist) {
X		int	top, bottom, next_block;
X
X		KGET2(swaplist, &head, sizeof(struct rlist), "swaplist");
X
X		top = head.rl_end;
X		bottom = head.rl_start;
X
X		nfree += top - bottom + 1;
X
X		/*
X		 * Swap space is split up among the configured disks.
X		 *
X		 * For interleaved swap devices, the first dmmax blocks
X		 * of swap space some from the first disk, the next dmmax
X		 * blocks from the next, and so on up to nswap blocks.
X		 *
X		 * The list of free space joins adjacent free blocks,
X		 * ignoring device boundries.  If we want to keep track
X		 * of this information per device, we'll just have to
X		 * extract it ourselves.
X		 */
X		while (top / dmmax != bottom / dmmax) {
X			next_block = ((bottom + dmmax) / dmmax);
X			perdev[(bottom / dmmax) % nswdev] +=
X				next_block * dmmax - bottom;
X			bottom = next_block * dmmax;
X		}
X		perdev[(bottom / dmmax) % nswdev] +=
X			top - bottom + 1;
X
X		swaplist = head.rl_next;
X	}
X
X	header = getbsize(&hlen, &blocksize);
X	div = blocksize / 512;
X	avail = npfree = 0;
X	for (i = 0; i < nswdev; i++) {
X		int xsize, xfree;
X
X		/*
X		 * Don't report statistics for partitions which have not
X		 * yet been activated via swapon(8).
X		 */
X
X		xsize = sw[i].sw_nblks;
X		xfree = perdev[i];
X		used = xsize - xfree;
X		npfree++;
X		avail += xsize;
X	}
X
X	/* 
X	 * If only one partition has been set up via swapon(8), we don't
X	 * need to bother with totals.
X	 */
X	used = avail - nfree;
X	free(sw); free(perdev);
X	return  (int)(((double)used / (double)avail * 100.0) + 0.5);
X}
X
X#endif
X
END_OF_FILE
if test 21760 -ne `wc -c <'machine/m_freebsd20.c'`; then
    echo shar: \"'machine/m_freebsd20.c'\" unpacked with wrong size!
fi
# end of 'machine/m_freebsd20.c'
fi
echo shar: End of archive 14 \(of 16\).
cp /dev/null ark14isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 16 archives.
    echo "Now read README and INSTALL, then run Configure"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
