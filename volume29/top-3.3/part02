Newsgroups: comp.sources.unix
From: lefebvre@athens.dis.anl.gov (William LeFebvre)
Subject: v29i002: top-3.3 - top users display, V3.3, Part02/16
References: <1.801816033.16454@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: lefebvre@athens.dis.anl.gov (William LeFebvre)
Posting-Number: Volume 29, Issue 2
Archive-Name: top-3.3/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 16)."
# Contents:  FAQ INSTALL Porting m-template screen.c utils.c
# Wrapped by lefebvre@athens on Thu Mar  2 11:39:39 1995
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'FAQ' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'FAQ'\"
else
echo shar: Extracting \"'FAQ'\" \(6782 characters\)
sed "s/^X//" >'FAQ' <<'END_OF_FILE'
X                             TOP
X                         Version 3.3
X
X                       William LeFebvre
X		     and a cast of dozens
X
X
XFREQUENTLY ASKED QUESTIONS AND THEIR ANSWERS
X
X1. "We just upgraded our operating system to version 99.9.9.9 and top
X   broke.  What should we do?"
X
X   Recompile.  Top is very sensitive to changes in internal kernel data
X   structures.  It is not uncommon for a new version of the operating
X   system to include changes to kernel data structures.
X
X2. "I tried compiling top under SunOS version 4.1.3 and it got compile
X   time errors.  Is there a patch?"
X
X   If you try compiling top in a "System V environment" under SunOS
X   (that is, /usr/5bin is before /usr/bin on your path) then the 
X   compilation will fail.  This is mostly due to the fact that top
X   thinks its being compiled on a System V machine when it really isn't.
X   The only solution is to put /usr/bin and /usr/ucb before /usr/5bin
X   on your path and try again.
X
X3. "Under Solaris 2, when I run top as root it only shows root processes.
X   It refuses to show anything else.  What do I do?"
X
X   You probably compiled it with /usr/ucb/cc instead of the real C
X   compiler.  /usr/ucb/cc is a cc front end that compiles programs in
X   BSD source-level compatability mode.  You do not want that.  Make
X   sure that /usr/ucb is not on your path and try compiling top again.
X
X4. "Under Solaris 2, when I try to run top it complains that it can't
X   open the library "libucb.so.1".  So I changed the LIBS line in
X   m_sunos5.c to include -R/usr/ucblib to make sure that the dynamic
X   linker will look there when top runs.  I figured this was just an
X   oversight.  Was I right?"
X
X   No, you were not right.  As distributed, top requires NO alterations
X   for successful compilation and operations under Solaris 2.0, 2.1, 2.2,
X   2.3, and 2.4.  You probably compiled top with /usr/ucb/cc instead of
X   the real C compiler.  See FAQ #3 for more details.
X
X5. "Top is (not) displaying idle processes and I don't (do) want it to."
X
X   This default has only changed about a dozen times, and I finally got
X   tired of people whining about it.  Go read the manual page for the
X   current version and pay special attention to the description of the
X   "TOP" environment variable.
X
X6. "We have so much memory in our machine that the memory status display
X   (the fourth line) ends up being longer than 80 characters.  This
X   completely messes up top's output.  Is there a patch?"
X
X   Most modules have been changed to use new memory formatting functions
X   which will display large values in terms of megabytes instead of
X   kilobytes.  This should fix all occurences of this problem.  If you
X   encounter a system where this large memory display overflow is still
X   occurring, please let me know (send mail to <lefebvre@dis.anl.gov>).
X
X7. "When I run top on my SVR4-derived operating system, it displays all
X   the system information at the top but does not display any process
X   information (or only displayes process information for my own
X   processes).  Yet when I run it as root, everything works fine."
X
X   Your system probably uses the pseudo file system "/proc", which is
X   by default only accessible by root.  Top needs to be installed setuid
X   root on such systems if it is going to function correctly for normal
X   users.
X
X8. "Configure said that it saw /proc and is recommending that I install
X   top setuid root.  Is there any way around this?  Is it safe?"
X
X   There is no way around it.  Complain to POSIX.  Every effort has been
X   made to make top a secure setuid program.  However, we cannot guarantee
X   that there are no security problems associated with this configuration.
X   The places where top is most vulnerable are the builtin kill and renice
X   commands.  There is no internal top command that causes top to start
X   a shell as a subprocess.  Some SVR4 systems may contain a bug that
X   enables a user to renice his own processes downward (to lower nice
X   values that are more favorable for the process).  This problem has
X   been fixed for the Solaris 2.x modules, but may still exist in others.
X   We will hopefully fix this up in the next release.
X
X9. "Top is not showing the command names.  Everything else is fine, just
X   no command names.  What's wrong?"
X
X   This usually occurs when top is compiled under one revision of the
X   operating system (say SunOS 4.1.3) but run under another (say
X   SunOS 4.1.3C_U1_B3_V9_Z47_*HIKE*).  What has happened is that the
X   user structure is different, and the location of the array that
X   contains the command name is not at the same offset.  Other than
X   maintaining separate executables for every variant of the operating
X   system, there is little you can do about this.  This will also occur
X   if you compile top on one machine sub-architecture (i.e.: sun4c) and
X   try to run the resulting executable on a different sub-architecture
X   (i.e.: sun4m).  Read "INSTALL" for more details.
X
X10."Is there a module that will make top work under AIX?"
X
X   Not at the current time.  Many people have started this project but
X   none have yet to finish.  That may say something about the difficulty
X   of the task......
X
X11."I tried to compile top with gcc and it doesn't work (either compilation
X   errors in the include files or a non-working executable).  What's wrong?"
X
X   Gnu CC likes very much to use its own include files.  Not being a gcc
X   expert, I can't explain why it does this.  But I can tell you that 
X   if you upgrade your operating system (say from SunOS 4.1.2 to SunOS
X   4.1.3) after installing gcc, then the include files that gcc uses will
X   be incorrect, especially those found in the "sys" directory.  Your
X   choices are:  (1) rebuild and reinstall the "standard" include files
X   for gcc (no I don't know how to do this), (2) compile machine.c with
X   "CFLAGS=-I/usr/include" then make the rest of the object files
X   normally, or (3) use "cc".
X
X12."Top is not written in ANSI C.  Do you ever plan to change that?"
X
X   Top predates ANSI C by about 5 years.  Yeah, it'll get "fixed"
X   eventually (if you can call that "fixing").  Maybe in 3.4, maybe
X   not until 4.0.  I'm not big on standards.
X
X13."To whom do I report problems with top?"
X
X   First, look through all the FAQ answers.  Chances are an answer to
X   your question can be found in this file.  If you still have an
X   unanswered question, you can send mail to "lefebvre@dis.anl.gov".
X   If it looks like the problem is machine-specific, I will forward the
X   report along to the module's author.  If you would like to converse
X   directly with the module author, the authors' names are listed at the
X   beginning of the module .c file in the "machine" directory.
X
X14."Are you superstitious?"
X
X   Not usually, no.   :-)
END_OF_FILE
if test 6782 -ne `wc -c <'FAQ'`; then
    echo shar: \"'FAQ'\" unpacked with wrong size!
fi
# end of 'FAQ'
fi
if test -f 'INSTALL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'INSTALL'\"
else
echo shar: Extracting \"'INSTALL'\" \(7606 characters\)
sed "s/^X//" >'INSTALL' <<'END_OF_FILE'
X                             TOP
X                     Version 3.3 and later
X
X                       William LeFebvre
X		     and a cast of dozens
X
XINSTALLATION
X
XConfiguration and installation of top is very straightforward.  After
Xunpacking the sources, run the script "Configure".  It will present you
Xwith a series of questions, all of which should be explained in the
Xpresentation.  After you have answered all the questions, "Configure" will
Xperform all the necessary configuration.  Once this is finished, type
X"make install".  Make will compile the sources then install the resulting
Xexecutable and manual page in the appropriate places.
X
XThe most difficult step in the configuration is the choice of an
Xappropriate machine-specific module.  The Configure script gives you a
Xlist of choices complete with brief descriptions of when each choice is
Xappropriate.  Each module is contained in a separate c file in the
Xdirectory "machine".  The module contains all of the machine-specific code
Xthat makes top work correctly on the architecture in question.  All of the
Xcode in the top-level directory is machine-independent (or at least
Xstrives to be).  Hints for some module choices that are not obvious are
Xgiven at the end of this file.
X
XThe first comment in each c file in that directory contains the synopsis
XAND a detailed description of the machines for which that module is
Xappropriate.  It also contains a list of authors for that module.  If you
Xare really stumped in this choice, use grep to find your machine
Xmanufacturer's name or operating system name in machine/*.c.  If you still
Xcan't find one that is appropriate, then chances are very good that one
Xhasn't been written yet.  If that is the case, then you are out of luck.
X
XHANDLING MULTIPLE ARCHITECTURES
X
XIf you need to recompile top for a different architecture (that is, using
Xa different module) you need to reconfigure top.  A short cut is available
Xto make this a little easier.  If all of your previous answers to the
Xconfiguration questions (except for the module name of course) are
Xadequate for the new architecture, then you can just use the command
X"Configure <modulename>".  The configuration script will reconfigure top
Xusing the new module and all the answers you gave last time.  It will
Xfinish with a "make clean".  Once that completes, type "make install"
Xand make will compile the sources and do the installation.
X
XHANDLING MULTIPLE OS VERSIONS
X
XBy far the most frequently received bug report for top is something like
Xthis: "We just upgraded our operating system to version 99.9.9.9 and top
Xbroke.  What should we do?"  The simple answer is "recompile".
X
XTop is very sensitive to changes in internal kernel data structures
X(especially the proc and user structures).  Some operating systems
X(especially SunOS) are notorious for changing these structure in every
Xminor release of the OS.  This means that a top executable made under one
Xversion of the OS will not always work correctly (if even at all) under
Xanother version.  This is just one of those tough facts of life.  There is
Xreally no way around it.
X
XTo make life even worse, some operating systems (SunOS again) will use
Xslightly different proc and user structures on different models.  For
Xexample, "top" built on a SparcStation 2 will not run correctly on a
XSparcStation 10, even if they are both running SunOS 4.1.3.  These
Xunfortunate circumstances make maintaining top very difficult, especially
Xin an environment that runs several different versions of the same
Xoperating system.
X
XBut there is hope.  If your operating system has a properly functioning
X"uname" command then you can handle this problem rather gracefully.
XIncluded in the distribution is a shell file called "metatop".  All this
Xshell file does is:
X
X	exec top-`uname -m`-`uname -r` "$@"
X
XSo when you run this script, it execs a filename that is unique to your
Xspecific machine architecture and your OS revision number.
X
XTo use "metatop", do the following:
X
X	. on any machine, run Configure and choose the module that is
X	  appropriate for the machine
X	. for all machines which use the same module:
X	    . group machines according to machine architecture AND OS
X	      revision number (i.e.: sun4-4.1.1, sun4c-4.1.1, sun4c-4.1.2,
X	      sun4-4.1.3, sun4c-4.1.3, sun4m-4.1.3, ...)
X	    . for each group, choose one machine from that group and on it
X	      run "make clean; make installmeta".
X
X
XThe "installmeta" rule in the makefile will insure that top is compiled,
Xinstall the shell file "metatop" as "top", then install the executable
X"top" with a name appropriate to the machine architecture and OS revision.
X
X
XHINTS FOR CHOOSING THE CORRECT MODULE:
X
XSUN MULTIPROCESSOR ARCHITECTURES
X
XFirst, we need to be speaking the same language:
X
Xsun4	a regular sparc sun 4 architecture machine (sparc station 1,
X	sparc station 2, IPC, SLC, etc.)
X
Xsun4m	a multiprocessor sparc (Sparc 10, 4/670, 4/690)
X
XI intended to write the sunos4 module so that an executable compiled on a
Xsun4m machine would work correctly on a sun4 machine.  Unfortunately my
Xexperiments indicate that this cannot be done.  It turns out that the user
Xstructure is so different between these two architectures that nothing
Xshort of a serious hack will make the same executable work correctly on
Xboth machines.  I recommend that you use the separate module "sunos4mp"
Xwhen making an executable for a sun4m architecture, and use "sunos4" when
Xmaking an executable for sun4 or sun4c architectures.
X
XSOLBOURNE OPERATING SYSTEM (OS/MP)
X
XIf you are running OS/MP version 4.1A, then use the module "osmp4.1a".
X
XIf you are running a version of OS/MP OLDER than 4.1A (that is, one
Xof its predecessors), use the module "sunos4".
X
XIf you are running OS/MP 4.1B or LATER, use the module "sunos4mp".
X
XHP/UX OPERATING SYSTEM
X
XThe module hpux8 works on all version 8 systems.  Some say that it works
Xwith version 9 as well, but one user did send me a separate module for
Xversion 9.  This module has only been tested on series 800 machines.  I
Xwould recommend the following for those running version 9: try hpux9 and
Xif it doesn't work then try hpux8.  If neither work, then send mail to me
Xand/or the modules' authors.  Another note:  we have a model 730 supposedly
Xrunning version 9.01.  The module hpux9 did not compile successfully, but
Xthe module hpux8 worked fine.
X
XNET/2 386BSD SYSTEMS
X
XIf your version of the operating system has patchkit 2.4 installed,
Xthen you will need to modify machine/m_386bsd.c and uncomment the
Xdefinition of PATCHED_KVM.  This patchkit makes what more than a few
Xpeople believe to be a wholly unnecessary patch to the way the kvm
Xroutines work.
X
XA/UX SYSTEMS
X
XThere is a module for A/UX 3.1.  Whether or not it works for any other
Xversion is not known.  Proceed at your own risk.
X
XAlthough AUX does not generally have a renice systemcall, it can be
Ximplemented by tweeking kernel memory.  The flag IMPLEMENT_SETPRIORITY
Xcontrols the inclusion of this code.  It is off be default.  While
Xsuch a simple hack should not be difficult to get right, USE THIS
XFEATURE AT YOUR OWN RISK!
X
X
XPOPULAR SYSTEMS WHICH DO NOT HAVE MODULES
X
XAIX SYSTEMS
X
XI have had many offers from kind individuals to write an AIX module.
XTo this date I have not yet received an actual working module.  I 
Xdon't have access to an AIX system, or even if I did I don't have the
Xtime to learn the internals of a completely different OS.
X
XSGI IRIX SYSTEMS
X
XA few people have offered to write an irix module, but I still have
Xnot received one that works.
X
XNeXT SYSTEMS
X
XI am working with two separate people in the development of a NeXT
Xmodule.
X
END_OF_FILE
if test 7606 -ne `wc -c <'INSTALL'`; then
    echo shar: \"'INSTALL'\" unpacked with wrong size!
fi
# end of 'INSTALL'
fi
if test -f 'Porting' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Porting'\"
else
echo shar: Extracting \"'Porting'\" \(7062 characters\)
sed "s/^X//" >'Porting' <<'END_OF_FILE'
XInstructions for porting top to other architectures.
X
XThis is still a preliminary document.  Suggestions for improvement are
Xmost welcome.
X
XMy address is now "lefebvre@dis.anl.gov".
X
XBefore you embark on a port, please send me a mail message telling me
Xwhat platform you are porting top to.  There are three reasons for
Xthis: (1) I may already have a port, (2) module naming needs to be
Xcentralized, (3) I want to loosely track the various porting efforts.
XYou do not need to wait for an "okay", but I do want to know that you
Xare working on it.  And of course, once it is finished, please send me
Xthe module files so that I can add them to the main distribution!
X
X----------
X
XThere is one set of functions which extract all the information that
Xtop needs for display.  These functions are collected in to one file.
XTo make top work on a different architecture simply requires a
Xdifferent implementation of these functions.  The functions for a
Xgiven architecture "foo" are stored in a file called "m_foo.c".  The
XConfigure script looks for these files and lets the configurer choose
Xone of them.  This file is called a "module".  The idea is that making
Xtop work on a different machine only requires one additional file and
Xdoes not require changes to any existing files.
X
XA module template is included in the distribution, called "m-template".
XTo write your own module, it is a good idea to start with this template.
XIf you architecture is similar to one for which a module already
Xexists, then you can start with that module instead.  If you do so,
Xremember to change the "AUTHOR" section at the top!
X
XThe first comment in a module contains information which is extracted
Xand used by Configure.  This information is marked with words in all
Xcapitals (such as "SYNOPSIS:" and "LIBS:").  Go look at m-template: it
Xis fairly self-explanatory.  The text after "LIBS:" (on the same line)
Xis extracted and included in the LIBS definition of the Makefile so
Xthat extra libraries which may be necessary on some machines (such as
X"-lkvm") can be specified in the module.  The text after "CFLAGS:"
X(on the same line) is extracted and included as flags in the "CFLAGS"
Xdefinition of the Makefile (thus in every compilation step).  This is
Xused for rare circumstances only:  please don't abuse this hook.
X
XSome operating systems have idiosyncrasies which will affect the form
Xand/or content of the information top displays.  You may wish to
Xdocument such anomalies in the top man page.  This can be done by adding
Xa file called m_{modulename}.man (where {modulename} is replaced with
Xthe name of the module).  Configure will automatically add this file to
Xthe end of the man page.  See m_sunos4.man for an example.
X
XA module is concerned with two structures:
X
XThe statics struct is filled in by machine_init.  Each item is a
Xpointer to a list of character pointers.  The list is terminated 
Xwith a null pointer.
X
Xstruct statics
X{
X    char **procstate_names;	/* process state names */
X    char **cpustate_names;	/* cpu state names */
X    char **memory_names;	/* memory information names */
X};
X
XThe system_info struct is filled in by get_system_info and
Xget_process_info.
X
Xstruct system_info
X{
X    int    last_pid;     /* last pid assigned (0 means non-sequential assignment) */
X    double load_avg[NUM_AVERAGES];     /* see below */
X    int    p_total;      /* total number of processes */
X    int    p_active;     /* number of procs considered "active" */
X    int    *procstates;  /* array of process state counters */
X    int    *cpustates;   /* array of cpustate counters */
X    int    *memory;      /* memory information */
X};
X
XThe last three pointers each point to an array of integers.  The
Xlength of the array is determined by the length of the corresponding
X_names array in the statics structure.  Furthermore, if an entry in a
X_names array is the empty string ("") then the corresponding value in
Xthe value array will be skipped over.  The display routine displays,
Xfor example, the string procstate_names[0] then the number
Xprocstates[0], then procstate_names[1], procstates[1], etc. until
Xprocstate_names[N] == NULL.  This allows for a tremendous amount of
Xflexibility in labeling the displayed values.
X
X"procstates" and "memory" are displayed as straight integer values.
XValues in "cpustates" are displayed as a percentage * 10.  For
Xexample, the (integer) value 105 is displayed as 10.5%.
X
XThese routines must be defined by the machine dependent module.
X
Xint machine_init(struct statics *)
X
X	returns 0 on success and -1 on failure,
X	prints error messages
X
Xchar *format_header(char *)
X
X	Returns a string which should be used as the header for the
X	process display area.  The argument is a string used to label
X	the username column (either "USERNAME" or "UID") and is always
X	8 characters in length.
X
Xvoid get_system_info(struct system_info *)
X
Xcaddr_t get_process_info(struct system_info *, int, int, int (*func)())
X
X	returns a handle to use with format_next_process
X
Xchar *format_next_process(caddr_t, char *(*func)())
X
X	returns string which describes next process
X
Xint proc_compare(caddr_t, caddr_t)
X
X	qsort comparison function
X
Xuid_t proc_owner(pid_t)
X
X	Returns the uid owner of the process specified by the pid argument.
X	This function is VERY IMPORTANT.  If it fails to do its job, then
X	top may pose a security risk.
X
X
Xget_process_info is called immediately after get_system_info.  In
Xfact, the two functions could be rolled in to one.  The reason they
Xare not is mostly historical.
X
XTop relies on the existence of a function called "setpriority" to
Xchange a process's priority.  This exists as a kernel call on most 4.3
XBSD derived Unixes.  If neither your operating system nor your C
Xlibrary supplies such a function, then you will need to add one to the
Xmodule.  It is defined as follows:
X
X	int setpriority (int dummy, int who, int niceval)
X
X	For the purposes of top, the first argument is meaningless.
X	The second is the pid and the third is the new nice value.
X	This function should behave just like a kernel call, setting
X	errno and returning -1 in case of an error.  This function MUST
X	check to make sure that a non-root user does not specify a nice
X	value less than the process's current value.  If it detects such
X	a condition, it should set errno to EACCES and return -1.
X	Other possible ERRNO values:  ESRCH when pid "who" does not exist,
X	EPERM when the invoker is not root and not the same as the
X	process owner.
X
XNote that top checks process ownership and should never call setpriority
Xwhen the invoker's uid is not root and not the same as the process's owner
Xuid.
X
X
XThe file "machine.h" contains definitions which are useful to modules
Xand to top.c (such as the structure definitions).  You SHOULD NOT need
Xto change it when porting to a new platform.
X
XPorting to a new platform should NOT require any changes to existing
Xfiles.  You should only need to add m_ files.  If you feel you need a
Xchange in one of the existing files, please contact me so that we can
Xdiscuss the details.  I want to keep such changes as general as
Xpossible.
X
END_OF_FILE
if test 7062 -ne `wc -c <'Porting'`; then
    echo shar: \"'Porting'\" unpacked with wrong size!
fi
# end of 'Porting'
fi
if test -f 'm-template' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'m-template'\"
else
echo shar: Extracting \"'m-template'\" \(5276 characters\)
sed "s/^X//" >'m-template' <<'END_OF_FILE'
X/*
X * top - a top users display for Unix
X *
X * THIS IS A TEMPLATE FILE FOR A MACHINE DEPENDENT (m_...c) FILE
X *
X * SYNOPSIS:  one line description of machine this module works with
X *
X * DESCRIPTION:
X * Detailed description of this machine dependent module.
X * It can be multiple lines, but a blank comment line (one with only an
X * asterisk) is considered to end it.  Place here a complete list of 
X * the machines and OS versions that this module works on.
X *
X * LIBS:  list of special libraries to include at link step (REMOVE THIS LINE IF NOT NEEDED)
X *
X * AUTHOR:  your name and <your@internet.address>
X */
X
X#include "top.h"
X#include "machine.h"
X
X
X/*
X *  These definitions control the format of the per-process area
X */
X
Xstatic char header[] =
X  "  PID X        PRI NICE   SIZE   RES STATE   TIME   WCPU    CPU COMMAND";
X/* 0123456   -- field to fill in starts at header+6 */
X#define UNAME_START 6
X
X#define Proc_format \
X	"%5d %-8.8s %3d %4d%6dK %4dK %-5s%4d:%02d %5.2f%% %5.2f%% %.14s"
X
X/* these are for detailing the process states */
X
Xint process_states[?];
Xchar *procstatenames[] = {
X    "", " sleeping, ", " ABANDONED, ", " running, ", " starting, ",
X    " zombie, ", " stopped, ",
X    NULL
X};
X
X/* these are for detailing the cpu states */
X
Xint cpu_states[?];
Xchar *cpustatenames[] = {
X    "user", "nice", "system", "idle",
X    NULL
X};
X
X/* these are for detailing the memory statistics */
X
Xint memory_stats[?];
Xchar *memorynames[] = {
X    "K available, ", "K in use, ", "K free, ", "K locked", NULL
X};
X
X/* useful externals */
Xextern int errno;
Xextern char *sys_errlist[];
X
Xlong lseek();
Xlong time();
Xlong percentages();
X
Xmachine_init(statics)
X
Xstruct statics *statics;
X
X{
X    return(0);
X}
X
Xchar *format_header(uname_field)
X
Xregister char *uname_field;
X
X{
X    register char *ptr;
X
X    ptr = header + UNAME_START;
X    while (*uname_field != '\0')
X    {
X	*ptr++ = *uname_field++;
X    }
X
X    return(header);
X}
X
Xget_system_info(si)
X
Xstruct system_info *si;
X
X{
X}
X
Xstatic struct handle handle;
X
Xcaddr_t get_process_info(si, sel, compare)
X
Xstruct system_info *si;
Xstruct process_select *sel;
Xint (*compare)();
X
X{
X    return((caddr_t)&handle);
X}
X
Xchar fmt[128];		/* static area where result is built */
X
X/* define what weighted cpu is.  */
X#define weighted_cpu(pct, pp) ((pp)->p_time == 0 ? 0.0 : \
X			 ((pct) / (1.0 - exp((pp)->p_time * logcpu))))
X
Xchar *format_next_process(handle, get_userid)
X
Xcaddr_t handle;
Xchar *(*get_userid)();
X
X{
X    return(fmt);
X}
X
X/*
X *  getkval(offset, ptr, size, refstr) - get a value out of the kernel.
X *	"offset" is the byte offset into the kernel for the desired value,
X *  	"ptr" points to a buffer into which the value is retrieved,
X *  	"size" is the size of the buffer (and the object to retrieve),
X *  	"refstr" is a reference string used when printing error meessages,
X *	    if "refstr" starts with a '!', then a failure on read will not
X *  	    be fatal (this may seem like a silly way to do things, but I
X *  	    really didn't want the overhead of another argument).
X *  	
X */
X
Xgetkval(offset, ptr, size, refstr)
X
Xunsigned long offset;
Xint *ptr;
Xint size;
Xchar *refstr;
X
X{
X    if (kvm_read(kd, offset, ptr, size) != size)
X    {
X	if (*refstr == '!')
X	{
X	    return(0);
X	}
X	else
X	{
X	    fprintf(stderr, "top: kvm_read for %s: %s\n",
X		refstr, sys_errlist[errno]);
X	    quit(23);
X	}
X    }
X    return(1);
X}
X    
X/* comparison routine for qsort */
X/* NOTE: this is specific to the BSD proc structure, but it should
X   give you a good place to start. */
X
X/*
X *  proc_compare - comparison function for "qsort"
X *	Compares the resource consumption of two processes using five
X *  	distinct keys.  The keys (in descending order of importance) are:
X *  	percent cpu, cpu ticks, state, resident set size, total virtual
X *  	memory usage.  The process states are ordered as follows (from least
X *  	to most important):  WAIT, zombie, sleep, stop, start, run.  The
X *  	array declaration below maps a process state index into a number
X *  	that reflects this ordering.
X */
X
Xstatic unsigned char sorted_state[] =
X{
X    0,	/* not used		*/
X    3,	/* sleep		*/
X    1,	/* ABANDONED (WAIT)	*/
X    6,	/* run			*/
X    5,	/* start		*/
X    2,	/* zombie		*/
X    4	/* stop			*/
X};
X 
Xproc_compare(pp1, pp2)
X
Xstruct proc **pp1;
Xstruct proc **pp2;
X
X{
X    register struct proc *p1;
X    register struct proc *p2;
X    register int result;
X    register pctcpu lresult;
X
X    /* remove one level of indirection */
X    p1 = *pp1;
X    p2 = *pp2;
X
X    /* compare percent cpu (pctcpu) */
X    if ((lresult = p2->p_pctcpu - p1->p_pctcpu) == 0)
X    {
X	/* use cpticks to break the tie */
X	if ((result = p2->p_cpticks - p1->p_cpticks) == 0)
X	{
X	    /* use process state to break the tie */
X	    if ((result = sorted_state[p2->p_stat] -
X			  sorted_state[p1->p_stat])  == 0)
X	    {
X		/* use priority to break the tie */
X		if ((result = p2->p_pri - p1->p_pri) == 0)
X		{
X		    /* use resident set size (rssize) to break the tie */
X		    if ((result = p2->p_rssize - p1->p_rssize) == 0)
X		    {
X			/* use total memory to break the tie */
X			result = PROCSIZE(p2) - PROCSIZE(p1);
X		    }
X		}
X	    }
X	}
X    }
X    else
X    {
X	result = lresult < 0 ? -1 : 1;
X    }
X
X    return(result);
X}
X
Xproc_owner(pid)
X
Xint pid;
X
X{
X   /* returns uid of owner of process pid */
X   return(uid);
X}
X
END_OF_FILE
if test 5276 -ne `wc -c <'m-template'`; then
    echo shar: \"'m-template'\" unpacked with wrong size!
fi
# end of 'm-template'
fi
if test -f 'screen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screen.c'\"
else
echo shar: Extracting \"'screen.c'\" \(9664 characters\)
sed "s/^X//" >'screen.c' <<'END_OF_FILE'
X/*
X *  Top users/processes display for Unix
X *  Version 3
X *
X *  This program may be freely redistributed,
X *  but this entire comment MUST remain intact.
X *
X *  Copyright (c) 1984, 1989, William LeFebvre, Rice University
X *  Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
X */
X
X/*  This file contains the routines that interface to termcap and stty/gtty.
X *
X *  Paul Vixie, February 1987: converted to use ioctl() instead of stty/gtty.
X *
X *  I put in code to turn on the TOSTOP bit while top was running, but I
X *  didn't really like the results.  If you desire it, turn on the
X *  preprocessor variable "TOStop".   --wnl
X */
X
X#include "os.h"
X#include "top.h"
X
X#include <sys/ioctl.h>
X#ifdef CBREAK
X# include <sgtty.h>
X# define SGTTY
X#else
X# ifdef TCGETA
X#  define TERMIO
X#  include <termio.h>
X# else
X#  define TERMIOS
X#  include <termios.h>
X# endif
X#endif
X#if defined(TERMIO) || defined(TERMIOS)
X# ifndef TAB3
X#  ifdef OXTABS
X#   define TAB3 OXTABS
X#  else
X#   define TAB3 0
X#  endif
X# endif
X#endif
X#include "screen.h"
X#include "boolean.h"
X
Xextern char *myname;
X
Xint putstdout();
X
Xint  overstrike;
Xint  screen_length;
Xint  screen_width;
Xchar ch_erase;
Xchar ch_kill;
Xchar smart_terminal;
Xchar PC;
Xchar *tgetstr();
Xchar *tgoto();
Xchar termcap_buf[1024];
Xchar string_buffer[1024];
Xchar home[15];
Xchar lower_left[15];
Xchar *clear_line;
Xchar *clear_screen;
Xchar *clear_to_end;
Xchar *cursor_motion;
Xchar *start_standout;
Xchar *end_standout;
Xchar *terminal_init;
Xchar *terminal_end;
Xshort ospeed;
X
X#ifdef SGTTY
Xstatic struct sgttyb old_settings;
Xstatic struct sgttyb new_settings;
X#endif
X#ifdef TERMIO
Xstatic struct termio old_settings;
Xstatic struct termio new_settings;
X#endif
X#ifdef TERMIOS
Xstatic struct termios old_settings;
Xstatic struct termios new_settings;
X#endif
Xstatic char is_a_terminal = No;
X#ifdef TOStop
Xstatic int old_lword;
Xstatic int new_lword;
X#endif
X
X#define	STDIN	0
X#define	STDOUT	1
X#define	STDERR	2
X
Xinit_termcap(interactive)
X
Xint interactive;
X
X{
X    char *bufptr;
X    char *PCptr;
X    char *term_name;
X    char *getenv();
X    int status;
X
X    /* set defaults in case we aren't smart */
X    screen_width = MAX_COLS;
X    screen_length = 0;
X
X    if (!interactive)
X    {
X	/* pretend we have a dumb terminal */
X	smart_terminal = No;
X	return;
X    }
X
X    /* assume we have a smart terminal until proven otherwise */
X    smart_terminal = Yes;
X
X    /* get the terminal name */
X    term_name = getenv("TERM");
X
X    /* if there is no TERM, assume it's a dumb terminal */
X    /* patch courtesy of Sam Horrocks at telegraph.ics.uci.edu */
X    if (term_name == NULL)
X    {
X	smart_terminal = No;
X	return;
X    }
X
X    /* now get the termcap entry */
X    if ((status = tgetent(termcap_buf, term_name)) != 1)
X    {
X	if (status == -1)
X	{
X	    fprintf(stderr, "%s: can't open termcap file\n", myname);
X	}
X	else
X	{
X	    fprintf(stderr, "%s: no termcap entry for a `%s' terminal\n",
X		    myname, term_name);
X	}
X
X	/* pretend it's dumb and proceed */
X	smart_terminal = No;
X	return;
X    }
X
X    /* "hardcopy" immediately indicates a very stupid terminal */
X    if (tgetflag("hc"))
X    {
X	smart_terminal = No;
X	return;
X    }
X
X    /* set up common terminal capabilities */
X    if ((screen_length = tgetnum("li")) <= 0)
X    {
X	screen_length = smart_terminal = 0;
X	return;
X    }
X
X    /* screen_width is a little different */
X    if ((screen_width = tgetnum("co")) == -1)
X    {
X	screen_width = 79;
X    }
X    else
X    {
X	screen_width -= 1;
X    }
X
X    /* terminals that overstrike need special attention */
X    overstrike = tgetflag("os");
X
X    /* initialize the pointer into the termcap string buffer */
X    bufptr = string_buffer;
X
X    /* get "ce", clear to end */
X    if (!overstrike)
X    {
X	clear_line = tgetstr("ce", &bufptr);
X    }
X
X    /* get necessary capabilities */
X    if ((clear_screen  = tgetstr("cl", &bufptr)) == NULL ||
X	(cursor_motion = tgetstr("cm", &bufptr)) == NULL)
X    {
X	smart_terminal = No;
X	return;
X    }
X
X    /* get some more sophisticated stuff -- these are optional */
X    clear_to_end   = tgetstr("cd", &bufptr);
X    terminal_init  = tgetstr("ti", &bufptr);
X    terminal_end   = tgetstr("te", &bufptr);
X    start_standout = tgetstr("so", &bufptr);
X    end_standout   = tgetstr("se", &bufptr);
X
X    /* pad character */
X    PC = (PCptr = tgetstr("pc", &bufptr)) ? *PCptr : 0;
X
X    /* set convenience strings */
X    (void) strcpy(home, tgoto(cursor_motion, 0, 0));
X    /* (lower_left is set in get_screensize) */
X
X    /* get the actual screen size with an ioctl, if needed */
X    /* This may change screen_width and screen_length, and it always
X       sets lower_left. */
X    get_screensize();
X
X    /* if stdout is not a terminal, pretend we are a dumb terminal */
X#ifdef SGTTY
X    if (ioctl(STDOUT, TIOCGETP, &old_settings) == -1)
X    {
X	smart_terminal = No;
X    }
X#endif
X#ifdef TERMIO
X    if (ioctl(STDOUT, TCGETA, &old_settings) == -1)
X    {
X	smart_terminal = No;
X    }
X#endif
X#ifdef TERMIOS
X    if (tcgetattr(STDOUT, &old_settings) == -1)
X    {
X	smart_terminal = No;
X    }
X#endif
X}
X
Xinit_screen()
X
X{
X    /* get the old settings for safe keeping */
X#ifdef SGTTY
X    if (ioctl(STDOUT, TIOCGETP, &old_settings) != -1)
X    {
X	/* copy the settings so we can modify them */
X	new_settings = old_settings;
X
X	/* turn on CBREAK and turn off character echo and tab expansion */
X	new_settings.sg_flags |= CBREAK;
X	new_settings.sg_flags &= ~(ECHO|XTABS);
X	(void) ioctl(STDOUT, TIOCSETP, &new_settings);
X
X	/* remember the erase and kill characters */
X	ch_erase = old_settings.sg_erase;
X	ch_kill  = old_settings.sg_kill;
X
X#ifdef TOStop
X	/* get the local mode word */
X	(void) ioctl(STDOUT, TIOCLGET, &old_lword);
X
X	/* modify it */
X	new_lword = old_lword | LTOSTOP;
X	(void) ioctl(STDOUT, TIOCLSET, &new_lword);
X#endif
X	/* remember that it really is a terminal */
X	is_a_terminal = Yes;
X
X	/* send the termcap initialization string */
X	putcap(terminal_init);
X    }
X#endif
X#ifdef TERMIO
X    if (ioctl(STDOUT, TCGETA, &old_settings) != -1)
X    {
X	/* copy the settings so we can modify them */
X	new_settings = old_settings;
X
X	/* turn off ICANON, character echo and tab expansion */
X	new_settings.c_lflag &= ~(ICANON|ECHO);
X	new_settings.c_oflag &= ~(TAB3);
X	new_settings.c_cc[VMIN] = 1;
X	new_settings.c_cc[VTIME] = 0;
X	(void) ioctl(STDOUT, TCSETA, &new_settings);
X
X	/* remember the erase and kill characters */
X	ch_erase = old_settings.c_cc[VERASE];
X	ch_kill  = old_settings.c_cc[VKILL];
X
X	/* remember that it really is a terminal */
X	is_a_terminal = Yes;
X
X	/* send the termcap initialization string */
X	putcap(terminal_init);
X    }
X#endif
X#ifdef TERMIOS
X    if (tcgetattr(STDOUT, &old_settings) != -1)
X    {
X	/* copy the settings so we can modify them */
X	new_settings = old_settings;
X
X	/* turn off ICANON, character echo and tab expansion */
X	new_settings.c_lflag &= ~(ICANON|ECHO);
X	new_settings.c_oflag &= ~(TAB3);
X	new_settings.c_cc[VMIN] = 1;
X	new_settings.c_cc[VTIME] = 0;
X	(void) tcsetattr(STDOUT, TCSADRAIN, &new_settings);
X
X	/* remember the erase and kill characters */
X	ch_erase = old_settings.c_cc[VERASE];
X	ch_kill  = old_settings.c_cc[VKILL];
X
X	/* remember that it really is a terminal */
X	is_a_terminal = Yes;
X
X	/* send the termcap initialization string */
X	putcap(terminal_init);
X    }
X#endif
X
X    if (!is_a_terminal)
X    {
X	/* not a terminal at all---consider it dumb */
X	smart_terminal = No;
X    }
X}
X
Xend_screen()
X
X{
X    /* move to the lower left, clear the line and send "te" */
X    if (smart_terminal)
X    {
X	putcap(lower_left);
X	putcap(clear_line);
X	fflush(stdout);
X	putcap(terminal_end);
X    }
X
X    /* if we have settings to reset, then do so */
X    if (is_a_terminal)
X    {
X#ifdef SGTTY
X	(void) ioctl(STDOUT, TIOCSETP, &old_settings);
X#ifdef TOStop
X	(void) ioctl(STDOUT, TIOCLSET, &old_lword);
X#endif
X#endif
X#ifdef TERMIO
X	(void) ioctl(STDOUT, TCSETA, &old_settings);
X#endif
X#ifdef TERMIOS
X	(void) tcsetattr(STDOUT, TCSADRAIN, &old_settings);
X#endif
X    }
X}
X
Xreinit_screen()
X
X{
X    /* install our settings if it is a terminal */
X    if (is_a_terminal)
X    {
X#ifdef SGTTY
X	(void) ioctl(STDOUT, TIOCSETP, &new_settings);
X#ifdef TOStop
X	(void) ioctl(STDOUT, TIOCLSET, &new_lword);
X#endif
X#endif
X#ifdef TERMIO
X	(void) ioctl(STDOUT, TCSETA, &new_settings);
X#endif
X#ifdef TERMIOS
X	(void) tcsetattr(STDOUT, TCSADRAIN, &new_settings);
X#endif
X    }
X
X    /* send init string */
X    if (smart_terminal)
X    {
X	putcap(terminal_init);
X    }
X}
X
Xget_screensize()
X
X{
X
X#ifdef TIOCGWINSZ
X
X    struct winsize ws;
X
X    if (ioctl (1, TIOCGWINSZ, &ws) != -1)
X    {
X	if (ws.ws_row != 0)
X	{
X	    screen_length = ws.ws_row;
X	}
X	if (ws.ws_col != 0)
X	{
X	    screen_width = ws.ws_col - 1;
X	}
X    }
X
X#else
X#ifdef TIOCGSIZE
X
X    struct ttysize ts;
X
X    if (ioctl (1, TIOCGSIZE, &ts) != -1)
X    {
X	if (ts.ts_lines != 0)
X	{
X	    screen_length = ts.ts_lines;
X	}
X	if (ts.ts_cols != 0)
X	{
X	    screen_width = ts.ts_cols - 1;
X	}
X    }
X
X#endif /* TIOCGSIZE */
X#endif /* TIOCGWINSZ */
X
X    (void) strcpy(lower_left, tgoto(cursor_motion, 0, screen_length - 1));
X}
X
Xstandout(msg)
X
Xchar *msg;
X
X{
X    if (smart_terminal)
X    {
X	putcap(start_standout);
X	fputs(msg, stdout);
X	putcap(end_standout);
X    }
X    else
X    {
X	fputs(msg, stdout);
X    }
X}
X
Xclear()
X
X{
X    if (smart_terminal)
X    {
X	putcap(clear_screen);
X    }
X}
X
Xclear_eol(len)
X
Xint len;
X
X{
X    if (smart_terminal && !overstrike && len > 0)
X    {
X	if (clear_line)
X	{
X	    putcap(clear_line);
X	    return(0);
X	}
X	else
X	{
X	    while (len-- > 0)
X	    {
X		putchar(' ');
X	    }
X	    return(1);
X	}
X    }
X    return(-1);
X}
X
Xgo_home()
X
X{
X    if (smart_terminal)
X    {
X	putcap(home);
X    }
X}
X
X/* This has to be defined as a subroutine for tputs (instead of a macro) */
X
Xputstdout(ch)
X
Xchar ch;
X
X{
X    putchar(ch);
X}
X
END_OF_FILE
if test 9664 -ne `wc -c <'screen.c'`; then
    echo shar: \"'screen.c'\" unpacked with wrong size!
fi
# end of 'screen.c'
fi
if test -f 'utils.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils.c'\"
else
echo shar: Extracting \"'utils.c'\" \(9704 characters\)
sed "s/^X//" >'utils.c' <<'END_OF_FILE'
X/*
X *  Top users/processes display for Unix
X *  Version 3
X *
X *  This program may be freely redistributed,
X *  but this entire comment MUST remain intact.
X *
X *  Copyright (c) 1984, 1989, William LeFebvre, Rice University
X *  Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
X */
X
X/*
X *  This file contains various handy utilities used by top.
X */
X
X#include "top.h"
X#include "os.h"
X
Xint atoiwi(str)
X
Xchar *str;
X
X{
X    register int len;
X
X    len = strlen(str);
X    if (len != 0)
X    {
X	if (strncmp(str, "infinity", len) == 0 ||
X	    strncmp(str, "all",      len) == 0 ||
X	    strncmp(str, "maximum",  len) == 0)
X	{
X	    return(Infinity);
X	}
X	else if (str[0] == '-')
X	{
X	    return(Invalid);
X	}
X	else
X	{
X	    return(atoi(str));
X	}
X    }
X    return(0);
X}
X
X/*
X *  itoa - convert integer (decimal) to ascii string for positive numbers
X *  	   only (we don't bother with negative numbers since we know we
X *	   don't use them).
X */
X
X				/*
X				 * How do we know that 16 will suffice?
X				 * Because the biggest number that we will
X				 * ever convert will be 2^32-1, which is 10
X				 * digits.
X				 */
X
Xchar *itoa(val)
X
Xregister int val;
X
X{
X    register char *ptr;
X    static char buffer[16];	/* result is built here */
X    				/* 16 is sufficient since the largest number
X				   we will ever convert will be 2^32-1,
X				   which is 10 digits. */
X
X    ptr = buffer + sizeof(buffer);
X    *--ptr = '\0';
X    if (val == 0)
X    {
X	*--ptr = '0';
X    }
X    else while (val != 0)
X    {
X	*--ptr = (val % 10) + '0';
X	val /= 10;
X    }
X    return(ptr);
X}
X
X/*
X *  itoa7(val) - like itoa, except the number is right justified in a 7
X *	character field.  This code is a duplication of itoa instead of
X *	a front end to a more general routine for efficiency.
X */
X
Xchar *itoa7(val)
X
Xregister int val;
X
X{
X    register char *ptr;
X    static char buffer[16];	/* result is built here */
X    				/* 16 is sufficient since the largest number
X				   we will ever convert will be 2^32-1,
X				   which is 10 digits. */
X
X    ptr = buffer + sizeof(buffer);
X    *--ptr = '\0';
X    if (val == 0)
X    {
X	*--ptr = '0';
X    }
X    else while (val != 0)
X    {
X	*--ptr = (val % 10) + '0';
X	val /= 10;
X    }
X    while (ptr > buffer + sizeof(buffer) - 7)
X    {
X	*--ptr = ' ';
X    }
X    return(ptr);
X}
X
X/*
X *  digits(val) - return number of decimal digits in val.  Only works for
X *	positive numbers.  If val <= 0 then digits(val) == 0.
X */
X
Xint digits(val)
X
Xint val;
X
X{
X    register int cnt = 0;
X
X    while (val > 0)
X    {
X	cnt++;
X	val /= 10;
X    }
X    return(cnt);
X}
X
X/*
X *  strecpy(to, from) - copy string "from" into "to" and return a pointer
X *	to the END of the string "to".
X */
X
Xchar *strecpy(to, from)
X
Xregister char *to;
Xregister char *from;
X
X{
X    while ((*to++ = *from++) != '\0');
X    return(--to);
X}
X
X/*
X * argparse(line, cntp) - parse arguments in string "line", separating them
X *	put into an argv-like array, and setting *cntp to the number of
X *	arguments encountered.  This is a simple parser that doesn't understand
X *	squat about quotes.
X */
X
Xchar **argparse(line, cntp)
X
Xchar *line;
Xint *cntp;
X
X{
X    register char *from;
X    register char *to;
X    register int cnt;
X    register int ch;
X    int length;
X    int lastch;
X    register char **argv;
X    char **argarray;
X    char *args;
X
X    /* unfortunately, the only real way to do this is to go thru the
X       input string twice. */
X
X    /* step thru the string counting the white space sections */
X    from = line;
X    lastch = cnt = length = 0;
X    while ((ch = *from++) != '\0')
X    {
X	length++;
X	if (ch == ' ' && lastch != ' ')
X	{
X	    cnt++;
X	}
X	lastch = ch;
X    }
X
X    /* add three to the count:  one for the initial "dummy" argument,
X       one for the last argument and one for NULL */
X    cnt += 3;
X
X    /* allocate a char * array to hold the pointers */
X    argarray = (char **)malloc(cnt * sizeof(char *));
X
X    /* allocate another array to hold the strings themselves */
X    args = (char *)malloc(length+2);
X
X    /* initialization for main loop */
X    from = line;
X    to = args;
X    argv = argarray;
X    lastch = '\0';
X
X    /* create a dummy argument to keep getopt happy */
X    *argv++ = to;
X    *to++ = '\0';
X    cnt = 2;
X
X    /* now build argv while copying characters */
X    *argv++ = to;
X    while ((ch = *from++) != '\0')
X    {
X	if (ch != ' ')
X	{
X	    if (lastch == ' ')
X	    {
X		*to++ = '\0';
X		*argv++ = to;
X		cnt++;
X	    }
X	    *to++ = ch;
X	}
X	lastch = ch;
X    }
X
X    /* set cntp and return the allocated array */
X    *cntp = cnt;
X    return(argarray);
X}
X
X/*
X *  percentages(cnt, out, new, old, diffs) - calculate percentage change
X *	between array "old" and "new", putting the percentages i "out".
X *	"cnt" is size of each array and "diffs" is used for scratch space.
X *	The array "old" is updated on each call.
X *	The routine assumes modulo arithmetic.  This function is especially
X *	useful on BSD mchines for calculating cpu state percentages.
X */
X
Xlong percentages(cnt, out, new, old, diffs)
X
Xint cnt;
Xint *out;
Xregister long *new;
Xregister long *old;
Xlong *diffs;
X
X{
X    register int i;
X    register long change;
X    register long total_change;
X    register long *dp;
X    long half_total;
X
X    /* initialization */
X    total_change = 0;
X    dp = diffs;
X
X    /* calculate changes for each state and the overall change */
X    for (i = 0; i < cnt; i++)
X    {
X	if ((change = *new - *old) < 0)
X	{
X	    /* this only happens when the counter wraps */
X	    change = (int)
X		((unsigned long)*new-(unsigned long)*old);
X	}
X	total_change += (*dp++ = change);
X	*old++ = *new++;
X    }
X
X    /* calculate percentages based on overall change, rounding up */
X    half_total = total_change / 2l;
X    for (i = 0; i < cnt; i++)
X    {
X	*out++ = (int)((*diffs++ * 1000 + half_total) / total_change);
X    }
X
X    /* return the total in case the caller wants to use it */
X    return(total_change);
X}
X
X/*
X * errmsg(errnum) - return an error message string appropriate to the
X *           error number "errnum".  This is a substitute for the System V
X *           function "strerror" with one important difference:  the string
X *           returned by this function does NOT end in a newline!
X *           N.B.:  there appears to be no reliable way to determine if
X *           "strerror" exists at compile time, so I make do by providing
X *           something of similar functionality.
X */
X
X/* externs referenced by errmsg */
X
Xextern char *sys_errlist[];
Xextern int sys_nerr;
X
Xchar *errmsg(errnum)
X
Xint errnum;
X
X{
X    if (errnum > 0 && errnum < sys_nerr)
X    {
X	return(sys_errlist[errnum]);
X    }
X    return("No error");
X}
X
X/* format_time(seconds) - format number of seconds into a suitable
X *		display that will fit within 6 characters.  Note that this
X *		routine builds its string in a static area.  If it needs
X *		to be called more than once without overwriting previous data,
X *		then we will need to adopt a technique similar to the
X *		one used for format_k.
X */
X
X/* Explanation:
X   We want to keep the output within 6 characters.  For low values we use
X   the format mm:ss.  For values that exceed 999:59, we switch to a format
X   that displays hours and fractions:  hhh.tH.  For values that exceed
X   999.9, we use hhhh.t and drop the "H" designator.  For values that
X   exceed 9999.9, we use "???".
X */
X
Xchar *format_time(seconds)
X
Xlong seconds;
X
X{
X    register int value;
X    register int digit;
X    register char *ptr;
X    static char result[10];
X
X    /* sanity protection */
X    if (seconds < 0 || seconds > (99999l * 360l))
X    {
X	strcpy(result, "   ???");
X    }
X    else if (seconds >= (1000l * 60l))
X    {
X	/* alternate (slow) method displaying hours and tenths */
X	sprintf(result, "%5.1fH", (double)seconds / (double)(60l * 60l));
X
X	/* It is possible that the sprintf took more than 6 characters.
X	   If so, then the "H" appears as result[6].  If not, then there
X	   is a \0 in result[6].  Either way, it is safe to step on.
X	 */
X	result[6] = '\0';
X    }
X    else
X    {
X	/* standard method produces MMM:SS */
X	/* we avoid printf as must as possible to make this quick */
X	sprintf(result, "%3d:%02d", seconds / 60l, seconds % 60l);
X    }
X    return(result);
X}
X
X/*
X * format_k(amt) - format a kilobyte memory value, returning a string
X *		suitable for display.  Returns a pointer to a static
X *		area that changes each call.  "amt" is converted to a
X *		string with a trailing "K".  If "amt" is 10000 or greater,
X *		then it is formatted as megabytes (rounded) with a
X *		trailing "M".
X */
X
X/*
X * Compromise time.  We need to return a string, but we don't want the
X * caller to have to worry about freeing a dynamically allocated string.
X * Unfortunately, we can't just return a pointer to a static area as one
X * of the common uses of this function is in a large call to sprintf where
X * it might get invoked several times.  Our compromise is to maintain an
X * array of strings and cycle thru them with each invocation.  We make the
X * array large enough to handle the above mentioned case.  The constant
X * NUM_STRINGS defines the number of strings in this array:  we can tolerate
X * up to NUM_STRINGS calls before we start overwriting old information.
X * Keeping NUM_STRINGS a power of two will allow an intelligent optimizer
X * to convert the modulo operation into something quicker.  What a hack!
X */
X
X#define NUM_STRINGS 8
X
Xchar *format_k(amt)
X
Xint amt;
X
X{
X    static char retarray[NUM_STRINGS][16];
X    static int index = 0;
X    register char *p;
X    register char *ret;
X    register char tag = 'K';
X
X    p = ret = retarray[index];
X    index = (index + 1) % NUM_STRINGS;
X
X    if (amt >= 10000)
X    {
X	amt = (amt + 500) / 1000;
X	tag = 'M';
X    }
X
X    p = strecpy(p, itoa(amt));
X    *p++ = tag;
X    *p = '\0';
X
X    return(ret);
X}
END_OF_FILE
if test 9704 -ne `wc -c <'utils.c'`; then
    echo shar: \"'utils.c'\" unpacked with wrong size!
fi
# end of 'utils.c'
fi
echo shar: End of archive 2 \(of 16\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 16 archives.
    echo "Now read README and INSTALL, then run Configure"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
