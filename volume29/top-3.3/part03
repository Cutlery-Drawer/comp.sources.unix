Newsgroups: comp.sources.unix
From: lefebvre@athens.dis.anl.gov (William LeFebvre)
Subject: v29i003: top-3.3 - top users display, V3.3, Part03/16
References: <1.801816033.16454@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: lefebvre@athens.dis.anl.gov (William LeFebvre)
Posting-Number: Volume 29, Issue 3
Archive-Name: top-3.3/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 16)."
# Contents:  Configure commands.c machine/m_dgux.c top.X
# Wrapped by lefebvre@athens on Thu Mar  2 11:39:40 1995
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Configure' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Configure'\"
else
echo shar: Extracting \"'Configure'\" \(12585 characters\)
sed "s/^X//" >'Configure' <<'END_OF_FILE'
X#!/bin/csh -f
X#
X# Configuration script for top.
X#
X# Use with version 3.0 and higher.
X#
Xset PRIME = "/usr/games/primes"
Xset vars = (module LoadMax topn NominalTopn delay owner group mode random \
X	TableSize bindir mandir manext mansty \
X	Cmdshell Cmdcc Cmdawk Cmdinstall cdefs)
Xset fastrack = 0
Xset yesno = (no yes)
X
Xonintr byebye
X
X# make sure that getans is there and ready
Xif (! -e getans) then
X   echo 'This package is not complete.  The shell file "getans" is missing.'
X   exit 10
Xendif
Xchmod +x getans
X
Xif ($#argv > 0) then
X# fast track configuration
X   set fastrack = 1
Xelse
Xcat <<'EOF'
XConfiguration for top, version 3
X
XOne moment....
X'EOF'
Xendif
X
X# collect file names and module names
Xls machine/m_*.c >$$.f
Xls machine/m_*.man >$$.m
Xsed -e 's@^machine/m_@@' -e 's/.c$//' $$.f >$$.n
X
X# build Make.desc
Xset descs = `sed -e 's@\.c$@.desc@' $$.f`
Xsed -e "s@%descs%@$descs@" Make.desc.X >Make.desc
X
X# build desc files and SYNOPSIS as needed
Xmake -f Make.desc >/dev/null
X
Xif (-e .defaults) then
X   echo ""
X   echo "Reading configuration from last time..."
X   source .defaults
X   set nodefaults = 0
X   if ($fastrack == 1) then
X      set module = $1
X   endif
Xelse
X   if ($fastrack == 1) then
X      echo "No previous configuration was found."
X      set fastrack = 0
X      set module = $1
X   else
X      set module = ""
X   endif
X   set LoadMax     = 5.0
X   set topn        = 15
X   set NominalTopn = 18
X   set delay       = 5
X   set TableSize   = 0
X   set bindir      = /usr/local/bin
X   set mandir      = /usr/man/manl
X   set manext      = l
X   set mansty      = man
X   set nodefaults  = 1
X   set Cmdshell    = /bin/sh
X   set Cmdawk      = awk
X   set Cmdinstall  = ./install
X   set Cmdcc       = cc
X   set cdefs       = -O
Xendif
Xecho ""
X
Xif ($fastrack == 1) then
X   grep -s $module $$.n >/dev/null
X   if ($status != 0) then
X      echo "$module is not recognized.  To see a list of available modules"
X      echo 'run "Configure" with no arguments.'
X      rm -f $$.[fmn]
X      exit 1
X   endif
X   set random1 = `expr $random + 1`
X   cat <<EOF
XUsing these settings:
X        Bourne Shell   $Cmdshell
X          C compiler   $Cmdcc
X    Compiler options   $cdefs
X         Awk command   $Cmdawk
X     Install command   $Cmdinstall
X
X              Module   $module
X             LoadMax   $LoadMax
X        Default TOPN   $topn
X        Nominal TOPN   $NominalTopn
X       Default Delay   $delay
XRandom passwd access   $yesno[$random1]
X          Table Size   $TableSize
X               Owner   $owner
X         Group Owner   $group
X                Mode   $mode
X       bin directory   $bindir
X       man directory   $mandir
X       man extension   $manext
X       man style       $mansty
X
XEOF
X   goto fast
Xendif
X
Xcat <<'EOF'
XYou will be asked a series of questions.  Each question will have a
Xdefault answer enclosed in brackets, such as "[5.0]".  In most cases,
Xthe default answer will work well.  To use that value, merely press
Xreturn.
X
X'EOF'
X
X# display synopses
X
Xgetmod:
Xcat <<'EOF'
X
XThe following machine-dependent modules are available:
X'EOF'
Xawk -F: ' { printf "%-8s %s\n", $1, $2 }' SYNOPSIS
Xecho ''
X./getans "What module is appropriate for this machine? " string "$module" .$$
Xset module = `cat .$$`
X
Xif ("$module" == "") then
X    echo "Please specify a valid module name."
X    goto getmod
Xendif
X
X# is it a valid one?
Xgrep -s "$module" $$.n >/dev/null
Xif ($status != 0) then
X    echo "That is not a recognized module name."
X    goto getmod
Xendif
X
X# display a full description
Xsed -e '1,/DESCRIPTION:/d' -e '/^$/,$d' machine/m_${module}.desc
X
X# verify it
Xecho ""
X./getans "Is this what you want to use?" yesno 1 .$$
Xif (`cat .$$` == 0) then
X   goto getmod
Xendif
Xendif
X
Xcat <<'EOF'
X
XFirst we need to find out a little bit about the executables needed to
Xcompile top.
X
X'EOF'
X./getans "What is the full path name for the Bourne shell" file "$Cmdshell" .$$
Xset Cmdshell = `cat .$$`
X
Xcat <<'EOF'
X
XPlease supply the name of the appropriate command.  It need not be a
Xfull path name, but the named command does need to exist somewhere on
Xthe current path.
X
X'EOF'
X./getans "AWK Interpreter" path "$Cmdawk" .$$
Xset Cmdawk = `cat .$$`
X./getans "C Compiler" path "$Cmdcc" .$$
Xset Cmdcc = `cat .$$`
X
Xcat <<'EOF'
X
XThe installer command needs to understand Berkeley-esque arguments:
X"-o" for owner, "-g" for group, and "-m" for mode.  A shell script
Xcalled "install" is distributed with top and is suitable for use by
Xtop.  You can specify a different program here if you like, or use
Xthe shell script (the default).
X
X'EOF'
X./getans "Installer" path "$Cmdinstall" .$$
Xset Cmdinstall = `cat .$$`
X
Xcat <<EOF
X
XWhat other options should be used with the $Cmdcc command (use "none" to
Xspecify no options)?
XEOF
X./getans "Compiler options" string "$cdefs" .$$
Xset cdefs = `cat .$$`
Xif ("$cdefs" == "none") then
X    set cdefs = ""
Xendif
X
Xcat <<'EOF'
X
XNow you need to answer some questions concerning the configuration of
Xtop itself.
X
XThe space command forces an immediate update.  Sometimes, on loaded
Xsystems, this update will take a significant period of time (because all
Xthe output is buffered).  So, if the short-term load average is above
X"LoadMax", then top will put the cursor home immediately after the space
Xis pressed before the next update is attempted.  This serves as a visual
Xacknowledgement of the command.  "LoadMax" should always be specified as a
Xfloating point number.
X
X'EOF'
X./getans "LoadMax" number "$LoadMax" .$$
Xset LoadMax = `cat .$$`
X
Xcat <<'EOF'
X
X"Default TOPN" is the default number of processes to show.  This is the
Xnumber that will be used when the user does not specify the number of
Xprocesses to show.  If you want "all" (or infinity) as the default, use
Xthe value "-1".
X
X'EOF'
X
X./getans "Default TOPN" neginteger "$topn" .$$
Xset topn = `cat .$$`
X
Xcat <<'EOF'
X
X"Nominal_TOPN" is used as the default TOPN when Default_TOPN is Infinity
Xand the output is a dumb terminal.  If we didn't do this, then
Xinstallations who use a default TOPN of Infinity will get every process in
Xthe system when running top on a dumb terminal (or redirected to a file).
XNote that Nominal_TOPN is a default: it can still be overridden on the
Xcommand line, even with the value "infinity".
X
X'EOF'
X
X./getans "Nominal TOPN" integer "$NominalTopn" .$$
Xset NominalTopn = `cat .$$`
X
Xcat <<'EOF'
X
XDefault Delay is the default number of seconds to wait between screen
Xupdates.
X
X'EOF'
X
X./getans "Default Delay" integer "$delay" .$$
Xset delay = `cat .$$`
X
Xecho ""
X
Xset rand = 0
Xypwhich >&/dev/null
Xif ($status == 0 || -e /etc/passwd.dir || -e /etc/pwd.db) then
X   set rand = 1
Xendif
X
Xif ($rand == 1) then
X   echo "It looks like you have a passwd file that can be accessed at random."
X   set pr = 'Do you want top to take advantage of this'
Xelse
X   echo "It looks like you have conventional passwd file access.  Top can take"
X   echo "advantage of a random access passwd mechanism if such exists.  Do"
X   echo "you want top to assume that accesses to the file /etc/passwd are done"
X   set pr = 'with random access rather than sequential'
Xendif
X
Xif ($nodefaults == 1) then
X   set random = $rand
Xendif
X
X./getans "${pr}?" yesno $random .$$
Xset random = `cat .$$`
X
Xecho ""
Xecho "Compiling prime.c"
X$Cmdcc $cdefs -o prime prime.c -lm
Xif ($status != 0) then
X    echo "Oh well."
X    rm -f prime
Xendif
X
Xecho ""
X
Xypcat passwd.byname >&/tmp/$$.a
Xif ($status == 0) then
X   set cnt = `wc -l </tmp/$$.a`
X   set mapfile = "NIS map"
Xelse
X   set cnt = `wc -l </etc/passwd`
X   set mapfile = "file"
Xendif
Xrm /tmp/$$.a
Xset double = `expr $cnt \* 2`
Xecho "I found $cnt entries in your passwd $mapfile.  Top hashes the username to"
Xecho "uid mappings as it goes along and it needs a good guess on the size of"
Xecho "that hash table.  This number should be the next highest prime number"
Xecho "after $double."
Xecho ""
Xif (-e prime) then
X   set pr = `./prime $double`
X   echo "I have calculated that to be $pr."
Xelse if (-e $PRIME) then
X   set pr = `$PRIME $double | head -1`
X   echo "I have calculated that to be $pr."
Xelse
X   set pr = $double
X   echo "I cannot calculate that prime number, so you will need to provide it for me."
Xendif
X
Xif ($TableSize == 0) then
X   set TableSize = $pr
Xendif
X
X./getans "Enter the hash table size" integer "$TableSize" .$$
Xset TableSize = `cat .$$`
X
Xecho ""
X
X# !!! I need to fix this:  /dev/kmem might not exist on some machines !!!
X
X# determine the right way to invoke ls to get full output
Xset ls = "ls -l"
Xif (`$ls getans | wc -w` < 9) then
X   set ls = "ls -lg"
Xendif
X
Xset t_owner = root
Xset t_group = wheel
Xif (-e /proc) then
X   cat <<EOF
XUh oh!  I see /proc out there.  Some new Unix variants provide the /proc
Xfile system as a mechanism to get to a process's address space.  This
Xdirectory is typically only accessible by root.  However, there are a few
Xsystems (such as DG/UX) on which this directory exists, but isn't used.
XI'm going to assume that top needs to run setuid to root, but you should
Xdouble check and use mode 2755 (set group id) if top doesn't really need
Xroot access.  If you are running SunOS 5.x then you will need to install
Xtop setuid root (owner root and mode 4711).
X
XEOF
X   set t_mode = 4711
Xelse if (-e /dev/kmem) then
X   $ls /dev/kmem >/tmp/$$.b
X   grep '^....r..r..' /tmp/$$.b >&/dev/null
X   if ($status == 1) then
X      grep '^....r..-..' /tmp/$$.b >&/dev/null
X      if ($status == 0) then
X         set t_group = `awk ' { print $4 }' /tmp/$$.b`
X         set t_mode = 2755
X         echo "It looks like only group $t_group can read the memory devices."
X      else
X         set t_mode = 4755
X         echo "It looks like only root can read the memory devices."
X      endif
X   else
X      set t_mode = 755
X      echo "It looks like anybody can read the memory devices."
X   endif
Xelse
X   echo "It looks like there are no memory device special files."
X   set t_mode = 755
Xendif
Xif ($nodefaults) then
X   set owner = $t_owner
X   set group = $t_group
X   set mode =  $t_mode
Xendif
Xecho "Tell me how to set the following when top is installed:"
X./getans "Owner" user "$owner" .$$
Xset owner = `cat .$$`
X./getans "Group owner" group "$group" .$$
Xset group = `cat .$$`
X./getans "Mode" integer "$mode" .$$
Xset mode = `cat .$$`
Xrm -f /tmp/$$.b
X
Xecho ""
X./getans "Install the executable in this directory" file "$bindir" .$$
Xset bindir = `cat .$$`
X
Xecho ""
X./getans "Install the manual page in this directory" file "$mandir" .$$
Xset mandir = `cat .$$`
X
Xecho ""
X./getans "Install the manual page with this extension" string "$manext" .$$
Xset manext = `cat .$$`
X
Xecho ""
X./getans "Install the manual page as 'man' or 'catman'" string "$mansty" .$$
Xset mansty = `cat .$$`
X
Xecho ""
Xecho "We are done with the questions."
X
Xecho "Saving configuration..."
X# save settings to use as defaults the next time
Xrm -f .defaults
Xforeach v ($vars)
X   set tmp = `eval echo \$$v`
X   echo set $v = "'$tmp'" >>.defaults
Xend
X
Xfast:
X
X# set variables which contain module lists
Xset modules = `cat $$.f`
Xset manmodules = `cat $$.m`
X
X# clean up
Xrm -f $$.f $$.m $$.n
X
X# set the link for machine.c
Xrm -f machine.c machine.o
Xln -s machine/m_${module}.c machine.c
Xset libs = `grep LIBS: machine/m_${module}.desc | sed -e 's/^.[^:]*: *//'`
Xset cflgs = `grep CFLAGS: machine/m_${module}.desc | sed -e 's/^.[^:]*: *//'`
X
Xif ( { grep -s SIGKILL /usr/include/signal.h } ) then
X    set signal="/usr/include/signal.h"
Xelse
X    set signal="/usr/include/sys/signal.h"
Xendif
X
X
Xecho "Building Makefile..."
Xsed -e "s|%topn%|$topn|" \
X    -e "s|%delay%|$delay|" \
X    -e "s|%owner%|$owner|" \
X    -e "s|%group%|$group|" \
X    -e "s|%mode%|$mode|" \
X    -e "s|%bindir%|$bindir|" \
X    -e "s|%mandir%|$mandir|" \
X    -e "s|%manext%|$manext|" \
X    -e "s|%mansty%|$mansty|" \
X    -e "s|%tablesize%|$TableSize|" \
X    -e "s|%libs%|$libs|" \
X    -e "s|%cflgs%|$cflgs|" \
X    -e "s|%cdefs%|$cdefs|" \
X    -e "s|%modules%|$modules|" \
X    -e "s|%manmodules%|$manmodules|" \
X    -e "s|%signal%|$signal|" \
X    -e "s|%cc%|$Cmdcc|" \
X    -e "s|%awk%|$Cmdawk|" \
X    -e "s|%install%|$Cmdinstall|" \
X    -e "s|%shell%|$Cmdshell|" \
X	Makefile.X >Makefile
X
Xecho "Building top.local.h..."
Xsed -e "s|%LoadMax%|$LoadMax|" \
X    -e "s|%TableSize%|$TableSize|" \
X    -e "s|%NominalTopn%|$NominalTopn|" \
X    -e "s|%topn%|$topn|" \
X    -e "s|%delay%|$delay|" \
X    -e "s|%random%|$random|" \
X	top.local.H >top.local.h
X
Xecho "Building top.1..."
Xsed -e "s|%topn%|$topn|" \
X    -e "s|%delay%|$delay|" \
X	top.X >top.1
Xif (-e machine/m_${module}.man ) then
X    cat machine/m_${module}.man >>top.1
Xendif
X
X# clean up
Xrm -f .$$
X
Xecho 'Doing a "make clean".'
Xmake clean
X
Xecho 'To create the executable, type "make".'
Xexit 0
X
Xbyebye:
Xrm -f .$$ $$.[fmn] /tmp/$$.[ab]
Xexit 1
END_OF_FILE
if test 12585 -ne `wc -c <'Configure'`; then
    echo shar: \"'Configure'\" unpacked with wrong size!
fi
chmod +x 'Configure'
# end of 'Configure'
fi
if test -f 'commands.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'commands.c'\"
else
echo shar: Extracting \"'commands.c'\" \(10344 characters\)
sed "s/^X//" >'commands.c' <<'END_OF_FILE'
X/*
X *  Top users/processes display for Unix
X *  Version 3
X *
X *  This program may be freely redistributed,
X *  but this entire comment MUST remain intact.
X *
X *  Copyright (c) 1984, 1989, William LeFebvre, Rice University
X *  Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
X */
X
X/*
X *  This file contains the routines that implement some of the interactive
X *  mode commands.  Note that some of the commands are implemented in-line
X *  in "main".  This is necessary because they change the global state of
X *  "top" (i.e.:  changing the number of processes to display).
X */
X
X#include "os.h"
X#include <ctype.h>
X#include <signal.h>
X#include <errno.h>
X#include <sys/time.h>
X#include <sys/resource.h>
X
X#include "sigdesc.h"		/* generated automatically */
X#include "boolean.h"
X#include "utils.h"
X
Xextern int  errno;
X
Xextern char *copyright;
X
X/* imported from screen.c */
Xextern int overstrike;
X
Xint err_compar();
Xchar *err_string();
X
X/*
X *  show_help() - display the help screen; invoked in response to
X *		either 'h' or '?'.
X */
X
Xshow_help()
X
X{
X    printf("Top version %s, %s\n", version_string(), copyright);
X    fputs("\n\n\
XA top users display for Unix\n\
X\n\
XThese single-character commands are available:\n\
X\n\
X^L      - redraw screen\n\
Xq       - quit\n\
Xh or ?  - help; show this text\n", stdout);
X
X    /* not all commands are availalbe with overstrike terminals */
X    if (overstrike)
X    {
X	fputs("\n\
XOther commands are also available, but this terminal is not\n\
Xsophisticated enough to handle those commands gracefully.\n\n", stdout);
X    }
X    else
X    {
X	fputs("\
Xd       - change number of displays to show\n\
Xe       - list errors generated by last \"kill\" or \"renice\" command\n\
Xi       - toggle the displaying of idle processes\n\
XI       - same as 'i'\n\
Xk       - kill processes; send a signal to a list of processes\n\
Xn or #  - change number of processes to display\n\
Xr       - renice a process\n\
Xs       - change number of seconds to delay between updates\n\
Xu       - display processes for only one user (+ selects all users)\n\
X\n\
X\n", stdout);
X    }
X}
X
X/*
X *  Utility routines that help with some of the commands.
X */
X
Xchar *next_field(str)
X
Xregister char *str;
X
X{
X    if ((str = strchr(str, ' ')) == NULL)
X    {
X	return(NULL);
X    }
X    *str = '\0';
X    while (*++str == ' ') /* loop */;
X
X    /* if there is nothing left of the string, return NULL */
X    /* This fix is dedicated to Greg Earle */
X    return(*str == '\0' ? NULL : str);
X}
X
Xscanint(str, intp)
X
Xchar *str;
Xint  *intp;
X
X{
X    register int val = 0;
X    register char ch;
X
X    /* if there is nothing left of the string, flag it as an error */
X    /* This fix is dedicated to Greg Earle */
X    if (*str == '\0')
X    {
X	return(-1);
X    }
X
X    while ((ch = *str++) != '\0')
X    {
X	if (isdigit(ch))
X	{
X	    val = val * 10 + (ch - '0');
X	}
X	else if (isspace(ch))
X	{
X	    break;
X	}
X	else
X	{
X	    return(-1);
X	}
X    }
X    *intp = val;
X    return(0);
X}
X
X/*
X *  Some of the commands make system calls that could generate errors.
X *  These errors are collected up in an array of structures for later
X *  contemplation and display.  Such routines return a string containing an
X *  error message, or NULL if no errors occurred.  The next few routines are
X *  for manipulating and displaying these errors.  We need an upper limit on
X *  the number of errors, so we arbitrarily choose 20.
X */
X
X#define ERRMAX 20
X
Xstruct errs		/* structure for a system-call error */
X{
X    int  errno;		/* value of errno (that is, the actual error) */
X    char *arg;		/* argument that caused the error */
X};
X
Xstatic struct errs errs[ERRMAX];
Xstatic int errcnt;
Xstatic char *err_toomany = " too many errors occurred";
Xstatic char *err_listem = 
X	" Many errors occurred.  Press `e' to display the list of errors.";
X
X/* These macros get used to reset and log the errors */
X#define ERR_RESET   errcnt = 0
X#define ERROR(p, e) if (errcnt >= ERRMAX) \
X		    { \
X			return(err_toomany); \
X		    } \
X		    else \
X		    { \
X			errs[errcnt].arg = (p); \
X			errs[errcnt++].errno = (e); \
X		    }
X
X/*
X *  err_string() - return an appropriate error string.  This is what the
X *	command will return for displaying.  If no errors were logged, then
X *	return NULL.  The maximum length of the error string is defined by
X *	"STRMAX".
X */
X
X#define STRMAX 80
X
Xchar *err_string()
X
X{
X    register struct errs *errp;
X    register int  cnt = 0;
X    register int  first = Yes;
X    register int  currerr = -1;
X    int stringlen;		/* characters still available in "string" */
X    static char string[STRMAX];
X
X    /* if there are no errors, return NULL */
X    if (errcnt == 0)
X    {
X	return(NULL);
X    }
X
X    /* sort the errors */
X    qsort((char *)errs, errcnt, sizeof(struct errs), err_compar);
X
X    /* need a space at the front of the error string */
X    string[0] = ' ';
X    string[1] = '\0';
X    stringlen = STRMAX - 2;
X
X    /* loop thru the sorted list, building an error string */
X    while (cnt < errcnt)
X    {
X	errp = &(errs[cnt++]);
X	if (errp->errno != currerr)
X	{
X	    if (currerr != -1)
X	    {
X		if ((stringlen = str_adderr(string, stringlen, currerr)) < 2)
X		{
X		    return(err_listem);
X		}
X		(void) strcat(string, "; ");	  /* we know there's more */
X	    }
X	    currerr = errp->errno;
X	    first = Yes;
X	}
X	if ((stringlen = str_addarg(string, stringlen, errp->arg, first)) ==0)
X	{
X	    return(err_listem);
X	}
X	first = No;
X    }
X
X    /* add final message */
X    stringlen = str_adderr(string, stringlen, currerr);
X
X    /* return the error string */
X    return(stringlen == 0 ? err_listem : string);
X}
X
X/*
X *  str_adderr(str, len, err) - add an explanation of error "err" to
X *	the string "str".
X */
X
Xstr_adderr(str, len, err)
X
Xchar *str;
Xint len;
Xint err;
X
X{
X    register char *msg;
X    register int  msglen;
X
X    msg = err == 0 ? "Not a number" : errmsg(err);
X    msglen = strlen(msg) + 2;
X    if (len <= msglen)
X    {
X	return(0);
X    }
X    (void) strcat(str, ": ");
X    (void) strcat(str, msg);
X    return(len - msglen);
X}
X
X/*
X *  str_addarg(str, len, arg, first) - add the string argument "arg" to
X *	the string "str".  This is the first in the group when "first"
X *	is set (indicating that a comma should NOT be added to the front).
X */
X
Xstr_addarg(str, len, arg, first)
X
Xchar *str;
Xint  len;
Xchar *arg;
Xint  first;
X
X{
X    register int arglen;
X
X    arglen = strlen(arg);
X    if (!first)
X    {
X	arglen += 2;
X    }
X    if (len <= arglen)
X    {
X	return(0);
X    }
X    if (!first)
X    {
X	(void) strcat(str, ", ");
X    }
X    (void) strcat(str, arg);
X    return(len - arglen);
X}
X
X/*
X *  err_compar(p1, p2) - comparison routine used by "qsort"
X *	for sorting errors.
X */
X
Xerr_compar(p1, p2)
X
Xregister struct errs *p1, *p2;
X
X{
X    register int result;
X
X    if ((result = p1->errno - p2->errno) == 0)
X    {
X	return(strcmp(p1->arg, p2->arg));
X    }
X    return(result);
X}
X
X/*
X *  error_count() - return the number of errors currently logged.
X */
X
Xerror_count()
X
X{
X    return(errcnt);
X}
X
X/*
X *  show_errors() - display on stdout the current log of errors.
X */
X
Xshow_errors()
X
X{
X    register int cnt = 0;
X    register struct errs *errp = errs;
X
X    printf("%d error%s:\n\n", errcnt, errcnt == 1 ? "" : "s");
X    while (cnt++ < errcnt)
X    {
X	printf("%5s: %s\n", errp->arg,
X	    errp->errno == 0 ? "Not a number" : errmsg(errp->errno));
X	errp++;
X    }
X}
X
X/*
X *  kill_procs(str) - send signals to processes, much like the "kill"
X *		command does; invoked in response to 'k'.
X */
X
Xchar *kill_procs(str)
X
Xchar *str;
X
X{
X    register char *nptr;
X    int signum = SIGTERM;	/* default */
X    int procnum;
X    struct sigdesc *sigp;
X    int uid;
X
X    /* reset error array */
X    ERR_RESET;
X
X    /* remember our uid */
X    uid = getuid();
X
X    /* skip over leading white space */
X    while (isspace(*str)) str++;
X
X    if (str[0] == '-')
X    {
X	/* explicit signal specified */
X	if ((nptr = next_field(str)) == NULL)
X	{
X	    return(" kill: no processes specified");
X	}
X
X	if (isdigit(str[1]))
X	{
X	    (void) scanint(str + 1, &signum);
X	    if (signum <= 0 || signum >= NSIG)
X	    {
X		return(" invalid signal number");
X	    }
X	}
X	else 
X	{
X	    /* translate the name into a number */
X	    for (sigp = sigdesc; sigp->name != NULL; sigp++)
X	    {
X		if (strcmp(sigp->name, str + 1) == 0)
X		{
X		    signum = sigp->number;
X		    break;
X		}
X	    }
X
X	    /* was it ever found */
X	    if (sigp->name == NULL)
X	    {
X		return(" bad signal name");
X	    }
X	}
X	/* put the new pointer in place */
X	str = nptr;
X    }
X
X    /* loop thru the string, killing processes */
X    do
X    {
X	if (scanint(str, &procnum) == -1)
X	{
X	    ERROR(str, 0);
X	}
X	else
X	{
X	    /* check process owner if we're not root */
X	    if (uid && (uid != proc_owner(procnum)))
X	    {
X		ERROR(str, EACCES);
X	    }
X	    /* go in for the kill */
X	    else if (kill(procnum, signum) == -1)
X	    {
X		/* chalk up an error */
X		ERROR(str, errno);
X	    }
X	}
X    } while ((str = next_field(str)) != NULL);
X
X    /* return appropriate error string */
X    return(err_string());
X}
X
X/*
X *  renice_procs(str) - change the "nice" of processes, much like the
X *		"renice" command does; invoked in response to 'r'.
X */
X
Xchar *renice_procs(str)
X
Xchar *str;
X
X{
X    register char negate;
X    int prio;
X    int procnum;
X    int uid;
X
X    ERR_RESET;
X    uid = getuid();
X
X    /* allow for negative priority values */
X    if ((negate = (*str == '-')) != 0)
X    {
X	/* move past the minus sign */
X	str++;
X    }
X
X    /* use procnum as a temporary holding place and get the number */
X    procnum = scanint(str, &prio);
X
X    /* negate if necessary */
X    if (negate)
X    {
X	prio = -prio;
X    }
X
X#if defined(PRIO_MIN) && defined(PRIO_MAX)
X    /* check for validity */
X    if (procnum == -1 || prio < PRIO_MIN || prio > PRIO_MAX)
X    {
X	return(" bad priority value");
X    }
X#endif
X
X    /* move to the first process number */
X    if ((str = next_field(str)) == NULL)
X    {
X	return(" no processes specified");
X    }
X
X    /* loop thru the process numbers, renicing each one */
X    do
X    {
X	if (scanint(str, &procnum) == -1)
X	{
X	    ERROR(str, 0);
X	}
X
X	/* check process owner if we're not root */
X	else if (uid && (uid != proc_owner(procnum)))
X	{
X	    ERROR(str, EACCES);
X	}
X	else if (setpriority(PRIO_PROCESS, procnum, prio) == -1)
X	{
X	    ERROR(str, errno);
X	}
X    } while ((str = next_field(str)) != NULL);
X
X    /* return appropriate error string */
X    return(err_string());
X}
X
END_OF_FILE
if test 10344 -ne `wc -c <'commands.c'`; then
    echo shar: \"'commands.c'\" unpacked with wrong size!
fi
# end of 'commands.c'
fi
if test -f 'machine/m_dgux.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machine/m_dgux.c'\"
else
echo shar: Extracting \"'machine/m_dgux.c'\" \(12268 characters\)
sed "s/^X//" >'machine/m_dgux.c' <<'END_OF_FILE'
X/*
X * top - a top users display for Unix
X *
X * SYNOPSIS:  for DG AViiON with DG/UX 5.4+
X *
X * DESCRIPTION:
X * A top module for DG/UX 5.4 systems.
X * Uses DG/UX system calls to get info from the kernel.
X * (NB. top DOES NOT need to be installed setuid root under DG/UX 5.4.2)
X *
X * AUTHOR:  Mike Williams <mike@inform.co.nz>
X */
X
X/*
X * NOTE: This module will only work with top versions 3.1 and later!
X */
X
X#include <stdlib.h> 
X#include <unistd.h>
X#include <stdio.h>
X
X#include <sys/dg_sys_info.h>
X#include <sys/dg_process_info.h>
X#include <sys/systeminfo.h> 
X#include <sys/sysmacros.h> 
X
X#include "top.h"
X#include "machine.h"
X#include "utils.h"
X
X/*--- process formatting --------------------------------------------------*/
X
Xstatic char header[] =
X  "  PID X         PRI NICE C    SIZE STATE    TIME    CPU COMMAND";
X/* ddddd ssssssss dddd ddd dd ddddddK ssssssdddd:dd dd.dd% sssssssssssssssss...
X * 0123456   -- field to fill in starts at header+6 */
X#define UNAME_START 6
X
X#define Proc_format \
X     "%5d %-8.8s %4d %3d %2d %7s %-6s %6s %5.2f%% %.20s"
X
X/*--- process states ------------------------------------------------------*/
X
Xstatic char* procStateNames[] = {
X    "", " sleeping, ", " waiting, ", " running, ", " starting, ",
X    " zombie, ", " stopped, ",
X    NULL
X};
X
Xstatic char* procStateAbbrevs[] = {
X    "", "sleep", "wait", "run", "start", "zombie", "stop",
X    NULL
X};
X
X#define N_PROCESS_STATES \
X(sizeof (procStateNames) / sizeof (procStateNames[0]) - 1)
X
Xstatic int processStats[N_PROCESS_STATES];
X
X/*--- cpu states ----------------------------------------------------------*/
X
Xenum {
X    CPU_user,
X    CPU_system,
X    CPU_idle,
X    CPU_io_wait,
X};
X
Xstatic char* cpuStateNames[] = {
X    "user", "system", "idle", "io_wait",
X    NULL
X};
X
X#define N_CPU_STATES \
X(sizeof (cpuStateNames) / sizeof (cpuStateNames[0]) - 1)
X
Xstatic int cpuStats[N_CPU_STATES];
X
X/*--- memory statistics ---------------------------------------------------*/
X
Xenum {
X    MEM_available,
X    MEM_used,
X    MEM_free,
X    MEM_freeswap,
X};
X
Xstatic char* memoryNames[] = {
X    "K physical, ", "K in use, ", "K free, ", "K free swap, ", NULL
X};
X
X#define N_MEMORY_STATS \
X(sizeof (memoryNames) / sizeof (memoryNames[0]) - 1)
X
Xstatic int memoryStats[N_MEMORY_STATS];
X
X/*--- conversion macros ---------------------------------------------------*/
X
X/* Convert clicks (kernel pages) to kbytes ... */
X#define pagetok(size) ctob(size) >> LOG1024
X
X/* Convert timeval's to double */
X#define tvtod(tval) (1000000.0 * (tval).tv_sec + 1.0 * (tval).tv_usec)
X
X/* Scale timeval's onto longs */
X#define scaledtv(tval) (tvtod (tval) / 4096) 
X
X/*--- process table -------------------------------------------------------*/
X
Xtypedef struct _ProcInfo {
X    struct dg_process_info    p_info;
X    double 		      cpu_time;
X    double 		      fraction_cpu;
X} ProcInfo;
X
Xstatic ProcInfo* 	      processInfo;
Xstatic ProcInfo** 	      activeProcessInfo;
X
Xint 			      activeIndex;
X
Xtypedef struct _ProcTime {
X    pid_t 		      pid;
X    double 		      cpu_time;
X} ProcTime;
X
Xstatic ProcTime* 	      oldProcessTimes;
Xstatic int 		      n_oldProcessTimes;
X
Xstatic double 		      lastTime;
Xstatic double 		      thisTime;
Xstatic double 		      timeSlice;
X
X/*=========================================================================*/
X/*=== top "Callback" routines =============================================*/
X
Xstatic int IntCmp (i1, i2)
X  int* 			i1;
X  int* 			i2;
X{
X    return (*i2 - *i1);
X}
X
X/*=== Data collection =====================================================*/
X
Xint machine_init (statics)
X  /*~~~~~~~~~~~~
X   */
X  struct statics *statics;
X{
X    struct dg_sys_info_pm_info pm_info;
X    int 		      table_size;
X
X    /* fill in the statics information */
X    statics->procstate_names = procStateNames;
X    statics->cpustate_names = cpuStateNames;
X    statics->memory_names = memoryNames;
X
X    dg_sys_info ((long *)&pm_info,
X		 DG_SYS_INFO_PM_INFO_TYPE,
X		 DG_SYS_INFO_PM_VERSION_0);
X    table_size = pm_info.process_table_size + 1;
X
X    processInfo = (ProcInfo *) 
X	malloc (sizeof (processInfo[0]) * table_size);
X    activeProcessInfo = (ProcInfo **) 
X	malloc (sizeof (activeProcessInfo[0]) * table_size);
X    oldProcessTimes = (ProcTime *) 
X	malloc (sizeof (oldProcessTimes[0]) * table_size);
X
X    lastTime = 0;
X
X    return(0);
X}
X
Xint get_system_info (si)
X  /*~~~~~~~~~~~~~~~
X   */
X  struct system_info *si;
X{
X    struct dg_sys_info_vm_info    vm_info;
X    struct dg_sys_info_pm_info    pm_info;
X    struct dg_sys_info_load_info  load_info;
X
X    static long cpu_time [N_CPU_STATES];
X    static long cpu_old [N_CPU_STATES];
X    static long cpu_diff [N_CPU_STATES];
X
X    /* memory info */
X    
X    dg_sys_info ((long *)&vm_info,
X		 DG_SYS_INFO_VM_INFO_TYPE,
X		 DG_SYS_INFO_VM_VERSION_0);
X
X    memoryStats[MEM_available] = sysconf (_SC_AVAILMEM);
X    memoryStats[MEM_free]      = pagetok (vm_info.freemem);
X    memoryStats[MEM_used]      = memoryStats[0] - memoryStats[2];
X    memoryStats[MEM_freeswap]  = pagetok (vm_info.freeswap);
X    si->memory 		       = memoryStats;
X
X    /* process info */
X    
X    dg_sys_info ((long *)&pm_info,
X		 DG_SYS_INFO_PM_INFO_TYPE,
X		 DG_SYS_INFO_PM_VERSION_0);
X
X    si->last_pid 	      = 0;
X    si->p_total 	      = pm_info.process_count;
X    si->p_active 	      = pm_info.bound_runnable_process_count;
X
X    cpu_time[CPU_user]        = scaledtv (pm_info.user_time);
X    cpu_time[CPU_system]      = scaledtv (pm_info.system_time);
X    cpu_time[CPU_idle] 	      = scaledtv (pm_info.idle_time);
X    cpu_time[CPU_io_wait]     = scaledtv (pm_info.io_wait_time);
X    percentages (N_CPU_STATES, cpuStats, cpu_time, cpu_old, cpu_diff);
X    si->cpustates 	      = cpuStats;
X
X    /* calculate timescale */
X
X    thisTime = tvtod (pm_info.current_time);
X    timeSlice = thisTime - lastTime;
X    lastTime = thisTime;
X    
X    /* load info */
X    
X    dg_sys_info ((long *)&load_info,
X		 DG_SYS_INFO_LOAD_INFO_TYPE,
X		 DG_SYS_INFO_LOAD_VERSION_0);
X
X    si->load_avg[0] 	= load_info.one_minute;
X    si->load_avg[1] 	= load_info.five_minute;
X    si->load_avg[2] 	= load_info.fifteen_minute;
X
X    return 1;
X}
X
Xcaddr_t get_process_info (si, sel, compare)
X  /*    ~~~~~~~~~~~~~~~~ 
X   */
X  struct system_info* 	si;
X  struct process_select* sel;
X  int 			(*compare)();
X{
X    long 		key = DG_PROCESS_INFO_INITIAL_KEY;
X 			
X    int 		n_total = 0;
X    int 		n_active = 0;
X
X    ProcInfo* 		pp;
X    int 		i;
X
X    bzero((char *)processStats, sizeof(processStats));
X
X    while (dg_process_info (DG_PROCESS_INFO_SELECTOR_ALL_PROCESSES, 0,
X			    DG_PROCESS_INFO_CMD_NAME_ONLY,
X			    &key,
X			    &(processInfo[n_total].p_info),
X			    DG_PROCESS_INFO_CURRENT_VERSION) == 1) {
X
X	ProcInfo*       pp = &(processInfo[n_total++]);
X	int 		pid = pp->p_info.process_id;
X	ProcTime* 	old_time;
X
X	/* Increment count for this process state */
X	++processStats[pp->p_info.state];
X
X	/* Calculate % CPU usage */
X	pp->cpu_time = (tvtod (pp->p_info.system_time) + 
X			tvtod (pp->p_info.user_time));
X	old_time = (ProcTime *) 
X	    bsearch (&pid, oldProcessTimes, 
X		     n_oldProcessTimes, sizeof (ProcTime),
X		     IntCmp);
X	pp->fraction_cpu = (old_time 
X			    ? ((pp->cpu_time - old_time->cpu_time)
X			       / timeSlice) 
X			    : 0.0);
X
X	/* Skip if process not classed as "active" */
X	if ((pp->p_info.state == DG_PROCESS_INFO_STATUS_TERMINATED) ||
X	    (!sel->idle 
X	     && (pp->p_info.state != DG_PROCESS_INFO_STATUS_RUNNING)
X	     && (pp->p_info.state != DG_PROCESS_INFO_STATUS_WAITING)) ||
X	    (sel->uid != -1 && pp->p_info.user_id != (uid_t)sel->uid) ||
X	    (!sel->system && (pp->p_info.user_id == 0 &&
X			     pp->p_info.parent_process_id == 1)) ||
X	    (sel->command && strcmp (pp->p_info.cmd, sel->command) != 0))
X	    continue;
X
X	activeProcessInfo[n_active++] = pp;
X	
X    }
X
X    activeProcessInfo[n_active] = NULL;
X
X    si->p_total 	= n_total;
X    si->p_active 	= n_active;
X    si->procstates 	= processStats;
X
X    /* If requested, sort the "interesting" processes */
X    if (compare != NULL) qsort((void *)activeProcessInfo, 
X			       n_active, 
X			       sizeof (ProcInfo *), 
X			       compare);
X
X    /* Record scaled CPU totals, for calculating %CPU */
X    n_oldProcessTimes = n_total;
X    for (i = 0; i < n_oldProcessTimes; i++) {
X	oldProcessTimes[i].pid = processInfo[i].p_info.process_id;
X	oldProcessTimes[i].cpu_time = processInfo[i].cpu_time;
X    }
X    qsort (oldProcessTimes, n_oldProcessTimes, sizeof (ProcTime), IntCmp);
X
X    /* pass back a handle */
X    activeIndex = 0;
X    return ((caddr_t) &activeIndex);
X}
X
X/*=== Process comparison routine ==========================================*/
X
X/*
X * Sort keys are (in descending order of importance):
X *     - percent cpu
X *     - cpu ticks
X *     - state
X *     - resident set size
X *     
X * The process states are ordered as follows:
X *     - zombie
X *     - wait
X *     - sleep
X *     - stop
X *     - start
X *     - run
X */
X
Xstatic unsigned char sortedState[] =
X{
X    0,	                                /* not used */
X    3,	                                /* sleep */
X    1,	                                /* wait	*/
X    6,	                                /* run */
X    5,	                                /* start */
X    2,	                                /* zombie */
X    4,	                                /* stop */
X};
X
Xint proc_compare(pp1, pp2)
X  /*~~~~~~~~~~~~
X   */
X  ProcInfo** 		pp1;
X  ProcInfo** 		pp2;
X{
X    register ProcInfo* 	p1;
X    register ProcInfo* 	p2;
X    register int 	result;
X    register float 	lresult;
X
X    register long 	p1_cpu;
X    register long 	p2_cpu;
X
X    /* remove one level of indirection */
X    p1 = *pp1;
X    p2 = *pp2;
X
X    /* calculate cpu totals */
X    p1_cpu = p1->p_info.system_time.tv_sec + p1->p_info.user_time.tv_sec;
X    p2_cpu = p2->p_info.system_time.tv_sec + p2->p_info.user_time.tv_sec;
X
X    /* Compare %CPU usage */
X    if ((lresult = (p2->fraction_cpu - p1->fraction_cpu)) != 0)
X	return lresult < 0 ? -1 : 1;
X
X    /* Compare other fields until one differs */
X    ((result = (p2->p_info.cpu_usage - p1->p_info.cpu_usage)) ||
X     (result = (sortedState [p2->p_info.state] - 
X		sortedState [p1->p_info.state])) ||
X     (result = (p2->p_info.priority - p1->p_info.priority)) ||
X     (result = (p2->p_info.resident_process_size - 
X		p1->p_info.resident_process_size)) ||
X     (result = (p1->p_info.process_id - p2->p_info.process_id)));
X
X    return result;
X}
X
X/*=== Process owner validation ============================================*/
X
X/*
X * proc_owner(pid) - returns the uid that owns process "pid", or -1 if
X *		the process does not exist.
X *		It is EXTREMLY IMPORTANT that this function work correctly.
X *		If top runs setuid root (as in SVR4), then this function
X *		is the only thing that stands in the way of a serious
X *		security problem.  It validates requests for the "kill"
X *		and "renice" commands.
X */
X
Xint proc_owner (pid)
X  /*~~~~~~~~~~
X   */
X  int pid;
X{
X    register int      i;
X    ProcInfo* 	      pp;
X
X    for (i = 0; (pp = activeProcessInfo [i]); i++) {
X	if (pp->p_info.process_id == pid) 
X	    return (int)pp->p_info.user_id;
X    }
X    return(-1);
X}
X
X/*=== Output formatting ===================================================*/
X
Xchar* format_header (uname_field)
X  /*  ~~~~~~~~~~~~~
X   */
X  register char* 	uname_field;
X{
X    register char* 	ptr;
X
X    ptr = header + UNAME_START;
X    while (*uname_field != '\0')
X    {
X	*ptr++ = *uname_field++;
X    }
X
X    return(header);
X}
X
Xchar* format_next_process (index_ptr, get_userid)
X  /*  ~~~~~~~~~~~~~~~~~~~
X   */
X  int* 			index_ptr;
X  char* 		(*get_userid)();
X{
X    static char 	fmt[MAX_COLS];
X
X    int 		proc_index;
X    ProcInfo* 		pp;
X    long 		proc_cpu;
X
X    proc_index = (*index_ptr)++;
X    pp = activeProcessInfo [proc_index];
X    proc_cpu = pp->p_info.system_time.tv_sec + pp->p_info.user_time.tv_sec;
X
X    /* format this entry */
X
X    sprintf (fmt,
X	     Proc_format,
X	     pp->p_info.process_id,
X	     (*get_userid) (pp->p_info.user_id),
X	     pp->p_info.priority,
X	     pp->p_info.nice_value,
X	     pp->p_info.cpu_usage,
X	     format_k(pagetok (pp->p_info.resident_process_size)),
X	     procStateAbbrevs[pp->p_info.state],
X	     format_time(proc_cpu),
X	     100.0 * pp->fraction_cpu,
X	     pp->p_info.cmd);
X    
X    return(fmt);
X}
X
X/*=== END of m_dgux.c =====================================================*/
END_OF_FILE
if test 12268 -ne `wc -c <'machine/m_dgux.c'`; then
    echo shar: \"'machine/m_dgux.c'\" unpacked with wrong size!
fi
# end of 'machine/m_dgux.c'
fi
if test -f 'top.X' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'top.X'\"
else
echo shar: Extracting \"'top.X'\" \(9945 characters\)
sed "s/^X//" >'top.X' <<'END_OF_FILE'
X.\" NOTE:  changes to the manual page for "top" should be made in the
X.\"        file "top.X" and NOT in the file "top.1".
X.nr N %topn%
X.nr D %delay%
X.TH TOP 1 Local
X.UC 4
X.SH NAME
Xtop \- display and update information about the top cpu processes
X.SH SYNOPSIS
X.B top
X[
X.B \-SbiInqu
X] [
X.BI \-d count
X] [
X.BI \-s time
X] [
X.BI \-U username
X] [
X.I number
X]
X.SH DESCRIPTION
X.\" This defines appropriate quote strings for nroff and troff
X.ds lq \&"
X.ds rq \&"
X.if t .ds lq ``
X.if t .ds rq ''
X.\" Just in case these number registers aren't set yet...
X.if \nN==0 .nr N 10
X.if \nD==0 .nr D 5
X.I Top
Xdisplays the top
X.if !\nN==-1 \nN
Xprocesses on the system and periodically updates this information.
X.if \nN==-1 \
X\{\
XIf standard output is an intelligent terminal (see below) then
Xas many processes as will fit on the terminal screen are displayed
Xby default.  Otherwise, a good number of them are shown (around 20).
X.\}
XRaw cpu percentage is used to rank the processes.  If
X.I number
Xis given, then the top
X.I number
Xprocesses will be displayed instead of the default.
X.PP
X.I Top
Xmakes a distinction between terminals that support advanced capabilities
Xand those that do not.  This
Xdistinction affects the choice of defaults for certain options.  In the
Xremainder of this document, an \*(lqintelligent\*(rq terminal is one that
Xsupports cursor addressing, clear screen, and clear to end of line.
XConversely, a \*(lqdumb\*(rq terminal is one that does not support such
Xfeatures.  If the output of
X.I top
Xis redirected to a file, it acts as if it were being run on a dumb
Xterminal.
X.SH OPTIONS
X.TP
X.B \-S
XShow system processes in the display.  Normally, system processes such as
Xthe pager and the swapper are not shown.  This option makes them visible.
X.TP
X.B \-b
XUse \*(lqbatch\*(rq mode.  In this mode, all input from the terminal is
Xignored.  Interrupt characters (such as ^C and ^\e) still have an effect.
XThis is the default on a dumb terminal, or when the output is not a terminal.
X.TP
X.B \-i
XUse \*(lqinteractive\*(rq mode.  In this mode, any input is immediately
Xread for processing.  See the section on \*(lqInteractive Mode\*(rq
Xfor an explanation of
Xwhich keys perform what functions.  After the command is processed, the
Xscreen will immediately be updated, even if the command was not
Xunderstood.  This mode is the default when standard output is an
Xintelligent terminal.
X.TP
X.B \-I
XDo not display idle processes.
XBy default, top displays both active and idle processes.
X.TP
X.B \-n
XUse \*(lqnon-interactive\*(rq mode.  This is indentical to \*(lqbatch\*(rq
Xmode.
X.TP
X.B \-q
XRenice
X.I top
Xto -20 so that it will run faster.  This can be used when the system is
Xbeing very sluggish to improve the possibility of discovering the problem.
XThis option can only be used by root.
X.TP
X.B \-u
XDo not take the time to map uid numbers to usernames.  Normally,
X.I top
Xwill read as much of the file \*(lq/etc/passwd\*(rq as is necessary to map
Xall the user id numbers it encounters into login names.  This option
Xdisables all that, while possibly decreasing execution time.  The uid
Xnumbers are displayed instead of the names.
X.TP
X.BI \-d count
XShow only
X.I count
Xdisplays, then exit.  A display is considered to be one update of the
Xscreen.  This option allows the user to select the number of displays he
Xwants to see before
X.I top
Xautomatically exits.  For intelligent terminals, no upper limit
Xis set.  The default is 1 for dumb terminals.
X.TP
X.BI \-s time
XSet the delay between screen updates to
X.I time
Xseconds.  The default delay between updates is \nD seconds.
X.TP
X.BI \-U username
XShow only those processes owned by
X.IR username .
XThis option currently only accepts usernames and will not understand
Xuid numbers.
X.PP
XBoth
X.I count
Xand
X.I number
Xfields can be specified as \*(lqinfinite\*(rq, indicating that they can
Xstretch as far as possible.  This is accomplished by using any proper
Xprefix of the keywords
X\*(lqinfinity\*(rq,
X\*(lqmaximum\*(rq,
Xor
X\*(lqall\*(rq.
XThe default for
X.I count
Xon an intelligent terminal is, in fact,
X.BI infinity .
X.PP
XThe environment variable
X.B TOP
Xis examined for options before the command line is scanned.  This enables
Xa user to set his or her own defaults.  The number of processes to display
Xcan also be specified in the environment variable
X.BR TOP .
XThe options
X.BR \-I ,
X.BR \-S ,
Xand
X.B \-u
Xare actually toggles.  A second specification of any of these options
Xwill negate the first.  Thus a user who has the environment variable
X.B TOP
Xset to \*(lq\-I\*(rq may use the command \*(lqtop \-I\*(rq to see idle processes.
X.SH "INTERACTIVE MODE"
XWhen
X.I top
Xis running in \*(lqinteractive mode\*(rq, it reads commands from the
Xterminal and acts upon them accordingly.  In this mode, the terminal is
Xput in \*(lqCBREAK\*(rq, so that a character will be
Xprocessed as soon as it is typed.  Almost always, a key will be
Xpressed when
X.I top
Xis between displays; that is, while it is waiting for
X.I time
Xseconds to elapse.  If this is the case, the command will be
Xprocessed and the display will be updated immediately thereafter
X(reflecting any changes that the command may have specified).  This
Xhappens even if the command was incorrect.  If a key is pressed while 
X.I top
Xis in the middle of updating the display, it will finish the update and
Xthen process the command.  Some commands require additional information,
Xand the user will be prompted accordingly.  While typing this information
Xin, the user's erase and kill keys (as set up by the command
X.IR stty )
Xare recognized, and a newline terminates the input.
X.PP
XThese commands are currently recognized (^L refers to control-L):
X.TP
X.B ^L
XRedraw the screen.
X.IP "\fBh\fP\ or\ \fB?\fP"
XDisplay a summary of the commands (help screen).
X.TP
X.B q
XQuit
X.IR top.
X.TP
X.B d
XChange the number of displays to show (prompt for new number).
XRemember that the next display counts as one, so typing
X.B d1
Xwill make
X.I top
Xshow one final display and then immediately exit.
X.TP
X.B n or #
XChange the number of processes to display (prompt for new number).
X.TP
X.B s
XChange the number of seconds to delay between displays
X(prompt for new number).
X.TP
X.B k
XSend a signal (\*(lqkill\*(rq by default) to a list of processes.  This
Xacts similarly to the command
X.IR kill (1)).
X.TP
X.B r
XChange the priority (the \*(lqnice\*(rq) of a list of processes.
XThis acts similarly to the command
X.IR renice (8)).
X.TP
X.B u
XDisplay only processes owned by a specific username (prompt for username).
XIf the username specified is simply \*(lq+\*(rq, then processes belonging
Xto all users will be displayed.
X.TP
X.B e
XDisplay a list of system errors (if any) generated by the last
X.BR k ill
Xor
X.BR r enice
Xcommand.
X.TP
X.B i
X(or
X.BR I)
XToggle the display of idle processes.
X.SH "THE DISPLAY"
XThe actual display varies depending on the specific variant of Unix
Xthat the machine is running.  This description may not exactly match
Xwhat is seen by top running on this particular machine.  Differences
Xare listed at the end of this manual entry.
X.PP
XThe top few lines of the display show general information
Xabout the state of the system, including
Xthe last process id assigned to a process (on most systems),
Xthe three load averages,
Xthe current time,
Xthe number of existing processes,
Xthe number of processes in each state
X(sleeping, running, starting, zombies, and stopped),
Xand a percentage of time spent in each of the processor states
X(user, nice, system, and idle).
XIt also includes information about physial and virtual memory allocation.
X.PP
XThe remainder of the screen displays information about individual
Xprocesses.  This display is similar in spirit to
X.IR ps (1)
Xbut it is not exactly the same.  PID is the process id, USERNAME is the name
Xof the process's owner (if
X.B \-u
Xis specified, a UID column will be substituted for USERNAME),
XPRI is the current priority of the process,
XNICE is the nice amount (in the range \-20 to 20),
XSIZE is the total size of the process (text, data, and stack),
XRES is the current amount of resident memory (both SIZE and RES are
Xgiven in kilobytes),
XSTATE is the current state (one of \*(lqsleep\*(rq, \*(lqWAIT\*(rq,
X\*(lqrun\*(rq, \*(lqidl\*(rq, \*(lqzomb\*(rq, or \*(lqstop\*(rq),
XTIME is the number of system and user cpu seconds that the process has used,
XWCPU, when displayed, is the weighted cpu percentage (this is the same
Xvalue that
X.IR ps (1)
Xdisplays as CPU),
XCPU is the raw percentage and is the field that is sorted to determine
Xthe order of the processes, and
XCOMMAND is the name of the command that the process is currently running
X(if the process is swapped out, this column is marked \*(lq<swapped>\*(rq).
X.SH NOTES
XThe \*(lqABANDONED\*(rq state (known in the kernel as \*(lqSWAIT\*(rq) was
Xabandoned, thus the name.  A process should never end up in this state.
X.SH AUTHOR
XWilliam LeFebvre, EECS Department, Northwestern University
X.SH ENVIRONMENT
X.DT
XTOP	user-configurable defaults for options.
X.SH FILES
X.DT
X/dev/kmem		kernel memory
X.br
X/dev/mem		physical memory
X.br
X/etc/passwd		used to map uid numbers to user names
X.br
X/vmunix		system image
X.SH BUGS
XDon't shoot me, but the default for
X.B \-I
Xhas changed once again.  So many people were confused by the fact that
X.I top
Xwasn't showing them all the processes that I have decided to make the
Xdefault behavior show idle processes, just like it did in version 2.
XBut to appease folks who can't stand that behavior, I have added the
Xability to set \*(lqdefault\*(rq options in the environment variable
X.B TOP
X(see the OPTIONS section).  Those who want the behavior that version
X3.0 had need only set the environment variable
X.B TOP
Xto \*(lq\-I\*(rq.
X.PP
XThe command name for swapped processes should be tracked down, but this
Xwould make the program run slower.
X.PP
XAs with
X.IR ps (1),
Xthings can change while
X.I top
Xis collecting information for an update.  The picture it gives is only a
Xclose approximation to reality.
X.SH "SEE ALSO"
Xkill(1),
Xps(1),
Xstty(1),
Xmem(4),
Xrenice(8)
END_OF_FILE
if test 9945 -ne `wc -c <'top.X'`; then
    echo shar: \"'top.X'\" unpacked with wrong size!
fi
# end of 'top.X'
fi
echo shar: End of archive 3 \(of 16\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 16 archives.
    echo "Now read README and INSTALL, then run Configure"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
