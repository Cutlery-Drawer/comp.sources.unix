Newsgroups: comp.sources.unix
From: kinch@julian.uwo.ca (Dave Kinchlea)
Subject: v29i052: libpass - pro-active password checker library, Part01/01
Message-id: <1.817522150.24012@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: kinch@julian.uwo.ca (Dave Kinchlea)
Posting-Number: Volume 29, Issue 52
Archive-Name: libpass/part01

The code was taken from passwd-suite found in:
ftp://ftp.uwo.ca/pub/unix/security/passwd-suite and modified so that the
global variables in use where wrapped around a struct
crack_config. However, I did not want to re-write Reg's code much at all so
I also supplied the necessary defines so that it still appears that global
variables are in use. See passwd.h for more info.

The interface to this library consists of the following:

        int configure(char *configfile, char *loginID);
        int crack(char *password, char *gecos, int noisy);
        char * libpass_errors(int errno);

See man libpass for more info.

#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	README
#	Makefile
#	libpass.h
#	passwd-config.c
#	passwd-crack.c
#	passwd-match.c
#	passwd-return.c
#	passwd.rc
#	passwd-return.h
#	passwd.h
#	libpass.man
#	libpass.exp
#	so_locations
# This archive created: Mon Nov 27 15:24:19 1995
export PATH; PATH=/bin:$PATH
echo shar: extracting "'README'" '(1611 characters)'
if test -f 'README'
then
	echo shar: will not over-write existing file "'README'"
else
sed 's/^	X//' << \SHAR_EOF > 'README'
	X$Author: kinch $
	X$Date: 1995/11/27 20:10:16 $
	X$Id: README,v 1.2 1995/11/27 20:10:16 kinch Exp $
	X
	XThis is the directory for the library, libpass. This implements Reg
	XQuinton's excellent work in a pro-active password checker into a
	X(shared, where possible) library so that other programs requiring
	Xpasswords can take advantage of that work.
	X
	XThe code was taken from passwd-suite found in:
	Xftp://ftp.uwo.ca/pub/unix/security/passwd-suite and modified so that the global
	Xvariables in use where wrapped around a struct crack_config. However,
	XI did not want to re-write Reg's code much at all so I also supplied
	Xthe necessary defines so that it still appears that global variables
	Xare in use. See passwd.h for more info.
	X
	XThe interface to this library consists of the following:
	X
	X	int configure(char *configfile, char *loginID);
	X	int crack(char *password, char *gecos, int noisy);
	X	char * libpass_errors(int errno);
	X
	XSee man libpass for more info.
	X
	X
	XDirectories:
	XRCS     - you know what thats for
	X
	XFiles:
	XREADME           - This file
	XMakefile         - for building libpass on different platforms
	Xpasswd-crack.c   - This is the cracking engine
	Xpasswd-config.c  - This is the configuration routines for crack to use
	Xpasswd-match.c   -  recognize strings that are unacceptable for passwords
	Xpasswd-return.c  - Small routine (libpass_errmess()) to return error
	X		   string generated by crack()
	Xpasswd-return.h  - Integer return code definitions from crack()
	Xpasswd.h         - Some defines necessary for smooth migration of code
	Xpasswd.rc	 - This comes from passwd-suite with all the server
	X		   specific stuff removed.
SHAR_EOF
if test 1611 -ne "`wc -c < 'README'`"
then
	echo shar: error transmitting "'README'" '(should have been 1611 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'Makefile'" '(5413 characters)'
if test -f 'Makefile'
then
	echo shar: will not over-write existing file "'Makefile'"
else
sed 's/^	X//' << \SHAR_EOF > 'Makefile'
	X# Makefile for libpasswd
	X#
	X# $Author: kinch $
	X# $Id: Makefile,v 1.14 1995/11/27 18:14:14 kinch Exp kinch $
	X# $Source: /usr/src/usr.local/security/libpasswd/RCS/Makefile,v $
	X# $Locker: kinch $
	X#
	X# Build and install things in the right places.
	X#
	X# Original work August 1994 by Dave Kinchlea <kinch@julian.uwo.ca>
	X#
	X#  Copyright (c) 1994 The University of Western Ontario.  All rights
	X#  reserved.  Redistribution is permitted provided that this notice is
	X#  preserved and that due credit is given to the authors as well as The
	X#  University of Western Ontario.
	X#
	X#  Start of Configuration Section
	X
	XSHELL=  	/bin/sh
	XENVIRONMENT=	SYSV
	XOLD=		/uwo/ccs/old
	XBIN=		/uwo/ccs/lib
	XPROG=		$(LIB)
	XMANEXT=		3
	XMAN=		/uwo/ccs/man/man${MANEXT}
	XDIRS=		$(MAN) $(BIN)
	XHDRS= passwd.h passwd-return.h
	XOBJS= passwd-config.o passwd-crack.o passwd-match.o passwd-return.o
	XSRCS= passwd-config.c passwd-crack.c 	passwd-match.c passwd-return.c
	X
	X# This assumes a BSD version of install, use 'make INSTALL=... install' to
	X# use your version of BSD install. If you don't know how to do that you
	XINSTALL= /uwo/ccs/share/bin/ucbinstall
	XOWNER= kinch
	XGROUP= guru
	XGET=		co
	X
	X# When testing I often do 'make FUNCTION= OPTIMIZE=-g' to skip my 
	X# setuid code and build something I can trace with dbx
	X
	XFUNCTION= 	-DSETUID
	XOPTIMIZE=	-O ${FUNCTION}
	Xdebug=		0
	X# End of Global Configuration section.
	X
	Xall:	
	X	@echo "You must pick a platform, there is NO default"
	X	@echo "Choose from: $(SYSTEMS)"
	X	@echo "Or create your own!"
	X
	X# To get things out of RCS
	X
	X$(SRCS):;	$(GET) $@
	X
	X.c.o:
	X	$(CC) $(CFLAGS) $(OPTIMIZE) -Ddebug=$(debug) -c $*.c -D$(ENVIRONMENT)
	X# Make the image(s)
	X
	X# special target for AIX who must do this in two steps
	Xarchive: $(LIB)
	X	rm -f libpass.a
	X	rm -f $(LIB).`uname -m`
	X	ar rv libpass.a $(LIB)
	X	cp libpass.a libpass.a.`uname -m`
	X
	X$(LIB): $(OBJS) Makefile
	X	$(LIB_BUILD) $(LIB_BUILD_OPT) $(LIB) $(OBJS) $(LIBS)
	X	cp $(LIB) $(LIB).`uname -m`
	X	
	X# Make some directories
	X
	X$(DIRS):
	X	umask 022; mkdir -p $@
	X
	X# Install things in the right places: 
	X# Because of the myriad of systems this runs on, and the differing
	X# ways that shared libraries are dealt with, this install will not
	X# work `out of the box' -- use the install targets below.
	X#
	X#         the program, setuid (remove setuid bit on old executable)
	X#         the passwd database, readable only by root
	X#         the man page
	X# this assumes a ucb compatible install
	X
	Xinstall: $(DIRS) $(SRCS) 
	X	cp $(LIB).`uname -m` $(LIB)
	X	-mv -f $(BIN)/$(LIB) $(OLD)
	X	$(INSTALL) -c -m 444 -o $(OWNER) -g $(GROUP) $(LIB) $(BIN)
	X	-mv -f $(MAN)/$(PROG).$(MANEXT) $(OLD)
	X	$(INSTALL) -c -m 444  -o $(OWNER) -g $(GROUP) $(PROG).man $(MAN)/$(PROG).$(MANEXT)
	X
	X# And clean up after yourself. Assume *~ are emacs backup files and
	X#     #*# files are emacs automatic backups.
	X
	Xclean:
	X	rm -f *.o *.a *.so.1
	X
	Xreallyclean:
	X	rm -f *.o *.c *.h  TAGS  $(PROG) $(CONFIG) $(CONFIG).in
	X
	X
	Xsunos.install:;	make LIB="libpass.a" install
	Xsolaris.install:;	make LIB="libpass.so.1" install
	Xepix.install:;	make LIB="libpass.a" install
	Xirix.install:;	make LIB="libpass.so.1" install
	Xaix.install:;	make LIB="libpass.a" install
	X
	X# The following are supported enviornments
	XSYSTEMS=	sunos, solaris, aix, irix, epix
	X# This seems to work:
	X# [2:05pm suncon] uname -a
	X# SunOS suncon.cc 4.1.3_U1 1 sun4c
	X# [2:05pm suncon] date
	X# Thu Sep 22 14:05:45 EDT 1994
	X
	Xsunos:
	X	make ENVIRONMENT=BSD \
	X	     CC=gcc \
	X	     CFLAGS="-O -Wall" \
	X	     OPTIMIZE="$(OPTIMIZE)" debug=$(debug) \
	X	     LIB="libpass.a"\
	X	     LIB_BUILD="/usr/5bin/ar" \
	X	     LIB_BUILD_OPT="r" \
	X	     LDFLAGS="-static" \
	X	     libpass.a
	X
	X# This seems to work:
	X# [2:21pm falcon] uname -a
	X# SunOS falcon.ccs.uwo.ca 5.3 Generic_Patch sun4m sparc
	X# [2:21pm falcon] date
	X# Thu Sep 22 14:21:53 EDT 1994
	X
	Xsolaris:
	X	make LIB_BUILD=ld \
	X	     LIB_BUILD_OPT="-G -o" \
	X	     LIB=libpass.so.1 \
	X	     CC=gcc \
	X	     CFLAGS="-Wall -O" \
	X	     OPTIMIZE="$(OPTIMIZE)" debug=$(debug) \
	X	     libpass.so.1
	X
	X# This one works now:
	X# [1:54pm julian] uname -a 
	X# julian.uwo.ca julian.uwo.ca 1.4.3 UMIPS mips
	X# [1:54pm julian] date 
	X# Mon Oct  3 13:54:37 EDT 1994
	X#
	X# NOTE: There is still a problem with ICANNON being
	X# mistakenly on with the EPIX environment, but 
	X# this works acceptably well for now.
	X
	Xepix:
	X	make ENVIRONMENT=BSD \
	X	     CC=gcc \
	X	     CFLAGS="-O -Wall" \
	X	     OPTIMIZE="$(OPTIMIZE)" debug=$(debug) \
	X	     LIB="libpass.a"\
	X	     LIB_BUILD="ar" \
	X	     LIB_BUILD_OPT="rs" \
	X	     libpass.a
	X#
	X#  This seems to work:
	X# [12:11pm xia] uname -a
	X# AIX xia 2 3 000065074100
	X# [12:11pm xia] date
	X# Tue Oct  4 12:12:01 EDT 1994
	X
	Xaix:
	X	make ENVIRONMENT=BSD \
	X	     CC=xlc langlvl=extended \
	X	     CFLAGS="${CFLAGS} -DNO_PWD_QUOTA \
	X		     -D__aix__ -D_ALL_SOURCE \
	X		     -DNO_FGETPWENT" \
	X	     OPTIMIZE="$(OPTIMIZE)" debug=$(debug) \
	X	     LIB=libpass.o \
	X	     LIB_BUILD="ld" \
	X	     LIB_BUILD_OPT="-bE:libpass.exp -bM:SRE -T512 -H512 -lc -o" \
	X	     LIBS="-lbsd" \
	X	     archive
	Xirix:
	X	make ENVIRONMENT=SYSV \
	X	     CC=cc \
	X	     CFLAGS="-xansi ${CFLAGS}" \
	X	     OPTIMIZE="$(OPTIMIZE)" debug=$(debug) \
	X	     LIB="libpass.so.1" \
	X	     LIB_BUILD=ld \
	X	     LIB_BUILD_OPT="-elf -shared -no_unresolved -o " \
	X	     LIBS=-lc \
	X	     libpass.so.1
	X
	Xjulian:	solaris
	Xmango:	irix
	Xxia:	aix
	Xpanther: epix
	Xsuncon:	sunos
	X
	X# DO NOT DELETE THIS LINE -- make depend depends on it.
	Xpasswd-config.o:	passwd-config.c passwd.h
	Xpasswd-match.o:		passwd-match.c passwd.h
	Xpasswd-crack.o:		passwd-crack.c passwd.h
SHAR_EOF
if test 5413 -ne "`wc -c < 'Makefile'`"
then
	echo shar: error transmitting "'Makefile'" '(should have been 5413 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'libpass.h'" '(327 characters)'
if test -f 'libpass.h'
then
	echo shar: will not over-write existing file "'libpass.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'libpass.h'
	X/* 
	X	This is the header file for libpass:
	X
	X $Author: kinch $
	X $Date: 1995/11/27 18:30:51 $
	X $Id: libpass.h,v 1.2 1995/11/27 18:30:51 kinch Exp $
	X $Source: /usr/src/usr.local/security/libpasswd/RCS/libpass.h,v $
	X $Locker:  $
	X
	X
	X*/
	Xint configure(char *);
	Xint crack(char *, char *, char *, int);
	Xconst char * libpass_errors(int);
	X
SHAR_EOF
if test 327 -ne "`wc -c < 'libpass.h'`"
then
	echo shar: error transmitting "'libpass.h'" '(should have been 327 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'passwd-config.c'" '(8481 characters)'
if test -f 'passwd-config.c'
then
	echo shar: will not over-write existing file "'passwd-config.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'passwd-config.c'
	X/*
	X * $Author: kinch $
	X * $Date: 1995/10/24 14:38:21 $
	X * $Id: passwd-config.c,v 1.5 1995/10/24 14:38:21 kinch Exp $
	X * $Source: /usr/src/usr.local/security/libpasswd/RCS/passwd-config.c,v $
	X *
	X * Read a configuration file and load some variables to configure things.
	X * 
	X * Original work 9-Sep-94 by Reg Quinton <reggers@julian.uwo.ca>
	X*/
	X
	Xstatic  char    
	X*rcsid="$Id: passwd-config.c,v 1.5 1995/10/24 14:38:21 kinch Exp $";
	X
	X#include	<stdio.h>
	X#include        <stdlib.h>
	X#include	<syslog.h>
	X#include	<string.h>
	X#include	<ctype.h>
	X#include        "passwd.h"
	X
	X/* This will be exported to the world */
	Xstruct crack_config crack_config, *Crack_Config=&crack_config;
	X
	Xint
	Xinitialize_crack(struct crack_config *Crack_Config)
	X{
	X
	X  /* This were initially global declarations, now this routine populates
	X     Crack_Config with default values.
	X     */
	X  
	X  /* there are certain characters that are problematic in any password */
	X  
	X#ifndef BADCHARS
	X#define BADCHARS        "@#"
	X#endif
	X  
	X  if (sizeof(BADCHARS) < BUFSIZE) {
	X    strcpy(badchars,BADCHARS);
	X  } else {
	X    return(EITSTOOBIG);
	X  }
	X  
	X  
	X  /* the dictionary I use to crack passwords, you might use a better one */
	X  
	X#ifdef	DEBUG
	X#define	DICT		"./words"
	X#endif
	X  
	X#ifndef DICT
	X#define DICT            "/usr/dict/words"
	X#endif
	X  
	X  if (sizeof(DICT) < BUFSIZE) {
	X    strcpy(dict,DICT);		/* can set from command line */
	X  } else {
	X    return(EITSTOOBIG);
	X  }
	X  
	X  /* how much do I require words to differ from one another (counting
	X     additions, deletions, or changed letters but not counting case
	X     changes or reversed word). Default is 2 but this change be changed
	X     on command line */
	X  
	X#ifndef MINDIFF
	X#define MINDIFF         2
	X#endif
	X  
	X  mindiff=MINDIFF;		/* can set from command line */
	X  
	X  /* how many different characters to I require? */
	X  
	X#ifndef MINUNIQ
	X#define MINUNIQ        4
	X#endif
	X  
	X  minuniq=MINUNIQ;		/* can set from command line */
	X
	X/* what is the minimum password length? Default is 4 but this change
	X   be changed on command line, 4 is far too short. */
	X
	X#ifndef MINLEN
	X#define MINLEN          4
	X#endif
	X
	X  minlen=MINLEN;
	X
	X/* maximum password length that counts is the first 8 characters.
	X   You really don't want to change this. */
	X
	X#ifndef MAXLEN
	X#define MAXLEN          8
	X#endif
	X
	X  maxlen=MAXLEN;
	X
	X  /* maximum/minimum number of alpha, too many makes it very easy to crack */
	X
	X#ifndef	MINALPHA
	X#define	MINALPHA	0
	X#endif
	X#ifndef	MAXALPHA
	X#define	MAXALPHA	6
	X#endif
	X
	X  minalpha=MINALPHA;
	X  maxalpha=MAXALPHA;
	X  
	X  /* maximum/minimum number of upper, too many makes it very easy to crack */
	X  
	X#ifndef	MINUPPER
	X#define	MINUPPER	0
	X#endif
	X#ifndef	MAXUPPER
	X#define	MAXUPPER	6
	X#endif
	X
	X  minupper=MINUPPER;
	X  maxupper=MAXUPPER;
	X  
	X  /* maximum/minimum number of lower, too many makes it very easy to crack */
	X
	X#ifndef	MINLOWER
	X#define	MINLOWER	0
	X#endif
	X#ifndef	MAXLOWER
	X#define	MAXLOWER	6
	X#endif
	X
	X  minlower=MINLOWER;
	X  maxlower=MAXLOWER;
	X  
	X  /* maximum/minimum number of punct, too many makes it very easy to crack */
	X
	X#ifndef	MINPUNCT
	X#define	MINPUNCT	0
	X#endif
	X#ifndef	MAXPUNCT
	X#define	MAXPUNCT	6
	X#endif
	X
	X  minpunct=MINPUNCT;
	X  maxpunct=MAXPUNCT;
	X
	X  /* maximum/minimum number of digits, too many makes it very easy to crack */
	X
	X#ifndef	MINDIGIT
	X#define	MINDIGIT	0
	X#endif
	X#ifndef	MAXDIGIT
	X#define	MAXDIGIT	3
	X#endif
	X
	X  mindigit=MINDIGIT;
	X  maxdigit=MAXDIGIT;
	X
	X  /* maximum/minimum number of others, too many makes it very easy to crack */
	X
	X#ifndef	MINOTHER
	X#define	MINOTHER	0
	X#endif
	X#ifndef	MAXOTHER
	X#define	MAXOTHER	6
	X#endif
	X
	X  minother=MINOTHER;
	X  maxother=MAXOTHER;
	X
	X  return(SUCCESS);
	X}
	X
	X/* what is my private key for cryptography? */
	X
	Xchar	cryptkey[BUFSIZ]="";		/* only configurable from here */
	X
	X/* what are the patterns I don't like to see in a password? */
	X
	Xchar	*patterns[BUFSIZ]={ NULL };	/* only configurable from here */
	Xstatic	int	patterni=0;		/* index into array */
	X
	Xint 
	Xconfigure(char *passwdrc, char *logid)
	X{
	X	FILE	*f;
	X	char	buf[BUFSIZ];		/* single line from config file */
	X	char	command[BUFSIZ];	/* command part of line */
	X	char	arg[BUFSIZ];		/* argument part of line */
	X	char	*t;			/* a temporary */
	X	extern char * mybadpattern(char *);
	X
	X	if ((f=fopen(passwdrc,"r")) == NULL)
	X	{
	X#ifndef	DEBUG
	X		syslog(LOG_ERR,"cannot open %s",passwdrc);
	X#endif
	X		return(errno);
	X	}
	X	badpattern = mybadpattern;
	X
	X	while (fgets(buf,BUFSIZ,f))
	X	{
	X		if (strchr("\n#",buf[0])) continue;
	X
	X		sscanf(buf,"%[^ \t]%*[ \t]%[^\n]", command, arg);
	X
	X		if (strcasecmp(command,"dict")		== 0)
	X		{	strcpy(dict, arg);
	X			continue;
	X		}
	X
	X		if (strcasecmp(command,"badchars")	== 0)
	X		{	strcpy(badchars, arg);
	X			continue;
	X		}
	X
	X		if (strcasecmp(command,"mindiff")	== 0)
	X		{	sscanf(arg,"%d",&mindiff);
	X			continue;
	X		}
	X
	X		if (strcasecmp(command,"minuniq")	== 0)
	X		{	sscanf(arg,"%d",&minuniq);
	X			continue;
	X		}
	X
	X		if (strcasecmp(command,"minlen")	== 0)
	X		{	sscanf(arg,"%d",&minlen);
	X			continue;
	X		}
	X
	X		if (strcasecmp(command,"maxlen")	== 0)
	X		{	sscanf(arg,"%d",&maxlen);
	X			continue;
	X		}
	X
	X		if (strcasecmp(command,"minalpha")	== 0)
	X		{	sscanf(arg,"%d",&minalpha);
	X			continue;
	X		}
	X
	X		if (strcasecmp(command,"maxalpha")	== 0)
	X		{	sscanf(arg,"%d",&maxalpha);
	X			continue;
	X		}
	X
	X		if (strcasecmp(command,"minupper")	== 0)
	X		{	sscanf(arg,"%d",&minupper);
	X			continue;
	X		}
	X
	X		if (strcasecmp(command,"maxupper")	== 0)
	X		{	sscanf(arg,"%d",&maxupper);
	X			continue;
	X		}
	X
	X		if (strcasecmp(command,"minupper")	== 0)
	X		{	sscanf(arg,"%d",&minupper);
	X			continue;
	X		}
	X
	X		if (strcasecmp(command,"maxupper")	== 0)
	X		{	sscanf(arg,"%d",&maxupper);
	X			continue;
	X		}
	X
	X		if (strcasecmp(command,"minlower")	== 0)
	X		{	sscanf(arg,"%d",&minlower);
	X			continue;
	X		}
	X
	X		if (strcasecmp(command,"maxlower")	== 0)
	X		{	sscanf(arg,"%d",&maxlower);
	X			continue;
	X		}
	X
	X		if (strcasecmp(command,"minpunct")	== 0)
	X		{	sscanf(arg,"%d",&minpunct);
	X			continue;
	X		}
	X
	X		if (strcasecmp(command,"maxpunct")	== 0)
	X		{	sscanf(arg,"%d",&maxpunct);
	X			continue;
	X		}
	X
	X		if (strcasecmp(command,"mindigit")	== 0)
	X		{	sscanf(arg,"%d",&mindigit);
	X			continue;
	X		}
	X
	X		if (strcasecmp(command,"maxdigit")	== 0)
	X		{	sscanf(arg,"%d",&maxdigit);
	X			continue;
	X		}
	X
	X		if (strcasecmp(command,"minother")	== 0)
	X		{	sscanf(arg,"%d",&minother);
	X			continue;
	X		}
	X
	X		if (strcasecmp(command,"maxother")	== 0)
	X		{	sscanf(arg,"%d",&maxother);
	X			continue;
	X		}
	X
	X		if (strcasecmp(command,"key")		== 0)
	X		{	strcpy(cryptkey, arg);
	X			continue;
	X		}
	X
	X		if (strcasecmp(command,"pattern")	== 0)
	X		{	
	X        		if ((t=(char*)malloc(strlen(arg)+1)))
	X				 patterns[patterni++]=strcpy(t,arg);
	X			continue;
	X		}
	X
	X		
	X#ifndef	DEBUG
	X		syslog(LOG_ERR,"Config error: %s", buf);
	X#endif
	X		return(EITSNOTFOUND);
	X	}
	X
	X	fclose(f);	
	X	return(SUCCESS);
	X}
	X
	X/* to display a string in ^C format (so things are readable) */
	X
	Xstatic
	Xchar	*toread(s)
	Xchar	*s;
	X{
	Xstatic	char	tmp[BUFSIZ];
	X	int	i;
	X
	X	for (i=0; *s; s++) {
	X		if (iscntrl(*s)) {
	X			tmp[i++]= '^';
	X			tmp[i++]= (*s ^ '@');
	X		}
	X		else	tmp[i++]= *s;
	X	}
	X	tmp[i]='\0';
	X	return(tmp);
	X}
	X
	Xvoid policy()
	X{
	X	int	i;
	X
	X	fprintf(stdout,"200-Password policy as follows:\r\n");
	X/* 	fprintf(stdout,"200- Service daemon:         \"%s\"\r\n",service); */
	X/* 	fprintf(stdout,"200- Password file:          \"%s\"\r\n",passwd); */
	X/* 	fprintf(stdout,"200- Password lock file:     \"%s\"\r\n",ptmp); */
	X/* 	fprintf(stdout,"200- Password file mode:      0%0o\r\n",mode); */
	X	fprintf(stdout,"200- Dictionary file:        \"%s\"\r\n",dict);
	X	fprintf(stdout,"200- Badchars (not allowed): \"%s\"\r\n",toread(badchars));
	X/* 	fprintf(stdout,"200- Sysuid   (accounts <=):  %d\r\n",sysuid);  */
	X	fprintf(stdout,"200- Mindiff  (from words):   %d\r\n",mindiff);
	X	fprintf(stdout,"200- Minuniq  (unique):       %d\r\n",minuniq);
	X	fprintf(stdout,"200- Limits:                  %d <= length <= %d\r\n", minlen,maxlen);
	X	fprintf(stdout,"200- Limits:                  %d <= alphas <= %d\r\n", minalpha,maxalpha);
	X	fprintf(stdout,"200- Limits:                  %d <= uppers <= %d\r\n", minupper,maxupper);
	X	fprintf(stdout,"200- Limits:                  %d <= lowers <= %d\r\n", minlower,maxlower);
	X	fprintf(stdout,"200- Limits:                  %d <= puncts <= %d\r\n", minpunct,maxpunct);
	X	fprintf(stdout,"200- Limits:                  %d <= others <= %d\r\n", minother,maxother);
	X/*	fprintf(stdout,"200- Change Shell:            %s\r\n",
	X				dochsh ? "true" : "false"); */
	X/* 	fprintf(stdout,"200- Change Full Name:        %s\r\n",
	X				dochfn ? "true" : "false"); */
	X	for (i=0; patterns[i]; i++)
	X	fprintf(stdout,"200- Unacceptable pattern:    %s\r\n",patterns[i]);
	X	fprintf(stdout,"200 Policy Done\r\n");
	X}
SHAR_EOF
if test 8481 -ne "`wc -c < 'passwd-config.c'`"
then
	echo shar: error transmitting "'passwd-config.c'" '(should have been 8481 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'passwd-crack.c'" '(10280 characters)'
if test -f 'passwd-crack.c'
then
	echo shar: will not over-write existing file "'passwd-crack.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'passwd-crack.c'
	X/*
	X $Author: kinch $
	X $Date: 1995/11/27 17:58:14 $
	X $Id: passwd-crack.c,v 1.4 1995/11/27 17:58:14 kinch Exp $
	X $Source: /usr/src/usr.local/security/libpasswd/RCS/passwd-crack.c,v $
	X $Locker:  $
	X
	X Is a word crackable? Would it not suffice as a password. Several
	X fancy dancy checks to make sure that users don't set dumb passwords.
	X
	X Original work 9-Sep-92 by Reg Quinton <reggers@julian.uwo.ca>
	X Big changes   8-Sep-94 by Reg Quinton <reggers@julian.uwo.ca> to
	X                        assure even better passwords.
	X Changed into a library routine 95/07/11 by Dave Kinchlea <kinch@julian.uwo.ca>
	X                        for inclusion into other code (regiserv).
	X*/
	X
	Xstatic	char	
	X*rcsid="$Id: passwd-crack.c,v 1.4 1995/11/27 17:58:14 kinch Exp $";
	X
	X#include	<stdio.h>
	X#include	<string.h>
	X#include	<ctype.h>
	X#include	<syslog.h>
	X#include        "passwd.h"
	X#include        "passwd-return.h"
	X
	X/* These declarations MUST be at file scope . */
	Xextern struct crack_config *Crack_Config;
	X
	X
	X/* to display a string in ^C format (so things are readable) */
	X
	Xstatic
	Xchar    *toread(s)
	Xchar    *s;
	X{
	Xstatic  char    tmp[BUFSIZ];
	X        int     i;
	X
	X        for (i=0; *s; s++) {
	X                if (iscntrl(*s)) {
	X                        tmp[i++]= '^';
	X                        tmp[i++]= (*s ^ '@');
	X                }
	X                else    tmp[i++]= *s;
	X        }
	X        tmp[i]='\0';
	X        return(tmp);
	X}
	X
	X#define	rank(a)	(isupper(a) ? tolower(a) : a)
	X
	X/* two words, how much do they differ by (ignoring case)? I want to find
	X   the minimal difference but I'm not too concerned about differences of
	X   more than two characters */
	X
	Xint	ndiff(guess,word)
	Xchar	*guess,*word;
	X{
	Xstatic	depth=0;	/* keep track of recursion depth */
	X	int	d1,d2,d3;
	X
	X	/* have we seen enough differences? */
	X
	X	if (depth > mindiff) return(0);
	X
	X	for (; *guess && *word; guess++, word++)
	X		if (rank(*guess) != rank(*word))
	X		{	depth++;
	X			d1=ndiff(guess+1,word);
	X			d2=ndiff(guess,word+1);
	X			d3=ndiff(guess+1,word+1);
	X			depth--;
	X			return(1 + ((d1= (d1 < d2 ? d1 : d2)) < d3 ? d1 : d3));
	X		}
	X
	X	/* I treat the prefix of a guess as a match */
	X
	X	return(strlen(word));
	X}
	X
	X/* is a password cracked by this guessed word? */
	X
	X#define	crackby(guess)	\
	X	((ndiff(guess,foreword) <= mindiff) || \
	X		(ndiff(guess,backword) <= mindiff))
	X
	X/* pull words one at a time -- note the string pointer is changed */
	X
	Xchar	*
	Xyankword(char **words)
	X{
	Xstatic	char	buf[BUFSIZ];
	Xchar    *c,*u;
	X
	X        /*      skip leading white      */
	X
	X        for (c= *words; *c && (strchr(" ,;\t",*c)); c++);
	X
	X        /*      store up to terminator  */
	X
	X        for (u= buf; *c && !(strchr(" ;,\t",*c)); *u++ = rank(*c), c++);
	X
	X        *u='\0';   *words=c;
	X 
	X        if (u == buf) return(NULL);
	X	return(buf);
	X}
	X
	X/* determine if a word is crackable, spit out an error diagnostic if it is */
	X
	Xint	crack(char *word, char *logid, char *gecos, int noisy)
	X{
	X	FILE	*fdict;
	X	int	i,fatal,len,uniqs,digits,alphas,
	X		lowers,uppers,others,puncts;
	X	char	buf[BUFSIZ], foreword[BUFSIZ],backword[BUFSIZ], *p, *guess;
	X
	X	strcpy(user,logid);
	X        len=strlen(word);
	X	fatal = uniqs = digits = alphas = 
	X		lowers = uppers = others = puncts = 0;
	X
	X	/* but passwords aren't arbitrarily long */
	X
	X	if (len > maxlen)
	X	{	word[maxlen]='\0';
	X		len=maxlen;
	X	}
	X
	X	/* scan word looking for bad characters that shouldn't be there,
	X	   counting character types and unique character counts */
	X
	X        for (p=word; *p; p++)
	X	{
	X		if (strchr(badchars, *p))
	X		{
	X#ifndef	DEBUG
	X			if (noisy)
	X                	syslog(LOG_ERR, "%s:%s bad chars in passwd",
	X				peer, user);
	X#endif
	X			if (noisy)
	X			printf("550 bad chars, none of \"%s\" allowed\r\n",
	X				 toread(badchars));
	X			fatal = LIBPASS_BADCHARS;
	X                }
	X
	X		if (!strchr(p+1,*p)) uniqs++;
	X
	X                if (isdigit(*p)) digits++;	
	X		else 
	X		if (ispunct(*p)) puncts++;
	X                else
	X		if (isalpha(*p))
	X		{	alphas++;
	X			if (islower(*p)) lowers++;
	X			else uppers++;
	X		}
	X                else    others++;
	X
	X        }
	X
	X	/* minimally long enough? */
	X
	X	if (len < minlen)
	X	{
	X#ifndef	DEBUG
	X		if (noisy)
	X                syslog(LOG_ERR, "%s:%s not enough chars in passwd",
	X			peer, user);
	X#endif
	X		if (noisy)
	X		printf("550 not enough chars (min %d)\r\n",
	X				minlen);
	X		fatal = LIBPASS_TOOSMALL;
	X        }
	X
	X	/* enough different characters? */
	X
	X	if (uniqs < minuniq)
	X	{
	X#ifndef	DEBUG
	X		if (noisy)
	X                syslog(LOG_ERR, "%s:%s not enough unique chars in passwd",
	X			peer, user);
	X#endif
	X		if (noisy)
	X		printf("550 not enough unique chars (min %d)\r\n",
	X				minuniq);
	X		fatal = LIBPASS_TOOFEW;
	X        }
	X
	X	/* enough alpha characters? */
	X
	X	if (alphas < minalpha)
	X	{
	X#ifndef	DEBUG
	X		if (noisy)
	X                syslog(LOG_ERR, "%s:%s not enough alphas in passwd",
	X			peer, user);
	X#endif
	X		if (noisy)
	X		printf("550 not enough alpha  chars (min %d)\r\n",
	X			minalpha);
	X		fatal = LIBPASS_MINALPH;
	X        }
	X	
	X	if (alphas > maxalpha)
	X	{
	X#ifndef	DEBUG
	X		if (noisy)
	X                syslog(LOG_ERR, "%s:%s too many alphas in passwd",
	X			peer, user);
	X#endif
	X		if (noisy)
	X		printf("550 too many alpha  chars (max %d)\r\n",
	X			maxalpha);
	X		fatal = LIBPASS_MAXALPH;
	X        }
	X	
	X	/* enough lower characters? */
	X
	X	if (lowers < minlower)
	X	{
	X#ifndef	DEBUG
	X		if (noisy)
	X                syslog(LOG_ERR, "%s:%s not enough lowers in passwd",
	X			peer, user);
	X#endif
	X		if (noisy)
	X		printf("550 not enough lower  chars (min %d)\r\n",
	X			minlower);
	X		fatal = LIBPASS_MINLOWER;
	X        }
	X	
	X	if (lowers > maxlower)
	X	{
	X#ifndef	DEBUG
	X		if (noisy)
	X                syslog(LOG_ERR, "%s:%s too many lowers in passwd",
	X			peer, user);
	X#endif
	X		if (noisy)
	X		printf("550 too many lower  chars (max %d)\r\n",
	X			maxlower);
	X		fatal = LIBPASS_MAXLOWER;
	X        }
	X
	X	/* enough upper characters? */
	X
	X	if (uppers < minupper)
	X	{
	X#ifndef	DEBUG
	X		if (noisy)
	X                syslog(LOG_ERR, "%s:%s not enough uppers in passwd",
	X			peer, user);
	X#endif
	X		if (noisy)
	X		printf("550 not enough upper  chars (min %d)\r\n",
	X			minupper);
	X		fatal = LIBPASS_MINUPPER;
	X        }
	X	
	X	if (uppers > maxupper)
	X	{
	X#ifndef	DEBUG
	X		if (noisy)
	X                syslog(LOG_ERR, "%s:%s too many uppers in passwd",
	X			peer, user);
	X#endif
	X		if (noisy)
	X		printf("550 too many upper  chars (max %d)\r\n",
	X			maxupper);
	X		fatal = LIBPASS_MAXUPPER;
	X        }
	X
	X	/* enough digit characters? */
	X
	X	if (digits < mindigit)
	X	{
	X#ifndef	DEBUG
	X		if (noisy)
	X                syslog(LOG_ERR, "%s:%s not enough digits in passwd",
	X			peer, user);
	X#endif
	X		if (noisy)
	X		printf("550 not enough digit  chars (min %d)\r\n",
	X			mindigit);
	X		fatal = LIBPASS_MINDIGIT;
	X        }
	X	
	X	if (digits > maxdigit)
	X	{
	X#ifndef	DEBUG
	X		if (noisy)
	X                syslog(LOG_ERR, "%s:%s too many digits in passwd",
	X			peer, user);
	X#endif
	X		if (noisy)
	X		printf("550 too many digit  chars (max %d)\r\n",
	X			maxdigit);
	X		fatal = LIBPASS_MAXDIGIT;
	X        }
	X
	X	/* enough punctuation characters? */
	X
	X	if (puncts < minpunct)
	X	{
	X#ifndef	DEBUG
	X		if (noisy)
	X                syslog(LOG_ERR, "%s:%s not enough puncts in passwd",
	X			peer, user);
	X#endif
	X		if (noisy)
	X		printf("550 not enough punct  chars (min %d)\r\n",
	X			minpunct);
	X		fatal = LIBPASS_MINPUNCT;
	X        }
	X	
	X	if (puncts > maxpunct)
	X	{
	X#ifndef	DEBUG
	X		if (noisy)
	X                syslog(LOG_ERR, "%s:%s too many puncts in passwd",
	X			peer, user);
	X#endif
	X		if (noisy)
	X		printf("550 too many punct  chars (max %d)\r\n",
	X			maxpunct);
	X		fatal = LIBPASS_MAXPUNCT;
	X        }
	X	
	X	/* enough other characters? */
	X
	X	if (others < minother)
	X	{
	X#ifndef	DEBUG
	X		if (noisy)
	X                syslog(LOG_ERR, "%s:%s not enough others in passwd",
	X			peer, user);
	X#endif
	X		if (noisy)
	X		printf("550 not enough other  chars (min %d)\r\n",
	X			minother);
	X		fatal = LIBPASS_MINOTHER;
	X        }
	X	
	X	if (others > maxother)
	X	{
	X#ifndef	DEBUG
	X		if (noisy)
	X                syslog(LOG_ERR, "%s:%s too many others in passwd",
	X			peer, user);
	X#endif
	X		if (noisy)
	X		printf("550 too many other  chars (max %d)\r\n",
	X			maxother);
	X		fatal = LIBPASS_MAXOTHER;
	X        }
	X
	X	/* we'll need this in a bit, reverse the word and lowercase */
	X
	X	for (p=backword, i=len;	i > 0; i--, (*p++)=rank(word[i])); *p='\0';
	X	for (p=foreword, i=0; i < len; (*p++)=rank(word[i]), i++); *p='\0';
	X
	X	/* is this a bad pattern? Like a licence plate? */
	X
	X	if ((p=badpattern(foreword)) ||
	X	    (p=badpattern(backword)))
	X	{
	X#ifndef	DEBUG
	X		if (noisy)
	X                syslog(LOG_ERR, "%s:%s bad pattern in passwd",
	X			peer, user);
	X#endif
	X		if (noisy)
	X		printf("550 bad pattern %s\r\n",p);
	X		fatal = LIBPASS_BADPATTERN;
	X        }
	X
	X	/* gotta not have a palindrome */
	X
	X	if (ndiff(backword,foreword) <= mindiff)
	X	{
	X#ifndef	DEBUG
	X		if (noisy)
	X                syslog(LOG_ERR,	"%s:%s passwd cracked by palindrome",
	X			peer, user);
	X#endif
	X		if (noisy)
	X		printf("550 cracked by palindrome (in less than %d moves)\r\n",
	X				mindiff);
	X		fatal = LIBPASS_PALINDROME;
	X	}
	X
	X	/* the user login name better not be in the password */
	X
	X	if (crackby(user))
	X	{
	X#ifndef	DEBUG
	X		if (noisy)
	X                syslog(LOG_ERR,	"%s:%s passwd cracked by login name",
	X			 peer, user);
	X#endif
	X		if (noisy)
	X		printf("550 cracked by \"%s\" (in less than %d moves)\r\n",
	X				user, mindiff);
	X		fatal = LIBPASS_CRACKED_L;
	X	}
	X
	X	/* I dig out gecos words and check them too. */
	X
	X	for (; ((guess=yankword(&gecos)) != NULL);)
	X		if (crackby(guess))
	X		{
	X#ifndef	DEBUG
	X			if (noisy)
	X        	        syslog(LOG_ERR, "%s:%s passwd cracked by gecos",
	X				peer, user);
	X#endif
	X			if (noisy)
	X			printf("550 cracked by \"%s\" (in less than %d moves)\r\n",
	X					guess, mindiff);
	X			fatal = LIBPASS_CRACKED_G;
	X		}
	X
	X	/* is the word (or reverse) a minor variation of a dictionary word? */
	X
	X	if (((fdict=fopen(dict,"r")) == NULL))
	X	{
	X#ifndef DEBUG
	X			if (noisy)
	X        	        syslog(LOG_ERR,	"%s:%s cannot read dictionary %s",
	X				peer, user, dict);
	X#endif
	X		goto done;
	X	}
	X
	X	/* we have a dictionary, walk through them */
	X
	X	while (fgets(buf,BUFSIZ,fdict) != NULL)
	X	{
	X		if ((p=strchr(buf,'\n')) != NULL) *p='\0';
	X
	X		if (crackby(buf))
	X		{
	X#ifndef	DEBUG
	X			if (noisy)
	X        	        syslog(LOG_ERR,	"%s:%s passwd cracked by dictionary",
	X				peer, user);
	X#endif
	X			if (noisy)
	X			printf("550 cracked by \"%s\" (in less than %d moves)\r\n",
	X				buf,mindiff);
	X			fatal = LIBPASS_CRACKED_D;
	X		}
	X	}
	X
	X	fclose(fdict);
	X
	Xdone:
	X	if (fatal && noisy)
	X		printf("550 Fatal errors, password not acceptable\r\n");
	X
	X 	return(fatal);
	X}
	X
SHAR_EOF
if test 10280 -ne "`wc -c < 'passwd-crack.c'`"
then
	echo shar: error transmitting "'passwd-crack.c'" '(should have been 10280 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'passwd-match.c'" '(2363 characters)'
if test -f 'passwd-match.c'
then
	echo shar: will not over-write existing file "'passwd-match.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'passwd-match.c'
	X/*
	X * $Author: kinch $
	X * $Date: 1995/07/12 02:08:22 $
	X * $Id: passwd-match.c,v 1.3 1995/07/12 02:08:22 kinch Exp $
	X * $Source: /usr/src/usr.local/security/libpasswd/RCS/passwd-match.c,v $
	X *
	X * recognize strings that are unacceptable for passwords based on
	X * character types. Eg. if 'a' means alpha, 'd' means digit, 'o'
	X * means other, '.' means any character and '*' means any character
	X * string then disallow
	X *        
	X *                aaa.ddd         looks like a licence plate
	X *                ddd.aaa         looks like a licence plate
	X *                adadad          looks like a postal code
	X * etc.
	X *
	X * Original work 16-Sep-94 by Reg Quinton <reggers@julian.uwo.ca>
	X*/
	X
	Xstatic  char    
	X*rcsid="$Id: passwd-match.c,v 1.3 1995/07/12 02:08:22 kinch Exp $";
	X
	X#include        <stdio.h>
	X#include        <string.h>
	X#include        <ctype.h>
	X
	Xextern	char	*patterns[BUFSIZ];	/* an array of patterns I don't like */
	X
	Xstatic
	Xint	match(password,pattern)
	Xchar	*password;
	Xchar	*pattern;
	X{
	X
	X	for (; *pattern && *password; password++,pattern++)
	X		switch (*pattern)
	X		{
	X		case	'.':		/* any single char */
	X			break;
	X
	X		case	'*':		/* any character string */
	X			if (!(*(++pattern))) return(1);
	X			for (; *password; password++)
	X				if (match(password,pattern)) return(1);
	X			return(0);
	X
	X		case	'a':
	X		case	'A':		/* any alpha */
	X			if (!isalpha(*password)) return(0);
	X			break;
	X
	X		case	'u':
	X		case	'U':		/* any upper */
	X			if (!isupper(*password)) return(0);
	X			break;
	X
	X		case	'l':
	X		case	'L':		/* any lower */
	X			if (!islower(*password)) return(0);
	X			break;
	X
	X		case	'd':
	X		case	'D':		/* any digit */
	X			if (!isdigit(*password)) return(0);
	X			break;
	X
	X		case	'p':
	X		case	'P':		/* any punctuation */
	X			if (!ispunct(*password)) return(0);
	X			break;
	X
	X		case	'o':
	X		case	'O':		/* any non alpha non digit non punct */
	X			if (isalpha(*password) || isdigit(*password) ||
	X				ispunct(*password)) return(0);
	X			break;
	X
	X		default:		/* uh.. any character match I guess */
	X			if (*pattern != *password) return(0);
	X			break;
	X
	X		}
	X
	X	return((*pattern == *password) || (strcmp(pattern,"*") == 0));
	X}
	X
	X/* is this password formed with a bad pattern? */
	X
	Xchar	*mybadpattern(char * password)
	X{
	Xchar	pattern[BUFSIZ];
	X	int	i;
	X
	X	for (i=0; patterns[i] != NULL; i++) {
	X		sscanf(patterns[i],"%[^ \t]",pattern);
	X		if (match(password,pattern)) return(patterns[i]);
	X	}
	X	return((char *)NULL);
	X}
SHAR_EOF
if test 2363 -ne "`wc -c < 'passwd-match.c'`"
then
	echo shar: error transmitting "'passwd-match.c'" '(should have been 2363 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'passwd-return.c'" '(1248 characters)'
if test -f 'passwd-return.c'
then
	echo shar: will not over-write existing file "'passwd-return.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'passwd-return.c'
	X#include <stdio.h>
	X#include "passwd-return.h"
	X
	X/* This is just a simple interface to get return code strings from the library. */
	X
	Xconst char *
	Xlibpass_errors(int errno)
	X{
	X
	X#define MAX_ERR_STR_LEN sizeof("Password Cracked using dictionary lookup")+1  
	X
	X  static const  char libpass_errmess[LIBPASS_MAXERRNO][MAX_ERR_STR_LEN]={
	X    {"Not Cracked"},
	X    {"Illegal Character(s) used"},
	X    {"Too Few Characters Used"},
	X    {"Too Few Unique Characters Used"},
	X    {"Too Few Alphas Used"},
	X    {"Too Many Alphas Used"},
	X    {"Too Few Lower-Case Alphas used"},
	X    {"Too Many Lower-Case Alphas used"},
	X    {"Too Few Upper-Case Alphas used"},
	X    {"Too Many Upper-Case Alphas used"},
	X    {"Too Few Digits used"},
	X    {"Too Many Digits used"},
	X    {"Too Few Punctuation Characters Used"},
	X    {"Too Many Punctuation Characters Used"},
	X    {"Too Few Other Characters Used"},
	X    {"Too Many Other Characters Used"},
	X    {"Bad Pattern Detected"},
	X    {"Palindrome (or close) detected"},
	X    {"Password Cracked using LoginID"},
	X    {"Password Cracked using GECOS"},
	X    {"Password Cracked using dictionary lookup"}
	X  };
	X  
	X  
	X  if ((LIBPASS_MAXERRNO <= errno) || (0 > errno)) {
	X    return("Unknown Error");
	X  } else {
	X    return(libpass_errmess[errno]);
	X  }
	X}
SHAR_EOF
if test 1248 -ne "`wc -c < 'passwd-return.c'`"
then
	echo shar: error transmitting "'passwd-return.c'" '(should have been 1248 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'passwd.rc'" '(3219 characters)'
if test -f 'passwd.rc'
then
	echo shar: will not over-write existing file "'passwd.rc'"
else
sed 's/^	X//' << \SHAR_EOF > 'passwd.rc'
	X# $Author: kinch $
	X# $Date: 1995/07/31 18:44:17 $
	X# $Id: passwd.rc,v 1.2 1995/07/31 18:44:17 kinch Exp $
	X# $Source: /ccs/export/src/student/cgi/regiserv/RCS/passwd.rc,v $
	X#
	X# A passwdd.rc that enforces what I believe to be a secure password
	X# policy.
	X#
	X# Configuration file for passwdd/server and passwd/client. Client only
	X# needs to find out where the server is. Server needs to be
	X# configurable. Values here override default compiled in values,
	X# and command line values override everything. This example merely
	X# enumerates the default values, but shows where you might change things.
	X#
	X# Install as /etc/passwdd.rc on clients and server. Clients need to
	X# know where the server is, but nothing more.
	X#
	X# Original work 9-Sep-94 by Reg Quinton <reggers@julian.uwo.ca>
	X#
	X# Syntax:
	X# 1. comments are lines beginning with '#'
	X# 2. blank lines ignored
	X# 3. configuration lines are "<variable><white space><value>"
	X#
	X# dictionary we crack against (default /usr/dict/words)
	X#
	Xdict		/dev/null
	X#
	X# characters not allowed (default "@#")
	X# have extended to include delete, ^U, and back space
	X#
	Xbadchars	@#
	X#
	X# difference required before crackable (default 2)
	X# I'm not doing a dictionary scan, but this still is important on
	X# gecos data and login name.
	X#
	Xmindiff		2
	X#
	X# minimum number of different chars (default 4)
	X# I want at least 5 unique characters
	Xminuniq         5
	X#
	X# shortest possible password (default 4)
	X# I want 8 characters, 6 is too short.
	Xminlen		8
	X#
	X#
	X# longest possible password (default 8.. that's very solid)
	X# I want no more than 8.
	Xmaxlen		8
	X#
	X# minimum/maximum number of alpha chars (default 6)
	X# I want at least one alpha
	Xminalpha        1
	Xmaxalpha        8
	X#
	X# minimum/maximum number of upper chars (default 6)
	X# I want at least one upper case
	Xminupper        1
	Xmaxupper        8
	X#
	X# minimum/maximum number of lower chars (default 6)
	X# I want at least one lower
	Xminlower        1
	Xmaxlower        8
	X#
	X# minimum/maximum number of punct chars (default 6)
	X# I want at least one punctuation char
	Xminpunct        1
	Xmaxpunct        8
	X#
	X# minimum/maximum number of digit chars (default 6)
	X# I want at least one digit
	Xmindigit        1
	Xmaxdigit        8
	X#
	X# minimum/maximum number of other chars (default 6)
	X#
	Xminother        0
	Xmaxother        8
	X#
	X# If a client wants to do encrypted passwords then this is what
	X# we encrypt by. Don't use this word, use something else.
	X# This file should be protected accordingly (say 640) and passwd(1)
	X# installed setgid() so it can read the private key.
	X#
	Xkey		PrivateKey
	X#
	X# define patterns that are unacceptable for passwords based on
	X# character types. Eg. if 'a' means alpha, 'd' means digit, 'o'
	X# means other, '.' means any character and '*' means any character
	X# string then disallow
	X#        
	X#    aaa*ddd         looks like a licence plate
	X#    ada*dad         looks like a postal code
	X#    *ddd*           too long a digit sequence
	X#    *aaa*           too long an alpha sequence (getting near words)
	X#
	X#pattern[ \t]<pattern>[ \t]<descriptive reason>
	X#
	Xpattern *ddd* ... too long a digit sequence
	Xpattern *aaaa* ... too long an alpha sequence
	Xpattern *aaa*ddd* ... looks like a licence plate variation
	Xpattern *ada*dad* ... looks like a postal code variation
SHAR_EOF
echo shar: 3 control characters may be missing from "'passwd.rc'"
if test 3219 -ne "`wc -c < 'passwd.rc'`"
then
	echo shar: error transmitting "'passwd.rc'" '(should have been 3219 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'passwd-return.h'" '(1761 characters)'
if test -f 'passwd-return.h'
then
	echo shar: will not over-write existing file "'passwd-return.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'passwd-return.h'
	X/* 
	X	This is the list of return codes and their meanings
	Xfrom libpasswd.c. Provided are a list of error strings to go along
	Xwith it.
	X
	X*/
	X
	X/*  I suggest you cut these out and use them ... */
	X/*
	X#define MAX_ERR_STR_LEN sizeof("Password Cracked using dictionary lookup")+1  
	Xstatic const  char libpass_errmess[LIBPASS_MAXERRNO][MAX_ERR_STR_LEN]={
	X    {"Not Cracked"},
	X    {"Illegal Character(s) used"},
	X    {"Too Few Characters Used"},
	X    {"Too Few Unique Characters Used"},
	X    {"Too Few Alphas Used"},
	X    {"Too Many Alphas Used"},
	X    {"Too Few Lower-Case Alphas used"},
	X    {"Too Many Lower-Case Alphas used"},
	X    {"Too Few Upper-Case Alphas used"},
	X    {"Too Many Upper-Case Alphas used"},
	X    {"Too Few Digits used"},
	X    {"Too Many Digits used"},
	X    {"Too Few Punctuation Characters Used"},
	X    {"Too Many Punctuation Characters Used"},
	X    {"Too Few Other Characters Used"},
	X    {"Too Many Other Characters Used"},
	X    {"Bad Pattern Detected"},
	X    {"Palindrome (or close) detected"},
	X    {"Password Cracked using LoginID"},
	X    {"Password Cracked using GECOS"},
	X    {"Password Cracked using dictionary lookup"},
	X    {NULL}
	X  };
	X*/
	X
	X#define LIBPASS_SUCCESS  0
	X#define LIBPASS_BADCHARS 1
	X#define LIBPASS_TOOSMALL 2
	X#define LIBPASS_TOOFEW   3
	X#define LIBPASS_MINALPH  4
	X#define LIBPASS_MAXALPH  5
	X#define LIBPASS_MINLOWER 6
	X#define LIBPASS_MAXLOWER 7
	X#define LIBPASS_MINUPPER 8
	X#define LIBPASS_MAXUPPER 9
	X#define LIBPASS_MINDIGIT 10
	X#define LIBPASS_MAXDIGIT 11
	X#define LIBPASS_MINPUNCT 12
	X#define LIBPASS_MAXPUNCT 13
	X#define LIBPASS_MINOTHER 14
	X#define LIBPASS_MAXOTHER 15
	X#define LIBPASS_BADPATTERN 16
	X#define LIBPASS_PALINDROME 17
	X#define LIBPASS_CRACKED_L  18
	X#define LIBPASS_CRACKED_G  19
	X#define LIBPASS_CRACKED_D  20
	X#define LIBPASS_MAXERRNO   21
	X
	X
SHAR_EOF
if test 1761 -ne "`wc -c < 'passwd-return.h'`"
then
	echo shar: error transmitting "'passwd-return.h'" '(should have been 1761 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'passwd.h'" '(2832 characters)'
if test -f 'passwd.h'
then
	echo shar: will not over-write existing file "'passwd.h'"
else
sed 's/^	X//' << \SHAR_EOF > 'passwd.h'
	X#include <errno.h>
	X#ifndef BUFSIZE
	X#define BUFSIZE 128
	X#endif
	X
	X#define SUCCESS 0
	X#define EITSTOOBIG 127
	X#define EITSNOTFOUND 128
	X
	X/* These used to be all external variables, they are now loaded from configure() */
	Xstruct crack_config {
	X	char	C_dict[BUFSIZ];	/* -f dictionary we crack against */
	X	char	C_badchars[BUFSIZ]; /* -x characters not allowed in password */
	X	int	C_mindiff;	/* -c difference required before crackable? */
	X	int	C_minuniq;	/* -s minimum number of different chars */
	X	int	C_minlen;		/* -m shortest possible password */
	X	int	C_maxlen;		/* -M longest possible password */
	X	int	C_minalpha;	/* -a minimum number of alpha required */
	X	int	C_maxalpha;	/* -A maximum number of alpha allowed */
	X	int	C_minupper;	/* -u minimum number of upper required */
	X	int	C_maxupper;	/* -U maximum number of upper allowed */
	X	int	C_minlower;	/* -l minimum number of lower required */
	X	int	C_maxlower;	/* -L maximum number of lower allowed */
	X	int	C_minpunct;	/* -p minimum number of punct required */
	X	int	C_maxpunct;	/* -P maximum number of punct allowed */
	X	int	C_mindigit;	/* -d minimum number of digit required */
	X	int	C_maxdigit;	/* -D maximum number of digit allowed */
	X	int	C_minother;	/* -o minimum number of other required */
	X	int	C_maxother;	/* -O maximum number of other allowed */
	X	char	C_peer[BUFSIZE];		/* peer name, who am i talking with? */
	X	char	C_user[BUFSIZE];		/* user, who am I talking about? */
	X	char	*(*C_badpattern)(char *);	/* password contains a bad pattern */
	X};
	X
	X/* In order to make the transition to a library routine smoother (ie: no code changes)
	X   I have changed all the above extern declarations into the struct you see and now I 
	X   use the defines below which allows me to use all the code Reg used in tact (I would 
	X   be SURE to miss something otherwise).
	X   Of course, this assumes that passwd-crack.c declares:
	X
	Xextern struct crack_config *Crack_Config;
	X
	X*/
	X   
	X#define dict (Crack_Config->C_dict)
	X#define badchars (Crack_Config->C_badchars)
	X#define sysuid (Crack_Config->sysuid)
	X#define mindiff (Crack_Config->C_mindiff)
	X#define minuniq (Crack_Config->C_minuniq)
	X#define minlen (Crack_Config->C_minlen)
	X#define maxlen (Crack_Config->C_maxlen)
	X#define minalpha (Crack_Config->C_minalpha)
	X#define maxalpha (Crack_Config->C_maxalpha)
	X#define minupper (Crack_Config->C_minupper)
	X#define maxupper (Crack_Config->C_maxupper)
	X#define minlower (Crack_Config->C_minlower)
	X#define maxlower (Crack_Config->C_maxlower)
	X#define minpunct (Crack_Config->C_minpunct)
	X#define maxpunct (Crack_Config->C_maxpunct)
	X#define mindigit (Crack_Config->C_mindigit)
	X#define maxdigit (Crack_Config->C_maxdigit)
	X#define minother (Crack_Config->C_minother)
	X#define maxother (Crack_Config->C_maxother)
	X#define peer (Crack_Config->C_peer)
	X#define user (Crack_Config->C_user)
	X#define badpattern (Crack_Config->C_badpattern)
	X
SHAR_EOF
if test 2832 -ne "`wc -c < 'passwd.h'`"
then
	echo shar: error transmitting "'passwd.h'" '(should have been 2832 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'libpass.man'" '(1811 characters)'
if test -f 'libpass.man'
then
	echo shar: will not over-write existing file "'libpass.man'"
else
sed 's/^	X//' << \SHAR_EOF > 'libpass.man'
	X.\" $Author: kinch $
	X.\" $Date: 1995/11/27 18:13:57 $
	X.\" $Id: libpass.man,v 1.2 1995/11/27 18:13:57 kinch Exp $
	X.\" $Source: /usr/src/usr.local/security/libpasswd/RCS/libpass.man,v $
	X.\"
	X.TH LIBPASS 3 "27 November 1995"
	X.SH NAME
	Xlibpass \- pro-active password checker library.
	X.SH SYNOPSIS
	X.B int configure(char *configfile);
	X.PP
	X.B int crack(char *password,  char *loginID, 
	X.B char *gecos, int noisy);
	X.PP
	X.B char * libpass_errors(int errno);
	X.SH DESCRIPTION
	X.LP
	X.B libpass
	Xis a (possibly shared) library implementing the very good pro-active
	Xpassword cracking routines done by 
	X.B Reg Quinton 
	Xin his 
	X.B passwd-suite(1).
	XThis allows for an interface into the guts of 
	X.B passwd-suite
	Xwithout the necessity of interfacing with the server itself. Some
	Xprograms still need good passwords, even if those passwords are not
	Xin /etc/passwd.
	X.PP
	XThere are three public routines availabe from libpass, 
	X.B configure(), crack()
	Xand
	X.B libpass_errors(), configure()
	Xis expected to be called 
	X.I before
	Xthe call to
	X.B crack()
	Xin order that libpass dynamically configure its checking routines.
	X.PP
	X.B configure()
	Xexpects, as its first argument, the name of a configuration
	Xfile. There currently is no default configuration file, maybe there
	Xshould be?
	X.PP
	X.B libpass_errors() 
	Xcan be used to get a string describing the return code from
	X.B crack()
	X.SH BUGS
	X.LP
	XAlthough
	X.B crack()
	Xwill find multiple errors (and report them if `noisy'),
	X.B libpass_errors()
	Xwill only report on the 
	X.I last
	Xerror found by 
	X.B crack()
	X.PP
	XAny other bugs found should be communicated to the author.
	X.SH "SEE ALSO"
	X.BR passwd (5),
	X.BR passwdd (8).
	X.SH AUTHOR
	XDave Kinchlea <kinch@julian.uwo.ca>, Information Technology Services, 
	XUniversity of Western Ontario. 1995/11/27 with the original work done
	Xby Reg Quinton <reggers@julian.uwo.ca>
SHAR_EOF
if test 1811 -ne "`wc -c < 'libpass.man'`"
then
	echo shar: error transmitting "'libpass.man'" '(should have been 1811 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'libpass.exp'" '(16 characters)'
if test -f 'libpass.exp'
then
	echo shar: will not over-write existing file "'libpass.exp'"
else
sed 's/^	X//' << \SHAR_EOF > 'libpass.exp'
	Xconfigure
	Xcrack
SHAR_EOF
if test 16 -ne "`wc -c < 'libpass.exp'`"
then
	echo shar: error transmitting "'libpass.exp'" '(should have been 16 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'so_locations'" '(94 characters)'
if test -f 'so_locations'
then
	echo shar: will not over-write existing file "'so_locations'"
else
sed 's/^	X//' << \SHAR_EOF > 'so_locations'
	Xlibpass.so.1 \
	X		:st = .text 0x5ffe0000, 0x00010000:\
	X		:st = .data 0x5fff0000, 0x00010000:\
	X
SHAR_EOF
if test 94 -ne "`wc -c < 'so_locations'`"
then
	echo shar: error transmitting "'so_locations'" '(should have been 94 characters)'
fi
fi # end of overwriting check
#	End of shell archive
exit 0

-- 
kinch  <finger kinch@julian.uwo.ca> for PGP key(s)
Unix PGP Key fingerprint =  6F 36 6F 9D 79 16 DF 40  2B EC 18 5B 5C 6D 03 6F 
Home PGP Key fingerprint =  28 20 0E DF 27 17 80 C5  5D 04 8E 1B D0 9A A6 4C 

