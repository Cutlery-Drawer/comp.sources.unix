Newsgroups: comp.sources.unix
From: schwartz@galapagos.cse.psu.edu (Scott Schwartz)
Subject: v29i017: libprint-1.1 -- extensible and dynamic string formatting library, Part01/01
Message-id: <1.804930368.25458@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: schwartz@galapagos.cse.psu.edu (Scott Schwartz)
Posting-Number: Volume 29, Issue 17
Archive-Name: libprint-1.1/part01

libprint 1.1 --

This release of libprint includes an important bug fix, and two
enhancements.  The bug was a typo in writeall() that could result in an
infinite loop.  The enhancements are a change in the return value of
snprint (to be more like 4.4bsd), and support for 16 bit Unicode
"Runes" (contributed by Erik Quanstrom based on code from Rob Pike's
sam editor).

libprint 1.0 --

The routines in this library format strings similarly to the printf
family of functions.  They are better in the following ways:

	* they are small and efficient 
		(about 5K on a sparc)
	* user installable format specifiers 
		(e.g. %I to print an ip quad given a struct in_addr*)
	* you can print into dynamically allocated memory
		(using either malloc or a user supplied allocation function)
	* they are reentrant
		(as all good code should be)

This code is derived from Paul Haahr's print library, which is part of
Byron Rakitzis' popular implementation of the rc shell.  This release
cleans up a number of bugs, makes everything reentrant, and adds a
uniform set of entry points.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  COPYRIGHT blurb print.3 print.c mprint.c conv.c runeconv.c
#   rune.c print.h rune.h makefile .depend t1.c t2.c t3.c t4.c t5.c
#   t6.c t7.c t8.c
# Wrapped by schwartz@galapagos on Tue Jul  4 01:57:12 1995
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'COPYRIGHT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'COPYRIGHT'\"
else
echo shar: Extracting \"'COPYRIGHT'\" \(2191 characters\)
sed "s/^X//" >'COPYRIGHT' <<'END_OF_FILE'
X.SH COPYRIGHT
XAll files in this library except rune.c and rune.h are 
Xcovered by the following copyright notice:
X
X.RS 
X.ps -2
X.\" ---------- ---------- ---------- ----------
XCopyright 1994 Paul Haahr, Scott Schwartz, Byron Rakitzis.
XAll rights reserved.
X 
XThis software is not subject to any license of the American Telephone
Xand Telegraph Company or of the Regents of the University of California.
X 
XPermission is granted to anyone to use this software for any purpose on
Xany computer system, and to alter it and redistribute it freely, subject
Xto the following restrictions:
X 
X1. The author is not responsible for the consequences of use of this
Xsoftware, no matter how awful, even if they arise from flaws in it.
X 
X2. The origin of this software must not be misrepresented, either by
Xexplicit claim or by omission.  Since few users ever read sources,
Xcredits must appear in the documentation.
X 
X3. Altered versions must be plainly marked as such, and must not be
Xmisrepresented as being the original software.  Since few users
Xever read sources, credits must appear in the documentation.
X 
X4. This notice may not be removed or altered.
X 
X[this copyright notice is adapted from Henry Spencer's
X"awf" copyright notice.]
X.\" ---------- ---------- ---------- ----------
X.ps
X.RE
X
XThe files rune.c and rune.h, originally distributed 
Xas part of the sam editor, are covered by
Xthe following copyright notice:
X
X.RS
X.ps -2
X.\" ---------- ---------- ---------- ----------
XThe authors of this software are Rob Pike and Howard Trickey.
XCopyright (c) 1992 by AT&T.
XPermission to use, copy, modify, and distribute this software for any
Xpurpose without fee is hereby granted, provided that this entire notice
Xis included in all copies of any software which is or includes a copy
Xor modification of this software and in all copies of the supporting
Xdocumentation for such software.
XTHIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
XWARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&T MAKE ANY
XREPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
XOF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
X.\" ---------- ---------- ---------- ----------
X.ps
X.RE
END_OF_FILE
if test 2191 -ne `wc -c <'COPYRIGHT'`; then
    echo shar: \"'COPYRIGHT'\" unpacked with wrong size!
fi
# end of 'COPYRIGHT'
fi
if test -f 'blurb' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'blurb'\"
else
echo shar: Extracting \"'blurb'\" \(1484 characters\)
sed "s/^X//" >'blurb' <<'END_OF_FILE'
Xlibprint 1.1 --
X
XThis release of libprint includes an important bug fix, and two
Xenhancements.  The bug was a typo in writeall() that could result in an
Xinfinite loop.  The enhancements are a change in the return value of
Xsnprint (to be more like 4.4bsd), and support for 16 bit Unicode
X"Runes" (contributed by Erik Quanstrom based on code from Rob Pike's
Xsam editor).
X
Xlibprint 1.0 --
X
XThe routines in this library format strings similarly to the printf
Xfamily of functions.  They are better in the following ways:
X
X	* they are small and efficient 
X		(about 5K on a sparc)
X	* user installable format specifiers 
X		(e.g. %I to print an ip quad given a struct in_addr*)
X	* you can print into dynamically allocated memory
X		(using either malloc or a user supplied allocation function)
X	* they are reentrant
X		(as all good code should be)
X
XThis code is derived from Paul Haahr's print library, which is part of
XByron Rakitzis' popular implementation of the rc shell.  This release
Xcleans up a number of bugs, makes everything reentrant, and adds a
Xuniform set of entry points.
X
XThis package doesn't do floating point conversions, although they would
Xbe easy to add.  
X
XTo compile, edit the makefile.  It is organized for SunOS 4.1; on other
Xsystems you will want to alter or elide the shared library stuff.
XYou'll need an ansi compiler.
X
XThere are a number of test programs included; see them for examples
Xif you don't want to read the manpage.
X
X-- Scott Schwartz <schwartz@cse.psu.edu>
END_OF_FILE
if test 1484 -ne `wc -c <'blurb'`; then
    echo shar: \"'blurb'\" unpacked with wrong size!
fi
# end of 'blurb'
fi
if test -f 'print.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'print.3'\"
else
echo shar: Extracting \"'print.3'\" \(11033 characters\)
sed "s/^X//" >'print.3' <<'END_OF_FILE'
X.\"
X.\" $Id: print.3,v 1.16 1995/07/04 05:13:25 schwartz Exp $ -*-nroff-*-
X.\"
X.TH PRINT 3
X.SH NAME
Xprint \- string formatting and printing library
X.SH SYNOPSYS
X.LP
X.nf
X.ft B
X#include <print.h>
X.ft
X.fi
X.LP
X.nf
Xtypedef struct Format Format;
Xtypedef int (*Fmtconv)(Format *, int);
X
Xstruct Format {
X	/* for the formatting routines */
X	va_list args;
X	long flags, f1, f2;
X	Fmtconv* fmttab;
X	/* for the buffer maintainence routines */
X	char *buf, *bufbegin, *bufend;
X	int flushed;
X	int (*grow)(Format *, SIZE_T);
X	int error;
X	union { int n; void *p; } u;
X	/* misc */
X	void* client_data;
X};
X.fi
X.LP
X.nf
Xint print (const char *fmt,...)
Xint eprint (const char *fmt,...)
Xint fprint (int fd, const char *fmt,...)
Xint vfprint (int fd, const char *fmt, va_list)
X.fi
X.LP
X.nf
Xint sprint (char *buf, const char *fmt,...)
Xint snprint (char *buf, int buflen, const char *fmt,...)
Xint vsnprint (char *buf, int buflen, const char *fmt, va_list)
X.fi
X.LP
X.nf
Xchar *mprint (const char *fmt,...)
Xchar *smprint (Alloc alloc, SIZE_T* len, const char* fmt, ...)
Xchar *vsmprint (Alloc alloc, SIZE_T* len, const char* fmt, va_list)
Xchar *palloc (char* p, SIZE_T size)
X.fi
X.LP
X.nf
XFmtconv fmtinstall (int c, Fmtconv f)
X.fi
X.LP
X.nf
Xint fmtputc (Format *f, const char c)
Xint fmtappend (Format *format, const char *s, SIZE_T len)
Xint fmtcat (Format *format, const char *s)
X.fi
X.LP
X.nf
Xint fmtengine (Format *format, const char *fmt)
Xint fmtprint (Format *format, const char *fmt,...)
X.fi
X.SH SUMMARY
XThese routines format strings similarly to the printf family of
Xfunctions.  Unlike printf, they support user supplied format specifiers,
Xthey can format into memory that is allocated as needed (using a user
Xsupplied allocation function), they are reentrant (except for errno, the
Xglobal table of format specifiers, and possibly malloc if you choose to
Xuse it), and they are 8 bit clean ('\\0' bytes can be printed).
XPrint is also space efficient.  The program text is about 5K
Xwhen compiled for a sparc.
X
X.B fprint
Xwrites formatted text to a file descriptor
Xand returns the number of bytes written, or -1 on error.
X.B print
Xwrites text to stdout
Xwhile
X.B eprint
Xwrites text to stderr.
X.B vfprint
Xformats arguments supplied in a
X.I va_list
Xobtained from
X.B stdargs.
X
X.B sprint
Xwrites text into a user supplied buffer.  It writes at most
XFMT_SPRINT_BUFSIZ bytes including the terminating '\\0'.  It returns
Xthe number of bytes requested
X(not including the terminating '\\0').  Note that one must
Xcheck for truncation by comparing this value to the
Xsize of the buffer.
X.B snprint
Xwrites at most 
X.I n
Xbytes into a user supplied buffer.
X.B vsnprint
Xdoes the same, but takes its  arguments from a
X.I va_list.
X
X.B mprint
Xformats into a dynamically allocated buffer, to which it returns
Xa pointer.
XThe space is obtained
Xfrom 
X.B malloc
Xand should be freed when no longer needed.
X.B smprint
Xtakes a user supplied allocation function as an argument.  This
Xfunction should behave as ANSI-\fBrealloc\fP
Xdoes.  Some pre-ANSI systems' realloc fails to treat
Xrealloc(0,\fIn\fP)
Xas equivalent to
Xmalloc(\fIn\fP),
Xso we provide a routine
X.B palloc
Xwhich does.
Xsmprint also returns the number of bytes generated by writing
Xinto the *len argument if it is a non-null pointer.
X.B vsmprint
Xis like smprint, but that it reads arguments from a va_list.
X
X.B fmtinstall
Xinstalls a user supplied conversion function for a given character,
Xand returns the old value.  A conversion function takes a pointer
Xto a format structure and the character that induced the call.
XIt must return FMT_flag if the format character signals
Xsetting a flag and FMT_verb if it signals performing a conversion.
X
XA conversion function can use 
X.B fmtappend
Xto put new text into the output buffer;
X.B fmtputc
Xand 
X.B fmtcat
Xare supplied for convenience.
X
X.B fmtengine 
Xis the entry point for the actual formatting engine.  Given a properly
Xinitialized format structure and a format string, it will do the 
Xspecified work.  
X
X.B fmtprint 
Xis a very general interface to 
X.B fmtengine.
XIts arguments are a properly initialized format structure, a format
Xstring, and a matching number of parameters.  
X.B fmtprint
Xsaves and restores the argument list stored in the format structure, so
Xit can be used inside a conversion function to perform arbitrary
Xformatting operations.  This usage avoids the temporary buffers
Xthat 
X.B fmtappend
Xwould require.
X.B fmtengine
Xand 
X.B fmtprint
Xreturn the number of characters that they generated.
X
X.LP
XThe format structure contains three kinds of information.
XFirst, variables used by the formatting routines.
XThese are:
X.I args,
Xthe argument list containing the data to be formatted.
X.I flags, 
Xa bitmask storing the flags set at the time each conversion
Xfunction is called.  Possible values are given in print.h.
X.I "f1, f2"
Xare the field width and precision of each conversion.
XThe flags, f1, and f2 are zeroed before each conversion begins.
X.I "fmttab"
Xis a pointer to the per-format array of conversion functions, indexed
Xby conversion character.  If it is
Xzero, the global table will be used instead.
X
XSecond, variables used for buffer maintainance:
XThese are:
X.I buf, 
X.I bufbegin,
X.I bufend,
Xpointers to the insertion point in the output buffer, 
Xthe buffer itself, and the end of the buffer.
X.I flushed,
Xthe number of characters that have been transmitted to their
Xultimate destination thus far.
X.I grow, 
Xthe buffer growing function, called when the buffer is nearly full
Xso that it can be flushed or reallocated.
X.I error,
Xnonzero if an error has occurred during formatting.
XFormatting will stop after the first error is noticed.
X.I u.n,
X.I u.p,
Xthe name of the file descriptor to write to, or the
Xrealloc function to call to resize a buffer.
X
XFinally,
X.I client_data
Xprovides access to other arguments
Xin a reentrant way.
X
X.LP
XA simple format function, the one for  %c, looks like this:
X
X.nf
Xstatic int cconv(Format *format, int c) {
X    fmtputc(format, va_arg(format->args, int));
X    return FMT_verb;
X}
X.fi
X.LP
XA more interesting example is a conversion function that formats
Xa string with all unprintable characters quoted as in C.
X
X.nf
Xint print_cquote_conv (Format* format, int c)
X{
X    unsigned char* s = va_arg (format->args, unsigned char*);
X    unsigned char ch;
X
X    while ((ch = *s++)) {
X	if (isascii (ch) && isalnum (ch)) {
X	    if (ch == '\\\\')
X		fmtputc (format, ch);
X	    fmtputc (format, ch);
X	} else {
X	    fmtprint (format, "\\\\%03uo", ch);
X	}
X    }
X    return FMT_verb;
X}
X.fi
X
X
X.SH STANDARD CONVERSIONS
X.SS verbs
X.LP
X.PD 0
X.TP 10
X.B %
XA literal percent.
X.TP
X.B s
XA string.  With the # flag, use f2 for size and don't assume '\\0' termination.
X.TP
X.B c
XA single character.
X.TP
X.B "d, i"
XA decimal integer.
X.TP
X.B o
XAn octal integer. With #, prefix 0.
X.TP
X.B x
XA hex integer. With #, prefix 0x.
X.TP
X.B "e, f, g"
XFloating point conversions (not implemented).
X.TP
X.B "r, m"
Xsys_errlist[errno].  With # flag, errno.
X.TP
X.B "n"
Xwrites the number of characters emitted thus far into into an
Xint* argument.  Note!  Since transput stops if an error occurs,
Xthis verb may not be executed.
X.PD
X.SS flags
X.PD 0
X.TP 10
X.B u
XArg is unsigned.
X.TP
X.B h
XArg is short.
X.TP
X.B l
XArg is long.
X.TP
X.B q
XArg is quad (not implemented).
X.TP
X.B #
XSelect alternate output format.
X.TP
X.B -
XLeft justify output.
X.TP
X.B 0
XZero pad output.
X.TP
X.B 1-9
XSet the f1 (field width) specifier.
X.TP
X.B .
XThe f2 (precision) specifier follows.
X.TP
X.B *
XSet f1 or f2 from int arg.
X.PD
X.LP
X
X.SH OPTIONAL CONVERSIONS
XCalling 
X.I fmt_install_runeconv()
Xinstalls conversion functions which support Unicode 16 bit "Runes"
Xby transforming them to the UTF-8 multibyte encoding.
XThe %C operator transforms a single Rune, while %S transforms
Xa 0 terminated array, analagously to %c and %s.
X
X.SH NOTES
XUnlike printf, flags like 'u' need to be followed by a verb like 'd'.
X
XThis code is derived from the print routines  that Paul Haahr wrote for
XByron Rakitzis' implementation of
X.I rc.
X
X.SH AUTHORS
X.LP
Xlibprint: 
XPaul Haahr, 
XByron Rakitzis,
XScott Schwartz.
X.LP
Xrunes:
XRob Pike, Howard Trickey
X.LP
Xruneconv:
XErik Quanstrom
X
X.SH BUGS
X.LP
XWhat to do when an invalid print char is detected?  BSD printf emits
Xthe character without comment.  We print a warning to stderr and stop
Xformatting.
X.LP
XWhat should snprint return?
X.LP
XThe namespace
Xfor installable format specifiers
Xis very small, so collisions and mistakes will probably cause trouble.
X.LP
XNo floating point conversion functions (%e, %f, %g) yet.
X.LP
XQuadword conversions (%qd) would be nice too.
X.LP
XDoes %d really work in boundary cases (signed/unsigned long/int/short
Xmaxint, minint)?
X.LP
XWhat should snprint return?  Number of bytes requested, or transferred?
X.LP
Xfmtputc still feels kludgy.  It used to directly write bytes into 
Xthe buffer, in an attempt at efficiency, but that turned out to 
Xcomplicate snprint. Now it just calls fmtappend.
X
X.SH COPYRIGHT
XAll files in this library except rune.c and rune.h are 
Xcovered by the following copyright notice:
X
X.RS 
X.ps -2
X.\" ---------- ---------- ---------- ----------
XCopyright 1994 Paul Haahr, Scott Schwartz, Byron Rakitzis.
XAll rights reserved.
X 
XThis software is not subject to any license of the American Telephone
Xand Telegraph Company or of the Regents of the University of California.
X 
XPermission is granted to anyone to use this software for any purpose on
Xany computer system, and to alter it and redistribute it freely, subject
Xto the following restrictions:
X 
X1. The author is not responsible for the consequences of use of this
Xsoftware, no matter how awful, even if they arise from flaws in it.
X 
X2. The origin of this software must not be misrepresented, either by
Xexplicit claim or by omission.  Since few users ever read sources,
Xcredits must appear in the documentation.
X 
X3. Altered versions must be plainly marked as such, and must not be
Xmisrepresented as being the original software.  Since few users
Xever read sources, credits must appear in the documentation.
X 
X4. This notice may not be removed or altered.
X 
X[this copyright notice is adapted from Henry Spencer's
X"awf" copyright notice.]
X.\" ---------- ---------- ---------- ----------
X.ps
X.RE
X
XThe files rune.c and rune.h, originally distributed 
Xas part of the sam editor, are covered by
Xthe following copyright notice:
X
X.RS
X.ps -2
X.\" ---------- ---------- ---------- ----------
XThe authors of this software are Rob Pike and Howard Trickey.
XCopyright (c) 1992 by AT&T.
XPermission to use, copy, modify, and distribute this software for any
Xpurpose without fee is hereby granted, provided that this entire notice
Xis included in all copies of any software which is or includes a copy
Xor modification of this software and in all copies of the supporting
Xdocumentation for such software.
XTHIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
XWARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&T MAKE ANY
XREPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
XOF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
X.\" ---------- ---------- ---------- ----------
X.ps
X.RE
END_OF_FILE
if test 11033 -ne `wc -c <'print.3'`; then
    echo shar: \"'print.3'\" unpacked with wrong size!
fi
# end of 'print.3'
fi
if test -f 'print.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'print.c'\"
else
echo shar: Extracting \"'print.c'\" \(12852 characters\)
sed "s/^X//" >'print.c' <<'END_OF_FILE'
X/* print.c -- formatted printing routines */
X/* this by Scott Schwartz, derived from Paul Haahr's version of 12/91 */
X
Xstatic const char rcsid[] = 
X"@(#)$Id: print.c,v 1.34 1995/05/01 06:09:17 schwartz Exp $";
X
X#include <unistd.h>
X#include <stdlib.h>
X#include <stdarg.h>
X#include <string.h>
X#include <errno.h>
X#include "print.h"
X
X#ifdef __GNUC__
Xextern void * memcpy (void *, const void *, long unsigned int);
X#endif
X
X/*
X * functions for inserting strings in the format buffer
X */
X
X#if !defined __GNUC__ || defined __STRICT_ANSI__
X#define inline /* */
X#endif
X
Xextern int fmtappend (Format *format, const char *s, SIZE_T len) {
X    format->reqlen += len;
X    if (format->error)
X	return 0;
X    while (len > format->bufend - format->buf) {
X	const SIZE_T split = format->bufend - format->buf;
X	memcpy (format->buf, s, split);
X	format->buf += split;
X	s += split;
X	len -= split;
X	if ((*format->grow)(format, len))
X	    return 0;
X    }
X    memcpy (format->buf, s, len);
X    format->buf += len;
X    return 1;
X}
X
Xextern int fmtputc (Format *f, const char c) {
X    return fmtappend (f, &c, 1);
X}
X
Xextern int fmtcat (Format *format, const char *s) {
X    return fmtappend (format, s, strlen (s));
X}
X
X/*
X * conversion functions
X *	true return -> flag changes only, not a conversion
X */
X
X#define Flag(name, flag) \
Xstatic int name (Format *format, int c) { \
X	format->flags |= flag; \
X	return FMT_flag; \
X}
X
XFlag (uconv,	FMT_unsigned)
XFlag (hconv,	FMT_short)
XFlag (lconv,	FMT_long)
XFlag (altconv,	FMT_altform)
XFlag (leftconv,	FMT_leftside)
XFlag (dotconv,	FMT_f2set)
X
Xstatic int digitconv (Format *format, int c) {
X    if (format->flags & FMT_f2set)
X	format->f2 = 10 * format->f2 + c - '0';
X    else {
X	format->flags |= FMT_f1set;
X	format->f1 = 10 * format->f1 + c - '0';
X    }
X    return FMT_flag;
X}
X
Xstatic int zeroconv (Format *format, int c) {
X    if (format->flags & (FMT_f1set | FMT_f2set))
X	return digitconv (format, '0');
X    format->flags |= FMT_zeropad;
X    return FMT_flag;
X}
X
Xstatic int starconv (Format *format, int c) {
X    int n = va_arg (format->args, int);
X    if (format->flags & FMT_f2set)
X	format->f2 = n;
X    else {
X	format->flags |= FMT_f1set;
X	format->f1 = n;
X    }
X    return FMT_flag;
X}
X
Xstatic void pad (Format *format, SIZE_T len, int c) {
X    do; while (len-- != 0 && fmtputc (format, c));
X}
X
Xstatic int sconv (Format *format, int c) {
X    SIZE_T maxbytes, minwidth, extra;
X    char *s = va_arg (format->args, char *);
X
X    if (!s) s = "(null)";
X
X    if (format->flags & FMT_altform) {
X	maxbytes = (format->flags & FMT_f2set) ? format->f2 : strlen (s);
X	/* maxbytes may overrun s,  but this way we don't have 
X	   to assume that s is null terminated when f2 is set. 
X	   Maybe use a different format character for this? */
X    } else {
X	/* do f2 like printf */
X	maxbytes = strlen (s);
X	if ((format->flags & FMT_f2set) && (format->f2 < maxbytes))
X	    maxbytes = format->f2;
X    }
X
X    minwidth = (format->flags & FMT_f1set) ? format->f1 : maxbytes;
X    extra = (minwidth > maxbytes) ? minwidth - maxbytes : 0;
X
X    if (format->flags & FMT_leftside) {
X	fmtappend (format, s, maxbytes);
X	pad (format, extra, ' ');
X    } else {
X	pad (format, extra, ' ');
X	fmtappend (format, s, maxbytes);
X    }
X	
X    return FMT_verb;
X}
X
Xstatic char *utoa (unsigned long u, 
X		  char *t, unsigned int radix, const char *digit) {
X    if (u >= radix) {
X	t = utoa (u / radix, t, radix, digit);
X	u %= radix;
X    }
X    *t++ = digit[u];
X    return t;
X}
X
Xstatic void intconv (Format *format, 
X		    unsigned int radix, int upper, const char *altform) {
X    static const char * const table[] = {
X	"0123456789abcdefghijklmnopqrstuvwxyz",
X	"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
X    };
X    char padchar;
X    SIZE_T len, pre, zeroes, padding, width;
X    long n, flags;
X    unsigned long u;
X    char number[64], prefix[20];
X
X    if (radix > 36)
X	return;
X
X    flags = format->flags;
X    if (flags & FMT_unsigned) {
X	if (flags & FMT_long)
X	    n = (unsigned long) va_arg (format->args, long);
X	else if (flags & FMT_short)
X	    n = (unsigned long)(unsigned short) va_arg (format->args, int);
X	else
X	    n = (unsigned long)(unsigned int) va_arg (format->args, int);
X    } else {
X	if (flags & FMT_long)
X	    n = (long) va_arg (format->args, long);
X	else if (flags & FMT_short)
X	    n = (long)(short) va_arg (format->args, int);
X	else
X	    n = (long) va_arg (format->args, int);
X    }
X
X    pre = 0;
X    if ((flags & FMT_unsigned) || n >= 0)
X	u = n;
X    else {
X	prefix[pre++] = '-';
X	u = -n;
X    }
X
X    if (flags & FMT_altform)
X	while (*altform != '\0')
X	    prefix[pre++] = *altform++;
X
X    len = utoa (u, number, radix, table[upper]) - number;
X    if ((flags & FMT_f2set) && (SIZE_T) format->f2 > len)
X	zeroes = format->f2 - len;
X    else
X	zeroes = 0;
X
X    width = pre + zeroes + len;
X    if ((flags & FMT_f1set) && (SIZE_T) format->f1 > width) {
X	padding = format->f1 - width;
X    } else
X	padding = 0;
X
X    padchar = ' ';
X    if (padding > 0 && flags & FMT_zeropad) {
X	padchar = '0';
X	if ((flags & FMT_leftside) == 0) {
X	    zeroes += padding;
X	    padding = 0;
X	}
X    }
X
X    if ((flags & FMT_leftside) == 0)
X	pad (format, padding, padchar);
X    fmtappend (format, prefix, pre);
X    pad (format, zeroes, '0');
X    fmtappend (format, number, len);
X    if (flags & FMT_leftside)
X	pad (format, padding, padchar);
X}
X
Xstatic int cconv (Format *format, int c) {
X    fmtputc (format, va_arg (format->args, int));
X    return FMT_verb;
X}
X
Xstatic int dconv (Format *format, int c) {
X    intconv (format, 10, 0, "");
X    return FMT_verb;
X}
X
Xstatic int oconv (Format *format, int c) {
X    intconv (format, 8, 0, "0");
X    return FMT_verb;
X}
X
Xstatic int xconv (Format *format, int c) {
X    intconv (format, 16, 0, "0x");
X    return FMT_verb;
X}
X
Xstatic int litconv (Format *format, int c) {
X    fmtputc (format, c);
X    return FMT_verb;
X}
X
Xextern int fmt_badconv (Format *format, int c) {
X    eprint ("libprint: bad conversion char '%c'\n", c);
X    format->error = 1; /* XXX - stop or not? consume an argv? */
X    return FMT_verb;
X}
X
Xstatic int nconv (Format* format, int c)
X{
X    /* write the current write length into an int* argument */
X    int *p = va_arg (format->args, int*);
X    if (p) *p = format->buf - format->bufbegin + format->flushed;
X    return FMT_verb;
X}
X
Xstatic int rconv (Format *format, int c) {
X    int e = errno;
X    /* do we have to store errno in the format structure because
X       the grow proc could make a syscall that sets errno before
X       we get here? */
X
X    if (format->flags & FMT_altform) {
X	fmtprint (format, "%d", e);
X    } else {
X	/* strerror() might be better, but this way we can range check */
X        extern int sys_nerr;
X        extern char* sys_errlist[];
X	if ((0 <= e) && (e < sys_nerr)) 
X	    fmtcat (format, sys_errlist[e]);
X	else
X	    fmtprint (format, "unknown error (%d)", e);
X    }
X    return FMT_verb;	
X}
X
X/*
X * conversion table management
X */
X
Xstatic Fmtconv dflt_fmttab[FMT_MAXCONV];
X
Xstatic Fmtconv* ensure_inittab (Fmtconv fmttab[])
X{
X    int i;
X
X    if (fmttab[0] != 0)
X	return fmttab;
X
X    for (i = 0; i < FMT_MAXCONV; i++)
X	fmttab[i] = fmt_badconv;
X
X    fmttab['%'] = litconv;
X
X    fmttab['s'] = sconv;
X    fmttab['c'] = cconv;
X    fmttab['d'] = dconv;
X    fmttab['i'] = dconv;
X    fmttab['o'] = oconv;
X    fmttab['x'] = xconv;
X    fmttab['r'] = rconv;
X    fmttab['m'] = rconv;
X    fmttab['n'] = nconv;
X
X    fmttab['u'] = uconv;
X    fmttab['h'] = hconv;
X    fmttab['l'] = lconv;
X    fmttab['#'] = altconv;
X    fmttab['-'] = leftconv;
X    fmttab['.'] = dotconv;
X    fmttab['*'] = starconv;
X
X    fmttab['0'] = zeroconv;
X    for (i = '1'; i <= '9'; i++)
X	fmttab[i] = digitconv;
X
X    return fmttab;
X}
X
Xextern Fmtconv fmtinstall (int c, Fmtconv f)
X{
X    Fmtconv oldf;
X
X    ensure_inittab (dflt_fmttab);
X    c &= FMT_MAXCONV - 1;
X    oldf = dflt_fmttab[c];
X    if (f != 0)
X	dflt_fmttab[c] = f;
X    return oldf;
X}
X
X/* --- */
X
Xstatic void fmtinitbuf (Format *format, 
X			char *buf, SIZE_T size, int (*grow)(Format *, SIZE_T))
X{
X    format->buf      = buf;
X    format->bufbegin = buf;
X    format->bufend   = buf + size;
X    format->grow     = grow;
X    format->flushed  = 0;
X    format->error    = 0;
X    format->reqlen   = 0;
X}
X
Xstatic void fmtinitarg (Format *format, 
X			va_list args, Fmtconv* fmttab, void* client_data)
X{
X    format->args = args;
X    format->fmttab = 0;
X    format->client_data = 0;
X}
X		     
X/*
X * the formatting engine
X */
X
Xextern int fmtengine (Format *format, const char *fmt)
X{
X    const unsigned char *s = (const unsigned char *) fmt;
X    Fmtconv* fmttab;
X 
X    if ((fmttab = format->fmttab) == 0)
X        fmttab = ensure_inittab (dflt_fmttab);
X
X    for (;;) {
X	int c = *s++;
X
X	switch (c) {
X	case '%':
X	    format->flags = format->f1 = format->f2 = 0;
X	    do c = *s++; while ((*fmttab[c])(format, c) == FMT_flag);
X	    break;
X	case '\0':
X	    return format->buf - format->bufbegin + format->flushed;
X	default:
X	    fmtputc (format, c);
X	    break;
X	}
X    }
X}
X
X
X/*
X * the public entry points
X */
X
Xextern int fmtprint (Format *format, const char *fmt,...) {
X    int n = -format->flushed;
X    va_list ap, saveargs;
X
X    va_start (ap, fmt);
X    saveargs = format->args;
X    format->args = ap;
X    n += fmtengine (format, fmt);
X    va_end (format->args);
X    format->args = saveargs;
X
X    return n + format->flushed;
X}
X
X/* --- */
X
Xstatic int writeall (int fd, char *buf, SIZE_T n) {
X    int i, remain;
X
X    for (i = 0, remain = n; remain > 0; buf += i, remain -= i)
X	if ((i = write (fd, buf, remain)) <= 0)
X	    if ((errno == EAGAIN) || (errno == EWOULDBLOCK))
X		continue;
X	    else
X		break;
X
X    return n - remain; 
X}
X
X/* --- */
X
Xextern int fmt_fprint_flush (Format *format, SIZE_T more) {
X    SIZE_T n = format->buf - format->bufbegin;
X    SIZE_T r;
X
X    r = writeall (format->u.n, format->bufbegin, n);
X    format->flushed += r;
X    format->buf -= r;
X    format->error |= (r != n);
X
X    return format->error;
X}
X
Xextern int vfprint (int fd, const char *fmt, va_list ap) {
X    char buf[1024];
X    Format format;
X
X    fmtinitbuf (&format, buf, sizeof buf, fmt_fprint_flush);
X    fmtinitarg (&format, ap, 0, 0);
X    format.u.n = fd;
X
X    fmtengine (&format, fmt);
X    fmt_fprint_flush (&format, 0);
X    return format.error ? -1 : format.flushed;
X}
X
Xextern int fprint (int fd, const char *fmt,...) {
X    int n;
X    va_list ap;
X
X    va_start (ap, fmt);
X    n = vfprint (fd, fmt, ap);
X    va_end (ap);
X    return n;
X}
X
Xextern int print (const char *fmt,...) {
X    int n;
X    va_list ap;
X
X    va_start (ap, fmt);
X    n = vfprint (1, fmt, ap);
X    va_end (ap);
X    return n;
X}
X
Xextern int eprint (const char *fmt,...) {
X    int n;
X    va_list ap;
X
X    va_start (ap, fmt);
X    n = vfprint (2, fmt, ap);
X    va_end (ap);
X    return n;
X}
X
X/* --- */
X
Xextern int fmt_memprint_grow (Format *format, SIZE_T more) {
X    char *buf = 0;
X    SIZE_T len = format->bufend - format->bufbegin + 1;
X    len = (len >= more)
X	? len * 2 
X        : ((len + more) + FMT_PRINT_ALLOCSIZE) &~ (FMT_PRINT_ALLOCSIZE - 1);
X
X    buf = ((Alloc)format->u.p)(format->bufbegin, len);
X    if (buf) {
X	format->buf	 = buf + (format->buf - format->bufbegin);
X	format->bufbegin = buf;
X	format->bufend   = buf + len - 1;
X	return 0;
X    }
X    return format->error = 1;
X}
X
Xextern char *fmt_memprint (Format *format, const char *fmt, SIZE_T* len) {
X    char* buf;
X    int n;
X
X    buf = (*(Alloc)format->u.p) (0, FMT_PRINT_ALLOCSIZE);
X    if (!buf) {
X	format->error = 1;
X	return 0;
X    }
X
X    fmtinitbuf (format, buf, FMT_PRINT_ALLOCSIZE - 1, fmt_memprint_grow);
X    n = fmtengine (format, fmt);
X    *format->buf = '\0';
X    if (len) *len = n;
X
X    return format->error ? 0 : format->bufbegin;
X}
X
Xextern char *vsmprint (Alloc a, SIZE_T* len, const char* fmt, va_list ap) {
X    Format format;
X
X    fmtinitarg (&format, ap, 0, 0);
X    format.u.p = (void*) a;
X
X    return fmt_memprint (&format, fmt, len);
X}
X
Xextern char *smprint (Alloc alloc, SIZE_T* len, const char* fmt, ...) {
X    char* result;
X    va_list ap;
X
X    va_start (ap, fmt);
X    result = vsmprint (alloc, len, fmt, ap);
X    va_end (ap);
X    return result;
X}
X
X/* note -- moved palloc and mprint to mprint.c */
X
X/* --- */
X
Xextern int fmt_snprint_grow (Format *format, SIZE_T more) {
X    return format->error=1;
X}
X
Xextern int vsnprint (char *buf, int buflen, const char *fmt, va_list ap) {
X    Format format;
X
X    fmtinitbuf (&format, buf, buflen - 1, fmt_snprint_grow);
X    fmtinitarg (&format, ap, 0, 0);
X    format.args = ap;
X
X    (void) fmtengine (&format, fmt);
X    *format.buf = '\0';
X    return format.reqlen;
X}
X
Xextern int snprint (char *buf, int buflen, const char *fmt,...) {
X    int n;
X    va_list ap;
X
X    va_start (ap, fmt);
X    n = vsnprint (buf, buflen, fmt, ap);
X    va_end (ap);
X    return n;
X}
X
Xextern int sprint (char *buf, const char *fmt,...) {
X    int n;
X    va_list ap;
X
X    va_start (ap, fmt);
X    n = vsnprint (buf, FMT_SPRINT_BUFSIZ, fmt, ap);
X    va_end (ap);
X    return n;
X}
END_OF_FILE
if test 12852 -ne `wc -c <'print.c'`; then
    echo shar: \"'print.c'\" unpacked with wrong size!
fi
# end of 'print.c'
fi
if test -f 'mprint.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mprint.c'\"
else
echo shar: Extracting \"'mprint.c'\" \(475 characters\)
sed "s/^X//" >'mprint.c' <<'END_OF_FILE'
X#include <stdlib.h>
X#include "print.h"
X
Xstatic const char rcsid[] = 
X"@(#)$Id: mprint.c,v 1.3 1994/10/15 19:37:26 schwartz Exp $";
X
X/* this is what ansi realloc does, but not e.g. sunos realloc */
Xextern char* palloc (char* p, SIZE_T size) {
X    return p ? realloc(p, size) : malloc(size);
X}
X
Xextern char *mprint(const char *fmt,...) {
X    char* result;
X    va_list ap;
X
X    va_start(ap, fmt);
X    result = vsmprint (palloc, 0, fmt, ap);
X    va_end(ap);
X    return result;
X}
END_OF_FILE
if test 475 -ne `wc -c <'mprint.c'`; then
    echo shar: \"'mprint.c'\" unpacked with wrong size!
fi
# end of 'mprint.c'
fi
if test -f 'conv.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'conv.c'\"
else
echo shar: Extracting \"'conv.c'\" \(1288 characters\)
sed "s/^X//" >'conv.c' <<'END_OF_FILE'
X/* miscellaneous conversion functions for the print library */
X
Xstatic const char rcsid[] =
X"@(#)$Id: conv.c,v 1.9 1994/10/15 19:37:26 schwartz Exp $";
X
X#include <netdb.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <netinet/in.h>
X#include <arpa/inet.h>
X#include <ctype.h>
X#include "print.h"
X
X/* %I prints a struct in_addr* in dotted quad form */
X
Xint print_inaddr_conv(Format *format, int c) 
X{
X    struct in_addr* in;
X
X    in = va_arg (format->args, struct in_addr*);
X    if (in)
X	fmtcat (format, inet_ntoa (*in));
X    else
X	fmtcat (format, "0.0.0.0");
X    return FMT_verb;
X}
X
X/* %Q writes a string quoted for reading by /bin/rc */
X
Xint print_rcquote_conv (Format* format, int c)
X{
X    unsigned char* s = va_arg (format->args, unsigned char*);
X    unsigned char ch;
X
X    while ((ch = *s++)) {
X	if (ch == '\'') 
X	    fmtputc (format, ch);
X	fmtputc (format, ch);
X    }
X    return FMT_verb;
X}
X
Xint print_cquote_conv (Format* format, int c)
X{
X    unsigned char* s = va_arg (format->args, unsigned char*);
X    unsigned char ch;
X
X    /* XXX - ignores f1 and f2 */
X    while ((ch = *s++)) {
X	if (isascii (ch) && isalnum (ch)) {
X	    if (ch == '\\')
X		fmtputc (format, ch);
X	    fmtputc (format, ch);
X	} else {
X	    fmtprint (format, "\\%03uo", ch);
X	}
X    }
X    return FMT_verb;
X}
END_OF_FILE
if test 1288 -ne `wc -c <'conv.c'`; then
    echo shar: \"'conv.c'\" unpacked with wrong size!
fi
# end of 'conv.c'
fi
if test -f 'runeconv.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'runeconv.c'\"
else
echo shar: Extracting \"'runeconv.c'\" \(1862 characters\)
sed "s/^X//" >'runeconv.c' <<'END_OF_FILE'
Xstatic const char rcsid[] = 
X"@(#)$Id: runeconv.c,v 1.3 1995/07/04 05:13:25 schwartz Exp $";
X
X/* Contributed by Erik Quanstrom <quanstro@sartre.minerva.bah.com> */
X
X#include "print.h"
X#include "rune.h"
X
Xstatic void pad (Format *format, SIZE_T len, int c) {
X    do; while (len-- != 0 && fmtputc (format, c));
X}
X
Xstatic SIZE_T Runelen (const Rune *r) {
X	const Rune *s = r;
X	while (*r) r++;
X	return r-s;
X}
X
X/* delete this when you get a decent compiler */
Xstatic Rune stupid[] = { 923, 0};
X
Xstatic int Sconv (Format *format, int c) {
X    SIZE_T maxrunes, minwidth, extra;
X    Rune *R = va_arg (format->args, Rune*);
X    char s[UTFmax]; 
X    int i;
X
X/*    if (!R) R = L"Λ";  some compilers choke on this*/
X    if (!R) R = stupid;
X
X    if (format->flags & FMT_altform) {
X	maxrunes = (format->flags & FMT_f2set) ? format->f2 : Runelen (R);
X	/* maxrunes may overrun R,  but this way we don't have 
X	   to assume that R is null terminated when f2 is set. */
X    } else {
X	/* do f2 like printf */
X	maxrunes = Runelen (R);
X	if ((format->flags & FMT_f2set) && (format->f2 < maxrunes))
X	    maxrunes = format->f2;
X    }
X
X    minwidth = (format->flags & FMT_f1set) ? format->f1 : maxrunes;
X    extra = (minwidth > maxrunes) ? minwidth - maxrunes : 0;
X
X    if (format->flags & FMT_leftside) {
X	while (maxrunes--) {
X    		i = runetochar (s, R++);
X    		fmtappend (format, s, i);
X	}
X	pad (format, extra, ' ');
X    } else {
X	pad (format, extra, ' ');
X	while (maxrunes--) {
X    		i = runetochar (s, R++);
X    		fmtappend (format, s, i);
X	}
X    }
X	
X    return FMT_verb;
X}
X
Xstatic int Cconv (Format *format, int c) {
X    Rune r = (unsigned short) va_arg (format->args, int);
X    char s[UTFmax];
X    int i;
X
X    i = runetochar (s, &r);
X    fmtappend (format, s, i);
X    return FMT_verb;
X}
X
Xvoid fmt_install_runeconv ()
X{
X    fmtinstall ('C', Cconv);
X    fmtinstall ('S', Sconv);
X}
X
END_OF_FILE
echo shar: 2 control characters may be missing from \"'runeconv.c'\"
if test 1862 -ne `wc -c <'runeconv.c'`; then
    echo shar: \"'runeconv.c'\" unpacked with wrong size!
fi
# end of 'runeconv.c'
fi
if test -f 'rune.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rune.c'\"
else
echo shar: Extracting \"'rune.c'\" \(3523 characters\)
sed "s/^X//" >'rune.c' <<'END_OF_FILE'
X/* 
X * The authors of this software are Rob Pike and Howard Trickey.
X * 		Copyright (c) 1992 by AT&T.
X * Permission to use, copy, modify, and distribute this software for any
X * purpose without fee is hereby granted, provided that this entire notice
X * is included in all copies of any software which is or includes a copy
X * or modification of this software and in all copies of the supporting
X * documentation for such software.
X * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
X * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&T MAKE ANY
X * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
X * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
X */
X
X/* Copyright (c) 1992 AT&T - All rights reserved. */
X#include	<string.h>
X#include	"rune.h"
X
Xtypedef unsigned char uchar;
X
Xenum
X{
X	Bit1	= 7,
X	Bitx	= 6,
X	Bit2	= 5,
X	Bit3	= 4,
X	Bit4	= 3,
X
X	T1	= ((1<<(Bit1+1))-1) ^ 0xFF,	/* 0000 0000 */
X	Tx	= ((1<<(Bitx+1))-1) ^ 0xFF,	/* 1000 0000 */
X	T2	= ((1<<(Bit2+1))-1) ^ 0xFF,	/* 1100 0000 */
X	T3	= ((1<<(Bit3+1))-1) ^ 0xFF,	/* 1110 0000 */
X	T4	= ((1<<(Bit4+1))-1) ^ 0xFF,	/* 1111 0000 */
X
X	Rune1	= (1<<(Bit1+0*Bitx))-1,		/* 0000 0000 0111 1111 */
X	Rune2	= (1<<(Bit2+1*Bitx))-1,		/* 0000 0111 1111 1111 */
X	Rune3	= (1<<(Bit3+2*Bitx))-1,		/* 1111 1111 1111 1111 */
X
X	Maskx	= (1<<Bitx)-1,			/* 0011 1111 */
X	Testx	= Maskx ^ 0xFF,			/* 1100 0000 */
X
X	Bad	= Runeerror
X};
X
Xint
Xchartorune(Rune *rune, const char *str)
X{
X	int c, c1, c2;
X	long l;
X
X	/*
X	 * one character sequence
X	 *	00000-0007F => T1
X	 */
X	c = *(uchar*)str;
X	if(c < Tx) {
X		*rune = c;
X		return 1;
X	}
X
X	/*
X	 * two character sequence
X	 *	0080-07FF => T2 Tx
X	 */
X	c1 = *(uchar*)(str+1) ^ Tx;
X	if(c1 & Testx)
X		goto bad;
X	if(c < T3) {
X		if(c < T2)
X			goto bad;
X		l = ((c << Bitx) | c1) & Rune2;
X		if(l <= Rune1)
X			goto bad;
X		*rune = l;
X		return 2;
X	}
X
X	/*
X	 * three character sequence
X	 *	0800-FFFF => T3 Tx Tx
X	 */
X	c2 = *(uchar*)(str+2) ^ Tx;
X	if(c2 & Testx)
X		goto bad;
X	if(c < T4) {
X		l = ((((c << Bitx) | c1) << Bitx) | c2) & Rune3;
X		if(l <= Rune2)
X			goto bad;
X		*rune = l;
X		return 3;
X	}
X
X	/*
X	 * bad decoding
X	 */
Xbad:
X	*rune = Bad;
X	return 1;
X}
X
Xint
Xrunetochar(char *str, const Rune *rune)
X{
X	long c;
X
X	/*
X	 * one character sequence
X	 *	00000-0007F => 00-7F
X	 */
X	c = *rune;
X	if(c <= Rune1) {
X		str[0] = c;
X		return 1;
X	}
X
X	/*
X	 * two character sequence
X	 *	0080-07FF => T2 Tx
X	 */
X	if(c <= Rune2) {
X		str[0] = T2 | (c >> 1*Bitx);
X		str[1] = Tx | (c & Maskx);
X		return 2;
X	}
X
X	/*
X	 * three character sequence
X	 *	0800-FFFF => T3 Tx Tx
X	 */
X	str[0] = T3 |  (c >> 2*Bitx);
X	str[1] = Tx | ((c >> 1*Bitx) & Maskx);
X	str[2] = Tx |  (c & Maskx);
X	return 3;
X}
X
Xint
Xrunelen(long c)
X{
X	Rune rune;
X	char str[10];
X
X	rune = c;
X	return runetochar(str, &rune);
X}
X
Xint
Xfullrune(const char *str, int n)
X{
X	int c;
X
X	if(n > 0) {
X		c = *(uchar*)str;
X		if(c < Tx)
X			return 1;
X		if(n > 1)
X			if(c < T3 || n > 2)
X				return 1;
X	}
X	return 0;
X}
X
Xchar*
Xutfrune(char *s, long c)
X{
X	long c1;
X	Rune r;
X	int n;
X
X	if(c < Runesync)		/* not part of utf sequence */
X		return strchr(s, c);
X
X	for(;;) {
X		c1 = *(uchar*)s;
X		if(c1 < Runeself) {	/* one byte rune */
X			if(c1 == 0)
X				return 0;
X			if(c1 == c)
X				return s;
X			s++;
X			continue;
X		}
X		n = chartorune(&r, s);
X		if(r == c)
X			return s;
X		s += n;
X	}
X	return 0;
X}
X
Xlong
Xutflen(const char *s)
X{
X	int c;
X	long n;
X	Rune rune;
X
X	n = 0;
X	for(;;) {
X		c = *(uchar*)s;
X		if(c < Runeself) {
X			if(c == 0)
X				return n;
X			s++;
X		} else
X			s += chartorune(&rune, s);
X		n++;
X	}
X	return 0;
X}
END_OF_FILE
if test 3523 -ne `wc -c <'rune.c'`; then
    echo shar: \"'rune.c'\" unpacked with wrong size!
fi
# end of 'rune.c'
fi
if test -f 'print.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'print.h'\"
else
echo shar: Extracting \"'print.h'\" \(2672 characters\)
sed "s/^X//" >'print.h' <<'END_OF_FILE'
X/* from rc 1.4 - code by Byron and Paul */
X#ifndef __nicer_print_h
X#define __nicer_print_h
X
X#include <stdarg.h>
X
X#ifndef SIZE_T
Xtypedef unsigned long int SIZE_T;
X#endif
X
Xenum {
X  /* return values of conversion functions */
X  FMT_flag = 0,			/* uhl#-.[0-9] */
X  FMT_verb = 1,			/* scdoxr */
X  FMT_error = 2,  		/* error during formatting */
X
X  /* sizes of various things */
X  FMT_MAXCONV = 256,	  	/* number of conversion characters */
X  FMT_PRINT_ALLOCSIZE = 64,	/* grow by this many bytes when necessary */
X  FMT_SPRINT_BUFSIZ = 1024	/* bytes */
X};
X
Xtypedef char* (*Alloc)(char *, SIZE_T);
X
Xtypedef struct Format Format;
Xtypedef int (*Fmtconv)(Format *, int);
X
Xstruct Format {
X	/* for the formatting routines */
X	va_list args;
X	long flags, f1, f2;
X	Fmtconv* fmttab;
X	/* for the buffer maintainence routines */
X	char *buf, *bufbegin, *bufend;
X	int flushed;
X	int (*grow)(Format *, SIZE_T);
X	int error;
X	int reqlen;
X	union { int n; void *p; } u;
X	/* for the sake of reentrancy */
X	void* client_data;
X};
X
X/* Format->flags values */
Xenum {
X	FMT_long	= (1<<0),	/* %l */
X	FMT_short	= (1<<1),	/* %h */
X	FMT_unsigned	= (1<<2),	/* %u */
X	FMT_zeropad	= (1<<3),	/* %0 */
X	FMT_leftside	= (1<<4),	/* %- */
X	FMT_altform	= (1<<5),	/* %# */
X	FMT_f1set	= (1<<6),	/* %<n> */
X	FMT_f2set	= (1<<7)	/* %.<n> */
X};
X
Xextern int fmtputc(Format *f, const char c);
Xextern int fmtappend(Format *format, const char *s, SIZE_T len);
Xextern int fmtcat(Format *format, const char *s);
Xextern Fmtconv fmtinstall(int c, Fmtconv f);
Xextern int fmtengine(Format *format, const char *fmt);
Xextern int fmtprint(Format *format, const char *fmt,...);
Xextern int fmt_fprint_flush (Format *format, SIZE_T more);
Xextern int vfprint(int fd, const char *fmt, va_list ap);
Xextern int fprint(int fd, const char *fmt,...);
Xextern int print(const char *fmt,...);
Xextern int eprint(const char *fmt,...);
Xextern char *fmt_memprint (Format *format, const char *fmt, SIZE_T* len);
Xextern int fmt_memprint_grow (Format *format, SIZE_T more);
Xextern char *vsmprint (Alloc a, SIZE_T* len, const char* fmt, va_list ap);
Xextern char *smprint (Alloc alloc, SIZE_T* len, const char* fmt, ...);
Xextern int fmt_snprint_grow (Format *format, SIZE_T more);
Xextern char* palloc (char* p, SIZE_T size);
Xextern char *mprint(const char *fmt,...);
Xextern int vsnprint(char *buf, int buflen, const char *fmt, va_list ap);
Xextern int snprint(char *buf, int buflen, const char *fmt,...);
Xextern int sprint(char *buf, const char *fmt,...);
X
Xextern int print_inaddr_conv (Format*, int);
Xextern int print_cquote_conv (Format*, int);
Xextern int print_rcquote_conv (Format*, int);
X
Xextern void fmt_install_runeconv ();
X
X#endif /* __nicer_print_h */
END_OF_FILE
if test 2672 -ne `wc -c <'print.h'`; then
    echo shar: \"'print.h'\" unpacked with wrong size!
fi
# end of 'print.h'
fi
if test -f 'rune.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rune.h'\"
else
echo shar: Extracting \"'rune.h'\" \(1536 characters\)
sed "s/^X//" >'rune.h' <<'END_OF_FILE'
X#ifndef __rune_h
X#define __rune_h
X
X/* 
X * The authors of this software are Rob Pike and Howard Trickey.
X * 		Copyright (c) 1992 by AT&T.
X * Permission to use, copy, modify, and distribute this software for any
X * purpose without fee is hereby granted, provided that this entire notice
X * is included in all copies of any software which is or includes a copy
X * or modification of this software and in all copies of the supporting
X * documentation for such software.
X * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
X * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&T MAKE ANY
X * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
X * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
X */
X
X/* Copyright (c) 1992 AT&T - All rights reserved. */
X
X	/* Plan 9 C library interface */
X
X
Xtypedef	unsigned short		Rune;
X
Xenum
X{
X	UTFmax		= 3,		/* maximum bytes per rune */
X	Runesync	= 0x80,		/* cannot represent part of a utf sequence (<) */
X	Runeself	= 0x80,		/* rune and utf sequences are the same (<) */
X	Runeerror	= 0x80		/* decoding error in utf */
X};
X
X/*
X * new rune routines
X */
Xextern	int	runetochar(char*, const Rune*);
Xextern	int	chartorune(Rune*, const char*);
Xextern	int	runelen(long);
Xextern	int	fullrune(const char*, const int);
X
X/*
X * rune routines from converted str routines
X */
Xextern	long	utflen(const char*);		/* was countrune */
Xextern	char*	utfrune(char*, const long);
Xextern	char*	utfrrune(char*, const long);
Xextern	char*	utfutf(const char*, const char*);
X
X#endif
END_OF_FILE
if test 1536 -ne `wc -c <'rune.h'`; then
    echo shar: \"'rune.h'\" unpacked with wrong size!
fi
# end of 'rune.h'
fi
if test -f 'makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile'\"
else
echo shar: Extracting \"'makefile'\" \(1315 characters\)
sed "s/^X//" >'makefile' <<'END_OF_FILE'
XDEST=/usr/local	# /{lib,man,include}
X
XCC=gcc
X#CFLAGS=-fkeep-inline-functions -O2 -g -Wall
XCFLAGS=-O2 -g -Wall
XPIC=-fpic
X
X#CC=acc
X#CFLAGS=-O2
X#PIC=-pic
X
XLDFLAGS=-L. -lprint
XREV=1.1
X
XCO=co
XCOFLAGS=
X
XSRC=print.c mprint.c conv.c runeconv.c rune.c
XOBJ=print.o mprint.o conv.o runeconv.o rune.o
XHDR=print.h rune.h
XMAN=print.3
XLIB=libprint.a libprint.so.$(REV)
X
Xall: $(LIB) test
X
XT=t1 t2 t3 t4 t5 t6 t7 t8
Xtest: $(T)
X$(T): $(LIB)
X
Xlibprint.a: $(OBJ)
X	$(AR) rcv libprint.a $(OBJ)
X	ranlib libprint.a
X
Xlibprint.so.$(REV): shared $(OBJ)
X	cd shared; ld -assert pure-text $(OBJ) -o ../$@
X
XCOPYRIGHT: print.3
X	sed -e '/COPYRIGHT/,$$p' -e d <print.3 >COPYRIGHT
X
Xinstall:
X	install -m 644 libprint.so.$(REV) $(DEST)/lib
X	install -m 644 libprint.a $(DEST)/lib
X	ranlib  -t $(DEST)/lib/libprint.a
X	install -m 644 $(MAN) $(DEST)/man/man3
X	install -m 644 print.h $(DEST)/include
Xclean:
X	delete -f *.o a.out *.a *.s *.so.* t? *~ shared/*
Xdepend:
X	gcc -MM $(CFLAGS) $(SRC) >.depend
Xshar:
X	shar COPYRIGHT blurb $(MAN) $(SRC) $(HDR) makefile .depend t*.c >print.shar
X
Xshared:
X	mkdir shared
X
X%.o: %.c
X	rm -f $*.o shared/$*.o
X	$(CC) $(CFLAGS) $(PIC) -c $< && mv $*.o shared
X	$(CC) $(CFLAGS) -c $<
X%.s: %.c
X	$(CC) $(CFLAGS) -S -c $<
X%: %.c
X	$(CC) $(CFLAGS) $< -o $@ $(LDFLAGS)
X%:: RCS/%,v
X	test -f $@ || $(CO) $(COFLAGS) $< $@
X
Xinclude .depend
END_OF_FILE
if test 1315 -ne `wc -c <'makefile'`; then
    echo shar: \"'makefile'\" unpacked with wrong size!
fi
# end of 'makefile'
fi
if test -f '.depend' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'.depend'\"
else
echo shar: Extracting \"'.depend'\" \(145 characters\)
sed "s/^X//" >'.depend' <<'END_OF_FILE'
Xprint.o : print.c print.h 
Xmprint.o : mprint.c print.h 
Xconv.o : conv.c print.h 
Xruneconv.o : runeconv.c print.h rune.h 
Xrune.o : rune.c rune.h 
END_OF_FILE
if test 145 -ne `wc -c <'.depend'`; then
    echo shar: \"'.depend'\" unpacked with wrong size!
fi
# end of '.depend'
fi
if test -f 't1.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'t1.c'\"
else
echo shar: Extracting \"'t1.c'\" \(2633 characters\)
sed "s/^X//" >'t1.c' <<'END_OF_FILE'
X#include <errno.h>
X#include <netdb.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/time.h>
X#include <sys/resource.h>
X#include <netinet/in.h>
X#include <arpa/inet.h>
X
X#include "print.h"
X
Xextern int print_inaddr_conv(Format*,int);
X
Xchar junk[9000];
X
Xvoid main(int argc, char**argv)
X{
X  struct in_addr* in = 0;
X  struct rlimit rl;
X  long int i, j;
X  unsigned long int u;
X  short int h;
X  unsigned short int uh;
X
X  fmtinstall('I', print_inaddr_conv);
X
X  if (argc > 1) {
X      rl.rlim_cur = rl.rlim_max = 1024 * atoi(argv[1]);
X      if (setrlimit (RLIMIT_DATA,&rl) < 0)
X	  eprint("setrlimit: %r");
X  }
X  
X  for (i = 0; i < sizeof(junk); ++i) 
X    junk[i] = (i&63) + ' ';
X  junk[sizeof(junk) - 1] = 0;
X
X  /* print nuls */
X  print ("%c%c\n", 0, 0);
X
X  /* test badconv */
X  print ("%Z", 0);
X
X  /* integers */
X  print("%d %#xd %0d %10.5d\n", 3,4,5,6);
X
X  /* nconv */
X  print ("%s\n%n", "foo", &i);
X  print ("len=%d\n", i);
X
X  /* print ip quads */
X  { struct hostent* h;
X    for (h = gethostbyname ("globin.cse.psu.edu"); 
X	h && *h->h_addr_list; h->h_addr_list++) {
X      in = (struct in_addr*) *h->h_addr_list;
X      print("g=%#ux [%I]\n", in->s_addr, in);
X    }
X  }
X
X  /* print errno */
X  for (errno = 0; errno < 10; ++errno) {
X    i = print("error %#r: %r");
X    print(" (%d)\n", i);
X  }
X  errno = 345; i = print("error %#r: %r"); print(" (%d)\n", i);
X
X
X  /* indirect field specs */
X  for (i = 0; i < 10; ++i)
X	for (j = 0; j < 5; ++j)
X		print ("%*.*s\n", i, j, "12345");
X
X  for (i = 0; i < 10; ++i)
X	for (j = 0; j < 10; ++j)
X		print ("%*.*d\n", i, j, 12345);
X
X  /* short conversions */
X  uh = 55555;  h = -12345;
X  print("-12345 %hd\n55555 %uhd\n", h, uh);
X
X  h = 32766; print("32766 %hd\n", h);
X  h = 32767; print("32767 %hd\n", h);
X  h = 32768; print("32768 %hd\n", h);
X  h = 32769; print("32769 %hd\n", h);
X  
X  uh = 32766; print("32766 %uhd\n", uh);
X  uh = 32767; print("32767 %uhd\n", uh);
X  uh = 32768; print("32768 %uhd\n", uh);
X  uh = 32769; print("32769 %uhd\n", uh);
X
X  h = -3; print("-3 %hd\n", h);
X  h = -2; print("-2 %hd\n", h);
X  h = -1; print("-1 %hd\n", h);
X  h = -0; print("-0 %hd\n", h);
X
X  uh = -3; print("-3 %hd\n", uh);
X  uh = -2; print("-2 %hd\n", uh);
X  uh = -1; print("-1 %hd\n", uh);
X  uh = -0; print("-0 %hd\n", uh);
X
X  i = fprint(1, "junk=%s\n", junk);
X
X  /* force extra memory allocations */
X  print(">>> %s\n", 
X	smprint(palloc, (SIZE_T*)&i,
X		"%d %s %s %s %I %d %r\n", 
X		strlen(junk), junk, "\n===\n", "\n---\n", in, 12312) );
X  print("rc=%d %r\n", i);
X
X  i = fprint(1, "!!! %d %s %s %s %I %d %r\n", 
X	 strlen(junk), junk, "\n===\n", "\n---\n", in, 12312);
X  print("rc=%d\n", i);
X  _exit(0);
X}
END_OF_FILE
if test 2633 -ne `wc -c <'t1.c'`; then
    echo shar: \"'t1.c'\" unpacked with wrong size!
fi
# end of 't1.c'
fi
if test -f 't2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'t2.c'\"
else
echo shar: Extracting \"'t2.c'\" \(539 characters\)
sed "s/^X//" >'t2.c' <<'END_OF_FILE'
X#include "print.h"
X
Xint main()
X{
X    char buf[32];
X    int i;
X
X    i = snprint (buf, sizeof buf, "%z123456789012345678901234567890");
X    print ("snprint (%s) -> %d\n", buf, i);
X
X    i = snprint (buf, sizeof buf, "123456789012345678901234567890");
X    print ("snprint (%s) -> %d\n", buf, i);
X
X    i = snprint (buf, sizeof buf, "1234567890123456789012345678901");
X    print ("snprint (%s) -> %d\n", buf, i);
X
X    i = snprint (buf, sizeof buf, "12345678901234567890123456789012");
X    print ("snprint (%s) -> %d\n", buf, i);
X
X    exit(0);
X}
END_OF_FILE
if test 539 -ne `wc -c <'t2.c'`; then
    echo shar: \"'t2.c'\" unpacked with wrong size!
fi
# end of 't2.c'
fi
if test -f 't3.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'t3.c'\"
else
echo shar: Extracting \"'t3.c'\" \(2848 characters\)
sed "s/^X//" >'t3.c' <<'END_OF_FILE'
X#include <time.h>
X#include "print.h"
X
Xvoid free (void*);
X
XFmtconv date_tab[FMT_MAXCONV];
X
X/* XXX - expose these things from print.c? */
X
Xstatic int badconv (Format *format, int c) {
X    eprint ("dateconv: bad conversion char '%c'\n", c);
X    format->error = 1;
X    return FMT_verb;
X}
X
Xstatic int litconv (Format *format, int c) {
X    fmtputc (format, c);
X    return FMT_verb;
X}
X
X/* XXX - expose intconv() instead? */
X
Xstatic void put_int02 (Format* format, int i)
X{
X    Fmtconv* save = format->fmttab;
X    format->fmttab = 0;
X    fmtprint (format, "%02d", i);
X    format->fmttab = save;
X}
X
Xstatic int dconv (Format *format, int c)
X{
X    struct tm* tm = (struct tm*) format->client_data;
X    put_int02 (format, tm->tm_mday);
X    return FMT_verb ;
X}
X
Xstatic int mconv (Format *format, int c)
X{
X    struct tm* tm = (struct tm*) format->client_data;
X    put_int02 (format, tm->tm_mon+1);
X    return FMT_verb ;
X}
X
Xstatic int yconv (Format *format, int c)
X{
X    struct tm* tm = (struct tm*) format->client_data;
X    put_int02 (format, tm->tm_year);
X    return FMT_verb ;
X}
X
Xstatic int Dconv (Format *format, int c)
X{
X    fmtprint (format, "%m/%d/%y");
X    return FMT_verb ;
X}
X
Xstatic int Hconv (Format *format, int c)
X{
X    struct tm* tm = (struct tm*) format->client_data;
X    put_int02 (format, tm->tm_hour);
X    return FMT_verb ;
X}
X
Xstatic int Mconv (Format *format, int c)
X{
X    struct tm* tm = (struct tm*) format->client_data;
X    put_int02 (format, tm->tm_min);
X    return FMT_verb ;
X}
X
Xstatic int Sconv (Format *format, int c)
X{
X    struct tm* tm = (struct tm*) format->client_data;
X    put_int02 (format, tm->tm_sec);
X    return FMT_verb ;
X}
X
Xstatic int Tconv (Format *format, int c)
X{
X    fmtprint (format, "%H:%M:%S");
X    return FMT_verb ;
X}
X
Xstatic void init_date_tab ()
X{
X    int i;
X    Fmtconv* fmttab = date_tab;
X
X    for (i = 0; i < FMT_MAXCONV; i++)
X	fmttab[i] = badconv;
X
X    fmttab['%'] = litconv;
X
X    fmttab['d'] = dconv;	/* day of month */
X    fmttab['m'] = mconv;	/* month */
X    fmttab['y'] = yconv;	/* year */
X    fmttab['D'] = Dconv;	/* %m/%d/%y */
X
X    fmttab['H'] = Hconv;	/* hour */
X    fmttab['M'] = Mconv;	/* min */
X    fmttab['S'] = Sconv;	/* sec */
X    fmttab['T'] = Tconv;	/* %H:%M:%S */
X}
X
Xchar* format_date (time_t clock, char* fmt)
X{
X    struct tm tm = *gmtime (&clock);
X    Format format;
X  
X    format.buf      = 0;
X    format.bufbegin = 0;
X    format.bufend   = 0;
X    format.flushed  = 0;
X    format.error    = 0;
X
X    format.args     = 0;
X    format.u.p      = (void*)palloc;
X    format.grow     = fmt_memprint_grow;
X    format.fmttab   = date_tab;
X    format.client_data = &tm;
X
X    if (date_tab[0] == 0)
X	init_date_tab ();
X
X    return fmt_memprint (&format, fmt, 0);
X}
X
Xint main ()
X{
X    char* ds = format_date (time(0), "%% the date is %D at time %T");
X    print ("%s\n", ds);
X    free (ds);
X    return 0;
X}
END_OF_FILE
if test 2848 -ne `wc -c <'t3.c'`; then
    echo shar: \"'t3.c'\" unpacked with wrong size!
fi
# end of 't3.c'
fi
if test -f 't4.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'t4.c'\"
else
echo shar: Extracting \"'t4.c'\" \(247 characters\)
sed "s/^X//" >'t4.c' <<'END_OF_FILE'
X#include "print.h"
X
Xint main()
X{
X    fmtinstall ('Q', print_cquote_conv);
X    fmtinstall ('R', print_rcquote_conv);
X
X    print ("\"%Q\"\n", "\001\002\200\127abcde\nend\n");
X    print ("'%R'\n", "this can't be and isn't either\n");
X    exit (0);
X}
END_OF_FILE
if test 247 -ne `wc -c <'t4.c'`; then
    echo shar: \"'t4.c'\" unpacked with wrong size!
fi
# end of 't4.c'
fi
if test -f 't5.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'t5.c'\"
else
echo shar: Extracting \"'t5.c'\" \(162 characters\)
sed "s/^X//" >'t5.c' <<'END_OF_FILE'
X
X#include "print.h"
X
Xint main()
X{
X    int i;
X    char ch;
X
X    for (i=0; i<256; ++i) {
X	ch = i;
X        print ("%o %o %03uo\n", i, ch, ch);
X    }
X    exit (0);
X}
END_OF_FILE
if test 162 -ne `wc -c <'t5.c'`; then
    echo shar: \"'t5.c'\" unpacked with wrong size!
fi
# end of 't5.c'
fi
if test -f 't6.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'t6.c'\"
else
echo shar: Extracting \"'t6.c'\" \(433 characters\)
sed "s/^X//" >'t6.c' <<'END_OF_FILE'
X#include "print.h"
X#include "rune.h"
X
XRune stupid[] = {945,946,947,948,0};
X
Xint 
Xmain(int c, char **v){
X/*	Rune r = L'α';*/
X	Rune r = 945;
X
X	fmt_install_runeconv ();
X	for (r = 945; r<945+26;r++)
X		fprint(2, "%C%C\n", r,r);
X	fprint(2, "'%S'\n", stupid);
X	fprint(2, "'%.2S'\n", stupid);
X	fprint(2, "'%10.10S'\n", stupid);
X	fprint(2, "'%10.10s'\n", "abcd");
X	fprint(2, "'%-10.10S'\n",stupid);
X	fprint(2, "%S\n", (Rune)0);
X	return 0;
X}
END_OF_FILE
echo shar: 2 control characters may be missing from \"'t6.c'\"
if test 433 -ne `wc -c <'t6.c'`; then
    echo shar: \"'t6.c'\" unpacked with wrong size!
fi
# end of 't6.c'
fi
if test -f 't7.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'t7.c'\"
else
echo shar: Extracting \"'t7.c'\" \(239 characters\)
sed "s/^X//" >'t7.c' <<'END_OF_FILE'
X
X#include "print.h"
X
Xint main()
X{
X    char junk[] = "abcdefghijklmnopqrstuvwzyz";
X    int jsize = sizeof junk;
X    int width = jsize + 5;
X    print("%*.*s\n", width, jsize, junk);
X    print("%#*.*s\n", width, jsize, junk);
X    exit (0);
X}
END_OF_FILE
if test 239 -ne `wc -c <'t7.c'`; then
    echo shar: \"'t7.c'\" unpacked with wrong size!
fi
# end of 't7.c'
fi
if test -f 't8.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'t8.c'\"
else
echo shar: Extracting \"'t8.c'\" \(103 characters\)
sed "s/^X//" >'t8.c' <<'END_OF_FILE'
X#include <print.h>
X
Xint main(int argc, char** argv)
X{
X    fprint(-1, "terminate\r\n");
X    return 0;
X}
END_OF_FILE
if test 103 -ne `wc -c <'t8.c'`; then
    echo shar: \"'t8.c'\" unpacked with wrong size!
fi
# end of 't8.c'
fi
echo shar: End of shell archive.
exit 0
