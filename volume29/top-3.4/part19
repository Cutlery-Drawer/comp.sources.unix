Newsgroups: comp.sources.unix
From: wnl@groupsys.com (William Lefebvre)
Subject: v29i120: top-3.4 - top process display, V3.4, Part19/22
References: <1.841608857.22962@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: wnl@groupsys.com (William Lefebvre)
Posting-Number: Volume 29, Issue 120
Archive-Name: top-3.4/part19

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 19 (of 22)."
# Contents:  top-3.4/machine/m_decosf1.c top-3.4/machine/m_netbsd10.c
# Wrapped by lefebvre@acapulco on Fri Aug 30 12:35:52 1996
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'top-3.4/machine/m_decosf1.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'top-3.4/machine/m_decosf1.c'\"
else
echo shar: Extracting \"'top-3.4/machine/m_decosf1.c'\" \(23295 characters\)
sed "s/^X//" >'top-3.4/machine/m_decosf1.c' <<'END_OF_FILE'
X/*
X * top - a top users display for Unix
X *
X * SYNOPSIS:  DEC Alpha AXP running OSF/1 or Digital Unix 4.0.
X *
X * DESCRIPTION:
X * This is the machine-dependent module for DEC OSF/1 
X * It is known to work on OSF/1 1.2, 1.3, 2.0-T3, 3.0, and Digital Unix V4.0
X * WARNING: if you use optimization with the standard "cc" compiler that
X * .        comes with V3.0 the resulting executable may core dump.  If
X * .        this happens, recompile without optimization.
X *
X * LIBS: -lmld -lmach
X *
X * CFLAGS: -DHAVE_GETOPT
X *
X * AUTHOR:  Anthony Baxter, <anthony@aaii.oz.au>
X * Derived originally from m_ultrix, by David S. Comay <dsc@seismo.css.gov>, 
X * although by now there is hardly any of the code from m_ultrix left.
X * Helped a lot by having the source for syd(1), by Claus Kalle, and
X * from several people at DEC who helped with providing information on
X * some of the less-documented bits of the kernel interface.
X *
X * Modified: 31-Oct-94, Pat Welch, tpw@physics.orst.edu
X *	changed _mpid to pidtab for compatibility with OSF/1 version 3.0
X *
X * Modified: 13-Dec-94, William LeFebvre, lefebvre@dis.anl.gov
X *	removed used of pidtab (that was bogus) and changed things to
X *	automatically detect the absence of _mpid in the nlist and
X *	recover gracefully---this appears to be the only difference
X *	with 3.0.
X */
X/* 
X * $Id: m_decosf1.c,v 1.14 1994/01/18 07:34:42 anthony Exp $
X * Theres some real icky bits in this code - you have been warned :)
X * Extremely icky bits are marked with FIXME: 
X *
X * Theory of operation: 
X * 
X * Use Mach calls to build up a structure that contains all the sorts
X * of stuff normally found in a struct proc in a BSD system. Then
X * everything else uses this structure. This has major performance wins,
X * and also should work for future versions of the O/S.
X */
X
X#include <sys/types.h>
X#include <sys/signal.h>
X#include <sys/param.h>
X
X#include <string.h>
X#include <sys/user.h>
X#include <stdio.h>
X#include <nlist.h>
X#include <math.h>
X#include <sys/dir.h>
X#include <sys/user.h>
X#include <sys/proc.h>
X#include <sys/dk.h>
X#include <sys/vm.h>
X#include <sys/file.h>
X#include <sys/time.h>
X/* #include <machine/pte.h> */
X#include <sys/table.h>
X#include <mach.h>
X#include <mach/mach_types.h>
X#include <mach/vm_statistics.h>
X#include <sys/syscall.h> /* for SYS_setpriority, in setpriority(), below */
X
X
X#include "top.h"
X#include "machine.h"
X
Xextern int errno, sys_nerr;
Xextern char *sys_errlist[];
X#define strerror(e) (((e) >= 0 && (e) < sys_nerr) ? sys_errlist[(e)] : "Unknown error")
X
X#define VMUNIX	"/vmunix"
X#define KMEM	"/dev/kmem"
X#define MEM	"/dev/mem"
X
X/* get_process_info passes back a handle.  This is what it looks like: */
X
Xstruct handle
X{
X    struct osf1_top_proc **next_proc;	/* points to next valid proc pointer */
X    int remaining;		/* number of pointers remaining */
X};
X
X/* declarations for load_avg */
X#include "loadavg.h"
X
X/* definitions for indices in the nlist array */
X#define X_MPID		0
X
Xstatic struct nlist nlst[] = {
X    { "_mpid" },		/* 0 */
X    { 0 }
X};
X
X/* Some versions of OSF/1 don't support reporting of the last PID.
X   This flag indicates whether or not we are reporting the last PID. */
Xstatic int do_last_pid = 1;
X
X/*
X *  These definitions control the format of the per-process area
X */
X
Xstatic char header[] =
X  "  PID X        PRI NICE  SIZE   RES STATE   TIME    CPU COMMAND";
X/* 0123456   -- field to fill in starts at header+6 */
X#define UNAME_START 6
X
X#define Proc_format \
X	"%5d %-8.8s %3d %4d %5s %5s %-5s %-6s %5.2f%% %.14s"
X
X
X/* process state names for the "STATE" column of the display */
X/* the extra nulls in the string "run" are for adding a slash and
X * the processor number when needed. Although OSF/1 doesnt support
X * multiple processors yet, (and this module _certainly_ doesnt
X * support it, either, we may as well plan for the future. :-)
X */
X
Xchar *state_abbrev[] =
X{
X    "", "run\0\0\0", "WAIT", "sleep", "sleep", "stop", "halt", "???", "zomb"
X};
X
X
Xstatic int kmem, mem;
X
X/* values that we stash away in _init and use in later routines */
X
Xstatic double logcpu;
X
X/* these are retrieved from the kernel in _init */
X
Xstatic unsigned long proc;
Xstatic          int  nproc;
Xstatic load_avg  ccpu;
X
Xtypedef long mtime_t;
X
X/* these are offsets obtained via nlist and used in the get_ functions */
X
Xstatic unsigned long mpid_offset;
X
X/* these are for detailing the process states */
X
Xint process_states[9];
Xchar *procstatenames[] = {
X    "", " running, ", " waiting, ", " sleeping, ", " idle, ",
X    " stopped, ", " halted, ", "", " zombie",
X    NULL
X};
X
X/* these are for detailing the cpu states */
X
Xint cpu_states[4];
Xchar *cpustatenames[] = {
X    "user", "nice", "system", "idle", NULL
X};
X
Xlong old_cpu_ticks[4];
X
X/* these are for detailing the memory statistics */
X
Xint memory_stats[8];
Xchar *memorynames[] = {
X    "Real: ", "K/", "K act/tot  ", "Virtual: ", "M/",
X    "M use/tot  ", "Free: ", "K", NULL
X};
X
X/* these are for getting the memory statistics */
X
Xstatic int pageshift;		/* log base 2 of the pagesize */
X
X/* define pagetok in terms of pageshift */
X
X#define pagetok(size) ((size) << pageshift)
X
X/* take a process, make it a mach task, and grab all the info out */
Xvoid do_threads_calculations();
X
X/*
X * Because I dont feel like repeatedly grunging through the kernel with
X * Mach calls, and I also dont want the horrid performance hit this
X * would give, I read the stuff I need out, and put in into my own
X * structure, for later use.
X */
X
Xstruct osf1_top_proc {
X    size_t p_mach_virt_size;
X    char p_mach_state;
X    fixpt_t p_mach_pct_cpu; /* aka p_pctcpu */
X    int used_ticks;
X    size_t process_size;
X    pid_t p_pid;
X    uid_t p_ruid;
X    char p_pri;
X    char p_nice;
X    size_t p_rssize;
X    char u_comm[PI_COMLEN + 1];
X} ;
X
X/* these are for keeping track of the proc array */
X
Xstatic int bytes;
Xstatic int pref_len;
Xstatic struct osf1_top_proc *pbase;
Xstatic struct osf1_top_proc **pref;
X
X/* useful externals */
Xextern int errno;
Xextern char *sys_errlist[];
X
Xlong percentages();
X
Xmachine_init(statics)
Xstruct statics *statics;
X{
X    register int i = 0;
X    register int pagesize;
X    struct tbl_sysinfo sibuf;
X
X    if ((kmem = open(KMEM, O_RDONLY)) == -1) {
X	perror(KMEM);
X	return(-1);
X    }
X    if ((mem = open(MEM, O_RDONLY)) == -1) {
X	perror(MEM);
X	return(-1);
X    }
X
X    /* get the list of symbols we want to access in the kernel */
X    if (nlist(VMUNIX, nlst) == -1)
X    {
X	perror("TOP(nlist)");
X	return (-1);
X    }
X
X    if (nlst[X_MPID].n_type == 0)
X    {
X	/* this kernel has no _mpid, so go without */
X	do_last_pid = 0;
X    }
X    else
X    {
X	/* stash away mpid pointer for later use */
X	mpid_offset = nlst[X_MPID].n_value;
X    }
X
X    /* get the symbol values out of kmem */
X    nproc  = table(TBL_PROCINFO, 0, (struct tbl_procinfo *)NULL, INT_MAX, 0);
X
X    /* allocate space for proc structure array and array of pointers */
X    bytes = nproc * sizeof(struct osf1_top_proc);
X    pbase = (struct osf1_top_proc *)malloc(bytes);
X    pref  = (struct osf1_top_proc **)malloc(nproc * 
X                                              sizeof(struct osf1_top_proc *));
X
X    /* Just in case ... */
X    if (pbase == (struct osf1_top_proc *)NULL || 
X                                  pref == (struct osf1_top_proc **)NULL)
X    {
X	fprintf(stderr, "top: cannot allocate sufficient memory\n");
X	return(-1);
X    }
X
X    /* get the page size with "getpagesize" and calculate pageshift from it */
X    pagesize = getpagesize();
X    pageshift = 0;
X    while (pagesize > 1)
X    {
X	pageshift++;
X	pagesize >>= 1;
X    }
X
X    /* we only need the amount of log(2)1024 for our conversion */
X    pageshift -= LOG1024;
X
X    /* fill in the statics information */
X    statics->procstate_names = procstatenames;
X    statics->cpustate_names = cpustatenames;
X    statics->memory_names = memorynames;
X
X    /* initialise this, for calculating cpu time */
X    if (table(TBL_SYSINFO,0,&sibuf,1,sizeof(struct tbl_sysinfo))<0) {
X	perror("TBL_SYSINFO");
X	return(-1);
X    }
X    old_cpu_ticks[0] = sibuf.si_user;
X    old_cpu_ticks[1] = sibuf.si_nice;
X    old_cpu_ticks[2] = sibuf.si_sys;
X    old_cpu_ticks[3] = sibuf.si_idle;
X
X    /* all done! */
X    return(0);
X}
X
Xchar *format_header(uname_field)
Xregister char *uname_field;
X{
X    register char *ptr;
X
X    ptr = header + UNAME_START;
X    while (*uname_field != '\0')
X    {
X	*ptr++ = *uname_field++;
X    }
X
X    return(header);
X}
X
Xget_system_info(si)
Xstruct system_info *si;
X{
X    struct tbl_loadavg labuf;
X    struct tbl_sysinfo sibuf;
X    struct tbl_swapinfo swbuf;
X    vm_statistics_data_t vmstats;
X    int swap_pages=0,swap_free=0,i;
X    long new_ticks[4],diff_ticks[4];
X    long delta_ticks;
X
X    if (do_last_pid)
X    {
X	/* last pid assigned */
X	(void) getkval(mpid_offset, &(si->last_pid), sizeof(si->last_pid), 
X		       "_mpid");
X    }
X    else
X    {
X	si->last_pid = -1;
X    }
X
X    /* get load averages */
X    if (table(TBL_LOADAVG,0,&labuf,1,sizeof(struct tbl_loadavg))<0) {
X	perror("TBL_LOADAVG");
X	return(-1);
X    }
X    if (labuf.tl_lscale)   /* scaled */
X	for(i=0;i<3;i++) 
X	    si->load_avg[i] = ((double)labuf.tl_avenrun.l[i] / 
X                                            (double)labuf.tl_lscale );
X    else                   /* not scaled */
X	for(i=0;i<3;i++) 
X	    si->load_avg[i] = labuf.tl_avenrun.d[i];
X
X    /* array of cpu state counters */
X    if (table(TBL_SYSINFO,0,&sibuf,1,sizeof(struct tbl_sysinfo))<0) {
X	perror("TBL_SYSINFO");
X	return(-1);
X    }
X    new_ticks[0] = sibuf.si_user ; new_ticks[1] = sibuf.si_nice;
X    new_ticks[2] = sibuf.si_sys  ; new_ticks[3] = sibuf.si_idle;
X    delta_ticks=0;
X    for(i=0;i<4;i++) {
X	diff_ticks[i] = new_ticks[i] - old_cpu_ticks[i];
X	delta_ticks += diff_ticks[i];
X	old_cpu_ticks[i] = new_ticks[i];
X    }
X    si->cpustates = cpu_states;
X    if(delta_ticks)
X	for(i=0;i<4;i++) 
X	    si->cpustates[i] = (int)( ( (double)diff_ticks[i] / 
X                                           (double)delta_ticks ) * 1000 );
X    
X    /* memory information */
X    /* this is possibly bogus - we work out total # pages by */
X    /* adding up the free, active, inactive, wired down, and */
X    /* zero filled. Anyone who knows a better way, TELL ME!  */
X    /* Change: dont use zero filled. */
X    (void) vm_statistics(task_self(),&vmstats);
X
X    /* thanks DEC for the table() command. No thanks at all for   */
X    /* omitting the man page for it from OSF/1 1.2, and failing   */
X    /* to document SWAPINFO in the 1.3 man page. Lets hear it for */
X    /* include files. */
X    i=0;
X    while(table(TBL_SWAPINFO,i,&swbuf,1,sizeof(struct tbl_swapinfo))>0) {
X	swap_pages += swbuf.size;
X	swap_free  += swbuf.free;
X	i++;
X    }
X    memory_stats[0] = -1;
X    memory_stats[1] = pagetok(vmstats.active_count);
X    memory_stats[2] = pagetok((vmstats.free_count + vmstats.active_count +
X	vmstats.inactive_count + vmstats.wire_count));
X    memory_stats[3] = -1;
X    memory_stats[4] = pagetok((swap_pages - swap_free))/1024;
X    memory_stats[5] = pagetok(swap_pages)/1024;
X    memory_stats[6] = -1;
X    memory_stats[7] = pagetok(vmstats.free_count);
X    si->memory = memory_stats;
X}
X
Xstatic struct handle handle;
X
Xcaddr_t get_process_info(si, sel, compare)
Xstruct system_info *si;
Xstruct process_select *sel;
Xint (*compare)();
X{
X    register int i;
X    register int total_procs;
X    register int active_procs;
X    register struct osf1_top_proc **prefp;
X    register struct osf1_top_proc *pp;
X    struct tbl_procinfo p_i[8];
X    int j,k,r;
X
X    /* these are copied out of sel for speed */
X    int show_idle;
X    int show_system;
X    int show_uid;
X    int show_command;
X
X    /* get a pointer to the states summary array */
X    si->procstates = process_states;
X
X    /* set up flags which define what we are going to select */
X    show_idle = sel->idle;
X    show_system = sel->system;
X    show_uid = sel->uid != -1;
X    show_command = sel->command != NULL;
X
X    /* count up process states and get pointers to interesting procs */
X    total_procs = 0;
X    active_procs = 0;
X    memset((char *)process_states, 0, sizeof(process_states));
X    process_states[0]=0;
X    process_states[1]=0;
X    process_states[2]=0;
X    process_states[3]=0;
X    process_states[4]=0;
X    process_states[5]=0;
X    process_states[6]=0;
X    prefp = pref;
X    pp=pbase;
X    for (j=0; j<nproc; j += 8) 
X    {
X	r = table(TBL_PROCINFO, j, (struct tbl_procinfo *)p_i, 8, 
X                                               sizeof(struct tbl_procinfo));
X	for (k=0; k < r; k++ , pp++) 
X	{
X	    if(p_i[k].pi_pid == 0) 
X	    {
X		pp->p_pid = 0;
X	    }
X	    else
X	    {
X		pp->p_pid = p_i[k].pi_pid;
X		pp->p_ruid = p_i[k].pi_ruid;
X		pp->p_nice = getpriority(PRIO_PROCESS,p_i[k].pi_pid);
X		/* Load useful values into the proc structure */
X		do_threads_calculations(pp);
X		/*
X		 *  Place pointers to each valid proc structure in pref[].
X		 *  Process slots that are actually in use have a non-zero
X		 *  status field.  Processes with SSYS set are system
X		 *  processes---these get ignored unless show_sysprocs is set.
X		 */
X		if (pp->p_mach_state != 0)
X		{
X		    total_procs++;
X		    process_states[pp->p_mach_state]++;
X		    if ((pp->p_mach_state != SZOMB) &&
X			(pp->p_mach_state != SIDL) &&
X			(show_idle || (pp->p_mach_pct_cpu != 0) || 
X                                   (pp->p_mach_state == SRUN)) &&
X			(!show_uid || pp->p_ruid == (uid_t)sel->uid)) {
X			*prefp++ = pp;
X			active_procs++;
X		    }
X		}
X	    }
X	}
X    }
X
X    /* if requested, sort the "interesting" processes */
X    if (compare != NULL)
X    {
X	qsort((char *)pref, active_procs, sizeof(struct osf1_top_proc *), 
X                                                                    compare);
X    }
X
X    /* remember active and total counts */
X    si->p_total = total_procs;
X    si->p_active = pref_len = active_procs;
X
X    /* pass back a handle */
X    handle.next_proc = pref;
X    handle.remaining = active_procs;
X    return((caddr_t)&handle);
X}
X
Xchar fmt[128];		/* static area where result is built */
X
Xchar *format_next_process(handle, get_userid)
Xcaddr_t handle;
Xchar *(*get_userid)();
X{
X    register struct osf1_top_proc *pp;
X    register long cputime;
X    register double pct;
X    int where;
X    struct user u;
X    struct handle *hp;
X
X    /* find and remember the next proc structure */
X    hp = (struct handle *)handle;
X    pp = *(hp->next_proc++);
X    hp->remaining--;
X
X    /* get the process's user struct and set cputime */
X    
X    if (table(TBL_UAREA,pp->p_pid,&u,1,sizeof(struct user))<0) {
X    /* whoops, it must have died between the read of the proc area
X     * and now. Oh well, lets just dump some meaningless thing out
X     * to keep the rest of the program happy
X     */
X	sprintf(fmt,
X		Proc_format,
X		pp->p_pid,
X		(*get_userid)(pp->p_ruid),
X		0,
X		0,
X		"",
X		"",
X		"dead",
X		"",
X		0.0,
X		"<dead>");
X	    return(fmt);
X    }
X
X    /* set u_comm for system processes */
X    if (u.u_comm[0] == '\0')
X    {
X	if (pp->p_pid == 0)
X	{
X	    (void) strcpy(u.u_comm, "[idle]");
X	}
X	else if (pp->p_pid == 2)
X	{
X	    (void) strcpy(u.u_comm, "[execpt.hndlr]");
X	}
X    }
X    if (where == 1) {
X	/*
X	 * Print swapped processes as <pname>
X	 */
X	char buf[sizeof(u.u_comm)];
X	(void) strncpy(buf, u.u_comm, sizeof(u.u_comm));
X	u.u_comm[0] = '<';
X	(void) strncpy(&u.u_comm[1], buf, sizeof(u.u_comm) - 2);
X	u.u_comm[sizeof(u.u_comm) - 2] = '\0';
X	(void) strncat(u.u_comm, ">", sizeof(u.u_comm) - 1);
X	u.u_comm[sizeof(u.u_comm) - 1] = '\0';
X    }
X
X    cputime = u.u_ru.ru_utime.tv_sec + u.u_ru.ru_stime.tv_sec;
X
X    /* calculate the base for cpu percentages */
X    pct = pctdouble(pp->p_mach_pct_cpu);
X
X    /* format this entry */
X    sprintf(fmt,
X	    Proc_format,
X	    pp->p_pid,
X	    (*get_userid)(pp->p_ruid),
X	    pp->p_pri,
X	    pp->p_nice,
X            format_k(pp->p_mach_virt_size/1024),
X            format_k(pp->p_rssize/1000),
X	    state_abbrev[pp->p_mach_state],
X	    format_time(cputime),
X	    100.0 * ((double)pp->p_mach_pct_cpu / 10000.0),
X	    printable(u.u_comm));
X
X    /* return the result */
X    return(fmt);
X}
X
X/*
X *  getkval(offset, ptr, size, refstr) - get a value out of the kernel.
X *	"offset" is the byte offset into the kernel for the desired value,
X *  	"ptr" points to a buffer into which the value is retrieved,
X *  	"size" is the size of the buffer (and the object to retrieve),
X *  	"refstr" is a reference string used when printing error meessages,
X *	    if "refstr" starts with a '!', then a failure on read will not
X *  	    be fatal (this may seem like a silly way to do things, but I
X *  	    really didn't want the overhead of another argument).
X *  	
X */
X
Xgetkval(offset, ptr, size, refstr)
X
Xunsigned long offset;
Xint *ptr;
Xint size;
Xchar *refstr;
X
X{
X    if (lseek(kmem, (long)offset, L_SET) == -1) {
X        if (*refstr == '!')
X            refstr++;
X        (void) fprintf(stderr, "%s: lseek to %s: %s\n", KMEM, 
X		       refstr, strerror(errno));
X        quit(23);
X    }
X    if (read(kmem, (char *) ptr, size) == -1) {
X        if (*refstr == '!') 
X            return(0);
X        else {
X            (void) fprintf(stderr, "%s: reading %s: %s\n", KMEM, 
X			   refstr, strerror(errno));
X            quit(23);
X        }
X    }
X    return(1);
X}
X    
X/* comparison routine for qsort */
X
X/*
X *  proc_compare - comparison function for "qsort"
X *   Compares the resource consumption of two processes using five
X *   distinct keys. The keys (in descending order of importance) are:
X *   percent cpu, cpu ticks, state, resident set size, total virtual
X *   memory usage. The process states are ordered as follows (from least
X *   to most important): WAIT, zombie, sleep, stop, start, run. The array
X *   declaration below maps a process state index into a number that
X *   reflects this ordering.
X */
X
Xstatic unsigned char sorted_state[] =
X{
X   0, /*""*/
X   8, /*"run"*/
X   1, /*"WAIT"*/
X   6, /*"sleep"*/
X   5, /*"idle"*/
X   7, /*"stop"*/
X   4, /*"halt"*/
X   3, /*"???"*/
X   2, /*"zomb"*/
X};
X 
Xproc_compare(pp1, pp2)
X
Xstruct osf1_top_proc **pp1;
Xstruct osf1_top_proc **pp2;
X
X{
X    register struct osf1_top_proc *p1;
X    register struct osf1_top_proc *p2;
X    register int result;
X    register pctcpu lresult=0.0;
X    struct user u1, u2;
X
X    /* remove one level of indirection */
X    p1 = *pp1;
X    p2 = *pp2;
X
X    /* compare percent cpu (pctcpu) */
X    if ((lresult = p2->p_mach_pct_cpu - p1->p_mach_pct_cpu) == 0)
X    {
X	/* use process state to break the tie */
X	if ((result = sorted_state[p2->p_mach_state] -
X		  sorted_state[p1->p_mach_state])  == 0)
X	{
X	    /* use elapsed time to break the tie */
X	    if ((result = p2->used_ticks - p1->used_ticks) == 0)
X	    {
X		/* use priority to break the tie */
X		if ((result = p2->p_pri - p1->p_pri) == 0)
X		{
X		    /* use resident set size (rssize) to break the tie */
X		    if ((result = p2->p_rssize - p1->p_rssize) == 0)
X		    {
X			/* use total memory to break the tie */
X			result = p2->process_size - p1->process_size;
X		    }
X		}
X	    }
X	}
X    }
X
X    if(lresult)
X	result = lresult < 0 ? -1 : 1;
X    return(result);
X}
X
X/*
X * proc_owner(pid) - returns the uid that owns process "pid", or -1 if
X *		the process does not exist.
X *		It is EXTREMLY IMPORTANT that this function work correctly.
X *		If top runs setuid root (as in SVR4), then this function
X *		is the only thing that stands in the way of a serious
X *		security problem.  It validates requests for the "kill"
X *		and "renice" commands.
X */
X
Xint proc_owner(pid)
X
Xint pid;
X
X{
X    register int cnt;
X    register struct osf1_top_proc **prefp;
X    register struct osf1_top_proc *pp;
X
X    prefp = pref;
X    cnt = pref_len;
X    while (--cnt >= 0)
X    {
X	if ((pp = *prefp++)->p_pid == (pid_t)pid)
X	{
X	    return((int)pp->p_ruid);
X	}
X    }
X    return(-1);
X}
X
X
X/*
X * We use the Mach interface, as well as the table(UAREA,,,) call to
X * get some more information, then put it into unused fields in our
X * copy of the proc structure, to make it faster and easier to get at
X * later.
X */
Xvoid do_threads_calculations(thisproc)
Xstruct osf1_top_proc *thisproc; 
X{
X  int j;
X  task_t  thistask;
X  task_basic_info_data_t   taskinfo;
X  unsigned int taskinfo_l;
X  thread_array_t    threadarr;
X  unsigned int threadarr_l;
X  thread_basic_info_t     threadinfo;
X  thread_basic_info_data_t threadinfodata;
X  unsigned int threadinfo_l;
X  int task_tot_cpu=0;  /* total cpu usage of threads in a task */
X  struct user u;
X
X  thisproc->p_pri=0; 
X  thisproc->p_rssize=0; 
X  thisproc->p_mach_virt_size=0; 
X  thisproc->p_mach_state=0; 
X  thisproc->p_mach_pct_cpu=0;
X
X  if(task_by_unix_pid(task_self(), thisproc->p_pid, &thistask) 
X                                                != KERN_SUCCESS){
X      thisproc->p_mach_state=8; /* (zombie) */
X  } else {
X    taskinfo_l=TASK_BASIC_INFO_COUNT;
X    if(task_info(thistask, TASK_BASIC_INFO, (task_info_t) &taskinfo, 
X                                      &taskinfo_l)
X       != KERN_SUCCESS) {
X      thisproc->p_mach_state=8; /* (zombie) */
X    } else {
X      int minim_state=99,mcurp=1000,mbasp=1000,mslpt=999;
X
X      thisproc->p_rssize=taskinfo.resident_size;
X      thisproc->p_mach_virt_size=taskinfo.virtual_size;
X
X      (void) task_threads(thistask, &threadarr, &threadarr_l);
X      threadinfo= &threadinfodata;
X      for(j=0; j < threadarr_l; j++) {
X	threadinfo_l=THREAD_BASIC_INFO_COUNT;
X	if(thread_info(threadarr[j],THREAD_BASIC_INFO,
X	       (thread_info_t) threadinfo, &threadinfo_l) == KERN_SUCCESS) {
X	    
X	  task_tot_cpu += threadinfo->cpu_usage;
X	  if(minim_state>threadinfo->run_state) 
X              minim_state=threadinfo->run_state;
X	  if(mcurp>threadinfo->cur_priority) 
X              mcurp=threadinfo->cur_priority;
X	  if(mbasp>threadinfo->base_priority) 
X              mbasp=threadinfo->base_priority;
X	  if(mslpt>threadinfo->sleep_time) 
X              mslpt=threadinfo->sleep_time;
X	}
X      }
X      switch (minim_state) {
X      case TH_STATE_RUNNING:      
X	    thisproc->p_mach_state=1;  break;
X      case TH_STATE_UNINTERRUPTIBLE: 
X	    thisproc->p_mach_state=2; break;
X      case TH_STATE_WAITING:      
X	    thisproc->p_mach_state=(threadinfo->sleep_time > 20) ? 4 : 3; break;
X      case TH_STATE_STOPPED:      
X	    thisproc->p_mach_state=5; break;
X      case TH_STATE_HALTED:       
X	    thisproc->p_mach_state=6; break;
X      default:                    
X	    thisproc->p_mach_state=7; break;
X      }
X
X      thisproc->p_pri=mcurp;
X      thisproc->p_mach_pct_cpu=(fixpt_t)(task_tot_cpu*10);
X      vm_deallocate(task_self(),(vm_address_t)threadarr,threadarr_l);
X    }
X  }
X  if (table(TBL_UAREA,thisproc->p_pid,&u,1,sizeof(struct user))>=0) {
X    thisproc->used_ticks=(u.u_ru.ru_utime.tv_sec + u.u_ru.ru_stime.tv_sec);
X    thisproc->process_size=u.u_tsize + u.u_dsize + u.u_ssize;
X  }
X}
X
X/* The reason for this function is that the system call will let
X * someone lower their own processes priority (because top is setuid :-(
X * Yes, using syscall() is a hack, if you can come up with something 
X * better, then I'd be thrilled to hear it. I'm not holding my breath,
X * though.  
X *             Anthony.
X */
Xint setpriority(int dummy, int procnum, int niceval)
X{
X
X    int uid, curprio;
X
X    uid=getuid();
X    if ( (curprio=getpriority(PRIO_PROCESS,procnum) ) == -1) 
X    {
X	return(-1); /* errno goes back to renice_process() */
X    }
X    /* check for not-root - if so, dont allow users to decrease priority */
X    else if ( uid && (niceval<curprio) )
X    {
X	errno=EACCES;
X	return(-1);
X    }
X    return(syscall(SYS_setpriority,PRIO_PROCESS,procnum,niceval));
X}
END_OF_FILE
if test 23295 -ne `wc -c <'top-3.4/machine/m_decosf1.c'`; then
    echo shar: \"'top-3.4/machine/m_decosf1.c'\" unpacked with wrong size!
fi
# end of 'top-3.4/machine/m_decosf1.c'
fi
if test -f 'top-3.4/machine/m_netbsd10.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'top-3.4/machine/m_netbsd10.c'\"
else
echo shar: Extracting \"'top-3.4/machine/m_netbsd10.c'\" \(23192 characters\)
sed "s/^X//" >'top-3.4/machine/m_netbsd10.c' <<'END_OF_FILE'
X/*
X * top - a top users display for Unix
X *
X * SYNOPSIS:  For a NetBSD-1.0 (4.4BSD) system
X *	      Note process resident sizes could be wrong, but ps shows
X *	      zero for them too..
X *
X * DESCRIPTION:
X * Originally written for BSD4.4 system by Christos Zoulas.
X * Based on the FreeBSD 2.0 version by Steven Wallace && Wolfram Schneider
X * NetBSD-1.0 port by Arne Helme
X * .
X * This is the machine-dependent module for NetBSD-1.0
X * Works for:
X *	NetBSD-1.0
X *
X * LIBS: -lkvm
X *
X * CFLAGS: -DHAVE_GETOPT
X *
X * AUTHOR:  Christos Zoulas <christos@ee.cornell.edu>
X *          Steven Wallace  <swallace@freebsd.org>
X *          Wolfram Schneider <wosch@cs.tu-berlin.de>
X *	    Arne Helme <arne@acm.org>
X *
X * $Id: machine.c,v 1.5 1995/01/06 02:04:39 swallace Exp $
X */
X
X
X
X#define LASTPID      /**/  /* use last pid, compiler depended */
X/* #define LASTPID_FIXED /**/ 
X#define VM_REAL      /**/  /* use the same values as vmstat -s */
X#define USE_SWAP     /**/  /* use swap usage (pstat -s), 
X                              need to much cpu time */
X/* #define DEBUG 1      /**/
X
X#include <sys/types.h>
X#include <sys/signal.h>
X#include <sys/param.h>
X
X#include "os.h"
X#include <stdio.h>
X#include <nlist.h>
X#include <math.h>
X#include <kvm.h>
X#include <sys/errno.h>
X#include <sys/sysctl.h>
X#include <sys/dir.h>
X#include <sys/dkstat.h>
X#include <sys/file.h>
X#include <sys/time.h>
X
X#ifdef USE_SWAP
X#include <stdlib.h>
X#include <sys/map.h>
X#include <sys/conf.h>
X#endif
X
Xstatic int check_nlist __P((struct nlist *));
Xstatic int getkval __P((unsigned long, int *, int, char *));
Xextern char* printable __P((char *));
X
X#include "top.h"
X#include "machine.h"
X
X
X/* get_process_info passes back a handle.  This is what it looks like: */
X
Xstruct handle
X{
X    struct kinfo_proc **next_proc;	/* points to next valid proc pointer */
X    int remaining;		/* number of pointers remaining */
X};
X
X/* declarations for load_avg */
X#include "loadavg.h"
X
X#define PP(pp, field) ((pp)->kp_proc . field)
X#define EP(pp, field) ((pp)->kp_eproc . field)
X#define VP(pp, field) ((pp)->kp_eproc.e_vm . field)
X
X/* define what weighted cpu is.  */
X#define weighted_cpu(pct, pp) (PP((pp), p_swtime) == 0 ? 0.0 : \
X			 ((pct) / (1.0 - exp(PP((pp), p_swtime) * logcpu))))
X
X/* what we consider to be process size: */
X#define PROCSIZE(pp) (VP((pp), vm_tsize) + VP((pp), vm_dsize) + VP((pp), vm_ssize))
X
X/* definitions for indices in the nlist array */
X
X
Xstatic struct nlist nlst[] = {
X#define X_CCPU		0
X    { "_ccpu" },		/* 0 */
X#define X_CP_TIME	1
X    { "_cp_time" },		/* 1 */
X#define X_HZ		2
X    { "_hz" },		        /* 2 */
X#define X_STATHZ	3
X    { "_stathz" },		/* 3 */
X#define X_AVENRUN	4
X    { "_averunnable" },		/* 4 */
X
X#ifdef USE_SWAP
X#define VM_SWAPMAP	5
X	{ "_swapmap" },	/* list of free swap areas */
X#define VM_NSWAPMAP	6
X	{ "_nswapmap" },/* size of the swap map */
X#define VM_SWDEVT	7
X	{ "_swdevt" },	/* list of swap devices and sizes */
X#define VM_NSWAP	8
X	{ "_nswap" },	/* size of largest swap device */
X#define VM_NSWDEV	9
X	{ "_nswdev" },	/* number of swap devices */
X#define VM_DMMAX	10
X	{ "_dmmax" },	/* maximum size of a swap block */
X#define VM_NISWAP	11
X	{ "_niswap" },
X#define VM_NISWDEV	12
X	{ "_niswdev" },
X#endif /* USE_SWAP */
X
X#ifdef VM_REAL
X#ifdef USE_SWAP
X#define X_CNT           13
X#else
X#define X_CNT           5
X#endif
X    { "_cnt" },		        /* struct vmmeter cnt */
X#endif
X
X#ifdef LASTPID
X#if (defined USE_SWAP && defined VM_REAL)
X#define X_LASTPID	14
X#elif (defined VM_REAL)
X#define X_LASTPID	6
X#else
X#define X_LASTPID       5
X#endif
X#ifdef LASTPID_FIXED
X    { "_nextpid" },		
X#else
X    { "_nextpid.178" },		/* lastpid, compiler depended 
X				 * should be changed 
X				 * in /sys/kern/kern_fork.c */
X#endif
X#endif
X
X    { 0 }
X};
X
X/*
X *  These definitions control the format of the per-process area
X */
X
Xstatic char header[] =
X  "  PID X        PRI NICE   SIZE   RES STATE   TIME   WCPU    CPU COMMAND";
X/* 0123456   -- field to fill in starts at header+6 */
X#define UNAME_START 6
X
X#define Proc_format \
X	"%5d %-8.8s %3d %4d%7s %5s %-5s%7s %5.2f%% %5.2f%% %.14s"
X
X
X/* process state names for the "STATE" column of the display */
X/* the extra nulls in the string "run" are for adding a slash and
X   the processor number when needed */
X
Xchar *state_abbrev[] =
X{
X    "", "start", "run\0\0\0", "sleep", "stop", "zomb", "WAIT"
X};
X
X
Xstatic kvm_t *kd;
X
X/* values that we stash away in _init and use in later routines */
X
Xstatic double logcpu;
X
X/* these are retrieved from the kernel in _init */
X
Xstatic          long hz;
Xstatic load_avg  ccpu;
X
X/* these are offsets obtained via nlist and used in the get_ functions */
X
Xstatic unsigned long cp_time_offset;
Xstatic unsigned long avenrun_offset;
X#ifdef LASTPID
Xstatic unsigned long lastpid_offset;
Xstatic long lastpid;
X#endif
X#ifdef VM_REAL
Xstatic unsigned long cnt_offset;
Xstatic long cnt;
X#endif
X/* these are for calculating cpu state percentages */
X
Xstatic long cp_time[CPUSTATES];
Xstatic long cp_old[CPUSTATES];
Xstatic long cp_diff[CPUSTATES];
X
X/* these are for detailing the process states */
X
Xint process_states[7];
Xchar *procstatenames[] = {
X    "", " starting, ", " running, ", " sleeping, ", " stopped, ",
X    " zombie, ", " ABANDONED, ",
X    NULL
X};
X
X/* these are for detailing the cpu states */
X
Xint cpu_states[CPUSTATES];
Xchar *cpustatenames[] = {
X    "user", "nice", "system", "interrupt", "idle", NULL
X};
X
X/* these are for detailing the memory statistics */
X
Xint memory_stats[8];
Xchar *memorynames[] = {
X#ifndef VM_REAL
X    "Real: ", "K/", "K ", "Virt: ", "K/",
X    "K ", "Free: ", "K", NULL
X#else
X#if 0
X    "K Act ", "K Inact ", "K Wired ", "K Free ", "% Swap, ",
X    "K/", "K SWIO", 
X#else
X    "K Act ", "K Inact ", "K Wired ", "K Free ", "% Swap, ",
X    "Kin ", "Kout", 
X#endif
X    NULL
X#endif
X};
X
X/* these are for keeping track of the proc array */
X
Xstatic int nproc;
Xstatic int onproc = -1;
Xstatic int pref_len;
Xstatic struct kinfo_proc *pbase;
Xstatic struct kinfo_proc **pref;
X
X/* these are for getting the memory statistics */
X
Xstatic int pageshift;		/* log base 2 of the pagesize */
X
X/* define pagetok in terms of pageshift */
X
X#define pagetok(size) ((size) << pageshift)
X
X/* useful externals */
Xlong percentages();
X
Xint
Xmachine_init(statics)
X
Xstruct statics *statics;
X
X{
X    register int i = 0;
X    register int pagesize;
X
X    if ((kd = kvm_open(NULL, NULL, NULL, O_RDONLY, "kvm_open")) == NULL)
X	return -1;
X
X
X    /* get the list of symbols we want to access in the kernel */
X    (void) kvm_nlist(kd, nlst);
X    if (nlst[0].n_type == 0)
X    {
X	fprintf(stderr, "top: nlist failed\n");
X	return(-1);
X    }
X
X    /* make sure they were all found */
X    if (i > 0 && check_nlist(nlst) > 0)
X    {
X	return(-1);
X    }
X
X    /* get the symbol values out of kmem */
X    (void) getkval(nlst[X_STATHZ].n_value, (int *)(&hz), sizeof(hz), "!");
X    if (!hz) {
X	(void) getkval(nlst[X_HZ].n_value, (int *)(&hz), sizeof(hz),
X		       nlst[X_HZ].n_name);
X    }
X
X
X#if (defined DEBUG)
X    fprintf(stderr, "Hertz: %d\n", hz); 
X#endif
X
X    (void) getkval(nlst[X_CCPU].n_value,   (int *)(&ccpu),	sizeof(ccpu),
X	    nlst[X_CCPU].n_name);
X
X    /* stash away certain offsets for later use */
X    cp_time_offset = nlst[X_CP_TIME].n_value;
X    avenrun_offset = nlst[X_AVENRUN].n_value;
X#ifdef LASTPID
X    lastpid_offset =  nlst[X_LASTPID].n_value;
X#endif
X#ifdef VM_REAL
X    cnt_offset = nlst[X_CNT].n_value;
X#endif
X
X    /* this is used in calculating WCPU -- calculate it ahead of time */
X    logcpu = log(loaddouble(ccpu));
X
X    pbase = NULL;
X    pref = NULL;
X    nproc = 0;
X    onproc = -1;
X    /* get the page size with "getpagesize" and calculate pageshift from it */
X    pagesize = getpagesize();
X    pageshift = 0;
X    while (pagesize > 1)
X    {
X	pageshift++;
X	pagesize >>= 1;
X    }
X
X    /* we only need the amount of log(2)1024 for our conversion */
X    pageshift -= LOG1024;
X
X    /* fill in the statics information */
X    statics->procstate_names = procstatenames;
X    statics->cpustate_names = cpustatenames;
X    statics->memory_names = memorynames;
X
X    /* all done! */
X    return(0);
X}
X
Xchar *format_header(uname_field)
X
Xregister char *uname_field;
X
X{
X    register char *ptr;
X
X    ptr = header + UNAME_START;
X    while (*uname_field != '\0')
X    {
X	*ptr++ = *uname_field++;
X    }
X
X    return(header);
X}
X
Xstatic int swappgsin = -1;
Xstatic int swappgsout = -1;
Xextern struct timeval timeout;
X
Xvoid
Xget_system_info(si)
X
Xstruct system_info *si;
X
X{
X    long total;
X    load_avg avenrun[3];
X
X    /* get the cp_time array */
X    (void) getkval(cp_time_offset, (int *)cp_time, sizeof(cp_time),
X		   nlst[X_CP_TIME].n_name);
X    (void) getkval(avenrun_offset, (int *)avenrun, sizeof(avenrun),
X		   nlst[X_AVENRUN].n_name);
X
X#ifdef LASTPID
X    (void) getkval(lastpid_offset, (int *)(&lastpid), sizeof(lastpid),
X		   "!");
X#endif
X
X    /* convert load averages to doubles */
X    {
X	register int i;
X	register double *infoloadp;
X	load_avg *avenrunp;
X
X#ifdef notyet
X	struct loadavg sysload;
X	int size;
X	getkerninfo(KINFO_LOADAVG, &sysload, &size, 0);
X#endif
X
X	infoloadp = si->load_avg;
X	avenrunp = avenrun;
X	for (i = 0; i < 3; i++)
X	{
X#ifdef notyet
X	    *infoloadp++ = ((double) sysload.ldavg[i]) / sysload.fscale;
X#endif
X	    *infoloadp++ = loaddouble(*avenrunp++);
X	}
X    }
X
X    /* convert cp_time counts to percentages */
X    total = percentages(CPUSTATES, cpu_states, cp_time, cp_old, cp_diff);
X
X    /* sum memory statistics */
X    {
X
X#ifndef VM_REAL
X	struct vmtotal total;
X	int size = sizeof(total);
X	static int mib[] = { CTL_VM, VM_METER };
X
X	/* get total -- systemwide main memory usage structure */
X	if (sysctl(mib, 2, &total, &size, NULL, 0) < 0) {
X	    (void) fprintf(stderr, "top: sysctl failed: %s\n", strerror(errno));
X	    bzero(&total, sizeof(total));
X	}
X	/* convert memory stats to Kbytes */
X	memory_stats[0] = -1;
X	memory_stats[1] = pagetok(total.t_arm);
X	memory_stats[2] = pagetok(total.t_rm);
X	memory_stats[3] = -1;
X	memory_stats[4] = pagetok(total.t_avm);
X	memory_stats[5] = pagetok(total.t_vm);
X	memory_stats[6] = -1;
X	memory_stats[7] = pagetok(total.t_free);
X    }
X#else
X	struct vmmeter sum;
X	static unsigned int swap_delay = 0;
X
X        (void) getkval(cnt_offset, (int *)(&sum), sizeof(sum),
X		   "_cnt");
X
X	/* convert memory stats to Kbytes */
X	memory_stats[0] = pagetok(sum.v_active_count);
X	memory_stats[1] = pagetok(sum.v_inactive_count);
X	memory_stats[2] = pagetok(sum.v_wire_count);
X	memory_stats[3] = pagetok(sum.v_free_count);
X
X        if (swappgsin < 0) {
X	    memory_stats[5] = 0;
X	    memory_stats[6] = 0;
X	} else {
X	    memory_stats[5] = pagetok(((sum.v_pswpin - swappgsin)));
X	    memory_stats[6] = pagetok(((sum.v_pswpout - swappgsout)));
X	}
X        swappgsin = sum.v_pswpin;
X	swappgsout = sum.v_pswpout;
X
X#ifdef USE_SWAP
X        if ((memory_stats[5] > 0 || memory_stats[6]) > 0 || swap_delay == 0) {
X	    memory_stats[4] = swapmode();
X	}
X        /* swap_delay++; XXX Arne */
X#else
X        memory_stats[4] = 0;
X#endif
X
X
X	memory_stats[7] = -1;
X    }
X#endif
X    /* set arrays and strings */
X    si->cpustates = cpu_states;
X    si->memory = memory_stats;
X#ifdef LASTPID
X    if(lastpid > 0) {
X	si->last_pid = lastpid;
X    } else {
X	si->last_pid = -1;
X    }
X#else
X    si->last_pid = -1;
X#endif
X
X}
X
Xstatic struct handle handle;
X
Xcaddr_t get_process_info(si, sel, compare)
X
Xstruct system_info *si;
Xstruct process_select *sel;
Xint (*compare)();
X
X{
X    register int i;
X    register int total_procs;
X    register int active_procs;
X    register struct kinfo_proc **prefp;
X    register struct kinfo_proc *pp;
X
X    /* these are copied out of sel for speed */
X    int show_idle;
X    int show_system;
X    int show_uid;
X    int show_command;
X
X    
X    pbase = kvm_getprocs(kd, KERN_PROC_ALL, 0, &nproc);
X    if (nproc > onproc)
X	pref = (struct kinfo_proc **) realloc(pref, sizeof(struct kinfo_proc *)
X		* (onproc = nproc));
X    if (pref == NULL || pbase == NULL) {
X	(void) fprintf(stderr, "top: Out of memory.\n");
X	quit(23);
X    }
X    /* get a pointer to the states summary array */
X    si->procstates = process_states;
X
X    /* set up flags which define what we are going to select */
X    show_idle = sel->idle;
X    show_system = sel->system;
X    show_uid = sel->uid != -1;
X    show_command = sel->command != NULL;
X
X    /* count up process states and get pointers to interesting procs */
X    total_procs = 0;
X    active_procs = 0;
X    memset((char *)process_states, 0, sizeof(process_states));
X    prefp = pref;
X    for (pp = pbase, i = 0; i < nproc; pp++, i++)
X    {
X	/*
X	 *  Place pointers to each valid proc structure in pref[].
X	 *  Process slots that are actually in use have a non-zero
X	 *  status field.  Processes with P_SYSTEM set are system
X	 *  processes---these get ignored unless show_sysprocs is set.
X	 */
X	if (PP(pp, p_stat) != 0 &&
X	    (show_system || ((PP(pp, p_flag) & P_SYSTEM) == 0)))
X	{
X	    total_procs++;
X	    process_states[(unsigned char) PP(pp, p_stat)]++;
X	    if ((PP(pp, p_stat) != SZOMB) &&
X		(show_idle || (PP(pp, p_pctcpu) != 0) || 
X		 (PP(pp, p_stat) == SRUN)) &&
X		(!show_uid || EP(pp, e_pcred.p_ruid) == (uid_t)sel->uid))
X	    {
X		*prefp++ = pp;
X		active_procs++;
X	    }
X	}
X    }
X
X    /* if requested, sort the "interesting" processes */
X    if (compare != NULL)
X    {
X	qsort((char *)pref, active_procs, sizeof(struct kinfo_proc *), compare);
X    }
X
X    /* remember active and total counts */
X    si->p_total = total_procs;
X    si->p_active = pref_len = active_procs;
X
X    /* pass back a handle */
X    handle.next_proc = pref;
X    handle.remaining = active_procs;
X    return((caddr_t)&handle);
X}
X
Xchar fmt[128];		/* static area where result is built */
X
Xchar *format_next_process(handle, get_userid)
X
Xcaddr_t handle;
Xchar *(*get_userid)();
X
X{
X    register struct kinfo_proc *pp;
X    register long cputime;
X    register double pct;
X    struct handle *hp;
X
X    /* find and remember the next proc structure */
X    hp = (struct handle *)handle;
X    pp = *(hp->next_proc++);
X    hp->remaining--;
X    
X
X    /* get the process's user struct and set cputime */
X    if ((PP(pp, p_flag) & P_INMEM) == 0) {
X	/*
X	 * Print swapped processes as <pname>
X	 */
X	char *comm = PP(pp, p_comm);
X#define COMSIZ sizeof(PP(pp, p_comm))
X	char buf[COMSIZ];
X	(void) strncpy(buf, comm, COMSIZ);
X	comm[0] = '<';
X	(void) strncpy(&comm[1], buf, COMSIZ - 2);
X	comm[COMSIZ - 2] = '\0';
X	(void) strncat(comm, ">", COMSIZ - 1);
X	comm[COMSIZ - 1] = '\0';
X    }
X
X#if 0
X    /* This does not produce the correct results */
X    cputime = PP(pp, p_uticks) + PP(pp, p_sticks) + PP(pp, p_iticks);
X#endif
X    cputime = PP(pp, p_rtime).tv_sec;	/* This does not count interrupts */
X
X    /* calculate the base for cpu percentages */
X    pct = pctdouble(PP(pp, p_pctcpu));
X
X    /* format this entry */
X    sprintf(fmt,
X	    Proc_format,
X	    PP(pp, p_pid),
X	    (*get_userid)(EP(pp, e_pcred.p_ruid)),
X	    PP(pp, p_priority) - PZERO,
X	    PP(pp, p_nice) - NZERO,
X	    format_k(pagetok(PROCSIZE(pp))),
X	    format_k(pagetok(VP(pp, vm_rssize))),
X	    state_abbrev[(unsigned char) PP(pp, p_stat)],
X	    format_time(cputime),
X	    10000.0 * weighted_cpu(pct, pp) / hz,
X	    10000.0 * pct / hz,
X	    printable(PP(pp, p_comm)));
X
X    /* return the result */
X    return(fmt);
X}
X
X
X/*
X * check_nlist(nlst) - checks the nlist to see if any symbols were not
X *		found.  For every symbol that was not found, a one-line
X *		message is printed to stderr.  The routine returns the
X *		number of symbols NOT found.
X */
X
Xstatic int check_nlist(nlst)
X
Xregister struct nlist *nlst;
X
X{
X    register int i;
X
X    /* check to see if we got ALL the symbols we requested */
X    /* this will write one line to stderr for every symbol not found */
X
X    i = 0;
X    while (nlst->n_name != NULL)
X    {
X	if (nlst->n_type == 0)
X	{
X	    /* this one wasn't found */
X	    (void) fprintf(stderr, "kernel: no symbol named `%s'\n",
X			   nlst->n_name);
X	    i = 1;
X	}
X	nlst++;
X    }
X
X    return(i);
X}
X
X
X/*
X *  getkval(offset, ptr, size, refstr) - get a value out of the kernel.
X *	"offset" is the byte offset into the kernel for the desired value,
X *  	"ptr" points to a buffer into which the value is retrieved,
X *  	"size" is the size of the buffer (and the object to retrieve),
X *  	"refstr" is a reference string used when printing error meessages,
X *	    if "refstr" starts with a '!', then a failure on read will not
X *  	    be fatal (this may seem like a silly way to do things, but I
X *  	    really didn't want the overhead of another argument).
X *  	
X */
X
Xstatic int getkval(offset, ptr, size, refstr)
X
Xunsigned long offset;
Xint *ptr;
Xint size;
Xchar *refstr;
X
X{
X    if (kvm_read(kd, offset, (char *) ptr, size) != size)
X    {
X	if (*refstr == '!')
X	{
X	    return(0);
X	}
X	else
X	{
X	    fprintf(stderr, "top: kvm_read for %s: %s\n",
X		refstr, strerror(errno));
X	    quit(23);
X	}
X    }
X    return(1);
X}
X    
X/* comparison routine for qsort */
X
X/*
X *  proc_compare - comparison function for "qsort"
X *	Compares the resource consumption of two processes using five
X *  	distinct keys.  The keys (in descending order of importance) are:
X *  	percent cpu, cpu ticks, state, resident set size, total virtual
X *  	memory usage.  The process states are ordered as follows (from least
X *  	to most important):  WAIT, zombie, sleep, stop, start, run.  The
X *  	array declaration below maps a process state index into a number
X *  	that reflects this ordering.
X */
X
Xstatic unsigned char sorted_state[] =
X{
X    0,	/* not used		*/
X    3,	/* sleep		*/
X    1,	/* ABANDONED (WAIT)	*/
X    6,	/* run			*/
X    5,	/* start		*/
X    2,	/* zombie		*/
X    4	/* stop			*/
X};
X 
Xint
Xproc_compare(pp1, pp2)
X
Xstruct proc **pp1;
Xstruct proc **pp2;
X
X{
X    register struct kinfo_proc *p1;
X    register struct kinfo_proc *p2;
X    register int result;
X    register pctcpu lresult;
X
X    /* remove one level of indirection */
X    p1 = *(struct kinfo_proc **) pp1;
X    p2 = *(struct kinfo_proc **) pp2;
X
X    /* compare percent cpu (pctcpu) */
X    if ((lresult = PP(p2, p_pctcpu) - PP(p1, p_pctcpu)) == 0)
X    {
X	/* use cpticks to break the tie */
X	if ((result = PP(p2, p_cpticks) - PP(p1, p_cpticks)) == 0)
X	{
X	    /* use process state to break the tie */
X	    if ((result = sorted_state[(unsigned char) PP(p2, p_stat)] -
X			  sorted_state[(unsigned char) PP(p1, p_stat)])  == 0)
X	    {
X		/* use priority to break the tie */
X		if ((result = PP(p2, p_priority) - PP(p1, p_priority)) == 0)
X		{
X		    /* use resident set size (rssize) to break the tie */
X		    if ((result = VP(p2, vm_rssize) - VP(p1, vm_rssize)) == 0)
X		    {
X			/* use total memory to break the tie */
X			result = PROCSIZE(p2) - PROCSIZE(p1);
X		    }
X		}
X	    }
X	}
X    }
X    else
X    {
X	result = lresult < 0 ? -1 : 1;
X    }
X
X    return(result);
X}
X
X
X/*
X * proc_owner(pid) - returns the uid that owns process "pid", or -1 if
X *		the process does not exist.
X *		It is EXTREMLY IMPORTANT that this function work correctly.
X *		If top runs setuid root (as in SVR4), then this function
X *		is the only thing that stands in the way of a serious
X *		security problem.  It validates requests for the "kill"
X *		and "renice" commands.
X */
X
Xint proc_owner(pid)
X
Xint pid;
X
X{
X    register int cnt;
X    register struct kinfo_proc **prefp;
X    register struct kinfo_proc *pp;
X
X    prefp = pref;
X    cnt = pref_len;
X    while (--cnt >= 0)
X    {
X	pp = *prefp++;	
X	if (PP(pp, p_pid) == (pid_t)pid)
X	{
X	    return((int)EP(pp, e_pcred.p_ruid));
X	}
X    }
X    return(-1);
X}
X
X
X#ifdef USE_SWAP
X/*
X * swapmode is based on a program called swapinfo written
X * by Kevin Lahey <kml@rokkaku.atl.ga.us>.
X */
X
X#define	SVAR(var) __STRING(var)	/* to force expansion */
X#define	KGET(idx, var)							\
X	KGET1(idx, &var, sizeof(var), SVAR(var))
X#define	KGET1(idx, p, s, msg)						\
X	KGET2(nlst[idx].n_value, p, s, msg)
X#define	KGET2(addr, p, s, msg)						\
X	if (kvm_read(kd, (u_long)(addr), p, s) != s)			\
X		warnx("cannot read %s: %s", msg, kvm_geterr(kd))
X#define	KGETRET(addr, p, s, msg)					\
X	if (kvm_read(kd, (u_long)(addr), p, s) != s) {			\
X		warnx("cannot read %s: %s", msg, kvm_geterr(kd));	\
X		return (0);						\
X	}
X
Xint
Xswapmode()
X{
X	char *header;
X	int hlen, nswap, nswdev, dmmax, nswapmap, niswap, niswdev;
X	int s, e, div, i, l, avail, nfree, npfree, used;
X	struct swdevt *sw;
X	long blocksize, *perdev;
X	struct map *swapmap, *kswapmap;
X	struct mapent *mp, *freemp;
X
X	KGET(VM_NSWAP, nswap);
X	KGET(VM_NSWDEV, nswdev);
X	KGET(VM_DMMAX, dmmax);
X	KGET(VM_NSWAPMAP, nswapmap);
X	KGET(VM_SWAPMAP, kswapmap);	/* kernel `swapmap' is a pointer */
X	if ((sw = malloc(nswdev * sizeof(*sw))) == NULL ||
X	    (perdev = malloc(nswdev * sizeof(*perdev))) == NULL ||
X	    (freemp = mp = malloc(nswapmap * sizeof(*mp))) == NULL)
X		err(1, "malloc");
X	KGET1(VM_SWDEVT, sw, nswdev * sizeof(*sw), "swdevt");
X	KGET2((long)kswapmap, mp, nswapmap * sizeof(*mp), "swapmap");
X
X	/* Supports sequential swap */
X	if (nlst[VM_NISWAP].n_value != 0) {
X		KGET(VM_NISWAP, niswap);
X		KGET(VM_NISWDEV, niswdev);
X	} else {
X		niswap = nswap;
X		niswdev = nswdev;
X	}
X
X	/* First entry in map is `struct map'; rest are mapent's. */
X	swapmap = (struct map *)mp;
X	if (nswapmap != swapmap->m_limit - (struct mapent *)kswapmap)
X		errx(1, "panic: nswapmap goof");
X
X	/* Count up swap space. */
X	nfree = 0;
X	memset(perdev, 0, nswdev * sizeof(*perdev));
X	for (mp++; mp->m_addr != 0; mp++) {
X		s = mp->m_addr;			/* start of swap region */
X		e = mp->m_addr + mp->m_size;	/* end of region */
X		nfree += mp->m_size;
X
X		/*
X		 * Swap space is split up among the configured disks.
X		 *
X		 * For interleaved swap devices, the first dmmax blocks
X		 * of swap space some from the first disk, the next dmmax
X		 * blocks from the next, and so on up to niswap blocks.
X		 *
X		 * Sequential swap devices follow the interleaved devices
X		 * (i.e. blocks starting at niswap) in the order in which
X		 * they appear in the swdev table.  The size of each device
X		 * will be a multiple of dmmax.
X		 *
X		 * The list of free space joins adjacent free blocks,
X		 * ignoring device boundries.  If we want to keep track
X		 * of this information per device, we'll just have to
X		 * extract it ourselves.  We know that dmmax-sized chunks
X		 * cannot span device boundaries (interleaved or sequential)
X		 * so we loop over such chunks assigning them to devices.
X		 */
X		i = -1;
X		while (s < e) {		/* XXX this is inefficient */
X			int bound = roundup(s+1, dmmax);
X
X			if (bound > e)
X				bound = e;
X			if (bound <= niswap) {
X				/* Interleaved swap chunk. */
X				if (i == -1)
X					i = (s / dmmax) % niswdev;
X				perdev[i] += bound - s;
X				if (++i >= niswdev)
X					i = 0;
X			} else {
X				/* Sequential swap chunk. */
X				if (i < niswdev) {
X					i = niswdev;
X					l = niswap + sw[i].sw_nblks;
X				}
X				while (s >= l) {
X					/* XXX don't die on bogus blocks */
X					if (i == nswdev-1)
X						break;
X					l += sw[++i].sw_nblks;
X				}
X				perdev[i] += bound - s;
X			}
X			s = bound;
X		}
X	}
X
X	header = getbsize(&hlen, &blocksize);
X	div = blocksize / 512;
X	avail = npfree = 0;
X	for (i = 0; i < nswdev; i++) {
X		int xsize, xfree;
X
X		xsize = sw[i].sw_nblks;
X		xfree = perdev[i];
X		used = xsize - xfree;
X		npfree++;
X		avail += xsize;
X	}
X
X	/* 
X	 * If only one partition has been set up via swapon(8), we don't
X	 * need to bother with totals.
X	 */
X	used = avail - nfree;
X	free (sw); free (freemp); free (perdev);
X	return  (int)(((double)used / (double)avail * 100.0) + 0.5);
X}
X
X
X#endif
X
END_OF_FILE
if test 23192 -ne `wc -c <'top-3.4/machine/m_netbsd10.c'`; then
    echo shar: \"'top-3.4/machine/m_netbsd10.c'\" unpacked with wrong size!
fi
# end of 'top-3.4/machine/m_netbsd10.c'
fi
echo shar: End of archive 19 \(of 22\).
cp /dev/null ark19isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 22 archives.
    echo "Now read README and INSTALL, then run Configure"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

