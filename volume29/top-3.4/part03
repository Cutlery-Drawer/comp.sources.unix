Newsgroups: comp.sources.unix
From: wnl@groupsys.com (William Lefebvre)
Subject: v29i104: top-3.4 - top process display, V3.4, Part03/22
References: <1.841608857.22962@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: wnl@groupsys.com (William Lefebvre)
Posting-Number: Volume 29, Issue 104
Archive-Name: top-3.4/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 22)."
# Contents:  top-3.4/FAQ top-3.4/commands.c top-3.4/top.X
#   top-3.4/utils.c
# Wrapped by lefebvre@acapulco on Fri Aug 30 12:35:49 1996
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'top-3.4/FAQ' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'top-3.4/FAQ'\"
else
echo shar: Extracting \"'top-3.4/FAQ'\" \(9949 characters\)
sed "s/^X//" >'top-3.4/FAQ' <<'END_OF_FILE'
X                             TOP
X                         Version 3.4
X
X                       William LeFebvre
X		     and a cast of dozens
X
X
XFREQUENTLY ASKED QUESTIONS AND THEIR ANSWERS
X
XThis FAQ is broken out in to several topics.
X
X
XGENERAL
X
X 1.  "Where do I get the latest version of top?"
X
XThe latest version of top is now available at the site "ftp.groupsys.com" in 
Xthe directory "/pub/top". It is also available at "eecs.nwu.edu" in the 
Xdirectory "/pub/top".
X
X 2.  "Is there a web page for top?"
X
XNot at this time, but I am planning one.  When it is finally available, you 
Xwill be able to find it at "www.groupsys.com."
X
X 3.  "Is there a mailing list for top?"
X
XCurrently there is a top developers mailing list that is used by beta 
Xtesters and other people who help me port the program to various machines.  
XI am planning a general mailing list for announcements and such, but it is 
Xnot yet available.
X
X 4.  "How can I find out when all these things become available?"
X
XInformation about the web site and the mailing list will be made available 
Xin future distributions of top.  New distributions will be announced on the 
Xappropriate Usenet newsgroups (including comp.sources.unix).
X
X 5.  "Why does it take so long for a new version of top to go through the
X      beta test process?"
X
XThis is completely my fault.  I have just not had the time recently to give 
Xtop the attention it deserves.  I thank everyone for their patience, and I 
Xhope that with the recent changes in the direction of my career that I can 
Xspend more time on this.
X
X 6.  "Top is not written in ANSI C.  Do you ever plan to change that?"
X
XTop predates ANSI C by about 5 years.  Yeah, it'll get "fixed" eventually.  
XProbably in 3.5.
X
X
XCONFIGURING
X
X 7.  "Configure said that it saw /proc and is recommending that I install top
X      setuid root.  Is there any way around this?  Is it safe?"
X
XThere is no way around it.  Complain to POSIX.  Every effort has been   made 
Xto make top a secure setuid program.  However, we cannot guarantee that 
Xthere are no security problems associated with this configuration.  The 
Xplaces where top is most vulnerable are the builtin kill and renice 
Xcommands.  There is no internal top command that causes top to start a shell 
Xas a subprocess.  Some SVR4 systems may contain a bug that enables a user to 
Xrenice his own processes downward (to lower nice values that are more 
Xfavorable for the process).  This problem has been fixed for the Solaris 2.x 
Xmodules, but may still exist in others.  We will hopefully fix this up in 
Xthe next release.
X
X 8.  "Why is Configure a c-shell script?  I thought c-shell scripts were 
X      evil?"
X
XThey are.  :-)  I'll probably be rewriting the Configure script for the
Xnext release.
X
X
XCOMPILING
X
X 9.  "We just upgraded our operating system to a new version and top broke.  
X      What should we do?"
X
XRecompile it.  Top is very sensitive to changes in internal kernel data 
Xstructures.  It is not uncommon for a new version of the operating system to 
Xinclude changes to kernel data structures.
X
X
XRUNNING
X
X10.  "I just finished compiling top and it works fine for root, but when
X      I try to run it as a regular user it either complains about files
X      it can't open or it doesn't display all the information it should.
X      Did I do something wrong?"
X
XWell, you're just not done.  On many operating systems today, access to
Xmany of the kernel memory devices and other system files is restricted to
Xeither root or a particular group.  The Configure script figures this out
X(usually) and makes sure that the "intsall" rule in the Makefile will
Xinstall top so that anyone can run it successfully.  However, you have to
X*install* it first.  Do this with the command "make install".
X
X11.  "Top is (not) displaying idle processes and I don't (do) want it to."
X
XThis default has only changed about a dozen times, and I finally got tired 
Xof people whining about it.  Go read the manual page for the current version 
Xand pay special attention to the description of the "TOP" environment 
Xvariable.
X
X12.  "We have so much memory in our machine that the memory status display 
X      (the fourth line) ends up being longer than 80 characters.  This
X      completely messes up top's output.  Is there a patch?"
X
XMost modules have been changed to use new memory formatting functions which 
Xwill display large values in terms of megabytes instead of kilobytes.  This 
Xshould fix all occurences of this problem.  If you encounter a system where 
Xthis large memory display overflow is still occurring, please let me know 
X(send mail to <wnl@groupsys.com>).  Also note that newer versions of top can 
Xuse columns beyond 79, and understand window resizes.  So you can always 
Xmake your window bigger.
X
X13.  "I tried to compile top with gcc and it doesn't work.  I get
X      compilation errors in the include files, or I get an executable that
X      dumps core, or top displays incorrect numbers in some of the displays.
X      What's wrong?"
X
XGnu CC likes very much to use its own include files.  Not being a gcc
Xexpert, I can't explain why it does this.  But I can tell you that if you
Xupgrade your operating system (say from Solaris 2.4 to Solaris 2.5) after
Xinstalling gcc, then the include files that gcc uses will be incorrect,
Xespecially those found in the "sys" directory.  Your choices are: (1)
Xrebuild and reinstall the "standard" include files for gcc (look for a
Xscript in the distribution called "fixincludes"), (2) compile machine.c
Xwith "CFLAGS=-I/usr/include" then make the rest of the object files
Xnormally, or (3) use "cc".
X
X14.  "The cpu state percentages are all wrong, indicating that my machine is 
X      using 95% system time when it is clearly idle.  What's wrong?"
X
XThis can happen if you compiled with gcc using the wrong include files.
XSee the previous question.
X
X
XSUNOS PROBLEMS
X
X15.  "I tried compiling top under SunOS version 4.1.x and it got compile time 
X      errors.  Is there a patch?"
X
XIf you try compiling top in a "System V environment" under SunOS (that is, 
X/usr/5bin is before /usr/bin on your path) then the compilation may fail.  
XThis is mostly due to the fact that top thinks its being compiled on a 
XSystem V machine when it really isn't. The only solution is to put /usr/bin 
Xand /usr/ucb before /usr/5bin on your path and try again.
X
X
XSVR4-derived PROBLEMS
X
X16.  "When I run top on my SVR4-derived operating system, it displays all
X      the system information at the top but does not display any process
X      information (or only displayes process information for my own
X      processes).  Yet when I run it as root, everything works fine."
X
XYour system probably uses the pseudo file system "/proc", which is by 
Xdefault only accessible by root.  Top needs to be installed setuid root on 
Xsuch systems if it is going to function correctly for normal users.
X
X
XSOLARIS PROBLEMS
X
X17.  "Under Solaris 2, when I run top as root it only shows root processes,
X      or it only shows processes with a PID less than 1000.  It refuses to
X      show anything else.  What do I do?"
X
XYou probably compiled it with /usr/ucb/cc instead of the real C compiler.  
X/usr/ucb/cc is a cc front end that compiles programs in BSD source-level 
Xcompatability mode.  You do not want that.  Make sure that /usr/ucb is not 
Xon your path and try compiling top again.
X
X18.  "Under Solaris 2, I compiled top using what I am sure is the correct
X      compiler but when I try to run it it complains about missing dynamic
X      libraries.  What is wrong?"
X
XCheck to see if you have LD_LIBRARY_PATH defined in your shell.  If you do, 
Xmake sure that /usr/ucblib is not on the path anywhere.  Then try compiling 
Xtop again.
X
X19.  "Under Solaris 2, when I try to run top it complains that it can't open 
X      the library "libucb.so.1".  So I changed the LIBS line in m_sunos5.c
X      to include -R/usr/ucblib to make sure that the dynamic linker will look 
X      there when top runs.  I figured this was just an oversight.  Was I
X      right?"
X
XNo, you were not right.  As distributed, top requires NO alterations for 
Xsuccessful compilation and operations under Solaris 2.0, 2.1, 2.2, 2.3, 2.4, 
Xand 2.5.  You probably compiled top with /usr/ucb/cc instead of the real C 
Xcompiler.  See FAQ #10 for more details.
X
X
XSCO PROBLEMS
X
X20.  "When I try to run Configure, it complains about a syntax error."
X
XSome versions of SCO's csh do not understand the syntax "$<".  This breaks 
XConfigure.  You'll just have to hack around it for now: the Configure script 
Xis going to be completely redone in the near future anyway.
X
X
XSVR42 PROBLEMS
X
X21.  "The load average and memory displays don't work right.  Why?"
X
XThis is a known bug with the svr42 module. The problem has been traced down 
Xto a potential bug in the "mem" driver.  The author of the svr42 module is 
Xworking on a fix.
X
X
XSTILL STUCK
X
X22.  I'm still stuck.  To whom do I report problems with top?"
X
XThe most common problems are caused by top's sensitivity to internal kernel 
Xdata structures.  So make sure that you are using the right include files, 
Xand make sure that you test out top on the same machine where you compiled 
Xit.  Sun's BSD Source Compatability Mode is also a common culprit.  Make 
Xsure you aren't using either /usr/ucb/cc or any of the libraries in 
X/usr/ucblib.  Finally, make sure you are using the correct module.  If there 
Xdoes not appear to be one appropriate for your computer, then top probably 
Xwill not work on your system.
X
XIf after reading all of this file and checking everything you can you are 
Xstill stuck, then send mail to "wnl@groupsys.com".  I will answer your mail 
Xwhen I have time.  Please bear with me in that regard!  If it looks like the 
Xproblem is machine-specific, I will forward the report along to the module's 
Xauthor.  If you would like to converse directly with the module author, the 
Xauthors' names are listed at the beginning of the module .c file in the 
X"machine" directory.
END_OF_FILE
if test 9949 -ne `wc -c <'top-3.4/FAQ'`; then
    echo shar: \"'top-3.4/FAQ'\" unpacked with wrong size!
fi
# end of 'top-3.4/FAQ'
fi
if test -f 'top-3.4/commands.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'top-3.4/commands.c'\"
else
echo shar: Extracting \"'top-3.4/commands.c'\" \(10459 characters\)
sed "s/^X//" >'top-3.4/commands.c' <<'END_OF_FILE'
X/*
X *  Top users/processes display for Unix
X *  Version 3
X *
X *  This program may be freely redistributed,
X *  but this entire comment MUST remain intact.
X *
X *  Copyright (c) 1984, 1989, William LeFebvre, Rice University
X *  Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
X */
X
X/*
X *  This file contains the routines that implement some of the interactive
X *  mode commands.  Note that some of the commands are implemented in-line
X *  in "main".  This is necessary because they change the global state of
X *  "top" (i.e.:  changing the number of processes to display).
X */
X
X#include "os.h"
X#include <ctype.h>
X#include <signal.h>
X#include <errno.h>
X#include <sys/time.h>
X#include <sys/resource.h>
X
X#include "sigdesc.h"		/* generated automatically */
X#include "boolean.h"
X#include "utils.h"
X
Xextern int  errno;
X
Xextern char *copyright;
X
X/* imported from screen.c */
Xextern int overstrike;
X
Xint err_compar();
Xchar *err_string();
X
X/*
X *  show_help() - display the help screen; invoked in response to
X *		either 'h' or '?'.
X */
X
Xshow_help()
X
X{
X    printf("Top version %s, %s\n", version_string(), copyright);
X    fputs("\n\n\
XA top users display for Unix\n\
X\n\
XThese single-character commands are available:\n\
X\n\
X^L      - redraw screen\n\
Xq       - quit\n\
Xh or ?  - help; show this text\n", stdout);
X
X    /* not all commands are availalbe with overstrike terminals */
X    if (overstrike)
X    {
X	fputs("\n\
XOther commands are also available, but this terminal is not\n\
Xsophisticated enough to handle those commands gracefully.\n\n", stdout);
X    }
X    else
X    {
X	fputs("\
Xd       - change number of displays to show\n\
Xe       - list errors generated by last \"kill\" or \"renice\" command\n\
Xi       - toggle the displaying of idle processes\n\
XI       - same as 'i'\n\
Xk       - kill processes; send a signal to a list of processes\n\
Xn or #  - change number of processes to display\n", stdout);
X#ifdef ORDER
X	fputs("\
Xo       - specify sort order (size, res, cpu, time)\n", stdout);
X#endif
X	fputs("\
Xr       - renice a process\n\
Xs       - change number of seconds to delay between updates\n\
Xu       - display processes for only one user (+ selects all users)\n\
X\n\
X\n", stdout);
X    }
X}
X
X/*
X *  Utility routines that help with some of the commands.
X */
X
Xchar *next_field(str)
X
Xregister char *str;
X
X{
X    if ((str = strchr(str, ' ')) == NULL)
X    {
X	return(NULL);
X    }
X    *str = '\0';
X    while (*++str == ' ') /* loop */;
X
X    /* if there is nothing left of the string, return NULL */
X    /* This fix is dedicated to Greg Earle */
X    return(*str == '\0' ? NULL : str);
X}
X
Xscanint(str, intp)
X
Xchar *str;
Xint  *intp;
X
X{
X    register int val = 0;
X    register char ch;
X
X    /* if there is nothing left of the string, flag it as an error */
X    /* This fix is dedicated to Greg Earle */
X    if (*str == '\0')
X    {
X	return(-1);
X    }
X
X    while ((ch = *str++) != '\0')
X    {
X	if (isdigit(ch))
X	{
X	    val = val * 10 + (ch - '0');
X	}
X	else if (isspace(ch))
X	{
X	    break;
X	}
X	else
X	{
X	    return(-1);
X	}
X    }
X    *intp = val;
X    return(0);
X}
X
X/*
X *  Some of the commands make system calls that could generate errors.
X *  These errors are collected up in an array of structures for later
X *  contemplation and display.  Such routines return a string containing an
X *  error message, or NULL if no errors occurred.  The next few routines are
X *  for manipulating and displaying these errors.  We need an upper limit on
X *  the number of errors, so we arbitrarily choose 20.
X */
X
X#define ERRMAX 20
X
Xstruct errs		/* structure for a system-call error */
X{
X    int  errno;		/* value of errno (that is, the actual error) */
X    char *arg;		/* argument that caused the error */
X};
X
Xstatic struct errs errs[ERRMAX];
Xstatic int errcnt;
Xstatic char *err_toomany = " too many errors occurred";
Xstatic char *err_listem = 
X	" Many errors occurred.  Press `e' to display the list of errors.";
X
X/* These macros get used to reset and log the errors */
X#define ERR_RESET   errcnt = 0
X#define ERROR(p, e) if (errcnt >= ERRMAX) \
X		    { \
X			return(err_toomany); \
X		    } \
X		    else \
X		    { \
X			errs[errcnt].arg = (p); \
X			errs[errcnt++].errno = (e); \
X		    }
X
X/*
X *  err_string() - return an appropriate error string.  This is what the
X *	command will return for displaying.  If no errors were logged, then
X *	return NULL.  The maximum length of the error string is defined by
X *	"STRMAX".
X */
X
X#define STRMAX 80
X
Xchar *err_string()
X
X{
X    register struct errs *errp;
X    register int  cnt = 0;
X    register int  first = Yes;
X    register int  currerr = -1;
X    int stringlen;		/* characters still available in "string" */
X    static char string[STRMAX];
X
X    /* if there are no errors, return NULL */
X    if (errcnt == 0)
X    {
X	return(NULL);
X    }
X
X    /* sort the errors */
X    qsort((char *)errs, errcnt, sizeof(struct errs), err_compar);
X
X    /* need a space at the front of the error string */
X    string[0] = ' ';
X    string[1] = '\0';
X    stringlen = STRMAX - 2;
X
X    /* loop thru the sorted list, building an error string */
X    while (cnt < errcnt)
X    {
X	errp = &(errs[cnt++]);
X	if (errp->errno != currerr)
X	{
X	    if (currerr != -1)
X	    {
X		if ((stringlen = str_adderr(string, stringlen, currerr)) < 2)
X		{
X		    return(err_listem);
X		}
X		(void) strcat(string, "; ");	  /* we know there's more */
X	    }
X	    currerr = errp->errno;
X	    first = Yes;
X	}
X	if ((stringlen = str_addarg(string, stringlen, errp->arg, first)) ==0)
X	{
X	    return(err_listem);
X	}
X	first = No;
X    }
X
X    /* add final message */
X    stringlen = str_adderr(string, stringlen, currerr);
X
X    /* return the error string */
X    return(stringlen == 0 ? err_listem : string);
X}
X
X/*
X *  str_adderr(str, len, err) - add an explanation of error "err" to
X *	the string "str".
X */
X
Xstr_adderr(str, len, err)
X
Xchar *str;
Xint len;
Xint err;
X
X{
X    register char *msg;
X    register int  msglen;
X
X    msg = err == 0 ? "Not a number" : errmsg(err);
X    msglen = strlen(msg) + 2;
X    if (len <= msglen)
X    {
X	return(0);
X    }
X    (void) strcat(str, ": ");
X    (void) strcat(str, msg);
X    return(len - msglen);
X}
X
X/*
X *  str_addarg(str, len, arg, first) - add the string argument "arg" to
X *	the string "str".  This is the first in the group when "first"
X *	is set (indicating that a comma should NOT be added to the front).
X */
X
Xstr_addarg(str, len, arg, first)
X
Xchar *str;
Xint  len;
Xchar *arg;
Xint  first;
X
X{
X    register int arglen;
X
X    arglen = strlen(arg);
X    if (!first)
X    {
X	arglen += 2;
X    }
X    if (len <= arglen)
X    {
X	return(0);
X    }
X    if (!first)
X    {
X	(void) strcat(str, ", ");
X    }
X    (void) strcat(str, arg);
X    return(len - arglen);
X}
X
X/*
X *  err_compar(p1, p2) - comparison routine used by "qsort"
X *	for sorting errors.
X */
X
Xerr_compar(p1, p2)
X
Xregister struct errs *p1, *p2;
X
X{
X    register int result;
X
X    if ((result = p1->errno - p2->errno) == 0)
X    {
X	return(strcmp(p1->arg, p2->arg));
X    }
X    return(result);
X}
X
X/*
X *  error_count() - return the number of errors currently logged.
X */
X
Xerror_count()
X
X{
X    return(errcnt);
X}
X
X/*
X *  show_errors() - display on stdout the current log of errors.
X */
X
Xshow_errors()
X
X{
X    register int cnt = 0;
X    register struct errs *errp = errs;
X
X    printf("%d error%s:\n\n", errcnt, errcnt == 1 ? "" : "s");
X    while (cnt++ < errcnt)
X    {
X	printf("%5s: %s\n", errp->arg,
X	    errp->errno == 0 ? "Not a number" : errmsg(errp->errno));
X	errp++;
X    }
X}
X
X/*
X *  kill_procs(str) - send signals to processes, much like the "kill"
X *		command does; invoked in response to 'k'.
X */
X
Xchar *kill_procs(str)
X
Xchar *str;
X
X{
X    register char *nptr;
X    int signum = SIGTERM;	/* default */
X    int procnum;
X    struct sigdesc *sigp;
X    int uid;
X
X    /* reset error array */
X    ERR_RESET;
X
X    /* remember our uid */
X    uid = getuid();
X
X    /* skip over leading white space */
X    while (isspace(*str)) str++;
X
X    if (str[0] == '-')
X    {
X	/* explicit signal specified */
X	if ((nptr = next_field(str)) == NULL)
X	{
X	    return(" kill: no processes specified");
X	}
X
X	if (isdigit(str[1]))
X	{
X	    (void) scanint(str + 1, &signum);
X	    if (signum <= 0 || signum >= NSIG)
X	    {
X		return(" invalid signal number");
X	    }
X	}
X	else 
X	{
X	    /* translate the name into a number */
X	    for (sigp = sigdesc; sigp->name != NULL; sigp++)
X	    {
X		if (strcmp(sigp->name, str + 1) == 0)
X		{
X		    signum = sigp->number;
X		    break;
X		}
X	    }
X
X	    /* was it ever found */
X	    if (sigp->name == NULL)
X	    {
X		return(" bad signal name");
X	    }
X	}
X	/* put the new pointer in place */
X	str = nptr;
X    }
X
X    /* loop thru the string, killing processes */
X    do
X    {
X	if (scanint(str, &procnum) == -1)
X	{
X	    ERROR(str, 0);
X	}
X	else
X	{
X	    /* check process owner if we're not root */
X	    if (uid && (uid != proc_owner(procnum)))
X	    {
X		ERROR(str, EACCES);
X	    }
X	    /* go in for the kill */
X	    else if (kill(procnum, signum) == -1)
X	    {
X		/* chalk up an error */
X		ERROR(str, errno);
X	    }
X	}
X    } while ((str = next_field(str)) != NULL);
X
X    /* return appropriate error string */
X    return(err_string());
X}
X
X/*
X *  renice_procs(str) - change the "nice" of processes, much like the
X *		"renice" command does; invoked in response to 'r'.
X */
X
Xchar *renice_procs(str)
X
Xchar *str;
X
X{
X    register char negate;
X    int prio;
X    int procnum;
X    int uid;
X
X    ERR_RESET;
X    uid = getuid();
X
X    /* allow for negative priority values */
X    if ((negate = (*str == '-')) != 0)
X    {
X	/* move past the minus sign */
X	str++;
X    }
X
X    /* use procnum as a temporary holding place and get the number */
X    procnum = scanint(str, &prio);
X
X    /* negate if necessary */
X    if (negate)
X    {
X	prio = -prio;
X    }
X
X#if defined(PRIO_MIN) && defined(PRIO_MAX)
X    /* check for validity */
X    if (procnum == -1 || prio < PRIO_MIN || prio > PRIO_MAX)
X    {
X	return(" bad priority value");
X    }
X#endif
X
X    /* move to the first process number */
X    if ((str = next_field(str)) == NULL)
X    {
X	return(" no processes specified");
X    }
X
X    /* loop thru the process numbers, renicing each one */
X    do
X    {
X	if (scanint(str, &procnum) == -1)
X	{
X	    ERROR(str, 0);
X	}
X
X	/* check process owner if we're not root */
X	else if (uid && (uid != proc_owner(procnum)))
X	{
X	    ERROR(str, EACCES);
X	}
X	else if (setpriority(PRIO_PROCESS, procnum, prio) == -1)
X	{
X	    ERROR(str, errno);
X	}
X    } while ((str = next_field(str)) != NULL);
X
X    /* return appropriate error string */
X    return(err_string());
X}
X
END_OF_FILE
if test 10459 -ne `wc -c <'top-3.4/commands.c'`; then
    echo shar: \"'top-3.4/commands.c'\" unpacked with wrong size!
fi
# end of 'top-3.4/commands.c'
fi
if test -f 'top-3.4/top.X' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'top-3.4/top.X'\"
else
echo shar: Extracting \"'top-3.4/top.X'\" \(10307 characters\)
sed "s/^X//" >'top-3.4/top.X' <<'END_OF_FILE'
X.\" NOTE:  changes to the manual page for "top" should be made in the
X.\"        file "top.X" and NOT in the file "top.1".
X.nr N %topn%
X.nr D %delay%
X.TH TOP 1 Local
X.UC 4
X.SH NAME
Xtop \- display and update information about the top cpu processes
X.SH SYNOPSIS
X.B top
X[
X.B \-SbiInqu
X] [
X.BI \-d count
X] [
X.BI \-s time
X] [
X.BI \-o field
X] [
X.BI \-U username
X] [
X.I number
X]
X.SH DESCRIPTION
X.\" This defines appropriate quote strings for nroff and troff
X.ds lq \&"
X.ds rq \&"
X.if t .ds lq ``
X.if t .ds rq ''
X.\" Just in case these number registers aren't set yet...
X.if \nN==0 .nr N 10
X.if \nD==0 .nr D 5
X.I Top
Xdisplays the top
X.if !\nN==-1 \nN
Xprocesses on the system and periodically updates this information.
X.if \nN==-1 \
X\{\
XIf standard output is an intelligent terminal (see below) then
Xas many processes as will fit on the terminal screen are displayed
Xby default.  Otherwise, a good number of them are shown (around 20).
X.\}
XRaw cpu percentage is used to rank the processes.  If
X.I number
Xis given, then the top
X.I number
Xprocesses will be displayed instead of the default.
X.PP
X.I Top
Xmakes a distinction between terminals that support advanced capabilities
Xand those that do not.  This
Xdistinction affects the choice of defaults for certain options.  In the
Xremainder of this document, an \*(lqintelligent\*(rq terminal is one that
Xsupports cursor addressing, clear screen, and clear to end of line.
XConversely, a \*(lqdumb\*(rq terminal is one that does not support such
Xfeatures.  If the output of
X.I top
Xis redirected to a file, it acts as if it were being run on a dumb
Xterminal.
X.SH OPTIONS
X.TP
X.B \-S
XShow system processes in the display.  Normally, system processes such as
Xthe pager and the swapper are not shown.  This option makes them visible.
X.TP
X.B \-b
XUse \*(lqbatch\*(rq mode.  In this mode, all input from the terminal is
Xignored.  Interrupt characters (such as ^C and ^\e) still have an effect.
XThis is the default on a dumb terminal, or when the output is not a terminal.
X.TP
X.B \-i
XUse \*(lqinteractive\*(rq mode.  In this mode, any input is immediately
Xread for processing.  See the section on \*(lqInteractive Mode\*(rq
Xfor an explanation of
Xwhich keys perform what functions.  After the command is processed, the
Xscreen will immediately be updated, even if the command was not
Xunderstood.  This mode is the default when standard output is an
Xintelligent terminal.
X.TP
X.B \-I
XDo not display idle processes.
XBy default, top displays both active and idle processes.
X.TP
X.B \-n
XUse \*(lqnon-interactive\*(rq mode.  This is indentical to \*(lqbatch\*(rq
Xmode.
X.TP
X.B \-q
XRenice
X.I top
Xto -20 so that it will run faster.  This can be used when the system is
Xbeing very sluggish to improve the possibility of discovering the problem.
XThis option can only be used by root.
X.TP
X.B \-u
XDo not take the time to map uid numbers to usernames.  Normally,
X.I top
Xwill read as much of the file \*(lq/etc/passwd\*(rq as is necessary to map
Xall the user id numbers it encounters into login names.  This option
Xdisables all that, while possibly decreasing execution time.  The uid
Xnumbers are displayed instead of the names.
X.TP
X.BI \-d count
XShow only
X.I count
Xdisplays, then exit.  A display is considered to be one update of the
Xscreen.  This option allows the user to select the number of displays he
Xwants to see before
X.I top
Xautomatically exits.  For intelligent terminals, no upper limit
Xis set.  The default is 1 for dumb terminals.
X.TP
X.BI \-s time
XSet the delay between screen updates to
X.I time
Xseconds.  The default delay between updates is \nD seconds.
X.TP
X.BI \-o field
XSort the process display area on the specified field.  The field name is
Xthe name of the column as seen in the output, but in lower case.  Likely
Xvalues are \*(lqcpu\*(rq, \*(lqsize\*(rq, \*(lqres\*(rq, and \*(lqtime\*(rq,
Xbut may vary on different operating systems.  Note that
Xnot all operating systems support this option.
X.TP
X.BI \-U username
XShow only those processes owned by
X.IR username .
XThis option currently only accepts usernames and will not understand
Xuid numbers.
X.PP
XBoth
X.I count
Xand
X.I number
Xfields can be specified as \*(lqinfinite\*(rq, indicating that they can
Xstretch as far as possible.  This is accomplished by using any proper
Xprefix of the keywords
X\*(lqinfinity\*(rq,
X\*(lqmaximum\*(rq,
Xor
X\*(lqall\*(rq.
XThe default for
X.I count
Xon an intelligent terminal is, in fact,
X.BI infinity .
X.PP
XThe environment variable
X.B TOP
Xis examined for options before the command line is scanned.  This enables
Xa user to set his or her own defaults.  The number of processes to display
Xcan also be specified in the environment variable
X.BR TOP .
XThe options
X.BR \-I ,
X.BR \-S ,
Xand
X.B \-u
Xare actually toggles.  A second specification of any of these options
Xwill negate the first.  Thus a user who has the environment variable
X.B TOP
Xset to \*(lq\-I\*(rq may use the command \*(lqtop \-I\*(rq to see idle processes.
X.SH "INTERACTIVE MODE"
XWhen
X.I top
Xis running in \*(lqinteractive mode\*(rq, it reads commands from the
Xterminal and acts upon them accordingly.  In this mode, the terminal is
Xput in \*(lqCBREAK\*(rq, so that a character will be
Xprocessed as soon as it is typed.  Almost always, a key will be
Xpressed when
X.I top
Xis between displays; that is, while it is waiting for
X.I time
Xseconds to elapse.  If this is the case, the command will be
Xprocessed and the display will be updated immediately thereafter
X(reflecting any changes that the command may have specified).  This
Xhappens even if the command was incorrect.  If a key is pressed while 
X.I top
Xis in the middle of updating the display, it will finish the update and
Xthen process the command.  Some commands require additional information,
Xand the user will be prompted accordingly.  While typing this information
Xin, the user's erase and kill keys (as set up by the command
X.IR stty )
Xare recognized, and a newline terminates the input.
X.PP
XThese commands are currently recognized (^L refers to control-L):
X.TP
X.B ^L
XRedraw the screen.
X.IP "\fBh\fP\ or\ \fB?\fP"
XDisplay a summary of the commands (help screen).
X.TP
X.B q
XQuit
X.IR top.
X.TP
X.B d
XChange the number of displays to show (prompt for new number).
XRemember that the next display counts as one, so typing
X.B d1
Xwill make
X.I top
Xshow one final display and then immediately exit.
X.TP
X.B n or #
XChange the number of processes to display (prompt for new number).
X.TP
X.B s
XChange the number of seconds to delay between displays
X(prompt for new number).
X.TP
X.B k
XSend a signal (\*(lqkill\*(rq by default) to a list of processes.  This
Xacts similarly to the command
X.IR kill (1)).
X.TP
X.B r
XChange the priority (the \*(lqnice\*(rq) of a list of processes.
XThis acts similarly to the command
X.IR renice (8)).
X.TP
X.B u
XDisplay only processes owned by a specific username (prompt for username).
XIf the username specified is simply \*(lq+\*(rq, then processes belonging
Xto all users will be displayed.
X.TP
X.B e
XDisplay a list of system errors (if any) generated by the last
X.BR k ill
Xor
X.BR r enice
Xcommand.
X.TP
X.B i
X(or
X.BR I)
XToggle the display of idle processes.
X.SH "THE DISPLAY"
XThe actual display varies depending on the specific variant of Unix
Xthat the machine is running.  This description may not exactly match
Xwhat is seen by top running on this particular machine.  Differences
Xare listed at the end of this manual entry.
X.PP
XThe top few lines of the display show general information
Xabout the state of the system, including
Xthe last process id assigned to a process (on most systems),
Xthe three load averages,
Xthe current time,
Xthe number of existing processes,
Xthe number of processes in each state
X(sleeping, running, starting, zombies, and stopped),
Xand a percentage of time spent in each of the processor states
X(user, nice, system, and idle).
XIt also includes information about physial and virtual memory allocation.
X.PP
XThe remainder of the screen displays information about individual
Xprocesses.  This display is similar in spirit to
X.IR ps (1)
Xbut it is not exactly the same.  PID is the process id, USERNAME is the name
Xof the process's owner (if
X.B \-u
Xis specified, a UID column will be substituted for USERNAME),
XPRI is the current priority of the process,
XNICE is the nice amount (in the range \-20 to 20),
XSIZE is the total size of the process (text, data, and stack),
XRES is the current amount of resident memory (both SIZE and RES are
Xgiven in kilobytes),
XSTATE is the current state (one of \*(lqsleep\*(rq, \*(lqWAIT\*(rq,
X\*(lqrun\*(rq, \*(lqidl\*(rq, \*(lqzomb\*(rq, or \*(lqstop\*(rq),
XTIME is the number of system and user cpu seconds that the process has used,
XWCPU, when displayed, is the weighted cpu percentage (this is the same
Xvalue that
X.IR ps (1)
Xdisplays as CPU),
XCPU is the raw percentage and is the field that is sorted to determine
Xthe order of the processes, and
XCOMMAND is the name of the command that the process is currently running
X(if the process is swapped out, this column is marked \*(lq<swapped>\*(rq).
X.SH NOTES
XThe \*(lqABANDONED\*(rq state (known in the kernel as \*(lqSWAIT\*(rq) was
Xabandoned, thus the name.  A process should never end up in this state.
X.SH AUTHOR
XWilliam LeFebvre, EECS Department, Northwestern University
X.SH ENVIRONMENT
X.DT
XTOP	user-configurable defaults for options.
X.SH FILES
X.DT
X/dev/kmem		kernel memory
X.br
X/dev/mem		physical memory
X.br
X/etc/passwd		used to map uid numbers to user names
X.br
X/vmunix		system image
X.SH BUGS
XDon't shoot me, but the default for
X.B \-I
Xhas changed once again.  So many people were confused by the fact that
X.I top
Xwasn't showing them all the processes that I have decided to make the
Xdefault behavior show idle processes, just like it did in version 2.
XBut to appease folks who can't stand that behavior, I have added the
Xability to set \*(lqdefault\*(rq options in the environment variable
X.B TOP
X(see the OPTIONS section).  Those who want the behavior that version
X3.0 had need only set the environment variable
X.B TOP
Xto \*(lq\-I\*(rq.
X.PP
XThe command name for swapped processes should be tracked down, but this
Xwould make the program run slower.
X.PP
XAs with
X.IR ps (1),
Xthings can change while
X.I top
Xis collecting information for an update.  The picture it gives is only a
Xclose approximation to reality.
X.SH "SEE ALSO"
Xkill(1),
Xps(1),
Xstty(1),
Xmem(4),
Xrenice(8)
END_OF_FILE
if test 10307 -ne `wc -c <'top-3.4/top.X'`; then
    echo shar: \"'top-3.4/top.X'\" unpacked with wrong size!
fi
# end of 'top-3.4/top.X'
fi
if test -f 'top-3.4/utils.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'top-3.4/utils.c'\"
else
echo shar: Extracting \"'top-3.4/utils.c'\" \(10192 characters\)
sed "s/^X//" >'top-3.4/utils.c' <<'END_OF_FILE'
X/*
X *  Top users/processes display for Unix
X *  Version 3
X *
X *  This program may be freely redistributed,
X *  but this entire comment MUST remain intact.
X *
X *  Copyright (c) 1984, 1989, William LeFebvre, Rice University
X *  Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
X */
X
X/*
X *  This file contains various handy utilities used by top.
X */
X
X#include "top.h"
X#include "os.h"
X
Xint atoiwi(str)
X
Xchar *str;
X
X{
X    register int len;
X
X    len = strlen(str);
X    if (len != 0)
X    {
X	if (strncmp(str, "infinity", len) == 0 ||
X	    strncmp(str, "all",      len) == 0 ||
X	    strncmp(str, "maximum",  len) == 0)
X	{
X	    return(Infinity);
X	}
X	else if (str[0] == '-')
X	{
X	    return(Invalid);
X	}
X	else
X	{
X	    return(atoi(str));
X	}
X    }
X    return(0);
X}
X
X/*
X *  itoa - convert integer (decimal) to ascii string for positive numbers
X *  	   only (we don't bother with negative numbers since we know we
X *	   don't use them).
X */
X
X				/*
X				 * How do we know that 16 will suffice?
X				 * Because the biggest number that we will
X				 * ever convert will be 2^32-1, which is 10
X				 * digits.
X				 */
X
Xchar *itoa(val)
X
Xregister int val;
X
X{
X    register char *ptr;
X    static char buffer[16];	/* result is built here */
X    				/* 16 is sufficient since the largest number
X				   we will ever convert will be 2^32-1,
X				   which is 10 digits. */
X
X    ptr = buffer + sizeof(buffer);
X    *--ptr = '\0';
X    if (val == 0)
X    {
X	*--ptr = '0';
X    }
X    else while (val != 0)
X    {
X	*--ptr = (val % 10) + '0';
X	val /= 10;
X    }
X    return(ptr);
X}
X
X/*
X *  itoa7(val) - like itoa, except the number is right justified in a 7
X *	character field.  This code is a duplication of itoa instead of
X *	a front end to a more general routine for efficiency.
X */
X
Xchar *itoa7(val)
X
Xregister int val;
X
X{
X    register char *ptr;
X    static char buffer[16];	/* result is built here */
X    				/* 16 is sufficient since the largest number
X				   we will ever convert will be 2^32-1,
X				   which is 10 digits. */
X
X    ptr = buffer + sizeof(buffer);
X    *--ptr = '\0';
X    if (val == 0)
X    {
X	*--ptr = '0';
X    }
X    else while (val != 0)
X    {
X	*--ptr = (val % 10) + '0';
X	val /= 10;
X    }
X    while (ptr > buffer + sizeof(buffer) - 7)
X    {
X	*--ptr = ' ';
X    }
X    return(ptr);
X}
X
X/*
X *  digits(val) - return number of decimal digits in val.  Only works for
X *	positive numbers.  If val <= 0 then digits(val) == 0.
X */
X
Xint digits(val)
X
Xint val;
X
X{
X    register int cnt = 0;
X
X    while (val > 0)
X    {
X	cnt++;
X	val /= 10;
X    }
X    return(cnt);
X}
X
X/*
X *  strecpy(to, from) - copy string "from" into "to" and return a pointer
X *	to the END of the string "to".
X */
X
Xchar *strecpy(to, from)
X
Xregister char *to;
Xregister char *from;
X
X{
X    while ((*to++ = *from++) != '\0');
X    return(--to);
X}
X
X/*
X * string_index(string, array) - find string in array and return index
X */
X
Xint string_index(string, array)
X
Xchar *string;
Xchar **array;
X
X{
X    register int i = 0;
X
X    while (*array != NULL)
X    {
X	if (strcmp(string, *array) == 0)
X	{
X	    return(i);
X	}
X	array++;
X	i++;
X    }
X    return(-1);
X}
X
X/*
X * argparse(line, cntp) - parse arguments in string "line", separating them
X *	out into an argv-like array, and setting *cntp to the number of
X *	arguments encountered.  This is a simple parser that doesn't understand
X *	squat about quotes.
X */
X
Xchar **argparse(line, cntp)
X
Xchar *line;
Xint *cntp;
X
X{
X    register char *from;
X    register char *to;
X    register int cnt;
X    register int ch;
X    int length;
X    int lastch;
X    register char **argv;
X    char **argarray;
X    char *args;
X
X    /* unfortunately, the only real way to do this is to go thru the
X       input string twice. */
X
X    /* step thru the string counting the white space sections */
X    from = line;
X    lastch = cnt = length = 0;
X    while ((ch = *from++) != '\0')
X    {
X	length++;
X	if (ch == ' ' && lastch != ' ')
X	{
X	    cnt++;
X	}
X	lastch = ch;
X    }
X
X    /* add three to the count:  one for the initial "dummy" argument,
X       one for the last argument and one for NULL */
X    cnt += 3;
X
X    /* allocate a char * array to hold the pointers */
X    argarray = (char **)malloc(cnt * sizeof(char *));
X
X    /* allocate another array to hold the strings themselves */
X    args = (char *)malloc(length+2);
X
X    /* initialization for main loop */
X    from = line;
X    to = args;
X    argv = argarray;
X    lastch = '\0';
X
X    /* create a dummy argument to keep getopt happy */
X    *argv++ = to;
X    *to++ = '\0';
X    cnt = 2;
X
X    /* now build argv while copying characters */
X    *argv++ = to;
X    while ((ch = *from++) != '\0')
X    {
X	if (ch != ' ')
X	{
X	    if (lastch == ' ')
X	    {
X		*to++ = '\0';
X		*argv++ = to;
X		cnt++;
X	    }
X	    *to++ = ch;
X	}
X	lastch = ch;
X    }
X    *to++ = '\0';
X
X    /* set cntp and return the allocated array */
X    *cntp = cnt;
X    return(argarray);
X}
X
X/*
X *  percentages(cnt, out, new, old, diffs) - calculate percentage change
X *	between array "old" and "new", putting the percentages i "out".
X *	"cnt" is size of each array and "diffs" is used for scratch space.
X *	The array "old" is updated on each call.
X *	The routine assumes modulo arithmetic.  This function is especially
X *	useful on BSD mchines for calculating cpu state percentages.
X */
X
Xlong percentages(cnt, out, new, old, diffs)
X
Xint cnt;
Xint *out;
Xregister long *new;
Xregister long *old;
Xlong *diffs;
X
X{
X    register int i;
X    register long change;
X    register long total_change;
X    register long *dp;
X    long half_total;
X
X    /* initialization */
X    total_change = 0;
X    dp = diffs;
X
X    /* calculate changes for each state and the overall change */
X    for (i = 0; i < cnt; i++)
X    {
X	if ((change = *new - *old) < 0)
X	{
X	    /* this only happens when the counter wraps */
X	    change = (int)
X		((unsigned long)*new-(unsigned long)*old);
X	}
X	total_change += (*dp++ = change);
X	*old++ = *new++;
X    }
X
X    /* avoid divide by zero potential */
X    if (total_change == 0)
X    {
X	total_change = 1;
X    }
X
X    /* calculate percentages based on overall change, rounding up */
X    half_total = total_change / 2l;
X    for (i = 0; i < cnt; i++)
X    {
X	*out++ = (int)((*diffs++ * 1000 + half_total) / total_change);
X    }
X
X    /* return the total in case the caller wants to use it */
X    return(total_change);
X}
X
X/*
X * errmsg(errnum) - return an error message string appropriate to the
X *           error number "errnum".  This is a substitute for the System V
X *           function "strerror" with one important difference:  the string
X *           returned by this function does NOT end in a newline!
X *           N.B.:  there appears to be no reliable way to determine if
X *           "strerror" exists at compile time, so I make do by providing
X *           something of similar functionality.
X */
X
X/* externs referenced by errmsg */
X
Xextern char *sys_errlist[];
Xextern int sys_nerr;
X
Xchar *errmsg(errnum)
X
Xint errnum;
X
X{
X    if (errnum > 0 && errnum < sys_nerr)
X    {
X	return(sys_errlist[errnum]);
X    }
X    return("No error");
X}
X
X/* format_time(seconds) - format number of seconds into a suitable
X *		display that will fit within 6 characters.  Note that this
X *		routine builds its string in a static area.  If it needs
X *		to be called more than once without overwriting previous data,
X *		then we will need to adopt a technique similar to the
X *		one used for format_k.
X */
X
X/* Explanation:
X   We want to keep the output within 6 characters.  For low values we use
X   the format mm:ss.  For values that exceed 999:59, we switch to a format
X   that displays hours and fractions:  hhh.tH.  For values that exceed
X   999.9, we use hhhh.t and drop the "H" designator.  For values that
X   exceed 9999.9, we use "???".
X */
X
Xchar *format_time(seconds)
X
Xlong seconds;
X
X{
X    register int value;
X    register int digit;
X    register char *ptr;
X    static char result[10];
X
X    /* sanity protection */
X    if (seconds < 0 || seconds > (99999l * 360l))
X    {
X	strcpy(result, "   ???");
X    }
X    else if (seconds >= (1000l * 60l))
X    {
X	/* alternate (slow) method displaying hours and tenths */
X	sprintf(result, "%5.1fH", (double)seconds / (double)(60l * 60l));
X
X	/* It is possible that the sprintf took more than 6 characters.
X	   If so, then the "H" appears as result[6].  If not, then there
X	   is a \0 in result[6].  Either way, it is safe to step on.
X	 */
X	result[6] = '\0';
X    }
X    else
X    {
X	/* standard method produces MMM:SS */
X	/* we avoid printf as must as possible to make this quick */
X	sprintf(result, "%3d:%02d", seconds / 60l, seconds % 60l);
X    }
X    return(result);
X}
X
X/*
X * format_k(amt) - format a kilobyte memory value, returning a string
X *		suitable for display.  Returns a pointer to a static
X *		area that changes each call.  "amt" is converted to a
X *		string with a trailing "K".  If "amt" is 10000 or greater,
X *		then it is formatted as megabytes (rounded) with a
X *		trailing "M".
X */
X
X/*
X * Compromise time.  We need to return a string, but we don't want the
X * caller to have to worry about freeing a dynamically allocated string.
X * Unfortunately, we can't just return a pointer to a static area as one
X * of the common uses of this function is in a large call to sprintf where
X * it might get invoked several times.  Our compromise is to maintain an
X * array of strings and cycle thru them with each invocation.  We make the
X * array large enough to handle the above mentioned case.  The constant
X * NUM_STRINGS defines the number of strings in this array:  we can tolerate
X * up to NUM_STRINGS calls before we start overwriting old information.
X * Keeping NUM_STRINGS a power of two will allow an intelligent optimizer
X * to convert the modulo operation into something quicker.  What a hack!
X */
X
X#define NUM_STRINGS 8
X
Xchar *format_k(amt)
X
Xint amt;
X
X{
X    static char retarray[NUM_STRINGS][16];
X    static int index = 0;
X    register char *p;
X    register char *ret;
X    register char tag = 'K';
X
X    p = ret = retarray[index];
X    index = (index + 1) % NUM_STRINGS;
X
X    if (amt >= 10000)
X    {
X	amt = (amt + 512) / 1024;
X	tag = 'M';
X	if (amt >= 10000)
X	{
X	    amt = (amt + 512) / 1024;
X	    tag = 'G';
X	}
X    }
X
X    p = strecpy(p, itoa(amt));
X    *p++ = tag;
X    *p = '\0';
X
X    return(ret);
X}
END_OF_FILE
if test 10192 -ne `wc -c <'top-3.4/utils.c'`; then
    echo shar: \"'top-3.4/utils.c'\" unpacked with wrong size!
fi
# end of 'top-3.4/utils.c'
fi
echo shar: End of archive 3 \(of 22\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 22 archives.
    echo "Now read README and INSTALL, then run Configure"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

