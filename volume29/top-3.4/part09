Newsgroups: comp.sources.unix
From: wnl@groupsys.com (William Lefebvre)
Subject: v29i110: top-3.4 - top process display, V3.4, Part09/22
References: <1.841608857.22962@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: wnl@groupsys.com (William Lefebvre)
Posting-Number: Volume 29, Issue 110
Archive-Name: top-3.4/part09

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 9 (of 22)."
# Contents:  top-3.4/machine/m_aix41.c top-3.4/machine/m_aux3.c
#   top-3.4/machine/m_netbsd08.c
# Wrapped by lefebvre@acapulco on Fri Aug 30 12:35:50 1996
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'top-3.4/machine/m_aix41.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'top-3.4/machine/m_aix41.c'\"
else
echo shar: Extracting \"'top-3.4/machine/m_aix41.c'\" \(17104 characters\)
sed "s/^X//" >'top-3.4/machine/m_aix41.c' <<'END_OF_FILE'
X/*
X * top - a top users display for Unix
X *
X * SYNOPSIS:  PowerPC running AIX 4.1.2.0
X *
X * DESCRIPTION:
X * This is the machine-dependent module for AIX 4.1.2.0
X * It is currenlty only tested on PowerPC architectures.
X *
X * TERMCAP: -lcurses
X *
X * CFLAGS: -DORDER
X *
X * AUTHOR:  Joep Vesseur <joep@fwi.uva.nl>
X */
X
X#include <stdlib.h>
X#include <stdio.h>
X#include <fcntl.h>
X#include <nlist.h>
X#include <sys/sysinfo.h>
X#include <procinfo.h>
X#include <sys/proc.h>
X#include <pwd.h>
X#include "top.h"
X#include "machine.h"
X
X
X#define PROCRESS(p) (((p)->pi_trss + (p)->pi_drss)*4)
X#define PROCSIZE(p) (((p)->pi_tsize/1024+(p)->pi_dvm)*4)
X#define PROCTIME(pi) (pi->pi_ru.ru_utime.tv_sec + pi->pi_ru.ru_stime.tv_sec)
X
X
X/*
X * structure definition taken from 'monitor' by Jussi Maki (jmaki@hut.fi)
X */
Xstruct vmker {
X    uint n0,n1,n2,n3,n4,n5,n6,n7,n8;
X    uint totalmem;
X    uint badmem; /* this is used in RS/6000 model 220 */
X    uint freemem;
X    uint n12;
X    uint numperm;   /* this seems to keep other than text and data segment 
X                       usage; name taken from /usr/lpp/bos/samples/vmtune.c */
X    uint totalvmem,freevmem;
X    uint n15, n16, n17, n18, n19;
X};
X
X
X#define KMEM "/dev/kmem"
X
X/* Indices in the nlist array */
X#define X_AVENRUN       0
X#define X_SYSINFO       1
X#define X_VMKER         2
X#define X_PROC          3
X#define X_V             4
X
Xstatic struct nlist nlst[] = {
X    { "avenrun", 0, 0, 0, 0, 0 }, /* 0 */
X    { "sysinfo", 0, 0, 0, 0, 0 }, /* 1 */
X    { "vmker",   0, 0, 0, 0, 0 }, /* 2 */
X    { "proc",    0, 0, 0, 0, 0 }, /* 3 */
X    { "v",       0, 0, 0, 0, 0 }, /* 4 */
X    {  NULL, 0, 0, 0, 0, 0 }
X};
X
X
X/* get_process_info returns handle. definition is here */
Xstruct handle
X{
X	struct procsinfo **next_proc;
X	int remaining;
X};
X
X/*
X *  These definitions control the format of the per-process area
X */
Xstatic char header[] =
X  "  PID X        PRI NICE   SIZE   RES STATE   TIME   WCPU    CPU COMMAND";
X/* 0123456   -- field to fill in starts at header+6 */
X#define UNAME_START 6
X
X#define Proc_format \
X	"%5d %-8.8s %3d %4d %5d%c %4d%c %-5s %6s %5.2f%% %5.2f%% %.14s%s"
X
X
X/* these are for detailing the process states */
Xint process_states[9];
Xchar *procstatenames[] = {
X    " none, ", " sleeping, ", " state2, ", " runnable, ",
X    " idle, ", " zombie, ", " stopped, ", " running, ", " swapped, ",
X    NULL
X};
X
X
X/* these are for detailing the cpu states */
Xint cpu_states[4];
Xchar *cpustatenames[] = {
X    "idle", "user", "kernel", "wait",
X    NULL
X};
X
X/* these are for detailing the memory statistics */
Xint memory_stats[7];
Xchar *memorynames[] = {
X    "M Total. Real: ", "M, ", "M Free, ", "M Buffers. Virtual: ", "M, ", "M Free, ", NULL
X};
X#define M_TOTAL	   0
X#define M_REAL     1
X#define M_REALFREE 2
X#define M_BUFFERS  3
X#define M_VIRTUAL  4
X#define M_VIRTFREE 5
X
Xchar *state_abbrev[] = {
X    "", "sleep", "", "", "sleep", "zomb", "stop", "run", "swap"
X};
X
X/* sorting orders. first is default */
Xchar *ordernames[] = {
X    "cpu", "size", "res", "time", "pri", NULL
X};
X
X/* compare routines */
Xint compare_cpu(), compare_size(), compare_res(), compare_time(), 
X    compare_prio();
X
Xint (*proc_compares[])() = {
X    compare_cpu,
X    compare_size,
X    compare_res,
X    compare_time,
X    compare_prio,
X    NULL
X};
X
X/* useful externals */
Xextern int errno;
Xextern char *sys_errlist[];
Xlong lseek();
Xlong time();
Xlong percentages();
X
X
X/* useful globals */
Xint kmem;			/* file descriptor */
X
X/* offsets in kernel */
Xstatic unsigned long avenrun_offset;
Xstatic unsigned long sysinfo_offset;
Xstatic unsigned long vmker_offset;
Xstatic unsigned long proc_offset;
Xstatic unsigned long v_offset;
X
X/* used for calculating cpu state percentages */
Xstatic long cp_time[CPU_NTIMES];
Xstatic long cp_old[CPU_NTIMES];
Xstatic long cp_diff[CPU_NTIMES];
X
X/* the runqueue length is a cumulative value. keep old value */
Xlong old_runque;
X
X/* process info */
Xstruct var v_info;		/* to determine nprocs */
Xint nprocs;			/* maximum nr of procs in proctab */
Xint ncpus;			/* nr of cpus installed */
X
Xint ptsize;			/* size of process table in bytes */
Xstruct proc *p_proc;		/* a copy of the process table */
Xstruct procsinfo *p_info;	/* needed for vm and ru info */
Xstruct procsinfo **pref;	/* processes selected for display */
Xint pref_len;			/* number of processes selected */
X
X/* needed to calculate WCPU */
Xunsigned long curtime;
X
X
X/*
X * Initialize globals, get kernel offsets and stuff...
X */
Xmachine_init(statics)
X    struct statics *statics;
X{
X    if ((kmem = open(KMEM, O_RDONLY)) == -1) {
X	perror(KMEM);
X	return -1;
X    }
X
X    /* get kernel symbol offsets */
X    if (knlist(nlst, 5, sizeof(struct nlist)) != 0) {
X	perror("knlist");
X	return -1;
X    }
X    avenrun_offset = nlst[X_AVENRUN].n_value;
X    sysinfo_offset = nlst[X_SYSINFO].n_value;
X    vmker_offset   = nlst[X_VMKER].n_value;
X    proc_offset    = nlst[X_PROC].n_value;
X    v_offset       = nlst[X_V].n_value;
X
X    getkval(v_offset, (caddr_t)&v_info, sizeof v_info, "v");
X
X    ncpus = v_info.v_ncpus;	/* number of cpus */
X    nprocs = PROCMASK(NPROC);
X
X    ptsize = nprocs * sizeof (struct proc);
X    p_proc = (struct proc *)malloc(ptsize);
X    p_info = (struct procsinfo *)malloc(nprocs * sizeof (struct procsinfo));
X    pref = (struct procsinfo **)malloc(nprocs * sizeof (struct procsinfo *));
X
X    if (!p_proc || !p_info || !pref) {
X	fprintf(stderr, "top: not enough memory\n");
X	return -1;
X    }
X
X    statics->procstate_names = procstatenames;
X    statics->cpustate_names = cpustatenames;
X    statics->memory_names = memorynames;
X    statics->order_names = ordernames;
X
X    return(0);
X}
X
X
X
Xchar *format_header(uname_field)
X    register char *uname_field;
X{
X    register char *ptr;
X
X    ptr = header + UNAME_START;
X    while (*uname_field != '\0')
X    {
X	*ptr++ = *uname_field++;
X    }
X
X    return(header);
X}
X
X
X
X
Xget_system_info(si)
X    struct system_info *si;
X{
X    int load_avg[3];
X    struct sysinfo s_info;
X    struct vmker m_info;
X    int i;
X    double total = 0;
X
X    /* get the load avarage array */
X    getkval(avenrun_offset, (caddr_t)load_avg, sizeof load_avg, "avenrun");
X
X    /* get the sysinfo structure */
X    getkval(sysinfo_offset, (caddr_t)&s_info, sizeof s_info, "sysinfo");
X
X    /* get vmker structure */
X    getkval(vmker_offset, (caddr_t)&m_info, sizeof m_info, "vmker");
X
X    /* convert load avarages to doubles */
X    for (i = 0; i < 3; i++)
X	si->load_avg[i] = (double)load_avg[i]/65536.0;
X
X    /* calculate cpu state in percentages */
X    for (i = 0; i < CPU_NTIMES; i++) {
X	cp_old[i] = cp_time[i];
X	cp_time[i] = s_info.cpu[i];
X	cp_diff[i] = cp_time[i] - cp_old[i];
X	total += cp_diff[i];
X    }
X
X    total = total/1000.0;  /* top itself will correct this */
X    for (i = 0; i < CPU_NTIMES; i++) {
X        cpu_states[i] = cp_diff[i] / total;
X    }
X
X    /* calculate memory statistics, scale 4K pages to megabytes */
X#define PAGE_TO_MB(a) ((a)*4/1024)
X    memory_stats[M_TOTAL]    = PAGE_TO_MB(m_info.totalmem+m_info.totalvmem);
X    memory_stats[M_REAL]     = PAGE_TO_MB(m_info.totalmem);
X    memory_stats[M_REALFREE] = PAGE_TO_MB(m_info.freemem);
X    memory_stats[M_BUFFERS]  = PAGE_TO_MB(m_info.numperm);
X    memory_stats[M_VIRTUAL]  = PAGE_TO_MB(m_info.totalvmem);
X    memory_stats[M_VIRTFREE] = PAGE_TO_MB(m_info.freevmem);
X
X    /* runnable processes */
X    process_states[0] = s_info.runque - old_runque;
X    old_runque = s_info.runque;
X
X    si->cpustates = cpu_states;
X    si->memory = memory_stats;
X}
X
Xstatic struct handle handle;
X
Xcaddr_t get_process_info(si, sel, compare)
X    struct system_info *si;
X    struct process_select *sel;
X    int (*compare)();
X{
X    int i, nproc;
X    int active_procs = 0, total_procs = 0;
X    struct procsinfo *pp, **p_pref = pref;
X    unsigned long pctcpu;
X    pid_t procsindex = 0;
X    struct proc *p;
X
X    si->procstates = process_states;
X
X    curtime = time(0);
X
X    /* get the procsinfo structures of all running processes */
X    nproc = getprocs(p_info, sizeof (struct procsinfo), NULL, 0, 
X		     &procsindex, nprocs);
X    if (nproc < 0) {
X	perror("getprocs");
X	exit(1);
X    }
X
X    /* the swapper has no cmd-line attached */
X    strcpy(p_info[0].pi_comm, "swapper");
X    
X    /* get proc table */
X    getkval(proc_offset, (caddr_t)p_proc, ptsize, "proc");
X
X    memset(process_states, 0, sizeof process_states);
X
X    /* build a list of pointers to processes to show. walk through the
X     * list of procsinfo structures instead of the proc table since the
X     * mapping of procsinfo -> proctable is easy, the other way around
X     * is cumbersome
X     */
X    for (pp = p_info, i = 0; i < nproc; pp++, i++) {
X
X	p = &p_proc[PROCMASK(pp->pi_pid)];
X
X	/* AIX marks all runnable processes as ACTIVE. We want to know
X	   which processes are sleeping, so check used cpu ticks and adjust
X	   status field accordingly
X	 */
X	if (p->p_stat == SACTIVE && p->p_cpticks == 0)
X	    p->p_stat = SIDL;
X
X        if (pp->pi_state && (sel->system || ((pp->pi_flags & SKPROC) == 0))) {
X	    total_procs++;
X	    process_states[p->p_stat]++;
X	    if ( (pp->pi_state != SZOMB) &&
X		(sel->idle || p->p_cpticks != 0 || (p->p_stat == SACTIVE))
X		&& (sel->uid == -1 || pp->pi_uid == (uid_t)sel->uid)) {
X                *p_pref++ = pp;
X		active_procs++;
X	    }
X	}
X    }   
X
X    /* the pref array now holds pointers to the procsinfo structures in
X     * the p_info array that were selected for display
X     */
X
X    /* sort if requested */
X    if (compare != NULL)
X	qsort((char *)pref, active_procs, sizeof (struct procsinfo *), 
X	      compare);
X    
X    si->last_pid = -1;		/* no way to figure out last used pid */
X    si->p_total = total_procs;
X    si->p_active = pref_len = active_procs;
X
X    handle.next_proc = pref;
X    handle.remaining = active_procs;
X
X    return((caddr_t)&handle);
X}
X
Xchar fmt[128];		/* static area where result is built */
X
X/* define what weighted cpu is. use definition of %CPU from 'man ps(1)' */
X#define weighted_cpu(pp) (PROCTIME(pp) == 0 ? 0.0 : \
X                        (((PROCTIME(pp)*100.0)/(curtime-pi->pi_start)/ncpus)))
X#define double_pctcpu(p) ((double)p->p_pctcpu/(double)FLT_MODULO)
X
Xchar *format_next_process(handle, get_userid)
X    caddr_t handle;
X    char *(*get_userid)();
X{
X    register struct handle *hp;
X    register struct procsinfo *pi;
X    register struct proc *p;
X    char *uname;
X    long cpu_time;
X    int proc_size, proc_ress;
X    char size_unit = 'K';
X    char ress_unit = 'K';
X
X    hp = (struct handle *)handle;
X    if (hp->remaining == 0) {	/* safe guard */
X	fmt[0] = '\0';
X	return fmt;
X    }
X    pi = *(hp->next_proc++);
X    hp->remaining--;
X    p = &p_proc[PROCMASK(pi->pi_pid)];
X
X    cpu_time = PROCTIME(pi);
X
X    /* we disply sizes up to 10M in KiloBytes, beyond 10M in MegaBytes */
X    if ((proc_size = (pi->pi_tsize/1024+pi->pi_dvm)*4) > 10240) {
X	proc_size /= 1024;
X	size_unit = 'M';
X    }
X    if ((proc_ress = (pi->pi_trss + pi->pi_drss)*4) > 10240) {
X	proc_ress /= 1024;
X	ress_unit = 'M';
X    }
X
X    sprintf(fmt, Proc_format ,
X            pi->pi_pid,					  /* PID */
X            (*get_userid)(pi->pi_uid),			  /* login name */
X            getpriority(PRIO_PROCESS, pi->pi_pid),
X	    EXTRACT_NICE(p),				  /* fixed or vari */
X            proc_size,					  /* size */
X            size_unit,					  /* K or M */
X            proc_ress,					  /* resident */
X            ress_unit,					  /* K or M */
X            state_abbrev[p->p_stat],			  /* process state */
X            format_time(cpu_time),			  /* time used */
X	    weighted_cpu(pi),	                          /* WCPU */
X	    100.0 * double_pctcpu(p),                     /* CPU */
X            printable(pi->pi_comm),                       /* COMM */
X	    (pi->pi_flags & SKPROC) == 0 ? "" : " (sys)"  /* kernel process? */
X	    );
X    return(fmt);
X}
X
X
X/*
X *  getkval(offset, ptr, size, refstr) - get a value out of the kernel.
X *	"offset" is the byte offset into the kernel for the desired value,
X *  	"ptr" points to a buffer into which the value is retrieved,
X *  	"size" is the size of the buffer (and the object to retrieve),
X *  	"refstr" is a reference string used when printing error meessages,
X *	    if "refstr" starts with a '!', then a failure on read will not
X *  	    be fatal (this may seem like a silly way to do things, but I
X *  	    really didn't want the overhead of another argument).
X *  	
X */
Xgetkval(offset, ptr, size, refstr)
X    unsigned long offset;
X    caddr_t ptr;
X    int size;
X    char *refstr;
X{
X    int upper_2gb = 0;
X
X    /* reads above 2Gb are done by seeking to offset%2Gb, and supplying
X     * 1 (opposed to 0) as fourth parameter to readx (see 'man kmem')
X     */
X    if (offset > 1<<31) {
X	upper_2gb = 1;
X	offset &= 0x7fffffff;
X    }
X
X    if (lseek(kmem, offset, SEEK_SET) != offset) {
X	fprintf(stderr, "top: lseek failed\n");
X	exit(-1);
X    }
X
X    if (readx(kmem, ptr, size, upper_2gb) != size) {
X	if (*refstr == '!')
X	    return 0;
X	else {
X	    fprintf(stderr, "top: kvm_read for %s: %s\n", refstr,
X		    sys_errlist[errno]);
X	    exit(-1);
X	}
X    }
X
X    return 1 ;
X}
X    
X/* comparison routine for qsort */
X/*
X * The following code is taken from the solaris module and adjusted
X * for AIX -- JV .
X */
X
X#define ORDERKEY_PCTCPU \
X           if (lresult = p2->p_pctcpu - p1->p_pctcpu, \
X               (result = lresult > 0 ? 1 : lresult < 0 ? -1 : 0) == 0)
X
X#define ORDERKEY_CPTICKS \
X           if ((result = PROCTIME(pi2) - PROCTIME(pi1)) == 0)
X
X
X#define ORDERKEY_STATE \
X           if ((result = sorted_state[p2->p_stat]  \
X                         - sorted_state[p1->p_stat])  == 0)
X
X/* Nice values directly reflect the process' priority, and are always >0 ;-) */
X#define ORDERKEY_PRIO \
X	   if ((result = EXTRACT_NICE(p1) - EXTRACT_NICE(p2)) == 0) 
X
X#define ORDERKEY_RSSIZE \
X           if ((result = PROCRESS(pi2) - PROCRESS(pi1)) == 0)
X#define ORDERKEY_MEM \
X           if ((result = PROCSIZE(pi2) - PROCSIZE(pi1)) == 0)
X
Xstatic unsigned char sorted_state[] =
X{
X    0, /* not used */
X    0,
X    0,
X    0,
X    3,                          /* sleep */
X    1,				/* zombie */
X    4,				/* stop */
X    6,				/* run */
X    2,				/* swap */
X};
X
X/* compare_cpu - the comparison function for sorting by cpu percentage */
X
Xint
Xcompare_cpu(ppi1, ppi2)
X    struct procsinfo **ppi1;
X    struct procsinfo **ppi2;
X{
X    register struct procsinfo *pi1 = *ppi1, *pi2 = *ppi2;
X    register struct proc *p1;
X    register struct proc *p2;
X    register int result;
X    register long lresult;
X
X    p1 = &p_proc[PROCMASK(pi1->pi_pid)];
X    p2 = &p_proc[PROCMASK(pi2->pi_pid)];
X
X    ORDERKEY_PCTCPU
X    ORDERKEY_CPTICKS
X    ORDERKEY_STATE
X    ORDERKEY_PRIO
X    ORDERKEY_RSSIZE
X    ORDERKEY_MEM
X    ;
X
X    return result;
X}
X    
X
X/* compare_size - the comparison function for sorting by total memory usage */
X
Xint
Xcompare_size(ppi1, ppi2)
X    struct procsinfo **ppi1;
X    struct procsinfo **ppi2;
X{
X    register struct procsinfo *pi1 = *ppi1, *pi2 = *ppi2;
X    register struct proc *p1;
X    register struct proc *p2;
X    register int result;
X    register long lresult;
X
X    p1 = &p_proc[PROCMASK(pi1->pi_pid)];
X    p2 = &p_proc[PROCMASK(pi2->pi_pid)];
X
X    ORDERKEY_MEM
X    ORDERKEY_RSSIZE
X    ORDERKEY_PCTCPU
X    ORDERKEY_CPTICKS
X    ORDERKEY_STATE
X    ORDERKEY_PRIO
X    ;
X
X    return result;
X}
X    
X
X/* compare_res - the comparison function for sorting by resident set size */
X
Xint
Xcompare_res(ppi1, ppi2)
X    struct procsinfo **ppi1;
X    struct procsinfo **ppi2;
X{
X    register struct procsinfo *pi1 = *ppi1, *pi2 = *ppi2;
X    register struct proc *p1;
X    register struct proc *p2;
X    register int result;
X    register long lresult;
X
X    p1 = &p_proc[PROCMASK(pi1->pi_pid)];
X    p2 = &p_proc[PROCMASK(pi2->pi_pid)];
X
X    ORDERKEY_RSSIZE
X    ORDERKEY_MEM
X    ORDERKEY_PCTCPU
X    ORDERKEY_CPTICKS
X    ORDERKEY_STATE
X    ORDERKEY_PRIO
X    ;
X
X    return result;
X}
X    
X
X/* compare_time - the comparison function for sorting by total cpu time */
X
Xint
Xcompare_time(ppi1, ppi2)
X    struct procsinfo **ppi1;
X    struct procsinfo **ppi2;
X{
X    register struct procsinfo *pi1 = *ppi1, *pi2 = *ppi2;
X    register struct proc *p1;
X    register struct proc *p2;
X    register int result;
X    register long lresult;
X
X    p1 = &p_proc[PROCMASK(pi1->pi_pid)];
X    p2 = &p_proc[PROCMASK(pi2->pi_pid)];
X
X    ORDERKEY_CPTICKS
X    ORDERKEY_PCTCPU
X    ORDERKEY_STATE
X    ORDERKEY_PRIO
X    ORDERKEY_MEM
X    ORDERKEY_RSSIZE
X    ;
X
X    return result;
X}
X    
X
X/* compare_prio - the comparison function for sorting by cpu percentage */
X
Xint
Xcompare_prio(ppi1, ppi2)
X    struct procsinfo **ppi1;
X    struct procsinfo **ppi2;
X{
X    register struct procsinfo *pi1 = *ppi1, *pi2 = *ppi2;
X    register struct proc *p1;
X    register struct proc *p2;
X    register int result;
X    register long lresult;
X
X    p1 = &p_proc[PROCMASK(pi1->pi_pid)];
X    p2 = &p_proc[PROCMASK(pi2->pi_pid)];
X
X    ORDERKEY_PRIO
X    ORDERKEY_PCTCPU
X    ORDERKEY_CPTICKS
X    ORDERKEY_STATE
X    ORDERKEY_RSSIZE
X    ORDERKEY_MEM
X    ;
X
X    return result;
X}
X    
X
Xproc_owner(pid)
Xint pid;
X{
X   int uid;
X   register struct procsinfo **prefp = pref;
X   register int cnt = pref_len;
X
X   while (--cnt >= 0) {
X       if ((*prefp)->pi_pid == pid)
X	   return (*prefp)->pi_uid;
X       prefp++;
X   }
X   
X   return(-1);
X}
X
END_OF_FILE
if test 17104 -ne `wc -c <'top-3.4/machine/m_aix41.c'`; then
    echo shar: \"'top-3.4/machine/m_aix41.c'\" unpacked with wrong size!
fi
# end of 'top-3.4/machine/m_aix41.c'
fi
if test -f 'top-3.4/machine/m_aux3.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'top-3.4/machine/m_aux3.c'\"
else
echo shar: Extracting \"'top-3.4/machine/m_aux3.c'\" \(17173 characters\)
sed "s/^X//" >'top-3.4/machine/m_aux3.c' <<'END_OF_FILE'
X/*
X * top - a top users display for Unix
X *
X * SYNOPSIS:  a Mac running A/UX version 3.x
X *
X * DESCRIPTION:
X * This is the machine-dependent module for A/UX 3.x.
X * ==
X * Although AUX does not generally have a renice systemcall, it can be
X * implemented by tweeking kernel memory.  While such a simple hack should
X * not be difficult to get right, USE THIS FEATURE AT YOUR OWN RISK!
X * To turn on setpriority emulation, add "-DIMPLEMENT_SETPRIORITY" to
X * the CFLAGS when prompted in the configure script.
X *
X * CFLAGS: -Dclear=clear_scr -DPRIO_PROCESS=0
X *
X * LIBS:
X *
X * AUTHOR:  Richard Henderson <rth@tamu.edu>
X */
X
X
X#include <stddef.h>
X#include <stdio.h>
X#include <string.h>
X#include <errno.h>
X#include <fcntl.h>
X#include <a.out.h>
X#include <sys/types.h>
X#include <sys/signal.h>
X#include <sys/param.h>
X#include <sys/proc.h>
X#include <sys/user.h>
X#include <sys/sysinfo.h>
X#include <sys/var.h>
X#include <sys/swap.h>
X
X#define FSCALE	65536.0
X
X#include "top.h"
X#include "machine.h"
X#include "loadavg.h"
X
X/*=NLIST INFO===========================================================*/
X
X#define X_V		0
X#define X_SYSINFO	1
X#define X_AVENRUN	2
X#define X_MAXMEM	3
X#define X_FREEMEM	4
X#define X_SWAPTAB	5
X#define X_AVAILRMEM	6
X#define X_AVAILSMEM	7
X
Xstatic struct nlist nlst[] = {
X    {"v"},
X    {"sysinfo"},
X    {"avenrun"},
X    {"maxmem"},
X    {"freemem"},
X    {"swaptab"},
X    {0},		/* "availrmem" */
X    {0},		/* "availsmem" */
X    {0}
X};
X
Xstatic int kmem;
Xstatic int mem;
X
Xstatic struct var v;
X
X#define V_OFS		(nlst[X_V].n_value)
X#define SYSINFO_OFS	(nlst[X_SYSINFO].n_value)
X#define AVENRUN_OFS	(nlst[X_AVENRUN].n_value)
X#define MAXMEM_OFS	(nlst[X_MAXMEM].n_value)
X#define FREEMEM_OFS	(nlst[X_FREEMEM].n_value)
X#define SWAPTAB_OFS	(nlst[X_SWAPTAB].n_value)
X#define AVAILRMEM_OFS	(nlst[X_AVAILRMEM].n_value)
X#define AVAILSMEM_OFS	(nlst[X_AVAILSMEM].n_value)
X
X/*=SYSTEM STATE INFO====================================================*/
X
X/* these are for calculating cpu state percentages */
X
Xstatic long cp_time[NCPUSTATES];
Xstatic long cp_old[NCPUSTATES];
Xstatic long cp_diff[NCPUSTATES];
X
X/* these are for keeping track of the proc array */
X
Xstruct top_proc
X{
X    pid_t p_pid;
X    pid_t p_pgrp;
X    uid_t p_uid;
X    int p_pri;
X    int p_nice;
X    int p_size;
X    int p_stat;
X    int p_flag;
X    int p_slot;
X    time_t p_start;
X    time_t p_time;
X    float p_pcpu;
X    float p_wcpu;
X    char p_name[COMMSIZ];
X};
X
Xstatic int hash_size;
Xstatic struct top_proc *ptable;	/* the hash table of processes */
Xstatic struct top_proc *eptable;
Xstatic struct top_proc **pactive; /* list of active structures */
Xstatic struct top_proc **nextactive; /* for iterating through the processes */
Xstatic struct proc *preal;
Xstatic struct proc *epreal;
X
Xstatic pid_t last_pid;
Xstatic struct timeval last_update;
X
X/* these are for passing data back to the mach. ind. portion */
X
Xstatic int cpu_states[NCPUSTATES];
Xstatic int process_states[8];
Xstatic int memory_stats[6];
X
X/* a few useful macros... */
X
X#define blocktok(b)	((b) >> 1)
X#define pagetok(pg)	((pg) << (v.v_pageshift - LOG1024))
X#define HASH(x)		((x) * 1686629713UL % hash_size)
X
X/*=STATE IDENT STRINGS==================================================*/
X
Xstatic char *state_abbrev[] =
X{
X    "", "sleep", "run", "zomb", "stop", "start", "cpu", "swap",
X    NULL
X};
X
Xstatic char *procstatenames[] =
X{
X    "", " sleeping, ", " running, ", " zombie, ", " stopped, ",
X    " starting, ", " on cpu, ", " swapping, ",
X    NULL
X};
X
Xstatic char *cpustatenames[] =
X{
X    "idle", "user", "kernel", "wait", "nice",
X    NULL
X};
X
Xstatic char *memorynames[] = 
X{
X    "K used, ", "K free, ", "K locked   Swap: ", 
X    "K used, ", "K free",
X    NULL
X};
X
Xstatic char fmt_header[] = 
X  "  PID  PGRP X        PRI NICE  SIZE STATE   TIME    WCPU     CPU COMMAND";
X
X
X/*======================================================================*/
X
Xint
Xmachine_init(statics)
X    struct statics *statics;
X{
X    /* access kernel memory */
X    if (
X#ifdef IMPLEMENT_SETPRIORITY
X        (kmem = open("/dev/kmem", O_RDWR)) < 0 &&
X#endif
X	(kmem = open("/dev/kmem", O_RDONLY)) < 0)
X    {
X	perror("/dev/kmem");
X	return -1;
X    }
X    if ((mem = open("/dev/mem", O_RDONLY)) < 0)
X    {
X	perror("/dev/mem");
X	return -1;
X    }
X
X    /* get the list of symbols we want to access in the kernel */
X    nlst[X_AVAILRMEM].n_nptr = "availrmem";
X    nlst[X_AVAILSMEM].n_nptr = "availsmem";
X
X    if (nlist("/unix", nlst) < 0)
X    {
X	fprintf(stderr, "top: nlist failed\n");
X	return -1;
X    }
X
X    /* make sure they were all found */
X    if (check_nlist(nlst) > 0)
X	return -1;
X
X    /* grab the kernel configuration information */
X    (void)getkval(V_OFS, (char *)&v, sizeof(v), "v");
X
X    /* allocate space for process related info */
X    hash_size = v.v_proc * 3 / 2;
X    ptable = (struct top_proc *)malloc(hash_size * sizeof(struct top_proc));
X    pactive = (struct top_proc **)malloc(v.v_proc * sizeof(struct top_proc *));
X
X    if (!ptable || !pactive)
X    {
X	fprintf(stderr, "top: can't allocate sufficient memory\n");
X	return -1;
X    }
X
X    eptable = ptable + hash_size;
X
X    {
X	struct top_proc *p;
X	for (p = ptable; p != eptable; ++p)
X	    p->p_pid = -1;
X    }
X
X    /* fill in the statics information */
X    statics->procstate_names = procstatenames;
X    statics->cpustate_names = cpustatenames;
X    statics->memory_names = memorynames;
X
X    /* all done! */
X    return 0;
X}
X
Xstatic struct top_proc *
Xlookup_proc(id)
X    pid_t id;
X{
X    struct top_proc *p;
X
X    p = ptable+HASH(rp->p_pid);
X    while (p->p_pid != rp->p_pid && p->p_pid != -1)
X    {
X	if (++p == eptable)
X	    p = ptable;
X    }
X
X    return p;
X}
X    
X
Xstatic void
Xupdate_proc_table()
X{
X    struct proc *rp;
X    struct top_proc *p;
X    float timediff, alpha, beta;
X
X    getkval((long)v.ve_proctab, (char *)preal, 
X	    sizeof(struct proc)*v.v_proc, "proc array");
X
X    /* calculate the time difference since our last proc read */
X    {
X	struct timeval thistime;
X	gettimeofday(&thistime, 0);
X	if (last_update.tv_sec)
X	    timediff = ((thistime.tv_sec - last_update.tv_sec) +
X		        (thistime.tv_usec - last_update.tv_usec) * 1e-6);
X	else
X	    timediff = 1e9;
X	last_update = thistime;
X    }
X
X    /* calculate constants for the exponental average */
X    if (timediff < 30.0)
X    {
X	alpha = 0.5 * (timediff / 30.0);
X	beta = 1.0 - alpha;
X    }
X    else
X	alpha = beta = 0.5;
X
X    timediff *= v.v_hz;
X
X    /* mark the hash table entries as not seen */
X    for (p = ptable; p != eptable; ++p)
X	p->p_stat = 0;
X
X    for (rp = preal; rp != epreal; ++rp)
X    {
X	struct user u;
X
X	if (rp->p_stat == 0)
X	    continue;
X	else if (rp->p_stat == SZOMB ||
X		 lseek(mem, rp->p_addr, 0) < 0 ||
X	         read(mem, &u, sizeof(u)) != sizeof(u))
X	{
X	    strcpy(u.u_comm, "???");
X	    u.u_utime = u.u_stime = u.u_start = 0;
X	}
X
X	p = lookup_proc(rp->p_pid);
X
X	p->p_pgrp = rp->p_pgrp;
X	p->p_uid = rp->p_uid;
X	p->p_pri = rp->p_pri - PZERO;
X	p->p_nice = rp->p_nice - NZERO;
X	p->p_size = pagetok(rp->p_size);
X	p->p_stat = rp->p_stat;
X	p->p_flag = rp->p_flag;
X	if (p->p_pid != rp->p_pid)
X	{
X	    /* new process */
X	    p->p_pid = rp->p_pid;
X	    p->p_slot = rp - preal;
X	    p->p_start = u.u_start;
X	    p->p_time = u.u_utime + u.u_stime;
X	    p->p_pcpu = p->p_time / timediff;
X	    p->p_wcpu = p->p_pcpu;
X	    strncpy(p->p_name, u.u_comm, sizeof(u.u_comm));
X	}
X	else
X	{
X	    time_t oldtime = p->p_time;
X	    p->p_time = u.u_utime + u.u_stime;
X	    p->p_pcpu = (p->p_time - oldtime) / timediff;
X	    p->p_wcpu = alpha * p->p_pcpu + beta * p->p_wcpu;
X	}
X    }
X	
X    for (p = ptable; p != eptable; ++p)
X	if (p->p_stat == 0)
X	    p->p_pid = -1;
X}
X
Xvoid
Xget_system_info(info)
X    struct system_info *info;
X{
X    /* convert load averages */
X    {
X	load_avg ar[3];
X
X	(void)getkval(AVENRUN_OFS, (char *)&ar, sizeof(ar), "avenrun");
X
X	/* convert load averages to doubles */
X	info->load_avg[0] = loaddouble(ar[0]);
X	info->load_avg[1] = loaddouble(ar[1]);
X	info->load_avg[2] = loaddouble(ar[2]);
X    }
X
X    /* get cpu time counts */
X    {
X	struct sysinfo si;
X
X	(void)getkval(SYSINFO_OFS, (char *)&si, sizeof(si), "sysinfo");
X
X	memcpy(cp_time, si.cpu, sizeof(cp_time));
X	percentages(NCPUSTATES, cpu_states, cp_time, cp_old, cp_diff);
X    }
X
X    /* get memory usage information */
X    {
X	int freemem, availrmem, availsmem, maxmem;
X	struct swaptab swaptab[MSFILES];
X	int i, swaptot, swapfree;
X
X        (void)getkval(MAXMEM_OFS, (char *)&maxmem, sizeof(maxmem), "maxmem");
X	(void)getkval(FREEMEM_OFS, (char *)&freemem, sizeof(freemem),
X		      "freemem");
X	(void)getkval(AVAILRMEM_OFS, (char *)&availrmem, sizeof(availrmem),
X		      "availrmem");
X	(void)getkval(AVAILSMEM_OFS, (char *)&availsmem, sizeof(availsmem),
X		      "availsmem");
X        (void)getkval(SWAPTAB_OFS, (char *)&swaptab, sizeof(swaptab),
X		      "swaptab");
X
X	for (i = swaptot = swapfree = 0; i < MSFILES; ++i)
X	    if (swaptab[i].st_dev)
X	    {
X		swaptot += swaptab[i].st_npgs;
X		swapfree += swaptab[i].st_nfpgs;
X	    }
X
X	memory_stats[0] = pagetok(availrmem - freemem);
X	memory_stats[1] = pagetok(freemem);
X	memory_stats[2] = pagetok(maxmem - availrmem);
X	memory_stats[3] = pagetok(swaptot - swapfree);
X	memory_stats[4] = pagetok(swapfree);
X    }
X
X    update_proc_table();
X
X    /* search proc structures for newest process id */
X    {
X	struct top_proc *p;
X	time_t t = 0;
X	pid_t id = 0;
X
X	for (p = ptable; p != eptable; ++p)
X	{
X	    if (!p->p_stat)
X		continue;
X	    if (p->p_start > t || p->p_start == t && p->p_pid > id)
X	    {
X		t = p->p_start;
X		id = p->p_pid;
X	    }
X	}
X
X	if (id > last_pid || id < last_pid - 10000)
X	    last_pid = id;
X
X	info->last_pid = last_pid;
X    }
X
X    /* set arrays and strings */
X    info->cpustates = cpu_states;
X    info->memory = memory_stats;
X}
X
Xcaddr_t
Xget_process_info(si, sel, compare)
X     struct system_info *si;
X     struct process_select *sel;
X     int (*compare)();
X{
X    int total_procs;
X    struct top_proc *p, **a;
X
X    /* these are copied out of sel for speed */
X    int show_idle, show_system, show_uid, show_command;
X
X    /* get a pointer to the states summary array */
X    si->procstates = process_states;
X
X    /* set up flags which define what we are going to select */
X    show_idle = sel->idle;
X    show_system = sel->system;
X    show_uid = sel->uid != -1;
X    show_command = sel->command != NULL;
X
X    /* count up process states and get pointers to interesting procs */
X    total_procs = 0;
X    memset(process_states, 0, sizeof(process_states));
X
X    for (p = ptable, a = pactive; p != eptable; ++p)
X    {
X	int stat = p->p_stat, flag = p->p_flag;
X
X	if (stat == 0 || (flag & SSYS) && !show_system)
X	    continue;
X
X	total_procs++;
X	process_states[stat]++;
X
X	if (stat != SZOMB &&
X	    (show_idle || stat == SRUN || stat == SIDL || stat == SONPROC ||
X	     ((stat == SSLEEP || stat == SSTOP) &&
X	      (flag & (SINTR | SSYS)) == 0)) &&
X	     (!show_uid || p->p_uid == (uid_t)sel->uid))
X	{
X	    /* add it to our active list */
X	    *a++ = p;
X	}
X    }
X
X    /* remember active and total counts */
X    si->p_total = total_procs;
X    si->p_active = a - pactive;
X
X    /* if requested, sort the "interesting" processes */
X    if (compare != NULL)
X	qsort(pactive, si->p_active, sizeof(struct top_proc *), compare);
X
X    /* set up to iterate though processes */
X    nextactive = pactive;
X
X    /* don't even pretend the return value isn't bogus */
X    return 0;
X}
X
X
Xchar *
Xformat_header(uname_field)
X    char *uname_field;
X{
X    int len = strlen(uname_field);
X    if (len > 8)
X	len = 8;
X
X    memcpy(strchr(fmt_header, 'X'), uname_field, len);
X
X    return fmt_header;
X}
X
Xchar *
Xformat_next_process(handle, get_userid)
X     caddr_t handle;
X     char *(*get_userid)();
X{
X    static char fmt[128];	/* static area where result is built */
X    struct top_proc *pp = *nextactive++;
X
X    sprintf(fmt,
X	    "%5d %5d %-8.8s %3d %4d %5s %-5s %6s %6.2f%% %6.2f%% %.14s",
X	    pp->p_pid,
X	    pp->p_pgrp,
X	    (*get_userid)(pp->p_uid),
X	    pp->p_pri,
X	    pp->p_nice,
X	    format_k(pp->p_size),
X	    state_abbrev[pp->p_stat],
X	    format_time((time_t)pp->p_time / v.v_hz),
X	    pp->p_wcpu * 100.0,
X	    pp->p_pcpu * 100.0,
X	    pp->p_name);
X
X    /* return the result */
X    return (fmt);
X}
X
X
X/*
X * check_nlist(nlst) - checks the nlist to see if any symbols were not
X *              found.  For every symbol that was not found, a one-line
X *              message is printed to stderr.  The routine returns the
X *              number of symbols NOT found.
X */
X
Xint
Xcheck_nlist(nlst)
X     register struct nlist *nlst;
X{
X    register int i;
X
X    /* check to see if we got ALL the symbols we requested */
X    /* this will write one line to stderr for every symbol not found */
X
X    i = 0;
X    while (nlst->n_name[0])
X    {
X	if (nlst->n_value == 0)
X	{
X	    /* this one wasn't found */
X	    fprintf(stderr, "kernel: no symbol named `%s'\n", nlst->n_name);
X	    i = 1;
X	}
X	nlst++;
X    }
X
X    return (i);
X}
X
X
X/*
X *  getkval(offset, ptr, size, refstr) - get a value out of the kernel.
X *      "offset" is the byte offset into the kernel for the desired value,
X *      "ptr" points to a buffer into which the value is retrieved,
X *      "size" is the size of the buffer (and the object to retrieve),
X *      "refstr" is a reference string used when printing error meessages,
X *          if "refstr" starts with a '!', then a failure on read will not
X *          be fatal (this may seem like a silly way to do things, but I
X *          really didn't want the overhead of another argument).
X *      
X */
X
Xgetkval(offset, ptr, size, refstr)
X     unsigned long offset;
X     int *ptr;
X     int size;
X     char *refstr;
X{
X    extern int errno;
X    extern char *sys_errlist[];
X
X    if (lseek(kmem, offset, 0) < 0 || read(kmem, ptr, size) != size)
X    {
X	if (*refstr == '!')
X	{
X	    return (0);
X	}
X	else
X	{
X	    fprintf(stderr, "top: getkval for %s: %s\n",
X		    refstr, sys_errlist[errno]);
X	    quit(23);
X	    /*NOTREACHED */
X	}
X    }
X    return (1);
X}
X
X/* comparison routine for qsort */
X
X/*
X *  proc_compare - comparison function for "qsort"
X *      Compares the resource consumption of two processes using five
X *      distinct keys.  The keys (in descending order of importance) are:
X *      percent cpu, cpu ticks, state, resident set size, total virtual
X *      memory usage.  The process states are ordered as follows (from least
X *      to most important):  WAIT, zombie, sleep, stop, start, run.  The
X *      array declaration below maps a process state index into a number
X *      that reflects this ordering.
X */
X
Xstatic unsigned char sorted_state[] =
X{
X    0,	/* not used             */
X    3,	/* sleep                */
X    6,	/* runable              */
X    1,	/* zombie               */
X    4,	/* stop                 */
X    5,	/* start                */
X    7,	/* running              */
X    2,	/* swapping             */
X};
X
Xproc_compare(pp1, pp2)
X    struct top_proc **pp1, **pp2;
X{
X    struct top_proc *p1, *p2;
X    int result;
X    double dresult;
X
X    /* remove one level of indirection */
X    p1 = *pp1;
X    p2 = *pp2;
X
X    /* compare percent cpu */
X    dresult = p2->p_pcpu - p1->p_pcpu;
X    if (dresult != 0.0)
X	return dresult > 0.0 ? 1 : -1;
X
X    /* use process state to break the tie */
X    if ((result = (sorted_state[p2->p_stat] -
X		   sorted_state[p1->p_stat])) == 0)
X    {
X	/* use priority to break the tie */
X	if ((result = p2->p_pri - p1->p_pri) == 0)
X	{
X	    /* use total memory to break the tie */
X	    result = p2->p_size - p1->p_size;
X	}
X    }
X
X    return result;
X}
X
X/*
X * proc_owner(pid) - returns the uid that owns process "pid", or -1 if
X *              the process does not exist.
X *              It is EXTREMLY IMPORTANT that this function work correctly.
X *              If top runs setuid root (as in SVR4), then this function
X *              is the only thing that stands in the way of a serious
X *              security problem.  It validates requests for the "kill"
X *              and "renice" commands.
X */
X
Xint
Xproc_owner(pid)
X    int pid;
X{
X    struct top_proc *p;
X
X    for (p = ptable; p != eptable; ++p)
X	if (p->p_pid == pid)
X	    return p->p_uid;
X
X    return -1;
X}
X
X/* 
X * setpriority(int which, pid_t pid, int val)
X * This system does not have this system call -- fake it
X */
X
Xint
Xsetpriority(which, pid, val)
X    int which, pid, val;
X{
X#ifndef IMPLEMENT_SETPRIORITY
X    errno = ENOSYS;
X    return -1;
X#else
X    struct top_proc *p;
X    struct proc proc;
X    int uid;
X
X    /* sanity check arguments */
X    val += NZERO;
X    if (val < 0)
X	val = 0;
X    else if (val > 39)
X	val = 39;
X
X    p = lookup_proc(pid);
X    if (p->p_pid == -1)
X    {
X	errno = ESRCH;
X	return -1;
X    }
X
X    getkval((long)v.ve_proctab+p->p_slot*sizeof(proc),
X	    (char *)&proc, sizeof(proc), "proc array");
X
X    if (proc.p_stat == 0 || proc.p_pid != pid)
X    {
X	errno = ESRCH;
X	return -1;
X    }
X
X    /* make sure we don't allow nasty people to do nasty things */
X    uid = getuid();
X    if (uid != 0)
X    {
X	if (uid != proc.p_uid || val < proc.p_nice)
X	{
X	    errno = EACCES;
X	    return -1;
X	}
X    }
X
X    /* renice */
X    proc.p_nice = val;
X    if (lseek(kmem, (v.ve_proctab + p->p_slot*sizeof(proc) +
X		     offsetof(struct proc, p_nice), 0) < 0 ||
X	write(kmem, &rp->p_nice, sizeof(rp->p_nice)) != sizeof(rp->p_nice))
X    {
X	return -1;
X    }
X
X    return 0;
X#endif
X}
END_OF_FILE
if test 17173 -ne `wc -c <'top-3.4/machine/m_aux3.c'`; then
    echo shar: \"'top-3.4/machine/m_aux3.c'\" unpacked with wrong size!
fi
# end of 'top-3.4/machine/m_aux3.c'
fi
if test -f 'top-3.4/machine/m_netbsd08.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'top-3.4/machine/m_netbsd08.c'\"
else
echo shar: Extracting \"'top-3.4/machine/m_netbsd08.c'\" \(17295 characters\)
sed "s/^X//" >'top-3.4/machine/m_netbsd08.c' <<'END_OF_FILE'
X/*
X * top - a top users display for Unix
X *
X * SYNOPSIS:  For a NetBSD system
X *
X * DESCRIPTION:
X * This is the machine-dependent module for NetBSD
X * READ THE NOTE AT THE END OF "INSTALL" BEFORE COMPILING.
X * Tested only with a:
X *	i386
X *
X * LIBS: -lkvm
X *
X * AUTHOR:  Christos Zoulas <christos@ee.cornell.edu>
X *	    [originally from m_386bsd.c]
X */
X
X#include <sys/types.h>
X#include <sys/signal.h>
X#include <sys/param.h>
X
X#include <stdio.h>
X#include <nlist.h>
X#include <math.h>
X#include <kvm.h>
X#include <sys/errno.h>
X#include <sys/kinfo.h>
X#include <sys/kinfo_proc.h>
X#ifdef notyet
X#define time __time
X#define hz __hz
X#include <sys/kernel.h>
X#undef time
X#undef hz
X#endif
X#include <sys/dir.h>
X#include <sys/dkstat.h>
X#include <sys/file.h>
X#include <sys/time.h>
X#include <sys/vmmeter.h>
X#include <sys/resource.h>
X
X
X/* #define PATCHED_KVM		/* READ THE FOLLOWING NOTE: */
X				/* define this ONLY if your version of 386bsd
X				   has patchkit 2.4 installed. */
X
X/* #define TOTAL_WORKING */	/* Uncomment when the total structure in */
X				/* the kernel actually works */
X#define DOSWAP
X#define GETLOADAVG
X
X#include "top.h"
X#include "machine.h"
X#include "utils.h"
X
X#define VMUNIX	"/netbsd"
X#define KMEM	"/dev/kmem"
X#define MEM	"/dev/mem"
X#ifdef DOSWAP
X#define SWAP	"/dev/drum"
X#endif
X
Xtypedef struct _kinfo {
X        struct proc ki_p;      /* proc structure */
X        struct eproc ki_e;     /* extra stuff */
X} KINFO;
X
X/* get_process_info passes back a handle.  This is what it looks like: */
X
Xstruct handle
X{
X    KINFO **next_proc;	/* points to next valid proc pointer */
X    int remaining;		/* number of pointers remaining */
X};
X
X/* declarations for load_avg */
X#include "loadavg.h"
X
X#define PP(pp, field) ((pp)->ki_p . field)
X#define EP(pp, field) ((pp)->ki_e . field)
X#define VP(pp, field) ((pp)->ki_e.e_vm . field)
X
X/* define what weighted cpu is.  */
X#define weighted_cpu(pct, pp) (PP((pp), p_time) == 0 ? 0.0 : \
X			 ((pct) / (1.0 - exp(PP((pp), p_time) * logcpu))))
X
X/* what we consider to be process size: */
X#define PROCSIZE(pp) (VP((pp), vm_tsize) + VP((pp), vm_dsize) + VP((pp), vm_ssize))
X
X/* definitions for indices in the nlist array */
X#define X_CCPU		0
X#define X_CP_TIME	1
X#define X_HZ		2
X#define X_TOTAL		3
X#if !defined(KINFO_LOADAVG) && !defined(GETLOADAVG)
X# define X_AVENRUN	4
X# define XX_LAST	4
X#else
X# define XX_LAST	3
X#endif
X#ifndef TOTAL_WORKING
X# define X_PG_FREE	(XX_LAST + 1)
X# define X_PG_ACTIVE	(XX_LAST + 2)
X# define X_PG_INACTIVE	(XX_LAST + 3)
X# define X_PG_WIRED	(XX_LAST + 4)
X#endif
X
Xstatic struct nlist nlst[] = {
X    { "_ccpu" },		/* 0 */
X    { "_cp_time" },		/* 1 */
X    { "_hz" },			/* 2 */
X    { "_total"},		/* 3 */
X#if !defined(KINFO_LOADAVG) && !defined(GETLOADAVG)
X    { "_averunnable" },		
X#endif
X#ifndef TOTAL_WORKING
X    { "_vm_page_free_count" },
X    { "_vm_page_active_count" },
X    { "_vm_page_inactive_count" },
X    { "_vm_page_wire_count" },	
X#endif
X    { 0 }
X};
X
X/*
X *  These definitions control the format of the per-process area
X */
X
Xstatic char header[] =
X  "  PID X        PRI NICE  SIZE   RES STATE   TIME   WCPU    CPU COMMAND";
X/* 0123456   -- field to fill in starts at header+6 */
X#define UNAME_START 6
X
X#define Proc_format \
X	"%5d %-8.8s %3d %4d %5s %5s %-5s %6s %5.2f%% %5.2f%% %.14s"
X
X
X/* process state names for the "STATE" column of the display */
X/* the extra nulls in the string "run" are for adding a slash and
X   the processor number when needed */
X
Xchar *state_abbrev[] =
X{
X    "", "sleep", "WAIT", "run\0\0\0", "start", "zomb", "stop"
X};
X
X
X/* values that we stash away in _init and use in later routines */
X
Xstatic double logcpu;
X
X/* these are retrieved from the kernel in _init */
X
Xstatic          long hz;
Xstatic load_avg  ccpu;
Xstatic          int  ncpu = 0;
X
X/* these are offsets obtained via nlist and used in the get_ functions */
X
Xstatic unsigned long cp_time_offset;
X#if !defined(KINFO_LOADAVG) && !defined(GETLOADAVG)
Xstatic unsigned long avenrun_offset;
X#endif
X
X/* these are for calculating cpu state percentages */
X
Xstatic long cp_time[CPUSTATES];
Xstatic long cp_old[CPUSTATES];
Xstatic long cp_diff[CPUSTATES];
X
X/* these are for detailing the process states */
X
Xint process_states[7];
Xchar *procstatenames[] = {
X    "", " sleeping, ", " ABANDONED, ", " running, ", " starting, ",
X    " zombie, ", " stopped, ",
X    NULL
X};
X
X/* these are for detailing the cpu states */
X
Xint cpu_states[4];
Xchar *cpustatenames[] = {
X    "user", "nice", "system", "idle", NULL
X};
X
X/* these are for detailing the memory statistics */
X
Xint memory_stats[8];
Xchar *memorynames[] = {
X#ifdef	TOTAL_WORKING
X    "Real: ", "K/", "K ", "Virt: ", "K/",
X    "K ", "Free: ", "K", NULL
X#else
X    " Free: ", "K ", " Active: ", "K ", " Inactive: ",
X    "K ", " Wired: ", "K ", NULL
X#endif
X};
X
X/* these are for keeping track of the proc array */
X
Xstatic int bytes;
Xstatic int nproc;
Xstatic int onproc = -1;
Xstatic int pref_len;
Xstatic KINFO *pbase;
Xstatic KINFO **pref;
X
X/* these are for getting the memory statistics */
X
Xstatic int pageshift;		/* log base 2 of the pagesize */
X
X/* define pagetok in terms of pageshift */
X
X#define pagetok(size) ((size) << pageshift)
X
Xmachine_init(statics)
X
Xstruct statics *statics;
X
X{
X    register int i = 0;
X    register int pagesize;
X    char buf[1024];
X
X#if 0		/* some funny stuff going on here */
X    if (kvm_openfiles(NULL, NULL, NULL) == -1);
X	return -1;
X#else
X    kvm_openfiles(VMUNIX, NULL, NULL);
X#endif
X
X    /* get the list of symbols we want to access in the kernel */
X    (void) kvm_nlist(nlst);
X    if (nlst[0].n_type == 0)
X    {
X	fprintf(stderr, "top: nlist failed\n");
X	return(-1);
X    }
X
X    /* make sure they were all found */
X    if (i > 0 && check_nlist(nlst) > 0)
X    {
X	return(-1);
X    }
X
X    /* get the symbol values out of kmem */
X    (void) getkval(nlst[X_HZ].n_value,     (int *)(&hz),	sizeof(hz),
X	    nlst[X_HZ].n_name);
X    (void) getkval(nlst[X_CCPU].n_value,   (int *)(&ccpu),	sizeof(ccpu),
X	    nlst[X_CCPU].n_name);
X
X    /* stash away certain offsets for later use */
X    cp_time_offset = nlst[X_CP_TIME].n_value;
X#ifndef KINFO_LOADAVG
X    avenrun_offset = nlst[X_AVENRUN].n_value;
X#endif
X
X    /* this is used in calculating WCPU -- calculate it ahead of time */
X    logcpu = log(loaddouble(ccpu));
X
X    pbase = NULL;
X    pref = NULL;
X    nproc = 0;
X    onproc = -1;
X    /* get the page size with "getpagesize" and calculate pageshift from it */
X    pagesize = getpagesize();
X    pageshift = 0;
X    while (pagesize > 1)
X    {
X	pageshift++;
X	pagesize >>= 1;
X    }
X
X    /* we only need the amount of log(2)1024 for our conversion */
X    pageshift -= LOG1024;
X
X    /* fill in the statics information */
X    statics->procstate_names = procstatenames;
X    statics->cpustate_names = cpustatenames;
X    statics->memory_names = memorynames;
X
X    /* all done! */
X    return(0);
X}
X
Xchar *format_header(uname_field)
X
Xregister char *uname_field;
X
X{
X    register char *ptr;
X
X    ptr = header + UNAME_START;
X    while (*uname_field != '\0')
X    {
X	*ptr++ = *uname_field++;
X    }
X
X    return(header);
X}
X
Xget_system_info(si)
X
Xstruct system_info *si;
X
X{
X    long total;
X#if !defined(KINFO_LOADAVG) && !defined(GETLOADAVG)
X    load_avg avenrun[3];
X#endif
X
X    /* get the cp_time array */
X    (void) getkval(cp_time_offset, (int *)cp_time, sizeof(cp_time),
X		   "_cp_time");
X
X#ifndef GETLOADAVG
X
X# ifndef KINFO_LOADAVG
X    (void) getkval(avenrun_offset, (int *)avenrun, sizeof(avenrun),
X		   "_avenrun");
X# endif
X
X    /* convert load averages to doubles */
X    {
X	register int i;
X	register double *infoloadp;
X
X# ifdef KINFO_LOADAVG
X	struct loadavg sysload;
X	int size;
X	getkerninfo(KINFO_LOADAVG, &sysload, &size, 0);
X# else
X	load_avg *avenrunp;
X	avenrunp = avenrun;
X# endif
X
X	infoloadp = si->load_avg;
X	for (i = 0; i < 3; i++)
X	{
X# ifdef KINFO_LOADAVG
X	    *infoloadp++ = ((double) sysload.ldavg[i]) / sysload.fscale;
X# else
X	    *infoloadp++ = loaddouble(*avenrunp++);
X# endif
X	}
X    }
X#else
X    getloadavg(si->load_avg, 3);
X#endif
X
X    /* convert cp_time counts to percentages */
X    total = percentages(CPUSTATES, cpu_states, cp_time, cp_old, cp_diff);
X
X    /* sum memory statistics */
X    {
X#ifdef TOTAL_WORKING
X	static struct vmtotal total;
X	int size;
X
X	/* get total -- systemwide main memory usage structure */
X#ifdef KINFO_METER
X	getkerninfo(KINFO_METER, &total, &size, 0);
X#else
X	(void) getkval(nlst[X_TOTAL].n_value, (int *)(&total), sizeof(total),
X		nlst[X_TOTAL].n_name);
X#endif
X	/* convert memory stats to Kbytes */
X	memory_stats[0] = -1;
X	memory_stats[1] = pagetok(total.t_arm);
X	memory_stats[2] = pagetok(total.t_rm);
X	memory_stats[3] = -1;
X	memory_stats[4] = pagetok(total.t_avm);
X	memory_stats[5] = pagetok(total.t_vm);
X	memory_stats[6] = -1;
X	memory_stats[7] = pagetok(total.t_free);
X#else
X        static int free, active, inactive, wired;
X
X	(void) getkval(nlst[X_PG_FREE].n_value, (int *)(&free), sizeof(free),
X                nlst[X_PG_FREE].n_name);
X	(void) getkval(nlst[X_PG_ACTIVE].n_value, (int *)(&active), sizeof(active),
X                nlst[X_PG_ACTIVE].n_name);
X	(void) getkval(nlst[X_PG_INACTIVE].n_value, (int *)(&inactive), sizeof(inactive),
X                nlst[X_PG_INACTIVE].n_name);
X	(void) getkval(nlst[X_PG_WIRED].n_value, (int *)(&wired), sizeof(wired),
X                nlst[X_PG_WIRED].n_name);
X	memory_stats[0] = -1;
X	memory_stats[1] = pagetok(free);
X	memory_stats[2] = -1;
X	memory_stats[3] = pagetok(active);
X	memory_stats[4] = -1;
X	memory_stats[5] = pagetok(inactive);
X	memory_stats[6] = -1;
X	memory_stats[7] = pagetok(wired);
X#endif
X    }
X
X    /* set arrays and strings */
X    si->cpustates = cpu_states;
X    si->memory = memory_stats;
X    si->last_pid = -1;
X}
X
Xstatic struct handle handle;
X
Xcaddr_t get_process_info(si, sel, compare)
X
Xstruct system_info *si;
Xstruct process_select *sel;
Xint (*compare)();
X
X{
X    register int i;
X    register int total_procs;
X    register int active_procs;
X    register KINFO **prefp;
X    KINFO *pp;
X    struct proc *pr;
X    struct eproc *epr;
X
X    /* these are copied out of sel for speed */
X    int show_idle;
X    int show_system;
X    int show_uid;
X    int show_command;
X
X    
X    nproc = kvm_getprocs(KINFO_PROC_ALL, 0);
X    if (nproc > onproc)
X    {
X	pref = (KINFO **) realloc(pref, sizeof(KINFO *)
X		* nproc);
X        pbase = (KINFO *) realloc(pbase, sizeof(KINFO)
X                * (nproc + 2));
X        onproc = nproc;
X    }
X    if (pref == NULL || pbase == NULL) {
X	(void) fprintf(stderr, "top: Out of memory.\n");
X	quit(23);
X    }
X    /* get a pointer to the states summary array */
X    si->procstates = process_states;
X
X    /* set up flags which define what we are going to select */
X    show_idle = sel->idle;
X    show_system = sel->system;
X    show_uid = sel->uid != -1;
X    show_command = sel->command != NULL;
X
X    /* count up process states and get pointers to interesting procs */
X    total_procs = 0;
X    active_procs = 0;
X    memset((char *)process_states, 0, sizeof(process_states));
X    prefp = pref;
X    for (pp = pbase, i = 0; pr = kvm_nextproc(); pp++, i++)
X    {
X	/*
X	 *  Place pointers to each valid proc structure in pref[].
X	 *  Process slots that are actually in use have a non-zero
X	 *  status field.  Processes with SSYS set are system
X	 *  processes---these get ignored unless show_sysprocs is set.
X	 */
X        epr = kvm_geteproc(pr);
X        pp->ki_p = *pr;
X        pp->ki_e = *epr;
X	if (PP(pp, p_stat) != 0 &&
X	    (show_system || ((PP(pp, p_flag) & SSYS) == 0)))
X	{
X	    total_procs++;
X	    process_states[PP(pp, p_stat)]++;
X	    if ((PP(pp, p_stat) != SZOMB) &&
X		(show_idle || (PP(pp, p_pctcpu) != 0) || 
X		 (PP(pp, p_stat) == SRUN)) &&
X		(!show_uid || EP(pp, e_pcred.p_ruid) == (uid_t)sel->uid))
X	    {
X		*prefp++ = pp;
X		active_procs++;
X	    }
X	}
X    }
X
X    /* if requested, sort the "interesting" processes */
X    if (compare != NULL)
X    {
X	qsort((char *)pref, active_procs, sizeof(KINFO *), compare);
X    }
X
X    /* remember active and total counts */
X    si->p_total = total_procs;
X    si->p_active = pref_len = active_procs;
X
X    /* pass back a handle */
X    handle.next_proc = pref;
X    handle.remaining = active_procs;
X#ifndef PATCHED_KVM
X    kvm_freeprocs();
X#endif
X    return((caddr_t)&handle);
X}
X
Xchar fmt[MAX_COLS];		/* static area where result is built */
X
Xchar *format_next_process(handle, get_userid)
X
Xcaddr_t handle;
Xchar *(*get_userid)();
X
X{
X    register KINFO *pp;
X    register long cputime;
X    register double pct;
X    int where;
X    struct handle *hp;
X
X    /* find and remember the next proc structure */
X    hp = (struct handle *)handle;
X    pp = *(hp->next_proc++);
X    hp->remaining--;
X    
X
X    /* get the process's user struct and set cputime */
X    cputime = PP(pp, p_utime.tv_sec) + PP(pp, p_stime.tv_sec);
X
X    /* calculate the base for cpu percentages */
X    pct = pctdouble(PP(pp, p_pctcpu));
X
X    /* format this entry */
X    sprintf(fmt,
X	    Proc_format,
X	    PP(pp, p_pid),
X	    (*get_userid)(EP(pp, e_pcred.p_ruid)),
X	    PP(pp, p_pri) - PZERO,
X	    PP(pp, p_nice) - NZERO,
X	    format_k(pagetok(PROCSIZE(pp))),
X#ifdef notyet
X	    format_k(pagetok(VP(pp, vm_rssize))),
X#else
X            format_k(pagetok(pp->ki_e.e_vm.vm_pmap.pm_stats.resident_count)),
X#endif
X	    state_abbrev[PP(pp, p_stat)],
X	    format_time(cputime),
X	    100.0 * weighted_cpu(pct, pp),
X	    100.0 * pct,
X	    printable(PP(pp, p_comm)));
X
X    /* return the result */
X    return(fmt);
X}
X
X
X/*
X * check_nlist(nlst) - checks the nlist to see if any symbols were not
X *		found.  For every symbol that was not found, a one-line
X *		message is printed to stderr.  The routine returns the
X *		number of symbols NOT found.
X */
X
Xint check_nlist(nlst)
X
Xregister struct nlist *nlst;
X
X{
X    register int i;
X
X    /* check to see if we got ALL the symbols we requested */
X    /* this will write one line to stderr for every symbol not found */
X
X    i = 0;
X    while (nlst->n_name != NULL)
X    {
X	if (nlst->n_type == 0)
X	{
X	    /* this one wasn't found */
X	    fprintf(stderr, "kernel: no symbol named `%s'\n", nlst->n_name);
X	    i = 1;
X	}
X	nlst++;
X    }
X
X    return(i);
X}
X
X
X/*
X *  getkval(offset, ptr, size, refstr) - get a value out of the kernel.
X *	"offset" is the byte offset into the kernel for the desired value,
X *  	"ptr" points to a buffer into which the value is retrieved,
X *  	"size" is the size of the buffer (and the object to retrieve),
X *  	"refstr" is a reference string used when printing error meessages,
X *	    if "refstr" starts with a '!', then a failure on read will not
X *  	    be fatal (this may seem like a silly way to do things, but I
X *  	    really didn't want the overhead of another argument).
X *  	
X */
X
Xgetkval(offset, ptr, size, refstr)
X
Xunsigned long offset;
Xint *ptr;
Xint size;
Xchar *refstr;
X
X{
X    if (kvm_read((void *) offset, (void *) ptr, size) != size)
X    {
X	if (*refstr == '!')
X	{
X	    return(0);
X	}
X	else
X	{
X	    fprintf(stderr, "top: kvm_read for %s: %s\n",
X		refstr, strerror(errno));
X	    quit(23);
X	}
X    }
X    return(1);
X}
X    
X/* comparison routine for qsort */
X
X/*
X *  proc_compare - comparison function for "qsort"
X *	Compares the resource consumption of two processes using five
X *  	distinct keys.  The keys (in descending order of importance) are:
X *  	percent cpu, cpu ticks, state, resident set size, total virtual
X *  	memory usage.  The process states are ordered as follows (from least
X *  	to most important):  WAIT, zombie, sleep, stop, start, run.  The
X *  	array declaration below maps a process state index into a number
X *  	that reflects this ordering.
X */
X
Xstatic unsigned char sorted_state[] =
X{
X    0,	/* not used		*/
X    3,	/* sleep		*/
X    1,	/* ABANDONED (WAIT)	*/
X    6,	/* run			*/
X    5,	/* start		*/
X    2,	/* zombie		*/
X    4	/* stop			*/
X};
X 
Xproc_compare(pp1, pp2)
X
XKINFO **pp1;
XKINFO **pp2;
X
X{
X    register KINFO *p1;
X    register KINFO *p2;
X    register int result;
X    register pctcpu lresult;
X
X    /* remove one level of indirection */
X    p1 = *pp1;
X    p2 = *pp2;
X
X    /* compare percent cpu (pctcpu) */
X    if ((lresult = PP(p2, p_pctcpu) - PP(p1, p_pctcpu)) == 0)
X    {
X	/* use cpticks to break the tie */
X	if ((result = PP(p2, p_cpticks) - PP(p1, p_cpticks)) == 0)
X	{
X	    /* use process state to break the tie */
X	    if ((result = sorted_state[PP(p2, p_stat)] -
X			  sorted_state[PP(p1, p_stat)])  == 0)
X	    {
X		/* use priority to break the tie */
X		if ((result = PP(p2, p_pri) - PP(p1, p_pri)) == 0)
X		{
X		    /* use resident set size (rssize) to break the tie */
X		    if ((result = VP(p2, vm_rssize) - VP(p1, vm_rssize)) == 0)
X		    {
X			/* use total memory to break the tie */
X			result = PROCSIZE(p2) - PROCSIZE(p1);
X		    }
X		}
X	    }
X	}
X    }
X    else
X    {
X	result = lresult < 0 ? -1 : 1;
X    }
X
X    return(result);
X}
X
X/*
X * proc_owner(pid) - returns the uid that owns process "pid", or -1 if
X *		the process does not exist.
X *		It is EXTREMLY IMPORTANT that this function work correctly.
X *		If top runs setuid root (as in SVR4), then this function
X *		is the only thing that stands in the way of a serious
X *		security problem.  It validates requests for the "kill"
X *		and "renice" commands.
X */
X
Xint proc_owner(pid)
X
Xint pid;
X
X{
X    register int cnt;
X    register KINFO **prefp;
X    register KINFO *pp;
X
X    prefp = pref;
X    cnt = pref_len;
X    while (--cnt >= 0)
X    {
X	pp = *prefp++;
X	if (PP(pp, p_pid) == (pid_t)pid)
X	{
X	    return((int)EP(pp, e_pcred.p_ruid));
X	}
X    }
X    return(-1);
X}
END_OF_FILE
if test 17295 -ne `wc -c <'top-3.4/machine/m_netbsd08.c'`; then
    echo shar: \"'top-3.4/machine/m_netbsd08.c'\" unpacked with wrong size!
fi
# end of 'top-3.4/machine/m_netbsd08.c'
fi
echo shar: End of archive 9 \(of 22\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 22 archives.
    echo "Now read README and INSTALL, then run Configure"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

