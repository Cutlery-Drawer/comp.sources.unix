Newsgroups: comp.sources.unix
From: peter@ifm.liu.se (Peter Eriksson)
Subject: v29i131: pidentd-2.7 - Portable Ident Daemon, V2.7, Part08/09
References: <1.842245525.22723@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: peter@ifm.liu.se (Peter Eriksson)
Posting-Number: Volume 29, Issue 131
Archive-Name: pidentd-2.7/part08

#!/bin/sh
# This is part 08 of a multipart archive.
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh08724; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= pidentd-2.7/src/kernel/svr4.c ==============
if test ! -d 'pidentd-2.7'; then
  $echo 'x -' 'creating directory' 'pidentd-2.7'
  mkdir 'pidentd-2.7'
fi
if test ! -d 'pidentd-2.7/src'; then
  $echo 'x -' 'creating directory' 'pidentd-2.7/src'
  mkdir 'pidentd-2.7/src'
fi
if test ! -d 'pidentd-2.7/src/kernel'; then
  $echo 'x -' 'creating directory' 'pidentd-2.7/src/kernel'
  mkdir 'pidentd-2.7/src/kernel'
fi
if test -f 'pidentd-2.7/src/kernel/svr4.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'pidentd-2.7/src/kernel/svr4.c' '(file already exists)'
else
  $echo 'x -' extracting 'pidentd-2.7/src/kernel/svr4.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'pidentd-2.7/src/kernel/svr4.c' &&
/*
** kernel/svr4.c                    SVR4 specific kernel access functions
**
** This program is in the public domain and may be used freely by anyone
** who wants to. 
**
** Last update: 17 March 1993
**
** Please send bug fixes/bug reports to: Peter Eriksson <pen@lysator.liu.se>
*/
X
#define STRNET
X
#include <stdio.h>
#include <errno.h>
#include <ctype.h>
#include <nlist.h>
#include <pwd.h>
#include <signal.h>
#include <syslog.h>
X
#  include "kvm.h"
X
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
X
#include <sys/socketvar.h>
X
#define KERNEL
X
#include <sys/file.h>
X
#include <fcntl.h>
X
#include <unistd.h>
#include <sys/fcntl.h>
#include <sys/stream.h>
#include <sys/stat.h>
#include <sys/cred.h>
#include <sys/vnode.h>
#include <sys/mkdev.h>
#define ucred cred
X
#include <sys/wait.h>
X  
#undef KERNEL
X
#include <net/if.h>
#include <net/route.h>
#include <netinet/in.h>
X
#ifndef ATTSVR4
#include <netinet/in_pcb.h>
#endif
X
#include <netinet/tcp.h>
#include <netinet/ip_var.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
X
#include <arpa/inet.h>
X
#include "identd.h"
#include "error.h"
X
X
extern void *calloc();
extern void *malloc();
X
X
struct nlist nl[] =
{
#ifndef ATTSVR4
X      
#define N_FILE  0
#define N_TCB 1
X      
X  { "file" },
X  { "tcb" },
X
#else                   /* AT&T's hacked version below */
X
#define N_FILE  0
#define N_TCPD 1
#define N_TCPD_CNT 2
X
X  { "file" },
X  { "tcpd" },
X  { "tcpd_cnt" },
#endif			/* ATTSVR4 */
X  
X  { "" }
};
X
static kvm_t *kd;
X
#ifndef ATTSVR4
static struct inpcb tcb;
#endif
X
#ifdef ATTSVR4
static struct tcpd tcpd;	/* we will read this one at a time */
static int tcpd_cnt;	        /* # of tcpd's we have */
#endif
X
X
int k_open()
{
X  /*
X  ** Open the kernel memory device
X  */
X  if (!(kd = kvm_open(path_unix, path_kmem, NULL, O_RDONLY, NULL)))
X    ERROR("main: kvm_open");
X  
X  /*
X  ** Extract offsets to the needed variables in the kernel
X  */
X  if (kvm_nlist(kd, nl) != 0)
X    ERROR("main: kvm_nlist");
X
X  return 0;
}
X
X
/*
** Get a piece of kernel memory with error handling.
** Returns 1 if call succeeded, else 0 (zero).
*/
static int getbuf(addr, buf, len, what)
X  long addr;
X  char *buf;
X  int len;
X  char *what;
{
X  if (kvm_read(kd, addr, buf, len) < 0)
X  {
X    if (syslog_flag)
X      syslog(LOG_ERR, "getbuf: kvm_read(%08x, %d) - %s : %m",
X	     addr, len, what);
X
X    return 0;
X  }
X  
X  return 1;
}
X
X
X
/*
** Traverse the inpcb list until a match is found.
** Returns NULL if no match.
*/
static short
X    getlist(pcbp, faddr, fport, laddr, lport)
#ifdef ATTSVR4
X  struct tcpd *pcbp;
#else
X  struct inpcb *pcbp;
#endif
X  struct in_addr *faddr;
X  int fport;
X  struct in_addr *laddr;
X  int lport;
{
#ifdef ATTSVR4
X  struct tcpcb *head;
X  struct tcpcb tcpcb;
X  int i;
X  int address_of_tcpcb;
#else  
X  struct inpcb *head;
#endif
X
X  if (!pcbp)
X    return -1;
X
#ifdef ATTSVR4
X  i = 0;	/* because we have already read 1 we inc later of the struct */
X  do
X  {
X    /* don't ask be why (HACK) but the forth element that td_tcpcb
X    ** points to contains the address of the tcpcb
X    ** the struct is struct msgb which is a bunch of pointers
X    ** to arrays (in <sys/stream.h> and the fouth element of the
X    ** struct seems to always have the address...there is no comments
X    ** in the .h files to indict why this is, and since I don't have
X    ** source I don't know why....I found this info using crash looking
X    ** around the structure tcpd, using the command 'od -x address count'
X    **
X    ** I assume that this would change....but it seems to work on AT&T SVR4.0
X    ** Rel. 2.1
X    **
X    ** Bradley E. Smith <brad@bradley.bradley.edu>
X    */
X    if (!getbuf( (long) pcbp->td_tcpcb + (3 * sizeof(int)),
X		&address_of_tcpcb, sizeof(int), "&address_of_tcpcb") )
X    {
X      return -1;
X    }
X    
X    if (!getbuf( address_of_tcpcb, &tcpcb, sizeof(tcpcb) , "&tcpcb"))
X    {
X      return -1;
X    }
X    
X    i++;	/* for the read */
X    if (!tcpcb.t_laddr || !tcpcb.t_faddr) /* skip unused entrys */
X	continue;
X    
X    /* have to convert these babies */
X    if ( tcpcb.t_faddr == htonl(faddr->s_addr) &&
X	 tcpcb.t_laddr == htonl(laddr->s_addr) &&
X	 tcpcb.t_fport == htons(fport) &&
X	 tcpcb.t_lport == htons(lport) )
X
X      return pcbp->td_dev;
X    
X    /* if we get here we need to read the tcpd followed by tcpcb, but
X    ** first we check if we are at the end of the tcpd struct
X    */
X  } while ( (i != tcpd_cnt) &&
X	   getbuf((long) (nl[N_TCPD].n_value + ( i * sizeof(struct tcpd)) ),
X		  pcbp, sizeof(struct tcpd), "tcpdlist")  );
X  
#else
X  
X  head = pcbp->inp_prev;
X  do 
X  {
X    if ( pcbp->inp_faddr.s_addr == faddr->s_addr &&
X	 pcbp->inp_laddr.s_addr == laddr->s_addr &&
X	 pcbp->inp_fport        == fport &&
X	 pcbp->inp_lport        == lport )
X      return pcbp->inp_minor;
X  } while (pcbp->inp_next != head &&
X	   getbuf((long) pcbp->inp_next,
X		  pcbp,
X		  sizeof(struct inpcb),
X		  "tcblist"));
#endif /* not ATTSVR4 */
X
X  return -1;
}
X
X
X
/*
** Return the user number for the connection owner in the int pointed
** at in the uid argument.
*/
int k_getuid(faddr, fport, laddr, lport, uid)
X  struct in_addr *faddr;
X  int fport;
X  struct in_addr *laddr;
X  int lport;
X  int *uid;
{
X  long addr;
X  struct stat s;
X  short tcpmajor;	/* Major number of the tcp device */
X  short sockp;		/* Really a device minor number */
X  struct file *filehead, file;
X  struct ucred ucb;
X
X  
X  /* -------------------- FILE DESCRIPTOR TABLE -------------------- */
X  if (!getbuf(nl[N_FILE].n_value, &addr, sizeof(addr), "&file"))
X    return -1;
X
X  /* we just need to determine the major number of the tcp module, which
X     is the minor number of the tcp clone device /dev/tcp */
X  if (stat("/dev/tcp", &s))
X    ERROR("stat(\"/dev/tcp\")");
X  
X  tcpmajor = minor(s.st_rdev);
X
X  /* -------------------- TCP PCB LIST -------------------- */
#ifdef ATTSVR4
X  /* get the number of tcpd structs together */
X  if (!getbuf(nl[N_TCPD_CNT].n_value, &tcpd_cnt,
X	      sizeof(tcpd_cnt), "&tcpd_cnt"))
X	return -1;
X  
X  if (!getbuf(nl[N_TCPD].n_value, &tcpd, sizeof(tcpd), "&tcpd"))
X	return -1;
X  
X  sockp = getlist(&tcpd, faddr, fport, laddr, lport);
#else
X  if (!getbuf(nl[N_TCB].n_value, &tcb, sizeof(tcb), "tcb"))
X    return -1;
X  
X  tcb.inp_prev = (struct inpcb *) nl[N_TCB].n_value;
X  sockp = getlist(&tcb, faddr, fport, laddr, lport);
#endif
X  
X  if (sockp < 0)
X    return -1;
X
X
X  /*
X  * Get the pointer to the head of the file list
X  */
X  if (!getbuf(nl[N_FILE].n_value, &filehead, sizeof(struct file *)))
X    return -1;
X  
X  file.f_next = filehead;
X  do
X  {
X    struct vnode vnode;
X 
X    /*
X    ** Grab a file record
X    */
X    if (!getbuf((long)file.f_next, &file, sizeof(struct file), "file"))
X      return -1;
X
X    /*
X    ** Grab the vnode information to check whether this file is the
X    ** correct major & minor char device
X    */
X    if (!getbuf((off_t)file.f_vnode, &vnode, sizeof(struct vnode), "vnode"))
X      return -1;
X    
X    if ((vnode.v_type == VCHR) && (major(vnode.v_rdev) == tcpmajor) &&
X	(minor(vnode.v_rdev) == sockp))
X    {
X      /*
X      ** We've found it!
X      */
X      if (!getbuf((off_t)file.f_cred, &ucb, sizeof(struct cred), "cred"))
X	return -1;
X      
X      *uid = ucb.cr_ruid;
X      return 0;
X    }
X    
X  } while (file.f_next != filehead);
X  
X  return -1;
}
SHAR_EOF
  $shar_touch -am 0317023593 'pidentd-2.7/src/kernel/svr4.c' &&
  chmod 0644 'pidentd-2.7/src/kernel/svr4.c' ||
  $echo 'restore of' 'pidentd-2.7/src/kernel/svr4.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'pidentd-2.7/src/kernel/svr4.c:' 'MD5 check failed'
624a40c47341f1b315d661b58ac42308  pidentd-2.7/src/kernel/svr4.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'pidentd-2.7/src/kernel/svr4.c'`"
    test 7316 -eq "$shar_count" ||
    $echo 'pidentd-2.7/src/kernel/svr4.c:' 'original size' '7316,' 'current size' "$shar_count!"
  fi
fi
# ============= pidentd-2.7/src/kernel/unicos6.c ==============
if test -f 'pidentd-2.7/src/kernel/unicos6.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'pidentd-2.7/src/kernel/unicos6.c' '(file already exists)'
else
  $echo 'x -' extracting 'pidentd-2.7/src/kernel/unicos6.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'pidentd-2.7/src/kernel/unicos6.c' &&
/*
** kernel/unicos6.c	Low level kernel access functions for Cray UNICOS 6
**
** This program is in the public domain and may be used freely by anyone
** who wants to. 
**
** Last update: 17 March 1993
**
** Please send bug fixes/bug reports to: Peter Eriksson <pen@lysator.liu.se>
*/
X
#include <stdio.h>
#include <errno.h>
#include <ctype.h>
#include <nlist.h>
#include <pwd.h>
#include <signal.h>
#include <syslog.h>
X
#include "kvm.h"
X
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
X
#define IP_SECURITY
X
#include <sys/socketvar.h>
X
#define KERNEL
X
#include <sys/file.h>
X
#include <fcntl.h>
X
#include <sys/param.h>
#include <sys/sysmacros.h>
X
#include <sys/wait.h>
X  
#undef KERNEL
X
#include <net/if.h>
#include <net/route.h>
#include <netinet/in.h>
X
#include <netinet/in_pcb.h>
X
#include <netinet/tcp.h>
#include <netinet/ip_var.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
X
#include <arpa/inet.h>
X
X
#include "identd.h"
#include "error.h"
X
X
extern void *calloc();
extern void *malloc();
X
X
struct nlist nl[] =
{
#define N_TCB 0
X
X   { "tcb" },
X   { "" }
};
X
static kvm_t *kd;
X
static struct file *xfile;
static int nfile;
X
static struct inpcb tcb;
X
X
int k_open()
{
X  /*
X  ** Open the kernel memory device
X  */
X  if (!(kd = kvm_open(path_unix, path_kmem, NULL, O_RDONLY, NULL)))
X    ERROR("main: kvm_open");
X  
X  /*
X  ** Extract offsets to the needed variables in the kernel
X  */
X  if (kvm_nlist(kd, nl) != 0)
X    ERROR("main: kvm_nlist");
X
X  return 0;
}
X
X
/*
** Get a piece of kernel memory with error handling.
** Returns 1 if call succeeded, else 0 (zero).
*/
static int getbuf(addr, buf, len, what)
X  long addr;
X  char *buf;
X  int len;
X  char *what;
{
X  if (kvm_read(kd, addr, buf, len) < 0)
X  {
X    if (syslog_flag)
X      syslog(LOG_ERR, "getbuf: kvm_read(%08x, %d) - %s : %m",
X	     addr, len, what);
X
X    return 0;
X  }
X  
X  return 1;
}
X
X
X
/*
** Traverse the inpcb list until a match is found.
** Returns NULL if no match.
*/
static struct socket *
X    getlist(pcbp, faddr, fport, laddr, lport)
X  struct inpcb *pcbp;
X  struct in_addr *faddr;
X  int fport;
X  struct in_addr *laddr;
X  int lport;
{
X  struct inpcb *head;
X
X  if (!pcbp)
X    return NULL;
X
X  
X  head = pcbp->inp_prev;
X  do 
X  {
X    if ( pcbp->inp_faddr.s_addr == faddr->s_addr &&
X	 pcbp->inp_laddr.s_addr == laddr->s_addr &&
X	 pcbp->inp_fport        == fport &&
X	 pcbp->inp_lport        == lport )
X      return pcbp->inp_socket;
X
X  } while (wtob((long) pcbp->inp_next) != (long) head &&
X	   getbuf(wtob((long) pcbp->inp_next), /* inp_next is a word ptr */
X		  pcbp,
X		  sizeof(struct inpcb),
X		  "tcblist"));
X
X  return NULL;
}
X
X
X
/*
** Return the user number for the connection owner
*/
int k_getuid(faddr, fport, laddr, lport, uid)
X  struct in_addr *faddr;
X  int fport;
X  struct in_addr *laddr;
X  int lport;
X  int *uid;
{
X  long addr;
X  struct socket *sockp;
X  int i;
X  struct socket sockbuf;
X  
X  /* -------------------- TCP PCB LIST -------------------- */
X  if (!getbuf(nl[N_TCB].n_value, &tcb, sizeof(tcb), "tcb"))
X    return -1;
X  
X  tcb.inp_prev = (struct inpcb *) nl[N_TCB].n_value;
X  sockp = getlist(&tcb, faddr, fport, laddr, lport);
X  
X  if (!sockp)
X    return -1;
X
X  /*
X    Creator of socket's uid is stored in the socket structure!!!
X    No need to walk the file table...
X  */
X  if(!getbuf(wtob(sockp), &sockbuf, sizeof(sockbuf), "socket"))
X       return -1;
X  *uid = sockbuf.so_uid;
X  return 0;
}
SHAR_EOF
  $shar_touch -am 0318001993 'pidentd-2.7/src/kernel/unicos6.c' &&
  chmod 0644 'pidentd-2.7/src/kernel/unicos6.c' ||
  $echo 'restore of' 'pidentd-2.7/src/kernel/unicos6.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'pidentd-2.7/src/kernel/unicos6.c:' 'MD5 check failed'
a748342543ac9a2b136af780d03ee09f  pidentd-2.7/src/kernel/unicos6.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'pidentd-2.7/src/kernel/unicos6.c'`"
    test 3462 -eq "$shar_count" ||
    $echo 'pidentd-2.7/src/kernel/unicos6.c:' 'original size' '3462,' 'current size' "$shar_count!"
  fi
fi
# ============= pidentd-2.7/src/kernel/freebsd.c.old ==============
if test -f 'pidentd-2.7/src/kernel/freebsd.c.old' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'pidentd-2.7/src/kernel/freebsd.c.old' '(file already exists)'
else
  $echo 'x -' extracting 'pidentd-2.7/src/kernel/freebsd.c.old' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'pidentd-2.7/src/kernel/freebsd.c.old' &&
/*
** kernel/other.c	Low level kernel access functions for FreeBSD 2.x
**
** This program is in the public domain and may be used freely by anyone
** who wants to. 
**
** Last update: 11 April 1995 - torstenb@FreeBSD.ORG
*/
X
#include <stdio.h>
#include <nlist.h>
#include <syslog.h>
X
#include <kvm.h>
X
#include <sys/param.h>
#include <sys/socket.h>
X
#include <sys/socketvar.h>
X
#define KERNEL
X
#include <sys/file.h>
X
#include <fcntl.h>
X
#undef KERNEL
X
#include <sys/resource.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/wait.h>
X
#include <net/if.h>
#include <net/route.h>
#include <netinet/in.h>
X
#include <netinet/in_systm.h>
#include <netinet/ip.h>
X 
#include <netinet/in_pcb.h>
X
#include <netinet/tcp.h>
#include <netinet/ip_var.h>
X 
#include <netinet/tcpip.h>
X 
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
X
#include <arpa/inet.h>
X
#include "identd.h"
#include "error.h"
X
#ifdef INPLOOKUP_SETLOCAL
#define	_HAVE_OLD_INPCB
#endif
X
extern void *calloc();
extern void *malloc();
X
X
struct nlist nl[] =
{
#define N_FILE 0  
#define N_NFILE 1
#define N_TCB 2
X
X  { "_filehead" },
X  { "_nfiles" },
X  { "_tcb" },
X  { "" }
};
X
static kvm_t *kd;
X
static struct file *xfile;
X
static int nfile;
X
#ifdef _HAVE_OLD_INPCB
static struct inpcb tcb;
#else
static struct inpcbhead tcb;
#endif
X
int k_open()
{
X  /*
X  ** Open the kernel memory device
X  */
X  if (!(kd = kvm_open(path_unix, path_kmem, NULL, O_RDONLY, NULL)))
X    ERROR("main: kvm_open");
X  
X  /*
X  ** Extract offsets to the needed variables in the kernel
X  */
X  if (kvm_nlist(kd, nl) != 0) 
X    ERROR("main: kvm_nlist");
X
X
X  return 0;
}
X
X
/*
** Get a piece of kernel memory with error handling.
** Returns 1 if call succeeded, else 0 (zero).
*/
static int getbuf(addr, buf, len, what)
X  long addr;
X  char *buf;
X  int len;
X  char *what;
{
X
X  if (kvm_read(kd, addr, buf, len) < 0)
X  {
X    if (syslog_flag)
X      syslog(LOG_DEBUG,"getbuf: kvm_read(%08x, %d) - %s : %m",
X	     addr, len, what);
X
X    return 0;
X  }
X  
X  return 1;
}
X
X
X
/*
** Traverse the inpcb list until a match is found.
** Returns NULL if no match.
*/
static struct socket *
#ifdef _HAVE_OLD_INPCB
X    getlist(pcbp, faddr, fport, laddr, lport)
X  struct inpcb *pcbp;
#else
X    getlist(pcbhead, faddr, fport, laddr, lport)
X  struct inpcbhead *pcbhead;
#endif
X  struct in_addr *faddr;
X  int fport;
X  struct in_addr *laddr;
X  int lport;
{
#ifdef _HAVE_OLD_INPCB
X  struct inpcb *head;
#else
X  struct inpcb *head, pcbp;
#endif
X
#ifdef _HAVE_OLD_INPCB
X  if (!pcbp)
X    return NULL;
#else
X  head = pcbhead->lh_first;
X  if (!head)
X    return NULL;
#endif
X 
X
#ifdef _HAVE_OLD_INPCB
X  head = pcbp->inp_prev;
#endif
X  do 
X  {
#ifdef _HAVE_OLD_INPCB
X    if ( pcbp->inp_faddr.s_addr == faddr->s_addr &&
X	 pcbp->inp_laddr.s_addr == laddr->s_addr &&
X	 pcbp->inp_fport        == fport &&
X	 pcbp->inp_lport        == lport )
X       return pcbp->inp_socket;
X  } while (pcbp->inp_next != head &&
X	   getbuf((long) pcbp->inp_next,
X		  pcbp,
X		  sizeof(struct inpcb),
X		  "tcblist"));
#else
X    if (!getbuf((long) head, &pcbp, sizeof(struct inpcb), "tcblist"))
X       break;
X    if (pcbp.inp_faddr.s_addr == faddr->s_addr &&
X	pcbp.inp_fport        == fport &&
X	pcbp.inp_lport        == lport )
X	return(pcbp.inp_socket);
X    head = pcbp.inp_list.le_next;
X  } while (head != NULL);
#endif
X
X  return NULL;
}
X
X
X
/*
** Return the user number for the connection owner
*/
int k_getuid(faddr, fport, laddr, lport, uid)
X  struct in_addr *faddr;
X  int fport;
X  struct in_addr *laddr;
X  int lport;
X  int *uid;
{
X  long addr;
X  struct socket *sockp;
X  int i;
X  struct ucred ucb;
X 
X  /* -------------------- FILE DESCRIPTOR TABLE -------------------- */
X
X  char	*filebuf;
X  filebuf=kvm_getfiles(kd,KERN_FILE,0,&nfile);
X  if(filebuf==0)
X     ERROR("k_getuid: out of memory (file table)");
X  xfile = (struct file *)(filebuf + sizeof (struct file *));
X
X  /* -------------------- TCP PCB LIST -------------------- */
X  if (!getbuf(nl[N_TCB].n_value, &tcb, sizeof(tcb), "tcb"))
X    return -1;
X  
#ifdef _HAVE_OLD_INPCB
X  tcb.inp_prev = (struct inpcb *) nl[N_TCB].n_value;
#endif
X  sockp = getlist(&tcb, faddr, fport, laddr, lport);
X 
X  if (!sockp)
X    return -1;
X
X  /*
X  ** Locate the file descriptor that has the socket in question
X  ** open so that we can get the 'ucred' information
X  */
X  for (i = 0; i < nfile; i++)
X  {
X    if (xfile[i].f_count == 0)
X      continue;
X
X    if (xfile[i].f_type == DTYPE_SOCKET &&
X	(struct socket *) xfile[i].f_data == sockp)
X    {
X      if (!getbuf(xfile[i].f_cred, &ucb, sizeof(ucb), "ucb"))
X	return -1;
X
X      *uid = ucb.cr_uid;
X
X      return 0;
X    }
X  }
X  
X  return -1;
}
X
SHAR_EOF
  $shar_touch -am 0605152795 'pidentd-2.7/src/kernel/freebsd.c.old' &&
  chmod 0644 'pidentd-2.7/src/kernel/freebsd.c.old' ||
  $echo 'restore of' 'pidentd-2.7/src/kernel/freebsd.c.old' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'pidentd-2.7/src/kernel/freebsd.c.old:' 'MD5 check failed'
9ff7b5140891f534cf690a14cad9a3bb  pidentd-2.7/src/kernel/freebsd.c.old
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'pidentd-2.7/src/kernel/freebsd.c.old'`"
    test 4615 -eq "$shar_count" ||
    $echo 'pidentd-2.7/src/kernel/freebsd.c.old:' 'original size' '4615,' 'current size' "$shar_count!"
  fi
fi
# ============= pidentd-2.7/src/kernel/machten.c ==============
if test -f 'pidentd-2.7/src/kernel/machten.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'pidentd-2.7/src/kernel/machten.c' '(file already exists)'
else
  $echo 'x -' extracting 'pidentd-2.7/src/kernel/machten.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'pidentd-2.7/src/kernel/machten.c' &&
/*
** kernel/machten.c	Low level kernel access functions for 
**			Tenon's MachTen 4.0.x for Power Macintosh.
**
** Modified from kernel/other.c by Trevor Strohman, Tenon Intersystems
** <trev@tenon.com>.
**
** This program is in the public domain and may be used freely by anyone
** who wants to use it. 
**
** Last update: 16 July 1996
**
** Please send bug fixes/bug reports to: Peter Eriksson <pen@lysator.liu.se>
*/
#include <stdio.h>
#include <errno.h>
#include <ctype.h>
#include <nlist.h>
#include <pwd.h>
#include <signal.h>
#include <syslog.h>
X
#include <kvm.h>
X
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
X
#define KERNEL
X
#define nfile SOME_OTHER_VARIABLE_NAME
#define _KERNEL
X
#include <sys/file.h>
X
#undef nfile
#undef _KERNEL
X
#include <fcntl.h>
X
#undef KERNEL
X
#include <sys/user.h>
#include <sys/wait.h>
X
#include <net/if.h>
#include <net/route.h>
#include <netinet/in.h>
X
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>
X
#include <netinet/tcp.h>
#include <netinet/tcpip.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <arpa/inet.h>
X
#include "identd.h"
#include "error.h"
X
X
extern void *calloc();
extern void *malloc();
X
X
struct nlist nl[] =
{
#define N_FILE 0  
#define N_NFILE 1
#define N_TCB 2
X
X  { "file" },
X  { "fileNFILE" },
X  { "tcb" },
X  { "" }
};
X
static kvm_t *kd;
X
static struct file *xfile;
static int nfile;
X
caddr_t nfile_dummy;
X
static struct inpcb tcb;
X
X
int k_open()
{
X  /*
X  ** Open the kernel memory device
X  */
X	int i;
X
X  if (!(kd = kvm_open(path_unix, path_kmem, NULL, O_RDONLY, NULL)))
X    ERROR("main: kvm_open");
X  
X  /*
X  ** Extract offsets to the needed variables in the kernel
X  */
X  if (kvm_nlist(kd, nl) != 0)
X     ERROR("main: kvm_nlist");
X
X  return 0;
}
X
X
/*
** Get a piece of kernel memory with error handling.
** Returns 1 if call succeeded, else 0 (zero).
*/
static int getbuf(addr, buf, len, what)
X  caddr_t addr;
X  char *buf;
X  int len;
X  char *what;
{
X
X  if (kvm_read(kd, addr, buf, len) < 0)
X  {
X    if (syslog_flag)
X      syslog(LOG_ERR, "getbuf: kvm_read(%08x, %d) - %s : %m",
X	     addr, len, what);
X
X    return 0;
X  }
X  return 1;
}
X
X
X
/*
** Traverse the inpcb list until a match is found.
** Returns NULL if no match.
*/
static struct socket *
X    getlist(pcbp, faddr, fport, laddr, lport)
X  struct inpcb *pcbp;
X  struct in_addr *faddr;
X  int fport;
X  struct in_addr *laddr;
X  int lport;
{
X  struct inpcb *head;
X  if (!pcbp)
X    return NULL;
X
X  head = pcbp->inp_prev;
X  do 
X  {
X    if ( pcbp->inp_faddr.s_addr == faddr->s_addr &&
X	 pcbp->inp_laddr.s_addr == laddr->s_addr &&
X	 pcbp->inp_fport        == fport &&
X	 pcbp->inp_lport        == lport )
X      return pcbp->inp_socket;
X  } while (pcbp->inp_next != head &&
X	   getbuf((caddr_t) pcbp->inp_next,
X		  pcbp,
X		  sizeof(struct inpcb),
X		  "tcblist"));
X  return NULL;
}
X
X
X
/*
** Return the user number for the connection owner
*/
int k_getuid(faddr, fport, laddr, lport, uid)
X  struct in_addr *faddr;
X  int fport;
X  struct in_addr *laddr;
X  int lport;
X  int *uid;
{
X  caddr_t addr;
X  struct socket *sockp;
X  int i;
X  struct ucred ucb;
X  
X  /* -------------------- FILE DESCRIPTOR TABLE -------------------- */
X
X  if (!getbuf(nl[N_NFILE].n_value, &nfile_dummy, sizeof(nfile_dummy), "nfile"))
X    return -1;
X  if (!getbuf(nl[N_FILE].n_value, &addr, sizeof(addr), "&file"))
X    return -1;
X
X  /* Convert pointer nfile_dummy to an integer number of files */
X  nfile = (int) ((nfile_dummy - addr) / sizeof(struct file));
X
X  xfile = (struct file *) calloc(nfile, sizeof(struct file));
X  if (!xfile)
X    ERROR2("k_getuid: calloc(%d,%d)", nfile, sizeof(struct file));
X  
X  if (!getbuf(addr, xfile, sizeof(struct file)*nfile, "file[]"))
X    return -1;
X  
X  /* -------------------- TCP PCB LIST -------------------- */
X  if (!getbuf(nl[N_TCB].n_value, &tcb, sizeof(tcb), "tcb"))
X    return -1;
X
X  tcb.inp_prev = (struct inpcb *) nl[N_TCB].n_value;
X  sockp = getlist(&tcb, faddr, fport, laddr, lport);
X  if (!sockp)
X    return -1;
X  /*
X  ** Locate the file descriptor that has the socket in question
X  ** open so that we can get the 'ucred' information
X  */
X  for (i = 0; i < nfile; i++)
X  {
X    if (xfile[i].f_count == 0)
X      continue;
X    
X    if (xfile[i].f_type == DTYPE_SOCKET &&
X	(struct socket *) xfile[i].f_data == sockp)
X    {
X      if (!getbuf(xfile[i].f_cred, &ucb, sizeof(ucb), "ucb"))
X	return -1;
X      
X      *uid = ucb.cr_ruid;
X
X      return 0;
X    }
X  }
X  
X  return -1;
}
SHAR_EOF
  $shar_touch -am 0811204096 'pidentd-2.7/src/kernel/machten.c' &&
  chmod 0644 'pidentd-2.7/src/kernel/machten.c' ||
  $echo 'restore of' 'pidentd-2.7/src/kernel/machten.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'pidentd-2.7/src/kernel/machten.c:' 'MD5 check failed'
0e72945c50750d3e04d9684b5e7cbae2  pidentd-2.7/src/kernel/machten.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'pidentd-2.7/src/kernel/machten.c'`"
    test 4575 -eq "$shar_count" ||
    $echo 'pidentd-2.7/src/kernel/machten.c:' 'original size' '4575,' 'current size' "$shar_count!"
  fi
fi
# ============= pidentd-2.7/src/kernel/uw2.c ==============
if test -f 'pidentd-2.7/src/kernel/uw2.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'pidentd-2.7/src/kernel/uw2.c' '(file already exists)'
else
  $echo 'x -' extracting 'pidentd-2.7/src/kernel/uw2.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'pidentd-2.7/src/kernel/uw2.c' &&
/*
** kernel/uw2.c                UnixWare v2.x specific kernel access functions
**
**
** Last update: 28 Nov 1995
**
** Please send mods/bug fixes/bug reports to: Paul F. Wells <paul@wellserv.com>
**
*/
X
#define _KMEMUSER
#include <sys/types.h>
#include <sys/ksynch.h>
#include <sys/flock.h>
#include <sys/pid.h>
#include <sys/var.h>
#include <sys/proc.h>
#include <sys/cred.h>
#include <sys/session.h>
#include <sys/socket.h>
#include <sys/strsubr.h>
#include <net/route.h>
#include <netinet/in_pcb.h>
#include <netinet/tcp_kern.h>
#include <sys/fs/snode.h>
#include <sys/stat.h>
#include <sys/mkdev.h>
#undef _KMEMUSER
X
#include <sys/ksym.h>
#include <sys/sysmacros.h>
X
#include <arpa/inet.h>
X
#include <fcntl.h>
X
#include "paths.h"
#include "kvm.h"
#include "identd.h"
#include "error.h"
X
#include <stdio.h>	/* this kinda reeks */
X
#ifndef TRUE
enum { FALSE, TRUE };
#endif
X
static kvm_t *kd;
X
int k_open()
{
X  /*
X  ** Open the kernel memory device
X  */
X  if (!(kd = kvm_open(path_unix, path_kmem, NULL, O_RDONLY, NULL)))
X    ERROR("main: kvm_open");
X  
#ifndef UW2	/* don't really need this */
X  /*
X  ** Extract offsets to the needed variables in the kernel
X  */
X  if (kvm_nlist(kd, nl) != 0)
X    ERROR("main: kvm_nlist");
#endif
X
X  return 0;
}
X
/*
** Get a piece of kernel memory with error handling.
** Returns 1 if call succeeded, else 0 (zero).
*/
static int
getbuf(long addr,void *buf,int len,char *what)
{
X	if (kvm_read(kd, addr, buf, len) < 0) {
X		if (syslog_flag)
X			syslog(LOG_ERR, "getbuf: kvm_read(%08x, %d) - %s : %m",
X					addr, len, what);
X		return 0;
X	}
X	return 1;
}
X
int
k_getuid(struct in_addr *faddr,int fport,struct in_addr *laddr,int lport,int *uid)
{
X	int gotit;
X	ulong_t info;
X	struct stat tcpstat;
X	dev_t tcp_clone;
X	minor_t tcp_minor;
X	snode_t **snode_base, *snodep, spec_node;
X	int snode_hash;
X	vnode_t *vnodep;
X	struct inpcb pcb, *tcb_first;
X	proc_t *proc_head, *procp, uproc;
X	int maxfd;
X	int ifdt, fdtable_len;
X	fd_entry_t *fdp;
X	file_t *filep, file_entry;
X	cred_t creds;
X
X	/* initialize & find pcb for specified connection */
X
X	if (stat("/dev/tcp", &tcpstat) != 0)
X		return -1;
X	tcp_minor = minor(tcpstat.st_rdev);
X
X	info = 0;
X	tcb_first = NULL;
X	if (getksym("tcb", (ulong_t *) &tcb_first, &info) < 0)
X		return -1;
X
X	for (gotit = FALSE, pcb.inp_prev = tcb_first; ; ) {
X		/* why do we have to go backward? */
X		if (!getbuf((long) pcb.inp_prev, &pcb, sizeof(pcb), "inp_prev"))
X			return -1;
X		if (
X			pcb.inp_faddr.s_addr == faddr->s_addr &&
X			pcb.inp_laddr.s_addr == laddr->s_addr &&
X			pcb.inp_fport == fport &&
X			pcb.inp_lport == lport
X		) {
X			/* I screwed up: 2.01 allowed makedev() */
X			tcp_clone = makedevice(tcp_minor, pcb.inp_minor);
X			gotit = TRUE;
X			break;
X		}
X		if (pcb.inp_prev == NULL || pcb.inp_prev == tcb_first) break;
X	}
X	if (!gotit) return -1;
X
X	/* now crawl through snodes to find vnode of clone device */
X
X	info = 0;
X	snode_base = NULL;
X	if (getksym("spectable", (ulong_t *) &snode_base, &info) < 0)
X		return -1;
X	snode_hash = SPECTBHASH(tcp_clone);
X	if (!getbuf((long) (snode_base + snode_hash), &snodep, sizeof(snodep), "snode_hash"))
X		return -1;
X
X	for (gotit = FALSE; snodep != NULL ; snodep = spec_node.s_next) {
X		if (!getbuf((long) snodep, &spec_node, sizeof(spec_node), "snodep"))
X			return -1;
X		if (spec_node.s_dev == tcp_clone) {
X			vnodep = (vnode_t *) ((char *) snodep + offsetof(struct snode, s_vnode));
X			gotit = TRUE;
X			break;
X		}
X	}
X	if (!gotit || (spec_node.s_flag & SINVALID)) return -1;
X
X	/* find process with this vnode */
X
X	info = 0;
X	procp = NULL;
X	if (getksym("practive", (ulong_t *) &procp, &info) < 0)
X		return -1;
X	if (!getbuf((long) procp, &proc_head, sizeof(proc_head), "practive"))
X		return -1;
X
X	for (gotit = FALSE, procp = proc_head; procp != NULL; procp = uproc.p_next) {
X		if (!getbuf((long) procp, &uproc, sizeof(uproc), "procp"))
X			return -1;
X		if((maxfd = uproc.p_fdtab.fdt_sizeused) == 0) continue;
X		fdtable_len = maxfd * sizeof(fd_entry_t);
X		if ((fdp = (fd_entry_t *) malloc(fdtable_len)) == NULL)
X			return -1;
X		if (!getbuf((long) uproc.p_fdtab.fdt_entrytab, fdp, fdtable_len, "fdt_entrytab")) {
X			free(fdp);
X			return -1;
X		}
X		for (ifdt = 0; ifdt < maxfd; ifdt++) {
X			if (fdp[ifdt].fd_status != FD_INUSE) continue;
X			filep = fdp[ifdt].fd_file;
X			if (!getbuf((long) filep, &file_entry, sizeof(file_entry), "filep")) {
X				free(fdp);
X				return -1;
X			}
X			if (vnodep == file_entry.f_vnode) {
X				if (file_entry.f_cred != NULL) {
X					if (!getbuf((long) file_entry.f_cred, &creds, sizeof(creds), "f_cred")) {
X						free(fdp);
X						return -1;
X					}
X					free(fdp);
X					gotit = TRUE;
X					goto got_proc;
X				}
X			}
X		}
X		free(fdp);
X	}
got_proc:	;	/* maybe */
X	if (!gotit) return -1;
X
X	/* wow! */
X	*uid = creds.cr_ruid;
X
X	return 0;
}
SHAR_EOF
  $shar_touch -am 0811221296 'pidentd-2.7/src/kernel/uw2.c' &&
  chmod 0644 'pidentd-2.7/src/kernel/uw2.c' ||
  $echo 'restore of' 'pidentd-2.7/src/kernel/uw2.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'pidentd-2.7/src/kernel/uw2.c:' 'MD5 check failed'
e78e40e2ecda093a515b2cdc8742c342  pidentd-2.7/src/kernel/uw2.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'pidentd-2.7/src/kernel/uw2.c'`"
    test 4742 -eq "$shar_count" ||
    $echo 'pidentd-2.7/src/kernel/uw2.c:' 'original size' '4742,' 'current size' "$shar_count!"
  fi
fi
# ============= pidentd-2.7/src/kvm.c ==============
if test -f 'pidentd-2.7/src/kvm.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'pidentd-2.7/src/kvm.c' '(file already exists)'
else
  $echo 'x -' extracting 'pidentd-2.7/src/kvm.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'pidentd-2.7/src/kvm.c' &&
/*
** kvm.c            A set of functions emulating KVM for machines without them.
**
** This code is in the public domain and may be used freely by anyone
** who wants to.
**
** Last update: 12 Dec 1992
**
** Author: Peter Eriksson <pen@lysator.liu.se>
*/
X
#ifndef NO_KVM
#ifndef HAVE_KVM
X
#ifdef NeXT31
#  include <libc.h>
#endif
X
#include <stdio.h>
#include <errno.h>
#include <nlist.h>
X
#ifdef IRIX
#  ifdef IRIX62
#    if _MIPS_SZPTR == 64
#       define _K64U64 1
#    else
#       define _K32U32 1
#    endif
#  endif
#  include <sys/sbd.h>
#  ifndef K0_TO_PHYS
#    define K0_TO_PHYS(x)   (x) 
#  endif
#  if defined(IRIX6) || (defined(IRIX62) && _MIPS_SZPTR == 64)
#    define nlist nlist64
#  endif
#endif
X
#ifdef BSD43
#  include <sys/types.h>
#  include <sys/dir.h>
#  include <sys/param.h>
#  include <sys/vmmac.h>
#if 0
#  include <sys/time.h>
#else
#  include <sys/user.h>
#endif
#  ifdef DIRBLKSIZ
#    undef DIRBLKSIZ
#  endif
#if 0
#  include <sys/user.h>
#endif
#  include <sys/proc.h>
#  include <machine/pte.h>
#  include "paths.h"
#endif
X 
X
#include "kernel/kvm.h"
#include "paths.h"
X
#if defined(BSD43) || defined(MIPS)
extern int errno;
#endif
X
extern void *malloc();
X
X
kvm_t *kvm_open(namelist, corefile, swapfile, flag, errstr)
X  char *namelist;
X  char *corefile;
X  char *swapfile;
X  int flag;
X  char *errstr;
{
X  kvm_t *kd;
X
X  if (!namelist)
X    namelist = _PATH_UNIX;
X  if (!corefile)
X    corefile = _PATH_KMEM;
X  
#ifdef BSD43
X  if (!swapfile)
X    swapfile = _PATH_SWAP;
#endif
X  
X  kd = (kvm_t *) malloc(sizeof(kvm_t));
X  if (!kd)
X  {
X    if (errstr)
X      perror(errstr);
X    return NULL;
X  }
X
X  kd->namelist = (char *) malloc(strlen(namelist)+1);
X  if (!kd->namelist)
X  {
X    if (errstr)
X      perror(errstr);
X    return NULL;
X  }
X  
X  if ((kd->fd = open(corefile, flag)) < 0)
X  {
X    if (errstr)
X      perror(errstr);
X    free(kd->namelist);
X    free(kd);
X    return NULL;
X  }
X
#ifdef BSD43
X  if ((kd->swap_fd = open(swapfile, flag)) < 0)
X  {
X    if (errstr)
X      perror(errstr);
X    close(kd->fd);
X    free(kd->namelist);
X    free(kd);
X    return NULL;
X  }
X
X  if ((kd->mem_fd = open(_PATH_MEM, flag)) < 0)
X  {
X    if (errstr)
X      perror(errstr);
X    close(kd->swap_fd);
X    close(kd->fd);
X    free(kd->namelist);
X    free(kd);
X    return NULL;
X  }
#endif
X  
X  strcpy(kd->namelist, namelist);
X  return kd;
}
X
X
int kvm_close(kd)
X  kvm_t *kd;
{
X  int code;
X  
X  code = close(kd->fd);
#ifdef BSD43
X  close(kd->swap_fd);
X  close(kd->mem_fd);
X  if (kd->proctab)
X    free(kd->proctab);
#endif
X  free(kd->namelist);
X  free(kd);
X
X  return code;
}
X
X
/*
** Extract offsets to the symbols in the 'nl' list. Returns 0 if all found,
** or else the number of variables that was not found.
*/
int kvm_nlist(kd, nl)
X  kvm_t *kd;
X  struct nlist *nl;
{
X  int code;
X  int i;
X
X  code = nlist(kd->namelist, nl);
X
X  if (code != 0)
X    return code;
X  
X  /*
X  ** Verify that we got all the needed variables. Needed because some
X  ** implementations of nlist() returns 0 although it didn't find all
X  ** variables.
X  */
X  if (code == 0)
X  {
#if defined(__convex__) || defined(NeXT)
X    for (i = 0; nl[i].n_un.n_name && nl[i].n_un.n_name[0]; i++)
#else  
X    for (i = 0; nl[i].n_name && nl[i].n_name[0]; i++)
#endif
#if defined(_AUX_SOURCE) || defined(_CRAY) || defined(sco) || defined(_SEQUENT_)
X      /* A/UX sets n_type to 0 if not compiled with -g. n_value will still
X      ** contain the (correct?) value (unless symbol unknown).
X      */
X      if( nl[i].n_value == 0)
X	code++;
#else
X      if (nl[i].n_type == 0)
X	code++;
#endif
X  }
X  
X  return code;
}
X
X
/*
** Get a piece of the kernel memory
*/
static int readbuf(fd, addr, buf, len)
X  int fd;
X  long addr;
X  char *buf;
X  int len;
{
#ifdef IRIX
X  addr = K0_TO_PHYS(addr);
#endif
X  errno = 0;
#if defined(__alpha)
X  /*
X   * Let us be paranoid about return values.
X   * It should be like this on all implementations,
X   * but some may have broken lseek or read returns.
X   */
X  if (lseek(fd, addr, 0) != addr || errno != 0) return -1;
X  if (read(fd, buf, len) != len  || errno != 0) return -1;
X  return len;
#else
X  if (lseek(fd, addr, 0) == -1 && errno != 0) return -1;
X  return read(fd, buf, len);
#endif
}
X
int kvm_read(kd, addr, buf, len)
X  kvm_t *kd;
X  long addr;
X  char *buf;
X  int len;
{
X  return readbuf(kd->fd, addr, buf, len);
}
X
X
#ifdef BSD43
X
struct user *kvm_getu(kd, procp)
X  kvm_t *kd;
X  struct proc *procp;
{
X  static union
X  {
X    struct user user;
X    char upages[UPAGES][NBPG];
X  } userb;
X
X  int ncl;
X  struct pte *pteaddr, apte;
X  struct pte arguutl[UPAGES+CLSIZE];
X  
X  
X  if ((procp->p_flag & SLOAD) == 0)
X  {
X    if(readbuf(kd->swap_fd,
X	       dtob(procp->p_swaddr),
X	       &userb.user, sizeof(struct user)) < 0)
X      return NULL;
X  }
X  else
X  {
X    /*
X    ** Sigh. I just *love* hard coded variable names in macros...
X    */
X    {
X      struct pte *usrpt = kd->usrpt;
X      
X      pteaddr = &kd->Usrptma[btokmx(procp->p_p0br) + procp->p_szpt - 1];
X      if (readbuf(kd->fd, pteaddr, &apte, sizeof(apte)) < 0)
X	return NULL;
X    }
X    
X    if (readbuf(kd->mem_fd,
X		ctob(apte.pg_pfnum+1)-(UPAGES+CLSIZE)*sizeof(struct pte),
X		arguutl, sizeof(arguutl)) < 0)
X      return NULL;
X
X    ncl = (sizeof(struct user) + NBPG*CLSIZE - 1) / (NBPG*CLSIZE);
X    while (--ncl >= 0)
X    {
X      int i;
X
X      
X      i = ncl * CLSIZE;
X      if(readbuf(kd->mem_fd,
X		 ctob(arguutl[CLSIZE+i].pg_pfnum),
X		 userb.upages[i], CLSIZE*NBPG) < 0)
X	return NULL;
X    }
X  }
X
X  return &userb.user;
}
X
X
X
struct proc *kvm_nextproc(kd)
X  kvm_t *kd;
{
X  if (kd->proctab == NULL)
X    if (kvm_setproc(kd) < 0)
X      return NULL;
X
X  if (kd->procidx < kd->nproc)
X    return &kd->proctab[kd->procidx++];
X
X  return (struct proc *) NULL;
}
X
int kvm_setproc(kd)
X  kvm_t *kd;
{
X  long procaddr;
X  
X  static struct nlist nl[] =
X  {
#define N_PROC 0
#define N_USRPTMA 1
#define N_NPROC 2
#define N_USRPT 3
X 
X    { "_proc" },
X    { "_Usrptmap" },
X    { "_nproc" },
X    { "_usrpt" },
X    { "" }
X  };
X
X  if (kvm_nlist(kd, nl) != 0)
X    return -1;
X  
X  kd->Usrptma = (struct pte *) nl[N_USRPTMA].n_value;
X  kd->usrpt   = (struct pte *) nl[N_USRPT].n_value;
X  
X  if (readbuf(kd->fd, nl[N_NPROC].n_value, &kd->nproc, sizeof(kd->nproc)) < 0)
X    return -1;
X
X  if (readbuf(kd->fd, nl[N_PROC].n_value, &procaddr, sizeof(procaddr)) < 0)
X    return -1;
X  
X  if (kd->proctab)
X    free(kd->proctab);
X
X  kd->proctab = (struct proc *) calloc(kd->nproc, sizeof(struct proc));
X  if (!kd->proctab)
X    return -1;
X
X  if (readbuf(kd->fd,
X	      procaddr,
X	      kd->proctab,
X	      kd->nproc*sizeof(struct proc)) < 0)
X    return -1;
X
X  kd->procidx = 0;
X
X  return 0;
}
X
X
struct proc *kvm_getproc(kd, pid)
X  kvm_t *kd;
X  int pid;
{
X  struct proc *procp;
X
X
X  if (kvm_setproc(kd) < 0)
X    return NULL;
X
X  while ((procp = kvm_nextproc(kd)) && procp->p_pid != pid)
X    ;
X  
X  return procp;
}
X
#endif
X
#else
/* Just to make some compilers shut up! */
int kvm_dummy()
{
X    return 1;
}
#endif
#endif
SHAR_EOF
  $shar_touch -am 0811201896 'pidentd-2.7/src/kvm.c' &&
  chmod 0644 'pidentd-2.7/src/kvm.c' ||
  $echo 'restore of' 'pidentd-2.7/src/kvm.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'pidentd-2.7/src/kvm.c:' 'MD5 check failed'
e5f8e791b14f8b26080ffcc452652f68  pidentd-2.7/src/kvm.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'pidentd-2.7/src/kvm.c'`"
    test 6918 -eq "$shar_count" ||
    $echo 'pidentd-2.7/src/kvm.c:' 'original size' '6918,' 'current size' "$shar_count!"
  fi
fi
# ============= pidentd-2.7/src/paths.h ==============
if test -f 'pidentd-2.7/src/paths.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'pidentd-2.7/src/paths.h' '(file already exists)'
else
  $echo 'x -' extracting 'pidentd-2.7/src/paths.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'pidentd-2.7/src/paths.h' &&
/*
** paths.h		Common path definitions for the in.identd daemon
**
** Last update: 11 Dec 1992
**
** Please send bug fixes/bug reports to: Peter Eriksson <pen@lysator.liu.se>
*/
X
#ifdef sequent
#  define _PATH_UNIX "/dynix"
#endif
X
#if defined(MIPS) || defined(IRIX) || defined(sco) || defined(_SEQUENT_)
#  define _PATH_UNIX "/unix"
#endif
X
#if defined(hpux) || defined(__hpux)
#ifdef HPUX_10
#  define _PATH_UNIX "/stand/vmunix"
#else
#  define _PATH_UNIX "/hp-ux"
#endif
#endif
X
#ifdef SOLARIS
#  define _PATH_UNIX "/dev/ksyms"
#else
#  if defined(SVR4) && !defined(_SEQUENT_)
#    define _PATH_UNIX "/stand/unix"
#  endif
#endif
X
#ifdef BSD43
#  define _PATH_SWAP "/dev/drum"
#  define _PATH_MEM  "/dev/mem"
#endif
X
#ifdef _AUX_SOURCE
#  define _PATH_UNIX "/unix"
#endif
X
#ifdef _CRAY
#  define _PATH_UNIX "/unicos"
#  define _PATH_MEM  "/dev/mem"
#endif
X
#ifdef NeXT
#  define _PATH_UNIX "/mach"
#endif
X
#ifdef	__bsdi__
#  define _PATH_UNIX "/bsd"
#endif	/* __bsdi__ */
X
X
/*
X * Some defaults...
X */
#ifndef _PATH_KMEM
#  define _PATH_KMEM "/dev/kmem"
#endif
X
#ifndef _PATH_UNIX
#  define _PATH_UNIX "/vmunix"
#endif
X
X
#ifndef PATH_CONFIG
#  define PATH_CONFIG "/etc/identd.conf"
#endif
X
#ifndef PATH_DESKEY
#  define PATH_DESKEY "/etc/identd.key"
#endif
SHAR_EOF
  $shar_touch -am 1004193895 'pidentd-2.7/src/paths.h' &&
  chmod 0644 'pidentd-2.7/src/paths.h' ||
  $echo 'restore of' 'pidentd-2.7/src/paths.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'pidentd-2.7/src/paths.h:' 'MD5 check failed'
7ce70ab26eb657ca777b1670caccd1ec  pidentd-2.7/src/paths.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'pidentd-2.7/src/paths.h'`"
    test 1259 -eq "$shar_count" ||
    $echo 'pidentd-2.7/src/paths.h:' 'original size' '1259,' 'current size' "$shar_count!"
  fi
fi
# ============= pidentd-2.7/src/proxy.c ==============
if test -f 'pidentd-2.7/src/proxy.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'pidentd-2.7/src/proxy.c' '(file already exists)'
else
  $echo 'x -' extracting 'pidentd-2.7/src/proxy.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'pidentd-2.7/src/proxy.c' &&
/*
** proxy.c                         This file implements the proxy() call.
**
** This program is in the public domain and may be used freely by anyone
** who wants to. 
**
** Last update: 12 Dec 1992
**
** Please send bug fixes/bug reports to: Peter Eriksson <pen@lysator.liu.se>
*/
X
#include <stdio.h>
#include <errno.h>
X
#include "identd.h"
X
X
#ifdef INCLUDE_PROXY
#include <sys/types.h>
#include <sys/time.h>
#include <netinet/in.h>
X
#include <ident.h>
#endif
X
X
/*
** This function should establish a connection to a remote IDENT
** server and query it for the information associated with the
** specified connection and the return that to the caller.
**
** Should there be three different timeouts (Connection Establishment,
** Query Transmit and Query Receive)?
*/
int proxy(laddr, faddr, lport, fport, timeout)
#ifdef INCLUDE_PROXY
X    struct in_addr *laddr;
X    struct in_addr *faddr;
#else
X    void *laddr, *faddr;
#endif
X    int lport;
X    int fport;
#ifdef INCLUDE_PROXY
X    struct timeval *timeout;
#else
X    void *timeout;
#endif
{
#ifndef INCLUDE_PROXY
X    /* Just here to make the compiler shut up! */
X    laddr = faddr = NULL;
X    timeout = NULL;
X	
X    printf("%d , %d : ERROR : %s\r\n",
X	   lport, fport,
X	   unknown_flag ? "UNKNOWN-ERROR" : "X-NOT-YET-IMPLEMENTED");
X    
X    return -1;
#else
X  id_t *idp;
X  char *answer;
X  char *opsys;
X  char *charset;
X  
X  idp = id_open(laddr, faddr, timeout);
X  if (!idp)
X  {
X    printf("%d , %d : ERROR : %s\r\n",
X	   lport, fport,
X	   unknown_flag ? "UNKNOWN-ERROR" : "X-CONNECTION-REFUSED");
X    return -1;
X  }
X
X  if (id_query(idp, lport, fport, timeout) < 0)
X  {
X    printf("%d , %d : ERROR : %s\r\n",
X	   lport, fport,
X	   unknown_flag ? "UNKNOWN-ERROR" : "X-TRANSMIT-QUERY-ERROR");
X    id_close(idp);
X    return -1;
X  }
X
X  switch (id_parse(idp, timeout, &lport, &fport, &answer, &opsys, &charset))
X  {
X    case 1:
X      printf("%d , %d : USERID : %s %s%s : %s\r\n",
X	     lport, fport,
X	     opsys,
X	     charset ? "," : "",
X	     charset ? charset : "",
X	     answer);
X      break;
X      
X    case 2:
X      printf("%d , %d : ERROR : %s\r\n",
X	     lport, fport, answer);
X      break;
X      
X    case 0:  /* More to parse - fix this later! */
X    case -1: /* Internal error */
X    default:
X      printf("%d , %d : ERROR : %s\r\n",
X	     lport, fport,
X	     unknown_flag ? "UNKNOWN-ERROR" : "X-PARSE-REPLY-ERROR");
X  }
X
X  id_close(idp);
#endif  
}
SHAR_EOF
  $shar_touch -am 0127035195 'pidentd-2.7/src/proxy.c' &&
  chmod 0644 'pidentd-2.7/src/proxy.c' ||
  $echo 'restore of' 'pidentd-2.7/src/proxy.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'pidentd-2.7/src/proxy.c:' 'MD5 check failed'
f66dbb5d687acf6946d8fa0711ece226  pidentd-2.7/src/proxy.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'pidentd-2.7/src/proxy.c'`"
    test 2408 -eq "$shar_count" ||
    $echo 'pidentd-2.7/src/proxy.c:' 'original size' '2408,' 'current size' "$shar_count!"
  fi
fi
# ============= pidentd-2.7/src/version.c ==============
if test -f 'pidentd-2.7/src/version.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'pidentd-2.7/src/version.c' '(file already exists)'
else
  $echo 'x -' extracting 'pidentd-2.7/src/version.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'pidentd-2.7/src/version.c' &&
char version[] = "2.7b1p";
SHAR_EOF
  $shar_touch -am 0514004496 'pidentd-2.7/src/version.c' &&
  chmod 0644 'pidentd-2.7/src/version.c' ||
  $echo 'restore of' 'pidentd-2.7/src/version.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'pidentd-2.7/src/version.c:' 'MD5 check failed'
e6c90a2cd31259126ca49cd6daf5681f  pidentd-2.7/src/version.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'pidentd-2.7/src/version.c'`"
    test 27 -eq "$shar_count" ||
    $echo 'pidentd-2.7/src/version.c:' 'original size' '27,' 'current size' "$shar_count!"
  fi
fi
# ============= pidentd-2.7/testdir/Makefile ==============
if test ! -d 'pidentd-2.7/testdir'; then
  $echo 'x -' 'creating directory' 'pidentd-2.7/testdir'
  mkdir 'pidentd-2.7/testdir'
fi
if test -f 'pidentd-2.7/testdir/Makefile' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'pidentd-2.7/testdir/Makefile' '(file already exists)'
else
  $echo 'x -' extracting 'pidentd-2.7/testdir/Makefile' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'pidentd-2.7/testdir/Makefile' &&
all:	test1
X	@echo "Running tests.."
X	@echo ""
X	@echo ""
X	@echo "Test #1..."
X	@echo ""
X	@echo "You should see your Unix username below:"
X	./test1
X	@echo ""
X	@echo ""
X	@echo "End of tests."
X
X
test1: test1.c
X	$(CC) -o test1 test1.c
X
clean:
X	rm -f test1 *~ core *.o \#*
SHAR_EOF
  $shar_touch -am 0223232094 'pidentd-2.7/testdir/Makefile' &&
  chmod 0644 'pidentd-2.7/testdir/Makefile' ||
  $echo 'restore of' 'pidentd-2.7/testdir/Makefile' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'pidentd-2.7/testdir/Makefile:' 'MD5 check failed'
19663acae60da3898452b9a23074fad6  pidentd-2.7/testdir/Makefile
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'pidentd-2.7/testdir/Makefile'`"
    test 266 -eq "$shar_count" ||
    $echo 'pidentd-2.7/testdir/Makefile:' 'original size' '266,' 'current size' "$shar_count!"
  fi
fi
# ============= pidentd-2.7/testdir/test1.c ==============
if test -f 'pidentd-2.7/testdir/test1.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'pidentd-2.7/testdir/test1.c' '(file already exists)'
else
  $echo 'x -' extracting 'pidentd-2.7/testdir/test1.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'pidentd-2.7/testdir/test1.c' &&
/*
** A small test program. If run without any arguments, it should
** return *your* user name if the machine it is run on has a correctly
** installed and running Ident server.
**
** Last modified: 11 August 1993 by Michael Kuch
**
** Author: Peter Eriksson <pen@lysator.liu.se>
*/
X
#include <stdio.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <ctype.h>
X
X
int Toupper(c)
X  int c;
{
X  if (islower(c))
X    return toupper(c);
X  else
X    return c;
}
X
X
/*
** Compare two strings, case insensitive
*/
int Stricmp(s1, s2)
X  char *s1, *s2;
{
X  int diff;
X
X
X  while (!(diff = Toupper(*s1) - Toupper(*s2)) && *s1)
X    s1++, s2++;
X
X  return diff;
}
X
X
Perror(str)
X  char *str;
{
X  perror(str);
X  exit(1);
}
X
X
main(argc,argv)
X  int argc;
X  char *argv[];
{
X  int fd;
X  struct sockaddr_in addr;
X  int addrlen;
X  int port;
X  FILE *fp_in, *fp_out;
X  int lport, fport;
X  char buffer[8192];
X  char *cp;
X  char reply_type[81];
X  char opsys_or_error[81];
X  char identifier[1024];
X  
X  
X  if (argc > 3)
X  {
X    printf("usage: %s [{host-ip-number} [{port number}]]", argv[0]);
X    exit(1);
X  }
X  
X  fd = socket(AF_INET, SOCK_STREAM, 0);
X  if (fd == -1)
X    Perror("socket");
X
X  addr.sin_family = AF_INET;
X  if(argc > 1)
X    addr.sin_addr.s_addr = inet_addr(argv[1]);
X  else
X    addr.sin_addr.s_addr = inet_addr("127.0.0.1");
X
X  if (argc > 2)
X    port = atoi(argv[2]);
X  else
X    port = 113;
X  
X  addr.sin_port = htons(port);
X  addrlen = sizeof(addr);
X
X  if (connect(fd, &addr, addrlen) == -1)
X    Perror("connect");
X
X  addrlen = sizeof(addr);
X  if (getsockname(fd, &addr, &addrlen) == -1)
X    Perror("getsockname");
X
X  fp_in  = fdopen(fd, "r");
X  fp_out = fdopen(fd, "w");
X  if (!fp_in || !fp_out)
X    Perror("fdopen");
X
X  fprintf(fp_out, "%d , %d\n", ntohs(addr.sin_port), port);
X  fflush(fp_out);
X
X  if (fgets(buffer, sizeof(buffer)-1, fp_in) == NULL)
X    Perror("fgets");
X
X  shutdown(fd, 1);
X
X  cp = buffer;
X  while (*cp != 0 && (*cp < ' ' || isspace(*cp)))
X      ++cp;
X  
X  argc = sscanf(cp, "%d , %d : %[^ \t\n\r:] : %[^\t\n\r:] : %[^\n\r]",
X		&lport, &fport, reply_type, opsys_or_error, identifier);
X  if (argc < 3)
X  {
X    fprintf(stderr, "sscanf: too few arguments (%d)\n", argc);
X    exit(1);
X  }
X  if (Stricmp(reply_type, "ERROR") == 0)
X  {
X    printf("Ident error: error code: %s\n", opsys_or_error);
X    exit(1);
X  }
X  else if (Stricmp(reply_type, "USERID") != 0)
X  {
X    printf("Ident error: illegal reply type: %s\n", reply_type);
X    exit(1);
X  }
X  else
X    printf("Ident returned:\n");
X    printf("\tOpsys and Charset (if -c specified for identd) = %s\n",
X				 opsys_or_error);
X    printf("\tIdentifier: %s\n", identifier);
X
X  fclose(fp_out);
X  fclose(fp_in);
X
X  exit(0);
}
SHAR_EOF
  $shar_touch -am 0605153495 'pidentd-2.7/testdir/test1.c' &&
  chmod 0644 'pidentd-2.7/testdir/test1.c' ||
  $echo 'restore of' 'pidentd-2.7/testdir/test1.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'pidentd-2.7/testdir/test1.c:' 'MD5 check failed'
7348b5ce9e6e3647bbdf0a0e496bb175  pidentd-2.7/testdir/test1.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'pidentd-2.7/testdir/test1.c'`"
    test 2750 -eq "$shar_count" ||
    $echo 'pidentd-2.7/testdir/test1.c:' 'original size' '2750,' 'current size' "$shar_count!"
  fi
fi
# ============= pidentd-2.7/.cvsignore ==============
if test -f 'pidentd-2.7/.cvsignore' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'pidentd-2.7/.cvsignore' '(file already exists)'
else
  $echo 'x -' extracting 'pidentd-2.7/.cvsignore' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'pidentd-2.7/.cvsignore' &&
idecrypt
identconn
identd.8
in.identd
itest
SHAR_EOF
  $shar_touch -am 0811214296 'pidentd-2.7/.cvsignore' &&
  chmod 0644 'pidentd-2.7/.cvsignore' ||
  $echo 'restore of' 'pidentd-2.7/.cvsignore' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'pidentd-2.7/.cvsignore:' 'MD5 check failed'
42aa7090f58b0b9351fade8ff181519e  pidentd-2.7/.cvsignore
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'pidentd-2.7/.cvsignore'`"
    test 44 -eq "$shar_count" ||
    $echo 'pidentd-2.7/.cvsignore:' 'original size' '44,' 'current size' "$shar_count!"
  fi
fi
# ============= pidentd-2.7/identconn.sh ==============
if test -f 'pidentd-2.7/identconn.sh' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'pidentd-2.7/identconn.sh' '(file already exists)'
else
  $echo 'x -' extracting 'pidentd-2.7/identconn.sh' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'pidentd-2.7/identconn.sh' &&
#! /bin/sh
:
PATH=/usr/bin:/usr/ucb:xDESTROOTx/bin ; export PATH
X
netstat -f inet -n | grep ESTAB | itest
X
SHAR_EOF
  $shar_touch -am 0811215296 'pidentd-2.7/identconn.sh' &&
  chmod 0755 'pidentd-2.7/identconn.sh' ||
  $echo 'restore of' 'pidentd-2.7/identconn.sh' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'pidentd-2.7/identconn.sh:' 'MD5 check failed'
967892bcd9c9967a121bc82aa883a200  pidentd-2.7/identconn.sh
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'pidentd-2.7/identconn.sh'`"
    test 107 -eq "$shar_count" ||
    $echo 'pidentd-2.7/identconn.sh:' 'original size' '107,' 'current size' "$shar_count!"
  fi
fi
# ============= pidentd-2.7/install-sh ==============
if test -f 'pidentd-2.7/install-sh' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'pidentd-2.7/install-sh' '(file already exists)'
else
  $echo 'x -' extracting 'pidentd-2.7/install-sh' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'pidentd-2.7/install-sh' &&
#! /bin/sh
#
# install - install a program, script, or datafile
# This comes from X11R5.
#
# Calling this script install-sh is preferred over install.sh, to prevent
# `make' implicit rules from creating a file called install from it
# when there is no Makefile.
#
# This script is compatible with the BSD install script, but was written
# from scratch.
#
X
X
# set DOITPROG to echo to test this script
X
# Don't use :- since 4.3BSD and earlier shells don't like it.
doit="${DOITPROG-}"
X
X
# put in absolute paths if you don't have them in your path; or use env. vars.
X
mvprog="${MVPROG-mv}"
cpprog="${CPPROG-cp}"
chmodprog="${CHMODPROG-chmod}"
chownprog="${CHOWNPROG-chown}"
chgrpprog="${CHGRPPROG-chgrp}"
stripprog="${STRIPPROG-strip}"
rmprog="${RMPROG-rm}"
mkdirprog="${MKDIRPROG-mkdir}"
X
transformbasename=""
transform_arg=""
instcmd="$mvprog"
chmodcmd="$chmodprog 0755"
chowncmd=""
chgrpcmd=""
stripcmd=""
rmcmd="$rmprog -f"
mvcmd="$mvprog"
src=""
dst=""
dir_arg=""
X
while [ x"$1" != x ]; do
X    case $1 in
X	-c) instcmd="$cpprog"
X	    shift
X	    continue;;
X
X	-d) dir_arg=true
X	    shift
X	    continue;;
X
X	-m) chmodcmd="$chmodprog $2"
X	    shift
X	    shift
X	    continue;;
X
X	-o) chowncmd="$chownprog $2"
X	    shift
X	    shift
X	    continue;;
X
X	-g) chgrpcmd="$chgrpprog $2"
X	    shift
X	    shift
X	    continue;;
X
X	-s) stripcmd="$stripprog"
X	    shift
X	    continue;;
X
X	-t=*) transformarg=`echo $1 | sed 's/-t=//'`
X	    shift
X	    continue;;
X
X	-b=*) transformbasename=`echo $1 | sed 's/-b=//'`
X	    shift
X	    continue;;
X
X	*)  if [ x"$src" = x ]
X	    then
X		src=$1
X	    else
X		# this colon is to work around a 386BSD /bin/sh bug
X		:
X		dst=$1
X	    fi
X	    shift
X	    continue;;
X    esac
done
X
if [ x"$src" = x ]
then
X	echo "install:	no input file specified"
X	exit 1
else
X	true
fi
X
if [ x"$dir_arg" != x ]; then
X	dst=$src
X	src=""
X	
X	if [ -d $dst ]; then
X		instcmd=:
X	else
X		instcmd=mkdir
X	fi
else
X
# Waiting for this to be detected by the "$instcmd $src $dsttmp" command
# might cause directories to be created, which would be especially bad 
# if $src (and thus $dsttmp) contains '*'.
X
X	if [ -f $src -o -d $src ]
X	then
X		true
X	else
X		echo "install:  $src does not exist"
X		exit 1
X	fi
X	
X	if [ x"$dst" = x ]
X	then
X		echo "install:	no destination specified"
X		exit 1
X	else
X		true
X	fi
X
# If destination is a directory, append the input filename; if your system
# does not like double slashes in filenames, you may need to add some logic
X
X	if [ -d $dst ]
X	then
X		dst="$dst"/`basename $src`
X	else
X		true
X	fi
fi
X
## this sed command emulates the dirname command
dstdir=`echo $dst | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`
X
# Make sure that the destination directory exists.
#  this part is taken from Noah Friedman's mkinstalldirs script
X
# Skip lots of stat calls in the usual case.
if [ ! -d "$dstdir" ]; then
defaultIFS='	
'
IFS="${IFS-${defaultIFS}}"
X
oIFS="${IFS}"
# Some sh's can't handle IFS=/ for some reason.
IFS='%'
set - `echo ${dstdir} | sed -e 's@/@%@g' -e 's@^%@/@'`
IFS="${oIFS}"
X
pathcomp=''
X
while [ $# -ne 0 ] ; do
X	pathcomp="${pathcomp}${1}"
X	shift
X
X	if [ ! -d "${pathcomp}" ] ;
X        then
X		$mkdirprog "${pathcomp}"
X	else
X		true
X	fi
X
X	pathcomp="${pathcomp}/"
done
fi
X
if [ x"$dir_arg" != x ]
then
X	$doit $instcmd $dst &&
X
X	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dst; else true ; fi &&
X	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dst; else true ; fi &&
X	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dst; else true ; fi &&
X	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dst; else true ; fi
else
X
# If we're going to rename the final executable, determine the name now.
X
X	if [ x"$transformarg" = x ] 
X	then
X		dstfile=`basename $dst`
X	else
X		dstfile=`basename $dst $transformbasename | 
X			sed $transformarg`$transformbasename
X	fi
X
# don't allow the sed command to completely eliminate the filename
X
X	if [ x"$dstfile" = x ] 
X	then
X		dstfile=`basename $dst`
X	else
X		true
X	fi
X
# Make a temp file name in the proper directory.
X
X	dsttmp=$dstdir/#inst.$$#
X
# Move or copy the file name to the temp name
X
X	$doit $instcmd $src $dsttmp &&
X
X	trap "rm -f ${dsttmp}" 0 &&
X
# and set any options; do chmod last to preserve setuid bits
X
# If any of these fail, we abort the whole thing.  If we want to
# ignore errors from any of these, just make sure not to ignore
# errors from the above "$doit $instcmd $src $dsttmp" command.
X
X	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dsttmp; else true;fi &&
X	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dsttmp; else true;fi &&
X	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dsttmp; else true;fi &&
X	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dsttmp; else true;fi &&
X
# Now rename the file to the real destination.
X
X	$doit $rmcmd -f $dstdir/$dstfile &&
X	$doit $mvcmd $dsttmp $dstdir/$dstfile 
X
fi &&
X
X
Xexit 0
SHAR_EOF
  $shar_touch -am 0811230496 'pidentd-2.7/install-sh' &&
  chmod 0755 'pidentd-2.7/install-sh' ||
  $echo 'restore of' 'pidentd-2.7/install-sh' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'pidentd-2.7/install-sh:' 'MD5 check failed'
e2f7509e56ca4245d80878e106226786  pidentd-2.7/install-sh
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'pidentd-2.7/install-sh'`"
    test 4773 -eq "$shar_count" ||
    $echo 'pidentd-2.7/install-sh:' 'original size' '4773,' 'current size' "$shar_count!"
  fi
fi
: || $echo 'restore of' 'pidentd-2.7/identd.8' 'failed'
$echo 'End of part' '8,' 'continue with part' '9'
exit 0
