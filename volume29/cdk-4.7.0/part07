Newsgroups: comp.sources.unix
From: glover@credit.erin.utoronto.ca (Mike Glover)
Subject: v29i111: cdk-4.7.0 - Curses Development Kit, V4.7.0, Part07/10
References: <1.833427459.28242@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: glover@credit.erin.utoronto.ca (Mike Glover)
Posting-Number: Volume 29, Issue 111
Archive-Name: cdk-4.7.0/part07

#!/bin/sh
# This is `cdk_part.07' (part 7 of a multipart archive).
# Do not concatenate these parts, unpack them in order with `/bin/sh'.
# File `man/scroll.3' is being continued...
#
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  echo 'WARNING: not restoring timestamps.  Consider getting and'
  echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if test ! -r _sharseq.tmp; then
  echo 'Please unpack part 1 first!'
  exit 1
fi
shar_sequence=`cat _sharseq.tmp`
if test "$shar_sequence" != 7; then
  echo "Please unpack part $shar_sequence next!"
  exit 1
fi
if test ! -f _sharnew.tmp; then
  echo 'x - still skipping man/scroll.3'
else
  echo 'x - continuing file man/scroll.3'
  sed 's/^X//' << 'SHAR_EOF' >> '_sharuue.tmp' &&
M(%1O(&%C=&EV871E('1H92!W:61G970@:6YT97)A=&EV96QY('!A<W,@"FEN
M(&$@3E5,3"!P;VEN=&5R(&9O<B!<9C)A8W1I;VYS7&8Q+B!4:&ES(&9U;F-T
M:6]N(')E='5R;G,@86X@7&8T:6YT7&8Q(`IR97!R97-E;G1I;F<@=&AE(&EN
M9&5X(&]F('1H92!S8W)O;&P@:71E;2!C:&]S96XN"BY210H*:6YT(&EN:F5C
M=$-$2U-C<F]L;"`H7&8R<V-R;VQL7&8Q+"!<9C)C:&%R86-T97)<9C$I.PHN
M4E,@,PI4:&ES(&9U;F-T:6]N(&EN:F5C=',@82!S:6YG;&4@8VAA<F%C=&5R
M(&EN=&\@=&AE('=I9&=E="X@5&AE('!A<F%M971E<B`*7&8R<V-R;VQL7&8Q
M(&ES(&$@<&]I;G1E<B!T;R!A(&1E9FEN960@<V-R;VQL('=I9&=E="X@5&AE
M('!A<F%M971E<B`*7&8R8VAA<F%C=&5R7&8Q(&ES(&]F('1Y<&4@7&8T8VAT
M>7!E7&8Q(&%N9"!I<R!T:&4@8VAA<F%C=&5R('1O(&EN:F5C="!I;G1O"G1H
M92!W:61G970N($EF('1H92!C:&%R86-T97(@:6YJ96-T960@:6YT;R!T:&ES
M('=I9&=E="!W87,@7&8T4D5455).7&8Q('1H96X*=&AE('9A;'5E(&]F('1H
M92!C=7)R96YT;'D@<V5L96-T960@:71E;2!W:6QL(&)E(')E='5R;F5D+B!)
M9B!T:&4@8VAA<F%C=&5R"FEN:F5C=&5D('=A<R!<9C1#5%),+4Y<9C$@=&AE
M;B!A('9A;'5E(&]F("TQ('=I;&P@8F4@<F5T=7)N960N($]T:&5R=VES92`*
M=&AI<R!F=6YC=&EO;B!R971U<FYS(&$@=F%L=64@;V8@+3(N"BY210H*=F]I
M9"!S971#1$M38W)O;&P@*%QF,G-C<F]L;%QF,2P@7&8R<V-R;VQL3&ES=%QF
M,2P@7&8R<V-R;VQL3&ES=$QE;F=T:%QF,2P@7&8R;G5M8F5R<UQF,2P@7&8R
M:&EG:&QI9VAT7&8Q+"!<9C)B;WA<9C$I.PHN4E,@,PI4:&ES(&9U;F-T:6]N
M(&QE=',@=&AE('!R;V=R86UM97(@;6]D:69Y(&-E<G1A:6X@96QE;65N=',@
M;V8@86X@86QR96%D>2!D969I;F5D"G-C<F]L;"!W:61G970N(%1H92!P87)A
M;65T97(@;F%M97,@8V]R<F5S<&]N9"!T;R!T:&4@<V%M92!P87)A;65T97(@
M;F%M97,@;&ES=&5D"FEN('1H92!<9C1N97=#1$M38W)O;&Q<9C$@9G5N8W1I
M;VXN"BY210H*=F]I9"!A9&1#1$M38W)O;&Q)=&5M("A<9C)S8W)O;&Q<9C$L
M(%QF,FET96U<9C$I.PHN4E,@,PI4:&ES(&9U;F-T:6]N(&%L;&]W<R!T:&4@
M=7-E<B!T;R!A9&0@86X@:71E;2!I;G1O(&%N(&%L<F5A9'D@9&5F:6YE9"!S
M8W)O;&QI;F<*;&ES="X@5&AE(%QF,G-C<F]L;%QF,2!P87)A;65T97(@:7,@
M82!P;VEN=&5R('1O('1H92!S8W)O;&QI;F<@;&ES="!T;R!A9&0@=&AE"FET
M96T@=&\N(%1H92!P87)A;65T97(@7&8R:71E;5QF,2!I<R!A(%QF-&-H87(@
M*EQF,2!R97!R97-E;G1I;F<@=&AE(&YE=R!I=&5M"G1O(&%D9"X@5&AE(&ET
M96T@:7,@86QW87ES(&%D9&5D('1O('1H92!E;F0@;V8@=&AE(&QI<W0N"BY2
M10H*=F]I9"!D96QE=&5#1$M38W)O;&Q)=&5M("A<9C)S8W)O;&Q<9C$L(%QF
M,G!O<VET:6]N7&8Q*3L*+E)3(#,*5&AI<R!F=6YC=&EO;B!A;&QO=W,@=&AE
M('5S97(@=&\@861D(&%N(&ET96T@:6YT;R!A;B!A;')E861Y(&1E9FEN960@
M<V-R;VQL:6YG"FQI<W0N(%1H92!<9C)S8W)O;&Q<9C$@<&%R86UE=&5R(&ES
M(&$@<&]I;G1E<B!T;R!T:&4@<V-R;VQL:6YG(&QI<W0@=&\@861D('1H90II
M=&5M('1O+B!4:&4@<&%R86UE=&5R(%QF,F8R<&]S:71I;VY<9C$@:7,@86X@
M7&8T:6YT7&8Q('=H:6-H('-P96-I9FEE<R!W:&EC:`IE;&5M96YT('1O(')E
M;6]V92X*+E)%"@IV;VED(&1R87=#1$M38W)O;&PH7&8R<V-R;VQL7&8Q+"!<
M9C)B;WA<9C$I.PHN4E,@,PI4:&ES(&9U;F-T:6]N(&1R87=S('1H92!S8W)O
M;&P@=VED9V5T(&]N('1H92!S8W)E96XN(%1H92!<9C)B;WA<9C$@;W!T:6]N
M(`ID<F%W<R!T:&4@=VED9V5T('=I=&@@;W(@=VET:&]U="!A(&)O>"X*+E)%
M"@IV;VED(&5R87-E0T1+4V-R;VQL("A<9C)S8W)O;&Q<9C$I.PHN4E,@,PI4
M:&ES(&9U;F-T:6]N(')E;6]V97,@=&AE('=I9&=E="!F<F]M('1H92!S8W)E
M96XN(%1H:7,@9&]E<R!<9C1.3U1<9C$@9&5S=')O>0IT:&4@=VED9V5T+@HN
M4D4*"G9O:60@9&5S=')O>4-$2U-C<F]L;"`H7&8R<V-R;VQL7&8Q*3L*+E)3
M(#,*5&AI<R!F=6YC=&EO;B!R96UO=F5S('1H92!W:61G970@9G)O;2!T:&4@
M<V-R965N(&%N9"!F<F5E<R!U<"!A;GD@;65M;W)Y('1H90IO8FIE8W0@;6%Y
M(&)E('5S:6YG+@HN4D4*"G9O:60@<V5T0T1+4V-R;VQL4')E4')O8V5S<R`H
M7&8R<V-R;VQL7&8Q+"!<9C)F=6YC=&EO;EQF,2P@7&8R9&%T85QF,BD["BY2
M4R`S"E1H:7,@9G5N8W1I;VX@86QL;W=S('1H92!U<V5R('1O(&AA=F4@=&AE
M('=I9&=E="!C86QL(&$@9G5N8W1I;VX@869T97(@82!K97D*:7,@:&ET(&%N
M9"!B969O<F4@=&AE(&ME>2!I<R!A<'!L:65D('1O('1H92!W:61G970N(%1H
M92!P87)A;65T97(@7&8R9G5N8W1I;VY<9C$*:68@;V8@='EP92!<9C104D]#
M15-31DY<9C$N(%1H92!P87)A;65T97(@7&8R9&%T85QF,2!I<R!A('!O:6YT
M97(@=&\@"EQF-'9O:61<9C$N(%1O(&QE87)N(&UO<F4@86)O=70@<')E+7!R
M;V-E<W-I;F<@<F5A9"!T:&4@7&8T8V1K7W!R;V-E<W-<9C$*;6%N=6%L('!A
M9V4N"BY210H@"G9O:60@<V5T0T1+4V-R;VQL4&]S=%!R;V-E<W,@*%QF,G-C
M<F]L;%QF,2P@7&8R9G5N8W1I;VY<9C$L(%QF,F1A=&%<9C(I.PHN4E,@,PI4
M:&ES(&9U;F-T:6]N(&%L;&]W<R!T:&4@=7-E<B!T;R!H879E('1H92!W:61G
M970@8V%L;"!A(&9U;F-T:6]N(&%F=&5R('1H90IK97D@:&%S(&)E96X@87!P
M;&EE9"!T;R!T:&4@=VED9V5T+B`@5&AE('!A<F%M971E<B!<9C)F=6YC=&EO
M;EQF,2!I9B!O9B!T>7!E"EQF-%!23T-%4U-&3EQF,2X@5&AE('!A<F%M971E
M<B!<9C)D871A7&8Q(&ES(&$@<&]I;G1E<B!T;R!<9C1V;VED7&8Q+B!4;PIL
M96%R;B!M;W)E(&%B;W5T('!O<W0M<')O8V5S<VEN9R!R96%D('1H92!<9C1C
M9&M?<')O8V5S<UQF,2!M86YU86P@<&%G92X*+E)%"@IV;VED(&)I;F1#1$M/
M8FIE8W0@*%QF,G=I9&=E=%1Y<&5<9C$L(%QF,F]B:F5C=%QF,2P@7&8R:V5Y
M7&8Q+"!<9C)F=6YC=&EO;EQF,2P@7&8R9&%T85QF,2D["BY24R`S"E1H:7,@
M9G5N8W1I;VX@86QL;W=S('1H92!U<V5R('1O(&-R96%T92!S<&5C:6%L(&ME
M>2!B:6YD:6YG<RX@5&AE(`I<9C)W:61G9714>7!E7&8Q('!A<F%M971E<B!I
M<R!A(&1E9FEN960@='EP92!W:&EC:"!S=&%T97,@=VAA="!#9&L@;V)J96-T
M(`IT>7!E(&ES(&)E:6YG('5S960N("!4;R!L96%R;B!M;W)E(&%B;W5T('1H
M92!T>7!E(%QF-$5/8FIE8W14>7!E7&8Q(')E860@=&AE(`I<9C1C9&M?8FEN
M9&EN9UQF,2!M86YU86P@<&%G92X@5&AE(%QF,F]B:F5C=%QF,2!P87)A;65T
M97(@:7,@=&AE('!O:6YT97(@=&\@"G1H92!W:61G970@;V)J96-T+B!4:&4@
M7&8R:V5Y7&8Q(&ES('1H92!C:&%R86-T97(@=&\@8FEN9"X@5&AE(%QF,F9U
M;F-T:6]N7&8Q(`II<R!T:&4@9G5N8W1I;VX@='EP92X@5&\@;&5A<FX@;6]R
M92!A8F]U="!T:&4@:V5Y(&)I;F1I;F<@8V%L;&)A8VL@9G5N8W1I;VX@"G1Y
M<&5S(')E860@=&AE(%QF-&-D:U]B:6YD:6YG7&8Q(&UA;G5A;"!P86=E+B!4
M:&4@;&%S="!P87)A;65T97(@7&8R9&%T85QF,2`*:7,@82!P;VEN=&5R('1O
M(&%N>2!D871A('1H870@;F5E9',@=&\@9V5T('!A<W-E9"!T;R!T:&4@8V%L
M;&)A8VL@9G5N8W1I;VXN"BY210HN4T@@2T59($))3D1)3D=3"E=H96X@=&AE
M('=I9&=E="!I<R!A8W1I=F%T960@=&AE<F4@87)E('-E=F5R86P@9&5F875L
M="!K97D@8FEN9&EN9W,@=VAI8V@@=VEL;`IH96QP('1H92!U<V5R(&5N=&5R
M(&]R(&UA;FEP=6QA=&4@=&AE(&EN9F]R;6%T:6]N('%U:6-K;'DN(%1H92!F
M;VQL;W=I;F<@=&%B;&4*;W5T;&EN97,@=&AE(&ME>7,@86YD('1H96ER(&%C
M=&EO;G,@9F]R('1H:7,@=VED9V5T+@HN3%`*+FYF"BY24R`S"EQF,DME>2`@
M("`@("`@("!!8W1I;VY<9C$*3&5F="!!<G)O=R`@4VAI9G1S('1H92!W:&]L
M92!L:7-T(&QE9G0@;VYE(&-H87)A8W1E<BX*4FEG:'0@07)R;W<@4VAI9G1S
M('1H92!W:&]L92!L:7-T(')I9VAT(&]N92!C:&%R86-T97(N"E5P($%R<F]W
M("`@(%-E;&5C=',@=&AE(&YE>'0@:71E;2!U<"!I;B!T:&4@;&ES="X*1&]W
M;B!!<G)O=R`@4V5L96-T<R!T:&4@;F5X="!I=&5M(&1O=VX@:6X@=&AE(&QI
M<W0N"E!R978@4&%G92`@($UO=F5S(&]N92!P86=E(&)A8VMW87)D<RX*0W1R
M;"U"("`@("`@36]V97,@;VYE('!A9V4@8F%C:W=A<F1S+@I.97AT(%!A9V4@
M("!-;W9E<R!O;F4@<&%G92!F;W)W87)D<RX*0W1R;"U&("`@("`@36]V97,@
M;VYE('!A9V4@9F]R=V%R9',N"F<@("`@("`@("`@($UO=F5S('1O('1H92!F
M:7)S="!E;&5M96YT(&EN('1H92!L:7-T+@HQ("`@("`@("`@("!-;W9E<R!T
M;R!T:&4@9FER<W0@96QE;65N="!I;B!T:&4@;&ES="X*1R`@("`@("`@("`@
M36]V97,@=&\@=&AE(&QA<W0@96QE;65N="!I;B!T:&4@;&ES="X*)"`@("`@
M("`@("`@4VAI9G1S('1H92!W:&]L92!L:7-T('1O('1H92!F87(@<FEG:'0N
M"GP@("`@("`@("`@(%-H:69T<R!T:&4@=VAO;&4@;&ES="!T;R!T:&4@9F%R
M(&QE9G0N"E)E='5R;B`@("`@($5X:71S('1H92!S8W)O;&QI;F<@;&ES="!A
M;F0@<F5T=7)N<R!A;B!I;G1E9V5R"B`@("`@("`@("`@(')E<')E<V5N=&EN
M9R!T:&4@8W5R<F5N=&QY('-E;&5C=&5D(&ET96TN"E1A8B`@("`@("`@($5X
M:71S('1H92!S8W)O;&QI;F<@;&ES="!A;F0@<F5T=7)N<R!A;B!I;G1E9V5R
M"B`@("`@("`@("`@(')E<')E<V5N=&EN9R!T:&4@8W5R<F5N=&QY('-E;&5C
M=&5D(&ET96TN"D-T<FPM3B`@("`@($5X:71S('1H92!S8W)O;&QI;F<@;&ES
M="!A;F0@<F5T=7)N<R`M,2X*17-C87!E("`@("`@17AI=',@=&AE('-C<F]L
M;&EN9R!L:7-T(&%N9"!R971U<FYS("TQ+@I#=')L+4P@("`@("!2969R97-H
M97,@=&AE('-C<F5E;BX*+E)%"BYF:0HN4T@@4T5%($%,4T\*+D)2(&-D:R`H
M,RDL"BY"4B!C9&M?8FEN9&EN9R`H,RDL"BY"4B!C9&M?9&ES<&QA>2`H,RDL
M"BY"4B!C9&M?<V-R965N("@S*0HN4T@@3D]415,*+E!0"E1H92!H96%D97(@
M9FEL92!<9C0\8V1K+F@^7&8Q(&%U=&]M871I8V%L;'D@:6YC;'5D97,@=&AE
M(&AE861E<B!F:6QE<PI<9C0\8W5R<V5S+F@^7&8Q+"!<9C0\<W1D;&EB+F@^
M7&8Q+"!<9C0\<W1R:6YG+F@^7&8Q+"!<9C0\8W1Y<&4N:#Y<9C$L"EQF-#QU
M;FES=&0N:#Y<9C$L(%QF-#QD:7)E;G0N:#Y<9C$L(%QF-#QT:6UE+F@^7&8Q
M+"!<9C0\97)R;F\N:#Y<9C$L"EQF-#QP=V0N:#Y<9C$L(%QF-#QG<G`N:#Y<
M9C$L(%QF-#QS>7,O<W1A="YH/EQF,2P@86YD(%QF-#QS>7,O='EP97,N:#Y<
M9C$N"E1H92!<9C0\8W5R<V5S+F@^7&8Q(&AE861E<B!F:6QE(&EN8VQU9&5S
M(%QF-#QS=&1I;RYH/EQF,2!A;F0@7&8T/'5N8W1R;"YH/EQF,2X*+E!0"DEF
M('EO=2!H879E(%QF-$YC=7)S97-<9C$@:6YS=&%L;&5D(&]N('EO=7(@;6%C
M:&EN92!A9&0@+41.0U524T53('1O('1H92`*8V]M<&EL92!L:6YE('1O(&EN
H8VQU9&4@=&AE($YC=7)S97,@:&5A9&5R(&9I;&5S(&EN<W1E860N"G1O
`
end
SHAR_EOF
  echo 'File man/scroll.3 is complete' &&
  echo 'uudecoding file man/scroll.3' &&
  uudecode _sharuue.tmp < _sharuue.tmp && rm -f _sharuue.tmp &&
  $shar_touch -am 0503190996 'man/scroll.3' &&
  chmod 0444 'man/scroll.3' ||
  echo 'restore of man/scroll.3 failed'
  shar_count="`wc -c < 'man/scroll.3'`"
  test 9355 -eq "$shar_count" ||
    echo "man/scroll.3: original size 9355, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= man/selection.3 ==============
if test -f 'man/selection.3' && test X"$1" != X"-c"; then
  echo 'x - skipping man/selection.3 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting man/selection.3 (binary)'
  sed 's/^X//' << 'SHAR_EOF' > _sharuue.tmp &&
begin 600 man/selection.3
M+F1E($ET"BYB<@HN:64@7%QN*"XD/CTS("YN92!<7"0S"BYE;"`N;F4@,PHN
M25`@(EQ<)#$B(%Q<)#(*+BX*+E1((&-D:U]S96QE8W1I;VX@,R`B,#4@1&5C
M(#$Y.34B"BY32"!.04U%"FYE=T-$2U-E;&5C=&EO;BP@86-T:79A=&5#1$M3
M96QE8W1I;VXL(&EN:F5C=$-$2U-E;&5C=&EO;BP@<V5T0T1+4V5L96-T:6]N
M+`ID<F%W0T1+4V5L96-T:6]N+"!E<F%S94-$2U-E;&5C=&EO;BP@9&5S=')O
M>4-$2U-E;&5C=&EO;BP@"G-E=$-$2U-E;&5C=&EO;E!R95!R;V-E<W,L('-E
M=$-$2U-E;&5C=&EO;E!O<W10<F]C97-S(%PM($-R96%T97,@82!M86YA9V5D
M(`IC=7)S97,@<V5L96-T:6]N(&QI<W0@=VED9V5T+@HN4T@@4UE.3U!325,*
M+DQ0"BY"(&-C"BY222`B6R`B(")F;&%G(B`B(%Q\+EQ\+EQ\+B!=("(@(F9I
M;&4B("(@7'PN7'PN7'PN(@HN0B!<+6QC9&L*+E))(");("(@(FQI8G)A<GDB
M("(@7'PN7'PN7'PN(%TB"BY,4`HC:6YC;'5D92`\8V1K+F@^"BY,4`HN0DD@
M(D-$2U-%3$5#5$E/3B`J;F5W0T1+4V5L96-T:6]N("A#1$M30U)%14X@*B(@
M(F-D:W-C<F5E;B(L"BY"22`B:6YT("(@(GAP;W,B+`HN0DD@(FEN="`B(")Y
M<&]S(BP*+D))(")I;G0@(B`B:&5I9VAT(BP*+D))(")I;G0@(B`B=VED=&@B
M+`HN0DD@(F-H87(@*B(@(G1I=&QE(BP*+D))(")C:&%R("HJ(B`B<V5L96-T
M:6]N3&ES="(L"BY"22`B:6YT("(@(G-E;&5C=&EO;DQI<W1,96YG=&@B+`HN
M0DD@(F-H87(@*BHB(")C:&]I8V5,:7-T(BP*+D))(")I;G0@(B`B8VAO:6-E
M3&ES=$QE;F=T:"(L"BY"22`B8VAT>7!E("(@(FAI9VAL:6=H="(L"BY"22`B
M8F]O;&5A;B`B(")B;W@B+`HN0DD@(F)O;VQE86X@(B`B<VAA9&]W(BD["BY,
M4`HN0DD@(FEN="!A8W1I=F%T94-$2U-E;&5C=&EO;B`H0T1+4T5,14-424].
M("HB(")S96QE8W1I;VXB+`HN0DD@(F-H='EP92`J("(@(F%C=&EO;G,B*3L*
M+DQ0"BY"22`B:6YT(&EN:F5C=$-$2U-E;&5C=&EO;B`H0T1+4T5,14-424].
M("HB(")S96QE8W1I;VXB+`HN0DD@(F-H='EP92`B(")I;G!U="(I.PHN3%`*
M+D))(")V;VED('-E=$-$2U-E;&5C=&EO;B`H0T1+4T5,14-424].("HB(")S
M96QE8W1I;VXB+`HN0DD@(F-H='EP92`B(")H:6=H;&EG:'0B+`HN0DD@(F-H
M='EP92`B(")C:&]I8V5#:&%R86-T97(B+`HN0DD@(F)O;VQE86X@(B`B8F]X
M(BD["BY,4`HN0DD@(G9O:60@9')A=T-$2U-E;&5C=&EO;B`H0T1+4T5,14-4
M24].("HB(")S96QE8W1I;VXB+`HN0DD@(F)O;VQE86X@(B`B8F]X(BD["BY,
M4`HN0DD@(G9O:60@97)A<V5#1$M396QE8W1I;VX@*$-$2U-%3$5#5$E/3B`J
M(B`B<V5L96-T:6]N(BD["BY,4`HN0DD@(G9O:60@9&5S=')O>4-$2U-E;&5C
M=&EO;B`H0T1+4T5,14-424].("HB(")S96QE8W1I;VXB*3L*+DQ0"BY"22`B
M=F]I9"!S971#1$M396QE8W1I;VY0<F50<F]C97-S("A#1$M314Q%0U1)3TX@
M*B(@(G-E;&5C=&EO;B(L"BY"22`B4%)/0T534T9.("(@(F-A;&QB86-K(BP*
M+D))(")V;VED("H@(B`B9&%T82(I.PHN3%`*+D))(")V;VED('-E=$-$2U-E
M;&5C=&EO;E!O<W10<F]C97-S("A#1$M314Q%0U1)3TX@*B(@(G-E;&5C=&EO
M;B(L"BY"22`B4%)/0T534T9.("(@(F-A;&QB86-K(BP*+D))(")V;VED("H@
M(B`B9&%T82(I.PHN3%`*+D))(")V;VED(&)I;F1#1$M/8FIE8W0@*$5/8FIE
M8W14>7!E("(@(G=I9&=E=%1Y<&4B+`HN0DD@(G9O:60@*B(@(F]B:F5C="(L
M"BY"22`B8VAT>7!E("(@(FME>2(L"BY"22`B0DE.1$9.("(@(F9U;F-T:6]N
M(BP*+D))(")V;VED("HB(")D871A(BD["BY32"!$15-#4DE05$E/3@I4:&4@
M0V1K('-E;&5C=&EO;B!W:61G970@8W)E871E<R!A('-E;&5C=&EO;B!L:7-T
M+B!4:&4@9F]L;&]W:6YG(&%R92!F=6YC=&EO;G,@"G=H:6-H(&-R96%T92!O
M<B!M86YI<'5L871E('1H92!#9&L@<V5L96-T:6]N(&)O>"!W:61G970N"@I#
M1$M314Q%0U1)3TX@*FYE=T-$2U-E;&5C=&EO;B`H7&8R<V-R965N7&8Q+"!<
M9C)X<&]S7&8Q+"!<9C)Y<&]S7&8Q+"!<9C)H96EG:'1<9C$L(%QF,G=I9'1H
M7&8Q+"!<9C)T:71L95QF,2P@7&8R<V5L96-T:6]N3&ES=%QF,2P@7&8R<V5L
M96-T:6]N3&ES=$QE;F=T:%QF,2P@7&8R8VAO:6-E3&ES=%QF,2P@7&8R8VAO
M:6-E3&ES=$QE;F=T:%QF,2P@7&8R:&EG:&QI9VAT7&8Q+"!<9C)B;WA<9C$L
M(%QF,G-H861O=UQF,2D["BY24R`S"E1H:7,@9G5N8W1I;VX@8W)E871E<R!A
M('!O:6YT97(@=&\@82!S96QE8W1I;VX@=VED9V5T+B!4:&4@<&%R86UE=&5R
M"EQF,G-C<F5E;EQF,2!I<R!O9B!T>7!E($-$2U-#4D5%3BX@5&AE('!A<F%M
M971E<B!<9C)X<&]S7&8Q(&-O;G1R;VQS('1H92`*<&QA8V5M96YT(&]F('1H
M92!O8FIE8W0@86QO;F<@=&AE(&AO<FEZ;VYT86P@87AI<SL@=VAI8V@@;65A
M;G,@:70@8V%N('1A:V4@"F%N(&EN=&5G97(@=F%L=64@;W(@=&AE('!R92UD
M969I;F5D('9A;'5E<R!O9B!<9C1,14947&8Q+"!<9C1224=(5%QF,2P@86YD
M(`I<9C1#14Y415)<9C$N(%1H92!P87)A;65T97(@7&8R>7!O<UQF,2!C;VYT
M<F]L<R!T:&4@<&QA8V5M96YT(&]F('1H92!O8FIE8W0@"F%L;VYG('1H92!V
M97)T:6-A;"!A>&ES('=H:6-H(&UE86YS(&ET(&-A;B!A8V-E<'0@86X@:6YT
M96=E<B!V86QU92!O<B!A(`IP<F4M9&5F:6YE9"!V86QU92!O9B!<9C143U!<
M9C$L(%QF-$)/5%1/35QF,2P@86YD(%QF-$-%3E1%4EQF,2X@5&AE('!A<F%M
M971E<G,*7&8R:&5I9VAT7&8Q(&%N9"!<9C)W:61T:%QF,2!S=&%T92!H;W<@
M=&%L;"!A;F0@=VED92!T:&4@<V5L96-T:6]N('=I;F1O=R`*:7,@=&\@8F4N
M(%1H92!P87)A;65T97(@7&8R=&ET;&5<9C$@:7,@=&AE('1I=&QE(&]F('1H
M92!S96QE8W1I;VX@;&ES="X@5&AE(`IP87)A;65T97(@7&8R<V5L96-T:6]N
M3&ES=%QF,2!I<R!T:&4@;&ES="!O9B!I=&5M<R!T;R!B92!D:7-P;&%Y960@
M:6X@=&AE(`IS96QE8W1I;VX@;&ES=#L@7&8R<V5L96-T:6]N3&ES=$QE;F=T
M:%QF,2!I<R!T:&4@;G5M8F5R(&]F(&5L96UE;G1S(&EN('1H92`*9VEV96X@
M;&ES="X@5&AE(%QF,F-H;VEC94QI<W1<9C$@<&%R86UE=&5R(&ES('1H92!L
M:7-T(&]F(&-H;VEC97,@=&AA="!W:6QL(`IB92!S96QE8W1E9"!W:&5N('1H
M92!U<V5R('!R97-S97,@=&AE('-P86-E(&)A<CL@7&8R8VAO:6-E3&ES=$QE
M;F=T:%QF,2!I<R`*=&AE(&QE;F=T:"!O9B!T:&ES(&QI<W0N(%1H92!<9C)H
M:6=H;&EG:'1<9C$@<&%R86UE=&5R('-P96-I9FEE<R!T:&4@9&ES<&QA>2`*
M871T<FEB=71E(&]F('1H92!C=7)R96YT;'D@<V5L96-T960@:71E;2X@5&AE
M(%QF,F)O>%QF,2!P87)A;65T97(@<W1A=&5S(`IW:&5T:&5R('1H92!W:61G
M970@=VEL;"!B92!D<F%W;B!W:71H(&$@8F]X(&%R;W5N9"!I="!O<B!N;W0N
M("!4:&4@"EQF,G-H861O=UQF,2!P87)A;65T97(@86-C97!T<R!A(&)O;VQE
M86X@=F%L=64@=&\@='5R;B!T:&4@<VAA9&]W(&]N(&]R(&]F9@IA<F]U;F0@
M=&AI<R!W:61G970N($EF('1H92!W:61G970@8V]U;&0@;F]T(&)E(&-R96%T
M960@=&AE;B!A($Y53$P@<&]I;G1E<B!I<PIR971U<FYE9"X*+E)%"@II;G0@
M86-T:79A=&5#1$M396QE8W1I;VX@*%QF,G-E;&5C=&EO;EQF,2D["BY24R`S
M"E1H:7,@9G5N8W1I;VX@86-T:79A=&5S('1H92!S96QE8W1I;VX@=VED9V5T
M(&%N9"!L971S('1H92!U<V5R(&EN=&5R86-T('=I=&@*=&AE('=I9&=E="X@
M5&AE('!A<F%M971E<B!<9C)A8W1I;VYS7&8Q(&ES(&%N(&%R<F%Y(&]F(%QF
M-&-H='EP95QF,2X@268*7&8R86-T:6]N<UQF,2!I<R!P87-S960@=VET:"!A
M(&YO;BU.54Q,('9A;'5E+"!T:&4@8VAA<F%C=&5R<R!I;B!T:&4@87)R87D@
M"G=I;&P@8F4@:6YS97)T960@:6YT;R!T:&4@=VED9V5T+B!4;R!A8W1I=F%T
M92!T:&4@=VED9V5T(&EN=&5R871I=F5L>2!P87-S(`II;B!A($Y53$P@<&]I
M;G1E<B!F;W(@7&8R86-T:6]N<UQF,2X@268@=&AE(%QF-%)%5%523EQF,2!K
M97D@:7,@96YT97)E9"!I;G1O"G1H92!W:61G970@=&AE;B!A8W1I=F%T92!W
M:6QL(')E='5R;B`P+B!)9B!T:&4@8VAA<F%C=&5R(%QF-$-(5%),+4Y<9C$@
M:7,*96YT97)E9"!T:&5N('1H:7,@9G5N8W1I;VX@<F5T=7)N<R!A('9A;'5E
M(&]F("TQ+B!4;R!G970@=&AE(&EN9F]R;6%T:6]N(`IF<F]M('1H92!S96QE
M8W1I;VX@;&ES="!C:&5C:R!T:&4@=F%L=64@;V8@=&AE(%QF-'-E;&5C=&EO
M;G-<9C$@96QE;65N="`*;V8@=&AE('-E;&5C=&EO;B!O8FIE8W0N"BY210H*
M:6YT(&EN:F5C=$-$2U-E;&5C=&EO;B`H7&8R<V5L96-T:6]N7&8Q+"!<9C)C
M:&%R86-T97)<9C$I.PHN4E,@,PI4:&ES(&9U;F-T:6]N(&EN:F5C=',@82!S
M:6YG;&4@8VAA<F%C=&5R(&EN=&\@=&AE('=I9&=E="X@5&AE('!A<F%M971E
M<B`*7&8R<V5L96-T:6]N7&8Q(&ES(&$@<&]I;G1E<B!T;R!A(&1E9FEN960@
M<V5L96-T:6]N('=I9&=E="X@5&AE('!A<F%M971E<B`*7&8R8VAA<F%C=&5R
M7&8Q(&ES(&]F('1Y<&4@7&8T8VAT>7!E7&8Q(&%N9"!I<R!T:&4@8VAA<F%C
M=&5R('1O(&EN:F5C="!I;G1O"G1H92!W:61G970N($EF('1H92!C:&%R86-T
M97(@:6YJ96-T960@:6YT;R!T:&ES('=I9&=E="!W87,@7&8T4D5455).7&8Q
M('1H96X*82!V86QU92!O9B`Q('=I;&P@8F4@<F5T=7)N960N($EF('1H92!C
M:&%R86-T97(@7&8T0U123"U.7&8Q('=A<R!I;FIE8W1E9`IT:&5N(&$@=F%L
M=64@;V8@+3$@=VEL;"!B92!R971U<FYE9"X@3W1H97)W:7-E('1H:7,@9G5N
M8W1I;VX@<F5T=7)N<R!A(`IV86QU92!O9B`M,BX*+E)%"@IV;VED('-E=$-$
M2U-E;&5C=&EO;B`H7&8R<V5L96-T:6]N7&8Q+"!<9C)H:6=H;&EG:'1<9C$L
M(%QF,F-H;VEC94-H87)A8W1E<EQF,2P@7&8R8F]X7&8Q*3L*+E)3(#,*5&AI
M<R!F=6YC=&EO;B!L971S('1H92!P<F]G<F%M;65R(&UO9&EF>2!C97)T86EN
M(&5L96UE;G1S(&]F(&%N(&%L<F5A9'D@"F1E9FEN960@<V5L96-T:6]N('=I
M9&=E="X@5&AE('!A<F%M971E<B!N86UE<R!C;W)R97-P;VYD('1O('1H92!S
M86UE(`IP87)A;65T97(@;F%M97,@;&ES=&5D(&EN('1H92!<9C1N97=#1$M3
M96QE8W1I;VY<9C$@9G5N8W1I;VXN"BY210H*=F]I9"!D<F%W0T1+4V5L96-T
M:6]N*%QF,G-E;&5C=&EO;EQF,2P@7&8R8F]X7&8Q*3L*+E)3(#,*5&AI<R!F
M=6YC=&EO;B!D<F%W<R!T:&4@<V5L96-T:6]N('=I9&=E="!O;B!T:&4@<V-R
M965N+B!4:&4@7&8R8F]X7&8Q(&]P=&EO;B`*9')A=W,@=&AE('=I9&=E="!W
M:71H(&]R('=I=&AO=70@82!B;W@N"BY210H*=F]I9"!E<F%S94-$2U-E;&5C
M=&EO;B`H7&8R<V5L96-T:6]N7&8Q*3L*+E)3(#,*5&AI<R!F=6YC=&EO;B!R
M96UO=F5S('1H92!W:61G970@9G)O;2!T:&4@<V-R965N+B!4:&ES(&1O97,@
M7&8T3D]47&8Q(&1E<W1R;WD*=&AE('=I9&=E="X*+E)%"@IV;VED(&1E<W1R
M;WE#1$M396QE8W1I;VX@*%QF,G-E;&5C=&EO;EQF,2D["BY24R`S"E1H:7,@
M9G5N8W1I;VX@<F5M;W9E<R!T:&4@=VED9V5T(&9R;VT@=&AE('-C<F5E;B!A
M;F0@9G)E97,@=7`@86YY(&UE;6]R>2!T:&4*;V)J96-T(&UA>2!B92!U<VEN
M9RX*+E)%"@IV;VED('-E=$-$2U-E;&5C=&EO;E!R95!R;V-E<W,@*%QF,G-E
M;&5C=&EO;EQF,2P@7&8R9G5N8W1I;VY<9C$L(%QF,F1A=&%<9C(I.PHN4E,@
M,PI4:&ES(&9U;F-T:6]N(&%L;&]W<R!T:&4@=7-E<B!T;R!H879E('1H92!W
M:61G970@8V%L;"!A(&9U;F-T:6]N(&%F=&5R(&$@:V5Y"FES(&AI="!A;F0@
M8F5F;W)E('1H92!K97D@:7,@87!P;&EE9"!T;R!T:&4@=VED9V5T+B!4:&4@
M<&%R86UE=&5R(%QF,F9U;F-T:6]N7&8Q"FEF(&]F('1Y<&4@7&8T4%)/0T53
M4T9.7&8Q+B!4:&4@<&%R86UE=&5R(%QF,F1A=&%<9C$@:7,@82!P;VEN=&5R
M('1O(`I<9C1V;VED7&8Q+B!4;R!L96%R;B!M;W)E(&%B;W5T('!R92UP<F]C
M97-S:6YG(')E860@=&AE(%QF-&-D:U]P<F]C97-S7&8Q"FUA;G5A;"!P86=E
M+@HN4D4*(`IV;VED('-E=$-$2U-E;&5C=&EO;E!O<W10<F]C97-S("A<9C)S
M96QE8W1I;VY<9C$L(%QF,F9U;F-T:6]N7&8Q+"!<9C)D871A7&8R*3L*+E)3
M(#,*5&AI<R!F=6YC=&EO;B!A;&QO=W,@=&AE('5S97(@=&\@:&%V92!T:&4@
M=VED9V5T(&-A;&P@82!F=6YC=&EO;B!A9G1E<B!T:&4*:V5Y(&AA<R!B965N
M(&%P<&QI960@=&\@=&AE('=I9&=E="X@(%1H92!P87)A;65T97(@7&8R9G5N
M8W1I;VY<9C$@:68@;V8@='EP90I<9C104D]#15-31DY<9C$N(%1H92!P87)A
M;65T97(@7&8R9&%T85QF,2!I<R!A('!O:6YT97(@=&\@7&8T=F]I9%QF,2X@
M5&\*;&5A<FX@;6]R92!A8F]U="!P;W-T+7!R;V-E<W-I;F<@<F5A9"!T:&4@
M7&8T8V1K7W!R;V-E<W-<9C$@;6%N=6%L('!A9V4N"BY210H*=F]I9"!B:6YD
M0T1+3V)J96-T("A<9C)W:61G9714>7!E7&8Q+"!<9C)O8FIE8W1<9C$L(%QF
M,FME>5QF,2P@7&8R9G5N8W1I;VY<9C$L(%QF,F1A=&%<9C$I.PHN4E,@,PI4
M:&ES(&9U;F-T:6]N(&%L;&]W<R!T:&4@=7-E<B!T;R!C<F5A=&4@<W!E8VEA
M;"!K97D@8FEN9&EN9W,N(%1H92`*7&8R=VED9V5T5'EP95QF,2!P87)A;65T
M97(@:7,@82!D969I;F5D('1Y<&4@=VAI8V@@<W1A=&5S('=H870@0V1K(&]B
M:F5C="`*='EP92!I<R!B96EN9R!U<V5D+B`@5&\@;&5A<FX@;6]R92!A8F]U
M="!T:&4@='EP92!<9C1%3V)J96-T5'EP95QF,2!R96%D(`IT:&4@7&8T8V1K
M7V)I;F1I;F=<9C$@;6%N=6%L('!A9V4N(%1H92!<9C)O8FIE8W1<9C$@<&%R
M86UE=&5R(&ES('1H92`*<&]I;G1E<B!T;R!T:&4@=VED9V5T(&]B:F5C="X@
M5&AE(%QF,FME>5QF,2!I<R!T:&4@8VAA<F%C=&5R('1O(&)I;F0N(%1H92`*
M7&8R9G5N8W1I;VY<9C$@:7,@=&AE(&9U;F-T:6]N('1Y<&4N(%1O(&QE87)N
M(&UO<F4@86)O=70@=&AE(&ME>2!B:6YD:6YG(`IC86QL8F%C:R!F=6YC=&EO
M;B!T>7!E<R!R96%D('1H92!<9C1C9&M?8FEN9&EN9UQF,2!M86YU86P@<&%G
M92X@5&AE(&QA<W0@"G!A<F%M971E<B!<9C)D871A7&8Q(&ES(&$@<&]I;G1E
M<B!T;R!A;GD@9&%T82!T:&%T(&YE961S('1O(&=E="!P87-S960@=&\@"G1H
M92!C86QL8F%C:R!F=6YC=&EO;BX*+E)%"@HN4T@@2T59($))3D1)3D=3"E=H
M96X@=&AE('=I9&=E="!I<R!A8W1I=F%T960@=&AE<F4@87)E('-E=F5R86P@
M9&5F875L="!K97D@8FEN9&EN9W,@=VAI8V@@=VEL;`IH96QP('1H92!U<V5R
M(&5N=&5R(&]R(&UA;FEP=6QA=&4@=&AE(&EN9F]R;6%T:6]N('%U:6-K;'DN
M(%1H92!F;VQL;W=I;F<@=&%B;&4*;W5T;&EN97,@=&AE(&ME>7,@86YD('1H
M96ER(&%C=&EO;G,@9F]R('1H:7,@=VED9V5T+@HN3%`*+E)3(#,*+FYF"EQF
M,DME>2`@("`@("`@("!!8W1I;VY<9C$*3&5F="!!<G)O=R`@4VAI9G1S('1H
M92!W:&]L92!L:7-T(&QE9G0@;VYE(&-H87)A8W1E<BX*4FEG:'0@07)R;W<@
M4VAI9G1S('1H92!W:&]L92!L:7-T(')I9VAT(&]N92!C:&%R86-T97(N"E5P
M($%R<F]W("`@(%-E;&5C=',@=&AE(&YE>'0@:71E;2!U<"!I;B!T:&4@;&ES
M="X*1&]W;B!!<G)O=R`@4V5L96-T<R!T:&4@;F5X="!I=&5M(&1O=VX@:6X@
M=&AE(&QI<W0N"E-P86-E("`@("`@($-Y8VQE<R!T;R!T:&4@;F5X="!C:&]I
M8V4@;VX@=&AE(&-U<G)E;G0@:71E;2X*4')E=B!086=E("`@36]V97,@;VYE
M('!A9V4@8F%C:W=A<F1S+@I#=')L+4(@("`@("!-;W9E<R!O;F4@<&%G92!B
M86-K=V%R9',N"DYE>'0@4&%G92`@($UO=F5S(&]N92!P86=E(&9O<G=A<F1S
M+@I#=')L+48@("`@("!-;W9E<R!O;F4@<&%G92!F;W)W87)D<RX*9R`@("`@
M("`@("`@36]V97,@=&\@=&AE(&9I<G-T(&5L96UE;G0@:6X@=&AE(&QI<W0N
M"C$@("`@("`@("`@($UO=F5S('1O('1H92!F:7)S="!E;&5M96YT(&EN('1H
M92!L:7-T+@I'("`@("`@("`@("!-;W9E<R!T;R!T:&4@;&%S="!E;&5M96YT
M(&EN('1H92!L:7-T+@HD("`@("`@("`@("!3:&EF=',@=&AE('=H;VQE(&QI
M<W0@=&\@=&AE(&9A<B!R:6=H="X*?"`@("`@("`@("`@4VAI9G1S('1H92!W
M:&]L92!L:7-T('1O('1H92!F87(@;&5F="X*4F5T=7)N("`@("`@17AI=',@
M=&AE('-E;&5C=&EO;B!L:7-T(&%N9"!R971U<FYS(&%N(&EN=&5G97(*("`@
M("`@("`@("`@<F5P<F5S96YT:6YG('1H92!C=7)R96YT;'D@<V5L96-T960@
M:71E;2X*5&%B("`@("`@("`@17AI=',@=&AE('-E;&5C=&EO;B!L:7-T(&%N
M9"!R971U<FYS(&%N(&EN=&5G97(*("`@("`@("`@("`@<F5P<F5S96YT:6YG
M('1H92!C=7)R96YT;'D@<V5L96-T960@:71E;2X*0W1R;"U.("`@("`@17AI
M=',@=&AE('-E;&5C=&EO;B!L:7-T(&%N9"!R971U<FYS("TQ+@I%<V-A<&4@
M("`@("!%>&ET<R!T:&4@<V5L96-T:6]N(&QI<W0@86YD(')E='5R;G,@+3$N
M"D-T<FPM3"`@("`@(%)E9G)E<VAE<R!T:&4@<V-R965N+@HN4D4*+F9I"BY3
M2"!3144@04Q33PHN0E(@8V1K("@S*2P*+D)2(&-D:U]B:6YD:6YG("@S*2P*
M+D)2(&-D:U]D:7-P;&%Y("@S*2P*+D)2(&-D:U]S8W)E96X@*#,I"BY32"!.
M3U1%4PHN4%`*5&AE(&AE861E<B!F:6QE(%QF-#QC9&LN:#Y<9C$@875T;VUA
M=&EC86QL>2!I;F-L=61E<R!T:&4@:&5A9&5R(&9I;&5S"EQF-#QC=7)S97,N
M:#Y<9C$L(%QF-#QS=&1L:6(N:#Y<9C$L(%QF-#QS=')I;F<N:#Y<9C$L(%QF
M-#QC='EP92YH/EQF,2P*7&8T/'5N:7-T9"YH/EQF,2P@7&8T/&1I<F5N="YH
M/EQF,2P@7&8T/'1I;64N:#Y<9C$L(%QF-#QE<G)N;RYH/EQF,2P*7&8T/'!W
M9"YH/EQF,2P@7&8T/&=R<"YH/EQF,2P@7&8T/'-Y<R]S=&%T+F@^7&8Q+"!A
M;F0@7&8T/'-Y<R]T>7!E<RYH/EQF,2X*5&AE(%QF-#QC=7)S97,N:#Y<9C$@
M:&5A9&5R(&9I;&4@:6YC;'5D97,@7&8T/'-T9&EO+F@^7&8Q(&%N9"!<9C0\
M=6YC=')L+F@^7&8Q+@HN4%`*268@>6]U(&AA=F4@7&8T3F-U<G-E<UQF,2!I
M;G-T86QL960@;VX@>6]U<B!M86-H:6YE(&%D9"`M1$Y#55)315,@=&\@=&AE
M(`IC;VUP:6QE(&QI;F4@=&\@:6YC;'5D92!T:&4@3F-U<G-E<R!H96%D97(@
/9FEL97,@:6YS=&5A9"X*
`
end
SHAR_EOF
  echo 'uudecoding file man/selection.3' &&
  uudecode _sharuue.tmp < _sharuue.tmp && rm -f _sharuue.tmp &&
  $shar_touch -am 0503190996 'man/selection.3' &&
  chmod 0444 'man/selection.3' ||
  echo 'restore of man/selection.3 failed'
  shar_count="`wc -c < 'man/selection.3'`"
  test 8970 -eq "$shar_count" ||
    echo "man/selection.3: original size 8970, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= man/swindow.3 ==============
if test -f 'man/swindow.3' && test X"$1" != X"-c"; then
  echo 'x - skipping man/swindow.3 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting man/swindow.3 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'man/swindow.3' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH cdk_swindow 3 "05 Dec 1995"
X.SH NAME
newCDKSwindow, activateCDKSwindow, injectCDKSwindow, setCDKSwindow,
drawCDKSwindow, eraseCDKSwindow, cleanCDKSwindow, addCDKSwindow, 
execCDKSwindow, trimCDKSwindow, destroyCDKSwindow, setCDKSwindowPreProcess, 
setCDKSwindowPostProcess \- Creates a managed curses swindow widget.
X.SH SYNOPSIS
X.LP
X.B cc
X.RI "[ " "flag" " \|.\|.\|. ] " "file" " \|.\|.\|."
X.B \-lcdk
X.RI "[ " "library" " \|.\|.\|. ]"
X.LP
#include <cdk.h>
X.LP
X.BI "CDKSWINDOW *newCDKSwindow (CDKSCREEN *" "cdkscreen",
X.BI "int " "xpos",
X.BI "int " "ypos",
X.BI "int " "height",
X.BI "int " "width",
X.BI "char *" "title",
X.BI "int " "saveLines",
X.BI "boolean " "box",
X.BI "boolean " "shadow");
X.LP
X.BI "void activateCDKSwindow (CDKSWINDOW *" "swindow",
X.BI "chtype * " "actions");
X.LP
X.BI "int injectCDKSwindow (CDKSWINDOW *" "swindow",
X.BI "chtype " "input");
X.LP
X.BI "void setCDKSwindow (CDKSWINDOW *" "swindow",
X.BI "char **" "info",
X.BI "int " "lines",
X.BI "boolean " "box");
X.LP
X.BI "void drawCDKSwindow (CDKSWINDOW *" "swindow",
X.BI "boolean " "box");
X.LP
X.BI "void eraseCDKSwindow (CDKSWINDOW *" "swindow");
X.LP
X.BI "void cleanCDKSwindow (CDKSWINDOW *" "swindow");
X.LP
X.BI "void addCDKSwindow (CDKSWINDOW *" "swindow",
X.BI "char *" "info",
X.BI "int " "insertPosition");
X.LP
X.BI "int execCDKSwindow (CDKSWINDOW *" "swindow",
X.BI "char * " "command",
X.BI "int " "insertPosition");
X.LP
X.BI "void trimCDKSwindow (CDKSWINDOW *" "swindow",
X.BI "int " "start",
X.BI "int " "finish");
X.LP
X.BI "void destroyCDKSwindow (CDKSWINDOW *" "swindow");
X.LP
X.BI "void setCDKSwindowPreProcess (CDKSWINDOW *" "swindow",
X.BI "PROCESSFN " "callback",
X.BI "void * " "data");
X.LP
X.BI "void setCDKSwindowPostProcess (CDKSWINDOW *" "swindow",
X.BI "PROCESSFN " "callback",
X.BI "void * " "data");
X.LP
X.BI "void bindCDKObject (EObjectType " "widgetType",
X.BI "void *" "object",
X.BI "chtype " "key",
X.BI "BINDFN " "function",
X.BI "void *" "data");
X.SH DESCRIPTION
The Cdk scrolling window widget creates a widget which can be used to display
messages. The following are functions which create or manipulate the Cdk 
swindow box widget.
X
CDKSWINDOW *newCDKSwindow (\f2screen\f1, \f2xpos\f1, \f2ypos\f1, \f2height\f1, \f2width\f1, \f2title\f1, \f2saveLines\f1, \f2box\f1);
X.RS 3
This function creates a pointer to a swindow widget. The parameter \f2screen\f1
is of type CDKSCREEN. The parameter \f2xpos\f1 controls the placement of the 
object along the horizontal axis; which means it can take an integer value
or the pre-defined values of \f4LEFT\f1, \f4RIGHT\f1, and \f4CENTER\f1. The
parameter \f2ypos\f1 controls the placement of the object along the vertical
axis which means it can accept an integer value or a pre-defined value of 
\f4TOP\f1, \f4BOTTOM\f1, and \f4CENTER\f1. The parameters \f2height\f1 and
\f2width\f1 are the height and the width of the window respectively. The
\f2title\f1 parameter is the title of the scrolling window. The parameter
\f2saveLines\f1 is the number of lines to save before throwing information
away. The \f2box\f1 parameter states whether the widget will
be drawn with a box around it or not. The \f2shadow\f1 parameter accepts a 
boolean value to turn the shadow on or off around this widget. If the widget
could not be created then a NULL pointer is returned.
X.RE
X
void activateCDKSwindow (\f2swindow\f1, \f2actions\f1);
X.RS 3
This function activates the swindow widget and lets the user interact with the
widget. The parameter \f2actions\f1 is an array of \f4chtype\f1. If
\f2actions\f1 is passed with a non-NULL value, the characters in the array 
will be inserted into the widget. To activate the widget interatively pass 
in a NULL pointer for \f2actions\f1. If the characters \f4RETURN\f1, \f4TAB\f1,
or \f4CTRL-N\f1 are entered then this function exits. This function returns
nothing.
X.RE
X
void setCDKSwindow (\f2swindow\f1, \f2info\f1, \f2lines\f1, \f2box\f1);
X.RS 3
This function lets the programmer modify certain elements of an already defined
swindow widget. The parameter \f2info\f1 is a \f4char **\f1 of the information
to set in the scrolling window; \f2lines\f1 is the number of lines being added.
The other parameter names correspond to the same parameter names listed in the 
\f4newCDKSwindow\f1 function.
X.RE
X
void drawCDKSwindow(\f2swindow\f1, \f2box\f1);
X.RS 3
This function draws the swindow widget on the screen. The \f2box\f1 option 
draws the widget with or without a box.
X.RE
X
void eraseCDKSwindow (\f2swindow\f1);
X.RS 3
This function removes the widget from the screen. This does \f4NOT\f1 destroy
the widget.
X.RE 
X
void cleanCDKSwindow (\f2swindow\f1);
X.RS 3
This function clears the information from the window.
X.RE
X
void addCDKSwindow (\f2swindow\f1, \f2info\f1, \f2insertPosition\f1);
X.RS 3
This function adds information to a defined scrolling window. The information
is supplied by the \f2info\f1 parameter. The information is immediately added
to the scrolling window. The position of the new information is governed by
the value of the parameter \f2insertPosition\f1. This parameter can accept
two values: \f4TOP\f1 or \f4BOTTOM\f1.
X.RE
X
void execCDKSwindow (\f2swindow\f1, \f2command\f1, \f2insertPosition\f1);
X.RS 3
This function allows the user to execute a shell command and have the output
of the shell command direct itself to the scrolling window. The \f2command\f1
parameter is the command to execute while \f2insertPosition\f1 is where the
output is to insert itself within the scrolling window.
X.RE
X
void trimCDKSwindow (\f2swindow\f1, \f2start\f1, \f2end\f1);
X.RS 3
This function removes information from the scrolling window. The parameters
\f2start\f1 and \f2end\f1 state where to start cutting from and where to stop.
The first element in the scrolling window starts at index 0.
X.RE
X
void destroyCDKSwindow (\f2swindow\f1);
X.RS 3
This function removes the widget from the screen and frees up any memory the
object may be using.
X.RE
X
void setCDKSwindowPreProcess (\f2swindow\f1, \f2function\f1, \f2data\f2);
X.RS 3
This function allows the user to have the widget call a function after a key
is hit and before the key is applied to the widget. The parameter \f2function\f1
if of type \f4PROCESSFN\f1. The parameter \f2data\f1 is a pointer to 
\f4void\f1. To learn more about pre-processing read the \f4cdk_process\f1
manual page.
X.RE
X 
void setCDKSwindowPostProcess (\f2swindow\f1, \f2function\f1, \f2data\f2);
X.RS 3
This function allows the user to have the widget call a function after the
key has been applied to the widget.  The parameter \f2function\f1 if of type
\f4PROCESSFN\f1. The parameter \f2data\f1 is a pointer to \f4void\f1. To
learn more about post-processing read the \f4cdk_process\f1 manual page.
X.RE
X
void bindCDKObject (\f2widgetType\f1, \f2object\f1, \f2key\f1, \f2function\f1, \f2data\f1);
X.RS 3
This function allows the user to create special key bindings. The 
\f2widgetType\f1 parameter is a defined type which states what Cdk object 
type is being used.  To learn more about the type \f4EObjectType\f1 read 
the \f4cdk_binding\f1 manual page. The \f2object\f1 parameter is the pointer
to the widget object. The \f2key\f1 is the character to bind. The 
\f2function\f1 is the function type. To learn more about the key binding 
callback function types read the \f4cdk_binding\f1 manual page. The last 
parameter \f2data\f1 is a pointer to any data that needs to get passed to 
the callback function.
X.RE
X.SH KEY BINDINGS
When the widget is activated there are several default key bindings which will
help the user enter or manipulate the information quickly. The following table
outlines the keys and their actions for this widget.
X.LP
X.nf
X.RS 3
\f2Key          Action\f1
Left Arrow  Scrolls the window left one character.
Right Arrow Scrolls the window right one character.
Up Arrow    Scrolls the window up one line.
Down Arrow  Scrolls the window up down line.
Prev Page   Scrolls the window backwards one page.
Ctrl-B      Scrolls the window backwards one page.
b           Scrolls the window backwards one page.
B           Scrolls the window backwards one page.
Next Page   Scrolls the window forwards one page.
Ctrl-F      Scrolls the window forwards one page.
Space       Scrolls the window forwards one page.
f           Scrolls the window forwards one page.
F           Scrolls the window forwards one page.
Home        Moves the whole list to the far left character.
|           Moves the whole list to the far left character.
End         Moves the whole list to the far right character.
$           Moves the whole list to the far right character.
g           Moves to the top of the scrolling window.
1           Moves to the top of the scrolling window.
G           Moves to the bottom of the scrolling window.
L           Moves half the distance to the end of the file.
l           Moves half the distance to the top of the file.
Return      Exits the widget.
Tab         Exits the widget.
Ctrl-N      Exits the widget.
Ctrl-L      Refreshes the screen.
X.RE
X.fi
X.SH SEE ALSO
X.BR cdk (3),
X.BR cdk_binding (3),
X.BR cdk_display (3),
X.BR cdk_screen (3)
X.SH NOTES
X.PP
The header file \f4<cdk.h>\f1 automatically includes the header files
\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
The \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
X.PP
If you have \f4Ncurses\f1 installed on your machine add -DNCURSES to the 
compile line to include the Ncurses header files instead.
SHAR_EOF
  $shar_touch -am 0503190996 'man/swindow.3' &&
  chmod 0444 'man/swindow.3' ||
  echo 'restore of man/swindow.3 failed'
  shar_count="`wc -c < 'man/swindow.3'`"
  test 9633 -eq "$shar_count" ||
    echo "man/swindow.3: original size 9633, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= man/template.3 ==============
if test -f 'man/template.3' && test X"$1" != X"-c"; then
  echo 'x - skipping man/template.3 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting man/template.3 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'man/template.3' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH cdk_template 3 "05 Dec 1995"
X.SH NAME
newCDKTemplate, activateCDKTemplate, injectCDKTemplate, setCDKTemplate,
setCDKTemplateCB, drawCDKTemplate, eraseCDKTemplate, cleanCDKTemplate, 
mixCDKTemplate, unmixCDKTemplate, destroyCDKTemplate, setCDKTemplatePreProcess,
setCDKTemplatePostProcess \- Creates a managed curses template 
widget.
X.SH SYNOPSIS
X.LP
X.B cc
X.RI "[ " "flag" " \|.\|.\|. ] " "file" " \|.\|.\|."
X.B \-lcdk
X.RI "[ " "library" " \|.\|.\|. ]"
X.LP
#include <cdk.h>
X.LP
X.BI "CDKTEMPLATE *newCDKTemplate (CDKSCREEN *" "cdkscreen",
X.BI "int " "xpos",
X.BI "int " "ypos",
X.BI "int " "lpos",
X.BI "char *" "label",
X.BI "char *" "plate",
X.BI "char *" "overlay",
X.BI "boolean " "box",
X.BI "boolean " "shadow");
X.LP
X.BI "char *activateCDKTemplate (CDKTEMPLATE *" "template",
X.BI "chtype * " "actions");
X.LP
X.BI "char *injectCDKTemplate (CDKTEMPLATE *" "template",
X.BI "chtype " "input");
X.LP
X.BI "void setCDKTemplate (CDKTEMPLATE *" "template",
X.BI "char *" "value",
X.BI "boolean " "box");
X.LP
X.BI "void setCDKTemplateCB (CDKTEMPLATE *" "template",
X.BI "TEMPLATECB " "callbackFunction");
X.LP
X.BI "void drawCDKTemplate (CDKTEMPLATE *" "template",
X.BI "boolean " "box");
X.LP
X.BI "void eraseCDKTemplate (CDKTEMPLATE *" "template");
X.LP
X.BI "void cleanCDKTemplate (CDKTEMPLATE *" "template");
X.LP
X.BI "char *mixCDKTemplate (CDKTEMPLATE *" "template");
X.LP
X.BI "char *unmixCDKTemplate (CDKTEMPLATE *" "template");
X.LP
X.BI "void destroyCDKTemplate (CDKTEMPLATE *" "template");
X.LP
X.BI "void setCDKTemplatePreProcess (CDKTEMPLATE *" "template",
X.BI "PROCESSFN " "callback",
X.BI "void * " "data");
X.LP
X.BI "void setCDKTemplatePostProcess (CDKTEMPLATE *" "template",
X.BI "PROCESSFN " "callback",
X.BI "void * " "data");
X.LP
X.BI "void bindCDKObject (EObjectType " "widgetType",
X.BI "void *" "object",
X.BI "chtype " "key",
X.BI "BINDFN " "function",
X.BI "void *" "data");
X.SH DESCRIPTION
The Cdk template widget creates a template widget which allows a user to type 
information into an entry field with a pre-set field format. Typical uses for
this widget would be a date field or a time field. The following are functions
which create or manipulate the Cdk template box widget.
X
CDKTEMPLATE *newCDKTemplate (\f2screen\f1, \f2xpos\f1, \f2ypos\f1, \f2lpos\f1, \f2label\f1, \f2plate\f1, \f2overlay\f1, \f2callbackFunction\f1, \f2box\f1, \f2shadow\f1);
X.RS 3
This function creates a pointer to a template widget. The parameter
\f2screen\f1 is of type CDKSCREEN. The parameter \f2xpos\f1 controls the 
placement of the object along the horizontal axis; which means it can 
take an integer value or the pre-defined values of \f4LEFT\f1, \f4RIGHT\f1, 
and \f4CENTER\f1. The parameter \f2ypos\f1 controls the placement of the 
object along the vertical axis which means it can accept an integer value 
or a pre-defined value of \f4TOP\f1, \f4BOTTOM\f1, and \f4CENTER\f1. The 
parameter \f2lpos\f1 controls where the label is to be set. It can take an 
integer value or one of the pre-defined values: \f4TOP\f1, \f4BOTTOM\f1, 
\f4LEFT\f1, \f4RIGHT\f1, and \f4CENTER\f1. The \f2label\f1 parameter is the 
string which will be displayed in the label of the template field. The 
\f2plate\f1 parameter defines what character is allowed at what position 
in the template field. This is done by creating a character plate by using 
special format character to tell the template widget what type of character 
is allowed where in the template widget.  The following table lists all of
the current format types.
X.LP
X.nf 
X.RS 3
\f2Plate_Character   Effect\f1
#                 Accepts an integer value.
A                 Accepts an alphabetic value.
C                 Accepts an alphabetic value. Automatically
X                  converts the character to upper case.
c                 Accepts an alphabetic value. Automatically
X                  converts the character to lower case.
M                 Accepts alphanumeric characters.
XX                 Accepts alphanumeric characters. Automatically
X                  converts the character to upper case.
x                 Accepts alphanumeric characters. Automatically
X                  converts the character to upper case.
Anything else     Ignored and assumed a non-editable position.
X.fi
X.RE
X.LP
The \f2overlay\f1 parameter is the overlay of the template field. If the field
needed some sort of overlay, this parameter supplies this. A date field could
have YY/MM/DD, the overlay parameter would display YY/MM/DD on an empty template
field.  The \f2box\f1 parameter states whether the widget will be drawn with a 
box around it or not. The \f2shadow\f1 parameter accepts a boolean value to 
turn the shadow on or off around this widget. The \f2box\f1 parameter states 
whether the widget will be drawn with a box around it or not. The \f2shadow\f1 
parameter accepts a boolean value to turn the shadow on or off around this 
widget. If the widget could not be created then a NULL pointer is returned.
X.RE
X
char *activateCDKTemplate (\f2template\f1, \f2actions\f1);
X.RS 3
This function activates the template widget and lets the user interact with 
the widget.  The parameter \f2actions\f1 is an array of \f4chtype\f1. If
\f2actions\f1 is passed with a non-NULL value, the characters in the array 
will be inserted into the widget. To activate the widget interatively pass 
in a NULL pointer for \f2actions\f1. If the character injected into this 
widget was \f4RETURN\f1 or \f4TAB\f1 then the information which was typed 
into the field will be returned. Otherwise this function returns a value 
stored in the global variable \f4GEarlyExit\f1.
X.RE
X
char *injectCDKTemplate (\f2template\f1, \f2character\f1);
X.RS 3
This function injects a single character into the widget. The parameter 
\f2template\f1 is a pointer to a defined template widget. The parameter 
\f2character\f1 is of type \f4chtype\f1 and is the character to inject into
the widget. If the character injected into this widget was \f4RETURN\f1 or
\f4TAB\f1 then the information which was typed into the field will 
be returned. Otherwise this function returns a value stored in the
global variable \f4GEarlyExit\f1.
X.RE
X
void setCDKTemplate (\f2template\f1, \f2value\f1, \f2box\f1);
X.RS 3
This function lets the programmer modify certain elements of an already defined
template widget. The parameter names correspond to the same parameter names 
listed in the \f4newCDKTemplate\f1 function.
X.RE
X
void setCDKTemplateCB (\f2template\f1, \f2callbackFunction\f1);
X.RS 3
This function allows the programmer to set a different widget input handler.
The parameter \f2callbackFunction\f1 is of type \f4TEMPLATECB\f1. The current
default function is \f4CDKTemplateCallBack\f1.
X.RE
X
void drawCDKTemplate(\f2template\f1, \f2box\f1);
X.RS 3
This function draws the template widget on the screen. The \f2box\f1 option 
draws the widget with or without a box.
X.RE
X
void eraseCDKTemplate (\f2template\f1);
X.RS 3
This function removes the widget from the screen. This does \f4NOT\f1 destroy
the widget.
X.RE
X
void cleanCDKTemplate (\f2template\f1);
X.RS 3
This function clears the information from the field.
X.RE
X
char *mixCDKTemplate (\f2template\f1);
X.RS 3
This function returns a \f4char *\f1 pointer to the field value and the 
plate.
X.RE
X
char *unmixCDKTemplate (\f2template\f1);
X.RS 3
This function returns a \f4char *\f1 pointer to the field value without any
plate characters.
X.RE
X
void destroyCDKTemplate (\f2template\f1);
X.RS 3
This function removes the widget from the screen and frees up any memory the
object may be using.
X.RE
X
void bindCDKObject (\f2widgetType\f1, \f2object\f1, \f2key\f1, \f2function\f1, \f2data\f1);
X.RS 3
This function allows the user to create special key bindings. The 
\f2widgetType\f1 parameter is a defined type which states what Cdk object 
type is being used.  To learn more about the type \f4EObjectType\f1 read the 
\f4cdk_binding\f1 manual page. The \f2object\f1 parameter is the pointer to 
the widget object. The \f2key\f1 is the character to bind. The \f2function\f1 
is the function type. To learn more about the key binding callback function 
types read the \f4cdk_binding\f1 manual page. The last parameter \f2data\f1 
is a pointer to any data that needs to get passed to the callback function.
X.RE
X
X.SH KEY BINDINGS
When the widget is activated there are several default key bindings which will
help the user enter or manipulate the information quickly. The following table
outlines the keys and their actions for this widget.
X.LP
X.nf
X.RS 3
\f2Key          Action\f1
Delete      Deletes the character to the left of the cursor.
Backspace   Deletes the character to the left of the cursor.
Return      Exits the widget and returns a char * representing
X            the information which was typed into the field.
Tab         Exits the widget and returns a char * representing
X            the information which was typed into the field.
Ctrl-P      Pastes whatever is in the paste buffer, into the widget.
Ctrl-K      Cuts the contents from the wigdte and saves a copy in 
X            the paste buffer.
Ctrl-T      Copies the contents of the widget into the paste buffer.
Ctrl-E      Erases the contents of the widget.
Ctrl-N      Exits the widget and returns a char * representing
X            the information which was typed into the field.
Ctrl-L      Refreshes the screen.
X.RE 
X.fi
X.SH SEE ALSO
X.BR cdk (3),
X.BR cdk_binding (3),
X.BR cdk_display (3),
X.BR cdk_screen (3)
X.SH NOTES
X.PP
The header file \f4<cdk.h>\f1 automatically includes the header files
\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
The \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
X.PP
If you have \f4Ncurses\f1 installed on your machine add -DNCURSES to the 
compile line to include the Ncurses header files instead.
SHAR_EOF
  $shar_touch -am 0503190996 'man/template.3' &&
  chmod 0444 'man/template.3' ||
  echo 'restore of man/template.3 failed'
  shar_count="`wc -c < 'man/template.3'`"
  test 9974 -eq "$shar_count" ||
    echo "man/template.3: original size 9974, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= man/viewer.3 ==============
if test -f 'man/viewer.3' && test X"$1" != X"-c"; then
  echo 'x - skipping man/viewer.3 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting man/viewer.3 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'man/viewer.3' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH cdk_viewer 3X "05 Dec 1995"
X.SH NAME
newCDKViewer, activateCDKViewer, setCDKViewer, drawCDKViewer, eraseCDKViewer,
destroyCDKViewer \- Creates a managed curses viewer list widget.
X.SH SYNOPSIS
X.LP
X.B cc
X.RI "[ " "flag" " \|.\|.\|. ] " "file" " \|.\|.\|."
X.B \-lcdk
X.RI "[ " "library" " \|.\|.\|. ]"
X.LP
#include <cdk.h>
X.LP
X.BI "CDKVIEWER *newCDKViewer (CDKSCREEN *" "cdkscreen",
X.BI "int " "xpos",
X.BI "int " "ypos",
X.BI "int " "height",
X.BI "int " "width",
X.BI "char **" "buttonList",
X.BI "int " "buttonCount",
X.BI "chtype " "buttonHighlight",
X.BI "boolean " "box",
X.BI "boolean " "shadow");
X.LP
X.BI "int activateCDKViewer (CDKVIEWER *" "viewer");
X.LP
X.BI "void setCDKViewer (CDKVIEWER *" "viewer",
X.BI "char *" "title",
X.BI "char **" "info",
X.BI "int " "infoSize",
X.BI "chtype " "buttonAttribute",
X.BI "boolean " "interpret",
X.BI "boolean " "box");
X.LP
X.BI "void drawCDKViewer (CDKVIEWER *" "viewer",
X.BI "boolean " "box");
X.LP
X.BI "void eraseCDKViewer (CDKVIEWER *" "viewer");
X.LP
X.BI "void destroyCDKViewer (CDKVIEWER *" "viewer");
X.LP
X.BI "void bindCDKObject (EObjectType " "widgetType",
X.BI "void *" "object",
X.BI "chtype " "key",
X.BI "BINDFN " "function",
X.BI "void *" "data");
X.SH DESCRIPTION
The Cdk viewer widget creates a file viewer widget. This widget allows a user 
to interact with a file. It does \f4NOT\f1 allow editing, this is view only. 
The following are functions which create or manipulate the Cdk viewer list 
widget.
X
CDKVIEWER *newCDKViewer (\f2screen\f1, \f2xpos\f1, \f2ypos\f1, \f2height\f1, \f2width\f1, \f2buttons\f1, \f2buttonCount\f1, \f2buttonHighlight\f1, \f2box\f1, \f2shadow\f1);
X.RS 3
This function creates a pointer to a viewer widget. The parameter \f2screen\f1
is of type CDKSCREEN. The parameter \f2xpos\f1 controls the placement of the 
object along the horizontal axis; which means it can take an integer value or
the pre-defined values of \f4LEFT\f1, \f4RIGHT\f1, and \f4CENTER\f1. The
parameter \f2ypos\f1 controls the placement of the object along the vertical 
axis which means it can accept an integer value or a pre-defined value of 
\f4TOP\f1, \f4BOTTOM\f1, and \f4CENTER\f1. The parameters \f2height\f1 and 
\f2width\f1 state how tall and wide the viewer window is to be.  The 
\f2buttons\f1 is an array of the button labels which are to be attached to
the viewer on the bottom; \f2buttonCount\f1 tells the viewer how many buttons
there are. The parameter \f2buttonHighlight\f1 is the highlight attribute of
the currently selected button.  The \f2box\f1 parameter states whether the 
widget will be drawn with a box around it or not. The \f2shadow\f1 parameter 
accepts a boolean value to turn the shadow on or off around this widget. If 
the widget could not be created then a NULL pointer is returned.
X.RE
X
int activateCDKViewer (\f2viewer\f1);
X.RS 3
This function activates the viewer widget and lets the user interact with the
widget. The only parameter this function requires is the \f2viewer\f1 widget
pointer. If the character injected into this widget was \f4RETURN\f1 then an 
integer value representing XXXX will be returned. If the character injected 
was \f4CTRL-N\f1 then a value of -1 will be returned.
X.RE
X
void setCDKViewer (\f2viewer\f1, \f2title\f1, \f2info\f1, \f2infoSize\f1, \f2buttonAttribute\f1, \f2interpret\f1, \f2box\f1);
X.RS 3
This function lets the programmer modify certain elements of an already defined
viewer widget. The parameter \f2title\f1 is the title to be displayed on
the top of the viewer. The parameter \f2info\f1 is the information to display,
while \f2infoSize\f1 states how many rows there are in the \f2info\f1 array.
The parameter \f2buttonAttribute\f1 states the attribute of the current
highlighted button. The boolean parameter \f2interpret\f1 tells the viewer to 
interpret the contents of \f2info\f1 for Cdk display command, or not. The
parameters \f2box\f1 and \f2shadow\f1 are the same as in the function
description of \f4newCDKViewer\f1.
X.RE
X
void drawCDKViewer(\f2viewer\f1, \f2box\f1);
X.RS 3
This function draws the viewer widget on the screen. The \f2box\f1 option 
draws the widget with or without a box.
X.RE
X
void eraseCDKViewer (\f2viewer\f1);
X.RS 3
This function removes the widget from the screen. This does \f4NOT\f1 destroy
the widget.
X.RE
X
void destroyCDKViewer (\f2viewer\f1);
X.RS 3
This function removes the widget from the screen and frees up any memory the
object may be using.
X.RE
X
void bindCDKObject (\f2widgetType\f1, \f2object\f1, \f2key\f1, \f2function\f1, \f2data\f1);
X.RS 3
This function allows the user to create special key bindings. The 
\f2widgetType\f1 parameter is a defined type which states what Cdk object 
type is being used.  To learn more about the type \f4EObjectType\f1 read 
the \f4cdk_binding\f1 manual page. The \f2object\f1 parameter is the pointer 
to the widget object. The \f2key\f1 is the character to bind. The 
\f2function\f1 is the function type. To learn more about the key binding 
calback function types read the \f4cdk_binding\f1 manual page. The last 
parameter \f2data\f1 is a pointer to any data that needs to get passed to 
the callback function.
X.RE
X.SH KEY BINDINGS
When the widget is activated there are several default key bindings which will
help the user enter or manipulate the information quickly. The following table
outlines the keys and their actions for this widget.
X.LP
X.nf
X.RS 3
\f2Key          Action\f1
Left Arrow  Shifts the contents of the viewer one character left.
Right Arrow Shifts the contents of the viewer one character left
Up Arrow    Scrolls the contents of the viewer one line up.
Down Arrow  Scrolls the contents of the viewer one line up.
Prev Page   Moves one page backwards.
Ctrl-B      Moves one page backwards.
B           Moves one page backwards.
b           Moves one page backwards.
Next Page   Moves one page forwards.
Ctrl-F      Moves one page forwards.
Space       Moves one page forwards.
F           Moves one page forwards.
f           Moves one page forwards.
Home        Shifts the whole list to the far left.
|           Shifts the whole list to the far left.
End         Shifts the whole list to the far right
$           Shifts the whole list to the far right.
g           Moves to the first line in the viewer.
1           Moves to the first line in the viewer.
G           Moves to the last line in the viewer.
L           Moves half the distance to the end of the viewer.
l           Moves half the distance to the top of the viewer.
?           Searches up for a pattern.
/           Searches down for a pattern.
n           Repeats last search.
:           Jumps to a given line.
i           Displays file statistics.
s           Displays file statistics.
Return      Exits the viewer list and returns an integer
X            representing the currently selected button.
Ctrl-N      Exits the viewer list and returns -1.
Ctrl-L      Refreshes the screen.
X.RE
X.fi
X.SH SEE ALSO
X.BR cdk (3X),
X.BR cdk_binding (3X),
X.BR cdk_display (3X),
X.BR cdk_screen (3X)
X.SH NOTES
X.PP
The header file \f4<cdk.h>\f1 automatically includes the header files
\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
The \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
X.PP
If you have \f4Ncurses\f1 installed on your machine add -DNCURSES to the 
compile line to include the Ncurses header files instead.
SHAR_EOF
  $shar_touch -am 0503190996 'man/viewer.3' &&
  chmod 0444 'man/viewer.3' ||
  echo 'restore of man/viewer.3 failed'
  shar_count="`wc -c < 'man/viewer.3'`"
  test 7552 -eq "$shar_count" ||
    echo "man/viewer.3: original size 7552, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= man/cdk.3 ==============
if test -f 'man/cdk.3' && test X"$1" != X"-c"; then
  echo 'x - skipping man/cdk.3 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting man/cdk.3 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'man/cdk.3' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH Cdk 3 "05 Dec 1995"
X.SH NAME
X   Cdk - \f2Curses Development Kit\f1
X.LP
X.SH SYNOPSIS
X.LP
X.B cc
X.RI "[ " "flag" " \|.\|.\|. ] " "file" " \|.\|.\|."
X.B \-lcdk
X.RI "[ " "library" " \|.\|.\|. ]"
X.LP
#include <cdk.h>
X.LP
Cdk provides functions to use a large number of pre-defined
curses widgets. To use the Cdk widgets the header file \f4cdk.h\f1 must be 
included in the source.
X.LP
The widgets available from Cdk are listed below.
X
X.RS 3
X.nf
\f2Widget_Type                 Manual_Page_Name\f1
Dialog                      cdk_dialog (3)
Entry Field                 cdk_entry (3)
File Viewer                 cdk_viewer (3)
Graph                       cdk_graph (3)
Histogram                   cdk_histogram (3)
Item List                   cdk_itemlist (3)
Label                       cdk_label (3)
Marquee                     cdk_marquee (3)
Matrix                      cdk_matrix (3)
Multiple Line Entry Field   cdk_mentry (3)
Numeric Scale               cdk_scale (3)
Pulldown Menu               cdk_menu (3)
Radio List                  cdk_radio (3)
Scrolling List              cdk_scroll (3)
Scrolling Selection List    cdk_selection (3)
Scrolling Window            cdk_swindow (3)
Template                    cdk_template (3)
X.RE
X
The rest of the manual pages are
X.RS 3
\f2Manual_Page_Name            Description\f1
cdk_binding (3)             Outlines how to create user definable
X                            key bindings.
cdk_display (3)             Shows how to add special display
X                            attributes, colors, and justification
X                            into a widget.
cdk_draw (3)                Outlines the basic drawing capabilities of
X                            Cdk.
cdk_screen (3)              Demonstrates the use of screens  
X                            within Cdk.
cdk_process (3)             Demonstrates the use of the pre and post
X                            process function class.
X.RE
X.fi
X
X.SH DESCRIPTION
Cdk is a library of functions which allow a programmer to quickly create a 
full screen interactive program with ease. The Cdk widgets support the 
following features:
X.It "\(bu Ncurses library." 5
Instead of using the standard curses library, Cdk can take advantage of the
colors that Ncurses provides. To learn how to take advantage of Cdk's color
capabilities, read the \f4cdk_display\f1 manual page.
X.PP
X.It "\(bu Key Bindings." 5
Individual keys can be overridden with a callback. The callback is set up using
the \f4bindCDKObject\f1 function. To learn more about this read the
\f4cdk_binding\f1 manual page.
X.PP
X.It "\(bu Pre and Post Processing." 5
Certain widgets allow the user to trap a character before and after the 
character has been applied to the widget. This allows programmers to 'filter'
character input. To learn more about this read the \f4cdk_process\f1 manual
page.
X.PP
X.It "\(bu Self Test Widgets." 5
With the use of the inject function class and the activate function, 
programmers can have the widgets test themselves. This allows the programmer
to perform automated tests on a final program.
X.PP
X.It "\(bu Special Display Formats" 5
There are special character format commands that can be inserted into any 
string in Cdk and the contents will get mapped to a \f4chtype\f1 (see the
curses manual page) with character attributes. This allows the programmer to 
insert format types on each character if they wish.
X.PP
X.It "\(bu The Ability To Build Predefined Screens" 5
Widgets can be associated to any given screen. If there is more than one 
screen defined, then Cdk has the ability to "flip" from one screen to another
with ease. See the \f4cdk_screen\f1 manual page for more details.
X.PP
X
X.SH SEE ALSO
X.BR cdk (3),
X.BR cdk_binding (3),
X.BR cdk_display (3),
X.BR cdk_screen (3)
X.SH NOTES
X.PP
The header file \f4<cdk.h>\f1 automatically includes the header files
\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
The \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
X.PP
If you have \f4Ncurses\f1 installed on your machine add -DNCURSES to the 
compile line to include the Ncurses header files instead.
SHAR_EOF
  $shar_touch -am 0503190996 'man/cdk.3' &&
  chmod 0444 'man/cdk.3' ||
  echo 'restore of man/cdk.3 failed'
  shar_count="`wc -c < 'man/cdk.3'`"
  test 4334 -eq "$shar_count" ||
    echo "man/cdk.3: original size 4334, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= man/screen.3 ==============
if test -f 'man/screen.3' && test X"$1" != X"-c"; then
  echo 'x - skipping man/screen.3 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting man/screen.3 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'man/screen.3' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH cdk_screen 3X "05 Dec 1995"
X.SH NAME
initCDKScreen, initCDKColor, registerCDKObject, unregisterCDKObject,
raiseCDKObject, lowerCDKObject, refreshCDKScreen, eraseCDKScreen,
destroyCDKScreen, endCDK - Cdk Screen and Widget Manipulation Functions
X.SH SYNOPSIS
X.LP
X.B cc
X.RI "[ " "flag" " \|.\|.\|. ] " "file" " \|.\|.\|."
X.B \-lcdk
X.RI "[ " "library" " \|.\|.\|. ]"
X.LP
#include <cdk.h>
X.LP
X.BI "CDKSCREEN *initCDKScreen (WINDOW *" "cursesWindow ");
X.LP
X.BI "void initCDKColor ()";
X.LP
X.BI "void registerCDKObject (CDKSCREEN *" "screen ",
X.BI "EObjectType " "widgetType ",
X.BI "void *" "object");
X.LP
X.BI "void unregisterCDKObject(EObjectType " "widgetType ",
X.BI "void *" "object");
X.LP
X.BI "void raiseCDKObject(EObjectType " "widgetType ",
X.BI "void *" "object");
X.LP
X.BI "void lowerCDKObject(EObjectType " "widgetType ",
X.BI "void *" "object");
X.LP
X.BI "void refreshCDKScreen(CDKSCREEN *" "screen");
X.LP
X.BI "void eraseCDKScreen(CDKSCREEN *" "screen");
X.LP
X.BI "void destroyCDKScreen(CDKSCREEN *" "screen");
X.LP
X.BI "void endCDK()";
X.LP
X.SH DESCRIPTION
One of the features of Cdk is that it will manage all of the widgets for you.
These functions perform some of the management of the widgets in a screen. The
following outline each function and it's purpose.
X
CDKSCREEN *initCDKScreen (\f2cursesWindow\f1);
X.RS 3
This function takes a \f4WINDOW *\f1 (\f2cursesWindow\f1) and returns a 
pointer to a \f4CDKSCREEN *\f1. Since all of the widgets take a 
\f4CDKSCREEN\f1 pointer as a first argument, this is also one of the first 
calls made. This also starts curses, so no curses initialization calls have 
to be made when using Cdk.
X.RE
X
void initCDKColor ();
X.RS 3
This call starts the Cdk color capabilities. It defines 64 color pairs each
of which is accessible using the COLOR_PAIR macro. If you do not have color
support, this function call makes no difference.
X.RE
X
void registerCDKObject (\f2screen\f1, \f2widgetType\f1, \f2object\f1);
X.RS 3
This function is called automatically when a widget is created. If for some
reason an object does get unregistered, by calling \f4unregisterCDKObject\f1, 
the widget can be registered again by calling this function. The 
\f2widgetType\f1 parameter states what Cdk widget type this object is. The 
\f2object\f1 parameter is a void pointer to the object.
X.RE
X
void unregisterCDKObject (\f2cdktype\f1, \f2object\f1);
X.RS 3
This function removes the widget from the screen. This does \f4NOT\f1 destroy 
the object, it mearly removes the widget from any further refreshes by the 
function \f4refreshCDKScreen\f1. The \f2widgetType\f1 parameter states what 
Cdk widget type this object is. The \f2object\f1 parameter is a void pointer 
to the object.
X.RE
X
void raiseCDKObject (\f2cdktype\f1, \f2object\f1);
X.RS 3
This function raises the widget to the top of the screen. If there are any 
widgets which overlap the given object when a refresh is done, calling this
function has the effect of raiding the object so no other widgets obstruct 
it. The \f2widgetType\f1 parameter states what Cdk widget type this object is.
The \f2object\f1 parameter is a void pointer to the object.
X.RE
X
void lowerCDKObject (\f2cdktype\f1, \f2object\f1);
X.RS
This function has the opposite effect of the \f4raiseCDKObject\f1 function
call.
X.RE
X
void refreshCDKScreen (\f2screen\f1);
X.RS 3
This function redraws all of the widgets which are currently associated to the
given screen.
X.RE
X
void eraseCDKScreen (\f2screen\f1);
X.RS 3
This function erases all of the widgets which are currently associated to the
given screen. This does \f4NOT\f1 destroy the widgets.
X.RE
X
void destroyCDKScreen (\f2screen\f1);
X.RS 3
This function destroys any memory allocated by the Cdk screen pointer.
X.RE
X
void endCDK();
X.RS 3
This function cleans up any memory created by starting Cdk and shuts down 
curses.
X.RE
X.SH SEE ALSO
X.BR cdk (3X),
X.BR cdk_binding (3X),
X.BR cdk_display (3X)
X.SH NOTES
X.PP
The header file \f4<cdk.h>\f1 automatically includes the header files
\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
The \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
X.PP
If you have \f4Ncurses\f1 installed on your machine add -DNCURSES to the 
compile line to include the Ncurses header files instead.
SHAR_EOF
  $shar_touch -am 0503190996 'man/screen.3' &&
  chmod 0444 'man/screen.3' ||
  echo 'restore of man/screen.3 failed'
  shar_count="`wc -c < 'man/screen.3'`"
  test 4470 -eq "$shar_count" ||
    echo "man/screen.3: original size 4470, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= man/binding.3 ==============
if test -f 'man/binding.3' && test X"$1" != X"-c"; then
  echo 'x - skipping man/binding.3 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting man/binding.3 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'man/binding.3' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH cdk_display 3 "05 Dec 1995"
X.SH NAME
bindCDKObject, unbindCDKObject, checkCDKObjectBind, cleanCDKObjectBindings -
\f2Curses Development Kit\f1 Character Binding Capabilities.
X.LP
X.SH SYNOPSIS
X.LP
X.B cc
X.RI "[ " "flag" " \|.\|.\|. ] " "file" " \|.\|.\|."
X.B \-lcdk
X.RI "[ " "library" " \|.\|.\|. ]"
X.LP
#include <cdk.h>
X.LP
X.BI "void bindCDKObject (EObjectType" "cdkType",
X.BI "void *" "object",
X.BI "chtype " "key",
X.BI "BINDFN " "function",
X.BI "void *" "data");
X.LP
X.BI "void unbindCDKObject (EObjectType " "cdkType",
X.BI "void *" "object",
X.BI "chtype " "key");
X.LP
X.BI "void checkCDKObjectBind (EObjectType " "cdkType",
X.BI "void *" "object",
X.BI "chtype " "key");
X.LP
X.BI "void cleanCDKObjectBindings (EObjectType " "cdkType",
X.BI "void *" "object");
X.LP
X.SH DESCRIPTION
Cdk has the ability to create user definable key bindings. This ability makes
Cdk more dynamic and usable for a wide variety of tasks. The following section
outlines the binding functions, their use, and their purpose.
X
void bindCDKObject (\f2cdkType\f1, \f2object\f1, \f2key\f1, \f2function\f1, \f2data\f1);
X.RS 3
This function creates a key binding between a specific Cdk widget (\f2object\f1)
given key (\f2key\f1). The parameter \f2cdkType\f1 is of type \f4EObjectType\f1
which is one of the following values.
X.LP
X.nf
\f2EObjectType_Value   Corresponding_Widget         Widget_Manual_Page\f1
vENTRY              Entry Widget                 cdk_entry (3)
vMENTRY             Multiple Line Entry Widget   cdk_mentry (3)
vLABEL              Label Widget                 cdk_label (3)
vSCROLL             Scrolling List Widget        cdk_scroll (3)
vDIALOG             Dialog Widget                cdk_dialog (3)
vSCALE              Numeric Scale Widget         cdk_scale (3)
vMARQUEE            Marquee Widget               cdk_marquee (3)
vMENU               Menu Widget                  cdk_menu (3)
vMATRIX             Matrix Widget                cdk_matrix (3)
vHISTOGRAM          Histogram Widget             cdk_histogram (3)
vSELECTION          Selection List Widget        cdk_selection (3)
vVIEWER             Viewer Widget                cdk_viewer (3)
vGRAPH              Graph Widget                 cdk_graph (3)
vRADIO              Radio List Widget            cdk_radio (3)
vTEMPLATE           Template Entry Widget        cdk_template (3)
vSWINDOW            Scrolling Window Widget      cdk_swindow (3)
vITEMLIST           Item List Widget             cdk_itemlist (3)
X.fi
X.RS 3
The parameter \f2function\f1 is of type \f4BINDFN\f1 which has the following
prototype:
X.RE
X
X.ce
\f4void function (EObjectType cdktype, void *object, void *clientData);\f1
X
X.RS 3
The parameter \f2data\f1 is a \f4void *\f1 pointer to whatever data the callback
function may need.
X.RE 
X
void unbindCDKObject (\f2cdkType\f1, \f2object\f1, \f2key\f1);
X.RS 3
This function removes a specific binding to an object. The parameter names are
the same as the description of the function \f4bindCDKObject\f1.
X.RE
X
int checkCDKObjectBind (\f2cdkType\f1, \f2object\f1, \f2key\f1);
X.RS 3
This function returns an integer value stating whether the key \f2key\f1 has
been bound to the given widget, \f2object\f1.
X.RE
X
void cleanCDKObjectBindings (\f2cdkType\f1, \f2object\f1);
X.RS 3
This function removes all user defined key bindings from the given widget.
X.RE
X
X.SH EXAMPLE
To help demonstrate how to use the key bindings I will demonstrate a simple
dialog box widget with help for each button. The following code segment creates
a dialog box and a callback function named \f4dialogHelpCB\f1.
X.LP
X.nf
X.ce
\f4----------------------------------------\f1
X.LP
#include "cdk.h"
X
void dialogHelpCB (EObjectType cdktype, void *object, void *clientData)
{
X   CDKDIALOG *dialog = (CDKDIALOG *)object;
X   char *mesg[5];
X
X   /* Check which button we are on.		*/
X   if (dialog->currentButton == 0)
X   {
X      mesg[0] = "<C></U>Help for </U>Who<!U>.";
X      mesg[1] = "<C>When this button is picked the name of the current";
X      mesg[2] = "<C>user is displayed on the screen in a popup window.";
X      popUpMessage (dialog->screen, mesg, 3);
X   }
X   else if (dialog->currentButton == 1)
X   {
X      mesg[0] = "<C></U>Help for </U>Time<!U>.";
X      mesg[1] = "<C>When this button is picked the current time is";
X      mesg[2] = "<C>displayed on the screen in a popup window.";
X      popUpMessage (dialog->screen, mesg, 3);
X   }
X   else if (dialog->currentButton == 2)
X   {
X      mesg[0] = "<C></U>Help for </U>Date<!U>.";
X      mesg[1] = "<C>When this button is picked the current date is";
X      mesg[2] = "<C>displayed on the screen in a popup window.";
X      popUpMessage (dialog->screen, mesg, 3);
X   }
X   else if (dialog->currentButton == 3)
X   {
X      mesg[0] = "<C></U>Help for </U>Quit<!U>.";
X      mesg[1] = "<C>When this button is picked the dialog box is exited.";
X      popUpMessage (dialog->screen, mesg, 2);
X   }
}
X
void main()
{
X   /* Declare variables.			*/
X   CDKSCREEN	*cdkscreen;
X   CDKDIALOG	*question;
X   WINDOW	*cursesWin;
X   char		*buttons[40];
X   char		*message[40], *info[5], *loginName;
X   char		temp[256];
X   int		selection;
X   int		x;
X   time_t	clck;
X   struct tm	*currentTime;
X
X   /* Set up CDK 				*/ 
X   cursesWin = initscr();
X   cdkscreen = initCDKScreen (cursesWin);
X
X   /* Start color.              		*/
X   initCDKColor();
X
X   /* Set up the dialog box.			*/
X   message[0] = "<C></U>Simple Command Interface";
X   message[1] = "Pick the command you wish to run.";
X   message[2] = "<C>Press </R>?<!R> for help.";
X   buttons[0] = "Who";
X   buttons[1] = "Time";
X   buttons[2] = "Date";
X   buttons[3] = "Quit";
X
X   /* Create the dialog box.			*/
X   question	= newCDKDialog (cdkscreen, CENTER, CENTER,
X				message, 3, buttons, 4, A_REVERSE,
X				TRUE, TRUE, FALSE);
X
X   /* Check if we got a null value back.	*/
X   if (question == (CDKDIALOG *)NULL)
X   {
X      destroyCDKScreen (cdkscreen);
X
X      /* End curses...				*/
X      endCDK();
X
X      /* Spit out a message.			*/
X      printf ("Oops. Can't seem to create the dialog box. Is the window too small?\n");
X      exit (1);
X   }
X
X   /* Create the key binding.			*/
X   bindCDKObject (vDIALOG, question, '?', dialogHelpCB, NULL);
X
X   /* Activate the dialog box.			*/
X   selection = 0;
X   while (selection != 3)
X   {
X      /* Get the users button selection.	*/
X      selection = activateCDKDialog (question, (chtype *)NULL);
X
X      /* Check the results.			*/
X      if (selection == 0)
X      {
X         /* Get the users login name.		*/
X         info[0] = "<C>     </U>Login Name<!U>     ";
X         loginName = getlogin();
X         if (loginName == (char *)NULL)
X         {
X            info[1] = "<C></R>Unknown";
X         }
X         else
X         {
X             sprintf (temp, "<C><%s>", loginName); info[1] = strdup (temp);
X         }
X         popUpMessage (question->screen, info, 2);
X         free (info[1]);
X      }
X      else if (selection == 1)
X      {
X         /* Print out the time.			*/
X         time(&clck);
X         currentTime = localtime(&clck);
X         sprintf (temp, "<C>%d:%d:%d", currentTime->tm_hour,
X					currentTime->tm_min,
X					currentTime->tm_sec);
X         info[0] = "<C>   </U>Current Time<!U>   ";
X         info[1] = strdup (temp);
X         popUpMessage (question->screen, info, 2);
X         free (info[1]);
X      }
X      else if (selection == 2)
X      {
X         /* Print out the date.			*/
X         time(&clck);
X         currentTime = localtime(&clck);
X         sprintf (temp, "<C>%d/%d/%d", currentTime->tm_mday,
X					currentTime->tm_mon,
X					currentTime->tm_year);
X         info[0] = "<C>   </U>Current Date<!U>   ";
X         info[1] = strdup (temp);
X         popUpMessage (question->screen, info, 2);
X         free (info[1]);
X      }
X   }
X
X   /* Clean up					*/
X   destroyCDKDialog (question);
X   destroyCDKScreen (cdkscreen);
X   endCDK();
X   delwin (cursesWin);
}
X.fi
X.ce
\f4----------------------------------------\f1
X
X.SH SEE ALSO
X.BR cdk (3),
X.BR cdk_display (3),
X.BR cdk_screen (3)
X.SH NOTES
The header file \f4<cdk.h>\f1 automatically includes the header files
\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
The \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
SHAR_EOF
  $shar_touch -am 0503190996 'man/binding.3' &&
  chmod 0444 'man/binding.3' ||
  echo 'restore of man/binding.3 failed'
  shar_count="`wc -c < 'man/binding.3'`"
  test 8383 -eq "$shar_count" ||
    echo "man/binding.3: original size 8383, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= man/display.3 ==============
if test -f 'man/display.3' && test X"$1" != X"-c"; then
  echo 'x - skipping man/display.3 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting man/display.3 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'man/display.3' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH cdk_display 3X "05 Dec 1995"
X.SH NAME
X   Cdk - \f2Curses Development Kit\f1 Display Capabilities.
X.LP
X.SH SYNOPSIS
Cdk has a number of pre-defined display types which need explaining. This
manual page will explain all of the display types and how to use them. The
following lists which display types will be outlined in this manual page.
X.It "\(bu How To Use Colors" 5
X.It "\(bu How To Use Different Character Attributes" 5
X.It "\(bu How To Justify Strings" 5
X.It "\(bu How To Use Special Drawing Characters" 5
X.SH DESCRIPTION
Cdk has special formatting commands which can be included in any string which
add highlights, justification, or even colors to a basic string. This manual
page outlines and demonstrates how they work. 
X.PP
\f2How To Use Colors\f1
X.RS 3
Cdk has the capability to display colors in almost every string type displayed
in a Cdk widget. To turn on colors, the function \f4initCDKColor\f1 has to be
called. When this function is called 64 color pairs are created. Normally the
color pairs are accessed via the COLOR_PAIR macro. You can still do this, but
creating a string with multiple colors gets terribly difficult. That is why
the color commands were created. The color setting are stored directly in the
string and when the widget is created or activated, the string is converted
to take advantage of any color commands in the string. To turn on a color pair
insert </XX> into the string; where \f4XX\f1 is a numeric value from 0 to 64.
Color pair 0 is the standard default color pair for the screen. To turn off a
color pair use the format command <!XX> where \f4XX\f1 is a numeric value from
0 to 64. The following code segment demonstrates the use of the color commands.
X.LP
X.nf
X.ce
\f4----------------------------------------\f1
#include <cdk.h>
X
void main()
{
X   CDKSCREEN	*cdkscreen;
X   CDKLABEL	*demo;
X   WINDOW 	*screen;
X   char		*mesg[4];
X
X   /* Initialize the Cdk screen.	*/
X   screen = initscr();
X   cdkscreen = initCDKScreen (screen);
X
X   /* Set the labels up.		*/
X   mesg[0] = "</1>This line should have a yellow foreground and a blue background.<!1>";
X   mesg[1] = "</2>This line should have a white  foreground and a blue background.<!2>";
X   mesg[2] = "</3>This line should have a yellow foreground and a red  background.<!3>";
X   mesg[3] = "<C>This line should be set to whatever the screen default is.";
X
X   /* Declare the labels.	*/
X   demo	= newCDKLabel (cdkscreen, CENTER, CENTER, mesg, 4, TRUE, TRUE);
X
X   /* Draw the label		*/
X   drawCDKLabel (demo, TRUE);
X   waitCDKLabel (demo, ' ');
X
X   /* Clean up			*/
X   destroyCDKLabel (demo);
X   destroyCDKScreen (cdkscreen);
X   endCDK();
X   exit (0);
}
X.fi
X.ce
\f4----------------------------------------\f1
This example uses the color pair 5 (which is white on blue) for the label to
the entry widget.
X.RE
X.PP
\f2How To Use Different Character Attributes\f1
X.RS 3
Cdk also provides attribute commands which allow different character attributes
to be displayed in a Cdk widget. To use a character attribute the format command
is </X> where \f4X\f1 is one of several command characters. To turn a attribute 
off use the command <!X>. The following table outlines the command characters
and what they mean.
X.LP
X.nf 
X.RS 3
\f2Command_Character      Character_Attribute\f1
B                      Bold 
U                      Underline
K                      Blink
R                      Reverse
S                      Standout
D                      Dim
N                      Normal
X.fi
X.RE
X
The following code segment demonstrates the use of character display attributes.
X.nf
X.ce 
\f4----------------------------------------\f1
#include <cdk.h>
X
void main()
{
X   CDKSCREEN	*cdkscreen;
X   CDKLABEL	*demo;
X   WINDOW	*screen;
X   char		*mesg[4];
X
X   /* Initialize the Cdk screen.	*/
X   screen = initscr();
X   cdkscreen = initCDKScreen (screen);
X
X   /* Set the labels up.		*/
X   mesg[0] = "</B/1>This line should have a yellow foreground and a blue background.<!1>";
X   mesg[1] = "</U/2>This line should have a white  foreground and a blue background.<!2>";
X   mesg[2] = "</K/3>This line should have a yellow foreground and a red  background.<!3>";
X   mesg[3] = "<C>This line should be set to whatever the screen default is.";
X
X   /* Declare the labels.	*/
X   demo	= newCDKLabel (cdkscreen, CENTER, CENTER, mesg, 4, TRUE, TRUE);
X
X   /* Draw the label		*/
X   drawCDKLabel (demo, TRUE);
X   waitCDKLabel (demo, ' ');
X
X   /* Clean up			*/
X   destroyCDKLabel (demo);
X   destroyCDKScreen (cdkscreen);
X   endCDK();
X   exit (0);
}
X.ce
\f4----------------------------------------\f1
X.fi
Notice that color commands and format commands can be mixed inside the same
format marker. The above example underlines the label marker, which also sets
color pair number 5.
X.RE
X.PP
\f2How To Justify Strings\f1
X.RS 3
Justification commands can left justify, right justify, or center a string of 
text. To use a justification format in a string the command <X> is used. The 
following table lists all of the format commands available.
X.LP
X.nf
X.RS 3
\f2Justification_Command    Action.\f1
<L>                      Left Justified. Default if not stated.
<C>                      Centered text.
<R>                      Right justified.
<I=X>                    Indent the line X characters.
<B=X>                    Bullet. X is the bullet string to use.
X.fi
X.RE
X.fi
X
The following code segment demonstrates how to use the justification commands
in a Cdk widget.
X.ce
\f4----------------------------------------\f1
X.nf
#include <cdk.h>
X
void main()
{
X   CDKSCREEN	*cdkscreen;
X   CDKLABEL	*demo;
X   WINDOW	*screen;
X   char		*mesg[4];
X
X   /* Initialize the Cdk screen.	*/
X   screen = initscr();
X   cdkscreen = initCDKScreen (screen);
X
X   /* Set the labels up.		*/
X   mesg[0] = "<R></B/1>This line should have a yellow foreground and a blue background.<!1>";
X   mesg[1] = "</U/2>This line should have a white  foreground and a blue background.<!2>";
X   mesg[2] = "<B=+>This is a bullet.";
X   mesg[3] = "<I=10>This is indented 10 characters.";
X   mesg[4] = "<C>This line should be set to whatever the screen default is.";
X
X   /* Declare the labels.	*/
X   demo	= newCDKLabel (cdkscreen, CENTER, CENTER, mesg, 5, TRUE, TRUE);
X
X   /* Draw the label		*/
X   drawCDKLabel (demo, TRUE);
X   waitCDKLabel (demo, ' ');
X
X   /* Clean up			*/
X   destroyCDKLabel (demo);
X   destroyCDKScreen (cdkscreen);
X   endCDK();
X   exit (0);
}
X.fi
X.ce
\f4----------------------------------------\f1
The bullet format command can take either a single character or a string.
The bullet in the the above example would look like
X.RS 3
\f4+\f1 This is a bullet.
X.RE
but if we were to use the following command instead
X.ce
<B=***>This is a bullet.
it would look like
X.RS 3
\f4***\f1 This is a bullet.
X.RE
X
The only restriction that a format command has is that it must be at the
beginning of the string.
X.RE
X.PP
\f2How To Use Special Drawing Characters\f1
X.RS 3
Cdk has a set of special drawing characters which can be inserted into any
ASCII file. In order to use a special character the format command <#XXX>
is used. The following table lists all of the special character commands
available.
X.LP
X.RS 3
X.nf 
\f2Special_Character   Character\f1
<#UL>               Upper Left Corner
<#UR>               Upper Right Corner
<#LL>               Lower Left Corner
<#LR>               Lower Right Corner
<#LT>               Left Tee
<#RT>               Right Tee
<#TT>               Top Tee
<#BT>               Bottom Tee
<#HL>               Horizontal Line
<#VL>               Vertical Line
<#PL>               Plus Sign
<#PM>               Plus/Minus Sign
<#DG>               Degree Sign
<#CB>               Checker Board
<#DI>               Diamond
<#BU>               Bullet
X.RE
X.fi
X.LP
The character formats can be repeated using an optional numeric repeat value.
To repeat a character add (XXX) to the end of the character format. The 
following example, draws 10 horizontal lines.
X.LP
<#HL(10)>
X.LP
The following code segment draws a box within a label window.
X.ce
\f4----------------------------------------\f1
X.nf
#include "cdk.h"
X
void main()
{
X   /* Declare variables.	*/
X   CDKSCREEN	*cdkscreen;
X   CDKLABEL	*demo;
X   WINDOW 	*cursesWin;
X   char		*mesg[4];
X
X   /* Set up CDK 		*/ 
X   cursesWin = initscr();
X   cdkscreen = initCDKScreen (cursesWin);
X
X   /* Start CDK Colors		*/
X   initCDKColor();
X
X   /* Set the labels up.	*/
X   mesg[0] = "<C><#UL><#HL(25)><#UR>";
X   mesg[1] = "<C><#VL></R>This text should be boxed.<!R><#VL>";
X   mesg[2] = "<C><#LL><#HL(25)><#LR>";
X   mesg[3] = "<C>While this is not.";
X
X   /* Declare the labels.	*/
X   demo	= newCDKLabel (cdkscreen, CENTER, CENTER, mesg, 4, TRUE, TRUE);
X
X   /* Is the label NULL???	*/
X   if (demo == (CDKLABEL *)NULL)
X   {
X      /* Clean up the memory.	*/
X      destroyCDKScreen (cdkscreen);
X
X      /* End curses...		*/
X      endCDK();
X
X      /* Spit out a message.	*/
X      printf ("Oops. Can't seem to create the label. Is the window too small?\n");
X      exit (1);
X   }
X
X   /* Draw the CDK screen.	*/
X   refreshCDKScreen (cdkscreen);
X   waitCDKLabel (demo, ' ');
X
X   /* Clean up			*/
X   destroyCDKLabel (demo);
X   destroyCDKScreen (cdkscreen);
X   delwin (cursesWin);
X   endCDK();
X   exit (0);
}
X.fi
X.ce
\f4----------------------------------------\f1
X.LP
Notice that drawn text can also be justified.
X.LP
X.SH SEE ALSO
X.BR cdk (3X),
X.BR cdk_binding (3X),
X.BR cdk_screen (3X)
X.SH NOTES
The header file \f4<cdk.h>\f1 automatically includes the header files
\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
The \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
SHAR_EOF
  $shar_touch -am 0503190996 'man/display.3' &&
  chmod 0444 'man/display.3' ||
  echo 'restore of man/display.3 failed'
  shar_count="`wc -c < 'man/display.3'`"
  test 9802 -eq "$shar_count" ||
    echo "man/display.3: original size 9802, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= marquee.c ==============
if test -f 'marquee.c' && test X"$1" != X"-c"; then
  echo 'x - skipping marquee.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting marquee.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'marquee.c' &&
#include "cdk.h"
X
/*
X * $Author: mikeg $
X * $Date: 1996/02/28 14:59:06 $
X * $Revision: 1.26 $
X */
X
/*
X * This creates a marquee widget.
X */
CDKMARQUEE *newCDKMarquee (CDKSCREEN *cdkscreen, int xplace, int yplace, int width, boolean shadow)
{
X   CDKMARQUEE *marquee	= (CDKMARQUEE *)malloc (sizeof (CDKMARQUEE));
X   int xpos		= xplace;
X   int ypos		= yplace;
X   int boxHeight	= 3;
X   int boxWidth		= width + 2;
X
X   /* Rejustify the x and y positions if we need to.			*/
X   alignxy (cdkscreen->window, &xpos, &ypos, boxWidth, boxHeight);
X
X   /* Create the marquee pointer.					*/
X   marquee->parent	= cdkscreen->window;
X   marquee->win		= newwin (boxHeight, boxWidth, ypos, xpos);
X   marquee->shadowWin	= (WINDOW *)NULL;
X   marquee->active	= TRUE;
X   marquee->width	= width;
X   marquee->box		= NOBOX;
X   marquee->shadow	= shadow;
X
X   /* Is the window NULL???						*/
X   if (marquee->win == (WINDOW *)NULL)
X   {
X      /* Clean up any memory.						*/
X      free (marquee);
X
X      /* Return a NULL pointer.						*/
X      return ( (CDKMARQUEE *)NULL );
X   }
X
X   /* Register this baby.						*/
X   registerCDKObject (cdkscreen, vMARQUEE, marquee);
X
X   /* Return the marquee pointer.					*/
X   return(marquee);
}
X
/* 
X * This activates the marquee.
X */
int activateCDKMarquee (CDKMARQUEE *marquee, char *mesg, int delay, int repeat, boolean box)
{
X   /* Declear local variables.						*/
X   chtype *message;
X   int mesglength 	= 0;
X   int startpos		= 0;
X   int firstchar	= 0;
X   int lastchar		= 1;
X   int repeatCount	= 0;
X   int viewsize		= 0;
#ifdef NOUSLEEP
X   int sleeper		= 0;
#endif
X   int x, y, junk;
X
X   /* Keep the box info.						*/
X   marquee->box = box;
X
X   /* Make sure the message has some content.				*/
X   if (mesg == (char *)NULL)
X   {
X      return (-1);
X   }
X   
X   /* Translate the char * to a chtype *				*/
X   message	= char2Chtype (mesg, &mesglength, &junk);
X
X   /* Draw in the marquee.						*/
X   drawCDKMarquee (marquee, box);
X
X   /* Set up the variables.						*/
X   viewsize = lastchar - firstchar;
X   startpos = marquee->width - viewsize + 1;
X
X   /* Start doing the marquee thing...					*/
X   for (;;)
X   {
X      if (marquee->active)
X      {
X         /* Draw in the characters.					*/
X         y = firstchar;
X         for (x=startpos ; x < (startpos+viewsize) ; x++)
X         {
X            mvwaddch (marquee->win, 1, x, message[y]);
X            y++;
X         }
X         wrefresh (marquee->win);
X   
X         /* Set my variables.						*/
X         if (mesglength < marquee->width-2)
X         {
X            if (lastchar < mesglength)
X            {
X               lastchar ++;
X               viewsize ++;
X               startpos = marquee->width - viewsize + 1;
X            }
X            else if (lastchar == mesglength)
X            {
X               if (startpos > 1)
X               {
X                  /* This means the whole string is visible.		*/
X                  startpos --;
X                  viewsize = mesglength;
X               }
X               else
X               {
X                 /* We have to start chopping the viewsize		*/
X                 startpos = 1;
X                 firstchar ++;
X                 viewsize --;
X               }
X            }
X         }
X         else
X         {
X            if (startpos > 1)
X            {
X               lastchar ++;
X               viewsize ++;
X               startpos --;
X            }
X            else
X            {
X               if (lastchar < mesglength)
X               {
X                  firstchar ++;
X                  lastchar  ++;
X                  viewsize = marquee->width;
X                  startpos = 1;
X               }
X               else
X               {
X                  firstchar ++;
X                  viewsize --;
X                  startpos = 1;
X               }
X            }
X         }
X
X         /* OK, lets check if we have to start over.			*/
X         if ( viewsize == 0 && firstchar == mesglength)
X         {
X            /* Check if we need to repeat or not.			*/
X            repeatCount ++;
X            if (repeat > 0 && repeatCount == repeat)
X            {
X               freeChtype (message);
X               return (0);
X            }
X
X            /* Time to start over. 					*/
X            mvwaddch (marquee->win, 1, 1, ' '|A_NORMAL);
X            wrefresh (marquee->win);
#ifndef AIX
X            curs_set(0);
#endif
X            firstchar = 0;
X            lastchar = 1;
X            viewsize = lastchar - firstchar;
X            startpos = marquee->width - viewsize + 1;
X         }
X   
X         /* Now sleep							*/
#ifdef NOUSLEEP
X         for (sleeper = 0; sleeper <= (delay * 250) ; sleeper++) {}
#else
X         usleep ( (delay * 10000) );
#endif
X      }
X      else
X      {
X         printf ("\r\n\r\n\r\n\r\nMarquee turned off\r\n");
X         }
X   }
}
X
/*
X * This draws the marquee widget on the screen.
X */
void drawCDKMarquee (CDKMARQUEE *marquee, boolean Box)
{
X   /* Keep the box information.						*/
X   marquee->box	= Box;
X
X   /* Erase the old object...						*/
X   eraseCDKMarquee (marquee);
X
X   /* Do we need to draw a shadow???					*/
X   if (marquee->shadow)
X   {
X      drawShadow (marquee->shadowWin);
X   }
X
X   /* Box it if needed.							*/
X   if (Box)
X   {
X      box (marquee->win, ACS_VLINE, ACS_HLINE);
X      wrefresh (marquee->win);
X   }
}
X
/*
X * This destroys the marquee.
X */
void destroyCDKMarquee (CDKMARQUEE *marquee)
{
X   /* Erase the object.							*/
X   eraseCDKMarquee (marquee);
X
X   /* Clean up the windows.						*/
X   delwin (marquee->win);
X   if (marquee->shadow)
X   {
X      delwin (marquee->shadowWin);
X   }
X
X   /* Unregister this object.						*/
X   unregisterCDKObject (vMARQUEE, marquee);
X   
X   /* Finish cleaning up.						*/
X   free (marquee);
}
X
/*
X * This erases the marquee.
X */
void eraseCDKMarquee (CDKMARQUEE *marquee)
{
X   werase (marquee->win);
X   wrefresh (marquee->win);
X   if (marquee->shadow)
X   {
X      werase (marquee->shadowWin);
X      wrefresh (marquee->shadowWin);
X   }
}
SHAR_EOF
  $shar_touch -am 0503190896 'marquee.c' &&
  chmod 0444 'marquee.c' ||
  echo 'restore of marquee.c failed'
  shar_count="`wc -c < 'marquee.c'`"
  test 5909 -eq "$shar_count" ||
    echo "marquee.c: original size 5909, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= matrix.c ==============
if test -f 'matrix.c' && test X"$1" != X"-c"; then
  echo 'x - skipping matrix.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting matrix.c (binary)'
  sed 's/^X//' << 'SHAR_EOF' > _sharuue.tmp &&
begin 600 matrix.c
M(VEN8VQU9&4@(F-D:RYH(@H*+RH*("H@)$%U=&AO<CH@9VQO=F5R("0*("H@
M)$1A=&4Z(#$Y.38O,#0O,38@,#$Z-#,Z-#(@)`H@*B`D4F5V:7-I;VXZ(#$N
M.#,@)`H@*B\*"B\J($1E8V%L<F4@9VQO8F%L('9A<G,N"0D)"0D)"2HO"G9O
M:60@<F5D<F%W5&ET;&5S("A#1$M-051225@@*FUA=')I>"P@:6YT(')O=RP@
M:6YT(&-O;"D["F5X=&5R;B!C:&%R("I'4&%S=&5"=69F97(["@HO*@H@*B!4
M:&ES(&9U;F-T:6]N(&-R96%T97,@=&AE(&UA=')I>"!W:61G970N"B`J+PI#
M1$M-051225@@*FYE=T-$2TUA=')I>"`H0T1+4T-2145.("IC9&MS8W)E96XL
M(&EN="!X<&QA8V4L(&EN="!Y<&QA8V4L(&EN="!R;W=S+"!I;G0@8V]L<RP@
M:6YT('9R;W=S+"!I;G0@=F-O;',L(&-H87(@*BIR;W=T:71L97,L(&-H87(@
M*BIC;VQT:71L97,L(&EN="`J8V]L=VED=&AS+"!I;G0@*F-O;'9A;'5E<RP@
M:6YT(')S<&%C92P@:6YT(&-S<&%C92P@8VAT>7!E(&9I;&QE<BP@:6YT(&1O
M;6EN86YT+"!B;V]L96%N(&)O>$UA=')I>"P@8F]O;&5A;B!B;WA#96QL+"!B
M;V]L96%N('-H861O=RD*>PH@("`O*B!$96-L87)E(&QO8V%L('9A<FEA8FQE
M<RX)"0D)"0DJ+PH@("!#1$M-051225@@*FUA=')I>`D]("A#1$M-051225@@
M*BEM86QL;V,@*'-I>F5O9BA#1$M-051225@I*3L*("`@:6YT(&)O>$AE:6=H
M=`D](#`["B`@(&EN="!B;WA7:61T:`D)/2`P.PH@("!I;G0@>'!O<PD)/2!X
M<&QA8V4["B`@(&EN="!Y<&]S"0D]('EP;&%C93L*("`@:6YT(&UA>%)O=U1I
M=&QE5VED=&@)/2`P.PH@("!I;G0@8F5G>"P@8F5G>2P@>"P@>2P@>BP@=RP@
M8V5L;'=I9'1H.PH@("!I;G0@<F]W4W!A8V4)"3T@34%8("@P+"!R<W!A8V4I
M.PH@("!I;G0@8V]L4W!A8V4)"3T@34%8("@P+"!C<W!A8V4I.PH*("`@+RH@
M36%K92!S=7)E('1H870@=&AE(&YU;6)E<B!O9B!R;W=S+V-O;',O=G)O=W,O
M=F-O;',@:7,@;F]T('IE<F\N"2HO"B`@(&EF("AR;W=S(#T](#`@?'P@8V]L
M<R`]/2`P('Q\('9R;W=S(#T](#`@?'P@=F-O;',@/3T@,"D*("`@>PH@("`@
M("`O*B!&<F5E('5P(&%N>2!U<V5D(&UE;6]R>2X)"0D)"2HO"B`@("`@(&9R
M964@*&UA=')I>"D["@H@("`@("`O*B!2971U<FX@82!.54Q,('!O:6YT97(N
M"0D)"0D)*B\*("`@("`@<F5T=7)N("@H0T1+34%44DE8("HI3E5,3"D["B`@
M('T*"B`@("\J($UA:V4@<W5R92!T:&4@;G5M8F5R(&]F('9I<G1U86P@8V5L
M;',@:7,@;F]T(&QA<F=E<B!T:&%N"0DJ+PH@("`O*B!T:&4@<&AY<VEC86P@
M<VEZ92X)"0D)"0DJ+PH@("!V<F]W<R`]("AV<F]W<R`^(')O=W,@/R!R;W=S
M(#H@=G)O=W,I.PH@("!V8V]L<R`]("AV8V]L<R`^(&-O;',@/R!C;VQS(#H@
M=F-O;',I.PH*("`@+RH@1&5T97)M:6YE('1H92!H96EG:'0@;V8@=&AE(&)O
M>"X)"0D)"2HO"B`@(&9O<B`H>#TQ.R!X(#P]('9R;W=S.R!X*RLI"B`@('L*
M("`@("`@8F]X2&5I9VAT("L](#,@*R!R;W=3<&%C93L*("`@?0H*("`@+RH@
M1&5T97)M:6YE('1H92!M87AI;75M(')O=R!T:71L92!W:61T:`D)"0DJ+PH@
M("!M87A2;W=4:71L95=I9'1H"3T@,#L*("`@9F]R("AX/3$[('@@/#T@<F]W
M<SL@>"LK*0H@("!["B`@("`@(&UA=')I>"T^<F]W=&ET;&5;>%T@/2!C:&%R
M,D-H='EP92`H<F]W=&ET;&5S6WA=+"`F;6%T<FEX+3YR;W=T:71L94QE;EMX
M72P@)FUA=')I>"T^<F]W=&ET;&50;W-;>%TI.PH@("`@("!M87A2;W=4:71L
M95=I9'1H(#T@34%8("AM87A2;W=4:71L95=I9'1H+"!M871R:7@M/G)O=W1I
M=&QE3&5N6WA=*3L*("`@?0H@("!M871R:7@M/FUA>')T(#T@;6%X4F]W5&ET
M;&57:61T:"`K(#(["B`@(&)O>%=I9'1H(#T@;6%T<FEX+3YM87AR=#L*"B`@
M("\J(%=E(&YE960@=&\@<F5J=7-T:69Y('1H92!R;W<@=&ET;&4@8V5L;"!I
M;F9O+@D)"2HO"B`@(&9O<B`H>#TQ.R!X(#P](')O=W,[('@K*RD*("`@>PH@
M("`@("!M871R:7@M/G)O=W1I=&QE4&]S6WA="3T@:G5S=&EF>5-T<FEN9R`H
M;6%T<FEX+3YM87AR="P@;6%T<FEX+3YR;W=T:71L94QE;EMX72P@;6%T<FEX
M+3YR;W=T:71L95!O<UMX72D["B`@('T*"B`@("\J($1E=&5R;6EN92!T:&4@
M=VED=&@@;V8@=&AE(&UA=')I>"X)"0D)*B\*("`@9F]R("AX/3$[('@@/#T@
M=F-O;',[('@K*RD*("`@>PH@("`@("!B;WA7:61T:"`K/2!C;VQW:61T:'-;
M>%T@*R`R("L@8V]L4W!A8V4["B`@('T*("`@8F]X5VED=&@M+3L*("`@8F]X
M2&5I9VAT*RL["@H@("`O*B!296IU<W1I9GD@=&AE('@@86YD('D@<&]S:71I
M;VYS(&EF('=E(&YE960@=&\N"0D)*B\*("`@86QI9VYX>2`H8V1K<V-R965N
M+3YW:6YD;W<L("9X<&]S+"`F>7!O<RP@8F]X5VED=&@L(&)O>$AE:6=H="D[
M"@H@("`O*B!-86ME('1H92!P;W`M=7`@=VEN9&]W+@D)"0D)"2HO"B`@(&UA
M=')I>"T^=VEN(#T@;F5W=VEN("AB;WA(96EG:'0L(&)O>%=I9'1H+"!Y<&]S
M+"!X<&]S*3L*"B`@("\J($-H96-K(&EF('1H92!N97<@=VEN9&]W(&ES($Y5
M3$P@;W(@;F]T+@D)"0DJ+PH@("!I9B`H;6%T<FEX+3YW:6X@/3T@*%=)3D1/
M5R`J*4Y53$PI"B`@('L*("`@("`@+RH@1G)E92!U<"!A;GD@=7-E9"!M96UO
M<GDN"0D)"0DJ+PH@("`@("!F;W(@*'H],3L@>B`\/2!R;W=S.R!Z*RLI"B`@
M("`@('L*("`@("`@("`@9G)E94-H='EP92`H;6%T<FEX+3YR;W=T:71L95MZ
M72D["B`@("`@('T*("`@("`@9G)E92`H;6%T<FEX*3L*"B`@("`@("\J(%)E
M='5R;B!A($Y53$P@<&]I;G1E<BX)"0D)"0DJ+PH@("`@("!R971U<FX@*"A#
M1$M-051225@@*BE.54Q,*3L*("`@?0H*("`@+RH@36%K92!T:&4@<W5B=VEN
M9&]W<R!I;B!T:&4@<&]P+75P+@D)"0DJ+PH@("!B96=X(#T@>'!O<SL*("`@
M8F5G>2`]('EP;W,@*R`Q.PH*("`@+RH@36%K92!T:&4@)V5M<'1Y)R`P>#`@
M8V5L;"X)"0D)"2HO"B`@(&UA=')I>"T^8V5L;%LP75LP72`]('-U8G=I;B`H
M;6%T<FEX+3YW:6XL(#,L(&UA=')I>"T^;6%X<G0L(&)E9WDL(&)E9W@I.PH@
M("!B96=X("L](&UA=')I>"T^;6%X<G0@*R`Q.PH*("`@+RH@36%K92!T:&4@
M8V]L=6UN('1I=&QE<RX)"0D)"0DJ+PH@("!F;W(@*'@],3L@>"`\/2!V8V]L
M<SL@>"LK*0H@("!["B`@("`@(&-E;&QW:61T:"`](&-O;'=I9'1H<UMX72`K
M(#(["B`@("`@(&UA=')I>"T^8V5L;%LP75MX72`]('-U8G=I;B`H;6%T<FEX
M+3YW:6XL(#$L(&-E;&QW:61T:"P@8F5G>2P@8F5G>"D["@H@("`@("`O*B!)
M<R!T:&4@<W5B=VEN9&]W($Y53$P)"0D)"0DJ+PH@("`@("!I9B`H;6%T<FEX
M+3YC96QL6S!=6WA=(#T]("A724Y$3U<@*BE.54Q,*0H@("`@("!["B`@("`@
M("`@("\J($9R964@=7`@86YY('5S960@;65M;W)Y+@D)"0D)*B\*("`@("`@
M("`@9F]R("AZ/3$[('H@/#T@<F]W<SL@>BLK*0H@("`@("`@("!["B`@("`@
M("`@("`@(&9R965#:'1Y<&4@*&UA=')I>"T^<F]W=&ET;&5;>ETI.PH@("`@
M("`@("!]"@H@("`@("`@("`O*B!792!H879E('1O(&1E;&5T92!A;GD@=VEN
M9&]W<R!C<F5A=&5D('-O(&9A<BX)"2HO"B`@("`@("`@(&9O<B`H>CTQ.R!Z
M(#P@>#L@>BLK*0H@("`@("`@("!["B`@("`@("`@("`@(&1E;'=I;B`H;6%T
M<FEX+3YC96QL6S!=6WI=*3L*("`@("`@("`@?0H@("`@("`@("!F<F5E("AM
M871R:7@I.PH*("`@("`@("`@+RH@4F5T=7)N(&$@3E5,3"!P;VEN=&5R+@D)
M"0D)*B\*("`@("`@("`@<F5T=7)N("@H0T1+34%44DE8("HI3E5,3"D["B`@
M("`@('T*("`@("`@8F5G>"`K/2`@8V5L;'=I9'1H("L@8V]L4W!A8V4@+2`Q
M.PH@("!]"B`@(&)E9WD@*RL["@H@("`O*B!-86ME('1H92!M86EN(&-E;&P@
M8F]D>0D)"0D)"2HO"B`@(&9O<B`H>#TQ.R!X(#P]('9R;W=S.R!X*RLI"B`@
M('L*("`@("`@+RH@36%K92!T:&4@<F]W('1I=&QE<PD)"0D)"2HO"B`@("`@
M(&UA=')I>"T^8V5L;%MX75LP72`]('-U8G=I;B`H;6%T<FEX+3YW:6XL(#,L
M(&UA=')I>"T^;6%X<G0L(&)E9WDL('AP;W,K,2D["@H@("`@("`O*B!)<R!T
M:&4@=VEN9&]W($Y53$P)"0D)"0DJ+PH@("`@("!I9B`H;6%T<FEX+3YC96QL
M6WA=6S!=(#T]("A724Y$3U<@*BE.54Q,*0H@("`@("!["B`@("`@("`@("\J
M($9R964@=7`@86YY('5S960@;65M;W)Y+@D)"0D)*B\*("`@("`@("`@9F]R
M("AZ/3$[('H@/#T@<F]W<SL@>BLK*0H@("`@("`@("!["B`@("`@("`@("`@
M(&9R965#:'1Y<&4@*&UA=')I>"T^<F]W=&ET;&5;>ETI.PH@("`@("`@("!]
M"@H@("`@("`@("`O*B!792!H879E('1O(&1E;&5T92!A;GD@=VEN9&]W<R!C
M<F5A=&5D('-O(&9A<BX)"2HO"B`@("`@("`@(&9O<B`H>CTQ.R!Z(#P]('9C
M;VQS.R!Z*RLI"B`@("`@("`@('L*("`@("`@("`@("`@9&5L=VEN("AM871R
M:7@M/F-E;&Q;,%U;>ETI.PH@("`@("`@("!]"B`@("`@("`@(&9O<B`H>CTQ
M.R!Z(#P@>"`[('HK*RD*("`@("`@("`@>PH@("`@("`@("`@("!D96QW:6X@
M*&UA=')I>"T^8V5L;%MZ75LP72D["B`@("`@("`@('T*("`@("`@("`@9G)E
M92`H;6%T<FEX*3L*"B`@("`@("`@("\J(%)E='5R;B!A($Y53$P@<&]I;G1E
M<BX)"0D)"2HO"B`@("`@("`@(')E='5R;B`H*$-$2TU!5%))6"`J*4Y53$PI
M.PH@("`@("!]"@H@("`@("`O*B!3970@=&AE('-T87)T(&]F('1H92!X('!O
M<VET:6]N+@D)"0DJ+PH@("`@("!B96=X(#T@>'!O<R`K(&UA=')I>"T^;6%X
M<G0@*R`Q.PH*("`@("`@+RH@36%K92!T:&4@8V5L;',)"0D)"0D)*B\*("`@
M("`@9F]R("AY/3$[('D@/#T@=F-O;',[('DK*RD*("`@("`@>PH@("`@("`@
M("!C96QL=VED=&@@/2!C;VQW:61T:'-;>5T@*R`R.PH@("`@("`@("!M871R
M:7@M/F-E;&Q;>%U;>5T@/2!S=6)W:6X@*&UA=')I>"T^=VEN+"`S+"!C96QL
M=VED=&@L(&)E9WDL(&)E9W@I.PH*("`@("`@("`@+RH@27,@=&AE(&-E;&P@
M3E5,3#\_/PD)"0D)"2HO"B`@("`@("`@(&EF("AM871R:7@M/F-E;&Q;>%U;
M>5T@/3T@*%=)3D1/5R`J*4Y53$PI"B`@("`@("`@('L*("`@("`@("`@("`@
M+RH@1G)E92!U<"!A;GD@=7-E9"!M96UO<GDN"0D)"0DJ+PH@("`@("`@("`@
M("!F;W(@*'D],3L@>2`\/2!R;W=S.R!Y*RLI"B`@("`@("`@("`@('L*("`@
M("`@("`@("`@("`@9G)E94-H='EP92`H;6%T<FEX+3YR;W=T:71L95MY72D[
M"B`@("`@("`@("`@('T*"B`@("`@("`@("`@("\J(%=E(&AA=F4@=&\@9&5L
M971E(&%N>2!W:6YD;W=S(&-R96%T960@<V\@9F%R+@D)*B\*("`@("`@("`@
M("`@9F]R("AY/3$[('D@/#T@=F-O;',[('DK*RD*("`@("`@("`@("`@>PH@
M("`@("`@("`@("`@("!D96QW:6X@*&UA=')I>"T^8V5L;%LP75MY72D["B`@
M("`@("`@("`@('T*("`@("`@("`@("`@9F]R("AY/3$[('D@/"!V<F]W<R`[
M('DK*RD*("`@("`@("`@("`@>PH@("`@("`@("`@("`@("!D96QW:6X@*&UA
M=')I>"T^8V5L;%MY75LP72D["B`@("`@("`@("`@('T*("`@("`@("`@("`@
M9F]R("AW/3$[('<@/#T@=G)O=W,[('<K*RD*("`@("`@("`@("`@>PH@("`@
M("`@("`@("`@("!F;W(@*'H],3L@>B`\/2!Y.R!Z*RLI"B`@("`@("`@("`@
M("`@('L*("`@("`@("`@("`@("`@("`@9&5L=VEN("AM871R:7@M/F-E;&Q;
M=UU;>ETI.PH@("`@("`@("`@("`@("!]"B`@("`@("`@("`@('T*("`@("`@
M("`@("`@9G)E92`H;6%T<FEX*3L*"B`@("`@("`@("`@("\J(%)E='5R;B!A
M($Y53$P@<&]I;G1E<BX)"0D)"2HO"B`@("`@("`@("`@(')E='5R;B`H*$-$
M2TU!5%))6"`J*4Y53$PI.PH@("`@("`@("!]"B`@("`@("`@(&)E9W@@*ST@
M8V5L;'=I9'1H("L@8V]L4W!A8V4@+2`Q.PH@("`@("`@("!K97EP860@*&UA
M=')I>"T^8V5L;%MX75MY72P@5%)512D["B`@("`@('T*("`@("`@8F5G>2`K
M/2!R;W=3<&%C92`K(#(["B`@('T*"B`@("\J($-O<'D@=&AE('1I=&QE<R!I
M;G1O('1H92!S='5R8W1U<F4N"0D)"2HO"B`@(&9O<B`H>#TQ.R!X(#P](&-O
M;',[('@K*RD*("`@>PH@("`@("!M871R:7@M/F-O;'1I=&QE6WA="3T@8VAA
M<C)#:'1Y<&4@*&-O;'1I=&QE<UMX72P@)FUA=')I>"T^8V]L=&ET;&5,96Y;
M>%TL("9M871R:7@M/F-O;'1I=&QE4&]S6WA=*3L*("`@("`@;6%T<FEX+3YC
M;VQT:71L95!O<UMX70D](&IU<W1I9GE3=')I;F<@*&-O;'=I9'1H<UMX72P@
M;6%T<FEX+3YC;VQT:71L94QE;EMX72P@;6%T<FEX+3YC;VQT:71L95!O<UMX
M72D["B`@("`@(&UA=')I>"T^8V]L=VED=&AS6WA="3T@8V]L=VED=&AS6WA=
M.PH@("!]"@H@("`O*B!-86ME(')O;VT@9F]R('1H92!C96QL(&EN9F]R;6%T
M:6]N+@D)"0DJ+PH@("!F;W(@*'@],3L@>"`\/2!R;W=S.R!X*RLI"B`@('L*
M("`@("`@9F]R("AY/3$[('D@/#T@8V]L<SL@>2LK*0H@("`@("!["B-I9F1E
M9B!.3T193D%,3$]#"B`@("`@("`@(&UA=')I>"T^:6YF;UMX75MY70D]("AC
M:&%R("HI;6%L;&]C("AS:7IE;V8@*&-H87(I("H@,C4V*3L*(V5L<V4*("`@
M("`@("`@;6%T<FEX+3YI;F9O6WA=6WE="3T@*&-H87(@*BEM86QL;V,@*'-I
M>F5O9B`H8VAA<BD@*B`H8V]L=VED=&AS6WE=*S$I*3L*(V5N9&EF"B`@("`@
M("`@(&UA=')I>"T^8V]L=F%L=65S6WE="3T@8V]L=F%L=65S6WE=.PH@("`@
M("`@("!M871R:7@M/F-O;'=I9'1H<UMY70D](&-O;'=I9'1H<UMY73L*("`@
M("`@("`@8VQE86Y#:&%R("AM871R:7@M/FEN9F];>%U;>5TL(&-O;'=I9'1H
M<UMY72LQ+"`G7#`G*3L*("`@("`@?0H@("!]"@H@("`O*B!+965P('1H92!R
M97-T(&]F('1H92!I;F9O+@D)"0D)*B\*("`@;6%T<FEX+3YP87)E;G0)"3T@
M8V1K<V-R965N+3YW:6YD;W<["B`@(&UA=')I>"T^<F]W<PD)"3T@<F]W<SL*
M("`@;6%T<FEX+3YC;VQS"0D)/2!C;VQS.PH@("!M871R:7@M/G9R;W=S"0D]
M('9R;W=S.PH@("!M871R:7@M/G9C;VQS"0D]('9C;VQS.PH@("!M871R:7@M
M/G)O=U-P86-E"0D](')O=U-P86-E.PH@("!M871R:7@M/F-O;%-P86-E"0D]
M(&-O;%-P86-E.PH@("!M871R:7@M/F9I;&QE<@D)/2!F:6QL97(["B`@(&UA
M=')I>"T^9&]M:6YA;G0)"3T@9&]M:6YA;G0["B`@(&UA=')I>"T^<F]W"0D)
M/2`Q.PH@("!M871R:7@M/F-O;`D)"3T@,3L*("`@;6%T<FEX+3YC<F]W"0D)
M/2`Q.PH@("!M871R:7@M/F-C;VP)"0D](#$["B`@(&UA=')I>"T^=')O=PD)
M"3T@,3L*("`@;6%T<FEX+3YL8V]L"0D)/2`Q.PH@("!M871R:7@M/F]L9&-R
M;W<)"3T@,3L*("`@;6%T<FEX+3YO;&1C8V]L"0D](#$["B`@(&UA=')I>"T^
M;VQD=G)O=PD)/2`Q.PH@("!M871R:7@M/F]L9'9C;VP)"3T@,3L*("`@;6%T
M<FEX+3YB;WA-871R:7@)"3T@8F]X36%T<FEX.PH@("!M871R:7@M/F)O>$-E
M;&P)"3T@8F]X0V5L;#L*("`@;6%T<FEX+3YS:&%D;W<)"3T@<VAA9&]W.PH@
M("!M871R:7@M/FAI9VAL:6=H=`D)/2!!7U)%5D524T4["B`@(&UA=')I>"T^
M8V%L;&)A8VMF;@D)/2`H=F]I9"`J*29#1$M-871R:7A#86QL0F%C:SL*("`@
M;6%T<FEX+3YP<F50<F]C97-S1G5N8W1I;VX)/2`H4%)/0T534T9.*4Y53$P[
M"B`@(&UA=')I>"T^<')E4')O8V5S<T1A=&$)/2`H=F]I9"`J*4Y53$P["B`@
M(&UA=')I>"T^<&]S=%!R;V-E<W-&=6YC=&EO;@D]("A04D]#15-31DXI3E5,
M3#L*("`@;6%T<FEX+3YP;W-T4')O8V5S<T1A=&$)/2`H=F]I9"`J*4Y53$P[
M"@H@("`O*B!$;R!W92!W86YT(&$@<VAA9&]W/S\_"0D)"0D)*B\*("`@:68@
M*'-H861O=RD*("`@>PH@("`@("!M871R:7@M/G-H861O=U=I;B`](&YE=W=I
M;B`H8F]X2&5I9VAT+"!B;WA7:61T:"P@>7!O<RLQ+"!X<&]S*S$I.PH@("!]
M"@H@("`O*B!#;&5A;B!T:&4@:V5Y(&)I;F1I;F=S+@D)"0D)"2HO"B`@(&-L
M96%N0T1+3V)J96-T0FEN9&EN9W,@*'9-051225@L(&UA=')I>"D["@H@("`O
M*B!296=I<W1E<B!T:&ES(&)A8GDN"0D)"0D)*B\*("`@<F5G:7-T97)#1$M/
M8FIE8W0@*&-D:W-C<F5E;BP@=DU!5%))6"P@;6%T<FEX*3L*"B`@("\J(%)E
M='5R;B!T:&4@;6%T<FEX('!O:6YT97()"0D)"0DJ+PH@("!R971U<FX@*&UA
M=')I>"D["GT*"B\J(`H@*B!4:&ES(&%C=&EV871E<R!T:&4@;6%T<FEX+@H@
M*B\*:6YT(&%C=&EV871E0T1+36%T<FEX("A#1$M-051225@@*FUA=')I>"P@
M8VAT>7!E("IA8W1I;VYS*0I["B`@("\J($1E8VQA<F4@;&]C86P@=F%R:6%B
M;&5S+@D)"0D)"2HO"B`@(&EN="!R970["@H@("`O*B!$<F%W('1H92!M871R
M:7@)"0D)"0D)*B\*("`@9')A=T-$2TUA=')I>"`H;6%T<FEX+"!M871R:7@M
M/F)O>$UA=')I>"D["B`@(`H@("`O*B!#:&5C:R!I9B!A8W1I;VYS(&ES($Y5
M3$PN"0D)"0D)*B\*("`@:68@*&%C=&EO;G,@/3T@*&-H='EP92`J*4Y53$PI
M"B`@('L*("`@("`@8VAT>7!E(&EN<'5T(#T@*&-H='EP92E.54Q,.PH@("`@
M("!F;W(@*#L[*0H@("`@("!["B`@("`@("`@("\J($=E="!T:&4@:6YP=70N
M"0D)"0D)*B\*("`@("`@("`@:6YP=70@/2!W9V5T8V@@*&UA=')I>"T^8V5L
M;%MM871R:7@M/F-R;W==6VUA=')I>"T^8V-O;%TI.PH*("`@("`@("`@+RH@
M26YJ96-T('1H92!C:&%R86-T97(@:6YT;R!T:&4@=VED9V5T+@D)"2HO"B`@
M("`@("`@(')E="`](&EN:F5C=$-$2TUA=')I>"`H;6%T<FEX+"!I;G!U="D[
M"B`@("`@("`@(&EF("AR970@(3T@+3(I"B`@("`@("`@('L*("`@("`@("`@
M("`@<F5T=7)N(')E=#L*("`@("`@("`@?0H@("`@("!]"B`@('T*("`@96QS
M90H@("!["B`@("`@(&EN="!L96YG=&@@/2!C:&QE;B`H86-T:6]N<RD["B`@
M("`@(&EN="!X(#T@,#L*"B`@("`@("\J($EN:F5C="!E86-H(&-H87)A8W1E
M<B!O;F4@870@82!T:6UE+@D)"0DJ+PH@("`@("!F;W(@*'@],#L@>"`\(&QE
M;F=T:#L@>"LK*0H@("`@("!["B`@("`@("`@(')E="`](&EN:F5C=$-$2TUA
M=')I>"`H;6%T<FEX+"!A8W1I;VYS6WA=*3L*("`@("`@("`@:68@*')E="`A
M/2`M,BD*("`@("`@("`@>PH@("`@("`@("`@("!R971U<FX@<F5T.PH@("`@
M("`@("!]"B`@("`@('T*("`@?0H@("!R971U<FX@,#L*?0H*+RH*("H@5&AI
M<R!I;FIE8W1S(&$@<VEN9VQE(&-H87)A8W1E<B!I;G1O('1H92!M871R:7@@
M=VED9V5T+@H@*B\*:6YT(&EN:F5C=$-$2TUA=')I>"`H0T1+34%44DE8("IM
M871R:7@L(&-H='EP92!I;G!U="D*>PH@("`O*B!$96-L87)E(&QO8V%L('9A
M<FEA8FQE<RX)"0D)"0DJ+PH@("!I;G0@<F5F<F5S:$-E;&QS"3T@1D%,4T4[
M"B`@(&EN="!M;W9E9$-E;&P)/2!&04Q313L*("`@:6YT(&-H87)C;W5N=`D]
M('-T<FQE;B`H;6%T<FEX+3YI;F9O6VUA=')I>"T^<F]W75MM871R:7@M/F-O
M;%TI.PH@("!I;G0@<'!2971U<FX)"3T@,3L*("`@:6YT('@L('DL(&EN9F]L
M96X["@H@("`O*B!0=70@=&AE(&9O8W5S(&]N('1H92!C=7)R96YT(&-E;&P)
M"0D)"2HO"B`@(&EF("AM871R:7@M/F)O>$-E;&PI"B`@('L*("`@("`@871T
M<F)O>"`H;6%T<FEX+3YC96QL6VUA=')I>"T^8W)O=UU;;6%T<FEX+3YC8V]L
M72P*"0E!0U-?54Q#3U).15(L"4%#4U]54D-/4DY%4BP*"0E!0U-?3$Q#3U).
M15(L"4%#4U],4D-/4DY%4BP*"0E!0U-?2$Q)3D4L"4%#4U]63$E.12P*"0E!
M7T)/3$0I.PH@("!]"B`@(&AI9VAL:6=H=$-$2TUA=')I>$-E;&P@*&UA=')I
M>"D["B`@(&EF("AM871R:7@M/F-O;'=I9'1H<UMM871R:7@M/F-C;VQ=(#T]
M(#$I"B`@('L*("`@("`@=VUO=F4@*&UA=')I>"T^8V5L;%MM871R:7@M/F-R
M;W==6VUA=')I>"T^8V-O;%TL(#$L(#$I.PH@("!]"B`@(&5L<V4*("`@>PH@
M("`@("!W;6]V92`H;6%T<FEX+3YC96QL6VUA=')I>"T^8W)O=UU;;6%T<FEX
M+3YC8V]L72P@,2P@"@D)<W1R;&5N("AM871R:7@M/FEN9F];;6%T<FEX+3YR
M;W==6VUA=')I>"T^8V]L72DK,2D["B`@('T*("`@=W)E9G)E<V@@*&UA=')I
SHAR_EOF
  : || echo 'restore of matrix.c failed'
fi
echo 'End of archive part 7'
echo 'File matrix.c is continued in part 8'
echo 8 > _sharseq.tmp
exit 0
