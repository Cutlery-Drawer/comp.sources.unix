Newsgroups: comp.sources.unix
From: glover@credit.erin.utoronto.ca (Mike Glover)
Subject: v29i106: cdk-4.7.0 - Curses Development Kit, V4.7.0, Part02/10
References: <1.833427459.28242@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: glover@credit.erin.utoronto.ca (Mike Glover)
Posting-Number: Volume 29, Issue 106
Archive-Name: cdk-4.7.0/part02

#!/bin/sh
# This is `cdk_part.02' (part 2 of a multipart archive).
# Do not concatenate these parts, unpack them in order with `/bin/sh'.
# File `cdk.h' is being continued...
#
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  echo 'WARNING: not restoring timestamps.  Consider getting and'
  echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if test ! -r _sharseq.tmp; then
  echo 'Please unpack part 1 first!'
  exit 1
fi
shar_sequence=`cat _sharseq.tmp`
if test "$shar_sequence" != 2; then
  echo "Please unpack part $shar_sequence next!"
  exit 1
fi
if test ! -f _sharnew.tmp; then
  echo 'x - still skipping cdk.h'
else
  echo 'x - continuing file cdk.h'
  sed 's/^X//' << 'SHAR_EOF' >> 'cdk.h' &&
X
/*
X * =========================================================
X * 	Delcare Global Generic Prototypes
X * =========================================================
X */
void Beep();
void alignxy   (WINDOW *window,
X		int *xpos, int *ypos,
X		int boxWidth, int boxHeight);
void alignlabel (char *label, int lplace,
X			int fieldWidth, int *boxWidth, int *boxHeight,
X			int *labelxoffset, int *labelyoffset,
X			int *fieldxoffset, int *fieldyoffset);
void drawScrollItem  (WINDOW *win,
X			char *item,
X			int woffset, int voffset, int hoffset,
X			int width, chtype attr);
char *substring (char *string, int start, int width);
int justifyMessage (int fieldWidth, char *mesg, int justify);
int justifyString (int fieldWidth, int mesglen, int justify);
void popupMessage (CDKSCREEN *win, char **mesg, int count);
int popupQuestion (CDKSCREEN *screen, char **mesg, int mesgCount,
X			char **buttons, int buttonCount);
void quickSort (char *list[], int left, int right);
void swapIndex (char *list[], int i, int j);
int readFile (char *filename, char **info, int maxlines);
void stripWhiteSpace (EStripType stripType, char *string);
int splitString (char *string, char *items[], char splitChar);
X
/*
X * =========================================================
X * 	Delcare Debugging Routines.
X * =========================================================
X */
FILE *startCDKDebug(char *filename);
void writeCDKDebugMessage (FILE *fd, char *filename, char *function, int line, char *message);
void stopCDKDebug (FILE *fd);
X
/*
X * =========================================================
X * 	Delcare String Handling Routines.
X * =========================================================
X */
void freeChar (char *string);
void freeChtype (chtype *string);
void cleanChar (char *string, int length, char character);
void cleanChtype (chtype *string, int length, chtype character);
char *chtype2Char (chtype *string);
chtype *char2Chtype (char *string, int *length, int *align);
chtype *copyChtype (chtype *string);
char *copyChar (char *string);
int chlen (chtype *string);
int mode2Char (char *string, mode_t fileMode);
X
/*
X * =========================================================
X * 	These functions are 'private' functions which
X * 	take care of screen objects and refreshing.
X * =========================================================
X */
CDKSCREEN *initCDKScreen (WINDOW *window);
void initCDKColor();
void registerCDKObject (CDKSCREEN *screen, EObjectType cdktype, void *object);
void unregisterCDKObject (EObjectType cdktype, void *object);
void raiseCDKObject (EObjectType cdktype, void *object);
void lowerCDKObject (EObjectType cdktype, void *object);
void refreshCDKScreen (CDKSCREEN *screen);
void eraseCDKScreen (CDKSCREEN *screen);
void destroyCDKScreen (CDKSCREEN *screen);
void debugCDKScreen (CDKSCREEN *screen, char *mesg);
void endCDK();
X
/*
X * =========================================================
X * 	These functions are 'private' functions which
X * 	take care of object key bindings.
X * =========================================================
X */
void bindCDKObject (EObjectType cdktype,
X			void *object, chtype key, BINDFN function, void *data);
void unbindCDKObject (EObjectType cdktype, void *object, chtype key);
int checkCDKObjectBind (EObjectType cdktype, void *object, chtype key);
void cleanCDKObjectBindings (EObjectType cdktype, void *object);
int mapChtype (chtype key);
X
/*
X * =========================================================
X * 	Declare Drawing routines.
X * =========================================================
X */
void boxWindow (WINDOW *window, chtype attr);
void drawLine (WINDOW *window,
X		int startx, int starty, int endx, int endy, chtype line);
void writeChar (WINDOW *window,
X		int xpos, int ypos, char *string,
X		int align, int start, int len);
void writeCharAttrib (WINDOW *window,
X		int xpos, int ypos, char *string,
X		chtype attr, int align, int start, int len);
void writeChtype (WINDOW *window,
X			int xpos, int ypos, chtype *string,
X			int align, int start, int len);
void writeChtypeAttrib (WINDOW *window,
X			int xpos, int ypos, chtype *string,
X			chtype attr, int align, int start, int len);
void attrbox (WINDOW *window,
X		chtype tlc, chtype trc,
X		chtype blc, chtype brc,
X		chtype hor, chtype vert,
X		chtype type);
void drawShadow (WINDOW *window);
X
/* REMOVE ME LATER	*/
void printattr         (WINDOW *window, int xpos, int ypos, int align, chtype attr, char *mesg);
X
/*
X * =========================================================
X * 	Declare Label Field Prototypes and Defines
X * =========================================================
X */
#define	MAXLABELROWS	300
struct _label_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowWin;
X   chtype	*info[MAXLABELROWS];
X   int		infoLen[MAXLABELROWS];
X   int		infoPos[MAXLABELROWS];
X   int		width;
X   int		xpos;
X   int		ypos;
X   int		rows;
X   boolean	box;
X   boolean	shadow;
X   CDKSCREEN	*screen;
X   int		screenIndex;
};
typedef struct _label_st CDKLABEL;
CDKLABEL *newCDKLabel (CDKSCREEN *screen, int xPos, int yPos,
X			char **mesg, int rows,
X			boolean box, boolean shadow);
void drawCDKLabel (CDKLABEL *label, boolean box);
void eraseCDKLabel (CDKLABEL *label);
void destroyCDKLabel (CDKLABEL *label);
char waitCDKLabel (CDKLABEL *label, char key);
X
/*
X * ===============================================================
X *	Declare Single-Line Entry Field Prototypes and Defines
X * ===============================================================
X */
struct _entry_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowWin;
X   WINDOW	*labelWin;
X   chtype	*label;
X   int		labelPos;
X   int		labelLen;
X   WINDOW	*field;
X   chtype	fieldAttr;
X   int		fieldWidth;
X   char		*info;
X   int		infoWidth;
X   int		screenCol;
X   int		leftChar;
X   int		min;
X   int		max;
X   EDisplayType	dispType;
X   boolean	box;
X   boolean	shadow;
X   chtype	filler;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X   void	*	callbackfn;
X   PROCESSFN	preProcessFunction;
X   void *	preProcessData;
X   PROCESSFN	postProcessFunction;
X   void *	postProcessData;
};
typedef struct _entry_st CDKENTRY;
typedef void (*ENTRYCB) (CDKENTRY *entry, chtype character);
CDKENTRY *newCDKEntry (CDKSCREEN *cdkscreen,
X			int xpos, int ypos, int lpos,
X			char *label, 
X			chtype fieldAttrib, chtype filler,
X			EDisplayType disptype,
X			int fieldWidth, int min, int max,
X			boolean box, boolean shadow);
char *activateCDKEntry (CDKENTRY *entry, chtype *actions);
char *injectCDKEntry (CDKENTRY *entry, chtype input);
void setCDKEntry (CDKENTRY *entry, char *value, int min, int max, boolean box);
void drawCDKEntry (CDKENTRY *entry, boolean box);
void eraseCDKEntry (CDKENTRY *entry);
void cleanCDKEntry (CDKENTRY *entry);
void destroyCDKEntry (CDKENTRY *entry);
void CDKEntryCallBack (CDKENTRY *entry, chtype character);
void drawCDKEntryField (CDKENTRY *entry);
void setCDKEntryCB (CDKENTRY *entry, ENTRYCB callback);
void setCDKEntryPreProcess (CDKENTRY *entry, PROCESSFN callback, void *data);
void setCDKEntryPostProcess (CDKENTRY *entry, PROCESSFN callback, void *data);
X
/*
X * =============================================================
X *	Declare Muli-Line Entry Field Prototypes and Defines
X * =============================================================
X */
struct _mentry_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowWin;
X   WINDOW	*labelWin;
X   WINDOW	*field;
X   chtype	*label;
X   int		labelLen;
X   int		labelPos;
X   chtype	fieldAttr;
X   int		fieldWidth;
X   char		*info;
X   int		totalWidth;
X   int		rows;
X   int		currentRow;
X   int		currentCol;
X   int		topRow;
X   EDisplayType	dispType;
X   int 		min;
X   int 		logicalRows;
X   boolean	box;
X   boolean	shadow;
X   chtype	filler;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X   void	*	callbackfn;
X   PROCESSFN	preProcessFunction;
X   void *	preProcessData;
X   PROCESSFN	postProcessFunction;
X   void *	postProcessData;
};
typedef struct _mentry_st CDKMENTRY;
typedef	void (*MENTRYCB) (CDKMENTRY *mentry, chtype character);
CDKMENTRY *newCDKMentry (CDKSCREEN *cdkscreen,
X				int xpos, int ypos, int lpos,
X				char *label,
X				chtype fieldAttr, chtype filler,
X				EDisplayType disptype,
X				int fieldWidth, int fieldrows,
X				int logicalRows, int min,
X				boolean box, boolean shadow);
char *activateCDKMentry (CDKMENTRY *mentry, chtype *input);
char *injectCDKMentry (CDKMENTRY *mentry, chtype input);
void setCDKMentry (CDKMENTRY *mentry, char *value, int min, boolean box);
void drawCDKMentry (CDKMENTRY *mentry, boolean box);
void eraseCDKMentry (CDKMENTRY *mentry);
void cleanCDKMentry (CDKMENTRY *mentry);
void destroyCDKMentry (CDKMENTRY *mentry);
void drawCDKMentryField (CDKMENTRY *mentry);
void CDKMentryCallBack (CDKMENTRY *mentry, chtype character);
void setCDKMentryCB (CDKMENTRY *mentry, MENTRYCB callback);
void setCDKMentryPreProcess (CDKMENTRY *mentry, PROCESSFN callback, void *data);
void setCDKMentryPostProcess (CDKMENTRY *mentry, PROCESSFN callback, void *data);
X
/*
X * =========================================================
X * 	Declare Scrolling List Prototypes and Defines
X * =========================================================
X */
#define MAXITEMS	2000
#define MAXVIEWSIZE	25
struct _scroll_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowWin;
X   chtype	*title;
X   int		titlePos;
X   int		titleLen;
X   int		titleAdj;
X   chtype	*item[MAXITEMS];
X   int		itemPos[MAXITEMS];
X   int		itemLen[MAXITEMS];
X   int		maxTopItem;
X   int		maxLeftChar;
X   int		leftChar;
X   int		lastItem;
X   int		currentTop;
X   int		currentItem;
X   int		currentHigh;
X   int		listSize;
X   int		boxWidth;
X   int		boxHeight;
X   int		viewSize;
X   boolean	box;
X   boolean	shadow;
X   boolean	numbers;
X   chtype	titlehighlight;
X   chtype	highlight;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X   PROCESSFN	preProcessFunction;
X   void *	preProcessData;
X   PROCESSFN	postProcessFunction;
X   void *	postProcessData;
};
#define	NUMBERS		TRUE
#define	NONUMBERS	FALSE
typedef struct _scroll_st CDKSCROLL;
CDKSCROLL *newCDKScroll(CDKSCREEN *cdkscreen,
X				int xpos, int ypos, int height, int width,
X				char *title,
X				char **scrollItems, int items, boolean numbers,
X				chtype highlight, boolean box, boolean shadow);
int activateCDKScroll (CDKSCROLL *scroll, chtype *actions);
int injectCDKScroll (CDKSCROLL *scroll, chtype input);
void setCDKScroll (CDKSCROLL *scroll, char **scrollItems, int listSize,
X			boolean numbers, chtype highlight, boolean box);
void addCDKScrollItem (CDKSCROLL *scroll, char *item);
void deleteCDKScrollItem (CDKSCROLL *scroll, int position);
void drawCDKScroll (CDKSCROLL *scroll, boolean box);
void drawCDKScrollList (CDKSCROLL *scroll, boolean box);
void eraseCDKScroll (CDKSCROLL *scroll);
void destroyCDKScroll (CDKSCROLL *scroll);
void createCDKScrollItemList (CDKSCROLL *scroll, boolean numbers,
X				char **list, int listSize);
void setCDKScrollPreProcess (CDKSCROLL *scroll, PROCESSFN callback, void *data);
void setCDKScrollPostProcess (CDKSCROLL *scroll, PROCESSFN callback, void *data);
X
/*
X * =========================================================
X * 	Declare Dialog Box Prototypes and Defines
X * =========================================================
X */
#define	MAXDIALOGROWS		50
#define	MAXDIALOGBUTTONS	25
#define	MINDIALOGWIDTH		10
struct _dialogBox_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowWin;
X   chtype	*info[MAXDIALOGROWS];
X   int		infoLen[MAXDIALOGROWS];
X   int		infoPos[MAXDIALOGROWS];
X   chtype	*buttonLabel[MAXDIALOGBUTTONS];
X   int		buttonLen[MAXDIALOGROWS];
X   int		buttonPos[MAXDIALOGROWS];
X   int		messageRows;
X   int		buttonCount;
X   int		currentButton;
X   int		boxWidth;
X   int		boxHeight;
X   boolean	separator;
X   boolean	box;
X   boolean	shadow;
X   chtype	highlight;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X   PROCESSFN	preProcessFunction;
X   void *	preProcessData;
X   PROCESSFN	postProcessFunction;
X   void *	postProcessData;
};
typedef struct _dialogBox_st CDKDIALOG;
CDKDIALOG *newCDKDialog (CDKSCREEN *cdkscreen,
X				int xPos, int yPos,
X				char **message, int Rows,
X				char **buttons, int buttonCount,
X				chtype highlight,
X				boolean separator, boolean box, boolean shadow);
int activateCDKDialog (CDKDIALOG *dialog, chtype *actions);
int injectCDKDialog (CDKDIALOG *dialog, chtype input);
void setCDKDialog (CDKDIALOG *dialog, chtype highlight,
X			boolean separator, boolean box);
void drawCDKDialogButton (CDKDIALOG *dialog, int button,
X				boolean box, chtype active, chtype highlight);
void drawCDKDialog (CDKDIALOG *dialog, boolean box);
void eraseCDKDialog (CDKDIALOG *dialog);
void destroyCDKDialog (CDKDIALOG *dialog);
void redrawCDKDialogButtons (CDKDIALOG *dialog);
void setCDKDialogPreProcess (CDKDIALOG *dialog, PROCESSFN callback, void *data);
void setCDKDialogPostProcess (CDKDIALOG *dialog, PROCESSFN callback, void *data);
X
/*
X * =========================================================
X * 	Declare Scale Box Prototypes and Defines
X * =========================================================
X */
struct _scale_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowWin;
X   WINDOW	*fieldWin;
X   WINDOW	*labelWin;
X   chtype	*label;
X   int		labelLen;
X   int		labelPos;
X   int		fieldWidth;
X   chtype	fieldAttr;
X   int		low;
X   int		high;
X   int		current;
X   int		inc;
X   int		fastinc;
X   boolean	box;
X   boolean	shadow;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X   PROCESSFN	preProcessFunction;
X   void *	preProcessData;
X   PROCESSFN	postProcessFunction;
X   void *	postProcessData;
};
typedef struct _scale_st CDKSCALE;
CDKSCALE *newCDKScale (CDKSCREEN *cdkscreen,
X			int xpos, int ypos, int lpos,
X			char *label, chtype fieldAttr, int fieldWidth,
X			int start, int low, int high, int inc, int fastinc,
X			boolean box, boolean shadow);
int activateCDKScale (CDKSCALE *scale, chtype *actions);
int injectCDKScale (CDKSCALE *scale, chtype input);
void setCDKScale (CDKSCALE *scale, int low, int high, int value, boolean box);
void drawCDKScale (CDKSCALE *scale, boolean box);
void drawCDKScaleField (CDKSCALE *scale);
void eraseCDKScale (CDKSCALE *scale);
void destroyCDKScale (CDKSCALE *scale);
void setCDKScalePreProcess (CDKSCALE *scale, PROCESSFN callback, void *data);
void setCDKScalePostProcess (CDKSCALE *scale, PROCESSFN callback, void *data);
X
/*
X * =========================================================
X * 	Declare Marquee Prototypes and Defines
X * =========================================================
X */
struct _marquee_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowWin;
X   int		active;
X   int		width;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   boolean	box;
X   boolean	shadow;
};
typedef struct _marquee_st CDKMARQUEE;
CDKMARQUEE *newCDKMarquee (CDKSCREEN *cdkscreen, int xpos, int ypos,
X				int width, boolean shadow);
int activateCDKMarquee (CDKMARQUEE *marquee, char *message,
X				int delay, int repeat, boolean box);
void drawCDKMarquee (CDKMARQUEE *marquee, boolean box);
void eraseCDKMarquee (CDKMARQUEE *marquee);
void destroyCDKMarquee (CDKMARQUEE *marquee);
X
/*
X * =========================================================
X * 	Declare Menu Prototypes and Defines
X * =========================================================
X */
#define MAXMENUITEMS	30
#define MAXSUBITEMS	98
struct _menu_st {
X   WINDOW	*parent;
X   WINDOW	*pullWin[MAXMENUITEMS];
X   WINDOW	*titleWin[MAXMENUITEMS];
X   chtype	*title[MAXMENUITEMS];
X   int		titleLen[MAXMENUITEMS];
X   chtype	*sublist[MAXMENUITEMS][MAXSUBITEMS];
X   int		sublistLen[MAXMENUITEMS][MAXSUBITEMS];
X   int		subsize[MAXMENUITEMS];
X   int		menuPos;
X   int		menuItems;
X   chtype	titleAttr;
X   chtype	subtitleAttr;
X   int		currentTitle;
X   int		currentSubtitle;
X   int		lastTitle;
X   int		lastSubtitle;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   int		lastSelection;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X   PROCESSFN	preProcessFunction;
X   void *	preProcessData;
X   PROCESSFN	postProcessFunction;
X   void *	postProcessData;
};
typedef struct _menu_st CDKMENU;
CDKMENU *newCDKMenu (CDKSCREEN *cdkscreen,
X			char *menulist[MAXMENUITEMS][MAXSUBITEMS],
X			int menuitems,
X			int *subsize,
X			int *menuloc,
X			int menuPos,
X			chtype titleattr,
X			chtype subtitleattr);
int activateCDKMenu (CDKMENU *menu, chtype *actions);
int injectCDKMenu (CDKMENU *menu, chtype input);
void setCDKMenu (CDKMENU *menu, int menuitem, int submenuitem,
X			chtype titlehighlight, chtype subtitlehighlight);
void drawCDKMenu (CDKMENU *menu);
void drawCDKMenuTitles (CDKMENU *menu);
void drawCDKMenuSubwin (CDKMENU *menu);
void eraseCDKMenu (CDKMENU *menu);
void eraseCDKMenuSubwin (CDKMENU *menu);
void destroyCDKMenu (CDKMENU *menu);
void cleanUpMenu (CDKMENU *menu);
void setCDKMenuPreProcess (CDKMENU *menu, PROCESSFN callback, void *data);
void setCDKMenuPostProcess (CDKMENU *menu, PROCESSFN callback, void *data);
X
/*
X * =========================================================
X * 	Declare Matrix Prototypes and Defines
X * =========================================================
X */
#define	MAXMATRIXROWS	1000
#define	MAXMATRIXCOLS	1000
struct _matrix_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowWin;
X   WINDOW	*cell[MAXMATRIXROWS][MAXMATRIXCOLS];
X   char		*info[MAXMATRIXROWS][MAXMATRIXCOLS];
X   int		rows;
X   int		cols;
X   int		vrows;
X   int		vcols;
X   int		colwidths[MAXMATRIXCOLS];
X   int		colvalues[MAXMATRIXCOLS];
X   chtype	*coltitle[MAXMATRIXCOLS];
X   int		coltitleLen[MAXMATRIXROWS];
X   int		coltitlePos[MAXMATRIXROWS];
X   int		maxct;
X   chtype	*rowtitle[MAXMATRIXROWS];
X   int		rowtitleLen[MAXMATRIXROWS];
X   int		rowtitlePos[MAXMATRIXROWS];
X   int		maxrt;
X   int		rowSpace;
X   int		colSpace;
X   int		row;
X   int		col;
X   int		crow;
X   int		ccol;
X   int		trow;
X   int		lcol;
X   int		oldcrow;
X   int		oldccol;
X   int		oldvrow;
X   int		oldvcol;
X   boolean	boxMatrix;
X   boolean	boxCell;
X   boolean	shadow;
X   chtype	highlight;
X   int		dominant;
X   chtype	filler;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X   void	*	callbackfn;
X   PROCESSFN    preProcessFunction;
X   void *       preProcessData;
X   PROCESSFN    postProcessFunction;
X   void *       postProcessData;
};
typedef struct _matrix_st CDKMATRIX;
typedef void (*MATRIXCB) (CDKMATRIX *matrix, chtype input);
CDKMATRIX *newCDKMatrix (CDKSCREEN *cdkscreen,
X				int xpos, int ypos,
X				int rows, int cols,
X				int vrows, int vcols,
X				char **rowtitles,
X				char **coltitles,
X				int *colwidths, int *coltypes,
X				int rowspace, int colspace, chtype filler,
X				int dominantAttrib,
X				boolean boxMatrix, boolean boxCell,
X				boolean shadow);
int activateCDKMatrix (CDKMATRIX *matrix, chtype *actions);
int injectCDKMatrix (CDKMATRIX *matrix, chtype input);
void setCDKMatrix (CDKMATRIX *matrix,
X			char *info[MAXMATRIXROWS][MAXMATRIXCOLS],
X			int rows, int *subSize);
void drawCDKMatrix (CDKMATRIX *matrix, boolean box);
void eraseCDKMatrix (CDKMATRIX *matrix);
void cleanCDKMatrix (CDKMATRIX *matrix);
void setCDKMatrixCB (CDKMATRIX *matrix, MATRIXCB callback);
int moveToCDKMatrixCell (CDKMATRIX *matrix, int newrow, int newcol);
void destroyCDKMatrix (CDKMATRIX *matrix);
void drawCDKMatrixCell (CDKMATRIX *matrix,
X			int srow, int scol, int vrow, int vcol,
X			chtype attr, boolean box);
void CDKMatrixCallBack (CDKMATRIX *matrix, chtype input);
void highlightCDKMatrixCell (CDKMATRIX *matrix);
int jumpToCell (CDKMATRIX *matrix);
void setCDKMatrixPreProcess (CDKMATRIX *matrix, PROCESSFN callback, void *data);
void setCDKMatrixPostProcess (CDKMATRIX *matrix, PROCESSFN callback, void *data);
X
/*
X * =========================================================
X * 	Declare Histogram Prototypes and Defines
X * =========================================================
X */
struct _histogram_st {
X   WINDOW			*parent;
X   WINDOW			*win;
X   WINDOW			*shadowWin;
X   WINDOW 			*labelWin;
X   chtype			*label;
X   int				labelLen;
X   char				*statschar;
X   char				*lowchar;
X   char				*highchar;
X   chtype			filler;
X   chtype			labelAttr;
X   float			percent;
X   int				height;
X   int				width;
X   int 				orient;
X   int				statspos;
X   int				statsattr;
X   EHistogramDisplayType	viewtype;
X   int				high;
X   int				low;
X   int				value;
X   int				chars;
X   int				lowx,	lowy;
X   int				highx,	highy;
X   int				labelx,	labely;
X   int				statsx,	statsy;
X   int				histx,	histy;
X   boolean			box;
X   boolean			shadow;
X   CDKSCREEN			*screen;
X   int				screenIndex;
};
typedef struct _histogram_st CDKHISTOGRAM;
CDKHISTOGRAM *newCDKHistogram (CDKSCREEN *cdkscreen,
X				int xpos, int ypos, int lpos,
X				int height, int width, int orient,
X				char *label, boolean box, boolean shadow);
void setCDKHistogram (CDKHISTOGRAM *histogram,
X			EHistogramDisplayType viewtype,
X			int statspos, chtype statsattr,
X			int low, int high, int value,
X			chtype filler, boolean box);
void drawCDKHistogram (CDKHISTOGRAM *histogram, boolean box);
void eraseCDKHistogram (CDKHISTOGRAM *histogram);
void destroyCDKHistogram (CDKHISTOGRAM *histogram);
X
/*
X * =========================================================
X * 	Declare Selection List Prototypes and Defines
X * =========================================================
X */
#define	MAXCHOICES	100
struct _selection_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowWin;
X   chtype	*title;
X   int		titlePos;
X   int		titleLen;
X   int		titleAdj;
X   chtype	*item[MAXITEMS];
X   int		itemLen[MAXITEMS];
X   int		itemPos[MAXITEMS];
X   chtype	*choice[MAXCHOICES];
X   int		choicelen[MAXCHOICES];
X   int		choiceCount;
X   int		maxchoicelen;
X   int		selections[MAXITEMS];
X   int		maxTopItem;
X   int		maxLeftChar;
X   int		leftChar;
X   int		lastItem;
X   int		currentTop;
X   int		currentHigh;
X   int		currentItem;
X   int		listSize;
X   int		boxWidth;
X   int		boxHeight;
X   int		viewSize;
X   boolean	box;
X   boolean	shadow;
X   chtype	highlight;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X   PROCESSFN	preProcessFunction;
X   void *	preProcessData;
X   PROCESSFN	postProcessFunction;
X   void *	postProcessData;
};
typedef struct _selection_st CDKSELECTION;
CDKSELECTION *newCDKSelection (CDKSCREEN *cdkscreen,
X				int xpos, int ypos, int height, int width,
X				char *title,
X				char **list, int listSize,
X				char **choices, int choiceSize,
X				chtype highlight,
X				boolean box, boolean shadow);
int activateCDKSelection (CDKSELECTION *selection, chtype *actions);
int injectCDKSelection (CDKSELECTION *selection, chtype input);
void drawCDKSelection (CDKSELECTION *selection, boolean box);
void eraseCDKSelection (CDKSELECTION *selection);
void destroyCDKSelection (CDKSELECTION *selection);
void drawCDKSelectionList (CDKSELECTION *selection, boolean box);
void setCDKSelection (CDKSELECTION *selection, chtype highlight,
X			int defChoices[], boolean box);
void setCDKSelectionPreProcess (CDKSELECTION *selection, PROCESSFN callback, void *data);
void setCDKSelectionPostProcess (CDKSELECTION *selection, PROCESSFN callback, void *data);
X
X
/*
X * =========================================================
X * 	Declare Viewer List Prototypes and Defines
X * =========================================================
X */
#define	MAXLINES	10000
#define	MAXBUTTONS	50
struct _viewer_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowWin;
X   chtype	*button[MAXBUTTONS];
X   int		buttonLen[MAXBUTTONS];
X   int		buttonPos[MAXBUTTONS];
X   int		buttonCount;
X   chtype	buttonHighlight;
X   chtype	*info[MAXLINES];
X   int		infoLen[MAXLINES];
X   int		infoPos[MAXLINES];
X   chtype	*title;
X   int		titleLen;
X   int		titlePos;
X   int		infoSize;
X   int		boxHeight;
X   int		boxWidth;
X   int		viewSize;
X   int		currentTop;
X   int		currentButton;
X   int		leftChar;
X   int		length;
X   int		maxLeftChar;
X   int		maxTopLine;
X   int		characters;
X   boolean	interpret;
X   boolean	box;
X   boolean	shadow;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
};
typedef struct _viewer_st CDKVIEWER;
CDKVIEWER *newCDKViewer (CDKSCREEN *cdkscreen,
X				int xpos, int ypos,
X				int height, int width,
X				char **buttons, int buttonCount,
X				chtype buttonHighlight,
X				boolean box, boolean shadow);
int activateCDKViewer (CDKVIEWER *viewer);
void setCDKViewer (CDKVIEWER *viewer, char *title, 
X			char **info, int infoSize,
X			chtype buttonHighlight,
X			boolean interpret, boolean box);
void drawCDKViewer (CDKVIEWER *viewer, int boolean);
void drawCDKViewerButtons (CDKVIEWER *viewer);
void eraseCDKViewer (CDKVIEWER *viewer);
void destroyCDKViewer (CDKVIEWER *viewer);
X
/*
X * =========================================================
X * 	Declare Graph Prototypes and Defines
X * =========================================================
X */
struct _graph_st {
X   WINDOW		*parent;
X   WINDOW		*win;
X   WINDOW		*shadowWin;
X   chtype		*title;
X   chtype		*graphChar;
X   int			titlePos;
X   int			titleLen;
X   boolean		box;
X   boolean		shadow;
X   int			boxHeight;
X   int			boxWidth;
X   chtype		*xtitle;
X   int			xtitlePos;
X   int			xtitleLen;
X   int			values[MAXLINES];
X   int			count;
X   int			minx;
X   int			maxx;
X   int			xscale;
X   int			txpos;
X   chtype		*ytitle;
X   int			ytitlePos;
X   int			ytitleLen;
X   int			yscale;
X   int			typos;
X   EGraphDisplayType	displayType;
X   CDKSCREEN		*screen;
X   int			screenIndex;
};
typedef struct _graph_st CDKGRAPH;
CDKGRAPH *newCDKGraph (CDKSCREEN *cdkscreen,
X			int xpos, int ypos, int height, int width,
X			char *title, char *xtitle, char *ytitle);
int setCDKGraph (CDKGRAPH *graph, 
X			int *values, int count, char *graphChar,
X			boolean startAtZero,
X			EGraphDisplayType displayType);
void drawCDKGraph (CDKGRAPH *graph, boolean box);
void eraseCDKGraph (CDKGRAPH *graph);
void destroyCDKGraph (CDKGRAPH *graph);
X
/*
X * =========================================================
X * 	Declare Radio Button Prototypes and Defines
X * =========================================================
X */
struct _radio_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowWin;
X   chtype	*title;
X   int		titleLen;
X   int		titlePos;
X   chtype	*item[MAXITEMS];
X   int		itemLen[MAXITEMS];
X   int		itemPos[MAXITEMS];
X   int		titleAdj;
X   chtype	choiceChar;
X   int		maxLeftChar;
X   int		widestItem;
X   int		leftChar;
X   int		selectedItem;
X   int		currentTop;
X   int		currentItem;
X   int		currentHigh;
X   int		listSize;
X   int		lastItem;
X   int		maxTopItem;
X   int		boxWidth;
X   int		boxHeight;
X   int		viewSize;
X   int		defItem;
X   boolean	box;
X   boolean	shadow;
X   chtype	highlight;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X   PROCESSFN	preProcessFunction;
X   void *	preProcessData;
X   PROCESSFN	postProcessFunction;
X   void *	postProcessData;
};
typedef struct _radio_st CDKRADIO;
CDKRADIO *newCDKRadio (CDKSCREEN *cdkscreen,
X			int xpos, int ypos, int height, int width,
X			char *title, char **mesg, int items,
X			chtype choiceChar, int defItem,
X			chtype highlight, boolean box, boolean shadow);
int activateCDKRadio (CDKRADIO *radio, chtype *actions);
int injectCDKRadio (CDKRADIO *radio, chtype input);
void setCDKRadio (CDKRADIO *radio, chtype highlight,
X			chtype choiceChar, boolean box);
void drawCDKRadio (CDKRADIO *radio, boolean box);
void drawCDKRadioList (CDKRADIO *radio, boolean box);
void eraseCDKRadio (CDKRADIO *radio);
void destroyCDKRadio (CDKRADIO *radio);
void setCDKRadioPreProcess (CDKRADIO *radio, PROCESSFN callback, void *data);
void setCDKRadioPostProcess (CDKRADIO *radio, PROCESSFN callback, void *data);
X
/*
X * =========================================================
X * 	       Declare Template Object....
X * =========================================================
X */
struct _template_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowWin;
X   WINDOW	*labelWin;
X   chtype	*label;
X   chtype	*overlay;
X   chtype	overlayAttr;
X   char 	*plate;
X   char		*info;
X   int		labelLen;
X   int		overlayLen;
X   int		labelPos;
X   int		fieldWidth;
X   int		platePos;
X   int		plateLen;
X   int		screenPos;
X   int		infoPos;
X   chtype	labelAttr;
X   chtype	fieldAttr;
X   WINDOW	*field;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   boolean	box;
X   boolean	shadow;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X   void	*	callbackfn;
X   PROCESSFN	preProcessFunction;
X   void *	preProcessData;
X   PROCESSFN	postProcessFunction;
X   void *	postProcessData;
};
typedef struct _template_st CDKTEMPLATE;
typedef void (*TEMPLATECB) (CDKTEMPLATE *template, chtype input);
CDKTEMPLATE *newCDKTemplate (CDKSCREEN *cdkscreen,
X				int xpos, int ypos, int lpos,
X				char *label, char *plate, char *overlay,
X				boolean box, boolean shadow);
char *activateCDKTemplate (CDKTEMPLATE *template, chtype *actions);
char *injectCDKTemplate (CDKTEMPLATE *template, chtype input);
void setCDKTemplate (CDKTEMPLATE *template, char *value, boolean box);
void drawCDKTemplate (CDKTEMPLATE *template, boolean box);
void drawCDKTemplateField (CDKTEMPLATE *template);
void eraseCDKTemplate (CDKTEMPLATE *template);
void cleanCDKTemplate (CDKTEMPLATE *template);
void destroyCDKTemplate (CDKTEMPLATE *template);
void setCDKTemplateCB (CDKTEMPLATE *template, TEMPLATECB callback);
char *mixCDKTemplate (CDKTEMPLATE *template);
char *unmixCDKTemplate (CDKTEMPLATE *template, char *string);
void adjustCDKTemplateCursor (CDKTEMPLATE *template, int direction);
void CDKTemplateCallBack (CDKTEMPLATE *template, chtype input);
void setCDKTemplatePreProcess (CDKTEMPLATE *template, PROCESSFN callback, void *data);
void setCDKTemplatePostProcess (CDKTEMPLATE *template, PROCESSFN callback, void *data);
X
/*
X * =========================================================
X * 	       Declare Scrolling Window Object....
X * =========================================================
X */
struct _swindow_st {
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowWin;
X   chtype	*info[MAXLINES];
X   int		infoPos[MAXLINES];
X   int		infoLen[MAXLINES];
X   chtype	*title;
X   int		titlePos;
X   int		titleLen;
X   int		titleAdj;
X   int		itemCount;
X   int		boxHeight;
X   int		boxWidth;
X   int		viewSize;
X   int		maxTopLine;
X   int		currentTop;
X   int		leftChar;
X   int		maxLeftChar;
X   int		widestLine;
X   int		saveLines;
X   boolean	box;
X   boolean	shadow;
X   CDKSCREEN	*screen;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X   PROCESSFN	preProcessFunction;
X   void *	preProcessData;
X   PROCESSFN	postProcessFunction;
X   void *	postProcessData;
};
typedef struct _swindow_st CDKSWINDOW;
typedef void (*SWINDOWCB) (CDKSWINDOW *swindow, chtype input);
CDKSWINDOW *newCDKSwindow (CDKSCREEN *cdkscreen,
X				int xpos, int ypos, int height, int width,
X				char *title,
X				int saveLines,
X				boolean box, boolean shadow);
void activateCDKSwindow (CDKSWINDOW *swindow, chtype *actions);
int injectCDKSwindow (CDKSWINDOW *swindow, chtype input);
int execCDKSwindow (CDKSWINDOW *swindow, char *command, int insertPos);
void setCDKSwindow (CDKSWINDOW *swindow, char **info, int lines, boolean box);
void drawCDKSwindow (CDKSWINDOW *swindow, boolean box);
void drawCDKSwindowList (CDKSWINDOW *swindow, boolean box);
void eraseCDKSwindow (CDKSWINDOW *swindow);
void cleanCDKSwindow (CDKSWINDOW *swindow);
void addCDKSwindow (CDKSWINDOW *swindow, char *info, int insertPos);
void trimCDKSwindow (CDKSWINDOW *swindow, int start, int finish);
void destroyCDKSwindow (CDKSWINDOW *swindow);
void setCDKSwindowPreProcess (CDKSWINDOW *swindow, PROCESSFN callback, void *data);
void setCDKSwindowPostProcess (CDKSWINDOW *swindow, PROCESSFN callback, void *data);
X
/*
X * =========================================================
X * 	       Declare Item List Widget
X * =========================================================
X */
struct _itemlist_st {
X   CDKSCREEN	*screen;
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowWin;
X   WINDOW	*labelWin;
X   chtype	*label;
X   int		labelPos;
X   int		labelLen;
X   WINDOW	*fieldWin;
X   int		fieldWidth;
X   chtype	*item[MAXITEMS];
X   int		itemPos[MAXITEMS];
X   int		itemLen[MAXITEMS];
X   int		itemCount;
X   int		currentItem;
X   int		defaultItem;
X   boolean	box;
X   boolean	shadow;
X   int		screenIndex;
X   BINDFN	bindFunction[MAXBINDINGS];
X   void *	bindData[MAXBINDINGS];
X   PROCESSFN	preProcessFunction;
X   void *	preProcessData;
X   PROCESSFN	postProcessFunction;
X   void *	postProcessData;
};
typedef struct _itemlist_st CDKITEMLIST;
CDKITEMLIST *newCDKItemlist (CDKSCREEN *cdkscreen,
X				int xpos, int ypos,
X				int lpos, char *label,
X				char **itemlist, int count, int defaultItem,
X				boolean box, boolean shadow);
int activateCDKItemlist (CDKITEMLIST *itemlist, chtype *actions);
int injectCDKItemlist (CDKITEMLIST *itemlist, chtype input);
void setCDKItemlist (CDKITEMLIST *itemlist, char **list, int count,
X			int current, boolean box);
void drawCDKItemlist (CDKITEMLIST *itemlist, boolean box);
void drawCDKItemlistField (CDKITEMLIST *itemlist);
void eraseCDKItemlist (CDKITEMLIST *itemlist);
void destroyCDKItemlist	(CDKITEMLIST *itemlist);
void setCDKItemlistPreProcess (CDKITEMLIST *itemlist, PROCESSFN callback, void *data);
void setCDKItemlistPostProcess (CDKITEMLIST *itemlist, PROCESSFN callback, void *data);
X
/*
X * =========================================================
X *             Declare File Selector Widget
X * =========================================================
X */
struct _fileselector_st {
X   CDKSCREEN	*screen;
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowWin;
X   CDKLABEL	*title;
X   CDKENTRY	*filename;
X   CDKSCROLL	*fileList;
X   char		*dirContents[MAXITEMS];
X   int		fileCounter;
X   char 	*pwd;
X   char		*pathname;
X   int		xpos;
X   int		ypos;
X   int		height;
X   int		width;
X   chtype	fieldAttribute;
X   chtype	fillerCharacter;
X   chtype	highlight;
X   char		*dirAttribute;
X   char		*fileAttribute;
X   char		*linkAttribute;
X   char		*sockAttribute;
X   boolean	box;
X   boolean	shadow;
X   int		screenIndex;
};
typedef struct _fileselector_st CDKFSELECT;
CDKFSELECT *newCDKFselect (CDKSCREEN *cdkscreen,
X				int xpos, int ypos,
X				int height, int width, 
X				chtype fieldAttribute, chtype fillerChar,
X				chtype highlight,
X				char *dirAttributes, char *fileAttributes,
X				char *linkAttribute, char *sockAttribute,
X				boolean box, boolean shadow);
char *activateCDKFselect (CDKFSELECT *fselect);
void setCDKFselect (CDKFSELECT *fselect,
X			char *directory,
X			chtype fieldAttribute, chtype fillerChar,
X			chtype highlight,
X			char *dirAttribute, char *fileAttribute,
X			char *linkAttribute, char *sockAttribute,
X			boolean box);
void drawCDKFselect (CDKFSELECT *fselect, boolean box);
void eraseCDKFselect (CDKFSELECT *fselect);
void destroyCDKFselect (CDKFSELECT *fselect);
void deleteFileCB (EObjectType objectType, void *object, void *clientData);
X
/*
X * =========================================================
X *             Declare Canvas Widget
X * =========================================================
X */
#define	MAXCANVASHEIGHT	300
struct _canvas_st {
X   CDKSCREEN	*screen;
X   WINDOW	*parent;
X   WINDOW	*win;
X   WINDOW	*shadowWin;
X   chtype	*characters[MAXCANVASHEIGHT];
X   boolean	box;
X   boolean	shadow;
X   int		screenIndex;
};
typedef struct _canvas_st CDKCANVAS;
CDKCANVAS *newCDKCanvas (CDKSCREEN *cdkscreen,
X				int xpos, int ypos,
X				int height, int width, 
X				boolean box, boolean shadow);
void drawCDKCanvas (CDKCANVAS *canvas, boolean box);
void drawlineCDKCanvas (CDKCANVAS *canvas,
X			int startXpos, int startYpos,
X			int enxXpos, int endYpos);
void drawboxCDKCanvas (CDKCANVAS *canvas,
X			int leftXpos, int leftYpos,
X			int height, int width);
void destroyCDKCanvas (CDKCANVAS *canvas);
#endif
SHAR_EOF
  echo 'File cdk.h is complete' &&
  $shar_touch -am 0503190996 'cdk.h' &&
  chmod 0444 'cdk.h' ||
  echo 'restore of cdk.h failed'
  shar_count="`wc -c < 'cdk.h'`"
  test 38118 -eq "$shar_count" ||
    echo "cdk.h: original size 38118, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= cdkscreen.c ==============
if test -f 'cdkscreen.c' && test X"$1" != X"-c"; then
  echo 'x - skipping cdkscreen.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting cdkscreen.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'cdkscreen.c' &&
#include "cdk.h"
X
/*
X * $Author: glover $
X * $Date: 1996/04/21 04:47:17 $
X * $Revision: 1.40 $
X */
extern char *GCdkObjects[];
X
/*
X * This creates a new CDK screen.
X */
CDKSCREEN *initCDKScreen(WINDOW *window)
{
X   CDKSCREEN	*screen		= (CDKSCREEN *)malloc (sizeof (CDKSCREEN));
X   screen->objectCount		= 0;
X   screen->window		= window;
X
X   /* Set up basic curses settings.		*/
X   noecho();
X   cbreak();
X
X   /* OK, we are done.				*/
X   return (screen);
}
X
/*
X * This registers a CDK object with a screen.
X */
void registerCDKObject (CDKSCREEN *screen, EObjectType cdktype, void *object)
{
X   /* Set some basic vars.						*/
X   int objectNumber				= screen->objectCount;
X   screen->object[objectNumber]			= (void *)object;
X
X   /* Since dereferencing a void pointer is a no-no, we have to cast	*/
X   /* our pointer correctly.						*/
X   if (cdktype == vLABEL)
X   {
X      ((CDKLABEL *)object)->screenIndex		= objectNumber;
X      ((CDKLABEL *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vLABEL;
X   }
X   else if (cdktype == vENTRY)
X   {
X      ((CDKENTRY *)object)->screenIndex		= objectNumber;
X      ((CDKENTRY *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vENTRY;
X   }
X   else if (cdktype == vMENTRY)
X   {
X      ((CDKMENTRY *)object)->screenIndex	= objectNumber;
X      ((CDKMENTRY *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vMENTRY;
X   }
X   else if (cdktype == vSCROLL)
X   {
X      ((CDKSCROLL *)object)->screenIndex	= objectNumber;
X      ((CDKSCROLL *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vSCROLL;
X   }
X   else if (cdktype == vDIALOG)
X   {
X      ((CDKDIALOG *)object)->screenIndex	= objectNumber;
X      ((CDKDIALOG *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vDIALOG;
X   }
X   else if (cdktype == vSCALE)
X   {
X      ((CDKSCALE *)object)->screenIndex		= objectNumber;
X      ((CDKSCALE *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vSCALE;
X   }
X   else if (cdktype == vMARQUEE)
X   {
X      ((CDKMARQUEE *)object)->screenIndex	= objectNumber;
X      ((CDKMARQUEE *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vMARQUEE;
X   }
X   else if (cdktype == vMENU)
X   {
X      ((CDKMENU *)object)->screenIndex		= objectNumber;
X      ((CDKMENU *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vMENU;
X   }
X   else if (cdktype == vMATRIX)
X   {
X      ((CDKMATRIX *)object)->screenIndex	= objectNumber;
X      ((CDKMATRIX *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vMATRIX;
X   }
X   else if (cdktype == vHISTOGRAM)
X   {
X      ((CDKHISTOGRAM *)object)->screenIndex	= objectNumber;
X      ((CDKHISTOGRAM *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vHISTOGRAM;
X   }
X   else if (cdktype == vSELECTION)
X   {
X      ((CDKSELECTION *)object)->screenIndex	= objectNumber;
X      ((CDKSELECTION *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vSELECTION;
X   }
X   else if (cdktype == vVIEWER)
X   {
X      ((CDKVIEWER *)object)->screenIndex	= objectNumber;
X      ((CDKVIEWER *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vVIEWER;
X   }
X   else if (cdktype == vGRAPH)
X   {
X      ((CDKGRAPH *)object)->screenIndex		= objectNumber;
X      ((CDKGRAPH *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vGRAPH;
X   }
X   else if (cdktype == vRADIO)
X   {
X      ((CDKRADIO *)object)->screenIndex		= objectNumber;
X      ((CDKRADIO *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vRADIO;
X   }
X   else if (cdktype == vTEMPLATE)
X   {
X      ((CDKTEMPLATE *)object)->screenIndex	= objectNumber;
X      ((CDKTEMPLATE *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vTEMPLATE;
X   }
X   else if (cdktype == vSWINDOW)
X   {
X      ((CDKSWINDOW *)object)->screenIndex	= objectNumber;
X      ((CDKSWINDOW *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vSWINDOW;
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      ((CDKITEMLIST *)object)->screenIndex	= objectNumber;
X      ((CDKITEMLIST *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vITEMLIST;
X   }
X   else if (cdktype == vFSELECT)
X   {
X      ((CDKFSELECT *)object)->screenIndex	= objectNumber;
X      ((CDKFSELECT *)object)->screen		= screen;
X      screen->cdktype[objectNumber]		= vFSELECT;
X   }
X
X   /* Don't forget to inc the count.					*/
X   screen->objectCount++;
}
X
/*
X * This removes an object from the CDK screen.
X */
void unregisterCDKObject (EObjectType cdktype, void *object)
{
X   /* Declare some vars.						*/
X   CDKSCREEN *screen;
X   char *type;
X   int screenSize, index, x;
X
X   /* Since dereferencing a void pointer is a no-no, we have to cast	*/
X   /* our pointer correctly.						*/
X   if (cdktype == vLABEL)
X   {
X      screen		= ((CDKLABEL *)object)->screen;
X      index		= ((CDKLABEL *)object)->screenIndex;
X      type		= "Label";
X   }
X   else if (cdktype == vENTRY)
X   {
X      screen		= ((CDKENTRY *)object)->screen;
X      index		= ((CDKENTRY *)object)->screenIndex;
X      type		= "Entry";
X   }
X   else if (cdktype == vMENTRY)
X   {
X      screen		= ((CDKMENTRY *)object)->screen;
X      index		= ((CDKMENTRY *)object)->screenIndex;
X      type		= "MEntry";
X   }
X   else if (cdktype == vSCROLL)
X   {
X      screen		= ((CDKSCROLL *)object)->screen;
X      index		= ((CDKSCROLL *)object)->screenIndex;
X      type		= "Scroll";
X   }
X   else if (cdktype == vDIALOG)
X   {
X      screen		= ((CDKDIALOG *)object)->screen;
X      index		= ((CDKDIALOG *)object)->screenIndex;
X      type		= "Dialog";
X   }
X   else if (cdktype == vSCALE)
X   {
X      screen		= ((CDKSCALE *)object)->screen;
X      index		= ((CDKSCALE *)object)->screenIndex;
X      type		= "Scale";
X   }
X   else if (cdktype == vMARQUEE)
X   {
X      screen		= ((CDKMARQUEE *)object)->screen;
X      index		= ((CDKMARQUEE *)object)->screenIndex;
X      type		= "Marquee";
X   }
X   else if (cdktype == vMENU)
X   {
X      screen		= ((CDKMENU *)object)->screen;
X      index		= ((CDKMENU *)object)->screenIndex;
X      type		= "Menu";
X   }
X   else if (cdktype == vMATRIX)
X   {
X      screen		= ((CDKMATRIX *)object)->screen;
X      index		= ((CDKMATRIX *)object)->screenIndex;
X      type		= "Matrix";
X   }
X   else if (cdktype == vHISTOGRAM)
X   {
X      screen		= ((CDKHISTOGRAM *)object)->screen;
X      index		= ((CDKHISTOGRAM *)object)->screenIndex;
X      type		= "Histogram";
X   }
X   else if (cdktype == vSELECTION)
X   {
X      screen		= ((CDKSELECTION *)object)->screen;
X      index		= ((CDKSELECTION *)object)->screenIndex;
X      type		= "Selection";
X   }
X   else if (cdktype == vVIEWER)
X   {
X      screen		= ((CDKVIEWER *)object)->screen;
X      index		= ((CDKVIEWER *)object)->screenIndex;
X      type		= "Viewer";
X   }
X   else if (cdktype == vGRAPH)
X   {
X      screen		= ((CDKGRAPH *)object)->screen;
X      index		= ((CDKGRAPH *)object)->screenIndex;
X      type		= "Graph";
X   }
X   else if (cdktype == vRADIO)
X   {
X      screen		= ((CDKRADIO *)object)->screen;
X      index		= ((CDKRADIO *)object)->screenIndex;
X      type		= "Radio";
X   }
X   else if (cdktype == vTEMPLATE)
X   {
X      screen		= ((CDKTEMPLATE *)object)->screen;
X      index		= ((CDKTEMPLATE *)object)->screenIndex;
X      type		= "Template";
X   }
X   else if (cdktype == vSWINDOW)
X   {
X      screen		= ((CDKSWINDOW *)object)->screen;
X      index		= ((CDKSWINDOW *)object)->screenIndex;
X      type		= "SWindow";
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      screen		= ((CDKITEMLIST *)object)->screen;
X      index		= ((CDKITEMLIST *)object)->screenIndex;
X      type		= "Itemlist";
X   }
X   else if (cdktype == vFSELECT)
X   {
X      screen		= ((CDKFSELECT *)object)->screen;
X      index		= ((CDKFSELECT *)object)->screenIndex;
X      type		= "File Selector";
X   }
X
X   /* Set the screenSize.		*/
X   screenSize = screen->objectCount - 1;
X
X   /* If this is the last object -1 then this is the last. If not	*/
X   /* we have to shuffle all the other objects to the left.		*/
X   for (x=index; x < screenSize; x++)
X   {
X      screen->object[x]		= screen->object[x+1];
X      screen->cdktype[x]	= screen->cdktype[x+1];
X   }
X   screen->object[x]		= (void *)NULL;
X   screen->cdktype[x]		= 0;
X   screen->objectCount--;
}
X
/*
X * This 'brings' a CDK object to the top of the stack.
X */
void raiseCDKObject (EObjectType cdktype, void *object)
{
X   /* Declare some vars.						*/
X   void *swapobject	= (void *)NULL;
X   int toppos		= -1;
X   int swapindex	= -1;
X   EObjectType swaptype;
X
X   /* Should never dereference a void * pointer.			*/
X   if (cdktype == vLABEL)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKLABEL *)object)->screen->objectCount - 1;
X      swapobject	= (void *)((CDKLABEL *)object)->screen->object[toppos];
X      swaptype		= ((CDKLABEL *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKLABEL *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKLABEL *)object)->screenIndex			= toppos;
X      ((CDKLABEL *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKLABEL *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vENTRY)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKENTRY *)object)->screen->objectCount;
X      swapobject	= ((CDKENTRY *)object)->screen->object[toppos];
X      swaptype		= ((CDKENTRY *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKENTRY *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKENTRY *)object)->screenIndex			= toppos;
X      ((CDKENTRY *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKENTRY *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMENTRY)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKMENTRY *)object)->screen->objectCount;
X      swapobject	= ((CDKMENTRY *)object)->screen->object[toppos];
X      swaptype		= ((CDKMENTRY *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMENTRY *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMENTRY *)object)->screenIndex		= toppos;
X      ((CDKMENTRY *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMENTRY *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSCROLL)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKSCROLL *)object)->screen->objectCount;
X      swapobject	= ((CDKSCROLL *)object)->screen->object[toppos];
X      swaptype		= ((CDKSCROLL *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSCROLL *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSCROLL *)object)->screenIndex		= toppos;
X      ((CDKSCROLL *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSCROLL *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vDIALOG)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKDIALOG *)object)->screen->objectCount;
X      swapobject	= ((CDKDIALOG *)object)->screen->object[toppos];
X      swaptype		= ((CDKDIALOG *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKDIALOG *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKDIALOG *)object)->screenIndex		= toppos;
X      ((CDKDIALOG *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKDIALOG *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSCALE)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKSCALE *)object)->screen->objectCount;
X      swapobject	= ((CDKSCALE *)object)->screen->object[toppos];
X      swaptype		= ((CDKSCALE *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSCALE *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSCALE *)object)->screenIndex			= toppos;
X      ((CDKSCALE *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSCALE *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMARQUEE)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKMARQUEE *)object)->screen->objectCount;
X      swapobject	= ((CDKMARQUEE *)object)->screen->object[toppos];
X      swaptype		= ((CDKMARQUEE *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMARQUEE *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMARQUEE *)object)->screenIndex		= toppos;
X      ((CDKMARQUEE *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMARQUEE *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMENU)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKMENU *)object)->screen->objectCount;
X      swapobject	= ((CDKMENU *)object)->screen->object[toppos];
X      swaptype		= ((CDKMENU *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMENU *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMENU *)object)->screenIndex			= toppos;
X      ((CDKMENU *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMENU *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMATRIX)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKMATRIX *)object)->screen->objectCount;
X      swapobject	= ((CDKMATRIX *)object)->screen->object[toppos];
X      swaptype		= ((CDKMATRIX *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMATRIX *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMATRIX *)object)->screenIndex		= toppos;
X      ((CDKMATRIX *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMATRIX *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vHISTOGRAM)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKHISTOGRAM *)object)->screen->objectCount;
X      swapobject	= ((CDKHISTOGRAM *)object)->screen->object[toppos];
X      swaptype		= ((CDKHISTOGRAM *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKHISTOGRAM *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKHISTOGRAM *)object)->screenIndex		= toppos;
X      ((CDKHISTOGRAM *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKHISTOGRAM *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSELECTION)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKSELECTION *)object)->screen->objectCount;
X      swapobject	= ((CDKSELECTION *)object)->screen->object[toppos];
X      swaptype		= ((CDKSELECTION *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSELECTION *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSELECTION *)object)->screenIndex		= toppos;
X      ((CDKSELECTION *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSELECTION *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vVIEWER)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKVIEWER *)object)->screen->objectCount;
X      swapobject	= ((CDKVIEWER *)object)->screen->object[toppos];
X      swaptype		= ((CDKVIEWER *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKVIEWER *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKVIEWER *)object)->screenIndex		= toppos;
X      ((CDKVIEWER *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKVIEWER *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vGRAPH)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKGRAPH *)object)->screen->objectCount;
X      swapobject	= ((CDKGRAPH *)object)->screen->object[toppos];
X      swaptype		= ((CDKGRAPH *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKGRAPH *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKGRAPH *)object)->screenIndex			= toppos;
X      ((CDKGRAPH *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKGRAPH *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vRADIO)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKRADIO *)object)->screen->objectCount;
X      swapobject	= ((CDKRADIO *)object)->screen->object[toppos];
X      swaptype		= ((CDKRADIO *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKRADIO *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKRADIO *)object)->screenIndex			= toppos;
X      ((CDKRADIO *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKRADIO *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vTEMPLATE)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKTEMPLATE *)object)->screen->objectCount;
X      swapobject	= ((CDKTEMPLATE *)object)->screen->object[toppos];
X      swaptype		= ((CDKTEMPLATE *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKTEMPLATE *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKTEMPLATE *)object)->screenIndex		= toppos;
X      ((CDKTEMPLATE *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKTEMPLATE *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSWINDOW)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKSWINDOW *)object)->screen->objectCount;
X      swapobject	= ((CDKSWINDOW *)object)->screen->object[toppos];
X      swaptype		= ((CDKSWINDOW *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSWINDOW *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSWINDOW *)object)->screenIndex		= toppos;
X      ((CDKSWINDOW *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSWINDOW *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKITEMLIST *)object)->screen->objectCount;
X      swapobject	= ((CDKITEMLIST *)object)->screen->object[toppos];
X      swaptype		= ((CDKITEMLIST *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKITEMLIST *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKITEMLIST *)object)->screenIndex		= toppos;
X      ((CDKITEMLIST *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKITEMLIST *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      /* Save the old info...						*/
X      toppos		= ((CDKFSELECT *)object)->screen->objectCount;
X      swapobject	= ((CDKFSELECT *)object)->screen->object[toppos];
X      swaptype		= ((CDKFSELECT *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKFSELECT *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKFSELECT *)object)->screenIndex		= toppos;
X      ((CDKFSELECT *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKFSELECT *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   
X   /* OK, Lets swap 'em....						*/
X   if (swaptype == vLABEL)
X   {
X      ((CDKLABEL *)object)->screenIndex			= swapindex;
X      ((CDKLABEL *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKLABEL *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vENTRY)
X   {
X      ((CDKENTRY *)object)->screenIndex			= swapindex;
X      ((CDKENTRY *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKENTRY *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMENTRY)
X   {
X      ((CDKMENTRY *)object)->screenIndex		= swapindex;
X      ((CDKMENTRY *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKMENTRY *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSCROLL)
X   {
X      ((CDKSCROLL *)object)->screenIndex		= swapindex;
X      ((CDKSCROLL *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKSCROLL *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vDIALOG)
X   {
X      ((CDKDIALOG *)object)->screenIndex		= swapindex;
X      ((CDKDIALOG *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKDIALOG *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSCALE)
X   {
X      ((CDKSCALE *)object)->screenIndex			= swapindex;
X      ((CDKSCALE *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKSCALE *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMARQUEE)
X   {
X      ((CDKMARQUEE *)object)->screenIndex			= swapindex;
X      ((CDKMARQUEE *)object)->screen->object[swapindex]		= swapobject;
X      ((CDKMARQUEE *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMENU)
X   {
X      ((CDKMENU *)object)->screenIndex			= swapindex;
X      ((CDKMENU *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKMENU *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMATRIX)
X   {
X      ((CDKMATRIX *)object)->screenIndex		= swapindex;
X      ((CDKMATRIX *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKMATRIX *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vHISTOGRAM)
X   {
X      ((CDKHISTOGRAM *)object)->screenIndex			= swapindex;
X      ((CDKHISTOGRAM *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKHISTOGRAM *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSELECTION)
X   {
X      ((CDKSELECTION *)object)->screenIndex			= swapindex;
X      ((CDKSELECTION *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKSELECTION *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vVIEWER)
X   {
X      ((CDKVIEWER *)object)->screenIndex		= swapindex;
X      ((CDKVIEWER *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKVIEWER *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vGRAPH)
X   {
X      ((CDKGRAPH *)object)->screenIndex			= swapindex;
X      ((CDKGRAPH *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKGRAPH *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vRADIO)
X   {
X      ((CDKRADIO *)object)->screenIndex			= swapindex;
X      ((CDKRADIO *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKRADIO *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vTEMPLATE)
X   {
X      ((CDKTEMPLATE *)object)->screenIndex			= swapindex;
X      ((CDKTEMPLATE *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKTEMPLATE *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSWINDOW)
X   {
X      ((CDKSWINDOW *)object)->screenIndex			= swapindex;
X      ((CDKSWINDOW *)object)->screen->object[swapindex]		= swapobject;
X      ((CDKSWINDOW *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vITEMLIST)
X   {
X      ((CDKITEMLIST *)object)->screenIndex			= swapindex;
X      ((CDKITEMLIST *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKITEMLIST *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vFSELECT)
X   {
X      ((CDKFSELECT *)object)->screenIndex			= swapindex;
X      ((CDKFSELECT *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKFSELECT *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
}
X   
/*
X * This 'lowers' an object.
*/
void lowerCDKObject (EObjectType cdktype, void *object)
{
X   /* Declare some vars.						*/
X   void *swapobject	= (void *)NULL;
X   int toppos		= 0;
X   int swapindex	= -1;
X   EObjectType swaptype;
X
X   /* Should never dereference a void * pointer.			*/
X   if (cdktype == vLABEL)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKLABEL *)object)->screen->object[toppos];
X      swaptype		= ((CDKLABEL *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKLABEL *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKLABEL *)object)->screenIndex			= toppos;
X      ((CDKLABEL *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKLABEL *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vENTRY)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKENTRY *)object)->screen->object[toppos];
X      swaptype		= ((CDKENTRY *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKENTRY *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKENTRY *)object)->screenIndex			= toppos;
X      ((CDKENTRY *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKENTRY *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMENTRY)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKMENTRY *)object)->screen->object[toppos];
X      swaptype		= ((CDKMENTRY *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMENTRY *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMENTRY *)object)->screenIndex		= toppos;
X      ((CDKMENTRY *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMENTRY *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSCROLL)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKSCROLL *)object)->screen->object[toppos];
X      swaptype		= ((CDKSCROLL *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSCROLL *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSCROLL *)object)->screenIndex		= toppos;
X      ((CDKSCROLL *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSCROLL *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vDIALOG)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKDIALOG *)object)->screen->object[toppos];
X      swaptype		= ((CDKDIALOG *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKDIALOG *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKDIALOG *)object)->screenIndex		= toppos;
X      ((CDKDIALOG *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKDIALOG *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSCALE)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKSCALE *)object)->screen->object[toppos];
X      swaptype		= ((CDKSCALE *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSCALE *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSCALE *)object)->screenIndex			= toppos;
X      ((CDKSCALE *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSCALE *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMARQUEE)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKMARQUEE *)object)->screen->object[toppos];
X      swaptype		= ((CDKMARQUEE *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMARQUEE *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMARQUEE *)object)->screenIndex		= toppos;
X      ((CDKMARQUEE *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMARQUEE *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMENU)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKMENU *)object)->screen->object[toppos];
X      swaptype		= ((CDKMENU *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMENU *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMENU *)object)->screenIndex			= toppos;
X      ((CDKMENU *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMENU *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vMATRIX)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKMATRIX *)object)->screen->object[toppos];
X      swaptype		= ((CDKMATRIX *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKMATRIX *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKMATRIX *)object)->screenIndex		= toppos;
X      ((CDKMATRIX *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKMATRIX *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vHISTOGRAM)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKHISTOGRAM *)object)->screen->object[toppos];
X      swaptype		= ((CDKHISTOGRAM *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKHISTOGRAM *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKHISTOGRAM *)object)->screenIndex		= toppos;
X      ((CDKHISTOGRAM *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKHISTOGRAM *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSELECTION)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKSELECTION *)object)->screen->object[toppos];
X      swaptype		= ((CDKSELECTION *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSELECTION *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSELECTION *)object)->screenIndex		= toppos;
X      ((CDKSELECTION *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSELECTION *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vVIEWER)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKVIEWER *)object)->screen->object[toppos];
X      swaptype		= ((CDKVIEWER *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKVIEWER *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKVIEWER *)object)->screenIndex		= toppos;
X      ((CDKVIEWER *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKVIEWER *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vGRAPH)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKGRAPH *)object)->screen->object[toppos];
X      swaptype		= ((CDKGRAPH *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKGRAPH *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKGRAPH *)object)->screenIndex			= toppos;
X      ((CDKGRAPH *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKGRAPH *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vRADIO)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKRADIO *)object)->screen->object[toppos];
X      swaptype		= ((CDKRADIO *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKRADIO *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKRADIO *)object)->screenIndex			= toppos;
X      ((CDKRADIO *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKRADIO *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vTEMPLATE)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKTEMPLATE *)object)->screen->object[toppos];
X      swaptype		= ((CDKTEMPLATE *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKTEMPLATE *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKTEMPLATE *)object)->screenIndex		= toppos;
X      ((CDKTEMPLATE *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKTEMPLATE *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vSWINDOW)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKSWINDOW *)object)->screen->object[toppos];
X      swaptype		= ((CDKSWINDOW *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKSWINDOW *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKSWINDOW *)object)->screenIndex		= toppos;
X      ((CDKSWINDOW *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKSWINDOW *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vITEMLIST)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKITEMLIST *)object)->screen->object[toppos];
X      swaptype		= ((CDKITEMLIST *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKITEMLIST *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKITEMLIST *)object)->screenIndex		= toppos;
X      ((CDKITEMLIST *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKITEMLIST *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   else if (cdktype == vFSELECT)
X   {
X      /* Save the old info...						*/
X      swapobject	= ((CDKFSELECT *)object)->screen->object[toppos];
X      swaptype		= ((CDKFSELECT *)object)->screen->cdktype[toppos];
X      swapindex		= ((CDKFSELECT *)object)->screenIndex;
X
X      /* Set the new info...						*/
X      ((CDKFSELECT *)object)->screenIndex		= toppos;
X      ((CDKFSELECT *)object)->screen->object[toppos]	= (void *)object;
X      ((CDKFSELECT *)object)->screen->cdktype[toppos]	= cdktype;
X   }
X   
X   /* OK, Lets swap 'em....						*/
X   if (swaptype == vLABEL)
X   {
X      ((CDKLABEL *)object)->screenIndex			= swapindex;
X      ((CDKLABEL *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKLABEL *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vENTRY)
X   {
X      ((CDKENTRY *)object)->screenIndex			= swapindex;
X      ((CDKENTRY *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKENTRY *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMENTRY)
X   {
X      ((CDKMENTRY *)object)->screenIndex		= swapindex;
X      ((CDKMENTRY *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKMENTRY *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSCROLL)
X   {
X      ((CDKSCROLL *)object)->screenIndex		= swapindex;
X      ((CDKSCROLL *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKSCROLL *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vDIALOG)
X   {
X      ((CDKDIALOG *)object)->screenIndex		= swapindex;
X      ((CDKDIALOG *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKDIALOG *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSCALE)
X   {
X      ((CDKSCALE *)object)->screenIndex			= swapindex;
X      ((CDKSCALE *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKSCALE *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMARQUEE)
X   {
X      ((CDKMARQUEE *)object)->screenIndex			= swapindex;
X      ((CDKMARQUEE *)object)->screen->object[swapindex]		= swapobject;
X      ((CDKMARQUEE *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMENU)
X   {
X      ((CDKMENU *)object)->screenIndex			= swapindex;
X      ((CDKMENU *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKMENU *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vMATRIX)
X   {
X      ((CDKMATRIX *)object)->screenIndex		= swapindex;
X      ((CDKMATRIX *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKMATRIX *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vHISTOGRAM)
X   {
X      ((CDKHISTOGRAM *)object)->screenIndex			= swapindex;
X      ((CDKHISTOGRAM *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKHISTOGRAM *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSELECTION)
X   {
X      ((CDKSELECTION *)object)->screenIndex			= swapindex;
X      ((CDKSELECTION *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKSELECTION *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vVIEWER)
X   {
X      ((CDKVIEWER *)object)->screenIndex		= swapindex;
X      ((CDKVIEWER *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKVIEWER *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vGRAPH)
X   {
X      ((CDKGRAPH *)object)->screenIndex			= swapindex;
X      ((CDKGRAPH *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKGRAPH *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vRADIO)
X   {
X      ((CDKRADIO *)object)->screenIndex			= swapindex;
X      ((CDKRADIO *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKRADIO *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vTEMPLATE)
X   {
X      ((CDKTEMPLATE *)object)->screenIndex			= swapindex;
X      ((CDKTEMPLATE *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKTEMPLATE *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vSWINDOW)
X   {
X      ((CDKSWINDOW *)object)->screenIndex			= swapindex;
X      ((CDKSWINDOW *)object)->screen->object[swapindex]		= swapobject;
X      ((CDKSWINDOW *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vITEMLIST)
X   {
X      ((CDKITEMLIST *)object)->screenIndex			= swapindex;
X      ((CDKITEMLIST *)object)->screen->object[swapindex]	= swapobject;
X      ((CDKITEMLIST *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
X   else if (swaptype == vFSELECT)
X   {
X      ((CDKFSELECT *)object)->screenIndex			= swapindex;
X      ((CDKFSELECT *)object)->screen->object[swapindex]		= swapobject;
X      ((CDKFSELECT *)object)->screen->cdktype[swapindex]	= swaptype;
X   }
}
X
/*
X * This refreshes all the objects in the screen.
X */
void refreshCDKScreen (CDKSCREEN *cdkscreen)
{
X   int objectCount 	= cdkscreen->objectCount;
X   int x;
X
X   /* We just call the drawObject function...	*/
X   for (x=0; x < objectCount; x++)
X   {
X      if (cdkscreen->cdktype[x] == vLABEL)
X      {
X         CDKLABEL *label	= (CDKLABEL *)(cdkscreen->object[x]);
X         drawCDKLabel (label, label->box);
X      }
X      else if (cdkscreen->cdktype[x] == vENTRY)
X      {
X         CDKENTRY *entry	= (CDKENTRY *)(cdkscreen->object[x]);
X         drawCDKEntry (entry, entry->box);
X      }
X      else if (cdkscreen->cdktype[x] == vMENTRY)
X      {
X         CDKMENTRY *mentry	= (CDKMENTRY *)(cdkscreen->object[x]);
X         drawCDKMentry (mentry, mentry->box);
X      }
X      else if (cdkscreen->cdktype[x] == vSCROLL)
X      {
X         CDKSCROLL *scroll	= (CDKSCROLL *)(cdkscreen->object[x]);
X         drawCDKScroll (scroll, scroll->box);
X      }
X      else if (cdkscreen->cdktype[x] == vDIALOG)
X      {
X         CDKDIALOG *dialog	= (CDKDIALOG *)(cdkscreen->object[x]);
X         drawCDKDialog (dialog, dialog->box);
X      }
X      else if (cdkscreen->cdktype[x] == vSCALE)
X      {
X         CDKSCALE *scale	= (CDKSCALE *)(cdkscreen->object[x]);
X         drawCDKScale (scale, scale->box);
X      }
X      else if (cdkscreen->cdktype[x] == vMARQUEE)
X      {
X         CDKMARQUEE *marquee	= (CDKMARQUEE *)(cdkscreen->object[x]);
X         drawCDKMarquee (marquee, marquee->box);
X      }
X      else if (cdkscreen->cdktype[x] == vMENU)
X      {
X         CDKMENU *menu	= (CDKMENU *)(cdkscreen->object[x]);
X         drawCDKMenu (menu);
X      }
X      else if (cdkscreen->cdktype[x] == vMATRIX)
X      {
X         CDKMATRIX *matrix	= (CDKMATRIX *)(cdkscreen->object[x]);
X         drawCDKMatrix (matrix, matrix->boxMatrix);
X      }
X      else if (cdkscreen->cdktype[x] == vHISTOGRAM)
X      {
X         CDKHISTOGRAM *histogram	= (CDKHISTOGRAM *)(cdkscreen->object[x]);
X         drawCDKHistogram (histogram, histogram->box);
X      }
X      else if (cdkscreen->cdktype[x] == vSELECTION)
X      {
X         CDKSELECTION *selection	= (CDKSELECTION *)(cdkscreen->object[x]);
X         drawCDKSelection (selection, selection->box);
X      }
X      else if (cdkscreen->cdktype[x] == vVIEWER)
X      {
X         CDKVIEWER *viewer	= (CDKVIEWER *)(cdkscreen->object[x]);
X         drawCDKViewer (viewer, viewer->box);
X      }
X      else if (cdkscreen->cdktype[x] == vGRAPH)
X      {
X         CDKGRAPH *graph	= (CDKGRAPH *)(cdkscreen->object[x]);
X         drawCDKGraph (graph, graph->box);
X      }
X      else if (cdkscreen->cdktype[x] == vRADIO)
X      {
X         CDKRADIO *radio	= (CDKRADIO *)(cdkscreen->object[x]);
X         drawCDKRadio (radio, radio->box);
X      }
X      else if (cdkscreen->cdktype[x] == vTEMPLATE)
X      {
X         CDKTEMPLATE *template	= (CDKTEMPLATE *)(cdkscreen->object[x]);
X         drawCDKTemplate (template, template->box);
X      }
X      else if (cdkscreen->cdktype[x] == vSWINDOW)
X      {
X         CDKSWINDOW *swindow	= (CDKSWINDOW *)(cdkscreen->object[x]);
X         drawCDKSwindow (swindow, swindow->box);
X      }
X      else if (cdkscreen->cdktype[x] == vITEMLIST)
X      {
X         CDKITEMLIST *itemlist	= (CDKITEMLIST *)(cdkscreen->object[x]);
X         drawCDKItemlist (itemlist, itemlist->box);
X      }
X      else if (cdkscreen->cdktype[x] == vFSELECT)
X      {
X         CDKFSELECT *fselect	= (CDKFSELECT *)(cdkscreen->object[x]);
X         drawCDKFselect (fselect, fselect->box);
X      }
X   }
X
X   /* Refresh the screen.			*/
X   /*wrefresh (cdkscreen->window);*/
}
X
/*
X * This clears all the objects in the screen.
X */
void eraseCDKScreen (CDKSCREEN *cdkscreen)
{
X   int objectCount 	= cdkscreen->objectCount;
X   int x;
X
X   /* We just call the drawObject function...	*/
X   for (x=0; x < objectCount; x++)
X   {
X      if (cdkscreen->cdktype[x] == vLABEL)
X      {
X         eraseCDKLabel ((CDKLABEL *)(cdkscreen->object[x]));
X      }
X      else if (cdkscreen->cdktype[x] == vENTRY)
X      {
X         eraseCDKEntry ((CDKENTRY *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vMENTRY)
X      {
X         eraseCDKMentry ((CDKMENTRY *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vSCROLL)
X      {
X         eraseCDKScroll ((CDKSCROLL *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vDIALOG)
X      {
X         eraseCDKDialog ((CDKDIALOG *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vSCALE)
X      {
X         eraseCDKScale ((CDKSCALE *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vMARQUEE)
X      {
X         eraseCDKMarquee ((CDKMARQUEE *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vMENU)
X      {
X         eraseCDKMenu ((CDKMENU *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vMATRIX)
X      {
X         eraseCDKMatrix ((CDKMATRIX *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vHISTOGRAM)
X      {
X         eraseCDKHistogram ((CDKHISTOGRAM *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vSELECTION)
X      {
X         eraseCDKSelection ((CDKSELECTION *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vVIEWER)
X      {
X         eraseCDKViewer ((CDKVIEWER *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vGRAPH)
X      {
X         eraseCDKGraph ((CDKGRAPH *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vRADIO)
X      {
X         eraseCDKRadio ((CDKRADIO *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vTEMPLATE)
X      {
X         eraseCDKTemplate ((CDKTEMPLATE *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vSWINDOW)
X      {
X         eraseCDKSwindow ((CDKSWINDOW *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vITEMLIST)
X      {
X         eraseCDKItemlist ((CDKITEMLIST *)cdkscreen->object[x]);
X      }
X      else if (cdkscreen->cdktype[x] == vFSELECT)
X      {
X         eraseCDKFselect ((CDKFSELECT *)cdkscreen->object[x]);
X      }
X   }
X
X   /* Refresh the screen.			*/
X   wrefresh (cdkscreen->window);
}
X
/*
X * This destroys a CDK screen.
X */
void destroyCDKScreen (CDKSCREEN *screen)
{
X   free (screen);
}
X
/*
X * This is added to remain consistent.
X */
void endCDK()
{
X   /* Turn echoing back on...		*/
X   echo();
X
X   /* Turn off cbreak...		*/
X   nocbreak();
X
X   /* End the curses windows...		*/
X   endwin();
X
#ifdef XCURSES
X   XCursesExit();
#endif
}
X
/*
X * This is for pure diagnostics. Really should be taken out
X * at some point in time.
X */
void debugCDKScreen (CDKSCREEN *screen, char *mesg)
{
X   int count = screen->objectCount;
X   int x;
X
X   printf ("\nScreen Object Count: %d\n", count);
X   printf ("Message: %s\n", mesg);
X   for (x=0; x < count ; x++)
X   {
X      printf ("CDK Object[%d] : Type: %s\n", x, GCdkObjects[screen->cdktype[x]]);
X   }
}
SHAR_EOF
  $shar_touch -am 0503190896 'cdkscreen.c' &&
  chmod 0444 'cdkscreen.c' ||
  echo 'restore of cdkscreen.c failed'
  shar_count="`wc -c < 'cdkscreen.c'`"
  test 43144 -eq "$shar_count" ||
    echo "cdkscreen.c: original size 43144, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= curdefs.h ==============
if test -f 'curdefs.h' && test X"$1" != X"-c"; then
  echo 'x - skipping curdefs.h (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting curdefs.h (binary)'
  sed 's/^X//' << 'SHAR_EOF' > _sharuue.tmp &&
begin 600 curdefs.h
M(VEF;F1E9B!#55)$149?2`HC9&5F:6YE($-54D1%1E]("@HO*@H@*B`D075T
M:&]R.B!G;&]V97(@)`H@*B`D1&%T93H@,3DY-B\P-2\P,2`P-#HT.3HU."`D
M"B`J("12979I<VEO;CH@,2XQ.2`D"B`J+PH*+RH*("H@5&AI<R!H96%D97(@
M9FEL92!I<R!F;W(@;6%C:&EN97,@=VET:&]U="!A(&9U;&P@8W5R<V5S(&1E
M9FEN:71I;VXN"B`J+PH*(VEF9&5F($Y/0TA465!%"G1Y<&5D968@=6YS:6=N
M960@;&]N9R`@8VAT>7!E.PHC96YD:68*"B-I9FYD968)0T1+7U)%1E)%4T@*
M(V1E9FEN90E#1$M?4D5&4D532`DG#"<)+RH@2V5Y('5S960@=&\@<F5F<F5S
M:"!T:&4@<V-R965N+@DJ+PHC96YD:68*(VEF;F1E9@E#1$M?4$%35$4*(V1E
M9FEN90E#1$M?4$%35$4))Q`G"2\J($ME>2!U<V5D(&9O<B!P87-T:6YG+@D)
M*B\*(V5N9&EF"B-I9FYD968)0T1+7T-/4%D*(V1E9FEN90E#1$M?0T]060DG
M%"<)+RH@2V5Y('5S960@9F]R('1A:VEN9R!C;W!I97,N"0DJ+PHC96YD:68*
M(VEF;F1E9@E#1$M?15)!4T4*(V1E9FEN90E#1$M?15)!4T4))P4G"2\J($ME
M>2!U<V5D(&9O<B!E<F%S96EN9R!F:65L9',N"2HO"B-E;F1I9@HC:69N9&5F
M"4-$2U]#550*(V1E9FEN90E#1$M?0U54"0DG"R<)+RH@2V5Y('5S960@9F]R
M(&-U='1I;F<N"0DJ+PHC96YD:68*(VEF;F1E9@E#1$M?3D585`HC9&5F:6YE
M"4-$2U].15A4"2<.)PDO*B!5<V5D(&9O<B!S=VET8VAI;F<@8F5T=V5E;B!#
M9&L@;V)J96-T<PDJ+PHC96YD:68*(VEF;F1E9@E#1$M?5$535`HC9&5F:6YE
M"4-$2U]415-4"2?P)PHC96YD:68*(VEF;F1E9@E!7TY/05144DE""B-D969I
M;F4)05].3T%45%))0@DM,0DO*B!.;R!A='1R:6)U=&5S('=A;G1E9"X@3&5A
M=F4@87,@:7,N"2HO"B-E;F1I9@H*(VEF;F1E9@E34$%#10HC9&5F:6YE"5-0
M04-%"0DG("<*(V5N9&EF"B-I9FYD968@1$5,151%"B-D969I;F4@1$5,151%
M"0DG7#$W-R<)+RH@1&5L971E(&ME>0D)"0DJ+PHC96YD:68*(VEF;F1E9@E4
M04(*(V1E9FEN90E404()"2=<="<)+RH@5&%B(&ME>2X)"0D)*B\*(V5N9&EF
M"B-I9FYD968)2T597T530PHC9&5F:6YE"4M%65]%4T,)"2<;)PDO*B!%<V-A
M<&4@2V5Y+@D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4D5455)."B-D969I
M;F4@2T597U)%5%523@DG7#`Q,B<)+RH@4F5T=7)N(&ME>0D)"0DJ+PHC96YD
M:68*(VEF;F1E9B!+15E?5$%""B-D969I;F4@2T597U1!0@D))UQT)PDO*B!4
M86(@:V5Y"0D)"2HO"B-E;F1I9@HC:69N9&5F($M%65]!,0HC9&5F:6YE($M%
M65]!,0D),#4S-`DO*B!5<'!E<B!L969T(&]F(&ME>7!A9`D)"2HO"B-E;F1I
M9@HC:69N9&5F($M%65]!,PHC9&5F:6YE($M%65]!,PD),#4S-0DO*B!5<'!E
M<B!R:6=H="!O9B!K97EP860)"2HO"B-E;F1I9@HC:69N9&5F($M%65]",@HC
M9&5F:6YE($M%65]",@D),#4S-@DO*B!#96YT97(@;V8@:V5Y<&%D"0D)*B\*
M(V5N9&EF"B-I9FYD968@2T597T,Q"B-D969I;F4@2T597T,Q"0DP-3,W"2\J
M($QO=V5R(&QE9G0@;V8@:V5Y<&%D"0D)*B\*(V5N9&EF"B-I9FYD968@2T59
M7T,S"B-D969I;F4@2T597T,S"0DP-30P"2\J($QO=V5R(')I9VAT(&]F(&ME
M>7!A9`D)*B\*(V5N9&EF"B-I9FYD968@2T597T)404(*(V1E9FEN92!+15E?
M0E1!0@DP-30Q"2\J($)A8VL@=&%B(&ME>0D)"0DJ+PHC96YD:68*(VEF;F1E
M9B!+15E?0D5'"B-D969I;F4@2T597T)%1PD),#4T,@DO*B!B96<H:6YN:6YG
M*2!K97D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?0T%.0T5,"B-D969I;F4@
M2T597T-!3D-%3`DP-30S"2\J(&-A;F-E;"!K97D)"0D)*B\*(V5N9&EF"B-I
M9FYD968@2T597T-,3U-%"B-D969I;F4@2T597T-,3U-%"3`U-#0)+RH@8VQO
M<V4@:V5Y"0D)"2HO"B-E;F1I9@HC:69N9&5F($M%65]#3TU-04Y$"B-D969I
M;F4@2T597T-/34U!3D0),#4T-0DO*B!C;60@*&-O;6UA;F0I(&ME>0D)"2HO
M"B-E;F1I9@HC:69N9&5F($M%65]#3U!9"B-D969I;F4@2T597T-/4%D),#4T
M-@DO*B!C;W!Y(&ME>0D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?0U)%051%
M"B-D969I;F4@2T597T-214%410DP-30W"2\J(&-R96%T92!K97D)"0D)*B\*
M(V5N9&EF"B-I9FYD968@2T597T5.1`HC9&5F:6YE($M%65]%3D0)"3`U-3`)
M+RH@96YD(&ME>0D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?15A)5`HC9&5F
M:6YE($M%65]%6$E4"3`U-3$)+RH@97AI="!K97D)"0D)*B\*(V5N9&EF"B-I
M9FYD968@2T597T9)3D0*(V1E9FEN92!+15E?1DE.1`DP-34R"2\J(&9I;F0@
M:V5Y"0D)"2HO"B-E;F1I9@HC:69N9&5F($M%65](14Q0"B-D969I;F4@2T59
M7TA%3%`),#4U,PDO*B!H96QP(&ME>0D)"0DJ+PHC96YD:68*(VEF;F1E9B!+
M15E?34%22PHC9&5F:6YE($M%65]-05)+"3`U-30)+RH@;6%R:R!K97D)"0D)
M*B\*(V5N9&EF"B-I9FYD968@2T597TU%4U-!1T4*(V1E9FEN92!+15E?3453
M4T%'10DP-34U"2\J(&UE<W-A9V4@:V5Y"0D)"2HO"B-E;F1I9@HC:69N9&5F
M($M%65]-3U9%"B-D969I;F4@2T597TU/5D4),#4U-@DO*B!M;W9E(&ME>0D)
M"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?3D585`HC9&5F:6YE($M%65].15A4
M"3`U-3<)+RH@;F5X="!O8FIE8W0@:V5Y"0D)*B\*(V5N9&EF"B-I9FYD968@
M2T597T]014X*(V1E9FEN92!+15E?3U!%3@DP-38P"2\J(&]P96X@:V5Y"0D)
M"2HO"B-E;F1I9@HC:69N9&5F($M%65]/4%1)3TY3"B-D969I;F4@2T597T]0
M5$E/3E,),#4V,0DO*B!O<'1I;VYS(&ME>0D)"0DJ+PHC96YD:68*(VEF;F1E
M9B!+15E?4%)%5DE/55,*(V1E9FEN92!+15E?4%)%5DE/55,),#4V,@DO*B!P
M<F5V:6]U<R!O8FIE8W0@:V5Y"0D)*B\*(V5N9&EF"B-I9FYD968@2T597U)%
M1$\*(V1E9FEN92!+15E?4D5$3PDP-38S"2\J(')E9&\@:V5Y"0D)"2HO"B-E
M;F1I9@HC:69N9&5F($M%65]2149%4D5.0T4*(V1E9FEN92!+15E?4D5&15)%
M3D-%"3`U-C0)+RH@<F5F*&5R96YC92D@:V5Y"0D)*B\*(V5N9&EF"B-I9FYD
M968@2T597U)%1E)%4T@*(V1E9FEN92!+15E?4D5&4D532`DP-38U"2\J(')E
M9G)E<V@@:V5Y"0D)"2HO"B-E;F1I9@HC:69N9&5F($M%65]215!,04-%"B-D
M969I;F4@2T597U)%4$Q!0T4),#4V-@DO*B!R97!L86-E(&ME>0D)"0DJ+PHC
M96YD:68*(VEF;F1E9B!+15E?4D535$%25`HC9&5F:6YE($M%65]215-405)4
M"3`U-C<)+RH@<F5S=&%R="!K97D)"0D)*B\*(V5N9&EF"B-I9FYD968@2T59
M7U)%4U5-10HC9&5F:6YE($M%65]215-5344),#4W,`DO*B!R97-U;64@:V5Y
M"0D)"2HO"B-E;F1I9@HC:69N9&5F($M%65]3059%"B-D969I;F4@2T597U-!
M5D4),#4W,0DO*B!S879E(&ME>0D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?
M4T)%1PHC9&5F:6YE($M%65]30D5'"3`U-S()+RH@<VAI9G1E9"!B96=I;FYI
M;F<@:V5Y"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4T-!3D-%3`HC9&5F:6YE
M($M%65]30T%.0T5,"3`U-S,)+RH@<VAI9G1E9"!C86YC96P@:V5Y"0D)*B\*
M(V5N9&EF"B-I9FYD968@2T597U-#3TU-04Y$"B-D969I;F4@2T597U-#3TU-
M04Y$"3`U-S0)+RH@<VAI9G1E9"!C;VUM86YD(&ME>0D)"2HO"B-E;F1I9@HC
M:69N9&5F($M%65]30T]060HC9&5F:6YE($M%65]30T]060DP-3<U"2\J('-H
M:69T960@8V]P>2!K97D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4T-214%4
M10HC9&5F:6YE($M%65]30U)%051%"3`U-S8)+RH@<VAI9G1E9"!C<F5A=&4@
M:V5Y"0D)*B\*(V5N9&EF"B-I9FYD968@2T597U-$0PHC9&5F:6YE($M%65]3
M1$,)"3`U-S<)+RH@<VAI9G1E9"!D96QE=&4@8VAA<B!K97D)"2HO"B-E;F1I
M9@HC:69N9&5F($M%65]31$P*(V1E9FEN92!+15E?4T1,"0DP-C`P"2\J('-H
M:69T960@9&5L971E(&QI;F4@:V5Y"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?
M4T5,14-4"B-D969I;F4@2T597U-%3$5#5`DP-C`Q"2\J('-E;&5C="!K97D)
M"0D)*B\*(V5N9&EF"B-I9FYD968@2T597U-%3D0*(V1E9FEN92!+15E?4T5.
M1`DP-C`R"2\J('-H:69T960@96YD(&ME>0D)"2HO"B-E;F1I9@HC:69N9&5F
M($M%65]314],"B-D969I;F4@2T597U-%3TP),#8P,PDO*B!S:&EF=&5D(&-L
M96%R(&QI;F4@:V5Y"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4T58250*(V1E
M9FEN92!+15E?4T58250),#8P-`DO*B!S:&EF=&5D(&5X:70@:V5Y"0D)*B\*
M(V5N9&EF"B-I9FYD968@2T597U-&24Y$"B-D969I;F4@2T597U-&24Y$"3`V
M,#4)+RH@<VAI9G1E9"!F:6YD(&ME>0D)"2HO"B-E;F1I9@HC:69N9&5F($M%
M65]32$5,4`HC9&5F:6YE($M%65]32$5,4`DP-C`V"2\J('-H:69T960@:&5L
M<"!K97D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4TA/344*(V1E9FEN92!+
M15E?4TA/344),#8P-PDO*B!S:&EF=&5D(&AO;64@:V5Y"0D)*B\*(V5N9&EF
M"B-I9FYD968@2T597U-)0PHC9&5F:6YE($M%65]324,)"3`V,3`)+RH@<VAI
M9G1E9"!I;G!U="!K97D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4TQ%1E0*
M(V1E9FEN92!+15E?4TQ%1E0),#8Q,0DO*B!S:&EF=&5D(&QE9G0@87)R;W<@
M:V5Y"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4TU%4U-!1T4*(V1E9FEN92!+
M15E?4TU%4U-!1T4),#8Q,@DO*B!S:&EF=&5D(&UE<W-A9V4@:V5Y"0D)*B\*
M(V5N9&EF"B-I9FYD968@2T597U--3U9%"B-D969I;F4@2T597U--3U9%"3`V
M,3,)+RH@<VAI9G1E9"!M;W9E(&ME>0D)"2HO"B-E;F1I9@HC:69N9&5F($M%
M65]33D585`HC9&5F:6YE($M%65]33D585`DP-C$T"2\J('-H:69T960@;F5X
M="!K97D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4T]05$E/3E,*(V1E9FEN
M92!+15E?4T]05$E/3E,),#8Q-0DO*B!S:&EF=&5D(&]P=&EO;G,@:V5Y"0D)
M*B\*(V5N9&EF"B-I9FYD968@2T597U-04D5624]54PHC9&5F:6YE($M%65]3
M4%)%5DE/55,),#8Q-@DO*B!S:&EF=&5D('!R978@:V5Y"0D)*B\*(V5N9&EF
M"B-I9FYD968@2T597U-04DE.5`HC9&5F:6YE($M%65]34%))3E0),#8Q-PDO
M*B!S:&EF=&5D('!R:6YT(&ME>0D)"2HO"B-E;F1I9@HC:69N9&5F($M%65]3
M4D5$3PHC9&5F:6YE($M%65]34D5$3PDP-C(P"2\J('-H:69T960@<F5D;R!K
M97D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4U)%4$Q!0T4*(V1E9FEN92!+
M15E?4U)%4$Q!0T4),#8R,0DO*B!S:&EF=&5D(')E<&QA8V4@:V5Y"0D)*B\*
M(V5N9&EF"B-I9FYD968@2T597U-224=(5`HC9&5F:6YE($M%65]34DE'2%0)
M,#8R,@DO*B!S:&EF=&5D(')I9VAT(&%R<F]W"0D)*B\*(V5N9&EF"B-I9FYD
M968@2T597U-24U5-10HC9&5F:6YE($M%65]34E-5344),#8R,PDO*B!S:&EF
M=&5D(')E<W5M92!K97D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4U-!5D4*
M(V1E9FEN92!+15E?4U-!5D4),#8R-`DO*B!S:&EF=&5D('-A=F4@:V5Y"0D)
M*B\*(V5N9&EF"B-I9FYD968@2T597U-355-014Y$"B-D969I;F4@2T597U-3
M55-014Y$"3`V,C4)+RH@<VAI9G1E9"!S=7-P96YD(&ME>0D)"2HO"B-E;F1I
M9@HC:69N9&5F($M%65]354Y$3PHC9&5F:6YE($M%65]354Y$3PDP-C(V"2\J
M('-H:69T960@=6YD;R!K97D)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4U53
M4$5.1`HC9&5F:6YE($M%65]355-014Y$"3`V,C<)+RH@<W5S<&5N9"!K97D)
M"0D)*B\*(V5N9&EF"B-I9FYD968@2T597U5.1$\*(V1E9FEN92!+15E?54Y$
M3PDP-C,P"2\J('5N9&\@:V5Y"0D)"2HO"B-E;F1I9@HC:69N9&5F($M%65]-
M05@*(V1E9FEN92!+15E?34%8"0DP-S<W"2\J($UA>&EM=6T@8W5R<V5S(&ME
M>0D)"2HO"B-E;F1I9@HC:69N9&5F($%?05144DE"551%4PHC9&5F:6YE($%?
M05144DE"551%4R`@("`P>&9F9F9F9C`P"B-E;F1I9@HC:69N9&5F($%?3D]2
M34%,"B-D969I;F4@05].3U)-04P@("`@("`@(#!X,#`P,#`P,#`*(V5N9&EF
M"B-I9FYD968@05]35$%.1$]55`HC9&5F:6YE($%?4U1!3D1/550@("`@("`P
M>#`P,#$P,#`P"B-E;F1I9@HC:69N9&5F($%?54Y$15),24Y%"B-D969I;F4@
M05]53D1%4DQ)3D4@("`@(#!X,#`P,C`P,#`*(V5N9&EF"B-I9FYD968@05]2
M159%4E-%"B-D969I;F4@05]2159%4E-%("`@("`@(#!X,#`P-#`P,#`*(V5N
M9&EF"B-I9FYD968@05]"3$E.2PHC9&5F:6YE($%?0DQ)3DL@("`@("`@("`P
M>#`P,#@P,#`P"B-E;F1I9@HC:69N9&5F($%?1$E-"B-D969I;F4@05]$24T@
M("`@("`@("`@(#!X,#`Q,#`P,#`*(V5N9&EF"B-I9FYD968@05]"3TQ$"B-D
M969I;F4@05]"3TQ$("`@("`@("`@(#!X,#`R,#`P,#`*(V5N9&EF"B-I9FYD
M968@05]!3%1#2$%24T54"B-D969I;F4@05]!3%1#2$%24T54("`@(#!X,#`T
M,#`P,#`*(V5N9&EF"B-I9FYD968@05])3E9)4PHC9&5F:6YE($%?24Y625,@
M("`@("`@("`P>#`P.#`P,#`P"B-E;F1I9@HC:69N9&5F($%?4%)/5$5#5`HC
M9&5F:6YE($%?4%)/5$5#5"`@("`@("`P>#`Q,#`P,#`P"B-E;F1I9@HC:69N
M9&5F($%?0TA!4E1%6%0*(V1E9FEN92!!7T-(05)415A4("`@("`@,'@P,#`P
M,#!F9@HC96YD:68*(VEF;F1E9B!!7T-/3$]2"B-D969I;F4@05]#3TQ/4B`@
M("`@("`@(#!X,#`P,&9F,#`*(V5N9&EF"B-I9FYD968@2T597TU)3@HC9&5F
M:6YE($M%65]-24X)"3`T,#$)+RH@36EN:6UU;2!C=7)S97,@:V5Y"0D)*B\*
M(V5N9&EF"B-I9FYD968@2T597T)214%+"B-D969I;F4@2T597T)214%+("`@
M("`@(#`T,#$)+RH@8G)E86L@:V5Y("AU;G)E;&EA8FQE*0D)*B\*(V5N9&EF
M"B-I9FYD968@2T597T1/5TX*(V1E9FEN92!+15E?1$]73B`@("`@("`@,#0P
M,@DO*B!4:&4@9F]U<B!A<G)O=R!K97ES("XN+@D)*B\*(V5N9&EF"B-I9FYD
M968@2T597U50"B-D969I;F4@2T597U50("`@("`@("`@(#`T,#,*(V5N9&EF
M"B-I9FYD968@2T597TQ%1E0*(V1E9FEN92!+15E?3$5&5"`@("`@("`@,#0P
M-`HC96YD:68*(VEF;F1E9B!+15E?4DE'2%0*(V1E9FEN92!+15E?4DE'2%0@
M("`@("`@,#0P-0DO*B`N+BX@*B\*(V5N9&EF"B-I9FYD968@2T597TA/344*
M(V1E9FEN92!+15E?2$]-12`@("`@("`@,#0P-@DO*B!(;VUE(&ME>2`H=7!W
M87)D*VQE9G0@87)R;W<I"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?0D%#2U-0
M04-%"B-D969I;F4@2T597T)!0TM34$%#12`@(#`T,#<)+RH@8F%C:W-P86-E
M("AU;G)E;&EA8FQE*0D)*B\*(V5N9&EF"B-I9FYD968@2T597T8P"B-D969I
M;F4@2T597T8P("`@("`@("`@(#`T,3`)+RH@1G5N8W1I;VX@:V5Y<RX@(%-P
M86-E(&9O<B`V-`D)*B\*(V5N9&EF"B-I9FYD968@2T597T8Q"B-D969I;F4@
M2T597T8Q("`@("`@("`@(#`T,3$*(V5N9&EF"B-I9FYD968@2T597T8R"B-D
M969I;F4@2T597T8R("`@("`@("`@(#`T,3(*(V5N9&EF"B-I9FYD968@2T59
M7T8S"B-D969I;F4@2T597T8S("`@("`@("`@(#`T,3,*(V5N9&EF"B-I9FYD
M968@2T597T8T"B-D969I;F4@2T597T8T("`@("`@("`@(#`T,30*(V5N9&EF
M"B-I9FYD968@2T597T8U"B-D969I;F4@2T597T8U("`@("`@("`@(#`T,34*
M(V5N9&EF"B-I9FYD968@2T597T8V"B-D969I;F4@2T597T8V("`@("`@("`@
M(#`T,38*(V5N9&EF"B-I9FYD968@2T597T8W"B-D969I;F4@2T597T8W("`@
M("`@("`@(#`T,3<*(V5N9&EF"B-I9FYD968@2T597T8X"B-D969I;F4@2T59
M7T8X("`@("`@("`@(#`T,3@*(V5N9&EF"B-I9FYD968@2T597T8Y"B-D969I
M;F4@2T597T8Y("`@("`@("`@(#`T,3D*(V5N9&EF"B-I9FYD968@2T597T8Q
M,`HC9&5F:6YE($M%65]&,3`)"3`T,C`*(V5N9&EF"B-I9FYD968@2T597T8Q
M,0HC9&5F:6YE($M%65]&,3$)"3`T,C$*(V5N9&EF"B-I9FYD968@2T597T8Q
M,@HC9&5F:6YE($M%65]&,3()"3`T,C(*(V5N9&EF"B-I9FYD968@2T597T1,
M"B-D969I;F4@2T597T1,("`@("`@("`@(#`U,3`)+RH@1&5L971E(&QI;F4)
M"0D)*B\*(V5N9&EF"B-I9FYD968@2T597TE,"B-D969I;F4@2T597TE,("`@
M("`@("`@(#`U,3$)+RH@26YS97)T(&QI;F4)"0D)*B\*(V5N9&EF"B-I9FYD
M968@2T597T1#"B-D969I;F4@2T597T1#("`@("`@("`@(#`U,3()+RH@1&5L
M971E(&-H87)A8W1E<@D)"2HO"B-E;F1I9@HC:69N9&5F($M%65])0PHC9&5F
M:6YE($M%65])0R`@("`@("`@("`P-3$S"2\J($EN<V5R="!C:&%R(&]R(&5N
M=&5R(&EN<V5R="!M;V1E"2HO"B-E;F1I9@HC:69N9&5F($M%65]%24,*(V1E
M9FEN92!+15E?14E#("`@("`@("`@,#4Q-`DO*B!%>&ET(&EN<V5R="!C:&%R
M(&UO9&4)"2HO"B-E;F1I9@HC:69N9&5F($M%65]#3$5!4@HC9&5F:6YE($M%
M65]#3$5!4B`@("`@("`P-3$U"2\J($-L96%R('-C<F5E;@D)"0DJ+PHC96YD
M:68*(VEF;F1E9B!+15E?14]3"B-D969I;F4@2T597T5/4R`@("`@("`@(#`U
M,38)+RH@0VQE87(@=&\@96YD(&]F('-C<F5E;@D)*B\*(V5N9&EF"B-I9FYD
M968@2T597T5/3`HC9&5F:6YE($M%65]%3TP@("`@("`@("`P-3$W"2\J($-L
M96%R('1O(&5N9"!O9B!L:6YE"0D)*B\*(V5N9&EF"B-I9FYD968@2T597U-&
M"B-D969I;F4@2T597U-&("`@("`@("`@(#`U,C`)+RH@4V-R;VQL(#$@;&EN
M92!F;W)W87)D"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?4U(*(V1E9FEN92!+
M15E?4U(@("`@("`@("`@,#4R,0DO*B!38W)O;&P@,2!L:6YE(&)A8VMW87)D
M<R`H<F5V97)S92D)*B\*(V5N9&EF"B-I9FYD968@2T597TY004=%"B-D969I
M;F4@2T597TY004=%("`@("`@(#`U,C()+RH@3F5X="!P86=E"0D)"2HO"B-E
M;F1I9@HC:69N9&5F($M%65]04$%'10HC9&5F:6YE($M%65]04$%'12`@("`@
M("`P-3(S"2\J(%!R979I;W5S('!A9V4)"0DJ+PHC96YD:68*(VEF;F1E9B!+
M15E?4U1!0@HC9&5F:6YE($M%65]35$%"("`@("`@("`P-3(T"2\J(%-E="!T
M86()"0D)*B\*(V5N9&EF"B-I9FYD968@2T597T-404(*(V1E9FEN92!+15E?
M0U1!0B`@("`@("`@,#4R-0DO*B!#;&5A<B!T86()"0D)*B\*(V5N9&EF"B-I
M9FYD968@2T597T-!5$%""B-D969I;F4@2T597T-!5$%"("`@("`@(#`U,C8)
M+RH@0VQE87(@86QL('1A8G,)"0DJ+PHC96YD:68*(VEF;F1E9B!+15E?14Y4
M15(*(V1E9FEN92!+15E?14Y415(@("`@("`@,#4R-PDO*B!%;G1E<B!O<B!S
M96YD("AU;G)E;&EA8FQE*0D)*B\*(V5N9&EF"B-I9FYD968@2T597U-215-%
M5`HC9&5F:6YE($M%65]34D53150@("`@("`P-3,P"2\J('-O9G0@*'!A<G1I
M86PI(')E<V5T("AU;G)E;&EA8FQE*0DJ+PHC96YD:68*(VEF;F1E9B!+15E?
M4D53150*(V1E9FEN92!+15E?4D53150@("`@("`@,#4S,0DO*B!R97-E="!O
M<B!H87)D(')E<V5T("AU;G)E;&EA8FQE*0DJ+PHC96YD:68*(VEF;F1E9B!+
M15E?4%))3E0*(V1E9FEN92!+15E?4%))3E0@("`@("`@,#4S,@DO*B!P<FEN
M="!O<B!C;W!Y"0D)*B\*(V5N9&EF"B-I9FYD968@2T597TQ,"B-D969I;F4@
M2T597TQ,("`@("`@("`@(#`U,S,)+RH@:&]M92!D;W=N(&]R(&)O='1O;2`H
M;&]W97(@;&5F="D)*B\*(V5N9&EF"@HO*@H@*B!3;VUE('-Y<W1E;7,@*&QI
M:V4@04E8(#XZ?"`I(&1O;B=T(&AA=F4@<')E9&5F:6YE9"!I=&5M<PH@*B!L
M:6ME($%#4U\J('-O($D@:&%V92!T;R`G9F%K92<@=&AE;2!H97)E+@HJ+PHC
M:69N9&5F($%#4U](3$E.10HC9&5F:6YE"4%#4U](3$E.10DG+2<*(V5N9&EF
M"B-I9FYD968@04-37U9,24Y%"B-D969I;F4)04-37U9,24Y%"2=\)PHC96YD
M:68*(VEF;F1E9B!!0U-?54Q#3U).15(*(V1E9FEN90E!0U-?54Q#3U).15()
M)RLG"B-E;F1I9@HC:69N9&5F($%#4U]54D-/4DY%4@HC9&5F:6YE"4%#4U]5
M4D-/4DY%4@DG*R<*(V5N9&EF"B-I9FYD968@04-37TQ,0T]23D52"B-D969I
M;F4)04-37TQ,0T]23D52"2<K)PHC96YD:68*(VEF;F1E9B!!0U-?3%)#3U).
M15(*(V1E9FEN90E!0U-?3%)#3U).15())RLG"B-E;F1I9@HC:69N9&5F($%#
M4U],5$5%"B-D969I;F4)04-37TQ4144))RLG"B-E;F1I9@HC:69N9&5F($%#
M4U]25$5%"B-D969I;F4)04-37U)4144))RLG"B-E;F1I9@HC:69N9&5F($%#
M4U]45$5%"B-D969I;F4)04-37U14144))RLG"B-E;F1I9@HC:69N9&5F($%#
M4U]"5$5%"B-D969I;F4)04-37T)4144))RLG"B-E;F1I9@HC:69N9&5F($%#
M4U]03%53"B-D969I;F4)04-37U!,55,))RLG"B-E;F1I9@HC96YD:68@+RH@
,0U521$5&7T@@*B\*
`
end
SHAR_EOF
  echo 'uudecoding file curdefs.h' &&
  uudecode _sharuue.tmp < _sharuue.tmp && rm -f _sharuue.tmp &&
  $shar_touch -am 0503190996 'curdefs.h' &&
  chmod 0444 'curdefs.h' ||
  echo 'restore of curdefs.h failed'
  shar_count="`wc -c < 'curdefs.h'`"
  test 10047 -eq "$shar_count" ||
    echo "curdefs.h: original size 10047, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= debug.c ==============
if test -f 'debug.c' && test X"$1" != X"-c"; then
  echo 'x - skipping debug.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting debug.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'debug.c' &&
#include "cdk.h"
X
/*
X * $Author: glover $
X * $Date: 1995/12/10 02:12:36 $
X * $Revision: 1.5 $
X */
X
/*
X * This starts debugging for CDK.
X */
FILE *startCDKDebug (char *filename)
{
X   char *defFile	= "cdkdebug.log";
X
X   /* Check if the filename is NULL.		*/
X   if (filename == (char *)NULL)
X   {
X      filename = defFile;
X   }
X
X   /* Try to open the file.			*/
X   return ( fopen (filename, "w") );
}
X
/*
X * This writes a message to the debug file.
X */
void writeCDKDebugMessage (FILE *fd, char *filename, char *function, int line, char *message)
{
X   /* Print the message as long as the file descr. is not NULL.	*/
X   if (fd != NULL)
X   {
X      fprintf (fd, "%s::%s (Line %d) %s\n", filename, function, line, message);
X   }
}
X
/*
X * This turns off the debugging for CDK.
X */
void stopCDKDebug (FILE *fd)
{
X   if (fd != NULL)
X   {
X      fclose (fd);
X   }
}
SHAR_EOF
  $shar_touch -am 0503190896 'debug.c' &&
  chmod 0444 'debug.c' ||
  echo 'restore of debug.c failed'
  shar_count="`wc -c < 'debug.c'`"
  test 854 -eq "$shar_count" ||
    echo "debug.c: original size 854, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= demo/fileview.c ==============
if test ! -d 'demo'; then
  echo 'x - creating directory demo'
  mkdir 'demo'
fi
if test -f 'demo/fileview.c' && test X"$1" != X"-c"; then
  echo 'x - skipping demo/fileview.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting demo/fileview.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'demo/fileview.c' &&
#include "cdk.h"
X
/*
X * Written by:	Mike Glover
X * Purpose:
X *		This uses the fselect and viewer widgets to create
X * a very basic file viewer.
X */
X
#define	MAXINFOLINES	10000
X
void main(int argc, char **argv)
{
X   /* Declare variables.					*/
X   CDKSCREEN	*cdkscreen;
X   CDKVIEWER	*example;
X   CDKFSELECT	*fileSelector;
X   WINDOW	*cursesWin;
X   char		*filename;
X   char		*info[MAXINFOLINES];
X   char		*button[2];
X   char		title[500];
X   int		selected;
X   int		lines;
X   int		x;
X
X   /* Create the viewer buttons.				*/
X   button[0]	= "</5><<OK>><!5>";
X
X   /* Set up CDK 						*/ 
X   cursesWin = initscr();
X   cdkscreen = initCDKScreen (cursesWin);
X
X   /* Start color.						*/
X   initCDKColor();
X
X   /* Get the filename.						*/
X   fileSelector = newCDKFselect (cdkscreen, CENTER, CENTER, 20, 55,
X			A_NORMAL, '.', COLOR_PAIR(48)|A_REVERSE,
X			"</5>", "</48>", "</N>", "</N>",
X			TRUE, FALSE);
X 
X   /* Activate the file selector.				*/
X   filename = activateCDKFselect (fileSelector);
X
X   /* Check if the value was NULL.				*/
X   if (filename == (char *)NULL)
X   {
X      /* Exit CDK.						*/
X      destroyCDKFselect (fileSelector);
X      destroyCDKScreen (cdkscreen);
X      endCDK();
X
X      /* Print out a message and exit.				*/
X      printf ("No file selected.\n");
X      exit (0);
X   }
X
X   /* Create the viewer.					*/
X   example = newCDKViewer (cdkscreen, CENTER, CENTER, 20, 70,
X				button, 1, A_REVERSE, TRUE, FALSE);
X
X   /* Is the viewer pointer NULL??				*/
X   if (example == (CDKVIEWER *)NULL)
X   {
X      /* Exit CDK.						*/
X      destroyCDKFselect (fileSelector);
X      destroyCDKScreen (cdkscreen);
X      endCDK();
X
X      /* Print out a message and exit.				*/
X      printf ("Oops. Can't seem to create viewer. Is the window too small?\n");
X      exit (0);
X   }
X
X   /* Set up the info.						*/
X   lines = readFile (filename, info, MAXINFOLINES);
X   if (lines == 0)
X   {
X      printf ("Could not open %s\n", filename);
X      exit (1);
X   }
X
X   /* Make it run...						*/
X   sprintf (title, "<C></B/21>Filename:<!21></22>%20s<!22!B>", filename);
X   setCDKViewer (example, title, info, lines,
X			COLOR_PAIR(21)|A_REVERSE, TRUE, TRUE);
X   selected = activateCDKViewer (example);
X
X   /* Clean up.							*/
X   destroyCDKViewer (example);
X   destroyCDKFselect (fileSelector);
X   destroyCDKScreen (cdkscreen);
X   delwin (cursesWin);
X   endCDK();
X   for (x=0; x < lines; x++)
X   {
X      freeChar (info[x]);
X   }
X
X   /* Spit out some info.					*/
X   printf ("\n\n\n\n");
X   printf ("You picked button %d\n", selected);
}
SHAR_EOF
  $shar_touch -am 0503190996 'demo/fileview.c' &&
  chmod 0444 'demo/fileview.c' ||
  echo 'restore of demo/fileview.c failed'
  shar_count="`wc -c < 'demo/fileview.c'`"
  test 2521 -eq "$shar_count" ||
    echo "demo/fileview.c: original size 2521, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= demo/rolodex.c ==============
if test -f 'demo/rolodex.c' && test X"$1" != X"-c"; then
  echo 'x - skipping demo/rolodex.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting demo/rolodex.c (binary)'
  sed 's/^X//' << 'SHAR_EOF' > _sharuue.tmp &&
begin 600 demo/rolodex.c
SHAR_EOF
  : || echo 'restore of demo/rolodex.c failed'
fi
echo 'End of archive part 2'
echo 'File demo/rolodex.c is continued in part 3'
echo 3 > _sharseq.tmp
exit 0
