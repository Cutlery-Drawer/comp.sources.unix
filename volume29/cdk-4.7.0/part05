Newsgroups: comp.sources.unix
From: glover@credit.erin.utoronto.ca (Mike Glover)
Subject: v29i109: cdk-4.7.0 - Curses Development Kit, V4.7.0, Part05/10
References: <1.833427459.28242@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: glover@credit.erin.utoronto.ca (Mike Glover)
Posting-Number: Volume 29, Issue 109
Archive-Name: cdk-4.7.0/part05

#!/bin/sh
# This is `cdk_part.05' (part 5 of a multipart archive).
# Do not concatenate these parts, unpack them in order with `/bin/sh'.
# File `fselect.c' is being continued...
#
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  echo 'WARNING: not restoring timestamps.  Consider getting and'
  echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if test ! -r _sharseq.tmp; then
  echo 'Please unpack part 1 first!'
  exit 1
fi
shar_sequence=`cat _sharseq.tmp`
if test "$shar_sequence" != 5; then
  echo "Please unpack part $shar_sequence next!"
  exit 1
fi
if test ! -f _sharnew.tmp; then
  echo 'x - still skipping fselect.c'
else
  echo 'x - continuing file fselect.c'
  sed 's/^X//' << 'SHAR_EOF' >> '_sharuue.tmp' &&
M=$-$2T9S96QE8W0@*$-$2T9314Q%0U0@*F9S96QE8W0L(&-H87(@*F1I<F5C
M=&]R>2P@8VAT>7!E(&9I96QD071T<FEB+"!C:'1Y<&4@9FEL;&5R+"!C:'1Y
M<&4@:&EG:&QI9VAT+"!C:&%R("ID:7)!='1R:6)U=&4L(&-H87(@*F9I;&5!
M='1R:6)U=&4L(&-H87(@*FQI;FM!='1R:6)U=&4L(&-H87(@*G-O8VM!='1R
M:6)U=&4L(&)O;VQE86X@8F]X*0I["B`@("\J($1E8VQA<F4@;&]C86P@=F%R
M:6%B;&5S+@D)"0D)"2HO"B`@($-$2U-#4D],3"`J9G-C<F]L;"`](&9S96QE
M8W0M/F9I;&5,:7-T.PH@("!#1$M%3E1262`J9F5N=')Y(#T@9G-E;&5C="T^
M9FEL96YA;64["B`@(&-H87(@*FUE<V=;,3!=+"!T96UP6S$P,%T["@H@("`O
M*B!+965P('1H92!I;F9O('-E;G0@=&\@=7,N"0D)"0D)*B\*("`@9G-E;&5C
M="T^9FEE;&1!='1R:6)U=&4@/2!F:65L9$%T=')I8CL*("`@9G-E;&5C="T^
M9FEL;&5R0VAA<F%C=&5R(#T@9FEL;&5R.PH@("!F<V5L96-T+3YH:6=H;&EG
M:'0@/2!H:6=H;&EG:'0["@H@("`O*B!#:&%N9V4@9&ER96-T;W)I97,N"0D)
M"0D)*B\*("`@:68@*&-H9&ER("AD:7)E8W1O<GDI*0H@("!["B`@("`@("\J
M($)E97`@870@=&AE;2X)"0D)"0D)*B\*("`@("`@0F5E<"@I.PH*("`@("`@
M+RH@0V]U;&1N)W0@9V5T(&EN=&\@=&AE(&1I<F5C=&]R>2P@<&]P('5P(&$@
M;&ET=&QE(&UE<W-A9V4N"2HO"B`@("`@('-P<FEN=&8@*'1E;7`L("(\0SY#
M;W5L9"!N;W0@8VAA;F=E(&EN=&\@)7,B+"!D:7)E8W1O<GDI.PH@("`@("!M
M97-G6S!=(#T@8V]P>4-H87(@*'1E;7`I.PH*(VEF9&5F($Y/4U1215)2"B`@
M("`@('-P<FEN=&8@*'1E;7`L("(\0SX\+U4^56YK;F]W;B!R96%S;VXN(BD[
M"B`@("`@(&UE<V=;,5T@/2!C;W!Y0VAA<B`H=&5M<"D["B-E;'-E"B`@("`@
M('-P<FEN=&8@*'1E;7`L("(\0SX\+U4^)7,B+"!S=')E<G)O<BAE<G)N;RDI
M.PH@("`@("!M97-G6S%=(#T@8V]P>4-H87(@*'1E;7`I.PHC96YD:68*"B`@
M("`@(&UE<V=;,ET@/2`B("(["B`@("`@(&UE<V=;,UT@/2`B/$,^4')E<W,@
M06YY($ME>2!4;R!#;VYT:6YU92XB.PH@("`@("`*("`@("`@+RH@4&]P(%5P
M(&$@;65S<V%G92X)"0D)"0DJ+PH@("`@("!P;W!U<$UE<W-A9V4@*&9S96QE
M8W0M/G-C<F5E;BP@;65S9RP@-"D["@H@("`@("`O*B!#;&5A;B!U<"!S;VUE
M(&UE;6]R>2X)"0D)"0DJ+PH@("`@("!F<F5E0VAA<B`H;65S9ULP72D["B`@
M("`@(&9R965#:&%R("AM97-G6S%=*3L*"B`@("`@("\J($=E="!O=70@;V8@
M:&5R92XN+@D)"0D)"2HO"B`@("`@(')E='5R;CL*("`@?0H*("`@+RH*("`@
M("H@268@=&AE(&EN9F]R;6%T:6]N(&-O;6EN9R!I;B!I<R!T:&4@<V%M92!A
M<R!T:&4@:6YF;W)M871I;VX*("`@("H@=&AA="!I<R!A;')E861Y('1H97)E
M+"!T:&5R92!I<R!N;R!N965D('1O(&1E<W1R;WD@:70N"B`@("`J+PH@("!I
M9B`H9G-E;&5C="T^<'=D("$](&1I<F5C=&]R>2D*("`@>PH@("`@("`O*B!2
M96UO=F4@=&AE(&]L9"!P;VEN=&5R"6%N9"!S970@=&AE(&YE=R!V86QU92X)
M"0DJ+PH@("`@("!F<F5E0VAA<B`H9G-E;&5C="T^<'=D*3L*("`@("`@9G-E
M;&5C="T^<'=D(#T@9V5T8W=D("A.54Q,+"`U,3(I.PH@("!]"B`@(&EF("AF
M<V5L96-T+3YF:6QE071T<FEB=71E("$](&9I;&5!='1R:6)U=&4I"B`@('L*
M("`@("`@+RH@4F5M;W9E('1H92!O;&0@<&]I;G1E<@EA;F0@<V5T('1H92!N
M97<@=F%L=64N"0D)*B\*("`@("`@9G)E94-H87(@*&9S96QE8W0M/F9I;&5!
M='1R:6)U=&4I.PH@("`@("!F<V5L96-T+3YF:6QE071T<FEB=71E(#T@8V]P
M>4-H87(@*&9I;&5!='1R:6)U=&4I.PH@("`@("!F<V5L96-T+3YF:6QE071T
M<FEB=71E(#T@8V]P>4-H87(@*&9I;&5!='1R:6)U=&4I.PH@("!]"B`@(&EF
M("AF<V5L96-T+3YD:7)!='1R:6)U=&4@(3T@9&ER071T<FEB=71E*0H@("![
M"B`@("`@("\J(%)E;6]V92!T:&4@;VQD('!O:6YT97()86YD('-E="!T:&4@
M;F5W('9A;'5E+@D)"2HO"B`@("`@(&9R965#:&%R("AF<V5L96-T+3YD:7)!
M='1R:6)U=&4I.PH@("`@("!F<V5L96-T+3YD:7)!='1R:6)U=&4@/2!C;W!Y
M0VAA<B`H9&ER071T<FEB=71E*3L*("`@?0H@("!I9B`H9G-E;&5C="T^;&EN
M:T%T=')I8G5T92`A/2!L:6YK071T<FEB=71E*0H@("!["B`@("`@("\J(%)E
M;6]V92!T:&4@;VQD('!O:6YT97()86YD('-E="!T:&4@;F5W('9A;'5E+@D)
M"2HO"B`@("`@(&9R965#:&%R("AF<V5L96-T+3YL:6YK071T<FEB=71E*3L*
M("`@("`@9G-E;&5C="T^;&EN:T%T=')I8G5T92`](&-O<'E#:&%R("AL:6YK
M071T<FEB=71E*3L*("`@?0H@("!I9B`H9G-E;&5C="T^<V]C:T%T=')I8G5T
M92`A/2!S;V-K071T<FEB=71E*0H@("!["B`@("`@("\J(%)E;6]V92!T:&4@
M;VQD('!O:6YT97()86YD('-E="!T:&4@;F5W('9A;'5E+@D)"2HO"B`@("`@
M(&9R965#:&%R("AF<V5L96-T+3YS;V-K071T<FEB=71E*3L*("`@("`@9G-E
M;&5C="T^<V]C:T%T=')I8G5T92`](&-O<'E#:&%R("AS;V-K071T<FEB=71E
M*3L*("`@?0H@("`*("`@+RH@4V5T('1H92!C;VYT96YT<R!O9B!T:&4@96YT
M<GD@9FEE;&0N"0D)"2HO"B`@('-E=$-$2T5N=')Y("AF96YT<GDL(&9S96QE
M8W0M/G!W9"P@,"P@-3$R+"!F96YT<GDM/F)O>"D["B`@(&1R87=#1$M%;G1R
M>2`H9F5N=')Y+"!F96YT<GDM/F)O>"D["@H@("`O*B!'970@=&AE(&1I<F5C
M=&]R>2!C;VYT96YT<RX)"0D)"2HO"B`@(&=E=$1I<D-O;G1E;G1S("AF<V5L
M96-T*3L*"B`@("\J(%-E="!T:&4@=F%L=65S(&EN('1H92!S8W)O;&QI;F<@
M;&ES="X)"0D)*B\*("`@<V5T0T1+4V-R;VQL("AF<V-R;VQL+`H)"69S96QE
M8W0M/F1I<D-O;G1E;G1S+"!F<V5L96-T+3YF:6QE0V]U;G1E<BP*"0E&04Q3
M12P@9G-C<F]L;"T^:&EG:&QI9VAT+"!F<V-R;VQL+3YB;W@I.PI]"@HO*@H@
M*B!4:&ES(&1E<W1R;WES('1H92!F:6QE('-E;&5C=&]R+@D*("HO"G9O:60@
M9&5S=')O>4-$2T9S96QE8W0@*$-$2T9314Q%0U0@*F9S96QE8W0I"GL*("`@
M:6YT('@["@H@("`O*B!%<F%S92!T:&4@9FEL92!S96QE8W1O<BX)"0D)"0DJ
M+PH@("!E<F%S94-$2T9S96QE8W0@*&9S96QE8W0I.PH*("`@+RH@1G)E92!U
M<"!T:&4@8VAA<F%C=&5R('!O:6YT97)S+@D)"0D)*B\*("`@9G)E94-H87(@
M*&9S96QE8W0M/G!W9"D["B`@(&9R965#:&%R("AF<V5L96-T+3YP871H;F%M
M92D["B`@(&9R965#:&%R("AF<V5L96-T+3YD:7)!='1R:6)U=&4I.PH@("!F
M<F5E0VAA<B`H9G-E;&5C="T^9FEL94%T=')I8G5T92D["B`@(&9R965#:&%R
M("AF<V5L96-T+3YL:6YK071T<FEB=71E*3L*("`@9G)E94-H87(@*&9S96QE
M8W0M/G-O8VM!='1R:6)U=&4I.PH@("!F;W(@*'@],#L@>"`\(&9S96QE8W0M
M/F9I;&5#;W5N=&5R.R!X*RLI"B`@('L*("`@("`@9G)E94-H87(@*&9S96QE
M8W0M/F1I<D-O;G1E;G1S6WA=*3L*("`@?0H*("`@+RH@1G)E92!U<"!T:&4@
M=VEN9&]W('!O:6YT97)S+B`)"0D)"2HO"B`@(&EF("AF<V5L96-T+3YS:&%D
M;W<I"B`@('L*("`@("`@9&5L=VEN("AF<V5L96-T+3YS:&%D;W=7:6XI.PH@
M("!]"B`@(&1E;'=I;B`H9G-E;&5C="T^=VEN*3L*"B`@("\J($1E<W1R;WD@
M=&AE(&]T:&5R($-D:R!O8FIE8W1S+@D)"0D)*B\*("`@9&5S=')O>4-$2T5N
M=')Y("AF<V5L96-T+3YF:6QE;F%M92D["B`@(&1E<W1R;WE#1$M38W)O;&P@
M*&9S96QE8W0M/F9I;&5,:7-T*3L*(`H@("`O*B!5;G)E9VES=&5R('1H92!O
M8FIE8W0N"0D)"0D)*B\*("`@=6YR96=I<W1E<D-$2T]B:F5C="`H=D9314Q%
M0U0L(&9S96QE8W0I.PH*("`@+RH@1G)E92!U<"!T:&4@;V)J96-T('!O:6YT
M97(N"0D)"0DJ+PH@("!F<F5E("AF<V5L96-T*3L*?0H*+RH*("HJ*BHJ*BHJ
M*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ"B`J($-A;&QB86-K(&9U;F-T:6]N
M<RX*("HJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ"B`J+PH*+RH@
M"B`J(%1H:7,@:7,@82!C86QL8F%C:R!T;R!T:&4@<V-R;VQL:6YG(&QI<W0@
M=VAI8V@@9&ES<&QA>7,@:6YF;W)M871I;VX*("H@86)O=70@=&AE(&-U<G)E
M;G0@9FEL92X@*&%N9"!T:&4@=VAO;&4@9&ER96-T;W)Y(&%S('=E;&PI"B`J
M+PIV;VED(&1I<W!L87E&:6QE:6YF;R`H14]B:F5C=%1Y<&4@;V)J96-T5'EP
M92P@=F]I9"`J;V)J96-T+"!V;VED("IC;&EE;G1$871A*0I["B`@("\J($1E
M8VQA<F4@;&]C86P@=F%R:6%B;&5S+@D)"0D)"2HO"B`@($-$2U-#4D],3`D)
M*F9S8W)O;&P)/2`H0T1+4T-23TQ,("HI;V)J96-T.PH@("!#1$M&4T5,14-4
M"0DJ9G-E;&5C=`D]("A#1$M&4T5,14-4("HI8VQI96YT1&%T83L*("`@0T1+
M3$%"14P)"2II;F9O3&%B96P["B`@('-T<G5C="!S=&%T"0EF:6QE4W1A=#L*
M("`@<W1R=6-T('!A<W-W9`DJ<'=%;G0["B`@('-T<G5C="!G<F]U<`D)*F=R
M16YT.PH@("!C:&%R"0D)*F9I;&5N86UE.PH@("!C:&%R"0D)*F9I;&5T>7!E
M.PH@("!C:&%R(`D)*FUE<V=;,3!=.PH@("!C:&%R"0D)=&5M<%LQ,#!=.PH@
M("!C:&%R"0D)<W1R:6YG36]D95LQ-5T["B`@(&EN=`D)"6QE;CL*("`@:6YT
M"0D):6YT36]D93L*"B`@("\J($=E="!T:&4@9FEL92!N86UE+@D)"0D)"2HO
M"B`@(&9I;&5N86UE"3T@8VAT>7!E,D-H87(@*&9S8W)O;&PM/FET96U;9G-C
M<F]L;"T^8W5R<F5N=$ET96U=*3L*("`@9FEL96YA;65;<W1R;&5N*&9I;&5N
M86UE*2TQ72`]("=<,"<["@H@("`O*B!'970@<W!E8VEF:6,@:6YF;W)M871I
M;VX@86)O=70@=&AE(&9I;&5S+@D)"0DJ+PH@("!L<W1A="`H9FEL96YA;64L
M("9F:6QE4W1A="D["B`@(`H@("`O*B!$971E<FUI;F4@=&AE(&9I;&4@='EP
M92X)"0D)"0DJ+PH@("!I9B`H4U])4TQ.2R`H9FEL95-T870N<W1?;6]D92DI
M"B`@('L*("`@("`@9FEL971Y<&4@/2`B3&EN:R(["B`@('T*("`@96QS92!I
M9B`H4U])4U-/0TL@*&9I;&53=&%T+G-T7VUO9&4I*0H@("!["B`@("`@(&9I
M;&5T>7!E(#T@(E-O8VME="(["B`@('T*("`@96QS92!I9B`H4U])4U)%1RAF
M:6QE4W1A="YS=%]M;V1E*2D*("`@>PH@("`@("!F:6QE='EP92`](")296=U
M;&%R($9I;&4B.PH@("!]"B`@(&5L<V4@:68@*%-?25-$25(H9FEL95-T870N
M<W1?;6]D92DI"B`@('L*("`@("`@9FEL971Y<&4@/2`B1&ER96-T;W)Y(CL*
M("`@?0H@("!E;'-E(&EF("A37TE30TA2*&9I;&53=&%T+G-T7VUO9&4I*0H@
M("!["B`@("`@(&9I;&5T>7!E(#T@(D-H87)A8W1E<B!$979I8V4B.PH@("!]
M"B`@(&5L<V4@:68@*%-?25-"3$LH9FEL95-T870N<W1?;6]D92DI"B`@('L*
M("`@("`@9FEL971Y<&4@/2`B0FQO8VL@1&5V:6-E(CL*("`@?0H@("!E;'-E
M(&EF("A37TE31DE&3RAF:6QE4W1A="YS=%]M;V1E*2D*("`@>PH@("`@("!F
M:6QE='EP92`](")&249/($1E=FEC92(["B`@('T*("`@96QS90H@("!["B`@
M("`@(&9I;&5T>7!E(#T@(E5N:VYO=VXB.PH@("!]"@H@("`O*B!'970@=&AE
M('5S97(@;F%M92!A;F0@9W)O=7`@;F%M92X)"0D)"2HO"B`@('!W16YT(#T@
M9V5T<'=U:60@*&9I;&53=&%T+G-T7W5I9"D["B`@(&=R16YT(#T@9V5T9W)G
M:60@*&9I;&53=&%T+G-T7V=I9"D["@H@("`O*B!#;VYV97)T('1H92!M;V1E
M7W0@='EP92!T;R!B;W1H('-T<FEN9R!A;F0@:6YT+@D)"2HO"B`@(&EN=$UO
M9&4@/2!M;V1E,D-H87(@*'-T<FEN9TUO9&4L(&9I;&53=&%T+G-T7VUO9&4I
M.PH*("`@+RH@0W)E871E('1H92!M97-S86=E+@D)"0D)"2HO"B`@('-P<FEN
M=&8@*'1E;7`L(")$:7)E8W1O<GD@(#H@/"]5/B5S(BP@9G-E;&5C="T^<'=D
M*3L*("`@;65S9ULP72`](&-O<'E#:&%R("AT96UP*3L*"B`@('-P<FEN=&8@
M*'1E;7`L(")&:6QE;F%M92`@(#H@/"]5/B5S(BP@9FEL96YA;64I.PH@("!M
M97-G6S%=(#T@8V]P>4-H87(@*'1E;7`I.PH*("`@<W!R:6YT9B`H=&5M<"P@
M(D]W;F5R("`@("`@.B`\+U4^)7,\(54^("@E9"DB+"!P=T5N="T^<'=?;F%M
M92P@9FEL95-T870N<W1?=6ED*3L*("`@;65S9ULR72`](&-O<'E#:&%R("AT
M96UP*3L*"B`@('-P<FEN=&8@*'1E;7`L(")'<F]U<"`@("`@(#H@/"]5/B5S
M/"%5/B`H)60I(BP@9W)%;G0M/F=R7VYA;64L(&9I;&53=&%T+G-T7V=I9"D[
M"B`@(&UE<V=;,UT@/2!C;W!Y0VAA<B`H=&5M<"D["@H@("!S<')I;G1F("AT
M96UP+"`B4&5R;6ES<VEO;G,Z(#PO53XE<SPA53X@*"5D*2(L('-T<FEN9TUO
M9&4L(&EN=$UO9&4I.PH@("!M97-G6S1=(#T@8V]P>4-H87(@*'1E;7`I.PH*
M("`@<W!R:6YT9B`H=&5M<"P@(E-I>F4@("`@("`@.B`\+U4^)6QD/"%5/B!B
M>71E<R(L(&9I;&53=&%T+G-T7W-I>F4I.PH@("!M97-G6S5=(#T@8V]P>4-H
M87(@*'1E;7`I.PH*("`@<W!R:6YT9B`H=&5M<"P@(DQA<W0@06-C97-S.B`\
M+U4^)7,B+"!C=&EM92`H)F9I;&53=&%T+G-T7V%T:6UE*2D["B`@(&QE;B`]
M('-T<FQE;B`H=&5M<"D["B`@('1E;7!;;&5N72`]("=<,"<[('1E;7!;;&5N
M+3%=(#T@)UPP)SL*("`@;65S9ULV72`](&-O<'E#:&%R("AT96UP*3L*"B`@
M('-P<FEN=&8@*'1E;7`L("),87-T($-H86YG93H@/"]5/B5S(BP@8W1I;64@
M*"9F:6QE4W1A="YS=%]C=&EM92DI.PH@("!L96X@/2!S=')L96X@*'1E;7`I
M.PH@("!T96UP6VQE;ET@/2`G7#`G.R!T96UP6VQE;BTQ72`]("=<,"<["B`@
M(&UE<V=;-UT@/2!C;W!Y0VAA<B`H=&5M<"D["@H@("!S<')I;G1F("AT96UP
M+"`B1FEL92!4>7!E("`Z(#PO53XE<R(L(&9I;&5T>7!E*3L*("`@;65S9ULX
M72`](&-O<'E#:&%R("AT96UP*3L*"B`@("\J($-R96%T92!T:&4@<&]P('5P
M(&QA8F5L+@D)"0D)"2HO"B`@(&EN9F],86)E;"`](&YE=T-$2TQA8F5L("AF
M<V-R;VQL+3YS8W)E96XL(`H)"4-%3E1%4BP@0T5.5$52+"`*"0EM97-G+"`Y
M+"!44E5%+"!&04Q312D["B`@(&1R87=#1$M,86)E;"`H:6YF;TQA8F5L+"!4
M4E5%*3L*("`@=V=E=&-H("AI;F9O3&%B96PM/G=I;BD["@H@("`O*B!#;&5A
M;B!U<"!S;VUE(&UE;6]R>2X)"0D)"0DJ+PH@("!D97-T<F]Y0T1+3&%B96P@
M*&EN9F],86)E;"D["B`@(&9R965#:&%R("AF:6QE;F%M92D["B`@(&9R965#
M:&%R("AM97-G6S!=*3L@9G)E94-H87(@*&UE<V=;,5TI.PH@("!F<F5E0VAA
M<B`H;65S9ULR72D[(&9R965#:&%R("AM97-G6S-=*3L*("`@9G)E94-H87(@
M*&UE<V=;-%TI.R!F<F5E0VAA<B`H;65S9ULU72D["B`@(&9R965#:&%R("AM
M97-G6S9=*3L@9G)E94-H87(@*&UE<V=;-UTI.PH@("!F<F5E0VAA<B`H;65S
M9ULX72D["@H@("`O*B!2961R87<@=&AE(&9I;&4@<V5L96-T;W(N"0D)"0D)
M*B\*("`@9')A=T-$2T9S96QE8W0@*&9S96QE8W0L(&9S96QE8W0M/F)O>"D[
M"GT*"B\J"B`J(%1H:7,@86QL;W=S('1H92!U<V5R('1O(&1E;&5T92!A(&9I
M;&4N"B`J+PIV;VED(&1E;&5T949I;&5#0B`H14]B:F5C=%1Y<&4@;V)J96-T
M5'EP92P@=F]I9"`J;V)J96-T+"!V;VED("IC;&EE;G1$871A*0I["B`@("\J
M($1E8VQA<F4@;&]C86P@=F%R:6%B;&5S+@D)"0D)"2HO"B`@($-$2U-#4D],
M3`DJ9G-C<F]L;`D]("A#1$M30U)/3$P@*BEO8FIE8W0["B`@($-$2T9314Q%
M0U0)*F9S96QE8W0)/2`H0T1+1E-%3$5#5"`J*6-L:65N=$1A=&$["B`@(&-H
M87()"2IB=71T;VYS6UT)/2![(DYO(BP@(EEE<R)].PH@("!#1$M$24%,3T<)
M*G%U97-T:6]N.PH@("!C:&%R"0DJ;65S9ULQ,%TL("IF:6QE;F%M92P@=&5M
M<%LQ,#!=.PH*("`@+RH@1V5T('1H92!F:6QE;F%M92!W:&EC:"!I<R!T;R!B
M92!D96QE=&5D+@D)"0DJ+PH@("!F:6QE;F%M92`](&-H='EP93)#:&%R("AF
M<V-R;VQL+3YI=&5M6V9S8W)O;&PM/F-U<G)E;G1)=&5M72D["B`@(&9I;&5N
M86UE6W-T<FQE;BAF:6QE;F%M92DM,5T@/2`G7#`G.PH*("`@+RH@0W)E871E
M('1H92!D:6%L;V<@;65S<V%G92X)"0D)"2HO"B`@(&UE<V=;,%T@/2`B/$,^
M07)E('EO=2!S=7)E('EO=2!W86YT('1O(&1E;&5T92!T:&4@9FEL93HB.PH@
M("!S<')I;G1F("AT96UP+"`B/$,^/"]5/B5S/R(L(&9I;&5N86UE*3L@;65S
M9ULQ72`](&-O<'E#:&%R("AT96UP*3L*"B`@("\J($-R96%T92!T:&4@9&EA
M;&]G(&)O>"X)"0D)"0DJ+PH@("!Q=65S=&EO;B`](&YE=T-$2T1I86QO9R`H
M9G-E;&5C="T^<V-R965N+"!#14Y415(L($-%3E1%4BP*"0D);65S9RP@,BP@
M8G5T=&]N<RP@,BP@05]2159%4E-%+`H)"0E44E5%+"!44E5%+"!&04Q312D[
M"@H@("`O*B!#;&5A;B!U<"!T:&ES('!O:6YT97(N("AW92!M87D@;F5E9"!I
M="!A9V%I;B!R96%L('-O;VXN*0D)*B\*("`@9G)E94-H87(@*&UE<V=;,5TI
M.PH*("`@+RH@268@=&AE('-A:60@>65S('1H96X@=')Y('1O(&YU:V4@:70N
M"0D)"2HO"B`@(&EF("AA8W1I=F%T94-$2T1I86QO9R`H<75E<W1I;VXL("AC
M:'1Y<&4@*BE.54Q,*2`]/2`Q*0H@("!["B`@("`@("\J($EF('=E('=E<F4@
M<W5C8V5S<V9U;"P@<F5L;V%D('1H92!S8W)O;&QI;F<@;&ES="X)"2HO"B`@
M("`@(&EF("AU;FQI;FL@*&9I;&5N86UE*2`]/2`P*0H@("`@("!["B`@("`@
M("`@("\J(%-E="!T:&4@9FEL92!S96QE8W1O<B!I;F9O<FUA=&EO;BX)"0D)
M*B\*("`@("`@("`@<V5T0T1+1G-E;&5C="`H9G-E;&5C="P@9G-E;&5C="T^
M<'=D+`H)"69S96QE8W0M/F9I96QD071T<FEB=71E+"!F<V5L96-T+3YF:6QL
M97)#:&%R86-T97(L(&9S96QE8W0M/FAI9VAL:6=H="P*"0EF<V5L96-T+3YD
M:7)!='1R:6)U=&4L(&9S96QE8W0M/F9I;&5!='1R:6)U=&4L(`H)"69S96QE
M8W0M/FQI;FM!='1R:6)U=&4L(&9S96QE8W0M/G-O8VM!='1R:6)U=&4L(`H)
M"69S96QE8W0M/F)O>"D["B`@("`@('T*("`@("`@96QS90H@("`@("!["B`@
M("`@("`@("\J(%!O<"!U<"!A(&UE<W-A9V4N"0D)"0D)*B\*(VEF9&5F($Y/
M4U1215)2"B`@("`@("`@('-P<FEN=&8@*'1E;7`L("(\0SY#86X@;F]T(&1E
M;&5T92!F:6QE+B!5;FMN;W=N(')E87-O;BXB*3L*(V5L<V4*("`@("`@("`@
M<W!R:6YT9B`H=&5M<"P@(CQ#/D-A;B=T(&1E;&5T92!F:6QE.B`\)7,^(BP@
M<W1R97)R;W(@*&5R<FYO*2D["B-E;F1I9@H@("`@("`@("!M97-G6S!=(#T@
M8V]P>4-H87(@*'1E;7`I.PH@("`@("`@("!M97-G6S%=(#T@(B`B.PH@("`@
M("`@("!M97-G6S)=(#T@(CQ#/E!R97-S(&%N>2!K97D@=&\@8V]N=&EN=64N
M(CL*("`@("`@("`@<&]P=7!-97-S86=E("AF<V5L96-T+3YS8W)E96XL(&UE
M<V<L(#,I.PH@("`@("`@("!F<F5E0VAA<B`H;65S9ULP72D["B`@("`@('T*
M("`@?0H*("`@+RH@0VQE86X@=7`N"0D)"0D)"0DJ+PH@("!D97-T<F]Y0T1+
M1&EA;&]G("AQ=65S=&EO;BD["@H@("`O*B!2961R87<@=&AE(&9I;&4@<V5L
M96-T;W(N"0D)"0D)*B\*("`@9')A=T-$2T9S96QE8W0@*&9S96QE8W0L(&9S
M96QE8W0M/F)O>"D["GT*"B\J"B`J(%1H:7,@9G5N8W1I;VX@<V5T<R!T:&4@
M<')E+7!R;V-E<W,@9G5N8W1I;VXN"B`J+PIV;VED('-E=$-$2T9S96QE8W10
M<F50<F]C97-S("A#1$M&4T5,14-4("IF<V5L96-T+"!04D]#15-31DX@8V%L
M;&)A8VLL('9O:60@*F1A=&$I"GL*("`@<V5T0T1+16YT<GE0<F50<F]C97-S
M("AF<V5L96-T+3YF:6QE;F%M92P@8V%L;&)A8VLL(&1A=&$I.PH@("!S971#
M1$M38W)O;&Q0<F50<F]C97-S("AF<V5L96-T+3YF:6QE3&ES="P@8V%L;&)A
M8VLL(&1A=&$I.PI]"B`*+RH*("H@5&AI<R!F=6YC=&EO;B!S971S('1H92!P
M;W-T+7!R;V-E<W,@9G5N8W1I;VXN"B`J+PIV;VED('-E=$-$2T9S96QE8W10
M;W-T4')O8V5S<R`H0T1+1E-%3$5#5"`J9G-E;&5C="P@4%)/0T534T9.(&-A
M;&QB86-K+"!V;VED("ID871A*0I["B`@('-E=$-$2T5N=')Y4&]S=%!R;V-E
M<W,@*&9S96QE8W0M/F9I;&5N86UE+"!C86QL8F%C:RP@9&%T82D["B`@('-E
M=$-$2U-C<F]L;%!O<W10<F]C97-S("AF<V5L96-T+3YF:6QE3&ES="P@8V%L
0;&)A8VLL(&1A=&$I.PI]"F]C
`
end
SHAR_EOF
  echo 'File fselect.c is complete' &&
  echo 'uudecoding file fselect.c' &&
  uudecode _sharuue.tmp < _sharuue.tmp && rm -f _sharuue.tmp &&
  $shar_touch -am 0503190896 'fselect.c' &&
  chmod 0444 'fselect.c' ||
  echo 'restore of fselect.c failed'
  shar_count="`wc -c < 'fselect.c'`"
  test 19186 -eq "$shar_count" ||
    echo "fselect.c: original size 19186, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= graph.c ==============
if test -f 'graph.c' && test X"$1" != X"-c"; then
  echo 'x - skipping graph.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting graph.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'graph.c' &&
#include "cdk.h"
X
/*
X * $Author: mikeg $
X * $Date: 1996/02/28 14:59:06 $
X * $Revision: 1.26 $
X */
X
/*
X * This creates a graph widget.
X */
CDKGRAPH *newCDKGraph (CDKSCREEN *cdkscreen, int xplace, int yplace, int height, int width, char *title, char *xtitle, char *ytitle)
{
X   /* Declare local variables.						*/
X   CDKGRAPH *graph	= (CDKGRAPH *)malloc (sizeof (CDKGRAPH));
X   int xpos		= xplace;
X   int ypos		= yplace;
X
X   /* Rejustify the x and y positions if we need to.			*/
X   alignxy (cdkscreen->window, &xpos, &ypos, width+3, height);
X
X   /* Create the graph pointer						*/
X   graph->parent	= cdkscreen->window;
X   graph->win		= newwin (height, width+3, ypos, xpos);
X   graph->boxHeight	= height;
X   graph->boxWidth	= width+3;
X   graph->box		= NOBOX;
X   graph->minx		= 0;
X   graph->maxx		= 0;
X   graph->xscale	= 0;
X   graph->yscale	= 0;
X   graph->displayType	= vLINE;
X
X   /* Is the graph pointer NULL???					*/
X   if (graph->win == (WINDOW *)NULL)
X   {
X      /* Clean up any memory used.					*/
X      free (graph);
X
X      /* Return a NULL pointer.						*/
X      return ( (CDKGRAPH *)NULL );
X   }
X
X   /* Translate the graph title char * to a chtype *			*/
X   if (title != (char *)NULL)
X   {
X      graph->title	= char2Chtype (title, &graph->titleLen, &graph->titlePos);
X      graph->titlePos	= justifyString (graph->boxWidth, graph->titleLen, graph->titlePos);
X   }
X   else
X   {
X      graph->title	= char2Chtype ("<C></5>Untitled", &graph->titleLen, &graph->titlePos);
X      graph->titlePos	= justifyString (graph->boxWidth, graph->titleLen, graph->titlePos);
X   }
X
X   /* Translate the X Axis title char * to a chtype *			*/
X   if (xtitle != (char *)NULL)
X   {
X      graph->xtitle	= char2Chtype (xtitle, &graph->xtitleLen, &graph->xtitlePos);
X      graph->xtitlePos	= justifyString (graph->boxHeight, graph->xtitleLen, graph->xtitlePos);
X   } 
X   else
X   {
X      graph->xtitle	= char2Chtype ("<C></5>X Axis", &graph->xtitleLen, &graph->xtitlePos);
X      graph->xtitlePos	= justifyString (graph->boxHeight, graph->xtitleLen, graph->xtitlePos);
X   }
X
X   /* Translate the Y Axis title char * to a chtype *			*/
X   if (ytitle != (char *)NULL)
X   {
X      graph->ytitle	= char2Chtype (ytitle, &graph->ytitleLen, &graph->ytitlePos);
X      graph->ytitlePos	= justifyString (graph->boxWidth, graph->ytitleLen, graph->ytitlePos);
X   } 
X   else
X   {
X      graph->ytitle	= char2Chtype ("<C></5>Y Axis", &graph->ytitleLen, &graph->ytitlePos);
X      graph->ytitlePos	= justifyString (graph->boxWidth, graph->ytitleLen, graph->ytitlePos);
X   }
X
X   /* Set some values of the graph structure.				*/
X   graph->graphChar	= (chtype *)NULL;
X
X   /* Register this baby.						*/
X   registerCDKObject (cdkscreen, vGRAPH, graph);
X
X   /* Return the graph pointer.						*/
X   return (graph);
}
X
/*
X * This sets the values of the graph.
X */
int setCDKGraph (CDKGRAPH *graph, int *values, int count, char *graphChar, boolean startAtZero, EGraphDisplayType displayType)
{
X   /* Declare local variables.						*/
X   int min	= 99999999;
X   int max	= (min * -1);
X   int x	= 0;
X   int charCount, temp;
X
X   /* Keep the display type.						*/
X   graph->displayType	= displayType;
X
X   /* Remove the old graph char if it exists.				*/
X   freeChtype (graph->graphChar);
X   graph->graphChar = char2Chtype (graphChar, &charCount, &temp);
X
X   /* Check if the number of characters back is the same as the number	*/
X   /* of elements in the list.						*/
X   if (charCount < count)
X   {
X      /* Oops. Better let them know.					*/
X      freeChtype (graph->graphChar);
X      return (FALSE);
X   }
X
X   /* Copy the X values.						*/
X   for (x=0; x <count; x++)
X   {
X      /* Determine the min/max values of the graph.			*/
X      min		= MIN (values[x], min);
X      max		= MAX (values[x], max);
X
X      /* Copy the value.						*/
X      graph->values[x]	= values[x];
X   }
X   graph->count = count;
X   graph->minx = min;
X   graph->maxx = max;
X
X   /* Check the start at zero status.					*/
X   if (startAtZero)
X   {
X      graph->minx = 0;
X   }
X
X   /* Determine the scales.						*/
X   graph->xscale = ((graph->maxx - graph->minx) / (graph->boxHeight - 5));
X   graph->yscale = ((graph->boxWidth-4) / count);
X   return (TRUE);
}
X
/*
X * This function draws the graph widget.
X */
void drawCDKGraph (CDKGRAPH *graph, boolean Box)
{
X   /* Declare local variables.						*/
X   int x		= 0;
X   int y		= 0;
X   int adj		= 0;
X   chtype attrib	= ' '|A_REVERSE;
X   char temp[100];
X
X   /* Keep the box information.						*/
X   graph->box		= Box;
X
X   /* Erase the old object...						*/
X   eraseCDKGraph (graph);
X
X   /* Draw in the vertical axis						*/
X   drawLine (graph->win, 2, 1, 2, graph->boxHeight-3, ACS_VLINE);
X
X   /* Draw in the horizontal axis					*/
X   drawLine (graph->win, 3, graph->boxHeight-3, graph->boxWidth, graph->boxHeight-3, ACS_HLINE);
X
X   /* Draw in the graph title.						*/
X   if (graph->title != (chtype *)NULL)
X   {
X      writeChtype (graph->win, graph->titlePos, 0, graph->title, HORIZONTAL, 0, graph->titleLen);
X   }
X   
X   /* Draw in the X axis title.						*/
X   if (graph->xtitle != (chtype *)NULL)
X   {
X      writeChtype (graph->win, 0, graph->xtitlePos, graph->xtitle, VERTICAL, 0, graph->xtitleLen);
X      attrib	= graph->xtitle[0] & A_ATTRIBUTES;
X   }
X   
X   /* Draw in the X axis high value.					*/
X   sprintf (temp, "%d", graph->maxx);
X   writeCharAttrib (graph->win, 1, 1, temp, attrib, VERTICAL, 0, strlen(temp));
X   
X   /* Draw in the X axis low value.					*/
X   sprintf (temp, "%d", graph->minx);
X   writeCharAttrib (graph->win, 1, graph->boxHeight-2-strlen(temp), temp, attrib, VERTICAL, 0, strlen(temp));
X   
X   /* Draw in the Y axis title.						*/
X   if (graph->ytitle != (chtype *)NULL)
X   {
X      writeChtype (graph->win, graph->ytitlePos, graph->boxHeight-1, graph->ytitle, HORIZONTAL, 0, graph->ytitleLen);
X      attrib	= graph->ytitle[0] & A_ATTRIBUTES;
X   }
X
X   /* Draw in the Y axis high value.					*/
X   sprintf (temp, "%d", graph->count);
X   writeCharAttrib (graph->win, graph->boxWidth-strlen(temp)-1, graph->boxHeight-2, temp, attrib, HORIZONTAL, 0, strlen(temp));
X   
X   /* Draw in the Y axis low value.					*/
X   sprintf (temp, "0");
X   writeCharAttrib (graph->win, 3, graph->boxHeight-2, temp, attrib, HORIZONTAL, 0, strlen(temp));
X   
X   /* Draw in the lines.						*/
X   adj	= 3;
X   for (y=0; y < graph->count; y++)
X   {
X       int colheight	= (graph->values[y] / graph->xscale) - 1;
X       mvwaddch (graph->win, graph->boxHeight-3, adj-1, ACS_TTEE);
X
X       /* If this is a plot graph, all we do is draw a dot.		*/
X       if (graph->displayType == vPLOT)
X       {
X          int temploc = graph->boxHeight-4-colheight;
X          mvwaddch (graph->win, temploc, adj, graph->graphChar[y]);
X          adj += 2;
X       } 
X       else
X       {
X          for (x=0; x <= graph->yscale; x++)
X          {
X             /* Draw a line.						*/
X             drawLine (graph->win, adj, graph->boxHeight-3-colheight, adj, graph->boxHeight-3, graph->graphChar[y]);
X             adj++;
X          }
X       }
X   }
X
X   /* Draw in the axis corners.						*/
X   mvwaddch (graph->win, 0, 2, ACS_URCORNER);
X   mvwaddch (graph->win, graph->boxHeight-3, 2, ACS_LLCORNER);
X   mvwaddch (graph->win, graph->boxHeight-3, graph->boxWidth, ACS_URCORNER);
X
X   /* Refresh and lets see 'er.						*/
X   wrefresh (graph->win);
}
X
/*
X * This function destroys the graph widget.
X */
void destroyCDKGraph (CDKGRAPH *graph)
{
X   /* Erase the object.							*/
X   eraseCDKGraph (graph);
X
X   /* Clear up the char pointers.					*/
X   freeChtype (graph->title);
X   freeChtype (graph->xtitle);
X   freeChtype (graph->ytitle);
X   freeChtype (graph->graphChar);
X      
X   /* Clean up the windows.						*/
X   delwin (graph->win);
X
X   /* Unregister this object.						*/
X   unregisterCDKObject (vGRAPH, graph);
X
X   /* Finish cleaning up.						*/
X   free (graph);
}
X
/*
X * This function erases the graph widget from the screen.
X */
void eraseCDKGraph (CDKGRAPH *graph)
{
X   werase (graph->win);
X   wrefresh (graph->win);
}
SHAR_EOF
  $shar_touch -am 0503190896 'graph.c' &&
  chmod 0444 'graph.c' ||
  echo 'restore of graph.c failed'
  shar_count="`wc -c < 'graph.c'`"
  test 7952 -eq "$shar_count" ||
    echo "graph.c: original size 7952, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= histogram.c ==============
if test -f 'histogram.c' && test X"$1" != X"-c"; then
  echo 'x - skipping histogram.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting histogram.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'histogram.c' &&
#include "cdk.h"
X
/*
X * $Author: mikeg $
X * $Date: 1996/02/28 14:59:06 $
X * $Revision: 1.31 $
X */
X
/*
X * This creates a histogram widget.
X */
CDKHISTOGRAM *newCDKHistogram (CDKSCREEN *cdkscreen, int xplace, int yplace, int lplace, int height, int width, int orient, char *label, boolean box, boolean shadow)
{
X   /* Declare local variables.						*/
X   CDKHISTOGRAM *histogram	= (CDKHISTOGRAM *)malloc (sizeof (CDKHISTOGRAM));
X   int boxWidth			= 0;
X   int boxHeight		= height + 2;
X   int xpos			= xplace;
X   int ypos			= yplace;
X   int labelxoffset		= 0;
X   int labelyoffset		= 0;
X   int fieldxoffset		= 0;
X   int fieldyoffset		= 0;
X   int junk			= 0;
X   char *plainLabel;
X
X   /* Translate the char * to a chtype *				*/
X   histogram->label	= char2Chtype (label, &histogram->labelLen, &junk);
X   plainLabel		= chtype2Char (histogram->label);
X   boxWidth		= width + histogram->labelLen + 3;
X
X   /* Adjust the offset values given the location of the label.		*/
X   alignlabel (plainLabel, lplace, width, &boxWidth, &boxHeight, &labelxoffset, &labelyoffset, &fieldxoffset, &fieldyoffset);
X   freeChar (plainLabel);
X
X   /* Rejustify the x and y positions if we need to.			*/
X   alignxy (cdkscreen->window, &xpos, &ypos, boxWidth, boxHeight);
X
X   /* Create the histogram pointer.					*/
X   histogram->parent	= cdkscreen->window;
X   histogram->win	= newwin (boxHeight, boxWidth, ypos, xpos);
X   histogram->shadowWin	= (WINDOW *)NULL;
X   histogram->labelWin	= subwin (cdkscreen->window, 1, histogram->labelLen+2, ypos+labelyoffset, xpos+labelxoffset);
X   histogram->width	= width;
X   histogram->height	= height;
X   histogram->orient	= orient;
X   histogram->shadow	= shadow;
X
X   /* Is the window NULL.						*/
X   if (histogram->win == (WINDOW *)NULL)
X   {
X      /* Remove the labelWin if its not NULL.				*/
X      if ( histogram->labelWin != (WINDOW *)NULL)
X      {
X         delwin (histogram->labelWin);
X      }
X
X      /* Clean up any memory used.					*/
X      freeChtype (histogram->label);
X      free (histogram);
X
X      /* Return a NULL pointer.						*/
X      return ( (CDKHISTOGRAM *)NULL );
X   }
X
X   /* Set up some default values.					*/
X   histogram->filler	= '#' | A_REVERSE;
X   histogram->statsattr	= A_NORMAL;
X   histogram->statspos	= TOP;
X   histogram->viewtype	= vREAL;
X   histogram->high	= 0;
X   histogram->low	= 0;
X   histogram->value	= 0;
X   histogram->chars	= 0;
X   histogram->lowx	= 0;
X   histogram->lowy	= 0;
X   histogram->highx	= 0;
X   histogram->highy	= 0;
X   histogram->labelx	= 0;
X   histogram->labely	= 0;
X   histogram->statsx	= 0;
X   histogram->statsy	= 0;
X   histogram->histx	= 0;
X   histogram->histy	= 0;
X   histogram->lowchar	= (char *)NULL;
X   histogram->highchar	= (char *)NULL;
X   histogram->statschar	= (char *)NULL;
X   histogram->box	= box;
X
X   /* Do we want a shadow???						*/
X   if (shadow)
X   {
X      histogram->shadowWin	= subwin (cdkscreen->window, boxHeight, boxWidth, ypos+1, xpos+1);
X   }
X
X   /* Register this baby.						*/
X   registerCDKObject (cdkscreen, vHISTOGRAM, histogram);
X
X   /* Return this thing.						*/
X   return (histogram);
}
X
/*
X * This sets the values for the histogram.
X */
void setCDKHistogram (CDKHISTOGRAM *histogram, EHistogramDisplayType viewtype, int statspos, chtype statsattr, int low, int high, int value, chtype filler, boolean box)
{
X   /* Declare local variables.						*/
X   char		string[100];
X   int		adj;
X   float	temp;
X
X   /* Keep the box info.						*/
X   histogram->box	= box;
X
X   /* We should error check the information we have.			*/
X   histogram->low	= (low <= high ? low : 0);
X   histogram->high	= (low <= high ? high : 0);
X   histogram->value	= ( low <= value && value <= high ? value : 0);
X
X   /* Set some of the basic values.					*/
X   histogram->statspos	= statspos;
X   histogram->statsattr	= statsattr;
X   histogram->filler	= filler;
X   histogram->viewtype	= viewtype;
X   histogram->percent	= (histogram->high == 0 ? 0 : ( (float)histogram->value / (float)histogram->high ));
X   if (histogram->orient == VERTICAL)
X   {
X      temp		= histogram->percent * (float)histogram->height;
X   } 
X   else
X   {
X      temp		= histogram->percent * (float)histogram->width;
X   }
X   histogram->chars	= ( (float)abs(temp) == (float)temp ? (int)temp : (int)temp + 1);
X
X   /* We have a number of variables which determine the personality of	*/
X   /* the histogram. We have to go through each one methodically, and 	*/
X   /* set them correctly. This section does this.			*/
X   if (histogram->viewtype != vNONE)
X   {
X      if (histogram->orient == VERTICAL)
X      {
X         /* Set the vertical adjustment var				*/
X         adj = (histogram->label != (chtype *)NULL ? histogram->labelLen + 1 : 0);
X
X         /* Make a vertical histogram the exception.			*/
X         if (histogram->statspos == LEFT || histogram->statspos == TOP)
X         {
X            /* Set the character strings correctly.			*/
X            freeChar (histogram->lowchar);
X            freeChar (histogram->highchar);
X            freeChar (histogram->statschar);
X
X            /* Set the low label attributes.				*/
X            sprintf (string, "%d", histogram->low);
X            histogram->lowchar		= copyChar (string);
X            histogram->lowx		= histogram->height - (int)strlen (string) + 2;
X            histogram->lowy		= adj;
X            
X            /* Set the high label attributes.				*/
X            sprintf (string, "%d", histogram->high);
X            histogram->highchar		= copyChar (string);
X            histogram->highx		= 0;
X            histogram->highy		= adj;
X   
X            /* Set the stats label attributes.				*/
X            if (histogram->viewtype == vPERCENT)
X            {
X               sprintf (string, "%3.1f%%", (float) (histogram->percent * 100));
X            }
X            else if (histogram->viewtype == vFRACTION)
X            {
X               sprintf (string, "%d/%d", histogram->value, histogram->high);
X            }
X            else
X            {
X               sprintf (string, "%d", histogram->value);
X            }
X            histogram->statschar	= copyChar (string);
X            histogram->statsx		= ((histogram->height - (int)strlen(string)) / 2) + 1;
X            histogram->statsy		= adj;
X         }
X         else if (histogram->statspos == RIGHT || histogram->statspos == BOTTOM)
X         {
X            /* Set the character strings correctly.			*/
X            freeChar (histogram->lowchar);
X            freeChar (histogram->highchar);
X            freeChar (histogram->statschar);
X   
X            /* Set the low label attributes.				*/
X            sprintf (string, "%d", histogram->low);
X            histogram->lowchar		= copyChar (string);
X            histogram->lowx		= histogram->height - (int)strlen (string) + 2;
X            histogram->lowy		= histogram->width + 1;
X            
X            /* Set the high label attributes.				*/
X            sprintf (string, "%d", histogram->high);
X            histogram->highchar		= copyChar (string);
X            histogram->highx		= 0;
X            histogram->highy		= histogram->width + 1;
X   
X            /* Set the stats label attributes.				*/
X            if (histogram->viewtype == vPERCENT)
X            {
X               sprintf (string, "%3.2f%%", (float) (histogram->percent * 100));
X            }
X            else if (histogram->viewtype == vFRACTION)
X            {
X               sprintf (string, "%d/%d", histogram->value, histogram->high);
X            }
X            else
X            {
X               sprintf (string, "%d", histogram->value);
X            }
X            histogram->statschar	= copyChar (string);
X            histogram->statsx		= ((histogram->height - (int)strlen(string)) / 2) + 1;
X            histogram->statsy		= histogram->width + 1;
X         }
X
X         /* Set the histogram positions attributes.			*/
X         histogram->histx		= histogram->height - histogram->chars + 1;
X         histogram->histy		= adj;
X      }
X      else
X      {
X         /* Set the vertical adjustment var				*/
X         adj = (histogram->label != (chtype *)NULL ? histogram->labelLen + 1 : 0);
X
X         /* Make horizontal the default.				*/
X         if (histogram->statspos == TOP || histogram->statspos == LEFT)
X         {
X            /* Set the character strings correctly.			*/
X            freeChar (histogram->lowchar);
X            freeChar (histogram->highchar);
X            freeChar (histogram->statschar);
X
X            /* Set the low label attributes.    			*/
X            sprintf (string, "%d", histogram->low);
X            histogram->lowchar          = copyChar (string);
X            histogram->lowx             = 0;
X            histogram->lowy             = adj;
X            
X            /* Set the high label attributes.   			*/
X            sprintf (string, "%d", histogram->high);
X            histogram->highchar         = copyChar (string);
X            histogram->highx            = 0;
X            histogram->highy            = histogram->width - (int)strlen (string) + adj + 1;
X   
X            /* Set the stats label attributes.  			*/
X            if (histogram->viewtype == vPERCENT)
X            {
X               sprintf (string, "%3.1f%%", (float) (histogram->percent * 100));
X            }
X            else if (histogram->viewtype == vFRACTION)
X            {
X               sprintf (string, "%d/%d", histogram->value, histogram->high);
X            }
X            else
X            {
X               sprintf (string, "%d", histogram->value);
X            }
X            histogram->statschar        = copyChar (string);
X            histogram->statsx           = 0;
X            histogram->statsy           = ((histogram->width - (int)strlen(string)) / 2) + adj + 1;
X         }
X         else if (histogram->statspos == BOTTOM || histogram->statspos == RIGHT)
X         {
X            /* Set the character strings correctly.			*/
X            freeChar (histogram->lowchar);
X            freeChar (histogram->highchar);
X            freeChar (histogram->statschar);
X
X            /* Set the low label attributes.    			*/
X            sprintf (string, "%d", histogram->low);
X            histogram->lowchar          = copyChar (string);
X            histogram->lowx             = histogram->height + 1;
X            histogram->lowy             = adj;
X            
X            /* Set the high label attributes.   			*/
X            sprintf (string, "%d", histogram->high);
X            histogram->highchar         = copyChar (string);
X            histogram->highx            = histogram->height + 1;
X            histogram->highy            = histogram->width - (int)strlen (string) + adj + 1;
X   
X            /* Set the stats label attributes.  			*/
X            if (histogram->viewtype == vPERCENT)
X            {
X               sprintf (string, "%3.1f%%", (float) (histogram->percent * 100));
X            }
X            else if (histogram->viewtype == vFRACTION)
X            {
X               sprintf (string, "%d/%d", histogram->value, histogram->high);
X            }
X            else
X            {
X               sprintf (string, "%d", histogram->value);
X            }
X            histogram->statschar        = copyChar (string);
X            histogram->statsx           = histogram->height + 1;
X            histogram->statsy           = ((histogram->width - (int)strlen(string)) / 2) + adj + 1;
X         }
X         else if (histogram->statspos == CENTER)
X         {
X            /* Set the character strings correctly.			*/
X            freeChar (histogram->lowchar);
X            freeChar (histogram->highchar);
X            freeChar (histogram->statschar);
X
X            /* Set the low label attributes.    			*/
X            sprintf (string, "%d", histogram->low);
X            histogram->lowchar          = copyChar (string);
X            histogram->lowx             = (histogram->height == 1 ? 1 : (histogram->height / 2) );
X            histogram->lowy             = adj;
X            
X            /* Set the high label attributes.   			*/
X            sprintf (string, "%d", histogram->high);
X            histogram->highchar         = copyChar (string);
X            histogram->highx            = (histogram->height == 1 ? 1 : (histogram->height / 2) );
X            histogram->highy            = histogram->width - (int)strlen (string) + adj + 1;
X   
X            /* Set the stats label attributes.  			*/
X            if (histogram->viewtype == vPERCENT)
X            {
X               sprintf (string, "%3.1f%%", (float) (histogram->percent * 100));
X            }
X            else if (histogram->viewtype == vFRACTION)
X            {
X               sprintf (string, "%d/%d", histogram->value, histogram->high);
X            }
X            else
X            {
X               sprintf (string, "%d", histogram->value);
X            }
X            histogram->statschar        = copyChar (string);
X            histogram->statsx           = (histogram->height == 1 ? 1 : (histogram->height / 2) );
X            histogram->statsy           = ((histogram->width - (int)strlen(string)) / 2) + adj + 1;
X         }
X      }
X   }
}
X
/*
X * This function draws the histogram.
X */
void drawCDKHistogram (CDKHISTOGRAM *histogram, boolean Box)
{
X   /* Declare the local variables.					*/
X   int x	= 0;
X   int y	= 0;
X
X   /* Erase the old object...						*/
X   eraseCDKHistogram (histogram);
X
X   /* Box the widget if asked.						*/
X   if (Box)
X   {
X      box (histogram->win, histogram->statsattr | ACS_VLINE, histogram->statsattr |ACS_HLINE);
X   }
X
X   /* Do we have a shadow to draw???					*/
X   if (histogram->shadow)
X   {
X      drawShadow (histogram->shadowWin);
X   }
X
X   /* Draw the histogram.						*/
X   if (histogram->orient == VERTICAL)
X   {
X       /* Declare the local vars.					*/
X       int temp	= (int)strlen (histogram->highchar);
X       chtype fattr, fchar, battr, bchar;
X
X       /* Draw in the high label					*/
X       for (x=0; x < temp; x++)
X       {
X          mvwaddch (histogram->win,	histogram->highx + x,
X					histogram->highy,
X					histogram->highchar[x] | histogram->statsattr);
X       }
X
X       /* Draw in the low label						*/
X       temp =(int)strlen (histogram->lowchar);
X       for (x=0; x < temp; x++)
X       {
X          mvwaddch (histogram->win,	histogram->lowx + x,
X					histogram->lowy,
X					histogram->lowchar[x] | histogram->statsattr);
X       }
X
X       /* Draw in the stats label					*/
X       temp =(int)strlen (histogram->statschar);
X       for (x=0; x < temp; x++)
X       {
X          mvwaddch (histogram->win,	histogram->statsx + x,
X					histogram->statsy,
X					histogram->statschar[x] | histogram->statsattr);
X       }
X
X       /* Draw in the histogram.					*/
X       temp	= histogram->labelLen;
X       fattr	= histogram->filler & A_ATTRIBUTES;
X       fchar	= histogram->filler & A_CHARTEXT;
X
X       for (x=histogram->histx; x <= histogram->height; x++)
X       {
X          for (y=1; y <= histogram->width; y++)
X          {
#ifdef WINCHBUG
X             battr	= ' ' | A_REVERSE;
#else
X             battr	= mvwinch (histogram->win, x, y+temp );
#endif
X             fchar	= battr & A_ATTRIBUTES;
X             bchar	= battr & A_CHARTEXT;
X             if (bchar == ' ')
X             {
X                mvwaddch (histogram->win, x, y+temp, histogram->filler);
X             }
X             else
X             {
X                mvwaddch (histogram->win, x, y+temp, battr | fattr);
X             }
X          }
X       }
X       wrefresh (histogram->win);
X
X       /* Draw in the label						*/
X       writeChtype (histogram->labelWin, 0, 0, histogram->label, HORIZONTAL, 0, histogram->labelLen);
X       wrefresh (histogram->labelWin);
X   }
X   else
X   {
X       /* Declare the local vars.					*/
X       int temp	= (int)strlen (histogram->highchar);
X       chtype fattr, fchar, battr, bchar;
X       int x, y;
X
X       /* Draw in the high label					*/
X       for (x=0; x < temp; x++)
X       {
X          mvwaddch (histogram->win,	histogram->highx,
X					histogram->highy + x,
X					histogram->highchar[x] | histogram->statsattr);
X       }
X
X       /* Draw in the low label						*/
X       temp	= (int)strlen (histogram->lowchar);
X       for (x=0; x < temp; x++)
X       {
X          mvwaddch (histogram->win,	histogram->lowx,
X					histogram->lowy + x,
X					histogram->lowchar[x] | histogram->statsattr);
X       }
X
X       /* Draw in the stats label					*/
X       temp	= (int)strlen (histogram->statschar);
X       for (x=0; x < temp; x++)
X       {
X          mvwaddch (histogram->win,	histogram->statsx,
X					histogram->statsy + x,
X					histogram->statschar[x] | histogram->statsattr);
X       }
X
X       /* Set up some variables we need for the histogram.		*/
X       temp	= histogram->labelLen;
X       fattr	= histogram->filler & A_ATTRIBUTES;
X       fchar	= histogram->filler & A_CHARTEXT;
X
X       /* Draw in the histogram.					*/
X       for (x=1; x <= histogram->height; x++)
X       {
X          for (y=0; y < histogram->chars; y++)
X          {
X             /* Get the character and split it into its elements	*/
#ifdef WINCHBUG
X             battr	= ' ' | A_REVERSE;
#else
X             battr	= mvwinch (histogram->win, x, y+temp );
#endif
X             bchar	= battr & A_CHARTEXT;
X             fchar	= battr & A_ATTRIBUTES;
X
X             /* If there was nothing there, put the histogram		*/
X             /* down.							*/
X             if (bchar == ' ')
X             {
X                mvwaddch (histogram->win, x, y+temp, histogram->filler);
X             }
X             else
X             {
X                mvwaddch (histogram->win, x, y+temp, bchar | fattr);
X             }
X          }
X       }
X       wrefresh (histogram->win);
X
X       /* Draw in the label						*/
X       writeChtype (histogram->labelWin, 0, 0, histogram->label, HORIZONTAL, 0, histogram->labelLen);
X       wrefresh (histogram->labelWin);
X   }
}
X
/*
X * This function destroys the histogram.
X */
void destroyCDKHistogram (CDKHISTOGRAM *histogram)
{
X   /* Erase the object.							*/
X   eraseCDKHistogram (histogram);
X
X   /* Clean up the char pointers.					*/
X   freeChtype (histogram->label);
X   freeChar (histogram->lowchar);
X   freeChar (histogram->highchar);
X   freeChar (histogram->statschar);
X
X   /* Clean up the windows.						*/
X   delwin (histogram->win);
X   delwin (histogram->labelWin);
X   if (histogram->shadow)
X   {
X      delwin (histogram->shadowWin);
X   }
X
X   /* Unregister this object.						*/
X   unregisterCDKObject (vHISTOGRAM, histogram);
X
X   /* Finish cleaning up.						*/
X   free (histogram);
}
X
/*
X * This function erases the histogram from the screen.
X */
void eraseCDKHistogram (CDKHISTOGRAM *histogram)
{
X   werase (histogram->win);
X   werase (histogram->labelWin);
X   wrefresh (histogram->win);
X   wrefresh (histogram->labelWin);
X
X   /* Do we need to erase the shadow...					*/
X   if (histogram->shadow)
X   {
X      werase (histogram->shadowWin);
X      wrefresh (histogram->shadowWin);
X   }
}
SHAR_EOF
  $shar_touch -am 0503190896 'histogram.c' &&
  chmod 0444 'histogram.c' ||
  echo 'restore of histogram.c failed'
  shar_count="`wc -c < 'histogram.c'`"
  test 18649 -eq "$shar_count" ||
    echo "histogram.c: original size 18649, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= itemlist.c ==============
if test -f 'itemlist.c' && test X"$1" != X"-c"; then
  echo 'x - skipping itemlist.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting itemlist.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'itemlist.c' &&
#include "cdk.h"
X
/*
X * $Author: glover $
X * $Date: 1996/04/14 03:02:12 $
X * $Revision: 1.11 $
X */
X
/*
X * This creates a pointer to an itemlist widget.
X */
CDKITEMLIST *newCDKItemlist (CDKSCREEN *cdkscreen, int xplace, int yplace, int lplace, char *label, char **item, int count, int defaultItem, boolean box, boolean shadow)
{
X   /* Set up some variables.						*/
X   CDKITEMLIST *itemlist = (CDKITEMLIST *)malloc (sizeof (CDKITEMLIST));
X   char *plainlabel	= (char *)NULL;
X   int boxWidth		= 0;
X   int boxHeight	= 3;
X   int fieldWidth	= 0;
X   int xpos		= xplace;
X   int ypos		= yplace;
X   int labelxoffset	= 0;
X   int labelyoffset	= 0;
X   int fieldxoffset	= 0;
X   int fieldyoffset	= 0;
X   int temp		= 0;
X   int x;
X
X   /* Translate the label char *pointer to a chtype pointer.		*/
X   itemlist->label	= char2Chtype (label, &itemlist->labelLen, &temp);
X   plainlabel		= chtype2Char (itemlist->label);
X
X   /* Go through the list and determine the widest item.		*/
X   for (x=0; x < count; x++)
X   {
X      /* Copy the item to the list.					*/
X      itemlist->item[x]	= char2Chtype (item[x], &itemlist->itemLen[x], &itemlist->itemPos[x]);
X      fieldWidth = (fieldWidth < itemlist->itemLen[x] ? itemlist->itemLen[x] : fieldWidth);
X   }
X   fieldWidth += 2;
X
X   /* Now we need to justify the strings.				*/
X   for (x=0; x < count; x++)
X   {
X      itemlist->itemPos[x] = justifyString (fieldWidth, itemlist->itemLen[x], itemlist->itemPos[x]);
X   }
X
X   /* Adjust the offset values given the location of the label.		*/
X   alignlabel (plainlabel, lplace, fieldWidth, &boxWidth, &boxHeight, &labelxoffset, &labelyoffset, &fieldxoffset, &fieldyoffset);
X   freeChar (plainlabel);
X   
X   /* Rejustify the x and y positions if we need to.			*/
X   alignxy (cdkscreen->window, &xpos, &ypos, boxWidth, boxHeight);
X
X   /* Make the label window.						*/
X   itemlist->win = newwin (boxHeight, boxWidth, ypos, xpos);
X
X   /* Is the window NULL ???						*/
X   if (itemlist->win == (WINDOW *)NULL)
X   {
X      /* Clean up the pointers.						*/
X      freeChtype (itemlist->label);
X      free (itemlist);
X      
X      /* Exit with NULL.						*/
X      return ((CDKITEMLIST *)NULL);
X   }
X
X   /* Make the field window.						*/
X   itemlist->fieldWin	= subwin (cdkscreen->window, 1, fieldWidth, ypos+fieldyoffset, xpos+fieldxoffset);
X   itemlist->labelWin	= subwin (cdkscreen->window, 1, itemlist->labelLen+1, ypos+labelyoffset, xpos+labelxoffset);
X   keypad (itemlist->fieldWin, TRUE);
X
X   /* Set up the rest of the structure.					*/
X   itemlist->parent			= cdkscreen->window;
X   itemlist->shadowWin			= (WINDOW *)NULL;
X   itemlist->fieldWidth			= fieldWidth;
X   itemlist->itemCount			= count-1;
X   itemlist->box			= box;
X   itemlist->shadow			= shadow;
X   itemlist->preProcessFunction		= (PROCESSFN)NULL;
X   itemlist->preProcessData		= (void *)NULL;
X   itemlist->postProcessFunction	= (PROCESSFN)NULL;
X   itemlist->postProcessData		= (void *)NULL;
X
X   /* Set then default item.						*/
X   if (defaultItem >= 0 && defaultItem <= itemlist->itemCount)
X   {
X      itemlist->currentItem	= defaultItem;
X      itemlist->defaultItem	= defaultItem;
X   }
X   else
X   {
X      itemlist->currentItem	= 0;
X      itemlist->defaultItem	= 0;
X   }
X
X   /* Do we want a shadow???						*/
X   if (shadow)
X   {
X      itemlist->shadowWin = newwin (boxHeight, boxWidth, ypos+1, xpos+1);
X   }
X
X   /* Clean the key bindings.						*/
X   cleanCDKObjectBindings (vITEMLIST, itemlist);
X
X   /* Register this baby.               				*/
X   registerCDKObject (cdkscreen, vITEMLIST, itemlist);
X
X   /* Return the pointer to the structure				*/
X   return (itemlist);
}
X
/*
X * This allows the user to play with the widget.
X */
int activateCDKItemlist (CDKITEMLIST *itemlist, chtype *actions)
{
X   /* Declare local variables.						*/	
X   int ret;
X
X   /* Draw the widget.							*/
X   drawCDKItemlist (itemlist, itemlist->box);
X
X   /* Check if actions is NULL.						*/
X   if (actions == (chtype *)NULL)
X   {
X      chtype input = (chtype)NULL;
X      for (;;)
X      {
X         /* Get the input.						*/
X         input = wgetch (itemlist->fieldWin);
X
X         /* Inject the character into the widget.			*/
X         ret = injectCDKItemlist (itemlist, input);
X         if (ret != -2)
X         {
X            return ret;
X         }
X      }
X   }
X   else
X   {
X      int length = chlen (actions);
X      int x = 0;
X
X      /* Inject each character one at a time.				*/
X      for (x=0; x < length; x++)
X      {
X         ret = injectCDKItemlist (itemlist, actions[x]);
X         if (ret != -2)
X         {
X            return ret;
X         }
X      }
X   }
X   return -1;
}
X
/*
X * This injects a single character into the widget.
X */
int injectCDKItemlist (CDKITEMLIST *itemlist, chtype input)
{
X   /* Declare local variables.						*/
X   int ppReturn = 1;
X
X   /* Draw the itemlist field.						*/
X   drawCDKItemlistField (itemlist);
X
X   /* Check if there is a pre-process function to be called.		*/
X   if (itemlist->preProcessFunction != (PROCESSFN)NULL)
X   {
X      /* Call the pre-process function.					*/
X      ppReturn = ((PROCESSFN)(itemlist->preProcessFunction)) (vITEMLIST, itemlist, itemlist->preProcessData, input);
X   }
X
X   /* Should we continue?						*/
X   if (ppReturn != 0)
X   {
X      /* Check a predefined binding.					*/
X      if (! checkCDKObjectBind (vITEMLIST, itemlist, input))
X      {
X         switch (input)
X         {
X            case KEY_UP : case KEY_RIGHT : case ' ' : case '+' : case 'n' :
X                 if (itemlist->currentItem < itemlist->itemCount)
X                 {
X                    itemlist->currentItem++;
X                 }
X                 else
X                 {
X                    itemlist->currentItem = 0;
X                 }
X                 break;
X   
X            case KEY_DOWN : case KEY_LEFT : case '-' : case 'p' :
X                 if (itemlist->currentItem > 0)
X                 {
X                    itemlist->currentItem--;
X                 }
X                 else
X                 {
X                    itemlist->currentItem = itemlist->itemCount;
X                 }
X                 break;
X   
X            case 'd' : case 'D' :
X                 itemlist->currentItem = itemlist->defaultItem;
X                 break;
X   
X            case '0' :
X                 itemlist->currentItem = 0;
X                 break;
X   
X            case '$' :
X                 itemlist->currentItem = itemlist->itemCount;
X                 break;
X   
X            case CDK_NEXT : case KEY_ESC :
X                 return -1;
X                 break;
X   
X            case KEY_RETURN : case KEY_TAB :
X                 return itemlist->currentItem;
X                 break;
X   
X            case CDK_REFRESH :
X                 refreshCDKScreen (itemlist->screen);
X                 break;
X   
X            default :
X                 Beep();
X                 break;
X         }
X      }
X
X      /* Should we call a post-process?					*/
X      if (itemlist->postProcessFunction != (PROCESSFN)NULL)
X      {
X         ((PROCESSFN)(itemlist->postProcessFunction)) (vITEMLIST, itemlist, itemlist->postProcessData, input);
X      }
X   }
X
X   /* Redraw the field.							*/
X   drawCDKItemlistField (itemlist);
X   return -2;
}
X
/*
X * This draws the widget on the screen.
X */
void drawCDKItemlist (CDKITEMLIST *itemlist, int Box)
{
X   /* Erase the widget from the screen.					*/
X   eraseCDKItemlist (itemlist);
X 
X   /* Did we ask for a shadow?						*/
X   if (itemlist->shadow)
X   {
X      drawShadow (itemlist->shadowWin);
X   }
X 
X   /* Box the widget if asked.						*/
X   if (Box)
X   {
X      box (itemlist->win, ACS_VLINE, ACS_HLINE);
X      wrefresh (itemlist->win);
X   }
X 
X   /* Draw in the label to the widget.                                  */
X   writeChtype (itemlist->labelWin, 0, 0, 
X		itemlist->label,
X		HORIZONTAL, 0,
X		itemlist->labelLen);
X   wrefresh (itemlist->labelWin);
X
X   /* Draw in the field.						*/
X   drawCDKItemlistField (itemlist);
}
X
/*
X * This function draws the contents of the field.
X */
void drawCDKItemlistField (CDKITEMLIST *itemlist)
{
X   /* Declare local vars.						*/
X   int currentItem = itemlist->currentItem;
X   int x;
X
X   /* Draw in the current item in the field.				*/
X   werase (itemlist->fieldWin);
X   for (x=0; x < itemlist->itemLen[currentItem]; x++)
X   {
X      mvwaddch (itemlist->fieldWin, 0,
X		x+itemlist->itemPos[currentItem],
X		itemlist->item[currentItem][x]);
X   }
X   wrefresh (itemlist->fieldWin);
}
X
/*
X * This function removes the widget from the screen.
X */
void eraseCDKItemlist (CDKITEMLIST *itemlist)
{
X   werase (itemlist->fieldWin);
X   werase (itemlist->labelWin);
X   werase (itemlist->win);
X   wrefresh (itemlist->win);
X
X   /* Do we want to erase the shadow.				*/
X   if (itemlist->shadow)
X   {
X      werase (itemlist->shadowWin);
X      wrefresh (itemlist->shadowWin);
X   }
}
X
/*
X * This function destroys the widget and all the memory it used.
X */
void destroyCDKItemlist (CDKITEMLIST *itemlist)
{
X   /* Declare local variables.					*/
X   int x;
X
X   /* Erase the object.						*/
X   eraseCDKItemlist (itemlist);
X
X   /* Clear out the character pointers.				*/
X   freeChtype (itemlist->label);
X   for (x=0; x <= itemlist->itemCount; x++)
X   {
X      freeChtype (itemlist->item[x]);
X   }
X
X   /* Delete the windows.					*/
X   delwin (itemlist->fieldWin);
X   delwin (itemlist->labelWin);
X   delwin (itemlist->win);
X   if (itemlist->shadow)
X   {
X      delwin (itemlist->shadowWin);
X   }
X
X   /* Unregister this object.					*/
X   unregisterCDKObject (vITEMLIST, itemlist);
X
X   /* Finish cleaning up.					*/
X   free (itemlist);
}
X
/*
X * This function sets the contents of the list.
X */
void setCDKItemlist (CDKITEMLIST *itemlist, char **item, int count, int defaultItem, boolean box)
{
X   /* Declare local variables.					*/
X   int x;
X
X   /* Free up the old memory.					*/
X   for (x=0; x <= itemlist->itemCount; x++)
X   {
X      freeChtype (itemlist->item[x]);
X   }
X
X   /* Copy in the new information.				*/
X   itemlist->itemCount = count-1;
X   for (x=0; x <= itemlist->itemCount; x++)
X   {
X      /* Copy the new stuff in.					*/
X      itemlist->item[x]	= char2Chtype (item[x], &itemlist->itemLen[x], &itemlist->itemPos[x]);
X      itemlist->itemPos[x] = justifyString (itemlist->fieldWidth, itemlist->itemLen[x], itemlist->itemPos[x]);
X   }
X
X   /* Set the box flag.						*/
X   itemlist->box = box;
X
X   /* Set the default item.					*/
X   if (defaultItem >= 0 && defaultItem <= itemlist->itemCount)
X   {
X      itemlist->currentItem = defaultItem;
X      itemlist->defaultItem = defaultItem;
X   }
X
X   /* Draw the field.						*/
X   drawCDKItemlistField (itemlist);
}
X
/*
X * This function sets the pre-process function.
X */
void setCDKItemlistPreProcess (CDKITEMLIST *itemlist, PROCESSFN callback, void *data)
{
X   itemlist->preProcessFunction = callback;
X   itemlist->preProcessData = data;
}
X 
/*
X * This function sets the post-process function.
X */
void setCDKItemlistPostProcess (CDKITEMLIST *itemlist, PROCESSFN callback, void *data)
{
X   itemlist->postProcessFunction = callback;
X   itemlist->postProcessData = data;
}
SHAR_EOF
  $shar_touch -am 0503190896 'itemlist.c' &&
  chmod 0444 'itemlist.c' ||
  echo 'restore of itemlist.c failed'
  shar_count="`wc -c < 'itemlist.c'`"
  test 10970 -eq "$shar_count" ||
    echo "itemlist.c: original size 10970, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= label.c ==============
if test -f 'label.c' && test X"$1" != X"-c"; then
  echo 'x - skipping label.c (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting label.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'label.c' &&
#include "cdk.h"
X
/*
X * $Author: mikeg $
X * $Date: 1996/02/28 14:59:06 $
X * $Revision: 1.30 $
X */
X
/*
X * This creates a label widget.
X */
CDKLABEL *newCDKLabel(CDKSCREEN *cdkscreen, int xplace, int yplace, char **mesg, int rows, boolean box, boolean shadow)
{
X   /* Maintain the label information					*/
X   CDKLABEL *label	= (CDKLABEL *)malloc (sizeof (CDKLABEL));
X   int boxWidth		= 0;
X   int boxHeight	= rows + 2;
X   int xpos		= xplace;
X   int ypos		= yplace;
X   int x		= 0;
X
X   /* Determine the box width.						*/
X   for (x=0; x < rows; x++)
X   {
X      /* Translate the char * to a chtype.				*/
X      label->info[x]	= char2Chtype (mesg[x], &label->infoLen[x], &label->infoPos[x]);
X      boxWidth		= MAX(boxWidth, label->infoLen[x]);
X   }
X   boxWidth += 2;
X
X   /* Create the string alignments.					*/
X   for (x=0; x < rows; x++)
X   {
X      label->infoPos[x]	= justifyString (boxWidth, label->infoLen[x], label->infoPos[x]);
X   }
X
X   /* Rejustify the x and y positions if we need to.			*/
X   alignxy (cdkscreen->window, &xpos, &ypos, boxWidth, boxHeight);
X
X   /* Create the label							*/
X   label->parent	= cdkscreen->window;
X   label->win		= newwin (boxHeight, boxWidth, ypos, xpos);
X   label->shadowWin	= (WINDOW *)NULL;
X   label->xpos		= xpos;
X   label->ypos		= ypos;
X   label->rows		= rows;
X   label->width		= boxWidth;
X   label->box		= box;
X   label->shadow	= shadow;
X
X   /* Is the window NULL???						*/
X   if (label->win == (WINDOW *)NULL) 
X   {
X      /* Free up any memory used.					*/
X      for (x=0; x < rows; x++)
X      {
X         freeChtype (label->info[x]);
X      }
X      free(label);
X
X      /* Return a NULL pointer.						*/
X      return ( (CDKLABEL *)NULL );
X   }
X
X   /* If a shadow was requested, then create the shadow window.		*/
X   if (shadow)
X   {
X      label->shadowWin	= newwin (boxHeight, boxWidth, ypos+1, xpos+1);
X   }
X
X   /* Register this baby.						*/
X   registerCDKObject (cdkscreen, vLABEL, label);
X
X   /* Return the label pointer.						*/
X   return (label);
}
X
/*
X * This draws the label widget.
X */
void drawCDKLabel (CDKLABEL *label, boolean Box)
{
X   /* Declare local variables.						*/
X   int x	= 0;
X   
X   /* Keep the box information.						*/
X   label->box	= Box;
X
X   /* Erase the label widget from the screen.				*/
X   eraseCDKLabel (label);
X
X   /* Is there a shadow???						*/
X   if (label->shadow)
X   {
X      drawShadow (label->shadowWin);
X   }
X
X   /* Box the widget if asked.						*/
X   if (label->box)
X   {
X      box (label->win, ACS_VLINE, ACS_HLINE);
X   }
X   wrefresh (label->win);
X
X   /* Draw in the message.						*/
X   for (x=0; x < label->rows; x++)
X   {
X     writeChtype (label->win, label->infoPos[x], x+1, label->info[x], HORIZONTAL, 0, label->infoLen[x]);
X   }
X   wrefresh (label->win);
}
X
/*
X * This erases the label widget.
X */
void eraseCDKLabel (CDKLABEL *label)
{
X   werase (label->win);
X   wrefresh (label->win);
X
X   /* Do we need to erase the shadow win.				*/
X   if (label->shadow)
X   {
X      werase (label->shadowWin);
X      wrefresh (label->shadowWin);
X   }
}
X
/*
X * This destroys the label object pointer.
X */
void destroyCDKLabel (CDKLABEL *label)
{
X   /* Declare local variables.						*/
X   int x		= 0;
X
X   /* Erase the old label.						*/
X   eraseCDKLabel (label);
X
X   /* Free up the character pointers.					*/
X   for (x=0; x < label->rows ; x++)
X   {
X      freeChtype (label->info[x]);
X   }
X
X   /* Free up the window pointers.					*/
X   delwin (label->win);
X
X   /* Is there a shadow with this widget???				*/
X   if (label->shadow)
X   {
X      delwin (label->shadowWin);
X   }
X 
X   /* Unregister the object.						*/
X   unregisterCDKObject (vLABEL, label);
X
X   /* Free the object pointer.						*/
X   free (label);
}
X
/*
X * This pauses until a user hits a key...
X */
char waitCDKLabel (CDKLABEL *label, char key)
{
X   /* If the key is null, we'll accept anything.			*/
X   if ( key == (char)NULL )
X   {
X      return (wgetch (label->win));
X   }
X   else
X   {
X      /* Only exit when a specific key is hit.				*/
X      char newkey;
X      for (;;)
X      {
X         newkey = wgetch(label->win);
X         if (newkey == key)
X         {
X            return ( newkey );
X         }
X      }
X   }
}
SHAR_EOF
  $shar_touch -am 0503190896 'label.c' &&
  chmod 0444 'label.c' ||
  echo 'restore of label.c failed'
  shar_count="`wc -c < 'label.c'`"
  test 4146 -eq "$shar_count" ||
    echo "label.c: original size 4146, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= man/dialog.3 ==============
if test ! -d 'man'; then
  echo 'x - creating directory man'
  mkdir 'man'
fi
if test -f 'man/dialog.3' && test X"$1" != X"-c"; then
  echo 'x - skipping man/dialog.3 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting man/dialog.3 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'man/dialog.3' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH cdk_dialog 3 "05 Dec 1995"
X.SH NAME
newCDKDialog, activateCDKDialog, setCDKDialog, injectCDKDialog, drawCDKDialog,
eraseCDKDialog, destroyCDKDialog, setCDKDialogPreProcess,
setCDKDialogPostProcess \- Creates a managed curses dialog widget.
X.SH SYNOPSIS
X.LP
X.B cc
X.RI "[ " "flag" " \|.\|.\|. ] " "file" " \|.\|.\|."
X.B \-lcdk
X.RI "[ " "library" " \|.\|.\|. ]"
X.LP
#include <cdk.h>
X.LP
X.BI "CDKDIALOG *newCDKDialog (CDKSCREEN *" "cdkscreen",
X.BI "int " "xpos",
X.BI "int " "ypos",
X.BI "char ** " "message" ,
X.BI "int " "rows",
X.BI "char ** " "buttons" ,
X.BI "int " "buttonCount",
X.BI "chtype " "highlight" ,
X.BI "boolean " "separator",
X.BI "boolean " "box",
X.BI "boolean " "shadow");
X.LP
X.BI "int activateCDKDialog (CDKDIALOG *" "dialog",
X.BI "chtype * " "actions");
X.LP
X.BI "int injectCDKDialog (CDKDIALOG *" "dialog",
X.BI "chtype " "input");
X.LP
X.BI "void setCDKDialog (CDKDIALOG *" "dialog",
X.BI "chtype " "highlight",
X.BI "boolean " "separator",
X.BI "boolean " "box");
X.LP
X.BI "void drawCDKDialog (CDKDIALOG *" "dialog",
X.BI "boolean " "box");
X.LP
X.BI "void eraseCDKDialog (CDKDIALOG *" "dialog");
X.LP
X.BI "void setCDKDialogPreProcess (CDKDIALOG *" "dialog",
X.BI "PROCESSFN " "callback",
X.BI "void * " "data");
X.LP
X.BI "void setCDKDialogPostProcess (CDKDIALOG *" "dialog",
X.BI "PROCESSFN " "callback",
X.BI "void * " "data");
X.LP
X.BI "void destroyCDKDialog (CDKDIALOG *" "dialog");
X.LP
X.BI "void bindCDKObject (EObjectType " "widgetType",
X.BI "void * " "object",
X.BI "chtype " "key",
X.BI "BINDFN " "function",
X.BI "void * " "data");
X.SH DESCRIPTION
The Cdk dialog widget creates a dialog box with a message and a varied number of
buttons to choose from. The following are functions which create or manipulate
the Cdk dialog box widget.
X.PP
X
CDKDIALOG *newCDKDialog (\f2screen\f1, \f2xpos\f1, \f2ypos\f1,\f2message\f1 , \f2rows\f1, \f2buttons\f1, \f2buttonCount\f1,\f2highLight\f1, \f2separator\f1, \f2box\f1, \f2shadow\f1);
X.RS 3
This function creates a pointer to a dialog widget. The parameter
\f2screen\f1 is of type CDKSCREEN. The parameter \f2xpos\f1 controls the 
placement of the object along the horizontal axis; which means it can take 
an integer value or the pre-defined values of \f4LEFT\f1, \f4RIGHT\f1, and 
\f4CENTER\f1. The parameter \f2ypos\f1 controls the placement of the object 
along the vertical axis which means it can accept an integer value or a 
pre-defined value of \f4TOP\f1, \f4BOTTOM\f1, and \f4CENTER\f1. The parameter 
\f2message\f1 is a \f4char **\f1 to be displayed in the message region of the 
dialog box. The \f2rows\f1 parameter states how many elements there are in the
\f2message\f1. The \f2buttons\f1 array contains a list of all the buttons to
be displayed on the dialog box; while \f2buttonCount\f1 is the number of 
elements in the \f2button\f1 array. \f2highlight\f1 is the attribute of the 
currently highlighted button. The \f2box\f1 parameter states whether the
widget will be drawn with a box around it or not. \f2separator\f1 states
whether a separator line will be drawn between the message region and the 
buttons. The \f2shadow\f1 parameter accepts a boolean value to turn the shadow
on or off around this widget. If the widget could not be created then a NULL
pointer is returned.
X.RE
X
int activateCDKDialog (\f2dialog\f1, \f2actions\f1);
X.RS 3
This function activates the dialog widget and lets the user interact with the
widget. The parameter \f2dialog\f1 is a pointer to a defined dialog widget.
The parameter \f2actions\f1 is an array of \f4chtype\f1. If \f2actions\f1 is 
passed with a non-NULL value, the characters in the array will be inserted 
into the widget. To activate the widget interatively pass in a NULL pointer for
\f2actions\f1. If the \f4RETURN\f1 character is entered then an integer value
representing the currently selected button is returned. If the \f4CTRL-N\f1
character is entered then a value -1 is returned.
X.RE
X
int injectCDKDialog (\f2dialog\f1, \f2character\f1);
X.RS 3
This function injects a single character into the widget. The parameter 
\f2dialog\f1 is a pointer to a defined dialog widget. The parameter 
\f2character\f1 is of type \f4chtype\f1 and is the character to inject into
the widget. If the character injected into the widget was \f4RETURN\f1
then the currently selected button number will be returned. If the character
injected was \f4CTRL-N\f1 then a value -1 is returned. Otherwise this 
function returns a value of -2.
X.RE
X
void setCDKDialog (\f2dialog\f1, \f2highlight\f1, \f2separator\f1, \f2box\f1);
X.RS 3
This function lets the programmer modify certain elements of an already defined
dialog widget. The parameter names correspond to the same parameter names listed
in the \f2newCDKDialog\f1 function.
X.RE
X
void drawCDKDialog(\f2dialog\f1, \f2box\f1);
X.RS 3
This function draws the dialog widget on the screen. The \f2box\f1 option 
draws the widget with or without a box.
X.RE
X
void eraseCDKDialog (\f2dialog\f1);
X.RS 3
This function removes the widget from the screen. This does \f4NOT\f1 destroy
the widget.
X.RE
X
void destroyCDKDialog (\f2dialog\f1);
X.RS 3
This function removes the widget from the screen and frees up any memory the
object may be using.
X.RE
X
void setCDKDialogPreProcess (\f2dialog\f1, \f2function\f1, \f2data\f2);
X.RS 3
This function allows the user to have the widget call a function after a key
is hit and before the key is applied to the widget. The parameter \f2function\f1
if of type \f4PROCESSFN\f1. The parameter \f2data\f1 is a pointer to 
\f4void\f1. To learn more about pre-processing read the \f4cdk_process\f1
manual page.
X.RE
X
void setCDKDialogPostProcess (\f2dialog\f1, \f2function\f1, \f2data\f2);
X.RS 3
This function allows the user to have the widget call a function after the
key has been applied to the widget.  The parameter \f2function\f1 if of type 
\f4PROCESSFN\f1. The parameter \f2data\f1 is a pointer to \f4void\f1. To 
learn more about post-processing read the \f4cdk_process\f1 manual page.
X.RE
X
void bindCDKObject (\f2widgetType\f1, \f2object\f1, \f2key\f1, \f2function\f1, \f2data\f1);
X.RS 3
This function allows the user to create special key bindings. The 
\f2widgetType\f1 parameter is a defined type which states what Cdk object 
type is being used.  To learn more about the type \f4EObjectType\f1 read 
the \f4cdk_binding\f1 manual page. The \f2object\f1 parameter is the pointer
to the widget object. The \f2key\f1 is the character to bind. The 
\f2function\f1 is the function type. To learn more about the key binding 
callback function types read the \f2cdk_binding\f1 manual page. The last 
parameter \f2data\f1 is a pointer to any data that needs to get passed to 
the callback function.
X.RE
X.SH KEY BINDINGS
When the widget is activated there are several default key bindings which will
help the user enter or manipulate the information quickly. The following table
outlines the keys and their actions for this widget.
X.LP
X.RS 3
X.nf
\f2Key          Action\f1
Left Arrow   Selects the button to the left of the current button.
Right Arrow  Selects the button to the right of the current button.
Tab          Selects the button to the right of the current button.
Space        Selects the button to the right of the current button.
Return       Exits the widget and returns an integer value
X             representing which button was selected.
Ctrl-N       Exits the widget and returns -1.
Escape       Exits the widget and returns -1.
Ctrl-L       Refreshes the screen.
X.fi
X.RE
X.SH SEE ALSO
X.BR cdk (3),
X.BR cdk_binding (3),
X.BR cdk_display (3),
X.BR cdk_process (3),
X.BR cdk_screen (3)
X.SH NOTES
X.PP
The header file \f4<cdk.h>\f1 automatically includes the header files
\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
The \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
X.PP
If you have \f4Ncurses\f1 installed on your machine add -DNCURSES to the 
compile line to include the Ncurses header files instead.
SHAR_EOF
  $shar_touch -am 0503190996 'man/dialog.3' &&
  chmod 0444 'man/dialog.3' ||
  echo 'restore of man/dialog.3 failed'
  shar_count="`wc -c < 'man/dialog.3'`"
  test 8137 -eq "$shar_count" ||
    echo "man/dialog.3: original size 8137, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= man/entry.3 ==============
if test -f 'man/entry.3' && test X"$1" != X"-c"; then
  echo 'x - skipping man/entry.3 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting man/entry.3 (binary)'
  sed 's/^X//' << 'SHAR_EOF' > _sharuue.tmp &&
begin 600 man/entry.3
M+F1E($ET"BYB<@HN:64@7%QN*"XD/CTS("YN92!<7"0S"BYE;"`N;F4@,PHN
M25`@(EQ<)#$B(%Q<)#(*+BX*+E1((&-D:U]E;G1R>2`S6"`B,#4@1&5C(#$Y
M.34B"BY32"!.04U%"FYE=T-$2T5N=')Y+"!A8W1I=F%T94-$2T5N=')Y+"!I
M;FIE8W1#1$M%;G1R>2P@<V5T0T1+16YT<GDL('-E=$-$2T5N=')Y0T(L(`ID
M<F%W0T1+16YT<GDL(&5R87-E0T1+16YT<GDL(&-L96%N0T1+16YT<GDL(&1E
M<W1R;WE#1$M%;G1R>2P@"G-E=$-$2T5N=')Y4')E4')O8V5S<RP@<V5T0T1+
M16YT<GE0;W-T4')O8V5S<R!<+2!#<F5A=&5S(&$@;6%N86=E9"!C=7)S97,@
M"F5N=')Y('=I9&=E="X*+E-((%-93D]04TE3"BY,4`HN0B!C8PHN4DD@(EL@
M(B`B9FQA9R(@(B!<?"Y<?"Y<?"X@72`B(")F:6QE(B`B(%Q\+EQ\+EQ\+B(*
M+D(@7"UL8V1K"BY222`B6R`B(")L:6)R87)Y(B`B(%Q\+EQ\+EQ\+B!=(@HN
M3%`*(VEN8VQU9&4@/&-D:RYH/@HN3%`*+D))(")#1$M%3E1262`J;F5W0T1+
M16YT<GD@*$-$2U-#4D5%3B`J(B`B8V1K<V-R965N(BP*+D))(")I;G0@(B`B
M>'!O<R(L"BY"22`B:6YT("(@(GEP;W,B+`HN0DD@(FEN="`B(")L<&]S(BP*
M+D))(")C:&%R("HB(")L86)E;"(L"BY"22`B8VAT>7!E("(@(F9I96QD071T
M<FEB=71E(BP*+D))(")C:'1Y<&4@(B`B9FEL;&5R0VAA<F%C=&5R(BP*+D))
M(")%1&ES<&QA>51Y<&4@(B`B9&ES<&QA>51Y<&4B+`HN0DD@(FEN="`B(")F
M:65L9%=I9'1H(BP*+D))(")I;G0@(B`B;6EN:6UU;4QE;F=T:"(L"BY"22`B
M:6YT("(@(FUA>&EM=6U,96YG=&@B+`HN0DD@(F)O;VQE86X@(B`B8F]X(BP*
M+D))(")B;V]L96%N("(@(G-H861O=R(I.PHN3%`*+D))(")C:&%R("IA8W1I
M=F%T94-$2T5N=')Y("A#1$M%3E1262`J(B`B96YT<GDB+`HN0DD@(F-H='EP
M92`J(B`B86-T:6]N<R(I.PHN3%`*+D))(")I;G0@:6YJ96-T0T1+16YT<GD@
M*$-$2T5.5%)9("HB(")E;G1R>2(L"BY"22`B8VAT>7!E("(@(FEN<'5T(BD[
M"BY,4`HN0DD@(G9O:60@<V5T0T1+16YT<GD@*$-$2T5.5%)9("HB(")E;G1R
M>2(L"BY"22`B8VAA<B`J(B`B=F%L=64B+`HN0DD@(FEN="`B(")M:6YI;75M
M3&5N9W1H(BP*+D))(")I;G0@(B`B;6%X:6UU;4QE;F=T:"(L"BY"22`B8F]O
M;&5A;B`B(")B;W@B*3L*+DQ0"BY"22`B=F]I9"!S971#1$M%;G1R>4-"("A#
M1$M%3E1262`J(B`B96YT<GDB+`HN0DD@(D5.5%)90T(@(B`B8V%L;$)A8VM&
M=6YC=&EO;B(I.PHN3%`*+D))(")V;VED(&1R87=#1$M%;G1R>2`H0T1+14Y4
M4ED@*B(@(F5N=')Y(BP*+D))(")B;V]L96%N("(@(F)O>"(I.PHN3%`*+D))
M(")V;VED(&5R87-E0T1+16YT<GD@*$-$2T5.5%)9("HB(")E;G1R>2(I.PHN
M3%`*+D))(")V;VED(&-L96%N0T1+16YT<GD@*$-$2T5.5%)9("HB(")E;G1R
M>2(I.PHN3%`*+D))(")V;VED(&1E<W1R;WE#1$M%;G1R>2`H0T1+14Y44ED@
M*B(@(F5N=')Y(BD["BY,4`HN0DD@(G9O:60@8FEN9$-$2T]B:F5C="`H14]B
M:F5C=%1Y<&4@(B`B=VED9V5T5'EP92(L"BY"22`B=F]I9"`J(B`B;V)J96-T
M(BP*+D))(")C:'1Y<&4B(")K97DB+`HN0DD@(D))3D1&3B(@(F9U;F-T:6]N
M(BP*+D))(")V;VED("HB(")D871A(BD["BY32"!$15-#4DE05$E/3@I4:&4@
M0V1K(&5N=')Y('=I9&=E="!C<F5A=&5S(&%N(&5N=')Y(&)O>"!W:71H(&$@
M;&%B96P@86YD(&%N(&5N=')Y(&9I96QD+B!4:&4@"F9O;&QO=VEN9R!A<F4@
M9G5N8W1I;VYS('=H:6-H(&-R96%T92!O<B!M86YI<'5L871E('1H92!#9&L@
M96YT<GD@8F]X('=I9&=E="X*"D-$2T5.5%)9("IN97=#1$M%;G1R>2`H7&8R
M<V-R965N7&8Q+"!<9C)X<&]S7&8Q+"!<9C)Y<&]S7&8Q+"!<9C)L<&]S7&8Q
M+"!<9C)L86)E;%QF,2P@7&8R9FEE;&1!='1R:6)U=&5<9C$L(%QF,F9I;&QE
M<D-H87)A8W1E<EQF,2P@7&8R9&ES<&QA>51Y<&5<9C$L(%QF,F9I96QD5VED
M=&A<9C$L(%QF,FUI;FEM=6U,96YG=&A<9C$L(%QF,FUA>&EM=6U,96YG=&A<
M9C$L(%QF,F-A;&QB86-K1G5N8W1I;VY<9C$L(%QF,F)O>%QF,2P@7&8R<VAA
M9&]W7&8Q*3L*+E)3(#,*5&AI<R!F=6YC=&EO;B!C<F5A=&5S(&$@<&]I;G1E
M<B!T;R!A;B!E;G1R>2!W:61G970N(%1H92!P87)A;65T97(@7&8R<V-R965N
M7&8Q"FES(&]F('1Y<&4@0T1+4T-2145.+B!4:&4@<&%R86UE=&5R(%QF,GAP
M;W-<9C$@8V]N=')O;',@=&AE('!L86-E;65N="!O9B!T:&4*;V)J96-T(&%L
M;VYG('1H92!H;W)I>F]N=&%L(&%X:7,[('=H:6-H(&UE86YS(&ET(&-A;B!T
M86ME(&%N(&EN=&5G97(@=F%L=64*;W(@=&AE('!R92UD969I;F5D('9A;'5E
M<R!O9B!<9C1,14947&8Q+"!<9C1224=(5%QF,2P@86YD(%QF-$-%3E1%4EQF
M,2X@5&AE"G!A<F%M971E<B!<9C)Y<&]S7&8Q(&-O;G1R;VQS('1H92!P;&%C
M96UE;G0@;V8@=&AE(&]B:F5C="!A;&]N9R!T:&4@=F5R=&EC86P*87AI<R!W
M:&EC:"!M96%N<R!I="!C86X@86-C97!T(&%N(&EN=&5G97(@=F%L=64@;W(@
M82!P<F4M9&5F:6YE9"!V86QU92!O9B`*7&8T5$]07&8Q+"!<9C1"3U143TU<
M9C$L(&%N9"!<9C1#14Y415)<9C$N(%1H92!P87)A;65T97(@7&8R;'!O<UQF
M,2!C;VYT<F]L<PIW:&5R92!T:&4@;&%B96P@:7,@=&\@8F4@<V5T+B!)="!C
M86X@=&%K92!A;B!I;G1E9V5R('9A;'5E(&]R(&]N92!O9B!T:&4@"G!R92UD
M969I;F5D('9A;'5E<SH@7&8T5$]07&8Q+"!<9C1"3U143TU<9C$L(%QF-$Q%
M1E1<9C$L(%QF-%))1TA47&8Q+"!A;F0@"EQF-$-%3E1%4EQF,2X@5&AE(%QF
M,FQA8F5L7&8Q('!A<F%M971E<B!I<R!T:&4@<W1R:6YG('=H:6-H('=I;&P@
M8F4@9&ES<&QA>65D"FEN('1H92!L86)E;"!O9B!T:&4@96YT<GD@9FEE;&0N
M(%1H92!<9C)F:65L9$%T=')I8G5T95QF,2!I<R!T:&4@871T<FEB=71E(&]F
M"G1H92!C:&%R86-T97)S('1O(&)E(&1I<W!L87EE9"!W:&5N('1H97D@87)E
M('1Y<&5D(&EN+B!<9C)F:6QL97)<9C$@:7,@=&AE(`IC:&%R86-T97(@=VAI
M8V@@:7,@=&\@8F4@9&ES<&QA>65D(&EN(&%N(&5M<'1Y('-P86-E(&EN('1H
M92!E;G1R>2!F:65L9"X@5&AE"G!A<F%M971E<B!<9C)D:7-P;&%Y5'EP95QF
M,2!T96QL<R!H;W<@=&AE(&5N=')Y(&9I96QD('=I;&P@8F5H879E('=H96X@
M82`*8VAA<F%C=&5R(&ES(&5N=&5R960@:6YT;R!T:&4@9FEE;&0N(%1H92!F
M;VQL;W=I;F<@=&%B;&4@;W5T;&EN97,@=F%L:60@=F%L=65S"F9O<B!T:&ES
M(&9I96QD(&%N9"!W:&%T('1H92!R97-U;'0@:7,N"BY,4`HN4E,@-@HN;F8@
M"EQF,D1I<W!L87E?5'EP92`@("`@(%)E<W5L=%QF,0IV0TA!4B`@("`@("`@
M("`@("!/;FQY(&%C8V5P=',@86QP:&%B971I8R!C:&%R86-T97)S+@IV3$-(
M05(@("`@("`@("`@("!/;FQY(&%C8V5P=',@86QP:&%B971I8R!C:&%R86-T
M97)S+@H@("`@("`@("`@("`@("`@("!-87!S('1H92!C:&%R86-T97(@=&\@
M;&]W97(@8V%S90H@("`@("`@("`@("`@("`@("!W:&5N(&$@8VAA<F%C=&5R
M(&AA<R!B965N(&%C8V5P=&5D+@IV54-(05(@("`@("`@("`@("!/;FQY(&%C
M8V5P=',@86QP:&%B971I8R!C:&%R86-T97)S+@H@("`@("`@("`@("`@("`@
M("!-87!S('1H92!C:&%R86-T97(@=&\@=7!P97(@8V%S90H@("`@("`@("`@
M("`@("`@("!W:&5N(&$@8VAA<F%C=&5R(&AA<R!B965N(&%C8V5P=&5D+@IV
M2$-(05(@("`@("`@("`@("!/;FQY(&%C8V5P=',@86QP:&%B971I8R!C:&%R
M86-T97)S+@H@("`@("`@("`@("`@("`@("!$:7-P;&%Y<R!A(%QF-"Y<9C$@
M=VAE;B!A(&-H87)A8W1E<@H@("`@("`@("`@("`@("`@("!H87,@8F5E;B!A
M8V-E<'1E9"X*=E5(0TA!4B`@("`@("`@("`@3VYL>2!A8V-E<'1S(&%L<&AA
M8F5T:6,@8VAA<F%C=&5R<RX*("`@("`@("`@("`@("`@("`@1&ES<&QA>7,@
M82!<9C0N7&8Q(&%N9"!M87!S('1H90H@("`@("`@("`@("`@("`@("!C:&%R
M86-T97(@=&\@=7!P97(@8V%S92!W:&5N(&$*("`@("`@("`@("`@("`@("`@
M8VAA<F%C=&5R(&AA<R!B965N(&%C8V5P=&5D+@IV3$A#2$%2("`@("`@("`@
M("!/;FQY(&%C8V5P=',@86QP:&%B971I8R!C:&%R86-T97)S+@H@("`@("`@
M("`@("`@("`@("!$:7-P;&%Y<R!A(%QF-"Y<9C$@86YD(&UA<',@=&AE"B`@
M("`@("`@("`@("`@("`@(&-H87)A8W1E<B!T;R!L;W=E<B!C87-E('=H96X@
M80H@("`@("`@("`@("`@("`@("!C:&%R86-T97(@:&%S(&)E96X@86-C97!T
M960N"G9)3E0@("`@("`@("`@("`@($]N;'D@86-C97!T<R!N=6UE<FEC(&-H
M87)A8W1E<G,N"G9(24Y4("`@("`@("`@("`@($]N;'D@86-C97!T<R!N=6UE
M<FEC(&-H87)A8W1E<G,N"B`@("`@("`@("`@("`@("`@($1I<W!L87ES(&$@
M7&8T+EQF,2!W:&5N(&$@8VAA<F%C=&5R"B`@("`@("`@("`@("`@("`@(&AA
M<R!B965N(&%C8V5P=&5D+@IV34E8140@("`@("`@("`@("!!8V-E<'1S(&%N
M>2!C:&%R86-T97(@='EP97,N"G9,34E8140@("`@("`@("`@($%C8V5P=',@
M86YY(&-H87)A8W1E<B!T>7!E<RX*("`@("`@("`@("`@("`@("`@36%P<R!T
M:&4@8VAA<F%C=&5R('1O(&QO=V5R(&-A<V4*("`@("`@("`@("`@("`@("`@
M=VAE;B!A;B!A;'!H86)E=&EC(&-H87)A8W1E<B!H87,*("`@("`@("`@("`@
M("`@("`@8F5E;B!A8V-E<'1E9"X*=E5-25A%1"`@("`@("`@("`@06-C97!T
M<R!A;GD@8VAA<F%C=&5R('1Y<&5S+@H@("`@("`@("`@("`@("`@("!-87!S
M('1H92!C:&%R86-T97(@=&\@=7!P97(@8V%S90H@("`@("`@("`@("`@("`@
M("!W:&5N(&%N(&%L<&AA8F5T:6,@8VAA<F%C=&5R(&AA<PH@("`@("`@("`@
M("`@("`@("!B965N(&%C8V5P=&5D+@IV2$U)6$5$("`@("`@("`@("!!8V-E
M<'1S(&%N>2!C:&%R86-T97(@='EP97,N"B`@("`@("`@("`@("`@("`@($1I
M<W!L87ES(&$@7&8T+EQF,2!W:&5N(&$@8VAA<F%C=&5R"B`@("`@("`@("`@
M("`@("`@(&AA<R!B965N(&%C8V5P=&5D+@IV3$A-25A%1"`@("`@("`@("!!
M8V-E<'1S(&%N>2!C:&%R86-T97(@='EP97,N"B`@("`@("`@("`@("`@("`@
M($1I<W!L87ES(&$@7&8T+EQF,2!A;F0@;6%P<R!T:&4*("`@("`@("`@("`@
M("`@("`@8VAA<F%C=&5R('1O(&QO=V5R(&-A<V4@=VAE;B!A"B`@("`@("`@
M("`@("`@("`@(&-H87)A8W1E<B!H87,@8F5E;B!A8V-E<'1E9"X*=E5(34E8
M140@("`@("`@("`@06-C97!T<R!A;GD@8VAA<F%C=&5R('1Y<&5S+@H@("`@
M("`@("`@("`@("`@("!$:7-P;&%Y<R!A(%QF-"Y<9C$@86YD(&UA<',@=&AE
M"B`@("`@("`@("`@("`@("`@(&-H87)A8W1E<B!T;R!U<'!E<B!C87-E('=H
M96X@80H@("`@("`@("`@("`@("`@("!C:&%R86-T97(@:&%S(&)E96X@86-C
M97!T960N"G9624573TY,62`@("`@("`@(%5N961I=&%B;&4@9FEE;&0N"BYF
M:0HN4D4*+E)3(#,*+DQ0"E1H92!<9C)F:65L9%=I9'1H7&8Q('!A<F%M971E
M<B!S=&%T97,@:&]W('=I9&4@=&AE(&9I96QD('=I;&P@8F4N(%1H92!P87)A
M;65T97(*7&8R;6EN:6UU;4QE;F=T:%QF,2!S=&%T97,@:&]W(&UA;GD@8VAA
M<F%C=&5R<R!H879E('1O(&)E(&5N=&5R960@8F5F;W)E('1H90IU<V4@8V%N
M(&5X:70@=&AE(&5N=')Y(&9I96QD+B!4:&4@7&8R;6%X:6UU;4QE;F=T:%QF
M,2!P87)A;65T97(@<V5T<R!T:&4@"FUA>&EM=6T@;G5M8F5R(&]F(&-H87)A
M8W1E<G,@=&AA="!C86X@8F4@96YT97)E9"X@5&AE(%QF,F)O>%QF,2!P87)A
M;65T97(@"G-T871E<R!W:&5T:&5R('1H92!W:61G970@=VEL;"!B92!D<F%W
M;B!W:71H(&$@8F]X(&%R;W5N9"!I="!O<B!N;W0N(%1H92`*7&8R<VAA9&]W
M7&8Q('!A<F%M971E<B!A8V-E<'1S(&$@8F]O;&5A;B!V86QU92!T;R!T=7)N
M('1H92!S:&%D;W<@;VX@;W(@;V9F(`IA<F]U;F0@=&AI<R!W:61G970N($EF
M('1H92!W:61G970@8V]U;&0@;F]T(&)E(&-R96%T960@=&AE;B!A($Y53$P@
M<&]I;G1E<B!I<R`*<F5T=7)N960N"BY210H*8VAA<B`J86-T:79A=&5#1$M%
M;G1R>2`H7&8R96YT<GE<9C$L(%QF,F%C=&EO;G-<9C$I.PHN4E,@,PI4:&ES
M(&9U;F-T:6]N(&%C=&EV871E<R!T:&4@96YT<GD@=VED9V5T(&%N9"!L971S
M('1H92!U<V5R(&EN=&5R86-T('=I=&@@=&AE"G=I9&=E="X@5&AE('!A<F%M
M971E<B!<9C)A8W1I;VYS7&8Q(&ES(&%N(&%R<F%Y(&]F(%QF-&-H='EP95QF
M,2X@268@"EQF,F%C=&EO;G-<9C$@:7,@<&%S<V5D('=I=&@@82!N;VXM3E5,
M3"!V86QU92P@=&AE(&-H87)A8W1E<G,@:6X@=&AE(&%R<F%Y('=I;&P@"F)E
M(&EN<V5R=&5D(&EN=&\@=&AE('=I9&=E="X@5&\@86-T:79A=&4@=&AE('=I
M9&=E="!I;G1E<F%T:79E;'D@<&%S<R!I;B!A($Y53$P*<&]I;G1E<B!F;W(@
M7&8R86-T:6]N<UQF,2X@268@=&AE(&-H87)A8W1E<B!E;G1E<F5D(&EN=&\@
M=&AI<R!W:61G970@:7,*7&8T4D5455).7&8Q(&]R(%1!0B!T:&5N('1H:7,@
M9G5N8W1I;VX@=VEL;"!R971U<FX@82!<9C1C:&%R("I<9C$@;V8@=&AE(`II
M;F9O<FUA=&EO;B!W:&EC:"!W87,@='EP960@:6X@=&AE(&9I96QD+B!)9B!T
M:&4@8VAA<F%C=&5R(&5N=&5R960@=V%S"EQF-$-44DPM3EQF,2!T:&5N('1H
M:7,@9G5N8W1I;VX@=VEL;"!R971U<FX@=&AE('9A;'5E(&]F('1H92!G;&]B
M86P@=F%R:6%B;&4*7&8T1T5A<FQY17AI=%QF,2X*+E)%"@IC:&%R("II;FIE
M8W1#1$M%;G1R>2`H7&8R96YT<GE<9C$L(%QF,F-H87)A8W1E<EQF,2D["BY2
M4R`S"E1H:7,@9G5N8W1I;VX@:6YJ96-T<R!A('-I;F=L92!C:&%R86-T97(@
M:6YT;R!T:&4@=VED9V5T+B!4:&4@<&%R86UE=&5R(`I<9C)E;G1R>5QF,2!I
M<R!A('!O:6YT97(@=&\@82!D969I;F5D(&5N=')Y('=I9&=E="X@5&AE('!A
M<F%M971E<B`*7&8R8VAA<F%C=&5R7&8Q(&ES(&]F('1Y<&4@7&8T8VAT>7!E
M7&8Q(&%N9"!I<R!T:&4@8VAA<F%C=&5R('1O(&EN:F5C="!I;G1O"G1H92!W
M:61G970N($EF('1H92!C:&%R86-T97(@:6YJ96-T960@:6YT;R!T:&ES('=I
M9&=E="!W87,@;VYE(&]F(%QF-%)%5%523EQF,0IO<B!<9C1404)<9C$@=&AE
M;B!T:&4@:6YF;W)M871I;VX@=VAI8V@@=V%S('1Y<&5D(&EN=&\@=&AE(&9I
M96QD('=I;&P@8F4@"G)E='5R;F5D+B!/=&AE<G=I<V4@=&AE(&=L;V)A;"!V
M87)I86)L92!<9C1'16%R;'E%>&ET7&8Q(&ES(')E='5R;F5D+@HN4D4*"G9O
M:60@<V5T0T1+16YT<GD@*%QF,F5N=')Y7&8Q+"!<9C)V86QU95QF,2P@7&8R
M;6EN:6UU;4QE;F=T:%QF,2P@7&8R;6%X:6UU;4QE;F=T:%QF,2P@7&8R8F]X
M7&8Q*3L*+E)3(#,*5&AI<R!F=6YC=&EO;B!L971S('1H92!P<F]G<F%M;65R
M(&UO9&EF>2!C97)T86EN(&5L96UE;G1S(&]F(&%N(&%L<F5A9'D@9&5F:6YE
M9`IE;G1R>2!W:61G970N(%1H92!<9C)V86QU95QF,2!P87)A;65T97(@<V5T
M<R!T:&4@=F%L=64@;V8@=&AE(&-O;G1E;G1S(&]F('1H90IE;G1R>2!F:65L
M9"X@5&AE(&]T:&5R('!A<F%M971E<B!N86UE<R!C;W)R97-P;VYD('1O('1H
M92!S86UE('!A<F%M971E<B!N86UE<PIL:7-T960@:6X@=&AE(%QF-&YE=T-$
M2T5N=')Y7&8Q(&9U;F-T:6]N+@HN4D4@"@IV;VED('-E=$-$2T5N=')Y0T(@
M*%QF,F5N=')Y7&8Q+"!<9C)C86QL8F%C:T9U;F-T:6]N7&8Q*3L*+E)3(#,*
M5&AI<R!F=6YC=&EO;B!A;&QO=W,@=&AE('!R;V=R86UM97(@=&\@<V5T(&$@
M9&EF9F5R96YT('=I9&=E="!I;G!U="!H86YD;&5R+@I4:&4@<&%R86UE=&5R
M(%QF,F-A;&QB86-K1G5N8W1I;VY<9C$@:7,@;V8@='EP92!<9C1%3E1264-"
M7&8Q+B!4:&4@8W5R<F5N="`*9&5F875L="!F=6YC=&EO;B!I<R!<9C1#1$M%
M;G1R>4-A;&Q"86-K7&8Q+@HN4D4*"G9O:60@9')A=T-$2T5N=')Y*%QF,F5N
M=')Y7&8Q+"!<9C)B;WA<9C$I.PHN4E,@,PI4:&ES(&9U;F-T:6]N(&1R87=S
M('1H92!E;G1R>2!W:61G970@;VX@=&AE('-C<F5E;BX@5&AE(%QF,F)O>%QF
M,2!O<'1I;VX@"F1R87=S('1H92!W:61G970@=VET:"!O<B!W:71H;W5T(&$@
M8F]X+@HN4D4*"G9O:60@97)A<V5#1$M%;G1R>2`H7&8R96YT<GE<9C$I.PHN
M4E,@,PI4:&ES(&9U;F-T:6]N(')E;6]V97,@=&AE('=I9&=E="!F<F]M('1H
M92!S8W)E96XN(%1H:7,@9&]E<R!<9C1.3U1<9C$@9&5S=')O>0IT:&4@=VED
M9V5T+@HN4D4*"G9O:60@8VQE86Y#1$M%;G1R>2`H7&8R96YT<GE<9C$I.PHN
M4E,@,PI4:&ES(&9U;F-T:6]N(&-L96%R<R!T:&4@:6YF;W)M871I;VX@9G)O
M;2!T:&4@9FEE;&0N"BY210H*=F]I9"!D97-T<F]Y0T1+16YT<GD@*%QF,F5N
M=')Y7&8Q*3L*+E)3(#,*5&AI<R!F=6YC=&EO;B!R96UO=F5S('1H92!W:61G
M970@9G)O;2!T:&4@<V-R965N(&%N9"!F<F5E<R!U<"!A;GD@;65M;W)Y('1H
M90IO8FIE8W0@;6%Y(&)E('5S:6YG+@HN4D4*"G9O:60@<V5T0T1+16YT<GE0
M<F50<F]C97-S("A<9C)E;G1R>5QF,2P@7&8R9G5N8W1I;VY<9C$L(%QF,F1A
M=&%<9C(I.PHN4E,@,PI4:&ES(&9U;F-T:6]N(&%L;&]W<R!T:&4@=7-E<B!T
M;R!H879E('1H92!W:61G970@8V%L;"!A(&9U;F-T:6]N(&%F=&5R(&$@:V5Y
M"FES(&AI="!A;F0@8F5F;W)E('1H92!K97D@:7,@87!P;&EE9"!T;R!T:&4@
M=VED9V5T+B!4:&4@<&%R86UE=&5R(%QF,F9U;F-T:6]N7&8Q"FEF(&]F('1Y
M<&4@7&8T4%)/0T534T9.7&8Q+B!4:&4@<&%R86UE=&5R(%QF,F1A=&%<9C$@
M:7,@82!P;VEN=&5R('1O(`I<9C1V;VED7&8Q+B!4;R!L96%R;B!M;W)E(&%B
M;W5T('!R92UP<F]C97-S:6YG(')E860@=&AE(%QF-&-D:U]P<F]C97-S7&8Q
M"FUA;G5A;"!P86=E+@HN4D4*(`IV;VED('-E=$-$2T5N=')Y4&]S=%!R;V-E
M<W,@*%QF,F5N=')Y7&8Q+"!<9C)F=6YC=&EO;EQF,2P@7&8R9&%T85QF,BD[
M"BY24R`S"E1H:7,@9G5N8W1I;VX@86QL;W=S('1H92!U<V5R('1O(&AA=F4@
M=&AE('=I9&=E="!C86QL(&$@9G5N8W1I;VX@869T97(@=&AE"FME>2!H87,@
M8F5E;B!A<'!L:65D('1O('1H92!W:61G970N("!4:&4@<&%R86UE=&5R(%QF
M,F9U;F-T:6]N7&8Q(&EF(&]F('1Y<&4*7&8T4%)/0T534T9.7&8Q+B!4:&4@
M<&%R86UE=&5R(%QF,F1A=&%<9C$@:7,@82!P;VEN=&5R('1O(%QF-'9O:61<
M9C$N(%1O"FQE87)N(&UO<F4@86)O=70@<&]S="UP<F]C97-S:6YG(')E860@
M=&AE(%QF-&-D:U]P<F]C97-S7&8Q(&UA;G5A;"!P86=E+@HN4D4*"G9O:60@
M8FEN9$-$2T]B:F5C="`H7&8R=VED9V5T5'EP95QF,2P@7&8R;V)J96-T7&8Q
M+"!<9C)K97E<9C$L(%QF,F9U;F-T:6]N7&8Q+"!<9C)D871A7&8Q*3L*+E)3
M(#,*5&AI<R!F=6YC=&EO;B!A;&QO=W,@=&AE('5S97(@=&\@8W)E871E('-P
M96-I86P@:V5Y(&)I;F1I;F=S+B!4:&4@"EQF,G=I9&=E=%1Y<&5<9C$@<&%R
M86UE=&5R(&ES(&$@9&5F:6YE9"!T>7!E('=H:6-H('-T871E<R!W:&%T($-D
M:R!O8FIE8W0@='EP90II<R!B96EN9R!U<V5D+B!4;R!L96%R;B!M;W)E(&%B
M;W5T('1H92!T>7!E(%QF-$5/8FIE8W14>7!E7&8Q(')E860@=&AE(`I<9C1C
M9&M?8FEN9&EN9UQF,2!M86YU86P@<&%G92X@5&AE(%QF,F]B:F5C=%QF,2!P
M87)A;65T97(@:7,@=&AE('!O:6YT97(@=&\@=&AE"G=I9&=E="!O8FIE8W0N
M(%1H92!<9C)K97E<9C$@:7,@=&AE(&-H87)A8W1E<B!T;R!B:6YD+B!4:&4@
M7&8R9G5N8W1I;VY<9C$@:7,@"G1H92!F=6YC=&EO;B!T>7!E+B!4;R!L96%R
M;B!M;W)E(&%B;W5T('1H92!K97D@8FEN9&EN9R!C86QL8F%C:R!F=6YC=&EO
M;B!T>7!E<PIR96%D('1H92!<9C1C9&M?8FEN9&EN9UQF,2!M86YU86P@<&%G
M92X@5&AE(&QA<W0@<&%R86UE=&5R(%QF,F1A=&%<9C$@:7,@82`*<&]I;G1E
M<B!T;R!A;GD@9&%T82!T:&%T(&YE961S('1O(&=E="!P87-S960@=&\@=&AE
M(&-A;&QB86-K(&9U;F-T:6]N+@HN4D4*"BY32"!+15D@0DE.1$E.1U,*5VAE
M;B!T:&4@=VED9V5T(&ES(&%C=&EV871E9"!T:&5R92!A<F4@<V5V97)A;"!D
M969A=6QT(&ME>2!B:6YD:6YG<R!W:&EC:"!W:6QL"FAE;'`@=&AE('5S97(@
M96YT97(@;W(@;6%N:7!U;&%T92!T:&4@:6YF;W)M871I;VX@<75I8VML>2X@
M5&AE(&9O;&QO=VEN9R!T86)L90IO=71L:6YE<R!T:&4@:V5Y<R!A;F0@=&AE
M:7(@86-T:6]N<R!F;W(@=&AI<R!W:61G970N"BY,4`HN4E,@,PHN;F8*7&8R
M2V5Y("`@("`@("`@($%C=&EO;EQF,0I,969T($%R<F]W("!-;W9E<R!T:&4@
M8W5R<V]R('1H92!T:&4@;&5F="X*4FEG:'0@07)R;W<@36]V97,@=&AE(&-U
M<G-O<B!T:&4@=&AE(')I9VAT+@I$96QE=&4@("`@("!$96QE=&5S('1H92!C
M:&%R86-T97(@=&\@=&AE(&QE9G0@;V8@=&AE(&-U<G-O<BX*0F%C:W-P86-E
M("`@1&5L971E<R!T:&4@8VAA<F%C=&5R('1O('1H92!L969T(&]F('1H92!C
M=7)S;W(N"E)E='5R;B`@("`@($5X:71S('1H92!W:61G970@86YD(')E='5R
M;G,@82!C:&%R("H@<F5P<F5S96YT:6YG"B`@("`@("`@("`@('1H92!I;F9O
M<FUA=&EO;B!W:&EC:"!W87,@='EP960@:6YT;R!T:&4@9FEE;&0N"E1A8B`@
M("`@("`@($5X:71S('1H92!W:61G970@86YD(')E='5R;G,@82!C:&%R("H@
M<F5P<F5S96YT:6YG"B`@("`@("`@("`@('1H92!I;F9O<FUA=&EO;B!W:&EC
M:"!W87,@='EP960@:6YT;R!T:&4@9FEE;&0N"D-T<FPM4"`@("`@(%!A<W1E
M<R!W:&%T979E<B!I<R!I;B!T:&4@<&%S=&4@8G5F9F5R+"!I;G1O('1H92!W
M:61G970N"D-T<FPM2R`@("`@($-U=',@=&AE(&-O;G1E;G1S(&9R;VT@=&AE
M('=I9V1T92!A;F0@<V%V97,@82!C;W!Y(&EN(`H@("`@("`@("`@("!T:&4@
M<&%S=&4@8G5F9F5R+@I#=')L+50@("`@("!#;W!I97,@=&AE(&-O;G1E;G1S
M(&]F('1H92!W:61G970@:6YT;R!T:&4@<&%S=&4@8G5F9F5R+@I#=')L+44@
M("`@("!%<F%S97,@=&AE(&-O;G1E;G1S(&]F('1H92!W:61G970N"D-T<FPM
M3B`@("`@($5X:71S('1H92!W:61G970@86YD('1H92!V86QU92!S=&]R960@
M:6X@=&AE(&=L;V)A;`H@("`@("`@("`@("!V87)I86)L92!<9C1'16%R;'E%
M>&ET7&8Q+@I#=')L+4P@("`@("!2969R97-H97,@=&AE('-C<F5E;BX*+F9I
M"BY210HN4T@@4T5%($%,4T\*+D)2(&-D:R`H,U@I+`HN0E(@8V1K7V)I;F1I
M;F<@*#-8*2P*+D)2(&-D:U]D:7-P;&%Y("@S6"DL"BY"4B!C9&M?<')O8V5S
M<R`H,U@I+`HN0E(@8V1K7W-C<F5E;B`H,U@I"BY32"!.3U1%4PHN4%`*5&AE
M(&AE861E<B!F:6QE(%QF-#QC9&LN:#Y<9C$@875T;VUA=&EC86QL>2!I;F-L
M=61E<R!T:&4@:&5A9&5R(&9I;&5S"EQF-#QC=7)S97,N:#Y<9C$L(%QF-#QS
M=&1L:6(N:#Y<9C$L(%QF-#QS=')I;F<N:#Y<9C$L(%QF-#QC='EP92YH/EQF
M,2P*7&8T/'5N:7-T9"YH/EQF,2P@7&8T/&1I<F5N="YH/EQF,2P@7&8T/'1I
M;64N:#Y<9C$L(%QF-#QE<G)N;RYH/EQF,2P*7&8T/'!W9"YH/EQF,2P@7&8T
M/&=R<"YH/EQF,2P@7&8T/'-Y<R]S=&%T+F@^7&8Q+"!A;F0@7&8T/'-Y<R]T
M>7!E<RYH/EQF,2X*5&AE(%QF-#QC=7)S97,N:#Y<9C$@:&5A9&5R(&9I;&4@
M:6YC;'5D97,@7&8T/'-T9&EO+F@^7&8Q(&%N9"!<9C0\=6YC=')L+F@^7&8Q
M+@HN4%`*268@>6]U(&AA=F4@7&8T3F-U<G-E<UQF,2!I;G-T86QL960@;VX@
M>6]U<B!M86-H:6YE(&%D9"`M1$Y#55)315,@=&\@=&AE(`IC;VUP:6QE(&QI
M;F4@=&\@:6YC;'5D92!T:&4@3F-U<G-E<R!H96%D97(@9FEL97,@:6YS=&5A
#9"X*
`
end
SHAR_EOF
  echo 'uudecoding file man/entry.3' &&
  uudecode _sharuue.tmp < _sharuue.tmp && rm -f _sharuue.tmp &&
  $shar_touch -am 0503190996 'man/entry.3' &&
  chmod 0444 'man/entry.3' ||
  echo 'restore of man/entry.3 failed'
  shar_count="`wc -c < 'man/entry.3'`"
  test 11568 -eq "$shar_count" ||
    echo "man/entry.3: original size 11568, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= man/graph.3 ==============
if test -f 'man/graph.3' && test X"$1" != X"-c"; then
  echo 'x - skipping man/graph.3 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting man/graph.3 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'man/graph.3' &&
X.de It
X.br
X.ie \\n(.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH cdk_graph 3 "05 Dec 1995"
X.SH NAME
newCDKGraph, setCDKGraph, drawCDKGraph, eraseCDKGraph, 
destroyCDKGraph \- Creates a managed curses graph widget.
X.SH SYNOPSIS
X.LP
X.B cc
X.RI "[ " "flag" " \|.\|.\|. ] " "file" " \|.\|.\|."
X.B \-lcdk
X.RI "[ " "library" " \|.\|.\|. ]"
X.LP
#include <cdk.h>
X.LP
X.BI "CDKGRAPH *newCDKGraph (CDKSCREEN *" "cdkscreen",
X.BI "int " "xpos",
X.BI "int " "ypos",
X.BI "int " "height",
X.BI "int " "width",
X.BI "char *" "title",
X.BI "char *" "xtitle",
X.BI "char *" "ytitle");
X.LP
X.BI "void setCDKGraph (CDKGRAPH *" "graph",
X.BI "int *" "values",
X.BI "int " "valueCount",
X.BI "char *" "graphCharacters",
X.BI "boolean " "startAtZero",
X.BI "EGraphDisplayType " "displayType");
X.LP
X.BI "void drawCDKGraph (CDKGRAPH *" "graph",
X.BI "boolean " "box");
X.LP
X.BI "void eraseCDKGraph (CDKGRAPH *" "graph");
X.LP
X.BI "void destroyCDKGraph (CDKGRAPH *" "graph");
X.LP
X.SH DESCRIPTION
The Cdk graph widget creates a graph widget. This widget can draw a graph in
both plot mode and line mode. The following are functions which create or 
manipulate the Cdk graph box widget.
X
CDKGRAPH *newCDKGraph (\f2screen\f1, \f2xpos\f1, \f2ypos\f1, \f2height\f1, \f2width\f1, \f2title\f1, \f2xtitle\f1, \f2ytitle\f1);
X.RS 3
This function creates a pointer to a graph widget. The parameter \f2screen\f1
is of type CDKSCREEN. The parameter \f2xpos\f1 controls the placement of the
object along the horizontal axis; which means it can take an integer value
or the pre-defined values of \f4LEFT\f1, \f4RIGHT\f1, and \f4CENTER\f1. The
parameter \f2ypos\f1 controls the placement of the object along the vertical
axis which means it can accept an integer value or a pre-defined value of 
\f4TOP\f1, \f4BOTTOM\f1, and \f4CENTER\f1. The parameters \f2height\f1 and 
\f2width\f1 specify the actual window height and width respectively. The
three parameters: \f2title\f1, \f2xtitle\f1, and \f2ytitle\f1, are the graph
title, the X axis title, and the Y axis title respectively. If the widget
could not be created then a NULL pointer is returned.
X.RE
X
void setCDKGraph (\f2graph\f1, \f2values\f1, \f2valueCount\f1, \f2graphCharacters\f1, \f2startAtZero\f1, \f2displayType\f1);
X.RS 3
This function lets the programmer set the specific values of the graph widget.
The parameter \f2values\f1 is an integer array of the values to display in the
widget; \f2valueCount\f1 is the number of values in the array. The parameter
\f2graphCharacters\f1 is an array of the characters to use for each graph point.
The parameter \f2startAtZero\f1 states whether you want the graph to start at
zero or the lowest values of the X and Y axis'. The parameter \f2displayType\f1
accepts either \f4vPLOT\f1, to make the graph draw the values as a plot graph,
or \f4vLINE\f1 to draw the values as a line graph.
X.RE
X
void drawCDKGraph(\f2graph\f1, \f2box\f1);
X.RS 3
This function draws the graph widget on the screen. The \f2box\f1 option 
draws the widget with or without a box.
X.RE
X
void eraseCDKGraph (\f2graph\f1);
X.RS 3
This function removes the widget from the screen. This does \f4NOT\f1 destroy
the widget.
X.RE 
X
void destroyCDKGraph (\f2graph\f1);
X.RS 3
This function removes the widget from the screen and frees up any memory the
object may be using.
X.RE
X.SH SEE ALSO
X.BR cdk (3),
X.BR cdk_binding (3),
X.BR cdk_display (3),
X.BR cdk_screen (3)
X.SH NOTES
X.PP
The header file \f4<cdk.h>\f1 automatically includes the header files
\f4<curses.h>\f1, \f4<stdlib.h>\f1, \f4<string.h>\f1, \f4<ctype.h>\f1,
\f4<unistd.h>\f1, \f4<dirent.h>\f1, \f4<time.h>\f1, \f4<errno.h>\f1,
\f4<pwd.h>\f1, \f4<grp.h>\f1, \f4<sys/stat.h>\f1, and \f4<sys/types.h>\f1.
The \f4<curses.h>\f1 header file includes \f4<stdio.h>\f1 and \f4<unctrl.h>\f1.
X.PP
If you have \f4Ncurses\f1 installed on your machine add -DNCURSES to the 
compile line to include the Ncurses header files instead.
SHAR_EOF
  $shar_touch -am 0503190996 'man/graph.3' &&
  chmod 0444 'man/graph.3' ||
  echo 'restore of man/graph.3 failed'
  shar_count="`wc -c < 'man/graph.3'`"
  test 3889 -eq "$shar_count" ||
    echo "man/graph.3: original size 3889, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= man/fselect.3 ==============
if test -f 'man/fselect.3' && test X"$1" != X"-c"; then
  echo 'x - skipping man/fselect.3 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting man/fselect.3 (binary)'
  sed 's/^X//' << 'SHAR_EOF' > _sharuue.tmp &&
begin 600 man/fselect.3
M+F1E($ET"BYB<@HN:64@7%QN*"XD/CTS("YN92!<7"0S"BYE;"`N;F4@,PHN
M25`@(EQ<)#$B(%Q<)#(*+BX*+E1((&-D:U]F<V5L96-T(#,@(C`U($1E8R`Q
M.3DU(@HN4T@@3D%-10IN97=#1$M&<V5L96-T+"!A8W1I=F%T94-$2T9S96QE
M8W0L('-E=$-$2T9S96QE8W0L(&1R87=#1$M&<V5L96-T+"`*97)A<V5#1$M&
M<V5L96-T+"!D97-T<F]Y0T1+1G-E;&5C="!<+2`*0W)E871E<R!A(&UA;F%G
M960@8W5R<V5S(&9I;&4@<V5L96-T;W(@=VED9V5T+@HN4T@@4UE.3U!325,*
M+DQ0"BY"(&-C"BY222`B6R`B(")F;&%G(B`B(%Q\+EQ\+EQ\+B!=("(@(F9I
M;&4B("(@7'PN7'PN7'PN(@HN0B!<+6QC9&L*+E))(");("(@(FQI8G)A<GDB
M("(@7'PN7'PN7'PN(%TB"BY,4`HC:6YC;'5D92`\8V1K+F@^"BY,4`HN0DD@
M(D-$2T9314Q%0U0@*FYE=T-$2T9S96QE8W0@*$-$2U-#4D5%3B`J(B`B8V1K
M<V-R965N(BP*+D))(")I;G0@(B`B>'!O<R(L"BY"22`B:6YT("(@(GEP;W,B
M+`HN0DD@(FEN="`B(")H96EG:'0B+`HN0DD@(FEN="`B(")W:61T:"(L"BY"
M22`B8VAT>7!E("(@(F9I96QD071T<FEB=71E(BP*+D))(")C:'1Y<&4@(B`B
M9FEL;&5R0VAA<F%C=&5R(BP*+D))(")C:'1Y<&4@(B`B:&EG:&QI9VAT(BP*
M+D))(")C:&%R("HB(")D:7)!='1R:6)U=&5S(BP*+D))(")C:&%R("HB(")F
M:6QE071T<FEB=71E<R(L"BY"22`B8VAA<B`J(B`B;&EN:T%T=')I8G5T92(L
M"BY"22`B8VAA<B`J(B`B<V]C:T%T=')I8G5T92(L"BY"22`B8F]O;&5A;B`B
M(")B;W@B+`HN0DD@(F)O;VQE86X@(B`B<VAA9&]W(BD["BY,4`HN0DD@(F-H
M87(@*F%C=&EV871E0T1+1G-E;&5C="`H0T1+1E-%3$5#5"`J(B`B9G-E;&5C
M="(I.PHN3%`*+D))(")V;VED('-E=$-$2T9S96QE8W0@*$-$2T9314Q%0U0@
M*B(@(F9S96QE8W0B+`HN0DD@(F-H='EP92`B(")F:65L9$%T=')I8G5T92(L
M"BY"22`B8VAT>7!E("(@(F9I;&QE<D-H87)A8W1E<B(L"BY"22`B8VAT>7!E
M("(@(FAI9VAL:6=H="(L"BY"22`B8VAA<B`J(B`B9&ER071T<FEB=71E<R(L
M"BY"22`B8VAA<B`J(B`B9FEL94%T=')I8G5T97,B+`HN0DD@(F-H87(@*B(@
M(FQI;FM!='1R:6)U=&4B+`HN0DD@(F-H87(@*B(@(G-O8VM!='1R:6)U=&4B
M+`HN0DD@(F)O;VQE86X@(B`B8F]X(BD["BY,4`HN0DD@(G9O:60@9')A=T-$
M2T9S96QE8W0@*$-$2T9314Q%0U0@*B(@(F9S96QE8W0B+`HN0DD@(F)O;VQE
M86X@(B`B8F]X(BD["BY,4`HN0DD@(G9O:60@97)A<V5#1$M&<V5L96-T("A#
M1$M&4T5,14-4("HB(")F<V5L96-T(BD["BY,4`HN0DD@(G9O:60@9&5S=')O
M>4-$2T9S96QE8W0@*$-$2T9314Q%0U0@*B(@(F9S96QE8W0B*3L*+DQ0"BY"
M22`B=F]I9"!B:6YD0T1+3V)J96-T("A%3V)J96-T5'EP92`B(")W:61G9714
M>7!E(BP*+D))(")V;VED("HB(")O8FIE8W0B+`HN0DD@(F-H='EP92`B(")K
M97DB+`HN0DD@(D))3D1&3B`B(")F=6YC=&EO;B(L"BY"22`B=F]I9"`J(B`B
M9&%T82(I.PHN4T@@1$530U))4%1)3TX*5&AE($-D:R!F:6QE('-E;&5C=&]R
M('=I9&=E="!C<F5A=&5S(&$@=VED9V5T('=H:6-H(&%L;&]W<R!A('5S97(@
M=&\@:6YT97)A8W0*=VET:"!T:&4@56YI>"!F:6QE('-Y<W1E;2X@5&AI<R!W
M:61G970@86QL;W=S('1H92!U<V5R('1O('1R879E<G-E('1H92!F:6QE"G-Y
M<W1E;2!A;F0@979E;B!D96QE=&4@9FEL97,N"@I#1$M&4T5,14-4("IN97=#
M1$M&<V5L96-T("A<9C)S8W)E96Y<9C$L(%QF,GAP;W-<9C$L(%QF,GEP;W-<
M9C$L(%QF,FAE:6=H=%QF,2P@7&8R=VED=&A<9C$L(%QF,F9I96QD071T<FEB
M=71E7&8Q+"!<9C)F:6QL97)#:&%R7&8Q+"!<9C)H:6=H;&EG:'1<9C$L(%QF
M,F1I<D%T=')I8G5T97-<9C$L(%QF,F9I;&5!='1R:6)U=&5S7&8Q+"!<9C)L
M:6YK071T<FEB=71E7&8Q+"!<9C)S;V-K071T<FEB=71E7&8Q+"!<9C)B;WA<
M9C$L(%QF,G-H861O=UQF,2D["BY24R`S"E1H:7,@9G5N8W1I;VX@8W)E871E
M<R!A('!O:6YT97(@=&\@82!F<V5L96-T('=I9&=E="X@5&AE('!A<F%M971E
M<@I<9C)S8W)E96Y<9C$@:7,@;V8@='EP92!#1$M30U)%14XN(%1H92!P87)A
M;65T97(@7&8R>'!O<UQF,2!C;VYT<F]L<R!T:&4@"G!L86-E;65N="!O9B!T
M:&4@;V)J96-T(&%L;VYG('1H92!H;W)I>F]N=&%L(&%X:7,[('=H:6-H(&UE
M86YS(&ET(&-A;B!T86ME(`IA;B!I;G1E9V5R('9A;'5E(&]R('1H92!P<F4M
M9&5F:6YE9"!V86QU97,@;V8@7&8T3$5&5%QF,2P@7&8T4DE'2%1<9C$L(&%N
M9"`*7&8T0T5.5$527&8Q+B!4:&4@<&%R86UE=&5R(%QF,GEP;W-<9C$@8V]N
M=')O;',@=&AE('!L86-E;65N="!O9B!T:&4@;V)J96-T"F%L;VYG('1H92!V
M97)T:6-A;"!A>&ES('=H:6-H(&UE86YS(&ET(&-A;B!A8V-E<'0@86X@:6YT
M96=E<B!V86QU92!O<B!A(`IP<F4M9&5F:6YE9"!V86QU92!O9B!<9C143U!<
M9C$L(%QF-$)/5%1/35QF,2P@86YD(%QF-$-%3E1%4EQF,2X@5&AE('!A<F%M
M971E<G,*7&8R:&5I9VAT7&8Q(&%N9"!<9C)W:61T:%QF,2!C;VYT<F]L('1H
M92!H96EG:'0@86YD('=I9'1H(&]F('1H92!F:6QE(`IS96QE8W1O<B!B;W@N
M(%1H92!<9C)F:65L9$%T=')I8G5T95QF,2!P87)A;65T97(@<V5T<R!T:&4@
M871T<FEB=71E(&]F('1H92`*96YT<GD@9FEE;&0@870@=&AE('1O<"!O9B!T
M:&4@=VED9V5T.R!<9C)F:6QL97)#:&%R86-T97)<9C$@9&5F:6YE<R!T:&4@
M"F9I;&QE<B!C:&%R86-T97(@9F]R('1H92!E;G1R>2!F:65L9"X@5&AE(%QF
M,FAI9VAL:6=H=%QF,2!S971S('1H92!H:6=H;&EG:'0@"F%T=')I8G5T92!O
M;B!T:&4@<V-R;VQL:6YG(&QI<W0N(%1H92!N97AT(&9O=7(@<&%R86UE=&5R
M<SH@7&8R9&ER071T<FEB=71E<UQF,2P*7&8R9FEL94%T=')I8G5T97-<9C$L
M(%QF,FQI;FM!='1R:6)U=&5<9C$L(&%N9"!<9C)S;V-K071T<FEB=71E7&8Q
M('-E="!T:&4*871T<FEB=71E<R!O9B!D:7)E8W1O<FEE<RP@9FEL97,L(&QI
M;FMS+"!A;F0@<V]C:V5T<R!F;W5N9"!I;B!T:&4@9&ER96-T;W)Y(`IL:7-T
M+B!4:&4@7&8R8F]X7&8Q('!A<F%M971E<B!S=&%T97,@=VAE=&AE<B!T:&4@
M=VED9V5T('=I;&P@8F4@9')A=VX@=VET:"`*82!B;W@@87)O=6YD(&ET(&]R
M(&YO="X@5&AE(%QF,G-H861O=UQF,2!P87)A;65T97(@86-C97!T<R!A(&)O
M;VQE86X@=F%L=64*=&\@='5R;B!T:&4@<VAA9&]W(&]N(&]R(&]F9B!A<F]U
M;F0@=&AI<R!W:61G970N($EF('1H92!W:61G970@8V]U;&0@;F]T(&)E"F-R
M96%T960@=&AE;B!A($Y53$P@<&]I;G1E<B!I<R!R971U<FYE9"X*+E)%"@IC
M:&%R("IA8W1I=F%T94-$2T9S96QE8W0@*%QF,F9S96QE8W1<9C$I.PHN4E,@
M,PI4:&ES(&9U;F-T:6]N(&%C=&EV871E<R!T:&4@9G-E;&5C="!W:61G970@
M86YD(&QE=',@=&AE('5S97(@:6YT97)A8W0@=VET:"!T:&4*=VED9V5T+B!4
M:&4@;VYL>2!P87)A;65T97(@=&AI<R!F=6YC=&EO;B!R97%U:7)E<R!I<R!T
M:&4@7&8R9G-E;&5C=%QF,2!W:61G970*<&]I;G1E<BX@5&AI<R!F=6YC=&EO
M;B!R971U<FYS(&$@7&8T8VAA<B`J7&8Q('=H:6-H(')E<')E<V5N=',@=&AE
M(&9I;&5N86UE"G-E;&5C=&5D+B!)9B!T:&4@=VED9V5T('=A<R!E>&ET960@
M96%R;'D@=7-I;F<@7&8T0U123"U.7&8Q('1H96X@82!.54Q,(`IC:&%R86-T
M97(@:7,@<F5T=7)N960N"BY210H*=F]I9"!S971#1$M&<V5L96-T("A<9C)F
M<V5L96-T7&8Q+"!<9C)D:7)E8W1O<GE<9C$L(%QF,F9I96QD071T<FEB=71E
M7&8Q+"!<9C)F:6QL97)#:&%R7&8Q+"!<9C)H:6=H;&EG:'1<9C$L(%QF,F1I
M<D%T=')I8G5T97-<9C$L(%QF,F9I;&5!='1R:6)U=&5S7&8Q+"!<9C)L:6YK
M071T<FEB=71E7&8Q+"!<9C)S;V-K071T<FEB=71E7&8Q+"!<9C)B;WA<9C$I
M.PHN4E,@,PI4:&ES(&9U;F-T:6]N(&QE=',@=&AE('!R;V=R86UM97(@;6]D
M:69Y(&-E<G1A:6X@96QE;65N=',@;V8@86X@86QR96%D>2`*9&5F:6YE9"!F
M<V5L96-T('=I9&=E="X@5&AE('!A<F%M971E<B!N86UE<R!C;W)R97-P;VYD
M('1O('1H92!S86UE('!A<F%M971E<B`*;F%M97,@;&ES=&5D(&EN('1H92!<
M9C1N97=#1$M&<V5L96-T7&8Q(&9U;F-T:6]N+@HN4D4*"G9O:60@9')A=T-$
M2T9S96QE8W0H7&8R9G-E;&5C=%QF,2P@7&8R8F]X7&8Q*3L*+E)3(#,*5&AI
M<R!F=6YC=&EO;B!D<F%W<R!T:&4@9G-E;&5C="!W:61G970@;VX@=&AE('-C
M<F5E;BX@5&AE(%QF,F)O>%QF,2!O<'1I;VX@"F1R87=S('1H92!W:61G970@
M=VET:"!O<B!W:71H;W5T(&$@8F]X+@HN4D4*"G9O:60@97)A<V5#1$M&<V5L
M96-T("A<9C)F<V5L96-T7&8Q*3L*+E)3(#,*5&AI<R!F=6YC=&EO;B!R96UO
M=F5S('1H92!W:61G970@9G)O;2!T:&4@<V-R965N+B!4:&ES(&1O97,@7&8T
M3D]47&8Q(&1E<W1R;WD*=&AE('=I9&=E="X*+E)%"@IV;VED(&1E<W1R;WE#
M1$M&<V5L96-T("A<9C)F<V5L96-T7&8Q*3L*+E)3(#,*5&AI<R!F=6YC=&EO
M;B!R96UO=F5S('1H92!W:61G970@9G)O;2!T:&4@<V-R965N(&%N9"!F<F5E
M<R!U<"!A;GD@;65M;W)Y('1H90IO8FIE8W0@;6%Y(&)E('5S:6YG+@HN4D4*
M"G9O:60@8FEN9$-$2T]B:F5C="`H7&8R=VED9V5T5'EP95QF,2P@7&8R;V)J
M96-T7&8Q+"!<9C)K97E<9C$L(%QF,F9U;F-T:6]N7&8Q+"!<9C)D871A7&8Q
M*3L*+E)3(#,*5&AI<R!F=6YC=&EO;B!A;&QO=W,@=&AE('5S97(@=&\@8W)E
M871E('-P96-I86P@:V5Y(&)I;F1I;F=S+B!4:&4@"EQF,G=I9&=E=%1Y<&5<
M9C$@<&%R86UE=&5R(&ES(&$@9&5F:6YE9"!T>7!E('=H:6-H('-T871E<R!W
M:&%T($-D:R!O8FIE8W0@"G1Y<&4@:7,@8F5I;F<@=7-E9"X@5&\@;&5A<FX@
M;6]R92!A8F]U="!T:&4@='EP92!<9C1%3V)J96-T5'EP95QF,2!R96%D(`IT
M:&4@7&8R8V1K7V)I;F1I;F=<9C$@;6%N=6%L('!A9V4N(%1H92!<9C)O8FIE
M8W1<9C$@<&%R86UE=&5R(&ES('1H92!P;VEN=&5R"G1O('1H92!W:61G970@
M;V)J96-T+B!4:&4@7&8R:V5Y7&8Q(&ES('1H92!C:&%R86-T97(@=&\@8FEN
M9"X@5&AE(`I<9C)F=6YC=&EO;EQF,2!I<R!T:&4@9G5N8W1I;VX@='EP92X@
M5&\@;&5A<FX@;6]R92!A8F]U="!T:&4@:V5Y(&)I;F1I;F<@"F-A;&QB86-K
M(&9U;F-T:6]N('1Y<&5S(')E860@=&AE(%QF-&-D:U]B:6YD:6YG7&8Q(&UA
M;G5A;"!P86=E+B!4:&4@;&%S="`*<&%R86UE=&5R(%QF,F1A=&%<9C$@:7,@
M82!P;VEN=&5R('1O(&%N>2!D871A('1H870@;F5E9',@=&\@9V5T('!A<W-E
M9"!T;R`*=&AE(&-A;&QB86-K(&9U;F-T:6]N+@HN4D4*"BY32"!+15D@0DE.
M1$E.1U,*5VAE;B!T:&4@=VED9V5T(&ES(&%C=&EV871E9"!T:&5R92!A<F4@
M<V5V97)A;"!D969A=6QT(&ME>2!B:6YD:6YG<R!W:&EC:"!W:6QL"FAE;'`@
M=&AE('5S97(@96YT97(@;W(@;6%N:7!U;&%T92!T:&4@:6YF;W)M871I;VX@
M<75I8VML>2X@4VEN8V4@=&AI<R!W:61G970@:7,@"F)U:6QT(&9R;VT@8F]T
M:"!T:&4@<V-R;VQL:6YG(&QI<W0@=VED9V5T(&%N9"!T:&4@96YT<GD@9FEE
M;&0@=VED9V5T+"!T:&4@:V5Y"F)I;F1I;F=S(&%R92!T:&4@<V%M92!F;W(@
M=&AE(')E<W!E8W1I=F4@9FEE;&1S+B!4:&4@97AT<F$@:V5Y(&)I;F1I;F=S
M(&%R90IL:7-T960@8F5L;W<N"BY,4`HN;F8*7&8T4V-R;VQL:6YG($QI<W0@
M2V5Y($)I;F1I;F=S7&8Q"BY24R`S"EQF,DME>2`@("`@("`@("!!8W1I;VY<
M9C$*5&%B("`@("`@("`@($QE879E<R!S8W)O;&QI;F<@;&ES="!W:61G970@
M86YD(&5N=&5R<R!T:&4@96YT<GD*("`@("`@("`@("`@(&9I96QD('=I9&=E
M="X*4F5T=7)N("`@("`@($EF('-E;&5C=&EN9R!A(&9I;&4L(&QE879E<R!T
M:&4@=VED9V5T(&%N9"!R971U<FYS"B`@("`@("`@("`@("!T:&4@8V]M<&QE
M=&4@<&%T:"!O9B!T:&4@<V5L96-T960@9FEL96YA;64N($EF"B`@("`@("`@
M("`@("!S96QE8W1I;F<@82!D:7)E8W1O<GDL(&5N=&5R<R!T:&4@9&ER96-T
M;W)Y+@I$96QE=&4@("`@("`@1&5L971E<R!T:&4@9FEL92X@*%-E92!.3U1%
M4R!B96QO=RD*/R`@("`@("`@("`@(%-H;W=S(&EN9F]R;6%T:6]N(&%B;W5T
M('1H92!F:6QE(&-U<G)E;G1L>2`*("`@("`@("`@("`@(&AI9VAL:6=H=&5D
M+@I#5%),+4X@("`@("`@17AI=',@=VET:&]U="!S96QE8W1I;F<@86YY=&AI
M;F<N"BY210H*7&8T16YT<GD@1FEE;&0@2V5Y($)I;F1I;F=S7&8Q"BY24R`S
M"EQF,DME>2`@("`@("`@("!!8W1I;VY<9C$*4F5T=7)N("`@("`@($EF(&$@
M9FEL96YA;64@=V%S('-E;&5C=&5D+"!E>&ET<R!T:&4@=VED9V5T(&%N9`H@
M("`@("`@("`@("`@<F5T=7)N<R!T:&4@8V]M<&QE=&4@<&%T:&YA;64@;V8@
M=&AE(&9I;&4N($EF(&]N"B`@("`@("`@("`@("!A(&1I<F5C=&]R>2P@96YT
M97)S('1H92!D:7)E8W1O<GDL(&QI<W1S(&%L;"!O9@H@("`@("`@("`@("`@
M=&AE(&9I;&5S(&%N9"!E;G1E<G,@=&AE('-C<F]L;&EN9R!L:7-T+@I486(@
M("`@("`@("`@268@82!F:6QE;F%M92!W87,@<V5L96-T960L(&5X:71S('1H
M92!W:61G970@86YD"B`@("`@("`@("`@("!R971U<FYS('1H92!C;VUP;&5T
M92!P871H;F%M92!O9B!T:&4@9FEL92X@268@;VX*("`@("`@("`@("`@(&$@
M9&ER96-T;W)Y+"!E;G1E<G,@=&AE(&1I<F5C=&]R>2P@;&ES=',@86QL(&]F
M"B`@("`@("`@("`@("!T:&4@9FEL97,@86YD(&5N=&5R<R!T:&4@<V-R;VQL
M:6YG(&QI<W0N"D-44DPM3B`@("`@("!%>&ET<R!W:71H;W5T('-E;&5C=&EN
M9R!A;GET:&EN9RX*+E)%"BYF:0HN4T@@4T5%($%,4T\*+D)2(&-D:R`H,RDL
M"BY"4B!C9&M?8FEN9&EN9R`H,RDL"BY"4B!C9&M?9&ES<&QA>2`H,RDL"BY"
M4B!C9&M?<V-R965N("@S*0HN4T@@3D]415,*+E!0"E1H:7,@=VED9V5T(&ES
M(&-R96%T960@9G)O;2!T:&4@<V-R;VQL:6YG(&QI<W0@=VED9V5T(&%N9"!T
M:&4@96YT<GD@9FEE;&0@"G=I9&=E="X@(%1H:7,@:7,@82!G;V]D(&5X86UP
M;&4@;VX@:&]W('1O(&)U:6QD('EO=7(@;W=N('=I9&=E=',@=7-I;F<@=&AE
M(`IB87-E('=I9&=E=',@<')O=FED960@:6X@=&AI<R!D:7-T<FEB=71I;VXN
M($EN(&]R9&5R(&9O<B!Y;W4@=&\@9&5L971E(`IF:6QE<R!U<VEN9R!T:&4@
M9FEL92!S96QE8W1O<BP@>6]U(&UU<W0@861D('1H92!F;VQL;W=I;F<@;&EN
M92!O9B!C;V1E(`II;G1O('EO=7(@<')O9W)A;2X*+DQ0"BYC92`*+D(@(F)I
M;F1#1$M/8FIE8W0@*'930U)/3$PL(&9S96QE8W0M/F9I;&5L:7-T+"!$14Q%
M5$4L(&1E;&5T949I;&4L(&9S96QE8W0I(@HN3%`*=VAE<F4@7&8R9G-E;&5C
M=%QF,2!I<R!A('!O:6YT97(@=&\@=&AE(&]B:F5C="X@5&AI<R!W87,@;W)I
M9VEN86QL>2!T=7)N960@;VXL"F)U="!)('1H;W5G:'0@:70@8F5T=&5R('1O
M('!U="!T:&4@8V]N=')O;"!O9B!F:6QE(&1E;&5T:6]N(&]N(&%N("=A<RUN
M965D)R`*8F%S:7,N"BY04`I4:&4@:&5A9&5R(&9I;&4@7&8T/&-D:RYH/EQF
M,2!A=71O;6%T:6-A;&QY(&EN8VQU9&5S('1H92!H96%D97(@9FEL97,*7&8T
M/&-U<G-E<RYH/EQF,2P@7&8T/'-T9&QI8BYH/EQF,2P@7&8T/'-T<FEN9RYH
M/EQF,2P@7&8T/&-T>7!E+F@^7&8Q+`I<9C0\=6YI<W1D+F@^7&8Q+"!<9C0\
M9&ER96YT+F@^7&8Q+"!<9C0\=&EM92YH/EQF,2P@7&8T/&5R<FYO+F@^7&8Q
M+`I<9C0\<'=D+F@^7&8Q+"!<9C0\9W)P+F@^7&8Q+"!<9C0\<WES+W-T870N
M:#Y<9C$L(&%N9"!<9C0\<WES+W1Y<&5S+F@^7&8Q+@I4:&4@7&8T/&-U<G-E
M<RYH/EQF,2!H96%D97(@9FEL92!I;F-L=61E<R!<9C0\<W1D:6\N:#Y<9C$@
M86YD(%QF-#QU;F-T<FPN:#Y<9C$N"BY04`I)9B!Y;W4@:&%V92!<9C1.8W5R
M<V5S7&8Q(&EN<W1A;&QE9"!O;B!Y;W5R(&UA8VAI;F4@861D("U$3D-54E-%
M4R!T;R!T:&4@"F-O;7!I;&4@;&EN92!T;R!I;F-L=61E('1H92!.8W5R<V5S
7(&AE861E<B!F:6QE<R!I;G-T96%D+@IT
`
end
SHAR_EOF
  echo 'uudecoding file man/fselect.3' &&
  uudecode _sharuue.tmp < _sharuue.tmp && rm -f _sharuue.tmp &&
  $shar_touch -am 0503190996 'man/fselect.3' &&
  chmod 0444 'man/fselect.3' ||
  echo 'restore of man/fselect.3 failed'
  shar_count="`wc -c < 'man/fselect.3'`"
  test 7898 -eq "$shar_count" ||
    echo "man/fselect.3: original size 7898, current size $shar_count"
  rm -f _sharnew.tmp
fi
# ============= man/histogram.3 ==============
if test -f 'man/histogram.3' && test X"$1" != X"-c"; then
  echo 'x - skipping man/histogram.3 (file already exists)'
  rm -f _sharnew.tmp
else
  > _sharnew.tmp
  echo 'x - extracting man/histogram.3 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'man/histogram.3' &&
X.de It
SHAR_EOF
  : || echo 'restore of man/histogram.3 failed'
fi
echo 'End of archive part 5'
echo 'File man/histogram.3 is continued in part 6'
echo 6 > _sharseq.tmp
exit 0
