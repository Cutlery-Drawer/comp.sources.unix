Newsgroups: comp.sources.unix
From: stevegru@welchlink.welch.jhu.edu (STEPHEN C GRUBB)
Subject: v29i094: copa - gui control panel kit for shell, C, perl - V1.0, Part07/08
References: <1.823324036.2981@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: stevegru@welchlink.welch.jhu.edu (STEPHEN C GRUBB)
Posting-Number: Volume 29, Issue 94
Archive-Name: copa/part07

#	This is a shell archive.
#	Remove everything above and including the cut line.
#	Then run the rest of the file through sh.
# - - - - - - C U T   H E R E - - - - - - - - - - - - - - -
#!/bin/sh
#
# Part 7
#
# shar:	Shell Archiver
#	Run the following text with /bin/sh to create:
#		src/graphic.c
#		src/init.c
#		src/interact.c
#		src/ipl.d
#		src/ipl.h
#		src/ipl.x
#		src/lib.c
#		src/mapdata.h
#		src/mark.c
#		src/obj.c
#		src/pcode.c
#		src/ps.c
echo src/graphic.c
cat << \SHAR_EOF > src/graphic.c
/* small, lowlevel routines for graphics */
#include "elib.x"

/* linear, log, time, yymm, mmddyy, polar */

/* =========================== */
/* for setting up scaling in x */
Escale_x( xlow, xhi, datalow, datahi )
double 	xlow, 	/* absolute x location of left side of the area */
	xhi, 	/* absolute x location of the right side of the area */
	datalow, /* data-units x at the left side */
	datahi;	 /* data-units x at the right side */
{
EXlo = xlow;
EXhi = xhi;
EDXlo = datalow;
EDXhi = datahi;
if( datahi-datalow <= 0 || xhi-xlow <= 0 ) { fprintf( stderr, "Bad x scaling min/max values.\n" ); exit(); }
if( EScale_discipline_x == E_LINEAR )EScale_x = (xhi-xlow) / (datahi-datalow) ;
else if( EScale_discipline_x == E_LOG )EScale_x = (xhi-xlow) / log( datahi-datalow ) ;
else if( EScale_discipline_x == E_YYMM ) {
	EScale_x = (xhi-xlow) / ( Eyymm_to_i( datahi ) - Eyymm_to_i( datalow ));
	EDXlo = Eyymm_to_i( datalow );
	EDXhi = Eyymm_to_i( datahi );
	}
}

/* =========================== */
/* for setting up scaling in y */
Escale_y( ylow, yhi, datalow, datahi )
double 	ylow, 	/* absolute y location of low side of the area */
	yhi, 	/* absolute y location of high side of the area */
	datalow, /* data-units y at the low side */
	datahi;	 /* data-units y at the high side */
{
EYlo = ylow;
EYhi = yhi;
EDYlo = datalow;
EDYhi = datahi;
if( datahi-datalow <= 0 || yhi-ylow <= 0 ) { fprintf( stderr, "Bad y scaling min/max values.\n" ); exit(); }
if( EScale_discipline_y == E_LINEAR )EScale_y = (yhi-ylow) / (datahi-datalow) ;
else if( EScale_discipline_y == E_LOG )EScale_y = (yhi-ylow) / log( datahi-datalow ) ;
}

/* =========================== */
/* returns an absolute x location from a data value */
double Eax( d )
double d;
{
double f;
if( EScale_discipline_x == E_LINEAR ) return( EXlo + (( d - EDXlo ) * EScale_x ));
else if( EScale_discipline_x == E_LOG ) { 
	if( d-EDXlo > 0.0 )return( EXlo + ( log( d - EDXlo )*EScale_x )); 
	else return( EXlo );
	}
else if( EScale_discipline_x == E_YYMM ) {
	if( d >= 7000 ) d = Eyymm_to_i( d );
	return( EXlo + (( d - EDXlo) * EScale_x ));
	}
}

/* =========================== */
/* returns an absolute y location from a data value */
double Eay( d )
double d;
{
if( EScale_discipline_y == E_LINEAR ) return( EYlo + (( d - EDYlo ) * EScale_y ));
else if( EScale_discipline_y == E_LOG ) {
	if( d-EDYlo > 0.0 )return( EYlo + ( log( d - EDYlo )*EScale_y ));
	else return( EYlo );
	}
}


/* =========================== */
/* returns a data x location from an abs value */
double Edx( d )
double d;
{
if( EScale_discipline_x == E_LINEAR ) return( ( d - Eax( 0.0 ) ) / EScale_x );
else if( EScale_discipline_x == E_LOG ) return( exp( (d-EXlo) / EScale_x ) );
}


/* =========================== */
/* returns a user y location from an abs value */
double Edy( d )
double d;
{
if( EScale_discipline_y == E_LINEAR ) return( ( d - Eay( 0.0 ) ) / EScale_y );
else if( EScale_discipline_y == E_LOG ) return( exp( (d-EYlo) / EScale_y ) );
}


/* ============================ */
/* Returns an integer given a YYMM date.  Jan 1970 is zero. */

Eyymm_to_i( m )
double m;
{
int yr, mo;

yr = (int)(m) / 100;
if( yr < 70 ) yr += 100;
mo = (int)(m) % 100;
return( ((yr-70)*12 ) + mo );
}

/* ============================ */
/* Select the scaling method */
Escaletype( typ, axis )
char typ[];
char axis;
{
if( strcmp( typ, "linear" )==0 ) {
	if( axis == 'x' ) EScale_discipline_x = E_LINEAR;
	if( axis == 'y' ) EScale_discipline_y = E_LINEAR;
	}
else if( strcmp( typ, "log" )==0 ) {
	if( axis == 'x' ) EScale_discipline_x = E_LOG;
	if( axis == 'y' ) EScale_discipline_y = E_LOG;
	}
else if( strcmp( typ, "yymm" )==0 ) {
	if( axis == 'x' ) EScale_discipline_x = E_YYMM;
	}
}


SHAR_EOF
############################

echo src/init.c
cat << \SHAR_EOF > src/init.c
/* EINIT - low level elib initialization. 
/* 
   110995	scg	env var COPA_DPI to adjust for different screen res 

 */
#include "elib.x"
#define MAXSTAK 5

Einit( name, dev, ux, uy, upleftx, uplefty )
char name[];
char dev;     /* 'x' for x11; 'p' for postscript */
double ux, uy;  /* size of window in inches.. */
int upleftx, uplefty; /* point (in native window system coords ) of upper-left corner of window */
{
char msg[100];
int yr, mon, day, hr, min, sec, i;
char host[30]; 
FILE *lfp;
char *pix, *getenv();

Esysdate( &mon, &day, &yr ); Esystime( &hr, &min, &sec );

/* initialize graphics parameters.. */
Edev = dev;


#ifndef NOX11
if( dev == 'x' ) {
	pix = getenv( "COPA_DPI" );
	Epixelsinch = 0;
	if( pix != NULL && strlen( pix ) > 0 ) sscanf( pix, "%d", &Epixelsinch );
	if( Epixelsinch < 1 || Epixelsinch > 800 ) Epixelsinch = 75;
		
	Esetwinscale( (int)(ux*Epixelsinch), (int)(uy*Epixelsinch), ux, uy );
	EXWsetup( name, Epixelsinch, ux, uy, upleftx, uplefty );
	}
#endif
else if( dev == 'p' ) {
	EPSsetup( name, "-" );
	}

else { 
	fprintf( stderr, 
	  "Bad display device code (%c).  Use 'p' for PostScript or 'x' for X11.\n", dev ); 
	exit(); 
	}

EWinx = ux;  EWiny = uy;
EWinx_0 = ux;  EWiny_0 = uy; /* remember original size.. */
Esetdefaults(); 
Eerasecolor = 1; Eeraseshade = 1.0; 
/* Eclr(); */
}

/* =================================== */
/* resize/move window (code driven, not user driven) */
/*  Eresize( double ux, double uy, int upleftx, int uplefty ) */
Eresize( ux, uy, upleftx, uplefty )
double ux, uy;
int upleftx, uplefty;
{
#ifndef NOX11
if( Edev == 'x' ) {
	/* update elibs idea of window size and original size */
	if( ux >= 0 ) { EWinx = ux; EWinx_0 = ux; }
	if( uy >= 0 ) { EWiny = uy; EWiny_0 = uy; }
	/* update scaling */
	Esetwinscale( (int)(ux*Epixelsinch), (int)(uy*Epixelsinch), ux, uy );
	/* resize window */
	EXWresizewin( Epixelsinch, upleftx, uplefty, ux, uy );
	}
#endif
return( 0 );
}

/* =========================================== */
/* Egraphenv() - save/restore graphics env. */
/* Only issues a pcode call if a change needs to be made.. */
Egraphenv( mode )
int mode; /* E_PUSH  or  E_POP */
{
static char scurfont[MAXSTAK][30];
static int scurtextsize[MAXSTAK];
static int scurtextdirection[MAXSTAK];
static double scurlinewidth[MAXSTAK];
static int scurlinetype[MAXSTAK];
static double scurpatternfactor[MAXSTAK];
static int scurcolor[MAXSTAK];
static int spaper[MAXSTAK];
static double trx[MAXSTAK], try[MAXSTAK]; /* translation */
static int ss = 0;

if( mode == E_PUSH ) {
	if( ss > MAXSTAK-1 ) { fprintf(stderr,"graphic environment stack capacity exceeded.\n" ); return(0); } 
	strcpy( scurfont[ss], Ecurfont );
	scurtextsize[ss] = Ecurtextsize;
	scurtextdirection[ss] = Ecurtextdirection;
	scurlinewidth[ss] = Ecurlinewidth;
	scurlinetype[ss] = Ecurlinetype;
	scurpatternfactor[ss] = Ecurpatternfactor;
	scurcolor[ss] = Ecurcolor;
	spaper[ss] = Ecurpaper;
	Etrlget( &trx[ss], &try[ss] );
	ss++;
	}
else if( mode == E_POP ) {
	if( ss > 0 ) ss--;
	if( strcmp( scurfont[ss], Ecurfont ) != 0 ) Efont( scurfont[ss] );
	if( scurtextsize[ss] != Ecurtextsize ) Etextsize( scurtextsize[ss] );
	if( scurtextdirection[ss] != Ecurtextdirection ) Etextdir( scurtextdirection[ss] );
	if( scurlinewidth[ss] != Ecurlinewidth || scurlinetype[ss] != Ecurlinetype || 
	    scurpatternfactor[ss] != Ecurpatternfactor ) {
		Elinetype( scurlinetype[ss], scurlinewidth[ss], scurpatternfactor[ss] );
		}
	if( scurcolor[ss] != Ecurcolor ) {
		Esetdrawcolor( scurcolor[ss] );
		}
	if( spaper[ss] != Ecurpaper )Epaper( spaper[ss] );
	Etrlset( trx[ss], try[ss] );
	}
}

/* ====================================== */
Esetdefaults()
{
strcpy( Estandardfont, "/Helvetica" );
if( strcmp( Estandardfont, Ecurfont ) != 0 ) Efont( Estandardfont );
if( Ecurtextsize != 10 ) Etextsize( 10 );
if( Ecurtextdirection != 0 ) Etextdir( 0 );

Estandardlinewidth = 0.6;
if( Ecurlinewidth != 0.6 || Ecurlinetype != 0 || Ecurpatternfactor != 1.0 ) Elinetype( 0, 0.6, 1.0 );

if( Ecurcolor != E_BLACK ) {
	Esetdrawcolor( E_BLACK );
	}

Ependraw();
Escaletype( "linear", 'x' );
Escaletype( "linear", 'y' );
if( Ecurpaper != 0 )Epaper( 0 );
EEvent = 0;
}
SHAR_EOF
############################

echo src/interact.c
cat << \SHAR_EOF > src/interact.c
#include "elib.x"

/* event modes */
#define STRING 2	/* getting a \n terminated string */
#define EVENTS 3	/* getting any mouse-button or keyboard event */


/* info re: most recent event.. */
static int  Eevent_mode;
static double Eevx, Eevy;
static int Eeid;
static int Eallpick = 0;
static int Eidlist[40], Eidlistn=0;
static double savex = 0.0, savey = 0.0;
static int savec = 0;




/* ==================================== */
/* get mouse position (x, y) and event code.. */

Egetkey( x, y, e )
double *x, *y;
int *e;
{
char ans[20];

if( Edev == 'p' ) { Eshow(); exit(); }  /* postscript-- eject page and exit.. */
Eevent_mode = EVENTS;
Esit();
*x = Eevx; *y = Eevy; *e = Eeid;

EEvent = 0; /* reset for the benefit of later non-blocking gets */
}
  

/* =================================== */
/* wait until a key or button is hit.. */

Egetclick()
{
double x, y;
int e;
if( Edev == 'p' ) { Eshow(); return(0); }  /* postscript-- eject page.. */

Egetkey( &x, &y, &e );
}

/* ================================ */
/* This gets called by the driver when we are waiting for an event 
   and then a key or mouse event happens. Never called directly by users. */
Ehandle_event( x, y, e )
double x, y;
int e;
{
int i;
char id[4];
double trlx, trly, dx, dy;

/* set global vars for async processes.. moved here from below scg Nov 95 */
EEvent = e; EEventx = x; EEventy = y;

if( e == E_EXPOSE ) {
	Etrlget( &trlx, &trly ); /* we need to save, set to zero, then restore the trl setting.. */
	Etrlset( 0.0, 0.0 );

	Eredraw_entryfield();
	Eclr(); 	/* added scg 11-9-95 */
	Egenall();	/* regenerate picture.. */
	Etrlset( trlx, trly );
	return( 1 );
	}
else if( e == E_RESIZE ) {
	/* x and y are in pixels */
	Etrlget( &trlx, &trly ); /* we need to save, set to zero, then restore the trl setting.. */
	Etrlset( 0.0, 0.0 );

	EWinx = x / (double)Epixelsinch;
	EWiny = y / (double)Epixelsinch;

	/* calculate a new text scale factor.. */
	dx = ((double)EWinx / (double)EWinx_0);
	dy = ((double)EWiny / (double)EWiny_0);
	if( dx < dy ) Escaletext( dx );
	else Escaletext( dy ); 

	/* adjust graphics scaling.. */
	Esetwinscale( (int)(x), (int)(y), EWinx, EWiny );


	Eredraw_entryfield();

	Ealignall();  /* re-align everything.. */
	Eclr(); 
	Egenall();   /* redraw everything */
	Etrlset( trlx, trly );
	return( 1 );
	}

/* set global vars for async processes.. */
/* EEvent = e; EEventx = x; EEventy = y; */

/* user is clicking any mouse button or key.. */
Eevx = x; Eevy = y; Eeid = e;
return( 1 );
}

/* ================================== */
/* given an x,y mouse location, return the
   corresponding procid.  If > 1, selects the one "on top". */
/* Returns -1 if none found. */
Ewhichobj( x, y )
double x, y;
{
double fabs();
char *typ;
double *x1, *y1, *x2, *y2;
int len;
int id;
int found;


EIgetnextobj( E_AT_END, 2 ); /* initialize */
Eidlistn = 0;

/* search the bounding boxes, starting with latest and going backwards.. */
while( 1 ) {
	found = 0;
	id = EIgetnextobj( E_PREVIOUS, 2 );
	if( id < 0 ) break;

	if( ! EIexists( id, "*", "bbt" )) continue;
	typ = EIgetc( id, "*", "bbt", &len );

	x1 = EIgetd( id, "*", "bb", &len );
	if( len != 4 ) continue;

	EIgetc( id, "*", "display", &len );
	if( len < 1 ) continue; /* its invisible.. */

	y1 = x1; y1++; x2 = y1; x2++; y2 = x2; y2++;  /* set up pointers */

	/* box.. */
	if( *typ == 'B' ) {
	      	if( x > *x1 && x < *x2 && y > *y1 && y < *y2 ) found = 1;
	      	}

	/* line.. */
	else if( *typ == 'L' ) {
		if( Eispointonline( x, y, *x1, *y1, *x2, *y2 ) ) found = 1;
		}

	if( found && !Eallpick ) { EIgetnextobj( E_DONE, 2 ); return( id ); }
	else if( found && Eallpick ) { Eidlist[ Eidlistn++ ] = id; }
	}
EIgetnextobj( E_DONE, 2 );
if( Eallpick && Eidlistn > 0 ) return( 1 );
return( -1 );
}
		
/* ===================================== */
/* variation for returning a list of all picked objects, ordered
   from "top to bottom". */
/* returns -1 if none found */
int *
Ewhichobjects( n, x, y )
int *n;      /* number of ids that will be in list */
double x, y; /* absolute location */
{
int i, j;

Eallpick = 1;
Eidlistn = 0;
i = Ewhichobj( x, y );
Eallpick = 0;
*n = Eidlistn;
return( Eidlist );
}
/* ==================== */
/* the following routines provide a place to save/retrieve an event */
Esavekey( lx, ly, c )
double lx, ly;
int c;
{
savex = lx;
savey = ly;
savec = c;
return( 0 );
}

Eretrievekey( lx, ly, c )
double *lx, *ly;
int *c;
{
*lx = savex;
*ly = savey;
*c = savec;
return( 0 );
}

SHAR_EOF
############################

echo src/ipl.d
cat << \SHAR_EOF > src/ipl.d
/*
COPA 1.0 - gui control panel kit for shell, C, perl etc.  
*              **      **                              *
Copyright 1991-1996 by Stephen C. Grubb.

Permission is hereby granted to USE this software for free.
Permission is hereby granted to MODIFY and/or REDISTRIBUTE 
this software for free, provided that no monetary gain is 
realized, and all attached authorship and copyright notices 
are preserved.

Inclusion of any portion (or derivation) of this software, 
including ancillary files, in any for-profit endeavor is not 
allowed without prior written permission of the author.  

See also the file 'Copyright'. 
*/





/* constants */
#include <stdio.h>
#include <math.h>
#include "elib.d"

#define INSTALL_TMP "/usr/tmp"
#define PATHNAME_LEN 80
#define HBUFSIZ 4096
#define MAX_D_ROWS 1000
#define MAX_D_COLS 24
#define DATAITEM_LEN 20
#define YES 1
#define NO 0

/* map the NT macros to Elib calls */
/* we'll continue to use the ipl scaling mechanism, though. */
/* ------------------------------------------------- */
#define NTmov( x , y )		Emov( (double)x, (double)y )
#define NTlin( x , y )		Elin( (double)x, (double)y )
#define NTpath( x , y )		Epath( (double)x, (double)y )
#define NTl( x , y )		Elin( da_x((double) x ) , da_y((double) y) )
#define NTm( x , y )		Emov( da_x((double) x ) , da_y((double) y) )
#define NTp( x , y )		Epath( da_x((double) x ) , da_y((double) y) )
#define NTshade( x )		Eshade( (double)x )
#define NTtext( s )		Etext( s )
/* NTcentext and NTrightjust are now in stub.c */
#define NTfont( s )		Efont( s )
#define NTptsize( x )		{ Etextsize( (int)x ); Chsz = x; Chh = (x+2)/72.0; }
#define NTchardir( x )		{ Etextdir( (int)x ); Chd = x ; }
#define NTpaper( x )		{ Paper = (int) (x); Epaper( x ); }
#define NTlinetype( s, x, y )   { Elinetype( atoi( s ), x, y ); Lw = x; } 
#define NTnormline()		{ Enormline(); Lw = StdLw; }
#define NTshow()		{ if( Dev == 't' )Eprint(); else Eclr(); }
#define NTbatch_on()		Ebatch_on()
#define NTbatch_off()		Ebatch_off()
#define point( x, y, s, r )	Emark( (double)x, (double)y, s, r )

#define LINEAR 0
#define LOG 1
#define YYMM 2

#define WHITE 1
#define BLACK 0
extern double da_x(), da_y(), ab_x(), ab_y();


#define FONTNAME_LEN	30	
#define TMPFILE_PATH	INSTALL_TMP
#define NSLOTS 24	/* number of slots in ASmax[] */

#define MOUSE_LEFT 1001
#define MOUSE_MIDDLE 1002
#define MOUSE_RIGHT 1003

extern char *getln();
extern FILE *popen();

/* map gget to zood call.. */
#define gget( b, a )		EIget( b, EPcurp, "", a )

/* map gdp_exit to a return(0) */
#define gdp_exit()		return(0)
SHAR_EOF
############################

echo src/ipl.h
cat << \SHAR_EOF > src/ipl.h
/*
COPA 1.0 - gui control panel kit for shell, C, perl etc.  
*              **      **                              *
Copyright 1991-1996 by Stephen C. Grubb.

Permission is hereby granted to USE this software for free.
Permission is hereby granted to MODIFY and/or REDISTRIBUTE 
this software for free, provided that no monetary gain is 
realized, and all attached authorship and copyright notices 
are preserved.

Inclusion of any portion (or derivation) of this software, 
including ancillary files, in any for-profit endeavor is not 
allowed without prior written permission of the author.  

See also the file 'Copyright'. 
*/





#include "ipl.d"

/***** internal graphics parameters *****/
double Xlo, Xhi, Ylo, Yhi;		/* graphic area bounds, absolute coords */
double DXlo, DXhi, DYlo, DYhi;		/* graphic area bounds, data coords */
double Scale_x = 1, Scale_y = 1; 		/* linear scaling factors in x and y */
int Scale_discipline_x = LINEAR;	/* either LINEAR or LOG */
int Scale_discipline_y = LINEAR;	/* either LINEAR or LOG */

char Dev;				/* output device */
char D[ MAX_D_ROWS ][ MAX_D_COLS ][ DATAITEM_LEN ];	/* plot data */ 
int N_d_fields;					/* number of data fields per row */
int N_d_rows;					/* number of data rows */
char Buf[HBUFSIZ];				/* general purpose buffers */
char Buf2[512];

double Chsz;				/* character size */
double Chh;				/* height of a line of text */
double Chw;				/* character spacing */
double Chd;				/* character direction vector, x comp. */
int Paper = 0;				/* paper orientation */
double Lw;				/* current line width */
double StdLw = 1.0;			/* standard line width */
double Rgb;				/* color identifier */
double Rgbint;				/* color intensity identifier */

/* maxes for autoscaling -- currently not used */
double ASmaxes[30] = { 0.1, 0.5, 1, 5, 10, 20, 30, 50, 75, 100, 200, 300, 500, 750, 1000, 1250, 1500, 2000, 2500, 3000, 5000,
				10000, 20000, 30000, 50000, 100000 };

/* default tic increments */
double Incs[30]  = {  0.01, 0.05, 0.1, 1, 1, 2, 5, 5, 5, 10, 20, 20, 50, 50, 50, 50, 
				100, 100, 100, 200, 500, 500, 1000, 2000, 5000, 5000 };

/* default tic stub number formats */
char *Tformats[30]= { "%2.2f", "%2.2f", "%2.1f", "%2.1f", "%2.0f", "%2.0f", "%2.0f", "%2.0f", "%2.0f", "%3.0f", 
			"%3.0f", "%3.0f", "%3.0f", "%3.0f", "%4.0f", "%4.0f", "%4.0f", "%4.0f", "%4.0f", "%4.0f",
			"%4.0f", "%5.0f", "%5.0f", "%5.0f", "%5.0f", "%6.0f" };

double DXtic, DYtic;	/* tic increments */

char DXticfmt[12], DYticfmt[12];  /* printf format for numeric stubs */

char Tempfile[PATHNAME_LEN];	/* name of uniquely named temp file */

double Xmin, Xmax, Ymin, Ymax;	/* ranges of the input data, set by proc, before calling global()  */

int Hold;	/* TRUE if QuitAppend was called */

char Templatepath[PATHNAME_LEN];  /* location of templates and aux. files */

char Stdfont[FONTNAME_LEN];  /* page-wide default font */

char Controlfile[PATHNAME_LEN] = "";  /* name of control file */

/* =========================================== */
int EPcurp; /* current gr object id for gget() */
SHAR_EOF
############################

echo src/ipl.x
cat << \SHAR_EOF > src/ipl.x
/*
COPA 1.0 - gui control panel kit for shell, C, perl etc.  
*              **      **                              *
Copyright 1991-1996 by Stephen C. Grubb.

Permission is hereby granted to USE this software for free.
Permission is hereby granted to MODIFY and/or REDISTRIBUTE 
this software for free, provided that no monetary gain is 
realized, and all attached authorship and copyright notices 
are preserved.

Inclusion of any portion (or derivation) of this software, 
including ancillary files, in any for-profit endeavor is not 
allowed without prior written permission of the author.  

See also the file 'Copyright'. 
*/



#include "ipl.d"

/***** internal graphics parameters *****/
extern double Xlo, Xhi, Ylo, Yhi;		/* graphic area bounds, absolute coords */
extern double DXlo, DXhi, DYlo, DYhi;		/* graphic area bounds, data coords */
extern double Scale_x, Scale_y; 		/* linear scaling factors in x and y */
extern int Scale_discipline_x;			/* either LINEAR or LOG */
extern int Scale_discipline_y;			/* either LINEAR or LOG */

extern char Dev;
extern char D[ MAX_D_ROWS ][ MAX_D_COLS ][ DATAITEM_LEN ];	/* plot data */ 
extern int N_d_fields;					/* number of data fields per row */
extern int N_d_rows;					/* number of data rows */
extern char Buf[];					/* general purpose buffers */
extern char Buf2[];

extern double Chsz;				/* character size */
extern double Chw;				/* character spacing */
extern double Chh;				/* height of a line of text */
extern double Chd;				/* character direction vector, x comp. */
extern int Paper;				/* paper orientation */
extern double Lw;				/* current line width */
extern double StdLw;				/* standard line width */
extern double Rgb;				/* color identifier */
extern double Rgbint;				/* color intensity identifier */

extern double ASmaxes[];
extern double Incs[]; 
extern char *Tformats[];

extern double DXtic, DYtic;	
extern char DXticfmt[], DYticfmt[]; 
extern char Tempfile[];
extern double Xmin, Xmax, Ymin, Ymax;
extern int Hold;
extern char Templatepath[];
extern char Stdfont[];
extern char Controlfile[];

extern int EPcurp;
SHAR_EOF
############################

echo src/lib.c
cat << \SHAR_EOF > src/lib.c
#include <stdio.h>
#include <ctype.h>


/* =================================== */
/* Emember() - returns char position if character c is a member of string s, 
		0 otherwise. Char positions start with 1 for this purpose. */
Emember( c, s )
char c, s[];
{
int i;
for( i = 0; i < strlen( s ); i++ ) if( s[i] == c ) return( i+1 );
return( 0 );
}

/* =================================== */
/* Esmember() - returns 1 if string s is present as a token in sep-separated list t,
		0 otherwise.  Auth: Steve Grubb */
Esmember( s, t, sep )
char s[], t[], sep[];
{
char tok[100];
int i;
i = 0;
while( 1 ) {
	Egetchunk( tok, t, &i, sep );
	if( tok[0] == '\0' ) break;
	if( strcmp( tok, s ) == 0 ) return( 1 );
	}
return( 0 );
}

/* ================================== */
/* Ecounttokens() - returns number of tokens on line */

Ecounttokens( s )
char s[];
{
char tok[100];
int ix, j;
ix = 0;
for( j = 0; ; j++ ) {
	Egetchunk( tok, s, &ix, " 	");
	if( tok[0] == '\0' ) return( j );
	}
}

/* =================================== */
/* strip white-space off of front and end of string s */
Estrip_ws( s )
char s[];
{
int i, j;
/* find last significant char and put a null after it */
for( j = strlen( s ) -1; j >= 0; j-- )
	if( !Emember( s[j], " \t\n" )) break;
s[j+1] = '\0';
/* find 1st significant char at position i */
for( i = 0; i < strlen( s ); i++ ) 
	if( !Emember( s[i], " \t\n" )) break; 
strcpy( s, &s[i] );
}

/* ====================================== */
/* get rid of imbedded backslashes.. */
Estrip_bs( s )
char s[];
{
int i, j;
j = 0;
for( i = 0; i < strlen( s ); i++ ) if( s[i] != '\\' ) s[j++] = s[i];
s[j] = '\0';
}

/* ================= */
Esysdate( mon, day, yr )
int	*mon, *day, *yr ;
{
	int	tvec[2], *dtime ;

	time( tvec );
	dtime = (int *)(localtime( tvec ));
	*mon = *(dtime+4) + 1 ;
	*day = *(dtime+3)  ;
	*yr = *(dtime+5)  ;
}
/* ================= */
Esystime( hour, min, sec )
int	*hour, *min, *sec ;
{
	int	tvec[2], *dtime ;

	time( tvec );
	dtime = (int *)localtime( tvec );
	*hour = *(dtime+2) ;
	*min = *(dtime+1)  ;
	*sec = *(dtime)  ;
}
/* =========================================== */
/* Get lines, which are separated by a newline (\n) */
/* (different from Egetchunk in the handling of consecutive occurrences of the separator) */
Egetln( rtn, inbuf, i )
char rtn[];
char inbuf[];
int *i;
{
int n;

n = 0;
rtn[0] = '\0';
while( 1 ){
	if( inbuf[*i] == '\0' ) break;
	else if( inbuf[*i] == '\n' ) { (*i)++; break; }
	else rtn[n++] = inbuf[(*i)++];
	if( n >= 511 ) break; /* 512 max */
	}
rtn[n] = '\0' ;
}



/* ============================================ */
/* Get tokens, which are separated by any member of sepstring */

Egetchunk( rtn, line, i, sepstring )
char rtn[];
char line[];
int *i;
char sepstring[];
{

int n;

while( Emember( line[(*i)], sepstring ) ) (*i)++; 
n = 0;
rtn[0] = '\0';
while( 1 ){
	if( Emember( line[*i], sepstring ) || line[*i] == '\0' ) break;
	else rtn[n++] = line[(*i)++];
	}
rtn[n] = '\0' ;
}
/* ============ */
/* test routine */
/*
* main()
* {
* char foo[20];
* int ix;
* ix = 0;
* Egetchunk( foo, "\nhello\nworld", &ix, "\n" );
* printf( "1. (%s) ix=%d\n", foo, ix );
* Egetchunk( foo, "\nhello\nworld", &ix, "\n" );
* printf( "2. (%s) ix=%d\n", foo, ix );
* Egetchunk( foo, "\nhello\nworld", &ix, "\n" );
* printf( "3. (%s) ix=%d\n", foo, ix );
* }
*/

/* ============================================= */
/* Eexpand_tabs()
      Takes a string parameter 'in' and expands tabs into spaces, placing the
      result into parameter 'out'.  Analagous to BSD expand(1).
      steveg 910531
 */
Eexpand_tabs( out, in )
char in[], out[];
{
int i, j, k, l;

out[0] = '\0';
k = 0;
for( i = 0; i < strlen( in ); i++ ) {
	if( in[i] == '\t' ) {
		j =  8 - ( k % 8 ); /* 1 to 8 spaces needed */
		for( l = 0; l < j; l++ ) out[k++] = ' ';
		}
	else out[k++] = in[i];
	}
out[k] = '\0';
}

/* ======================================================== */
/* copy a file.  Mode is either "w" for create or "a" for append  */
Efilecopy( source, dest, mode )
char source[], dest[], mode[];
{
FILE *fp1, *fp2;
char buf[512];

fp1 = fopen( source, "r" );
if( fp1 == NULL ) { printf( "cant open %s to copy from\n", source ); return( 0 ); }
fp2 = fopen( dest, mode );
if( fp2 == NULL ) { printf( "cant open %s to copy to\n", dest ); return( 0 ); }

while( fgets( buf, 512, fp1 ) != NULL ) fprintf( fp2, "%s", buf );

fclose( fp1 ); fclose( fp2 );
return( 1 );
}

/* ======================================================== */
/* returns a char representation of a float (using %g format). */
char *
Eftoa( f )
double f;
{ 
static char buf[30];
sprintf( buf, "%g", f );
return( buf );
}
/* ==========================================
 * getok( )
*/
#define GETOKMAX        100
char *Egetok( string, index )
        char    string[];       /* array to obtain token from */
        int     *index;
        {
                static char     tok[GETOKMAX+1];
                register        n;
                while( Emember( string[(*index)], " \t\n" ) ) (*index)++;
                /* EAT( SPACE, TAB, EOR, string, (*index) ); */
                for( n=0;
                        n <= GETOKMAX &&
                        string[*index] != ' '  &&
                        string[*index] != '\t'  &&
                        string[*index] != '\n'  &&
                        string[*index] != '\0'  ;
                                tok[n++] = string[(*index)++] )  ;
                tok[n] = '\0' ;
                if( n > GETOKMAX ) fprintf( stderr, "token %s too long\n", tok );
                return(tok);
        }
/* ============================================ */
/* Get a certain line from a certain file.. */
/* returns 1 on success, 0 on fail */
/* no checking is done on the length of line string */
Efileline( filenm, ln, line )
char filenm[], line[];
int ln;
{
FILE *fp;
int n;

line[0] = '\0';
fp = fopen( filenm, "r" );
if( fp == NULL ) return( 0 );

n=0;
while( fgets( line, 512, fp ) != NULL ) {
	n++;
	if( n == ln ) { fclose( fp ); return( 1 ); }
	}
return( 0 );
}

/* ============================================== */
/* see if point (x,y) is on the line (or close to it) */
Eispointonline( x, y, x1, y1, x2, y2 )
double x, y, x1, y1, x2, y2;
{
double m, b;
int online;
double margin, fabs();

margin = 0.15; /* tolerance */

online = 0;
if( fabs( x1 - x2 ) < 0.05 ) {
	if( fabs( x - x1 ) < margin ) online = 1; /* approaching a vertical line */
	}
else	{ /* other lines.. */
	m = ( y2 - y1) / (x2 - x1 );
	if( fabs( m ) > 8.0 ) margin *= 8; /* slopes approaching vertical */
	b = y1 - ( m * x1 );
	if( fabs( y - (( m * x ) + b )) < margin ) online = 1;
	}
if( online ) {
	if( x1 < x2 && x >= x1 && x <= x2 ) return( 1 );
	else if( x1 > x2 && x <= x1 && x >= x2 ) return( 1 );
	else if( x1 == x2 ) {
		if( y1 < y2 && y >= y1 && y <= y2 ) return( 1 );
		else if( y1 > y2 && y <= y1 && y >= y2 ) return( 1 );
		}
	}
return( 0 );
}
/* ================================================== */
/* see if point( x, y ) overlaps with cirular (u, v) with radius r. */
Econtain( x, y, u, v, r )
double x, y, u, v, r;
{
double fabs();
if( fabs( x - u ) < r && fabs( y - v ) < r ) return( 1 );
else return( 0 );
}
/* ================================================== */
/* goodnum() - checks a token to see if it is a legal number,
	either float or integer, returns 1 if so, 0 if not a
	legal number.  Returns 2nd arg which is the position of
	the decimal point (if any).
*/
Egoodnum( str, prec )
char str[];
int *prec;
{
int l, p, bad, point, n;
char numstr[80], foo[80];

n = sscanf( str, "%s %s", numstr, foo );
if( n > 1 ) return( 0 );  /* multiple tokens==string */

l = strlen( numstr );
if( l < 1 ) return( 0 );
bad = 0; *prec = -1;
for( p = 0; p < strlen( numstr ); p++ ) { 
	if( numstr[p] == '.' ) { if( *prec == -1 ) *prec = p; else bad=1; }
	else if( p == 0 && l > 1 && ( numstr[p] == '-' || numstr[p] == '+' ) );
	else if( ! isdigit( numstr[p]) ) bad=1;
	}
if( bad ) return( 0 );
else return( 1 );
}

/* =============================== */
/* append str to buffer */

Eaddb( bb, str )
char bb[], str[];
{
int len;

len = strlen( bb );
sprintf( &bb[ len ], "%s", str );
}

SHAR_EOF
############################

echo src/mapdata.h
cat << \SHAR_EOF > src/mapdata.h
float usa[ 220 ] = {
3.5,23,
3.5,22,
3,21.6,
3.2,22.3,
2.4,22.8,
2.4,21.6,
2.2,20.8,
2,19.8,
1,18.1,
1,17.2,
.4,16,
.25,13.6,
1,13.3,
.7,13,
1.4,11.1,
1.4,10.4,
3.6,8,
5.4,7.7,
8.1,6,
10.5,6,
10.5,6.2,
11.6,6.2,
13,4.8,
13,4.1,
14,3.8,
14.5,4.2,
15.4,4.2,
16.3,2.8,
17.2,1,
19,0.8,
18.8,2.3,
21.3,4.2,
23,4.2,
24,3.8,
25.2,3.9,
24.6,4.4,
27.6,5,
28.2,4.7,
29.2,5,
30.4,4.2,
30.8,2.7,
32.2,1.2,
32.9,1.35,
33,2.5,
31,5.5,
30.9,6.6,
31.2,7.5,
32.5,9,
34.3,11.3,
33.5,12,
33.1,13.5,
33.6,13,
34,12.5,
34.3,14.3,
34,14.4,
33.8,15.4,
34.5,15.5,
35,16,
34.4,16.2,
35.6,16.7,
37,17,
36.5,17.4,
36,18,
36.6,19.5,
36.7,20,
37.7,20.2,
37.5,20.8,
36.8,21.2,
36.5,22.3,
35.5,22.2,
35,20,
32.8,19.4,
32.2,18.5,
32,17.2,
30.3,17,
30.2,16.4,
28.4,15.2,
27.9,15.3,
28.4,16.5,
28,17,
28.2,17.5,
27.8,18.6,
26.4,18.9,
25.8,17.7,
26,16.2,
25.9,15.2,
25.2,15,
24.9,16.6,
25.3,18.7,
26.3,19.2,
24.3,19.3,
24.3,19.7,
23,19,
22.8,19.4,
22.1,19.1,
23,20,
23.7,20.4,
20.5,21,
20.3,21.4,
20.1,21.3,
20,21,
14.7,21.15,
7.6,22.1,
6.8,22.2,
3.5,23 };

float canada[200] = {
40,21.5,
39.5,20,
38.4,19.5,
38,20,
38.6,21.4,
38.3,21.6,
37.5,20.8,
36.8,21.2,
36.5,22.3,
35.5,22.2,
35,20,
32.8,19.4,
32.2,18.5,
30.5,17.8,
30.2,17,
28.7,16.4,
29.3,18.8,
26.8,19.5,
25.8,21,
24.3,21,
23.7,20.4,
20.5,21,
20.3,21.4,
20.1,21.3,
20,21,
14.7,21.15,
7.6,22.1,
6.8,22.2,
3.5,23,
2.5,24.2,
3.5,22.8,
2.4,23,
1.1,25,
1.4,25.1,
2.3,24.4,
1.7,26,
1.5,26.8,
1.8,26.9,
1.7,27.3,
1,28,
1.3,29,
0,30,
0,40,
21,40,
21.5,38,
22.7,38.5,
23,40,
36,40,
37,38.5,
35.5,38,
37,37,
35.6,35.6,
33,37,
29.6,37.5,
30.5,38.5,
28.5,40,
26,40,
26.7,38,
25,36.3,
28,36,
28.3,35,
25,34.5,
24.3,35.5,
21.7,32,
21,30.5,
22.5,28,
24,28.5,
27.5,27.5,
28.7,26,
29,24.5,
29.3,24.4,
29.7,23.5,
30,24,
30.4,25.5,
30,27,
31,27,
32,29,
32.2,30,
31.5,30.5,
31.7,31.5,
32.3,31.8,
31.2,36,
32.2,36.2,
34.5,33.5,
34.3,32.2,
35,32,
36,33,
37,34,
38,34,
38.7,33,
39.1,32.8,
40,31.4,
40,21.5 };

float states[1000] = {
3.5,23,/*-WA*/
3.5,22,
3,21.6,
3.2,22.3,
2.4,22.8,
2.4,21.6,
2.2,20.8,
3,20.6,
3.2,20,
6.3,19.5,
6.8,22.2,
3.5,23,
6.3,19.5,/*-OR*/ 
3.2,20,
3,20.6,
2.2,20.8,
2,19.8,
1,18.1,
1,17.2,
3.6,16.5,
6,16,
6.2,18.2,
6.6,19,
6.3,19.5,
3.6,16.5,/*-CA*/ 
1,17.2,
.4,16,
.25,13.6,
1,13.3,
.7,13,
1.4,11.1,
1.4,10.4,
3.6,8,
5.4,7.7,
6.4,9.5,
6,10,
3,13.8,
3.6,16.5,
3.6,16.5,/*-NV*/ 
3,13.8,
6,10,
6.2,10.5,
6.6,10.4,
6.7,11.1,
7.5,15.7,
6,16,
3.6,16.5,
6.7,11.1,/*-AZ*/ 
6.6,10.4,
6.2,10.5,
6,10,
6.4,9.5,
5.4,7.7,
8.1,6,
9.8,6,
10.1,10.8,
6.7,11.1,
7.5,15.7,/*-UT*/ 
6.7,11.1,
10.1,10.8,
10.5,14.5,
9.5,14.6,
9.6,15.5,
7.5,15.7,
7.6,22.1,/*-ID*/ 
6.8,22.2,
6.3,19.5,
6.6,19,
6.2,18.2,
6,16,
7.5,15.7,
9.6,15.5,
9.8,17.8,
9,17.6,
8.5,18.6,
7.9,18.6,
7.8,19.8,
7.3,20.2,
7.4,22.15,
14.7,21.15,/*-MT*/ 
7.4,22.15,
7.3,20.2,
7.8,19.8,
7.9,18.6,
8.5,18.6,
9,17.6,
9.8,17.8,
9.7,18.2,
14.4,17.8,
14.5,18.3,
14.7,21.15,
14.4,17.8,/*-WY*/ 
9.7,18.2,
9.8,17.8,
9.6,15.5,
9.5,14.6,
10.5,14.5,
14.2,14.2,
14.3,15.8,
14.4,17.8,
14.2,14.2,/*-CO*/ 
10.5,14.5,
10.1,10.8,
14.3,10.7,
15.1,10.65,
15.2,13.2,
15.25,14.2,
14.2,14.2,
14.3,10.7,/*-NM*/ 
10.1,10.8,
9.8,6,
10.5,6,
10.5,6.2,
11.6,6.2,
14.2,6.2,
14.3,10.7,
14.3,10.2,/*-TX*/ 
14.2,6.2,
11.6,6.2,
11.6,6.2,
13,4.8,
13,4.1,
14,3.8,
14.5,4.2,
15.4,4.2,
16.3,2.8,
17.2,1,
19,0.8,
18.8,2.3,
21.3,4.2,
21.2,5.8,
21,7.1,
20.9,7.9,
18.4,7.7,
16.7,8.1,
16.8,10.2,
14.3,10.2,
14.3,10.7,/*-OK*/ 
14.3,10.2,
16.8,10.2,
16.7,8.1,
18.4,7.7,
20.9,7.9,
20.8,10.3,
20.8,10.6,
15.1,10.65,
14.3,10.7,
15.2,13.2,/*-KS*/ 
15.1,10.65,
20.8,10.6,
20.6,12.4,
20,13.15,
15.2,13.2,
14.3,15.8,/*-NE*/ 
14.2,14.2,
15.25,14.2,
15.2,13.2,
20,13.15,
19,15.5,
17.6,15.8,
14.3,15.8,
14.5,18.3,/*-SD*/ 
14.4,17.8,
14.3,15.8,
17.6,15.8,
19,15.5,
19.4,16.3,
19.4,18.2,
14.5,18.3,
14.7,21.15,/*-ND*/ 
14.5,18.3,
19.4,18.2,
19,21.05,
14.7,21.15,
21.3,4.2,/*-LA*/ 
23,4.2,
24,3.8,
25.2,3.9,
24.6,4.4,
24.3,5.1,
22.9,5.1,
23.1,7.1,
21,7.1,
21.2,5.8,
20.8,10.3,/*-AK*/ 
20.9,7.9,
21,7.1,
23.1,7.1,
23,8,
23.6,9,
24,10,
23.2,10,
23.5,10.4,
20.8,10.3,
20,13.15,/*-MO*/ 
20.6,12.4,
20.8,10.6,
20.8,10.3,
23.5,10.4,
23.2,10,
24,10,
24.3,10.5,
24.4,10.8,
22.4,13.8,
19.68,13.8,
20,13.15,
19,15.5,/*-IO*/ 
19.68,13.8,
22.4,13.8,
23.2,14.9,
22.8,16.3,
19.4,16.3,
19,15.5,
19,21.05,/*-MN*/ 
19.4,18.2,
19.4,16.3,
22.8,16.3,
21.7,17.6,
22.1,19.1,
23,20,
23.7,20.4,
20.5,21,
20.3,21.4,
20.1,21.3,
20,21,
19,21.05,
23.6,9,/*MS*/ 
23,8,
23.1,7.1,
22.9,5.1,
24.3,5.1,
24.6,4.4,
25.5,4.6,
25.3,9.1,
23.6,9,
25.3,9.1,/*-AL*/ 
25.5,4.6,
26.3,4.75,
26.3,5.5,
28.2,5.6,
27,9.3,
25.3,9.1,
28.2,5.6,/*-FL*/ 
26.3,5.5,
26.3,4.75,
27.6,5,
28.2,4.7,
29.2,5,
30.4,4.2,
30.8,2.7,
32.2,1.2,
32.9,1.35,
33,2.5,
31,5.5,
30.95,6.3,
30.5,6.3,
30.1,5.7,
28.2,5.6,
27,9.3,/*-GA*/ 
28.2,5.6,
30.1,5.7,
30.5,6.3,
30.95,6.3,
30.9,6.6,
31.2,7.5,
29,9.4,
28,9.3,
27,9.3,
23,15.6,/*-IL*/ 
23.2,14.9,
22.4,13.8,
24.4,10.8,
25,11,
25.2,11.5,
25.3,12.5,
25.2,15,
25.1,15.6,
23,15.6,
21.7,17.6,/*-WI*/ 
22.8,16.3,
23,15.6,
25.1,15.6,
24.9,16.6,
25.3,18.7,
23,19,
22.8,19.4,
22.1,19.1,
21.7,17.6,
26.4,18.9,/*-MI*/ 
25.8,17.7,
26,16.2,
25.9,15.2,
26.8,15.25,
27.9,15.3,
28.4,16.5,
28,17,
28.2,17.5,
27.8,18.6,
26.4,18.9,	/*break  */
26.3,19.2,
24.3,19.3,
24.3,19.7,
23,19,
25.3,18.7,
26.3,19.2,
26.4,18.9,
25.9,15.2,/*-IN*/ 
25.2,15,
25.3,12.5,
25.2,11.5,
26.6,12,
27.2,13,
26.8,15.25,
25.9,15.2,
26.8,15.25,/*-OH*/ 
27.2,13,
28.9,12.7,
29.8,13.7,
30,14.6,
29.65,16,
28.4,15.2,
27.9,15.3,
26.8,15.25,
29,9.4,/*-SC*/ 
31.2,7.5,
32.6,9.1,
31.1,9.65,
30.7,9.55,
30.6,9.8,
29.5,9.75,
29,9.4,
28.9,12.7,/*-KY*/ 
27.2,13,
26.6,12,
25.2,11.5,
25,11,
24.4,10.8,
24.3,10.5,
28.5,10.8,
29.5,11.7,
28.9,12.7,
24.3,10.5,/*-TE*/ 
24,10,
23.6,9,
25.3,9.1,
27,9.3,
28,9.3,
29.8,11,
28.5,10.8,
24.3,10.5,
29.8,11,/*-NC*/ 
28,9.3,
29,9.4,
29.5,9.75,
30.6,9.8,
30.7,9.55,
31.1,9.65,
32.6,9.1,
34.3,11.3,
33.85,11.6,
29.8,11,
29.5,11.7,/*-VA*/ 
28.5,10.8,
29.8,11,
33.85,11.6,
33.5,12,
33.35,12.4,
32.3,13.7,
31.7,13.8,
30.6,11.75,
29.5,11.7,
30,14.6,/*-WV*/ 
29.8,13.7,
28.9,12.7,
29.5,11.7,
30.6,11.75,
31.7,13.8,
30.8,13.2,
30.7,14,
30.3,13.85,
30,14.6,
29.65,16,/*-PA*/ 
30,14.6,
30.3,13.85,
30.7,14,
33.2,14.5,
33.3,15,
32.9,15.6,
33.2,16.2,
32.9,16.5,
30.4,16,
30.2,16.4,
29.65,16,
30.7,14,/*-MD*/ 
30.8,13.2,
31.7,13.8,
32.3,13.7,
33.35,12.4,
33.1,13.5,
33.6,13,
34,12.5,
33.2,14.5,
30.7,14,
33.2,14.5,/*-DE*/ 
34,12.5,
34.17,13.8,
33.2,14.5,
33.2,16.2,/*-NJ*/ 
32.9,15.6,
33.3,15,
33.2,14.5,
34.17,13.8,
34.3,14.3,
34,14.4,
33.8,15.4,
34,15.4,
33.2,16.2,
32.8,19.4,/*-NY*/ 
32.2,18.5,
32,17.2,
30.3,17,
30.2,16.4,
30.4,16,
32.9,16.5,
33.2,16.2,
34,15.4,
34.5,15.5,
35,16,
34.4,16.2,
34.1,19.73,
32.8,19.4,
34.4,16.2,/*-CT*/ 
35.6,16.7,
35.6,17.7,
34.3,17.7,
34.4,16.2,
35.6,17.7,/*-RI*/ 
35.6,16.7,
36.3,16.85,
36,17.6,
35.6,17.7,
34.3,17.7,/*-MA*/ 
35.6,17.7,
36,17.6,
36.3,16.85,
37,17,
36.5,17.4,
36,18,
36.2,18.35,
34.8,18.1,
34.2,18,
34.3,17.7,
34.1,19.73,/*-VT*/ 
34.2,18,
34.8,18.1,
35,20,
34.1,19.73,
35,20,/*-NH*/ 
34.8,18.1,
36,18.3,
35.15,20.35,
35,20,
35.15,20.35,/*-ME*/ 
36,18.3,
36.12,18.35,
36.6,19.5,
36.7,20,
37.7,20.2,
37.5,20.8,
36.8,21.2,
36.5,22.3,
35.5,22.2,
35.15,20.35,
0, 0,	/* dc */
3, 0,
3, 3, 
0, 3,
3, 0,  /* alaska */
6, 0, 
6, 3,
3, 3,
6, 0, /* hawaii */
9, 0,
9, 3,
6, 3,  };

float provinces[370] = {
0,40,/*-YK*/ 
0,34.8,
3.6,33.2,
4.5,35.6,
3,40,
0,40,
0,34.8,/*-BC*/ 
0,30,
1.3,29,
1,28,
1.7,27.3,
1.8,26.9,
1.5,26.8,
1.7,26,
2.3,24.4,
1.4,25.1,
1.1,25,
2.4,23,
3.5,22.8,
2.5,24.2,
3.5,23,
6.8,22.2,
7.6,22.1,
8.9,22,
8.8,22.9,
6.7,24.4,
6.7,26.3,
5.6,27.9,
7,32,
3.6,33.2,
0,34.8,
7,32,/*-AB*/ 
5.6,27.9,
6.7,26.3,
6.7,24.4,
8.8,22.9,
8.9,22,
11.8,21.58,
13,31,
7,32,
13,31,/*-SK*/ 
11.8,21.62,
14.7,21.15,
16,21.13,
16.7,30.6,
13,31,
16.7,30.6,/*-MB*/ 
16,21.13,
20,21,
20.1,21.3,
20.3,21.4,
20.6,24.3,
20.3,25.2,
23.3,27.4,
23.3,28.35,
22.5,28,
21,30.5,
16.7,30.6,
23.3,28.35,/*-ON*/ 
23.3,27.4,
20.3,25.2,
20.6,24.3,
20.3,21.4,
20.5,21,
23.7,20.4,
24.3,21,
25.8,21,
26.8,19.5,
29.3,18.8,
28.7,16.4,
30.2,17,
30.5,17.8,
32.2,18.5,
32.8,19.4,
33.2,19.6,
33.15,20,
30.4,20.8,
31,22.3,
30,24,
29.7,23.5,
29.3,24.4,
29,24.5,
28.7,26,
27.5,27.5,
24,28.5,
23.3,28.35,
31,22.3,/*-QE*/ 
30.4,20.8,
33.15,20,
33.2,19.6,
35,20,
35.5,22.2,
36.5,22.3,
37.3,23.7,
40,25,
40,27,
39,26.6,
37.4,27.9,
38,28.6,
37.3,32.3,
37,34,
36,33,
35,32,
34.3,32.2,
34.5,33.5,
32.2,36.2,
31.2,36,
32.3,31.8,
31.7,31.5,
31.5,30.5,
32.2,30,
32,29,
31,27,
30,27,
30.4,25.5,
30,24,
31,22.3,
40,25,/*-NB*/ 
37.3,23.7,
36.5,22.3,
36.8,21.2,
37.5,20.8,
38.3,21.6,
38.6,21.4,
38,20,
38.4,19.5,
39.5,20,
40,21.5,
40,25,
40,31.4,/*-NF*/ 
39.1,32.8,
38.7,33,
38,34,
37,34,
37.3,32.3,
38,28.6,
37.4,27.9,
39,26.6,
40,27,
40,31.4,
3,40,/*-NW*/ 
4.5,35.6,
3.6,33.2,
7,32,
13,31,
16.7,30.6,
21,30.5,
21.7,32,
24.3,35.5,
25,34.5,
28.3,35,
28,36,
25,36.3,
26.7,38,
26,40,
28.5,40,
30.5,38.5,
29.6,37.5,
33,37,
35.6,35.6,
37,37,
35.5,38,
37,38.5,
36,40,
23,40,
22.7,38.5,
21.5,38,
21,40,
3,40,
34, 0, /* P.E.Is. */
37, 0,
37, 3,
34, 3,
37, 0, /* N. S. */
40, 0,
40, 3, 
37, 3 };

char sindex[110][4] = {
"0", "wa",
"12", "or",
"24", "ca",
"38", "nv",
"47", "az",
"57", "ut",
"64", "id",
"79", "mt",
"91", "wy",
"100", "co",
"108", "nm",
"116", "tx",
"137", "ok",
"147", "ks",
"153", "ne",
"161", "sd",
"169", "nd",
"174", "la",
"184", "ar",
"194", "mo",
"206", "ia",
"213", "mn",
"226", "ms",
"235", "al",
"242", "fl",
"258", "ga",
"268", "il",
"278", "wi",
"288", "mi",
"306", "in",
"314", "oh",
"323", "sc",
"331", "ky",
"341", "tn",
"350", "nc",
"361", "va",
"371", "wv",
"381", "pa",
"393", "md",
"403", "de",
"407", "nj",
"417", "ny",
"431", "ct",
"436", "ri",
"441", "ma",
"452", "vt",
"457", "nh",
"462", "me",
"473", "dc",
"477", "ak",
"481", "hi",
"485" };

char pindex[26][4] = {
"0", "yk",
"6", "bc",
"31", "ab",
"40", "sa",
"46", "mb",
"58", "on",
"86", "qu",
"117", "nb",
"129", "nf",
"140", "nw",
"169", "pe",
"173", "ns",
"177" };

int nusa = 105;
int ncanada = 93;
int nstates = 485;
int nprovinces = 177;
int nsi = 51;
int npi = 12;

char *sname[55] = {
"Washington",
"Oregon",
"California",
"Nevada",
"Arizona",
"Utah",
"Idaho",
"Montana",
"Wyoming",
"Colorado",
 "New Mexico",
 "Texas",
 "Oklahoma",
 "Kansas",
 "Nebraska",
 "S Dakota",
 "N Dakota",
 "Louisiana",
 "Arkansas",
 "Missouri",
 "Iowa",
 "Minnesota",
 "Mississippi",
 "Alabama",
 "Florida",
 "Georgia",
 "Illinois",
 "Wisconsin",
 "Michigan",
 "Indiana",
 "Ohio",
 "S Carolina",
 "Kentucky",
 "Tennessee",
 "N Carolina",
 "Virginia",
 "W Virginia",
 "Pennsylvania",
 "Maryland",
 "Delaware",
 "New Jersey",
 "New York",
 "Connecticut",
 "Rhode Island",
 "Massachusetts",
 "Vermont",
 "New Hampshire",
 "Maine",
 "Dist. of Columbia",
 "Alaska",
 "Hawaii" };

char *pname[12] = {
"Yukon",
"Brit. Columbia",
"Alberta",
"Saskatchewan",
"Manitoba",
"Ontario",
"Quebec",
"New Brunswick",
"Newfoundland",
"Northwest Terr.",
"Prince Edward Is.",
"Nova Scotia" };

SHAR_EOF
############################

echo src/mark.c
cat << \SHAR_EOF > src/mark.c
#include "elib.x"
/* draw a data point */
/* point styles are selected by the code string "symNSf.ff", where N is an integer
   0-9 selecting the shape, S is a lower-case character selecting the style, and
   f.ff is an optional shade, which overrides that selected as part of the style.  
   N and S are required.  See point1.g in the examples.
*/
#define NVARIAT 18
#define NSHAPE 8


Emark( x, y, code, r )
double x, y; 	/* point location in abs space */
char code[];	/* pre-set symbol name */
double r; 	/* radius of dot in absolute units */
{
int i;
double g, theta;
static char prevcode[10] = "";
static double prev_r, shade;
static int inc, ins;
static int nc[] =    {  3,  3,  4,  4,  5, 12, 3, 3 };	/* number of corners */
static int nt[] =    { 90,270,  0, 45, 90, 90, 0, 180 }; /* location (in deg) to start building point */
/* preset outline thicknesses.. */
static double ol[] = { .5,  1,1.5,  2, .5, .5, .5, .5, .5,  0,  0,  0,  0, 0, -0.5, -1, -1.5, -2 }; 
/* preset shades..  */
static double sh[] = { -1, -1, -1, -1,  1, .9, .7, .5, .3, .9, .7, .5, .3, 0, -1, -1,  -1,  -1 }; 
static double h[14][2]; /* the offsets */

/* no-op code */
if( strcmp( code, "sym00" ) == 0 ) return( 0 );

if( strcmp( code, prevcode ) != 0 || r != prev_r ) {
	strcpy( prevcode, code );
	prev_r = r;
	inc = ((code[3] - '0') -1 ) % NSHAPE;
	if( code[4] == '\0' ) code[4] = 'a';
	ins = (code[4] - 'a') % NVARIAT;
	if( strlen( code ) > 5 )shade = atof( &code[5] );
	else shade = sh[ins];

	theta = 360.0 / (double)nc[inc];
	/* get offsets */
	g = nt[inc];
	for( i = 0; i < nc[inc]; i++ ) {
		h[i][0] = r * cos( (g*3.1415927)/180.0 );
		h[i][1] = r * sin( (g*3.1415927)/180.0 );
		g += theta;
		}
	}

/* lock-on */
/* shade point */
if( shade >= 0 ) {
	Emov( x+h[0][0], y+h[0][1] );
	for( i = 1; i < nc[inc]; i++ ) Epath( x+h[i][0], y+h[i][1] );
	Eshade( shade );
	}

/* draw perimeter point */
if( ol[ins] > 0.0 ) {
	Elinetype( 0, ol[ins], 1.0 );
	Emov( x+h[0][0], y+h[0][1] );
	for( i = 1; i < nc[inc]; i++ ) Elin( x+h[i][0], y+h[i][1] );
	Elin( x+h[0][0], y+h[0][1] );
	Enormline();
	}

/* draw spokes */
if( ol[ins] < 0.0 ) {
	double fabs();
	Elinetype( 0, fabs(ol[ins]), 1.0 );
	for( i = 0; i < nc[inc]; i++ ) { Emov( x, y ); Elin( x+h[i][0], y+h[i][1] ); }
	Enormline();
	}
/* lock-off */

}


/* ======================================= */
/* draw a circle of n "sides" */
Ecircle( cx, cy, r, shade, outline )
double cx, cy; 	/* point location in abs space */
double r; 	/* radius of dot in absolute units */
double shade;	/* shade, from 0.0 to 1.0.  If shade < 0.0, no filling takes place. */
int outline;    /* if 1, circle will be outlined. */
{
double theta, x, y, g;
int i;
static double hx[32], hy[32];
static int first = 1;
int n;

n = 25;


if( first ) {
	first = 0;
	theta = 360.0 / (double)n;
	/* get offsets */
	g = 0.0;
	for( i = 0; i < n+1; i++ ) {
		hx[i] = cos( (g*3.1415927)/180.0 );
		hy[i] = sin( (g*3.1415927)/180.0 );
		g += theta;
		}
	}
if( shade >= 0.0 ) {
	for( i = 0; i < n+1; i++ ) {
		if( i == 0 ) Emov( cx+(r*hx[i]), cy+(r*hy[i]) );
		else Epath( cx+(r*hx[i]), cy+(r*hy[i]) );
		}
	Eshade( shade );
	}
if( outline ) {
	for( i = 0; i < n+1; i++ ) {
		if( i == 0 ) Emov( cx+(r*hx[i]), cy+(r*hy[i]) );
		else Elin( cx+(r*hx[i]), cy+(r*hy[i]) );
		}
	}
}
/* ========================================= */
/* draw an elipse */
Eellipse( cx, cy, r1, r2, shade, outline )
double cx, cy, r1, r2;
double shade;	/* shade, from 0.0 to 1.0.  If shade < 0.0, no filling takes place. */
int outline;    /* if 1, circle will be outlined. */
{
double theta, x, y, g;
int i;
static double hx[32], hy[32];
int n;

n = 25;

theta = 360.0 / (double)n;
/* get offsets */
g = 0.0;
for( i = 0; i < n+1; i++ ) {
        hx[i] = cos( (g*3.1415927)/180.0 );
        hy[i] = sin( (g*3.1415927)/180.0 );
        g += theta;
        }

if( shade >= 0.0 ) {
	for( i = 0; i < n+1; i++ ) {
       		if( i == 0 ) Emov( cx+(r1*hx[i]), cy+(r2*hy[i]) );
        	else Epath( cx+(r1*hx[i]), cy+(r2*hy[i]) );
		}
	Eshade( shade );
        }

if( outline ) {
	for( i = 0; i < n+1; i++ ) {
	        if( i == 0 ) Emov( cx+(r1*hx[i]), cy+(r2*hy[i]) );
	        else Elin( cx+(r1*hx[i]), cy+(r2*hy[i]) );
	        }
	}
}


SHAR_EOF
############################

echo src/obj.c
cat << \SHAR_EOF > src/obj.c
#include "elib.x"
#define MAXNEST 6

static int Enest = 0;				/* current object nest level */
static double Exmax[MAXNEST], Eymax[MAXNEST], Exmin[MAXNEST], Eymin[MAXNEST]; /*obj stack: bounding info*/
static int Ecalcflag[MAXNEST];			/* obj stack: does bb need to be calculated? */
static int Eid[MAXNEST];			/* obj stack: obj ids */
static int Ewhichend = 0;

/* ================================================= */
/* Begin an object. */
Eobjbegin( id )
int id;
{
char str[E_GPBUF];
int len;

if( Enest > (MAXNEST-1) ) { fprintf( stderr, "too many object nest levels\n" ); return( 0 ); }
Eid[ Enest ] = id;

/* if bb exists (but not in inheritance) , it need not be computed.. */
EIgetd( id, "*", "bb", &len );
if( len != 4 ) {
	Ecalcflag[ Enest ] = 1;
	Exmax[ Enest ] = -1.0; Exmin[ Enest ] = 20.0;
	Eymax[ Enest ] = -1.0; Eymin[ Enest ] = 20.0;
	}
else Ecalcflag[ Enest ] = 0;

/* set parent */
if( Enest >= 1 ) {
	sprintf( str, "%d", Eid[ Enest-1 ] );
	EImodattr( id, "", "*/parent", str );
	}
Enest++;
Esetobjectflag( 1 ); /* see pcode.c */
}
	
/* ================================================= */
/* End an object.  Save the bounding box we just calculated.. */
/* Returns the proc_id of the object. */
Eobjend( bbtyp )
char bbtyp[];
{
char str[E_GPBUF];
int i;

Enest--;
if( Enest <= 0 ) Enest = 0; 

if( ! (( Exmin[ Enest ] > Exmax[ Enest ] ) && ( Eymin[ Enest ] > Eymax[ Enest ] )) 
    && Ecalcflag[ Enest ] ) {
	sprintf( str, "%g %g %g %g", Exmin[ Enest ], Eymin[ Enest ], Exmax[ Enest ], Eymax[ Enest ] );
	EImodattr( Eid[ Enest ], "", "*/bb", str );
	EImodattr( Eid[ Enest ], "", "*/bbt", bbtyp );
	}
if( Enest == 0 ) Esetobjectflag( 0 ); /* see pcode.c */
return( Eid[ Enest ] );
}
/* ================================================= */
Echecknest()
{
return( Enest );
}

/* ================================================= */
/* check bounding box to see if we have new min or max.. */
/* (checks all active group nest levels..) */
Echeckbb( x, y )
double x, y;
{
int inest;

if( Enest == 0 ) return( 1 );  /* level 0 -- no need to keep info.. */

for( inest = 0; inest < Enest; inest++ ) {
	if( Ecalcflag[ inest ] == 1 ) {
		if( x > Exmax[ inest ] ) Exmax[ inest ] =  x;
		if( x < Exmin[ inest ] ) Exmin[ inest ] =  x;
		if( y > Eymax[ inest ] ) Eymax[ inest ] =  y;
		if( y < Eymin[ inest ] ) Eymin[ inest ] =  y;
		}
	}
}
/* =============================================== */
/* null out the bounding box of an object (and all ancestors), to */
/* forced them to be recalculated.  */
Enulloutbb( p )
int p;
{
int *parent, len;

while( 1 ) {
	if( !EIexists( p, "", "*/bb" )) return( 0 );

	EImodattr( p, "", "*/bb", "" );
	parent = EIgeti( p, "", "*/parent", &len );
	if( len < 1 ) return( 0 );
	else p = *parent;
	}
}

/* =============================================== */
/* show the zone of an object */

Eobjoutline( id )
int id;
{
double *p, *q, *r, *s;
char *typ;
/* remember the parameters from last highlight so we can turn it off */
static double op, oq, or, os;
static char otyp = '\0';
int len;

Ejournalsuspend();
Egraphenv( E_PUSH );
Elinetype( 0, 3.0, 1.0 );
if( otyp != '\0' ) { /* get rid of emphasis */
	Epenerase();
	if( otyp == 'B' ) Eblock( op, oq, or, os, -1.0, 1 );
	else if( otyp == 'L' ) { Emov( op, oq ); Elin( or, os ); }
	Ependraw();
	Elinetype( 1, 0.5, 1.0 );
	if( otyp == 'B' ) Eblock( op, oq, or, os, -1.0, 1 );
	else if( otyp == 'L' ) { Emov( op, oq ); Elin( or, os ); }
	Elinetype( 0, 3.0, 1.0 );
	}

if( id == E_NIL ) { otyp = '\0'; goto RETURN; }


if( ! EIexists( id, "*", "bb" )) goto RETURN;
p = EIgetd( id, "*", "bb", &len );
if( len != 4 ) goto RETURN;
q = p+1; r = p+2; s = p+3;
typ = EIgetc( id, "*","bbt", &len );

if( *typ == 'B' ) Eblock( *p, *q, *r, *s, -1.0, 1 );
else if( *typ == 'L' ) { Emov( *p, *q ); Elin( *r, *s ); }

otyp = (*typ); op = (*p); oq = (*q); or = (*r); os = (*s);


RETURN:
Egraphenv( E_POP );
Ejournalresume();
return( 0 );
}

/* =============================================== */
/* show the tentative zone of an object if translated or scaled by (x,y) */


Etentativeoutline( id, tx, ty, mode )
int id;
double tx, ty;
char mode[];  /* T for translate or S for scale */
{
double *p, *q, *r, *s;
char *typ;
/* remember the parameters from last highlight so we can turn it off */
static double op, oq, or, os;
static char otyp = '\0';
int len;

Ejournalsuspend();
Egraphenv( E_PUSH );
Elinetype( 0, 2.0, 1.0 );
if( otyp != '\0' ) {
	Epenerase();
	if( otyp == 'B' ) Eblock( op, oq, or, os, -1.0, 1 );
	else if( otyp == 'L' ) { Emov( op, oq ); Elin( or, os ); }
	Ependraw();
	}

if( id == E_NIL ) { Ewhichend = 0; otyp = '\0'; goto RETURN; } /* reset */

if( ! EIexists( id, "*", "bb" )) goto RETURN;
p = EIgetd( id, "*", "bb", &len );
if( len != 4 ) goto RETURN;
q = p+1; r = p+2; s = p+3;

typ = EIgetc( id, "*", "bbt", &len );

if( mode[0] == 'T' ) { /* translation (move,copy,show)*/
	if( *typ == 'B' ) Eblock( *p+tx, *q+ty, *r+tx, *s+ty, -1.0, 1 );
	else if( *typ == 'L' ) { Emov( *p+tx, *q+ty ); Elin( *r+tx, *s+ty ); }
	otyp= (*typ); op = *p+tx; oq = *q+ty; or=*r+tx; os = *s+ty;
	}
else if( mode[0] == 'S' ) { /* scaling (resize) */
	if( *typ == 'B' ) {
		Eblock( *p, *q, tx, ty, -1.0, 1 );
		op = *p; oq = *q; or=tx; os = ty;
		}
	else if( *typ == 'L' ) { 
		/* needs work */
		if( Ewhichend == 0 ) {
			if( (fabs(tx-*p)+fabs(ty-*q)) < (fabs(tx-*r)+fabs(ty-*s))) Ewhichend = 1;
			else Ewhichend = 2;
			}
		if( Ewhichend == 1 ) { Emov( tx, ty ); Elin( *r, *s ); op=tx; oq=ty; or=*r; os=*s; }
		else if( Ewhichend == 2 ) { Emov( *p, *q ); Elin( tx, ty ); op=*p; oq=*q; or=tx; os=ty; }
		}
	otyp = *typ;
	}

RETURN:
Egraphenv( E_POP );
Ejournalresume();
return( 0 );
}
/* =========================================== */
/* show all bounding boxes */
Eshowallbounds()
{
int i, n;
char *typ;
double *d1, *d2, *d3, *d4;
int len;
int ip;

Egraphenv( E_PUSH );
Ejournalsuspend();
Elinetype( 0, 3.0, 3.0 );
EIgetnextobj( E_AT_BEGINNING, 0 );
while( 1 ) {
	ip = EIgetnextobj( E_NEXT, 0 ); 
	if( ip < 0 ) break;

	if( ! EIexists( ip, "*", "bb" )) continue;
	d1 = EIgetd( ip, "*", "bb", &len );
	if( len != 4 ) continue;
	d2 = d1 + 1; d3 = d1 + 2; d4 = d1 + 3;

	typ = EIgetc( ip, "*", "bbt", &len );
	if( len < 1 ) continue;

        EIgetc( ip, "*", "display", &len );
        if( len < 1 ) continue; /* its invisible.. */
	
	if( *typ == 'B' ) Eblock( *d1, *d2, *d3, *d4, -1.0, 1 );
	else if( *typ == 'L' ) { Emov( *d1, *d2 ); Elin( *d3, *d4 ); }
	}
EIgetnextobj( E_DONE, 0 );
Ejournalresume();
Egraphenv( E_POP );
}
/* ============================================== */
SHAR_EOF
############################

echo src/pcode.c
cat << \SHAR_EOF > src/pcode.c
/* PCODE - all text/graphics requests (except init) are processed
		via this function.  Many E function calls such
		as Emov and Elin are actually macros defined in
		elib.d, which call pcode with a single character
		op code and perhaps some parameters.

   ==========================================================================
   Device codes (Edev):
	p		postscript
	x		X11

   Op codes:
	L		lineto
	M		moveto
	P		path to
	T, C, J		text, centered text, right justified text
	S		shade
	O		paper (ps only)
	I		text size
	F		text font 
	D		text direction (ps only)
	Y		line properties
	Z		print/eject (ps only)
	B, b		batching on/off for efficiency (sv only)
	R		line/text color
	W		wait for a key or mouse click (win only)
	w		cycle notifier from within a loop (win only)
	.		dot
	z		clear screen 
	d		make window disappear (x11 only)
	a		make window re-appear (x11 only)
	e		set text scale factor (x11 only, when user resizes window)
	Q		end of file (tells ps driver to append trailer)


   ==========================================================================

   NOTE: When Ewidth is returned by the x11 text functions, it is ignored.
*/

#include "elib.x"

static int Ejournal = 0;			/* journal on/off */
static int Ejournalsusp = 0;			/* journal suspend counter */
static int Enew = 0, Edrawing = 0;		/* used by postscript section */
static int Evertchar = 0; 			/* true if character direction is vertical..*/
						/* ..used by x11 to do vertical characters */
static double Ecurx;				/* real starting place of centered &rt justified text */
static double Ewidth;				/* width of most recently drawn text line. */
static char Eprevop;				/* previous op */
static double Etx = 0, Ety = 0;			/* current translation vector */
static int Edoingobject = 0;			/* are we inside an object begin/end? 1=yes */
static int Esquelched = 0;			/* is output being squelched? 1=yes, 0=no */
static int Epspage = 1;			/* current page # */
static int Epsvirginpage = 1;		/* 1 when nothing has yet been drawn on current page */
static int bbexempt = 0;
					
static double Epsx1 = 999;		/* coords of bounding box for entire run */
static double Epsy1 = 999;
static double Epsx2 = -999;
static double Epsy2 = -999;


Epcode( op, x, y, s )
char op; /* op code */
double x, y;  /* coordinates */
char s[];     /* optional character string */
{
char buf[E_GPBUF];


/* Do object package related translation.. if any..  */
if( Emember( op, "MLP." )) { 
	x += Etx; y += Ety; /* translate.. */
	}

/* Postscript: intercept all 'clear' ops - they're not necessary and
   mess up bounding box calculation.. */
if( Edev == 'p' && op == 'z' ) return( 0 );


/* Postscript: inform driver we're beginning a new page.. */
if( Edev == 'p' && Epsvirginpage && !Emember( op, "Q" ) ) {
	EPSnewpage( Epspage );
	Epsvirginpage = 0;
	}

/* if output is squelched, do not do any draw operations, except textsize, which
   returns text width, which is necessary for bb calculations.. */
if( Esquelched ) {
	if( op == 'I' ) {
#ifndef NOX11
		if( Edev == 'x' ) { EXWpointsize( (int)(x), &Ecurtextwidth ); }
#endif
		}
	}


#ifndef NOX11
else if( Edev == 'x' ) {
	switch (op) {
		case 'L' : EXWlineto( x, y ); break;
		case 'M' : EXWmoveto( x, y ); break;
		case 'P' : EXWpath( x, y ); break;
		case 'T' : if( !Evertchar ) EXWtext( s, &Ewidth ); 
			   break;
		case 'U' : EXWflush(); break;
		case 'I' : EXWpointsize( (int)(x), &Ecurtextwidth ); break;
		case 'S' : EXWshade( x ); break;
		case 'C' : if( !Evertchar ) { 
				EXWmoveto( Ex1-6.0, Ey1 ); 
				EXWcentext( s, 12.0, &Ecurx, &Ewidth ); 
				}
			   break;
		case 'J' : if( !Evertchar ) {
				EXWmoveto( Ex1-12.0, Ey1 ); 
				EXWrightjust( s, 12.0, &Ecurx, &Ewidth );
				}
			   break;
		case 'W' : EXWwait(); break;
		case 'Y' : EXWlinetype( s, x, y ); break;
		case 'D' : if( x == 90 || x == 270 ) Evertchar = 1;
			   else Evertchar = 0;
			   break;
		case 'R' : EXWcolor( (int)(x)); break;
		case 'w' : EXWasync(); break;
		case '.' : EXWdot( x, y ); break;
		case 'd' : EXWdisappear(); break;
		case 'a' : EXWappear(); break;
		case 'e' : EXWscaletext( x ); break;
		}
	}
else
#endif

/* interface to postscript driver */
if( Edev == 'p'  ) {

	if( op != 'L' ) { 
		if( Edrawing ) EPSstroke(); 
		Edrawing = 0;
		}

	switch( op ) {
		case 'L' : if( Enew ) EPSmoveto( Ex1, Ey1 ); 
			    EPSlineto( x, y );
			    Enew = 0;
			    Edrawing = 1;
			    break;
		case 'M' : Enew = 1; break;
		case 'P' : if( Enew ) EPSmoveto( Ex1, Ey1 ); 
			   EPSpath( x, y ); 
			   Enew = 0;
			   break;
		case 'T' : EPStext( op, Ex1, Ey1, s, 0.0 ); break;
	
		case 'C' : if( !Evertchar ) EPStext( op, Ex1-6.0, Ey1, s, 12.0 );
			   else if( Evertchar )EPStext( op, Ex1, Ey1-6.0, s, 12.0 );
			   break;
		case 'J' : if( !Evertchar ) EPStext( op, Ex1-12.0, Ey1, s, 12.0 );
			   else if( Evertchar ) EPStext( op, Ex1, Ey1-12.0, s, 12.0 );
			   break;
	
		case 'S' : EPSshade( x ); break;
		case 'O' : EPSpaper( (int)x ); break;
		case 'I' : EPSpointsize( (int)x ); break;
		case 'F' : EPSfont( s ); break;
		case 'D' : EPSchardir( (int)x );
			   if( x == 90 || x == 270 ) Evertchar = 1;
			   else Evertchar = 0;
			   break;
		case 'Y' : EPSlinetype( s, x, y ); break;
		case 'Z' : EPSshow(); Epspage++; Epsvirginpage = 1; break;
		case 'Q' : if( !Epsvirginpage ) { EPSshow(); Epspage++; }
			   /* the 0.2 margin is to be generous in cases of fat lines, etc. */
			   EPStrailer( Epspage - 1, Epsx1-0.2, Epsy1-0.2, Epsx2+0.2, Epsy2+0.2 );
			   break;
		/* case '.' : EPSdot( x, y ); ??? */
		/* case 'R' : ??? */
		}
	}



else { 
	if( Edev == '\0' ) fprintf( stderr, "Elib has not been initialized (device is null).\n" );
	else fprintf( stderr, "Unrecognised graphic environment (%c).\n", Edev ); 
	exit();
	}



/* non device-dependent actions.. */

if( op == 'M' ) { Ex1 = x; Ey1 = y; } /* remember most recent 'move' */

else if( op == 'L' ) { Ex2 = x; Ey2 = y; } /* remember most recent 'line' */


/* add to journal.. */
if( Ejournal && (!Ejournalsusp) && Edoingobject && Edev != 'n' ) {
	if( ! Emember( op, "zWwBb#" )) {
		sprintf( buf, "%c %g %g %s", op, x, y, s );
		EIaddcontline( buf );
		}
	}

/* figure text dimensions */
if( Emember( op, "TCJ" )) {
	if( Emember( Edev, "xs" )) Ewidth = strlen( s ) * Ecurtextwidth;
	/* else if( Edev == 'p' ) Ewidth = EPStextwidth( s )??? */
	}



/* keep bounding box info (minima and maxima) */
if( Emember( op, "LP" ) ) {
	if( Eprevop == 'M' ) Ebb( Ex1, Ey1 );
	Ebb( x, y );
	}
/* normal (horizontal) text operations.  (vertical text below) */
else if( op == 'T' && !Evertchar ) {
	if( Eprevop == 'M' ) Ebb( Ex1, Ey1 );
	Ebb( Ex1+Ewidth+0.05, Ey1+Ecurtextheight );
	}
else if( op == 'C' && !Evertchar ) { 
	Ebb( Ex1-((Ewidth/2.0)+0.05), Ey1 );
	Ebb( Ex1+((Ewidth/2.0)+0.05), Ey1+Ecurtextheight );
	}
else if( op == 'J' && !Evertchar ) { 
	Ebb( Ex1-(Ewidth+0.05), Ey1 );
	Ebb( Ex1, Ey1+Ecurtextheight );
	}
Eprevop = op;


/* clear screen (recursive) */
if( op == 'z' && Edev != 'n' ) { 
	Eobjoutline( E_NIL ); /* reset */
	Etentativeoutline( E_NIL, 0.0, 0.0, "" ); /* reset */
	Eblock( 0.0, 0.0, EWinx, EWiny, x, 0 ); 
	/* if( status != E_DOING_LOAD )Edumpgraphenv(); */
	}

/* vertical text simulation (recursive) */
else if( Evertchar && Emember( Edev, "sxn" ) && Emember( op, "TCJ" )) Everttextsim( op, s );
}

/* ============================================= */
/* EBB - keep an overall bounding box for the entire image.
	 Also call Echeckbb() to maintain nested object bounding boxes.. */
/* Ebb( double x, double y ) */
Ebb( x, y )
double x, y;
{
if( bbexempt ) return( 0 );

if( x < Epsx1 ) Epsx1 = x;
if( x > Epsx2 ) Epsx2 = x;
if( y < Epsy1 ) Epsy1 = y;
if( y > Epsy2 ) Epsy2 = y;

Echeckbb( x, y );
return( 0 );
}


/* ============================================== */
/* EGETTEXTSIZE - get width and height of last text item.. */

Egettextsize( w, h )
  double *w, *h;
{
*w = Ewidth;
*h = Ecurtextheight;
}


/* ============================================== */
/* turn journalling on/off */
Ejournalon()
{
Ejournal = 1;
Ejournalsusp = 0;
}

/* ============================================== */
Ejournaloff()
{
Ejournal = 0;
Ejournalsusp = 0;
}
/* ============================================== */
/* suspend / resume journalling.. */
Ejournalsuspend()
{
Ejournalsusp++;
}
/* ============================================== */
Ejournalresume()
{
if( Ejournalsusp > 0 ) Ejournalsusp--;
}
/* ================================================ */
/* vertical text simulation for window displays */
Everttextsim( op, s )
char op, s[];
{
double dist, x1, y1, x2, y2;
Ejournalsuspend();
dist = strlen(s) * (Ecurtextheight/2.0);
x1 = Ex1-Ecurtextheight; 
x2 = Ex1;
if( op == 'T' ) { y1 = Ey1; y2 = Ey1 + dist; }
else if( op == 'C' ) { y1 = Ey1-(dist/2); y2 = Ey1 + (dist/2); }
else if( op == 'J' ) { y1 = Ey1-dist; y2 = Ey1; }
Eblock( x1, y1, x2, y2, 0.9, 1 );
Ejournalresume();
}

/* ================================================== */
Etrladd( x, y )
double x, y;
{
Etx += x;  Ety += y;
}
/* ================================================== */
Etrlset( x, y )
double x, y;
{
Etx = x; Ety = y;
}
/* ================================================== */
Etrlget( x, y )
double *x, *y;
{
*x = Etx; *y = Ety;
}
/* =================================================== */
Esetobjectflag( mode )
int mode; /* 1 = doing an object-- ok to write journal.  0 - not */
{
int ip;
if( mode == 1 && mode == Edoingobject && Ejournal ) { 
	fprintf( stderr, "Warning, nested objects are not allowed while in journal mode --ignored.\n" );
	return( 1 );
	}
Edoingobject = mode;
}
/* =================================================== */
/* This routine should be used to begin an elib journal object. */
/* Eend_journal_object() should be used to end the object. */
/* It returns the proc_id of the journal object. */
Ebegin_journal_object()
{
int ip;
Ejournalon();
ip = EIcreate( "elib_journal" );
EImodattr( ip, "", "text", "# 0 0" ); /* will be appended to by subsequent journal writes. */
Eobjbegin( ip );
return( ip );
}
/* =================================================== */
/* This routine should be used to end an elib journal object. */
/* typ is the type of bounding zone: "B" = box (usually used)  "L" = line */
Eend_journal_object( typ )
char typ[];
{
Eobjend( typ );
Ejournaloff( );
}
/* ==================================================== */
/* 1 = squelch all display activity, 0 restore to normal */
/* handles nested calls. */
Esquelch_display( mode )
int mode;
{
static int snest = 0;
if( mode == 1 ) {
	snest++;
	Esquelched = 1;
	}
else if( mode == 0 ) { 
	if( snest > 0 ) snest--;
	if( snest == 0 )Esquelched = 0;
	}
}

/* ================================== */
/* 1 = make what follows exempt from bb checking, 0 restore to normal */
Ebbexempt( mode )
{
bbexempt = mode;
}
SHAR_EOF
############################

echo src/ps.c
cat << \SHAR_EOF > src/ps.c
/*
COPA 1.0 - gui control panel kit for shell, C, perl etc.  
*              **      **                              *
Copyright 1991-1996 by Stephen C. Grubb.

Permission is hereby granted to USE this software for free.
Permission is hereby granted to MODIFY and/or REDISTRIBUTE 
this software for free, provided that no monetary gain is 
realized, and all attached authorship and copyright notices 
are preserved.

Inclusion of any portion (or derivation) of this software, 
including ancillary files, in any commercial product is not 
allowed without prior written permission of the author.  

See also the file 'Copyright'. 
*/





/* Postscript driver.	(c) 1989 Steve Grubb


	13 Nov 95 scg	upgraded to EPSF-3.0 guidelines, including:
			bounding box and page # information; and
			using "userdict begin" and "end" to ensure
			that dictionary stack is undisturbed.

			As far as I can tell, all operands pushed onto
			the operand stack will be popped.

			Added a closepath to the stroke operator.

			Added EPstdout to ensure that stdout doesn't get
			fclosed.
*/

#include <stdio.h>
#define YES 1
#define NO 0
#define PORTRAIT 0
#define LANDSCAPE 1
#define MARG_X 14 
#define MARG_Y 8 
#define PAGWIDTH 600;

static int EPorient;		/* paper orientation */
static int EPorgx, EPorgy;	/* location of origin on page */
static int EPtheta;		/* current rotation for page orientation */
static char EPfont[50];		/* current font name */
static int EPchdir;	 	/* char direction in degrees */
static int EPcurpointsz;		/* current char size in points */
static double EPlinewidth, EPdashmag; /* line thickness and dash magnif. */
static char EPlinetype[20];		/* line type */
static int EPstdout;		/* 1 if Epf is stdout */

double atof();
static FILE *Epf;

/* ============================= */
EPSsetup( name, f )    /* initialize */
char *name; /* arbitrary name */
char f[];  /* file to put code in */
{  
/* set globals */
EPorient = -1;
strcpy( EPfont, "/Helvetica" );
EPtheta = 0;
EPchdir = 0;
EPcurpointsz = 10;

EPstdout = 0;
if( f[0] == '-' ) {
	Epf = stdout;
	EPstdout = 1;
	}
else Epf = fopen( f, "w" );
if( Epf == NULL ) Epf = stdout;

/* print header */
fprintf( Epf,  "%%!PS-Adobe-3.0 EPSF-3.0\n" );
fprintf( Epf,  "%%%%Title: %s\n", name );
fprintf( Epf,  "%%%%Creator: elib 2.0\n" );
fprintf( Epf,  "%%%%Copyright: Generated by ELIB 2.0 (c) 1989-96 Stephen Grubb\n" );
fprintf( Epf,  "%%%%Copyright: and Johns Hopkins University School of Medicine.\n" );
fprintf( Epf,  "%%%%Copyright: stevegru@welchlink.welch.jhu.edu\n" );
fprintf( Epf,  "%%%%Copyright: 550 N. Broadway #900 Baltimore, Maryland 21205 USA\n" );
fprintf( Epf,  "%%%%Pages: (atend)\n%%%%BoundingBox: (atend)\n%%%%EndComments\n\n\n" );
fprintf( Epf,  "%%%%BeginProlog\n" );

	
/* set up macros (mainly to reduce output verbosity) */
fprintf( Epf,  "userdict begin\n" );
fprintf( Epf,  "/sset\n" );
fprintf( Epf,  "{ translate rotate } def \n" );
fprintf( Epf,  "/sclr\n" );
fprintf( Epf,  "{ rotate translate } def \n" );
fprintf( Epf,  "/mv { moveto } def\n" );
fprintf( Epf,  "/np { newpath } def\n" );
fprintf( Epf,  "/ln { lineto } def\n" );
/* fprintf( Epf,  "/st { closepath stroke } def\n" ); */ /* closepath added scg 11-9-95 */
fprintf( Epf,  "/st { stroke } def\n" ); /* closepath deleted scg 1-23-96 */
fprintf( Epf,  "/sh { show } def\n" );
fprintf( Epf,  "/cent { stringwidth pop sub 2 div 0 rmoveto } def\n" );
fprintf( Epf,  "/rjust { stringwidth pop sub 0 rmoveto } def\n" );

/* load default font */
fprintf( Epf,  "%s findfont\n", EPfont );
fprintf( Epf,  "%d scalefont setfont\n", (int) EPcurpointsz );

/* set up standard line width */
fprintf( Epf,  "1 setlinewidth\n" );

fprintf( Epf,  "%%%%EndProlog\n" ); 
}

/* ============================= */
EPSclose()
{
if( EPstdout ) return( 0 ); /* we don't want to close stdout */
if( Epf != NULL )fclose( Epf );
}


/* ============================= */
EPSmoveto( x, y )
double x, y;
{

/* convert to p.s. units (1/72 inch) */
x = ( x * 72.0 ) +MARG_X; y = ( y * 72.0 ) + MARG_Y; 
fprintf( Epf,  "np\n%-5.2f %-5.2f mv\n", x, y ); 
}


/* ============================= */
EPSlineto( x, y )
double x, y;
{
/* convert to p.s. units */
x = ( x * 72 ) +MARG_X; 
y = ( y * 72 ) +MARG_Y; 
fprintf( Epf,  "%-5.2f %-5.2f ln\n", x, y );
}

/* ============================== */
EPSstroke( )
{
fprintf( Epf, "st\n" );
}


/* ============================= */
EPSpath( x, y )
double x, y;
{
/* convert to p.s. units */
x = ( x * 72 ) +MARG_X; y = ( y * 72 ) + MARG_Y; 
fprintf( Epf,  "%-5.2f %-5.2f ln\n",  x, y );
}


/* ============================= */
EPSshade( s )
double s;
{
fprintf( Epf,  "closepath\n%3.2f setgray\nfill\n0 setgray\n", s );
}

/* ============================== */
EPSpaper( i )
int i;
{
if( EPorient != -1 ) return( 1 );		/* paper orientation - can only be done once per page */
if( i == 1 ) { /* handle landscape mode-- it's put into portrait mode before beginning each page */
	EPorgx = PAGWIDTH; 
	EPorgy = 0; 
	EPtheta = 90; 
	fprintf( Epf,  "%d %d %d sset\n", EPtheta, EPorgx, EPorgy );
	} 
EPorient = (int) i;
}


/* ================================= */
EPStext( com, x, y, s, w )
char com;
double x, y;
char s[];
double w;
{
char str[400];
int i, j, k;

x = (x*72)+MARG_X;  y = (y*72)+MARG_Y; w *= 72;

/* if text direction is not normal do a rotate then move.. */
if( EPchdir != 0 ) fprintf( Epf,  "%d %-5.2f %-5.2f sset 0 0 mv\n", EPchdir, x, y ); 
/* normal direction-- do a move.. */
else fprintf( Epf,  "%-5.2f %-5.2f mv ", x, y );

if( Emember( com, "CJ" )) Estrip_ws( s );

/* escape out parens */
for( i = 0, j = 0; i < strlen( s ); i++ ) {
	if( s[i] == '(' || s[i] == ')' ) { str[j++] = '\\'; str[j++] = s[i]; }
	else str[j++] = s[i];
	}
str[j] = '\0';

/* centered text */
if( com == 'C' ) fprintf( Epf,  "%-5.2f (%s) cent ", w, str ); 
else if( com == 'J' ) fprintf( Epf,  "%-5.2f (%s) rjust ", w, str );

/* do the string */
fprintf( Epf,  "(%s) sh\n", str );

if( EPchdir != 0 ) fprintf( Epf,  "%-5.2f %-5.2f %d sclr\n", -x, -y, -EPchdir ); /* restore */
}


/* ================================= */
EPSpointsize( p )
int p;
{
if( p != EPcurpointsz ) { 	/* char size (specified in points) */
	EPcurpointsz = p;
	fprintf( Epf,  "%s findfont\n", EPfont );
	fprintf( Epf,  "%d scalefont\nsetfont\n", p );
	}
}


/* ================================== */
EPSfont( f )
char f[];
{
if( strcmp( f, EPfont ) != 0 ) {
	strcpy( EPfont, f );
	fprintf( Epf,  "%s findfont\n", EPfont );
	fprintf( Epf,  "%d scalefont setfont\n", EPcurpointsz );
	}
}

/* ================================== */
EPSchardir( t )
int t;
{
EPchdir = t;
}


/* ================================== */
EPSlinetype( s, x, y )
char s[];
double x, y;
{
/* X = line width;  Y = dash pattern magnification (0.1 to 10)
 *  S indicates dash pattern.  If S is "0", an unbroken (normal) line is produced.
 *  If S is "1" through "8", a preset dash pattern is used.  Otherwise, S is
 *  assumed to hold the dash pattern string "[ n1 n2 n3.. ]".	
 */
static int dash[10][6]= { {0,0,0,0,0,0}, {1,1}, {3,1}, {5,1}, {2,1,1,1}, {4,1,1,1}, {6,1,1,1}, 
			  {2,1,1,1,1,1}, {4,1,1,1,1,1}, {6,1,1,1,1,1} };
int ltype, i;

if( x != EPlinewidth ) fprintf( Epf,  "%3.1f setlinewidth\n", x );
if( strcmp( s, EPlinetype )!= 0 ) {
	if( strlen( s ) < 1 || strcmp( s, "0" )==0 ) fprintf( Epf,  "[] 0 setdash\n" );
	else 	{
		if( strlen( s ) > 1 ) { 
			ltype = 0; 
			sscanf( s, "%d %d %d %d %d %d", &dash[0][0], &dash[0][1], &dash[0][2], 
				&dash[0][3], &dash[0][4], &dash[0][5] );
			}
		else ltype = atoi( s );
		fprintf( Epf,  "[" );
		for( i = 0; i < 6; i++ ) 
			if( dash[ ltype ][ i ] > 0 ) fprintf( Epf,  "%3.1f ", dash[ ltype ][ i ] * y );
		fprintf( Epf,  "] 0 setdash\n" );
		}
	}
EPlinewidth = x;
strcpy( EPlinetype, s );
}
	

/* =================================== */

EPSshow()
{
if( EPorient == 1 )fprintf( Epf,  "%d %d %d sclr\n", -EPorgx, -EPorgy, -EPtheta ); /* restore rotation */
EPorient = -1; 
fprintf( Epf, "showpage\n" );
}

/* =================================== */

EPSnewpage( p )
int p;
{
fprintf( Epf, "\n\n\n%%%%Page: %d %d\n", p, p );
}

/* =================================== */

/* EPStrailer( int pp, double x1, double y1, double x2, double y2 ) */
EPStrailer( pp, x1, y1, x2, y2 )
int pp; 
double x1, y1, x2, y2;
{
fprintf( Epf, "end\n" );
fprintf( Epf, "\n\n\n%%%%Trailer\n" );
fprintf( Epf, "%%%%Pages: %d\n", pp );
fprintf( Epf, "%%%%BoundingBox: %5.2f %5.2f %5.2f %5.2f\n",
  ( x1 * 72 ) + MARG_X, ( y1 * 72 ) + MARG_Y, ( x2 * 72 ) + MARG_X, ( y2 * 72 ) + MARG_Y );

fprintf( Epf, "%%%%EOF\n" );
}

SHAR_EOF
############################


