Newsgroups: comp.sources.unix
From: stevegru@welchlink.welch.jhu.edu (STEPHEN C GRUBB)
Subject: v29i095: copa - gui control panel kit for shell, C, perl - V1.0, Part08/08
References: <1.823324036.2981@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: stevegru@welchlink.welch.jhu.edu (STEPHEN C GRUBB)
Posting-Number: Volume 29, Issue 95
Archive-Name: copa/part08

#	This is a shell archive.
#	Remove everything above and including the cut line.
#	Then run the rest of the file through sh.
# - - - - - - C U T   H E R E - - - - - - - - - - - - - - -
#
# Part 8
#
#!/bin/sh
# shar:	Shell Archiver
#	Run the following text with /bin/sh to create:
#		src/sleep.c
#		src/stub.c
#		src/version.c
#		src/wild.c
#		src/winscale.c
#		src/x11.c
#		src/x11shades.h
#		src/zood.c
echo src/sleep.c
cat << \SHAR_EOF > src/sleep.c
#include <time.h>

/* Suspend process for an interval in microseconds (us) */
/* Copa actually doesn't need resolution any finer than 1/100th of a second. */
/* Returns 0 if ok; otherwise an error code.. */

Eusleep( us )
long us;
{
int stat;

#ifdef SOLARIS2
struct timespec sleeptime;

if( us < 0 ) us = 0;
if( us > 999999 ) us = 999999;
sleeptime.tv_sec = 0;
sleeptime.tv_nsec = us * 1000; /* nanoseconds */
stat = nanosleep( &sleeptime, NULL );
return( stat );
#endif

#ifdef SUNOS4
usleep( us );
return( 0 );
#endif

}

SHAR_EOF
############################

echo src/stub.c
cat << \SHAR_EOF > src/stub.c
#include "elib.x"
/* Low level elib drawing stubs.. */
/* These calls always issue pcode calls */
/* They really should only issue pcode calls if necessary.. */

/* ======================================== */
Efont( s )      
char s[];
{ 
if( strlen( s ) < 1 ) {
        Epcode( 'F', 0.0, 0.0, Estandardfont ); 
	strcpy( Ecurfont, Estandardfont ); 
	}
else    { 
	Epcode( 'F', 0.0, 0.0, s ); strcpy( Ecurfont, s ); 
	} 
}
/* ======================================== */
Etextsize( x )          
int x;
{ 
Epcode( 'I', (double)x , 0.0, "" );
Ecurtextsize = (int)x; 
Ecurtextheight = (x+2)/72.0; 
}
/* ======================================== */
Etextdir( x )
int x;
{ 
Epcode( 'D', (double)x , 0.0, "" ); 
Ecurtextdirection = x ; 
}
/* ======================================== */
Epaper( x )
int x;
{
Epcode( 'O', (double)x , 0.0, "" ); 
Ecurpaper = x; 
}
/* ======================================== */
Elinetype( pattern, linewidth, pat_dens )    
int pattern;
double linewidth, pat_dens;
{ 
char buf[12];
sprintf( buf, "%d", pattern );
Epcode( 'Y', linewidth, pat_dens, buf );
Ecurlinewidth = linewidth; 
Ecurlinetype = pattern; 
Ecurpatternfactor = pat_dens;
}

/* ======================================== */
Enormline()             
{ 
Epcode( 'Y', Estandardlinewidth, 1.0, "0" ); 
Ecurlinewidth = Estandardlinewidth;
Ecurlinetype = 0; 
Ecurpatternfactor = 1; 
}

/* ======================================== */
Esetdrawcolor(c)                
int c;
{ 
Ecurcolor = c; 
/*
 * if( c == 1 ) { Eerasecolor = 0; Eeraseshade = 0.0; }
 * else { Eerasecolor = 1; Eeraseshade = 1.0; }
*/
Ependraw();
}
/* ======================================== */
Eseteraseshade(s)
double s;
{
Eeraseshade = s;
if( s > 0.5 ) Eerasecolor = 1;  /* scg */
/* if( s > 0.8 ) Eerasecolor = 1; */ /* scg */
else Eerasecolor = 0;
}


/* ======================================== */
/* set 'pen' to draw */
Ependraw()              
{
if( Ecurpen != Ecurcolor ) {
	Epcode( 'R', (double)Ecurcolor, (double)Ecurcolor, "" );
	Ecurpen = Ecurcolor;
	}
}

/* ======================================== */
/* set 'pen' to erase */
Epenerase()
{
if( Ecurpen != Eerasecolor ) {
	Epcode( 'R', (double)Eerasecolor, (double)Eerasecolor, "" );
	Ecurpen = Eerasecolor;
	}
}

/* ======================================== */
Eaddpick( label, typ, p, q, r, s )  
char label[], typ[];
double p, q, r, s;
{ 
Epcode( 'a', (double)p, (double)q, label );
Epcode( 'A', (double)r, (double)s, typ );
}
 
SHAR_EOF
############################

echo src/version.c
cat << \SHAR_EOF > src/version.c
#include <stdio.h>
/* ================================================ */
/* Please add to this file appropriately if you are */
/* redistributing source code which you modified.   */
/* See also the file: Copyright			    */
/* ================================================ */
copa_version()
{
fprintf( stderr, "COPA version 1.0" );
#ifdef SOLARIS2
fprintf( stderr, " (Solaris 2.x)" );
#endif
#ifdef SUNOS4
fprintf( stderr, " (SunOS 4.x)" );
#endif
#ifdef PLOT
fprintf( stderr, "(with plotting)" );
#endif
fprintf( stderr, "\nCopyright 1991-96 by Stephen C. Grubb (stevegru@welchlink.welch.jhu.edu)\n" );
return(0);
}
SHAR_EOF
############################

echo src/wild.c
cat << \SHAR_EOF > src/wild.c
/* WILDCMP - compare two strings s1 and s2.  S2 may contain 
   wildcards (* and ?).

   Function returns 0 on a match;  < 0 if s1 < s2;   > 0 if s1 > s2
   Prints an error message and returns -999 on error.

   * wildcard limited to the following uses: *ppp; ppp*; pp*pp; *ppp*
   ? can be used anywhere.

   Double asterisks at beginning and end are also handled (means the
   same as single asterisk).

 */

#include <stdio.h>
#include <ctype.h>

Ewildcmp( s1, s2, len, casecare )
char *s1, *s2;
int len;
int casecare;
/* s1  = data value
   s2  = query value which can contain wildcards - not null terminated.
   len = length of s2
   casecare = 0 for case-insensitive, 1 for case-sensitive
 */
{
int i, nwc, wcp, stat;


if( len == 0 ) return( strlen( s1 ) );
else if( s2[0] == '*' ) {
	if( len == 1 ) return( 0 ); /* everything matches */
	}
else if( s2[0] == '?' ) ; /* can't tell yet */
else if( tolower( s1[0] ) < tolower( s2[0] ) ) return( -1 ); /* way off */
else if( tolower( s1[0] ) > tolower( s2[0] ) ) return( 1 );  /* way off */

/* strip off extraneous * at beginning and end.. */
if( s2[0] == '*' && s2[1] == '*' ) { s2 = &s2[1]; len--; }
if( s2[len-1] == '*' && s2[len-2] == '*' ) len--;

/* see if any wild cards were used.. */
nwc = 0;
for( i = 0; i < len; i++ ) if( s2[i] == '*' ) { nwc++; wcp = i; }

if( nwc < 1 ) {  /* straight match */
	if( strlen( s1 ) > len ) return( wcmp( s1, s2, strlen( s1 ), casecare));
	else return( wcmp( s1, s2, len, casecare ) ); 
	}

else if( nwc == 1 ) {                /* wildcard match */
	/* find beginning of what we need to compare */
	i = strlen( s1 ) - (len - (wcp+1) );

	/* case 1: wc at end.. */
	if( wcp == len-1 ) return( wcmp( s1, s2, len-1, casecare ) );

	/* case 2: wc at beginning.. */
	if( wcp == 0 ) return( wcmp( &s1[i], &s2[ 1 ], len-1, casecare ) );

	/* case 3: wc in middle.. */
	else	{
		stat = wcmp( s1, s2, wcp, casecare );
		stat += wcmp( &s1[i], &s2[ (wcp+1) ], strlen( &s1[i] ), casecare );
		return( stat );
		}
	}

else if( nwc == 2 ) {
	/* case 4: wc at beginning and end.. */
	if( wcp != (len-1) ) goto ERR;
	else if( s2[0] != '*' ) goto ERR;
	for( i = 0; i <= (strlen( s1 ) - len) + 2; i++ ) 
		if( wcmp( &s1[i], &s2[1], len-2, casecare ) == 0 ) return( 0 );

	return( -1 );
	}
else 	{
	ERR:
	fprintf( stderr, "Wild card match error.\n" );
	return( -999 );
	}
}

/* ============================= */
/* WCMP - compare two strings.  S2 may contain ? wildcards which matches any
       single character.  Len is the # of characters to check.
 */

wcmp( s1, s2, len, casecare )
char *s1, *s2;
int len;
int casecare;
{
int i;
for( i = 0; i < len; i++ ) {
	if( ! casecare ) {
		if( tolower(s1[i]) < tolower(s2[i]) && s2[i] != '?' ) 
			return( -1 );
		else if( tolower(s1[i]) > tolower(s2[i]) && s2[i] != '?' ) 
			return( 1 );
		}
	else	{
		if( s1[i] < s2[i] && s2[i] != '?' ) return( -1 );
		else if( s1[i] > s2[i] && s2[i] != '?' ) return( 1 );
		}
	}
return( 0 );
}
/* ============================= */
/* TEST MODULE
 * #include <stdio.h>
 * main()
 * {
 * char s1[100], s2[100];
 * int stat;
 * 
 * printf( "s1> " );
 * fgets( s1, 100, stdin );
 * 
 * printf( "s2> " );
 * fgets( s2, 100, stdin );
 * 
 * stat = Ewildcmp( s1, s2, strlen( s2 ), 0 );
 * printf( "\nstat=%d\n\n", stat );
 * }
 */ 
SHAR_EOF
############################

echo src/winscale.c
cat << \SHAR_EOF > src/winscale.c
double xscale, yscale;
int window_height, window_width;

/* ====================== set up user coords */
Esetwinscale( width, height, x_max, y_max )
int width, height;
double x_max, y_max;
{
xscale = (double)(width) / (x_max);
yscale = (double)(height) / (y_max);
window_height = height;
window_width = width;
}
/* ==================== scale in x to window size */
Exsca( f )
double f;
{
int iout;
iout = (int) (f * xscale);
return( iout );
}

/* ==================== inverse of xsca */
double Exsca_inv( i )
int i;
{
double out;
out = (double) i / xscale;
return( out );
}

/* ==================== scale in y to window size */
Eysca( f )
double f;
{
int iout;
iout = window_height - (int) (f * yscale);
return( iout );
}

/* ===================== inverse of ysca */
double Eysca_inv( i )
int i;
{
double out;
out = (double)(window_height-i) / yscale;
return( out );
}

SHAR_EOF
############################

echo src/x11.c
cat << \SHAR_EOF > src/x11.c
/*
COPA 1.0 - gui control panel kit for shell, C, perl etc.  
*              **      **                              *
Copyright 1991-1996 by Stephen C. Grubb.

Permission is hereby granted to USE this software for free.
Permission is hereby granted to MODIFY and/or REDISTRIBUTE 
this software for free, provided that no monetary gain is 
realized, and all attached authorship and copyright notices 
are preserved.

Inclusion of any portion (or derivation) of this software, 
including ancillary files, in any commercial product is not 
allowed without prior written permission of the author.  

See also the file 'Copyright'. 
*/


/* ===========================
   X11 xlib interface for copa

   Revisions:
	950906 - fixed to work on color displays. scg
	950906 - now consults DISPLAY env variable to learn display host
	950907 - fixed problem with white text (change gc fillstyle temporarily)
	951109 - made font selection more robust and accessable via COPA_XFONT env var.
	951109 - reduced # of redraws when window is moved

   ===========================
*/
	

#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xos.h>
#include <stdio.h>
#include "x11shades.h"

#define MAX_D_ROWS 1000		/* LIMIT */
#define DEFAULT_FONT "-adobe-courier-bold-r-normal"
#define MISC_FONT "-misc-fixed-medium-r-normal"    /* available on NDG xterminals */
#define LAST_RESORT_FONT "9x15"


#define E_EXPOSE 1010  /* window has been exposed and needs to be redrawn */
#define E_RESIZE 1011  /* window has been resized */

double Exsca_inv(), Eysca_inv();

static double EXWoldx = 0, EXWoldy = 0;
static int EXWwaitflag;
static Display	*EXWdisp;
static Window	EXWwin;
static int EXWscreen;
static GC EXWgc;
static int EXWlinewidth;
static int EXWcharsize;
static double EXWcurshade;
static char EXWdash[4][10][6]= {
		{ {1}, {1,1}, {3,1}, {5,1}, {2,1,1,1}, {4,1,1,1}, {6,1,1,1}, 
		  {2,1,1,1,1,1}, {4,1,1,1,1,1}, {6,1,1,1,1,1} },
		{ {2}, {2,2}, {6,2}, {10,2}, {4,2,2,2}, {8,2,2,2}, {12,2,2,2}, 
		  {4,2,2,2,2,2}, {8,2,2,2,2,2}, {12,2,2,2,2,2} },
		{ {3}, {3,3}, {9,3}, {15,3}, {6,3,3,3}, {12,3,3,3}, {18,3,3,3}, 
		  {6,3,3,3,3,3}, {12,3,3,3,3,3}, {18,3,3,3,3,3} },
		{ {4}, {4,4}, {12,4}, {20,4}, {8,4,4,4}, {16,4,4,4}, {24,4,4,4}, 
		  {8,4,4,4,4,4}, {16,4,4,4,4,4}, {24,4,4,4,4,4} }
			};
static int EXWndash[10] = { 1, 2, 2, 2, 4, 4, 4, 6, 6, 6 };

/* create pixmap tiles for shading.. */
static Pixmap EXW_s_00, EXW_s_10, EXW_s_20, EXW_s_30, EXW_s_40, EXW_s_50, EXW_s_60, 
	EXW_s_70, EXW_s_80, EXW_s_90, EXW_s1_0;

/* polygon vertexes */
static XPoint EXWvlist[MAX_D_ROWS];
static int EXWnvtx = 0;

static int EXWwinheight, EXWwinwidth;   /* current size of window */
static int EXWwinheight0, EXWwinwidth0; /* original size of window */
static int EXWupperleftx, EXWupperlefty; /* screen pixel position of upper left of window */
static int EXWclr = 0;
static double EXWtextscale = 1.0;

static XFontStruct *EXWfont; /* the full name of the current font */
static char EXWfontset[120]; /* the font short name - known to be available */
static int EXWmapped;



/* =========================== */
/* get the elib x environment handles.. */
EXWgethandle( display, window, gc )
Display *display;
Window *window;
GC *gc;
{
display = EXWdisp;
window = &EXWwin;
gc = &EXWgc;
}

/* ========================== */
EXWsetup( name, pixels_inch, x_max, y_max, upperleftx, upperlefty )
char name[];
int pixels_inch;
double x_max, y_max;
int upperleftx, upperlefty;
{
char inbuf[20];

XSizeHints win_size;
XEvent event;
int n = 1;
int nplanes; /* # of planes of display */
unsigned long fg, bg; /* forground and background for setting pixmaps */
char *userfont;
char *getenv();
int stat;

/* get window size in pixels */
EXWwinwidth =  (int)(x_max * pixels_inch ); 
EXWwinheight = (int)(y_max * pixels_inch );

/* remember original size.. */
EXWwinwidth0 = EXWwinwidth; 
EXWwinheight0 = EXWwinheight;

/* remember position */
EXWupperleftx = upperleftx;
EXWupperlefty = upperlefty;

/* initialize parameters */
EXWfont = NULL;
EXWlinewidth = 1;
EXWcharsize = 0;
EXWtextscale = 1.0;

/* open the display indicated in DISPLAY env var.. */
if(( EXWdisp = XOpenDisplay( NULL )) == NULL ){
	fprintf( stderr, "Display open failed\n" );
	exit( 1 );
	}

/* see if user font env variable is defined.. */
userfont = getenv( "COPA_XFONT" );

/* window size */
EXWscreen = DefaultScreen( EXWdisp );
win_size.flags = PPosition | PSize;
win_size.x = EXWupperleftx;
win_size.y = EXWupperlefty;
win_size.width = EXWwinwidth;
win_size.height = EXWwinheight;

/* create the window */
EXWwin = XCreateSimpleWindow (
	EXWdisp,
	RootWindow(EXWdisp, EXWscreen),	/*  parent window */
	win_size.x,
	win_size.y,		/*  location	  */
	win_size.width,
	win_size.height,	/*  size          */
	5,			/*  border	  */
	BlackPixel(EXWdisp,EXWscreen),	/*  forground	  */
	WhitePixel(EXWdisp,EXWscreen)	/*  background	  */
	);

XSetWMNormalHints( EXWdisp, EXWwin, &win_size );

XStoreName( EXWdisp, EXWwin, name );



/* set grays */
fg = BlackPixel(EXWdisp, EXWscreen);
bg = WhitePixel(EXWdisp, EXWscreen);
nplanes = XDisplayPlanes( EXWdisp, EXWscreen );
EXW_s_00 = XCreatePixmapFromBitmapData( EXWdisp, EXWwin, EXW_im_00, 16, 16, fg, bg, nplanes);
EXW_s_10 = XCreatePixmapFromBitmapData( EXWdisp, EXWwin, EXW_im_10, 16, 16, fg, bg, nplanes);
EXW_s_20 = XCreatePixmapFromBitmapData( EXWdisp, EXWwin, EXW_im_20, 16, 16, fg, bg, nplanes);
EXW_s_30 = XCreatePixmapFromBitmapData( EXWdisp, EXWwin, EXW_im_30, 16, 16, fg, bg, nplanes);
EXW_s_40 = XCreatePixmapFromBitmapData( EXWdisp, EXWwin, EXW_im_40, 16, 16, fg, bg, nplanes);
EXW_s_50 = XCreatePixmapFromBitmapData( EXWdisp, EXWwin, EXW_im_50, 16, 16, fg, bg, nplanes);
EXW_s_60 = XCreatePixmapFromBitmapData( EXWdisp, EXWwin, EXW_im_60, 16, 16, fg, bg, nplanes);
EXW_s_70 = XCreatePixmapFromBitmapData( EXWdisp, EXWwin, EXW_im_70, 16, 16, fg, bg, nplanes);
EXW_s_80 = XCreatePixmapFromBitmapData( EXWdisp, EXWwin, EXW_im_80, 16, 16, fg, bg, nplanes);
EXW_s_90 = XCreatePixmapFromBitmapData( EXWdisp, EXWwin, EXW_im_90, 16, 16, fg, bg, nplanes);
EXW_s1_0 = XCreatePixmapFromBitmapData( EXWdisp, EXWwin, EXW_im1_0, 16, 16, fg, bg, nplanes);


/*  create graphics context */
EXWgc = XCreateGC( EXWdisp, EXWwin, 0, NULL );

XSetForeground( EXWdisp, EXWgc, BlackPixel( EXWdisp, EXWscreen ));
XSetBackground( EXWdisp, EXWgc, WhitePixel( EXWdisp, EXWscreen )); /* added SCG 950907 */

XSetLineAttributes( EXWdisp, EXWgc, EXWlinewidth, LineSolid, CapButt, JoinMiter );

/* XSetFillStyle( EXWdisp, EXWgc, FillTiled ); */
XSetFillStyle( EXWdisp, EXWgc, FillSolid ); /* FillSolid is used for lines & text;
						we switch over to FillTiled for
						polygons below.. */

XSetTile( EXWdisp, EXWgc, EXW_s_00 );

/* find a font set to use.. */
stat = EXWloadfont( userfont, 10 ); 		/* user's choice font */
if( stat == 0 ) strcpy( EXWfontset, userfont );
else	{
	stat = EXWloadfont( DEFAULT_FONT, 10 ); /* default font */
	if( stat == 0 ) strcpy( EXWfontset, DEFAULT_FONT );
	else	{
		stat = EXWloadfont( MISC_FONT, 10 );    /* available on ndg xterms */
		if( stat == 0 ) strcpy( EXWfontset, MISC_FONT );
		else	{
			stat = EXWloadfont( "9x15", 0 );		/* last resort.. */
			if( stat == 0 ) strcpy( EXWfontset, LAST_RESORT_FONT );
			else {
				fprintf(stderr, "Error: cannot find a font.  Set the env var\n" ); 
				fprintf(stderr, "COPA_XFONT to hold the base name of an available\n");
				fprintf(stderr, "Xwindow font, e.g. -adobe-courier-bold-r-normal\n");
				exit();
				}
			}
		}
	}


/* Set up for events  */
/*  we want: (1) mouse clicks (2) Key presses (3) expose events (4) resize events */
XSelectInput (
	EXWdisp,
	EXWwin,
	ButtonPressMask | ExposureMask | KeyPressMask | StructureNotifyMask
	);


/* map the window */
XMapWindow( EXWdisp, EXWwin );
EXWmapped = 1;

/* wait for initial expose event to draw.. */
while( 1 ) {
	XNextEvent( EXWdisp, &event );
	if( event.type == Expose ) break;
	}
}

/* =============================== */
EXWevent( event )
XEvent event;
{
int x, y;
unsigned eid;
char s[10];
XEvent fooevent;
int index, status;
FILE *fp;

if( event.type == KeyPress ) {
	x = event.xkey.x;
	y = event.xkey.y;

	if( event.xkey.state == ShiftMask ) index = 1;
	else index = 0;
	eid = (unsigned) XLookupKeysym( &(event.xkey), index );
	if( eid >= 0xFFE1 && eid <= 0xFFEE ) EXWwaitflag = 0; /* screen out shift, control, alt, etc. */
	else	{
		eid &= 0x007F;
		EXWwaitflag = Ehandle_event( Exsca_inv( x ), Eysca_inv( y ), eid );
		}
	}
else if( event.type == ButtonPress ) {
	x = event.xbutton.x;
	y = event.xbutton.y;
	if( event.xbutton.button == Button1 ) eid = 1001;
	else if( event.xbutton.button == Button2 ) eid = 1002;
	else if( event.xbutton.button == Button3 ) eid = 1003;
	EXWwaitflag = Ehandle_event( Exsca_inv( x ), Eysca_inv( y ), eid );
	}
else if( event.type == Expose ) {
	if( event.xexpose.count == 0 ) {
		Ehandle_event( 0.0, 0.0, E_EXPOSE );
		}
	}

else if( event.type == ConfigureNotify ) { 

	/* on openwin, this event is generated when window is move, and when it is
	 * resized.  We need do nothing when it is simply moved; when it is resized
	 * we need to recalculate and redisplay everything.. */

	if( (double)event.xconfigure.width != EXWwinwidth ||
	   (double)(event.xconfigure.height) != EXWwinheight ) { /* if size changed.. */

		Ehandle_event( (double)(event.xconfigure.width), 
			(double)(event.xconfigure.height), E_RESIZE );
		Ehandle_event( 0.0, 0.0, E_EXPOSE );
		EXWwinwidth = event.xconfigure.width; 
		EXWwinheight = event.xconfigure.height;
		}
	}
}
/* ============================== */
/* Code driven resize of window.
   All parameters (except pixels_inch) may be sent as -1 = don't change */
   
/* EXWresizewin( int pixels_inch, int x, int y, double x_max, double y_max ) */
EXWresizewin( pixels_inch, x, y, x_max, y_max )
int pixels_inch, x, y;
double x_max, y_max;
{
XSizeHints win_size;

/* get window size in pixels, and consider it 'original' */
if( x_max > 0 ) { EXWwinwidth =  (int)(x_max * pixels_inch ); EXWwinwidth0 = EXWwinwidth; }
if( y_max > 0 ) {EXWwinheight = (int)(y_max * pixels_inch ); EXWwinheight0 = EXWwinheight; }

if( x > 0 ) EXWupperleftx = x;
if( y > 0 ) EXWupperlefty = y;

win_size.x = EXWupperleftx;
win_size.y = EXWupperlefty;
win_size.width = EXWwinwidth;
win_size.height = EXWwinheight;

/* create the window */
XMoveResizeWindow ( EXWdisp,
	EXWwin,
	win_size.x,
	win_size.y,	
	win_size.width,	
	win_size.height	);

/* XSetWMNormalHints( EXWdisp, EXWwin, &win_size ); */
XFlush();
return( 0 );
}

/* =============================== */
EXWwait()
{
XEvent event;
EXWwaitflag = 0;
while( ! EXWwaitflag ) {
	XNextEvent( EXWdisp, &event );
	EXWevent( event );
        }
}

/* ==================== dot */
EXWdot( x, y )
double x, y;
{
XDrawPoint( EXWdisp, EXWwin, EXWgc, Exsca( x ), Eysca( y ) );
}

/* ====================  line to */
EXWlineto(x,y)
double x, y;
{
int a, b, c, d;


a = Exsca( EXWoldx ); b = Eysca( EXWoldy ); c = Exsca( x ); d = Eysca( y );
XDrawLine( EXWdisp, EXWwin, EXWgc, a, b, c, d );
EXWoldx=x;
EXWoldy=y;
}

/* =====================  moveto */
EXWmoveto(x,y)
double x, y;
{
EXWoldx = x;
EXWoldy = y;
}

/* ===================== set point size of type */
/* XWpointsize */
EXWpointsize( p, aw )
int p;
double *aw; /* width of one character -- returned */
{
int newp;
int stat;

if( p == EXWcharsize ) return( 1 );
EXWcharsize = p;

/* use p to find equivalent size parameter for x font */
if( p <= 6 ) newp = 8; 
else if( p == 7 || p == 8 ) newp = 10; 
else if( p == 9 || p == 10 ) newp = 12; 
else if( p >= 11 && p <= 14 ) newp = 14;
else if( p >= 15 && p <= 18 ) newp = 18;
else newp = 24;

/* scale based upon pixels/inch */
newp = (int)(newp * EXWtextscale);

/* try to load a font.. */
stat = EXWloadfont( EXWfontset, newp ); 		/* load our font in the requested size.. */
if( stat != 0 ) {
	fprintf( stderr, "Error: Cannot load %s in the requested size (%d).\n", EXWfontset, p );
	exit(1);
	}

/* get the char size for our new font */
*aw = Exsca_inv( XTextWidth( EXWfont, "A", 1 ) );
return( 0 );
}

/* ======================== */
/* EXW LOADFONT - given short font name f, see if an X font is available for
   the requested size, or something close.. */
/* EXWloadfont( char *f, int size ) */
EXWloadfont( f, size )
char *f;
int size;
{
char fontname[100];
char ofslist[12];
int i, p;
Font fnt;

strcpy( ofslist, "EFDGCHBIAJ" ); /* used to vary the size.. */

if( f == NULL ) return( 1 );
if( (int) strlen( f ) < 1 ) return( 1 );
if( strcmp( f, LAST_RESORT_FONT ) == 0 ) {
	strcpy( fontname, f );
	EXWfont = XLoadQueryFont( EXWdisp, fontname );
	if( EXWfont == NULL ) return( 1 );
	goto LOAD_IT;
	}

for( i = 0; i < 10; i++ ) { /* try 10 times with varying sizes until we get a hit.. */
	p = size + ( ofslist[i] - 'E' );
	sprintf( fontname, "%s--%d-*-*-*-*-*-*-*", f, p );
	EXWfont = XLoadQueryFont( EXWdisp, fontname );
	if( EXWfont != NULL ) break;
	}
if( i == 10 ) return( 1 ); /* not found */

LOAD_IT:
fnt = XLoadFont( EXWdisp, fontname );
XSetFont( EXWdisp, EXWgc, fnt );
return( 0 );
}

/* ==================== EXWscaletext - when window is resized, to adjust text size */
EXWscaletext( f )
double f;
{
EXWtextscale = f;
}

/* ==================== EXWdisplay left adjusted text starting at current position */
EXWtext( s, aw )
char s[];
double *aw; /* actual string width in inches (sent back) */
{
/* XSetFillStyle( EXWdisp, EXWgc, FillSolid ); */  /* added SCG 950907 */
XDrawString( EXWdisp, EXWwin, EXWgc, Exsca( EXWoldx ), Eysca( EXWoldy ), s, strlen( s ) );
/* XSetFillStyle( EXWdisp, EXWgc, FillTiled ); */  /* added SCG 950907 */
*aw = Exsca_inv( XTextWidth( EXWfont, s, strlen( s ) ) );
EXWoldx += ( *aw );
}

/* ==================== EXWdisplay centered text */
EXWcentext( s, w, x, aw )
char s[];
double w;
double *x; /* actual X starting point in inches (sent back) */
double *aw; /* actual string width in inches (sent back) */
{
double width;

Estrip_ws( s );
width = Exsca_inv( XTextWidth( EXWfont, s, strlen( s ) ) );
EXWmoveto( EXWoldx+((w-width)/2.0), EXWoldy );
EXWtext( s, aw );
*x = Exsca_inv((int)( EXWoldx+((w-width)/2.0) ) );
}

/* ==================== EXWdisplay right-justified text */
EXWrightjust( s, w, x, aw )
char s[];
double w;
double *x; /* actual X starting point in inches (sent back) */
double *aw; /* actual string width in inches (sent back) */
{
double width;

Estrip_ws( s );
width = Exsca_inv( XTextWidth( EXWfont, s, strlen( s ) ) );
EXWmoveto( EXWoldx+(w-width), EXWoldy );
EXWtext( s, aw );
*x = Exsca_inv((int)(EXWoldx+(w-width) ));
}

/* ========= set line dotting attribs ============= */

EXWlinetype( t, w, mag )
char t[];
double w, mag;
{
int i, j, k;

if( (int) strlen( t ) < 1 ) return( 0 );
if( mag < 1 ) mag = 1;
if( mag > 4 ) mag = 4;
/* 
w_brush->width = (int)((w*1.6)+0.5);
w_texture->pattern = w_dash[ (int)mag-1 ][ atoi( t ) % 10 ];
*/
EXWlinewidth = (w*1.6) + 0.5;
if( t[0] == '0' ) {
	XSetLineAttributes( EXWdisp, EXWgc, EXWlinewidth, LineSolid, CapButt, JoinMiter );
	}
else	{
	XSetDashes( EXWdisp, EXWgc, 0, EXWdash[ (int)mag-1 ][ atoi(t)%10 ], EXWndash[ atoi(t)%10 ] );
	XSetLineAttributes( EXWdisp, EXWgc, EXWlinewidth, LineOnOffDash, CapButt, JoinMiter );
	}
}

/* ==================== add to "fill path" */
EXWpath( x, y )
double x, y;
{
if( EXWnvtx == 0 ) { EXWvlist[0].x = Exsca( EXWoldx ); EXWvlist[0].y = Eysca( EXWoldy ); EXWnvtx++; }
EXWvlist[ EXWnvtx ].x = (short) (Exsca(x));
EXWvlist[ EXWnvtx ].y = (short) (Eysca(y));
EXWnvtx++;
}

/* ==================== fill prev. defined polygon path with color c */
EXWshade( c )
double c; 
{
Pixmap pr;
if( c >= 0.0 && c <= 1.0 ) {
	if( c == 1.0 ) pr = EXW_s1_0;
	else if( c > .95 ) pr = EXW_s_90;
	else if( c > .90 ) pr = EXW_s_80;
	else if( c > .85 ) pr = EXW_s_70;
	else if( c > .75 ) pr = EXW_s_60;
	else if( c > .65 ) pr = EXW_s_50;
	else if( c > .55 ) pr = EXW_s_40;
	else if( c > .45 ) pr = EXW_s_30;
	else if( c > .35 ) pr = EXW_s_20;
	else if( c > .15 ) pr = EXW_s_10;
	else if( c >= 0.0 ) pr = EXW_s_00;
	else pr = (Pixmap ) 0;
	}

XSetTile( EXWdisp, EXWgc, pr );

XSetFillStyle( EXWdisp, EXWgc, FillTiled );   /* added SCG 11-10-95 */

XFillPolygon( EXWdisp, EXWwin, EXWgc, EXWvlist, EXWnvtx, Complex, CoordModeOrigin );

/* set fillstyle back to solif and set tile back to black.. */
XSetFillStyle( EXWdisp, EXWgc, FillSolid );   /* added SCG 11-10-95 */
XSetTile( EXWdisp, EXWgc, EXW_s_00 );
/* reset vertex counter */
EXWnvtx = 0;
}

/* ==================== set drawing color */
EXWcolor( c )
int c;
{
if( c == EXWclr ) return(1);
if( c == 0 ) { 
	XSetForeground( EXWdisp, EXWgc, BlackPixel( EXWdisp, EXWscreen ));
	XSetBackground( EXWdisp, EXWgc, WhitePixel( EXWdisp, EXWscreen )); /* added SCG 950907 */
	}
else if( c == 1 ) { 
	XSetForeground( EXWdisp, EXWgc, WhitePixel( EXWdisp, EXWscreen ));
	XSetBackground( EXWdisp, EXWgc, BlackPixel( EXWdisp, EXWscreen )); /* added SCG 950907 */
	}
EXWclr=c;
/* EXWtileflag = -1; */
}

/* ==================== asynchronous */
EXWasync()
{
XEvent event;
while( 1 ) {
	if( XCheckMaskEvent( EXWdisp, ButtonPressMask | ExposureMask | KeyPressMask | StructureNotifyMask , 
		&event ) != True ) return(1);
	EXWevent( event );
        }
}
/* ==================== */

EXWflush()
{
XFlush( EXWdisp );
}

/* ===================== */

EXWappear()
{
XEvent event;

if( EXWmapped ) return( 0 );

/* map the window */
XMapWindow( EXWdisp, EXWwin );
EXWmapped = 1;

/* redraw everything.. */
/* Egenall();   scg Nov 95 */
XFlush( EXWdisp );
}
/* ====================== */

EXWdisappear()
{
if( ! EXWmapped ) return( 0 );

/* unmap the window.. */
XUnmapWindow( EXWdisp, EXWwin );
EXWmapped = 0;
XFlush( EXWdisp );
}


#ifdef NEVER
if( event->count ) return; /* i.e. more expose events */

/* How big is the window? 
XGetGeometry( event->display, event->window, &r, &x, &y, &w, &h, &bw, &d );

/* clear window to make sure that contents of previous window do not cause problems */
XClearArea( event->display, event->window, 0, 0, w, h, 0 );

/* scale normalized picture to the largest square that fits in the window */
scale = w < h ? w:h;
#endif
SHAR_EOF
############################

echo src/x11shades.h
cat << \SHAR_EOF > src/x11shades.h


/* shading .... */

static unsigned char EXW_im_00[] = {
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

static unsigned short EXW_im_10[] = {
/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
 */
	0x7F7F,0xFFFF,0xF7F7,0xFFFF,0x7F7F,0xFFFF,0xF7F7,0xFFFF,
	0x7F7F,0xFFFF,0xF7F7,0xFFFF,0x7F7F,0xFFFF,0xF7F7,0xFFFF
};


static unsigned short EXW_im_20[] = {
/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
 */
	0x7777,0xFFFF,0x7777,0xFFFF,0x7777,0xFFFF,0x7777,0xFFFF,
	0x7777,0xFFFF,0x7777,0xFFFF,0x7777,0xFFFF,0x7777,0xFFFF
};

static unsigned short EXW_im_30[] = {
/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
 */
	0x7DF7,0xDF7D,0xFBEF,0xEFBE,0xBEFB,0xF7DF,0x7DF7,0xDF7D,
	0xFBEF,0xEFBE,0xBEFB,0xF7DF,0x7DF7,0xDF7D,0xFBEF,0xEFBE
} ;

static unsigned short EXW_im_40[] = {
/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
 */
	0x7777,0xDDDD,0x7777,0xDDDD,0x7777,0xDDDD,0x7777,0xDDDD,
	0x7777,0xDDDD,0x7777,0xDDDD,0x7777,0xDDDD,0x7777,0xDDDD
} ;

static unsigned short EXW_im_50[] = {
/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
 */
	0xEEEE,0xAAAA,0xAAAA,0xBBBB,0xEEEE,0xAAAA,0xAAAA,0xBBBB,
	0xEEEE,0xAAAA,0xAAAA,0xBBBB,0xEEEE,0xAAAA,0xAAAA,0xBBBB
};

static unsigned short EXW_im_60[] = {
/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
 */
	0x5555,0x5555,0x5555,0x5555,0x5555,0x5555,0x5555,0x5555,
	0x5555,0x5555,0x5555,0x5555,0x5555,0x5555,0x5555,0x5555
};

static unsigned short EXW_im_70[] = {
/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
 */
	0x8888,0x2222,0x8888,0x2222,0x8888,0x2222,0x8888,0x2222,
	0x8888,0x2222,0x8888,0x2222,0x8888,0x2222,0x8888,0x2222
};

static unsigned short EXW_im_80[] = {
/* #include <images/square_17.pr> */
/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
 */
	0x8208,0x2082,0x0410,0x1041,0x4104,0x0820,0x8208,0x2082,
	0x0410,0x1041,0x4104,0x0820,0x8208,0x2082,0x0410,0x1041
};

static unsigned short EXW_im_90[] = {
/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
 */
	0x8080,0x0000,0x0808,0x0000,0x8080,0x0000,0x0808,0x0000,
	0x8080,0x0000,0x0808,0x0000,0x8080,0x0000,0x0808,0x0000
};

/*
static unsigned short EXW_im1_0[] = {		
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000
};
*/

static unsigned char EXW_im1_0[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

SHAR_EOF
############################

echo src/zood.c
cat << \SHAR_EOF > src/zood.c
/*
COPA 1.0 - gui control panel kit for shell, C, perl etc.  
*              **      **                              *
Copyright 1991-1996 by Stephen C. Grubb.

Permission is hereby granted to USE this software for free.
Permission is hereby granted to MODIFY and/or REDISTRIBUTE 
this software for free, provided that no monetary gain is 
realized, and all attached authorship and copyright notices 
are preserved.

Inclusion of any portion (or derivation) of this software, 
including ancillary files, in any commercial product is not 
allowed without prior written permission of the author.  

See also the file 'Copyright'. 
*/





/* ==================================================================== */
/* ==================================================================== */
/* This is the OO database.						*/
/* ==================================================================== */
/* ==================================================================== */
#include <stdio.h>
#define TMP_DIR "/usr/tmp/"



#define NIL -1			/* nil indicator */

/* Egetnextobj sequences.. */ 
#define E_AT_BEGINNING 0
#define E_AT_END 2
#define E_NEXT 1
#define E_PREVIOUS -1
#define E_DONE 3

#define MAXO 200       		/* max number of user objects */ /* LIMIT */
#define MAXD 200      		/* max number of default objects */ /* LIMIT */
#define MAXA 2500     		/* max number of attributes (both user and default) */ /* LIMIT */
#define MAXNP 3000		/* max size of name parts list */
#define MAXPACK 10		/* max number of object packages */ /* LIMIT */

#define STRINGPOOLLEN 300000  	/* capacity of the string pool */  /* LIMIT */
#define DLISTLEN     10000     	/* capacity of double list */	   /* LIMIT */
#define ILISTLEN     500     	/* capacity of int list */	   /* LIMIT */
#define ANAMELEN     80



/* Packages */
static int EIPname[MAXPACK];          	/* package name (pointer into string pool) */
static int EIPn;			/* number of packages */

/* Display order */
static int  EIorder[MAXO];		/* contains procids, in display order (-1 == skip) */

/* User Objects */
/* cell 0 corresponds to procid 0, 1 to 1, etc. */
static int  EIOname[MAXO]; 		/* proc name (pointer into string pool) */
static int  EIOinheritid[MAXO]; 	/* procid of proc from which inheritance may happen, or NIL */
static int  EIOattrkey[MAXO]; 		/* points to first attribute, or nil */
static int  EIOdefkey[MAXO];  		/* points to entry in default list */
static int  EIOn;    			/* how many */

/* Attributes (both user and default) */
static int  EIAnparts[MAXA];		/* number of parts in name, or NIL for hard default */
static int  EIAnamep[MAXA];		/* points to first entry in namepart pool, or to s.p. for hard def. */
static int  EIAnext[MAXA];            	/* points to next attribute or NIL */
static char EIAtype[MAXA];            	/* I, D, or C */
static int  EIApos[MAXA];             	/* position in storage list */
static int  EIAlen[MAXA];             	/* amount of storage list occupied */
static int  EIAalloc[MAXA];		/* amount of storage list reserved */
static int  EIAconkey[MAXA];            /* (defaults only) points to constraint in the string pool, or NIL */
static int  EIAdeskey[MAXA];		/* (defaults only) points to description in the string pool, or NIL */
static int  EIAxkey[MAXA];		/* for 'X'types this points to called obj. in the EIO list */
static int  EIAdef[MAXA];		/* attributes: points to default entry.  defaults: contains flags */
static int  EIAavail;                 	/* next available slot-- just a counter for now.. */  

/* Name parts */
static char *EINP[MAXNP];		/* point to a name part in the string pool. */
static int  EINPn;			/* how many */

/* Default Object index */
static int  EIDname[MAXD]; 		/* default object name (pointer into string pool) */
static int  EIDattrkey[MAXD];      	/* points to first attribute */
static int  EIDpack[MAXD];		/* index into packages list */
static int  EIDoverrideflag[MAXD];	/* indicates whether any overrides were used */
static int  EIDn;			/* how many */

/* Storage lists */
/* String */
static char  EISs[STRINGPOOLLEN];  	/* string pool */
static int   EISsn;                 	/* next available slot in string pool */

/* Double */
static double EISd[DLISTLEN];	     	/* doubles */
static int  EISdn;

/* Int */
static int EISi[ILISTLEN]; 		/* ints */
static int EISin;


static int EIinitstate[8];		/* State of structure before user stuff.. */	

/* input file line number */
static int EILineno;
static int EIerrorflag = 0;

static int EIcontplace = NIL;		/* placeholder for continuation lines */
static int EIoccur = 1;			/* occurrence selector-- usually the first occurrence */
static int EIaddalways = 0;		/* flag, if 1, EImodattr adds as a new occurrence unconditionally. */
static int EImustalloc = NIL;		/* if non-NIL, indicates amount of storage allocation by EImodattr */
static int EIsilentflag = 0;		/* flag for silencing error messages */
static int EIwhere = NIL;		/* set by EIlocate, 1 = user-specified, 2 = inherited, 3 = default */

static int EIflag = 0; 			/* for debugging */
static int EIulookups, EIinhlookups, EIdeflookups, EIdeflookupfaults;


extern char *EIgetobjname(), *EIgetattrname();

/* ========================================================== */
/* ===== move an object to the beginning of the display list  */
/* ===== so that it is displayed at the bottom of the stacking order. */
/* ========================================================== */
EIlower( p )
int p;
{
int i, riffling;
/* start at end of order list and look for p.  When found, riffle.. */
riffling = 0;
for( i = EIOn-1; i > 0; i-- ) {
	if( EIorder[i] == p ) riffling = 1;
	if( riffling ) EIorder[i] = EIorder[i-1];
	}
EIorder[0] = p;
}

/* ========================================================== */
/* ===== move an object to the end of the display list ====== */
/* ===== so that it is displayed at the top of the stacking order. */
/* ========================================================== */
EIraise( p )
int p;
{
int i, riffling;
/* start at beginning of order list and look for p.  When found, riffle.. */
riffling = 0;
for( i = 0; i < EIOn-1; i++ ) {
	if( EIorder[i] == p ) riffling = 1;
	if( riffling ) EIorder[i] = EIorder[i+1];
	}
EIorder[EIOn-1] = p;
}




/* ========================================================== */
/* ==== initialize structures =============================== */
/* ========================================================== */
EIinit()
{
EIOn = 0;  EIAavail = 0;  EIDn = 0;  

/* put friendly null values in first slot of each type.. */
EISs[0] ='\0'; EISsn = 1; 
EISd[0] = 0.0; EISdn = 1;  
EISi[0] = 0;   EISin = 1; 

EIPn = 0;
EINPn = 0;
EIdeflookups = 0;
EIdeflookupfaults = 0;
EIulookups = 0;
EIinhlookups = 0;
}

/* ========================================================== */
/* ===== save state before any objects are defined.. ============ */
/* ========================================================== */
EIsaveinitstate()
{
EIinitstate[0] = EIAavail; EIinitstate[1] = EISsn; EIinitstate[2] = EISdn; EIinitstate[3] = EISin;
EIinitstate[4] = EIOn; EIinitstate[5] = EINPn;
}

/* ========================================================== */
/* ===== clear all objects (defaults list remains) ============================ */ 
/* ========================================================== */
EIclear()
{
int i;
EIAavail = EIinitstate[0]; EISsn = EIinitstate[1]; EISdn = EIinitstate[2]; EISin = EIinitstate[3];
EIOn = EIinitstate[4]; EINPn = EIinitstate[5];

/* We need to rebuild order list for presets, since the order list
   can be rearranged during zood use.. Presets will be raised when used
   so it doesn't matter. */
for( i = 0; i < EIOn; i++ ) EIorder[i] = i;

}

/* ============================================================ */
/* ============================================================ */
/* = look up the defaults info (type, given length) for an attribute= */
/* = Low level routine.. should never be called by an application */
/* 								*/
/* = returns a pointer into the attributes list which can be == */
/* = used to get alloc, constraint, and description info. ===== */
/* = Returns NIL on failure. ================================== */
/* = Understands external procs. ============================== */ 
/* = Fills the array nameslots with pointers to attribute names,*/
/* = for every part.  ========================================= */
/* ============================================================ */
static
EIgetinfo( defkey, attr, typ, nameslots, nslots )
int defkey; /* points to a slot in the defaults list */
char attr[]; /* attribute name */
char *typ;  /* type - returned */
int nameslots[]; /* returned- up to 5 pointers into attr list, so complete 
			attribute names need not be stored */
int *nslots;   /* returned- number of name slots filled */
{
int i, j, k, ia, id, ix;
int nparts;
char part[5][20];

ia = EIDattrkey[defkey];

/* see if attribute is multi-level -- break up into parts (delimited by / ) */
ix = 0;
for( i = 0; i < 5 ; i++ ) {
	if( ix >= strlen( attr )) break;
	Egetchunk( part[i], attr, &ix, "/" ); 
	}
nparts = i;
if( nparts >= 5 ) { fprintf( stderr, "(%s) too many parts.\n", attr ); EIerrorflag = 1; return( NIL ); }

for( i = 0; i < nparts; i++ ) {
	/* look up the part.. */
	while( ia != NIL ) {
		if( EIAnparts[ ia ] != NIL ) { 
			fprintf( stderr, "Internal error: nparts != NIL\n" ); 
			EIerrorflag = 1;
			return( NIL ); 
			}
		if( strcmp( part[i], &EISs[ EIAnamep[ ia ]] ) == 0 ) break;
		else ia = EIAnext[ia];
		}
	nameslots[i] = ia;
	if( ia == NIL ) { 
		fprintf( stderr, "%s: not found in the default template.\n", part[i] ); 
		EIerrorflag = 1;
		return(NIL);
		}
	if( EIAtype[ia] == 'X' && i < nparts-1 ) {   /* an exec */
		id = EIAxkey[ ia ];
		ia = EIDattrkey[ id ];
		}
	else break;
	}
*typ = EIAtype[ia];
*nslots = i+1;
return( ia );
}


/* ============================================================== */
/* Get the constraint for the specified attr list entry */
/* ============================================================== */
char *
EIgetconstraint( ia )
int ia;
{
return( &EISs[ EIAconkey[ ia ] ] );
}
/* ============================================================== */
/* Get the description for the specified attr list entry */
/* ============================================================== */
char *
EIgetdesc( ia )
int ia;
{
return( &EISs[ EIAdeskey[ ia ] ] );
}

/* ============================================================ */
/* = Get successive attributes of the given procid, in the ==== */
/* ==order given in the template.  Returns a null string ("") when */
/* ==there are no more..                                        */
/* ============================================================ */
char *
EIgetnextattr( procid, ia )
int procid;
int *ia;  /* pointer into attribute list to access the default - returned */
{
static int oldprocid = NIL;
int idef;

if( procid == NIL ) { oldprocid = NIL; return( 0 ); } /* reset */
*ia = NIL;
if( procid != oldprocid ) {
	idef = EIDattrkey[ EIOdefkey[ procid ] ];
	oldprocid = procid;
	}
else 	{
	if( idef == NIL ) return( "" );
	idef = EIAnext[ idef ];
	}
if( idef == NIL ) return( "" );

*ia = idef;
return( &EISs[ EIAnamep[ idef ] ] );
}
/* ============================================================== */
/* Get the value of an attribute.
/* ============================================================== */
EIget( rtn, procid, path, attr )
char rtn[];
int procid;
char path[], attr[];
{
char typ;
int pos, len, stat;
double *dval;
int *ival;
int i;

stat = EIlocate( procid, path, attr, &typ, &pos, &len );
if( stat < 1 ) return( 0 );

if( typ == 'C' || typ == 'X' ) {
	strcpy( rtn, &EISs[ pos ] );
	}
else if( typ == 'I' ) {
	rtn[0] = '\0';
	ival = &EISi[ pos ];
	for( i = 0; i < len; i++ ) { sprintf( rtn, "%s%d ", rtn, *ival ); ival++; }
	if( strlen( rtn ) > 0 ) rtn[ strlen( rtn ) - 1 ] = '\0'; /* remove last blank */
	}
else if( typ == 'D' ) {
	rtn[0] = '\0';
	dval = &EISd[ pos ];
	for( i = 0; i < len; i++ ) { sprintf( rtn, "%s%g ", rtn, *dval ); dval++; }
	if( strlen( rtn ) > 0 ) rtn[ strlen( rtn ) - 1 ] = '\0'; /* remove last blank */
	}
return( 1 );
}

/* ============================================================== */
/* Get the value associated with the specified attr list entry == */
/* Value is in string format. =================================== */
/* ============================================================== */
char *
EIgetval( ia )
int ia;
{
static char rtn[240];
double *dval;
int *ival;
int i;
int pos, len;
char typ;

pos = EIApos[ia];
typ = EIAtype[ia];
len = EIAlen[ia];

if( typ == 'C' || typ == 'X' ) return( &EISs[ pos ] );
else if( typ == 'I' ) {
	rtn[0] = '\0';
	ival = &EISi[ pos ];
	for( i = 0; i < len; i++ ) { sprintf( rtn, "%s%d ", rtn, *ival ); ival++; }
	return( rtn );
	}
else if( typ == 'D' ) {
	rtn[0] = '\0';
	dval = &EISd[ pos ];
	for( i = 0; i < len; i++ ) { sprintf( rtn, "%s%g ", rtn, *dval ); dval++; }
	return( rtn );
	}
}

/* ============================================================ */
/* See if the named attribute exists. Returns 0 if there is no
   such attribute.  Returns 1 if found in user-spec, 2 if inherited,
   3 if coming from default.  */
/* ============================================================ */
EIexists( procid, path, attr )
int procid;
char path[];
char attr[];
{
int len, pos, stat;
char typ;
if( procid < 0 ) return( 0 );

EIsilence( 1 );
stat = EIlocate( procid, path, attr, &typ, &pos, &len );
EIsilence( 0 );
if( stat >= 1 ) return( stat );
else return( 0 );
}


/* ============================================================ */
/* ============================================================ */
/* Given a proc id and attribute name, return a pointer into C list.*/
/* Len (number of characters) is also returned. =============== */
/* Len will be returned as 0 if the attribute is unspecified. */
/* ============================================================ */
char *
EIgetc( procid, path, attr, len )
int procid;
char path[];
char attr[];
int *len;
{
char typ;
int pos;

if( EIlocate( procid, path, attr, &typ, &pos, len ) < 1 ) { EIerrorflag = 1; return( &EISs[0] ); }
if( !Emember( typ, "CX" )) { 
	fprintf( stderr, "Attempt to use EIgetc() for %s %s (type=%c).\n", 
		EIgetobjname( procid ), attr, typ ); 
	EIerrorflag = 1;
	return( &EISs[0] );
	}
(*len)--; /* compensate for null terminator */
return( &EISs[ pos ] );
}

/* ============================================================ */
/* ============================================================ */
/* Given a proc id and attribute name, return an I value. = */
/* Len (number of members) is also returned. ================== */
/* Len will be returned as 0 if the attribute is unspecified. */
/* ============================================================ */
int *
EIgeti( procid, path, attr, len )
int procid;
char path[];
char attr[];
int *len;
{
char typ;
int pos;

if( EIlocate( procid, path, attr, &typ, &pos, len ) < 1 ) { EIerrorflag = 1; return( &EISi[0] ); }
if( typ != 'I' ) { 
	fprintf( stderr, "Attempt to use EIgeti() for %s %s (type=%c).\n", 
		EIgetobjname( procid ), attr, typ ); 
	EIerrorflag = 1;
	return( &EISi[0] );
	}
return( &EISi[ pos ] );
}

/* ============================================================ */
/* ============================================================ */
/* Given a proc id and attribute name, return a pointer into D list. = */
/* Len (number of members) is also returned. ================== */
/* Len will be returned as 0 if the attribute is unspecified. */
/* ============================================================ */
double *
EIgetd( procid, path, attr, len )
int procid;
char path[];
char attr[];
int *len;
{
char typ;
int pos;

if( EIlocate( procid, path, attr, &typ, &pos, len ) < 1 ) { EIerrorflag = 1; return( &EISd[0] ); }
if( typ != 'D' ) { 
	fprintf( stderr, "EIgetd(): wrong type %s %s (type=%c).\n", EIgetobjname( procid ), attr, typ ); 
	EIerrorflag = 1;
	return( &EISd[0] );
	}

return( &EISd[ pos ] );
}


/* ============================================================ */
/* ============================================================ */
/* Algorithm for matching against a user attribute name ======= */
/* Returns 1 if a match, 0 if not ============================= */
/* Coded for speed. =========================================== */
/* ============================================================ */
static
EInamematch( attr, ia )
char attr[];
int ia;   /* points to attribute list entry */
{
int j;
char cmpattr[40];

j = EIAnamep[ ia ];
strcpy( cmpattr, EIgetattrname( ia ));
if( attr[0] != EINP[j][0] ) return( 0 ); /* quick escape */
else if( strcmp( attr, cmpattr ) ==0 ) return( 1 );
return( 0 );
}

/* ============================================================ */
/* ============================================================ */
/* Get an attribute name. */
/* ============================================================ */
char *
EIgetattrname( ia )
int ia;
{
int j;
int nparts;
static char buf[80];
nparts = EIAnparts[ ia ]; 
j = EIAnamep[ ia ];
buf[0] = '\0';
if( nparts == 1 ) return( EINP[j] );
else if( nparts == 2 ) sprintf( buf, "%s/%s", EINP[ j ], EINP[ j+1 ] );
else if( nparts == 3 ) sprintf( buf, "%s/%s/%s", EINP[ j ], EINP[ j+1 ], EINP[ j+2 ] );
else if( nparts == 4 ) sprintf( buf, "%s/%s/%s/%s", EINP[ j ], EINP[ j+1 ], EINP[ j+2 ], EINP[ j+3 ] );
else if( nparts == 5 ) sprintf( buf, "%s/%s/%s/%s/%s", EINP[j], EINP[j+1], EINP[j+2], EINP[j+3], EINP[j+4] );
else if( nparts == NIL ) return( &EISs[ j ] ); /* default attributes */
else { fprintf( stderr, "Internal error, nparts == %d\n", nparts ); EIerrorflag = 1; return( "" ); }
return( buf );
}
/* ============================================================ */
/* ============================================================ */
/* Silence certain error messages. */
/* ============================================================ */
static
EIsilence( mode )
int mode; /* 1 = silence, 0 = normal; */
{
EIsilentflag = mode;
}

/* ============================================================ */
/* ============================================================ */
/* This routine makes it possible to specify an attribute more */
/* than once.  This routine sets the "occurrance" value N.  The */
/* next EImodattr or EIlocate call will then put/get the Nth   */
/* occurance of the specified attribute. ===================== */
/* The application must keep track of setting the occurrence, */
/* and resetting to 1.

EIsetoccur( n )
int n;
{
EIoccur = n;
}

/* ============================================================ */
/* ============================================================ */
/* This routine allows an application to control the amount of list space */
/* allocated during the subsequent EImodattr call.  It will be automatically */
/* reset in EImodattr(). */
EIsetalloc( n )
int n;
{
EImustalloc = n;
}


/* ============================================================ */
/* ============================================================ */
/* Given a proc id and attribute name, find DATA location info.  */
/* Low level routine, should never be called by application. */
/* Attributes must be requested in the order given in the template. */
/* Returns 1 if found in user list, 2 if found in inheritance, 3 */
/* if found in defaults. ======================================= */
/* Returns 0 on fail. ========================================== */
/* ============================================================ */
/* ============================================================ */
static 
EIlocate( procid, path, aname, typ, pos, len )
int procid;
char path[];
char aname[];
char *typ;
int *pos;
int *len;
{
int i, j, k, ipp;
int nmatches;
char attr[ANAMELEN];
int iflag;

*len = 0;

if( procid < 0 ) { fprintf( stderr, "EIlocate: object does not exist.\n" ); return(0); }

/* build attr name */
if( strlen( path ) > 0 ) {
	if( path[0] == '/' )sprintf( attr, "%s/%s", &path[1], aname );
	else sprintf( attr, "%s/%s", path, aname );
	}
else strcpy( attr, aname );
if( attr[0] == '/' ) 
	{ fprintf( stderr, "%s: unrecognized attribute.\n", attr ); EIerrorflag = 1; return(0); }


/* see if the requested attribute was specified by the user.. */
EIwhere = 1;
i = EIOattrkey[procid];
nmatches = 0;
while( i != NIL ) {
	if( EInamematch( attr, i ) == 1 ) nmatches++;
	if( nmatches >= EIoccur ) { EIulookups++; break; }
	i = EIAnext[i];
	}


/* check the defaults.. */
if( i == NIL ) {
	EIwhere = 3;
	i = EIgetdefaultvalue( procid, attr );
	}

/* its not there.. */
if( i == NIL ) { EIwhere = NIL; return( 0 ); }

/* if attribute is inheritable and there is an inheritable proc, check it.. */
/* if( EIwhere == 1 ) iflag = EIAdef[ EIAdef[i] ]; */
/* else if( EIwhere == 3 ) iflag = EIAdef[i]; */

if( EIwhere == 3 ) {
	iflag = EIAdef[i];
	
	if( iflag % 2 != 1 && EIOinheritid[procid] != NIL ) { 
		ipp = procid;
		j = NIL;
		for( k = 0; k < 4; k++ ) {
			if( j == NIL && EIOinheritid[ipp] != NIL ) {
				EIwhere = 2;
				ipp = EIOinheritid[ ipp ];
				j = EIOattrkey[ ipp ];
				nmatches = 0;
				while( j != NIL ) {
					if( EInamematch( attr, j ) == 1 ) nmatches++;
					if( nmatches >= EIoccur ) { EIinhlookups++; break; }
					else j = EIAnext[j];
					}
				}
			else break;
			}
		if( k >= 4 ) {
			fprintf( stderr, "Too many inheritances (%s %s).\n", EIgetobjname( procid ), attr );
			EIerrorflag = 1;
			}
	
		if( j != NIL ) i = j;  /* put location back into i.. */
		}
	}



*typ = EIAtype[i];
*pos = EIApos[i];
*len = EIAlen[i];
return( EIwhere );
}
/* ============================================================ */
/* ============================================================ */
/* query to get the value of Ewhere (where the last EIlocate found its value) */
EIwhere_was_it()
{
return( EIwhere );
}

/* ============================================================ */
/* == Get an attribute's value from the defaults. ============= */
/* == Low level routine-- should never be called by an application. */
/* == Handles multi-part attribute names. ===================== */
/* == Tries to increase efficiency by keeping a pointer for === */
/* == each part level. ======================================== */
/* ============================================================ */
static
EIgetdefaultvalue( procid, attr )  
int procid;	     
char attr[];
{
int i, k, ix, ip;
int nparts;
char part[5][20];
int div[5];
int nsearch;
int override_exists = 0;
static int prev_idef[5];
static int prevkey[5] = { NIL, NIL, NIL, NIL, NIL };
static int second_try[5];
static int oldprocid = NIL;
int idef;
int dkey;

EIdeflookups++;

/* change of proc, re-initialize.. */
if( procid != oldprocid ) {
	for( i = 0; i < 5; i++ ) prevkey[i] = NIL;
	oldprocid = procid;
	}

/* break up attribute name on dash (/) */
ix = 0;
for( i = 0; i < 5; i++ ) {
	if( ix >= strlen( attr )) break;
	div[i] = ix;
	Egetchunk( part[i], attr, &ix, "/" ); 
	}
nparts = i;

for( i = 0; i < 5; i++ )second_try[i] = 0;
ip = procid;
for( i = 0; i < nparts; i++ ) {

	SEARCH:
	if( i == 0 ) { /* level 0 */
		dkey = EIOdefkey[ip];
		override_exists = EIDoverrideflag[ dkey ]; 
		if( EIDattrkey[ dkey ] == NIL ) idef = NIL;
		else if( prevkey[i] != EIDattrkey[ dkey ] || override_exists ) { 
			/* we've started a new proc */
			idef = EIDattrkey[ dkey ]; 
			prevkey[i] = idef;
			}
		else idef = prev_idef[i];
		}
	else 	{     /* called procs */
		override_exists = EIDoverrideflag[ ip ]; 
		if( EIDattrkey[ ip ] == NIL ) idef = NIL;
		else if( prevkey[i] != EIDattrkey[ ip ] || override_exists ) {  
			/* we've started a new sub-proc in the tree walk */
			idef = EIDattrkey[ ip ]; 
			prevkey[i] = idef;
			}
		else idef = prev_idef[i];
		}

	nsearch = 0;
	while( idef != NIL ) {
		nsearch++;
		if( EISs[EIAnamep[idef]] == part[i][0] ) {     /* opt */
			if( override_exists ) {
				if( strcmp( &EISs[EIAnamep[ idef ] ], &attr[ div[i] ] )==0 ) break;
				}
			if( strcmp( &EISs[ EIAnamep[ idef ] ], part[i] )== 0 ) break;
			}
		idef = EIAnext[ idef ];
		}
	if( idef == NIL ) {
		if( ! second_try[i] ) {
			second_try[i] = 1;
			prevkey[i] = NIL;
			/* fprintf( stderr, "[r:%s]", attr ); */
			EIdeflookupfaults++;
			goto SEARCH;   /* indicates an 'out-of-sequence request' */
			}
		if( EIoccur == 1 && !EIsilentflag ) {
			fprintf( stderr, "Proc %s: default attribute (%s) not found.\n", 
				EIgetobjname( procid ), attr );
			EIerrorflag = 1;
			}
		second_try[i] = 0;
		return( NIL );
		}

	/* if we reach here, we found it.. */
	prev_idef[i] = idef; /* save pointer */
	second_try[i] = 0;

	/* see if we need to check another default.. */
	if( EIAtype[ idef ] == 'X' ) {
		ip = EIAxkey[ idef ];
		continue;
		}
	else break;
	}

return( idef );
}

/* ============================================================ */
/* Return number of user procs to run. ======================== */
/* ============================================================ */
/* ============================================================ */
EIgetn()
{
return( EIOn );
}

/* ============================================================ */
/* ============================================================ */
/* Walk through the order list (upon successive calls) ======== */
/* Must be initialized before use and "closed" after use.. */
/*   mode     effect
   -------  ------------
E_AT_BEGINNING      0    initialize at beginning of list 
E_NEXT      	    1    return next entry
E_AT_END            2    initialize at end of list
E_PREVIOUS         -1    return previous entry
E_DONE              3    finished (necessary to prevent collisions)
 */
/* ============================================================ */
EIgetnextobj( mode, c )
int mode;
int c; /* channel */
{
static int pointer[5] = { 0, 0, 0, 0, 0 };
static int flag[5] = { 0, 0, 0, 0, 0 };  /* 0 = off, 1 = on */

/* check for collisions */
if( ( mode == E_AT_BEGINNING || mode == E_AT_END ) && flag[c] == 1 ) /* collision! */
	fprintf( stderr, "Collision on EIgetnextobj(), channel %d.\n", c );

if( mode == E_AT_BEGINNING ) { pointer[c] = -1; flag[c] = 1; return( NIL ); }
else if( mode == E_AT_END ) { pointer[c] = EIOn; flag[c] = 1; return( NIL ); }
else if( mode == E_DONE ) { flag[c] = 0; return( NIL ); }
while( 1 ) {
	if( mode == 1 ) { 
		pointer[c]++; 
		if( pointer[c] >= EIOn ) { return( NIL ); } 
		}
	else if( mode == -1 ) { 
		pointer[c]--; 
		if( pointer[c] < 0 ) { return( NIL ); } 
		}

	if( EIorder[ pointer[c] ] >= 0 ) break;
	}
return( EIorder[ pointer[c] ] );
}

/* ============================================================ */
/* Mark a proc as deleted by negating it in the order list ==== */
/* ============================================================ */
/* ============================================================ */
EIdelete( procid )
int procid;
{
int i;
for( i = 0; i < EIOn; i++ ) {
	if( EIorder[i] == procid ) {
		EIorder[i] = NIL;
		return( 1 );
		}
	}
fprintf( stderr, "can't find %d for delete.\n", procid );
EIerrorflag = 1;
}


/* ============================================================ */
/* given a proc id, return proc name. */
/* Should really be called EIgetobjecttype() */
/* ============================================================ */
/* ============================================================ */
char *
EIgetobjname( procid )
int procid;
{
int i;
if( procid < 0 || procid >= EIOn ) return( "" );
else return( &EISs[ EIOname[procid] ] );
}

/* ============================================================ */
/* given a proc id, return package name. */
/* ============================================================ */
/* ============================================================ */
char *
EIgetpackagename( procid )
int procid;
{
int i;
if( procid < 0 || procid >= EIOn ) return( "" );
else return( &EISs[ EIPname[ EIDpack[ EIOdefkey[ procid ] ] ] ] );
}

/* ============================================================ */
/* ============================================================ */
/* Write out all procs in order 				*/
/* ============================================================ */
EIwriteall( fnm, mode )
char fnm[];
int mode; /* 0 for user dump, 2 for everything.. 3 everything but popups */
{
FILE *fp;
int ip, len;
char *tag;

fp = fopen( fnm, "w" );
if( fp == NULL ) { fprintf( stderr, "cannot open %s for writing.\n", fnm ); exit(); }
EIgetnextobj( E_AT_BEGINNING, 0 );
while( 1 ) {
	ip = EIgetnextobj( E_NEXT, 0 );
	if( ip < 0 ) break;

	tag = EIgetc( ip, "", "*/tag", &len );
	if( mode == 3 && len > 0 && tag[0] == '_' ) continue; /* skip popups */

	/* write the object */
	EIwriteobj( ip, fp, mode );
	}
EIgetnextobj( E_DONE, 0 );
fclose( fp );
chmod( fnm, 00600 ); /* change file protection */
}


/* ============================================================ */
/* ============================================================ */
/* Write a proc to the given file descriptor. ================= */
/* Returns 1 on success, 0 on fail. =========================== */
/* ============================================================ */
EIwriteobj( procid, fp, mode )
int procid;
FILE *fp;
int mode; /* 0 for user dump, 1 for gc, 2 for all.. */
{
int ip, i, j;
int *ival;
double *dval;
char *name;

if( fp == NULL ) { 
	fprintf( stderr, "Null file descriptor.\n" ); 
	EIerrorflag = 1;
	return( 0 ); 
	}
	
ip = procid;
i = EIOattrkey[ ip ];

fprintf( fp, "\nProc %s\n", EIgetobjname( procid ) );
while( i != NIL ) {
	name = EIgetattrname( i );

	/* supress silent attributes if writing a user dump.. */
	if( mode >= 1 || EIAdef[ EIAdef[ i ] ] < 2 ) {
		fprintf( fp, "%s: ", name );
		if( Emember ( EIAtype[i], "CX" )) {
			/* enclose in quotes */
			fprintf( fp, "\"" );
			for( j = EIApos[i]; j < EIApos[i]+EIAlen[i]; j++ ) {
				if( EISs[j] == '\0' ) break;
				if( EISs[j] == '\n' ) fprintf( fp, "\"\n\"" );
				else fprintf( fp, "%c", EISs[j] );
				}
			fprintf( fp, "\"" );
			}
		else if( EIAtype[i] == 'I' ) {
			ival = &EISi[ EIApos[i] ];
			for( j = 0; j < EIAlen[i]; j++ ) { fprintf( fp, "%d ", *ival ); ival++; }
			}
		else if( EIAtype[i] == 'D' ) {
			dval = &EISd[ EIApos[i] ];
			for( j = 0; j < EIAlen[i]; j++ ) { fprintf( fp, "%g ", *dval ); dval++; }
			}
		fprintf( fp, "\n" );
		}
	i = EIAnext[i];
	}
return( 1 );
}


/* ==== read a defaults file ================================== */
/* ============================================================ */
/* ==== Return 1 on success, 0 on failure. ==================== */
/* ============================================================ */
/* Defaults file format:
 *  @@begin <objname>
 *  <attr-name> <attr-type> [attr-length] : <default-val> : <attr-constraint> : <description>
 *  ...
 *  @@end
 */
EIreaddeflist( fnm )
char fnm[];
{
FILE *fp;
char buf[512];
int state;
int ix;
char onm[50];
char attr[50];
char constraint[40];
char typ[4];
char lenstr[40];
char val[200];  
char str[300];
int len;
int na;
int lasta;
int itmp;
int i;
int n;
int pack;
char flags[12];
int iflag;

fp = fopen( fnm, "r" );
if( fp == NULL ) { 
	fprintf( stderr, "Cannot open defaults list %s.\n", fnm ); 
	EIerrorflag = 1;
	return( 0 ); 
	}

state = 0;
pack = NIL;
EILineno = 0;
EIerrorflag = 0;
while( fgets( buf, 512, fp ) != NULL ) {
	EILineno++;
	if( state == 0 ) {      /* looking for @@package or @@begin */
		if( strncmp( buf, "@@package", 9 )==0 ) {
			sscanf( buf, "%*s %s", onm );
			for( i = 0; i < EIPn; i++ ) if( strcmp( onm, &EISs[EIPname[i]] )==0 )break;
			if( i == EIPn ) {
				EIPname[i] = EIaddss( onm );
				EIPn++;
				}
			pack = i;
			}
		else if( strncmp( buf, "@@begin", 7 )==0 ) {  /* get a def obj name */
			state = 1; 
			sscanf( buf, "%*s %s", onm );
			for( i = 0; i < EIDn; i++ ) if( strcmp( onm, &EISs[EIDname[i]] )==0 ) break;
			if( i != EIDn ) continue;
			EIDname[ EIDn ] = EIaddss( onm );
			EIDattrkey[ EIDn ] = NIL;
			EIDpack[ EIDn ] = pack;
			EIDoverrideflag[ EIDn ] = 0;
			EIDn++;
			na = 0;
			}
		continue;
		}
	
	else if( state == 1 ) {   /* getting attributes, and looking for @@end */
		if( strncmp( buf, "@@end", 5 )==0 ) { state = 0; continue; }
		else if( buf[0] == '#' ) continue; /* comment */

		ix = 0;
		Egetchunk( str, buf, &ix, ":" );

		if( ix >= strlen( buf ) ) continue; /* blank line.. */

		/* bad continuation line or some other problem.. */
		if( strlen( str ) > 60 ) { 
			fprintf( stderr, "%3d: illegal text\n", EILineno ); 
			EIerrorflag = 1;
			continue; 
			}

		n = sscanf( str, "%s %s %s", attr, typ, lenstr );

		EIAxkey[ EIAavail ] = NIL;
		if( typ[0] == 'X' ) { /* external proc include.. */
			len = 1;
			/* lookup the referenced proc, which is in lenstr */
			for( i = 0; i < EIDn; i++ ) if( strcmp( &EISs[ EIDname[i] ], lenstr )==0 ) break;
			if( i == EIDn ) { 
				fprintf( stderr, "%3d: Referenced Proc (%s) not defined.\n", EILineno, lenstr ); 
				EIerrorflag = 1;
				continue;
				}
			EIAxkey[ EIAavail ] = i; /* save handle on default for future quick access */
			}

		else if( n == 2 ) len = 1;
		else if( n == 3 )len = atoi( lenstr );
		else { 
			fprintf( stderr, "%3d: attribute name and type required.\n", EILineno ); 
			EIerrorflag = 1;
			continue; 
			}

		/* add room for null terminator.. */
		if( Emember( typ[0], "CX" )) len++;
	
		Egetchunk( val, buf, &ix, ":" );
		Estrip_ws( val );

		if( Emember( '/', attr )) { /* an override, no constraint or description.. */
			constraint[0] = '\0';
			str[0] = '\0';
			EIDoverrideflag[ EIDn-1 ] = 1;
			/* note-- override names will be stored in the string pool */
			}

		else	{		    /* everything else.. */

			/* flag */
			Egetchunk( flags, buf, &ix, ":" );
			iflag = 0;
			if( Emember( 'U', flags )) iflag += 1;
			if( Emember( 'H', flags )) iflag += 2;

			/* constraint */
			Egetchunk( constraint, buf, &ix, ":" );
			Estrip_ws( constraint );
			if( strlen( constraint ) < 1 ) { 
				fprintf( stderr, "%3d: missing constraint field\n", EILineno ); 
				EIerrorflag = 1;
				continue; 
				}

			/* description */
			Egetchunk( str, buf, &ix, ":" );
			Estrip_ws( str );
			if( strlen( str ) < 1 ) {
				fprintf( stderr, "%3d: missing description field\n", EILineno ); 
				EIerrorflag = 1;
				continue; 
				}
			}

		/* continuation desc lines.. */
		if( str[ strlen( str )-1 ] == '\\' ) {
			str[ strlen( str )-1 ] = '\0'; /* get rid of backslash */
			while( 1 ) {
				fgets( buf, 512, fp );
				EILineno++;
				Estrip_ws( buf );
				sprintf( str, "%s %s", str, buf );
				if( buf[ strlen( buf ) - 1 ] != '\\' ) break;
				else str[ strlen( str )-1 ] = '\0'; /* get rid of backslash */
				}
			}
		
		itmp = EIAavail;
		if( na == 0 ) {
			EIDattrkey[ EIDn-1 ] = EIAavail; 
			EIadda( NIL, attr, typ[0], len, constraint, val, str, NIL, NULL, NIL, iflag ); 
			}
		else EIadda( NIL, attr, typ[0], len, constraint, val, str, lasta, NULL, NIL, iflag );
		na++;
		lasta = itmp;
		}
	}
fclose( fp );
if( pack < 0 ) { fprintf( stderr, "No @@package declaration was found.\n" ); EIerrorflag = 1; }
else if( EIDn < 1 ) { fprintf( stderr, "Expecting @@begin.  No objects found in file.\n" ); EIerrorflag = 1; }
else if ( state == 1 ) { fprintf( stderr, "Missing @@end.\n" ); EIerrorflag = 1; }
if( EIerrorflag ) return( 0 );
else return( 1 );
}

/* ==== read a user file ============================= */
/* =================================================== */
/* ==== Returns 1 on success, 0 on failure. ========== */
/* =================================================== */
/* Syntax is Proc <procname> 
   	     <attr-name> : <attr-value>
	     <attr-name> : <attr-value>
	     ..
   We also need to handle old-style files which have just procname.
 */
EIreaduserlist( s )
char s[];
{
char buf[512];
int state;
int firstproc;
int firstattr;
char str[200];
char procname[200];
char val[512];
int nprms, id;
double tx, ty, scx, scy;
int len;
int itmp, lasta;
int ip; /* always points to the current proc.. */
int i;
char typ;
int found;
int ix;
int nameslots[5], nslots;
int idef;
int sourceflag; /* 0=file   1=in the string s */
int readix; 
FILE *fp;
int stat;

/* inheritflag = 0; */

firstproc = 1;
firstattr = 1;
EILineno = 0;
EIerrorflag = 0;

/* try to open s as a filename.. */
fp = NULL;
if( strlen( s ) < 80 ) fp = fopen( s, "r" );
if( fp != NULL ) sourceflag = 0;
else sourceflag = 1;

readix = 0;

	

while( 1 ) {
	EILineno++;
	str[0] = '\0'; procname[0] = '\0'; /* null out tokens */

	if( sourceflag == 0 ) {
		if( fgets( buf, 512, fp ) == NULL ) strcpy( str, "Proc" ); /* indicate that we're done.. */
		buf[ strlen( buf ) - 1 ] = '\0'; /* strip off newline.. */
		}
	else if( sourceflag == 1 ) {
		if( readix >= strlen( s ) ) strcpy( str, "Proc" );  /* indicate that we're done.. */
		Egetchunk( buf, s, &readix, "\n" );
		}

	if( str[0] == '\0' ) { /* everything but the end.. */
		nprms = sscanf( buf, "%s %s", str, procname ); /* check first two tokens.. */
		if( nprms < 1 ) continue;
		}

	if( str[0] == '#' ) continue;  /* comments */

	if( strcmp( str, "Proc" )==0 ) {  
		if( procname[0] == '\0' ) {
			if( EIOn < 1 ) { 
				fprintf( stderr, "No objects were found.\n" ); 
				EIerrorflag = 1;
				}
			if( sourceflag == 0 ) fclose( fp );
			if( EIerrorflag != 0 ) return( 0 );  /* normal exit */
			else return( 1 );  /* normal exit */
			}

		/* add a new proc */
		/* ============== */
		/* strip off colon if there is one.. */
		if( procname[ strlen( procname )-1 ] == ':' ) procname[ strlen( procname )-1 ] = '\0';
		ip = EIcreate( procname );
		firstproc = 0;
		firstattr = 1;
		}

	else if( !firstproc ) { 	

		/* add an attribute */
		/* ================ */
		ix = 0;
		Egetchunk( str, buf, &ix, ":" );
		Estrip_ws( str );
		len = strlen( str );

		/* its a "tag: value" line.. */
		if( str[0] != '"' && str[len-1] != '\\' && ix != strlen( buf ) ) { 

			strcpy( val, &buf[ix+1] );
	
			Estrip_ws( val ); /* get rid of leading & trailing white space */

			/* get rid of leading and trailing quote.. */
			if( val[ strlen( val ) -1 ] == '"' ) val[ strlen( val ) -1 ] = '\0';
			if( val[0] == '"' ) {
				strcpy( val, &val[1] );
				}

			/* take special action if it is a "built-in" attribute.. */
			if( strcmp( str, "*/inherit" )==0 ) EIaddinherit( val, ip );
			
			EIaddalways = 1; /* for the sake of multiple occurrences */
			stat = EImodattr( ip, "", str, val );
			if( stat != 1 ) fprintf( stderr, "Error in line %d of control file.\n",
						EILineno );	
			EIaddalways = 0;
			
			}	
		else 	{
			Estrip_ws( buf );
			EIaddcontline( buf );
			}
		firstattr = 0;
		}
	}
}

/* =========================================================== */
/* =========================================================== */
/* Create a user instance of an object.  ===================== */
/* Returns procid. =========================================== */
/* =========================================================== */

EIcreate( procname )
char procname[];
{
int i, ip;
char tag[20];

ip = EIOn;
/* verify proc name and get index of first default attribute.. */
for( i = 0; i < EIDn; i++ ) if( strcmp( procname, &EISs[EIDname[i]] )==0 ) break;
if( i == EIDn ) { 
	fprintf( stderr, "%3d: Unrecognized Proc name (%s).\n", EILineno, procname );
	EIerrorflag = 1;
	return( 0 ); 
	}
else EIOdefkey[ip] = i;

EIOname[ip] = EIaddss( procname );   	/* save the name */

EIOinheritid[ip] = NIL; /* initialize */
EIOattrkey[ip] = NIL; 
EIorder[ip] = ip;
EIOn++;

return( ip );
}

/* =========================================================== */
/* =========================================================== */
/* Copy a user object, creating a new instance. ============== */
/* Returns the new procid. =================================== */
/* =========================================================== */

EIcopy( procid )
int procid;
{
int i, newprocid;
char attr[40];

newprocid = EIcreate( &EISs[ EIOname[ procid ]] );
i = EIOattrkey[ procid ];
while( i != NIL ) {
	strcpy( attr, EIgetattrname( i ));
	EImodattr( newprocid, "", attr, EIgetval( i ) );
	if( Esmember( attr, "Clone */inherit", " " )) {
		EIaddinherit( EIgetval( i ), newprocid );
		}
	i = EIAnext[i];
	}

return( newprocid );
}

/* ============================================================ */
/* ============================================================ */
/* Add an inheritance relationship */
/* ============================================================ */
static
EIaddinherit( val, ip )
char val[];
int ip;
{
int itag;

itag = EItaglookup( val, ip );
if( itag == NIL ) { 
	fprintf( stderr, "%3d: inherited Proc (%s) not recognized.\n", 
		EILineno, val );
	EIerrorflag = 1;
	}
else EIOinheritid[ip] = itag;
}

/* ============================================================ */
/* Get the proc_id associated with the tag.  Starts with current */
/* procid (ip), and searches backward through the order list until a */
/* match is found.  If ip is NIL, scanning just goes through list linearly. */
/* Returns the proc_id, or NIL if none found. */
EItaglookup( tag, ip )
char tag[];
int ip;       /* current procid */
{
int  itag, len;
char *s;

/* simple linear scan.. */
if( ip == NIL ) {
	EIgetnextobj( E_AT_BEGINNING, 3 );
	while( 1 ) {
		itag = EIgetnextobj( E_NEXT, 3 ); 
		if( itag == NIL ) { EIgetnextobj( E_DONE, 3 ); return( NIL ); }
		if( EIexists( itag, "", "*/tag" ) == 1 ) { /* must be in user-spec, not inherited. */
			s = EIgetc( itag, "", "*/tag", &len );
			if( len > 0 ) {
				if( strcmp( s, tag )==0 ) break;
				}
			}
		}
	EIgetnextobj( E_DONE, 3 );
	return( itag );
	}

/* scan from current proc backward.. */
EIgetnextobj( E_AT_END, 3 );
while( 1 ) {
	itag = EIgetnextobj( E_PREVIOUS, 3 );
	if( itag == NIL ) { EIgetnextobj( E_DONE, 3 ); return( NIL ); }
	else if( itag == ip ) break;
	}
while( 1 ) {
	itag = EIgetnextobj( E_PREVIOUS, 3 ); /* now, search back until the desired tag is found.. */
	if( itag == NIL ) { EIgetnextobj( E_DONE, 3 ); return( NIL ); }
	if( EIexists( itag, "", "*/tag" ) == 1 ) { /* must be in user-spec, not inherited. */
		s = EIgetc( itag, "", "*/tag", &len );
		if( len > 0 ) {
			if( strcmp( s, tag )==0 ) break;
			}
		}
	}
EIgetnextobj( E_DONE, 3 );
return( itag );
}


/* ============================================================ */
/* ============================================================ */
/* Set an attribute to a value. =============================== */
/* Returns 1 on success, 0 on fail. =========================== */
/* ============================================================ */
EImodattr( procid, path, aname, val )
int procid;    /* the proc id */
char path[];   /* attribute path */
char aname[];   /* attribute name */
char val[];    /* the new value */
{
int ip, i, lasta, status, idef, alloc, len, itmp, stat, dogc;
char typ;
int nameslots[5], nslots;
char attr[ ANAMELEN ];
int nmatches;
int gc_once = 0;
char gcfnm[80];

RETRY:

if( procid < 0 ) { fprintf( stderr, "Unrecognized tag." ); return( 0 ); }

/* build attr name */
if( strlen( path ) > 0 ) {
	if( path[0] == '/' )sprintf( attr, "%s/%s", &path[1], aname );
	else sprintf( attr, "%s/%s", path, aname );
	}
else strcpy( attr, aname );

ip = procid;
i = EIOattrkey[ip];
lasta = NIL;

/* look up attribute in default list to get type and allocation */
idef = EIgetinfo( EIOdefkey[ip], attr, &typ, nameslots, &nslots );
if( idef == NIL ) {
  	/* fprintf( stderr, "Unrecognized attribute (%s) in %s.\n", attr, EIgetobjname( procid ) ); */
	EIerrorflag = 1;
  	return( 0 );
  	}
alloc = EIAalloc[ idef ];

/* find length */
if( Emember( typ, "CX" ) ) len = strlen( val ) +1;
else { len = Ecounttokens( val ); }
		
/* check for full list */
dogc = 0;
if( Emember( typ, "CX" ) && (EISsn + len) > STRINGPOOLLEN ) dogc = 1;
else if( typ == 'D' && (EISdn + len) > DLISTLEN ) dogc = 1;
else if( typ == 'I' && (EISin + len) > ILISTLEN ) dogc = 1;
if( dogc ) { 
	if( gc_once ) {
		fprintf( stderr, "Internal capacity exceeded even after gc.\n\
	Type: %c; Length: %d; String: %d; Float: %d; Int: %d.\n", typ, len, EISsn, EISdn, EISin );
		return( 0 );
		}
	
	fprintf( stderr, "Garbage collection.." );
	/* do garbage collection and retry.. */
	sprintf( gcfnm, "%szoodgc%05d", TMP_DIR, getpid() );
	/* EIwriteall( "/usr/tmp/zood.gc", 2 ); */
	EIwriteall( gcfnm, 2 );
	EIinit();
	EIreaduserlist( gcfnm );
	fprintf( stderr, "completed.\n" );
	/* unlink( gcfnm ); */
	gc_once = 1;
	goto RETRY;
	}


/* look up attribute in user list */
nmatches = 0;
while( i != NIL ) {
	if( EInamematch( attr, i )) nmatches++;
	if( nmatches >= EIoccur && !EIaddalways ) break;
	else {
		lasta = i;
		i = EIAnext[ i ];
		}
	}

if( EImustalloc != NIL ) { len = EImustalloc; EImustalloc = NIL; }

if( i == NIL ) { /* if not found we will add it to the end of the user attribute chain.. */
	len = alloc; 
	if( lasta == NIL ) {
		EIOattrkey[ ip ] = EIAavail; 
		status = EIadda( NIL, attr, typ, len, "", val, "", NIL, nameslots, nslots, idef );
		}
	else status = EIadda( NIL, attr, typ, len, "", val, "", lasta, nameslots, nslots, idef );
	return( status );
	}
else if( len > EIAalloc[i] ) {  /* or, if new length is too big we will have to add it and link it in.. */
	/* fprintf( stderr, "." ); fflush( stderr ); */
	if( lasta == NIL ) {
		itmp = EIOattrkey[ip];
		EIOattrkey[ip] = EIAavail;
		status = EIadda( NIL, attr, typ, len, "", val, "", NIL, nameslots, nslots, idef );
		EIAnext[ EIAavail-1 ] = itmp; /* preserve the 'next' pointer */
		}
	else	{
		status = EIadda( NIL, attr, typ, len, "", val, "", lasta, nameslots, nslots, idef );
		EIAnext[ EIAavail-1 ] = EIAnext[i];
		/* return( status );  */ /* moved down two lines.. scg 11-17-95 */
		}
	return( status ); 
	}

/* or, just modify the data.. */
status = EIadda( i, attr, typ, 0, "", val, "", NIL, nameslots, nslots, idef );
return( status );
}

/* =================================================== */
/* =================================================== */
/* Low-level routine to add info to the database. ==== */
/* Used to add both defaults and user attributes. ==== */
/* Should never be called by an application. ========= */
/* =================================================== */
static
EIadda( slot, attr, typ, alloc, constraint, val, desc, lasta, nameslots, nslots, idef )
int slot;          /* NIL = insert,   else update into this slot */
char attr[];       /* attribute name */
char typ;	   /* attribute storage type */
int alloc;         /* (insert mode only).  If > 0, this many slots will be reserved in the storage list.
				For user values this will generally be the alloc of the default entry.
				If not supplied (passed as 0), storage reservation is based on the value. */
char constraint[]; /* required for defaults only.. */
char val[];	   /* always requred */
char desc[];       /* required for defaults only.. */
int lasta; 	   /* previous attribute in chain.. */
int nameslots[];   
int nslots;
int idef;	   /* attributes only-- points to the default entry */
{
int i, ia, n, k, ix;
char str[100];
double atof();
int isnum;

if( slot == NIL ) { /* inserting.. */
	/* add attribute to attr-list */
	ia = EIAavail;
	if( lasta != NIL ) EIAnext[lasta] = ia;
	/* process the attribute name */
	if( nslots == NIL ) EIAnamep[ia] = EIaddss( attr ); /* default */
	else if( nslots == 0 ) { fprintf( stderr, "Internal error. nslots == %d\n", nslots ); return( 0 ); }
	else	{   /* add to name part list */
		EIAnamep[ia] = EINPn;
		for( i = 0; i < nslots; i++ ) EINP[ EINPn++ ] = &EISs[ EIAnamep[ nameslots[i] ] ]; 
		if( EINPn > MAXNP ) fprintf( stderr, "Name part list overflow.\n" ); 
		}
	EIAnparts[ia] = nslots;
	EIAtype[ia] = typ;
	EIAdef[ia] = idef;
	EIAnext[ia] = NIL;
	EIAavail++;
	}
else	{
	ia = slot;
	}

EIcontplace = NIL;

/* put constraint into string pool.. */
if( slot == NIL && strlen( constraint ) > 0 ) EIAconkey[ia] = EIaddss( constraint );
else EIAconkey[ia] = NIL;


/* put descriptor into string pool.. */
if( slot == NIL && strlen( desc ) > 0 ) EIAdeskey[ia] = EIaddss( desc );
else EIAdeskey[ia] = NIL;

/* put val into one of the lists.. */

/* string */
if( typ == 'C' || typ == 'X' ) { 
	/* a null string ("") will go into the string list and occupy one spot. */
	/* we can't use the utility routine because other stuff is going on.. */
	if( slot == NIL ) { i = EISsn; EIApos[ia] = i; }
	else i = EIApos[ia];

	strcpy( &EISs[i], val );
	n = strlen( val ) + 1;
	EIAlen[ia] = n;
	if( slot == NIL ) { /* we're inserting.. */
		if( n > alloc ) EIAalloc[ia] = n;
		else EIAalloc[ia] = alloc;
		EIcontplace = EISsn + n; /* remember exact end of string in case there's a continuation.. */
		EISsn += EIAalloc[ia];
		}
	if( EISsn > STRINGPOOLLEN ) { 
		fprintf( stderr, "%3d: String list overflow.\n", EILineno ); 
		EIerrorflag = 1;
		return( 0 ); 
		}
	}	

/* int */
else if( typ == 'I' ) {
	if( slot == NIL ) { i = EISin; EIApos[ia] = i; }
	else i = EIApos[ia];
	ix = 0;
	for( n = 0; ; n++ ) {
		if( ix >= strlen( val )) break;
		Egetchunk( str, val, &ix, " 	," );
		if( str[0] == '\0' ) break;
		EISi[i+n] = atoi( str );
		}
	EIAlen[ia] = n;
	if( slot == NIL ) { /* we're inserting.. */
		if( n > alloc ) EIAalloc[ia] = n;
		else if( n < 1 && alloc < 1 ) EIAalloc[ia] = 1;
		else EIAalloc[ia] = alloc;
		EISin += EIAalloc[ia];
		}
	if( EISin > ILISTLEN ) { 
		fprintf( stderr, "%3d: Int list overflow.\n", EILineno ); 
		EIerrorflag = 1;
		return( 0 ); 
		}
	}

/* double */
else if( typ == 'D' ) {
	if( slot == NIL ) { i = EISdn; EIApos[ia] = i; }
	else i = EIApos[ia];
	ix = 0;
	for( n = 0; ; n++ ) {
		if( ix >= strlen( val )) break;
		Egetchunk( str, val, &ix, " 	," );
		if( str[0] == '\0' ) break;
		EISd[i+n] = atof( str );
		}
	EIAlen[ia] = n;
	if( slot == NIL ) { /* we're inserting.. */
		if( n > alloc ) EIAalloc[ia] = n;
		else if( n < 1 && alloc < 1 ) EIAalloc[ia] = 1;
		else EIAalloc[ia] = alloc;
		EISdn += EIAalloc[ia];
		}
	if( EISdn > DLISTLEN ) { 
		fprintf( stderr, "%3d: Double list overflow.\n", EILineno ); 
		EIerrorflag = 1;
		return( 0 ); 
		}
	}


return( 1 );
}

/* ========================================================== */
/* ==== add a continuation line to the previous attribute..== */
/* ==== Only when adding new attributes (not modifying existing ones) */
/* ==== C type only..  Must be called IMMEDIATELY after first row is added. */
/* ============================================================ */
EIaddcontline( line )
char line[];	/* continuation line to be appended to string.. */
{
int ia;
int len;

ia = EIAavail - 1;
if( ! Emember( EIAtype[ia], "CX" )) return(0); /* continuations for char only */

if( EIcontplace == NIL ) { 
	fprintf( stderr, "%3d. Illegal continuation.", EILineno );
	EIerrorflag = 1;
	return( 0 );
	}

/* strip off trailing quote which may be used to maintain white space in text */
if( line[ strlen( line ) - 1 ] ==  '"' ) line[ strlen( line )-1 ] = '\0';

/* handle the case of empty first line */
if( (EIcontplace-1) == EIApos[ia] ) EIApos[ia]++;
else EISs[ EIcontplace -1 ] = '\n';

/* strip off leading quote */
if( line[0] == '"' ) strcpy( line, &line[1] );

/* add the string */
if( strlen( line ) == 0 ) strcpy( line, " " );
len = strlen( line ) + 1;
strcpy( &EISs[ EIcontplace ], line );

EIcontplace += len;
EISsn += len; 
EIAlen[ia] += len; 
if( EIAlen[ia] > EIAalloc[ia] ) EIAalloc[ia] = EIAlen[ia];  /* update storage list reservation..*/
}

/* ========================================================= */
/* add a static string to the string pool. ================= */
/* function returns an index into string pool ============== */
/* ========================================================= */
/* ========================================================= */
static
EIaddss( s )
char s[];
{
int i;
i = EISsn;
strcpy( &EISs[ i ], s );
EISsn += strlen( s ) + 1;
if( EISsn > STRINGPOOLLEN ) { 
	fprintf( stderr, "%3d: String list overflow.\n", EILineno ); 
	EIerrorflag = 1;
	return( -1 ); 
	}
return( i );
}

/* ========================================================== */
EIcheckerror()
{
return( EIerrorflag );
}
/* ========================================================== */
EIseterror()
{
EIerrorflag = 0;
}
/* =================================================== */
/* =================================================== */
/* =================================================== */
/* =================================================== */
EIdump( fnm )
char *fnm;
{
int i;
FILE *fp;
int detailed;

detailed = 1;

fp = fopen( fnm, "w" );
if( fp == NULL ) { fprintf( stderr, "can't write to dump file.\n" ); return( 0 ); }

fprintf( fp, "Default lookups: %d.   Retries: %d   User lookups: %d   Inh lookups: %d.\n", 
	EIdeflookups, EIdeflookupfaults, EIulookups, EIinhlookups );
fprintf( fp, "----------------------------\n**** Defaults:\n" );
for( i = 0; i < EIDn; i++ ) fprintf( fp, "%2d. %20s attr=%d override=%d\n", 
	i, &EISs[EIDname[i]], EIDattrkey[i], EIDoverrideflag[i] );

fprintf( fp, "**** Procs:\n" );
for( i = 0; i < EIOn; i++ ) fprintf( fp, "%2d. %20s attr@%d def@%d clone=%d\n", i, &EISs[ EIOname[i] ],
				EIOattrkey[i], EIOdefkey[i], EIOinheritid[i] );

fprintf( fp, "**** Order list:\n" );
for( i = 0; i < EIOn; i++ ) {
	if( i % 30 == 0 ) fprintf( fp, "\n" );
	fprintf( fp, "%d ", EIorder[i] );
	}
fprintf( fp, "\n" );

fprintf( fp, "**** Attributes: (def names go in string list, others via name part list)\n" );
for( i = 0; i < EIAavail; i++ ) {
	fprintf( fp, "%02d. %-12s [%s] %d/%d", i, EIgetattrname( i ), EIgetval( i ), EIAlen[i], EIAalloc[i] );

	if( detailed ) fprintf( fp, " def/fl=%d np=%d ptr=%d typ=%c pos=%d next=%d con=%d des=%d xkey=%d",
				EIAdef[i], EIAnparts[i], EIAnamep[i], EIAtype[i], EIApos[i], 
				EIAnext[i], EIAconkey[i], EIAdeskey[i], EIAxkey[i] );
	fprintf( fp, "\n" );
	}
fprintf( fp, "\n**** Name part list:\n" );
for( i = 0; i < EINPn; i++ ) {
	if( i % 10 == 0 ) fprintf( fp, "\n" );
	fprintf( fp, "(%d)%s ", i, EINP[i] );
	}


fprintf( fp, "\n**** String list\n" );
EISs[ EISsn ] = '\0';
for( i = 0; i < EISsn; i++ ) {
	if( i % 100 == 0 ) fprintf( fp, "\n %5d.", i );
	if( EISs[i] == '\0' && EISs[i+1] != '\0' ) fprintf( fp, "|" );
	else if( EISs[i] == '\0' ) fprintf( fp, "_" );
	else if( EISs[i] == '\n' ) fprintf( fp, "\\n" );
	else fprintf( fp, "%c", EISs[i] );
	}

fprintf( fp, "\n\n**** Double list" );
for( i = 0; i < EISdn; i++ ) {
	if( i % 10 == 0 ) fprintf( fp, "\n" );
	fprintf( fp, "(%d)%g ", i, EISd[i] );
	}
 
fprintf( fp, "\n\n**** Int list" );
for( i = 0; i < EISin; i++ ) {
	if( i % 10 == 0 ) fprintf( fp, "\n" );
	fprintf( fp, "%(%d)%d ", i, EISi[i] );
	}

fprintf( fp, "\n\n" );
fclose( fp );
fprintf( stderr, "Dump completed.\n" ); fflush( stderr );
}
SHAR_EOF
############################


