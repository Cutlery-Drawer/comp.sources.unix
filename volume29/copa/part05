Newsgroups: comp.sources.unix
From: stevegru@welchlink.welch.jhu.edu (STEPHEN C GRUBB)
Subject: v29i092: copa - gui control panel kit for shell, C, perl - V1.0, Part05/08
References: <1.823324036.2981@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: stevegru@welchlink.welch.jhu.edu (STEPHEN C GRUBB)
Posting-Number: Volume 29, Issue 92
Archive-Name: copa/part05

#	This is a shell archive.
#	Remove everything above and including the cut line.
#	Then run the rest of the file through sh.
# - - - - - - C U T   H E R E - - - - - - - - - - - - - - -
#!/bin/sh
#
# Part 5
#
# shar:	Shell Archiver
#	Run the following text with /bin/sh to create:
#		src/align.c
#		src/arrow.c
#		src/bigbuf.h
#		src/block.c
#		src/copa_api.c
#		src/copa_button.c
#		src/copa_cli.c
#		src/copa_entry.c
#		src/copa_exec.c
#		src/copa_gen.c
echo src/align.c
cat << \SHAR_EOF > src/align.c
/* Object alignment system */

#include "elib.x"

/* ======================================================== */
/* Run alignment on everything.. */
Ealignall()
{
int ip;
char *package, *procname;

Esquelch_display( 1 );

EIgetnextobj( E_AT_BEGINNING, 1 );
while( 1 ) {
	ip = EIgetnextobj( E_NEXT, 1 );
	if( ip < 0 ) break;

	package = EIgetpackagename( ip );
	if( strcmp( package, "plot" )==0 ) continue; /* don't run alignment on the plot objects.. */

	Ealign( ip );
	Egen( ip ); /* update bb */
	}
EIgetnextobj( E_DONE, 1 );

/* experimental.. */
Esquelch_display( 0 );
return( 1 ); 

}

/* ======================================================== */
/* run alignment on proc p */
/* p should not have been displayed yet */
/* this will modify the translation vector for the object.. */
Ealign( p )
int p;
{
int len, len2, guidep;
double *x1, *y1, *x2, *y2;
double *guidex1;
double *oldtrl_x, *oldtrl_y;
char *hexpr, *vexpr, side[12], obj[20], alex[12], foo[12];
double pos, trl_x, trl_y;
char buf[40];
double root[4];

if( !EIexists( p, "", "*/display" )) return( 0 );
EIgetc( p, "", "*/display", &len ); /* invisible.. */
if( len < 1 ) return( 0 );

if( !EIexists( p, "", "*/align_h" )) return( 0 );

/* first see if there is any alignment info.. */
hexpr = EIgetc( p, "", "*/align_h", &len );
vexpr = EIgetc( p, "", "*/align_v", &len2 );
if( len == 0 && len2 == 0 ) return( 0 );

/* set up root entry.. */
root[0] = 0.0; root[1] = 0.0; root[2] = EWinx; root[3] = EWiny; 

/* if bb doesn't exist yet, generate the object silently to get bounding box.. */
/* get a clean bounding box.. */
Esquelch_display( 1 );
Enulloutbb( p );
Egen( p );
Esquelch_display( 0 );
x1 = EIgetd( p, "", "*/bb", &len );
y1 = x1 + 1; x2 = x1 + 2; y2 = x1 + 3;

oldtrl_x = EIgetd( p, "", "*/trl", &len );
oldtrl_y = oldtrl_x + 1;

trl_x = 0.0; trl_y = 0.0;

/* horizontal.. */

if( sscanf( hexpr, "%s %s %s %s", side, obj, alex, foo ) != 3 )
	{ fprintf( stderr, "(%s) Illegal alignment expression.\n", hexpr ); return( 0 ); }

if( strcmp( obj, "root" )==0 ) guidex1 = root;
else	{
	guidep = EItaglookup( obj, E_NIL );   /* get the proc_id for the h guide tag.. */
	if( guidep == E_NIL ) { fprintf( stderr, "Referenced tag (%s) not found.\n", obj ); return( 0 ); }
	
	/* get the bounding box of guidep.. */
	guidex1 = EIgetd( guidep, "", "*/bb", &len );
	if( len != 4 ) { fprintf( stderr, "Referenced object (%s) has bad bb, len=%d.\n", obj, len ); return( 0 ); }
	}

Eparse_alex( alex, guidex1, &pos, 'h' );
if( side[0] == 'L' ) trl_x = pos - *x1;
else if( side[0] == 'R' ) trl_x = pos - *x2;
else if( side[0] == 'C' ) trl_x = pos - (*x1 + ((*x2 - *x1)/2.0));


/* vertical.. */
if( sscanf( vexpr, "%s %s %s %s", side, obj, alex, foo ) != 3 )
	{ fprintf( stderr, "(%s) Illegal alignment expression.\n", vexpr ); return( 0 ); }

if( strcmp( obj, "root" )==0 ) guidex1 = root;
else	{
	guidep = EItaglookup( obj, E_NIL ); /* get the proc_id for the v guide tag.. */
	if( guidep == E_NIL ) { fprintf( stderr, "Referenced tag (%s) not found.\n", obj ); return( 0 ); }
	
	/* get the bounding box of guidep.. */
	guidex1 = EIgetd( guidep, "", "*/bb", &len );
	if( len != 4 ) { fprintf( stderr, "Referenced object (%s) has bad bb, len=%d.\n", obj, len ); return( 0 ); }
	}
Eparse_alex( alex, guidex1, &pos, 'v' );
if( side[0] == 'B' ) trl_y = pos - *y1;
else if( side[0] == 'T' ) trl_y = pos - *y2;
else if( side[0] == 'C' ) trl_y = pos - (*y1 + ((*y2 - *y1)/2.0));

/* translate.. */
Emoveobj( p, trl_x, trl_y );

return( 1 );
}

/* ============================================ */
/* parse an alignment expression */
Eparse_alex( expr, x1, pos, dir )
char expr[];
double *x1;
double *pos;
char dir;
{
double *y1, *x2, *y2, ofs;
char side;

*pos = 0; ofs = 0;
y1 = x1 + 1; x2 = x1 + 2; y2 = x1 + 3;
side = expr[0];

if( strlen( expr ) > 1 ) ofs = atof( &expr[1] );

if( side == 'L' ) *pos = *x1 + ofs;
else if( side == 'R' ) *pos = *x2 + ofs;
else if( side == 'B' ) *pos = *y1 + ofs;
else if( side == 'T' ) *pos = *y2 + ofs;
else if( side == 'C' && dir == 'h' ) *pos = (*x1 + ((*x2 - *x1)/2.0)) + ofs;
else if( side == 'C' && dir == 'v' ) *pos = (*y1 + ((*y2 - *y1)/2.0)) + ofs;
}
SHAR_EOF
############################

echo src/arrow.c
cat << \SHAR_EOF > src/arrow.c
#include "elib.x"
#define DELT_THETA 0.25

/* Draws an arrow from (x1,y1) inches to (x2,y2) inches with point at (x1,y1).
   Uses the current line type, thickness, etc.
   The parameter r controls the length of the arrowhead in inches, and can be
   sent as 0.0 to use the default (0.2).  The parameter sh controls the shade 
   (0.0 to 1.0) of the arrowhead.
*/
   
Earrow( x1, y1, x2, y2, r, sh )
double x1, y1, x2, y2, r, sh;
{
double vx, vy, ax1, ay1, ax2, ay2, th0, th1, th2, atan();
vx = x2 - x1;
vy = y2 - y1;

th0 = atan( vy / vx );
th1 = th0 + DELT_THETA;
th2 = th0 - DELT_THETA;

if( r <= 0.0 ) r = 0.2;


if( x2 < x1 ) {
	ax1 = x2 + (r * cos( th1 ));
	ay1 = y2 + (r * sin( th1 ));
	ax2 = x2 + (r * cos( th2 ));
	ay2 = y2 + (r * sin( th2 ));
	}
else 	{
	ax1 = x2 - (r * cos( th1 ));
	ay1 = y2 - (r * sin( th1 ));
	ax2 = x2 - (r * cos( th2 ));
	ay2 = y2 - (r * sin( th2 ));
	}

Emov( x2, y2 );
Epath( ax1, ay1 );
Epath( ax2, ay2 );
Eshade( sh );
Emov( x1, y1 );
Elin( x2, y2 );
}
SHAR_EOF
############################

echo src/bigbuf.h
cat << \SHAR_EOF > src/bigbuf.h
#define BIGBUFSIZE 200000	/* max amount of text to be handled */  /* LIMIT */
#define LINEMAX 512		/* max length of a line of os command results */ /* LIMIT */
#define SELECTIONMAX 512	/* max length of a user response - */ /* LIMIT */

char Ebigbuf[ BIGBUFSIZE ];   /* text buffer */
char Ebuf[ LINEMAX ];		/* this must be able to hold a single line of
					command results */
SHAR_EOF
############################

echo src/block.c
cat << \SHAR_EOF > src/block.c
/* do a rectangle, with shading and/or outline */
#include "elib.x"

double Ebox_x1 = 0, Ebox_y1 = 0, Ebox_x2 = 0, Ebox_y2 = 0;

/* Eblock() - all coords in abs space */
Eblock( xlo, ylo, xhi, yhi, shade, outline )
double xlo, ylo, xhi, yhi, shade;
int outline;
{
if( shade >= 0 ) {
	Emov( xlo, ylo );
	Epath( xlo, yhi );
	Epath( xhi, yhi );
	Epath( xhi, ylo );
	Eshade( shade );
	}
if( outline ) {
	Emov( xlo, ylo );
	Elin( xlo, yhi );
	Elin( xhi, yhi );
	Elin( xhi, ylo );
	Elin( xlo, ylo );
	}
}

/* ========================================== */
/* Eblocku() - all coords in user space */
Eblocku( xlo, ylo, xhi, yhi, shade, outline )
double xlo, ylo, xhi, yhi, shade;
int outline;
{
double x1, y1, x2, y2;

x1 = Eax( xlo );
y1 = Eay( ylo );
x2 = Eax( xhi );
y2 = Eay( yhi );
Eblock( x1, y1, x2, y2, shade, outline );
}

/* ============================================== */
/* set last box */
Esetlastbox( x1, y1, x2, y2 )
double x1, y1, x2, y2;
{
Ebox_x1 = x1; Ebox_y1 = y1; Ebox_x2 = x2; Ebox_y2 = y2;
}
/* ============================================== */
/* get dimensions of most recently generated box.. */
Egetlastbox( x1, y1, x2, y2 )
double *x1, *y1, *x2, *y2;
{
*x1 = Ebox_x1; *y1 = Ebox_y1; *x2 = Ebox_x2; *y2 = Ebox_y2;
}

/* ============================================== */
/* Eblockdress - neat shadowing for rectangles */
Eblockdress( x1, y1, x2, y2, lowfrontshadow, hifrontshadow, fssiz, backshadow, bssiz )
double x1, y1, x2, y2;
double lowfrontshadow, hifrontshadow, fssiz, backshadow, bssiz;
{

if( lowfrontshadow >= 0.0 ) {
	Emov( x1, y1 ); Epath( x1+fssiz, y1+fssiz ); 
	Epath( x2-fssiz, y1+fssiz ); Epath( x2-fssiz, y2-fssiz ); 
	Epath( x2, y2 ); Epath( x2, y1 ); Eshade( lowfrontshadow );
	}
if( hifrontshadow >= 0.0 ) {
	Emov( x1, y1 ); Epath( x1+fssiz, y1+fssiz ); Epath( x1+fssiz, y2-fssiz );
	Epath( x2-fssiz, y2-fssiz ); Epath( x2, y2 ); Epath( x1, y2 ); Eshade( hifrontshadow );
	}

if( backshadow >= 0.0 ) {
	Ebbexempt( 1 ); /* make shadows not update bounding box so that centering is true.. */
        Eblock( x1+bssiz, y1-bssiz, x2+bssiz, y1, backshadow, 0 );
        Eblock( x2, y1-bssiz, x2+bssiz, y2-bssiz, backshadow, 0 );
	Ebbexempt( 0 );
	}
}
SHAR_EOF
############################

echo src/copa_api.c
cat << \SHAR_EOF > src/copa_api.c
/*
COPA 1.0 - gui control panel kit for shell, C, perl etc.  
*              **      **                              *
Copyright 1991-1996 by Stephen C. Grubb.

Permission is hereby granted to USE this software for free.
Permission is hereby granted to MODIFY and/or REDISTRIBUTE 
this software for free, provided that no monetary gain is 
realized, and all attached authorship and copyright notices 
are preserved.

Inclusion of any portion (or derivation) of this software, 
including ancillary files, in any commercial product is not 
allowed without prior written permission of the author.  

See also the file 'Copyright'. 
*/



/* API - all copa functions are here.  All elib calls are from here. */


#include "elib.h"
#include <ctype.h> /* for isspace() */

#define MAXSTACK 5	/* LIMIT */
#define NONE ".!none" 

static int window_exists = 0;
static char *nowin_msg = "No window: copa_start never run.";
static char tagbuf[40]; 
static char tinybuf[8];
static int  evkey = -1;  /* most recent key event.. */
static double evx = 0.0, evy = 0.0;  /* mouse location at most recent key/mouse event */
static int  evp = -1;	/* proc id of most recent mouse click which produced a selection */
static char errstring[80];
static int  curde = -1; /* the "current" data entry area.. */
static int  nlimit = 0;
static int  limlist[12];
static int  window_visible = 1;
static char panstack[MAXSTACK][21];    /* LIMIT (tag length)*/
static int npanstack = 0;
static int popmsg_exists = 0; /* 0 when a popmsg is not on the screen, 1 when is */
static char echotag[21] = "";  /* current mechanism being echoed to.. */
static char *bigbufp; 
static int holdrefresh = 0; /* if 1 dont do any 'genall's */

/* ========== COPA_WINDOW ============== */
/* Create display window.
 * If window already exists, do a resize (ignore new title). 
 */
/* copa_window( int win_x, int win_y, double win_w, double win_h, char *title, double bkclr ) */
copa_window( win_x, win_y, win_w, win_h, title, bkclr )
int win_x; 
int win_y; 
double win_w; 
double win_h; 
char *title; 
double bkclr;
{

if( win_w > 30.0 || win_h > 30.0 ) 
  return( cerr( 2003, "Window too large. Specify width/height in inches." ) );


/* if window already exists, update window size, pos, color, etc.. */
/* -1 can be sent for any of these parameters. -1 causes the current value
	to remain in effect. */
if( window_exists ) {
	copa_resize( win_x, win_y, win_w, win_h, bkclr );
	return( 0 );
	}

/* this goes here because -1 is allowed for win size when window already exists.. */
if( win_w < 1.0 || win_h < 1.0 ) 
  return( cerr( 2002, "Window too small. Specify width/height in inches.", "" ) );

Einitall( title, 'x', win_w, win_h, win_x, win_y ); 

if( bkclr < 0.0 || bkclr > 1.0 ) bkclr = 1.0;
Eseteraseshade( bkclr );
Ebkcolor0 = bkclr; /* remember original color.. */

/* we need to do the align and gen here because copa_load may, in theory, not ever be called */
/* this may change though.. */
/* align all preset mechanisms.. */
Ealignall();
/* display anything that's visible (probably just window background) */
/* Eclr(); */
Egenall();

window_exists = 1;
return( 0 );
}
/* =========== COPA_RESIZE ===================== */
/* Resize or move window.. */
/* copa_resize( int win_x, int win_y, double win_w, double win_h, double bkclr ) */
copa_resize( win_x, win_y, win_w, win_h, bkclr )
int win_x;
int win_y;
double win_w; 
double win_h; 
double bkclr;
{
int stat;
Eresize( win_w, win_h, win_x, win_y );
Eflush();
Eusleep( E_WAITFOR_WM ); /* unknown problem - need to wait for window manager.. */
if( bkclr >= 0 )Eseteraseshade( bkclr );
Ealignall();
if( !holdrefresh) Egenall();
return( 0 );
}

/* =========== COPA_DISPLAY ======================== */
/* Execute various actions on the display window. */
/* copa_display( char *action ) */
copa_display( action )
char *action;
{
if( strcmp( action, "disappear" )==0 ) 
	{ Ewindisappear(); window_visible = 0; return( 0 ); }

else if( strcmp( action, "appear" )==0 ) {
	Ewinappear(); 
	window_visible = 1; 
	Eflush(); 
	Eusleep( E_WAITFOR_WM );  /* unknown problem - need to wait for window manager.. */
	/* Eclr(); */ 
	if( !holdrefresh ) Egenall(); 
	return( 0 ); 
	}

else if( strcmp( action, "refresh" )==0 ) 
	{ /* Eclr(); */ Egenall(); holdrefresh = 0; return( 0 ); }

else if( strncmp( action, "regen", 5 )==0 ) 
	{ Ealignall(); Eclr(); holdrefresh = 0; Egenall(); return( 0 ); }

else if( strcmp( action, "holdrefresh" )==0 ) {
	holdrefresh = 1;
	return( 0 );
	}
else if( strcmp( action, "dump" )==0 ) {
	EIwriteall( "copadump.pan" , 3 ); /* save everything except presets */
	return( 0 );
	}
}

/* =========== COPA_POP =============== */
/* copa_pop( char *msg, char *choices, char *response ) */
copa_pop( msg, choices, response )
char *msg;
char *choices;
char *response;
{
int status;
if( strlen( choices ) < 1 ) return( cerr( 2026, "No buttons specified","" ) );
status = copa_fpopup( "b", msg, choices, response, "" );
return( status );
}
/* =========== COPA_POPLIST =============== */
/* copa_poplist( char *msg, char *choices, char *buttons, char *response ) */
copa_poplist( msg, choices, buttons, response )
char *msg;
char *choices; 
char *buttons;
char *response;
{
int status;
if( strlen( choices ) < 1 ) return( cerr( 2027, "No selection list specified","" ) );
status = copa_fpopup( "l", msg, choices, response, buttons );
return( status );
}
/* =========== COPA_POPENTRY =============== */
/* copa_popentry( char *msg, char *def, int len, char *response ) */
copa_popentry( msg, def, len, response )
char *msg;
char *def;
int len;
char *response;
{
int status;
char parm[10];
sprintf( parm, "%d", len );

status = copa_fpopup( "d", msg, def, response, parm );
return( status );
}
/* =========== COPA_POPMSG =============== */
/* copa_popmsg( char *msg, char *buttons ) */
copa_popmsg( msg, buttons )
char *msg;
char *buttons;
{
int status;
status = copa_fpopup( "m", msg, buttons );
popmsg_exists = 1;
return( status );
}
/* ============ COPA_POPCLEAR ============ */
copa_popclear()
{
int status;
status = copa_fpopup( "c" );
popmsg_exists = 0;
return( status );
}

/* ============= COPA_FPOPUP (internal) ========== */
/* full popup (popup with various options).. */
/* (central point where popup prep/cleanup can be done in one place) */
static int
/* copa_fpopup( char *mectype, char *msg, char *choices, char *response, char *parm ) */
copa_fpopup( mectype, msg, choices, response, parm )
char *mectype;
char *msg;
char *choices;
char *response;
char *parm;
{
int status;
int pop;
if( !window_exists ) return( cerr( 2003, nowin_msg, "" ) );
pop = 0;
if( !window_visible ) {
	pop = 1;
	Ewinappear();
	}
if( mectype[0] == 'b' ) status = copa_btnpop( msg, choices, response );
else if( mectype[0] == 'd' ) status = copa_depop( msg, choices, parm, response );
else if( mectype[0] == 'l' ) status = copa_lbpop( msg, choices, parm, response );
else if( mectype[0] == 'm' ) { status = copa_mopop( msg, choices ); return( 0 ); }
else if( mectype[0] == 'c' ) status = copa_clpop();

if( status == 2100 ) return( cerr( 2100, "presets.pan file not loaded.", "" ) );
if( pop ) { Ewindisappear(); return( 0 ); }
if( mectype[0] != 'c' ) {
	if( all_whitespace( response ) ) strcpy( response, NONE );
	}
/* Eclr(); */
if( !holdrefresh ) Egenall(); /* restore current contents */
Eflush();
return( 0 );
}
/* =========== COPA_PANLOAD ============ */
/* copa_panload( char *fnm, char *tag ) */
copa_panload( fnm, tag )
char *fnm;
char *tag;
{
int status;
status = copa_panel( "load", fnm, tag );
return( status );
}

/* =========== COPA_PANUSE ============ */
copa_panuse( tag )
char *tag;
{
int status;
status = copa_panel( "use", "", tag );
return( status );
}

/* =========== COPA_PANADD ============= */
copa_panadd( fnm )
char *fnm;
{
int stat;
stat = copa_load( fnm ); /* load */
Ealignall(); 
if( !holdrefresh )Egenall();
return( stat );
}


/* =========== COPA_PANQUIT ============ */
copa_panquit( )
{
int status;
status = copa_panel( "return", "", "" );
return( status );
}

/* =========== COPA_PANEL (internal) =============== */
/* Control panel management (called by one of the above copa_pan* routines) 
   act can be: 
	load = load a new copy from the pan file
	use  = use existing panel (in its current state) if found, otherwise load a new one
	return = save current panel, reload previous panel, if any.
 */
static int
/* copa_panel( char *act, char *fnm, char *tag ) */
copa_panel( act, fnm, tag )
char *act;
char *fnm;
char *tag;
{
char buf[120];
int stat;
if( act[0] == 'r' ) { /* return */
	if( npanstack < 1 ) return( cerr( 2015, "warning, mismatched panquit", "" ) ); 

	/* save current panel in its current state.. */
	sprintf( buf, "%s/copa%05d%s", E_TMPDIR, getpid(), panstack[ npanstack-1 ] );
	EIwriteall( buf, 2 ); /* save everything, including presets */

	if( npanstack == 1 ) {  /* restore to nothing (except presets) */
		npanstack--;
		EIclear(); 
		Eload_presets(); /* since there was nothing else there.. */
		}
	else if( npanstack > 1 ) {  /* restore to previous panel (and presets) */
		npanstack--;
		EIclear(); 
		sprintf( buf, "%s/copa%05d%s", E_TMPDIR, getpid(), panstack[ npanstack-1 ] );
		/* read tmp file.. */
		stat = EIreaduserlist( buf );
		if( stat != 1 ) return( cerr( 2018, "Cannot restore previous panel", buf ) );
		}
	Eclr(); 
	if( !holdrefresh )Egenall();
	return( 0 );
	}

/* load or use... */
if( strlen( tag ) < 1 ) return( cerr( 2014, "copa panel: invalid tag", fnm ));

/* if there's an existing panel, write out current control panel in /tmp.. */
if( npanstack > 0 ) {
	sprintf( buf, "%s/copa%05d%s", E_TMPDIR, getpid(), panstack[ npanstack-1 ] );
	EIwriteall( buf, 2 ); /* save everything, including presets */
	EIclear(); 
	}

/* make sure there is room in the stack..*/
if( npanstack >= MAXSTACK-1 ) return( cerr( 2019, "Max panel nesting depth exceeded.", tag ) );

/* add tag to stack */
/* see if we're currently using it.. then just return.. */
if( strcmp( tag, panstack[ npanstack-1 ] )==0 ) return( 0 ); /* its already the
								current panel */
strncpy( panstack[ npanstack ], tag, 20 ); panstack[ npanstack ][20] = '\0';
npanstack++;

if( act[0] == 'l' ) {
	if( npanstack > 1 )Eload_presets(); /* get presets.. (scg 1-23-96) */
	stat = copa_load( fnm ); /* load */
	Ealignall(); 
	/* Eclr(); */  
	if( !holdrefresh )Egenall();
	return( stat );
	}
	
else if( act[0] == 'u' ) {    /* use */
	/* don't need to get presets; they were written out with tmp file.. */
	sprintf( buf, "%s/copa%05d%s", E_TMPDIR, getpid(), tag );
	/* read tmp file.. */
	stat = EIreaduserlist( buf );
	/* if tmp file doesn't exist, return error */
	if( stat != 1 ) return( cerr( 2016, "copa panuse: panel hasn't been loaded yet", tag ) );

	/* Eclr(); */  
	if( !holdrefresh )Egenall();
	return( 0 );
	}
}

/* =========== COPA_LOAD (internal, used by copa_panel) ============== */
static int
copa_load( fnm )
char *fnm;
{
int stat;
int ip;
int nde, firstde;
char fullfnm[100], *cf, *getenv();
FILE *fp;

/* locate file.. */
/* first check local directory.. */
strcpy( fullfnm, fnm );
fp = fopen( fnm, "r" );
if( fp == NULL ) {
	/* now check COPA_FILES directory.. */
	cf = getenv( "COPA_FILES" );
	if( cf != NULL && strlen( cf ) > 0 ) { 
		sprintf( fullfnm, "%s/%s", cf, fnm ); 
		fp = fopen( fullfnm, "r" ); 
		}
	if( fp == NULL ) {
		/* now check COPA_HOME directory.. */
		cf = getenv( "COPA_HOME" );
		if( cf != NULL  && strlen( cf ) > 0 ) {
			sprintf( fullfnm, "%s/%s", cf, fnm );
			fp = fopen( fullfnm, "r" );
			}
		if( fp == NULL ) return( cerr( 2011, "Control panel def file not found.", fnm ) );
		}
	}
fclose( fp );

/* read the file.. */
stat = EIreaduserlist( fullfnm );
if( stat != 1 ) cerr( 2004, "Error in control file.", "" );


count_de( &nde, &firstde ); /* get info on visible de areas.. added scg 12-7-95 */
if( nde == 1 ) EImodattr( firstde, "", "active", "x" ); /* make cursor dark */

return( 0 );
}


/* ============ COPA_TEXT - THIS VERSION USED BY C API ONLY ======== */
/* NOTE Shell "copa text" functionality is in cli.c and srv.c        */
/* capture text + results of any embedded command into bigbuf;
   then update the text attribute of the given mechanism. */

/* copa_text( char *tag, char *txt ) */
copa_text( tag, txt )
char *tag;
char *txt;
{
int i;
char *c;
char *copa_txt();
int stat;
char *s, *copa_fillbuf();

if( !window_exists ) return( cerr( 2003, nowin_msg, "" ) );

/* if this is the server, all command exansion is done by the client..
   so don't do it here.. */
if( !Eservermode ) s = copa_fillbuf( txt, 0 );
else s = txt;
stat = update_zood( tag, "text", s );
if( stat != 0 ) return( cerr( 2020, "Internal update error.", tag ) );
if( tag[0] != '_' ) redraw( tag ); /* don't redraw for popups.. */
return( 0 );
}

/* =========== COPA_ECHO (used by C API only) =========================== */

copa_echo( txt )
char *txt;
{
int stat;
char *copa_fillbuf();

if( !window_exists ) return( cerr( 2003, nowin_msg, "" ) );

if( strncmp( txt, ".!begin", 7 )==0 ) {   /* starting a new run.. */
	echotag[0] = '\0';
	sscanf( txt, "%*s %s", echotag );
	if( strlen( echotag ) < 1 )
		return( cerr( 2022, "copa_echo: No tag found with .!begin", "" ));
	if( EItaglookup( echotag, E_NIL) < 0 )
		return( cerr( 2024, "copa_echo: invalid mechanism tag", echotag ) );
	copa_fillbuf( "", 1 ); /* initialize buffer.. */
	return( 0 );
	}

else if( strcmp( txt, ".!end" )==0 ) {
	stat = update_zood( echotag, "text", bigbufp );
	if( echotag[0] != '_' ) redraw( echotag ); /* don't redraw for popups.. */
	return( 0 );
	}
	
else	{
	if( strlen( echotag ) < 1 )
		return( cerr( 2023, "copa_echo: a mechanism tag needs to be specified using .!begin","" ));
	bigbufp = copa_fillbuf( txt, 2 );
	return( 0 );
	}
}

/* =========== COPA_GETENTRY ======================= */
/* Activate the named data entry area and get a user response */
copa_getentry( tag, response )
char *tag;
char *response;
{
int p;
p = Egetid( tag );
if( p < 0 || !visible( p ) ) return( cerr( 2029, "getentry: bad mechanism tag", "" ) );
else if( strcmp( EIgetobjname( p ) , "dataentry" )!=0 )
	return( cerr( 2030, "getentry: may be used for dataentry mechanisms only", "" ) );

Eexec( p, 0.0, 0.0, E_MOUSE_LEFT, "" ); /* activate it.. */

evp = p;

/* get the terminating event (could be used by copa rinfo).. */
Eretrievekey( &evx, &evy, &evkey );

if( all_whitespace( Eselection ) ) strcpy( response, NONE );
else strcpy( response, Eselection );
return( 0 );
}

/* =========== COPA_GET  =========================== */
/* Get user response - normal mode */
copa_get( response )
char *response;
{
int stat;
stat = copa_mget( "standard", response );
return( stat );
}


/* =========== COPA_MGET ============================ */
/* Get user response - various input modes.
   Args: 
     rtyp = response type, one of the following:
	s(tandard) = Standard mode, suitable for most situations.  Receive results 
		produced by mouse click or data entry.
		If there is only one visible data entry area, all key presses
		will be captured by it.  If there is more than one data entry
		area on the screen, the "current" one (see below) will receive 
		keystrokes by default.  Other dataentry areas must be selected 
		before typing (see below).  In any case, keystrokes which aren't 
		captured in a data entry area are ignored.
	k(eys) = Intercept and return all keystrokes.  Key presses will not
		be received by data entry area(s).  Ignore mouse selections. 
	a(ny)  = Receive results produced by mouse click or data entry. 
		For keystrokes to be captured by a dataentry area, the
		dataentry area must be selected before typing (see below). 
		Keystrokes not captured by a dataentry area are returned.
		Mouse clicks which do not produce results are ignored.
	m(ousepos) = produce only a string containing the tag of the mechanism
		the mouse was in (or ".!none" ) when mouse click or keystroke
		occurs.  get_uinfo can be subsequently called to get x and y 
		location info.
	n(onblocking) = same as standard mode, except that mget will not wait
		for mouse click or data entry; if neither of these has occurred,
		mget when used in this mode will return immediately, with
		response set to ".!none".

    NOTE: The "current" data entry area is generally the one most recently 
	used.  If none have yet been used, it is the first-defined one which
	is visible.

    NOTE: A data entry area may be "selected" by the user clicking on it 
	with mouse.

    NOTE: Data entry responses of zero length or which contain only
	white-space characters are returned as ".!none", to avoid problems 
	in shell scripts.

    NOTE: Keystroke representation: see keyrep() below.

*/
/* copa_mget( char *rtyp, char *response ) */
copa_mget( rtyp, response )
char *rtyp;
char *response;
{
int p, len, bp;
char *keyrep();
int nde, firstde;  /* # de visible areas, proc id of first-defined de area */
int status;
char *next;
char buf[256];

/* evkey = key which was pressed 'A'=A, or mouse button 1001=left 1002=mid 1003=right */

if( !window_exists ) return( cerr( 2003, nowin_msg, "" ) );

bp = EItaglookup( "_POPB1", E_NIL); /* for popmsg */

strcpy( Eselection, NONE );
evp = -1;
while( 1 ) {

	if( rtyp[0] == 'n' ) {
		Easync(); /* check for events; if there is one EEvent will be set to non-zero */
		if( EEvent == 0 ) { /* no mouse click or data entry has occurred */
			strcpy( response, NONE );
			return( 0 );
			}
		else	{
			evx = EEventx;
			evy = EEventy;
			evkey = EEvent;
			EEvent = 0; /* reset */
			}
		}

	else Egetkey( &evx, &evy, &evkey );

	/* keys mode-- intercept keys */
	if( rtyp[0] == 'k' ) {
		if( evkey < 1000 ) {
			sprintf( response, "%s", keyrep( evkey ) ); /* key representation.. */
			return( 0 );
			}
		else continue;
		}

	/* mousepos mode-- */
	else if( rtyp[0] == 'm' ) {
		p = Ewhichobj( evx, evy );
		if( p < 0 ) strcpy( response, NONE );
		else strcpy( response, EIgetc( p, "", "*/tag", &len ) );
		if( all_whitespace( response ) ) strcpy( response, NONE ); /* for safety */
		return( 0 );
		}

	/* normal mode-- */
	else if( rtyp[0] == 's' || rtyp[0] == 'n' || rtyp[0] == 'a' ) {

		/* mouse click -- get results.. */
		if( evkey > 1000 ) {  
			p = Ewhichobj( evx, evy );
			if( p < 0 ) continue;
			if( rtyp[0] == 'n' && popmsg_exists && p != bp ) {
				strcpy( response, NONE );
				return( 0 );
				}
			if( !popmsg_exists && offlimits( p ) ) continue;
        		Eexec( p, evx, evy, evkey, "" );
        		if( strcmp( Eselection, NONE ) == 0 ) continue;
			}

		/* key press */
		else	{
			if( popmsg_exists ) {
				strcpy( response, NONE );
				return( 0 );
				}
			if( rtyp[0] == 'a' ) {  /* any-- just return key */
				sprintf( response, "%s", keyrep( evkey ) );
				return( 0 );
				}
			/* count_de( &nde, &firstde ); */ /* get info on visible de areas.. */
			if( nde >= 1 ) {
				if( nde == 1 ) p = curde = firstde; 
				else if( curde < 0 || !visible( curde ) ) p = curde = firstde;
				else p = curde;
				/* The following Eexec call will get its own keystrokes
				   and return the ascii of the key which terminated it  */
				status = Eexec( p, evx, evy, evkey, "" );

				/* update curde, based on "next" de attribute, etc. //
				/*
				 * if( nde > 1 && status != 27 ) { // look for next //
 			         *     next = EIgetc( p, "", "next", &len );
				 *     if( len > 0 ) {
				 *	  curde = Egetid( next );
				 *	  }
				 *     // else curde remains the same.. //
				 *     }
				 */
				}
			else if( nde < 1 ) continue;
			}
		/* set up for secondary response.. */
		if( strcmp( EIgetobjname( p ), "dataentry" )==0 ) {
			/* get the terminating event of the dataentry area for rinfo.. */
			Eretrievekey( &evx, &evy, &evkey );
			} 
		evp = p;
		if( sscanf( Eselection, "%s", buf ) > 0 ) strcpy( response, Eselection );
		else strcpy( response, NONE );
		return( 0 );
		} 
	}
}

/* ============= COPA_RLIMIT =============================== */
/* limit input to certain mechanism(s) */
copa_rlimit( meclist )
char *meclist;
{
int i, p;
char *tok;
if( strcmp( meclist, ".!all" )==0 || strlen( meclist ) < 1 ) nlimit = 0;
else	{
	for( i = 0; i < strlen( meclist ); i++ ) if( meclist[i] == ',' ) meclist[i] = ' ';
	for( i = 0; i < strlen( meclist ); ) {
		tok = Egetok( meclist, &i );
		p = Egetid( tok );
		if( p < 0 ) cerr( 2008, "copa_rlimit: tag not defined - ignored.", tok );
		limlist[ nlimit++ ] = p;
		}
	}
return( 0 );
}


/* ============= COPA_RINFO ============================ */
/* return requested info related to previous selection/mouse click . */
/* copa_rinfo( char *inftyp, char *results ) */
copa_rinfo( inftyp, results )
char *inftyp,  *results;
{
int len;
char *keyrep();
int ip;

if( !window_exists ) return( cerr( 2003, nowin_msg, "" ) );
if( strcmp( inftyp, "tag" )==0 ) {
	if( evp < 0 ) strcpy( results, NONE );
	else strcpy( results, EIgetc( evp, "", "*/tag", &len ) );
	if( all_whitespace( results ) ) strcpy( results, NONE ); /* safety */
	return( 0 );
	}
else if( strcmp( inftyp, "mectype" )==0 ) {
	if( evp < 0 ) strcpy( results, NONE );
	else strcpy( results, EIgetobjname( evp ) );
	return( 0 );
	}

else if( strcmp( inftyp, "secondary_tag" ) == 0 ) {
	results[0] = '\0';
	if( evp < 0 ); 
	else if( strcmp( EIgetobjname( evp ), "dataentry" )==0 && evkey >= 1000 ) {
		ip = Ewhichobj( evx, evy );
		if( evp >= 0 ) strcpy( results, EIgetc( ip, "", "*/tag", &len ) );
		}
	if( all_whitespace( results ) ) strcpy( results, NONE );
	return( 0 );
	}

else if( strcmp( inftyp, "secondary_result" ) == 0 ) {
	results[0] = '\0';
	if( evp < 0 );
	else if( strcmp( EIgetobjname( evp ), "dataentry" ) ==0 && evkey >= 1000 ) {
		ip = Ewhichobj( evx, evy );
		if( ip >= 0 && strcmp( EIgetobjname( ip ), "dataentry" )!= 0 ) {
			Eexec( ip, evx, evy, evkey, "" );
			strcpy( results, Eselection );
			}
		}
	if( all_whitespace( results ) ) strcpy( results, NONE );
	return( 0 );
	}

else if( strcmp( inftyp, "key" )==0 ) {
	if( evkey < 0 ) strcpy( results, NONE );
	else sprintf( results, "%s", keyrep( evkey ) ); 
	return( 0 );
	}
else if( strcmp( inftyp, "keytype" )==0 ) {
	if( evkey < 0 ) strcpy( results, NONE );
	else if( evkey >= 1000 ) strcpy( results, "mouse" );
	else strcpy( results, "key" );
	return( 0 );
	}
else if( strcmp( inftyp, "x" )==0 ) {
	sprintf( results, "%g", evx );
	return( 0 );
	}
else if( strcmp( inftyp, "y" )==0 ) {
	sprintf( results, "%g", evy );
	return( 0 );
	}

return( cerr( 2007, "Unrecognized parameter in copa_rinfo.", inftyp ) );
}
/* ============= COPA_SETVALUE =========================== */
copa_setvalue( tag, value )
char *tag, *value;
{
char buf[ E_SELECTION_LEN ];
char intag[40];
int stat, nt;
FILE *fp;
if( strcmp( tag, ".!file" )==0 ) {
	fp = fopen( value, "r" );
	if( fp == NULL ) return( cerr( 2033, "Cannot open tag/values file", value ) );
	while( fgets( buf, E_SELECTION_LEN-1, fp ) != NULL ) {
		buf[ strlen( buf ) - 1 ] = '\0'; /* rm newline */
		nt = sscanf( buf, "%s", intag ); 
		if( nt < 1 ) continue;
		if( intag[0] == '#' ) continue;
		stat = copa_setsel( intag, &buf[ strlen( intag ) + 1 ] );
		if( stat != 0 ) 
			fprintf( stderr, "Warning, setvalue failed for a data line (%s)\n", buf );
		}
	fclose( fp );
	if( !holdrefresh ) Egenall();
	return( 0 );
	}
stat = copa_setsel( tag, value );
redraw( tag );
return( stat );
}

/* ============= COPA_GETVALUE =========================== */
copa_getvalue( tag, results )
char *tag;
char *results;
{
int ip, len;
char *typ, *outtag, *val;

if( strcmp( tag, ".!all" )==0 ) {   /* do a tag/value dump.. */
	EIgetnextobj( E_AT_BEGINNING, 0 );
	results[0] = '\0';
	while( 1 ) {
        	ip = EIgetnextobj( E_NEXT, 0 );
        	if( ip < 0 ) break;
		if( strlen( results ) >= E_SELECTION_LEN - 10 )
			return( cerr( 2031, "rinfo allmecs - results too long", "" ) );
		typ = EIgetobjname( ip );
		if( strcmp( typ, "textb" )==0 ||
		    strcmp( typ, "button" )==0 ||
		    strcmp( typ, "slider" )==0 ||
		    strcmp( typ, "dataentry" )==0 ) {
			outtag = EIgetc( ip, "", "*/tag", &len );
			if( outtag[0] == '_' ) continue; /* don't do popups */
			if( strlen( outtag ) < 1 ) continue; /* null tag.. */
			if( strlen( results ) + len >= E_SELECTION_LEN - 3 )
			  return( cerr( 2031, "rinfo allmecs - results too long", "" ) );
			Eaddb( results, outtag );
			Eaddb( results, " " );
			val = EIgetc( ip, "", "pick/value", &len );
			if( strlen( results ) + len >= E_SELECTION_LEN - 3 )
			  return( cerr( 2031, "rinfo allmecs - results too long", "" ) );
		
			Eaddb( results, val );
			Eaddb( results, "\n" );
			}
		}
	EIgetnextobj( E_DONE, 0 );
	if( all_whitespace( results ) ) strcpy( results, NONE );
	return( 0 );
	}
else	{
	results[0] = '\0';
	ip = Egetid( tag );
	if( ip < 0 ) return( cerr( 2032, "Invalid tag", tag ) );
	strcpy( results, EIgetc( ip, "", "pick/value", &len ) );
	if( all_whitespace( results ) ) strcpy( results, NONE );
	return( 0 );
	}
}

/* ============= COPA_SETMEC ============================= */
/* Set a characteristic of a mechanism. */
/* copa_setmec( char *tag, char *attr, char *value ) */
copa_setmec( tag, attr, value )
char *tag, *attr, *value;
{
int status;
char buf[40];
if( strcmp( attr, "value" )==0) strcpy( buf, "pick/value" );
else strcpy( buf, attr );
status = update_zood( tag, buf, value );
if( status < 0 ) return( cerr( 2013, "setmec failed.", buf ) );
redraw( tag );
return( 0 );
}

/* ============= COPA_GETMEC ============================= */
/* Get a characteristic of a mechanism. */
/* copa_getmec( char *tag, char *attr, char *value ) */
copa_getmec( tag, attr, value )
char *tag, *attr, *value;
{
int len;
char buf[40];
int stat;
strcpy( buf, attr );
stat = EIget( value, Egetid( tag ), "", buf );
if( stat != 1 ) return( cerr( 2021, "No mechanism by this name has been defined.", tag ) );
if( all_whitespace( value ) ) strcpy( value, NONE );
return( 0 );
}

/* ============= COPA_PS ============================== */
/* THIS DOESNT WORK WELL FOR CONTROL PANELS  */
/* Do a vector EPS representation of current copa screen. 
   Place it in file fnm ("-" = stdout ).
   Use paper orientation: "L" = landscape  "P" =portrait
 */ 
/* copa_ps( char *name, char *fnm, char *paperway ) */
copa_ps( name, fnm, paperway )
char *name, *fnm, *paperway;
{
Eprintall( name, fnm, paperway[0] );
return( 0 );
}

/* ============= COPA_QUIT ============================ */
copa_quit()
{
char buf[120];
/* remove any tmp files */
sprintf( buf, "rm %s/copa%05d* 2>/dev/null", E_TMPDIR, getpid() );
system( buf );
return( 0 );
}


/* =============== INTERNAL ROUTINES -================= */

/* ============= KEYREP (internal) ============= */
/* Does translation on non-printable and white-space characters.

Printable non-whitespace keystrokes are represented as a string 
containing the character.  All others are represented as a string 
containing ".!char", followed by the character's decimal ascii value, 
e.g.  space = ".!char32".  
Mouse button representations are: ".!mouseleft", ".!mousemiddle" 
	and ".!mouseright".
*/

		
static char *
keyrep( key )
int key;
{

/*       enter      space       backsp      del           esc          tab  */
if( key == 1001 ) sprintf( tinybuf, ".!mouseleft" );
else if( key == 1002 ) sprintf( tinybuf, ".!mousemiddle" );
else if( key == 1003 ) sprintf( tinybuf, ".!mouseright" );
else if( key == 13 || key == 32 || key == 8 || key == 127 || key == 27 || key == '\t'  
	|| ! isprint( key ) ) {
	sprintf( tinybuf, ".!char%d", key );
	return( tinybuf );
	}
else sprintf( tinybuf, "%c", key );

return( tinybuf );
}
/* ============= UPDATE_ZOOD (internal) ============= */
/* Update mechanisms database */
static int
/* update_zood( char *tag, char *attrib, char *value ) */
update_zood( tag, attrib, value )
char *tag, *attrib, *value;
{
int p, status;
p = Egetid( tag );
if( p < 0 ) return( cerr( 2025, "Bad mechanism tag", tag ) );
Enulloutbb( p );
status = EImodattr( p, "", attrib, value );
if( status < 1 ) return( -1 );
updatehooks( p, attrib ); /* check dependencies */
return( 0 );
}


/* ============= REDRAW (internal) ==================== */
/* Redraw a mechanism. */
static int
redraw( tag )
char *tag;
{
int p;
p = Egetid( tag );
Enulloutbb( p );
Egen( p );
return( 0 );
}
/* ============= COUNT_DE ========================= */
/* count how many data entry mechanisms exist and are visible */
static int
/* count_de( int *nde, int *firstde ) */
count_de( nde, firstde )
int *nde, *firstde;
{
int ip, len;
char *c;

*nde = 0; *firstde = -1;
EIgetnextobj( E_AT_BEGINNING, 0 );
while( 1 ) {
        ip = EIgetnextobj( E_NEXT, 0 );
        if( ip < 0 ) break;

	/* if limits are in effect and ip cannot respond, don't include it.. */
	if( offlimits( ip ) ) continue;
	if( strcmp( EIgetobjname( ip ) , "dataentry" )==0 ) {
		c = EIgetc( ip, "", "*/display", &len );
		if( strlen( c ) > 0 ) {
			/* we've found one.. */
			if( *nde == 0 ) *firstde = ip;
			(*nde) ++;
			}
		}
        }
EIgetnextobj( E_DONE, 0 );
return( 0 );
}

/* ============= OFFLIMITS ========================= */
/* see if a given proc id is off limits (not responsive) to user.. */
/* return 1 if the proc is not responsive; 0 if it is responsive */
static int
offlimits( p )
int p;
{
int i;
if( nlimit < 1 ) return( 0 );
for( i = 0; i < nlimit; i++ ) {
	if( p == limlist[i] ) return( 0 );
	}
return( 1 );
}


/* ============= VISIBLE ========================= */
static int
visible( p )
int p;
{
int len;
char *c;

c = EIgetc( p, "", "*/display", &len );
if( strlen( c ) > 0 ) return( 1 );
else return( 0 );
}

/* ============= UPDATEHOOKS ========================= */
static int
/* updatehooks( int p, char *attr ) */
updatehooks( p, attr )
int p;
char *attr;
{
char *class;
class = EIgetobjname( p );
 
/* If text in a text box changes, the textbox auto-scaling may need to be rerun.. */
/* Or if text box becomes scrollable/not scrollable, scrolling control may need to be
   added/removed. */
if( strcmp( class, "textb" )== 0  && strcmp( attr, "text" )==0 ) {
        Eexec( p, 0.0, 0.0, E_MESSAGE, "REINIT" );
#ifdef PLOT
        EPrefreshplotdata( p ); /* notifiy ipl that the plot data may have changed. */
#endif
        }
}

/* ============= CERR ========================= */
static int
/* cerr( int errno, char *msg, char *parm ) */
cerr( errno, msg, parm )
int errno;
char *msg;
char *parm;
{
return( Eerrmsg( errno, msg, parm ) );
}

/* ============= ALL_WHITESPACE ================ */
/* check string, return 1 if it's all white space or 0 length.  Return 0 otherwise */
static int
all_whitespace( s )
char *s;
{
int i;
for( i = 0; i < strlen( s ); i++ ) {
	if( s[i] == ' ' || s[i] == '\t' || s[i] == '\n' );
	else return( 0 );
	}
return( 1 );
}
SHAR_EOF
############################

echo src/copa_button.c
cat << \SHAR_EOF > src/copa_button.c
/*
COPA 1.0 - gui control panel kit for shell, C, perl etc.  
*              **      **                              *
Copyright 1991-1996 by Stephen C. Grubb.

Permission is hereby granted to USE this software for free.
Permission is hereby granted to MODIFY and/or REDISTRIBUTE 
this software for free, provided that no monetary gain is 
realized, and all attached authorship and copyright notices 
are preserved.

Inclusion of any portion (or derivation) of this software, 
including ancillary files, in any commercial product is not 
allowed without prior written permission of the author.  

See also the file 'Copyright'. 
*/


/* for generating a single button. */

#include "elib.x"

Ebutton( txt, posx, posy, margin, color, width )
char txt[];
double posx, posy;
double margin;
double color;
double width; /* explicit width, or -1.0 for auto (based on text).  margin additional. */
{
double x, y, w;
double x1, x2, y1, y2;

x = posx; y = posy;

if( width < 0 ) w = strlen( txt ) * Ecurtextwidth;
else w = width;
x1 = x - margin;
x2 = x + w + margin;
y1 = y  - margin;
y2 = y + Ecurtextheight + margin;
Eblock( x1, y1, x2, y2, color, 0 );
Esetlastbox( x1, y1, x2, y2 );

Emov( x + (w/2.0), y );
Ecentext( txt );
}



/* === The GEN routine ============ */
EAbutton( p, path )
int p;
char path[];
{
int i, j;
char newpath[80];
char *txt;
double *d1, *d2, *color, *margin, hilitecolor;
double posx, posy;
int len;
char buttonlabel[200]; /* LIMIT */
double x1, y1, x2, y2;
int ix;
double hzones[20];
char buf[ E_GPBUF ];
int *h, hselect;
double *width;

txt = EIgetc( p, path, "text", &len );
if( len < 1 ) return( 0 );

sprintf( newpath, "%s/text", path );
EAtext_props( p, newpath );

d1 = EIgetd( p, path, "position", &len ); d2 = d1; d2++;
if( len < 2 ) return( 0 );
else { posx = *d1; posy = *d2; }

margin = EIgetd( p, path, "box.margin", &len );
color = EIgetd( p, path, "box.color", &len );

width = EIgetd( p, path, "width", &len ); /* explicit width */
if( len < 1 ) *width = -1.0;

/* typ = EIgetc( p, path, "type", &len ); */
h = EIgeti( p, path, "pick/hselect", &len );   /* 0..n */
if( len > 0 ) hselect = *h;
else hselect = -1;


if( *color > 0.6 ) hilitecolor = 0.0; 
else hilitecolor = 1.0;

for( ix = 0, j = 0; ; j++ ) {
	hzones[j] = posx-(*margin);
	Egetchunk( buttonlabel, txt, &ix, "," );
	if( strlen( buttonlabel ) < 1 ) break;

	/* draw the currently selected button in reverse vid.*/
	if( j == hselect ) {  
		if( hilitecolor == 0.0 ) Esetdrawcolor( E_WHITE );
		else Esetdrawcolor( E_BLACK );
		Ebutton( buttonlabel, posx, posy, *margin, hilitecolor, *width );
		if( Ecurcolor == E_WHITE ) Esetdrawcolor( E_BLACK );
		else Esetdrawcolor( E_WHITE );
		EImodattr( p, "", "pick/value", buttonlabel );
		}
	else Ebutton( buttonlabel, posx, posy, *margin, *color, *width );

	EIgetc( p, path, "dress", &len );
	if( len > 0 ) {
       		sprintf( newpath, "%s/dress", path );
        	EArect_dress( p, newpath );
		}
	Egetlastbox( &x1, &y1, &x2, &y2 );
	posx = x2+(*margin);
	}

/* save the horizontal cuts.. */
buf[0] = '\0';
for( i = 0; i <= j; i++ ) sprintf( buf, "%s%g ", buf, hzones[i] ); /* portability? */
EImodattr( p, "", "pick/hzones", buf );
return( 1 );
}

/* ==== The EXEC routine ============= */
EEbutton( p, x, y, e, message )
int p;
double x, y;
int e;
char message[];
{
int i, j, len;
double *c, color;
double *d;
char buf[12];
char *sendmsg, *recip;
int recip_id;
double left, right;
char *txt;
int ix;
char buttonlabel[30];
int hselect;
char msg[80];
char *flashpick;
int unsel;
int *cursel;

/* allow mouse clicks and messages.. */
if( e < 1000 ) return( 0 );

if( e == E_MESSAGE && strcmp( message, "RESET" )==0 ) {
	EImodattr( p, "", "pick/hselect", "" );
        EImodattr( p, "", "pick/value", "" );
	return( 1 );
	}

txt = EIgetc( p, "", "text", &len );

c = EIgetd( p, "", "box.color", &len );
color = *c;
/* typ = EIgetc( p, "", "type", &len ); removed scg Nov 95 */


EIgetc( p, "", "unpick", &unsel ); /* scg */

/* see which button was pressed.. */
d = EIgetd( p, "", "pick/hzones", &len );
if( len < 1 ) return( 0 );

for( i = 0; i < len; i++ ) if( *(d+i) > x ) break;

hselect = i-1;
left = *(d+i);
right = *(d+i+1);

for( j = 0, ix = 0; j <= hselect; j++ )Egetchunk( buttonlabel, txt, &ix, "," );

cursel = EIgeti( p, "", "pick/hselect", &len ); /* scg */
if( len < 1 || *cursel != hselect ) {		/* scg */
	sprintf( buf, "%d", hselect );
	EImodattr( p, "", "pick/hselect", buf );
	EImodattr( p, "", "pick/value", buttonlabel ); 
	strcpy( Eselection, buttonlabel );
	}
else if( unsel ) { /* scg */
	Eexec( p, 0.0, 0.0, E_MESSAGE, "RESET" ); /* scg */
	Eselection[0] = '\0';
	}

/* send a message to other object(s) if requested */
sendmsg = EIgetc( p, "", "message", &len );
if( len > 0 ) {
	/* find the message corresponding to the button pressed.. */
	for( j = 0, ix = 0; j <= hselect; j++ )Egetchunk( msg, sendmsg, &ix, "," );
	/* process the message(s) */
	Eprocess_message( p, msg );
	}

Egen( p );

/* flash pick */
flashpick = EIgetc( p, "", "flashpick", &len );
if( len > 0 ) {
	Eflush();
	Eusleep( Eflashdelay );
	Eexec( p, 0.0, 0.0, E_MESSAGE, "RESET" );
	Egen( p );
	}

return( 1 );
} 
SHAR_EOF
############################

echo src/copa_cli.c
cat << \SHAR_EOF > src/copa_cli.c
/*
COPA 1.0 - gui control panel kit for shell, C, perl etc.  
*              **      **                              *
Copyright 1991-1996 by Stephen C. Grubb.

Permission is hereby granted to USE this software for free.
Permission is hereby granted to MODIFY and/or REDISTRIBUTE 
this software for free, provided that no monetary gain is 
realized, and all attached authorship and copyright notices 
are preserved.

Inclusion of any portion (or derivation) of this software, 
including ancillary files, in any commercial product is not 
allowed without prior written permission of the author.  

See also the file 'Copyright'. 
*/


/* CLI - capture command line arguments, marshall them into a
	record, and send record over command pipe.
	When results come back via results pipe, print them to stdout.

*/
#include <stdio.h>
#include <fcntl.h>

#include "bigbuf.h"

#define TMP_DIR "/usr/tmp"


main( argc, argv )
int argc;
char **argv;
{
char buf[SELECTIONMAX+1], *copa_pipe, compipe[80], resultpipe[80], *getenv();
int i, j, k;
int cfd, rfd, nbytes;
int stat;
char dc1[3], dc2[3];
int pos;
char *c, *expand_txt();
int noterm, predelim, nodelim, nopre, autonewline, forcedelim; /* for echo exception */
int len;
int timeout;
long elapsed;

sprintf( dc1, "%c", 17 );
sprintf( dc2, "%c", 18 );

if( argc < 2 ) {
	Eerrmsg( 50, "Usage: copa  command  [args]", "" );
	exit(1);
	}

/* open pipes */
copa_pipe = getenv( "COPA_PIPE" );
if( copa_pipe == NULL ) sprintf( buf, "%d", geteuid() );
else if( strlen( copa_pipe ) < 1 ) sprintf( buf, "%d", geteuid() );
else sprintf( buf, "%d%s", geteuid(), copa_pipe );
if( strlen( buf ) > 20 ) buf[20] = '\0'; /* truncate at length of 20 */
 
sprintf( compipe, "%s/copaC%s", TMP_DIR, buf );
sprintf( resultpipe, "%s/copaR%s", TMP_DIR, buf );


/* rfd = open( resultpipe, O_RDONLY | O_NONBLOCK ); */
rfd = open( resultpipe, O_RDONLY | O_NDELAY );
if( rfd == NULL ) {
	Eerrmsg( 51, "Client cannot open fifo", resultpipe );
	exit(1);
	}


/* open command pipe */
cfd = open( compipe, O_WRONLY );
if( cfd == NULL ) {
	Eerrmsg( 52, "Client cannot open fifo", compipe );
	exit(1);
	}

/* handle echo (special case)..  srv will see one command: 
	copa  echo  .!begin tag   text   .!end   */
noterm = 0; predelim = 0; nodelim = 0; nopre = 0; autonewline = 0; forcedelim = 0;
if( strcmp( argv[1], "echo" )==0 ) {
	if( strncmp( argv[2], ".!begin", 5 )==0 ) { noterm = 1; forcedelim = 1; }
	else if( strcmp( argv[2], ".!end" )==0 ) { predelim = 1; nopre = 1; }
	else	{ noterm = 1; nodelim = 1; nopre = 1; autonewline = 1; }
	}


/* write args (!commands within text args are expanded here then piped).. */
for( i = 0; i < argc; i++ ) {

	if( nopre && i < 2 ) continue; /* echo exception */

	/* there must be an argv[1] if we got this far.. */
	c = expand_txt( argv[1], i, argv[i] ); 

	/* convert 17 and 18 to 19.. */
	len = strlen( c );
	for( j = 0; j < len; j++ ) if( c[j] == 17 || c[j] == 18 ) c[j] = 19;
	
	/* fprintf( stderr, "Sending[%s]", c ); fflush( stderr ); */

	if( predelim )write( cfd, dc1, 1 ); /* echo exception */

	write( cfd, c, strlen( c ) );

	if( autonewline ) write( cfd, "\n", 1 ); /* echo exception */

	if( forcedelim ) write( cfd, dc1, 1 ); /* echo exception */
	else if( i < (argc-1) && !nodelim )write( cfd, dc1, 1 ); /* write arg delimiter */
	}

if( !noterm ) write( cfd, dc2, 1 ); /* write terminator */
close( cfd ); /* close command pipe */
if( noterm ) exit( 0 );

/* gather results */
if( argc >= 3 && strcmp( argv[2], "display" )==0 && strcmp( argv[3], "ping" )==0 ) {
	timeout = 1;
	elapsed = 0;
	}
else timeout = 0;

pos = 0;
while( 1 ) {
	nbytes = read( rfd, &buf[pos], SELECTIONMAX-(pos+1) );
	if( nbytes <= 0 ) {   /* sleep then try again.. */
		stat = Eusleep( 20000 ); /* 1/50th of a second */

		/* keep track of time for ping command */
		if( timeout ) {
			elapsed++;
			if( elapsed > 200 ) {
				printf( "noresponse\n" );
				exit(0);
				}
			}
		if( stat != 0 ) {
			sprintf( buf, "%d", stat );
			Eerrmsg( 54, "Client sleep error", buf );
			exit( 1 );
			}
		continue;
		}

	if( buf[ pos+(nbytes-1) ] != 18 ) { /* there's more to read for this record.. */
		pos += nbytes;
		nbytes = 0;
		if( pos > SELECTIONMAX-2 ) {
			Eerrmsg( 53, "warning: results too long.. truncated", "" );
			break;
			}
		continue;
		}
	break; /* we've gotten it all */
	}
buf[ pos+(nbytes-1) ] = '\0';


/* write results to stdout */
if( strcmp( buf, ".!error" )==0 ) {
	fprintf( stderr, "while executing command: " );
	for( i = 0; i < argc; i++ ) fprintf( stderr, "%s ", argv[i] );
	fprintf( stderr, "\n" );
	printf( ".!error\n" );
	exit(0);
	}
else if( strncmp( buf, ".!ok", 4 )==0 ) /* printf( "(%s)\n", buf ) */ ;

else printf( "%s\n", buf );

/* if this is a 'quit', remove the pipes.. */
if( strcmp( argv[1], "quit" )==0 ) {
	unlink( compipe );
	unlink( resultpipe );
	}

/* exit */
exit(0);
}
/* ========================== */
/* For situations where command expansion is allowed, do it.. */
static char *
/* expand_txt( char *com, int argi, char *arg ) */
expand_txt( com, argi, arg )
char *com;
int argi;
char *arg;
{
int i;
char *c;
char *copa_txt();
int full;
int stat;
int expand;
char *copa_fillbuf();

static char *s;

/* see if this is a situation where expansion is possible.. */
expand = 0;
if( strcmp( com, "text" )==0 && argi == 3 ) expand = 1;
else if( strncmp( com, "pop", 3 )==0 && argi == 2 ) expand = 1;
else if( strcmp( com, "poplist" )==0 && argi == 3 ) expand = 1;
else if( strcmp( com, "echo" )==0 && argi == 2 ) expand = 1;

if( !expand ) { /* just return pointer to original arg.. */
	return( arg );
	}

else s = copa_fillbuf( arg, 0 ); /* expand it */

return( s );
}


/* =============================== */
/* append str to buffer */
static int
addb( bb, str )
char bb[], str[];
{
int len;

len = strlen( bb );
sprintf( &bb[ len ], "%s", str );
}
SHAR_EOF
############################

echo src/copa_entry.c
cat << \SHAR_EOF > src/copa_entry.c
/*
COPA 1.0 - gui control panel kit for shell, C, perl etc.  
*              **      **                              *
Copyright 1991-1996 by Stephen C. Grubb.

Permission is hereby granted to USE this software for free.
Permission is hereby granted to MODIFY and/or REDISTRIBUTE 
this software for free, provided that no monetary gain is 
realized, and all attached authorship and copyright notices 
are preserved.

Inclusion of any portion (or derivation) of this software, 
including ancillary files, in any commercial product is not 
allowed without prior written permission of the author.  

See also the file 'Copyright'. 
*/



#include "elib.x"

static int inuse = 0; /* This will be set to the object id for redraw purposes.. */

/* =================================== */
/* The GEN routine.. */
/* Make a one-line data entry area. */

EAentryfield( p, path )
int p, path;
{
double *posx, *posy;
double x, y, x1, y1, x2, y2;
char newpath[80], *entry;
int *w, len;
double cursorpos, *cursorcolor, *margin, *color;
int textcolor;
int active;
int curchar;
char *pr;
char buf[E_GPBUF];
int showicur;

EIgetc( p, "", "active", &len );
if( len > 0 ) active = 1; else active = 0;

/* if( active ) Ekeyboard_focus( p ); */ /* removed scg Nov 95 */

posx = EIgetd( p, path, "position", &len );
if( len != 2 ) { fprintf( stderr, "Position must be specified for getstring.\n" ); return( 0 ); }
posy = posx + 1;

x = *posx; y = *posy;

sprintf( newpath, "%s/text", path );
EAtext_props( p, newpath );

textcolor = Ecurcolor;

w = EIgeti( p, path, "maxlength", &len );
pr = EIgetc( p, path, "prompt", &len );

/* backing box.. */
margin = EIgetd( p, path, "box.margin", &len );
color = EIgetd( p, path, "box.color", &len );
x1 = x - (*margin);
y1 = y - (*margin);
x2 = x + (((*w)+2) * Ecurtextwidth ) + (strlen( pr ) * Ecurtextwidth) + (*margin);
y2 = y + Ecurtextheight+ (*margin);
Eblock( x1, y1, x2, y2, *color, 0 );
Esetlastbox( x1, y1, x2, y2 );

/* rectangle dressing */
EIgetc( p, path, "dress", &len );
if( len > 0 ) {
	sprintf( newpath, "%s/dress", path );
	EArect_dress( p, newpath );
	}
	

Esetdrawcolor( textcolor );

/* prompt and any existing text.. */
Emov( x, y ); Etext( pr );
entry = EIgetc( p, path, "pick/value", &len );
Emov( x + ((strlen( pr )+1)*Ecurtextwidth), y ); Etext( entry );

/* cursor.. */
curchar = strlen( entry ) + strlen( pr ) + 1;
cursorpos = x + ( curchar * Ecurtextwidth );
cursorcolor = EIgetd( p, path, "cursor.color", &len );
EIgetc( p, path, "showicur", &showicur );
if( active )Eblock( cursorpos, y-.03, cursorpos+Ecurtextwidth, y+Ecurtextheight, *cursorcolor, 0 );
else if( showicur ) {
	Elinetype( 0, 1.0, 1.0 ); 
	Eblock( cursorpos, y-.03, cursorpos+Ecurtextwidth, y+Ecurtextheight, *color, 1 );
	}
}

/* ============================================== */
/* The EXEC routine.. */
/* Get characters until a return is pressed, or a mouse button is pressed. */
/* The decimal ascii value of the terminating key will be returned, or 0 or 1 */
/* append the character e to the end of the entry.. */
EEentryfield( p, x, y, e, message )
int p;
double x, y;
int e;
char message[];
{
double *posx, *posy;
char s[2];
double cursorpos, *cursorcolor, *color;
int len;
int *w;
double lx, ly;
int curchar;
int c;
char *pr;
char *next;
int nextp, status;
double startpos;
int first;
char *mousemode, *tweakmode;
int clickp;
int nc;
double *tx;
int do_tx;
double pos;

/* TOP: removed scg Nov 95 */

c = e;

if( e == E_MESSAGE && strcmp( message, "RESET" )==0 ) { 
	EImodattr( p, "", "pick/value", "" );
	return( 1 );
	}

/* if( c < 1000 ) return( 0 ); */
first = 0;
if( c < 1000 ) first = 1;

do_tx = 0;
tx = EIgetd( p, "", "*/trl", &do_tx );

EImodattr( p, "", "active", "x" ); /* make it active.. */
/* Ekeyboard_focus( p ); */ /* removed scg Nov 95 */
Egen( p );
if( e == E_MESSAGE && strcmp( message, "ACTIVATE" )==0 ) return( 0 ); /* scg 1-31-96 */

Egraphenv( E_PUSH ); 
if( EAstd( p, "*" ) == 0 ) { Egraphenv( E_POP ); return( 0 ); } /* object not visible, return.. */

posx = EIgetd( p, "", "position", &len );
posy = posx + 1;

EAtext_props( p, "text" );

w = EIgeti( p, "", "maxlength", &len );
pr = EIgetc( p, "", "prompt", &len );
color = EIgetd( p, "", "box.color", &len );
strcpy( Eselection, EIgetc( p, "", "pick/value", &len ) );
curchar = strlen( Eselection ) + strlen( pr ) + 1;

cursorcolor = EIgetd( p, "", "cursor.color", &len );

mousemode = EIgetc( p, "", "mousemode", &len );

tweakmode = EIgetc( p, "", "tweakmode", &len );

cursorpos = (*posx) + ( curchar * Ecurtextwidth ); /* update position.. */
startpos = *posx + ( ( strlen( pr ) + 1 ) * Ecurtextwidth );
lx = x; ly = y;
inuse = p; /* in case of redraw in midst of data entry */

/* for every character.. */
while( 1 ) {  
	if( ! first ) {
		Egetkey( &lx, &ly, &c );
		Esavekey( lx, ly, c ); /* remember event in case its needed later.. */
		}
	if( c >= 1000 ) {  /* a mouse button was pressed.. added 12-7-95 scg */

		/* tweak -- allow middle mouse button to decrement selected digit; right mouse
		   		button increment selected digit. */
		if( tweakmode[0] == 'x' ) {
			if( do_tx > 0 ) lx -= (*tx); /* we may have to translate if object was aligned.. */
			nc = (int) ( (lx - *posx) / Ecurtextwidth ) - (strlen( pr ) + 1) ;
			if( nc < 0 || nc >= strlen( Eselection ) ) {
				if( c == E_MOUSE_MIDDLE || c == E_MOUSE_RIGHT ) continue;
				/* else fall thru.. */
				}
			else if( c == E_MOUSE_LEFT );
			else if( Eselection[ nc ] >= '0' && Eselection[ nc ] <= '9' ) {
				if( c == E_MOUSE_MIDDLE ) Eselection[ nc ]--;
				if( c == E_MOUSE_RIGHT ) Eselection[ nc ]++;
				/* wrap.. */
				if( Eselection[ nc ] > '9' ) Eselection[ nc ] = '0';
				if( Eselection[ nc ] < '0' ) Eselection[ nc ] = '9';

				/* erase old digit and display new one.. */
				pos = startpos + ( nc * Ecurtextwidth );
				Eblock( pos-0.01, (*posy)-.03, pos+Ecurtextwidth+0.01, 
					(*posy)+Ecurtextheight, *color, 0 );
				Emov( startpos, (*posy) ); Etext( Eselection );
				continue;
				}
			}

		/* handle mouse clicks other than tweaks.. */
		if( mousemode[0] == 'T' ) break;  /* terminate */
		else if( mousemode[0] == 'I' ) continue; /* ignore */
		else if( mousemode[0] == 'R' ) {  /* terminate if mouse click within range */
			clickp = Ewhichobj( x, y );
			if( clickp == p ) break;
			else continue;
			}
		continue;  
		}
	if( ! inuse ) break; /* for resize during data entry - terminate */
	first = 0;

	/* tab, carriage return or escape */
	if( c == '\011' || c == '\012' || c == '\015' || c == '\033' ) break; 

	else if( ( c == '\010' || c == '\177' ) ) {   /* backspace.. */
	
		if( curchar <= (strlen( pr ) + 1) ) continue;
		else curchar--;

		/* erase old cursor (a little extra to clean up any grunge) */
		Eblock( (cursorpos-0.01), (*posy)-.03, cursorpos+Ecurtextwidth+0.01, 
			(*posy)+Ecurtextheight, *color, 0 );

		cursorpos = (*posx) + ( curchar * Ecurtextwidth ); /* update position.. */
	
		/* draw the cursor over the existing character.. */
		Eblock( cursorpos, (*posy)-.03, cursorpos+Ecurtextwidth, (*posy)+Ecurtextheight, 
			*cursorcolor, 0 );
	
		Eselection[ strlen( Eselection ) - 1 ] = '\0';  /* take the last char off end of buf.. */
		continue;
		}
	else if( strlen( Eselection ) >= (*w) ) {  /* check length */ 
		fprintf( stderr, "%c", 7 ); /* bell */ /* scg */
		/* break */ /* scg */
		continue; /* scg */
		}
	else if( c < 32 || c > 126 ) continue; /* throw out garbage chars.. */
	
	curchar++;
	cursorpos = (*posx) + ( curchar * Ecurtextwidth );

	/* erase old cursor (with slight extra to get rid of any grunge) and draw new cursor.. */
	Eblock( (cursorpos-Ecurtextwidth)-0.01, (*posy)-.05, cursorpos+0.01, (*posy)+Ecurtextheight, *color, 0 );
	Eblock( cursorpos, (*posy)-.03, cursorpos+Ecurtextwidth, (*posy)+Ecurtextheight, *cursorcolor, 0 );

	/* display new character.. */
	/* sprintf( s, "%c", c ); Emov( cursorpos-Ecurtextwidth, (*posy) ); Etext( s );    */

	/* sprintf( Eselection, "%s%c", Eselection, c ); */     /* build up the buffer.. */
	len = strlen( Eselection );
	Eselection[ len ] = c;
	Eselection[ len+1 ] = '\0';

	Emov( startpos, (*posy) ); Etext( Eselection );


	}

/* finish up.. */
EImodattr( p, "", "pick/value", Eselection );	/* save the new value.. */
EImodattr( p, "", "active", "" ); 	/* make it inactive.. */

Egraphenv( E_POP );
Egen( p );
inuse = 0;

return( c );
}

/* ====================================================== */
/* special case-- handle redraw in midst of data entry.. */

Eredraw_entryfield()
{
if( inuse ) {
	EImodattr( inuse, "", "pick/value", Eselection );	/* save the new value.. */
	EImodattr( inuse, "", "active", "" );	/* make it inactive */
	inuse = 0;
	/* Egen( inuse ); */
	}
}
SHAR_EOF
############################

echo src/copa_exec.c
cat << \SHAR_EOF > src/copa_exec.c
/*
COPA 1.0 - gui control panel kit for shell, C, perl etc.  
*              **      **                              *
Copyright 1991-1996 by Stephen C. Grubb.

Permission is hereby granted to USE this software for free.
Permission is hereby granted to MODIFY and/or REDISTRIBUTE 
this software for free, provided that no monetary gain is 
realized, and all attached authorship and copyright notices 
are preserved.

Inclusion of any portion (or derivation) of this software, 
including ancillary files, in any commercial product is not 
allowed without prior written permission of the author.  

See also the file 'Copyright'. 
*/


#include "elib.x"

/* ==================================================== */
/* return 1 "if it did anything", 0 otherwise */
Eexec( p, x, y, e, message )
int p;
double x, y;
int e;
char message[];
{
char *packagename, *procname;
double *tx, *ty;
int len, status;

procname = EIgetobjname( p );
packagename = EIgetpackagename( p );

status = 0;
if( strcmp( packagename, "std" )==0 ) {

/*
 *	if( strcmp( procname, "scalezone" )==0 ) {
 *		/ don't adjust coords../
 *		status = EEscalezone( p, x, y, e, message );
 *		return( status );
 *		}
 */

	/* get translation vector and adjust coords */
	tx = EIgetd( p, "", "*/trl", &len );
	if( len > 0 ) {
		ty = tx; ty++; 
		x -= (*tx);  y-= (*ty);
		}

	if( strcmp( procname, "textb" )==0 ) status = EEtextb( p, x, y, e, message );
	else if( strcmp( procname, "dataentry" )==0 ) status = EEentryfield( p, x, y, e, message );
	else if( strcmp( procname, "button" )==0 ) status = EEbutton( p, x, y, e, message );
	else if( strcmp( procname, "slider" )==0 ) status = EEslider( p, x, y, e, message );
	else if( strcmp( procname, "rectangle" )==0 || strcmp( procname, "ellipse" )==0 ) { 
		/* nothing other than object pick.. */
		EIgetc( p, "", "pick", &len );
		if( len > 0 ) { Eselection[0] = '\0'; status = 1; }
		else status = 0;
		}
	}
return( status );
}

/* ========================================================== */
EEscalezone( p, x, y, e, message )
int p, e;
double x, y;
char message[];
{
double *x1, *y1, *x2, *y2, *xlo, *ylo, *xhi, *yhi, Edx(), Edy(), zero, one;
int len;
char *xscaletype, *yscaletype;

zero = 0.0;
one = 1.0;

EIgetc( p, "", "pick", &len );
if( len < 1 ) return( 0 );

x1 = EIgetd( p, "*", "bb", &len );
y1 = x1 + 1;
x2 = x1 + 2;
y2 = x1 + 3;

xlo = EIgetd( p, "", "xrange", &len );
if( len != 2 ) { xlo = &zero; xhi = &one; }
else xhi = xlo + 1;
ylo = EIgetd( p, "", "yrange", &len );
if( len != 2 ) { ylo = &zero; yhi = &one; }
else yhi = ylo + 1;

xscaletype = EIgetc( p, "", "xscaletype", &len );
yscaletype = EIgetc( p, "", "yscaletype", &len );

Escaletype( xscaletype, 'x' );
Escale_x( *x1, *x2, *xlo, *xhi );

Escaletype( yscaletype, 'y' );
Escale_y( *y1, *y2, *ylo, *yhi );

sprintf( Eselection, "%g %g", Edx( x ), Edy( y ) );
}
 


/* ========================================================== */
/* process message(s) */
/* msg is a semicolon-separated list of messages. */
/* Each message is of the format MESSAGE TEXT > RECIPIENT_TAG */
Eprocess_message( p, msg )
int p; /* procid of the sender */
char msg[];
{
int i, j, k, ix, idx, recip_id;
char m[40], txt[30], recip[30];

if( sscanf( msg, "%s", txt ) < 1 ) return( 0 );

for( i = 0, ix = 0; ; i++ ) {
	Egetchunk( m, msg, &ix, ";" );
	if( strlen( m ) < 1 ) break;
	
	idx = 0;
	Egetchunk( txt, m, &idx, ">" );
	Estrip_ws( txt );
	sscanf( &m[idx+1], "%s", recip );
	/* this lookup should really first check the group if any, then the whole list.. */
	recip_id = EItaglookup( recip, p );
	if( recip_id == E_NIL ) { 
		fprintf( stderr, "Message recipient (%s) not recognized.\n", recip );
		continue;
		}
	else Eexec( recip_id, 0.0, 0.0, E_MESSAGE, txt );
	}
}
SHAR_EOF
############################

echo src/copa_gen.c
cat << \SHAR_EOF > src/copa_gen.c
/*
COPA 1.0 - gui control panel kit for shell, C, perl etc.  
*              **      **                              *
Copyright 1991-1996 by Stephen C. Grubb.

Permission is hereby granted to USE this software for free.
Permission is hereby granted to MODIFY and/or REDISTRIBUTE 
this software for free, provided that no monetary gain is 
realized, and all attached authorship and copyright notices 
are preserved.

Inclusion of any portion (or derivation) of this software, 
including ancillary files, in any commercial product is not 
allowed without prior written permission of the author.  

See also the file 'Copyright'. 
*/



#include "elib.x"

static double *Ed1;
static int Eival;

/* Egen() - generate (redraw) an object.  Returns 1 on success, 0 otherwise.. */
Egen( p )
int p;
{
char *procname;
char *attr;
char *package;
int id;
char str[20];


if( p < 0 ) { fprintf( stderr, "Egen: object does not exist.\n" ); return( 0 ); }

/* get proc name */
procname = EIgetobjname( p );

/* get package */
package = EIgetpackagename( p );





if( strcmp( package, "std" )==0 ) {

	/* group begin/end (handle specially) */
	if( strcmp( procname, "group_begin" )==0 ) {
		Eobjbegin( p );
		EAstd( p, "*" );
		return( 1 );
		}
	else if( strcmp( procname, "group_end" )==0 ) {
		id = Eobjend( "B" );
		sprintf( str, "%d", p );
		EImodattr( id, "", "endid", str );
		return( 1 );
		}


	/* other objects.. */
	Ebatch_on();
	Egraphenv( E_PUSH );
	Eobjbegin( p );

	if( EAstd( p, "*" ) != 0 ) {  /* if it's visible.. */

		if( strcmp( procname, "textb" )==0 ) EAtextb( p, "" );
		else if( strcmp( procname, "line" )==0 ) EAline( p, "" );
		else if( strcmp( procname, "dataentry" )==0 ) EAentryfield( p, "" );
		else if( strcmp( procname, "button" )==0 ) EAbutton( p, "" );
		else if( strcmp( procname, "slider" )==0 ) EAslider( p, "" );
		else if( strcmp( procname, "scalezone" )==0 ) EAscalezone( p, "" );
		else if( strcmp( procname, "rectangle" )==0 ) EArectangle( p, "" );
		else if( strcmp( procname, "ellipse" )==0 ) EAellipse( p, "" );
		else if( strcmp( procname, "backing" )==0 ) EAbacking( p, "" );
		else if( strcmp( procname, "elib_journal" )==0 ) EAelib_journal( p, "" );
		}
	
	if( strcmp( procname, "line" )==0 ) Eobjend( "L" );
	else Eobjend( "B" ); 


	Egraphenv( E_POP );

	/* see if we need to do textb scroller.. */
	if( strcmp( procname, "textb" )==0 ) EAvscroller( p );
		
	Ebatch_off();
	}
#ifdef PLOT
else if( strcmp( package, "plot" )==0 ) EPgenipl( procname, p );
#endif

return( 1 );
}

/* ================================================== */
EAstd( p, path )
int p;
char path[];
{
char *c1;
double *d1, *d2;
int len;

c1 = EIgetc( p, path, "display", &len );
if( len < 1 ) return(0);

d1 = EIgetd( p, path, "trl", &len ); d2 = d1; d2++;
if( len > 0 )Etrladd( *d1, *d2 );
return( 1 );
}


/* ==================================================== */
EArect_dress( p, path )
int p;
char path[];
{
double x1, y1, x2, y2;
double *d1, *d2, *d3, *d4, f1, f2, f3, f4;
int len;
char newpath[E_ANAMELEN], *c1;
double *color;

Egetlastbox( &x1, &y1, &x2, &y2 );

EIgetc( p, path, "outline", &len );
if( len > 0 ) {
	sprintf( newpath, "%s/outline", path );
	EAline_props( p, newpath );
	Emov( x1, y1 ); Elin( x1, y2 ); Elin( x2, y2 ); Elin( x2, y1 ); Elin( x1, y1 );
	}

d1 = EIgetd( p, path, "shadow", &len );
if( len < 1 ) f1 = -1.0; else f1 = *d1;

d1 = EIgetd( p, path, "shadow.size", &len );
d2 = EIgetd( p, path, "3d.upper", &len );
if( len < 1 ) f2 = -1.0; else f2 = *d2;
d3 = EIgetd( p, path, "3d.lower", &len );
if( len < 1 ) f3 = -1.0; else f3 = *d3;
d4 = EIgetd( p, path, "3d.size", &len );
Eblockdress( x1, y1, x2, y2, f3, f2, *d4, f1, *d1 );
}

/* =========================================== */
EAtext_props( p, path )
int p;
char path[];
{
int *i1, len;
char *c1, *c2;

i1 = EIgeti( p, path, "size", &len ); Etextsize( *i1 );
c2 = EIgetc( p, path, "font", &len ); Efont( c2 );
c1 = EIgetc( p, path, "pen", &len ); 
if( *c1 == 'w' ) Esetdrawcolor( E_WHITE );
else Esetdrawcolor( E_BLACK );
}

/* =========================================== */
EAline( p, path )
int p;
char path[];
{
double *d1, *d2;
int *i1, len;
char newpath[E_ANAMELEN];

sprintf( newpath, "%s/props", path );
EAline_props( p, newpath );
d1 = EIgetd( p, path, "end1", &len ); d2 = d1; d2++; Emov( *d1, *d2 );
d1 = EIgetd( p, path, "end2", &len ); d2 = d1; d2++; Elin( *d1, *d2 );
}

/* =========================================== */
EAline_props( p, path )
int p;
char path[];
{
int len;
double *d1, *d2;
int *i1;
char *c1;

d1 = EIgetd( p, path, "thick", &len );
i1 = EIgeti( p, path, "dash", &len );
d2 = EIgetd( p, path, "dashdens", &len );
Elinetype( *i1, *d1, *d2 );
c1 = EIgetc( p, path, "pen", &len );
if( *c1 == 'w' ) Esetdrawcolor( E_WHITE );
else Esetdrawcolor( E_BLACK );
}

/* =========================================== */
EAelib_journal( p, path )
int p;
char path[];
{
int ix, ixx, len;
double x, y;
char op;
char *journ;
char buf[E_GPBUF], tok[20];

journ = EIgetc( p, path, "text", &len );

ix = 0;
while( 1 ) {
	
	Egetchunk( buf, journ, &ix, "\n" ); /* op */
	if( strlen( buf ) < 1 ) break;

	op = buf[0];
	ixx = 2;
	Egetchunk( tok, buf, &ixx, " " );
	x = atof( tok );
	Egetchunk( tok, buf, &ixx, " " );
	y = atof( tok );
	strcpy( buf, &buf[ixx] );

	Epcode( op, x, y, buf );
	}
}
/* ============================================= */
/* plain rectangle.. */
EArectangle( p, path )
int p;
char path[];
{
double *cx, *cy, *h, *v, *shade;
int len;
char newpath[E_ANAMELEN];
int outline;
char *txt;
int i, ix, nnl;
double ystart, xstart, x1, x2, y1, y2;
char buf[80];

cx = EIgetd( p, path, "position", &len );
if( len != 2 ) return( 0 );
cy = cx + 1;

h = EIgetd( p, path, "horiz", &len );
v = EIgetd( p, path, "vert", &len );

shade = EIgetd( p, path, "color", &len );
EIgetc( p, path, "outline", &len );
if( len > 0 ) outline = 1;
else outline = 0;

if( outline ) {
	sprintf( newpath, "%s/outline", path );
	EAline_props( p, newpath );
	}

Eblock( *cx-(*h), *cy-(*v), *cx+(*h), *cy+(*v), *shade, outline );

txt = EIgetc( p, path, "text", &len );

if( len > 0 ) {
	x1 = *cx-*h;
	y1 = *cy-*v;
	x2 = *cx+*h;
	y2 = *cy+*v;
	xstart = (x1 + x2) / 2.0;
	ystart = (y1 + y2) / 2.0;
	sprintf( newpath, "%s/text", path );
	EAtext_props( p, newpath );

	/* draw text, centered.. */
	for( i = 0, nnl = 1; i < strlen( txt ); i++ ) if( txt[i] == '\n' ) nnl++; /* count newlines */
	ystart += ( (((double)(nnl)-1) / 2.0 ) * Ecurtextheight );
	for( i = 0, ix = 0; i < nnl; i++ ) {
		Egetchunk( buf, txt, &ix, "\n" );
		Emov( xstart, ystart );
		Ecentext( buf );
		ystart-= Ecurtextheight;
		}
	}
}

/* ============================================= */
/* circle/ellipse.. */
EAellipse( p, path )
int p;
char path[];
{
double *cx, *cy, *shade, *r1, *r2;
int len;
char newpath[E_ANAMELEN];
int outline;
char *txt;
int i, ix, nnl;
double ystart;
char buf[80];

cx = EIgetd( p, path, "position", &len );
cy = cx + 1;

r1 = EIgetd( p, path, "hradius", &len );
r2 = EIgetd( p, path, "vradius", &len );

shade = EIgetd( p, path, "color", &len );

EIgetc( p, path, "outline", &len );
if( len > 0 ) outline = 1;
else outline = 0;

if( outline ) {
	sprintf( newpath, "%s/outline", path );
	EAline_props( p, newpath );
	}

Eellipse( *cx, *cy, *r1, *r2, *shade, outline );

txt = EIgetc( p, path, "text", &len );
if( len > 0 ) {
	sprintf( newpath, "%s/text", path );
	EAtext_props( p, newpath );

	/* draw text, centered.. */
	for( i = 0, nnl = 1; i < strlen( txt ); i++ ) if( txt[i] == '\n' ) nnl++; /* count newlines */
	ystart = *cy + ( (((double)(nnl)-1) / 2.0 ) * Ecurtextheight );
	for( i = 0, ix = 0; i < nnl; i++ ) {
		Egetchunk( buf, txt, &ix, "\n" );
		Emov( *cx, ystart );
		Ecentext( buf );
		ystart-= Ecurtextheight;
		}
	}
}

/* =========================================== */
/* scalezone sets up a bounding box but doesn't draw anything..*/

EAscalezone( p, path )
int p;
char path[];
{
double *posx, *posy, *w, *h, *color;
int len;

posx = EIgetd( p, path, "position", &len );
posy = posx + 1;
w = EIgetd( p, path, "width", &len );
h = EIgetd( p, path, "height", &len );

Esquelch_display( 1 );
Emov( *posx, *posy );
Elin( (*posx) + (*w), (*posy) + (*h) );
Esquelch_display( 0 );

color = EIgetd( p, path, "color", &len );
if( len < 1 || *color < 0.0 ) return( 1 );
Eblock( *posx, *posy, (*posx+*w), (*posy+*h), *color, 0 );

}
/* =========================================== */
/* background */
EAbacking( p, path )
int p;
char *path;
{
int len, len2;
double *s;
double *h, *w, color;
char newpath[E_ANAMELEN];

EIgetc( p, path, "nobacking", &len );
if( len > 0 ) return( 0 ); /* do nothing, not even a clear.. */

s = EIgetd( p, path, "color", &len );
if( *s >= 0 ) Eseteraseshade( *s );

if( *s < 0 ) color = 1.0;
else color = *s;

/* if we reach here we will do a rectangle backing box.. */
w = EIgetd( p, path, "box.width", &len );
h = EIgetd( p, path, "box.height", &len2 );
if( len < 1 || len2 < 1 ) { /* no backing box defined, clear entire window.. */
	Eclr();
	return( 0 );
	}

/* do the box.. */
Eblock( 0.0, 0.0, *w, *h, color, 1 );
Esetlastbox( 0.0, 0.0, *w, *h );

/* do the deco */
EIgetc( p, path, "dress", &len );
if( len > 0 ) {
      	sprintf( newpath, "%s/dress", path );
       	EArect_dress( p, newpath );
	}
return( 0 );
}



/* =========================================== */
/* =========================================== */
/* =========================================== */
/* returns 1 on success, 0 otherwise (indicates group begin/end mismatch) */
Egenall()
{
int ip;
double x, y;
int i;
char *objtyp;
int found;


/* first we need to check if backing is defined by user somewhere in the file.. 
   if not specified by user we need to do clear the window here.. */
found = 0;
EIgetnextobj( E_AT_BEGINNING, 0 );
while( 1 ){
	ip = EIgetnextobj( E_NEXT, 0 );
	if( ip < 0 ) break;
	if( strcmp( EIgetobjname( ip ) , "backing" )== 0 ) { found = 1; break; }
	}
EIgetnextobj( E_DONE, 0 );
if( !found ) {
	Eseteraseshade( Ebkcolor0 );
	Eclr();
	}


/* display all objects.. */
EIgetnextobj( E_AT_BEGINNING, 0 );
while( 1 ) {
	ip = EIgetnextobj( E_NEXT, 0 );
	if( ip < 0 ) break;
	Egen( ip );
	}
EIgetnextobj( E_DONE, 0 );

Etrlget( &x, &y );

if( Echecknest() != 0 ) { fprintf( stderr, "Unbalanced group_begin/group_end.\n" ); return( 0 ); }
else return( 1 );
}
/* ============================================== */
Eprintall( name, fnm, mode )
char *name; /* arbitrary name */
char fnm[]; /* file for postscript output, or dash (-) for standard output. */
char mode; /* 'P' for portrait, 'L' for landscape */
{
char dev;

dev = Edev;
Edev = 'p'; /* switch to postscript */
EPSsetup( name, fnm );
if( mode == 'L' ) Epaper( 1 );
else Epaper( 0 );
Egenall();
Eendoffile();
if( strcmp( fnm, "-" )!=0 ) EPSclose();
Edev = dev;
}

SHAR_EOF
############################


