Newsgroups: comp.sources.unix
From: stevegru@welchlink.welch.jhu.edu (STEPHEN C GRUBB)
Subject: v29i091: copa - gui control panel kit for shell, C, perl - V1.0, Part04/08
References: <1.823324036.2981@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: stevegru@welchlink.welch.jhu.edu (STEPHEN C GRUBB)
Posting-Number: Volume 29, Issue 91
Archive-Name: copa/part04

#	This is a shell archive.
#	Remove everything above and including the cut line.
#	Then run the rest of the file through sh.
# - - - - - - C U T   H E R E - - - - - - - - - - - - - - -
#!/bin/sh
#
# Part 4
#
# shar:	Shell Archiver
#	Run the following text with /bin/sh to create:
#		src/Paxes.c
#		src/Pbargraph.c
#		src/Pdistribution.c
#		src/Pdraw.c
#		src/Perrorbars.c
#		src/Pfilld.c
#		src/Pgen.c
#		src/Phorizbar.c
#		src/Plegend.c
#		src/Plineplot.c
#		src/Pmap.c
#		src/Ppgraphic.c
#		src/Ppie.c
#		src/Ppinit.c
#		src/Pplib.c
#		src/Ppstub.c
#		src/Prect.c
#		src/Putil.c
echo src/Paxes.c
cat << \SHAR_EOF > src/Paxes.c
/* Set up a graphics area and do axes, etc. */
#include "ipl.x"
#define LINE 1
#define SHADE 2
#define WLINE 3
#define NUMERIC 0
#define FROM_FILE 1
#define VAR 2
#define LITERAL 3

EPaxes( )
{
char paper[12],
	areaname[30],
	s1[12], s2[12], s3[12], s4[12],
	uin[12];
double	xlo,
	xhi,
	ylo,
	yhi,
	dxlo,
	dxhi,
	dylo,
	dyhi;
int	n,
	areasrc,
	p,
	bad,
	loadflag,
	i;
char 	str[200], 
	do_x[10], do_y[10],
	shade[12],
	month[6], year[6],
	buf[100],
	*copa_home, *getenv(),
	s[3][100];
int 	j,
	tl, tr, 
	sl, sr, 
	grid, 
	even, 
	minor,
	stub0or1,
	varfield,
	nrows,
	no_lone_tics,
	stubisrc;
double 	tcl = 0.08, 
	mtcl = 0.035, /* tic length, major and minor */
	stop,
	xstubyofs,
	ystubxofs,
	y,
	stubxofs,
	sh,
	f, g, h;
FILE 	*fp;

/* tic increment */
bad = NO;
gget( uin, "Xinc" ); if( ! goodnum( uin, &p )) bad = YES; DXtic = atof( uin );
gget( uin, "Yinc" ); if( ! goodnum( uin, &p )) bad = YES; DYtic = atof( uin );
if( bad ) { fprintf( stderr, "Tic increments incomplete.\n" ); }

/* get tic numbering format */
gget( DXticfmt, "Xticfmt" );
gget( DYticfmt, "Yticfmt" );

/* do the graphic work for axes, ticks, etc. */



/* set to uer's standard font */
gget( Buf, "Font" );
NTfont( Buf );


/* frame of the graphics area */
gget( Buf, "Frame" );
if( strcmp( Buf, "double" ) == 0 ) ab_rect( Xlo-mtcl, Ylo-mtcl, Xhi+mtcl, Yhi+mtcl, 1.0, 1 );
if( strcmp( Buf, "none" ) != 0 ) ab_rect( Xlo, Ylo, Xhi, Yhi, 1.0, 1 );
/* shade the area */
/*
 * gget( Buf, "Shade" );
 * if( strlen( Buf ) > 0 ) {
 *	sh = atof( Buf );
 *	ab_rect( Xlo, Ylo, Xhi, Yhi, sh, 0 );
 *	}
 */

gget( Buf, "Ystub.ticlen" ); tcl = atof( Buf );
gget( Buf, "Ystub.ticlen.minor" ); mtcl = atof( Buf );

/**** Y ****/
/* draw axis line */
gget( do_y, "Yaxis" ); 
if( do_y[0] == 'n' ) goto BEGIN_X; /* if 'no', skip all the y axis code */


/* stub text can be numeric, from a data field, from a file, or literally specified. */
gget( Buf, "Ystub" ); 
if( strcmp( Buf, "num" )==0 ) stubisrc = NUMERIC;
else if( Buf[0] == '@' ) { 
	stubisrc = VAR;
	varfield = atoi( &Buf[1] ); 
	if( varfield < 1 || varfield > N_d_fields ) { fprintf( stderr, "bad stub var field\n" ); gdp_exit(); }
	}
else if( strlen( Buf ) < 1 ) fprintf( stderr, "Warning, Ystub not specified.\n" );
else 	{
	stubisrc = FROM_FILE;
	fp = fopen( Buf, "r" );
	if( fp != NULL ) {
		gget( Buf, "Ystub.fileline" );
		for( i = 0; i < atoi( Buf ); i++ ) fgets( str, 200, fp );
		}
	else if( fp == NULL ) {
		sprintf( Buf2, "%s/%s", Templatepath, Buf );
		fp = fopen( Buf2, "r" );
		if( fp != NULL ) {
			gget( Buf, "Ystub.fileline" );
			for( i = 0; i < atoi( Buf ); i++ ) fgets( str, 200, fp );
			}
		else if( fp == NULL ) {
			text_tofile( Buf, Tempfile );
			fp = fopen( Tempfile, "r" );
			}
		}
	}


/* sides to put tics on */
gget( Buf, "Ystub.tics" ); 
if( smember( Buf, "left both" )) tl = YES; else tl = NO;
if( smember( Buf, "right both" )) tr = YES; else tr = NO;

/* sides to put stubs on */
gget( Buf, "Ystub.stubs" ); 
if( smember( Buf, "left both" )) sl = YES; else sl = NO;
if( smember( Buf, "right both" )) sr = YES; else sr = NO;

/* point size of stubs */
gget( Buf, "Ystub.size" ); NTptsize( atoi( Buf ) );

/* shade level for shaded blocks */
gget( shade, "Ystub.shade" );

/* grid style */
gget( Buf, "Ystub.grid" ); 
if( strcmp( Buf, "line" )==0 ) grid = LINE;
else if( strcmp( Buf, "shade" )==0 ) grid = SHADE;
else if( strcmp( Buf, "wline" )==0 ) grid = WLINE;
else grid = NO;

/* minor tics */
gget( Buf, "Ystub.minor" ); minor = atoi( Buf );

gget( Buf, "Ystub.xofs" ); ystubxofs = - atof( Buf ); /* note sign change */
gget( Buf, "Ystub.nolonetics" ); if( Buf[0] == 'y' ) no_lone_tics = 1; else no_lone_tics = 0;

/**** loop for doing y axis tics and stubs ****/
even = YES;
n = 0; /* counter for stub from var */
gget( Buf, "Ystart.0or1" ); stub0or1 = atoi( Buf );
if( stub0or1 ) { f = DYlo + (stub0or1 * DYtic); stop = DYhi - DYtic; }
else { f = DYlo; stop = DYhi; }
for( ; f <= stop +.0001; f+= DYtic ) {

	/* get stub text */
	if( stubisrc == NUMERIC )sprintf( str, DYticfmt, f );
	else if( stubisrc == VAR ) {
		if( n < N_d_rows ) strcpy( str, D[ n++ ][ atoi( &Buf[1] ) -1 ] );
		else str[0] = '\0';
		}
	else if( stubisrc == FROM_FILE) { 
		if( fgets( str, 200, fp ) == NULL ) str[0] = '\0';
		str[ strlen( str )-1 ] = '\0'; 
		if( str[0] == '!' ) { str[0] = ' '; sscanf( &str[1], "%lf", &f ); if( f > stop ) break; }
		}

	if( no_lone_tics && strlen( str ) < 1 ) { even = !even; continue; }

	if( tl ) { NTm( DXlo, f ); NTlin( da_x( DXlo ) - tcl , da_y( f ) ); } /* tics, left */
	if( tr ) { NTm( DXhi, f ); NTlin( da_x( DXhi ) + tcl , da_y( f ) ); } /* tics, right */
	if( f <= (DYhi-DYtic)+.0001 ) for( i = 0, g = f; i < minor; i++ ) {  /* minor tics */
		g+= DYtic / (double) minor ;
		if( tl ) { NTm( DXlo, g ); NTlin( da_x( DXlo ) - mtcl , da_y( g ) ); } /* tics, left */
		if( tr ) { NTm( DXhi, g ); NTlin( da_x( DXhi ) + mtcl , da_y( g ) ); } /* tics, right */
		}
	if( sl ) { /* text left */
		NTmov( da_x( DXlo ) - 2, da_y( f ) - 0.03 ); 
		NTrightjust( str, (2+ystubxofs) ); 
		} 
	if( sr ) { /* text right */
		NTmov( da_x( DXhi ) - ystubxofs , da_y( f ) - 0.03 ); 
		NTtext( str ); 
		}	
	if( grid == LINE ) { 	/* lines */
		NTlinetype( "0", 0.3, 0 );
		NTm( DXlo, f ); 
		NTl( DXhi, f ); 
		NTnormline();
		}
	if( grid == WLINE ) ab_rect( da_x( DXlo ), da_y( f ) - 0.02, da_x( DXhi ), da_y( f )+ 0.02, 1.0, 0 );
	if( grid == SHADE && even && f <= (DYhi-DYtic)+.0001 ) { /* shaded blocks */
		rect( DXlo, f, DXhi, f+DYtic, atof( shade ), 0 );
		} 
	even = !even;
	}
if( stubisrc == FROM_FILE ) fclose( fp );
if( smember( do_y, "left both" ) ) { NTmov( Xlo, Ylo ); NTlin( Xlo, Yhi ); }
if( smember( do_y, "right both" ) ) { NTmov( Xhi, Ylo ); NTlin( Xhi, Yhi ); }



/**** X ****/
/* draw axis line */
BEGIN_X:
gget( do_x, "Xaxis" ); 
if( do_x[0] == 'n' ) goto TITLES; /* dont do any of this */

gget( Buf, "Xstub.ticlen" ); tcl = atof( Buf );
gget( Buf, "Xstub.ticlen.minor" ); mtcl = atof( Buf );

/* Figure out where stub text will come from.. either
 * plain numeric, from a data field, from a file, or literally specified.
 * Also available for x axis only is month/year, which actually comes from a file. */

gget( Buf, "Xstub" ); 

if( strcmp( Buf, "num" )==0 ) stubisrc = NUMERIC;
else if( Buf[0] == '@' ) { 
	stubisrc = VAR; 
	varfield = atoi( &Buf[1] ); 
	if( varfield < 1 || varfield > N_d_fields ) { fprintf( stderr, "bad stub var field\n" ); gdp_exit(); }
	}
else if( strcmp( Buf, "month" )==0 ) { 
	int start;
	if( Scale_discipline_x == YYMM ) {
		gget( Buf, "Xmin" );
		sprintf( month, "%02d", atoi( Buf ) % 100 );
		sprintf( year, "%02d", atoi( Buf ) / 100 );
		}
	else	{
		gget( month, "Xstub.startmonth" );
		gget( year, "Xstub.startyear" );
		}
	if( month[0] == '\0' || year[0] == '\0' ) {
		fprintf( stderr, "Warning, Xstub.startmonth (1-12) or Xstub.startyear (70-90) are missing.\n" );
		}
	start = (((atoi(year)%100)*12) + atoi( month )) - (70*12);

	/* following 2 lines changed, scg 1-24-96 */
	copa_home = getenv( "COPA_HOME" );
	sprintf( buf, "%s/examples/month.stubs", copa_home );

	fp = fopen( buf, "r" );
	if( fp == NULL ) { fprintf( stderr, "Can't open month stub file.\n" ); gdp_exit(); }
	for( i = 0; i < start; i++ ) fgets( str, 200, fp );
	stubisrc = FROM_FILE;
	}
else 	{
	stubisrc = FROM_FILE;
	fp = fopen( Buf, "r" );
	if( fp != NULL ) {
		gget( Buf, "Xstub.fileline" );
		for( i = 0; i < atoi( Buf ); i++ ) fgets( str, 200, fp );
		}
	else if( fp == NULL ) {
		sprintf( Buf2, "%s/%s", Templatepath, Buf );
		fp = fopen( Buf2, "r" );
		if( fp != NULL ) {
			gget( Buf, "Xstub.fileline" );
			for( i = 0; i < atoi( Buf ); i++ ) fgets( str, 200, fp );
			}

		else if( fp == NULL ) {
			text_tofile( Buf, Tempfile );
			fp = fopen( Tempfile, "r" );
			}
		}
	}


gget( Buf, "Xstub.tics" ); 
if( smember( Buf, "bottom both" )) tl = YES; else tl = NO;
if( smember( Buf, "top both" )) tr = YES; else tr = NO;

gget( Buf, "Xstub.stubs" ); 
if( smember( Buf, "bottom both" )) sl = YES; else sl = NO;
if( smember( Buf, "top both" )) sr = YES; else sr = NO;

gget( Buf, "Xstub.size" ); NTptsize( atoi( Buf ) );
gget( shade, "Xstub.shade" );

gget( Buf, "Xstub.grid" ); 
if( strcmp( Buf, "line" )==0 ) grid = LINE; 
else if( strcmp( Buf, "shade" )==0 ) grid = SHADE;
else if( strcmp( Buf, "wline" )==0 ) grid = WLINE;
else grid = NO;

gget( Buf, "Xstub.minor" ); minor = atoi( Buf );
gget( Buf, "Xstub.nolonetics" ); if( Buf[0] == 'y' ) no_lone_tics = 1; else no_lone_tics = 0;

/**** loop for doing x axis tics and stubs ****/
n = 0;
even = YES;
gget( Buf, "Xstub.yofs" ); xstubyofs = - atof( Buf ); /* note sign change */
gget( Buf, "Xstart.0or1" ); stub0or1 = atoi( Buf );
if( stub0or1 ) { f = DXlo + (stub0or1 * DXtic ); stop = DXhi - DXtic; }
else { f = DXlo; stop = DXhi; }
for( ; f <= stop + .0001; f+= DXtic ) {

	/* get stub text */
	if( stubisrc == NUMERIC )sprintf( str, DXticfmt, f );
	else if( stubisrc == VAR ) {
		if( n < N_d_rows ) strcpy( str, D[ n++ ][ varfield -1 ] );
		else str[0] = '\0';
		}
	else if( stubisrc == FROM_FILE) { 
		if( fgets( str, 200, fp ) == NULL ) str[0] = '\0';
		else str[ strlen( str )-1 ] = '\0'; 
		if( str[0] == '!' ) { str[0] = ' '; sscanf( &str[1], "%lf", &f ); if( f > stop ) break; }
		}

	if( no_lone_tics && strlen( str ) < 1 ) { even = !even; continue; }

	if( tl ) { NTm( f, DYlo ); NTlin( da_x( f ), da_y( DYlo ) - tcl ); }
	if( tr ) { NTm( f, DYhi ); NTlin( da_x( f ), da_y( DYhi ) + tcl ); }
	if( f <= (stop-DXtic)+.0001 ) for( i = 0, g = f; i < minor; i++ ) {  /* minor tics */
		g+= DXtic / (double) minor ;
		if( tl ) { NTm( g, DYlo ); NTlin( da_x( g ), da_y( DYlo ) - mtcl ); }
		if( tr ) { NTm( g, DYhi ); NTlin( da_x( g ), da_y( DYhi ) + mtcl ); }
		}

	if( sl ) {    /* tokens are stacked, max=3 */
		for( i = 0; i < strlen( str ); i++ ) { 
			if( str[i] == ' ' )str[i] = '_';
			else if( str[i] == '~' ) str[i] = '\n' ;
			}
		nrows = sscanf( str, "%s %s %s", s[0], s[1], s[2] ); 
		h = da_y( DYlo ) + xstubyofs;
		for( i = 0; i < nrows; i++ ) {
			for( j = 0; j < strlen( s[i] ); j++ ) if( s[i][j]== '_' ) s[i][j]=' ';
			NTmov( da_x( f ) - 1, h ); NTcentext( s[i], 2.0 ); 
			h -= Chh;
			}
		}
	if( sr ){ 
		for( i = 0; i < strlen( str ); i++ ) { 
			if( str[i] == ' ' )str[i] = '_';
			else if( str[i] == '~' ) str[i] = '\n' ;
			}
		nrows = sscanf( str, "%s %s %s", s[0], s[1], s[2] ); 
		h = -(xstubyofs) + da_y( DYhi ) + ((nrows-2)*Chh); /* */
		for( i = 0; i < nrows; i++ ) {
			for( j = 0; j < strlen( s[i] ); j++ ) if( s[i][j]== '_' ) s[i][j]=' ';
			NTmov( da_x( f ) - 1, h ); NTcentext( s[i], 2.0 ); 
			h -= Chh;
			}
		}


	if( grid == LINE ) { 
		NTlinetype( "0", 0.3, 0 );
		NTm( f, DYlo ); 
		NTl( f, DYhi ); 
		NTnormline();
		}
	if( grid == WLINE ) ab_rect( da_x( f ) - 0.02, da_y( DYlo ), da_x( f ) + 0.02, da_y( DYhi ), 1.0, 0 );
		
	if( grid == SHADE && even && f <= (stop-DXtic)+.0001 ) { 
		rect( f, DYlo, f+DXtic, DYhi, atof( shade ), 0 );
		} 
	even = !even;
	}
if( stubisrc == FROM_FILE ) fclose( fp );
if( smember( do_x, "top both" ) ) { NTmov( Xlo, Yhi ); NTlin( Xhi, Yhi ); }
if( smember( do_x, "bottom both" ) ){ NTmov( Xlo, Ylo ); NTlin( Xhi, Ylo ); }

TITLES:


/**** do axis identifiers ****/
	{
	int n, c1, c2, c3;
	double ofs;
	gget( Buf, "Xlabel" );
	if( strlen( Buf ) > 0 ) {
		gget( Buf2, "Xlabel.size" ); NTptsize( atof( Buf2 ) );
		gget( Buf2, "Xlabel.position" ); ofs = atof( Buf2 );
		getln( "" );
		for( i = 0; i < countln( Buf ); i++ ) {
			NTmov( Xlo, Ylo - ofs ); 
			NTcentext( getln( Buf ), (Xhi-Xlo) );
			ofs += Chh; 
			}
		}

	gget( Buf, "Ylabel" );
	if( strlen( Buf ) > 0 ) {
		gget( Buf2, "Ylabel.size" ); NTptsize( atof( Buf2 ) );
		gget( Buf2, "Ylabel.position" ); ofs = atof( Buf2 );
		NTchardir( 90 );
		getln( "" );
		for( i = 0; i < countln( Buf ); i++ ) {
			NTmov( Xlo-ofs, Ylo ); 
			NTcentext( getln( Buf ), (Yhi-Ylo) ); 
			ofs -= Chh;
			}
		NTchardir( 0 );
		}
	}

/**** area title ****/
	{
	int i = 1, c;
	double ofs;
	char just[20];

	gget( Buf, "Subtitle" );
	if( strlen( Buf ) > 0 ) {
		gget( Buf2, "Subtitle.font" ); NTfont( Buf2 );
		gget( Buf2, "Subtitle.size" ); NTptsize( atof( Buf2 ) );
		gget( Buf2, "Subtitle.above" ); ofs = atof( Buf2 );
		gget( Buf2, "Subtitle.justify" ); strcpy( just, Buf2 );

		getln( "" );
		for( i = 0; i < countln( Buf ); i++ ) {
			NTmov( Xlo+0.1, Yhi+ofs );
			if( strcmp( just, "center" )==0 ) NTcentext( getln( Buf ), Xhi-(Xlo+0.1) );
			else if( strcmp( just, "right" )==0 )NTrightjust( getln( Buf ), Xhi-(Xlo+0.2) );
			else NTtext( getln( Buf ) );
			ofs -= Chh;
			}
		}
	}
/* restore standard font */
gget( Buf, "Font" ); NTfont( Buf );
}
SHAR_EOF
############################

echo src/Pbargraph.c
cat << \SHAR_EOF > src/Pbargraph.c
/* horizontal (standard) bar graphs */


/* The following parameters were added recently:
	Idfield.top
	Idfield.zero

   10-10-90 There was a bug involving 0 values when labeling was on,
   causing the an entire cluster to disappear.  Apparently caused
   by a 'break' statement which should have been a 'continue'.  Fixed.

*/

#include "ipl.x"
#define STACK	0
#define CLUSTER 1


EPbargraph( )
{
int 	k[8], 
	idf[8],
	format,
	label,
	n,
	nc,
	i, j, jj,
	p,
	xfld,
	xset,
	start,
	outline,
	zeros,
	just_top;

double s[8],
	accum,
	zer,
	curx,
	xspace,
	subspace,
	y,
	y2,
	f,
	lblpos,
	sep,
	msep = 0.03;
char str[10];

/* get the data field list */
gget( Buf, "Field" ); 
n = 0;
while( n < 1 ) { 
	n = sscanf( Buf, "%d %d %d %d %d %d %d %d", &k[0], &k[1], &k[2], &k[3], &k[4], &k[5], &k[6], &k[7] );
	if( N_d_fields == 1 ) strcpy( Buf, "1" );
	else if( n < 1 ) { fprintf( stderr, "Field parameter(s) for bar graph are missing.\n" ); gdp_exit(); }
	}
for( i = 0; i < n; i++ ) 
	if( k[i] < 1 || k[i] > N_d_fields ) { fprintf( stderr, "Field is bad\n" ); gdp_exit(); }

/* get the label field list, if any */
gget( Buf, "Idfield" ); 
if( strlen( Buf ) > 0 ) { 
	label = YES;
	sscanf( Buf, "%d %d %d %d %d %d %d %d", &idf[0], &idf[1], &idf[2], &idf[3], &idf[4], &idf[5], &idf[6], &idf[7] );
	for( i = 0; i < n; i++ ) 
		if( idf[i] < 1 || idf[i] > N_d_fields ) { fprintf( stderr, "Idfield is bad\n" ); gdp_exit(); }
	}
else label = NO;


gget( Buf, "Format" );  
if( strcmp( Buf, "stack" )==0 ) format = STACK;
else format = CLUSTER;

DXtic = 1.0;

/* get bar shades */
gget( Buf, "Shade" ); 
sscanf( Buf, "%lf %lf %lf %lf %lf %lf %lf %lf", &s[0], &s[1], &s[2], &s[3], &s[4], &s[5], &s[6], &s[7] );

/* get zero line */
gget( Buf, "Zeroat" ); 
if( goodnum( Buf, &p )) zer = atof( Buf );
else zer = DYlo;


/* get label size */
if( label ) { gget( Buf, "Idfield.size" ); NTptsize( atof( Buf ) ) };

/* distance of label from bar top */
if( label ) { gget( Buf, "Idfield.position" ); lblpos = atof( Buf ); }

/* get zero flag */
if( label ) {
   gget( Buf, "Idfield.zeros" );
   if( Buf[0] == 'n' || Buf[0] == 'N') zeros = NO;
   else zeros = YES;
}

/* print 1 field on staked bars */
if( label ) { 
   gget( Buf, "Idfield.top" ); 
   if( Buf[0] == 'N' || Buf[0] == 'n' ) just_top = NO;
   else just_top = YES;
}

/* outline or not */
gget( Buf, "Outlinebars" ); if( Buf[0] == 'y' ) outline = YES; else outline = NO;

/* x distance between major bar spaces */
gget( Buf, "Separation" ); sep = atof( Buf );

gget( Buf, "Separation.sub" ); msep = atof( Buf );

xspace = ( (Xhi-Xlo)/((DXhi-DXlo)+1) ) - (sep*Scale_x);

if( format == CLUSTER ) nc = n; else nc = 1;


gget( Buf, "Killwild" ); /* option for aborting plot if any values out of range */
if( atof( Buf ) != 0 ) {
	for( i = 1; i <= N_d_rows; i++ ) {
		if( atof( D[i-1][ k[0] -1 ] ) > atof( Buf ) ) {
			fprintf( stderr, "Note: This Bargraph terminated due to a value of %s.\n", D[i-1][k[0]-1] );
			return( 0 );
			}
		}
	}

gget( Buf, "Xfield" ); /* allow placement of bars by a data field */
if( strlen( Buf ) > 0 ) {
	xset = 1;
	xfld = atoi( Buf );
	if( xfld < 1 || xfld > N_d_fields ) { fprintf( stderr, "Yfield bad.\n" ); gdp_exit(); }
	xspace = sep;
	}
else xset = 0;

gget( Buf, "Xstart.0or1" ); /* allow starting at 0 or 1 */
if( Buf[0] == '0' ) { start = 0; }
else { start = 1; }

for( i = 1; i <= N_d_rows; i++ ) {
	if( xset ) curx = da_x( atof( D[i-1][xfld-1] ) ) - (xspace/2);
	else curx = da_x((double)(DXlo+i+(start-1))) - (xspace/2);

	subspace = ( xspace / nc );
	for( j = 0; j < nc; j++ ) {
		if( !goodnum( D[i-1][ k[j]-1 ], &p )) {
			fprintf( stderr, "Warning, row %d, field %d, is bad (%s)\n", i, k[j], D[i-1][ k[j]-1] );
			curx += subspace;
			continue;
			}
		y = atof(D[i-1][ k[j]-1 ]);
		if( y != DYlo )
			ab_rect( curx, da_y(zer), curx+(subspace-msep), da_y(y), s[j], (s[j]==1)?1:outline );
		if( label && !just_top ) {
			if( !zeros && D[i-1][ idf[j]-1 ][0] == '0' ) {curx += subspace; continue; }
			if( y < zer || format == STACK ) f = (-lblpos)-Chh; else f = lblpos;
			strcpy( str, D[i-1][ idf[j]-1 ] );
			NTmov( curx, da_y(y)+f );
			NTcentext( str, subspace-msep );
			}
		if( format == STACK ) for( jj = 1; jj < n; jj++ ) {
			if( !goodnum( D[i-1][ k[jj] -1 ], &p ) ) {
				fprintf( stderr, "Warning, row %d, field %d, is bad (%s)\n", i, k[jj], D[i-1][k[jj]-1] );
				continue;
				}
			y2 = y + atof( D[i-1][ k[jj] -1 ] );
			if( y2 != DYlo )
				ab_rect( curx, da_y(y), curx+(subspace-msep), da_y(y2), s[jj], (s[jj]==1)?1:outline );
			if( label ) {
				if( !zeros && D[i-1][ idf[jj]-1 ][0] == '0' ) { curx += subspace; continue; }
				if( y2 < zer || format == STACK ) f = (-lblpos)-Chh; else f = lblpos;
				NTmov( curx, da_y(y2)+f );
				strcpy( str, D[i-1][ idf[jj]-1 ] );
				NTcentext( str, subspace-msep );
				}
			y = y2;
			}

		curx += subspace;
		}
	}

gget( Buf, "Segment" );
if( Buf[0] == 'y' ) 
	for( f = DYlo+DYtic; f < DYhi; f += DYtic ) 
		rect( DXlo + 0.2, f-(DYhi*0.003), DXhi - 0.2, f+(DYhi*0.004), 1.0, 0 );
}
SHAR_EOF
############################

echo src/Pdistribution.c
cat << \SHAR_EOF > src/Pdistribution.c
/* distribution() - produces scatter plots.  If cluster is passed
	as YES, duplicate values will cluster around the point.
	Data must be sorted numerically for this to work.  If
	cluster == NO, duplicate points will overstrike.
*/
#include "ipl.x"

EPdistribution( )
{
int 	i, j, 
	dups, 
	cluster, 
	p, 
	dist, 
	justdist,
	xfield, 
	yfield, 
	sizefield,
	shadefield,
	markfield;
double 	adjx, adjy, 
	xdat, ydat,
	x, y, 
	prevx, prevy, 
	charh, charv, 
	size,
	sizescale,
	shade,
	shadescale,
	distlen;
char 	c[20];
FILE 	*fp, 
	*fp2;
static double xofst[38] = { 0, 0, 4, 0, -4, 4, -4, -4, 4,
	0, -8, 0, 8, 4, -8, 4, 8, -4, -8, -4, 8,
	0, 0, 12, -12, 4, 4, 12, -12, -4, -4, 12, -12,
	8, -8, -8, 8 };
static double yofst[38] = { 0, 4, 0, -4, 0, 4, -4, 4, -4,
	-8, 0, 8, 0, -8, 4, 8, 4, -8, -4, 8, -4,
	12, -12, 0, 0, 12, -12, 4, 4, 12, -12, -4, -4,
	8, -8, 8, -8 };
static double distofst[38] = { 0, 1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6, 7, -7, 8, -8, 
	9, -9, 10, -10, 11, -11, 12, -12, 13, -13, 14, -14, 15, -15, 16, -16, 17, -17, 18, -18 };

gget( Buf, "Xfield" ); xfield = atoi( Buf );
gget( Buf, "Yfield" ); yfield = atoi( Buf );
if( xfield < 1 ) { fprintf( stderr, "1 or 2 fdata fields need to be given for distributions.\n" ); gdp_exit(); }
if( yfield < 1 ) {
	justdist = YES; 
	yfield = xfield;
	}
else justdist = NO;
gget( Buf, "Mark.field" ); markfield = atoi( Buf );

gget( c, "Mark" );
gget( Buf, "Mark.font" ); NTfont( Buf ); 
gget( Buf, "Mark.size" ); NTptsize( atof( Buf ) );
charv = Chh / 2.0;
charh = Chh / 4.0;
size = Chh * 0.4;
gget( Buf, "Cluster" ); if( Buf[0] == 'y' ) cluster = YES; else cluster = NO;
dist = NO;
gget( Buf, "Axdist" ); 
if( Buf[0] == 'y' ) { 
	dist = YES; 
	gget( Buf, "Axdist.length" ); distlen = atof( Buf );
	}
gget( Buf, "Sizefield" ); sizefield = atoi( Buf );
gget( Buf, "Sizescale" ); sizescale = atof( Buf );
gget( Buf, "Shadefield" ); shadefield = atoi( Buf );
gget( Buf, "Shadescale" ); shadescale = atof( Buf );

if( cluster ) {		/* sort the data numerically */
	/* write out data */
	fp = fopen( Tempfile, "w" );
	if( fp == NULL ) fprintf( stderr, "Distribution can't open: %s", Tempfile );	
	for( i = 0; i < N_d_rows; i++ ) {
		for( j = 0; j < N_d_fields; j++ ) fprintf( fp, "%s ", D[i][j] );
		fprintf( fp, "\n" );
		}
	fclose( fp );
	/* build Unix sort command */
	sprintf( Buf, "sort -n %s +%d -%d +%d -%d -o %s", Tempfile, xfield-1, xfield, yfield-1, yfield, Tempfile );
	system( Buf );
	fp2 = fopen( Tempfile, "r" );
	for( i = 0; i < N_d_rows; i++ ) {
		for( j = 0; j < N_d_fields; j++ ) { fscanf( fp2, "%s", D[i][j] ); }
		}
	fclose( fp2 );
	}

x = -99999.0;
y = -99999.0;
dups = 0;
for( i = 0; i < N_d_rows; i++ ) {
	if( (!goodnum( D[i][yfield-1], &p ) && !justdist) || !goodnum( D[i][xfield-1], &p )) {
		fprintf( stderr, "row %d ", i ); 
 		fprintf( stderr, "is bad: (%s,%s) (Warning)\n", D[i][xfield-1], D[i][yfield-1] );
		continue;
		}
	x = da_x( atof( D[i][xfield-1] ) );
	y = da_y( atof( D[i][yfield-1] ) );
	if( (!justdist && (y < Ylo || y > Yhi )) || x < Xlo || x > Xhi ) { 
		fprintf( stderr, "Row %d ", i );
		fprintf( stderr, "is out of bounds: (%s,%s) (Warning)\n", D[i][xfield-1], D[i][yfield-1] );
		continue; 
		}  
	if( cluster && (x == prevx && y == prevy ) ) {
		dups++;
		if( dups > 36 ) dups = 1;
		if( justdist ) adjx = x + (.01*distofst[dups]);
		else adjx = x + (.01*xofst[dups]);
		adjy = y + (.01*yofst[dups]);
		}
	else	{
		dups = 0;
		prevx = x;
		prevy = y;
		adjx = x;
		adjy = y;
		}
	if( !justdist ) {
		if( sizefield > 0 && sizefield <= 24 ) {
			size = ( atof( D[i][sizefield-1] ) * sizescale) / 144.0; 
			if( size < 0.001 || size > 3 ) {
				fprintf( stderr, "warning, rec. %d, abnormal size data value\n", i  ); 
				}
			}
		if( shadefield > 0 && shadefield <= 24 ) {
			shade = atof( D[i][shadefield-1] ) * shadescale;
			if( shade < 0 || shade > 1 ) {
				fprintf( stderr, "warning, rec %d, abnormal shade data value, truncated.\n", i );
				if( shade < 0 ) shade = 0;
				if( shade > 1 ) shade = 1;
				}
			sprintf( c, "%s%4.2f", c, shade );
			}
			
			
		if( strncmp( c, "sym", 3 )==0 ) {
			point( adjx, adjy, c, size );
			c[5] = '\0'; /* get rid of shade if any */
			}
		if( markfield || strncmp( c, "sym", 3 )!=0 ) {
			NTmov( (adjx-(charh*0.20))-1, adjy-(charv*0.48) );
			if( markfield ) NTcentext( D[i][markfield-1], 2.0 );
			else NTcentext( c, 2.0 );
			}
		}
	else if( justdist ) {
		NTmov( adjx, Ylo ); NTlin( adjx, Yhi );
		}
	if( dist && !justdist ) {
		NTmov( Xhi, adjy ); NTlin( Xhi+distlen, adjy );
		NTmov( adjx, Yhi ); NTlin( adjx, Yhi+distlen );
		}
	}
}
SHAR_EOF
############################

echo src/Pdraw.c
cat << \SHAR_EOF > src/Pdraw.c
/* draw - for drawing with lines */
#include "ipl.x"
#define ABSOLUTE 0
#define DATA 1

EPdraw( )
{
int sys, n, i, p;
double mag, thick, x, y, x2, y2;
char ltype[10];

gget( Buf, "System" );
if( strcmp( Buf, "absolute" )==0 ) sys = ABSOLUTE;
else 	{
	sys = DATA;
	if( DXlo == 0 && DXhi == 0 ) { fprintf( stderr, "No graphics area.\n" ); gdp_exit(); }
	}

/* get line style parameters */
gget( Buf, "Linetype" ); strcpy( ltype, Buf );

gget( Buf, "Linetype.magnify" ); 
if( goodnum( Buf, &p )) mag = atof( Buf );
else mag = 1;

gget( Buf, "Linethick" ); thick = atof( Buf );


/* set line style */
NTlinetype( ltype, thick, mag );

/* get points */
gget( Buf, "Points" );
getln( "" );
for( i = 0; i < countln( Buf ); i++ ) {
	n = sscanf( getln( Buf ), "%lf %lf %lf %lf", &x, &y, &x2, &y2 );
	if( sys == DATA && n == 2 ) NTl( x, y );
	else if( sys == DATA && n == 2 && i == 0 ) NTm( x, y );
	else if( sys == DATA && n == 4 ) { NTm( x, y ); NTl( x2, y2 ); }
	else if( sys == ABSOLUTE && n == 2 ) NTlin( x, y );
	else if( sys == ABSOLUTE && n == 2 && i == 0 ) NTmov( x, y );
	else if( sys == ABSOLUTE && n == 4 ) { NTmov( x, y ); NTlin( x2, y2 ); }
	else { fprintf( stderr, "Points should contain either one or two coord pairs per line.\n" ); gdp_exit(); }
	}

NTnormline(); /* return line to normal */
}	
SHAR_EOF
############################

echo src/Perrorbars.c
cat << \SHAR_EOF > src/Perrorbars.c
#include "ipl.x"

EPerrorbars( )
{
int i, xfld, yfld, efld, dubl;
double x, y, err, tlen, ofs;

gget( Buf, "Xfield" );
xfld = atoi( Buf );
if( xfld < 1 || xfld > 24 ) { fprintf( stderr, "Xfield bad.\n" ); gdp_exit(); }

gget( Buf, "Yfield" );
yfld = atoi( Buf );
if( yfld < 1 || yfld > 24 ) { fprintf( stderr, "Yfield bad.\n" ); gdp_exit(); }

gget( Buf, "Errfield" );
efld = atoi( Buf );
if( efld < 1 || efld > 24 ) { fprintf( stderr, "Errfield bad.\n" ); gdp_exit(); }

gget( Buf, "Offset" );
ofs = atof( Buf );

gget( Buf, "Double" );
if( Buf[0] == 'y' ) dubl = 1;
else dubl = 0;

gget( Buf, "Linethick" );
if( strlen( Buf ) > 0 ) NTlinetype( "0", atof( Buf ), 1.0 );

gget( Buf, "Taillen" );
if( strlen( Buf ) > 0 ) tlen = atof( Buf );

for( i = 1; i <= N_d_rows; i++ ) {
	x = atof( D[i-1][xfld-1] ) ;
	y = atof( D[i-1][yfld-1] );
	err = atof( D[i-1][efld-1] );
	if( dubl ) err *= 2.0;

	NTmov( da_x(x)+ofs, da_y(y) ); /* top bar */
	NTlin( da_x(x)+ofs, da_y(y+err) );
	NTmov( (da_x(x)-(tlen/2))+ofs, da_y(y+err) ); /* tail */
	NTlin( da_x(x)+(tlen/2)+ofs, da_y(y+err) );
	
	NTmov( da_x(x)+ofs, da_y(y) ); /* bottom bar */
	NTlin( da_x(x)+ofs, da_y(y-err) );
	NTmov( (da_x(x)-(tlen/2))+ofs, da_y(y-err) ); /* tail */
	NTlin( da_x(x)+(tlen/2)+ofs, da_y(y-err) );
	
	}

NTnormline();
}
SHAR_EOF
############################

echo src/Pfilld.c
cat << \SHAR_EOF > src/Pfilld.c
/* returns 1 if data was converted, 0 if not. */

#include "elib.x"
#include "ipl.h"

static int fillflag = 0;
static int curobjid = -1;

EPfilld( p )
int p; /* ref. to a plotting object */
{
char *obj, *txt, *tok;
int i, ix, j, ixx, id, len;
int oldix; /* scg 1-22-96 */

obj = EIgetc( p, "", "Plot/Datasource", &len );    /* get the textb which holds the data.. */
if( len < 1 ) return( 0 );

id = Egetid( obj );

if( id == curobjid && ! fillflag ) return( 0 ); /* do a scan if we are given a different textb,
							or if notified that the body of text changed. */
curobjid = id;
fillflag = 0;

txt = EIgetc( id, "", "text", &len );

ixx = 0;
N_d_rows = 0;
N_d_fields = 0;
oldix = -1;
for( i = 0, ix = 0; ix < len; i++ ) {
	if( i >= MAX_D_ROWS ) {
		fprintf( stderr, "Reaching max. of %d rows.\n", MAX_D_ROWS );
		break;
		}
	Egetchunk( Buf, txt, &ix, "\n" );
	if( ix == oldix ) break; /* no more lines.. (scg 1-22-96) */
	else oldix = ix;

	if( strlen( Buf ) < 1 ) continue;
	for( j = 0, ixx = 0; j < MAX_D_COLS; j++ ) {
		tok = Egetok( Buf, &ixx );
		if( strlen( tok ) < 1 ) break;
		else if( strlen( tok ) >= DATAITEM_LEN-1 ) {
			fprintf( stderr, "Item too long (row %d field %d).\n", i+1, j+1 );
			strncpy( D[i][j], tok, DATAITEM_LEN -2 );
			D[i][j][DATAITEM_LEN - 1 ] = '\0';
			} 
		else strcpy( D[i][j], tok );
		}
	if( N_d_fields < 1 ) N_d_fields = j;
	N_d_rows ++;
	}
return( 1 );
}

/* ====================================== */
/* This is called by gr when text is modified, so that the D array can be updated */

EPrefreshplotdata( p )
{
if( p == curobjid ) fillflag = 1;
}
SHAR_EOF
############################

echo src/Pgen.c
cat << \SHAR_EOF > src/Pgen.c
/* gen routine for plot */
#include "ipl.x"

EPgenipl( name, p )
char name[];
int p;
{

EPcurp = p;

if( EPsetupzone( p ) == 0 ) return(0); /* set the ipl scaling */
EPfilld( p ); 			/* transfer the data from a textb to the ipl D structure */


if( strcmp( name, "Axes" )==0 ) EPaxes();
else if( strcmp( name, "Lineplot" )==0 ) EPlineplot();
else if( strcmp( name, "Bargraph" )==0 ) EPbargraph();
else if( strcmp( name, "Horizbar" )==0 ) EPhorizbar();
else if( strcmp( name, "Pie" )==0 ) EPpie();
else if( strcmp( name, "Map" )==0 ) EPmap();
else if( strcmp( name, "Legend" )==0 ) EPlegend();
else if( strcmp( name, "Distribution" )==0 ) EPdistribution();
else if( strcmp( name, "Errorbars" )==0 ) EPerrorbars();
else if( strcmp( name, "Draw" )==0 ) EPdraw();
}

/* ======================================== */
/* set up a scaled zone for plots */

EPsetupzone( p )
int p;
{
char *tag, *zone, *xscaletype, *yscaletype;
double *xlo, *ylo, *xhi, *yhi;
double *x1, *y1, *x2, *y2;
int len, zp;
double zero, one;

zero = 0.0;
one = 1.0;

tag = EIgetc( p, "", "*/tag", &len );
zone = EIgetc( p, "", "Plot/Zone", &len );
if( len < 1 ) { 
	fprintf( stderr, "Plot object %s must have a Plot/Zone specified.\n", tag ); 
	return( 0 ); 
	}

zp = Egetid( zone );

if( strcmp( EIgetobjname( zp ), "scalezone" )!= 0 ) {
	fprintf( stderr, "Plot/Zone must refer to an object of type 'scalezone'.\n" );
	return( 0 );
	}

x1 = EIgetd( zp, "*", "bb", &len );
y1 = x1 + 1;
x2 = x1 + 2;
y2 = x1 + 3;

xlo = EIgetd( zp, "", "xrange", &len );
if( len != 2 ) { xlo = &zero; xhi = &one; }
else xhi = xlo + 1;
ylo = EIgetd( zp, "", "yrange", &len );
if( len != 2 ) { ylo = &zero; yhi = &one; }
else yhi = ylo + 1;

xscaletype = EIgetc( zp, "", "xscaletype", &len );
yscaletype = EIgetc( zp, "", "yscaletype", &len );

if( strcmp( xscaletype, "linear" )==0 ) Scale_discipline_x = LINEAR;
else if( strcmp( xscaletype, "log" )==0 ) Scale_discipline_x = LOG;
else if( strcmp( xscaletype, "yymm" )==0 ) Scale_discipline_x = YYMM;

if( strcmp( yscaletype, "linear" )==0 ) Scale_discipline_y = LINEAR;
else if( strcmp( yscaletype, "log" )==0 ) Scale_discipline_y = LOG;
else if( strcmp( yscaletype, "yymm" )==0 ) Scale_discipline_y = YYMM;

setscale_x( *x1, *x2 , *xlo, *xhi );
setscale_y( *y1, *y2, *ylo, *yhi );

return( 1 );
}
SHAR_EOF
############################

echo src/Phorizbar.c
cat << \SHAR_EOF > src/Phorizbar.c
#include "ipl.x"
#define STACK	0
#define CLUSTER 1


EPhorizbar( )
{
int 	k[8], 
	idf[8],
	format,
	label,
	n,
	nc,
	i, j, jj,
	p,
	start,
	yset,
	yfld,
	outline;

double s[8],
	accum,
	zer,
	cury,
	yspace,
	subspace,
	x,
	x2,
	f,
	lblpos,
	sep,
	msep = 0.03;
char str[10];


/* get the data field list */
gget( Buf, "Field" ); 
n = 0;
while( n < 1 ) { 
	n = sscanf( Buf, "%d %d %d %d %d %d %d %d", &k[0], &k[1], &k[2], &k[3], &k[4], &k[5], &k[6], &k[7] );
	if( N_d_fields == 1 ) strcpy( Buf, "1" );
	else if( n < 1 ) { fprintf( stderr, "Field bad\n" ); gdp_exit(); }
	}
for( i = 0; i < n; i++ ) 
	if( k[i] < 1 || k[i] > N_d_fields ) { fprintf( stderr, "Field out of range" ); gdp_exit(); }

/* get the label field list, if any */
gget( Buf, "Idfield" ); 
if( strlen( Buf ) > 0 ) { 
	label = YES;
	sscanf( Buf, "%d %d %d %d %d %d %d %d", &idf[0], &idf[1], &idf[2], &idf[3], &idf[4], &idf[5], &idf[6], &idf[7] );
	for( i = 0; i < n; i++ ) 
		if( idf[i] < 1 || idf[i] > N_d_fields ) { fprintf( stderr, "Idfield bad.\n" ); gdp_exit(); }
	}
else label = NO;


gget( Buf, "Format" );  
if( strcmp( Buf, "stack" )==0 ) format = STACK;
else format = CLUSTER;

DYtic = 1.0;

/* get bar shades */
gget( Buf, "Shade" ); 
sscanf( Buf, "%lf %lf %lf %lf %lf %lf %lf %lf", &s[0], &s[1], &s[2], &s[3], &s[4], &s[5], &s[6], &s[7] );

/* get zero line */
gget( Buf, "Zeroat" ); 
if( goodnum( Buf, &p )) zer = atof( Buf );
else zer = DXlo;

/* get label size */
if( label ) { gget( Buf, "Idfield.size" ); NTptsize( atof( Buf ) ) };

/* distance of label from bar top */
if( label ) { gget( Buf, "Idfield.position" ); lblpos = atof( Buf ); }

/* outline or not */
gget( Buf, "Outlinebars" ); if( Buf[0] == 'y' ) outline = YES; else outline = NO;

/* x distance between major bar spaces */
gget( Buf, "Separation" ); sep = atof( Buf );

gget( Buf, "Separation.sub" ); msep = atof( Buf );

yspace = ( (Yhi-Ylo)/((DYhi-DYlo)+1) ) - (sep*Scale_y);

if( format == CLUSTER ) nc = n; else nc = 1;

gget( Buf, "Killwild" ); /* option for aborting plot if any values out of range */
if( atof( Buf ) != 0 ) {
	for( i = 1; i <= N_d_rows; i++ ) {
		if( atof( D[i-1][ k[0] -1 ] ) > atof( Buf ) ) {
			fprintf( stderr, "Note: This Vbargraph terminated due to a value of %s.\n", D[i-1][k[0]-1] );
			return( 0 );
			}
		}
	}

gget( Buf, "Yfield" ); /* allow placement of bars by a data field */
if( strlen( Buf ) > 0 ) {
	yset = 1;
	yfld = atoi( Buf );
	if( yfld < 1 || yfld > N_d_fields ) { fprintf( stderr, "Yfield bad.\n" ); gdp_exit(); }
	yspace = sep;
	}
else yset = 0;

gget( Buf, "Ystart.0or1" ); /* allow starting at 0 or 1 */
if( Buf[0] == '0' ) { start = 0; }
else { start = 1; }

for( i = 1; i <= N_d_rows; i++ ) {
	if( yset ) cury = da_y( atof( D[i-1][yfld-1] ) ) - (yspace/2);
	else cury = da_y((double)(DYlo+i+(start-1))) - (yspace/2);
	subspace = ( yspace / nc );
	for( j = 0; j < nc; j++ ) {
		if( !goodnum( D[i-1][ k[j]-1 ], &p )) {
			fprintf( stderr, "Warning: row %d, field %d, is bad (%s)\n", i, k[j], D[i-1][ k[j]-1] );
			cury += subspace;
			continue;
			}
		x = atof(D[i-1][ k[j]-1 ]);
		if( x != DXlo )
		    ab_rect( da_x(zer), cury, da_x(x), cury+(subspace-msep), s[j], (s[j]==1)?1:outline );
		if( label ) {
			if( x < zer || format == STACK ) f = (-lblpos)-Chh; else f = lblpos;
			strcpy( str, D[i-1][ idf[j]-1 ] );
			NTmov( da_x(x)+f, cury );
			NTtext( str ); /* will change */
			}
		if( format == STACK ) for( jj = 1; jj < n; jj++ ) {
			if( !goodnum( D[i-1][ k[jj] -1 ], &p ) ) {
				fprintf( stderr, "Warning: row %d, field %d, is bad (%s)\n", i, k[jj], D[i-1][k[jj]-1] );
				continue;
				}
			x2 = x + atof( D[i-1][ k[jj] -1 ] );
			if( x2 != DXlo )
			   ab_rect( da_x(x), cury,  da_x(x2), cury+(subspace-msep), s[jj], (s[jj]==1)?1:outline );
			if( label ) {
				if( x2 < zer || format == STACK ) f = (-lblpos)-Chh; else f = lblpos;
				NTmov( da_x(x2)+f, cury );
				strcpy( str, D[i-1][ idf[jj]-1 ] );
				NTtext( str );
				}
			x = x2;
			}

		cury += subspace;
		}
	}

gget( Buf, "Segment" );
if( Buf[0] == 'y' ) 
	for( f = DXlo+DXtic; f < DXhi; f += DXtic ) 
		rect(  f-(DXhi*0.003), DYlo + 0.2, f+(DXhi*0.004), DYhi - 0.2, (double)WHITE, 0 );
}
SHAR_EOF
############################

echo src/Plegend.c
cat << \SHAR_EOF > src/Plegend.c
/* legend() - creates legend for line and bar graphs */
#include "ipl.x"
#define SHADE	1
#define MARK	4	
#define LINE	8	
#define MAXENTRIES 10

EPlegend( )
{
double	val[MAXENTRIES],
	margin,
	piclen,
	lablen,
	depth,
	x, ylo, yhi,
	lx, ly, cx, cy, bxw, ty,
	mrksize,
	stdsize,
	pm[MAXENTRIES],
	ms[MAXENTRIES],
	th[MAXENTRIES],
	thick = 1,
	magnify;
int 	i, 
	n,
	format,
	lenmax, 
	outline,
	nms,
	nlt,
	npm,
	nth,
	nmf,
	nent;
char 	ent[MAXENTRIES][100],
	poscode[4],
	stdfont[FONTNAME_LEN],
	mrkfont[FONTNAME_LEN],
	lt[MAXENTRIES][3],
	mrk[MAXENTRIES][10],
	mf[MAXENTRIES][20],
	linetype[3];



gget( Buf, "Entry.font" );
strcpy( stdfont, Buf ); NTfont( Buf ); /* go to standard font */

strcpy( mrkfont, Stdfont ); /* default mark font */

/* position of legend can either be specified using a corner A,B,C,D or by giving an
   x,y location for the upper left corner of the legend.
*/
lx = Xlo; ly = Yhi;



/* get entries and find longest one */
gget( Buf, "Entry" );
lenmax = 0;
nent = countln( Buf );
if( nent > MAXENTRIES ) { fprintf( stderr, "Maximum of 10 legend entries" ); nent = 10; }
getln( "" );
for( i = 0; i < nent; i++ ) {
	strcpy( ent[i], getln( Buf ) );
	if( strlen( ent[i] ) > lenmax ) lenmax = strlen( ent[i] ); 
	}

/* figure if we're doing lines or shades, and get 'em */
format = 0;
gget( Buf, "Shade" ); 
if( strlen( Buf ) > 0 ) { 
	format = SHADE; 
	n = sscanf( Buf, "%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf", 
		&val[0],&val[1],&val[2],&val[3],&val[4],&val[5],&val[6],&val[7],&val[8],&val[9] );
	if( n < nent ) { fprintf( stderr, "need %d shades.\n", nent ); gdp_exit(); }
	}
gget( Buf, "Linetype" );
if( strlen( Buf ) > 0 ) {
	format = LINE;
	nlt = sscanf( Buf, "%s %s %s %s %s %s %s %s %s %s", 
		lt[0],lt[1],lt[2],lt[3],lt[4],lt[5],lt[6],lt[7],lt[8],lt[9] );
	gget( Buf, "Linetype.magnify" );
	npm = sscanf( Buf, "%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf", 
		&pm[0],&pm[1],&pm[2],&pm[3],&pm[4],&pm[5],&pm[6],&pm[7],&pm[8],&pm[9] );
	gget( Buf, "Linethick" );
	nth = sscanf( Buf, "%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf", 
		&th[0],&th[1],&th[2],&th[3],&th[4],&th[5],&th[6],&th[7],&th[8],&th[9] );
	}


gget( Buf, "Mark" );
if( strlen( Buf ) > 0 ) {
	format += MARK;
	n = sscanf( Buf, "%s %s %s %s %s %s %s %s %s %s", 
		mrk[0],mrk[1],mrk[2],mrk[3],mrk[4],mrk[5],mrk[6],mrk[7],mrk[8],mrk[9] );
	if( n < nent ) { fprintf( stderr, "need %d marks\n", nent ); gdp_exit(); }

	gget( Buf, "Mark.font" );
	nmf = sscanf( Buf, "%s %s %s %s %s %s %s %s %s %s",
		mf[0], mf[1], mf[2], mf[3], mf[4], mf[5], mf[6], mf[7], mf[8], mf[9] );

	gget( Buf, "Mark.size" ); 
	nms = sscanf( Buf, "%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf", 
		&ms[0],&ms[1],&ms[2], &ms[3], &ms[4], &ms[5], &ms[6], &ms[7], &ms[8], &ms[9] );
	}


margin = .20;
lablen = lenmax * (Chh*0.6); /* lenmax = space in plot units of longest label */

if( format == SHADE || format == MARK ) piclen = .20;  /* piclen = size in x of line or swatch */
else piclen = 1.10;

depth = (Chh*1.2) * (nent+1);
if( format == SHADE ) depth *= 1.65;

/* generate legend */

/* do a legend title */
gget( Buf, "Title.size" );
NTptsize( atof( Buf ) );
gget( Buf, "Title" );
ty = ly + (countln( Buf ) * Chh);
getln( "" );
for( i = 0; i < countln( Buf ); i++ ) {
	NTmov( lx, ty );
	NTcentext( getln( Buf ), (lablen+piclen) );
	ty -= Chh;
	}

gget( Buf, "Entry.size" ); stdsize = atof( Buf ); NTptsize( stdsize );

gget( Buf, "Backshade" );
if( strlen( Buf ) > 0 ) {
	ab_rect( lx-.08, ly - (depth)+0.02, lx+(lablen+piclen), ly+.08, atof( Buf ), 0 );
	}
gget( Buf, "Outlinebars" );
if( Buf[0] == 'y' ) outline = YES;
else outline = NO;

cx = lx; cy = ly;
for( i = 0; i < nent; i++ ) {

	if( format >= MARK && i < nms ) mrksize = ms[i];
	if( format >= LINE && i < nlt ) strcpy( linetype, lt[i] );
	if( format >= LINE && i < npm ) magnify = pm[i];
	if( format >= LINE && i < nth ) thick = th[i];
	if( format >= MARK && i < nmf ) strcpy( mrkfont, mf[i] );

	/* trap */ if( format >= LINE && ( thick < 0.01 || thick > 20 )) { 
		fprintf( stderr, "Internal error. Try again.\n" ); gdp_exit(); 
		}

	if( format == SHADE || format == MARK ) {
		if( format == SHADE ) {
			cy -= 0.1; x = cx; bxw =  0.2; ylo = cy - 0.1; yhi = cy + 0.1;
			if( outline || val[i] == 1.0 )ab_rect( x, ylo, x+bxw, yhi, val[i], 1 );
			else ab_rect( x, ylo, x+bxw, yhi, val[i], 0 );
			}
		else if( format == MARK ) { 
			NTfont( mrkfont ); NTptsize( mrksize );
			if( strncmp( mrk[i], "sym", 3 )==0 ) point( cx, cy, mrk[i], Chh*0.4 );
			else {
				NTmov( cx, cy-0.06 ); 
				NTtext( mrk[i] ); 
				NTfont( stdfont ); 
				}
			NTmov( cx, cy ); 
			NTfont( stdfont ); NTptsize( stdsize );
			}
		NTmov( cx+0.4, cy-0.06 );
		NTtext( ent[i] );
		}
	else if( format >= LINE ) {
		NTlinetype( linetype, thick, magnify );
		NTmov( cx, cy );
		NTlin( cx+1.0, cy );
		if( format == LINE + MARK ) {
			NTfont( mrkfont ); NTptsize( mrksize );
			if( strncmp( mrk[i], "sym", 3 )==0 ) {
				point( cx+0.2, cy, mrk[i], Chh*0.4 );
				point( cx+0.8, cy, mrk[i], Chh*0.4 );
				}
			else {
				NTfont( mrkfont ); NTptsize( mrksize ); 
				NTmov( cx+0.2, cy-0.03 ); NTtext( mrk[i] );
				NTmov( cx+0.8, cy-0.03 ); NTtext( mrk[i] ); 
				NTfont( stdfont ); NTptsize( stdsize );
				}
			NTfont( stdfont ); NTptsize( stdsize );
			}
		NTmov( cx+1.1, cy-0.06 );
		NTtext( ent[i] );
		NTnormline();
		}
	cy -= (Chh*1.2); 
	}
}
SHAR_EOF
############################

echo src/Plineplot.c
cat << \SHAR_EOF > src/Plineplot.c
#include "ipl.x"

EPlineplot( )
{
int 	i, j, p,
	ncurves,
	xfield, yf[10],
	nlab,
	nmrk,
	nsh,
	number,
	nums,
	accum,
	stair,
	x0or1,
	stairbars;
	
double 	prvx, prvy,
	x, y,
	cx, cy,
	lblsiz,
	mrksiz,
	size,
	nofs,
	zer,
	pm[10],
	th[10],
	sh[10];

char 	lt[10][3],
	lb[10][20],
	str[12],
	mk[10][10];


/* get data fields */
gget( Buf, "Xfield" ); 
xfield = atoi( Buf );

gget( Buf, "Xstart.0or1" );
x0or1 = atoi( Buf );

gget( Buf, "Yfield" ); 
ncurves = sscanf( Buf, "%d %d %d %d %d %d %d %d %d %d", 
	&yf[0], &yf[1], &yf[2], &yf[3], &yf[4], &yf[5], &yf[6], &yf[7], &yf[8], &yf[9]  );
for( i = 0; i < ncurves; i++ ) if( yf[i] < 1 || yf[i] > N_d_fields ) { fprintf( stderr, "Yfield bad.\n" ); gdp_exit(); }
if( ncurves < 1 ) { fprintf( stderr, "Yfield must be specified.\n" ); gdp_exit(); }

gget( Buf, "Accum" ); if( Buf[0] == 'y' ) accum = YES; else accum = NO;


/* get line parameters for curves */
gget( Buf, "Linetype" );
sscanf( Buf, "%s %s %s %s %s %s %s %s %s %s", 
	lt[0],lt[1],lt[2],lt[3],lt[4],lt[5],lt[6],lt[7],lt[8],lt[9] );
gget( Buf, "Linetype.magnify" );
sscanf( Buf, "%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf", 
	&pm[0],&pm[1],&pm[2],&pm[3],&pm[4],&pm[5],&pm[6],&pm[7],&pm[8],&pm[9] );
gget( Buf, "Linethick" );
sscanf( Buf, "%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf", 
	&th[0],&th[1],&th[2],&th[3],&th[4],&th[5],&th[6],&th[7],&th[8],&th[9] );
gget( Buf, "Mark" );
nmrk = sscanf( Buf, "%s %s %s %s %s %s %s %s %s %s", 
	mk[0],mk[1],mk[2],mk[3],mk[4],mk[5],mk[6],mk[7],mk[8],mk[9] );
gget( Buf, "Mark.size" ); mrksiz = atof( Buf );
NTptsize( mrksiz );
size = Chh * 0.4;

gget( Buf, "Shade" );
nsh = sscanf( Buf, "%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf", 
	&sh[0],&sh[1],&sh[2],&sh[3],&sh[4],&sh[5],&sh[6],&sh[7],&sh[8],&sh[9] );
gget( Buf, "Zeroat" ); zer = atof( Buf );

gget( Buf, "Label" );
nlab = countln( Buf );
getln( "" );
for( i = 0; i < nlab; i++ ) {
	strcpy( lb[i], getln( Buf ) );
	}

gget( Buf, "Stairstep" ); if( Buf[0] == 'y' ) stair = YES; else stair = NO;
gget( Buf, "Stairstep.bars" ); 
if( Buf[0] == 'y' ) { stairbars = YES; stair = YES; }
else stairbars = NO; /* for steps over bars */

gget( Buf, "Label.size" ); lblsiz = atof( Buf );

gget( Buf, "Numberfinal" ); if( Buf[0] == 'y' ) number = YES; else number = NO;
gget( Buf, "Numbers" ); if( Buf[0] == 'y' ) nums = YES; else nums = NO;
gget( Buf, "Numbers.offset" ); nofs = atof( Buf );

NTptsize( lblsiz );

/* do shading */
for( j = 0; j < ncurves; j ++ ) {
	if( nsh >= j ) {
		if( stair ) fprintf( stderr, "warning, stairstep can't be combined with shading\n" ); 
		y = atof( D[0][yf[j]-1] );
		if( x0or1 ) x = 1;
		else x = atof( D[0][xfield-1] );
		/* Eobjbegin( "#Shade" ); */
		NTm( x, zer );
		NTp( x, y );
		for( i = 0; i < N_d_rows-1; i++ ) {
			/* get current x, y */
			if( xfield < 1 ) x = i + 2;
			else x = atof( D[i+1][xfield-1] );
			if( accum ) y += atof( D[i+1][yf[j]-1] );
			else y = atof( D[i+1][yf[j]-1] );
			NTp( x, y );
			}
		NTp( x, zer );
		NTshade( sh[j] );
		Eobjend( "B" );
		}
	}

/* do the curves */
for( j = 0; j < ncurves; j ++ ) {

	/* Eobjbegin( "#Lineplot" ); */

	NTlinetype( lt[j], th[j], pm[j] );

	/* find 1st y */
	y = atof( D[0][yf[j]-1] );
	/* find 1st x */
	if( x0or1 ) {
		if( stairbars ) x = 0.5;
		else x = 1;
		}
	else x = atof( D[0][xfield-1] );
	prvx = x;
	prvy = y;
	
	/* move to beginning of line */
	NTm( x, y );

	for( i = 0; i < N_d_rows-1; i++ ) {

		/* skip bad values.. */
		if( ! goodnum( D[i+1][yf[j]-1], &p ) ) {
			fprintf( stderr, "Warning, row %d field %d is bad (%s)\n", i+2, yf[j], D[i+1][yf[j]-1] );
			continue;
			}
		

		/* get current x, y */
		if( xfield < 1 ) {
			if( stairbars ) x = i+1.5;
			else x = i+2;
			}
		else 	x = atof( D[i+1][xfield-1] );
		if( accum ) y += atof( D[i+1][yf[j]-1] );
		else y = atof( D[i+1][yf[j]-1] );

		/* if doing stairsteps, get last x and y */
		if( stair ) { 
			if( xfield < 1 ) {
				if( stairbars ) prvx = i + .5 ;
				else prvx = i+1;
				}
			else prvx = atof( D[i][xfield-1] );
			if( accum ) prvy += atof( D[i][yf[j]-1] );
			else prvy = atof( D[i][yf[j]-1] );
			
			NTl( x, prvy );
			if( nums ) { 
				NTmov( da_x(prvx), da_y(prvy)+nofs );
				sprintf( str, DYticfmt, prvy );
				NTcentext( str, da_x(x)-da_x(prvx) ); 
				NTm( x, prvy ); 
				}
			}
		NTl( x, y );
		if( nums && ! stair ) { 
			sprintf( str, DYticfmt, y );
			NTmov( da_x(x)-1, da_y(y)+nofs );
			NTcentext( str, 2.0 ); NTm( x, y ); 
			}
		}
	
	if( stair ) { /* give line a tail */
		if( nums ) { sprintf( str, DYticfmt, y ); NTmov( da_x( x ), da_y( y )+nofs ); NTtext( str ); }
		NTm( x, y );
		gget( Buf, "Taillen" );
		if( atof( Buf ) > 0 ) x += atof( Buf );
		else x += (DXtic*.7);
		NTl( x, y );
		}
	if( nlab > 0 ) {
		/* Eobjbegin( "#Label" ); */
		NTmov( da_x( x )+ 0.05, da_y( y ) - (Chh/2) );
		NTtext( lb[j] );
		Eobjend( "B" );
		}
	if( number ) {
		sprintf( str, DYticfmt, y );
		NTmov( da_x( x )+ 0.05, da_y( y ) + (Chh/1.8) );
		NTtext( str );
		}
	/* put marks on lines */
	if( nmrk >= j ) {
		if( stair )fprintf( stderr, "warning, stairstep can't be combined with point marks\n"); 
		y = atof( D[0][yf[j]-1] );
		if( x0or1 ) x = 1;
		else x = atof( D[0][xfield-1] );
		if( strncmp( mk[j], "sym", 3 )==0 ) point( da_x( x ), da_y( y ), mk[j], size );
		for( i = 0; i < N_d_rows-1; i++ ) {
			/* get current x, y */
			if( xfield < 1 ) x = i + 2;
			else x = atof( D[i+1][xfield-1] );
			if( accum ) y += atof( D[i+1][yf[j]-1] );
			else y = atof( D[i+1][yf[j]-1] );
			if( strncmp( mk[j], "sym", 3 )==0 ) point( da_x( x ), da_y( y ), mk[j], size );
			}
		}
	Eobjend( "B" );
	}
NTnormline();
}
SHAR_EOF
############################

echo src/Pmap.c
cat << \SHAR_EOF > src/Pmap.c
/* usa and canada map, with state distributions expressed by shading */
#include "ipl.x"
#include "mapdata.h"
#define USA_ONLY 1
#define USA_CANADA 2
#define CANADA_ONLY 3

EPmap( )
{
int i, j, k, slot;
int valfield, statefield;
int nt, ns;
int start, stop;
int ctry;
double t[15], s[15];
double stab[50], ptab[12];
double sshade[50], pshade[12];
double thick, y;
FILE *fp;
char ans[10];

gget( Buf, "Country" );
if( strcmp( Buf, "usa" )==0 ) ctry = USA_ONLY;
if( strcmp( Buf, "usa+canada" )==0 ) ctry = USA_CANADA;
if( strcmp( Buf, "canada" )==0 ) ctry = CANADA_ONLY;

NTm( usa[0], usa[1] );
for( i = 0; i < nusa*2; i+=2 ) NTp( usa[i], usa[i+1] );
NTshade( 1.0 );
NTm( canada[0], canada[1] );
for( i = 0; i < ncanada*2; i+=2 ) NTp( canada[i], canada[i+1] );
NTshade( 1.0 );

gget( Buf, "Mode" ); 
if( strcmp( Buf, "country" )==0 ) goto COUNTRY_OUTLINE;
else if( strcmp( Buf, "state" )==0 ) goto STATE_OUTLINE;
/* else mode should be state-distribution */

gget( Buf, "Valfield" ); 
if( Buf[0] == '\0' ) valfield = 0;
else valfield = atoi( Buf );

gget( Buf, "Statefield" );
if( strlen( Buf ) < 1 ) { fprintf( stderr, "Statefield (containing state abreviations) is missing.\n" ); gdp_exit(); }
statefield = atoi( Buf );

/* add up data */
for( i = 0; i < nsi; i++ ) stab[i] = 0;
for( i = 0; i < npi; i++ ) ptab[i] = 0;

/* NTclip_on(); */

/* for each row of data.. */
for( i = 0; i < N_d_rows; i++ ) {

	/* check state list */
 	for( j = 0; j < nsi*2; j+=2 ) if( strcmp( D[ i ][ statefield-1 ], sindex[ j+1 ] )==0 ) break;

	if( j >= (nsi*2) ) { /* not a state, check provinces */
		for( j = 0; j < npi*2; j+=2 ) if( strcmp( D[i][ statefield-1 ], pindex[j+1 ] ) == 0 ) break;
		if( j >= (npi*2) ) { 
			fprintf( stderr, "Warning: row %d, bad state or province code (%s).\n", i, D[i][statefield-1] );
			continue;
			}
		slot = j / 2;
		/* increment counter */
		if( valfield > 0 ) ptab[ slot ] += atof( D[ i ][ valfield-1 ] );
		else if( valfield == 0 ) ptab[ slot ] += 1.0; 
		}
	else 	{
		slot = j / 2;
		/* increment counter */
		if( valfield > 0 ) stab[ slot ] += atof( D[ i ][ valfield-1 ] );
		else if( valfield == 0 ) stab[ slot ] += 1.0;
		}
	}

gget( Buf, "Threshold" ); 
nt = sscanf( Buf, "%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",&t[0],&t[1],&t[2],&t[3],&t[4],&t[5],&t[6],&t[7],&t[8],&t[9] );
gget( Buf, "Shade" );
ns = sscanf( Buf, "%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",&s[0],&s[1],&s[2],&s[3],&s[4],&s[5],&s[6],&s[7],&s[8],&s[9] );

/* assign shades */
for( i = 0; i < nsi; i++ ) {
	for( j = 0; j < nt; j++ ) 
		if( stab[i] < t[j] ) { sshade[i] = s[j]; break; }
	if( j == nt ) sshade[i] = s[ns-1];
	}

for( i = 0; i < npi; i++ ) {
	for( j = 0; j < nt; j++ ) 
		if( ptab[i] < t[j] ) { pshade[i] = s[j]; break; }
	if( j == nt ) pshade[i] = s[ns-1];
	}


/* shade in states */
for( i = 0; i < nsi*2; i+=2 ) {
	start = atoi( sindex[i] )*2;
	stop = atoi( sindex[i+2] )*2;
	NTm( states[ start ], states[ start+1 ] );
	for( j = start; j < stop; j+=2 ) NTp( states[ j ], states[ j+1 ] );
	NTshade( sshade[ i / 2 ] );
	}
		
	
/* shade in provinces */
for( i = 0; i < npi*2; i+=2 ) {
	start = atoi( pindex[i] )*2;
	stop = atoi( pindex[i+2] )*2;
	NTm( provinces[ start ], provinces[ start+1 ] );
	for( j = start; j < stop; j+=2 ) NTp( provinces[ j ], provinces[ j+1 ] );
	NTshade( pshade[ i / 2 ] );
	}

/* label the blocks */
NTfont( "/Helvetica" ); NTptsize( 6 ); 
NTm( 1, 1 ); NTtext( "DC" );
NTm( 4, 1 ); NTtext( "AK" );
NTm( 7, 1 ); NTtext( "HI" );
/* label province blocks (07-06-90 bah) */
NTm( 35, 1 ); NTtext( "PE" );
NTm( 38, 1 ); NTtext( "NS" );

/* do list */
gget( Buf, "List" );
if( Buf[0] == 'y' ) {
	fp = fopen( Tempfile, "w" );
	for( i = 0; i < nsi; i++ ) fprintf( fp, "%s: %3.0f\n", sname[i], stab[i] );
	for( i = 0; i < npi; i++ ) fprintf( fp, "%s: %3.0f\n", pname[i], ptab[i] );
	fclose( fp );
	sprintf( Buf, "sort %s", Tempfile );
	fp = popen( Buf, "r" );
	y = 38.8;
	NTfont( "/Helvetica" ); NTptsize( 6 ); 
	while( fgets( Buf, 100, fp ) != NULL ) {
		NTm( 40.4, y );
		NTtext( Buf );
		y-= 0.6;
		}
	fclose( fp );
	}
	

STATE_OUTLINE:
gget( Buf, "State.linethick" ); thick = atof( Buf );
NTlinetype( "0", thick, 1 );
/* outline states */
for( i = 0; i < nsi*2; i+=2 ) {
	start = atoi( sindex[i] )*2;
	stop = atoi( sindex[i+2] )*2;
	NTm( states[ start ], states[ start+1 ] );
	for( j = start; j < stop; j+=2 ) NTl( states[ j ], states[ j+1 ] );
	}
/* outline provinces */
for( i = 0; i < npi*2; i+=2 ) {
	start = atoi( pindex[i] )*2;
	stop = atoi( pindex[i+2] )*2;
	NTm( provinces[ start ], provinces[ start+1 ] );
	for( j = start; j < stop; j+=2 ) NTl( provinces[ j ], provinces[ j+1 ] );
	}

		
COUNTRY_OUTLINE:
gget( Buf, "Country.linethick" ); thick = atof( Buf );
NTlinetype( "0", thick, 1 );
NTm( usa[0], usa[1] );
for( i = 0; i < nusa*2; i+=2 ) NTl( usa[i], usa[i+1] );
NTm( canada[0], canada[1] );
for( i = 0; i < ncanada*2; i+=2 ) NTl( canada[i], canada[i+1] );


/* NTclip_off(); */
}
SHAR_EOF
############################

echo src/Ppgraphic.c
cat << \SHAR_EOF > src/Ppgraphic.c
/* small, lowlevel routines for graphics */

#include "ipl.x"

/* linear, log, time, yymm, mmddyy, polar */

/* =========================== */
/* for setting up scaling in x */
setscale_x( xlow, xhi, datalow, datahi )
double 	xlow, 	/* absolute x location of left side of the area */
	xhi, 	/* absolute x location of the right side of the area */
	datalow, /* data-units x at the left side */
	datahi;	 /* data-units x at the right side */
{
Xlo = xlow;
Xhi = xhi;
DXlo = datalow;
DXhi = datahi;
if( datahi-datalow <= 0 || xhi-xlow <= 0 ) fprintf( stderr, "wild" );
if( Scale_discipline_x == LINEAR )Scale_x = (xhi-xlow) / (datahi-datalow) ;
else if( Scale_discipline_x == LOG )Scale_x = (xhi-xlow) / log( datahi-datalow ) ;
else if( Scale_discipline_x == YYMM ) {
	Scale_x = (xhi-xlow) / ( yymm_to_i( datahi ) - yymm_to_i( datalow ));
	DXlo = yymm_to_i( datalow );
	DXhi = yymm_to_i( datahi );
	}
}

/* =========================== */
/* for setting up scaling in y */
setscale_y( ylow, yhi, datalow, datahi )
double 	ylow, 	/* absolute y location of low side of the area */
	yhi, 	/* absolute y location of high side of the area */
	datalow, /* data-units y at the low side */
	datahi;	 /* data-units y at the high side */
{
Ylo = ylow;
Yhi = yhi;
DYlo = datalow;
DYhi = datahi;
if( datahi-datalow <= 0 || yhi-ylow <= 0 ) fprintf( stderr, "wild" );
if( Scale_discipline_y == LINEAR )Scale_y = (yhi-ylow) / (datahi-datalow) ;
else if( Scale_discipline_y == LOG )Scale_y = (yhi-ylow) / log( datahi-datalow ) ;
}

/* =========================== */
/* returns an absolute x location from a data value */
double da_x( d )
double d;
{
double f;
if( Scale_discipline_x == LINEAR ) return( Xlo + (( d - DXlo ) * Scale_x ));
else if( Scale_discipline_x == LOG ) { 
	if( d-DXlo > 0.0 )return( Xlo + ( log( d - DXlo )*Scale_x )); 
	else return( Xlo );
	}
else if( Scale_discipline_x == YYMM ) {
	if( d >= 7000 ) d = yymm_to_i( d );
	return( Xlo + (( d - DXlo) * Scale_x ));
	}
}

/* =========================== */
/* returns an absolute y location from a data value */
double da_y( d )
double d;
{
if( Scale_discipline_y == LINEAR ) return( Ylo + (( d - DYlo ) * Scale_y ));
else if( Scale_discipline_y == LOG ) {
	if( d-DYlo > 0.0 )return( Ylo + ( log( d - DYlo )*Scale_y ));
	else return( Ylo );
	}
}


/* =========================== */
/* returns a data x location from an abs value */
double ab_x( d )
double d;
{
if( Scale_discipline_x == LINEAR ) return( ( d - da_x( 0.0 ) ) / Scale_x );
else if( Scale_discipline_x == LOG ) return( exp( (d-Xlo) / Scale_x ) );
}


/* =========================== */
/* returns a data y location from an abs value */
double ab_y( d )
double d;
{
if( Scale_discipline_y == LINEAR ) return( ( d - da_y( 0.0 ) ) / Scale_y );
else if( Scale_discipline_y == LOG ) return( exp( (d-Ylo) / Scale_y ) );
}


/* ============================ */
/* Returns an integer given a YYMM date.  Jan 1970 is zero. */

yymm_to_i( m )
double m;
{
int yr, mo;

yr = (int)(m) / 100;
if( yr < 70 ) yr += 100;
mo = (int)(m) % 100;
return( ((yr-70)*12 ) + mo );
}

SHAR_EOF
############################

echo src/Ppie.c
cat << \SHAR_EOF > src/Ppie.c
#include "ipl.x"

/* pie graph, built within the scalezone (but no scaling is used) */

EPpie( )
{
int i, f, first, ns, explode;
double theta, val, stop;
double hx, hy, x, y, r;
double sh[20], lt;
double u, ux, uy, adj;

gget( Buf, "Field" );
f = atoi( Buf );

/*
 * gget( Buf, "Center" );
 * sscanf( Buf, "%lf %lf", &hx, &hy );
 */
hx = Xlo + ((Xhi-Xlo)/2.0);
hy = Ylo + ((Yhi-Ylo)/2.0);

/*
 * gget( Buf, "Radius" );
 * r = atof( Buf );
 */
r = ((Xhi-Xlo)/2.0) - 0.2;

gget( Buf, "Linethick" );
lt = atof( Buf );
NTlinetype( "0", lt, 1.0 );

gget( Buf, "Explode" );
u = atof( Buf );

gget( Buf, "Rotate" );
adj = atof( Buf );

gget( Buf, "Shade" );
ns = sscanf( Buf, "%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
  &sh[0],&sh[1],&sh[2],&sh[3],&sh[4],&sh[5],&sh[6],&sh[7],&sh[8],&sh[9],
  &sh[10],&sh[11],&sh[12],&sh[13],&sh[14],&sh[15],&sh[16],&sh[17],&sh[18],&sh[19] );

/* do shades */
theta = adj * (3.1415927/180.0) ;
for( i = 0; i < N_d_rows; i++ ) {

	val = atof( D[i][f-1] );
	
	/* convert val (percentage) to radians.. */
	val = ( val/100.0 ) * 6.28319;
	stop = theta + val;
	ux = u * cos( theta+(val/2.0) );
	uy = u * sin( theta+(val/2.0) );

	first = 1;
	for( ; theta < (stop+0.001); theta += 0.02 ) {
		x = hx + (r * cos( theta ));
		y = hy + (r * sin( theta ));
		if( first ) { NTmov( hx+ux, hy+uy ); NTpath( x+ux, y+uy ); first = 0; }
		NTpath( x+ux, y+uy );
		}
	if( i < ns )NTshade( sh[i] );
	else NTshade( 1.0 );
	theta = stop;
	}

/* do lines */
theta = adj * (3.1415927/180.0);
for( i = 0; i < N_d_rows; i++ ) {

	val = atof( D[i][f-1] );
	
	/* convert val (percentage) to radians.. */
	val = ( val/100.0 ) * 6.28319;
	stop = theta + val;
	ux = u * cos( theta+(val/2.0) );
	uy = u * sin( theta+(val/2.0) );

	first = 1;
	for( ; theta < (stop+0.001); theta += 0.02 ) {
		x = hx + (r * cos( theta ));
		y = hy + (r * sin( theta ));
		if( first ) { NTmov( hx+ux, hy+uy ); NTlin( x+ux, y+uy ); first = 0; }
		NTlin( x+ux, y+uy );
		}
	NTlin( hx+ux, hy+uy );
	theta = stop;
	}

NTnormline();
}
SHAR_EOF
############################

echo src/Ppinit.c
cat << \SHAR_EOF > src/Ppinit.c
/* Initialize plotting pack */
#include "ipl.x"

static char fnm[PATHNAME_LEN];
static int filecount;

EPinit( )
{
int yr, mon, day, hr, min, sec, i;
char host[30];

sysdate( &mon, &day, &yr ); systime( &hr, &min, &sec );

sprintf( Tempfile, "/usr/tmp/copa%05dplot", getpid() );

DXlo = DXhi = 0; /* null out data dimensions */
DYlo = DYhi = 0;

/* sprintf( Buf, "%s (%02d%02d%02d %02d:%02d)", getlogin(), yr, mon, day, hr, min ); */

strcpy( Stdfont, "/Helvetica" );
StdLw = 1.0;
NTfont( "/Helvetica" ); 
NTptsize( 6 );
/*
 * NTmov( 0.1, 0.1 ); 
 * NTtext( Buf );
 */

}
SHAR_EOF
############################

echo src/Pplib.c
cat << \SHAR_EOF > src/Pplib.c
#include <stdio.h>
#include <ctype.h>


/* ================================ */
/* getfld()
/* Gets fields which are separated by ":". */
/* Natural ":" which appear in text must be prefixed by a backslash. */
/* Deletes the ':' and all leading and trailing white space. */
/* Leaves index pointing at next char. */

getfld( out, line, index )
char out[], line[];
int *index;
{
int i, j, esc;

j = 0;
for( i = *index; i < strlen( line ); i++ ) {
	if( line[i] == ' ' || line[i] == '\t' ) continue;
	else break;
	}
for( ; i < strlen( line ); i++ ) {
	if( line[i] == '\\' ) { esc = 1; continue; }
	if( line[i] == ':' && ! esc ) { i++; esc = 0; break; }
	else out[j++] = line[i];
	esc = 0;
	}
j--;
for( ; j > 0; j-- ) {
	if( out[j] == ':' || out[j] == ' ' || out[j] == '\t' || out[j] == '\n' || out[j] == '\0' ) continue;
	else break;
	}
out[ j+1 ] = '\0';
*index = i;
}


/* ==========================================
 * getok( )
*/
#define GETOKMAX	100
char *getok( string, index )
	char	string[];	/* array to obtain token from */
	int	*index;
	{
		static char	tok[GETOKMAX+1];
		register	n;
		while( member( string[(*index)], " \t\n" ) ) (*index)++; 
		/* EAT( SPACE, TAB, EOR, string, (*index) ); */
		for( n=0;
			n <= GETOKMAX &&
			string[*index] != ' '  &&
			string[*index] != '\t'  &&
			string[*index] != '\n'  &&
			string[*index] != '\0'  ;
				tok[n++] = string[(*index)++] )  ;
		tok[n] = '\0' ;
		if( n > GETOKMAX ) fprintf( stderr, "token %s too long\n", tok );
		return(tok);
	}

/* ================================== */
/* goodnum() - checks a token to see if it is a legal number,
	either float or integer, returns 1 if so, 0 if not a
	legal number.  2nd arg is precision, ie the position of
	the decimal point 
*/
#include <ctype.h>
#define YES 1
#define NO 0
goodnum( str, prec )
char str[];
int *prec;
{
int l, p, bad, point;
l = strlen( str );
if( l < 1 ) return( 0 );
bad = NO; *prec = -1;
for( p = 0; p < l; p++ ) { 
	if( str[p] == '.' ) { if( *prec == -1 ) *prec = p; else bad=YES; }
	else if( p == 0 && l > 1 && ( str[p] == '-' || str[p] == '+' ) );
	else if( ! isdigit( str[p]) ) bad=YES;
	}
if( bad ) return( 0 );
else return( 1 );
}


/* =================================== */
/* member() - returns char position if character c is a member of string s, 
		0 otherwise. Char positions start with 1 for this purpose. */
member( c, s )
char c, s[];
{
int i;
for( i = 0; i < strlen( s ); i++ ) if( s[i] == c ) return( i+1 );
return( 0 );
}



/* =================================== */
/* smember() - returns 1 if string s is present as a token in string t,
		0 otherwise. */
smember( s, t )
char s[], t[];
{
char tok[100], *getok();
int i;
i = 0;
while( 1 ) {
	strcpy( tok, getok( t, &i ) );
	if( tok[0] == '\0' ) break;
	if( strcmp( tok, s ) == 0 ) return( 1 );
	}
return( 0 );
}


/* =================================== */
/* strip white-space off of front and end of string s */
strip_ws( s )
char s[];
{
int i, j;
/* find last significant char and put a null after it */
for( j = strlen( s ) -1; j >= 0; j-- )
	if( !member( s[j], " \t\n" )) break;
s[j+1] = '\0';
/* find 1st significant char at position i */
for( i = 0; i < strlen( s ); i++ ) 
	if( !member( s[i], " \t\n" )) break; 
strcpy( s, &s[i] );
}

/* ================= */
sysdate( mon, day, yr )
int	*mon, *day, *yr ;
{
	int	tvec[2], *dtime ;

	time( tvec );
	dtime = (int *)(localtime( tvec ));
	*mon = *(dtime+4) + 1 ;
	*day = *(dtime+3)  ;
	*yr = *(dtime+5)  ;
}
/* ================= */
systime( hour, min, sec )
int	*hour, *min, *sec ;
{
	int	tvec[2], *dtime ;

	time( tvec );
	dtime = (int *)localtime( tvec );
	*hour = *(dtime+2) ;
	*min = *(dtime+1)  ;
	*sec = *(dtime)  ;
}


SHAR_EOF
############################

echo src/Ppstub.c
cat << \SHAR_EOF > src/Ppstub.c
#include "elib.x"
#include "ipl.x"

/* ========================= */
NTcentext( s, w ) 	
char s[];
double w;
{ 
if( Chd == 0 ) { 
	Emov( Ex1 + (w/2.0), Ey1 ); 
	Ecentext( s ); 
	}
else if( Chd == 90 ) { Emov( Ex1, Ey1 + (w/2.0)); Ecentext( s ); }
}

/* ========================= */
NTrightjust( s, w ) 	
char s[];
double w;
{
if( Chd == 0 ) { Emov( Ex1 + w, Ey1 ); Erightjust( s ); } 
else if( Chd == 90 ) { Emov( Ex1, Ey1 + w ); Erightjust( s ); } 
}
SHAR_EOF
############################

echo src/Prect.c
cat << \SHAR_EOF > src/Prect.c
/* do a rectangle, with shading and/or outline */
/* only used internally, user proc is Polygon */
#include "ipl.x"

/* rect() - all coords in data space */
rect( xlo, ylo, xhi, yhi, shade, outline )
double xlo, ylo, xhi, yhi, shade;
int outline;
{
if( shade >= 0 ) {
	NTm( xlo, ylo );
	NTp( xlo, yhi );
	NTp( xhi, yhi );
	NTp( xhi, ylo );
	NTshade( shade );
	}
if( outline ) {
	NTm( xlo, ylo );
	NTl( xlo, yhi );
	NTl( xhi, yhi );
	NTl( xhi, ylo );
	NTl( xlo, ylo );
	}
}

/* ab_rect() - all coords in absolute space */
ab_rect( xlo, ylo, xhi, yhi, shade, outline )
double xlo, ylo, xhi, yhi, shade;
int outline;
{
if( shade >= 0 ) {
	NTmov( xlo, ylo );
	NTpath( xlo, yhi );
	NTpath( xhi, yhi );
	NTpath( xhi, ylo );
	NTshade( shade );
	}
if( outline ) {
	NTmov( xlo, ylo );
	NTlin( xlo, yhi );
	NTlin( xhi, yhi );
	NTlin( xhi, ylo );
	NTlin( xlo, ylo );
	}
}
SHAR_EOF
############################

echo src/Putil.c
cat << \SHAR_EOF > src/Putil.c
#include "ipl.x"
/* =============
   ============= */
/* The following are utilities for dealing with multi-line responses */
/* ========= */
/* getln() returns successive portions of s as separated by \n */

char *getln( s )
char s[];
{
static char rtn[120];
static int c = 0;
int l, start;

/* a null argument resets */
if( strlen( s ) < 1 ) {
	c = 0;
	return( "" );
	}
start = c;
for( ; c < strlen( s ); c++ ) if( s[c] == '\n' ) break;
strncpy( rtn, &s[start], c-start );
rtn[ c-start ] = '\0';
c++;
return( rtn );
}


/* ======= */
/* countln() returns number of \n separated lines in s */

countln( s )
char s[];
{
int i, nnl;
if( strlen( s ) < 1 ) return( 0 );
nnl = 0;
for( i = 0; i < strlen( s ) -1; i++ ) if( s[i] == '\n' ) nnl++;
nnl++;
return( nnl );
}

/* ======== */
/* text_tofile() places text s into file f */

text_tofile( s, f )
char s[], f[];
{
FILE *fp;

fp = fopen( f, "w" );
if( fp == NULL ) { fprintf( stderr, "text_tofile: can't open Tempfile.\n" ); exit(); }
fprintf( fp, "%s\n", s );
fclose( fp );
}


/* ============ */
/* main program for testing these routines. */
/* main() 
{
char s[30];
char *getln();
strcpy( s, "Hello\nworld\nhello\n" );
printf( "%d\n", countln( s ) );
printf( "%s\n", getln( s ) );
printf( "%s\n", getln( s ) );
printf( "%s\n", getln( s ) );
strcpy( s, "Hello\nworld\nhello" );
printf( "%d\n", countln( s ) );
printf( "%s\n", getln( s ) );
printf( "%s\n", getln( s ) );
printf( "%s\n", getln( s ) );
text_tofile( s, "/usr/tmp/testutil001" );
}
*/
SHAR_EOF
############################


