Newsgroups: comp.sources.unix
From: svalente@athena.mit.edu (Salvatore Valente)
Subject: v29i052: more - the standard paging utility with some new features, Part01/01
Message-id: <1.816764522.1079@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: svalente@athena.mit.edu (Salvatore Valente)
Posting-Number: Volume 29, Issue 52
Archive-Name: more/part01

# This is a shell archive.  Save it in a file, remove anything before
# this line, and then unpack it by entering "sh file".  Note, it may
# create directories; files and directories will be owned by you and
# have default permissions.
#
# This archive contains:
#
#	more
#	more/Makefile
#	more/README
#	more/magic.c
#	more/more.1
#	more/more.c
#	more/more.help
#	more/morefile.c
#	more/morefile.h
#	more/pathnames.h
#	more/regex.h
#	more/termcap.h
#
echo c - more
mkdir -p more > /dev/null 2>&1
echo x - more/Makefile
sed 's/^X//' >more/Makefile << 'END-of-more/Makefile'
X
XCC	= gcc
XCFLAGS	= -O
XLDFLAGS	= 
X
XPROG	= more
XSRCS	= more.c morefile.c magic.c
XOBJS	= more.o morefile.o magic.o
XLIBS	= -ltermcap
X
Xall: ${PROG}
X
X${PROG}: ${OBJS}
X	${CC} ${LDFLAGS} -o $@ ${OBJS} $(LIBS)
X
Xclean:
X	rm -f ${PROG} *.o *~
X
Xinstall:
X	install -c -s more /bin/
X	install -c -m 644 more.help /usr/lib/
X	install -c -m 644 more.1 /usr/man/man1
X
Xmore.o: more.c morefile.h
END-of-more/Makefile
echo x - more/README
sed 's/^X//' >more/README << 'END-of-more/README'
X
XREADME for "more"
XWritten by Sal Valente <svalente@mit.edu>  11/10/95
X
XThis is the "more" pager from old versions of BSD, up to BSD 4.3.
XAccording to the the source file, it was SCCS version 5.19, originally
Xwritten in 1980, last modified at Berkely in 1988.  This particular
Xversion has been floating around the Linux ftp sites for the past few
Xyears, and has probably been slightly modified by a cast of thousands.
X
XAnyway, I added the ability to go backwards when reading from a
Xpipe, because it's a useful feature.
X
X(This feature exists in the popular "less" pager.  But I never really
Xliked "less", mostly because it doesn't handle the "-c" option as well
Xas "more" does.)
X
XThere are probably some other cool features that "more" does not have
Xand that other pager do have.  If you can think of one of these
Xfeatures, please add it and send me a patch.  :-)
X
XBuilding "more"
X---------------
X
XYou must use an ANSI compiler.
X
XYou must have a BSD compatible "termcap" library.  If you do not have
Xone, you can use the GNU termcap library, which is available at
Xftp://prep.ai.mit.edu/pub/gnu/termcap-1.3.tar.gz.
X
XYou must have a regex library with re_comp() and re_exec().  Most old
XBSD-based systems have these in libc.  BSD 4.4 based systems should
Xlink with -lcompat.  For other systems, I have collected the relevant
Xfunctions from BSD 4.4's libc and libcompat and made them a standalone
Xlibrary.  You can download this from
Xhttp://www.mit.edu:8001/people/svalente/archive/regex.tar.gz.
X
XYou need to have the POSIX.1 termios functions in your C library.
X
Xmagic.c is very non-portable.  If you can't figure out how to get it
Xto compile on your system, just comment out the whole function.
X("more" uses this function to determine if a file is text or binary.
XIt's a nice feature, but is not absolutely necessary.)
X
XYou will probably hate where the Makefile installs stuff.  If you
Xchange where "more.help" is installed, remember to change pathnames.h
Xas well.
X
XHave a nice day.
XSal Valente
X<svalente@mit.edu>
Xhttp://www.mit.edu:8001/people/svalente/home.html
END-of-more/README
echo x - more/magic.c
sed 's/^X//' >more/magic.c << 'END-of-more/magic.c'
X
X#include <stdio.h>
X#ifndef SOLARIS
X#include <a.out.h>
X#endif
X#if defined(linux) || defined(SOLARIS)
X#include <elf.h>
X#endif
X
X#ifndef SEEK_SET
X#define SEEK_SET 0
X#endif
X
X/*
X * magic --
X *	check for file magic numbers.  This code would best be shared with
X *	the file(1) program or, perhaps, more should not try and be so smart?
X */
Xint
Xmagic(FILE *f, char *fs)
X{
X#ifdef __hp9000s800
X    unsigned long ex;
X#   define N_BADMAG(x) (((x)!=EXEC_MAGIC)&&((x)!=SHARE_MAGIC))
X#elif defined(SOLARIS)
X    struct { unsigned long a_info; } ex;
X#elif defined(mips) || defined(__osf__) || defined(_AIX)
X    struct aouthdr ex;
X#else
X    struct exec ex;
X#endif
X    int bad;
X
X    bad = 0;
X    if (fread(&ex, sizeof(ex), 1, f) == 1) {
X#ifdef N_BADMAG
X	bad = ! N_BADMAG (ex);
X#endif
X#ifdef ELFMAG
X	if (bad == 0) {
X	    unsigned long elfmagic;
X	    char *elfbytes = ELFMAG;
X	    elfmagic = *((unsigned long *) elfbytes);
X	    bad = (ex.a_info == elfmagic);
X	}
X#endif
X#ifdef ISCOFF
X	if (bad == 0) {
X	    bad = ISCOFF (ex.magic);
X	}
X#endif
X    }
X
X    if (bad != 0) {
X	printf("\n******** %s: Not a text file ********\n\n", fs);
X	fclose(f);
X	return(1);
X    }
X    fseek(f, 0L, SEEK_SET);		/* rewind() not necessary */
X    return(0);
X}
END-of-more/magic.c
echo x - more/more.1
sed 's/^X//' >more/more.1 << 'END-of-more/more.1'
X.\" Copyright (c) 1980 The Regents of the University of California.
X.\" All rights reserved.
X.\"
X.\" Redistribution and use in source and binary forms, with or without
X.\" modification, are permitted provided that the following conditions
X.\" are met:
X.\" 1. Redistributions of source code must retain the above copyright
X.\"    notice, this list of conditions and the following disclaimer.
X.\" 2. Redistributions in binary form must reproduce the above copyright
X.\"    notice, this list of conditions and the following disclaimer in the
X.\"    documentation and/or other materials provided with the distribution.
X.\" 3. All advertising materials mentioning features or use of this software
X.\"    must display the following acknowledgement:
X.\"	This product includes software developed by the University of
X.\"	California, Berkeley and its contributors.
X.\" 4. Neither the name of the University nor the names of its contributors
X.\"    may be used to endorse or promote products derived from this software
X.\"    without specific prior written permission.
X.\"
X.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X.\" SUCH DAMAGE.
X.\"
X.\"	@(#)more.1	6.6 (Berkeley) 4/18/91
X.\"
X.TH MORE 1 "April 18, 1991"
X.UC 4
X.SH NAME
Xmore \- file perusal filter for crt viewing
X.SH SYNOPSIS
X.B more
X[
X.B \-cpdflsu
X]
X[
X.B \-\fIn\fP
X]
X[
X.B +\fIlinenumber\fP 
X]
X[
X.B +/\fIpattern\fP
X] [ name ...  ]
X.SH DESCRIPTION
X.I  More
Xis a filter which allows examination of a continuous text
Xone screenful at a time on a soft-copy terminal.
XIt normally pauses after each screenful, printing --More--
Xat the bottom of the screen.
XIf the user then types a carriage return, one more line is displayed.
XIf the user hits a space,
Xanother screenful is displayed.  Other possibilities are enumerated later.
X.PP
XThe command line options are:
X.TP
X.I \-n
XAn integer which is the size (in lines) of the window which
X.I more
Xwill use instead of the default.
X.TP
X.B \-c
X.I More
Xwill draw each page by beginning at the top of the screen and erasing 
Xeach line just before it draws on it.
XThis avoids scrolling the screen, making it easier to read while 
X.I more 
Xis writing.
XThis option will be ignored if the terminal does not have the ability
Xto clear to the end of a line.
X.TP
X.B \-d
X.I More
Xwill prompt the user with the message "Press
Xspace to continue, \'q\' to quit." at the end of each screenful,
Xand will respond to subsequent illegal user input by
Xprinting "Press \'h\' for instructions." instead of ringing the bell.
XThis is useful if
X.I more
Xis being used as a filter in some setting,
Xsuch as a class,
Xwhere many users may be unsophisticated.
X.TP
X.B \-f
XThis causes
X.I more
Xto count logical, rather than screen lines.
XThat is, long lines are not folded.
XThis option is recommended if
X.I nroff
Xoutput is being piped through
X.I ul,
Xsince the latter may generate escape sequences.
XThese escape sequences contain characters which would ordinarily occupy
Xscreen positions, but which do not print when they are sent to the
Xterminal as part of an escape sequence.
XThus
X.I more
Xmay think that lines are longer than they actually are, and fold
Xlines erroneously.
X.TP
X.B \-l
XDo
Xnot treat ^\&L (form feed) specially.
XIf this option is not given,
X.I more
Xwill pause after any line that contains a ^\&L, as if the end of a
Xscreenful had been reached.
XAlso, if a file begins with a form feed, the screen will be cleared
Xbefore the file is printed.
X.TP
X.B \-s
XSqueeze multiple blank lines from the output, producing only one blank
Xline.  Especially helpful when viewing
X.I nroff
Xoutput, this option maximizes the useful information present on the screen.
X.TP
X.B \-u
XNormally,
X.I more
Xwill handle underlining such as produced by
X.I nroff
Xin a manner appropriate to the particular terminal:  if the terminal can
Xperform underlining or has a stand-out mode,
X.I more
Xwill output appropriate escape sequences to enable underlining or stand-out
Xmode for underlined information in the source file.  The
X.I \-u
Xoption suppresses this processing.
X.TP
X.B +\fIlinenumber\fP
XStart up at \fIlinenumber\fP.
X.TP
X.B +/\fIpattern\fP
XStart up two lines before the line containing the
Xregular expression \fIpattern\fP.
X.PP
XIf the program is invoked as
X.I page,
Xthen the screen is cleared before each screenful is printed (but only
Xif a full screenful is being printed), and
X.I k
X\- 1 rather
Xthan
X.I k
X\- 2 lines are printed in each screenful, where
X.I k
Xis the number of lines the terminal can display.
X.PP
X.I More
Xlooks in the file
X.I /etc/termcap
Xto determine terminal characteristics,
Xand to determine the default window size.
XOn a terminal capable of displaying 24 lines,
Xthe default window size is 22 lines.
X.PP
X.I More
Xlooks in the environment variable
X.I MORE
Xto pre-set any flags desired.  For example, if you prefer to view files using
Xthe
X.I \-c
Xmode of operation, the
X.I csh
Xcommand
X.I "setenv MORE -c"
Xor the
X.I sh
Xcommand sequence
X.I "MORE='-c' ; export MORE"
Xwould cause all invocations of
X.I more ,
Xincluding invocations by programs such as
X.I man
Xand
X.I msgs ,
Xto use this mode.
XNormally, the user will place the command sequence which sets up the
X.I MORE
Xenvironment variable in the
X.I .cshrc
Xor
X.I .profile
Xfile.
X.PP
XIf
X.I more
Xis reading from a file, rather than a pipe, then a percentage is displayed
Xalong with the --More-- prompt.
XThis gives the fraction of the file (in characters, not lines) that has been
Xread so far.
X.PP
XOther sequences which may be typed when
X.I more
Xpauses, and their effects, are as follows (\fIi\fP is an optional integer
Xargument, defaulting to 1) :
X.PP
X.IP \fIi\|\fP<space>
Xdisplay
X.I i
Xmore lines, (or another screenful if no argument is given)
X.PP
X.IP ^D
Xdisplay 11 more lines (a ``scroll'').
XIf
X.I i
Xis given, then the scroll size is set to \fIi\|\fP.
X.PP
X.IP d
Xsame as ^D (control-D)
X.PP
X.IP \fIi\|\fPz
Xsame as typing a space except that \fIi\|\fP, if present, becomes the new
Xwindow size.
X.PP
X.IP \fIi\|\fPs
Xskip \fIi\|\fP lines and print a screenful of lines
X.PP
X.IP \fIi\|\fPf
Xskip \fIi\fP screenfuls and print a screenful of lines
X.PP
X.IP \fIi\|\fPb
Xskip back \fIi\fP screenfuls and print a screenful of lines
X.PP
X.IP \fIi\|\fP^B
Xsame as b
X.PP
X.IP "q or Q"
XExit from
X.I more.
X.PP 
X.IP =
XDisplay the current line number.
X.PP
X.IP v
XStart up the editor
X.I vi
Xat the current line.
X.PP
X.IP h
XHelp command; give a description of all the
X.I more
Xcommands.
X.PP
X.IP \fIi\|\fP/expr
Xsearch for the \fIi\|\fP-th occurrence of the regular expression \fIexpr.\fP
XIf there are less than \fIi\fP occurrences of \fIexpr\|\fP,
Xand the input is a file (rather than a pipe),
Xthen the position in the file remains unchanged.
XOtherwise, a screenful is displayed, starting two lines before the place
Xwhere the expression was found.
XThe user's erase and kill characters may be used to edit the regular
Xexpression.
XErasing back past the first column cancels the search command.
X.PP
X.IP \fIi\|\fPn
Xsearch for the \fIi\|\fP-th occurrence of the last regular expression entered.
X.PP
X.IP \'
X(single quote) Go to the point from which the last search started.
XIf no search has been performed in the current file, this command
Xgoes back to the beginning of the file.
X.PP
X.IP !command
Xinvoke a shell with \fIcommand\|\fP. 
XThe characters `%' and `!' in "command" are replaced with the
Xcurrent file name and the previous shell command respectively.
XIf there is no current file name, `%' is not expanded.
XThe sequences "\\%" and "\\!" are replaced by "%" and "!" respectively.
X.PP
X.IP \fIi\|\fP:n
Xskip to the \fIi\|\fP-th next file given in the command line
X(skips to last file if n doesn't make sense)
X.PP
X.IP \fIi\|\fP:p
Xskip to the \fIi\|\fP-th previous file given in the command line.
XIf this command is given in the middle of printing out a
Xfile, then
X.I more
Xgoes back to the beginning of the file. If \fIi\fP doesn't make sense,
X.I more
Xskips back to the first file.
XIf
X.I more
Xis not reading from a file, the bell is rung and nothing else happens.
X.PP
X.IP :f
Xdisplay the current file name and line number.
X.PP
X.IP ":q or :Q"
Xexit from 
X.I more
X(same as q or Q).
X.PP
X.IP .
X(dot) repeat the previous command.
X.PP
XThe commands take effect immediately, i.e., it is not necessary to
Xtype a carriage return.
XUp to the time when the command character itself is given,
Xthe user may hit the line kill character to cancel the numerical
Xargument being formed.
XIn addition, the user may hit the erase character to redisplay the
X--More--(xx%) message.
X.PP
XAt any time when output is being sent to the terminal, the user can
Xhit the quit key (normally control\-\\).
X.I More
Xwill stop sending output, and will display the usual --More--
Xprompt.
XThe user may then enter one of the above commands in the normal manner.
XUnfortunately, some output is lost when this is done, due to the
Xfact that any characters waiting in the terminal's output queue
Xare flushed when the quit signal occurs.
X.PP
XThe terminal is set to
X.I noecho
Xmode by this program so that the output can be continuous.
XWhat you type will thus not show on your terminal, except for the / and !
Xcommands.
X.PP
XIf the standard output is not a teletype, then
X.I more
Xacts just like
X.I cat,
Xexcept that a header is printed before each file (if there is
Xmore than one).
X.PP
X.DT
XA sample usage of
X.I more
Xin previewing
X.I nroff
Xoutput would be
X.PP
X	nroff \-ms +2 doc.n | more -s
X.SH FILES
X.DT
X/usr/lib/more.help	Help file
X.br
X/etc/termcap		Terminal data base
X.SH AUTHORS
XEric Shienbrood, UC Berkeley
X.br
XModifications by Geoff Peck, John Foderaro, Sal Valente
X.\" .SH "SEE ALSO"
X.\" csh(1), man(1), msgs(1), script(1), sh(1), environ(7)
X.SH BUGS
XSkipping backwards is too slow on large files.
END-of-more/more.1
echo x - more/more.c
sed 's/^X//' >more/more.c << 'END-of-more/more.c'
X/*
X * Copyright (c) 1980 Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that the above copyright notice and this paragraph are
X * duplicated in all such forms and that any documentation,
X * advertising materials, and other materials related to such
X * distribution and use acknowledge that the software was developed
X * by the University of California, Berkeley.  The name of the
X * University may not be used to endorse or promote products derived
X * from this software without specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#ifndef lint
Xchar copyright[] =
X"@(#) Copyright (c) 1980 Regents of the University of California.\n\
X All rights reserved.\n";
X#endif /* not lint */
X
X#ifndef lint
X/* static char sccsid[] = "@(#)more.c	5.19 (Berkeley) 6/29/88"; */
Xstatic char rcsid[] = "$Id: more.c,v 1.2 1995/11/19 00:22:34 svalente Exp $";
X#endif /* not lint */
X
X/*
X** more.c - General purpose tty output filter and file perusal program
X**
X**	by Eric Shienbrood, UC Berkeley
X**
X**	modified by Geoff Peck, UCB to add underlining, single spacing
X**	modified by John Foderaro, UCB to add -c and MORE environment variable
X*/
X
X#define _BSD_SOURCE 1
X
X#include <stdio.h>
X#include <string.h>
X#include <stdlib.h>
X#include <stdarg.h>
X#include <ctype.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <signal.h>
X#include <errno.h>
X#include <setjmp.h>
X#include <unistd.h>
X#include <sys/wait.h>
X#ifndef sun
X#include <sys/ioctl.h>
X#endif
X#include <termios.h>
X#include "termcap.h"
X#include "regex.h"
X#include "morefile.h"
X#include "pathnames.h"
X
X#define TBUFSIZ	1024
X#define LINSIZ	256
X#define ctrl(letter)	(letter & 077)
X#define RUBOUT	'\177'
X#define ESC	'\033'
X#define QUIT	'\034'
X#ifndef LONG_MAX
X#define LONG_MAX 0x7fffffff
X#endif
X
Xstruct termios	otty, savetty;
Xstruct mfile	*cur_mfile;
Xlong		file_size;
Xint		fnum, no_intty, no_tty, slow_tty;
Xint		dum_opt, dlines;
Xint		nscroll = 11;	/* Number of lines scrolled by 'd' */
Xint		fold_opt = 1;	/* Fold long lines */
Xint		stop_opt = 1;	/* Stop after form feeds */
Xint		ssp_opt = 0;	/* Suppress white space */
Xint		ul_opt = 1;	/* Underline as best we can */
Xint		promptlen;
Xint		Currline;	/* Line we are currently at */
Xint		startup = 1;
Xint		firstf = 1;
Xint		notell = 1;
Xint		docrterase = 0;
Xint		docrtkill = 0;
Xint		bad_so;	/* True if overwriting does not turn off standout */
Xint		inwait, Pause, errors;
Xint		within;	/* true if we are within a file,
X			false if we are between files */
Xint		hard, dumb, noscroll, hardtabs, clreol, eatnl;
Xint		catch_susp;	/* We should catch the SIGTSTP signal */
Xchar		**fnames;	/* The list of file names */
Xint		nfiles;		/* Number of files left to process */
Xchar		*shell;		/* The name of the shell to use */
Xint		shellp;		/* A previous shell command exists */
Xchar		ch;
Xjmp_buf		restore;
Xchar		Line[LINSIZ];	/* Line buffer */
Xint		Lpp = 24;	/* lines per page */
Xchar		*Clear;		/* clear screen */
Xchar		*eraseln;	/* erase line */
Xchar		*Senter, *Sexit;/* enter and exit standout mode */
Xchar		*ULenter, *ULexit;	/* enter and exit underline mode */
Xchar		*chUL;		/* underline character */
Xchar		*chBS;		/* backspace character */
Xchar		*Home;		/* go to home */
Xchar		*cursorm;	/* cursor movement */
Xchar		cursorhome[40];	/* contains cursor movement to home */
Xchar		*EodClr;	/* clear rest of screen */
Xint		Mcol = 80;	/* number of columns */
Xint		Wrap = 1;	/* set if automargins */
Xint		soglitch;	/* terminal has standout mode glitch */
Xint		ulglitch;	/* terminal has underline mode glitch */
Xint		pstate = 0;	/* current UL state */
Xstruct {
X    long chrctr, line;
X} context, screen_start;
X
Xvoid argscan (char *s);
Xstruct mfile *checkf (char *fs, int *clearfirst);
Xint putch (int ch);
Xvoid screen (struct mfile *f, int num_lines);
Xvoid onquit (int sig);
Xvoid chgwinsz (int sig);
Xvoid end_it (void);
Xvoid end_on_sig (int sig);
Xvoid copy_file (FILE *f);
Xint printd (int n);
Xvoid scanstr (int n, char *str);
Xint tailequ (char *path, char *string);
Xvoid prompt (char *filename);
Xint getline (struct mfile *f, int *length);
Xvoid erase (int col);
Xvoid kill_line (void);
Xvoid cleareol (void);
Xvoid clreos (void);
Xint pr (char *s1);
Xvoid prbuf (char *s, int n);
Xvoid doclear (void);
Xvoid home (void);
Xint command (char *filename, struct mfile *f);
Xint colon (char *filename, int cmd, int nlines);
Xint number (char *cmd);
Xvoid do_shell (char *filename);
Xvoid search (char *buf, struct mfile *file, int n);
Xvoid execute (char *filename, char *cmd, ...);
Xvoid skiplns (int n, struct mfile *f);
Xvoid skipf (int nskip);
Xvoid initterm (void);
Xint readch (void);
Xvoid ttyin (char *buf, int nmax, int pchar);
Xint expand (char *outbuf, char *inbuf);
Xvoid show (int ch);
Xvoid error (char *mess);
Xvoid set_tty (void);
Xvoid reset_tty (void);
Xvoid rdline (struct mfile *f);
Xvoid onsusp (int sig);
X#ifndef linux
Xchar *basename (char *pathname);
X#endif
Xint magic (FILE *f, char *fs);
X
Xint
Xmain(int argc, char **argv)
X{
X    struct mfile	*f;
X    register char	*s;
X    register char	*p;
X    register char	ch;
X    register int	left;
X    int			prnames = 0;
X    int			initopt = 0;
X    int			srchopt = 0;
X    int			clearit = 0;
X    int			initline = 0;
X    char		initbuf[80];
X
X    nfiles = argc;
X    fnames = argv;
X    initterm ();
X    nscroll = Lpp/2 - 1;
X    if (nscroll <= 0)
X	nscroll = 1;
X    if ((s = getenv("MORE")) != NULL)
X	argscan(s);
X    while (--nfiles > 0) {
X	if ((ch = (*++fnames)[0]) == '-') {
X	    argscan(*fnames+1);
X	}
X	else if (ch == '+') {
X	    s = *fnames;
X	    if (*++s == '/') {
X		srchopt++;
X		for (++s, p = initbuf; p < initbuf + 79 && *s != '\0';)
X		    *p++ = *s++;
X		*p = '\0';
X	    }
X	    else {
X		initopt++;
X		for (initline = 0; *s != '\0'; s++)
X		    if (isdigit (*s))
X			initline = initline*10 + *s -'0';
X		--initline;
X	    }
X	}
X	else break;
X    }
X    /* allow clreol only if Home and eraseln and EodClr strings are
X     *  defined, and in that case, make sure we are in noscroll mode
X     */
X    if(clreol)
X    {
X        if((Home == NULL) || (*Home == '\0') ||
X	   (eraseln == NULL) || (*eraseln == '\0') ||
X           (EodClr == NULL) || (*EodClr == '\0') )
X	      clreol = 0;
X	else noscroll = 1;
X    }
X    if (dlines == 0)
X	dlines = Lpp - (noscroll ? 1 : 2);
X    left = dlines;
X    if (nfiles > 1)
X	prnames++;
X    if (!no_intty && nfiles == 0) {
X	fputs("usage: ", stderr);
X	fputs(basename(argv[0]), stderr);
X	fputs(" [-cpdflsuv] [+linenum | +/pattern] name1 name2 ...\n", stderr);
X	exit(1);
X    }
X    if (!no_tty) {
X	signal(SIGQUIT, onquit);
X	signal(SIGINT, end_on_sig);
X#ifdef SIGWINCH
X	signal(SIGWINCH, chgwinsz);
X#endif
X	if (signal (SIGTSTP, SIG_IGN) == SIG_DFL) {
X	    signal(SIGTSTP, onsusp);
X	    catch_susp++;
X	}
X	tcsetattr (fileno(stderr), TCSANOW, &otty);
X    }
X    if (no_intty) {
X	if (no_tty)
X	    copy_file (stdin);
X	else {
X	    f = cur_mfile = Fopen_stdin();
X	    if ((ch = Getc (f)) == '\f')
X		doclear();
X	    else {
X		Ungetc (ch, f);
X		if (noscroll && (ch != EOF)) {
X		    if (clreol)
X			home ();
X		    else
X			doclear ();
X		}
X	    }
X	    if (srchopt)
X	    {
X		search (initbuf, f, 1);
X		if (noscroll)
X		    left--;
X	    }
X	    else if (initopt)
X		skiplns (initline, f);
X	    screen (f, left);
X	    Fclose (f);
X	}
X	no_intty = 0;
X	prnames++;
X	firstf = 0;
X    }
X
X    while (fnum < nfiles) {
X	if ((f = checkf (fnames[fnum], &clearit)) != NULL) {
X	    cur_mfile = f;
X	    context.line = context.chrctr = 0;
X	    Currline = 0;
X	    if (firstf)
X		setjmp (restore);
X	    if (firstf) {
X		firstf = 0;
X		if (srchopt)
X		{
X		    search (initbuf, f, 1);
X		    if (noscroll)
X			left--;
X		}
X		else if (initopt)
X		    skiplns (initline, f);
X	    }
X	    else if (fnum < nfiles && !no_tty) {
X		setjmp (restore);
X		left = command (fnames[fnum], f);
X	    }
X	    if (left != 0) {
X		if ((noscroll || clearit) && (file_size != LONG_MAX))
X		    if (clreol)
X			home ();
X		    else
X			doclear ();
X		if (prnames) {
X		    if (bad_so)
X			erase (0);
X		    if (clreol)
X			cleareol ();
X		    fputs("::::::::::::::", stdout);
X		    if (promptlen > 14)
X			erase (14);
X		    fputs("\n", stdout);
X		    if(clreol) cleareol();
X		    fputs(fnames[fnum], stdout);
X		    fputs("\n", stdout);
X		    if(clreol) cleareol();
X		    fputs("::::::::::::::\n", stdout);
X		    if (left > Lpp - 4)
X			left = Lpp - 4;
X		}
X		if (no_tty)
X		    copy_file (f->fp);
X		else {
X		    within++;
X		    screen(f, left);
X		    within = 0;
X		}
X	    }
X	    setjmp (restore);
X	    fflush(stdout);
X	    Fclose(f);
X	    screen_start.line = screen_start.chrctr = 0L;
X	    context.line = context.chrctr = 0L;
X	}
X	fnum++;
X	firstf = 0;
X    }
X    reset_tty ();
X    return(0);
X}
X
Xvoid
Xargscan(char *s)
X{
X	int seen_num = 0;
X
X	while (*s != '\0') {
X		switch (*s) {
X		  case '0': case '1': case '2':
X		  case '3': case '4': case '5':
X		  case '6': case '7': case '8':
X		  case '9':
X			if (!seen_num) {
X				dlines = 0;
X				seen_num = 1;
X			}
X			dlines = dlines*10 + *s - '0';
X			break;
X		  case 'd':
X			dum_opt = 1;
X			break;
X		  case 'l':
X			stop_opt = 0;
X			break;
X		  case 'f':
X			fold_opt = 0;
X			break;
X		  case 'p':
X			noscroll++;
X			break;
X		  case 'c':
X			clreol++;
X			break;
X		  case 's':
X			ssp_opt = 1;
X			break;
X		  case 'u':
X			ul_opt = 0;
X			break;
X		  case 'v':
X			puts(rcsid);
X			exit(0);
X		}
X		s++;
X	}
X}
X
X
X/*
X** Check whether the file named by fs is an ASCII file which the user may
X** access.  If it is, return the opened file. Otherwise return NULL.
X*/
X
Xstruct mfile *
Xcheckf (register char *fs, int *clearfirst)
X{
X	struct stat stbuf;
X	register struct mfile *f;
X	char c;
X
X	if (stat (fs, &stbuf) == -1) {
X		fflush(stdout);
X		if (clreol)
X			cleareol ();
X		perror(fs);
X		return(NULL);
X	}
X	if ((stbuf.st_mode & S_IFMT) == S_IFDIR) {
X		printf("\n*** %s: directory ***\n\n", fs);
X		return(NULL);
X	}
X	if ((f = Fopen(fs)) == NULL) {
X		fflush(stdout);
X		perror(fs);
X		return(NULL);
X	}
X	if (magic(f->fp, fs))
X		return(NULL);
X	c = Getc(f);
X	*clearfirst = c == '\f';
X	Ungetc (c, f);
X	if ((file_size = stbuf.st_size) == 0)
X		file_size = LONG_MAX;
X	return(f);
X}
X
X/*
X** A real function, for the tputs routine in termlib
X*/
X
Xint
Xputch (int ch)
X{
X    return (putchar (ch));
X}
X
X/*
X** Print out the contents of the file f, one screenful at a time.
X*/
X
X#define STOP -10
X
Xvoid
Xscreen (register struct mfile *f, register int num_lines)
X{
X    register int c;
X    register int nchars;
X    int length;			/* length of current line */
X    static int prev_len = 1;	/* length of previous line */
X
X    while (1) {
X	while (num_lines > 0 && !Pause) {
X	    if ((nchars = getline (f, &length)) == EOF)
X	    {
X		if (clreol)
X		    clreos();
X		return;
X	    }
X	    if (ssp_opt && length == 0 && prev_len == 0)
X		continue;
X	    prev_len = length;
X	    if (bad_so || ((Senter && *Senter == ' ') && promptlen > 0))
X		erase (0);
X	    /* must clear before drawing line since tabs on some terminals
X	     * do not erase what they tab over.
X	     */
X	    if (clreol)
X		cleareol ();
X	    prbuf (Line, length);
X	    if (nchars < promptlen)
X		erase (nchars);	/* erase () sets promptlen to 0 */
X	    else promptlen = 0;
X	    /* is this needed? */
X	    /* if (clreol)
X		cleareol(); */	/* must clear again in case we wrapped */
X	    if (nchars < Mcol || !fold_opt)
X		prbuf("\n", 1);	/* will turn off UL if necessary */
X	    if (nchars == STOP)
X		break;
X	    num_lines--;
X	}
X	if (pstate) {
X		tputs(ULexit, 1, putch);
X		pstate = 0;
X	}
X	fflush(stdout);
X	if ((c = Getc(f)) == EOF)
X	{
X	    if (clreol)
X		clreos ();
X	    return;
X	}
X
X	if (Pause && clreol)
X	    clreos ();
X	Ungetc (c, f);
X	setjmp (restore);
X	Pause = 0; startup = 0;
X	if ((num_lines = command (NULL, f)) == 0)
X	    return;
X	if (hard && promptlen > 0)
X		erase (0);
X	if (noscroll && num_lines >= dlines)
X	{
X	    if (clreol)
X		home();
X	    else
X		doclear ();
X	}
X	screen_start.line = Currline;
X	screen_start.chrctr = Ftell (f);
X    }
X}
X
X/*
X** Come here if a quit signal is received
X*/
X
Xvoid onquit(int sig)
X{
X    signal(SIGQUIT, SIG_IGN);
X    if (!inwait) {
X	putchar ('\n');
X	if (!startup) {
X	    signal(SIGQUIT, onquit);
X	    longjmp (restore, 1);
X	}
X	else
X	    Pause++;
X    }
X    else if (!dum_opt && notell) {
X	write (2, "[Use q or Q to quit]", 20);
X	promptlen += 20;
X	notell = 0;
X    }
X    signal(SIGQUIT, onquit);
X}
X
X/*
X** Come here if a signal for a window size change is received
X*/
X
X#ifdef SIGWINCH
Xvoid chgwinsz(int sig)
X{
X    struct winsize win;
X
X    signal(SIGWINCH, SIG_IGN);
X    if (ioctl(fileno(stdout), TIOCGWINSZ, &win) != -1) {
X	if (win.ws_row != 0) {
X	    Lpp = win.ws_row;
X	    nscroll = Lpp/2 - 1;
X	    if (nscroll <= 0)
X		nscroll = 1;
X	    dlines = Lpp - (noscroll ? 1 : 2);
X	}
X	if (win.ws_col != 0)
X	    Mcol = win.ws_col;
X    }
X     signal(SIGWINCH, chgwinsz);
X}
X#endif
X
X/*
X** Clean up terminal state and exit.
X** Also come here if interrupt signal received.
X*/
X
Xvoid end_it (void)
X{
X    reset_tty ();
X    if (clreol) {
X	putchar ('\r');
X	clreos ();
X	fflush (stdout);
X    }
X    else if (!clreol && (promptlen > 0)) {
X	kill_line ();
X	fflush (stdout);
X    }
X    else
X	write (2, "\n", 1);
X    _exit(0);
X}
X
Xvoid end_on_sig (int sig)
X{
X    end_it ();
X}
X
Xvoid
Xcopy_file(register FILE *f)
X{
X    register int c;
X
X    while ((c = getc(f)) != EOF)
X	putchar(c);
X}
X
X/*
X** Print an integer as a string of decimal digits,
X** returning the length of the print representation.
X*/
X
Xint
Xprintd (int n)
X{
X    int a, nchars;
X
X    if ((a = n/10) != 0)
X	nchars = 1 + printd(a);
X    else
X	nchars = 1;
X    putchar (n % 10 + '0');
X    return (nchars);
X}
X
X/* Put the print representation of an integer into a string */
X
Xvoid
Xscanstr (int n, char *str)
X{
X    sprintf (str, "%d", n);
X}
X
X
Xstatic char bell = ctrl('G');
X
X/* See whether the last component of the path name "path" is equal to the
X** string "string"
X*/
X
Xint
Xtailequ (char *path, register char *string)
X{
X	register char *tail;
X
X	tail = path + strlen(path);
X	while (tail >= path)
X		if (*(--tail) == '/')
X			break;
X	++tail;
X	while (*tail++ == *string++)
X		if (*tail == '\0')
X			return(1);
X	return(0);
X}
X
Xvoid
Xprompt (char *filename)
X{
X    if (clreol)
X	cleareol ();
X    else if (promptlen > 0)
X	kill_line ();
X    if (!hard) {
X	promptlen = 8;
X	if (Senter && Sexit) {
X	    tputs (Senter, 1, putch);
X	    promptlen += (2 * soglitch);
X	}
X	if (clreol)
X	    cleareol ();
X	fputs("--More--", stdout);
X	if (filename != NULL) {
X	    promptlen += printf("(Next file: %s)", filename);
X	}
X	else if (!no_intty) {
X	    promptlen += printf("(%d%%)", (int)((cur_mfile->file_pos * 100) /
X						file_size));
X	}
X	if (dum_opt) {
X	    promptlen += pr("[Press space to continue, 'q' to quit.]");
X	}
X	if (Senter && Sexit)
X	    tputs (Sexit, 1, putch);
X	if (clreol)
X	    clreos ();
X	fflush(stdout);
X    }
X    else
X	write (2, &bell, 1);
X    inwait++;
X}
X
X/*
X** Get a logical line
X*/
X
Xint
Xgetline(register struct mfile *f, int *length)
X{
X    register int	c;
X    register char	*p;
X    register int	column;
X    static int		colflg;
X
X    p = Line;
X    column = 0;
X    c = Getc (f);
X    if (colflg && c == '\n') {
X	Currline++;
X	c = Getc (f);
X    }
X    while (p < &Line[LINSIZ - 1]) {
X	if (c == EOF) {
X	    if (p > Line) {
X		*p = '\0';
X		*length = p - Line;
X		return (column);
X	    }
X	    *length = p - Line;
X	    return (EOF);
X	}
X	if (c == '\n') {
X	    Currline++;
X	    break;
X	}
X	*p++ = c;
X	if (c == '\t')
X	    if (!hardtabs || (column < promptlen && !hard)) {
X		if (hardtabs && eraseln && !dumb) {
X		    column = 1 + (column | 7);
X		    tputs (eraseln, 1, putch);
X		    promptlen = 0;
X		}
X		else {
X		    for (--p; p < &Line[LINSIZ - 1];) {
X			*p++ = ' ';
X			if ((++column & 7) == 0)
X			    break;
X		    }
X		    if (column >= promptlen) promptlen = 0;
X		}
X	    }
X	    else
X		column = 1 + (column | 7);
X	else if (c == '\b' && column > 0)
X	    column--;
X	else if (c == '\r')
X	    column = 0;
X	else if (c == '\f' && stop_opt) {
X		p[-1] = '^';
X		*p++ = 'L';
X		column += 2;
X		Pause++;
X	}
X	else if (c == EOF) {
X	    *length = p - Line;
X	    return (column);
X	}
X	else if (c >= ' ' && c != RUBOUT)
X	    column++;
X	if (column >= Mcol && fold_opt) break;
X	c = Getc (f);
X    }
X    if (column >= Mcol && Mcol > 0) {
X	if (!Wrap) {
X	    *p++ = '\n';
X	}
X    }
X    colflg = column == Mcol && fold_opt;
X    if (colflg && eatnl && Wrap) {
X	*p++ = '\n'; /* simulate normal wrap */
X    }
X    *length = p - Line;
X    *p = 0;
X    return (column);
X}
X
X/*
X** Erase the rest of the prompt, assuming we are starting at column col.
X*/
X
Xvoid
Xerase (register int col)
X{
X    if (promptlen == 0)
X	return;
X    if (hard) {
X	putchar ('\n');
X    }
X    else {
X	if (col == 0)
X	    putchar ('\r');
X	if (!dumb && eraseln)
X	    tputs (eraseln, 1, putch);
X	else
X	    for (col = promptlen - col; col > 0; col--)
X		putchar (' ');
X    }
X    promptlen = 0;
X}
X
X/*
X** Erase the current line entirely
X*/
X
Xvoid
Xkill_line (void)
X{
X    erase (0);
X    if (!eraseln || dumb) putchar ('\r');
X}
X
X/*
X * force clear to end of line
X */
Xvoid
Xcleareol(void)
X{
X    tputs(eraseln, 1, putch);
X}
X
Xvoid
Xclreos(void)
X{
X    tputs(EodClr, 1, putch);
X}
X
X/*
X**  Print string and return number of characters
X*/
X
Xint
Xpr(char *s1)
X{
X    register char	*s;
X    register char	c;
X
X    for (s = s1; c = *s++; )
X	putchar(c);
X    return (s - s1 - 1);
X}
X
X
X/* Print a buffer of n characters */
X
X#define wouldul(s,n)	((n) >= 2 && (((s)[0] == '_' && (s)[1] == '\b') || ((s)[1] == '\b' && (s)[2] == '_')))
X
Xvoid
Xprbuf (register char *s, register int n)
X{
X    register char c;			/* next output character */
X    register int state;			/* next output char's UL state */
X
X    while (--n >= 0)
X	if (!ul_opt)
X	    putchar (*s++);
X	else {
X	    if (*s == ' ' && pstate == 0 && ulglitch && wouldul(s+1, n-1)) {
X		s++;
X		continue;
X	    }
X	    if (state = wouldul(s, n)) {
X		c = (*s == '_')? s[2] : *s ;
X		n -= 2;
X		s += 3;
X	    } else
X		c = *s++;
X	    if (state != pstate) {
X		if (c == ' ' && state == 0 && ulglitch && wouldul(s, n-1))
X		    state = 1;
X		else
X		    tputs(state ? ULenter : ULexit, 1, putch);
X	    }
X	    if (c != ' ' || pstate == 0 || state != 0 || ulglitch == 0)
X	        putchar(c);
X	    if (state && *chUL) {
X		pr(chBS);
X		tputs(chUL, 1, putch);
X	    }
X	    pstate = state;
X	}
X}
X
X/*
X**  Clear the screen
X*/
X
Xvoid
Xdoclear(void)
X{
X    if (Clear && !hard) {
X	tputs(Clear, 1, putch);
X
X	/* Put out carriage return so that system doesn't
X	** get confused by escape sequences when expanding tabs
X	*/
X	putchar ('\r');
X	promptlen = 0;
X    }
X}
X
X/*
X * Go to home position
X */
Xvoid
Xhome(void)
X{
X    tputs(Home,1,putch);
X}
X
Xstatic int lastcmd, lastarg, lastp;
Xstatic int lastcolon;
Xchar shell_line[132];
X
X/*
X** Read a command and do it. A command consists of an optional integer
X** argument followed by the command character.  Return the number of lines
X** to display in the next screenful.  If there is nothing more to display
X** in the current file, zero is returned.
X*/
X
Xint
Xcommand (char *filename, register struct mfile *f)
X{
X    register int nlines;
X    register int retval;
X    register char c;
X    char colonch;
X    FILE *helpf;
X    int done;
X    char comchar, cmdbuf[80], *p;
X    int initline;
X
X#define ret(val) retval=val;done++;break
X
X    done = 0;
X    if (!errors)
X	prompt (filename);
X    else
X	errors = 0;
X    while (1) {
X	nlines = number (&comchar);
X	lastp = colonch = 0;
X	if (comchar == '.') {	/* Repeat last command */
X		lastp++;
X		comchar = lastcmd;
X		nlines = lastarg;
X		if (lastcmd == ':')
X			colonch = lastcolon;
X	}
X	lastcmd = comchar;
X	lastarg = nlines;
X	if (comchar == otty.c_cc[VERASE]) {
X	    kill_line ();
X	    prompt (filename);
X	    continue;
X	}
X	switch (comchar) {
X	case ':':
X	    retval = colon (filename, colonch, nlines);
X	    if (retval >= 0)
X		done++;
X	    break;
X	case 'b':
X	case ctrl('B'):
X	    if (nlines == 0)
X		nlines++;
X	    putchar ('\r');
X	    erase (0);
X	    printf ("\n");
X	    if (clreol)
X		cleareol ();
X	    printf ("...back %d page", nlines);
X	    if (nlines > 1)
X		putchar('s');
X	    putchar('\n');
X
X	    if (clreol)
X		cleareol ();
X	    putchar('\n');
X
X	    initline = Currline - dlines * (nlines + 1);
X	    if (! noscroll)
X		--initline;
X	    if (initline < 0)
X		initline = 0;
X	    Fseek(f, 0L);
X	    Currline = 0;	/* skiplns() will make Currline correct */
X	    skiplns(initline, f);
X	    if (! noscroll) {
X		ret(dlines + 1);
X	    }
X	    ret(dlines);
X	case ' ':
X	case 'z':
X	    if (nlines == 0) nlines = dlines;
X	    else if (comchar == 'z') dlines = nlines;
X	    ret (nlines);
X	case 'd':
X	case ctrl('D'):
X	    if (nlines != 0) nscroll = nlines;
X	    ret (nscroll);
X	case 'q':
X	case 'Q':
X	    end_it ();
X	case 's':
X	case 'f':
X	    if (nlines == 0) nlines++;
X	    if (comchar == 'f')
X		nlines *= dlines;
X	    putchar ('\r');
X	    erase (0);
X	    putchar('\n');
X	    if (clreol)
X		cleareol ();
X	    printf ("...skipping %d line", nlines);
X	    if (nlines > 1)
X		putchar('s');
X	    putchar('\n');
X
X	    if (clreol)
X		cleareol ();
X	    putchar('\n');
X
X	    while (nlines > 0) {
X		while ((c = Getc (f)) != '\n')
X		    if (c == EOF) {
X			retval = 0;
X			done++;
X			goto endsw;
X		    }
X		    Currline++;
X		    nlines--;
X	    }
X	    ret (dlines);
X	case '\n':
X	    if (nlines != 0)
X		dlines = nlines;
X	    else
X		nlines = 1;
X	    ret (nlines);
X	case '\f':
X	    doclear ();
X	    Fseek (f, screen_start.chrctr);
X	    Currline = screen_start.line;
X	    ret (dlines);
X	case '\'':
X	    kill_line ();
X	    fputs ("\n***Back***\n\n", stdout);
X	    Fseek (f, context.chrctr);
X	    Currline = context.line;
X	    ret (dlines);
X	case '=':
X	    kill_line ();
X	    promptlen = printd (Currline);
X	    fflush (stdout);
X	    break;
X	case 'n':
X	    lastp++;
X	case '/':
X	    if (nlines == 0) nlines++;
X	    kill_line ();
X	    putchar ('/');
X	    promptlen = 1;
X	    fflush (stdout);
X	    if (lastp) {
X		write (2,"\r", 1);
X		search (NULL, f, nlines);	/* Use previous r.e. */
X	    }
X	    else {
X		ttyin (cmdbuf, 78, '/');
X		write (2, "\r", 1);
X		search (cmdbuf, f, nlines);
X	    }
X	    ret (dlines-1);
X	case '!':
X	    do_shell (filename);
X	    break;
X	case '?':
X	case 'h':
X	    if ((helpf = fopen (_PATH_HELPFILE, "r")) == NULL)
X		error ("Can't open help file");
X	    if (noscroll) doclear ();
X	    copy_file (helpf);
X	    fclose (helpf);
X	    prompt (filename);
X	    break;
X	case 'v':	/* This case should go right before default */
X	    if (!no_intty) {
X		kill_line ();
X		cmdbuf[0] = '+';
X		scanstr (Currline - dlines < 0 ? 0 :
X			 Currline - (dlines + 1) / 2, &cmdbuf[1]);
X		p = basename (_PATH_VI);
X		printf ("%s %s %s", p, cmdbuf, fnames[fnum]);
X		execute (filename, _PATH_VI, p, cmdbuf, fnames[fnum], NULL);
X		break;
X	    }
X	default:
X	    if (dum_opt) {
X   		kill_line ();
X		if (Senter && Sexit) {
X		    tputs (Senter, 1, putch);
X		    promptlen = pr ("[Press 'h' for instructions.]") + (2 * soglitch);
X		    tputs (Sexit, 1, putch);
X		}
X		else
X		    promptlen = pr ("[Press 'h' for instructions.]");
X		fflush (stdout);
X	    }
X	    else
X		write (2, &bell, 1);
X	    break;
X	}
X	if (done) break;
X    }
X    putchar ('\r');
Xendsw:
X    inwait = 0;
X    notell++;
X    return (retval);
X}
X
Xchar ch;
X
X/*
X * Execute a colon-prefixed command.
X * Returns <0 if not a command that should cause
X * more of the file to be printed.
X */
X
Xint
Xcolon (char *filename, int cmd, int nlines)
X{
X    if (cmd == 0)
X	ch = readch ();
X    else
X	ch = cmd;
X    lastcolon = ch;
X    switch (ch) {
X    case 'f':
X	kill_line ();
X	if (!no_intty)
X	    promptlen = printf ("\"%s\" line %d", fnames[fnum], Currline);
X	else
X	    promptlen = printf ("[Not a file] line %d", Currline);
X	fflush (stdout);
X	return (-1);
X    case 'n':
X	if (nlines == 0) {
X	    if (fnum >= nfiles - 1)
X		end_it ();
X	    nlines++;
X	}
X	putchar ('\r');
X	erase (0);
X	skipf (nlines);
X	return (0);
X    case 'p':
X	if (no_intty) {
X	    write (2, &bell, 1);
X	    return (-1);
X	}
X	putchar ('\r');
X	erase (0);
X	if (nlines == 0)
X	    nlines++;
X	skipf (-nlines);
X	return (0);
X    case '!':
X	do_shell (filename);
X	return (-1);
X    case 'q':
X    case 'Q':
X	end_it ();
X    default:
X	write (2, &bell, 1);
X	return (-1);
X    }
X}
X
X/*
X** Read a decimal number from the terminal. Set cmd to the non-digit which
X** terminates the number.
X*/
X
Xint
Xnumber(char *cmd)
X{
X    register int i;
X
X    ch = otty.c_cc[VKILL];
X    i = 0;
X    while (1) {
X	ch = readch ();
X	if (ch >= '0' && ch <= '9')
X	    i = i*10 + ch - '0';
X	else if (ch == otty.c_cc[VKILL])
X	    i = 0;
X	else {
X	    *cmd = ch;
X	    break;
X	}
X    }
X    return (i);
X}
X
Xvoid
Xdo_shell (char *filename)
X{
X    char cmdbuf[80];
X
X    kill_line ();
X    putchar ('!');
X    fflush (stdout);
X    promptlen = 1;
X    if (lastp)
X	fputs (shell_line, stdout);
X    else {
X	ttyin (cmdbuf, 78, '!');
X	if (expand (shell_line, cmdbuf)) {
X	    kill_line ();
X	    promptlen = printf ("!%s", shell_line);
X	}
X    }
X    fflush (stdout);
X    write (2, "\n", 1);
X    promptlen = 0;
X    shellp = 1;
X    execute (filename, shell, shell, "-c", shell_line, NULL);
X}
X
X/*
X** Search for nth ocurrence of regular expression contained in buf in the file
X*/
X
Xvoid
Xsearch (char *buf, struct mfile *file, register int n)
X{
X    long startline = Ftell (file);
X    register long line1 = startline;
X    register long line2 = startline;
X    register long line3 = startline;
X    register int lncount;
X    int saveln, rv;
X    char *s;
X
X    context.line = saveln = Currline;
X    context.chrctr = startline;
X    lncount = 0;
X    if ((s = re_comp (buf)) != 0)
X	error (s);
X    while (!feof (file->fp)) {
X	line3 = line2;
X	line2 = line1;
X	line1 = Ftell (file);
X	rdline (file);
X	lncount++;
X	if ((rv = re_exec (Line)) == 1)
X	    if (--n == 0) {
X		if (lncount > 3 || (lncount > 1 && no_intty)) {
X		    putchar ('\n');
X		    if (clreol)
X			cleareol ();
X		    fputs("...skipping\n", stdout);
X		}
X		Currline -= (lncount >= 3 ? 3 : lncount);
X		Fseek (file, line3);
X		if (noscroll)
X		    if (clreol) {
X			home ();
X			cleareol ();
X		    } else {
X			doclear ();
X		    }
X		break;
X	    }
X	    else if (rv == -1)
X		error ("Regular expression botch");
X    }
X    if (feof (file->fp)) {
X	Currline = saveln;
X	clearerr (file->fp);
X	Fseek (file, startline);
X	error ("Pattern not found");
X    }
X}
X
Xvoid execute (char *filename, char *cmd, ...)
X{
X    int id;
X    int n;
X    va_list argp;
X
X    fflush (stdout);
X    reset_tty ();
X    for (n = 10; (id = fork ()) < 0 && n > 0; n--)
X	sleep (5);
X    if (id == 0) {
X	char *argv[10];
X	if (!isatty(0)) {
X	    close(0);
X	    open("/dev/tty", 0);
X	}
X	va_start(argp, cmd);
X	for (n = 0; (argv[n] = va_arg (argp, char *)) != NULL; n++);
X	va_end(argp);
X	execv (cmd, argv);
X	write (2, "exec failed\n", 12);
X	exit (1);
X    }
X    if (id > 0) {
X	signal (SIGINT, SIG_IGN);
X	signal (SIGQUIT, SIG_IGN);
X	if (catch_susp)
X	    signal(SIGTSTP, SIG_DFL);
X	while (wait(NULL) > 0);
X	signal (SIGINT, end_on_sig);
X	signal (SIGQUIT, onquit);
X	if (catch_susp)
X	    signal(SIGTSTP, onsusp);
X    } else {
X	write(2, "can't fork\n", 11);
X    }
X    set_tty ();
X    fputs ("------------------------\n", stdout);
X    prompt (filename);
X}
X
X/*
X** Skip n lines in the file f
X*/
X
Xvoid
Xskiplns (register int n, register struct mfile *f)
X{
X    register char c;
X
X    while (n > 0) {
X	while ((c = Getc (f)) != '\n')
X	    if (c == EOF)
X		return;
X	n--;
X	Currline++;
X    }
X}
X
X/*
X** Skip nskip files in the file list (from the command line). Nskip may be
X** negative.
X*/
X
Xvoid
Xskipf (int nskip)
X{
X    if (nskip == 0)
X	return;
X    if (nskip > 0) {
X	if (fnum + nskip > nfiles - 1)
X	    nskip = nfiles - fnum - 1;
X    }
X    else if (within)
X	++fnum;
X    fnum += nskip;
X    if (fnum < 0)
X	fnum = 0;
X    fputs ("\n...Skipping \n", stdout);
X    if (clreol)
X	cleareol ();
X    fputs ("...Skipping ", stdout);
X    fputs (nskip > 0 ? "to file " : "back to file ", stdout);
X    fputs (fnames[fnum], stdout);
X    fputs ("\n", stdout);
X    if (clreol)
X	cleareol ();
X    fputs ("\n", stdout);
X    fnum--;
X}
X
X/*----------------------------- Terminal I/O -------------------------------*/
X
X#if !defined(XTABS) && defined(TAB3)
X#define XTABS TAB3
X#endif
X
Xvoid
Xinitterm (void)
X{
X    char	buf[TBUFSIZ];
X    static char	clearbuf[TBUFSIZ];
X    char	*clearptr, *padstr;
X    char	*term;
X    struct winsize win;
X
X    no_tty = tcgetattr(fileno(stdout), &otty);
X    if (!no_tty) {	
X	docrterase = (otty.c_cc[VERASE] != 255);
X	docrtkill =  (otty.c_cc[VKILL] != 255);
X	if ((term = getenv("TERM")) == 0 || tgetent(buf, term) <= 0) {
X	    dumb++; ul_opt = 0;
X	}
X	else {
X#ifdef TIOCGWINSZ
X	    if (ioctl(fileno(stdout), TIOCGWINSZ, &win) < 0) {
X#endif
X		Lpp = tgetnum("li");
X		Mcol = tgetnum("co");
X#ifdef TIOCGWINSZ
X	    } else {
X		if ((Lpp = win.ws_row) == 0)
X		    Lpp = tgetnum("li");
X		if ((Mcol = win.ws_col) == 0)
X		    Mcol = tgetnum("co");
X	    }
X#endif
X	    if ((Lpp <= 0) || tgetflag("hc")) {
X		hard++;	/* Hard copy terminal */
X		Lpp = 24;
X	    }
X	    if (tgetflag("xn"))
X		eatnl++; /* Eat newline at last column + 1; dec, concept */
X	    if (Mcol <= 0)
X		Mcol = 80;
X
X	    if (tailequ (fnames[0], "page") || (!hard && tgetflag("ns")))
X		noscroll++;
X	    Wrap = tgetflag("am");
X	    bad_so = tgetflag ("xs");
X	    clearptr = clearbuf;
X	    eraseln = tgetstr("ce",&clearptr);
X	    Clear = tgetstr("cl", &clearptr);
X	    Senter = tgetstr("so", &clearptr);
X	    Sexit = tgetstr("se", &clearptr);
X	    if ((soglitch = tgetnum("sg")) < 0)
X		soglitch = 0;
X
X	    /*
X	     *  Set up for underlining:  some terminals don't need it;
X	     *  others have start/stop sequences, still others have an
X	     *  underline char sequence which is assumed to move the
X	     *  cursor forward one character.  If underline sequence
X	     *  isn't available, settle for standout sequence.
X	     */
X
X	    if (tgetflag("ul") || tgetflag("os"))
X		ul_opt = 0;
X	    if ((chUL = tgetstr("uc", &clearptr)) == NULL )
X		chUL = "";
X	    if (((ULenter = tgetstr("us", &clearptr)) == NULL ||
X	         (ULexit = tgetstr("ue", &clearptr)) == NULL) && !*chUL) {
X	        if ((ULenter = Senter) == NULL || (ULexit = Sexit) == NULL) {
X			ULenter = "";
X			ULexit = "";
X		} else
X			ulglitch = soglitch;
X	    } else {
X		if ((ulglitch = tgetnum("ug")) < 0)
X		    ulglitch = 0;
X	    }
X
X	    if ((padstr = tgetstr("pc", &clearptr)) != NULL)
X		PC = *padstr;
X	    Home = tgetstr("ho",&clearptr);
X	    if (Home == 0 || *Home == '\0')
X	    {
X		if ((cursorm = tgetstr("cm", &clearptr)) != NULL) {
X		    strcpy(cursorhome, tgoto(cursorm, 0, 0));
X		    Home = cursorhome;
X	       }
X	    }
X	    EodClr = tgetstr("cd", &clearptr);
X	    if ((chBS = tgetstr("bc", &clearptr)) == NULL)
X		chBS = "\b";
X
X	}
X	if ((shell = getenv("SHELL")) == NULL)
X	    shell = "/bin/sh";
X    }
X    no_intty = tcgetattr(fileno(stdin), &otty);
X    tcgetattr(fileno(stderr), &otty);
X    savetty = otty;
X    ospeed = cfgetospeed (&otty);
X    slow_tty = ospeed < B1200;
X#ifdef OXTABS
X    hardtabs = (otty.c_oflag & OXTABS) != OXTABS;
X#else
X    hardtabs = (otty.c_oflag & TABDLY) != XTABS;
X#endif
X    if (!no_tty) 
X	otty.c_lflag &= ~(ICANON|ECHO);
X    otty.c_cc[VTIME] = 0;
X    otty.c_cc[VMIN] = 1;
X}
X
Xint
Xreadch (void)
X{
X    char ch;
X
X    errno = 0;
X    if (read (2, &ch, 1) <= 0)
X	if (errno != EINTR)
X	    end_it();
X	else
X	    ch = otty.c_cc[VKILL];
X    return (ch);
X}
X
Xstatic char BS = '\b';
Xstatic char *BSB = "\b \b";
Xstatic char CARAT = '^';
X#define ERASEONECHAR \
X    if (docrterase) \
X	write (2, BSB, sizeof(BSB)); \
X    else \
X	write (2, &BS, sizeof(BS));
X
Xvoid
Xttyin (char *buf, int nmax, int pchar)
X{
X    register char *sptr;
X    register char ch;
X    register int slash = 0;
X    int	maxlen;
X    char cbuf;
X
X    sptr = buf;
X    maxlen = 0;
X    while (sptr - buf < nmax) {
X	if (promptlen > maxlen)
X	    maxlen = promptlen;
X	ch = readch ();
X	if (ch == '\\') {
X	    slash++;
X	}
X	else if ((ch == otty.c_cc[VERASE]) && !slash) {
X	    if (sptr > buf) {
X		--promptlen;
X		ERASEONECHAR;
X		--sptr;
X		if ((*sptr < ' ' && *sptr != '\n') || *sptr == RUBOUT) {
X		    --promptlen;
X		    ERASEONECHAR;
X		}
X		continue;
X	    }
X	    else {
X		if (!eraseln) promptlen = maxlen;
X		longjmp (restore, 1);
X	    }
X	}
X	else if ((ch == otty.c_cc[VKILL]) && !slash) {
X	    if (hard) {
X		show (ch);
X		putchar ('\n');
X		putchar (pchar);
X	    }
X	    else {
X		putchar ('\r');
X		putchar (pchar);
X		if (eraseln)
X		    erase (1);
X		else if (docrtkill)
X		    while (promptlen-- > 1)
X			write (2, BSB, sizeof(BSB));
X		promptlen = 1;
X	    }
X	    sptr = buf;
X	    fflush (stdout);
X	    continue;
X	}
X	if (slash && (ch == otty.c_cc[VKILL] || ch == otty.c_cc[VERASE])) {
X	    ERASEONECHAR;
X	    --sptr;
X	}
X	if (ch != '\\')
X	    slash = 0;
X	*sptr++ = ch;
X	if ((ch < ' ' && ch != '\n' && ch != ESC) || ch == RUBOUT) {
X	    ch += ch == RUBOUT ? -0100 : 0100;
X	    write (2, &CARAT, 1);
X	    promptlen++;
X	}
X	cbuf = ch;
X	if (ch != '\n' && ch != ESC) {
X	    write (2, &cbuf, 1);
X	    promptlen++;
X	}
X	else
X	    break;
X    }
X    *--sptr = '\0';
X    if (!eraseln)
X	promptlen = maxlen;
X    if (sptr - buf >= nmax - 1)
X	error ("Line too long");
X}
X
Xint
Xexpand (char *outbuf, char *inbuf)
X{
X    register char *instr;
X    register char *outstr;
X    register char ch;
X    char temp[200];
X    int changed = 0;
X
X    instr = inbuf;
X    outstr = temp;
X    while ((ch = *instr++) != '\0')
X	switch (ch) {
X	case '%':
X	    if (!no_intty) {
X		strcpy (outstr, fnames[fnum]);
X		outstr += strlen (fnames[fnum]);
X		changed++;
X	    }
X	    else
X		*outstr++ = ch;
X	    break;
X	case '!':
X	    if (!shellp)
X		error ("No previous command to substitute for");
X	    strcpy (outstr, shell_line);
X	    outstr += strlen (shell_line);
X	    changed++;
X	    break;
X	case '\\':
X	    if (*instr == '%' || *instr == '!') {
X		*outstr++ = *instr++;
X		break;
X	    }
X	default:
X	    *outstr++ = ch;
X	}
X    *outstr++ = '\0';
X    strcpy (outbuf, temp);
X    return (changed);
X}
X
Xvoid
Xshow (int ch)
X{
X    char cbuf;
X
X    if ((ch < ' ' && ch != '\n' && ch != ESC) || ch == RUBOUT) {
X	ch += ch == RUBOUT ? -0100 : 0100;
X	write (2, &CARAT, 1);
X	promptlen++;
X    }
X    cbuf = ch;
X    write (2, &cbuf, 1);
X    promptlen++;
X}
X
Xvoid
Xerror (char *mess)
X{
X    if (clreol)
X	cleareol ();
X    else
X	kill_line ();
X    promptlen += strlen (mess);
X    if (Senter && Sexit) {
X	tputs (Senter, 1, putch);
X	fputs(mess, stdout);
X	tputs (Sexit, 1, putch);
X    }
X    else {
X	fputs(mess, stdout);
X    }
X    fflush(stdout);
X    errors++;
X    longjmp (restore, 1);
X}
X
X
Xvoid
Xset_tty (void)
X{
X    otty.c_lflag &= ~(ICANON|ECHO);
X    tcsetattr(fileno(stderr), TCSANOW, &otty);
X}
X
Xvoid
Xreset_tty (void)
X{
X    if (no_tty)
X	return;
X    if (pstate) {
X	tputs(ULexit, 1, putch);
X	fflush(stdout);
X	pstate = 0;
X    }
X    otty.c_lflag |= ICANON|ECHO;
X    tcsetattr(fileno(stderr), TCSANOW, &savetty);
X}
X
Xvoid
Xrdline (register struct mfile *f)
X{
X    register char c;
X    register char *p;
X
X    p = Line;
X    while ((c = Getc (f)) != '\n' && c != EOF && p - Line < LINSIZ - 1)
X	*p++ = c;
X    if (c == '\n')
X	Currline++;
X    *p = '\0';
X}
X
X/* Come here when we get a suspend signal from the terminal */
X
Xvoid
Xonsusp (int sig)
X{
X    /* ignore SIGTTOU so we don't get stopped if csh grabs the tty */
X    signal(SIGTTOU, SIG_IGN);
X    reset_tty ();
X    fflush (stdout);
X    signal(SIGTTOU, SIG_DFL);
X    /* Send the TSTP signal to suspend our process group */
X    signal(SIGTSTP, SIG_DFL);
X    /* sigsetmask(0);*/
X    kill (0, SIGTSTP);
X    /* Pause for station break */
X
X    /* We're back */
X    signal (SIGTSTP, onsusp);
X    set_tty ();
X    if (inwait) longjmp (restore, 1);
X}
X
X#ifndef linux
Xchar *
Xbasename (char *pathname)
X{
X    char *p;
X
X    p = strrchr (pathname, '/');
X    return (p ? p + 1 : pathname);
X}
X#endif
END-of-more/more.c
echo x - more/more.help
sed 's/^X//' >more/more.help << 'END-of-more/more.help'
X
XMost commands optionally preceded by integer argument k.  Defaults in brackets.
XStar (*) indicates argument becomes new default.
X-------------------------------------------------------------------------------
X<space>			Display next k lines of text [current screen size]
Xz			Display next k lines of text [current screen size]*
X<return>		Display next k lines of text [1]*
Xd or ctrl-D		Scroll k lines [current scroll size, initially 11]*
Xq or Q or <interrupt>	Exit from more
Xs			Skip forward k lines of text [1]
Xf			Skip forward k screenfuls of text [1]
Xb or ctrl-B		Skip backwards k screenfuls of text [1]
X'			Go to place where previous search started
X=			Display current line number
X/<regular expression>	Search for kth occurrence of regular expression [1]
Xn			Search for kth occurrence of last r.e [1]
X!<cmd> or :!<cmd>	Execute <cmd> in a subshell
Xv			Start up an editor at current line
Xctrl-L			Redraw screen
X:n			Go to kth next file [1]
X:p			Go to kth previous file [1]
X:f			Display current file name and line number
X.			Repeat previous command
X-------------------------------------------------------------------------------
END-of-more/more.help
echo x - more/morefile.c
sed 's/^X//' >more/morefile.c << 'END-of-more/morefile.c'
X/*
X * Copyright (c) 1995 by Salvatore Valente <svalente@mit.edu>
X *
X * Redistribution and use in source and binary forms are permitted.
X * Have fun.
X *
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X/*
X *  morefile.c -- Functions to implement the "mfile" data type,
X *  which allows you to rewind an otherwise unrewindable file.
X *
X *  You can only read from an mfile one character at a time.
X *  It would have been much more efficient if I made it work one line at
X *  a time.  However, that would have required extensive modifications
X *  to more.c.  Simply using Getc() and Ungetc() required almost no
X *  modifications to more.c, since it all ready used them for everything.
X *  I was lazy and this was a quick hack, so I went for the quick and
X *  ugly method.
X *
X *  It still reads much much faster than an xterm can display it,
X *  so the efficiency is not really an issue.
X *
X *  When writing the mfile data type, I first considered using a
X *  temporary file, rather than memory, to store the data that is read.
X *  I figured that memory is finite, and stdin can be infinite,
X *  which may be a problem.  After a minute's thought, I decided that
X *  anyone who pipes more than like 16 megs to "more" deserves to lose.
X *
X *  Of course, the "mfile" routines can be completely rewritten to use
X *  a temporary file without changing the data type specifications at all.
X *  Hooray, abstraction.
X *
X *  Less talk.  More code.
X *
X */
X
X#include <sys/types.h>
X#include <stdio.h>
X#include <stdlib.h>
X#include <unistd.h>
X#include "morefile.h"
X
Xstatic struct area *new_area (void);
X
Xstruct mfile *Fopen (char *filename)
X{
X    struct mfile *mp;
X    FILE *fp;
X
X    fp = fopen (filename, "r");
X    if (! fp)
X	return (NULL);
X    mp = malloc (sizeof (struct mfile));
X    mp->fp = fp;
X    mp->contents = mp->cur_area = NULL;
X    mp->cur_area_idx = 0;
X    mp->file_pos = 0;
X    return (mp);
X}
X
Xstruct mfile *Fopen_stdin (void)
X{
X    struct mfile *mp;
X
X    mp = malloc (sizeof (struct mfile));
X    mp->fp = stdin;
X    mp->contents = mp->cur_area = new_area ();
X    mp->cur_area_idx = 0;
X    mp->file_pos = 0;
X    return (mp);
X}
X
Xint Fseek (struct mfile *mp, size_t off)
X{
X    int size;
X
X    /*
X     *  Quickly:  If not saving the contents, just do the fseek.
X     */
X    if (! mp->contents) {
X	mp->file_pos = off;
X	return (fseek (mp->fp, off, SEEK_SET));
X    }
X    /*
X     *  Reset all pointers to the beginning of the contents.
X     */
X    mp->cur_area = mp->contents;
X    mp->cur_area_idx = mp->file_pos = 0;
X    /*
X     *  Loop through the content areas until we find the offset.
X     */
X    while (off > 0) {
X	size = mp->cur_area->size;
X	if (off <= size) {
X	    mp->cur_area_idx = off;
X	    mp->file_pos += off;
X	    off = 0;
X	    break;
X	}
X	/*
X	 *  Advance the file position past the entire area.
X	 */
X	mp->cur_area_idx = size;
X	mp->file_pos += size;
X	off -= size;
X	/*
X	 *  Go to the next area.
X	 */
X	if (! mp->cur_area->next)
X	    break;
X	mp->cur_area = mp->cur_area->next;
X	mp->cur_area_idx = 0;
X    }
X    /*
X     *  Check if the offset was inside the known contents.
X     *  If it wasn't, I should probably read more of the file until
X     *  I reach the offset.  However, that case never comes up,
X     *  so I won't write it right now.
X     */
X    if (off > 0)
X	return (-1);
X    return (0);
X}
X
Xint Getc_contents (struct mfile *mp)
X{
X    int c;
X
X    if (mp->cur_area_idx < mp->cur_area->size) {
X	/*
X	 *  This character was all ready read from stdin.  Return it.
X	 */
X	c = mp->cur_area->buf[mp->cur_area_idx];
X	mp->cur_area_idx++;
X	/*
X	 *  Handle the case where we've reached the end of the current area
X	 *  but have not reached the end of the string of areas.
X	 */
X	if ((mp->cur_area_idx == mp->cur_area->size) &&
X	    (mp->cur_area->next != NULL)) {
X	    mp->cur_area = mp->cur_area->next;
X	    mp->cur_area_idx = 0;
X	}
X    } else {
X	/*
X	 *  Read from stdin and store it in memory.
X	 */
X	c = getc (mp->fp);
X	if (mp->cur_area_idx == AREA_SIZE) {
X	    mp->cur_area->next = new_area ();
X	    mp->cur_area = mp->cur_area->next;
X	    mp->cur_area_idx = 0;
X	}
X	mp->cur_area->buf[mp->cur_area_idx] = c;
X	mp->cur_area->size++;
X	mp->cur_area_idx++;
X    }
X    return (c);
X}
X
Xint Ungetc_contents (int c, struct mfile *mp)
X{
X    struct area *ap;
X
X    if (mp->cur_area_idx == 0) {
X	if (mp->cur_area == mp->contents)
X	    return (-1);
X	/*
X	 *  Looks like I should have used a doubly-linked list.
X	 *  Oh well, too late now.
X	 */
X	for (ap = mp->contents; ap->next != mp->cur_area; ap = ap->next);
X	mp->cur_area = ap;
X	mp->cur_area_idx = ap->size;
X    }
X    mp->cur_area_idx--;
X    mp->cur_area->buf[mp->cur_area_idx] = c;
X    return (c);
X}
X
Xvoid Fclose (struct mfile *mp)
X{
X    struct area *ap, *next;
X
X    fclose (mp->fp);
X    for (ap = mp->contents; ap != NULL; ap = next) {
X	next = ap->next;
X	free (ap);
X    }
X    free (mp);
X}
X
Xstatic struct area *new_area (void)
X{
X    struct area *ap;
X
X    ap = malloc (sizeof (struct area));
X    ap->size = 0;
X    ap->next = NULL;
X    return (ap);
X}
END-of-more/morefile.c
echo x - more/morefile.h
sed 's/^X//' >more/morefile.h << 'END-of-more/morefile.h'
X/*
X * Copyright (c) 1995 by Salvatore Valente <svalente@mit.edu>
X *
X * Redistribution and use in source and binary forms are permitted.
X * Have fun.
X *
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X/*
X *  morefile.h -- Functions to implement the "mfile" data type,
X *  which allows you to rewind an otherwise unrewindable file.
X *
X *  What's important here is to make Getc() as efficient as possible.
X *  It's called repeatedly in an extremely tight loop.
X *  Any cycle that can be shaved off of the running time of Getc()
X *  makes the program significantly more efficient.
X *  Maybe Getc_contents() should be inlined...?
X *
X */
X
X#ifndef MOREFILE_H_INCLUDED
X#define MOREFILE_H_INCLUDED
X
X#define AREA_SIZE 32768
X
Xstruct area {
X    char buf[AREA_SIZE];
X    int size;
X    struct area *next;
X};
X
Xstruct mfile {
X    FILE *fp;
X    struct area *contents;
X    struct area *cur_area;
X    int cur_area_idx;
X    int file_pos;
X};
X
X#if !defined(__GNUC__) && !defined(inline)
X#define inline
X#endif
X
Xextern struct mfile *Fopen (char *filename);
Xextern struct mfile *Fopen_stdin (void);
X
Xstatic inline off_t Ftell (struct mfile *mp)
X{
X    return (mp->file_pos);
X}
X
Xextern int Fseek (struct mfile *mp, size_t off);
X
X/*  These functions should only be called through Getc() and Ungetc(). */
Xextern int Getc_contents (struct mfile *mp);
Xextern int Ungetc_contents (int c, struct mfile *mp);
X
Xstatic inline int Getc (struct mfile *mp)
X{
X    mp->file_pos++;
X    return (mp->contents != NULL ? Getc_contents (mp) : getc (mp->fp));
X}
X
Xstatic inline int Ungetc (int c, struct mfile *mp)
X{
X    mp->file_pos--;
X    return (mp->contents != NULL ? Ungetc_contents (c, mp) :
X	    ungetc (c, mp->fp));
X}
X
Xextern void Fclose (struct mfile *mp);
X
X#endif /* MOREFILE_H_INCLUDED */
END-of-more/morefile.h
echo x - more/pathnames.h
sed 's/^X//' >more/pathnames.h << 'END-of-more/pathnames.h'
X#ifndef _PATH_HELPFILE
X#define _PATH_HELPFILE	"/usr/lib/more.help"
X#endif
X#ifndef _PATH_VI
X#define _PATH_VI	"/usr/bin/emacs"
X#endif
END-of-more/pathnames.h
echo x - more/regex.h
sed 's/^X//' >more/regex.h << 'END-of-more/regex.h'
X
X#ifndef REGEX_H_INCLUDED
X#define REGEX_H_INCLUDED
X
Xextern char *re_comp (const char *s);
Xextern int re_exec (const char *s);
Xextern void regerror (const char *s);
X
X#endif /* REGEX_H_INCLUDED */
END-of-more/regex.h
echo x - more/termcap.h
sed 's/^X//' >more/termcap.h << 'END-of-more/termcap.h'
X
X#ifndef TERMCAP_H_INCLUDED
X#define TERMCAP_H_INCLUDED
X
Xextern void tputs (const char *, int, int (*)(int));
Xextern int tgetent (char *, const char *);
Xextern int tgetnum (const char *);
Xextern int tgetflag (const char *);
Xextern char *tgetstr (const char *, char **);
Xextern char *tparam (const char *, void *, int, ...);
Xextern char *tgoto (const char *, int, int);
X
Xextern char PC;
Xextern short ospeed;
X
X#endif /* TERMCAP_H_INCLUDED */
END-of-more/termcap.h
exit

-- 
/*                 Sal Valente   <svalente@athena.mit.edu>               */
/*  All opinions stated here are shared by my school, my employer, my    */
/*  friends, my family, a large group of people I've never met, the      */
/*  entire cast of "Taxi," President Clinton, the Pope, Elvis, and you.  */

