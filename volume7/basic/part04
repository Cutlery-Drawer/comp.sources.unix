Subject:  v07i076:  A BASIC Interpreter, Part04/06
Newsgroups: mod.sources
Approved: mirror!rs

Submitted by: phil@Cs.Ucl.AC.UK
Mod.sources: Volume 7, Issue 76
Archive-name: basic/Part04

# Shar file shar04 (of 6)
#
# This is a shell archive containing the following files :-
#	termcap.c
#	cursor/cursor.c.ucl
#	cursor/cursor.c.ukc
#	docs/addfuncs.n
#	docs/basic.1
#	docs/short_forms
#	m68000/Makefile
#	m68000/conf.h
#	m68000/term.c
#	pdp11/Makefile.fp
#	pdp11/Makefile.nofp
# ------------------------------
# This is a shell archive, shar, format file.
# To unarchive, feed this text into /bin/sh in the directory
# you wish the files to be in.

echo x - termcap.c 1>&2
sed 's/^X//' > termcap.c << 'End of termcap.c'
X/*
X * BASIC by Phil Cockcroft
X */
X#include        "bas.h"
X
X#define         COMPILE
X#include        "cursor.c"
X#undef          COMPILE
X
X/*
X * Handle the termcap file
X */
X#define BUFSIZ	1024
X
Xchar    *tskip();
Xchar    *tgetstr();
Xchar    *getenv();
X
X
X#define CE      (sstrs[0])
X#define DC      (sstrs[1])
X#define DM      (sstrs[2])
X#define DO      (sstrs[3])
X#define ED      (sstrs[4])
X#define EI      (sstrs[5])
X#define IC      (sstrs[6])
X#define IM      (sstrs[7])
X#define ND      (sstrs[8])
X#define tUP     (sstrs[9])
X#define CL      (sstrs[10])
X
X
X#define AM      (sflags[0])
X#define BS      (sflags[1])
X#define HC      (sflags[2])
X#define NC      (sflags[3])
X#define BW      (sflags[4])
X
X
Xchar    o_CLEARSCR[33] = "\014";
X
Xset_cap()
X{
X	char ltcbuf[BUFSIZ];
X	char    *type = getenv("TERM");
X	char    *aoftspace;
X	register char   *namp,*fp,**sp;
X	char    sflags[5];
X	char    *sstrs[11];
X	char    tspace[128];
X	int     i,j;
X
X	if ( ! type || ! *type )
X		type = "xx";
X	if (tgetent(ltcbuf, type) != 1)
X		strcpy("uk|dumb:", ltcbuf);
X	aoftspace = tspace;
X	namp = "ambshcncbw";
X	fp = sflags;
X	do {
X		*fp++ = tgetflag(namp);
X		namp += 2;
X	} while (*namp);
X	namp = "cedcdmdoedeiicimndupcl";
X	sp = sstrs;
X	do {
X		*sp++ = tgetstr(namp, &aoftspace);
X		namp += 2;
X	} while (*namp);
X	i = tgetnum("co");
X	if(i > 0 && i < 1000)
X		ter_width = i;
X/*
X * now check to see if we are can use the editor. If so set up values
X */
X	if( !BS /* || !BW */ || HC || NC ){
X		noedit++;
X		return;
X	}
X/*  &CE, &DC, &DM, &DO, &ED, &EI, &IC, &IM, &ND, &UP, */
X	for(i= 0 ; i < 11 ; i++){
X		if(!(namp = sstrs[i]) )
X			j = 0;
X		else
X			j = strlen(namp);
X		if(j > 9 ){
X			if(i != 10 || j >= 33)     /* clear scr */
X				j = 0;
X		}
X		switch(i){
X		case 0: fp = o_DEOL;            /* ce */
X			break;
X		case 1: fp = o_DELCHAR;         /* dc */
X			break;
X		case 3: if(!j)
X				continue;
X			fp = o_DOWN2;           /* do */
X			break;
X		case 6: fp = o_INSCHAR;         /* ic */
X			break;
X		case 9: fp = o_UP;              /* up */
X			break;
X		case 10:                        /* clear screen */
X			if(!j)
X				continue;
X			fp = o_CLEARSCR;        /* clear screen */
X			break;
X		default:
X			continue;
X		}
X		if(!j)
X			*fp = 0;
X		else do {
X			*fp++ = *namp++;
X		} while(--j);
X	}
X}
End of termcap.c
chmod u=rw-,g=r,o=r termcap.c
echo x - cursor/cursor.c.ucl 1>&2
sed 's/^X//' > cursor/cursor.c.ucl << 'End of cursor/cursor.c.ucl'
X/*
X	To configure the editor to your system is relatively simple.
X	The input character is used as an index into this table with the
X	exception of character '\177' which is mapped through
X	location 33 of the table.
X	Assign to the character which is to do the relavent
X	function the code which is specified below.
X	E.g.
X		Backspace = '\010' ->   _in_char[010] = i_LEFT
X		Cursor Up = '\013' ->   _in_char[013] = i_UP
X
X*/
X
X#define i_CLEAR         01      /* redraw line */
X#define i_DELLINE       02      /* delete full line */
X#define i_DELCHAR       03      /* delete character under cursor */
X#define i_RUBOUT        04      /* delete the character to left */
X#define i_UP            05      /* move up a line */
X#define i_DOWN1         06      /* move down one line */
X#define i_CNTRLD        07      /* the eof character ( can't be '\177' ) */
X#define i_INSCHAR       010     /* toggle inset / overwrite switch */
X#define i_RIGHT         011     /* move 1 character right */
X#define i_LLEFT         012     /* move left to the last tab position */
X#define i_RRIGHT        013     /* move right to next tab position */
X#define i_DELSOL        014     /* delete to start of line */
X#define i_DELWORD       015     /* delete word to left */
X#define i_BACKWORD      016     /* move to previous word */
X#define i_NEXTWORD      017     /* go to start of next word */
X#define i_DEOL          020     /* delete to end of line */
X#define i_DOWN2         021     /* line feed */
X#define i_RETURN        022     /* return */
X#define i_ESCAPE        023     /* escape - used in other places */
X#define i_LEFT          024     /* Move left / backspace */
X
X#ifdef  COMPILE
Xextern  char    _in_char[];
X#else
Xchar    _in_char[] = {
X	0,              0,              i_DELLINE,      0,
X	i_CNTRLD,       0,              0,              0,
X	i_LEFT,         0,              i_DOWN2,        i_UP,
X	i_CLEAR,        i_RETURN,       i_DELCHAR,      i_INSCHAR,
X	i_LLEFT,        i_RRIGHT,       i_DELSOL,       0,
X	i_NEXTWORD,     i_BACKWORD,     i_DOWN1,        i_DELWORD,
X	i_RIGHT,        i_DEOL,         0,              i_ESCAPE,
X	0,              0,              0,              0,
X	i_RUBOUT,
X	};
X#endif
X
X#define LEFT            '\010'  /* move left ( backspace ) */
X#define UP              '\013'  /* move up a line */
X#define DELCHAR         '\016'  /* delete a character from current pos. */
X#define INSCHAR         '\017'  /* insert space at cursor posn. */
X#define DEOL            '\031'  /* delete from cursor to eol */
X#define DOWN2           '\012'  /* line feed */
X#define PING            '\007'  /* bell */
X#define RETURN          '\015'  /* carriage return */
X
X#ifdef  COMPILE
Xextern  char   _out_char[8][10];
X
X#define o_LEFT          (_out_char[0])
X#define o_UP            (_out_char[1])
X#define o_DELCHAR       (_out_char[2])
X#define o_INSCHAR       (_out_char[3])
X#define o_DEOL          (_out_char[4])
X#define o_RETURN        (_out_char[5])
X#define o_DOWN2         (_out_char[6])
X#define o_PING          (_out_char[7])
X
X#else
X
Xchar    _out_char[8][10]= {
X	LEFT,   0,0,0,0,0,0,0,0,0,
X	UP,     0,0,0,0,0,0,0,0,0,
X	DELCHAR,0,0,0,0,0,0,0,0,0,
X	INSCHAR,0,0,0,0,0,0,0,0,0,
X	DEOL,   0,0,0,0,0,0,0,0,0,
X	RETURN, 0,0,0,0,0,0,0,0,0,
X	DOWN2,  0,0,0,0,0,0,0,0,0,
X	PING,   0,0,0,0,0,0,0,0,0,
X	};
X#endif
End of cursor/cursor.c.ucl
chmod u=rw-,g=r,o=r cursor/cursor.c.ucl
echo x - cursor/cursor.c.ukc 1>&2
sed 's/^X//' > cursor/cursor.c.ukc << 'End of cursor/cursor.c.ukc'
X/*
X	To configure the editor to your system is relatively simple.
X	The input character is used as an index into this table with the
X	exception of character '\177' which is mapped through
X	location 33 of the table.
X	Assign to the character which is to do the relavent
X	function the code which is specified below.
X	E.g.
X		Backspace = '\010' ->   _in_char[010] = i_LEFT
X		Cursor Up = '\013' ->   _in_char[013] = i_UP
X
X*/
X
X#define i_CLEAR         01      /* redraw line */
X#define i_DELLINE       02      /* delete full line */
X#define i_DELCHAR       03      /* delete character under cursor */
X#define i_RUBOUT        04      /* delete the character to left */
X#define i_UP            05      /* move up a line */
X#define i_DOWN1         06      /* move down one line */
X#define i_CNTRLD        07      /* the eof character ( can't be '\177' ) */
X#define i_INSCHAR       010     /* toggle inset / overwrite switch */
X#define i_RIGHT         011     /* move 1 character right */
X#define i_LLEFT         012     /* move left to the last tab position */
X#define i_RRIGHT        013     /* move right to next tab position */
X#define i_DELSOL        014     /* delete to start of line */
X#define i_DELWORD       015     /* delete word to left */
X#define i_BACKWORD      016     /* move to previous word */
X#define i_NEXTWORD      017     /* go to start of next word */
X#define i_DEOL          020     /* delete to end of line */
X#define i_DOWN2         021     /* line feed */
X#define i_RETURN        022     /* return */
X#define i_ESCAPE        023     /* escape - used in other places */
X#define i_LEFT          024     /* Move left / backspace */
X
X#ifdef  COMPILE
Xextern  char    _in_char[];
X#else
Xchar    _in_char[] = {
X	0,              0,              i_DELLINE,      0,
X	i_CNTRLD,       i_DELSOL,       0,              0,
X	i_LEFT,         0,              i_DOWN1,        i_UP,
X	i_CLEAR,        i_RETURN,       i_DELCHAR,      i_INSCHAR,
X	i_RRIGHT,       0,              0,              0,
X	i_NEXTWORD,     i_BACKWORD,     i_DOWN1,        i_DELWORD,
X	i_RIGHT,        i_DEOL,         i_LLEFT,        i_ESCAPE,
X	0,              0,              0,              0,
X	i_RUBOUT,
X	};
X#endif
X
X#define LEFT            '\010'  /* move left ( backspace ) */
X#define UP              '\013'  /* move up a line */
X#define DELCHAR         '\016'  /* delete a character from current pos. */
X#define INSCHAR         '\017'  /* insert space at cursor posn. */
X#define DEOL            '\031'  /* delete from cursor to eol */
X#define DOWN2           '\012'  /* line feed */
X#define PING            '\007'  /* bell */
X#define RETURN          '\015'  /* carriage return */
X
X#ifdef  COMPILE
Xextern  char   _out_char[8][10];
X
X#define o_LEFT          (_out_char[0])
X#define o_UP            (_out_char[1])
X#define o_DELCHAR       (_out_char[2])
X#define o_INSCHAR       (_out_char[3])
X#define o_DEOL          (_out_char[4])
X#define o_RETURN        (_out_char[5])
X#define o_DOWN2         (_out_char[6])
X#define o_PING          (_out_char[7])
X
X#else
X
Xchar    _out_char[8][10]= {
X	LEFT,   0,0,0,0,0,0,0,0,0,
X	UP,     0,0,0,0,0,0,0,0,0,
X	DELCHAR,0,0,0,0,0,0,0,0,0,
X	INSCHAR,0,0,0,0,0,0,0,0,0,
X	DEOL,   0,0,0,0,0,0,0,0,0,
X	RETURN, 0,0,0,0,0,0,0,0,0,
X	DOWN2,  0,0,0,0,0,0,0,0,0,
X	PING,   0,0,0,0,0,0,0,0,0,
X	};
X#endif
End of cursor/cursor.c.ukc
chmod u=rw-,g=r,o=r cursor/cursor.c.ukc
echo x - docs/addfuncs.n 1>&2
sed 's/^X//' > docs/addfuncs.n << 'End of docs/addfuncs.n'
X
XNotes for updateing and maintaining Basic.
X                (c) P. (Rabbit) Cockcroft 1982.
X
X1) Variables and their uses.
X
Xchar    *point    - This points to the next character that will
X                    be interpreted.
X
Xtypedef struct lin *lpoint
X
Xlpoint  stocurlin - Points to the start of the line structure
X                    of the current line. Is null in direct mode.
X
Xunsigned curline  - Linenumber of current line being executed.
X                    Zero in direct mode.
X
Xlpoint  errortrap - Pointer to start of line where error trapping will
X                    go to. Null if no error trapping.
X
Xchar    inserted  - Flag set if program has been changed. Used to clear
X                    data space if program text changed.
X
Xchar    trapped   - Set if cntrl-c has been hit. Will cause program to
X                    exit next time through the execute routine.
X
Xchar    elsecount - Set if elses are legal terminators. (After an if
X                    statement only).
X
Xchar    runmode   - Set if in runmode. Zero in direct mode.
X
Xchar    vartype   - Type of variable. Set by getname() - get a variable,
X                    getop() - get a number and several of the other
X                    functions.
X                    Values:-   0) Floating point variable
X                               1) Integer variable
X                               2) String variable.
X
Xchar   *filestart - Pointer to start of file buffers. If you want to
X                    add more dynamic buffers for other purposes. Put
X                    them in before filestart is initialised. For semi
X                    permanent buffers. Or place them after estarr and
X                    change data space by using xpand (Fairly unstable).
X
Xchar    *fendcore - End of file buffers start of basic text.
X
Xchar    *ecore    - End of basic program.
X
Xchar    *vvend    - Very end of allocated data. Changes very quickly
X                   ( by for-next - gosub stack ).
X
Xtypedef value  union {
X                double f;
X                int     i;
X                };
X
Xvalue  res        - General purpose register for maths. Result always in
X                    here. (else return value from evalint() ).
X
Xlong  overfl      - Used when integer maths overflows. Value is
X                    converted from long to double with vartype set
X                    accordingly by over().
X
Xint     cursor    - Current cursor location across screen.
X
Xchar    line[]    - Input line. Place where edit and readfi() put the
X                    input line. Where the editor works. Input to compile
X                    function.
X
Xchar    nline[]   - Compiled line is here. What is executed in direct
X                    mode. Sqirelled away by insert().
X
Xint     (*functb[]),
X        (*functs[]),
X        (*commandf[]),
X        (*strngcommand[]) - Maths , Command, and string function jump tables.
X
Xchar    *ermsg[]  - Table of error messages. To add other error messages
X                    put them at the end of this table and increment MAXERR.
X
XOther pointers and variables are used for various purposes probarbly
Xnot needed for adding functions. Don't change them if you don't know
Xwhat they do.
X
X2) Useful functions.etc.
X
Xobject *getname() - If point points to a valid name then returns a
X                    pointer to it. If variable does not exist create it.
X                    (Will not create arrays).
X                    Only ever returns with a valid pointer.
X
Xint     getch()   - Get the next character on the line. Ignores spaces.
X                    ( Care must be used at end of line so don't run off).
X
Xint     check()   - calls error if not at the end of a statement.
X                    Use when got all arguments and want to see if and
X                    garbage is at end of command.
X
Xint     error()   - Call error routines. Will always tidy up. Sets error
X                    code to parameter. (NO checking of parameter is done).
X                    THIS ROUTINE NEVER RETURNS. WILL ALWAYS GET YOU OUT
X                    FROM WHERE YOU ARE BACK TO COMMAND MODE. (Useful).
X
Xint     eval()    - Will evaluate any mathematical expression. The
X                    result will be in res with vartype set accordingly.
X
Xint     evalint() - Will call eval() and then returns an integer if
X                    possible. Otherwise returns -1. (Negative values are
X                    usually thought of as an error).
X
Xint     stringeval(f) - Will evaluate string expressions. f is the
X                    destination it must be a pointer to a character
X                    array of at least 256 characters. (Usually gblock or
X                    on stack or allocated by grow() -actually on the stack).
X                    gcursiz will contain the length of the string.
X                    N.B. gblock (can) will be corrupted by stringeval
X                        and the input routine ( edit() ).
X
Xint     edit(f1,f2) - Input routine from the terminal. (Full editor).
X                   f1 is number of characters to be used as a prompt.
X                   (in line[] ), f2 is the number of characters to be
X                   printed out at the start. (so can be used to edit the
X                   given string. The string must already be in line[].
X                   f2 must never be less than f1.
X
Xobject  *grow(v) - Will allocate v bytes on the stack. V must be even.
X                   Should be used for maths functions which need a lot
X                   of stack space for their local variables. It will
X                   call error if it runs out of stack space. (Will only
X                   use one segmentation register for the stack. Rest is
X                   for program and data). Returns a pointer to the space.
X                   (This means that 75 or so brackets can be used).
Xint   istermin(c),
X      isletter(c),
X      isdigit(c) - Macros that return true if c is a terminator, a
X                   letter or a digit.
X
X3) Adding More functions, commands. etc.
X
XThe basic idea is to put an entry in the corresponding table and to add
Xthe function name and token value into the tokenising table at the
Xcorrect spot. Commands need to return a value all others do not.
XCommands that need to change the direction of the program return -1
Xotherwise use 'normret'. - Most commands will return by using 'normret'.
X
XMaths and string functions that require brackets fit perfectly into this
Xscheme but the exceptions are as follows:-
X
Xcommands:-
X        These require a zero to be deleted and the function to be
Xadded in it's place this is so that mid$ can be used on the left hand
Xside of a statement. Nothing else need be done.
X
XMaths functions without brackets or optional brackets:-
X        These are nasty because the value of rnd is used for various
Xuses. So :- Decrement the defined constant RND and then decrement the
Xentry in the tokenising table. Place the new entry where RND used to be.
X
X( Maybe you might like to make brackets not as tightly bound to
Xfunctions - currently must be tight against the keyword (No particular
Xreason but thats how I like functions to be)).
End of docs/addfuncs.n
chmod u=rw-,g=r,o=r docs/addfuncs.n
echo x - docs/basic.1 1>&2
sed 's/^X//' > docs/basic.1 << 'End of docs/basic.1'
X.TH BASIC 1
X.SH
Xbasic \- `Basic' language interpreter
X.SH SYNOPSIS
X.B basic
X[ -e -x -n file ]
X.SH DESCRIPTION
X.B Basic
Xis an interpreter for the Basic language. See below
Xfor current commands recognised. If a file is given then
Xthat file is loaded up into core and run without any
Xinteraction. This can be used for games etc. which use a
Xsmall calling program which is set user-id. All commands
Xare only recognised in lower case. A line editor is
Xinvoked for all input from the terminal.
XTo get characters less than space into a line use the
Xconstruct \\n \\a etc. which will get cntrl-n and
Xcntrl-a into the line.
X.PP
XFLAGS
X.HP 6
X-e use the in built editor for line input. Even when
Xdefault mode is for no editor.
X.HP 6
X-x don't use the editor ever. Use the terminal driver
Xfor all editing and input.
X.HP 6
X-n where n is any number between 0 and 9 defines the
Xnumber of file buffers allocated at start up.
X.PP
XCOMMANDS
X.HP 6
XStandard Dartmouth Basic Commands:-
X.HP 6
Xend
X.br
XThis terminates the execution of a program
Xand returns to command level.
X.HP 6
Xrun { l }
X.br
XThis will execute a program, if an optional
Xline number is given then the program is run from that
Xline. All variables are cleared and all files are
Xclosed.
X.HP 6
Xgoto l
X.br
XThis command will transfer control to the
Xspecified line number
X.HP 6
Xlet x = EXP
X.br
XThis command is used to introduce an
Xassignment. If a command is not found on a line then a
Ximplied let is assumed.
X.HP 6
Xlist
X.br
Xthe whole file
X.HP 6
Xlist 1-2
X.br
Xlines 1 to 2
X.HP 6
Xlist -1
X.br
Xlines up to 1
X.HP 6
Xlist 1
X.br
Xline 1
Xlist 1-
X.HP 6
X.br
Xline 1 onwards
X.br
XThis command will list any number of lines of
Xtext onto the terminal. The start and last line can be
Xspecified as can to a specified line and from a
Xspecified line.
X.HP 6
Xprint or '?'
X.HP 6
Xprint #f
X.br
XThis command will print out all of it's
Xparameters, they have to be separated by commas or
Xsemi-colons, if a comma is used then the print head is
Xmoved to the next tab position (16 places ). If a file
Xdescriptor is given then output is to the given file.
X.HP 6
Xrem or `'
X.br
XA comment statement, is ignored totally by
Xthe program during execution.
X.HP 6
Xstop
X.br
XStops the execution of the program and
Xreturns to command level. Similar to 'end' but prints a
Xmessage. A program can also be 'cont'inued after a stop.
X.HP 6
Xfor x = EXP to EXP { step EXP }
X.br
XWill start execution of a for loop. It will
Xtake the two limits and an optional step argument. The
Xloop is always executed once.
X.HP 6
Xnext { x { , y } }
X.br
XEnd of the for loop, if the terminal
Xconditions are met then execution continues from the
Xnext statement otherwise return to end of the
Xcorresponding for statement. The next does not need a
Xparameter if this is the case the most recently
Xactivated loop is used. If there are more than one
Xparameter then each one is only checked after the
Xcompletion of the inner loop.
X.HP 6
Xgosub l
X.br
XTransfer command to a line number. Save
Xreturn address so that the program can resume execution
Xafter the gosub command.
X.HP 6
Xreturn
X.br
XReturn from a subroutine ( called by gosub ).
XIt will return from the most recently activated
Xsubroutine call.
X.HP 6
Xread VAR { , VAR }
X.br
XRead data from the data statements contained
Xin the program. An item can be a string or a variable.
X.HP 6
Xdata OBJECT { , OBJECT }
X.br
XStatements that contain the data used in the
Xread statements. Items are separated by commas. The
Xdata statement must be the only one on the line.
X.HP 6
Xrestore { l }
X.br
XRestore the data pointer to the start of the
Xfile. So that the data can be read again. If an
Xoptional line number is given then the restore occurs
Xfrom the start of that line. If no data statements are
Xfound then the restore is from the start of the
Xprogram.
X.HP 6
Xif EXP then STATEMENT { else STATEMENT }
X.br
XThe if statement if the condition is true
Xthen the commands after the 'then' are executed. If
Xthis is a line number then a goto is performed. If the
Xcondition is false then the statement after the else is
Xdealt with in a similar manner, the else statement is
Xan optinal facility.
X.HP 6
Xdim VAR(d,d,d) { , VAR(d) }
X.br
XDimension a list of arrays ( string or
Xarithmetic ) a maximum of three subscripts can be used.
XAll arrays must be dimensioned before use.
X.HP 6
Xexit , bye , quit
X.br
XTerminate the execution of the interpreter,
Xclosing all files.
X.PP
XExtended Basic Commands
X.HP 6
Xdelete l - l
X.br
XDelete a specified range of lines. If they
Xare not found then no lines will be deleted.
X.HP 6
Xedit l
X.br
XEdit a given line. If the exit from the edit
Xis via a cntrl-c then do not change the line.
X.HP 6
Xinput { #f, } 
X.br
Xinput "prompt";
X.br
XInput from a terminal or from a file. If the
Xinput is from the terminal then a prompt message can
Xalso be added.
X.HP 6
Xclear EXP
X.br
XClear all variables then allocate the amount
Xof string space specified by the second parameter.
X.HP 6
Xsave STRINGEXP
X.br
XSave the current program to a named file.
X.HP 6
Xold STRINGEXP
X.br
XLoad a program from the named file. All
Xvariables are cleared.
X.HP 6
Xnew { EXP }
X.br
XWipe the program from core. All files are
Xclosed and the interpreter is reset to its inital
Xstate. If a parameter is given then that is the number
Xof file buffers that are allocated.
X.HP 6
Xshell
X.br
XShell out to Unix. This is the Bourne shell. If
Xthe interpreter is made set userid then this is turned
Xoff in the shell.
X.HP 6
Xresume { l }
X.br
XReturn from an error trap. If a parameter is
Xgiven then the return is made to that line. An error
Xtrap is set up by the "on error goto" statement.
X.HP 6
Xrandom
X.br
XRandomise the random number generator. The
Xgenerator always starts from the same place in its
Xsequence, when a program is started.
X.HP 6
Xon EXP goto l { , l}
Xon - gosub
Xon error goto l
X.br
XThis command will execute either a goto or a
Xgosub to a specified line number. The linenumber is
Xspecified by the value of the statement and the
Xlinenumber is taken from the list of line numbers that
Xis given.
XIf the error format is used, only one
Xlinenumber is required. This is the line where a jump
Xis performed to if an error occurs.
X.HP 6
Xerror EXP
X.br
XExecute the given error sequence. Useful for
Xdebugging of error trap routines.
X.HP 6
Xauto { l { ,l } }
X.br
XPerform auto line numbering so that a program
Xcan be typed in without having to bother about
Xlinenumbers. An optional start and increment can also
Xbe specified.
X.HP 6
Xcls
X.br
XClear the terminals screen.
X.HP 6
Xbase 0 | 1
X.br
XSpecify the starting index for arrays. This
Xcan have a value of either zero or one.
X.HP 6
Xpoke EXP,EXP
X.br
XPoke a value into a location. Unreasonable
Xaddresses are ignored. ( Can cause bus-errors if not
Xusing split i and d space.
X(Not available on Vax systems).
X.HP 6
Xopen STRINGEXP
X{ for input|output|append|terminal } as EXP
X.br
XOpen a file for input/ output. This command
Xcan be used to specify whether the file is to be read
Xor writen to. A file cannot be opened for writing if
Xthe file is already open. If the mode is terminal then
Xit will believe that it is talking to a terminal. (No
Xbuffering. Open for reading and writing.) If the option
Xis 'for output' it may be ommitted.
X.HP 6
Xclose EXP
X.br
XClose a file. Releases the file descriptor
Xand flushes out all stored data.
X.HP 6
Xmerge STRINGEXP
X.br
XMerge two files together. If there is a line
Xin the file with the same linenumber as in the program
Xthen that line is replaced by the new one. All other
Xlines are inserted into the file.
X.HP 6
Xchain STRINGEXP
X.br
XRead in a program, then start to execute it.
XAll simple variables are kept but all arrays and
Xstrings are cleared. The size of the string space is
Xkept the same.
X.HP 6
Xdef fnNAME{ ( VAR {,VAR } ) } = EXP
X.br
XDefine a user defineable function.
X.HP 6
Xlinput
X.br
XIdentical to input but ignores seperators.
X.HP 6
Xmid$(STRINGVAL, EXP { ,EXP} ) = STRINGEXP
X.br
XAssign STRINGEXP to STRINGVAL starting at EXP1
Xand finishing at EXP2.
X.HP 6
Xcont
X.br
XContinue execution of a program that has been
Xhalted by a stop statement or by control-c.
X.HP 6
Xwhile EXP
X.br
XStart of a while loop. The loop is repeated
Xuntil EXP is false. If EXP is false at the start then do
Xnot execute the loop at all. A while loop must be
Xterminated by a wend statement.
X.HP 6
Xwend
X.br
XTerminating statement of a while loop. Only one
Xwend is allowed for each while.
X.HP 6
Xrepeat
X.br
XStart statement for a repeat - until loop. This
Xtype of loop will always be executed at least once.
X.HP 6
Xuntil EXP
X.br
XThe terminating statement of a repeat - until
Xloop. The loop terminates when EXP is true.
X.PP
XString functions Available
X.br
X.HP 6
Xmid$(a$,i,j)
X.br
XReturns the part of a$ between the i'th and
Xj'th positions. If the second parameter is not
Xspecified then the string is taken between the start
Xvalue and the end of the string.
X.HP 6
Xright$(a$,j)
X.br
XReturns the right j characters of a$.
X.HP 6
Xleft$(a$,j)
X.br
XReturns the left j characters of a$.
X.HP 6
Xstring$(a$,j)
X.br
XReturns a$ repeated j times.
X.HP 6
Xermsg$(j)
X.br
XReturns the j'th error message.
X.HP 6
Xchr$(j)
X.br
XReturns the ascii character corresponding to
Xthe value of j.
X.HP 6
Xstr$(j)
X.br
XReturns a string representation corresponding
Xto j. This is similar but not the same as what can
Xprinted out.
X.HP 6
Xspace$(j)
X.br
XReturns a string of j spaces
X.HP 6
Xget$(f)
X.br
XReturns one character from file f. If f is zero
Xuse the terminal. Returns a zero lenght string on cntl-c
X.HP 6
Xdate$
X.br
Xreturns a string coresponding to the current
Xdate. ( Same string as printed out when logging on. ).
X.PP
XMaths functions Available:-
X.HP 6
Xsgn(x)
X.br
XReturns the sign of a number. It's value is 1
Xif greater than zero , zero if equal to zero. -1 if
Xnegative.
X.HP 6
Xlen(a$)
X.br
XReturns the length of string a$.
X.HP 6
Xabs(x)
X.br
XReturns the absolute value of x.
X.HP 6
Xint(x)
X.br
Xthan x.
X.HP 6
Xval(a$)
X.br
XReturns the value of the number specified by
Xthe string.
X.HP 6
Xasc(a$)
X.br
XReturns the ascii code for the first element
Xof a$.
X.HP 6
Xinstr(a$,b$,c)
X.br
XReturns the starting position that a$ is in
Xb$, starting from the optional c'th position.
X.HP 6
Xeof(f)
X.br
XReturns true if the file specified by f has
Xreached the end of the file.
X.HP 6
Xposn(f)
X.br
XReturns the current printing position in the
Xfile. If f is zero then it is the printing position of
Xthe terminal.
X.HP 6
Xsqrt(x)
X.br
XReturns the square root of X.
X.HP 6
Xlog(x)
X.br
XReturns the natural logarithm of x.
X.HP 6
Xexp(x)
X.br
XReturns e^x. e=2.7182818..
X.HP 6
Xeval(a$)
X.br
XEvaluates a$.
Xe.g. eval("12") returns the value 12.
X.HP 6
Xrnd
X.br
XReturns a random number between 1 and 32767.
X.HP 6
Xrnd(x)
X.br
XIf x is zero returns a random number between
X0 and 1 otherwise returns a random number
Xbetween 1 and int(x).
X.HP 6
Xpeek(x)
X.br
XReturns the value of the byte at address x.
XIf x is unreasonable then returns zero.
X( Not available on a VAX )
X.HP 6
Xsin(x)
X.br
X.HP 6
Xcos(x)
X.br
X.HP 6
Xatan(x)
X.br
XTrignometric functions. (May not yet be
Ximplemented).
X.HP 6
Xpi
X.br
XReturns the value of pi. = 3.141592653589...
X.HP 6
Xerl
X.br
XReturns the line number of the last error.
XZero if error was in immeadiate mode.
X.HP 6
Xerr
X.br
XReturns the error code of the last error.
X.HP 6
Xtim
X.br
XReturns a numeric value for the number of
Xseconds since
X1:1:1970 i.e. the value of the Unix clock.
X.PP
XMathematical Operators:-
X.HP 6
X	The  following  mathematical  operators   are
Xaccepted.
X.nf
X             ^               exponentiation
X             *               multiplication
X             /               division
X             mod             remainder
X             +               addition
X             -               subtraction
X
X     bitwise operators:-
X        for real values non-zero is true,
X             and             bitwise and
X             or              bitwise or
X             xor             bitwise exclusive or
X             not             bitwise not
X
X     comparison operators:-
X             <=              less than or equal
X             <>              not equal to
X             >=              greater than or equal
X             =               equal
X             >               greater than
X             <               less than
X
X      Assignment statements can also have the form
X        a +=  b     a -=  b     a *=  b    a /=  b
X      Which have similar meanings to C's interpretation
X.fi
X.PP
X.nf
XEXPRESSION SYNTAX
X
X        stringexp  ::= string | string + stringexp
X        string     ::= qstring | stringvar | stringfunc
X        qstrings   ::= "any char" | `any char`
X                        N.B. strings with nothing after them on the
X                             line do not need the terminating quote
X        stringvar  ::= numbvar$ | numbvar$[ dim1 { ,dim2 {, dim3 } } ]
X        stringfunc ::= chr$(val) | mid$(stringexp, val {,val} )
X                        | date$ | right$(stringexp, val)
X                        | left$(stringexp, val) | ermsg$(val)
X                        | str$( val) | space$(val)
X                        | string$(stringexp, val) | get$( 0 | fval )
X
X        val        ::= term | term sep val
X                        | not val | - val
X        term       ::= numb | valfunc | numbvr
X                        | stringexp csep stringexp
X        numb       ::= digit | digit digit+
X                        | digit* . digit*
X                        | digit* e {+ | -} digit+
X                        | digit* . digit* e {+ | -} digit+
X        digit      ::= 0 1 2 3 4 5 6 7 8 9
X        numbvr     ::= numbvar | subsc
X        numbvar    ::= lett | lett alpha+
X        subsc      ::= numbvar( val {, val { ,val } } )
X        sep        ::= + - * /  ^ and or xor | csep
X        csep       ::= <> > < >= <= =
X        valfunc    ::= sgn(val) | len(stringexp)
X                        | abs(val) | val(stringexp)
X                        | asc(stringexp) | eof(fval)
X                        | posn( 0 | fval) | sqrt(val)
X                        | instr(stringexp, val { ,val} )
X                        | log(val) | exp(val) | eval(stringexp)
X                        | int(val) | peek(val) | rnd
X                        | rnd(val) | usrfunc | pi
X                        | erl | err | tim
X        usrfunc    ::=  fn/numbvar { (val { , val { , val } } ) }
X        fval       ::= val with value between 1-9
X
X.SH DIAGNOSTICS
XWhen the interpreter discovers an error it will call
Xan error trapping routine. The errors can be caught by
Xthe user program using the on-error feature. If no error
Xtrapping routine has been supplied a message is printed
Xwith the corresponding line number.
X
X.SH BUGS
XNone yet!
X
X.SH AUTHOR
XPhil Cockcroft
End of docs/basic.1
chmod u=rw-,g=r,o=r docs/basic.1
echo x - docs/short_forms 1>&2
sed 's/^X//' > docs/short_forms << 'End of docs/short_forms'
XWhen using the SCOMMS option these are the shortened representations
Xof the commands.
X----------------
Xabs     abs
Xand     an.
Xappend  ap.
Xas      as
Xasc     asc
Xatan    at.
Xauto    a.
Xbase    b.
Xbye     by.
Xchain   ch.
Xchr$    chr.
Xclear   c.
Xclose   clo.
Xcls     cls
Xcont    co.
Xcos     cos
Xdata    da.
Xdate$   date.
Xdef     def
Xdelete  d.
Xdim     di.
Xdump    du.
Xedit    ed.
Xelse    el.
Xend     e.
Xeof     eo.
Xerl     erl
Xermsg$  erm.
Xerr     err
Xerror   er.
Xeval    ev.
Xexit    ex.
Xexp     exp
Xfn      fn
Xfor     f.
Xget$    ge.
Xgosub   gos.
Xgoto    g.
Xif      if
Xinput   i.
Xinstr   ins.
Xint     int
Xleft$   le.
Xlen     len
Xlet     le.
Xlinput  lin.
Xlist    l.
Xload    lo.
Xlog     log
Xmerge   m.
Xmid$    mi.
Xmkds$   mkd.
Xmkis$   mk.
Xmksd    mksd
Xmksi    mks.
Xmod     mod
Xnew     n.
Xnext    nex.
Xnot     not
Xold     o.
Xon      on
Xopen    op.
Xor      or
Xoutput  ou.
Xpeek    pe.
Xpi      pi
Xpoke    po.
Xposn    pos.
Xprint   p.
Xquit    q.
Xrandom  ra.
Xread    rea.
Xrem     re.
Xrenumber ren.
Xrepeat  rep.
Xrestore rest.
Xresume  res.
Xreturn  ret.
Xright$  ri.
Xrnd     rn.
Xrun     r.
Xsave    sa.
Xseek    se.
Xsgn     sg.
Xshell   sh.
Xsin     sin
Xspace$  sp.
Xsqrt    sq.
Xstep    ste.
Xstop    s.
Xstr$    str.
Xstring$ st.
Xtab     ta.
Xterminal ter.
Xthen    th.
Xtim     t.
Xto      to
Xuntil   u.
Xval     v.
Xwend    we.
Xwhile   w.
Xxor     xo.
End of docs/short_forms
chmod u=rw-,g=r,o=r docs/short_forms
echo x - m68000/Makefile 1>&2
sed 's/^X//' > m68000/Makefile << 'End of m68000/Makefile'
X# which cursor file we want.
X# can be ucl or ukc or ssl
XCURSOR = ucl
X
Xbasic:  bas1.o bas2.o bas3.o bas4.o bas5.o bas6.o bas7.o bas8.o \
X       bas9.o cursor.o termcap.o assist.o term.o
X	cc -O bas1.o bas2.o bas3.o bas4.o bas5.o bas6.o bas7.o \
X       bas8.o bas9.o cursor.o termcap.o assist.o term.o -lm -ltermcap -o basic
X
Xclean:
X	rm -f *.o *.s cursor.c term.c
X
Xassist.o: bas.h assist.c
X	cc -O -c -Dm68000 -Uvax -Updp11 assist.c
X
Xterm.o: term.c
X	cc -O -c term.c
X
Xterm.c: m68000/term.c m68000/conf.h
X	cp m68000/term.c term.c
X
Xtermcap.o: bas.h termcap.c cursor.c
X	cc -O -c -Dm68000 -Uvax -Updp11 termcap.c
X
Xcursor.c: cursor/cursor.c.${CURSOR}
X	cp cursor/cursor.c.${CURSOR} cursor.c
X
Xcursor.o: cursor.c
X	cc -O -c cursor.c
X.c.o:
X	cc -O -c -Dm68000 -Uvax -Updp11 $*.c
X
Xbas.h:  m68000/conf.h
X
Xbas1.o: bas1.c bas.h
Xbas2.o: bas2.c bas.h
Xbas3.o: bas3.c bas.h
Xbas4.o: bas4.c bas.h
Xbas5.o: bas5.c bas.h
Xbas6.o: bas6.c bas.h
Xbas7.o: bas7.c bas.h
Xbas7.c: cursor.c
Xbas8.o: bas8.c bas.h
Xbas9.o: bas9.c bas.h
End of m68000/Makefile
chmod u=rw-,g=r,o=r m68000/Makefile
echo x - m68000/conf.h 1>&2
sed 's/^X//' > m68000/conf.h << 'End of m68000/conf.h'
X/*
X * BASIC by Phil Cockcroft
X */
X/*
X * configuration file for Motorola 68000 systems
X */
X
X/*
X * standard constants of a motorola 68000 processor
X */
X
X#define MAXMEM  (memp)500000    /* maximum memory it is allowed */
X#define MEMINC  8191            /* memory increment size -1 */
X#define BLOCKSIZ 512            /* size of disk blocks */
X#define MPORTABLE		/* must use portable memory allocation */
X/*
X * could possibly not use this.
X * It would make it much faster if we didn't need to 
X * It is used to make the Fp routines portable.
X */
X#define PORTABLE                /* must use the portable version of */
X				/* the code */
X
X/*
X * various options
X */
X
X#define V7
X#define BERK
X#define LKEYWORDS
X#define LNAMES
X#define RENUMB
X#define SCOMMS
X#define MCBREAK
X
X/*
X * various terminal options
X */
X
X#define CTRLINT         03      /* the interupt character */
X#define CTRLQUIT        034     /* the quit FS character */
X#define DEFPAGE         80      /* default page width */
X
X
X/* #define V7     */ /* define for v7 */
X/* #define BERK   */ /* define if got Berkley tty driver ( not v6 ) */
X
X/* #define MCBREAK   /* define if you want to always be in cbreak mode */
X		     /* because the terminal driver is broken */
X
X/* #define NOEDIT    /* define if don't want editing ever ! */
X		     /* NB basic -e will still turn on editing */
X		     /* basic -x will still turn off editing */
X
X/* #define LKEYWORDS /* define this if you want to have variable names which*/
X		     /* contain commands this is like the later versions of */
X		     /* microsoft but not like the orignal version */
X		     /* it wastes more space since you have to have some */
X		     /* spaces in to distinguish keywords */
X
X/* #define RENUMB    /* define if you want to put the code for renumbering */
X		     /* in. It works but is very wasteful of space. If you */
X		     /* are short of space then don't use it. */
X
X/* #define LNAMES    /* define if you want long variables names. This only */
X		     /* slows it down by a small fraction */
X
X/* #define _BLOCKED  /* This is a switch to allow block mode files */
X		     /* don't define it here look below for where it is done*/
X		     /* in the file handling bits */
X
X/* #define SCOMMS    /* to allow shortened command names e.g. l. -> list */
X		     /* this might cause some problems with overwriting of */
X		     /* core but I think they have all been solved */
End of m68000/conf.h
chmod u=rw-,g=r,o=r m68000/conf.h
echo x - m68000/term.c 1>&2
sed 's/^X//' > m68000/term.c << 'End of m68000/term.c'
X/*
X * BASIC by Phil Cockcroft
X */
X/*
X * terminal specific configuration routines for 68000's
X */
X#include "m68000/conf.h"
X#include <sgtty.h>
X
Xstruct  sgttyb  osttyb,nsttyb;
Xstruct  tchars  otchr,ntchr;
X
Xextern  int     ter_width;
Xextern  char    noedit;
X
X#ifndef SCOPE
X#define SCOPE   0
X#endif
X
X#ifdef  MCBREAK
Xstatic  char    doneset;
X#endif
X
Xstatic  int     got_mode;
X
Xsetu_term()
X{
X	register i;
X	char    *p, *getenv();
X
X	p = getenv("TERM");
X
X	ioctl(0,TIOCGETP,&osttyb);
X	nsttyb=osttyb;
X	ioctl(0,TIOCGETC,&otchr);
X	ntchr = otchr;                  /* do we need this ??? */
X	ntchr.t_brkc = -1;
X	ntchr.t_eofc = -1;
X	ntchr.t_intrc = CTRLINT;
X	ntchr.t_quitc = CTRLQUIT;
X	if(p && strcmp(p, "ucl7009") == 0){
X		ntchr.t_startc = -1;
X		ntchr.t_stopc = -1;
X	}
X	i = osttyb.sg_flags & ( LCASE | XTABS);
X#ifdef  MCBREAK
X	nsttyb.sg_flags = CBREAK | ANYP | CRMOD | i;
X#else
X	nsttyb.sg_flags = CBREAK | ANYP | i;
X#endif
X	osttyb.sg_flags = ECHO | ANYP | CRMOD | SCOPE | i;
X	if(ter_width <= 0)
X		ter_width=DEFPAGE;
X	got_mode = 1;
X}
X
Xset_term()
X{
X	if(noedit || !got_mode)
X		return;
X#ifdef  MCBREAK
X	if(doneset)
X		return;
X	doneset = 1;
X#endif
X	ioctl(0,TIOCSETN,&nsttyb);
X	ioctl(0,TIOCSETC,&ntchr);
X}
X
Xrset_term(type)
X{
X	if(noedit || !got_mode)
X		return;
X#ifdef  MCBREAK
X	if(!type){
X		/* in editing loop */
X		if(doneset)
X			return;
X	} else
X		doneset = 0;
X#endif
X	ioctl(0,TIOCSETN,&osttyb);
X	ioctl(0,TIOCSETC,&otchr);
X}
End of m68000/term.c
chmod u=rw-,g=r,o=r m68000/term.c
echo x - pdp11/Makefile.fp 1>&2
sed 's/^X//' > pdp11/Makefile.fp << 'End of pdp11/Makefile.fp'
XSEPID=-i
X# which cursor control file you want . either ucl or ukc
XCURSOR = ucl
X
Xbasic:  bas1.o bas2.o bas3.o bas4.o bas5.o bas6.o bas7.o bas8.o \
X       bas9.o cursor.o termcap.o fpassist.o term.o
X	cc -s -O ${SEPID} fpassist.o bas1.o bas2.o bas3.o bas4.o bas5.o \
X       bas6.o bas7.o bas8.o bas9.o cursor.o termcap.o term.o -lm -o basic
X
Xclean:
X	rm -f *.o *.s term.c cursor.c
X
Xfpassist.o: pdp11/fpassist.s
X	cp pdp11/fpassist.s fpassist.s
X	cc -O -c fpassist.s
X	rm -f fpassist.s
X
Xterm.o: term.c
X	cc -O -c term.c
X
Xterm.c: pdp11/term.c pdp11/conf.h
X	cp pdp11/term.c term.c
X
X
Xcursor.c: cursor/cursor.c.${CURSOR}
X	cp cursor/cursor.c.${CURSOR} cursor.c
X
Xcursor.o: cursor.c
X	cc -0 -c cursor.c
X
Xtermcap.o: bas.h termcap.c
X	cc -O -c termcap.c
X
X.c.o:   $*.c
X	cc -O -f -c $*.c
X
Xbas.h: pdp11/conf.h
X
Xbas1.o: bas1.c bas.h
Xbas2.o: bas2.c bas.h
Xbas3.o: bas3.c bas.h
Xbas4.o: bas4.c bas.h
Xbas5.o: bas5.c bas.h
Xbas6.o: bas6.c bas.h
Xbas7.o: bas7.c bas.h
Xbas7.c: cursor.c
Xbas8.o: bas8.c bas.h
Xbas9.o: bas9.c bas.h
End of pdp11/Makefile.fp
chmod u=rw-,g=r,o=r pdp11/Makefile.fp
echo x - pdp11/Makefile.nofp 1>&2
sed 's/^X//' > pdp11/Makefile.nofp << 'End of pdp11/Makefile.nofp'
XSEPID=-i
X# which cursor key file you want - ucl or ukc
XCURSOR = ucl
X
Xbasic:  bas1.o bas2.o bas3.o bas4.o bas5.o bas6.o bas7.o bas8.o \
X       bas9.o cursor.o termcap.o assist.o lfunc.o nfp.o term.o
X	cc -s -O ${SEPID} assist.o bas1.o bas2.o bas3.o bas4.o bas5.o bas6.o \
X       bas7.o bas8.o bas9.o cursor.o termcap.o lfunc.o nfp.o term.o -o basic
X
Xclean:
X	rm -f *.o *.s term.c cursor.c
X
Xassist.o: pdp11/assist.s
X	cp pdp11/assist.s assist.s
X	cc -O -c assist.s
X	rm -f assist.s
X
Xlfunc.o: pdp11/lfunc.s
X	cp pdp11/lfunc.s lfunc.s
X	cc -O -c lfunc.s
X	rm -f lfunc.s
X
Xnfp.o: pdp11/nfp.s
X	cp pdp11/nfp.s nfp.s
X	cc -O -c nfp.s
X	rm -f nfp.s
X
Xcursor.c: cursor/cursor.c.${CURSOR}
X	cp cursor/cursor.c.${CURSOR} cursor.c
X
Xcursor.o: cursor.c
X	cc -O -c cursor.c
X
Xtermcap.o: bas.h termcap.c
X	cc -O -c termcap.c
X
Xterm.o: term.c
X	cc -O -c term.c
X
Xterm.c: pdp11/term.c pdp11/conf.h
X	cp pdp11/term.c term.c
X
X.c.o:   bas.h $*.c
X	cc -O -c -f -DSOFTFP $*.c
X
Xbas.h:  pdp11/conf.h
X
Xbas1.o: bas1.c bas.h
Xbas2.o: bas2.c bas.h
Xbas3.o: bas3.c bas.h
Xbas4.o: bas4.c bas.h
Xbas5.o: bas5.c bas.h
Xbas6.o: bas6.c bas.h
Xbas7.o: bas7.c bas.h
Xbas7.c: cursor.c
Xbas8.o: bas8.c bas.h
Xbas9.o: bas9.c bas.h
End of pdp11/Makefile.nofp
chmod u=rw-,g=r,o=r pdp11/Makefile.nofp

