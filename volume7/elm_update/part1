Subject:  v07i018:  ELM Update Kit, Part01/03
Newsgroups: mod.sources
Approved: mirror!rs

Submitted by: Dave Taylor <taylor@hplabs.HP.COM>
Mod.sources: Volume 7, Issue 18
Archive-name: elm_update/Part01

[  The shell scripts in this posting should be run on a clean copy of
   the ELM sources.  Then run the "Configure.sh" script now provided,
   to build the Makefiles, etc.  I suppose this is a good time to say
   that Dave said to ignore errors in unpacking Part 12 of the Volume
   6 ELM distribution.  -- r$  ]

#!/bin/sh
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".

# Exit status; set to 1 on "wc" errors or if would overwrite.
STATUS=0
# Contents:  Edit1
 
echo x - Edit1
if test -f Edit1 ; then
    echo Edit1 exists, putting output in $$Edit1
    OUT=$$Edit1
    STATUS=1
else
    OUT=Edit1
fi
sed 's/^XX//' > $OUT <<'@//E*O*F Edit1//'
XX: Use /bin/sh

XX# This is the automatically generated output of the AUTODIFF program after
XX# being run on the two directories;
XX#
XX#	Old Directory: Elm-Posted
XX#	New Directory: Elm

XX# Any problems with execution of this script should be reported to the 
XX#     author of the program, Dave Taylor, at "hplabs!taylor".  Thanks

XX# first off, let's make sure we're running in SH

XXexport PATH || (sh $0; exit $$)

XX# next, let's ensure the user has "ed"...

XXif [ ! -f /bin/ed ]
XXthen
XX  echo I can\'t find /bin/ed\!
XX  exit 1
XXfi

XX# finally, let's get this show on the road!!

XX#-------------------------------------
XX# File 'doc/newmail.1' diffs...

XXcat << 'EOF' > doc/newmail.D
XX36a
XXIf the message is a \fIpriority\fR message (that is, it has a field
XXin the header "Priority:"), then the line will be "PRIORITY mail"
XXinstead of "New mail".
XX.P
XX.
XXw
XXEOF

XXchars=`cat doc/newmail.1 | wc -c`

XXif [ $chars -ne 1214 ]
XXthen
XX  echo Your file doc/newmail.1 has been changed\!
XX  echo diffs saved as \"doc/newmail.D\"
XXelse
XX  echo applying diffs to file doc/newmail.1...
XX  /bin/cat doc/newmail.D | /bin/ed - doc/newmail.1
XXfi

XX#-------------------------------------
XX# File 'doc/readmsg.1' diffs...

XXcat << 'EOF' > doc/readmsg.D
XX137a
XX.SH BUGS
XXThe '*' metacharacter doesn't always work as expected!
XX.br
XXPerhaps the pattern matching should be case insensitive?
XX.
XX50c
XXthe last message in the mailfile.  Similarly, '*' is understood to
XXrepresent every message in the file (that is, 1-$)
XX.
XXw
XXEOF

XXchars=`cat doc/readmsg.1 | wc -c`

XXif [ $chars -ne 3454 ]
XXthen
XX  echo Your file doc/readmsg.1 has been changed\!
XX  echo diffs saved as \"doc/readmsg.D\"
XXelse
XX  echo applying diffs to file doc/readmsg.1...
XX  /bin/cat doc/readmsg.D | /bin/ed - doc/readmsg.1
XXfi

XX#-------------------------------------
XX# File 'doc/Config.guide' diffs...

XXcat << 'EOF' > doc/Config.gui.D
XX349c
XX-------------------------------------------------------------------------------------
XX.
XX140c
XX                                           (can't be within this boundary)    */
XX.
XX120c
XX-------------------------------------------------------------------------------------
XX.
XX84c
XXsystems, including HP-UX (and the \fISPECTRUM\fR series!) or simulations thereof.
XX.
XX68a
XXIt's \fIhighly\fR recommended that installation be done by using the
XX\fBConfigure.sh\fR script supplied with the system.  Please see the
XXfile \fIInstructions\fR for further information.
XX.sp 2
XX.P
XX.
XXw
XXEOF

XXchars=`cat doc/Config.guide | wc -c`

XXif [ $chars -ne 20499 ]
XXthen
XX  echo Your file doc/Config.guide has been changed\!
XX  echo diffs saved as \"doc/Config.gui.D\"
XXelse
XX  echo applying diffs to file doc/Config.guide...
XX  /bin/cat doc/Config.gui.D | /bin/ed - doc/Config.guide
XXfi

XX#-------------------------------------
XX# File 'doc/wnewmail.1' diffs...

XXcat << 'EOF' > doc/wnewmail.D
XX37a
XXIf the message is a \fIpriority\fR message (that is, the
XXheader contains a line "Priority:"), then the line output
XXwill be "PRIORITY mail from ..." rather than just "Mail from".
XX.P
XX.
XXw
XXEOF

XXchars=`cat doc/wnewmail.1 | wc -c`

XXif [ $chars -ne 1318 ]
XXthen
XX  echo Your file doc/wnewmail.1 has been changed\!
XX  echo diffs saved as \"doc/wnewmail.D\"
XXelse
XX  echo applying diffs to file doc/wnewmail.1...
XX  /bin/cat doc/wnewmail.D | /bin/ed - doc/wnewmail.1
XXfi

XX#-------------------------------------
XX# File 'doc/Ref.guide' diffs...

XXcat << 'EOF' > doc/Ref.gui.D
XX290,291c
XXThere is also a built in pager, considerably faster than calling
XXa remote one, called 'builtin'.  This is the default if none is
XXspecified.
XX.
XXw
XXEOF

XXchars=`cat doc/Ref.guide | wc -c`

XXif [ $chars -ne 39623 ]
XXthen
XX  echo Your file doc/Ref.guide has been changed\!
XX  echo diffs saved as \"doc/Ref.gui.D\"
XXelse
XX  echo applying diffs to file doc/Ref.guide...
XX  /bin/cat doc/Ref.gui.D | /bin/ed - doc/Ref.guide
XXfi

XX#-------------------------------------
XX# File 'doc/Users.guide' diffs...

XXcat << 'EOF' > doc/Users.gui.D
XX857c
XXnamely Guy Hillyer, Bruce Townsend and special guest appearances
XX(almost \fIall\fR the BSD fixes for Elm 1.1) by Eric Negaard.
XX.
XX841c
XXJohn Dilley (who got the SPECTRUM version checked out, too!) and Carl Dierschow.
XX.
XX541c
XX.mk a
XX.
XX517c
XX.mk a
XX.
XX425c
XX.mk a
XX.
XX393c
XX.mk a
XX.
XX166,167c
XX.mk a
XX.mk a
XX.
XXw
XXEOF

XXchars=`cat doc/Users.guide | wc -c`

XXif [ $chars -ne 25463 ]
XXthen
XX  echo Your file doc/Users.guide has been changed\!
XX  echo diffs saved as \"doc/Users.gui.D\"
XXelse
XX  echo applying diffs to file doc/Users.guide...
XX  /bin/cat doc/Users.gui.D | /bin/ed - doc/Users.guide
XXfi

XX#-------------------------------------
XX# File 'doc/elm.1' diffs...

XXcat << 'EOF' > doc/elm.1.D
XX65a
XX.TP
XX.
XX63a
XX.TP
XX.
XX21c
XX.B \-s 
XX.
XX8c
XX.B \-achkKmrwz
XX.
XXw
XXEOF

XXchars=`cat doc/elm.1 | wc -c`

XXif [ $chars -ne 2788 ]
XXthen
XX  echo Your file doc/elm.1 has been changed\!
XX  echo diffs saved as \"doc/elm.1.D\"
XXelse
XX  echo applying diffs to file doc/elm.1...
XX  /bin/cat doc/elm.1.D | /bin/ed - doc/elm.1
XXfi

XX#---------------------------------
XX# File Elm/doc/messages.1 is new!

XXecho File Elm/doc/messages.1 is new - extracting...
XXif [ -f doc/messages.1 ]
XXthen
XX  echo File \'doc/messages.1\' is new, but you already have something called that\!
XX  echo I\'m going to move your file to \'doc/messages.1.old\'...
XX  /bin/mv -f doc/messages.1 doc/messages.1.old
XXelse
XX  echo Extracting new file \'doc/messages.1\'
XXfi

XXcat > doc/messages.1 << 'END_OF_FILE'
XX.TH MESSAGES 1L
XX.ad b
XX.SH NAME
XXmessages - quick count of messages in mailbox or folder
XX.SH SYNOPSIS
XX.B messages
XX.br
XX.B messages
XXfolder-name
XX.SH HP-UX COMPATIBILITY
XX.TP 10
XXLevel:
XXHP-UX/STANDARD
XX.TP
XXOrigin:
XXHewlett-Packard
XX.SH DESCRIPTION
XX.I Messages
XXcounts the occurances of "^From\ " in either the current incoming 
XXmailbox or the specified folder.
XX.P
XXThis is, in fact, a simple little shell script!!
XX.SH AUTHOR
XXDave Taylor, Hewlett-Packard Laboratories
XX.SH SEE\ ALSO
XXfrom(1L), elm(1L)
XX.SH BUGS
XXDon't be foolish...
XXEND_OF_FILE

XXchars=`cat doc/messages.1 | wc -c`

XXif [ $chars -ne 515 ]
XXthen
XX  echo File damaged in transit...should be 515 bytes, is $chars instead
XX  echo  I suggest you check it closely...
XXfi

XX#---------------------------------
XX# File Elm/doc/trim-headers.1 is new!

XXecho File Elm/doc/trim-headers.1 is new - extracting...
XXif [ -f doc/trim-headers.1 ]
XXthen
XX  echo File \'doc/trim-headers.1\' is new, but you already have something called that\!
XX  echo I\'m going to move your file to \'doc/trim-headers.1.old\'...
XX  /bin/mv -f doc/trim-headers.1 doc/trim-headers.1.old
XXelse
XX  echo Extracting new file \'doc/trim-headers.1\'
XXfi

XXcat > doc/trim-headers.1 << 'END_OF_FILE'
XX.TH TRIM-HEADERS 1L
XX.ad b
XX.SH NAME
XXtrim-headers - help keep mailbox files clean of trash headers
XX.SH SYNOPSIS
XXcat \fIfilename\fR |
XX.B trim-headers
XX> \fIfilename2\fR
XX.br
XX.B trim-headers
XXfilename-list
XX.SH HP-UX COMPATIBILITY
XX.TP 10
XXLevel:
XXHP-UX/STANDARD
XX.TP
XXOrigin:
XXHewlett-Packard Laboratories
XX.SH DESCRIPTION
XX.I Trim-headers
XXis a simple awk script that removes all headers from the specified
XXfolder, either standard input or one of a list of filenames, according
XXto how it's invoked.  The program knows about the following headers;
XX.sp
XX.nf
XX	From 
XX	From:
XX	Subject:
XX	To:
XX	Cc:
XX	Date:

XX.fi
XXAll other headers are considered extraneous and are removed.
XX.SH AUTHOR
XXDave Taylor, Hewlett-Packard Laboratories
XX.SH SEE\ ALSO
XXawk(1), printmail(1L), readmsg(1L)
XX.SH BUGS
XXThe current incancation of the \fIawk\fR script doesn't understand
XXthe idea of multiple line header fields, so a message that has, say,
XXa three line To: list will only have the first line saved...
XXEND_OF_FILE

XXchars=`cat doc/trim-headers.1 | wc -c`

XXif [ $chars -ne 955 ]
XXthen
XX  echo File damaged in transit...should be 955 bytes, is $chars instead
XX  echo  I suggest you check it closely...
XXfi

XX#-------------------------------------
XX# File 'src/alias.c' diffs...

XXcat << 'EOF' > src/alias.c.D
XX288a
XX		      if (mini_menu) show_alias_menu();
XX.
XX244c
XX			  PutLine1(LINES-1,0,"Aliased address: %-60.60s", 
XX.
XX240c
XX	                  PutLine1(LINES-1,0,"Group alias:%-60.60s", address);
XX.
XX225a
XX	    case LINE_FEED:
XX.
XXw
XXEOF

XXchars=`cat src/alias.c | wc -c`

XXif [ $chars -ne 7725 ]
XXthen
XX  echo Your file src/alias.c has been changed\!
XX  echo diffs saved as \"src/alias.c.D\"
XXelse
XX  echo applying diffs to file src/alias.c...
XX  /bin/cat src/alias.c.D | /bin/ed - src/alias.c
XXfi

XX#-------------------------------------
XX# File 'src/curses.c' diffs...

XXcat << 'EOF' > src/curses.c.D
XX422c
XX	printf(_clearbold);
XX.
XX409c
XX	printf("%s", _setbold);		/* don't ask, okay? */
XX.
XX174c
XX	if (strlen(termcap_label) < 2)
XX	  return(NULL);

XX	if (termcap_label[0] == 's' && termcap_label[1] == 'o')
XX	  sprintf(escape_sequence, _setinverse);
XX	else if (termcap_label[0] == 's' && termcap_label[1] == 'e')
XX	  sprintf(escape_sequence, _clearinverse);
XX	else if ((myptr = tgetstr(termcap_label, &ptr)) == NULL)
XX	  return( (char *) NULL );
XX	else
XX	  sprintf(escape_sequence, myptr);

XX.
XX170c
XX	char *myptr, *tgetstr();     		/* Get termcap capability */
XX.
XX152,155d
XX114a
XX#ifdef BSD
XX	initscr();	/* initalize curses too! */
XX#endif

XX.
XX44a
XX#ifdef SHORTNAMES
XX# define CleartoEOS	ClrtoEOS
XX# define _clearinverse	_clrinv
XX# define _cleartoeoln	_clrtoeoln
XX# define _cleartoeos	_clr2eos
XX# define _transmit_off	xmit_off
XX# define _transmit_on	xmit_on
XX#endif

XX.
XX28c
XX#  ifndef BSD4.1
XX#    include <sgtty.h>
XX#  endif
XX.
XXw
XXEOF

XXchars=`cat src/curses.c | wc -c`

XXif [ $chars -ne 15951 ]
XXthen
XX  echo Your file src/curses.c has been changed\!
XX  echo diffs saved as \"src/curses.c.D\"
XXelse
XX  echo applying diffs to file src/curses.c...
XX  /bin/cat src/curses.c.D | /bin/ed - src/curses.c
XXfi

XX#-------------------------------------
XX# File 'src/date.c' diffs...

XXcat << 'EOF' > src/date.c.D
XX372a

XX#ifdef SITE_HIDING

XXchar *get_ctime_date()
XX{
XX	/** returns a ctime() format date, but a few minutes in the 
XX	    past...(more cunningness to implement hidden sites) **/

XX	static char buffer[SLEN];	/* static character buffer       */
XX	struct tm *the_time,		/* Time structure, see CTIME(3C) */
XX		  *localtime();
XX	long	   junk;		/* time in seconds....		 */
XX#ifdef BSD
XX	struct  timeval  time_val;		
XX	struct  timezone time_zone;
XX#endif

XX#ifdef BSD
XX	gettimeofday(&time_val, &time_zone);
XX	junk = time_val.tv_sec;
XX#else
XX	junk = (long) time((long *) 0);	/* this must be here for it to work! */
XX#endif
XX	the_time = localtime(&junk);

XX	sprintf(buffer, "%s %s %d %02d:%02d:%02d %d",
XX	  arpa_dayname[the_time->tm_wday],
XX	  arpa_monname[the_time->tm_mon],
XX	  the_time->tm_mday % 32,
XX	  min(the_time->tm_hour % 24, (rand() % 24)),
XX	  min(abs(the_time->tm_min  % 61 - (rand() % 60)), (rand() % 60)),
XX	  min(abs(the_time->tm_sec  % 61 - (rand() % 60)), (rand() % 60)),
XX	  the_time->tm_year % 100 + 1900);
XX	
XX	return( (char *) buffer);
XX}

XX#endif
XX.
XX339c
XX	return( minute1 - minute2 );		/* ignore seconds... */
XX.
XX335a
XX	/* did we get the time?  If not, try again */

XX	if (minute1 < 0)
XX	  sscanf(rec1->time, "%2d%2d", &hour1, &minute1);

XX	if (minute2 < 0)
XX	  sscanf(rec2->time, "%2d%2d", &hour2, &minute2);

XX	/** deal with am/pm, if present... **/

XX	if (strlen(rec1->time) > 3)
XX	  if (rec1->time[strlen(rec1->time)-2] == 'p')
XX	    hour1 += 12;

XX	if (strlen(rec2->time) > 3)
XX	  if (rec2->time[strlen(rec2->time)-2] == 'p')
XX	    hour2 += 12;

XX.
XX332a
XX	minute1 = minute2 = -1;

XX.
XX282c
XX	  sprintf(timestring, "12:%2.2d (midnight)", minute);
XX.
XX192c
XX	junk = (long) time((long *) 0);	/* this must be here for it to work! */
XX.
XX146a
XX# endif
XX.
XX145a
XX# ifdef BSD4.1
XX	  timezone(time_zone.timezone, the_time->tm_isdst));
XX# else
XX.
XX134a

XX.
XX133c
XX	junk = (long) time((long *) 0);	/* this must be here for it to work! */
XX.
XX131a
XX# endif

XX.
XX129d
XX127d
XX124a
XX# ifdef BSD4.1
XX	struct timeb	loc_time;

XX	junk = (long) time(long *) 0);
XX	ftime(&loc_time);
XX# else
XX.
XX123a

XX.
XX68c
XX	junk = (long) time((long *) 0);	/* this must be here for it to work! */
XX.
XX18a
XX#undef tolower
XX.
XX10c
XX#  ifndef BSD4.1
XX#    include <sys/time.h>
XX#  else
XX#    include <time.h>
XX#    include <sys/types.h>
XX#    include <sys/timeb.h>
XX#  endif
XX.
XX8a

XX.
XXw
XXEOF

XXchars=`cat src/date.c | wc -c`

XXif [ $chars -ne 9538 ]
XXthen
XX  echo Your file src/date.c has been changed\!
XX  echo diffs saved as \"src/date.c.D\"
XXelse
XX  echo applying diffs to file src/date.c...
XX  /bin/cat src/date.c.D | /bin/ed - src/date.c
XXfi

XX#-------------------------------------
XX# File 'src/delete.c' diffs...

XXcat << 'EOF' > src/delete.c.D
XX80c
XX	  if (msg == current && !arrow_cursor) {
XX	    StartBold();
XX	    PutLine2((msg % headers_per_page) + 4, 3, "%c%c",
XX		   ison(header_table[msg].status, DELETED)? 'D' : ' ',
XX		   ison(header_table[msg].status, TAGGED )? '+' : ' ');
XX	    EndBold();
XX	  }
XX	  else
XX	    PutLine2((msg % headers_per_page) + 4, 3, "%c%c",
XX.
XX67c
XX	  if (msg == current && !arrow_cursor) {
XX	    StartBold();
XX	    Writechar( ison(header_table[msg].status, TAGGED)? '+' : ' ');
XX	    EndBold();
XX	  }
XX	  else
XX	    Writechar( ison(header_table[msg].status, TAGGED)? '+' : ' ');
XX.
XX44c
XX	  if (msg == current && !arrow_cursor) {
XX	    StartBold();
XX	    Writechar( ison(header_table[msg].status, DELETED)? 'D' : ' ');
XX	    EndBold();
XX	  }
XX	  else
XX	    Writechar( ison(header_table[msg].status, DELETED)? 'D' : ' ');
XX.
XXw
XXEOF

XXchars=`cat src/delete.c | wc -c`

XXif [ $chars -ne 1863 ]
XXthen
XX  echo Your file src/delete.c has been changed\!
XX  echo diffs saved as \"src/delete.c.D\"
XXelse
XX  echo applying diffs to file src/delete.c...
XX  /bin/cat src/delete.c.D | /bin/ed - src/delete.c
XXfi

XX#-------------------------------------
XX# File 'src/aliasdb.c' diffs...

XXcat << 'EOF' > src/aliasdb.D
XX169c
XX	} while (absolute(last) - absolute(first) > FIND_DELTA);
XX.
XX135a
XX	   strcat(expanded, comment);		/* add comment */
XX.
XX132a
XX	    }
XX.
XX131c
XX	    else {			     /* We just can't get there! */
XX	      strcpy(expanded, old_name);	/* restore! */
XX.
XX124a
XX	       strcat(expanded, comment);	/* patch in comment */
XX.
XX104a
XX	dprint3(5,"\nBroke address into '%s' @ '%s' '%s'\n\n",
XX		name, sitename, comment);

XX.
XX94c
XX	while (cryptic[i] != '\0' && cryptic[i] != '(' && 
XX               ! whitespace(cryptic[i]))
XX.
XX81c
XX	       cryptic[i] != '\0' && cryptic[i] != '(')
XX.
XX79a
XX	/** first, rip out the comment, if any **/

XX	if ((i = chloc(cryptic, '(')) > -1) {
XX	  comment[j++] = ' ';			/* leading space */
XX	  for ( ;cryptic[i] != ')'; i++)
XX  	    comment[j++] = cryptic[i];
XX	  comment[j++] = ')';
XX	  comment[j] = '\0';
XX	  /* and remove this from cryptic string too... */
XX	  if (cryptic[(j = chloc(cryptic,'('))-1] == ' ')
XX	    cryptic[j-1] = '\0';
XX	  else
XX	    cryptic[j] = '\0';
XX	}
XX	else
XX	  comment[0] = '\0';

XX	i = j = 0;	/* reset */

XX.
XX72c
XX               temp[VERY_LONG_STRING], old_name[VERY_LONG_STRING],
XX	       comment[LONG_STRING];
XX.
XX62c
XX	    0 = found, -1 return means unknown site code 
XX	
XX	    Modified to strip out parenthetical comments...
XX	**/
XX.
XX40,41c
XX	      if (mail_only)
XX	        printf("Warning: couldn't expand %s...\n\r", name);
XX	      else {
XX	        error1("Warning: couldn't expand %s...", name);
XX	        sleep(1);
XX	      }
XX.
XX13a
XX#define  absolute(x)		((x) > 0 ? x : -(x))

XX.
XXw
XXEOF

XXchars=`cat src/aliasdb.c | wc -c`

XXif [ $chars -ne 5484 ]
XXthen
XX  echo Your file src/aliasdb.c has been changed\!
XX  echo diffs saved as \"src/aliasdb.D\"
XXelse
XX  echo applying diffs to file src/aliasdb.c...
XX  /bin/cat src/aliasdb.D | /bin/ed - src/aliasdb.c
XXfi

XX#-------------------------------------
XX# File 'src/file.c' diffs...

XXcat << 'EOF' > src/file.c.D
XX158c
XX	ptr = filename;
XX	while (*ptr == ' ') ptr++;	/* leading spaces GONE! */
XX	strcpy(filename, ptr);

XX	/** New stuff - make sure no illegal char as last **/
XX.
XX155c
XX	char buffer[SLEN], varname[SLEN], env_value[SLEN], *ptr;
XX.
XX79a
XX#endif
XX.
XX78a
XX#ifdef BSD4.1
XX	if ((errno = ((can_open(filename, "a") & ~0x0200) >>8))) {
XX#else
XX.
XXw
XXEOF

XXchars=`cat src/file.c | wc -c`

XXif [ $chars -ne 5704 ]
XXthen
XX  echo Your file src/file.c has been changed\!
XX  echo diffs saved as \"src/file.c.D\"
XXelse
XX  echo applying diffs to file src/file.c...
XX  /bin/cat src/file.c.D | /bin/ed - src/file.c
XXfi

XX#-------------------------------------
XX# File 'src/read_rc.c' diffs...

XXcat << 'EOF' > src/read_rc.D
XX367c
XX	      pmalloc(strlen(default_list[weedcount]) + 1)) == NULL) {
XX.
XX342c
XX			       pmalloc(sizeof *alternative_addresses);
XX.
XX334c
XX			       pmalloc(sizeof *alternative_addresses);
XX.
XX305c
XX	    if ((weedlist[weedcount] = pmalloc(strlen(header) + 1)) == NULL) {
XX.
XX63c
XXchar *shift_lower(), *strtok(), *getenv(), *pmalloc();
XX.
XXw
XXEOF

XXchars=`cat src/read_rc.c | wc -c`

XXif [ $chars -ne 12722 ]
XXthen
XX  echo Your file src/read_rc.c has been changed\!
XX  echo diffs saved as \"src/read_rc.D\"
XXelse
XX  echo applying diffs to file src/read_rc.c...
XX  /bin/cat src/read_rc.D | /bin/ed - src/read_rc.c
XXfi

XX#-------------------------------------
XX# File 'src/hdrconfg.c' diffs...

XXcat << 'EOF' > src/hdrconfg.D
XX95c
XX	    case 'I' : if (strlen(in_reply_to) > 0) {
XX.
XX84c
XX	    case 'R' : if (optionally_enter(reply_to, 7, 10, FALSE) == -1)
XX.
XX67c
XX	    case RETURN:
XX	    case LINE_FEED:
XX.
XXw
XXEOF

XXchars=`cat src/hdrconfg.c | wc -c`

XXif [ $chars -ne 4054 ]
XXthen
XX  echo Your file src/hdrconfg.c has been changed\!
XX  echo diffs saved as \"src/hdrconfg.D\"
XXelse
XX  echo applying diffs to file src/hdrconfg.c...
XX  /bin/cat src/hdrconfg.D | /bin/ed - src/hdrconfg.c
XXfi

XX#-------------------------------------
XX# File 'src/help.c' diffs...

XXcat << 'EOF' > src/help.c.D
XX9a

XX#ifdef BSD
XX# undef tolower
XX#endif

XX.
XXw
XXEOF

XXchars=`cat src/help.c | wc -c`

XXif [ $chars -ne 5576 ]
XXthen
XX  echo Your file src/help.c has been changed\!
XX  echo diffs saved as \"src/help.c.D\"
XXelse
XX  echo applying diffs to file src/help.c...
XX  /bin/cat src/help.c.D | /bin/ed - src/help.c
XXfi

XX#-------------------------------------
XX# File 'src/initialize.c' diffs...

XXcat << 'EOF' > src/initialize.D
XX199a

XX	/** allocate the first KLICK headers... **/

XX	if ((header_table = (struct header_rec *) malloc(KLICK * sizeof (struct
XX	     header_rec))) == NULL) {
XX	   fprintf(stderr,"\n\r\n\rCouldn't allocate initial headers!\n\r\n");
XX	   leave();
XX	}
XX	max_headers = KLICK;		/* we have those preallocated */

XX	/** now cruise along... **/
XX.
XX181a
XX	dprint0(1,"past the return_ stuff\n");

XX.
XX174a
XX	    else if (strlen(cp) != 2)
XX	      cursor_control = FALSE;
XX.
XX173c
XX	    if ((cp = return_value_of("kd")) == NULL)
XX.
XX169,171c
XX	  cursor_control = FALSE;

XX	  if ((cp = return_value_of("ku")) != NULL)
XX	   if (strlen(cp) != 2) {
XX	    dprint0(1,"ku != NULL\n");
XX.
XX148a
XX	ScreenSize(&LINES, &COLUMNS);

XX.
XX113,114c
XX	        full_username[j++] = pass->pw_gecos[i];
XX	  full_username[j] = '\0'; 
XX.
XX110c
XX	        j = strlen(full_username);
XX.
XX108c
XX	        full_username[j] = '\0';
XX.
XX105c
XX	  /* fix for this section from Don Joslyn of Nova University */
XX	  for (i=0,j=0; pass->pw_gecos[i] != '\0' && pass->pw_gecos[i] != ',';
XX.
XX74a
XX#endif
XX.
XX72a
XX#ifndef BSD	/* if BSD we've already done this! */
XX.
XX46c
XX	register int i, j;
XX.
XX34c
XXchar *error_name(), *error_description(), *malloc();
XX.
XX31d
XX27a
XX#undef toupper
XX.
XXw
XXEOF

XXchars=`cat src/initialize.c | wc -c`

XXif [ $chars -ne 7108 ]
XXthen
XX  echo Your file src/initialize.c has been changed\!
XX  echo diffs saved as \"src/initialize.D\"
XXelse
XX  echo applying diffs to file src/initialize.c...
XX  /bin/cat src/initialize.D | /bin/ed - src/initialize.c
XXfi

XX#-------------------------------------
XX# File 'src/showmsg.c' diffs...

XXcat << 'EOF' > src/showmsg.D
XX275,276c
XX	  if (errno != 0)
XX	    dprint1(1,"\terror %s hit!\n", error_name(errno));
XX	}
XX}

XXint
XXsecure_display(lines, msgnumber)
XXint lines, msgnumber;
XX{
XX	/** This is the cheap way to implement secure pipes - spawn a
XX	    child process running under the old userid, then open the
XX	    pager and feed the message to it.  When the subprocess ends
XX	    (the routine returns) simply return.  Simple and effective.
XX	    (too bad it's this much of a hassle to implement secure
XX	    pipes, though - I can imagine it being a constant problem!)
XX	**/

XX	int stat = 0, pid, w;
XX#ifdef BSD
XX	union wait status;
XX#else
XX	int status;
XX#endif
XX	register int (*istat)(), (*qstat)();
XX	
XX#ifdef NO_VM		/* machine without virtual memory! */
XX	if ((pid = fork()) == 0) {
XX#else
XX	if ((pid = vfork()) == 0) {
XX#endif

XX	  setgid(groupid);	/* and group id		    */
XX	  setuid(userid);	/* back to the normal user! */

XX	  _exit(display(lines, msgnumber));
XX	}

XX	istat = signal(SIGINT, SIG_IGN);
XX	qstat = signal(SIGQUIT, SIG_IGN);

XX	while ((w = wait(&status)) != pid && w != -1)
XX		;

XX	signal(SIGINT, istat);
XX	signal(SIGQUIT, qstat);

XX#ifdef BSD
XX	return(status.w_retcode);
XX#else
XX	return(status);
XX#endif
XX.
XX272,273c
XX	if (builtin) {
XX	  strcat(buffer, "\n\r");
XX	  pipe_abort = display_line(buffer);
XX	}
XX	else {
XX	  errno = 0;
XX	  fprintf(output_pipe, "%s\n", buffer);
XX.
XX270c
XX	/** Hands the given line to the output pipe.  'builtin' is true if
XX	    we're using the builtin pager.  **/ 
XX.
XX268a
XXint  builtin;
XX.
XX267c
XXshow_line(buffer, builtin)
XX.
XX259c
XX	  if (! builtin)
XX	    PutLine0(LINES+1,0,"\rPress <return> to return to Elm: ");
XX	  else
XX	    Write_to_screen("\n\r\n\rPress <return> to return to Elm: ");
XX.
XX257c
XX	if (! builtin) pclose(output_pipe);

XX.
XX251c
XX	        show_line(buffer, builtin);
XX.
XX248c
XX	          show_line(buffer, builtin);
XX.
XX243c
XX	        show_line(buffer, builtin); 
XX.
XX238c
XX	          show_line(buffer, builtin);
XX.
XX235c
XX	          show_line(buffer, builtin);
XX.
XX221c
XX		show_line(buffer, builtin);
XX.
XX194c
XX		if (!builtin)
XX	          PutLine0(LINES+1,0,"\rPress <return> to return to Elm: ");
XX	        else
XX		  Write_to_screen("\n\r\n\rPress <return> to return to Elm: ");
XX.
XX192c
XX	      if (!builtin) 
XX	        pclose(output_pipe);
XX.
XX188c
XX	        if (!builtin) pclose(output_pipe);	/* close pipe NOW! */
XX		show_mailfile_stats();
XX.
XX173,176d
XX154a
XX	    if (builtin)
XX	      display_line(buffer);
XX	    else
XX	      fprintf(output_pipe, "%s", buffer);
XX	  }
XX.
XX152,153c
XX	      strlen(header_table[current-1].to) > 0) {
XX	    sprintf(buffer, "\n\r(message addressed to %s)\n\r", 
XX.
XX149a
XX	  if (builtin)
XX	    display_line(buffer);
XX	  else
XX	    fprintf(output_pipe, "%s", buffer);

XX.
XX140,148c
XX		   mail_sent? "to" : "from", from_buffer,
XX		   (strlen(from_buffer) > 24? "\n\r": 
XX		     (strlen(from_buffer) > 16 ? "" : "\t")),
XX		   notesfile? "Posted" : "Mailed",
XX     		   full_month(header_table[msgnum-1].month), 
XX		   header_table[msgnum-1].day, 
XX	           atoi(header_table[msgnum-1].year) + 1900,
XX	           header_table[msgnum-1].time,
XX		   filter? "": "\n\r\n\r");
XX.
XX137,138c
XX	  tail_of(header_table[msgnum-1].from, from_buffer, FALSE);

XX	  sprintf(buffer, "\r%s #%d %s %s%s\t %s %s %s, %d at %s%s\n\r",
XX.
XX131d
XX124,129c
XX	builtin = (strcmp(pager, "builtin") == 0 || 
XX		   strcmp(pager,"internal") == 0);

XX	if (builtin) 
XX	  start_builtin(lines);
XX	else {
XX	  if ((output_pipe = popen(pager,"w")) == NULL) {
XX	    error2("Can't create pipe to %s [%s]", pager, 
XX		    error_name(errno));
XX	    dprint2(1,"\n*** Can't create pipe to %s - error %s ***\n\n",
XX	   	    pager, error_name(errno));
XX	    return(0);
XX	  }
XX	  dprint1(4,"Opened a write-only pipe to routine %s \n", pager);
XX.
XX121a
XX	ClearScreen();

XX	if (cursor_control) transmit_functions(OFF);

XX.
XX117c
XX	int mail_sent,				/* misc use   */
XX	    builtin = FALSE;			/* our pager? */
XX.
XX111c
XX	char from_buffer[LONG_STRING], buffer[VERY_LONG_STRING], *full_month();
XX.
XX99c
XXFILE   *output_pipe, *popen();
XX.
XX88c
XX	if (strcmp(pager,"builtin") == 0 || strcmp(pager,"internal") == 0)
XX	  display(lines, msgnumber);
XX	else
XX	  secure_display(lines, msgnumber);
XX.
XX84a
XX	if (feof(mailfile))
XX	  dprint0(1,"\n*** seek put us at END OF FILE!!! ***\n");

XX.
XX17c
XX# include <sys/wait.h>
XX# undef tolower
XX.
XX14a
XX#include <signal.h>
XX.
XX11d
XX8a
XX   Modified 7/86 to have secure pipes.. *sigh*
XX.
XXw
XXEOF

XXchars=`cat src/showmsg.c | wc -c`

XXif [ $chars -ne 7704 ]
XXthen
XX  echo Your file src/showmsg.c has been changed\!
XX  echo diffs saved as \"src/showmsg.D\"
XXelse
XX  echo applying diffs to file src/showmsg.c...
XX  /bin/cat src/showmsg.D | /bin/ed - src/showmsg.c
XXfi

XX#-------------------------------------
XX# File 'src/newmbox.c' diffs...

XXcat << 'EOF' > src/newmbox.D
XX352,353c
XX	header_table[count > 0? count-1:count].lines = line + 1;
XX	
XX.
XX266a
XX	
XX	    /** try to allocate new headers, if needed... **/

XX	    if (count >= max_headers) {
XX	      max_headers += KLICK;
XX	      dprint2(1,
XX		  "\n\nAbout to allocate headers, count = %d, max_headers=%d\n",
XX		  count, max_headers);
XX	      if ((temp_struct = (struct header_rec *) realloc(header_table,
XX			max_headers * sizeof(struct header_rec))) == NULL) {
XX	        error1(
XX      "\n\r\n\rCouldn't allocate enough memory!  Failed on message #%d\n\r\n\r",
XX			count);
XX	        leave();
XX	       }
XX	       header_table = temp_struct;
XX	       dprint1(1,"\tallocated %d more headers!\n\n", KLICK);
XX	     }
XX	     else 
XX	       dprint1(1,"\ndidn't need to allocate headers: count=%d\n\n",
XX			count);
XX	      
XX.
XX241c
XX	     line = 0;
XX.
XX239c
XX	     line = header_table[message_count - 1].lines;
XX.
XX185a
XX	    if (access(temp_filename, ACCESS_EXISTS) != -1) {
XX	      /* Hey!  What the hell is this?  The temp file already exists? */
XX	      /* Looks like a potential clash of processes on the same file! */
XX	      unlock();				     /* so remove lock file! */
XX	      error("What's this?  The temp mailbox already exists??");
XX	      sleep(2);
XX	      error("Ahhhh.....I give up");
XX	      silently_exit();	/* leave without tampering with it! */
XX	    }
XX.
XX151a
XX	struct header_rec *temp_struct;
XX.
XX120c
XX	if (mailfile != NULL)
XX	  (void) fclose(mailfile);  /* close it first, to avoid too many open */
XX.
XX114a
XX	if (switching_from_default) {	/* we need to remove the tmp file */
XX	    sprintf(buff, "%s%s", temp_mbox, username);
XX	    if (unlink(buff) != 0) {
XX	      error1(
XX	    "Sorry, but I can't seem to unlink your temp mail file [%s]\n\r",
XX		error_name(errno));
XX              silently_exit();
XX	    }
XX	}

XX.
XX108c
XX	    PutLine1(LINES-3,COLUMNS-40,"Mailbox: %s", buff);
XX.
XX106c
XX	    PutLine0(LINES-3,COLUMNS-40,"Resynchronizing file");
XX.
XX104a
XX	  if (first_word(buff, mailhome)) {	/* a mail file! */
XX	    mbox_specified = 0; 	  /* fake program to think that */
XX	    stat = 1;		    	  /*     we're the default file */
XX	    switching_to_default++;	  /*        remember this act!  */
XX	  }

XX.
XX89,93d
XX50a
XX	  if (stat == 1 && strlen(infile) == 0) {	

XX	    /* Subtlety - check to see if there's another instantiation
XX	       of Elm (e.g. if the /tmp file is in use).  If so, DIE! */

XX	    sprintf(infile, "%s%s", temp_mbox, username);
XX	    if (access(infile, ACCESS_EXISTS) != -1) {
XX	      error(
XX	    "Hey!  An instantiation of Elm is already reading this mail!\n\r");
XX              exit(1);
XX            }
XX            sprintf(infile, "%s%s", mailhome, username);
XX	  }
XX.
XX49a
XX	if (mbox_specified == 0 && stat == 0)
XX	  switching_from_default++;

XX.
XX47c
XX	int  switching_to_default = 0, switching_from_default = 0;
XX.
XX25c
XXchar *error_name(), *error_description(), *realloc();
XX.
XX18c
XX#  ifndef BSD4.1
XX#    include <sys/time.h>
XX#  else
XX#    include <time.h>
XX#  endif
XX.
XXw
XXEOF

XXchars=`cat src/newmbox.c | wc -c`

XXif [ $chars -ne 11389 ]
XXthen
XX  echo Your file src/newmbox.c has been changed\!
XX  echo diffs saved as \"src/newmbox.D\"
XXelse
XX  echo applying diffs to file src/newmbox.c...
XX  /bin/cat src/newmbox.D | /bin/ed - src/newmbox.c
XXfi

XX#-------------------------------------
XX# File 'src/file_utils.c' diffs...

XXcat << 'EOF' > src/file_utils.D
XX124c
XX	return(stat);
XX.
XX119c
XX#ifdef BSD
XX	stat = status.w_retcode;
XX#else
XX	stat = status;
XX#endif
XX.
XX108,109c
XX	  if ((fd = fopen(file, mode)) == NULL)
XX	    _exit(errno);
XX	  else {
XX	    fclose(fd);		/* don't just LEAVE it! */
XX	    _exit(0);
XX	  }
XX.
XX106a
XX	  setuid(userid);		/** back to normal userid **/
XX.
XX105d
XX97c
XX	FILE *fd;
XX	int stat = 0, pid, w;
XX#ifdef BSD
XX	union wait status;
XX#else
XX	int status;
XX#endif
XX.
XX93c
XX	/** returns 0 iff user can open the file.  This is not
XX.
XX85c
XX	return(stat);
XX.
XX80,81c
XX#ifdef BSD
XX	stat = status.w_retcode;
XX#else
XX	stat = status;
XX#endif

XX.
XX69,70c

XX	  if (access(file, mode) == 0) 
XX	    _exit(0);
XX	  else 
XX	    _exit(errno != 0? errno : 1);	/* never return zero! */
XX.
XX67a
XX	  setuid(userid);		/** back to normal userid **/

XX.
XX66d
XX58c
XX	int stat = 0, pid, w;
XX#ifdef BSD
XX	union wait status;
XX#else
XX	int status;
XX#endif
XX.
XX56c
XX	/** returns ZERO iff user can access file or "errno" otherwise **/
XX.
XX19a
XX#ifdef BSD
XX# include <sys/wait.h>
XX#endif

XX.
XX16a

XX.
XX15c
XX# undef tolower
XX.
XXw
XXEOF

XXchars=`cat src/file_utils.c | wc -c`

XXif [ $chars -ne 4640 ]
XXthen
XX  echo Your file src/file_utils.c has been changed\!
XX  echo diffs saved as \"src/file_utils.D\"
XXelse
XX  echo applying diffs to file src/file_utils.c...
XX  /bin/cat src/file_utils.D | /bin/ed - src/file_utils.c
XXfi

XX#-------------------------------------
XX# File 'src/reply.c' diffs...

XXcat << 'EOF' > src/reply.c.D
XX362a
XX}

XXint
XXbreak_down_tolist(buf, index, address, comment)
XXchar *buf, *address, *comment;
XXint  *index;
XX{
XX	/** This routine steps through "buf" and extracts a single address
XX	    entry.  This entry can be of any of the following forms;

XX		address (name)
XX		name <address>
XX		address
XX	
XX	    Once it's extracted a single entry, it will then return it as
XX	    two tokens, with 'name' (e.g. comment) surrounded by parens.
XX	    Returns ZERO if done with the string...
XX	**/

XX	char buffer[LONG_STRING];
XX	register int i, loc = 0;

XX	if (*index > strlen(buf)) return(FALSE);

XX	while (whitespace(buf[*index])) (*index)++;

XX	if (*index > strlen(buf)) return(FALSE);

XX	/** Now we're pointing at the first character of the token! **/

XX	while (buf[*index] != ',' && buf[*index] != '\0')
XX	  buffer[loc++] = buf[(*index)++];

XX	(*index)++;

XX	while (whitespace(buffer[loc])) loc--;	/* remove trailing whitespace */

XX	buffer[loc] = '\0';

XX	if (strlen(buffer) == 0) return(FALSE);

XX	dprint1(5, "\n* got \"%s\"\n", buffer);

XX	if (buffer[loc-1] == ')') {	/*   address (name)  format */
XX	  for (loc = 0;buffer[loc] != '(' && loc < strlen(buffer); loc++)
XX		/* get to the opening comment character... */ ;

XX	  loc--;	/* back up to just before the paren */
XX	  while (whitespace(buffer[loc])) loc--;	/* back up */

XX	  /** get the address field... **/

XX	  for (i=0; i <= loc; i++)
XX	    address[i] = buffer[i];
XX	  address[i] = '\0';

XX	  /** now get the comment field, en toto! **/

XX	  loc = 0;

XX	  for (i = chloc(buffer, '('); i < strlen(buffer); i++)
XX	    comment[loc++] = buffer[i];
XX	  comment[loc] = '\0';
XX	}
XX	else if (buffer[loc-1] == '>') {	/*   name <address>  format */
XX	  dprint0(7, "\tcomment <address>\n");
XX	  for (loc = 0;buffer[loc] != '<' && loc < strlen(buffer); loc++)
XX		/* get to the opening comment character... */ ;
XX	  while (whitespace(buffer[loc])) loc--;	/* back up */

XX	  /** get the comment field... **/

XX	  comment[0] = '(';
XX	  for (i=1; i < loc; i++)
XX	    comment[i] = buffer[i-1];
XX	  comment[i++] = ')';
XX	  comment[i] = '\0';

XX	  /** now get the address field, en toto! **/

XX	  loc = 0;

XX	  for (i = chloc(buffer,'<') + 1; i < strlen(buffer) - 1; i++)
XX	    address[loc++] = buffer[i];
XX	
XX	  address[loc] = '\0';
XX	}
XX	else {
XX	  strcpy(address, buffer);
XX	  comment[0] = '\0';
XX	}

XX	dprint2(5,"-- returning '%s' '%s'\n", address, comment);

XX	return(TRUE);
XX.
XX178a

XX	  if (in_message) dprint1(1,"> %s", buf);
XX.
XX175d
XX170c
XX	  while (break_down_tolist(buf, &index, address, comment)) {

XX.
XX168c
XX	  /** we have a buffer with a list of addresses, each of either the
XX	      form "address (name)" or "name <address>".  Our mission, should
XX	      we decide not to be too lazy, is to break it into the two parts.
XX	  **/
XX	      
XX	  if (!whitespace(buf[0]))
XX	    index = chloc(buf, ':')+1;		/* skip header field */
XX	  else
XX	    index = 0;				/* skip whitespace   */
XX.
XX135,137c
XX    char ret_address[LONG_SLEN], buf[LONG_SLEN], new_address[LONG_SLEN],
XX	 address[LONG_SLEN], comment[LONG_SLEN];
XX    char *bufptr;
XX    int  in_message = 1, first_pass = 0, index;
XX.
XXw
XXEOF

XXchars=`cat src/reply.c | wc -c`

XXif [ $chars -ne 10560 ]
XXthen
XX  echo Your file src/reply.c has been changed\!
XX  echo diffs saved as \"src/reply.c.D\"
XXelse
XX  echo applying diffs to file src/reply.c...
XX  /bin/cat src/reply.c.D | /bin/ed - src/reply.c
XXfi

XX#-------------------------------------
XX# File 'src/screen.c' diffs...

XXcat << 'EOF' > src/screen.c.D
XX245c
XX		(highlight && has_highlighting && !arrow_cursor) ?
XX			  end_highlight : "");
XX.
XX230,231c
XX		highlight? ((has_highlighting && !arrow_cursor) ?
XX		           start_highlight : "->") : "  ",
XX		(highlight && has_highlighting && !arrow_cursor)? "  " : "",
XX.
XXw
XXEOF

XXchars=`cat src/screen.c | wc -c`

XXif [ $chars -ne 7956 ]
XXthen
XX  echo Your file src/screen.c has been changed\!
XX  echo diffs saved as \"src/screen.c.D\"
XXelse
XX  echo applying diffs to file src/screen.c...
XX  /bin/cat src/screen.c.D | /bin/ed - src/screen.c
XXfi

XX#-------------------------------------
XX# File 'src/strings.c' diffs...

XXcat << 'EOF' > src/strings.D
XX167c
XX	    current_length += strlen(word);
XX.
XX165c
XX	      current_length += 2;
XX	    }
XX	    for (i=(word[0] == ' '? 1:0); i<strlen(word); i++)
XX.
XX162,163c

XX	  else {	/* just add this address to the list.. */

XX	    if (index > 0) {
XX	      ret_buffer[index++] = ',';	/* comma added! */
XX.
XX158c
XX	    
XX	    /* now add this pup! */

XX	    for (i=(word[0] == ' '? 1:0); i<strlen(word); i++)
XX.
XX152a
XX	      ret_buffer[index++] = ',';	/* close 'er up, doctor! */
XX.
XX150c
XX	while ((word = get_token(bufptr,",", depth)) != NULL) {

XX	    /* first, decide what sort of separator we need, if any... */

XX.
XX131,136c
XX	/** Return buffer with \n\t sequences added at each point where it 
XX	    would be more than 80 chars long.  It only allows the breaks at 
XX	    legal points (ie commas followed by white spaces).  init-len is 
XX	    the characters already on the first line...  Changed so that if 
XX            this is called while mailing without the overhead of "elm", it'll 
XX            include "\r\n\t" instead.
XX	    Changed to use ',' as a separator and to REPLACE it after it's
XX	    found in the output stream...
XX.
XXw
XXEOF

XXchars=`cat src/strings.c | wc -c`

XXif [ $chars -ne 10842 ]
XXthen
XX  echo Your file src/strings.c has been changed\!
XX  echo diffs saved as \"src/strings.D\"
XXelse
XX  echo applying diffs to file src/strings.c...
XX  /bin/cat src/strings.D | /bin/ed - src/strings.c
XXfi

XX#-------------------------------------
XX# File 'src/utils.c' diffs...

XXcat << 'EOF' > src/utils.c.D
XX68a
XX	(void) unlink(buffer);

XX	if (! mail_only) {
XX	  MoveCursor(LINES,0);
XX	  Writechar('\n');
XX	}

XX	exit(0);
XX}

XXsilently_exit()
XX{
XX	/** This is the same as 'leave', but it doesn't remove any non-pid
XX	    files.  It's used when we notice that we're trying to create a
XX	    temp mail file and one already exists!!
XX	**/
XX	char buffer[SLEN];

XX	dprint0(2,"\nLeaving mailer quietly (silently_exit)\n");

XX	Raw(OFF);
XX	if (cursor_control)  transmit_functions(OFF);
XX	if (hp_terminal)     softkeys_off();

XX	sprintf(buffer,"%s%d",temp_file, getpid());  /* editor buffer */
XX	(void) unlink(buffer);

XX	sprintf(buffer,"%s%d",temp_file, getpid()+1);  /* editor buffer */
XX.
XX18a
XXextern int errno;
XXchar *error_name();

XXshow_mailfile_stats()
XX{
XX	/** when we're about to die, let's try to dump lots of good stuff
XX	    to the debug file... **/

XX	struct stat buffer;

XX	if (debug == 0) return;		/* Damn!  Can't do it! */

XX	if (fstat(fileno(mailfile), &buffer) == 0) {
XX	  dprint1(1,"\nDump of stats for mailfile %s;\n", infile);

XX	  dprint3(1, "\tinode: %d, mode: %o, uid: %d, ",
XX			buffer.st_ino, buffer.st_mode, buffer.st_uid);
XX	  dprint2(1,"gid: %d, size: %d\n\n", buffer.st_gid, buffer.st_size);

XX	  dprint1(1,"\toffset into file = %l\n", ftell(mailfile));
XX	}
XX	else
XX	  dprint2(1,"\nfstat on mailfile '%s' failed with error %s!!\n\n",
XX			infile, error_name(errno));
XX}
XX	
XX.
XX11a
XX#include <errno.h>
XX.
XXw
XXEOF

XXchars=`cat src/utils.c | wc -c`

XXif [ $chars -ne 3786 ]
XXthen
XX  echo Your file src/utils.c has been changed\!
XX  echo diffs saved as \"src/utils.c.D\"
XXelse
XX  echo applying diffs to file src/utils.c...
XX  /bin/cat src/utils.c.D | /bin/ed - src/utils.c
XXfi

XX#-------------------------------------
XX# File 'src/syscall.c' diffs...

XXcat << 'EOF' > src/syscall.D
XX91c
XX	return(stat);
XX.
XX86c
XX#ifdef BSD
XX	if (status.w_retcode != 0) stat = status.w_retcode;
XX#else
XX	if (w == -1) stat = status;
XX#endif
XX.
XX76c
XX	    execl("/bin/sh", "sh", "-c", string, (char *) 0);
XX.
XX73c
XX	    execl(shell, argv_zero(shell), "-c", string, (char *) 0);
XX.
XX70a
XX	  setuid(userid);	/* back to the normal user! */
XX.
XX69d
XX58c
XX	int stat = 0, pid, w;
XX#ifdef BSD
XX	union wait status;
XX#else
XX	int status;
XX#endif
XX.
XX12a
XX#ifdef BSD
XX#  include <sys/wait.h>
XX#endif

XX.
XXw
XXEOF

XXchars=`cat src/syscall.c | wc -c`

XXif [ $chars -ne 4692 ]
XXthen
XX  echo Your file src/syscall.c has been changed\!
XX  echo diffs saved as \"src/syscall.D\"
XXelse
XX  echo applying diffs to file src/syscall.c...
XX  /bin/cat src/syscall.D | /bin/ed - src/syscall.c
XXfi

XX#-------------------------------------
XX# File 'src/aliaslib.c' diffs...

XXcat << 'EOF' > src/aliaslib.D
XX159c
XX	/* Read from file fd.  End read upon reading either 
XX.
XXw
XXEOF

XXchars=`cat src/aliaslib.c | wc -c`

XXif [ $chars -ne 4476 ]
XXthen
XX  echo Your file src/aliaslib.c has been changed\!
XX  echo diffs saved as \"src/aliaslib.D\"
XXelse
XX  echo applying diffs to file src/aliaslib.c...
XX  /bin/cat src/aliaslib.D | /bin/ed - src/aliaslib.c
XXfi

XX#-------------------------------------
XX# File 'src/domains.c' diffs...

XXcat << 'EOF' > src/domains.D
XX16a
XX#ifdef BSD
XX# undef toupper
XX# undef tolower
XX#endif

XX.
XXw
XXEOF

XXchars=`cat src/domains.c | wc -c`

XXif [ $chars -ne 7635 ]
XXthen
XX  echo Your file src/domains.c has been changed\!
XX  echo diffs saved as \"src/domains.D\"
XXelse
XX  echo applying diffs to file src/domains.c...
XX  /bin/cat src/domains.D | /bin/ed - src/domains.c
XXfi

XX#-------------------------------------
XX# File 'src/fileio.c' diffs...

XXcat << 'EOF' > src/fileio.c.D
XX64a

XX#ifdef SITE_HIDING

XXint
XXis_a_hidden_user(username)
XXchar *username;
XX{
XX	/** Returns true iff the username is present in the list of
XX	   'hidden users' on the system.
XX	**/
XX	
XX	FILE *hidden_users;
XX	char  buffer[SLEN];

XX	if ((hidden_users = fopen (HIDDEN_SITE_USERS,"r")) == NULL) {
XX	  dprint2(1,"Couldn't open hidden site file %s [%s]\n",
XX		  HIDDEN_SITE_USERS, error_name(errno));
XX	  return(FALSE);
XX	}

XX	while (fscanf(hidden_users, "%s", buffer) != EOF)
XX	  if (strcmp(buffer, username) == 0) {
XX	    dprint1(3,"** Found user '%s' in hidden site file!\n",
XX		    username);
XX	    fclose(hidden_users);
XX	    return(TRUE);
XX	  }

XX	fclose(hidden_users);
XX	dprint1(3,"** Couldn't find user '%s' in hidden site file!\n",
XX		username);

XX	return(FALSE);
XX}

XX#endif
XX.
XX59a
XX	    ok = 0;	/* STOP NOW! */
XX.
XX14a
XXextern int errno;

XXchar *error_name();

XX.
XX9a
XX#include <errno.h>
XX.
XXw
XXEOF

XXchars=`cat src/fileio.c | wc -c`

XXif [ $chars -ne 1967 ]
XXthen
XX  echo Your file src/fileio.c has been changed\!
XX  echo diffs saved as \"src/fileio.c.D\"
XXelse
XX  echo applying diffs to file src/fileio.c...
XX  /bin/cat src/fileio.c.D | /bin/ed - src/fileio.c
XXfi

XX#-------------------------------------
XX# File 'src/return_addr.c' diffs...

XXcat << 'EOF' > src/return_addr.D
XX282a
XX    else {
XX       /* if we have a space character, or we DON'T have '!' or '@' chars */

XX       if (chloc(header_table[current-1].from, ' ') >= 0 ||
XX	   (chloc(header_table[current-1].from, '!') < 0 &&
XX	    chloc(header_table[current-1].from, '@') < 0))

XX	 sprintf(name2, " (%s)", header_table[current-1].from);
XX	 strcat(buffer, name2);
XX    }

XX.
XX229a
XX    /* now initialize all the char buffers [thanks Keith!] */

XX    buf[0] = name1[0] = name2[0] = lastname[0] = '\0';
XX    hold_return[0] = alt_name2[0] = '\0';

XX.
XXw
XXEOF

XXchars=`cat src/return_addr.c | wc -c`

XXif [ $chars -ne 9321 ]
XXthen
XX  echo Your file src/return_addr.c has been changed\!
XX  echo diffs saved as \"src/return_addr.D\"
XXelse
XX  echo applying diffs to file src/return_addr.c...
XX  /bin/cat src/return_addr.D | /bin/ed - src/return_addr.c
XXfi

XX#-------------------------------------
XX# File 'src/addr_utils.c' diffs...

XXcat << 'EOF' > src/addr_utils.D
XX219c

XX	      if (mail_only) 
XX	        printf(buffer);
XX	      else
XX.
XXw
XXEOF

XXchars=`cat src/addr_utils.c | wc -c`

XXif [ $chars -ne 15408 ]
XXthen
XX  echo Your file src/addr_utils.c has been changed\!
XX  echo diffs saved as \"src/addr_utils.D\"
XXelse
XX  echo applying diffs to file src/addr_utils.c...
XX  /bin/cat src/addr_utils.D | /bin/ed - src/addr_utils.c
XXfi

XX#-------------------------------------
XX# File 'src/input_utils.c' diffs...

XXcat << 'EOF' > src/input_utils.D
XX85c
XX	if (! append_current && ! mail_only)
XX.
XX83c
XX	if (!mail_only)
XX	  PutLine1(x,y, "%s", string);	
XX	else
XX	  printf("%s", string);	

XX.
XXw
XXEOF

XXchars=`cat src/input_utils.c | wc -c`

XXif [ $chars -ne 7235 ]
XXthen
XX  echo Your file src/input_utils.c has been changed\!
XX  echo diffs saved as \"src/input_utils.D\"
XXelse
XX  echo applying diffs to file src/input_utils.c...
XX  /bin/cat src/input_utils.D | /bin/ed - src/input_utils.c
XXfi

XX#-------------------------------------
XX# File 'src/mailtime.c' diffs...

XXcat << 'EOF' > src/mailtime.D
XX117a
XX	/** That's what I like about programming for BSD & USG - the easy
XX	    portability between 'em.  Especially the section 2 calls!! **/

XX.
XX116c
XX	if (utime(filename, NULL) == -1)	/* note no "S"  */
XX.
XX114c
XX	if (utimes(filename, &tval) == -1)	/* note the "S" */
XX# endif
XX.
XX110a
XX# ifdef BSD4.1
XX	tval = (time_t) time((long *) 0);
XX	if (utime(filename, &tval) == -1)
XX# else
XX.
XX105a
XX# endif
XX.
XX103a
XX# ifdef BSD4.1
XX	struct timeb  loc_time;
XX	time_t tval;
XX# else
XX.
XX73a
XX#ifdef BSD
XX	extern struct tm *localtime();
XX#endif
XX.
XX14c
XX#  ifndef BSD4.1
XX#    include <sys/time.h>
XX#  else
XX#    include <time.h>
XX#    include <sys/timeb.h>
XX#  endif
XX.
XXw
XXEOF

XXchars=`cat src/mailtime.c | wc -c`

XXif [ $chars -ne 4271 ]
XXthen
XX  echo Your file src/mailtime.c has been changed\!
XX  echo diffs saved as \"src/mailtime.D\"
XXelse
XX  echo applying diffs to file src/mailtime.c...
XX  /bin/cat src/mailtime.D | /bin/ed - src/mailtime.c
XXfi

XX#-------------------------------------
XX# File 'src/opt_utils.c' diffs...

XXcat << 'EOF' > src/opt_utils.D
XX38a

XX#endif

XX#ifdef UTS
XX.
XX20c
XX#ifdef NEED_GETHOSTNAME
XX.
XX17,18c
XX# include <sys/tubio.h>
XX# define  TTYIN		0		/* standard input */
XX#endif
XX.
XX13c
XX# include <pwd.h>
XX#else
XX# include <sys/utsname.h>
XX.
XXw
XXEOF

XXchars=`cat src/opt_utils.c | wc -c`

XXif [ $chars -ne 4997 ]
XXthen
XX  echo Your file src/opt_utils.c has been changed\!
XX  echo diffs saved as \"src/opt_utils.D\"
XXelse
XX  echo applying diffs to file src/opt_utils.c...
XX  /bin/cat src/opt_utils.D | /bin/ed - src/opt_utils.c
XXfi

XX#-------------------------------------
XX# File 'src/mailmsg2.c' diffs...

XXcat << 'EOF' > src/mailmsg2.D
XX405,406c
XX	fprintf(filedesc,"From: %s <%s!%s>\n", full_username,
XX		hostname, username);
XX.
XX401,402c
XX	fprintf(filedesc,"From: %s <%s@%s>\n", full_username,
XX		username, hostname);
XX.
XX398,399c
XX	fprintf(filedesc,"From: %s <%s@%s%s>\n", full_username, 
XX		username, hostname, DOMAIN);
XX.
XX395a
XX# ifdef SITE_HIDING
XX	if (is_a_hidden_user(username))
XX	  fprintf(filedesc,"From: %s <%s!%s!%s>\n", full_username,
XX		  hostname, HIDDEN_SITE_NAME, username);
XX	else
XX# endif
XX.
XX390a
XX#ifdef SITE_HIDING
XX	if (is_a_hidden_user(username)) {
XX	  /** this is the interesting part of this trick... **/
XX	  sprintf(buffer, "From %s!%s %s\n",  HIDDEN_SITE_NAME,
XX		  username, get_ctime_date());
XX	  fprintf(filedesc, "%s", buffer);
XX	  dprint1(1,"\nadded: %s", buffer);
XX	  /** so is this perverted or what? **/
XX	}
XX#endif

XX.
XX313c
XX	      printf("No\n\r\n\r");
XX	      /** try to save it as a dead letter file **/
XX	      
XX	      sprintf(fname, "%s/%s", home, dead_letter);

XX	      if ((deadfd = fopen(fname,"a")) == NULL) {
XX		dprint2(1,
XX		    "\nAttempt to append to deadletter file '%s' failed: %s\n",
XX		    fname, error_name(errno));
XX	        printf("Message not saved, Sorry.\n\r\n\r");
XX		return('f');
XX	      }
XX	      else if ((messagefd = fopen(filename, "r")) == NULL) {
XX		dprint2(1,"\nAttempt to read reply file '%s' failed: %s\n",
XX			filename, error_name(errno));
XX	        printf("Message not saved, Sorry.\n\r\n\r");
XX		return('f');
XX	      }
XX	
XX	      /* if we get here we're okay for everything, right? */

XX	      while (fgets(buffer, LONG_SLEN, messagefd) != NULL)
XX		fputs(buffer, deadfd);

XX	      fclose(messagefd);
XX	      fclose(deadfd);

XX	      printf("Message saved in file \"$HOME/%s\"\n\n", dead_letter);

XX.
XX303c
XX	FILE *deadfd, *messagefd;
XX	char ch, buffer[LONG_SLEN], fname[SLEN];
XX.
XX301c
XX	    TRUE if everything is okay, FALSE if cancelled.  Modified
XX	    compliments of Steve Wolf to add the'dead.letter' feature **/
XX.
XX298c
XXverify_transmission(filename)
XXchar *filename;
XX.
XX199c
XX                  mailer, strip_parens(strip_commas(expanded_to)), 
XX.
XX195c
XX                  sendmail, smflags, strip_parens(strip_commas(expanded_to)), 
XX.
XX193c
XX	  if (access(sendmail, EXECUTE_ACCESS) == 0 
XX#ifdef SITE_HIDING
XX	      && ! is_a_hidden_user(username))
XX#else
XX	     )
XX#endif
XX.
XX178c
XX                  mailx, subject, strip_parens(strip_commas(expanded_to)), 
XX.
XX155c
XX	if (auto_cc && !batch) 
XX.
XX139,140c
XX	  error1("Could not open reply file (%s)", error_name(errno));
XX	  return(1);
XX.
XX136c
XX	  dprint2(1,
XX.
XX133a

XX	  if ((reply = fopen(filename,"r")) == NULL) {
XX	      dprint2(1,
XX	    "Attempt to open file %s for reading failed with error %s (mail)\n",
XX                filename, error_name(errno));
XX	      error1("Could not open reply file (%s)", error_name(errno));
XX	      return(1);
XX	  }
XX.
XX129c
XX	    if ((ch = verify_transmission(filename)) == 'f') {	/* cancelled! */
XX.
XX124a
XX	       default : /* do nothing */ ;
XX.
XX121c
XX******************************************************************************/
XX.
XX112c
XX/*****************************************************************************
XX	      case 'e' : if (edit_message) edit_the_message(filename);
XX	               /** now let's try reading it again... 

XX		       (void) fclose(reply);	/* make sure it's closed
XX.
XX110c
XX	      case 'e' : edit_the_message(filename);	break;
XX.
XX108d
XX103c
XX	ch = edit_message? 'e' : ' ';	/* drop through if needed... */
XX.
XX78c
XX	    fprintf(reply, "%s\n", very_long_buffer);
XX.
XX75d
XX71d
XX40c
XX	char ch;
XX.
XX14c
XXchar *format_long(), *strip_commas(), *tail_of_string(); 
XX#ifdef SITE_HIDING 
XX char *get_ctime_date();
XX#endif
XX.
XXw
XXEOF

XXchars=`cat src/mailmsg2.c | wc -c`

XXif [ $chars -ne 14200 ]
XXthen
XX  echo Your file src/mailmsg2.c has been changed\!
XX  echo diffs saved as \"src/mailmsg2.D\"
XXelse
XX  echo applying diffs to file src/mailmsg2.c...
XX  /bin/cat src/mailmsg2.D | /bin/ed - src/mailmsg2.c
XXfi

XX#-------------------------------------
XX# File 'src/savecopy.c' diffs...

XXcat << 'EOF' > src/savecopy.D
XX100c
XX	thetime = (long) time((long *) 0);      /* dumb dumb dumb routine */
XX.
XX52c
XX	    if (can_access(savename, READ_ACCESS) != 0)
XX.
XX10a
XX# endif
XX.
XX9a
XX# ifdef BSD4.1
XX#  include <time.h>
XX# else
XX.
XXw
XXEOF

XXchars=`cat src/savecopy.c | wc -c`

XXif [ $chars -ne 4059 ]
XXthen
XX  echo Your file src/savecopy.c has been changed\!
XX  echo diffs saved as \"src/savecopy.D\"
XXelse
XX  echo applying diffs to file src/savecopy.c...
XX  /bin/cat src/savecopy.D | /bin/ed - src/savecopy.c
XXfi

XX#-------------------------------------
XX# File 'src/mailmsg1.c' diffs...

XXcat << 'EOF' > src/mailmsg1.D
XX245c
XX	  printf("To: %s\n\r", format_long(address, 3));
XX.
XXw
XXEOF

XXchars=`cat src/mailmsg1.c | wc -c`

XXif [ $chars -ne 6587 ]
XXthen
XX  echo Your file src/mailmsg1.c has been changed\!
XX  echo diffs saved as \"src/mailmsg1.D\"
XXelse
XX  echo applying diffs to file src/mailmsg1.c...
XX  /bin/cat src/mailmsg1.D | /bin/ed - src/mailmsg1.c
XXfi

XX#-------------------------------------
XX# File 'src/connect_to.c' diffs...

XXcat << 'EOF' > src/connect_to.D
XX128c
XX	    system_record = (struct lsys_rec *) pmalloc(sizeof *talk_to_sys);
XX.
XX115c
XX	    previous_record = (struct lsys_rec *) pmalloc(sizeof *talk_to_sys);
XX.
XX61c
XX	    system_record = (struct lsys_rec *) pmalloc(sizeof *talk_to_sys);
XX.
XX48c
XX	    previous_record = (struct lsys_rec *) pmalloc(sizeof *talk_to_sys);
XX.
XX13a
XXchar *pmalloc();

XX.
XXw
XXEOF

XXchars=`cat src/connect_to.c | wc -c`

XXif [ $chars -ne 3887 ]
XXthen
XX  echo Your file src/connect_to.c has been changed\!
XX  echo diffs saved as \"src/connect_to.D\"
XXelse
XX  echo applying diffs to file src/connect_to.c...
XX  /bin/cat src/connect_to.D | /bin/ed - src/connect_to.c
XXfi

XX#-------------------------------------
XX# File 'src/errno.c' diffs...

XXcat << 'EOF' > src/errno.c.D
XX74,75d
XX60,61d
XXw
XXEOF

XXchars=`cat src/errno.c | wc -c`

XXif [ $chars -ne 2612 ]
XXthen
XX  echo Your file src/errno.c has been changed\!
XX  echo diffs saved as \"src/errno.c.D\"
XXelse
XX  echo applying diffs to file src/errno.c...
XX  /bin/cat src/errno.c.D | /bin/ed - src/errno.c
XXfi

XX#-------------------------------------
XX# File 'src/options.c' diffs...

XXcat << 'EOF' > src/options.D
XX52c
XX  "This is the program invoked to display individual messages (try 'builtin')");
XX.
XXw
XXEOF

XXchars=`cat src/options.c | wc -c`

XXif [ $chars -ne 7702 ]
XXthen
XX  echo Your file src/options.c has been changed\!
XX  echo diffs saved as \"src/options.D\"
XXelse
XX  echo applying diffs to file src/options.c...
XX  /bin/cat src/options.D | /bin/ed - src/options.c
XXfi

XX#-------------------------------------
XX# File 'src/elm.c' diffs...

XXcat << 'EOF' > src/elm.c.D
XX105c
XX			   if (move_when_paged && header_page >= 0)
XX.
XX100c
XX			       header_page <=(message_count / headers_per_page))
XX.
XX34c
XX		   format_long(to_whom, 3));
XX.
XX31a
XX#ifdef BSD4.1
XX	   initscr();
XX#endif

XX.
XX27a
XX#ifdef BSD
XX	InitScreen();
XX#endif

XX.
XX10a
XX#ifdef BSD
XX# undef toupper
XX# undef tolower
XX#endif

XX.
XXw
XXEOF

XXchars=`cat src/elm.c | wc -c`

XXif [ $chars -ne 15852 ]
XXthen
XX  echo Your file src/elm.c has been changed\!
XX  echo diffs saved as \"src/elm.c.D\"
XXelse
XX  echo applying diffs to file src/elm.c...
XX  /bin/cat src/elm.c.D | /bin/ed - src/elm.c
XXfi

XX#---------------------------------
XX# File Elm/src/builtin.c is new!

XXecho File Elm/src/builtin.c is new - extracting...
XXif [ -f src/builtin.c ]
XXthen
XX  echo File \'src/builtin.c\' is new, but you already have something called that\!
XX  echo I\'m going to move your file to \'src/builtin.c.old\'...
XX  /bin/mv -f src/builtin.c src/builtin.c.old
XXelse
XX  echo Extracting new file \'src/builtin.c\'
XXfi

XXcat > src/builtin.c << 'END_OF_FILE'
XX/**			builtin.c		**/

XX/** This is the built-in pager for displaying messages while in the Elm
XX    program.  It's a bare-bones pager with precious few options. The idea
XX    is that those systems that are sufficiently slow that using an external
XX    pager such as 'more' is too slow, then they can use this!

XX    (C) Copyright 1986, Dave Taylor
XX**/

XX#include "headers.h"
XX#include <ctype.h>

XX#define  BEEP		007		/* ASCII Bell character */

XX#ifdef BSD
XX#  undef tolower
XX#endif

XXint	lines_put_on_screen = 0,    /* number of lines displayed per screen */
XX	lines_displayed = 0,	    /* Total number of lines displayed      */
XX	total_lines_to_display;	    /* total number of lines in message     */

XXstart_builtin(lines_in_message)
XXint lines_in_message;
XX{
XX	/** clears that screen and resets it's internal counters... **/

XX	dprint1(8,"displaying %d lines from message using internal pager\n",
XX		lines_in_message);

XX	lines_displayed = 0;
XX	lines_put_on_screen = 0;

XX	total_lines_to_display = lines_in_message;
XX}

XXint
XXdisplay_line(line)
XXchar *line;
XX{
XX	/** Display the given line on the screen, taking into account such
XX	    dumbness as wraparound and such.  If displaying this would put
XX	    us at the end of the screen, put out the "MORE" prompt and wait
XX	    for some input.   Return non-zero if the user terminates the
XX	    paging (e.g. 'q') or zero if we should continue...
XX	**/
XX	
XX	register int lines_needed, okay_char, ch;

XX	lines_needed = (int) (printable_chars(line) / COLUMNS);	/* wraparound */

XX	for (ch = 0; ch < strlen(line); ch++)
XX	  if (line[ch] == '\n') lines_needed++;

XX	dprint1(6,"* display-line \"%s\"\n", line);
XX	dprint2(7,"**  at line %d of the screen (%d available)\n",
XX		 lines_put_on_screen, LINES-1);

XX	if (lines_needed + lines_put_on_screen > LINES-1) {
XX	  dprint2(9,"** need CR: lines on screen = %d, need %d\n", lines_needed,
XX		  lines_put_on_screen);
XX	  StartBold();
XX	  Write_to_screen(" More (%d%%)", 1, 
XX		(int) (100.0 * (
XX		   (float) lines_displayed / (float) total_lines_to_display)));
XX	  EndBold();
XX	  okay_char = FALSE;
XX	  do {
XX	     Raw(ON);
XX	     ch =  tolower(ReadCh());
XX	     Raw(OFF);
XX	     switch (ch) {
XX	       case '\n' : 
XX	       case '\r' : /* <return> pressed... */
XX			   lines_put_on_screen -= lines_needed;
XX			   okay_char = TRUE;
XX			   break;
XX	       case ' '  : /* <space> pressed... */
XX			   lines_put_on_screen = 0;
XX			   okay_char = TRUE;
XX			   break;
XX	       case 'q'  :
XX	       case 'Q'  : return(TRUE);	/* get OUTTA here! */
XX	       default   : putchar(BEEP);	
XX			   fflush(stdout);
XX			   break;
XX	     }
XX	  } while (! okay_char);

XX	  CursorLeft(11);		/* back up to the beginning of line */
XX	  CleartoEOLN();
XX	}

XX	Write_to_screen("%s", 1, line);

XX	lines_displayed     += 1;		   /* tossed on screen */
XX	lines_put_on_screen += lines_needed;	   /* read from file   */

XX	return (FALSE);
XX}
XXEND_OF_FILE

XXchars=`cat src/builtin.c | wc -c`

XXif [ $chars -ne 2825 ]
XXthen
XX  echo File damaged in transit...should be 2825 bytes, is $chars instead
XX  echo  I suggest you check it closely...
XXfi

XX#-------------------------------------
XX# File 'src/getopt.c' diffs...

XXcat << 'EOF' > src/getopt.c.D
XX83c
XX	if (word == NULL)
XX	  return(ERROR);		/* Sun compatibility */

XX	if (word == NULL || strlen(word) == 0) 
XX.
XX71,75d
XX66c
XX	if (_argnum >= argc) {
XX.
XX61,64d
XX57c
XX	if (_indx > strlen(argv[_argnum]) == NULL && _indx > 1) {
XX.
XX52c
XX	if (_argnum >= argc) {	/* quick check first - no arguments! */
XX.
XX18a

XX.
XX7a
XX#include "defs.h"

XX.
XXw
XXEOF

XXchars=`cat src/getopt.c | wc -c`

XXif [ $chars -ne 2253 ]
XXthen
XX  echo Your file src/getopt.c has been changed\!
XX  echo diffs saved as \"src/getopt.c.D\"
XXelse
XX  echo applying diffs to file src/getopt.c...
XX  /bin/cat src/getopt.c.D | /bin/ed - src/getopt.c
XXfi

XXecho end of autodiff, part 1
XXexit 0

@//E*O*F Edit1//
chmod u=rwx,g=rwx,o=rwx $OUT
 
echo Inspecting for damage in transit...
temp=/tmp/sharin$$; dtemp=/tmp/sharout$$
trap "rm -f $temp $dtemp; exit" 0 1 2 3 15
cat > $temp <<\!!!
    2543    7256   53137 Edit1
!!!
wc  Edit1 | sed 's=[^ ]*/==' | diff -b $temp - >$dtemp
if test -s $dtemp ; then
    echo "Ouch [diff of wc output]:"
    cat $dtemp
    STATUS=1
elif test $STATUS = 0 ; then
    echo "No problems found."
else
    echo "WARNING -- PROBLEMS WERE FOUND..."
fi
exit $STATUS
