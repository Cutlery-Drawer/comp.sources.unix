Subject:  v07i039:  Release 2.0 of patch, Part02/03
Newsgroups: mod.sources
Approved: mirror!rs

Submitted by: sdcrdcf!lwall (Larry Wall)
Mod.sources: Volume 7, Issue 39
Archive-name: patch2/Part02

Here is the official 2.0 release of patch.  It supersedes the 1.5 beta
version posted to net.sources, and the version that comes with 4.3bsd.

Larry Wall
sdcrdcf!lwall

--------------------------CUT HERE---------------------------
#! /bin/sh

# Make a new directory for the patch sources, cd to it, and run kits 1 thru 3 
# through sh.  When all 3 kits have been run, read README.

echo "This is patch kit 2 (of 3).  If kit 2 is complete, the line"
echo '"'"End of kit 2 (of 3)"'" will echo at the end.'
echo ""
export PATH || (echo "You didn't use sh, you clunch." ; kill $$)
echo Extracting patch.c
sed >patch.c <<'!STUFFY!FUNK!' -e 's/X//'
Xchar rcsid[] =
X	"$Header: patch.c,v 2.0 86/09/17 15:37:32 lwall Exp $";
X
X/* patch - a program to apply diffs to original files
X *
X * Copyright 1986, Larry Wall
X *
X * This program may be copied as long as you don't try to make any
X * money off of it, or pretend that you wrote it.
X *
X * $Log:	patch.c,v $
X * Revision 2.0  86/09/17  15:37:32  lwall
X * Baseline for netwide release.
X * 
X * Revision 1.5  86/08/01  20:53:24  lwall
X * Changed some %d's to %ld's.
X * Linted.
X * 
X * Revision 1.4  86/08/01  19:17:29  lwall
X * Fixes for machines that can't vararg.
X * Added fuzz factor.
X * Generalized -p.
X * General cleanup.
X * 
X * 85/08/15 van%ucbmonet@berkeley
X * Changes for 4.3bsd diff -c.
X *
X * Revision 1.3  85/03/26  15:07:43  lwall
X * Frozen.
X * 
X * Revision 1.2.1.9  85/03/12  17:03:35  lwall
X * Changed pfp->_file to fileno(pfp).
X * 
X * Revision 1.2.1.8  85/03/12  16:30:43  lwall
X * Check i_ptr and i_womp to make sure they aren't null before freeing.
X * Also allow ed output to be suppressed.
X * 
X * Revision 1.2.1.7  85/03/12  15:56:13  lwall
X * Added -p option from jromine@uci-750a.
X * 
X * Revision 1.2.1.6  85/03/12  12:12:51  lwall
X * Now checks for normalness of file to patch.
X * 
X * Revision 1.2.1.5  85/03/12  11:52:12  lwall
X * Added -D (#ifdef) option from joe@fluke.
X * 
X * Revision 1.2.1.4  84/12/06  11:14:15  lwall
X * Made smarter about SCCS subdirectories.
X * 
X * Revision 1.2.1.3  84/12/05  11:18:43  lwall
X * Added -l switch to do loose string comparison.
X * 
X * Revision 1.2.1.2  84/12/04  09:47:13  lwall
X * Failed hunk count not reset on multiple patch file.
X * 
X * Revision 1.2.1.1  84/12/04  09:42:37  lwall
X * Branch for sdcrdcf changes.
X * 
X * Revision 1.2  84/11/29  13:29:51  lwall
X * Linted.  Identifiers uniqified.  Fixed i_ptr malloc() bug.  Fixed
X * multiple calls to mktemp().  Will now work on machines that can only
X * read 32767 chars.  Added -R option for diffs with new and old swapped.
X * Various cosmetic changes.
X * 
X * Revision 1.1  84/11/09  17:03:58  lwall
X * Initial revision
X * 
X */
X
X#include "INTERN.h"
X#include "common.h"
X#include "EXTERN.h"
X#include "version.h"
X#include "util.h"
X#include "pch.h"
X#include "inp.h"
X
X/* procedures */
X
Xvoid reinitialize_almost_everything();
Xvoid get_some_switches();
XLINENUM locate_hunk();
Xvoid abort_hunk();
Xvoid apply_hunk();
Xvoid do_ed_script();
Xvoid init_output();
Xvoid init_reject();
Xvoid copy_till();
Xvoid spew_output();
Xvoid dump_line();
Xbool patch_match();
Xbool similar();
Xvoid re_input();
Xvoid my_exit();
X
X/* Apply a set of diffs as appropriate. */
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X{
X    LINENUM where;
X    LINENUM newwhere;
X    LINENUM fuzz;
X    LINENUM mymaxfuzz;
X    int hunk = 0;
X    int failed = 0;
X    int i;
X
X    setbuf(stderr, serrbuf);
X    for (i = 0; i<MAXFILEC; i++)
X	filearg[i] = Nullch;
X    Mktemp(TMPOUTNAME);
X    Mktemp(TMPINNAME);
X    Mktemp(TMPREJNAME);
X    Mktemp(TMPPATNAME);
X
X    /* parse switches */
X    Argc = argc;
X    Argv = argv;
X    get_some_switches();
X    
X    /* make sure we clean up /tmp in case of disaster */
X    set_signals();
X
X    for (
X	open_patch_file(filearg[1]);
X	there_is_another_patch();
X	reinitialize_almost_everything()
X    ) {					/* for each patch in patch file */
X
X	if (outname == Nullch)
X	    outname = savestr(filearg[0]);
X    
X	/* initialize the patched file */
X	if (!skip_rest_of_patch)
X	    init_output(TMPOUTNAME);
X    
X	/* for ed script just up and do it and exit */
X	if (diff_type == ED_DIFF) {
X	    do_ed_script();
X	    continue;
X	}
X    
X	/* initialize reject file */
X	init_reject(TMPREJNAME);
X    
X	/* find out where all the lines are */
X	if (!skip_rest_of_patch)
X	    scan_input(filearg[0]);
X    
X	/* from here on, open no standard i/o files, because malloc */
X	/* might misfire and we can't catch it easily */
X    
X	/* apply each hunk of patch */
X	hunk = 0;
X	failed = 0;
X	out_of_mem = FALSE;
X	while (another_hunk()) {
X	    hunk++;
X	    fuzz = Nulline;
X	    mymaxfuzz = pch_context();
X	    if (maxfuzz < mymaxfuzz)
X		mymaxfuzz = maxfuzz;
X	    if (!skip_rest_of_patch) {
X		do {
X		    where = locate_hunk(fuzz);
X		    if (hunk == 1 && where == Nulline && !force) {
X						/* dwim for reversed patch? */
X			if (!pch_swap()) {
X			    if (fuzz == Nulline)
X				say1("\
XNot enough memory to try swapped hunk!  Assuming unswapped.\n");
X			    continue;
X			}
X			reverse = !reverse;
X			where = locate_hunk(fuzz);  /* try again */
X			if (where == Nulline) {	    /* didn't find it swapped */
X			    if (!pch_swap())         /* put it back to normal */
X				fatal1("Lost hunk on alloc error!\n");
X			    reverse = !reverse;
X			}
X			else if (noreverse) {
X			    if (!pch_swap())         /* put it back to normal */
X				fatal1("Lost hunk on alloc error!\n");
X			    reverse = !reverse;
X			    say1("\
XIgnoring previously applied (or reversed) patch.\n");
X			    skip_rest_of_patch = TRUE;
X			}
X			else {
X			    ask3("\
X%seversed (or previously applied) patch detected!  %s -R? [y] ",
X				reverse ? "R" : "Unr",
X				reverse ? "Assume" : "Ignore");
X			    if (*buf == 'n') {
X				ask1("Apply anyway? [n] ");
X				if (*buf != 'y')
X				    skip_rest_of_patch = TRUE;
X				where = Nulline;
X				reverse = !reverse;
X				if (!pch_swap())  /* put it back to normal */
X				    fatal1("Lost hunk on alloc error!\n");
X			    }
X			}
X		    }
X		} while (!skip_rest_of_patch && where == Nulline &&
X		    ++fuzz <= mymaxfuzz);
X
X		if (skip_rest_of_patch) {		/* just got decided */
X		    Fclose(ofp);
X		    ofp = Nullfp;
X		}
X	    }
X
X	    newwhere = pch_newfirst() + last_offset;
X	    if (skip_rest_of_patch) {
X		abort_hunk();
X		failed++;
X		if (verbose)
X		    say3("Hunk #%d ignored at %ld.\n", hunk, newwhere);
X	    }
X	    else if (where == Nulline) {
X		abort_hunk();
X		failed++;
X		if (verbose)
X		    say3("Hunk #%d failed at %ld.\n", hunk, newwhere);
X	    }
X	    else {
X		apply_hunk(where);
X		if (verbose) {
X		    say3("Hunk #%d succeeded at %ld", hunk, newwhere);
X		    if (fuzz)
X			say2(" with fuzz %ld", fuzz);
X		    if (last_offset)
X			say3(" (offset %ld line%s)",
X			    last_offset, last_offset==1L?"":"s");
X		    say1(".\n");
X		}
X	    }
X	}
X
X	if (out_of_mem && using_plan_a) {
X	    Argc = Argc_last;
X	    Argv = Argv_last;
X	    say1("\n\nRan out of memory using Plan A--trying again...\n\n");
X	    continue;
X	}
X    
X	assert(hunk);
X    
X	/* finish spewing out the new file */
X	if (!skip_rest_of_patch)
X	    spew_output();
X	
X	/* and put the output where desired */
X	ignore_signals();
X	if (!skip_rest_of_patch) {
X	    if (move_file(TMPOUTNAME, outname) < 0) {
X		toutkeep = TRUE;
X		chmod(TMPOUTNAME, filemode);
X	    }
X	    else
X		chmod(outname, filemode);
X	}
X	Fclose(rejfp);
X	rejfp = Nullfp;
X	if (failed) {
X	    if (!*rejname) {
X		Strcpy(rejname, outname);
X		Strcat(rejname, ".rej");
X	    }
X	    if (skip_rest_of_patch) {
X		say4("%d out of %d hunks ignored--saving rejects to %s\n",
X		    failed, hunk, rejname);
X	    }
X	    else {
X		say4("%d out of %d hunks failed--saving rejects to %s\n",
X		    failed, hunk, rejname);
X	    }
X	    if (move_file(TMPREJNAME, rejname) < 0)
X		trejkeep = TRUE;
X	}
X	set_signals();
X    }
X    my_exit(0);
X}
X
X/* Prepare to find the next patch to do in the patch file. */
X
Xvoid
Xreinitialize_almost_everything()
X{
X    re_patch();
X    re_input();
X
X    input_lines = 0;
X    last_frozen_line = 0;
X
X    filec = 0;
X    if (filearg[0] != Nullch && !out_of_mem) {
X	free(filearg[0]);
X	filearg[0] = Nullch;
X    }
X
X    if (outname != Nullch) {
X	free(outname);
X	outname = Nullch;
X    }
X
X    last_offset = 0;
X
X    diff_type = 0;
X
X    if (revision != Nullch) {
X	free(revision);
X	revision = Nullch;
X    }
X
X    reverse = FALSE;
X    skip_rest_of_patch = FALSE;
X
X    get_some_switches();
X
X    if (filec >= 2)
X	fatal1("You may not change to a different patch file.\n");
X}
X
X/* Process switches and filenames up to next '+' or end of list. */
X
Xvoid
Xget_some_switches()
X{
X    Reg1 char *s;
X
X    rejname[0] = '\0';
X    Argc_last = Argc;
X    Argv_last = Argv;
X    if (!Argc)
X	return;
X    for (Argc--,Argv++; Argc; Argc--,Argv++) {
X	s = Argv[0];
X	if (strEQ(s, "+")) {
X	    return;			/* + will be skipped by for loop */
X	}
X	if (*s != '-' || !s[1]) {
X	    if (filec == MAXFILEC)
X		fatal1("Too many file arguments.\n");
X	    filearg[filec++] = savestr(s);
X	}
X	else {
X	    switch (*++s) {
X	    case 'b':
X		origext = savestr(Argv[1]);
X		Argc--,Argv++;
X		break;
X	    case 'c':
X		diff_type = CONTEXT_DIFF;
X		break;
X	    case 'd':
X		if (!*++s) {
X		    Argc--,Argv++;
X		    s = Argv[0];
X		}
X		if (chdir(s) < 0)
X		    fatal2("Can't cd to %s.\n", s);
X		break;
X	    case 'D':
X	    	do_defines = TRUE;
X		if (!*++s) {
X		    Argc--,Argv++;
X		    s = Argv[0];
X		}
X		Sprintf(if_defined, "#ifdef %s\n", s);
X		Sprintf(not_defined, "#ifndef %s\n", s);
X		Sprintf(end_defined, "#endif /* %s */\n", s);
X		break;
X	    case 'e':
X		diff_type = ED_DIFF;
X		break;
X	    case 'f':
X		force = TRUE;
X		break;
X	    case 'F':
X		if (*++s == '=')
X		    s++;
X		maxfuzz = atoi(s);
X		break;
X	    case 'l':
X		canonicalize = TRUE;
X		break;
X	    case 'n':
X		diff_type = NORMAL_DIFF;
X		break;
X	    case 'N':
X		noreverse = TRUE;
X		break;
X	    case 'o':
X		outname = savestr(Argv[1]);
X		Argc--,Argv++;
X		break;
X	    case 'p':
X		if (*++s == '=')
X		    s++;
X		strippath = atoi(s);
X		break;
X	    case 'r':
X		Strcpy(rejname, Argv[1]);
X		Argc--,Argv++;
X		break;
X	    case 'R':
X		reverse = TRUE;
X		break;
X	    case 's':
X		verbose = FALSE;
X		break;
X	    case 'S':
X		skip_rest_of_patch = TRUE;
X		break;
X	    case 'v':
X		version();
X		break;
X#ifdef DEBUGGING
X	    case 'x':
X		debug = atoi(s+1);
X		break;
X#endif
X	    default:
X		fatal2("Unrecognized switch: %s\n", Argv[0]);
X	    }
X	}
X    }
X}
X
X/* Attempt to find the right place to apply this hunk of patch. */
X
XLINENUM
Xlocate_hunk(fuzz)
XLINENUM fuzz;
X{
X    Reg1 LINENUM first_guess = pch_first() + last_offset;
X    Reg2 LINENUM offset;
X    LINENUM pat_lines = pch_ptrn_lines();
X    Reg3 LINENUM max_pos_offset = input_lines - first_guess
X				- pat_lines + 1; 
X    Reg4 LINENUM max_neg_offset = first_guess - last_frozen_line - 1
X				+ pch_context();
X
X    if (!pat_lines)			/* null range matches always */
X	return first_guess;
X    if (max_neg_offset >= first_guess)	/* do not try lines < 0 */
X	max_neg_offset = first_guess - 1;
X    if (first_guess <= input_lines && patch_match(first_guess, Nulline, fuzz))
X	return first_guess;
X    for (offset = 1; ; offset++) {
X	Reg5 bool check_after = (offset <= max_pos_offset);
X	Reg6 bool check_before = (offset <= max_pos_offset);
X
X	if (check_after && patch_match(first_guess, offset, fuzz)) {
X#ifdef DEBUGGING
X	    if (debug & 1)
X		say3("Offset changing from %ld to %ld\n", last_offset, offset);
X#endif
X	    last_offset = offset;
X	    return first_guess+offset;
X	}
X	else if (check_before && patch_match(first_guess, -offset, fuzz)) {
X#ifdef DEBUGGING
X	    if (debug & 1)
X		say3("Offset changing from %ld to %ld\n", last_offset, -offset);
X#endif
X	    last_offset = -offset;
X	    return first_guess-offset;
X	}
X	else if (!check_before && !check_after)
X	    return Nulline;
X    }
X}
X
X/* We did not find the pattern, dump out the hunk so they can handle it. */
X
Xvoid
Xabort_hunk()
X{
X    Reg1 LINENUM i;
X    Reg2 LINENUM pat_end = pch_end();
X    /* add in last_offset to guess the same as the previous successful hunk */
X    LINENUM oldfirst = pch_first() + last_offset;
X    LINENUM newfirst = pch_newfirst() + last_offset;
X    LINENUM oldlast = oldfirst + pch_ptrn_lines() - 1;
X    LINENUM newlast = newfirst + pch_repl_lines() - 1;
X    char *stars = (diff_type == NEW_CONTEXT_DIFF ? " ****" : "");
X    char *minuses = (diff_type == NEW_CONTEXT_DIFF ? " ----" : " -----");
X
X    fprintf(rejfp, "***************\n");
X    for (i=0; i<=pat_end; i++) {
X	switch (pch_char(i)) {
X	case '*':
X	    if (oldlast < oldfirst)
X		fprintf(rejfp, "*** 0%s\n", stars);
X	    else if (oldlast == oldfirst)
X		fprintf(rejfp, "*** %ld%s\n", oldfirst, stars);
X	    else
X		fprintf(rejfp, "*** %ld,%ld%s\n", oldfirst, oldlast, stars);
X	    break;
X	case '=':
X	    if (newlast < newfirst)
X		fprintf(rejfp, "--- 0%s\n", minuses);
X	    else if (newlast == newfirst)
X		fprintf(rejfp, "--- %ld%s\n", newfirst, minuses);
X	    else
X		fprintf(rejfp, "--- %ld,%ld%s\n", newfirst, newlast, minuses);
X	    break;
X	case '\n':
X	    fprintf(rejfp, "%s", pfetch(i));
X	    break;
X	case ' ': case '-': case '+': case '!':
X	    fprintf(rejfp, "%c %s", pch_char(i), pfetch(i));
X	    break;
X	default:
X	    say1("Fatal internal error in abort_hunk().\n"); 
X	    abort();
X	}
X    }
X}
X
X/* We found where to apply it (we hope), so do it. */
X
Xvoid
Xapply_hunk(where)
XLINENUM where;
X{
X    Reg1 LINENUM old = 1;
X    Reg2 LINENUM lastline = pch_ptrn_lines();
X    Reg3 LINENUM new = lastline+1;
X#define OUTSIDE 0
X#define IN_IFNDEF 1
X#define IN_IFDEF 2
X#define IN_ELSE 3
X    Reg4 int def_state = OUTSIDE;
X    Reg5 bool R_do_defines = do_defines;
X
X    where--;
X    while (pch_char(new) == '=' || pch_char(new) == '\n')
X	new++;
X    
X    while (old <= lastline) {
X	if (pch_char(old) == '-') {
X	    copy_till(where + old - 1);
X	    if (R_do_defines) {
X		if (def_state == OUTSIDE) {
X		    fputs(not_defined, ofp);
X		    def_state = IN_IFNDEF;
X		}
X		else if (def_state == IN_IFDEF) {
X		    fputs(else_defined, ofp);
X		    def_state = IN_ELSE;
X		}
X		fputs(pfetch(old), ofp);
X	    }
X	    last_frozen_line++;
X	    old++;
X	}
X	else if (pch_char(new) == '+') {
X	    copy_till(where + old - 1);
X	    if (R_do_defines) {
X		if (def_state == IN_IFNDEF) {
X		    fputs(else_defined, ofp);
X		    def_state = IN_ELSE;
X		}
X		else if (def_state == OUTSIDE) {
X		    fputs(if_defined, ofp);
X		    def_state = IN_IFDEF;
X		}
X	    }
X	    fputs(pfetch(new), ofp);
X	    new++;
X	}
X	else {
X	    if (pch_char(new) != pch_char(old)) {
X		say3("Out-of-sync patch, lines %ld,%ld\n",
X		    pch_hunk_beg() + old - 1,
X		    pch_hunk_beg() + new - 1);
X#ifdef DEBUGGING
X		say3("oldchar = '%c', newchar = '%c'\n",
X		    pch_char(old), pch_char(new));
X#endif
X		my_exit(1);
X	    }
X	    if (pch_char(new) == '!') {
X		copy_till(where + old - 1);
X		if (R_do_defines) {
X		   fputs(not_defined, ofp);
X		   def_state = IN_IFNDEF;
X		}
X		while (pch_char(old) == '!') {
X		    if (R_do_defines) {
X			fputs(pfetch(old), ofp);
X		    }
X		    last_frozen_line++;
X		    old++;
X		}
X		if (R_do_defines) {
X		    fputs(else_defined, ofp);
X		    def_state = IN_ELSE;
X		}
X		while (pch_char(new) == '!') {
X		    fputs(pfetch(new), ofp);
X		    new++;
X		}
X		if (R_do_defines) {
X		    fputs(end_defined, ofp);
X		    def_state = OUTSIDE;
X		}
X	    }
X	    else {
X		assert(pch_char(new) == ' ');
X		old++;
X		new++;
X	    }
X	}
X    }
X    if (new <= pch_end() && pch_char(new) == '+') {
X	copy_till(where + old - 1);
X	if (R_do_defines) {
X	    if (def_state == OUTSIDE) {
X	    	fputs(if_defined, ofp);
X		def_state = IN_IFDEF;
X	    }
X	    else if (def_state == IN_IFNDEF) {
X		fputs(else_defined, ofp);
X		def_state = IN_ELSE;
X	    }
X	}
X	while (new <= pch_end() && pch_char(new) == '+') {
X	    fputs(pfetch(new), ofp);
X	    new++;
X	}
X    }
X    if (R_do_defines && def_state != OUTSIDE) {
X	fputs(end_defined, ofp);
X    }
X}
X
X/* Apply an ed script by feeding ed itself. */
X
Xvoid
Xdo_ed_script()
X{
X    Reg1 char *t;
X    Reg2 long beginning_of_this_line;
X    Reg3 bool this_line_is_command = FALSE;
X    Reg4 FILE *pipefp;
X    FILE *popen();
X
X    if (!skip_rest_of_patch) {
X	Unlink(TMPOUTNAME);
X	copy_file(filearg[0], TMPOUTNAME);
X	if (verbose)
X	    Sprintf(buf, "/bin/ed %s", TMPOUTNAME);
X	else
X	    Sprintf(buf, "/bin/ed - %s", TMPOUTNAME);
X	pipefp = popen(buf, "w");
X    }
X    for (;;) {
X	beginning_of_this_line = ftell(pfp);
X	if (pgets(buf, sizeof buf, pfp) == Nullch) {
X	    next_intuit_at(beginning_of_this_line);
X	    break;
X	}
X	for (t=buf; isdigit(*t) || *t == ','; t++) ;
X	this_line_is_command = (isdigit(*buf) &&
X	  (*t == 'd' || *t == 'c' || *t == 'a') );
X	if (this_line_is_command) {
X	    if (!skip_rest_of_patch)
X		fputs(buf, pipefp);
X	    if (*t != 'd') {
X		while (pgets(buf, sizeof buf, pfp) != Nullch) {
X		    if (!skip_rest_of_patch)
X			fputs(buf, pipefp);
X		    if (strEQ(buf, ".\n"))
X			break;
X		}
X	    }
X	}
X	else {
X	    next_intuit_at(beginning_of_this_line);
X	    break;
X	}
X    }
X    if (skip_rest_of_patch)
X	return;
X    fprintf(pipefp, "w\n");
X    fprintf(pipefp, "q\n");
X    Fflush(pipefp);
X    Pclose(pipefp);
X    ignore_signals();
X    if (move_file(TMPOUTNAME, outname) < 0) {
X	toutkeep = TRUE;
X	chmod(TMPOUTNAME, filemode);
X    }
X    else
X	chmod(outname, filemode);
X    set_signals();
X}
X
X/* Open the new file. */
X
Xvoid
Xinit_output(name)
Xchar *name;
X{
X    ofp = fopen(name, "w");
X    if (ofp == Nullfp)
X	fatal2("patch: can't create %s.\n", name);
X}
X
X/* Open a file to put hunks we can't locate. */
X
Xvoid
Xinit_reject(name)
Xchar *name;
X{
X    rejfp = fopen(name, "w");
X    if (rejfp == Nullfp)
X	fatal2("patch: can't create %s.\n", name);
X}
X
X/* Copy input file to output, up to wherever hunk is to be applied. */
X
Xvoid
Xcopy_till(lastline)
XReg1 LINENUM lastline;
X{
X    Reg2 LINENUM R_last_frozen_line = last_frozen_line;
X
X    if (R_last_frozen_line > lastline)
X	say1("patch: misordered hunks! output will be garbled.\n");
X    while (R_last_frozen_line < lastline) {
X	dump_line(++R_last_frozen_line);
X    }
X    last_frozen_line = R_last_frozen_line;
X}
X
X/* Finish copying the input file to the output file. */
X
Xvoid
Xspew_output()
X{
X#ifdef DEBUGGING
X    if (debug & 256)
X	say3("il=%ld lfl=%ld\n",input_lines,last_frozen_line);
X#endif
X    if (input_lines)
X	copy_till(input_lines);		/* dump remainder of file */
X    Fclose(ofp);
X    ofp = Nullfp;
X}
X
X/* Copy one line from input to output. */
X
Xvoid
Xdump_line(line)
XLINENUM line;
X{
X    Reg1 char *s;
X    Reg2 char R_newline = '\n';
X
X    /* Note: string is not null terminated. */
X    for (s=ifetch(line, 0); putc(*s, ofp) != R_newline; s++) ;
X}
X
X/* Does the patch pattern match at line base+offset? */
X
Xbool
Xpatch_match(base, offset, fuzz)
XLINENUM base;
XLINENUM offset;
XLINENUM fuzz;
X{
X    Reg1 LINENUM pline = 1 + fuzz;
X    Reg2 LINENUM iline;
X    Reg3 LINENUM pat_lines = pch_ptrn_lines() - fuzz;
X
X    for (iline=base+offset; pline <= pat_lines; pline++,iline++) {
X	if (canonicalize) {
X	    if (!similar(ifetch(iline, (offset >= 0)),
X			 pfetch(pline),
X			 pch_line_len(pline) ))
X		return FALSE;
X	}
X	else if (strnNE(ifetch(iline, (offset >= 0)),
X		   pfetch(pline),
X		   pch_line_len(pline) ))
X	    return FALSE;
X    }
X    return TRUE;
X}
X
X/* Do two lines match with canonicalized white space? */
X
Xbool
Xsimilar(a,b,len)
XReg1 char *a;
XReg2 char *b;
XReg3 int len;
X{
X    while (len) {
X	if (isspace(*b)) {		/* whitespace (or \n) to match? */
X	    if (!isspace(*a))		/* no corresponding whitespace? */
X		return FALSE;
X	    while (len && isspace(*b) && *b != '\n')
X		b++,len--;		/* skip pattern whitespace */
X	    while (isspace(*a) && *a != '\n')
X		a++;			/* skip target whitespace */
X	    if (*a == '\n' || *b == '\n')
X		return (*a == *b);	/* should end in sync */
X	}
X	else if (*a++ != *b++)		/* match non-whitespace chars */
X	    return FALSE;
X	else
X	    len--;			/* probably not necessary */
X    }
X    return TRUE;			/* actually, this is not reached */
X					/* since there is always a \n */
X}
X
X/* Exit with cleanup. */
X
Xvoid
Xmy_exit(status)
Xint status;
X{
X    Unlink(TMPINNAME);
X    if (!toutkeep) {
X	Unlink(TMPOUTNAME);
X    }
X    if (!trejkeep) {
X	Unlink(TMPREJNAME);
X    }
X    Unlink(TMPPATNAME);
X    exit(status);
X}
!STUFFY!FUNK!
echo Extracting patch.man
sed >patch.man <<'!STUFFY!FUNK!' -e 's/X//'
X''' $Header: patch.man,v 2.0 86/09/17 15:39:09 lwall Exp $
X''' 
X''' $Log:	patch.man,v $
X''' Revision 2.0  86/09/17  15:39:09  lwall
X''' Baseline for netwide release.
X''' 
X''' Revision 1.4  86/08/01  19:23:22  lwall
X''' Documented -v, -p, -F.
X''' Added notes to patch senders.
X''' 
X''' Revision 1.3  85/03/26  15:11:06  lwall
X''' Frozen.
X''' 
X''' Revision 1.2.1.4  85/03/12  16:14:27  lwall
X''' Documented -p.
X''' 
X''' Revision 1.2.1.3  85/03/12  16:09:41  lwall
X''' Documented -D.
X''' 
X''' Revision 1.2.1.2  84/12/05  11:06:55  lwall
X''' Added -l switch, and noted bistability bug.
X''' 
X''' Revision 1.2.1.1  84/12/04  17:23:39  lwall
X''' Branch for sdcrdcf changes.
X''' 
X''' Revision 1.2  84/12/04  17:22:02  lwall
X''' Baseline version.
X''' 
X.de Sh
X.br
X.ne 5
X.PP
X\fB\\$1\fR
X.PP
X..
X.de Sp
X.if t .sp .5v
X.if n .sp
X..
X'''
X'''     Set up \*(-- to give an unbreakable dash;
X'''     string Tr holds user defined translation string.
X'''     Bell System Logo is used as a dummy character.
X'''
X.ie n \{\
X.tr \(bs-\*(Tr
X.ds -- \(bs-
X.if (\n(.H=4u)&(1m=24u) .ds -- \(bs\h'-12u'\(bs\h'-12u'-\" diablo 10 pitch
X.if (\n(.H=4u)&(1m=20u) .ds -- \(bs\h'-12u'\(bs\h'-8u'-\" diablo 12 pitch
X.ds L" ""
X.ds R" ""
X.ds L' '
X.ds R' '
X'br\}
X.el\{\
X.ds -- \(em\|
X.tr \*(Tr
X.ds L" ``
X.ds R" ''
X.ds L' `
X.ds R' '
X'br\}
X.TH PATCH 1 LOCAL
X.SH NAME
Xpatch - a program for applying a diff file to an original
X.SH SYNOPSIS
X.B patch
X[options] orig patchfile [+ [options] orig]
X.sp
Xbut usually just
X.sp
X.B patch
X<patchfile
X.SH DESCRIPTION
X.I Patch
Xwill take a patch file containing any of the three forms of difference
Xlisting produced by the
X.I diff
Xprogram and apply those differences to an original file, producing a patched
Xversion.
XBy default, the patched version is put in place of the original, with
Xthe original file backed up to the same name with the
Xextension \*(L".orig\*(R", or as specified by the
X.B -b
Xswitch.
XYou may also specify where you want the output to go with a
X.B -o
Xswitch.
XIf
X.I patchfile
Xis omitted, or is a hyphen, the patch will be read from standard input.
X.PP
XUpon startup, patch will attempt to determine the type of the diff listing,
Xunless over-ruled by a
X.BR -c ,
X.BR -e ,
Xor
X.B -n
Xswitch.
XContext diffs and normal diffs are applied by the
X.I patch
Xprogram itself, while ed diffs are simply fed to the
X.I ed
Xeditor via a pipe.
X.PP
X.I Patch
Xwill try to skip any leading garbage, apply the diff,
Xand then skip any trailing garbage.
XThus you could feed an article or message containing a
Xdiff listing to
X.IR patch ,
Xand it should work.
XIf the entire diff is indented by a consistent amount,
Xthis will be taken into account.
X.PP
XWith context diffs, and to a lesser extent with normal diffs,
X.I patch
Xcan detect when the line numbers mentioned in the patch are incorrect,
Xand will attempt to find the correct place to apply each hunk of the patch.
XAs a first guess, it takes the line number mentioned for the hunk, plus or
Xminus any offset used in applying the previous hunk.
XIf that is not the correct place,
X.I patch
Xwill scan both forwards and backwards for a set of lines matching the context
Xgiven in the hunk.
XFirst
X.I patch
Xlooks for a place where all lines of the context match.
XIf no such place is found, and it's a context diff, and the maximum fuzz factor
Xis set to 1 or more, then another scan takes place ignoring the first and last
Xline of context.
XIf that fails, and the maximum fuzz factor is set to 2 or more,
Xthe first two and last two lines of context are ignored,
Xand another scan is made.
X(The default maximum fuzz factor is 2.)
XIf
X.I patch
Xcannot find a place to install that hunk of the patch, it will put the
Xhunk out to a reject file, which normally is the name of the output file
Xplus \*(L".rej\*(R".
X(Note that the rejected hunk will come out in context diff form whether the
Xinput patch was a context diff or a normal diff.
XIf the input was a normal diff, many of the contexts will simply be null.)
XThe line numbers on the hunks in the reject file may be different than
Xin the patch file: they reflect the approximate location patch thinks the
Xfailed hunks belong in the new file rather than the old one.
X.PP
XAs each hunk is completed, you will be told whether the hunk succeeded or
Xfailed, and which line (in the new file)
X.I patch
Xthought the hunk should go on.
XIf this is different from the line number specified in the diff you will
Xbe told the offset.
XA single large offset MAY be an indication that a hunk was installed in the
Xwrong place.
XYou will also be told if a fuzz factor was used to make the match, in which
Xcase you should also be slightly suspicious.
X.PP
XIf no original file is specified on the command line,
X.I patch
Xwill try to figure out from the leading garbage what the name of the file
Xto edit is.
XIn the header of a context diff, the filename is found from lines beginning
Xwith \*(L"***\*(R" or \*(L"---\*(R", with the shortest name of an existing
Xfile winning.
XOnly context diffs have lines like that, but if there is an \*(L"Index:\*(R"
Xline in the leading garbage,
X.I patch
Xwill try to use the filename from that line.
XThe context diff header takes precedence over an Index line.
XIf no filename can be intuited from the leading garbage, you will be asked
Xfor the name of the file to patch.
X.PP
X(If the original file cannot be found, but a suitable SCCS or RCS file is
Xhandy,
X.I patch
Xwill attempt to get or check out the file.)
X.PP
XAdditionally, if the leading garbage contains a \*(L"Prereq: \*(R" line,
X.I patch
Xwill take the first word from the prerequisites line (normally a version
Xnumber) and check the input file to see if that word can be found.
XIf not,
X.I patch
Xwill ask for confirmation before proceeding.
X.PP
XThe upshot of all this is that you should be able to say, while in a news
Xinterface, the following:
X.Sp
X	| patch -d /usr/src/local/blurfl
X.Sp
Xand patch a file in the blurfl directory directly from the article containing
Xthe patch.
X.PP
XIf the patch file contains more than one patch,
X.I patch
Xwill try to apply each of them as if they came from separate patch files.
XThis means, among other things, that it is assumed that the name of the file
Xto patch must be determined for each diff listing,
Xand that the garbage before each diff listing will
Xbe examined for interesting things such as filenames and revision level, as
Xmentioned previously.
XYou can give switches (and another original file name) for the second and
Xsubsequent patches by separating the corresponding argument lists
Xby a \*(L'+\*(R'.
X(The argument list for a second or subsequent patch may not specify a new
Xpatch file, however.)
X.PP
X.I Patch
Xrecognizes the following switches:
X.TP 5
X.B \-b
Xcauses the next argument to be interpreted as the backup extension, to be
Xused in place of \*(L".orig\*(R".
X.TP 5
X.B \-c
Xforces
X.I patch
Xto interpret the patch file as a context diff.
X.TP 5
X.B \-d
Xcauses
X.I patch
Xto interpret the next argument as a directory, and cd to it before doing
Xanything else.
X.TP 5
X.B \-D
Xcauses
X.I patch
Xto use the "#ifdef...#endif" construct to mark changes.
XThe argument following will be used as the differentiating symbol.
XNote that, unlike the C compiler, there must be a space between the
X.B \-D
Xand the argument.
X.TP 5
X.B \-e
Xforces
X.I patch
Xto interpret the patch file as an ed script.
X.TP 5
X.B \-f
Xforces
X.I patch
Xto assume that the user knows exactly what he or she is doing, and to not
Xask any questions.
XIt does not suppress commentary, however.
XUse
X.B \-s
Xfor that.
X.TP 5
X.B \-F<number>
Xsets the maximum fuzz factor.
XThis switch only applied to context diffs, and causes
X.I patch
Xto ignore up to that many lines in looking for places to install a hunk.
XNote that a larger fuzz factor increases the odds of a faulty patch.
XThe default fuzz factor is 2, and it may not be set to more than
Xthe number of lines of context in the context diff, ordinarily 3.
X.TP 5
X.B \-l
Xcauses the pattern matching to be done loosely, in case the tabs and
Xspaces have been munged in your input file.
XAny sequence of whitespace in the pattern line will match any sequence
Xin the input file.
XNormal characters must still match exactly.
XEach line of the context must still match a line in the input file.
X.TP 5
X.B \-n
Xforces
X.I patch
Xto interpret the patch file as a normal diff.
X.TP 5
X.B \-N
Xcauses
X.I patch
Xto ignore patches that it thinks are reversed or already applied.
XSee also
X.B \-R .
X.TP 5
X.B \-o
Xcauses the next argument to be interpreted as the output file name.
X.TP 5
X.B \-p<number>
Xsets the pathname strip count,
Xwhich controls how pathnames found in the patch file are treated, in case
Xthe you keep your files in a different directory than the person who sent
Xout the patch.
XThe strip count specifies how many backslashes are to be stripped from
Xthe front of the pathname.
X(Any intervening directory names also go away.)
XFor example, supposing the filename in the patch file was
X.sp
X	/u/howard/src/blurfl/blurfl.c
X.sp
Xsetting
X.B \-p
Xor
X.B \-p0
Xgives the entire pathname unmodified,
X.B \-p1
Xgives
X.sp
X	u/howard/src/blurfl/blurfl.c
X.sp
Xwithout the leading slash,
X.B \-p4
Xgives
X.sp
X	blurfl/blurfl.c
X.sp
Xand not specifying
X.B \-p
Xat all just gives you "blurfl.c".
XWhatever you end up with is looked for either in the current directory,
Xor the directory specified by the
X.B \-d
Xswitch.
X.TP 5
X.B \-r
Xcauses the next argument to be interpreted as the reject file name.
X.TP 5
X.B \-R
Xtells
X.I patch
Xthat this patch was created with the old and new files swapped.
X(Yes, I'm afraid that does happen occasionally, human nature being what it
Xis.)
X.I Patch
Xwill attempt to swap each hunk around before applying it.
XRejects will come out in the swapped format.
XThe
X.B \-R
Xswitch will not work with ed diff scripts because there is too little
Xinformation to reconstruct the reverse operation.
X.Sp
XIf the first hunk of a patch fails,
X.I patch
Xwill reverse the hunk to see if it can be applied that way.
XIf it can, you will be asked if you want to have the
X.B \-R
Xswitch set.
XIf it can't, the patch will continue to be applied normally.
X(Note: this method cannot detect a reversed patch if it is a normal diff
Xand if the first command is an append (i.e. it should have been a delete)
Xsince appends always succeed, due to the fact that a null context will match
Xanywhere.
XLuckily, most patches add or change lines rather than delete them, so most
Xreversed normal diffs will begin with a delete, which will fail, triggering
Xthe heuristic.)
X.TP 5
X.B \-s
Xmakes
X.I patch
Xdo its work silently, unless an error occurs.
X.TP 5
X.B \-S
Xcauses
X.I patch
Xto ignore this patch from the patch file, but continue on looking
Xfor the next patch in the file.
XThus
X.sp
X	patch -S + -S + <patchfile
X.sp
Xwill ignore the first and second of three patches.
X.TP 5
X.B \-v
Xcauses
X.I patch
Xto print out it's revision header and patch level.
X.TP 5
X.B \-x<number>
Xsets internal debugging flags, and is of interest only to
X.I patch
Xpatchers.
X.SH ENVIRONMENT
XNo environment variables are used by
X.IR patch .
X.SH FILES
X/tmp/patch*
X.SH SEE ALSO
Xdiff(1)
X.SH NOTES FOR PATCH SENDERS
XThere are several things you should bear in mind if you are going to
Xbe sending out patches.
XFirst, you can save people a lot of grief by keeping a patchlevel.h file
Xwhich is patched to increment the patch level as the first diff in the
Xpatch file you send out.
XIf you put a Prereq: line in with the patch, it won't let them apply
Xpatches out of order without some warning.
XSecond, make sure you've specified the filenames right, either in a
Xcontext diff header, or with an Index: line.
XIf you are patching something in a subdirectory, be sure to tell the patch
Xuser to specify a 
X.B \-p
Xswitch as needed.
XThird, you can create a file by sending out a diff that compares a
Xnull file to the file you want to create.
XThis will only work if the file you want to create doesn't exist already in
Xthe target directory.
XFourth, take care not to send out reversed patches, since it makes people wonder
Xwhether they already applied the patch.
XFifth, while you may be able to get away with putting 582 diff listings into
Xone file, it is probably wiser to group related patches into separate files in
Xcase something goes haywire.
X.SH DIAGNOSTICS
XToo many to list here, but generally indicative that
X.I patch
Xcouldn't parse your patch file.
X.PP
XThe message \*(L"Hmm...\*(R" indicates that there is unprocessed text in
Xthe patch file and that
X.I patch
Xis attempting to intuit whether there is a patch in that text and, if so,
Xwhat kind of patch it is.
X.SH CAVEATS
X.I Patch
Xcannot tell if the line numbers are off in an ed script, and can only detect
Xbad line numbers in a normal diff when it finds a \*(L"change\*(R" or
Xa \*(L"delete\*(R" command.
XA context diff using fuzz factor 3 may have the same problem.
XUntil a suitable interactive interface is added, you should probably do
Xa context diff in these cases to see if the changes made sense.
XOf course, compiling without errors is a pretty good indication that the patch
Xworked, but not always.
X.PP
X.I Patch
Xusually produces the correct results, even when it has to do a lot of
Xguessing.
XHowever, the results are guaranteed to be correct only when the patch is
Xapplied to exactly the same version of the file that the patch was
Xgenerated from.
X.SH BUGS
XCould be smarter about partial matches, excessively \&deviant offsets and
Xswapped code, but that would take an extra pass.
X.PP
XIf code has been duplicated (for instance with #ifdef OLDCODE ... #else ...
X#endif),
X.I patch
Xis incapable of patching both versions, and, if it works at all, will likely
Xpatch the wrong one, and tell you that it succeeded to boot.
X.PP
XIf you apply a patch you've already applied,
X.I patch
Xwill think it is a reversed patch, and offer to un-apply the patch.
XThis could be construed as a feature.
!STUFFY!FUNK!
echo Extracting inp.c
sed >inp.c <<'!STUFFY!FUNK!' -e 's/X//'
X/* $Header: inp.c,v 2.0 86/09/17 15:37:02 lwall Exp $
X *
X * $Log:	inp.c,v $
X * Revision 2.0  86/09/17  15:37:02  lwall
X * Baseline for netwide release.
X * 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "util.h"
X#include "pch.h"
X#include "INTERN.h"
X#include "inp.h"
X
X/* Input-file-with-indexable-lines abstract type */
X
Xstatic long i_size;			/* size of the input file */
Xstatic char *i_womp;			/* plan a buffer for entire file */
Xstatic char **i_ptr;			/* pointers to lines in i_womp */
X
Xstatic int tifd = -1;			/* plan b virtual string array */
Xstatic char *tibuf[2];			/* plan b buffers */
Xstatic LINENUM tiline[2] = {-1, -1};	/* 1st line in each buffer */
Xstatic LINENUM lines_per_buf;		/* how many lines per buffer */
Xstatic int tireclen;			/* length of records in tmp file */
X
X/* New patch--prepare to edit another file. */
X
Xvoid
Xre_input()
X{
X    if (using_plan_a) {
X	i_size = 0;
X#ifndef lint
X	if (i_ptr != Null(char**))
X	    free((char *)i_ptr);
X#endif
X	if (i_womp != Nullch)
X	    free(i_womp);
X	i_womp = Nullch;
X	i_ptr = Null(char **);
X    }
X    else {
X	using_plan_a = TRUE;		/* maybe the next one is smaller */
X	Close(tifd);
X	tifd = -1;
X	free(tibuf[0]);
X	free(tibuf[1]);
X	tibuf[0] = tibuf[1] = Nullch;
X	tiline[0] = tiline[1] = -1;
X	tireclen = 0;
X    }
X}
X
X/* Constuct the line index, somehow or other. */
X
Xvoid
Xscan_input(filename)
Xchar *filename;
X{
X    if (!plan_a(filename))
X	plan_b(filename);
X    if (verbose) {
X	say3("Patching file %s using Plan %s...\n", filename,
X	  (using_plan_a ? "A" : "B") );
X    }
X}
X
X/* Try keeping everything in memory. */
X
Xbool
Xplan_a(filename)
Xchar *filename;
X{
X    int ifd;
X    Reg1 char *s;
X    Reg2 LINENUM iline;
X
X    if (ok_to_create_file && stat(filename, &filestat) < 0) {
X	if (verbose)
X	    say2("(Creating file %s...)\n",filename);
X	makedirs(filename, TRUE);
X	close(creat(filename, 0666));
X    }
X    if (stat(filename, &filestat) < 0) {
X	Sprintf(buf, "RCS/%s%s", filename, RCSSUFFIX);
X	if (stat(buf, &filestat) >= 0 || stat(buf+4, &filestat) >= 0) {
X	    Sprintf(buf, CHECKOUT, filename);
X	    if (verbose)
X		say2("Can't find %s--attempting to check it out from RCS.\n",
X		    filename);
X	    if (system(buf) || stat(filename, &filestat))
X		fatal2("Can't check out %s.\n", filename);
X	}
X	else {
X	    Sprintf(buf, "SCCS/%s%s", SCCSPREFIX, filename);
X	    if (stat(buf, &filestat) >= 0 || stat(buf+5, &filestat) >= 0) {
X		Sprintf(buf, GET, filename);
X		if (verbose)
X		    say2("Can't find %s--attempting to get it from SCCS.\n",
X			filename);
X		if (system(buf) || stat(filename, &filestat))
X		    fatal2("Can't get %s.\n", filename);
X	    }
X	    else
X		fatal2("Can't find %s.\n", filename);
X	}
X    }
X    filemode = filestat.st_mode;
X    if ((filemode & S_IFMT) & ~S_IFREG)
X	fatal2("%s is not a normal file--can't patch.\n", filename);
X    i_size = filestat.st_size;
X    if (out_of_mem) {
X	set_hunkmax();		/* make sure dynamic arrays are allocated */
X	out_of_mem = FALSE;
X	return FALSE;			/* force plan b because plan a bombed */
X    }
X#ifdef lint
X    i_womp = Nullch;
X#else
X    i_womp = malloc((MEM)(i_size+2));	/* lint says this may alloc less than */
X					/* i_size, but that's okay, I think. */
X#endif
X    if (i_womp == Nullch)
X	return FALSE;
X    if ((ifd = open(filename, 0)) < 0)
X	fatal2("Can't open file %s\n", filename);
X#ifndef lint
X    if (read(ifd, i_womp, (int)i_size) != i_size) {
X	Close(ifd);	/* probably means i_size > 15 or 16 bits worth */
X	free(i_womp);	/* at this point it doesn't matter if i_womp was */
X	return FALSE;	/*   undersized. */
X    }
X#endif
X    Close(ifd);
X    if (i_size && i_womp[i_size-1] != '\n')
X	i_womp[i_size++] = '\n';
X    i_womp[i_size] = '\0';
X
X    /* count the lines in the buffer so we know how many pointers we need */
X
X    iline = 0;
X    for (s=i_womp; *s; s++) {
X	if (*s == '\n')
X	    iline++;
X    }
X#ifdef lint
X    i_ptr = Null(char**);
X#else
X    i_ptr = (char **)malloc((MEM)((iline + 2) * sizeof(char *)));
X#endif
X    if (i_ptr == Null(char **)) {	/* shucks, it was a near thing */
X	free((char *)i_womp);
X	return FALSE;
X    }
X    
X    /* now scan the buffer and build pointer array */
X
X    iline = 1;
X    i_ptr[iline] = i_womp;
X    for (s=i_womp; *s; s++) {
X	if (*s == '\n')
X	    i_ptr[++iline] = s+1;	/* these are NOT null terminated */
X    }
X    input_lines = iline - 1;
X
X    /* now check for revision, if any */
X
X    if (revision != Nullch) { 
X	if (!rev_in_string(i_womp)) {
X	    if (force) {
X		if (verbose)
X		    say2("\
XWarning: this file doesn't appear to be the %s version--patching anyway.\n",
X			revision);
X	    }
X	    else {
X		ask2("\
XThis file doesn't appear to be the %s version--patch anyway? [n] ",
X		    revision);
X	    if (*buf != 'y')
X		fatal1("Aborted.\n");
X	    }
X	}
X	else if (verbose)
X	    say2("Good.  This file appears to be the %s version.\n",
X		revision);
X    }
X    return TRUE;			/* plan a will work */
X}
X
X/* Keep (virtually) nothing in memory. */
X
Xvoid
Xplan_b(filename)
Xchar *filename;
X{
X    Reg3 FILE *ifp;
X    Reg1 int i = 0;
X    Reg2 int maxlen = 1;
X    Reg4 bool found_revision = (revision == Nullch);
X
X    using_plan_a = FALSE;
X    if ((ifp = fopen(filename, "r")) == Nullfp)
X	fatal2("Can't open file %s\n", filename);
X    if ((tifd = creat(TMPINNAME, 0666)) < 0)
X	fatal2("Can't open file %s\n", TMPINNAME);
X    while (fgets(buf, sizeof buf, ifp) != Nullch) {
X	if (revision != Nullch && !found_revision && rev_in_string(buf))
X	    found_revision = TRUE;
X	if ((i = strlen(buf)) > maxlen)
X	    maxlen = i;			/* find longest line */
X    }
X    if (revision != Nullch) {
X	if (!found_revision) {
X	    if (force) {
X		if (verbose)
X		    say2("\
XWarning: this file doesn't appear to be the %s version--patching anyway.\n",
X			revision);
X	    }
X	    else {
X		ask2("\
XThis file doesn't appear to be the %s version--patch anyway? [n] ",
X		    revision);
X		if (*buf != 'y')
X		    fatal1("Aborted.\n");
X	    }
X	}
X	else if (verbose)
X	    say2("Good.  This file appears to be the %s version.\n",
X		revision);
X    }
X    Fseek(ifp, 0L, 0);		/* rewind file */
X    lines_per_buf = BUFFERSIZE / maxlen;
X    tireclen = maxlen;
X    tibuf[0] = malloc((MEM)(BUFFERSIZE + 1));
X    tibuf[1] = malloc((MEM)(BUFFERSIZE + 1));
X    if (tibuf[1] == Nullch)
X	fatal1("Can't seem to get enough memory.\n");
X    for (i=1; ; i++) {
X	if (! (i % lines_per_buf))	/* new block */
X	    if (write(tifd, tibuf[0], BUFFERSIZE) < BUFFERSIZE)
X		fatal1("patch: can't write temp file.\n");
X	if (fgets(tibuf[0] + maxlen * (i%lines_per_buf), maxlen + 1, ifp)
X	  == Nullch) {
X	    input_lines = i - 1;
X	    if (i % lines_per_buf)
X		if (write(tifd, tibuf[0], BUFFERSIZE) < BUFFERSIZE)
X		    fatal1("patch: can't write temp file.\n");
X	    break;
X	}
X    }
X    Fclose(ifp);
X    Close(tifd);
X    if ((tifd = open(TMPINNAME, 0)) < 0) {
X	fatal2("Can't reopen file %s\n", TMPINNAME);
X    }
X}
X
X/* Fetch a line from the input file, \n terminated, not necessarily \0. */
X
Xchar *
Xifetch(line,whichbuf)
XReg1 LINENUM line;
Xint whichbuf;				/* ignored when file in memory */
X{
X    if (line < 1 || line > input_lines)
X	return "";
X    if (using_plan_a)
X	return i_ptr[line];
X    else {
X	LINENUM offline = line % lines_per_buf;
X	LINENUM baseline = line - offline;
X
X	if (tiline[0] == baseline)
X	    whichbuf = 0;
X	else if (tiline[1] == baseline)
X	    whichbuf = 1;
X	else {
X	    tiline[whichbuf] = baseline;
X#ifndef lint		/* complains of long accuracy */
X	    Lseek(tifd, (long)baseline / lines_per_buf * BUFFERSIZE, 0);
X#endif
X	    if (read(tifd, tibuf[whichbuf], BUFFERSIZE) < 0)
X		fatal2("Error reading tmp file %s.\n", TMPINNAME);
X	}
X	return tibuf[whichbuf] + (tireclen*offline);
X    }
X}
X
X/* True if the string argument contains the revision number we want. */
X
Xbool
Xrev_in_string(string)
Xchar *string;
X{
X    Reg1 char *s;
X    Reg2 int patlen;
X
X    if (revision == Nullch)
X	return TRUE;
X    patlen = strlen(revision);
X    for (s = string; *s; s++) {
X	if (isspace(*s) && strnEQ(s+1, revision, patlen) && 
X		isspace(s[patlen+1] )) {
X	    return TRUE;
X	}
X    }
X    return FALSE;
X}
X
!STUFFY!FUNK!
echo Extracting util.c
sed >util.c <<'!STUFFY!FUNK!' -e 's/X//'
X#include "EXTERN.h"
X#include "common.h"
X#include "INTERN.h"
X#include "util.h"
X
X/* Rename a file, copying it if necessary. */
X
Xint
Xmove_file(from,to)
Xchar *from, *to;
X{
X    char bakname[512];
X    Reg1 char *s;
X    Reg2 int i;
X    Reg3 int fromfd;
X
X    /* to stdout? */
X
X    if (strEQ(to, "-")) {
X#ifdef DEBUGGING
X	if (debug & 4)
X	    say2("Moving %s to stdout.\n", from);
X#endif
X	fromfd = open(from, 0);
X	if (fromfd < 0)
X	    fatal2("patch: internal error, can't reopen %s\n", from);
X	while ((i=read(fromfd, buf, sizeof buf)) > 0)
X	    if (write(1, buf, i) != 1)
X		fatal1("patch: write failed\n");
X	Close(fromfd);
X	return 0;
X    }
X
X    Strcpy(bakname, to);
X    Strcat(bakname, origext?origext:ORIGEXT);
X    if (stat(to, &filestat) >= 0) {	/* output file exists */
X	dev_t to_device = filestat.st_dev;
X	ino_t to_inode  = filestat.st_ino;
X	char *simplename = bakname;
X	
X	for (s=bakname; *s; s++) {
X	    if (*s == '/')
X		simplename = s+1;
X	}
X	/* find a backup name that is not the same file */
X	while (stat(bakname, &filestat) >= 0 &&
X		to_device == filestat.st_dev && to_inode == filestat.st_ino) {
X	    for (s=simplename; *s && !islower(*s); s++) ;
X	    if (*s)
X		*s = toupper(*s);
X	    else
X		Strcpy(simplename, simplename+1);
X	}
X	while (unlink(bakname) >= 0) ;	/* while() is for benefit of Eunice */
X#ifdef DEBUGGING
X	if (debug & 4)
X	    say3("Moving %s to %s.\n", to, bakname);
X#endif
X	if (link(to, bakname) < 0) {
X	    say3("patch: can't backup %s, output is in %s\n",
X		to, from);
X	    return -1;
X	}
X	while (unlink(to) >= 0) ;
X    }
X#ifdef DEBUGGING
X    if (debug & 4)
X	say3("Moving %s to %s.\n", from, to);
X#endif
X    if (link(from, to) < 0) {		/* different file system? */
X	Reg4 int tofd;
X	
X	tofd = creat(to, 0666);
X	if (tofd < 0) {
X	    say3("patch: can't create %s, output is in %s.\n",
X	      to, from);
X	    return -1;
X	}
X	fromfd = open(from, 0);
X	if (fromfd < 0)
X	    fatal2("patch: internal error, can't reopen %s\n", from);
X	while ((i=read(fromfd, buf, sizeof buf)) > 0)
X	    if (write(tofd, buf, i) != i)
X		fatal1("patch: write failed\n");
X	Close(fromfd);
X	Close(tofd);
X    }
X    Unlink(from);
X    return 0;
X}
X
X/* Copy a file. */
X
Xvoid
Xcopy_file(from,to)
Xchar *from, *to;
X{
X    Reg3 int tofd;
X    Reg2 int fromfd;
X    Reg1 int i;
X    
X    tofd = creat(to, 0666);
X    if (tofd < 0)
X	fatal2("patch: can't create %s.\n", to);
X    fromfd = open(from, 0);
X    if (fromfd < 0)
X	fatal2("patch: internal error, can't reopen %s\n", from);
X    while ((i=read(fromfd, buf, sizeof buf)) > 0)
X	if (write(tofd, buf, i) != i)
X	    fatal2("patch: write (%s) failed\n", to);
X    Close(fromfd);
X    Close(tofd);
X}
X
X/* Allocate a unique area for a string. */
X
Xchar *
Xsavestr(s)
XReg1 char *s;
X{
X    Reg3 char *rv;
X    Reg2 char *t;
X
X    if (!s)
X	s = "Oops";
X    t = s;
X    while (*t++);
X    rv = malloc((MEM) (t - s));
X    if (rv == Nullch) {
X	if (using_plan_a)
X	    out_of_mem = TRUE;
X	else
X	    fatal1("patch: out of memory (savestr)\n");
X    }
X    else {
X	t = rv;
X	while (*t++ = *s++);
X    }
X    return rv;
X}
X
X#if defined(lint) && defined(CANVARARG)
X
X/*VARARGS ARGSUSED*/
Xsay(pat) char *pat; { ; }
X/*VARARGS ARGSUSED*/
Xfatal(pat) char *pat; { ; }
X/*VARARGS ARGSUSED*/
Xask(pat) char *pat; { ; }
X
X#else
X
X/* Vanilla terminal output (buffered). */
X
Xvoid
Xsay(pat,arg1,arg2,arg3)
Xchar *pat;
Xint arg1,arg2,arg3;
X{
X    fprintf(stderr, pat, arg1, arg2, arg3);
X    Fflush(stderr);
X}
X
X/* Terminal output, pun intended. */
X
Xvoid				/* very void */
Xfatal(pat,arg1,arg2,arg3)
Xchar *pat;
Xint arg1,arg2,arg3;
X{
X    void my_exit();
X
X    say(pat, arg1, arg2, arg3);
X    my_exit(1);
X}
X
X/* Get a response from the user, somehow or other. */
X
Xvoid
Xask(pat,arg1,arg2,arg3)
Xchar *pat;
Xint arg1,arg2,arg3;
X{
X    int ttyfd;
X    int r;
X    bool tty2 = isatty(2);
X
X    Sprintf(buf, pat, arg1, arg2, arg3);
X    Fflush(stderr);
X    write(2, buf, strlen(buf));
X    if (tty2) {				/* might be redirected to a file */
X	r = read(2, buf, sizeof buf);
X    }
X    else if (isatty(1)) {		/* this may be new file output */
X	Fflush(stdout);
X	write(1, buf, strlen(buf));
X	r = read(1, buf, sizeof buf);
X    }
X    else if ((ttyfd = open("/dev/tty", 2)) >= 0 && isatty(ttyfd)) {
X					/* might be deleted or unwriteable */
X	write(ttyfd, buf, strlen(buf));
X	r = read(ttyfd, buf, sizeof buf);
X	Close(ttyfd);
X    }
X    else if (isatty(0)) {		/* this is probably patch input */
X	Fflush(stdin);
X	write(0, buf, strlen(buf));
X	r = read(0, buf, sizeof buf);
X    }
X    else {				/* no terminal at all--default it */
X	buf[0] = '\n';
X	r = 1;
X    }
X    if (r <= 0)
X	buf[0] = 0;
X    else
X	buf[r] = '\0';
X    if (!tty2)
X	say1(buf);
X}
X#endif lint
X
X/* How to handle certain events when not in a critical region. */
X
Xvoid
Xset_signals()
X{
X    void my_exit();
X
X#ifndef lint
X    if (signal(SIGHUP, SIG_IGN) != SIG_IGN)
X	Signal(SIGHUP, my_exit);
X    if (signal(SIGINT, SIG_IGN) != SIG_IGN)
X	Signal(SIGINT, my_exit);
X#endif
X}
X
X/* How to handle certain events when in a critical region. */
X
Xvoid
Xignore_signals()
X{
X#ifndef lint
X    Signal(SIGHUP, SIG_IGN);
X    Signal(SIGINT, SIG_IGN);
X#endif
X}
X
X/* Make sure we'll have the directories to create a file. */
X
Xvoid
Xmakedirs(filename,striplast)
XReg1 char *filename;
Xbool striplast;
X{
X    char tmpbuf[256];
X    Reg2 char *s = tmpbuf;
X    char *dirv[20];
X    Reg3 int i;
X    Reg4 int dirvp = 0;
X
X    while (*filename) {
X	if (*filename == '/') {
X	    filename++;
X	    dirv[dirvp++] = s;
X	    *s++ = '\0';
X	}
X	else {
X	    *s++ = *filename++;
X	}
X    }
X    *s = '\0';
X    dirv[dirvp] = s;
X    if (striplast)
X	dirvp--;
X    if (dirvp < 0)
X	return;
X    strcpy(buf, "mkdir");
X    s = buf;
X    for (i=0; i<=dirvp; i++) {
X	while (*s) s++;
X	*s++ = ' ';
X	strcpy(s, tmpbuf);
X	*dirv[i] = '/';
X    }
X    system(buf);
X}
X
X/* Make filenames more reasonable. */
X
Xchar *
Xfetchname(at,strip_leading,assume_exists)
Xchar *at;
Xint strip_leading;
Xint assume_exists;
X{
X    char *s;
X    char *name;
X    Reg1 char *t;
X    char tmpbuf[200];
X
X    if (!at)
X	return Nullch;
X    s = savestr(at);
X    for (t=s; isspace(*t); t++) ;
X    name = t;
X#ifdef DEBUGGING
X    if (debug & 128)
X	say4("fetchname %s %d %d\n",name,strip_leading,assume_exists);
X#endif
X    if (strnEQ(name, "/dev/null", 9))	/* so files can be created by diffing */
X	return Nullch;			/*   against /dev/null. */
X    for (; *t && !isspace(*t); t++)
X	if (*t == '/')
X	    if (--strip_leading >= 0)
X		name = t+1;
X    *t = '\0';
X    if (name != s && *s != '/') {
X	name[-1] = '\0';
X	if (stat(s, &filestat) && filestat.st_mode & S_IFDIR) {
X	    name[-1] = '/';
X	    name=s;
X	}
X    }
X    name = savestr(name);
X    Sprintf(tmpbuf, "RCS/%s", name);
X    free(s);
X    if (stat(name, &filestat) < 0 && !assume_exists) {
X	Strcat(tmpbuf, RCSSUFFIX);
X	if (stat(tmpbuf, &filestat) < 0 && stat(tmpbuf+4, &filestat) < 0) {
X	    Sprintf(tmpbuf, "SCCS/%s%s", SCCSPREFIX, name);
X	    if (stat(tmpbuf, &filestat) < 0 && stat(tmpbuf+5, &filestat) < 0) {
X		free(name);
X		name = Nullch;
X	    }
X	}
X    }
X    return name;
X}
!STUFFY!FUNK!
echo ""
echo "End of kit 2 (of 3)"
cat /dev/null >kit2isdone
config=true
for iskit in 1 2 3; do
    if test -f kit${iskit}isdone; then
	echo "You have run kit ${iskit}."
    else
	echo "You still need to run kit ${iskit}."
	config=false
    fi
done
case $config in
    true)
	echo "You have run all your kits.  Please read README and then type Configure."
	chmod 755 Configure
	;;
esac
: I do not append .signature, but someone might mail this.
exit

