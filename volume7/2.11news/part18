Subject:  v07i057:  2.11 News Source, Part08/09
Newsgroups: mod.sources
Approved: mirror!rs

Submitted by: seismo!rick (Rick Adams)
Mod.sources: Volume 7, Issue 57
Archive-name: 2.11news/Part08

# To extract, sh this file
#	news 2.11 source part 8 of 9
if test ! -d src
then
	mkdir src
fi
echo x - src/Makefile.dst 1>&2
sed 's/.//' >src/Makefile.dst <<'*-*-END-of-src/Makefile.dst-*-*'
-# '@(#)Makefile.dst	1.17	10/29/86'
-# Generic Makefile.
-# This is converted to USG/v7/etc by localize.sh
-# which should at least be a copy of localize.v7 or localize.usg
-
-# definitions
-
-#V7 OSTYPE = v7
-#USG OSTYPE = usg
-
-# HOME is the user name whose home dir has all the news stuff in it.
-HOME=	exptools
-# Use the -DHOME line if you want dynamic lookup in /etc/passwd
-#HOMENAME=	-DHOME=\"$(HOME)\"
-HOMENAME=
-
-NEWSUSR = news
-NEWSGRP = news
-SPOOLDIR = /usr/spool/news
-BATCHDIR = /usr/spool/batch
-LIBDIR = /usr/lib/news
-BINDIR = /usr/bin
-DESTDIR =
-UUXFLAGS = -r -z
-
-LNRNEWS = ln
-#VMS LNRNEWS = cp	# No links in Eunice
-DEBUG =
-SCCSID = -DSCCSID
-DEFS =	-DRNEWS=\"$(BINDIR)/rnews\" -DSPOOLDIR=\"$(SPOOLDIR)\" \
-	-DBATCHDIR=\"$(BATCHDIR)\" -DLIBDIR=\"$(LIBDIR)\" \
-	-DBINDIR=\"$(BINDIR)\" -DNEWSUSR=\"$(NEWSUSR)\" \
-	-DNEWSGRP=\"$(NEWSGRP)\"
-
-# Order is important here
-INSCOMPRESS=
-#BSD4_3 INSCOMPRESS= rm -f $(DESTDIR)$(LIBDIR)/compress; ln -s /usr/ucb/compress $(DESTDIR)$(LIBDIR)/compress
-COMPRESS= compress
-#BSD4_3 COMPRESS=
-
-#USG VFORK=-Dvfork=fork
-#V7 VFORK=-Dvfork=fork
-
-#BSD4_1 VFORK=
-#BSD4_2 VFORK=
-#BSD4_3 VFORK=
-
-#USG IBMFLAGS =
-#USG CFLAGS = ${DEBUG} -O $(IBMFLAGS) -DUSG -Dindex=strchr -Drindex=strrchr ${DEFS} ${SCCSID} ${VFORK}
-#USG LFLAGS = ${DEBUG} -s -i $(IBMFLAGS)
-#USG LIBS =
-#USG LINTFLAGS = ${DEFS}
-#V7 CFLAGS = ${DEBUG} -O -DDBM ${DEFS} ${SCCSID} ${VFORK}
-#V7 LFLAGS = ${DEBUG}
-#V7 LIBS = -ldbm
-#V7 LINTFLAGS = -chba -DDBM ${DEFS}
-#BSD4_1 LIBS = -ldbm -ljobs
-
-TERMLIB = -ltermlib
-
-#VMS TERMLIB = -ltrmlib
-#VMS LIBS = -ldbm
-#VMS CFLAGS = ${DEBUG} -O -DDBM ${DEFS} -DVMS ${SCCSID} ${VFORK}
-#VMS MISC = uname.o
-#VMS LINTFLAGS = -chba -DDBM -DVMS ${DEFS}
-#VMS VFORK=
-
-#V7 MISC = uname.o
-#USG MISC = ftime.o
-OBJECTS = funcs.o funcs2.o getdate.o header.o ndir.o $(MISC)
-IOBJECTS = inews.o ifuncs.o iextern.o control.o fullname.o \
-	ipathinit.o $(OBJECTS)
-
-POBJECTS = postnews.o rextern.o rpathinit.o funcs.o $(MISC)
-ROBJECTS = readnews.o rfuncs.o rfuncs2.o rextern.o readr.o \
-	process.o rpathinit.o digest.o $(OBJECTS)
-VOBJECTS = readnews.o rfuncs.o rfuncs2.o rextern.o process.o rpathinit.o \
-	$(OBJECTS) visual.o virtterm.o
-EXPOBJS = expire.o header.o funcs.o getdate.o iextern.o epathinit.o \
-	funcs2.o ndir.o $(MISC)
-
-SRCS = funcs.c funcs2.c header.c
-ISRCS = inews.c ifuncs.c iextern.c control.c fullname.c  $(SRCS)
-PSRCS = postnews.c rextern.c funcs.c
-RSRCS = readnews.c rfuncs.c rfuncs2.c rextern.c readr.c process.c  \
-	digest.c $(SRCS)
-VSRCS = readnews.c rfuncs.c rfuncs2.c rextern.c process.c $(SRCS) \
-	visual.c virtterm.c
-ESRCS = expire.c header.c funcs.c iextern.c \
-	funcs2.c
-OSRCS = uurec.c recnews.c sendnews.c batch.c unbatch.c caesar.c \
-	recmail.c compress.c
-
-UTILS = inews uurec recnews sendnews expire batch unbatch caesar recmail \
-	encode decode $(COMPRESS)
-SCRIPTS = sendbatch rmgroup checkgroups
-OTHERS = $(UTILS) $(SCRIPTS)
-COMMANDS = readnews checknews postnews vnews
-
-# dependencies
-all: $(COMMANDS) $(OTHERS)
-
-install: all help vnews.help
-	-mkdir $(DESTDIR)$(BINDIR)
-	-mkdir $(DESTDIR)$(LIBDIR)
-	cp $(COMMANDS) $(DESTDIR)$(BINDIR)
-	-cd $(DESTDIR)$(BINDIR); \
-		strip $(COMMANDS); \
-		chown $(NEWSUSR) $(COMMANDS); \
-		chgrp $(NEWSGRP) $(COMMANDS); \
-		chmod 755 $(COMMANDS)
-	cp help vnews.help $(OTHERS) $(DESTDIR)$(LIBDIR)
-	cd $(DESTDIR)$(LIBDIR); \
-		strip $(UTILS); \
-		chown $(NEWSUSR) $(OTHERS); \
-		chgrp $(NEWSGRP) $(OTHERS); \
-		chmod 755 $(OTHERS)
-	-rm -f $(DESTDIR)$(BINDIR)/rnews $(DESTDIR)$(BINDIR)/inews
-	${LNRNEWS} $(DESTDIR)$(LIBDIR)/inews $(DESTDIR)$(BINDIR)/rnews
-	chown $(NEWSUSR) $(DESTDIR)$(LIBDIR)/inews
-	chgrp $(NEWSGRP) $(DESTDIR)$(LIBDIR)/inews
-	chmod 6755 $(DESTDIR)$(LIBDIR)/inews $(DESTDIR)$(BINDIR)/rnews
-	$(INSCOMPRESS)
-#VMS 	vms -v @euninstal
-
-defs.h:	defs.dist localize.sh Makefile.dst Makefile
-	sh localize.sh
-
-Makefile: localize.sh defs.dist Makefile.dst
-	sh localize.sh
-
-update: install.sh makeactive.sh
-	sh install.sh $(SPOOLDIR) $(LIBDIR) $(BINDIR) $(NEWSUSR) $(NEWSGRP) $(OSTYPE)
-	chmod 6755 $(LIBDIR)/inews
-
-clean:
-	rm -f $(COMMANDS) $(OTHERS) *.o a.out
-	rm -f core index errs getdate.c
-
-lint:  ilint vlint rlint elint plint olint
-ilint: defs.h params.h iparams.h header.h $(ISRCS) pathinit.c
-	lint $(LINTFLAGS) $(ISRCS) -DINEW pathinit.c
-vlint: defs.h params.h rparams.h header.h $(VSRCS) pathinit.c
-	lint $(LINTFLAGS) $(VSRCS) -DREAD pathinit.c
-rlint: defs.h params.h rparams.h header.h $(RSRCS) pathinit.c
-	lint $(LINTFLAGS) $(RSRCS) -DREAD pathinit.c
-elint: defs.h params.h iparams.h header.h $(ESRCS) pathinit.c
-	lint $(LINTFLAGS) $(ESRCS) -DEXP pathinit.c
-plint: defs.h params.h iparams.h header.h $(PSRCS) pathinit.c
-	lint $(LINTFLAGS) $(PSRCS) -DREAD pathinit.c
-
-olint: defs.h params.h iparams.h header.h $(OSRCS)
-	for i in $(OSRCS); do lint $(LINTFLAGS) $$i; done
-
-inews:  $(IOBJECTS)
-	$(CC) $(LFLAGS) $(IOBJECTS) -o inews $(LIBS)  #NOTVMS
-#VMS 	vms link/notrace inews.o,ifuncs.o,iextern.o,control.o, \
-#VMS 	fullname.o,ipathinit.o,funcs.o,funcs2.o,getdate.o,header.o, \
-#VMS 	ndir.o,uname.o,lib:libdbm/lib,lib:libc/lib/exe=inews.
-
-readnews:  $(ROBJECTS)
-	$(CC) $(LFLAGS) $(ROBJECTS) -o readnews $(LIBS)
-#VMS 	mv readnews.exe readnews
-
-funcs.o:  funcs.c params.h defs.h header.h Makefile
-	$(CC) $(CFLAGS) -c funcs.c
-
-funcs2.o:  funcs2.c params.h defs.h header.h Makefile
-	$(CC) $(CFLAGS) -c funcs2.c
-
-getdate.o:  getdate.y
-	@echo "expect 8 shift/reduce conflicts"
-	yacc getdate.y
-	mv y.tab.c getdate.c
-	$(CC) $(CFLAGS) -c getdate.c
-	-rm -f getdate.c
-
-inews.o:  inews.c iparams.h defs.h params.h header.h Makefile
-	$(CC) $(CFLAGS) -c inews.c
-
-ifuncs.o:  ifuncs.c iparams.h defs.h params.h header.h Makefile
-	$(CC) $(CFLAGS) $(HOMENAME) -c ifuncs.c
-
-iextern.o:  iextern.c iparams.h defs.h params.h Makefile header.h
-	$(CC) $(CFLAGS) -c iextern.c
-
-postnews: $(POBJECTS)
-	$(CC) $(CFLAGS) $(LFLAGS) $(POBJECTS) -o postnews
-#VMS 	mv postnews.exe postnews
-
-postnews.o: postnews.c defs.h params.h header.h Makefile
-	$(CC) $(CFLAGS) -c postnews.c
-
-readnews.o:  readnews.c rparams.h defs.h params.h header.h Makefile
-	$(CC) $(CFLAGS) $(HOMENAME) -c readnews.c
-
-rfuncs.o:  rfuncs.c rparams.h defs.h params.h header.h Makefile
-	$(CC) $(CFLAGS) -c rfuncs.c
-
-rfuncs2.o:  rfuncs2.c rparams.h defs.h params.h header.h Makefile
-	$(CC) $(CFLAGS) -c rfuncs2.c
-
-rextern.o:  rextern.c rparams.h defs.h params.h Makefile header.h
-	$(CC) $(CFLAGS) -c rextern.c
-
-readr.o:  readr.c rparams.h defs.h params.h Makefile ndir.h header.h
-	$(CC) $(CFLAGS) -c readr.c
-
-checknews.o:  checknews.c defs.h header.h Makefile params.h
-	$(CC) $(CFLAGS) -c checknews.c
-
-vnews:	$(VOBJECTS)
-	$(CC) $(LFLAGS) $(VOBJECTS) $(TERMLIB) $(LIBS) -o $@
-#VMS 	mv vnews.exe vnews
-
-visual.o:  visual.c rparams.h defs.h params.h ndir.h header.h Makefile
-	$(CC) $(CFLAGS) -c visual.c
-
-control.o:  control.c defs.h iparams.h params.h header.h Makefile
-	$(CC) $(CFLAGS) -c control.c
-
-logdir.o: logdir.c Makefile
-	$(CC) $(CFLAGS) -c logdir.c
-
-uname.o:  uname.c defs.h params.h header.h Makefile
-	$(CC) $(CFLAGS) -c uname.c
-
-ndir.o: ndir.c ndir.h
-	$(CC) $(CFLAGS) -c ndir.c
-
-uurec:  uurec.c defs.h Makefile
-	$(CC) $(CFLAGS) $(LFLAGS) uurec.c -o uurec
-#VMS 	mv uurec.exe uurec
-
-recnews:  recnews.c defs.h header.h Makefile
-	$(CC) $(CFLAGS) $(LFLAGS) recnews.c -o recnews
-#VMS 	mv recnews.exe recnews
-
-sendnews:  sendnews.o uname.o
-	$(CC) $(LFLAGS) sendnews.o uname.o -o sendnews
-#VMS 	mv sendnews.exe sendnews
-
-batch:  batch.c Makefile
-	$(CC) $(CFLAGS) $(LFLAGS) batch.c -o batch
-#VMS 	mv batch.exe batch
-
-unbatch:  unbatch.c Makefile
-	$(CC) $(CFLAGS) $(LFLAGS) unbatch.c -o unbatch
-#VMS 	mv unbatch.exe unbatch
-
-encode:	encode.c
-	$(CC) $(CFLAGS) $(LFLAGS) encode.c -o encode
-#VMS 	mv encode.exe encode
-
-decode:	decode.c
-	$(CC) $(CFLAGS) $(LFLAGS) decode.c -o decode
-#VMS 	mv decode.exe decode
-
-caesar:  caesar.c Makefile
-	$(CC) $(CFLAGS) $(LFLAGS) caesar.c -o caesar -lm
-#VMS 	mv caesar.exe caesar
-
-compress: compress.c
-	$(CC) $(CFLAGS) $(LFLAGS) -o compress compress.c
-#VMS 	mv compress.exe compress
-
-recmail:  recmail.c defs.h params.h header.h
-	$(CC) $(CFLAGS) $(LFLAGS) recmail.c -o recmail
-#VMS 	mv recmail.exe recmail
-
-process.o:  process.c rparams.h defs.h params.h header.h Makefile
-	$(CC) $(CFLAGS) -c process.c
-
-checknews:  checknews.o process.o cpathinit.o
-	$(CC) $(LFLAGS) checknews.o process.o cpathinit.o -o checknews
-#VMS 	mv checknews.exe checknews
-
-sendbatch: sendbatch.sh Makefile
-	sed -e "s%LIBDIR%$(LIBDIR)%g" \
-	 -e "s%UUXFLAGS%$(UUXFLAGS)%g" \
-	 -e "s%BATCHDIR%$(BATCHDIR)%g" sendbatch.sh > sendbatch
-#VMS 	/etc/unixtovms sendbatch
-
-rmgroup: rmgroup.sh Makefile
-	sed -e "s%LIBDIR%$(LIBDIR)%g" \
-	 -e "s%SPOOLDIR%$(SPOOLDIR)%g" rmgroup.sh > rmgroup
-#VMS 	/etc/unixtovms rmgroup
-
-checkgroups: checkgroups.sh Makefile
-	sed -e "s%LIBDIR%$(LIBDIR)%g" checkgroups.sh > checkgroups
-#VMS 	/etc/unixtovms checkgroups
-
-sendnews.o: sendnews.c defs.h
-	$(CC) $(CFLAGS) -c sendnews.c
-
-fullname.o: defs.h params.h header.h Makefile
-	$(CC) $(CFLAGS) -c fullname.c
-
-expire: $(EXPOBJS)
-	$(CC) $(LFLAGS) -o expire $(EXPOBJS) $(LIBS)
-#VMS 	mv expire.exe expire
-
-header.o:  header.c header.h defs.h params.h Makefile
-	$(CC) $(CFLAGS) -c header.c
-
-expire.o:  expire.c defs.h Makefile params.h ndir.h header.h Makefile
-	$(CC) $(CFLAGS) -c expire.c
-
-digest.o:  digest.c Makefile
-	$(CC) $(CFLAGS) -c digest.c
-
-# Some silliness here to get pathinit for both readnews & inews
-rpathinit.o:  pathinit.c rparams.h header.h params.h defs.h Makefile
-	$(CC) $(CFLAGS) $(HOMENAME) -DREAD -c pathinit.c
-	mv pathinit.o rpathinit.o
-
-ipathinit.o:  pathinit.c iparams.h header.h params.h defs.h Makefile
-	$(CC) $(CFLAGS) $(HOMENAME) -DINEW -c pathinit.c
-	mv pathinit.o ipathinit.o
-
-cpathinit.o:  pathinit.c iparams.h header.h params.h defs.h Makefile
-	$(CC) $(CFLAGS) $(HOMENAME) -DCHKN -c pathinit.c
-	mv pathinit.o cpathinit.o
-
-epathinit.o:  pathinit.c iparams.h header.h params.h defs.h Makefile
-	$(CC) $(CFLAGS) $(HOMENAME) -DEXP -c pathinit.c
-	mv pathinit.o epathinit.o
-
-tags:	/tmp
-	ctags -w *.h *.c
-
-$(LIBDIR):
-	mkdir $(LIBDIR)
-	chmod 755 $(LIBDIR)
-	chown $(NEWSUSR) $(LIBDIR)
-	chgrp $(NEWSGRP) $(LIBDIR)
-
-$(BINDIR):
-	mkdir $(BINDIR)
-	chmod 755 $(BINDIR)
-	chown $(NEWSUSR) $(BINDIR)
-	chgrp $(NEWSGRP) $(BINDIR)
*-*-END-of-src/Makefile.dst-*-*
echo x - src/digest.c 1>&2
sed 's/.//' >src/digest.c <<'*-*-END-of-src/digest.c-*-*'
-/*
- * digest - process ARPANET digests
- *
- * digest(ifile, ofile, header)
- * FILE *ifile, *ofile;
- * struct header *header;
- *
- * returns:	TRUE	EOF reached, exit from readnews.
- *		FALSE	normal exit, continue reading news.
- */
-
-#ifdef SCCSID
-static char	*SccsId = "@(#)digest.c	1.7	9/19/86";
-#endif /* SCCSID */
-
-#include "rparams.h"
-
-struct art {
-	long	a_hdr;
-	long	a_bod;
-	int	a_blen;
-	int	a_hlen;
-};
-
-#define	loop		for(;;)
-#define	getnum(p, n)	for (n=0; *p>='0' && *p<='9'; p++) n = n*10 + *p-'0'
-#define	errchk(p)	if (*p) goto badopt
-
-#define	MAXART		128
-
-struct art	*arts;
-int		lastart;
-
-digest(ifp, ofp, h)
-FILE *ifp, *ofp;
-struct hbuf *h;
-{
-	register int	n, curart;
-	struct art	artbuf[MAXART];
-	int		printh, eod, nomore;
-	char		cbuf[BUFLEN], *cmd;
-
-	arts = artbuf;
-	printh = TRUE;
-	nomore = eod = FALSE;
-	curart = 1;
-
-	if (dscan(ifp))
-		return FALSE;
-
-	dprint(0, ifp, ofp);
-
-	loop {
-		if (nomore) break;
-		if (curart < 1) {
-			curart = 1;
-			eod = nomore = FALSE;
-		}
-		if (curart > lastart) curart = lastart;
-		if (eod) nomore = TRUE;
-		if (printh && !nomore)
-			(void) dhprint(curart, ifp, ofp);
-	getcmd:
-		loop {
-			SigTrap = FALSE;
-			fprintf(ofp, "Digest article %d of %d ", curart, lastart);
-			if (curart==lastart && nomore)
-				fprintf(ofp, "Last digest article ");
-			fprintf(ofp, "(%d lines) More? [%s] ",
-				arts[curart].a_blen, nomore?"snq":"ynq");
-			(void) fflush(ofp);
-			cmd = cbuf;
-			if (fgets(cmd, BUFLEN, stdin))
-				break;
-			if (!SigTrap)
-				return(TRUE);
-			putc('\n', ofp);
-		}
-		(void) nstrip(cmd);
-		while (*cmd==' ' || *cmd=='\t')
-			cmd++;
-		printh = TRUE;
-
-		switch (*cmd++) {
-		case '#':
-			fprintf(ofp, "%d articles in digest\n", lastart);
-			(void) fflush(ofp);
-			printh = FALSE;
-			break;
-
-		case '$':
-			curart = lastart;
-			break;
-
-		case '!':
-			fwait(fsubr(ushell, cmd, (char *)NULL));
-			fprintf(ofp, "!\n");
-			printh = FALSE;
-			break;
-
-		case '\0':
-			if (nomore) {
-				putc('\n', ofp);
-				return(FALSE);
-			}
-			cmd--;
-		case 'y':
-		case 'p':
-			errchk(cmd);
-			dprint(curart++, ifp, ofp);
-			if (curart > lastart)
-				eod = TRUE;
-			break;
-
-		case 'n':
-			errchk(cmd);
-			if (++curart > lastart) {
-				putc('\n', ofp);
-				return(FALSE);
-			}
-			break;
-
-		case '+':
-			getnum(cmd, n);
-			errchk(cmd);
-			if (nomore) {
-				putc('\n', ofp);
-				return(FALSE);
-			}
-			if (n)	curart += n;
-			else {
-				curart += 1;
-				if (curart > lastart)
-					eod = TRUE;
-			}
-			break;
-
-		case '-':
-			getnum(cmd, n);
-			errchk(cmd);
-			eod = nomore = FALSE;
-			curart -= (n) ? n : 1;
-			break;
-
-		case '0': case '1': case '2': case '3': case '4':
-		case '5': case '6': case '7': case '8': case '9':
-			cmd--;
-			getnum(cmd, n);
-			errchk(cmd);
-			curart = n;
-			eod = nomore = FALSE;
-			break;
-
-		case 'q':
-		case 'x':
-			putc('\n', ofp);
-			return(FALSE);
-
-		case '?':
-			fprintf(ofp, "\nDigester options:\n\n");
-			fprintf(ofp, "y\tyes, print article.\n");
-			fprintf(ofp, "n\tno, go to next article.\n");
-			fprintf(ofp, "q\texit from digester.\n");
-			fprintf(ofp, "h\tprint article header.\n");
-			fprintf(ofp, "s file\tsave article in file.\n");
-			fprintf(ofp, "t\ttable of contents.\n");
-			fprintf(ofp, "+[n]\tforward n articles (1).\n");
-			fprintf(ofp, "-[n]\tback n articles (1).\n");
-			fprintf(ofp, "\nh and s may be followed by '-'\n");
-			(void) fflush(ofp);
-			break;
-
-		case 'h':
-			n = curart;
-			if (*cmd=='-') {
-				cmd++;
-				if (n > 1) n--;
-			}
-			errchk(cmd);
-			(void) dhprint(n, ifp, ofp);
-			nomore = printh = FALSE;
-			if (n!=curart)
-				putc('\n', ofp);
-			break;
-
-		case 's':
-		case 'w':
-			n = curart;
-			if (*cmd=='-') {
-				cmd++;
-				if (n > 1) n--;
-			}
-			while (*cmd==' ' || *cmd=='\t')
-				cmd++;
-			dsaveart(n, ifp, ofp, cmd);
-			nomore = printh = FALSE;
-			if (n!=curart)
-				putc('\n', ofp);
-			break;
-
-		case 'H':
-			errchk(cmd);
-			hprint(h, ofp, 1);
-			eod = nomore = FALSE;
-			break;
-
-		case 'T':
-		case 't':
-			errchk(cmd);
-			if (cmd[-1]=='T')
-				hprint(h, ofp, 0);
-			dprint(0, ifp, ofp);
-			eod = nomore = FALSE;
-			break;
-
-		default:
-	badopt:
-			if (!nomore)
-				fprintf(ofp, "y (yes), n (no), ");
-			fprintf(ofp, "q (quit), s file (save), h (header), t (table of contents)\n");
-			fprintf(ofp, "? for help\n");
-			goto getcmd;
-		}
-	}
-	putc('\n', ofp);
-	return(FALSE);
-}
-
-dscan(ifp)
-register FILE *ifp;
-{
-	char		scanbuf[BUFLEN];
-	register int	n, len;
-	register char	*s;
-	register long	pos;
-	short		wasblank, ishead;
-
-	n = len = 0;
-	wasblank = FALSE;
-	s = scanbuf;
-	arts[0].a_bod = arts[1].a_hdr = ftell(ifp);
-	arts[0].a_hdr = 0L;
-	arts[1].a_bod = -1L;
-
-	loop {
-		if (SigTrap)
-			return(TRUE);
-		pos = ftell(ifp);
-		if (fgets(s, BUFLEN, ifp)==NULL)
-			*s = '\0';
-		if (wasblank && isheader(s)) {
-			long lastpos;
-			short is_blank;
-			short nhlines;
-			arts[n++].a_blen = len;
-			len = 0;
-			nhlines = 0;
-			arts[n].a_hdr = pos;
-			is_blank = FALSE;
-			ishead = TRUE;
-			do {
-				lastpos = pos;
-				wasblank = is_blank;
-				nhlines++;
-				pos = ftell(ifp);
-				if (fgets(s, BUFLEN, ifp)==NULL)
-					*s = '\0';
-				else
-					len++;
-				is_blank = (*s=='\n') ? TRUE : FALSE;
-				if (is_blank && nhlines==1)
-					/* one liner--not a header */
-					break;
-				if (!ishead || (s[0] != ' ' && s[0] != '\t'))
-					ishead = isheader(s);
-			} while ((is_blank && !wasblank) || ishead);
-			if ((!is_blank && !wasblank) || nhlines < 2) {
-				/* oops! not a header... back off */
-				arts[n].a_hdr = arts[n-1].a_bod;
-				len += arts[--n].a_blen;
-			} else {
-				if (wasblank)
-					pos = lastpos;
-				arts[n].a_hlen = len;
-				arts[n].a_bod = arts[n+1].a_hdr = pos;
-				arts[n+1].a_bod = -1L;
-				arts[n+1].a_hlen = 3;	/* average header len */
-				len = 0;
-			}
-		}
-		if (*s=='\0')
-			break;
-		wasblank = (*s=='\n') ? TRUE : FALSE;
-		len++;
-	}
-	arts[n].a_blen = len;
-	arts[n+1].a_hdr = pos;
-	lastart = n;
-	return FALSE;
-}
-
-dhprint(art, ifp, ofp)
-register int art;
-register FILE *ifp, *ofp;
-{
-	register char	c;
-	register long	pos = arts[art].a_hdr;
-	register long	epos = arts[art].a_bod;
-	register int	nlines = 1;
-
-	putc('\n', ofp);
-	fseek(ifp, pos, 0);
-	while (pos++ < epos && !SigTrap) {
-		if ((c = getc(ifp))=='\n')
-			nlines++;
-		putc(c, ofp);
-	}
-	(void) fflush(ofp);
-	SigTrap = FALSE;
-	return nlines;
-}
-
-dprint(art, ifp, ofp)
-int art;
-FILE *ifp, *ofp;
-{
-#ifdef	PAGE
-	register int	cnt;
-	FILE		*pfp, *popen();
-
-	if (art && arts[art].a_blen > 23-arts[art+1].a_hlen && *PAGER) {
-		if (!index(PAGER, FMETA)) {
-			if ((pfp = popen(PAGER, "w"))==NULL)
-				(void) dprinta(art, ifp, ofp);
-			else {
-				cnt = dprinta(art, ifp, pfp) % 23;
-				if (cnt > 23-arts[art+1].a_hlen)
-					while (cnt++ < 24)
-						putc('\n', pfp);
-				(void) pclose(pfp);
-			}
-		} else
-			pout(ofp);
-	} else
-#endif /* PAGE */
-		(void) dprinta(art, ifp, ofp);
-}
-
-dprinta(art, ifp, ofp)
-int art;
-register FILE *ifp, *ofp;
-{
-	register char	c;
-	register long	pos = arts[art].a_bod;
-	register long	epos = arts[art+1].a_hdr;
-	register int	nlines = 0;
-
-	(void) fseek(ifp, pos, 0);
-	while (pos++ < epos && !SigTrap) {
-		if ((c = getc(ifp))=='\n')
-			nlines++;
-		putc(c, ofp);
-	}
-	(void) fflush(ofp);
-	SigTrap = FALSE;
-	return nlines;
-}
-
-dsaveart(art, ifp, ofp, name)
-int art;
-register FILE *ifp, *ofp;
-register char *name;
-{
-	register FILE	*nfp;
-	char		fname[BUFLEN];
-	char		*strcat(), *strcpy(), *getenv();
-	register char	*nb;
-
-	while (*name==' ' || *name=='\t')
-		name++;
-
-	if (*name=='|') {
-		fprintf(ofp, "don't know how to pipe yet.\n");
-		(void) fflush(ofp);
-		return;
-	} else if (*name=='/')
-		(void) strcpy(fname, name);
-	else {
-		if (nb = getenv("NEWSBOX"))
-			(void) strcpy(fname, nb);
-		else
-			(void) strcpy(fname, userhome);
-		(void) strcat(fname, "/");
-		(void) strcat(fname, name);
-	}
-
-	fprintf(ofp, "Save digest article %d in \"%s\"", art, fname);
-	(void) fflush(ofp);
-	if ((nfp = fopen(fname, "a"))!=NULL) {
-		int ln;
-		ln = dhprint(art, ifp, nfp);
-		ln += dprinta(art, ifp, nfp);
-		fprintf(ofp, " [Appended] %d lines\n", ln);
-		(void) fclose(nfp);
-	} else
-		fprintf(ofp, " cannot append to.\n");
-}
-
-isheader(s)
-register char *s;
-{
-	if (isupper(*s) || islower(*s)) {
-		while (*s && *s!=':' && !isspace(*s))
-			s++;
-		if (*s==':' && *++s==' ')
-			return TRUE;
-	}
-	return FALSE;
-}
*-*-END-of-src/digest.c-*-*
echo x - src/readnews.c 1>&2
sed 's/.//' >src/readnews.c <<'*-*-END-of-src/readnews.c-*-*'
-/*
- * readnews - read news articles.
- */
-
-#ifdef SCCSID
-static char	*SccsId = "@(#)readnews.c	2.31	9/16/86";
-#endif /* SCCSID */
-
-#include "rparams.h"
-
-/*
- * readnews - article reading program
- */
-
-#ifndef SYSBUF
-char	SYSBUF[BUFSIZ];	/* to buffer std out */
-#endif
-
-#define OPTION	0	/* pick up an option string */
-#define STRING	1	/* pick up a string of arguments */
-
-struct timeb Now;
-
-int onsig(), cleanup();
-
-/*
- *	Authors:
- *		Matt Glickman	ucbvax!glickman
- *		Mark Horton	cbosg!mark
- *		Stephen Daniels	duke!swd
- *		Tom Truscott	duke!trt
- */
-
-main(argc, argv)
-int	argc;
-register char	**argv;
-{
-	register char	*ptr;	/* pointer to rest of buffer		*/
-	char	*user, *home;
-	int	optflag = FALSE, space = FALSE;
-	struct utsname ubuf;
-	char	*myrc;
-
-	/* set up defaults and initialize. */
-	pathinit();
-	mode = UNKNOWN;
-	header.title[0] = header.nbuf[0] = '\0';
-	coptbuf[0] = datebuf[0] = '\0';
-	uname(&ubuf);
-	strcpy(FULLSYSNAME, ubuf.nodename);
-
-	savmask = umask(N_UMASK);	/* set up mask */
-	uid = getuid();
-	gid = getgid();
-	duid = 0;
-	dgid = 0;
-	(void) ftime(&Now);
-
-#ifndef SHELL
-	if ((SHELL = getenv("SHELL")) == NULL)
-		SHELL = "/bin/sh";
-#endif
-#ifndef IHCC
-	/*
-	 * IHCC does not allow use of $LOGNAME to prevent forgery.
-	 * Note that this shouldn't matter in readnews, since inews
-	 * does all the actual posting of news.
-	 */
-	if ((user = getenv("USER")) == NULL)
-		user = getenv("LOGNAME");
-	if ((home = getenv("HOME")) == NULL)
-		home = getenv("LOGDIR");
-#endif
-	if (user == NULL || home == NULL)
-		getuser();
-	else {
-		username = AllocCpy(user);
-		(void) strcpy(header.path, username);
-		userhome = AllocCpy(home);
-	}
-
-	if (!(MAILER = getenv("MAILER")))
-		MAILER = "mail";	/* was /bin/mail */
-
-#ifdef PAGE
-	if (myrc = getenv("PAGER"))
-		PAGER = AllocCpy(myrc);
-	else {
-# ifdef IHCC
-		(void) sprintf(bfr, "%s/bin/%s", logdir(HOME), PAGE);
-		PAGER = AllocCpy(bfr);
-# else /* !IHCC */
-		PAGER = PAGE;
-# endif /* !IHCC */
-	}
-#endif /* PAGE */
-
-	if (ptr = getenv("NEWSOPTS"))
-		(void) strcpy(rcbuf, ptr);
-	else
-		*rcbuf = '\0';
-	if (*rcbuf) {
-		(void) strcat(rcbuf, " \1");
-		ptr = rcbuf;
-		while (*++ptr)
-			if (isspace(*ptr))
-				*ptr = '\0';
-		for (ptr = rcbuf; ; ptr++) {
-			if (!*ptr)
-				continue;
-			if (*ptr == '\1')
-				break;
-			if (++line > LINES)
-				xerror("Too many options.");
-			if ((rcline[line] = malloc((unsigned)(strlen(ptr) + 1))) == NULL)
-				xerror("Not enough memory.");
-			argvrc[line] = rcline[line];
-			(void) strcpy(rcline[line], ptr);
-			while (*ptr)
-				ptr++;
-		}
-	}
-	myrc = getenv("NEWSRC");
-	if (myrc == NULL) {
-		myrc = NEWSRC;
-		(void) sprintf(newsrc, "%s/%s", userhome, myrc);
-	} else {
-		(void) strcpy(newsrc, myrc);
-	}
-	if (access(newsrc, 0))
-		newrc(newsrc);
-	if ((rcfp = fopen(newsrc, "r")) != NULL) {
-		rcreadok = FALSE;
-		while (fgets(rcbuf, LBUFLEN, rcfp) != NULL) {
-			if (!(space = isspace(*rcbuf)))
-				optflag = FALSE;
-			if (!strncmp(rcbuf, "options ", 8))
-				optflag = TRUE;
-			if (optflag) {
-				(void) strcat(rcbuf, "\1");
-				if (space)
-					ptr = rcbuf - 1;
-				else
-					ptr = &rcbuf[7];
-				while (*++ptr)
-					if (isspace(*ptr))
-						*ptr = '\0';
-				if (space)
-					ptr = rcbuf;
-				else
-					ptr = &rcbuf[8];
-				for (; ; ptr++) {
-					if (!*ptr)
-						continue;
-					if (*ptr == '\1')
-						break;
-					if (++line > LINES)
-						xerror("Too many options.");
-					if ((rcline[line] = malloc((unsigned)(strlen(ptr) + 1))) == NULL)
-						xerror("Not enough memory.");
-					argvrc[line] = rcline[line];
-					(void) strcpy(rcline[line], ptr);
-					while (*ptr)
-						ptr++;
-				}
-			}
-		}
-		(void) fclose(rcfp);
-		rcreadok = TRUE;
-	}
-	if (line != -1) {
-#ifdef DEBUG
-		register int i;
-		for (i = 0; i <= line; i++)
-			fprintf(stderr, "options:  %s\n", rcline[i]);
-#endif
-		process(line + 2, argvrc);
-		do {
-#ifdef DEBUG
-			fprintf(stderr, "Freeing %d\n", line);
-#endif
-			free(rcline[line]);
-		} while (line--);
-	}
-
-	argv++;
-	(void) strcat(header.nbuf, ADMSUB);
-	process(argc, argv);
-	if (!nflag)
-		(void) sprintf(header.nbuf, "%s,%s", ADMSUB, DFLTSUB);
-	else {
-		char *p = rindex(header.nbuf, ',');
-		if (p && p[1] == '\0')	/* strip of trailing NGDELIM */
-			*p ='\0';
-	}
-	lcase(header.nbuf);
-	makehimask(header.nbuf, "junk");
-	makehimask(header.nbuf, "control");
-	makehimask(header.nbuf, "test");
-
-	setbuf(stdout, SYSBUF);
-	SigTrap = FALSE;	/* true if a signal has been caught */
-	if (!pflag && !lflag && !eflag) {
-		(void) signal(SIGQUIT, SIG_IGN);
-		(void) signal(SIGHUP, cleanup);
-		(void) signal(SIGINT, onsig);
-		(void) signal(SIGPIPE, onsig);
-	} else {
-		int (* old)();
-		if ((old = signal(SIGQUIT, SIG_IGN)) != SIG_IGN)
-			(void) signal(SIGQUIT, cleanup);
-		if ((old = signal(SIGHUP, SIG_IGN)) != SIG_IGN)
-			(void) signal(SIGHUP, cleanup);
-		if ((old = signal(SIGINT, SIG_IGN)) != SIG_IGN)
-			(void) signal(SIGINT, cleanup);
-	}
-
-	/*
-	 * ALL of the command line has now been processed. (!)
-	 */
-
-	if (!*header.nbuf)
-		strcpy(header.nbuf, DFLTSUB);
-	if (sflag) {
-		printf("Subscription list:  %s\n", header.nbuf);
-		xxit(0);
-	}
-	if (xflag)
-		line = -1;
-	rcfp = xfopen(newsrc, "r");
-	while (fgets(rcbuf, LBUFLEN, rcfp) != NULL) {
-		if (!nstrip(rcbuf))
-			xerror(".newsrc line too long");
-		if (++line >= LINES)
-			xerror("Too many .newsrc lines");
-		if ((rcline[line] = malloc((unsigned)(strlen(rcbuf) + 1))) == NULL)
-			xerror("Not enough memory");
-		(void) strcpy(rcline[line], rcbuf);
-	}
-	fclose(rcfp);
-
-	if (SigTrap) {
-		if (SigTrap == SIGHUP || !rcreadok)
-			xxit(0);
-		fprintf(stdout, "Abort (n)?  ");
-		(void) fflush(stdout);
-		if (gets(bfr) == NULL || *bfr == 'y' || *bfr == 'Y')
-			xxit(0);
-		SigTrap = FALSE;
-	}
-	sortactive();
-	actfp = xfopen(ACTIVE, "r");
-
-#ifdef DEBUG
-	fprintf(stderr, "header.nbuf = %s\n", header.nbuf);
-#endif /* DEBUG */
-	if (Kflag)
-		news++;
-	else {
-		switch (mode) {
-		case UNKNOWN:
-			readr();
-			break;
-#ifdef TMAIL
-		case MAIL:
-			Mail();
-			break;
-#endif /* TMAIL */
-		}
-	}
-
-	cleanup();
-	/*NOTREACHED*/
-}
-
-cleanup()
-{
-	(void) signal(SIGHUP, SIG_IGN);
-	(void) fflush(stdout);
-	if (!news || xflag || lflag || tflag)
-		xxit(0);
-	if (*groupdir && mode != MAIL)
-		updaterc();
-	writeoutrc();
-	xxit(0);
-}
-
-/*
- * Write out the .newsrc file. It's already been cleaned up by sortactive()
- * Take care that data is all written, and flushed, before we destroy the
- * old copy.
- */
-writeoutrc()
-{
-	FILE *wrcfp;
-	char aline[BUFLEN];
-	register int i;
-
-	/* NEVER write it out if xflag */
-	if (xflag || !rcreadok)
-		return;
-
-	(void) strcpy(aline, newsrc);
-	(void) strcat(aline, ".new");
-
-#ifdef VMS
-	(void) vmsdelete(aline);
-#endif
-	wrcfp = xfopen(aline, "w");
-
-	for (i = 0; i <= line; i++) {
-		if (rcline[i] != NULL)
-			if (fprintf(wrcfp, "%s\n", rcline[i]) < 0)
-				goto fouled;
-	}
-	if (fclose(wrcfp) < 0)
-		goto fouled;
-
-#ifdef VMS
-	(void) vmsdelete(newsrc);
-#endif
-	if (rename(aline, newsrc) < 0)
-		xerror("Cannot rename %s to %s", aline, newsrc);
-	return;
-
-  fouled:
-	xerror("Error writing new .newsrc file - no changes made\n");
-	return;
-}
-
-/*
- * Forbid newsgroup ng, unless he asked for it in nbuf.
- */
-makehimask(nbuf, ng)
-char *nbuf, *ng;
-{
-	if (!findex(nbuf, ng))
-		(void) sprintf(rindex(nbuf, '\0'), ",!%s", ng);
-}
-
-/*
- * Return true if the string searchfor is in string, but not if preceded by !.
- */
-findex(string, searchfor)
-char *string, *searchfor;
-{
-	register char first;
-	register char *p;
-
-	first = *searchfor;
-	for (p=index(string, first); p; p = index(p+1, first)) {
-		if (((p==string) || (p[-1]!='!')) && strncmp(p, searchfor, strlen(searchfor)) == 0)
-			return TRUE;
-	}
-	return FALSE;
-}
*-*-END-of-src/readnews.c-*-*
echo x - src/install.sh 1>&2
sed 's/.//' >src/install.sh <<'*-*-END-of-src/install.sh-*-*'
-: '@(#)install.sh	1.16	10/29/86'
-
-if test "$#" != 6
-then
-	echo "usage: $0 spooldir libdir bindir nuser ngroup ostype"
-	exit 1
-fi
-SPOOLDIR=$1
-LIBDIR=$2
-BINDIR=$3
-NEWSUSR=$4
-NEWSGRP=$5
-OSTYPE=$6
-
-: Get name of local system
-case $OSTYPE in
-	usg)	SYSNAME=`uname -n`
-		if test ! -d $LIBDIR/history.d
-		then
-			mkdir $LIBDIR/history.d
-			chown $NEWSUSR $LIBDIR/history.d
-			chgrp $NEWSGRP $LIBDIR/history.d
-		fi;;
-	v7)	SYSNAME=`uuname -l`
-		touch $LIBDIR/history.pag $LIBDIR/history.dir;;
-	*)	echo "$0: Unknown Ostype"
-		exit 1;;
-esac
-
-if test "$SYSNAME" = ""
-then
-	echo "$0: Cannot get system name"
-	exit 1
-fi
-
-: Ensure SPOOLDIR exists
-for i in $SPOOLDIR $SPOOLDIR/.rnews
-do
-	if test ! -d $i
-	then
-		mkdir $i
-	fi
-	chmod 777 $i
-	chown $NEWSUSR $i
-	chgrp $NEWSGRP $i
-done
-
-chown $NEWSUSR $LIBDIR
-chgrp $NEWSGRP $LIBDIR
-
-: Ensure certain files in LIBDIR exist
-touch $LIBDIR/history $LIBDIR/active $LIBDIR/log $LIBDIR/errlog $LIBDIR/users
-chmod 666 $LIBDIR/users
-
-: If no sys file, make one.
-if test ! -f $LIBDIR/sys
-then
-echo
-echo Making a $LIBDIR/sys file to link you to oopsvax.
-echo You must change oopsvax to your news feed.
-echo If you are not in the USA, remove '"usa"' from your line in the sys file.
-echo If you are not in North America, remove '"na"' from your line in the sys file.
-	cat > $LIBDIR/sys << EOF
-$SYSNAME:world,comp,sci,news,rec,soc,talk,misc,net,mod,na,usa,to::
-oopsvax:world,comp,sci,news,rec,soc,talk,misc,net,mod,na,usa,to.oopsvax::
-EOF
-fi
-
-: If no seq file, make one.
-if test ! -s $LIBDIR/seq
-then
-	echo '100' >$LIBDIR/seq
-fi
-
-: If no mailpaths, make one.
-if test ! -s $LIBDIR/mailpaths
-then
-	cat <<E_O_F >$LIBDIR/mailpaths
-backbone	%s
-internet	%s
-E_O_F
-echo "I have created $LIBDIR/mailpaths for you. The paths are certainly wrong."
-echo "You must correct them manually to be able to post to moderated groups."
-fi
-
-sh makeactive.sh $LIBDIR $SPOOLDIR $NEWSUSR $NEWSGRP
-
-for i in $LIBDIR/ngfile $BINDIR/inews $LIBDIR/localgroups $LIBDIR/moderators \
-	$LIBDIR/cunbatch $LIBDIR/c7unbatch
-do
-	if test -f $i
-	then
-		echo "$i is no longer used. You should remove it."
-	fi
-done
-
-for i in $LIBDIR/csendbatch $LIBDIR/c7sendbatch
-do
-	if test -f $i
-	then
-		echo "$i is no longer used. You should remove it after"
-		echo "changing your crontab entry to use sendbatch [flags]"
-	fi
-done
-
-if test -f $BINDIR/cunbatch
-then
-	echo "$BINDIR/cunbatch is not used by the new batching scheme."
-	echo "You should remove it when all of your neighbors have upgraded."
-fi
-
-cat >$LIBDIR/aliases.new <<EOF
-net.chess		net.games.chess
-net.trivia		net.games.trivia
-net.rec.radio		net.ham-radio
-net.term		net.info-terms
-net.joke		net.jokes
-net.vlsi		net.lsi
-net.micro.16k		net.micro.ns32k
-net.music.gdea		net.music.gdead
-net.notes		net.news.notes
-net.periph		net.periphs
-net.puzzles		net.puzzle
-net.unix.wizards	net.unix-wizards
-net.sources.wanted	net.wanted.sources
-net.consumers		misc.consumers
-net.consumers.house	misc.consumers.house
-net.house		misc.consumers.house
-na.forsale		misc.forsale
-net.forsale		misc.forsale
-net.politics.terror	misc.headlines
-net.invest		misc.invest
-net.jobs		misc.jobs
-net.kids		misc.kids
-mod.legal		misc.legal
-net.legal		misc.legal
-net.followup		misc.misc
-net.general		misc.misc
-net.misc		misc.misc
-net.suicide		misc.misc
-net.taxes		misc.taxes
-mod.test		misc.test
-net.test		misc.test
-net.wanted		misc.wanted
-net.announce		mod.announce
-net.announce.newusers	mod.announce.newusers
-mod.map.uucp		mod.map
-net.religion.christian	mod.religion.christian
-net.religion.xian	mod.religion.christian
-net.astro		sci.astro
-net.astro.expert	sci.astro
-net.bio			sci.bio
-net.crypt		sci.crypt
-net.analog		sci.electronics
-net.nlang		sci.lang
-net.math		sci.math
-net.stat		sci.math.stat
-net.math.stat		sci.math.stat
-net.math.symbolic	sci.math.symbolic
-net.med			sci.med
-net.sci			sci.misc
-net.physics		sci.physics
-net.research		sci.research
-net.space		sci.space
-net.columbia		sci.space.shuttle
-net.challenger		sci.space.shuttle
-net.college		soc.college
-net.nlang.africa	soc.culture.african
-net.nlang.celts		soc.culture.celtic
-net.nlang.greek		soc.culture.greek
-net.nlang.india		soc.culture.indian
-net.religion.jewish	soc.culture.jewish
-net.social		soc.misc
-mod.motss		soc.motss
-net.motss		soc.motss
-net.net-people		soc.net-people
-net.roots		soc.roots
-net.singles		soc.singles
-net.women		soc.women
-net.abortion		talk.abortion
-net.bizarre		talk.bizarre
-net.origins		talk.origins
-net.philosophy		talk.philosophy.misc
-net.politics		talk.politics.misc
-net.politics.theory	talk.politics.theory
-net.religion		talk.religion.misc
-talk.religion		talk.religion.misc
-net.rumor		talk.rumors
-talk.rumor		talk.rumors
-EOF
-: if no aliases file, make one
-if test ! -f $LIBDIR/aliases
-then
-	mv $LIBDIR/aliases.new $LIBDIR/aliases
-else
-	: see whats missing
-	sort $LIBDIR/aliases | sed -e 's/  */	/g'  -e 's/		*/	/g' >/tmp/$$aliases
-	sort $LIBDIR/aliases.new | sed -e 's/  */	/g'  -e 's/		*/	/g' >/tmp/$$aliases.new
-	comm -23 /tmp/$$aliases.new /tmp/$$aliases >/tmp/$$comm
-	if test -s /tmp/$$comm
-	then
-		echo "The following suggested aliases are missing or incorrect in your"
-		echo "$LIBDIR/aliases file. It is suggested you add them."
-		echo ""
-		cat /tmp/$$comm
-		echo ""
-		echo "A suggested aliases file has been left in $LIBDIR/aliases.new"
-		echo "for your convenience."
-		rm /tmp/$$comm /tmp/$$aliases
-	else
-		rm /tmp/$$comm /tmp/$$aliases $LIBDIR/aliases.new
-	fi
-fi
-
-: if no distributions file, make one
-if test ! -f $LIBDIR/distributions
-then
-	cat >$LIBDIR/distributions <<EOF
-local		Local to this site
-regional	Everywhere in this general area
-usa		Everywhere in the USA
-na		Everywhere in North America
-world		Everywhere on Usenet in the world
-EOF
-echo
-echo You may want to add distributions to $LIBDIR/distributions if your
-echo site particpates in a regional distribution such as '"ba"' or '"dc"'.
-fi
-
-chown $NEWSUSR $LIBDIR/[a-z]*
-chgrp $NEWSGRP $LIBDIR/[a-z]*
-
-echo
-echo Reminder: uux must permit rnews if running over uucp.
-rm -f /tmp/$$*
*-*-END-of-src/install.sh-*-*
echo x - src/batch.c 1>&2
sed 's/.//' >src/batch.c <<'*-*-END-of-src/batch.c-*-*'
-
-/*
- * This software is Copyright (c) 1985 by Rick Adams.
- *
- * Permission is hereby granted to copy, reproduce, redistribute or
- * otherwise use this software as long as: there is no monetary
- * profit gained specifically from the use or reproduction or this
- * software, it is not sold, rented, traded or otherwise marketed, and
- * this copyright notice is included prominently in any copy
- * made.
- *
- * The author make no claims as to the fitness or correctness of
- * this software for any use whatsoever, and it is provided as is. 
- * Any use of this software is at the user's own risk.
- *
- * Batch: program to batch a list of news articles into an unbatch script.
- * Usage: /usr/lib/news/batch listfile [bytecount]
- *  where listfile is a file containing a list, one per line, of full
- *  path names of files containing articles, e.g. as produced by the F
- *  transmission option in the sys file.
- *  bytecount is the maximum number of bytes to output before exiting
- * Output is placed on standard output.
- *
- * Intended usage:
- *
- *	With the shellfile "sendbatch", with machine names as arguments:
- * 		e.g
- *		sendbatch rlgvax seismo
- *
- * This would be invoked every hour or two from crontab.
- *
- */
-
-#ifdef SCCSID
-static char	*SccsId = "@(#)batch.c	1.15	1/17/86";
-#endif /* SCCSID */
-
-#include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <errno.h>
-#include "defs.h"
-
-#if defined(USG) || defined(BSD4_2) || defined(BSD4_1C)
-#include <fcntl.h>
-#endif
-
-struct stat sbuf;
-
-extern int errno;
-extern char *sys_errlist[];
-
-main(argc,argv)
-char **argv;
-{
-	register FILE *fd, *nfd;
-	register int c;
-	register long n;
-	register char *cp;
-	char *fdstatus;
-	long maxbytes, nbytes;
-	long atol();
-	char fname[512];
-	char workfile[512];
-	char *index(), *fgets();
-
-	if (argc < 2) {
-		fprintf(stderr, "Usage: batch listfile [bytecount]\n");
-		exit(1);
-	}
-
-	/*
-	 * Rename real file to a work name to avoid race conditions.
-	 * If workfile exists skip the rename in order
-	 * to recover from a crash w/o losing anything.
-	 */
-	(void) strcpy(workfile, argv[1]);
-	(void) strcat(workfile, ".work");
-	if (access(workfile, 0) < 0) {
-		if (access(argv[1], 0) < 0 && errno == ENOENT)
-			exit(0);	/* no news */
-		if (rename(argv[1], workfile) < 0) {
-			logerror("rename(%s,%s) %s", argv[1], workfile,
-				sys_errlist[errno]);
-			exit(1);
-		}
-	}
-	fd = fopen(workfile, "r");
-	if (fd == NULL) {
-		logerror("fopen(%s,r) %s", workfile, sys_errlist[errno]);
-		exit(1);
-	}
-
-	if (argc > 2)
-		maxbytes = atol(argv[2]);
-	else
-		maxbytes = 100000000L; /* backwards compatible */
-	nbytes = 0;
-	while ((fdstatus = fgets(fname, sizeof fname, fd)) != NULL) {
-		cp = index(fname, '\n');
-		if (cp)
-			*cp = '\0';
-		nfd = fopen(fname, "r");
-		if (nfd == NULL) {
-			perror(fname);
-			continue;
-		}
-		(void) fstat(fileno(nfd), &sbuf);
-		if (cp)
-			*cp = '\n';
-		nbytes += sbuf.st_size;
-		if (nbytes > maxbytes && nbytes != sbuf.st_size)
-			break;
-		printf("#! rnews %ld\n", (long)sbuf.st_size);
-		/* guess length of #! rnews string */
-		nbytes += 13;
-		n = 0;
-		while ((c = getc(nfd)) != EOF) {
-			putchar(c);
-			n++;
-		}
-		(void) fclose(nfd);
-		if (ferror(stdout)){
-			logerror("stdout write %s", sys_errlist[errno]);
-			exit(1);
-		}
-		if (n != sbuf.st_size) { /* paranoia */
-			logerror("%s, expected %ld bytes, got %ld", fname,
-				n, sbuf.st_size);
-			/* breaking out of this early will end up resyncing
-			   the batch files (isn't serendipity wonderful?) */
-			break;
-		}
-	}
-	if (fdstatus != NULL) {		/* exceeded maxbytes */
-		char tmpfile[512];
-
-		(void) umask(2);
-		(void) strcpy(tmpfile, argv[1]);
-		(void) strcat(tmpfile, ".tmp");
-	    	nfd = fopen(tmpfile, "w");
-		if (nfd == NULL) {
-			logerror("fopen(%s,w) %s", tmpfile, sys_errlist[errno]);
-			exit(1);
-		}
-		do {
-			fputs(fname, nfd);
-		} while (fgets(fname, sizeof fname, fd) != NULL);
-		if (ferror(nfd)) {
-			logerror("write(%s) %s", tmpfile, sys_errlist[errno]);
-			exit(1);
-		}
-		(void) fclose(nfd);
-		(void) fclose(fd);
-		/* will pick it up next time thru */
-		if (rename(tmpfile, workfile) < 0) {
-			logerror("rename(%s,%s) %s", tmpfile, workfile,
-				sys_errlist[errno]);
-			exit(1);
-		}
-	}		
-	else
-		(void) unlink(workfile);
-	exit(0);
-}
-
-/*
- * Log the given message, with printf strings and parameters allowed,
- * on the log file, if it can be written.
- */
-/* VARARGS1 */
-logerror(fmt, a1, a2, a3, a4, a5, a6, a7, a8, a9)
-char *fmt;
-{
-	FILE *logfile;
-	char lfname[BUFLEN];		/* the log file */
-	char bfr[BUFLEN];
-	char *logtime, *ctime(); 
-	time_t t;
-
-	(void) time(&t);
-	logtime = ctime(&t);
-	logtime[16] = 0;
-	logtime += 4;
-
-#ifdef IHCC
-	(void) sprintf(lfname, "%s/%s/errlog", logdir(HOME), LIBDIR);
-#else
-	(void) sprintf(lfname, "%s/errlog", LIBDIR);
-#endif
-
-	(void) sprintf(bfr, fmt, a1, a2, a3, a4, a5, a6, a7, a8, a9);
-	fprintf(stderr, bfr);
-	if (access(lfname, 0) == 0 && (logfile = fopen(lfname, "a")) != NULL) {
-#if defined(USG) || defined(BSD4_2) || defined(BSD4_1C)
-		int flags;
-		flags = fcntl(fileno(logfile), F_GETFL, 0);
-		(void) fcntl(fileno(logfile), F_SETFL, flags|O_APPEND);
-#else /* v7 */
-		(void) lseek(fileno(logfile), 0L, 2);
-#endif /* v7 */
-		fprintf(logfile, "%s\tbatch\t%s\n", logtime, bfr);
-		(void) fclose(logfile);
-	}
-}
-
-#if !defined(BSD4_2) && !defined(BSD4_1C)
-rename(from, to)
-register char *from, *to;
-{
-	(void) unlink(to);
-	if (link(from, to) < 0)
-		return -1;
-
-	(void) unlink(from);
-	return 0;
-}
-#endif /* !BSD4_2 && !BSD4_1C */
*-*-END-of-src/batch.c-*-*
echo x - src/process.c 1>&2
sed 's/.//' >src/process.c <<'*-*-END-of-src/process.c-*-*'
-/*
- * This software is Copyright (c) 1986 by Rick Adams.
- *
- * Permission is hereby granted to copy, reproduce, redistribute or
- * otherwise use this software as long as: there is no monetary
- * profit gained specifically from the use or reproduction or this
- * software, it is not sold, rented, traded or otherwise marketed, and
- * this copyright notice is included prominently in any copy
- * made.
- *
- * The author make no claims as to the fitness or correctness of
- * this software for any use whatsoever, and it is provided as is. 
- * Any use of this software is at the user's own risk.
- *
- * process - process options for readnews/vnews
- */
-
-#ifdef SCCSID
-static char	*SccsId = "@(#)process.c	2.15	9/16/86";
-#endif /* SCCSID */
-
-#include "rparams.h"
-
-#define OPTION	0	/* pick up an option string */
-#define STRING	1	/* pick up a string of arguments */
-
-struct optable *optpt, options[] = { /*
-optlet	filchar	flag	newstate oldmode	newmode	buf	*/
-'p',	'\0',	FALSE,	OPTION,	UNKNOWN,	UNKNOWN,(char *)NULL,	
-'t',	'\0',	FALSE,	STRING,	ANY,		UNKNOWN,header.title,	
-'a',	' ',	FALSE,	STRING,	ANY,		UNKNOWN,datebuf,
-'n',   NGDELIM,	FALSE,	STRING,	ANY,		UNKNOWN,header.nbuf,
-'c',	' ',	FALSE,	STRING,	UNKNOWN,	UNKNOWN,coptbuf,	
-'l',	' ',	FALSE,	OPTION,	UNKNOWN,	UNKNOWN,(char *)NULL,
-'r',	'\0',	FALSE,	OPTION,	ANY,		UNKNOWN,(char *)NULL,
-'s',   NGDELIM,	FALSE,	STRING,	ANY,		UNKNOWN,header.nbuf,
-'x',	'\0',	FALSE,	OPTION,	ANY,		UNKNOWN,(char *)NULL,
-'h',	'\0',	FALSE,	OPTION,	ANY,		UNKNOWN,(char *)NULL,
-#ifdef TMAIL
-'M',	'\0',	FALSE,	OPTION,	UNKNOWN,	MAIL,	(char *)NULL,
-#else /* !TMAIL */
-'\377',	'\0',	FALSE,	OPTION,	UNKNOWN,	UNKNOWN,(char *)NULL,
-#endif /* !TMAIL */
-'f',	'\0',	FALSE,	OPTION,	ANY,		UNKNOWN,(char *)NULL,
-'u',	'\0',	FALSE,	OPTION,	ANY,		UNKNOWN,(char *)NULL,
-'e',	'\0',	FALSE,	OPTION,	ANY,		UNKNOWN,(char *)NULL,
-'K',	'\0',	FALSE,	OPTION,	ANY,		UNKNOWN,(char *)NULL,
-'\0',	'\0',	0,	0,	0,		0,	(char *)NULL
-};
-
-process(argc,argv)
-register int argc;
-register char **argv;
-{
-	register int state = STRING;
-	register char *ptr = header.nbuf;
-	char filchar = NGDELIM;
-	int len = BUFLEN, tlen;
-
-	/* loop once per arg. */
-
-	if (argc > 1 && **argv != '-')
-		nflag = TRUE;
-
-	while (--argc) {
-	    if (state == OPTION) {
-		if (**argv != '-') {
-			xerror("Bad option string \"%s\"", *argv);
-		}
-		while (*++*argv != '\0') {
-			for (optpt = options; optpt->optlet != '\0'; ++optpt) {
-				if (optpt->optlet == **argv)
-					goto found;
-			}
-			/* unknown option letter */
-#ifdef TMAIL
-			fprintf(stderr, "Usage: %s [ -a [ date ]] [ -n newsgroups ] [ -t titles ] [ -lprxhfuMK ]\n", Progname);
-#else /* !TMAIL */
-			fprintf(stderr, "Usage: %s [ -a [ date ]] [ -n newsgroups ] [ -t titles ] [ -lprxhfuK ]\n", Progname);
-#endif /* !TMAIL */
-			fprintf(stderr, "\t[ -c [ ``mailer'' ]]\n\n");
-			fprintf(stderr, "       %s -s\n", Progname);
-			exit(1);
-
-		    found:;
-			if (mode != UNKNOWN && (mode&optpt->oldmode) == 0) {
-				xerror("Bad %c option", **argv);
-			}
-			if (mode == UNKNOWN)
-				mode = optpt->newmode;
-			filchar = optpt->filchar;
-			optpt->flag = TRUE;
-			state = optpt->newstate;
-			ptr = optpt->buf;
-			len = BUFLEN;
-		}
-
-		argv++;		/* done with this option arg. */
-
-	    } else {
-
-		/*
-		 * Pick up a piece of a string and put it into
-		 * the appropriate buffer.
-		 */
-		if (**argv == '-') {
-			state = OPTION;
-			argc++;	/* uncount this arg. */
-			continue;
-		}
-
-		if ((tlen = strlen(*argv)) >= len)
-			xerror("Argument string too long");
-		strcpy(ptr, *argv++);
-		ptr += tlen;
-		if (*(ptr-1) != filchar)
-			*ptr++ = filchar;
-		len -= tlen + 1;
-		*ptr = '\0';
-	    }
-	}
-	return;
-}
*-*-END-of-src/process.c-*-*
echo x - src/uurec.c 1>&2
sed 's/.//' >src/uurec.c <<'*-*-END-of-src/uurec.c-*-*'
-/*
- * uurec - receive articles via /bin/mail.
- */
-
-#ifdef SCCSID
-static char	*SccsId = "@(#)uurec.c	2.9	4/16/85";
-#endif /* SCCSID */
-
-#include "defs.h"
-
-#include <stdio.h>
-#include <ctype.h>
-
-/*
- * Process a news article which has been shipped via /bin/mail.
- */
-
-#define FROM	01
-#define NLIN	02
-#define BLANK	03
-#define OTHER	04
-
-#define SKIPPING	010
-#define READING		020
-
-#define BFSZ 250
-
-#define EOT	'\004'
-
-#define A	01
-#define B	02
-
-#ifdef debug
-# define RNEWS "cat"
-#endif
-extern	char	*strcat(), *strcpy();
-extern	char	*frombreak();
-extern	FILE	*popen();
-
-/* ARGSUSED */
-main(argc, argv)
-int argc;
-char **argv;
-{
-	char buf[BFSZ], fbuf[BFSZ];
-	char bfr[BFSZ], *pbfr = bfr;
-	register char *p = NULL;
-	register FILE *pipe = stdout;
-	register int mode, frmflg, pathcnt, format;
-	char *index();
-
-	mode = SKIPPING;
-	frmflg = FALSE;
-	while (fgets(buf, BFSZ, stdin) != NULL) {
-#ifdef debug
-		printf("%o\t%s", mode|type(buf), buf);
-#endif
-		switch (mode | type(buf)) {
-
-		case FROM | SKIPPING:
-			if (frmflg)
-				p = frombreak(p, buf);
-			else
-				p = fbuf;
-			frmflg = TRUE;
-			break;
-
-		case FROM | READING:
-			if (!frmflg) {
-				frmflg = TRUE;
-				p = fbuf;
-				pclose(pipe);
-			}
-			p = frombreak(p, buf);
-			break;
-
-		case NLIN | SKIPPING:
-			if ((isupper(buf[1]) && index(buf, ':')) || !strncmp(buf, "From ", 5))
-				format = B;
-			else
-				format = A;
-#ifdef debug
-			printf("format = %d\n", format);
-#endif
-			mode = READING;
-
-		case NLIN | READING:
-			if (frmflg) {
-				frmflg = FALSE;
-				--p;
-				while (p >= fbuf && *--p != '!')
-					;
-				*++p = '\0';
-				pathcnt = 0;
-#ifdef IHCC
-				sprintf(pbfr, "%s/%s/%s", logdir(HOME),
-						LIBDIR, "rnews");
-#else
-				pbfr = RNEWS;
-#endif
-				if ((pipe = popen(pbfr, "w")) == NULL) {
-					perror("uurec: popen failed");
-					exit(1);
-				}
-			}
-			if (format == A) {
-				if (++pathcnt == 3)
-					fputs(fbuf, pipe);
-				fputs(buf+1, pipe);
-			} else {
-				if (!pathcnt && (!strncmp(buf+1, "From: ", 6) || !strncmp(buf+1, "From ", 5))) {
-					pathcnt++;
-					fprintf(pipe, "From: %s", fbuf);
-					sscanf(buf, "%s %[^\n]", fbuf, fbuf);
-					fprintf(pipe, "%s\n", fbuf);
-				} else
-					fputs(buf+1, pipe);
-			}
-			break;
-
-		case OTHER | SKIPPING:
-			break;
-
-		case OTHER | READING:
-			pclose(pipe);
-			mode = SKIPPING;
-		}
-	}
-	if (pipe)
-		pclose(pipe);
-	exit(0);
-}
-
-type(p)
-register char *p;
-{
-	while (*p == ' ' || *p == '?')
-		++p;
-
-	if (*p == 'N')
-		return (NLIN);
-
-	if (strncmp(p, ">From ", 6) == 0)
-		return (FROM);
-
-	if (strncmp(p, "From ", 5) == 0)
-		return (FROM);
-
-	return(OTHER);
-}
-
-/*
- * Get the system name out of a from line.
- */
-char *
-frombreak(buf, fbuf)
-register char *buf, *fbuf;
-{
-	register char *p;
-
-	/* break the line into tokens. */
-	p = fbuf;
-	while (*++p != '\0')
-		switch (*p) {
-		case '\n':
-		case '\t':
-		case ' ':
-			*p = '\0';
-			break;
-		case EOT:
-			goto garbled;
-		default:;
-		}
-	*++p = EOT;
-	*++p = '\0';
-
-	for (p=fbuf; *p != EOT  || p[1] != '\0'; p += strlen(p)+1) {
-		if (strcmp(p, "forwarded") == 0)
-			return(buf);
-		if (strcmp(p, "remote") == 0) {
-			p += strlen(p)+1;
-			if (strcmp(p, "from") == 0) {
-				p += strlen(p)+1;
-				strcpy(buf, p);
-				strcat(buf, "!");
-				return(buf+strlen(buf));
-			}
-		}
-	}
-    garbled:
-	strcat(buf, "???!");
-	return(buf+4);
-}
*-*-END-of-src/uurec.c-*-*
echo x - src/checkgroups.sh 1>&2
sed 's/.//' >src/checkgroups.sh <<'*-*-END-of-src/checkgroups.sh-*-*'
-: check active file for missing or extra newsgroups
-: '@(#)checkgroups	1.17	10/29/86'
-
-if  test  ! -s LIBDIR/newsgroups
-then
-	cp /dev/null LIBDIR/newsgroups
-fi
-# Read first line of stdin.  If of the form "-n group", then only check
-# for the specified group.  Otherwise, assume doing standard groups
-sed -e '/^[a-zA-Z-]*: /d' -e '/^$/d' -e '/^[#:]/d' | (
-read line
-case "${line}" in
--n*)
-	# Doing specific group.  extract group name and preserve
-	# all of current newsgroups file except for that group.
-	# Then append entries for this group.
-	group=`echo "${line}" | sed -e 's/-n /^/' -e 's/$/\\\\./'`
-	egrep -v "${group}" LIBDIR/newsgroups > /tmp/$$a
-	cat /tmp/$$a - > LIBDIR/newsgroups
-	;;
-*)
-	group="^net\\.|^mod\\.|^comp\\.|^sci\\.|^rec\\.|^news\\.|^soc\\.|^misc\\.|^talk\\."
-	egrep -v "${group}" LIBDIR/newsgroups > /tmp/$$a
-	cat /tmp/$$a > LIBDIR/newsgroups
-	cat >> LIBDIR/newsgroups
-	;;
-esac
-
-egrep "${group}" LIBDIR/active | sed 's/ .*//' | sort >/tmp/$$active
-egrep "${group}" LIBDIR/newsgroups | sed 's/	.*//' | sort >/tmp/$$newsgroups
-
-comm -13 /tmp/$$active /tmp/$$newsgroups >/tmp/$$missing
-comm -23 /tmp/$$active /tmp/$$newsgroups >/tmp/$$remove
-
-egrep "${group}" LIBDIR/active | sed -n "/m\$/s/ .*//p" |
-	sort > /tmp/$$active.mod.all
-egrep "${group}" LIBDIR/newsgroups |
-sed -n "/Moderated/s/[ 	][ 	]*.*//p" | sort > /tmp/$$newsg.mod
-
-comm -12 /tmp/$$missing /tmp/$$newsg.mod >/tmp/$$add.mod
-comm -23 /tmp/$$missing /tmp/$$newsg.mod >/tmp/$$add.unmod
-cat /tmp/$$add.mod /tmp/$$add.unmod >>/tmp/$$add
-
-comm -23 /tmp/$$active.mod.all /tmp/$$remove >/tmp/$$active.mod
-comm -13 /tmp/$$newsg.mod /tmp/$$active.mod >/tmp/$$ismod
-comm -23 /tmp/$$newsg.mod /tmp/$$active.mod >/tmp/$$notmod.all
-comm -23 /tmp/$$notmod.all /tmp/$$add >/tmp/$$notmod
-
-if test -s /tmp/$$remove
-then
-	(
-	echo "The following newsgroups are not valid and should be removed."
-	sed "s/^/	/" /tmp/$$remove
-	echo ""
-	echo "You can do this by executing the command:"
-	echo \	LIBDIR/rmgroup `cat /tmp/$$remove`
-	echo ""
-	) 2>&1 >/tmp/$$out
-fi
-
-if test -s /tmp/$$add
-then
-	(
-	echo "The following newsgroups were missing and should be added."
-	sed "s/^/	/" /tmp/$$add
-	echo ""
-	echo "You can do this by executing the command(s):"
-	for i in `cat /tmp/$$add.unmod`
-	do
-		echo 'LIBDIR/inews -C '$i' </dev/null'
-	done
-	for i in `cat /tmp/$$add.mod`
-	do
-		echo 'LIBDIR/inews -C '$i' moderated </dev/null'
-	done
-	echo ""
-	) 2>&1 >>/tmp/$$out
-fi
-
-if test -s /tmp/$$ismod
-then
-	(
-	echo "The following newsgroups are not moderated and are marked moderated."
-	sed "s/^/	/" /tmp/$$ismod
-	echo ""
-	echo "You can correct this by executing the command(s):"
-	for i in `cat /tmp/$$ismod`
-	do
-		echo 'LIBDIR/inews -C '$i' </dev/null'
-	done
-	echo ""
-	) 2>&1 >>/tmp/$$out
-fi
-
-if test -s /tmp/$$notmod
-then
-	(
-	echo "The following newsgroups are moderated and not marked so."
-	sed "s/^/	/" /tmp/$$notmod
-	echo ""
-	echo "You can correct this by executing the command(s):"
-	for i in `cat /tmp/$$notmod`
-	do
-		echo 'LIBDIR/inews -C '$i' moderated </dev/null'
-	done
-	echo ""
-	) 2>&1 >>/tmp/$$out
-fi
-
-if test -s /tmp/$$out
-then
-	(echo	"Subject: Problems with your active file"
-	echo ""
-	cat /tmp/$$out
-	) | if test $# -gt 0
-		then
-			mail $1
-		else
-			cat
-		fi	
-fi
-)
-
-rm -f /tmp/$$*
*-*-END-of-src/checkgroups.sh-*-*
echo x - src/encode.c 1>&2
sed 's/.//' >src/encode.c <<'*-*-END-of-src/encode.c-*-*'
-#include <stdio.h>
-
-#ifdef SCCSID
-static char	*SccsId = "@(#)encode.c	1.3	5/15/85";
-#endif /* SCCSID */
-
-/*
- * Produce a 7 bit printable encoding of stdin on stdout.
- *
- * Encoding uses acsii chars from ' ' .. 'z'
- * (040 .. 0172) (0x20 - 0x7a) inclusive
- *
- * Method is to expand 3 chars -> 4 6 bit ones.
- * Then collect 13 6 bit chars, and spread the 13th over
- * the preceding 12, so that each of the 12 chars is now
- * 6.5 bits.  These 2 6.5 bit chars are a little hard
- * to represent on most common machines (one of these days
- * sane hosts will have 1/2 bits just for this program)
- * so we take a pair of them, and represent that in 13 bits.
- * 13 bits (max value 8191) can be represented as
- *	A * 91 + B
- * where A < 91, B < 91  (91^2 == 8281, so it fits!)
- *
- * Each of A and B is encoded as a character by adding 32
- * to make it printable (ie: 0x20).
- *
- * The termination conditions are foul beyond belief.  Don't
- * monkey with them!
- *
- * If you think its a fluke that 040 .. 0171 just happen to
- * be the chars that Piet Beertema's uucp 'f' protocol transmits
- * as single bytes, you're insane.  0172 chars are produced
- * with lower frequency than any other (given random data)
- * so the doubling that occurs with that we will just suffer.
- * (A newer 'f' proto, sometime, will probably not use 0172)
- */
-
-/*
- * the following pair of characters cannot legally occur
- * in normal output (since 90*91 + 90 == 8280, which > 2^13)
- * so we use them to indicate that the data that follows is the
- * terminator.  The character immediately following this
- * pair is the length of the (expanded) terminator (which
- * otherwise might be indeterminable)
- */
-#define	ENDMARK1	((90*91 + 90) / 91 + ' ')
-#define	ENDMARK2	((90*91 + 90) % 91 + ' ')
-
-main()
-{
-	register char *p;
-	register char *e;
-	register c;
-	char b3[3];
-
-	p = b3;
-	e = b3 + 3;
-	while ((c = getchar()) != EOF) {
-		*p++ = c;
-		if (p == e) {
-			encode(b3, 3);
-			p = b3;
-		}
-	}
-	encode(b3, p - b3);
-	flushout();
-	exit(0);
-}
-
-static char b13[13];
-static int cnt = 0;
-
-encode(c, n)
-	register char *c;
-	int n;
-{
-	register char *p;
-	register i = cnt;
-	register j;
-	char b4[4];
-
-	p = b4;
-
-	p[0] = (c[0] >> 2) & 0x3f;
-	p[1] = ((c[0] & 0x3) << 4) | ((c[1] >> 4) & 0xf);
-	p[2] = ((c[1] & 0xF) << 2) | ((c[2] >> 6) & 0x3);
-	if (n == 3)
-		p[3] = c[2] & 0x3f;
-	else
-		p[3] = n;
-
-	c = &b13[i];
-	for (j = 4; --j >= 0; i++) {
-		if (i == 13) {
-			dumpcode(b13, 13);
-			c = b13;
-			i = 0;
-		}
-		*c++ = *p++;
-	}
-	cnt = i;
-}
-
-flushout()
-{
-	putchar(ENDMARK1);
-	putchar(ENDMARK2);
-	putchar(cnt + ' ');
-	dumpcode(b13, cnt);
-}
-
-dumpcode(p, n)
-	register char *p;
-	register int n;
-{
-	register last;
-	register c;
-
-	if (n == 13)
-		n--, last = p[12];
-	else if (n & 1)
-		last = (1 << (6-1));
-	else
-		last = 0;
-
-	for ( ; n > 0; n -= 2) {
-		c = *p++ << 6;
-		c |= *p++;
-		if (last & (1 << (6-1)))
-			c |= (1 << 12);
-		last <<= 1;
-
-		/*
-		 * note: 91^2 > 2^13, 90^2 < 2^13, (91 + ' ') is printable
-		 */
-
-		/* oh for a compiler that would only do one division... */
-		putchar((c / 91) + ' ');
-		putchar((c % 91) + ' ');
-	}
-}
*-*-END-of-src/encode.c-*-*
echo x - src/caesar.c 1>&2
sed 's/.//' >src/caesar.c <<'*-*-END-of-src/caesar.c-*-*'
-/*
- * program to to decrypt caesar(tm) cypher
- * (caesar is a trademark of the roman empire)
- *
- * to compile:
- *
- *	cc decrypt.c -lm -o decrypt.c
- *
- * usage:
- *
- *	decrypt [n] < file
- *
- * where n is an optional forced rotation.
- *
- * authors: Stan King, John Eldridge, based on algorithm suggested by
- *		Bob Morris
- * 29-Sep-82
- *
- */
-
-#ifdef SCCSID
-static char	*SccsId = "@(#)caesar.c	1.7	4/16/85";
-#endif /* SCCSID */
-
-#include <stdio.h>
-#include <ctype.h>
-#include <math.h>
-extern char *calloc();
-
-main(argc, argv)
-int argc;
-char *argv[];
-{
-	/* letter frequencies (taken from some unix(tm) documentation) */
-	/* (unix is a trademark of Bell Laboratories) */
-	static double stdf[ 26 ] =
-	{
-		7.97, 1.35, 3.61, 4.78, 12.37, 2.01, 1.46, 4.49,
-		6.39, 0.04, 0.42, 3.81, 2.69, 5.92, 6.96, 2.91,
-		0.08, 6.63, 8.77, 9.68, 2.62, 0.81, 1.88, 0.23,
-		2.07, 0.06,
-	};
-	int obs[26];
-	int bufsize;
-	int c, i, try;
-	double dot, winnerdot;  /* .. */
-	int winner, forced = 0;
-	char *inbuf;
-
-	bufsize = 0;
-	if( argc > 1 )
-		sscanf( argv[1], "%d", &forced );
-	if( forced == 0 )
-		forced = -1000;
-		
-	inbuf = calloc( BUFSIZ, 1 );
-
-	/* adjust frequency table to weight low probs REAL low */
-	for (i=0; i<26; i++)	{
-		stdf[i] = log(stdf[i]) + log(26.0/100.0);
-	}
-
-	/* Decode each line separately */
-	for (;;) {
-		for (i=0; i<=25; obs[i++]=0)
-			;
-
-		/* get a sample of the text */
-		for( i = 0; i < BUFSIZ; i++ ) {
-			if( (c = getchar()) == EOF ) {
-				exit(0);
-			}	
-			inbuf[i] = c;
-			if (c == '\n') {
-				bufsize = i+1; 
-				break;
-			}
-			if (islower(c))
-				obs[c-'a'] += 1;
-			else if (isupper(c))
-				obs[c-'A'] += 1;
-		}
-
-		/* now "dot" the freqs with the observed letter freqs */
-		/*	and keep track of best fit */
-		winner = 0;	
-		for (try = 0; try<26; try+=13) {
-			dot = 0;
-			for ( i=0; i<26; i++ ) {
-				dot += obs[i] * stdf[ (i+try) % 26 ];
-				}
-			/* initialize winning score */
-			if( try == 0 )
-				winnerdot = dot;
-			if( dot > winnerdot ) {
-				/* got a new winner! */
-				winner = try;
-				winnerdot = dot;
-			}
-		}
-
-		if (forced != -1000)
-			winner = forced;
-
-		/* print out sample buffer */
-		for( i = 0; i < bufsize; i++ )
-			putchar( rotate( inbuf[i], winner ) );
-	}
- }
-
-
-static int
-rotate( c, perm )
-char c;
-int perm;
-{
-	if (isupper(c))	{
-		return 'A' + (c - 'A' + perm) % 26 ;
-	}
-	else if (islower(c)) {
-		return 'a' + (c-'a'+perm) % 26 ;
-	}
-	else return c;
-}
*-*-END-of-src/caesar.c-*-*
echo x - src/defs.dist 1>&2
sed 's/.//' >src/defs.dist <<'*-*-END-of-src/defs.dist-*-*'
-/*
- *	This software is Copyright (c) 1986 by Rick Adams.
- *
- *	Permission is hereby granted to copy, reproduce, redistribute or
- *	otherwise use this software as long as: there is no monetary
- *	profit gained specifically from the use or reproduction or this
- *	software, it is not sold, rented, traded or otherwise marketed, and
- *	this copyright notice is included prominently in any copy
- *	made.
- *
- *	The author make no claims as to the fitness or correctness of
- *	this software for any use whatsoever, and it is provided as is. 
- *	Any use of this software is at the user's own risk.
- *
- */
-
-/*	@(#)defs.dist	2.55	10/30/86	*/
-
-/*
- * defs.h - defines for news-related programs.
- *
- * If you remove any lines here or in your Makefile, make the change
- * to localize.sh so you won't have to redo it for each news release.
- *
- * If TMAIL is undefined, the -M option will be disabled.
- *
- * By convention, the version of the software you are running is taken
- * to be news_version below.
- */
-
-#define NEWS_VERSION   "B 2.11 10/30/86"
-
-#define DAYS	(60L*60L*24L)
-#define WEEKS	(7*DAYS)
-/* Things that very well may require local configuration */
-#ifndef HOME
-#define	ROOTID	10	/* uid of person allowed to cancel anything	*/
-#endif
-#define	N_UMASK 000	/* mask for umask call, 022 for secure system	*/
-#define DFLTEXP	2*WEEKS	/* default no. of seconds to expire in		*/
-#define HISTEXP	4*WEEKS	/* default no. of seconds to forget in		*/
-#define DFLTSUB "general,all.announce"	/* default subscription list	*/
-#define TMAIL	"/usr/ucb/Mail"	/* Mail program that understands -T	*/
-#define	ADMSUB	"general,all.announce"	/* Mandatory subscription list	*/
-#define PAGE	"/usr/ucb/more"	/* Default pager			*/
-#define NOTIFY	"usenet"	/* Tell him about certain ctl messages	*/
-				/* Default xmit command - remove -z if	*/
-#define DFTXMIT	"uux - -r -z %s!rnews < %s" /* your uux can't do it	*/
-#define UXMIT	"uux -r -z -c %s!rnews '<' %s" /* If uux -c is ok	*/
-#define DFTEDITOR "vi"		/* Default editor, see also postnews.	*/
-/* #define UUPROG "euuname"	/* omit for uuname, put in LIBDIR	*/
-#define MANUALLY		/* Don't execute rmgroups, just notify.	*/
-/* #define NONEWGROUPS		/* Don't create new groups, just notify.*/
-#define BATCH "unbatch"		/* name of unbatcher 		*/
-/* #define SPOOLNEWS		/* Spool incoming news, don't process	*/
-/* #define LOCALNAME 		/* There is no full name database. 	*/
-/* #define INTERNET		/* Internet mail works locally		*/
-#define MYDOMAIN ".UUCP"	/* Local domain				*/
-/* #define CHEAP		/* don't chown files to news		*/
-/* #define OLD			/* Add extra headers for old neighbors	*/
-/* #define UNAME		/* If uname call returns your nodename  */
-/* #define GHNAME		/* If gethostname call is available.	*/
-/* #define UUNAME "/etc/uucpname" /* If your nodename is stored in a file */
-#define V7MAIL			/* Local mail format is V7 ("From ")	*/
-#define SORTACTIVE		/* if you want news presented in the order of the .newsrc */
-#define ZAPNOTES		/* if you want old style notes headers moved into the headers */
-#define DIGPAGE			/* allow digestifying in vnews */
-/* #define DOXREFS		/* Generate xref line for rn to use */
-/* #define MULTICAST		/* If you want to be able to multicast news */
-/* #define BSD4_2		/* If you are running 4.2  or 4.3 BSD	*/
-/* #define BSD4_1C		/* If you are running 4.1C BSD		*/
-/* #define LOCKF		/* If you have the lockf() sys call */
-/* #define ALWAYSALIAS		/* temporary kludge for conversion */
-/* #define SENDMAIL "/usr/lib/sendmail" /* command line to run "sendmail" if you have it	*/
-/* #define MMDF	"/usr/mmdf/submit"	/* command line to run mmdf if you have it */
-#define MYORG "Frobozz Inc., St. Louis"	/* My organization.  Please	*/
-				/* include your city (and state, and	*/
-				/* country, if not obvious) in MYORG,	*/
-				/* and please keep it short.		*/
-/* #define HIDDENNET "frooz"	/* if you have a local network and want */
-				/* The mail address to look like it came */
-				/* from one machine */
-/* #define NICENESS	4	/* does a nice(NICENESS) in rnews */
-/* #define FASCIST	"all,!all.all"	/* only permit posting to certain groups */
-				/* see installation guide for details */
-/* #define SMALL_ADDRESS_SPACE	/* If your machine can't address > 32767 */
-/* #define ORGDISTRIB	"froozum"	/* For organization wide control message handling */
-
-/* Things you might want to change */
-#define NEWSRC  ".newsrc"	/* name of .newsrc file (in home dir)	*/
-#define LINES	512	/* maximum no. of lines in .newsrc		*/
-#define NEGCHAR	'!'	/* newsgroup negation character			*/
-#define DEADTIME 45	/* no. of seconds to wait on deadlock		*/
-#define FMETA	'%'	/* file meta-character for c option		*/
-#if defined(pdp11) || defined(SMALL_ADDRESS_SPACE)
-# define BUFLEN	128	/* standard buffer size				*/
-#else
-# define BUFLEN	256	/* standard buffer size				*/
-#endif
-#define LBUFLEN 1024	/* big buffer size				*/
-#define	SBUFLEN 32	/* small buffer size (for system names, etc)	*/
-#define LNCNT	14	/* Articles with > LNCNT lines go through pager */
-
-/* Things you probably won't want to change */
-#define PATHLEN 512	/* length of longest source string		*/
-#define	DATELEN	64	/* length of longest allowed date string	*/
-#define	NAMELEN	128	/* length of longest possible message ID	*/
-#define	SNLN	8	/* max significant characters in sysname	*/
-#define	PROTO	'A'	/* old protocol name				*/
-#define NETCHRS	"!:@^%,"/* Punct. chars used for various networks	*/
-#define	TRUE	1	/* boolean true					*/
-#define	FALSE	0	/* boolean false				*/
-#define	PERHAPS	2	/* indeterminate boolean value			*/
-#define	NGDELIM	','	/* delimit character in news group line		*/
*-*-END-of-src/defs.dist-*-*
exit

