From rick@seismo.CSS.GOV Fri Oct 16 18:23:27 1987
Path: seismo!rick
From: rick@seismo.CSS.GOV (Rick Adams)
Newsgroups: news.software.b
Subject: news 2.11 src patch #11
Message-ID: <44164@beno.seismo.CSS.GOV>
Date: 16 Oct 87 22:23:27 GMT
Organization: Center for Seismic Studies, Arlington, VA
Lines: 1951

Description:
	This is patch #11 for news 2.11 src.

	Fix problems with expire and sendbatch introduced in patch #10
	Fix lint and more xenix mods.
	A Sample localize.xenix is provided.
	recnews now takes a -a flag for moderated articles
	Code from Stan Barber to allow readnews/postnews/checknews/postnews
		to work with NNTP.

Fix:
	cd to the src directory and apply the following patch.

Index: localize.nntp
*** .d/localize.nntp	Thu Oct 15 18:37:31 1987
--- localize.nntp	Thu Oct 15 18:29:59 1987
***************
*** 0 ****
--- 1,92 ----
+ # 
+ # The file "localize.nntp" should be used as a starting point from which
+ # to build a localize.sh from which nntp-capable programs can be built.
+ # Basically, you can use the regular localize.sh you use and add those line
+ # that contain #NNTP, NNTPSRC and SERVERFILE to make it work.
+ # The string NNTPSRC should be replaced with the location of your nntp source
+ # directory. The string SERVERFILE should be replaced with the location of
+ # the serverfile. See the nntp (Version 1.4) instructions for more information.
+ # 
+ # You will need nntp version 1.4 to make full use of these programs. They
+ # make some use of the XHDR extenstion in nntp version 1.4.
+ # 
+ # You do not need to include any reference to the dbm library. DBM may remain
+ # undefined. You may also want to remove $(OTHERS) from the line in the
+ # Makefile that starts with "all:".
+ # 
+ # You may want to include the line that begins with #RESOLVE in localize.sh
+ # if you want to link against the resolver library. I use it on my suns.
+ # 
+ # You will need to create a "mailpaths" file on each host that uses these
+ # programs. See the regular news documenation for information on the
+ # mailpaths file.
+ # 
+ # PROBLEMS:
+ # 
+ # 1. Distribution checking is disabled in postnews. nntp does not provide this
+ # information, so postnews cannot check the article before posting.
+ # 
+ # 2. History file support is marginal. nntp does not provided direct access
+ # to the history file information. nntp can tell if an article is not avail-
+ # able, but you cannot know if it was cancelled or expired or has not arrived
+ # yet.
+ # 
+ # 3. The recording feature is available, but you have to implement it on each
+ # host that uses these programs. nntp does not provide this information from
+ # the server.
+ # 
+ # 4. sys file searching is disabled. Again, nntp does not provide access to 
+ # this information from the server.
+ # 
+ # 5. XHDR support is necessary for some functions to work. This can be rewritten
+ # to avoid this, but I have not done it yet.
+ # 
+ # FINALLY
+ # 
+ # If you have bug reports on the nntp hunks of code, please feel free to let
+ # me know about it. I will do my best to fix them and route the fixes 
+ # through Rick Adams for patch releases.
+ # 
+ # Stan Barber
+ # Baylor College of Medicine
+ # uucp: {hoptoad,killer,rice}!academ!sob
+ # Internet: sob@tmc.edu
+ # 
+ rm -f Makefile
+ cp Makefile.dst Makefile
+ chmod u+w Makefile
+ ed Makefile  <<'EOF'
+ g/^#BSD4_2 /s///
+ g/^#V7 /s///
+ g/^#NNTP /s///
+ g/^#RESOLVE /s///
+ g/^#USG /d
+ g/^#EXCELAN /d
+ g/=fork/d
+ g/^#VMS /d
+ g/^#BSD4_3 /d
+ g/^#BSD4_1 /d
+ g/^all:/s/$(OTHERS)//
+ g/#NOTVMS/s/#NOTVMS//
+ g/-DDBM/s/-DDBM//
+ g/-ldbm/s/-ldbm//
+ g/NNTPSRC/s/NNTPSRC/\/usr\/src\/nntp/
+ w
+ q
+ EOF
+ rm -f defs.h
+ cp defs.dist defs.h
+ chmod u+w defs.h
+ ed defs.h << 'EOF'
+ g/NNTPSRC/s/NNTPSRC/\usr\/src\/nntp/
+ g/SERVERFILE/s/SERVERFILE/\/usr\/lib\/news\/server/
+ w
+ q
+ EOF
+ echo "Be sure to make a login for usenet and create the group news"
+ echo "Also, be sure to alter Makefile and defs.h to reflect the"
+ echo "user name, id number, group name and group id number in the"
+ echo "places documented."
+ echo "Finally, please set your organization name in defs.h"
+ echo "Look for #define MYORG for the string to alter."
+ echo "Good Luck."
Index: nntp.c
*** .d/nntp.c	Thu Oct 15 18:37:35 1987
--- nntp.c	Thu Oct 15 18:30:01 1987
***************
*** 0 ****
--- 1,253 ----
+ /*
+  * This software is Copyright 1987 by Stan Barber. 
+  *
+  * Permission is hereby granted to copy, reproduce, redistribute or otherwise
+  * use this software as long as: there is no monetary profit gained
+  * specifically from the use or reproduction or this software, it is not
+  * sold, rented, traded or otherwise marketed, and this copyright notice is
+  * included prominently in any copy made. 
+  *
+  * The author make no claims as to the fitness or correctness of this software
+  * for any use whatsoever, and it is provided as is. Any use of this software
+  * is at the user's own risk. 
+  *
+  * this is a file full of functions used by the various news client programs 
+  */
+ #ifdef SCCSID
+ static char *SccsId = "@(#)nntp.c	2.2	10/15/87";
+ #endif	/* SCCSID */
+ 
+ #include "params.h"
+ 
+ static char *nntpserver;
+ static char ser_line[256];
+ static char active_file_name[512];
+ static char article_file_name[512];
+ static char last_group[256];
+ /*
+  * open_server open a connection to the server 
+  */
+ open_server()
+ {
+ 	int response;
+ 
+ 	/* open connection to nntpserver if appropriate */
+ 
+ 	nntpserver = getserverbyfile(SERVER_FILE);
+ 	if (nntpserver == NULL) {
+ 		fprintf(stderr, "Can't get the name of the news server from %s\n",
+ 			SERVER_FILE);
+ 		fprintf(stderr, "Either fix this file, or put NNTPSERVER in your environment.");
+ 		return -1;
+ 	}
+ 	response = server_init(nntpserver);
+ 	if (response < 0) {
+ 		fprintf(stderr, "Couldn't connect to %s news server, try again later.\n",
+ 			nntpserver);
+ 		return -1;
+ 	}
+ 	if (handle_server_response(response, nntpserver) < 0) {
+ 		fprintf(stderr, "Cannot handle response from nntpserver.\n");
+ 		return -1;
+ 	}
+ 	return 0;
+ }
+ 
+ /*
+  * open_active gets the active file and returns an open file descriptor to
+  * the calling program 
+  */
+ 
+ FILE *
+ open_active()
+ {
+ 	FILE *openfp;
+ 	bzero(active_file_name, sizeof(active_file_name));
+ 	put_server("LIST");	/* tell server we want the active file */
+ 	(void) get_server(ser_line, sizeof(ser_line));
+ 	if (*ser_line != CHAR_OK) {	/* and then see if that's ok */
+ 		xerror("Can't get active file from server: \n%s\n", ser_line);
+ 	}
+ 	strcpy(active_file_name, "/tmp/nsact.XXXXXX");
+ 	(void) mktemp(active_file_name);	/* make a temporary name */
+ 	openfp = fopen(active_file_name, "w+");	/* and get ready */
+ 	if (openfp == NULL)
+ 		return NULL;
+ 
+ 	while (get_server(ser_line, sizeof(ser_line)) >= 0) {	/* while */
+ 		if (ser_line[0] == '.' && strlen(ser_line) == 1)
+ 			/* there's another line */
+ 			break;	/* get it and write it to */
+ 		fputs(ser_line, openfp);
+ 		putc('\n', openfp);
+ 	}
+ 
+ 	fseek(openfp, 0L, 0);	/* just get to the beginning */
+ 
+ 	return openfp;
+ }
+ 
+ /*
+  * active_name() returns the name of the temporary file that contains the
+  * name of the current active file. 
+  */
+ 
+ char *
+ active_name()
+ {
+ 	if (active_file_name[0] == '\0')
+ 		return NULL;
+ 	return &active_file_name[0];
+ }
+ 
+ /*
+  * set_group() set the current group returns NULL if failure "string" if
+  * successful 
+  */
+ 
+ char *
+ set_group(newsgroup)
+ char *newsgroup;
+ {
+ 	char nntpbfr[256];
+ 	if (newsgroup == NULL || *newsgroup == '\0')
+ 		return NULL;
+ 	if (strcmp(newsgroup, last_group)) {
+ 		(void) sprintf(nntpbfr, "GROUP %s", newsgroup);
+ 		put_server(nntpbfr);
+ 		(void) get_server(ser_line, sizeof(ser_line));
+ 		if (*ser_line != CHAR_OK)
+ 			return NULL;
+ 		strcpy(last_group, newsgroup);
+ 	}
+ 	return &ser_line[0];
+ }
+ 
+ /*
+  * getarticle() returns an open file descriptor to the requested article. 
+  */
+ 
+ FILE *
+ getarticle(newsgroup, number, command)
+ char *newsgroup, *command;
+ int number;
+ {
+ 	FILE *fp;
+ 	char nntpbfr[256];
+ 	bzero(article_file_name, sizeof(article_file_name));
+ 	if (set_group(newsgroup) == NULL)
+ 		return NULL;
+ 	strcpy(article_file_name, "/tmp/nsart.XXXXXX");
+ 	if (mktemp(article_file_name) == NULL)
+ 		return NULL;
+ 	(void) sprintf(nntpbfr, "%s %ld", command, number);
+ 	put_server(nntpbfr);
+ 	(void) get_server(ser_line, sizeof(ser_line));
+ 	if (*ser_line != CHAR_OK)
+ 		return NULL;
+ 	if ((fp = fopen(article_file_name, "w+")) == NULL) {
+ 		/* and get ready */
+ 		sync_server();
+ 		return NULL;
+ 	}
+ 	while (get_server(ser_line, sizeof(ser_line)) >= 0) {	/* while */
+ 		if (ser_line[0] == '.' && strlen(ser_line) == 1)
+ 			/* there's another line */
+ 			break;	/* get it and write it to */
+ 		fputs(ser_line, fp);	/* the temp file */
+ 		putc('\n', fp);
+ 	}
+ 	fseek(fp, 0L, 0);	/* just get to the beginning */
+ 	return fp;
+ }
+ /*
+  * article_name() returns the name of the temporary file that contains the
+  * name of the current article file. 
+  */
+ 
+ char *
+ article_name()
+ {
+ 	if (article_file_name[0] == '\0')
+ 		return NULL;
+ 	return &article_file_name[0];
+ }
+ 
+ /*
+  * group_name() returns the name of the last group accessed from nntp 
+  */
+ 
+ char *
+ group_name()
+ {
+ 	if (last_group[0] == '\0')
+ 		return NULL;
+ 	return &last_group[0];
+ }
+ 
+ /*
+  * getartbyid retrieves an article by id number and returns an open file
+  * descriptor for that article 
+  */
+ 
+ FILE *
+ getartbyid(id)
+ char *id;
+ {
+ 	FILE *fp;
+ 	char nntpbfr[256];
+ 	(void) sprintf(nntpbfr, "ARTICLE %s", id);
+ 	put_server(nntpbfr);
+ 	(void) get_server(ser_line, sizeof(ser_line));
+ 	if (*ser_line != CHAR_OK) {
+ 		fprintf(stderr, "Cannot fetch article %s\n", id);
+ 		return NULL;
+ 	}
+ 	strcpy(article_file_name, "/tmp/nsart.XXXXXX");
+ 	if (mktemp(article_file_name) == NULL)
+ 		return NULL;
+ 	if ((fp = fopen(article_file_name, "w+")) == NULL) {
+ 		/* and get ready */
+ 		sync_server();
+ 		return NULL;
+ 	}
+ 	while (get_server(ser_line, sizeof(ser_line)) >= 0) {	/* while */
+ 		if (ser_line[0] == '.' && strlen(ser_line) == 1)
+ 			/* there's another line */
+ 			break;	/* get it and write it to */
+ 		fputs(ser_line, fp);	/* the temp file */
+ 		putc('\n', fp);
+ 	}
+ 	fseek(fp, 0L, 0);	/* just get to the beginning */
+ 	return fp;
+ }
+ 
+ /*
+  * sync_server gobbles up the rest of the server output until it sees the .
+  * on the beginning of a line by itself 
+  */
+ 
+ sync_server()
+ {
+ 	while (get_server(ser_line, sizeof(ser_line)) >= 0) {	/* while */
+ 		if (ser_line[0] == '.' && strlen(ser_line) == 1)
+ 			/* there's another line */
+ 			break;	/* get it and throw it away */
+ 	}
+ 
+ }
+ 
+ /*
+  * strindex returns location of tx in sx 
+  */
+ int
+ strindex(sx, tx)
+ char *sx, *tx;
+ {
+ 	int i, n;
+ 	n = strlen(tx);
+ 	for (i = 0; sx[i] != '\0'; i++)
+ 		if (strncmp(sx + i, tx, n) == 0)
+ 			return i;
+ 	return -1;
+ }
Index: Makefile.dst
Prereq: 1.24
*** .d/Makefile.dst	Wed Oct  7 16:47:57 1987
--- Makefile.dst	Thu Oct 15 19:06:04 1987
***************
*** 1,2 ****
! # '@(#)Makefile.dst	1.24	9/24/87'
  # Generic Makefile.
--- 1,2 ----
! # '@(#)Makefile.dst	1.26	10/15/87'
  # Generic Makefile.
***************
*** 35,36 ****
--- 35,39 ----
  SCCSID = -DSCCSID
+ 
+ #NNTP SERVER= -DSERVER 
+ 
  DEFS =	-DRNEWS=\"$(BINDIR)/rnews\" -DSPOOLDIR=\"$(SPOOLDIR)\" \
***************
*** 38,40 ****
  	-DBINDIR=\"$(BINDIR)\" -DNEWSUSR=\"$(NEWSUSR)\" \
! 	-DNEWSGRP=\"$(NEWSGRP)\"
  
--- 41,43 ----
  	-DBINDIR=\"$(BINDIR)\" -DNEWSUSR=\"$(NEWSUSR)\" \
! 	-DNEWSGRP=\"$(NEWSGRP)\" ${SERVER}
  
***************
*** 48,50 ****
  #V7 VFORK=-Dvfork=fork
! 
  #BSD4_1 VFORK=
--- 51,53 ----
  #V7 VFORK=-Dvfork=fork
! #EXCELAN NETINCLUDE= -I/usr/include/EXOS
  #BSD4_1 VFORK=
***************
*** 54,56 ****
  #USG IBMFLAGS =
! #USG CFLAGS = ${DEBUG} -O $(IBMFLAGS) -DUSG -Dindex=strchr -Drindex=strrchr ${DEFS} ${SCCSID} ${VFORK}
  #USG LFLAGS = ${DEBUG} -s -i $(IBMFLAGS)
--- 57,59 ----
  #USG IBMFLAGS =
! #USG CFLAGS = ${DEBUG} -O $(IBMFLAGS) -DUSG -Dindex=strchr -Drindex=strrchr ${DEFS} ${SCCSID} ${VFORK} ${NETINCLUDE}
  #USG LFLAGS = ${DEBUG} -s -i $(IBMFLAGS)
***************
*** 57,60 ****
  #USG LIBS =
! #USG LINTFLAGS = ${DEFS}
! #V7 CFLAGS = ${DEBUG} -O -DDBM ${DEFS} ${SCCSID} ${VFORK}
  #V7 LFLAGS = ${DEBUG}
--- 60,63 ----
  #USG LIBS =
! #USG LINTFLAGS = ${DEFS} ${NETINCLUDE}
! #V7 CFLAGS = ${DEBUG} -DDBM ${DEFS} ${SCCSID} ${VFORK} ${NETINCLUDE}
  #V7 LFLAGS = ${DEBUG}
***************
*** 61,63 ****
  #V7 LIBS = -ldbm
! #V7 LINTFLAGS = -chba -DDBM ${DEFS}
  #BSD4_1 LIBS = -ldbm -ljobs
--- 64,66 ----
  #V7 LIBS = -ldbm
! #V7 LINTFLAGS = -chba -DDBM ${DEFS} ${NETINCLUDE}
  #BSD4_1 LIBS = -ldbm -ljobs
***************
*** 64,65 ****
--- 67,71 ----
  
+ #EXCELAN NETLIB = -lsocket
+ #RESOLVE NETLIB = -lresolv
+ 
  TERMLIB = -ltermlib
***************
*** 75,78 ****
  
! #V7 MISC = uname.o
! #USG MISC = ftime.o
  OBJECTS = funcs.o funcs2.o header.o ndir.o $(MISC) getdate.o 
--- 81,85 ----
  
! #NNTP CLIENTLIB = clientlib.o nntp.o
! #V7 MISC = uname.o ${CLIENTLIB}
! #USG MISC = ftime.o ${CLIENTLIB}
  OBJECTS = funcs.o funcs2.o header.o ndir.o $(MISC) getdate.o 
***************
*** 89,90 ****
--- 96,99 ----
  
+ #NNTP CSRCS = NNTPSRC/common/clientlib.c nntp.c
+ 
  SRCS = funcs.c funcs2.c header.c
***************
*** 91,97 ****
  ISRCS = inews.c ifuncs.c iextern.c control.c fullname.c  $(SRCS)
! PSRCS = postnews.c rextern.c funcs.c
  RSRCS = readnews.c rfuncs.c rfuncs2.c rextern.c readr.c process.c  \
! 	digest.c $(SRCS)
  VSRCS = readnews.c rfuncs.c rfuncs2.c rextern.c process.c $(SRCS) \
! 	visual.c virtterm.c
  ESRCS = expire.c header.c funcs.c iextern.c \
--- 100,106 ----
  ISRCS = inews.c ifuncs.c iextern.c control.c fullname.c  $(SRCS)
! PSRCS = postnews.c rextern.c funcs.c $(CSRCS)
  RSRCS = readnews.c rfuncs.c rfuncs2.c rextern.c readr.c process.c  \
! 	digest.c $(SRCS) $(CSRCS)
  VSRCS = readnews.c rfuncs.c rfuncs2.c rextern.c process.c $(SRCS) \
! 	visual.c virtterm.c $(CSRCS)
  ESRCS = expire.c header.c funcs.c iextern.c \
***************
*** 101,102 ****
--- 110,113 ----
  
+ 
+ 
  UTILS = uurec recnews sendnews expire batch caesar recmail \
***************
*** 110,115 ****
  
! install: all help vnews.help
  	chmod 755 ./installit
! 	-mkdir $(DESTDIR)$(BINDIR)
! 	-mkdir $(DESTDIR)$(LIBDIR)
  	for i in $(COMMANDS); do \
--- 121,126 ----
  
! install: all help vnews.help installit
  	chmod 755 ./installit
! 	-test -d $(DESTDIR)$(BINDIR) || mkdir $(DESTDIR)$(BINDIR)
! 	-test -d $(DESTDIR)$(LIBDIR) || mkdir $(DESTDIR)$(LIBDIR)
  	for i in $(COMMANDS); do \
***************
*** 175,177 ****
  readnews:  $(P) $(ROBJECTS)
! 	$(CC) $(LFLAGS) $(ROBJECTS) -o readnews $(LIBS)
  #VMS 	mv readnews.exe readnews
--- 186,188 ----
  readnews:  $(P) $(ROBJECTS)
! 	$(CC) $(LFLAGS) $(ROBJECTS) -o readnews $(LIBS) $(NETLIB)
  #VMS 	mv readnews.exe readnews
***************
*** 178,179 ****
--- 189,196 ----
  
+ #NNTP clientlib.o: NNTPSRC/common/clientlib.c
+ #NNTP 	$(CC) $(CFLAGS) -c NNTPSRC/common/clientlib.c
+ 
+ #NNTP nntp.o: nntp.c
+ #NNTP 	$(CC) $(CFLAGS) -c nntp.c
+ 
  funcs.o:  funcs.c params.h defs.h header.h Makefile
***************
*** 201,203 ****
  postnews: $(P) $(POBJECTS)
! 	$(CC) $(CFLAGS) $(LFLAGS) $(POBJECTS) -o postnews
  #VMS 	mv postnews.exe postnews
--- 218,220 ----
  postnews: $(P) $(POBJECTS)
! 	$(CC) $(CFLAGS) $(LFLAGS) $(POBJECTS) -o postnews $(NETLIB)
  #VMS 	mv postnews.exe postnews
***************
*** 204,207 ****
  
! postnews.o: postnews.c defs.h params.h header.h Makefile
! 	$(CC) $(CFLAGS) -c postnews.c
  
--- 221,224 ----
  
! postnews.o: postnews.c defs.h params.h header.h  Makefile
! 	$(CC) $(CFLAGS) -c postnews.c 
  
***************
*** 226,228 ****
  vnews:	$(P) $(VOBJECTS)
! 	$(CC) $(LFLAGS) $(VOBJECTS) $(TERMLIB) $(LIBS) -o $@
  #VMS 	mv vnews.exe vnews
--- 243,245 ----
  vnews:	$(P) $(VOBJECTS)
! 	$(CC) $(LFLAGS) $(VOBJECTS)  -o $@  $(TERMLIB) $(LIBS) $(NETLIB)
  #VMS 	mv vnews.exe vnews
***************
*** 248,250 ****
  
! recnews:  recnews.c defs.h header.h Makefile
  	$(CC) $(CFLAGS) $(LFLAGS) recnews.c -o recnews
--- 265,267 ----
  
! recnews:  recnews.c defs.h header.h params.h Makefile
  	$(CC) $(CFLAGS) $(LFLAGS) recnews.c -o recnews
***************
*** 283,286 ****
  
! checknews:  $(P) checknews.o process.o cpathinit.o rextern.o
! 	$(CC) $(LFLAGS) checknews.o process.o cpathinit.o rextern.o -o checknews
  #VMS 	mv checknews.exe checknews
--- 300,303 ----
  
! checknews:  $(P) checknews.o process.o cpathinit.o rextern.o $(NNTP) $(CLIENTLIB) 
! 	$(CC) $(LFLAGS) checknews.o process.o cpathinit.o rextern.o $(NNTP) $(CLIENTLIB) -o checknews $(NETLIB)
  #VMS 	mv checknews.exe checknews
Index: checknews.c
Prereq: 2.29
*** .d/checknews.c	Tue Apr  7 13:58:55 1987
--- checknews.c	Thu Oct 15 18:29:47 1987
***************
*** 18,20 ****
  #ifdef SCCSID
! static char	*SccsId = "@(#)checknews.c	2.29	4/6/87";
  #endif /* SCCSID */
--- 18,20 ----
  #ifdef SCCSID
! static char	*SccsId = "@(#)checknews.c	2.30	10/15/87";
  #endif /* SCCSID */
***************
*** 129,130 ****
--- 129,134 ----
  #endif
+ #ifdef SERVER
+ 	if (open_server() < 0)
+ 		xerror("NNTP connection failed.");
+ #endif /* SERVER */
  	ptr = getenv("NEWSRC");
***************
*** 213,217 ****
  	}
  	if ((actfp = fopen(ACTIVE, "r")) == NULL)
  		xerror("Cannot open active newsgroups file");
- 
  #ifdef DEBUG
--- 217,224 ----
  	}
+ #ifdef SERVER
+ 	if ((actfp = open_active(ACTIVE, "r")) == NULL)
+ #else /* !SERVER */
  	if ((actfp = fopen(ACTIVE, "r")) == NULL)
+ #endif /* !SERVER */
  		xerror("Cannot open active newsgroups file");
  #ifdef DEBUG
***************
*** 544,545 ****
--- 551,555 ----
  {
+ #ifdef SERVER
+ 	close_server();
+ #endif /* SERVER */
  	exit(i);
Index: defs.dist
Prereq: 2.58
*** .d/defs.dist	Wed Oct  7 16:50:11 1987
--- defs.dist	Thu Oct 15 18:29:48 1987
***************
*** 16,18 ****
  
! /*	@(#)defs.dist	2.58	4/10/87 	*/
  
--- 16,18 ----
  
! /*	@(#)defs.dist	2.59	10/15/87	*/
  
***************
*** 68,71 ****
  /* #define BSD4_2		/* If you are running 4.2  or 4.3 BSD	*/
! /* #define BSD4_1C		/* If you are running 4.1C BSD		*/
  /* #define LOCKF		/* If you have the lockf() sys call */
  /* #define ALWAYSALIAS		/* temporary kludge for conversion */
--- 68,75 ----
  /* #define BSD4_2		/* If you are running 4.2  or 4.3 BSD	*/
! /* #define BSD2_10		/* If you are running 2.10 BSD */
  /* #define LOCKF		/* If you have the lockf() sys call */
+ /* #define DOGETUSER		/* Always do 'getuser' so can't fake name */
+ /* #define LOGDIR		/* use the 'logdir' call on path lookups */
+ /* #define MKDIRSUB		/* your system has mkdir as a syscall */
+ /* #define READDIR		/* your system has readdir() in libc */
  /* #define ALWAYSALIAS		/* temporary kludge for conversion */
***************
*** 115 ****
--- 119,131 ----
  #define NGDELIM	','	/* delimit character in news group line		*/
+ 
+ /* for NNTP */
+ #ifdef SERVER
+ # include "NNTPSRC/common/response_codes.h"
+ # define SERVER_FILE "SERVERFILE"
+ #endif /* SERVER */
+ 
+ #ifdef M_XENIX
+ #define index	strchr
+ #define rindex	strrchr
+ #define	vfork	fork
+ #endif /* M_XENIX */
Index: expire.c
Prereq: 2.54
*** .d/expire.c	Thu Oct  8 00:22:29 1987
--- expire.c	Thu Oct 15 18:29:50 1987
***************
*** 19,21 ****
  #ifdef SCCSID
! static char	*SccsId = "@(#)expire.c	2.54	10/7/87";
  #endif /* SCCSID */
--- 19,21 ----
  #ifdef SCCSID
! static char	*SccsId = "@(#)expire.c	2.55	10/15/87";
  #endif /* SCCSID */
***************
*** 769,773 ****
  		(void) rename(ARTFILE, OARTFILE);
- #endif /* !DBM */
  		(void) rename(NARTFILE, ARTFILE);
- #ifdef DBM
  		if (dorebuild)
--- 769,771 ----
***************
*** 807,810 ****
  		if (i++ > 5) {
! 			error("Can't get lock for expire");
! 			exit(1);
  		}
--- 805,807 ----
  		if (i++ > 5) {
! 			xerror("Can't get lock for expire");
  		}
Index: funcs2.c
Prereq: 1.21
*** .d/funcs2.c	Thu Oct  8 00:20:34 1987
--- funcs2.c	Thu Oct 15 18:29:52 1987
***************
*** 19,21 ****
  #ifdef SCCSID
! static char	*SccsId = "@(#)funcs2.c	1.21	10/7/87";
  #endif /* SCCSID */
--- 19,21 ----
  #ifdef SCCSID
! static char	*SccsId = "@(#)funcs2.c	1.22	10/15/87";
  #endif /* SCCSID */
***************
*** 43,45 ****
  			xerror("Cannot get user's name");
! 		if ( username == NULL || username[0] == 0)
  			username = AllocCpy(p->pw_name);
--- 43,46 ----
  			xerror("Cannot get user's name");
! 		if ( username == NULL || username[0] == 0 ||
! 			STRCMP(username, "Unknown") == 0)
  			username = AllocCpy(p->pw_name);
***************
*** 51,52 ****
--- 52,55 ----
  
+ /* no sys file on clients via nntp */
+ #ifndef SERVER
  static	FILE	*sysfile;
***************
*** 185,186 ****
--- 188,190 ----
  }
+ #endif /* SERVER */
  
***************
*** 428,429 ****
--- 432,434 ----
  
+ 
  /*
***************
*** 441,442 ****
--- 446,452 ----
  	register char *p;
+ #ifdef SERVER
+ 	char workspace[256];
+ 	struct tm *tm;
+ 	long clock;
+ #else /* !SERVER */
  #ifdef DBM
***************
*** 448,450 ****
  #endif /* !DBM */
! 
  	/* Try to understand old artid's as well.  Assume .UUCP domain. */
--- 458,460 ----
  #endif /* !DBM */
! #endif /* !SERVER */
  	/* Try to understand old artid's as well.  Assume .UUCP domain. */
***************
*** 459,460 ****
--- 469,548 ----
  		(void) strcpy(oidbuf, artid);
+ #ifdef SERVER
+ 	(void) sprintf(lbuf,"STAT %s",oidbuf);
+ 	put_server(lbuf);
+ 	(void) get_server(workspace,sizeof(workspace));
+ 	if (*workspace != CHAR_OK)
+ 		return NULL;
+ 	(void) sprintf(lbuf,"XHDR xref %s",oidbuf);
+ 	put_server(lbuf);
+ 	(void) get_server(workspace,sizeof(workspace));	/* get response */
+ 	if (*workspace != CHAR_OK)
+ 		return NULL;		/* old style nntp */
+ 	(void) get_server(workspace,sizeof(workspace)); /* get header line */
+ 	sync_server();	/* get rid of the rest of it */
+ 	p = index(workspace,' ');
+ 	p++;
+ 
+ 	if (*p == '(') {	/* there is no xref line */
+ 		long s,sm;
+ 		FILE * af;
+ 		char n[100], buf[100], *name;
+ 		(void) sprintf(lbuf,"XHDR newsgroups %s",oidbuf);
+ 		put_server(lbuf);
+ 		(void) get_server(workspace,sizeof(workspace));
+ 		if (*workspace != CHAR_OK)
+ 			return NULL;
+ 		(void) get_server(workspace,sizeof(workspace));
+ 		sync_server();
+ 		if ((name = index(workspace,' ')) == NULL)
+ 			return NULL;
+ 		name++;
+ 		/* now we fetch the line from the active file */
+ 		af = xfopen(ACTIVE, "r");
+ 		while (fgets(buf, sizeof(buf), af) != NULL) {
+ 			if (sscanf(buf, "%s %ld %ld", n, &s, &sm) == 3 &&
+ 			     STRCMP(n, name) == 0) {
+ 				break;
+ 			}
+ 		}
+ 		(void) fclose(af);
+ 		/* now we ask for a message ids in that newsgroup */
+ 		if (set_group(name) == NULL)
+ 			return NULL;
+ 		(void) sprintf(lbuf, "XHDR message-id %d-%d", sm, s);
+ 		put_server(lbuf);
+ 		(void) get_server(workspace,sizeof(workspace));
+ 		if (*workspace != CHAR_OK)
+ 			return NULL;
+ 		while (	get_server(workspace,sizeof(workspace)) >= 0) {
+ 			if (*workspace == '.'  && strlen(workspace) == 1) 
+ 				return NULL;
+ 			if (strindex(workspace,oidbuf) > -1)
+ 				break;
+ 		}
+ 		sync_server();
+ 		*(index(workspace,' ')) = '\0';
+ 		(void) sprintf(lbuf, "%s/%s", n, workspace);
+ 		bzero(workspace,sizeof(workspace));
+ 		strcpy(workspace, lbuf);
+ 	} else {
+ 		bzero(lbuf, sizeof(lbuf));
+ 		strcpy(lbuf, p);
+ 		while (*p != '\0' && (p = index(lbuf,':')) != NULL) {
+ 			*p = '/';
+ 			p++;
+ 		}
+ 		strcpy(workspace, lbuf);
+ 	}
+ 	p = &workspace[0];
+ 	time(&clock);		
+ 	tm = localtime(&clock);
+ #ifdef USG
+ 	sprintf(lbuf, "%s\t%2.2d/%2.2d/%d %2.2d:%2.2d\t%s",
+ #else /* !USG */
+ 	sprintf(lbuf, "%s\t%02d/%02d/%d %02d:%02d\t%s",
+ #endif /* !USG */
+ 	oidbuf,tm->tm_mon,tm->tm_mday,tm->tm_year,tm->tm_hour,tm->tm_min,p);
+ 	return lbuf;		/* not really the same, but close */
+ #else	/* !SERVER */
  	lcase(oidbuf);
***************
*** 491,492 ****
--- 579,581 ----
  	return NULL;
+ #endif	/* !SERVER */
  }
***************
*** 537,539 ****
--- 626,638 ----
  	if (p) {
+ #ifdef SERVER
+ 	if ((rv = getartbyid(p)) != NULL) {
+ 		strcpy(fname, article_name());
+ 		(void) fclose(rv);
+ 		rv = NULL;
+ 	}
+ 	else
+ 		xerror("Cannot hfopen article %s", artid);
+ #else 	/* !SERVER */
  		(void) strcpy(fname, dirname(p));
+ #endif	/* !SERVER */
  		rv = fopen(fname, "r");	/* NOT xfopen! */
***************
*** 542,543 ****
--- 641,645 ----
  	}
+ #ifdef SERVER
+ 	(void) unlink(fname);
+ #endif /* !SERVER */
  	return rv;
***************
*** 544,547 ****
  }
! 
! #ifdef DBM
  /*
--- 646,649 ----
  }
! #ifndef SERVER
! # ifdef DBM
  /*
***************
*** 559,561 ****
  }
! #endif
  
--- 661,664 ----
  }
! # endif /* DBM */
! #endif	/* !SERVER */
  
Index: inews.c
Prereq: 2.81
*** .d/inews.c	Thu Oct  8 00:22:03 1987
--- inews.c	Thu Oct 15 18:29:58 1987
***************
*** 19,21 ****
  #ifdef SCCSID
! static char	*SccsId = "@(#)inews.c	2.81	10/7/87";
  #endif /* SCCSID */
--- 19,21 ----
  #ifdef SCCSID
! static char	*SccsId = "@(#)inews.c	2.82	10/15/87";
  #endif /* SCCSID */
***************
*** 28,32 ****
  
! #  ifdef F_RDLCK
  struct flock news_lock;
! #  endif /* F_RDLCK */
  # endif /* LOCKF */
--- 28,32 ----
  
! # if defined(F_RDLCK) && defined(F_SETLK)
  struct flock news_lock;
! #  endif /* F_RDLCK  && F_SETLK */
  # endif /* LOCKF */
***************
*** 138,140 ****
  #ifdef	LOCKF
! # ifdef	F_RDLCK
  	news_lock.l_type = F_RDLCK;
--- 138,140 ----
  #ifdef	LOCKF
! # if	defined(F_RDLCK) && defined(F_SETLK)
  	news_lock.l_type = F_RDLCK;
Index: installit
Prereq: 2.3
*** .d/installit	Wed Oct  7 16:53:08 1987
--- installit	Thu Oct 15 18:29:58 1987
***************
*** 2,4 ****
  #
! #	'@(#)installit	2.3	9/24/87'
  #	From install.sh	4.8	(Berkeley)	3/6/86
--- 2,4 ----
  #
! #	'@(#)installit	2.4	10/15/87'
  #	From install.sh	4.8	(Berkeley)	3/6/86
***************
*** 7,9 ****
  PATH=/bin:/etc:/usr/bin:/usr/ucb
! export BATH
  cmd=""
--- 7,9 ----
  PATH=/bin:/etc:/usr/bin:/usr/ucb
! export PATH
  cmd=""
Index: localize.xenix
*** .d/localize.xenix	Wed Oct  7 16:53:23 1987
--- localize.xenix	Thu Oct 15 18:30:00 1987
***************
*** 0 ****
--- 1,49 ----
+ #
+ #	This is correct for the
+ #		XENIX (empty) 5.0 iAPX286 1 1006 (empty)
+ #	version. There are so many versions of xenix out there
+ #	that it is probabably wrong for yours. At least this should give
+ #	you a starting point.
+ #
+ rm -f Makefile
+ cp Makefile.dst Makefile
+ chmod u+w Makefile
+ ed - Makefile  <<'EOF'
+ g/^#USG /s///
+ g/^#V7 /d
+ g/^#VMS /d
+ g/^#BSD4_[123] /d
+ g/#NOTVMS/s/#NOTVMS.*//
+ g/^MISC *=/s/$/ uname.o/
+ g/^UUXFLAGS/s//UUXFLAGS =/
+ g/^IBMFLAGS/s/$/ -M2l -LARGE -DM_XENIX/
+ g/^LIBS/s/$/ -lx -ldbm/
+ g/termlib/s//curses -ltermcap/
+ g/^LFLAGS =/s/$/ -F 8000 -m ${@}.map/
+ g/rm -f $(COMMANDS) $(OTHERS) \*.o a.out/s/a.out/\*.map a.out/
+ g/-o inews/s/-o/-m inews.map -F 5000 -o/
+ g/-o readnews/s/-o/-m readnews.map -F 3000 -o/
+ g/-o vnews /s/-o/-F 5000 -m vnews.map -o /
+ g/-o checknews/s/-o/-F E000 -o/
+ g/-o expire/s/-o/-F A000 -o/
+ g/-Dvfork=fork/s///
+ g/-Dindex=strchr/s///
+ g/-Drindex=strrchr/s///
+ g/^SCCSID/s/^/#/
+ w
+ q
+ EOF
+ 
+ rm -f defs.h
+ cp defs.dist defs.h
+ chmod u+w defs.h
+ ed - defs.h <<'EOF'
+ g/#define TMAIL/s//\/\* #define TMAIL/
+ g/\/usr\/ucb\/more/s//\/usr\/bin\/more/
+ g/uux - -r -z/s//uux - /
+ g/uucpname/s//systemid/
+ g/\/\* #define LOCKF/s//#define LOCKF/
+ g/\/\* #define UUNAME/s/...//
+ w
+ q
+ EOF
Index: ndir.c
Prereq: 1.11
*** .d/ndir.c	Tue Mar 24 13:51:46 1987
--- ndir.c	Thu Oct 15 18:30:00 1987
***************
*** 2,3 ****
--- 2,6 ----
  #if !defined(BSD4_2) && !defined(BSD4_1C) && !defined(HP9K5)
+ #ifdef M_XENIX
+ #include <sys/types.h>
+ #endif /* M_XENIX */
  #include <sys/param.h>
***************
*** 6,8 ****
  #ifdef SCCSID
! static char	*SccsId = "@(#)ndir.c	1.11	3/20/87";
  #endif /* SCCSID */
--- 9,11 ----
  #ifdef SCCSID
! static char	*SccsId = "@(#)ndir.c	1.12	10/15/87";
  #endif /* SCCSID */
Index: params.h
Prereq: 2.24
*** .d/params.h	Thu Oct  8 00:22:15 1987
--- params.h	Thu Oct 15 18:30:02 1987
***************
*** 4,6 ****
  
! /*	@(#)params.h	2.24	10/7/87	*/
  
--- 4,6 ----
  
! /*	@(#)params.h	2.25	10/15/87	*/
  
***************
*** 160 ****
--- 160,180 ----
  #define PREFIX(a,b)  ((*(a) != *(b)) ? FALSE : prefix((a)+1, (b)+1))
+ 
+ #ifdef SERVER
+ /* from clientlib.c */
+ extern	char	*getserverbyfile();
+ extern	int	server_init();
+ extern  void	put_server();
+ extern	int	get_server();
+ extern	void	close_server();
+ /* from nntp.c */
+ extern	FILE	*open_active();
+ extern	int	open_server();
+ extern	char	*set_group();
+ extern	char	*active_name();
+ extern	char	*group_name();
+ extern	FILE	*getarticle();
+ extern	FILE	*getartbyid();
+ extern	char	*article_name();
+ extern	void	sync_server();
+ extern	int	strindex();
+ #endif /* SERVER */
Index: patchlevel.h
*** .d/patchlevel.h	Thu Oct  8 00:22:21 1987
--- patchlevel.h	Thu Oct 15 18:30:17 1987
***************
*** 1,3 ****
! #define	PATCHLEVEL	10
  
! #define NEWS_VERSION   "B 2.11 10/07/87"
--- 1,3 ----
! #define	PATCHLEVEL	11
  
! #define NEWS_VERSION   "B 2.11 10/15/87"
Index: postnews.c
Prereq: 1.32
*** .d/postnews.c	Thu Oct  8 00:23:21 1987
--- postnews.c	Thu Oct 15 18:30:05 1987
***************
*** 19,21 ****
  #ifdef SCCSID
! static char	*SccsId = "@(#)postnews.c	1.32	10/7/87";
  #endif /* SCCSID */
--- 19,21 ----
  #ifdef SCCSID
! static char	*SccsId = "@(#)postnews.c	1.33	10/15/87";
  #endif /* SCCSID */
***************
*** 109,110 ****
--- 109,115 ----
  			}
+ #ifdef SERVER
+ 			if (getarticle(ng, num, "ARTICLE") == NULL)
+ 					goto nothere;
+ 			strcpy(original, article_name());
+ #else	/* !SERVER */
  			(void) sprintf(original, "%s/%s", SPOOL, ng);
***************
*** 115,117 ****
  			(void) strcat(original, num);
! 
  			if ((fd=open(original,0)) >= 0) {
--- 120,122 ----
  			(void) strcat(original, num);
! #endif	/* !SERVER */
  			if ((fd=open(original,0)) >= 0) {
***************
*** 126,127 ****
--- 131,135 ----
  			} else
+ #ifdef SERVER
+ nothere:
+ #endif	/* !SERVER */
  				printf("I can't find that article.\n");
***************
*** 234,236 ****
--- 242,246 ----
  	}
+ #ifndef SERVER
  	printf("For a list of newsgroups, type ?\n");
+ #endif	/* !SERVER */
  	n = 0;
***************
*** 245,246 ****
--- 255,257 ----
  				return TRUE;
+ #ifndef SERVER
  		if (buf[0] == '?'){
***************
*** 266,267 ****
--- 277,279 ----
  		}
+ #endif	/* !SERVER */
  		if (valid_ng(buf, &i, &i, &canpost)) {
***************
*** 345,346 ****
--- 357,361 ----
  
+ #ifdef SERVER
+ 		return;		/* can't do this yet */
+ #else	/* !SERVER */
  		/* Check that it's a proper distribution */
***************
*** 385,386 ****
--- 400,402 ----
  		}
+ #endif	/* !SERVER */
  	}
***************
*** 544,546 ****
  
! 	if (ngmatch(newsgroups, "rec.humor,!rec.humor.d")) {
  		if (askyes("Could this be offensive to anyone? ","")) {
--- 560,562 ----
  
! 	if (ngmatch(newsgroups, "rec.humor,!rec.humor.all")) {
  		if (askyes("Could this be offensive to anyone? ","")) {
***************
*** 742,744 ****
--- 758,769 ----
  	pathinit();
+ #ifdef SERVER
+ 	if (open_server() < 0) 
+ 		xerror("Server error");
+ 			/* do something to some up with distributions */
+ 	if ((fd = open_active()) == NULL)
+ 		xerror("Server error");
+ 	strcpy(ACTIVE,active_name());
+ #else	/* !SERVER */
  	(void) sprintf(buf, "%s/%s", LIB, "distributions");
+ 
  	fd = xfopen(buf, "r");
***************
*** 751,752 ****
--- 776,778 ----
  	}
+ #endif	/* !SERVER */
  	(void) fclose(fd);
Index: readnews.c
Prereq: 2.32
*** .d/readnews.c	Wed Oct  7 16:54:09 1987
--- readnews.c	Thu Oct 15 18:30:06 1987
***************
*** 5,7 ****
  #ifdef SCCSID
! static char	*SccsId = "@(#)readnews.c	2.32	3/21/87";
  #endif /* SCCSID */
--- 5,7 ----
  #ifdef SCCSID
! static char	*SccsId = "@(#)readnews.c	2.33	10/15/87";
  #endif /* SCCSID */
***************
*** 54,59 ****
  	gid = getgid();
! 	duid = 0;
! 	dgid = 0;
  	(void) ftime(&Now);
- 
  	/* give reasonable error message if SPOOL directory
--- 54,58 ----
  	gid = getgid();
! 	duid = geteuid();
! 	dgid = getegid();
  	(void) ftime(&Now);
  	/* give reasonable error message if SPOOL directory
***************
*** 62,64 ****
--- 61,67 ----
  	 */
+ #ifdef SERVER
+ 	if (open_server() < 0)
+ #else	/* !SERVER */
  	if (access(SPOOL, 05))
+ #endif	/* !SERVER */
  	{
***************
*** 67,69 ****
  	}
- 
  #ifndef SHELL
--- 70,71 ----
***************
*** 147,149 ****
  				optflag = FALSE;
! 			if (!strncmp(rcbuf, "options ", 8))
  				optflag = TRUE;
--- 149,151 ----
  				optflag = FALSE;
! 			if (!STRNCMP(rcbuf, "options ", 8))
  				optflag = TRUE;
***************
*** 219,226 ****
  	} else {
! 		int (* old)();
! 		if ((old = signal(SIGQUIT, SIG_IGN)) != SIG_IGN)
  			(void) signal(SIGQUIT, cleanup);
! 		if ((old = signal(SIGHUP, SIG_IGN)) != SIG_IGN)
  			(void) signal(SIGHUP, cleanup);
! 		if ((old = signal(SIGINT, SIG_IGN)) != SIG_IGN)
  			(void) signal(SIGINT, cleanup);
--- 221,227 ----
  	} else {
! 		if (signal(SIGQUIT, SIG_IGN) != SIG_IGN)
  			(void) signal(SIGQUIT, cleanup);
! 		if (signal(SIGHUP, SIG_IGN) != SIG_IGN)
  			(void) signal(SIGHUP, cleanup);
! 		if (signal(SIGINT, SIG_IGN) != SIG_IGN)
  			(void) signal(SIGINT, cleanup);
***************
*** 261,262 ****
--- 262,270 ----
  	}
+ #ifdef SERVER
+     if ((actfp = open_active()) == NULL)
+ 		xerror("Cannot open active newsgroups file");
+     strcpy(ACTIVE, active_name());
+     (void) fclose(actfp);
+     actfp = NULL;
+ #endif	/* !SERVER */
  	sortactive();
***************
*** 263,265 ****
  	actfp = xfopen(ACTIVE, "r");
- 
  #ifdef DEBUG
--- 271,272 ----
***************
*** 370,372 ****
  	for (p=index(string, first); p; p = index(p+1, first)) {
! 		if (((p==string) || (p[-1]!='!')) && strncmp(p, searchfor, strlen(searchfor)) == 0)
  			return TRUE;
--- 377,379 ----
  	for (p=index(string, first); p; p = index(p+1, first)) {
! 		if (((p==string) || (p[-1]!='!')) && STRNCMP(p, searchfor, strlen(searchfor)) == 0)
  			return TRUE;
Index: readr.c
Prereq: 2.62
*** .d/readr.c	Thu Oct  8 00:23:40 1987
--- readr.c	Fri Oct 16 14:58:24 1987
***************
*** 18,20 ****
  #ifdef SCCSID
! static char	*SccsId = "@(#)readr.c	2.62	10/7/87";
  #endif /* SCCSID */
--- 18,20 ----
  #ifdef SCCSID
! static char	*SccsId = "@(#)readr.c	2.64	10/16/87";
  #endif /* SCCSID */
***************
*** 46,48 ****
--- 46,50 ----
   */
+ #ifndef SERVER
  static char goodone[BUFLEN];		/* last decent article		*/
+ #endif	/* !SERVER */
  static char ogroupdir[BUFLEN];		/* last groupdir		*/
***************
*** 135,137 ****
--- 137,141 ----
  #endif
+ #ifndef SERVER
  		(void) strcpy(goodone, filename);
+ #endif	/* SERVER */
  		if (pflag || lflag || eflag) {
***************
*** 218,219 ****
--- 222,226 ----
  	long i;
+ #ifdef SERVER
+ 	char workspace[256];
+ #endif	/* !SERVER */
  
***************
*** 391,393 ****
  			(void) strcpy(bfr, groupdir);
! 			selectng(ogroupdir, TRUE, FALSE);
  			(void) strcpy(groupdir, ogroupdir);
--- 398,400 ----
  			(void) strcpy(bfr, groupdir);
! 			selectng(ogroupdir, FALSE, FALSE);
  			(void) strcpy(groupdir, ogroupdir);
***************
*** 439,441 ****
  		break;
! 
  	/* escape to shell */
--- 446,448 ----
  		break;
! #ifndef NOSHELL
  	/* escape to shell */
***************
*** 448,449 ****
--- 455,457 ----
  	/* mail reply */
+ #endif
  	case 'r':
***************
*** 835,836 ****
--- 843,845 ----
  	}
+ #ifndef SERVER
  	if (s_find(&srec, bptr) == 0) {
***************
*** 839,840 ****
--- 848,850 ----
  	}
+ #endif	/* !SERVER */
  	(void) transmit(&srec, tfilename);
***************
*** 964,965 ****
--- 974,978 ----
   	int noaccess;
+ #ifdef SERVER
+ 	char workspace[256];
+ #else	/* !SERVER */
   	register DIR *dirp;
***************
*** 966,967 ****
--- 979,981 ----
   	register struct direct *dir;
+ #endif	/* !SERVER */
   	long nextnum, tnum;
***************
*** 1022,1024 ****
--- 1036,1046 ----
  		rcreadok = 2;	/* have seen >= 1 article */
+ #ifdef SERVER
+ 	if ((fp = getarticle(groupdir, bit, "ARTICLE")) == NULL)
+ 		goto badart;
+ 	strcpy(filename, article_name());
+ 	(void) fclose(fp);
+ 	fp = NULL;
+ #else	/* !SERVER */
  	(void) sprintf(filename, "%s/%ld", dirname(groupdir), bit);
+ 
  	if (rfq && goodone[0])
***************
*** 1025,1026 ****
--- 1047,1049 ----
  		strcpy(filename, goodone);
+ #endif	/* !SERVER */
  	if (SigTrap) {
***************
*** 1056,1057 ****
--- 1079,1085 ----
  		noaccess = 0;
+ #ifdef SERVER
+ 		if (*groupdir == ' ' || *groupdir == '\0' || 
+ 			set_group(groupdir) == NULL)
+ 			goto badart;
+ #else	/* !SERVER */
   		dirp = opendir(dirname(groupdir));
***************
*** 1062,1064 ****
--- 1090,1107 ----
   		}
+ #endif	/* !SERVER */
   		nextnum = rflag ? minartno - 1 : ngsize + 1;
+ #ifdef SERVER 
+ 		tnum = nextnum;
+ 		for(;;){
+ 			(void) sprintf(bfr,"STAT %ld",tnum);
+ 			put_server(bfr);
+ 			(void) get_server(workspace,sizeof(workspace));
+ 			if (*workspace != CHAR_OK) {
+ 				if (rflag)
+ 					tnum++;
+ 				else
+ 					tnum--;
+ 				continue;
+ 			}
+ #else	/* !SERVER */
   		while ((dir = readdir(dirp)) != NULL) {
***************
*** 1067,1068 ****
--- 1110,1112 ----
   				continue;
+ #endif	/* !SERVER */
   			if (rflag ? (tnum > nextnum && tnum < bit)
***************
*** 1070,1073 ****
--- 1114,1122 ----
   				nextnum = tnum;
+ #ifdef SERVER
+ 			break;		/* not exactly right */
+ #endif	/* !SERVER */
   		}
+ #ifndef SERVER
   		closedir(dirp);
+ #endif	/* SERVER */
   		if (rflag ? (nextnum >= bit) : (nextnum <= bit))
***************
*** 1094,1095 ****
--- 1143,1145 ----
   badart:
+ #ifndef SERVER
  #ifdef DEBUG
***************
*** 1096,1098 ****
  		fprintf(stderr, "Bad article '%s'\n", filename);
! #endif
  		FCLOSE(fp);
--- 1146,1149 ----
  		fprintf(stderr, "Bad article '%s'\n", filename);
! #endif	/* DEBUG */
! #endif	/* !SERVER */
  		FCLOSE(fp);
***************
*** 1119,1120 ****
--- 1170,1174 ----
  	obit = bit;
+ #ifdef SERVER
+ 	(void) unlink(filename);
+ #endif	/* SERVER */
  	return 0;
***************
*** 1198,1199 ****
--- 1252,1257 ----
  #endif /* SORTACTIVE */
+ #ifdef SERVER
+ 	(void) unlink(active_name());
+ 	close_server();	
+ #endif	/* SERVER */
  	exit(status);
Index: recnews.c
Prereq:  2.13
*** .d/recnews.c	Wed Oct  7 16:54:32 1987
--- recnews.c	Thu Oct 15 18:30:09 1987
***************
*** 1,3 ****
  /*
!  * recnews [to newsgroup] [from user]
   *
--- 1,3 ----
  /*
!  * recnews [to newsgroup] [from user] [approved by]
   *
***************
*** 23,24 ****
--- 23,25 ----
   *		machine.)
+  *	in-gamemasters: "|/usr/lib/news/recnews mail.gamemasters '' news"
   *
***************
*** 35,37 ****
   * should not allow recnews (and thus the mail interface) to be used.
! *
   * 1) We leave the from line alone.  Just escape the double quotes, but let the
--- 36,38 ----
   * should not allow recnews (and thus the mail interface) to be used.
!  *
   * 1) We leave the from line alone.  Just escape the double quotes, but let the
***************
*** 41,42 ****
--- 42,46 ----
   *    Modifications by rad@tek
+  *
+  * John@ODU.EDU: add third argument to cause inews to be invoked with -a,
+  *		 for use with local groups for mailing lists with 2.11.
   */
***************
*** 44,46 ****
  #ifdef SCCSID
! static char	*SccsId = "@(#)recnews.c	2.13	10/23/86";
  #endif /* SCCSID */
--- 48,50 ----
  #ifdef SCCSID
! static char	*SccsId = "@(#)recnews.c	2.14	10/15/87";
  #endif /* SCCSID */
***************
*** 47,53 ****
  
! #include "defs.h"
  
- #include <stdio.h>
- #include <ctype.h>
- 
  /*
--- 51,54 ----
  
! #include "params.h"
  
  /*
***************
*** 90,91 ****
--- 91,93 ----
  char	newsgroup[BFSZ];	/* newsgroups of message */
+ char	approved[BFSZ];		/* Approved: */
  int	fromset;		/* from passed on command line */
***************
*** 93,95 ****
  
! extern	char	*strcat(), *strcpy();
  extern	FILE	*popen();
--- 95,97 ----
  
! extern	char	*strcat(), *strcpy(), *index();
  extern	FILE	*popen();
***************
*** 107,109 ****
  	/* build inews command */
! #ifdef IHCC
  	sprintf(inews, "%s/%s/%s", logdir(HOME), LIBDIR, "inews");
--- 109,111 ----
  	/* build inews command */
! #ifdef LOGDIR
  	sprintf(inews, "%s/%s/%s", logdir(HOME), LIBDIR, "inews");
***************
*** 117,118 ****
--- 119,123 ----
  		strcpy(from, argv[2]);
+ 	if (argc > 3 && *argv[3]) {
+ 		sprintf(approved,"-a %s", argv[3]);
+ 	}
  
***************
*** 189,193 ****
  			strcpy(newsgroup, to);
! 			sprintf(cmdbuf, "exec %s -t \"%s\" -n \"%s\" -f \"%s\"",
  				inews, *subject ? subject : "(none)",
! 				newsgroup, from);
  #ifdef debug
--- 194,199 ----
  			strcpy(newsgroup, to);
! 			sprintf(cmdbuf,
! 				"exec %s -t \"%s\" -n \"%s\" -f \"%s\" %s",
  				inews, *subject ? subject : "(none)",
! 				newsgroup, from, *approved ? approved : 0);
  #ifdef debug
***************
*** 216,219 ****
  			}
! 			sprintf(cmdbuf, "exec \"%s\" -t \"%s\" -n \"%s\" -f \"%s\"",
! 				inews, subject, newsgroup, from);
  #ifdef debug
--- 222,227 ----
  			}
! 			sprintf(cmdbuf,
! 				"exec \"%s\" -t \"%s\" -n \"%s\" -f \"%s\" %s",
! 				inews, subject, newsgroup, from,
! 				*approved ? approved : 0);
  #ifdef debug
***************
*** 252,261 ****
  		return BLANK;
! 	if (strncmp(p, ">From", 5) == 0 || strncmp(p, "From", 4) == 0)
  		return FROM;
! 	if (strncmp(p, "Subj", 4)==0 || strncmp(p, "Re:", 3)==0 ||
! 		strncmp(p, "re:", 3)==0)
  		return SUBJ;
! 	if (strncmp(p, "To", 2)==0)
  		return TO;
! 	if (strncmp(p, "\1\1\1\1", 4)==0)
  		return EOM;
--- 260,269 ----
  		return BLANK;
! 	if (STRNCMP(p, ">From", 5) == 0 || STRNCMP(p, "From", 4) == 0)
  		return FROM;
! 	if (STRNCMP(p, "Subj", 4)==0 || STRNCMP(p, "Re:", 3)==0 ||
! 		STRNCMP(p, "re:", 3)==0)
  		return SUBJ;
! 	if (STRNCMP(p, "To", 2)==0)
  		return TO;
! 	if (STRNCMP(p, "\1\1\1\1", 4)==0)
  		return EOM;
***************
*** 274,276 ****
  	register char *p, *q;
- 
  	if (fbuf[0] && fromset) {	/* we already know who it's from */
--- 282,283 ----
***************
*** 300,302 ****
  	q[-1] = '\0';
! 	if ((p=(char *)index(fbuf,'\n')) != NULL)
  		*p = '\0';
--- 307,309 ----
  	q[-1] = '\0';
! 	if ((p=index(fbuf,'\n')) != NULL)
  		*p = '\0';
Index: rfuncs.c
Prereq: 2.41
*** .d/rfuncs.c	Thu Oct  8 00:23:50 1987
--- rfuncs.c	Thu Oct 15 18:30:11 1987
***************
*** 18,20 ****
  #ifdef SCCSID
! static char	*SccsId = "@(#)rfuncs.c	2.41	10/7/87";
  #endif /* SCCSID */
--- 18,20 ----
  #ifdef SCCSID
! static char	*SccsId = "@(#)rfuncs.c	2.42	10/15/87";
  #endif /* SCCSID */
***************
*** 259,261 ****
  		while (bit <= ngsize) {
! 			(void) sprintf(filename, "%s/%ld", dirname(groupdir), bit);
  			if (access(filename, 4)
--- 259,277 ----
  		while (bit <= ngsize) {
! #ifdef SERVER
! 		if ((fp = getarticle(groupdir,bit,"ARTICLE")) != NULL) {
! 			strcpy(filename, article_name());
! 			(void) fclose(fp);
! 			fp = NULL;
! 		} else {
! #ifdef DEBUG
! 			fprintf(stderr, "Bad article '%s/%d'\n", groupdir,
! 					bit);
! #endif	/* DEBUG */
! 			clear(bit);
! 			nextbit();
! 			continue;
! 		}
! #else	/* !SERVER */
! 		(void) sprintf(filename, "%s/%ld", dirname(groupdir), bit);
! #endif	/* !SERVER */
  			if (access(filename, 4)
***************
*** 301,302 ****
--- 317,321 ----
  			(void) fclose(fp);
+ #ifdef SERVER
+ 			(void) unlink(filename); /* get rid of temp file */
+ #endif	/* SERVER */
  			fp = NULL;
***************
*** 624,625 ****
--- 643,645 ----
  	afp = xfopen(p, "r");
+ 
  #else /* !SORTACTIVE */
***************
*** 744,745 ****
--- 764,766 ----
  	struct hbuf hh;
+ #ifndef SERVER
  	register DIR *dirp;
***************
*** 746,747 ****
--- 767,769 ----
  	register struct direct *dir;
+ #endif	/* !SERVER */
  	register FILE *fp_art;
***************
*** 753,755 ****
  	char *gets();
! 
  	/* This should get the numbers from the active file XXX */
--- 775,792 ----
  	char *gets();
! #ifdef SERVER 
! 	int lowgp,highgp;
! 	char workspace[256];
! 	if (*lgroup == ' ' || *lgroup == '\0') return;
! 	strcpy(workspace, set_group(lgroup));
! 	if (*workspace != CHAR_OK) {	
! 		printf("Group %s is invalid: \n%s\n", lgroup, workspace);
! 		return;
! 	}
! 	/* We assume that the server will return a line of this format */
! 	(void) sscanf(workspace, "%s %ld %ld %ld", bfr, &i, &lowgp, &highgp);
! 	if (i == 0) {
! 		printf("There are no articles in %s\n", lgroup);
! 		return;
! 	}
! #else	/* !SERVER */
  	/* This should get the numbers from the active file XXX */
***************
*** 759,760 ****
--- 796,798 ----
  	}
+ #endif	/* !SERVER */
  	entries = 0;
***************
*** 765,766 ****
--- 803,807 ----
  	}
+ #ifdef SERVER
+ 	for(i = lowgp; i < highgp; i++){
+ #else	/* !SERVER */
  	while ((dir = readdir(dirp)) != NULL) {
***************
*** 769,770 ****
--- 810,812 ----
  		i = atoi(dir->d_name);
+ #endif	/* !SERVER */
  		if ((i < 1) || (i > pngsize))
***************
*** 793,795 ****
--- 835,848 ----
  	for (lg_entry = lg_array; *lg_entry != 0 && int_sig == 0; lg_entry++) {
+ #ifdef SERVER
+ /* we'll see if just getting the header will work here */
+ 	if ((fp_art = getarticle(lgroup, *lg_entry, "HEAD")) != NULL) {
+ 			strcpy(filename, article_name());
+ 			(void) fclose(fp_art);
+ 			fp_art = NULL;
+ 		}
+ 	else
+ 		continue;
+ #else	/* !SERVER */
  		(void) sprintf(filename, "%s/%d", dirname(lgroup), *lg_entry);
+ #endif	/* !SERVER */
  		fp_art = fopen(filename, "r");
***************
*** 815,816 ****
--- 868,872 ----
  		(void) fclose(fp_art);
+ #ifdef SERVER
+ 		(void) unlink(filename);
+ #endif	/* SERVER */
  	}
***************
*** 817,822 ****
  	(void) fflush(stdout);
! 
  	closedir(dirp);
  	(void) signal(SIGINT, old_sig);	/* restore to old value */
- 
  	printf("[Press RETURN to continue]");
--- 873,878 ----
  	(void) fflush(stdout);
! #ifndef SERVER
  	closedir(dirp);
+ #endif	/* !SERVER */
  	(void) signal(SIGINT, old_sig);	/* restore to old value */
  	printf("[Press RETURN to continue]");
***************
*** 840,841 ****
--- 896,898 ----
  }
+ #endif /* !SMALL_ADDRESS_SPACE */
  
***************
*** 849,850 ****
  }
- #endif /* !SMALL_ADDRESS_SPACE */
--- 906 ----
Index: sendbatch.sh
Prereq: 1.12
*** .d/sendbatch.sh	Thu Oct  8 00:23:53 1987
--- sendbatch.sh	Thu Oct 15 18:30:12 1987
***************
*** 1,2 ****
! : '@(#)sendbatch.sh	1.12	10/7/87'
  
--- 1,2 ----
! : '@(#)sendbatch.sh	1.13	10/15/87'
  
***************
*** 44,46 ****
  	testit="yes"
! 	while test $? -eq 0 -a \( \( -n "$testit" -s BATCHDIR/$rmt \) -o -s BATCHDIR/$rmt.work -o  \( -n "$DOIHAVE" -a -s BATCHDIR/$rmt.ihave \) \)
  	do
--- 44,46 ----
  	testit="yes"
! 	while test $? -eq 0 -a \( \( -n "$testit" -a -s BATCHDIR/$rmt \) -o -s BATCHDIR/$rmt.work -o  \( -n "$DOIHAVE" -a -s BATCHDIR/$rmt.ihave \) \)
  	do
Index: visual.c
Prereq: 1.37
*** .d/visual.c	Thu Oct  8 00:24:28 1987
--- visual.c	Thu Oct 15 18:30:17 1987
***************
*** 6,8 ****
  #ifdef SCCSID
! static char	*SccsId = "@(#)visual.c	1.37	10/7/87";
  #endif /* SCCSID */
--- 6,8 ----
  #ifdef SCCSID
! static char	*SccsId = "@(#)visual.c	1.38	10/15/87";
  #endif /* SCCSID */
***************
*** 151,153 ****
--- 151,155 ----
   */
+ #ifndef SERVER
  static char goodone[BUFLEN];		/* last decent article		*/
+ #endif	/* !SERVER */
  static char ogroupdir[BUFLEN];		/* last groupdir		*/
***************
*** 217,219 ****
--- 219,223 ----
  			break;
+ #ifndef SERVER
  		(void) strcpy(goodone, filename);
+ #endif	/* !SERVER */
  		if (SigTrap)
***************
*** 895,897 ****
--- 899,905 ----
  		}
+ #ifdef SERVER
+ 		(void) sprintf(bfr, "%s/%s", BIN, "postnews");
+ #else	/* !SERVER */
  		(void) sprintf(bfr, "%s/%s %s", BIN, "postnews", goodone);
+ #endif	/* !SERVER */
  		shcmd(bfr, CWAIT);
***************
*** 1020,1021 ****
--- 1028,1030 ----
  
+ #ifndef SERVER
  		of = xart_open(goodone, "r");
***************
*** 1028,1030 ****
--- 1037,1041 ----
  		putc('\n', rfp);
+ #endif		/* !SERVER */
  	}
+ 
  	fflush(rfp);
***************
*** 1132,1133 ****
--- 1143,1147 ----
  	int noaccess;
+ #ifdef SERVER
+ 	char workspace[256];
+ #else	/* !SERVER */
  	register DIR *dirp;
***************
*** 1134,1135 ****
--- 1148,1150 ----
  	register struct direct *dir;
+ #endif	/* !SERVER */
  	long nextnum, tnum;
***************
*** 1136,1138 ****
  	long atol();
- 
  	noaccess = 0;
--- 1151,1152 ----
***************
*** 1181,1182 ****
--- 1195,1203 ----
  		rcreadok = 2;	/* have seen >= 1 article */
+ #ifdef SERVER
+ 	if ((fp = getarticle(groupdir, bit, "ARTICLE")) == NULL)
+ 		goto badart;
+ 	strcpy(filename, article_name());
+ 	(void) fclose(fp);
+ 	fp = NULL;
+ #else	/* !SERVER */
  	(void) sprintf(filename, "%s/%ld", dirname(groupdir), bit);
***************
*** 1184,1185 ****
--- 1205,1207 ----
  		strcpy(filename, goodone);
+ #endif	/* !SERVER */
  	if (SigTrap == SIGHUP)
***************
*** 1194,1195 ****
--- 1216,1222 ----
  		noaccess = 0;
+ #ifdef SERVER
+ 		if (*groupdir == ' ' || *groupdir == '\0' || 
+ 			set_group(groupdir) == NULL)
+ 			goto nextart;
+ #else	/* !SERVER */
  		dirp = opendir(dirname(groupdir));
***************
*** 1200,1202 ****
--- 1227,1244 ----
  		}
+ #endif	/* !SERVER */
  		nextnum = rflag ? minartno - 1 : ngsize + 1;
+ #ifdef SERVER 
+ 		tnum = nextnum;
+ 		for(;;){
+ 			(void) sprintf(bfr,"STAT %ld",tnum);
+ 			put_server(bfr);
+ 			(void) get_server(workspace,sizeof(workspace));
+ 			if (*workspace != CHAR_OK) {
+ 				if (rflag)
+ 					tnum++;
+ 				else
+ 					tnum--;
+ 				continue;
+ 			}
+ #else	/* !SERVER */
  		while ((dir = readdir(dirp)) != NULL) {
***************
*** 1207,1208 ****
--- 1249,1251 ----
  				continue;
+ #endif	/* !SERVER */
  			if (rflag ? (tnum > nextnum && tnum < bit)
***************
*** 1210,1213 ****
--- 1253,1261 ----
  				nextnum = tnum;
+ #ifdef SERVER
+ 			break;		/* not exactly right */
+ #endif	/* SERVER */
  		}
+ #ifndef SERVER
  		closedir(dirp);
+ #endif	/* !SERVER */
  		if (rflag ? (nextnum >= bit) : (nextnum <= bit))
***************
*** 1249,1250 ****
--- 1297,1301 ----
  	obit = bit;
+ #ifdef SERVER
+ 	(void) unlink(filename);
+ #endif	/* SERVER */
  	return 0;
***************
*** 2645,2646 ****
--- 2696,2701 ----
  #endif /* SORTACTIVE */
+ #ifdef SERVER
+ 	(void) unlink(active_name());
+ 	close_server();	
+ #endif	/* SERVER */
  	if (ospeed) {	/* is == 0, we haven't been in raw mode yet */


