Subject:  v07i028:  A collection of tools for TeX users, Part01/02
Newsgroups: mod.sources
Approved: mirror!rs

Submitted by: Kamal Al-Yahya <kamal@hanauma.Stanford.EDU>
Mod.sources: Volume 7, Issue 28
Archive-name: textools/Part01

#!/bin/sh
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
# If all goes well, you will see the message "No problems found."
# Wrapped by mirror!rs on Mon Sep 15 00:26:36 EDT 1986

# Exit status; set to 1 on "wc" errors or if would overwrite.
STATUS=0
# Contents:  Manifest README TEX TEX.1 TeXExpand.c TeXMatch.c detex.1
#	detex1.c detex2.c inc_file inc_file2.tex makefile makefile.par
#	testfile texeqn.1 texeqn1.c texeqn2.c texexpand.1 texspell
 
echo x - Manifest
if test -f Manifest ; then
    echo Manifest exists, putting output in $$Manifest
    OUT=$$Manifest
    STATUS=1
else
    OUT=Manifest
fi
sed 's/^X//' > $OUT <<'@//E*O*F Manifest//'
XManifest
XREADME
XTEX
XTEX.1
XTeXExpand.c
XTeXMatch.c
Xdetex.1
Xdetex1.c
Xdetex2.c
Xinc_file
Xinc_file2.tex
Xmakefile
Xmakefile.par
Xtestfile
Xtexeqn.1
Xtexeqn1.c
Xtexeqn2.c
Xtexexpand.1
Xtexexpand1.c
Xtexexpand2.c
Xtexmatch.1
Xtexmatch1.c
Xtexmatch2.c
Xtexspell
Xtrmatch.1
Xtrmatch.c
@//E*O*F Manifest//
chmod u=rw,g=rw,o=rw $OUT
 
echo x - README
if test -f README ; then
    echo README exists, putting output in $$README
    OUT=$$README
    STATUS=1
else
    OUT=README
fi
sed 's/^X//' > $OUT <<'@//E*O*F README//'
XThis directory contains some filters that were developed at the
XStanford Exploration Project, Geophysics Department, by Kamal Al-Yahya.
XJoe Dellinger gave valuable suggestions to improve the warning messages.
XCopying them to any other machine is permitted without prior permission.

XThe main programs have names that end with either 1 or 2 (e.g. detex1.c,
Xdetex2.c). Those ending with 2 are used in makefile.par and can
Xbe used only by those who have getpar(). This enables them to use
Xin=  and out=  for input and output files specifications in addition
Xto what can be done in files ending with 1.

XThe following files should be in this directory:

XREADME		this file
Xtestfile	a file that demonstrates how these programs work
Xinc_file	an include file that is opened by testfile
Xinc_file2.tex	another include file.
Xmakefile	what else but a makefile
Xmakefile.par	a makefile that assumes you have access to getpar().
Xdetex1.c	strips TeX's commands from the document
Xdetex2.c	same as detex1.c but assumes you have access to getpar().
Xtexeqn1.c	picks displayed equations from a document
Xtexeqn2.c	same as texeqn1.c but assumes you have access to getpar().
Xtexexpand1.c	expands the document by opening \input and \include files
Xtexexpand2.c	same as texexpand1.c but assumes you have access to getpar().
Xtexmatch1.c	checks for matching braces, brackets, parentheses, and dollar signs
Xtexmatch2.c	same as texmatch1.c but assumes you have access to getpar().
XTeXExpand.c	subroutine to expand the document
XTeXMatch.c	subroutine that checks the matching
XTEX		a shell that can be used to run all TeX processing
Xdetex.1		manual page for detex
Xtexeqn.1	manual page for texeqn
Xtexexpand.1	manual page for texexpand
Xtexmatch.1	manual page for texmatch


XFeedbacks are welcome. E-mail: try any of these

X		kamal%hanauma@su-shasta
X		kamal%hanauma@su-score
X		kamal%hanauma@su-gregoria
X		kamal%erebus@su-shasta
@//E*O*F README//
chmod u=rw,g=rw,o=rw $OUT
 
echo x - TEX
if test -f TEX ; then
    echo TEX exists, putting output in $$TEX
    OUT=$$TEX
    STATUS=1
else
    OUT=TEX
fi
sed 's/^X//' > $OUT <<'@//E*O*F TEX//'
X#! /bin/csh -f
X#
X# Usage: TEX [-flags ...] filename
X#
X# The various flags are described below, but only one filename should
X# be given; stdin is not used. File types are indicated by the filename
X# suffix. Input files may have one of the following suffixes:
X#	.tex -- a file with tex commands, equations.
X#	.dvi -- device independent format.
X#	.ver -- output of verser1 (for the varian or AED)
X#	.imp -- output of dvi-imagen (or dviimp)
X# Anything else is assumed to be in .tex format.
X# If TEX sees a .dvi, .ver, or .imp suffix, it will skip ahead to the right
X# point in the processing sequence. Specifically,
X#	texeqn	accepts .tex, outputs .tex
X#	tex	accepts .tex, outputs .dvi and .log
X#	latex	accepts .tex, outputs .dvi and .log
X#	verser1	accepts .dvi, outputs .ver (for the varian or AED, not on hanuma).
X#	lpr	accepts .ver, outputs raster
X#	ipr	accepts	.imp, outputs raster
X#
X# Flags:
X# -latex uses LaTeX.
X# -log	 saves a log file from the tex run in filename.log.
X# -d	 quits once the .dvi file has been made.
X# -x	 makes two passes on the (latex) input, so cross-references
X#	 are resolved.
X# -v	 output device is the varian (imagen is the default)
X# -q	 quits once the .imp file has been made if the imagen is the target printer
X#	 or after the .ver file	(i.e. after verser1 stage) if the AED or the varian
X#	 is the target printer.
X# -eqn	 strips out the equations with texeqn and typeset them.
X#
X# Authors: Kamal Al-Yahya, Jeff Thorson, and Chuck Sword, Stanfor University
X#
Xumask 0
Xonintr removal
Xset name=() host=()
Xset destdir = /usr/local
Xset tmp = TEX$$
Xset device = imagen
Xset st = 0
Xunset latex x d q eqn log

Xif ($#argv == 0) then
X	echo "usage: TEX [-latex] [-eqn] [-log] [-d] [-q] [-x] filename"
X	exit(-1)
Xendif

Xwhile ($#argv > 0 && !($?inf))
X	switch ($argv[1])
X		case -latex:
X			set latex
X			breaksw

X		case -x:
X			set x
X			breaksw

X		case -q:
X			set q
X			breaksw

X		case -d:
X			set d
X			breaksw

X		case -v:
X			set device = varian
X			breaksw

X		case -eqn:
X			set eqn
X			breaksw

X		case -log:
X			set log
X			breaksw

X		case -*:
X			echo unknown flag $argv[1], ignored
X			breaksw
X                default:
X			set inf = $argv[1]
X			if !(-e $inf) then

X#  filename not found, try with .tex ending

X				if !(-e $inf.tex) then 
X					echo $0 'cannot find file' $inf.
X					exit(-1)
X				else
X					set inf = ($inf.tex)
X				endif
X			endif
X			breaksw
X		endsw
X	shift argv
Xend

Xset name = $inf:t
Xset sname = $name:r
Xset name = $cwd/$name
Xset suffix = $name:e

Xif ($suffix == dvi) then
X	echo TEX: starting with .dvi file
X	set name = $name:r
X	set dvifile = $inf
X	goto dvi
Xendif

Xif ($suffix == ver) then
X	echo TEX: starting with .ver file
X	set name = $name:r
X	set verfile = $inf
X	goto ver
Xendif

Xif ($suffix == imp) then
X	echo TEX: starting with .imp file
X	set name = $name:r
X	set impfile = $inf
X	goto imp
Xendif

Xif ($suffix == tex || $suffix == eqn) then
X	set name = $name:r
Xendif

Xecho "\batchmode" > $tmp.tex

Xif ($?eqn) then
X	$destdir/texeqn < $inf >> $tmp.tex
Xelse
X	cat $inf >> $tmp.tex
Xendif

Xecho "\bye" >> $tmp.tex

X# Choose tex or latex

Xif ($?latex) then
X	if (-e $name.aux) then
X		cp $name.aux $tmp.aux
X	endif
X	$destdir/latex $tmp:t
X	if ($status != 0) then
X		goto oops
X	else
X		if (-e $tmp.aux) then
X			cp $tmp.aux $name.aux
X		endif
X	endif

X	if ($?x) then
X		echo "Starting second pass"
X		$destdir/latex $tmp
X		if ($status != 0) then
X			goto oops
X		endif
X		if (-e $tmp.aux) then
X			cp $tmp.aux $name.aux
X		endif
X	endif

Xelse	$destdir/tex $tmp
X	if ($status != 0) then
Xoops:
X		echo TEX could not process your file.
X		echo Error messages are in $name.log
X		mv -f $tmp.log $name.log
X		set st = -1
X		goto removal
X	endif
Xendif

Xif ($?log) then
X	mv -f $tmp.log $name.log
X	if (-e $tmp.aux) then
X		mv -f $tmp.aux $name.aux
X	endif
Xendif

Xset dvifile = $tmp.dvi

Xif ($?d) then
X	mv -f $dvifile $name.dvi
X	goto removal
Xendif

Xdvi:

Xif($device == imagen) then
X	$destdir/dvi-imagen -s $dvifile > $tmp.imp
X	if ($?q) then
X		mv -f $tmp.imp $name.imp
X		goto removal
X	endif
X	set impfile = $tmp.imp
Ximp:
X	(echo -n \@document\(owner \"$user\", site \"$host\", spooldate \
X	\"`date`\", language \"imPress\", jobheader off, \
X	jamresistance on\) ; cat $impfile ) | $destdir/ipr
X	goto removal
Xendif

Xif($device == varian) then
X	$destdir/verser1 < $dvifile > $tmp.ver
X	if ($status != 0) then
X		echo TEX bombed out on verser1.
X		set st = -1
X		goto removal
X	endif
X	set verfile = $tmp.ver

X	if ($?q) then
X		mv -f $verfile $name.ver
X		goto removal
X	endif
Xver:
X	lpr -d -s -Pvarian $tmp.ver
Xendif

Xremoval:
X/bin/rm -f $tmp.tex $tmp.log $tmp.dvi $tmp.ver $tmp.imp $tmp.aux
Xexit($st)
@//E*O*F TEX//
chmod u=rwx,g=rwx,o=rwx $OUT
 
echo x - TEX.1
if test -f TEX.1 ; then
    echo TEX.1 exists, putting output in $$TEX.1
    OUT=$$TEX.1
    STATUS=1
else
    OUT=TEX.1
fi
sed 's/^X//' > $OUT <<'@//E*O*F TEX.1//'
X.TH TEX 1 2/2/84
X.UC 4
X.SH NAME
XTEX \- 
X.I TeX
Xand
X.I LaTeX
Xtypesetter and printer.
X.SH SYNOPSIS
X.B TEX
X[
Xoptions
X]
X.I  filename
X.SH DESCRIPTION
X.I TEX
Xprocesses a file 
Xand sends it to a printer. The default is the Imagen; other devices 
Xcan be used if available at the site.
X.PP
XThe input to
X.I TEX
Xdoes not have to be the raw manuscript.
X.I TEX
Xcan be given a
X.I .dvi
Xfile (which results from using the
X.B -d
Xoption),
Xor
X.I .imp
Xand
X.I .ver
Xfiles (which result from using the
X.B -q
Xoption), and it will proceed from and end at the appropriate stage.
X.br
XThe file name does not have to end with
X.I
Xtex.
X.sp 2
XOPTIONS :
X.br
X.TP
X.B \-latex
Xuses LaTeX.  See the LaTeX manual.
X.TP
X.B \-x
Xmakes two passes on the
X.I LaTeX
Xinput to resolve cross-references.
X.TP
X.B \-eqn
Xuses
X.B
Xtexeqn
Xto extract the equations.
X.TP
X.B \-log
Xsaves messages from the
X.B tex
Xrun in 
X.I filename
X.B .log
Xand saves messages from LaTeX run in 
X.I filename
X.B .aux
X.TP
X.B \-d
Xquits once the
X.I dvi
Xfile is produced without producing a hardcopy.
X.TP
X.B \-q
X(for quiescent) intermediate output is not spooled 
Xto the printing device.
X.TP
X.B \-v
Xoutput device is the varian (default is the imagen).
X.fi
X.SH SEE ALSO
Xtex(1), texeqn(1), texmatch(1), detex(1)
X.SH FILES
Xfile.aux			the auxiliary file used by LaTeX for labeling figures.
X.br
XThe default is to remove the following files at the end of the run:
X.br
XTE????.dvi		the device independent file.
X.br
XTE????.log		the log file.
X.br
XTE????.imp		the impress file; can be printed by
X.B ipr
Xfile.
X.SH BUGS
XOnly one file can be processed at a time.
X.br
XDrivers flags are not incorporated. Add the ones you need.
X.SH AUTHOR
XKamal Al-Yahya
X.br
XJeff Thorson
X.br
XChuck Sword

@//E*O*F TEX.1//
chmod u=rw,g=rw,o=rw $OUT
 
echo x - TeXExpand.c
if test -f TeXExpand.c ; then
    echo TeXExpand.c exists, putting output in $$TeXExpand.c
    OUT=$$TeXExpand.c
    STATUS=1
else
    OUT=TeXExpand.c
fi
sed 's/^X//' > $OUT <<'@//E*O*F TeXExpand.c//'
X/* expand TeX and LaTeX's \input and \include */

X#include        <stdio.h>
XTeXExpand(fp,big,maxlen)

XFILE *fp;
Xchar *big;
Xint maxlen;
X{
Xchar bigg[50000];
XFILE *fpp;
Xint c,c1;
Xchar w[100];
Xint i,j;
Xextern wflag;

Xwhile ((c = getc(fp)) != EOF)
X	{
X	if (c == '%' || c1 == '%')
X		{
X		while ((c =getc(fp)) != EOF)
X			if (c == '\n')
X				{
X				*big++=c;
X				break;
X				}
X		c1=c;
X		continue;
X		}
X	if (c != '\\')
X		*big++=c;
X	else			/* detect TeX commands (backslash) */
X		{
X		/* see if \input or \include is the control sequence */
X		i=0;
X		c1=c;		/* update last character */
X		while ((c = getc(fp)) != EOF)
X			{
X			if(c == ' ' || c=='\n' || c=='$' || c=='#' || c=='%'
X			|| c=='{' || c=='(' || c==')' || c == '\\') break;
X			w[i++]=c;
X			}
X			if(w[1]=='n' && w[2]=='p' && w[3]=='u' && w[4]=='t'
X			   || w[1]=='n' && w[2]=='c' && w[3]=='l' && w[4]=='u'
X			   && w[5]=='d' && w[6]=='e')
X					{
X/* if it is \input or \include , get the file name */
X					i=0;
X					while (( c = getc(fp)) != EOF)
X						{
X						if (c==' ' || c=='\n' || c=='}')
X							break;
X						w[i++]=c;
X						}
X					w[i]='\0';
X					fpp=fopen(w, "r"); /* open the new file */
X					if( fpp == NULL )
X					     {
X/* if file is not found, try file.tex  */
X					     strcat(w,".tex");
X					     fpp=fopen(w, "r");
X					     if( fpp == NULL )
X						{
X						fprintf(stderr,
X						"TeXExpand: Cannot open %s\n",w);
X						bigg[0]='\0';
X						}
X					     else
X						{
X						if (wflag != 1)
X						{
X						fprintf(stderr,"%s:\n",w);
X						TeXMatch(fpp);
X						fprintf(stderr,"\n");
X						fseek(fpp,0,0);
X						}
X						TeXExpand(fpp,bigg,maxlen);
X						fclose(fpp);
X						}
X					     }
X					else
X						{
X						if (wflag != 1)
X						{
X						fprintf(stderr,"%s:\n",w);
X						TeXMatch(fpp);
X						fprintf(stderr,"\n");
X						fseek(fpp,0,0);
X						}
X						TeXExpand(fpp,bigg,maxlen);
X						fclose(fpp);
X						}
X					strcat(big,bigg);
X					big += strlen(bigg);
X					w[0]='\0';
X					}
X				else
X/* if the control sequence is not \input or \include write it out */
X					{
X					*big++='\\';
X					for (j=0; j < i; j++)
X						*big++=w[j];
X/* do not write commented text */
X					if (c1 != '\\' && c != '%')
X						*big++=c;
X					else
X						if (c1 == '\\')
X							{
X							*big++=c;
X							c=' ';
X							}
X					}
X		}
X	c1=c;				/* update last character */
X	}
X*big++ = '\0';
X}
@//E*O*F TeXExpand.c//
chmod u=rw,g=rw,o=rw $OUT
 
echo x - TeXMatch.c
if test -f TeXMatch.c ; then
    echo TeXMatch.c exists, putting output in $$TeXMatch.c
    OUT=$$TeXMatch.c
    STATUS=1
else
    OUT=TeXMatch.c
fi
sed 's/^X//' > $OUT <<'@//E*O*F TeXMatch.c//'
X#include <stdio.h>

XTeXMatch(fp)			/* check matching */
XFILE *fp;
X{

Xint l=1;			/* line counter */
Xint ld=0;			/* single left dollar signs */
Xint rd=0;			/* single right dollar signs */
Xint ldd=0;			/* left double dollar signs */
Xint rdd=0;			/* right double dollar signs */
Xint lateq=0;			/* LaTeX \begin{equation} \end{equation} */
Xint lp=0;			/* left paranthesis */
Xint rp=0;			/* right paranthesis */
Xint lb=0;			/* left brackets */
Xint rb=0;			/* right brackets */
Xint lbr=0;			/* left braces */
Xint rbr=0;			/* right braces */
Xint c=' ';			/* current character */
Xint c1=' ';			/* previous character */
Xint lbrl=1;			/* line number of left braces */
Xint lbl=1;			/* line number of left bracket */
Xint lpl=1;			/* line number of left parenthesis */
Xint ldl=1;			/* line number of left single dollar sign */
Xint lddl=1;			/* line number of left double dollar sign */
Xint lbeg=1;			/* line of \begin{equation} */
Xint war=0;			/* warning status */
Xint esc=0;			/* escape status */
Xint i=0;

Xwhile ((c =getc(fp)) != EOF)
X	{
X	if (ldd == 1 && ld == 1 && c != '$')
X		{
X		fprintf(stderr,"line %d: a double dollar sign is closed by a single dollar sign\n",l);
X		ld=0.;	ldd=0.;			/* reset dollar signs */
X/* Give warning about unclosed openings */
X		if ((lbr-rbr) > 0)
X	fprintf(stderr,"line %d: %d unclosed braces in equation\n",lddl,lbr-rbr);
X		if ((lb-rb) > 0)
X	fprintf(stderr,"line %d: %d unclosed brackets in equation\n",lddl,lb-rb);
X		if ((lp-rp) > 0)
X	fprintf(stderr,"line %d: %d unclosed parantheses in equation\n",lddl,lp-rp);
X/* clear registers */
X		lp=0; lb=0; lbr=0;
X		rp=0; rb=0; rbr=0;
X		lpl=0; lbrl=0; lbl=0;
X		}
Xtop:
X	switch(c)
X		{
X		case '\n':
X			l++;		/* increment line counter */
X/* check to see if a single dollar sign is not closed at the same line */
X			if (ld == 1 && war == 0)
X				{
X				fprintf(stderr,"line %d: single dollar sign is not closed on the same line\n",l-1);
X				war=1;		/* warning has been given */
X				}
X			esc = 0;	/* escape status */
X			break;
X		case '%':		/* ignore commented text */
X			if (esc == 1)		/* escaped % */
X				{ esc=0;	break; }
X			while ((c =getc(fp)) != EOF)
X				if (c == '\n')	{l++;	break;}
X			esc=0;
X			break;
X		case '{':
X			if (esc == 0)
X				{
X				lbr++;
X				if (lbrl == 0)	lbrl=l;
X				}
X			esc = 0;	/* escape status */
X			break;
X		case '}':
X			if (esc == 0)	rbr++;
X			esc = 0;	/* escape status */
X			if (rbr > lbr)
X				{
X				fprintf(stderr,"line %d: unmatched braces\n",l);
X				rbr--;		/* reset the count */
X				}
X			if (lbr == rbr)	lbrl=0;
X			break;
X		case '[':
X			if (esc == 0)
X				{
X				lb++;
X				if (lbl == 0)	lbl=l;
X				}
X			esc = 0;	/* escape status */
X			break;
X		case ']':
X			if (esc == 0)	rb++;
X			esc = 0;	/* escape status */
X			if (rb > lb)
X				{
X			     fprintf(stderr,"line %d: unmatched brackets\n",l);
X				rb--;		/* reset the count */
X				}
X			if (lb == rb)	lbl=0;
X			break;
X		case '(':
X			if (esc == 0)
X				{
X				lp++;
X				if (lpl == 0)	lpl=l;
X				}
X			esc = 0;	/* escape status */
X			break;
X		case ')':
X			if (esc == 0)	rp++;
X			esc = 0;	/* escape status */
X			if (rp > lp)
X			    {
X			   fprintf(stderr,"line %d: unmatched parentheses\n",l);
X			    rp--;		/* reset the count */
X			    }
X			if (lp == rp)	lpl=0;
X			break;
X		case '$':
X			if (esc == 1)		/* escaped dollar sign */
X				{
X				c=' ';		/* reset the dollar sign */
X				esc = 0;	/* escape status */
X				break;
X				}
X			if (c1 == '$')		/* double dollar sign */
X				{
X				if (ld == 0)
X					{
X					fprintf(stderr,"line %d: single dollar sign is closed by a duble dollar sign\n",l);
X					c=' ';		/* reset the dollar sign */
X					break;
X					}
X				if (ldd == 1)
X					{
X					rdd=1; /* right double dollar sign */
X/* Give warning about unclosed openings */
X					if ((lbr-rbr) > 0)
X	fprintf(stderr,"line %d: %d unclosed braces in equation\n",lddl,lbr-rbr);
X					if ((lb-rb) > 0)
X	fprintf(stderr,"line %d: %d unclosed brackets in equation\n",lddl,lb-rb);
X					if ((lp-rp) > 0)
X	fprintf(stderr,"line %d: %d unclosed parantheses in equation\n",lddl,lp-rp);
X/* clear registers */
X					lp=0; lb=0; lbr=0;
X					rp=0; rb=0; rbr=0;
X					lpl=0; lbrl=0; lbl=0;
X					}
X				else
X					{
X					ldd=1;	/* left double dollar sign */
X					lddl=l;	/* line number */
X/* Give warning about unclosed openings */
X					if ((lbr-rbr) > 0)
X	fprintf(stderr,"line %d: %d unclosed braces before equation, first opened at line %d\n",lddl,lbr-rbr,lbrl);
X					if ((lb-rb) > 0)
X	fprintf(stderr,"line %d: %d unclosed brackets before equation, first opened at line %d\n",lddl,lb-rb,lbl);
X					if ((lp-rp) > 0)
X	fprintf(stderr,"line %d: unclosed parentheses before equation, first opened at line %d\n",lddl,lp-rp,lpl);
X/* clear registers */
X					lp=0; lb=0; lbr=0;
X					rp=0; rb=0; rbr=0;
X					lpl=0; lbrl=0; lbl=0;
X					}
X				}
X			if (ld == 1)	rd=1;	/* right dollar sign */
X			else
X				{
X				ld=1; 	/* left dollar sign */
X				ldl=l;	/* line number */
X				war=0;	/* no warning has been given */
X				}
X			esc = 0;		/* escape status */
X			break;
X		case '\\':
X/* check if \begin{equation} or \end{equation} */
X			i=begin_end_file(fp,&c);
X/* check escape status */
X			if (c == '\\')
X				{
X				if (i == 0)	esc = 0;
X				else		esc = 1;
X				}
X			if (i < 0)	 	/* not equation */
X				{
X				if (c != '\\')	esc = 0;
X				c1 = ' ';	/* doesn't matter */
X				goto top;  
X				}
X			if (i == 0)
X				{
X				if (c == '\n')	l++;
X				esc = 0;
X				c1 = ' ';	/* doesn't matter */
X				}
X			else if (i == 1)
X				{
X				if (lateq == 1)
X	fprintf(stderr,"line %d: new equation starts while equation on line %d is not closed\n",l,lbeg);
X				lateq=1;	/* \begin{equation} */
X				lbeg=l;		/* line number */
X/* Give warning about unclosed openings */
X				if ((lbr-rbr) > 0)
X	fprintf(stderr,"line %d: %d unclosed braces before equation, first opened at line %d\n",lbeg,lbr-rbr,lbrl);
X				if ((lb-rb) > 0)
X	fprintf(stderr,"line %d: %d unclosed brackets before equation, first opened at line %d\n",lbeg,lb-rb,lbl);
X				if ((lp-rp) > 0)
X	fprintf(stderr,"line %d: %d unclosed parentheses before equation, first opened at line %d\n",lbeg,lp-rp,lpl);
X/* clear registers */
X				lp=0; lb=0; lbr=0;
X				rp=0; rb=0; rbr=0;
X				lpl=0; lbrl=0; lbl=0;
X				}
X			else
X				{
X				if (lateq == 0)
X	fprintf(stderr,"line %d: equation ends but no beginning\n",l);
X/* Give warning about unclosed openings */
X				if ((lbr-rbr) > 0)
X	fprintf(stderr,"line %d: %d unclosed braces in equation\n",l,lbr-rbr);
X				if ((lb-rb) > 0)
X	fprintf(stderr,"line %d: %d unclosed brackets in equation\n",l,lb-rb);
X				if ((lp-rp) > 0)
X	fprintf(stderr,"line %d: %d unclosed parantheses in equation\n",l,lp-rp);
X/* clear registers */
X				lp=0; lb=0; lbr=0;
X				rp=0; rb=0; rbr=0;
X				lpl=0; lbrl=0; lbl=0;
X				lateq=0;
X				}
X			break;
X		default:
X			esc=0;			/* escape status */
X			break;
X		}
X	c1=c;					/* update previous character */
X	if (ld == 1 && rd == 1)
X		{ld=0.;		rd=0.;}		/* matched dollar signs */
X	if (ldd == 1 && rdd == 1)
X		{ldd=0.;	rdd=0.;}	/* matched double dollar signs */
X	}
Xif ((lbr-rbr) > 0)
X	fprintf(stderr,"file ends: %d unclosed left braces, first opened at line %d \n",lbr-rbr,lbrl);
Xif ((lb-rb) > 0)
X	fprintf(stderr,"file ends: %d unclosed left brackets, first opened at line %d \n",lb-rb,lbl);
Xif ((lp-rp) > 0)
X	fprintf(stderr,"file ends: %d unclosed left parentheses, first opened at line %d \n",lp-rp,lpl);
Xif (ld == 1)
X	fprintf(stderr,"file ends: single dollar sign opened at line %d unclosed\n",ldl);
Xif (ldd == 1)
X	fprintf(stderr,"file ends: double dollar sign opened at line %d unclosed\n",lddl);
Xif (lateq == 1)
X	fprintf(stderr,"file ends: equation started at line %d unclosed\n",lbeg);
X}

Xtmpbuf(in,buffer)	/* copy input to buffer, assume buffer is big enough */
XFILE *in;
Xchar *buffer;
X{
Xwhile (( *buffer++ = getc(in)) != EOF) ;
X}

Xscrbuf(in,out)			/* copy input to output */
XFILE *in,*out;
X{
Xint c;
Xwhile ((c =getc(in)) != EOF)	putc(c,out);
X}

Xbegin_end_buf(buffer,be)
X/*
Xreads from a buffer and returns 1 if \begin{equation} is found,
X2 if \end{equation} is found and -1 if neither is found
X*/
Xchar *buffer;
Xint *be;
X{
X	int i;
X	char w[11];

X	*be = -1;
X	for (i=0; (w[i] = *buffer++) != '\0' && i < 5; i++)
X		if (w[i] < 'a' || w[i] > 'z')		break;
X	buffer--;
X	w[i]='\0';
X	if (strcmp(w,"egin") == 0)	*be=1;		/* \begin */
X	else if (strcmp(w,"end") == 0)	*be=2;		/* \end */
X	if ( *be > 0)
X		{
X		for (i=0; (w[i] = *buffer++) != '\0' && i < 10; i++) ;
X		w[i]='\0';
X		if (strcmp(w,"{equation}") == 0)
X			return(0);
X		}
X	return(i);
X}


X#define MAXWORD 20
Xbegin_end_file(fp,c)
X/*
Xreads from a file and checks for equations; returns 1 if \begin{equation}
Xis found and 2 if \end{equation} is found; returns -1 if neither is found;
Xreturn 0 if no letter is consumed.
X*/
XFILE *fp;
Xint *c;
X{
X	int i,be;
X	char w[MAXWORD];

X	for (i=0; (w[i] = getc(fp)) != EOF && i < MAXWORD; i++)
X		if (w[i] < 'a' || w[i] > 'z')		break;
X	*c=w[i];
X	w[i]='\0';
X	be = -1;
X	if (strcmp(w,"begin") == 0)	be=1;
X	else if (strcmp(w,"end") == 0)	be=2;
X	if (i == 0)	return(0);
X	if (be > 0)
X		{
X		w[0] = *c;
X		for (i=1; (w[i] = getc(fp)) != EOF  && i < MAXWORD; i++)
X			if (w[i] < 'a' || w[i] > 'z')
X				if (w[i] != '{')	break;
X		*c=w[i];
X		w[i]='\0';
X		if (strcmp(w,"{equation") == 0)
X			return(be);
X		*c=' ';			/* so that the brace does not count */
X		}
X	return(-1);
X}
@//E*O*F TeXMatch.c//
chmod u=rw,g=rw,o=rw $OUT
 
echo x - detex.1
if test -f detex.1 ; then
    echo detex.1 exists, putting output in $$detex.1
    OUT=$$detex.1
    STATUS=1
else
    OUT=detex.1
fi
sed 's/^X//' > $OUT <<'@//E*O*F detex.1//'
X.TH detex 1 2/27/86
X.UC 4
X.SH NAME
Xdetex \- a filter to strip TeX and LaTeX's commands from a file.
X.SH SYNOPSIS
X.B detex [-iw]
X.I file1 [file2 ......]
X.br
Xor
X.B detex [-iw]
X.I < file
X.br
X.SH DESCRIPTION
XTeX and LaTeX have control characters that
X.B spell
Xand other
X.I troff
X-dependent
Xprocessors (like diction) do not recognize.
X.I Detex
Xworks as a preprocessor by
Xfiltering those control characters. The output can then be piped to the next
Xprocess. The output can be saved by redirecting the standard output.
X.I Detex
Xdoes not break the document into individual words. It merely
X.I erases
Xthe control sequences.
XThe character '%' is recognized as a comment indicator and the commented
Xtext is not passed to the output.
X.br
X.I Detex
Xrecognizes and opens files called by TeX's and LaTeX's \\input
Xand \\include commands. The
X.B -i
Xflag makes
X.I detex
Xignore these commands.
XThe file name has to be correct relative to the current working directory.
XIf it cannot open the file nor file_name.tex, it will give a non-fatal
Xerror message and proceed.
X.br
XWarning is given if suspected unmatching is detected. Use the
X.B -w
Xflag to suppress these warnings.
X.SH DIAGNOSTICS
XNesting of \\input and \\include is allowed but the number of opened files
Xmust not exceed the system's limit on the number of simultaneously opened
Xfiles (normally < 20).
X.br
XMaterial between single or double dollar signs or between \\begin{equation} and
X\\end{equation} is regarded as mathematical
Xequations and is ignored.
X.SH SEE ALSO
Xtexexpand(1), texeqn(1), texmatch(1).
X.SH AUTHOR
XKamal Al-Yahya, Stanford University
@//E*O*F detex.1//
chmod u=rw,g=rw,o=rw $OUT
 
echo x - detex1.c
if test -f detex1.c ; then
    echo detex1.c exists, putting output in $$detex1.c
    OUT=$$detex1.c
    STATUS=1
else
    OUT=detex1.c
fi
sed 's/^X//' > $OUT <<'@//E*O*F detex1.c//'
X/* detex: strips TeX's and LaTeX's commands */
X/* to compile:   cc detex.c -o detex */

Xchar *documentation[] = {
X" SYNTAX",
X"        detex [-i] file1 [file2 .....]",
X"     or detex [-i]  < file1 [file2 ....]",
X"",
X"See the manual page for more details.",
X"",
X"        Flag:",
X"             -i:     ignores TeX's and LaTeX's \input and \include commands",
X"             -w:     matching is not checked",
X"",
X};

X/* Author: Kamal Al-Yahya, Stanford University,		11/1/83 */
X/* Modified:						6/30/86 */

Xint	doclength = { sizeof documentation/sizeof documentation[0] };

X#include        <stdio.h>
X#include        <sys/ioctl.h>
X#include        <sgtty.h>
X#define	MAXLEN	100000

Xstruct sgttyb ttystat;
Xextern char *strcpy(), *mktemp();
Xchar scratch_file[100];

Xint wflag;
Xint xargc;
Xchar **xargv;

Xmain(argc,argv)
Xint argc; 
Xchar *argv[];
X{
Xchar big[MAXLEN];
XFILE *temp,*scr;
Xregister char *cptr;
Xint piped_in;
Xint iflag,i;

X/* If no arguments, and not in a pipeline, self document */
Xpiped_in = ioctl ((fileno (stdin)), TIOCGETP, &ttystat);
Xif (argc == 1 && !piped_in)
X	{
X	for( i=0; i<doclength; i++)
X		printf("%s\n",documentation[i]);
X	exit (0);
X	}

X/* process option flags */
Xxargc = argc;
Xxargv = argv;
Xfor (xargc--,xargv++; xargc; xargc--,xargv++)
X	{
X	cptr = *xargv; 
X	if( *cptr=='-' )
X		{
X		while( *(++cptr))
X			{
X			switch( *cptr )
X				{
X				case 'i':
X					iflag=1;
X					break;
X				case 'w':
X					wflag=1;
X					break;
X				default:
X			     		fprintf(stderr,
X					"unknown flag -%c\n",*cptr);
X					break;
X				}
X			}
X		}
X	}

X/* first process pipe input */
Xif(piped_in)
X	{
X/* need to buffer; can't seek in pipes */
X/* make a temporary and volatile file in /tmp */
X	strcpy(scratch_file,"/tmp/texXXXXXX");
X	mktemp(scratch_file);
X	scr=fopen(scratch_file,"w");
X	scrbuf(stdin,scr);
X	fclose(scr);
X	scr=fopen(scratch_file,"r");
X	unlink(scratch_file);
X	if (wflag != 1)
X		{
X		fprintf(stderr,"Checking matching...\n");
X		TeXMatch(scr);
X		fseek(scr,0,0);
X		}
X/* either expand or buffer */
X	if (iflag != 1)
X		{ TeXExpand(scr,big,MAXLEN);	fclose(scr); }
X	else
X		{ tmpbuf(scr,big);		fclose(scr); }
X	if (wflag != 1)
X		fprintf(stderr,"Checking matching done\n\n");
X	DeTeX(big);
X	fclose(scr);
X	}

X/* then process input line for arguments and assume they are input files */
Xxargc = argc;
Xxargv = argv;
Xfor (xargc--,xargv++; xargc; xargc--,xargv++)
X	{
X	cptr = *xargv; 
X	if( *cptr=='-' ) continue;		/* this is a flag */
X	if((temp=fopen(cptr,"r")) != NULL)
X		{
X		if (wflag != 1)
X			{
X			fprintf(stderr,"Checking matching...\n");
X			fprintf(stderr,"%s:\n",cptr);
X			TeXMatch(temp);
X			fprintf(stderr,"\n");
X			fseek(temp,0,0);
X			}
X/* either expand or buffer */
X		if (iflag != 1)
X			{ TeXExpand(temp,big,MAXLEN);	fclose(temp); }
X		else
X			{ tmpbuf(temp,big);		fclose(temp); }
X		if (wflag != 1)
X			fprintf(stderr,"Checking matching done\n\n");
X		DeTeX(big);
X		fclose(temp);
X		}
X	else
X		fprintf(stderr,"detex: Cannot open %s\n",cptr);
X	}

X}

XDeTeX(big)			/* stripping TEX commands */

Xchar *big;
X{
Xint c,c1,be;

Xwhile ((c = *big++) != '\0')
X	{
X	switch (c)
X	{
X/* detect TeX commands (backslash) */
X	case '\\':
X		c1=c ;		/* c1 is needed to see if there is \$ */
X		c=' ' ;		/* "erase" the backslash */
X		putc(c,stdout);
X		if ((c = *big++) =='b')
X		if (begin_end_buf(big,&be) == 0)
X			{
X			if (be == 1)
X				{
X				big += 14;
X				while ( *big++ != '\0')
X					{
X					if(begin_end_buf(big,&be) == 0)
X						if (be == 2)
X							{
X							big += 13;
X							break;
X							}
X					}
X				}
X			}
X		while ((c = *big++) != '\0')
X			{
X			if (c == '$')			goto dollar;
X			if (c == '%')			goto comm;
X			if (c == '{' || c == '#')	break;
X			if (c == ' ' || c == '\n' || c == '(' || c == ')')
X				{
X				putc(c,stdout);
X				break;
X				}
X			c1=c;				/* reinitialize c1 */
X			}
X		break;
X/* come here if the character is dollar sign */
Xdollar:
X	case '$':
X		c=' ' ;		/* "erase" the dollar sign */
X		putc (c,stdout);
X		if (c1 == '\\')		 break;		/* means \$ */
X		c = *big++;
X		if(c == '$')		goto dollar2;
X		else			goto dollar1;
X		break;

X/* see if it is an in-line equation (delimeter is one dollar sign) */
Xdollar1:
X		while((c = *big++) != '\0')
X			if(c == '$')	break;
X		break;

X/* see if it is a displayed equation (delimeter is two dollar signs) */
Xdollar2:
X		while((c = *big++) != '\0')
X			{
X			if(c == '$')
X				{
X				c = *big++;
X				if (c != '$')	putc(c,stdout);
X				break;
X				}
X			}
X		break;

X/* ignore commented text */
Xcomm:
X	case '%':
X		if (c1 == '\\')		 break;		/* means \% */
X		while((c = *big++) != '\0')
X			if (c == '\n')
X				{
X				putc(c,stdout);
X				break;
X				}
X		break;
X/* erase these character */
X	case '{':
X		c=' ';
X	case '}':
X		c=' ';
X	case '_':
X		c=' ';
X	case '^':
X		c=' ';
X	case '&':
X		c=' ';
X	case '#':
X		c=' ';
X/* default is doing nothing: pass the character to the output */
X	default:
X		putc(c,stdout);
X		break;
X	}
X	c1=c;			/* reinitialize c1 */
X	}
X}
@//E*O*F detex1.c//
chmod u=rw,g=rw,o=rw $OUT
 
echo x - detex2.c
if test -f detex2.c ; then
    echo detex2.c exists, putting output in $$detex2.c
    OUT=$$detex2.c
    STATUS=1
else
    OUT=detex2.c
fi
sed 's/^X//' > $OUT <<'@//E*O*F detex2.c//'
X/* detex: strips TeX's and LaTeX's commands */
X/* to compile:   cc detex.c -o detex */


Xchar *documentation[] = {
X" SYNTAX",
X"        detex [-iw] [parameters] [inputfiles]",
X"",
X"        flags:",
X"              -i   ignores TeX's and LaTeX's \input and \include commands",
X"              -w   does not check matching",
X"",
X"        parameters:",
X"              in=filename       filename is the input file",
X"                                (Default: in=stdin)",
X"",
X"              out=filename      filename is the output file",
X"                                (Default: out=stdout)",
X""
X};

X/* Author: Kamal Al-Yahya, Stanford University,		11/1/83 */
X/* Modified:						6/30/86 */

Xint	doclength = { sizeof documentation/sizeof documentation[0] };

X#include        <stdio.h>
X#include        <sys/ioctl.h>
X#include        <sgtty.h>
X#define	MAXLEN	100000

Xchar string[100],filename[100];
XFILE *out_file;
Xstruct sgttyb ttystat;
Xextern char *strcpy(), *mktemp();
Xchar scratch_file[100];

Xint wflag;
Xint xargc;
Xchar **xargv;

Xmain(argc,argv)
Xint argc; 
Xchar *argv[];
X{
Xchar big[MAXLEN];
XFILE *temp,*scr;
Xregister char *cptr;
Xint piped_in;
Xint iflag,i;

X/* If no arguments, and not in a pipeline, self document */
Xpiped_in = ioctl ((fileno (stdin)), TIOCGETP, &ttystat);
Xif (argc == 1 && !piped_in)
X	{
X	for( i=0; i<doclength; i++)
X		printf("%s\n",documentation[i]);
X	exit (0);
X	}

Xout_file = stdout;		/* default output */

X/* process option flags */
Xxargc = argc;
Xxargv = argv;
Xfor (xargc--,xargv++; xargc; xargc--,xargv++)
X	{
X	cptr = *xargv; 
X	if( *cptr=='-' )
X		{
X		while( *(++cptr))
X			{
X			switch( *cptr )
X				{
X				case 'i':
X					iflag=1;
X					break;
X				case 'w':
X					wflag=1;
X					break;
X				default:
X			     		fprintf(stderr,
X					"unknown flag -%c\n",*cptr);
X					break;
X				}
X			}
X		}
X	}

X/* process getpar parameters */
Xxargc = argc;
Xxargv = argv;

Xif(getpar_("out","s",string))
X	{
X	sscanf(string,"%s",filename);
X	if((temp=fopen(filename,"w")) == NULL)
X		fprintf(stderr,"detex: Cannot open output file %s\n",filename);
X	else
X		out_file = temp;
X	}

X/* first process pipe input */
Xif(piped_in)
X	{
X/* need to buffer; can't seek in pipes */
X/* make a temporary and volatile file in /tmp */
X	strcpy(scratch_file,"/tmp/texXXXXXX");
X	mktemp(scratch_file);
X	scr=fopen(scratch_file,"w");
X	scrbuf(stdin,scr);
X	fclose(scr);
X	scr=fopen(scratch_file,"r");
X	unlink(scratch_file);
X	if (wflag != 1)
X		{
X		fprintf(stderr,"Checking matching...\n");
X		TeXMatch(scr);
X		fseek(scr,0,0);
X		}
X/* either expand or buffer */
X	if (iflag != 1)
X		{ TeXExpand(scr,big,MAXLEN);	fclose(scr); }
X	else
X		{ tmpbuf(scr,big);		fclose(scr); }
X	if (wflag != 1)
X		fprintf(stderr,"Checking matching done\n\n");
X	DeTeX(big,out_file);
X	fclose(scr);
X	}

X/* next process in=inputfiles */
Xif(getpar_("in","s",string))
X	{
X	sscanf(string,"%s",filename);
X	if((temp=fopen(filename,"r")) != NULL)
X		{
X		if (wflag != 1)
X			{
X			fprintf(stderr,"Checking matching...\n");
X			fprintf(stderr,"%s:\n",cptr);
X			TeXMatch(temp);
X			fprintf(stderr,"\n");
X			fseek(temp,0,0);
X			}
X/* either expand or buffer */
X		if (iflag != 1)
X			{ TeXExpand(temp,big,MAXLEN);	fclose(temp); }
X		else
X			{ tmpbuf(temp,big);		fclose(temp); }
X		if (wflag != 1)
X			fprintf(stderr,"Checking matching done\n\n");
X		DeTeX(big,out_file);
X		fclose(temp);
X		}
X	else
X		fprintf(stderr,"detex: Cannot open %s\n",filename);
X	}

X/* then process input line for arguments and assume they are input files */
Xxargc = argc;
Xxargv = argv;

Xfor (xargc--,xargv++; xargc; xargc--,xargv++)
X	{
X	cptr = *xargv; 
X	if( *cptr=='-' ) continue; /* this is a flag */
X	while (*cptr)
X		{
X		if (*cptr == '=')  break; /* this is for getpar */
X		cptr++;
X		}       
X	if (*cptr)  continue;
X	cptr = *xargv;
X	if((temp=fopen(cptr,"r")) != NULL)
X		{
X		if (wflag != 1)
X			{
X			fprintf(stderr,"Checking matching...\n");
X			fprintf(stderr,"%s:\n",cptr);
X			TeXMatch(temp);
X			fprintf(stderr,"\n");
X			fseek(temp,0,0);
X			}
X/* either expand or buffer */
X		if (iflag != 1)
X			{ TeXExpand(temp,big,MAXLEN);	fclose(temp); }
X		else
X			{ tmpbuf(temp,big);		fclose(temp); }
X		if (wflag != 1)
X			fprintf(stderr,"Checking matching done\n\n");
X		DeTeX(big,out_file);
X		fclose(temp);
X		}
X	else
X		fprintf(stderr,"detex: Cannot open %s\n",cptr);
X	}

X}

XDeTeX(big,out_file)			/* stripping TEX commands */

Xchar *big;
XFILE *out_file;
X{
Xint c,c1,be;

Xwhile ((c = *big++) != '\0')
X	{
X	switch (c)
X	{
X/* detect TeX commands (backslash) */
X	case '\\':
X		c1=c ;		/* c1 is needed to see if there is \$ */
X		c=' ' ;		/* "erase" the backslash */
X		putc(c,out_file);
X		if ((c = *big++) =='b')
X		if (begin_end_buf(big,&be) == 0)
X			{
X			if (be == 1)
X				{
X				big += 14;
X				while ( *big++ != '\0')
X					{
X					if(begin_end_buf(big,&be) == 0)
X						if (be == 2)
X							{
X							big += 13;
X							break;
X							}
X					}
X				}
X			}
X		while ((c = *big++) != '\0')
X			{
X			if (c == '$')			goto dollar;
X			if (c == '%')			goto comm;
X			if (c == '{' || c == '#')	break;
X			if (c == ' ' || c == '\n' || c == '(' || c == ')')
X				{
X				putc(c,out_file);
X				break;
X				}
X			c1=c;				/* reinitialize c1 */
X			}
X		break;
X/* come here if the character is dollar sign */
Xdollar:
X	case '$':
X		c=' ' ;		/* "erase" the dollar sign */
X		putc (c,out_file);
X		if (c1 == '\\')		 break;		/* means \$ */
X		c = *big++;
X		if(c == '$')		goto dollar2;
X		else			goto dollar1;
X		break;

X/* see if it is an in-line equation (delimeter is one dollar sign) */
Xdollar1:
X		while((c = *big++) != '\0')
X			if(c == '$')	break;
X		break;

X/* see if it is a displayed equation (delimeter is two dollar signs) */
Xdollar2:
X		while((c = *big++) != '\0')
X			{
X			if(c == '$')
X				{
X				c = *big++;
X				if (c != '$')	putc(c,out_file);
X				break;
X				}
X			}
X		break;

X/* ignore commented text */
Xcomm:
X	case '%':
X		if (c1 == '\\')		 break;		/* means \% */
X		while((c = *big++) != '\0')
X			if (c == '\n')
X				{
X				putc(c,out_file);
X				break;
X				}
X		break;
X/* erase these character */
X	case '{':
X		c=' ';
X	case '}':
X		c=' ';
X	case '_':
X		c=' ';
X	case '^':
X		c=' ';
X	case '&':
X		c=' ';
X	case '#':
X		c=' ';
X/* default is doing nothing: pass the character to the output */
X	default:
X		putc(c,out_file);
X		break;
X	}
X	c1=c;			/* reinitialize c1 */
X	}
X}
@//E*O*F detex2.c//
chmod u=rw,g=rw,o=rw $OUT
 
echo x - inc_file
if test -f inc_file ; then
    echo inc_file exists, putting output in $$inc_file
    OUT=$$inc_file
    STATUS=1
else
    OUT=inc_file
fi
sed 's/^X//' > $OUT <<'@//E*O*F inc_file//'
XThis is an included file.
Xwhen texexpand is run on testfile, this file should be inserted.
X(unmatching in inc_file))
XEND OF INSERTED FILE.
@//E*O*F inc_file//
chmod u=rw,g=rw,o=rw $OUT
 
echo x - inc_file2.tex
if test -f inc_file2.tex ; then
    echo inc_file2.tex exists, putting output in $$inc_file2.tex
    OUT=$$inc_file2.tex
    STATUS=1
else
    OUT=inc_file2.tex
fi
sed 's/^X//' > $OUT <<'@//E*O*F inc_file2.tex//'
XThis is another included file
@//E*O*F inc_file2.tex//
chmod u=rw,g=rw,o=rw $OUT
 
echo x - makefile
if test -f makefile ; then
    echo makefile exists, putting output in $$makefile
    OUT=$$makefile
    STATUS=1
else
    OUT=makefile
fi
sed 's/^X//' > $OUT <<'@//E*O*F makefile//'
Xclean:
X	rm -f *.o core *junk*

Xall: texexpand detex texeqn texmatch

Xtexexpand: texexpand1.o TeXExpand.o TeXMatch.o
X	cc -o texexpand texexpand1.o TeXExpand.o TeXMatch.o

Xdetex: detex1.o TeXExpand.o TeXMatch.o
X	cc -o detex detex1.o TeXExpand.o TeXMatch.o

Xtexeqn: texeqn1.o TeXExpand.o TeXMatch.o
X	cc -o texeqn texeqn1.o TeXExpand.o TeXMatch.o

Xtexmatch: texmatch1.o TeXMatch.o TeXExpand.o
X	cc -o texmatch texmatch1.o TeXMatch.o TeXExpand.o
@//E*O*F makefile//
chmod u=rw,g=rw,o=rw $OUT
 
echo x - makefile.par
if test -f makefile.par ; then
    echo makefile.par exists, putting output in $$makefile.par
    OUT=$$makefile.par
    STATUS=1
else
    OUT=makefile.par
fi
sed 's/^X//' > $OUT <<'@//E*O*F makefile.par//'
X# Use this makefile if you have access to getpar(). You then
X# need to link with the library that provides it (e.g. -lsep below).
X# If you don't use the other makefile (./makefiile).

Xclean:
X	rm -f *.o core *junk*

Xall: texexpand detex texeqn texmatch

Xtexexpand: texexpand2.o TeXExpand.o TeXMatch.o subs.o
X	cc -o texexpand texexpand2.o TeXExpand.o TeXMatch.o subs.o -lsep

Xdetex: detex2.o TeXExpand.o TeXMatch.o subs.o
X	cc -o detex detex2.o TeXExpand.o TeXMatch.o subs.o -lsep

Xtexeqn: texeqn2.o TeXExpand.o TeXMatch.o subs.o
X	cc -o texeqn texeqn2.o TeXExpand.o TeXMatch.o subs.o -lsep

Xtexmatch: texmatch2.o TeXMatch.o TeXExpand.o subs.o
X	cc -o texmatch texmatch2.o TeXMatch.o TeXExpand.o subs.o -lsep
@//E*O*F makefile.par//
chmod u=rw,g=rw,o=rw $OUT
 
echo x - testfile
if test -f testfile ; then
    echo testfile exists, putting output in $$testfile
    OUT=$$testfile
    STATUS=1
else
    OUT=testfile
fi
sed 's/^X//' > $OUT <<'@//E*O*F testfile//'
XThis is a test file for our tex library
X$\beta$
X(unmatched parentheses))
X$dollar sign not closed at the same line
Xit could be a mistake!$
XInput another file
X\input inc_file
XTry to input a non existing file
X\input not_available
X$$
X{{unmatched parentheses}
X$ this should be a double dollar sign
X% commented text is ignored, so unmatching like this (( is ignored.
XInsert another file
X\include{inc_file2}
Xbut \% this is not a commented text
Xthis \$ is also not a math dollar sign, so it should not give
Xa matching warning, nor should this \{ escaped left brace.
X$$ This is a properly displayed text $$
X$((unmatched parentheses)$
XLaTeX equation:
X\begin{equation}
X\alpha + beta =0
X\begin{array}

X\end{array}
X\end{equation}

X\end{equation}
@//E*O*F testfile//
chmod u=rw,g=rw,o=rw $OUT
 
echo x - texeqn.1
if test -f texeqn.1 ; then
    echo texeqn.1 exists, putting output in $$texeqn.1
    OUT=$$texeqn.1
    STATUS=1
else
    OUT=texeqn.1
fi
sed 's/^X//' > $OUT <<'@//E*O*F texeqn.1//'
X.TH texeqn 1 2/2/84
X.UC 4
X.SH NAME
Xtexeqn \- extracts the equations in a TEX document and
Xpasses them to the standard output.
X.SH SYNOPSIS
X.B texeqn [-iw]
X.I filename
X.SH DESCRIPTION
XIt is sometimes desirable to check only the equations of a document.
X.I texeqn
Xstrips those patterns that constitute displayed equations, i.e. anything
Xsurrounded by
X.I two
Xdollar signs or \\begin{equation} and \\end{equation}.
XNote that this also includes any text that is displayed
Xin this fashion even if it is not an equation.
X.br
X\\input and \\include files are inserted unless the
X.B -i
Xflag is used.
X.br
XWarning is given if suspected unmatching is detected. Use the
X.B -w
Xflag to suppress these warnings.
X.br
XText commented by '%' is ignored.
X.br
XUsing 
X.I texeqn 
Xalone does not typest the equations. If you want them typeset use the
X.B \-eqn
Xoption with TEX(1).
X.SH DIAGNOSTICS
XDisplayed equations that are started and ended by user-defined
Xcontrol sequences are regarded as text.
X.SH SEE ALSO
XTEX(1), detex(1), texexpand(1), texmatch(1)
X.SH AUTHOR
XKamal Al-Yahya, Stanford University
@//E*O*F texeqn.1//
chmod u=rw,g=rw,o=rw $OUT
 
echo x - texeqn1.c
if test -f texeqn1.c ; then
    echo texeqn1.c exists, putting output in $$texeqn1.c
    OUT=$$texeqn1.c
    STATUS=1
else
    OUT=texeqn1.c
fi
sed 's/^X//' > $OUT <<'@//E*O*F texeqn1.c//'
X/* texeqn: TeX equation stripping
X * to compile:   cc texeqn.c -o texeqn */

Xchar *documentation[] = {
X" SYNTAX",
X"        texeqn [-iw] file1 [file2 .....]",
X"     or texeqn [-iw]  < file1 [file2 ....]",
X"",
X"        Flags:",
X"              -i     ignores TeX's and LaTeX's \input files",
X"              -w     matching is not checked",
X"",
X"See the manual page for more details.",
X"",
X};

X/* Author: Kamal Al-Yahya, Stanford University,		11/1/83 */
X/* Modified:						6/30/86 */

Xint	doclength = { sizeof documentation/sizeof documentation[0] };

X#include        <stdio.h>
X#include        <sys/ioctl.h>
X#include        <sgtty.h>
X#define	MAXLEN	100000

Xstruct sgttyb ttystat;
Xextern char *strcpy(), *mktemp();
Xchar scratch_file[100];

Xint wflag;
Xint xargc;
Xchar **xargv;

Xmain(argc,argv)
Xint argc; 
Xchar *argv[];
X{
Xchar big[MAXLEN];
XFILE *temp,*scr;
Xregister char *cptr;
Xint piped_in;
Xint iflag,i;

X/* If no arguments, and not in a pipeline, self document */
Xpiped_in = ioctl ((fileno (stdin)), TIOCGETP, &ttystat);
Xif (argc == 1 && !piped_in)
X	{
X	for( i=0; i<doclength; i++)
X		printf("%s\n",documentation[i]);
X	exit (0);
X	}

X/* process option flags */
Xxargc = argc;
Xxargv = argv;
Xfor (xargc--,xargv++; xargc; xargc--,xargv++)
X	{
X	cptr = *xargv; 
X	if( *cptr=='-' )
X		{
X		while( *(++cptr))
X			{
X			switch( *cptr )
X				{
X				case 'i':
X					iflag=1;
X					break;
X				case 'w':
X					wflag=1;
X					break;
X				default:
X			     		fprintf(stderr,
X					"unknown flag -%c\n",*cptr);
X					break;
X				}
X			}
X		}
X	}

X/* first process pipe input */
Xif(piped_in)
X	{
X/* need to buffer; can't seek in pipes */
X/* make a temporary and volatile file in /tmp */
X	strcpy(scratch_file,"/tmp/texXXXXXX");
X	mktemp(scratch_file);
X	scr=fopen(scratch_file,"w");
X	scrbuf(stdin,scr);
X	fclose(scr);
X	scr=fopen(scratch_file,"r");
X	unlink(scratch_file);
X	if (wflag != 1)
X		{
X		fprintf(stderr,"Checking matching...\n");
X		TeXMatch(scr);
X		fseek(scr,0,0);
X		}
X/* either expand or buffer */
X	if (iflag != 1)
X		{ TeXExpand(scr,big,MAXLEN);	fclose(scr); }
X	else
X		{ tmpbuf(scr,big);		fclose(scr); }
X	if (wflag != 1)
X		fprintf(stderr,"Checking matching done\n\n");
X	TeXEqn(big);
X	fclose(scr);
X	}

X/* then process input line for arguments and assume they are input files */
Xxargc = argc;
Xxargv = argv;
Xfor (xargc--,xargv++; xargc; xargc--,xargv++)
X	{
X	cptr = *xargv; 
X	if( *cptr=='-' ) continue;		/* this is a flag */
X	if((temp=fopen(cptr,"r")) != NULL)
X		{
X		if (wflag != 1)
X			{
X			fprintf(stderr,"Checking matching...\n");
X			fprintf(stderr,"%s:\n",cptr);
X			TeXMatch(temp);
X			fprintf(stderr,"\n");
X			fseek(temp,0,0);
X			}
X/* either expand or buffer */
X		if (iflag != 1)
X			{ TeXExpand(temp,big,MAXLEN);	fclose(temp); }
X		else
X			{ tmpbuf(temp,big);		fclose(temp); }
X		if (wflag != 1)
X			fprintf(stderr,"Checking matching done\n\n");
X		TeXEqn(big);
X		fclose(temp);
X		}
X	else
X		fprintf(stderr,"texeqn: Cannot open %s\n",cptr);
X	}

X}

XTeXEqn(buffer)			/* srips TEX equations */
Xchar *buffer;
X{
Xint c,d;
Xint i,j,be;
Xwhile ((c = *buffer++) != '\0')
X	{
X	if(c == '%')
X		{
X		while ((c = *buffer++) != '\0')
X			if (c == '\n') break;
X		}
X	if(c == '$')
X		{
X		if ((d = *buffer++) == '$')
X			{
X			putc(c,stdout);	putc(d,stdout);
X			while ((c = *buffer++) != '\0')
X				{
X				if(c != '$')   putc(c,stdout);
X				else
X					{
X					buffer++;
X					fprintf(stdout,"$$ \n");
X					break;
X					}
X				}
X			}
X		}
X	if(c == '\\')
X		{			/* check for LaTeX \begin{equation} */
X		if ((c = *buffer++) =='b')
X		if ((i=begin_end_buf(buffer,&be)) == 0)
X			{
X			if (be == 1)
X				{
X				fprintf(stdout,"\\begin{equation}");
X				buffer += 14;
X				while ((c = *buffer++) != '\0')
X					{
X					if (c != '\\')
X						putc(c,stdout);
X					else	putc('\\',stdout);
X					if((i=begin_end_buf(buffer,&be)) > 0)
X						{
X						for (j=0; j < i; j++)
X							{
X							c = *buffer++;
X							putc(c,stdout);
X							}
X						}
X					else if (be == 2)
X					    {
X					    fprintf(stdout,"end{equation}\n");
X					    break;
X					    }
X					}
X				}
X			}
X		}
X	}
X}
@//E*O*F texeqn1.c//
chmod u=rw,g=rw,o=rw $OUT
 
echo x - texeqn2.c
if test -f texeqn2.c ; then
    echo texeqn2.c exists, putting output in $$texeqn2.c
    OUT=$$texeqn2.c
    STATUS=1
else
    OUT=texeqn2.c
fi
sed 's/^X//' > $OUT <<'@//E*O*F texeqn2.c//'
X/* texeqn: TeX equation stripping
X * to compile:   cc texeqn.c -o texeqn */

Xchar *documentation[] = {
X" SYNTAX",
X"        texeqn [-iw] [parameters] [inputfiles]",
X"",
X"        flags:",
X"              -i   ignores TeX's and LaTeX's \input and \include commands",
X"              -w   does not check matching",
X"",
X"        parameters:",
X"              in=filename       filename is the input file",
X"                                (Default: in=stdin)",
X"",
X"              out=filename      filename is the output file",
X"                                (Default: out=stdout)",
X""
X};

X/* Author: Kamal Al-Yahya, Stanford University,		11/1/83 */
X/* Modified:						6/30/86 */

Xint	doclength = { sizeof documentation/sizeof documentation[0] };

X#include        <stdio.h>
X#include        <sys/ioctl.h>
X#include        <sgtty.h>
X#define	MAXLEN	100000

Xchar string[100],filename[100];
Xstruct sgttyb ttystat;
Xextern char *strcpy(), *mktemp();
Xchar scratch_file[100];
XFILE *out_file;

Xint wflag;
Xint xargc;
Xchar **xargv;

Xmain(argc,argv)
Xint argc; 
Xchar *argv[];
X{
Xchar big[MAXLEN];
XFILE *temp,*scr;
Xregister char *cptr;
Xint piped_in;
Xint iflag,i;

X/* If no arguments, and not in a pipeline, self document */
Xpiped_in = ioctl ((fileno (stdin)), TIOCGETP, &ttystat);
Xif (argc == 1 && !piped_in)
X	{
X	for( i=0; i<doclength; i++)
X		printf("%s\n",documentation[i]);
X	exit (0);
X	}

Xout_file=stdout;			/* default standard output */

X/* process option flags */
Xxargc = argc;
Xxargv = argv;
Xfor (xargc--,xargv++; xargc; xargc--,xargv++)
X	{
X	cptr = *xargv; 
X	if( *cptr=='-' )
X		{
X		while( *(++cptr))
X			{
X			switch( *cptr )
X				{
X				case 'i':
X					iflag=1;
X					break;
X				case 'w':
X					wflag=1;
X					break;
X				default:
X			     		fprintf(stderr,
X					"unknown flag -%c\n",*cptr);
X					break;
X				}
X			}
X		}
X	}

X/* process getpar parameters */
Xxargc = argc;
Xxargv = argv;

Xif(getpar_("out","s",string))
X	{
X	sscanf(string,"%s",filename);
X	if((temp=fopen(filename,"w")) == NULL)
X		fprintf(stderr,"texeqn: Cannot open output file %s\n",filename);
X	else
X		out_file = temp;
X	}

X/* first process pipe input */
Xif(piped_in)
X	{
X/* need to buffer; can't seek in pipes */
X/* make a temporary and volatile file in /tmp */
X	strcpy(scratch_file,"/tmp/texXXXXXX");
X	mktemp(scratch_file);
X	scr=fopen(scratch_file,"w");
X	scrbuf(stdin,scr);
X	fclose(scr);
X	scr=fopen(scratch_file,"r");
X	unlink(scratch_file);
X	if (wflag != 1)
X		{
X		fprintf(stderr,"Checking matching...\n");
X		TeXMatch(scr);
X		fseek(scr,0,0);
X		}
X/* either expand or buffer */
X	if (iflag != 1)
X		{ TeXExpand(scr,big,MAXLEN);	fclose(scr); }
X	else
X		{ tmpbuf(scr,big);		fclose(scr); }
X	if (wflag != 1)
X		fprintf(stderr,"Checking matching done\n");
X	TeXEqn(big,out_file);
X	fclose(scr);
X	}

X/* next process in=inputfiles */
Xif(getpar_("in","s",string))
X	{
X	sscanf(string,"%s",filename);
X	if((temp=fopen(filename,"r")) != NULL)
X		{
X		if (wflag != 1)
X			{
X			fprintf(stderr,"Checking matching...\n");
X			fprintf(stderr,"%s:\n",cptr);
X			TeXMatch(temp);
X			fprintf(stderr,"\n");
X			fseek(temp,0,0);
X			}
X/* either expand or buffer */
X		if (iflag != 1)
X			{ TeXExpand(temp,big,MAXLEN);	fclose(temp); }
X		else
X			{ tmpbuf(temp,big);		fclose(temp); }
X		if (wflag != 1)
X			fprintf(stderr,"Checking matching done\n\n");
X		TeXEqn(big,out_file);
X		fclose(temp);
X		}
X		else
X			fprintf(stderr,"texeqn: Cannot open %s\n",filename);
X	}

X/* then process input line for arguments and assume they are input files */
Xfor (xargc--,xargv++; xargc; xargc--,xargv++)
X	{
X	cptr = *xargv; 
X	if( *cptr=='-' ) continue;		/* this is a flag */
X	while (*cptr)
X		{
X		if (*cptr == '=')  break; /* this is for getpar */
X		cptr++;
X		}       
X	if (*cptr)  continue;
X	cptr = *xargv;
X	if((temp=fopen(cptr,"r")) != NULL)
X		{
X		if (wflag != 1)
X			{
X			fprintf(stderr,"Checking matching...\n");
X			fprintf(stderr,"%s:\n",cptr);
X			TeXMatch(temp);
X			fprintf(stderr,"\n");
X			fseek(temp,0,0);
X			}
X/* either expand or buffer */
X		if (iflag != 1)
X			{ TeXExpand(temp,big,MAXLEN);	fclose(temp); }
X		else
X			{ tmpbuf(temp,big);		fclose(temp); }
X		if (wflag != 1)
X			fprintf(stderr,"Checking matching done\n\n");
X		TeXEqn(big,out_file);
X		fclose(temp);
X		}
X	else
X		fprintf(stderr,"texeqn: Cannot open %s\n",cptr);
X	}

X}

XTeXEqn(buffer,out_file)			/* srips TEX equations */

XFILE *out_file;
Xchar *buffer;
X{
Xint c,d;
Xint i,j,be;
Xwhile ((c = *buffer++) != '\0')
X	{
X	if(c == '%')
X		{
X		while ((c = *buffer++) != '\0')
X			if (c == '\n') break;
X		}
X	if(c == '$')
X		{
X		if ((d = *buffer++) == '$')
X			{
X			putc(c,out_file);	putc(d,out_file);
X			while ((c = *buffer++) != '\0')
X				{
X				if(c != '$')   putc(c,out_file);
X				else
X					{
X					buffer++;
X					fprintf(out_file,"$$ \n");
X					break;
X					}
X				}
X			}
X		}
X	if(c == '\\')
X		{			/* check for LaTeX \begin{equation} */
X		if ((c = *buffer++) =='b')
X		if ((i=begin_end_buf(buffer,&be)) == 0)
X			{
X			if (be == 1)
X				{
X				fprintf(out_file,"\\begin{equation}");
X				buffer += 14;
X				while ((c = *buffer++) != '\0')
X					{
X					if (c != '\\')
X						putc(c,out_file);
X					else	putc('\\',out_file);
X					if((i=begin_end_buf(buffer,&be)) > 0)
X						{
X						for (j=0; j < i; j++)
X							{
X							c = *buffer++;
X							putc(c,out_file);
X							}
X						}
X					else if (be == 2)
X					    {
X					    fprintf(out_file,"end{equation}\n");
X					    break;
X					    }
X					}
X				}
X			}
X		}
X	}
X}
@//E*O*F texeqn2.c//
chmod u=rw,g=rw,o=rw $OUT
 
echo x - texexpand.1
if test -f texexpand.1 ; then
    echo texexpand.1 exists, putting output in $$texexpand.1
    OUT=$$texexpand.1
    STATUS=1
else
    OUT=texexpand.1
fi
sed 's/^X//' > $OUT <<'@//E*O*F texexpand.1//'
X.TH texexpand 1 7/10/86
X.UC 4
X.SH NAME
Xtexexpand \- expands TeX's \\input and LaTeX's \\input{} and \\include{}.
X.SH SYNOPSIS
X.B texexpand [-w]
X.I filename
X.SH DESCRIPTION
XA TeX or LaTeX document can have included files.
X.I Texexpand
Xrewrites the document after inserting these files. The name of the
Xincluded file has to be correct relative to the current working
Xdirectory. If
X.I filename
Xcannot be open, it will try to open
X.I filename.tex.
XThe character '%' is recognized as a comment indicator and the commented
Xtext is not passed to the output.
X.br
XWarning is given if suspected unmatching is detected. Use the
X.B -w
Xflag to suppress these warnings.
X.SH SEE ALSO
Xtexeqn(1), texmatch(1), detex(1).
X.SH DIAGNOSTICS
XNesting of \\input and \\include is allowed but the number of opened files
Xmust not exceed the system's limit on the number of simultaneously opened
Xfiles (normally < 20).
X.SH AUTHOR
XKamal Al-Yahya, Stanford University, 7/10/86
@//E*O*F texexpand.1//
chmod u=rw,g=rw,o=rw $OUT
 
echo x - texspell
if test -f texspell ; then
    echo texspell exists, putting output in $$texspell
    OUT=$$texspell
    STATUS=1
else
    OUT=texspell
fi
sed 's/^X//' > $OUT <<'@//E*O*F texspell//'
X#! /bin/csh
X# shell for running texspell which is TeX and LaTeX's spell
X# Author: Kamal Al-Yahya 1984

Xset flag = 

Xif ($#argv == 0) then
X	echo "usage:  texspell [-w] file"
X	exit (-1)
Xendif
Xswitch ($argv[1])
X	case -w:
X		set flag = -w
X		if ($#argv == 1) then
X			echo "usage:  texspell [-w] file"
X			exit (-1)
X		endif
X		shift argv
X	endsw

Xwhile ($#argv > 0)
X		if -e $argv[1] then
X			detex $flag $argv[1] | spell
X		else
X			echo "Can't open $argv[1]"
X			exit(-1)
X		endif
X		shift argv
Xend
Xexit(0)
@//E*O*F texspell//
chmod u=rwx,g=rwx,o=rwx $OUT
 
echo Inspecting for damage in transit...
temp=/tmp/sharin$$; dtemp=/tmp/sharout$$
trap "rm -f $temp $dtemp; exit" 0 1 2 3 15
cat > $temp <<\!!!
      26      26     260 Manifest
      42     281    1891 README
     227     772    4562 TEX
     105     319    1689 TEX.1
     117     318    2308 TeXExpand.c
     337    1474    9163 TeXMatch.c
      56     266    1593 detex.1
     249     708    4818 detex1.c
     308     837    6166 detex2.c
       4      23     139 inc_file
       1       5      30 inc_file2.tex
      16      51     440 makefile
      20      97     704 makefile.par
      29     119     733 testfile
      40     177    1077 texeqn.1
     204     511    3965 texeqn1.c
     260     635    5314 texeqn2.c
      30     155     947 texexpand.1
      30      82     492 texspell
    2101    6856   46291 total
!!!
wc  Manifest README TEX TEX.1 TeXExpand.c TeXMatch.c detex.1 detex1.c detex2.c inc_file inc_file2.tex makefile makefile.par testfile texeqn.1 texeqn1.c texeqn2.c texexpand.1 texspell | sed 's=[^ ]*/==' | diff -b $temp - >$dtemp
if test -s $dtemp ; then
    echo "Ouch [diff of wc output]:"
    cat $dtemp
    STATUS=1
elif test $STATUS = 0 ; then
    echo "No problems found."
else
    echo "WARNING -- PROBLEMS WERE FOUND..."
fi
exit $STATUS
