Subject:  v07i066:  Image manipulation routines in C++, Part03/05
Newsgroups: mod.sources
Approved: mirror!rs

Submitted by: David Sher <seismo!rochester!sher>
Mod.sources: Volume 7, Issue 66
Archive-name: image/Part03


[  The Makefiles had ESCAPE and \r characters in their comment lines;
   I changed them to their printable representation, the two-character
   sequences ^[ and ^M, respectively.  Also, the file ascii2var/uu.test.var
   had some non-ASCII characters in it; I used uuencode; the resultant
   file is really ascii2var/test.var.  Also, I do not have C++ nor any
   images, so I have not tested this package.  --r$  ]

#!/bin/sh
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
# If all goes well, you will see the message "No problems found."
# Wrapped by mirror!rs on Mon Nov 10 13:43:02 EST 1986

# Exit status; set to 1 on "wc" errors or if would overwrite.
STATUS=0
# Contents:  varc++/double_image.h++ varc++/for.h++
#	varc++/iff_image.h++ varc++/iff_local.h++ varc++/iff_stdim.h++
#	varc++/image.h++ varc++/long_image.h++ varc++/makefile
#	varc++/var.h++ varc++/var_double_image.c++ varc++/var_image.c++
#	varc++/var_long_image.c++ vartools/README vartools/var2ascii.c++
#	vartools/ascii2var.c++
 
echo x - varc++/double_image.h++
if test -f varc++/double_image.h++ ; then
    echo varc++/double_image.h++ exists, putting output in $$varc++/double_image.h++
    OUT=$$varc++/double_image.h++
    STATUS=1
else
    OUT=varc++/double_image.h++
fi
sed 's/^X//' > $OUT <<'@//E*O*F varc++/double_image.h++//'
X/*
X    This file contains the definitions necessary to define an
X    image whose data is 8-bit
X*/

X#ifndef DOUBLE_IMAGE_H
X#define DOUBLE_IMAGE_H
X/* include the support for image data types */
X#include <image.h++>

X/*
X    the definition of the class to manage image structures
X*/
Xclass double_image : image_class
X    {
X    double *image_buffer;	// buffer to hold image
X    double **image_rows;	// pointers to the rows of the image
X    double **window_rows;	// pointers to the rows of the window
X    /* functions for function pointers */

X    /* this version of next assumes the window has been initialized */
X    int initialized_next ();

X    /* this version of prev assumes the window has been initialized */
X    int initialized_prev ();

X    /* this version of next initializes the window */
X    int uninitialized_next ();

X    /* this version of prev initializes the window */
X    int uninitialized_prev ();

X    /* this version of next says that the operation is impossible */
X    int impossible_next ();

X    /* this version of prev says that the operation is impossible */
X    int impossible_prev ();

X    /* uninitialized version of get_w_e will just die */
X    double uninitialized_get_w_e ( const card i , const card j );

X    /* initialized version of get_w_e */
X    double initialized_get_w_e ( const card i , const card j );

X    /* uninitialized version of write_w_e will just die */
X    void uninitialized_write_w_e ( const card i , const card j , const double value );

X    /* initialized version of write_w_e */
X    void initialized_write_w_e ( const card i , const card j , const double value );

X    /*
X	the function to write to the specified element of a window.
X	it is a function pointer so that unitialized windows
X	or protected images don't get read from
X    */
X    double (* get_w_e_pointer )( const card i , const card j  );

X    /*
X	the function to write to the specified element of a window.
X	it is a function pointer so that unitialized windows
X	or protected images don't get read from
X	can not check argument because it will point to internal
X	elements
X    */
X    void (* write_w_e_pointer )( const card i , const card j , const double value  );

Xpublic:
X    /* constructors */
X    /* the constructor when the image is being read from a file */
X    double_image
X	( 
X	const read_image_type rit , 	// marker that the image is being read
X	const FILE * image_file ,	// file for image
X	const card w_width = 1 ,	// window width
X	const card w_length = 1		// window length
X	);

X    /* the constructor when the image is built */
X    double_image
X	( 
X	const create_image_type cit ,	// marker that the image is being created
X	const card n_rows , 		// the number of rows in the image
X	const card n_cols , 		// the number of collumns in the image
X	const FILE * image_file ,	// file for image
X	const card w_width = 1 ,	// window width
X	const card w_length = 1 	// window length
X	);

X    /* destructor (who would want to destroy an image?) */
X    ~double_image ( ) { ; }

X    /* access routines for parts of data structure */
X    const card n_rows() { return number_rows ; }
X    const card n_cols() { return number_cols ; }
X    const image_prot the_prot() { return prot; }
X    const card c_length() { return comment_length ; }
X    const char *the_comments() { return comments ; }
X    const card the_collumn() { return collumn ; }
X    const card the_row() { return row ; }
X    const card the_width() { return window_width ; }
X    const card the_length() { return window_length ; }
X    const FILE * the_file() { return file ; }
X    const status image_init() { return image_status ; }
X    const status window_init() { return window_status ; }

X    /* access a pointer to a particular row */
X    const double * get_row( card row );

X    /* sets the comments */
X    void set_comments( char * string , const card length )
X	{
X	this->image_class::set_comments ( string , length );
X	}

X    /* adds a string to the comments */
X    void add_comment( char * string , const card length )
X	{
X	this->image_class::add_comment ( string , length );
X	}


X    /* real versions of virtual functions */
X    /* routine to write out the image to a file */
X    void write ( ) ;

X    /*
X	move in row n steps 
X	returns 1 when that motion is legal 0 otherwise
X    */
X    int move_collumn ( const int n ) ;

X    /*
X	move in collumn n steps
X	returns 1 when that motion is legal 0 otherwise
X    */
X    int move_row ( const int n ) ;

X    /*
X	move to specified row
X    */
X    void move_to_row ( const card n ) ;

X    /*
X	move to specified collumn
X    */
X    void move_to_collumn ( const card n ) ;

X    
X    /*
X	the function to get the specified element of a window
X	it is a function pointer so that unitialized windows
X	or protected images don't get read from
X	this accesses the function pointer
X    */
X    double get_w_e ( const card i , const card j )
X	{ return (( double (*) (...) )(* get_w_e_pointer)) ( this , i , j ); }

X    /*
X	the fast function without checking for initialization
X	of a function pointer for getting elements of a window
X	Also no bounds checking!
X	( Not recommended!)
X    */
X    double fast_g_w_e ( const card i , const card j )
X	{ return window_rows[i][j]; }
X    
X    /*
X	the function to write to the specified element of a window.
X	it is a function pointer so that unitialized windows
X	or protected images don't get read from
X	this accesses the function pointer
X    */
X    void write_w_e ( const card i , const card j , const double value )
X	{ ((void (*) (...) )(* write_w_e_pointer)) ( this , i , j , value ); }

X    /*
X	the fast function without checking for initialization
X	of a function pointer for writing elements to a window
X	Also no bounds checking!
X	( Not recommended!)
X    */
X    void fast_w_w_e ( const card i , const card j , const double value )
X	{ window_rows[i][j] = value; }

X    /* 
X	the function call on the image gets the upper left hand 
X	of the image window and returns a reference so it can be
X	used as a lvalue or rvalue
X	optimized so does not check that the window is initialized
X	if the window is not initialized then odd things may happen
X    */
X    double& operator() ()
X	{ return **window_rows; }
X    
X    /* 
X	move to next legal position in image
X	returns 1 when there is a next legal position 0 otherwise
X	if the window is not initialized then it initializes it.
X	with the window in the position 0,0 (if possible)
X    */
X    int (* next) (...); /* this will point to member functions! */

X    /* 
X	move to previous legal position in image
X	returns 1 when there is a previous legal position 0 otherwise
X	if the window is not initialized then it initializes it.
X	with the window in the farthest position (if possible)
X    */
X    int (* prev) (...); /* this will point to member functions! */

X    /*
X	Access for next and previous elements of images
X    */
X    int operator++ ( ) 
X	{ return (* next) ( this /* because points to member*/ ); }
X    int operator-- ( ) 
X	{ return (* prev) ( this /* because points to member*/ ); }

X    /*
X	Change the size of a window
X	causes the window to become uninitialized
X    */
X    void resize_window ( card width , card length );

X    /*
X	Causes the window to cover the entire image.
X	Allows one to access any part of the image with window operations
X    */
X    void window_entire_image ( );

X    };

X#endif DOUBLE_IMAGE_H
X/*
XCopyright (C) 1986, David Sher in the University of Rochester
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit, provided
Xthis copyright notice is retained.
X*/
@//E*O*F varc++/double_image.h++//
chmod u=rw,g=r,o=r $OUT
 
echo x - varc++/for.h++
if test -f varc++/for.h++ ; then
    echo varc++/for.h++ exists, putting output in $$varc++/for.h++
    OUT=$$varc++/for.h++
    STATUS=1
else
    OUT=varc++/for.h++
fi
sed 's/^X//' > $OUT <<'@//E*O*F varc++/for.h++//'
X/* prevents repeated reading of file */
X#ifndef FOR_H
X#define FOR_H 1
X/* 
X    this is to define true powerful iterators for for loops
X*/
X#define FOR { for /* so for loop is inside a block */
X#define ENDFOR } /* terminate block */
X#endif FOR_H
X/*
XCopyright (C) 1986, David Sher in the University of Rochester
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit, provided
Xthis copyright notice is retained.
X*/
@//E*O*F varc++/for.h++//
chmod u=rw,g=r,o=r $OUT
 
echo x - varc++/iff_image.h++
if test -f varc++/iff_image.h++ ; then
    echo varc++/iff_image.h++ exists, putting output in $$varc++/iff_image.h++
    OUT=$$varc++/iff_image.h++
    STATUS=1
else
    OUT=varc++/iff_image.h++
fi
sed 's/^X//' > $OUT <<'@//E*O*F varc++/iff_image.h++//'
X# include  "iff_stdim.h++"
X# include "iff_local.h++"
X/*
XCopyright (C) 1986, David Sher in the University of Rochester
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit, provided
Xthis copyright notice is retained.
X*/
@//E*O*F varc++/iff_image.h++//
chmod u=rw,g=r,o=r $OUT
 
echo x - varc++/iff_local.h++
if test -f varc++/iff_local.h++ ; then
    echo varc++/iff_local.h++ exists, putting output in $$varc++/iff_local.h++
    OUT=$$varc++/iff_local.h++
    STATUS=1
else
    OUT=varc++/iff_local.h++
fi
sed 's/^X//' > $OUT <<'@//E*O*F varc++/iff_local.h++//'
X/* 
Xlocal.h
Xdefinitions local to UR

XM. Swain 
XUniversity of Rochester
X8-JAN-86
X*/

X# define TRUE	1
X# define FALSE	0

X# define IN		0
X# define OUT	1

X# define MAXFNAMELEN	30
Xstatic char prog_name [ MAXFNAMELEN	] ;

X# define MAX(a,b) ((a) > (b) ? (a) : (b))
X# define MIN(a,b) ((a) < (b) ? (a) : (b))
X# define ABS(a) ((a) > 0 ? (a) : -(a))

X# define getimage(ifp,annote,im) { getheader(ifp,annote);\
X  im = (long *) malloc (ifp->nrows * ifp->ncols * sizeof (long));\
X  getimg (ifp, im); }
X/*
XCopyright (C) 1986, David Sher in the University of Rochester
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit, provided
Xthis copyright notice is retained.
X*/
@//E*O*F varc++/iff_local.h++//
chmod u=rw,g=r,o=r $OUT
 
echo x - varc++/iff_stdim.h++
if test -f varc++/iff_stdim.h++ ; then
    echo varc++/iff_stdim.h++ exists, putting output in $$varc++/iff_stdim.h++
    OUT=$$varc++/iff_stdim.h++
    STATUS=1
else
    OUT=varc++/iff_stdim.h++
fi
sed 's/^X//' > $OUT <<'@//E*O*F varc++/iff_stdim.h++//'
X/* file: image.h  */

X/* iff: Standard image file format					*/

X/* (c) Copyright 1982,
X   William S. Havens
X   Laboratory for Computational Vision
X   University of British Columbia

X   Adapted from image files developed by Randy Schulz at 
X    the University of Wisconsin-Madison
X   Differences:
X    1) Uses bit-stream I/O allowing random access of arbitrary size pixels.
X    2) Pixels may range in size from 0 to sizeof(long) = 32-bits.
X    3) Signed/unsigned images are supported.
X    4) Positive/negative images are supported.
X    5) Extensible user-defined parameter space is defined.
X*/

X#include  "bitio.h++"


X/* Image file definitions						*/

X#define IMAGIC	"Imagefile"	/* Magic number for image files		*/
X#define	IMVERSION 2		/* iff version number			*/
X#define	IMBPP     8		/* Default number of bits per pixel	*/
X#define IMSIGNED  0		/* Default image is unsigned		*/
X#define	IMPOSTVE  1		/* Default image is positive encoded	*/
X#define	IMNPARMS  6		/* # of image parameters in header	*/

X#define IMBLKSZE BBLKSZE	/* Use block size of bitio file		*/
X#define IMHDRSZE 1024		/* Physical header size in file		*/

Xstruct image 
X       {
X	struct iff_bfile	*bfile;		/* bitio file pointer			*/
X	long	nrows;		/* Number of rows in image		*/
X	long	ncols;		/* Number of columns in image		*/
X	short	bpp;		/* Bits per pixel			*/
X	short	is_signed;	/* Signed / Unsigned image		*/
X	short	positive;	/* Positive / Negative image		*/
X	short	hdroffset;	/* Header offset in file in bits	*/
X  } ;


Xstruct image *iopen(...), *idopen(...);

X/* Image header format	*/
X#define IMHDRFMT  "Imagefile version-%d: nrows = %D ncols = %D bpp = %hd signed = %hd positive = %hd\n"


X/* Macros */

X#define getpix(ifp)		bget ((ifp)->bfile, (ifp)->bpp, (ifp)->is_signed)
X#define putpix(ifp,pixel)	bput ((ifp)->bfile, pixel, (ifp)->bpp)
X#define isync(ifp)		bsync ((ifp)->bfile)
X#define iseek(ifp,row,col)	bseek ((ifp)->bfile, (long)((((ifp)->ncols*(row))+(col))*((ifp)->bpp)+(ifp)->hdroffset), 0)
X#define ierror(ifp)		berror ((ifp)->bfile)
X#define ieof(ifp)		beof ((ifp)->bfile)

X/* end of file image.h */
X/*
XCopyright (C) 1986, David Sher in the University of Rochester
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit, provided
Xthis copyright notice is retained.
X*/
@//E*O*F varc++/iff_stdim.h++//
chmod u=rw,g=r,o=r $OUT
 
echo x - varc++/image.h++
if test -f varc++/image.h++ ; then
    echo varc++/image.h++ exists, putting output in $$varc++/image.h++
    OUT=$$varc++/image.h++
    STATUS=1
else
    OUT=varc++/image.h++
fi
sed 's/^X//' > $OUT <<'@//E*O*F varc++/image.h++//'
X#ifndef IMAGE_H
X#define IMAGE_H
X/*
X    This file contains the definitions for 
X    the generic stuff for handling images
X*/

X/* 
X    define cardinal as integer 
X    (later I might want to implement a type of integer that does
X    bounds checking)
X*/
Xtypedef int card;

X/* tolerance for equality in floating point */
Xstatic const double EPSILON = 0.0000001;	


X/*
X    Infinite loop (real useful)
X*/
X#define LOOP for(;;)

X/*
X    define some constants for unbuffered io
X*/
Xstatic const int inputd = 0;
Xstatic const int outputd = 1;
Xstatic const int errord = 2;

X/*
X    define some system routines
X*/
Xint read ( int fd , void * buffer , int size );
Xint write ( int fd , void * buffer , int size );


X/*
X    The operations that can be applied when creating the window.
X    one can read in an image or create one.
X*/
Xenum create_image_type { CREATE = 7 };
Xenum read_image_type { READ = 4 };


X/* protection for images */
Xenum image_prot 
X    { 
X    CAN_READ = 1 , 
X    CAN_WRITE = 2 , 
X    CAN_READ_AND_WRITE = 3 ,
X    CAN_NOT_DO_ANYTHING = 4
X    };

X/*
X    useful for determining the status of data structures
X*/
Xenum status { INITIALIZED = 8 , UNINITIALIZED = 16 };

X/*
X    This is the abstract data type for any image
X    Actually objects of this type are not useful
X    it is meant to have derived types
X*/
Xclass image_class
X    {
Xpublic:
X    card number_rows;		// number rows in image
X    card number_cols;		// number of collumns in image
X    void * header_info ;	// any further header information required by implementation
X    image_prot prot;		// the protection of the image 
X    card comment_length;	// the length of the comments
X    char * comments ;		// comments about the image
X    status image_status;	// determines when image data is initialized

X    /* position in image */
X    status window_status;	// determines when the window has been initialized
X    card collumn;		// the collumn
X    card row;			// the row
X    card window_width;		// width of possible window in image
X    card window_length;		// length of possible window in image
X    FILE * file;		// file associated with image

X    /* constructors for images */
X    /* constructor when reading an image from a file */
X    image_class
X	( 
X	const read_image_type rit , 	// marker that the image is being read
X	const FILE * image_file ,	// file for image
X	const card w_width  ,	// window width
X	const card w_length 	// window length
X	);

X    /* constructor for creating a new image */
X    image_class
X	( 
X	const create_image_type cit,	// maker that the image is being created
X	const FILE * image_file , 	// the file for the image
X	const card n_rows , 		// the number of rows in the image
X	const card n_cols , 		// the number of collumns in the image
X	const card w_width , 		// the width of the window
X	const card w_length 		// the length of the window
X	);

X    /* destructor for images */
X    ~image_class () { ; }

X    /* comment manipulation */

X    /* sets the comments */
X    void set_comments( char * string , const card length );

X    /* adds a string to the comments */
X    void add_comment( char * string , const card length );

X    /* for moving around in an image */


X    /*
X	move in row n steps 
X	returns 1 when that motion is legal 0 otherwise
X    */
X    virtual int move_collumn ( const int n ) ;

X    /*
X	move in collumn n steps
X	returns 1 when that motion is legal 0 otherwise
X    */
X    virtual int move_row ( const int n ) ;

X    /*
X	move to specified row
X    */
X    virtual void move_to_row ( const card n ) ;

X    /*
X	move to specified collumn
X    */
X    virtual void move_to_collumn ( const card n ) ;

X    /* routine to write out the image to a file */
X    virtual void write ( ) ;

X    /* change the protection from CAN_WRITE to CAN_READ_AND_WRITE */
X    virtual void read_and_write ( );

X    };

X/* returns a null terminated string for comments */
Xconst char * comment_string ( image_class& i );


X#endif IMAGE_H
X/*
XCopyright (C) 1986, David Sher in the University of Rochester
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit, provided
Xthis copyright notice is retained.
X*/
@//E*O*F varc++/image.h++//
chmod u=rw,g=r,o=r $OUT
 
echo x - varc++/long_image.h++
if test -f varc++/long_image.h++ ; then
    echo varc++/long_image.h++ exists, putting output in $$varc++/long_image.h++
    OUT=$$varc++/long_image.h++
    STATUS=1
else
    OUT=varc++/long_image.h++
fi
sed 's/^X//' > $OUT <<'@//E*O*F varc++/long_image.h++//'
X/*
X    This file contains the definitions necessary to define an
X    image whose data is 8-bit
X*/

X#ifndef LONG_IMAGE_H
X#define LONG_IMAGE_H
X/* include the support for image data types */
X#include <image.h++>

X/*
X    the definition of the class to manage image structures
X*/
Xclass long_image : image_class
X    {
X    long *image_buffer;	// buffer to hold image
X    long **image_rows;	// pointers to the rows of the image
X    long **window_rows;	// pointers to the rows of the window
X    /* functions for function pointers */

X    /* this version of next assumes the window has been initialized */
X    int initialized_next ();

X    /* this version of prev assumes the window has been initialized */
X    int initialized_prev ();

X    /* this version of next initializes the window */
X    int uninitialized_next ();

X    /* this version of prev initializes the window */
X    int uninitialized_prev ();

X    /* this version of next says that the operation is impossible */
X    int impossible_next ();

X    /* this version of prev says that the operation is impossible */
X    int impossible_prev ();

X    /* uninitialized version of get_w_e will just die */
X    long uninitialized_get_w_e ( const card i , const card j );

X    /* initialized version of get_w_e */
X    long initialized_get_w_e ( const card i , const card j );

X    /* uninitialized version of write_w_e will just die */
X    void uninitialized_write_w_e ( const card i , const card j , const long value );

X    /* initialized version of write_w_e */
X    void initialized_write_w_e ( const card i , const card j , const long value );

X    /*
X	the function to write to the specified element of a window.
X	it is a function pointer so that unitialized windows
X	or protected images don't get read from
X    */
X    long (* get_w_e_pointer )( const card i , const card j  );

X    /*
X	the function to write to the specified element of a window.
X	it is a function pointer so that unitialized windows
X	or protected images don't get read from
X	can not check argument because it will point to internal
X	elements
X    */
X    void (* write_w_e_pointer )( const card i , const card j , const long value  );

Xpublic:
X    /* constructors */
X    /* the constructor when the image is being read from a file */
X    long_image
X	( 
X	const read_image_type rit , 	// marker that the image is being read
X	const FILE * image_file ,	// file for image
X	const card w_width = 1 ,	// window width
X	const card w_length = 1		// window length
X	);

X    /* the constructor when the image is built */
X    long_image
X	( 
X	const create_image_type cit ,	// marker that the image is being created
X	const card n_rows , 		// the number of rows in the image
X	const card n_cols , 		// the number of collumns in the image
X	const FILE * image_file ,	// file for image
X	const card w_width = 1 ,	// window width
X	const card w_length = 1 	// window length
X	);

X    /* destructor (who would want to destroy an image?) */
X    ~long_image ( ) { ; }

X    /* access routines for parts of data structure */
X    const card n_rows() { return number_rows ; }
X    const card n_cols() { return number_cols ; }
X    const image_prot the_prot() { return prot; }
X    const card c_length() { return comment_length ; }
X    const char *the_comments() { return comments ; }
X    const card the_collumn() { return collumn ; }
X    const card the_row() { return row ; }
X    const card the_width() { return window_width ; }
X    const card the_length() { return window_length ; }
X    const FILE * the_file() { return file ; }
X    const status image_init() { return image_status ; }
X    const status window_init() { return window_status ; }

X    /* access a pointer to a particular row */
X    const long * get_row( card row );

X    /* sets the comments */
X    void set_comments( char * string , const card length )
X	{
X	this->image_class::set_comments ( string , length );
X	}

X    /* adds a string to the comments */
X    void add_comment( char * string , const card length )
X	{
X	this->image_class::add_comment ( string , length );
X	}


X    /* real versions of virtual functions */
X    /* routine to write out the image to a file */
X    void write ( ) ;

X    /*
X	move in row n steps 
X	returns 1 when that motion is legal 0 otherwise
X    */
X    int move_collumn ( const int n ) ;

X    /*
X	move in collumn n steps
X	returns 1 when that motion is legal 0 otherwise
X    */
X    int move_row ( const int n ) ;

X    /*
X	move to specified row
X    */
X    void move_to_row ( const card n ) ;

X    /*
X	move to specified collumn
X    */
X    void move_to_collumn ( const card n ) ;

X    
X    /*
X	the function to get the specified element of a window
X	it is a function pointer so that unitialized windows
X	or protected images don't get read from
X	this accesses the function pointer
X    */
X    long get_w_e ( const card i , const card j )
X	{ return (( long (*) (...) )(* get_w_e_pointer)) ( this , i , j ); }

X    /*
X	the fast function without checking for initialization
X	of a function pointer for getting elements of a window
X	Also no bounds checking!
X	( Not recommended!)
X    */
X    long fast_g_w_e ( const card i , const card j )
X	{ return window_rows[i][j]; }
X    
X    /*
X	the function to write to the specified element of a window.
X	it is a function pointer so that unitialized windows
X	or protected images don't get read from
X	this accesses the function pointer
X    */
X    void write_w_e ( const card i , const card j , const long value )
X	{ ((void (*) (...) )(* write_w_e_pointer)) ( this , i , j , value ); }

X    /*
X	the fast function without checking for initialization
X	of a function pointer for writing elements to a window
X	Also no bounds checking!
X	( Not recommended!)
X    */
X    void fast_w_w_e ( const card i , const card j , const long value )
X	{ window_rows[i][j] = value; }

X    /* 
X	the function call on the image gets the upper left hand 
X	of the image window and returns a reference so it can be
X	used as a lvalue or rvalue
X	optimized so does not check that the window is initialized
X	if the window is not initialized then odd things may happen
X    */
X    long& operator() ()
X	{ return **window_rows; }
X    
X    /* 
X	move to next legal position in image
X	returns 1 when there is a next legal position 0 otherwise
X	if the window is not initialized then it initializes it.
X	with the window in the position 0,0 (if possible)
X    */
X    int (* next) (...); /* this will point to member functions! */

X    /* 
X	move to previous legal position in image
X	returns 1 when there is a previous legal position 0 otherwise
X	if the window is not initialized then it initializes it.
X	with the window in the farthest position (if possible)
X    */
X    int (* prev) (...); /* this will point to member functions! */

X    /*
X	Access for next and previous elements of images
X    */
X    int operator++ ( ) 
X	{ return (* next) ( this /* because points to member*/ ); }
X    int operator-- ( ) 
X	{ return (* prev) ( this /* because points to member*/ ); }

X    /*
X	Change the size of a window
X	causes the window to become uninitialized
X    */
X    void resize_window ( card width , card length );

X    /*
X	Causes the window to cover the entire image.
X	Allows one to access any part of the image with window operations
X    */
X    void window_entire_image ( );

X    };

X#endif LONG_IMAGE_H
X/*
XCopyright (C) 1986, David Sher in the University of Rochester
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit, provided
Xthis copyright notice is retained.
X*/
@//E*O*F varc++/long_image.h++//
chmod u=rw,g=r,o=r $OUT
 
echo x - varc++/makefile
if test -f varc++/makefile ; then
    echo varc++/makefile exists, putting output in $$varc++/makefile
    OUT=$$varc++/makefile
    STATUS=1
else
    OUT=varc++/makefile
fi
sed 's/^X//' > $OUT <<'@//E*O*F varc++/makefile//'
X# this is the makefile for the var library

X# This line constructs the library name (equal to the directory name)
X# jccpwd^[!!sh^M:s/.*\///g^MILIBRARY = lib^[A.a^[
XLIBRARY = libvarc++.a

X.SUFFIXES: .c++ 


XCFLAGS = -O  -I/usr/grads/include -DVAX 

XC++FLAGS = +i $(CFLAGS)

XLIBS = -liff -lC

X# This line constructs the list of possible objects
X# 2jc}ls *[A-Za-z0-9].c *.c++^[!!sh^M>}>}:g/\.c\+*$/ s//.o \\/^M
XOBJS = \
X	double_image.o \
X	image.o \
X	long_image.o \
X	var_double_image.o \
X	var_image.o \
X	var_long_image.o 


X.c++.o:
X	c++ -c  $(C++FLAGS) $*.c++ 

X# the library is constructed by this line
X$(LIBRARY) : $(OBJS)
X	ar qv $(LIBRARY) $(OBJS)
X	ranlib $(LIBRARY)

@//E*O*F varc++/makefile//
chmod u=rw,g=r,o=r $OUT
 
echo x - varc++/var.h++
if test -f varc++/var.h++ ; then
    echo varc++/var.h++ exists, putting output in $$varc++/var.h++
    OUT=$$varc++/var.h++
    STATUS=1
else
    OUT=varc++/var.h++
fi
sed 's/^X//' > $OUT <<'@//E*O*F varc++/var.h++//'
X/*
X    This file contains the definitions necessary to use
X    vision archive based stuff.
X*/
X#ifndef VAR_H
X#define VAR_H 1

X/*
X    Structure for a list of positions filenames and 
X    file types
X*/
Xstruct band
X    {
X    int b_position;			// The position of a band in the pixel
X    char * b_file_name;		// The name of the file
X    char * b_file_type;		// The type of the file
X    };

X/*
X    header structure for archive files
X*/
Xstruct var_header
X    {
X    char *		vh_file_type;	// type of entire file
X    int			vh_bytes_per_pixel;
X    int			vh_number_bands;
X    struct band *	vh_bands;	// bands to store image
X    int 		vh_length;	// length of image
X    int 		vh_width;	// width of image
X    char * 		vh_comments;	// the comments on the image
X    char *		vh_header;	// the contents of the _.HEADER file
X    };

X/*
X    structure for storing color info.
X    Overlay field is in for compatibility with 
X    ikonas.  Also it rounds out the data structure
X    so it is an integral number of words long.
X*/
Xstruct color_pixel
X    {
X    unsigned char red;		// red pixel
X    unsigned char green;	// green pixel
X    unsigned char blue;		// blue pixel
X    unsigned char overlay;	// overlay pixel
X    };

X/*
X    Reads in the beginning of 
X    an archive and parses the Header file
X*/
Xstruct var_header *
Xvar_read_header(FILE * var_file);

X/*
X    This is the general data reading routine that reads in any kind
X    of data
X*/
Xvoid *
Xvar_read_data(FILE * var_file , struct var_header * vh );

X/*
X    Returns an array of doubles given a file that
X    can be used otherwise fails
X    also fills in comment field
X*/
Xdouble *
Xvar_read_doubles(FILE * var_file , struct var_header * vh );

X/*
X    Returns an array of longs given a file that can be
X    used that way otherwise fails
X    also fills in comment field
X*/
Xlong *
Xvar_read_longs (FILE * var_file , struct var_header * vh );

X/*
X    Returns an array of color structures for 
X    color images
X    also fills in comment field
X*/
Xstruct color_pixel *
Xvar_read_color (FILE * var_file , struct var_header * vh );

X/*
X    Creates the beginning of 
X    an archive 
X*/
Xstruct var_header *
Xvar_create_header
X    (
X    char * file_type, 
X    char * comments, 
X    int bytes_per_pixel,
X    int number_bands,
X    struct band * bands,
X    int length,
X    int width
X    );

X/*
X    sets up the header for an array of doubles
X*/
Xstruct var_header *
Xvar_create_double_header ( int length , int width );

X/*
X    sets up the header for an array of longs
X*/
Xstruct var_header *
Xvar_create_long_header ( int length , int width );

X/*
X    sets up the header for an array of color pixels
X*/
Xstruct var_header *
Xvar_create_color_header ( int length , int width );

X/*
X    Writes the header and comments for a file
X    otherwise fails
X    also fills in comment field
X*/
Xvoid
Xvar_write_header(FILE * var_file , struct var_header * vh);

X/*
X    Writes the data out to the file as directed by the header
X*/
Xvoid
Xvar_write_data(FILE * var_file ,  struct var_header * vh , void * data );

X/*
X    Writes an array of doubles given a file that
X    can be used otherwise fails
X    also fills in comment field
X*/
Xvoid
Xvar_write_doubles(FILE * var_file , struct var_header * vh, double * array );

X/*
X    Writes an array of longs given a file that can be
X    used that way otherwise fails
X    also fills in comment field
X*/
Xvoid
Xvar_write_longs (FILE * var_file , struct var_header * vh, long * array );

X/*
X    Writes an array of color structures for 
X    color images
X    also fills in comment field
X*/
Xvoid
Xvar_write_color (FILE * var_file , struct var_header * vh, struct color_pixel * array );


X#endif VAR_H
X/*
XCopyright (C) 1986, David Sher in the University of Rochester
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit, provided
Xthis copyright notice is retained.
X*/
@//E*O*F varc++/var.h++//
chmod u=rw,g=r,o=r $OUT
 
echo x - varc++/var_double_image.c++
if test -f varc++/var_double_image.c++ ; then
    echo varc++/var_double_image.c++ exists, putting output in $$varc++/var_double_image.c++
    OUT=$$varc++/var_double_image.c++
    STATUS=1
else
    OUT=varc++/var_double_image.c++
fi
sed 's/^X//' > $OUT <<'@//E*O*F varc++/var_double_image.c++//'
X/*
X    This is the interface between the mv image file format
X    and my c++ image handling datatype for images full of doubles
X*/
X#include <stream.h>
X#include <stdio.h>
X#include <string.h>
X#include "error.h++"
X#include "var.h++"
X#include "image.h++"
X#include "for.h++"
X#include "double_image.h++"

X/*
X    Reads in a double image from a mv file
X*/
Xdouble_image::double_image 
X	( 
X	const read_image_type rit , 	// marker that the image is being read
X	const FILE * image_file ,	// file for image
X	const card w_width = 1 ,	// window width
X	const card w_length = 1		// window length
X	)
X    : ( READ , image_file ,  w_width , w_length )
X    {
X    /* check that the constructor is called correctly */
X    if ( rit != READ )
X	{
X	cerr << "constructor for double_image being called in obscure way\n";
X	abort();
X	}
X    
X    /* read in image from file */
X    struct var_header *vh = (struct var_header *) header_info;
X    double * image_buffer = var_read_doubles ( image_file , vh );
X    if (error_occured)
X	{
X	cerr << "error when reading in data from file";
X	print_errors_and_abort();
X	}
X    /* assign fields of the class */
X    comments = vh->vh_comments;
X    comment_length = strlen(vh->vh_comments);
X    number_rows = vh->vh_length;
X    number_cols = vh->vh_width;

X    /* allocate space for dope vector */
X    image_rows = new double * [ number_rows ];
X    /* allocate space for window dope vector */
X    window_rows = new double * [ w_length ];

X    /* initialize dope vector */
X    FOR(int i1 = 0 ; i1 < number_rows; i1++)
X	{
X	image_rows[i1] = image_buffer + i1*number_cols;
X	}
X    ENDFOR

X    /* set up the protection  so the image can be written */
X    prot = CAN_READ;

X    /* initialize function pointers */
X    next = &uninitialized_next;
X    prev = &uninitialized_prev;
X    get_w_e_pointer = &uninitialized_get_w_e;
X    write_w_e_pointer = &uninitialized_write_w_e;
X    }

X/*
X    This writes out a double image to a mv image file
X*/
Xvoid
Xdouble_image::write ( )
X    {
X    /* do the image independent stuff */
X    this->image_class::write();

X    /* fill in the relevant fields of the header info */
X    struct var_header *vh = var_create_double_header(number_rows,number_cols);
X    vh->vh_comments = comments;

X    /* put the header, comments and data out to the file */
X    var_write_doubles(file,vh,image_buffer);
X    
X    }
X/*
XCopyright (C) 1986, David Sher in the University of Rochester
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit, provided
Xthis copyright notice is retained.
X*/
@//E*O*F varc++/var_double_image.c++//
chmod u=rw,g=r,o=r $OUT
 
echo x - varc++/var_image.c++
if test -f varc++/var_image.c++ ; then
    echo varc++/var_image.c++ exists, putting output in $$varc++/var_image.c++
    OUT=$$varc++/var_image.c++
    STATUS=1
else
    OUT=varc++/var_image.c++
fi
sed 's/^X//' > $OUT <<'@//E*O*F varc++/var_image.c++//'
X/*
X    This the support for generic images using the mv image file format
X*/

X#include <stream.h>
X#include <stdio.h>
X#include <string.h>
X#include "for.h++"
X#include "var.h++"
X#include "error.h++"
X#include "image.h++"

X/*
X    Reads in the data type independent header information from the
X    mv file and stores it in the relevant places
X*/
Ximage_class::image_class
X    ( 
X    const read_image_type rit , 	// marker that the image is being read
X    const FILE * image_file ,	// file for image
X    const card w_width  ,	// window width
X    const card w_length 	// window length
X    )
X    {
X    /* check that the constructor is called correctly */
X    if ( rit != READ )
X	{
X	cerr << "Generic constructor for image being called in obscure way\n";
X	abort();
X	}

X    /* initialize using arguments */
X    file = image_file;
X    window_width = w_width;
X    window_length = w_length;

X    /* the header for the var file */
X    /* read in the header for the var file */
X    /* put the annotation in as comments */
X    struct var_header *vh = var_read_header(image_file);
X    /* check if error occured */
X    if (error_occured)
X	{
X	cerr << "Error when reading in header for image";
X	print_errors_and_abort();
X	}
X    /* place the header in the header slot */
X    header_info = vh;

X    /* a priori initializations */
X    /* status */
X    image_status = UNINITIALIZED;
X    window_status = UNINITIALIZED;
X    prot = CAN_READ;
X    }

X/*
X    Sets up the data type independent header information to be read 
X    out to the mv file.
X*/
Xvoid
Ximage_class::write ()
X    {
X    /* check that the protection allows the image to be written */
X    if ( (prot != CAN_WRITE) && (prot != CAN_READ_AND_WRITE))
X	{
X	cerr << "Trying to write image that is write protected to file";
X	abort();
X	}

X    }
X/*
XCopyright (C) 1986, David Sher in the University of Rochester
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit, provided
Xthis copyright notice is retained.
X*/
@//E*O*F varc++/var_image.c++//
chmod u=rw,g=r,o=r $OUT
 
echo x - varc++/var_long_image.c++
if test -f varc++/var_long_image.c++ ; then
    echo varc++/var_long_image.c++ exists, putting output in $$varc++/var_long_image.c++
    OUT=$$varc++/var_long_image.c++
    STATUS=1
else
    OUT=varc++/var_long_image.c++
fi
sed 's/^X//' > $OUT <<'@//E*O*F varc++/var_long_image.c++//'
X/*
X    This is the interface between the mv image file format
X    and my c++ image handling datatype for images full of longs
X*/
X#include <stream.h>
X#include <stdio.h>
X#include "error.h++"
X#include "var.h++"
X#include "image.h++"
X#include "for.h++"
X#include "long_image.h++"

X/*
X    Reads in a long image from a mv file
X*/
Xlong_image::long_image 
X	( 
X	const read_image_type rit , 	// marker that the image is being read
X	const FILE * image_file ,	// file for image
X	const card w_width = 1 ,	// window width
X	const card w_length = 1		// window length
X	)
X    : ( READ , image_file ,  w_width , w_length )
X    {
X    /* check that the constructor is called correctly */
X    if ( rit != READ )
X	{
X	cerr << "constructor for long_image being called in obscure way\n";
X	abort();
X	}
X    
X    /* read in image from file */
X    struct var_header *vh = (struct var_header *) header_info;
X    long * image_buffer = var_read_longs ( image_file , vh );
X    if (error_occured)
X	{
X	cerr << "error when reading in data from file";
X	print_errors_and_abort();
X	}
X    /* assign fields of the class */
X    comments = vh->vh_comments;
X    comment_length = strlen(vh->vh_comments);
X    number_rows = vh->vh_length;
X    number_cols = vh->vh_width;

X    /* allocate space for dope vector */
X    image_rows = new long * [ number_rows ];
X    /* allocate space for window dope vector */
X    window_rows = new long * [ w_length ];

X    /* initialize dope vector */
X    FOR(int i1 = 0 ; i1 < number_rows; i1++)
X	{
X	image_rows[i1] = image_buffer + i1*number_cols;
X	}
X    ENDFOR

X    /* set up the protection  so the image can be written */
X    prot = CAN_READ;

X    /* initialize function pointers */
X    next = &uninitialized_next;
X    prev = &uninitialized_prev;
X    get_w_e_pointer = &uninitialized_get_w_e;
X    write_w_e_pointer = &uninitialized_write_w_e;
X    }

X/*
X    This writes out a long image to a mv image file
X*/
Xvoid
Xlong_image::write ( )
X    {
X    /* do the image independent stuff */
X    this->image_class::write();

X    /* fill in the relevant fields of the header info */
X    struct var_header *vh = var_create_long_header(number_rows,number_cols);
X    vh->vh_comments = comments;

X    /* put the header, comments and data out to the file */
X    var_write_longs(file,vh,image_buffer);
X    
X    }
X/*
XCopyright (C) 1986, David Sher in the University of Rochester
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit, provided
Xthis copyright notice is retained.
X*/
@//E*O*F varc++/var_long_image.c++//
chmod u=rw,g=r,o=r $OUT
 
echo x - vartools/README
if test -f vartools/README ; then
    echo vartools/README exists, putting output in $$vartools/README
    OUT=$$vartools/README
    STATUS=1
else
    OUT=vartools/README
fi
sed 's/^X//' > $OUT <<'@//E*O*F vartools/README//'
XThis is the directory in which the most useful utility routines for
Xmanipulating var files are gathered into a package.
@//E*O*F vartools/README//
chmod u=rw,g=r,o=r $OUT
 
echo x - vartools/var2ascii.c++
if test -f vartools/var2ascii.c++ ; then
    echo vartools/var2ascii.c++ exists, putting output in $$vartools/var2ascii.c++
    OUT=$$vartools/var2ascii.c++
    STATUS=1
else
    OUT=vartools/var2ascii.c++
fi
sed 's/^X//' > $OUT <<'@//E*O*F vartools/var2ascii.c++//'
X/*
X    This contains the work routine that converts an image to
X    a ascii file
X*/
X#include <stream.h>
X#include <stdio.h>
X#include <double_image.h++>
X#include "vartools.h++"


X// input is an initialized image
X// output is a file pointer open for output
X// format is the format to output each number
Xvoid
Xvar2ascii2(double_image& input , FILE *output , char *format )
X    {
X    // output the length and the width
X    fprintf(output,"%d %d",input.n_rows(),input.n_cols());

X    // iterate through the input image
X    while(input++)
X	{
X	// if at the beginning of a row output a carriage return
X	if(input.the_collumn() == 0)
X	    {
X	    fprintf(output,"\n");
X	    }
X	// output the element of input
X	fprintf(output,format,input());
X	}
X    
X    // print out the comments
X    fprintf(output,"\n%s",input.the_comments());

X    // make sure the output goes to some file
X    fflush(output);
X    }

X/*
X    This is a version of var2ascii that takes an input file rather
X    than an initialized image
X*/
Xvoid
Xvar2ascii(FILE *input, FILE *output , char *format)
X    {
X    // read in the image
X    double_image input_image(READ,input);
X    // call the work function
X    var2ascii2(input_image,output,format);
X    }
X/*
XCopyright (C) 1986, David Sher in the University of Rochester
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit, provided
Xthis copyright notice is retained.
X*/
@//E*O*F vartools/var2ascii.c++//
chmod u=rw,g=r,o=r $OUT
 
echo x - vartools/ascii2var.c++
if test -f vartools/ascii2var.c++ ; then
    echo vartools/ascii2var.c++ exists, putting output in $$vartools/ascii2var.c++
    OUT=$$vartools/ascii2var.c++
    STATUS=1
else
    OUT=vartools/ascii2var.c++
fi
sed 's/^X//' > $OUT <<'@//E*O*F vartools/ascii2var.c++//'
X/*
X    This contains the work routine that converts an image to
X    a ascii file
X*/
X#include <stream.h>
X#include <stdio.h>
X#include <string.h>
X#include <double_image.h++>
X#include "vartools.h++"


X// input is a file pointer to the input file
X// output is a file pointer open for output
Xvoid
Xascii2var(FILE *input , FILE *output)
X    {
X    int number_rows = -1;
X    int number_cols = -1;
X    // read the length and the width
X    fscanf(input,"%d%d",&number_rows,&number_cols);
X    // initialize the image
X    double_image output_image(CREATE,number_rows,number_cols,output);

X    // iterate through the output image reading in numbers
X    while(output_image++)
X	{
X	fscanf(input,"%lf",&(output_image()));
X	}
X    
X    // scan through the image until an end of file or a new line
X    char c;
X    for(;;) 
X	{
X	c = getc(input);
X	if ( c == EOF ) return ;
X	if ( c == '\n') break;
X	}

X    // read in the comments
X    int comments_size = 128;
X    char * comments = new char[comments_size];
X    for ( int i = 0 ; EOF != (c = getc(input)) ; i++ )
X	{
X	// if you ran out of room double the size of the comments
X	if ( i == comments_size )
X	    {
X	    char *new_comments = new char[comments_size + comments_size];
X	    for( int j = 0 ; j < comments_size ; j++ )
X		{
X		new_comments[j] = comments[j];
X		}
X	    comments_size += comments_size;
X	    comments = new_comments;
X	    }
X	comments[i] = c;
X	}
X    comments[i] = 0;
X    output_image.set_comments(comments,i);

X    // write the output to disk
X    output_image.write();
X    }
X/*
XCopyright (C) 1986, David Sher in the University of Rochester
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit, provided
Xthis copyright notice is retained.
X*/
@//E*O*F vartools/ascii2var.c++//
chmod u=rw,g=r,o=r $OUT
 
echo Inspecting for damage in transit...
temp=/tmp/sharin$$; dtemp=/tmp/sharout$$
trap "rm -f $temp $dtemp; exit" 0 1 2 3 15
cat > $temp <<\!!!
     239    1271    7543 double_image.h++
      15      88     492 for.h++
       8      48     302 iff_image.h++
      31     132     735 iff_local.h++
      68     341    2328 iff_stdim.h++
     159     700    4149 image.h++
     239    1271    7497 long_image.h++
      34      94     667 makefile
     165     628    3868 var.h++
      91     375    2578 var_double_image.c++
      77     312    2018 var_image.c++
      90     373    2530 var_long_image.c++
       2      20     120 README
      56     201    1450 var2ascii.c++
      68     262    1760 ascii2var.c++
    1342    6116   38037 total
!!!
wc  varc++/double_image.h++ varc++/for.h++ varc++/iff_image.h++ varc++/iff_local.h++ varc++/iff_stdim.h++ varc++/image.h++ varc++/long_image.h++ varc++/makefile varc++/var.h++ varc++/var_double_image.c++ varc++/var_image.c++ varc++/var_long_image.c++ vartools/README vartools/var2ascii.c++ vartools/ascii2var.c++ | sed 's=[^ ]*/==' | diff -b $temp - >$dtemp
if test -s $dtemp ; then
    echo "Ouch [diff of wc output]:"
    cat $dtemp
    STATUS=1
elif test $STATUS = 0 ; then
    echo "No problems found."
else
    echo "WARNING -- PROBLEMS WERE FOUND..."
fi
exit $STATUS
