Subject:  v07i065:  Image manipulation routines in C++, Part02/05
Newsgroups: mod.sources
Approved: mirror!rs

Submitted by: David Sher <seismo!rochester!sher>
Mod.sources: Volume 7, Issue 65
Archive-name: image/Part02


[  The Makefiles had ESCAPE and \r characters in their comment lines;
   I changed them to their printable representation, the two-character
   sequences ^[ and ^M, respectively.  Also, the file ascii2var/uu.test.var
   had some non-ASCII characters in it; I used uuencode; the resultant
   file is really ascii2var/test.var.  Also, I do not have C++ nor any
   images, so I have not tested this package.  --r$  ]

#!/bin/sh
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
# If all goes well, you will see the message "No problems found."
# Wrapped by mirror!rs on Mon Nov 10 13:40:52 EST 1986

# Exit status; set to 1 on "wc" errors or if would overwrite.
STATUS=0
# Contents:  man/vartools.3 man/var2ascii.1 man/truncate.1
#	man/scale.1 man/correlate.1 man/lowerbound.1 man/upperbound.1
#	scale/main.c++ scale/makefile truncate/main.c++ truncate/makefile
#	upperbound/main.c++ upperbound/makefile var2ascii/main.c++
#	var2ascii/makefile varc++/archive.h++ varc++/bitio.h++
#	varc++/char_image.h++ varc++/error.h++
 
echo x - man/vartools.3
if test -f man/vartools.3 ; then
    echo man/vartools.3 exists, putting output in $$man/vartools.3
    OUT=$$man/vartools.3
    STATUS=1
else
    OUT=man/vartools.3
fi
sed 's/^X//' > $OUT <<'@//E*O*F man/vartools.3//'
X.TH VARTOOLS 3 8/25/86
X.CM 1
X.SH "NAME"
Xvartools \- iff2var var2iff ascii2var var2ascii trunc scale correlate trunc2 scale2 correlate2
X.SH "SYNOPSIS"
X.nf
XCompile with -lvartools -lvar -liff -lC (C)
XCompile with -lvartools -lvar -liff (C++)
X#include <vartools.h> (C)
X#include <vartools.h++> (C++)
X/*
X    This routine gets information from an iff file and constructs
X    a var file from it
X    comments is a null terminated string that sets up the
X    comments for the var file
X*/
Xvoid
Xiff2var(FILE *iff_file, FILE *var_file, char *comments);
X.sp
X/*
X    This routine gets information from a var file and constructs
X    an iff file from it.
X    This only works with graytone (integer) var files 
X    To make a double var file into a graytone one use trunc
X*/
Xvoid
Xvar2iff(FILE *var_file, FILE *iff_file);
X.sp
X/*
X    This converts a file in ascii format to a double var file
X    ascii format is 2 dimensions followed by an appropriate number
X    of doubles followed by comments
X    input is a file pointer to the input file
X    output is a file pointer open for output
X*/
Xvoid
Xascii2var(FILE *input , FILE *output);
X.sp
X/*
X   This takes an initialized double image and outputs a file in ascii format
X   described above
X   input is an initialized image
X   output is a file pointer open for output
X   format is the format to output each number
X*/
Xvoid
Xvar2ascii2(double_image& input , FILE *output , char *format );
X.sp
X/*
X    This is a version of var2ascii that takes an input file rather
X    than an initialized image
X*/
Xvoid
Xvar2ascii(FILE *input, FILE *output , char *format);
X.sp
X/*
X    Truncates an input image (takes floating point to long)
X    needs a file to be output to
X    but does not write to file
X    instead returns the truncated image
X*/
Xlong_image&
Xtrunc2( double_image& input , FILE *outfile );
X.sp
X/*
X    Truncates a double image into a graytone (integer image)
X    Takes two files and reads from one to write to the other
X    comment is a comment to be placed on the image
X*/
Xvoid
Xtrunc( FILE *infile , FILE *outfile, char *comment);
X.sp
X/*
X    This takes an image as input and creates another
X    It takes every pixel of the image and multiplies it by the
X    scale and then adds to it the increment.
X*/
Xdouble_image&
Xscale2(double scale, double increment, double_image& input, FILE *output_file);
X.sp
X/*
X    This takes two files and takes one and puts 
X    a scaled and incremented version into the other
X    comment will be placed in the comment for the output image
X*/
Xvoid
Xscale(double scale, double increment, FILE *input, FILE *output, char * comment);
X.sp
X/*
X   this one takes 2 images and returns an image containing the 
X   correlation of the input image with the template image
X   it only returns values for the point where the template lies
X   entirely within the input
X*/
Xdouble_image&
Xcorrelate2(double_image& template, double_image& input, FILE *output_file);
X.sp
X/*
X   this one takes 2 image files and returns an image file containing the 
X   correlation of the input image with the template image
X   it only returns values for the point where the template lies
X   entirely within the input
X*/
Xvoid
Xcorrelate(FILE *template_file, FILE *input_file, FILE *output_file, char *comment);
X.sp
X/*
X    This code places an upper bound on the values of the pixels.
X    If a pixel exceeds the bound it is set to the bound.
X*/
Xdouble_image&
Xupper_bound2(double bound, double_image& input, FILE * output_file);
X.sp
X/*
X    This code places an lower bound on the values of the pixels.
X    If a pixel exceeds the bound it is set to the bound.
X*/
Xdouble_image&
Xlower_bound2(double bound, double_image& input, FILE * output_file);
X.sp
X/*
X    This code is like upper_bound2 but with files (for C)
X*/
Xvoid
Xupper_bound(double bound, FILE * input_file, FILE * output_file, char *comment);
X.sp
X/*
X    This code is like lower_bound2 but with files (for C)
X*/
Xvoid
Xlower_bound(double bound, FILE * input_file, FILE * output_file, char *comment);
X.fi
X.SH "DESCRIPTION"
XThis is a package of tools to do useful things with var files.
XI make no claims about the completeness or consistency of this package.
XIt is meant to be used with the var(3) routines and to be called
Xeither from C or C++.
XAt the moment it is considerably more
Xconvinient to use from C++ with the image(5) package.
XThe routines are as shown below, routines that end with 2 are meant
Xonly to be called from C++ with the image(5) package.
X.IP "iff2var"
XThis is a routine written in C that takes 2 file pointers and
Xretrieves a valid iff file from the first and sends a valid var file
Xwith the same information into the second.
XAny annotation in the
Xiff file is lost.
X.IP "var2iff"
XThis is the inverse operation to iff2var.
XIt reads a varfile
Xand writes an iff file.
XAny comments in the varfile are lost.
XIt is also written in C.
X.IP "ascii2var"
XThis reads in a file in an ascii format.
XThe ascii format is
Xto have the first two things in the file be the length and width
Xof the image.
XThen each pixel of the image is read in as the
Xascii representation of a floating point number.
XAftern a sufficient
Xnumber of numbers are read in the rest of the file is considerred to
Xbe comments.
XThis ascii format is convinient when constructing templates
Xor transfering data between machines with different floating point formats.
X.IP "var2ascii"
XThis is the inverse operation of ascii2var, reading in a var file
Xand writing out an ascii file using a supplied format string to 
Xformat the floating point numbers being output.
X.IP "var2ascii2"
XThis command is the same as var2ascii except instead of being given
Xa file to work on it takes an image data structure (which may be
Xconstructed rather than read in from a file).
X.IP "trunc2"
XThis command takes in a double image data structure and truncates
Xeach of the floating point pixels into and integral pixel.
XIt outputs
Xa graytone image data structure.
X.IP "trunc"
XThis is the version that works with files instead of data structures.
X.IP "scale2"
XThis routine takes every pixel of an input data structures, multiplies
Xit by a scaling constant and increments it with an incrementation
Xconstant.
XThe combination scale2 trunc2 and var2iff are supposed to
Xbe particularly useful for displaying var files.
X.IP "scale"
XThis is like scale2 but with files instead of data structures.
X.IP "correlate2"
XThis correlates an image with a template.
XBoth are entered as 
Xdouble image data structures.
XThe output only contains the points
Xwhere the template did not fall off the edge.
X.IP "correlate"
XThis is the version of correlate2 with files instead of data structures.
X.IP "lower_bound2"
XThis routine goes through the pixels of a var image and sets any that
Xgo below the bound to the bound.
XIt is meant to limit the range of
Xvalues of the pixels for inspection or error control.
X.IP "lower_bound"
XThis is like lowerbound2 but with files instead of image data structures.
X.IP "upper_bound2"
XThis routine goes through the pixels of a var image and sets any
Xthat exceed the bound to the bound.
XIt is meant to limit the range of
Xvalues of the pixels for inspection or error control.
X.IP "upper_bound"
XThis is like upper_bound2 but with files instead of image data structures.
X.SH "FILES"
X/usr/local/include/vartools.h
X/usr/local/include/vartools.h++
X.SH "SEE ALSO"
Xvar(3) var(5) image(5)
X.SH "DIAGNOSTICS"
XWhen something goes wrong in general it will print an error message
Xand dump core.
X.SH "BUGS"
XProbably.
@//E*O*F man/vartools.3//
chmod u=rw,g=r,o=r $OUT
 
echo x - man/var2ascii.1
if test -f man/var2ascii.1 ; then
    echo man/var2ascii.1 exists, putting output in $$man/var2ascii.1
    OUT=$$man/var2ascii.1
    STATUS=1
else
    OUT=man/var2ascii.1
fi
sed 's/^X//' > $OUT <<'@//E*O*F man/var2ascii.1//'
X.TH VAR2ASCII 1 8/25/86
X.CM 1
X.SH "NAME"
Xvar2ascii \- takes a var file and outputs it in ascii format
X.SH "SYNOPSIS"
Xvar2ascii [format [input.var [output.ascii]]]
X.SH "DESCRIPTION"
XThis program is designed to output in ascii format a double precision
Xvar file (though since graytone is automatically converted to double
Xit can also handle graytone).
XThe output is 2 dimensions followed by
Xthe pixels in row order followed by the comments.
XThe first argument
Xis the format string used to print out the strings.
XIf it is left
Xout var2ascii must be used as a pipe and it uses a default format.
XIf only the format is given var2ascii is a pipe.
XOtherwise giving
Xthe input file only with output to stdout.
XOtherwise the behavior
Xis as one would expect.
XThis program can facilitate passing floating point images
Xbetween machines with incompatible floating point formats.
X.SH "SEE ALSO"
Xvar(3) var(5) vartools(3) ascii2var(1)
X.SH "DIAGNOSTICS"
Xprints error message and dumps core 
X.SH "BUGS"
XHmmmm....
X,
@//E*O*F man/var2ascii.1//
chmod u=rw,g=r,o=r $OUT
 
echo x - man/truncate.1
if test -f man/truncate.1 ; then
    echo man/truncate.1 exists, putting output in $$man/truncate.1
    OUT=$$man/truncate.1
    STATUS=1
else
    OUT=man/truncate.1
fi
sed 's/^X//' > $OUT <<'@//E*O*F man/truncate.1//'
X.TH TRUNCATE 1 8/25/86
X.CM 1
X.SH "NAME"
Xtruncate \- takes a floating point image and generates a graytone image
X.SH "SYNOPSIS"
Xtruncate [input.var [output.var]]
X.SH "DESCRIPTION"
XThis takes a floating point var file and generates a graytone
Xvar file by truncating the pixels.
XIf no arguments then its a pipe.
XIf only input is given output to stdout.
XOtherwise input
Xand output is specified.
XThis routine can be useful in turning a floating point image into
Xan image displayed on a screen.
X.SH "SEE ALSO"
Xvar(5) var(3) vartools(3)
X.SH "DIAGNOSTICS"
Xprints errors and dumps core.
X.SH "BUGS"
XHmmm...
@//E*O*F man/truncate.1//
chmod u=rw,g=r,o=r $OUT
 
echo x - man/scale.1
if test -f man/scale.1 ; then
    echo man/scale.1 exists, putting output in $$man/scale.1
    OUT=$$man/scale.1
    STATUS=1
else
    OUT=man/scale.1
fi
sed 's/^X//' > $OUT <<'@//E*O*F man/scale.1//'
X.TH SCALE 1 8/25/86
X.CM 1
X.SH "NAME"
Xscale \- scales and increments pixels of an image.
X.SH "SYNOPSIS"
Xscale scale [increment [input.var [output.var]]]
X.SH "DESCRIPTION"
XThis program multiplies every pixel of a floating point image
Xby a scale (specified in the first argument) and adds to them
Xan increment (specified in the second argument).
XIf the second
Xargument is left out the increment is set to 0 and the program
Xacts as a pipe.
XOtherwise the 3rd argument when present specifies
Xthe input file and the 4th argument when present specifies the
Xoutput file.
XIf the 3rd or 4th argument are left out then the 
Xprogram suplies stdin and stdout for the missing arguments.
X.SH "SEE ALSO"
Xvar(3) var(5) vartools(3)
X.SH "DIAGNOSTICS"
Xprints error message and dumps core
X.SH "BUGS"
XHmmm....
@//E*O*F man/scale.1//
chmod u=rw,g=r,o=r $OUT
 
echo x - man/correlate.1
if test -f man/correlate.1 ; then
    echo man/correlate.1 exists, putting output in $$man/correlate.1
    OUT=$$man/correlate.1
    STATUS=1
else
    OUT=man/correlate.1
fi
sed 's/^X//' > $OUT <<'@//E*O*F man/correlate.1//'
X.TH CORRELATE 1 8/25/86
X.CM 1
X.SH "NAME"
Xcorrelate \- correlates an input image with a template
X.SH "SYNOPSIS"
Xcorrelate template.var [input.var [output.var]]
X.SH "DESCRIPTION"
XThis generates the correlation of a template with an input file.
XIt only generates points when the template fits entirely within the
Xinput image so the output is smaller than the input.
XWhen the input
Xand output files are not supplied they are replaced by stdin and stdout.
X.SH "SEE ALSO"
Xvar(3) vartools(3) var(5)
X.SH "DIAGNOSTICS"
Xprints error message and dumps core
X.SH "BUGS"
XHmmm....
@//E*O*F man/correlate.1//
chmod u=rw,g=r,o=r $OUT
 
echo x - man/lowerbound.1
if test -f man/lowerbound.1 ; then
    echo man/lowerbound.1 exists, putting output in $$man/lowerbound.1
    OUT=$$man/lowerbound.1
    STATUS=1
else
    OUT=man/lowerbound.1
fi
sed 's/^X//' > $OUT <<'@//E*O*F man/lowerbound.1//'
X.TH LOWERBOUND 1 8/25/86
X.CM 1
X.SH "NAME"
Xlowerbound \- places a lower bound on the pixels of a var file
X.SH "SYNOPSIS"
Xlowerbound bound [input.var [output.var]]
X.SH "DESCRIPTION"
XThis goes through the pixels of a var file and all the ones
Xthat are less than the bound are set to the bound.
XIf input or output are not supplied they are replaced with stdin
Xand stdout
X.SH "SEE ALSO"
Xvar(3) var(5) vartools(3) upperbound(1)
X.SH "DIAGNOSTICS"
Xprints error messages and dumps core for the most part.
X.SH "BUGS"
XHmmm....
@//E*O*F man/lowerbound.1//
chmod u=rw,g=r,o=r $OUT
 
echo x - man/upperbound.1
if test -f man/upperbound.1 ; then
    echo man/upperbound.1 exists, putting output in $$man/upperbound.1
    OUT=$$man/upperbound.1
    STATUS=1
else
    OUT=man/upperbound.1
fi
sed 's/^X//' > $OUT <<'@//E*O*F man/upperbound.1//'
X.TH UPPERBOUND 1 8/25/86
X.CM 1
X.SH "NAME"
Xupperbound \- places an upperbound on the pixels of a var file
X.SH "SYNOPSIS"
Xupperbound bound [input.var [output.var]]
X.SH "DESCRIPTION"
XThis program goes through the pixels of a var file replacing
Xeach pixel that exceeds the bound with the bound.
XThis program should be useful in constructing files to be
Xshown on devices with limited range.
XWhen input or output file names are not present they are replaced
Xwith stdin and stdout respectively.
X.SH "SEE ALSO"
Xvar(3) var(5) vartools(3) lowerbound(1)
X.SH "DIAGNOSTICS"
Xprints error message and dumps core for the most part
X.SH "BUGS"
XHmmm....
@//E*O*F man/upperbound.1//
chmod u=rw,g=r,o=r $OUT
 
echo x - scale/main.c++
if test -f scale/main.c++ ; then
    echo scale/main.c++ exists, putting output in $$scale/main.c++
    OUT=$$scale/main.c++
    STATUS=1
else
    OUT=scale/main.c++
fi
sed 's/^X//' > $OUT <<'@//E*O*F scale/main.c++//'
X/*
X    Main routine for scaling image
X    Syntax of scale is:
X    scale scale [increment [input.var [output.var]]]
X*/

X#include <stream.h>
X#include <stdio.h>
X#include <string.h>
X#include <vartools.h++>

Xint
Xmain ( int argc , char *argv[] )
X    {
X    switch(argc)
X	{
X	// if just scale given (acts as a pipe)
X    case 2:
X	scale(atof(argv[1]),0.,stdin,stdout,"");
X    break;
X	// if just scale and increment given (acts as a pipe)
X    case 3:
X	scale(atof(argv[1]),atof(argv[2]),stdin,stdout,"");
X    break;
X	// if scale, increment and input file given (output to stdout)
X    case 4:
X	    {
X	    FILE *input;
X	    if(NULL == (input = fopen(argv[3],"r")))
X		{
X		char * string = form("Could not open %s for reading:",argv[3]);
X		perror(string);
X		return 2;
X		}
X	    scale(atof(argv[1]),atof(argv[2]),input,stdout,"");
X	    }
X    break;
X	// if scale, increment, input file and output file given
X    case 5:
X	    {
X	    FILE *input;
X	    FILE *output;
X	    if(NULL == (input = fopen(argv[3],"r")))
X		{
X		char * string = form("Could not open %s for reading:",argv[3]);
X		perror(string);
X		return 2;
X		}
X	    if(NULL == (output = fopen(argv[4],"w")))
X		{
X		char * string = form("Could not open %s for writing:",argv[3]);
X		perror(string);
X		return 3;
X		}
X	    scale(atof(argv[1]),atof(argv[2]),input,output,"");
X	    }
X    break;
X	// if wrong arguments given
X    default:
X	cerr << "Syntax is: scale scale [increment [input.var [output.var]]]\n";
X	return 1;
X    break;
X	}
X    
X    return 0;
X    }

X/*
XCopyright (C) 1986, David Sher in the University of Rochester
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit, provided
Xthis copyright notice is retained.
X*/
@//E*O*F scale/main.c++//
chmod u=rw,g=r,o=r $OUT
 
echo x - scale/makefile
if test -f scale/makefile ; then
    echo scale/makefile exists, putting output in $$scale/makefile
    OUT=$$scale/makefile
    STATUS=1
else
    OUT=scale/makefile
fi
sed 's/^X//' > $OUT <<'@//E*O*F scale/makefile//'
X# this is the makefile for iff2var

X.SUFFIXES: .c++ 

X# This line constructs the program name (equal to the directory name)
X# jccpwd^[!!sh^M:s/.*\///g^MIPROGRAM = ^[
XPROGRAM = scale

XCFLAGS = -O -I/usr/grads/include -DVAX -Ddebug 


XC++FLAGS = +i $(CFLAGS)

XLIBS = -lvartools -lvarc++ -lvar -liff 

X# This line constructs the list of possible objects
X# 2jc}ls *[A-Za-z0-9].c *.c++^[!!sh^M>}>}:g/\.c\+*$/ s//.o \\/^M
XOBJS = \
X	main.o 


X.c++.o:
X	c++ -c  $(C++FLAGS) $*.c++ 

X# the program is linked by this line
X$(PROGRAM) : $(OBJS)
X	c++ -o $(PROGRAM) $(CFLAGS) $(OBJS) $(LIBS) 

X# the program is linted by this line
X$(PROGRAM).lint : *.c 
X	lint -hb *.c -lm > lint.out
@//E*O*F scale/makefile//
chmod u=rw,g=r,o=r $OUT
 
echo x - truncate/main.c++
if test -f truncate/main.c++ ; then
    echo truncate/main.c++ exists, putting output in $$truncate/main.c++
    OUT=$$truncate/main.c++
    STATUS=1
else
    OUT=truncate/main.c++
fi
sed 's/^X//' > $OUT <<'@//E*O*F truncate/main.c++//'
X/*
X    Main routine for calling the trunc routine
X*/

X#include <stream.h>
X#include <stdio.h>
X#include <vartools.h++>

Xint
Xmain ( int argc , char *argv[] )
X    {
X    switch(argc)
X	{
X	// with no arguments it acts as a pipe
X    case 1:
X	trunc(stdin,stdout,"Truncating file from stdin\n");
X    break;
X	// with 1 argument it reads from specified file and writes to stdout
X    case 2:
X	FILE *input;
X	if(NULL == (input = fopen(argv[1],"r")))
X	    {
X	    perror("trunc:");
X	    return 5;
X	    }
X	trunc(input,stdout,form("Truncating file %s\n",argv[1]));
X    break;
X	// with 2 arguments it reads from specified file and writes to 
X	// specified file
X    case 3:
X	FILE *input;
X	FILE *output;
X	if(NULL == (input = fopen(argv[1],"r")))
X	    {
X	    perror("trunc:");
X	    return 5;
X	    }
X	if(NULL == (output = fopen(argv[2],"w")))
X	    {
X	    perror("trunc:");
X	    return 6;
X	    }
X	trunc(input,output,form("Truncating file %s to file %s\n",argv[1],argv[2]));
X    break;
X	// otherwise wrong number of arguments failure!
X    default:
X	cerr << "Syntax is: trunc [input.var [output.var]]";
X	return 1;
X    break;
X	}
X    return 0;
X    }
X/*
XCopyright (C) 1986, David Sher in the University of Rochester
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit, provided
Xthis copyright notice is retained.
X*/
@//E*O*F truncate/main.c++//
chmod u=rw,g=r,o=r $OUT
 
echo x - truncate/makefile
if test -f truncate/makefile ; then
    echo truncate/makefile exists, putting output in $$truncate/makefile
    OUT=$$truncate/makefile
    STATUS=1
else
    OUT=truncate/makefile
fi
sed 's/^X//' > $OUT <<'@//E*O*F truncate/makefile//'
X# this is the makefile for iff2var

X.SUFFIXES: .c++ 

X# This line constructs the program name (equal to the directory name)
X# jccpwd^[!!sh^M:s/.*\///g^MIPROGRAM = ^[
XPROGRAM = truncate

XCFLAGS = -O -I/usr/grads/include -DVAX -Ddebug 


XC++FLAGS = +i $(CFLAGS)

XLIBS = -lvartools -lvarc++ -lvar -liff 

X# This line constructs the list of possible objects
X# 2jc}ls *[A-Za-z0-9].c *.c++^[!!sh^M>}>}:g/\.c\+*$/ s//.o \\/^M
XOBJS = \
X	main.o 


X.c++.o:
X	c++ -c  $(C++FLAGS) $*.c++ 

X# the program is linked by this line
X$(PROGRAM) : $(OBJS)
X	c++ -o $(PROGRAM) $(CFLAGS) $(OBJS) $(LIBS) 

X# the program is linted by this line
X$(PROGRAM).lint : *.c 
X	lint -hb *.c -lm > lint.out
@//E*O*F truncate/makefile//
chmod u=rw,g=r,o=r $OUT
 
echo x - upperbound/main.c++
if test -f upperbound/main.c++ ; then
    echo upperbound/main.c++ exists, putting output in $$upperbound/main.c++
    OUT=$$upperbound/main.c++
    STATUS=1
else
    OUT=upperbound/main.c++
fi
sed 's/^X//' > $OUT <<'@//E*O*F upperbound/main.c++//'
X/*
X    This applies an upper bound to a var file
X    The syntax is:
X    upperbound bound [input.var [output.var]]
X*/
X#include <stream.h>
X#include <stdio.h>
X#include <vartools.h++>


Xint
Xmain ( int argc , char *argv[] )
X    {
X    switch(argc)
X	{
X	// with 1 argument it acts as a pipe
X    case 2:
X	upper_bound(atof(argv[1]),stdin,stdout,"Bounding file from stdin\n");
X    break;
X	// with 2 arguments it reads from specified file and writes to stdout
X    case 3:
X	FILE *input;
X	if(NULL == (input = fopen(argv[2],"r")))
X	    {
X	    perror(form("upperbound problem with openning %s:",argv[2]));
X	    return 5;
X	    }
X	upper_bound(atof(argv[1]),input,stdout,form("bounding file %s\n",argv[2]));
X    break;
X	// with 3 arguments it reads from specified file and writes to 
X	// specified file
X    case 4:
X	FILE *input;
X	FILE *output;
X	if(NULL == (input = fopen(argv[2],"r")))
X	    {
X	    perror(form("upperbound problem with openning %s:",argv[2]));
X	    return 5;
X	    }
X	if(NULL == (output = fopen(argv[3],"w")))
X	    {
X	    perror(form("upperbound problem with openning %s:",argv[3]));
X	    return 6;
X	    }
X	upper_bound(atof(argv[1]),input,output,form("bounding file %s to file %s\n",argv[2],argv[3]));
X    break;
X	// otherwise wrong number of arguments failure!
X    default:
X	cerr << "Syntax is: upperbound bound [input.var [output.var]]";
X	return 1;
X    break;
X	}
X    return 0;
X    }
X/*
XCopyright (C) 1986, David Sher in the University of Rochester
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit, provided
Xthis copyright notice is retained.
X*/
@//E*O*F upperbound/main.c++//
chmod u=rw,g=r,o=r $OUT
 
echo x - upperbound/makefile
if test -f upperbound/makefile ; then
    echo upperbound/makefile exists, putting output in $$upperbound/makefile
    OUT=$$upperbound/makefile
    STATUS=1
else
    OUT=upperbound/makefile
fi
sed 's/^X//' > $OUT <<'@//E*O*F upperbound/makefile//'
X# this is the makefile for iff2var

X.SUFFIXES: .c++ 

X# This line constructs the program name (equal to the directory name)
X# jccpwd^[!!sh^M:s/.*\///g^MIPROGRAM = ^[
XPROGRAM = upperbound

XCFLAGS = -O -I/usr/grads/include -DVAX -Ddebug 


XC++FLAGS = +i $(CFLAGS)

XLIBS = -lvartools -lvarc++ -lvar -liff 

X# This line constructs the list of possible objects
X# 2jc}ls *[A-Za-z0-9].c *.c++^[!!sh^M>}>}:g/\.c\+*$/ s//.o \\/^M
XOBJS = \
X	main.o 


X.c++.o:
X	c++ -c  $(C++FLAGS) $*.c++ 

X# the program is linked by this line
X$(PROGRAM) : $(OBJS)
X	c++ -o $(PROGRAM) $(CFLAGS) $(OBJS) $(LIBS) 

X# the program is linted by this line
X$(PROGRAM).lint : *.c 
X	lint -hb *.c -lm > lint.out
@//E*O*F upperbound/makefile//
chmod u=rw,g=r,o=r $OUT
 
echo x - var2ascii/main.c++
if test -f var2ascii/main.c++ ; then
    echo var2ascii/main.c++ exists, putting output in $$var2ascii/main.c++
    OUT=$$var2ascii/main.c++
    STATUS=1
else
    OUT=var2ascii/main.c++
fi
sed 's/^X//' > $OUT <<'@//E*O*F var2ascii/main.c++//'
X/*
X    This is the main routine for translating floating point images
X    to ascii
X*/

X#include <stream.h>
X#include <stdio.h>
X#include <vartools.h++>

Xint
Xmain(int argc,char *argv[])
X    {
X    switch ( argc )
X	{
X    // with 0 arguments it is a pipe with default format
X    case 1:
X	var2ascii(stdin,stdout,"%lf ");
X	break;
X    // with 1 argument it is a pipe with entered format
X    case 2:
X	var2ascii(stdin,stdout,argv[1]);
X	break;
X    // with 2 arguments it takes from named file to stdout
X    case 3:
X	{
X	FILE *input;	// pointer to the input file
X	if ( NULL == ( input = fopen(argv[2],"r") ) )
X	    {
X	    perror("var2ascii");
X	    return 2;
X	    }
X	var2ascii(input,stdout,argv[1]);
X	}
X	break;
X    // with 3 arguments it takes from named file to named file
X    case 4:
X	{
X	FILE *input;	// pointer to the input file
X	FILE *output;	// pointer to the output file
X	if ( NULL == ( input = fopen(argv[2],"r") ) )
X	    {
X	    perror("var2ascii");
X	    return 2;
X	    }
X	if ( NULL == ( output = fopen(argv[3],"w") ) )
X	    {
X	    perror("var2ascii");
X	    return 2;
X	    }
X	var2ascii(input,output,argv[1]);
X	}
X	break;
X    // otherwise something is wrong
X    default:
X	cerr << "Syntax is: var2ascii [input [output]]\n";
X	return 1;
X	}
X    return 0;
X    }
X/*
XCopyright (C) 1986, David Sher in the University of Rochester
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit, provided
Xthis copyright notice is retained.
X*/
@//E*O*F var2ascii/main.c++//
chmod u=rw,g=r,o=r $OUT
 
echo x - var2ascii/makefile
if test -f var2ascii/makefile ; then
    echo var2ascii/makefile exists, putting output in $$var2ascii/makefile
    OUT=$$var2ascii/makefile
    STATUS=1
else
    OUT=var2ascii/makefile
fi
sed 's/^X//' > $OUT <<'@//E*O*F var2ascii/makefile//'
X# this is the makefile for iff2var

X.SUFFIXES: .c++ 

X# This line constructs the program name (equal to the directory name)
X# jccpwd^[!!sh^M:s/.*\///g^MIPROGRAM = ^[
XPROGRAM = var2ascii

XCFLAGS = -O -I/usr/grads/include -DVAX -Ddebug 


XC++FLAGS = +i $(CFLAGS)

XLIBS = -lvartools -lvarc++ -lvar -liff 

X# This line constructs the list of possible objects
X# 2jc}ls *[A-Za-z0-9].c *.c++^[!!sh^M>}>}:g/\.c\+*$/ s//.o \\/^M
XOBJS = \
X	main.o 


X.c++.o:
X	c++ -c  $(C++FLAGS) $*.c++ 

X# the program is linked by this line
X$(PROGRAM) : $(OBJS)
X	c++ -o $(PROGRAM) $(CFLAGS) $(OBJS) $(LIBS) 

X# the program is linted by this line
X$(PROGRAM).lint : *.c 
X	lint -hb *.c -lm > lint.out
@//E*O*F var2ascii/makefile//
chmod u=rw,g=r,o=r $OUT
 
echo x - varc++/archive.h++
if test -f varc++/archive.h++ ; then
    echo varc++/archive.h++ exists, putting output in $$varc++/archive.h++
    OUT=$$varc++/archive.h++
    STATUS=1
else
    OUT=varc++/archive.h++
fi
sed 's/^X//' > $OUT <<'@//E*O*F varc++/archive.h++//'
X/*
X    This file contains definitions for archive manipulation routines
X*/
X/*
X    Archive format definitions
X*/
X#include "ar.h"

X/*
XGeneral Utility
X*/
X/*
XReads in a certain number of bytes from a file or fail with message
Xto stderr.  If at EOF returns a NULL pointer.  
X*/
Xchar *
Xar_read_bytes_from_file_or_report_eof(const int file_descriptor , const int number_bytes );

X/*
XWrites out a certain number of bytes from a file or fail with message
Xto stderr.  If at EOF returns a NULL pointer.  
X*/
Xvoid
Xar_write_bytes_to_file_or_report_error( int file_descriptor , int buffer,  int number_bytes  );

X/*
X    Routines to access archives
X*/
X/*
X    Checks that the archive is valid
X    returns 1 if valid 0 otherwise
X    should be run at begining of file
X*/
Xchar
Xar_check_archive(FILE  *fptr );

X/*
X    Writes out the archive header to a file and checks for errors
X*/
Xvoid
Xar_write_archive_header( FILE *archive_file );

X/*
X    Reads in an archive header or reports that you are at eof
X    by returning a NULL pointer.
X*/
Xstruct ar_hdr *
Xar_read_header_or_report_eof(FILE *fptr );

X/*
X    Writes out the archive header for each file
X*/
Xvoid
Xar_write_header( FILE *archive_file, char *buffer, struct ar_hdr *header );

X/*
X    Reads a file into memory
X*/
Xchar *
Xar_read_file(FILE * fptr , struct ar_hdr *header);

X/*
X    writes the contents of a file out to an archive
X*/
Xvoid
Xar_write_file( FILE *archive_file, char *buffer, struct ar_hdr * header );

X/*
X    Creates a header for an archive entry
X*/
Xstruct ar_hdr *
Xar_create_header(const char * name , const int date , const int uid , const int gid , const int mode , const int size , const char * fmag );


X/*
X    Definitions of sizes for header elements
X*/
X#define AR_FILE_NAME_SIZE 16	/* the file name */
X#define AR_FILE_PROTECTION_SIZE 8	/* the file protection */
X#define AR_FILE_UID_SIZE 6	/* the file uid */
X#define AR_FILE_GID_SIZE 6	/* the file gid */
X#define AR_FILE_DATE_SIZE 12	/* the file date */
X#define AR_FILE_SIZE_SIZE 10	/* the file size */

X/*
X    Routines to access entries from the archive header
X*/

X/*
X    Get the file name
X*/
Xchar *
Xar_file_name( struct  ar_hdr *header );

X/*
X    Get the protection
X*/
Xchar *
Xar_file_protection( struct  ar_hdr *header );

X/*
X    Get the uid
X*/
Xchar *
Xar_file_uid( struct ar_hdr *header );

X/*
X    Get the gid
X*/
Xchar *
Xar_file_gid( struct ar_hdr *header );

X/*
X    Get the date
X*/
Xchar *
Xar_file_date( struct ar_hdr *header );

X/*
X    Get the size
X*/
Xchar *
Xar_file_size( struct ar_hdr *header );

X/*
XCopyright (C) 1986, David Sher in the University of Rochester
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit, provided
Xthis copyright notice is retained.
X*/
@//E*O*F varc++/archive.h++//
chmod u=rw,g=r,o=r $OUT
 
echo x - varc++/bitio.h++
if test -f varc++/bitio.h++ ; then
    echo varc++/bitio.h++ exists, putting output in $$varc++/bitio.h++
    OUT=$$varc++/bitio.h++
    STATUS=1
else
    OUT=varc++/bitio.h++
fi
sed 's/^X//' > $OUT <<'@//E*O*F varc++/bitio.h++//'
X/* file:  bitio.h							*/

X/* BFILE: include file for bit stream I/O.				*/
X/* Bitio provides the capabilities to access unix files as arbitrary	*/
X/*  bit streams. I/O is buffered on both reading and writing.		*/
X/* Read, write, and read/write access is defined.			*/
X/* Bit streams of upto the width in bits of a long integer may be read	*/
X/*  and written with each access.					*/
X/* CPU word and character boundaries are otherwise ignored.		*/
X/* These routines are compatible with normal unix file access.		*/

X/* Copyright (c) 1982,
X   W. S. Havens,
X   Laboratory for Computational Vision,
X   University of British Columbia
X*/

X/* Modifications:
X    original:						WSH 82/5/20
X    added delayed filling of cache:			WSH 82/5/27
X    change block size:					SJK 84/5/4
X*/

X#define		BBLKSZE	4096		/* # of bytes in bit cache	*/
X#define		R	0		/* mode = read			*/
X#define		W	1		/* mode = write			*/
X#define		RW	2		/* mode = read/write		*/
X#define		UBXBYTE	8		/* # of bits per byte		*/
X#define		WRDSZE	UBXBYTE*sizeof(long)/* # of bits per long word	*/
X#define		BEOF	001
X#define		BRDERR	002
X#define		BWRERR	004
X#define		BSKERR	010
X#define		NULL	0

X/* flags:
X  Bit	Indication
X  ---	----------
X   1	EOF during last read.
X   2	read error occurred.
X   3	write error occurred.
X   4	seek error occurred.
X*/

Xstruct iff_bfile
X {int		file;			/* unix file descriptor		*/
X  short		wpos;			/* location of bword in cache	*/
X  short		bpos;			/* current low-order bit	*/
X  short		nwrd;			/* # of bytes in cache		*/
X  short		bmode;			/* access mode of file		*/
X  short		flags;			/* EOF and ERROR flags		*/
X  char		cache[BBLKSZE];		/* byte cache for stream        */	
X  };

Xunsigned long	bseek(...);
Xstruct iff_bfile		*bopen(...), *bdopen(...);
X	       

X/* Notes:
X   ------
X1) Beware of the odd bits !!

X*/

X/* Macros */

X#define beof(bfp)	((bfp)->flags & BEOF)
X#define berror(bfp)	((bfp)->flags & (BRDERR | BWRERR | BSKERR))
X#define bget(bfp,n,signed)						\
X  ((n)!=8 || (bfp)->bpos || (bfp)->wpos>=(bfp)->nwrd || (bfp)->bmode==W ?\
X    fbget(bfp,n,signed) : 						\
X      (signed) ?							\
X	*(char *)((bfp)->cache+((bfp)->wpos++)) :			\
X	*(unsigned char *)((bfp)->cache+((bfp)->wpos++)) )

X#define bput(bfp,bits,n)						\
X  ((n)!=8 || (bfp)->bpos || (bfp)->wpos>=BBLKSZE || (bfp)->bmode!=W ?	\
X	fbput(bfp,bits,n) :						\
X	(*(char *)(bfp->cache+bfp->wpos++) = bits))


X/* end of file:  bitio.h */
X/*
XCopyright (C) 1986, David Sher in the University of Rochester
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit, provided
Xthis copyright notice is retained.
X*/
@//E*O*F varc++/bitio.h++//
chmod u=rw,g=r,o=r $OUT
 
echo x - varc++/char_image.h++
if test -f varc++/char_image.h++ ; then
    echo varc++/char_image.h++ exists, putting output in $$varc++/char_image.h++
    OUT=$$varc++/char_image.h++
    STATUS=1
else
    OUT=varc++/char_image.h++
fi
sed 's/^X//' > $OUT <<'@//E*O*F varc++/char_image.h++//'
X/*
X    This file contains the definitions necessary to define an
X    image whose data is 8-bit
X*/

X#ifndef CHAR_IMAGE_H
X#define CHAR_IMAGE_H
X/* include the support for image data types */
X#include "image.h++"

X/*
X    the definition of the class to manage image structures
X*/
Xclass char_image : image_class 
X    {
X    char *image_buffer;	// buffer to hold image
X    char **image_rows;	// pointers to the rows of the image
X    char **window_rows;	// pointers to the rows of the window
X    /* functions for function pointers */

X    /* this version of next assumes the window has been initialized */
X    int initialized_next ();

X    /* this version of prev assumes the window has been initialized */
X    int initialized_prev ();

X    /* this version of next initializes the window */
X    int uninitialized_next ();

X    /* this version of prev initializes the window */
X    int uninitialized_prev ();

X    /* this version of next says that the operation is impossible */
X    int impossible_next ();

X    /* this version of prev says that the operation is impossible */
X    int impossible_prev ();

X    /* uninitialized version of get_w_e will just die */
X    char uninitialized_get_w_e ( const card i , const card j );

X    /* initialized version of get_w_e */
X    char initialized_get_w_e ( const card i , const card j );

X    /* uninitialized version of write_w_e will just die */
X    void uninitialized_write_w_e ( const card i , const card j , const char value );

X    /* initialized version of write_w_e */
X    void initialized_write_w_e ( const card i , const card j , const char value );

X    /*
X	the function to write to the specified element of a window.
X	it is a function pointer so that unitialized windows
X	or protected images don't get read from
X    */
X    char (* get_w_e_pointer )( const card i , const card j  );

X    /*
X	the function to write to the specified element of a window.
X	it is a function pointer so that unitialized windows
X	or protected images don't get read from
X	can not check argument because it will point to internal
X	elements
X    */
X    void (* write_w_e_pointer )( const card i , const card j , const char value  );

Xpublic:
X    /* constructors */
X    /* the constructor when the image is being read from a file */
X    char_image
X	( 
X	const read_image_type rit , 	// marker that the image is being read
X	const FILE * image_file ,	// file for image
X	const card w_width = 1 ,	// window width
X	const card w_length = 1		// window length
X	);

X    /* the constructor when the image is built */
X    char_image
X	( 
X	const create_image_type cit ,	// marker that the image is being created
X	const card n_rows , 		// the number of rows in the image
X	const card n_cols , 		// the number of collumns in the image
X	const FILE * image_file ,	// file for image
X	const card w_width = 1 ,	// window width
X	const card w_length = 1 	// window length
X	);

X    /* destructor (who would want to destroy an image?) */
X    ~char_image ( ) { ; }

X    /* access routines for parts of data structure */
X    const card n_rows() { return number_rows ; }
X    const card n_cols() { return number_cols ; }
X    const image_prot the_prot() { return prot; }
X    const card c_length() { return comment_length ; }
X    const char *the_comments() { return comments ; }
X    const card the_collumn() { return collumn ; }
X    const card the_row() { return row ; }
X    const card the_width() { return window_width ; }
X    const card the_length() { return window_length ; }
X    const FILE * the_file() { return file ; }
X    const status image_init() { return image_status ; }
X    const status window_init() { return window_status ; }

X    /* access a pointer to a particular row */
X    const char * get_row( card row );

X    /* sets the comments */
X    void set_comments( char * string , const card length )
X	{
X	this->image_class::set_comments ( string , length );
X	}

X    /* adds a string to the comments */
X    void add_comment( char * string , const card length )
X	{
X	this->image_class::add_comment ( string , length );
X	}


X    /* real versions of virtual functions */
X    /* routine to write out the image to a file */
X    void write ( ) ;

X    /*
X	move in row n steps 
X	returns 1 when that motion is legal 0 otherwise
X    */
X    int move_collumn ( const int n ) ;

X    /*
X	move in collumn n steps
X	returns 1 when that motion is legal 0 otherwise
X    */
X    int move_row ( const int n ) ;

X    /*
X	move to specified row
X    */
X    void move_to_row ( const card n ) ;

X    /*
X	move to specified collumn
X    */
X    void move_to_collumn ( const card n ) ;

X    
X    /*
X	the function to get the specified element of a window
X	it is a function pointer so that unitialized windows
X	or protected images don't get read from
X	this accesses the function pointer
X    */
X    char get_w_e ( const card i , const card j )
X	{ return (( char (*) (...) )(* get_w_e_pointer)) ( this , i , j ); }

X    /*
X	the fast function without checking for initialization
X	of a function pointer for getting elements of a window
X	Also no bounds checking!
X	( Not recommended!)
X    */
X    char fast_g_w_e ( const card i , const card j )
X	{ return window_rows[i][j]; }
X    
X    /*
X	the function to write to the specified element of a window.
X	it is a function pointer so that unitialized windows
X	or protected images don't get read from
X	this accesses the function pointer
X    */
X    void write_w_e ( const card i , const card j , const char value )
X	{ ((void (*) (...) )(* write_w_e_pointer)) ( this , i , j , value ); }

X    /*
X	the fast function without checking for initialization
X	of a function pointer for writing elements to a window
X	Also no bounds checking!
X	( Not recommended!)
X    */
X    void fast_w_w_e ( const card i , const card j , const char value )
X	{ window_rows[i][j] = value; }

X    /* 
X	the function call on the image gets the upper left hand 
X	of the image window and returns a reference so it can be
X	used as a lvalue or rvalue
X	optimized so does not check that the window is initialized
X	if the window is not initialized then odd things may happen
X    */
X    char& operator() ()
X	{ return **window_rows; }
X    
X    /* 
X	move to next legal position in image
X	returns 1 when there is a next legal position 0 otherwise
X	if the window is not initialized then it initializes it.
X	with the window in the position 0,0 (if possible)
X    */
X    int (* next) (...); /* this will point to member functions! */

X    /* 
X	move to previous legal position in image
X	returns 1 when there is a previous legal position 0 otherwise
X	if the window is not initialized then it initializes it.
X	with the window in the farthest position (if possible)
X    */
X    int (* prev) (...); /* this will point to member functions! */

X    /*
X	Access for next and previous elements of images
X    */
X    int operator++ ( ) 
X	{ return (* next) ( this /* because points to member*/ ); }
X    int operator-- ( ) 
X	{ return (* prev) ( this /* because points to member*/ ); }

X    /*
X	Change the size of a window
X	causes the window to become uninitialized
X    */
X    void resize_window ( card width , card length );

X    /*
X	Causes the window to cover the entire image.
X	Allows one to access any part of the image with window operations
X    */
X    void window_entire_image ( );

X    };

X#endif CHAR_IMAGE_H
X/*
XCopyright (C) 1986, David Sher in the University of Rochester
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit, provided
Xthis copyright notice is retained.
X*/
@//E*O*F varc++/char_image.h++//
chmod u=rw,g=r,o=r $OUT
 
echo x - varc++/error.h++
if test -f varc++/error.h++ ; then
    echo varc++/error.h++ exists, putting output in $$varc++/error.h++
    OUT=$$varc++/error.h++
    STATUS=1
else
    OUT=varc++/error.h++
fi
sed 's/^X//' > $OUT <<'@//E*O*F varc++/error.h++//'
X/*
X    This contains the definitions for the error handling routines 
X    I do not contain this file in my error handling routines so that
X    the extern definition of error_occured does not screw things up
X*/

X/*
X    flag that indicates an error occured
X*/
Xextern char error_occured;

X/*
X    Indicates an error occured and adds an error string to the
X    set of error strings
X*/
Xvoid
Xindicate_error(const char error_string[]);

X/*
X    Prints a set of error messages and aborts
X*/
Xvoid
Xprint_errors_and_abort();

X/*
X    Prints a set of error messages and exits with specified code
X*/
Xvoid
Xprint_errors_and_exit( const int exit_code);

X/*
X    Returns a system error string (to replace perror
X*/
Xconst char *
Xsystem_error_string();
X/*
XCopyright (C) 1986, David Sher in the University of Rochester
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit, provided
Xthis copyright notice is retained.
X*/
@//E*O*F varc++/error.h++//
chmod u=rw,g=r,o=r $OUT
 
echo Inspecting for damage in transit...
temp=/tmp/sharin$$; dtemp=/tmp/sharout$$
trap "rm -f $temp $dtemp; exit" 0 1 2 3 15
cat > $temp <<\!!!
     220    1228    7405 vartools.3
      30     164     996 var2ascii.1
      21      99     597 truncate.1
      24     132     787 scale.1
      18      90     566 correlate.1
      17      89     516 lowerbound.1
      19     103     635 upperbound.1
      73     227    1735 main.c++
      31     102     668 makefile
      58     186    1370 main.c++
      31     102     671 makefile
      60     208    1630 main.c++
      31     102     673 makefile
      65     226    1496 main.c++
      31     102     672 makefile
     130     448    2750 archive.h++
      88     405    2632 bitio.h++
     239    1271    7498 char_image.h++
      41     152     979 error.h++
    1227    5436   34276 total
!!!
wc  man/vartools.3 man/var2ascii.1 man/truncate.1 man/scale.1 man/correlate.1 man/lowerbound.1 man/upperbound.1 scale/main.c++ scale/makefile truncate/main.c++ truncate/makefile upperbound/main.c++ upperbound/makefile var2ascii/main.c++ var2ascii/makefile varc++/archive.h++ varc++/bitio.h++ varc++/char_image.h++ varc++/error.h++ | sed 's=[^ ]*/==' | diff -b $temp - >$dtemp
if test -s $dtemp ; then
    echo "Ouch [diff of wc output]:"
    cat $dtemp
    STATUS=1
elif test $STATUS = 0 ; then
    echo "No problems found."
else
    echo "WARNING -- PROBLEMS WERE FOUND..."
fi
exit $STATUS
