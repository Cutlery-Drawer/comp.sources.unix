Subject:  v21i004:  A text formatter with some nroff-like capabilities, Part02/03
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: tcamp@dukeac.UUCP (Ted A. Campbell)
Posting-number: Volume 21, Issue 4
Archive-name: ro/part02

#! /bin/sh
#
# This is a shell archive.  Save this into a file, edit it
# and delete all lines above this comment.  Then give this
# file to sh by executing the command "sh file".  The files
# will be extracted into the current directory owned by
# you with default permissions.
#
# The files contained herein are:
#
# -rw-r--r--  1 tcamp   users      8693 Nov 24 12:50 ro_dive.c
# -rw-r--r--  1 tcamp   users      8527 Nov 24 12:50 ro_word.c
# -rw-r--r--  1 tcamp   users      7044 Nov 24 12:50 ro_text.c
# -rw-r--r--  1 tcamp   users      5367 Nov 24 12:50 ro_setp.c
# -rw-r--r--  1 tcamp   users      8805 Nov 24 12:50 ro_outp.c
# -rw-r--r--  1 tcamp   users       280 Nov 10 09:08 Makefile
# -rw-r--r--  1 tcamp   users       827 Nov 24 13:05 ro.mak
# -rw-r--r--  1 tcamp   users       355 Nov 24 12:50 term.h
# -rw-r--r--  1 tcamp   users       730 Nov 24 12:50 termnull.c
# -rw-r--r--  1 tcamp   users       796 Nov 24 12:50 termansi.c
# -rw-r--r--  1 tcamp   users       843 Nov 24 12:50 termnx10.c
#
echo 'x - ro_dive.c'
if test -f ro_dive.c; then echo 'shar: not overwriting ro_dive.c'; else
sed 's/^X//' << '________This_Is_The_END________' > ro_dive.c
X/********************************************************/
X/*							*/
X/*	ro_dive.c	diversion and register routines	*/
X/*			for ro				*/
X/*							*/
X/*	ro version 1.00					*/
X/*							*/
X/*	Portions copyright (c) 1989 by Ted A. Campbell	*/
X/*		Bywater Software			*/
X/*		P. O. Box 4023				*/
X/*		Duke Station				*/
X/*		Durham, NC  27706			*/
X/*							*/
X/*	Contains portions of ROFF4, Version 1.60	*/
X/*      (c) 1983, 4 by Ernest E. Bergmann               */
X/*		Physics, Building #16			*/
X/*		Lehigh University			*/
X/*		Bethlehem, Pa. 18015			*/
X/*							*/
X/*	Contains portions of ROFF4, Version 1.61	*/
X/*      (c) 1985 by Konrad Kwok                         */
X/*		20 3rd Street, Section M		*/
X/*		Fariview Park,				*/
X/*		Hong Kong				*/
X/*							*/
X/*	ro and its predecessor ROFF4 are based on 	*/
X/*	the ROFF text processor described in Kernigan	*/
X/*	and Plauger's now-classic text <Software Tools> */
X/*							*/
X/* Permission is hereby granted for all commercial and	*/
X/* non-commercial reproduction and distribution of this */
X/* material provided this notice is included.		*/
X/*							*/
X/********************************************************/
X
X#include "ro.h"
X
X/****************************************/
X/* checks RLIST; creates new entry if needed;
X   returns pointer to integer variable */
X
Xint *
Xregist( s )	 
X	char *s;
X	{
X	struct divfd *pw;
X	int *pi;
X	char *pc, *s2;
X	struct divfd *sptr;
X
X	pw = find2( s, rlink );	
X
X	if ( pw != NULL ) 
X		{
X		return( &( pw->val ) );
X		}
X
X	/*  else create new entry */
X
X	if ( ( sptr = (struct divfd *) malloc( (size_t) sizeof( struct divfd ))) == NULL )
X		{
X		fprintf( stderr, "Fatal error: cannot allocate memory for register structure.  \n" );
X		exit ( -1 );
X		}
X	sptr->prev = rlink;		/* save previous link	*/
X	strcpy( sptr->nm, s );		/* copy register name to structure */
X	sptr->bf = NULL;		/* not a stream */
X	sptr->mstr = NULL;		/* and not a macro */
X	rlink = sptr;			/* set new link 	*/
X	pi = &(sptr->val);
X	*pi = REGDEF;
X	return( pi );
X	}
X
X/****************************************/
X/* process .nr request                  */
X
Xdovar()
X	{
X	static char wbuf[MAXLINE];
X	static int typ;
X	int val, *pw;
X	getwrd( ro_curline, wbuf );
X	skip_blanks( ro_curline );
X	val = get_val( ro_curline, &typ );
X	getwrd( ro_curline, wbuf);
X	if ( wbuf[0] == NUMSIGN && wbuf[1] == '\0' )
X		{
X		set( &ro_newpag, val, typ, ro_newpag, 1, 9999);
X		}
X	else
X		{
X		pw = (int *) regist(wbuf);
X		set( pw, val, typ, REGDEF, 0, 9999);
X		}
X	}
X
Xpreregister( name, value )
X	char *name;
X	int value;
X	{
X	int *pw;
X	pw = (int *) regist( name );
X	*pw = value;
X	}
X
X/****************************************/
X/* process .di version */
X
Xdodiv()		 
X	{
X	char wbuf[MAXLINE], *pc, *pc1, *wb;
X	struct divfd *pd;
X	int *pw, p;
X
X	getwrd( ro_curline, wbuf );
X	if ( getwrd( ro_curline, wbuf) != WE_HAVE_A_WORD )
X		{
X		strcpy( wbuf, "div.$$$");
X		fprintf( stderr,".di:  no name, %s assumed\n",
X			wbuf);
X		}
X	if ( strlen( wbuf ) > 2 )
X		{
X		wbuf[ 2 ] = '\0';
X		if ( ro_verbose )
X			{
X			fprintf( stderr,
X				".di:  name over two characters shortened to <%s> \n",
X				wbuf );
X			}
X		}	
X
X	if ( ( pd = find2( wbuf, dlink )) != NULL ) /*if in table*/
X		{
X		if DEBUG
X			{
X			fprintf( stderr, "DEBUG:  diversion <%s> found. \n",
X				wbuf );
X			}
X		if ( ( pd->bf == NULL ))		/* file not open */
X			{
X			if (( pd->bf = fopen( pd->fn, "w" )) != NULL)
X				{
X				if DEBUG
X					{
X					fprintf( stderr, "DEBUG:  .di:  <%s> reopened for diversion.\n", pd->fn );
X					}
X				}
X			else
X				{
X				fprintf( stderr, "Fatal error:  <%s> cannot be rewritten\n",wbuf);
X				exit( -1 );
X				}
X			}
X		}
X	else			/* not in table, build new entry */
X		{
X
X		if ( ( pd = (struct divfd *) malloc( (size_t) sizeof( struct divfd ))) == NULL )
X			{
X			fprintf( stderr, "Fatal error: cannot allocate memory for diversion structure.  \n" );
X			exit ( -1 );
X			}
X
X		pd->prev = dlink;		/* save previous link	*/
X		strcpy( pd->nm, wbuf );		/* save name		*/
X		dlink = pd;			/* set new link 	*/
X		pd->mstr = NULL;		/* not a macro		*/
X		pd->ls = pd->cs = 0;		/* set these to 0       */
X		strcpy( pd->fn, wbuf );		/* get name in filename */
X		strcat( pd->fn, "_ro.div" );	/* make unique diversion name */
X
X		if (( pd->bf = fopen( pd->fn, "w" )) == NULL )
X			{
X			fprintf( stderr, 
X				"Fatal error:  Can't create diversion file <%s>.\n", pd->fn );
X			exit( -1 );
X			}
X		}
X
X	/*** from this point we may presume a valid structure and file */
X
X	while ( ro_gets( ro_curline ) != NULL )
X		{
X		if (( *ro_curline == COMMAND ) && ( comtyp( ro_curline ) == DI )) 
X			{
X
X			/*** NESTING of diversions not currently supported; 
X			     implementation would require testing at this point 
X			     for argument to .di ***/
X
X			break;
X			}
X		if ( pc = (char *) macq( ro_curline))	/* if macro	*/
X			{
X			pbmac( pc, ro_curline);	/* process macro */
X			continue;
X			}
X
X		/*else*/
X
X		p = strlen( ro_curline );
X		ro_curline[ p ] = '\n';		/* terminate the line with CR */
X		++p;
X		ro_curline[ p ] = '\0';		/* and then '\0' */
X		fputs( ro_curline, pd->bf );	/* and put to diversion file */
X		( pd->ls )++;			/* increment line counter */
X		( pd->cs ) += strlen( ro_curline ); /* and char counter */
X		}
X	}
X
X/****************************************/
X/* read from diversion                  */
X
Xread_div( sptr )
X	struct divfd *sptr;
X	{
X	if ( sptr->bf != NULL )
X		{
X		dclose( sptr );
X		}
X
X	if DEBUG
X		{
X		fprintf( stderr, "DEBUG:  reading from diversion <%s>, file <%s> \n",
X			sptr->nm, sptr->fn );
X		}
X
X	if ( ro_fptr < FMAX ) 
X		{
X		ro_fstack[ ro_fptr++ ] = instream;
X		}
X	else	
X		{
X		fprintf( stderr,"Fatal error:  ro_fstack overflow\n");
X		exit( -1 );
X		}
X
X	if (( instream = fopen( sptr->fn, "r" )) != NULL ) 
X		{
X		return;		/* file opened successfully */
X		}
X
X	/* else the attempt has failed */
X
X	if ( ro_verbose )
X		{
X		fprintf( stderr, ".%s:  can't open <%s>\n", sptr->nm, sptr->fn );
X		}
X	endso();
X
X	}
X
X/****************************************/
X/* .so -- read from source file         */
X
Xsource()
X	{
X	char name[ MAXLINE ];
X
X	getwrd( ro_curline, name );
X	if( getwrd( ro_curline, name ) != WE_HAVE_A_WORD)
X		{
X		if ( ro_verbose )
X			{
X			fprintf( stderr,".so has no name\n");
X			}
X		return -1;
X		}
X
X	if ( ro_fptr < FMAX ) 
X		{
X		ro_fstack[ ro_fptr++ ] = instream;
X		}
X	else	
X		{
X		fprintf( stderr,"Fatal error:  ro_fstack overflow\n");
X		exit( -1 );
X		}
X
X	if (( instream = fopen( name, "r" )) != NULL ) 
X		{
X		return;
X		}
X
X	/* else the attempt has failed */
X
X	if ( ro_verbose )
X		{
X		fprintf( stderr, ".so:  can't open <%s>\n", name );
X		}
X	endso();
X	}
X
X/****************************************/
X
Xshowr() /*lists register names and contents*/
X	{
X	struct divfd *pw;
X	fprintf( stderr, "REGISTERS and <values>:\n");
X	pw = rlink;
X	while ( pw != NULL )
X		{
X		fprintf( stderr, "%s:\t<%d> \n",pw->nm, pw->val );
X		pw = pw->prev;
X		}
X	dashes();
X	}
X
X/****************************************/
X
Xshowd() /*shows all diversions and status*/
X	{
X	struct divfd *pd;
X
X	fprintf( stderr, "Diversion files:\n");
X	pd = dlink;
X	while( pd != NULL )
X		{
X		fprintf( stderr, "%s:\t", pd->nm );
X		fprintf( stderr, "%d characters, %d lines [",
X		pd->cs, pd->ls );
X		if( pd->bf ) 
X			{
X			fprintf( stderr, "open]\n");
X			}
X		else	
X			{
X			fprintf( stderr, "closed]\n");
X			}
X		pd = pd->prev;
X		}
X	dashes();
X	}
X
X/****************************************/
X/* flushes and closes all open diversions, */
X/* erases diversion files */
X
Xdsclose()	 
X	{
X	struct divfd *pd;
X
X	pd = dlink;
X	while( pd != NULL )
X		{
X		if ( pd->bf != NULL ) 
X			{
X			dclose( pd );
X			if ( unlink( pd->fn ) == -1 )
X				{
X				if DEBUG
X					{
X					fprintf( stderr, "Failed to erase <%s> \n",
X						pd->fn );
X					}
X				}
X			}
X		pd = pd->prev;
X		}
X	}
X
X/****************************************/
X
Xdclose( pd )		/*flushes and closes diversion*/
X	struct divfd *pd;
X	{
X	if ( pd && ( !( pd->bf ))) 
X		{
X		return(FALSE);
X		}
X
X	if ( ro_verbose == TRUE )
X		{
X		fprintf( stderr, "Closing %s ", pd->nm );
X		}
X
X	fflush( pd->bf );		/* Flush the stream		*/
X
X	if( fclose( pd->bf ) == ERROR )	/* Close the file		*/
X		{
X		if ( ro_verbose == TRUE )
X			{
X			fprintf( stderr, "FAILED! \n" );
X			}
X		}
X	else if ( ro_verbose == TRUE )
X		{
X		fprintf( stderr, "[O.K.]\n");
X		pd->bf = NULL;		/* Set file pointer to NULL	*/
X		}
X	return( TRUE );			/* Indicate successful completion */
X	}
X
X/****************************************/
X
Xucstr(s)		/*convert s to upper case*/
X	char *s;
X	{
X	while(*s)
X		{
X		*s = toupper(*s);
X		s++;
X		}
X	}
X
X/****************************************/
X
Xendso() /*called upon EOF to return to previous input file*/
X	{
X	if ( ro_fptr )
X		{
X		fclose( instream );
X		instream = ro_fstack[ --ro_fptr ];
X		}
X	ro_binp = 0;
X	}
X
X/****************************************/
X
Xdashes()
X	{
X	fprintf( stderr, "-----------\n");
X	}
________This_Is_The_END________
if test `wc -l < ro_dive.c` -ne 425; then
	echo 'shar: ro_dive.c was damaged during transit (should have been 425 bytes)'
fi
fi		; : end of overwriting check
echo 'x - ro_word.c'
if test -f ro_word.c; then echo 'shar: not overwriting ro_word.c'; else
sed 's/^X//' << '________This_Is_The_END________' > ro_word.c
X/********************************************************/
X/*							*/
X/*	ro_word.c	word-handling routines for ro	*/
X/*							*/
X/*	ro version 1.00					*/
X/*							*/
X/*	Portions copyright (c) 1989 by Ted A. Campbell	*/
X/*		Bywater Software			*/
X/*		P. O. Box 4023				*/
X/*		Duke Station				*/
X/*		Durham, NC  27706			*/
X/*							*/
X/*	Contains portions of ROFF4, Version 1.60	*/
X/*      (c) 1983, 4 by Ernest E. Bergmann               */
X/*		Physics, Building #16			*/
X/*		Lehigh University			*/
X/*		Bethlehem, Pa. 18015			*/
X/*							*/
X/*	Contains portions of ROFF4, Version 1.61	*/
X/*      (c) 1985 by Konrad Kwok                         */
X/*		20 3rd Street, Section M		*/
X/*		Fariview Park,				*/
X/*		Hong Kong				*/
X/*							*/
X/*	ro and its predecessor ROFF4 are based on 	*/
X/*	the ROFF text processor described in Kernigan	*/
X/*	and Plauger's now-classic text <Software Tools> */
X/*							*/
X/* Permission is hereby granted for all commercial and	*/
X/* non-commercial reproduction and distribution of this */
X/* material provided this notice is included.		*/
X/*							*/
X/********************************************************/
X
X#include "ro.h"
X
X/****************************************/
X
Xputtl3( s1, s2, s3, pageno )
X	char *s1, *s2, *s3;
X	int pageno;			 /*put out three part title, none
X					containing '\n', with
X					optional page numbering; aligning
X					with page margins,0 & ro_rmval[0];*/
X	{
X	int size1, gap1, size2, gap2, size3, gaps, remain;
X	size1 = strln3( s1, FALSE, pageno );
X	ro_outtop = ro_ltop;
X	ro_outbot = ro_lbot;
X	size2 = strln3(s2,FALSE,pageno);
X	if (ro_ltop<ro_outtop)
X		ro_outtop=ro_ltop;
X	size3 = strln3(s3,FALSE,pageno);
X	if (ro_ltop<ro_outtop)
X		ro_outtop=ro_ltop;
X	gaps = ro_max( 0, ro_rmval[0]-size1-size2-size3);
X	gap1 = gaps/2;
X	gap2 = gaps-gap1;
X	remain = ro_rmval[0];
X	if ( size1 <= remain )
X		{
X		puttl( s1, pageno);
X		remain -= size1;
X		}
X	if ( gap1 < remain )
X		{
X		blanks( gap1 );
X		remain -= gap1;
X		}
X	if ( size2 <= remain )
X		{
X		puttl( s2, pageno );
X		remain -= size2;
X		}
X	if ( gap2 < remain )
X		{
X		blanks( gap2 );
X		remain -= gap2;
X		}
X	if ( size3 <= remain )
X		{
X		puttl( s3, pageno );
X		remain -= size3;
X		}
X	printout();
X	putchar('\r');
X	}
X
X/****************************************/
X
Xblanks( i )
X	int i;	/*sends i blanks to ro_out2buf*/
X	{		
X	if(i<0) return;
X	for( ; i ; i--) putout( BLANK );
X	}
X
X/****************************************/
X/* Gets from source line three part title that it
X	transfers to buffer delineated by ttl1 which has
X	capacity for all three strings; none of the strings
X	will contain '\n' */
X
Xgettl3( sl, ttl1, ttl2, ttl3 )
X	char *sl, *ttl1, *ttl2, *ttl3;
X	{
X	char c, cc, *dp;
X
X	if DEBUG fprintf( stderr,"DEBUG:  gettl3() sl = <%s> \n", sl );
X
X	/*pass over command*/
X
X	for ( c = *sl; c != ' ' && c != '\n' && c != '\t'; sl++ )
X		{
X		c = *sl;
X		}
X
X	/*advance to first non-blank or '\n' */
X
X	for ( ; c == ' ' || c == '\t'; sl++ )
X		{
X		c = *sl;
X		}
X
X	/* c should now be set to the delimiter */
X	/* advance beyond delimiter, if present */
X
X	if ( c != '\n' && !c ) 
X		{
X		sl++;
X		}
X
X	dp = ttl1;
X	transfer( &sl, &dp, c );
X	dp = ttl2;
X	transfer( &sl, &dp, c);
X	dp = ttl3;
X	transfer( &sl, &dp, c);
X
X	if DEBUG
X		{
X		fprintf( stderr,"DEBUG:  delim=<%c>\nT1=<%s>\nT2=<%s>\nT3=<%s>;\n",
X			c, ttl1, ttl2, ttl3);
X		}
X
X	}
X
X/****************************************/
X/* Copy string from source to destination.	Original delim.
Xcan be \0, \n, or char.	The pointer to the source is updated
Xto point at the \0, \n, or past char.	In destination, delim.
Xis always replaced by \0.	The destination pointer always
Xpoints past this \0. */
X
Xtransfer( src, dst, c )
X	char c;     		/* terminal character */
X	char **src;		/* source string */
X	char **dst;		/* destination string */
X	{
X	char a;
X
X	a = **src;
X	while ( a != c && a != '\n' && a != '\0' && a )
X		{
X		**dst = a;	
X		(*dst)++;
X		(*src)++;	
X		a = **src;
X		}
X	**dst = '\0';
X	(*dst)++;
X	if ( a != '\n' ) 
X		{
X		(*src)++;
X		}
X	}
X
X/**********************************************************
X centers a line of text
X**********************************************************/
X
Xcenter (line)
X	char *line;
X	{
X	ro_tival = ro_max(( ro_rmval[0]+ro_tival-strln3(line,FALSE,1))/2, 0 );
X	ro_outtop=ro_ltop;
X	ro_outbot=ro_lbot;
X	return;
X	}
X
X/************************************************************
XRevised April 24,83.Transfers next word from in to out.	Scans
Xoff leading white space from in.	If there is no word, returns
XFALSE.	Otherwise, input is truncated on left of word which is
Xtransfered to out without leading or trailling blanks.
XWE_HAVE_A_WORD will be returned.	If the transfered word
Xterminates a sentence then ro_sentence is set to 1, otherwise it
Xis reset to FALSE.
X**************************************************************/
X
Xint getwrd (in,	out )
X	char *in, *out;
X	{
X	char *pin, *pout, c, cm, cp;
X
X	skip_blanks(in);
X	replace_char(in,TAB,BLANK);
X	pin = in;
X	pout = out;
X	c = *pin;
X	ro_sentence=FALSE;
X	if(c==NEWLINE || c=='\0')
X		{
X		*out='\0';
X		if DEBUG fprintf( stderr,"DEBUG:  getwrd() = <%s> \n", out );
X		return(FALSE);
X		}
X	while(c!=BLANK && c!=NEWLINE && c)
X		{
X		*(pout++) = c;
X		*pin = BLANK;
X		c=*(++pin);
X		}
X	*pout = '\0';	/*terminate out string*/
X	cm=*(pout-1);
X	cp=*(pin+1);
X	switch (cm)
X		{
X	case ':' :
X	case ';' :
X	case '?' :
X	case '!' :
X			ro_sentence=1;
X			break;
X	case '.' :
X			if(cp==BLANK||cp==NEWLINE||c==NEWLINE)
X				 ro_sentence=1;
X		}
X	if DEBUG fprintf( stderr, "DEBUG:  getwrd() = <%s> \n", out );
X	return(WE_HAVE_A_WORD);
X	}
X
X/*******************************************************
XTruncates white-space characters at the end of a string.
X********************************************************/
X
Xtrunc_bl (string)
X	char *string;
X	{
X	char *ptr;
X	int k;
X	k = strlen (string);
X	ptr = &string[ k-1 ];	 /* char before terminating nul */
X	while (*ptr==BLANK || *ptr==TAB || *ptr==NEWLINE)		
X			*ptr--	= '\0';
X	}
X
X/*********************************************
X		 distribute words evenly across a line
X**********************************************/
X
Xspread ( line, nextra, no_words)
X	char *line;
X	int nextra;	/* no. extra places left in line */
X	int no_words;	 /* no. words in the line		*/
X	{
X	int i, j, nblanks, nholes;
X
X	if DEBUG fprintf( stderr,"DEBUG:  spread(): line = <%s>,\n        nextra = %d, no_words = %d\n",
X		 line, nextra, no_words	);
X
X	if (nextra <= 0 || no_words <= 1)
X		return;
X	ro_dir = !(ro_dir);
X	nholes = no_words - 1;
X	trunc_bl (line);
X	i = strlen(line) - 1 ; /* last character of string */
X	j = ro_min(MAXLINE-2,i+nextra);	/* last	position in output */
X	line[j+1] = '\0';
X	for ( ; i<j ; i--, j-- )
X		{ 
X			line[j] = line[i];
X			if ( line[i] == BLANK)
X				{ 
X				 if (ro_dir == 0) nblanks=(nextra-1)/nholes+1;
X				 else			nblanks = nextra/nholes;
X				 nextra = nextra - nblanks;
X				 nholes = nholes - 1;
X				 for ( ; nblanks > 0;	nblanks-- )
X					line[--j] = BLANK;
X				}
X		}
X	}
X
X/************************************************
Xplace portion of title line with optional page no. in ro_out2buf
X*************************************************/
X
Xputtl ( str, num )
X	char *str;
X	int num;
X	{
X	int i;
X	char c;
X	for (i=0;c= *str; str++)
X		{
X			if ( c != NUMSIGN ) putout(c);
X			else putnum(num);
X		}
X	}
X
X/*******************************************
X put out num to ro_out2buf (conversion)
X********************************************/
Xputnum ( num, w )
X	int num;
X	{
X	int i, nd;
X	char chars[10];
X	nd = itoc ( num, chars, 10 );
X	for ( i=0;i<nd; i++) putout(chars[i]);
X	}
X
X/************************************************
X convert int num to char string in numstr
X*************************************************/
X
Xitoc ( num, numstr, size )
X	int num;
X	char *numstr;
X	int size;		/* largest size of numstr */
X	{
X	int absnum, i, j, k, d;
X	absnum = abs (num);
X	numstr[0] = '\0';
X	i = 0;
X	do	 	{ 
X			i++;
X			d = absnum % 10;
X			numstr[i] = d + '0';
X			absnum = absnum/10;
X		}
X	while ( absnum != 0 && i<size );
X	if ( num < 0 && i<size )
X		{ 
X			i++;
X			numstr[i] = '-';
X		}
X	for( j=0; j<i; j++ )
X		{ 
X			k = numstr[i];
X			numstr[i] = numstr[j];
X			numstr[j] = k;
X			i--;
X		}
X	return ( strlen(numstr) );
X	}
X
X/****************************************/
X
Xputout(c)		/*places c in ro_out2buf[]*/
X	char c;
X	{
X	if(c==ro_scval[0]) c= BLANK;
X	if(c==NEWLINE)c='\0';
X	ro_out2buf[ro_bpos++]=c;
X	ro_out2buf[ro_bpos]='\0';/*safty net*/
X	}
X
X/************************************
X replace c1 in string with c2
X*************************************/
X
Xreplace_char (string, c1, c2)
X	char *string, c1, c2;
X	{
X	int i;
X	for (i=0; string[i]; i++)
X			if (string[i] == c1)	string[i] = c2;
X	}
________This_Is_The_END________
if test `wc -l < ro_word.c` -ne 380; then
	echo 'shar: ro_word.c was damaged during transit (should have been 380 bytes)'
fi
fi		; : end of overwriting check
echo 'x - ro_text.c'
if test -f ro_text.c; then echo 'shar: not overwriting ro_text.c'; else
sed 's/^X//' << '________This_Is_The_END________' > ro_text.c
X/********************************************************/
X/*							*/
X/*	ro_text.c	text-handling routines for ro	*/
X/*							*/
X/*	ro version 1.00					*/
X/*							*/
X/*	Portions copyright (c) 1989 by Ted A. Campbell	*/
X/*		Bywater Software			*/
X/*		P. O. Box 4023				*/
X/*		Duke Station				*/
X/*		Durham, NC  27706			*/
X/*							*/
X/*	Contains portions of ROFF4, Version 1.61	*/
X/*      (c) 1985 by Konrad Kwok                         */
X/*		20 3rd Street, Section M		*/
X/*		Fariview Park,				*/
X/*		Hong Kong				*/
X/*							*/
X/*      Contains portions of ROFF4, Version 1.60        */
X/*      (c) 1983, 4 by Ernest E. Bergmann               */
X/*              Physics, Building #16                   */
X/*              Lehigh University                       */
X/*              Bethlehem, Pa. 18015                    */
X/*                                                      */
X/*	ro and its predecessor ROFF4 are based on 	*/
X/*	the ROFF text processor described in Kernigan	*/
X/*	and Plauger's now-classic text <Software Tools> */
X/*							*/
X/* Permission is hereby granted for all commercial and	*/
X/* non-commercial reproduction and distribution of this */
X/* material provided this notice is included.		*/
X/*							*/
X/********************************************************/
X
X#include "ro.h"
X
X/**************************************************
Xhandles case of leading blanks or tabs; empty lines 
X***************************************************/
X
Xleadbl( line )
X	char *line;
X	{
X	int i, j, white;
X	ro_brk();
X	for ( white = 0, i = 0; line[i] == ' ' || line[i] == '\t'; i++ )
X		{
X		if (line[i] == ' ')
X			white++;
X		else
X			white = ro_min( ro_rmval[0], ro_tabsiz[0]*(1+white/ro_tabsiz[0]));
X		}
X
X	if ( line[i] != NEWLINE )
X		ro_tival += white;
X
X	/* move line to left */
X	for( j = 0; (line[j] = line[i]) != '\0'; j++, i++ );
X	}
X
X/*****************************************
Xputs out page header
X******************************************/
X
Xphead()
X	{
X	exchange();
X	ro_uf=ro_xf=FALSE;
X	ro_mcnt=1;
X	ro_curpag = ro_newpag++;
X	preregister( "%", ro_curpag );
X	if((ro_curpag<ro_firstpage)||(ro_curpag>ro_lastpage))
X		ro_suppress=TRUE;
X	else
X		ro_suppress=FALSE;
X	ro_oldln=-1;
X	if( ro_pagestop )
X		{
X		fprintf( stderr, "%cPAGE:  Please type <RETURN> to continue:  ",
X			BELL );
X		getchar(); 		/* wait until char typed at console */ 
X		}
X	ro_plineno=0;
X	ro_pflineno=0;
X	if (ro_m1val[0] > 0 )
X		{ 
X		ro_vlineno = ro_m1val[0]-1;
X		if (ro_curpag % 2) puttl3 ( ro_ohead, ro_oh2, ro_oh3, ro_curpag );
X		else puttl3 ( ro_ehead, ro_eh2, ro_eh3, ro_curpag );
X		}
X	ro_vlineno = ro_m1val[0]+ro_m2val[0]; 
X	ro_vflineno=0;
X	exchange();
X	}
X
X/**************************************
Xputs out page footer
X***************************************/
X
Xpfoot()
X	{
X	exchange();
X	ro_uf=ro_xf=FALSE;
X	ro_mcnt=1;
X	ro_vlineno = ro_bottom+ro_m3val[0]; 
X	ro_vflineno=0;
X	if ( ro_m4val[0] > 0 )
X		{ 
X		if(ro_curpag % 2)puttl3 ( ro_ofoot,ro_of2,ro_of3, ro_curpag );
X		else puttl3(ro_efoot,ro_ef2,ro_ef3,ro_curpag);
X		}
X	ro_vlineno = ro_plval[0];
X	ro_vflineno=0;
X	if (ro_useff) putchar(FORMF);
X	else padv();
X	ro_oldbot=ro_plineno=ro_pflineno=0; /*printer at start of newpage*/
X	ro_oldln=-1;
X	exchange();
X	}
X
X/**********************************************
Xspace n lines or to bottom of the page
X***********************************************/
X
Xdo_space( n )
X	int n;
X	{
X	ro_brk(); /* flush out last unfilled line */
X	if ( ro_vlineno >= ro_bottom)	
X		{
X		return; /* end of page */
X		}
X	if ( ro_vlineno < 0) 
X		{
X		phead(); /* top of page */
X		}
X	ro_vlineno += n;
X
X	if ( ro_vlineno >= ro_bottom ) 
X		{
X		pfoot(); /* print footer if bottom */
X		}
X	}
X
X/*******************************************************/
X
Xtext (line)
X	char *line;
X	{
X	char wrdbuf [LSZ];
X	int i, j, k;
X	char *p1, *p2;
X	if DEBUG fprintf( stderr, "DEBUG:  text: <%s> \n", line);
X
X	if (line[0] == BLANK || line[0]==NEWLINE || line[0] == TAB)
X		leadbl (line);
X	if (ro_ceval > 0)
X		{ 
X		center(line);
X		put(line);
X		ro_ceval--;
X		}
X	else if ( ( line[0] == NEWLINE ) || ( line[0] == '\0' ))
X		{
X		do_space( ro_lsval[0] );
X		}
X	else if(!ro_fill[0])
X		put(line);
X	else
X		while (WE_HAVE_A_WORD == getwrd (line, wrdbuf))
X			putwrd (wrdbuf);
X	}
X
X/******************************************************
Xput out a line of text with correct indentation
Xunderlining if specified
X*******************************************************/
X
Xput (line)
X	char *line;
X	{
X	int i, fs, minfs;
X	if ((ro_vlineno < 0)||(ro_vlineno >= ro_bottom))
X		{
X		phead();
X		}
X	fs=(ro_vlineno-ro_oldln)*ro_frval;
X	minfs=ro_oldbot-ro_outtop; 
X	if(!(ro_oldbot&&ro_outtop))
X		{
X		minfs++;
X		}
X	while ( fs < minfs )
X		{
X		fs += ro_frval;
X		ro_vlineno++;
X		}
X	need(0);
X	putline(line);
X	ro_tival = ro_inval[0];
X	ro_vlineno += ro_lsval[0];
X	if (ro_vlineno >= ro_bottom)
X		{
X		pfoot();
X		}
X	}
X
X/***********************************************************
Xconcatenates the word onto the end of ro_outbuf for filled text
X************************************************************/
X
Xputwrd (wrdbuf) /*Nov 22: ro_sentence*/
X	char *wrdbuf;
X	{
X	int i, j, k;
X	char s[MAXLINE], ch;
X	int line_len, new_out_width, wid;
X	int nextra;
X	skip_blanks (wrdbuf); 
X	trunc_bl (wrdbuf);
X	wid =1+ro_sentence+strln3(wrdbuf,TRUE,1);/*sets ro_wtop,ro_wbot*/
X	line_len = ro_rmval[0] - ro_tival;
X	new_out_width = ro_outw+wid;
X	if (new_out_width > ro_min(line_len, MAXLINE-1))
X		{ 
X		nextra = ro_min(line_len, MAXLINE-1)-ro_outw+1;
X		if(ro_outbuf[ro_outpos-2]==BLANK) nextra++;
X		if(ro_adjust) spread(ro_outbuf,nextra,ro_outwrds);
X		ro_brk();
X		}
X	ro_outw += wid;
X	OUTcat(wrdbuf);
X	OUTSP(); 
X	if(ro_sentence) OUTSP();
X	ro_outwrds++;
X	if(ro_wtop<ro_outtop) ro_outtop=ro_wtop;
X	if(ro_wbot>ro_outbot) ro_outbot=ro_wbot;
X	}
X
X/**********************************************************
Xa new putline routine; sends line to	OUTPUT2
X***********************************************************/
X
Xputline (line)
X	char *line;
X	{
X	char c;
X	blanks ( ro_tival );
X	for ( ; c = *line; line++ )
X		{
X		putout(c);
X		}
X	putout('\0');
X	printout();
X	}
X
X/****************************************/
X
XOUTcat(str)	 /*appends string to ro_outbuf*/
X	char *str;
X	{
X	while(ro_outbuf[ro_outpos]=*(str++))
X		ro_outpos++;
X	}
X
X/****************************************/
X
XOUTSP()		 /*appends BLANK to ro_outbuf*/
X	{
X	ro_outbuf[ro_outpos++]=BLANK;
X	ro_outbuf[ro_outpos]='\0';
X	}
X
X/****************************************/
X
Xgloss() /*prints on STDOUT a glossary of .tr chars*/
X	{
X	int i;
X	char line[20],tcs;
X	put("GLOSSARY:");
X	put("USE	 <GET>");
X	tcs=ro_tcval[0];
X	ro_tcval[0] |= 128; /*set most significant bit*/
X	for(i=1;i<19;i++) line[i]=' ';
X	line[0]=tcs;
X	line[8]='<';
X	line[9]=ro_tcval[0];
X	line[11]='>';
X	line[12]='\0';
X	for(i=' ';i<127;i++)
X		{
X		if(ro_tptr[i-' '])
X			{
X			line[1]=line[10]=i;
X			put(line);
X			}
X		}
X	ro_tcval[0]=tcs;
X	do_space(HUGE);
X	}
X
X/***************************************/
X
Xexchange() /*maintain separate environment for headers and
X		footers*/
X	{
X	int i;
X	i=ro_mcnt2; 
X	ro_mcnt2=ro_mcnt; 
X	ro_mcnt=i;
X	i=ro_xf2; 
X	ro_xf2=ro_xf; 
X	ro_xf=i;
X	i=ro_uf2; 
X	ro_uf2=ro_uf; 
X	ro_uf=i;
X	}
________This_Is_The_END________
if test `wc -l < ro_text.c` -ne 317; then
	echo 'shar: ro_text.c was damaged during transit (should have been 317 bytes)'
fi
fi		; : end of overwriting check
echo 'x - ro_setp.c'
if test -f ro_setp.c; then echo 'shar: not overwriting ro_setp.c'; else
sed 's/^X//' << '________This_Is_The_END________' > ro_setp.c
X/********************************************************/
X/*							*/
X/*	ro_setp.c	set parameters and other 	*/
X/*			routines for ro			*/
X/*							*/
X/*	ro version 1.00					*/
X/*							*/
X/*	Portions copyright (c) 1989 by Ted A. Campbell	*/
X/*		Bywater Software			*/
X/*		P. O. Box 4023				*/
X/*		Duke Station				*/
X/*		Durham, NC  27706			*/
X/*							*/
X/*	Contains portions of ROFF4, Version 1.60	*/
X/*      (c) 1983, 4 by Ernest E. Bergmann               */
X/*		Physics, Building #16			*/
X/*		Lehigh University			*/
X/*		Bethlehem, Pa. 18015			*/
X/*							*/
X/*	Contains portions of ROFF4, Version 1.61	*/
X/*      (c) 1985 by Konrad Kwok                         */
X/*		20 3rd Street, Section M		*/
X/*		Fariview Park,				*/
X/*		Hong Kong				*/
X/*							*/
X/*	ro and its predecessor ROFF4 are based on 	*/
X/*	the ROFF text processor described in Kernigan	*/
X/*	and Plauger's now-classic text <Software Tools> */
X/*							*/
X/* Permission is hereby granted for all commercial and	*/
X/* non-commercial reproduction and distribution of this */
X/* material provided this notice is included.		*/
X/*							*/
X/********************************************************/
X
X#include "ro.h"
X
X/**************************************************/
X
Xint value( base, string)	/*unsigned conversion*/
X	int base;			/*radix for conversion*/
X	char *string;		 	/*no leading blanks please!*/
X				/*trailing whitespace or '\0'*/
X	{
X	int val,d;
X	char c;
X	val=0;
X	for(d=digit(*string);d>=0 && d<base ; d=digit(*string))
X		{
X		val = val*base + d;
X		string++;
X		}
X	c = *string;
X	if ( !c || c==' ' || c==TAB || c=='\n') return(val);
X	else return(-1);		/*error return is -1*/
X	}
X
X/**************************************************/
X
Xint digit(d)
Xchar d;
X	{	 
X	d=toupper(d);
X	if(d<='9') return(d-'0');
X	if(d<'A') return(-1); /*error return is negative val*/
X	if(d<='Z') return(10-'A'+d);
X	return(-1);	 /*error*/
X	}
X
X/**************************************************/
X/* returns printed string length; checks legality of
Xword function; keeps track of vertical
Xexcursions; records them in globals */
X
Xstrln3( s, word, num )
X	char *s;
X	int word;               /* boolean, if true, check is made for none
X 				   black characters in the string */
X	int num;                /* for expansion of NUMSIGN; set 1 to ignore */
X	{
X	int i, i2, p1, p2, p3;
X	int t, b, h;            /*vertical vars*/
X	char c, *ss;
X	ss = s;
X	t = b = h = 0;
X	p3 = p2 = p1 = -LSZ;
X	for ( c = *ss, i2 = i = 0; c; c = *(++ss) )
X		{
X		if ( c == NUMSIGN )
X			{
X			i++;
X			if(num>9) i++;
X			if(num>99) i++;
X			if(num>999) i++;
X			}
X		else if ( (c != ro_tcval[0] ) && ( c != ESCAPE ) )
X			{
X			if ( ( c <= ' ' ) && (word) )
X				{
X				if ( ro_verbose == TRUE )
X					{
X					fprintf( stderr, "ro: illegal character 0x%x \n",
X						c );
X					}
X				goto error;
X				}
X			else i++;
X			}
X		else if ( c == ESCAPE )
X			{
X			c = *(++ss);		
X			if ( c == ESCAPE ) 
X				{
X				goto error; /*both ro_cfval[0], ro_tcval[0] */
X				}
X			switch( c )
X				{
X				case ROMAN:
X				case ITALIC:
X				case BOLD:
X				case HALFUP:
X				case HALFDOWN:
X					break;
X				default: 
X					if (ro_verbose )
X						fprintf( stderr, "ro:  c <%c> is not printer code. \n", c );
X					goto error;	 /*undecipherable*/
X					break;
X				}
X			}
X		else	/*c==ro_tcval[0]*/
X			{
X			if(class(*(s+1))!=BLACK)
X				{
X				goto error;      /*illegal translation*/
X				}
X			}
X		}
X	if ( h )
X		{
X		goto error;
X		}
X	if ( word )
X		{
X		ro_wtop=t;
X		ro_wbot=b;
X		}
X	else
X		{
X		ro_ltop=t;
X		ro_lbot=b;
X		}
X	if(i>=i2)
X		{
X		return( i );
X		}
X
X	/* else prints beyond last character: */
X
Xerror:
X	if ( ro_verbose == TRUE )
X		{
X		fprintf( stderr, "ro: line <%s> is illegally formed.\n", s );
X		}
X
X	return ( strlen( ss ) );
X	}
X
X/* A properly formed token string has its first printable
Xcharacter indicating the lefthand edge and the last printable
Xcharacter at the right hand edge.	Only legal control pairs
Xaccepted.	It must consist of printable symbols. */
X
X/**************************************************************
XSet a stack variable like set() sets a global integer variable.  
X**************************************************************/
X
XsetS ( param, val, arg_typ, defval, minval, maxval )
X	int param[STKSIZ], val, defval, minval, maxval;
X	int arg_typ;
X	{
X	register int i;
X
X	if ( val == NO_VAL )
X		{
X		for ( i = 0; i < STKSIZ - 1; i++ )	/*pop*/
X			{
X			param[ i ] = param[ i + 1 ];
X			}
X		param[ STKSIZ - 1 ] = defval;
X		}
X	else
X		{
X		for ( i = STKSIZ - 1; i; i-- )	/*push*/
X			{
X		 	param[ i ] = param[ i - 1 ];
X			}
X		if ( arg_typ == '+' ) 
X			{
X			param[ 0 ] += val;
X			}
X		else if ( arg_typ == '-' ) 
X			{
X			param[ 0 ] -= val;
X			}
X		else param[ 0 ] = val;
X		}
X	param[ 0 ] = ro_min( ro_max( param[ 0 ], minval), maxval );
X
X	if DEBUG fprintf( stderr, "DEBUG:  setS(): *param = %d \n", *param );
X
X	}
X
X/******************************************
Xinitialize stack type variable, st, with v
X*******************************************/
X
Xinitsk( st, v )
X	int st[STKSIZ], v;
X	{
X	register int i;
X	for ( i = STKSIZ - 1; i >= 0; --i )
X		{
X		st[ i ] = v;
X		}
X	}
X
X/**************************************************/
X
Xgettr() /*process .tr */
X	{
X	if ( ro_verbose )
X		fprintf( stderr, ".tr is not currently implemented. \n" );
X	}
X
X/**************************************************/
X
Xoutstr(p)	 /*print string whose bytecount is *p */
Xchar *p;
X	{
X	int i;
X	for(i=*(p++); i; i--) putchar(*(p++));
X	}
X
________This_Is_The_END________
if test `wc -l < ro_setp.c` -ne 244; then
	echo 'shar: ro_setp.c was damaged during transit (should have been 244 bytes)'
fi
fi		; : end of overwriting check
echo 'x - ro_outp.c'
if test -f ro_outp.c; then echo 'shar: not overwriting ro_outp.c'; else
sed 's/^X//' << '________This_Is_The_END________' > ro_outp.c
X/********************************************************/
X/*							*/
X/*	ro_outp.c	output routines for ro		*/
X/*							*/
X/*	ro version 1.00					*/
X/*							*/
X/*	Portions copyright (c) 1989 by Ted A. Campbell	*/
X/*		Bywater Software			*/
X/*		P. O. Box 4023				*/
X/*		Duke Station				*/
X/*		Durham, NC  27706			*/
X/*							*/
X/*	Contains portions of ROFF4, Version 1.60	*/
X/*      (c) 1983, 4 by Ernest E. Bergmann               */
X/*		Physics, Building #16			*/
X/*		Lehigh University			*/
X/*		Bethlehem, Pa. 18015			*/
X/*							*/
X/*	Contains portions of ROFF4, Version 1.61	*/
X/*      (c) 1985 by Konrad Kwok                         */
X/*		20 3rd Street, Section M		*/
X/*		Fariview Park,				*/
X/*		Hong Kong				*/
X/*							*/
X/*	ro and its predecessor ROFF4 are based on 	*/
X/*	the ROFF text processor described in Kernigan	*/
X/*	and Plauger's now-classic text <Software Tools> */
X/*							*/
X/* Permission is hereby granted for all commercial and	*/
X/* non-commercial reproduction and distribution of this */
X/* material provided this notice is included.		*/
X/*							*/
X/********************************************************/
X
X#include "ro.h"
X
X/*assuming REVSCROLL is FALSE*/
X/*output ro_out2buf with the vertical height of the mainline
Xspecified by ro_vlineno,ro_vflineno[they must not be changed here].
XExcessive superscripting will be pushed down.*/
X
Xprintout()
X	{
X	int level, top, bot;       /* "up" is negative; units fractional */
X	int lsave;
X	register int n;
X
X	ro_out2buf[ ro_bpos ] = '\0';           /* terminate with '\0' */
X	lsave = ro_vlineno;
X	level = ro_plineno - ro_vlineno;
X
X	if ( !ro_oldbot )
X		{
X		level++;
X		}
X
X	excurs( &ro_out2buf[0], &top, &bot );
X
X	if ( top > level )
X		{
X		level=top;
X		}
X
X	padv();
X
X	/* output offset spaces at beginning of line */
X
X	for ( n = 0; n < ro_poval; ++n )
X		{
X		putchar( ' ' );
X		}
X
X	for ( ; level <= bot; level++ )
X		{
X		ro_ocnt = 0;
X		do
X			{
X			ro_ocnt++; 
X			flp( level, FALSE );
X			}
X		while ( retype() );
X		}
X
X	ro_out2buf[0] = ro_bpos = 0;
X	ro_oldln = ro_vlineno = lsave;
X	ro_oldbot = bot;
X	}
X
X/****************************************/
X/*moves printer vertically so that its position is specified
Xby ro_vlineno,ro_vflineno*/
X
Xpadv()
X	{
X	int w;
X
X	w = ro_vlineno - ro_plineno;
X	if ( w < 0 )
X		{
X		if (ro_verbose )
X			{
X			fprintf( stderr,"padv(): VL=%d, PL=%d\n",
X				ro_vlineno, ro_plineno);
X			}
X		ro_vlineno += w;
X		}
X	while( w-- )
X		{
X		putchar('\n');
X		ro_plineno++;
X		}
X	}
X
X/**************************************************/
X/* finds the topmost and bottommost line
Xpositions of str */
X
Xexcurs( str, t, b)
X	char *str;
X	int *t, *b;
X	{
X	int l;
X	char c;
X	*t = *b = l = 0;        /*current line position */
X	c = *str;
X	while ( c )
X		{
X		if ( c == ro_cfval[0])
X			{
X			if ( c = *(++str) )
X				{
X				switch ( c )
X					{
X				case '+':
X					l--; 
X					if ( l < *t )
X						{
X						*t = l;
X						}
X					c = *( ++str );
X					break;
X				case '-':
X					l++; 
X					if ( l >* b)
X						{
X						*b = l;
X						}
X					c = *( ++str );
X					break;
X				default : 
X					c = *( ++str );
X					break;
X					}
X				}
X			}
X		else c = *( ++str );
X		}
X	}
X
X/**************************************************/
X/*fancy line print at a given vertical level
Xthe string in ro_out2buf[] with backspacing,
Xunderlining, and strikout.	To permit boldface
Xit modifies ro_dbuf[], ro_dpos so that retype can be
Xused to patch up ro_out2buf for resubmittal to
Xflp()*/
X
Xflp( level, updat )
X	int level;	/* current vertical level to print*/
X	int updat;	/* boolean for update of ro_uf,ro_xf,ro_mcnt*/
X	{
X	int i;
X	ro_blkcnt=lbc(level,ro_out2buf);
X	ro_first=TRUE;
X	while((ro_blkcnt>0)||updat)
X		{
X		prpass(level,updat); 
X		putchar('\r');
X		updat=ro_first=FALSE;
X		}
X	if(ro_xcol>-1)	{
X		for(i=0;i<=ro_xcol;i++)
X			putchar(ro_xbuf[i]);
X		putchar('\r');
X		}
X	if(ro_ucol>-1)	{
X		for(i=0;i<=ro_ucol;i++)
X			putchar(ro_ubuf[i]);
X		putchar('\r');
X		}
X	if((ro_ucol>-1)||(ro_xcol>-1)) initxu();
X	}
X
X/**************************************************/
Xretype()		/*restores characters into ro_out2buf from ro_dbuf
X			that need to be overstruck again*/
X	{
X	int i;
X	if ( ro_dpos == -1 )
X		{
X		return(FALSE);
X		}
X	else
X		{
X		for(i=0;i<=ro_dpos;i++)
X			{
X			if(ro_dbuf[i])
X				{
X				ro_out2buf[i]=ro_dbuf[i];
X				ro_dbuf[i]=FALSE;
X				}
X			}
X		ro_dpos = -1;
X		return( TRUE );
X		}
X	}
X
X/**************************************************/
X/*counts printable chars in line level and
Xabove; parity must be reset*/
X
Xint lbc( lev, str ) 
X	int lev; /*=0 main line,=-1 superscripts,=+1 subscripts, etc.*/
X	char *str;
X	{
X	char c;
X	int l, n;
X	l = n = 0;
X	c = *str;
X	while ( c )
X		{
X		if(c == ro_cfval[0])
X			{
X			if ( c = *(++str) )
X				{
X				switch(c)
X					{
X				case '+':
X					l--;
X					c = *(++str);
X					break;
X				case '-':
X					l++;
X					c = *(++str);
X					break;
X				default: 
X					c = *(++str);
X					break;
X					}
X				}
X			}
X		else
X			{
X			if((c>' ')&&(l<=lev))
X				{
X				if(c!=ro_tcval[0])
X					{
X					n++;
X					}
X				}
X			c = *( ++str );
X			}
X		}
X	return(n);
X	}
X
X/**************************************************/
X/*printer pass initial cr; no lf anywhere*/
X
Xprpass( lev, updat ) 
X	int lev; /*=0 main line,=-1 superscripts,=+1 subscripts, etc.*/
X	int updat;/*boolean to update ro_uf,ro_xf,ro_mcnt*/
X	{
X	char ch;
X	int l;
X	int xfs,ufs,mcnts;	/*save variables*/
X	int p1,p2,p3;		 /*position holders*/
X	int cp2;		/*for tabulation calculation*/
X	xfs=ro_xf; 
X	ufs=ro_uf; 
X	mcnts=ro_mcnt;
X	p1=p2=p3=l=ro_bpos=ro_cp=ro_pp=0;
X	while(ch=ro_out2buf[ro_bpos])
X		{
X		switch (class(ch))
X			{
X		case 	ESCAPE:
X		case	BLACK:	/*print it if posssible*/
X			if ( ( ro_pp > ro_cp ) || ( l > lev ) )	
X				{
X				ro_cp++;
X				ro_bpos++;
X				break;
X				}
X			else		{
X				while(ro_cp>ro_pp)	{
X					putchar(' ');
X					ro_pp++;
X					}
X				if(ch==ro_scval[0])putchar(' ');
X				else putchar(ch);
X				ro_pp++;
X				if(ro_mcnt>ro_ocnt)
X					{
X					ro_dbuf[ro_bpos]=ro_out2buf[ro_bpos];
X					if(ro_bpos>ro_dpos) ro_dpos=ro_bpos;
X					}
X				ro_out2buf[ro_bpos++]=' ';
X				if(ro_uf&&ro_first)ro_ubuf[ro_ucol=ro_cp]=UCHAR;
X				if(ro_xf&&ro_first)ro_xbuf[ro_xcol=ro_cp]=XCHAR;
X				ro_blkcnt--; 
X				ro_cp++;
X				} 
X			break;
X		case	WHITE:/*assume blank*/
X			ro_cp++;
X			ro_bpos++;
X			break;
X		case	TRANSLATE:/*similar to BLACK and WHITE*/
X			ch=ro_out2buf[++ro_bpos];
X			if((ro_pp>ro_cp)||(l>lev)||(ch==' '))
X				{
X				ro_cp++;
X				ro_bpos++;
X				break;
X				}
X			else
X					{
X				while(ro_cp>ro_pp)	{
X					putchar(' ');
X					ro_pp++;
X					}
X				trch(ch);
X				ro_pp++;
X				if(ro_mcnt>ro_ocnt)
X					{
X					ro_dbuf[ro_bpos]=ro_out2buf[ro_bpos];
X					ro_dbuf[ro_bpos-1]=ro_out2buf[ro_bpos-1];
X					if(ro_bpos>ro_dpos) ro_dpos=ro_bpos;
X					}
X				ro_out2buf[ro_bpos++]=' ';
X				if(ro_uf&&ro_first)ro_ubuf[ro_ucol=ro_cp]=UCHAR;
X				if(ro_xf&&ro_first)ro_xbuf[ro_xcol=ro_cp]=XCHAR;
X				ro_blkcnt--; 
X				ro_cp++;
X				} 
X			break;
X
X		case	SENTINEL: 
X			ro_out2buf[ro_bpos]=0;
X			break;
X		case	HTAB: 
X			for(cp2=0;ro_cp>=0;cp2+=ro_tabsiz[0])ro_cp-=ro_tabsiz[0];
X			ro_cp=cp2; 
X			ro_bpos++; 
X			break;
X		case	OTHERS:
X			if ( ro_verbose )
X				fprintf( stderr,"\nweird character value[octal]: %o\n",ch);
X			ro_bpos++;
X			break;
X			}
X		}
X	if(!updat)	{/*restore original values*/
X		ro_newxf=ro_xf;
X		ro_xf=xfs;
X		ro_newuf=ro_uf;
X		ro_uf=ufs;
X		ro_newmcnt=ro_mcnt;
X		ro_mcnt=mcnts;
X		}
X	}
X
X/**************************************************/
Xupdatef()	/* 3rd Mar, 85		 */
X	{		/* By Conrad Kwok	*/
X	ro_xf=ro_newxf;
X	ro_uf=ro_newuf;
X	ro_mcnt=ro_newmcnt;
X	}
X
X/**************************************************/
X
Xint class( c )
X	char c;
X	{
X	if ( c == ro_tcval[0] ) return(TRANSLATE);
X	if ( c == ESCAPE ) return(ESCAPE);
X	if ( c > ' ' ) return(BLACK);
X	if ( c == ' ') return(WHITE);
X	if ( c == '\n' ) return(SENTINEL);
X	if ( c == '\r' ) return(SENTINEL);
X	if ( c == TAB ) return(HTAB);
X	if (!c) return(SENTINEL);
X	return ( OTHERS );
X	}
X
X/**************************************************/
Xfraction()	/*put printer in fractional spcing mode;
X				set ro_frq*/
X	{
X	if(!ro_frq && ro_frstring && (ro_frval!=1))
X		{
X		outstr(ro_frstring);
X		ro_frq = TRUE;
X		}
X	}
X/**************************************************/
Xwhole()		 /*put printer in whole line spacing;
X				reset ro_frq */
X	{
X	if(ro_frq && ro_whstring)
X		{
X		outstr(ro_whstring);
X		ro_frq = FALSE;
X		}
X	}
X/**************************************************/
Xtrch(c) /*output string translation of c*/
Xchar c;
X	{
X	char *p;
X	if(c<' ') 
X		{
X		putchar(ro_tcval[0]);
X		putchar(c);
X		return;
X		}
X	p = ro_tptr[c-' '];
X	if(p) outstr(p);
X	else		
X		{/*not initialized*/
X		putchar(ro_tcval[0]);
X		putchar('?');
X		}
X	}
X/****************************************/
Xpcont(c) /*output printer control string for c*/
Xchar c;
X	{
X	char *p;
X	if(c<' ') 
X		{
X		putchar(ro_cfval[0]);
X		putchar(c);
X		return;
X		}
X	p = ro_cptr[c-' '];
X	if(p) outstr(p);
X	else	
X		{/*not initialized*/
X		putchar(ro_cfval[0]);
X		putchar('?');
X		}
X	}
________This_Is_The_END________
if test `wc -l < ro_outp.c` -ne 455; then
	echo 'shar: ro_outp.c was damaged during transit (should have been 455 bytes)'
fi
fi		; : end of overwriting check
echo 'x - Makefile'
if test -f Makefile; then echo 'shar: not overwriting Makefile'; else
sed 's/^X//' << '________This_Is_The_END________' > Makefile
XCFLAGS=		-O
X
XOFILES=		ro.o ro_proc.o ro_macr.o ro_dive.o ro_outp.o ro_word.o \
X		ro_setp.o ro_text.o
X
XCFILES=		ro.c ro_proc.c ro_macr.c ro_dive.c ro_outp.c ro_word.c \
X		ro_setp.c ro_text.c
X
XHFILES=		ro.h
X
Xroff4:		$(OFILES)
X		$(CC) $(CFLAGS) $(OFILES) -o ro
X
X$(OFILES):	$(HFILES)
________This_Is_The_END________
if test `wc -l < Makefile` -ne 14; then
	echo 'shar: Makefile was damaged during transit (should have been 14 bytes)'
fi
fi		; : end of overwriting check
echo 'x - ro.mak'
if test -f ro.mak; then echo 'shar: not overwriting ro.mak'; else
sed 's/^X//' << '________This_Is_The_END________' > ro.mak
XPROJ	=RO
XDEBUG	=0
XCC	=qcl
XCFLAGS_G	= /AS /W1 /Za 
XCFLAGS_D	= /Zd /Zr /Gi$(PROJ).mdt /Od 
XCFLAGS_R	= /O /Ot /DNDEBUG 
XCFLAGS	=$(CFLAGS_G) $(CFLAGS_R)
XLFLAGS_G	=/NOI
XLFLAGS_D	=/INCR /CO
XLFLAGS_R	=
XLFLAGS	=$(LFLAGS_G) $(LFLAGS_R)
XRUNFLAGS	=
XOBJS_EXT = 	
XLIBS_EXT = 	
X
Xall:	$(PROJ).exe
X
Xro.obj:	ro.c
X
Xro_dive.obj:	ro_dive.c
X
Xro_macr.obj:	ro_macr.c
X
Xro_outp.obj:	ro_outp.c
X
Xro_proc.obj:	ro_proc.c
X
Xro_setp.obj:	ro_setp.c
X
Xro_word.obj:	ro_word.c
X
Xro_text.obj:	ro_text.c
X
X$(PROJ).exe:	ro.obj ro_dive.obj ro_macr.obj ro_outp.obj ro_proc.obj ro_setp.obj ro_word.obj \
X	ro_text.obj $(OBJS_EXT)
X	echo >NUL @<<$(PROJ).crf
Xro.obj +
Xro_dive.obj +
Xro_macr.obj +
Xro_outp.obj +
Xro_proc.obj +
Xro_setp.obj +
Xro_word.obj +
Xro_text.obj +
X$(OBJS_EXT)
X$(PROJ).exe
X
X$(LIBS_EXT);
X<<
X	link $(LFLAGS) @$(PROJ).crf
X
Xrun: $(PROJ).exe
X	$(PROJ) $(RUNFLAGS)
X
________This_Is_The_END________
if test `wc -l < ro.mak` -ne 54; then
	echo 'shar: ro.mak was damaged during transit (should have been 54 bytes)'
fi
fi		; : end of overwriting check
echo 'x - term.h'
if test -f term.h; then echo 'shar: not overwriting term.h'; else
sed 's/^X//' << '________This_Is_The_END________' > term.h
X#define	ESCAPE		0x1b
X
X/**	Single-character printer code designations ***/
X
X#define	ROMAN		'R'	/* Restore "roman" or "regular" font */
X				/* Should turn off Bold and Italic */
X#define	ITALIC		'I'	/* Switch to italics or underline */
X#define	BOLD		'B'	/* Switch to bold */
X#define	HALFUP		'u'	/* Half-line up */
X#define	HALFDOWN	'd'	/* Half-line down */
X
X
________This_Is_The_END________
if test `wc -l < term.h` -ne 12; then
	echo 'shar: term.h was damaged during transit (should have been 12 bytes)'
fi
fi		; : end of overwriting check
echo 'x - termnull.c'
if test -f termnull.c; then echo 'shar: not overwriting termnull.c'; else
sed 's/^X//' << '________This_Is_The_END________' > termnull.c
X
X#include "stdio.h"
X#include "term.h"
X
Xchar progname[] = "termnull";
X
Xmain()
X	{
X	register int c;
X
X	while( !feof( stdin ))
X		{
X		c = getchar();
X		switch( c )
X			{
X			case ESCAPE:
X				getpc();
X				break;
X			case EOF:
X				break;
X			default:
X				putchar( c );
X				break;
X			}
X		}
X	}
X
Xgetpc()
X	{
X	register int c;
X
X	c = getchar();
X	switch( c )
X		{
X		case ROMAN:
X			roman();
X			break;
X		case ITALIC:
X			italic();
X			break;
X		case BOLD:
X			bold();
X			break;
X		case HALFUP:
X			halfup();
X			break;
X		case HALFDOWN:
X			halfdown();
X			break;
X		default:
X			fprintf( stderr, "%s:  unrecognized output escape sequence ESC-0x%x \n", progname, c );
X			break;
X		}
X	}
X
Xroman()
X	{
X	}
X
Xitalic()
X	{
X	}
X
Xbold()
X	{
X	}
X
Xhalfup()
X	{
X	}
X
Xhalfdown()
X	{
X	}
X
X
________This_Is_The_END________
if test `wc -l < termnull.c` -ne 76; then
	echo 'shar: termnull.c was damaged during transit (should have been 76 bytes)'
fi
fi		; : end of overwriting check
echo 'x - termansi.c'
if test -f termansi.c; then echo 'shar: not overwriting termansi.c'; else
sed 's/^X//' << '________This_Is_The_END________' > termansi.c
X
X#include "stdio.h"
X#include "term.h"
X
Xchar progname[] = "termansi";
X
Xmain()
X	{
X	register int c;
X
X	while( !feof( stdin ))
X		{
X		c = getchar();
X		switch( c )
X			{
X			case ESCAPE:
X				getpc();
X				break;
X			case EOF:
X				break;
X			default:
X				putchar( c );
X				break;
X			}
X		}
X	}
X
Xgetpc()
X	{
X	register int c;
X
X	c = getchar();
X	switch( c )
X		{
X		case ROMAN:
X			roman();
X			break;
X		case ITALIC:
X			italic();
X			break;
X		case BOLD:
X			bold();
X			break;
X		case HALFUP:
X			halfup();
X			break;
X		case HALFDOWN:
X			halfdown();
X			break;
X		default:
X			fprintf( stderr, "%s:  unrecognized output escape sequence ESC-0x%x \n", progname, c );
X			break;
X		}
X	}
X
Xroman()
X	{
X	printf( "\033[0m" );
X	}
X
Xitalic()
X	{
X	printf( "\033[4m" );
X	}
X
Xbold()
X	{
X	printf( "\033[1m" );
X	}
X
Xhalfup()
X	{
X	}
X
Xhalfdown()
X	{
X	}
X
X
________This_Is_The_END________
if test `wc -l < termansi.c` -ne 79; then
	echo 'shar: termansi.c was damaged during transit (should have been 79 bytes)'
fi
fi		; : end of overwriting check
echo 'x - termnx10.c'
if test -f termnx10.c; then echo 'shar: not overwriting termnx10.c'; else
sed 's/^X//' << '________This_Is_The_END________' > termnx10.c
X
X#include "stdio.h"
X#include "term.h"
X
Xchar progname[] = "termnx10";
X
Xmain()
X	{
X	register int c;
X
X	while( !feof( stdin ))
X		{
X		c = getchar();
X		switch( c )
X			{
X			case ESCAPE:
X				getpc();
X				break;
X			case EOF:
X				break;
X			default:
X				putchar( c );
X				break;
X			}
X		}
X	}
X
Xgetpc()
X	{
X	register int c;
X
X	c = getchar();
X	switch( c )
X		{
X		case ROMAN:
X			roman();
X			break;
X		case ITALIC:
X			italic();
X			break;
X		case BOLD:
X			bold();
X			break;
X		case HALFUP:
X			halfup();
X			break;
X		case HALFDOWN:
X			halfdown();
X			break;
X		default:
X			fprintf( stderr, "%s:  unrecognized output escape sequence ESC-0x%x \n", progname, c );
X			break;
X		}
X	}
X
Xroman()
X	{
X	printf( "\0335\033H" );
X	}
X
Xitalic()
X	{
X	printf( "\0334" );
X	}
X
Xbold()
X	{
X	printf( "\033G" );
X	}
X
Xhalfup()
X	{
X	printf( "\033j\022" );
X	}
X
Xhalfdown()
X	{
X	printf( "\033J\022" );
X	}
X
X
________This_Is_The_END________
if test `wc -l < termnx10.c` -ne 81; then
	echo 'shar: termnx10.c was damaged during transit (should have been 81 bytes)'
fi
fi		; : end of overwriting check
exit 0


