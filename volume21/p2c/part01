Subject:  v21i046:  Pascal to C translator, Part01/32
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: c25ae944 79ecd7e6 3bf506e0 0d07036e

Submitted-by: Dave Gillespie <daveg@csvax.caltech.edu>
Posting-number: Volume 21, Issue 46
Archive-name: p2c/part01

This is p2c a Pascal to C translator.  This is the second one in
comp.sources.unix; the first one ptoc, appeared in volume 10.

P2c understands several Pascal dialects (HP, partial Turbo, etc) and
is very flexible and configurable.

P2c was originally developed on a homebrew C compiler on the HP Pascal
Workstation operating system.  Current development takes place on HP-UX,
which is System V based.  The translator has also been compiled and used
on Sun-3's, so presumably it is fairly portable among 32-bit Unix machines.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 32)."
# Contents:  HP/import/asm.imp HP/import/general_0.imp
#   HP/import/general_1.imp HP/import/general_2.imp
#   HP/import/general_3.imp HP/import/general_4.imp
#   HP/import/hpib_0.imp HP/import/hpib_1.imp HP/import/hpib_2.imp
#   HP/import/hpib_3.imp HP/import/misc.imp HP/import/rnd.imp
#   HP/include/asm.h HP/include/general_0.h HP/include/general_1.h
#   HP/include/general_2.h HP/include/general_3.h
#   HP/include/general_4.h HP/include/hpib_0.h HP/include/hpib_1.h
#   HP/include/hpib_2.h HP/include/hpib_3.h HP/include/rnd.h MANIFEST
#   Makefile PACKNOTES README examples/Makefile examples/README
#   examples/e.p examples/fact.p examples/p2crc examples/self.p
#   src/loc.p2clib.c src/loc.p2crc src/string.pas src/system.m2
# Wrapped by rsalz@litchi.bbn.com on Mon Mar 26 14:29:24 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'HP/import/asm.imp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/import/asm.imp'\"
else
echo shar: Extracting \"'HP/import/asm.imp'\" \(1332 characters\)
sed "s/^X//" >'HP/import/asm.imp' <<'END_OF_FILE'
X
X
X{IncludeFrom=asm <p2c/asm.h>}
X
X
X{*VarStrings=1} {*ExportSymbol=asm_%s}
X
X
Xmodule asm;
Ximport sysglobals;
Xexport
Xtype
Xstringmax = string[255];
X procedure moveleft (anyvar s,d: integer; z:integer);
X procedure moveright(anyvar s,d: integer; z:integer);
X procedure fastmove (       s,d: anyptr;  z:integer);
X procedure newbytes(var p: anyptr;        z:integer);
X procedure powerup;
X procedure errmsg;
X procedure findroms;
X procedure f_pwr_on;
X procedure flpyread(sector: integer;  anyvar buffer: integer);
X procedure flpy_wrt(sector: integer;  anyvar buffer: integer);
X procedure flpymread(sector_count, sector: integer;  anyvar buffer: integer);
X procedure flpymwrite(sector_count, sector: integer;  anyvar buffer: integer);
X procedure flpyinit(ptr: anyptr; i: shortint);
X procedure setintlevel(level: integer);
X function  intlevel:  integer;
X procedure newwords(var p: anyptr; wordsize: integer);
X procedure userprogram (execloc,initsp: integer);
X procedure sappend(var dest: string;src:stringmax);
X function iand(a,b: integer): integer;
X function ior (a,b: integer): integer;
X procedure ci_switch;
X procedure initvects;
X procedure cpymsg(msg: string255);
X function memavail:integer;
X function ticker:integer;
X procedure cache_on;
X procedure cache_off;
X procedure icache_off;
X procedure icache_on;
X procedure flush_icache;
X
X
Xend.
X
X
X
END_OF_FILE
if test 1332 -ne `wc -c <'HP/import/asm.imp'`; then
    echo shar: \"'HP/import/asm.imp'\" unpacked with wrong size!
fi
# end of 'HP/import/asm.imp'
fi
if test -f 'HP/import/general_0.imp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/import/general_0.imp'\"
else
echo shar: Extracting \"'HP/import/general_0.imp'\" \(940 characters\)
sed "s/^X//" >'HP/import/general_0.imp' <<'END_OF_FILE'
X
X
X{IncludeFrom=general_0 <p2c/general_0.h>}
X
X
X{*VarStrings=0} {*ExportSymbol=P_%s} {*Export_Symbol=%s}
X
X
XMODULE GENERAL_0;
XIMPORT  iodeclarations; 
X
XEXPORT
X
X   VAR
X      kbd_crt_drivers : drv_table_type;
X      dummy_drivers   : drv_table_type;
X
X   FUNCTION  ioread_word ( select_code: type_isc ; register   : io_word ): io_word ;
X   PROCEDURE iowrite_word( select_code: type_isc ; register   : io_word ;
X                           value      : io_word);
X   FUNCTION  ioread_byte ( select_code: type_isc ; register   : io_word ): io_byte ;
X   PROCEDURE iowrite_byte( select_code: type_isc ; register   : io_word ;
X                           value      : io_byte);
X   FUNCTION  iostatus    ( select_code: type_isc ; register   : io_word ): io_word ;
X   PROCEDURE iocontrol   ( select_code: type_isc ; register   : io_word ;
X                           value      : io_word);
X   PROCEDURE kernel_initialize;
X   PROCEDURE io_system_reset;
Xend.
X
END_OF_FILE
if test 940 -ne `wc -c <'HP/import/general_0.imp'`; then
    echo shar: \"'HP/import/general_0.imp'\" unpacked with wrong size!
fi
# end of 'HP/import/general_0.imp'
fi
if test -f 'HP/import/general_1.imp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/import/general_1.imp'\"
else
echo shar: Extracting \"'HP/import/general_1.imp'\" \(646 characters\)
sed "s/^X//" >'HP/import/general_1.imp' <<'END_OF_FILE'
X
X
X{IncludeFrom=general_1 <p2c/general_1.h>}
X
X
X{*VarStrings=0} {*ExportSymbol=P_%s} {*Export_Symbol=%s}
X
X
XMODULE GENERAL_1;
X
XIMPORT
X   iodeclarations;
X
XEXPORT
X
X   PROCEDURE ioinitialize;
X   PROCEDURE iouninitialize;
X   PROCEDURE ioreset     ( select_code : type_isc);
X   PROCEDURE readchar    ( select_code : type_isc ; VAR value   : CHAR );
X   PROCEDURE writechar   ( select_code : type_isc ; value       : CHAR );
X   PROCEDURE readword    ( select_code : type_isc ; VAR num     : INTEGER);
X   PROCEDURE writeword   ( select_code : type_isc ; value       : INTEGER);
X   PROCEDURE set_timeout ( select_code : type_isc ; time        : REAL);
XEND.
X
END_OF_FILE
if test 646 -ne `wc -c <'HP/import/general_1.imp'`; then
    echo shar: \"'HP/import/general_1.imp'\" unpacked with wrong size!
fi
# end of 'HP/import/general_1.imp'
fi
if test -f 'HP/import/general_2.imp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/import/general_2.imp'\"
else
echo shar: Extracting \"'HP/import/general_2.imp'\" \(911 characters\)
sed "s/^X//" >'HP/import/general_2.imp' <<'END_OF_FILE'
X
X
X{IncludeFrom=general_2 <p2c/general_2.h>}
X
X
X{*VarStrings=0} {*ExportSymbol=P_%s} {*Export_Symbol=%s}
X
X
XMODULE GENERAL_2;
XIMPORT    iodeclarations;  
X
XEXPORT
X
X   PROCEDURE readnumber ( device : type_device ; VAR num: REAL ) ;
X   PROCEDURE writenumber ( device : type_device ; value  : REAL ) ;
X   PROCEDURE readstring ( device : type_device ; VAR str: STRING ) ;
X   PROCEDURE readstring_until ( term   : CHAR ; device : type_device ;
X                                VAR str: STRING );
X   PROCEDURE writestring ( device : type_device ; str    : io_STRING ) ;
X   PROCEDURE readnumberln ( device : type_device ; VAR num: REAL );
X   PROCEDURE writenumberln ( device : type_device ; value  : REAL );
X   PROCEDURE writestringln ( device : type_device ; str    : io_STRING );
X   PROCEDURE readuntil  ( term   : CHAR ; device : type_device );
X   PROCEDURE skipfor    ( count  : INTEGER ; device : type_device );
XEND.
X
END_OF_FILE
if test 911 -ne `wc -c <'HP/import/general_2.imp'`; then
    echo shar: \"'HP/import/general_2.imp'\" unpacked with wrong size!
fi
# end of 'HP/import/general_2.imp'
fi
if test -f 'HP/import/general_3.imp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/import/general_3.imp'\"
else
echo shar: Extracting \"'HP/import/general_3.imp'\" \(232 characters\)
sed "s/^X//" >'HP/import/general_3.imp' <<'END_OF_FILE'
X
X
X{IncludeFrom=general_3 <p2c/general_3.h>}
X
X
X{*VarStrings=0} {*ExportSymbol=P_%s} {*Export_Symbol=%s}
X
X
XMODULE GENERAL_3;
XIMPORT    iodeclarations ;  
X
XEXPORT
X
X   FUNCTION  ioerror_message ( ioerror : INTEGER )  : io_STRING;
XEND.
X
END_OF_FILE
if test 232 -ne `wc -c <'HP/import/general_3.imp'`; then
    echo shar: \"'HP/import/general_3.imp'\" unpacked with wrong size!
fi
# end of 'HP/import/general_3.imp'
fi
if test -f 'HP/import/general_4.imp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/import/general_4.imp'\"
else
echo shar: Extracting \"'HP/import/general_4.imp'\" \(1992 characters\)
sed "s/^X//" >'HP/import/general_4.imp' <<'END_OF_FILE'
X
X
X{IncludeFrom=general_4 <p2c/general_4.h>}
X
X
X{*VarStrings=0} {*ExportSymbol=P_%s} {*Export_Symbol=%s}
X
X
Xmodule general_4;
Ximport    iodeclarations ;
X
Xexport
X
X   procedure abort_transfer ( var b_info: buf_info_type );
X   function  transfer_setup ( device    : type_device; t_tfr     : user_tfr_type;
X                              t_dir     : dir_of_tfr ; var b_info: buf_info_type ;
X                              t_cnt : integer ): type_isc ;
X   procedure transfer   ( device    : type_device; t_tfr     : user_tfr_type;
X                          t_dir     : dir_of_tfr ; var b_info: buf_info_type;
X                          x_count   : integer ) ;
X   procedure transfer_word ( device    : type_device; t_tfr     : user_tfr_type;
X                             t_dir     : dir_of_tfr ; var b_info: buf_info_type;
X                             x_count   : integer ) ;
X   procedure transfer_until ( term      : char ; device    : type_device;
X                              t_tfr     : user_tfr_type; t_dir     : dir_of_tfr;
X                              var b_info: buf_info_type ) ;
X   procedure transfer_end ( device    : type_device; t_tfr     : user_tfr_type;
X                            t_dir     : dir_of_tfr; var b_info: buf_info_type ) ;
X   procedure iobuffer   ( var b_info: buf_info_type ; t_count   : integer );
X   procedure buffer_reset(var b_info: buf_info_type ) ;
X   function  buffer_space( var b_info: buf_info_type): integer;
X   function  buffer_data( var b_info: buf_info_type): integer;
X   procedure readbuffer ( var b_info: buf_info_type; var value : char);
X   procedure writebuffer( var b_info: buf_info_type; value     : char);
X   procedure readbuffer_string( var b_info: buf_info_type; var str   : string;
X                                str_count : integer);
X   procedure writebuffer_string ( var b_info: buf_info_type; str       : io_string);
X   function  buffer_busy( var b_info: buf_info_type ): boolean;
X   function  isc_busy   ( isc       : type_isc ): boolean;
Xend.
X
END_OF_FILE
if test 1992 -ne `wc -c <'HP/import/general_4.imp'`; then
    echo shar: \"'HP/import/general_4.imp'\" unpacked with wrong size!
fi
# end of 'HP/import/general_4.imp'
fi
if test -f 'HP/import/hpib_0.imp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/import/hpib_0.imp'\"
else
echo shar: Extracting \"'HP/import/hpib_0.imp'\" \(775 characters\)
sed "s/^X//" >'HP/import/hpib_0.imp' <<'END_OF_FILE'
X
X
X{IncludeFrom=hpib_0 <p2c/hpib_0.h>}
X
X
X{*VarStrings=0} {*ExportSymbol=P_%s} {*Export_Symbol=%s}
X
X
XMODULE hpib_0 ;        
X
X        { by      Tim Mikkelsen
X          date    07/17/81
X          update  09/17/81
X          
X          purpose This module contains the LEVEL 0 HPIB GROUP procedures.   
X                
X        }
X
X
XIMPORT    iodeclarations ;  
X        
X        
XEXPORT
X  
X        
X  PROCEDURE set_hpib    ( select_code : type_isc ;
X                          line        : type_hpib_line);
X  PROCEDURE clear_hpib  ( select_code : type_isc ;
X                          line        : type_hpib_line);
X  FUNCTION  hpib_line   ( select_code : type_isc ;
X                          line        : type_hpib_line)
X                        : BOOLEAN;
X
XEND.    { of hpib_0 }
X
END_OF_FILE
if test 775 -ne `wc -c <'HP/import/hpib_0.imp'`; then
    echo shar: \"'HP/import/hpib_0.imp'\" unpacked with wrong size!
fi
# end of 'HP/import/hpib_0.imp'
fi
if test -f 'HP/import/hpib_1.imp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/import/hpib_1.imp'\"
else
echo shar: Extracting \"'HP/import/hpib_1.imp'\" \(1359 characters\)
sed "s/^X//" >'HP/import/hpib_1.imp' <<'END_OF_FILE'
X
X
X{IncludeFrom=hpib_1 <p2c/hpib_1.h>}
X
X
X{*VarStrings=0} {*ExportSymbol=P_%s} {*Export_Symbol=%s}
X
X
XMODULE hpib_1 ;        
X
X        { by      Tim Mikkelsen
X          date    07/16/81
X          update  08/03/83 by J Schmidt
X          
X          purpose This module contains the LEVEL 1 HPIB GROUP procedures.   
X                
X        }
X
X
XIMPORT    iodeclarations ;  
X  
XEXPORT
X  
X                          
X  PROCEDURE send_command( select_code : type_isc ;
X                          command     : CHAR );
X  FUNCTION  my_address  ( select_code : type_isc)
X                        : type_hpib_addr ;
X  FUNCTION  active_controller
X                        ( select_code : type_isc)
X                        : BOOLEAN;
X  FUNCTION  system_controller
X                        ( select_code : type_isc)
X                        : BOOLEAN;
X  FUNCTION  addr_to_talk( device      : type_device)
X                        : type_isc;
X  FUNCTION  addr_to_listen
X                        ( device      : type_device)
X                        : type_isc;
X  FUNCTION  set_to_talk ( device      : type_device)
X                        : type_isc;
X  FUNCTION  set_to_listen 
X                        ( device      : type_device)
X                        : type_isc;
X  FUNCTION  end_set     ( select_code : type_isc )
X                        : BOOLEAN;
X  
X  
X  
XEND.    { of hpib_1 }
X
END_OF_FILE
if test 1359 -ne `wc -c <'HP/import/hpib_1.imp'`; then
    echo shar: \"'HP/import/hpib_1.imp'\" unpacked with wrong size!
fi
# end of 'HP/import/hpib_1.imp'
fi
if test -f 'HP/import/hpib_2.imp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/import/hpib_2.imp'\"
else
echo shar: Extracting \"'HP/import/hpib_2.imp'\" \(1489 characters\)
sed "s/^X//" >'HP/import/hpib_2.imp' <<'END_OF_FILE'
X
X
X{IncludeFrom=hpib_2 <p2c/hpib_2.h>}
X
X
X{*VarStrings=0} {*ExportSymbol=P_%s} {*Export_Symbol=%s}
X
X
XMODULE hpib_2 ;        
X
X        { by      Tim Mikkelsen
X          date    07/17/81
X          update  03/09/83
X          
X          purpose This module contains the LEVEL 
X                  2 HPIB GROUP procedures.   
X                
X        }
X
X
XIMPORT  iodeclarations ;  
X  
XEXPORT
X  
X                          
X  PROCEDURE abort_hpib
X                    ( select_code : type_isc);
X  PROCEDURE clear   ( device      : type_device);
X  PROCEDURE listen  ( select_code : type_isc ;   
X                      address     : type_hpib_addr );
X  PROCEDURE local   ( device      : type_device);
X  PROCEDURE local_lockout
X                    ( select_code : type_isc);
X  PROCEDURE pass_control
X                    ( device      : type_device);
X  PROCEDURE ppoll_configure
X                    ( device      : type_device;
X                      mask        : INTEGER );
X  PROCEDURE ppoll_unconfigure
X                    ( device      : type_device);
X  PROCEDURE remote  ( device      : type_device);
X  PROCEDURE secondary
X                    ( select_code : type_isc ;
X                      address     : type_hpib_addr );
X  PROCEDURE talk    ( select_code : type_isc ;
X                      address     : type_hpib_addr );
X  PROCEDURE trigger ( device      : type_device);
X  PROCEDURE unlisten( select_code : type_isc );
X  PROCEDURE untalk  ( select_code : type_isc );
X  
X  
X
XEND.    { of hpib_2 }
X
END_OF_FILE
if test 1489 -ne `wc -c <'HP/import/hpib_2.imp'`; then
    echo shar: \"'HP/import/hpib_2.imp'\" unpacked with wrong size!
fi
# end of 'HP/import/hpib_2.imp'
fi
if test -f 'HP/import/hpib_3.imp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/import/hpib_3.imp'\"
else
echo shar: Extracting \"'HP/import/hpib_3.imp'\" \(1178 characters\)
sed "s/^X//" >'HP/import/hpib_3.imp' <<'END_OF_FILE'
X
X
X{IncludeFrom=hpib_3 <p2c/hpib_3.h>}
X
X
X{*VarStrings=0} {*ExportSymbol=P_%s} {*Export_Symbol=%s}
X
X
XMODULE hpib_3 ;        
X
X        { by      Tim Mikkelsen
X          date    07/17/81
X          update  01/08/82
X          
X          purpose This module contains the LEVEL 
X                  3 HPIB GROUP procedures.   
X                
X        }
X
X
XIMPORT    iodeclarations ;  
X  
XEXPORT
X  
X                          
X  FUNCTION  requested
X                    ( select_code : type_isc )
X                    : BOOLEAN ;
X  FUNCTION  ppoll   ( select_code : type_isc )
X                    : INTEGER ;
X  FUNCTION  spoll   ( device      : type_device)
X                    : INTEGER ;   
X  
X  PROCEDURE request_service 
X                    ( select_code : type_isc ;
X                      response    : INTEGER );
X  FUNCTION  listener( select_code : type_isc )
X                    : BOOLEAN;
X  FUNCTION  talker  ( select_code : type_isc )   
X                    : BOOLEAN ;
X  FUNCTION  remoted ( select_code : type_isc )
X                    : BOOLEAN ;
X  FUNCTION  locked_out
X                    ( select_code : type_isc )
X                    : BOOLEAN ;
X  
X  
X  
XEND.    { of hpib_3 }
X
END_OF_FILE
if test 1178 -ne `wc -c <'HP/import/hpib_3.imp'`; then
    echo shar: \"'HP/import/hpib_3.imp'\" unpacked with wrong size!
fi
# end of 'HP/import/hpib_3.imp'
fi
if test -f 'HP/import/misc.imp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/import/misc.imp'\"
else
echo shar: Extracting \"'HP/import/misc.imp'\" \(2478 characters\)
sed "s/^X//" >'HP/import/misc.imp' <<'END_OF_FILE'
X
X
X{IncludeFrom=misc <p2c/misc.h>}
X
X
X{*VarStrings=0} {*ExportSymbol=misc_%s}
X
X
Xmodule misc;    {homeless orphans}
X
Ximport sysglobals, asm; 
X
Xexport
X
Xconst
X  
X  null  = 0;    nullchar  = chr(0);
X                homechar  = chr(1); 
X  etx   = 3; 
X  bell  = 7;    bellchar  = chr(7); 
X  bs    = 8;    leftchar  = chr(8); 
X  tab   = 9;    cteol     = chr(9); 
X  lf    = 10;   downchar  = chr(10); 
X  vt    = 11;   cteos     = chr(11); 
X  ff    = 12;   clearscr  = chr(12); 
X  cr    = 13;   eol       = chr(13); 
X  dle   = 16;     
X  esc   = 27;   escchar   = chr(27);
X  fsp   = 28;   rightchar = chr(28);
X  us    = 31;   upchar    = chr(31); 
X  del   = 127;
X  cntrl = 255; 
X
Xtype 
X(* CATALOGUE INFORMATION, zero entry refers to the directory itself *)
X  
X  catentry = record
X    cname:  tid;                {name of file or directory}
X    ceft:   shortint;           {external file type (LIF)}
X    ckind:  filekind;           {file kind}
X    cpsize: integer;            {physical size of file 
X                                        or of total data space on volume}
X    clsize: integer;            {logical size of file 
X                                        or unused space on medium}
X    cstart: integer;            {starting location of file 
X                                        or first possible data location}
X    cblocksize: integer;        {size of a sector or block}
X    ccreatedate, clastdate:  daterec;   {creation, last modified dates}
X    ccreatetime, clasttime:  timerec;   {creation, last modified times}
X    cextra1,                    {extension 
X                                        or total possible number of files
X                                        or requested number of files}
X    cextra2:   integer;         {secondary discretionary field
X                                        or start index of requested catalog}
X    cinfo:  string[20];         {comment or miscellaneous information}
X    
X    end; 
X    
X    passentry = record
X                 pbits: integer; 
X                 pword: passtype; 
X                 end; 
X    
Xvar
X  idle: byte;              { idle character -- 3.0 bug jws 3/20/84 }
X  
Xprocedure getioerrmsg(var s :string; lastior : integer);
Xprocedure printerror(errorcode, lastior: integer); 
Xprocedure upc(var s: string); 
Xfunction ueovbytes(unit: unitnum): integer;
Xprocedure unblockeddam(anyvar f: fib; unum: unitnum; request: damrequesttype); 
Xprocedure initfilekinds;
Xprocedure lockup; 
Xprocedure lockdown; 
X  
X
Xend.
X
X
X
END_OF_FILE
if test 2478 -ne `wc -c <'HP/import/misc.imp'`; then
    echo shar: \"'HP/import/misc.imp'\" unpacked with wrong size!
fi
# end of 'HP/import/misc.imp'
fi
if test -f 'HP/import/rnd.imp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/import/rnd.imp'\"
else
echo shar: Extracting \"'HP/import/rnd.imp'\" \(210 characters\)
sed "s/^X//" >'HP/import/rnd.imp' <<'END_OF_FILE'
X
X
X{IncludeFrom=misc <p2c/rnd.h>}
X
X
X{*ExportSymbol=P_%s}
X
X
Xmodule rnd;
X
Ximport sysglobals; 
X
Xexport
X
X
Xprocedure random(var seed : integer);
Xfunction rand(var seed : integer; max : integer) : integer;
X
X
Xend.
X
X  
END_OF_FILE
if test 210 -ne `wc -c <'HP/import/rnd.imp'`; then
    echo shar: \"'HP/import/rnd.imp'\" unpacked with wrong size!
fi
# end of 'HP/import/rnd.imp'
fi
if test -f 'HP/include/asm.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/include/asm.h'\"
else
echo shar: Extracting \"'HP/include/asm.h'\" \(1663 characters\)
sed "s/^X//" >'HP/include/asm.h' <<'END_OF_FILE'
X/* Header for module asm, generated by p2c */
X#ifndef ASM_H
X#define ASM_H
X
X
X
X#ifndef SYSGLOBALS_H
X#include <p2c/sysglobals.h>
X#endif
X
X
X
X#ifdef ASM_G
X# define vextern
X#else
X# define vextern extern
X#endif
X
X
X
Xextern Void asm_moveleft PP((long *s, long *d, long z));
Xextern Void asm_moveright PP((long *s, long *d, long z));
Xextern Void asm_fastmove PP((Anyptr *s, Anyptr *d, long z));
Xextern Void asm_newbytes PP((Anyptr **p, long z));
Xextern Void asm_powerup PV( );
Xextern Void asm_errmsg PV( );
Xextern Void asm_findroms PV( );
Xextern Void asm_f_pwr_on PV( );
Xextern Void asm_flpyread PP((long sector, long *buffer));
Xextern Void asm_flpy_wrt PP((long sector, long *buffer));
Xextern Void asm_flpymread PP((long sector_count, long sector, long *buffer));
Xextern Void asm_flpymwrite PP((long sector_count, long sector, long *buffer));
Xextern Void asm_flpyinit PP((Anyptr *ptr, int i));
Xextern Void asm_setintlevel PP((long level));
Xextern long asm_intlevel PV( );
Xextern Void asm_newwords PP((Anyptr **p, long wordsize));
Xextern Void asm_userprogram PP((long execloc, long initsp));
Xextern Void asm_sappend PP((Char *dest, int MAX_dest, Char *src));
Xextern long asm_iand PP((long a, long b));
Xextern long asm_ior PP((long a, long b));
Xextern Void asm_ci_switch PV( );
Xextern Void asm_initvects PV( );
Xextern Void asm_cpymsg PP((Char *msg));
X#define asm_memavail()        10000000
X/*  extern long asm_memavail PV( );  */
Xextern long asm_ticker PV( );
Xextern Void asm_cache_on PV( );
Xextern Void asm_cache_off PV( );
Xextern Void asm_icache_off PV( );
Xextern Void asm_icache_on PV( );
Xextern Void asm_flush_icache PV( );
X
X
X
X#undef vextern
X
X#endif /*ASM_H*/
X
X/* End. */
X
END_OF_FILE
if test 1663 -ne `wc -c <'HP/include/asm.h'`; then
    echo shar: \"'HP/include/asm.h'\" unpacked with wrong size!
fi
# end of 'HP/include/asm.h'
fi
if test -f 'HP/include/general_0.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/include/general_0.h'\"
else
echo shar: Extracting \"'HP/include/general_0.h'\" \(824 characters\)
sed "s/^X//" >'HP/include/general_0.h' <<'END_OF_FILE'
X/* Header for module GENERAL_0, generated by p2c */
X#ifndef GENERAL_0_H
X#define GENERAL_0_H
X
X
X
X#ifndef IODECLARATIONS_H
X#include <p2c/iodecl.h>
X#endif
X
X
X
X#ifdef GENERAL_0_G
X# define vextern
X#else
X# define vextern extern
X#endif
X
X
X
Xvextern drv_table_type kbd_crt_drivers, dummy_drivers;
X
X
X
Xextern short ioread_word PP((int select_code, int register_));
Xextern Void iowrite_word PP((int select_code, int register_, int value));
Xextern uchar ioread_byte PP((int select_code, int register_));
Xextern Void iowrite_byte PP((int select_code, int register_, int value));
Xextern short P_iostatus PP((int select_code, int register_));
Xextern Void P_iocontrol PP((int select_code, int register_, int value));
Xextern Void kernel_initialize PV( );
Xextern Void io_system_reset PV( );
X
X
X
X#undef vextern
X
X#endif /*GENERAL_0_H*/
X
X/* End. */
X
END_OF_FILE
if test 824 -ne `wc -c <'HP/include/general_0.h'`; then
    echo shar: \"'HP/include/general_0.h'\" unpacked with wrong size!
fi
# end of 'HP/include/general_0.h'
fi
if test -f 'HP/include/general_1.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/include/general_1.h'\"
else
echo shar: Extracting \"'HP/include/general_1.h'\" \(690 characters\)
sed "s/^X//" >'HP/include/general_1.h' <<'END_OF_FILE'
X/* Header for module GENERAL_1, generated by p2c */
X#ifndef GENERAL_1_H
X#define GENERAL_1_H
X
X
X
X#ifndef IODECLARATIONS_H
X#include <p2c/iodecl.h>
X#endif
X
X
X
X#ifdef GENERAL_1_G
X# define vextern
X#else
X# define vextern extern
X#endif
Xextern Void P_ioinitialize PV( );
Xextern Void P_iouninitialize PV( );
Xextern Void P_ioreset PP((int select_code));
Xextern Void P_readchar PP((int select_code, Char *value));
Xextern Void P_writechar PP((int select_code, int value));
Xextern Void P_readword PP((int select_code, long *num));
Xextern Void P_writeword PP((int select_code, long value));
Xextern Void set_timeout PP((int select_code, double time));
X
X
X
X#undef vextern
X
X#endif /*GENERAL_1_H*/
X
X/* End. */
X
END_OF_FILE
if test 690 -ne `wc -c <'HP/include/general_1.h'`; then
    echo shar: \"'HP/include/general_1.h'\" unpacked with wrong size!
fi
# end of 'HP/include/general_1.h'
fi
if test -f 'HP/include/general_2.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/include/general_2.h'\"
else
echo shar: Extracting \"'HP/include/general_2.h'\" \(862 characters\)
sed "s/^X//" >'HP/include/general_2.h' <<'END_OF_FILE'
X/* Header for module GENERAL_2, generated by p2c */
X#ifndef GENERAL_2_H
X#define GENERAL_2_H
X
X
X
X#ifndef IODECLARATIONS_H
X#include <p2c/iodecl.h>
X#endif
X
X
X
X#ifdef GENERAL_2_G
X# define vextern
X#else
X# define vextern extern
X#endif
Xextern Void P_readnumber PP((long device, double *num));
Xextern Void P_writenumber PP((long device, double value));
Xextern Void P_readstring PP((long device, Char *str));
Xextern Void readstring_until PP((int term, long device, Char *str));
Xextern Void P_writestring PP((long device, Char *str));
Xextern Void P_readnumberln PP((long device, double *num));
Xextern Void P_writenumberln PP((long device, double value));
Xextern Void P_writestringln PP((long device, Char *str));
Xextern Void P_readuntil PP((int term, long device));
Xextern Void P_skipfor PP((long count, long device));
X
X
X
X#undef vextern
X
X#endif /*GENERAL_2_H*/
X
X/* End. */
X
END_OF_FILE
if test 862 -ne `wc -c <'HP/include/general_2.h'`; then
    echo shar: \"'HP/include/general_2.h'\" unpacked with wrong size!
fi
# end of 'HP/include/general_2.h'
fi
if test -f 'HP/include/general_3.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/include/general_3.h'\"
else
echo shar: Extracting \"'HP/include/general_3.h'\" \(347 characters\)
sed "s/^X//" >'HP/include/general_3.h' <<'END_OF_FILE'
X/* Header for module GENERAL_3, generated by p2c */
X#ifndef GENERAL_3_H
X#define GENERAL_3_H
X
X
X
X#ifndef IODECLARATIONS_H
X#include <p2c/iodecl.h>
X#endif
X
X
X
X#ifdef GENERAL_3_G
X# define vextern
X#else
X# define vextern extern
X#endif
Xextern Char *ioerror_message PP((Char *P_Result, long ioerror));
X
X
X
X#undef vextern
X
X#endif /*GENERAL_3_H*/
X
X/* End. */
X
END_OF_FILE
if test 347 -ne `wc -c <'HP/include/general_3.h'`; then
    echo shar: \"'HP/include/general_3.h'\" unpacked with wrong size!
fi
# end of 'HP/include/general_3.h'
fi
if test -f 'HP/include/general_4.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/include/general_4.h'\"
else
echo shar: Extracting \"'HP/include/general_4.h'\" \(1497 characters\)
sed "s/^X//" >'HP/include/general_4.h' <<'END_OF_FILE'
X/* Header for module general_4, generated by p2c */
X#ifndef GENERAL_4_H
X#define GENERAL_4_H
X
X
X
X#ifndef IODECLARATIONS_H
X#include <p2c/iodecl.h>
X#endif
X
X
X
X#ifdef GENERAL_4_G
X# define vextern
X#else
X# define vextern extern
X#endif
Xextern Void abort_transfer PP((buf_info_type *b_info));
Xextern char transfer_setup PP((long device, int t_tfr, int t_dir,
X			       buf_info_type *b_info, long t_cnt));
Xextern Void P_transfer PP((long device, int t_tfr, int t_dir,
X			   buf_info_type *b_info, long x_count));
Xextern Void transfer_word PP((long device, int t_tfr, int t_dir,
X			      buf_info_type *b_info, long x_count));
Xextern Void transfer_until PP((int term, long device, int t_tfr, int t_dir,
X			       buf_info_type *b_info));
Xextern Void transfer_end PP((long device, int t_tfr, int t_dir,
X			     buf_info_type *b_info));
Xextern Void P_iobuffer PP((buf_info_type *b_info, long t_count));
Xextern Void buffer_reset PP((buf_info_type *b_info));
Xextern long buffer_space PP((buf_info_type *b_info));
Xextern long buffer_data PP((buf_info_type *b_info));
Xextern Void P_readbuffer PP((buf_info_type *b_info, Char *value));
Xextern Void P_writebuffer PP((buf_info_type *b_info, int value));
Xextern Void readbuffer_string PP((buf_info_type *b_info, Char *str,
X				  long str_count));
Xextern Void writebuffer_string PP((buf_info_type *b_info, Char *str));
Xextern boolean buffer_busy PP((buf_info_type *b_info));
Xextern boolean isc_busy PP((int isc));
X
X
X
X#undef vextern
X
X#endif /*GENERAL_4_H*/
X
X/* End. */
X
END_OF_FILE
if test 1497 -ne `wc -c <'HP/include/general_4.h'`; then
    echo shar: \"'HP/include/general_4.h'\" unpacked with wrong size!
fi
# end of 'HP/include/general_4.h'
fi
if test -f 'HP/include/hpib_0.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/include/hpib_0.h'\"
else
echo shar: Extracting \"'HP/include/hpib_0.h'\" \(435 characters\)
sed "s/^X//" >'HP/include/hpib_0.h' <<'END_OF_FILE'
X/* Header for module hpib_0, generated by p2c */
X#ifndef HPIB_0_H
X#define HPIB_0_H
X
X
X
X#ifndef IODECLARATIONS_H
X#include <p2c/iodecl.h>
X#endif
X
X
X
X#ifdef HPIB_0_G
X# define vextern
X#else
X# define vextern extern
X#endif
Xextern Void set_hpib PP((int select_code, int line));
Xextern Void clear_hpib PP((int select_code, int line));
Xextern boolean hpib_line PP((int select_code, int line));
X
X
X
X#undef vextern
X
X#endif /*HPIB_0_H*/
X
X/* End. */
X
END_OF_FILE
if test 435 -ne `wc -c <'HP/include/hpib_0.h'`; then
    echo shar: \"'HP/include/hpib_0.h'\" unpacked with wrong size!
fi
# end of 'HP/include/hpib_0.h'
fi
if test -f 'HP/include/hpib_1.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/include/hpib_1.h'\"
else
echo shar: Extracting \"'HP/include/hpib_1.h'\" \(710 characters\)
sed "s/^X//" >'HP/include/hpib_1.h' <<'END_OF_FILE'
X/* Header for module hpib_1, generated by p2c */
X#ifndef HPIB_1_H
X#define HPIB_1_H
X
X
X
X#ifndef IODECLARATIONS_H
X#include <p2c/iodecl.h>
X#endif
X
X
X
X#ifdef HPIB_1_G
X# define vextern
X#else
X# define vextern extern
X#endif
Xextern Void send_command PP((int select_code, int command));
Xextern char my_address PP((int select_code));
Xextern boolean active_controller PP((int select_code));
Xextern boolean system_controller PP((int select_code));
Xextern char addr_to_talk PP((long device));
Xextern char addr_to_listen PP((long device));
Xextern char set_to_talk PP((long device));
Xextern char set_to_listen PP((long device));
Xextern boolean end_set PP((int select_code));
X
X
X
X#undef vextern
X
X#endif /*HPIB_1_H*/
X
X/* End. */
X
END_OF_FILE
if test 710 -ne `wc -c <'HP/include/hpib_1.h'`; then
    echo shar: \"'HP/include/hpib_1.h'\" unpacked with wrong size!
fi
# end of 'HP/include/hpib_1.h'
fi
if test -f 'HP/include/hpib_2.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/include/hpib_2.h'\"
else
echo shar: Extracting \"'HP/include/hpib_2.h'\" \(934 characters\)
sed "s/^X//" >'HP/include/hpib_2.h' <<'END_OF_FILE'
X/* Header for module hpib_2, generated by p2c */
X#ifndef HPIB_2_H
X#define HPIB_2_H
X
X
X
X#ifndef IODECLARATIONS_H
X#include <p2c/iodecl.h>
X#endif
X
X
X
X#ifdef HPIB_2_G
X# define vextern
X#else
X# define vextern extern
X#endif
Xextern Void abort_hpib PP((int select_code));
Xextern Void P_clear PP((long device));
Xextern Void P_listen PP((int select_code, int address));
Xextern Void P_local PP((long device));
Xextern Void local_lockout PP((int select_code));
Xextern Void pass_control PP((long device));
Xextern Void ppoll_configure PP((long device, long mask));
Xextern Void ppoll_unconfigure PP((long device));
Xextern Void P_remote PP((long device));
Xextern Void P_secondary PP((int select_code, int address));
Xextern Void P_talk PP((int select_code, int address));
Xextern Void P_trigger PP((long device));
Xextern Void P_unlisten PP((int select_code));
Xextern Void P_untalk PP((int select_code));
X
X
X
X#undef vextern
X
X#endif /*HPIB_2_H*/
X
X/* End. */
X
END_OF_FILE
if test 934 -ne `wc -c <'HP/include/hpib_2.h'`; then
    echo shar: \"'HP/include/hpib_2.h'\" unpacked with wrong size!
fi
# end of 'HP/include/hpib_2.h'
fi
if test -f 'HP/include/hpib_3.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/include/hpib_3.h'\"
else
echo shar: Extracting \"'HP/include/hpib_3.h'\" \(658 characters\)
sed "s/^X//" >'HP/include/hpib_3.h' <<'END_OF_FILE'
X/* Header for module hpib_3, generated by p2c */
X#ifndef HPIB_3_H
X#define HPIB_3_H
X
X
X
X#ifndef IODECLARATIONS_H
X#include <p2c/iodecl.h>
X#endif
X
X
X
X#ifdef HPIB_3_G
X# define vextern
X#else
X# define vextern extern
X#endif
Xextern boolean P_requested PP((int select_code));
Xextern long P_ppoll PP((int select_code));
Xextern long P_spoll PP((long device));
Xextern Void request_service PP((int select_code, long response));
Xextern boolean P_listener PP((int select_code));
Xextern boolean P_talker PP((int select_code));
Xextern boolean P_remoted PP((int select_code));
Xextern boolean locked_out PP((int select_code));
X
X
X
X#undef vextern
X
X#endif /*HPIB_3_H*/
X
X/* End. */
X
END_OF_FILE
if test 658 -ne `wc -c <'HP/include/hpib_3.h'`; then
    echo shar: \"'HP/include/hpib_3.h'\" unpacked with wrong size!
fi
# end of 'HP/include/hpib_3.h'
fi
if test -f 'HP/include/rnd.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/include/rnd.h'\"
else
echo shar: Extracting \"'HP/include/rnd.h'\" \(160 characters\)
sed "s/^X//" >'HP/include/rnd.h' <<'END_OF_FILE'
X#ifndef RND_H
X#define RND_H
X
X#ifdef RND_G
X# define vextern
X#else
X# define vextern extern
X#endif
X
X
Xextern void P_random();
Xextern long P_rand();
X
X
X
X#endif RND_H
END_OF_FILE
if test 160 -ne `wc -c <'HP/include/rnd.h'`; then
    echo shar: \"'HP/include/rnd.h'\" unpacked with wrong size!
fi
# end of 'HP/include/rnd.h'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(3100 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X HP/import/asm.imp          1	
X HP/import/fs.imp           2	
X HP/import/general_0.imp    1	
X HP/import/general_1.imp    1	
X HP/import/general_2.imp    1	
X HP/import/general_3.imp    1	
X HP/import/general_4.imp    1	
X HP/import/hpib_0.imp       1	
X HP/import/hpib_1.imp       1	
X HP/import/hpib_2.imp       1	
X HP/import/hpib_3.imp       1	
X HP/import/iodecl.imp       4	
X HP/import/misc.imp         1	
X HP/import/rnd.imp          1	
X HP/import/sysdevs.imp      6	
X HP/import/sysglobals.imp   5	
X HP/include/asm.h           1	
X HP/include/fs.h            2	
X HP/include/general_0.h     1	
X HP/include/general_1.h     1	
X HP/include/general_2.h     1	
X HP/include/general_3.h     1	
X HP/include/general_4.h     1	
X HP/include/hpib_0.h        1	
X HP/include/hpib_1.h        1	
X HP/include/hpib_2.h        1	
X HP/include/hpib_3.h        1	
X HP/include/iodecl.h        2	
X HP/include/misc.h          2	
X HP/include/rnd.h           1	
X HP/include/sysdevs.h       4	
X HP/include/sysglobals.h    3	
X MANIFEST                   1	
X Makefile                   1	
X PACKNOTES                  1	Warnings about long lines, etc
X README                     1	
X examples/Makefile          1	
X examples/README            1	
X examples/basic.doc         4	
X examples/basic.p.1        19	(part 1)
X examples/basic.p.2         7	(part 2)
X examples/cref.p            4	
X examples/e.p               1	
X examples/fact.p            1	
X examples/p2crc             1	
X examples/self.p            1	
X src/COPYING                5	
X src/HISTORY                7	
X src/INSTALL                2	
X src/Makefile               2	
X src/NOTES                 11	
X src/README                 2	
X src/citmods.c             10	
X src/comment.c              3	
X src/decl.c.1              28	(part 1)
X src/decl.c.2              27	(part 2)
X src/decl.c.3              14	(part 3)
X src/dir.c                  2	
X src/expr.c.1              26	(part 1)
X src/expr.c.2              25	(part 2)
X src/expr.c.3              16	(part 3)
X src/funcs.c.1             21	(part 1)
X src/funcs.c.2             22	(part 2)
X src/funcs.c.3             17	(part 3)
X src/hpmods.c               2	
X src/lex.c.1               31	(part 1)
X src/lex.c.2               13	(part 2)
X src/loc.p2clib.c           1	
X src/loc.p2crc              1	
X src/makeproto.c            6	
X src/out.c                 12	
X src/p2c.h                  3	
X src/p2c.man               18	
X src/p2clib.c               6	
X src/parse.c.1             29	(part 1)
X src/parse.c.2             30	(part 2)
X src/parse.c.3              8	(part 3)
X src/pexpr.c.1             23	(part 1)
X src/pexpr.c.2             24	(part 2)
X src/pexpr.c.3              3	(part 3)
X src/string.pas             1	
X src/stuff.c                5	
X src/sys.p2crc.1           32	(part 1)
X src/sys.p2crc.2            8	(part 2)
X src/system.imp             2	
X src/system.m2              1	
X src/trans.c               15	
X src/trans.h.1             20	(part 1)
X src/trans.h.2              9	(part 2)
X src/turbo.imp              3	
END_OF_FILE
if test 3100 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(1629 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Makefile for "p2c", the Pascal to C translator.
X#  Copyright (C) 1989 David Gillespie.
X#  Author's address: daveg@csvax.caltech.edu; 256-80 Caltech/Pasadena CA 91125.
X
X# This program is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation (any version).
X
X# This program is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X
X# You should have received a copy of the GNU General Public License
X# along with this program; see the file COPYING.  If not, write to
X# the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
X
X
X# This file compiles and installs p2c in the "home" subdirectory of this
X# directory, then runs it on various example programs in the "examples"
X# subdirectory.  To install a permanent, public copy of p2c, see "README"
X# and src/Makefile.
X
Xtest:
X	@echo "Compiling p2c, installing in `pwd`/home..."
X	cd src; make install
X	@echo ""
X	@echo "Translating and compiling example files..."
X	cd examples; make comp
X	@echo ""
X	@echo "Running the factorial example..."
X	examples/fact
X	@echo ""
X	@echo "Running the 'e' computation example..."
X	examples/e
X	@echo ""
X	@echo "Running the self-printing Pascal example..."
X	examples/self >examples/self.out
X	cat examples/self.out
X	diff examples/self.p examples/self.out
X	@echo ""
X	@echo "Also try 'cref' and 'basic' in the examples directory."
X
X
Xinstall:
X	cd src; make install
X
END_OF_FILE
if test 1629 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'PACKNOTES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PACKNOTES'\"
else
echo shar: Extracting \"'PACKNOTES'\" \(900 characters\)
sed "s/^X//" >'PACKNOTES' <<'END_OF_FILE'
XFile "src/sys.p2crc" was split because of its size; to create it, do
X	cat src/sys.p2crc.? >src/sys.p2crc
XFile "src/lex.c" was split because of its size; to create it, do
X	cat src/lex.c.? >src/lex.c
XFile "src/parse.c" was split because of its size; to create it, do
X	cat src/parse.c.? >src/parse.c
XFile "src/decl.c" was split because of its size; to create it, do
X	cat src/decl.c.? >src/decl.c
XFile "src/expr.c" was split because of its size; to create it, do
X	cat src/expr.c.? >src/expr.c
XFile "src/pexpr.c" was split because of its size; to create it, do
X	cat src/pexpr.c.? >src/pexpr.c
XFile "src/funcs.c" was split because of its size; to create it, do
X	cat src/funcs.c.? >src/funcs.c
XFile "src/trans.h" was split because of its size; to create it, do
X	cat src/trans.h.? >src/trans.h
XFile "examples/basic.p" was split because of its size; to create it, do
X	cat examples/basic.p.? >examples/basic.p
END_OF_FILE
if test 900 -ne `wc -c <'PACKNOTES'`; then
    echo shar: \"'PACKNOTES'\" unpacked with wrong size!
fi
# end of 'PACKNOTES'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(5638 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X
XThis directory contains "p2c" version 1.14, a Pascal to C translator.
X
X"p2c"  Copyright 1989  Dave Gillespie
X                       256-80 Caltech
X                       Pasadena CA 91125
X                       daveg@csvax.caltech.edu, cit-vax!daveg
X
X
XThis program is distributed under the terms of the GNU License Agreement.
XSee the file src/COPYING for details.
X
XThe GNU License Agreement restrictions do _not_ apply to code generated
Xby p2c, nor to the p2c run-time files "p2clib.c" and "p2c.h".
X
X
X
XQUICK INSTRUCTIONS
X
XThe top-level Makefile in this directory tree knows how to build
Xp2c and run it on some example programs.  The compiled p2c will be
X"installed" in this directory tree rather than in public directories.
X(For a full public installation, see the instructions below.)
XJust type "make test" to build p2c and run the examples.
X
X
X
XFULL INSTALLATION INSTRUCTIONS
X
XFor a complete system, you must:
X
X   a) Create a home directory for p2c, such as /usr/lib/p2c.  The exact
X      location does not matter, as long as p2c knows how to find it.
X
X   b) Create an include directory, such as /usr/include/p2c.  If you are
X      unable to arrange for an include directory, you can edit sys.p2crc
X      so as not to require one, or compile translated code with a
X      suitable -I flag.
X
X   c) Install the executable "p2c" in /usr/bin or elsewhere on the
X      standard search path.
X
X   d) Install the run-time library "libp2c.a" in /usr/lib or elsewhere
X      on the standard library search path.
X
X   e) Install the Unix manual entry "p2c.1" in /usr/man/man1.  If you
X      have a "man1.Z" directory instead (for compressed man pages)
X      you will have to edit the Makefile to use a "compress" command.
X
X   f) Install the necessary files in the p2c home directory.
X
XThe Makefile is initially set up to create a private version of p2c in
Xthe p2c distribution directory.  Just "cd src" and "make install" to
Xperform the above steps.  This will place the p2c executable, run-time
Xlibrary, include directory, and man page in the "home" subdirectory of
Xthe distribution directory.  The man page will be in human-readable form.
X
XTo compile code that has been translated by this private version of p2c,
Xuse the command:
X
X    cc -I. foo.c libp2c.a
X
X(assuming "home," i.e., HOMEDIR, is the current directory.)
X
XThe "examples" subdirectory contains a few sample Pascal programs and
Xa Makefile to translate and compile them.
X
XTo install p2c for public use, edit the Makefile to indicate the correct
Xdirectory names.  Suggested names are included as comments.  Also change
XMANFILE as shown to store the man page in the proper form for the "man"
Xcommand.
X
X    HOMEDIR      default /usr/lib/p2c       Home directory
X    INCDIR       default /usr/include/p2c   Include directory
X    BINDIR       default /usr/bin           Directory for "p2c" executable
X    LIBDIR       default /usr/lib           Directory for "libp2c.a" library
X    MANDIR       default /usr/man/man1      Directory for "p2c.1" manual page
X
XMake sure the home and include directories have been created and are
Xwritable, and that the bin, lib, and man directories are writable.
X(You may have to be root to do this.)  Recompile "p2c" with another
X"make install".  Be sure "trans.c" is recompiled with the new value
Xof HOMEDIR; you can ensure this by doing "make newhome" before
X"make install".  You can always type "make" with no arguments to
Xcompile without installing.
X
XHP Pascal Workstation System users will want to copy all of ../HP/include
Xinto the new p2c include directory, and copy all of ../HP/import into
Xthe p2c home directory.  You will have to write emulations for the
Xfunctions you use out of these modules.  (The HP directories are
Xpresent in the ftp distribution only---they have been omitted from
Xthe shar'd version to save space.)
X
XIncomplete interface texts for standard Turbo units are included in
Xturbo.imp.  Turbo users will have to flesh these out and write emulations
Xfor whatever parts of the Turbo runtime library they need.
X
XIf you wish to edit various system-wide configuration parameters, it is
Xbetter to put them in loc.p2crc than in sys.p2crc.  As an example, on a
XTurbo-oriented environment you may wish to add
X
X    Language Turbo
X
Xto the loc.p2crc file to replace the normal default (HP Pascal).
X
X
X
XPORTABILITY
X
XP2c was originally developed on a homebrew C compiler on the HP Pascal
XWorkstation operating system.  Current development takes place on HP-UX,
Xwhich is System V based.  The translator has also been compiled and used
Xon Sun-3's, so presumably it is fairly portable among 32-bit Unix machines.
X
XMany parts of the code will have to be adjusted in order for p2c to work
Xon a machine with 16-bit ints.  I have never had reason or opportunity to
Xtrack these down since I don't have access to such a machine.  Please note
Xthat code _generated_ by p2c works with either size of int even though p2c
Xitself does not.
X
XIf your compiler supports ANSI prototypes, most of the 16-bit portability
Xproblems will go away except for possible %d/%ld sloppiness in sprintf control
Xstrings.  There may be places where p2c tries to cast a pointer into an
Xint, but I believe all such cases use longs consistently.  You will have
Xa problem if your long type is not large enough to store a pointer.
X
XBecause p2c was developed to run under Unix, it is sloppy about memory
Xallocation.  Some data structures are allocated but never freed.  Profiles
Xshow that the waste is not too great in most cases, but if it is a problem
Xyou may have to write a garbage collector (this shouldn't be too hard if you
Xonly run the collector after translating each procedure).
X
END_OF_FILE
if test 5638 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'examples/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/Makefile'\"
else
echo shar: Extracting \"'examples/Makefile'\" \(777 characters\)
sed "s/^X//" >'examples/Makefile' <<'END_OF_FILE'
X
X# Examples for "p2c", the Pascal to C translator.
X
X
X# The following definitions assume p2c has been compiled into the "home"
X# directory as shown in src/Makefile.
XP2C = ../p2c
XINC = ../home
XLIB = ../home/libp2c.a
X
X
Xdefault: comp
X
X
X# Translating everything:
X
Xtrans:  fact.c  e.c  self.c  cref.c  basic.c
X
Xfact.c: fact.p
X	$(P2C) fact.p
X
Xe.c: e.p
X	$(P2C) e.p
X
Xself.c: self.p
X	$(P2C) self.p
X
Xcref.c: cref.p
X	$(P2C) cref.p
X
Xbasic.c: basic.p
X	$(P2C) basic.p
X
X
X
X# Compiling everything:
X
Xcomp:  fact  e  self  cref  basic
X
Xfact: fact.c
X	$(CC) -I$(INC) fact.c $(LIB) -o fact
X
Xe: e.c
X	$(CC) -I$(INC) e.c $(LIB) -o e
X
Xself: self.c
X	$(CC) -I$(INC) self.c $(LIB) -o self
X
Xcref: cref.c
X	$(CC) -I$(INC) cref.c $(LIB) -o cref
X
Xbasic: basic.c
X	$(CC) -I$(INC) basic.c $(LIB) -lm -o basic
X
X
X
X
X
X
END_OF_FILE
if test 777 -ne `wc -c <'examples/Makefile'`; then
    echo shar: \"'examples/Makefile'\" unpacked with wrong size!
fi
# end of 'examples/Makefile'
fi
if test -f 'examples/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/README'\"
else
echo shar: Extracting \"'examples/README'\" \(1432 characters\)
sed "s/^X//" >'examples/README' <<'END_OF_FILE'
X
XThis directory contains examples for "p2c", a Pascal to C translator.
X
X"p2c"  Copyright 1989  Dave Gillespie
X                       256-80 Caltech
X                       Pasadena CA 91125
X                       daveg@csvax.caltech.edu, cit-vax!daveg
X
X
X
X
XHere are some sample programs you can run through p2c.  The Makefile
Xfor this directory knows how to translate and compile all programs.
XThe "c" subdirectory contains pre-translated files you can compare
Xwith your p2c output.  (The "c" subdirectory is present in the ftp
Xdistribution only, not in the shar distribution.)
X
XTo translate only:          make trans   or just   make
XTo translate and compile:   make comp
X
XThese programs have been culled from various places around the Caltech
XC.S. educational lab.  All programs are by Dave Gillespie except as
Xnoted, and are in the HP Pascal dialect.
X
X
Xfact.p   	The obligatory recursive factorial program.  Try this
X		one first: "make fact.c" to translate, or "make fact"
X		to translate and compile.
X
X
Xe.p   		Program for computing "e" to high precision.
X		(Courtesy of Scott Hemphill.)
X
X
Xself.p   	A self-printing program in Pascal.  Try translating,
X		running, and diff'ing the output with self.p.
X
X
Xcref.p   	A cross-referencer for Pascal programs.  Enter source
X		file name(s), then a blank line, then output file name.
X
X
Xbasic.p   	An interpreter for the Basic language, just for kicks!
X		See "basic.doc" for documentation.
X
END_OF_FILE
if test 1432 -ne `wc -c <'examples/README'`; then
    echo shar: \"'examples/README'\" unpacked with wrong size!
fi
# end of 'examples/README'
fi
if test -f 'examples/e.p' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/e.p'\"
else
echo shar: Extracting \"'examples/e.p'\" \(2411 characters\)
sed "s/^X//" >'examples/e.p' <<'END_OF_FILE'
X
X$partial_eval on$
X
Xprogram e(input,output);
X
Xconst
X   NDIGITS = 1007;
X   NPRINT = 1000;
X
Xtype
X   digit = 0..255;
X   digitarray = packed array [0..NDIGITS] of digit;
X
Xvar
X   s,x,t: ^digitarray;
X   xs,ts: integer;
X   i: integer;
X
Xprocedure initinteger(var x:digitarray; n:integer);
Xvar
X   i: integer;
Xbegin
X   x[0] := n;
X   for i := 1 to NDIGITS do x[i] := 0;
Xend;
X
Xprocedure divide(var x:digitarray; xs,n:integer;
X                 var y:digitarray; var ys:integer);
Xvar
X   i: integer;
X   c: integer;
Xbegin
X   c := 0;
X   for i := xs to NDIGITS do begin
X      c := 10*c + x[i];
X      y[i] := c div n;
X      c := c mod n;
X   end;
X   ys := xs;
X   while (ys <= NDIGITS) and (y[ys] = 0) do ys := ys+1;
Xend;
X
Xprocedure add(var s,x:digitarray; xs:integer);
Xvar
X   i: integer;
X   c: integer;
Xbegin
X   c := 0;
X   for i := NDIGITS downto xs do begin
X      c := s[i] + x[i] + c;
X      if c >= 10 then begin
X         s[i] := c - 10;
X         c := 1;
X      end else begin
X         s[i] := c;
X         c := 0;
X      end;
X   end;
X   i := xs;
X   while c <> 0 do begin
X      i := i-1;
X      c := s[i] + c;
X      if c >= 10 then begin
X         s[i] := c - 10;
X         c := 1;
X      end else begin
X         s[i] := c;
X         c := 0;
X      end;
X   end;
Xend;
X
Xprocedure sub(var s,x:digitarray; xs:integer);
Xvar
X   i: integer;
X   c: integer;
Xbegin
X   c := 0;
X   for i := NDIGITS downto xs do begin
X      c := s[i] - x[i] + c;
X      if c < 0 then begin
X         s[i] := c + 10;
X         c := -1;
X      end else begin
X         s[i] := c;
X         c := 0;
X      end;
X   end;
X   i := xs;
X   while c <> 0 do begin
X      i := i-1;
X      c := s[i] + c;
X      if c < 0 then begin
X         s[i] := c + 10;
X         c := -1;
X      end else begin
X         s[i] := c;
X         c := 0;
X      end;
X   end;
Xend;
X
Xbegin
X   new(s); new(x);
X   initinteger(s^,0);
X   initinteger(x^,1);
X   xs := 0;
X   add(s^,x^,xs);
X   i := 0;
X   repeat
X      i := i+1;
X      divide(x^,xs,i,x^,xs);
X      add(s^,x^,xs);
X      write(#M'Series: ',100*xs/(NDIGITS+1):5:2,'%');
X   until xs > NDIGITS;
X   writeln;
X   writeln('':45,'e = ',s^[0]:1,'.');
X   i := 0;
X   for i := 1 to NPRINT do begin
X      write(s^[i]:1);
X      if i mod 1000 = 0 then writeln;
X      if i mod 100 = 0 then writeln
X      else if i mod 10 = 0 then write(' ');
X   end;
X   writeln;
X   write('Final digits: ');
X   for i := NPRINT+1 to NDIGITS do begin
X      write(s^[i]:1);
X   end;
X   writeln;
Xend.
END_OF_FILE
if test 2411 -ne `wc -c <'examples/e.p'`; then
    echo shar: \"'examples/e.p'\" unpacked with wrong size!
fi
# end of 'examples/e.p'
fi
if test -f 'examples/fact.p' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/fact.p'\"
else
echo shar: Extracting \"'examples/fact.p'\" \(299 characters\)
sed "s/^X//" >'examples/fact.p' <<'END_OF_FILE'
X
X
Xprogram factorials(input, output);
X
X
Xvar
X   i : integer;
X
X
X
Xfunction fact(n : integer) : integer;
X   begin
X      if n > 1 then
X         fact := n * fact(n-1)
X      else
X         fact := 1;
X   end;
X
X
X
Xbegin
X   for i := 1 to 10 do
X      writeln('The factorial of ', i:1, ' is ', fact(i):1);
Xend.
X
X
X
END_OF_FILE
if test 299 -ne `wc -c <'examples/fact.p'`; then
    echo shar: \"'examples/fact.p'\" unpacked with wrong size!
fi
# end of 'examples/fact.p'
fi
if test -f 'examples/p2crc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/p2crc'\"
else
echo shar: Extracting \"'examples/p2crc'\" \(822 characters\)
sed "s/^X//" >'examples/p2crc' <<'END_OF_FILE'
X
X# Configuration options for translating the p2c examples.
X
X
XLanguage	HP	# All programs are in HP Pascal dialect
X
XVarFiles	0	# This helps basic.text's listtokens procedure work
X
XUseEnum		0	# Not necessary except to keep Sun's pitpicking
X			# compiler happy.
X
X
X# These kludges will get basic.c to compile without extra runtime support:
X# External procedures:
XFuncMacro	hpm_new(p,n) = (*p = Malloc(n))
XFuncMacro	hpm_dispose(p,n) = Free(*p)
XFuncMacro	misc_getioerrmsg(s,io) = sprintf(s, "I/O Error %d", (int)io)
XFuncMacro	misc_printerror(er,io) = printf("Error %d/%d!\n", (int)er, (int)io)
XFuncMacro	gotoxy(a,b) = 0
X# Functions imported from asm:
XFuncMacro	asm_iand(a,b) = (a & b)
XFuncMacro	asm_ior(a,b) = (a | b)
X# Functions in basic.text; may as well do these, too:
XFuncMacro	ixor(a,b) = (a ^ b)
XFuncMacro	inot(a) = (~a)
X
X
END_OF_FILE
if test 822 -ne `wc -c <'examples/p2crc'`; then
    echo shar: \"'examples/p2crc'\" unpacked with wrong size!
fi
# end of 'examples/p2crc'
fi
if test -f 'examples/self.p' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/self.p'\"
else
echo shar: Extracting \"'examples/self.p'\" \(1101 characters\)
sed "s/^X//" >'examples/self.p' <<'END_OF_FILE'
Xprogram self(input, output);
Xtype s = string[255]; n=integer;
Xvar a : array [1..100] of s; i,j : integer;
Xfunction t(a:integer):integer; begin if a<7 then t:=a else t:=a+11 end; function q(a:s):s;
X var j:n;begin for j:=strlen(a)downto 1 do if a[j]=#39 then strinsert(#39,a,j);q:=a;end;
Xbegin
X   a[1] := 'program self(input, output);';
X   a[2] := 'type s = string[255]; n=integer;';
X   a[3] := 'var a : array [1..100] of s; i,j : integer;';
X   a[4] := 'function t(a:integer):integer; begin if a<7 then t:=a else t:=a+11 end; function q(a:s):s;';
X   a[5] := ' var j:n;begin for j:=strlen(a)downto 1 do if a[j]=#39 then strinsert(#39,a,j);q:=a;end;';
X   a[6] := 'begin';
X   a[18] := '   for i := 1 to 11 do begin setstrlen(a[i+6], 0);';
X   a[19] := '      strwrite(a[i+6],1,j,''   a['',t(i):1,''] := '''''', q(a[t(i)]), '''''';'');';
X   a[20] := '   end;';
X   a[21] := '   for i := 1 to 22 do writeln(a[i]);';
X   a[22] := 'end.';
X   for i := 1 to 11 do begin setstrlen(a[i+6], 0);
X      strwrite(a[i+6],1,j,'   a[',t(i):1,'] := ''', q(a[t(i)]), ''';');
X   end;
X   for i := 1 to 22 do writeln(a[i]);
Xend.
END_OF_FILE
if test 1101 -ne `wc -c <'examples/self.p'`; then
    echo shar: \"'examples/self.p'\" unpacked with wrong size!
fi
# end of 'examples/self.p'
fi
if test -f 'src/loc.p2clib.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/loc.p2clib.c'\"
else
echo shar: Extracting \"'src/loc.p2clib.c'\" \(185 characters\)
sed "s/^X//" >'src/loc.p2clib.c' <<'END_OF_FILE'
X
X/* Put p2c runtime features local to your system here.
X * In particular, additional initialization may be provided by defining
X * the symbol LOCAL_INIT when you compile p2clib.c.
X */
X
END_OF_FILE
if test 185 -ne `wc -c <'src/loc.p2clib.c'`; then
    echo shar: \"'src/loc.p2clib.c'\" unpacked with wrong size!
fi
# end of 'src/loc.p2clib.c'
fi
if test -f 'src/loc.p2crc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/loc.p2crc'\"
else
echo shar: Extracting \"'src/loc.p2crc'\" \(138 characters\)
sed "s/^X//" >'src/loc.p2crc' <<'END_OF_FILE'
X
X# Store public p2crc commands local to your system here, so that
X# you can grab a new version of sys.p2crc without losing your changes.
X
END_OF_FILE
if test 138 -ne `wc -c <'src/loc.p2crc'`; then
    echo shar: \"'src/loc.p2crc'\" unpacked with wrong size!
fi
# end of 'src/loc.p2crc'
fi
if test -f 'src/string.pas' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/string.pas'\"
else
echo shar: Extracting \"'src/string.pas'\" \(1802 characters\)
sed "s/^X//" >'src/string.pas' <<'END_OF_FILE'
X
X{ Oregon Software Pascal dynamic string package. }
X
X
X{*VarFiles=0}  {INTF-ONLY}
X
Xfunction Len(var s : array [lo..hi:integer] of char) : integer; external;
X{FuncMacro Len(lo,hi,s) = strlen(s)}
X
Xprocedure Clear(var s : array [lo..hi:integer] of char); external;
X{FuncMacro Clear(lo,hi,s) = (s[lo] = 0)}
X
Xprocedure ReadString(var f : text;
X		     var s : array [lo..hi:integer] of char); external;
X{FuncMacro ReadString(f,lo,hi,s) = fgets(s, hi-lo+1, f)}
X
Xprocedure WriteString(var f : text;
X		      var s : array [lo..hi:integer] of char); external;
X{FuncMacro WriteString(f,lo,hi,s) = fprintf(f, "%s", s)}
X
Xprocedure Concatenate(var d : array [lod..hid:integer] of char;
X		      var s : array [los..his:integer] of char); external;
X{FuncMacro Concatenate(lod,hid,d,los,his,s) = strcat(d, s)}
X
Xfunction Search(var s : array [lo..hi:integer] of char;
X		var s2 : array [lo2..hi2:integer] of char;
X		i : integer) : integer; external;
X{FuncMacro Search(lo,hi,s,lo2,hi2,s2,i) = strpos2(s,s2,i-lo)+lo}
X
Xprocedure Insert(var d : array [lod..hid:integer] of char;
X		 var s : array [los..his:integer] of char;
X		 i : integer); external;
X{FuncMacro Insert(lod,hid,d,los,his,s,i) = strinsert(s,d,i-lod)}
X
Xprocedure Assign(var d : array [lo..hi:integer] of char;
X		 var s : array [los..his:integer] of char); external;
X{FuncMacro Assign(lo,hi,d,los,his,s) = strcpy(d,s)}
X
Xprocedure AssChar(var d : array [lo..hi:integer] of char;
X		  c : char); external;
X{FuncMacro AssChar(lo,hi,d,c) = sprintf(d, "%c", c)}
X
Xfunction Equal(var s1 : array [lo1..hi1:integer] of char;
X	       var s2 : array [lo2..hi2:integer] of char) : boolean; external;
X{FuncMacro Equal(lo1,hi1,s1,lo2,hi2,s2) = !strcmp(s1,s2)}
X
Xprocedure DelString(var s; i, j : integer); external;
X
Xprocedure SubString(var d; var s; i, j : integer); external;
X
END_OF_FILE
if test 1802 -ne `wc -c <'src/string.pas'`; then
    echo shar: \"'src/string.pas'\" unpacked with wrong size!
fi
# end of 'src/string.pas'
fi
if test -f 'src/system.m2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/system.m2'\"
else
echo shar: Extracting \"'src/system.m2'\" \(803 characters\)
sed "s/^X//" >'src/system.m2' <<'END_OF_FILE'
X
X(* Declarations for Modula-2 built-in objects *)
X
X(* Note: All functions with unusual syntaxes are not included here *)
X
X
X
XDEFINITION MODULE SYSTEM;   (*PERMANENT*)
X
XTYPE
X   PROC = PROCEDURE;
X   ADDRESS = POINTER TO WORD;
X
XFUNCTION  CAP(c : CHAR) : CHAR;
XFUNCTION  CHR(i : INTEGER) : CHAR;
XFUNCTION  ODD(i : INTEGER) : BOOLEAN;
XFUNCTION  ROUND(x : REAL) : INTEGER;
XFUNCTION  TRUNC(x : REAL) : INTEGER;
X(* Other things are defined internally to p2c *)
X
XEND;
X
X
X
XDEFINITION MODULE InOut;
X
X
X
XEND;
X
X
X
XDEFINITION MODULE MathLib0;
X
XFUNCTION  arctan(x : REAL) : REAL;
XFUNCTION  cos(x : REAL) : REAL;
XFUNCTION  entier(x : REAL) : INTEGER;
XFUNCTION  exp(x : REAL) : REAL;
XFUNCTION  ln(x : REAL) : REAL;
XFUNCTION  real(i : INTEGER) : REAL;
XFUNCTION  sin(x : REAL) : REAL;
XFUNCTION  sqrt(x : REAL) : REAL;
X
XEND.
X
X
END_OF_FILE
if test 803 -ne `wc -c <'src/system.m2'`; then
    echo shar: \"'src/system.m2'\" unpacked with wrong size!
fi
# end of 'src/system.m2'
fi
echo shar: End of archive 1 \(of 32\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 32 archives.
    echo "Now see PACKNOTES and the README"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
