Subject:  v21i047:  Pascal to C translator, Part02/32
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: 0f80ecf4 a1dff4b2 39acc187 3b336861

Submitted-by: Dave Gillespie <daveg@csvax.caltech.edu>
Posting-number: Volume 21, Issue 47
Archive-name: p2c/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 32)."
# Contents:  HP/import/fs.imp HP/include/fs.h HP/include/iodecl.h
#   HP/include/misc.h src/INSTALL src/Makefile src/README src/dir.c
#   src/hpmods.c src/system.imp
# Wrapped by rsalz@litchi.bbn.com on Mon Mar 26 14:29:26 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'HP/import/fs.imp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/import/fs.imp'\"
else
echo shar: Extracting \"'HP/import/fs.imp'\" \(4894 characters\)
sed "s/^X//" >'HP/import/fs.imp' <<'END_OF_FILE'
X
X
X{IncludeFrom=fs <p2c/fs.h>}
X
X
X{*VarStrings=0} {*VarFiles=0} {*ExportSymbol=fs_%s} {*Export_Symbol=%s}
X
X
Xmodule fs;    {file support} 
X
Ximport sysglobals, asm, misc;
X
Xexport
X
Xtype 
X     closetype = (cnormal, lock, purge, ccrunch); 
X     faccess = (readonly,writeonly,readwrite,writeappend,overwrite);
X     vptr = record case integer of
X              0: (j: integer);
X              1: (i: ^shortint); 
X              2: (s: ^string80);
X              end;
X           
X
Xprocedure fstripname(s : fid; var pvname,ppath,pfname : string);
Xprocedure fixname(var title: string; kind: filekind); 
Xprocedure zapspaces(var s: string); 
Xfunction suffix(var ftitle: string): filekind; 
Xfunction scantitle (fname: fid; var fvid: vid; var ftitle: fid; 
X                            var fsegs: integer; var fkind: filekind): boolean; 
Xfunction findvolume (var fvid: vid; verify: boolean): unitnum; 
Xprocedure doprefix(var dirname:fid; var kvid:vid; var kunit:integer; 
X                                                             findunit:boolean);
X
X{WarnNames=1}
Xprocedure finitb (var f: fib; window: windowp; recbytes: integer); 
Xprocedure fhpopen(var f: fib; typ: faccess; var title, option: string255);
Xprocedure fhpreset(var f: fib; typ: faccess);
Xprocedure fcloseit(var f: fib; stype: string255);
Xprocedure fclose (var f: fib; ftype: closetype); 
Xprocedure fmaketype(anyvar f:fib; var title, option, typestring: string); 
Xprocedure foverfile(anyvar f:fib; var title, option, typestring: string); 
Xprocedure fanonfile(anyvar f:fib; var name:string; kind:filekind;size:integer);
X
Xprocedure fseek(var f: fib; position: integer); 
Xfunction fposition(var f: fib): integer;
Xfunction fmaxpos(var f: fib): integer;
X
Xfunction fbufferref(var f: fib): windowp;
Xprocedure fget (var f: fib); 
Xprocedure fput (var f: fib); 
Xfunction feof (var f: fib): boolean; 
Xfunction feoln (var f: fib): boolean; 
Xprocedure fwriteln (var f: fib); 
X
Xprocedure fread(anyvar f: fib; anyvar buf: window); 
Xprocedure fwrite(anyvar f: fib;  anyvar buf: window); 
X
X{WarnNames}
Xprocedure freadbytes(anyvar f: fib; anyvar buf: window; size: integer); 
Xprocedure fwritebytes(anyvar f: fib;  anyvar buf: window; size: integer); 
X{*WarnNames=1}
X
Xfunction fblockio (var f: fib; var buf: window;
X                           nblocks,rblock: integer; doread: boolean): integer; 
X
X
Xprocedure killchar (anyvar f: fib; var sinx: integer); 
X
Xprocedure fpage (var t: text); 
Xprocedure foverprint(var t: text); 
Xprocedure fgotoxy(anyvar f: fib;      x, y:  integer); 
Xprocedure fgetxy (anyvar f: fib;  var x, y:  integer); 
X
Xprocedure freadln (var t:text); 
Xprocedure fwritechar (var t: text; ch: char; rleng: shortint); 
Xprocedure freadchar (var t:text; var ch: char);
Xprocedure freadword (var t:text; var i: shortint);
Xprocedure freadint (var t:text; var i: integer); 
Xprocedure fwriteword (var t:text;i,rleng: shortint); 
Xprocedure fwriteint (var t:text;i: integer; rleng: shortint); 
Xprocedure fwritestr (var t:text;anyvar s: string80; rleng: shortint); 
Xprocedure freadstr (var t:text; var s: string);
Xprocedure fwritepaoc (var t: text; var a: window; aleng,rleng: shortint); 
Xprocedure freadpaoc (var t: text; var a: window; aleng: shortint);
Xprocedure freadenum (var t: text; var i: shortint; p: vptr);
Xprocedure fwriteenum(var t: text; i: shortint; rleng: shortint; p: vptr);
Xprocedure freadbool (var t: text; var b: boolean);
Xprocedure fwritebool(var t: text; b: boolean; rleng: shortint);
X
X
Xprocedure freadstrchar (var s: string255;var p2: integer; var ch: char);
Xprocedure fwritestrchar (var s: string;
X                                  var p2: integer; ch: char; rleng: shortint); 
Xprocedure freadstrword (var s: string255;var p2: integer; var i: shortint);
X{PROCEDURE FREADSTRINT (VAR S: STRING255;VAR P2,I: INTEGER);}
Xprocedure fwritestrword (var s: string;var p2: integer; i,rleng: shortint); 
X{PROCEDURE FWRITESTRINT(VAR T: STRING;
X                               VAR P2: INTEGER; I: INTEGER; RLENG: SHORTINT); }
Xprocedure freadstrstr (var t: string255;var p2: integer; var s: string);
Xprocedure fwritestrstr (var s: string; var p2: integer;
X                                        anyvar t: string255; rleng: shortint); 
Xprocedure fwritestrpaoc (var s: string; var p2: integer;
X                                        var a: window; aleng,rleng: shortint); 
Xprocedure freadstrpaoc (var s: string255; var p2: integer;
X                                              var a: window; aleng: shortint);
Xprocedure freadstrenum (var s: string255;
X                                    var p2: integer; var i: shortint; p: vptr);
Xprocedure fwritestrenum(var s: string;
X                                  var p2: integer; i,rleng: shortint; p: vptr);
Xprocedure freadstrbool (var s: string255;var p2: integer; var b: boolean);
Xprocedure fwritestrbool(var s: string;
X                                 var p2: integer; b: boolean; rleng: shortint);
X
X
Xend.
X
X
END_OF_FILE
if test 4894 -ne `wc -c <'HP/import/fs.imp'`; then
    echo shar: \"'HP/import/fs.imp'\" unpacked with wrong size!
fi
# end of 'HP/import/fs.imp'
fi
if test -f 'HP/include/fs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/include/fs.h'\"
else
echo shar: Extracting \"'HP/include/fs.h'\" \(4438 characters\)
sed "s/^X//" >'HP/include/fs.h' <<'END_OF_FILE'
X/* Header for module fs, generated by p2c */
X#ifndef FS_H
X#define FS_H
X
X
X
X/*file support*/
X#ifndef SYSGLOBALS_H
X#include <p2c/sysglobals.h>
X#endif
X
X#ifndef ASM_H
X#include <p2c/asm.h>
X#endif
X
X#ifndef MISC_H
X#include <p2c/misc.h>
X#endif
X
X
X
X#ifdef FS_G
X# define vextern
X#else
X# define vextern extern
X#endif
X
X
X
Xtypedef enum {
X    fs_cnormal, fs_lock, fs_purge, fs_ccrunch
X} fs_closetype;
X
Xtypedef enum {
X    fs_readonly, fs_writeonly, fs_readwrite, fs_writeappend, fs_overwrite
X} fs_faccess;
X
Xtypedef union fs_vptr {
X    long j;
X    short *i;
X    Char *s;
X} fs_vptr;
X
X
X
Xextern Void fs_fstripname PP((Char *s, Char *pvname, Char *ppath,
X			      Char *pfname));
Xextern Void fs_fixname PP((Char *title, int kind));
Xextern Void fs_zapspaces PP((Char *s));
Xextern filekind fs_suffix PP((Char *ftitle));
Xextern boolean fs_scantitle PP((Char *fname, Char *fvid, Char *ftitle,
X				long *fsegs, filekind *fkind));
Xextern char fs_findvolume PP((Char *fvid, int verify));
Xextern Void fs_doprefix PP((Char *dirname, Char *kvid, long *kunit,
X			    int findunit));
Xextern Void fs_finitb PP((fib *f, Char *window_, long recbytes));
Xextern Void fs_fhpopen PP((fib *f, int typ, Char *title, Char *option));
Xextern Void fs_fhpreset PP((fib *f, int typ));
Xextern Void fs_fcloseit PP((fib *f, Char *stype));
Xextern Void fs_fclose PP((fib *f, int ftype));
Xextern Void fs_fmaketype PP((fib *f, Char *title, Char *option,
X			     Char *typestring));
Xextern Void fs_foverfile PP((fib *f, Char *title, Char *option,
X			     Char *typestring));
Xextern Void fs_fanonfile PP((fib *f, Char *name, int kind, long size));
Xextern Void fs_fseek PP((fib *f, long position));
Xextern long fs_fposition PP((fib *f));
Xextern long fs_fmaxpos PP((fib *f));
Xextern Char *fs_fbufferref PP((fib *f));
Xextern Void fs_fget PP((fib *f));
Xextern Void fs_fput PP((fib *f));
Xextern boolean fs_feof PP((fib *f));
Xextern boolean fs_feoln PP((fib *f));
Xextern Void fs_fwriteln PP((fib *f));
Xextern Void fs_fread PP((fib *f, Char *buf));
Xextern Void fs_fwrite PP((fib *f, Char *buf));
Xextern Void fs_freadbytes PP((fib *f, Char *buf, long size));
Xextern Void fs_fwritebytes PP((fib *f, Char *buf, long size));
Xextern long fs_fblockio PP((fib *f, Char *buf, long nblocks, long rblock,
X			    int doread));
Xextern Void fs_killchar PP((fib *f, long *sinx));
Xextern Void fs_fpage PP((FILE *t));
Xextern Void fs_foverprint PP((FILE *t));
Xextern Void fs_fgotoxy PP((fib *f, long x, long y));
Xextern Void fs_fgetxy PP((fib *f, long *x, long *y));
Xextern Void fs_freadln PP((FILE *t));
Xextern Void fs_fwritechar PP((FILE *t, int ch, int rleng));
Xextern Void fs_freadchar PP((FILE *t, Char *ch));
Xextern Void fs_freadword PP((FILE *t, short *i));
Xextern Void fs_freadint PP((FILE *t, long *i));
Xextern Void fs_fwriteword PP((FILE *t, int i, int rleng));
Xextern Void fs_fwriteint PP((FILE *t, long i, int rleng));
Xextern Void fs_fwritestr PP((FILE *t, Char *s, int rleng));
Xextern Void fs_freadstr PP((FILE *t, Char *s));
Xextern Void fs_fwritepaoc PP((FILE *t, Char *a, int aleng, int rleng));
Xextern Void fs_freadpaoc PP((FILE *t, Char *a, int aleng));
Xextern Void fs_freadenum PP((FILE *t, short *i, fs_vptr p));
Xextern Void fs_fwriteenum PP((FILE *t, int i, int rleng, fs_vptr p));
Xextern Void fs_freadbool PP((FILE *t, boolean *b));
Xextern Void fs_fwritebool PP((FILE *t, int b, int rleng));
Xextern Void fs_freadstrchar PP((Char *s, long *p2, Char *ch));
Xextern Void fs_fwritestrchar PP((Char *s, long *p2, int ch, int rleng));
Xextern Void fs_freadstrword PP((Char *s, long *p2, short *i));
X
X/*PROCEDURE FREADSTRINT (VAR S: STRING255;VAR P2,I: INTEGER);*/
Xextern Void fs_fwritestrword PP((Char *s, long *p2, int i, int rleng));
X
X/*PROCEDURE FWRITESTRINT(VAR T: STRING; */
X/*                                VAR P2: INTEGER; I: INTEGER; RLENG: SHORTINT); */
Xextern Void fs_freadstrstr PP((Char *t, long *p2, Char *s));
Xextern Void fs_fwritestrstr PP((Char *s, long *p2, Char *t, int rleng));
Xextern Void fs_fwritestrpaoc PP((Char *s, long *p2, Char *a, int aleng,
X				 int rleng));
Xextern Void fs_freadstrpaoc PP((Char *s, long *p2, Char *a, int aleng));
Xextern Void fs_freadstrenum PP((Char *s, long *p2, short *i, fs_vptr p));
Xextern Void fs_fwritestrenum PP((Char *s, long *p2, int i, int rleng,
X				 fs_vptr p));
Xextern Void fs_freadstrbool PP((Char *s, long *p2, boolean *b));
Xextern Void fs_fwritestrbool PP((Char *s, long *p2, int b, int rleng));
X
X
X
X#undef vextern
X
X#endif /*FS_H*/
X
X/* End. */
X
END_OF_FILE
if test 4438 -ne `wc -c <'HP/include/fs.h'`; then
    echo shar: \"'HP/include/fs.h'\" unpacked with wrong size!
fi
# end of 'HP/include/fs.h'
fi
if test -f 'HP/include/iodecl.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/include/iodecl.h'\"
else
echo shar: Extracting \"'HP/include/iodecl.h'\" \(6087 characters\)
sed "s/^X//" >'HP/include/iodecl.h' <<'END_OF_FILE'
X/* Header for module IODECLARATIONS, generated by p2c */
X#ifndef IODECLARATIONS_H
X#define IODECLARATIONS_H
X
X
X
X#ifndef SYSGLOBALS_H
X#include <p2c/sysglobals.h>
X#endif
X
X
X
X#ifdef IODECLARATIONS_G
X# define vextern
X#else
X# define vextern extern
X#endif
X
X
X
X#define P_iominisc      0
X#define P_iomaxisc      31
X#define P_minrealisc    7
X#define P_maxrealisc    31
X
X#define io_line_feed    '\n'
X#define io_carriage_rtn '\015'
X
X#define P_ioescapecode  (-26)
X#define ioe_no_error    0
X#define ioe_no_card     1
X#define ioe_not_hpib    2
X#define ioe_not_act     3
X#define ioe_not_dvc     4
X#define ioe_no_space    5
X#define ioe_no_data     6
X#define ioe_bad_tfr     7
X#define ioe_isc_busy    8
X#define ioe_buf_busy    9
X#define ioe_bad_cnt     10
X#define ioe_bad_tmo     11
X#define ioe_no_driver   12
X#define ioe_no_dma      13
X#define ioe_no_word     14
X#define ioe_not_talk    15
X#define ioe_not_lstn    16
X#define ioe_timeout     17
X#define ioe_not_sctl    18
X#define ioe_rds_wtc     19
X#define ioe_bad_sct     20
X#define ioe_crd_dwn     21
X#define ioe_eod_seen    22
X#define ioe_misc        23
X#define ioe_sr_toomany  304
X#define ioe_dc_fail     306
X#define ioe_dc_usart    313
X#define ioe_dc_ovfl     314
X#define ioe_dc_clk      315
X#define ioe_dc_cts      316
X#define ioe_dc_car      317
X#define ioe_dc_act      318
X#define ioe_dc_conn     319
X#define ioe_dc_conf     325
X#define ioe_dc_reg      326
X#define ioe_dc_rval     327
X#define ioe_sr_fail     353
X#define no_isc          255
X
X#define gtl_message     '\001'
X#define sdc_message     '\004'
X#define ppc_message     '\005'
X#define get_message     '\b'
X#define tct_message     '\t'
X#define llo_message     '\021'
X#define dcl_message     '\024'
X#define ppu_message     '\025'
X#define spe_message     '\030'
X#define spd_message     '\031'
X#define unl_message     '?'
X#define unt_message     '_'
X#define ppe_message     '`'
X#define ppd_message     'p'
X
X#define talk_constant   64
X#define listen_constant 32
X#define no_card         0
X#define other_card      1
X#define system_card     2
X#define hpib_card       3
X#define gpio_card       4
X#define serial_card     5
X#define graphics_card   6
X#define srm_card        7
X#define bubble_card     8
X#define eprom_prgmr     9
X#define hp98628_dsndl   (-7)
X#define P_hp98629       (-6)
X#define hp_datacomm     (-5)
X#define P_hp98620       (-4)
X#define internal_kbd    (-3)
X#define internal_crt    (-2)
X#define internal_hpib   (-1)
X#define no_id           0
X#define P_hp98624       1
X#define P_hp98626       2
X#define P_hp98622       3
X#define P_hp98623       4
X#define P_hp98625       8
X#define hp98628_async   20
X#define P_hpGATOR       25
X#define P_hp98253       27
X#define P_hp98627       28
X#define P_hp98259       30
X#define P_hp98644       66
X
X
X
Xtypedef enum {
X    ren_line, ifc_line, srq_line, eoi_line, nrfd_line, ndac_line, dav_line,
X    atn_line
X} type_hpib_line;
X
Xtypedef enum {
X    no_parity, odd_parity, even_parity, zero_parity, one_parity
X} type_parity;
X
Xtypedef enum {
X    rts_line, cts_line, dcd_line, dsr_line, drs_line, ri_line, dtr_line
X} type_serial_line;
X
Xtypedef struct drv_table_type {
X    _PROCEDURE iod_init;
X    _PROCEDURE iod_isr;
X    _PROCEDURE iod_rdb;
X    _PROCEDURE iod_wtb;
X    _PROCEDURE iod_rdw;
X    _PROCEDURE iod_wtw;
X    _PROCEDURE iod_rds;
X    _PROCEDURE iod_wtc;
X    _PROCEDURE iod_end;
X    _PROCEDURE iod_tfr;
X    _PROCEDURE iod_send;
X    _PROCEDURE iod_ppoll;
X    _PROCEDURE iod_set, iod_clr;
X    _PROCEDURE iod_test;
X} drv_table_type;
X
Xtypedef union io_funny_proc {
X    _PROCEDURE real_proc;
X    struct {
X	Anyptr *dummy_pr, *dummy_sl;
X    } U0;
X} io_funny_proc;
X
Xtypedef struct io_temp_type {
X    isrib myisrib;
X    io_funny_proc user_isr;
X    Anyptr *user_parm, *card_addr, *in_bufptr, *out_bufptr;
X    Char eirbyte;
X    uchar my_isc;
X    long timeout;
X    short addressed;
X    Char drv_misc[32];
X} io_temp_type;
X
Xtypedef struct io_temp_type2 {
X    isrib myisrib;
X    io_funny_proc user_isr;
X    Anyptr *user_parm, *card_addr, *in_bufptr, *out_bufptr;
X    Char eirbyte;
X    uchar my_isc;
X    long timeout;
X    short addressed;
X    Char drv_misc[128];
X} io_temp_type2;
X
Xtypedef struct io_temp_type3 {
X    isrib myisrib;
X    io_funny_proc user_isr;
X    Anyptr *user_parm, *card_addr, *in_bufptr, *out_bufptr;
X    Char eirbyte;
X    uchar my_isc;
X    long timeout;
X    short addressed;
X    Char drv_misc[160];
X} io_temp_type3;
X
Xtypedef struct io_temp_type4 {
X    isrib myisrib;
X    io_funny_proc user_isr;
X    Anyptr *user_parm, *card_addr, *in_bufptr, *out_bufptr;
X    Char eirbyte;
X    uchar my_isc;
X    long timeout;
X    short addressed;
X    Char drv_misc[164];
X} io_temp_type4;
X
Xtypedef struct isc_table_type {
X    drv_table_type *io_drv_ptr;
X    io_temp_type *io_tmp_ptr;
X    short card_type;
X    long user_time;
X    short card_id;
X    Anyptr *card_ptr;
X} isc_table_type;
X
Xtypedef enum {
X    dummy_tfr_1, serial_DMA, serial_FHS, serial_FASTEST, dummy_tfr_2,
X    overlap_INTR, overlap_DMA, overlap_FHS, overlap_FASTEST, P_OVERLAP
X} user_tfr_type;
X
Xtypedef enum {
X    no_tfr, INTR_tfr, DMA_tfr, BURST_tfr, FHS_tfr
X} actual_tfr_type;
X
Xtypedef enum {
X    to_memory, from_memory
X} dir_of_tfr;
X
Xtypedef Char buf_type[];
X
Xtypedef struct buf_info_type {
X    io_temp_type *drv_tmp_ptr;
X    uchar active_isc;
X    actual_tfr_type act_tfr;
X    user_tfr_type usr_tfr;
X    boolean b_w_mode, end_mode;
X    dir_of_tfr direction;
X    short term_char;
X    long term_count;
X    Char *buf_ptr;
X    long buf_size;
X    Anyptr *buf_empty, *buf_fill;
X    io_funny_proc eot_proc;
X    Anyptr *eot_parm;
X    boolean dma_priority;
X} buf_info_type;
X
X
X
Xvextern io_funny_proc dma_ch_0;
Xvextern uchar dma_isc_0;
Xvextern io_funny_proc dma_ch_1;
Xvextern uchar dma_isc_1;
Xvextern isrib dma_isrib0, dma_isrib1;
Xvextern boolean dma_here;
Xvextern Char io_work_char;
Xvextern long ioe_result, ioe_isc;
Xvextern isc_table_type isc_table[P_iomaxisc - P_iominisc + 1];
Xvextern Char io_revid[97];
Xvextern _PROCEDURE io_error_link;
X
X
X
Xextern Void io_escape PP((long my_code, long select_code));
Xextern uchar io_find_isc PP((Anyptr *iod_temp));
X
X
X
X#undef vextern
X
X#endif /*IODECLARATIONS_H*/
X
X/* End. */
X
END_OF_FILE
if test 6087 -ne `wc -c <'HP/include/iodecl.h'`; then
    echo shar: \"'HP/include/iodecl.h'\" unpacked with wrong size!
fi
# end of 'HP/include/iodecl.h'
fi
if test -f 'HP/include/misc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HP/include/misc.h'\"
else
echo shar: Extracting \"'HP/include/misc.h'\" \(2815 characters\)
sed "s/^X//" >'HP/include/misc.h' <<'END_OF_FILE'
X/* Header for module misc, generated by p2c */
X#ifndef MISC_H
X#define MISC_H
X
X
X
X/*homeless orphans*/
X#ifndef SYSGLOBALS_H
X#include <p2c/sysglobals.h>
X#endif
X
X#ifndef ASM_H
X#include <p2c/asm.h>
X#endif
X
X
X
X#ifdef MISC_G
X# define vextern
X#else
X# define vextern extern
X#endif
X
X
X
X#define misc_null       0
X
X#define misc_nullchar   '\0'
X#define misc_homechar   '\001'
X
X#define misc_etx        3
X#define misc_bell       7
X
X#define misc_bellchar   '\007'
X
X#define misc_bs         8
X
X#define misc_leftchar   '\b'
X
X#define misc_tab        9
X
X#define misc_cteol      '\t'
X
X#define misc_lf         10
X
X#define misc_downchar   '\n'
X
X#define misc_vt         11
X
X#define misc_cteos      '\013'
X
X#define misc_ff         12
X
X#define misc_clearscr   '\f'
X
X#define misc_cr         13
X
X#define misc_eol        '\015'
X
X#define misc_dle        16
X#define misc_esc        27
X
X#define misc_escchar    '\033'
X
X#define misc_fsp        28
X
X#define misc_rightchar  '\034'
X
X#define misc_us         31
X
X#define misc_upchar     '\037'
X
X#define misc_del        127
X#define misc_cntrl      255
X
X
X
X/* CATALOGUE INFORMATION, zero entry refers to the directory itself */
X/*name of file or directory*/
X/*external file type (LIF)*/
X/*file kind*/
X/*physical size of file  */
X/*                                         or of total data space on volume*/
X/*logical size of file  */
X/*                                         or unused space on medium*/
X/*starting location of file  */
X/*                                         or first possible data location*/
X/*size of a sector or block*/
X/*creation, last modified dates*/
X/*creation, last modified times*/
X/*extension  */
X/*                                         or total possible number of files */
X/*                                         or requested number of files*/
X/*secondary discretionary field */
X/*                                         or start index of requested catalog*/
X/*comment or miscellaneous information*/
X
Xtypedef struct misc_catentry {
X    Char cname[tidleng + 1];
X    short ceft;
X    filekind ckind;
X    long cpsize, clsize, cstart, cblocksize;
X    daterec ccreatedate, clastdate;
X    timerec ccreatetime, clasttime;
X    long cextra1, cextra2;
X    Char cinfo[21];
X} misc_catentry;
X
Xtypedef struct misc_passentry {
X    long pbits;
X    Char pword[passleng + 1];
X} misc_passentry;
X
X
X
Xvextern uchar misc_idle;
X
X
X
X/* idle character -- 3.0 bug jws 3/20/84 */
Xextern Void misc_getioerrmsg PP((Char *s, long lastior));
Xextern Void misc_printerror PP((long errorcode, long lastior));
Xextern Void misc_upc PP((Char *s));
Xextern long misc_ueovbytes PP((int unit));
Xextern Void misc_unblockeddam PP((fib *f, int unum, int request));
Xextern Void misc_initfilekinds PV( );
Xextern Void misc_lockup PV( );
Xextern Void misc_lockdown PV( );
X
X
X
X#undef vextern
X
X#endif /*MISC_H*/
X
X/* End. */
X
END_OF_FILE
if test 2815 -ne `wc -c <'HP/include/misc.h'`; then
    echo shar: \"'HP/include/misc.h'\" unpacked with wrong size!
fi
# end of 'HP/include/misc.h'
fi
if test -f 'src/INSTALL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/INSTALL'\"
else
echo shar: Extracting \"'src/INSTALL'\" \(5638 characters\)
sed "s/^X//" >'src/INSTALL' <<'END_OF_FILE'
X
XThis directory contains "p2c" version 1.14, a Pascal to C translator.
X
X"p2c"  Copyright 1989  Dave Gillespie
X                       256-80 Caltech
X                       Pasadena CA 91125
X                       daveg@csvax.caltech.edu, cit-vax!daveg
X
X
XThis program is distributed under the terms of the GNU License Agreement.
XSee the file src/COPYING for details.
X
XThe GNU License Agreement restrictions do _not_ apply to code generated
Xby p2c, nor to the p2c run-time files "p2clib.c" and "p2c.h".
X
X
X
XQUICK INSTRUCTIONS
X
XThe top-level Makefile in this directory tree knows how to build
Xp2c and run it on some example programs.  The compiled p2c will be
X"installed" in this directory tree rather than in public directories.
X(For a full public installation, see the instructions below.)
XJust type "make test" to build p2c and run the examples.
X
X
X
XFULL INSTALLATION INSTRUCTIONS
X
XFor a complete system, you must:
X
X   a) Create a home directory for p2c, such as /usr/lib/p2c.  The exact
X      location does not matter, as long as p2c knows how to find it.
X
X   b) Create an include directory, such as /usr/include/p2c.  If you are
X      unable to arrange for an include directory, you can edit sys.p2crc
X      so as not to require one, or compile translated code with a
X      suitable -I flag.
X
X   c) Install the executable "p2c" in /usr/bin or elsewhere on the
X      standard search path.
X
X   d) Install the run-time library "libp2c.a" in /usr/lib or elsewhere
X      on the standard library search path.
X
X   e) Install the Unix manual entry "p2c.1" in /usr/man/man1.  If you
X      have a "man1.Z" directory instead (for compressed man pages)
X      you will have to edit the Makefile to use a "compress" command.
X
X   f) Install the necessary files in the p2c home directory.
X
XThe Makefile is initially set up to create a private version of p2c in
Xthe p2c distribution directory.  Just "cd src" and "make install" to
Xperform the above steps.  This will place the p2c executable, run-time
Xlibrary, include directory, and man page in the "home" subdirectory of
Xthe distribution directory.  The man page will be in human-readable form.
X
XTo compile code that has been translated by this private version of p2c,
Xuse the command:
X
X    cc -I. foo.c libp2c.a
X
X(assuming "home," i.e., HOMEDIR, is the current directory.)
X
XThe "examples" subdirectory contains a few sample Pascal programs and
Xa Makefile to translate and compile them.
X
XTo install p2c for public use, edit the Makefile to indicate the correct
Xdirectory names.  Suggested names are included as comments.  Also change
XMANFILE as shown to store the man page in the proper form for the "man"
Xcommand.
X
X    HOMEDIR      default /usr/lib/p2c       Home directory
X    INCDIR       default /usr/include/p2c   Include directory
X    BINDIR       default /usr/bin           Directory for "p2c" executable
X    LIBDIR       default /usr/lib           Directory for "libp2c.a" library
X    MANDIR       default /usr/man/man1      Directory for "p2c.1" manual page
X
XMake sure the home and include directories have been created and are
Xwritable, and that the bin, lib, and man directories are writable.
X(You may have to be root to do this.)  Recompile "p2c" with another
X"make install".  Be sure "trans.c" is recompiled with the new value
Xof HOMEDIR; you can ensure this by doing "make newhome" before
X"make install".  You can always type "make" with no arguments to
Xcompile without installing.
X
XHP Pascal Workstation System users will want to copy all of ../HP/include
Xinto the new p2c include directory, and copy all of ../HP/import into
Xthe p2c home directory.  You will have to write emulations for the
Xfunctions you use out of these modules.  (The HP directories are
Xpresent in the ftp distribution only---they have been omitted from
Xthe shar'd version to save space.)
X
XIncomplete interface texts for standard Turbo units are included in
Xturbo.imp.  Turbo users will have to flesh these out and write emulations
Xfor whatever parts of the Turbo runtime library they need.
X
XIf you wish to edit various system-wide configuration parameters, it is
Xbetter to put them in loc.p2crc than in sys.p2crc.  As an example, on a
XTurbo-oriented environment you may wish to add
X
X    Language Turbo
X
Xto the loc.p2crc file to replace the normal default (HP Pascal).
X
X
X
XPORTABILITY
X
XP2c was originally developed on a homebrew C compiler on the HP Pascal
XWorkstation operating system.  Current development takes place on HP-UX,
Xwhich is System V based.  The translator has also been compiled and used
Xon Sun-3's, so presumably it is fairly portable among 32-bit Unix machines.
X
XMany parts of the code will have to be adjusted in order for p2c to work
Xon a machine with 16-bit ints.  I have never had reason or opportunity to
Xtrack these down since I don't have access to such a machine.  Please note
Xthat code _generated_ by p2c works with either size of int even though p2c
Xitself does not.
X
XIf your compiler supports ANSI prototypes, most of the 16-bit portability
Xproblems will go away except for possible %d/%ld sloppiness in sprintf control
Xstrings.  There may be places where p2c tries to cast a pointer into an
Xint, but I believe all such cases use longs consistently.  You will have
Xa problem if your long type is not large enough to store a pointer.
X
XBecause p2c was developed to run under Unix, it is sloppy about memory
Xallocation.  Some data structures are allocated but never freed.  Profiles
Xshow that the waste is not too great in most cases, but if it is a problem
Xyou may have to write a garbage collector (this shouldn't be too hard if you
Xonly run the collector after translating each procedure).
X
END_OF_FILE
if test 5638 -ne `wc -c <'src/INSTALL'`; then
    echo shar: \"'src/INSTALL'\" unpacked with wrong size!
fi
# end of 'src/INSTALL'
fi
if test -f 'src/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/Makefile'\"
else
echo shar: Extracting \"'src/Makefile'\" \(5131 characters\)
sed "s/^X//" >'src/Makefile' <<'END_OF_FILE'
X# Makefile for "p2c", the Pascal to C translator.
X#  Copyright (C) 1989 David Gillespie.
X#  Author's address: daveg@csvax.caltech.edu; 256-80 Caltech/Pasadena CA 91125.
X
X# This program is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation (any version).
X
X# This program is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X
X# You should have received a copy of the GNU General Public License
X# along with this program; see the file COPYING.  If not, write to
X# the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
X
X# Directories (private version)
XHOMEDIR = ../home
XINCDIR = ../home/p2c
XBINDIR = ..
XLIBDIR = ../home
XMANDIR = ../home
XMANFILE = p2c.cat          # human-readable manual (for cat.1)
X#MANFILE = p2c.man.inst    # uncompressed nroff source (for man.1)
X#MANFILE = p2c.man.Z       # compressed nroff source (for man.1.Z)
X
X# Directories (public version)
X#HOMEDIR = /usr/lib/p2c
X#INCDIR = /usr/include/p2c
X#BINDIR = /usr/bin
X#LIBDIR = /usr/lib
X#MANDIR = /usr/man/man1
X#MANFILE = p2c.man.inst
X
X# Compiler options
XCC = cc                    # you may wish to use gcc here instead
XOPT = # -O		   # uncomment this for optimization
XDEB = # -g		   # uncomment this for debugging
XDEFS =			   # place other -D types of things here
XCFLAGS = $(OPT) $(DEB) $(DEFS)
XLFLAGS =
X
X
X# Custom translator modules
XCUSTSRCS = hpmods.c citmods.c
XCUSTOBJS = hpmods.o citmods.o
XCUSTDEFS = -DCUST1=hpmods -DCUST2=citmods
X
X
X# File names
XP2CSRCS = trans.c stuff.c out.c comment.c lex.c parse.c decl.c \
X          expr.c pexpr.c funcs.c dir.c
XP2COBJS = trans.o stuff.o out.o comment.o lex.o parse.o decl.o \
X          expr.o pexpr.o funcs.o dir.o
X
XSRCS = $(P2CSRCS) $(CUSTSRCS)
XOBJS = $(P2COBJS) $(CUSTOBJS)
X
XLIBSRCS = p2clib.c loc.p2clib.c
XLIBOBJS = p2clib.o loc.p2clib.o
XOTHERLIBOBJS =
X
XABSHOMEDIR = `cd $(HOMEDIR); pwd`
XABSINCDIR = `cd $(INCDIR); pwd`
XABSLIBDIR = `cd $(LIBDIR); pwd`
X
XMISCSRCS = makeproto.c
XPROTOS = p2c.proto p2c.hdrs
XHDRS = trans.h p2c.h
X
X
X# Top-level targets
Xall: proto p2c libp2c.a p2c.cat
Xproto: $(PROTOS)
X
X
X# Making p2c
Xp2c: $(OBJS)
X	$(CC) $(LFLAGS) $(OBJS) -o p2c
X
Xdir.o: dir.c trans.h
X	$(CC) -c $(CFLAGS) $(CUSTDEFS) dir.c
X
Xtrans.o: trans.c trans.h
X	$(CC) -c $(CFLAGS) -DHASDUMPS -DP2C_HOME=\"$(ABSHOMEDIR)\" trans.c
X
X
X# Making and using makeproto
Xp2c.hdrs: $(SRCS) makeproto
X	./makeproto -n -m -h -t16 -a35 -s0 -x $(SRCS) -o p2c.hdrs
X
Xp2c.proto: $(SRCS) makeproto
X	./makeproto -n -m -h -t16 -a35 -s1 -i $(SRCS) -o p2c.proto
X
Xmakeproto: makeproto.c
X	$(CC) $(CFLAGS) $(LFLAGS) makeproto.c -o makeproto
X
X
X# Making the p2c runtime library
Xlibp2c.a: $(LIBOBJS)
X	ar r libp2c.a $(LIBOBJS) $(OTHERLIBOBJS)
X
Xp2clib.o: p2clib.c
X	$(CC) -c $(CFLAGS) p2clib.c
X
X
X# Making the p2c man page
Xp2c.man.inst: p2c.man
X	sed -e "s;--HOMEDIR--;$(ABSHOMEDIR);"   \
X            -e "s;--INCDIR--;$(ABSINCDIR);"     \
X            -e "s;--LIBDIR--;$(ABSLIBDIR);"     \
X            p2c.man >p2c.man.inst
X
Xp2c.man.Z: p2c.man.inst
X	compress -c p2c.man.inst >p2c.man.Z
X
Xp2c.cat: p2c.man.inst
X	if [ -f /usr/bin/nroff -o -f /bin/nroff ];  \
X	    then nroff -man p2c.man.inst >p2c.cat; fi
X
X
X
X# Initially installing p2c:
X#  First, make sure $(HOMEDIR) and $(INCDIR) exist and are writable;
X#  Second, make sure $(LIBDIR), $(BINDIR) and $(MANDIR) are writable;
X#  Third, execute "make install" to compile and set things up.
X# (You may need to have a system operator do these steps for you.)
X
XCOPY = cp
X
Xnewhome:
X	rm -f trans.o     # force trans.c to be recompiled (if HOMEDIR changes)
X
Xinstall: proto \
X	$(BINDIR)/p2c         \
X	$(LIBDIR)/libp2c.a    \
X	$(MANDIR)/p2c.1	      \
X	$(INCDIR)/p2c.h	      \
X	$(HOMEDIR)/p2crc      \
X	$(HOMEDIR)/loc.p2crc  \
X	$(HOMEDIR)/system.imp \
X	$(HOMEDIR)/system.m2  \
X	$(HOMEDIR)/turbo.imp  \
X	$(HOMEDIR)/string.pas
X
X$(BINDIR)/p2c: p2c
X	$(COPY)  p2c          $(BINDIR)/p2c
X
XSHELL=/bin/sh
X$(LIBDIR)/libp2c.a: libp2c.a
X	$(COPY)  libp2c.a     $(LIBDIR)/libp2c.a
X	if [ -f /usr/bin/ranlib -o -f /bin/ranlib ]; then ranlib $(LIBDIR)/libp2c.a; fi
X
X$(MANDIR)/p2c.1: $(MANFILE)
X	$(COPY)  $(MANFILE)   $(MANDIR)/p2c.1
X
X$(INCDIR)/p2c.h: p2c.h
X	$(COPY)  p2c.h        $(INCDIR)/p2c.h
X
X$(HOMEDIR)/p2crc: sys.p2crc
X	$(COPY)  sys.p2crc    $(HOMEDIR)/p2crc
X
X$(HOMEDIR)/loc.p2crc: loc.p2crc
X	$(COPY)  loc.p2crc    $(HOMEDIR)/loc.p2crc
X
X$(HOMEDIR)/system.imp: system.imp
X	$(COPY)  system.imp   $(HOMEDIR)/system.imp
X
X$(HOMEDIR)/system.m2: system.m2
X	$(COPY)  system.m2    $(HOMEDIR)/system.m2
X
X$(HOMEDIR)/turbo.imp: turbo.imp
X	$(COPY)  turbo.imp    $(HOMEDIR)/turbo.imp
X
X$(HOMEDIR)/string.pas: string.pas
X	$(COPY)  string.pas   $(HOMEDIR)/string.pas
X
X
X
X# Miscellaneous
Xtags:
X	etags $(SRCS) $(LIBSRCS) $(MISCSRCS) $(HDRS)
X
Xclean.o:
X	rm $(OBJS)
X
Xclean:
X	rm $(OBJS) $(LIBOBJS) $(PROTOS) p2c
X
Xwc:
X	wc $(SRCS) $(LIBSRCS) trans.h
X
Xtest:
X	echo '"make test" should be used in the outer-level p2c directory.'
X	echo 'Type "cd .." and "make test" again.'
X
END_OF_FILE
if test 5131 -ne `wc -c <'src/Makefile'`; then
    echo shar: \"'src/Makefile'\" unpacked with wrong size!
fi
# end of 'src/Makefile'
fi
if test -f 'src/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/README'\"
else
echo shar: Extracting \"'src/README'\" \(2993 characters\)
sed "s/^X//" >'src/README' <<'END_OF_FILE'
X
XThis directory contains "p2c", a Pascal to C translator.
X
X"p2c"  Copyright 1989  Dave Gillespie
X                       256-80 Caltech
X                       Pasadena CA 91125
X                       daveg@csvax.caltech.edu, cit-vax!daveg
X
X
XThis program is distributed under the terms of the GNU License Agreement.
XSee the file src/COPYING for details.
X
XThe GNU License Agreement restrictions do _not_ apply to code generated
Xby p2c, nor to the p2c run-time files "p2clib.c" and "p2c.h".
X
X
X
XThe file "trans.c" includes an overview of the source files of p2c.
XAll p2c source files include the header "trans.h".
X
XThe file "dir.c" is intended to be modified by the user to install
Xcode for custom translations of certain procedures.  To add your own
Xcustom code to p2c, modify CUSTSRCS and CUSTDEFS in the Makefile,
Xthen recompile dir.c.
X
XThe file "system.imp" (copied to %H/system.imp) contains declarations
Xfor "predefined" functions like "sqrt".  These generally have custom
Xtranslation code in funcs.c.  Functions with irregular syntaxes have
Xtheir symbol table entries built directly in funcs.c; they do not
Xappear here.  The default sys.p2crc causes p2c to read system.imp at
Xthe beginning of every job.
X
XThe file "system.m2" contains declarations for predefined Modula-2
Xfunctions.  It should be substituted for "system.imp" when translating
XModula-2 programs.
X
XThe file "turbo.imp" contains declarations for all the Turbo Pascal
Xstandard units like dos and crt.  (These are very incomplete at
Xpresent.)  The default sys.p2crc causes p2c to read turbo.imp as
Xsoon as any Turbo standard unit is used.
X
XThe file "string.pas" implements the Oregon Software dynamic strings
Xpackage.  These are translated pretty completely into native C strings
Xusing only the FuncMacro mechanism of p2c---no custom C code was
Xwritten to support these functions.
X
XThe file "NOTES" contains the author's current bugs-and-plans list.
XThe file "HISTORY" contains the revision history of the program.
X
XThe "makeproto" program is an independent utility for scanning a large
XC program with old-style declarations and building function prototypes
Xfor all its functions.  The "trans.h" file #includes the prototype
Xfiles for all of p2c.
X
X
XNO WARRANTY:
X   The program in this directory was developed for internal use at
X   Caltech and thus absolutely no guarantee is made that the program
X   will compile or run on other systems or that it will produce correct
X   code.  P2c is _not_ a compiler, it is a translator; it strives to
X   produce correct code but reserves the right to sacrifice correctness
X   in extreme cases for readability in the general case.  P2c is designed
X   to be extended (see funcs.c, hpmods.c and citmods.c for examples), but
X   some of the main code is pretty messy since the translator has grown
X   considerably beyond its original planned scale.  Bug reports are
X   welcome at daveg@csvax.caltech.edu, but I may not have time to respond
X   to them immediately.  Suggestions are welcome, too!
X
END_OF_FILE
if test 2993 -ne `wc -c <'src/README'`; then
    echo shar: \"'src/README'\" unpacked with wrong size!
fi
# end of 'src/README'
fi
if test -f 'src/dir.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/dir.c'\"
else
echo shar: Extracting \"'src/dir.c'\" \(5243 characters\)
sed "s/^X//" >'src/dir.c' <<'END_OF_FILE'
X/* "p2c", a Pascal to C translator.
X   Copyright (C) 1989 David Gillespie.
X   Author's address: daveg@csvax.caltech.edu; 256-80 Caltech/Pasadena CA 91125.
X
XThis program is free software; you can redistribute it and/or modify
Xit under the terms of the GNU General Public License as published by
Xthe Free Software Foundation (any version).
X
XThis program is distributed in the hope that it will be useful,
Xbut WITHOUT ANY WARRANTY; without even the implied warranty of
XMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
XGNU General Public License for more details.
X
XYou should have received a copy of the GNU General Public License
Xalong with this program; see the file COPYING.  If not, write to
Xthe Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */
X
X
X
X#define define_parameters
X#define PROTO_DIR_C
X#include "trans.h"
X
X
X/* This file is user-modifiable.  It is the "directory" of C functions
X   for compiling in-line various Pascal library routines. */
X
X
X
Xextern void setup_module_hp();
Xextern void setup_module_cit();
Xextern void setup_module_tanner();
X
X
X
X
X/* This function is called once when p2c is starting up, before
X   the p2crc file has been read.
X*/
X
Xvoid init_dir()
X{
X
X
X}
X
X
X
X
X
X/* This function is called once when p2c is starting up, after
X   the p2crc file has been read.
X*/
X
Xvoid setup_dir()
X{
X
X
X}
X
X
X
X
X
X/* This procedure is called after reading the import text for a module,
X   where "name" is the module name, in upper-case letters.  Calls to
X   "addmeaning", "makestandardfunc", etc. will annotate the context of
X   the module.  Note that this will be called if the module is searched,
X   even if it is never actually imported.
X*/
X
X#if 0
XStatic void _setup(name, defn)
Xchar *name;
Xint defn;
X{
X    /* this is a dummy procedure which may be called by setup_module */
X}
X#endif
X
X#define _setup(a,b)
X
Xvoid setup_module(name, defn)
Xchar *name;
Xint defn;
X{
X    if (!strcicmp(name, "SYSTEM"))
X	decl_builtins();
X#ifdef CUST1
X    CUST1(name, defn);
X#endif
X#ifdef CUST2
X    CUST2(name, defn);
X#endif
X#ifdef CUST3
X    CUST3(name, defn);
X#endif
X#ifdef CUST4
X    CUST4(name, defn);
X#endif
X#ifdef CUST5
X    CUST5(name, defn);
X#endif
X}
X
X
X
X
X
X/* This procedure is called once after the p2crc file has been
X   read and the built-in parameters have been "fixed".  It should
X   check ranges and add defaults for any newly introduced parameters
X   in the "rctable" (see "trans.h").
X*/
X
Xvoid fix_parameters()
X{
X
X
X}
X
X
X
X
X
X/* This function is called during a traversal of the tree of statements for
X   a procedure.  Ordinarily it returns its argument; it may instead return
X   an arbitrary other statement or sequence of statements, which will then
X   be spliced in to replace the original one.  It may return NULL to delete
X   the statement altogether.
X*/
X
XStmt *fix_statement(sp)
XStmt *sp;
X{
X    return sp;
X}
X
X
X
X
X
X/* This is the analogous function for expression traversals.  It is
X   called after the arguments have been (recursively) fixed and all
X   built-in fixes have been performed.
X*/
X
XExpr *fix_expression(ex, env)
XExpr *ex;
Xint env;
X{
X    return ex;
X}
X
X
X
X
X
X/* This procedure is called when fixing an expression of type
X   EK_BICALL.  It is called before the arguments are fixed.  If
X   it recognizes the BICALL, it should fix the arguments, then
X   return a (possibly modified) fixed expression, which may or
X   may not be a BICALL.  That expression will then be sent to
X   fix_expression() as usual, but other standard fixes will not
X   automatically be performed on it.  If the BICALL is not
X   recognized, the function should return NULL.
X*/
X
XExpr *fix_bicall(ex, env)
XExpr *ex;
Xint env;
X{
X    return NULL;
X}
X
X
X
X
X
X/* This function returns nonzero if the built-in function "name"
X   should be written "if (f(x))" rather than "if (f(x) != 0)"
X   when used as a boolean.  The call does *not* necessarily have
X   to return a 1-or-0 value.
X*/
X
Xint boolean_bicall(name)
Xchar *name;
X{
X    return (!strcmp(name, "strcmp") ||
X            !strcmp(name, "strncmp") ||
X            !strcmp(name, "memcmp") ||
X            !strcmp(name, "feof") ||
X            !strcmp(name, "feoln"));
X}
X
X
X
X
X
X/* The function "name" promises not to change certain of its
X   VAR-style parameters.  For each of arguments i = 0 through 15,
X   if bit 1<<i of the return value of this function is set, and
X   the i'th parameter is a pointer to an object, then the function
X   guarantees not to change that object.
X*/
X
Xunsigned int safemask_bicall(name)
Xchar *name;
X{
X    Symbol *sp;
X
X    sp = findsymbol_opt(name);
X    if (sp) {
X	if (sp->flags & (STRUCTF|STRLAPF))
X	    return ~1;
X	if (sp->flags & (NOSIDEEFF|DETERMF))
X	    return ~0;
X    }
X    if (!strcmp(name, "fwrite") ||
X        !strcmp(name, "memchr"))
X        return 1;
X    if (!strcmp(name, "memcpy") ||
X        !strcmp(name, "memmove"))
X        return 2;
X    if (!strcmp(name, "memcmp"))
X        return 3;
X    if (!strcmp(name, "sprintf") ||
X        !strcmp(name, "fprintf"))
X        return ~1;
X    if (!strcmp(name, "printf"))
X        return ~0;
X    return 0;
X}
X
X
X
X
X
X/* The function "name" has side effects that could affect other variables
X   in the program besides those that are explicitly mentioned.
X*/
X
Xint sideeffects_bicall(name)
Xchar *name;
X{
X    return 0;
X}
X
X
X
X
X
X
X/* End. */
X
X
X
END_OF_FILE
if test 5243 -ne `wc -c <'src/dir.c'`; then
    echo shar: \"'src/dir.c'\" unpacked with wrong size!
fi
# end of 'src/dir.c'
fi
if test -f 'src/hpmods.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/hpmods.c'\"
else
echo shar: Extracting \"'src/hpmods.c'\" \(3133 characters\)
sed "s/^X//" >'src/hpmods.c' <<'END_OF_FILE'
X/* "p2c", a Pascal to C translator.
X   Copyright (C) 1989 David Gillespie.
X   Author's address: daveg@csvax.caltech.edu; 256-80 Caltech/Pasadena CA 91125.
X
XThis program is free software; you can redistribute it and/or modify
Xit under the terms of the GNU General Public License as published by
Xthe Free Software Foundation (any version).
X
XThis program is distributed in the hope that it will be useful,
Xbut WITHOUT ANY WARRANTY; without even the implied warranty of
XMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
XGNU General Public License for more details.
X
XYou should have received a copy of the GNU General Public License
Xalong with this program; see the file COPYING.  If not, write to
Xthe Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */
X
X
X
X#define PROTO_HPMODS_C
X#include "trans.h"
X
X
X
X
X
X/* FS functions */
X
X
XStatic Stmt *proc_freadbytes()
X{
X    Expr *ex, *ex2, *vex, *fex;
X    Type *type;
X
X    if (!skipopenparen())
X	return NULL;
X    fex = p_expr(tp_text);
X    if (!skipcomma())
X	return NULL;
X    vex = p_expr(NULL);
X    if (!skipcomma())
X	return NULL;
X    ex2 = p_expr(tp_integer);
X    skipcloseparen();
X    type = vex->val.type;
X    ex = makeexpr_bicall_4("fread", tp_integer,
X                           makeexpr_addr(vex),
X                           convert_size(type, ex2, "FREADBYTES"),
X                           makeexpr_long(1),
X                           copyexpr(fex));
X    if (checkeof(fex)) {
X        ex = makeexpr_bicall_2(name_SETIO, tp_void,
X                               makeexpr_rel(EK_EQ, ex, makeexpr_long(1)),
X                               makeexpr_long(30));
X    }
X    return wrapopencheck(makestmt_call(ex), fex);
X}
X
X
X
X
XStatic Stmt *proc_fwritebytes()
X{
X    Expr *ex, *ex2, *vex, *fex;
X    Type *type;
X
X    if (!skipopenparen())
X	return NULL;
X    fex = p_expr(tp_text);
X    if (!skipcomma())
X	return NULL;
X    vex = p_expr(NULL);
X    if (!skipcomma())
X	return NULL;
X    ex2 = p_expr(tp_integer);
X    skipcloseparen();
X    type = vex->val.type;
X    ex = makeexpr_bicall_4("fwrite", tp_integer,
X                           makeexpr_addr(vex),
X                           convert_size(type, ex2, "FWRITEBYTES"),
X                           makeexpr_long(1),
X                           copyexpr(fex));
X    if (checkfilewrite) {
X        ex = makeexpr_bicall_2(name_SETIO, tp_void,
X                               makeexpr_rel(EK_EQ, ex, makeexpr_long(1)),
X                               makeexpr_long(3));
X    }
X    return wrapopencheck(makestmt_call(ex), fex);
X}
X
X
X
X
X
X
X
X
X
X
X/* SYSGLOBALS */
X
X
XStatic void setup_sysglobals()
X{
X    Symbol *sym;
X
X    sym = findsymbol("SYSESCAPECODE");
X    if (sym->mbase)
X        strchange(&sym->mbase->name, name_ESCAPECODE);
X    sym = findsymbol("SYSIORESULT");
X    if (sym->mbase)
X        strchange(&sym->mbase->name, name_IORESULT);
X}
X
X
X
X
X
X
X
X
Xvoid hpmods(name, defn)
Xchar *name;
Xint defn;
X{
X    if (!strcmp(name, "FS")) {
X        makespecialproc("freadbytes", proc_freadbytes);
X        makespecialproc("fwritebytes", proc_fwritebytes);
X    } else if (!strcmp(name, "SYSGLOBALS")) {
X        setup_sysglobals();
X    }
X}
X
X
X
X
X/* End. */
X
X
X
END_OF_FILE
if test 3133 -ne `wc -c <'src/hpmods.c'`; then
    echo shar: \"'src/hpmods.c'\" unpacked with wrong size!
fi
# end of 'src/hpmods.c'
fi
if test -f 'src/system.imp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/system.imp'\"
else
echo shar: Extracting \"'src/system.imp'\" \(3784 characters\)
sed "s/^X//" >'src/system.imp' <<'END_OF_FILE'
X
X{ Declarations for Pascal built-in objects }
X
X{ Note: All functions with unusual syntaxes are not included here }
X
X
X{*IgnoreNonAlpha=0}   { If Language=UCSD, make sure we can parse "__module" }
X
X
X__module SYSTEM;   {PERMANENT}
X
X
X__export
X
X{ Standard Pascal functions }
Xfunction  arctan(x : longreal) : longreal;
Xfunction  cos(x : longreal) : longreal;
Xfunction  exp(x : longreal) : longreal;
Xfunction  ln(x : longreal) : longreal;
Xprocedure mark(var p);
Xfunction  odd(i : integer) : boolean;
Xprocedure release(var p);
Xfunction  round(x : longreal) : integer;
Xfunction  sin(x : longreal) : longreal;
Xfunction  sqrt(x : longreal) : longreal;
Xfunction  trunc(x : longreal) : integer;
X
X
X
X{ HP Pascal extensions }
Xfunction  binary(s : string) : integer;
Xprocedure gotoxy(x, y : integer);
Xfunction  hex(s : string) : integer;
Xfunction  lastpos(anyvar f : text) : integer;
Xfunction  linepos(var f : text) : integer;
Xprocedure moveleft(anyvar s, d : integer; i : integer);
Xprocedure moveright(anyvar s, d : integer; i : integer);
Xfunction  octal(s : string) : integer;
Xfunction  str(s : string; i, j : integer) : string;
Xfunction  strlen(s : string) : integer;
Xfunction  strltrim(s : string) : string;
Xfunction  strmax(s : string) : integer;
Xfunction  strpos(s, s2 : string) : integer;
Xfunction  strrpt(s : string; i : integer) : string;
Xfunction  strrtrim(s : string) : string;
X
X
X
X{ Turbo/UCSD Pascal extensions }
Xfunction  copy(s : string; i, j : integer) : string;
Xprocedure delete(var s; i, j : integer);
Xfunction  frac(x : longreal) : longreal;
Xprocedure freemem(var p);
Xprocedure getmem(var p; i : integer);
Xprocedure insert(s : string; var s2; i : integer);
Xfunction  length(s : string) : integer;
Xfunction  log(x : longreal) : longreal;
Xfunction  maxavail : integer;
Xfunction  memavail : integer;
Xprocedure move(var s, d; i : integer);
Xfunction  paramcount : integer;
Xfunction  paramstr(i : integer) : string;
Xfunction  pos(s, s2 : string) : integer;
Xfunction  ptr(i, j : integer) : pointer;
Xfunction  pwroften(r : longreal) : longreal;
Xfunction  swap(i : integer) : integer;
Xfunction  upcase(c : char) : char;
X
X
X{ Turbo standard variables }
X
Xvar
X   HeapPtr, FreePtr: pointer;
X
X
X{ Oregon Software Pascal-2 extensions }
X{FuncMacro p2_inew(n) = malloc(n)}
X{FuncMacro p2_new(x,n) = (*x = Malloc(n))}
X{FuncMacro p2_dispose(x,n) = Free(*x)}
Xprocedure noioerror(var f);
Xfunction ioerror(var f) : boolean;
Xfunction iostatus(var f) : integer;
X{FuncMacro exitst(s) = exit(s)}
Xprocedure exitst(s : integer);
X{FuncMacro P_getcmdline(low,high,line,len)=(*len=P_getcmdline(low,high,line))}
Xprocedure P_getcmdline(var line : array [low..high : integer] of char; var len : integer);
Xprocedure TimeStamp(var day, month, year, hour, min, sec : integer);
X
X
X{ VAX Pascal extensions }
Xfunction  expo(r : real) : integer;
Xfunction  index(s, s2 : string) : integer;
Xfunction  pad(s : string; padchar : char; size : integer) : string;
Xfunction  substr(s : string; i, j : integer) : string;
Xfunction  uround(x : longreal) : integer;
Xfunction  utrunc(x : longreal) : integer;
X
X
X
X{ MPW Pascal extensions }
Xfunction  arccos(r : longreal) : longreal;
Xfunction  arcsin(r : longreal) : longreal;
Xfunction  arctanh(r : longreal) : longreal;
Xfunction  cosh(r : longreal) : longreal;
Xfunction  exp10(r : longreal) : longreal;
Xfunction  log10(r : longreal) : longreal;
Xfunction  scaneq(limit : integer; ch : char; var s : univ integer) : integer;
Xfunction  scanne(limit : integer; ch : char; var s : univ integer) : integer;
Xfunction  sinh(r : longreal) : longreal;
Xfunction  tan(r : longreal) : longreal;
Xfunction  tanh(r : longreal) : longreal;
X
X
X{ SUN Pascal extensions }
Xtype alfa = packed array [1..10] of char;
X{FuncMacro argc = P_argc}
Xfunction  argc : integer;
X{FuncMacro null = 0}
Xprocedure null;
X
X
X
Xend.
X
X
X
END_OF_FILE
if test 3784 -ne `wc -c <'src/system.imp'`; then
    echo shar: \"'src/system.imp'\" unpacked with wrong size!
fi
# end of 'src/system.imp'
fi
echo shar: End of archive 2 \(of 32\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 32 archives.
    echo "Now see PACKNOTES and the README"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
