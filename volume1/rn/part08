Date: Tue, 7 May 85 14:05:44 pdt
From: allegra!sdcrdcf!RDCF.SDC.UUCP!lwall (Larry Wall)
Newsgroups: mod.sources
Subject: rn version 4.3 (kit 8 of 9)
Reply-To: lwall@sdcrdcf.UUCP
Organization: System Development Corporation R&D, Santa Monica

#! /bin/sh

# Make a new directory for the rn sources, cd to it, and run kits 1 thru 9 
# through sh.  When all 9 kits have been run, read README.

echo "This is rn kit 8 (of 9).  If kit 8 is complete, the line"
echo '"'"End of kit 8 (of 9)"'" will echo at the end.'
echo ""
export PATH || (echo "You didn't use sh, you clunch." ; kill $$)
echo Extracting addng.c
cat >addng.c <<'!STUFFY!FUNK!'
/* $Header: addng.c,v 4.3 85/05/01 11:34:41 lwall Exp $
 *
 * $Log:	addng.c,v $
 * Revision 4.3  85/05/01  11:34:41  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

#include "EXTERN.h"
#include "common.h"
#include "rn.h"
#include "ngdata.h"
#include "last.h"
#include "util.h"
#include "intrp.h"
#include "only.h"
#include "rcstuff.h"
#include "INTERN.h"
#include "addng.h"

void
addng_init()
{
    ;
}

#ifdef FINDNEWNG
/* generate a list of new newsgroups from active file */

bool
newlist(munged,checkinlist)
bool munged;				/* are we scanning the whole file? */
bool checkinlist;
{
    char *tmpname;
    register char *s;
    long birthof();

    tmpname = savestr(filexp("/tmp/rnew.%$"));
    tmpfp = fopen(tmpname,"w");
    if (tmpfp == Nullfp) {
	printf(cantcreate,tmpname) FLUSH;
	return FALSE;
    }
    while (fgets(buf,LBUFLEN,actfp) != Nullch) {
	if (s = index(buf,' ')) {
	    *s++ = '\0';
	    if (strnEQ(buf,"to.",3))
		continue;
	    if (find_ng(buf) == nextrcline &&
		    (checkinlist ?
			(inlist(buf)) :
			(birthof(buf,(ART_NUM)atol(s)) > lasttime)
		    )
		) {
					/* if not in .newsrc and younger */
					/* than the last time we checked */
		fprintf(tmpfp,"%s\n",buf);
					/* then remember said newsgroup */
	    }
#ifdef FASTNEW
	    else {			/* not really a new group */
		if (!munged) {		/* did we assume not munged? */
		    fclose(tmpfp);	/* then go back, knowing that */
		    UNLINK(tmpname);
		    free(tmpname);
		    return TRUE;	/* active file was indeed munged */
		}
	    }
#endif
	}
#ifdef DEBUGGING
	else
	    printf("Bad active record: %s\n",buf) FLUSH;
#endif
    }

    /* we have successfully generated the list */

    fclose(tmpfp);
    tmpfp = fopen(tmpname,"r");
    UNLINK(tmpname);			/* be nice to the world */
    if (tmpfp == Nullfp) {
	printf(cantopen,tmpname) FLUSH;
	return FALSE;
    }
    while (fgets(buf,LBUFLEN,tmpfp) != Nullch) {
	buf[strlen(buf)-1] = '\0';
	get_ng(buf,TRUE);		/* add newsgroup, maybe */
    }
    fclose(tmpfp);			/* be nice to ourselves */
    free(tmpname);
    return FALSE;			/* do not call us again */
}

/* return creation time of newsgroup */

long
birthof(ngnam,ngsize)
char *ngnam;
ART_NUM ngsize;
{
    char tst[128];
 
    sprintf(tst, ngsize ? "%s/%s/1" : "%s/%s" ,spool,getngdir(ngnam));
    if (stat(tst,&filestat) < 0)
	return 0L;			/* not there, assume ancient */
    else
	return filestat.st_mtime;
}

bool
scanactive()
{
    NG_NUM oldnext = nextrcline;	/* remember # lines in newsrc */

    fseek(actfp,0L,0);
    newlist(TRUE,TRUE);
    if (nextrcline != oldnext) {	/* did we add any new groups? */
	return TRUE;
    }
    return FALSE;
}

#endif

!STUFFY!FUNK!
echo Extracting Pnews.1
cat >Pnews.1 <<'!STUFFY!FUNK!'
''' $Header: Pnews.1,v 4.3 85/05/01 11:33:50 lwall Exp $
''' 
''' $Log:	Pnews.1,v $
''' Revision 4.3  85/05/01  11:33:50  lwall
''' Baseline for release with 4.3bsd.
''' 
.de Sh
.br
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.ie n \{\
.tr \(bs-\*(Tr
.ds -- \(bs-
.if (\n(.H=4u)&(1m=24u) .ds -- \(bs\h'-12u'\(bs\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(bs\h'-12u'\(bs\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
'br\}
.TH PNEWS 1 LOCAL
.SH NAME
Pnews - a program for posting news articles
.SH SYNOPSIS
.B Pnews newsgroup title
.br
  or
.br
.B Pnews -h headerfile [oldarticle]
.br
  or
.br
.B Pnews
.SH DESCRIPTION
Pnews is a friendly interface for posting news articles.
It will ask several questions, then allow you to enter your article,
and then post it using the inews(1) program.
If you type h and a carriage return at any point,
.I Pnews
will tell you what it wants to know.
.PP
The -h form is used when invoked from
.IR rn .
If your editor can edit multiple files, and you want the article to which
you are replying to show up as an alternate file, define the environment
variable NEWSPOSTER as \*(L"Pnews -h %h %A\*(R".
You can also modify the the NEWSHEADER environment variable to change the
header file that
.I rn
passes to Pnews.
.SH ENVIRONMENT
.IP DOTDIR 8
Where to find your dot files, if they aren't in your home directory.
.Sp
Default: $HOME
.IP EDITOR 8
The editor you want to use, if VISUAL is undefined.
.Sp
Default: whatever your news administrator installed, usually vi.
.IP HOME 8
Your home directory.
.Sp
Default: $LOGDIR
.IP LOGDIR 8
Your home directory if HOME is undefined.
.IP LOGNAME 8
Your login name, if USER is undefined.
.Sp
Default: value of \*(L"whoami\*(R".
.IP NAME 8
Your full name.
.Sp
Default: name from /etc/passwd, or ~/.fullname.
.IP ORGANIZATION 8
Either the name of your organization, or the name of a file containing the
name of your organization.
.Sp
Default: whatever your news administrator chose.
.IP USER 8
Your login name.
.Sp
Default: $LOGNAME
.IP VISUAL 8
The editor you want to use.
.Sp
Default: $EDITOR
.SH FILES
/tmp/article$$
.br
~/dead.article
.SH SEE ALSO
rn(1), Rnmail(1), inews(1)
.SH DIAGNOSTICS
.SH BUGS
Not the speediest program in the world, but maybe that's a blessing to the
net.
!STUFFY!FUNK!
echo Extracting Rnmail.1
cat >Rnmail.1 <<'!STUFFY!FUNK!'
''' $Header: Rnmail.1,v 4.3 85/05/01 11:34:28 lwall Exp $
''' 
''' $Log:	Rnmail.1,v $
''' Revision 4.3  85/05/01  11:34:28  lwall
''' Baseline for release with 4.3bsd.
''' 
.de Sh
.br
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.ie n \{\
.tr \(bs-\*(Tr
.ds -- \(bs-
.if (\n(.H=4u)&(1m=24u) .ds -- \(bs\h'-12u'\(bs\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(bs\h'-12u'\(bs\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
'br\}
.TH RNMAIL 1 LOCAL
.SH NAME
Rnmail - a program for replying via mail
.SH SYNOPSIS
.B Rnmail destination_list
.br
  or
.br
.B Rnmail -h headerfile [oldarticle]
.br
  or
.br
.B Rnmail
.SH DESCRIPTION
Rnmail is a friendly interface for mailing replies to news articles.
It will ask several questions, then allow you to enter your letter,
and then mail it off.
If you type h and a carriage return at any point,
.I Rnmail
will tell you what it wants to know.
.PP
The -h form is used when invoked from
.IR rn .
If your editor can edit multiple files, and you want the article to which
you are replying to show up as an alternate file, define the environment
variable MAILPOSTER as \*(L"Rnmail -h %h %A\*(R".
You can also modify the the MAILHEADER environment variable to change the
header file that
.I rn
passes to Rnmail.
.SH ENVIRONMENT
.IP EDITOR 8
The editor you want to use, if VISUAL is undefined.
.Sp
Default: whatever your news administrator installed, usually vi.
.IP HOME 8
Your home directory.
.Sp
Default: $LOGDIR
.IP LOGDIR 8
Your home directory if HOME is undefined.
.IP LOGNAME 8
Your login name, if USER is undefined.
.Sp
Default: value of \*(L"whoami\*(R".
.IP ORGANIZATION 8
Either the name of your organization, or the name of a file containing the
name of your organization.
.Sp
Default: whatever your news administrator chose.
.IP USER 8
Your login name.
.Sp
Default: $LOGNAME
.IP VISUAL 8
The editor you want to use.
.Sp
Default: $EDITOR
.SH FILES
/tmp/rnmail$$
.br
~/dead.letter
.SH SEE ALSO
rn(1), Pnews(1), mail(1)
.SH DIAGNOSTICS
.SH BUGS
Uses /bin/mail in the absence of sendmail.
!STUFFY!FUNK!
echo Extracting only.c
cat >only.c <<'!STUFFY!FUNK!'
/* $Header: only.c,v 4.3 85/05/01 11:45:21 lwall Exp $
 *
 * $Log:	only.c,v $
 * Revision 4.3  85/05/01  11:45:21  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

#include "EXTERN.h"
#include "common.h"
#include "search.h"
#include "util.h"
#include "final.h"
#include "ngsrch.h"
#include "INTERN.h"
#include "only.h"

void
only_init()
{
    ;
}

void
setngtodo(pat)
char *pat;
{
    char *s;

#ifdef ONLY
    if (!*pat)
	return;
    if (maxngtodo < NGMAX) {
	ngtodo[maxngtodo] = savestr(pat);
#ifdef SPEEDOVERMEM
#ifndef lint
	compextodo[maxngtodo] = (COMPEX*)safemalloc(sizeof(COMPEX));
#endif lint
	init_compex(compextodo[maxngtodo]);
	compile(compextodo[maxngtodo],pat,TRUE,TRUE);
	if ((s = ng_comp(compextodo[maxngtodo],pat,TRUE,TRUE)) != Nullch) {
					    /* compile regular expression */
	    printf("\n%s\n",s) FLUSH;
	    finalize(1);
	}
#endif
	maxngtodo++;
    }
#else
    notincl("o");
#endif
}

/* if command line list is non-null, is this newsgroup wanted? */

bool
inlist(ngnam)
char *ngnam;
{
#ifdef ONLY
    register int i;
#ifdef SPEEDOVERMEM

    if (maxngtodo == 0)
	return TRUE;
    for (i=0; i<maxngtodo; i++) {
	if (execute(compextodo[i],ngnam))
	    return TRUE;
    }
    return FALSE;
#else
    COMPEX ilcompex;
    char *s;

    if (maxngtodo == 0)
	return TRUE;
    init_compex(&ilcompex);
    for (i=0; i<maxngtodo; i++) {
	if ((s = ng_comp(&ilcompex,ngtodo[i],TRUE,TRUE)) != Nullch) {
					    /* compile regular expression */
	    printf("\n%s\n",s) FLUSH;
	    finalize(1);
	}
	
	if (execute(&ilcompex,ngnam) != Nullch) {
	    free_compex(&ilcompex);
	    return TRUE;
	}
    }
    free_compex(&ilcompex);
    return FALSE;
#endif
#else
    return TRUE;
#endif
}

#ifdef ONLY
void
end_only()
{
    if (maxngtodo) {			/* did they specify newsgroup(s) */
	int whicharg;

#ifdef VERBOSE
	IF(verbose)
	    printf("\nRestriction %s%s removed.\n",ngtodo[0],
		maxngtodo > 1 ? ", etc." : nullstr) FLUSH;
	ELSE
#endif
#ifdef TERSE
	    fputs("\nExiting \"only\".\n",stdout) FLUSH;
#endif
	for (whicharg = 0; whicharg < maxngtodo; whicharg++) {
	    free(ngtodo[whicharg]);
#ifdef SPEEDOVERMEM
	    free_compex(compextodo[whicharg]);
#ifndef lint
	    free((char*)compextodo[whicharg]);
#endif lint
#endif
	}
	maxngtodo = 0;
    }
}
#endif
!STUFFY!FUNK!
echo Extracting backpage.c
cat >backpage.c <<'!STUFFY!FUNK!'
/* $Header: backpage.c,v 4.3 85/05/01 11:36:03 lwall Exp $
 *
 * $Log:	backpage.c,v $
 * Revision 4.3  85/05/01  11:36:03  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

#include "EXTERN.h"
#include "common.h"
#include "intrp.h"
#include "final.h"
#include "INTERN.h"
#include "backpage.h"

ART_LINE maxindx = -1;
long lseek();

void
backpage_init()
{
    char *varyname;
    
    varyname = filexp(VARYNAME);
    close(creat(varyname,0600));
    varyfd = open(varyname,2);
    UNLINK(varyname);
    if (varyfd < 0) {
	printf(cantopen,varyname) FLUSH;
	sig_catcher(0);
    }
    
}

/* virtual array read */

ART_POS
vrdary(indx)
ART_LINE indx;
{
    int subindx;
    long offset;

#ifdef DEBUGGING
    if (indx > maxindx) {
	printf("vrdary(%ld) > %ld\n",(long)indx, (long)maxindx) FLUSH;
	return 0;
    }
#endif
    if (indx < 0)
	return 0;
    subindx = indx % VARYSIZE;
    offset = (indx - subindx) * sizeof(varybuf[0]);
    if (offset != oldoffset) {
	if (oldoffset >= 0) {
#ifndef lint
	    (void)lseek(varyfd,oldoffset,0);
	    write(varyfd, (char *)varybuf,sizeof(varybuf));
#endif lint
	}
#ifndef lint
	(void)lseek(varyfd,offset,0);
	read(varyfd,(char *)varybuf,sizeof(varybuf));
#endif lint
	oldoffset = offset;
    }
    return varybuf[subindx];
}

/* write to virtual array */

void
vwtary(indx,newvalue)
ART_LINE indx;
ART_POS newvalue;
{
    int subindx;
    long offset;

#ifdef DEBUGGING
    if (indx < 0)
	printf("vwtary(%ld)\n",(long)indx) FLUSH;
    if (!indx)
	maxindx = 0;
    if (indx > maxindx) {
	if (indx != maxindx + 1)
	    printf("indx skipped %d-%d\n",maxindx+1,indx-1) FLUSH;
	maxindx = indx;
    }
#endif
    subindx = indx % VARYSIZE;
    offset = (indx - subindx) * sizeof(varybuf[0]);
    if (offset != oldoffset) {
	if (oldoffset >= 0) {
#ifndef lint
	    (void)lseek(varyfd,oldoffset,0);
	    write(varyfd,(char *)varybuf,sizeof(varybuf));
#endif lint
	}
#ifndef lint
	(void)lseek(varyfd,offset,0);
	read(varyfd,(char *)varybuf,sizeof(varybuf));
#endif lint
	oldoffset = offset;
    }
    varybuf[subindx] = newvalue;
}

!STUFFY!FUNK!
echo Extracting makedepend.SH
cat >makedepend.SH <<'!STUFFY!FUNK!'
case $CONFIG in
    '') . config.sh ;;
esac
echo "Extracting makedepend (with variable substitutions)"
$spitshell >makedepend <<!GROK!THIS!
$startsh
# $Header: makedepend.SH,v 4.3 85/05/01 11:42:26 lwall Exp $
#
# $Log:	makedepend.SH,v $
# Revision 4.3  85/05/01  11:42:26  lwall
# Baseline for release with 4.3bsd.
# 

export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)

$cat /dev/null >.deptmp
$echo "(Note: this is going to take a while.)"
$rm -f X*.c
for file in *.c; do
    filebase=\`basename \$file .c\`
    $echo "Finding dependencies for \$filebase.o."
    $sed -n <\$file >X\$file \\
	-e "/^\${filebase}_init(/q" \\
	-e '/^#/{' \\
	-e 's|/\*.*$||' \\
	-e p \\
	-e '}'
    $cpp X\$file | $sed  \\
	-e '/^# *[0-9]/!d' \\
	-e 's/^.*"\(.*\)".*\$/'\$filebase'.o: \1/' \\
	-e 's|: \./|: |' \\
	-e 's|: X|: |' | \\
	$uniq | $sort | $uniq >> .deptmp
done

for file in *.SH; do
    $echo \`basename \$file .SH\`: \$file config.sh \; /bin/sh \$file >> .deptmp
done

$sed <Makefile >Makefile.new -e '1,/^# AUTOMATICALLY/!d'

if $test -s .deptmp; then
    echo "Updating Makefile..."
    echo "# If this runs make out of memory, delete /usr/include lines." >>Makefile.new
    $cat .deptmp >>Makefile.new
else
    $echo "You don't seem to have a proper C preprocessor.  Using grep instead."
    $egrep '^#include ' *.c *.h >.deptmp
    echo "Updating Makefile..."
    <.deptmp $sed -n 's|c:#include "\(.*\)".*\$\$|o: \1|p' >> Makefile.new
    <.deptmp $sed -n 's|c:#include <\(.*\)>.*\$\$|o: /usr/include/\1|p' >> Makefile.new
    <.deptmp $sed -n 's|h:#include "\(.*\)".*\$\$|h: \1|p' >> Makefile.new
    <.deptmp $sed -n 's|h:#include <\(.*\)>.*\$\$|h: /usr/include/\1|p' >> Makefile.new
fi
$mv Makefile Makefile.old
$mv Makefile.new Makefile
$echo "# WARNING: Put nothing here or make depend will gobble it up!" >> Makefile
rm .deptmp X*.c

!GROK!THIS!
$eunicefix makedepend
chmod 755 makedepend
!STUFFY!FUNK!
echo Extracting subs.help.SH
cat >subs.help.SH <<'!STUFFY!FUNK!'
case $CONFIG in
    '') . config.sh ;;
esac
echo "Extracting subs.help (with variable substitutions)"
$spitshell >subs.help <<!GROK!THIS!
$startsh
# $Header: subs.help.SH,v 4.3 85/05/01 11:50:50 lwall Exp $
# 
# $Log:	subs.help.SH,v $
# Revision 4.3  85/05/01  11:50:50  lwall
# Baseline for release with 4.3bsd.
# 

$pager <<'EOT'
Valid substitutions are:

a	Current article number
A	Full name of current article (%P/%c/%a)
b	Destination of last save command, often a mailbox
B	Bytes to ignore at beginning of last saved article
c	Current newsgroup, directory form
C	Current newsgroup, dot form
d	Full name of newsgroup directory (%P/%c)
D	Distribution line from current article\
f	Who the current article is from
F	Newsgroups to followup to (from Newsgroups and Followup-To)
h	(This help message)
H	Host name (yours)
i	Message-I.D. line from current article, with <>
I	Reference indicator mark (see -F switch)
l	News administrator's login name, if any
L	Login name (yours)
m	Current mode, first letter of (init,newsgroup,article,pager,misc)
M	Number of article marked with M
n	Newsgroups from current article
N	Full name (yours)
o	Organization (yours)
O	Original working directory (where you ran rn from)
p	Your private news directory (from -d)
P	Public news spool directory
r	Last reference (parent article id)
R	References list for followup article
s	Subject, with all Re's and (nf)'s stripped off
S	Subject, with one Re stripped off\
t	New To line derived from From and Reply-To (Internet format)
T	New To line derived from Path
u	Number of unread articles
U	Number of unread articles not counting current article
x	News library directory
X	Rn library directory
z	Length of current article in bytes
~	Your home directory
.	Directory containing . files
$	Current process number
/	Last search string
ESC	Run preceding command through % interpretation
EOT
!GROK!THIS!
$eunicefix subs.help
chmod 755 subs.help
!STUFFY!FUNK!
echo Extracting ndir.c
cat >ndir.c <<'!STUFFY!FUNK!'
/* $Header: ndir.c,v 4.3 85/05/01 11:42:55 lwall Exp $
 *
 * $Log:	ndir.c,v $
 * Revision 4.3  85/05/01  11:42:55  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

#include "EXTERN.h"
#include "common.h"
#include "INTERN.h"
#include "ndir.h"

#ifdef USENDIR
/*
 * support for Berkeley directory reading routine on a V7 file system
 */

/*
 * open a directory.
 */
DIR *
opendir(name)
char *name;
{
	register DIR *dirp;
	register int fd;

	if ((fd = open(name, 0)) == -1)
		return NULL;
	if ((dirp = (DIR *)malloc(sizeof(DIR))) == NULL) {
		close (fd);
		return NULL;
	}
	dirp->dd_fd = fd;
	dirp->dd_loc = 0;
	return dirp;
}

/*
 * read an old style directory entry and present it as a new one
 */
#ifndef pyr
#define	ODIRSIZ	14

struct	olddirect {
	short	od_ino;
	char	od_name[ODIRSIZ];
};
#else	an Pyramid in the ATT universe
#define	ODIRSIZ	248

struct	olddirect {
	long	od_ino;
	short	od_fill1, od_fill2;
	char	od_name[ODIRSIZ];
};
#endif

/*
 * get next entry in a directory.
 */
struct direct *
readdir(dirp)
register DIR *dirp;
{
	register struct olddirect *dp;
	static struct direct dir;

	for (;;) {
		if (dirp->dd_loc == 0) {
			dirp->dd_size = read(dirp->dd_fd, dirp->dd_buf,
			    DIRBLKSIZ);
			if (dirp->dd_size <= 0)
				return NULL;
		}
		if (dirp->dd_loc >= dirp->dd_size) {
			dirp->dd_loc = 0;
			continue;
		}
		dp = (struct olddirect *)(dirp->dd_buf + dirp->dd_loc);
		dirp->dd_loc += sizeof(struct olddirect);
		if (dp->od_ino == 0)
			continue;
		dir.d_ino = dp->od_ino;
		strncpy(dir.d_name, dp->od_name, ODIRSIZ);
		dir.d_name[ODIRSIZ] = '\0'; /* insure null termination */
		dir.d_namlen = strlen(dir.d_name);
		dir.d_reclen = DIRSIZ(&dir);
		return (&dir);
	}
}

/*
 * close a directory.
 */
void
closedir(dirp)
register DIR *dirp;
{
	close(dirp->dd_fd);
	dirp->dd_fd = -1;
	dirp->dd_loc = 0;
	free(dirp);
}
#endif USENDIR
!STUFFY!FUNK!
echo Extracting header.c.1.pat
cat >header.c.1.pat <<'!STUFFY!FUNK!'
NOTE: the preceding context may be different under 2.10.2, but you should
be able to figure it out anyway.

*** header.old.c	Fri Apr 27 11:30:49 1984
--- header.c	Mon Feb 27 10:44:03 1984
***************
*** 107,112
  #define NUMLINES	19
  #define KEYWORDS	20
  #define APPROVED	21
  #define OTHER		99
  
  char *malloc();

--- 107,115 -----
  #define NUMLINES	19
  #define KEYWORDS	20
  #define APPROVED	21
+ #ifdef DOXREFS
+ #define XREF		98
+ #endif DOXREFS
  #define OTHER		99
  
  char *malloc();
***************
*** 201,206
  				seenrelay = 1;
  			}
  			break;
  		case OTHER:
  			if (unreccnt < NUNREC) {
  				hp->unrec[unreccnt] = malloc(strlen(bfr) + 1);

--- 204,214 -----
  				seenrelay = 1;
  			}
  			break;
+ #ifdef DOXREFS
+ 		case XREF:
+ 			getfield(hp->xref);
+ 			break;
+ #endif DOXREFS
  		case OTHER:
  			if (unreccnt < NUNREC) {
  				hp->unrec[unreccnt] = malloc(strlen(bfr) + 1);
***************
*** 398,403
  		return KEYWORDS;
  	if (its("Approved: "))
  		return APPROVED;
  	return OTHER;
  }
  

--- 406,415 -----
  		return KEYWORDS;
  	if (its("Approved: "))
  		return APPROVED;
+ #ifdef DOXREFS
+ 	if (its("Xref: "))
+ 		return XREF;
+ #endif DOXREFS
  	return OTHER;
  }
  
***************
*** 507,512
  		fprintf(fp, "Keywords: %s\n", hp->keywords);
  	if (*hp->approved)
  		fprintf(fp, "Approved: %s\n", hp->approved);
  	for (iu = 0; iu < NUNREC; iu++) {
  		if (hp->unrec[iu])
  			fprintf(fp, "%s", &hp->unrec[iu][0]);

--- 519,528 -----
  		fprintf(fp, "Keywords: %s\n", hp->keywords);
  	if (*hp->approved)
  		fprintf(fp, "Approved: %s\n", hp->approved);
+ #ifdef DOXREFS
+ 	if (wr == 1 && *hp->xref)
+ 		fprintf(fp, "Xref: %s\n", hp->xref);
+ #endif DOXREFS
  	for (iu = 0; iu < NUNREC; iu++) {
  		if (hp->unrec[iu])
  			fprintf(fp, "%s", &hp->unrec[iu][0]);
!STUFFY!FUNK!
echo Extracting ng.help.SH
cat >ng.help.SH <<'!STUFFY!FUNK!'
case $CONFIG in
    '') . config.sh ;;
esac
echo "Extracting ng.help (with variable substitutions)"
$spitshell >ng.help <<!GROK!THIS!
$startsh
# $Header: ng.help.SH,v 4.3 85/05/01 11:44:34 lwall Exp $
# 
# $Log:	ng.help.SH,v $
# Revision 4.3  85/05/01  11:44:34  lwall
# Baseline for release with 4.3bsd.
# 

$pager <<'EOT'
Newsgroup Selection commands:

y,SP	Do this newsgroup now.
.cmd	Do this newsgroup, executing cmd as first command.
=	Equivalent to .=<carriage return>.
u	Unsubscribe from this newsgroup.
c	Catch up (mark this newsgroup all read).

n	Go to the next newsgroup with unread news.
N	Go to the next newsgroup.
p	Go to the previous newsgroup with unread news.
P	Go to the previous newsgroup.
-	Go to the previously displayed newsgroup.
1	Go to the first newsgroup.
^	Go to the first newsgroup with unread news.
$	Go to the last newsgroup.
g name	Go to the named newsgroup.  Subscribe to new newsgroups this way too.
/pat	Search forward for newsgroup matching pattern.
?pat	Search backward for newsgroup matching pattern.
	(Use * and ? style patterns.  Append r to include read newsgroups.)
l pat	List unsubscribed newsgroups containing pattern.
m name	Move named newsgroup elsewhere (no name moves current newsgroup).
o pat	Only display newsgroups matching pattern.  Omit pat to unrestrict.
a pat	Like o, but also scans for unsubscribed newsgroups matching pattern.
L	List current .newsrc.
&	Print current command-line switch settings.
&switch {switch}
	Set (or unset) more command-line switches.
&&	Print current macro definitions.
&&def	Define a new macro.
!cmd	Shell escape.
q	Quit rn.
^K	Edit the global KILL file.  Use commands like /pattern/j to suppress
	pattern in every newsgroup.
v	Print version.
EOT
!GROK!THIS!
$eunicefix ng.help
chmod 755 ng.help
!STUFFY!FUNK!
echo Extracting header.c.2.pat
cat >header.c.2.pat <<'!STUFFY!FUNK!'
*** header.old.c	Tue Apr 30 14:33:53 1985
--- header.c		Tue Apr 30 14:33:56 1985
***************
*** 119,124
  #define APPROVED	21
  #define NFID		22
  #define NFFROM		23
  #define OTHER		99
  
  char *malloc();

--- 119,127 -----
  #define APPROVED	21
  #define NFID		22
  #define NFFROM		23
+ #ifdef DOXREFS
+ #define XREF		98
+ #endif DOXREFS
  #define OTHER		99
  
  char *malloc();
***************
*** 214,219
  				getfield(hp->relayversion);
  			}
  			break;
  		case OTHER:
  			if (unreccnt < NUNREC) {
  				if ((hp->unrec[unreccnt] = malloc((unsigned)(strlen(bfr) + 1))) != NULL ) {

--- 217,227 -----
  				getfield(hp->relayversion);
  			}
  			break;
+ #ifdef DOXREFS
+ 		case XREF:
+ 			getfield(hp->xref);
+ 			break;
+ #endif DOXREFS
  		case OTHER:
  			if (unreccnt < NUNREC) {
  				if ((hp->unrec[unreccnt] = malloc((unsigned)(strlen(bfr) + 1))) != NULL ) {
***************
*** 422,427
  		return NFID;
  	if (its("Nf-From: "))
  		return NFFROM;
  	return OTHER;
  }
  

--- 430,439 -----
  		return NFID;
  	if (its("Nf-From: "))
  		return NFFROM;
+ #ifdef DOXREFS
+ 	if (its("Xref: "))
+ 		return XREF;
+ #endif DOXREFS
  	return OTHER;
  }
  
***************
*** 536,541
  		fprintf(fp, "Nf-ID: %s\n", hp->nf_id);
  	if (*hp->nf_from)
  		fprintf(fp, "Nf-From: %s\n", hp->nf_from);
  	for (iu = 0; iu < NUNREC; iu++) {
  		if (hp->unrec[iu])
  			fprintf(fp, "%s", &hp->unrec[iu][0]);

--- 548,557 -----
  		fprintf(fp, "Nf-ID: %s\n", hp->nf_id);
  	if (*hp->nf_from)
  		fprintf(fp, "Nf-From: %s\n", hp->nf_from);
+ #ifdef DOXREFS
+ 	if (wr == 1 && *hp->xref)
+ 		fprintf(fp, "Xref: %s\n", hp->xref);
+ #endif DOXREFS
  	for (iu = 0; iu < NUNREC; iu++) {
  		if (hp->unrec[iu])
  			fprintf(fp, "%s", &hp->unrec[iu][0]);
!STUFFY!FUNK!
echo Extracting newsgroups.1
cat >newsgroups.1 <<'!STUFFY!FUNK!'
''' $Header: newsgroups.1,v 4.3 85/05/01 11:43:32 lwall Exp $
''' 
''' $Log:	newsgroups.1,v $
''' Revision 4.3  85/05/01  11:43:32  lwall
''' Baseline for release with 4.3bsd.
''' 
''' 
.de Sh
.br
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.ie n \{\
.tr \(bs-\*(Tr
.ds -- \(bs-
.if (\n(.H=4u)&(1m=24u) .ds -- \(bs\h'-12u'\(bs\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(bs\h'-12u'\(bs\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
'br\}
.TH NEWSGROUPS 1 LOCAL
.SH NAME
newsgroups - a program to list unsubscribed newsgroups.
.SH SYNOPSIS
.B newsgroups pattern flag
.SH DESCRIPTION
The
.I newsgroups
program compares your .newsrc file with the file of active newsgroups,
and prints a list of unsubscribed newsgroups matching pattern.
If the second argument \*(L"flag\*(R" is present, only newsgroups not
found in your .newsrc are listed, and the display is not paged.
If the second argument is missing, the display is paged, and an additional
list of unsubscribed newsgroups occurring in your .newsrc is printed.
.SH ENVIRONMENT
.IP DOTDIR 8
Where to find your .newsrc, if not in your home directory.
.Sp
Default: $HOME
.IP HOME 8
Your home directory.
.Sp
Default: $LOGDIR
.IP LOGDIR 8
Your home directory if HOME is undefined.
.SH FILES
/usr/lib/news/active or a reasonable facsimile
.br
${DOTDIR-{$HOME-$LOGDIR}}/.newsrc
.SH SEE ALSO
rn(1), newsrc(5)
.SH DIAGNOSTICS
.SH BUGS
The flag argument is a kludge.
!STUFFY!FUNK!
echo Extracting bits.h
cat >bits.h <<'!STUFFY!FUNK!'
/* $Header: bits.h,v 4.3 85/05/01 11:36:39 lwall Exp $
 *
 * $Log:	bits.h,v $
 * Revision 4.3  85/05/01  11:36:39  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

EXT char *ctlarea INIT(Nullch);	/* one bit for each article in current newsgroup */
			/* with the following interpretation: */
			/*	0 => unread  */
			/*	1 => read    */

/* if subscripting is faster than shifting on your machine, define this */
#undef USESUBSCRIPT
#ifdef USESUBSCRIPT
EXT char powerof2[] INIT({1,2,4,8,16,32,64,128});
#define pow2(x) powerof2[x]
#else
#define pow2(x) (1 << (x))
#endif

#ifdef lint
EXT bool nonesuch INIT(FALSE);
#define ctl_set(a)
#define ctl_clear(a)
#define ctl_read(a) nonesuch
#define was_read(a) nonesuch
#else
#define ctl_set(a) (ctlarea[(OFFSET(a)) / BITSPERBYTE] |= pow2((OFFSET(a)) % BITSPERBYTE))
#define ctl_clear(a) (ctlarea[(OFFSET(a)) / BITSPERBYTE] &= ~pow2((OFFSET(a)) % BITSPERBYTE))
#define ctl_read(a) ((ctlarea[(OFFSET(a)) / BITSPERBYTE] & pow2((OFFSET(a)) % BITSPERBYTE)) != 0)

#define was_read(a) ((a)<firstart || ctl_read(a))
#endif lint

EXT ART_NUM absfirst INIT(0);	/* 1st real article in current newsgroup */
EXT ART_NUM firstart INIT(0);	/* minimum unread article number in newsgroup */
EXT ART_NUM lastart INIT(0);	/* maximum article number in newsgroup */

#ifdef DELAYMARK
EXT FILE *dmfp INIT(Nullfp);
EXT char *dmname INIT(Nullch);
EXT int dmcount INIT(0);
#endif

void	bits_init();
void	checkpoint_rc();
void	restore_ng();
void	onemore();
void	oneless();
void	unmark_as_read();
void	delay_unmark();
void	mark_as_read();
void	check_first();
#ifdef DELAYMARK
    void	yankback();
#endif
int	chase_xrefs();
int	initctl();
void	grow_ctl();
!STUFFY!FUNK!
echo Extracting pager.help.SH
cat >pager.help.SH <<'!STUFFY!FUNK!'
case $CONFIG in
    '') . config.sh ;;
esac
echo "Extracting pager.help (with variable substitutions)"
$spitshell >pager.help <<!GROK!THIS!
$startsh
# $Header: pager.help.SH,v 4.3 85/05/01 11:45:31 lwall Exp $
#
# $Log:	pager.help.SH,v $
# Revision 4.3  85/05/01  11:45:31  lwall
# Baseline for release with 4.3bsd.
# 

$pager <<'EOT'
Paging commands:

SP	Display the next page.
x	Display the next page decrypted (rot13).
d	Display half a page more.
CR	Display one more line.
^R,v,^X	Restart the current article (v=verbose header, ^X=rot13).
^B	Back up one page.
^L,X	Refresh the screen (X=rot13).
g pat	Go to (search forward within article for) pattern.
G	Search again for current pattern within article.
^G	Search for next line beginning with \"Subject:\".
TAB	Search for next line beginning with a different character.
q	Quit the pager, go to end of article.  Leave article read or unread.
j	Junk this article (mark it read).  Goes to end of article.

The following commands skip the rest of the current article, then behave
just as if typed to the 'What next?' prompt at the end of the article:

n	Scan forward for next unread article.
N	Go to next article.
^N	Scan forward for next unread article with same title.
p,P,^P	Same as n,N,^N, only going backwards.
-	Go to previously displayed article.

The following commands also take you to the end of the article.
Type h at end of article for a description of these commands:

	# $ & / = ? c C f F k K ^K m M number r R ^R s S u v w W Y ^ |

(To return to the middle of the article after one of these commands, type ^L.)
EOT
!GROK!THIS!
$eunicefix pager.help
chmod 755 pager.help
!STUFFY!FUNK!
echo Extracting artio.c
cat >artio.c <<'!STUFFY!FUNK!'
/* $Header: artio.c,v 4.3 85/05/01 11:35:39 lwall Exp $
 *
 * $Log:	artio.c,v $
 * Revision 4.3  85/05/01  11:35:39  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

#include "EXTERN.h"
#include "common.h"
#include "INTERN.h"
#include "artio.h"

void
artio_init()
{
    ;
}

/* open an article, unless it's already open */

FILE *
artopen(artnum)
ART_NUM artnum;
{
    char artname[8];			/* filename of current article */

    if (artnum < 1)
	return Nullfp;
    if (openart == artnum) {		/* this article is already open? */
	fseek(artfp,0L,0);		/* just get to the beginning */
	return artfp;			/* and say we succeeded */
    }
    if (artfp != Nullfp) {		/* it was somebody else? */
	fclose(artfp);			/* put them out of their misery */
	openart = 0;			/* and remember them no more */
    }
    sprintf(artname,"%ld",(long)artnum);
					/* produce the name of the article */
    if (artfp = fopen(artname,"r"))	/* if we can open it */
	openart = artnum;		/* remember what we did here */
#ifdef LINKART
    {
	char tmpbuf[256];
	char *s;

	if (fstat(artfp->_file,&filestat))
	    return artfp;
	if (filestat.st_size < (sizeof tmpbuf)) {
	    fgets(tmpbuf,(sizeof tmpbuf),artfp);
	    if (*tmpbuf == '/') {	/* is a "link" to another article */
		fclose(artfp);
		if (s=index(tmpbuf,'\n'))
		    *s = '\0';
		if (!(artfp = fopen(tmpbuf,"r")))
		    openart = 0;
		else {
		    if (*linkartname)
			free(linkartname);
		    linkartname = savestr(tmpbuf);
		}
	    }
	    else
		fseek(artfp,0L,0);		/* get back to the beginning */
	}
    }
#endif
    return artfp;			/* and return either fp or NULL */
}

!STUFFY!FUNK!
echo Extracting newsetup.1
cat >newsetup.1 <<'!STUFFY!FUNK!'
''' $Header: newsetup.1,v 4.3 85/05/01 11:43:22 lwall Exp $
''' 
''' $Log:	newsetup.1,v $
''' Revision 4.3  85/05/01  11:43:22  lwall
''' Baseline for release with 4.3bsd.
''' 
''' 
.de Sh
.br
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.ie n \{\
.tr \(bs-\*(Tr
.ds -- \(bs-
.if (\n(.H=4u)&(1m=24u) .ds -- \(bs\h'-12u'\(bs\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(bs\h'-12u'\(bs\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
'br\}
.TH NEWSETUP 1 LOCAL
.SH NAME
newsetup - a program to set up a .newsrc file
.SH SYNOPSIS
.B newsetup
.SH DESCRIPTION
The
.I newsetup
program creates a new .newsrc file containing all of the currently active
newsgroups.
It tries to put them in a reasonable order, i.e. local newsgroups earlier,
but you'll probably want to change the ordering anyway (if you use
.IR rn )
in order to put interesting newsgroups first.
If you already have a .newsrc, it will be backed up with the name
\*(L".oldnewsrc\*(R".
.SH ENVIRONMENT
.IP DOTDIR 8
Where to put your .newsrc, if not in your home directory.
.Sp
Default: $HOME
.IP HOME 8
Your home directory.
.Sp
Default: $LOGDIR
.IP LOGDIR 8
Your home directory if HOME is undefined.
.SH FILES
/usr/lib/news/active or a reasonable facsimile
.br
${DOTDIR-{$HOME-$LOGDIR}}/.newsrc
.SH SEE ALSO
rn(1), newsrc(5)
.SH DIAGNOSTICS
.SH BUGS
!STUFFY!FUNK!
echo Extracting newsgroups.SH
cat >newsgroups.SH <<'!STUFFY!FUNK!'
case $CONFIG in
    '') . config.sh ;;
esac
echo "Extracting newsgroups (with variable substitutions)"
$spitshell >newsgroups <<!GROK!THIS!
$startsh
# $Header: newsgroups.SH,v 4.3 85/05/01 11:43:27 lwall Exp $
# 
# $Log:	newsgroups.SH,v $
# Revision 4.3  85/05/01  11:43:27  lwall
# Baseline for release with 4.3bsd.
# 

export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)

: syntax: newsgroups [pattern] [pipeflag]

: System Dependencies

: You might want to change pager to a "make column" program if you have one.
: On the other hand, if your kernel does paging, cat would probably do.
pager="${pager-/usr/ucb/more}"
active="${active-/usr/lib/news/active}"

: End of system dependencies, hopefully

case \$active in
~*) active=\`$filexp \$active\` ;;
esac

if $test \$# -ge 2 ; then
    pager=$cat
else
    $echo "Completely unsubscribed newsgroups:"
fi

dotdir=\${DOTDIR-\${HOME-\$LOGDIR}}

: Throwing .newsrc into the pot twice is a lovely hack to prevent
: bogus newsgroups from showing up as unsubscribed.

$cat \$dotdir/.newsrc \$dotdir/.newsrc \$active | \\
$sed	-e '/^options/d' \\
	-e '/^[	 ]/d' \\
	-e '/^control/d' \\
	-e '/^to\./d' \\
	-e 's/^\([^ !:]*\)[ !:].*\$/\1/' \\
	-e "/.*\$1/p" \\
	-e 'd' | \\
$sort | $uniq -u | \$pager
if $test \$# -ge 2 ; then
    exit
fi
$echo $n "[Type return to continue] $c"
read tmp
$echo ""
$echo "Unsubscribed but mentioned in .newsrc:"
$sed < \$dotdir/.newsrc \\
	-e "/\$1.*!/"'s/^\([^!]*\)!.*\$/\1/p' \\
	-e 'd' | \\
$sort | \$pager
!GROK!THIS!
$eunicefix newsgroups
chmod 755 newsgroups
!STUFFY!FUNK!
echo Extracting ndir.h
cat >ndir.h <<'!STUFFY!FUNK!'
/* $Header: ndir.h,v 4.3 85/05/01 11:43:00 lwall Exp $
 *
 * $Log:	ndir.h,v $
 * Revision 4.3  85/05/01  11:43:00  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

#ifdef LIBNDIR
#   include <ndir.h>
#else
#   ifndef USENDIR
#	include <sys/dir.h>
#   else

#ifndef DEV_BSIZE
#define	DEV_BSIZE	512
#endif
#define DIRBLKSIZ	DEV_BSIZE
#define	MAXNAMLEN	255

struct	direct {
	long	d_ino;			/* inode number of entry */
	short	d_reclen;		/* length of this record */
	short	d_namlen;		/* length of string in d_name */
	char	d_name[MAXNAMLEN + 1];	/* name must be no longer than this */
};

/*
 * The DIRSIZ macro gives the minimum record length which will hold
 * the directory entry.  This requires the amount of space in struct direct
 * without the d_name field, plus enough space for the name with a terminating
 * null byte (dp->d_namlen+1), rounded up to a 4 byte boundary.
 */
#undef DIRSIZ
#define DIRSIZ(dp) \
    ((sizeof (struct direct) - (MAXNAMLEN+1)) + (((dp)->d_namlen+1 + 3) &~ 3))

/*
 * Definitions for library routines operating on directories.
 */
typedef struct _dirdesc {
	int	dd_fd;
	long	dd_loc;
	long	dd_size;
	char	dd_buf[DIRBLKSIZ];
} DIR;
#ifndef NULL
#define NULL 0
#endif
extern	DIR *opendir();
extern	struct direct *readdir();
extern	long telldir();
extern	void seekdir();
#define rewinddir(dirp)	seekdir((dirp), (long)0)
extern	void closedir();

#   endif
#endif
!STUFFY!FUNK!
echo Extracting newsnews.SH
cat >newsnews.SH <<'!STUFFY!FUNK!'
case $CONFIG in
    '') . config.sh ;;
esac
echo "Extracting newsnews (with variable substitutions)"
cat >newsnews <<!GROK!THIS!
			*** NEWS NEWS ***

Welcome to rn.  There are more options to rn than you want to think about, so
we won't list them here.  If you want to find out about them, read the manual
page(s).  There are some important things to remember, though:

  * Rn is not a modified readnews.  Don't expect the commands to be identical.
  * Rn runs in cbreak mode.  This means you don't have to type carriage return
    on single character commands.  (There are some multi-character commands.)
  * At ANY prompt in rn, you may type 'h' for help.  There are many different
    help menus, depending on where you are in rn.  Typing <esc>h in the
    middle of a multi-character command will list escape substitutions.
  * Typing a space to any prompt means to do the normal thing.  You could
    spend all day reading news and never hit anything but the space bar.

This particular message comes from $rnlib/newsnews.  You will only
see it once.  You news administrator should feel free to substitute his or
her own message whenever something new happens to rn, and then the file
will again be displayed, just once for each person.

Larry Wall	sdcrdcf!lwall
!GROK!THIS!
$eunicefix newsnews
!STUFFY!FUNK!
echo Extracting rcstuff.h
cat >rcstuff.h <<'!STUFFY!FUNK!'
/* $Header: rcstuff.h,v 4.3 85/05/01 11:46:49 lwall Exp $
 *
 * $Log:	rcstuff.h,v $
 * Revision 4.3  85/05/01  11:46:49  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

EXT char *rcline[MAXRCLINE];/* pointers to lines of .newsrc */
EXT ART_UNREAD toread[MAXRCLINE];
			/* number of articles to be read in newsgroup */
			/* <0 => invalid or unsubscribed newsgroup */
#define TR_ONE ((ART_UNREAD) 1)
#define TR_NONE ((ART_UNREAD) 0)
#define TR_UNSUB ((ART_UNREAD) -1)
			/* keep this one as -1, some tests use >= TR_UNSUB */
#define TR_BOGUS ((ART_UNREAD) -2)
#define TR_JUNK ((ART_UNREAD) -3)

EXT char rcchar[MAXRCLINE]; /* holds the character : or ! while spot is \0 */
EXT char rcnums[MAXRCLINE]; /* offset from rcline to numbers on line */
EXT ACT_POS softptr[MAXRCLINE];
			/* likely ptr to active file entry for newsgroup */
EXT bool paranoid INIT(FALSE);	/* did we detect some inconsistency in .newsrc? */

bool	rcstuff_init();
bool	get_ng();	/* return TRUE if newsgroup can be found or added */
NG_NUM	add_newsgroup();
#ifdef RELOCATE
    NG_NUM	relocate_newsgroup();	/* move newsgroup around */
#endif
void	list_newsgroups();
NG_NUM	find_ng();	/* return index of newsgroup */
void	cleanup_rc();
void	sethash();
int	hash();
void	newsrc_check();
void	write_rc();
void	get_old_rc();
!STUFFY!FUNK!
echo Extracting kitlists.c
cat >kitlists.c <<'!STUFFY!FUNK!'
/* $Header: kitlists.c,v 4.3 85/05/01 11:42:08 lwall Exp $
 *
 * $Log:	kitlists.c,v $
 * Revision 4.3  85/05/01  11:42:08  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

#include <stdio.h>

#define MAXKIT 100
#define MAXKITSIZE 63000
#define KITOVERHEAD 700
#define FILEOVERHEAD 80

long tot[MAXKIT];
FILE *outfp[MAXKIT];		/* of course, not this many file descriptors */

main(argc,argv)
int argc;
char **argv;
{
    FILE *inp, *popen();
    char buf[1024], filnam[128];
    char *index();
    register char *s;
    register int i, newtot;
    
    sprintf(buf,"\
ls -l `awk '{print $1}' <%s'` | awk '{print $8 \" \" $4}' | sort +1nr\
", argc > 1 ? argv[1] : "MANIFEST.new");
    inp = popen(buf,"r");

    while (fgets(buf,1024,inp) != Nullch) {
	s = index(buf,' ');
	*s++ = '\0';
	for (i=1;
	  (newtot = tot[i] + atol(s) + FILEOVERHEAD) > MAXKITSIZE-KITOVERHEAD;
	  i++) 
	    ;
	if (!tot[i]) {
	    sprintf(filnam,"kit%d.list",i);
	    outfp[i] = fopen(filnam,"w");
	}
	tot[i] = newtot;
	printf("Adding %s to kit %d giving %d bytes\n",buf,i,newtot);
	fprintf(outfp[i],"%s\n",buf);
    }
}
!STUFFY!FUNK!
echo Extracting makedir.SH
cat >makedir.SH <<'!STUFFY!FUNK!'
case $CONFIG in
    '') . config.sh ;;
esac
echo "Extracting makedir (with variable substitutions)"
$spitshell >makedir <<!GROK!THIS!
$startsh
# $Header: makedir.SH,v 4.3 85/05/01 11:42:31 lwall Exp $
# 
# $Log:	makedir.SH,v $
# Revision 4.3  85/05/01  11:42:31  lwall
# Baseline for release with 4.3bsd.
# 

export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)

case \$# in
  0)
    $echo "makedir pathname filenameflag"
    exit 1
    ;;
esac

: guarantee one slash before 1st component
case \$1 in
  /*) ;;
  *)  set ./\$1 \$2 ;;
esac

: strip last component if it is to be a filename
case X\$2 in
  X1) set \`$echo \$1 | $sed 's:\(.*\)/[^/]*\$:\1:'\` ;;
  *)  set \$1 ;;
esac

: return reasonable status if nothing to be created
if $test -d "\$1" ; then
    exit 0
fi

list=''
while true ; do
    case \$1 in
    */*)
	list="\$1 \$list"
	set \`echo \$1 | $sed 's:\(.*\)/:\1 :'\`
	;;
    *)
	break
	;;
    esac
done

set \$list

for dir do
    $mkdir \$dir >/dev/null 2>&1
done
!GROK!THIS!
$eunicefix makedir
chmod 755 makedir
!STUFFY!FUNK!
echo Extracting search.h
cat >search.h <<'!STUFFY!FUNK!'
/* $Header: search.h,v 4.3 85/05/01 11:50:46 lwall Exp $
 *
 * $Log:	search.h,v $
 * Revision 4.3  85/05/01  11:50:46  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

#ifndef NBRA
#define	NBRA	10		/* the maximum number of meta-brackets in an
				   RE -- \( \) */
#define NALTS	10		/* the maximum number of \|'s */
 
typedef struct {	
    char *expbuf;		/* The compiled search string */
    int eblen;			/* Length of above buffer */
    char *alternatives[NALTS];	/* The list of \| seperated alternatives */
    char *braslist[NBRA];	/* RE meta-bracket start list */
    char *braelist[NBRA];	/* RE meta-bracket end list */
    char *brastr;		/* saved match string after execute() */
    char nbra;			/* The number of meta-brackets int the most
				   recenlty compiled RE */
    bool do_folding;		/* fold upper and lower case? */
} COMPEX;

void	search_init();
void	init_compex();
void	free_compex();
char	*getbracket();
void	case_fold();
char	*compile(); 
void	grow_eb();
char	*execute(); 
bool	advance();
bool	backref(); 
bool	cclass(); 
#endif
!STUFFY!FUNK!
echo Extracting last.c
cat >last.c <<'!STUFFY!FUNK!'
/* $Header: last.c,v 4.3 85/05/01 11:42:16 lwall Exp $
 *
 * $Log:	last.c,v $
 * Revision 4.3  85/05/01  11:42:16  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

#include "EXTERN.h"
#include "common.h"
#include "rn.h"
#include "util.h"
#include "intrp.h"
#include "INTERN.h"
#include "last.h"

char *lastname = Nullch;	/* path name of .rnlast file */

void
last_init(tcbuf)
char *tcbuf;
{
    lastname = savestr(filexp(LASTNAME));
    if ((tmpfp = fopen(lastname,"r")) != Nullfp) {
	fgets(tcbuf,1024,tmpfp);
	tcbuf[strlen(tcbuf)-1] = '\0';
	lastngname = savestr(tcbuf);
	fgets(tcbuf,1024,tmpfp);
	lasttime = atol(tcbuf);
	fgets(tcbuf,1024,tmpfp);
	lastactsiz = atol(tcbuf);
	fclose(tmpfp);
    }
    else {
	lastngname = nullstr;
	lasttime = 0;
	lastactsiz = 0;
    }
}

/* put out certain values for next run of rn */

void
writelast()
{
    if ((tmpfp = fopen(lastname,"w")) != Nullfp) {
	fprintf(tmpfp,"%s\n%ld\n%ld\n",ngname,(long)lasttime,(long)lastactsiz);
	fclose(tmpfp);
    }
    else
	printf(cantcreate,lastname) FLUSH;
}
!STUFFY!FUNK!
echo Extracting artsrch.h
cat >artsrch.h <<'!STUFFY!FUNK!'
/* $Header: artsrch.h,v 4.3 85/05/01 11:35:55 lwall Exp $
 *
 * $Log:	artsrch.h,v $
 * Revision 4.3  85/05/01  11:35:55  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

#ifndef NBRA
#include "search.h"
#endif

#ifdef ARTSEARCH

#define SRCH_ABORT 0
#define SRCH_INTR 1
#define SRCH_FOUND 2
#define SRCH_NOTFOUND 3
#define SRCH_DONE 4
#define SRCH_SUBJDONE 5
#define SRCH_ERROR 6
#endif

EXT char *lastpat INIT(nullstr);	/* last search pattern */
#ifdef ARTSEARCH
    EXT COMPEX sub_compex;		/* last compiled subject search */
    EXT COMPEX art_compex;		/* last compiled normal search */
#   ifdef CONDSUB
	EXT COMPEX *bra_compex INIT(&art_compex);
					/* current compex with brackets */
#   endif
    EXT char art_howmuch;		/* search just the subjects */
    EXT bool art_doread;		/* search read articles? */
#endif

void	artsrch_init();
#ifdef ARTSEARCH
    int		art_search();
    bool	wanted();	/* return TRUE if current article matches pattern */
#endif
!STUFFY!FUNK!
echo Extracting mbox.saver.SH
cat >mbox.saver.SH <<'!STUFFY!FUNK!'
case $CONFIG in
    '') . config.sh ;;
esac
echo "Extracting mbox.saver (with variable substitutions)"
$spitshell >mbox.saver <<!GROK!THIS!
$startsh
# $Header: mbox.saver.SH,v 4.3 85/05/01 11:42:51 lwall Exp $
# 
# $Log:	mbox.saver.SH,v $
# Revision 4.3  85/05/01  11:42:51  lwall
# Baseline for release with 4.3bsd.
# 
# 
#	Arguments:
#	1 Full name of article (%A)
#	2 Public news spool directory (%P)
#	3 Directory of current newsgroup (%c)
#	4 Article number (%a)
#	5 Where in article to start (%B)
#	6 Newsgroup name (%C)
#	7 Save destination (%b)
#	8 First line of message, normally From...
#
export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)

( $echo "\$8"
  case "$5" in
  0) $echo "Article \$4 of \$6:" ;;
  esac
  $tail +\$5c \$1 | $sed "s/^From/>From/"
  $echo ""
  $echo "" ) >> \$7
!GROK!THIS!
$eunicefix mbox.saver
chmod 755 mbox.saver
!STUFFY!FUNK!
echo Extracting util.h
cat >util.h <<'!STUFFY!FUNK!'
/* $Header: util.h,v 4.3 85/05/01 11:51:58 lwall Exp $
 *
 * $Log:	util.h,v $
 * Revision 4.3  85/05/01  11:51:58  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

EXT bool waiting INIT(FALSE);		/* are we waiting for subprocess (in doshell)? */
EXT int len_last_line_got INIT(0);
			/* strlen of some_buf after */
			/*  some_buf = get_a_line(bufptr,buffersize,fp) */

/* is the string for makedir a directory name or a filename? */

#define MD_DIR 0
#define MD_FILE 1

void	util_init();
int	doshell();
char	*safemalloc();
char	*saferealloc();
char	*safecpy();
char	*safecat();
char	*cpytill();
char	*instr();
#ifdef SETUIDGID
    int		eaccess();
#endif
char	*getwd();
void	cat();
void	prexit();
char	*get_a_line();
char	*savestr();
int	makedir();
void	setenv();
int	envix();
void	notincl();
char	*getval();
void	growstr();
void	setdef();
!STUFFY!FUNK!
echo Extracting norm.saver.SH
cat >norm.saver.SH <<'!STUFFY!FUNK!'
case $CONFIG in
    '') . config.sh ;;
esac
echo "Extracting norm.saver (with variable substitutions)"
$spitshell >norm.saver <<!GROK!THIS!
$startsh
# $Header: norm.saver.SH,v 4.3 85/05/01 11:45:16 lwall Exp $
# 
# $Log:	norm.saver.SH,v $
# Revision 4.3  85/05/01  11:45:16  lwall
# Baseline for release with 4.3bsd.
# 
# 
#	Arguments:
#	1 Full name of article (%A)
#	2 Public news spool directory (%P)
#	3 Directory of current newsgroup (%c)
#	4 Article number (%a)
#	5 Where in article to start (%B)
#	6 Newsgroup name (%C)
#	7 Save destination (%b)
#
export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)

( case "$5" in
  0) $echo "Article \$4 of \$6:" ;;
  esac
  $tail +\$5c \$1
  $echo ""
  $echo "" ) >> \$7
!GROK!THIS!
$eunicefix norm.saver
chmod 755 norm.saver
!STUFFY!FUNK!
echo Extracting rn.h
cat >rn.h <<'!STUFFY!FUNK!'
/* $Header: rn.h,v 4.3 85/05/01 11:48:19 lwall Exp $
 *
 * $Log:	rn.h,v $
 * Revision 4.3  85/05/01  11:48:19  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

EXT char *ngname INIT(Nullch);		/* name of current newsgroup */
EXT int ngnlen INIT(0);			/* current malloced size of ngname */
EXT char *ngdir INIT(Nullch);		/* same thing in directory name form */
EXT int ngdlen INIT(0);			/* current malloced size of ngdir */

EXT NG_NUM ng INIT(0);		/* current newsgroup index into rcline and toread */
EXT NG_NUM current_ng INIT(0);	/* stable current newsgroup so we can ditz with ng */
EXT NG_NUM starthere INIT(0);   /* set to the first newsgroup with unread news on startup */
EXT char *spool INIT(Nullch);		/* public news spool directory */

void	rn_init();
void	main();
void	set_ngname();
char	*getngdir();
!STUFFY!FUNK!
echo Extracting Wishlist
cat >Wishlist <<'!STUFFY!FUNK!'
Generalized article set manipulation
	Interface to subject listing.
	Recursive newsgroup visitation.
Virtual article abstract type to allow the following:
	Personalized header munging via % subs.
	Undigestification.
	Personal archive perusal.
	Mail handling.
	Remotely stored news.
Parent command (waiting for ARTFILE interface and recursive newsgroups).
Merge Pnews and postnews.
Vnews duplicate suppression algorithm for sites that can't do Xref patch.
Dynamic allocation of stuff currently restricted by MAXRCLINE.
	(And pull parallel arrays into array of structs).
Separation of .newsrc functions and newsgroup functions to separate processes
	communicating via pipes (to make fit on non-separate-I-and-D pdp11,
	or unreasonable facsimiles thereof).
Faster!!!
Smaller!!!
More general!!!
Perfect?
!STUFFY!FUNK!
echo Extracting intrp.h
cat >intrp.h <<'!STUFFY!FUNK!'
/* $Header: intrp.h,v 4.3 85/05/01 11:41:48 lwall Exp $
 *
 * $Log:	intrp.h,v $
 * Revision 4.3  85/05/01  11:41:48  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

EXT char *lib INIT(Nullch);		/* news library */
EXT char *rnlib INIT(Nullch);		/* private news program library */
EXT char *origdir INIT(Nullch);		/* cwd when rn invoked */
EXT char *homedir INIT(Nullch);		/* login directory */
EXT char *dotdir INIT(Nullch);		/* where . files go */
EXT char *logname INIT(Nullch);		/* login id */
EXT char *sitename INIT(Nullch);	/* host name */

#ifdef NEWSADMIN
    EXT char newsadmin[] INIT(NEWSADMIN);/* news administrator */
    EXT int newsuid INIT(0);
#endif

void    intrp_init();
char	*filexp();
char	*dointerp();
void	interp();
void	refscpy();
char	*getrealname();
!STUFFY!FUNK!
echo Extracting makekit
cat >makekit <<'!STUFFY!FUNK!'
#!/bin/sh
# $Header: makekit,v 4.3 85/05/01 11:42:38 lwall Exp $
#
# $Log:	makekit,v $
# Revision 4.3  85/05/01  11:42:38  lwall
# Baseline for release with 4.3bsd.
# 

numkits=$#
for kitlist in $*; do
    kit=`basename $kitlist .list`
    kitnum=`expr "$kit" : 'kit\([0-9][0-9]*\)'`
    echo "*** Making $kit ***"
    kitleader "$kit" "$kitnum" "$numkits"
    for file in `/bin/cat $kitlist`; do
	echo $file
	echo "echo Extracting $file" >> $kit
	if egrep '^\.$' $file; then
	    echo "sed >$file <<'!STUFFY!FUNK!' -e 's/X//'" >> $kit
	    sed <$file >>$kit -e 's/^/X/'
	else
	    echo "cat >$file <<'!STUFFY!FUNK!'" >> $kit
	    /bin/cat $file >> $kit
	fi
	echo "!STUFFY!FUNK!" >> $kit
    done
    kittrailer "$kit" "$kitnum" "$numkits"
done
!STUFFY!FUNK!
echo Extracting artstate.h
cat >artstate.h <<'!STUFFY!FUNK!'
/* $Header: artstate.h,v 4.3 85/05/01 11:35:59 lwall Exp $
 *
 * $Log:	artstate.h,v $
 * Revision 4.3  85/05/01  11:35:59  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

EXT bool reread INIT(FALSE);		/* consider current art temporarily */
				    /* unread? */
EXT bool do_fseek INIT(FALSE);	/* should we back up in article file? */

EXT bool oldsubject INIT(FALSE);	/* not 1st art in subject thread */
EXT ART_LINE topline INIT(-1);		/* top line of current screen */
EXT bool do_hiding INIT(TRUE);		/* hide header lines with -h? */
#ifdef ROTATION
EXT bool rotate INIT(FALSE);		/* has rotation been requested? */
#endif
EXT char *prompt;			/* pointer to current prompt */

EXT char *firstline INIT(Nullch);			/* special first line? */
!STUFFY!FUNK!
echo Extracting final.h
cat >final.h <<'!STUFFY!FUNK!'
/* $Header: final.h,v 4.3 85/05/01 11:38:17 lwall Exp $
 * 
 * $Log:	final.h,v $
 * Revision 4.3  85/05/01  11:38:17  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

/* cleanup status for fast exits */

EXT bool panic INIT(FALSE);		/* we got hung up or something-- */
					/*  so leave tty alone */
EXT bool rc_changed INIT(FALSE);	/* need we rewrite .newsrc? */
EXT bool doing_ng INIT(FALSE);		/* do we need to reconstitute */
					/* current rc line? */

EXT char int_count INIT(0);		/* how many interrupts we've had */

/* signal catching routines */

int	int_catcher();
int	sig_catcher();
#ifdef SIGTSTP
    int	stop_catcher();
    int	cont_catcher();
#endif

void	final_init();
void	finalize();
!STUFFY!FUNK!
echo Extracting manimake
cat >manimake <<'!STUFFY!FUNK!'
#!/bin/sh
# $Header: manimake,v 4.3 85/05/01 11:42:46 lwall Exp $
#
# $Log:	manimake,v $
# Revision 4.3  85/05/01  11:42:46  lwall
# Baseline for release with 4.3bsd.
# 

: make MANIFEST and MANIFEST.new say the same thing
if test -f MANIFEST.new; then
    cat <<'EOH' > MANIFEST
After all the rn kits are run you should have the following files:

Filename	Kit Description
--------	--- -----------
EOH
    sort MANIFEST.new >.mani
    grep . kit*.list | sed 's/^kit\(.*\)\.list:\$*\(.*\)$/\2 |\1|/' | \
	sort | \
	join -a1 - .mani | \
	awk -F'|' '{printf "%-16s%2s %s\n",$1,$2,$3}' | \
	unexpand >> MANIFEST
    rm .mani
else
    echo "You don't have a MANIFEST.new file.  Run manifake."
fi
!STUFFY!FUNK!
echo Extracting kittrailer
cat >kittrailer <<'!STUFFY!FUNK!'
#! /bin/sh
# $Header: kittrailer,v 4.3 85/05/01 11:42:11 lwall Exp $
#
# $Log:	kittrailer,v $
# Revision 4.3  85/05/01  11:42:11  lwall
# Baseline for release with 4.3bsd.
# 

rangelist=`range 1 $3`
cat >>$1 <<EOT
echo ""
echo "End of kit $2 (of $3)"
cat /dev/null >kit${2}isdone
config=true
for iskit in $rangelist; do
    if test -f kit\${iskit}isdone; then
	echo "You have run kit \${iskit}."
    else
	echo "You still need to run kit \${iskit}."
	config=false
    fi
done
case \$config in
    true)
	echo "You have run all your kits.  Please read README and then type Configure."
	chmod 755 Configure
	;;
esac
: I do not append .signature, but someone might mail this.
exit
EOT
!STUFFY!FUNK!
echo Extracting only.h
cat >only.h <<'!STUFFY!FUNK!'
/* $Header: only.h,v 4.3 85/05/01 11:45:27 lwall Exp $
 *
 * $Log:	only.h,v $
 * Revision 4.3  85/05/01  11:45:27  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

#ifndef NBRA
#include "search.h"
#endif

#ifdef ONLY
    EXT char *ngtodo[NGMAX];		/* restrictions in effect */
#   ifdef SPEEDOVERMEM
	EXT COMPEX *compextodo[NGMAX];	/* restrictions in compiled form */
#   endif
#endif

EXT int maxngtodo INIT(0);			/*  0 => no restrictions */
					/* >0 => # of entries in ngtodo */

void	only_init();
bool	inlist();	/* return TRUE if ngname is in command line list */
			/* or if there was no list */
void	setngtodo();
#ifdef ONLY
    void	end_only();
#endif
!STUFFY!FUNK!
echo Extracting header.h.1.pat
cat >header.h.1.pat <<'!STUFFY!FUNK!'
NOTE: the preceding context may be different under 2.10.2, but you should
be able to figure it out anyway.

*** header.old.h	Fri Apr 27 11:30:49 1984
--- header.h	Thu May 10 15:19:55 1984
***************
*** 34,38
  	int	intnumlines;		/* Integer version	*/
  	char	keywords[BUFLEN];	/* Keywords:		*/
  	char	approved[BUFLEN];	/* Approved:		*/
  	char	*unrec[NUNREC];		/* unrecognized lines	*/
  };

--- 34,41 -----
  	int	intnumlines;		/* Integer version	*/
  	char	keywords[BUFLEN];	/* Keywords:		*/
  	char	approved[BUFLEN];	/* Approved:		*/
+ #ifdef DOXREFS
+ 	char	xref[BUFLEN];		/* Xref:		*/
+ #endif
  	char	*unrec[NUNREC];		/* unrecognized lines	*/
  };
!STUFFY!FUNK!
echo Extracting artio.h
cat >artio.h <<'!STUFFY!FUNK!'
/* $Header: artio.h,v 4.3 85/05/01 11:35:43 lwall Exp $
 *
 * $Log:	artio.h,v $
 * Revision 4.3  85/05/01  11:35:43  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

EXT ART_POS artpos INIT(0);	/* byte position in article file */

EXT ART_LINE artline INIT(0);		/* current line number in article file */
EXT FILE *artfp INIT(Nullfp);		/* current article file pointer */
EXT ART_NUM openart INIT(0);		/* what is the currently open article number? */
#ifdef LINKART
    EXT char *linkartname INIT(nullstr);/* real name of article for Eunice */
#endif

void	artio_init();
FILE	*artopen();			/* open an article unless already opened */
!STUFFY!FUNK!
echo Extracting ngdata.h
cat >ngdata.h <<'!STUFFY!FUNK!'
/* $Header: ngdata.h,v 4.3 85/05/01 11:44:48 lwall Exp $
 *
 * $Log:	ngdata.h,v $
 * Revision 4.3  85/05/01  11:44:48  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

EXT FILE *actfp INIT(Nullfp);	/* the active file */
EXT bool writesoft INIT(FALSE);	/* rewrite the soft pointer file? */
EXT int softtries INIT(0), softmisses INIT(0);

#ifdef CACHEFIRST
    EXT ART_NUM abs1st[MAXRCLINE];	/* 1st real article in newsgroup */
#else
# ifdef MININACT
    EXT ART_NUM abs1st INIT(0);
# endif
#endif


void	ngdata_init();
ART_NUM	getngsize();
ACT_POS findact();
ART_NUM	getabsfirst();
ART_NUM	getngmin();
!STUFFY!FUNK!
echo Extracting kitleader
cat >kitleader <<'!STUFFY!FUNK!'
#! /bin/sh
# $Header: kitleader,v 4.3 85/05/01 11:42:03 lwall Exp $
#
# $Log:	kitleader,v $
# Revision 4.3  85/05/01  11:42:03  lwall
# Baseline for release with 4.3bsd.
# 

cat >$1 <<EOT
#! /bin/sh

# Make a new directory for the rn sources, cd to it, and run kits 1 thru $3 
# through sh.  When all $3 kits have been run, read README.

echo "This is rn kit $2 (of $3).  If kit $2 is complete, the line"
echo '"'"End of kit $2 (of $3)"'" will echo at the end.'
echo ""
export PATH || (echo "You didn't use sh, you clunch." ; kill \$\$)
EOT
!STUFFY!FUNK!
echo Extracting kfile.h
cat >kfile.h <<'!STUFFY!FUNK!'
/* $Header: kfile.h,v 4.3 85/05/01 11:42:00 lwall Exp $
 *
 * $Log:	kfile.h,v $
 * Revision 4.3  85/05/01  11:42:00  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

#define KF_GLOBAL 0
#define KF_LOCAL 1

#ifdef KILLFILES
EXT FILE *globkfp INIT(Nullfp);		/* global article killer file */
EXT FILE *localkfp INIT(Nullfp);	/* local (for this newsgroup) */
					/*  article killer file */
#endif

void	kfile_init();
int	do_kfile();
void	kill_unwanted();
int	edit_kfile();
void	open_kfile();
void    kf_append();
void	setthru();

!STUFFY!FUNK!
echo Extracting backpage.h
cat >backpage.h <<'!STUFFY!FUNK!'
/* $Header: backpage.h,v 4.3 85/05/01 11:36:11 lwall Exp $
 *
 * $Log:	backpage.h,v $
 * Revision 4.3  85/05/01  11:36:11  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

/* things for doing the 'back page' command */

EXT int varyfd INIT(0);			/* virtual array file for storing  */
					/* file offsets */
EXT ART_POS varybuf[VARYSIZE];		/* current window onto virtual array */

EXT long oldoffset INIT(-1);		/* offset to block currently in window */

void	backpage_init();
ART_POS	vrdary();
void	vwtary();
!STUFFY!FUNK!
echo Extracting ngsrch.h
cat >ngsrch.h <<'!STUFFY!FUNK!'
/* $Header: ngsrch.h,v 4.3 85/05/01 11:44:56 lwall Exp $
 *
 * $Log:	ngsrch.h,v $
 * Revision 4.3  85/05/01  11:44:56  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

#ifdef NGSEARCH
#define NGS_ABORT 0
#define NGS_FOUND 1
#define NGS_INTR 2
#define NGS_NOTFOUND 3

EXT bool ng_doread INIT(FALSE);		/* search read newsgroups? */
#endif

void	ngsrch_init();
#ifdef NGSEARCH 
    int		ng_search();
    bool	ng_wanted();
#endif
#ifdef NGSORONLY
    char	*ng_comp();
#endif
!STUFFY!FUNK!
echo Extracting manifake
cat >manifake <<'!STUFFY!FUNK!'
#!/bin/sh
# $Header: manifake,v 4.3 85/05/01 11:42:41 lwall Exp $
#
# $Log:	manifake,v $
# Revision 4.3  85/05/01  11:42:41  lwall
# Baseline for release with 4.3bsd.
# 

: make MANIFEST and MANIFEST.new say the same thing
if test ! -f MANIFEST.new; then
    if test -f MANIFEST; then
	sed <MANIFEST >MANIFEST.new \
	    -e '1,/---/d' \
	    -e 's/\([ 	][ 	]*\)[0-9]*  */\1/'
    else
	echo "Make a MANIFEST.new file, with names and descriptions."
    fi
fi
!STUFFY!FUNK!
echo Extracting respond.h
cat >respond.h <<'!STUFFY!FUNK!'
/* $Header: respond.h,v 4.3 85/05/01 11:47:50 lwall Exp $
 *
 * $Log:	respond.h,v $
 * Revision 4.3  85/05/01  11:47:50  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

EXT char *savedest INIT(Nullch);	/* value of %b */
EXT ART_POS savefrom INIT(0);		/* value of %B */
EXT char *headname INIT(Nullch);

#define SAVE_ABORT 0
#define SAVE_DONE 1

void	respond_init();
int	save_article();
int	cancel_article();
void	reply();
void	followup();
void	invoke();
!STUFFY!FUNK!
echo Extracting cheat.h
cat >cheat.h <<'!STUFFY!FUNK!'
/* $Header: cheat.h,v 4.3 85/05/01 11:36:58 lwall Exp $
 *
 * $Log:	cheat.h,v $
 * Revision 4.3  85/05/01  11:36:58  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

#ifdef ARTSEARCH
EXT ART_NUM srchahead INIT(0); 	/* are we in subject scan mode? */
				/* (if so, contains art # found or -1) */
#endif

#ifdef PENDING
#   ifdef CACHESUBJ
	EXT ART_NUM subj_to_get;
#   endif
#endif

void	cheat_init();
void	look_ahead();
void	collect_subjects();
!STUFFY!FUNK!
echo Extracting last.h
cat >last.h <<'!STUFFY!FUNK!'
/* $Header: last.h,v 4.3 85/05/01 11:42:22 lwall Exp $
 *
 * $Log:	last.h,v $
 * Revision 4.3  85/05/01  11:42:22  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

EXT char *lastngname INIT(Nullch);	/* last newsgroup read, from .rnlast file */
EXT long lasttime INIT(0);	/* time last rn was started up */
EXT long lastactsiz INIT(0);	/* size of active file when rn last started up */

void	last_init();
void    writelast();
!STUFFY!FUNK!
echo Extracting rcln.h
cat >rcln.h <<'!STUFFY!FUNK!'
/* $Header: rcln.h,v 4.3 85/05/01 11:45:52 lwall Exp $
 *
 * $Log:	rcln.h,v $
 * Revision 4.3  85/05/01  11:45:52  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

#ifdef DEBUGGING
EXT ART_NUM ngmax[MAXRCLINE];
#endif

void    rcln_init();
#ifdef CATCHUP
    void	catch_up();
#endif
int	addartnum();
#ifdef MCHASE
    void	subartnum();
#endif
void	prange();
void	set_toread();
void	checkexpired();
!STUFFY!FUNK!
echo Extracting art.h
cat >art.h <<'!STUFFY!FUNK!'
/* $Header: art.h,v 4.3 85/05/01 11:35:29 lwall Exp $
 *
 * $Log:	art.h,v $
 * Revision 4.3  85/05/01  11:35:29  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

/* do_article() return values */

#define DA_NORM 0
#define DA_RAISE 1
#define DA_CLEAN 2
#define DA_TOEND 3

void	art_init();
int	do_article();
int	page_switch();
bool	innermore();
!STUFFY!FUNK!
echo Extracting ngstuff.h
cat >ngstuff.h <<'!STUFFY!FUNK!'
/* $Header: ngstuff.h,v 4.3 85/05/01 11:45:12 lwall Exp $
 *
 * $Log:	ngstuff.h,v $
 * Revision 4.3  85/05/01  11:45:12  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

#define NN_NORM 0
#define NN_INP 1
#define NN_REREAD 2
#define NN_ASK 3

void	ngstuff_init();
int	escapade();
int	switcheroo();
int	numnum();
int	perform();
!STUFFY!FUNK!
echo ""
echo "End of kit 8 (of 9)"
cat /dev/null >kit8isdone
config=true
for iskit in 1 2 3 4 5 6 7 8 9; do
    if test -f kit${iskit}isdone; then
	echo "You have run kit ${iskit}."
    else
	echo "You still need to run kit ${iskit}."
	config=false
    fi
done
case $config in
    true)
	echo "You have run all your kits.  Please read README and then type Configure."
	chmod 755 Configure
	;;
esac
: I do not append .signature, but someone might mail this.
exit

