Date: Thu, 9 May 85 11:43:43 pdt
From: allegra!sdcrdcf!RDCF.SDC.UUCP!lwall (Larry Wall)
Newsgroups: mod.sources
Subject: rn version 4.3 (kit 2 of 9)
Reply-To: lwall@sdcrdcf.UUCP
Organization: System Development Corporation R&D, Santa Monica

#! /bin/sh

# Make a new directory for the rn sources, cd to it, and run kits 1 thru 9 
# through sh.  When all 9 kits have been run, read README.

echo "This is rn kit 2 (of 9).  If kit 2 is complete, the line"
echo '"'"End of kit 2 (of 9)"'" will echo at the end.'
echo ""
export PATH || (echo "You didn't use sh, you clunch." ; kill $$)
echo Extracting Configure
cat >Configure <<'!STUFFY!FUNK!'
#! /bin/sh
#
# If these # comments don't work, trim them.  Don't worry about the other
# shell scripts, Configure will trim # comments from them for you.
#
# $Header: Configure,v 4.3 85/05/01 11:31:23 lwall Exp $
#
# $Log:	Configure,v $
# Revision 4.3  85/05/01  11:31:23  lwall
# Baseline for release with 4.3bsd.
# 

# Yes, you may rip this off to use in other distribution packages.

n=''
c=''
libc=''
eunicefix=''
eunice=''
cpp=''
shsharp=''
spitshell=''
startsh=''
test=''
expr=''
sed=''
echo=''
cat=''
rm=''
mv=''
cp=''
tail=''
tr=''
mkdir=''
sort=''
uniq=''
inews=''
grep=''
egrep=''
contains=''
lib=''
nametype=''
cc=''
iandd=''
termlib=''
jobslib=''
ndirlib=''
libndir=''
usendir=''
ndirc=''
ndiro=''
pager=''
mailer=''
internet=''
rnbin=''
filexp=''
distlist=''
Log=''
Header=''
sitename=''
orgname=''
isadmin=''
newsadmin=''
rnlib=''
mansrc=''
manext=''
maildir=''
spool=''
active=''
myactive=''
mininact=''
pref=''
defeditor=''
rootid=''
mboxchar=''
locpref=''
orgpref=''
citypref=''
statepref=''
cntrypref=''
contpref=''
strchr=''
novoid=''
novfork=''
portable=''
passnam=''
berknam=''
usgnam=''
whoami=''
termio=''
fcntl=''
ioctl=''
normsig=''
havetlib=''
getpwent=''
gethostname=''
douname=''
phostname=''
hostcmd=''
CONFIG=''

echo "Beginning of configuration questions for rn kit."
: Eunice requires " " instead of "", can you believe it
echo " "

: sanity checks
PATH='.:/bin:/usr/bin:/usr/local/bin:/usr/ucb:/usr/local:/usr/lbin:/etc'
export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh $0; kill $$)

if test ! -t 0; then
    echo "Say 'sh Configure', not 'sh <Configure'"
    exit 1
fi

: some greps do not return status, grrr.
echo "grimblepritz" >grimble
if grep blurfldyick grimble >/dev/null 2>&1 ; then
    contains=contains
else
    if grep grimblepritz grimble >/dev/null 2>&1 ; then
	contains=grep
    else
	contains=contains
    fi
fi
rm grimble
: the following should work in any shell
case $contains in
contains*)
    echo " "
    echo "AGH!  Grep doesn't return a status.  Attempting remedial action."
    cat >contains <<'EOSS'
grep "$1" "$2" >.greptmp && cat .greptmp && test -s .greptmp
EOSS
chmod 755 contains
esac

: first determine how to suppress newline on echo command
echo "Checking echo to see how to suppress newlines..."
(echo "hi there\c" ; echo " ") >.echotmp
if $contains c .echotmp >/dev/null 2>&1 ; then
    echo "...using -n."
    n='-n'
    c=''
else
    echo "...using \\\c."
    n=''
    c='\c'
fi
echo $n "Type carriage return to continue.  Your cursor should be here-->$c"
read ans
rm .echotmp

: now set up to do reads with possible shell escape
: if this does not work on your machine, 1,$s/. myread/read ans/
cat <<EOSC >myread
ans='!'
while expr "X\$ans" : "X!" >/dev/null; do
    read ans
    case "\$ans" in
    !)
	sh
	echo " "
	echo $n "Your answer: $c"
	;;
    !*)
	set \`expr "X\$ans" : "X!\(.*\)\$"\`
	sh -c "\$*"
	echo " "
	echo $n "Your answer: $c"
	;;
    esac
done
EOSC

: general instructions
cat <<'EOH'
 
This installation shell script will examine your system and ask you questions
to determine how rn and its auxiliary files should be installed.  If you
get stuck on a question, you may use a ! shell escape to start a subshell or
execute a command.  Many of the questions will have default answers in
square brackets--typing carriage return will give you the default.

On some of the questions which ask for file or directory names you are
allowed to use the ~name construct to specify the login directory belonging
to "name", even if you don't have a shell which knows about that.  Questions
where this is allowed will be marked "(~name ok)".

Much effort has been expended to ensure that this shell script will run
on any Unix system.  If despite that it blows up on you, your best bet is
to edit Configure and run it again.  (Trying to install rn without having run
Configure is well nigh impossible.)  Also, let me (lwall@sdcrdcf.UUCP) know
how I blew it.

This installation script affects things in two ways: 1) it does direct
variable substitutions on some of the files included in this kit, and
2) it builds a config.h file for inclusion in C programs.  You may edit
any of these files as the need arises after running this script.

EOH
echo $n "[Type carriage return to continue] $c"
. myread

: get old answers, if there is a config file out there
if test -f config.sh; then
    echo " "
    echo "(Fetching default answers from your old config.sh file...)"
    . config.sh
fi

: get list of predefined functions in a handy place
echo " "
if test -f /lib/libc.a; then
    echo "Your C library is in /lib/libc.a.  You're normal."
    libc=/lib/libc.a
else
    if test -f /usr/lib/libc.a; then
	echo "Your C library is in /usr/lib/libc.a, of all places."
	libc=/usr/lib/libc.a
    else
	if test -f "$libc"; then
	    echo "Your C library is in $libc, like you said before."
	else
	    cat <<'EOM'
 
I can't seem to find your C library.  I've looked for /lib/libc.a and
/usr/lib/libc.a, but neither of those are there.  What is the full name
EOM
	    echo $n "of your C library? $c"
	    . myread
	    libc="$ans"
	fi
    fi
fi
echo " "
echo $n "Extracting names from $libc for later perusal...$c"
if ar t $libc > libc.list; then
    echo "done"
else
    echo " "
    echo "The archiver doesn't think $libc is a reasonable library."
    exit 1
fi

: make some quick guesses about what we are up against
echo " "
echo $n "Hmm...  $c"
if $contains SIGTSTP /usr/include/signal.h >/dev/null 2>&1 ; then
    echo "Looks kind of like a BSD system, but we'll see..."
    echo exit 0 >bsd
    echo exit 1 >usg
    echo exit 1 >v7
else
    if $contains fcntl.o libc.list >/dev/null 2>&1 ; then
	echo "Looks kind of like a USG system, but we'll see..."
	echo exit 1 >bsd
	echo exit 0 >usg
	echo exit 1 >v7
    else
	echo "Looks kind of like a version 7 system, but we'll see..."
	echo exit 1 >bsd
	echo exit 1 >usg
	echo exit 0 >v7
    fi
fi
if $contains vmssystem.o libc.list >/dev/null 2>&1 ; then
    cat <<'EOI'
There is, however, a strange, musty smell in the air that reminds me of
something...hmm...yes...I've got it...there's a VMS nearby, or I'm a Blit.
EOI
    echo "exit 0" >eunice
    eunicefix=unixtovms
    eunice=define
: it so happens the Eunice I know will not run shell scripts in Unix format
else
    echo " "
    echo "Congratulations.  You aren't running Eunice."
    eunicefix=':'
    eunice=undef
    echo "exit 1" >eunice
fi
chmod 755 bsd usg v7 eunice
$eunicefix bsd usg v7 eunice

: see how we invoke the C preprocessor
echo " "
echo "Checking to see how your C preprocessor is invoked..."
cat <<'EOT' >testcpp.c
#define ABC abc
#define XYZ xyz
ABC+XYZ
EOT
echo 'Maybe "cc -E" will work...'
cc -E testcpp.c >testcpp.out 2>&1
if $contains 'abc+xyz' testcpp.out >/dev/null 2>&1 ; then
    echo "Yup, it does."
    cpp='cc -E'
else
    echo 'Nope...maybe "cc -P" will work...'
    cc -P testcpp.c >testcpp.out 2>&1
    if $contains 'abc+xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yup, that does."
	cpp='cc -P'
    else
	echo 'Nixed again...maybe "/lib/cpp" will work...'
	/lib/cpp testcpp.c >testcpp.out 2>&1
	if $contains 'abc+xyz' testcpp.out >/dev/null 2>&1 ; then
	    echo "Hooray, it works!  I was beginning to wonder."
	    cpp='/lib/cpp'
	else
	    echo 'Hmm...maybe you already told me...'
	    case "$cpp" in
	    '') ;;
	    *) $cpp testcpp.c >testcpp.out 2>&1;;
	    esac
	    if $contains 'abc+xyz' testcpp.out >/dev/null 2>&1 ; then
		echo "Hooray, you did!  I was beginning to wonder."
	    else
		echo "Nope. I can't find a C preprocessor.  Name one: $c"
		. myread
		cpp="$ans"
		$cpp testcpp.c >testcpp.out 2>&1
		if $contains 'abc+xyz' testcpp.out >/dev/null 2>&1 ; then
		    echo "OK, that will do."
		else
		    echo "Sorry, I can't get that to work.  Go find one."
		    exit 1
		fi
	    fi
	fi
    fi
fi
rm -f testcpp.c testcpp.out

: check for pdp11
echo " "
if usg; then
    : pdp11 is already defined
else
    cat <<'EOT' >pdp11.c
#ifdef pdp11
exit 0
#else
exit 1
#endif
EOT
    $cpp pdp11.c | grep exit >pdp11
    chmod 755 pdp11
    $eunicefix pdp11
    rm pdp11.c
fi
if pdp11; then
    echo "This looks like a pdp11 to me."
else
    echo "This doesn't look like a pdp11 to me."
fi

: see if sh knows # comments
echo " "
echo "Checking your sh to see if it knows about # comments..."
if sh -c '#' >/dev/null 2>&1 ; then
    echo "Your sh handles # comments correctly."
    shsharp=true
    spitshell=cat
    echo " "
    echo "Okay, let's see if #! works on this system..."
    echo "#!/bin/echo hi" > try
    $eunicefix try
    chmod 755 try
    try > today
    if test -s today; then
	echo "It does."
	sharpbang='#!'
    else
	echo "#! /bin/echo hi" > try
	$eunicefix try
	chmod 755 try
	try > today
	if test -s today; then
	    echo "It does."
	    sharpbang='#! '
	else
	    echo "It doesn't."
	    sharpbang=': use '
	fi
    fi
else
    echo "Your sh doesn't grok # comments--I will strip them later on."
    shsharp=false
    echo "exec grep -v '^#'" >spitshell
    chmod 755 spitshell
    $eunicefix spitshell
    spitshell=`pwd`/spitshell
    echo "I presume that if # doesn't work, #! won't work either!"
    sharpbang=': use '
fi

: figure out how to guarantee sh startup
echo " "
echo "Checking out how to guarantee sh startup..."
startsh=$sharpbang'/bin/sh'
echo "Let's see if '$startsh' works..."
cat >try <<EOSS
$startsh
set abc
test "$?abc" != 1
EOSS

chmod 755 try
$eunicefix try
if try; then
    echo "Yup, it does."
else
    echo "Nope.  You may have to fix up the shell scripts to make sure sh runs them."
fi
rm -f try today

: find out where common programs are
echo " "
echo "Locating common programs..."
pth="/usr/ucb /bin /usr/bin /usr/local /usr/local/bin /usr/lbin /etc /usr/lib"
cat <<EOSC >loc
$startsh
thing=\$1
shift
dflt=\$1
shift
for dir in \$*; do
    case "\$thing" in
    .)
	if test -d \$dir/\$thing; then
	    echo \$dir
	    exit 0
	fi
	;;
    *)
	if test -f \$dir/\$thing; then
	    echo \$dir/\$thing
	    exit 0
	fi
	;;
    esac
done
echo \$dflt
exit 1
EOSC
chmod 755 loc
$eunicefix loc
loclist="expr sed echo cat rm mv cp tail tr mkdir sort uniq grep"
trylist="test inews egrep more pg Mcc"
for file in $loclist; do
    xxx=`loc $file $file $pth`
    eval $file=$xxx
    case "$xxx" in
    /*)
	echo $file is in $xxx.
	;;
    *)
	echo "I don't know where $file is.  I hope it's in everyone's PATH."
	;;
    esac
done
echo " "
echo "Don't worry if any of the following aren't found..."
for file in $trylist; do
    xxx=`loc $file $file $pth`
    eval $file=$xxx
    case "$xxx" in
    /*)
	echo $file is in $xxx.
	;;
    *)
	echo "I don't see $file out there, offhand."
	;;
    esac
done
case $egrep in
egrep)
    echo "Substituting grep for egrep."
    egrep=$grep
    ;;
*)
    case "$contains" in
    grep*) contains=e$contains;;
    esac
    ;;
esac
case $test in
test)
    echo "Hopefully test is built into your sh."
    ;;
/bin/test)
    echo " "
    echo $n 'Is your "test" built into sh? [n] (OK to guess) '"$c"
    . myread
    case $ans in
    y*) test=test ;;
    esac
    ;;
*)
    test=test
    ;;
esac
case $echo in
echo)
    echo "Hopefully echo is built into your sh."
    ;;
/bin/echo)
    echo " "
    echo "Checking compatibility between /bin/echo and builtin echo (if any)..."
    $echo $n "hi there$c" >foo1
    echo $n "hi there$c" >foo2
    if cmp foo1 foo2 >/dev/null 2>&1; then
	echo "They are compatible.  In fact, they may be identical."
    else
	echo "They are not compatible--the echo builtin will be used."
	echo=echo
    fi
    $rm -f foo1 foo2
    ;;
*)
    echo=echo
    ;;
esac

: decide how portable to be
case "$portable" in
define) dflt=y;;
*)	dflt=n;;
esac
$cat <<'EOH'
 
I can set things up so that your shell scripts and binaries are more portable,
at what may be a noticable cost in performance.  In particular, if you
ask to be portable, the following happens:

     1) shell scripts will rely on the PATH variable rather than using
	the paths derived above.
     2) ~username interpretations will be done at run time rather than
	by Configure.
     3) the system name will be determined at run time, if at all possible.

EOH
$echo $n "Do you expect to run these scripts and binaries on multiple machines? [$dflt] $c"
. myread
case $ans in
'') ans=$dflt;;
esac
case $ans in
    y*) portable=define
	for file in $loclist; do
	    eval $file=$file
	done
	;;
    *)  portable=undef ;;
esac

: set up shell script to do ~ expansion
cat >filexp <<EOSS
$startsh
: expand filename
case \$1 in
~/*|~)
    $echo \$1 | $sed "s/~/\${HOME-\$LOGDIR}/"
    ;;
~*)
    if $test -f /bin/csh; then
	/bin/csh -f -c "glob \$1"
	$echo " "
    else
	name=\`$expr x\$1 : '..\([^/]*\)'\`
	dir=\`$sed </etc/passwd -n -e "/^\${name}:/{s/^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\).*"'\$'"/\1/" -e p -e q -e '}'\`
	if $test ! -d "\$dir"; then
	    me=\`basename \$0\`
	    $echo "\$me: can't locate home directory for: \$name" >&2
	    exit 1
	fi
	case \$1 in
	*/*)
	    $echo \$dir/\`$expr x\$1 : '..[^/]*/\(.*\)'\`
	    ;;
	*)
	    $echo \$dir
	    ;;
	esac
    fi
    ;;
*)
    $echo \$1
    ;;
esac
EOSS
chmod 755 filexp
$eunicefix filexp

: now get the site name
$echo " "
$echo "Figuring out site name..."
$echo 'Maybe "hostname" will work...'
if ans=`sh -c hostname 2>&1` ; then
    sitename=$ans
    hostcmd=hostname
else
    $echo 'No, maybe "uuname -l" will work...'
    if ans=`sh -c 'uuname -l' 2>&1` ; then
	sitename=$ans
	hostcmd='uuname -l'
    else
	$echo 'Strange.  Maybe "uname -n" will work...'
	if ans=`sh -c 'uname -n' 2>&1` ; then
	    sitename=$ans
	    hostcmd='uname -n'
	else
	    $echo 'Oh well, maybe I can mine it out of whoami.h...'
	    if ans=`sh -c $contains' sysname /usr/include/whoami.h' 2>&1` ; then
		sitename=`$echo "$ans" | $sed 's/^.*"\(.*\)"/\1/'`
		hostcmd="sed -n -e '"'/sysname/s/^.*\"\\(.*\\)\"/\1/{'"' -e p -e q -e '}' </usr/include/whoami.h"
	    else
		case "$sitename" in
		'') echo "Does this machine have an identity crisis or something?"
		    hostcmd=''
		    ;;
		*)  echo "Well, you said $sitename before...";;
		esac
	    fi
	fi
    fi
fi
: you do not want to know about this
set $sitename
sitename=$1

: translate upper to lower if necessary
case $sitename in
    *[A-Z]*)
	sitename=`$echo $sitename | tr '[A-Z]' '[a-z]'`
	$echo "(Normalizing case in your site name)"
	;;
esac

: verify guess
if $test "$sitename" ; then
    $echo 'Your site name appears to be "'$sitename'".'
    $echo $n "Is this correct? [y] $c"
    . myread
    case $ans in
      y*|'')  ;;
      *)      sitename='' ;;
    esac
fi

: bad guess or no guess
while $test "X$sitename" = X ; do
    $echo $n "Please type the (one word) name of your site: $c"
    . myread
    sitename="$ans"
    case $hostcmd in
    sed*)
	$echo "(That doesn't agree with your whoami.h file, by the way.)"
	;;
    *)
	$echo "(That doesn't agree with your $hostcmd command, by the way.)"
	;;
    esac
    hostcmd=''
done

: get organizaton name
longshots='/usr/src/new /usr/src/local /usr/local/src'
case "$orgname" in
'') if xxx=`loc news/src/defs.h x $longshots`; then
	dflt=`$sed -n 's/^.*MYORG[ 	]*"\(.*\)".*$/\1/p' $xxx`
    else
	dflt='no default'
    fi
    ;;
*)  dflt="$orgname";;
esac
$cat << 'EOH'
 
Please type the name of your organization as you want it to appear on the
Organization line of outgoing articles.  (It's nice if this also specifies
your location.  Your city name is probably sufficient if well known.)
For example:

	University of Southern North Dakota, Hoople

You may also put the name of a file, as long as it begins with a slash.
For example:

	/etc/organization

EOH
orgname="no default"
while test "X$orgname" = "Xno default"; do
    $echo $n "Organization: [$dflt] $c"
    . myread
    case "$ans" in
    '') orgname="$dflt";;
    *)  orgname="$ans" ;;
    esac
done

: get news administrator name
case "$newsadmin" in
'')
    if $contains "^news:" /etc/passwd >/dev/null 2>&1 ; then
	dflt=news
    else
	if $contains "^usenet:" /etc/passwd >/dev/null 2>&1 ; then
	    dflt=news
	else
	    if eunice; then
		dflt=system
	    else
		dflt=root
	    fi
	fi
    fi
    ;;
*)  dflt="$newsadmin"
    ;;
esac
cat <<'EOM'
 
Many systems keep their news in a private directory, or have a non-superuser
in charge of administering news.  (If you don't have such a user, take the
default answer.)  What is the login name (not directory) that is used for news
EOM
echo $n "administration? [$dflt] $c"
. myread
newsadmin="$ans"
case $newsadmin in
'') newsadmin=$dflt ;;
esac
case $newsadmin in
root) isadmin=undef ;;
*)    isadmin=define ;;
esac

: figure out news library
case "$lib" in
'')
    dflt=/usr/lib/news
    ;;
*)  dflt=$lib ;;
esac
libexp=$lib
libexp='blurfl/dyick'
while $test ! -d "$libexp"; do
    $echo " "
    case "$libexp" in
    blurfl*) ;;
    *) $echo "Directory $libexp not found";;
    esac
    echo $n "Where is your news library (~name okay)? [$dflt] $c"
    . myread
    case "$ans" in
    '') ans="$dflt";;
    esac
    lib="$ans"
    case $lib in
    ~*)
	libexp=`filexp $lib`
	echo "(That is $libexp on this particular system.)"
	case $portable in
	  undef) lib=$libexp ;;
	esac
	;;
    *)
	libexp=$lib
	;;
    esac
done
if $test -f $libexp/inews; then
    echo "Aha!  Inews is really in $libexp!  Maybe this is 2.10.2..."
    case $inews in
    inews) 
	: null
	;;
    *)
	echo "(Make sure $inews isn't an old version.)"
	;;
    esac
    inews=$libexp/inews
fi

: determine where manual pages go
case "$mansrc" in
'')
    dflt=`loc . /usr/man/man1 /usr/man/mann /usr/man/local/man1 /usr/man/u_man/man1 /usr/man/man1`
    ;;
*)  dflt="$mansrc"
    ;;
esac
mansrc='blurfl/dyick'
while $test ! -d "$mansrc" ; do
    case $mansrc in
      blurfl*) ;;
      *) $echo "$mansrc does not appear to exist." ;;
    esac
    $echo " "
    $echo $n "Where do the manual pages (source) go? [$dflt] $c"
    . myread
    mansrc=`filexp "$ans"`
    case $mansrc in
      '') mansrc=$dflt ;;
    esac
done
case "$mansrc" in
*l)
    manext=l
    ;;
*n)
    manext=n
    ;;
*)
    manext=1
    ;;
esac

: determine where mail is spooled
case "$maildir" in
'')
    dflt=`loc . /usr/spool/mail /usr/spool/mail /usr/mail`
    ;;
*)  dflt="$maildir"
    ;;
esac
maildir='blurfl/dyick'
while $test ! -d "$maildir" ; do
    case $maildir in
      blurfl*) ;;
      *) $echo "$maildir does not appear to exist." ;;
    esac
    $echo " "
    $echo $n "Where is yet-to-be-read mail spooled? [$dflt] $c"
    . myread
    maildir=`filexp "$ans"`
    case $maildir in
      '') maildir=$dflt ;;
    esac
done

: find out how to find out full name
$echo " "
case "$berkname" in
define)
    dflt=y;;
undef)
    dflt=n;;
*)
    if bsd; then
	dflt=y
    else
	dflt=n
    fi
    ;;
esac
$echo "Does your /etc/passwd file keep full names in Berkeley/V7 format (name first"
$echo $n "thing after ':' in GCOS field)? [$dflt] $c"
. myread
case $ans in
  '') ans=$dflt ;;
esac
case $ans in
  y*)
    passnam=define
    berknam=define
    usgnam=undef
    nametype=bsd
    ;;
  *)
    $echo " "
    case "$usgname" in
    define)
	dflt=y;;
    undef)
	dflt=n;;
    *)
	if usg; then
	    dflt=y
	else
	    dflt=n
	fi
	;;
    esac
    $echo "Does your passwd file keep full names in USG format (name sandwiched"
    $echo $n "between a '-' and a '(')? [$dflt] $c"
    . myread
    case $ans in
      '') ans=$dflt ;;
    esac
    case $ans in
      n*)
	$echo "Full name will be taken from ~/.fullname"
	passnam=undef
	berknam=undef
	usgnam=undef
	nametype=other
	;;
      *)
	passnam=define
	berknam=undef
	usgnam=define
	nametype=usg
	;;
    esac
    ;;
esac

: see if we need a special compiler
$echo " "
if usg; then
    case "$cc" in
    '')
	case "$Mcc" in
	/*) dflt='Mcc'
	    ;;
	*)
	    if $contains '\-M' $mansrc/cc.1 >/dev/null 2>&1 ; then
		dflt='cc -M'
	    else
		dflt='cc'
	    fi
	    ;;
	esac
	;;
    *)  dflt="$cc";;
    esac
    $cat <<'EOM'
 
On some systems the default C compiler will not resolve multiple global
references that happen to have the same name.  On some such systems the
"Mcc" command may be used to force these to be resolved.  On other systems
a "cc -M" command is required.  What command will force resolution on
EOM
    $echo $n "this system? [$dflt] $c"
    . myread
    cc="$ans"
    case "$cc" in
	'') cc="$dflt" ;;
    esac
else
    $echo "Not a USG system--assuming cc can resolve multiple definitions."
    cc=cc
fi

: see if we should throw a -i into the Makefile
$echo " "
if pdp11; then
    if $contains '\-i' $mansrc/cc.1 >/dev/null 2>&1 ; then
	$echo $n "Your system appears to have separate I and D space.  Is this true? [y] $c"
	. myread
	case $ans in
	    n*|f*) iandd='' ;;
	    *)     iandd='-i' ;;
	esac
    else
	$echo "Your system appears to NOT have separate I and D space."
	$echo $n "Is this correct? [y] $c"
	. myread
	case $ans in
	    n*|f*) iandd='-i' ;;
	    *)     iandd='' ;;
	esac
    fi
else
    $echo "Not a pdp11--assuming no separate I and D."
fi

: index or strcpy
$echo " "
if $contains index.o libc.list >/dev/null 2>&1 ; then
    $echo "Your system appears to use index() and rindex() rather than strchr()"
    $echo $n "and strrchr().  Is this correct? [y] $c"
    . myread
    case $ans in
	n*|f*) strchr='define' ;;
	*)     strchr='undef' ;;
    esac
else
    $echo "Your system appears to use strchr() and strrchr() rather than index()"
    $echo $n "and rindex().  Is this correct? [y] $c"
    . myread
    case $ans in
	n*|f*) strchr=undef ;;
	*)     strchr=define ;;
    esac
fi

: determine how to determine when a file is a mailbox
case "$mboxchar" in
'') dflt=F;;
*)  dflt="$mboxchar";;
esac
$cat <<'EOM'
 
In saving articles, rn wants to differentiate between saving to mailbox
format files and normal files.  It does this by examining the first character
of the file in question.  On most systems the first line starts "From...",
so the first character is F.  On other systems there are magic cookies like
control codes between articles, so one of those would be first.  On your
system, if a file is in mailbox format, what is the first character of
EOM
echo $n "that file? [$dflt] $c"
. myread
mboxchar="$ans"
case $mboxchar in
'') mboxchar="$dflt" ;;
esac
case $mboxchar in
'F') ;;
*)  cat <<'EOM'
You will need to edit the shell script mbox.saver to properly append an
article to a mailbox.  The arguments to the script are documented in
EOM
    case $shsharp in
    false)
	echo "comments in mbox.saver.std."
	;;
    true)
	echo "comments in the shell script itself."
	;;
    esac
esac

: where do we get termlib routines from
$echo " "
if $test -d /usr/lib/terminfo || $test -d /etc/term; then
    termlib='-lcurses'
    havetlib=define
    $echo "Terminfo library found."
else
    if loc libtermlib.a x /usr/lib /usr/local/lib /lib >/dev/null; then
	termlib='-ltermlib'
	havetlib=define
	$echo "Termlib library found."
    else
	if loc libtermcap.a x /usr/lib /usr/local/lib /lib >/dev/null; then
	    termlib='-ltermcap'
	    havetlib=define
	    $echo "Termcap library found."
	else
	    case "$termlib" in
	    '')
		$echo $n "Your system appears to NOT have termlib-style routines.  Is this true? [y] $c"
		. myread
		case $ans in
		    n*|f*) havetlib=define
			  $echo "Then where are the termlib-style routines kept (specify either -llibname"
			  $echo $n " or full pathname (~name ok))? $c"
			  . myread
			  termlib=`filexp $ans`
			  ;;
		    *)    havetlib=undef
			  termlib=''
			  $echo "You will have to play around with term.c then."
			  ;;
		esac
		$echo " "
		;;
	    *)  $echo "You said termlib was $termlib before."
		;;
	    esac
	fi
    fi
fi

: see if there is a whoami file
if $test -r /usr/include/whoami.h ; then
    whoami=define
    $echo "whoami.h found."
else
    whoami=undef
fi

: see if this is a termio system
if $test -r /usr/include/termio.h ; then
    termio=define
    $echo "termio.h found."
else
    if $test -r /usr/include/sgtty.h ; then
	termio=undef
	$echo "sgtty.h found."
    else
	termio=undef
	$echo "Neither termio.h nor sgtty.h found--you could have problems."
    fi
fi

: see if this is a termio system
if $test -r /usr/include/fcntl.h ; then
    fcntl=define
    $echo "fcntl.h found."
else
    fcntl=undef
    $echo "No fcntl.h found, but that's ok."
fi

: see if ioctl defs are in sgtty/termio or sys/ioctl
if $test -r /usr/include/sys/ioctl.h ; then
    ioctl=define
    $echo "sys/ioctl.h found."
else
    ioctl=undef
    $echo "sys/ioctl.h not found, assuming ioctl args are defined in sgtty.h."
fi

: see if there is a vfork
if $contains vfork.o libc.list >/dev/null 2>&1 ; then
    $echo "vfork() found."
    novfork='undef'
else
    $echo "No vfork() found--will use fork() instead."
    novfork='define'
fi

: see if there is a getpw
if $contains getpw.o libc.list >/dev/null 2>&1 ; then
    $echo "getpw() found."
    getpwent='undef'
else
    $echo "No getpw() found--will use getpwent() instead."
    getpwent='define'
fi

: see how we will look up site name
douname=undef
gethostname=undef
phostname=undef
if $contains gethostname.o libc.list >/dev/null 2>&1 ; then
    $echo "gethostname() found."
    gethostname=define
else
    if $contains uname.o libc.list >/dev/null 2>&1 ; then
	$echo "uname() found."
	douname=define
    else
	case $hostcmd in
	  '') ;;
	  *)
	    $cat <<EOT
 
There is no gethostname() or uname() on this system.  You have two
possibilites at this point:

1)  You can have your site name ($sitename) compiled into rn, which lets rn
    start up faster, but makes your binaries non-portable, or
2)  you can have rn use a
	
	popen("$hostcmd","r")

    which will start slower but be more portable.

Option 1 will use whoami.h if you have one.  If you want option 2 but with
a different command, you can edit config.h after this shell script is done.

EOT
	    case "$phostname" in
	    define) dflt=n;;
	    undef)  dflt=y;;
	    '')
		case $portable in
		define) dflt=n ;;
		*)      dflt=y ;;
		esac
		;;
	    esac
	    $echo $n "Do you want your site name compiled in? [$dflt] $c"
	    . myread
	    case $ans in
	    '') ans=$dflt;;
	    esac
	    case $ans in
	      n*) phostname=define ;;
	      *)  hostcmd='' phostname=undef;;
	    esac
	    ;;
	esac
	case $hostcmd in
	  '')
	    case $whoami in
	      define)
		$echo 'No hostname function--using whoami.h.'
		;;
	      undef)
		$echo 'No hostname function--hardwiring "'$sitename'".'
		;;
	    esac
	    ;;
	esac
    fi
fi

: see if we need -ljobs and if we have sigset, etc.
if $test -r /usr/lib/libjobs.a || $test -r /usr/local/lib/libjobs.a ; then
    $echo "Jobs library found."
    normsig=undef
    jobslib='-ljobs'
else
    if bsd; then
	$echo "No jobs library found.  (I suppose this is 4.2...)"
    else
	$echo "No jobs library found.  (That's okay, we all have our faults.)"
    fi
    normsig=define
    jobslib=''
fi

: see if there are directory access routines out there
if $test -r /usr/lib/libndir.a || $test -r /usr/local/lib/libndir.a ; then
    $echo "Ndir library found."
    ndirlib='-lndir'
    libndir=define
    usendir=undef
    ndirc=''
    ndiro=''
else
    ndirlib=''
    libndir=undef
    if $contains readdir.o libc.list >/dev/null 2>&1 ; then
	$echo "No ndir library found, but you have readdir() so we'll use that."
	usendir=undef
	ndirc=''
	ndiro=''
    else
	$echo "No ndir library found and no readdir() found--using ./ndir.c."
	usendir=define
	ndirc='ndir.c'
	ndiro='ndir.o'
    fi
fi

: locate spool directory
case "$spool" in
'')
    dflt=/usr/spool/news
    ;;
*)  dflt="$spool";;
esac
ans='blurfl/dyick'
while $test ! -d $ans; do
    $echo " "
    case "$ans" in
    blurfl*);;
    *) echo "Directory $ans not found.";;
    esac
    $echo $n "Where is news spooled (~name ok)? [$dflt] $c"
    . myread
    case "$ans" in
    '') ans="$dflt";;
    esac
    spool="$ans"
    case $spool in
    ~*)
	ans=`filexp $spool`
	echo "(That is $ans on this particular system.)"
	case $portable in
	  undef) spool=$ans ;;
	esac
	;;
    *)
	ans=$spool
	;;
    esac
done

: locate active file
case "$active" in
'')
    dflt=$lib/active
    ;;
*)  dflt="$active";;
esac
myactive='blurfl/dyick'
while $test ! -f "$myactive"; do
    $echo " "
    case "$myactive" in
    blurfl*);;
    *) "File $myactive not found.";;
    esac
    $echo $n "Where is the active file (~name ok)? [$dflt] $c"
    . myread
    case "$ans" in
    '') ans="$dflt";;
    esac
    active="$ans"
    case $active in
    ~*)
	myactive=`filexp $active`
	echo "(That is $myactive on this particular system.)"
	case $portable in
	  undef) active=$myactive ;;
	esac
	;;
    *)
	myactive=$active
	;;
    esac
    if $test -d $myactive ; then
	myactive=$myactive/active
	active=$active/active
    fi
done

: check for 2.10.2
echo " "
if $contains ' [0-9][0-9]* [0-9]' "$myactive" >/dev/null 2>&1; then
    echo "Looks like you are running at least 2.10.2 news."
    mininact=define
else
    echo "It doesn't look like you are running 2.10.2 news yet.  Are you planning"
    echo $n "to install it in the near future? [y] $c"
    . myread
    case $ans in
    n*) mininact=undef ;;
    *)  mininact=define ;;
    esac
fi


: check for void type
$echo " "
$echo "Checking to see if your C compiler groks the void type..."
$cat >try.c <<'EOCP'
void main();
EOCP
if cc -c try.c >/dev/null 2>&1 ; then
    novoid='undef'
    $echo "Yup, it does."
else
    novoid='define'
    $echo "Nope, it doesn't (boo hiss).  I will substitute int."
fi
$rm try.*

: find out which shell people like to use most
ans='blurfl/dyick'
while $test ! -f "$ans" ; do
    case $ans in
      blurfl*) ;;
      *) $echo "$ans does not appear to exist." ;;
    esac
    case "$pref" in
    '')
	if $test -f /bin/ksh; then
	    dflt='/bin/ksh'
	else
	    if $test -f /bin/csh; then
		dflt='/bin/csh'
	    else
		dflt='/bin/sh'
	    fi
	fi
	;;
    *)  dflt="$pref";;
    esac
    $echo " "
    $echo "Give the full path name of the shell most people like to use on your"
    $echo $n "system: [$dflt] $c"
    . myread
    case $ans in
      '') ans=$dflt ;;
    esac
done
pref=$ans

: locate the preferred pager for this system
case "$pager" in
'')
    case $pg in
    /*) dflt=$pg
	;;
    esac
    case $more in
    /*) dflt=$more
	;;
    esac
    case $dflt in
    '') dflt=/usr/ucb/more
	;;
    esac
    ;;
*)  dflt="$pager";;
esac
pager='blurfl/dyick'
while $test ! -f "$pager" ; do
    case $pager in
      blurfl*)
	$echo " "
	$echo "(If your kernel does terminal paging then you may answer this with '/bin/cat'.)"
	;;
      /*) $echo "$pager does not appear to exist."
	$echo " "
        ;;
      *) $echo "Please give the full path name."
	$echo " "
        ;;
    esac
    $echo $n "What pager is used on your system? [$dflt] $c"
    . myread
    pager="$ans"
    case $pager in
      '') pager="$dflt" ;;
    esac
done

: determine default editor
case "$defeditor" in
'')
    dflt=/usr/ucb/vi
    ;;
*)  dflt="$defeditor"
    ;;
esac
defeditor='blurfl/dyick'
while $test ! -f "$defeditor" ; do
    case $defeditor in
      blurfl*) ;;
      *) $echo "$defeditor does not appear to exist." ;;
    esac
    $echo " "
    $echo $n "What is the default editor on your system? [$dflt] $c"
    . myread
    defeditor="$ans"
    case $defeditor in
      '') defeditor=$dflt ;;
    esac
done

: determine mailer for Rnmail to use
echo " "
if $test -f /usr/lib/sendmail; then
    mailer=/usr/lib/sendmail
else
    if usg && $test -f $libexp/recmail; then
	mailer=$libexp/recmail
    else
	mailer=/bin/mail
    fi
fi
echo "Mail sender is $mailer"

: check for internet mailer
case "$internet" in
define) dflt=y;;
undef)	dflt=n;;
*)	dflt=n;;
esac
cat <<EOM
 
Some newer mailers can deliver mail to addresses of the INTERNET persuasion,
such as user@host.UUCP.  Other older mailers require the complete path to
the destination to be specified in the address.  Does your mailer understand
EOM
$echo $n "INTERNET addresses? [$dflt] $c"
. myread
case "$ans" in
'') ans=$dflt;;
esac
case "$ans" in
y*) internet=define;;
*)  internet=undef;;
esac

: determine where public executables go
case "$rnbin" in
'')
    dflt=`loc . /bin /usr/local/bin /usr/lbin /usr/local /usr/bin`
    ;;
*)  dflt="$rnbin"
    ;;
esac
rnbin='blurfl/dyick'
while $test ! -d "$rnbin" ; do
    case $rnbin in
      blurfl*) ;;
      *) $echo "$rnbin does not appear to exist." ;;
    esac
    $echo " "
    $echo $n "Where do you want to put the public executables? [$dflt] $c"
    . myread
    rnbin="$ans"
    rnbin=`filexp $rnbin`
    case $rnbin in
      '') rnbin=$dflt ;;
    esac
done

: determine where private executables go
case "$rnlib" in
'')
    dflt=$lib/rn
    ;;
*)  dflt="$rnlib"
    ;;
esac
$echo " "
$echo "Rn has a number of auxiliary programs that need not be visible to the"
$echo "whole world.  Where do you want to put these private executables?"
$echo $n "[$dflt] (~name ok) $c"
. myread
rnlib="$ans"
case $rnlib in
  '') rnlib=$dflt ;;
esac
case $portable in
undef)
    rnlib=`filexp $rnlib`
    ;;
esac
: must not allow self reference
case $rnlib in
  /*)
    filexp=$rnlib/filexp
    ;;
  *)
    filexp=`pwd`/filexp
    ;;
esac

: get the local distribution prefixes
if $test -f $libexp/sys ; then
    $sed <$libexp/sys -n -e "s/^$sitename://p" | \
    $sed -e "s/:.*//" -e "s/,/ /g" | tr ' ' '\012' | \
    $sed -e "/^to./d" -e "/^net$/d" -e "/^fa$/d" -e "/^mod$/d" > .distlist
fi

$cat <<'EOH'
 
Distribution groups are the things you use on the Distribution line to limit
where an article will go to.  You are likely to be a member of several
distribution groups, such as organization, city, state, province, country,
continent, etc.  For example, Los Angeles has the distribution prefix "la",
New Jersey has the prefix "nj", and Europe has the prefix "eunet".

The categories you will be asked are: 

local organization	(Could be just one machine or a cluster or an office)
organization		att, dec, kgb, ...
city			la, ny, mosc, ...
state/province		ca, nj, bc, ...
country			usa, can, rok, whatever
continent		na (North America, not "Not Applicable"), asia, etc.

(If you don't have a distribution prefix in any of these categories then
just hit return.)

EOH
if $test -f .distlist; then
    distlist=`tr '\012' ' ' <.distlist`
    if $test "$distlist" ; then
	$echo "(These are the distributions in your sys file: $distlist)"
	$echo " "
    fi
fi
case "$locpref" in
'') dflt="";;
*)  dflt="[$locpref] ";;
esac
$echo $n "What is the distribution prefix for your local organization? $dflt$c"
. myread
case "$ans" in
'') ;;
*)  locpref="$ans";;
esac
case $locpref in
  '') locpref=none ;;
esac
case "$orgpref" in
'') dflt="";;
*)  dflt="[$orgpref] ";;
esac
$echo $n "What is the distribution prefix for your organization? $dflt$c"
. myread
case "$ans" in
'') ;;
*)  orgpref="$ans";;
esac
case $orgpref in
  '') orgpref=none ;;
esac
case "$citypref" in
'') dflt="";;
*)  dflt="[$citypref] ";;
esac
$echo $n "What is the distribution prefix for your city? $dflt$c"
. myread
case "$ans" in
'') ;;
*)  citypref="$ans";;
esac
case $citypref in
  '') citypref=none ;;
esac
case "$statepref" in
'') dflt="";;
*)  dflt="[$statepref] ";;
esac
$echo $n "What is the distribution prefix for your state/province? $dflt$c"
. myread
case "$ans" in
'') ;;
*)  statepref="$ans";;
esac
case $statepref in
  '') statepref=none ;;
esac
case "$cntrypref" in
'') dflt="";;
*)  dflt="[$cntrypref] ";;
esac
$echo $n "What is the distribution prefix for your country? $dflt$c"
. myread
case "$ans" in
'') ;;
*)  cntrypref="$ans";;
esac
case $cntrypref in
  '') cntrypref=none ;;
esac
case "$contpref" in
'') dflt="";;
*)  dflt="[$contpref] ";;
esac
$echo $n "What is the distribution prefix for your continent? $dflt$c"
. myread
case "$ans" in
'') ;;
*)  contpref="$ans";;
esac
case $contpref in
  '') contpref=none ;;
esac

$echo " "
$echo "If you have any other distribution groups you will need to edit Pnews"
$echo "and newsetup to add them."
$echo " "

: determine root id
rootid=`$sed </etc/passwd -e "/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*"'$'"/\1/" -e "q" -e "}" -e "d"`
case $rootid in
  '') rootid=0 ;;
  *)  $echo "Root uid = $rootid" ;;
esac

: weed out incompatibilities
case $douname in
  define) whoami=undef ;;
esac

: preserve RCS keywords in files with variable substitution, grrr
Log='$Log'
Header='$Header'

: Warnings
if v7; then
    cat <<'EOM'
 
NOTE: the V7 compiler may ignore some #undefs that rn uses.  If so, you will
get messages about redefining EXT.  Some V7 compilers also have difficulties
with #defines near buffer boundaries, so beware.  You may have to play with
the spacing in common.h.
EOM
fi

if pdp11; then
    cat <<'EOM'
 
NOTE: the PDP-11 does not have enough data space to do subject caching
reliably.  That feature will be disabled automatically.  Subject searching
will tend to be slow.
EOM
fi

$echo " "
$echo "End of configuration questions."
$echo " "

: create config.sh file
$echo " "
$echo "Creating config.sh..."
$spitshell <<EOT >config.sh
$startsh
# config.sh
# This file was produced by running the Configure script.

n="$n"
c="$c"
libc="$libc"
eunicefix="$eunicefix"
eunice="$eunice"
cpp="$cpp"
shsharp="$shsharp"
startsh="$startsh"
spitshell="$spitshell"
test="$test"
expr="$expr"
sed="$sed"
echo="$echo"
cat="$cat"
rm="$rm"
mv="$mv"
cp="$cp"
tail="$tail"
tr="$tr"
mkdir="$mkdir"
sort="$sort"
uniq="$uniq"
inews="$inews"
grep="$grep"
egrep="$egrep"
contains="$contains"
lib="$lib"
libexp="$libexp"
nametype="$nametype"
cc="$cc"
iandd="$iandd"
termlib="$termlib"
jobslib="$jobslib"
ndirlib="$ndirlib"
libndir="$libndir"
usendir="$usendir"
ndirc="$ndirc"
ndiro="$ndiro"
pager="$pager"
mailer="$mailer"
internet="$internet"
rnbin="$rnbin"
filexp="$filexp"
distlist="$distlist"
Log="$Log"
Header="$Header"
sitename="$sitename"
orgname="$orgname"
isadmin="$isadmin"
newsadmin="$newsadmin"
rnlib="$rnlib"
mansrc="$mansrc"
manext="$manext"
maildir="$maildir"
spool="$spool"
active="$active"
myactive="$myactive"
mininact="$mininact"
pref="$pref"
defeditor="$defeditor"
rootid="$rootid"
mboxchar="$mboxchar"
locpref="$locpref"
orgpref="$orgpref"
citypref="$citypref"
statepref="$statepref"
cntrypref="$cntrypref"
contpref="$contpref"
strchr="$strchr"
novoid="$novoid"
novfork="$novfork"
portable="$portable"
passnam="$passnam"
berknam="$berknam"
usgnam="$usgnam"
whoami="$whoami"
termio="$termio"
fcntl="$fcntl"
ioctl="$ioctl"
normsig="$normsig"
havetlib="$havetlib"
getpwent="$getpwent"
gethostname="$gethostname"
douname="$douname"
phostname="$phostname"
hostcmd="$hostcmd"
CONFIG=true
EOT

: create config.h file
$echo " "
$echo "Creating config.h..."
$cat <<EOT >config.h
/* config.h
 * This file was produced by running the Configure script.
 * Feel free to modify any of this as the need arises.
 */

/* name of the site.  May be overridden by gethostname, uname, etc. */
#define SITENAME "$sitename"

/* name of the organization, may be a file name */
#define ORGNAME "$orgname"

/* login name of news administrator, if any. */
#$isadmin NEWSADMIN "$newsadmin"

/* news library, may use only ~ and %l expansion */
#define LIB "$lib"

/* rn private library, may use ~ expansion, %x and %l */
#define RNLIB "$rnlib"

/* location of the news spool directory, may use ~ expansion, %x and %l */
#define SPOOL "$spool"

/* location of the active file, may use ~ expansion, %x and %l */
#define ACTIVE "$active"

/* location of spooled mail */
#define MAILFILE "$maildir/%L"

/* default shell--ok to be a slow shell like csh */
#define PREFSHELL "$pref"

/* default editor */
#define DEFEDITOR "$defeditor"

/* root uid */
#define ROOTID $rootid

/* what is the first character of a mailbox? */
#define MBOXCHAR '$mboxchar'

/* how to cancel an article */
#define CANCEL "$inews -h <%h"

/* distribution groups */
#define LOCDIST "$locpref"
#define ORGDIST "$orgpref"
#define CITYDIST "$citypref"
#define STATEDIST "$statepref"
#define CNTRYDIST "$cntrypref"
#define CONTDIST "$contpref"

#$strchr	index strchr	/* cultural */
#$strchr	rindex strrchr	/*  differences? */
#$novoid	void int	/* is void to be avoided? */
#$novfork	vfork fork	/* is vfork too virtual? */
#$eunice	EUNICE		/* no linking? */
#$eunice	VMS		/* not currently used, here just in case */
#$usendir	USENDIR		/* include ndir.c? */
#$libndir	LIBNDIR		/* include /usr/include/ndir.h? */
#$mininact	MININACT	/* include 2.10.2 optimization? */
#$portable	PORTABLE	/* do we do extra lookups to start up? */
#$passnam	PASSNAMES	/* do names come from the passwd file? */
				/*  (undef to take name from ~/.fullname) */
#$berknam	BERKNAMES	/* if so, are they Berkeley format? */
				/* (that is, ":name,stuff:") */
#$usgnam	USGNAMES	/* or are they USG format? */
				/* (that is, ":stuff-name(stuff):") */
#$whoami	WHOAMI		/* should we include whoami.h? */
#$termio	TERMIO		/* is this a termio system? */
#$fcntl		FCNTL		/* should we include fcntl.h? */
#$ioctl		IOCTL		/* are ioctl args all defined in one place? */
#$normsig	NORMSIG		/* use signal rather than sigset? */
#$havetlib	HAVETERMLIB	/* do we have termlib-style routines? */
#$getpwent	GETPWENT	/* need we include slow getpwent? */
#$internet	INTERNET	/* does our mailer do INTERNET addressing? */
#$gethostname	GETHOSTNAME	/* do we have a gethostname function? */
#$douname	DOUNAME		/* do we have a uname function? */
#$phostname	PHOSTNAME "$hostcmd"	/* how to get host name with popen */
EOT

CONFIG=true

$rm -f libc.list .distlist kit*isdone

echo " "
echo "Doing variable substitutions on various files..."
echo " "
set `$grep <MANIFEST '\.SH' | awk '{print $1}'`
for file in $*; do
    . $file
done

echo " "
echo 'Now you need to generate make dependencies by running "makedepend".'
echo 'You might prefer to run it in background: "makedepend > makedepend.out &"'
echo $n "Would you like me to run it for you (it takes quite a while)? [n] $c" 
. myread
case "$ans" in
y*) makedepend;;
esac
: end of Configure
!STUFFY!FUNK!
echo Extracting rcstuff.c
cat >rcstuff.c <<'!STUFFY!FUNK!'
/* $Header: rcstuff.c,v 4.3 85/05/01 11:45:56 lwall Exp $
 *
 * $Log:	rcstuff.c,v $
 * Revision 4.3  85/05/01  11:45:56  lwall
 * Baseline for release with 4.3bsd.
 * 
 */

#include "EXTERN.h"
#include "common.h"
#include "util.h"
#include "ngdata.h"
#include "term.h"
#include "final.h"
#include "rn.h"
#include "intrp.h"
#include "only.h"
#include "rcln.h"
#include "INTERN.h"
#include "rcstuff.h"

char *rcname INIT(Nullch);		/* path name of .newsrc file */
char *rctname INIT(Nullch);		/* path name of temp .newsrc file */
char *rcbname INIT(Nullch);		/* path name of backup .newsrc file */
char *softname INIT(Nullch);		/* path name of .rnsoft file */
FILE *rcfp INIT(Nullfp);			/* .newsrc file pointer */

#ifdef HASHNG
    short hashtbl[HASHSIZ];
#endif

bool
rcstuff_init()
{
    register NG_NUM newng;
    register char *s;
    register int i;
    register bool foundany = FALSE;
    char *some_buf;
    long length;

#ifdef HASHNG
    for (i=0; i<HASHSIZ; i++)
	hashtbl[i] = -1;
#endif

    /* make filenames */

    rcname = savestr(filexp(RCNAME));
    rctname = savestr(filexp(RCTNAME));
    rcbname = savestr(filexp(RCBNAME));
    softname = savestr(filexp(SOFTNAME));
    
    /* make sure the .newsrc file exists */

    newsrc_check();

    /* open .rnsoft file containing soft ptrs to active file */

    tmpfp = fopen(softname,"r");
    if (tmpfp == Nullfp)
	writesoft = TRUE;

    /* read in the .newsrc file */

    for (nextrcline = 0;
	(some_buf = get_a_line(buf,LBUFLEN,rcfp)) != Nullch;
	nextrcline++) {
					/* for each line in .newsrc */
	char tmpbuf[10];

	newng = nextrcline;		/* get it into a register */
	length = len_last_line_got;	/* side effect of get_a_line */
	if (length <= 1) {		/* only a newline??? */
	    nextrcline--;		/* compensate for loop increment */
	    continue;
	}
	if (newng >= MAXRCLINE) {	/* check for overflow */
	    fputs("Too many lines in .newsrc\n",stdout) FLUSH;
	    finalize(1);
	}
	if (tmpfp != Nullfp && fgets(tmpbuf,10,tmpfp) != Nullch)
	    softptr[newng] = atoi(tmpbuf);
	else
	    softptr[newng] = 0;
	some_buf[--length] = '\0';	/* wipe out newline */
	if (some_buf == buf) {
	    rcline[newng] = savestr(some_buf);
					/* make a semipermanent copy */
	}
	else {
	    /*NOSTRICT*/
#ifndef lint
	    some_buf = saferealloc(some_buf,(MEM_SIZE)(length+1));
#endif lint
	    rcline[newng] = some_buf;
	}
#ifdef NOTDEF
	if (strnEQ(some_buf,"to.",3)) {	/* is this a non-newsgroup? */
	    nextrcline--;		/* destroy this line */
	    continue;
	}
#endif
	if (*some_buf == ' ' ||
	  *some_buf == '\t' ||
	  strnEQ(some_buf,"options",7)) {		/* non-useful line? */
	    toread[newng] = TR_JUNK;
	    rcchar[newng] = ' ';
	    rcnums[newng] = 0;
	    continue;
	}
	for (s = rcline[newng]; *s && *s != ':' && *s != NEGCHAR; s++) ;
	if (!*s) {
#ifndef lint
	    rcline[newng] = saferealloc(rcline[newng],(MEM_SIZE)length+2);
#endif lint
	    s = rcline[newng] + length;
	    *s = ':';
	    *(s+1) = '\0';
	}
	rcchar[newng] = *s;		/* salt away the : or ! */
	rcnums[newng] = (char)(s - rcline[newng]); 
	rcnums[newng]++;		/* remember where it was */
	*s = '\0';			/* null terminate newsgroup name */
#ifdef HASHNG
	if (!checkflag)
	    sethash(newng);
#endif
	if (rcchar[newng] == NEGCHAR) {
	    toread[newng] = TR_UNSUB;
	    continue;
	}

	/* now find out how much there is to read */

	if (!inlist(buf) || (suppress_cn && foundany && !paranoid))
	    toread[newng] = TR_NONE;	/* no need to calculate now */
	else
	    set_toread(newng);
#ifdef VERBOSE
	if (!checkflag && softmisses == 1) {
	    softmisses++;		/* lie a little */
	    fputs("(Revising soft pointers--be patient.)\n",stdout) FLUSH;
	}
#endif
	if (toread[newng] > TR_NONE) {	/* anything unread? */
	    if (!foundany) {
		starthere = newng;
		foundany = TRUE;	/* remember that fact*/
	    }
	    if (suppress_cn) {		/* if no listing desired */
		if (checkflag) {	/* if that is all they wanted */
		    finalize(1);	/* then bomb out */
		}
	    }
	    else {
#ifdef VERBOSE
		IF(verbose)
		    printf("Unread news in %-20s %5ld article%s\n",
			rcline[newng],(long)toread[newng],
			toread[newng]==TR_ONE ? nullstr : "s") FLUSH;
		ELSE
#endif
#ifdef TERSE
		    printf("%s: %ld article%s\n",
			rcline[newng],(long)toread[newng],
			toread[newng]==TR_ONE ? nullstr : "s") FLUSH;
#endif
		if (int_count) {
		    countdown = 1;
		    int_count = 0;
		}
		if (countdown) {
		    if (! --countdown) {
			fputs("etc.\n",stdout) FLUSH;
			if (checkflag)
			    finalize(1);
			suppress_cn = TRUE;
		    }
		}
	    }
	}
    }
    fclose(rcfp);			/* close .newsrc */
    if (tmpfp != Nullfp)
	fclose(tmpfp);			/* close .rnsoft */
    if (checkflag) {			/* were we just checking? */
	finalize(foundany);		/* tell them what we found */
    }
    if (paranoid)
	cleanup_rc();

#ifdef DEBUGGING
    if (debug & DEB_HASH) {
	page_init();
	for (i=0; i<HASHSIZ; i++) {
	    sprintf(buf,"%d	%d",i,hashtbl[i]);
	    print_lines(buf,NOMARKING);
	}
    }
#endif

    return foundany;
}

/* try to find or add an explicitly specified newsgroup */
/* returns TRUE if found or added, FALSE if not. */
/* assumes that we are chdir'ed to SPOOL */

bool
get_ng(what,do_reloc)
char *what;
bool do_reloc;
{
    char *ntoforget;
    char promptbuf[128];

#ifdef VERBOSE
    IF(verbose)
	ntoforget = "Type n to forget about this newsgroup.\n";
    ELSE
#endif
#ifdef TERSE
	ntoforget = "n to forget it.\n";
#endif
    if (index(what,'/')) {
	dingaling();
	printf("\nBad newsgroup name.\n") FLUSH;
	return FALSE;
    }
    set_ngname(what);
    ng = find_ng(ngname);
    if (ng == nextrcline) {		/* not in .newsrc? */
	if (eaccess(ngdir,0) ||
	    (softptr[ng] = findact(buf,ngname,strlen(ngname),0L)) < 0 ) {
	    dingaling();
#ifdef VERBOSE
	    IF(verbose)
		printf("\nNewsgroup %s does not exist!\n",ngname) FLUSH;
	    ELSE
#endif
#ifdef TERSE
		printf("\nNo %s!\n",ngname) FLUSH;
#endif
	    sleep(2);
	    return FALSE;
	}
#ifdef VERBOSE
	IF(verbose)
	    sprintf(promptbuf,"\nNewsgroup %s not in .newsrc--add? [yn] ",ngname);
	ELSE
#endif
#ifdef TERSE
	    sprintf(promptbuf,"\nAdd %s? [yn] ",ngname);
#endif
reask_add:
	in_char(promptbuf);
	putchar('\n') FLUSH;
	setdef(buf,"y");
#ifdef VERIFY
	printcmd();
#endif
	if (*buf == 'h') {
#ifdef VERBOSE
	    IF(verbose)
		printf("Type y or SP to add %s to your .newsrc.\n", ngname)
		  FLUSH;
	    ELSE
#endif
#ifdef TERSE
		fputs("y or SP to add\n",stdout) FLUSH;
#endif
	    fputs(ntoforget,stdout) FLUSH;
	    goto reask_add;
	}
	else if (*buf == 'n' || *buf == 'q') {
	    return FALSE;
	}
	else if (*buf == 'y') {
	    ng = add_newsgroup(ngname);
	    do_reloc = FALSE;
	}
	else {
	    fputs(hforhelp,stdout) FLUSH;
	    settle_down();
	    goto reask_add;
	}
    }
    else if (rcchar[ng] == NEGCHAR) {	/* unsubscribed? */
#ifdef VERBOSE
	IF(verbose)
	    sprintf(promptbuf,
"\nNewsgroup %s is currently unsubscribed to--resubscribe? [yn] ",ngname)
  FLUSH;
	ELSE
#endif
#ifdef TERSE
	    sprintf(promptbuf,"\n%s unsubscribed--resubscribe? [yn] ",ngname)
	      FLUSH;
#endif
reask_unsub:
	in_char(promptbuf);
	putchar('\n') FLUSH;
	setdef(buf,"y");
#ifdef VERIFY
	printcmd();
#endif
	if (*buf == 'h') {
#ifdef VERBOSE
	    IF(verbose)
		printf("Type y or SP to resubscribe to %s.\n", ngname) FLUSH;
	    ELSE
#endif
#ifdef TERSE
		fputs("y or SP to resubscribe.\n",stdout) FLUSH;
#endif
	    fputs(ntoforget,stdout) FLUSH;
	    goto reask_unsub;
	}
	else if (*buf == 'n' || *buf == 'q') {
	    return FALSE;
	}
	else if (*buf == 'y') {
	    rcchar[ng] = ':';
	}
	else {
	    fputs(hforhelp,stdout) FLUSH;
	    settle_down();
	    goto reask_unsub;
	}
    }

    /* now calculate how many unread articles in newsgroup */

    set_toread(ng);
#ifdef RELOCATE
    if (do_reloc)
	ng = relocate_newsgroup(ng,-1);
#endif
    return toread[ng] >= TR_NONE;
}

/* add a newsgroup to the .newsrc file (eventually) */

NG_NUM
add_newsgroup(ngn)
char *ngn;
{
    register NG_NUM newng = nextrcline++;
					/* increment max rcline index */
    
    rcnums[newng] = strlen(ngn) + 1;
    rcline[newng] = safemalloc((MEM_SIZE)(rcnums[newng] + 1));
    strcpy(rcline[newng],ngn);		/* and copy over the name */
    *(rcline[newng] + rcnums[newng]) = '\0';
    rcchar[newng] = ':';		/* call it subscribed */
    toread[newng] = TR_NONE;	/* just for prettiness */
#ifdef HASHNG
    sethash(newng);			/* so we can find it again */
#endif
#ifdef RELOCATE
    return relocate_newsgroup(newng,-1);
#else
    return newng;
#endif
}

#ifdef RELOCATE
NG_NUM
relocate_newsgroup(ngx,newng)
NG_NUM ngx;
NG_NUM newng;
{
    char *dflt = (ngx!=current_ng ? "$^.L" : "$^L");
    char *tmprcline;
    ART_UNREAD tmptoread;
    char tmprcchar;
    char tmprcnums;
    ACT_POS tmpsoftptr;
    register NG_NUM i;
#ifdef DEBUGGING
    ART_NUM tmpngmax;
#endif
#ifdef CACHEFIRST
    ART_NUM tmpabs1st;
#endif
    
    starthere = 0;                      /* Disable this optimization */
    writesoft = TRUE;			/* Update soft pointer file */
    if (ngx < nextrcline-1) {
#ifdef HASHNG
	for (i=0; i<HASHSIZ; i++) {
	    if (hashtbl[i] > ngx)
		--hashtbl[i];
	    else if (hashtbl[i] == ngx)
		hashtbl[i] = nextrcline-1;
	}
#endif
	tmprcline = rcline[ngx];
	tmptoread = toread[ngx];
	tmprcchar = rcchar[ngx];
	tmprcnums = rcnums[ngx];
	tmpsoftptr = softptr[ngx];
#ifdef DEBUGGING
	tmpngmax = ngmax[ngx];
#endif
#ifdef CACHEFIRST
	tmpabs1st = abs1st[ngx];
#endif
	for (i=ngx+1; i<nextrcline; i++) {
	    rcline[i-1] = rcline[i];
	    toread[i-1] = toread[i];
	    rcchar[i-1] = rcchar[i];
	    rcnums[i-1] = rcnums[i];
	    softptr[i-1] = softptr[i];
#ifdef DEBUGGING
	    ngmax[i-1] = ngmax[i];
#endif
#ifdef CACHEFIRST
	    abs1st[i-1] = abs1st[i];
#endif
	}
	rcline[nextrcline-1] = tmprcline;
	toread[nextrcline-1] = tmptoread;
	rcchar[nextrcline-1] = tmprcchar;
	rcnums[nextrcline-1] = tmprcnums;
	softptr[nextrcline-1] = tmpsoftptr;
#ifdef DEBUGGING
	ngmax[nextrcline-1] = tmpngmax;
#endif
#ifdef CACHEFIRST
	abs1st[nextrcline-1] = tmpabs1st;
#endif
    }
    if (current_ng > ngx)
	current_ng--;
    if (newng < 0) {
      reask_reloc:
	unflush_output();		/* disable any ^O in effect */
#ifdef VERBOSE
	IF(verbose)
	    printf("\nPut newsgroup where? [%s] ", dflt);
	ELSE
#endif
#ifdef TERSE
	    printf("\nPut where? [%s] ", dflt);
#endif
	fflush(stdout);
      reinp_reloc:
	eat_typeahead();
	getcmd(buf);
	if (errno || *buf == '\f') {
			    /* if return from stop signal */
	    goto reask_reloc;	/* give them a prompt again */
	}
	setdef(buf,dflt);
#ifdef VERIFY
	printcmd();
#endif
	if (*buf == 'h') {
#ifdef VERBOSE
	    IF(verbose) {
		printf("\n\n\
Type ^ to put the newsgroup first (position 0).\n\
Type $ to put the newsgroup last (position %d).\n", nextrcline-1);
		printf("\
Type . to put it before the current newsgroup (position %d).\n", current_ng);
		printf("\
Type -newsgroup name to put it before that newsgroup.\n\
Type +newsgroup name to put it after that newsgroup.\n\
Type a number between 0 and %d to put it at that position.\n", nextrcline-1);
		printf("\
Type L for a listing of newsgroups and their positions.\n") FLUSH;
	    }
	    ELSE
#endif
#ifdef TERSE
	    {
		printf("\n\n\
^ to put newsgroup first (pos 0).\n\
$ to put last (pos %d).\n", nextrcline-1);
		printf("\
. to put before current newsgroup (pos %d).\n", current_ng);
		printf("\
-newsgroup to put before newsgroup.\n\
+newsgroup to put after.\n\
number in 0-%d to put at that pos.\n", nextrcline-1);
		printf("\
L for list of .newsrc.\n") FLUSH;
	    }
#endif
	    goto reask_reloc;
	}
	else if (*buf == 'L') {
	    putchar('\n') FLUSH;
	    list_newsgroups();
	    goto reask_reloc;
	}
	else if (isdigit(*buf)) {
	    if (!finish_command(TRUE))	/* get rest of command */
		goto reinp_reloc;
	    newng = atoi(buf);
	    if (newng < 0)
		newng = 0;
	    if (newng >= nextrcline)
		return nextrcline-1;
	}
	else if (*buf == '^') {
	    putchar('\n') FLUSH;
	    newng = 0;
	}
	else if (*buf == '$') {
	    putchar('\n') FLUSH;
	    return nextrcline-1;
	}
	else if (*buf == '.') {
	    putchar('\n') FLUSH;
	    newng = current_ng;
	}
	else if (*buf == '-' || *buf == '+') {
	    if (!finish_command(TRUE))	/* get rest of command */
		goto reinp_reloc;
	    newng = find_ng(buf+1);
	    if (newng == nextrcline) {
		fputs("Not found.",stdout) FLUSH;
		goto reask_reloc;
	    }
	    if (*buf == '+')
		newng++;
	}
	else {
	    printf("\n%s",hforhelp) FLUSH;
	    settle_down();
	    goto reask_reloc;
	}
    }
    if (newng < nextrcline-1) {
#ifdef HASHNG
	for (i=0; i<HASHSIZ; i++) {
	    if (hashtbl[i] == nextrcline-1)
		hashtbl[i] = newng;
	    else if (hashtbl[i] >= newng)
		++hashtbl[i];
	}
#endif
	tmprcline = rcline[nextrcline-1];
	tmptoread = toread[nextrcline-1];
	tmprcchar = rcchar[nextrcline-1];
	tmprcnums = rcnums[nextrcline-1];
	tmpsoftptr = softptr[nextrcline-1];
#ifdef DEBUGGING
	tmpngmax = ngmax[nextrcline-1];
#endif
#ifdef CACHEFIRST
	tmpabs1st = abs1st[nextrcline-1];
#endif
	for (i=nextrcline-2; i>=newng; i--) {
	    rcline[i+1] = rcline[i];
	    toread[i+1] = toread[i];
	    rcchar[i+1] = rcchar[i];
	    rcnums[i+1] = rcnums[i];
	    softptr[i+1] = softptr[i];
#ifdef DEBUGGING
	    ngmax[i+1] = ngmax[i];
#endif
#ifdef CACHEFIRST
	    abs1st[i+1] = abs1st[i];
#endif
	}
	rcline[newng] = tmprcline;
	toread[newng] = tmptoread;
	rcchar[newng] = tmprcchar;
	rcnums[newng] = tmprcnums;
	softptr[newng] = tmpsoftptr;
#ifdef DEBUGGING
	ngmax[newng] = tmpngmax;
#endif
#ifdef CACHEFIRST
	abs1st[newng] = tmpabs1st;
#endif
    }
    if (current_ng >= newng)
	current_ng++;
    return newng;
}
#endif

/* List out the newsrc with annotations */

void
list_newsgroups()
{
    register NG_NUM i;
    char tmpbuf[2048];
    static char *status[] = {"(READ)","(UNSUB)","(BOGUS)","(JUNK)"};
    int cmd;

    page_init();
    print_lines("\
  #  Status  Newsgroup\n\
",STANDOUT);
    for (i=0; i<nextrcline && !int_count; i++) {
	if (toread[i] >= 0)
	    set_toread(i);
	*(rcline[i] + rcnums[i] - 1) = rcchar[i];
	if (toread[i] > 0)
	    sprintf(tmpbuf,"%3d %6d   ",i,toread[i]);
	else
	    sprintf(tmpbuf,"%3d %7s  ",i,status[-toread[i]]);
	safecpy(tmpbuf+13,rcline[i],2034);
	*(rcline[i] + rcnums[i] - 1) = '\0';
	if (cmd = print_lines(tmpbuf,NOMARKING)) {
	    if (cmd > 0)
		pushchar(cmd);
	    break;
	}
    }
    int_count = 0;
}

/* find a newsgroup in .newsrc */

NG_NUM
find_ng(ngnam)
char *ngnam;
{
    register NG_NUM ngnum;
#ifdef HASHNG
    register int hashix = hash(ngnam);
    register int incr = 1;

    while ((ngnum = hashtbl[hashix]) >= 0) {
	if (strEQ(rcline[ngnum], ngnam) && toread[ngnum] >= TR_UNSUB)
	    return ngnum;
	hashix = (hashix + incr) % HASHSIZ;
	incr += 2;			/* offsets from original are in n*2 */
    }
    return nextrcline;			/* = notfound */

#else /* just do linear search */

    for (ngnum = 0; ngnum < nextrcline; ngnum++) {
	if (strEQ(rcline[ngnum],ngnam))
	    break;
    }
    return ngnum;
#endif
}

void
cleanup_rc()
{
    register NG_NUM ngx;
    register NG_NUM bogosity = 0;

#ifdef VERBOSE
    IF(verbose)
	fputs("Checking out your .newsrc--hang on a second...\n",stdout)
	  FLUSH;
    ELSE
#endif
#ifdef TERSE
	fputs("Checking .newsrc--hang on...\n",stdout) FLUSH;
#endif
    for (ngx = 0; ngx < nextrcline; ngx++) {
	if (toread[ngx] >= TR_UNSUB) {
	    set_toread(ngx);		/* this may reset newsgroup */
					/* or declare it bogus */
	}
	if (toread[ngx] == TR_BOGUS)
	    bogosity++;
    }
    for (ngx = nextrcline-1; ngx >= 0 && toread[ngx] == TR_BOGUS; ngx--)
	bogosity--;			/* discount already moved ones */
    if (nextrcline > 5 && bogosity > nextrcline / 2) {
	fputs(
"It looks like the active file is messed up.  Contact your news administrator,\n\
",stdout);
	fputs(
"leave the \"bogus\" groups alone, and they may come back to normal.  Maybe.\n\
",stdout) FLUSH;
    }
#ifdef RELOCATE
    else if (bogosity) {
#ifdef VERBOSE
	IF(verbose)
	    fputs("Moving bogus newsgroups to the end of your .newsrc.\n",
		stdout) FLUSH;
	ELSE
#endif
#ifdef TERSE
	    fputs("Moving boguses to the end.\n",stdout) FLUSH;
#endif
	for (; ngx >= 0; ngx--) {
	    if (toread[ngx] == TR_BOGUS)
		relocate_newsgroup(ngx,nextrcline-1);
	}
#ifdef DELBOGUS
reask_bogus:
	in_char("Delete bogus newsgroups? [ny] ");
	putchar('\n') FLUSH;
	setdef(buf,"n");
#ifdef VERIFY
	printcmd();
#endif
	if (*buf == 'h') {
#ifdef VERBOSE
	    IF(verbose)
		fputs("\
Type y to delete bogus newsgroups.\n\
Type n or SP to leave them at the end in case they return.\n\
",stdout) FLUSH;
	    ELSE
#endif
#ifdef TERSE
		fputs("y to delete, n to keep\n",stdout) FLUSH;
#endif
	    goto reask_bogus;
	}
	else if (*buf == 'n' || *buf == 'q')
	    ;
	else if (*buf == 'y') {
	    while (toread[nextrcline-1] == TR_BOGUS && nextrcline > 0)
		--nextrcline;		/* real tough, huh? */
	}
	else {
	    fputs(hforhelp,stdout) FLUSH;
	    settle_down();
	    goto reask_bogus;
	}
#endif
    }
#else
#ifdef VERBOSE
    IF(verbose)
	fputs("You should edit bogus newsgroups out of your .newsrc.\n",
	    stdout) FLUSH;
    ELSE
#endif
#ifdef TERSE
	fputs("Edit boguses from .newsrc.\n",stdout) FLUSH;
#endif
#endif
    paranoid = FALSE;
}

#ifdef HASHNG
/* make an entry in the hash table for the current newsgroup */

void
sethash(thisng)
NG_NUM thisng;
{
    register int hashix = hash(rcline[thisng]);
    register int incr = 1;
#ifdef DEBUGGING
    static int hashhits = 0, hashtries = 0;
#endif

#ifdef DEBUGGING
    hashtries++;
#endif
    while (hashtbl[hashix] >= 0) {
#ifdef DEBUGGING
	hashhits++;
	if (debug & DEB_HASH) {
	    printf("  Hash hits: %d / %d\n",hashhits, hashtries) FLUSH;
	}
	hashtries++;
#endif
	hashix = (hashix + incr) % HASHSIZ;
	incr += 2;			/* offsets from original are in n*2 */
    }
    hashtbl[hashix] = thisng;
}

short prime[] = {1,2,-3,-5,7,11,-13,-17,19,23,-29,-31,37,41,-43,-47,53,57,-59,
    -61,67,71,-73,-79,83,89,-97,-101,1,1,1,1,1,1,1,1,1,1,1,1};

int
hash(ngnam)
register char *ngnam;
{
    register int i = 0;
    register int ch;
    register int sum = 0;
#ifdef DEBUGGING
    char *ngn = ngnam;
#endif

    while (ch = *ngnam++) {
	sum += (ch + i) * prime[i];   /* gives ~ 10% hits at 25% full */
	i++;
    }
#ifdef DEBUGGING
    if (debug & DEB_HASH)
	printf("hash(%s) => %d => %d\n",ngn, sum, (sum<0?-sum:sum)%HASHSIZ)
	  FLUSH;
#endif
    if (sum < 0)
	sum = -sum;
    return sum % HASHSIZ;
}

#endif

void
newsrc_check()
{
    rcfp = fopen(rcname,"r");		/* open it */
    if (rcfp == Nullfp) {			/* not there? */
#ifdef VERBOSE
	IF(verbose)
	    fputs("\
Trying to set up a .newsrc file--running newsetup...\n\n\
",stdout) FLUSH;
	ELSE
#endif
#ifdef TERSE
	    fputs("Setting up .newsrc...\n",stdout) FLUSH;
#endif
	if (doshell(sh,filexp(NEWSETUP)) ||
	    (rcfp = fopen(rcname,"r")) == Nullfp) {
#ifdef VERBOSE
	    IF(verbose)
		fputs("\
Can't create a .newsrc--you must do it yourself.\n\
",stdout) FLUSH;
	    ELSE
#endif
#ifdef TERSE
		fputs("(Fatal)\n",stdout) FLUSH;
#endif
	    finalize(1);
	}
    }
    else {
	UNLINK(rcbname);		/* unlink backup file name */
	link(rcname,rcbname);		/* and backup current name */
    }
}

/* write out the (presumably) revised .newsrc */

void
write_rc()
{
    register NG_NUM tmpng;
    register char *delim;

    rcfp = fopen(rctname, "w");		/* open .newsrc */
    if (rcfp == Nullfp) {
	printf("Can't recreate .newsrc\n") FLUSH;
	finalize(1);
    }

    /* write out each line*/

    for (tmpng = 0; tmpng < nextrcline; tmpng++) {
	if (rcnums[tmpng]) {
	    delim = rcline[tmpng] + rcnums[tmpng] - 1;
	    *delim = rcchar[tmpng];
	}
	else
	    delim = Nullch;
#ifdef DEBUGGING
	if (debug & DEB_NEWSRC_LINE)
	    printf("%s\n",rcline[tmpng]) FLUSH;
#endif
	fprintf(rcfp,"%s\n",rcline[tmpng]);
	if (delim)
	    *delim = '\0';		/* might still need this line */
    }

    fclose(rcfp);			/* close .newsrc */
    UNLINK(rcname);
    link(rctname,rcname);
    UNLINK(rctname);

    if (writesoft) {
	tmpfp = fopen(filexp(softname), "w");	/* open .rnsoft */
	if (tmpfp == Nullfp) {
	    printf(cantcreate,filexp(softname)) FLUSH;
	    return;
	}
	for (tmpng = 0; tmpng < nextrcline; tmpng++) {
	    fprintf(tmpfp,"%ld\n",(long)softptr[tmpng]);
	}
	fclose(tmpfp);
    }
}

void
get_old_rc()
{
    UNLINK(rctname);
    link(rcname,rctname);
    UNLINK(rcname);
    link(rcbname,rcname);
    UNLINK(rcbname);
}
!STUFFY!FUNK!
echo ""
echo "End of kit 2 (of 9)"
cat /dev/null >kit2isdone
config=true
for iskit in 1 2 3 4 5 6 7 8 9; do
    if test -f kit${iskit}isdone; then
	echo "You have run kit ${iskit}."
    else
	echo "You still need to run kit ${iskit}."
	config=false
    fi
done
case $config in
    true)
	echo "You have run all your kits.  Please read README and then type Configure."
	chmod 755 Configure
	;;
esac
: I do not append .signature, but someone might mail this.
exit

