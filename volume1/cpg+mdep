From: ihnp4!amdcad!idi!bene!luke!steven
Date: Mon, 10 Jun 85 15:22:59 pdt
Newsgroups: mod.sources
Subject: cpg and mdep 
Reply-To: steven@luke.UUCP (Steven List)
Organization: Benetics Corp, Mt. View, CA
Keywords: C print format make dependencies

The following shar contains two programs and their documentation:

	cpg - a C source file formatter
	mdep - a make dependency list generator

CPG is a little tool developed locally to enable us to produce listings
that had both line numbers and nesting level indication for our code.
My incentive was due to the lack of any such facility.  Some of the code
in cpg is borrowed from cpr (came accross the net a while back), but
most of it is completely original.  Those of you who have seen other
postings of mine, or see some more, will find that they include cpg
triggers throughout.

MDEP provides programatically what Larry Wall and others have done in
their makefiles (makedepend and make depend).  It will search out and
list all include files needed to make a module.  Hopefully, this will
find some legitimate use out there.  We use it regularly here.

Please forgive the fact that these (and all my programs) are System III
specific.  It's the only system that I have access to.  If anyone out
there modifies them so that they are selectable (with ifdefs or
whatever) by version, please send them back to me.

Comments, improvements, and whatever are more than welcome.

Steven
***
*  Steven List @ Benetics Corporation  *  (415) 940-6300
*  {cdp,greipa,idi,oliveb,sun,tolerant}!bene!luke!steven
***
======================== Cut Here ======================================
#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	cpg.1
#	cpg.c
#	mdep.1
#	mdep.c
# This archive created: Fri Oct 25 19:06:29 1985
export PATH; PATH=/bin:$PATH
echo shar: extracting "'cpg.1'" '(5283 characters)'
if test -f 'cpg.1'
then
	echo shar: will not over-write existing file "'cpg.1'"
else
sed 's/^X//' << \SHAR_EOF > 'cpg.1'
X.so /b/doc/nroffmacros/manmac
X.TH "cpg" "1" "Benetics Local"
X.ds C \fIcpg\fR
X.tr ~  
X.fi
X.ad b
X.SH NAME
cpg - C source listing formatter
X.SH SYNOPSIS
cpg [ -b<asename> ] [ -t tabstop ] [ file... ]
X.SH DESCRIPTION
\*C is a C language source listing formatter.  It employs certain
triggers to perform its formatting.  Those same triggers may be used to
extract in-line documentation to create documentation.  At the end of
the listing produced by \*C is a table of contents of all files and
functions contained in the current listing.  The table of contents is
sorted alphabetically by function and file.
X.P
The listing produced by \*C includes on each line a line number.  On each
line containing any braces ({}), there will also be a
nesting level indicator.  The nesting level indicator includes a number
(the current nesting level) and a directional character.  The
directional characters are:
X.IP > 6
The nesting level increased on this line
X.IP < 6
The nesting level decreased on this line
X.IP * 6
The nesting level changed both ways, with a net change of zero
X.P
The triggers that \*C recognizes are itemized below.  Each must appear
in column 1.
X.TP
<formfeed>
A formfeed will cause a new page to be started with a full header.
X.TP
/*F filename *<anything>
The file name may be specified in a comment preceding a descriptive
header block.  The filename argument must be delimited by asterisks in
the trigger.  The filename will appear in all page headings up to the
next filename trigger or the next file.  A filename comment block
\fBmust\fR be terminated by the endofblock trigger (see below).
This trigger will print as a line in the listing.  This trigger causes
the start of a new page (form feed) in the listing, with printing of the
page header including the current file name.
X.TP
/*H funcname *<anything>
The function name may be specified in a comment preceding a descriptive
header block.  The funcname argument must be delimited by asterisks in
the trigger.  The funcname will appear in all page headings up to the
next funcname trigger or the next file.  A funcname comment block
\fBmust\fR be terminated by the endofblock trigger (see below).
This trigger will print as a line in the listing.  This trigger causes
the start of a new page (form feed) in the listing, with printing of the
page header including the current function name.
X.TP
/*E*/
This is the endofblock trigger.  Everything between the last filename or
funcname trigger and the endofblock trigger will be passed straight
through by \*C without evaluation of nesting levels, comments, or quoted
strings.  Thus, a header block is treated as one long comment by \*C.
This trigger will print as a line in the listing.
X.TP
/*P*/
This is a page eject trigger.  It will not print in the listing, but
will be counted for line numbering purposes.  This trigger causes the
page heading, title, and subtitle to be reprinted based on their current
values (see title and subtitle below).
X.TP
/*S <text> */
This is the subtitle trigger.  It determines the contents of the second
title line on the page header.  All characters after the initial space
and up to but not including the following asterisk (required) are
included as part of the subtitle.  This trigger will not print in the
listing but will be counted for line numbering purposes.
X.TP
/*T <text> */
This is the title trigger.  It determines the contents of the first
title line on the page header.  All characters after the initial space
and up to but not including the following asterisk (required) are
included as part of the title.  This trigger will not print in the
listing but will be counted for line numbering purposes.
X.SS Options
X.IP "-b" 16
The basename option causes \fIcpg\fR to use only the basename portion of
the filename (whether obtained from the fileheader trigger or the
current filename) in page headers as well as the table of contents.
Thus, if a file is printed using "cpg -bt4 `pwd`/xyz.c", only "xyz.c"
will show up in the page header.
X.IP "-t tabstop" 16
The tabstop argument to the -t option specifies how to expand tabs.  The
expansion is performed automatically with a tabstop of 8 if none is
specified.
X.SS Arguments
X.IP file 16
Any number of file names may be specified on the command line (within
limits set by whichever shell is used).  Each file will be formatted and
its name added to the table of contents.  If no file names are
specified, \*C will read the standard input.
X.SH FILES
X.IP "/tmp/toc_XXXXXX" 20
temporary file for building the table of contents.
X.SH "SEE ALSO"
dtab(1), nl(1), pr(1), sort(1)
X.SH NOTES
This tool was developed at Benetics Corporation.
X.P
A side note: \*C also properly processes comments in shell scripts and
makefiles.  These comments are correctly handled when the comment
character (# or :) is the first nonblank character on a line.  In order
to facilitate documentation of shell scripts, \*C recognizes the
sequences #{ and #} as the beginning and ending of nesting, and treats
them as it does in C program sources.  Thus lengthy for, if, while, and
case statements may be more clearly documented as to nesting levels,
particulary in shell scripts.
X.SH AUTHOR
X.na
X.nf
XSteven M. List
Benetics Corporation
Mountain View, CA.
{cdp,idi,greipa,oliveb,sun,tolerant}!bene!luke!steven
SHAR_EOF
if test 5283 -ne "`wc -c < 'cpg.1'`"
then
	echo shar: error transmitting "'cpg.1'" '(should have been 5283 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'cpg.c'" '(24738 characters)'
if test -f 'cpg.c'
then
	echo shar: will not over-write existing file "'cpg.c'"
else
sed 's/^X//' << \SHAR_EOF > 'cpg.c'
/*Tcpg - c program source listing formatter */
/*F cpg.c **********************************************************
 *
 *                           cpg.c
 *
 *    DESCRIPTION OF FILE CONTENTS:
 *      C source program listing formatter source.
 *
 *  Cpg provides the facility to print out a C language source file
 *  with headers, nesting level indicators, and table of contents.
 *  It makes use of "triggers" for page headings, titles and
 *  subtitles, and pagination.  It also recognizes function
 *  declarations and form feeds and treats them appropriately.
 *
 *******************************************************************/
/*E*/
/*S includes, defines, and globals */
/*P*/
#include <stdio.h>
#include    <ctype.h>
#include    <time.h>

#define EQ ==
#define NE !=
#define GT >
#define GE >=
#define LT <
#define LE <=
#define OR ||
#define AND &&

#define TRUE 1
#define FALSE 0
#define YES 1
#define NO 0

#define SPACE ' '
#define NUL '\0'

typedef short   BOOL;

#define INULL -32768
#define LNULL -2147483648

#define MAX(a,b) ((a) > (b) ? (a) : (b))
#define MIN(a,b) ((a) < (b) ? (a) : (b))
#define ABS(a) ((a) >= 0 ? (a) : -(a))

#define LINESINHEAD 6
#define LPP 60
#define MAXWIDTH    130

#define notend(ll) ((ll[0] EQ SLASH AND ll[1] EQ STAR AND ll[2] EQ 'E') ? FALSE : TRUE)
#define SLASH   '/'
#define STAR    '*'
#define DQUOTE '"'
#define SQUOTE '\''
#define BSLASH '\\'

#ifdef BSD
#define strrchr rindex
#define strchr index
#endif BSD

extern char *strrchr ();
extern char *strchr ();

char    *basename ();

char    tim_lin[40];
char    *file_name;
char    fh_name[50] = "";
char    fnc_name[40] = "";
char    subttl[70] = "";
char    title[70] = "";
char    tocname[] = "/tmp/toc_XXXXXX";

int     nlvl = 0;

int     page_line = LPP+1;
int     pageno = 1;

int     tabstop = 8;

int     infunc = FALSE;
int     logging = 0;
int     BASENAME = FALSE;

int     incomment = FALSE;
int     insquote = FALSE;
int     indquote = FALSE;

char    specline = FALSE;

XFILE    *tocfile;
XFILE    *fd;

char    *pgm;

char    *ReservedWord[]  = { 
     "auto", "bool", "break", "case", "char", "continue",
     "default", "do", "double", "else", "entry", "enum",
     "extern", "float", "for", "goto", "if",
     "int", "long", "register", "return", "short",
     "sizeof", "static", "struct", "switch",
     "typedef", "union", "unsigned", "void", "while",
     NULL };

/*S main function */
/*Hmain */
/*E*/

main (ac, av)
int     ac;
char    **av;
{
    char    *std_input = "standard input";  /* input file name      */

    long    cur_time;               /* place for current raw time   */

    long    *time();                /* return raw time from system  */

    register int i;                 /* temporary for indexes, etc.  */

    struct tm *tim;                 /* return from localtime        */
    struct tm *localtime ();

    char    cmdbuf[40];             /* place to format sort command */

    extern char *optarg;            /* option argument pointer      */
    extern int   optind;            /* option index                 */

    pgm = basename (av[0]);

    while ((i = getopt (ac, av, "bl:t:")) NE EOF)
    {
        switch (i)
        {
            case    'b':
                BASENAME = TRUE;
                break;
            case    'l':
                logging = atoi (optarg);
                break;
            case    't':
                tabstop = atoi (optarg);
                break;
            default:
                fprintf (stderr,
        "usage: %s [ -b<asename> ] [ -t <tabstop> ] [ files... ]\n",
                        pgm);
        }
    }

    /* ------------------------------------------------------------ */
    /* set up the date/time portion of page headings                */
    /* ------------------------------------------------------------ */

    time(&cur_time);

    tim = localtime (&cur_time);
    sprintf (tim_lin, "Printed: %02d/%02d/%02d at %2d:%02d %s",
        tim->tm_mon + 1, tim->tm_mday, tim->tm_year,
        tim->tm_hour GT 12 ? tim->tm_hour - 12 : tim->tm_hour,
        tim->tm_min,
        tim->tm_hour GE 12 ? "PM" : "AM" );

    /* ------------------------------------------------------------ */
    /* create the temporary file for the table of contents          */
    /*   don't bother if output is to a terminal                    */
    /* ------------------------------------------------------------ */

    mktemp (tocname);
    if (!isatty (1))
    {
        tocfile = fopen (tocname, "w");
        if (!tocfile)
        {
            fprintf (stderr, "%s: unable to create tocfile %s\n",
                pgm, tocname);
            exit (2);
        }
    }

    /* ------------------------------------------------------------ */
    /* if no file names, read standard input                        */
    /* ------------------------------------------------------------ */

    if (optind EQ ac)
    {
        fd = stdin;
        file_name = std_input;
        dofile (fd);
    }
    else
    {
    /* ------------------------------------------------------------ */
    /* process each file named on the command line                  */
    /* ------------------------------------------------------------ */

        for (i = optind; i LT ac; i++)
        {
    /* ------------------------------------------------------------ */
    /* special file name `-' is standard input                      */
    /* ------------------------------------------------------------ */

            if (strcmp (av[i], "-") EQ 0)
            {
                fd = stdin;
                file_name = std_input;
            }
            else
            {
                fd = fopen (av[i], "r");
                if (fd EQ NULL)
                {
                    fprintf (stderr,
                        "cpg: unable to open %s\n", av[i]);
                }
            }
            if (fd NE NULL)
            {
                if (BASENAME) strcpy (fh_name, basename (av[i]));
                else strcpy (fh_name, av[i]);
                file_name = av[i];
                dofile (fd);
                fclose (fd);
            }
        }
    }

    fflush (stdout);

    /* ------------------------------------------------------------ */
    /* sort and print the table of contents - straight alpha order  */
    /* on function and file name                                    */
    /* ------------------------------------------------------------ */

    if (!isatty (1))
    {
        fclose (tocfile);
        sprintf (cmdbuf, "sort +1 -2 +0 -1 -u -o %s %s", tocname, tocname);
        system (cmdbuf);
        tocfile = fopen (tocname, "r");
        if (!tocfile)
        {
            fprintf (stderr, "%s: unable to read tocfile\n", pgm);
            exit (2);
        }
        else
        {
            tocout (tocfile);
            fclose (tocfile);
            if (!logging) unlink (tocname);
        }
    }

    fprintf (stdout, "\f");

    exit (0);
}
/*Sdofile - process an input file */
/*Hdofile*/
/*E*/
dofile (fd)
XFILE    *fd;
{
    register int i;                 /* temporary                    */

    int     lineno = 1;             /* line number in current file  */

    register char *line;            /* current line pointer         */

    char    ibuf[MAXWIDTH];         /* original input line          */
    char    ebuf[MAXWIDTH];         /* line with tabs expanded      */

    register char *p;               /* temporary char pointer       */

    /* ------------------------------------------------------------ */
    /* initialize the function name to `.' - unknown                */
    /* retrieve the basename portion of the file name               */
    /* ------------------------------------------------------------ */

    strcpy (fnc_name, ".");

    /* ------------------------------------------------------------ */
    /* if building TOC, add this entry                              */
    /* ------------------------------------------------------------ */

    if (!isatty (1))
        fprintf (tocfile,
            "%s %s %d %d\n", fh_name, fnc_name, pageno, lineno);

    /* ------------------------------------------------------------ */
    /* if tabs are to be expanded, use the expansion buffer         */
    /* ------------------------------------------------------------ */

    if (tabstop) line = ebuf;
    else         line = ibuf;

    /* ------------------------------------------------------------ */
    /* process each line in the file, looking for triggers          */
    /* ------------------------------------------------------------ */

    while (fgets (ibuf, MAXWIDTH, fd) NE NULL)
    {
        if (logging GE 9) fprintf (stderr, "%s: LOG: %s", pgm, line);
    /* ------------------------------------------------------------ */
    /* expand the input line                                        */
    /* ------------------------------------------------------------ */

        expand (ebuf, ibuf);

        if (line[0] EQ SLASH AND line[1] EQ STAR)
        {
    /* ------------------------------------------------------------ */
    /* comment found - could be a trigger                           */
    /* ------------------------------------------------------------ */

            switch (line[2])
            {
                case 'F':
                case 'H':
                {
                    if (logging GE 9) fprintf (stderr, "F/H header\n");
                    header (&lineno, line, fd);
                    break;
                }
                case 'P':
                {
                    if (logging GE 9) fprintf (stderr, "page break\n");
                    print_head ();
                    lineno++;
                    break;
                }
                case 'S':
                {
                    if (logging GE 9) fprintf (stderr, "subtitle\n");
                    getname (line, subttl);
                    lineno++;
                    break;
                }
                case 'T':
                {
                    if (logging GE 9) fprintf (stderr, "title\n");
                    getname (line, title);
                    /* print_head (); */
                    lineno++;
                    break;
                }
                default:
                {
                    if (logging GE 9) fprintf (stderr, "other comment\n");
                    print (&lineno, line);
                    break;
                }
            }
        }
        else
        {
    /* ------------------------------------------------------------ */
    /* not a comment - check for function declaration               */
    /* if a form feed is found, start a new page with header        */
    /* ------------------------------------------------------------ */

            if (logging GE 9) fprintf (stderr, "not a comment\n");
            if (!nlvl AND !isatty (1)) infunc = ckfunc (lineno, line);
            if (*line EQ '\f') print_head ();
            else print (&lineno, line);
        }
    }

    page_line = LPP+1;      /* force new page after file            */
    title[0] = NUL;         /* clear title and subtitle             */
    subttl[0] = NUL;

    return;
}
/*Sheader - construct and print header box */
/*Hheader*/
/*E*/
header  (lineno, line, fd)
register int     *lineno;
register char    *line;
register FILE    *fd;
{
    register char *p;

    if (line[2] EQ 'F')
    {
        getname (line, fh_name);
        if (BASENAME) strcpy (fh_name, basename (fh_name));
        strcpy (fnc_name, ".");
    }
    else if (line[2] EQ 'H')
    {
        getname (line, fnc_name);
    }

    if (!isatty (1))
        fprintf (tocfile,
            "%s %s %d %d\n", fh_name, fnc_name, pageno, *lineno);

    print_head ();

    print (lineno, line);

    while (fgets (line, MAXWIDTH, fd) NE NULL AND
            notend (line))
    {
        if (line[0] EQ SLASH AND line[1] EQ STAR AND line[2] EQ 'P')
        {
            print_head ();
            (*lineno)++;
        }
        else
        {
            print (lineno, line);
        }
    }

    print (lineno, line);

    return;
}
/*Sgetname - get a string from a signal line */
/*Hgetname */
/*E*/
getname (line, name)
register char    *line;
register char    *name;
{
    register int     i;
    register int     j;

    /* ------------------------------------------------------------ */
    /* skip leading spaces in the trigger line                      */
    /* copy up to trailing asterisk or end-of-line                  */
    /* strip trailing spaces                                        */
    /* ------------------------------------------------------------ */

    for (i = 3; isspace(line[i]) AND i LT MAXWIDTH; i++);

    for (j = 0; line[i] AND line[i] NE '*'; i++, j++)
    {
        name[j] = line[i];
    }

    while (j-- GT 0 AND isspace (name[j]));

    name[++j] = NUL;

    return;
}
/*Sprint - print a line with line number */
/*Hprint */
/*E*/
print (lineno, line)
register int     *lineno;
register char    *line;
{
    register int llen = strlen (line);
    register int i;

    register char sc = specline ? '*' : ' ';

    int     j = 0;

    register char    dc = NUL;

    /* ------------------------------------------------------------ */
    /* new page with header if page length is exceeded              */
    /* ------------------------------------------------------------ */

    if (page_line GT LPP)
    {
        print_head ();
    }

    /* ------------------------------------------------------------ */
    /* if brace(s) found,                                           */
    /*   modify the nesting level by the net nesting delta          */
    /*   select the indicator according to the net delta            */
    /*   if nexting is back to zero (none), clear function name     */
    /* ------------------------------------------------------------ */

    if (fnd (line, &j))
    {
        nlvl += j;

        if (j LT 0) dc = '<';
        else if (j EQ 0) dc = '*';
        else dc = '>';

        i = nlvl;
        if (j LT 0) i++;
        fprintf (stdout, "%4d%c%2d%c ",
            (*lineno)++, sc, i, dc);
        if (nlvl EQ 0) strcpy (fnc_name, ".");
    }
    else
    {
        fprintf (stdout, "%4d%c    ", (*lineno)++, sc);
    }

    /* ------------------------------------------------------------ */
    /* break up long lines by finding the first space form the end  */
    /* ------------------------------------------------------------ */

    if (llen GT 71)
    {
        for (i = 70; i GE 0; i--)
        {
            if (line[i] EQ SPACE)
            {
                fprintf (stdout, "%*.*s \\\n", i, i, line);
                page_line++;
                break;
            }
        }

        j = 79 - (llen - i);

        for (j; j GE 0; j--) putc (SPACE, stdout);

        fprintf (stdout, "%s", &line[i+1]);
    }
    else
    {
        fprintf (stdout, "%s", line);
    }

    page_line++;

    specline = FALSE;       /* true if function declaration     */

    return;
}
/*Sprint_head - print the page heading with page number */
/*Hprint_head */
/*E*/
print_head ()
{
    char    headbuf[80];
    register int len;

    sprintf (headbuf, "[ %s | %s <- %s",
        tim_lin, fh_name, fnc_name);

    for (len = strlen (headbuf); len LT 68; len++) headbuf[len] = SPACE;

    sprintf (&headbuf[68], "Page %-4d ]", pageno++);
    fprintf (stdout, "\f\n");
    if (!isatty (1))
        fprintf (stdout, "_______________________________________\
________________________________________");
    fprintf (stdout, "\n%s\n", headbuf);
    fprintf (stdout, "[-------------------------------+------\
---------------------------------------]\n");

    if (*title)
    {
        sprintf (headbuf, "[    %s", title);
    }
    else
    {
        sprintf (headbuf, "[    %s", fh_name);
    }
    for (len = strlen (headbuf); len LT 78; len++) headbuf[len] = SPACE;
    headbuf[78] = ']';
    fprintf (stdout, "%s\n", headbuf);

    if (*subttl)
    {
        sprintf (headbuf, "[    %s", subttl);
    }
    else
    {
        sprintf (headbuf, "[    %s", fnc_name);
    }
    for (len = strlen (headbuf); len LT 78; len++) headbuf[len] = SPACE;
    headbuf[78] = ']';
    fprintf (stdout, "%s", headbuf);

    if (!isatty (1))
        fprintf (stdout, "\r_______________________________________\
________________________________________");
    fprintf (stdout, "\n\n");

    page_line = LINESINHEAD;

    return;
}
/*S fnd - return true if a brace is found */
/*H fnd */
/*E*/
fnd (in, nchg)
register char *in;
register int    *nchg;
{
#   define LBRACE   '{'
#   define RBRACE   '}'
#   define SHARP    '#'
#   define COLON    ':'

    register found = FALSE;         /* true if keyword found        */

    register char blank = TRUE;     /* used to check for shell/make */
                                    /* comments beginning with #/:  */
    register int inshcomment = FALSE;   /* true if in shell comment */

    *nchg = 0;              /* initialize net change to zero        */

    /* ------------------------------------------------------------ */
    /* check each character of the line                             */
    /* ------------------------------------------------------------ */

    for (in; *in; in++)
    {
        if (!incomment AND !inshcomment AND !indquote AND !insquote)
        {
            if (logging GE 9) fprintf (stderr, "not in comment or quote\n");
            if (*in EQ SLASH AND *(in+1) EQ STAR)
            {
                incomment = TRUE;
                blank = FALSE;
                if (logging GE 9) fprintf (stderr, "new comment\n");
            }
            else if (blank AND
                     ((*in EQ SHARP OR *in EQ COLON) AND
                     (*(in+1) NE LBRACE AND *(in+1) NE RBRACE))
                    )
            {
                inshcomment = TRUE;
                blank = FALSE;
                if (logging GE 9) fprintf (stderr, "new shell comment\n");
            }
            else if (*in EQ DQUOTE AND
                    (*(in-1) NE BSLASH OR *(in-2) EQ BSLASH))
            {
                indquote = TRUE;
                blank = FALSE;
                if (logging GE 9) fprintf (stderr, "new dquote\n");
            }
            else if (*in EQ SQUOTE AND
                    (*(in-1) NE BSLASH OR *(in-2) EQ BSLASH))
            {
                insquote = TRUE;
                blank = FALSE;
                if (logging GE 9) fprintf (stderr, "new squote\n");
            }
            else if (*in EQ LBRACE)
            {
                (*nchg)++;
                found = TRUE;
                blank = FALSE;
                if (logging GE 9) fprintf (stderr, "nest in\n");
            }
            else if (*in EQ RBRACE)
            {
                (*nchg)--;
                found = TRUE;
                blank = FALSE;
                if (logging GE 9) fprintf (stderr, "nest out\n");
            }
            else if (!isspace (*in))
            {
                blank = FALSE;
            }
        }
        else if (incomment AND *in EQ STAR AND *(in+1) EQ SLASH)
        {
            incomment = FALSE;
            if (logging GE 9) fprintf (stderr, "end comment\n");
        }
        else if (indquote AND *in EQ DQUOTE AND
                (*(in-1) NE BSLASH OR *(in-2) EQ BSLASH))
        {
            indquote = FALSE;
            if (logging GE 9) fprintf (stderr, "end dquote\n");
        }
        else if (insquote AND *in EQ SQUOTE AND
                (*(in-1) NE BSLASH OR *(in-2) EQ BSLASH))
        {
            insquote = FALSE;
            if (logging GE 9) fprintf (stderr, "end squote\n");
        }
    }
    
    return found;
}
/*Stocout - print out the table of contents */
/*Htocout */
/*E*/
tocout (toc)
XFILE    *toc;
{
    char    buf[80];
    char    filenam[80];
    char    fncnam[80];
    int     page;
    int     line;

    char    outline[80];

    register int toclines = 99;

    while (fscanf (toc, "%s%s%d%d", filenam, fncnam, &page, &line) EQ 4)
    {
        if (toclines GT 54)
        {
            printf ("\f\n\
                             _____________________\n\
                             [ TABLE OF CONTENTS ]\r\
                             _____________________\n\n\
                File -> Function                     Page    Line\r\
________________________________________\
________________________________________\n\n");
            toclines = 0;
        }

        toclines++;

        printf ("\
    %16s -> %-16.16s ............ %3d   %5d\n",
            filenam, *fncnam EQ '.' ? "START" : fncnam, page, line);
    }
    return;
}
/*S expand - expand tabs to tabstop */
/*H expand */
/*E*/
expand (to, from)
register char *to;
register char *from;
{
    register int i;
    register int tofill;

#   define BACKSPACE '\b'
#   define FORMFEED '\f'
#   define NEWLINE '\n'
#   define RETURN '\r'
#   define TAB '\t'
    
    i = 0;

    while (*from)
    {
        switch (*from)
        {
            case    TAB:
                tofill = tabstop - (i % tabstop);
                i += tofill;
                while (tofill--) *(to++) = SPACE;
                break;
            case    NEWLINE:
            case    RETURN:
                i = 0;
            case    FORMFEED:
                *(to++) = *from;
                break;
            case    BACKSPACE:
                i--;
                *(to++) = *from;
                break;
            default:
                i++;
                *(to++) = *from;
                break;
        }

        from++;
    }

    *to = NUL;

    return;
}
/*S ckfunc - check line for function declaration */
/*H ckfunc */
/*E*/

#define isidchr(c) (isalnum(c) || (c == '_'))

ckfunc (lineno, s)
register int lineno;
register char   *s;
{
    register char *p;
    register int  Cnt;
    register int  i;
    register int  result;
    register char found = FALSE;

    static char *_fnm = "ckfunc";

    char FunctionName[40];

    if (logging GE 3)
    {
        fprintf (stderr,
            "%s<%s>: LOG: ckfunc called - line = %s",
            pgm, _fnm, s);
    }

    if(!strcmp (fnc_name, ".") AND !incomment && !indquote && !insquote)
    {
        found = TRUE;

        while (found)
        {
            found = FALSE;
            p = FunctionName;
            for (s; isascii (*s) && isspace (*s) && *s; s++);
            if( *s == '*' )
            {
                for (++s; isascii (*s) && isspace (*s) && *s; s++);
            }

            if ((*s == '_') || isalpha(*s))
            {
                while (isidchr (*s)) *p++ = *s++;

                *p = '\0';

                for (found = FALSE, i = 0;
                     !found AND ReservedWord[i]; i++)
                {
                    if (!(result = strcmp (FunctionName, ReservedWord[i])))
                        found = TRUE;

                    if  (result < 0) break;
                }

                if (logging GE 3 AND found)
                {
                    fprintf (stderr,
                        "%s<%s>: LOG: reserved word = %s\n",
                        pgm, _fnm, FunctionName);
                }
            }
        }

        if (logging GE 3)
        {
            fprintf (stderr,
                "%s<%s>: LOG: last word = %s\n",
                pgm, _fnm, FunctionName);
        }
        
        for (s; isascii (*s) && isspace (*s) && *s; s++);

        if (*s EQ '(')
        {
            for (found = FALSE; *s AND !found; s++)
                found = *s EQ ')';
            
            if (found)
            {
                for (; *s AND isspace (*s); s++);

                found = *s NE ';';
                
                if (found)
                {
                    strcpy (fnc_name, FunctionName);
                    fprintf (tocfile,
                        "%s %s %d %d\n",
                        fh_name, fnc_name, pageno-1, lineno);
                    specline = TRUE;
                }
            }
        }
    }

    if (logging GE 3)
    {
        fprintf (stderr,
    "%s<%s>: LOG: this line does%s contain a function declaration\n",
            pgm, _fnm, found ? "" : " not");
    }

    return found;
}
/*S basename - return the basename part of a pathname */
/*H basename *********************************************************
*
*                                   basename
*
*  given a (presumed) pathname, return the part after the last slash
*
*********************************************************************/
/*E*/
char *
basename (str)
register char *str;
{
    register char *ret;

    if (ret = strrchr (str, '/')) ret++;
    else ret = str;

    return ret;
}
SHAR_EOF
if test 24738 -ne "`wc -c < 'cpg.c'`"
then
	echo shar: error transmitting "'cpg.c'" '(should have been 24738 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'mdep.1'" '(2641 characters)'
if test -f 'mdep.1'
then
	echo shar: will not over-write existing file "'mdep.1'"
else
sed 's/^X//' << \SHAR_EOF > 'mdep.1'
X.TH "mdep" "1" "Benetics Local"
X.fi
X.ad b
X.SH NAME
mdep - generate the dependency list for C sources
X.SH SYNOPSIS
mdep [ -D symbol ] [ -I searchpath ] [ -r ] [ -x \fIabc\fR ]
X.br
     sourcefiles
X.SH DESCRIPTION
The purpose of \fImdep\fR is to generate the list of include file
dependencies for some source file.  The source files are expected to be
C language source files, and may include either .c or .h files (or any
other file, for that matter).  The source files are examined for lines
containing the `#include' statement (also `$include' for those of us who
use UNIFY), and those file names are included in the list of dependencies.
X.P
Additional features are provided by command line options: recursive
expansion of include files (includes that include includes), suppression
of expansion of specific include files, and Defining symbols so that the
appropriate dependencies are generated.
X.SS Options
X.IP "-D symbol" 16
Define a symbol (as you would to the C preprocessor) to cause the
recognition of the appropriate sections of code.  Since \fImdep\fR does
not read #define statements in the source files, this is the only way of
causing symbols to be defined.  Conversely, symbols are #undef by
default.  Multiple occurrences of the -D option, with argument, may
appear in the command line.
X.IP "-I searchpath" 16
Define a directory to be searched for include files, as is done for the
C preprocessor.  Multiple occurrences of the -I option, with argument,
may appear in the command line.
X.IP "-r" 16
Perform recursive expansion of include files.  Thus, if an include file
includes other files, include those file names (and so on) in the
dependency list.  This option is moderated by the -x option.
X.IP "-x filename" 16
Exclude a file from recursive expansion.  The filename associated with
this option may omit the .h suffix, and \fImdep\fR will append the
suffix.
X.SS Arguments
X.IP sourcefile 16
One or more C source files to be processed.  The files may actually be
any ascii file.
X.SH EXAMPLES
The following example shows the command to process mdep.c and the output
from the command:
X.nf
X.RS 6
X.P
% mdep -r mdep.c
X.sp
mdep.o: \\
        /usr/include/sys/types.h \\
        /usr/include/sys/dir.h \\
        /usr/include/stdio.h 
X.RE
X.fi
X.P
To generate the dependency list for file `foo.c' that includes `foo.h'
which includes some standard files:
X.nf
X.RS 6
X.P
% mdep -r -I/usr/local/include foo.c
X.sp
foo.o: \\
        ./foo.h \\
        /usr/include/stdio.h 
X.RE
X.fi
X.SH "SEE ALSO"
make(1)
X.SH AUTHOR
X.nf
X.na
XSteven M. List
Benetics Corporation
Mountain View, CA.
{cdp,idi,greipa,oliveb,sun,tolerant}!bene!luke!steven
X.ad b
SHAR_EOF
if test 2641 -ne "`wc -c < 'mdep.1'`"
then
	echo shar: error transmitting "'mdep.1'" '(should have been 2641 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'mdep.c'" '(19941 characters)'
if test -f 'mdep.c'
then
	echo shar: will not over-write existing file "'mdep.c'"
else
sed 's/^X//' << \SHAR_EOF > 'mdep.c'
/*T mdep - generate a list of make dependencies */
/*F mdep.c ***********************************************************
*
*                                  mdep.c
*
*  generate the list of make dependencies for a source file.  The
*  program can optionally do recursive expansions (for includes that
*  include includes) and suppress expansion of specific files.
*
*  This program was written for and tested ONLY on SYSTEM III.  While
*  there is the possibility that it will work on other systems, it
*  is not assured.
*
*  Permission to use, modify, and pass along this program is granted
*  as long as this notice is included.
*
*  (c) 1985		Steven List
*               Benetics Corporation
*               Mountain View, CA
*               {cdp,greipa,idi,oliveb,sun,tolerant}!bene!luke!steven
*
*********************************************************************/
/*E*/
/*S some global declarations and stuff */
/*Page Eject */
#ifdef BSD
#	define	strchr	index
#	define	strrchr	rindex
#endif BSD

char	*Allocate ();
char	*ReAllocate ();

int		mstrcmp ();
int		pstrcmp ();

#include    <sys/types.h>
#include    <sys/dir.h>
#include    <stdio.h>

/* ------------------------------------------------------------ */
/* some standard defines - easier to include than change        */
/* ------------------------------------------------------------ */

#define EQ ==
#define NE !=
#define GT >
#define GE >=
#define LT <
#define LE <=
#define OR ||
#define AND &&

#define TRUE 1
#define FALSE 0
#define YES 1
#define NO 0

#define SPACE ' '
#define NUL '\0'

typedef unsigned char   BOOL;

#define INULL -32768
#define LNULL -2147483648

#define MAX(a,b) ((a) > (b) ? (a) : (b))
#define MIN(a,b) ((a) < (b) ? (a) : (b))
#define ABS(a) ((a) >= 0 ? (a) : -(a))

int		MAXDIRS = 10;
int		MAXNOEXP = 10;
int		MAXFILES = 128;

	/* ------------------------------------------------------------ */
	/* a description of each file in the search path                */
	/* ------------------------------------------------------------ */

struct  file
{
    char    name[DIRSIZ+1];
    int     dirind;
}	*file;

	/* ------------------------------------------------------------ */
	/* counts of directories and files under consideration          */
	/* ------------------------------------------------------------ */

int		nfil = 0;
int		ndir = 0;

	/* ------------------------------------------------------------ */
	/* the list of directories searched                             */
	/* ------------------------------------------------------------ */

char	**dirs;

	/* ------------------------------------------------------------ */
	/* exclusion table and counter                                  */
	/* ------------------------------------------------------------ */

char	**noexp;				/* exclusion list				*/
int		nx = 0;					/* number of exclusions			*/

	/* ------------------------------------------------------------ */
	/* some stuff to handle #ifdef/#else/#endif                     */
	/* ------------------------------------------------------------ */

char	**deftab;			/* list of objects defined				*/
int		ndef = 0;			/* number of objects defined			*/

BOOL    recursion = FALSE;

char	*pgm;

/*S main - control all processing, and do a lot of it */
/*H main *************************************************************
*
*                                   main
*
*  process the command line, set up the lists of files, and then 
*  process the input file(s).
*
*********************************************************************/
/*E*/
main (ac, av)
register int     ac;
char    *av[];
{
    int     		fcmp ();		/* compare two file entries		*/
    register int	i;				/* general purpose stuff		*/
    int    			strcmp ();		/* compare two strings			*/

    char    *strchr ();
    char    *strrchr ();

    /* getopt stuff */

    extern char *optarg;
    extern int  optind;

	/* ------------------------------------------------------------ */
	/* for logging and stuff, set up program name (basename only)   */
	/* ------------------------------------------------------------ */

	if (pgm = strrchr (av[0], '/')) pgm++;
	else pgm = av[0];

	/* ------------------------------------------------------------ */
	/* provide initial allocations of space for tables/lists        */
	/* ------------------------------------------------------------ */

	dirs = (char **) Allocate (MAXDIRS, sizeof (char *));
	file = (struct file *) Allocate (MAXFILES, sizeof (struct file));
	noexp = (char **) Allocate (MAXNOEXP, sizeof (char *));
	deftab = (char **) Allocate (1, sizeof (char *));

	/* ------------------------------------------------------------ */
	/* put the current directory in first - same as C compiler      */
	/* ------------------------------------------------------------ */

	dirs[ndir] = (char *) Allocate (1, 2);
    strcpy (dirs[ndir], ".");      /* first is always current directory    */
    dirlist (dirs[ndir++]);
/*Page Eject*/
	/* ------------------------------------------------------------ */
	/* process the command line options                             */
	/* ------------------------------------------------------------ */

    while ( (i = getopt (ac, av, "D:I:x:r")) NE EOF)
    {
        switch (i)
        {
			case	'D':			/* define objects				*/
				deftab[ndef] = (char *)
					Allocate (1, strlen (optarg) + 1);
				strcpy (deftab[ndef], optarg);
				deftab = (char **)
					ReAllocate (deftab, (++ndef) * sizeof (char *));
				break;
            case    'I':			/* search directory - like cc	*/
				ndir++;
				if (!dirlist (optarg)) 
				{
					dirs[ndir-1] = (char *)
						Allocate (1, strlen (optarg) + 1);
					strcpy (dirs[ndir-1], optarg);
					if (ndir GE MAXDIRS)
					{
						MAXDIRS += 10;
						dirs = (char **) ReAllocate (dirs,
										MAXDIRS * sizeof (char *));
					}
				}
				else ndir--;
                break;
            case    'x':			/* a file to exclude			*/
				noexp[nx] = (char *) Allocate (1, strlen (optarg) + 3);
                strcpy (noexp[nx], optarg);
				if (!strrchr (optarg, '.')) strcat (noexp[nx], ".h");
				nx++;
				if (nx GE MAXNOEXP)
				{
					MAXNOEXP += 10;
					noexp = (char **) ReAllocate (noexp,
										MAXNOEXP * sizeof (char *));
				}
                break;
            case    'r':			/* turn on recursive search		*/
                recursion = TRUE;
                break;
            default:
                fprintf (stderr,
                    "<%s> unknown argument - %c\n", pgm, i);
                break;
        }
    }
/*Page Eject*/
	/* ------------------------------------------------------------ */
	/* add /usr/include as the last of the directories - as cc      */
	/* ------------------------------------------------------------ */

	dirs[ndir] = (char *) Allocate (1, strlen ("/usr/include") + 1);
    strcpy (dirs[ndir], "/usr/include");
    dirlist (dirs[ndir++]);

	/* ------------------------------------------------------------ */
	/* sort the include file list for use with bsearch              */
	/* ------------------------------------------------------------ */

    qsort (file, nfil, sizeof(struct file), fcmp);

	/* ------------------------------------------------------------ */
	/* if we are doing recursive searches, also sort the exclusions */
	/* ------------------------------------------------------------ */

    if (recursion) qsort (noexp, nx, sizeof noexp[0], pstrcmp);

	/* ------------------------------------------------------------ */
	/* if there are any definitions, sort the define table          */
	/* ------------------------------------------------------------ */

	if (ndef) qsort (deftab, ndef, sizeof (char *), pstrcmp);

	/* ------------------------------------------------------------ */
	/* Now that we've complete the tedious job of setting up,       */
	/*  process each remaining command line argument (they are      */
	/*  expected to be C source file names)                         */
	/* ------------------------------------------------------------ */

    for (i = optind; i LT ac; i++)
    {
        dofile (av[i], FALSE);
    }

    exit (0);
}
/*S dirlist - expand a directory name into a list of include files */
/*H dirlist **********************************************************
*
*                                   dirlist
*
*  Examine each entry in a directory.  If a file is an include file
*  (name ends with .h), include it and the directory index in the
*  file list.
*
*********************************************************************/
/*E*/
dirlist (dnam)
register char    *dnam;			/* directory path name				*/
{
    register int    i;			/* general purpose stuff			*/

    register char   c;			/* ditto							*/
    register char   *ptr;		/* again							*/

    char    *strrchr ();		/* find char from end				*/

    static char   *fn = "dirlist";	/* function name for logging	*/

    register FILE    *dir;		/* directory file stream			*/

	struct direct direct;		/* place to read entries into		*/

	/* ------------------------------------------------------------ */
	/* attempt to open the directory file - exit on error           */
	/* ------------------------------------------------------------ */

    if ( (dir = fopen (dnam, "r")) EQ NULL)
    {
        fprintf (stderr,
            "dirlist: unable to open directory %s for read\n", dnam);
        return (1);
    }
    else
    {
	/* ------------------------------------------------------------ */
	/* read each directory entry                                    */
	/* if the entry is active                                       */
	/*  if the file is an include file (*.h)                        */
	/*   copy the name and directory index into the file list       */
	/* ------------------------------------------------------------ */

        while (fread (&direct, sizeof direct, 1, dir) EQ 1)
        {
			if (direct.d_ino)
			{
				for (ptr = &direct.d_name[DIRSIZ-1]; !*ptr; ptr--);

				if (*ptr EQ 'h' AND *(ptr-1) EQ '.')
				{
					strncpy (file[nfil].name, direct.d_name, DIRSIZ+1);
					file[nfil].dirind = ndir - 1;
					nfil++;

	/* ------------------------------------------------------------ */
	/* if we're out of space in the list, allocate some more        */
	/* ------------------------------------------------------------ */

					if (nfil GE MAXFILES)
					{
						MAXFILES += 50;
						file = (struct file *) ReAllocate (file,
									MAXFILES * sizeof (struct file));
					}
				}
			}
		}
        fclose (dir);
    }

    return (0);
}
/*S dofile - process an input (C source) file */
/*H dofile ***********************************************************
*
*                                   dofile
*
*  examine each line of the input file.  If the first char is either
*  # or $ (UNIFY includes, for those of us who use it) and the next
*  word is include, look for the named file.  If the input file name
*  is `-', read from standard input and provide a default dependency
*  name.
*
*********************************************************************/
/*E*/
dofile (fnam, suppress)
char    *fnam;					/* input file name					*/
register BOOL    suppress;		/* true if this is called for		*/
								/* recursive expansion and file name*/
								/* has already been printed			*/
{
    register FILE    *curfile;	/* current input file stream		*/

    char    dep[80];			/* place for dependency object name	*/
	register char *c;			/* temp pointer						*/
	register char *cd;			/* temp pointer						*/
    static char *fn = "dofile";	/* function name for logging		*/
    char    lbuf[120];			/* input line buffer				*/
    register char    *suffix;	/* pointer to file name suffix		*/
    char    tname[80];			/* place to build full name			*/

	register int count = 0;		/* number of things matched - sscanf*/

    register struct  file *iname;	/* pointer to matching file		*/

    struct  file *bsearch ();

    register int     i;			/* general purpose stuff			*/
	register BOOL skip = FALSE;	/* true if skipping because of DEF	*/

    int     strcmp ();

    BOOL    first = TRUE;		/* true for initial condition		*/

	/* ------------------------------------------------------------ */
	/* open the current file if it is not stdin                     */
	/* ------------------------------------------------------------ */

	if (strcmp (fnam, "-") EQ 0)
	{
		curfile = stdin;
		fnam = "standardin.c";
	}
	else
	{
		curfile = fopen (fnam, "r");
	}

    if (curfile EQ NULL)
    {
        fprintf (stderr, "<%s> _error_ cannot open %s\n", fn, fnam);
    }
    else
    {
	/* ------------------------------------------------------------ */
	/* look at each line in the file and process those beginning    */
	/*  with a legal include statement                              */
	/* ------------------------------------------------------------ */

        while (fgets (lbuf, sizeof lbuf, curfile) EQ lbuf)
        {
			skip = ckdef (lbuf, skip);
			if (skip) continue;
			count = sscanf (lbuf, "%*[#$] include%s", dep);
            if (count EQ 1)
            {
	/* ------------------------------------------------------------ */
	/* if this is the first time in, print out the file name        */
	/* ------------------------------------------------------------ */

                if (first AND !suppress)
                {
                    suffix = &fnam[strlen(fnam)-1];
                    if (*suffix EQ 'c') *suffix = 'o';
                    printf ("%s: ", fnam);
                    first = FALSE;
                }
	/* ------------------------------------------------------------ */
	/* clean up the dependency name                                 */
	/* ------------------------------------------------------------ */

				c = cd = dep;
				while ((*c = *(++cd)) NE '>' AND *c NE '"') c++;
				*c = NUL;

	/* ------------------------------------------------------------ */
	/* if the include is sys/something.h, assume that it's from     */
	/*   /usr/include/sys, since this is the 99.9% case             */
	/* ------------------------------------------------------------ */

				if (strncmp (dep, "sys/", 4) EQ 0)
				{
					printf ("\\\n\t\t/usr/include/%s ", dep);
				}
				else if (strchr (dep, '/'))
				{
					printf ("\\\n\t\t%s ", dep);
				}
				else
				{
	/* ------------------------------------------------------------ */
	/* look for the include file name in the list of known files    */
	/* ------------------------------------------------------------ */

					iname = bsearch (dep, file, nfil,
								sizeof(struct file), strcmp);
					if (iname)
					{
	/* ------------------------------------------------------------ */
	/* since there might be more than one copy of the include file  */
	/*  back up to the first (bsearch will just find one)           */
	/* ------------------------------------------------------------ */

						while (iname GT file)
						{
							if (strcmp (iname, iname - 1) EQ 0)
								iname--;
							else
								break;
						}
						printf ("\\\n\t\t%s/%s ",
							dirs[iname->dirind], dep);
	/* ------------------------------------------------------------ */
	/* if recursive search was requested and the file is not        */
	/*  in the exclusion list, then look for its includes           */
	/* ------------------------------------------------------------ */

						if (recursion AND
							!bsearch (dep, noexp, nx,
									sizeof (char *), mstrcmp))
						{
							sprintf (tname,
								"%s/%s", dirs[iname->dirind], dep);
							dofile (tname, TRUE);
						}
					}
	/* ------------------------------------------------------------ */
	/* things that have paths in them, either relative or absolute, */
	/*   will be passed through as is.  since this is generally     */
	/*   contrary to standard coding practice, it should be ok for  */
	/*   the majority of the cases                                  */
	/* ------------------------------------------------------------ */

					else
					{
						printf ("\\\n\t\t%s ", dep);
					}
				}
            }
        }
        if (!suppress) printf ("\n");
        fclose (curfile);
    }
}
/*S fcmp - compare two file list entries */
/*H fcmp *************************************************************
*
*                                   fcmp
*
*  a comparison function for qsort to call
*
*********************************************************************/
/*E*/
fcmp (f1, f2)
struct file *f1;
struct file *f2;
{
	register int i;

	if (i = strncmp (f1->name, f2->name, sizeof f1->name))
		return i;
	else
		return f1->dirind - f2->dirind;
}
/*S Allocate - call calloc and process return */
/*H Allocate *********************************************************
*
*                                   Allocate
*
*  veneer over calloc to handle bad returns
*
*********************************************************************/
/*E*/
char *
Allocate (nelem, size)
register int nelem;
register int size;
{
	extern char *calloc ();

	register char *to;

	if (!(to = calloc (nelem, size)))
	{
		fprintf (stderr,
			"%s: allocation failure - %d * %d\n",
			pgm, nelem, size);
		exit (99);
	}

	return to;
}
/*S ReAllocate - call calloc and process return */
/*H ReAllocate *******************************************************
*
*                                   ReAllocate
*
*  veneer over realloc to handle bad returns
*
*********************************************************************/
/*E*/
char *
ReAllocate (oldp, size)
register char *oldp;
register int size;
{
	extern char *realloc ();

	register char *to;

	if (!(to = realloc (oldp, size)))
	{
		fprintf (stderr,
			"%s: reallocation failure - %d\n",
			pgm, size);
		exit (99);
	}

	return to;
}
/*S ckdef - check for #ifdef/ifndef/else/endif line */
/*H ckdef ************************************************************
*
*                                   ckdef
*
*  Look at the line and return the appropriate status depending on
*  whether or not a preprocessor symbol is defined or not.
*
*********************************************************************/
/*E*/
ckdef (buf, skip)
register char *buf;				/* line to check					*/
register BOOL skip;				/* current state of skip			*/
{
	char	sym[40];			/* defined symbol if found			*/

	char	lbuf[120];			/* local buffer						*/

	register int count = 0;		/* return from sscanf				*/

	count = sscanf (buf, "%*[#$]%s", lbuf);

	if (count EQ 1)
	{
		if (!skip AND !strcmp (lbuf, "ifdef"))
		{
			sscanf (buf, "%*[#$]%*s%s", sym);
			skip = !(BOOL)bsearch (sym, deftab, ndef,
					sizeof(char *), mstrcmp);
		}
		else if (!skip AND !strcmp (lbuf, "ifndef"))
		{
			sscanf (buf, "%*[#$]%*s%s", sym);
			skip = (BOOL)bsearch (sym, deftab,
					ndef, sizeof(char *), mstrcmp);
		}
		else if (!strcmp (lbuf, "else"))
		{
			skip = !skip;
		}
		else if (skip AND !strcmp (lbuf, "endif"))
		{
			skip = !skip;
		}
	}

	return skip;
}
/*S mstrcmp - compare two strings given one direct and one indirect */
/*H mstrcmp **********************************************************
*
*                                   mstrcmp
*
*  for use with bsearch, this assumes that the arguments are a
*  string address and a pointer to a string address.  This is
*  used to allow the comparison of a string to a string pointed
*  to by an element of `noexp'.
*
*********************************************************************/
/*E*/
mstrcmp (s1, s2)
register char *s1;
register char **s2;
{
	return strcmp (s1, *s2);
}
/*S pstrcmp - compare two strings given pointers to pointers */
/*H pstrcmp **********************************************************
*
*                                   pstrcmp
*
*  for use with qsort and bsearch, this assumes that the arguments
*  passed are pointers to the string addresses rather than the
*  addresses of the strings
*
*********************************************************************/
/*E*/
pstrcmp (s1, s2)
register char **s1;
register char **s2;
{
	return strcmp (*s1, *s2);
}
SHAR_EOF
if test 19941 -ne "`wc -c < 'mdep.c'`"
then
	echo shar: error transmitting "'mdep.c'" '(should have been 19941 characters)'
fi
fi # end of overwriting check
#	End of shell archive
exit 0
