Subject:  v20i030:  Command-line editor with predictions, Part02/04
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Mark James <jamesm@cpsc.UCalgary.CA>
Posting-number: Volume 20, Issue 30
Archive-name: reactivekbd/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 4)."
# Contents:  getopt.c parse_keys.c rk.1
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'getopt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getopt.c'\"
else
echo shar: Extracting \"'getopt.c'\" \(16259 characters\)
sed "s/^X//" >'getopt.c' <<'END_OF_FILE'
X
X#undef _POSIX_OPTION_ORDER
X
X/* Getopt for GNU.
X   Modified by David MacKenzie to use malloc and free instead of alloca,
X   and memcpy instead of bcopy under System V.
X   Copyright (C) 1987 Free Software Foundation, Inc.
X
X               NO WARRANTY
X
X  BECAUSE THIS PROGRAM IS LICENSED FREE OF CHARGE, WE PROVIDE ABSOLUTELY
XNO WARRANTY, TO THE EXTENT PERMITTED BY APPLICABLE STATE LAW.  EXCEPT
XWHEN OTHERWISE STATED IN WRITING, FREE SOFTWARE FOUNDATION, INC,
XRICHARD M. STALLMAN AND/OR OTHER PARTIES PROVIDE THIS PROGRAM "AS IS"
XWITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
XBUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
XFITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY
XAND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE
XDEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
XCORRECTION.
X
X IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW WILL RICHARD M.
XSTALLMAN, THE FREE SOFTWARE FOUNDATION, INC., AND/OR ANY OTHER PARTY
XWHO MAY MODIFY AND REDISTRIBUTE THIS PROGRAM AS PERMITTED BELOW, BE
XLIABLE TO YOU FOR DAMAGES, INCLUDING ANY LOST PROFITS, LOST MONIES, OR
XOTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
XUSE OR INABILITY TO USE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR
XDATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD PARTIES OR
XA FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS) THIS
XPROGRAM, EVEN IF YOU HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH
XDAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.
X
X        GENERAL PUBLIC LICENSE TO COPY
X
X  1. You may copy and distribute verbatim copies of this source file
Xas you receive it, in any medium, provided that you conspicuously and
Xappropriately publish on each copy a valid copyright notice "Copyright
X (C) 1987 Free Software Foundation, Inc."; and include following the
Xcopyright notice a verbatim copy of the above disclaimer of warranty
Xand of this License.  You may charge a distribution fee for the
Xphysical act of transferring a copy.
X
X  2. You may modify your copy or copies of this source file or
Xany portion of it, and copy and distribute such modifications under
Xthe terms of Paragraph 1 above, provided that you also do the following:
X
X    a) cause the modified files to carry prominent notices stating
X    that you changed the files and the date of any change; and
X
X    b) cause the whole of any work that you distribute or publish,
X    that in whole or in part contains or is a derivative of this
X    program or any part thereof, to be licensed at no charge to all
X    third parties on terms identical to those contained in this
X    License Agreement (except that you may choose to grant more
X    extensive warranty protection to third parties, at your option).
X
X    c) You may charge a distribution fee for the physical act of
X    transferring a copy, and you may at your option offer warranty
X    protection in exchange for a fee.
X
X  3. You may copy and distribute this program or any portion of it in
Xcompiled, executable or object code form under the terms of Paragraphs
X1 and 2 above provided that you do the following:
X
X    a) cause each such copy to be accompanied by the
X    corresponding machine-readable source code, which must
X    be distributed under the terms of Paragraphs 1 and 2 above; or,
X
X    b) cause each such copy to be accompanied by a
X    written offer, with no time limit, to give any third party
X    free (except for a nominal shipping charge) a machine readable
X    copy of the corresponding source code, to be distributed
X    under the terms of Paragraphs 1 and 2 above; or,
X
X    c) in the case of a recipient of this program in compiled, executable
X    or object code form (without the corresponding source code) you
X    shall cause copies you distribute to be accompanied by a copy
X    of the written offer of source code which you received along
X    with the copy you received.
X
X  4. You may not copy, sublicense, distribute or transfer this program
Xexcept as expressly provided under this License Agreement.  Any attempt
Xotherwise to copy, sublicense, distribute or transfer this program is void and
Xyour rights to use the program under this License agreement shall be
Xautomatically terminated.  However, parties who have received computer
Xsoftware programs from you with this License Agreement will not have
Xtheir licenses terminated so long as such parties remain in full compliance.
X
X  5. If you wish to incorporate parts of this program into other free
Xprograms whose distribution conditions are different, write to the Free
XSoftware Foundation at 675 Mass Ave, Cambridge, MA 02139.  We have not yet
Xworked out a simple rule that can be stated here, but we will often permit
Xthis.  We will be guided by the two goals of preserving the free status of
Xall derivatives of our free software and of promoting the sharing and reuse of
Xsoftware.
X
X
XIn other words, you are welcome to use, share and improve this program.
XYou are forbidden to forbid anyone else to use, share and improve
Xwhat you give them.   Help stamp out software-hoarding!  */
X
X/* This version of `getopt' appears to the caller like standard Unix `getopt'
X   but it behaves differently for the user, since it allows the user
X   to intersperse the options with the other arguments.
X
X   As `getopt' works, it permutes the elements of `argv' so that,
X   when it is done, all the options precede everything else.  Thus
X   all application programs are extended to handle flexible argument order.
X
X   Setting the environment variable _POSIX_OPTION_ORDER disables permutation.
X   Then the behavior is completely standard.
X
X   GNU application programs can use a third alternative mode in which
X   they can distinguish the relative order of options and other arguments.  */
X
X#include <stdio.h>
X
X#if SYSV || SYSVR3
X#define bcopy(s, d, l) memcpy((d), (s), (l))
X#define index strchr
X#endif
X
X/* For communication from `getopt' to the caller.
X   When `getopt' finds an option that takes an argument,
X   the argument value is returned here.
X   Also, when `ordering' is RETURN_IN_ORDER,
X   each non-option ARGV-element is returned here.  */
X
Xchar *optarg = 0;
X
X/* Index in ARGV of the next element to be scanned.
X   This is used for communication to and from the caller
X   and for communication between successive calls to `getopt'.
X
X   On entry to `getopt', zero means this is the first call; initialize.
X
X   When `getopt' returns EOF, this is the index of the first of the
X   non-option elements that the caller should itself scan.
X
X   Otherwise, `optind' communicates from one call to the next
X   how much of ARGV has been scanned so far.  */
X
Xint optind = 0;
X
X/* The next char to be scanned in the option-element
X   in which the last option character we returned was found.
X   This allows us to pick up the scan where we left off.
X
X   If this is zero, or a null string, it means resume the scan
X   by advancing to the next ARGV-element.  */
X
Xstatic char *nextchar;
X
X/* Callers store zero here to inhibit the error message
X   for unrecognized options.  */
X
Xint opterr = 1;
X
X/* Describe how to deal with options that follow non-option ARGV-elements.
X
X   UNSPECIFIED means the caller did not specify anything;
X   the default is then REQUIRE_ORDER if the environment variable
X   _OPTIONS_FIRST is defined, PERMUTE otherwise.
X
X   REQUIRE_ORDER means don't recognize them as options.
X   Stop option processing when the first non-option is seen.
X   This is what Unix does.
X
X   PERMUTE is the default.  We permute the contents of `argv' as we scan,
X   so that eventually all the options are at the end.  This allows options
X   to be given in any order, even with programs that were not written to
X   expect this.
X
X   RETURN_IN_ORDER is an option available to programs that were written
X   to expect options and other ARGV-elements in any order and that care about
X   the ordering of the two.  We describe each non-option ARGV-element
X   as if it were the argument of an option with character code zero.
X   Using `-' as the first character of the list of option characters
X   requests this mode of operation.
X
X   The special argument `--' forces an end of option-scanning regardless
X   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
X   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */
X
Xstatic enum { REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER } ordering;
X
Xchar *malloc ();
X
X/* Allocate memory dynamically, with error checking.  */
X
Xstatic char *
Xxmalloc (n)
X  unsigned n;
X{
X  char *p;
X
X  p = malloc (n);
X  if (!p)
X    {
X      fprintf (stderr, "Virtual memory exhausted\n");
X      exit (1);
X    }
X  return p;
X}
X
X/* Handle permutation of arguments.  */
X
X/* Describe the part of ARGV that contains non-options that have
X   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
X   `last_nonopt' is the index after the last of them.  */
X
Xstatic int first_nonopt;
Xstatic int last_nonopt;
X
X/* Exchange two adjacent subsequences of ARGV.
X   One subsequence is elements [first_nonopt,last_nonopt)
X    which contains all the non-options that have been skipped so far.
X   The other is elements [last_nonopt,optind), which contains all
X    the options processed since those non-options were skipped.
X
X   `first_nonopt' and `last_nonopt' are relocated so that they describe
X    the new indices of the non-options in ARGV after they are moved.  */
X
Xstatic void
Xexchange (argv)
X     char **argv;
X{
X  int nonopts_size
X    = (last_nonopt - first_nonopt) * sizeof (char *);
X  char **temp = (char **) xmalloc (nonopts_size);
X
X  /* Interchange the two blocks of data in argv.  */
X
X  bcopy (&argv[first_nonopt], temp, nonopts_size);
X  bcopy (&argv[last_nonopt], &argv[first_nonopt],
X     (optind - last_nonopt) * sizeof (char *));
X  bcopy (temp, &argv[first_nonopt + optind - last_nonopt],
X     nonopts_size);
X
X  free (temp);
X
X  /* Update records for the slots the non-options now occupy.  */
X
X  first_nonopt += (optind - last_nonopt);
X  last_nonopt = optind;
X}
X
X/* Scan elements of ARGV (whose length is ARGC) for option characters
X   given in OPTSTRING.
X
X   If an element of ARGV starts with '-', and is not exactly "-" or "--",
X   then it is an option element.  The characters of this element
X   (aside from the initial '-') are option characters.  If `getopt'
X   is called repeatedly, it returns successively each of the option characters
X   from each of the option elements.
X
X   If `getopt' finds another option character, it returns that character,
X   updating `optind' and `nextchar' so that the next call to `getopt' can
X   resume the scan with the following option character or ARGV-element.
X
X   If there are no more option characters, `getopt' returns `EOF'.
X   Then `optind' is the index in ARGV of the first ARGV-element
X   that is not an option.  (The ARGV-elements have been permuted
X   so that those that are not options now come last.)
X
X   OPTSTRING is a string containing the legitimate option characters.
X   A colon in OPTSTRING means that the previous character is an option
X   that wants an argument.  The argument is taken from the rest of the
X   current ARGV-element, or from the following ARGV-element,
X   and returned in `optarg'.
X
X   If an option character is seen that is not listed in OPTSTRING,
X   return '?' after printing an error message.  If you set `opterr' to
X   zero, the error message is suppressed but we still return '?'.
X
X   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
X   so the following text in the same ARGV-element, or the text of the following
X   ARGV-element, is returned in `optarg.  Two colons mean an option that
X   wants an optional arg; if there is text in the current ARGV-element,
X   it is returned in `optarg'.
X
X   If OPTSTRING starts with `-', it requests a different method of handling the
X   non-option ARGV-elements.  See the comments about RETURN_IN_ORDER, above.
X */
X
Xint
Xgetopt (argc, argv, optstring)
X     int argc;
X     char **argv;
X     char *optstring;
X{
X  /* Initialize the internal data when the first call is made.
X     Start processing options with ARGV-element 1 (since ARGV-element 0
X     is the program name); the sequence of previously skipped
X     non-option ARGV-elements is empty.  */
X
X  if (optind == 0)
X    {
X      first_nonopt = last_nonopt = optind = 1;
X
X      nextchar = 0;
X
X      /* Determine how to handle the ordering of options and nonoptions.  */
X
X      if (optstring[0] == '-')
X    ordering = RETURN_IN_ORDER;
X      else if (getenv ("_POSIX_OPTION_ORDER") != 0)
X    ordering = REQUIRE_ORDER;
X      else
X    ordering = PERMUTE;
X    }
X
X  if (nextchar == 0 || *nextchar == 0)
X    {
X      if (ordering == PERMUTE)
X    {
X      /* If we have just processed some options following some non-options,
X         exchange them so that the options come first.  */
X
X      if (first_nonopt != last_nonopt && last_nonopt != optind)
X        exchange (argv);
X      else if (last_nonopt != optind)
X        first_nonopt = optind;
X
X      /* Now skip any additional non-options
X         and extend the range of non-options previously skipped.  */
X
X      while (optind < argc
X         && (argv[optind][0] != '-'
X             || argv[optind][1] == 0))
X        optind++;
X      last_nonopt = optind;
X    }
X
X      /* Special ARGV-element `--' means premature end of options.
X     Skip it like a null option,
X     then exchange with previous non-options as if it were an option,
X     then skip everything else like a non-option.  */
X
X      if (optind != argc && !strcmp (argv[optind], "--"))
X    {
X      optind++;
X
X      if (first_nonopt != last_nonopt && last_nonopt != optind)
X        exchange (argv);
X      else if (first_nonopt == last_nonopt)
X        first_nonopt = optind;
X      last_nonopt = argc;
X
X      optind = argc;
X    }
X
X      /* If we have done all the ARGV-elements, stop the scan
X     and back over any non-options that we skipped and permuted.  */
X
X      if (optind == argc)
X    {
X      /* Set the next-arg-index to point at the non-options
X         that we previously skipped, so the caller will digest them.  */
X      if (first_nonopt != last_nonopt)
X        optind = first_nonopt;
X      return EOF;
X    }
X
X      /* If we have come to a non-option and did not permute it,
X     either stop the scan or describe it to the caller and pass it by.  */
X
X      if (argv[optind][0] != '-' || argv[optind][1] == 0)
X    {
X      if (ordering == REQUIRE_ORDER)
X        return EOF;
X      optarg = argv[optind++];
X      return 0;
X    }
X
X      /* We have found another option-ARGV-element.
X     Start decoding its characters.  */
X
X      nextchar = argv[optind] + 1;
X    }
X
X  /* Look at and handle the next option-character.  */
X
X  {
X    char c = *nextchar++;
X    char *temp = (char *) index (optstring, c);
X
X    /* Increment `optind' when we start to process its last character.  */
X    if (*nextchar == 0)
X      optind++;
X
X    if (temp == 0 || c == ':')
X      {
X    if (opterr != 0)
X      {
X        if (c < 040 || c >= 0177)
X          fprintf (stderr, "%s: unrecognized option, character code 0%o\n",
X               argv[0], c);
X        else
X          fprintf (stderr, "%s: unrecognized option `-%c'\n",
X               argv[0], c);
X      }
X    return '?';
X      }
X    if (temp[1] == ':')
X      {
X    if (temp[2] == ':')
X      {
X        /* This is an option that accepts an argument optionally.  */
X        if (*nextchar != 0)
X          {
X            optarg = nextchar;
X        optind++;
X          }
X        else
X          optarg = 0;
X        nextchar = 0;
X      }
X    else
X      {
X        /* This is an option that requires an argument.  */
X        if (*nextchar != 0)
X          {
X        optarg = nextchar;
X        /* If we end this ARGV-element by taking the rest as an arg,
X           we must advance to the next element now.  */
X        optind++;
X          }
X        else if (optind == argc)
X          {
X        if (opterr != 0)
X          fprintf (stderr, "%s: no argument for `-%c' option\n",
X               argv[0], c);
X        c = '?';
X          }
X        else
X          /* We already incremented `optind' once;
X         increment it again when taking next ARGV-elt as argument.  */
X          optarg = argv[optind++];
X        nextchar = 0;
X      }
X      }
X    return c;
X  }
X}
X
Xmemcpy(s,d,len)
Xchar *s,*d;
Xint len;
X{
X	while(len--) *d++ = *s++;
X}
END_OF_FILE
if test 16259 -ne `wc -c <'getopt.c'`; then
    echo shar: \"'getopt.c'\" unpacked with wrong size!
fi
# end of 'getopt.c'
fi
if test -f 'parse_keys.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'parse_keys.c'\"
else
echo shar: Extracting \"'parse_keys.c'\" \(15394 characters\)
sed "s/^X//" >'parse_keys.c' <<'END_OF_FILE'
X
X#include "file+rk.h"
X#include "functions.h"
X#include <stdio.h>
X#include <sys/ioctl.h>
X#include <ctype.h>
X
X#define MAXKEYLEN 19
X#define MAXTOKEN  30
X#define UPCASE(c) (islower(c)?toupper(c):c)
X
X#define UPCASE(c) (islower(c)?toupper(c):c)
X#define KEYWORDS (sizeof(functions)/sizeof(struct func))
X#define isodigit(c) ((isdigit(c))&&(c<'8'))
X
XFILE *filedesc;
Xchar *key_file;
X
Xextern int (*keymap[128][MAXEXTENSIONS])();
Xextern char meta_prefixes[MAXEXTENSIONS][MAXEXTENSIONS];
Xextern int  meta_map[MAXEXTENSIONS][MAXEXTENSIONS];
Xextern char next_free_map;
Xextern char tc_ent[1024], tc_seq_buf[1024];
Xextern struct sgttyb   new_stdin, old_stdin;
X
Xchar *tgetstr();
Xstruct func {
X	char *name;
X	int (*address)();
X	char *description;
X} functions[]=
X	{
X		{"BOGUS",
X		  BOGUS,
X		 "Null routine, beeps terminal bell"},
X
X		{"accept_forward_char",
X		  accept_forward_char,
X		 "Accept the next predicted character"},
X
X		{"accept_forward_word",
X		  accept_forward_word,
X		 "Accept the next predicted word"},
X
X		{"accept_to_end_of_line",
X		  accept_to_end_of_line,
X		 "Accept the whole predicted line"},
X
X		{"backspace_char",
X		  backspace_char,
X		 "Backspace a single character"},
X
X		{"backspace_word",
X		  backspace_word,
X		 "Backspace a single word"},
X
X		{"backward_char",
X		  backward_char,
X		 "Go backwards a single character"},
X
X		{"backward_paren",
X		  backward_paren,
X		 "Go backwards to matching parenthesis \"(\""},
X
X		{"backward_word",
X		  backward_word,
X		 "Go backwards a single word"},
X
X		{"beginning_of_line",
X		  beginning_of_line,
X		 "Move to the beginning of the line"},
X
X		{"bogus",
X		  BOGUS,
X		 "Null routine, beeps terminal bell"},
X
X		{"capitalize_word",
X		  capitalize_word,
X		 "Capitalize this word"},
X
X		{"clear_display",
X		  clear_display,
X		 "Clear the screen and redraw the line"},
X
X		{"close_paren",
X		  close_paren,
X		 "Close and show matching parenthesis"},
X
X		{"command_completion",
X		  command_completion,
X		 "Expand a command using $PATH"},
X
X		{"dash_to_ul_word",
X		  dash_to_ul_word,
X		 "Convert -'s to _'s in this word"},
X
X		{"delete_char",
X		  delete_char,
X		 "Delete a single character"},
X
X		{"delete_region_to_killbuffer",
X		  delete_region_to_killbuffer,
X		 "Delete marked region to killbuffer"},
X
X		{"delete_word",
X		  delete_word,
X		 "Delete a single word"},
X
X		{"describe_arguments",
X		  describe_arguments,
X		 "Show the current command line arguments"},
X
X		{"describe_bindings",
X		  describe_bindings,
X		 "Show the current key bindings"},
X
X		{"discard_current_edit_line",
X		  discard_current_edit_line,
X		 "Delete this line and forget it"},
X
X		{"discard_rest_of_line",
X		  discard_rest_of_line,
X		 "Delete rest of line to killbuffer"},
X
X		{"end_of_line",
X		  end_of_line,
X		 "Move to the end of the line"},
X
X		{"file_completion",
X		  file_completion,
X		 "Expand pathname from the current prefix"},
X
X		{"finish_editing_line",
X		  finish_editing_line,
X		 "Enter this line"},
X
X		{"forward_char",
X		  forward_char,
X		 "Go forward a single character"},
X
X		{"forward_paren",
X		  forward_paren,
X		 "Move to matching close parenthesis \")\""},
X
X		{"forward_word",
X		  forward_word,
X		 "Go forward a single word"},
X
X		{"increment_universal_argument",
X		  increment_universal_argument,
X		 "Do the next command 4^(presses) times"},
X
X		{"insert_interrupt_char",
X		  insert_interrupt_char,
X		 "Send an interrupt character"},
X
X		{"insert_quit_char",
X		  insert_quit_char,
X		 "Send a quit character"},
X
X		{"insert_start_char",
X		  insert_start_char,
X		 "Send a start character"},
X
X		{"insert_stop_char",
X		  insert_stop_char,
X		 "Send a stop character"},
X
X		{"insert_suspend_char",
X		  insert_suspend_char,
X		 "Send a suspend character"},
X
X		{"lowercase_word",
X		  lowercase_word,
X		 "Lowercase this word"},
X
X		{"next_line",
X		  next_line,
X		 "Show the next line buffer"},
X
X		{"next_pred",
X		  next_pred,
X		 "Show next alternative prediction"},
X
X		{"null",
X		  BOGUS,
X		 "Null routine, beeps terminal bell"},
X
X		{"open_paren",
X		  open_paren,
X		 "Open and show matching parenthesis"},
X
X		{"previous_line",
X		  previous_line,
X		 "Show the previous line buffer"},
X
X		{"previous_pred",
X		  previous_pred,
X		 "Show the previous alternative prediction"},
X
X		{"prime_from_file",
X		  prime_from_file,
X		 "Prime the predictions from a file"},
X
X		{"quote_char",
X		  quote_char,
X		 "Literally insert the next character"},
X
X		{"run_mesg",
X		  run_mesg,
X		 "Run the mesg command"},
X
X		{"run_ruptime",
X		  run_ruptime,
X		 "Run the ruptime command"},
X
X		{"run_talk",
X		  run_talk,
X		 "Run the talk command"},
X
X		{"run_tty_program",
X		  run_tty_program,
X		 "Run a program with rk turned off"},
X
X		{"run_write",
X		  run_write,
X		 "Run the write command"},
X
X		{"self_insert",
X		  self_insert,
X		 "Literally insert the current character"},
X
X		{"set_mark",
X		  set_mark,
X		 "Set mark at the current cursor position"},
X
X		{"show_free_nodes",
X		  show_free_nodes,
X		 "Show memory usage info for debugging"},
X
X		{"show_mark",
X		  show_mark,
X		 "Show the position of the current mark"},
X
X		{"show_version",
X		  show_version,
X		 "Show the current version number and date"},
X
X		{"toggle_add_space_mode",
X		  toggle_add_space_mode,
X		 "Toggle add_space_mode (see manual)"},
X
X		{"toggle_eol_longer_mode",
X		  toggle_eol_longer_mode,
X		 "Toggle eol_longer_mode (see manual)"},
X
X		{"toggle_eol_only_mode",
X		  toggle_eol_only_mode,
X		 "Toggle eol_only_mode (see manual)"},
X
X		{"toggle_lisp_mode",
X		  toggle_lisp_mode,
X		 "Toggle lisp_mode (see manual)"},
X
X		{"toggle_nl_truncate_mode",
X		  toggle_nl_truncate_mode,
X		 "Toggle nl_truncate_mode (see manual)"},
X
X		{"toggle_pred_mode",
X		  toggle_pred_mode,
X		 "Turn prediction display off or on"},
X
X		{"toggle_show_eol_mode",
X		  toggle_show_eol_mode,
X		 "Toggle display of ^J at end of line"},
X
X		{"twiddle_chars",
X		  twiddle_chars,
X		 "Exchange previous two characters"},
X
X		{"ul_to_dash_word",
X		  ul_to_dash_word,
X		 "Convert _'s to -'s in this word"},
X
X		{"uppercase_word",
X		  uppercase_word,
X		 "Uppercase this word"},
X
X		{"yank_from_kill_buffer",
X		  yank_from_kill_buffer,
X		 "Insert text stored in killbuffer"}
X	};
X
X
Xstruct list {
X	char *key;
X	struct list *next;
X} *bindings[sizeof(functions)/sizeof(struct func)];
X
X
X
X/***********************************\
X* 				    *
X*  binary search from K&R "C" book  *
X* 				    *
X\***********************************/
X
Xbsearch(s)
Xchar *s;
X{
X	int low, high, mid, cond;
X	low=0;
X	high= KEYWORDS-1;
X	while( low<= high) {
X		mid = (low+high)/2;
X		if( (cond = strcmp(s,functions[mid].name)) < 0)
X			high=mid-1;
X		else if (cond>0)
X			low=mid+1;
X		else
X			return(mid);
X	}
X	return(-1);
X}
X
Xparse_command()
X{
X	int x=1;
X	int number;
X	char c;
X	char token[MAXTOKEN];
X
X
X	while(isspace(c=fgetc(filedesc)));
X	
X	token[0]=c;
X
X	while((isalpha(c=fgetc(filedesc)) || (c=='_'))&& (x<=MAXTOKEN))
X		token[x++]=c;
X
X	token[x]=0;
X	if (c==EOF) return(-1);
X
X	if ((!isspace(c)) && (c!=EOF)){
X		printf("Unexpected character '%c', Expecting whitespace or EOF.\n",c);
X		return(-1);
X	}
X	if(x>MAXTOKEN){
X		printf("Function name too long: '%s'\n",token);
X		return(-1);
X	}
X	number=bsearch(token);
X	if(number==-1)
X		printf("Function not found: %s\n",token);
X	return(number);
X}
X
X
Xchar get_cntl()
X{
X	int c=fgetc(filedesc);
X	
X	if(c==' ') return(200); /* Can't use 0 */
X	else if(c==EOF){
X		printf("Unexpected EOF\n");
X		return(200);
X	}else return(UPCASE(c)-'@');
X}
X
Xchar parse_cntl(key)
Xchar key;
X{
X	if(key==0) abortit("Invalid ^ in key binding.\n",-1);
X	if(key==' ') return(0);
X	else return(UPCASE(key)-'@');
X}
X
X
Xchar get_slash()
X{
X
X	int c=fgetc(filedesc);
X	int code=0;
X
X	if(isodigit(c)){
X		while(isodigit(c)){
X			if((256-(c-='0'))<code){
X				printf("Character Overflow\n");
X				return(code);
X			}
X			code=(code<<3)+c;
X			c=fgetc(filedesc);
X		}
X		ungetc(c,filedesc);
X		return((char)code);
X	}
X	else if(c=='E')
X		return(27);
X	else if(c=='n')
X		return('\n');
X	else if(c=='r')
X		return('\r');
X	else if(c=='t')
X		return('\t');
X	else if(c=='b')
X		return('\b');
X	else if(c=='f')
X		return('\f');
X	else return(c);
X}	
X
Xchar parse_slash(key)
Xchar **key;
X{
X
X	int c=(*key)[0];
X	int code=0;
X
X	(*key)++;
X	if(c==0) abortit("Invalid \\ in key binding.\n",-1);
X		
X	if(isodigit(c)){
X		while(isodigit(c)){
X			if((256-(c-='0'))<code){
X				printf("Character Overflow\n");
X				return(code);
X			}
X			code=(code<<3)+c;
X			c=(*key)[0];
X			(*key)++;
X		}
X		(*key)--;
X		return((char)code);
X	}
X	else if(c=='E')
X		return(27);
X	else if(c=='n')
X		return('\n');
X	else if(c=='r')
X		return('\r');
X	else if(c=='t')
X		return('\t');
X	else if(c=='b')
X		return('\b');
X	else if(c=='f')
X		return('\f');
X	else return(c);
X}	
X	
X
Xchar *parse_key(key)
Xchar *key;
X{
X	static char ret_key[20];
X	int  x=0;
X	int  retval;
X	char c;
X
X	while(((c=key[0])!='\0') && (x<=MAXKEYLEN)){
X		if(c=='\\'){
X			key++;
X			ret_key[x++]=parse_slash(&key);
X		}
X		else if(c=='^'){
X			ret_key[x++]=parse_cntl(key[1]);
X			key+=2;
X		}		
X		else{
X			ret_key[x++]=c;
X			key++;
X		}
X	}
X	ret_key[x]=0;
X
X	if(x>MAXKEYLEN){
X		printf("Key too long.\n");
X		return((char *)-1);
X	}
X	return(ret_key);
X}
X
Xchar *parse_termcap_key(key)
Xchar *key;
X{
X	char *term_key;
X	char term_cap[3];	
X	char *key_ptr;
X	
X
X	term_key = tc_seq_buf;
X	key_ptr=tgetstr(key,&term_key);
X	if(!key_ptr){
X		printf("Unavailable Terminal Capability: %s\n",term_cap);
X		return((char *) -1);
X	}else
X		return(key_ptr); 
X}
X
Xchar *get_key(buffer)
Xchar *buffer;
X{
X	static char key[20];
X	char *term_key;
X	char *key_ptr;
X	char term_cap[3];	
X	int  x=0;
X	int  c;
X	int  retval;
X	
X	while(isspace(c=fgetc(filedesc)));
X	if (c!='"'){
X		term_cap[0]=c;
X		term_cap[1]=fgetc(filedesc);
X		term_cap[2]=0;
X		term_key = tc_seq_buf;
X		key_ptr=tgetstr(term_cap,&term_key);
X		if(!key_ptr){
X			printf("Unavailable Terminal Capability: %s\n",term_cap);
X			return((char *) -1);
X		}
X		else{
X			strcpy(buffer,term_cap);
X			return(key_ptr);
X		}
X	}
X
X	while(((c=fgetc(filedesc))!='\"') && (c!=EOF) 
X			&& (x<=MAXKEYLEN)){
X		if(c=='\\') key[x++]=get_slash();
X		else if(c=='^') key[x++]=get_cntl();
X		else key[x++]=c;
X	}
X	key[x]=0;
X
X	if(x>MAXKEYLEN){
X		printf("Key too long.\n");
X		return((char *)-1);
X	}
X	strcpy(buffer,key);
X	return(key);
X}
X
X/***************************************************************************\
X* 									    *
X* Find the length of a string but count control chars as two so the length  *
X* of something like ^C is right						    *
X* 									    *
X\***************************************************************************/
XStrlen(str)
Xchar *str;
X{
X	register int len=0;
X	while(*str){
X		if((*str<32) || (*str==127))
X			len++;
X		len++;
X		str++;
X	}
X	return(len);
X}
X/*****************************************************************\
X* 								  *
X* Copy from b to a but replace control chars with ^-char like ^C  *
X* 								  *
X\*****************************************************************/
XStrcpy(a,b)
Xchar *a,*b;
X{
X	while(*b){
X		if((*b<32) || (*b==127)){
X			*a++='^';
X			*a++=(*b==127)?b++,'?':(*b++)+'@';
X		}				
X		*a++ = *b++;
X	}
X	*a=0;
X}
X
X
Xadd_to_bindings(key,function)
Xchar *key;
Xint (*function)();
X{
X	int x,found_it=0;
X	struct list *current,*previous;
X	char good_key[30];
X	Strcpy(good_key,key);
X
X	for(x=0;x<sizeof(functions)/sizeof(struct func);x++){
X		current=bindings[x];
X		while(bindings[x]&&!strcmp(bindings[x]->key,good_key)){
X			current=bindings[x]->next;
X			free(bindings[x]);
X			bindings[x]=current;
X		}
X		while(current!=0){
X			if(!strcmp(current->key,good_key)){
X				previous->next=current->next;
X				free(current);
X			}
X			previous=current;
X			current=current->next;
X		}
X
X	}
X	for(x=0;x<sizeof(functions)/sizeof(struct func);x++){
X		if(function==functions[x].address){
X			found_it=1;
X			break;
X		}
X	}
X	if(found_it){
X		if(bindings[x]==0){
X			bindings[x]=(struct list *)malloc(sizeof(struct list));
X			bindings[x]->key=malloc(Strlen(key)+1);
X			Strcpy(bindings[x]->key,key);
X			bindings[x]->next=0;
X		} else {
X			current=bindings[x];
X			while(current->next != 0)
X				current=current->next;
X			current->next=(struct list *)malloc(sizeof(struct list));
X			current->next->key=malloc(Strlen(key)+1);
X			Strcpy(current->next->key,key);
X			current->next->next=0;
X		}
X	}
X}			
X			
X
X
Xbind_to_key(key,function)
Xchar *key;
Xint (*function)();
X{
X	char *binary_key;	
X	
X	binary_key=parse_key(key);
X	if(binary_key!=(char *)-1){
X		add_to_bindings(key,function);
X		do_bind_to_key(binary_key,0,function);
X	}
X}
X
Xbind_termcap_key(key,function)
Xchar *key;
Xint (*function)();
X{
X	char *binary_key;	
X	
X	binary_key=parse_termcap_key(key);
X	if(binary_key!=(char *)-1){
X		add_to_bindings(key,function);
X		do_bind_to_key(binary_key,0,function);
X	}
X}
X
Xdo_bind_to_key(key,current_key_map,function)
Xchar *key;
Xchar  current_key_map;
Xint (*function)();
X{
X	int x;
X
X	
X	if((strlen(key)==1) || (strlen(key)==0)){
X		keymap[key[0]][current_key_map]=function;
X	} else {
X		for(x=0;(x<MAXEXTENSIONS)&&(meta_prefixes[x][current_key_map])&&
X			(key[0]!=meta_prefixes[x][current_key_map]);x++);
X		if(x==MAXEXTENSIONS){
X			abortit("Too many keymaps, aborting.\r\n",-1);
X		}else if(meta_prefixes[x][current_key_map]){
X			do_bind_to_key(key+1,meta_map[x][current_key_map],function);
X		}else {
X			meta_prefixes[x][current_key_map]=key[0];
X			meta_map[x][current_key_map]=next_free_map;
X			keymap[key[0]][current_key_map]=meta_prefix;
X			next_free_map++;
X			do_bind_to_key(key+1,next_free_map-1,function);
X			if(next_free_map==MAXEXTENSIONS)
X				abortit("Too many keymaps, aborting.\r\n",-1);
X		}
X	}
X}
X
X
Xget_key_bindings()
X{
X
X	char *termname, *tbuf, *getenv();
X	int  function_num;
X	char *key;
X	char key_string[30];
X	int x;
X
X	if ((filedesc=fopen(key_file,"r"))==0){
X		return;
X	}
X
X	do{
X		function_num=parse_command();
X		if(function_num==-1)
X			break;
X		key=get_key(key_string);
X		if(key==(char *)-1)
X			break;
X		add_to_bindings(key_string,functions[function_num].address);
X		do_bind_to_key(key,0,functions[function_num].address);
X	} while(1);
X	fclose(filedesc);
X}
X
Xint
Xdescribe_bindings(e)
X	ED_STRUCT      *e;
X{
X	void		(*sig)();
X	char	reply;
X	char	fname[100];	
X		
X	printf("\r\nSend to a file? (y/n)");
X	if((reply=getchar())=='Y' || reply == 'y'){
X		ioctl(0, TIOCGETP, &new_stdin);
X		ioctl(0, TIOCSETP, &old_stdin);
X		sig=signal(SIGCHLD,SIG_DFL); 
X		printf("\nFilename: ");
X		gets(fname);
X		show_bindings(fname);
X	}else{
X		ioctl(0, TIOCGETP, &new_stdin);
X		ioctl(0, TIOCSETP, &old_stdin);
X		sig=signal(SIGCHLD,SIG_DFL); 
X		fname[0]=0;	
X		show_bindings(0);
X	}	
X	signal(SIGCHLD,sig); 
X	ioctl(0, TIOCSETP, &new_stdin);
X	write(1, "Continue: ", 10);
X	draw_current_edit_line(e);
X}
X
X
Xshow_bindings(fname)
X	char *fname;
X{
X	int x;
X	struct list *current;
X	char *more;
X	FILE *pipe;
X
X	if(!fname)	
X		if((more=getenv("PAGER"))==0){
X			if((pipe=popen("more","w"))==0){
X				perror("more");
X				return;
X			}
X		} else {
X			if((pipe=popen(more,"w"))==0){
X				perror(more);
X				return;
X			}
X		}
X	else
X		if((pipe=fopen(fname,"w"))==0){
X			perror(fname);
X			return;
X		}
X	
X
X
X	fprintf(pipe,"\n         FUNCTION NAME       BOUND TO \tDESCRIPTION\n");
X	fprintf(pipe,"         -------- ----       ----- -- \t-----------\n");
X
X	for(x=0;x<(sizeof(functions)/sizeof(struct func));x++){
X		if((functions[x].address==BOGUS)
X			|| (functions[x].address==self_insert))
X			continue;
X		fprintf(pipe,"%28s",functions[x].name);
X		current=bindings[x];
X		if(current!=0){
X			fprintf(pipe,"%6s\t",current->key);
X			current=current->next;
X		} else {
X			fprintf(pipe,"      \t");
X		}
X		fprintf(pipe,"%s",functions[x].description);
X		while(current!=0){
X			fprintf(pipe,"\n%34s",current->key);
X			current=current->next;
X		}
X		fprintf(pipe,"\n");
X	}
X	pclose(pipe);
X}
X
X
END_OF_FILE
if test 15394 -ne `wc -c <'parse_keys.c'`; then
    echo shar: \"'parse_keys.c'\" unpacked with wrong size!
fi
# end of 'parse_keys.c'
fi
if test -f 'rk.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rk.1'\"
else
echo shar: Extracting \"'rk.1'\" \(17257 characters\)
sed "s/^X//" >'rk.1' <<'END_OF_FILE'
X.TH RK 1
X.SH NAME
Xrk \- The Reactive Keyboard
X.SH SYNOPSIS
X.B "rk [\- options]"
X.SH DESCRIPTION
X.I "The Reactive Keyboard"
Xis a general purpose command line editor with the addition of predictive text
Xgeneration.  It interfaces with a standard shell and allows simple editing
Xof input lines.  It will also predict new input lines based on previous
Xinput.  
X
X.SH PREDICTIVE TEXT GENERATION
X.I "The Reactive Keyboard"
X(\fIrk\fP) accelerates typewritten communication with a
Xcomputer system by predicting what the user is going to type next.  To
Xenable it to make predictions, a model of previously-entered
Xtext is created and maintained adaptively.  (The modeling technique was
Xdeveloped for use in text compression, and in fact forms the basis of
Xone of the most effective existing compression methods.) This generally
Xcontains a large number of recurring selection element sequences
X(n-grams), with associated occurrence frequencies.  The current
Xcontext, recent selections, is used to look up likely continuations.
X
XThe basic idea is to order context-conditioned candidate strings, which
Xare predicted by the model, according to popularity and display them
Xfor selection.  Each prediction starts with a different \s-2ASCII\s+2
Xcharacter, so that the entire character set can always be accessed.
XDisplayed options are actually concatenations of several predicted
Xcharacters.  With the standard keyboard interface the user can cycle
Xthrough these predictions and accept all or part of any one.  Accepted
Xpredictions appear to the computer system as though the user had typed
Xthem himself.
X
XObviously predictions are not always correct, but they are correct
Xoften enough to form the basis of a useful communication device.  Since
Xthey are created adaptively, based on what the user has already typed
Xin this session or in previous ones, the system conforms to whatever
Xkind of text is being entered.  Prediction accuracy improves continually
Xas user history accumulates.
X
XPresent implementations have proved most useful in enhancing the
Xcommand interface to the \s-2UNIX\s+2 operating system by predicting commands,
Xarguments, and filenames; and for the entry of free text.  Although
Xdesigned as a general purpose computer interface, the Reactive Keyboard
Xalso has great potential to enhance the ease and rate of communication
Xfor physically limited people.
X
X.SH TECHNICAL DESCRIPTION
X
X.I "The Reactive Keyboard"
Xopens a shell on a pseudo terminal (pty).  Any input typed by the
Xuser is sent to the standard input of the shell.  Any output from the
Xshell is simply sent to the screen.  The advantage of this setup is
Xthat programs do not need to do anything special to work with \fIrk\fP.
X
X.I "The Reactive Keyboard"
Xautomatically switches off when a program is competing for control of the
Xpty.  Programs like screen editors for example will cause \fIrk\fP to shut off.
XOther programs can be run with \fIrk\fP turned off with 
Xthe ``run-tty-program'' function.
X
X.SH OPTIONS
X.IP "\-b <buffers>"
XThe number of buffers used by \fIrk\fP to save previous commands used by
X.I "previous_line."
XDefault: 60.
X.PP
X.IP "\-e <eol length>"
XThe maximum length of predictions at the end of the line. Default: 40.
X.PP
X.IP "\-f <count>"
XThe maximum frequency count for any given context.  Default: 128.
X.PP
X.IP "\-i <inline length>"
XThe maximum length of predictions in the middle of the line. Default: 8.
X.PP
X.IP "\-k <keys file>"
XThe file to read key bindings from.  Default:\fI$HOME/.rk.keys.\FP
X.PP
X.IP "\-n <number of nodes>"
XThe amount of memory to allocate initially to speed up creation of nodes.
XAfter this memory is used up, more will be allocated, but this will be slower.
XDefault: 64*1024 nodes.
X.PP
X.IP "\-o <model order>"
XThis argument controls how deep a tree will be built by \fIrk\fP in order to make predictions.  As
X.I k
Xincreases, the accuracy of predictions increases, but the speed decreases.
XDefault: 8.
X.PP
X.IP "\-p <prime file>"
XThe file used to prime the
X.I "Reactive Keyboard."
XDefault:
X.I "$HOME/.rk.log_file."
X.PP
X.IP "\-s <startup amount>"
XThe maximum number of characters to be read from the prime file at startup.
XDefault: 16*1024.
X.PP
X.IP "\-z <zero freq>"
XThe zero frequency file name.  See Zero Frequency below. This argument defaults to 
X.I "$HOME/.rk.zero_freq"
Xif it is not present.
X.PP
X.IP "\-A"
XWhen you accept a predicted word,
X.I "rk"
Xusually accepts all characters up to a space.  If the \-A option is present,
Xthe space is also accepted.
X.PP
X.IP "\-E"
X.I "rk"
Xnormally never displays predictions in the middle of a line.  If the \-E
Xoption is present
X.I "rk"
Xwill display predictions no matter where the cursor is.
X.PP
X.IP "\-L"
XBy default, predictions made at the end of a line are longer than those made
Xin the middle of a line.  The \-L option disables this feature.
X.PP
X.IP "\-N"
XNormally, predictions stop at the end of a line.  The \-N option causes
X.I "rk"
Xto continue making predictions past the end of the line, allowing several
Xcommands to be predicted at once.
X.PP
X.IP "\-P"
XThe \-P option disables display of predictions.  If the \-P option is present,
Xthe predictions are still made, and 
X.I "rk"
Xstill reads all input, but the predictions are not displayed.
X.PP
X.IP "\-S"
XNormally, when
X.I "rk"
Xpredicts a line, it shows the whole line up to and including the return (^J) at the
Xend.  If the \-S option is present, the return at the end of the line is not
Xdisplayed.
X.IP "\-g"
XNormally,
X.I "rk"
Xopens a login shell.  This means the users .login will be run and it is
Xpossible to quit
X.I "rk"
Xby typing "logout".  The \-g
Xoption causes
X.I "rk"
Xto open a normal shell  and not run the users .login.
X.PP
X.IP "\-h"
XThe \-h option causes a short description of the command line arguments to be
Xprinted.
X.PP
X.IP "\-l"
XThe \-l option turns on lisp mode, and allows ()'s to be matched.
X.PP
X.IP "\-m"
XIf the \-m option is present, the normal startup messages will be skipped.
X.PP
X.IP "\-v"
XThe \-v option prints the current version of the
X.I "Reactive Keyboard."
X.PP
X
X.SH "EXAMPLES"
X
X.I rk \-gmP
XSilently open a shell with the line editor enabled, but the predictions turned
Xoff.
X
X.I rk \-h
XJust print help for the command line arguments.
X
X.I rk \-o5
XRun the predictions, but make the order of the model only 5 instead of 8.
X
X.I rk \-z cfreq \-p cprimefile
XLoads the file cfreq into the zero frequency table and primes the prediction
Xmechanism with the file cprimefile.  Using these two arguments, it is
Xpossible to set up different environments for prediction.  In the above
Xexample, cfreq could have been created using a large C source file as input
Xand cprimefile could be another large C source file.  With these inputs, the
Xinput of C programs will be simplified as
X.I "rk"
Xwill predict common variable
Xnames and keywords.
X
X
X.SH "BINDABLE EDITING COMMANDS"
X
X.SS "Selection Control"
X.IP "accept_forward_char"
XAccept the next predicted character.
X.PP
X.IP "accept_forward_word"
XAccept the next predicted word.
X.PP
X.IP "accept_to_end_of_line"
XAccept the whole predicted line.
X.PP
X.IP "next_pred"
XShow next alternative prediction.
X.PP
X.IP "previous_pred"
XShow the previous alternative prediction.
X
X.SS "Display Control"
X.IP "clear_display"
XClear the screen and redraw the current edit line.
X.PP
X.IP "toggle_add_space_mode"
XWhen you accept a predicted word,
X.I "rk"
Xusually accepts all characters up to a space.  If add_space_mode is true,
Xthe space is also accepted.
X.PP
X.IP "toggle_eol_longer_mode"
XBy default, predictions made at the end of a line are longer than those made
Xin the middle of a line.  If eol_longer_mode is turned off this feature is
Xdisabled.
X.PP
X.IP "toggle_eol_only_mode"
X.I "rk"
Xnormally never displays predictions in the middle of a line.  If
Xeol_only_mode is true
X.I "rk"
Xwill display predictions no matter where the cursor is.
X.PP
X.IP "toggle_nl_truncate_mode"
XNormally, predictions stop at the end of a line.  If nl_truncate_mode is
Xfalse,
X.I "rk"
Xcontinues making predictions past the end of the line, allowing several
Xcommands to be predicted at once.
X.PP
X.IP "toggle_pred_mode"
XIF pred_mode is false, display of predictions is disabled.
XThe predictions are still made, and 
X.I "rk"
Xstill reads all input, but the predictions are not displayed.
X.PP
X.IP "toggle_show_eol_mode"
XNormally, when
X.I "rk"
Xpredicts a line, it shows the whole line up to and including the return (^J) at the
Xend.  If the show_eol_mode is false, the return at the end of the line is not
Xdisplayed.
X.SS "Model Control"
X
X.IP "prime_from_file"
XPrime the predictions from a file.
X.PP
X.IP "show_free_nodes"
XShow memory usage information for debugging.
X
X.SS "Error Control (editing)"
X.IP "backspace_char"
XBackspace a single character.
X.PP
X.IP "backspace_word"
XBackspace a single word.
X.PP
X.IP "backward_char"
XGo backwards a single character.
X.PP
X.IP "backward_paren"
XGo backwards to a matching parenthesis ``(''.
X.PP
X.IP "backward_word"
XGo backwards a single word.
X.PP
X.IP "beginning_of_line"
XMove to the beginning of the line.
X.PP
X.IP "capitalize_word"
XCapitalize this word.
X.PP
X.IP "close_paren"
XClose and show matching parenthesis.  This only has a visible effect if
Xlisp_mode is on.
X.PP
X.IP "dash_to_ul_word"
XConvert \-'s to _'s in this word.
X.PP
X.IP "delete_char"
XDelete a single character.
X.PP
X.IP "delete_region_to_killbuffer"
XDelete marked region to killbuffer.
X.PP
X.IP "delete_word"
XDelete a single word.
X.PP
X.IP "discard_current_edit_line"
XDelete this line and forget it.
X.PP
X.IP "discard_rest_of_line"
XDelete rest of line to killbuffer.
X.PP
X.IP "end_of_line"
XMove to the end of the line.
X.PP
X.IP "file_completion"
XExpand pathname from the current prefix.
X.PP
X.IP "finish_editing_line"
XEnter this line.
X.PP
X.IP "forward_char"
XGo forward a single character.
X.PP
X.IP "forward_paren"
XMove to matching close parenthesis ``)''.
X.PP
X.IP "forward_word"
XGo forward a single word.
X.PP
X.IP "increment_universal_argument"
XDo the next command 4^(presses) times.  For example, assume
Xincrement_universal_argument is bound to ^U and forward_char is bound top ^F.
XIf the user types ^U^U^F the cursor will move forward 4^2 or 16 spaces.
X.PP
X.IP "insert_interrupt_char"
XSend an interrupt character. This usually kills the current process.
X.PP
X.IP "insert_quit_char"
XSend a quit character. This usually kills the current process and causes a
Xcore image to be dumped.
X.PP
X.IP "insert_start_char"
XSend a start character.  This usually continues output stopped by
Xinsert_stop_char.
X.PP
X.IP "insert_stop_char"
XSend a stop character.  This usually pauses output from a program.
X.PP
X.IP "insert_suspend_char"
XSend a suspend character.  This usually stops a process.
X.PP
X.IP "lowercase_word"
XLowercase this word.
X.PP
X.IP "next_line"
XShow the next line buffer.
X.PP
X.IP "open_paren"
XOpen and show matching parenthesis.  This only has a visible effect if
Xlisp_mode is on.
X.PP
X.IP "previous_line"
XShow the previous line buffer.
X.PP
X.IP "quote_char"
XLiterally insert the next character.
X.PP
X.IP "self_insert"
XLiterally insert the current character.
X.PP
X.IP "set_mark"
XSet mark at the current cursor position.
X.PP
X.IP "show_mark"
XShow the position of the current mark.
X.PP
X.IP "toggle_lisp_mode"
XWhen lisp mode is turned on,
X.I rk
Xwill automatically match parenthesis.
X.PP
X.IP "twiddle_chars"
XExchange previous two characters.
X.PP
X.IP "ul_to_dash_word"
XConvert _'s to \-'s in this word.
X.PP
X.IP "uppercase_word"
XUppercase this word.
X.PP
X.IP "yank_from_kill_buffer"
XInsert text stored in killbuffer.
X.PP
X
X.SS "Panic Control"
X.IP "describe_arguments"
XShow the current command line arguments.
X.PP
X.IP "describe_bindings"
XShow the current key bindings.  This is usually bound to Esc-?.
X.PP
X.IP "show_version"
XShow the current version number and date.
X.PP
X.SS "Other"
X.IP "BOGUS, bogus or null"
XNull routine, beeps terminal bell.  If you want to unbind a key, bind
Xit to this command.
X.PP
X.IP "command_completion"
XExpand a command using $PATH.
X.PP
X.IP "run_mesg"
XRun the mesg command.
X.PP
X.IP "run_ruptime"
XRun the ruptime command.
X.PP
X.IP "run_talk"
XRun the talk command.
X.PP
X.IP "run_tty_program"
XRun a program with \fIrk\fP turned off.
X.PP
X.IP "run_write"
XRun the write command.
X.PP
X
X
X.SH CHANGING KEY BINDINGS
XOn startup, 
X.I rk
Xlooks for the file \fI$HOME/.rk.keys\fP or a file specified by the \-k option.
XIf it exists,
X.I rk
Xreads new key bindings from it.  Bindings consist of a function name
Xfollowed by a key to bind to in double quotes (").  Control characters
Xmay be imbedded in this string by the ^ character, so ^A is Control-A.
XThe \\ character works the same way as the \\ character in termcap entries:
X.TS
Xcenter,tab (@);
Xl.
X\\\\E is Escape
X\\\\n is newline
X\\\\r is carrige return
X\\\\t is tab
X\\\\\\\\ is a single \\\\
X\\\\^ is a single ^
X.TE
X
XIf you leave off the quotes, the corresponding entry is read from the termcap file.  See the manual entry for termcap for a list of these capabilities.
X
XFor example, a file like this:
X.TS
Xcenter,tab (@);
Xl.
Xaccept_forward_word    "^N"
Xdescribe_bindings      "^[?"
Xtoggle_lisp_mode       k1
X.TE
X
Xwould bind Control-N to accept_forward_word, Escape-? to describe_bindings
Xand Function key F1 to toggle_lisp_mode
X
X.SH DEFAULT BINDINGS
X
XThe default bindings are as follows (Note ^[p means Esc-p):
X.TS
Xcenter,tab (@);
Xl l.
Xaccept_forward_char@^Q
Xaccept_forward_word@^W
Xaccept_to_end_of_line@^S
Xbackspace_char@^H
Xbackspace_word@^G or ^[h
Xbackward_char@^B or kl
Xbackward_paren@^[(
Xbackward_word@^[b
Xbeginning_of_line@^A
Xcapitalize_word@^[c
Xclear_display@^L
Xclose_paren@)
Xcommand_completion@^\\
Xdash_to_ul_word@^[_
Xdelete_char@^D
Xdelete_region_to_killbuffer@^[k
Xdelete_word@^[d
Xdescribe_arguments@^[C
Xdescribe_bindings@^[?
Xdiscard_current_edit_line@^[^[
Xdiscard_rest_of_line@^K
Xend_of_line@^E
Xfile_completion@^C
Xfinish_editing_line@^J or ^M
Xforward_char@^F or kr
Xforward_paren@^[)
Xforward_word@^[f
Xincrement_universal_argument@^U
Xinsert_interrupt_char@^?
Xinsert_quit_char@^[Q
Xinsert_start_char@^_
Xinsert_stop_char@^^
Xinsert_suspend_char@^Z
Xlowercase_word@^[l
Xnext_line@^N or kd
Xnext_pred@^R
Xopen_paren@(
Xprevious_line@^P,^[= or ku
Xprevious_pred@^O
Xprime_from_file@^[g
Xquote_char@^V
Xrun_mesg@^[m
Xrun_ruptime@^[z
Xrun_talk@^[t
Xrun_tty_program@^[r
Xrun_write@^[w
Xset_mark@^space
Xshow_free_nodes@^[q
Xshow_mark@^X
Xshow_version@^[v
Xtoggle_add_space_mode@^[space
Xtoggle_eol_longer_mode@^[F
Xtoggle_eol_only_mode@^[E or ^[e
Xtoggle_lisp_mode@^[L
Xtoggle_nl_truncate_mode@^[N
Xtoggle_pred_mode@^[P or^[p
Xtoggle_show_eol_mode@^[S
Xtwiddle_chars@^T
Xul_to_dash_word@^[\-
Xuppercase_word@^[u
Xyank_from_kill_buffer@^Y
X.TE
X
X
X.SH ZERO FREQUENCY FILE
X
XWhen the current input has never been encountered before, 
X.I "rk"
Xis forced to
Xconsult it's zero frequency data.  If it exists, the file
X\fI$HOME/.rk.zero_freq\fP is read at startup.  If not, 
X.I "rk"
Xuses a default zero
Xfrequency table.  The program "freq" will create zero frequency files for
Xyou.  Simply run "freq < input_data > output_file" and the frequency's of
Xcharacters in the file input_data will be used to generate the file
Xoutput_file.
X
X
X.SH ADDING A NEW EDITING FUNCTION
X
XIf you want to add a new function to
X.I The Reactive Keyboard
Xyou need to add the function name, address and description in the
Xparse_keys.c file and the function declaration in functions.h
X
X
X.SH "FILES"
X
X.IP "freq"
XA program to generate zero frequency files.
X.IP ".rk.logfile"
XThe default file to use to prime the prediction mechanism and store all of
Xthe users input.
X.PP
X.IP ".rk.keys"
XThe default key bindings file. See Key Bindings above.
X.PP
X.IP ".rk.zero_freq"
XThe default zero frequency file. See Zero Frequency above.
X.PP
X
X.SH "AUTHORS (WHO TO BLAME)"
X
X  Mark James   (Key Bindings, Command Line arguments, General Maintainence)
X  John Darragh (Reactive Keyboard)
X  Dan Freedman (Input Line Editor)
X  Doug Taylor  (File Completion)
X
X
X.SH "SEE ALSO"
X
Xcsh(1),termcap(5)
X
XDarragh, J.J. (1988) ``Adaptive Predictive Text Generation And The Reactive
XKeyboard'' Research Report 88/343/05, Computer Science Department,
XUniversity of Calgary
X
X.SH "KNOWN BUGS"
X
XOn some terminals, 
X.I rk
Xhas problems with displaying predictions at the right edge of the screen.  If
Xthe terminal wraps some highlighted text may be left on the previous line.
X
X
XThe line editor doesn't do enough checking on the size of the input.  If the
Xuser types too much input before hitting return,
X.I rk
Xwill crash.
X
XFile completion reads a character to see if it should show a different
Xcompletion.  This is completely incompatible with the key bindings code.
XSince file completion only reads one character it is impossible to bind file
Xcompletion to a multi-character key like ESC-[-A.  At the moment, the key
Xbindings code does not make a special case for file completion so it is
Ximpossible to bind file completion to a different key without changing the
Xsource. This will hopefully be fixed in future versions.
X
XFile completion also makes some fairly liberal assumptions about the current
Xworking directory.  It is fairly simple to trick it into thinking it is in a
Xdifferent directory than it really is.
X
X.SH "WISH LIST"
X
XIt would be nice to be able to add teleportation or time travel, but I
Xunfortunately do not have time to implement these features.
X
XIt should not be too difficult to allow bindings to be changed at run time.
X
X.SH "BUG REPORTS"
X
XSend any bug reports or fixes to jamesm@cpsc.ucalgary.ca.
X
END_OF_FILE
if test 17257 -ne `wc -c <'rk.1'`; then
    echo shar: \"'rk.1'\" unpacked with wrong size!
fi
# end of 'rk.1'
fi
echo shar: End of archive 2 \(of 4\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

