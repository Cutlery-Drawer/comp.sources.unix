Subject:  v20i063:  LQ-1500 drivers for nroff, Part03/06
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: "John Rupley" <rupley@arizona.edu>
Posting-number: Volume 20, Issue 63
Archive-name: epf/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 6)."
# Contents:  ./nobs.c ./specialeqn1 ./specialeqn2 ./specialerr
#   ./specialgrk ./specialtbl ./tabepson.c ./tabepson12.c ./table.c
#   ./table.h ./Matrix/Delta ./Matrix/Gamma ./Matrix/Lambda
#   ./Matrix/Makefile ./Matrix/NOTE ./Matrix/Omega ./Matrix/Phi
#   ./Matrix/Pi ./Matrix/Psi ./Matrix/README ./Matrix/Sigma
#   ./Matrix/Theta ./Matrix/mat.c
# Wrapped by local@rupley on Mon Jul 10 23:08:54 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f './nobs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./nobs.c'\"
else
echo shar: Extracting \"'./nobs.c'\" \(6097 characters\)
sed "s/^X//" >'./nobs.c' <<'END_OF_FILE'
X/* nobs.c - Simple backspace filter - 3.0 */
X
X/*
X * This program will take lines containing overstrike pragmas of the form
X * <char><bs><char> and convert them to individual lines of output with a
X * return but no line feed between them. It is designed for filtering nroff
X * output to line printers that cannot back space (or on which back spaces
X * are expensive). 
X *
X * Only the following control characters are expected: \b, \t, \n, \r, \f, ESC,
X * SO, and SI. \t is expanded. \b is processed (obviously). SO and SI delimit
X * an alternate character set. A single printer control character must follow
X * ESC; it is assumed that in the nroff output this character was a 7, 8, or
X * 9, for forward or reverse carriage motion, and that "col" processing has
X * made each ESC passed part of a line terminator sequence (\n-ESC-9 or
X * ESC-9-\r). Other ESC sequences are very likely to corrupt the output.
X * Other control characters may be passed, but with undefined results if
X * there is overstriking. 
X *
X * Output from "col -f" is processed properly.  Indeed, if there are reverse or
X * half-line forward carriage motions (ESC-[789]), then the raw nroff output
X * _must_ be filtered through "col" before "nobs". As noted, "Nobs" assumes
X * that escape sequences terminate a line, as in the output from "col". 
X *
X * "Nobs", like "col", passes strings in an alternate character set, delimited
X * by SO (\016) and SI (\017). Characters of the alternate set are translated
X * subsequently by a printer-specific filter into printer control strings and
X * serve, e.g., to generate Greek characters and math symbols. "Nobs"
X * understands that characters of the alternate set have unit width for char
X * < 'r' and zero width for char >= 'r' (there is a non-portable assumption
X * of ascii order). 
X *
X * Usage: cat file|pic|tbl|neqn|nroff -m? -TX|col -fx|nobs|X-filter >/dev/lp 
X */
X
X/*-
X * Author:
X *   Chad R. Larson			This program is placed in the
X *   DCF, Inc.				Public Domain.  You may do with
X *   14623 North 49th Place		it as you please.
X *   Scottsdale, AZ 85254
X *
X * Modified 3/3/89:
X *   Kevin O'Gorman			Changes also in the public domain.
X *   Vital Computer Systems
X *   5115 Beachcomber
X *   Oxnard, CA  93035
X *
X * Rewritten 6/27/89:
X *   J.A. Rupley			rupley!local@megaron.arizona.edu
X */
X
X#include <stdio.h>
X
X#define	LINESIZE	1024	/* maximum line length */
X#define MAXOVER		8	/* maximum number of overstrikes */
X#define TABSIZE		8	/* tab length */
X#define ALT		0200	/* set MSB for alternate character set */
X#define SO		'\016'	/* input flag for start of alternate char set */
X#define SI		'\017'	/* input flag for end of above */
X
X/* forward references */
void            exit();
char           *memset();
X
static char     output[MAXOVER][LINESIZE + 3];	/* output line buffers with
X						 * room for end of line
X						 * delimters */
X
int
main()
X{
X	int             out_dex;/* offset into output buffer */
X	int             max_dex;/* high water for above */
X	int             line;	/* output buffer array index */
X	int             line_count;	/* number of output lines */
X	int             strip;	/* trailing space strip index */
X	int             alt;	/* flag for alternate character set on input */
X	int             chr;	/* single character storage */
X	char            c;	/* temp storage */
X	char           *s;	/* pointer into an output buffer */
X
X	/*
X	 * file is processed by parts, delimited by \n, \r, \f or \033
X	 * strings; splitting at \033 and \r handles \b in lines with printer
X	 * control characters, specifically fwrd-half-line in output of 
X	 * the "col -f" filter. 
X	 */
X	do {
X		memset((char *) output, ' ', sizeof(output));
X		out_dex = -1;
X		max_dex = 0;
X		line = 0;
X		line_count = 0;
X
X		/* slide through input line, dropping bs chars */
X		while ((chr = getchar())
X		       && chr != EOF
X		       && chr != '\033'
X		       && chr != '\f'
X		       && chr != '\n'
X		       && chr != '\r') {
X			switch (chr) {
X			case '\b':
X				/* cannot backup thru half or full newline */
X				out_dex = (out_dex >= 0) ? --out_dex : -1;
X				break;
X			case '\t':
X				out_dex = ((out_dex + TABSIZE + 1) /
X					   TABSIZE) * TABSIZE - 1;
X				break;
X			case SO:
X				alt = ALT;
X				break;
X			case SI:
X				alt = 0;
X				break;
X			case ' ':
X				max_dex = (++out_dex > max_dex) ? out_dex : max_dex;
X				break;
X			default:
X				if ((max_dex = (++out_dex > max_dex) ? out_dex : max_dex) > LINESIZE) {
X					fprintf(stderr, "nobs: line segment overflows buffer\n");
X					exit(1);
X				}
X				for (line = 0; /* exit at break */ ; line++) {
X					if (line == MAXOVER) {
X						fprintf(stderr, "nobs: too many overstrikes\n");
X						exit(1);
X					}
X					if (output[line][out_dex] == ' ') {
X						/* flag alt char */
X						output[line][out_dex] = chr | alt;
X						if (line_count < line)
X							line_count = line;
X						/* for zero-width alt char */
X						if (alt && chr >= 'r')
X							out_dex = (out_dex >= 0) ? --out_dex : -1;
X						break;	/* exit loop */
X					}
X				}
X			}
X		}		/* end (\n, \E, etc)-delimited processing */
X
X		/* print the output buffers */
X		for (line = 0; line <= line_count; line++) {
X			strip = max_dex;
X			while (output[line][strip] == ' ' && strip >= 0)
X				--strip;	/* strip trailing spaces */
X			++strip;/* point past string end */
X			/*
X			 * append line terminator (\r for line to be
X			 * overwritten); only [789] for +-movt should follow
X			 * ESC, and col preprocessing is assumed to have made
X			 * each ESC part of a line terminator. 
X			 */
X			if (line < line_count) {
X				output[line][strip++] = '\r';
X			} else {
X				if (chr == '\033') {
X					output[line][strip++] = chr;
X					chr = getchar();
X				}
X				output[line][strip++] = (chr == EOF) ? '\r' : chr;
X			}
X			output[line][strip] = '\0';
X			for (s = output[line]; *s; s++) {
X				c = *s & ~ALT;	/* careful about sign
X						 * extension */
X				if (*s & ALT && c > ' ') {
X					putchar(SO);	/* output printable
X							 * alt char with SO-SI 
X							 * delimiters */
X					putchar(c);
X					putchar(SI);
X				} else {
X					putchar(c);
X				}
X			}
X		}
X
X	} while (chr != EOF);	/* end of file */
X	return (0);
X}				/* end of main */
END_OF_FILE
if test 6097 -ne `wc -c <'./nobs.c'`; then
    echo shar: \"'./nobs.c'\" unpacked with wrong size!
fi
# end of './nobs.c'
fi
if test -f './specialeqn1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./specialeqn1'\"
else
echo shar: Extracting \"'./specialeqn1'\" \(851 characters\)
sed "s/^X//" >'./specialeqn1' <<'END_OF_FILE'
X\" By Tom Tkacik	...decvax!mcnc!ncsu!uvacs!uvaee!tet
X.ne 50
X.nf
X.sp 10
X.in 1i
X.ft B
A Big Equation - \fIFrom the EQN User's Guide\fP
X.ft R
X.sp
X.EQ
G(z)~mark =~ e sup { ln ~ G(z) }
X~=~ exp left [
sum from k>=1 {S sub k z sup k} over k right ]
X~=~ prod from k>=1 e sup { S sub k z sup k /k}
X.EN
X.sp 2
X.EQ
lineup =~ left ( 1 + S sub 1 z +
X{ S sub 1 sup 2 z sup 2 } over 2! + "..." right )
left ( 1 + {S sub 2 z sup 2 } over 2
X+ { S sub 2 sup 2 z sup 4 } over { 2 sup 2 ~ 2! }
X+ "..." right ) "..."
X.EN
X.sp 
X.EQ
lineup =~ sum from m>=0 left {
sum from
pile { k sub 1 ,k sub 2 ",...," k sub m >=0
above
k sub 1 +2k sub 2 ",...," +mk sub m = m }
X{S sub 1 sup {k sub 1} } over {1 sup k sub 1 k sub 1 ! } ~
X{S sub 2 sup {k sub 2} } over {2 sup k sub 2 k sub 2 ! } ~
X"..."
X{S sub m sup {k sub m} } over {m sup k sub m k sub m ! } ~
right } z sup m
X.EN
X.in -1i
END_OF_FILE
if test 851 -ne `wc -c <'./specialeqn1'`; then
    echo shar: \"'./specialeqn1'\" unpacked with wrong size!
fi
# end of './specialeqn1'
fi
if test -f './specialeqn2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./specialeqn2'\"
else
echo shar: Extracting \"'./specialeqn2'\" \(1518 characters\)
sed "s/^X//" >'./specialeqn2' <<'END_OF_FILE'
X.ne 50
X.nf
X.sp 3
X.ta 2.5i 5i
X\fBTests of Neqn\fP
X.sp 3
X.EQ
X"brackets:" ~~~ left [ a +  b right ]	"curlys:" ~~~ left { a +  b right }	"parens:" ~~~ left ( a +  b right )
X.EN
X.ta 4i
X.sp 3
X.EQ
X"floors:" ~~~ left floor x right floor ~~~ left floor x over y right floor	"ceilings:" ~~~ left ceiling x right ceiling ~~~ left ceiling x over y right ceiling
X.EN
X.ta 2i 4i 6i
X.sp 3
diacriticals:
X.sp
X.EQ
X"x dot:" ~ x dot 	"x dotdot:" ~ x dotdot 	"x hat:" ~ x hat 	"x tilde:" ~ x tilde 
X.EN
X.sp
X.EQ
X"x vec:" ~ x vec 	"x dyad:" ~ x dyad 	"x bar:" ~ x bar 	"x under:" ~ x under
X.EN
X.sp 3
diacriticals (with fudging for better (?) representations):
X.sp
X.EQ
X"x dot:" ~ x"\h'-1'\u.\d" 	"x dotdot:" ~ x"\h'-1'\"" 	"x hat:" ~ x hat 	"x tilde:" ~ x tilde 
X.EN
X.sp
X.EQ
X"x vec:" ~ x"\h'-1'\u\(->\d"	"x dyad:" ~ x"\h'-1'\u\(->\h'-1'\(<-\d"	"x bar:" ~ x bar	"x under:" ~ x under
X.EN
X.sp 3
X.ta .5i +.5i +.5i +.5i +.5i +.5i +.5i +.5i +.5i +.5i +.5i +.5i +.5i +.5i +.5i 
symbols:
X.sp
X.EQ
X>=	<=	==	!=	+-	->	<-	<<	>>	inf	partial	half	prime
X.EN
X.sp
X.EQ
approx	cdot	times	del	grad	...	,...,~~	sum	int	prod	union	inter
X.EN
X.sp 3
eqnchar symbols (from /usr/pub/eqnchar modified for Epson LQ 1500)
X.sp 2
X.PS <./epseqnchar
X.EQ
ciplus	citimes	=wig	bigstar	=dot	orsign	andsign	=del	oppA	oppE	incl	nomem
X.EN
X.sp
X.EQ
angstrom	star	||	<wig	>wig	langle	rangle	hbar	ppd	<->	<=>	|<	|>
X.EN
X.sp
X.EQ
ang	rang	3dot	thf	quarter	3quarter	degree	square	circle	blot	bullet	-wig	wig
X.EN
X.sp
X.EQ
prop	empty	member	scrL	==>	==<	cap	cup	subset	supset	!subset	!supset
X.EN
END_OF_FILE
if test 1518 -ne `wc -c <'./specialeqn2'`; then
    echo shar: \"'./specialeqn2'\" unpacked with wrong size!
fi
# end of './specialeqn2'
fi
if test -f './specialerr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./specialerr'\"
else
echo shar: Extracting \"'./specialerr'\" \(582 characters\)
sed "s/^X//" >'./specialerr' <<'END_OF_FILE'
X.ne 50
X.fi
X.na
X.in +1i
X.sp 10
X\fBSome Problems and Fixes\fP
X.sp2
X1. The three symbols (SO-<char>-SI) of a special character representation
are treated equally in overstriking by nroff, giving:
X.sp
SO<bksp>SO<bksp>SO<bksp>SO<char><bksp><char><bksp>.......
X.sp
col throws away the SO or SI, but processes the <bksp>'s.
X.sp
fix: filter the raw nroff output before sending it through col,
as done in the test targets of the makefile.
X.sp3
X\fB1234567890\fP
X.sp
X1234567890\fB\(*a\fP
X.sp
X1234567890\fB\(*a\(*b\fP
X.sp
X1234567890\fB\(*a\(*b\(*c\fP
X.sp 2
X1234567890\fI\(*a\(*b\(*c\fP
X.in -1i
END_OF_FILE
if test 582 -ne `wc -c <'./specialerr'`; then
    echo shar: \"'./specialerr'\" unpacked with wrong size!
fi
# end of './specialerr'
fi
if test -f './specialgrk' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./specialgrk'\"
else
echo shar: Extracting \"'./specialgrk'\" \(2108 characters\)
sed "s/^X//" >'./specialgrk' <<'END_OF_FILE'
X\" By Tom Tkacik	...decvax!mcnc!ncsu!uvacs!uvaee!tet
X.ne 50
X.sp 2
X\fBTest of the Special Character Set\fP
X.sp
X.nf
X.ta 2i 4i 6i
ALPHA \(*A	alpha \(*a	BETA \(*B 	beta \(*b
GAMMA \(*G	gamma \(*g	DELTA \(*D 	delta \(*d
XEPSILON \(*E 	epsilon \(*e	ZETA \(*Z 	zeta \(*z
XETA \(*Y 	eta \(*y	THETA \(*H 	theta \(*h
IOTA \(*I 	iota \(*i	KAPPA \(*K 	kappa \(*k
LAMBDA \(*L 	lambda \(*l	MU \(*M 	mu \(*m
NU \(*N 	nu \(*n	XI \(*C 	xi \(*c
OMICRON \(*O 	omicron \(*o	PI \(*P 	pi \(*p
RHO \(*R 	rho \(*r	SIGMA \(*S 	sigma \(*s
TAU \(*T 	tau \(*t	UPSILON \(*U 	upsilon \(*u
PHI \(*F 	phi \(*f	CHI \(*X 	chi \(*x
PSI \(*Q 	psi \(*q	OMEGA \(*W 	omega \(*w
X1/4  \(14	1/2  \(12	3/4  \(34	degree \(de
dagger \(dg	double dagger \(dd	footmark \(fm	cent sign \(ct
registered \(rg	copyright \(co	math +  \(pl	math -  \(mi
math =  \(eq	math *  \(**	section  \(sc	underrule \(ul
acute accent \(aa	grave accent \(ga	backslash \(sl	square root \(sr
root en extender \(rn	plus minus \(+-	>= \(>=	<= \(<=
identically = \(==	approx. = \(~=	approximates \(ap	not equal \(!=
right arrow \(->	left arrow \(<-	up arrow \(ua	down arrow \(da
multiply \(mu	divide \(di	union \(cu	intersection \(ca
subset of \(sb	superset of \(sp	improper subset \(ib	improper superset \(ip
infinity \(if	partial \(pd	gradient \(gr	not \(no
integral \(is	proportional to \(pt	empty set \(es	member of \(mo
box vertical rule \(br	Bell System Logo \(bs	right hand \(rh	left hand \(lh
or \(or	circle \(ci	bullet \(bu	square \(sq
left floor \(lf	right floor \(rf	left ceiling \(lc	right ceiling \(rc
left top curly \(lt	left bottom \(lb	left center \(lk
right top curly \(rt	right bottom \(rb	right center \(rk
bold vertical \(bv
X.sp 3
X.ft B
Greek Characters
X.ft P
X\(*a\(*b\(*g\(*d\(*e\(*z\(*y\(*h\(*i\(*k\(*l\(*m\(*n\(*c\(*o\(*p\(*r\(*s\(*t\(*u\(*f\(*x\(*q\(*w
X\(*A\(*B\(*G\(*D\(*E\(*Z\(*Y\(*H\(*I\(*K\(*L\(*M\(*N\(*C\(*O\(*P\(*R\(*S\(*T\(*U\(*F\(*X\(*Q\(*W
X.sp 3
X\fBSuperscript, Subscript Tests\fP
X.sp
X\fBBOLD\fP
X.sp
X\fBBO\d2\u\h'-1'\u2\dLD\fP
X.sp
X\fIitalic\fP
X.sp
X\fIital\d2\u\h'-1'\u2\dic\fP
X.sp
A\u2\d  A\d2\u  A\u2\d\h'-1'\d2\u  end of test
X.br
A\u2\d\h'-1'\d2\u
END_OF_FILE
if test 2108 -ne `wc -c <'./specialgrk'`; then
    echo shar: \"'./specialgrk'\" unpacked with wrong size!
fi
# end of './specialgrk'
fi
if test -f './specialtbl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./specialtbl'\"
else
echo shar: Extracting \"'./specialtbl'\" \(743 characters\)
sed "s/^X//" >'./specialtbl' <<'END_OF_FILE'
X.ne 50
X.sp 10
X.EQ
delim $$
X.EN
X.fi
X.na
X.in +1i
X.TS
center allbox;
cfi s
cw(2i) cw(2i)
l l.
X\fBTest of Table\fP
X.sp
X\fIA	B\fP
hi	there
T{
we find that there is danger in gifts bearing 
greeks: there may be \(bu's and \(dg's 
among the \(*a \(*b \(*g's.
X.br
Some greeks 
X.br
are bold:      \fB\(*P\fP
X.br
others perverted: $ pile { \(*b above bold \(*P above \(*a } $
X.sp
and others increase
X.sp 2
exponentially: \(*a\u\(*b\u\(*g\d\d.
T}	T{
now is the time for all good men to come to the aid of their country.
X.br
X\fInow\fP is the \fItime\fP for all good men to come to the aid of their country.
X.br
now is the \fBtime for all \ug\d\do\u\uo\d\dd\u men to \fPcome 
to the aid of their. country.
T}
and another	line
X.TE
X.in -1i
X.EQ
delim off
X.EN
END_OF_FILE
if test 743 -ne `wc -c <'./specialtbl'`; then
    echo shar: \"'./specialtbl'\" unpacked with wrong size!
fi
# end of './specialtbl'
fi
if test -f './tabepson.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./tabepson.c'\"
else
echo shar: Extracting \"'./tabepson.c'\" \(1130 characters\)
sed "s/^X//" >'./tabepson.c' <<'END_OF_FILE'
X/*
X * EPSON        -       FOR 10 CHAR/INCH, PICA
X * nroff driving tables
X * width and code tables
X */
X
X#define INCH	240
X
struct {
X	int bset;
X	int breset;
X	int Hor;
X	int Vert;
X	int Newline;
X	int Char;
X	int Em;
X	int Halfline;
X	int Adj;
X	char *twinit;
X	char *twrest;
X	char *twnl;
X	char *hlr;
X	char *hlf;
X	char *flr;
X	char *bdon;
X	char *bdoff;
X	char *iton;
X	char *itoff;
X	char *ploton;
X	char *plotoff;
X	char *up;
X	char *down;
X	char *right;
X	char *left;
X	char *codetab[256-32];
X	int zzz;
X	} t = {
X/*bset    */		00,
X/*breset  */		00,
X/*Hor     */		INCH/10,
X/*Vert    */		INCH/12,
X/*Newline */		INCH/6,
X/*Char    */		INCH/10,
X/*Em      */		INCH/10,
X/*Halfline*/		INCH/12,
X/*Adj     */		INCH/10,
X/*twinit  */		"\016{\017",	/* pica */
X/*twrest  */		"",
X/*twnl    */		"\r\n",
X/*hlr     */		"\0338",
X/*hlf     */		"\0339",
X/*flr     */		"\0337",
X/*bdon    */		"",		/* "\016v\017", */
X/*bdoff   */		"",		/* "\016w\017", */
X/*iton    */		"",		/* "\016|\017", */
X/*itoff   */		"",		/* "\016}\017", */
X/*ploton  */		"",
X/*plotoff */		"",
X/*up      */		"",
X/*down    */		"",
X/*right   */		"",
X/*left    */		"",
X/*codetab*/
X#include "code.epson"
END_OF_FILE
if test 1130 -ne `wc -c <'./tabepson.c'`; then
    echo shar: \"'./tabepson.c'\" unpacked with wrong size!
fi
# end of './tabepson.c'
fi
if test -f './tabepson12.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./tabepson12.c'\"
else
echo shar: Extracting \"'./tabepson12.c'\" \(1139 characters\)
sed "s/^X//" >'./tabepson12.c' <<'END_OF_FILE'
X/*
X * EPSON	-	FOR 12 CHAR/INCH, ELITE
X * nroff driving tables
X * width and code tables
X */
X
X#define INCH	240
X
struct {
X	int bset;
X	int breset;
X	int Hor;
X	int Vert;
X	int Newline;
X	int Char;
X	int Em;
X	int Halfline;
X	int Adj;
X	char *twinit;
X	char *twrest;
X	char *twnl;
X	char *hlr;
X	char *hlf;
X	char *flr;
X	char *bdon;
X	char *bdoff;
X	char *iton;
X	char *itoff;
X	char *ploton;
X	char *plotoff;
X	char *up;
X	char *down;
X	char *right;
X	char *left;
X	char *codetab[256-32];
X	int zzz;
X	} t = {
X/*bset    */		00,
X/*breset  */		00,
X/*Hor     */		INCH/10,
X/*Vert    */		INCH/12,
X/*Newline */		INCH/6,
X/*Char    */		INCH/12,
X/*Em      */		INCH/12,
X/*Halfline*/		INCH/12,
X/*Adj     */		INCH/12,
X/*twinit  */		"\016z\017",	/* elite */
X/*twrest  */		"\016{\017",	/* pica */
X/*twnl    */		"\r\n",
X/*hlr     */		"\0338",
X/*hlf     */		"\0339",
X/*flr     */		"\0337",
X/*bdon    */		"",		/* "\016v\017", */
X/*bdoff   */		"",		/* "\016w\017", */
X/*iton    */		"",		/* "\016|\017", */
X/*itoff   */		"",		/* "\016}\017", */
X/*ploton  */		"",
X/*plotoff */		"",
X/*up      */		"",
X/*down    */		"",
X/*right   */		"",
X/*left    */		"",
X/*codetab*/
X#include "code.epson"
END_OF_FILE
if test 1139 -ne `wc -c <'./tabepson12.c'`; then
    echo shar: \"'./tabepson12.c'\" unpacked with wrong size!
fi
# end of './tabepson12.c'
fi
if test -f './table.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./table.c'\"
else
echo shar: Extracting \"'./table.c'\" \(5011 characters\)
sed "s/^X//" >'./table.c' <<'END_OF_FILE'
X/*
X	table (version 2.0) - a utility for creating nroff driver tables.
X
X	table:  a program to compile nroff terminal driver tables.
X		Written by Bruce Townsend Oct, 1987.
X
X	Copyright (c) 1987 by Bruce Townsend and Bell-Northern Research.
X	Permission is granted to use and distribute, except for profit,
X	providing this copyright notice and the author's name is included.
X	No warranty of any kind is expressed or implied, and no liability of
X	any kind is assumed by either the author or Bell-Northern Research.
X
X	The contributions of Ian Darwin are gratefully acknowledged.
X*/
X
X#define C_SIZE	20000	/* The maximum amount of character data allowed
X			   in the initialized structure t - increase if
X			   necessary */
X
X#include <stdio.h>
X#include "table.h"	/* This file contains the definition of the
X			   the structures t and t_stor */
X
X/*	The compiled tab file contains three primary elements:
X	-  An integer (c_size) which gives the size in bytes of the character
X	   data (the third element of the file).
X	-  The structure t_stor, which contains integer data and integer
X	   indices into the character data that follows.
X	-  c_size bytes of character data.
X	Note that the file size in bytes is therefore:
X	c_size + sizeof (int) + sizeof (t_stor)
X*/
X
extern struct t t;	/* Defined in the tab file source */
struct t_stor t_stor;	/* This structure is stored in the compiled tab file */
X
char	c_data[C_SIZE];	/* The character data to be stored in the tab file */
int	c_size;		/* The amount of character data in bytes */
X
main (argc, argv)
int	argc;
char	*argv[];
X{
X	FILE	*table;
X	int	i;
X
X	if (argc != 2) {	/* Need a file name argument */
X	    fprintf (stderr, "Usage: table tabfilename\n");
X	    exit (1);
X	}
X
X	if ((table = fopen (argv[1], "w")) == NULL) {	/* Open the file */
X	    fprintf (stderr, "Could not open file %s for writing\n", argv[1]);
X	    exit (1);
X	}
X
X	/* Copy the integer values from the initialized structure t
X	   to the storage structure t_stor */
X	t_stor.bset = t.bset;
X	t_stor.breset = t.breset;
X	t_stor.Hor = t.Hor;
X	t_stor.Vert = t.Vert;
X	t_stor.Newline = t.Newline;
X	t_stor.Char = t.Char;
X#ifdef KANJI
X	t_stor.Kchar = t.Kchar;
X#endif KANJI
X	t_stor.Em = t.Em;
X	t_stor.Halfline = t.Halfline;
X	t_stor.Adj = t.Adj;
X
X	/* Find each string in the character data table c_data, or add it to
X	   the table if it is not there, and provide an index to it which
X	   is stored in t_stor */
X	t_stor.twinit = addstring (t.twinit);
X	t_stor.twrest = addstring (t.twrest);
X	t_stor.twnl = addstring (t.twnl);
X	t_stor.hlr = addstring (t.hlr);
X	t_stor.hlf = addstring (t.hlf);
X	t_stor.flr = addstring (t.flr);
X	t_stor.bdon = addstring (t.bdon);
X	t_stor.bdoff = addstring (t.bdoff);
X	t_stor.iton = addstring (t.iton);
X	t_stor.itoff = addstring (t.itoff);
X	t_stor.ploton = addstring (t.ploton);
X	t_stor.plotoff = addstring (t.plotoff);
X	t_stor.up = addstring (t.up);
X	t_stor.down = addstring (t.down);
X	t_stor.right = addstring (t.right);
X	t_stor.left = addstring (t.left);
X	for (i = 0; i < 256 - 32; i++)
X	    t_stor.codetab[i] = addchar (t.codetab[i]);
X	t_stor.zzz = 0;		/* The null terminator */
X
X	/* Write to the tab file the amount of character data in bytes,
X	   the structure t_stor, and the character data */
X	if (fwrite (&c_size, sizeof (c_size), 1, table) != 1 ||
X	    fwrite (&t_stor, sizeof (t_stor), 1, table) != 1 ||
X	    fwrite (c_data, sizeof (*c_data), c_size, table) != c_size) {
X	    fprintf (stderr, "Write to file failed\n");
X	    exit (1);
X	}
X
X	/* Close the tab file */
X	if (fclose (table)) {
X	    fprintf (stderr, "File %s not closed properly\n", argv[1]);
X	    exit (1);
X	}
X}
X
addstring (string)
char	*string;
X{
X	if (string)	/* If pointer is non-zero add string to table */
X	    return (string_search (string, strlen (string) + 1));
X
X	else		/* If pointer is zero return 0 index */
X	    return (0);
X}
X
addchar (string)
char	*string;
X{
X	if (string)	/* If pointer is non-zero add string to table */
X			/* Note that the string is at least 2 chars long
X			   and that the first 2 bytes may be null */
X	    return (string_search (string, strlen (string + 2) + 3));
X
X	else		/* If pointer is zero return 0 index */
X	    return (0);
X}
X
X/*	string_search searches through the character array c_data to
X	find the string.  If found, the routine returns an integer
X	index that locates the string in c_data.  If it is not
X	found, the string is added to c_data, and c_size, the amount
X	of data in c_data, is updated.
X*/
string_search (string, length)
char	*string;	/* The string to find in or add to the table */
int	length;		/* The string length including the null terminator */
X{
X	int	s_index, c_index, match;
X	char	*pointer;
X
X	for (s_index = 0; s_index <= c_size - length; s_index++) {
X	    pointer = string;
X	    match = 1;
X	    for (c_index = s_index; c_index < s_index + length;) {
X		if (*pointer++ != c_data[c_index++]) {
X		    match = 0;
X		    break;
X		}
X	    }
X	    if (match) return (s_index);
X	}
X
X	s_index = c_size;
X	while (length--)
X	    c_data[c_size++] = *string++;
X
X	return (s_index); 
X}
END_OF_FILE
if test 5011 -ne `wc -c <'./table.c'`; then
    echo shar: \"'./table.c'\" unpacked with wrong size!
fi
# end of './table.c'
fi
if test -f './table.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./table.h'\"
else
echo shar: Extracting \"'./table.h'\" \(876 characters\)
sed "s/^X//" >'./table.h' <<'END_OF_FILE'
X#ifndef	INCH
X#define	INCH	240
X#endif
X
struct t {
X	int bset;
X	int breset;
X	int Hor;
X	int Vert;
X	int Newline;
X	int Char;
X#ifdef KANJI
X	int Kchar;
X#endif KANJI
X	int Em;
X	int Halfline;
X	int Adj;
X	char *twinit;
X	char *twrest;
X	char *twnl;
X	char *hlr;
X	char *hlf;
X	char *flr;
X	char *bdon;
X	char *bdoff;
X	char *iton;
X	char *itoff;
X	char *ploton;
X	char *plotoff;
X	char *up;
X	char *down;
X	char *right;
X	char *left;
X	char *codetab[256-32];
X	char *zzz;
X	};
X
struct t_stor {		/* This structure will be stored in the tab file */
X	int bset;
X	int breset;
X	int Hor;
X	int Vert;
X	int Newline;
X	int Char;
X#ifdef KANJI
X	int Kchar;
X#endif KANJI
X	int Em;
X	int Halfline;
X	int Adj;
X	int twinit;
X	int twrest;
X	int twnl;
X	int hlr;
X	int hlf;
X	int flr;
X	int bdon;
X	int bdoff;
X	int iton;
X	int itoff;
X	int ploton;
X	int plotoff;
X	int up;
X	int down;
X	int right;
X	int left;
X	int codetab[256-32];
X	int zzz;
X};
END_OF_FILE
if test 876 -ne `wc -c <'./table.h'`; then
    echo shar: \"'./table.h'\" unpacked with wrong size!
fi
# end of './table.h'
fi
if test -f './Matrix/Delta' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./Matrix/Delta'\"
else
echo shar: Extracting \"'./Matrix/Delta'\" \(1509 characters\)
sed "s/^X//" >'./Matrix/Delta' <<'END_OF_FILE'
int	array	[24][28]	=	{
X				/* ^ */
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X/*sq*/	{ , , , , , , , , , , , , ,1, , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , ,1,1, , , , , , , , , , , , , },
X/*top*/	{ , , , , , , , , , , , ,1, ,1,1, , , , , , , , , , , , },
X	{ , , , , , , , , , , ,1, , , ,1,1, , , , , , , , , , , },
X	{ , , , , , , , , , , ,1, , , , ,1,1, , , , , , , , , , },
X	{ , , , , , , , , , ,1, , , , , , ,1,1, , , , , , , , , },
X	{ , , , , , , , , ,1, , , , , , , ,1,1, , , , , , , , , },
X	{ , , , , , , , ,1, , , , , , , , , ,1,1, , , , , , , , },
X	{ , , , , , , ,1, , , , , , , , , , , ,1,1, , , , , , , },
X	{ , , , , , , ,1, , , , , , , , , , , , ,1,1, , , , , , },
X	{ , , , , , ,1, , , , , , , , , , , , , ,1,1, , , , , , },
X	{ , , , , ,1, , , , , , , , , , , , , , , ,1,1, , , , , },
X	{ , , , , ,1, , , , , , , , , , , , , , , , ,1,1, , , , },
X	{ , , , ,1, , , , , , , , , , , , , , , , , , ,1,1, , , },
X/*bot*/	{ , , ,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	};			/* ^ */
END_OF_FILE
if test 1509 -ne `wc -c <'./Matrix/Delta'`; then
    echo shar: \"'./Matrix/Delta'\" unpacked with wrong size!
fi
# end of './Matrix/Delta'
fi
if test -f './Matrix/Gamma' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./Matrix/Gamma'\"
else
echo shar: Extracting \"'./Matrix/Gamma'\" \(1503 characters\)
sed "s/^X//" >'./Matrix/Gamma' <<'END_OF_FILE'
int	array	[24][28]	=	{
X				/* ^ */
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , ,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, , , },
X	{ , , , ,1,1,1, , , , , , , , , , , , , , , , ,1,1, , , },
X/*top*/	{ , , , ,1,1,1, , , , , , , , , , , , , , , , , ,1, , , },
X	{ , , , ,1,1,1, , , , , , , , , , , , , , , , , , , , , },
X	{ , , , ,1,1,1, , , , , , , , , , , , , , , , , , , , , },
X	{ , , , ,1,1,1, , , , , , , , , , , , , , , , , , , , , },
X	{ , , , ,1,1,1, , , , , , , , , , , , , , , , , , , , , },
X	{ , , , ,1,1,1, , , , , , , , , , , , , , , , , , , , , },
X	{ , , , ,1,1,1, , , , , , , , , , , , , , , , , , , , , },
X	{ , , , ,1,1,1, , , , , , , , , , , , , , , , , , , , , },
X	{ , , , ,1,1,1, , , , , , , , , , , , , , , , , , , , , },
X	{ , , , ,1,1,1, , , , , , , , , , , , , , , , , , , , , },
X	{ , , , ,1,1,1, , , , , , , , , , , , , , , , , , , , , },
X	{ , , , ,1,1,1, , , , , , , , , , , , , , , , , , , , , },
X/*bot*/	{ , ,1,1,1,1,1,1,1, , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	};			/* ^ */
END_OF_FILE
if test 1503 -ne `wc -c <'./Matrix/Gamma'`; then
    echo shar: \"'./Matrix/Gamma'\" unpacked with wrong size!
fi
# end of './Matrix/Gamma'
fi
if test -f './Matrix/Lambda' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./Matrix/Lambda'\"
else
echo shar: Extracting \"'./Matrix/Lambda'\" \(1509 characters\)
sed "s/^X//" >'./Matrix/Lambda' <<'END_OF_FILE'
int	array	[24][28]	=	{
X				/* ^ */
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X/*sq*/	{ , , , , , , , , , , , , ,1,1, , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , ,1,1,1, , , , , , , , , , , , },
X/*top*/	{ , , , , , , , , , , , ,1, ,1,1,1, , , , , , , , , , , },
X	{ , , , , , , , , , , ,1, , , ,1,1,1, , , , , , , , , , },
X	{ , , , , , , , , , , ,1, , , , ,1,1,1, , , , , , , , , },
X	{ , , , , , , , , , ,1, , , , , , ,1,1,1, , , , , , , , },
X	{ , , , , , , , , ,1, , , , , , , ,1,1,1, , , , , , , , },
X	{ , , , , , , , ,1, , , , , , , , , ,1,1,1, , , , , , , },
X	{ , , , , , , ,1, , , , , , , , , , , ,1,1,1, , , , , , },
X	{ , , , , , , ,1, , , , , , , , , , , , ,1,1,1, , , , , },
X	{ , , , , , ,1, , , , , , , , , , , , , ,1,1,1, , , , , },
X	{ , , , , ,1, , , , , , , , , , , , , , , ,1,1,1, , , , },
X	{ , , , , ,1, , , , , , , , , , , , , , , , ,1,1,1, , , },
X	{ , , , ,1, , , , , , , , , , , , , , , , , , ,1,1,1, , },
X/*bot*/	{ , ,1,1,1,1, , , , , , , , , , , , , , , , ,1,1,1,1,1, },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	};			/* ^ */
END_OF_FILE
if test 1509 -ne `wc -c <'./Matrix/Lambda'`; then
    echo shar: \"'./Matrix/Lambda'\" unpacked with wrong size!
fi
# end of './Matrix/Lambda'
fi
if test -f './Matrix/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./Matrix/Makefile'\"
else
echo shar: Extracting \"'./Matrix/Makefile'\" \(503 characters\)
sed "s/^X//" >'./Matrix/Makefile' <<'END_OF_FILE'
X# mkmake  $Revision: 1.8 $ $Date: 85/02/08 13:26:48 $
X.SUFFIXES:	.c .L .o .y .l
X.c.L:	;	lint $? > $@
DST=.
X
OBJECTS=mat.o matrix.o 
X
CFLAGS=
LDFLAGS=
X
CSOURCES=mat.c matrix.c 
X
LFILES=mat.L matrix.L 
X
out:	${OBJECTS}
X	@cc ${CFLAGS} ${OBJECTS} -o out ${LDFLAGS}
X	@out > to_be_put_in_epf.c
X
mat.o:	mat.c 
X	cc ${CFLAGS} -c mat.c
X
matrix.o:	matrix.c 
X	@cc ${CFLAGS} -c matrix.c
X
lint:	${LFILES}
X
install:
X	strip out
X	mv out ${DST}/out
X
ctags:
X	ctags -v ${CFILES} | sort -f > ctags
X
clean:
X	rm -f ${OBJECTS}
END_OF_FILE
if test 503 -ne `wc -c <'./Matrix/Makefile'`; then
    echo shar: \"'./Matrix/Makefile'\" unpacked with wrong size!
fi
# end of './Matrix/Makefile'
fi
if test -f './Matrix/NOTE' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./Matrix/NOTE'\"
else
echo shar: Extracting \"'./Matrix/NOTE'\" \(993 characters\)
sed "s/^X//" >'./Matrix/NOTE' <<'END_OF_FILE'
This directory contains source code from the posting by:
X
John Nellen, Delft Univ. of Technology 
X..!{decvax,philabs}!mcvax!dutesta!john 
Newsgroups: net.sources
Subject: Epson filter to type nroff Non-ASCII char's (no 1 of 4)
Date: 30 Oct 85 09:54:20 GMT
X
This code is not in the comp.sources archives.  It is on simtel20.arpa.
X
The data files are patterns for LQ-1500 graphics for the nroff special
characters that cannot be decently obtained by overstriking, etc., of the
printable ascii set.
X
Mat.c generates the printer control strings used by the "epf" filter,
for conversion of the representations of the special characters in the
nroff driver table (tabepson) to epson graphics (more precisely,
user-defined characters).  The generaged code forms the substance of
matrix.h.
X
A few special characters have been added:
X	bold_vert
X	left_bot
X	left_top
X	propor
X	right_bot
X	right_top
X
The shell script "mk.addin.sh" makes it a bit easier to convert the
pictures to printer control strings.
X
END_OF_FILE
if test 993 -ne `wc -c <'./Matrix/NOTE'`; then
    echo shar: \"'./Matrix/NOTE'\" unpacked with wrong size!
fi
# end of './Matrix/NOTE'
fi
if test -f './Matrix/Omega' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./Matrix/Omega'\"
else
echo shar: Extracting \"'./Matrix/Omega'\" \(1509 characters\)
sed "s/^X//" >'./Matrix/Omega' <<'END_OF_FILE'
int	array	[24][28]	=	{
X				/* ^ */
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X/*sq*/	{ , , , , , , , , , ,1,1,1,1,1,1,1, , , , , , , , , , , },
X	{ , , , , , , , ,1,1,1,1,1, ,1,1,1,1,1, , , , , , , , , },
X/*top*/	{ , , , , , ,1,1,1, , , , , , , , , ,1,1,1, , , , , , , },
X	{ , , , , ,1,1,1,1, , , , , , , , , ,1,1,1,1, , , , , , },
X	{ , , , ,1,1,1, , , , , , , , , , , , , ,1,1,1, , , , , },
X	{ , , , ,1,1,1, , , , , , , , , , , , , ,1,1,1, , , , , },
X	{ , , ,1,1,1, , , , , , , , , , , , , , , ,1,1,1, , , , },
X	{ , , ,1,1,1, , , , , , , , , , , , , , , ,1,1,1, , , , },
X	{ , , ,1,1,1, , , , , , , , , , , , , , , ,1,1,1, , , , },
X	{ , , , ,1,1,1, , , , , , , , , , , , , ,1,1,1, , , , , },
X	{ , , , , ,1,1,1, , , , , , , , , , , ,1,1,1, , , , , , },
X	{ , , , , , , ,1,1,1, , , , , , , ,1,1,1, , , , , , , , },
X	{ , , , , , , , ,1,1,1, , , , , ,1,1,1, , , , , , , , , },
X	{ , ,1,1, , , , , , ,1, , , , , ,1, , , , , , ,1,1, , , },
X/*bot*/	{ , , ,1,1,1,1,1,1,1,1, , , , , ,1,1,1,1,1,1,1,1, , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{;			/* ^ */
END_OF_FILE
if test 1509 -ne `wc -c <'./Matrix/Omega'`; then
    echo shar: \"'./Matrix/Omega'\" unpacked with wrong size!
fi
# end of './Matrix/Omega'
fi
if test -f './Matrix/Phi' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./Matrix/Phi'\"
else
echo shar: Extracting \"'./Matrix/Phi'\" \(1503 characters\)
sed "s/^X//" >'./Matrix/Phi' <<'END_OF_FILE'
int	array	[24][28]	=	{
X				/* ^ */
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , ,1,1,1,1,1,1,1,1, , , , , , , , , , },
X	{ , , , , , , , , , , , ,1,1,1, , , , , , , , , , , , , },
X	{ , , , , , , , , , , , ,1,1,1, , , , , , , , , , , , , },
X/*top*/	{ , , , , , , , , , ,1,1,1,1,1,1,1, , , , , , , , , , , },
X	{ , , , , , , ,1,1,1, , ,1,1,1, , ,1,1,1, , , , , , , , },
X	{ , , , , ,1,1,1, , , , ,1,1,1, , , , ,1,1,1, , , , , , },
X	{ , , , ,1,1,1, , , , , ,1,1,1, , , , , ,1,1,1, , , , , },
X	{ , , ,1,1,1, , , , , , ,1,1,1, , , , , , ,1,1,1, , , , },
X	{ , ,1,1,1,1, , , , , , ,1,1,1, , , , , , ,1,1,1,1, , , },
X	{ , ,1,1,1, , , , , , , ,1,1,1, , , , , , , ,1,1,1, , , },
X	{ , ,1,1,1,1, , , , , , ,1,1,1, , , , , , ,1,1,1,1, , , },
X	{ , , ,1,1,1, , , , , , ,1,1,1, , , , , , ,1,1,1, , , , },
X	{ , , , ,1,1,1, , , , , ,1,1,1, , , , , ,1,1,1, , , , , },
X	{ , , , , ,1,1,1, , , , ,1,1,1, , , , ,1,1,1, , , , , , },
X	{ , , , , , , ,1,1,1, , ,1,1,1, , ,1,1,1, , , , , , , , },
X/*bot*/	{ , , , , , , , , , ,1,1,1,1,1,1,1, , , , , , , , , , , },
X	{ , , , , , , , , , , , ,1,1,1, , , , , , , , , , , , , },
X	{ , , , , , , , , , , , ,1,1,1, , , , , , , , , , , , , },
X	{ , , , , , , , , , ,1,1,1,1,1,1,1, , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	};			/* ^ */
END_OF_FILE
if test 1503 -ne `wc -c <'./Matrix/Phi'`; then
    echo shar: \"'./Matrix/Phi'\" unpacked with wrong size!
fi
# end of './Matrix/Phi'
fi
if test -f './Matrix/Pi' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./Matrix/Pi'\"
else
echo shar: Extracting \"'./Matrix/Pi'\" \(1509 characters\)
sed "s/^X//" >'./Matrix/Pi' <<'END_OF_FILE'
int	array	[24][28]	=	{
X				/* ^ */
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X/*sq*/	{ , , ,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, , , },
X	{ , , , , ,1,1,1, , , , , , , , , , , , ,1,1,1, , , , , },
X/*top*/	{ , , , , ,1,1,1, , , , , , , , , , , , ,1,1,1, , , , , },
X	{ , , , , ,1,1,1, , , , , , , , , , , , ,1,1,1, , , , , },
X	{ , , , , ,1,1,1, , , , , , , , , , , , ,1,1,1, , , , , },
X	{ , , , , ,1,1,1, , , , , , , , , , , , ,1,1,1, , , , , },
X	{ , , , , ,1,1,1, , , , , , , , , , , , ,1,1,1, , , , , },
X	{ , , , , ,1,1,1, , , , , , , , , , , , ,1,1,1, , , , , },
X	{ , , , , ,1,1,1, , , , , , , , , , , , ,1,1,1, , , , , },
X	{ , , , , ,1,1,1, , , , , , , , , , , , ,1,1,1, , , , , },
X	{ , , , , ,1,1,1, , , , , , , , , , , , ,1,1,1, , , , , },
X	{ , , , , ,1,1,1, , , , , , , , , , , , ,1,1,1, , , , , },
X	{ , , , , ,1,1,1, , , , , , , , , , , , ,1,1,1, , , , , },
X	{ , , , , ,1,1,1, , , , , , , , , , , , ,1,1,1, , , , , },
X/*bot*/	{ , , ,1,1,1,1,1,1,1, , , , , , , , ,1,1,1,1,1,1,1, , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	};			/* ^ */
END_OF_FILE
if test 1509 -ne `wc -c <'./Matrix/Pi'`; then
    echo shar: \"'./Matrix/Pi'\" unpacked with wrong size!
fi
# end of './Matrix/Pi'
fi
if test -f './Matrix/Psi' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./Matrix/Psi'\"
else
echo shar: Extracting \"'./Matrix/Psi'\" \(1509 characters\)
sed "s/^X//" >'./Matrix/Psi' <<'END_OF_FILE'
int	array	[24][28]	=	{
X				/* ^ */
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X/*sq*/	{ , , , , , , , , , ,1,1,1,1,1,1,1, , , , , , , , , , , },
X	{ , , , , , , , , , , , ,1,1,1, , , , , , , , , , , , , },
X/*top*/	{ , , , , ,1,1, , , , , ,1,1,1, , , , , ,1,1, , , , , , },
X	{ , , , ,1,1,1,1, , , , ,1,1,1, , , , ,1,1,1,1, , , , , },
X	{ , , ,1,1, , ,1,1, , , ,1,1,1, , , ,1,1, , ,1,1, , , , },
X	{ , , ,1, , , ,1,1, , , ,1,1,1, , , ,1,1, , , ,1, , , , },
X	{ , , , , , , ,1,1, , , ,1,1,1, , , ,1,1, , , , , , , , },
X	{ , , , , , , ,1,1, , , ,1,1,1, , , ,1,1, , , , , , , , },
X	{ , , , , , , ,1,1, , , ,1,1,1, , , ,1,1, , , , , , , , },
X	{ , , , , , , ,1,1, , , ,1,1,1, , , ,1,1, , , , , , , , },
X	{ , , , , , , ,1,1, , , ,1,1,1, , , ,1,1, , , , , , , , },
X	{ , , , , , , ,1,1, , , ,1,1,1, , , ,1,1, , , , , , , , },
X	{ , , , , , , , ,1,1, , ,1,1,1, , ,1,1, , , , , , , , , },
X	{ , , , , , , , , ,1,1,1,1,1,1,1,1,1, , , , , , , , , , },
X/*bot*/	{ , , , , , , , , , , ,1,1,1,1,1, , , , , , , , , , , , },
X	{ , , , , , , , , , , , ,1,1,1, , , , , , , , , , , , , },
X	{ , , , , , , , , , ,1,1,1,1,1,1,1, , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	};			/* ^ */
END_OF_FILE
if test 1509 -ne `wc -c <'./Matrix/Psi'`; then
    echo shar: \"'./Matrix/Psi'\" unpacked with wrong size!
fi
# end of './Matrix/Psi'
fi
if test -f './Matrix/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./Matrix/README'\"
else
echo shar: Extracting \"'./Matrix/README'\" \(794 characters\)
sed "s/^X//" >'./Matrix/README' <<'END_OF_FILE'
This directory contains all the characters implemented in epf.c
X
To make a new character: edit matrix.c and copy it to a file which
you give the name of the character.
Mat.c is a file which scans matrix.c and produces a file called: out
X
X'out' will be excuted by the makefile and produces a file 'to_be_put_in_epf.c'
which is to be put in epf.c,(ha-ha) and there you have your user-defined char.
All the characters are known by nroff when you change the driving tables
called tabepson.c and code.epson (comes with this package)
X(To be installed in /usr/src/usr.bin/troff/term)
Characters are defined in those tables via <cntr>AA, <cntr>AB, <cntr>AC,....
X
then: nroff -Tepson - ... file 	will work for you.
X
X--
X			John Nellen, Delft Univ. of Technology
X			..!{decvax,philabs}!mcvax!dutesta!john
END_OF_FILE
if test 794 -ne `wc -c <'./Matrix/README'`; then
    echo shar: \"'./Matrix/README'\" unpacked with wrong size!
fi
# end of './Matrix/README'
fi
if test -f './Matrix/Sigma' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./Matrix/Sigma'\"
else
echo shar: Extracting \"'./Matrix/Sigma'\" \(1509 characters\)
sed "s/^X//" >'./Matrix/Sigma' <<'END_OF_FILE'
int	array	[24][28]	=	{
X				/* ^ */
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X/*sq*/	{ , , ,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, , , , , },
X	{ , , , ,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, , , , },
X/*top*/	{ , , , , ,1, , , , , , , , , , , , , , , , , , ,1, , , },
X	{ , , , , , ,1, , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , ,1, , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , ,1, , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , ,1, , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , ,1, , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , ,1, , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , ,1, , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , ,1, , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , ,1, , , , , , , , , , , , , , , , , ,1, , , },
X	{ , , , , ,1, , , , , , , , , , , , , , , , , ,1,1, , , },
X	{ , , , ,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, , , },
X/*bot*/	{ , , ,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	};			/* ^ */
END_OF_FILE
if test 1509 -ne `wc -c <'./Matrix/Sigma'`; then
    echo shar: \"'./Matrix/Sigma'\" unpacked with wrong size!
fi
# end of './Matrix/Sigma'
fi
if test -f './Matrix/Theta' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./Matrix/Theta'\"
else
echo shar: Extracting \"'./Matrix/Theta'\" \(1509 characters\)
sed "s/^X//" >'./Matrix/Theta' <<'END_OF_FILE'
int	array	[24][28]	=	{
X				/* ^ */
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X/*sq*/	{ , , , , , , , , , ,1,1,1,1,1,1,1, , , , , , , , , , , },
X	{ , , , , , , , ,1,1, , , , , , , ,1,1, , , , , , , , , },
X/*top*/	{ , , , , , , ,1,1, , , , , , , , , ,1,1, , , , , , , , },
X	{ , , , , , ,1,1, , , , , , , , , , , , ,1,1, , , , , , },
X	{ , , , , ,1,1, , , , , , , , , , , , , , ,1,1, , , , , },
X	{ , , , ,1,1, , , ,1, , , , , , , ,1, , , , ,1,1, , , , },
X	{ , , ,1,1, , , , ,1,1, , , , , ,1,1, , , , , ,1,1, , , },
X	{ , , ,1,1, , , , ,1,1,1,1,1,1,1,1,1, , , , , ,1,1, , , },
X	{ , , ,1,1, , , , ,1,1, , , , , ,1,1, , , , , ,1,1, , , },
X	{ , , ,1,1,1, , , ,1, , , , , , , ,1, , , , ,1,1,1, , , },
X	{ , , , ,1,1,1, , , , , , , , , , , , , , ,1,1,1, , , , },
X	{ , , , , ,1,1,1, , , , , , , , , , , , ,1,1, , , , , , },
X	{ , , , , , ,1,1,1, , , , , , , , , ,1,1,1, , , , , , , },
X	{ , , , , , , , ,1,1, , , , , , , ,1,1, , , , , , , , , },
X/*bot*/	{ , , , , , , , , , ,1,1,1,1,1,1,1, , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	{ , , , , , , , , , , , , , , , , , , , , , , , , , , , },
X	};			/* ^ */
END_OF_FILE
if test 1509 -ne `wc -c <'./Matrix/Theta'`; then
    echo shar: \"'./Matrix/Theta'\" unpacked with wrong size!
fi
# end of './Matrix/Theta'
fi
if test -f './Matrix/mat.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./Matrix/mat.c'\"
else
echo shar: Extracting \"'./Matrix/mat.c'\" \(824 characters\)
sed "s/^X//" >'./Matrix/mat.c' <<'END_OF_FILE'
X
main () {
X   int   digit,
X         x,
X         y,
X         n;
X   extern int  array[24][28]; 
X   printf ("    {\n    ");
X   printf (" 27,'p',  1, 27,'&',  0,'A','A',  4, 28,  5,\n    ");
X   for (x = 0; x < 28; x++) {
X      digit = 0;
X      n = 1;
X      for (y = 7; y >= 0; y-- ) {
X	 digit += (array[y][x] * n);
X	 n = n * 2;
X      }
X      printf ("%3d,", digit);
X      digit = 0;
X      n = 1;
X      for (y = 15; y > 7; y--) {
X	 digit += (array[y][x] * n);
X	 n = n * 2;
X      }
X      printf ("%3d,", digit);
X      digit = 0;
X      n = 1;
X      for (y = 23; y > 15; y--) {
X	 digit += (array[y][x] * n);
X	 n = n * 2;
X      }
X      printf ("%3d,", digit);
X      if (x == 4 | x == 9 | x == 14 | x == 19 | x == 24)
X	 printf ("\n    ");
X   }
X   printf("\n     27,'%%',  1,'A', 27,'%%',  0, 27,'p',  0");
X   printf ("\n    },\n");
X}
END_OF_FILE
if test 824 -ne `wc -c <'./Matrix/mat.c'`; then
    echo shar: \"'./Matrix/mat.c'\" unpacked with wrong size!
fi
# end of './Matrix/mat.c'
fi
echo shar: End of archive 3 \(of 6\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

