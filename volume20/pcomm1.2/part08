Subject:  v20i074:  Pcomm telecommunication package, Part08/08
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: fthood!egray
Posting-number: Volume 20, Issue 74
Archive-name: pcomm1.2/part08

#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create:
#	x_menu.c
#	x_rcv.c
#	x_send.c
#	x_win.c
#	xmodem.c
#	xmodem.h
export PATH; PATH=/bin:/usr/bin:$PATH
echo shar: "extracting 'x_menu.c'" '(7594 characters)'
if test -f 'x_menu.c'
then
	echo shar: "will not over-write existing file 'x_menu.c'"
else
sed 's/^X//' << \SHAR_EOF > 'x_menu.c'
X/*
X * Open a window to display the choices of file transfer protocols and
X * prompt for the file name(s).  A non-zero return code means turn the
X * input routine back on.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <curses.h>
X#include "config.h"
X#include "extrnl.h"
X#include "misc.h"
X#include "xmodem.h"
X
Xint
Xxfer_menu(up)
Xint up;
X{
X	extern int fd;
X	extern char *null_ptr;
X	WINDOW *xm_win, *newwin();
X	char buf[2048], *list, *get_names(), *get_extrnl(), *strcat();
X	char *strcpy();
X	int type, is_batch, i, ans, num_extrnl, n, ret_code;
X	void xfer_win(), xfer_ascii(), do_extrnl(), error_win();
X
X	num_extrnl = (up) ? extrnl->up_entries : extrnl->dn_entries;
X	xm_win = newwin(14+num_extrnl, 20, 2, 45);
X
X	mvwaddstr(xm_win, 2, 3, "1) xmodem");
X	mvwaddstr(xm_win, 3, 3, "2) xmodem-1k");
X	mvwaddstr(xm_win, 4, 3, "3) modem7");
X	mvwaddstr(xm_win, 5, 3, "4) ymodem");
X	mvwaddstr(xm_win, 6, 3, "5) ymodem-g");
X	mvwaddstr(xm_win, 7, 3, "6) ASCII");
X
X	for (i=0; i<num_extrnl; i++)
X		mvwprintw(xm_win, i+8, 3, "%d) %-12.12s", i+7, extrnl->name[up][i]);
X	mvwaddstr(xm_win, i+8, 3, "E) (external)");
X	mvwaddstr(xm_win, i+10, 3, "<ESC> to Abort");
X	mvwaddstr(xm_win, i+11, 3, "Protocol:");
X	box(xm_win, VERT, HORZ);
X	if (up)
X		mvwattrstr(xm_win, 0, 6, A_BOLD, " Upload ");
X	else
X		mvwattrstr(xm_win, 0, 5, A_BOLD, " Download ");
X
X	wmove(xm_win, i+11, 13);
X	wrefresh(xm_win);
X					/* get the protocol */
X	type = -1;
X	while ((ans = wgetch(xm_win)) != ESC) {
X		switch (ans) {
X			case '1':
X				type = XMODEM;
X				break;
X			case '2':
X				type = XMODEM_1k;
X				break;
X			case '3':
X				type = MODEM7;
X				break;
X			case '4':
X				type = YMODEM;
X				break;
X			case '5':
X				type = YMODEM_G;
X				break;
X			case '6':
X				type = XASCII;
X				break;
X			case '7':
X				if (num_extrnl >= 1)
X					type = EXT_1;
X				else
X					beep();
X				break;
X			case '8':
X				if (num_extrnl >= 2)
X					type = EXT_2;
X				else
X					beep();
X				break;
X			case '9':
X				if (num_extrnl >= 3)
X					type = EXT_3;
X				else
X					beep();
X				break;
X			case 'e':
X			case 'E':
X				type = EXT_MANUAL;
X				break;
X			default:
X				beep();
X		}
X		if (type != -1)
X			break;
X	}
X	werase(xm_win);
X	wrefresh(xm_win);
X	delwin(xm_win);
X					/* chicken'd out */
X	if (type == -1)
X		return(0);
X
X	if (fd == -1) {
X		error_win(0, "Not currently connected to any host", "");
X		return(0);
X	}
X					/* which protocol? */
X	ret_code = 0;
X	is_batch = 0;
X	switch(type) {
X		case MODEM7:
X		case YMODEM:
X		case YMODEM_G:		/* built-in protocols */
X			is_batch++;
X			/* fall thru */
X		case XMODEM:
X		case XMODEM_1k:		/* non-batch built-ins */
X			list = null_ptr;
X			/*
X			 * When receiving in a batch mode, don't prompt
X			 * for file names.
X			 */
X			if (up || !is_batch) {
X				if (!(list = get_names(up, type, is_batch)))
X					break;
X			}
X			xfer_win(list, up, type);
X			ret_code++;
X			break;
X		case XASCII:		/* ascii xfer, yuck! */
X			if (list = get_names(up, type, FALSE)) {
X				xfer_ascii(list, up);
X				if (!up)
X					ret_code++;
X			}
X			break;
X		case EXT_1:
X		case EXT_2:
X		case EXT_3:		/* one of the externals */
X			n = type -NUM_INTERNAL;
X			strcpy(buf, extrnl->command[up][n]);
X					/* see if we need to prompt for files */
X			if (extrnl->prompt[up][n] == 'Y') {
X				if (list = get_names(up, type, TRUE)) {
X					strcat(buf, " ");
X					strcat(buf, list);
X				}
X				else
X					break;
X			}
X			do_extrnl(buf);
X			ret_code++;
X			break;
X		case EXT_MANUAL:	/* the manual external protocol */
X			if (list = get_extrnl(up)) {
X				do_extrnl(list);
X				ret_code++;
X			}
X			break;
X	}
X	return(ret_code);
X}
X
Xchar *protocol[NUM_INTERNAL] = {"xmodem", "xmodem-1k", "modem7", "ymodem",
X	"ymodem-g", "ASCII"};
X
X/*
X * Prompt for a list of files for the transfer programs.  Since expand()
X * is used, it returns a pointer to a static area.  Returns a NULL if 
X * you chicken'd out.
X */
X
Xstatic char *
Xget_names(up, type, is_batch)
Xint up, type, is_batch;
X{
X	int got_it;
X	WINDOW *gn_win, *newwin();
X	char *ans, *file, *list, buf[40], *expand(), *get_str(), *strtok();
X	void st_line();
X	struct stat stbuf;
X
X	touchwin(stdscr);
X	refresh();
X	st_line("");
X
X	gn_win = newwin(7, 70, 5, 5);
X	mvwaddstr(gn_win, 3, 4, "Enter filename: ");
X	box(gn_win, VERT, HORZ);
X	if (up) {
X		if (type < NUM_INTERNAL)
X			sprintf(buf, " Send %s ", protocol[type]);
X		else
X			sprintf(buf, " Send %s ", extrnl->name[up][type-NUM_INTERNAL]);
X	}
X	else {
X		if (type < NUM_INTERNAL)
X			sprintf(buf, " Receive %s ", protocol[type]);
X		else
X			sprintf(buf, " Receive %s ", extrnl->name[up][type-NUM_INTERNAL]);
X	}
X	mvwattrstr(gn_win, 0, 3, A_BOLD, buf);
X
X	while (1) {
X		wmove(gn_win, 3, 20);
X		wrefresh(gn_win);
X					/* get the answers */
X		if (is_batch)
X			ans = get_str(gn_win, 60, "", "\n");
X		else
X			ans = get_str(gn_win, 60, "", " \t\n");
X
X		if (ans == NULL || *ans == '\0') {
X			list = NULL;
X			break;
X		}
X		list = expand(ans);
X					/* batches are checked on-the-fly */
X		if (is_batch)
X			break;
X		/*
X		 * Here we have the opportunity to determine the read and
X		 * write permissions before things get started.  Much nicer
X		 * than finding out later when there's no way to fix it.
X		 * Only checks the first file.
X		 */
X		file = strtok(list, " \t");
X					/* sanity checking */
X		if (!stat(file, &stbuf)) {
X			if ((stbuf.st_mode & S_IFREG) != S_IFREG) {
X				beep();
X				clear_line(gn_win, 4, 15, TRUE);
X				mvwattrstr(gn_win, 4, 15, A_BOLD, "Not a regular file");
X				wrefresh(gn_win);
X				wait_key(gn_win, 3);
X				clear_line(gn_win, 4, 15, TRUE);
X				clear_line(gn_win, 3, 20, TRUE);
X				continue;
X			}
X		}
X					/* check read permission */
X		if (up) {
X			if (access(file, 0)) {
X				beep();
X				mvwattrstr(gn_win, 4, 15, A_BOLD, "Can't find file");
X				wrefresh(gn_win);
X				wait_key(gn_win, 3);
X				clear_line(gn_win, 4, 15, TRUE);
X				clear_line(gn_win, 3, 20, TRUE);
X				continue;
X			}
X			if (access(file, 4)) {
X				beep();
X				mvwattrstr(gn_win, 4, 15, A_BOLD, "No read permission");
X				wrefresh(gn_win);
X				wait_key(gn_win, 3);
X				clear_line(gn_win, 4, 15, TRUE);
X				clear_line(gn_win, 3, 20, TRUE);
X				continue;
X			}
X			break;
X		}
X					/* check write permission */
X		got_it = 0;
X		switch(can_write(file)) {
X			case DENIED:
X				beep();
X				clear_line(gn_win, 4, 15, TRUE);
X				mvwattrstr(gn_win, 4, 15, A_BOLD, "No write permission");
X				wrefresh(gn_win);
X				wait_key(gn_win, 3);
X				clear_line(gn_win, 4, 15, TRUE);
X				clear_line(gn_win, 3, 20, TRUE);
X				break;
X			case OK_BUT_EXISTS:
X				if (!yes_prompt(gn_win, 4, 15, A_BOLD, "File exists, overwrite")) {
X					clear_line(gn_win, 4, 15, TRUE);
X					clear_line(gn_win, 3, 20, TRUE);
X					break;
X				}
X				/* fall thru */
X			case WRITE_OK:
X				got_it++;
X				break;
X		}
X		if (got_it)
X			break;
X	}
X	werase(gn_win);
X	wrefresh(gn_win);
X	delwin(gn_win);
X
X	return(list);
X}
X
X/*
X * Prompt for the Unix command line to be used as an external file
X * transfer program.  Since expand() is used, it returns a pointer to
X * a static area.
X */
X
Xstatic char *
Xget_extrnl(up)
Xint up;
X{
X	WINDOW *ge_win, *newwin();
X	char *ans, *cmd, *get_str(), *expand();
X	void st_line();
X
X	touchwin(stdscr);
X	refresh();
X	st_line("");
X					/* prompt for command line */
X	ge_win = newwin(7, 70, 5, 5);
X	mvwaddstr(ge_win, 3, 4, "Enter Unix command: ");
X	box(ge_win, VERT, HORZ);
X
X	if (up)
X		mvwattrstr(ge_win, 0, 3, A_BOLD, " Send (external) ");
X	else
X		mvwattrstr(ge_win, 0, 3, A_BOLD, " Receive (external) ");
X
X	wmove(ge_win, 3, 24);
X	wrefresh(ge_win);
X					/* get the line */
X	ans = get_str(ge_win, 60, "", "\n");
X	if (ans == NULL || *ans == '\0')
X		cmd = NULL;
X	else
X		cmd = expand(ans);
X
X	werase(ge_win);
X	wrefresh(ge_win);
X	delwin(ge_win);
X	return(cmd);
X}
SHAR_EOF
if test 7594 -ne "`wc -c < 'x_menu.c'`"
then
	echo shar: "error transmitting 'x_menu.c'" '(should have been 7594 characters)'
fi
fi
echo shar: "extracting 'x_rcv.c'" '(12008 characters)'
if test -f 'x_rcv.c'
then
	echo shar: "will not over-write existing file 'x_rcv.c'"
else
sed 's/^X//' << \SHAR_EOF > 'x_rcv.c'
X/*
X * Receive a list of files using a version of Ward Christensen's file
X * transfer protocol.  A non-zero return code means the user must acknowledge
X * an error condition (a user generated abort returns a 0).  Write errors
X * are considered fatal.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "dial_dir.h"
X#include "misc.h"
X#include "xmodem.h"
X
Xunsigned char buf[1029];
Xchar file_name[15];
Xlong file_length;
X
Xstatic int err_method, tot_err, block_size;
X
Xint
Xrcv_xmodem(win, list, type, fast)
XWINDOW *win;
Xchar *list;
Xint type, fast;
X{
X	extern char *protocol[];
X	FILE *fp, *my_fopen();
X	int i, default_err, is_batch, max_block, code, file_count, got_hdr;
X	int hours, mins, secs, len;
X	long block, recv;
X	float percent, performance;
X	unsigned char blk;
X	unsigned int sleep();
X	char *file, *name, *strcpy(), *strrchr(), *strtok();
X	void cancel_xfer();
X					/* which protocol? */
X	switch (type) {
X		case XMODEM:
X			default_err = CRC_CHECKSUM;
X			is_batch = 0;
X			max_block = 128;
X			break;
X		case XMODEM_1k:
X			default_err = CRC_CHECKSUM;
X			is_batch = 0;
X			max_block = 1024;
X			break;
X		case MODEM7:
X			default_err = CHECKSUM;
X			is_batch = 1;
X			max_block = 128;
X			break;
X		case YMODEM:
X			default_err = CRC;
X			is_batch = 1;
X			max_block = 1024;
X			performance = 1.09;
X			break;
X		case YMODEM_G:
X			default_err = NONE;
X			is_batch = 1;
X			max_block = 1024;
X			performance = 1.02;
X			break;
X		default:
X			return(1);
X	}
X
X	tot_err = 0;
X	file_count = 0;
X	mvwaddstr(win, 2, 24, protocol[type]);
X	mvwaddstr(win, 11, 24, "0  ");
X
X	while (1) {
X		file_count++;
X		file_length = 0L;
X					/* user supplied name */
X		if (!is_batch) {
X			if (file_count > 1)
X				break;
X
X			file = strtok(list, " \t");
X					/* dissect the file name */
X			if ((name = strrchr(file, '/')))
X				strcpy(file_name, ++name);
X			else
X				strcpy(file_name, file);
X		}
X					/* get the modem7 file name */
X		if (type == MODEM7) {
X			if (code = rcv_modem7(win, default_err))
X				return(code +1);
X
X			file = file_name;
X		}
X					/* get the block 0 */
X		if (type == YMODEM || type == YMODEM_G) {
X			if (code = send_first(win, max_block, default_err))
X				return(code +1);
X
X			if (code = rcv_ymodem(win))
X				return(code +1);
X
X					/* at the end? */
X			if (buf[3] == '\0') {
X				beep();
X				wrefresh(win);
X				putc_line(ACK);
X				sleep(1);
X				return(0);
X			}
X			file = file_name;
X		}
X					/* any trouble? */
X		if (file_name[0] == '\0')
X			continue;
X
X		clear_line(win, 3, 24, TRUE);
X		waddstr(win, file_name);
X					/* if file length is known */
X		if (file_length != 0L) {
X			mvwprintw(win, 4, 24, "%-10ld", file_length);
X
X			secs = (file_length * 10.0 / dir->baud[dir->d_cur]) * performance;
X			hours = secs / 3600;
X			mins = (secs % 3600) / 60;
X			secs = (secs % 3600) % 60;
X
X			mvwprintw(win, 6, 24, "%d:%02d:%02d", hours, mins, secs);
X		}
X					/* some starting numbers */
X		mvwaddstr(win, 7, 24, "0    ");
X		if (file_length != 0L && fast)
X			mvwaddstr(win, 8, 24, "0%  ");
X		if (fast)
X			mvwaddstr(win, 9, 24, "0          ");
X		mvwaddstr(win, 10, 24, "0 ");
X		clear_line(win, 12, 24, TRUE);
X		waddstr(win, "NONE");
X		wrefresh(win);
X
X		/*
X		 * If the user supplied the name, write permission is checked
X		 * by the get_names() routine in xfer_menu().  If modem7
X		 * or ymodem supplied name, the name is unique and the write
X		 * permission on the directory is checked by the change_name()
X		 * routines.  However, this is required for systems with
X		 * SETUID_BROKE set.
X		 */
X					/* open the file */
X		if (!(fp = my_fopen(file, "w"))) {
X			beep();
X			clear_line(win, 12, 24, TRUE);
X			wattrstr(win, A_BOLD, "CAN'T OPEN FILE");
X			wrefresh(win);
X			cancel_xfer(DOWN_LOAD);
X			return(1);
X		}
X					/* ACK the block 0 */
X		if (type == YMODEM || type == YMODEM_G)
X			putc_line(ACK);
X
X		if (code = send_first(win, max_block, default_err)) {
X			fclose(fp);
X			return(code +1);
X		}
X					/* here we go... */
X		clear_line(win, 12, 24, TRUE);
X		waddstr(win, "NONE");
X		wrefresh(win);
X		blk = 1;
X		block = 1L;
X		recv = 0L;
X		got_hdr = 1;
X		while (1) {
X			code = rcv_block(win, got_hdr, max_block, blk);
X
X			if (code < 0) {
X				fclose(fp);
X				return(code +1);
X			}
X			got_hdr = 0;
X					/* are we done? */
X			if (buf[0] == EOT) {
X				if (!is_batch) {
X					beep();
X					wrefresh(win);
X					sleep(1);
X				}
X				break;
X			}
X					/* if not a duplicate block */
X			if (!code) {
X				if (file_length != 0L) {
X					len = file_length - recv;
X					if (len > block_size)
X						len = block_size;
X				}
X				else
X					len = block_size;
X
X				if (fwrite((char *) &buf[3], sizeof(char), len, fp) != len) {
X					beep();
X					clear_line(win, 12, 24, TRUE);
X					wattrstr(win, A_BOLD, "WRITE ERROR");
X					wrefresh(win);
X					cancel_xfer(DOWN_LOAD);
X					fclose(fp);
X					/* fatal */
X					return(1);
X				}
X				mvwprintw(win, 7, 24, "%-5ld", block);
X				recv = recv + (unsigned int) len;
X				if (fast)
X					mvwprintw(win, 9, 24, "%-10ld", recv);
X				blk++;
X				block++;
X			}
X			/*
X			 * If the length is known, give the same status
X			 * report as uploading
X			 */
X			if (file_length != 0L && fast) {
X				percent = recv * 100.0 / file_length;
X				if (percent > 100.0)
X					percent = 100.0;
X				mvwprintw(win, 8, 24, "%0.1f%%", percent);
X			}
X			wrefresh(win);
X			putc_line(ACK);
X		}
X		if (file_length != 0L && fast) {
X			mvwaddstr(win, 8, 24, "100%  ");
X			wrefresh(win);
X		}
X		/*
X		 * If the file length is not known, search backwards from
X		 * the end of the file until you find a character that is
X		 * not the ^Z padding character.
X		 */
X		if (file_length == 0L) {
X			for (i=block_size+2; i>2; i--) {
X				if (buf[i] != CTRLZ)
X					break;
X			}
X			file_length = recv - (unsigned int) block_size + (unsigned int) i -2L;
X			fclose(fp);
X			if (fix_length(file, file_length)) {
X				beep();
X				clear_line(win, 12, 24, TRUE);
X				wattrstr(win, A_BOLD, "TRUNCATE ERROR");
X				wrefresh(win);
X					/* fatal */
X				return(1);
X			}
X		}
X		else
X			fclose(fp);
X					/* ACK the EOT */
X		putc_line(ACK);
X	}
X	return(0);
X}
X
X/*
X * Send the first character to start the transmission and set the error
X * checking method.  Returns the standard error codes or 0 on success.
X * The variables err_method and block_size are global.
X */
X
Xstatic int
Xsend_first(win, max_block, default_err)
XWINDOW *win;
Xint max_block, default_err;
X{
X	int i, err_count;
X	unsigned int sleep();
X	void cancel_xfer();
X					/* default error method */
X	err_method = default_err;
X	if (default_err == CRC_CHECKSUM)
X		err_method = CRC;
X					/* send the first char */
X	err_count = 0;
X	while (err_count < MAX_ERRORS*2) {
X		mvwprintw(win, 10, 24, "%-2d", err_count);
X
X					/* check for keyboard abort */
X		if (wgetch(win) == ESC) {
X			beep();
X			clear_line(win, 12, 24, TRUE);
X			waddstr(win, "ABORTED");
X			wrefresh(win);
X			cancel_xfer(DOWN_LOAD);
X			sleep(3);
X			return(ABORT);
X		}
X					/* switch to checksum? */
X		if (default_err == CRC_CHECKSUM && err_count > MAX_ERRORS/2)
X			err_method = CHECKSUM;
X
X					/* send error method code */
X		clear_line(win, 5, 24, TRUE);
X		switch (err_method) {
X			case CHECKSUM:
X				waddstr(win, "CHECKSUM");
X				putc_line(NAK);
X				break;
X			case CRC:
X				waddstr(win, "CRC");
X				putc_line('C');
X				break;
X			case NONE:
X				waddstr(win, "NONE");
X				putc_line('G');
X				break;
X		}
X		/*
X		 * We've cut the delay time in half, so we double
X		 * the allowable errors
X		 */
X		if ((i = getc_line(5)) == -1) {
X			err_count++;
X			clear_line(win, 12, 24, TRUE);
X			waddstr(win, "NO RESPONSE");
X			wrefresh(win);
X			continue;
X		}
X		buf[0] = i;
X#ifdef DEBUG
X		fprintf(stderr, "send_first: got header %02x, %03o, %d\n", buf[0], buf[0], buf[0]);
X#endif /* DEBUG */
X
X		switch (buf[0]) {
X			case SOH:	/* small block follows */
X				block_size = 128;
X				return(0);
X			case STX:	/* large block follows */
X				if (max_block == 1024) {
X					block_size = 1024;
X					return(0);
X				}
X				/* fall thru */
X			default:
X				err_count++;
X				clear_line(win, 12, 24, TRUE);
X				waddstr(win, "BAD HEADER");
X				wrefresh(win);
X					/* read some garbage... */
X				while(fread_line(buf, 1028, 1) != -1)
X					;
X				putc_line(NAK);
X				break;
X		}
X	}
X	beep();
X	clear_line(win, 12, 24, TRUE);
X	wattrstr(win, A_BOLD, "TIMED OUT");
X	wrefresh(win);
X	return(ERROR);
X}
X
X/*
X * Receive a block of info from the host.  Returns a 0 on success, a 1 on
X * a duplicate block or the standard error codes.  The variables
X * err_method and block_size are global.
X */
X
Xint
Xrcv_block(win, got_hdr, max_block, blk)
XWINDOW *win;
Xint got_hdr, max_block;
Xunsigned char blk;
X{
X	int i, err_count, bad_block, out_of_sync;
X	unsigned short crc, calc_crc();
X	unsigned int packet, sleep();
X	unsigned char blk_compliment, calc_sum(), crc_1, crc_2;
X	void cancel_xfer();
X
X	err_count = 0;
X	while (err_count < MAX_ERRORS) {
X		mvwprintw(win, 10, 24, "%-2d", err_count);
X		mvwprintw(win, 11, 24, "%-3d", tot_err);
X
X					/* scan the keyboard for abort */
X		if (wgetch(win) == ESC) {
X			beep();
X			clear_line(win, 12, 24, TRUE);
X			waddstr(win, "ABORTED");
X			wrefresh(win);
X			cancel_xfer(DOWN_LOAD);
X			sleep(3);
X			return(ABORT);
X		}
X					/* have we already got a hdr? */
X		if (!got_hdr) {
X			if ((i = getc_line(10)) == -1) {
X				err_count++;
X				tot_err++;
X				clear_line(win, 12, 24, TRUE);
X				waddstr(win, "NO RESPONSE");
X				wrefresh(win);
X				continue;
X			}
X			buf[0] = i;
X#ifdef DEBUG
X			fprintf(stderr, "rcv_block: got header %02x, %03o, %d\n", buf[0], buf[0], buf[0]);
X#endif /* DEBUG */
X					/* what'd we get? */
X			switch (buf[0]) {
X				case EOT:	/* we're done! */
X					clear_line(win, 12, 24, TRUE);
X					waddstr(win, "TRANSFER COMPLETE");
X					wrefresh(win);
X					sleep(1);
X					return(0);
X				case SOH:	/* small block follows */
X					block_size = 128;
X					break;
X				case STX:	/* large block follows */
X					if (max_block == 1024) {
X						block_size = 1024;
X						break;
X					}
X					/* fall thru... */
X				default:
X					err_count++;
X					tot_err++;
X					clear_line(win, 12, 24, TRUE);
X					waddstr(win, "BAD HEADER");
X					wrefresh(win);
X
X					/* read some garbage... */
X					while(fread_line(buf, 1028, 1) != -1)
X						;
X					putc_line(NAK);
X					continue;
X			}
X		}
X					/* read the rest of the packet */
X		packet = block_size + 2 + (err_method == CHECKSUM ? 1 : 2);
X		if (fread_line(&buf[1], packet, 10) == -1) {
X			clear_line(win, 12, 24, TRUE);
X			waddstr(win, "TIMED OUT");
X			wrefresh(win);
X			putc_line(NAK);
X			err_count++;
X			tot_err++;
X			continue;
X		}
X
X		/*
X		 * Validation of the packet includes checking the
X		 * block number, its complement, and the crc/checksum.
X		 */
X		out_of_sync = 0;
X		blk_compliment = ~blk;
X		if (buf[1] != blk || buf[2] != blk_compliment)
X			out_of_sync++;
X
X		bad_block = 0;
X		switch (err_method) {
X			case CHECKSUM:
X#ifdef DEBUG
X				fprintf(stderr, "blk=%d, checksum=%d\n", blk, calc_sum(&buf[3], block_size));
X#endif /* DEBUG */
X				if (buf[block_size +3] != calc_sum(&buf[3], block_size))
X					bad_block++;
X				break;
X			case CRC:
X				crc = calc_crc(&buf[3], block_size);
X				crc_1 = crc >> 8;
X				crc_2 = crc;
X#ifdef DEBUG
X				fprintf(stderr, "blk=%d, crc1=%d, crc2=%d\n", blk, crc_1, crc_2);
X#endif /* DEBUG */
X				if (buf[block_size +3] != crc_1 || buf[block_size +4] != crc_2)
X					bad_block++;
X				break;
X			case NONE:
X				return(0);
X		}
X					/* handle errors */
X		if (bad_block) {
X			clear_line(win, 12, 24, TRUE);
X			if (err_method == CRC)
X				waddstr(win, "CRC FAILED");
X			else
X				waddstr(win, "CHECKSUM FAILED");
X			wrefresh(win);
X			putc_line(NAK);
X			err_count++;
X			tot_err++;
X			continue;
X		}
X					/* not really an error */
X		if (out_of_sync) {
X			/*
X			 * If a perfect packet is off by 1 block number,
X			 * (a lost ACK could cause this) then treat it as
X			 * a good block but don't write it to disk.
X			 */
X			if (buf[1] == (unsigned char) blk-1)
X				return(1);
X
X			clear_line(win, 12, 24, TRUE);
X			waddstr(win, "OUT OF SYNC");
X			wrefresh(win);
X			putc_line(NAK);
X			err_count++;
X			tot_err++;
X			continue;
X		}
X		return(0);
X	}
X	beep();
X	clear_line(win, 12, 24, TRUE);
X	waddstr(win, "TOO MANY ERRORS");
X	wrefresh(win);
X	cancel_xfer(DOWN_LOAD);
X	return(ERROR);
X}
SHAR_EOF
if test 12008 -ne "`wc -c < 'x_rcv.c'`"
then
	echo shar: "error transmitting 'x_rcv.c'" '(should have been 12008 characters)'
fi
fi
echo shar: "extracting 'x_send.c'" '(11650 characters)'
if test -f 'x_send.c'
then
	echo shar: "will not over-write existing file 'x_send.c'"
else
sed 's/^X//' << \SHAR_EOF > 'x_send.c'
X/*
X * Send a list of files using a version of Ward Christensen's file
X * transfer protocol.  A non-zero return code means an error must be
X * acknowledged by the user (a user generated abort returns a 0).
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include "config.h"
X#include "dial_dir.h"
X#include "misc.h"
X#include "xmodem.h"
X
Xstatic int tot_err, err_method;
X
Xint
Xsend_xmodem(win, list, type, fast)
XWINDOW *win;
Xchar *list;
Xint type, fast;
X{
X	extern char *protocol[];
X	FILE *fp, *my_fopen();
X	int i, block_size, file_count, secs, mins, hours, big_blocks;
X	int small_blocks, err_count, got_it, num, is_batch, code;
X	int max_block, default_err;
X	long size, block, sent, xmit_size;
X	char *file, *strtok(), *name, *strrchr();
X	unsigned short crc, calc_crc();
X	unsigned char buf[1029], blk, calc_sum();
X	unsigned int packet, sleep();
X	float performance, percent;
X	struct stat stbuf;
X					/* which protocol? */
X	switch (type) {
X		case XMODEM:
X			is_batch = 0;
X			default_err = CRC_CHECKSUM;
X			max_block = 128;
X			performance = 1.36;
X			break;
X		case XMODEM_1k:
X			is_batch = 0;
X			default_err = CRC_CHECKSUM;
X			max_block = 1024;
X			performance = 1.09;
X			break;
X		case MODEM7:
X			is_batch = 1;
X			default_err = CHECKSUM;
X			max_block = 128;
X			performance = 1.36;
X			break;
X		case YMODEM:
X			is_batch = 1;
X			default_err = CRC;
X			max_block = 1024;
X			performance = 1.09;
X			break;
X		case YMODEM_G:
X			is_batch = 1;
X			default_err = NONE;
X			max_block = 1024;
X			performance = 1.02;
X			break;
X		default:
X			return(1);
X	}
X
X	tot_err = 0;
X	file_count = 0;
X	mvwaddstr(win, 2, 24, protocol[type]);
X	mvwaddstr(win, 11, 24, "0  ");
X
X					/* each one in the list */
X	file = strtok(list, " \t");
X	do {
X					/* is it a batch type? */
X		file_count++;
X		if (file_count > 1 && !is_batch)
X			break;
X					/* display the name */
X		clear_line(win, 3, 24, TRUE);
X		if ((name = strrchr(file, '/')))
X			name++;
X		else
X			name = file;
X		waddstr(win, name);
X		wrefresh(win);
X					/* get the file size */
X		if (stat(file, &stbuf) < 0) {
X			beep();
X			clear_line(win, 12, 24, TRUE);
X			wattrstr(win, A_BOLD, "CAN'T FIND FILE");
X			wrefresh(win);
X			sleep(3);
X			continue;
X		}
X					/* sanity checking */
X		if ((stbuf.st_mode & S_IFREG) != S_IFREG) {
X			beep();
X			clear_line(win, 12, 24, TRUE);
X			wattrstr(win, A_BOLD, "NOT REGULAR FILE");
X			wrefresh(win);
X			sleep(3);
X			continue;
X		}
X
X		size = stbuf.st_size;
X		mvwprintw(win, 4, 24, "%-10ld", size);
X		clear_line(win, 5, 24, TRUE);
X
X		if (!(fp = my_fopen(file, "r"))) {
X			beep();
X			clear_line(win, 12, 24, TRUE);
X			wattrstr(win, A_BOLD, "PERMISSION DENIED");
X			wrefresh(win);
X			sleep(3);
X			continue;
X		}
X					/* get the xmit size */
X		block_size = max_block;
X		big_blocks = 0;
X		small_blocks = 0;
X		if (block_size == 128) {
X			small_blocks = size / 128;
X			if (size % 128)
X				small_blocks++;
X		}
X		else {
X			big_blocks = size / 1024;
X			small_blocks = (size % 1024) / 128;
X			if (size % 128)
X				small_blocks++;
X
X			if (small_blocks == 8 && !big_blocks) {
X				big_blocks++;
X				small_blocks = 0;
X			}
X					/* if tiny file */
X			if (big_blocks == 0)
X				block_size = 128;
X		}
X
X		xmit_size = ((unsigned int) big_blocks * 1024L) + ((unsigned int) small_blocks * 128L);
X					/* add block 0 to the size */
X		if (type == YMODEM || type == YMODEM_G)
X			xmit_size += 128L;
X
X		secs = (xmit_size * 10.0 / dir->baud[dir->d_cur]) * performance;
X		hours = secs / 3600;
X		mins = (secs % 3600) / 60;
X		secs = (secs % 3600) % 60;
X
X		mvwprintw(win, 6, 24, "%d:%02d:%02d", hours, mins, secs);
X
X					/* some starting numbers */
X		mvwaddstr(win, 7, 24, "     ");
X		mvwaddstr(win, 8, 24, "0%  ");
X		mvwaddstr(win, 9, 24, "0          ");
X		mvwaddstr(win, 10, 24, "0 ");
X		clear_line(win, 12, 24, TRUE);
X		waddstr(win, "NONE");
X		wrefresh(win);
X					/* send the batch stuff */
X		switch (type) {
X			case MODEM7:
X				if (code = rcv_first(win, default_err)) {
X					fclose(fp);
X					return(code +1);
X				}
X
X				if (send_modem7(win, name)) {
X					fclose(fp);
X					return(1);
X				}
X				break;
X			case YMODEM:
X			case YMODEM_G:
X				if (code = rcv_first(win, default_err)) {
X					fclose(fp);
X					return(code +1);
X				}
X
X				if (code = send_ymodem(win, name, size)) {
X					fclose(fp);
X					/*
X					 * CANCEL now means that the other
X					 * end can't open that file.
X					 */
X					if (code == CANCEL)
X						break;
X					return(code +1);
X				}
X				xmit_size -= 128L;
X				break;
X			default:
X				code = 0;
X				break;
X		}
X					/* remote can't receive that file? */
X		if (code == CANCEL)
X			break;
X					/* wait for first character */
X		if (code = rcv_first(win, default_err)) {
X			fclose(fp);
X			return(code +1);
X		}
X					/* here we go... */
X		clear_line(win, 12, 24, TRUE);
X		waddstr(win, "NONE");
X		wrefresh(win);
X		sent = 0L;
X		block = 1L;
X		blk = 1;
X		while (num = fread((char *) &buf[3], sizeof(char), block_size, fp)) {
X
X					/* fill short block */
X			if (num < block_size) {
X				for (i=num; i<block_size; i++)
X					buf[i+3] = CTRLZ;
X			}
X
X					/* show current stats */
X			mvwprintw(win, 7, 24, "%-5ld", block);
X			if (fast) {
X				percent = sent * 100.0 / xmit_size;
X				mvwprintw(win, 8, 24, "%0.1f%%", percent);
X				mvwprintw(win, 9, 24, "%-10ld", sent);
X			}
X			wrefresh(win);
X
X					/* build the header */
X			if (block_size == 128)
X				buf[0] = SOH;
X			else
X				buf[0] = STX;
X
X			buf[1] = blk;
X			buf[2] = ~blk;
X
X					/* build the error detection stuff */
X			switch (err_method) {
X				case CHECKSUM:
X					buf[block_size+3] = calc_sum(&buf[3], block_size);
X#ifdef DEBUG
X					fprintf(stderr, "blk=%d, checksum=%d\n", blk, buf[block_size+3]);
X#endif /* DEBUG */
X					packet = block_size +4;
X					break;
X				case CRC:
X					crc = calc_crc(&buf[3], block_size);
X					buf[block_size+3] = crc >> 8;
X					buf[block_size+4] = crc;
X#ifdef DEBUG
X					fprintf(stderr, "blk=%d, crc1=%d, crc2=%d\n", blk, buf[block_size+3], buf[block_size+4]);
X#endif /* DEBUG */
X					packet = block_size +5;
X					break;
X				case NONE:
X					buf[block_size+3] = 0;
X					buf[block_size+4] = 0;
X					packet = block_size +5;
X					break;
X			}
X
X					/* send the block */
X			if (code = send_block(win, buf, packet)) {
X				fclose(fp);
X				return(code +1);
X			}
X			block++;
X			blk++;
X			sent = sent + (unsigned int) block_size;
X
X					/* change block size? */
X			if (xmit_size - sent < 1024)
X				block_size = 128;
X		}
X		mvwaddstr(win, 8, 24, "100%  ");
X		mvwprintw(win, 9, 24, "%-10ld", sent);
X					/* at the end of the file */
X		err_count = 0;
X		got_it = 0;
X		while (err_count < MAX_ERRORS) {
X			putc_line(EOT);
X			if (getc_line(10) == ACK) {
X				got_it++;
X				break;
X			}
X			err_count++;
X		}
X		clear_line(win, 12, 24, TRUE);
X		if (!got_it) {
X			/*
X			 * So what???  We don't do anything if there is
X			 * no acknowledge from the host!!
X			 */
X			waddstr(win, "NO ACKNOWLEDGE");
X		}
X		else
X			waddstr(win, "TRANSFER COMPLETE");
X		if (!is_batch)
X			beep();
X		wrefresh(win);
X		sleep(2);
X					/* prepare to start again */
X		fclose(fp);
X	} while (file = strtok((char *) NULL, " \t"));
X
X	/*
X	 * The end of batch markers... For modem7 it's an ACK and EOT, for
X	 * ymodem, it's an empty block 0.
X	 */
X	switch (type) {
X		case MODEM7:
X			if (code = rcv_first(win, default_err))
X				return(code +1);
X			putc_line(ACK);
X			putc_line(EOT);
X			beep();
X			wrefresh(win);
X			break;
X		case YMODEM:
X		case YMODEM_G:
X			if (code = rcv_first(win, default_err))
X				return(code +1);
X
X			if (code = send_ymodem(win, "", 0L))
X				return(code +1);
X			beep();
X			wrefresh(win);
X			break;
X		default:
X			break;
X	}
X	return(0);
X}
X
X/*
X * Wait for the first character to start the transmission.  This first
X * character also sets the crc/checksum method.  Returns the standard
X * error codes, or 0 on success.  The variable err_method is global.
X */
X
Xstatic int
Xrcv_first(win, default_err)
XWINDOW *win;
Xint default_err;
X{
X	int i, err_count;
X	unsigned int sleep();
X	void cancel_xfer();
X
X	err_count = 0;
X	while (err_count < MAX_ERRORS) {
X
X					/* scan the keyboard for abort */
X		if (wgetch(win) == ESC) {
X			beep();
X			clear_line(win, 12, 24, TRUE);
X			waddstr(win, "ABORTED");
X			wrefresh(win);
X			cancel_xfer(UP_LOAD);
X			sleep(3);
X			return(ABORT);
X		}
X					/* scan the TTY line */
X		i = getc_line(10);
X#ifdef DEBUG
X		fprintf(stderr, "rcv_first: got \"%c\", %02x, %03o, %d\n", i, i, i, i);
X#endif /* DEBUG */
X		switch (i) {
X			case -1:	/* timed out */
X				clear_line(win, 12, 24, TRUE);
X				wattrstr(win, A_BOLD, "NO RESPONSE");
X				err_count++;
X				break;
X			case NAK:	/* checksum marker */
X				if (default_err == CHECKSUM || default_err == CRC_CHECKSUM) {
X					mvwaddstr(win, 5, 24, "CHECKSUM");
X					err_method = CHECKSUM;
X					return(0);
X				}
X				err_count++;
X				break;
X			case 'C':	/* CRC marker */
X				if (default_err == CRC_CHECKSUM || default_err == CRC) {
X					mvwaddstr(win, 5, 24, "CRC");
X					err_method = CRC;
X					return(0);
X				}
X				err_count++;
X				break;
X			case 'G':	/* ymodem-g marker */
X				if (default_err == NONE) {
X					mvwaddstr(win, 5, 24, "NONE");
X					err_method = NONE;
X					return(0);
X				}
X				err_count++;
X				break;
X			case CAN:	/* two CAN's and you're out! */
X				if (getc_line(2) == CAN) {
X					beep();
X					clear_line(win, 12, 24, TRUE);
X					wattrstr(win, A_BOLD, "REMOTE ABORTED");
X					wrefresh(win);
X					return(CANCEL);
X				}
X				err_count++;
X				break;
X			default:
X				clear_line(win, 12, 24, TRUE);
X				waddstr(win, "BAD HEADER");
X				err_count++;
X				break;
X		}
X		mvwprintw(win, 10, 24, "%-2d", err_count);
X		wrefresh(win);
X	}
X					/* failed to get it right? */
X	beep();
X	clear_line(win, 12, 24, TRUE);
X	wattrstr(win, A_BOLD, "TIMED OUT");
X	wrefresh(win);
X	return(ERROR);
X}
X
X/*
X * Send a block of data, scan the keyboard for a user abort, and check
X * the return codes from the host.  Returns standard error codes or 0
X * on success.
X */
X
Xint
Xsend_block(win, blk, packet)
XWINDOW *win;
Xunsigned char *blk;
Xunsigned int packet;
X{
X	extern int fd;
X	int i, err_count;
X	void cancel_xfer();
X
X	err_count = 0;
X	mvwaddstr(win, 10, 24, "0 ");
X
X	while (err_count < MAX_ERRORS) {
X					/* write the block */
X		write(fd, (char *) blk, packet);
X					/* scan the keyboard */
X		if (wgetch(win) == ESC) {
X			beep();
X			clear_line(win, 12, 24, TRUE);
X			waddstr(win, "ABORTED");
X			wrefresh(win);
X			cancel_xfer(UP_LOAD);
X			sleep(3);
X			return(ABORT);
X		}
X					/* ymodem-g doesn't need ACKs */
X		if (err_method == NONE)
X			return(0);
X					/* wait for acknowledge */
X		i = getc_line(10);
X#ifdef DEBUG
X		fprintf(stderr, "send_block: got \"%c\", %02x, %03o, %d\n", i, i, i, i);
X#endif /* DEBUG */
X		switch (i) {
X			case -1:	/* timed out */
X				clear_line(win, 12, 24, TRUE);
X				waddstr(win, "NO RESPONSE");
X				err_count++;
X				tot_err++;
X				break;
X			case ACK:	/* Hooray!! we got it */
X				return(0);
X			case NAK:	/* show our disappointment... */
X				clear_line(win, 12, 24, TRUE);
X				if (err_method == CRC)
X					waddstr(win, "CRC FAILED");
X				else
X					waddstr(win, "CHECKSUM FAILED");
X				err_count++;
X				tot_err++;
X				break;
X			case CAN:	/* two CAN's and you're out! */
X				if (getc_line(2) == CAN) {
X					beep();
X					clear_line(win, 12, 24, TRUE);
X					wattrstr(win, A_BOLD, "REMOTE ABORTED");
X					wrefresh(win);
X					return(CANCEL);
X				}
X				/* fall thru... */
X			default:
X				clear_line(win, 12, 24, TRUE);
X				waddstr(win, "RESENDING");
X				err_count++;
X				tot_err++;
X				break;
X		}
X					/* flush any pending garbage */
X		tty_flush(fd, 0);
X
X		mvwprintw(win, 10, 24, "%-2d", err_count);
X		mvwprintw(win, 11, 24, "%-3d", tot_err);
X		wrefresh(win);
X	}
X					/* failed to get it right */
X	beep();
X	clear_line(win, 12, 24, TRUE);
X	wattrstr(win, A_BOLD, "TOO MANY ERRORS");
X	wrefresh(win);
X	cancel_xfer(UP_LOAD);
X	return(ERROR);
X}
SHAR_EOF
if test 11650 -ne "`wc -c < 'x_send.c'`"
then
	echo shar: "error transmitting 'x_send.c'" '(should have been 11650 characters)'
fi
fi
echo shar: "extracting 'x_win.c'" '(2317 characters)'
if test -f 'x_win.c'
then
	echo shar: "will not over-write existing file 'x_win.c'"
else
sed 's/^X//' << \SHAR_EOF > 'x_win.c'
X/*
X * Display the file transfer window, and invoke the transfer protocol.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "dial_dir.h"
X#include "misc.h"
X#include "xmodem.h"
X
Xvoid
Xxfer_win(list, up, type)
Xchar *list;
Xint up, type;
X{
X	extern int fd;
X	WINDOW *xf_win, *newwin();
X	int ack_error, fast;
X	void xmodem_mode(), input_off(), line_set(), st_line();
X
X	touchwin(stdscr);
X	refresh();
X	st_line("");
X
X	xf_win = newwin(15, 44, 2, 30);
X	/*
X	 * This window should be in the non-blocking mode, so we can
X	 * scan the keyboard for input while transferring a file.
X	 */
X	nodelay(xf_win, TRUE);
X					/* basic window stuff */
X	mvwaddstr(xf_win, 2, 14, "Protocol:");
X	mvwaddstr(xf_win, 3, 13, "File name:");
X	mvwaddstr(xf_win, 4, 13, "File size:");
X	mvwaddstr(xf_win, 5, 4, "Error check method:");
X	mvwaddstr(xf_win, 6, 5, "Est transfer time:");
X	mvwaddstr(xf_win, 7, 11, "Block count:");
X	mvwaddstr(xf_win, 8, 6, "Percent complete:");
X	mvwaddstr(xf_win, 9, 5, "Bytes transferred:");
X	mvwaddstr(xf_win, 10, 5, "Errors this block:");
X	mvwaddstr(xf_win, 11, 5, "Total error count:");
X	mvwaddstr(xf_win, 12, 10, "Last message: NONE");
X	box(xf_win, VERT, HORZ);
X
X	if (up)
X		mvwattrstr(xf_win, 0, 17, A_BOLD, " Uploading ");
X	else
X		mvwattrstr(xf_win, 0, 16, A_BOLD, " Downloading ");
X
X	mvwaddstr(xf_win, 14, 11, " Press <ESC> to abort ");
X	wrefresh(xf_win);
X					/* fix up the terminal mode */
X	input_off();
X	xmodem_mode(fd);
X
X	/*
X	 * Is your terminal slower than the xfer baud rate?  For example:
X	 * I'm at home with my PC and 1200 baud modem; I call my system
X	 * at work so I can use their 2400 baud modems to call some other
X	 * system.  In this case, I don't wanna spend too much time updating
X	 * my screen at 1200 baud, when I'm transferring the file at 2400 baud.
X	 */
X	fast = 0;
X
X	if (my_speed() >= dir->baud[dir->d_cur])
X		fast++;
X
X	if (up)
X		ack_error = send_xmodem(xf_win, list, type, fast);
X	else
X		ack_error = rcv_xmodem(xf_win, list, type, fast);
X
X	nodelay(xf_win, FALSE);
X					/* prompt for a key on errors */
X	if (ack_error) {
X		beep();
X		clear_line(xf_win, 13, 9, TRUE);
X		wattrstr(xf_win, A_BOLD, "Press any key to continue");
X		wrefresh(xf_win);
X		wgetch(xf_win);
X	}
X	werase(xf_win);
X	wrefresh(xf_win);
X	delwin(xf_win);
X					/* undo what xmodem_mode() did */
X	line_set();
X	return;
X}
SHAR_EOF
if test 2317 -ne "`wc -c < 'x_win.c'`"
then
	echo shar: "error transmitting 'x_win.c'" '(should have been 2317 characters)'
fi
fi
echo shar: "extracting 'xmodem.c'" '(6553 characters)'
if test -f 'xmodem.c'
then
	echo shar: "will not over-write existing file 'xmodem.c'"
else
sed 's/^X//' << \SHAR_EOF > 'xmodem.c'
X/*
X * Miscellaneous routines to support the xmodem file transfer protocols.
X */
X
X#define TMP_FILE	"trunXXXXXX"
X
X#include <stdio.h>
X#include <signal.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include "config.h"
X#include "misc.h"
X#include "param.h"
X#include "xmodem.h"
X
X#ifdef BSD
X#include <setjmp.h>
Xjmp_buf gl_buf, rl_buf;
X#endif /* BSD */
X
X/*
X * Calculate the CRC for the given buffer
X */
X
Xunsigned short
Xcalc_crc(buf, len)
Xunsigned char *buf;
Xint len;
X{
X	register int i;
X	unsigned short crc;
X	static unsigned short crctab[256] = {
X	0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,
X	0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,
X	0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,
X	0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,
X	0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
X	0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,
X	0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,
X	0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,
X	0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
X	0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,
X	0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,
X	0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
X	0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,
X	0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,
X	0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,
X	0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,
X	0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,
X	0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
X	0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,
X	0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,
X	0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,
X	0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
X	0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,
X	0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,
X	0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,
X	0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,
X	0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
X	0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,
X	0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,
X	0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,
X	0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
X	0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0};
X
X	crc = 0;
X	for (i=0; i<len; i++)
X		crc = (crc<<8) ^ crctab[(crc>>8) ^ *buf++];
X
X	return(crc);
X}
X
X/*
X * Calculate the checksum for the given buffer.
X */
X
Xunsigned char
Xcalc_sum(buf, len)
Xunsigned char *buf;
Xint len;
X{
X	unsigned char sum;
X
X	sum = 0;
X	while (--len >= 0)
X		sum += *buf++;
X
X	return(sum);
X}
X
X/*
X * Get a single character from the line with a specified time-out period
X * in seconds.  If the function times-out, it returns a -1.
X */
X
Xstatic int gl_flag;
X
Xint
Xgetc_line(sec)
Xunsigned int sec;
X{
X	extern int fd;
X	int gl_force();
X	char c;
X	unsigned int alarm();
X
X	signal(SIGALRM, gl_force);
X	gl_flag = 0;
X
X	alarm(sec);
X
X#ifdef BSD
X	if (setjmp(gl_buf))
X		return(-1);
X#endif /* BSD */
X
X	if (read(fd, &c, 1) <= 0) {
X		alarm(0);
X		return(-1);
X	}
X	if (gl_flag)
X		return(-1);
X	alarm(0);
X	return(c & 0xff);
X}
X
X/* ARGSUSED */
Xstatic int
Xgl_force(dummy)
Xint dummy;
X{
X#ifdef BSD
X	longjmp(gl_buf, 1);
X#else /* BSD */
X	signal(SIGALRM, gl_force);
X	gl_flag = 1;
X#endif /* BSD */
X}
X
X/*
X * Same as above, but reads a bunch of characters.  The return code is
X * now just a success/fail indicator.
X */
X
Xstatic int rl_flag;
X
Xint
Xfread_line(buf, len, sec)
Xunsigned char *buf;
Xunsigned int len, sec;
X{
X	extern int fd;
X	int n, rl_force();
X	unsigned int try, alarm();
X
X	signal(SIGALRM, rl_force);
X	rl_flag = 0;
X
X	alarm(sec);
X	while (len) {
X					/* read at most CLIST_SIZ chars */
X		try = (len > CLIST_SIZ) ? CLIST_SIZ : len;
X#ifdef BSD
X		if (setjmp(rl_buf))
X			return(-1);
X#endif /* BSD */
X		if ((n = read(fd, (char *) buf, try)) <= 0) {
X			alarm(0);
X			return(-1);
X		}
X		if (rl_flag)
X			return(-1);
X		len -= n;
X		buf = buf + n;
X	}
X	alarm(0);
X	return(0);
X}
X
X/* ARGSUSED */
Xstatic int
Xrl_force(dummy)
Xint dummy;
X{
X#ifdef BSD
X	longjmp(rl_buf, 1);
X#else /* BSD */
X	signal(SIGALRM, rl_force);
X	rl_flag = 1;
X#endif /* BSD */
X}
X
X/*
X * Put a character on the TTY line.  This serves no useful purpose other
X * than making the code look pretty.
X */
X
Xint
Xputc_line(c)
Xunsigned char c;
X{
X	extern int fd;
X
X	return(write(fd, (char *) &c, 1));
X}
X
X/*
X * Cancel the file transfer.  Send several ^X's to the remote, followed
X * by an equal number of backspaces (in case they have already aborted and
X * we're really at the command line).
X */
X
Xvoid
Xcancel_xfer(up)
Xint up;
X{
X	extern char file_name[15];
X
X	if (!up && !strcmp(param->abort, "DELETE"))
X		unlink(file_name);
X
X	putc_line(CAN);
X	putc_line(CAN);
X	putc_line(CAN);
X	putc_line(BS);
X	putc_line(BS);
X	putc_line(BS);
X	return;
X}
X
X/*
X * Shorten a file to a predetermined length.  Used to remove the ^Z
X * padding from the end of files.  (Heaven help us, if one day a binary
X * file actually has ^Z's as part of the end of the file).
X */
X
Xint
Xfix_length(file, len)
Xchar *file;
Xlong len;
X{
X	FILE *fp, *tempfp, *my_fopen();
X	register int num;
X	char *mktemp(), tempfile[128], buf[BUFSIZ], *strcpy();
X	char *s, *strrchr(), *strcat();
X	struct stat stbuf;
X
X	if (stat(file, &stbuf) < 0)
X		return(1);
X					/* see if we have any work to do */
X	if (len >= stbuf.st_size)
X		return(0);
X
X	if (!(fp = my_fopen(file, "r")))
X		return(1);
X
X	/*
X	 * The temporary file should be in the same directory as the
X	 * file being received because otherwise we'd have no way of
X	 * guaranteeing they would be in the same file system.  (Hard
X	 * links across different file systems aren't allowed).
X	 */
X	strcpy(tempfile, file);
X	if (s = strrchr(tempfile, '/'))
X		*++s = '\0';
X	else
X		strcpy(tempfile, "./");
X
X	strcat(tempfile, TMP_FILE);
X	mktemp(tempfile);
X
X	if (!(tempfp = my_fopen(tempfile, "w"))) {
X		fclose(fp);
X		return(1);
X	}
X
X	while (len != 0L) {
X		num = (len > BUFSIZ) ? BUFSIZ : len;
X		fread(buf, sizeof(char), num, fp);
X		if (fwrite(buf, sizeof(char), num, tempfp) != num) {
X			fclose(fp);
X			fclose(tempfp);
X			return(1);
X		}
X		len = len - (unsigned int) num;
X	}
X
X	fclose(fp);
X	fclose(tempfp);
X
X	if (unlink(file) < 0)
X		return(1);
X
X	if (link(tempfile, file) < 0)
X		return(1);
X
X	if (unlink(tempfile) < 0)
X		return(1);
X
X	return(0);
X}
SHAR_EOF
if test 6553 -ne "`wc -c < 'xmodem.c'`"
then
	echo shar: "error transmitting 'xmodem.c'" '(should have been 6553 characters)'
fi
fi
echo shar: "extracting 'xmodem.h'" '(561 characters)'
if test -f 'xmodem.h'
then
	echo shar: "will not over-write existing file 'xmodem.h'"
else
sed 's/^X//' << \SHAR_EOF > 'xmodem.h'
X/*
X * Definitions for the xmodem stuff.
X */
X
X#define MAX_ERRORS	10
X
X#define SOH		1
X#define STX		2
X#define EOT		4
X#define ACK		6
X#define NAK		21
X#define CAN		24
X#define CTRLZ		26
X
X#define NUM_INTERNAL	6
X#define XMODEM		0
X#define XMODEM_1k	1
X#define MODEM7		2
X#define YMODEM		3
X#define YMODEM_G	4
X#define XASCII		5
X#define EXT_1		6
X#define EXT_2		7
X#define EXT_3		8
X#define EXT_MANUAL	9
X
X#define ABORT		(-1)
X#define ERROR		(-2)
X#define CANCEL		(-3)
X
X#define CHECKSUM	0
X#define CRC_CHECKSUM	1
X#define CRC		2
X#define NONE		3
X
X#define DOWN_LOAD	0
X#define UP_LOAD		1
SHAR_EOF
if test 561 -ne "`wc -c < 'xmodem.h'`"
then
	echo shar: "error transmitting 'xmodem.h'" '(should have been 561 characters)'
fi
fi
exit 0
#	End of shell archive


