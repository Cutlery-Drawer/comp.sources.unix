Subject:  v20i072:  Pcomm telecommunication package, Part06/08
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: fthood!egray
Posting-number: Volume 20, Issue 72
Archive-name: pcomm1.2/part06

#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create:
#	redial.c
#	s_axfer.c
#	s_extrnl.c
#	s_gen.c
#	s_menu.c
#	s_modem.c
#	s_prompt.c
#	s_term.c
#	s_tty.c
#	screen.c
#	script.c
#	st_line.c
#	status.h
#	strings.c
# This archive created: Fri Feb  3 07:35:32 1989
export PATH; PATH=/bin:/usr/bin:$PATH
echo shar: "extracting 'redial.c'" '(2253 characters)'
if test -f 'redial.c'
then
	echo shar: "will not over-write existing file 'redial.c'"
else
sed 's/^X//' << \SHAR_EOF > 'redial.c'
X/*
X * The redial option (actually a misnomer, it's really a queuing system).
X * We expect a space-separated list of dialing directory entries (although
X * new users always try to put in a phone number).  A non-zero return code
X * means we're ready to dial.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "dial_dir.h"
X#include "misc.h"
X
Xint
Xredial()
X{
X	extern int fd;
X	WINDOW *rd_win, *newwin();
X	char *ans, *entry, *get_str(), *strchr(), *strtok();
X	int i, oops, number, ret_code;
X
X	rd_win = newwin(6, 70, 5, 5);
X
X	mvwaddstr(rd_win, 4, 23, "(<CR> for previous numbers)");
X	mvwaddstr(rd_win, 2, 4, "Directory Entry Number(s): ");
X	box(rd_win, VERT, HORZ);
X
X	mvwattrstr(rd_win, 0, 3, A_BOLD, " Redial Queue ");
X	wmove(rd_win, 2, 31);
X	wrefresh(rd_win);
X					/* get the string of numbers */
X	ret_code = 0;
X	while ((ans = get_str(rd_win, 35, "0123456789+-@# ", "")) != NULL) {
X		oops = 0;
X		if (*ans == '\0') {
X					/* use previous queue */
X			if (dir->q_num[0] != -1) {
X				ret_code++;
X				break;
X			}
X					/* there is no previous queue */
X			beep();
X			mvwattrstr(rd_win, 3, 4, A_BOLD, "No previous numbers");
X			wrefresh(rd_win);
X			wait_key(rd_win, 3);
X			clear_line(rd_win, 3, 4, TRUE);
X			wmove(rd_win, 2, 31);
X			wrefresh(rd_win);
X			continue;
X		}
X					/* parse the queue values */
X		entry = strtok(ans, " \t");
X		for (i=0; i<NUM_QUEUE; i++) {
X			if (*entry == '\0') {
X				dir->q_num[i] = -1;
X				continue;
X			}
X					/* is there a LD code? */
X			dir->q_ld[i] = '\0';
X			if (strchr("+-@#", *entry)) {
X				dir->q_ld[i] = *entry;
X				entry++;
X			}
X
X			/*
X			 * Zero is valid here, because it means use
X			 * the current entry information.
X			 */
X			number = atoi(entry);
X			if (number < -1 || number > NUM_DIR) {
X				beep();
X				mvwattrstr(rd_win, 3, 4, A_BOLD, "Invalid directory entry number");
X				wrefresh(rd_win);
X				wait_key(rd_win, 3);
X				clear_line(rd_win, 3, 4, TRUE);
X				clear_line(rd_win, 2, 31, TRUE);
X				wrefresh(rd_win);
X				oops++;
X				break;
X			}
X					/* store the number in the queue */
X			dir->q_num[i] = number;
X			entry = strtok((char *) NULL, " \t");
X		}
X		if (oops)
X			continue;
X		ret_code++;
X		break;
X	}
X	if (fd == -1) {
X		werase(rd_win);
X		wrefresh(rd_win);
X	}
X	delwin(rd_win);
X	return(ret_code);
X}
SHAR_EOF
if test 2253 -ne "`wc -c < 'redial.c'`"
then
	echo shar: "error transmitting 'redial.c'" '(should have been 2253 characters)'
fi
fi
echo shar: "extracting 's_axfer.c'" '(3835 characters)'
if test -f 's_axfer.c'
then
	echo shar: "will not over-write existing file 's_axfer.c'"
else
sed 's/^X//' << \SHAR_EOF > 's_axfer.c'
X/*
X * Display the ASCII transfer setup, query for changes.  A non-zero return
X * code means something was changed.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "misc.h"
X#include "param.h"
X
Xint
Xaxfer_setup()
X{
X	extern char *v_yes[];
X	WINDOW *x_win, *newwin();
X	int i, ret_code, num;
X	char *ans, *menu_prompt(), *str_rep();
X	static char *v_cr[4] = {"NONE", "STRIP", "ADD LF", NULL};
X	static char *v_lf[4] = {"NONE", "STRIP", "ADD CR", NULL};
X	static char *v_delay[4] = {"0", "100", "150", NULL};
X
X	x_win = newwin(23, 80, 0, 0);
X
X	horizontal(x_win, 0, 0, 28);
X	mvwattrstr(x_win, 0, 29, A_BOLD, "ASCII Transfer Setup");
X	horizontal(x_win, 0, 50, 29);
X	mvwaddstr(x_win, 3, 33, "ASCII UPLOAD");
X	mvwprintw(x_win, 5, 22, "1) Echo locally ........... %s", param->lecho);
X	mvwprintw(x_win, 6, 22, "2) Expand blank lines ..... %s", param->expand);
X	mvwprintw(x_win, 7, 22, "3) CR delay (ms) .......... %d", param->cr_delay);
X	mvwprintw(x_win, 8, 22, "4) Pace the output ........ %s", param->pace);
X	mvwprintw(x_win, 9, 22, "5) CR translation ......... %s", param->cr_up);
X	mvwprintw(x_win, 10, 22, "6) LF translation ......... %s", param->lf_up);
X	mvwaddstr(x_win, 12, 32, "ASCII DOWNLOAD");
X	mvwprintw(x_win, 14, 22, "7) Transfer timeout (sec) . %d", param->timer);
X	mvwprintw(x_win, 15, 22, "8) CR translation ......... %s", param->cr_dn);
X	mvwprintw(x_win, 16, 22, "9) LF translation ......... %s", param->lf_dn);
X	horizontal(x_win, 19, 0, 80);
X	mvwattrstr(x_win, 20, 0, A_BOLD, "OPTION ==> ");
X	mvwaddstr(x_win, 20, 58, "Press <ESC> to return");
X	wmove(x_win, 20, 12);
X	touchwin(x_win);
X	wrefresh(x_win);
X					/* get the option number */
X	ret_code = 0;
X	while ((i = get_num(x_win, 1)) != -1) {
X		switch (i) {
X			case 1:
X				if ((ans = menu_prompt(x_win, 5, 50, "Echo locally", v_yes)) != NULL) {
X					param->lecho = str_rep(param->lecho, ans);
X					ret_code++;
X				}
X				break;
X			case 2:
X				if ((ans = menu_prompt(x_win, 6, 50, "Expand blank lines", v_yes)) != NULL) {
X					param->expand = str_rep(param->expand, ans);
X					ret_code++;
X				}
X				break;
X			case 3:
X				if ((ans = menu_prompt(x_win, 7, 50, "CR delay (ms)", v_delay)) != NULL) {
X					param->cr_delay = atoi(ans);
X					ret_code++;
X				}
X				break;
X			case 4:
X				if ((ans = menu_prompt(x_win, 8, 50, "Pace the output", v_yes)) != NULL) {
X					param->pace = str_rep(param->pace, ans);
X					ret_code++;
X				}
X				break;
X			case 5:
X				if ((ans = menu_prompt(x_win, 9, 50, "CR translation (upload)", v_cr)) != NULL) {
X					param->cr_up = str_rep(param->cr_up, ans);
X					ret_code++;
X				}
X				break;
X			case 6:
X				if ((ans = menu_prompt(x_win, 10, 50, "LF translation (upload)", v_lf)) != NULL) {
X					param->lf_up = str_rep(param->lf_up, ans);
X					ret_code++;
X				}
X				break;
X			case 7:
X				if ((num = num_prompt(x_win, 14, 50, "Transfer timeout", "(in seconds)")) != -1) {
X					if (num > MAX_TIMER || num < MIN_TIMER) {
X						beep();
X					/* some reasonable range of values */
X						if (num < MIN_TIMER)
X							num = MIN_TIMER;
X						else
X							num = MAX_TIMER;
X						mvwaddstr(x_win, 14, 50, "   ");
X						wrefresh(x_win);
X						mvwattrnum(x_win, 14, 50, A_BOLD, num);
X						wrefresh(x_win);
X					}
X					param->timer = num;
X					ret_code++;
X				}
X				break;
X			case 8:
X				if ((ans = menu_prompt(x_win, 15, 50, "CR translation (download)", v_cr)) != NULL) {
X					param->cr_dn = str_rep(param->cr_dn, ans);
X					ret_code++;
X				}
X				break;
X			case 9:
X				if ((ans = menu_prompt(x_win, 16, 50, "LF translation (download)", v_lf)) != NULL) {
X					param->lf_dn = str_rep(param->lf_dn, ans);
X					ret_code++;
X				}
X				break;
X			default:
X				beep();
X		}
X		mvwaddch(x_win, 20, 12, (chtype) ' ');
X		clear_line(x_win, 21, 0, FALSE);
X		clear_line(x_win, 22, 0, FALSE);
X		wmove(x_win, 20, 12);
X		wrefresh(x_win);
X	}
X	delwin(x_win);
X	return(ret_code);
X}
SHAR_EOF
if test 3835 -ne "`wc -c < 's_axfer.c'`"
then
	echo shar: "error transmitting 's_axfer.c'" '(should have been 3835 characters)'
fi
fi
echo shar: "extracting 's_extrnl.c'" '(4086 characters)'
if test -f 's_extrnl.c'
then
	echo shar: "will not over-write existing file 's_extrnl.c'"
else
sed 's/^X//' << \SHAR_EOF > 's_extrnl.c'
X/*
X * Display the external protocol setup, query for changes.  A non-zero
X * return code means something was changed.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "extrnl.h"
X#include "misc.h"
X
Xint
Xext_setup()
X{
X	extern char *null_ptr;
X	WINDOW *ext_win, *newwin();
X	int i, ret_code;
X	char *str, *get_str();
X	void disp_ext();
X
X	ext_win = newwin(23, 80, 0, 0);
X
X	horizontal(ext_win, 0, 0, 27);
X	mvwattrstr(ext_win, 0, 28, A_BOLD, "External Protocol Setup");
X	horizontal(ext_win, 0, 52, 27);
X	mvwaddstr(ext_win, 3, 36, "UPLOAD");
X	mvwaddstr(ext_win, 5, 8, "Name");
X	mvwaddstr(ext_win, 5, 21, "Command line");
X	mvwaddstr(ext_win, 5, 54, "Requires file list?");
X	mvwaddstr(ext_win, 10, 35, "DOWNLOAD");
X	mvwaddstr(ext_win, 12, 8, "Name");
X	mvwaddstr(ext_win, 12, 21, "Command line");
X	mvwaddstr(ext_win, 12, 54, "Requires file list?");
X					/* display the current list */
X	disp_ext(ext_win);
X
X	horizontal(ext_win, 19, 0, 80);
X	mvwattrstr(ext_win, 20, 0, A_BOLD, "OPTION ==> ");
X	mvwaddstr(ext_win, 20, 58, "Press <ESC> to return");
X	wmove(ext_win, 20, 12);
X	touchwin(ext_win);
X	wrefresh(ext_win);
X					/* get the option */
X	ret_code = 0;
X	while ((str = get_str(ext_win, 1, "1234356", "")) != NULL) {
X		switch(*str) {
X			case '1':
X				if (ext_prompt(ext_win, 1, 0, 6))
X					ret_code++;
X				break;
X			case '2':
X				if (ext_prompt(ext_win, 1, 1, 7))
X					ret_code++;
X				break;
X			case '3':
X				if (ext_prompt(ext_win, 1, 2, 8))
X					ret_code++;
X				break;
X			case '4':
X				if (ext_prompt(ext_win, 0, 0, 13))
X					ret_code++;
X				break;
X			case '5':
X				if (ext_prompt(ext_win, 0, 1, 14))
X					ret_code++;
X				break;
X			case '6':
X				if (ext_prompt(ext_win, 0, 2, 15))
X					ret_code++;
X				break;
X		}
X		mvwaddstr(ext_win, 20, 12, "  ");
X		clear_line(ext_win, 21, 0, FALSE);
X		clear_line(ext_win, 22, 0, FALSE);
X		wmove(ext_win, 20, 12);
X		wrefresh(ext_win);
X	}
X	/*
X	 * Recalculate the number of entries.  Please notice that if you
X	 * create an empty entry (a hole), all entries after that are ignored.  
X	 * The software doesn't compact the holes out.. you're on your own.
X	 */
X	if (ret_code) {
X		for (i=0; i<3; i++) {
X			if (extrnl->name[1][i] == null_ptr)
X				break;
X		}
X		extrnl->up_entries = i;
X
X		for (i=0; i<3; i++) {
X			if (extrnl->name[0][i] == null_ptr)
X				break;
X		}
X		extrnl->dn_entries = i;
X	}
X	delwin(ext_win);
X	return(ret_code);
X}
X
X/*
X * Display the current list of external file transfer programs.
X */
X
Xstatic void
Xdisp_ext(win)
XWINDOW *win;
X{
X	int i, up, entry, line;
X
X	up = 1;
X	line = 6;
X	for (i=0; i<6; i++) {
X		if (i < 3)
X			entry = i;
X		else {
X			up = 0;
X			entry = i-3;
X			line = 10;
X		}
X		mvwprintw(win, i+line, 5, "%d) %-12.12s %-40.40s  %c\n",
X		 i+1, extrnl->name[up][entry], extrnl->command[up][entry],
X		 extrnl->prompt[up][entry]);
X	}
X	return;
X}
X
X/*
X * Prompt for the info in the database.  A non-zero return code means
X * that something was changed.  To delete the line, you enter a single
X * space character at the first prompt.
X */
X
Xstatic int
Xext_prompt(win, up, entry, line)
XWINDOW *win;
Xint up, entry, line;
X{
X	extern char *v_yn[], *null_ptr;
X	char *ans, t_name[80], t_command[80], *str_prompt(), *str_rep();
X	char *strcpy(), *menu_prompt();
X
X					/* get temp name */
X	if ((ans = str_prompt(win, line, 8, "Protocol name", "")) == NULL)
X		return(0);
X
X	strcpy(t_name, ans);
X	clear_line(win, 21, 0, FALSE);
X					/* are we zapping the line */
X	if (ans == null_ptr) {
X		extrnl->name[up][entry] = null_ptr;
X		extrnl->command[up][entry] = null_ptr;
X		extrnl->prompt[up][entry] = 'N';
X		return(1);
X	}
X					/* get temp command */
X	if ((ans = str_prompt(win, line, 21, "Command line", "")) == NULL)
X		return(0);
X
X	strcpy(t_command, ans);
X	clear_line(win, 21, 0, FALSE);
X
X					/* get temp prompt */
X	if ((ans = menu_prompt(win, line, 63, "Does it require a file list", v_yn)) == NULL)
X		return(0);
X
X	wrefresh(win);
X					/* store 'em for real */
X	extrnl->name[up][entry] = str_rep(extrnl->name[up][entry], t_name);
X	extrnl->command[up][entry] = str_rep(extrnl->command[up][entry], t_command);
X	extrnl->prompt[up][entry] = *ans;
X
X	return(1);
X}
SHAR_EOF
if test 4086 -ne "`wc -c < 's_extrnl.c'`"
then
	echo shar: "error transmitting 's_extrnl.c'" '(should have been 4086 characters)'
fi
fi
echo shar: "extracting 's_gen.c'" '(4402 characters)'
if test -f 's_gen.c'
then
	echo shar: "will not over-write existing file 's_gen.c'"
else
sed 's/^X//' << \SHAR_EOF > 's_gen.c'
X/*
X * Display the general setup, query for changes.  A non-zero return code
X * means something was changed.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "misc.h"
X#include "param.h"
X
Xint
Xgen_setup()
X{
X	extern char *v_yes[];
X	WINDOW *g_win, *newwin();
X	int i, num, ret_code;
X	char c, *ans, *str_prompt(), *menu_prompt(), chr_prompt();
X	char *str_rep();
X	void line_set();
X	static char *v_abort[3] = {"KEEP", "DELETE", NULL};
X
X	g_win = newwin(23, 80, 0, 0);
X
X	horizontal(g_win, 0, 0, 32);
X	mvwattrstr(g_win, 0, 33, A_BOLD, "General Setup");
X	horizontal(g_win, 0, 47, 32);
X	mvwprintw(g_win, 3, 22, "1) Default log file ....... %s", param->logfile);
X	mvwprintw(g_win, 4, 22, "2) Screen dump file ....... %s", param->dumpfile);
X	mvwprintw(g_win, 6, 22, "3) Strip high bit  ........ %s", param->strip);
X	mvwprintw(g_win, 8, 22, "4) Pause character ........ %c", param->pause_char);
X	mvwprintw(g_win, 9, 22, "5) CR character ........... %c", param->cr_char);
X	mvwprintw(g_win, 10, 22, "6) CTRL character ......... %c", param->ctrl_char);
X	mvwprintw(g_win, 11, 22, "7) ESC character .......... %c", param->esc_char);
X	mvwprintw(g_win, 12, 22, "8) Break character ........ %c", param->brk_char);
X	mvwprintw(g_win, 14, 22, "9) Aborted downloads ...... %s", param->abort);
X	mvwprintw(g_win, 16, 21, "10) Connect delay (sec) .... %d", param->c_delay);
X	mvwprintw(g_win, 17, 21, "11) Redial delay (sec) ..... %d", param->r_delay);
X	horizontal(g_win, 19, 0, 80);
X	mvwattrstr(g_win, 20, 0, A_BOLD, "OPTION ==> ");
X	mvwaddstr(g_win, 20, 58, "Press <ESC> to return");
X	wmove(g_win, 20, 12);
X	touchwin(g_win);
X	wrefresh(g_win);
X					/* get the option number */
X	ret_code = 0;
X	while ((i = get_num(g_win, 2)) != -1) {
X		switch (i) {
X			case 1:
X				if ((ans = str_prompt(g_win, 3, 50, "Default log file", "")) != NULL) {
X					param->logfile = str_rep(param->logfile, ans);
X					ret_code++;
X				}
X				break;
X			case 2:
X				if ((ans = str_prompt(g_win, 4, 50, "Default screen dump file", "")) != NULL) {
X					param->dumpfile = str_rep(param->dumpfile, ans);
X					ret_code++;
X				}
X				break;
X			case 3:
X				if ((ans = menu_prompt(g_win, 6, 50, "Strip high bit?", v_yes)) != NULL) {
X					param->strip = str_rep(param->strip, ans);
X					line_set();
X					ret_code++;
X				}
X				break;
X			case 4:
X				if ((c = chr_prompt(g_win, 8, 50, "Pause character", "1 second")) != '\0') {
X					param->pause_char = c;
X					ret_code++;
X				}
X				break;
X			case 5:
X				if ((c = chr_prompt(g_win, 9, 50, "CR character", "(carriage return)")) != '\0') {
X					param->cr_char = c;
X					ret_code++;
X				}
X				break;
X			case 6:
X				if ((c = chr_prompt(g_win, 10, 50, "CTRL character", "(control)")) != '\0') {
X					param->ctrl_char = c;
X					ret_code++;
X				}
X				break;
X			case 7:
X				if ((c = chr_prompt(g_win, 11, 50, "ESC character", "(escape)")) != '\0') {
X					param->esc_char = c;
X					ret_code++;
X				}
X				break;
X			case 8:
X				if ((c = chr_prompt(g_win, 12, 50, "Break character", "")) != '\0') {
X					param->brk_char = c;
X					ret_code++;
X				}
X			case 9:
X				if ((ans = menu_prompt(g_win, 14, 50, "Aborted downloads", v_abort)) != NULL) {
X					param->abort = str_rep(param->abort, ans);
X					ret_code++;
X				}
X				break;
X			case 10:
X				if ((num = num_prompt(g_win, 16, 50, "Connect delay time", "(in seconds)")) != -1) {
X					if (num > MAX_CDELAY || num < MIN_CDELAY) {
X						beep();
X					/* some reasonable range of values */
X						if (num < MIN_CDELAY)
X							num = MIN_CDELAY;
X						else
X							num = MAX_CDELAY;
X						mvwaddstr(g_win, 16, 50, "   ");
X						wrefresh(g_win);
X						mvwattrnum(g_win, 16, 50, A_BOLD, num);
X						wrefresh(g_win);
X					}
X					param->c_delay = num;
X					ret_code++;
X				}
X				break;
X			case 11:
X				if ((num = num_prompt(g_win, 17, 50, "Redial delay time", "(in seconds)")) != -1) {
X					if (num > MAX_PAUSE || num < MIN_PAUSE) {
X						beep();
X					/* some reasonable range */
X						if (num < MIN_PAUSE)
X							num = MIN_PAUSE;
X						else
X							num = MAX_PAUSE;
X						mvwaddstr(g_win, 17, 50, "    ");
X						wrefresh(g_win);
X						mvwattrnum(g_win, 17, 50, A_BOLD, num);
X						wrefresh(g_win);
X					}
X					param->r_delay = num;
X					ret_code++;
X				}
X				break;
X			default:
X				beep();
X		}
X		mvwaddstr(g_win, 20, 12, "  ");
X		clear_line(g_win, 21, 0, FALSE);
X		clear_line(g_win, 22, 0, FALSE);
X		wmove(g_win, 20, 12);
X		wrefresh(g_win);
X	}
X	delwin(g_win);
X	return(ret_code);
X}
SHAR_EOF
if test 4402 -ne "`wc -c < 's_gen.c'`"
then
	echo shar: "error transmitting 's_gen.c'" '(should have been 4402 characters)'
fi
fi
echo shar: "extracting 's_menu.c'" '(3200 characters)'
if test -f 's_menu.c'
then
	echo shar: "will not over-write existing file 's_menu.c'"
else
sed 's/^X//' << \SHAR_EOF > 's_menu.c'
X/*
X * Display the setup menu, prompts for a bunch of other menus.  A non-zero
X * return code means we have to restart the input routine.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "misc.h"
X
Xint
Xsetup_menu()
X{
X	extern int fd, xmc;
X	WINDOW *s_win, *newwin();
X	char *ans, *get_str();
X	int param_flag, modem_flag, ext_flag, ret_code;
X	void top_line();
X
X	s_win = newwin(23, 80, 0, 0);
X
X	top_line(s_win);
X	mvwaddstr(s_win, 3, 29, "1) TTY Setup");
X	mvwaddstr(s_win, 5, 29, "2) Modem Setup");
X	mvwaddstr(s_win, 7, 29, "3) Terminal Setup");
X	mvwaddstr(s_win, 9, 29, "4) General Setup");
X	mvwaddstr(s_win, 11, 29, "5) ASCII Transfer Setup");
X	mvwaddstr(s_win, 13, 29, "6) External Protocol Setup");
X	mvwaddstr(s_win, 15, 29, "S) Save setup to disk");
X	horizontal(s_win, 19, 0, 80);
X	mvwattrstr(s_win, 20, 0, A_BOLD, "OPTION ==> ");
X	mvwaddstr(s_win, 20, 58, "  Press <ESC> to exit");
X	wmove(s_win, 20, 12);
X	touchwin(s_win);
X	wrefresh(s_win);
X
X	param_flag = 0;
X	modem_flag = 0;
X	ext_flag = 0;
X	ret_code = 0;
X					/* get the options */
X	while ((ans = get_str(s_win, 1, "123456Ss", "")) != NULL) {
X		if (xmc > 0) {
X			clear_line(s_win, 0, 0, FALSE);
X			wrefresh(s_win);
X		}
X		switch (*ans) {
X			case '1':
X				if (tty_setup())
X					modem_flag++;
X				break;
X			case '2':
X				if (modem_setup())
X					modem_flag++;
X				break;
X			case '3':
X				/*
X				 * term_setup() returns a 1 if something was
X				 * changed, and a 2 if the change requires
X				 * the input routine to be restarted.
X				 */
X				if (ret_code = term_setup()) {
X					ret_code--;
X					param_flag++;
X				}
X				break;
X			case '4':
X				if (gen_setup())
X					param_flag++;
X				break;
X			case '5':
X				if (axfer_setup())
X					param_flag++;
X				break;
X			case '6':
X				if (ext_setup())
X					ext_flag++;
X				break;
X			case 's':
X			case 'S':
X				if (xmc > 0)
X					top_line(s_win);
X				/*
X				 * Writes to disk are not critical, since
X				 * the changes are made in memory.
X				 */
X				if (param_flag) {
X					mvwattrstr(s_win, 22, 27, A_BLINK, "Updating Parameter File");
X					wrefresh(s_win);
X					wait_key(s_win, 3);
X					if (up_param()) {
X						touchwin(s_win);
X						wrefresh(s_win);
X					}
X				}
X				if (modem_flag) {
X					mvwattrstr(s_win, 22, 27, A_BLINK, "Updating Modem Database");
X					wrefresh(s_win);
X					wait_key(s_win, 3);
X					if (up_modem()) {
X						touchwin(s_win);
X						wrefresh(s_win);
X					}
X				}
X				if (ext_flag) {
X					mvwattrstr(s_win, 22, 25, A_BLINK, "Updating External Protocols");
X					wrefresh(s_win);
X					wait_key(s_win, 3);
X					if (up_extrnl()) {
X						touchwin(s_win);
X						wrefresh(s_win);
X					}
X				}
X				clear_line(s_win, 22, 25, FALSE);
X				wrefresh(s_win);
X				break;
X			default:
X				beep();
X		}
X		touchwin(s_win);
X		if (xmc > 0)
X			top_line(s_win);
X
X		mvwaddch(s_win, 20, 12, (chtype) ' ');
X		wmove(s_win, 20, 12);
X		wrefresh(s_win);
X	}
X	if (fd == -1) {
X		werase(s_win);
X		wrefresh(s_win);
X	}
X	delwin(s_win);
X	return(ret_code);
X}
X
X/*
X * Put the top line on the window.
X */
X
Xvoid
Xtop_line(win)
XWINDOW *win;
X{
X	clear_line(win, 0, 0, FALSE);
X	wrefresh(win);
X	horizontal(win, 0, 0, 33);
X	mvwattrstr(win, 0, 34, A_BOLD, "Setup Menu");
X	horizontal(win, 0, 45, 34);
X	wrefresh(win);
X	return;
X}
SHAR_EOF
if test 3200 -ne "`wc -c < 's_menu.c'`"
then
	echo shar: "error transmitting 's_menu.c'" '(should have been 3200 characters)'
fi
fi
echo shar: "extracting 's_modem.c'" '(6656 characters)'
if test -f 's_modem.c'
then
	echo shar: "will not over-write existing file 's_modem.c'"
else
sed 's/^X//' << \SHAR_EOF > 's_modem.c'
X/*
X * Display the modem setup, query for changes.  A non-zero return code
X * means something was changed.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "misc.h"
X#include "modem.h"
X
Xint
Xmodem_setup()
X{
X	WINDOW *mo_win, *newwin();
X	int i, j, ret_code, mod_prompt();
X	char *ans, *str_rep(), *str_prompt(), *menu_prompt();
X	void disp_modem();
X	extern char *v_yn[];
X					/* the current modem */
X	j = 0;
X	if (modem->m_cur != -1)
X		j = modem->m_cur;
X
X	mo_win = newwin(23, 80, 0, 0);
X
X	horizontal(mo_win, 0, 0, 33);
X	mvwattrstr(mo_win, 0, 34, A_BOLD, "Modem Setup");
X	horizontal(mo_win, 0, 46, 34);
X					/* display the current settings */
X	disp_modem(mo_win, j);
X	horizontal(mo_win, 19, 0, 80);
X	mvwattrstr(mo_win, 20, 0, A_BOLD, "OPTION ==> ");
X	mvwaddstr(mo_win, 20, 58, "Press <ESC> to return");
X	wmove(mo_win, 20, 12);
X	touchwin(mo_win);
X	wrefresh(mo_win);
X					/* get the option number */
X	ret_code = 0;
X	while ((i = get_num(mo_win, 2)) != -1) {
X		switch (i) {
X			case 1:
X				j = mod_prompt(mo_win);
X				break;
X			case 2:
X				if ((ans = str_prompt(mo_win, 3, 39, "Modem init string", "sent to the modem once")) != NULL) {
X					modem->init[j] = str_rep(modem->init[j], ans);
X					ret_code++;
X				}
X				break;
X			case 3:
X				if ((ans = str_prompt(mo_win, 4, 39, "Dialing command", "")) != NULL) {
X					modem->dial[j] = str_rep(modem->dial[j], ans);
X					ret_code++;
X				}
X				break;
X			case 4:
X				if ((ans = str_prompt(mo_win, 5, 39, "Dialing cmd suffix", "typically the <CR> character")) != NULL) {
X					modem->suffix[j] = str_rep(modem->suffix[j], ans);
X					ret_code++;
X				}
X				break;
X			case 5:
X				if ((ans = str_prompt(mo_win, 6, 39, "Hang up string", "")) != NULL) {
X					modem->hang_up[j] = str_rep(modem->hang_up[j], ans);
X					ret_code++;
X				}
X				break;
X			case 6:
X				if ((ans = menu_prompt(mo_win, 7, 39, "Auto Baud detect", v_yn)) != NULL) {
X					modem->auto_baud[j] = *ans;
X					ret_code++;
X				}
X				break;
X			case 7:
X				if ((ans = str_prompt(mo_win, 8, 39, "300 baud connect string", "")) != NULL) {
X					modem->con_3[j] = str_rep(modem->con_3[j], ans);
X					ret_code++;
X				}
X				break;
X			case 8:
X				if ((ans = str_prompt(mo_win, 9, 39, "1200 baud connect string", "")) != NULL) {
X					modem->con_12[j] = str_rep(modem->con_12[j], ans);
X					ret_code++;
X				}
X				break;
X			case 9:
X				if ((ans = str_prompt(mo_win, 10, 39, "2400 baud connect string", "")) != NULL) {
X					modem->con_24[j] = str_rep(modem->con_24[j], ans);
X					ret_code++;
X				}
X				break;
X			case 10:
X				if ((ans = str_prompt(mo_win, 11, 39, "4800 baud connect string", "")) != NULL) {
X					modem->con_48[j] = str_rep(modem->con_48[j], ans);
X					ret_code++;
X				}
X				break;
X			case 11:
X				if ((ans = str_prompt(mo_win, 12, 39, "9600 baud connect string", "")) != NULL) {
X					modem->con_96[j] = str_rep(modem->con_96[j], ans);
X					ret_code++;
X				}
X				break;
X			case 12:
X				if ((ans = str_prompt(mo_win, 13, 39, "19200 baud connect string", "")) != NULL) {
X					modem->con_192[j] = str_rep(modem->con_192[j], ans);
X					ret_code++;
X				}
X				break;
X			case 13:
X				if ((ans = str_prompt(mo_win, 14, 39, "No connect string 1", "")) != NULL) {
X					modem->no_con1[j] = str_rep(modem->no_con1[j], ans);
X					ret_code++;
X				}
X				break;
X			case 14:
X				if ((ans = str_prompt(mo_win, 15, 39, "No connect string 2", "")) != NULL) {
X					modem->no_con2[j] = str_rep(modem->no_con2[j], ans);
X					ret_code++;
X				}
X				break;
X			case 15:
X				if ((ans = str_prompt(mo_win, 16, 39, "No connect string 3", "")) != NULL) {
X					modem->no_con3[j] = str_rep(modem->no_con3[j], ans);
X					ret_code++;
X				}
X				break;
X			case 16:
X				if ((ans = str_prompt(mo_win, 17, 39, "No connect string 4", "")) != NULL) {
X					modem->no_con4[j] = str_rep(modem->no_con4[j], ans);
X					ret_code++;
X				}
X				break;
X			default:
X				beep();
X		}
X					/* clear the previous prompts */
X		mvwaddstr(mo_win, 20, 12, "   ");
X		clear_line(mo_win, 21, 0, FALSE);
X		clear_line(mo_win, 22, 0, FALSE);
X		wmove(mo_win, 20, 12);
X		wrefresh(mo_win);
X	}
X	delwin(mo_win);
X	return(ret_code);
X}
X
X/*
X * Prompts for the modem name.  The user selects the currently showing
X * choice by hitting a carriage return.  Returns the modem entry number.
X * DOES NOT change the value of modem->m_cur.
X */
X
Xstatic int
Xmod_prompt(win)
XWINDOW *win;
X{
X	char ans;
X	int i;
X					/* print prompt lines */
X	mvwaddstr(win, 22, 0, "Press any key to change, or <CR> to accept");
X	mvwaddstr(win, 21, 0, "Modem name: ");
X					/* show current choice */
X	i = 0;
X	if (modem->m_cur != -1)
X		i = modem->m_cur;
X	mvwprintw(win, 21, 12, "%-30.30s", modem->mname[i]);
X	wmove(win, 21, 12);
X	wrefresh(win);
X					/* show the choices one at a time */
X	while ((ans = wgetch(win)) != '\r') {
X		i++;
X		if (*modem->mname[i] == '\0')
X			i = 0;
X		if (ans == ESC)
X			return(0);
X		mvwprintw(win, 21, 12, "%-30.30s", modem->mname[i]);
X		wmove(win, 21, 12);
X		wrefresh(win);
X	}
X					/* display the new values */
X	disp_modem(win, i);
X					/* display the name in bold */
X	clear_line(win, 2, 39, FALSE);
X	wrefresh(win);
X	mvwattrstr(win, 2, 39, A_BOLD, modem->mname[i]);
X	mvwprintw(win, 2, 25, "(%d of %d) ", i+1, modem->m_entries);
X
X	return(i);
X}
X
X/*
X * Show the current settings for the given modem entry number.
X */
X
Xstatic void
Xdisp_modem(w, i)
XWINDOW *w;
Xint i;
X{
X	mvwprintw(w, 2, 11, "1) Modem name ............. %-39.39s", modem->mname[i]);
X	mvwprintw(w, 2, 25, "(%d of %d) ", i+1, modem->m_entries);
X	mvwprintw(w, 3, 11, "2) Modem init string ...... %-39.39s", modem->init[i]);
X	mvwprintw(w, 4, 11, "3) Dialing command ........ %-39.39s", modem->dial[i]);
X	mvwprintw(w, 5, 11, "4) Dialing cmd suffix ..... %-39.39s", modem->suffix[i]);
X	mvwprintw(w, 6, 11, "5) Hang up string ......... %-39.39s", modem->hang_up[i]);
X	mvwprintw(w, 7, 11, "6) Auto baud detect ....... %c", modem->auto_baud[i]);
X	mvwprintw(w, 8, 11, "7) 300 baud connect ....... %-39.39s", modem->con_3[i]);
X	mvwprintw(w, 9, 11, "8) 1200 baud connect ...... %-39.39s", modem->con_12[i]);
X	mvwprintw(w, 10, 11, "9) 2400 baud connect ...... %-39.39s", modem->con_24[i]);
X	mvwprintw(w, 11, 10, "10) 4800 baud connect ...... %-39.39s", modem->con_48[i]);
X	mvwprintw(w, 12, 10, "11) 9600 baud connect ...... %-39.39s", modem->con_96[i]);
X	mvwprintw(w, 13, 10, "12) 19200 baud connect ..... %-39.39s", modem->con_192[i]);
X	mvwprintw(w, 14, 10, "13) No connect string 1 .... %-39.39s", modem->no_con1[i]);
X	mvwprintw(w, 15, 10, "14) No connect string 2 .... %-39.39s", modem->no_con2[i]);
X	mvwprintw(w, 16, 10, "15) No connect string 3 .... %-39.39s", modem->no_con3[i]);
X	mvwprintw(w, 17, 10, "16) No connect string 4 .... %-39.39s", modem->no_con4[i]);
X	return;
X}
SHAR_EOF
if test 6656 -ne "`wc -c < 's_modem.c'`"
then
	echo shar: "error transmitting 's_modem.c'" '(should have been 6656 characters)'
fi
fi
echo shar: "extracting 's_prompt.c'" '(3089 characters)'
if test -f 's_prompt.c'
then
	echo shar: "will not over-write existing file 's_prompt.c'"
else
sed 's/^X//' << \SHAR_EOF > 's_prompt.c'
X/*
X * Prompting routines used in the setup menus.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "misc.h"
X
X/*
X * Prompt for a string at line 21 (with optional line 22 for additional
X * information).  Display the new string in bold at its original location
X * in the menu.  Used in virtually all of the *_setup() routines.  Since
X * it uses get_str(), the return value points to a static area.
X */
X
Xchar *
Xstr_prompt(win, y, x, p1, p2)
XWINDOW *win;
Xint y, x;
Xchar *p1, *p2;
X{
X	extern char *null_ptr;
X	char *ans, *get_str();
X					/* print first prompt last */
X	mvwaddstr(win, 22, 0, p2);
X	mvwaddstr(win, 21, 0, p1);
X	waddstr(win, ": ");
X	wrefresh(win);
X
X	if ((ans = get_str(win, 80, "", "\n")) == NULL)
X		return(NULL);
X					/* check the value */
X	if (!strcmp(ans, " "))
X		ans = null_ptr;
X					/* display the value in bold */
X	clear_line(win, y, x, FALSE);
X	wattrstr(win, A_BOLD, ans);
X
X	return(ans);
X}
X
X/*
X * Same as above, except we return a single character.
X */
X
Xchar
Xchr_prompt(win, y, x, p1, p2)
XWINDOW *win;
Xint y, x;
Xchar *p1, *p2;
X{
X	char *ans, *get_str();
X					/* print first prompt last */
X	mvwaddstr(win, 22, 0, p2);
X	mvwaddstr(win, 21, 0, p1);
X	waddstr(win, ": ");
X	wrefresh(win);
X
X	if ((ans = get_str(win, 1, "", "\n")) == NULL)
X		return('\0');
X					/* display the value in bold */
X	mvwaddstr(win, y, x, "  ");
X	wrefresh(win);
X	mvwattrstr(win, y, x, A_BOLD, ans);
X
X	return(*ans);
X}
X
X/*
X * Same as above, except that it prompts for a three digit number.
X */
X
Xint
Xnum_prompt(win, y, x, p1, p2)
XWINDOW *win;
Xint y, x;
Xchar *p1, *p2;
X{
X	int i;
X					/* print first prompt last */
X	mvwaddstr(win, 22, 0, p2);
X	mvwaddstr(win, 21, 0, p1);
X	waddstr(win, ": ");
X	wrefresh(win);
X
X	if ((i = get_num(win, 3)) == -1)
X		return(-1);
X					/* display the value in bold */
X	mvwaddstr(win, y, x, "    ");
X	wrefresh(win);
X	mvwattrnum(win, y, x, A_BOLD, i);
X					/* return the number */
X	return(i);
X}
X
X/*
X * Prompts for a selection from a menu.  We display the prompt lines,
X * and show the choices one at a time.  The user selects the currently
X * showing choice by hitting a carriage return.  Unlike the similar
X * routines in d_prompt(), the first choice shown is not necessarily
X * the current.
X */
X
Xchar *v_yes[3] = {"YES", "NO", NULL};
Xchar *v_yn[3] = {"Y", "N", NULL};
X
Xchar *
Xmenu_prompt(win, y, x, p, menu)
XWINDOW *win;
Xint y, x;
Xchar *p, *menu[];
X{
X	char ans;
X	int i, cy, cx;
X					/* print first prompt last */
X	mvwaddstr(win, 22, 0, "Press any key to change, or <CR> to accept");
X	mvwaddstr(win, 21, 0, p);
X	waddstr(win, ": ");
X					/* show first choice */
X	i = 0;
X	getyx(win, cy, cx);
X	mvwprintw(win, cy, cx, "%-30.30s", menu[i]);
X	wmove(win, cy, cx);
X	wrefresh(win);
X					/* show the choices one at a time */
X	while ((ans = wgetch(win)) != '\r') {
X		i++;
X		if (menu[i] == NULL)
X			i = 0;
X		if (ans == ESC)
X			return(NULL);
X		mvwprintw(win, cy, cx, "%-30.30s", menu[i]);
X		wmove(win, cy, cx);
X		wrefresh(win);
X	}
X					/* display the value in bold */
X	clear_line(win, y, x, FALSE);
X	wattrstr(win, A_BOLD, menu[i]);
X					/* return the value */
X	return(menu[i]);
X}
SHAR_EOF
if test 3089 -ne "`wc -c < 's_prompt.c'`"
then
	echo shar: "error transmitting 's_prompt.c'" '(should have been 3089 characters)'
fi
fi
echo shar: "extracting 's_term.c'" '(3046 characters)'
if test -f 's_term.c'
then
	echo shar: "will not over-write existing file 's_term.c'"
else
sed 's/^X//' << \SHAR_EOF > 's_term.c'
X/*
X * Display the terminal setup, query for changes.  A return code of 1
X * means something was changed, 2 means we have to kill and restart
X * the input routine.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "misc.h"
X#include "param.h"
X#include "status.h"
X
Xint
Xterm_setup()
X{
X	WINDOW *t_win, *newwin();
X	int i, num, ret_code;
X	char *ans, *str_rep(), *str_prompt(), *menu_prompt();
X	void input_off(), line_set();
X	static char *v_crio[3] = {"CR", "CR/LF", NULL};
X	static char *v_duplex[3] = {"FULL", "HALF", NULL};
X	static char *v_flow[3] = {"NONE", "XON/XOFF", NULL};
X
X	t_win = newwin(23, 80, 0, 0);
X
X	horizontal(t_win, 0, 0, 32);
X	mvwattrstr(t_win, 0, 33, A_BOLD, "Terminal Setup");
X	horizontal(t_win, 0, 48, 32);
X	mvwprintw(t_win, 4, 22, "1) Hot key (decimal) ...... %d", param->hot);
X	mvwprintw(t_win, 6, 22, "2) ASCII version of hot ... %s", param->ascii_hot);
X	mvwprintw(t_win, 9, 22, "3) Duplex ................. %s", param->d_duplex);
X	mvwprintw(t_win, 11, 22, "4) Flow control ........... %s", param->flow);
X	mvwprintw(t_win, 13, 22, "5) CR translation (in) .... %s", param->cr_in);
X	mvwprintw(t_win, 15, 22, "6) CR translation (out) ... %s", param->cr_out);
X	horizontal(t_win, 19, 0, 80);
X	mvwattrstr(t_win, 20, 0, A_BOLD, "OPTION ==> ");
X	mvwaddstr(t_win, 20, 58, "Press <ESC> to return");
X	wmove(t_win, 20, 12);
X	touchwin(t_win);
X	wrefresh(t_win);
X					/* get the option number */
X	ret_code = 0;
X	while ((i = get_num(t_win, 1)) != -1) {
X		switch (i) {
X			case 1:
X				if ((num = num_prompt(t_win, 4, 50, "Hot key", "decimal code for the hot key")) != -1) {
X					param->hot = num;
X					ret_code = 1;
X				}
X				break;
X			case 2:
X				if ((ans = str_prompt(t_win, 6, 50, "ASCII version of hot key", "(printable version)")) != NULL) {
X					param->ascii_hot = str_rep(param->ascii_hot, ans);
X					ret_code = 1;
X				}
X				break;
X			case 3:
X				if ((ans = menu_prompt(t_win, 9, 50, "Duplex", v_duplex)) != NULL) {
X					param->d_duplex = str_rep(param->d_duplex, ans);
X					ret_code = 1;
X				}
X				break;
X			case 4:
X				if ((ans = menu_prompt(t_win, 11, 50, "Flow control", v_flow)) != NULL) {
X					param->flow = str_rep(param->flow, ans);
X					line_set();
X					ret_code = 1;
X				}
X				break;
X			case 5:
X				if ((ans = menu_prompt(t_win, 13, 50, "CR translation (in)", v_crio)) != NULL) {
X
X					/*
X					 * the "add lf to cr" function is
X					 * performed by the input routine
X					 */
X					param->cr_in = str_rep(param->cr_in, ans);
X					status->add_lf = !strcmp(ans, "CR/LF");
X#ifdef SHAREDMEM
X					ret_code = 1;
X#else /* SHAREDMEM */
X					input_off();
X					ret_code = 2;
X#endif /* SHAREDMEM */
X				}
X				break;
X			case 6:
X				if ((ans = menu_prompt(t_win, 15, 50, "CR translation (out)", v_crio)) != NULL) {
X					param->cr_out = str_rep(param->cr_out, ans);
X					ret_code = 1;
X				}
X				break;
X			default:
X				beep();
X		}
X		mvwaddch(t_win, 20, 12, (chtype) ' ');
X		clear_line(t_win, 21, 0, FALSE);
X		clear_line(t_win, 22, 0, FALSE);
X		wmove(t_win, 20, 12);
X		wrefresh(t_win);
X	}
X	delwin(t_win);
X	return(ret_code);
X}
SHAR_EOF
if test 3046 -ne "`wc -c < 's_term.c'`"
then
	echo shar: "error transmitting 's_term.c'" '(should have been 3046 characters)'
fi
fi
echo shar: "extracting 's_tty.c'" '(4903 characters)'
if test -f 's_tty.c'
then
	echo shar: "will not over-write existing file 's_tty.c'"
else
sed 's/^X//' << \SHAR_EOF > 's_tty.c'
X/*
X * Display the TTY setup, query for changes.  A non-zero return code
X * means something was changed.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "misc.h"
X#include "modem.h"
X
Xint
Xtty_setup()
X{
X	WINDOW *tt_win, *newwin();
X	char message[80], *str, *get_str();
X	int num, i, j, ret_code;
X	void disp_tty(), create_modem(), del_modem(), error_win();
X	void del_tty();
X
X	tt_win = newwin(23, 80, 0, 0);
X
X	horizontal(tt_win, 0, 0, 34);
X	mvwattrstr(tt_win, 0, 35, A_BOLD, "TTY Setup");
X	horizontal(tt_win, 0, 45, 34);
X	mvwaddstr(tt_win, 2, 22, "TTY name");
X	mvwaddstr(tt_win, 2, 37, "Modem name");
X	mvwaddstr(tt_win, 2, 51, "Init speed");
X					/* display the current TTY list */
X	disp_tty(tt_win);
X					/* prompt for options */
X	mvwaddstr(tt_win, 15, 20, "A) Add a TTY entry");
X	mvwaddstr(tt_win, 16, 20, "D) Delete a TTY entry");
X	horizontal(tt_win, 19, 0, 80);
X	mvwattrstr(tt_win, 20, 0, A_BOLD, "OPTION ==> ");
X	mvwaddstr(tt_win, 20, 58, "Press <ESC> to return");
X	wmove(tt_win, 20, 12);
X	touchwin(tt_win);
X	wrefresh(tt_win);
X					/* get the option */
X	ret_code = 0;
X	while ((str = get_str(tt_win, 2, "01234356789AaDd", "")) != NULL) {
X		switch(*str) {
X			case '0':
X			case '1':
X			case '2':
X			case '3':
X			case '4':
X			case '5':
X			case '6':
X			case '7':
X			case '8':
X			case '9':
X				i = atoi(str);
X					/* if beyond t_entries */
X				if (i > modem->t_entries) {
X					beep();
X					break;
X				}
X
X					/* change the entry  */
X				if (tty_prompt(tt_win, i-1)) {
X
X					/* requires modem update? */
X					create_modem(modem->tname[i-1]);
X					del_modem();
X					ret_code++;
X				}
X				break;
X			case 'a':
X			case 'A':	/* add an entry */
X				if (modem->t_entries == NUM_TTY) {
X					sprintf(message, "\"%s\"", modem->m_path);
X					error_win(0, "No empty TTY slots in modem/TTY database", message);
X					break;
X				}
X					/* prompt for info */
X				j = modem->t_entries;
X				if (tty_prompt(tt_win, j)) {
X
X					/* add modem entry? */
X					modem->t_entries++;
X					create_modem(modem->tname[j]);
X					ret_code++;
X				}
X				break;
X			case 'd':
X			case 'D':	/* delete an entry */
X				mvwaddstr(tt_win, 21, 0, "Entry number to delete: ");
X				wrefresh(tt_win);
X				while ((num = get_num(tt_win, 4)) != -1) {
X					/* valid range */
X					if (!num || num>modem->t_entries) {
X						beep();
X						mvwaddstr(tt_win, 21, 24, "   ");
X						wmove(tt_win, 21, 24);
X						wrefresh(tt_win);
X						continue;
X					}
X					del_tty(num-1);
X					del_modem();
X
X					/* show the new list */
X					disp_tty(tt_win);
X					ret_code++;
X					break;
X				}
X				break;
X			default:
X				beep();
X				break;
X		}
X		mvwaddstr(tt_win, 20, 12, "  ");
X		clear_line(tt_win, 21, 0, FALSE);
X		clear_line(tt_win, 22, 0, FALSE);
X		wmove(tt_win, 20, 12);
X		wrefresh(tt_win);
X	}
X	delwin(tt_win);
X	return(ret_code);
X}
X
X/*
X * Display the current TTY list.  No scrolling yet, so if your NUM_TTY is
X * greater than ten, this routine will need some work.
X */
X
Xstatic void
Xdisp_tty(win)
XWINDOW *win;
X{
X	int i;
X
X	for (i=0; i<NUM_TTY; i++)
X		mvwprintw(win, i+4, 20, "%2d) %-14.14s %-14.14s  %d\n",
X		 i+1, modem->tty[i], modem->tname[i], modem->init_sp[i]);
X	return;
X}
X
X/*
X * Prompt the user for the TTY database info.  A non-zero return code means
X * something was changed.  The second argument is the zero based index.
X */
X
Xstatic int
Xtty_prompt(win, i)
XWINDOW *win;
Xint i;
X{
X	char *ans, t_tty[80], t_tname[80], *str_prompt(), *menu_prompt();
X	char *str_rep(), *strcpy();
X	static char *v_baud[8] = {"0", "300", "1200", "2400", "4800", "9600",
X	 "19200", NULL};
X					/* get temp TTY */
X	if ((ans = str_prompt(win, i+4, 24, "TTY name", "")) == NULL)
X		return(0);
X
X	strcpy(t_tty, ans);
X	clear_line(win, 21, 0, FALSE);
X
X					/* get temp tname */
X	if ((ans = str_prompt(win, i+4, 39, "Modem name", "")) == NULL)
X		return(0);
X
X	strcpy(t_tname, ans);
X	clear_line(win, 21, 0, FALSE);
X
X					/* get maximum baud */
X	if ((ans = menu_prompt(win, i+4, 55, "Init speed", v_baud)) == NULL)
X		return(0);
X
X	wrefresh(win);
X					/* store 'em for real */
X	modem->tty[i] = str_rep(modem->tty[i], t_tty);
X	modem->tname[i] = str_rep(modem->tname[i], t_tname);
X	modem->init_sp[i] = atoi(ans);
X
X	return(1);
X}
X
X/*
X * Delete a TTY entry.  Since the list must be contiguous, we collapse the
X * list to cover the hole we made.
X */
X
Xstatic void
Xdel_tty(i)
Xint i;
X{
X	extern char *null_ptr;
X	int j;
X	char *str_rep();
X	void free_ptr();
X					/* collapse the list */
X	for (j=i; j<modem->t_entries-1; j++) {
X		modem->tty[j] = str_rep(modem->tty[j], modem->tty[j+1]);
X		modem->tname[j] = str_rep(modem->tname[j], modem->tname[j+1]);
X		modem->init_sp[j] = modem->init_sp[j+1];
X	}
X	j = modem->t_entries-1;
X					/* zap the entry */
X	free_ptr(modem->tty[j]);
X	free_ptr(modem->tname[j]);
X	modem->tty[j] = null_ptr;
X	modem->tname[j] = null_ptr;
X	modem->init_sp[j] = 0;
X					/* update the count */
X	modem->t_entries--;
X	if (modem->t_cur >= modem->t_entries)
X		modem->t_cur = -1;
X	return;
X}
SHAR_EOF
if test 4903 -ne "`wc -c < 's_tty.c'`"
then
	echo shar: "error transmitting 's_tty.c'" '(should have been 4903 characters)'
fi
fi
echo shar: "extracting 'screen.c'" '(2024 characters)'
if test -f 'screen.c'
then
	echo shar: "will not over-write existing file 'screen.c'"
else
sed 's/^X//' << \SHAR_EOF > 'screen.c'
X/*
X * Routines to read and copy the virtual screen image file.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "param.h"
X#include "status.h"
X
X/*
X * Do a screen dump.  Actually, the screen is already dumped, all we
X * do is copy the file.
X */
X
Xvoid
Xscreen_dump()
X{
X	FILE *fp_in, *fp_out, *my_fopen();
X	char buf[MAX_COL];
X	void error_win();
X	int i;
X					/* open for append */
X	if (!(fp_out = my_fopen(param->dumpfile, "a"))) {
X		sprintf(buf, "\"%s\" for write", param->dumpfile);
X		error_win(0, "Can't open screen dump file", buf);
X		return;
X	}
X#ifdef SHAREDMEM
X	for (i=0; i<LINES; i++)
X		fprintf(fp_out, "%s\n", status->vs[i]);
X
X#else /* SHAREDMEM */
X					/* not guaranteed to exist yet */
X	if (!(fp_in = my_fopen(status->vs_path, "r"))) {
X		fclose(fp_in);
X		return;
X	}
X					/* skip the x, y coordinates */
X	fgets(buf, 10, fp_in);
X
X	while (fgets(buf, MAX_COL, fp_in) != NULL)
X		fputs(buf, fp_out);
X
X	fclose(fp_in);
X#endif /* SHAREDMEM */
X
X	fclose(fp_out);
X
X	return;
X}
X
X/*
X * Read the virtual screen and paint its contents to the stdscr using
X * curses(3).  Move the cursor where it belongs.
X */
X
Xvoid
Xload_vs()
X{
X	register int i;
X	FILE *fp, *my_fopen();
X	int row, col, max_col;
X	char buf[MAX_COL];
X
X	clearok(curscr, TRUE);
X	erase();
X
X#ifdef SHAREDMEM
X	for (i=0; i<LINES; i++)
X		mvaddstr(i, 0, status->vs[i]);
X
X	move(status->row, status->col);
X#else /* SHAREDMEM */
X					/* not guaranteed to exist yet */
X	if (!(fp = my_fopen(status->vs_path, "r")))
X		return;
X					/* get the x, y coordinates */
X	fgets(buf, 10, fp);
X	sscanf(buf, "%d,%d\n", &row, &col);
X
X	i = 0;
X	max_col = (COLS > MAX_COL-1) ? MAX_COL-1 : COLS;
X	while (fgets(buf, MAX_COL, fp) != NULL) {
X					/* zap the line feed */
X		buf[max_col] = '\0';
X		mvaddstr(i++, 0, buf);
X	}
X	fclose(fp);
X	move(row, col);
X#endif /* SHAREDMEM */
X
X	refresh();
X	return;
X}
X
X/*
X * Zap the virtual screen file (or clear it).
X */
X
Xvoid
Xzap_vs()
X{
X#ifdef SHAREDMEM
X	status->clr = 1;
X#else /* SHAREDMEM */
X	unlink(status->vs_path);
X#endif /* SHAREDMEM */
X	return;
X}
SHAR_EOF
if test 2024 -ne "`wc -c < 'screen.c'`"
then
	echo shar: "error transmitting 'screen.c'" '(should have been 2024 characters)'
fi
fi
echo shar: "extracting 'script.c'" '(3790 characters)'
if test -f 'script.c'
then
	echo shar: "will not over-write existing file 'script.c'"
else
sed 's/^X//' << \SHAR_EOF > 'script.c'
X/*
X * Spawn a shell with file descriptors that look like this:
X *
X *              +---------+
X *   TTYin ---> | input   | ---> screen (& virtual screen)
X *              | program |
X *              +---------+
X *                   |                     +---------+
X *                  pipe ----------> stdin |         |
X *                                         |  shell  |
X *   TTYout <---------------------- stdout |         |
X *                                         +---------+
X *
X * The input program has a routine that duplicates the TTYin and sends it
X * down a pipe.  The other end of the pipe is the stdin to the shell script.
X * This allows the characters to appear on the screen *and* be interpreted
X * by the shell script.
X */
X
X#include <stdio.h>
X#include <signal.h>
X#include <curses.h>
X#include <errno.h>
X#include "config.h"
X#include "dial_dir.h"
X#include "status.h"
X
X#ifdef BSD
X#include <sys/file.h>
X#else /* BSD */
X#include <fcntl.h>
X#endif /* BSD */
X
Xvoid
Xdo_script(extra)
Xchar *extra;
X{
X	extern int fd, errno;
X	SIG_TYPE (*istat)(), (*qstat)();
X	int epid, dup_pipe[2], want_out, sig_status;
X	char buf[80], *ttyname(), *strcpy(), *path, *findfile();
X	void _exit(), error_win(), input_off(), do_input();
X	unsigned int sleep();
X
X					/* if empty */
X	if (*dir->script[dir->d_cur] == '\0')
X		return;
X					/* if a device */
X	if (chk_script(dir->script[dir->d_cur]))
X		return;
X					/* find the script file */
X	if ((path = findfile(extra, dir->script[dir->d_cur])) == NULL) {
X		sprintf(buf, "Can't locate script \"%s\"", dir->script[dir->d_cur]);
X		error_win(0, buf, "");
X		return;
X	}
X					/* execute permission ? */
X	if (access(path, 1)) {
X		sprintf(buf, "\"%s\"", path);
X		error_win(0, "No execute permission on script file", buf);
X		return;
X	}
X					/* create a fd for duplicating input */
X	if (pipe(dup_pipe) < 0)
X		return;
X
X	status->dup_fd = dup_pipe[1];
X					/* start input duplication */
X	do_input();
X
X	if (!(epid = fork())) {
X					/* create a new process group ID */
X#ifdef BSD
X		setpgrp(0, getpid());
X#else /* BSD */
X		setpgrp();
X#endif /* BSD */
X					/* recreate the device name */
X		strcpy(buf, ttyname(fd));
X		close(fd);
X					/* swap the stdin */
X		close(0);
X		dup(dup_pipe[0]);
X					/* swap the stdout */
X		close(1);
X#ifdef UNIXPC
X/*
X * Some strange things here... The OBM uses the second parameter of 
X * open() to determine if the the port should be in the DATA mode or
X * the VOICE mode.  Therefore, we must always open with read and write.
X */
X		if (!strncmp(buf, "/dev/ph", 7))
X			open(buf, O_RDWR);
X		else
X#endif /* UNIXPC */
X
X		open(buf, O_WRONLY);
X#ifdef SETUGID
X		setgid(getgid());
X		setuid(getuid());
X#endif /* SETUGID */
X
X		execl("/bin/sh", "sh", "-c", path, (char *) 0);
X		_exit(1);
X	}
X	istat = signal(SIGINT, SIG_IGN);
X	qstat = signal(SIGQUIT, SIG_IGN);
X
X	/*
X	 * Check the keyboard while the script is being "played".  If the
X	 * user hits the <ESC> key, then kill the entire process group
X	 * associated with the new shell.
X	 */
X	want_out = 0;
X	while(1) {
X		switch(wait_key(stdscr, 1)) {
X			case -1:	/* timed out */
X				break;
X			case 27:	/* a user abort */
X#ifdef BSD
X				killpg(epid, SIGKILL);
X#else /* BSD */
X				kill(-epid, SIGKILL);
X#endif /* BSD */
X				want_out++;
X				break;
X			default:
X				beep();
X				break;
X		}
X		if (want_out)
X			break;
X					/* see if the process it still active */
X#ifdef BSD
X		if ((kill(epid, 0) == -1) && errno == ESRCH) 
X#else /* BSD */
X		if ((kill(-epid, 0) == -1) && errno == ESRCH) 
X#endif /* BSD */
X			break;
X	}
X					/* wait for the zombie process */
X	wait(&sig_status);
X
X	signal(SIGINT, istat);
X	signal(SIGQUIT, qstat);
X					/* shut down the duplication of input */
X	status->dup_fd = -1;
X
X#ifndef SHAREDMEM
X	input_off();
X#endif /* SHAREDMEM */
X
X	close(dup_pipe[0]);
X	close(dup_pipe[1]);
X	sleep(1);
X	beep();
X	return;
X}
SHAR_EOF
if test 3790 -ne "`wc -c < 'script.c'`"
then
	echo shar: "error transmitting 'script.c'" '(should have been 3790 characters)'
fi
fi
echo shar: "extracting 'st_line.c'" '(2103 characters)'
if test -f 'st_line.c'
then
	echo shar: "will not over-write existing file 'st_line.c'"
else
sed 's/^X//' << \SHAR_EOF > 'st_line.c'
X/*
X * Display the status line.  Up to now, we've never really cared how
X * large the physical screen was... but now we want the status line
X * on the bottom.
X */
X
X#include <curses.h>
X#include "config.h"
X#include "dial_dir.h"
X#include "misc.h"
X#include "modem.h"
X#include "param.h"
X#include "status.h"
X
Xvoid
Xst_line(message)
Xchar *message;
X{
X	extern int xmc;
X	WINDOW *sl_win, *newwin();
X	int d, x, y;
X	static char *dn[2] = {"FDX", "HDX"};
X	static char *ln[2] = {"LOG OFF", "LOG ON"};
X	static char *pn[2] = {"PTR OFF", "PTR ON "};
X	char buf[80], field_one[15], *cur_tty;
X
X					/* is anybody missing? */
X	if (dir == NULL || modem == NULL || param == NULL)
X		return;
X					/* remember where we parked the car.. */
X	getyx(stdscr, y, x);
X
X	sl_win = newwin(1, 80, LINES-1, 0);
X					/* duplex message */
X	d = 0;
X	if (dir->duplex[dir->d_cur] == 'H')
X		d++;
X					/* the current TTY */
X	cur_tty = "No TTY";
X	if (modem->t_cur != -1)
X		cur_tty = modem->tty[modem->t_cur];
X
X	/*
X	 * The philosophy is:  If you press a command sequence that
X	 * doesn't generate a window on the screen, then show the user
X	 * what's going on in the status line.
X	 */
X	if (*message == '\0')
X		sprintf(field_one, " %4.4s-0 HELP  ", param->ascii_hot);
X	else
X		sprintf(field_one, " %-13.13s", message);
X
X#ifdef XMC_BROKE
X	if (xmc > 0)
X		sprintf(buf, "%s | %-9.9s| %s | %5d %c%d%d | %-7.7s | %-7.7s | %-5.5s|%-5.5s",
X		 field_one, cur_tty, dn[d], dir->baud[dir->d_cur],
X		 dir->parity[dir->d_cur], dir->dbits[dir->d_cur],
X		 dir->sbits[dir->d_cur], ln[status->log], pn[status->print],
X		 param->cr_in, param->cr_out);
X	else
X#endif /* XMC_BROKE */
X		sprintf(buf, "%s | %-9.9s| %s | %5d %c%d%d | %-7.7s | %-7.7s | %-5.5s| %-5.5s",
X		 field_one, cur_tty, dn[d], dir->baud[dir->d_cur],
X		 dir->parity[dir->d_cur], dir->dbits[dir->d_cur],
X		 dir->sbits[dir->d_cur], ln[status->log], pn[status->print],
X		 param->cr_in, param->cr_out);
X
X	if (xmc > 0) {
X		touchwin(sl_win);
X		werase(sl_win);
X		wrefresh(sl_win);
X	}
X	wattrstr(sl_win, A_STANDOUT, buf);
X	wrefresh(sl_win);
X					/* go ahead and delete it now */
X	delwin(sl_win);
X	move(y, x);
X	return;
X}
SHAR_EOF
if test 2103 -ne "`wc -c < 'st_line.c'`"
then
	echo shar: "error transmitting 'st_line.c'" '(should have been 2103 characters)'
fi
fi
echo shar: "extracting 'status.h'" '(808 characters)'
if test -f 'status.h'
then
	echo shar: "will not over-write existing file 'status.h'"
else
sed 's/^X//' << \SHAR_EOF > 'status.h'
X/*
X * The status flags, and other various changeable things.  Obviously
X * the "config.h" file must appear before this file.
X */
X
X#define MAX_ROW		64
X#define MAX_COL		133
X#define PATH		128
X
Xstruct STATUS {
X	int	fd;			/* file descriptor for TTY */
X	int	dup_fd;			/* for duplicating input */
X	int	add_lf;			/* add <CR> to <LF>? */
X	int	log;			/* status of log option */
X	int	print;			/* status of print option */
X	char	log_path[PATH];		/* data logging file */
X#ifdef SHAREDMEM
X	int	clr;			/* flag to clear the screen */
X	int	row;			/* cursor row position */
X	int	col;			/* cursor column position */
X	char	vs[MAX_ROW][MAX_COL];	/* the virtual screen */
X#else /* SHAREDMEM */
X	char	vs_path[PATH];		/* virtual screen file */
X#endif /* SHAREDMEM */
X};
X
X#ifndef MAIN
Xextern struct STATUS *status;
X#endif /* MAIN */
SHAR_EOF
if test 808 -ne "`wc -c < 'status.h'`"
then
	echo shar: "error transmitting 'status.h'" '(should have been 808 characters)'
fi
fi
echo shar: "extracting 'strings.c'" '(4200 characters)'
if test -f 'strings.c'
then
	echo shar: "will not over-write existing file 'strings.c'"
else
sed 's/^X//' << \SHAR_EOF > 'strings.c'
X/*
X * Miscellaneous string routines.
X */
X
X#define STRSTR
X
X#include <stdio.h>
X#include "config.h"
X
X/*
X * Do a fancy string copy.  If NULL, return null.  If pointer to NULL, then
X * return the special "null_ptr" variable.  If a normal copy, allocate
X * memory first.
X */
X
Xchar *
Xstr_dup(str)
Xchar *str;
X{
X	extern char *null_ptr;
X	char *ret, *malloc(), *strcpy();
X	void error_win();
X
X	if (str == NULL)
X		return(NULL);
X					/* if pointer to null */
X	if (*str == '\0')
X		return(null_ptr);
X
X	if (!(ret = malloc((unsigned int) strlen(str)+1)))
X		error_win(1, "Out of memory", "");
X
X	strcpy(ret, str);
X	return(ret);
X}
X
X/*
X * Perform the free(2) function, but check for NULL and the special
X * "null_ptr" variable first.
X */
X
Xvoid
Xfree_ptr(str)
Xchar *str;
X{
X	extern char *null_ptr;
X	void free();
X
X	if (str != NULL && str != null_ptr)
X		free(str);
X	return;
X}
X
X/*
X * Replace a string.  Follows the same convention as str_dup(), except
X * that realloc() is used instead of malloc().  Returns a pointer to
X * the new string (which may have moved).
X */
X
Xchar *
Xstr_rep(s1, s2)
Xchar *s1, *s2;
X{
X	extern char *null_ptr;
X	void free_ptr(), error_win();
X	char *s, *malloc(), *realloc(), *strcpy();
X
X					/* copy null pointer ? */
X	if (s2 == NULL) {
X		free_ptr(s1);
X		return(NULL);
X	}
X	if (s2 == '\0') {
X		free_ptr(s1);
X		return(null_ptr);
X	}
X					/* use realloc()? */
X	if (s1 == NULL || s1 == null_ptr) {
X		if (!(s = malloc((unsigned int) strlen(s2)+1)))
X			error_win(1, "Out of memory", "");
X	}
X	else {
X		if (!(s = realloc(s1, (unsigned int) strlen(s2)+1)))
X			error_win(1, "Out of memory", "");
X	}
X
X	strcpy(s, s2);
X	return(s);
X}
X
X/*
X * This routine is similar to strtok(3).  But this version handles missing
X * tokens by returning a pointer to null.  Also it takes a single separator
X * character as an argument.  Returns a NULL on end of string or error.
X */
X
Xchar *
Xstr_tok(str, c)
Xchar *str, c;
X{
X	char *strchr();
X	static char *ptr, *sep;
X					/* start at beginning */
X	if (str != NULL)
X		ptr = str;
X	else
X		ptr = sep;
X					/* at the end? */
X	if (*ptr == '\0')
X		return(NULL);
X					/* no separator? */
X	if (!(sep = strchr(ptr, c)))
X		return(NULL);
X					/* zap the sep, move past it */
X	*sep = '\0';
X	sep++;
X
X	return(ptr);
X}
X
X#ifdef STRSTR
X/*
X * Return a pointer to the first occurance of string str2 in str1.
X * Returns a NULL if str2 is not in str1.
X */
X
Xchar *
Xstrstr(str1, str2)
Xchar *str1, *str2;
X{
X	int len;
X
X	len = strlen(str2);
X	while (*str1) {
X		if (*str2 == *str1) {
X			if (!strncmp(str2, str1, len))
X				return(str1);
X		}
X		str1++;
X	}
X	return(NULL);
X}
X#endif /* STRSTR */
X
X#ifdef BSD
X/*
X * Returns the length of the initial segment of string which consists
X * entirely of characters from charset.
X */
X
Xint
Xstrspn(string, charset)
Xchar	*string;
Xregister char	*charset;
X{
X	register char *p, *q;
X
X	for(q=string; *q != '\0'; ++q) {
X		for(p=charset; *p != '\0' && *p != *q; ++p)
X			;
X		if(*p == '\0')
X			break;
X	}
X	return(q-string);
X}
X
X/*
X * Strtok considers string to consist of a sequence of zero or more
X * text tokens separated by spans of one or more characters from sepset.
X */
X
Xchar *
Xstrtok(string, sepset)
Xchar	*string, *sepset;
X{
X	register char	*p, *q, *r;
X	static char	*savept;
X	char *strpbrk();
X
X	/*first or subsequent call*/
X	p = (string == NULL)? savept: string;
X
X	if(p == 0)		/* return if no tokens remaining */
X		return(NULL);
X
X	q = p + strspn(p, sepset);	/* skip leading separators */
X
X	if(*q == '\0')		/* return if no tokens remaining */
X		return(NULL);
X
X	if((r = strpbrk(q, sepset)) == NULL)	/* move past token */
X		savept = 0;	/* indicate this is last token */
X	else {
X		*r = '\0';
X		savept = ++r;
X	}
X	return(q);
X}
X
X/*
X * Return ptr to first occurrence of any character from `brkset'
X * in the character string `string'; NULL if none exists.
X */
X
Xchar *
Xstrpbrk(string, brkset)
Xregister char *string, *brkset;
X{
X	register char *p;
X
X	if(!string || !brkset)
X		return(0);
X	do {
X		for(p=brkset; *p != '\0' && *p != *string; ++p)
X			;
X		if(*p != '\0')
X			return(string);
X	}
X	while(*string++);
X	return(0);
X}
X
X/*
X * Copies the character c, n times to string s
X */
X
Xchar *
Xmemset(s, c, n)
Xchar *s, c;
Xint n;
X{
X	char *s1 = s;
X
X	while (n > 0) {
X		--n;
X		*s++ = c;
X	}
X	return(s1);
X}
X#endif /* BSD */
SHAR_EOF
if test 4200 -ne "`wc -c < 'strings.c'`"
then
	echo shar: "error transmitting 'strings.c'" '(should have been 4200 characters)'
fi
fi
exit 0
#	End of shell archive


