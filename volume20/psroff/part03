Subject:  v20i035:  Troff upgrade for PostScript, DiTroff compatibility, Part03/06
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Chris Lewis <eci386!clewis@uunet.uu.net>
Posting-number: Volume 20, Issue 35
Archive-name: psroff/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 6)."
# Contents:  Makefile cat.5 chartab.m dit2catwid.c fonts.lk ltest.m
#   psxlate.c showfont.sh troff2ps.1
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(3689 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#	Copyright 1985, 1986, 1987, 1988 Chris Lewis
X#		All Rights Reserved
X#
X#    Permission to copy and further distribute is freely given provided 
X#    this copyright notice remains intact and that this software is not 
X#    sold for profit.
X#
X#	Project:	Generic Troff drivers
X#	Module:		Makefile
X#	Author: 	Chris Lewis
X#	Specs:		Makefile for Generic Troff drivers
X#	Note:		This is a System V Makefile, so you may
X#			have some problems making a few of the items.
X#
X#ident  "@(#)Makefile: 1.33 Copyright 89/08/28 17:13:47 Chris Lewis"
X
X#	Set to where you want the user-interfaces to go
XINDIR	= /usr/lbin
X
X#	Command to send the output from troff2
X#	"rlp" is a local command for remote printing to an AppleLaser.
X#	You will undoubtibly have to change this for your printers.
X#	PLEASE NOTE: the print spooler you use *MUST* pass stuff
X#	through unmodified - eg: no tab expansion, must be 8 bit (LJ with
X#	font downloading - others should work with only 7 bit).
X#	If you add a driver, please add an xxOUTPUT here:
XPSOUTPUT	= | $(LIBDIR)/psxlate | rlp -dgate!AppleLaser -n$$copies
X#	System V'ish printing to printer called laser, with no filtering
XLJOUTPUT	= | lp -dlaser -og -n$$copies
X#	Ditroff output
XDTOUTPUT	= | /usr/lib/troff/tpscript | rlp -dgate!AppleLaser
X#	Testing type:
XTTYPE	= ps
X
X#	Libraries for Troff2 internals, created if it doesn't exist.
XLIBDIR	= /usr/lib/troff2
X
X#	nroff/troff macro directory
XTMACDIR	= /usr/lib/tmac
X#	Where should the manual pages go?
XMANDIR	= /usr/man/local/man1
X
X#	Comment this if you don't have shared libraries ala 386/ix
XLIBFLAGS = -lc_s
X
XINSTALL	=	$(LIBDIR)/troff2ps $(INDIR)/psroff $(LIBDIR)/psxlate \
X		$(TMACDIR)/tmac.t2 \
X		$(MANDIR)/psroff.1 \
X		$(MANDIR)/troff2ps.1 \
X		$(LIBDIR)/lib.lj  $(LIBDIR)/fonts.lj \
X		$(LIBDIR)/lib.lk $(LIBDIR)/fonts.lk \
X		$(LIBDIR)/lib.dt  $(LIBDIR)/fonts.dt \
X		$(LIBDIR)/lib.ps $(LIBDIR)/fonts.ps \
X		$(LIBDIR)/confid.ps $(LIBDIR)/lethead.ps
X
XDEFINES	= '-DLIBDIR="$(LIBDIR)"'
XCFLAGS	= $(DEFINES)
X
X.SUFFIXES: .ps .ps~ .lj .lj~ .1 .1~ .lk .lk~ .dt .dt~ .tst .prt .m .m~
X
X.lj~.lj:
X	$(GET) $(GFLAGS) $<
X
X.m.prt:
X	tbl $*.m | eqn | ./psroff -d$(TTYPE) -mt2 -
X
X.m.tst:
X	tbl $*.m | eqn | ./psroff -d$(TTYPE) -t -mt2 - > $*.tst
X
X.m~.m:
X	$(GET) $(GFLAGS) $<
X
X.dt~.dt:
X	$(GET) $(GFLAGS) $<
X
X.lk~.lk:
X	$(GET) $(GFLAGS) $<
X
X.1~.1:
X	$(GET) $(GFLAGS) $<
X
X.ps~.ps:
X	$(GET) $(GFLAGS) $<
X
XUTILLIST = troff2ps psroff psxlate tmac.t2 ltest.m chartab.m \
X	psroff.1 troff2ps.1 \
X	upload showfont \
X	lib.ps lib.lj lib.lk \
X	fonts.ps fonts.lj fonts.lk \
X	confid.ps lethead.ps
X
Xall:	$(UTILLIST)
X
Xchartab.tst ltest.tst: troff2ps
Xchartab.prt ltest.prt: troff2ps
X
Xchartab.tst ltest.tst: troff2ps
Xchartab.prt ltest.prt: troff2ps
X
Xprtall:	ltest.prt chartab.prt
Xtestall: ltest.tst chartab.tst
X
Xtroff2ps:	troff2.o utils.o t2conf.o lj.o ps.o lj.o ljtables.o dt.o
X	$(CC) $(CFLAGS) -o troff2ps troff2.o t2conf.o utils.o \
X		ps.o \
X		dt.o \
X		lj.o ljtables.o \
X		$(LIBFLAGS)
X
X#	Drivers include dependencies - add to this list if you're adding
X#	drivers.
Xt2conf.o:	defs.h ps.h lj.h dt.h
Xps.o:	defs.h ps.h
Xlj.o ljtables.o:	defs.h lj.h
Xdt.o:	defs.h dt.h
X
X#	Testing software:
Xtestps.o:	defs.h ps.h
X
Xtroff2.o utils.o: defs.h
X
Xinstall:	$(LIBDIR) $(TMACDIR) $(INSTALL) fonts
X
Xfonts:	dit2catwid gfnttab
X	su root -c "./gfnttab"
X
X$(INSTALL):	$$(@F)
X	su root -c "cp $(@F) $@"
X
X$(LIBDIR) $(TMACDIR):
X	su root -c "mkdir $@"
X
Xpsroff:	psroff.sh Makefile
X	sed -e 's;%%LJOUTPUT%%;$(LJOUTPUT);g' \
X	    -e 's;%%PSOUTPUT%%;$(PSOUTPUT);g' \
X	    -e 's;%%DTOUTPUT%%;$(DTOUTPUT);g' \
X	    -e 's;%%LIBDIR%%;$(LIBDIR);g' \
X	    psroff.sh > T
X	chmod 755 T
X	mv T psroff
X
Xdeinstall:
X	su root -c "rm -f $(INSTALL); rmdir $(LIBDIR)"
X
Xclean:
X	rm -f core *.o $(UTILLIST) ltest.troff
END_OF_FILE
if test 3689 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'cat.5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cat.5'\"
else
echo shar: Extracting \"'cat.5'\" \(5349 characters\)
sed "s/^X//" >'cat.5' <<'END_OF_FILE'
X.\"@(#)cat.5 1.3 89/04/21 11:48:42 (Henry Spencer)
X.TH CAT 5 local writeup
X.DA 4 April 1981
X.SH NAME
Xcat \- C/A/T phototypesetter code
X.SH DESCRIPTION
XThe Graphic Systems C/A/T phototypesetter is driven by sending it a
Xsequence of one-byte codes
Xwhich specify characters, fonts, sizes, and other control information.
X.PP
XThe C/A/T's basic unit of length is 1/432 of an inch (6 units to a
Xtypesetter's ``point'').
XThe quantum of horizontal motion is one unit.
XThe quantum of vertical motion is three units (1/144 of an inch, 1/2 point).
X.PP
XThe top two bits of the code classify it as one of three major
Xtypes:
Xan \fIescape\fR code (top bit 1),
Xa \fIflash\fR code (top bits 00),
Xor a control code (top bits 01).
XA code of all zeros is ignored;  a code of all ones is illegal.
X.PP
XA flash code specifies flashing one of 63 characters, as given by the
Xremaining six bits.
XSince this is not enough to specify all possible characters, or even
Xall characters in a single font \(em there are 108 per font \(em
Xvarious control codes (described later) select a font and either
Xthe Lower or Upper half of the font.
XThe Lower half is the first 63 characters of the font;  the Upper
Xhalf is the remaining 45.
XA flash code of 46 or higher in the Upper half is illegal.
X.PP
XAn escape code specifies horizontal motion.
XThe size of the motion, in horizontal quanta, is the one's-complement
Xof the low seven bits of the code.
XThe direction of the motion is set by control codes.
XHitting the right or left margin limit switch is illegal and will
Xcause the machine to stop.
XThe machine starts out, after initialization, hard against the left
Xmargin limit switch;  an initial escape of 16 units \fImust\fR
Xbe given before starting work, and the position after this motion
Xshould be the limit of all future leftward motions.
XFrom this point, the distance to the right margin limit switch
Xis about 7.5 inches.
X.PP
XA code with the top three bits 011 is a \fIlead\fR code,
Xspecifying vertical motion.
XThe remaining five bits are the one's-complement of the size of
Xthe motion, in vertical quanta.
XThe direction of motion is set by control codes.
XThe amount of vertical motion is, in principle, limited only by
Xrunning off the paper in the upward direction and by the limited
Xcapacity of the output cartridge in the downward direction.
X.PP
XA code with the top four bits 0101 is a size-change code, which
Xspecifies movement of the lens turret and the doubler lens to
Xchange point size.
XThese codes are as follows:
X.PP
X.RS
X.nf
X.ta 2c
XSize	Code
X
X6	0101\|1000
X7	0101\|0000
X8	0101\|0001
X9	0101\|0111
X10	0101\|0010
X11	0101\|0011
X12	0101\|0100
X14	0101\|0101
X16	0101\|1001
X18	0101\|0110
X20	0101\|1010
X22	0101\|1011
X24	0101\|1100
X28	0101\|1101
X36	0101\|1110
X.DT
X.fi
X.RE
X.PP
XSize changes involving the doubler lens alter the horizontal position.
XChanges from single to double sizes should be followed by a forward
Xescape of 55 quanta;  changes from double to single sizes should be
Xfollowed by a reverse escape of 55 quanta.
XThe single sizes are 6, 7, 8, 9, 10, 11, 12, 14, and 18;
Xthe double sizes are 16, 20, 22, 24, 28, and 36.
X.PP
XThe control codes with the top four bits 0100 specify miscellaneous
Xcontrol codes, not all of which have valid meanings.
XThey are:
X.PP
X.RS
X.ta 6c
X.nf
Xinitialize	0100\|0000
Xstop	0100\|1001
Xupper rail	0100\|0010
Xlower rail	0100\|0001
Xupper mag	0100\|0011
Xlower mag	0100\|0100
Xtilt up	0100\|1110
Xtilt down	0100\|1111
Xupper font half	0100\|0110
Xlower font half	0100\|0101
Xescape forward	0100\|0111
Xescape backward	0100\|1000
Xlead forward	0100\|1010
Xlead backward	0100\|1100
Xsoftware cut	0100\|1011
X.fi
X.DT
X.RE
X.PP
XThe \fIinitialize\fR code causes leftward motion to the left margin limit
Xswitch,
Xand sets the following modes:
Xescape forward, lead forward, lower font half,
Xlower rail, lower mag, tilt down.
XNote that the left margin limit switch does not define a precise
Xposition, and hence reinitializing the machine
Xwill destroy precise left-margin alignment.
X.PP
XThe \fIstop\fR code stops the machine, which must be manually
Xrestarted (normally after changing output cartridges);
Xthis code should be used only at the end of a run.
X.PP
XFonts are selected by the combination of \fIrail\fR, \fImag\fR, and \fItilt\fR.
XThe tilt codes do not exist on the 4-font C/A/T;  this is the only user-visible
Xdifference between the 4-font and 8-font machines.
XThe correspondence between rail/mag/tilt and font number is as follows:
X.PP
X.RS
X.nf
X.ta 2c 4c 6c 8c
Xrail	mag	tilt	4font	8font
X
Xlower	lower	up	1	1
Xlower	lower	down	1	2
Xupper	lower	up	2	3
Xupper	lower	down	2	4
Xlower	upper	up	3	5
Xlower	upper	down	3	6
Xupper	upper	up	4	7
Xupper	upper	down	4	8
X.DT
X.fi
X.RE
X.PP
XThe \fIsoftware cut\fR code should not be issued to the hardware, but
Xis used by local spooling software to indicate places where it is
Xlegal for the spooler to break output between pages.
XThis code should be followed by an \fIinitialize\fR code.
X.PP
XA complete C/A/T file should begin with an \fIinitialize\fR code followed
Xby an \fIescape\fR-16 code,
Xand should end with 14 inches of trailer and a \fIstop\fR code.
X.SH HISTORY
XThe \fIsoftware cut\fR code is a local invention.
XThis manual page written at U of T by Henry Spencer.
X.SH BUGS
XThe documentation and the hardware disagree on the initial tilt setting;
Xthe above describes the hardware.
X.PP
XIt's not the fastest or most modern typesetter.
END_OF_FILE
if test 5349 -ne `wc -c <'cat.5'`; then
    echo shar: \"'cat.5'\" unpacked with wrong size!
fi
# end of 'cat.5'
fi
if test -f 'chartab.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'chartab.m'\"
else
echo shar: Extracting \"'chartab.m'\" \(3287 characters\)
sed "s/^X//" >'chartab.m' <<'END_OF_FILE'
X.\"1.3 89/07/06
X.lg 1
X.DS
X.TS
Xallbox;
Xcf3 p14 s s s s s
Xc c c || c c c
Xl l l || l l l.
XMathematical and Other Characters
X=
Xcharacter	denotation	name	character	denotation	name
X=
X\(pl	\e(pl	math plus	\(ib	\e(ib	improper subset
X\(mi	\e(mi	math minus	\(ip	\e(ip	improper superset
X\(eq	\e(eq	math equal	\(if	\e(if	infinity
X\(**	\e(**	math star	\(pd	\e(pd	partial derivative
X\(sc	\e(sc	section	\(gr	\e(gr	gradient
X\(aa	\e\(aa or \e(aa	acute accent	\(no	\e(no	not
X\(ga	\e\(ga or \e(ga	grave accent	\(is	\e(is	integral sign
X\(ul	\(ul or \e(ul	underrule	\(pt	\e(pt	proportional to
X\(sl	\(sl or \e(sl	slash	\(es	\e(es	empty set
X\(sr	\e(sr	square root	\(mo	\e(mo	member of
X\(rn	\e(rn	root en	\(br	\e(br or |	box rule
X\(>=	\e(>=	\(>=	\(dd	\e(dd	dbl dagger
X\(<=	\e(<=	\(<=	\(rh	\e(rh	right hand
X\(==	\e(==	equivalence	\(lh	\e(lh	left hand
X\(~=	\e(~=	approx =	\(or	\e(or	or
X\(ap	\e(ap	approximates	\(ci	\e(ci	circle
X\(!=	\e(!=	not equal	\(lt	\e(lt	left top of big { and (
X\(->	\e(->	right arrow	\(lb	\e(lb	left bot of big { and (
X\(<-	\e(<-	left arrow	\(rt	\e(rt	right top of big } and )
X\(ua	\e(ua	up arrow	\(rb	\e(rb	right bot of big } and )
X\(da	\e(da	down arrow	\(lk	\e(lk	left ctr of big { and (
X\(mu	\e(mu	multiply	\(rk	\e(rk	right ctr of big } and )
X\(di	\e(di	divide	\(bv	\e(bv	bold vertical
X\(+-	\e(+-	plus-minus	\(lf	\e(lf	left floor
X\(cu	\e(cu	cup (union)	\(rf	\e(rf	right floor
X\(ca	\e(ca	intersection	\(lc	\e(lc	left ceiling
X\(sb	\e(sb	subset of	\(rc	\e(rc	right ceiling
X\(sp	\e(sp	superset of	
X.TE
X.DE
X.P
XAlignment test:
X.DS
X\(sr\(rn
X.DE
X.P
XLigatures:
Xfido, floor, snaffle, suffix, shuffle.
X.DS
X.EQ
Xsum from i=0 to {i= inf} x sup i
X.EN
X.EQ
Xsqrt a+b + 1 over sqrt {ax sup 2 +bx+c}
X.EN
X.EQ
Xsqrt {a sup 2 over b sub 2}
X.EN
X.TS
Xallbox;
Xcf3 p14 s s s s s
Xc c c || c c c
Xl l l || l l l.
XGreek Characters
X=
Xcharacter	denotation	name	character	denotation	name
X=
X\(*a	\e(*a	alpha	\(*A	\e(*A	Alpha
X\(*b	\e(*b	beta	\(*B	\e(*B	Beta
X\(*g	\e(*g	gamma	\(*G	\e(*G	Gamma
X\(*d	\e(*d	delta	\(*D	\e(*D	Delta
X\(*e	\e(*e	epsilon	\(*E	\e(*E	Epsilon
X\(*z	\e(*z	zeta	\(*Z	\e(*Z	Zeta
X\(*y	\e(*y	eta	\(*Y	\e(*Y	Eta
X\(*h	\e(*h	theta	\(*H	\e(*H	Theta
X\(*i	\e(*i	iota	\(*I	\e(*I	Iota
X\(*k	\e(*k	kappa	\(*K	\e(*K	Kappa
X\(*l	\e(*l	lambda	\(*L	\e(*L	Lambda
X\(*m	\e(*m	mu	\(*M	\e(*M	Mu
X\(*n	\e(*n	nu	\(*N	\e(*N	Nu
X\(*c	\e(*c	xi	\(*C	\e(*C	Xi
X\(*o	\e(*o	omicron	\(*O	\e(*O	Omicron
X\(*p	\e(*p	pi	\(*P	\e(*P	Pi
X\(*r	\e(*r	rho	\(*R	\e(*R	Rho
X\(*s	\e(*s	sigma	\(*S	\e(*S	Sigma
X\(ts	\e(ts	terminal sigma	
X\(*t	\e(*t	tau	\(*T	\e(*T	Tau
X\(*u	\e(*u	upsilon	\(*U	\e(*U	Upsilon
X\(*f	\e(*f	phi	\(*F	\e(*F	Phi
X\(*x	\e(*x	chi	\(*X	\e(*X	Chi
X\(*q	\e(*q	psi	\(*Q	\e(*Q	Psi
X\(*w	\e(*w	omega	\(*W	\e(*W	Omega
X.TE
X.DE
X.DS
X.TS
Xallbox;
Xcf3 p14 s s s s s
Xc c c || c c c
Xl l l || l l l.
XNon-ASCII Characters and minus on the Standard Fonts
X=
Xcharacter	denotation	name	character	denotation	name
X=
X\&`	\`	open quote	\(34	\e(34	3/4
X\&'	\'	close quote	\(fi	\e(fi	fi
X\&``	\`\`	open double quotes	\(fl	\e(fl	fl
X\&''	\'\'	close double quotes	\(ff	\e(ff	ff
X\(em	\e(em	3/4 em	\(Fi	\e(Fi	ffi
X\(hy	\e(hy	- hyphen	\(Fl	\e(Fl	ffl
X\-	\e-	minus	\(de	\e(de	degree
X\(bu	\e(bu	bullet	\(dg	\e(dg	dagger
X\(sq	\e(sq	square	\(fm	\e(fm	foot mark
X\(ru	\e(ru	rule	\(ct	\e(ct	cent sign
X\(14	\e(14	1/4	\(rg	\e(rg	registered
X\(12	\e(12	1/2	\(co	\e(co	copyright
X.TE
X.DE
X.S
END_OF_FILE
if test 3287 -ne `wc -c <'chartab.m'`; then
    echo shar: \"'chartab.m'\" unpacked with wrong size!
fi
# end of 'chartab.m'
fi
if test -f 'dit2catwid.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dit2catwid.c'\"
else
echo shar: Extracting \"'dit2catwid.c'\" \(8778 characters\)
sed "s/^X//" >'dit2catwid.c' <<'END_OF_FILE'
X/* Brute force ditroff to CAT width table converter 1.5 89/08/25
X   Will generate ft* files that are compatible with troff (at least the
X   Xenix version that is)
X*/
X
Xstatic char SCCSid[] = "@(#)dit2catwid.c 1.5 89/08/25";
X
X#include <stdio.h>
X#include "defs.h"
X#include <ctype.h>
Xint res = 720;
Xint unitwid = 10;
Xint symfont = 0;
Xint verbose = 0;
X
X#define	TROFFUWID	6
X
X#ifdef	DEBUG
X#undef	DEBUG
X#endif
X
XFILE *mustopen();
X
Xstruct widths {
X    char *name;
X    unsigned char catwidth;
X};
X
Xstruct widths symbol[256-32] = {
X	{NULL},{NULL},	 		/* ".=Sw+042-40" */
X	{"\""},
X	{"#"},
X	{NULL},{NULL},{NULL},{NULL},	 		/* ".=Sw+074-40" */
X	{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},
X	{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},
X	{NULL},{NULL},{NULL},{NULL},
X	{"<"},
X	{NULL},	 		/* ".=Sw+076-40" */
X	{">"},
X	{NULL},	 		/* ".=Sw+100-40" */
X	{"@"},
X	{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},		/* ".=Sw+134-40" */
X	{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},
X	{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},
X	{NULL},{NULL},{NULL},{NULL},
X	{"\\"},
X	{NULL},	 		/* ".=Sw+136-40" */
X	{"^"},
X	{"_"},
X	{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},
X	{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},
X	{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},
X	{NULL},{NULL},{NULL},
X	{"}"},
X	{NULL},	 		/* ".=Sw+175-40" */
X	{"}"},
X	{"~"},
X	{NULL},	 		/* ".=Sw+220-40" */
X	{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},
X	{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},
X	{"sc"},
X	{NULL},			/* ".=Sw+222-40" */
X	{"aa"},
X	{"ga"},
X	{"ul"},
X	{"sl"},
X	{NULL},	 	/* "" */
X	{NULL},	 	/* "" */
X	{"*a"},
X	{"*b"},
X	{"*g"},
X	{"*d"},
X	{"*e"},
X	{"*z"},
X	{"*y"},
X	{"*h"},
X	{"*i"},
X	{"*k"},
X	{"*l"},
X	{"*m"},
X	{"*n"},
X	{"*c"},
X	{"*o"},
X	{"*p"},
X	{"*r"},
X	{"*s"},
X	{"*t"},
X	{"*u"},
X	{"*f"},
X	{"*x"},
X	{"*q"},
X	{"*w"},
X	{"*G"},
X	{"*D"},
X	{"*H"},
X	{"*L"},
X	{"*C"},
X	{"*P"},
X	{"*S"},
X	{NULL},	 	/* "" */
X	{"*U"},
X	{"*F"},
X	{"*Q"},
X	{"*W"},
X	{"sr"},
X	{"ts"},
X	{"rn"},
X	{">="},
X	{"<="},
X	{"=="},
X	{"mi"},
X	{"~="},
X	{"ap"},
X	{"!="},
X	{"->"},
X	{"<-"},
X	{"ua"},
X	{"da"},
X	{"eq"},
X	{"mu"},
X	{"di"},
X	{"+-"},
X	{"cu"},
X	{"ca"},
X	{"sb"},
X	{"sp"},
X	{"ib"},
X	{"ip"},
X	{"if"},
X	{"pd"},
X	{"gr"},
X	{"no"},
X	{"is"},
X	{"pt"},
X	{"es"},
X	{"mo"},
X	{"pl"},
X	{NULL},
X	{NULL},
X	{NULL},	 	/* "box vert rule (was 2.)" */
X	{NULL},
X	{"dd"},
X	{"rh"},
X	{"lh"},
X	{"**"},
X	{"bs"},
X	{"or"},
X	{"ci"},
X	{"lt"},
X	{"lb"},
X	{"rt"},
X	{"rb"},
X	{"lk"},
X	{"rk"},
X	{"bv"},
X	{"lf"},
X	{"rf"},
X	{"lc"},
X	{"rc"}
X};
X
Xstruct widths normal[256-32] = {
X	{" "},
X	{"!"},
X	{NULL}, {NULL},
X	{"$"},
X	{"%"},
X	{"&"},
X	{"'"},
X	{"("},
X	{")"},
X	{"*"},
X	{"+"},
X	{","},
X	{"-"},		/* - hyphen - is this right? */
X	{"."},
X	{"/"},
X	{"0"},
X	{"1"},
X	{"2"},
X	{"3"},
X	{"4"},
X	{"5"},
X	{"6"},
X	{"7"},
X	{"8"},
X	{"9"},
X	{":"},
X	{";"},
X	{NULL},
X	{"="},
X	{NULL},
X	{"?"},
X	{NULL},
X	{"A"},
X	{"B"},
X	{"C"},
X	{"D"},
X	{"E"},
X	{"F"},
X	{"G"},
X	{"H"},
X	{"I"},
X	{"J"},
X	{"K"},
X	{"L"},
X	{"M"},
X	{"N"},
X	{"O"},
X	{"P"},
X	{"Q"},
X	{"R"},
X	{"S"},
X	{"T"},
X	{"U"},
X	{"V"},
X	{"W"},
X	{"X"},
X	{"Y"},
X	{"Z"},
X	{"["},
X	{NULL},
X	{"]"},
X	{NULL},
X	{NULL},
X	{"`"},
X	{"a"},
X	{"b"},
X	{"c"},
X	{"d"},
X	{"e"},
X	{"f"},
X	{"g"},
X	{"h"},
X	{"i"},
X	{"j"},
X	{"k"},
X	{"l"},
X	{"m"},
X	{"n"},
X	{"o"},
X	{"p"},
X	{"q"},
X	{"r"},
X	{"s"},
X	{"t"},
X	{"u"},
X	{"v"},
X	{"w"},
X	{"x"},
X	{"y"},
X	{"z"},
X	{NULL},
X	{"|"},
X	{NULL},
X	{NULL},
X	{"\\|"},	/* narrow space, not utterable in CAT troff? */
X	{"hy"},
X	{"bu"},
X	{"sq"},
X	{"em"},
X	{"ru"},
X	{"14"},
X	{"12"},
X	{"34"},
X	{"-"},		/* - hyphen - is this right? */
X	{"fi"},
X	{"fl"},
X	{"ff"},
X	{"Fi"},
X	{"Fl"},
X	{"de"},
X	{"dg"},
X	{NULL},
X	{"fm"},
X	{NULL},
X	{NULL},
X	{NULL},
X	{NULL},
X	{"\\^"},	/* half narrow space, not utterable in troff? */
X	{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},
X	{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},
X	{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},
X	{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},
X	{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},
X	{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},
X	{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},
X	{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},
X	{NULL},{NULL},{NULL},{NULL},{NULL},
X	{"rg"},
X	{"co"},
X	{NULL},
X	{"ct"},
X};
X
Xchar *progname;
X
Xmain(argc, argv)
Xint argc; char **argv; {
X    extern char *optarg;
X    extern int optind;
X    int c;
X
X    FILE *in1, *in2, *out;
X    char *fin1, *fin2, *fout;
X
X    progname = argv[0];
X
X    while ((c = getopt(argc, argv, "vsr:u:")) != EOF)
X	switch(c) {
X	    case 's':
X		symfont = 1;
X		break;
X	    case 'r':
X		res = atoi(optarg);
X		break;
X	    case 'u':
X		unitwid = atoi(optarg);
X		break;
X	    case 'v':
X		verbose = 1;
X		break;
X	    default:
X		usage();
X	}
X    if (optind != argc - 3) {
X	usage();
X    }
X    in1 = mustopen(fin1 = argv[optind], "r");
X    in2 = mustopen(fin2 = argv[optind+1], "r");
X    out = mustopen(fout = argv[optind+2], "w");
X    process(in1, fin1);
X    process(in2, fin2);
X    if (symfont)
X	output(symbol, out, fout, "Symbol character set");
X    else
X	output(normal, out, fout, "Normal character set");
X    fclose(in1);
X    fclose(in2);
X    fclose(out);
X    exit(0);
X}
X
Xoutput(symset, f, file, type)
XFILE *f;
Xstruct widths *symset;
Xchar *type, *file; {
X    int i;
X    for (i = 0; i < 224; i++) {
X	if (symset[i].name && !symset[i].catwidth) {
X	    fprintf(stderr, "%s: No width for %s (file %s)\n",
X		progname, symset[i].name, file);
X	    fputc(normal[0].catwidth, f);
X	} else
X	    fputc(symset[i].catwidth, f);
X    }
X    if (verbose) {
X	for (i = 0; i < 224; i++) {
X	    printf("	%d+%03o,",
X		symset[i].catwidth & 077, symset[i].catwidth & 0300);
X	    if (symset[i].name)
X		printf ("	/* \"%s\" */\n", symset[i].name);
X	    else
X		printf ("\n");
X	}
X    }
X}
X
Xusage() {
X    fprintf(stderr, "usage: %s [-rres] [-uunitwid] normfont symfont output\n",
X	progname);
X    exit(1);
X}
X
XFILE *
Xmustopen(f, mode)
Xchar *f, *mode; {
X    FILE *desc;
X    if ((desc = fopen(f, mode)) == NULL) {
X	fprintf(stderr, "%s: cannot open file %s mode %s\n", progname, f, mode);
X	exit(1);
X    } else
X	return(desc);
X}
X
Xchar *gettoken();
X
Xprocess(f, filename)
XFILE *f;
Xchar *filename; {
X    char *sv;
X    char buffer[512];
X    char *tok;
X    int commentsok = 1;
X    int widval, oldwidval;
X    while(fgets(buffer, sizeof(buffer), f) && buffer[0] == '#');
X    while(fgets(buffer, sizeof(buffer), f)) {
X	tok = gettoken(buffer, NULL);
X
X	if (!tok)
X	    continue;
X	if (0 == strcmp(tok, "charset"))
X	    break;
X
X	if (0 == strcmp(tok, "spacewidth")) {
X	    if (!(tok = gettoken(buffer, 1))) {
X		fprintf(stderr, "%s: bad spacewidth line in %s\n",
X		    progname, filename);
X		exit(1);
X	    }
X	    widval = atoi(tok);
X	    widval = (TROFFUWID * TROFFRESOLUTION * widval / (unitwid * res));
X	    update(symbol, " ", widval);
X	    update(normal, " ", widval);
X	    update(symbol, "narrow space", widval / 2);
X	    update(normal, "narrow space", widval / 2);
X	    update(symbol, "half narrow space", widval / 4);
X	    update(normal, "half narrow space", widval / 4);
X	}
X    }
X    if (strcmp(tok, "charset")) {
X	fprintf(stderr, "%s: %s bad format - no charset line\n", progname,
X	    filename);
X	exit(1);
X    }
X    while(fgets(buffer, sizeof(buffer), f)) {
X	char str[3];
X	if (commentsok && buffer[0] == '#')
X	    continue;
X	commentsok = 0;
X#ifdef	DEBUG
X	printf("buffer: %s\n", buffer);
X#endif
X	tok = gettoken(buffer, NULL);
X	if (!tok)
X	    continue;
X	if (strlen(tok) > 2) {
X	    fprintf(stderr, "%s: %s bad format on line %s\n",
X		progname, filename, buffer);
X	    exit(1);
X	}
X	strcpy(str, tok);
X	tok = gettoken(buffer, 1);
X	if (!tok) {
X	    fprintf(stderr, "%s: %s bad format on line %s\n",
X		progname, filename, buffer);
X	    exit(1);
X	}
X#ifdef	DEBUG
X	printf("token: %s\n", tok);
X#endif
X	if (0 == strcmp(tok, "\""))
X	    widval = oldwidval;
X	else {
X	    widval = (TROFFUWID * TROFFRESOLUTION * atoi(tok) / (unitwid * res));
X	    tok = gettoken(buffer, 1);
X	    if (!tok) {
X		fprintf(stderr, "%s: %s bad format on line %s\n",
X		    progname, filename, buffer);
X		exit(1);
X	    }
X	    widval |= (atoi(tok) << 6);
X	}
X	update(symbol, str, widval);
X	update(normal, str, widval);
X	oldwidval = widval;
X    }
X}
X
Xupdate(table, str, val)
Xstruct widths *table;
Xchar *str;
Xint val; {
X    int i;
X
X#ifdef	DEBUG
X    printf("Inserting char %s, (%03o)\n", str, val);
X#endif
X
X    for (i = 0; i < 224; i++)
X	if (0 == strcmp(table[i].name, str))
X	    table[i].catwidth = val;
X}
X
Xchar *
Xgettoken(buf, ptr)
Xchar *buf, *ptr; {
X    static char *saveptr;
X    static char savebuf[512];
X    char *bp = savebuf;
X    if (!ptr)
X	saveptr = buf;
X    while(*saveptr && isspace(*saveptr)) saveptr++;
X    if (*saveptr)
X	while(*saveptr && !isspace(*saveptr))
X	    *bp++ = *saveptr++;
X    *bp = '\0';
X    if (savebuf[0])
X	return(savebuf);
X    else
X	return((char *) NULL);
X}
END_OF_FILE
if test 8778 -ne `wc -c <'dit2catwid.c'`; then
    echo shar: \"'dit2catwid.c'\" unpacked with wrong size!
fi
# end of 'dit2catwid.c'
fi
if test -f 'fonts.lk' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fonts.lk'\"
else
echo shar: Extracting \"'fonts.lk'\" \(3271 characters\)
sed "s/^X//" >'fonts.lk' <<'END_OF_FILE'
X#@(#)fonts.lk 1.2 89/06/14
X               +------------------------------------ Symbol set
X               |      +----------------------------- 0=fixed, 1=proportional
X               |      | +--------------------------- 0=upright, 1=italics
X               |      | |  +------------------------ stroke weight -7...7
X               |      | |  |  +--------------------- Typeface
X               |      | |  |  |
X               |      | |  |  |
X               v      v v  v  v	*/
X/* A*/	"\033(0U\033(s1p0s00b05T",	/* Times-Roman */
X/* B*/	"\033(0U\033(s1p1s-3b05T",	/* Times-Italic */
X/* C*/	"\033(0U\033(s1p0s03b05T",	/* Times-Bold */
X/* D*/	"\033(0E\033(s0p0s00b03T",	/* Math Symbol (actually Roman Ext.) */
X/* E*/	"\033(0U\033(s1p1s03b05T",	/* Times-BoldItalic */
X/* F*/	"\033(0U\033(s0p0s00b03T",	/* Courier */
X/* G*/	"\033(0U\033(s0p1s-3b03T",	/* Courier-Oblique */
X/* H*/	"\033(0U\033(s0p0s03b03T",	/* Courier-Bold */
X	/*
X	 * These are for special characters that aren't in the symbol font
X	 * The are in the HP 'K' font cartridge ?
X	 */
X/* I*/	"\033(0Q\033(s0p0s00b03T",	/* Math 8a */
X/* J*/	"\033(1Q\033(s0p0s00b03T",	/* Math 8b */
X/* K*/	"\033(0A\033(s0p0s00b03T",	/* Math 7 */
X/* L*/	"\033(2Q\033(s0p0s00b03T",	/* PiFonta */
X/* M*/	"\033(8U\033(s0p0s00b00T",	/* LinePrinter */
X/* N*/	"\033(8U\033(s0p1s-3b00T",	/* LinePrinter-Italic */
X/* O*/	"\033(8U\033(s0p0s03b00T",	/* LinePrinter-Bold */
X	/*
X	 * rest currently unsupported
X	 */
X/* P	"\033(8U\033(s1p0s00b01T",	/* Pica */
X/* Q	"\033(8U\033(s1p1s-3b01T",	/* Pica-Italic */
X/* R	"\033(8U\033(s1p0s03b01T",	/* Pica-Bold */
X/* S	"\033(8U\033(s1p0s00b02T",	/* Elite */
X/* T	"\033(8U\033(s1p1s-3b02T",	/* Elite-Italic */
X/* U	"\033(8U\033(s1p0s03b02T",	/* Elite-Bold */
X/* V	"\033(8U\033(s1p0s00b04T",	/* Helvette */
X/* W	"\033(8U\033(s1p1s-3b04T",	/* Helvette-Italic */
X/* X	"\033(8U\033(s1p0s03b04T",	/* Helvette-Bold */
X
X/* Y	"\033(8U\033(s1p0s00b06T",	/* Gothic */
X/* Z	"\033(8U\033(s1p1s-3b06T",	/* Gothic-Italic */
X/*	"\033(8U\033(s1p0s03b06T",	/* Gothic-Bold */
X/* 	"\033(8U\033(s1p0s00b07T",	/* Script */
X/*	"\033(8U\033(s1p1s-3b07T",	/* Script-Italic */
X/*	"\033(8U\033(s1p0s03b07T",	/* Script-Bold */
X/*	"\033(8U\033(s1p0s00b08T",	/* Prestige */
X/*	"\033(8U\033(s1p1s-3b08T",	/* Prestige-Italic */
X/*	"\033(8U\033(s1p0s03b08T",	/* Prestige-Bold */
X/*	"\033(8U\033(s1p0s00b09T",	/* Caslon */
X/*	"\033(8U\033(s1p1s-3b09T",	/* Caslon-Italic */
X/*	"\033(8U\033(s1p0s03b09T",	/* Caslon-Bold */
X/*	"\033(8U\033(s1p0s00b10T",	/* Orator */
X/*	"\033(8U\033(s1p1s-3b10T",	/* Orator-Italic */
X/*	"\033(8U\033(s1p0s03b10T",	/* Orator-Bold */
X
X/*	"\033(8M\033(s1p0s00b05T",	/* Math-8 Symbol */
X/*	"\033(10N\033(s1p0s00b05T",	/* US Symbol */
X};
X
Xstatic
Xchar *fontNames[LASTFONT-'A'+1] = {
X	"Times-Roman",			/* default font (1:A) */
X	"Times-Italic",			/* default font (2:B) */
X	"Times-Bold",			/* default font (3:C) */
X	"Symbol",			/* default font (4:D) */
X	"Times-BoldItalic",		/* font E */
X	"Courier",			/* font F */
X	"Courier-Oblique",		/* font G */
X	"Courier-Bold",			/* font H */
X	"Math 8a",			/* font I */
X	"Math 8b",			/* font J */
X	"Math 7",			/* font K */
X	"PiFonta",			/* font L */
X	"LinePrinter",			/* font M */	/* only 16.66 fixed */
X	"LinePrinter-Italic",		/* font N */
X	"LinePrinter-Bold",		/* font O */
X};
END_OF_FILE
if test 3271 -ne `wc -c <'fonts.lk'`; then
    echo shar: \"'fonts.lk'\" unpacked with wrong size!
fi
# end of 'fonts.lk'
fi
if test -f 'ltest.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ltest.m'\"
else
echo shar: Extracting \"'ltest.m'\" \(8315 characters\)
sed "s/^X//" >'ltest.m' <<'END_OF_FILE'
X.\"Document revision 1.12 89/08/25
X.nr Ej 1
X.TL
Xtroff2ps testing script.
X.AU "Chris Lewis"
X.AS 1 10
XEver since the dawn of time, people have been dreaming of being
Xable to use "troff" on devices other than Wang Cat Phototypesetters.
XThis is a test document of one such thingie.
X.AE
X.MT 4 1
X.SP 2i
X.H 1 "Line Test"
X.P
XThis line should be exactly 5 inches long:
X.DS
X\l'5i\&\(ru'
X.DE
X.H 2 "Extended font test"
X.P
XExtended font test:
X.eX I
XThis is a standard display - this should be 
XCourier, fixed width.
X.eE
X.H 2 "Simple paragraphs"
X.P
XThis is some more of the testing.  Can't you tell?
XTesting, testing, testing testing.
XThis book is a practical guide to the \fBUNIX\fP system and all users 
Xfrom the novice to the expert should find it useful.
XMany examples are used throughout the text to illustrate techniques that make
Xthe system attractive to use.  By giving examples of the interactions
Xbetween commands, the user is able to take full advantage of the power of the
X\fBUNIX\fP system.
X.P
XThis is some more of the testing.  Can't you tell?
XTesting, testing, testing testing.
XThis book is a practical guide to the \fBUNIX\fP system and all users 
Xfrom the novice to the expert should find it useful.
XMany examples are used throughout the text to illustrate techniques that make
Xthe system attractive to use.  By giving examples of the interactions
Xbetween commands, the user is able to take full advantage of the power of the
X\fBUNIX\fP system.
X.H 1 "Lists"
X.P
XBullet list:
X.BL
X.LI
X\(<- that was a bullet.
X.LI
XThis is 2
X.LI
XDashlist:
X.DL
X.LI
XDash
X.LI
XDasher
X.LE
X.LE
X.H 2 "Ligature test"
X.P
XLigature test: fido, flu, duffle, duffin
X.P
Xnroff doesn't like double quotes too much.
X"X" should look reasonable.
XMore 'test` `test'\*F
X.FS
XThis here's a footnote - slightly smaller pitch.
X.FE
XThis is more of the paragraph.
X.SK
X.H 1 "Different Fonts"
X.P
XThis is normal\f3Bold\fP\f2italic\fPnormal.
XThis is normal \f3Bold\fP \f2italic\fP normal.
X.S 36 38
X.P
X\(bs
X.S
X.S 14 26
X.P
Xthat was the logo at 36 point.  This sentence is 14 point.
X.S
X.P
XThe Logo will be printed whether or not you have raster fonts.
XThe original logo is a stylized "cX".
XIf you don't have the vfonts installed, the rest of the line will be
Xnormal characters with big spacing.
XIf the fonts are installed, you will see 75DPI big print.
X.P
XThis is some more of bigger stuff:
X.S 22
XTesting
X.I Testing
X.B Testing
X.S
X.SP
X.S 6
X6 Point
X.br
X.S 7
X7 Point
X.br
X.S 8
X8 Point
X.br
X.S 9
X9 Point
X.br
X.S 10
X10 Point
X.br
X.S 11
X11 Point
X.br
X.S 12
X12 Point
X.br
X.S 14
X14 Point
X.br
X.S 16
X16 Point
X.br
X.S 18
X18 Point
X.br
X.S 20
X20 Point
X.br
X.S 22
X22 Point
X.br
X.S 24
X24 Point
X.br
X.S 28
X28 Point
X.br
X.S 36
X36 Point
X.br
X.S 10
X.P
XNow, lets have some phun with phonts:
X.br
X.fp 1 H
X.fp 2 HO
X.fp 3 HB
X.ft 1
XThis should be Helvetica.
X\f2Helvetica Oblique\fP, \f3Helvetica Bold\fP.
X.br
X.fp 1 BR
X.fp 2 BO
X.fp 3 BB
X.ft 1
X.P
XThis should be Bookman.
X\f2Bookman Oblique\fP, \f3Bookman Bold\fP.
X.br
X.fp 1 R
X.fp 2 I
X.fp 3 B
X.H 3 "Testing 3"
Xhello 3
X.H 4 "Testing 4"
Xhello 4
X.H 5 "Testing 5"
Xhello 5
X.H 6 "Testing 6"
Xhello 6
X.H 7 "Testing 7"
Xhello 7
X.H 1 "Some Equations"
X.S 16
XEquations:
X.S
X.DS
X.EQ
Xleft [ x sup 2 + y sup 2 over alpha right ] ~=~ 1
X.EN
X.DE
X.br
X.DS
X.EQ
Xx dot = f(t) bar
X.EN
X.DE
X.DS
X.EQ
Xlim from {n -> inf} sum from 0 to n x sub i
X.EN
X.DE
X.DS
X.EQ
Xt ~=~ 2 pi int sub 0 sup 1
Xsin ( sqrt { x sup 2 + a sup 2 } ) dx
X.EN
X.DE
X.\".P
X.\"This is a test of piling (though, this isn't eqn):
X.\".DS I
X.\"\b'\(lt\(lk\(lb'\b'\(lc\(lf x \b'\(rc\(rf\b'\(rt\(rk\(rb'
X.\".DE
X.H 2 "More Equations"
X.DS
X.EQ
XG(z)~mark =~ e sup { ln ~ G(z) }
X~=~ exp left (
Xsum from k>=1 { S sub k z sup k } over k right )
X~=~ prod from k>=1 e sup { S sub k z sup k / k }
X.EN
X.DE
X.DS
X.EQ
Xlineup = left ( 1 + S sub 1 z +
X{ S sub 1 sup 2 z sup 2 } over 2! + ... right )
Xleft ( 1 + { S sub 2 z sup 2 } over 2
X+ { S sub 2 sup 2 z sup 4 } over { 2 sup 2 cdot 2! }
X+ ... right ) ...
X.EN
X.DE
X.DS
X.EQ
Xlineup = sum from m>=0 left (
Xsum from
Xpile { k sub 1 ,k sub 2 ,..., k sub m >= 0
Xabove
Xk sub 1 +2k sub 2 + ... + mk sub m = m }
X{ S sub 1 sup { k sub 1 } } over { 1 sup k sub 1 k sub 1 ! } ~
X{ S sub 2 sup { k sub 2 } } over { 2 sup k sub 2 k sub 2 ! } ~
X{ S sub m sup { k sub m } } over { m sup k sub m k sub m ! }
Xright ) z sup m
X.EN
X.DE
X.H 2 "Hanging Caps"
X.fp 1 PA
X.fp 3 PB
X.ta 1i
X.in +0.6i
X.ll -0.3i
X.ti -0.3i
X\v'1'\s36P\s0\v'-1'ater 
X.de Xx
X'in -0.6i
X..
X.wh \n(nlu+1.5v Xx
Xnoster qui est
Xin caelis scanctificetur nomen tuum; adveniat regnum tuum;
Xfiat voluntus tua, sicut in caelo, et in terra ...
XAmen.
XToo bad I can't read Latin so I don't know what that line meant.
XBut it should be a good example of INITIAL hanging caps.
X(AND Palatino...)
X.fp 1 R
X.fp 3 B
X.H 1 "tbl output"
X.DS
X.TS
Xallbox doublebox;
Xc c c
Xl l l.
XCommand	Reference Section	Action
X
Xcc	CP	Compiles C programs
Xcp	C	Copies files
Xdisk cp	C	Copies archive media
Xlc	C	Lists files
Xlogin	M	Access to the system
Xtroff	CT	Typesets text
X.TE
X.DE
X.DS
X.TS
Xbox;
Xc s s
Xc | c | c
Xl | l | n.
XMajor New York Bridges
X=
XBridge	Designer	Length
X_
XBrooklyn	JA Roebling	1595
XManhattan	G Lindenthal	1470
XWilliamsburg	LL Buck	1600
X_
XQueensborough	Palmer &	1182
X	  Hornbostel
X_
X		1380
XTriborough	OH Ammann	_
X		383
X_
XBronx Whitestone	OH Ammann	2300
XThrogs Neck	OH Ammann	1800
X_
XGeorge Washington	OH Ammann	3500
X.TE
X.DE
X.DS
X.TS
Xbox;
XcfB s s s.
XComposition of Foods
X_
X.T&
Xc | c s s
Xc | c s s.
XFood	Percent by Weight
X\^	_
X\^	Protein	Fat	Carbo-
X\^	\^	\^	hydrate
X_
X.T&
Xl | n | n | n.
XApples	.4	.5	13.0
XHalibut	18.4	5.2	...
XLima beans	7.5	.8	22.o
XMilk	3.3	4.0	5.0
XMushrooms	3.5	.4	6.0
XRye bread	9.0	.6	52.7
X.TE
X.DE
X.H 1 "A Test of Two Column Output"
X.2C
X.P
XThe IBM salesman and the IBM system analyst went to spend 
Xa weekend in the forest, hunting bear.
XThey hired a log cabin, and when they got there, took 
Xtheir backpacks off and put them inside.
XAt which point the salesman said to the systems analyst:
X"You unpack while I go and find us a bear."
XThe analyst finished unpacking and then went and sat 
Xoutside to await events. He did not have to wait too long.
XSoon he could hear noises in the forest. The noises got 
Xnearer - and suddenly there was the salesman, running 
Xacross the clearing toward the cabin, pursued by one of the 
Xlargest and most ferocious Brown Bears the analyst had 
Xever seen.
X"Open the door! shouted the salesman.
XThe analyst opened the door.
XThe salesman ran to the door, suddenly stopped, and 
Xstepped aside.
XThe Bear carried by its momentum, continued though the 
Xdoor and disappeared inside.
XThe salesman promptly shut the door on it, turned, looked 
Xat the analyst, and said:
X"Ok, you skin that one while I go rustle us up another."
X.P
XThe IBM salesman and the IBM system analyst went to spend 
Xa weekend in the forest, hunting bear.
XThey hired a log cabin, and when they got there, took 
Xtheir backpacks off and put them inside.
XAt which point the salesman said to the systems analyst:
X"You unpack while I go and find us a bear."
XThe analyst finished unpacking and then went and sat 
Xoutside to await events. He did not have to wait too long.
XSoon he could hear noises in the forest. The noises got 
Xnearer - and suddenly there was the salesman, running 
Xacross the clearing toward the cabin, pursued by one of the 
Xlargest and most ferocious Brown Bears the analyst had 
Xever seen.
X"Open the door! shouted the salesman.
XThe analyst opened the door.
XThe salesman ran to the door, suddenly stopped, and 
Xstepped aside.
XThe Bear carried by its momentum, continued though the 
Xdoor and disappeared inside.
XThe salesman promptly shut the door on it, turned, looked 
Xat the analyst, and said:
X"Ok, you skin that one while I go rustle us up another."
X.P
XThe IBM salesman and the IBM system analyst went to spend 
Xa weekend in the forest, hunting bear.
XThey hired a log cabin, and when they got there, took 
Xtheir backpacks off and put them inside.
XAt which point the salesman said to the systems analyst:
X"You unpack while I go and find us a bear."
XThe analyst finished unpacking and then went and sat 
Xoutside to await events. He did not have to wait too long.
XSoon he could hear noises in the forest. The noises got 
Xnearer - and suddenly there was the salesman, running 
Xacross the clearing toward the cabin, pursued by one of the 
Xlargest and most ferocious Brown Bears the analyst had 
Xever seen.
X"Open the door! shouted the salesman.
X.1C
X.CS
X.TC
END_OF_FILE
if test 8315 -ne `wc -c <'ltest.m'`; then
    echo shar: \"'ltest.m'\" unpacked with wrong size!
fi
# end of 'ltest.m'
fi
if test -f 'psxlate.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'psxlate.c'\"
else
echo shar: Extracting \"'psxlate.c'\" \(5230 characters\)
sed "s/^X//" >'psxlate.c' <<'END_OF_FILE'
X/*	Copyright 1985, 1986, 1987, 1988 Chris Lewis
X		All Rights Reserved
X
X    Permission to copy and further distribute is freely given provided 
X    this copyright notice remains intact and that this software is not 
X    sold for profit.
X
X	Project:	Generic Troff drivers
X	Module:		psxlate.c
X	Author: 	Chris Lewis
X	Specs:		Generic Postscript filter (page reversal etc.)
X */
X#ifndef	SVR3
X#ifndef	lint
Xstatic char SCCSid[] = "@(#)psxlate.c: 1.4 Copyright 89/04/21 11:48:27 Chris Lewis";
X#endif
X#else
X#ident  "@(#)psxlate.c: 1.4 Copyright 89/04/21 11:48:27 Chris Lewis"
X#endif
X#include <stdio.h>
X
Xint	xlate = 0;
X#define	MAXPAGE	1000
X
Xstruct headers {
X    char *hptr;
X    struct headers *next;
X};
X
Xstruct pagedesc {
X    unsigned long start;
X    unsigned long end;
X    char *type;
X    struct headers *comments;
X} pageidx[MAXPAGE];
X
Xchar *tmp = "/tmp/psxXXXXXX";
Xint page = 0;
Xchar *progname;
Xint debug;
X
Xmain(argc, argv)
Xint argc; char **argv; {
X    extern int optind;
X    int c;
X    progname = argv[0];
X    while ((c = getopt(argc, argv, "drx")) != EOF)
X	switch(c) {
X	    case 'r': xlate = 0; break;
X	    case 'x': xlate = 1; break;
X	    case 'd': debug = 1; break;
X	    default:
X		usage();
X		exit(1);
X	}
X    mktemp(tmp);
X    scan(stdin, tmp);
X    transform();
X    emit(tmp);
X    if (!debug)
X	cleanup();
X    exit(0);
X}
X
Xscan(f, file)
XFILE *f; char *file; {
X    FILE *t;
X    extern char *malloc();
X    int state = 1;
X    long ind = 0;
X    int c;
X    char buf[100];
X    if ((t = fopen(file, "w")) == NULL) {
X	fprintf(stderr, "Cannot open temporary file %s\n", file);
X	exit(1);
X    }
X    page = 0;
X    while((c = getc(f)) != EOF) {
X	putc(c, t);
X	ind++;
X	switch(state) {
X	    case 0:
X		if (c == '\n') {
X		    state = 1;
X		}
X		break;
X	    case 1:	/* seen \n */
X		if (c == '%') {
X		    fgets(buf, sizeof(buf), f);
X		    fputs(buf, t);
X		    if (0 == strncmp(buf, "!PS-Adobe", 9) ||
X			0 == strncmp(buf, "%Page:", 6) ||
X			0 == strncmp(buf, "%Trailer", 8)) {
X			if (page)
X			    pageidx[page-1].end = ind - 2;
X			pageidx[page].start = ind - 1;
X			strcpy(pageidx[page].type = malloc(strlen(buf)+1), buf);
X			add(page, buf);
X			page++;
X		    } else
X			add(page, buf);
X		    ind += strlen(buf);
X		    break;
X		}
X		state = 0;
X		break;
X	}
X    }
X    if (page)
X	pageidx[page-1].end = ind - 1;
X    fclose(t);
X}
X
Xcleanup() {
X    unlink(tmp);
X}
X
Xemit(file)
Xchar *file; {
X    FILE *t;
X    register int i;
X    if ((t = fopen(file, "r")) == NULL) {
X	fprintf(stderr, "Panic\n");
X	exit(1);
X    }
X    for(i = 0; i < page; i++) {
X	register long start, end, cnt;
X	register int c;
X
X	start = pageidx[i].start;
X	end = pageidx[i].end;
X	cnt = end - start + 1;
X	fseek(t, start, 0);
X	while(cnt--)
X	    putchar(getc(t));
X    }
X}
X
X
Xusage() {
X    fprintf(stderr, "Usage: %s [-r|-x] < file > file\n", progname);
X}
X
Xdumppg() {
X    register int i;
X    register struct headers *h;
X    if (debug) {
X	for (i = 0; i < page; i++) {
X	    fprintf(stderr, "%d %d %d %s\n", i, pageidx[i].start, 
X		pageidx[i].end, pageidx[i].type);
X	    for (h = pageidx[i].comments; h; h=h->next)
X		fprintf(stderr, "%s", h->hptr);
X	}
X    }
X}
X
Xtransform() {
X    dumppg();
X    switch(xlate) {
X	case 0:
X	    revpages();
X	    break;
X	case 1:
X	    xpages();
X	    break;
X    }
X    dumppg();
X}
X
Xfstart() {
X    register int i;
X    for (i = 0; i < page; i++)
X	if (0 == strncmp(pageidx[i].type, "%Page:", 6))
X	    break;
X    return(i);
X}
Xfend() {
X    register int i;
X    for (i = page-1; i >= 0; i--)
X	if (0 == strncmp(pageidx[i].type, "%Page:", 6))
X	    break;
X    return(i);
X}
X
Xrevpages() {
X    register int i, j;
X    struct pagedesc t;
X    i = fstart();
X
X    if (i == page)
X	return;
X    
X    j = fend();
X
X    while(i < j) {
X	t = pageidx[i];
X	pageidx[i] = pageidx[j];
X	pageidx[j] = t;
X	i++;j--;
X    }
X}
X
Xxpages() {
X    register int i, j, mid, first, last;
X    struct pagedesc t;
X    struct pagedesc *p = 
X	(struct pagedesc *) malloc(sizeof(struct pagedesc) * page);
X    revpages();
X    first = fstart();
X
X    if (first == page)
X	return;
X    
X    last = fend();
X
X    if (debug)
X	fprintf(stderr, "first: %d, last: %d, page: %d\n", first, last, page);
X    if ((last - first + 1) < 3)
X	return;
X
X    if (first)
X	memcpy(p, pageidx, sizeof(struct pagedesc) * first);	/* prolog */
X    if (page - last)	/* copy epilog */
X	memcpy(p+last+1, 
X	    &pageidx[last+1], sizeof(struct pagedesc) * (page - last - 1));
X    mid = (last + first + 1) / 2 ;	/* offset of middle */
X    for (i = first; i < mid; i++)
X	p[first + (i - first) * 2] = pageidx[i];
X    for (i = mid; i <= last; i++)
X	p[first + (i - mid) * 2 + 1] = pageidx[i];
X    memcpy(pageidx, p, sizeof(struct pagedesc) * page);
X    free(p);
X}
X
Xadd(page, buf)
Xint page; char *buf; {
X    struct headers *hdr, *hp, *ohp;
X    char *p;
X    if (debug)
X	fprintf(stderr, "Adding %s\n", buf);
X    hdr = (struct headers *) malloc(sizeof(struct headers));
X    if (hdr == 0 || !(hdr->hptr = malloc(strlen(buf) + 2))) {
X	fprintf(stderr, "psxlate: Out of space\n");
X	exit(1);
X    }
X    strcpy(hdr->hptr, "%");
X    strcat(hdr->hptr, buf);
X    hdr->next = NULL;
X    for (ohp = hp = pageidx[page].comments; ; hp = hp->next) {
X	if (!hp) {
X	    if (ohp == pageidx[page].comments)
X		pageidx[page].comments = hdr;
X	    else
X		ohp->next = hdr;
X	    break;
X	}
X	ohp = hp;
X    }
X    return;
X}
END_OF_FILE
if test 5230 -ne `wc -c <'psxlate.c'`; then
    echo shar: \"'psxlate.c'\" unpacked with wrong size!
fi
# end of 'psxlate.c'
fi
if test -f 'showfont.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'showfont.sh'\"
else
echo shar: Extracting \"'showfont.sh'\" \(3197 characters\)
sed "s/^X//" >'showfont.sh' <<'END_OF_FILE'
X:
X#@(#)showfont 1.3 89/08/25
X# Shell script to dump postscript fonts with widths into a pretty table
X
X(
Xcat << !END!
X%! PS-Adobe 1.0
X%%Title: showfont -- displays the font metrics in a pretty one page table
X%%Creator: Ken Marchant
X%%CreationDate: March 1989
X%%Pages: atend
X%%
X!END!
X
Xif [ -r $1 ]
Xthen
X    cat $1
X    shift
Xfi
Xcat << !END!
X
X/FONTname ($1) def
X
X%%  Setup functions used and etc...
X
X/rowmove {
X  /I exch def 
X  I 16 mod 30 mul 72 add
X  680 I 16 idiv 30 mul sub
X  moveto 
X} def
X
X/widths 259 array def
X/heights 259 array def
X/lbear 259 array def
X/rbear 259 array def
X/tmp 1 string def
X.5 setlinewidth
X
X/Helvetica findfont 9 scalefont setfont
X
X%% Draw the grid around the cells 
X%% and add the hex labels to the outside of the box
X
X0 1 16
X{
X    /i exch def
X    /j i 30 mul def
X    %% vertical lines
X    j 62 add dup 220 moveto
X    700 lineto
X    stroke
X
X    %% horizontal lines
X    j 220 add dup 62 exch moveto
X    542 exch lineto
X    stroke
X
X    i 16 ge { clear exit } if
X
X    %% hex across the top
X    j 77 add dup 705 moveto
X    i 16 (   ) cvrs show
X
X    %% hex along the sides
X    50 670 j sub 12 add moveto 
X    i 16 (   ) cvrs show
X}
Xfor
X
X/myscale {
X    2 mul 
X    % 10 mul round cvi 10 div
X    round cvi
X} def
X
X/irmove {
X    CY add exch
X    CX add exch moveto
X} def
X
X%% Print out the headings in the font to be displayed and Times-Roman
X
X/Times-Roman findfont 18 scalefont setfont
X295 FONTname stringwidth pop .5 mul sub 750 moveto FONTname show
X
XFONTname findfont 18 scalefont setfont
X295 FONTname stringwidth pop .5 mul sub 730 moveto FONTname show
X
X
X%% loop thru all the charcters and display in 18 point
X%% insert the character widths into the widths array
X	    0 1 258 
X	    { 
X	     newpath
X	     /i exch def
X	     i rowmove
X	     i 255 gt {
X		 i 256 eq { /tmp (ff) def } if
X		 i 257 eq { /tmp (ffi) def } if
X		 i 258 eq { /tmp (ffl) def } if
X	     } {
X		 /tmp 1 string def
X		 tmp 0 i put
X	     } ifelse
X	     tmp show 
X	     widths i tmp stringwidth pop dup /width exch def 
X	     myscale put 
X
X	     %	Set current point again.
X	     i rowmove
X	     /curx currentpoint pop def
X
X	     % retrieve bounding box info.
X	     tmp false charpath flattenpath pathbbox
X	     /ury exch def
X	     /urx exch def
X	     /lly exch def
X	     /llx exch def
X
X	     % calc left bearing as leftx - curx
X
X	     lbear i llx curx sub myscale put
X
X	     % calc height as upper y - lower y
X
X	     heights i ury lly sub myscale put
X
X	     % calc right bearing as width - upper x
X
X	     rbear i width urx curx sub sub myscale put
X
X	    } 
X	    for 
X
X%% display the widths in the widths array
X
X	/Helvetica-Narrow findfont 5 scalefont setfont
X
X	    0 1 258 
X	    { 
X	     /i exch def
X
X	     i rowmove
X
X	     currentpoint /CY exch def /CX exch def
X
X	     2 -8 irmove
X	     widths i get (       ) cvs show 
X
X	     -9 4 irmove
X	     heights i get (       ) cvs show 
X
X	     -9 -8 irmove 
X	     lbear i get (       ) cvs show 
X
X	     12 -8 irmove
X	     rbear i get (       ) cvs show
X
X	     -9 15 irmove
X	     i 8 (   ) cvrs show
X
X	     1 15 irmove
X	     i 10 (   ) cvrs show
X
X	     12 15 irmove
X	     i 16 (   ) cvrs show
X	    }
X	    for
X
X	showpage
X
X%%Pages: 1
X!END!
Xecho '\004'
X) | rlp -dgate!AppleLaser
END_OF_FILE
if test 3197 -ne `wc -c <'showfont.sh'`; then
    echo shar: \"'showfont.sh'\" unpacked with wrong size!
fi
# end of 'showfont.sh'
fi
if test -f 'troff2ps.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'troff2ps.1'\"
else
echo shar: Extracting \"'troff2ps.1'\" \(5942 characters\)
sed "s/^X//" >'troff2ps.1' <<'END_OF_FILE'
X.\"Copyright 1988 by Chris Lewis 1.3 89/04/21
X.TH TROFF2PS 1 local
X.SH NAME
Xtroff2ps, troff2lj, troff2xx \- convert troff output to Postscript, HP etc.
X.SH SYNOPSIS
X.BI /usr/lib/troff2/troff2 xx
X[-D] 
X.RI "[-d" xx "]"
X.RI "[-l" length "]"
X[-V] [-m]
X.SH DESCRIPTION
X.I Troff2ps
Xtakes
X.I troff
Xoutput on standard input and transforms it into another format for
Xoutput on a printer.
XThis program is normally invoked by
X.BR psroff(1L),
Xwhich has a more complete description of how to use some of the more
Xinteresting features of this program.
X.P
XThe output format is determined by how
X.I troff2ps
Xis invoked.
XNormally,
X.I troff2ps
Xwill generate PostScript output, but if the
X.I troff2ps
Xprogram has been linked to another name, the program will
Xcheck the trailing two characters in the name it was invoked by to find
Xout what format should be generated.
XIf the trailing two characters are "lj", it will generate HP Laserjet
Xcodes (that is, providing your system administrator hasn't disabled
Xit).
XYour system administrator (or the original author of this program) may
Xmake other output options available from time to time.
X.P
XThe
X.BI -l length
Xoption is used to tell the software how long the pages are on the printer.
XThe default value is 11 inches.
XLength should be written as if you were issuing a ".pl" 
X.I troff 
Xcommand; eg: troff scaling should be used.
XFor example: "-l11i", "-l4752u", "-l792p" specify a page length of
X11 inches in inches,
X.I troff
Xunits and points respectively.
X.P
XThe
X.BI -d xx
Xoption can be used to override the format determined by looking at the
Xlast two characters of how 
X.I troff2ps 
Xwas invoked.
XFor example, "troff2ps -dlj" will generate Laserjet output.
X.P
XThe
X.B -D
Xoption generates scads of diagnostic output in a file called "diagnostics"
Xin the current directory.
XWarning: this file has been known to grow over a megabyte on less than 10
Xpages, so be careful.
X.P
XThe
X.B -V
Xoption causes
X.I troff2ps
Xto print a version message and quit.
X.P
XA trailer page of statistics can be generated by using the
X.B -m
Xoption provided that the driver supports it.
X.SH "SPECIAL REQUESTS"
X.BI troff2 xx
Xsupports a number of additional features over and above bare
X.IR troff .
XThe file tmac.t2 contains a series of macro definitions, 
X(these macros are recommended for use as a replacement for "-mm" with
X.IR psroff )
Xcontains a macro called "\fB.sR\fP".
XThis macro is used to send special requests to the printer driver.
XThe macro is invoked with the following arguments:
X.sp
X.nf
X\&.sR "<func><arg><arg>..."
X.fi
X.sp
X.P
XWhere 
X.I func 
Xis a single letter function code.
X.I arg 
Xis an argument to the function - the number of arguments a function
Xtakes is dependent on the function.
X.ta 1.2i
X.in +1.2i
X.ti -1i
XFunction	Meaning
X.sp
X.ti -1i
XO<name>	Overlay - use "name" as the name of an overlay file.
XMore than one can be specified by separating by blanks.
XThe overlay is typically a name from the printer-specific library.
XEg: "Confidential" is the name for the confidential overlay.
XNot supported in Laserjet driver.
X.sp
X.ti -1i
XFna	Switch troff font (n) 1..4 to driver font (a) A..O.
XSupported by Laserjet filter inasmuch as the LJ doesn't download fonts.
X.sp
X.ti -1i
XI<file>	Include the file specified as the single argument into the driver
Xoutput.
XThe driver type is appended onto the end of the file name.
XEg: with the Postscript driver,
X".sR Ifoo"
Xbecomes an inclusion of "foo.ps".
X.RI troff2 xx
Xwill read the file from the current directory if it exists there, otherwise
Xfrom the troff2 library directory.
X.sp
XThese are not
X.I troff
Xinclusions - they are interpreted only by
X.RI troff2 xx.
XThis is how the libraries are loaded.
XSee the section on libraries on how to write library files.
X.sp
X.ti -1i
Xi	Same as "I", except that no translations are done whatsover,
Xallowing you to enter binary files in the driver's output stream.
X.sp
X.ti -1i
XB	Bin selection.
XNot supported yet, but stubs exist.
X.in -1.2i
X.SH "LIBRARY FILES"
X.I Troff2ps
Xsupports the inclusion of printer-specific files both through explicit
Xinclusions in your
X.I troff
Xfiles, as well as including a standard prolog in a printer-independent
Xfashion.
X.I troff2xx
Xloads the file
X.RI lib. xx ,
Xwhere
X.I xx
Xis the printer type selected.
XEg: "lib.ps" for PostScript, or "lib.lj" for LaserJet.
XWith an include directive (either "I" or "i" with ".sR"), 
X.I troff2xx
Xwill append the suffix to the file name before searching for the file.
X.P
XFiles are searched for in the current directory first, then the
X.I troff2xx
Xlibrary directory second.
X.P
XThe scanning of normal include files is done by stripping all comments
X(prefixed by "%") and all whitespace (in lj driver, not neccessary for
XPostScript).
XSee the comment in the lib.lj file for more details.
XWithin the lib files you can recursively include other files as well by
Xusing "%%%include filename".
X.P
XThe "i" include form (.sR macro) or "%%%binclude filename" form (inside
Xa library file) does the same thing, except that the file included is
Xsimply copied, no translations are done.
X.SH FILES
X.if t .ta 2i
X.if n .ta 3i
X/usr/lib/troff2	Troff2ps library directory
X.br
X/usr/lib/troff2/*.ps	Postscript libraries
X.br
X/usr/lib/troff2/*.lj	HP Laserjet libraries
X.SH BUGS
XDue to the nature by which special sequences are transmitted by
Xtroff (stderr, forced into stdin by
X.IR psroff ),
Xnormal troff errors will not be seen and may generate a few
X"invalid opcode" messages from troff2ps.
XNormally the document will be truncated if this occurs.
XIf this happens, run
X.I troff
Xwith the same arguments you gave to
X.I psroff
Xexcept that you should redirect the standard output to /dev/null, and
Xgive the "-t" option.
X.P
XUnfortunately, there is no way at present for the ".sR" macro to
Xchange fonts within a line - for some pretty bizarre reasons if you ask
Xme.
XNever mind.
XAsk me if you want more information.
X.SH "SEE ALSO"
Xtroff(1), psroff(1L).
X.SH AUTHOR
XChris Lewis (...lsuc!gate!eci386!clewis or clewis@eci386)
END_OF_FILE
if test 5942 -ne `wc -c <'troff2ps.1'`; then
    echo shar: \"'troff2ps.1'\" unpacked with wrong size!
fi
# end of 'troff2ps.1'
fi
echo shar: End of archive 3 \(of 6\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    echo "Read README to install psroff"
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

