Subject:  v20i036:  Troff upgrade for PostScript, DiTroff compatibility, Part04/06
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Chris Lewis <eci386!clewis@uunet.uu.net>
Posting-number: Volume 20, Issue 36
Archive-name: psroff/part04

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 6)."
# Contents:  genftable.ps lib.ps lj.c troff2.c
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'genftable.ps' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'genftable.ps'\"
else
echo shar: Extracting \"'genftable.ps'\" \(13536 characters\)
sed "s/^X//" >'genftable.ps' <<'END_OF_FILE'
X%!
X% genftable - Postcript program to produce font tables for ditroff.
X%	      Tables are output on the standard output file - which
X%	      needs to be captured by the host computer.
X%
X%	      Note the routine "commondefs" which outputs local
X%	      defined (hand built) characters.
X%
X% Michael Rourke, University of N.S.W., Australia
X% (included in troff2: 1.2 89/08/25)
X
X/t 30 string def
X
X(Starting genftable.ps\n) print
X
X/ps
X% string ->
X{
X	print
X} def
X
X/pr
X% any -->
X{
X	t cvs ps
X} def
X
X/prsp
X{
X	(\t) ps
X} def
X
X/prnl
X{
X	(\n) ps
X} def
X
X/pro
X% int -->
X{
X	dup 0 eq
X	{ pr }
X	{ dup 8 idiv pro 8 mod pr }
X	ifelse
X} def
X
X/charsize
X% string --> bot top
X{
X	gsave
X	newpath 0 0 moveto false charpath flattenpath pathbbox
X	exch pop 3 -1 roll pop
X	grestore
X} def
X
X/strwidth
X% string --> width
X{
X	stringwidth pop round cvi
X} def
X
X/prsize
X% string -->
X{
X	dup strwidth pr prsp
X	dup charsize
X	top gt { 2 } { 0 } ifelse
X	exch bot lt { 1 or } if
X	pr prsp
X	0 get pro 
X} def
X
X/fontinfo
X% fontname troffinternal troffname
X{
X	(\ncat <<"!" > ) ps dup pr prnl
X	(# ) ps 2 index pr prnl
X	(name ) ps pr prnl
X	(internalname ) ps pr prnl
X	dup findfont 100 scalefont setfont
X	/fixedwidth false def
X	/Symbol eq
X	{
X		/actions symbol-encoding def
X		(special\n) ps
X	}
X	{
X		/actions standard-encoding def
X		currentfont /FontInfo get /isFixedPitch get
X		{
X			(# fixed width\n) ps
X			/fixedwidth true def
X		}
X		{
X			(ligatures fi fl ff ffi ffl 0\n) ps
X		}
X		ifelse
X	}
X	ifelse
X	% use "o" to get top and bottom on a normal char
X	(o) charsize /top exch def /bot exch def
X	% some non ascending chars slightly higher than "o"
X	% and some lower so adjust slightly
X	/top top 2 add def
X	/bot bot 4 sub def
X	/encoding currentfont /Encoding get def
X	/s 1 string def
X	0 1 255
X	{
X		s 0 2 index put
X		encoding exch get dup /.notdef ne
X		{
X			s 1 index actions exch get
X			% charname charstr
X			exec
X			flush
X		}
X		{
X			pop
X		}		
X		ifelse
X	} for
X	actions standard-encoding eq { commondefs } if
X	(!\n) ps flush
X} def
X
X/commondefs
X{
X	/fracsize (0) strwidth (\244) strwidth add def		% \244 = '/'
X	/Fisize (f) strwidth (\256) strwidth add 5 sub def	% \256 = 'fi'
X	/ffsize (f) strwidth 2 mul 5 sub def
X	/fl { flush } def
X	fixedwidth not
X	{
X		(ff) ps prsp ffsize pr (\t2\t0100\tff ligature - faked\n) ps fl
X		(Fi) ps prsp Fisize pr (\t2\t0100\tffi ligature - faked\n) ps fl
X		(Fl) ps prsp Fisize pr (\t2\t0100\tffl ligature - faked\n) ps fl
X	} if
X	(12) ps prsp fracsize pr (\t2\t0100\t1/2 - faked\n) ps fl
X	(13) ps prsp fracsize pr (\t2\t0100\t1/3 - faked\n) ps fl
X	(14) ps prsp fracsize pr (\t2\t0100\t1/4 - faked\n) ps fl
X	(18) ps prsp fracsize pr (\t2\t0100\t1/8 - faked\n) ps fl
X	(23) ps prsp fracsize pr (\t2\t0100\t2/3 - faked\n) ps fl
X	(34) ps prsp fracsize pr (\t2\t0100\t3/4 - faked\n) ps fl
X	(38) ps prsp fracsize pr (\t2\t0100\t3/8 - faked\n) ps fl
X	(58) ps prsp fracsize pr (\t2\t0100\t5/8 - faked\n) ps fl
X	(78) ps prsp fracsize pr (\t2\t0100\t7/8 - faked\n) ps fl
X	(sq\t100\t3\t0100\tsquare box - faked\n) ps fl
X} def
X
X/space
X% charname charstr -->
X{
X	(spacewidth ) ps
X	strwidth pr pop prnl
X	(charset\n) ps
X} def
X
X/norm
X% charname charstr -->
X{
X	dup pr prsp prsize pop prnl
X} def
X
X/normdup
X% charname charstr dupname -->
X{
X	3 1 roll norm
X	pr prsp (") ps prnl
X} def
X
X/gnorm
X% charname charstr -->
X{
X	(*) ps norm
X} def
X
X/map
X% charname charstr mapname -->
X{
X	pr prsp prsize prsp pr prnl
X} def
X
X/mapdup
X% charname charstr mapname dupname -->
X{
X	4 1 roll map
X	pr prsp (") ps prnl
X} def
X
X/mapdupdup
X% charname charstr mapname dupname dupname -->
X{
X	5 1 roll mapdup
X	pr prsp (") ps prnl
X} def
X
X/cmap
X% charname charstr mapname -->
X{
X	fixedwidth { 3 { pop } repeat } { map } ifelse
X} def
X
X/standard-encoding 149 dict def
Xstandard-encoding begin
X	/space		{ space }		def
X	/exclam		{ norm }		def
X	/quotedbl	{ norm }		def
X	/numbersign	{ norm }		def
X	/dollar		{ norm }		def
X	/percent	{ norm }		def
X	/ampersand	{ norm }		def
X	/quoteright	{ norm }		def
X	/parenleft	{ norm }		def
X	/parenright	{ norm }		def
X	/asterisk	{ norm }		def
X	/plus		{ norm }		def
X	/comma		{ norm }		def
X	/hyphen		{ (hy) normdup }	def
X	/period		{ norm }		def
X	/slash		{ (sl) dup }		def
X	/zero		{ norm }		def
X	/one		{ norm }		def
X	/two		{ norm }		def
X	/three		{ norm }		def
X	/four		{ norm }		def
X	/five		{ norm }		def
X	/six		{ norm }		def
X	/seven		{ norm }		def
X	/eight		{ norm }		def
X	/nine		{ norm }		def
X	/colon		{ norm }		def
X	/semicolon	{ norm }		def
X	/less		{ norm }		def
X	/equal		{ norm }		def
X	/greater	{ norm }		def
X	/question	{ norm }		def
X	/at		{ norm }		def
X	/A		{ norm }		def
X	/B		{ norm }		def
X	/C		{ norm }		def
X	/D		{ norm }		def
X	/E		{ norm }		def
X	/F		{ norm }		def
X	/G		{ norm }		def
X	/H		{ norm }		def
X	/I		{ norm }		def
X	/J		{ norm }		def
X	/K		{ norm }		def
X	/L		{ norm }		def
X	/M		{ norm }		def
X	/N		{ norm }		def
X	/O		{ norm }		def
X	/P		{ norm }		def
X	/Q		{ norm }		def
X	/R		{ norm }		def
X	/S		{ norm }		def
X	/T		{ norm }		def
X	/U		{ norm }		def
X	/V		{ norm }		def
X	/W		{ norm }		def
X	/X		{ norm }		def
X	/Y		{ norm }		def
X	/Z		{ norm }		def
X	/bracketleft	{ norm }		def
X	/backslash	{ norm }		def
X	/bracketright	{ norm }		def
X	/asciicircum	{ (a^) map }		def
X	/underscore	{ (ru) normdup }	def
X	/quoteleft	{ norm }		def
X	/a		{ norm }		def
X	/b		{ norm }		def
X	/c		{ norm }		def
X	/d		{ norm }		def
X	/e		{ norm }		def
X	/f		{ norm }		def
X	/g		{ norm }		def
X	/h		{ norm }		def
X	/i		{ norm }		def
X	/j		{ norm }		def
X	/k		{ norm }		def
X	/l		{ norm }		def
X	/m		{ norm }		def
X	/n		{ norm }		def
X	/o		{ norm }		def
X	/p		{ norm }		def
X	/q		{ norm }		def
X	/r		{ norm }		def
X	/s		{ norm }		def
X	/t		{ norm }		def
X	/u		{ norm }		def
X	/v		{ norm }		def
X	/w		{ norm }		def
X	/x		{ norm }		def
X	/y		{ norm }		def
X	/z		{ norm }		def
X	/braceleft	{ norm }		def
X	/bar		{ norm }		def
X	/braceright	{ norm }		def
X	/asciitilde	{ (a~) map }		def
X	/exclamdown	{ (I!) map }		def
X	/cent		{ (ct) map }		def
X	/sterling	{ (po) map }		def
X	/fraction	{ }			def
X	/yen		{ ($J) map }		def
X	/florin		{ }			def
X	/section	{ (sc) map }		def
X	/currency	{ }			def
X	/quotesingle	{ (fm) (n') mapdup }	def
X	/quotedblleft	{ (lq) map }		def
X	/guillemotleft	{ (d<) map }		def
X	/guilsinglleft	{ (l<) map }		def
X	/guilsinglright	{ (r>) map }		def
X	/fi		{ (fi) cmap }		def
X	/fl		{ (fl) cmap }		def
X	/endash		{ (\\-) map }		def
X	/dagger		{ (dg) map }		def
X	/daggerdbl	{ (dd) map }		def
X	/periodcentered	{ }			def
X	/paragraph	{ (pp) map }		def
X	/bullet		{ (bu) map }		def
X	/quotesinglbase	{ } 			def
X	/quotedblbase	{ }			def
X	/quotedblright	{ (rq) map }		def
X	/guillemotright	{ (d>) map }		def
X	/ellipsis	{ }			def
X	/perthousand	{ (pm) cmap }		def
X	/questiondown	{ (I?) map }		def
X	/grave		{ (ga) (\\`) mapdup }	def
X	/acute		{ (aa) (\\') mapdup }	def
X	/circumflex	{ (^) map }		def
X	/tilde		{ (~) map }		def
X	/macron		{ (ma) map }		def
X	/breve		{ (be) map }		def
X	/dotaccent	{ (dt) map }		def
X	/dieresis	{ (..) (um) mapdup }	def
X	/ring		{ (ri) map }		def
X	/cedilla	{ (cd) map }		def
X	/hungarumlaut	{ ('') map }		def
X	/ogonek		{ (og) map }		def
X	/caron		{ (hc) map }		def
X	/emdash		{ (em) map }		def
X	/AE		{ (AE) cmap }		def
X	/ordfeminine	{ }			def
X	/Lslash		{ (PL) map }		def
X	/Oslash		{ (O/) map }		def
X	/OE		{ (OE) cmap }		def
X	/ordmasculine	{ }			def
X	/ae		{ (ae) cmap }		def
X	/dotlessi	{ (ui) map }		def
X	/lslash		{ (Pl) map }		def
X	/oslash		{ (o/) map }		def
X	/oe		{ (oe) cmap }		def
X	/germandbls	{ (ss) map }		def
Xend
X
X/symbol-encoding 189 dict def
Xsymbol-encoding begin
X	/space		{ space }		def
X	/exclam		{ norm }		def
X	/universal	{ (fa) map }		def
X	/numbersign	{ norm }		def
X	/existential	{ (te) map }		def
X	/percent	{ norm }		def
X	/ampersand	{ norm }		def
X	/suchthat	{ (cm) map }		def
X	/parenleft	{ norm }		def
X	/parenright	{ norm }		def
X	/asteriskmath	{ (**) map }		def
X	/plus		{ (pl) map }		def
X	/comma		{ norm }		def
X	/minus		{ (mi) normdup }	def
X	/period		{ norm }		def
X	/slash		{ (sl) map }		def
X	/zero		{ norm }		def
X	/one		{ norm }		def
X	/two		{ norm }		def
X	/three		{ norm }		def
X	/four		{ norm }		def
X	/five		{ norm }		def
X	/six		{ norm }		def
X	/seven		{ norm }		def
X	/eight		{ norm }		def
X	/nine		{ norm }		def
X	/colon		{ norm }		def
X	/semicolon	{ norm }		def
X	/less		{ norm }		def
X	/equal		{ (eq) normdup }	def
X	/greater	{ norm }		def
X	/question	{ norm }		def
X	/congruent	{ (=~) map }		def
X	/Alpha		{ gnorm }		def
X	/Beta		{ gnorm }		def
X	/Chi		{ (*X) map }		def
X	/Delta		{ gnorm }		def
X	/Epsilon	{ gnorm }		def
X	/Phi		{ gnorm }		def
X	/Gamma		{ gnorm }		def
X	/Eta		{ (*Y) map }		def
X	/Iota		{ gnorm }		def
X	/theta1		{ }			def
X	/Kappa		{ gnorm }		def
X	/Lambda		{ gnorm }		def
X	/Mu		{ gnorm }		def
X	/Nu		{ gnorm }		def
X	/Omicron	{ gnorm }		def
X	/Pi		{ gnorm }		def
X	/Theta		{ (*H) map }		def
X	/Rho		{ gnorm }		def
X	/Sigma		{ gnorm }		def
X	/Tau		{ gnorm }		def
X	/Upsilon	{ gnorm }		def
X	/sigma1		{ (ts) map }		def
X	/Omega		{ (*W) map }		def
X	/Xi		{ (*C) map }		def
X	/Psi		{ (*Q) map }		def
X	/Zeta		{ gnorm }		def
X	/bracketleft	{ norm }		def
X	/therefore	{ (tf) map }		def
X	/bracketright	{ norm }		def
X	/perpendicular	{ (bt) map }		def
X	/underscore	{ (ul) map }		def
X	/radicalex	{ }			def
X	/alpha		{ gnorm }		def
X	/beta		{ gnorm }		def
X	/chi		{ (*x) map }		def
X	/delta		{ gnorm }		def
X	/epsilon	{ gnorm }		def
X	/phi		{ gnorm }		def
X	/gamma		{ gnorm }		def
X	/eta		{ (*y) map }		def
X	/iota		{ gnorm }		def
X	/phi1		{ }			def
X	/kappa		{ gnorm }		def
X	/lambda		{ gnorm }		def
X	/mu		{ gnorm }		def
X	/nu		{ gnorm }		def
X	/omicron	{ gnorm }		def
X	/pi		{ gnorm }		def
X	/theta		{ (*h) map }		def
X	/rho		{ gnorm }		def
X	/sigma		{ gnorm }		def
X	/tau		{ gnorm }		def
X	/upsilon	{ gnorm }		def
X	/omega1		{ }			def
X	/omega		{ (*w) map }		def
X	/xi		{ (*c) map }		def
X	/psi		{ (*q) map }		def
X	/zeta		{ gnorm }		def
X	/braceleft	{ norm }		def
X	/bar		{ (or) normdup }	def
X	/braceright	{ norm }		def
X	/similar	{ (ap) map }		def
X	/Upsilon1	{ }			def
X	/minute		{ (mt) map }		def
X	/lessequal	{ (<=) map }		def
X	/fraction	{ (/) map }		def
X	/infinity	{ (if) map }		def
X	/florin		{ }			def
X	/club		{ (Cc) map }		def
X	/diamond	{ (Cd) map }		def
X	/heart		{ (Ch) map }		def
X	/spade		{ (Cs) map }		def
X	/arrowboth	{ (<>) map }		def
X	/arrowleft	{ (<-) map }		def
X	/arrowup	{ (ua) map }		def
X	/arrowright	{ (->) map }		def
X	/arrowdown	{ (da) map }		def
X	/degree		{ (de) map }		def
X	/plusminus	{ (+-) map }		def
X	/second		{ (sd) map }		def
X	/greaterequal	{ (>=) map }		def
X	/multiply	{ (mu) map }		def
X	/proportional	{ (pt) map }		def
X	/partialdiff	{ (pd) map }		def
X	/bullet		{ }			def
X	/divide		{ (di) map }		def
X	/notequal	{ (!=) map }		def
X	/equivalence	{ (==) map }		def
X	/approxequal	{ (~=) map }		def
X	/ellipsis	{ }			def
X	/arrowvertex	{ }			def
X	/arrowhorizex	{ }			def
X	/carriagereturn	{ (cr) map }		def
X	/aleph		{ (al) map }		def
X	/Ifraktur	{ }			def
X	/Rfraktur	{ }			def
X	/weierstrass	{ }			def
X	/circlemultiply	{ (ax) map }		def
X	/circleplus	{ (a+) map }		def
X	/emptyset	{ (es) map }		def
X	/intersection	{ (ca) map }		def
X	/union		{ (cu) map }		def
X	/propersuperset	{ (sp) map }		def
X	/reflexsuperset	{ (ip) map }		def
X	/notsubset	{ (!s) map }		def
X	/propersubset	{ (sb) map }		def
X	/reflexsubset	{ (ib) map }		def
X	/element	{ (mo) map }		def
X	/notelement	{ (!m) (nm) mapdup }	def
X	/angle		{ (ag) map }		def
X	/gradient	{ (gr) map }		def
X	/registerserif	{ }			def
X	/copyrightserif	{ }			def
X	/trademarkserif	{ }			def
X	/product	{ }			def
X	/radical	{ (sr) map }		def
X	/dotmath	{ (m.) map }		def
X	/logicalnot	{ (no) map }		def
X	/logicaland	{ (an) (la) mapdup }	def
X	/logicalor	{ (lo) map }		def
X	/arrowdblboth	{ (io) map }		def
X	/arrowdblleft	{ (<:) (lh) mapdup }	def
X	/arrowdblup	{ (u=) map }		def
X	/arrowdblright	{ (:>) (rh) (im) mapdupdup } def
X	/arrowdbldown	{ (d=) map }		def
X	/lozenge	{ (dm) map }		def
X	/angleleft	{ (L<) map }		def
X	/registersans	{ (rg) map }		def
X	/copyrightsans	{ (co) map }		def
X	/trademarksans	{ (tm) map }		def
X	/summation	{ }			def
X	/parenlefttp	{ }			def
X	/parenleftex	{ }			def
X	/parenleftbt	{ }			def
X	/bracketlefttp	{ }			def
X	/bracketleftex	{ }			def
X	/bracketleftbt	{ }			def
X	/bracelefttp	{ }			def
X	/braceleftmid	{ }			def
X	/braceleftbt	{ }			def
X	/braceex	{ }			def
X	/apple		{ (AL) map }		def
X	/angleright	{ (R>) map }		def
X	/integral	{ (is) map }		def
X	/integraltp	{ }			def
X	/integralex	{ }			def
X	/integralbt	{ }			def
X	/parenrighttp	{ }			def
X	/parenrightex	{ }			def
X	/parenrightbt	{ }			def
X	/bracketrighttp	{ }			def
X	/bracketrightex	{ }			def
X	/bracketrightbt	{ }			def
X	/bracerighttp	{ }			def
X	/bracerightmid	{ }			def
X	/bracerightbt	{ }			def
Xend
X
X/Times-Roman		/Roman		/R	fontinfo
X/Helvetica		/Helvetica	/H	fontinfo
X/Courier		/Courier	/C	fontinfo
X/Symbol			/Symbol		/S	fontinfo
X/Times-Italic		/Italic		/I	fontinfo
X/Times-Bold		/Bold		/B	fontinfo
X/Times-BoldItalic	/BoldI		/BI	fontinfo
X/Helvetica-Bold		/HelveticaB	/HB	fontinfo
X/Helvetica-Oblique	/HelveticaO	/HO	fontinfo
X/Helvetica-BoldOblique	/HelveticaBO	/HX	fontinfo
X/Courier-Bold		/CourierB	/CB	fontinfo
X/Courier-Oblique	/CourierO	/CO	fontinfo
X/Courier-BoldOblique	/CourierBO	/CX	fontinfo
X/Helvetica-Narrow	/HelvNarHn	/Hn	fontinfo
X/Helvetica-Narrow-Oblique /HelvNarHo	/Ho	fontinfo
X/Helvetica-Narrow-BoldOblique	/HelvNarHx	/Hx	fontinfo
X/ZapfChancery-MediumItalic	/ZapfC	/ZC	fontinfo
X/AvantGarde-Book	/AvantAR	/AR	fontinfo
X/AvantGarde-BookOblique	/AvantAX	/AX	fontinfo
X/AvantGarde-Demi	/AvantAB	/AB	fontinfo
X/AvantGarde-DemiItalic	/AvantAI	/AI	fontinfo
X/Palatino-Roman	/PalatPR	/PR	fontinfo
X/Palatino-Bold	/PalatPB	/PB	fontinfo
X/Palatino-BoldItalic /PalatPX	/PX	fontinfo
X/Palatino-Italic /PalatPI	/PI	fontinfo
X/NewCenturySchlbk-Bold		/NB	fontinfo
X/NewCenturySchlbk-BoldItalic	/NX	fontinfo
X/NewCenturySchlbk-Italic	/NI	fontinfo
X/NewCenturySchlbk-Roman		/NR	fontinfo
END_OF_FILE
if test 13536 -ne `wc -c <'genftable.ps'`; then
    echo shar: \"'genftable.ps'\" unpacked with wrong size!
fi
# end of 'genftable.ps'
fi
if test -f 'lib.ps' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib.ps'\"
else
echo shar: Extracting \"'lib.ps'\" \(9920 characters\)
sed "s/^X//" >'lib.ps' <<'END_OF_FILE'
X%	Copyright 1985, 1986, 1987, 1988 Chris Lewis
X%		All Rights Reserved
X%
X%    Permission to copy and further distribute is freely given provided 
X%    this copyright notice remains intact and that this software is not 
X%    sold for profit.
X%
X%	Project:	Generic Troff drivers
X%	Module:		lib.ps
X%	Author: 	Chris Lewis
X%	Specs:		Predefinitions for PostScript
X%ident  @(#)lib.ps: 1.16 Copyright 89/07/04 16:59:33 Chris Lewis"
X
X/Y { 3 1 roll dup /CurY exch def moveto show } def
X/X { exch CurY moveto show } def
X
X/Hits	10 string def
XHits 0 0 1 string cvs putinterval
X/Misses	10 string def
XMisses 0 0 1 string cvs putinterval
X
X/drawfraction {
X    /denominator exch def
X    /numerator exch def
X    /origY exch def
X    /origX exch def
X    origX curPoints 4 div add origY moveto
X    (/) show
X    curFont findfont curPoints .5 mul cvi scalefont setfont
X    origX origY curPoints 4 div add moveto
X    numerator show
X    origX curPoints 2 div add origY moveto
X    denominator show
X    curFont findfont curPoints scalefont setfont
X    origX origY moveto
X} def
X
X/mySetLineWidth {
X    curPoints 3 72 div mul setlinewidth
X} def
X
X/do12 {
X    (1) (2) drawfraction
X} def
X
X/do14 {
X    (1) (4) drawfraction
X} def
X
X/do34 {
X    (3) (4) drawfraction
X} def
X
X/doff {
X    moveto
X    (f) show curPoints 20 div neg 0 rmoveto (f) show
X} def
X
X/doFi {
X    moveto
X    (f) show curPoints 20 div neg 0 rmoveto (\256) show
X} def
X
X/doFl {
X    moveto
X    (f) show curPoints 20 div neg 0 rmoveto (\257) show
X} def
X
X%	This should be sort of a font-caching mechanism - eg:
X%	remember each font/point combination requested, and
X%	if the setting is not already known, *then* do the findfont/scalefont.
X%	Otherwise, simply retrieve it.
X%	However, even with simply recalculating the font each time, it
X%	isn't *that* slow.  Eg: 20 seconds or so for *very* "font-changy"
X%	pages.
X%
X%	Trial font cache - I can't think in Polish... ;-)
X/SetFont {
X    /curPoints exch def
X    /curFont exch def
X    %	Concatenate the curFont string with the curPoints to create
X    %	a new name and assign to cF
X
X    /cF 50 string def 
X
X    cF 0
X	    cF curFont cF cvs		% cF 0 string "curFont"
X	    length dup			% cF 0 "curFont\0\0..." N N
X	    curPoints 10 string cvs	% cF 0 "curFont\0\0..." N N "points"
X	    dup length			% cF 0 "curFont\0\0..." N N "points" M
X	    3 -1 roll add		% cF 0 "curFont\0\0..." N "points" M+N
X	    4 1 roll			% cF 0 M+N "curFont\0\0..." N "points"
X	    putinterval			% cF 0 M+N    (cF <- "curFontpoints")
X    getinterval				% "curFontpoints"
X
X    /cF exch def
X    cF
X    cvn					% /curFontpoints
X
X    where {
X	/hits hits 1 add def
X	pop 
X    } {
X	/misses misses 1 add def
X	cF curFont findfont curPoints scalefont def
X    } ifelse
X    cF load setfont
X} def
X
X/docircle {
X    /origY exch def
X    /origX exch def
X    /radius curPoints 3 div def
X    newpath origX radius add origY radius add radius 0 360 arc 
X    mySetLineWidth
X    stroke
X    origX origY moveto
X} def
X
X/doru {
X    moveto
X    0 curPoints 5 div rmoveto (_) show
X} def
X
X/do34em {
X    /origY exch def
X    /origX exch def
X    /emheight curPoints .23 mul def
X    newpath
X    origX origY emheight add moveto
X    origX curPoints .75 mul add origY emheight add lineto
X    mySetLineWidth
X    stroke
X    origX origY moveto
X} def
X
X/dosq {
X    /origY exch def
X    /origX exch def
X    /L (M) stringwidth pop 3 div def
X    newpath
X    origX origY moveto
X    origX origY L add lineto
X    origX L add origY L add lineto
X    origX L add origY lineto
X    closepath
X    mySetLineWidth
X    stroke
X    origX origY moveto
X} def
X
X/dobox {
X    /origY exch def
X    /origX exch def
X    /L curPoints def
X    newpath
X    origX origY moveto
X    origX origY L add lineto
X    origX L add origY L add lineto
X    origX L add origY lineto
X    closepath
X    1 setlinewidth
X    stroke
X    origX origY moveto
X} def
X
X
X/fourpops {
X    4 {pop} repeat
X} def
X
X%	These are macros so that they can be redefined.
X%	print current page.
X/ShowPage {
X    Misses dup cvi misses add 10 string cvs 0 exch putinterval
X    Hits dup cvi hits add 10 string cvs 0 exch putinterval
X    showpage
X} def
X
X%	Emitted at beginning of page.
X/StartPage {
X    /hits 0 def
X    /misses 0 def
X    Form
X} def
X
X%	If you want to define a Bell System Logo, go ahead.  This
X%	one draws an animal (ferret) face
X%	Object should be scaled off of curPoints, with origX,origY
X%	lower left coordinates.
X/BellSymbol {
X    /origY exch def
X    /origX exch def
X    /TEMPSAVE save def
X
X    /Radius curPoints 2 div def	% Face Radius
X    /HRadius Radius 2 div def	% Half Face Radius
X    /NRadius Radius 6 div def	% Nose Radius
X    /ERadius Radius 8 div def	% Eye Radius
X    /EarRadius Radius 3 div def	% Ear Radius
X    /FaceType (Ferret) def
X
X    /MRadius Radius 4 div def	% Mask corner radius
X    /TopMask Radius .7 mul def	% XCent & YCent max delta
X    /BotMask NRadius 1.1 mul def % YCent min delta
X
X    /XCent origX Radius add def
X    /YCent origY Radius add def
X
X    newpath
X    %	Main face
X    XCent YCent Radius 0 360 arc mySetLineWidth stroke
X    %	Nose
X    XCent YCent NRadius 0 360 arc fill
X    %	Left Ear
X    XCent Radius 45 sin mul sub 
X	YCent Radius 45 sin mul add EarRadius 20 250 arc mySetLineWidth stroke
X    %	Right Ear
X    XCent Radius 45 sin mul add 
X	YCent Radius 45 sin mul add EarRadius -70 160 arc mySetLineWidth stroke
X    %	Cleft
X    XCent YCent NRadius sub moveto
X    XCent YCent HRadius sub lineto 
X    mySetLineWidth stroke
X
X    %	Mouth
X    XCent HRadius 45 sin mul sub YCent HRadius 45 sin mul sub moveto
X    XCent HRadius 30 sin mul sub YCent HRadius sub lineto
X    XCent HRadius 30 sin mul add YCent HRadius sub lineto
X    XCent HRadius 45 sin mul add YCent HRadius 45 sin mul sub lineto
X    mySetLineWidth stroke
X
X    FaceType (Ferret) eq {
X	%	Mask
X	.6 setgray
X	XCent TopMask sub YCent BotMask add YCent TopMask add add 2 div moveto
X
X	XCent TopMask sub YCent TopMask add 
X	    XCent TopMask add YCent TopMask add
X	    MRadius arcto fourpops
X	XCent TopMask add YCent TopMask add
X	    XCent TopMask add YCent BotMask add
X	    MRadius arcto fourpops
X	XCent TopMask add YCent BotMask add
X	    XCent TopMask sub YCent BotMask add
X	    MRadius arcto fourpops
X	XCent TopMask sub YCent BotMask add
X	    XCent TopMask sub YCent TopMask add 
X	    MRadius arcto fourpops
X	fill
X
X	0 setgray
X    } if
X	
X    %	Eyes
X    XCent HRadius add YCent HRadius add ERadius 0 360 arc fill
X    XCent HRadius sub YCent HRadius add ERadius 0 360 arc fill
X    TEMPSAVE restore
X    origX origY moveto
X} def
X
X%	bracket building font
X%!
X%
X% Michael Rourke, University of N.S.W., Australia
X%
X/BracketFontDict 9 dict def /$workingdict 10 dict def
XBracketFontDict begin
X/FontType 3 def
X/FontName (Bracket) cvn def
X/FontMatrix [ 0.001 0 0 0.001 0 0] def
X/FontBBox [ -50 -250 1000 1000 ] def
X/Encoding 256 array def 0 1 255 { Encoding exch /.notdef put } for
XEncoding
Xdup 65 /Cbv put	%A
Xdup 66 /Clt put	%B
Xdup 67 /Clk put	%C
Xdup 68 /Clb put	%D
Xdup 69 /Crt put	%E
Xdup 70 /Crk put	%F
Xdup 71 /Crb put	%G
Xdup 72 /Clc put	%H
Xdup 73 /Clf put	%I
Xdup 74 /Crc put	%J
Xdup 75 /Crf put	%K
Xdup 76 /Cbr put	%L
Xdup 77 /Crn put	%M
Xdup 78 /Cci put	%N
Xdup 79 /Cru put	%O
Xpop
X/CharProcs 24 dict dup begin
X/setC { 0 -50 -250 500 1000 setcachedevice} def
X/C.bv {220 -250 moveto 0 1000 rlineto
X60 0 rlineto 0 -1000 rlineto fill } def
X/C.barc { 750 moveto 180 0 rlineto 0 -60 rlineto -180 0 rlineto fill } def
X/C.barf { -250 moveto 180 0 rlineto 0 60 rlineto -180 0 rlineto fill } def
X/C.brk.end { 1 setlinewidth moveto rlineto rcurveto
Xreversepath 60 0 rlineto rlineto rcurveto fill } def
X/C.setl {dup dtransform exch round exch idtransform pop setlinewidth } def
X/Cbv {
X300 setC
XC.bv
X} def
X/Clt {
X300 setC
X  0 150 50 210 140 250   0 730  0 150 50 250 200 250   0 750   220 -250   C.brk.end
X} def
X/Clk {
X300 setC
X  1 setlinewidth  220 -250 moveto  0 400 rlineto  0 50 -50 100 -100 100 rcurveto  50 0 100 50 100 100 rcurveto  0 400 rlineto  60 0 rlineto  0 -400 rlineto  0 -50 -50 -100 -100 -100 rcurveto  50 0 100 -50 100 -100 rcurveto  0 -400 rlineto  closepath fill
X} def
X/Clb {
X300 setC
X  0 -150 50 -210 140 -250   0 -730  0 -150 50 -250 200 -250   0 -750   220 750   C.brk.end
X} def
X/Crt {
X300 setC
X  0 150 -50 250 -200 250   0 750   0 150 -50 210 -140 250   0 730  220 -250   C.brk.end
X} def
X/Crk {
X300 setC
X  1 setlinewidth  220 -250 moveto  0 400 rlineto  0 50 50 100 100 100 rcurveto  -50 0 -100 50 -100 100 rcurveto  0 400 rlineto  60 0 rlineto  0 -400 rlineto  0 -50 50 -100 100 -100 rcurveto  -50 0 -100 -50 -100 -100 rcurveto  0 -400 rlineto  fill
X} def
X/Crb {
X300 setC
X  0 -150 -50 -250 -200 -250   0 -750   0 -150 -50 -210 -140 -250   0 -730  220 750   C.brk.end
X} def
X/Clc {
X300 setC
X  C.bv   280   C.barc
X} def
X/Clf {
X300 setC
X  C.bv 280 C.barf
X} def
X/Crc {
X300 setC
X  C.bv 40 C.barc
X} def
X/Crf {
X300 setC
X  C.bv 40 C.barf
X} def
X/Cbr {
X0 0 -50 -250 0 1000 setcachedevice
X  40 C.setl  0 -250 moveto  0 1000 rlineto  stroke
X} def
X/Cru {
X0 0 -50 -250 1000 0 setcachedevice
X  40 C.setl  0 -250 moveto 500 0 rlineto stroke
X} def
X/Crn {
X300 setC
X  40 C.setl  0 895 moveto  500 0 rlineto  stroke
X} def
X/Cci {
X600 0 -50 -250 700 1000 setcachedevice
X  40 C.setl  400 250   300   0 360 arc   stroke
X} def
Xend def
X/BuildChar
X{
X	$workingdict begin
X	/charcode exch def
X	/fontdict exch def
X	fontdict /CharProcs get begin
X	fontdict /Encoding get
X	charcode get load
X	gsave
X	0 setlinecap 0 setgray newpath
X	exec
X	grestore
X	end end
X} def end
X/BracketFont BracketFontDict definefont pop
X
X%	This macro is invoked by ShowPage to display the current form.
X%	Usually redefined to point at a form loaded by an include
X%	directive.  Redefinition triggered by .sR O<formname> troff
X%	directive.
X%	Global default form (usually redefined top of each page anyways)
X/Form {} def
X%	This is a convenient place for putting your extra inclusions.
X%	Eg: this would load conf.ps (from current directory or LIBDIR)
X%	and insert it into the end of the prolog.
X%   This loads the confidential form.
X%%%include confid
X%%%include lethead
END_OF_FILE
if test 9920 -ne `wc -c <'lib.ps'`; then
    echo shar: \"'lib.ps'\" unpacked with wrong size!
fi
# end of 'lib.ps'
fi
if test -f 'lj.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lj.c'\"
else
echo shar: Extracting \"'lj.c'\" \(9120 characters\)
sed "s/^X//" >'lj.c' <<'END_OF_FILE'
X/*	Copyright 1985, 1986, 1987, 1988 Chris Lewis
X		All Rights Reserved
X
X    Permission to copy and further distribute is freely given provided 
X    this copyright notice remains intact and that this software is not 
X    sold for profit.
X
X	Project:	Generic Troff drivers
X	Module:		lj.c
X	Author: 	Chris Lewis
X	Specs:		LaserJet driver, hacked from ps.c and lcat.c
X			(Gosh, this is a lot simpler than lcat's stuff.
X			Thank PostScript for getting my brain in order.)
X
X			Font downloading is supported, but untested as
X			yet.
X			Font downloading is not supported yet, however
X			all of the font selection stuff is.  Therefore,
X			this stuff will actually work if all of the
X			fonts have been previously downloaded...
X			However, the LJ considers different point sizes
X			to be different fonts, so don't expect much....
X
X			Macro "DOWNLOAD" is used to denote places and
X			some coding for font downloading.
X
X			Without font downloading, this is LJ compatible.
X			Font downloading will require a LJ+, LJ500+ or
X			LJ II.
X
X			This code has not been tested - however, it is
X			a derivitive of the original lcat software, so
X			it may actually do things right.  Chances are,
X			any errors are in some of the escape sequence
X			details.  Eg: the stroke-weight parameter may
X			need tweaking.
X
X			Only standardFont bears any resemblance to what it
X			should.  symbolFont is still PostScript.
X
X			The tables have been moved from this file to
X			ljtables.c
X*/
X
X#include "defs.h"
X
X#if	defined(LJ) || defined(LK)
X#include "lj.h"
X
X#define	MAXFONT	50
X
X#ifndef	SVR3
X#ifndef	lint
Xstatic char SCCSid[] = "@(#)lj.c: 1.7 Copyright 89/06/14 17:40:23 Chris Lewis";
X#endif
X#else
X#ident  "@(#)lj.c: 1.7 Copyright 89/06/14 17:40:23 Chris Lewis" /*(SVR3)*/
X#endif
X
X#define	USED	1
X#define	BUILTIN 2
Xstruct ljFts {
X    char *troffName;
X    char *fontSeq;
X    char *ascName;
X    int	 flags;
X} ljFts[MAXFONT+1];
X
Xstruct ljFts *t2ljf[8];
X
X/*	Used for characters not in Roman8 Character set */
X#define	NOPE	"\0374"
XljPage() {
X	printf("\033&l0H");
X	pagePending = 1;
X}
X
Xstatic
XdoPageStart(e) {
X    currentPage++;
X    pagePending = 0;
X}
X
Xstatic int lastFont = (-1), lastPoints = (-1);
Xstatic
Xputoct(s)
Xchar *s; {
X    int d;
X    if (strlen(s) < 3) {
X	fprintf(stderr, "%s: octal sequence in fonts.l[kj] bad\n", progname);
X	exit(1);
X    }
X    d = (*s - '0') * 64 + (*(s+1) - '0') * 8 + *(s+2) - '0';
X    putchar(d);
X}
X
XljSetFont(font, points)
Xint font, points; {
X
X	if (lastPoints != points || font != lastFont) {
X	    register char *p;
X#ifdef	DOWNLOAD
X	    if (!(ljFts[font].flags&(USED|BUILTIN))) {
X		char buf[512];
X		FILE *fontfile;
X		int count;
X		sprintf(buf, "%s/%s.%s.%d", LIBDIR, be->bename,
X		    ljFts[font].troffName, points);
X		if ((fontfile = fopen(buf, "r")) == NULL) {
X		    fprintf(stderr, "%s: Cannot open fontfile %s\n", progname,
X			buf);
X		} else {
X		    while(0 > (count = fread(buf, sizeof(char), 512, fontfile)))
X			fwrite(buf, sizeof(char), count, stdout);
X		    fclose(fontfile);
X		}
X	    }
X#endif
X	    ljFts[font].flags |= USED;
X	    for (p = ljFts[font].fontSeq; *p; p++) {
X		if (*p == '\\') {
X		    putoct(p+1);
X		    p+=3;
X		} else
X		    putchar(*p);
X	    }
X	    printf("\033(s%dV", points);
X	    lastPoints = points;
X	    lastFont = font;
X	}
X
X}
X
XljChar(x, y, font, points, troffChar) 
Xint x, y, font, points, troffChar; {
X	static double lasty = (-1);
X	register double nx = TROFF2LJX(x), ny = TROFF2LJY(y);
X	register struct troff2befont *rp;
X	register char *sequence = "a";
X	double xad, yad;
X	if (pagePending) {
X	    lasty = lastFont = lastPoints = (-1);
X	    doPageStart();
X	}
X
X	DEBUGPRINTF("x,y=%d,%d; font=%d, points=%d, tc=%d\n",
X	    x, y, font, points, troffChar);
X
X	if (font == 3) {
X	    rp = &be->besymfont[troffChar];
X	} else {
X	    rp = &be->bestdfont[troffChar];
X	}
X
X	switch(rp->t2b_font) {
X	    /* Only fonts with "U" are subject to font translation */
X	    case U: 
X		if (font == 3)
X		    font = 0;	/* Special chars are Courier */
X		else {
X		    DEBUGPRINTF("ljSetChar %d->%s (%s)\n", font, 
X			t2ljf[font]->troffName,
X			t2ljf[font]->ascName);
X		    font = t2ljf[font] - ljFts;
X		}
X		break;
X	    case S: 
X		font = 3;
X		break;
X	    case D:
X		break;
X	    default:
X		/* Typically used when the main fonts don't have the
X		   character desired.  Eg: right-hand is in the
X		   ZapfDingbats font */
X		font = rp->t2b_font;
X		break;
X	}
X
X	sequence = rp->t2b_charseq;
X
X	if (!sequence) {
X	    fprintf(stderr, "No coding for %d\n", troffChar);
X	    return;
X	}
X
X	/*	We're committed now */
X
X	points *= rp->t2b_scale;
X	xad = points * rp->t2b_xc;
X	yad = points * rp->t2b_yc;
X	ljSetFont(font, points);
X
X/*	We won't output fractions */
X#define	XYS	"\033&a%.0fh%.0fV%s"
X#define	XS	"\033&a%.0fH%s"
X
X	if (lasty != ny) {
X	    printf(XYS, nx+xad, ny+yad, sequence);
X	    lasty = ny;
X	} else
X	    printf(XS, nx+xad, sequence);
X}
X
Xstatic
Xloadfontdefs(f)
XFILE *f; {
X    struct ljFts *p = ljFts;
X    extern char *malloc();
X    int flags;
X    char rbuf[512], nbuf[512], ljbuf[512], seqbuf[512];
X    while(fgets(rbuf, sizeof(rbuf), f)) {
X	if (rbuf[0] == '#')
X	    continue;
X	switch(sscanf(rbuf, "%s%s%s%d", nbuf, ljbuf, seqbuf, &flags)) {
X	    default:
X		break;
X	    case 4:
X		if (nbuf[0] == '#')
X		    break;
X		if (p - ljFts >= MAXFONT) {
X		    fprintf(stderr, "Too many font definitions in %s\n",
X			be->bename);
X		    exit(1);
X		}
X		p->troffName = malloc(strlen(nbuf) + 1);
X		strcpy(p->troffName, nbuf);
X		p->ascName = malloc(strlen(ljbuf) + 1);
X		strcpy(p->ascName, ljbuf);
X		p->fontSeq = malloc(strlen(seqbuf) + 1);
X		strcpy(p->fontSeq, seqbuf);
X		p->flags = flags;
X		p++;
X	}
X    }
X#ifdef	DEBUG
X    for (p = ljFts; p->troffName; p++)
X	DEBUGPRINTF("%s -> %s, seq: %s\n", p->troffName, p->ascName, p->fontSeq);
X#endif
X}
X
XljProlog() {
X    extern char *getlogin(), *ctime();
X    char *buf2[15];
X    FILE *library;
X    int c;
X    long curtime;
X
X    currentPage = 0;
X    pagePending = 1;
X
X    for (c = 0; c < 8; c++)
X	t2ljf[c] = &ljFts[c];
X
X    sprintf(buf2, "%s.%s", LJFONTS, be->bename);
X
X    if ((library = fopen(buf2, "r")) == NULL) {
X	char buffer[512];
X	sprintf(buffer, "%s/%s", LIBDIR, buf2);
X	if ((library = fopen(buffer, "r")) == NULL) {
X	    fprintf(stderr, "Cannot open %s font definitions %s\n",
X		LJFONTS, buffer);
X	    exit(1);
X	}
X    }
X
X    loadfontdefs(library);
X    fclose(library);
X
X    sprintf(buf2, "%s.%s", LJLIB, be->bename);
X
X    if ((library = fopen(buf2, "r")) == NULL) {
X	char buffer[512];
X	sprintf(buffer, "%s/%s", LIBDIR, buf2);
X	if ((library = fopen(buffer, "r")) == NULL) {
X	    fprintf(stderr, "Cannot open %s\n", buffer);
X	    exit(1);
X	}
X    }
X
X    printf("\033E\033&k2G");	/* reset printer, set CR=CR,LF=CRLF,FF=CRFF */
X    printf("\033&l6d66p0o0e66f0L");/* letter size, portrait, no perf skip */
X    printf("\0339");		/* reset side margins */
X    printf("\033&a0r0C");	/* move cursor to 0,0 */
X
X    ljXlate(library);
X    fclose(library);
X}
X
XljEpilog() {
X}
X
XljFontSel(from, to)
Xchar from, *to; {
X#ifdef	DEBUG
X    register int i;
X    register struct ljFts *p;
X#endif
X    DEBUGPRINTF("ljFontSel: %c -> %s\n", from, to);
X    if (from < '1' || from > '8') {
X	fprintf(stderr, "Bad arguments to ljFontSel: %c %s\n", from, to);
X	return;
X    }
X
X    for (p = ljFts; p->troffName; p++)
X	if (strcmp(p->troffName, to) == 0) {
X	    t2ljf[from - '1'] = p;
X	    break;
X	}
X    if (!p->troffName) {
X	fprintf(stderr, "Could not translate font %c (%s)\n", from, to);
X    }
X#ifdef	DEBUG
X    for (i = 0; i < 8; i++)
X	DEBUGPRINTF("Font %d->%s\n", i+1, t2ljf[i]->ascName);
X#endif
X}
X
X/*	Copy the library file to the standard output, stripping
X	%line\n
X	%%%<something> is a metadirective
X	and converting \nnn and \xnn as you go.
X	Strip out line termination.
X*/
X
XljXlate(library)
XFILE *library; {
X    char buf[4];
X    int c, i;
X    c = getc(library);
X    while(!feof(library)) {
X
X      nextchar:
X
X	switch(c) {
X	    case '%':
X		/* strip from percent sign to end of line */
X		/* If line is %%%<something> pass onto interp */
X		if (((c = getc(library)) == '%') &&
X		    ((c = getc(library)) == '%')) {
X		    char buf2[4];
X		    sprintf(buf2, ".%s", be->bename);
X		    fgets(buf, strlen(buf), library);
X		    interp(buf, ljXlate, buf2);
X		    break;
X		}
X		while ((c = getc(library)) != EOF && c != '\n');
X		break;
X	    case '\n':	/* throw away real newlines. */
X		break;
X	    case '\\':
X		c = getc(library);
X		if (c == 'x' || c == 'X') {
X		    i = 0;
X		    while(1) {
X			c = getc(library);
X
X			if (c == EOF || !((c >= '0' && c <= '9') ||
X					  (c >= 'A' && c <= 'F') ||
X					  (c >= 'a' && c <= 'f')))
X			    goto nextchar;
X
X			buf[i++] = c;
X			if (i == 2) {
X			    buf[i] = '\0';
X			    sscanf(buf, "%x", &i);
X			    putchar(i);
X			    i = 0;
X			}
X		    }
X		} else {
X		    buf[0] = c;
X		    i = 1;
X		    while(1) {
X			c = getc(library);
X			if (c == EOF || c < '0' || c > '7')
X			    goto nextchar;
X			buf[i++] = c;
X			if (i == 3) {
X			    buf[i] = '\0';
X			    sscanf(buf, "%o", &i);
X			    putchar(i);
X			    i = 0;
X			}
X		    }
X		}
X		/* NOTREACHED */
X
X	    case ' ': case '\t':
X		break;
X
X	    case EOF:
X		fprintf(stderr, "%s: Unexpected eof on ljlib\n", progname);
X		break;
X
X	    default:
X		putchar(c);
X	}
X	c = getc(library);
X    }
X}
X#endif
END_OF_FILE
if test 9120 -ne `wc -c <'lj.c'`; then
    echo shar: \"'lj.c'\" unpacked with wrong size!
fi
# end of 'lj.c'
fi
if test -f 'troff2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'troff2.c'\"
else
echo shar: Extracting \"'troff2.c'\" \(11128 characters\)
sed "s/^X//" >'troff2.c' <<'END_OF_FILE'
X/*	Copyright 1985, 1986, 1987, 1988 Chris Lewis
X		All Rights Reserved
X
X    Permission to copy and further distribute is freely given provided 
X    this copyright notice remains intact and that this software is not 
X    sold for profit.
X
X	Project:	Generic Troff drivers
X	Module:		troff2.c
X	Author: 	Chris Lewis
X	Specs:		Troff interpreter, needs a driver to work.
X */
X
X#include "defs.h"
X
X#ifndef	SVR3
X#ifndef	lint
Xstatic char SCCSid[] = "@(#)troff2.c: 1.16 Copyright 89/07/17 10:58:29 Chris Lewis";
X#endif
X#else
X#ident  "@(#)troff2.c: 1.16 Copyright 89/07/17 10:58:29 Chris Lewis"
X#endif
X
X#define	ESC	0x80
X#define	FLASH	0x00
X#define	CONTROL	0x40
X#define	LEAD	0x60
X#define	SIZE	0x50
X
X#define	DOWN	0
X#define	UP	1
X#define	LOWER	2
X#define	UPPER	3
X#define	FORWARD	4
X#define	BACKWARD 5
X
Xchar ptab[15] = { 7, 8, 10, 11, 12, 14, 18, 9, 6, 16, 20, 22, 24, 28, 36};
Xint	points;
X
Xlong	xpos, ypos;
X
Xchar *words[] = {
X	"down", "up", "lower", "upper", "forward", "backwards"
X	};
X
X
X#define	CTOINT(val,sig)	((~c)&sig)
X
Xdouble pagelength = 11 * TROFFRESOLUTION;
X
X#define	CFONT (((mag == UPPER)<<2)|((rail == UPPER)<<1)|(tilt==DOWN))
X#ifdef	FONT4
X#define	calcfont	font = (CFONT >> 1)
X#else
X#define	calcfont	font = CFONT
X#endif
X
Xchar *progname;
Xchar *device = {"alw"};
X
Xdouble calc();
X
Xchar *driver;
X
Xmain(argc, argv)
Xint	argc;
Xchar	**argv; {
X	register int nc, c;
X	register int i,j;
X	register int units;
X	register int font, rail, mag, tilt, half, escape, lead;
X
X	extern int getopt();
X	extern char *optarg;
X
X	progname = strrchr(argv[0], "/");
X	if (progname)
X	    progname++;
X	else
X	    progname = argv[0];
X	
X	if (strlen(progname) >= 2)
X	    driver = progname + strlen(progname) - 2;
X	else
X	    driver = "ZZ";
X
X	while((c = getopt(argc, argv, "T:VDd:l:m")) != EOF)
X	    switch (c) {
X		case 'T':
X		    device = optarg;
X		    break;
X		case 'm':
X		    metrics = 1;
X		    break;
X		case 'V':
X		    printf("%s: version %s\n", progname, T2VERSION);
X		    exit(0);
X		case 'D':
X		    diagFile = fopen("diagnostics", "w");
X		    if (!diagFile) {
X			fprintf(stderr, "%s: Could not open diagnostics file\n",
X			    progname);
X			exit(1);
X		    }
X		    break;
X		case 'd':
X		    driver = optarg;
X		    break;
X		case 'l':
X		    pagelength = calc(optarg);
X		    if (pagelength == 0) {
X			fprintf(stderr, "%s: Bad pagelength %s\n", progname, 
X			    optarg);
X			exit(1);
X		    }
X		    break;
X		case '?':
X		default:
X		    usage();
X		    exit(1);
X	    }
X	
X	getdriver(driver);
X
X	if (be->beprolog)
X	    (*be->beprolog)();
X
X	while (!feof(stdin)) {
X		c = getc(stdin);
X		switch(c) {
X		case 0x00:
X			DEBUGPRINTF("NOP\n");
X			break;
X		/* Flash (print character) codes */
X		case 0x01: case 0x02: case 0x03: case 0x04: 
X		case 0x05: case 0x06: case 0x07: case 0x08: 
X		case 0x09: case 0x0a: case 0x0b: case 0x0c: 
X		case 0x0d: case 0x0e: case 0x0f: case 0x10: 
X		case 0x11: case 0x12: case 0x13: case 0x14:
X		case 0x15: case 0x16: case 0x17: case 0x18: 
X		case 0x19: case 0x1a: case 0x1b: case 0x1c: 
X		case 0x1d: case 0x1e: case 0x1f: case 0x20: 
X		case 0x21: case 0x22: case 0x23: case 0x24: 
X		case 0x25: case 0x26: case 0x27: case 0x28:
X		case 0x29: case 0x2a: case 0x2b: case 0x2c: 
X		case 0x2d: case 0x2e: case 0x2f: case 0x30: 
X		case 0x31: case 0x32: case 0x33: case 0x34: 
X		case 0x35: case 0x36: case 0x37: case 0x38: 
X		case 0x39: case 0x3a: case 0x3b: case 0x3c:
X		case 0x3d: case 0x3e: case 0x3f:
X			/* This is terribly kludgey:
X				In 432 units per inch, 4752 is 11 inches.
X				When we go beyond this, we subtract 4752
X				continually until we're back in range.
X			*/
X			while (ypos >= pagelength) {
X			       ypos -= pagelength;
X			    DEBUGPRINTF("Page break\n", 0, 0);
X			    if (be->bepage)
X				(be->bepage) ();
X			}
X			c = c&0x3f;
X			/*	Find the C/A/T code */
X			if (half == UPPER) {
X			    if (c > 46) {
X				fprintf(stderr, "%s: Illegal upper flash: %d\n", 
X				    progname, c);
X				exit(1);
X			    }
X			    nc = c + 62;
X			} else
X			    nc = c - 1;
X
X			DEBUGPRINTF("nc=%d;pnts=%d;x,y=%ld,%ld;fnt=%d;",
X			    nc,points,xpos,ypos,font);
X			DEBUGPRINTF("rail=%s;mag=%s;tilt=%s;half=%s\n",
X			    words[rail], words[mag],words[tilt], words[half]);
X
X			if (be->beputchar)
X			    (*be->beputchar)(xpos, ypos, font, points, nc);
X			
X			break;
X		/* Control codes */
X		case 0x40:
X			DEBUGPRINTF("Initialize\n");
X			xpos = 0;
X			ypos = -153;
X			escape = FORWARD;
X			lead = FORWARD;
X			half = LOWER;
X			rail = LOWER;
X			mag = LOWER;
X			tilt = DOWN;
X			calcfont;
X			break;
X		case 0x41:
X			DEBUGPRINTF("Rail lower\n");
X			rail = LOWER;
X			calcfont;
X			break;
X		case 0x42:
X			DEBUGPRINTF("Rail upper\n");
X			rail = UPPER;
X			calcfont;
X			break;
X		case 0x43:
X			DEBUGPRINTF("Mag upper\n");
X			mag = UPPER;
X			calcfont;
X			break;
X		case 0x44:
X			DEBUGPRINTF("Mag lower\n");
X			mag = LOWER;
X			calcfont;
X			break;
X		case 0x45:
X			DEBUGPRINTF("half lower\n");
X			half = LOWER;
X			break;
X		case 0x46:
X			DEBUGPRINTF("half upper\n");
X			half = UPPER;
X			break;
X		case 0x47:
X			DEBUGPRINTF("Escape forward\n");
X			escape = FORWARD;
X			break;
X		case 0x48:
X			DEBUGPRINTF("Escape backward\n");
X			escape = BACKWARD;
X			break;
X		case 0x49:
X			DEBUGPRINTF("STOP\n");
X			break;
X		case 0x4a:
X			DEBUGPRINTF("Lead forward\n");
X			lead = FORWARD;
X			break;
X		case 0x4b:
X			DEBUGPRINTF("Software cut!\n");
X			break;
X		case 0x4c:
X			DEBUGPRINTF("Lead backward\n");
X			lead = BACKWARD;
X			break;
X		case 0x4d: 
X#ifdef	SPECIAL
X#define	SPSIZ	256
X			{
X			    static char specialbuf[SPSIZ], *sbp;
X			    sbp = specialbuf;
X			    while((c = getc(stdin)) != EOF && c != '\n') {
X				if (sbp < &specialbuf[SPSIZ]-2)
X				*sbp++ = c;
X			    }
X			    *sbp = '\0';
X				
X			    DEBUGPRINTF("SPECIAL SEQUENCE: %s!\n", specialbuf);
X			    dospecial(specialbuf);
X			    break;
X			}
X#else
X			fprintf(stderr, "%s: Illegal C/A/T code - %s\n",
X			    progname, "special sequences are disabled");
X			exit(1);
X#endif
X		case 0x4e:
X			DEBUGPRINTF("Tilt up\n");
X			tilt = UP;
X			calcfont;
X			break;
X		case 0x4f:
X			DEBUGPRINTF("Tilt down\n");
X			tilt = DOWN;
X			calcfont;
X			break;
X
X		/* Size changes */
X		case 0x50: case 0x51: case 0x52: case 0x53:
X		case 0x54: case 0x55: case 0x56: case 0x57:
X		case 0x58: case 0x59: case 0x5a: case 0x5b:
X		case 0x5c: case 0x5d: case 0x5e: case 0x5f:
X		    /* basic code is the points = ptab[c] line.
X		       The rest of the brain-damage is due to the
X		       fact that switching from some of the fonts
X		       to some of the others blow the horizontal
X		       position - see the cat(5) manual page
X		       about single vs. doubler point sizes. */
X		    {	static lastc = 0;
X			c &= 0xf;
X			points = ptab[c];
X
X			DEBUGPRINTF("SPoints:%d;lastc:%5d;c:%d;xpos:%d\n", 
X			    points, lastc, c, xpos);
X			if (lastc <= 8 && c > 8) /* single -> doubler */
X			    xpos -= 55;
X			else if (lastc > 8 && c <= 8) /* doubler -> single */
X			    xpos += 55;
X
X			DEBUGPRINTF("EPoints:%d;lastc:%5d;c:%d;xpos:%d\n", 
X			    points, lastc, c, xpos);
X			lastc = c;
X			break;
X		    }
X		/* Lead (vertical motion) codes */
X		case 0x60: case 0x61: case 0x62: case 0x63:
X		case 0x64: case 0x65: case 0x66: case 0x67:
X		case 0x68: case 0x69: case 0x6a: case 0x6b:
X		case 0x6c: case 0x6d: case 0x6e: case 0x6f:
X		case 0x70: case 0x71: case 0x72: case 0x73:
X		case 0x74: case 0x75: case 0x76: case 0x77:
X		case 0x78: case 0x79: case 0x7a: case 0x7b:
X		case 0x7c: case 0x7d: case 0x7e: case 0x7f:
X
X			DEBUGPRINTF("Lead(vertical) %02x\n", c&0x1f);
X			units = CTOINT(c,0x1f);
X			if (lead == FORWARD)
X			    ypos += 3*units;
X			else
X			    ypos -= 3*units;
X			break;
X		/* Escape (horizontal motion) codes */
X		case 0x80: case 0x81: case 0x82: case 0x83:
X		case 0x84: case 0x85: case 0x86: case 0x87:
X		case 0x88: case 0x89: case 0x8a: case 0x8b:
X		case 0x8c: case 0x8d: case 0x8e: case 0x8f:
X		case 0x90: case 0x91: case 0x92: case 0x93:
X		case 0x94: case 0x95: case 0x96: case 0x97:
X		case 0x98: case 0x99: case 0x9a: case 0x9b:
X		case 0x9c: case 0x9d: case 0x9e: case 0x9f:
X		case 0xa0: case 0xa1: case 0xa2: case 0xa3:
X		case 0xa4: case 0xa5: case 0xa6: case 0xa7:
X		case 0xa8: case 0xa9: case 0xaa: case 0xab:
X		case 0xac: case 0xad: case 0xae: case 0xaf:
X		case 0xb0: case 0xb1: case 0xb2: case 0xb3:
X		case 0xb4: case 0xb5: case 0xb6: case 0xb7:
X		case 0xb8: case 0xb9: case 0xba: case 0xbb:
X		case 0xbc: case 0xbd: case 0xbe: case 0xbf:
X		case 0xc0: case 0xc1: case 0xc2: case 0xc3:
X		case 0xc4: case 0xc5: case 0xc6: case 0xc7:
X		case 0xc8: case 0xc9: case 0xca: case 0xcb:
X		case 0xcc: case 0xcd: case 0xce: case 0xcf:
X		case 0xd0: case 0xd1: case 0xd2: case 0xd3:
X		case 0xd4: case 0xd5: case 0xd6: case 0xd7:
X		case 0xd8: case 0xd9: case 0xda: case 0xdb:
X		case 0xdc: case 0xdd: case 0xde: case 0xdf:
X		case 0xe0: case 0xe1: case 0xe2: case 0xe3:
X		case 0xe4: case 0xe5: case 0xe6: case 0xe7:
X		case 0xe8: case 0xe9: case 0xea: case 0xeb:
X		case 0xec: case 0xed: case 0xee: case 0xef:
X		case 0xf0: case 0xf1: case 0xf2: case 0xf3:
X		case 0xf4: case 0xf5: case 0xf6: case 0xf7:
X		case 0xf8: case 0xf9: case 0xfa: case 0xfb:
X		case 0xfc: case 0xfd: case 0xfe:
X
X			units = CTOINT(c,0x7f);
X			if (escape == FORWARD)
X			    xpos += units;
X			else
X			    xpos -= units;
X			DEBUGPRINTF("ESC (hor): %02x\n", c&0x7f);
X			break;
X
X		case 0xff:
X			DEBUGPRINTF("Illegal: %02x\n", c);
X			break;
X		}
X	}
X	if (be->bepage)
X	    (*be->bepage)();
X	if (be->beepilog)
X	    (*be->beepilog) ();
X	exit(0);
X}
X
Xusage() {
X    fprintf(stderr, "usage: %s [-D]\n", progname);
X}
X
Xdouble
Xcalc(s)
Xregister char *s; {
X    double retval = 0.0;
X    char scale;
X    switch (sscanf(s, "%lf%c", &retval, &scale)) {
X	case 0:
X	case EOF:
X	    retval = 0.0;
X	case 1:
X	    retval *= TROFFRESOLUTION; /* default is inches */
X	    break;
X	case 2:
X	    switch(scale) {
X		default:
X		    fprintf(stderr, "%s: bad scale %c\n", scale);
X		    retval = 0.0;
X		case 'i':
X		    retval *= TROFFRESOLUTION;
X		case 'u':
X		    break;
X		case 'c':
X		    retval *= TROFFRESOLUTION * 50. / 127.;
X		    break;
X		case 'P':
X		    retval *= 72.;
X		    break;
X	    }
X	    break;
X    }
X    return(retval);
X}
X
X#ifdef	SPECIAL
X
Xdospecial(string)
Xchar *string; {
X    char buffer[512];
X    char b2[4];
X    buffer[0] = '\0';
X
X    DEBUGPRINTF("Dospecial: (%d) %s\n", strlen(string), string);
X    while (*string)
X	switch(*string) {
X	    case 'F':
X		/*if (parmchk(2, string))
X		    return;*/
X		if (be->befontsel)
X		    (*be->befontsel)(*(string+1), string+2);
X		*string ='\0';
X		return;
X#ifdef	FORM
X	    case 'O':
X		if (be->beoverlay)
X		    (*be->beoverlay)(string+1);
X		*string = '\0';
X		return;
X#endif
X	    case 'i':
X		strcpy(buffer, "b");
X
X	    case 'I':
X		strcat(buffer, "include ");
X		strcat(buffer, string+1);
X		strcpy(b2, ".");
X		strcat(b2, driver);
X		interp(buffer, (be->bexlat && *string == 'F') ? be->bexlat:
X		    FNULL, b2);
X		return;
X
X	    case 'B':
X		if (be->bebin)
X		    (*be->bebin)(string+1);
X		string += 2;
X		break;
X	    default:
X		fprintf(stderr, "%s: Illegal sequence %s\n", progname, string);
X		return;
X	}
X}
X
Xparmchk(cnt, string)
Xint cnt; char *string; {
X    register int i;
X    for (i = 0; i < cnt; i++)
X	if (!string[i]) {
X	    fprintf(stderr, "%s: Bad %d parameter command: %s\n", progname,
X		cnt, string);
X	    return(1);
X	}
X    return(0);
X}
X#endif
END_OF_FILE
if test 11128 -ne `wc -c <'troff2.c'`; then
    echo shar: \"'troff2.c'\" unpacked with wrong size!
fi
# end of 'troff2.c'
fi
echo shar: End of archive 4 \(of 6\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    echo "Read README to install psroff"
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

