Subject:  v20i106:  Perl, a language with features of C/sed/awk/shell/etc, Part23/24
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Larry Wall <lwall@jpl-devvax.jpl.nasa.gov>
Posting-number: Volume 20, Issue 106
Archive-name: perl3.0/part23

#! /bin/sh

# Make a new directory for the perl sources, cd to it, and run kits 1
# thru 24 through sh.  When all 24 kits have been run, read README.

echo "This is perl 3.0 kit 23 (of 24).  If kit 23 is complete, the line"
echo '"'"End of kit 23 (of 24)"'" will echo at the end.'
echo ""
export PATH || (echo "You didn't use sh, you clunch." ; kill $$)
mkdir eg eg/g eg/scan eg/van lib t x2p 2>/dev/null
echo Extracting eg/scan/scanner
sed >eg/scan/scanner <<'!STUFFY!FUNK!' -e 's/X//'
X#!/usr/bin/perl
X
X# $Header: scanner,v 3.0 89/10/18 15:16:02 lwall Locked $
X
X# This runs all the scan_* routines on all the machines in /etc/ghosts.
X# We run this every morning at about 6 am:
X
X#	!/bin/sh
X#	cd /usr/adm/private
X#	decrypt scanner | perl >scan.out 2>&1
X#	mail admin <scan.out
X
X# Note that the scan_* files should be encrypted with the key "-inquire", and
X# scanner should be encrypted somehow so that people can't find that key.
X# I leave it up to you to figure out how to unencrypt it before executing.
X
X$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin:/usr/ucb:.';
X
X$| = 1;		# command buffering on stdout
X
Xprint "Subject: bizarre happenings\n\n";
X
X(chdir '/usr/adm/private') || die "Can't cd to /usr/adm/private: $!\n";
X
Xif ($#ARGV >= 0) {
X    @scanlist = @ARGV;
X} else {
X    @scanlist = split(/[ \t\n]+/,`echo scan_*`);
X}
X
Xscan: while ($scan = shift(@scanlist)) {
X    print "\n********** $scan **********\n";
X    $showhost++;
X
X    $systype = 'all';
X
X    open(ghosts, '/etc/ghosts') || die 'No /etc/ghosts file';
X
X    $one_of_these = ":$systype:";
X    if ($systype =~ s/\+/[+]/g) {
X	$one_of_these =~ s/\+/:/g;
X    }
X
X    line: while (<ghosts>) {
X	s/[ \t]*\n//;
X	if (!$_ || /^#/) {
X	    next line;
X	}
X	if (/^([a-zA-Z_0-9]+)=(.+)/) {
X	    $name = $1; $repl = $2;
X	    $repl =~ s/\+/:/g;
X	    $one_of_these =~ s/:$name:/:$repl:/;
X	    next line;
X	}
X	@gh = split;
X	$host = $gh[0];
X	if ($showhost) { $showhost = "$host:\t"; }
X	class: while ($class = pop(gh)) {
X	    if (index($one_of_these,":$class:") >=0) {
X		$iter = 0;
X		`exec crypt -inquire <$scan >.x 2>/dev/null`;
X		unless (open(scan,'.x')) {
X		    print "Can't run $scan: $!\n";
X		    next scan;
X		}
X		$cmd = <scan>;
X		unless ($cmd =~ s/#!(.*)\n/$1/) {
X		    $cmd = '/usr/bin/perl';
X		}
X		close(scan);
X		if (open(pipe,"exec rsh $host '$cmd' <.x|")) {
X		    sleep(5);
X		    unlink '.x';
X		    while (<pipe>) {
X			last if $iter++ > 1000;		# must be looping
X			next if /^[0-9.]+u [0-9.]+s/;
X			print $showhost,$_;
X		    }
X		    close(pipe);
X		} else {
X		    print "(Can't execute rsh: $!)\n";
X		}
X		last class;
X	    }
X	}
X    }
X}
!STUFFY!FUNK!
echo Extracting eg/g/gcp.man
sed >eg/g/gcp.man <<'!STUFFY!FUNK!' -e 's/X//'
X.\" $Header: gcp.man,v 3.0 89/10/18 15:14:09 lwall Locked $
X.TH GCP 1C "13 May 1988"
X.SH NAME
Xgcp \- global file copy
X.SH SYNOPSIS
X.B gcp
Xfile1 file2
X.br
X.B gcp
X[
X.B \-r
X] file ... directory
X.SH DESCRIPTION
X.I gcp
Xworks just like rcp(1C) except that you may specify a set of hosts to copy files
Xfrom or to.
XThe host sets are defined in the file /etc/ghosts.
X(An individual host name can be used as a set containing one member.)
XYou can give a command like
X
X	gcp /etc/motd sun:
X
Xto copy your /etc/motd file to /etc/motd on all the Suns.
XIf, on the other hand, you say
X
X	gcp /a/foo /b/bar sun:/tmp
X
Xthen your files will be copied to /tmp on all the Suns.
XThe general rule is that if you don't specify the destination directory,
Xfiles go to the same directory they are in currently.
X.P
XYou may specify the union of two or more sets by using + as follows:
X
X	gcp /a/foo /b/bar 750+mc:
X
Xwhich will copy /a/foo to /a/foo on all 750's and Masscomps, and then copy
X/b/bar to /b/bar on all 750's and Masscomps.
X.P
XCommonly used sets should be defined in /etc/ghosts.
XFor example, you could add a line that says
X
X	pep=manny+moe+jack
X
XAnother way to do that would be to add the word "pep" after each of the host
Xentries:
X
X	manny	sun3 pep
X.br
X	moe		sun3 pep
X.br
X	jack		sun3 pep
X
XHosts and sets of host can also be excluded:
X
X	foo=sun-sun2
X
XAny host so excluded will never be included, even if a subsequent set on the
Xline includes it:
X
X	foo=abc+def
X.br
X	bar=xyz-abc+foo
X
Xcomes out to xyz+def.
X
XYou can define private host sets by creating .ghosts in your current directory
Xwith entries just like /etc/ghosts.
XAlso, if there is a file .grem, it defines "rem" to be the remaining hosts
Xfrom the last gsh or gcp that didn't succeed everywhere.
X.PP
XInterrupting with a SIGINT will cause the rcp to the current host to be skipped
Xand execution resumed with the next host.
XTo stop completely, send a SIGQUIT.
X.SH SEE ALSO
Xrcp(1C)
X.SH BUGS
XAll the bugs of rcp, since it calls rcp.
!STUFFY!FUNK!
echo Extracting lib/complete.pl
sed >lib/complete.pl <<'!STUFFY!FUNK!' -e 's/X//'
X;#
X;#	@(#)complete.pl	1.0 (sun!waynet) 11/11/88
X;#
X;# Author: Wayne Thompson
X;#
X;# Description:
X;#     This routine provides word completion.
X;#     (TAB) attempts word completion.
X;#     (^D)  prints completion list.
X;#
X;# Diagnostics:
X;#     Bell when word completion fails.
X;#
X;# Dependencies:
X;#     The tty driver is put into raw mode.
X;#
X;# Bugs:
X;#     The erase and kill characters are hard coded.
X;#
X;# Usage:
X;#     $input = do Complete('prompt_string', @completion_list);
X;#
X
Xsub Complete {
X    local ($prompt) = shift (@_);
X    local ($c, $cmp, $l, $r, $ret, $return, $test);
X    @_ = sort @_;
X    system 'stty raw -echo';
X    loop: {
X	print $prompt, $return;
X	while (($c = getc(stdin)) ne "\r") {
X	    if ($c eq "\t") {			# (TAB) attempt completion
X		@_match = ();
X		foreach $cmp (@_) {
X		    push (@_match, $cmp) if $cmp =~ /^$return/;
X		}
X    	    	$test = $_match[0];
X    	    	$l = length ($test);
X		unless ($#_match == 0) {
X    	    	    shift (@_match);
X    	    	    foreach $cmp (@_match) {
X    	    	    	until (substr ($cmp, 0, $l) eq substr ($test, 0, $l)) {
X    	    	    	    $l--;
X    	    	    	}
X    	    	    }
X    	    	    print "\007";
X    	    	}
X    	    	print $test = substr ($test, $r, $l - $r);
X    	    	$r = length ($return .= $test);
X	    }
X	    elsif ($c eq "\004") {		# (^D) completion list
X		print "\r\n";
X		foreach $cmp (@_) {
X		    print "$cmp\r\n" if $cmp =~ /^$return/;
X		}
X		redo loop;
X	    }
X    	    elsif ($c eq "\025" && $r) {	# (^U) kill
X    	    	$return = '';
X    	    	$r = 0;
X    	    	print "\r\n";
X    	    	redo loop;
X    	    }
X	    	    	    	    	    	# (DEL) || (BS) erase
X	    elsif ($c eq "\177" || $c eq "\010") {
X		if($r) {
X		    print "\b \b";
X		    chop ($return);
X		    $r--;
X		}
X	    }
X	    elsif ($c =~ /\S/) {    	    	# printable char
X		$return .= $c;
X		$r++;
X		print $c;
X	    }
X	}
X    }
X    system 'stty -raw echo';
X    print "\n";
X    $return;
X}
X
X1;
!STUFFY!FUNK!
echo Extracting t/op.study
sed >t/op.study <<'!STUFFY!FUNK!' -e 's/X//'
X#!./perl
X
X# $Header: op.study,v 3.0 89/10/18 15:31:38 lwall Locked $
X
Xprint "1..24\n";
X
X$x = "abc\ndef\n";
Xstudy($x);
X
Xif ($x =~ /^abc/) {print "ok 1\n";} else {print "not ok 1\n";}
Xif ($x !~ /^def/) {print "ok 2\n";} else {print "not ok 2\n";}
X
X$* = 1;
Xif ($x =~ /^def/) {print "ok 3\n";} else {print "not ok 3\n";}
X$* = 0;
X
X$_ = '123';
Xstudy;
Xif (/^([0-9][0-9]*)/) {print "ok 4\n";} else {print "not ok 4\n";}
X
Xif ($x =~ /^xxx/) {print "not ok 5\n";} else {print "ok 5\n";}
Xif ($x !~ /^abc/) {print "not ok 6\n";} else {print "ok 6\n";}
X
Xif ($x =~ /def/) {print "ok 7\n";} else {print "not ok 7\n";}
Xif ($x !~ /def/) {print "not ok 8\n";} else {print "ok 8\n";}
X
Xstudy($x);
Xif ($x !~ /.def/) {print "ok 9\n";} else {print "not ok 9\n";}
Xif ($x =~ /.def/) {print "not ok 10\n";} else {print "ok 10\n";}
X
Xif ($x =~ /\ndef/) {print "ok 11\n";} else {print "not ok 11\n";}
Xif ($x !~ /\ndef/) {print "not ok 12\n";} else {print "ok 12\n";}
X
X$_ = 'aaabbbccc';
Xstudy;
Xif (/(a*b*)(c*)/ && $1 eq 'aaabbb' && $2 eq 'ccc') {
X	print "ok 13\n";
X} else {
X	print "not ok 13\n";
X}
Xif (/(a+b+c+)/ && $1 eq 'aaabbbccc') {
X	print "ok 14\n";
X} else {
X	print "not ok 14\n";
X}
X
Xif (/a+b?c+/) {print "not ok 15\n";} else {print "ok 15\n";}
X
X$_ = 'aaabccc';
Xstudy;
Xif (/a+b?c+/) {print "ok 16\n";} else {print "not ok 16\n";}
Xif (/a*b+c*/) {print "ok 17\n";} else {print "not ok 17\n";}
X
X$_ = 'aaaccc';
Xstudy;
Xif (/a*b?c*/) {print "ok 18\n";} else {print "not ok 18\n";}
Xif (/a*b+c*/) {print "not ok 19\n";} else {print "ok 19\n";}
X
X$_ = 'abcdef';
Xstudy;
Xif (/bcd|xyz/) {print "ok 20\n";} else {print "not ok 20\n";}
Xif (/xyz|bcd/) {print "ok 21\n";} else {print "not ok 21\n";}
X
Xif (m|bc/*d|) {print "ok 22\n";} else {print "not ok 22\n";}
X
Xif (/^$_$/) {print "ok 23\n";} else {print "not ok 23\n";}
X
X$* = 1;		# test 3 only tested the optimized version--this one is for real
Xif ("ab\ncd\n" =~ /^cd/) {print "ok 24\n";} else {print "not ok 24\n";}
!STUFFY!FUNK!
echo Extracting hash.h
sed >hash.h <<'!STUFFY!FUNK!' -e 's/X//'
X/* $Header: hash.h,v 3.0 89/10/18 15:18:39 lwall Locked $
X *
X *    Copyright (c) 1989, Larry Wall
X *
X *    You may distribute under the terms of the GNU General Public License
X *    as specified in the README file that comes with the perl 3.0 kit.
X *
X * $Log:	hash.h,v $
X * Revision 3.0  89/10/18  15:18:39  lwall
X * 3.0 baseline
X * 
X */
X
X#define FILLPCT 80		/* don't make greater than 99 */
X#define DBM_CACHE_MAX 63	/* cache 64 entries for dbm file */
X				/* (resident array acts as a write-thru cache)*/
X
X#define COEFFSIZE (16 * 8)	/* size of array below */
X#ifdef DOINIT
Xchar coeff[] = {
X		61,59,53,47,43,41,37,31,29,23,17,13,11,7,3,1,
X		61,59,53,47,43,41,37,31,29,23,17,13,11,7,3,1,
X		61,59,53,47,43,41,37,31,29,23,17,13,11,7,3,1,
X		61,59,53,47,43,41,37,31,29,23,17,13,11,7,3,1,
X		61,59,53,47,43,41,37,31,29,23,17,13,11,7,3,1,
X		61,59,53,47,43,41,37,31,29,23,17,13,11,7,3,1,
X		61,59,53,47,43,41,37,31,29,23,17,13,11,7,3,1,
X		61,59,53,47,43,41,37,31,29,23,17,13,11,7,3,1};
X#else
Xextern char coeff[];
X#endif
X
Xtypedef struct hentry HENT;
X
Xstruct hentry {
X    HENT	*hent_next;
X    char	*hent_key;
X    STR		*hent_val;
X    int		hent_hash;
X    int		hent_klen;
X};
X
Xstruct htbl {
X    HENT	**tbl_array;
X    int		tbl_max;	/* subscript of last element of tbl_array */
X    int		tbl_dosplit;	/* how full to get before splitting */
X    int		tbl_fill;	/* how full tbl_array currently is */
X    int		tbl_riter;	/* current root of iterator */
X    HENT	*tbl_eiter;	/* current entry of iterator */
X    SPAT 	*tbl_spatroot;	/* list of spats for this package */
X#ifdef SOME_DBM
X#ifdef NDBM
X    DBM		*tbl_dbm;
X#else
X    int		tbl_dbm;
X#endif
X#endif
X    unsigned char tbl_coeffsize;	/* is 0 for symbol tables */
X};
X
XSTR *hfetch();
Xbool hstore();
XSTR *hdelete();
XHASH *hnew();
Xvoid hclear();
Xvoid hentfree();
Xint hiterinit();
XHENT *hiternext();
Xchar *hiterkey();
XSTR *hiterval();
Xbool hdbmopen();
Xvoid hdbmclose();
Xbool hdbmstore();
!STUFFY!FUNK!
echo Extracting t/TEST
sed >t/TEST <<'!STUFFY!FUNK!' -e 's/X//'
X#!./perl
X
X# $Header: TEST,v 3.0 89/10/18 15:24:06 lwall Locked $
X
X# This is written in a peculiar style, since we're trying to avoid
X# most of the constructs we'll be testing for.
X
X$| = 1;
X
Xif ($ARGV[0] eq '-v') {
X    $verbose = 1;
X    shift;
X}
X
Xchdir 't' if -f 't/TEST';
X
Xif ($ARGV[0] eq '') {
X    @ARGV = split(/[ \n]/,`echo base.* comp.* cmd.* io.* op.*`);
X}
X
Xopen(config,"../config.sh");
Xwhile (<config>) {
X    if (/sharpbang='(.*)'/) {
X	$sharpbang = ($1 eq '#!');
X	last;
X    }
X}
X$bad = 0;
Xwhile ($test = shift) {
X    if ($test =~ /\.orig$/) {
X	next;
X    }
X    if ($test =~ /~$/) {
X	next;
X    }
X    print "$test" . '.' x (16 - length($test));
X    if ($sharpbang) {
X	open(results,"./$test|") || (print "can't run.\n");
X    } else {
X	open(script,"$test") || die "Can't run $test.\n";
X	$_ = <script>;
X	close(script);
X	if (/#!..perl(.*)/) {
X	    $switch = $1;
X	} else {
X	    $switch = '';
X	}
X	open(results,"./perl$switch $test|") || (print "can't run.\n");
X    }
X    $ok = 0;
X    $next = 0;
X    while (<results>) {
X	if ($verbose) {
X	    print $_;
X	}
X	unless (/^#/) {
X	    if (/^1\.\.([0-9]+)/) {
X		$max = $1;
X		$next = 1;
X		$ok = 1;
X	    } else {
X		if (/^ok (.*)/ && $1 == $next) {
X		    $next = $next + 1;
X		} else {
X		    $ok = 0;
X		}
X	    }
X	}
X    }
X    $next = $next - 1;
X    if ($ok && $next == $max) {
X	print "ok\n";
X    } else {
X	$next += 1;
X	print "FAILED on test $next\n";
X	$bad = $bad + 1;
X	$_ = $test;
X	if (/^base/) {
X	    die "Failed a basic test--cannot continue.\n";
X	}
X    }
X}
X
Xif ($bad == 0) {
X    if ($ok) {
X	print "All tests successful.\n";
X    } else {
X	die "FAILED--no tests were run for some reason.\n";
X    }
X} else {
X    if ($bad == 1) {
X	die "Failed 1 test.\n";
X    } else {
X	die "Failed $bad tests.\n";
X    }
X}
X($user,$sys,$cuser,$csys) = times;
Xprint sprintf("u=%g  s=%g  cu=%g  cs=%g\n",$user,$sys,$cuser,$csys);
!STUFFY!FUNK!
echo Extracting t/op.write
sed >t/op.write <<'!STUFFY!FUNK!' -e 's/X//'
X#!./perl
X
X# $Header: op.write,v 3.0 89/10/18 15:32:16 lwall Locked $
X
Xprint "1..2\n";
X
Xformat OUT =
Xthe quick brown @<<
X$fox
Xjumped
X@*
X$multiline
X^<<<<<<<<<
X$foo
X^<<<<<<<<<
X$foo
X^<<<<<<...
X$foo
Xnow @<<the@>>>> for all@|||||men to come @<<<<
X'i' . 's', "time\n", $good, 'to'
X.
X
Xopen(OUT, '>Op.write.tmp') || die "Can't create Op.write.tmp";
X
X$fox = 'foxiness';
X$good = 'good';
X$multiline = "forescore\nand\nseven years\n";
X$foo = 'when in the course of human events it becomes necessary';
Xwrite(OUT);
Xclose OUT;
X
X$right =
X"the quick brown fox
Xjumped
Xforescore
Xand
Xseven years
Xwhen in
Xthe course
Xof huma...
Xnow is the time for all good men to come to\n";
X
Xif (`cat Op.write.tmp` eq $right)
X    { print "ok 1\n"; unlink 'Op.write.tmp'; }
Xelse
X    { print "not ok 1\n"; }
X
Xformat OUT2 =
Xthe quick brown @<<
X$fox
Xjumped
X@*
X$multiline
X^<<<<<<<<< ~~
X$foo
Xnow @<<the@>>>> for all@|||||men to come @<<<<
X'i' . 's', "time\n", $good, 'to'
X.
X
Xopen(OUT2, '>Op.write.tmp') || die "Can't create Op.write.tmp";
X
X$fox = 'foxiness';
X$good = 'good';
X$multiline = "forescore\nand\nseven years\n";
X$foo = 'when in the course of human events it becomes necessary';
Xwrite(OUT2);
Xclose OUT2;
X
X$right =
X"the quick brown fox
Xjumped
Xforescore
Xand
Xseven years
Xwhen in
Xthe course
Xof human
Xevents it
Xbecomes
Xnecessary
Xnow is the time for all good men to come to\n";
X
Xif (`cat Op.write.tmp` eq $right)
X    { print "ok 2\n"; unlink 'Op.write.tmp'; }
Xelse
X    { print "not ok 2\n"; }
X
!STUFFY!FUNK!
echo Extracting t/op.substr
sed >t/op.substr <<'!STUFFY!FUNK!' -e 's/X//'
X#!./perl
X
X# $Header: op.substr,v 3.0 89/10/18 15:31:52 lwall Locked $
X
Xprint "1..19\n";
X
X$a = 'abcdefxyz';
X
Xprint (substr($a,0,3) eq 'abc' ? "ok 1\n" : "not ok 1\n");
Xprint (substr($a,3,3) eq 'def' ? "ok 2\n" : "not ok 2\n");
Xprint (substr($a,6,999) eq 'xyz' ? "ok 3\n" : "not ok 3\n");
Xprint (substr($a,999,999) eq '' ? "ok 4\n" : "not ok 4\n");
Xprint (substr($a,6,-1) eq '' ? "ok 5\n" : "not ok 5\n");
Xprint (substr($a,-3,1) eq 'x' ? "ok 6\n" : "not ok 6\n");
X
X$[ = 1;
X
Xprint (substr($a,1,3) eq 'abc' ? "ok 7\n" : "not ok 7\n");
Xprint (substr($a,4,3) eq 'def' ? "ok 8\n" : "not ok 8\n");
Xprint (substr($a,7,999) eq 'xyz' ? "ok 9\n" : "not ok 9\n");
Xprint (substr($a,999,999) eq '' ? "ok 10\n" : "not ok 10\n");
Xprint (substr($a,7,-1) eq '' ? "ok 11\n" : "not ok 11\n");
Xprint (substr($a,-3,1) eq 'x' ? "ok 12\n" : "not ok 12\n");
X
X$[ = 0;
X
Xsubstr($a,3,3) = 'XYZ';
Xprint $a eq 'abcXYZxyz' ? "ok 13\n" : "not ok 13\n";
Xsubstr($a,0,2) = '';
Xprint $a eq 'cXYZxyz' ? "ok 14\n" : "not ok 14\n";
Xy/a/a/;
Xsubstr($a,0,0) = 'ab';
Xprint $a eq 'abcXYZxyz' ? "ok 15\n" : "not ok 15 $a\n";
Xsubstr($a,0,0) = '12345678';
Xprint $a eq '12345678abcXYZxyz' ? "ok 16\n" : "not ok 16\n";
Xsubstr($a,-3,3) = 'def';
Xprint $a eq '12345678abcXYZdef' ? "ok 17\n" : "not ok 17\n";
Xsubstr($a,-3,3) = '<';
Xprint $a eq '12345678abcXYZ<' ? "ok 18\n" : "not ok 18\n";
Xsubstr($a,-1,1) = '12345678';
Xprint $a eq '12345678abcXYZ12345678' ? "ok 19\n" : "not ok 19\n";
X
!STUFFY!FUNK!
echo Extracting spat.h
sed >spat.h <<'!STUFFY!FUNK!' -e 's/X//'
X/* $Header: spat.h,v 3.0 89/10/18 15:23:14 lwall Locked $
X *
X *    Copyright (c) 1989, Larry Wall
X *
X *    You may distribute under the terms of the GNU General Public License
X *    as specified in the README file that comes with the perl 3.0 kit.
X *
X * $Log:	spat.h,v $
X * Revision 3.0  89/10/18  15:23:14  lwall
X * 3.0 baseline
X * 
X */
X
Xstruct scanpat {
X    SPAT	*spat_next;		/* list of all scanpats */
X    REGEXP	*spat_regexp;		/* compiled expression */
X    ARG		*spat_repl;		/* replacement string for subst */
X    ARG		*spat_runtime;		/* compile pattern at runtime */
X    STR		*spat_short;		/* for a fast bypass of execute() */
X    bool	spat_flags;
X    char	spat_slen;
X};
X
X#define SPAT_USED 1			/* spat has been used once already */
X#define SPAT_ONCE 2			/* use pattern only once per reset */
X#define SPAT_SCANFIRST 4		/* initial constant not anchored */
X#define SPAT_ALL 8			/* initial constant is whole pat */
X#define SPAT_SKIPWHITE 16		/* skip leading whitespace for split */
X#define SPAT_FOLD 32			/* case insensitivity */
X#define SPAT_CONST 64			/* subst replacement is constant */
X#define SPAT_KEEP 128			/* keep 1st runtime pattern forever */
X
XEXT SPAT *curspat;		/* what to do \ interps from */
XEXT SPAT *lastspat;		/* what to use in place of null pattern */
X
XEXT char *hint INIT(Nullch);	/* hint from cmd_exec to do_match et al */
X
X#define Nullspat Null(SPAT*)
!STUFFY!FUNK!
echo Extracting t/op.undef
sed >t/op.undef <<'!STUFFY!FUNK!' -e 's/X//'
X#!./perl
X
X# $Header: op.undef,v 3.0 89/10/18 15:32:01 lwall Locked $
X
Xprint "1..21\n";
X
Xprint defined($a) ? "not ok 1\n" : "ok 1\n";
X
X$a = 1+1;
Xprint defined($a) ? "ok 2\n" : "not ok 2\n";
X
Xundef $a;
Xprint defined($a) ? "not ok 3\n" : "ok 3\n";
X
X$a = "hi";
Xprint defined($a) ? "ok 4\n" : "not ok 4\n";
X
X$a = $b;
Xprint defined($a) ? "not ok 5\n" : "ok 5\n";
X
X@ary = ("1arg");
X$a = pop(@ary);
Xprint defined($a) ? "ok 6\n" : "not ok 6\n";
X$a = pop(@ary);
Xprint defined($a) ? "not ok 7\n" : "ok 7\n";
X
X@ary = ("1arg");
X$a = shift(@ary);
Xprint defined($a) ? "ok 8\n" : "not ok 8\n";
X$a = shift(@ary);
Xprint defined($a) ? "not ok 9\n" : "ok 9\n";
X
X$ary{'foo'} = 'hi';
Xprint defined($ary{'foo'}) ? "ok 10\n" : "not ok 10\n";
Xprint defined($ary{'bar'}) ? "not ok 11\n" : "ok 11\n";
Xundef $ary{'foo'};
Xprint defined($ary{'foo'}) ? "not ok 12\n" : "ok 12\n";
X
Xprint defined(@ary) ? "ok 13\n" : "not ok 13\n";
Xprint defined(%ary) ? "ok 14\n" : "not ok 14\n";
Xundef @ary;
Xprint defined(@ary) ? "not ok 15\n" : "ok 15\n";
Xundef %ary;
Xprint defined(%ary) ? "not ok 16\n" : "ok 16\n";
X@ary = (1);
Xprint defined @ary ? "ok 17\n" : "not ok 18\n";
X%ary = (1,1);
Xprint defined %ary ? "ok 18\n" : "not ok 18\n";
X
Xsub foo { print "ok 19\n"; }
X
X&foo || print "not ok 19\n";
X
Xprint defined &foo ? "ok 20\n" : "not ok 20\n";
Xundef &foo;
Xprint defined(&foo) ? "not ok 21\n" : "ok 21\n";
!STUFFY!FUNK!
echo Extracting eg/van/unvanish
sed >eg/van/unvanish <<'!STUFFY!FUNK!' -e 's/X//'
X#!/usr/bin/perl
X
X# $Header: unvanish,v 3.0 89/10/18 15:16:35 lwall Locked $
X
Xsub it {
X    if ($olddir ne '.') {
X	chop($pwd = `pwd`) if $pwd eq '';
X	(chdir $olddir) || die "Directory $olddir is not accesible";
X    }
X    unless ($olddir eq '.deleted') {
X	if (-d '.deleted') {
X	    chdir '.deleted' || die "Directory .deleted is not accesible";
X	}
X	else {
X	    chop($pwd = `pwd`) if $pwd eq '';
X	    die "Directory .deleted does not exist" unless $pwd =~ /\.deleted$/;
X	}
X    }
X    print `mv $startfiles$filelist..$force`;
X    if ($olddir ne '.') {
X	(chdir $pwd) || die "Can't get back to original directory $pwd: $!\n";
X    }
X}
X
Xif ($#ARGV < 0) {
X    open(lastcmd,'.deleted/.lastcmd') || 
X	open(lastcmd,'.lastcmd') || 
X	    die "No previous vanish in this dir";
X    $ARGV = <lastcmd>;
X    close(lastcmd);
X    @ARGV = split(/[\n ]+/,$ARGV);
X}
X
Xwhile ($ARGV[0] =~ /^-/) {
X    $_ = shift;
X    /^-f/ && ($force = ' >/dev/null 2>&1');
X    /^-i/ && ($interactive = 1);
X    if (/^-+$/) {
X	$startfiles = '- ';
X	last;
X    }
X}
X
Xwhile ($file = shift) {
X    if ($file =~ s|^(.*)/||) {
X	$dir = $1;
X    }
X    else {
X	$dir = '.';
X    }
X
X    if ($dir ne $olddir) {
X	do it() if $olddir;
X	$olddir = $dir;
X    }
X
X    if ($interactive) {
X	print "unvanish: restore $dir/$file? ";
X	next unless <stdin> =~ /^y/i;
X    }
X
X    $filelist .= $file; $filelist .= ' ';
X
X}
X
Xdo it() if $olddir;
!STUFFY!FUNK!
echo Extracting eg/van/vanish
sed >eg/van/vanish <<'!STUFFY!FUNK!' -e 's/X//'
X#!/usr/bin/perl
X
X# $Header: vanish,v 3.0 89/10/18 15:16:46 lwall Locked $
X
Xsub it {
X    if ($olddir ne '.') {
X	chop($pwd = `pwd`) if $pwd eq '';
X	(chdir $olddir) || die "Directory $olddir is not accesible";
X    }
X    if (!-d .deleted) {
X	print `mkdir .deleted; chmod 775 .deleted`;
X	die "You can't remove files from $olddir" if $?;
X    }
X    $filelist =~ s/ $//;
X    $filelist =~ s/#/\\#/g;
X    if ($filelist !~ /^[ \t]*$/) {
X	open(lastcmd,'>.deleted/.lastcmd');
X	print lastcmd $filelist,"\n";
X	close(lastcmd);
X	print `/bin/mv $startfiles$filelist .deleted$force`;
X    }
X    if ($olddir ne '.') {
X	(chdir $pwd) || die "Can't get back to original directory $pwd: $!\n";
X    }
X}
X
Xwhile ($ARGV[0] =~ /^-/) {
X    $_ = shift;
X    /^-f/ && ($force = ' >/dev/null 2>&1');
X    /^-i/ && ($interactive = 1);
X    if (/^-+$/) {
X	$startfiles = '- ';
X	last;
X    }
X}
X
Xchop($pwd = `pwd`);
X
Xwhile ($file = shift) {
X    if ($file =~ s|^(.*)/||) {
X	$dir = $1;
X    }
X    else {
X	$dir = '.';
X    }
X
X    if ($interactive) {
X	print "vanish: remove $dir/$file? ";
X	next unless <stdin> =~ /^y/i;
X    }
X
X    if ($file eq '.deleted') {
X	print stderr "To delete .deleted (the trashcan) use the 'empty' command.\n";
X	next;
X    }
X
X    if ($dir ne $olddir) {
X	do it() if $olddir;
X	$olddir = $dir;
X    }
X
X    $filelist .= $file; $filelist .= ' ';
X}
X
Xdo it() if $olddir;
!STUFFY!FUNK!
echo Extracting eg/scan/scan_df
sed >eg/scan/scan_df <<'!STUFFY!FUNK!' -e 's/X//'
X#!/usr/bin/perl -P
X
X# $Header: scan_df,v 3.0 89/10/18 15:15:26 lwall Locked $
X
X# This report points out filesystems that are in danger of overflowing.
X
X(chdir '/usr/adm/private/memories') || die "Can't cd to memories: $!\n";
X`df >newdf`;
Xopen(Df, 'olddf');
X
Xwhile (<Df>) {
X    ($fs,$kbytes,$used,$avail,$capacity,$mounted_on) = split;
X    next if $fs =~ /:/;
X    next if $fs eq '';
X    $oldused{$fs} = $used;
X}
X
Xopen(Df, 'newdf') || die "scan_df: can't open newdf";
X
Xwhile (<Df>) {
X    ($fs,$kbytes,$used,$avail,$capacity,$mounted_on) = split;
X    next if $fs =~ /:/;
X    next if $fs eq '';
X    $oldused = $oldused{$fs};
X    next if ($oldused == $used && $capacity < 99);	# inactive filesystem
X    if ($capacity >= 90) {
X#if defined(mc300) || defined(mc500) || defined(mc700)
X	$_ = substr($_,0,13) . '        ' . substr($_,13,1000);
X	$kbytes /= 2;		# translate blocks to K
X	$used /= 2;
X	$oldused /= 2;
X	$avail /= 2;
X#endif
X	$diff = int($used - $oldused);
X	if ($avail < $diff * 2) {	# mark specially if in danger
X	    $mounted_on .= ' *';
X	}
X	next if $diff < 50 && $mounted_on eq '/';
X	$fs =~ s|/dev/||;
X	if ($diff >= 0) {
X	    $diff = '(+' . $diff . ')';
X	}
X	else {
X	    $diff = '(' . $diff . ')';
X	}
X	printf "%-8s%8d%8d %-8s%8d%7s    %s\n",
X	    $fs,$kbytes,$used,$diff,$avail,$capacity,$mounted_on;
X    }
X}
X
Xrename('newdf','olddf');
!STUFFY!FUNK!
echo Extracting eg/scan/scan_last
sed >eg/scan/scan_last <<'!STUFFY!FUNK!' -e 's/X//'
X#!/usr/bin/perl -P
X
X# $Header: scan_last,v 3.0 89/10/18 15:15:31 lwall Locked $
X
X# This reports who was logged on at weird hours
X
X($dy, $mo, $lastdt) = split(/ +/,`date`);
X
Xopen(Last, 'exec last 2>&1 |') || die "scan_last: can't run last";
X
Xwhile (<Last>) {
X#if defined(mc300) || defined(mc500) || defined(mc700)
X    $_ = substr($_,0,19) . substr($_,23,100);
X#endif
X    next if /^$/;
X    (print),next if m|^/|;
X    $login  = substr($_,0,8);
X    $tty    = substr($_,10,7);
X    $from   = substr($_,19,15);
X    $day    = substr($_,36,3);
X    $mo     = substr($_,40,3);
X    $dt     = substr($_,44,2);
X    $hr     = substr($_,47,2);
X    $min    = substr($_,50,2);
X    $dash   = substr($_,53,1);
X    $tohr   = substr($_,55,2);
X    $tomin  = substr($_,58,2);
X    $durhr  = substr($_,63,2);
X    $durmin = substr($_,66,2);
X    
X    next unless $hr;
X    next if $login eq 'reboot  ';
X    next if $login eq 'shutdown';
X
X    if ($dt != $lastdt) {
X	if ($lastdt < $dt) {
X	    $seen += $dt - $lastdt;
X	}
X	else {
X	    $seen++;
X	}
X	$lastdt = $dt;
X    }
X
X    $inat = $hr + $min / 60;
X    if ($tohr =~ /^[a-z]/) {
X	$outat = 12;		# something innocuous
X    } else {
X	$outat = $tohr + $tomin / 60;
X    }
X
X  last if $seen + ($inat < 8) > 1;
X
X    if ($inat < 5 || $inat > 21 || $outat < 6 || $outat > 23) {
X	print;
X    }
X}
!STUFFY!FUNK!
echo Extracting makedir.SH
sed >makedir.SH <<'!STUFFY!FUNK!' -e 's/X//'
Xcase $CONFIG in
X'')
X    if test ! -f config.sh; then
X	ln ../config.sh . || \
X	ln ../../config.sh . || \
X	ln ../../../config.sh . || \
X	(echo "Can't find config.sh."; exit 1)
X    fi
X    . ./config.sh
X    ;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting makedir (with variable substitutions)"
X$spitshell >makedir <<!GROK!THIS!
X$startsh
X# $Header: makedir.SH,v 3.0 89/10/18 15:20:27 lwall Locked $
X# 
X# $Log:	makedir.SH,v $
X# Revision 3.0  89/10/18  15:20:27  lwall
X# 3.0 baseline
X# 
X
Xexport PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
X
Xcase \$# in
X  0)
X    $echo "makedir pathname filenameflag"
X    exit 1
X    ;;
Xesac
X
X: guarantee one slash before 1st component
Xcase \$1 in
X  /*) ;;
X  *)  set ./\$1 \$2 ;;
Xesac
X
X: strip last component if it is to be a filename
Xcase X\$2 in
X  X1) set \`$echo \$1 | $sed 's:\(.*\)/[^/]*\$:\1:'\` ;;
X  *)  set \$1 ;;
Xesac
X
X: return reasonable status if nothing to be created
Xif $test -d "\$1" ; then
X    exit 0
Xfi
X
Xlist=''
Xwhile true ; do
X    case \$1 in
X    */*)
X	list="\$1 \$list"
X	set \`echo \$1 | $sed 's:\(.*\)/:\1 :'\`
X	;;
X    *)
X	break
X	;;
X    esac
Xdone
X
Xset \$list
X
Xfor dir do
X    $mkdir \$dir >/dev/null 2>&1
Xdone
X!GROK!THIS!
X$eunicefix makedir
Xchmod +x makedir
!STUFFY!FUNK!
echo Extracting x2p/hash.h
sed >x2p/hash.h <<'!STUFFY!FUNK!' -e 's/X//'
X/* $Header: hash.h,v 3.0 89/10/18 15:34:57 lwall Locked $
X *
X *    Copyright (c) 1989, Larry Wall
X *
X *    You may distribute under the terms of the GNU General Public License
X *    as specified in the README file that comes with the perl 3.0 kit.
X *
X * $Log:	hash.h,v $
X * Revision 3.0  89/10/18  15:34:57  lwall
X * 3.0 baseline
X * 
X */
X
X#define FILLPCT 60		/* don't make greater than 99 */
X
X#ifdef DOINIT
Xchar coeff[] = {
X		61,59,53,47,43,41,37,31,29,23,17,13,11,7,3,1,
X		61,59,53,47,43,41,37,31,29,23,17,13,11,7,3,1,
X		61,59,53,47,43,41,37,31,29,23,17,13,11,7,3,1,
X		61,59,53,47,43,41,37,31,29,23,17,13,11,7,3,1,
X		61,59,53,47,43,41,37,31,29,23,17,13,11,7,3,1,
X		61,59,53,47,43,41,37,31,29,23,17,13,11,7,3,1,
X		61,59,53,47,43,41,37,31,29,23,17,13,11,7,3,1,
X		61,59,53,47,43,41,37,31,29,23,17,13,11,7,3,1};
X#else
Xextern char coeff[];
X#endif
X
Xtypedef struct hentry HENT;
X
Xstruct hentry {
X    HENT	*hent_next;
X    char	*hent_key;
X    STR		*hent_val;
X    int		hent_hash;
X};
X
Xstruct htbl {
X    HENT	**tbl_array;
X    int		tbl_max;
X    int		tbl_fill;
X    int		tbl_riter;	/* current root of iterator */
X    HENT	*tbl_eiter;	/* current entry of iterator */
X};
X
XSTR *hfetch();
Xbool hstore();
Xbool hdelete();
XHASH *hnew();
Xint hiterinit();
XHENT *hiternext();
Xchar *hiterkey();
XSTR *hiterval();
!STUFFY!FUNK!
echo Extracting t/comp.term
sed >t/comp.term <<'!STUFFY!FUNK!' -e 's/X//'
X#!./perl
X
X# $Header: comp.term,v 3.0 89/10/18 15:26:04 lwall Locked $
X
X# tests that aren't important enough for base.term
X
Xprint "1..14\n";
X
X$x = "\\n";
Xprint "#1\t:$x: eq " . ':\n:' . "\n";
Xif ($x eq '\n') {print "ok 1\n";} else {print "not ok 1\n";}
X
X$x = "#2\t:$x: eq :\\n:\n";
Xprint $x;
Xunless (index($x,'\\\\')>0) {print "ok 2\n";} else {print "not ok 2\n";}
X
Xif (length('\\\\') == 2) {print "ok 3\n";} else {print "not ok 3\n";}
X
X$one = 'a';
X
Xif (length("\\n") == 2) {print "ok 4\n";} else {print "not ok 4\n";}
Xif (length("\\\n") == 2) {print "ok 5\n";} else {print "not ok 5\n";}
Xif (length("$one\\n") == 3) {print "ok 6\n";} else {print "not ok 6\n";}
Xif (length("$one\\\n") == 3) {print "ok 7\n";} else {print "not ok 7\n";}
Xif (length("\\n$one") == 3) {print "ok 8\n";} else {print "not ok 8\n";}
Xif (length("\\\n$one") == 3) {print "ok 9\n";} else {print "not ok 9\n";}
Xif (length("\\${one}") == 2) {print "ok 10\n";} else {print "not ok 10\n";}
X
Xif ("${one}b" eq "ab") { print "ok 11\n";} else {print "not ok 11\n";}
X
X@foo = (1,2,3);
Xif ("$foo[1]b" eq "2b") { print "ok 12\n";} else {print "not ok 12\n";}
Xif ("@foo[0..1]b" eq "1 2b") { print "ok 13\n";} else {print "not ok 13\n";}
X$" = '::';
Xif ("@foo[0..1]b" eq "1::2b") { print "ok 14\n";} else {print "not ok 14\n";}
!STUFFY!FUNK!
echo Extracting t/io.tell
sed >t/io.tell <<'!STUFFY!FUNK!' -e 's/X//'
X#!./perl
X
X# $Header: io.tell,v 3.0 89/10/18 15:26:45 lwall Locked $
X
Xprint "1..13\n";
X
X$TST = 'tst';
X
Xopen($TST, '../Makefile') || (die "Can't open ../Makefile");
X
Xif (eof(tst)) { print "not ok 1\n"; } else { print "ok 1\n"; }
X
X$firstline = <$TST>;
X$secondpos = tell;
X
X$x = 0;
Xwhile (<tst>) {
X    if (eof) {$x++;}
X}
Xif ($x == 1) { print "ok 2\n"; } else { print "not ok 2\n"; }
X
X$lastpos = tell;
X
Xunless (eof) { print "not ok 3\n"; } else { print "ok 3\n"; }
X
Xif (seek($TST,0,0)) { print "ok 4\n"; } else { print "not ok 4\n"; }
X
Xif (eof) { print "not ok 5\n"; } else { print "ok 5\n"; }
X
Xif ($firstline eq <tst>) { print "ok 6\n"; } else { print "not ok 6\n"; }
X
Xif ($secondpos == tell) { print "ok 7\n"; } else { print "not ok 7\n"; }
X
Xif (seek(tst,0,1)) { print "ok 8\n"; } else { print "not ok 8\n"; }
X
Xif (eof($TST)) { print "not ok 9\n"; } else { print "ok 9\n"; }
X
Xif ($secondpos == tell) { print "ok 10\n"; } else { print "not ok 10\n"; }
X
Xif (seek(tst,0,2)) { print "ok 11\n"; } else { print "not ok 11\n"; }
X
Xif ($lastpos == tell) { print "ok 12\n"; } else { print "not ok 12\n"; }
X
Xunless (eof) { print "not ok 13\n"; } else { print "ok 13\n"; }
!STUFFY!FUNK!
echo Extracting t/base.lex
sed >t/base.lex <<'!STUFFY!FUNK!' -e 's/X//'
X#!./perl
X
X# $Header: base.lex,v 3.0 89/10/18 15:24:24 lwall Locked $
X
Xprint "1..18\n";
X
X$ # this is the register <space>
X= 'x';
X
Xprint "#1	:$ : eq :x:\n";
Xif ($  eq 'x') {print "ok 1\n";} else {print "not ok 1\n";}
X
X$x = $#;	# this is the register $#
X
Xif ($x eq '') {print "ok 2\n";} else {print "not ok 2\n";}
X
X$x = $#x;
X
Xif ($x eq '-1') {print "ok 3\n";} else {print "not ok 3\n";}
X
X$x = '\\'; # ';
X
Xif (length($x) == 1) {print "ok 4\n";} else {print "not ok 4\n";}
X
Xeval 'while (0) {
X    print "foo\n";
X}
X/^/ && (print "ok 5\n");
X';
X
Xeval '$foo{1} / 1;';
Xif (!$@) {print "ok 6\n";} else {print "not ok 6\n";}
X
Xeval '$foo = 123+123.4+123e4+123.4E5+123.4e+5+.12;';
X
X$foo = int($foo * 100 + .5);
Xif ($foo eq 2591024652) {print "ok 7\n";} else {print "not ok 7\n";}
X
Xprint <<'EOF';
Xok 8
XEOF
X
X$foo = 'ok 9';
Xprint <<EOF;
X$foo
XEOF
X
Xeval <<\EOE, print $@;
Xprint <<'EOF';
Xok 10
XEOF
X
X$foo = 'ok 11';
Xprint <<EOF;
X$foo
XEOF
XEOE
X
Xprint <<`EOS` . <<\EOF;
Xecho ok 12
XEOS
Xok 13
XEOF
X
Xprint qq/ok 14\n/;
Xprint qq(ok 15\n);
X
Xprint qq
Xok 16\n
X;
X
Xprint q<ok 17
X>;
X
Xprint <<;   # Yow!
Xok 18
X
X# previous line intentionally left blank.
!STUFFY!FUNK!
echo Extracting eg/scan/scan_sudo
sed >eg/scan/scan_sudo <<'!STUFFY!FUNK!' -e 's/X//'
X#!/usr/bin/perl -P
X
X# $Header: scan_sudo,v 3.0 89/10/18 15:15:52 lwall Locked $
X
X# Analyze the sudo log.
X
Xchdir('/usr/adm/private/memories') || die "Can't cd to memories: $!\n";
X
Xif (open(Oldsudo,'oldsudo')) {
X    $maxpos = <Oldsudo>;
X    close Oldsudo;
X}
Xelse {
X    $maxpos = 0;
X    `echo 0 >oldsudo`;
X}
X
Xunless (open(Sudo, '/usr/adm/sudo.log')) {
X    print "Somebody removed sudo.log!!!\n" if $maxpos;
X    exit 0;
X}
X
X($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
X   $blksize,$blocks) = stat(Sudo);
X
Xif ($size < $maxpos) {
X    $maxpos = 0;
X    print "Somebody reset sudo.log!!!\n";
X}
X
Xseek(Sudo,$maxpos,0);
X
Xwhile (<Sudo>) {
X    s/^.* :[ \t]+//;
X    s/ipcrm.*/ipcrm/;
X    s/kill.*/kill/;
X    unless ($seen{$_}++) {
X	push(@seen,$_);
X    }
X    $last = $_;
X}
X$max = tell(Sudo);
X
Xopen(tmp,'|sort >oldsudo.tmp') || die "Can't create tmp file: $!\n";
Xwhile ($_ = pop(@seen)) {
X    print tmp $_;
X}
Xclose(tmp);
Xopen(tmp,'oldsudo.tmp') || die "Can't reopen tmp file: $!\n";
Xwhile (<tmp>) {
X    print $seen{$_},":\t",$_;
X}
X
Xprint `(rm -f oldsudo.tmp; echo $max > oldsudo) 2>&1`;
!STUFFY!FUNK!
echo Extracting t/op.eval
sed >t/op.eval <<'!STUFFY!FUNK!' -e 's/X//'
X#!./perl
X
X# $Header: op.eval,v 3.0 89/10/18 15:28:53 lwall Locked $
X
Xprint "1..10\n";
X
Xeval 'print "ok 1\n";';
X
Xif ($@ eq '') {print "ok 2\n";} else {print "not ok 2\n";}
X
Xeval "\$foo\n    = # this is a comment\n'ok 3';";
Xprint $foo,"\n";
X
Xeval "\$foo\n    = # this is a comment\n'ok 4\n';";
Xprint $foo;
X
Xprint eval '
X$foo =';		# this tests for a call through yyerror()
Xif ($@ =~ /line 2/) {print "ok 5\n";} else {print "not ok 5\n";}
X
Xprint eval '$foo = /';	# this tests for a call through fatal()
Xif ($@ =~ /Search/) {print "ok 6\n";} else {print "not ok 6\n";}
X
Xprint eval '"ok 7\n";';
X
X# calculate a factorial with recursive evals
X
X$foo = 5;
X$fact = 'if ($foo <= 1) {1;} else {push(@x,$foo--); (eval $fact) * pop(@x);}';
X$ans = eval $fact;
Xif ($ans == 120) {print "ok 8\n";} else {print "not ok 8\n";}
X
X$foo = 5;
X$fact = 'local($foo)=$foo; $foo <= 1 ? 1 : $foo-- * (eval $fact);';
X$ans = eval $fact;
Xif ($ans == 120) {print "ok 9\n";} else {print "not ok 9 $ans\n";}
X
Xopen(try,'>Op.eval');
Xprint try 'print "ok 10\n"; unlink "Op.eval";',"\n";
Xclose try;
X
Xdo 'Op.eval'; print $@;
!STUFFY!FUNK!
echo Extracting x2p/str.h
sed >x2p/str.h <<'!STUFFY!FUNK!' -e 's/X//'
X/* $Header: str.h,v 3.0 89/10/18 15:35:27 lwall Locked $
X *
X *    Copyright (c) 1989, Larry Wall
X *
X *    You may distribute under the terms of the GNU General Public License
X *    as specified in the README file that comes with the perl 3.0 kit.
X *
X * $Log:	str.h,v $
X * Revision 3.0  89/10/18  15:35:27  lwall
X * 3.0 baseline
X * 
X */
X
Xstruct string {
X    char *	str_ptr;	/* pointer to malloced string */
X    double	str_nval;	/* numeric value, if any */
X    int		str_len;	/* allocated size */
X    int		str_cur;	/* length of str_ptr as a C string */
X    union {
X	STR *str_next;		/* while free, link to next free str */
X    } str_link;
X    char	str_pok;	/* state of str_ptr */
X    char	str_nok;	/* state of str_nval */
X};
X
X#define Nullstr Null(STR*)
X
X/* the following macro updates any magic values this str is associated with */
X
X#define STABSET(x) (x->str_link.str_magic && stabset(x->str_link.str_magic,x))
X
XEXT STR **tmps_list;
XEXT long tmps_max INIT(-1);
X
Xchar *str_2ptr();
Xdouble str_2num();
XSTR *str_static();
XSTR *str_make();
XSTR *str_nmake();
Xchar *str_gets();
!STUFFY!FUNK!
echo Extracting lib/look.pl
sed >lib/look.pl <<'!STUFFY!FUNK!' -e 's/X//'
X;# Usage: &look(*FILEHANDLE,$key,$dict,$fold)
X
X;# Sets file position in FILEHANDLE to be first line greater than or equal
X;# (stringwise) to $key.  Pass flags for dictionary order and case folding.
X
Xsub look {
X    local(*FH,$key,$fold) = @_;
X    local($max,$min,$mid,$_);
X    local($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
X       $blksize,$blocks) = stat(FH);
X    $blksize = 8192 unless $blksize;
X    $key =~ s/[^\w\s]//g if $dict;
X    $key =~ y/A-Z/a-z/ if $fold;
X    $max = $size + $blksize - 1;
X    $max -= $size % $blksize;
X    while ($max - $min > $blksize) {
X	$mid = ($max + $min) / 2;
X	die "look: internal error"  if $mid % $blksize;
X	seek(FH,$mid,0);
X	$_ = <FH>;		# probably a partial line
X	$_ = <FH>;
X	chop;
X	s/[^\w\s]//g if $dict;
X	y/A-Z/a-z/ if $fold;
X	if ($_ lt $key) {
X	    $min = $mid;
X	}
X	else {
X	    $max = $mid;
X	}
X    }
X    seek(FH,$min,0);
X    while (<FH>) {
X	chop;
X	s/[^\w\s]//g if $dict;
X	y/A-Z/a-z/ if $fold;
X	last if $_ ge $key;
X	$min = tell(FH);
X    }
X    seek(FH,$min,0);
X    $min;
X}
X
X1;
!STUFFY!FUNK!
echo Extracting t/op.each
sed >t/op.each <<'!STUFFY!FUNK!' -e 's/X//'
X#!./perl
X
X# $Header: op.each,v 3.0 89/10/18 15:28:48 lwall Locked $
X
Xprint "1..3\n";
X
X$h{'abc'} = 'ABC';
X$h{'def'} = 'DEF';
X$h{'jkl','mno'} = "JKL\034MNO";
X$h{'a',2,3,4,5} = join("\034",'A',2,3,4,5);
X$h{'a'} = 'A';
X$h{'b'} = 'B';
X$h{'c'} = 'C';
X$h{'d'} = 'D';
X$h{'e'} = 'E';
X$h{'f'} = 'F';
X$h{'g'} = 'G';
X$h{'h'} = 'H';
X$h{'i'} = 'I';
X$h{'j'} = 'J';
X$h{'k'} = 'K';
X$h{'l'} = 'L';
X$h{'m'} = 'M';
X$h{'n'} = 'N';
X$h{'o'} = 'O';
X$h{'p'} = 'P';
X$h{'q'} = 'Q';
X$h{'r'} = 'R';
X$h{'s'} = 'S';
X$h{'t'} = 'T';
X$h{'u'} = 'U';
X$h{'v'} = 'V';
X$h{'w'} = 'W';
X$h{'x'} = 'X';
X$h{'y'} = 'Y';
X$h{'z'} = 'Z';
X
X@keys = keys %h;
X@values = values %h;
X
Xif ($#keys == 29 && $#values == 29) {print "ok 1\n";} else {print "not ok 1\n";}
X
Xwhile (($key,$value) = each(h)) {
X    if ($key eq $keys[$i] && $value eq $values[$i] && $key gt $value) {
X	$key =~ y/a-z/A-Z/;
X	$i++ if $key eq $value;
X    }
X}
X
Xif ($i == 30) {print "ok 2\n";} else {print "not ok 2\n";}
X
X@keys = ('blurfl', keys(%h), 'dyick');
Xif ($#keys == 31) {print "ok 3\n";} else {print "not ok 3\n";}
!STUFFY!FUNK!
echo Extracting t/op.time
sed >t/op.time <<'!STUFFY!FUNK!' -e 's/X//'
X#!./perl
X
X# $Header: op.time,v 3.0 89/10/18 15:31:56 lwall Locked $
X
Xprint "1..5\n";
X
X($beguser,$begsys) = times;
X
X$beg = time;
X
Xwhile (($now = time) == $beg) {}
X
Xif ($now > $beg && $now - $beg < 10){print "ok 1\n";} else {print "not ok 1\n";}
X
Xfor ($i = 0; $i < 100000; $i++) {
X    ($nowuser, $nowsys) = times;
X    $i = 200000 if $nowuser > $beguser && $nowsys > $begsys;
X    last if time - $beg > 20;
X}
X
Xif ($i >= 200000) {print "ok 2\n";} else {print "not ok 2\n";}
X
X($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($beg);
X($xsec,$foo) = localtime($now);
X$localyday = $yday;
X
Xif ($sec != $xsec && $mday && $year)
X    {print "ok 3\n";}
Xelse
X    {print "not ok 3\n";}
X
X($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime($beg);
X($xsec,$foo) = localtime($now);
X
Xif ($sec != $xsec && $mday && $year)
X    {print "ok 4\n";}
Xelse
X    {print "not ok 4\n";}
X
Xif (index(" :0:1:-1:365:366:-365:-366:",':' . ($localyday - $yday) . ':') > 0)
X    {print "ok 5\n";}
Xelse
X    {print "not ok 5\n";}
!STUFFY!FUNK!
echo Extracting lib/getopt.pl
sed >lib/getopt.pl <<'!STUFFY!FUNK!' -e 's/X//'
X;# $Header: getopt.pl,v 3.0 89/10/18 15:19:26 lwall Locked $
X
X;# Process single-character switches with switch clustering.  Pass one argument
X;# which is a string containing all switches that take an argument.  For each
X;# switch found, sets $opt_x (where x is the switch name) to the value of the
X;# argument, or 1 if no argument.  Switches which take an argument don't care
X;# whether there is a space between the switch and the argument.
X
X;# Usage:
X;#	do Getopt('oDI');  # -o, -D & -I take arg.  Sets opt_* as a side effect.
X
Xsub Getopt {
X    local($argumentative) = @_;
X    local($_,$first,$rest);
X
X    while (($_ = $ARGV[0]) =~ /^-(.)(.*)/) {
X	($first,$rest) = ($1,$2);
X	if (index($argumentative,$first) >= $[) {
X	    if ($rest ne '') {
X		shift(@ARGV);
X	    }
X	    else {
X		shift(@ARGV);
X		$rest = shift(@ARGV);
X	    }
X	    eval "\$opt_$first = \$rest;";
X	}
X	else {
X	    eval "\$opt_$first = 1;";
X	    if ($rest ne '') {
X		$ARGV[0] = "-$rest";
X	    }
X	    else {
X		shift(@ARGV);
X	    }
X	}
X    }
X}
X
X1;
!STUFFY!FUNK!
echo Extracting t/op.do
sed >t/op.do <<'!STUFFY!FUNK!' -e 's/X//'
X#!./perl
X
X# $Header: op.do,v 3.0 89/10/18 15:28:43 lwall Locked $
X
Xsub foo1
X{
X    print $_[0];
X    'value';
X}
X
Xsub foo2
X{
X    shift(_);
X    print $_[0];
X    $x = 'value';
X    $x;
X}
X
Xprint "1..15\n";
X
X$_[0] = "not ok 1\n";
X$result = do foo1("ok 1\n");
Xprint "#2\t:$result: eq :value:\n";
Xif ($result EQ 'value') { print "ok 2\n"; } else { print "not ok 2\n"; }
Xif ($_[0] EQ "not ok 1\n") { print "ok 3\n"; } else { print "not ok 3\n"; }
X
X$_[0] = "not ok 4\n";
X$result = do foo2("not ok 4\n","ok 4\n","not ok 4\n");
Xprint "#5\t:$result: eq :value:\n";
Xif ($result EQ 'value') { print "ok 5\n"; } else { print "not ok 5\n"; }
Xif ($_[0] EQ "not ok 4\n") { print "ok 6\n"; } else { print "not ok 6\n"; }
X
X$result = do{print "ok 7\n"; 'value';};
Xprint "#8\t:$result: eq :value:\n";
Xif ($result EQ 'value') { print "ok 8\n"; } else { print "not ok 8\n"; }
X
Xsub blather {
X    print @_;
X}
X
Xdo blather("ok 9\n","ok 10\n");
X@x = ("ok 11\n", "ok 12\n");
X@y = ("ok 14\n", "ok 15\n");
Xdo blather(@x,"ok 13\n",@y);
!STUFFY!FUNK!
echo Extracting regexp.h
sed >regexp.h <<'!STUFFY!FUNK!' -e 's/X//'
X/*
X * Definitions etc. for regexp(3) routines.
X *
X * Caveat:  this is V8 regexp(3) [actually, a reimplementation thereof],
X * not the System V one.
X */
X
X/* $Header: regexp.h,v 3.0 89/10/18 15:22:46 lwall Locked $
X *
X * $Log:	regexp.h,v $
X * Revision 3.0  89/10/18  15:22:46  lwall
X * 3.0 baseline
X * 
X */
X
X#define NSUBEXP  10
X
Xtypedef struct regexp {
X	char *startp[NSUBEXP];
X	char *endp[NSUBEXP];
X	STR *regstart;		/* Internal use only. */
X	char *regstclass;
X	STR *regmust;		/* Internal use only. */
X	int regback;		/* Can regmust locate first try? */
X	char *precomp;		/* pre-compilation regular expression */
X	char *subbase;		/* saved string so \digit works forever */
X	char reganch;		/* Internal use only. */
X	char do_folding;	/* do case-insensitive match? */
X	char lastparen;		/* last paren matched */
X	char nparens;		/* number of parentheses */
X	char program[1];	/* Unwarranted chumminess with compiler. */
X} regexp;
X
Xregexp *regcomp();
Xint regexec();
!STUFFY!FUNK!
echo Extracting t/cmd.for
sed >t/cmd.for <<'!STUFFY!FUNK!' -e 's/X//'
X#!./perl
X
X# $Header: cmd.for,v 3.0 89/10/18 15:24:43 lwall Locked $
X
Xprint "1..7\n";
X
Xfor ($i = 0; $i <= 10; $i++) {
X    $x[$i] = $i;
X}
X$y = $x[10];
Xprint "#1	:$y: eq :10:\n";
X$y = join(' ', @x);
Xprint "#1	:$y: eq :0 1 2 3 4 5 6 7 8 9 10:\n";
Xif (join(' ', @x) eq '0 1 2 3 4 5 6 7 8 9 10') {
X	print "ok 1\n";
X} else {
X	print "not ok 1\n";
X}
X
X$i = $c = 0;
Xfor (;;) {
X	$c++;
X	last if $i++ > 10;
X}
Xif ($c == 12) {print "ok 2\n";} else {print "not ok 2\n";}
X
X$foo = 3210;
X@ary = (1,2,3,4,5);
Xforeach $foo (@ary) {
X	$foo *= 2;
X}
Xif (join('',@ary) eq '246810') {print "ok 3\n";} else {print "not ok 3\n";}
X
Xfor (@ary) {
X    s/(.*)/ok $1\n/;
X}
X
Xprint $ary[1];
X
X# test for internal scratch array generation
X# this also tests that $foo was restored to 3210 after test 3
Xfor (split(' ','a b c d e')) {
X	$foo .= $_;
X}
Xif ($foo eq '3210abcde') {print "ok 5\n";} else {print "not ok 5 $foo\n";}
X
Xforeach $foo (("ok 6\n","ok 7\n")) {
X	print $foo;
X}
!STUFFY!FUNK!
echo Extracting t/op.magic
sed >t/op.magic <<'!STUFFY!FUNK!' -e 's/X//'
X#!./perl
X
X# $Header: op.magic,v 3.0 89/10/18 15:29:54 lwall Locked $
X
X$| = 1;		# command buffering
X
Xprint "1..5\n";
X
Xeval '$ENV{"foo"} = "hi there";';	# check that ENV is inited inside eval
Xif (`echo \$foo` eq "hi there\n") {print "ok 1\n";} else {print "not ok 1\n";}
X
X$! = 0;
Xopen(foo,'ajslkdfpqjsjfkslkjdflksd');
Xif ($! == 2) {print "ok 2\n";} else {print "not ok 2\n";}
X
X# the next tests are embedded inside system simply because sh spits out
X# a newline onto stderr when a child process kills itself with SIGINT.
X
Xsystem './perl',
X'-e', '$| = 1;		# command buffering',
X
X'-e', '$SIG{"INT"} = "ok3"; kill 2,$$;',
X'-e', '$SIG{"INT"} = "IGNORE"; kill 2,$$; print "ok 4\n";',
X'-e', '$SIG{"INT"} = "DEFAULT"; kill 2,$$; print "not ok\n";',
X
X'-e', 'sub ok3 { print "ok 3\n" if pop(@_) eq "INT"; }';
X
X@val1 = @ENV{keys(%ENV)};	# can we slice ENV?
X@val2 = values(%ENV);
X
Xprint join(':',@val1) eq join(':',@val2) ? "ok 5\n" : "not ok 5\n";
!STUFFY!FUNK!
echo Extracting t/op.repeat
sed >t/op.repeat <<'!STUFFY!FUNK!' -e 's/X//'
X#!./perl
X
X# $Header: op.repeat,v 3.0 89/10/18 15:31:07 lwall Locked $
X
Xprint "1..11\n";
X
X# compile time
X
Xif ('-' x 5 eq '-----') {print "ok 1\n";} else {print "not ok 1\n";}
Xif ('-' x 1 eq '-') {print "ok 2\n";} else {print "not ok 2\n";}
Xif ('-' x 0 eq '') {print "ok 3\n";} else {print "not ok 3\n";}
X
Xif ('ab' x 3 eq 'ababab') {print "ok 4\n";} else {print "not ok 4\n";}
X
X# run time
X
X$a = '-';
Xif ($a x 5 eq '-----') {print "ok 5\n";} else {print "not ok 5\n";}
Xif ($a x 1 eq '-') {print "ok 6\n";} else {print "not ok 6\n";}
Xif ($a x 0 eq '') {print "ok 7\n";} else {print "not ok 7\n";}
X
X$a = 'ab';
Xif ($a x 3 eq 'ababab') {print "ok 8\n";} else {print "not ok 8\n";}
X
X$a = 'xyz';
X$a x= 2;
Xif ($a eq 'xyzxyz') {print "ok 9\n";} else {print "not ok 9\n";}
X$a x= 1;
Xif ($a eq 'xyzxyz') {print "ok 10\n";} else {print "not ok 10\n";}
X$a x= 0;
Xif ($a eq '') {print "ok 11\n";} else {print "not ok 11\n";}
X
!STUFFY!FUNK!
echo Extracting t/io.argv
sed >t/io.argv <<'!STUFFY!FUNK!' -e 's/X//'
X#!./perl
X
X# $Header: io.argv,v 3.0 89/10/18 15:26:10 lwall Locked $
X
Xprint "1..5\n";
X
Xopen(try, '>Io.argv.tmp') || (die "Can't open temp file.");
Xprint try "a line\n";
Xclose try;
X
X$x = `./perl -e 'while (<>) {print \$.,\$_;}' Io.argv.tmp Io.argv.tmp`;
X
Xif ($x eq "1a line\n2a line\n") {print "ok 1\n";} else {print "not ok 1\n";}
X
X$x = `echo foo|./perl -e 'while (<>) {print $_;}' Io.argv.tmp -`;
X
Xif ($x eq "a line\nfoo\n") {print "ok 2\n";} else {print "not ok 2\n";}
X
X$x = `echo foo|./perl -e 'while (<>) {print $_;}'`;
X
Xif ($x eq "foo\n") {print "ok 3\n";} else {print "not ok 3\n";}
X
X@ARGV = ('Io.argv.tmp', 'Io.argv.tmp', '/dev/null', 'Io.argv.tmp');
Xwhile (<>) {
X    $y .= $. . $_;
X    if (eof()) {
X	if ($. == 3) {print "ok 4\n";} else {print "not ok 4\n";}
X    }
X}
X
Xif ($y eq "1a line\n2a line\n3a line\n")
X    {print "ok 5\n";}
Xelse
X    {print "not ok 5\n";}
X
X`/bin/rm -f Io.argv.tmp`;
!STUFFY!FUNK!
echo Extracting eg/changes
sed >eg/changes <<'!STUFFY!FUNK!' -e 's/X//'
X#!/usr/bin/perl -P
X
X# $Header: changes,v 3.0 89/10/18 15:13:23 lwall Locked $
X
X($dir, $days) = @ARGV;
X$dir = '/' if $dir eq '';
X$days = '14' if $days eq '';
X
X# Masscomps do things differently from Suns
X
X#if defined(mc300) || defined(mc500) || defined(mc700)
Xopen(Find, "find $dir -mtime -$days -print |") ||
X	die "changes: can't run find";
X#else
Xopen(Find, "find $dir \\( -fstype nfs -prune \\) -o -mtime -$days -ls |") ||
X	die "changes: can't run find";
X#endif
X
Xwhile (<Find>) {
X
X#if defined(mc300) || defined(mc500) || defined(mc700)
X    $x = `/bin/ls -ild $_`;
X    $_ = $x;
X    ($inode,$perm,$links,$owner,$group,$size,$month,$day,$time,$name)
X      = split(' ');
X#else
X    ($inode,$blocks,$perm,$links,$owner,$group,$size,$month,$day,$time,$name)
X      = split(' ');
X#endif
X
X    printf("%10s%3s %-8s %-8s%9s %3s %2s %s\n",
X	    $perm,$links,$owner,$group,$size,$month,$day,$name);
X}
X
!STUFFY!FUNK!
echo Extracting eg/myrup
sed >eg/myrup <<'!STUFFY!FUNK!' -e 's/X//'
X#!/usr/bin/perl
X
X# $Header: myrup,v 3.0 89/10/18 15:15:06 lwall Locked $
X
X# This was a customization of ruptime requested by someone here who wanted
X# to be able to find the least loaded machine easily.  It uses the
X# /etc/ghosts file that's defined for gsh and gcp to prune down the
X# number of entries to those hosts we have administrative control over.
X
Xprint "node    load (u)\n------- --------\n";
X
Xopen(ghosts,'/etc/ghosts') || die "Can't open /etc/ghosts: $!";
Xline: while (<ghosts>) {
X    next line if /^#/;
X    next line if /^$/;
X    next line if /=/;
X    ($host) = split;
X    $wanted{$host} = 1;
X}
X
Xopen(ruptime,'ruptime|') || die "Can't run ruptime: $!";
Xopen(sort,'|sort +1n');
X
Xwhile (<ruptime>) {
X    ($host,$upness,$foo,$users,$foo,$foo,$load) = split(/[\s,]+/);
X    if ($wanted{$host} && $upness eq 'up') {
X	printf sort "%s\t%s (%d)\n", $host, $load, $users;
X    }
X}
!STUFFY!FUNK!
echo Extracting eg/shmkill
sed >eg/shmkill <<'!STUFFY!FUNK!' -e 's/X//'
X#!/usr/bin/perl
X
X# $Header: shmkill,v 3.0 89/10/18 15:16:09 lwall Locked $
X
X# A script to call from crontab periodically when people are leaving shared
X# memory sitting around unattached.
X
Xopen(ipcs,'ipcs -m -o|') || die "Can't run ipcs: $!";
X
Xwhile (<ipcs>) {
X    $tmp = index($_,'NATTCH');
X    $pos = $tmp if $tmp >= 0;
X    if (/^m/) {
X	($m,$id,$key,$mode,$owner,$group,$attach) = split;
X	if ($attach != substr($_,$pos,6)) {
X	    die "Different ipcs format--can't parse!\n";
X	}
X	if ($attach == 0) {
X	    push(@goners,'-m',$id);
X	}
X    }
X}
X
Xexec 'ipcrm', @goners if $#goners >= 0;
!STUFFY!FUNK!
echo ""
echo "End of kit 23 (of 24)"
cat /dev/null >kit23isdone
run=''
config=''
for iskit in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24; do
    if test -f kit${iskit}isdone; then
	run="$run $iskit"
    else
	todo="$todo $iskit"
    fi
done
case $todo in
    '')
	echo "You have run all your kits.  Please read README and then type Configure."
	chmod 755 Configure
	;;
    *)  echo "You have run$run."
	echo "You still need to run$todo."
	;;
esac
: Someone might mail this, so...
exit

