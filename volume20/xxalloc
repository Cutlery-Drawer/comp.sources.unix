Subject:  v20i028:  Multi-dimension dynamic array manipulation package
Newsgroups: comp.sources.unix,comp.lang.c
Sender: sources
Approved: rsalz@uunet.UU.NET
Followups-to: comp.sources.d

Submitted-by: Harold G. Walters <walters@ce.okstate.edu>
Posting-number: Volume 20, Issue 28
Archive-name: xxalloc

[  109 functions!?  Wow... This is one of the rare cross-posts into
   comp.lang.c /r$  ]

xxalloc is a family of routines for dynamic array manipulation in one,
two and three dimensions.  Routines are included for allocation,
initialization, printing, renumbering, and freeing both arrays of
structures and arrays of simple types.  Since the "edge-vector" approach
is used for two and three dimensional arrays, this set of routines
allows for the development of reusable subroutine libraries without
regard to some "maximum" dimension.  Both positive and negative indices
are allowed. 

Installation instructions are in the makefile.  A test program is
included to exercise most of the package.  I have compiled this package
on many machines (SYS5, BSD, MSDOS) without a hitch.  The man page uses
some abbreviation to save space since there are actually 109 functions


--
Harold G. Walters                 Internet: walters@ce.okstate.edu
School of Civil Engineering       Uucp: {cbosgd, ihnp4, uiucdcs}
Oklahoma State University               	!okstate!osubem!walters
Stillwater, OK 74078 "If all you have is a hammer, everything looks like a nail"

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 1)."
# Contents:  MANIFEST Makefile README example1.c example2.c nx.c nx.h
#   nxtest.c proto.h tx.c tx.h txtest.c xx.sh xxalloc.man xxerror.c
#   xxh.sh xxtest.sh
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(641 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	This shipping list
X Makefile                   1	
X README                     1	
X example1.c                 1	
X example2.c                 1	
X nx.c                       1	
X nx.h                       1	
X nxtest.c                   1	
X proto.h                    1	
X tx.c                       1	
X tx.h                       1	
X txtest.c                   1	
X xx.sh                      1	
X xxalloc.man                1	
X xxerror.c                  1	
X xxh.sh                     1	
X xxtest.sh                  1	
END_OF_FILE
if test 641 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(2980 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#/*makefile***************************************************************/     
X#/*									*/
X#/*				xxalloc 				*/
X#/*									*/
X#/*			Placed in the public domain			*/
X#/*			 by Harold G. Walters 1988			*/
X#/*									*/
X#/*	Bug fixes, ect to walters@ce.okstate.edu until May 1989		*/
X#/*									*/
X#/*	This software is provided as is.  No claims are made for	*/
X#/*	this software regarding its fitness and/or correctness for	*/
X#/* 	any purpose.  Use of this software is at the user's own risk.	*/
X#/*									*/
X#/************************************************************************/
X#
X# Memory is allocated with calloc().  If your compiler requires that memory
X# allocated with calloc() be freed with cfree() then add a -Dfree=cfree to
X# the CFLAGS line
X#
X# The package testing program is automatically executed.  Some compilers
X# may generate warnings about illegal pointer combinations.  Ignore these -
X# the compiler is wrong.  The testing program will generate a messages like
X# 		checking type n
X# This is correct. Other messages mean something is wrong.
X#
X# This package should be compiled first on a UN*X machine to generate the
X# .c and .h files since the Makefile uses things like sed, cp, and echo.
X# The generated files can then be copied to whatever machine you want.
X
CFLAGS = -O
X
X# For installation the following need to be defined for your system
X
LIB = /usr/lib
MAN = /usr/man/manl
INCLUDE = /usr/include
SECTION = l
X
all: xxalloc.c xxalloc.h \
xxalloc.o libxxalloc.a \
xxerror.o libxxerror.a \
xxalloc.$(SECTION) xxtest 
X
xxalloc.c: nx.c tx.c 
X	chmod u+x xx.sh
X	cp nx.c $@
X	xx.sh char c tx.c $@
X	xx.sh short s tx.c $@
X	xx.sh long l tx.c $@
X	xx.sh int i tx.c $@
X	xx.sh float f tx.c $@
X	xx.sh double d tx.c $@
X	
xxalloc.h: nx.h tx.h 
X	chmod u+x xx.sh
X	cp nx.h $@
X	xx.sh char c tx.h $@
X	xx.sh short s tx.h $@
X	xx.sh long l tx.h $@
X	xx.sh int i tx.h $@
X	xx.sh float f tx.h $@
X	xx.sh double d tx.h $@
X
xxtest.c: nxtest.c txtest.c 
X	chmod u+x xxtest.sh
X	cp nxtest.c $@
X	xxtest.sh char c d txtest.c $@
X	xxtest.sh short s d txtest.c $@
X	xxtest.sh long l ld txtest.c $@
X	xxtest.sh int i d txtest.c $@
X	xxtest.sh float f f txtest.c $@
X	xxtest.sh double d lf txtest.c $@
X	echo 'exit(0); }' >> $@
X
xxalloc.o: xxalloc.c xxalloc.h
X
xxtest.o: xxtest.c xxalloc.h
X
xxtest: xxtest.o xxalloc.h xxalloc.o xxerror.o
X	$(CC) $(CFLAGS) xxtest.o xxalloc.o xxerror.o -o xxtest
X	xxtest
X
libxxalloc.a: xxalloc.o
X	ar rv $@ xxalloc.o
X
libxxerror.a: xxerror.o
X	ar rv $@ xxerror.o
X
xxalloc.$(SECTION): xxalloc.man
X	cp xxalloc.man xxalloc.$(SECTION)
X
install:
X	cp libxxalloc.a $(LIB)
X	chmod 664 $(LIB)/libxxalloc.a
X	cp libxxerror.a $(LIB)
X	chmod 664 $(LIB)/libxxalloc.a
X	cp xxalloc.h $(INCLUDE)
X	chmod 664 $(INCLUDE)/xxalloc.h
X	cp xxalloc.$(SECTION) $(MAN)
X	chmod 664 $(MAN)/xxalloc.$(SECTION)
X
clean:
X	rm -f core *.o xxtest libxxalloc.a libxxerror.a xxalloc.$(SECTION)
X
superclean:
X	rm -f core *.o xxtest libxxalloc.a libxxerror.a xxalloc.$(SECTION) \
xxalloc.c xxalloc.h xxtest.c
X
X
END_OF_FILE
if test 2980 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(1664 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
xxalloc is a family of routines for dynamic array manipulation in one,
two and three dimensions.  Routines are included for allocation,
initialization, printing, renumbering, and freeing both arrays of
structures and arrays of simple types.  Since the "edge-vector" approach
is used for two and three dimensional arrays, this set of routines
allows for the development of reusable subroutine libraries without
regard to some "maximum" dimension.  Both positive and negative indices
are allowed. 
X
When I converted to C several years ago after my first large program in
XFORTRAN, the first thing I wanted to do was to have adjustable
multi-dimensional arrays.  This can be achieved in C (sort of, the array
dimensions are fixed) through the use of pointers (the so called
X"edge-vector" approach, see also K&R p.  110).  I then added routines
for manipulating structures and routines for renumbering the indices,
initializing, and printing.  These routines also solve the problem of
not being able to have 2D arrays greater than 64k on machines with 16
bit addresses (ie.  PC's). 
X
Installation instructions are in the makefile.  A test program is
included to exercise most of the package.  I have compiled this package
on many machines (SYS5, BSD, MSDOS) without a hitch.  The man page uses
some abbreviation to save space since there are actually 109 functions
in this package. 
X
X--
Harold G. Walters                 Internet: walters@ce.okstate.edu
School of Civil Engineering       Uucp: {cbosgd, ihnp4, uiucdcs}
Oklahoma State University               	!okstate!osubem!walters
Stillwater, OK 74078 "If all you have is a hammer, everything looks like a nail"
X
X
X
X
END_OF_FILE
if test 1664 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'example1.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'example1.c'\"
else
echo shar: Extracting \"'example1.c'\" \(1396 characters\)
sed "s/^X//" >'example1.c' <<'END_OF_FILE'
X/* example1.c */
X
X#include <stdio.h>
X#include <xxalloc.h>
X
void mtxtsp(a, ib, ie, jb, je, b)
double **a, **b;
int ib, ie, jb, je;
X{
X	int i, j;
X	double tmp;
X	
X	for (i = ib; i <= ie; i++)
X 		for (j = i; j <= je; j++)
X		{
X			tmp = a[i][j];
X			b[i][j] = a[j][i];
X			b[j][i] = tmp;
X		}
X	return;
X}
X
main()
X{
X	double **a;
X	int i, j;
X	
X/* allocate a two dimensional array of doubles */
X
X	a = d2_alloc(0, 9, 0, 9);
X
X/* initialize the array to 1.0 and print */
X
X	d2_init(a, 0, 9, 0, 9, 1.0);
X	printf("\ninitialized to 1\n");
X	d2_prnt(stdout, "%5.0f ", a, 0, 9, 0, 9);
X
X/* set the array equal to the 2*i + j and print*/
X
X	for (i = 0; i < 10; i++)
X		for (j = 0; j < 10; j++)
X			a[i][j] = (double) (2*i + j);
X	printf("\n2*i + j\n");
X	d2_prnt(stdout, "%5.0f ", a, 0, 9, 0, 9);
X
X/* take the transpose and print*/
X
X	mtxtsp(a, 0, 9, 0, 9, a);
X	printf("\ntransposed\n");
X	d2_prnt(stdout, "%5.0f ", a, 0, 9, 0, 9);
X
X/* renumber the indices a la FORTRAN and print*/
X/* the new indices must be used from now on */
X
X	a = d2_renum(a, 0, 9, 0, 9, 1, 10, 1, 10);
X	printf("\nrenumbered\n");
X	d2_prnt(stdout, "%5.0f ", a, 1, 10, 1, 10);
X
X/* renumber the indices a la C and print */
X/* the new indices must be used from now on */
X
X	a = d2_renum(a, 1, 10, 1, 10, 0, 9, 0, 9);
X	printf("\nrenumbered again\n");
X	d2_prnt(stdout, "%5.0f ", a, 0, 9, 0, 9);
X
X/* free the allocated memory */
X
X	d2_free(a, 0, 9, 0, 9);
X	exit(0);
X}		
END_OF_FILE
if test 1396 -ne `wc -c <'example1.c'`; then
    echo shar: \"'example1.c'\" unpacked with wrong size!
fi
# end of 'example1.c'
fi
if test -f 'example2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'example2.c'\"
else
echo shar: Extracting \"'example2.c'\" \(1290 characters\)
sed "s/^X//" >'example2.c' <<'END_OF_FILE'
X/* example2.c */
X
X#include <stdio.h>
X#include <xxalloc.h>
X
typedef struct
X{
X	double dnum;
X	int inum;
X} NUM;
X
X/* structure initialization function */
X/* passed as an argument to {d}n_init() */
void num_init(num)
NUM *num;
X{
X	num->dnum = 1.0;
X	num->inum = 1;
X	return;
X}
X
X/* structure printing function */
X/* passed as an argument to {d}n_prnt() */
void num_prnt(fp, num)
XFILE *fp;
NUM *num;
X{
X	fprintf(fp, "%5.1f %3d ", num->dnum, num->inum);
X	return;
X}
X
main()
X{
X	int i;
X	NUM *num;
X	
X/* allocate a one dimensional array of NUM */
X
X	num = (NUM *) n1_alloc(0, 4, sizeof(NUM));
X
X/* initialize the array to 1.0 and print */
X
X	n1_init(num, 0, 4, sizeof(NUM), num_init);
X	printf("\ninitialized to 1\n");
X	n1_prnt(stdout, num_prnt, num, 0, 4, sizeof(NUM));
X
X/* set the array equal to the i and print */
X
X	for (i = 0; i <= 4; i++)
X	{
X		num[i].dnum = (double) i;
X		num[i].inum = i;
X	}
X	printf("\nset to i\n");
X	n1_prnt(stdout, num_prnt, num, 0, 4, sizeof(NUM));
X
X/* renumber the indices a la FORTRAN and print */
X/* the new indices must be used from now on */
X
X	num = (NUM *) n1_renum(num, 0, 4, 1, 5, sizeof(NUM));
X	printf("\nindicies renumbered\n");
X	n1_prnt(stdout, num_prnt, num, 1, 5, sizeof(NUM));
X	printf("\n");
X
X/* free the allocated memory */
X
X	n1_free(num, 1, 5, sizeof(NUM));
X	exit(0);
X}
X
END_OF_FILE
if test 1290 -ne `wc -c <'example2.c'`; then
    echo shar: \"'example2.c'\" unpacked with wrong size!
fi
# end of 'example2.c'
fi
if test -f 'nx.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nx.c'\"
else
echo shar: Extracting \"'nx.c'\" \(6395 characters\)
sed "s/^X//" >'nx.c' <<'END_OF_FILE'
X/*xxalloc.c**************************************************************/     
X/*									*/
X/*				xxalloc 				*/
X/*									*/
X/*			Placed in the public domain			*/
X/*			 by Harold G. Walters 1988			*/
X/*									*/
X/*	Bug fixes, ect to walters@ce.okstate.edu until May 1989		*/
X/*									*/
X/*	This software is provided as is.  No claims are made for	*/
X/*	this software regarding its fitness and/or correctness for	*/
X/* 	any purpose.  Use of this software is at the user's own risk.	*/
X/*									*/
X/************************************************************************/
X
X#include <stdio.h>
X
extern char *calloc();
extern void free();
X
X#define STRLEN 132
static char msg[STRLEN];
static long amount = 0L;
X
extern void xx_error();
X
char *xx_alloc(n)
unsigned n;
X{
X	char *m;
X	amount += n;
X	if ((m = calloc(1, n)) == (char *) NULL)
X	{
X		sprintf(msg, "xx_alloc: memory allocation error at %ld bytes\n",
X			amount);
X		xx_error(msg);
X		return((char *) NULL);
X	}
X	return((char *) m);
X}
X
void xx_free(p, n)
char *p;
unsigned n;
X{
X	free(p);
X	amount -= n;
X	return;
X}
X
long xx_amount()
X{
X	return(amount);
X}
X
X/* end index >= begin index */
static void index_test(b, e)
int b, e;
X{
X	if (e < b)
X	{
X		sprintf(msg, "index_test: end index %d < begin index %d\n",
X			e, b);
X		xx_error(msg);
X		/* exit here even if xx_error() returns */
X		/* this is a programming error if this ever happens */
X		exit(2);
X	}
X	return;
X}
X
char *n1_alloc(ib, ie, n)
int ib, ie, n;
X{
X	char *m;
X	index_test(ib, ie);
X	m = (char *) xx_alloc((unsigned) (ie - ib + 1) * n);
X	if (m == (char *) NULL) return((char *) NULL);
X	m -= ib * n;
X	return((char *) m);
X}
X
char *n1_renum(m, ib, ie, nib, nie, n)
char *m;
int ib, ie, nib, nie, n;
X{
X	index_test(ib, ie);
X	index_test(nib, nie);
X	m += (ib - nib) * n;
X	return((char *) m);
X}
X
void n1_free(m, ib, ie, n)
char *m;
int ib, ie, n;
X{
X	index_test(ib, ie);
X	xx_free((char*) (m + ib * n), (unsigned) ((ie - ib + 1) * n));
X	return;
X}
X
void n1_init(m, ib, ie, n, nini)
char *m;
int ib, ie, n;
void (*nini)();
X{
X	int i;
X	index_test(ib, ie);
X	if (nini == (void (*)()) NULL)
X		return;
X	for (i = ib; i <= ie; i++)
X		(*nini)(&m[i*n]);
X	return;
X}
X
void n1_prnt(fp, nprn, m, ib, ie, n)
XFILE *fp;
void (*nprn)();
char *m;
int ib, ie, n;
X{
X	int i;
X	index_test(ib, ie);
X	if (nprn == (void (*)()) NULL)
X		return;
X	for (i = ib; i <= ie; i++)
X		(*nprn)(fp, &m[i*n]);
X	return;
X}
X
char **n2_alloc(ib, ie, jb, je, n)
int ib, ie, jb, je, n;
X{
X	int i;
X	char **m;
X	index_test(ib, ie);
X	index_test(jb, je);
X	m = (char **) xx_alloc((unsigned) (ie - ib + 1) * sizeof(char *));
X	if (m == (char **) NULL) return((char **) NULL);
X	m -= ib;
X	for(i = ib; i <= ie; i++)
X	{
X		m[i] = (char *) xx_alloc((unsigned) (je - jb + 1) * n);
X		if (m[i] == (char *) NULL) return((char **) NULL);
X		m[i] -= jb * n;
X	}
X	return((char **) m);
X}
X
char **n2_renum(m, ib, ie, jb, je, nib, nie, njb, nje, n)
char **m;
int ib, ie, jb, je, nib, nie, njb, nje, n;
X{
X	int i;
X	index_test(ib, ie);
X	index_test(jb, je);
X	index_test(nib, nie);
X	index_test(njb, nje);
X	for(i = ie; i >= ib; i--)
X		m[i] += (jb - njb) * n;
X	m += (ib - nib);
X	return((char **) m);
X}
X
void n2_free(m, ib, ie, jb, je, n)
char **m;
int ib, ie, jb, je, n;
X{
X	int i;
X	index_test(ib, ie);
X	index_test(jb, je);
X	for(i = ie; i >= ib; i--)
X		xx_free((char*) (m[i] + jb * n), 
X			(unsigned) ((je - jb + 1) * n));
X	xx_free((char*) (m + ib), (unsigned) ((ie - ib + 1) * sizeof(char *)));
X	return;
X}
X
void n2_init(m, ib, ie, jb, je, n, nini)
char **m;
int ib, ie, jb, je, n;
void (*nini)();
X{
X	int i, j;
X	index_test(ib, ie);
X	index_test(jb, je);
X	if (nini == (void (*)()) NULL)
X		return;
X	for (i = ib; i <= ie; i++)
X		for (j = jb; j <= je; j++)
X			(*nini)(&m[i][j*n]);
X	return;
X}
X
void n2_prnt(fp, nprn, m, ib, ie, jb, je, n)
XFILE *fp;
void (*nprn)();
char **m;
int ib, ie, jb, je, n;
X{
X	int i, j;
X	index_test(ib, ie);
X	index_test(jb, je);
X	if (nprn == (void (*)()) NULL)
X		return;
X	for (i = ib; i <= ie; i++)
X		for (j = jb; j <= je; j++)
X			(*nprn)(fp, &m[i][j*n]);
X	return;
X}
X
char ***n3_alloc(ib, ie, jb, je, kb, ke, n)
int ib, ie, jb, je, kb, ke, n;
X{
X	int i, j;
X	char ***m;
X	index_test(ib, ie);
X	index_test(jb, je);
X	index_test(kb, ke);
X	m = (char ***) xx_alloc((unsigned) (ie - ib + 1) * sizeof(char **));
X	if (m == (char ***) NULL) return((char ***) NULL);
X	m -= ib;
X	for(i = ib; i <= ie; i++)
X	{
X		m[i] = (char **) xx_alloc((unsigned) (je - jb + 1) * 
X			sizeof(char *));
X		if (m[i] == (char **) NULL) return((char ***) NULL);
X		m[i] -= jb;
X		for(j = jb; j <= je; j++)
X		{
X			m[i][j] = (char *) xx_alloc((unsigned) (ke - kb + 1)
X				* n);
X			if (m[i][j] == (char *) NULL) return((char ***) NULL);
X			m[i][j] -= kb * n;
X		}
X	}
X	return((char ***) m);
X}
X
char ***n3_renum(m, ib, ie, jb, je, kb, ke, nib, nie, njb, nje, nkb, nke, n)
char ***m;
int ib, ie, jb, je, kb, ke, nib, nie, njb, nje, nkb, nke, n;
X{
X	int i, j;
X	index_test(ib, ie);
X	index_test(jb, je);
X	index_test(kb, ke);
X	index_test(nib, nie);
X	index_test(njb, nje);
X	index_test(nkb, nke);
X	for(i = ie; i >= ib; i--)
X		for (j = je; j >= jb; j--)
X			m[i][j] += (kb - nkb) * n;
X	for(i = ie; i >= ib; i--)
X		m[i] += (jb - njb);
X	m += (ib - nib);
X	return((char ***) m);
X}
X
void n3_free(m, ib, ie, jb, je, kb, ke, n)
char ***m;
int ib, ie, jb, je, kb, ke, n;
X{
X	int i, j;
X	index_test(ib, ie);
X	index_test(jb, je);
X	index_test(kb, ke);
X	for(i = ie; i >= ib; i--)
X		for (j = je; j >= jb; j--)
X			xx_free((char*) (m[i][j] + kb * n),
X				(unsigned) (ke - kb + 1) * n);
X	for(i = ie; i >= ib; i--)
X		xx_free((char*) (m[i] + jb), 
X			(unsigned) ((je - jb + 1) * sizeof(char *)));
X	xx_free((char*) (m + ib),
X		(unsigned) ((ie - ib + 1) * sizeof(char **)));
X	return;
X}
X
void n3_init(m, ib, ie, jb, je, kb, ke, n, nini)
char ***m;
int ib, ie, jb, je, kb, ke, n;
void (*nini)();
X{
X	int i, j, k;
X	index_test(ib, ie);
X	index_test(jb, je);
X	index_test(kb, ke);
X	if (nini == (void (*)()) NULL)
X		return;
X	for (i = ib; i <= ie; i++)
X		for (j = jb; j <= je; j++)
X			for (k = kb; k <= ke; k++)
X				(*nini)(&m[i][j][k*n]);
X	return;
X}
X
void n3_prnt(fp, nprn, m, ib, ie, jb, je, kb, ke, n)
XFILE *fp;
void (*nprn)();
char ***m;
int ib, ie, jb, je, kb, ke, n;
X{
X	int i, j, k;
X	index_test(ib, ie);
X	index_test(jb, je);
X	index_test(kb, ke);
X	if (nprn == (void (*)()) NULL)
X		return;
X	for (i = ib; i <= ie; i++)
X	{
X		fprintf(fp, "%d\n", i);
X		for (j = jb; j <= je; j++)
X			for (k = kb; k <= ke; k++)
X				(*nprn)(fp, &m[i][j][k*n]);
X	}
X	return;
X}
X
X
END_OF_FILE
if test 6395 -ne `wc -c <'nx.c'`; then
    echo shar: \"'nx.c'\" unpacked with wrong size!
fi
# end of 'nx.c'
fi
if test -f 'nx.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nx.h'\"
else
echo shar: Extracting \"'nx.h'\" \(1057 characters\)
sed "s/^X//" >'nx.h' <<'END_OF_FILE'
X/*xxalloc.h**************************************************************/     
X/*									*/
X/*				xxalloc 				*/
X/*									*/
X/*			Placed in the public domain			*/
X/*			 by Harold G. Walters 1988			*/
X/*									*/
X/*	Bug fixes, ect to walters@ce.okstate.edu until May 1989		*/
X/*									*/
X/*	This software is provided as is.  No claims are made for	*/
X/*	this software regarding its fitness and/or correctness for	*/
X/* 	any purpose.  Use of this software is at the user's own risk.	*/
X/*									*/
X/************************************************************************/
X
extern void xx_error();
extern char *xx_alloc();
extern void xx_free();
extern long xx_amount();
X
X/* size n */
extern char *n1_alloc();
extern char *n1_renum();
extern void n1_free();
extern void n1_init();
extern void n1_prnt();
extern char **n2_alloc();
extern char **n2_renum();
extern void n2_free();
extern void n2_init();
extern void n2_prnt();
extern char ***n3_alloc();
extern char ***n3_renum();
extern void n3_free();
extern void n3_init();
extern void n3_prnt();
X
END_OF_FILE
if test 1057 -ne `wc -c <'nx.h'`; then
    echo shar: \"'nx.h'\" unpacked with wrong size!
fi
# end of 'nx.h'
fi
if test -f 'nxtest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nxtest.c'\"
else
echo shar: Extracting \"'nxtest.c'\" \(3276 characters\)
sed "s/^X//" >'nxtest.c' <<'END_OF_FILE'
X/*xxtest.c***************************************************************/     
X/*									*/
X/*				xxalloc 				*/
X/*									*/
X/*			Placed in the public domain			*/
X/*			 by Harold G. Walters 1988			*/
X/*									*/
X/*	Bug fixes, ect to walters@ce.okstate.edu until May 1989		*/
X/*									*/
X/*	This software is provided as is.  No claims are made for	*/
X/*	this software regarding its fitness and/or correctness for	*/
X/* 	any purpose.  Use of this software is at the user's own risk.	*/
X/*									*/
X/************************************************************************/
X
X#include <stdio.h>
X#include "xxalloc.h"
X
X#define STRLEN 132
static char msg[STRLEN];
X
X/* 3*(NE+NO) <= 126 for char */
X
X/* begin */
X#define NB -2
X/* end */
X#define NE 2
X/* offset */
X#define NO 9
X
typedef struct
X{
X	int l;
X	char junk;
X} STU;
X
main()
X{
X	int i, j, k;	
X	if (3*(NE+NO) > 126)
X	{
X		sprintf(msg, "3*(NE+NO) == %d but must be <= 126", 3*(NE+NO));
X		xx_error(msg);
X	}
X	{
X		STU *n1, **n2, ***n3;
X
X		printf("checking STU 1 \n");
X		if (xx_amount() != 0L)
X			printf("STU: amount == %ld", xx_amount());
X		n1 = (STU *) n1_alloc(NB, NE, sizeof(STU));
X 		for (i = NB; i <= NE; i++)
X 			n1[i].l = i;
X 		for (i = NB; i <= NE; i++)
X 			if (n1[i].l != i)
X			printf("STU: after allocate n1[%d].l = %d != %d\n",
X				i, n1[i].l, i);
X		n1 = (STU *) n1_renum(n1, NB, NE, NB+NO, NE+NO, sizeof(STU));
X 		for (i = NB+NO; i <= NE+NO; i++)
X			if (n1[i].l != i-NO)
X			printf("STU: after renum n1[%d].l = %d != %d\n",
X				i, n1[i].l, i-NO);
X		n1_free(n1, NB+NO, NE+NO, sizeof(STU));
X		
X
X		printf("checking STU 2 \n");
X		if (xx_amount() != 0L)
X			printf("STU: amount == %ld", xx_amount());
X		n2 = (STU **) n2_alloc(NB, NE, NB, NE, sizeof(STU));
X 		for (i = NB; i <= NE; i++)
X	 		for (j = NB; j <= NE; j++)
X	 			n2[i][j].l = i + j;
X 		for (i = NB; i <= NE; i++)
X	 		for (j = NB; j <= NE; j++)
X	 			if (n2[i][j].l != i+j)
X			printf("STU: after allocate n2[%d][%d].l = %d != %d\n",
X					i, j, n2[i][j].l, i+j);
X		n2 = (STU **) n2_renum(n2, NB, NE, NB, NE,
X			NB+NO, NE+NO, NB+NO, NE+NO, sizeof(STU));
X 		for (i = NB+NO; i <= NE+NO; i++)
X	 		for (j = NB+NO; j <= NE+NO; j++)
X	 			if (n2[i][j].l != i+j-NO-NO)
X			printf("STU: after renum n2[%d][%d].l = %d != %d\n",
X					i, j, n2[i][j].l, i+j-NO-NO);
X		n2_free(n2, NB+NO, NE+NO, NB+NO, NE+NO, sizeof(STU));
X
X		printf("checking STU 3 \n");
X		if (xx_amount() != 0L)
X			printf("STU: amount == %ld", xx_amount());
X		n3 = (STU ***) n3_alloc(NB, NE, NB, NE, NB, NE, sizeof(STU));
X 		for (i = NB; i <= NE; i++)
X	 		for (j = NB; j <= NE; j++)
X	 			for (k = NB; k <= NE; k++)
X		 			n3[i][j][k].l = i + j + k;
X 		for (i = NB; i <= NE; i++)
X	 		for (j = NB; j <= NE; j++)
X	 			for (k = NB; k <= NE; k++)
X		 			if (n3[i][j][k].l != i+j+k)
X		printf("STU: after allocate n3[%d][%d][%d].l = %d != %d\n",
X						i, j, k, n3[i][j][k].l, i+j+k);
X		n3 = (STU ***) n3_renum(n3, NB, NE, NB, NE, NB, NE, 
X			NB+NO, NE+NO, NB+NO, NE+NO, NB+NO, NE+NO, sizeof(STU));
X 		for (i = NB+NO; i <= NE+NO; i++)
X	 		for (j = NB+NO; j <= NE+NO; j++)
X		 		for (k = NB+NO; k <= NE+NO; k++)
X		 			if (n3[i][j][k].l != i+j+k-3*NO)
X		printf("STU: after renum n3[%d][%d][%d].l = %d != %d\n",
X					i, j, k, n3[i][j][k].l, i+j+k-3*NO);
X		n3_free(n3, NB+NO, NE+NO, NB+NO, NE+NO, NB+NO, NE+NO,
X			sizeof(STU));
X	}
END_OF_FILE
if test 3276 -ne `wc -c <'nxtest.c'`; then
    echo shar: \"'nxtest.c'\" unpacked with wrong size!
fi
# end of 'nxtest.c'
fi
if test -f 'proto.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'proto.h'\"
else
echo shar: Extracting \"'proto.h'\" \(7999 characters\)
sed "s/^X//" >'proto.h' <<'END_OF_FILE'
X/* proto.h */
static  void index_test(int b,int e);
extern  void xx_error(char *s);
extern  char *xx_alloc(unsigned int n);
extern  void xx_free(char *p,unsigned int n);
extern  long xx_amount(void );
extern  char *n1_alloc(int ib,int ie,int n);
extern  char *n1_renum(char *m,int ib,int ie,int nib,int nie,
X	int n);
extern  void n1_free(char *m,int ib,int ie,int n);
extern  void n1_init(char *m,int ib,int ie,int n,void (*nini)());
extern  void n1_prnt(FILE *fp,void (*nprn)(),char *m,int ib,int ie,
X	int n);
extern  char **n2_alloc(int ib,int ie,int jb,int je,int n);
extern  char **n2_renum(char **m,int ib,int ie,int jb,int je,
X	int nib,int nie,int njb,int nje,int n);
extern  void n2_free(char **m,int ib,int ie,int jb,int je,int n);
extern  void n2_init(char **m,int ib,int ie,int jb,int je,int n,
X	void (*nini)());
extern  void n2_prnt(FILE *fp,void (*nprn)(),char **m,int ib,
X	int ie,int jb,int je,int n);
extern  char ***n3_alloc(int ib,int ie,int jb,int je,int kb,int ke,
X	int n);
extern  char ***n3_renum(char ***m,int ib,int ie,int jb,int je,
X	int kb,int ke,int nib,int nie,int njb,int nje,int nkb,
X	int nke,int n);
extern  void n3_free(char ***m,int ib,int ie,int jb,int je,int kb,
X	int ke,int n);
extern  void n3_init(char ***m,int ib,int ie,int jb,int je,int kb,
X	int ke,int n,void (*nini)());
extern  void n3_prnt(FILE *fp,void (*nprn)(),char ***m,int ib,
X	int ie,int jb,int je,int kb,int ke,int n);
extern  char *c1_alloc(int ib,int ie);
extern  char *c1_renum(char *m,int ib,int ie,int nib,int nie);
extern  void c1_free(char *m,int ib,int ie);
extern  void c1_init(char *m,int ib,int ie,char ini);
extern  void c1_prnt(FILE *fp,char *fmt,char *m,int ib,int ie);
extern  char **c2_alloc(int ib,int ie,int jb,int je);
extern  char **c2_renum(char **m,int ib,int ie,int jb,int je,
X	int nib,int nie,int njb,int nje);
extern  void c2_free(char **m,int ib,int ie,int jb,int je);
extern  void c2_init(char **m,int ib,int ie,int jb,int je,char ini);
extern  void c2_prnt(FILE *fp,char *fmt,char **m,int ib,int ie,
X	int jb,int je);
extern  char ***c3_alloc(int ib,int ie,int jb,int je,int kb,int ke);
extern  char ***c3_renum(char ***m,int ib,int ie,int jb,int je,
X	int kb,int ke,int nib,int nie,int njb,int nje,int nkb,
X	int nke);
extern  void c3_free(char ***m,int ib,int ie,int jb,int je,int kb,
X	int ke);
extern  void c3_init(char ***m,int ib,int ie,int jb,int je,int kb,
X	int ke,char ini);
extern  void c3_prnt(FILE *fp,char *fmt,char ***m,int ib,int ie,
X	int jb,int je,int kb,int ke);
extern  short *s1_alloc(int ib,int ie);
extern  short *s1_renum(short *m,int ib,int ie,int nib,int nie);
extern  void s1_free(short *m,int ib,int ie);
extern  void s1_init(short *m,int ib,int ie,short ini);
extern  void s1_prnt(FILE *fp,char *fmt,short *m,int ib,int ie);
extern  short **s2_alloc(int ib,int ie,int jb,int je);
extern  short **s2_renum(short **m,int ib,int ie,int jb,int je,
X	int nib,int nie,int njb,int nje);
extern  void s2_free(short **m,int ib,int ie,int jb,int je);
extern  void s2_init(short **m,int ib,int ie,int jb,int je,short ini);
extern  void s2_prnt(FILE *fp,char *fmt,short **m,int ib,int ie,
X	int jb,int je);
extern  short ***s3_alloc(int ib,int ie,int jb,int je,int kb,
X	int ke);
extern  short ***s3_renum(short ***m,int ib,int ie,int jb,int je,
X	int kb,int ke,int nib,int nie,int njb,int nje,int nkb,
X	int nke);
extern  void s3_free(short ***m,int ib,int ie,int jb,int je,int kb,
X	int ke);
extern  void s3_init(short ***m,int ib,int ie,int jb,int je,int kb,
X	int ke,short ini);
extern  void s3_prnt(FILE *fp,char *fmt,short ***m,int ib,int ie,
X	int jb,int je,int kb,int ke);
extern  long *l1_alloc(int ib,int ie);
extern  long *l1_renum(long *m,int ib,int ie,int nib,int nie);
extern  void l1_free(long *m,int ib,int ie);
extern  void l1_init(long *m,int ib,int ie,long ini);
extern  void l1_prnt(FILE *fp,char *fmt,long *m,int ib,int ie);
extern  long **l2_alloc(int ib,int ie,int jb,int je);
extern  long **l2_renum(long **m,int ib,int ie,int jb,int je,
X	int nib,int nie,int njb,int nje);
extern  void l2_free(long **m,int ib,int ie,int jb,int je);
extern  void l2_init(long **m,int ib,int ie,int jb,int je,long ini);
extern  void l2_prnt(FILE *fp,char *fmt,long **m,int ib,int ie,
X	int jb,int je);
extern  long ***l3_alloc(int ib,int ie,int jb,int je,int kb,int ke);
extern  long ***l3_renum(long ***m,int ib,int ie,int jb,int je,
X	int kb,int ke,int nib,int nie,int njb,int nje,int nkb,
X	int nke);
extern  void l3_free(long ***m,int ib,int ie,int jb,int je,int kb,
X	int ke);
extern  void l3_init(long ***m,int ib,int ie,int jb,int je,int kb,
X	int ke,long ini);
extern  void l3_prnt(FILE *fp,char *fmt,long ***m,int ib,int ie,
X	int jb,int je,int kb,int ke);
extern  int *i1_alloc(int ib,int ie);
extern  int *i1_renum(int *m,int ib,int ie,int nib,int nie);
extern  void i1_free(int *m,int ib,int ie);
extern  void i1_init(int *m,int ib,int ie,int ini);
extern  void i1_prnt(FILE *fp,char *fmt,int *m,int ib,int ie);
extern  int **i2_alloc(int ib,int ie,int jb,int je);
extern  int **i2_renum(int **m,int ib,int ie,int jb,int je,int nib,
X	int nie,int njb,int nje);
extern  void i2_free(int **m,int ib,int ie,int jb,int je);
extern  void i2_init(int **m,int ib,int ie,int jb,int je,int ini);
extern  void i2_prnt(FILE *fp,char *fmt,int **m,int ib,int ie,
X	int jb,int je);
extern  int ***i3_alloc(int ib,int ie,int jb,int je,int kb,int ke);
extern  int ***i3_renum(int ***m,int ib,int ie,int jb,int je,
X	int kb,int ke,int nib,int nie,int njb,int nje,int nkb,
X	int nke);
extern  void i3_free(int ***m,int ib,int ie,int jb,int je,int kb,
X	int ke);
extern  void i3_init(int ***m,int ib,int ie,int jb,int je,int kb,
X	int ke,int ini);
extern  void i3_prnt(FILE *fp,char *fmt,int ***m,int ib,int ie,
X	int jb,int je,int kb,int ke);
extern  float *f1_alloc(int ib,int ie);
extern  float *f1_renum(float *m,int ib,int ie,int nib,int nie);
extern  void f1_free(float *m,int ib,int ie);
extern  void f1_init(float *m,int ib,int ie,double ini);
extern  void f1_prnt(FILE *fp,char *fmt,float *m,int ib,int ie);
extern  float **f2_alloc(int ib,int ie,int jb,int je);
extern  float **f2_renum(float **m,int ib,int ie,int jb,int je,
X	int nib,int nie,int njb,int nje);
extern  void f2_free(float **m,int ib,int ie,int jb,int je);
extern  void f2_init(float **m,int ib,int ie,int jb,int je,double ini);
extern  void f2_prnt(FILE *fp,char *fmt,float **m,int ib,int ie,
X	int jb,int je);
extern  float ***f3_alloc(int ib,int ie,int jb,int je,int kb,
X	int ke);
extern  float ***f3_renum(float ***m,int ib,int ie,int jb,int je,
X	int kb,int ke,int nib,int nie,int njb,int nje,int nkb,
X	int nke);
extern  void f3_free(float ***m,int ib,int ie,int jb,int je,int kb,
X	int ke);
extern  void f3_init(float ***m,int ib,int ie,int jb,int je,int kb,
X	int ke,double ini);
extern  void f3_prnt(FILE *fp,char *fmt,float ***m,int ib,int ie,
X	int jb,int je,int kb,int ke);
extern  double *d1_alloc(int ib,int ie);
extern  double *d1_renum(double *m,int ib,int ie,int nib,int nie);
extern  void d1_free(double *m,int ib,int ie);
extern  void d1_init(double *m,int ib,int ie,double ini);
extern  void d1_prnt(FILE *fp,char *fmt,double *m,int ib,int ie);
extern  double **d2_alloc(int ib,int ie,int jb,int je);
extern  double **d2_renum(double **m,int ib,int ie,int jb,int je,
X	int nib,int nie,int njb,int nje);
extern  void d2_free(double **m,int ib,int ie,int jb,int je);
extern  void d2_init(double **m,int ib,int ie,int jb,int je,double ini);
extern  void d2_prnt(FILE *fp,char *fmt,double **m,int ib,int ie,
X	int jb,int je);
extern  double ***d3_alloc(int ib,int ie,int jb,int je,int kb,
X	int ke);
extern  double ***d3_renum(double ***m,int ib,int ie,int jb,int je,
X	int kb,int ke,int nib,int nie,int njb,int nje,int nkb,
X	int nke);
extern  void d3_free(double ***m,int ib,int ie,int jb,int je,
X	int kb,int ke);
extern  void d3_init(double ***m,int ib,int ie,int jb,int je,
X	int kb,int ke,double ini);
extern  void d3_prnt(FILE *fp,char *fmt,double ***m,int ib,int ie,
X	int jb,int je,int kb,int ke);
END_OF_FILE
if test 7999 -ne `wc -c <'proto.h'`; then
    echo shar: \"'proto.h'\" unpacked with wrong size!
fi
# end of 'proto.h'
fi
if test -f 'tx.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tx.c'\"
else
echo shar: Extracting \"'tx.c'\" \(4732 characters\)
sed "s/^X//" >'tx.c' <<'END_OF_FILE'
X/* type allocation */
X
type *t1_alloc(ib, ie)
int ib, ie;
X{
X	type *m;
X	index_test(ib, ie);
X	m = (type *) xx_alloc((unsigned) (ie - ib + 1) * sizeof(type));
X	if (m == (type *) NULL) return((type *) NULL);
X	m -= ib;
X	return((type *) m);
X}
X
type *t1_renum(m, ib, ie, nib, nie)
type *m;
int ib, ie, nib, nie;
X{
X	index_test(ib, ie);
X	index_test(nib, nie);
X	m += (ib - nib);
X	return((type *) m);
X}
X
void t1_free(m, ib, ie)
type *m;
int ib, ie;
X{
X	index_test(ib, ie);
X	xx_free((char*) (m + ib), (unsigned) ((ie - ib + 1) * sizeof(type)));
X	return;
X}
X
void t1_init(m, ib, ie, ini)
type *m;
int ib, ie;
type ini;
X{
X	int i;
X	index_test(ib, ie);
X	for (i = ib; i <= ie; i++)
X		m[i] = ini;
X	return;
X}
X
void t1_prnt(fp, fmt, m, ib, ie)
XFILE *fp;
char *fmt;
type *m;
int ib, ie;
X{
X	int i;
X	index_test(ib, ie);
X	for (i = ib; i <= ie; i++)
X		fprintf(fp, fmt, m[i]);
X	fprintf(fp, "\n");
X	return;
X}
X	
type **t2_alloc(ib, ie, jb, je)
int ib, ie, jb, je;
X{
X	int i;
X	type **m;
X	index_test(ib, ie);
X	index_test(jb, je);
X	m = (type **) xx_alloc((unsigned) (ie - ib + 1) *
X		sizeof(type *));
X	if (m == (type **) NULL) return((type **) NULL);
X	m -= ib;
X	for(i = ib; i <= ie; i++)
X	{
X		m[i] = (type *) xx_alloc((unsigned) (je - jb + 1) *
X			sizeof(type));
X		if (m[i] == (type *) NULL) return((type **) NULL);
X		m[i] -= jb;
X	}
X	return((type **) m);
X}
X
type **t2_renum(m, ib, ie, jb, je, nib, nie, njb, nje)
type **m;
int ib, ie, jb, je, nib, nie, njb, nje;
X{
X	int i;
X	index_test(ib, ie);
X	index_test(jb, je);
X	index_test(nib, nie);
X	index_test(njb, nje);
X	for(i = ie; i >= ib; i--)
X		m[i] += (jb - njb);
X	m += (ib - nib);
X	return((type **) m);
X}
X
void t2_free(m, ib, ie, jb, je)
type **m;
int ib, ie, jb, je;
X{
X	int i;
X	index_test(ib, ie);
X	index_test(jb, je);
X	for(i = ie; i >= ib; i--)
X		xx_free((char*) (m[i] + jb), 
X			(unsigned) ((je - jb + 1) * sizeof(type)));
X	xx_free((char*) (m + ib), (unsigned) ((ie - ib + 1) * sizeof(type *)));
X	return;
X}
X
void t2_init(m, ib, ie, jb, je, ini)
type **m;
int ib, ie, jb, je;
type ini;
X{
X	int i, j;
X	index_test(ib, ie);
X	index_test(jb, je);
X	for (i = ib; i <= ie; i++)
X		for (j = jb; j <= je; j++)
X			m[i][j] = ini;
X	return;
X}
X
void t2_prnt(fp, fmt, m, ib, ie, jb, je)
XFILE *fp;
char *fmt;
type **m;
int ib, ie, jb, je;
X{
X	int i, j;
X	index_test(ib, ie);
X	index_test(jb, je);
X	for (i = ib; i <= ie; i++)
X	{
X		for (j = jb; j <= je; j++)
X			fprintf(fp, fmt, m[i][j]);
X		fprintf(fp, "\n");
X	}
X	return;
X}
X
type ***t3_alloc(ib, ie, jb, je, kb, ke)
int ib, ie, jb, je, kb, ke;
X{
X	int i, j;
X	type ***m;
X	index_test(ib, ie);
X	index_test(jb, je);
X	index_test(kb, ke);
X	m = (type ***) xx_alloc((unsigned) (ie - ib + 1) * 
X		sizeof(type **));
X	if (m == (type ***) NULL) return((type ***) NULL);
X	m -= ib;
X	for(i = ib; i <= ie; i++)
X	{
X		m[i] = (type **) xx_alloc((unsigned) (je - jb + 1) * 
X			sizeof(type *));
X		if (m[i] == (type **) NULL) return((type ***) NULL);
X		m[i] -= jb;
X		for(j = jb; j <= je; j++)
X		{
X			m[i][j] = (type *) xx_alloc((unsigned) (ke - kb + 1) *
X				sizeof(type));
X			if (m[i][j] == (type *) NULL) return((type ***) NULL);
X			m[i][j] -= kb;
X		}
X	}
X	return((type ***) m);
X}
X
type ***t3_renum(m, ib, ie, jb, je, kb, ke, nib, nie, njb, nje, nkb, nke)
type ***m;
int ib, ie, jb, je, kb, ke, nib, nie, njb, nje, nkb, nke;
X{
X	int i, j;
X	index_test(ib, ie);
X	index_test(jb, je);
X	index_test(kb, ke);
X	index_test(nib, nie);
X	index_test(njb, nje);
X	index_test(nkb, nke);
X	for(i = ie; i >= ib; i--)
X		for (j = je; j >= jb; j--)
X			m[i][j] += (kb - nkb);
X	for(i = ie; i >= ib; i--)
X		m[i] += (jb - njb);
X	m += (ib - nib);
X	return((type ***) m);
X}
X
void t3_free(m, ib, ie, jb, je, kb, ke)
type ***m;
int ib, ie, jb, je, kb, ke;
X{
X	int i, j;
X	index_test(ib, ie);
X	index_test(jb, je);
X	index_test(kb, ke);
X	for(i = ie; i >= ib; i--)
X		for (j = je; j >= jb; j--)
X			xx_free((char*) (m[i][j] + kb),
X				(unsigned) ((ke - kb + 1) * sizeof(type)));
X	for(i = ie; i >= ib; i--)
X		xx_free((char*) (m[i] + jb), 
X			(unsigned) ((je - jb + 1) * sizeof(type *)));
X	xx_free((char*) (m + ib),
X		(unsigned) ((ie - ib + 1) * sizeof(type **)));
X	return;
X}
X
void t3_init(m, ib, ie, jb, je, kb, ke, ini)
type ***m;
int ib, ie, jb, je, kb, ke;
type ini;
X{
X	int i, j, k;
X	index_test(ib, ie);
X	index_test(jb, je);
X	index_test(kb, ke);
X	for (i = ib; i <= ie; i++)
X		for (j = jb; j <= je; j++)
X			for (k = kb; k <= ke; k++)
X				m[i][j][k] = ini;
X	return;
X}
X
void t3_prnt(fp, fmt, m, ib, ie, jb, je, kb, ke)
XFILE *fp;
char *fmt;
type ***m;
int ib, ie, jb, je, kb, ke;
X{
X	int i, j, k;
X	index_test(ib, ie);
X	index_test(jb, je);
X	index_test(kb, ke);
X	for (i = ib; i <= ie; i++)
X	{
X		fprintf(fp, "%d\n", i);
X		for (j = jb; j <= je; j++)
X		{
X			for (k = kb; k <= ke; k++)
X				fprintf(fp, fmt, m[i][j][k]);
X			fprintf(fp, "\n");
X		}
X	}
X	return;
X}
X
X
END_OF_FILE
if test 4732 -ne `wc -c <'tx.c'`; then
    echo shar: \"'tx.c'\" unpacked with wrong size!
fi
# end of 'tx.c'
fi
if test -f 'tx.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tx.h'\"
else
echo shar: Extracting \"'tx.h'\" \(375 characters\)
sed "s/^X//" >'tx.h' <<'END_OF_FILE'
X/* type */
extern type *t1_alloc();
extern type *t1_renum();
extern void t1_free();
extern void t1_init();
extern void t1_prnt();
extern type **t2_alloc();
extern type **t2_renum();
extern void t2_free();
extern void t2_init();
extern void t2_prnt();
extern type ***t3_alloc();
extern type ***t3_renum();
extern void t3_free();
extern void t3_init();
extern void t3_prnt();
X
END_OF_FILE
if test 375 -ne `wc -c <'tx.h'`; then
    echo shar: \"'tx.h'\" unpacked with wrong size!
fi
# end of 'tx.h'
fi
if test -f 'txtest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'txtest.c'\"
else
echo shar: Extracting \"'txtest.c'\" \(2199 characters\)
sed "s/^X//" >'txtest.c' <<'END_OF_FILE'
X	{
X		type *t1, **t2, ***t3;
X	
X		printf("checking type 1 \n");
X		if (xx_amount() != 0L)
X			printf("type: amount == %ld", xx_amount());
X		t1 = t1_alloc(NB, NE);
X 		for (i = NB; i <= NE; i++)
X 			t1[i] = (type) i;
X 		for (i = NB; i <= NE; i++)
X 			if (t1[i] != (type) i)
X			printf("type: after allocate t1[%d] = %t != %d\n",
X				i, t1[i], i);
X		t1 = t1_renum(t1, NB, NE, NB+NO, NE+NO);
X 		for (i = NB+NO; i <= NE+NO; i++)
X			if (t1[i] != (type) (i-NO))
X			printf("type: after renum t1[%d] = %t != %d\n",
X				i, t1[i], i-NO);
X		t1_free(t1, NB+NO, NE+NO);
X		
X
X		printf("checking type 2 \n");
X		if (xx_amount() != 0L)
X			printf("type: amount == %ld", xx_amount());
X		t2 = t2_alloc(NB, NE, NB, NE);
X 		for (i = NB; i <= NE; i++)
X	 		for (j = NB; j <= NE; j++)
X	 			t2[i][j] = (type) (i + j);
X 		for (i = NB; i <= NE; i++)
X	 		for (j = NB; j <= NE; j++)
X	 			if (t2[i][j] != (type) (i+j))
X			printf("type: after allocate t2[%d][%d] = %t != %d\n",
X					i, j, t2[i][j], i+j);
X		t2 = t2_renum(t2, NB, NE, NB, NE, NB+NO, NE+NO, NB+NO, NE+NO);
X 		for (i = NB+NO; i <= NE+NO; i++)
X	 		for (j = NB+NO; j <= NE+NO; j++)
X	 			if (t2[i][j] != (type) (i+j-NO-NO))
X			printf("type: after allocate t2[%d][%d] = %t != %d\n",
X					i, j, t2[i][j], i+j-NO-NO);
X		t2_free(t2, NB+NO, NE+NO, NB+NO, NE+NO);
X
X		printf("checking type 3 \n");
X		if (xx_amount() != 0L)
X			printf("type: amount == %ld", xx_amount());
X		t3 = t3_alloc(NB, NE, NB, NE, NB, NE);
X 		for (i = NB; i <= NE; i++)
X	 		for (j = NB; j <= NE; j++)
X	 			for (k = NB; k <= NE; k++)
X		 			t3[i][j][k] = (type) (i + j + k);
X 		for (i = NB; i <= NE; i++)
X	 		for (j = NB; j <= NE; j++)
X	 			for (k = NB; k <= NE; k++)
X		 			if (t3[i][j][k] != (type) (i+j+k))
X		printf("type: after allocate t3[%d][%d][%d] = %t != %d\n",
X						i, j, k, t3[i][j][k], i+j+k);
X		t3 = t3_renum(t3, NB, NE, NB, NE, NB, NE, 
X			NB+NO, NE+NO, NB+NO, NE+NO, NB+NO, NE+NO);
X 		for (i = NB+NO; i <= NE+NO; i++)
X	 		for (j = NB+NO; j <= NE+NO; j++)
X		 		for (k = NB+NO; k <= NE+NO; k++)
X		 			if (t3[i][j][k] != (type) (i+j+k-3*NO))
X		printf("type: after allocate t3[%d][%d][%d] = %t != %d\n",
X					i, j, k, t3[i][j][k], i+j+k-3*NO);
X		t3_free(t3, NB+NO, NE+NO, NB+NO, NE+NO, NB+NO, NE+NO);
X	}
X
END_OF_FILE
if test 2199 -ne `wc -c <'txtest.c'`; then
    echo shar: \"'txtest.c'\" unpacked with wrong size!
fi
# end of 'txtest.c'
fi
if test -f 'xx.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xx.sh'\"
else
echo shar: Extracting \"'xx.sh'\" \(85 characters\)
sed "s/^X//" >'xx.sh' <<'END_OF_FILE'
X:
sed -e s/type/$1/g -e s/t1/$2"1"/g -e s/t2/$2"2"/g -e s/t3/$2"3"/g $3 >> $4
exit 0
END_OF_FILE
if test 85 -ne `wc -c <'xx.sh'`; then
    echo shar: \"'xx.sh'\" unpacked with wrong size!
fi
chmod +x 'xx.sh'
# end of 'xx.sh'
fi
if test -f 'xxalloc.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xxalloc.man'\"
else
echo shar: Extracting \"'xxalloc.man'\" \(8963 characters\)
sed "s/^X//" >'xxalloc.man' <<'END_OF_FILE'
X.TH XXALLOC 3 local
X.SH NAME
xxalloc \- family of routines for multi\-dimensional dynamic array allocation,
initialization, printing, renumbering, and freeing
X.SH SYNOPSIS
X.sp
X.B #include <xxalloc.h>
X.br
X.B cc
X[flags] files
X.B -lxxalloc [-lxxerror]
X[libraries]
X.sp
X.B
Base Routines
X.sp
void xx_error(s)
char *s;
X.br
char *xx_alloc(n)
unsigned n;
X.br
void xx_free(p, n)
char *p;
unsigned n;
X.br
long xx_amount()
X.sp
X.B
Prefixes and Arguments
X.sp
X{type} \- char \- short \- long \- int \- float \- double
X.br
X{*} \- * \- ** \- *** for 1 \- 2 \- 3 dimensions
X.br
X{t} \- c \- s \- l \- i \- f \- d
X.br
X{d} \- 1 \- 2 \- 3
X.br
X{args} \- ib,ie \- ib,ie,jb,je \- ib,ie,jb,je,kb,ke
X.br
X.sp
X.B
XFunctions for Simple Types
X.sp
X{type} {*}{t}{d}_alloc({args})
X.br
int {args};
X.sp
void {t}{d}_init(m, {args}, ini)
X.br
X{type} {*}m;
X.br
int {args};
X.br
X{type} ini;
X.sp
void {t}{d}_prnt(fp, fmt, m, {args})
X.br
XFILE *fp;
X.br
char *fmt;
X.br
X{type} {*}m;
X.br
int {args};
X.sp
X{type} {*}{t}{d}_renum(m, {args}, {args})
X.br
X{type} {*}m;
X.br
int {args}, {args};
X.sp
void {t}{d}_free(m, {args})
X.br
X{type} {*}m;
X.br
int {args};
X.sp
X.bp
X.B
XFunctions for Structures
X.sp
char {*}n{d}_alloc({args}, n)
X.br
int {args}, n;
X.sp
void n{d}_init(m, {args}, n, nini)
X.br
char {*}m;
X.br
int {args}, n;
X.br
void (*nini)();
X.sp
void n{d}_prnt(fp, nprn, m, {args}, n)
X.br
XFILE *fp;
X.br
void (*nprn)();
X.br
char {*}m;
X.br
int {args}, n;
X.sp
char {*}n{d}_renum(m, {args}, {args}, n)
X.br
char {*}m;
X.br
int {args}, {args}, n;
X.sp
void n{d}_free(m, {args}, n)
X.br
char {*}m;
X.br
int {args}, n;
X.sp
X.SH DESCRIPTION
X.PP 
xxalloc is a family of routines for dynamic array manipulation in one,
two and three dimensions.  Routines are included for allocation,
initialization, printing, renumbering, and freeing both arrays of
structures and arrays of simple types.  Since the "edge-vector" approach
is used for two and three dimensional arrays, this set of routines
allows for the development of reusable subroutine libraries without
regard to some "maximum" dimension.  Both positive and negative indices
are allowed.  In this document "array of" is often used where "pointer
to" would be more correct. 
X.PP
X.B
Base Routines
X.IP "xx_error"
The required error handling routine. The default routine exits
when called, but it may be replaced by a user's routine of the same name.
The default routine may be linked in by
X.IP
X.B cc
X[flags] files
X.B \-lxxalloc \-lxxerror
X[libraries]
X.sp
The default routine is simply
X.sp
X#include <stdio.h>
X.br
void xx_error(s)
X.br
char *s;
X.br
X{
X.br
X	fprintf(stderr, s);
X.br
X	exit(2);
X.br
X	return;
X.br
X}
X.IP "xx_alloc"
Allocates memory and checks for error return.  Similar to malloc().
Returns a NULL pointer if there is no available memory or another error occurs.
X.IP "xx_free"
XFree memory allocated with xx_alloc(). Similar to free() but take an extra
argument for the amount of memory.
X.IP "xx_amount"
Returns the amount of memory currently allocated with this package.
X.PP
X.B
The suffix on the function name indicates its function.
X.B
The five function types are
X.IP "_alloc"
Allocate memory.  Returns an appropriate NULL pointer if there is no
available memory or another error occurs. 
X.IP "_init"
Initialize.
X.IP "_prnt"
Print.
X.IP "_renum"
Renumber the array indices.
X.IP "_free"
XFree the allocated memory.
X.PP
X.B
The prefix on the function name indicates its type. They are
X.PP
X.IP "{type}"
The data type the function manipulates.
X.IP
char \- array of structure
X.br
char \- array of char
X.br
short \- array of short
X.br
long \- array of long
X.br
int \- array of int
X.br
float \- array of float
X.br
double \- array of double
X.PP
X.IP "{*}"
Number of dimensions
X.IP
X* \- 1 dimension \- pointer to 
X.br
X** \- 2 dimensions \- pointer to pointer to
X.br
X*** \- 3 dimensions \- pointer to pointer to pointer to
X.PP
X.IP "{t}"
The type that the function manipulates.
X.IP
n \- array of structure
X.br
c \- array of char
X.br
s \- array of short
X.br
l \- array of long
X.br
i \- array of int
X.br
f \- array of float
X.br
d \- array of double
X.PP
X.IP "{d}"
The dimension of the array to be manipulated. 
X.IP
X1 \- one dimension
X.br
X2 \- two dimensions
X.br
X3 \- three dimensions
X.PP
X.B
Arguments common to both functions that operate on simple types and structures.
X.PP
X.IP "{args}"
Integer arguments specifying the beginning and ending indices of each
dimension of the array.  For example the length of an array with
ib = \-2 and ie = 5 would be ((5 \- (-2)) + 1).
X.IP 
ib, ie \- row indices
X.br
ib, ie, jb, je \- row and column indices
X.br
ib, ie, jb, je, kb, ke \- row, column, and third dimension indices
X.PP
X.IP "fp"
XFILE pointer for the printing functions' output.
X.PP
X.B
Arguments to functions that operate on simple types.
X.PP
X.IP "ini"
Value to initialize the array to.  Must be of {type}.
X.PP
X.IP "fmt"
Character string to be passed as an argument to fprintf.  It should
contain the conversion specification for a single argument of {type}. 
X.PP
X.B
Arguments to functions that operate on structures.
X.PP
X.IP "n"
sizeof the structure.
X.PP
X.IP "nini"
Pointer to a function used to initialize the structure.  The function
receives a pointer to the structure as the only argument as shown.
X.sp
void initialize_some_structure(some_struct)
X.br
struct *some_struct;
X.PP
X.IP "nprn"
Pointer to a function used to print the structure.  The function
receives a FILE pointer and a pointer to the structure as arguments as shown.
An example is
given in the examples section.
X.sp
void print_some_structure(fp, some_struct)
X.br
XFILE *fp;
X.br
struct *some_struct;
X.SH EXAMPLES
X.sp
X.B
XExample1 \- Operations on a two dimensional array of doubles
X.sp
X/* example1.c */
X.sp
X#include <stdio.h>
X.br
X#include <xxalloc.h>
X.sp
void mtxtsp(a, ib, ie, jb, je, b)
X.br
double **a, **b;
X.br
int ib, ie, jb, je;
X.br
X{
X.br
X	int i, j;
X.br
X	double tmp;
X.br
X	
X.br
X	for (i = ib; i <= ie; i++)
X.br
X 		for (j = i; j <= je; j++)
X.br
X		{
X.br
X			tmp = a[i][j];
X.br
X			b[i][j] = a[j][i];
X.br
X			b[j][i] = tmp;
X.br
X		}
X.br
X	return;
X.br
X}
X.sp
main()
X.br
X{
X.br
X	double **a;
X.br
X	int i, j;
X.br
X	
X.br
X/* allocate a two dimensional array of doubles */
X.sp
X	a = d2_alloc(0, 9, 0, 9);
X.sp
X/* initialize the array to 1.0 and print */
X.sp
X	d2_init(a, 0, 9, 0, 9, 1.0);
X.br
X	printf("\\ninitialized to 1\\n");
X.br
X	d2_prnt(stdout, "%5.0f ", a, 0, 9, 0, 9);
X.sp
X/* set the array equal to the 2*i + j and print */
X.sp
X	for (i = 0; i < 10; i++)
X.br
X		for (j = 0; j < 10; j++)
X.br
X			a[i][j] = (double) (2*i + j);
X.br
X	printf("\\n2*i + j\\n");
X.br
X	d2_prnt(stdout, "%5.0f ", a, 0, 9, 0, 9);
X.sp
X/* take the transpose and print*/
X.sp
X	mtxtsp(a, 0, 9, 0, 9, a);
X.br
X	printf("\\ntransposed\\n");
X.br
X	d2_prnt(stdout, "%5.0f ", a, 0, 9, 0, 9);
X.sp
X/* renumber the indices a la FORTRAN and print */
X.br
X/* the new indices must be used from now on */
X.sp
X	a = d2_renum(a, 0, 9, 0, 9, 1, 10, 1, 10);
X.br
X	printf("\\nrenumbered\\n");
X.br
X	d2_prnt(stdout, "%5.0f ", a, 1, 10, 1, 10);
X.sp
X/* renumber the indices a la C and print */
X.br
X/* the new indices must be used from now on */
X.sp
X	a = d2_renum(a, 1, 10, 1, 10, 0, 9, 0, 9);
X.br
X	printf("\\nrenumbered again\\n");
X.br
X	d2_prnt(stdout, "%5.0f ", a, 0, 9, 0, 9);
X.sp
X/* free the allocated memory */
X.sp
X	d2_free(a, 0, 9, 0, 9);
X.br
X	exit(0);
X.br
X}		
X.sp
X.B
XExample 2 \- Operations on an array of structures
X.sp
X/* example2.c */
X.sp
X#include <stdio.h>
X.br
X#include <xxalloc.h>
X.sp
typedef struct
X.br
X{
X.br
X	double dnum;
X.br
X	int inum;
X.br
X} NUM;
X.sp
X/* structure initialization function */
X.br
X/* passed as an argument to {d}n_init() */
X.br
void num_init(num)
X.br
NUM *num;
X.br
X{
X.br
X	num->dnum = 1.0;
X.br
X	num->inum = 1;
X.br
X	return;
X.br
X}
X.sp
X/* structure printing function */
X.br
X/* passed as an argument to {d}n_prnt() */
X.br
void num_prnt(fp, num)
X.br
XFILE *fp;
X.br
NUM *num;
X.br
X{
X.br
X	fprintf(fp, "%5.1f %3d ", num->dnum, num->inum);
X.br
X	return;
X.br
X}
X.sp
main()
X.br
X{
X.br
X	int i;
X.br
X	NUM *num;
X.br
X	
X.br
X/* allocate a one dimensional array of NUM */
X.sp
X	num = (NUM *) n1_alloc(0, 4, sizeof(NUM));
X.sp
X/* initialize the array to 1.0 and print */
X.sp
X	n1_init(num, 0, 4, sizeof(NUM), num_init);
X.br
X	printf("\\ninitialized to 1\\n");
X.br
X	n1_prnt(stdout, num_prnt, num, 0, 4, sizeof(NUM));
X.sp
X/* set the array equal to the i and print */
X.sp
X	for (i = 0; i <= 4; i++)
X.br
X	{
X.br
X		num[i].dnum = (double) i;
X.br
X		num[i].inum = i;
X.br
X	}
X.br
X	printf("\\nset to i\\n");
X.br
X	n1_prnt(stdout, num_prnt, num, 0, 4, sizeof(NUM));
X.sp
X/* renumber the indices a la FORTRAN and print */
X.br
X/* the new indices must be used from now on */
X.sp
X	num = (NUM *) n1_renum(num, 0, 4, 1, 5, sizeof(NUM));
X.br
X	printf("\\nindices renumbered\\n");
X.br
X	n1_prnt(stdout, num_prnt, num, 1, 5, sizeof(NUM));
X.br
X	printf("\\n");
X.sp
X/* free the allocated memory */
X.sp
X	n1_free(num, 1, 5, sizeof(NUM));
X.br
X	exit(0);
X.br
X}
X.SH FILES
X.PP
X/lib/xxalloc.a
X.br
X/lib/xxerror.a
X.SH BUGS
X.PP
There is only minimal error checking and no error checking at all
between function calls.
X.SH AUTHOR
X.PP
Harold G. Walters
X
END_OF_FILE
if test 8963 -ne `wc -c <'xxalloc.man'`; then
    echo shar: \"'xxalloc.man'\" unpacked with wrong size!
fi
# end of 'xxalloc.man'
fi
if test -f 'xxerror.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xxerror.c'\"
else
echo shar: Extracting \"'xxerror.c'\" \(107 characters\)
sed "s/^X//" >'xxerror.c' <<'END_OF_FILE'
X/* xxerror.c */
X#include <stdio.h>
void xx_error(s)
char *s;
X{
X	fprintf(stderr, s);
X	exit(2);
X	return;
X}
X
X
END_OF_FILE
if test 107 -ne `wc -c <'xxerror.c'`; then
    echo shar: \"'xxerror.c'\" unpacked with wrong size!
fi
# end of 'xxerror.c'
fi
if test -f 'xxh.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xxh.sh'\"
else
echo shar: Extracting \"'xxh.sh'\" \(85 characters\)
sed "s/^X//" >'xxh.sh' <<'END_OF_FILE'
X:
sed -e s/type/$1/g -e s/t1/$2"1"/g -e s/t2/$2"2"/g -e s/t3/$2"3"/g $3 >> $4
exit 0
END_OF_FILE
if test 85 -ne `wc -c <'xxh.sh'`; then
    echo shar: \"'xxh.sh'\" unpacked with wrong size!
fi
chmod +x 'xxh.sh'
# end of 'xxh.sh'
fi
if test -f 'xxtest.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xxtest.sh'\"
else
echo shar: Extracting \"'xxtest.sh'\" \(101 characters\)
sed "s/^X//" >'xxtest.sh' <<'END_OF_FILE'
X:
sed -e s/type/$1/g -e s/t1/$2"1"/g -e s/t2/$2"2"/g -e s/t3/$2"3"/g -e s/\%t/\%$3/g $4 >> $5
exit 0
END_OF_FILE
if test 101 -ne `wc -c <'xxtest.sh'`; then
    echo shar: \"'xxtest.sh'\" unpacked with wrong size!
fi
chmod +x 'xxtest.sh'
# end of 'xxtest.sh'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0


