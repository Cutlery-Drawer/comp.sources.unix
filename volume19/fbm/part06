Subject:  v19i052:  FBM, image manipulation library, Part06/08
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Michael.Mauldin@NL.CS.CMU.EDU
Posting-number: Volume 19, Issue 52
Archive-name: fbm/part06

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 8)."
# Contents:  Makefile flgifc.c flpcx.c fltga.c
# Wrapped by rsalz@fig.bbn.com on Fri Jun  9 08:38:28 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(13166 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X################################################################
X# Copyright (C) 1989 by Michael Mauldin.  Permission is granted to
X# use this file in whole or in part provided that you do not sell it
X# for profit and that this copyright notice is retained unchanged.
X#
X#	Makefile for FBM pixmap manipulation routines
X#
X# HISTORY
X# 20-May-89  Michael Mauldin (mlm) at Carnegie Mellon University
X#	Beta relase (version 0.94) (Amiga HAM mode, bug fixes)
X#
X# 03-May-89  Michael Mauldin (mlm) at Carnegie Mellon University
X#	Beta relase (version 0.93) (bug fixes)
X#
X# 30-Apr-89  Michael Mauldin (mlm) at Carnegie Mellon University
X#	Beta relase (version 0.92) (color PS files, bug fixes)
X#
X# 06-Apr-89  Michael Mauldin (mlm) at Carnegie Mellon University
X#	Added qrt2fbm, tga2fbm, fbm2tga, pic2fbm to Makefile
X#	User contributed software.
X#
X# 16-Feb-89  Michael Mauldin (mlm) at Carnegie Mellon University
X#	Alpha release (version 0.8)
X#
X# 18-Nov-88  Gary W. Sherwin (sherwin) at Westinghouse R&D
X#       added bedge and bclean libraries and instructions.
X#
X# 12-Nov-88  Michael Mauldin (mlm) at Carnegie-Mellon University
X#	Created this makefile, broke libfbm into separate files
X#	for compilation.
X#
X# Notes: "make all" will compile all of the programs.  "make install"
X#	 will compile all programs and place the executables in the
X#	 BIN directory and the manual entries in the MAN directory.
X#
X#	 For most people, linking the executables to the bin directory
X#	 is fine.  But if your local software is on a different filesystem,
X#	 you should change the value of the INSTALL variable to either
X#	 "cp" or "mv".
X#
X#	 On some systems that keep software in /usr/local, the
X#	 required extension on manual entries is "l" (ell).  For
X#	 these systems, change the MANEXT variable.
X#
X################################################################
X
XINSTALL= ln
XBIN= /usr/mlm/bin/
XMAN= /usr/mlm/man/
XFTP= /usr/mlm/ftp/
XMANEXT= 1
XDBG= -g
XLIB= -L. -lfbm
XVER= 094
XVERSTR= "FBM Library 0.94, Beta release"
X
XEXES= clr2gray fbcat fbclean fbedge fbext fbhalf fbhist fbinfo \
X      fbm2pod fbmask fbnorm fbps fbquant fbrot fbsample fbsharp \
X      gray2clr idiff pbm2ps pbmtitle raw2fbm qrt2fbm pic2fbm tga2fbm \
X      fbm2tga unmap udiff fbham
X
XBINS= $(BIN)clr2gray $(BIN)fbcat $(BIN)fbclean $(BIN)fbedge \
X      $(BIN)fbext $(BIN)fbhalf $(BIN)fbhist $(BIN)fbinfo \
X      $(BIN)fbm2pod $(BIN)fbmask $(BIN)fbnorm $(BIN)fbps \
X      $(BIN)fbquant $(BIN)fbrot $(BIN)fbsample $(BIN)fbsharp \
X      $(BIN)gray2clr $(BIN)idiff $(BIN)pbm2ps $(BIN)pbmtitle \
X      $(BIN)raw2fbm $(BIN)qrt2fbm $(BIN)pic2fbm $(BIN)tga2fbm \
X      $(BIN)fbm2tga $(BIN)unmap $(BIN)udiff $(BIN)fbham
X
XLIBO= flalfb.o flblue.o flbyte.o flcavg.o flclr.o fledge.o flextr.o flface.o \
X      flflyd.o flgifc.o flgife.o flgifr.o flgifw.o fliff.o flklnr.o flpbm.o \
X      flpcx.o flrdfb.o flread.o flrot.o flshrp.o flsun.o flthre.o flwrfb.o \
X      flpic.o fltga.o
X
XSRCS= fbext.c fbrot.c fbhist.c fbinfo.c fbmask.c fbnorm.c fbps.c fbsharp.c \
X      fbedge.c fbclean.c clr2gray.c fbcat.c fbhalf.c fbm2pod.c fbquant.c \
X      gray2clr.c idiff.c fbsample.c pbm2ps.c pbmtitle.c raw2fbm.c \
X      fbm2tga.c tga2fbm.c pic2fbm.c qrt2fbm.c fbham.c \
X      flalfb.c flblue.c flcavg.c flclr.c flextr.c flface.c flrot.c flflyd.c \
X      flpbm.c flrdfb.c flread.c flshrp.c flsun.c flthre.c flwrfb.c flgifr.c \
X      flgifw.c flgifc.c flgife.c flpcx.c fliff.c fledge.c flklnr.c flbyte.c \
X      flpic.c fltga.c
X
XDOCS= clr2gray.1 fbcat.1 fbclean.1 fbedge.1 fbext.1 fbhalf.1 fbhist.1 \
X      fbinfo.1 fbm.1 fbm2pod.1 fbmask.1 fbnorm.1 fbps.1 fbquant.1 fbrot.1 \
X      fbsample.1 fbsharp.1 gray2clr.1 idiff.1 pbm2ps.1 pbmtitle.1 raw2fbm.1 \
X      qrt2fbm.1 fbham.1
X
XMANS= $(MAN)clr2gray.$(MANEXT) $(MAN)fbcat.$(MANEXT) $(MAN)fbclean.$(MANEXT) \
X      $(MAN)fbedge.$(MANEXT) $(MAN)fbext.$(MANEXT) $(MAN)fbhalf.$(MANEXT) \
X      $(MAN)fbhist.$(MANEXT) $(MAN)fbinfo.$(MANEXT) $(MAN)fbm2pod.$(MANEXT) \
X      $(MAN)fbmask.$(MANEXT) $(MAN)fbnorm.$(MANEXT) $(MAN)fbps.$(MANEXT) \
X      $(MAN)fbquant.$(MANEXT) $(MAN)fbrot.$(MANEXT) $(MAN)fbsample.$(MANEXT) \
X      $(MAN)fbsharp.$(MANEXT) $(MAN)gray2clr.$(MANEXT) $(MAN)idiff.$(MANEXT) \
X      $(MAN)pbm2ps.$(MANEXT) $(MAN)pbmtitle.$(MANEXT) $(MAN)raw2fbm.$(MANEXT) \
X      $(MAN)qrt2fbm.$(MANEXT) $(MAN)fbm.$(MANEXT) $(MAN)fbham.$(MANEXT)
X
XMISC= README Features README.lib Makefile
X
XHDRS= fbm.h
X
Xall: $(EXES)
X
Xinstall: $(BINS) $(MANS)
X
Xuninstall: clean
X	rm -f $(EXES)
X
X# Subroutine library
X
Xlibfbm.a: $(LIBO)
X	rm -f $@
X	ar clq $@ $(LIBO)
X	ranlib $@
X
X# Library routines
Xflalfb.o: flalfb.c fbm.h
X	$(CC) $(DBG) -c flalfb.c
Xflblue.o: flblue.c fbm.h
X	$(CC) $(DBG) -c flblue.c
Xflbyte.o: flbyte.c fbm.h
X	$(CC) $(DBG) -c flbyte.c
Xflcavg.o: flcavg.c fbm.h
X	$(CC) $(DBG) -c flcavg.c
Xflclr.o: flclr.c fbm.h
X	$(CC) $(DBG) -c flclr.c
Xfledge.o: fledge.c fbm.h
X	$(CC) $(DBG) -c fledge.c
Xflextr.o: flextr.c fbm.h
X	$(CC) $(DBG) -c flextr.c
Xflface.o: flface.c fbm.h
X	$(CC) $(DBG) -c flface.c
Xflflyd.o: flflyd.c fbm.h
X	$(CC) $(DBG) -c flflyd.c
Xflgifc.o: flgifc.c fbm.h
X	$(CC) $(DBG) -c flgifc.c
Xflgife.o: flgife.c fbm.h
X	$(CC) $(DBG) -c flgife.c
Xflgifr.o: flgifr.c fbm.h
X	$(CC) $(DBG) -c flgifr.c
Xflgifw.o: flgifw.c fbm.h
X	$(CC) $(DBG) -c flgifw.c
Xfliff.o: fliff.c fbm.h
X	$(CC) $(DBG) -c fliff.c
Xflklnr.o: flklnr.c fbm.h
X	$(CC) $(DBG) -c flklnr.c
Xflpbm.o: flpbm.c fbm.h
X	$(CC) $(DBG) -c flpbm.c
Xflpcx.o: flpcx.c fbm.h
X	$(CC) $(DBG) -c flpcx.c
Xflpic.o: flpic.c fbm.h
X	$(CC) $(DBG) -c flpic.c
Xflrdfb.o: flrdfb.c fbm.h
X	$(CC) $(DBG) -c flrdfb.c
Xflread.o: flread.c fbm.h
X	$(CC) $(DBG) -c flread.c
Xflrot.o: flrot.c fbm.h
X	$(CC) $(DBG) -c flrot.c
Xflshrp.o: flshrp.c fbm.h
X	$(CC) $(DBG) -c flshrp.c
Xflsun.o: flsun.c fbm.h
X	$(CC) $(DBG) -c flsun.c
Xfltga.o: fltga.c fbm.h
X	$(CC) $(DBG) -c fltga.c
Xflthre.o: flthre.c fbm.h
X	$(CC) $(DBG) -c flthre.c
Xflwrfb.o: flwrfb.c fbm.h
X	$(CC) $(DBG) -c flwrfb.c
X
X# Programs
X
Xclr2gray: clr2gray.c fbm.h libfbm.a
X	$(CC) $(DBG) -o clr2gray clr2gray.c $(LIB) -lm
Xfbcat: fbcat.c fbm.h libfbm.a
X	$(CC) $(DBG) -o fbcat fbcat.c $(LIB) -lm
Xfbclean: fbclean.c fbm.h libfbm.a
X	$(CC) $(DBG) -o fbclean fbclean.c $(LIB) -lm
Xfbedge: fbedge.c fbm.h libfbm.a
X	$(CC) $(DBG) -o fbedge fbedge.c $(LIB) -lm
Xfbext: fbext.c fbm.h libfbm.a
X	$(CC) $(DBG) -o fbext fbext.c $(LIB) -lm
Xfbhalf: fbhalf.c fbm.h libfbm.a
X	$(CC) $(DBG) -o fbhalf fbhalf.c $(LIB) -lm
Xfbhist: fbhist.c fbm.h libfbm.a
X	$(CC) $(DBG) -o fbhist fbhist.c $(LIB) -lm
Xfbinfo: fbinfo.c fbm.h libfbm.a
X	$(CC) $(DBG) -o fbinfo fbinfo.c $(LIB) -lm
Xfbm2tga: fbm2tga.c fbm.h libfbm.a
X	$(CC) $(DBG) -o fbm2tga fbm2tga.c $(LIB) -lm
Xtga2fbm: tga2fbm.c fbm.h libfbm.a
X	$(CC) $(DBG) -o tga2fbm tga2fbm.c $(LIB) -lm
Xpic2fbm: pic2fbm.c fbm.h libfbm.a
X	$(CC) $(DBG) -o pic2fbm pic2fbm.c $(LIB) -lm
Xqrt2fbm: qrt2fbm.c fbm.h libfbm.a
X	$(CC) $(DBG) -o qrt2fbm qrt2fbm.c $(LIB) -lm
Xfbm2pod: fbm2pod.c fbm.h libfbm.a
X	$(CC) $(DBG) -o fbm2pod fbm2pod.c $(LIB) -lm
Xfbm2sun: fbm2sun.c fbm.h libfbm.a
X	$(CC) $(DBG) -o fbm2sun fbm2sun.c $(LIB) -lm
Xfbmask: fbmask.c fbm.h libfbm.a
X	$(CC) $(DBG) -o fbmask fbmask.c $(LIB) -lm
Xfbnorm: fbnorm.c fbm.h libfbm.a
X	$(CC) $(DBG) -o fbnorm fbnorm.c $(LIB) -lm
Xfbps: fbps.c fbm.h libfbm.a
X	$(CC) $(DBG) -o fbps fbps.c $(LIB) -lm
Xfbquant: fbquant.c fbm.h libfbm.a
X	$(CC) $(DBG) -o fbquant fbquant.c $(LIB) -lm
Xfbrot: fbrot.c fbm.h libfbm.a
X	$(CC) $(DBG) -o fbrot fbrot.c $(LIB) -lm
Xfbsample: fbsample.c fbm.h libfbm.a
X	$(CC) $(DBG) -o fbsample fbsample.c $(LIB) -lm
Xfbsharp: fbsharp.c fbm.h libfbm.a
X	$(CC) $(DBG) -o fbsharp fbsharp.c $(LIB) -lm
Xgray2clr: gray2clr.c fbm.h libfbm.a
X	$(CC) $(DBG) -o gray2clr gray2clr.c $(LIB) -lm
Xunmap: gray2clr
X	rm -rf unmap
X	ln gray2clr unmap
Xidiff: idiff.c
X	$(CC) $(DBG) -o idiff idiff.c -lm
Xudiff: idiff
X	rm -rf udiff
X	ln idiff udiff
Xpbm2face: pbm2face.c fbm.h libfbm.a
X	$(CC) $(DBG) -o pbm2face pbm2face.c $(LIB) -lm
Xpbm2ps: pbm2ps.c
X	$(CC) $(DBG) -o pbm2ps pbm2ps.c -lm
Xpbmtitle: pbmtitle.c
X	$(CC) $(DBG) -o pbmtitle pbmtitle.c -lm
Xraw2fbm: raw2fbm.c fbm.h libfbm.a
X	$(CC) $(DBG) -o raw2fbm raw2fbm.c $(LIB) -lm
X
X$(BIN)fbext: fbext
X	rm -f $(BIN)fbext
X	$(INSTALL) fbext $(BIN)fbext
X$(BIN)fbrot: fbrot
X	rm -f $(BIN)fbrot
X	$(INSTALL) fbrot $(BIN)fbrot
X$(BIN)fbhist: fbhist
X	rm -f $(BIN)fbhist
X	$(INSTALL) fbhist $(BIN)fbhist
X$(BIN)fbinfo: fbinfo
X	rm -f $(BIN)fbinfo
X	$(INSTALL) fbinfo $(BIN)fbinfo
X$(BIN)fbmask: fbmask
X	rm -f $(BIN)fbmask
X	$(INSTALL) fbmask $(BIN)fbmask
X$(BIN)fbnorm: fbnorm
X	rm -f $(BIN)fbnorm
X	$(INSTALL) fbnorm $(BIN)fbnorm
X$(BIN)fbps: fbps
X	rm -f $(BIN)fbps
X	$(INSTALL) fbps $(BIN)fbps
X$(BIN)fbsharp: fbsharp
X	rm -f $(BIN)fbsharp
X	$(INSTALL) fbsharp $(BIN)fbsharp
X$(BIN)fbedge: fbedge
X	rm -f $(BIN)fbedge
X	$(INSTALL) fbedge $(BIN)fbedge
X$(BIN)fbclean: fbclean
X	rm -f $(BIN)fbclean
X	$(INSTALL) fbclean $(BIN)fbclean
X$(BIN)clr2gray: clr2gray
X	rm -f $(BIN)clr2gray
X	$(INSTALL) clr2gray $(BIN)clr2gray
X$(BIN)fbcat: fbcat
X	rm -f $(BIN)fbcat
X	$(INSTALL) fbcat $(BIN)fbcat
X$(BIN)fbhalf: fbhalf
X	rm -f $(BIN)fbhalf
X	$(INSTALL) fbhalf $(BIN)fbhalf
X$(BIN)fbm2pod: fbm2pod
X	rm -f $(BIN)fbm2pod
X	$(INSTALL) fbm2pod $(BIN)fbm2pod
X$(BIN)fbm2sun: fbm2sun
X	rm -f $(BIN)fbm2sun
X	$(INSTALL) fbm2sun $(BIN)fbm2sun
X$(BIN)fbquant: fbquant
X	rm -f $(BIN)fbquant
X	$(INSTALL) fbquant $(BIN)fbquant
X$(BIN)gray2clr: gray2clr
X	rm -f $(BIN)gray2clr
X	$(INSTALL) gray2clr $(BIN)gray2clr
X$(BIN)unmap: $(BIN)gray2clr
X	rm -f $(BIN)unmap
X	ln $(BIN)gray2clr $(BIN)unmap
X$(BIN)idiff: idiff
X	rm -f $(BIN)idiff
X	$(INSTALL) idiff $(BIN)idiff
X$(BIN)udiff: $(BIN)idiff
X	rm -f $(BIN)udiff
X	ln $(BIN)idiff $(BIN)udiff
X$(BIN)fbsample: fbsample
X	rm -f $(BIN)fbsample
X	$(INSTALL) fbsample $(BIN)fbsample
X$(BIN)qrt2fbm: qrt2fbm
X	rm -f $(BIN)qrt2fbm
X	$(INSTALL) qrt2fbm $(BIN)qrt2fbm
X$(BIN)fbm2tga: fbm2tga
X	rm -f $(BIN)fbm2tga
X	$(INSTALL) fbm2tga $(BIN)fbm2tga
X$(BIN)pic2fbm: pic2fbm
X	rm -f $(BIN)pic2fbm
X	$(INSTALL) pic2fbm $(BIN)pic2fbm
X$(BIN)tga2fbm: tga2fbm
X	rm -f $(BIN)tga2fbm
X	$(INSTALL) tga2fbm $(BIN)tga2fbm
X$(BIN)pbm2ps: pbm2ps
X	rm -f $(BIN)pbm2ps
X	$(INSTALL) pbm2ps $(BIN)pbm2ps
X$(BIN)pbmtitle: pbmtitle
X	rm -f $(BIN)pbmtitle
X	$(INSTALL) pbmtitle $(BIN)pbmtitle
X$(BIN)raw2fbm: raw2fbm
X	rm -f $(BIN)raw2fbm
X	$(INSTALL) raw2fbm $(BIN)raw2fbm
X
X# Manual Entries
X
X$(MAN)clr2gray.$(MANEXT): clr2gray.1
X	rm -f $(MAN)clr2gray.$(MANEXT)
X	$(INSTALL) clr2gray.1 $(MAN)clr2gray.$(MANEXT)
X$(MAN)fbcat.$(MANEXT): fbcat.1
X	rm -f $(MAN)fbcat.$(MANEXT)
X	$(INSTALL) fbcat.1 $(MAN)fbcat.$(MANEXT)
X$(MAN)fbclean.$(MANEXT): fbclean.1
X	rm -f $(MAN)fbclean.$(MANEXT)
X	$(INSTALL) fbclean.1 $(MAN)fbclean.$(MANEXT)
X$(MAN)fbedge.$(MANEXT): fbedge.1
X	rm -f $(MAN)fbedge.$(MANEXT)
X	$(INSTALL) fbedge.1 $(MAN)fbedge.$(MANEXT)
X$(MAN)fbext.$(MANEXT): fbext.1
X	rm -f $(MAN)fbext.$(MANEXT)
X	$(INSTALL) fbext.1 $(MAN)fbext.$(MANEXT)
X$(MAN)fbhalf.$(MANEXT): fbhalf.1
X	rm -f $(MAN)fbhalf.$(MANEXT)
X	$(INSTALL) fbhalf.1 $(MAN)fbhalf.$(MANEXT)
X$(MAN)fbhist.$(MANEXT): fbhist.1
X	rm -f $(MAN)fbhist.$(MANEXT)
X	$(INSTALL) fbhist.1 $(MAN)fbhist.$(MANEXT)
X$(MAN)fbinfo.$(MANEXT): fbinfo.1
X	rm -f $(MAN)fbinfo.$(MANEXT)
X	$(INSTALL) fbinfo.1 $(MAN)fbinfo.$(MANEXT)
X$(MAN)fbm2pod.$(MANEXT): fbm2pod.1
X	rm -f $(MAN)fbm2pod.$(MANEXT)
X	$(INSTALL) fbm2pod.1 $(MAN)fbm2pod.$(MANEXT)
X$(MAN)fbmask.$(MANEXT): fbmask.1
X	rm -f $(MAN)fbmask.$(MANEXT)
X	$(INSTALL) fbmask.1 $(MAN)fbmask.$(MANEXT)
X$(MAN)fbnorm.$(MANEXT): fbnorm.1
X	rm -f $(MAN)fbnorm.$(MANEXT)
X	$(INSTALL) fbnorm.1 $(MAN)fbnorm.$(MANEXT)
X$(MAN)fbps.$(MANEXT): fbps.1
X	rm -f $(MAN)fbps.$(MANEXT)
X	$(INSTALL) fbps.1 $(MAN)fbps.$(MANEXT)
X$(MAN)fbquant.$(MANEXT): fbquant.1
X	rm -f $(MAN)fbquant.$(MANEXT)
X	$(INSTALL) fbquant.1 $(MAN)fbquant.$(MANEXT)
X$(MAN)fbrot.$(MANEXT): fbrot.1
X	rm -f $(MAN)fbrot.$(MANEXT)
X	$(INSTALL) fbrot.1 $(MAN)fbrot.$(MANEXT)
X$(MAN)fbsample.$(MANEXT): fbsample.1
X	rm -f $(MAN)fbsample.$(MANEXT)
X	$(INSTALL) fbsample.1 $(MAN)fbsample.$(MANEXT)
X$(MAN)fbsharp.$(MANEXT): fbsharp.1
X	rm -f $(MAN)fbsharp.$(MANEXT)
X	$(INSTALL) fbsharp.1 $(MAN)fbsharp.$(MANEXT)
X$(MAN)qrt2fbm.$(MANEXT): qrt2fbm.1
X	rm -f $(MAN)qrt2fbm.$(MANEXT)
X	$(INSTALL) qrt2fbm.1 $(MAN)qrt2fbm.$(MANEXT)
X$(MAN)gray2clr.$(MANEXT): gray2clr.1
X	rm -f $(MAN)gray2clr.$(MANEXT)
X	$(INSTALL) gray2clr.1 $(MAN)gray2clr.$(MANEXT)
X$(MAN)idiff.$(MANEXT): idiff.1
X	rm -f $(MAN)idiff.$(MANEXT)
X	$(INSTALL) idiff.1 $(MAN)idiff.$(MANEXT)
X$(MAN)pbm2ps.$(MANEXT): pbm2ps.1
X	rm -f $(MAN)pbm2ps.$(MANEXT)
X	$(INSTALL) pbm2ps.1 $(MAN)pbm2ps.$(MANEXT)
X$(MAN)pbmtitle.$(MANEXT): pbmtitle.1
X	rm -f $(MAN)pbmtitle.$(MANEXT)
X	$(INSTALL) pbmtitle.1 $(MAN)pbmtitle.$(MANEXT)
X$(MAN)raw2fbm.$(MANEXT): raw2fbm.1
X	rm -f $(MAN)raw2fbm.$(MANEXT)
X	$(INSTALL) raw2fbm.1 $(MAN)raw2fbm.$(MANEXT)
X$(MAN)fbm.$(MANEXT): fbm.1
X	rm -f $(MAN)fbm.$(MANEXT)
X	$(INSTALL) fbm.1 $(MAN)fbm.$(MANEXT)
X
X# Miscellaneous things
X
Xclean:
X	rm -f *.o *.CKP *.BAK libfbm.a core
X
Xfluff: $(SRCS)
X	lint $(SRCS) | grep -v 'main multiply declared' | \
X	grep -v 'inconsistently' | grep -v 'ignored' > fluff
X	
X
Xfbm.tar: $(MISC) $(DOCS) $(HDRS) $(SRCS)
X	tar cvf fbm.tar  $(MISC) $(DOCS) $(HDRS) $(SRCS)
X	rm -f $(FTP)fbm.tar.Z $(FTP)fbm$(VER).tar.Z
X	compress < fbm.tar > $(FTP)fbm$(VER).tar.Z
X	ln $(FTP)fbm$(VER).tar.Z $(FTP)fbm.tar.Z
X
Xdist: fbm.01
Xfbm.01: $(MISC) $(DOCS) $(HDRS) $(SRCS)
X	rm -f fbm.??
X	packmail -ofbm -t$(VERSTR) -s50000 \
X	$(MISC) $(DOCS) $(HDRS) $(SRCS)
END_OF_FILE
if test 13166 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'flgifc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'flgifc.c'\"
else
echo shar: Extracting \"'flgifc.c'\" \(12187 characters\)
sed "s/^X//" >'flgifc.c' <<'END_OF_FILE'
X/*****************************************************************
X * flgifc.c: FBM Library 0.9 (Beta test) 07-Mar-89  Michael Mauldin
X *
X * Portions of this code Copyright (C) 1989 by Michael Mauldin.
X * Permission is granted to use this file in whole or in part provided
X * that you do not sell it for profit and that this copyright notice
X * and the names of all authors are retained unchanged.
X *
X * flgifc.c:
X *
X * CONTENTS
X *	compress( init_bits, outfile, ReadValue )
X *
X * HISTORY
X * 07-Mar-89  Michael Mauldin (mlm) at Carnegie Mellon University
X *	Beta release (version 0.9) mlm@cs.cmu.edu
X *
X * 21-Feb-89  Michael Mauldin (mlm) at Carnegie Mellon University
X *	Removed two unused variables found by Lint.
X *
X * 19-Feb-89  Michael Mauldin (mlm) at Carnegie Mellon University
X *	Adapted to FBM package.
X *
X * 13-Feb-89  David Rowley (mgardi@watdcsu.waterloo.edu)
X *	GIF encoding modifications (sent by mail on 2/13/89)
X *	original name: GIFENCODE.C - GIF Image compression interface
X *
X *	Based on: compress.c - File compression ala IEEE Computer, June 1984.
X *
X *	Spencer W. Thomas       (decvax!harpo!utah-cs!utah-gr!thomas)
X *	Jim McKie               (decvax!mcvax!jim)
X *	Steve Davies            (decvax!vax135!petsd!peora!srd)
X *	Ken Turkowski           (decvax!decwrl!turtlevax!ken)
X *	James A. Woods          (decvax!ihnp4!ames!jaw)
X *	Joe Orost               (decvax!vax135!petsd!joe)
X *
X *****************************************************************/
X
X/*
X * General DEFINEs
X */
X#define min(a,b)        ((a>b) ? b : a)
X
X#define BITS	12
X#define MSDOS	1
X
X#define HSIZE  5003            /* 80% occupancy */
X
X/*
X * Pointer to function returning an int
X */
Xtypedef int (* ifunptr)();
X
X/*
X * a code_int must be able to hold 2**BITS values of type int, and also -1
X */
Xtypedef int             code_int;
X
X#ifdef SIGNED_COMPARE_SLOW
Xtypedef unsigned long int count_int;
Xtypedef unsigned short int count_short;
X#else
Xtypedef long int          count_int;
X#endif
X
X#ifdef NO_UCHAR
X typedef char   char_type;
X#else
X typedef        unsigned char   char_type;
X#endif /* UCHAR */
X
X/*
X *
X * GIF Image compression - modified 'compress'
X *
X * Based on: compress.c - File compression ala IEEE Computer, June 1984.
X *
X * By Authors:  Spencer W. Thomas       (decvax!harpo!utah-cs!utah-gr!thomas)
X *              Jim McKie               (decvax!mcvax!jim)
X *              Steve Davies            (decvax!vax135!petsd!peora!srd)
X *              Ken Turkowski           (decvax!decwrl!turtlevax!ken)
X *              James A. Woods          (decvax!ihnp4!ames!jaw)
X *              Joe Orost               (decvax!vax135!petsd!joe)
X *
X */
X#include <stdio.h>
X#include <ctype.h>
X#include <signal.h>
X
X#define ARGVAL() (*++(*argv) || (--argc && *++argv))
X
Xstatic int n_bits;                        /* number of bits/code */
Xstatic int maxbits = BITS;                /* user settable max # bits/code */
Xstatic code_int maxcode;                  /* maximum code, given n_bits */
Xstatic code_int maxmaxcode = (code_int)1 << BITS; /* should NEVER generate this code */
X#ifdef COMPATIBLE               /* But wrong! */
X# define MAXCODE(n_bits)        ((code_int) 1 << (n_bits) - 1)
X#else
X# define MAXCODE(n_bits)        (((code_int) 1 << (n_bits)) - 1)
X#endif /* COMPATIBLE */
X
Xstatic count_int htab [HSIZE];
Xstatic unsigned short codetab [HSIZE];
X#define HashTabOf(i)       htab[i]
X#define CodeTabOf(i)    codetab[i]
X
Xstatic code_int hsize = HSIZE;                 /* for dynamic table sizing */
X
X/*
X * To save much memory, we overlay the table used by compress() with those
X * used by decompress().  The tab_prefix table is the same size and type
X * as the codetab.  The tab_suffix table needs 2**BITS characters.  We
X * get this from the beginning of htab.  The output stack uses the rest
X * of htab, and contains characters.  There is plenty of room for any
X * possible stack (stack used to be 8000 characters).
X */
X
X#define tab_prefixof(i) CodeTabOf(i)
X#define tab_suffixof(i)        ((char_type *)(htab))[i]
X#define de_stack               ((char_type *)&tab_suffixof((code_int)1<<BITS))
X
Xstatic code_int free_ent = 0;                  /* first unused entry */
X
X/*
X * block compression parameters -- after all codes are used up,
X * and compression rate changes, start over.
X */
Xstatic int clear_flg = 0;
X
Xstatic long int in_count = 1;            /* length of input */
Xstatic long int out_count = 0;           /* # of codes output (for debugging) */
X
X/*
X * compress stdin to stdout
X *
X * Algorithm:  use open addressing double hashing (no chaining) on the 
X * prefix code / next character combination.  We do a variant of Knuth's
X * algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime
X * secondary probe.  Here, the modular division first probe is gives way
X * to a faster exclusive-or manipulation.  Also do block compression with
X * an adaptive reset, whereby the code table is cleared when the compression
X * ratio decreases, but after the table fills.  The variable-length output
X * codes are re-sized at this point, and a special CLEAR code is generated
X * for the decompressor.  Late addition:  construct the table according to
X * file size for noticeable speed improvement on small files.  Please direct
X * questions about this implementation to ames!jaw.
X */
X
Xstatic int g_init_bits;
Xstatic FILE *g_outfile;
X
Xstatic int ClearCode;
Xstatic int EOFCode;
X
X#ifndef lint
Xstatic char *fbmid =
X	"$FBM flgifc.c <0.9> 07-Mar-89  (C) 1989 by Michael Mauldin$";
X#endif
X
Xcompress( init_bits, outfile, ReadValue )
Xint init_bits;
XFILE *outfile;
Xifunptr ReadValue;
X{
X    register long fcode;
X    register code_int i = 0;
X    register int c;
X    register code_int ent;
X    register code_int disp;
X    register code_int hsize_reg;
X    register int hshift;
X
X    /*
X     * Set up the globals:  g_init_bits - initial number of bits
X     *                      g_outfile   - pointer to output file
X     */
X    g_init_bits = init_bits;
X    g_outfile = outfile;
X
X    /*
X     * Set up the necessary values
X     */
X    out_count = 0;
X    clear_flg = 0;
X    in_count = 1;
X    maxcode = MAXCODE(n_bits = g_init_bits);
X
X    ClearCode = (1 << (init_bits - 1));
X    EOFCode = ClearCode + 1;
X    free_ent = ClearCode + 2;
X
X    char_init();
X    
X    ent = GIFNextPixel( ReadValue );
X
X    hshift = 0;
X    for ( fcode = (long) hsize;  fcode < 65536L; fcode *= 2L )
X        hshift++;
X    hshift = 8 - hshift;                /* set hash code range bound */
X
X    hsize_reg = hsize;
X    cl_hash( (count_int) hsize_reg);            /* clear hash table */
X
X    output( (code_int)ClearCode );
X    
X#ifdef SIGNED_COMPARE_SLOW
X    while ( (c = GIFNextPixel( ReadValue )) != (unsigned) EOF ) {
X#else
X    while ( (c = GIFNextPixel( ReadValue )) != EOF ) {
X#endif
X
X        in_count++;
X
X        fcode = (long) (((long) c << maxbits) + ent);
X        i = (((code_int)c << hshift) ^ ent);    /* xor hashing */
X
X        if ( HashTabOf (i) == fcode ) {
X            ent = CodeTabOf (i);
X            continue;
X        } else if ( (long)HashTabOf (i) < 0 )      /* empty slot */
X            goto nomatch;
X        disp = hsize_reg - i;           /* secondary hash (after G. Knott) */
X        if ( i == 0 )
X            disp = 1;
Xprobe:
X        if ( (i -= disp) < 0 )
X            i += hsize_reg;
X
X        if ( HashTabOf (i) == fcode ) {
X            ent = CodeTabOf (i);
X            continue;
X        }
X        if ( (long)HashTabOf (i) > 0 ) 
X            goto probe;
Xnomatch:
X        output ( (code_int) ent );
X        out_count++;
X        ent = c;
X#ifdef SIGNED_COMPARE_SLOW
X        if ( (unsigned) free_ent < (unsigned) maxmaxcode) {
X#else
X        if ( free_ent < maxmaxcode ) {
X#endif
X            CodeTabOf (i) = free_ent++; /* code -> hashtable */
X            HashTabOf (i) = fcode;
X        } else
X		cl_block();
X    }
X    /*
X     * Put out the final code.
X     */
X    output( (code_int)ent );
X    out_count++;
X    output( (code_int) EOFCode );
X
X    return;
X}
X
X/*****************************************************************
X * TAG( output )
X *
X * Output the given code.
X * Inputs:
X *      code:   A n_bits-bit integer.  If == -1, then EOF.  This assumes
X *              that n_bits =< (long)wordsize - 1.
X * Outputs:
X *      Outputs code to the file.
X * Assumptions:
X *      Chars are 8 bits long.
X * Algorithm:
X *      Maintain a BITS character long buffer (so that 8 codes will
X * fit in it exactly).  Use the VAX insv instruction to insert each
X * code in turn.  When the buffer fills up empty it and start over.
X */
X
Xstatic unsigned long cur_accum = 0;
Xstatic int  cur_bits = 0;
X
Xstatic
Xunsigned long masks[] = { 0x0000, 0x0001, 0x0003, 0x0007, 0x000F,
X                                  0x001F, 0x003F, 0x007F, 0x00FF,
X                                  0x01FF, 0x03FF, 0x07FF, 0x0FFF,
X                                  0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF };
X
Xstatic
Xoutput( code )
Xcode_int  code;
X{
X    cur_accum &= masks[ cur_bits ];
X
X    if( cur_bits > 0 )
X    	cur_accum |= ((long)code << cur_bits);
X    else
X        cur_accum = code;
X	
X    cur_bits += n_bits;
X
X    while( cur_bits >= 8 ) {
X    	char_out( (unsigned int)(cur_accum & 0xff) );
X	cur_accum >>= 8;
X	cur_bits -= 8;
X    }
X
X    /*
X     * If the next entry is going to be too big for the code size,
X     * then increase it, if possible.
X     */
X   if ( free_ent > maxcode || clear_flg ) {
X
X            if( clear_flg ) {
X	    
X                maxcode = MAXCODE (n_bits = g_init_bits);
X                clear_flg = 0;
X		
X            } else {
X	    
X                n_bits++;
X                if ( n_bits == maxbits )
X                    maxcode = maxmaxcode;
X                else
X                    maxcode = MAXCODE(n_bits);
X            }
X        }
X	
X    if( code == EOFCode ) {
X        /*
X         * At EOF, write the rest of the buffer.
X         */
X        while( cur_bits > 0 ) {
X    	        char_out( (unsigned int)(cur_accum & 0xff) );
X	        cur_accum >>= 8;
X	        cur_bits -= 8;
X        }
X
X	flush_char();
X	
X        fflush( g_outfile );
X
X	if( ferror( g_outfile ) )
X                writeerr();
X    }
X}
X
X/*
X * Clear out the hash table
X */
Xstatic
Xcl_block ()             /* table clear for block compress */
X{
X
X        cl_hash ( (count_int) hsize );
X        free_ent = ClearCode + 2;
X        clear_flg = 1;
X
X        output( (code_int)ClearCode );
X}
X
Xstatic
Xcl_hash(hsize)          /* reset code table */
Xregister count_int hsize;
X{
X
X        register count_int *htab_p = htab+hsize;
X
X        register long i;
X        register long m1 = -1;
X
X        i = hsize - 16;
X        do {                            /* might use Sys V memset(3) here */
X                *(htab_p-16) = m1;
X                *(htab_p-15) = m1;
X                *(htab_p-14) = m1;
X                *(htab_p-13) = m1;
X                *(htab_p-12) = m1;
X                *(htab_p-11) = m1;
X                *(htab_p-10) = m1;
X                *(htab_p-9) = m1;
X                *(htab_p-8) = m1;
X                *(htab_p-7) = m1;
X                *(htab_p-6) = m1;
X                *(htab_p-5) = m1;
X                *(htab_p-4) = m1;
X                *(htab_p-3) = m1;
X                *(htab_p-2) = m1;
X                *(htab_p-1) = m1;
X                htab_p -= 16;
X        } while ((i -= 16) >= 0);
X
X	for ( i += 16; i > 0; i-- )
X                *--htab_p = m1;
X}
X
Xstatic
Xwriteerr()
X{
X	printf( "error writing output file\n" );
X	exit(1);
X}
X
X/******************************************************************************
X *
X * GIF Specific routines
X *
X ******************************************************************************/
X
X/*
X * Number of characters so far in this 'packet'
X */
Xstatic int a_count;
X
X/*
X * Set up the 'byte output' routine
X */
Xstatic
Xchar_init()
X{
X	a_count = 0;
X}
X
X/*
X * Define the storage for the packet accumulator
X */
Xstatic char accum[ 256 ];
X
X/*
X * Add a character to the end of the current packet, and if it is 254
X * characters, flush the packet to disk.
X */
Xstatic
Xchar_out( c )
Xint c;
X{
X	accum[ a_count++ ] = c;
X	if( a_count >= 254 ) 
X		flush_char();
X}
X
X/*
X * Flush the packet to disk, and reset the accumulator
X */
Xstatic
Xflush_char()
X{
X	if( a_count > 0 ) {
X		fputc( a_count, g_outfile );
X		fwrite( accum, 1, a_count, g_outfile );
X		a_count = 0;
X	}
X}	
X
X/* The End */
X
END_OF_FILE
if test 12187 -ne `wc -c <'flgifc.c'`; then
    echo shar: \"'flgifc.c'\" unpacked with wrong size!
fi
# end of 'flgifc.c'
fi
if test -f 'flpcx.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'flpcx.c'\"
else
echo shar: Extracting \"'flpcx.c'\" \(9151 characters\)
sed "s/^X//" >'flpcx.c' <<'END_OF_FILE'
X/*****************************************************************
X * flpcx.c: FBM Library 0.9 (Beta test) 07-Mar-89  Michael Mauldin
X *
X * Copyright (C) 1989 by Michael Mauldin.  Permission is granted to
X * use this file in whole or in part provided that you do not sell it
X * for profit and that this copyright notice is retained unchanged.
X *
X * flpcx.c: 
X *
X * CONTENTS
X *	write_pcx (image, stream)
X *	read_pcx (image, stream, mstr, mlen)
X *
X * EDITLOG
X *	LastEditDate = Tue Mar  7 19:57:24 1989 - Michael Mauldin
X *	LastFileName = /usr2/mlm/src/misc/fbm/flpcx.c
X *
X * HISTORY
X * 07-Mar-89  Michael Mauldin (mlm) at Carnegie Mellon University
X *	Beta release (version 0.9) mlm@cs.cmu.edu
X *
X * 12-Nov-88  Michael Mauldin (mlm) at Carnegie-Mellon University
X *	Created.
X *****************************************************************/
X
X# include <stdio.h>
X# include <math.h>
X# include <ctype.h>
X# include "fbm.h"
X
X/****************************************************************
X * pcx.h: Paintbrush file format header, as per "ZSoft Technical
X *	Reference Manual for Publisher's Paintbrush, PC Paintbrush Plus,
X *	PC Paintbrush and Frieze Graphics.", 1988,  ZSoft corporation,
X *
X *	450 Franklin Rd. Suite 100 / Marietta, GA  30067 / 404-428-0008
X *
X * HISTORY
X * {1}	 1-Sep-87  Michael L. Mauldin (mlm) at cognac
X * 	Created.
X * 
X ****************************************************************/
X
X# define UBYTE	unsigned char	/*  8 bits unsigned		*/
X# define WORD	short		/* 16 bits signed		*/
X
Xtypedef struct pcxstruct {
X  UBYTE	Manufacturer;		/* 10 == ZSoft PCX		*/
X  UBYTE	Version;		/* Version Information		*/
X				/*	0 == ver 2.5		*/
X				/*	2 == ver 2.8 w/pallete	*/
X				/*	3 == 2.8 w/o pallete	*/
X				/*	5 == ver 3.0 w/pallete	*/
X  UBYTE	Encoding;		/* 01 == PCX run-length encoding */
X  UBYTE	BitsPerPixel;		/* 8/number of pixels per byte	*/
X  WORD	Window[4];		/* xmin, ymin, xmax, ymax	*/
X  WORD	Hres;			/* Horizontal resolution	*/
X  WORD	Vres;			/* Vertical resolution		*/
X  UBYTE	Colormap[16][3];	/* Color Pallete, RGB in 0..255	*/
X  UBYTE	Reserved;		/* Reserved			*/
X  UBYTE NPlanes;		/* Number of Color Planes	*/
X  WORD	BytesPerLine;		/* Number of bytes per scan line */
X  WORD	Palette;		/* 1 = color/BW, 2 = grayscale  */
X  UBYTE	Filler[58];		/* Pad header to 128 bytes	*/
X} PCXHDR;
X
X# define XMIN 0
X# define YMIN 1
X# define XMAX 2
X# define YMAX 3
X
X# define CNTMSK 0xc0
X# define MAXCNT 0x3f
X
X# define swapword(X) ((((X)&0xff) << 8) | (((X) & 0xff00) >> 8))
X
X/****************************************************************
X * write_pcx: Write PC Paintbrush format
X ****************************************************************/
X
X#ifndef lint
Xstatic char *fbmid =
X	"$FBM flpcx.c <0.9> 07-Mar-89  (C) 1989 by Michael Mauldin$";
X#endif
X
Xwrite_pcx (image, stream)
XFBM *image;
XFILE *stream;
X{  
X  fprintf (stderr, "PCX support not yet available\n");
X
X  return (0);
X}
X
X/****************************************************************
X * read_pcx: Read PC Paintbrush format
X ****************************************************************/
X
Xread_pcx (image, rfile, mstr, mlen)
XFBM *image;
XFILE *rfile;
Xchar *mstr;
Xint mlen;
X{ PCXHDR phdr;
X  char *hp;
X  register unsigned char *bmp, *scan;
X  register int k, r, c, bit, byte, mask, width, height, rowlen;
X  int depth, ptype, color, enc, clrlen, totalbytes;
X  unsigned char *buf, *tail;
X
X  /* Read PCX file header */
X  hp = (char *) &phdr;
X
X  if (mlen > 0) strncpy (hp, mstr, mlen);
X
X  if (! fread (hp+mlen, sizeof (phdr) - mlen, 1, rfile))
X  { perror ("read_fbm (header)"); return (0); }
X
X  if (phdr.Manufacturer != PCX_MAGIC)
X  { fprintf (stderr,
X	     "Error, file is not a PCX file, magic %02x is not 0a\n",
X	      phdr.Manufacturer);
X    return (0);
X  }
X  
X  /* PCX uses Little Indian byte order, swap on SUNS, RTs, ... */
X  if (machine_byte_order () == BIG)
X  { phdr.Window[0] =     swapword (phdr.Window[0]);
X    phdr.Window[1] =     swapword (phdr.Window[1]);
X    phdr.Window[2] =     swapword (phdr.Window[2]);
X    phdr.Window[3] =     swapword (phdr.Window[3]);
X    phdr.Hres =          swapword (phdr.Hres);
X    phdr.Vres =          swapword (phdr.Vres);
X    phdr.BytesPerLine =  swapword (phdr.BytesPerLine);
X    phdr.Palette =  swapword (phdr.Palette);
X  }
X  
X# ifdef DEBUG
X  fprintf (stderr, "Manufacturer        %d\n", phdr.Manufacturer);
X  fprintf (stderr, "Version             %d\n", phdr.Version);
X  fprintf (stderr, "Encoding            %d\n", phdr.Encoding);
X  fprintf (stderr, "BitsPerPixel        %d\n", phdr.BitsPerPixel);
X  fprintf (stderr, "Window0             %d\n", phdr.Window[0]);
X  fprintf (stderr, "Window1             %d\n", phdr.Window[1]);
X  fprintf (stderr, "Window2             %d\n", phdr.Window[2]);
X  fprintf (stderr, "Window3             %d\n", phdr.Window[3]);
X  fprintf (stderr, "Hres                %d\n", phdr.Hres);
X  fprintf (stderr, "Vres                %d\n", phdr.Vres);
X  fprintf (stderr, "Reserved            %d\n", phdr.Reserved);
X  fprintf (stderr, "NPlanes             %d\n", phdr.NPlanes);
X  fprintf (stderr, "BytesPerLine        %d\n", phdr.BytesPerLine);
X  fprintf (stderr, "Palette             %d\n", phdr.Palette);
X# endif
X
X  /* Now extract relevant features of PCX file header */
X  width =  phdr.Window[XMAX] - phdr.Window[XMIN] + 1;
X  height = phdr.Window[YMAX] - phdr.Window[YMIN] + 1;
X  depth =  phdr.NPlanes;
X  ptype =  phdr.Version;
X  color =  (ptype == 2) || (ptype == 5);
X  enc =    phdr.Encoding;
X
X  if (phdr.BitsPerPixel != 1)
X  { fprintf (stderr, "%s %d bits per pixel with %d planes\n", 
X	     "Error in PCX file, can't handle", 
X	     phdr.BitsPerPixel, depth);
X    return (0);
X  }
X
X  /* Initialize image header */
X  image->hdr.cols = width;
X  image->hdr.rows = height;
X  image->hdr.planes = 1;
X  image->hdr.bits = (color || depth > 1) ? 8 : 1;
X  image->hdr.physbits = 8;
X  image->hdr.rowlen = rowlen = 16 * ((width + 15) / 16);
X  image->hdr.plnlen = rowlen * height;
X  image->hdr.clrlen = clrlen = color ? (16 * 3) : 0;
X  image->hdr.aspect = 1.0;
X  image->hdr.title[0] = '\0';
X  image->hdr.credits[0] = '\0';
X
X  /* Describe what we are doing */
X  fprintf (stderr, "Reading PCX file [%dx%d]", width, height);
X  if (phdr.BitsPerPixel > 1)
X    fprintf (stderr, ", %d bits per pixel", phdr.BitsPerPixel);
X  if (depth > 1)
X    fprintf (stderr, ", %d planes", depth);
X  if (clrlen > 0)
X    fprintf (stderr, ", %d colors", clrlen/3);
X  fprintf (stderr, "\n");
X
X  /* Allocate space */
X  alloc_fbm (image);
X
X  /* Read colormap if need be */
X  if (clrlen > 0)
X  { for (c=0; c<16; c++)
X    { image->cm[c]    = phdr.Colormap[c][0];
X      image->cm[c+16] = phdr.Colormap[c][1];
X      image->cm[c+32] = phdr.Colormap[c][2];
X    }
X  }
X
X  /* Zero out the bits */
X  bmp = image->bm;
X  tail = bmp + image->hdr.plnlen;
X
X  while (bmp < tail) { *bmp++ = 0; }
X  
X  /* Bytes per scan line */
X  totalbytes = depth * phdr.BytesPerLine;
X  buf = (unsigned char *) malloc (totalbytes);
X
X  /* Now read bits */
X  for (r=0; r<height; r++)
X  { bmp = &(image->bm[r * rowlen]);
X  
X    /* Read a scan line */
X    if (pcxline_read (enc, buf, totalbytes, rfile) == 0)
X    { fprintf (stderr, "Premature EOF in row %d, totalbytes %d\n",
X		r, totalbytes);
X# ifdef REAL
X      free_fbm (image);
X      return (0);
X# else
X      return (1);
X# endif
X    }
X        
X    /* Decode scan line into row of image */
X    if (depth == 1)
X    { bmp = &(image->bm[r * rowlen]);
X      scan = buf;
X
X      for (c=0; c<width; c++)
X      { byte = c>>3;
X	mask = 0x80 >> (c&7);
X	*bmp++ = (buf[byte] & mask) ? WHITE : BLACK;
X      }
X    }
X    else
X    { for (k=0; k<depth; k++)
X      { bmp = &(image->bm[r * rowlen]);
X        scan = &buf[k * phdr.BytesPerLine];
X	bit = 1 << k;
X
X        for (c=0; c<width; c++)
X	{ byte = c>>3;
X	  mask = 0x80 >> (c&7);
X
X	  *bmp++ |= (buf[byte] & mask) ? bit : 0;
X        }
X      }
X    }
X  }
X
X  if (depth > 1)
X  { fprintf (stderr, "Read %d planes successfully\n", depth);
X  }
X
X  return (1);
X}
X
X/****************************************************************
X * encget (pbyt, pcnt, fid)	Page 10 of ZSoft Manual
X ****************************************************************/
X
Xencget (pbyt, pcnt, fid)
Xint *pbyt;	/* Where to place data */
Xint *pcnt;	/* Where to place count */
XFILE *fid;	/* Image file stream */
X{ register int i;
X
X  *pcnt = 1;		/* Safety play */
X  if (EOF == (i = getc (fid))) return (EOF);
X  if (CNTMSK == (CNTMSK & i))
X  { *pcnt = MAXCNT & i;
X    if (EOF == (i = getc (fid))) return (EOF);
X  }
X  *pbyt = i;
X  return (0);
X}
X
X/****************************************************************
X * pcxline_read
X ****************************************************************/
Xpcxline_read (enc, buf, total, fid)
Xunsigned char *buf;	/* Output buffer */
Xint total;		/* Bytes in one scan line */
XFILE *fid;		/* Input stream */
X{ int data, count, len=0;
X
X  if (enc != 1)
X  { return (fread (buf, 1, total, fid)); }
X
X  while (len < total)
X  { if (EOF == encget (&data, &count, fid))
X      return (len);
X    while (count > 0) { *buf++ = data; len++; count--; }
X  }
X  
X  if (count > 0)
X  { fprintf (stderr, "%s, after %d bytes, lost %d bytes of %02x\n",
X	     "Error in reading scan lines", total, count, data);
X  }
X
X  return (len);
X}
END_OF_FILE
if test 9151 -ne `wc -c <'flpcx.c'`; then
    echo shar: \"'flpcx.c'\" unpacked with wrong size!
fi
# end of 'flpcx.c'
fi
if test -f 'fltga.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fltga.c'\"
else
echo shar: Extracting \"'fltga.c'\" \(13220 characters\)
sed "s/^X//" >'fltga.c' <<'END_OF_FILE'
X/*****************************************************************
X * fltga.c: FBM Library 0.93 (Beta Test) 03-May-89  Ian MacPhedran
X *
X * Author Ian MacPhedran.
X * Permission is given to use any portion of this file, (including
X * its entirety) for whatever you wish. Howvever, please note that
X * it was written for Michael Mauldin's FBM Library, and conditions
X * therein are more restrictive.
X *
X * CONTENTS
X *    read_tga (image, rfile, mstr, mlen)
X *    write_tga (image, wfile)
X *
X * EDITLOG
X *	LastEditDate = Sat May 20 19:53:58 1989 - Michael Mauldin
X *	LastFileName = /usr2/mlm/src/misc/fbm/fltga.c
X *
X * HISTORY
X * 03-May-89  Michael Mauldin (mlm) at Carnegie Mellon University
X *	Beta release (version 0.93) mlm@cs.cmu.edu
X *
X * HISTORY
X * 13-Mar-89  Ian J. MacPhedran
X *	Add write_tga
X *
X * 07-Mar-89  Ian J. MacPhedran, University of Saskatchewan.
X *	Created.
X *****************************************************************/
X
X#include <stdio.h>
X#include "fbm.h"
X
X#ifndef lint
Xstatic char *fbmid =
X	"$FBM fltga.c <0.93> 03-May-89  (C) 1989 by Ian MacPhedran$";
X#endif
X
X
X/* For convenience, the TGA header file is included herein. */
X
X/*
X * Header file for Targa file definitions.
X *
X * These definitions will allow a consistant interface to build Targa (.TGA)
X * image files.
X *
X * Created NOV-15-1988 IJMP
X *
X */
X 
X/* File header definition */
X
Xstruct TGA_ImageHeader {
X		unsigned char IDLength;/* Length of Identifier String */
X		unsigned char CoMapType; /* 0 = NoMap */
X		unsigned char ImgType;	/* Image Type (1,2,3,9,10) */
X		unsigned char Index_lo, Index_hi;
X			/* Index of first colour map entry */
X		unsigned char Length_lo, Length_hi;
X			/* Length of colour map (number of entries) */
X		unsigned char CoSize;	/* Length of colour map entry */
X		unsigned char X_org_lo, X_org_hi;	/* X Origin of Image */
X		unsigned char Y_org_lo, Y_org_hi;	/* Y Origin of Image */
X		unsigned char Width_lo, Width_hi;	/* Width of Image */
X		unsigned char Height_lo, Height_hi;	/* Height of Image */
X		unsigned char PixelSize;	/* Pixel Size (8,16,24) */
X		unsigned AttBits : 4;	/* Number of Attribute Bits per pixel */
X		unsigned Rsrvd   : 1;	/* Reserved bit */
X		unsigned OrgBit  : 1;
X			/* Origin Bit (0=lower left, 1=upper left) */
X		unsigned IntrLve : 2;	/* Interleaving Flag */
X		};
X
Xchar TGA_ImageIDField[256];
X
X/* Definitions for Image Types */
X
X#define TGA_MapRGBType 1
X#define TGA_RawRGBType 2
X#define TGA_RawMonoType 3
X#define TGA_MapEnCodeType 9
X#define TGA_RawEnCodeType 10
X
X/*
X * read_tga(image, rfile, mstr, mlen)
X * from tga2rast.c:
X * Version 1.0 - first released for public consumption, 21 Feb, 1989
X *
X */
X
X#define MAXCOLOURS 16384
X
X/* Define flags for mode - these indicate special conditions */
X#define GREYSC 0
X#define COLOUR 1
X#define MAPPED 2
X#define RLENCD 4
X#define INTERL 8
X#define FOURWY 16
X
Xunsigned char ColourMap[MAXCOLOURS][3];
Xint RLE_count=0,RLE_flag=0;
X
Xread_tga(image, rfile, mstr, mlen)
XFBM *image;
XFILE *rfile;
Xchar *mstr;
Xint mlen;
X{
X/* Define Identifiers */
Xstruct TGA_ImageHeader	*tga;
Xint			i, j;
Xunsigned int		temp1, temp2, mode;
Xunsigned char		r, g, b;
Xunsigned long		k, baseline,linewidth;
Xunsigned char		*Red, *Grn, *Blu, *Redk, *Grnk, *Bluk;
X
X/* Input the Targa file header */
X	if ((tga=(struct TGA_ImageHeader *)
X		 malloc(sizeof(struct TGA_ImageHeader))) == NULL)
X	{
X		fprintf(stderr,"Can't allocate TGA memory\n");
X		exit(1);
X	}
X
X	if ((i = fread(tga,1,18,rfile)) != 18)
X	{
X		fprintf(stderr,"Read only %d bytes in header\n",i);
X		exit(1);
X	}
X	switch (tga->ImgType)
X	{
X		case TGA_MapRGBType:
X		case TGA_RawRGBType:
X		case TGA_RawMonoType:
X		case TGA_MapEnCodeType:
X		case TGA_RawEnCodeType:
X			break;
X
X		default:
X			fprintf(stderr,"Targa File Type %d",tga->ImgType);
X			fprintf(stderr," not supported!\n");
X			exit(1);
X	}
X
X/* Create output image header */
X	temp1 = tga->Height_lo; temp2 = tga->Height_hi;
X	image->hdr.rows = temp1 + temp2 * 256;
X	temp1 = tga->Width_lo; temp2 = tga->Width_hi;
X	image->hdr.cols = temp1 + temp2 * 256;
X	/* If this is odd number of bytes, add one */
X	if ((image->hdr.cols & 1) != 0) image->hdr.cols++;
X
X/* If greyscale, use only one plane */
X	if (tga->ImgType == TGA_RawMonoType)
X	{
X		image->hdr.planes = 1;
X		mode = GREYSC;
X	}
X	else
X	{
X		image->hdr.planes = 3;
X		mode = COLOUR;
X	}
X
X/* Uses 8 bits, sort of - 16 bits/pixel is 5 bits per colour */
X	image->hdr.bits = 8;
X	image->hdr.physbits = 8;
X	image->hdr.rowlen = image->hdr.cols;
X	image->hdr.plnlen = image->hdr.rows * image->hdr.cols;
X/* Ignore colour map for this version. */
X	image->hdr.clrlen = 0;
X	image->hdr.aspect = 1.0;
X	image->hdr.title[0] = '\0';
X	image->hdr.credits[0] = '\0';
X
X/* Get the Image */
X	alloc_fbm(image);
X
X/* Read ID String, if present */
X	if (tga->IDLength != 0)
X		fread(TGA_ImageIDField,1,tga->IDLength,rfile);
X
X/* If present, read the colour map information */
X        if (tga->CoMapType != 0)
X        {
X		temp1 = tga->Index_lo + tga->Index_hi * 256;
X		temp2 = tga->Length_lo + tga->Length_hi * 256;
X		if ((temp1+temp2+1) >= MAXCOLOURS)
X		{
X			fprintf(stderr,"Too many colours %d\n",(temp1+temp2+1));
X			exit(1);
X		}
X		for (i=temp1; i<(temp1+temp2); i++)
X			get_map_entry(&ColourMap[i][0],&ColourMap[i][1],
X			&ColourMap[i][2],tga->CoSize,mode);
X		if ((tga->ImgType != TGA_RawRGBType) &&
X			(tga->ImgType != TGA_RawMonoType) &&
X			(tga->ImgType != TGA_RawEnCodeType))
X			mode = mode | MAPPED;
X	}
X
X/* Check Run Length Encoding */
X	if ((tga->ImgType == TGA_MapEnCodeType) || 
X		(tga->ImgType == TGA_RawEnCodeType))
X		mode = mode | RLENCD;
X
X/* Check for interlacing of the Targa file */
X	switch (tga->IntrLve)
X	{
X		case 2: /* Four way interlace */
X			mode = mode | FOURWY;
X		case 1: /* Two way interlace */
X			mode = mode | INTERL;
X		case 0: /* No interlace */
X			break;
X		default: /* Reserved - we'll let it pass */
X			break;
X	}
X
X/* Set up byte map for writing */
X
X	Red = image->bm;
X	if ((mode & COLOUR) != GREYSC)
X	{
X		Grn = Red + image->hdr.plnlen;
X		Blu = Grn + image->hdr.plnlen;
X	}
X/* Read the Targa file body and convert to image format */
X	linewidth = tga->Width_lo + tga->Width_hi * 256;
X	for (i=0; i< image->hdr.rows; i++)
X	{
X		/* No interlace */
X		if ((mode & INTERL) == 0)
X		{
X			j = i;
X		}
X		/* Two way interlace */
X		else if ((mode & FOURWY) != 0)
X		{
X			if (2*i < image->hdr.rows)
X				j = 2*i;
X			else
X			{
X				j = i - image->hdr.rows/2;
X				j = 2*j + 1;
X			}
X		}
X		/* Four way interlace */
X		else
X		{
X			if (4*i < image->hdr.rows)
X				j = 4*i;
X			else if (2*i < image->hdr.rows)
X			{
X				j = i - image->hdr.rows/4;
X				j = 4*j + 1;
X			}
X			else if (4*i < 3*image->hdr.rows)
X			{
X				j = i - image->hdr.rows/2;
X				j = 4*j + 2;
X			}
X			else
X			{
X				j = i - image->hdr.rows/2 - image->hdr.rows/4;
X				j = 4*j + 3;
X			}
X		}
X		k = (image->hdr.rows - 1 - j) * image->hdr.cols;
X		Redk = Red + k;
X		if ((mode & COLOUR) != GREYSC)
X		{
X			Grnk = Grn + k; Bluk = Blu + k;
X		}
X		for (j=0; j<linewidth; j++)
X		{
X			get_pixel(&r,&g,&b,tga->PixelSize,mode);
X			*Redk++=r;
X			if ((mode & COLOUR) != GREYSC)
X			{
X				*Grnk++=g; *Bluk++=b;
X			}
X		}
X	}
X	free(tga);
X
X	return (1);
X}
X
X
Xget_map_entry(Red,Grn,Blu,Size,mode)
Xunsigned char     *Red,*Grn,*Blu;
Xint     Size,mode;
X{
Xunsigned int j,k,l;
Xunsigned char i,r,g,b;
X
X        /* read appropriate number of bytes, break into rgb & put in map */
X        switch (Size)
X        {
X	        case 8: /* Grey Scale already, read and triplicate */
X	                fread(&i,1,1,stdin);
X			r = i; g = i; b = i;
X	                break;
X
X	        case 16: /* 5 bits each of red green and blue */
X	        case 15: /* Watch for byte order */
X	                fread(&j,1,1,stdin);
X	                fread(&k,1,1,stdin);
X	                l = j + k*256;
X	                r = ((l >> 10) & 31) << 3;
X	                g = ((l >>  5) & 31) << 3;
X	                b = (l & 31) << 3;
X	                break;
X
X	        case 32: /* Read alpha byte & throw away */
X	                fread(&i,1,1,stdin);
X	        case 24: /* Eight bits each of red green and blue */
X	                fread(&i,1,1,stdin); r = i;
X	                fread(&i,1,1,stdin); g = i;
X	                fread(&i,1,1,stdin); b = i;
X	                break;
X
X	        default:
X	                fprintf(stderr,"Unknown Pixel Size\n"); exit(1);
X        }
X	*Red = r; *Grn = g; *Blu = b;
X}
X
Xget_pixel(rRed,rGrn,rBlu,Size,mode)
Xunsigned char *rRed,*rGrn,*rBlu;
Xint Size,mode;
X{
X	static unsigned char Red, Grn, Blu;
X	unsigned char i,j,k;
X	static unsigned int l;
X
X	/* Check if run length encoded. */
X	if ((mode & RLENCD) != 0)
X	{
X		if (RLE_count == 0) /* Have to restart run */
X		{
X			fread(&i,1,1,stdin);
X			RLE_flag = (i & 0x80) >> 7;
X			if (RLE_flag == 0)
X			{ /* Stream of unencoded pixels */
X				RLE_count = i + 1;
X			}
X			else
X			{ /* Single pixel replicated */
X				RLE_count = i - 127;
X			}
X			RLE_count--; /* Decrement count & get pixel */
X		}
X		else
X		{ /* Have already read count & (at least) first pixel */
X			RLE_count--;
X			if (RLE_flag != 0)
X			{ /* Replicated pixels */
X				goto PixEncode;
X			}
X		}
X	}
X	/* Read appropriate number of bytes, break into RGB */
X	switch(Size)
X	{
X	case 8: /* Grey Scale - read a byte and triplicate */
X		fread(&i,1,1,stdin);
X		Red = i; Grn = i; Blu = i; l = i;
X		break;
X
X	case 16: /* Five bits each of red green and blue */
X	case 15: /* Watch byte order */
X		fread(&j,1,1,stdin);
X		fread(&k,1,1,stdin);
X		l = j + k*256;
X		Red = ((k & 0x7C) << 1);
X		Grn = ((k & 0x03) << 6) + ((j & 0xE0) >> 2);
X		Blu = ((j & 0x1F) << 3);
X		break;
X
X	case 32: /* Read alpha byte & throw away */
X		fread(&i,1,1,stdin);
X	case 24: /* Eight bits each of red green and blue */
X		fread(&i,1,1,stdin); Red = i;
X		fread(&i,1,1,stdin); Grn = i;
X		fread(&i,1,1,stdin); Blu = i;
X		l = 0;
X		break;
X
X	default:
X		fprintf(stderr,"Unknown Pixel Size\n"); exit(1);
X	}
X
XPixEncode:
X	if ((mode & MAPPED) == MAPPED)
X	{
X		*rRed = ColourMap[l][0];
X		*rGrn = ColourMap[l][1];
X		*rBlu = ColourMap[l][2];
X	}
X	else
X	{
X		*rRed = Red;
X		*rGrn = Grn;
X		*rBlu = Blu;
X	}
X}
X
X/*
X * write_tga(image, wfile)
X *
X */
Xwrite_tga(image, wfile)
XFBM *image;
XFILE *wfile;
X{
Xunsigned char		*Red, *Grn, *Blu, *Redk, *Grnk, *Bluk;
Xunsigned char		*Redc, *Grnc, *Bluc, *Redck, *Grnck, *Bluck;
Xstruct TGA_ImageHeader	*tga;
Xunsigned char		buffer[MAXCOLOURS];
Xunsigned int		mode;
Xunsigned long		index, index2;
Xint			i, j, k, l;
X
X	if (image->hdr.cols > (MAXCOLOURS / 2))
X	{
X		fprintf(stderr,"Line too wide is %d, must be %d\n",
X		image->hdr.cols, MAXCOLOURS/2);
X		exit(1);
X	}
X
X	if ((image->hdr.planes != 1) && (image->hdr.planes != 3))
X	{
X		fprintf(stderr,"TGA files must 1 or 3 planes deep\n");
X		exit(1);
X	}
X	if (image->hdr.planes == 1) mode = GREYSC;
X	else mode = COLOUR;
X	
X	if ((tga=(struct TGA_ImageHeader *)
X	         malloc(sizeof(struct TGA_ImageHeader))) == NULL)
X	{
X		fprintf(stderr,"Can't allocate TGA memory\n");
X		exit(1);
X	}
X	tga->IDLength = 0; /* Don't write ID into file */
X	tga->CoMapType = 0; /* Use raw bytes, not mapped */
X	
X	tga->ImgType = TGA_RawRGBType;
X	if ((mode & COLOUR) == GREYSC) tga->ImgType = TGA_RawMonoType;
X	
X	tga->Index_hi = 0; tga->Index_lo = 0; /* Colour Mapped stuff */
X	tga->Length_hi = 0; tga->Length_lo = 0;
X	tga->CoSize = 8;
X
X	tga->X_org_lo = 0; tga->X_org_hi = 0; /* Origin at 0,0 */
X	tga->Y_org_lo = 0; tga->Y_org_hi = 0;
X
X	tga->Width_hi = (unsigned char)(image->hdr.cols / 256);
X	tga->Width_lo = (unsigned char)(image->hdr.cols % 256);
X	tga->Height_hi = (unsigned char)(image->hdr.rows / 256);
X	tga->Height_lo = (unsigned char)(image->hdr.rows % 256);
X	
X	tga->PixelSize = 16;
X	if ((mode & COLOUR) == GREYSC) tga->PixelSize = 8;
X	
X	/* All funny bits set to zero */
X	tga->AttBits = 0; tga->Rsrvd = 0; tga->OrgBit; tga->IntrLve = 0;
X
X	fwrite(tga,1,18,wfile); /* Write out header */
X
X	Red = image->bm;
X	l = image->hdr.cols;
X	if ((mode & COLOUR) == COLOUR)
X	{
X		l = l * 2;
X		Grn = Red + image->hdr.plnlen;
X		Blu = Grn + image->hdr.plnlen;
X	}
X
X	if (image->hdr.clrlen > 0)
X	{
X		mode = mode | MAPPED;
X		Redc = image->cm;
X		if ((mode & COLOUR) == COLOUR)
X		{
X			Grnc = Redc + image->hdr.clrlen/3;
X			Bluc = Grnc + image->hdr.clrlen/3;
X		}
X	}
X	
X	Redk = Red + image->hdr.plnlen - image->hdr.cols;
X	if ((mode & COLOUR) == COLOUR)
X	{
X		Grnk = Grn + image->hdr.plnlen - image->hdr.cols;
X		Bluk = Blu + image->hdr.plnlen - image->hdr.cols;
X	}
X
X	/* Okay, ready to write */
X	for (j=0; j<image->hdr.rows; j++)
X	{
X	for (i=0; i<image->hdr.cols; i++)
X	{
X		index = *Redk++;
X		if ((mode & COLOUR) == COLOUR)
X			index = (index << 16) + ((*Grnk++) << 8) +  *Bluk++;
X
X		if ((mode & MAPPED) == MAPPED)
X		{
X			index2 = index;
X			Redck = Redc + index2;
X			index = *Redck;
X			if ((mode & COLOUR) == COLOUR)
X			{
X				Grnck = Grnc + index2; Bluck = Bluc + index2;
X				index = (index << 16) +
X					((unsigned long)*Grnck << 8) +
X					*Bluck;
X			}
X		}
X		
X		if ((mode & COLOUR) == COLOUR)
X		{
X			index2 = ((index & 0x00f80000) >> 9)
X			       + ((index & 0x0000f800) >> 6)
X			       + ((index & 0x000000f8) >> 3);
X			k = 2 * i;
X			buffer[k] = (unsigned char)(index2 % 256);
X			k = k + 1;
X			buffer[k] = (unsigned char)(index2 / 256);
X		}
X		else
X		{
X			buffer[i] = (unsigned char)index;
X		}
X	}
X	fwrite(buffer,l,1,wfile);
X	Redk = Redk - 2 * image->hdr.cols;
X	if ((mode & COLOUR) == COLOUR)
X	{
X		Grnk = Grnk - 2 * image->hdr.cols;
X		Bluk = Bluk - 2 * image->hdr.cols;
X	}
X	}
X	free(tga);
X	
X	return (1);
X}
END_OF_FILE
if test 13220 -ne `wc -c <'fltga.c'`; then
    echo shar: \"'fltga.c'\" unpacked with wrong size!
fi
# end of 'fltga.c'
fi
echo shar: End of archive 6 \(of 8\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
