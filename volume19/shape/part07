Subject:  v19i020:  A software configuration management system, Part07/33
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Axel Mahler <unido!coma!axel>
Posting-number: Volume 19, Issue 20
Archive-name: shape/part07



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 33)."
# Contents:  bin/rcs2afs man/man3/afversions.3 src/afs/Shapefile
#   src/misc/hash.c src/vc/save.c src/vc/vc_call.c src/vfind/at_misc.c
# Wrapped by rsalz@papaya.bbn.com on Thu Jun  1 19:26:55 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'bin/rcs2afs' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bin/rcs2afs'\"
else
echo shar: Extracting \"'bin/rcs2afs'\" \(6853 characters\)
sed "s/^X//" >'bin/rcs2afs' <<'END_OF_FILE'
X#! /bin/csh -f
X#
X# Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X#  and U. Pralle
X# 
X# This software is published on an as-is basis. There is ABSOLUTELY NO
X# WARRANTY for any part of this software to work correctly or as described
X# in the manuals. We do not accept any liability for any kind of damage
X# caused by use of this software, such as loss of data, time, money, or effort.
X# 
X# Permission is granted to use, copy, modify, or distribute any part of
X# this software as long as this is done without asking for charge, and
X# provided that this copyright notice is retained as part of the source
X# files. You may charge a distribution fee for the physical act of
X# transferring a copy, and you may at your option offer warranty
X# protection in exchange for a fee.
X# 
X# Direct questions to: Tech. Univ. Berlin
X# 		     Wilfried Koch
X# 		     Sekr. FR 5-6 
X# 		     Franklinstr. 28/29
X# 		     D-1000 Berlin 10, West Germany
X# 
X# 		     Tel: +49-30-314-22972
X# 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X# 
X# LAST EDIT: Thu Feb 23 18:53:42 1989 by Uli Pralle (coma!uli) 
X# LAST EDIT: Wed Oct 26 23:58:29 1988 by Uli Pralle (coma!uli) 
X# LAST EDIT: Tue Oct 25 23:59:52 1988 by Uli Pralle (coma!uli) 
X#
X# rcs2afs  -- convert a RCS file to AFS
X#						Uli Pralle (uli@coma.UUCP)
Xset AFSid = '$Header: rcs2afs[1.0] Thu Feb 23 19:03:47 1989 uli@coma published $'
X
X#
X# Log for /u/shape/dist-tape/bin/rcs2afs[1.0]
X# 	Thu Feb 23 19:03:47 1989 uli@coma published $
X#  --- empty log message ---  
X#
X
Xset progname = $0
Xset progname = $progname:t  # weiss der henker warum $0:t nicht geht... 
X      	      	      	    # und kommt mit bloss keiner mit rtfm...
X
Xif ($#argv == 0) goto usage
X
Xset files = ""
Xset _verbose = 1
Xset incremental = 0
Xset preserve = 0
Xset mode = 644
X
X# test for options
Xset i = 0
Xwhile ($i < $#argv)
X  @ i++
X  switch ($argv[$i])
X  case "-incremental":
X    echo "Option -incremental not yet implemented."
X    goto usage
X    set incremantal = 1
X    continue;
X  case "-preserve":
X    set preserve = 1
X    continue;
X  case "-mode":
X    @ i++;
X    set mode = $argv[$i]
X    continue;
X  case "-q":
X    set _verbose = 0
X    continue;
X  case "-h":
X  case "-help":
X    goto usage			# never returns
X    continue;
X  case "-version":
X    set noglob
X    set vers = ($AFSid)
X    set last = $#vers
X    @ last--
X    echo "This is $vers[2]:t $vers[3-$last]"
X    unset noglob
X    exit (0)
X  default:
X    set files = ($files "$argv[$i]")
X    continue;
X  endswitch
Xend
X
Xif ($#files == 0) goto usage
X
Xonintr signal			# catch signals
X
Xset busysaved = 0		# 1 if busy version existst
X
X# generate awk script
X
Xcat << AWKEOF > /tmp/$$.awk
X#! /bin/awk -f
XBEGIN {
X  revs = 0;
X  branches = 0;
X  nsym = 0;
X}
X
X/head/ || /next/ {
X  if (\$2 != ";") {
X    rev[revs] = substr(\$2,1,length(\$2)-1);
X    revs++;
X  }
X}
X
X/symbols/ {
X  symbolics = substr(\$0,index(\$0,\$2));
X  symbolics = substr(symbolics, 1, length(symbolics) -1 );
X}
X   
X/comment/ {
X  clead = substr(\$0, index(\$0,\$2));
X  clead = substr(clead,2,length(clead)-3);
X  if (clead == "@@") {
X    clead = "@";
X  }
X}
X
X/branches/ {
X  if (\$2 != ";") {
X    branches++;
X  }
X}
X
X/desc/ { exit; }
X
XEND {
X  printf ("set revisions = (");
X  for (revs--; revs >= 0; revs-- )
X    printf ("%s ", rev[revs]);
X  printf (")\n");
X  printf ("set clead = \"%s\"\n", clead);
X  printf ("set branches = \"%s\"\n", branches);
X  printf ("set symbolics = (");
X  nsym = split(symbolics, symbolics);
X  for (i = 1; i <= nsym; i++) {
X    split (symbolics[i], foo, ":");
X    printf ("%s %s ", foo[2], foo[1]);
X  }
X  printf (")\n");
X}
XAWKEOF
X
Xif (! -d AFS) then
X  if ($_verbose) echo "Creating AFS directory."
X  mkdir AFS
Xendif
X
X# process each RCS file
Xforeach i ($files)
X  set i = "`basename $i ',v'`,v"
X
X  set dir = ""
X  if (! -e $i) then
X    if ( -e RCS/$i) then
X      set dir = "RCS/"
X    else
X     echo "RCS archive <$i> not found. --- Skipped." > /dev/tty
X     continue;
X    endif
X  endif
X
X  set noglob  
X  eval `awk -f /tmp/$$.awk $dir$i`
X  unset noglob
X  
X  set i = $i:t
X
X  if ($#revisions == 0) then
X    echo "$i is not an RCS archive. --- Skipped." > /dev/tty
X    continue
X  endif
X
X  if ($branches > 0) then
X    echo "Warning: $i contains non convertible branches. Ignored."
X  endif
X
X  set busyvers = `basename $i ",v"`
X
X  if ($incremental) then
X    set vlrevisions = (`vl $busyvers | sed -e 's/.*\[//' -e 's/\]//'`)
X  endif
X
X  if (-e $busyvers) then
X    if ($_verbose) echo "Temporary saving busy version $busyvers as $$save..."
X    mv $busyvers $$save
X    set busysaved = 1
X  endif
X  
X  if (! $preserve) set curgen = `echo $revisions[1] | sed -e 's/\.[0-9]*//'`
X  
X  if ($_verbose) echo -n $i":"
X
X  if (! $incremental) then 
X    (rm -f AFS/*$busyvers*) >& /dev/null
X
X  foreach j ($revisions)
X    if ($_verbose) echo -n " $j"
X    co -r$j $busyvers >& /dev/null
X    chmod $mode $busyvers
X    
X    if ($status != 0) then
X      echo $progname":" "co fails. Do You wish to continue ? [y/n]" > /dev/tty
X      set answer = $<
X      switch ($answer)
X      	case "N":
X      	case "n":
X      	  goto cleanup
X      	case "y":
X      	case "Y":
X      	default:
X          continue;
X      endswitch
X    endif
X
X    if (! $preserve) then
X      set thisgen = `echo $j | sed -e 's/\.[0-9]*//'`
X    
X      if ($thisgen > $curgen) then # change in generation
X        Save -fq $busyvers
X        set curgen = $thisgen
X      else
X        save -fq $busyvers
X      endif
X    else
X      save -fq -setvnum $j $busyvers
X    endif
X    rm -f $busyvers
X  end
X  
X# set comment leader, iff necessary
X  set noglob
X  if ("$clead" != "") then
X      vadm -q -setc $clead $busyvers
X  endif
X  unset noglob
X
X  if ($_verbose) echo ""
X
X# preserve symbolic names
X    set k = 1;
X    while ($k <= $#symbolics) 
X      set thisrev = $symbolics[$k]
X      @ k++;
X      set thissymbolic = $symbolics[$k]
X      vadm -q -V $thisrev -symbolic $thissymbolic $busyvers 
X      @ k++;
X    end
X
X  if ($busysaved == 1) then
X    if ($_verbose) echo "$busyvers restored..."
X    mv $$save $busyvers
X    set busysaved = 0
X  endif
Xend
X
Xif ($_verbose) echo "done."
Xrm -f /tmp/$$.awk
Xexit (0)
X
Xsignal:
X  if ($_verbose) then
X    echo ""
X    echo $progname": Caught signal, cleaning up..."
X  endif
Xcleanup:
X  if ($busysaved == 1) then
X    if ($_verbose) echo "$busyvers restored..."
X      mv $$save $busyvers
X      set busysaved = 0
X  endif
X  rm -f /tmp/$$.awk
X  if ($_verbose) echo "terminated."
X  exit (1)
X
Xusage:
X  echo $progname":" "[-h -q -incremental -preserve] file ..."
X  echo " -h  -- this help"
X  echo " -q  -- be quiet"
X  echo " -incremental -- convert into an existing AFS file (not yet implemented)"
X  echo " -preserve -- preserve RCS version numbering"
X  exit (1)
X
X# Local Variables:
X# tab-stop-list:(2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72)
X# eval:(local-set-key "	" 'tab-to-tab-stop)
X# End:
X
X
END_OF_FILE
if test 6853 -ne `wc -c <'bin/rcs2afs'`; then
    echo shar: \"'bin/rcs2afs'\" unpacked with wrong size!
fi
chmod +x 'bin/rcs2afs'
# end of 'bin/rcs2afs'
fi
if test -f 'man/man3/afversions.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/man3/afversions.3'\"
else
echo shar: Extracting \"'man/man3/afversions.3'\" \(6476 characters\)
sed "s/^X//" >'man/man3/afversions.3' <<'END_OF_FILE'
X...
X... Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X...  and U. Pralle
X... 
X... This software is published on an as-is basis. There is ABSOLUTELY NO
X... WARRANTY for any part of this software to work correctly or as described
X... in the manuals. We do not accept any liability for any kind of damage
X... caused by use of this software, such as loss of data, time, money, or 
X... effort.
X... 
X... Permission is granted to use, copy, modify, or distribute any part of
X... this software as long as this is done without asking for charge, and
X... provided that this copyright notice is retained as part of the source
X... files. You may charge a distribution fee for the physical act of
X... transferring a copy, and you may at your option offer warranty
X... protection in exchange for a fee.
X... 
X... Direct questions to: Tech. Univ. Berlin
X... 		     Wilfried Koch
X... 		     Sekr. FR 5-6 
X... 		     Franklinstr. 28/29
X... 		     D-1000 Berlin 10, West Germany
X... 
X... 		     Tel: +49-30-314-22972
X... 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X... 
X.TH AF_VERSIONS 3 "" \n(dy.\n(mo.\n(yr
X.SH NAME
Xaf_version \(em interface to the version control system in the Attribute
XFilesystem
X.SH SYNOPSIS
X\fB#include <afs.h>
X.sp
Xaf_newgen (key, newkey)
X.br
XAf_key	*key, *newkey;
X.sp
Xaf_setbusy (busykey, newkey)
X.br
XAf_key	*busykey, *newkey;
X.sp
Xaf_saverev (busykey, savekey)
X.br
XAf_key	*busykey, *savekey;
X.sp
Xaf_savebinary (busykey, savekey)
X.br
XAf_key	*busykey, *savekey;
X.sp
Xaf_rstate (key)
X.br
XAf_key	*key;
X.sp
Xaf_sstate (key, state)
X.br
XAf_key	*key;
X.br
Xint	state;
X.sp
Xaf_svnum (key, gen, rev)
X.br
Xint	gen, rev;
X.SH DESCRIPTION
X\fIAf_newgen\fR opens a new generation in a line of development.
XThe last saved version will be duplicated. This creates a new ASO,
Xthat is numbered by a new generation number (increased by 1)
Xand the initial revision number (0).
XAll other attributes remain unchanged.
X\fIaf_newgen\fR requires a lock (see af_lock(3)) set on the ASO specified
Xby \fIkey\fR.
X.PP
XWith \fIaf_setbusy\fR you can declare a saved version as new busy version.
X\fBNote:\fR Only the corresponding attributes are updated.
X\fIAf_setbusy\fR does not copy any data! You have to use \fIaf_open(3)\fR
Xand \fIfread/fwrite(3)\fR to produce a new busy version
X\fIAf_setbusy\fR requires a lock (see af_lock(3)) set on the ASO specified
Xby \fIbusykey\fR.
X.PP
X\fIAf_saverev\fR makes a copy of the ASO identified by \fIbusykey\fR.
XThis new ASO gets the status \fIsaved\fR and a version number
Xaccording to the AFS version-numbering scheme:
X.RS
XThe initial revision is numbered by generation number 1 and revision number 0.
XAll other saved versions get version numbers built from
Xthese of their predecessors by preserving the generation number and
Xincreasing the revision number by 1.
X.RE
XAll remaining attributes (including user defined attributes) are inherited
Xfrom the busy version.
XThe key of the generated ASO is returned in \fIsavekey\fR. 
XUse \fIaf_dropkey\fR to free the allocated memory associated with
X\fIsavekey\fR.
X.br
XBefore you can save an ASO you must reserve the update permission
Xfor the corresponding line of development by locking the busy
Xobject (\fIaf_lock\fR).
XThe execution of \fIaf_saverev\fR does not affect the lock
X(it remains active).
X.PP
X\fIAf_savebinary\fR saves an ASO to a derived object pool.
XDerived object pools are intended to hold derived objects that can be
Xreproduced at any time.
XThis is important, because ASOs residing in derived object pools
Xthat have not been accessed for a longer time may be deleted
Xautomatically due to storage limitations for derived object pools.
XThe maximum number of objects stored in a binary pool
Xcan be given by setting the environment variable AFSBPSIZ to the
Xappropriate value (default is 64).
XSee \fIaf_intro (3)\fR for further details on derived object pools.
X.br
XASOs that are saved in derived object pools do not get a version number.
XBy means of \fIaf_svnum\fR you can attach any version number to an
XASO stored in a derived object pool.
X.br
XBy saving an object to a derived object pool, the given busy object
X(identified by \fIbusykey\fR) is destroyed.
XDuring the execution of \fIaf_savebinary\fR \fIbusykey\fR is
Xautomatically dropped and cannot be used any longer.
X.PP
X\fIAf_rstate\fR returns the version state of the ASO
Xidentified by \fIkey\fR.
XPossible states are:
X.IP \fBbusy\fR 0.8i 
XThe version is under development and its contents may
Xbe changed.
X.IP \fBsaved\fR 
XThe version is saved and may be used for later backup.
X.IP \fBproposed\fR
XThe version has been submitted for publication by the developer
Xbut still needs formal approval by a quality assurance board
Xto become publically visible and accessible in the official
Xdatabase.
X.IP \fBpublished\fR
XThe version has passed the formal approval and is now accessible to
Xevery member of the project. It is not yet accessed and may therefore
Xbe withdrawn if necessary.
X.IP \fBaccessed\fR 
XThe version has been published, and is now 
Xaccessed by some members of the project.
X.IP \fBfrozen\fR
XThe version may be part of a system configuration
Xthat has been released to the outside world. This means it must, under
Xno circumstances, be destroyed.
X.RE
X.PP
XThe function
X\fIaf_sstate\fR sets the state of the identified ASO.
XOnly state transitions from one state to the next or previous state
X(according to the list above) are allowed.
X.PP
X\fIAf_svnum\fR sets the version number of the identified ASO to the
Xgiven generation (\fIgen\fR) and revision (\fIrev\fR) number.
XThe version number of source objects can only be \(bqincreased\(rq \-
Xthe version number of derived objects can be set to any value.
X\fIAf_svnum\fR requires a lock (see af_lock(3)) set on the ASO specified
Xby \fIkey\fR.
X.SH SEE ALSO
Xaf_intro (3), af_lock(3)
X.SH DIAGNOSTICS
XUpon error, \-1 is returned and \fIaf_errno\fR is set to the corresponding
Xerror number
X.SH BUGS
X\fIAf_setbusy\fR interrupts the delta chain if no busy version is present.
XFor the user of AFS, this is only a performance loss \- not a malfunction.
X.PP
XDue to limitations in the \s-1UNIX\s+1 filesystem, only the creator
X(author) of a derived object may save it to a derived object pool.
X.PP
XEmpty files cannot be inserted in a derived object pool.
X.PP
XShrinking of binary pools (setting AFSBPSIZ to a value that is smaller
Xthan the actual number of files inthe binary pool) causes
Xuncontrolled removing of supernumerary files. They are \fInot\fR
Xcleared out on a last accessed basis.
END_OF_FILE
if test 6476 -ne `wc -c <'man/man3/afversions.3'`; then
    echo shar: \"'man/man3/afversions.3'\" unpacked with wrong size!
fi
# end of 'man/man3/afversions.3'
fi
if test -f 'src/afs/Shapefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/afs/Shapefile'\"
else
echo shar: Extracting \"'src/afs/Shapefile'\" \(6254 characters\)
sed "s/^X//" >'src/afs/Shapefile' <<'END_OF_FILE'
X#
X# Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X#  and U. Pralle
X# 
X# This software is published on an as-is basis. There is ABSOLUTELY NO
X# WARRANTY for any part of this software to work correctly or as described
X# in the manuals. We do not accept any liability for any kind of damage
X# caused by use of this software, such as loss of data, time, money, or effort.
X# 
X# Permission is granted to use, copy, modify, or distribute any part of
X# this software as long as this is done without asking for charge, and
X# provided that this copyright notice is retained as part of the source
X# files. You may charge a distribution fee for the physical act of
X# transferring a copy, and you may at your option offer warranty
X# protection in exchange for a fee.
X# 
X# Direct questions to: Tech. Univ. Berlin
X# 		     Wilfried Koch
X# 		     Sekr. FR 5-6 
X# 		     Franklinstr. 28/29
X# 		     D-1000 Berlin 10, West Germany
X# 
X# 		     Tel: +49-30-314-22972
X# 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X# 
X#
X# Shapefile for AFS
X#
X# $Header: Shapefile[1.0] Wed Feb 22 16:28:28 1989 andy@coma published $
X#
X
XUSERID  = `/usr/ucb/whoami`\@`hostname`
X
X#
X#  Tool definition & location part
X#  (these macros might be site and/or system-dependent)
X#
X
XSYSTEM = bsd_4_3 
XQUALITY = test_profiling
Xvpath = /u/shape/src/delta
X
X# ---> define locations of sources and executables
XSRCDIR = /u/andy/shape/afs
XINSTALDIR = /u/shape
XAFSINC = /u/shape/src/inc
XDELTAPATH = /u/shape/src/delta
XINSTALOWNER = shape
XINSTALGROUP = unib
X
X#% VARIANT-SECTION
X
Xvclass system ::= (bsd_4_3, sunos_3_4, sunos_4_0, ultrix_2_0)
Xvclass quality ::= (test, test_profiling, trace, final)
X
Xbsd_4_3:
X	vflags = -DBSD_4_3 -DSYSLOG
Xsunos_3_4:
X	vflags = -DSUNOS_3_4 -DOLDDBM
X	CLIBS = -ldbm
Xsunos_4_0:
X	vflags = -DSUNOS_4_0 -DSYSLOG
Xultrix_2_0:
X	vflags = -DULTRIX_2_0 -DOLDDBM
X	CLIBS = -ldbm
X
Xtest:
X	CFLAGS = -g
X	LDFLAGS = -g
Xtest_profiling:
X	CFLAGS = -pg -g
X	LDLAGS = -pg -g
Xtrace:
X	CFLAGS = -g -DMEMDEBUG  -DTMPDEBUG  -DHASHDEBUG
Xfinal:
X	CFLAGS = -g
X	LDFLAGS = -g
X
X#% END-VARIANT-SECTION
X
X#% RULE-SECTION
X
Xtestrule:
X	af_version.c, attrge (state, saved), attrmax (version);
X	*, attr (state, busy);
X	*, attrge (state, saved), attrmax (version), \
X		msg (used archived version of $+.).
X
Xrelrule:
X	bsfd.c, attr (state, busy);
X	lcs*.c, attr (state, busy);
X	*, attr (state, published), attrmax (version).
X
X#% END-RULE-SECTION
X
XPRODUCT = afs
XPROGS = libafs.a afsrepair
X
XSOURCE = \
X	afarchive.c afenviron.c aflib.c afvers.c afdelta.c afkeys.c\
X	afstates.c afsattrs.c afretr.c afsysc.c affiles.c afcattrs.c\
X	afsets.c afhash.c afcompar.c afbpool.c afsymtab.c afstore.c\
X	aflock.c afsrepair.c
X
X
XDELTASOURCE = \
X	bsfd.c lcs.main.c lcs.cdlt.c lcs.gedc.c edcmd.h suffix.h predef.h
X
XINCLUDE = afs.h afsys.h afarchive.h
X
XCOMPONENTS = $(SOURCE) $(INCLUDE) afsrepair.h
X
X.BPOOL: $(AFSOBJS) $(DELTALIB) $(AFSDB)
X
XVERSION = af_version
X
XAFSOBJS = \
X	afarchive.o afenviron.o aflib.o afvers.o afdelta.o afkeys.o\
X	afstates.o afsattrs.o afretr.o afsysc.o affiles.o afcattrs.o\
X	afsets.o afhash.o afcompar.o afbpool.o afsymtab.o afstore.o\
X	aflock.o
X
XDELTALIB = bsfd.o lcs.cdlt.o lcs.gedc.o lcs.main.o
X#DELTALIB = deltalib.o
X
XTESTSOURCE = \
X	testmain.c testcall.c testfdes.c testkey.c testabuf.c testset.c\
X	testvar.c testshow.c test.h
X
XAFSDB = testmain.o testcall.o testshow.o testvar.o testkey.o testset.o\
X	testabuf.o testfdes.o
X
X#
X#  Top level targets (containing selection rules)
X#
X
Xall: testrule +$(SYSTEM) +$(QUALITY) libafs.a afsrepair afsdb
X# "afsdb" only on coma
X
Xlib: testrule +$(SYSTEM) +$(QUALITY) libafs.a
X
Xrepair: testrule +$(SYSTEM) +$(QUALITY) afsrepair
X
Xtest: testrule +$(SYSTEM) +$(QUALITY) afsdb
X
Xinstallall: install installtest
X
Xinstall: relrule +$(SYSTEM) +final installafs
X
X# installtest: relrule +$(SYSTEM) +final prepare_testrel installafsdb
Xinstalltest: relrule +$(SYSTEM) +test prepare_testrel installafsdb
X
Xobjects : testrule +$(SYSTEM) +$(QUALITY) $(AFSOBJS) afsrepair.o
X
X#
X# building the library
X#
X
Xlibafs.a: $(AFSOBJS) $(DELTALIB) $(VERSION).o
X	@ar ruv libafs.a $(AFSOBJS) $(DELTALIB) $(VERSION).o
X
X#
X# preparing releases
X#
X
Xsave:
X	save $(COMPONENTS) $(TESTSOURCE)
X
Xrelease:
X	@rm -f $(VERSION).c; \
X	echo 'char *$Shapefile () {' >> $(VERSION).c ; \
X	echo '  static char ConfID[] =  "$1.0 ($Wed Feb 22 16:25:33 1989 by $andy@coma$)";' >> $(VERSION).c ; \
X	echo '  return ConfID;' >> $(VERSION).c ; \
X	echo '}' >> $(VERSION).c; \
X	sbmt -fq $(VERSION).c; \
X	__rel__=`vl -y $(VERSION).c | sed -e 's/^.*\[//;s/\]$$//'`; \
X	echo Generating Release $$__rel__; \
X	sbmt -q -n rel-$$__rel__ $(COMPONENTS) $(TESTSOURCE) Shapefile Makefile; \
X	echo ;\
X	echo don\'t forget to execute \'shape install\'
X
Xgeneration:
X
X#
X# installing
X#
X
Xinstallafs: libafs.a afsrepair $(AFSINC)/afs.h $(AFSINC)/afsys.h
X	mv $(INSTALDIR)/lib/libafs.a $(INSTALDIR)/lib/libafs.backup
X	install -c -m 644 -o $(INSTALOWNER) -g $(INSTALGROUP) libafs.a $(INSTALDIR)/lib
X	ranlib $(INSTALDIR)/lib/libafs.a
X	install -c -m 755 -o $(INSTALOWNER) -g $(INSTALGROUP) afsrepair $(INSTALDIR)/bin
X
X$(AFSINC)/afs.h: afs.h
X	install -c -m 644 -o $(INSTALOWNER) -g $(INSTALGROUP) afs.h $(AFSINC)
X
X$(AFSINC)/afsys.h: afsys.h
X	install -c -m 644 -o $(INSTALOWNER) -g $(INSTALGROUP) afsys.h $(AFSINC)
X	touch $(AFSINC)/afs.h
X
X#
X# archive repair tool
X#
X
X$(AFSOBJS) $(AFSDB) afsrepair.o: $(INCLUDE)
X
Xafsrepair.o: afsrepair.h
X
Xafsrepair: afsrepair.o afsysc.o afsymtab.o afenviron.o afhash.o\
X		aflib.o af_version.o
X	$(CC) -o afsrepair $(LDFLAGS) afsrepair.o afsysc.o afsymtab.o\
X		afenviron.o afhash.o aflib.o af_version.o
X
X#
X# Test-environment for libafs.a (only on coma)
X#
X
Xinstallafsdb: $(AFSDB) afsdb
X	install -c -m 755 -o $(INSTALOWNER) -g $(INSTALGROUP) afsdb $(INSTALDIR)/bin
X	rm -f $(INSTALDIR)/bin/afstest
X	ln $(INSTALDIR)/bin/afsdb $(INSTALDIR)/bin/afstest
X
Xafsdb: $(AFSDB) $(AFSOBJS) $(DELTALIB) $(VERSION).o
X	$(CC) -o afsdb $(LDFLAGS) $(AFSDB) $(AFSOBJS) $(VERSION).o\
X		$(DELTALIB) $(CLIBS)
X
X$(AFSDB): test.h
X
X#
X# Miscellaneous stuff
X#
X
Xlint:
X	lint $(DELTASOURCE) $(SOURCE)
X
Xtags: $(SOURCE)
X	/usr/local/etags $(SOURCE)
X
Xxref: $(SOURCE)
X	/usr/ucb/ctags -w -x $(SOURCE) > xref
X
Xclean :
X	rm $(AFSOBJS)
X
Xtar:
X	tar cvf /tmp/afs.tar $(COMPONENTS) $(TESTSOURCE) Makefile; \
X	cd $(DELTAPATH); \
X	tar uvf /tmp/afs.tar $(DELTASOURCE)
END_OF_FILE
if test 6254 -ne `wc -c <'src/afs/Shapefile'`; then
    echo shar: \"'src/afs/Shapefile'\" unpacked with wrong size!
fi
# end of 'src/afs/Shapefile'
fi
if test -f 'src/misc/hash.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/misc/hash.c'\"
else
echo shar: Extracting \"'src/misc/hash.c'\" \(6107 characters\)
sed "s/^X//" >'src/misc/hash.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
Xstatic char *AFSid = "$Header: hash.c[2.1] Thu Feb 23 21:24:20 1989 axel@coma published $";
X
X/*
X * Log for /u/shape/dist-tape/src/misc/hash.c[1.1]
X * 	Thu Feb 23 21:24:20 1989 axel@coma save $
X *  --- empty log message ---
X *  hash.c[2.0] Thu Feb 23 21:24:20 1989 axel@coma published $
X *  --- empty log message ---
X *  hash.c[2.1] Thu Feb 23 21:24:20 1989 axel@coma published $
X *  --- empty log message ---
X */
X/*
X * $Log:	hash.c,v $
X * Revision 2.0  88/06/29  16:14:43  axel
X * New System Generation
X * 
X * Revision 1.1  88/06/07  17:10:05  axel
X * This version is part of a release
X * 
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <strings.h>
X#include "hash.h"
X
Xhashinit (htab, hsize, sizeratio, fhash) Hash *htab; int hsize, sizeratio,
X       (*fhash)(); {
X  char *chash, *malloc();
X  int ltimes, ctimes;
X  register int i;
X  register int lnull = 0L;
X  long *lhash;
X
X/*
X * Determination of reasonable size and initialization of hashtable.
X */
X
X  /* initialize Hash - structure */
X  htab->hsize = hsize/sizeratio;
X  if ((htab->hashtb = 
X       (Hashent *)malloc (htab->hsize*sizeof (Hashent))) == NULL) {
X    perror ("malloc hashtable");
X    exit (1);
X  }
X  htab->fhash = fhash;
X#ifdef CCOL
X  htab->collcnt = 0;
X#endif
X  htab->symcount = 0;
X
X  /* set hashlist all zeros, take care of alignment */
X  lhash = (long *)htab->hashtb;
X  ltimes = (htab->hsize*sizeof (Hashent))/sizeof (long);
X  ctimes = (htab->hsize*sizeof (Hashent))%sizeof (long);
X  for (i=0; i < ltimes; i++)
X    *lhash++ = lnull;
X  chash = (char *)lhash;
X  for (i=0; i < ctimes; i++)
X    *chash++ = '\0';
X/*
X * End of hashtable initialization.
X */
X}
X
Xchar *hashsym (htab, symbol, symval) Hash *htab; char *symbol, *symval; {
X/*
X * put entry into hashtable. Only called, if symbol hasn't been found in 
X * hashtable. Function returns pointer to the symbol-string and sets
X * external variable cur_symval to corresponding symval.
X */
X  int symindex;
X  Hashent *new, *curptr;
X
X  htab->symcount++;
X  symindex = htab->fhash (htab, symbol);
X  if (!htab->hashtb[symindex].symbol[0]) { /* found entry is not used yet */
X    strcpy (htab->hashtb[symindex].symbol, symbol);
X    strcpy (htab->hashtb[symindex].symval, symval);
X    htab->hashtb[symindex].next = NULL;
X    htab->cur_symval = htab->hashtb[symindex].symval;
X    return htab->hashtb[symindex].symbol;
X  }
X  else {    /* oh boy - a collision! */
X#ifdef CCOLL
X    htab->collcnt++;
X    fprintf (stderr, "%d'th hash-collision.\n", htab->collcnt);
X#endif
X    new = (Hashent*)malloc (sizeof (Hashent));
X    strcpy (new->symbol, symbol);
X    strcpy (new->symval, symval);
X    new->next = NULL;
X    curptr = &htab->hashtb[symindex];
X    while (curptr->next) curptr = curptr->next;
X    curptr->next = new;
X    htab->cur_symval = new->symval;
X    return new->symbol;
X  } /* endif */
X} /* end symhash */
X
Xint fhash (htab, hstr) Hash *htab; char *hstr; {
X  register int lhstr, hval = 0, i;
X
X  lhstr = strlen (hstr);
X  for (i = 0; i < lhstr; i++)
X    hval = hval + i*hstr[i];
X  return hval%htab->hsize;
X}
X
Xchar *symlookup (htab, symbol) Hash *htab; char *symbol; {
X/* 
X * Function searches htab for an entry with the given name symbol.
X * If such an entry exists, a pointer to the symbol string is returned
X * and the external variable cur_symval is set to the corresponding
X * symbolvalue
X */
X  int where;
X  Hashent *targ;
X
X  where = htab->fhash (htab, symbol);
X  if (htab->hashtb[where].symbol[0]) { /* well, we found at least something */
X    if (!strcmp (symbol, htab->hashtb[where].symbol)) {  /* found it ? */
X      htab->cur_symval = htab->hashtb[where].symval;
X      return htab->hashtb[where].symbol;
X    }
X    else {  /* maybe it is somewhere down the gully */
X      targ = &htab->hashtb[where];
X      while (targ->next) {
X	targ = targ->next;
X	if (!strcmp (targ->symbol, symbol)) {
X	  htab->cur_symval = targ->symval;
X	  return targ->symbol;
X	}
X      }
X    }
X  }
X  /* when we come to this point, the symbol hasn't been known */
X  htab->cur_symval = NULL;
X  return NULL;
X}
X
Xchar *cur_symval (htab) Hash *htab; {
X  return htab->cur_symval;
X}
X
Xdestroy_htab (htab) Hash *htab; {
X  free (htab->hashtb);
X}
X
Xdumphtb (htab) Hash *htab; {
X  extern FILE *yyout;
X  register int i;
X  register Hashent *h;
X
X#ifdef CCOLL
X  fprintf (yyout, "Hash-collision statistics:\n");
X  fprintf (yyout, "Table-size: %d\tNo. of symbols: %d\tCollisions: %d\n",
X	   htab->hsize, htab->symcount, htab->collcnt);
X#endif
X
X  for (i = 0; i < htab->hsize; i++) {
X    if (htab->hashtb[i].symbol[0]) {
X      h = &htab->hashtb[i];
X      while (h) {
X	fprintf (yyout, "symbol: %s", h->symbol);
X	if (h->symval[0])
X	  fprintf (yyout, ", value: %s.\n", h->symval);
X	else
X	  fprintf (yyout, " -- no value.\n");
X	h = h->next;
X      }
X    }
X    else fprintf (yyout, "empty hastable-entry.\n");
X  }
X}
X
Xgetfsize (fil) FILE *fil; {
X  struct stat buf;
X
X  if (fil == stdin) {
X    return DEFHSIZE;
X  }
X  else {
X    if (fstat (fileno (fil), &buf) == -1) {
X      perror ("file should be accessible");
X      exit (1);
X    }
X    return (int)buf.st_size;
X  }
X}
END_OF_FILE
if test 6107 -ne `wc -c <'src/misc/hash.c'`; then
    echo shar: \"'src/misc/hash.c'\" unpacked with wrong size!
fi
# end of 'src/misc/hash.c'
fi
if test -f 'src/vc/save.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/vc/save.c'\"
else
echo shar: Extracting \"'src/vc/save.c'\" \(6983 characters\)
sed "s/^X//" >'src/vc/save.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *AFSid = "$Header: save.c[3.15] Thu Feb 23 18:13:53 1989 axel@coma published $";
X#ifdef CFFLGS
Xstatic char *ConfFlg = CFFLGS;
X	/* should be defined from within Makefile */
X#endif
X#endif
X/*
X * Log for /u/shape/dist-tape/src/vc/save.c[3.8]
X * 	Thu Feb 23 18:13:53 1989 axel@coma published $
X *  --- empty log message ---
X *  save.c[3.11] Thu Feb 23 18:13:53 1989 axel@coma published $
X *  --- empty log message ---
X *  save.c[3.12] Thu Feb 23 18:13:53 1989 axel@coma save $
X *  --- empty log message ---
X *  save.c[3.13] Thu Feb 23 18:13:53 1989 axel@coma save $
X *  --- empty log message ---
X *  save.c[3.14] Thu Feb 23 18:13:53 1989 axel@coma save $
X *  --- empty log message ---
X *  save.c[3.15] Thu Feb 23 18:13:53 1989 axel@coma published $
X *  --- empty log message ---
X */
X
X#include <signal.h>
X#include <stdio.h>
X#include <ctype.h>
X#include <strings.h>
X#include "ParseArgs.h"
X#include "save.h"
X#include "project.h"
X
Xchar *progname, vcomment[1024], tfname[MAXNAMLEN], atr_fname[MAXNAMLEN],
X  symname[MAXNAMLEN], projname[80];
Xint newvnum;
X
X/* forward decls for option handlers */
Xextern handle_R_switch ();
Xextern handle_f_switch ();
Xextern handle_q_switch ();
Xextern handle_u_switch ();
Xextern handle_a_opt ();
Xextern handle_m_opt ();
Xextern handle_n_opt ();
Xextern handle_p_opt ();
Xextern handle_svnum_opt ();
Xextern handle_t_opt ();
Xextern usage ();
X
Xunsigned int options;
X
XOptDesc argdesc[] = {
X  { "version", OPT_IS_SWITCH, handle_R_switch },
X  { "f", OPT_IS_SWITCH, handle_f_switch },
X  { "q", OPT_IS_SWITCH, handle_q_switch },
X  { "u", OPT_IS_SWITCH, handle_u_switch },
X  { "unlock", OPT_IS_SWITCH, handle_u_switch },
X  { "a", OPT_HAS_ARG, handle_a_opt }, 
X  { "m", OPT_HAS_ARG, handle_m_opt }, 
X  { "n", OPT_HAS_ARG, handle_n_opt }, 
X  { "p", OPT_HAS_ARG, handle_p_opt }, 
X  { "setvnum", OPT_HAS_ARG, handle_svnum_opt },
X  { "t", OPT_HAS_ARG, handle_t_opt },
X  { "h", OPT_IS_SWITCH, usage },
X  { "?", OPT_HAS_ARG, usage },
X  { (char *)  NULL, NULL, NULL }
X};
X
Xstruct Transaction ThisTransaction;
Xint nfnms;
X
Xmain (ac, av) char **av; {
X  register int i;
X  int nac, rc = 0;
X  char projname[80], **nav, messg[80], *es, *getenv(), *version();
X  Project pdesc;
X
X  if (!rindex (av[0], '/')) progname = av[0];
X  else progname = rindex (av[0], '/') + 1;
X  /* make prog-name available to entire program */
X
X  if (ac < 2) {
X    usage ();
X    exit (1);
X  }
X
X  if (isupper(progname[0])) options |= NEWGEN;
X  if (strcmp (progname+1, SAVE)) /* check from 2nd char onwards */
X    options |= SUBMIT;
X  if (ParseArgs (ac, av, &nac, &nav, argdesc)) {
X    usage ();
X  }
X    
X  if (!(options & ATTRDEF)) {
X    es = getenv (SVATTR);
X    if ((es) && (es[0] != '\0')) {
X      options |= ATTRDEF;
X      (void)strcpy (atr_fname, es);
X    }
X  }
X
X  if (GetProject (projname, &pdesc) < 0) {
X    (void)sprintf (messg, "%s %s", EINVALPROJ, projname);
X    logmsg (messg);
X    exit (1);
X  }
X
X  CatchSigs ();
X  nfnms = nac;
X  ThisTransaction.tr_rc = 0;
X  for (i = 0; i < nfnms; i++) {
X    if (!setjmp (ThisTransaction.tr_env)) {
X      ThisTransaction.tr_seqno = i;
X      (void)strcpy (ThisTransaction.tr_fname, nav[i]);
X      ThisTransaction.tr_done = FALSE;
X      SaveAFile (nav[i], &pdesc);
X    }
X    else { /* ThisTransaction was aborted */
X      rc += ThisTransaction.tr_rc;
X    }
X  }
X  logmsg ("done.");
X  return (rc);
X}
X
XSfunc_t interrupt_action () { /* is executed by appropriate signal handler */
X  char messg[80];
X  int mask = sigblock (SIGINT);
X  
X  if ((nfnms - ThisTransaction.tr_seqno) > 1) { 
X    (void)sprintf (messg, "\ncompletely stop saving (%d files unsaved) ?", 
X	     nfnms - ThisTransaction.tr_seqno);
X    if (ask_confirm (messg, "no")) {
X      if (ThisTransaction.tr_done) {
X	(void)sprintf (messg, "\ntoo late, %s already saved", 
X		 ThisTransaction.tr_fname);
X	logmsg (messg);
X	return; /* continue where we've been interrupted */
X      }
X      (void)sprintf (messg, "%s not saved", ThisTransaction.tr_fname);
X      logmsg (messg);
X      (void)sigsetmask (mask);
X      longjmp (ThisTransaction.tr_env, 1);
X    }
X    else {
X      (void)sprintf (messg, "%s not saved", ThisTransaction.tr_fname);
X      logmsg (messg);
X      exit (1);
X    }
X  }
X  else {
X    (void)sprintf (messg, "\n%s not saved", ThisTransaction.tr_fname);
X    logmsg (messg);
X    exit (1);
X  }
X}
X
Xlogmsg (msg) char *msg; {
X  if (!(options & QUIETPLEASE)) {
X    fprintf (stdout, "%s\n", msg);
X  }
X}
X
Xlogerr (msg) char *msg; {
X  fprintf (stderr, "%s: %s\n", progname, msg);
X}
X
X/*ARGSUSED*/
Xhandle_R_switch (o, a) char *o, *a; {
X  printf ("This is %s version %s.\n", progname, version());
X  printf ("AFS version %s.\n", af_version());
X  exit (0);
X}
X
X/*ARGSUSED*/
Xhandle_a_opt (o, a) char *o, *a; {
X  options |= ATTRDEF;
X  (void)strcpy (atr_fname, a);
X  return 0;
X}
X
X/*ARGSUSED*/
Xhandle_f_switch (o, a) char *o, *a; {
X  options |= FORCE;
X  return 0;
X}
X
X/*ARGSUSED*/
Xhandle_m_opt (o, a) char *o, *a; {
X  if (!(options & TXTFSET)) {
X    options |= MSGSET;
X    (void)strcpy (vcomment, a);
X    return 0;
X  }
X  return 0;
X}
X
X/*ARGSUSED*/
Xhandle_n_opt (o, a) char *o, *a; {
X  if (a && a[0]) {
X    options |= SYMNSET;
X    (void)strcpy (symname, a);
X  }
X  return 0;
X}
X
X/*ARGSUSED*/
Xhandle_q_switch (o, a) char *o, *a; {
X  options |= QUIETPLEASE;
X  return 0;
X}
X
X/*ARGSUSED*/
Xhandle_p_opt (o, a) char *o, *a; {
X  options |= OTHERPROJ;
X  (void)strcpy (projname, a);
X  return 0;
X}
X
X/*ARGSUSED*/
Xhandle_svnum_opt (o, a) char *o, *a; {
X  char messg[80];
X  if (!(newvnum = mkvno (a))) {
X    (void)sprintf (messg, "bad version number \"%s\"", a);
X    logerr (messg);
X    return 1;
X  }
X  options |= SETVNUM;
X  return 0;
X}
X
X/*ARGSUSED*/
Xhandle_t_opt (o, a) char *o, *a; {
X  if (options & MSGSET) {
X    options &= ~MSGSET;
X  }
X  options |= TXTFSET;
X  (void)strcpy (tfname, a);
X  return 0;
X}
X
X/*ARGSUSED*/
Xhandle_u_switch (o, a) char *o, *a; {
X  options |= LCKGIVEUP;
X  return 0;
X}
X
Xusage () {
X  pa_ShortUsage (progname, argdesc, "files ...");
X  exit (1);
X}
X
END_OF_FILE
if test 6983 -ne `wc -c <'src/vc/save.c'`; then
    echo shar: \"'src/vc/save.c'\" unpacked with wrong size!
fi
# end of 'src/vc/save.c'
fi
if test -f 'src/vc/vc_call.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/vc/vc_call.c'\"
else
echo shar: Extracting \"'src/vc/vc_call.c'\" \(5928 characters\)
sed "s/^X//" >'src/vc/vc_call.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *AFSid = "$Header: vc_call.c[1.10] Thu Feb 23 18:14:28 1989 axel@coma published $";
X#ifdef CFFLGS
Xstatic char *ConfFlg = CFFLGS;
X	/* should be defined from within Makefile */
X#endif
X#endif
X/*
X * Log for /u/shape/dist-tape/src/vc/vc_call.c[1.3]
X * 	Thu Feb 23 18:14:28 1989 axel@coma published $
X *  --- empty log message ---
X *  vc_call.c[1.6] Thu Feb 23 18:14:28 1989 axel@coma published $
X *  --- empty log message ---
X *  vc_call.c[1.7] Thu Feb 23 18:14:28 1989 axel@coma save $
X *  --- empty log message ---
X *  vc_call.c[1.8] Thu Feb 23 18:14:28 1989 axel@coma save $
X *  --- empty log message ---
X *  vc_call.c[1.9] Thu Feb 23 18:14:28 1989 axel@coma save $
X *  --- empty log message ---
X *  vc_call.c[1.10] Thu Feb 23 18:14:28 1989 axel@coma published $
X *  --- empty log message ---
X */
X
X#include <stdio.h>
X#include <strings.h>
X#include <signal.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <sys/wait.h>
X#ifndef MAXNAMLEN
X#include <sys/dir.h>
X#endif MAXNAMLEN
X#include "afsapp.h"
X#include <sys/resource.h>
X
Xextern char *malloc();
Xextern char *FindProgram();
X
X/**/
Xint call (status, this_program, argvec)
X     union wait *status;
X     char *this_program;
X     char **argvec;
X{
X  int pid, offered_pid;
X  extern char **environ;
X
X  if (!rindex (this_program, '/')) {
X    if ((this_program = FindProgram (this_program)) == NULL)
X      return 0;
X  }
X  
X  if (!FileExecutable (this_program))
X    return 0;
X  
X  pid = vfork ();
X
X  if (pid == -1) {
X    logerr ("Can't fork");
X    return 0;
X  }
X
X  if (!pid) {
X    /* child */
X    /* close open files ? */
X    execve (this_program, argvec, environ);
X    logerr ("Can't exec");
X    _exit (1);
X    return 1;			/* to make lint happy */
X  }
X  else {
X    /* parent */
X    /* here we must redefine actual interrupt handler. */
X    while ( ((offered_pid = wait (status)) != pid) && (offered_pid != -1))
X      ;				/* nothing to do */
X
X    
X    if (offered_pid == -1) {
X      return 0;
X    }
X    /* here we must reconstruct old sighandl */
X    if (status->w_status)
X      return 0;
X    else
X      return 1;
X  }
X/*NOTREACHED*/
X  return 1;
X}
X
X/**/
Xint call_editor (editor, file, contents, newcontents)
X     char *editor, *file, *contents;
X/*     unsigned long *newcontents; */
X     char **newcontents;
X{
X  /*
X   * Calls editor "editor" with file "file" and returns its
X   * contents after the editor session in "newcontents".
X   * Return value is the length of the new text.
X   *
X   * On failure, 0 is returned to indicate the error. newcontents
X   * is *not* updated and points to nowhere. On error the file
X   * will be removed.
X   *
X   * If "contents" points to a valid text, this text is put (not appended)
X   * into the temporary file before editor starts. Text must be
X   * NULL terminated, otherwise strange things will happen...
X   */
X  
X  FILE *fid;
X  char *new;
X  char cmd[MAXNAMLEN];
X  int length;
X  union wait status;
X  struct stat sbuf;
X  char buf[100];
X  char *argvec[10];
X
X  *newcontents = NULL;		/* don't get confused on error. */
X
X  Register (file, TYPEF);
X  if ((fid = fopen (file, "w")) == NULL) { /* create a file */
X    (void)sprintf (buf,"Can't open temporary file %s.", file);
X    UnRegister (file, TYPEF);
X    logerr (buf);
X    return -1;
X  }
X
X  if (contents && *contents) {
X    length = strlen (contents);
X    
X    if (fwrite (contents, sizeof (char), length, fid) != length) {
X      (void)sprintf (buf, "lost bytes while writing to %s.", file);
X      logerr (buf);
X      (void)fclose (fid);
X      RemoveFile (file);
X      UnRegister (file, TYPEF);
X      return -1;
X    }
X  }
X  
X  (void)fclose (fid);
X  
X  (void)sprintf (cmd, "%s %s", editor, file);
X  (void)sprintf (buf, "starting up %s...", cmd);
X  logmsg (buf);
X
X  argvec[0] = editor;
X  argvec[1] = file;
X  argvec[2] = (char *) NULL;
X
X  /*  if (retcode = system (cmd)) { */
X  /*VARARGS2*/
X  if (! call (&status, editor, argvec)) {
X    (void)sprintf (buf, "Editor %s exited abnormally.", editor);
X    logerr (buf);
X    RemoveFile (file);
X    UnRegister (file, TYPEF);
X    return -1;
X  }
X
X  if (stat (file, &sbuf) == -1) {
X    (void)sprintf (buf,"Can't stat temporary file %s.", file);
X    logerr (buf);
X    return -1;
X  }
X    
X  if ((fid = fopen (file, "r")) == NULL) {
X    (void)sprintf (buf,"Can't reopen temporary file %s.", file);
X    logerr (buf);
X    RemoveFile (file);
X    UnRegister (file, TYPEF);
X    return -1;
X  }
X  RemoveFile (file);
X  UnRegister (file, TYPEF);
X  length = sbuf.st_size;
X  if ((new = malloc ((unsigned)(sizeof (char) * (length + 1)))) == NULL) {
X    logerr ("Can't malloc for new");
X    (void)fclose (fid);
X    return -1;
X  }
X  
X  if (!fread (new, sizeof (char), length, fid)) {
X    (void)sprintf (buf, "lost bytes while reading from %s.", file);
X    logerr (buf);
X    (void)fclose (fid);
X    return -1;
X  }
X  new[length] = NULL;
X
X  (void)fclose (fid);
X  *newcontents = new;
X  return length;
X}
END_OF_FILE
if test 5928 -ne `wc -c <'src/vc/vc_call.c'`; then
    echo shar: \"'src/vc/vc_call.c'\" unpacked with wrong size!
fi
# end of 'src/vc/vc_call.c'
fi
if test -f 'src/vfind/at_misc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/vfind/at_misc.c'\"
else
echo shar: Extracting \"'src/vfind/at_misc.c'\" \(6781 characters\)
sed "s/^X//" >'src/vfind/at_misc.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X/*  LAST EDIT: Mon Feb 20 15:43:04 1989 by Uli Pralle (coma!uli)  */
X/*
X * at_misc.c
X */
X#ifndef lint
Xstatic char *AFSid = "$Header: at_misc.c[1.2] Tue Feb 21 20:22:58 1989 uli@coma published $";
Xstatic char *Objfile = "at_misc.c[1.2] published";
X#ifdef CFFLGS
X  static char *Cflags = CFFLGS;
X#endif
X#endif
X/*
X * Log for /u/shape/dist-tape/src/vfind/at_misc.c[1.2]
X * 	Tue Feb 21 20:22:58 1989 uli@coma published $
X *  	* This file contains many AFS utilities that makes life easier.
X *  	  This comes with atk.h.
X *  
X *  
X */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <sys/param.h>
X#include <time.h>
X#include <strings.h>
X
X#include <afs.h>
X
Xextern char *malloc();
Xstatic char at_filemode[12];
X
Xchar *at_getmode (attr)
X     Af_attrs *attr;
X{
X  /* This function should return a capital 'L' in the file-class field */
X  /* to indicate a *locked* version. Maybe optional. Instead of Ownername */
X  /* the name of the locker is to be printed. */
X  ushort mode;
X
X  mode = attr->af_mode;
X  (void) sprintf (at_filemode, " %c%c%c%c%c%c%c%c%c",
X		  (mode & S_IREAD) ? 'r' : '-',
X		  (mode & S_IWRITE) ? 'w' : '-',
X		  (mode & S_IEXEC) ? 'x' : '-',
X		  (mode & (S_IREAD >> 3)) ? 'r' : '-',
X		  (mode & (S_IWRITE >> 3)) ? 'w' : '-',
X		  (mode & (S_IEXEC >> 3)) ? 'x' : '-',
X		  (mode & (S_IREAD >> 6)) ? 'r' : '-',
X		  (mode & (S_IWRITE >> 6)) ? 'w' : '-',
X		  (mode & (S_IEXEC >> 6)) ? 'x' : '-'
X		  );
X
X  switch (mode & S_IFMT) {
X  case S_IFDIR:
X    at_filemode[0] =  'd';
X    break;
X  case S_IFCHR:
X    at_filemode[0] = 'c';
X    break;
X  case S_IFBLK:
X    at_filemode[0] = 'b';
X    break;
X  case S_IFREG:
X    at_filemode[0] = '-';
X    break;
X  case S_IFLNK:
X    at_filemode[0] = 'l';
X    break;
X  case S_IFSOCK:
X    at_filemode[0] = 's';
X    break;
X  }
X  
X  if (mode & S_ISUID)
X    at_filemode[1] = 's';
X  if (mode & S_ISGID)
X    at_filemode[6] = 's';
X  if (mode & S_ISVTX)
X    at_filemode[9] = 't';
X
X  return at_filemode;
X}
X
Xchar *
X#ifdef __STDC__
X  at_symbfiletype (u_short mode, int afstate)
X#else
Xsymbfiletype (mode, afstate) u_short mode; int afstate;
X#endif
X{
X  if (afstate == AF_NOSTATE) return "$"; /* derived object */
X  switch (mode & S_IFMT) {
X  case S_IFDIR:
X    return "/";
X  case S_IFLNK:
X    return "@";
X  case S_IFSOCK:
X    return "=";
X  default:
X    if ((mode & S_IEXEC) || (mode & (S_IEXEC >> 3)) || (mode & (S_IEXEC >> 6)))
X      return "*";
X    else
X      return "";
X  }
X}
X
Xint at_string2state (string)
X     char *string;
X{
X  if (!strcmp(string,"busy"))
X    return AF_BUSY;
X  else if (!strcmp(string,"save"))
X    return AF_SAVED;
X  else if (!strcmp(string,"proposed"))
X    return AF_PROPOSED;
X  else if (!strcmp(string,"published"))
X    return AF_PUBLISHED;
X  else if (!strcmp(string,"accessed"))
X    return AF_ACCESSED;
X  else if (!strcmp(string,"frozen"))
X    return AF_FROZEN;
X  else return AF_NOSTATE;
X}
X
Xchar *at_getversstate (attr, verbose) Af_attrs *attr; int verbose;
X{
X  int state;
X
X  state = attr->af_state;
X  
X  switch (state) {
X  case AF_BUSY:
X    return verbose ? "[busy]" : "b";
X  case AF_SAVED:
X    return verbose ? "[save]" : "s";
X  case AF_PROPOSED:
X    return verbose ? "[prop]" : "p";
X  case AF_PUBLISHED:
X    return verbose ? "[publ]" : "P";
X  case AF_ACCESSED:
X    return verbose ? "[acce]" : "a";
X  case AF_FROZEN:
X    return verbose ? "[froz]" : "f";
X  default:
X    return verbose ? "[drvd]" : "$"; /* binary pool ? */
X  }
X}
X
Xstatic char boundversion[2*MAXNAMLEN];
X
Xchar *at_getbndvers (attr)
X     Af_attrs *attr;     
X{
X  char *path, *name, *type;
X  int gen, rev;
X  
X  path = attr->af_syspath;
X  name = attr->af_name;
X  type = attr->af_type;
X  gen = attr->af_gen;
X  rev = attr->af_rev;
X  
X  if (gen == AF_BUSYVERS && rev == AF_BUSYVERS) {
X    (void) sprintf (boundversion, "%s%s%s%s%s",
X		    (path[0]) ? path : "",
X		    (path[0]) ? "/" : "",
X		    name,
X		    (type[0]) ? "." : "",
X		    (type[0]) ? type : "");
X  }
X  else {
X    (void) sprintf (boundversion, "%s%s%s%s%s[%d.%d]",
X		    (path[0]) ? path : "",
X		    (path[0]) ? "/" : "",
X		    name,
X		    (type[0]) ? "." : "",
X		    (type[0]) ? type : "",
X		    gen, rev);
X  }
X
X  return boundversion;
X}
X
Xstatic char at_filename[MAXNAMLEN+1];
X
Xchar *at_getfilename (attr)
X     Af_attrs *attr;     
X{
X  (void) sprintf (at_filename, "%s%s%s", attr->af_name,
X		  attr->af_type[0] ? "." : "",
X		  attr->af_type[0] ? attr->af_type : "" );
X  
X  return at_filename;
X}
X    
Xchar *at_getdate (attr)
X     Af_attrs *attr;
X{
X  time_t date;
X  char *tmp_time;
X  extern char *ctime();
X
X  date = (attr->af_state == AF_BUSY ? attr->af_mtime : attr->af_stime);
X  tmp_time = ctime(&date);
X
X  /* Format is "Sun Sep 16 01:03:52 1973\n\0" */
X  tmp_time = tmp_time + 4;
X  tmp_time[20] = '\0';
X  return tmp_time;
X}
X
Xstatic char at_userandhost[20];
X
Xchar *at_getuser(user) 
X     Af_user *user;
X{
X  char tmp[20];
X  
X  tmp[0] = '\0';
X  (void) strncat (tmp, user->af_username, 8);
X  (void) strcat (tmp, "@");
X  (void) strncat (tmp, user->af_userhost, 8);
X  (void) sprintf (at_userandhost, "%-16s", tmp);
X  return at_userandhost;
X}
X
Xint at_matchuda (attrbuf, uda)
X     Af_attrs *attrbuf;
X     char *uda;
X{
X  /* Returns 1 if attrbuf has an uda uda, otherwise 0. */
X
X  char *v, *cp;
X  char **udattrs = attrbuf->af_udattrs;
X  int ul, vl = 0;
X
X  if (!uda) return 0;
X
X  if (v = index(uda, '='))
X    vl = strlen(++v);
X    
X  ul = strlen(uda) - vl - 1;
X
X  while (udattrs && *udattrs)
X    if (!strncmp(uda, *udattrs, ul)) {
X      cp = (*udattrs)+ul;
X      if (*cp == '\0' && !v) return 1;
X      if (*cp == '=' && !v)
X	return 1;
X      else cp++;
X      
X      while (cp) {
X	if (*cp == '\n')
X	  cp++;
X	if (!strncmp(cp, v, vl))
X	  return 1;
X	else
X	  if (cp = index(cp , '\n'))
X	    cp++;
X	  else
X	    return 0;
X      }
X    }
X    else
X      udattrs++;
X
X  return 0;
X}
END_OF_FILE
if test 6781 -ne `wc -c <'src/vfind/at_misc.c'`; then
    echo shar: \"'src/vfind/at_misc.c'\" unpacked with wrong size!
fi
# end of 'src/vfind/at_misc.c'
fi
echo shar: End of archive 7 \(of 33\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
