Subject:  v19i018:  A software configuration management system, Part05/33
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Axel Mahler <unido!coma!axel>
Posting-number: Volume 19, Issue 18
Archive-name: shape/part05



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 33)."
# Contents:  man/man3/afmisc.3 src/afs/Makefile.distribution
#   src/afs/afkeys.c src/afs/lcs.gedc.c src/shape/Shapefile
#   src/shape/select.c src/shape/vpath.c src/vc/deps
#   src/vc/vadm_delete.c src/vc/vc_keyboardIo.c src/vfind/Shapefile
#   tutorial/tutorial.ms
# Wrapped by rsalz@papaya.bbn.com on Thu Jun  1 19:26:52 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'man/man3/afmisc.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/man3/afmisc.3'\"
else
echo shar: Extracting \"'man/man3/afmisc.3'\" \(4025 characters\)
sed "s/^X//" >'man/man3/afmisc.3' <<'END_OF_FILE'
X...
X... Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X...  and U. Pralle
X... 
X... This software is published on an as-is basis. There is ABSOLUTELY NO
X... WARRANTY for any part of this software to work correctly or as described
X... in the manuals. We do not accept any liability for any kind of damage
X... caused by use of this software, such as loss of data, time, money, or 
X... effort.
X... 
X... Permission is granted to use, copy, modify, or distribute any part of
X... this software as long as this is done without asking for charge, and
X... provided that this copyright notice is retained as part of the source
X... files. You may charge a distribution fee for the physical act of
X... transferring a copy, and you may at your option offer warranty
X... protection in exchange for a fee.
X... 
X... Direct questions to: Tech. Univ. Berlin
X... 		     Wilfried Koch
X... 		     Sekr. FR 5-6 
X... 		     Franklinstr. 28/29
X... 		     D-1000 Berlin 10, West Germany
X... 
X... 		     Tel: +49-30-314-22972
X... 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X... 
X.TH AF_MISC 3 "" \n(dy.\n(mo.\n(yr
X.SH NAME
Xaf_misc \(em miscellaneous AFS-functions
X.SH SYNOPSIS
X\fBchar *af_afname (path)
X.br
Xchar	*path;
X.sp
Xchar *af_afpath (path)
X.br
Xchar	*path;
X.sp
Xchar *af_aftype (path)
X.br
Xchar	*path;
X.sp
Xchar *af_access (path, name, type, mode)
X.br
Xchar	*path, *name, *type;
X.br
Xint	mode;
X.sp
Xaf_setarchpath (path)
X.br
Xchar	*path;
X.sp
Xaf_cleanup ()
X.sp
Xaf_perror (string)
X.br
Xchar	*string;
X.sp
Xchar *af_version()
X.SH DESCRIPTION
XThe functions \fIaf_afname, af_afpath\fR and \fIaf_aftype\fR
Xextract name, syspath or type from a given (operating
Xsystem dependent) file identification.
XIn an \s-1UNIX\s+1 environment, a given pathname of the form
X\fC/usr/lib/libafs.a\fR
Xleads to the afname \fClibafs\fR, afpath \fC/usr/lib\fR and aftype \fCa\fR.
XIf no path (eg. \fCotto.c\fR), or no type
X(eg. \fC/usr/hugo/Makefile\fR) is given, the corresponding routine returns an
Xempty string.
XA period as first character in a filename is always
Xconsidered to be part of the name (e.g. \fC.cshrc\fR has the name
X\fC.cshrc\fR and an empty type string).
X\(lq\fC.\fR\(rq and \(lq\fC..\fR\(rq are recognized as names.
XArchive file extensions and AFS-specific path extensions are stripped from
Xthe resulting name resp. pathname.
X.br
X\fBNote:\fR \fIaf_afname, af_afpath\fR and \fIaf_aftype\fR use static
Xmemory for the returned results.
XSubsequent calls of the same function overwrite former results.
X.PP
X\fIAf_access\fR determines the existence of an line of development.
XIf any ASO (any version) with the given \fIpath\fR, \fIname\fR
Xand \fItype\fR attributes exists, af_access returns zero, otherwise \-1.
XThe \fImode\fR argument can either be \fIAF_SOURCE\fR indicating that
Xonly source objects shall be searched or \fIAF_DERIVED\fR which means that
Xonly the derived object pool shall be searched for existence
Xof a matching ASO.
X.PP
X\fIAf_setarchpath\fR is used to define the location of the AFS 
Xarchive files. If no path is set, the archive files are stored
Xin a subdirectory called \fCAFS\fR, relative to the directory
Xwhere corresponding busy version resides.
XIf a nil-pointer is given as \fIpath\fR-argument, the former setting
Xof the global archive path is cleared.
X.PP
X\fIAf_cleanup\fR serves as cleanup routine upon premature termination
Xof an AFS application. It removes temporary files and frees all allocated
Xmemory.
X.PP
X\fIAf_perror\fR produces a short error message on the standard error file
Xof the form described in \fIperror(3)\fR.
XIf the last error encountered during an AFS-application was an AFS-specific
Xerror, a corresponding message is generated, otherwise \fIaf_perror\fR
Xcalls \fIperror(3)\fR.
X.PP
X\fIAf_version\fR returns a string that names the version and the
Xcreator of the currently used AFS library.
X.SH SEE ALSO
Xintro(2), af_intro(3), perror(3), free(3)
X.SH DIAGNOSTICS
XUpon error, af_afname, af_afpath and af_aftype returned a nil pointer
Xand \fIaf_errno\fR is set to the corresponding error number.
X
X
END_OF_FILE
if test 4025 -ne `wc -c <'man/man3/afmisc.3'`; then
    echo shar: \"'man/man3/afmisc.3'\" unpacked with wrong size!
fi
# end of 'man/man3/afmisc.3'
fi
if test -f 'src/afs/Makefile.distribution' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/afs/Makefile.distribution'\"
else
echo shar: Extracting \"'src/afs/Makefile.distribution'\" \(4290 characters\)
sed "s/^X//" >'src/afs/Makefile.distribution' <<'END_OF_FILE'
X#
X# Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X#  and U. Pralle
X# 
X# This software is published on an as-is basis. There is ABSOLUTELY NO
X# WARRANTY for any part of this software to work correctly or as described
X# in the manuals. We do not accept any liability for any kind of damage
X# caused by use of this software, such as loss of data, time, money, or effort.
X# 
X# Permission is granted to use, copy, modify, or distribute any part of
X# this software as long as this is done without asking for charge, and
X# provided that this copyright notice is retained as part of the source
X# files. You may charge a distribution fee for the physical act of
X# transferring a copy, and you may at your option offer warranty
X# protection in exchange for a fee.
X# 
X# Direct questions to: Tech. Univ. Berlin
X# 		     Wilfried Koch
X# 		     Sekr. FR 5-6 
X# 		     Franklinstr. 28/29
X# 		     D-1000 Berlin 10, West Germany
X# 
X# 		     Tel: +49-30-314-22972
X# 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X# 
X#
X#  Makefile.distribution for AFS
X#
X
XSOURCE = \
X	afarchive.c afenviron.c aflib.c afvers.c afdelta.c afkeys.c\
X	afstates.c afsattrs.c afretr.c afsysc.c affiles.c afcattrs.c\
X	afsets.c afhash.c afcompar.c afbpool.c afsymtab.c afstore.c\
X	aflock.c afsrepair.c
X
XDELTASOURCE = \
X	bsfd.c lcs.main.c lcs.cdlt.c lcs.gedc.c edcmd.h suffix.h predef.h
X
XINCLUDE = $(INCLUDEDIR)/afs.h $(INCLUDEDIR)/afsys.h afarchive.h typeconv.h
X
XCOMPONENTS = $(SOURCE) $(INCLUDE) afsrepair.h
X
XVERSION = af_version
X
XAFSOBJS = \
X	afarchive.o afenviron.o aflib.o afvers.o afdelta.o afkeys.o\
X	afstates.o afsattrs.o afretr.o afsysc.o affiles.o afcattrs.o\
X	afsets.o afhash.o afcompar.o afbpool.o afsymtab.o afstore.o\
X	aflock.o $(VERSION).o
X
XDELTALIB = bsfd.o lcs.cdlt.o lcs.gedc.o lcs.main.o
X
XTESTSOURCE = \
X	testmain.c testcall.c testfdes.c testkey.c testabuf.c testset.c\
X	testvar.c testshow.c test.h
X
XTESTOBJS = testmain.o testcall.o testshow.o testvar.o testkey.o testset.o\
X	testabuf.o testfdes.o
X
X#
X#  Product dependencies
X#
X
Xall: $(LIBDIR)/libafs.a afsrepair $(AFSDB) # macro AFSDB only set on coma
X
X$(LIBDIR)/libafs.a: $(AFSOBJS) $(DELTALIB) $(VERSION).o
X	@ar ruv $(LIBDIR)/libafs.a $(AFSOBJS) $(DELTALIB); \
X	ranlib $(LIBDIR)/libafs.a
X
X#
X# installation stuff
X#
X
Xinstallall: install installtest
X
Xinstall: $(LIBDIR)/libafs.a afsrepair\
X		 $(INSTALINCDIR)/afs.h $(INSTALINCDIR)/afsys.h
X	@-if [ "$(INSTALLIBDIR)" != "$(LIBDIR)" ]; then \
X	echo installing libafs.a in $(INSTALLIBDIR) ...; \
X	install -c -m 644 -o $(INSTALOWNER) -g $(INSTALGROUP)\
X		$(LIBDIR)/libafs.a $(INSTALLIBDIR); \
X	ranlib $(INSTALLIBDIR)/libafs.a; \
X	fi; \
X	echo installing afsrepair in $(INSTALDIR)/bin ...; \
X	install -c -m 755 -o $(INSTALOWNER) -g $(INSTALGROUP) afsrepair $(INSTALDIR)/bin
X	
X$(INSTALINCDIR)/afs.h: $(INCLUDEDIR)/afs.h
X	@-if [ "$(INSTALINCDIR)" != "$(INCLUDEDIR)" ]; then \
X	echo installing afs.h in $(INSTALINCDIR) ...; \
X	install -c -m 644 -o $(INSTALOWNER) -g $(INSTALGROUP) $(INCLUDEDIR)/afs.h $(INSTALINCDIR); \
X	fi
X
X$(INSTALINCDIR)/afsys.h: $(INCLUDEDIR)/afsys.h
X	@-if [ "$(INSTALINCDIR)" != "$(INCLUDEDIR)" ]; then \
X	echo installing afsys.h in $(INSTALINCDIR) ...; \
X	install -c -m 644 -o $(INSTALOWNER) -g $(INSTALGROUP) $(INCLUDEDIR)/afsys.h $(INSTALINCDIR); \
X	touch $(INSTALINCDIR)/afs.h; \
X	fi
X
X#
X# archive repair tool
X#
X
X$(AFSOBJS) $(TESTOBJS) afsrepair.o: $(INCLUDE)
X
Xafsrepair.o: afsrepair.h
X
Xafsrepair: afsrepair.o afsysc.o afsymtab.o afenviron.o afhash.o aflib.o\
X		af_version.o
X	$(CC) -o afsrepair $(LDFLAGS) afsrepair.o afsysc.o afsymtab.o\
X		afenviron.o afhash.o aflib.o af_version.o
X
X#
X# Test-environment for libafs.a (only on coma)
X#
X
Xinstalltest: $(TESTOBJS) afsdb
X	install -c -m 755 -o $(INSTALOWNER) -g $(INSTALGROUP) afsdb $(INSTALDIR)/bin
X
Xafsdb: $(TESTOBJS) $(AFSOBJS) $(DELTALIB)
X	$(CC) -o afsdb $(LDFLAGS) $(TESTOBJS) $(AFSOBJS) $(DELTALIB) $(CLIBS)
X
X$(TESTOBJS): test.h
X
X#
X# Miscellaneous stuff
X#
X
Xobjects : $(AFSOBJS) afsrepair.o
X
Xlint:
X	lint -DLINT -D$(SYSTEM) -I$(INCLUDEDIR) $(SOURCE)  
X
Xtags: $(SOURCE)
X	/usr/local/etags $(SOURCE)
X
Xxref: $(SOURCE)
X	/usr/ucb/ctags -w -x $(SOURCE) > xref
X
Xclean :
X	rm $(AFSOBJS)
X
Xtar:
X	retrv -fq $(VERSION).c; \
X	tar cvhf /tmp/afs.tar $(COMPONENTS) $(TESTSOURCE) Makefile\
X			 $(VERSION).c $(DELTASOURCE); \
X	rm -f $(VERSION).c
END_OF_FILE
if test 4290 -ne `wc -c <'src/afs/Makefile.distribution'`; then
    echo shar: \"'src/afs/Makefile.distribution'\" unpacked with wrong size!
fi
# end of 'src/afs/Makefile.distribution'
fi
if test -f 'src/afs/afkeys.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/afs/afkeys.c'\"
else
echo shar: Extracting \"'src/afs/afkeys.c'\" \(4153 characters\)
sed "s/^X//" >'src/afs/afkeys.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X/*
X *	Shape/AFS
X *
X *	afkeys.c -- handle revision keys
X *
X *	Author: Andreas Lampen, TU-Berlin (andy@coma.UUCP)
X *					  (andy@db0tui62.BITNET)
X *
X *	$Header: afkeys.c[1.3] Wed Feb 22 16:27:39 1989 andy@coma published $
X *
X *	EXPORT:
X *	af_buildkey -- build key from generation and revision
X *      af_gbuskey -- get key of busy version
X *      af_glastkey -- get key of last saved version
X *      af_gfreepos -- search free position in revlist
X *	af_keytest -- check plausibility of key
X */
X
X#include <stdio.h>
X
X#include "typeconv.h"
X#include "afsys.h"
X#include "afs.h"
X
X/*================================================================
X *	af_buildkey
X *
X *================================================================*/
X
XEXPORT af_buildkey (list, gen, rev, key)
X     Af_revlist *list;
X     int 	gen;
X     int	rev;
X     Af_key	*key; /* out */
X{
X  int i;
X  
X  key->af_ldes = list;
X  if (list->af_list[0].af_class & AF_VALID)
X    i = list->af_nrevs-1;
X  else
X    i = list->af_nrevs;
X
X  while (!((list->af_list[i].af_gen == gen) && (list->af_list[i].af_rev == rev)
X	 && (list->af_list[i].af_class & AF_VALID)))
X    {
X      if (i == 0)
X	SFAIL ("buildkey", "", AF_ENOREV, ERROR);
X      i--;
X    }
X  key->af_lpos = i;
X  return (AF_OK);
X}
X
X/*================================================================
X *	af_gbuskey
X *
X *================================================================*/
X
XEXPORT Af_key *af_gbuskey (list)
X     Af_revlist *list;
X{
X  static Af_key busykey;
X
X  busykey.af_ldes = list;
X  busykey.af_lpos = 0;
X  return (&busykey);
X}
X
X
X/*================================================================
X *	af_glastkey
X *
X *================================================================*/
X
XEXPORT Af_key *af_glastkey (list)
X     Af_revlist *list;
X{
X  int i;
X  static Af_key lastkey;
X
X  lastkey.af_ldes = list;
X  i = list->af_listlen-1;
X  while (!(list->af_list[i].af_class & AF_VALID))
X    {
X      if (i-- == 1)
X	return ((Af_key *)0);
X    }
X  lastkey.af_lpos = i;
X  return (&lastkey);
X}
X
X/*================================================================
X * af_gfreepos -- search space for new list entry
X *                preserve increasing order
X *
X *================================================================*/
X
XEXPORT af_gfreepos (list)
X     Af_revlist *list;
X{
X  int i;
X
X  i = list->af_listlen-1;
X  while (!(list->af_list[i].af_class & AF_VALID) && (i >= 0))
X    i--;
X
X  if (i == list->af_listlen-1)
X    return (ERROR);
X
X  if (!(list->af_list[i].af_class & AF_VALID) && (i == 0))
X    return (0);
X
X  return (i+1);
X}
X
X 
X/*================================================================
X *	af_keytest -- test plausibility of filekey
X *                    returnes TRUE (ERROR) if key is invalid,
X *                    otherwise FALSE (AF_OK).
X *
X *================================================================*/
X
XEXPORT af_keytest (key)
X     Af_key *key;
X{
X  if (key == (Af_key *)0)
X    return (ERROR);
X  if ((key->af_lpos < 0) || (key->af_lpos >= key->af_ldes->af_listlen))
X    return (ERROR);
X  if (VATTR(key).af_nlinks < 1)
X    return (ERROR);
X
X  return (AF_OK);
X}
X
END_OF_FILE
if test 4153 -ne `wc -c <'src/afs/afkeys.c'`; then
    echo shar: \"'src/afs/afkeys.c'\" unpacked with wrong size!
fi
# end of 'src/afs/afkeys.c'
fi
if test -f 'src/afs/lcs.gedc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/afs/lcs.gedc.c'\"
else
echo shar: Extracting \"'src/afs/lcs.gedc.c'\" \(4012 characters\)
sed "s/^X//" >'src/afs/lcs.gedc.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X
X/* ================================================== */
X/* ================================================== */
X/*                                                    */
X/* MODULE-NAME: gedc        KEY : ge                  */
X/*              = generate editor commands            */
X/* ORIGINAL                                           */
X/* AUTHOR : sibylle         DATE: 28/07/87            */
X/*                                                    */
X/* LAST UPDATE                                        */
X/* AUTHOR :                 DATE:                     */
X/*                                                    */
X/* VERSION: 1.6.2                                     */
X/*                                                    */
X/* ================================================== */
X/*                                                    */
X/* PURPOSE:                                           */
X/*                generation of editor commands;      */
X/*                writing them into the delta file    */
X/*                                                    */
X/* SPECIALITIES:                                      */
X/*                targetsize gets written into        */
X/*                deltafile                           */                       
X/*                                                    */
X/* EXCEPTIONS, ERRORS:                                */
X/*                none                                */
X/*                                                    */
X/* ================================================== */
X/*                                                    */
X/*
X * $Header: lcs.gedc.c[1.0] Wed Feb 22 16:14:22 1989 shape@coma save $
X */
X
X# include "predef.h"
X# include "typeconv.h"
X# include <stdio.h>
X# include "edcmd.h"
X
X
Xextern int fwrite();
Xextern int fclose();
Xextern FILE *fopen();
X
X
XLOCAL char *trg_str = NIL;
XLOCAL FILE *fdelta = (FILE *) NIL;
X
X
XLOCAL void write_cmd (ecmd, indx)
X     struct ed_cmd *ecmd;
X     long indx;
X{
X  long cmd_ind;
X  char *t_str = trg_str;
X  
X  cmd_ind = indx;
X  if (ecmd->cmd == MV)
X    {
X      (void) fwrite ((char *)ecmd, sizeof (*ecmd), 1, fdelta);
X      (void) fwrite ((char *)&cmd_ind, sizeof(cmd_ind), 1, fdelta);
X    }
X  else
X    {
X      (void) fwrite ((char *)ecmd, sizeof (*ecmd), 1, fdelta);
X      (void) fwrite ((t_str = (t_str + cmd_ind)), sizeof(char), (Size_t)ecmd->length, fdelta);
X    }
X
X  return;
X}
X
X
X
XEXPORT void ge_init (deltafile, targetstr)
X     char *deltafile, *targetstr;
X{
X  trg_str = targetstr;
X  fdelta  = fopen (deltafile, "w");
X  return;
X}
X
X
XEXPORT void ge_finit()
X{
X  (void) fclose (fdelta);
X  return;
X}
X
X
XEXPORT void ge_move (indx, length)
X     long indx, length;
X{
X  struct ed_cmd cmd;
X
X  cmd.cmd = MV;
X  cmd.length = length;
X  write_cmd (&cmd, indx);
X
X  return;
X}
X
X
XEXPORT void ge_add (indx, length)
X     long indx, length;
X{
X  struct ed_cmd cmd;
X
X  cmd.cmd = AD;
X  cmd.length = length;
X  write_cmd (&cmd, indx);
X  return;
X}
X
X
X
END_OF_FILE
if test 4012 -ne `wc -c <'src/afs/lcs.gedc.c'`; then
    echo shar: \"'src/afs/lcs.gedc.c'\" unpacked with wrong size!
fi
# end of 'src/afs/lcs.gedc.c'
fi
if test -f 'src/shape/Shapefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/shape/Shapefile'\"
else
echo shar: Extracting \"'src/shape/Shapefile'\" \(3789 characters\)
sed "s/^X//" >'src/shape/Shapefile' <<'END_OF_FILE'
X#
X# Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X#  and U. Pralle
X# 
X# This software is published on an as-is basis. There is ABSOLUTELY NO
X# WARRANTY for any part of this software to work correctly or as described
X# in the manuals. We do not accept any liability for any kind of damage
X# caused by use of this software, such as loss of data, time, money, or effort.
X# 
X# Permission is granted to use, copy, modify, or distribute any part of
X# this software as long as this is done without asking for charge, and
X# provided that this copyright notice is retained as part of the source
X# files. You may charge a distribution fee for the physical act of
X# transferring a copy, and you may at your option offer warranty
X# protection in exchange for a fee.
X# 
X# Direct questions to: Tech. Univ. Berlin
X# 		     Wilfried Koch
X# 		     Sekr. FR 5-6 
X# 		     Franklinstr. 28/29
X# 		     D-1000 Berlin 10, West Germany
X# 
X# 		     Tel: +49-30-314-22972
X# 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X# 
X#
X#	$__Log$
X#
X###############################################################################
X#									      #
X#        		  Shapefile for SHAPE      			      #
X#									      #
X###############################################################################
X
X
XCOMPONENTS = 	README Shapefile attr.c attr.h error.c files.c files.h \
X		hash.c 	hash.h inherit.c shape.l macro.c macro.h main.c \
X		shape.h misc.c 	produce.c rule.c rule.h select.c selrule.c \
X		selrule.h shape.1 shapeopt.c sighand.c std.c std.h string.c \
X		varsec.c varsec.h vpath.c version.c
X
XSRCDIR =	/u/wolf/src/shape
X
XINSTALDIR =	/u/shape/bin
X
XPROGS =		shapex
XINSTALLPROGS =	shape
X
XSHAPESRC = 	 main.c hash.c macro.c rule.c files.c error.c produce.c \
X		 std.c selrule.c attr.c varsec.c select.c vpath.c misc.c \
X		 sighand.c inherit.c string.c version.c
X
XSHAPOBJS =	main.o shape.o hash.o macro.o rule.o files.o error.o \
Xproduce.o std.o selrule.o attr.o varsec.o select.o vpath.o \
Xmisc.o sighand.o shapeopt.o inherit.o string.o version.o
X
XHFILES =	shape.h macro.h hash.h rule.h selrule.h std.h varsec.h \
Xattr.h file.h
X
XAFSLIB =	/u/shape/lib/libafs.a
X
XCLIBS =
X
XUTILLIB =	/u/shape/lib/libutil.a
X
XAFSINC =	/u/shape/src/inc
X
XHEADER =	shape.h $(AFSINC)/afs.h 
X
XSYSTEM = 	bsd_4_3
X
XQUALITY = 	test
X
XCC = cc -DCFFLGS='"$$Flags: $(CFLAGS) $$"'
X
XRULE = test
XSYSTEM = bsd_4_3
XQUALITY = test 
X
Xall: $(PROGS)
X
Xshapex: $(RULE) +$(SYSTEM) +$(QUALITY) $(SHAPOBJS) $(AFSLIB) $(UTILLIB)
X	cc -g -pg -o $@ $(SHAPOBJS) $(UTILLIB) $(AFSLIB) $(CLIBS) -ll
X
X$(SHAPOBJS):	$(HEADER)
Xmacro.o:	$(HEADER) macro.h
Xhash.o:		$(HEADER) hash.h
Xrule.o: 	$(HEADER) rule.h
Xselrule.o:	$(HEADER) selrule.h
Xstd.o:		$(HEADER) std.h
Xvarsec.o:	$(HEADER) varsec.h
Xattr.o:		$(HEADER) attr.h
Xfiles.o:	$(HEADER) files.h
Xversion.o:	version.c
X
XClean:
X	rm shape *.o core
X
Xsave:
X	save $(COMPONENTS)
X
Xlint:
X	lint  -I/u/shape/src/inc $(SHAPESRC) shape.c
X
Xshar:
X	shar Shapefile Makefile $(COMPONENTS) version.c /u/shape/src/inc/ParseArgs.h > shape.sh 
X
Xinstall: all
X	@-for i in $(INSTALLPROGS); \
X	do \
X	echo installing $$i in $(INSTALDIR); \
X	install -c -g unib shapex $(INSTALDIR)/$$i;\
X	done;
X
X
X#% RULE-SECTION
X
Xrelease:
X	*, attr (state, published), attrmax (version);
X	*, attr (state, busy).
X
Xtest:	*, attr(state, busy);
X	*, attrmax(version).
X
X#% END-RULE-SECTION
X
X#% VARIANT-SECTION
X
Xvclass system ::= (bsd_4_3, ultrix_2_0)
Xvclass quality ::= (test, release)
X
Xbsd_4_3:
X
Xultrix_2_0:
X	vflags = -DULTRIX_2_0 -DOLDDBM
X	CFLAGS = -g -I$(AFSINC)
X	CLIBS = -ldbm
X
Xtest:
X	CFLAGS = -pg -g -I$(AFSINC)
X	LDFLAGS = -pg -g
X
Xrelease:
X	CFLAGS = -O -I$(AFSINC)
X	LDFLAGS = -s
X
Xgnu:
X	CC = gcc -I/u/shape/src/inc
X	CFLAGS = -O -g -finline-functions -fkeep-inline-functions \
X		-fcombine-regs -DCFFLGS=\"HALLO\"
X# '"$$Flags: $(CFLAGS) $$"'
X
X#% END-VARIANT-SECTION
END_OF_FILE
if test 3789 -ne `wc -c <'src/shape/Shapefile'`; then
    echo shar: \"'src/shape/Shapefile'\" unpacked with wrong size!
fi
# end of 'src/shape/Shapefile'
fi
if test -f 'src/shape/select.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/shape/select.c'\"
else
echo shar: Extracting \"'src/shape/select.c'\" \(4466 characters\)
sed "s/^X//" >'src/shape/select.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *RCSid = "$Header: select.c,v 3.1 89/02/20 16:26:38 wolfgang Exp $";
X#endif
X#ifndef lint
Xstatic char *ConfFlg = CFFLGS;	/* should be defined from within Makefile */
X#endif
X/*
X * $Log:	select.c,v $
X * Revision 3.1  89/02/20  16:26:38  wolfgang
X * NET-RELEASE
X * 
X * Revision 3.0  89/01/24  11:36:45  wolfgang
X * New System Generation
X * 
X * Revision 2.5  89/01/03  13:13:21  wolfgang
X * changes done for lint
X * 
X * Revision 2.4  88/12/21  15:12:33  wolfgang
X * changes done for lint
X * 
X * Revision 2.3  88/11/22  17:37:42  wolfgang
X * This version is part of a release
X * 
X * Revision 2.2  88/08/31  12:12:53  wolfgang
X * Bugs fixed.
X * 
X * Revision 2.1  88/08/19  10:17:57  wolfgang
X * This version is part of a release
X * 
X */
X
X#include <pwd.h>
X
X#include "shape.h"
X
Xextern struct passwd *getpwnam();
Xextern char *mktemp();
X
Xextern int get_set();
Xextern int af_setgkey();
Xextern int af_gattrs();
X
Xextern char current_dep[];
Xextern Af_attrs buft;
Xextern int depth;
Xextern char actpath[];
X
Xchar cursr[64]; /* name of active selection rule */
Xstruct selection_rules *currule; /* active selection rule */
X
XBool Sselect(targ, path, ttt, fdep, dep)
X     char *targ;
X     char *path;
X     Bool ttt;
X     /*ARGSUSED*/
X     char *fdep;
X     char *dep;
X{
X
XAf_attrs buf1;
X/* Af_attrs buft; */
X
XAf_key key1;
XAf_key key2;
X
XAf_set set1;
XAf_set set2;
XBool t1;
XBool t2;
Xchar path1[MAXNAMLEN];
Xchar path2[MAXNAMLEN];
XBool appflg = TRUE;
Xchar apptest[MAXNAMLEN];
X
X/* if (strcmp(cursr,"-STD-"))
X return(TRUE); */
X
Xif (buft.af_name[0] == targ[0])
X  {
X    (void) strcpy(apptest,buft.af_name);
X    (void) strcat(apptest,".");
X    (void) strcat(apptest,buft.af_type);
X    if (!strcmp(apptest,targ))
X      appflg = FALSE;
X  }
X
Xpath1[0] = '\0';
Xpath2[0] = '\0';
X
Xaf_initattrs(&buf1);
Xaf_initattrs(&buft);
X
X/* no selection rule is active or dep didn't match */
Xt1 = ttt; /* exists_file(targ,0);  */
X(void) strcpy(path1,path); /* actpath); */
Xt2 = exists_file(dep,0);
X(void) strcpy(path2,actpath);
X(void) strcpy(actpath,"");
Xif ((t1) && (t2))
X  {
X
X    get_date_of(targ,&set1,path1);
X    if (set1.af_setlen == 0)
X      return(TRUE);   /* targ only in bpool */
X
X    get_date_of(dep,&set2,path2);
X    
X    if (af_setgkey(&set1,0,&key1) == -1)
X      errexit(10,"af_setgkey");
X    if (af_setgkey(&set2,0,&key2) == -1)
X      errexit(10,"af_setgkey");
X    
X    if (af_gattrs(&key1,&buf1) == -1)
X      errexit(10,"af_gattrs");
X    if (af_gattrs(&key2,&buft) == -1)
X      errexit(10,"af_gattrs");
X	
X    if (af_dropset(&set1) == -1)
X      errexit(10, "af_dropset");
X
X    if (af_dropset(&set2) == -1)
X      errexit(10, "af_dropset");
X    
X
X    if ((buf1.af_mtime < buft.af_mtime) || ((buf1.af_mtime == -1) && (buft.af_mtime == -1)))
X      {
X	if(appflg)
X	  append_attrs(&buft,depth);
X	(void) strcpy(current_dep,dep);
X	return(TRUE);
X      }
X    else
X      return(FALSE);
X  }
Xelse
X  {
X    (void) strcpy(current_dep,dep);
X    if ((!t1) && (t2))
X      {
X	if (appflg)
X	  {
X	    /* get attrs for inheritage */
X	    get_date_of(dep,&set2,path2);
X	    if (af_setgkey(&set2,0,&key2) == -1)
X	      errexit(10,"af_setgkey");
X	    if (af_gattrs(&key2,&buft) == -1)
X	      errexit(10,"af_gattrs");
X	    if (af_dropset(&set2) == -1)
X	      errexit(10, "af_dropset");
X	    append_attrs(&buft,depth);
X	  }
X	return(TRUE);
X      }
X    if ((!t1) && (!t2))
X      return(TRUE);
X    if ((t1) && (!t2))
X      return(TRUE);
X  }
X/*NOTREACHED*/
X}
X
END_OF_FILE
if test 4466 -ne `wc -c <'src/shape/select.c'`; then
    echo shar: \"'src/shape/select.c'\" unpacked with wrong size!
fi
# end of 'src/shape/select.c'
fi
if test -f 'src/shape/vpath.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/shape/vpath.c'\"
else
echo shar: Extracting \"'src/shape/vpath.c'\" \(3595 characters\)
sed "s/^X//" >'src/shape/vpath.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *RCSid = "$Header: vpath.c,v 3.2 89/02/20 16:26:55 wolfgang Exp $";
X#endif
X#ifndef lint
Xstatic char *ConfFlg = CFFLGS;	/* should be defined from within Makefile */
X#endif
X/*
X * $Log:	vpath.c,v $
X * Revision 3.2  89/02/20  16:26:55  wolfgang
X * NET-RELEASE
X * 
X * Revision 3.1  89/02/08  12:44:58  wolfgang
X * performance improved.
X * 
X * Revision 3.0  89/01/24  11:37:26  wolfgang
X * New System Generation
X * 
X * Revision 2.6  89/01/03  13:14:30  wolfgang
X * changes done for lint
X * 
X * Revision 2.5  88/12/21  15:13:37  wolfgang
X * changes done for lint
X * 
X * Revision 2.4  88/11/21  20:54:15  wolfgang
X * changes done for sun
X * 
X * Revision 2.3  88/11/21  15:49:32  wolfgang
X * return code of all malloc's checked
X * 
X * Revision 2.2  88/11/18  15:03:21  wolfgang
X * is_vpath_dir added.
X * 
X * Revision 2.1  88/08/19  10:18:19  wolfgang
X * This version is part of a release
X * 
X */
X
X#include "shape.h"
X
Xinsertvpath(string)
X     char *string;
X{
X  char *p;
X  int i;
X  for(i = 1; (p = index(string,':')) != NIL; i++)
X    {
X      *p = '\0';
X      if(*string != '/')
X	{
X	  if ((curvpath[i] = malloc((unsigned) (strlen(string) + strlen(curvpath[0])
X			     + 3 * sizeof(char)))) == NIL)
X	    errexit(10,"malloc");
X	  (void) strcpy(curvpath[i],curvpath[0]);
X	  (void) strcat(curvpath[i],"/");
X	  if ((*string == '.') && (*string+1 == '/'))
X	    {
X	      string++;
X	      string++;
X	    }
X	  else
X	    {
X	      if ((*string == '.') && (*string+1 == '.') && (*string+2 == '/'))
X		{
X		  *string++;
X		  *string++;
X		  *string++;
X		}
X	    }
X	  (void) strcat(curvpath[i],string);
X	}
X      else
X	{
X	  if ((curvpath[i] = malloc((unsigned) (strlen(string) + sizeof(char)))) == NIL)
X	    errexit(10,"malloc");
X	  (void) strcpy(curvpath[i],string);
X	  p++;
X	  string = p;
X	}
X    }
X  if((p == NIL) && (string != NIL))
X    {
X      if(*string != '/')
X	{
X	  if((curvpath[i] = malloc((unsigned) (strlen(string) + strlen(curvpath[0])
X			     + 2 * sizeof(char)))) == NIL)
X	    errexit(10,"malloc");
X	  (void) strcpy(curvpath[i],curvpath[0]);
X	  (void) strcat(curvpath[i],"/");
X	  if ((*string == '.') && (*string+1 == '/'))
X	    {
X	      string++;
X	      string++;
X	    }
X	  else
X	    {
X	      if ((*string == '.') && (*string+1 == '.') && (*string+2 == '/'))
X		{
X		  *string++;
X		  *string++;
X		  *string++;
X		}
X	    }
X	  (void) strcat(curvpath[i],string);
X	}
X      else
X	{
X	  if((curvpath[i] = malloc((unsigned) (strlen(string) + sizeof(char)))) == NIL)
X	    errexit(10,"malloc");
X	  (void) strcpy(curvpath[i],string);
X	}
X    }
X}
X
END_OF_FILE
if test 3595 -ne `wc -c <'src/shape/vpath.c'`; then
    echo shar: \"'src/shape/vpath.c'\" unpacked with wrong size!
fi
# end of 'src/shape/vpath.c'
fi
if test -f 'src/vc/deps' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/vc/deps'\"
else
echo shar: Extracting \"'src/vc/deps'\" \(3686 characters\)
sed "s/^X//" >'src/vc/deps' <<'END_OF_FILE'
Xdoretrv.o: afsapp.h
Xdoretrv.o: locks.h
Xdoretrv.o: project.h
Xdoretrv.o: retrv.h
Xdoretrv.o: typeconv.h
Xdoretrv.o: /u/shape/src/inc/afs.h
Xdoretrv.o: /u/shape/src/inc/afsys.h
Xdoretrv.o: doretrv.c
Xdosave.o: afsapp.h
Xdosave.o: locks.h
Xdosave.o: project.h
Xdosave.o: save.h
Xdosave.o: typeconv.h
Xdosave.o: /u/shape/src/inc/afs.h
Xdosave.o: /u/shape/src/inc/afsys.h
Xdosave.o: dosave.c
Xmkattr.o: afsapp.h
Xmkattr.o: retrv.h
Xmkattr.o: typeconv.h
Xmkattr.o: /u/shape/src/inc/afs.h
Xmkattr.o: /u/shape/src/inc/afsys.h
Xmkattr.o: mkattr.c
Xproject.o: project.h
Xproject.o: project.c
Xretrv.o: afsapp.h
Xretrv.o: project.h
Xretrv.o: retrv.h
Xretrv.o: typeconv.h
Xretrv.o: /u/shape/src/inc/ParseArgs.h
Xretrv.o: /u/shape/src/inc/afs.h
Xretrv.o: /u/shape/src/inc/afsys.h
Xretrv.o: retrv.c
Xsave.o: afsapp.h
Xsave.o: project.h
Xsave.o: save.h
Xsave.o: typeconv.h
Xsave.o: /u/shape/src/inc/ParseArgs.h
Xsave.o: save.c
Xsighand.o: afsapp.h
Xsighand.o: typeconv.h
Xsighand.o: /u/shape/src/inc/afs.h
Xsighand.o: /u/shape/src/inc/afsys.h
Xsighand.o: sighand.c
Xutil.o: afsapp.h
Xutil.o: locks.h
Xutil.o: project.h
Xutil.o: typeconv.h
Xutil.o: /u/shape/src/inc/afs.h
Xutil.o: /u/shape/src/inc/afsys.h
Xutil.o: util.c
Xvadm.o: afsapp.h
Xvadm.o: typeconv.h
Xvadm.o: vadm.h
Xvadm.o: /u/shape/src/inc/ParseArgs.h
Xvadm.o: /u/shape/src/inc/afs.h
Xvadm.o: /u/shape/src/inc/afsys.h
Xvadm.o: vadm.c
Xvadm_delete.o: afsapp.h
Xvadm_delete.o: locks.h
Xvadm_delete.o: typeconv.h
Xvadm_delete.o: vadm.h
Xvadm_delete.o: /u/shape/src/inc/afs.h
Xvadm_delete.o: /u/shape/src/inc/afsys.h
Xvadm_delete.o: vadm_delete.c
Xvadm_gkeys.o: afsapp.h
Xvadm_gkeys.o: typeconv.h
Xvadm_gkeys.o: vadm.h
Xvadm_gkeys.o: /u/shape/src/inc/afs.h
Xvadm_gkeys.o: /u/shape/src/inc/afsys.h
Xvadm_gkeys.o: vadm_gkeys.c
Xvadm_note.o: afsapp.h
Xvadm_note.o: locks.h
Xvadm_note.o: typeconv.h
Xvadm_note.o: vadm.h
Xvadm_note.o: vc_sysdep.h
Xvadm_note.o: /u/shape/src/inc/afs.h
Xvadm_note.o: /u/shape/src/inc/afsys.h
Xvadm_note.o: vadm_note.c
Xvadm_promote.o: afsapp.h
Xvadm_promote.o: locks.h
Xvadm_promote.o: typeconv.h
Xvadm_promote.o: vadm.h
Xvadm_promote.o: /u/shape/src/inc/afs.h
Xvadm_promote.o: /u/shape/src/inc/afsys.h
Xvadm_promote.o: vadm_promote.c
Xvadm_reserve.o: afsapp.h
Xvadm_reserve.o: locks.h
Xvadm_reserve.o: typeconv.h
Xvadm_reserve.o: vadm.h
Xvadm_reserve.o: /u/shape/src/inc/afs.h
Xvadm_reserve.o: /u/shape/src/inc/afsys.h
Xvadm_reserve.o: vadm_reserve.c
Xvadm_symname.o: afsapp.h
Xvadm_symname.o: project.h
Xvadm_symname.o: typeconv.h
Xvadm_symname.o: vadm.h
Xvadm_symname.o: /u/shape/src/inc/afs.h
Xvadm_symname.o: /u/shape/src/inc/afsys.h
Xvadm_symname.o: vadm_symname.c
Xvadm_utils.o: afsapp.h
Xvadm_utils.o: typeconv.h
Xvadm_utils.o: vadm.h
Xvadm_utils.o: vadmdefs.h
Xvadm_utils.o: /u/shape/src/inc/afs.h
Xvadm_utils.o: /u/shape/src/inc/afsys.h
Xvadm_utils.o: vadm_utils.c
Xvc_call.o: afsapp.h
Xvc_call.o: typeconv.h
Xvc_call.o: vc_call.c
Xvc_files.o: afsapp.h
Xvc_files.o: locks.h
Xvc_files.o: typeconv.h
Xvc_files.o: vc_sysdep.h
Xvc_files.o: /u/shape/src/inc/afs.h
Xvc_files.o: /u/shape/src/inc/afsys.h
Xvc_files.o: vc_files.c
Xvc_keyboardIo.o: afsapp.h
Xvc_keyboardIo.o: typeconv.h
Xvc_keyboardIo.o: vc_keyboardIo.c
Xvc_lock.o: afsapp.h
Xvc_lock.o: typeconv.h
Xvc_lock.o: /u/shape/src/inc/afs.h
Xvc_lock.o: /u/shape/src/inc/afsys.h
Xvc_lock.o: vc_lock.c
Xvl.o: afsapp.h
Xvl.o: typeconv.h
Xvl.o: vl.h
Xvl.o: /u/shape/src/inc/ParseArgs.h
Xvl.o: vl.c
Xvldovl.o: afsapp.h
Xvldovl.o: typeconv.h
Xvldovl.o: vl.h
Xvldovl.o: /u/shape/src/inc/afs.h
Xvldovl.o: /u/shape/src/inc/afsys.h
Xvldovl.o: vldovl.c
Xvlmisc.o: afsapp.h
Xvlmisc.o: typeconv.h
Xvlmisc.o: vl.h
Xvlmisc.o: /u/shape/src/inc/afs.h
Xvlmisc.o: /u/shape/src/inc/afsys.h
Xvlmisc.o: vlmisc.c
Xvlopt.o: afsapp.h
Xvlopt.o: typeconv.h
Xvlopt.o: vl.h
Xvlopt.o: /u/shape/src/inc/ParseArgs.h
Xvlopt.o: vlopt.c
END_OF_FILE
if test 3686 -ne `wc -c <'src/vc/deps'`; then
    echo shar: \"'src/vc/deps'\" unpacked with wrong size!
fi
# end of 'src/vc/deps'
fi
if test -f 'src/vc/vadm_delete.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/vc/vadm_delete.c'\"
else
echo shar: Extracting \"'src/vc/vadm_delete.c'\" \(4539 characters\)
sed "s/^X//" >'src/vc/vadm_delete.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *AFSid = "$Header: vadm_delete.c[3.7] Thu Feb 23 18:14:09 1989 axel@coma published $";
X#ifdef CFFLGS
Xstatic char *ConfFlg = CFFLGS;
X	/* should be defined from within Makefile */
X#endif
X#endif
X/*
X * Log for /u/shape/dist-tape/src/vc/vadm_delete.c[3.4]
X * 	Thu Feb 23 18:14:09 1989 axel@coma published $
X *  --- empty log message ---
X *  vadm_delete.c[3.5] Thu Feb 23 18:14:09 1989 axel@coma published $
X *  --- empty log message ---
X *  vadm_delete.c[3.6] Thu Feb 23 18:14:09 1989 axel@coma save $
X *  --- empty log message ---
X *  vadm_delete.c[3.7] Thu Feb 23 18:14:09 1989 axel@coma published $
X *  --- empty log message ---
X */
X
X#include <stdio.h>
X#include <strings.h>
X
X#include "afs.h"
X#include "afsapp.h"
X#include "vadm.h"
X#include "locks.h"
X
X/* external */
Xextern char *malloc();
Xextern unsigned int options;
Xextern struct Transaction ThisTransaction;
X
X/* locals */
Xstatic char buf[2048];
X
X/**/
Xint DoDelete (vlist, ac, av)
X     struct vc_vlist *vlist;
X     int ac;
X     char **av;
X{
X  Af_set set;
X  Af_key *key;
X  Af_user *vc_testlock(), *vc_lock();
X  Uid_t lockeruid();
X  char **erroneous, *lockerid();
X  char version[1024];
X  int state;
X  int i;
X  int errs = 0;
X
X  errs = GetKeysByName (ac, av, vlist, &set, &erroneous);
X
X  if (errs)
X    print_erroneous (erroneous, errs);
X
X  if (!set.af_nkeys) {
X    logmsg ("Nothing appropriate found."); 
X    return 1;
X  }
X
X  if (errs)
X    if (IsOptionSet(Vopt_no_confirm) || IsOptionSet(Vopt_quiet) 
X	|| !ask_confirm ("Continue", "yes"))
X      return 1;
X
X  ThisTransaction.tr_rc = 0;
X  for (i = 0 ; i < set.af_nkeys; i++) {
X    Af_user *thislock;
X    ThisTransaction.tr_seqno = i;
X    key = &set.af_klist[i];
X    mkvstring (version, key);
X    (void)strcpy (ThisTransaction.tr_fname, version);
X    if (setjmp (ThisTransaction.tr_env)) continue;
X    if ((state = af_rstate (key)) == -1) {
X      (void) sprintf (buf, "DoDelete (%s): af_rstate", 
X		      ThisTransaction.tr_fname);
X      af_perror (buf);
X      ThisTransaction.tr_rc++;
X      continue;
X    }
X
X    if (state > AF_SAVED) {
X      (void)sprintf (buf, "%s cannot be deleted. Version state must be \"saved\".",
X	       version);
X      logmsg (buf);
X      ThisTransaction.tr_rc++;
X      continue;
X    }
X
X    (void)sprintf (buf, "Delete %s ?", version);
X    thislock = vc_testlock_v(key);
X    if (locked(thislock)) {
X      if (lockeruid (thislock) != (Uid_t)getuid ()) {
X	/* locked ! ... but by somebody else */
X	(void)sprintf (buf, "No permission to delete %s (locked by %s).",
X		 version, lockerid (thislock));
X	logmsg (buf); free ((char *)thislock);
X	continue;
X      }
X    }
X    else { /* the version is not locked. We must lock it to delete it. */
X      Af_user *mylock = vc_lock_v(key, (Uid_t)getuid ());
X      if (lockeruid (mylock) != (Uid_t)getuid ()) {
X	(void)sprintf (buf, "can't lock %s. Not deleted.", version);
X	logmsg (buf);
X	free ((char *)mylock); free ((char *)thislock);
X	continue;
X      }
X      free ((char *)mylock);
X    }
X    free ((char *)thislock);
X
X    if (!(IsOptionSet(Vopt_no_confirm) || IsOptionSet(Vopt_quiet)))
X      if (!ask_confirm (buf, "yes")) {
X	(void)sprintf (buf, "%s not deleted.", version);
X	logmsg (buf); free ((char *)thislock);
X	continue;
X      }
X    if (af_rm (key) == -1) {
X      (void)sprintf (buf, "DoDelete(): During deletion of %s.", version);
X      af_perror (buf);
X      return 1;
X    }
X    (void)sprintf (buf, "%s deleted.", version);
X    logmsg (buf);
X  }
X
X  if (errs)
X    return 1;
X  else
X    return 0;
X}
X
END_OF_FILE
if test 4539 -ne `wc -c <'src/vc/vadm_delete.c'`; then
    echo shar: \"'src/vc/vadm_delete.c'\" unpacked with wrong size!
fi
# end of 'src/vc/vadm_delete.c'
fi
if test -f 'src/vc/vc_keyboardIo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/vc/vc_keyboardIo.c'\"
else
echo shar: Extracting \"'src/vc/vc_keyboardIo.c'\" \(4259 characters\)
sed "s/^X//" >'src/vc/vc_keyboardIo.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *AFSid = "$Header: vc_keyboardIo.c[1.5] Thu Feb 23 18:14:31 1989 axel@coma published $";
X#ifdef CFFLGS
Xstatic char *ConfFlg = CFFLGS;
X	/* should be defined from within Makefile */
X#endif
X#endif
X/*
X * Log for /u/shape/dist-tape/src/vc/vc_keyboardIo.c[1.3]
X * 	Thu Feb 23 18:14:31 1989 axel@coma published $
X *  --- empty log message ---
X *  vc_keyboardIo.c[1.4] Thu Feb 23 18:14:31 1989 axel@coma published $
X *  --- empty log message ---
X *  vc_keyboardIo.c[1.5] Thu Feb 23 18:14:31 1989 axel@coma published $
X *  --- empty log message ---
X */
X
X#include <stdio.h>
X#include "afsapp.h"
X
Xextern char *malloc();
X
X#define INPUTQUEUE 4000
X#define PROMPT "> "
X
X/*ARGSUSED*/
Xstatic
Xchar *read_unbuffered (term_char)
X     int term_char;
X{
X  char *frame, *nextframe;
X  int this_char, last_char, last_last_char, curlen, maxlen;
X
X  if ((frame = 
X       malloc ((unsigned)(sizeof (char) * (INPUTQUEUE + 1)))) == NULL) {
X    fprintf (stderr, "read_unbuffered: can't malloc frame");
X    exit (1);
X  }
X
X  curlen = 0;
X  maxlen = INPUTQUEUE;
X  nextframe = NULL;
X  last_char = last_last_char = -1;
X  
X  (void)fflush(stdin);
X  printf (PROMPT);
X
X  while ((this_char = getchar()) != EOF) {
X    if (curlen == maxlen) {
X     /* we need a new frame */
X      nextframe = 
X	malloc ((unsigned)(sizeof (char) * (maxlen + INPUTQUEUE + 1)));
X      if (nextframe == NULL) {
X	fprintf (stderr, "read_unbuffer: can't malloc new frame,2");
X	exit (1);
X      }
X
X      bzero (nextframe, maxlen + INPUTQUEUE + 1);
X      bcopy (frame, nextframe, maxlen);
X      free (frame);
X      maxlen += INPUTQUEUE;
X      frame = nextframe;
X    }
X	
X    frame[curlen++] = this_char;
X
X    if (this_char == '\n') {
X      if ((last_char == '.')
X	  && ((last_last_char == '\n') || (last_last_char == -1))) {
X	/* input is done */
X	curlen -= 2;		/* forget "<term_char>\n"  */
X	break;
X      }
X      else
X	printf (PROMPT);		/* print prompt */
X    }
X    
X    last_last_char = last_char;
X    last_char = this_char;
X  }
X  frame[curlen] = NULL;
X  return frame;
X}
X
Xstatic
Xchar *read_buffered ()
X{
X  /* hmmm, muss ich erstmal ueber eine geniale
X   * Implementierung nachdenken. Also erstmal
X   * read_unbuffered ().
X   */
X
X  return read_unbuffered (-1);	/* no special term_char */
X}
X
Xchar *get_from_stdin (contents, term_char)
X     char *contents;
X     int term_char;		/* char that indicates input termination */
X{
X  /*
X   * Reads from stdin a text terminated by ^D or by a specified
X   * single charcter "term_char" at the beginning of a new line.
X   * If term_char is -1 text is terminated  by ^D.
X   *
X   * The text is appended to "contents", if "contents" is given.
X   */
X  char *tmp, *new;
X  int ltmp, lcontents;		/* length of tmp and contents */
X  
X  if (!isatty (0))		/* 0 == stdin */
X    tmp = read_buffered ();	/* ignore term_char */
X  else
X    tmp = read_unbuffered (term_char);
X
X  if (contents && *contents) {
X    ltmp = strlen (tmp);
X    lcontents = strlen (contents);
X    if ((new = 
X	 malloc ((unsigned)(sizeof (char) * (ltmp+lcontents+1)))) == NULL) {
X      fprintf (stderr, "Get_from_stdin: Can't malloc");
X      exit (1);
X    }
X
X    (void)sprintf (new, "%s%s", contents, tmp);
X    free (tmp);
X    return new;
X  }
X
X  return tmp;
X}
END_OF_FILE
if test 4259 -ne `wc -c <'src/vc/vc_keyboardIo.c'`; then
    echo shar: \"'src/vc/vc_keyboardIo.c'\" unpacked with wrong size!
fi
# end of 'src/vc/vc_keyboardIo.c'
fi
if test -f 'src/vfind/Shapefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/vfind/Shapefile'\"
else
echo shar: Extracting \"'src/vfind/Shapefile'\" \(4217 characters\)
sed "s/^X//" >'src/vfind/Shapefile' <<'END_OF_FILE'
X#
X# Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X#  and U. Pralle
X# 
X# This software is published on an as-is basis. There is ABSOLUTELY NO
X# WARRANTY for any part of this software to work correctly or as described
X# in the manuals. We do not accept any liability for any kind of damage
X# caused by use of this software, such as loss of data, time, money, or effort.
X# 
X# Permission is granted to use, copy, modify, or distribute any part of
X# this software as long as this is done without asking for charge, and
X# provided that this copyright notice is retained as part of the source
X# files. You may charge a distribution fee for the physical act of
X# transferring a copy, and you may at your option offer warranty
X# protection in exchange for a fee.
X# 
X# Direct questions to: Tech. Univ. Berlin
X# 		     Wilfried Koch
X# 		     Sekr. FR 5-6 
X# 		     Franklinstr. 28/29
X# 		     D-1000 Berlin 10, West Germany
X# 
X# 		     Tel: +49-30-314-22972
X# 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X# 
X# Shapefile for vfind
X# $Header: Shapefile[1.6] Tue Feb 21 20:23:03 1989 uli@coma published $
X#
X# Log for /u/shape/dist-tape/src/vfind/Shapefile[1.6]
X# 	Tue Feb 21 20:23:03 1989 uli@coma published $
X#  	* This is the Shapefile for vfind. It works on BSD 4.3, SunOS
X#  	4.0, and Ultrix 2.0.
X#  
X#  
X#
X# This is the directory where the AFS header files reside.
XAFSINC = /u/shape/src/inc
X# This is the directory where the AFS libraries reside.
XAFSLIBPATH = /u/shape/lib
X#
X# You are ready, if you don't want to install vfind via shape.
XINSTALDIR = /u/shape/bin
X#
X# Ok, that's it. Don't change other macros settings.
XRULE=
XSYSTEM=bsd_4_3
XCOMPILER=pcc
XQUALITY=debug
XAFSLIBS = $(AFSLIBPATH)/libutil.a $(AFSLIBPATH)/libafs.a
X
X#% RULE-SECTION
Xrel:
X	$(AFSINC)/*, attr (state, busy);
X	*.a, attr (state, busy);
X	*, attrge (state, published), attrmax (version).
X
Xvsave:
X	*, attrmax (version);
X	*.a, attr (state, busy).
X
X
X#% END-RULE-SECTION
X
X#% VARIANT-SECTION
X
Xvclass system ::= (bsd_4_3, sunos_4_0, ultrix_2_0)
Xvclass compiler ::= (pcc, gcc)
X#
X#
Xcfflags:
X	vflags = -DCFFLGS='"$$Flags: <$<> $(CFLAGS) $$"'
X#
X# vclass system
Xbsd_4_3:
X	CFLAGS = -DBSD_4_3
X	LIBS = $(AFSLIBS)
Xsunos_4_0:
X	CFLAGS = -DSUNOS_4_0
X	LIBS = $(AFSLIBS)
Xultrix_2_0:
X	CFLAGS = -DULTRIX_2_0
X	LIBS = $(AFSLIBS) -ldbm
X#
X# vclass compiler
X#
Xpcc:
X	CC=cc $(INCLUDES)
Xgnu:
X	CC=gcc -traditional 
X	CFLAGS=-g -fwritable-strings $(INCLUDES)
X#
X# vclass quality
X#
Xdebug:
X	CFLAGS=-g
X
Xas:
X	CFLAGS=-S
X
Xprofile:
X	CFLAGS=-pg
X	LDFLAGS=-pg
X
Xoptimize:
X	CFLAGS=-O
X
Xmaxoptimize:
X	CFLAGS=-O -finline-functions -fcombine-regs -fstrength-reduce
X
Xpreprocess:
X	CFLAGS=-E
X
X#% END-VARIANT-SECTION
X
XCOMPONENTS = $(SOURCES) $(HEADERS) $(MANUALS) Shapefile README
XSOURCES = vfind.c vfversion.c at_misc.c
XOBJECTS = vfind.o vfversion.o at_misc.o
XHEADERS = atk.h
XMANUALS = vfind.1
XINCLUDES = -I$(AFSINC)
X
X.BPOOL:
X#.NOBPOOL:
X
Xvfind: $(RULE) +cfflags +$(SYSTEM) +$(COMPILER) +$(QUALITY) $(LIBS) $(OBJECTS)
X	$(CC) $(LDFLAGS) -o vfind $(OBJECTS) $(LIBS)
X
Xpreprel: rel @newrel @publish
X
Xcomprel: rel vfind
X
X
Xlint: +$(SYSTEM) +$(COMPILER) +$(QUALITY) +$(PURITY) $(COMPONENTS)
X	lint $(CFLAGS) $(INCLUDES) $(COMPONENTS)
X
XVERSIONPROTO = /u/shape/lib/version.c
Xvfversion.o: $(VERSIONPROTO)
Xvfind.o: atk.h
X
X#
X# Metatargets
X#
X@save:
X	save -q $(COMPONENTS)
X
X@publish:
X	sbmt -q $(COMPONENTS) -n $(RELNAME)
X
X@newrel:
X	cp $(VERSIONPROTO) vfversion.c ; \
X	sbmt -fq vfversion.c
X
X@sunset: $(COMPONENTS)
X	rsh troll '(cd vfind; rm -f $(COMPONENTS) )';
X	rcp $(COMPONENTS) troll:vfind;
X	rsh troll '(set path = ($$path /usr/gnu/bin) ;cd vfind; /u/shape/bin/shape SYSTEM=sunos_4_0)'
X
X@suninstall: vsave $(COMPONENTS)
X	rsh troll '(cd vfind; rm -f $(COMPONENTS) )';
X	rcp $(COMPONENTS) troll:vfind;
X	rsh troll '(set path = ($$path /usr/gnu/bin) ;cd vfind; /u/shape/bin/shape SYSTEM=sunos_4_0)'
X
X@vaxset: $(COMPONENTS)
X	rsh chaos '(cd vfind; rm -f $(COMPONENTS) )';
X	rcp $(COMPONENTS) chaos:vfind;
X	rsh chaos '(set path = ($$path /usr/local) ;cd vfind; /u/shape/bin/shape SYSTEM=ultrix_2_0)'
X
X@bclean:
X	rm -f AFS/?B*
X
Xinstall: rel vfind
X	@echo installing vfind in $(INSTALDIR); \
X	install -c -m 755 vfind $(INSTALDIR)
X
X@nothing:
X
X@echocomp:
X	@echo $(COMPONENTS)
X
Xtags:
X	etags $(SOURCES) $(HEADERS)
END_OF_FILE
if test 4217 -ne `wc -c <'src/vfind/Shapefile'`; then
    echo shar: \"'src/vfind/Shapefile'\" unpacked with wrong size!
fi
# end of 'src/vfind/Shapefile'
fi
if test -f 'tutorial/tutorial.ms' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tutorial/tutorial.ms'\"
else
echo shar: Extracting \"'tutorial/tutorial.ms'\" \(4195 characters\)
sed "s/^X//" >'tutorial/tutorial.ms' <<'END_OF_FILE'
X.\"
X.\" Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X.\"  and U. Pralle
X.\" 
X.\" This software is published on an as-is basis. There is ABSOLUTELY NO
X.\" WARRANTY for any part of this software to work correctly or as described
X.\" in the manuals. We do not accept any liability for any kind of damage
X.\" caused by use of this software, such as loss of data, time, money, or 
X.\" effort.
X.\" 
X.\" Permission is granted to use, copy, modify, or distribute any part of
X.\" this software as long as this is done without asking for charge, and
X.\" provided that this copyright notice is retained as part of the source
X.\" files. You may charge a distribution fee for the physical act of
X.\" transferring a copy, and you may at your option offer warranty
X.\" protection in exchange for a fee.
X.\" 
X.\" Direct questions to: Tech. Univ. Berlin
X.\" 		     Wilfried Koch
X.\" 		     Sekr. FR 5-6 
X.\" 		     Franklinstr. 28/29
X.\" 		     D-1000 Berlin 10, West Germany
X.\" 
X.\" 		     Tel: +49-30-314-22972
X.\" 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X.\" 
X.IZ
X.sp 1i
X.nr PS 30
X.ps \n(PS
X.nr VS 33
X.vs \n(VS
X.ce 2
XA tutorial introduction to the
X\f(HB\s-1shape\s+1\fR-toolkit
X.sp 1i
X.nr PS 12
X.ps \n(PS
X.nr VS 14
X.vs \n(VS
X.ce 3
X\fIWilfried Koch, Andreas Lampen, Axel Mahler, Wolfgang Obst, Uli Pralle\fR
XTechnische Universit\*:at Berlin
X.sp 4i
X.ce
XPreliminary Draft (\n(dy.\n(mo.\n(yr)
X.bp
X.NH 1
XAbout the status of this release
X.PP
XAs you will see when going on reading, this tutorial is still very raw
Xand incomplete. Properly spoken it is just a small fragment of the
Xtutorial we plan to write. We put this on the distribution tape because
Xwe think that a fragment of a tutorial is better than no
Xtutorial at all.
X.NH 1
XIntroduction
X.PP
XThe \*(sh-toolkit is a collection of programs to support
Xsoftware configuration management in an
X.UX
Xenvironment. It consists of a set of version control
Xcommands and \*(sh, a significantly enhanced \fIMake-oid\fR. \*(sh and
Xthe version control commands are integrated on top of AFS (Attributed
XFile System), a dedicated version object base. The system features
XRCS-style version control and a configuration identification and
X-build process that has full access to all revisions in the object
Xbase (other than make which only knows about plain files).  AFS also
Xsupports derived object management, i.e. it maintains a cache of
Xmultiple versions of compiled object-files (e.g. compiled c-files with
Xdifferent compile switches).
X.PP
XThe \*(sh program itself is upward compatible to Make in that it can
Xproperly handle conventional Makefiles. The \fIShapefile\fR however, uses
XMakefile-style dependencies as (versionless) \fIabstract system model\fR
Xand employs \fIconfiguration selection rules\fR to dynamically bind
Xparticular version objects in the object base to the names listed in
Xthe system model. The version selection mechanism exploits AFS'
Xability to maintain any number of arbitrary attributes for objects in
Xthe object base.
XOn special request, \*(sh records an identified configuration in a
X\fIconfiguration identification document\fR (CID) which has the form of
Xa completely bound Shapefile (all object-instances are explicit). This
Xmakes it particularly easy to rebuild recorded configurations. As 
XCID's are themselves documents, they can be placed under version control,
Xmaking it easy to maintain histories of entire software systems. 
X.PP
XThe object base abstraction presented by AFS provides uniform access to
Ximmutable revisions of data entities (files) stored in special
Xarchives, and mutable regular
X.UX
Xfiles. Consequently, the AFS based
Xtoolkit lives peacefully (and meaningfully!) together with standard
Xfilesystem applications (editors, compilers, formatters etc.).
XCooperative work within projects is supported by a build-in status
Xmodel, controlling visibility of version objects, and locking, a
Xprimitive form of \fIlong transactions\fR. The general concept of object
Xattributes provides for passing information between individual tools
Xthat would otherwise be lost. This mechanism is useful for building
Xintegrated environments from a set of unrelated tools.
X.bp
X.so make2shape.ms
X.bp
X.so trouble.ms
END_OF_FILE
if test 4195 -ne `wc -c <'tutorial/tutorial.ms'`; then
    echo shar: \"'tutorial/tutorial.ms'\" unpacked with wrong size!
fi
# end of 'tutorial/tutorial.ms'
fi
echo shar: End of archive 5 \(of 33\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
