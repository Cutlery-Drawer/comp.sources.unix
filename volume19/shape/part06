Subject:  v19i019:  A software configuration management system, Part06/33
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Axel Mahler <unido!coma!axel>
Posting-number: Volume 19, Issue 19
Archive-name: shape/part06



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 33)."
# Contents:  man/man3/afretrieve.3 man/man5/afarchive.5
#   src/afs/afarchive.h src/afs/aflock.c src/afs/afsysc.c
#   src/afs/bsfd.c src/shape/hash.c src/shape/shape.h
#   src/vc/vc_files.c src/vc/vc_lock.c
# Wrapped by rsalz@papaya.bbn.com on Thu Jun  1 19:26:54 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'man/man3/afretrieve.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/man3/afretrieve.3'\"
else
echo shar: Extracting \"'man/man3/afretrieve.3'\" \(5193 characters\)
sed "s/^X//" >'man/man3/afretrieve.3' <<'END_OF_FILE'
X...
X... Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X...  and U. Pralle
X... 
X... This software is published on an as-is basis. There is ABSOLUTELY NO
X... WARRANTY for any part of this software to work correctly or as described
X... in the manuals. We do not accept any liability for any kind of damage
X... caused by use of this software, such as loss of data, time, money, or 
X... effort.
X... 
X... Permission is granted to use, copy, modify, or distribute any part of
X... this software as long as this is done without asking for charge, and
X... provided that this copyright notice is retained as part of the source
X... files. You may charge a distribution fee for the physical act of
X... transferring a copy, and you may at your option offer warranty
X... protection in exchange for a fee.
X... 
X... Direct questions to: Tech. Univ. Berlin
X... 		     Wilfried Koch
X... 		     Sekr. FR 5-6 
X... 		     Franklinstr. 28/29
X... 		     D-1000 Berlin 10, West Germany
X... 
X... 		     Tel: +49-30-314-22972
X... 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X... 
X.TH AF_RETRIEVE 3 "" \n(dy.\n(mo.\n(yr
X.SH NAME
Xaf_retrieve \(em retrieve interface of the Attribute Filesystem
X.SH SYNOPSIS
X\fB#include <sys/dir.h>
X.br
X#include <sys/param.h>
X.br
X#include <afs.h>
X.sp
Xaf_find (attrbuf, resultset)
X.br
XAf_attrs	*attrbuf;
X.br
XAf_set	*resultset;
X.sp
Xaf_bpfind (attrbuf, resultset)
X.br
XAf_attrs	*attrbuf;
X.br
XAf_set	*resultset;
X.sp
Xaf_initattrs (attrbuf)
X.br
XAf_attrs	*attrbuf;
X.sp
Xaf_getkey (syspath, name, type, gen, rev, var, key)
X.br
Xchar	*syspath, *name, *type;
X.br
Xint	gen, rev;
X.br
Xchar	*var;
X.br
XAf_key	*key;
X.sp
Xaf_dropkey (key)
X.br
XAf_key	*key;
X.SH DESCRIPTION
X\fIAf_find\fR and \fIaf_bpfind\fR retrieve ASOs by given attributes.
X\fIAf_find\fR operates on source objects and \fIaf_bpfind\fR only on
Xderived objects.
XThe keys of all found ASOs are returned in \fIresultset\fR. 
XThe set is not ordered in any way.
XThe retrieve arguments are passed in \fIattrbuf\fR.
X\fIAttrbuf\fR should be initialized by \fIaf_initattrs\fR before
Xcalling \fIaf_find\fR.
X.LP
XThe structure of \fIattrbuf\fR is the following:
X.nf
X.ta 0.4i 1i 3.2i
Xtypedef struct {
X	char	af_host[MAXHOSTNAMELEN];	/* hostname */
X	char	af_syspath[MAXNAMLEN];	/* system path */
X	char	af_name[MAXNAMLEN];	/* name */
X	char	af_type[MAXTYPLEN];	/* type */
X	int	af_gen;	/* generation number */
X	int	af_rev;	/* revision number */
X	char	af_variant[MAXVARLEN];	/* variant attribute */
X	int	af_state;	/* version state */
X	Af_user	af_owner;	/* owner */
X	Af_user	af_author;	/* author */
X	off_t	af_size;	/* size of file */
X	u_short	af_mode;	/* protection */
X	Af_user	af_locker;	/* locker */
X	time_t	af_mtime;	/* date of last modification */
X	time_t	af_atime;	/* date of last access */
X	time_t	af_ctime;	/* date of last status change*/
X	time_t	af_stime;	/* save date */
X	time_t	af_ltime;	/* date of last lock change */
X	char	*af_udattrs[AF_MAXUDAS];	/* user defined attributes */
X} Af_attrs;
X.fi
X.PP
XA retrieve operation is always limited to one directory.
XIf no syspath is given in the attribute buffer, the current directory
Xis searched.
X.PP
XIt is possible to pass a list of \fIuser defined attributes\fR as
Xretrieve arguments.
XThe list of pointers \fIaf_udattrs\fR in \fIattrbuf\fR can be associated
Xwith strings of the form name[=value].
XThe list must be terminated by a nil pointer.
X.PP
XIt is interpreted in the following way:
X.IP "\fIempty list\fR (first entry is a nil pointer)"
Xmatches every ASO.
X.IP "\fI""""\fR (first entry is an empty string)"
Xmatches every ASO that has \fBno\fR user defined attributes.
X.IP "\fIname\fR[\fI=\fR]"
Xmatches, if a user defined attribute with the given name
Xis present.
X.IP "\fIname=value\fR"
Xmatches all ASOs that have a corresponding user defined
Xattribute, that has at least the given value.
X.PP
XA set generated by \fIaf_find\fR should be released by \fIaf_dropset\fR
Xas soon as it will not be used any longer.
X.PP
X\fIAf_getkey\fR builds up an object key by unique attributes (pathname, name,
Xtype, generation number, revision number and variant name).
XUpon successful completion, the found object key is
Xreturned in the buffer \fIkey\fR. \fIAf_getkey\fR works only on
Xsource objects.
X.PP
XInstead of explicit version numbers, you can pass the pseudo-numbers
X\fIAF_BUSYVERS\fR, \fIAF_FIRSTVERS\fR or \fIAF_LASTVERS\fR to \fIaf_getkey\fR.
X.br
XThe call \fCaf_getkey ("", "otto", "c", AF_BUSYVERS, AF_BUSYVERS)\fR leads
Xto the key of the busy version of the ASO named otto (type c) in
Xyour current context.
X.br
X\fCAf_getkey ("", "otto", "c", AF_LASTVERS, AF_LASTVERS)\fR delivers the
Xlast saved Version (if present).
X.PP
XUse \fIaf_dropkey\fR to free the allocated memory associated with \fIkey\fR.
X.SH SEE ALSO
Xaf_dropset(3)
X.SH DIAGNOSTICS
X\fIAf_find\fR returns the number of found ASOs.
XUpon error, -1 is returned and \fIaf_errno\fR is set to the corresponding
Xerror number.
X.SH BUGS
XA given hostname will be ignored during \fIaf_find\fR.
X.PP
XIn \fIaf_getkey\fR, the \fIvariant\fR argument is ignored.
X.PP
XMixed version numbering in calls of af_getkey 
X(eg. \fIgetkey ("", "otto", "c", AF_LASTVERS, 1)\fR or
X\fIgetkey ("", "otto", "c", AF_FIRSTVERS, AF_LASTVERS)\fR are not supported.
END_OF_FILE
if test 5193 -ne `wc -c <'man/man3/afretrieve.3'`; then
    echo shar: \"'man/man3/afretrieve.3'\" unpacked with wrong size!
fi
# end of 'man/man3/afretrieve.3'
fi
if test -f 'man/man5/afarchive.5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/man5/afarchive.5'\"
else
echo shar: Extracting \"'man/man5/afarchive.5'\" \(4579 characters\)
sed "s/^X//" >'man/man5/afarchive.5' <<'END_OF_FILE'
X...
X... Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X...  and U. Pralle
X... 
X... This software is published on an as-is basis. There is ABSOLUTELY NO
X... WARRANTY for any part of this software to work correctly or as described
X... in the manuals. We do not accept any liability for any kind of damage
X... caused by use of this software, such as loss of data, time, money, or 
X... effort.
X... 
X... Permission is granted to use, copy, modify, or distribute any part of
X... this software as long as this is done without asking for charge, and
X... provided that this copyright notice is retained as part of the source
X... files. You may charge a distribution fee for the physical act of
X... transferring a copy, and you may at your option offer warranty
X... protection in exchange for a fee.
X... 
X... Direct questions to: Tech. Univ. Berlin
X... 		     Wilfried Koch
X... 		     Sekr. FR 5-6 
X... 		     Franklinstr. 28/29
X... 		     D-1000 Berlin 10, West Germany
X... 
X... 		     Tel: +49-30-314-22972
X... 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X... 
X.TH AF_ARCHIVE 5 "" \n(dy.\n(mo.\n(yr
X.SH NAME
Xaf_archive -- format of archive files in the \fIAttribute Filesystem\fR
X.SH SYNOPSIS
X\fB#include <afs.h>
X.br
X#include <afsys.h>
X.SH DESCRIPTION
XAFS archive files are used to store the data and attributes of
Xnon-busy ASOs.
XBeside these, some attributes (including all user defined attributes)
Xof busy ASOs are stored in AFS archive files.
X.PP
XAFS maintains two archive files for each line of development \-
Xone to hold the standard- and the user defined attributes and
Xthe other to hold the data and change notes.
XThese files are stored either in a subdirectory named \fCAFS\fR
Xor in a explicitly named directory somewhere in your file system.
XThe two archive files are named (\(lq\fC^B\fR\(rq stands for \(lqCtrl-B\(rq)
X.br
X	\fC^BA\fR<filename>\fCA\fR		(attributes) and
X.br
X	\fC^BA\fR<filename>\fCD\fR		(data).
X.PP
XThis manual contains a short, exemplary description of the archive structure.
XApart from deltas, all data in AFS-archives are stored as ASCII-strings.
XThe archives contain keywords that have the form \fC^B\fR<key>.
XIn the following description, strings of the form \fI<field>\fR describe
Xthe purpose of the appropriate field in the archive.
X.PP
XHere's the structure (the attributes file first):
X.sp
X.ce
XThe Header, ...
X.nf
X.sp
X\fC^BARHD\fR   <archive_format_version>   <no_of_revisions>   <size_of_data>
X.sp
X.ce
X\&... the name ..
X.sp
X\fC^BI\fR   <hostname>   <path>   <name>   <type>   <variant>
X.sp
X.ce
X\&... and the owner ..
X.sp
X\fC^BO\fR   <owner's_name>   <owner's_host>
X.sp
X.ce
X\&... followed by some attributes for the busy version ...
X.sp
X\fC^BP\fR   <gen_>   <rev_of_physical_predecessor>
X.br
X\fC^BL\fR   <locker's_name>   <locker's_host>   <dat_of_last_lock_change>
X.ce 2
X\&... and the revision list, that contains all standard 
Xattributes for non-busy versions. ... 
X.sp
X\fC^R\fR   <generation>   <revision>   <state>   <mode>   <variant>
X.br
X	\fC^BA\fR   <author's_name>   <_host>   <locker's_name>   <_host>
X.br
X	\fC^BT\fR   <date_of_last_modification>   <_last_access>   <_last_status_change>   ...
X.in +3.3i
X\&...   <_saving>   <_locking>
X.in -3.3i
X	\fC^BM\fR   <kind_of_representation>   <size_of_file>   <size_of_delta>   ...
X.br
X			...   <gen_>   <rev_of_phys._successor>   <gen_>   <rev_of_phys._predecessor>
X.br
X\fC^BR ...\fR
X.br
X\fC^BR ...\fR
X.sp
X.ce 2
X\&... Now follows a list of lists of user defined attributes
X("-2 -2" indicates the busy version; "\fC@\fR" stands for a null byte). ...
X.sp
X\fC^BUSEG\fR
X\fC^BU -2 -2\fR   <size_of_user_def_attributes>
X\fCmachine=vax@data=fs@@\fR
X\fC^BU\fR   <gen>   <rev>   <size_of_user_def_attributes>
X\fCname=value@@\fR
X\fC^BU ...\fR
X.sp 0.5i
XThe structure of the datafile:
X.sp
XData are represented either by deltas or by complete data-chunks...
X.sp
X\fC^BDATA\fR
X.sp
X\fC^BN\fR   <gen>   <rev>   <size_of_note>
X\fC--- empty log message ---\fR
X.sp
X\fC^BD\fR   <gen>   <rev>   <kind_of_representation>   <size_of_data>
X\fCA typical delta looks like:\fR
X\fC"^A^?hg^some text^@^%^Gmore text^?^?$^D^E" and so on.\fR
X\fCDeltas are indicated by a "1" at the "kind_of_representation" field.
X.sp
X\fC^BN\fR   <gen>   <rev>   <size_of_note>
X\fCThis is a log message\fR
X.sp
X\fC^BD\fR   <gen>   <rev>   <kind_of_representation>   <size_of_data>
X\fCA "0" at the "kind_of_representation" field indicates that this version\fR
X\fCis stored completely.\fR
X.sp
X\fC^BN ...\fR
X.sp
X\fC^BD ...\fR
X.fi
X.SH AUTHOR
XAndreas Lampen, TU Berlin
X.br
X.ta 0.7i
XUUCP:	unido!coma!andy
X.br
XBITNET:	andy@db0tui62
END_OF_FILE
if test 4579 -ne `wc -c <'man/man5/afarchive.5'`; then
    echo shar: \"'man/man5/afarchive.5'\" unpacked with wrong size!
fi
# end of 'man/man5/afarchive.5'
fi
if test -f 'src/afs/afarchive.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/afs/afarchive.h'\"
else
echo shar: Extracting \"'src/afs/afarchive.h'\" \(4674 characters\)
sed "s/^X//" >'src/afs/afarchive.h' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X/*
X *	Shape/AFS
X *
X *	afarchive.h - Constant-Definitions for AFS-archives
X *
X *	Author:	Andreas Lampen (andy@coma.UUCP
X *				andy@db0tui62.BITNET)
X *
X *	$Header: afarchive.h[1.2] Wed Feb 22 16:27:08 1989 andy@coma published $
X *
X */
X
X/*=========================================================================
X * Internal Installation dependent constants
X *=========================================================================*/
X
X#define AF_NEWREVS      8	/* add. space for new revisions in rev list */
X#define AF_MAXLISTS   211       /* maximum number of read-in archives */
X#define AF_LISTSEG      8       /* size of segments of revlists-list */
X
X#define AF_BPOOLSIZE   64       /* max number of files in binary pool */
X                                /* should be determined dynamically */
X#define MAXDBMLEN    1024       /* maximum size of dbm-datastring */
X#define DBMLOSS         8       /* size of management data in dbm entry */
X                                /* ( 2 * sizeof (int)) */
X
X/*=========================================================================
X * Identification strings in archive and binary pool files
X *=========================================================================*/
X
X#define AF_LINESIZ      1024            /* size of input line */
X
X#define AF_SEGSTRLEN    5
X#define AF_ARHEADER 	"\02ARHD"	/* Header of Archive-file */
X#define AF_DATAHEADER 	"\02DATA"	/* Header of Data-file */
X#define AF_BPHEADER 	"\02BPHD"	/* Header of Binary-pool-file */
X#define AF_UDASEG 	"\02USEG"	/* User defined attributes Segment */
X
X#define AF_IDSTRLEN 	2
X#define AF_NAMEID	"\02I" 	/* Identification path, name, type */ 
X#define AF_OWNID	"\02O" 	/* Owner */
X#define AF_PRDID	"\02P" 	/* predecessor of busy version */
X#define AF_LOCKID	"\02L" 	/* Lock */
X#define AF_REVID	"\02R" 	/* revision specific attributes */
X				/* gen, rev, state, mode */
X#define AF_AUTHORID	"\02A" 	/* Author */
X#define AF_DATEID	"\02T" 	/* date of last mod., last access, */
X				/* creation, save */
X#define AF_REPRID	"\02M" 	/* kind of represetation, size of file, size */
X				/* of delta and other delta stuff (tree) */
X#define AF_NOTEID	"\02N" 	/* gen, rev, size, text of note */
X#define AF_UDAID	"\02U" 	/* gen, rev, size, text of udattrs */
X#define AF_DATAID	"\02D" 	/* gen, rev, size, repr, text of data */
X
X#define AF_BPFILEID     "\02B"  /* filename prefix for BP files */
X#define AF_AFSFILEID    "\02A"  /* filename prefix for AFS archives */
X
X/******* binary pool specific stuff *********/
X#define AF_BPSTDENTRY   "\01##" /* dbm entry name for special information */
X#define AF_BPOOLNAME    "\02Bpool"
X
X/*======================================================================
X * other constants
X *======================================================================*/
X
X#define AF_ARCHMODE     0444
X#define AF_ARCURVERS    1
X#define AF_BPCURVERS    1
X
X#define AF_NOSTRING     "\01$"
X
X/**** extent and type of revision list ****/
X
X#define AF_ATTRS	0001   /* Attributes are loaded */
X#define AF_DATA		0002   /* Data are loaded */
X#define AF_ALLSEGS	0003   /* Attributes and Data are loaded */
X#define AF_COMPLETE     0004   /* List is complete (binary pools only) */
X
X#define AF_BPOOL        0010   /* Binary pool */
X#define AF_ARCHIVE      0020   /* Line of development */
X
X#define AF_UXWRITE      0100   /* Unix write permission on AFS subdir */
X
X/*=========================================================================
X * Useful macros
X *=========================================================================*/
X
X/* test if string is empty */
X#define NOTMT(str) ((str && str[0]) ? str : AF_NOSTRING)
X
END_OF_FILE
if test 4674 -ne `wc -c <'src/afs/afarchive.h'`; then
    echo shar: \"'src/afs/afarchive.h'\" unpacked with wrong size!
fi
# end of 'src/afs/afarchive.h'
fi
if test -f 'src/afs/aflock.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/afs/aflock.c'\"
else
echo shar: Extracting \"'src/afs/aflock.c'\" \(5339 characters\)
sed "s/^X//" >'src/afs/aflock.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X/*LINTLIBRARY*/
X/*
X *	Shape/AFS
X *
X *	aflock.c -- Version locking
X *
X *	Author: Andreas Lampen, TU-Berlin (andy@coma.UUCP)
X *					  (andy@db0tui62.BITNET)
X *
X *	$Header: aflock.c[1.4] Wed Feb 22 16:27:44 1989 andy@coma published $
X *
X *	EXPORT:
X *	af_lock -- lock busy version
X *	af_unlock -- unlock version
X *	af_testlock -- test if version is locked
X */
X
X#include <stdio.h>
X#include <string.h>
X#ifdef SUNOS_4_0
X#include <strings.h>
X#endif
X#include <sys/types.h>
X#include <sys/stat.h>
X
X#include "typeconv.h"
X#include "afsys.h"
X#include "afs.h"
X#include "afarchive.h"
X
X/*================================================================
X *	af_lock
X *
X *================================================================*/
X
XEXPORT Af_user *af_lock (key, locker, mode)
X     Af_key  *key;
X     Af_user *locker;
X     int     mode;
X{
X  int oldlockeruid, newlockeruid, calleruid;
X  Af_key lkey, *lkp;
X
X  if (af_keytest (key))
X    SFAIL ("lock", "", AF_EINVKEY, (Af_user *)0);
X  
X  if ((VATTR(key).af_mode & S_IFMT) != S_IFREG)
X    SFAIL ("lock", "", AF_ENOTREGULAR, (Af_user *)0);
X
X  if (VATTR(key).af_class & AF_DERIVED)
X    SFAIL ("lock", "", AF_EDERIVED, (Af_user *)0);
X
X  /* if caller == locker, everyone who has write access may set a lock, */
X  /*                      if the object is not locked by someone else */
X  /* else (caller != locker), only the owner may set a lock for someone else */
X
X  newlockeruid = af_getuid (locker->af_username, locker->af_userhost);
X  calleruid = getuid ();
X
X  if (calleruid == newlockeruid)
X    {
X      if (af_checkperm (key, AF_WORLD) == ERROR)
X	return ((Af_user *)0);
X    }
X  else
X    {
X      if (af_checkperm (key, AF_OWNER) == ERROR)
X	return ((Af_user *)0);
X    }
X
X  lkp = &lkey;
X  lkp->af_ldes = key->af_ldes;
X  if (mode == AF_VERSIONLOCK)
X    lkp->af_lpos = key->af_lpos;
X  else
X    lkp->af_lpos = 0;
X
X  /* if version is not locked or already locked by caller */
X  oldlockeruid = af_getuid (VATTR(lkp).af_lckname, VATTR(lkp).af_lckhost);
X
X  if ((oldlockeruid == (Uid_t) ERROR) || (oldlockeruid == calleruid))
X    {
X      VATTR(lkp).af_lckname = af_entersym (locker->af_username);
X      VATTR(lkp).af_lckhost = af_enterhost (locker->af_userhost);
X      VATTR(lkp).af_ltime = (time_t) af_acttime();
X      if (af_updtvers (lkp, AF_CHANGE) == ERROR)
X	return ((Af_user *)0);
X      return (locker);
X    }
X  else
X    SFAIL ("lock", "", AF_ENOTLOCKED, (Af_user *)0);
X}
X
X/*================================================================
X *	af_unlock
X *
X *================================================================*/
X
XEXPORT Af_user *af_unlock (key, mode)
X     Af_key *key;
X     int    mode;
X{
X  static Af_user locker;
X  Af_key lkey, *lkp;
X
X  if (af_keytest (key))
X    SFAIL ("unlock", "", AF_EINVKEY, (Af_user *)0);
X
X  if (af_checkperm (key, AF_OWNER | AF_LOCKHOLDER) == ERROR)
X    return ((Af_user *)0);
X
X  lkp = &lkey;
X  lkp->af_ldes = key->af_ldes;
X  if (mode == AF_VERSIONLOCK)
X    lkp->af_lpos = key->af_lpos;
X  else
X    lkp->af_lpos = 0;
X
X  if (VATTR(lkp).af_lckname != (char *)0)
X    {
X      (void) strcpy (locker.af_username, VATTR(lkp).af_lckname);
X      (void) strcpy (locker.af_userhost, VATTR(lkp).af_lckhost);
X      VATTR(lkp).af_lckname = (char *)0;
X      VATTR(lkp).af_lckhost = (char *)0;
X      VATTR(lkp).af_ltime = (time_t) af_acttime();
X      if (af_updtvers (lkp, AF_CHANGE) == ERROR)
X	return ((Af_user *)0);
X    }
X  else
X    {
X      locker.af_username[0] = '\0';
X      locker.af_userhost[0] = '\0';
X    }
X  return (&locker);
X}
X
X/*================================================================
X *	af_testlock
X *
X *================================================================*/
X
XEXPORT Af_user *af_testlock (key, mode)
X     Af_key *key;
X     int    mode;
X{
X  static Af_user locker;
X  Af_key lkey, *lkp;
X
X  if (af_keytest (key))
X    SFAIL ("testlock", "", AF_EINVKEY, (Af_user *)0);
X
X  lkp = &lkey;
X  lkp->af_ldes = key->af_ldes;
X  if (mode == AF_VERSIONLOCK)
X    lkp->af_lpos = key->af_lpos;
X  else
X    lkp->af_lpos = 0;
X
X  if (VATTR(lkp).af_lckname != (char *)0)
X    {
X      (void) strcpy (locker.af_username, VATTR(lkp).af_lckname);
X      (void) strcpy (locker.af_userhost, VATTR(lkp).af_lckhost);
X    }
X  else
X    {
X      locker.af_username[0] = '\0';
X      locker.af_userhost[0] = '\0';
X    }
X  return (&locker);
X}
X
X
END_OF_FILE
if test 5339 -ne `wc -c <'src/afs/aflock.c'`; then
    echo shar: \"'src/afs/aflock.c'\" unpacked with wrong size!
fi
# end of 'src/afs/aflock.c'
fi
if test -f 'src/afs/afsysc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/afs/afsysc.c'\"
else
echo shar: Extracting \"'src/afs/afsysc.c'\" \(4951 characters\)
sed "s/^X//" >'src/afs/afsysc.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X/*
X *	Shape/AFS
X *
X *	afsysc.c -- Isolate syscalls for portability 
X *
X *	Author: Andreas Lampen, TU-Berlin (andy@coma.UUCP)
X *					  (andy@db0tui62.BITNET)
X *
X *	$Header: afsysc.c[1.3] Wed Feb 22 16:28:23 1989 andy@coma published $
X *
X *	EXPORT:
X *	af_syslink -- create a link to a file
X *      af_sysaccess -- determine accessibility of file
X *	af_unlink -- remove file
X *      af_retfsize -- return file size
X *      af_uchown -- change owner
X *      af_uchmod -- change mode
X *      af_gethostname -- get host name
X *      af_asctime -- get time as ascii string
X *      af_acttime -- get actual time
X *      af_cvttime -- convert time
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <sys/file.h>
X#include <sys/time.h>
X
X#include "typeconv.h"
X#include "afsys.h"
X#include "afs.h"
X
X/*================================================================
X *	af_syslink
X *
X *================================================================*/
X
XEXPORT af_syslink (existfile, newfile)
X     char *existfile, *newfile;
X{
X  if (link (existfile, newfile) == ERROR)
X    return (ERROR);
X  return (AF_OK);
X} /* af_syslink */ 
X
X/*================================================================
X *	af_sysaccess
X *
X *================================================================*/
X
XEXPORT af_sysaccess (path, mode)
X     char *path;
X     int  mode;
X{
X  return (access (path, mode));
X} /* af_syslink */ 
X
X/*================================================================
X *	af_unlink
X *
X *================================================================*/
X
XEXPORT af_unlink (file)
X     char *file;
X{
X  return (unlink (file));
X} /* af_unlink */ 
X
X/*================================================================
X *	af_retfsize
X *
X *================================================================*/
X
XEXPORT off_t af_retfsize (file)
X     char *file;
X{
X  struct stat ibuf;
X  
X  (void) lstat (file, &ibuf);
X  return (ibuf.st_size);
X} /* af_retfsize */ 
X
X/*================================================================
X *	af_uchown
X *
X *================================================================*/
X
XEXPORT af_uchown (file, uid, gid)
X     char *file;
X     int uid, gid;
X{
X  if (chown (file, uid, gid) == ERROR)
X    return (ERROR);
X  return (AF_OK);
X} /* af_uchown */
X
X
X/*================================================================
X *	af_uchmod
X *
X *================================================================*/
X
XEXPORT af_uchmod (file, mode)
X     char *file;
X     int  mode;
X{
X  if (chmod (file, mode) == ERROR)
X    return (ERROR);
X  return (AF_OK);
X} /* af_uchmod */
X
X
X/*================================================================
X *	af_gethostname
X *
X *================================================================*/
X
Xstatic char *hostsym = (char *)0;
X
XEXPORT char *af_gethostname ()
X{
X  char hostname[MAXHOSTNAMELEN];
X
X  if (!hostsym)
X    {
X      (void) gethostname (hostname, MAXHOSTNAMELEN);
X      hostsym =  af_entersym (hostname);
X    }
X  return (hostsym);
X} /* af_uchmod */
X
X/*================================================================
X *	af_asctime
X *
X *================================================================*/
X
XEXPORT char *af_asctime ()
X{
X  char *asctime();  
X  long seconds, time();
X
X  seconds = time ((long *)0);
X  return (asctime (localtime (&seconds)));
X}
X
X/*================================================================
X *	af_acttime -- return actual time (in seconds after ...)
X *
X *================================================================*/
X
XEXPORT af_acttime ()
X{
X  struct timeval tm;
X  struct timezone tz;
X
X  (void) gettimeofday (&tm, &tz);
X
X  return (tm.tv_sec);
X}
X
X/*================================================================
X *	af_cvttime -- convert time from inode
X *
X *================================================================*/
X
XEXPORT af_cvttime (time)
X     time_t time;
X{
X  return (time);
X}
END_OF_FILE
if test 4951 -ne `wc -c <'src/afs/afsysc.c'`; then
    echo shar: \"'src/afs/afsysc.c'\" unpacked with wrong size!
fi
# end of 'src/afs/afsysc.c'
fi
if test -f 'src/afs/bsfd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/afs/bsfd.c'\"
else
echo shar: Extracting \"'src/afs/bsfd.c'\" \(4694 characters\)
sed "s/^X//" >'src/afs/bsfd.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X/* ================================================== */
X/* ================================================== */
X/*                                                    */
X/* MODULE-NAME: bsfd        KEY : bs                  */
X/*              = build string from delta             */
X/*                                                    */
X/* ORIGINAL                                           */
X/* AUTHOR : sibylle         DATE: 15/06/87            */
X/*                                                    */
X/* LAST UPDATE                                        */
X/* AUTHOR :                 DATE:                     */
X/*                                                    */
X/* VERSION: 1.6.1                                     */
X/*                                                    */
X/* ================================================== */
X/*                                                    */
X/* PURPOSE:                                           */
X/*                building a string from a delta      */
X/*                and writing it into a targetfile    */
X/*                                                    */
X/* SPECIALITIES:                                      */
X/*                none                                */
X/*                                                    */
X/* EXCEPTIONS, ERRORS:                                */
X/*                none                                */
X/*                                                    */
X/* ================================================== */
X/*                                                    */
X/*
X * $Header: bsfd.c[1.0] Wed Feb 22 16:14:33 1989 shape@coma save $
X */
X
X
X# include "predef.h"
X# include <stdio.h>
X# include "edcmd.h"
X# include "typeconv.h"
X
Xextern char *malloc();
Xextern char *calloc();
Xextern int free();
Xextern int fwrite();
Xextern int fclose();
Xextern FILE *fopen();
X
X
XLOCAL char *src_str = NIL;
XLOCAL long src_size = (long) 0;
XLOCAL char *dlt_str = NIL;
XLOCAL char *dlt_pnt = NIL;
XLOCAL long dlt_size = (long) 0;
X
X	      
X
XLOCAL void move_to_target (cmd, indx, ftrg)
X     struct ed_cmd *cmd;
X     long indx;
X     FILE *ftrg;
X{
X  char *str_addr = src_str;
X
X  (void) fwrite ((str_addr = (str_addr + indx)), sizeof(char), (Size_t)cmd->length, ftrg);
X  return;
X}
X
X
XLOCAL void add_to_target (cmd, ftrg)
X     struct ed_cmd *cmd;
X     FILE *ftrg;
X{
X  (void) fwrite (dlt_pnt, sizeof(char), (Size_t)cmd->length, ftrg);
X  dlt_pnt += cmd->length;
X  return;
X}
X
X
XLOCAL Bool build_string (trg_fn)
X     char *trg_fn;
X{
X  FILE *ftarg;
X  struct ed_cmd cmd;
X  long indx;
X
X  if ((ftarg = fopen(trg_fn, "w")) == (FILE *) NIL)
X    return (FALSE);
X
X  if (dlt_size == (long) 0)
X    {
X      cmd.cmd = MV;
X      cmd.length = src_size;
X      indx = (long) 0;
X      move_to_target (&cmd, indx, ftarg);
X      (void) fclose (ftarg);
X      
X      return (TRUE);
X     }
X
X  while (dlt_pnt < (dlt_str + dlt_size))
X    {
X      bcopy (dlt_pnt, (char *)&cmd, sizeof (cmd));
X      dlt_pnt += sizeof (cmd);
X      if (cmd.cmd == MV)
X	{
X	  bcopy (dlt_pnt, (char*)&indx, sizeof (indx));
X	  dlt_pnt += sizeof (indx);
X	  move_to_target (&cmd, indx, ftarg);
X	}
X      else 
X	{
X	  if (cmd.cmd == AD)
X	    add_to_target (&cmd, ftarg);
X	  else
X	    return (FALSE);
X	}
X    }
X  
X  (void) fclose(ftarg);
X  return(TRUE);
X}
X      
X
XEXPORT bsfd (sourcestr, deltastr, sourcesize, deltasize, targetfn)
X     char *sourcestr, *deltastr;
X     long sourcesize, deltasize;
X     char *targetfn;
X{
X  src_str = sourcestr;
X  src_size = sourcesize;
X  dlt_str = deltastr;
X  dlt_size = deltasize;
X  dlt_pnt = dlt_str;
X
X  if (!(build_string(targetfn)))
X    return (-1);
X
X  return (0);
X}
END_OF_FILE
if test 4694 -ne `wc -c <'src/afs/bsfd.c'`; then
    echo shar: \"'src/afs/bsfd.c'\" unpacked with wrong size!
fi
# end of 'src/afs/bsfd.c'
fi
if test -f 'src/shape/hash.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/shape/hash.c'\"
else
echo shar: Extracting \"'src/shape/hash.c'\" \(4626 characters\)
sed "s/^X//" >'src/shape/hash.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *RCSid = "$Header: hash.c,v 3.0 89/01/24 11:35:41 wolfgang Stable $";
X#endif
X#ifndef lint
Xstatic char *ConfFlg = CFFLGS;	/* should be defined from within Makefile */
X#endif
X/*
X * $Log:	hash.c,v $
X * Revision 3.0  89/01/24  11:35:41  wolfgang
X * New System Generation
X * 
X * Revision 2.7  89/01/03  13:10:39  wolfgang
X * changes done for lint
X * 
X * Revision 2.6  88/12/21  15:03:22  wolfgang
X * changes done for lint
X * 
X * Revision 2.5  88/11/21  15:49:16  wolfgang
X * return code of all malloc's checked
X * 
X * Revision 2.4  88/08/23  16:40:12  wolfgang
X * This version is part of a release
X * 
X * Revision 2.3  88/08/23  14:39:29  wolfgang
X * In dump(fd) the printing of special macros is now suppressed.
X * 
X * Revision 2.2  88/08/22  17:00:57  wolfgang
X * Procedure dump() change to dump(fd) to be able to use it for the
X * construction of confid's.
X * 
X * Revision 2.1  88/08/19  10:17:28  wolfgang
X * This version is part of a release
X * 
X */
X
X#include "hash.h"
X#include "shape.h"
X
X#include <stdio.h>
X
Xhashval(name)
X     char *name;
X{
Xint hash = 0;
Xint i = 0;
X
Xfor(; name[i] != '\0'; i++)
X  hash = hash + name[i];
Xreturn(hash % HASHSIZE);
X} /* end hashval */
X
X
Xvoid addhash(hashv, name, value)
X     int hashv;
X     char *name;
X     char *value;
X{
X
Xstruct hash *current;
X  
Xif (hashtab[hashv] == (struct hash *) NIL)
X  {
X    if ((current = hashtab[hashv] = (struct hash *) malloc(sizeof(struct hash))) == (struct hash *) NIL)
X      errexit(10,"malloc");
X    current->name = NIL;
X    current->entry = NIL;
X    current->next = (struct hash *)NIL;
X  }
Xelse
X  current = hashtab[hashv];
X
Xif (current->name == NIL)
X  {
X    if ((current->entry = malloc ( (unsigned) strlen(value) + sizeof(char))) == NIL)
X      errexit(10,"malloc");
X    if((current->name = malloc ( (unsigned) strlen(name) + sizeof(char))) == NIL)
X      errexit(10,"malloc");
X    (void) strcpy(current->entry, value);
X    (void) strcpy(current->name, name);
X    return;
X  }
Xelse
X  {
X    while ((strcmp (current->name, name) != 0) &&
X	   (current->next != (struct hash *)NIL))
X      current = current->next;
X
X    if(strcmp (current->name, name) == 0)
X      {
X	current->entry = realloc (current->entry,
X				  (unsigned) (strlen(value) + sizeof(char)));
X	(void) strcpy(current->entry, value);
X	return;
X      }
X
X    if(current->next == (struct hash *)NIL)
X      {
X	if ((current = current->next = (struct hash *) malloc(sizeof (struct hash))) == (struct hash *) NIL)
X	  errexit(10,"malloc");
X	if((current->entry = malloc ( (unsigned) strlen (value) + sizeof(char))) == NIL)
X	  errexit(10,"malloc");
X	if((current->name = malloc ((unsigned) strlen (name) + sizeof(char))) == NIL)
X	  errexit(10,"malloc");
X	current->next = (struct hash *) NIL;
X	(void) strcpy(current->name, name);
X	(void) strcpy(current->entry, value);
X	return;
X      }
X  }
Xreturn;
X} /* end addhash */
X
X
Xdump(fd)
X     FILE *fd;
X{
Xint i;
Xstruct hash *current;
X
Xfprintf(fd,"# Macros:\n");
X
Xfor(i = 0; i < HASHSIZE; i++)
X  {
X    if (hashtab[i] != (struct hash *) NIL)
X      {
X	current = hashtab[i];
X	while(current != (struct hash *) NIL)
X	  {
X
X	    if((current->name[0] != '$') &&
X	       (current->name[0] != '*') &&
X	       (current->name[0] != '+') &&
X	       (current->name[0] != '<') &&
X	       (current->name[0] != '?') &&
X	       (current->name[0] != '@'))
X	      {
X		if(fd != stdout)
X		  {
X		    fprintf(fd,"%s = %s\n", current->name, current->entry);
X		  }
X		else
X		  {
X		    fprintf(fd,"\t%s = %s\n", current->name, current->entry);
X		  }
X	      }
X	    current = current->next;
X
X	  }
X      }
X  }
X} /* end dump */
END_OF_FILE
if test 4626 -ne `wc -c <'src/shape/hash.c'`; then
    echo shar: \"'src/shape/hash.c'\" unpacked with wrong size!
fi
# end of 'src/shape/hash.c'
fi
if test -f 'src/shape/shape.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/shape/shape.h'\"
else
echo shar: Extracting \"'src/shape/shape.h'\" \(4910 characters\)
sed "s/^X//" >'src/shape/shape.h' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X/*
X * $Log:	shape.h,v $
X * Revision 3.0  89/01/24  11:36:09  wolfgang
X * New System Generation
X * 
X * Revision 2.14  88/12/21  15:11:02  wolfgang
X * changes done for lint
X * 
X * Revision 2.13  88/12/19  13:22:04  wolfgang
X * bpoolflg, nobpoolflg, forceflg added.
X * 
X * Revision 2.12  88/11/08  11:02:39  wolfgang
X * explg & noexpflg added.
X * 
X * Revision 2.11  88/11/02  13:30:20  wolfgang
X * This version is part of a release
X * 
X * Revision 2.10  88/10/14  17:12:12  wolfgang
X * changes don for new handling of variants: struct vardefs.
X * 
X * Revision 2.9  88/09/22  16:15:45  wolfgang
X * struct linkreg changed: member newfn added.
X * 
X * Revision 2.8  88/09/15  17:25:27  wolfgang
X * struct varclass changed: int active added.
X * 
X * Revision 2.7  88/08/23  15:34:53  wolfgang
X * rebuildflg added.
X * 
X * Revision 2.6  88/08/22  10:16:40  wolfgang
X * Added constant: nostdfile (indicates that no standard input file has been
X * found).
X * 
X * Revision 2.5  88/08/19  14:09:46  wolfgang
X * *** empty log message ***
X * 
X * Revision 2.4  88/08/18  10:25:55  wolfgang
X * This version is part of a release
X * 
X * Revision 2.3  88/08/12  08:58:17  wolfgang
X * This version is part of a release
X * 
X */
X
X
Xtypedef int Bool;
X
X#define TRUE 1
X#define FALSE 0
X#define VOID int
X#define EOL '\n'
X#define EOS '\0'
X#define NIL ((char *) 0)
X
X#include "afs.h"
X#include <strings.h>
X
X#define SMILEY -1
X#define GRIMMY -2
X
Xextern int af_errno;
X
Xextern char *rindex();
Xextern char *index();
Xextern char *malloc();
Xextern char *realloc();
X
Xextern int errexit();
X
Xextern Bool pattern();
Xextern Bool attr();
Xextern Bool attrnot();
Xextern Bool attrvar();
Xextern Bool attrnotvar();
Xextern Bool attrlt();
Xextern Bool attrgt();
Xextern Bool attrle();
Xextern Bool attrge();
Xextern Bool attrmin();
Xextern Bool attrmax();
Xextern Bool getfromcid();
Xextern Bool msg();
Xextern Bool stopit();
Xextern Bool tunix();
X
X#define ATTRNAME "__ATTRS__="
X#define MAXATTRLENGTH 10000
X
X#define MAX_ATTR 10000
X#define MAXDEPTH 10
X
X#define MAXPATHLIST 256
Xextern char *pathlist[MAXPATHLIST][2];
Xextern int lastpath;
X
Xextern char *curvpath[];
X
Xextern char rbrule[];
Xextern char rbfile[];
X
XBool debugflg;
XBool envflg;
XBool fileflg;
XBool nostdfile;
XBool ignoreflg;
XBool goflg;
XBool noexflg;
XBool printflg;
XBool questflg;
XBool ruleflg;
XBool silentflg;
XBool touchflg;
XBool stdinflg;
XBool confid;
XBool rebuildflg;
XBool stopflg;
XBool tunixflg;
XBool logflg;
XBool expflg;
XBool noexpflg;
X
XBool bpoolflg;
XBool nobpoolflg;
XBool forceflg;
X
XFILE *cid;
XFILE *logfd;
X
XBool doublecolon;
Xextern Bool suffs_deleted;
X
Xstruct linked_list {
X  char *string;
X  struct linked_list *nextstring;
X};
X
Xstruct hash
X{
X  char *name;
X  char *entry;
X  struct hash *next;
X};
X
Xextern struct hash *hashtab[];
X
Xstruct cmds
X{
X  char *command;
X  struct cmds *nextcmd;
X};
X
X#define MAXTARGS 128
X#define MAXHERIT 32
X#define MAXDEPS 256
X#define MAXCMDS 32
Xstruct rules
X{
X  char *name;
X  Af_set date;
X  Bool done;
X  Bool doublecolon;
X  char *firstdep;                 /* possibly selection rule name */
X  char *deplist[MAXDEPS];
X  char *heritage[MAXHERIT];
X  char *targetlist[MAXHERIT];
X  struct cmds *cmdlist;
X  struct rules *nextrule;
X};
X
Xextern struct rules *ruletab[];
Xextern struct rules *stdruletab[];
Xextern int lastrule;    /* index of last std rule */
X
Xstruct list
X{
X  int (*selfunc)();
X  char *parn;
X  char *parv;
X  int i;
X  struct list *cont;
X};
X
Xextern struct selection_rules *sels[];
X
X
Xstruct linkreg {
X  char *fn;
X  char *newfn;
X  Bool busy_exist;
X  struct linkreg *next;
X};
X
X#define MAXVARIANTS 32
X#define MAXVMACROS 32 
X
Xstruct vardef {
X  char *name;
X  char *vmacros[MAXVMACROS];
X  char *vflags;
X  char *vpath;
X};
X
Xstruct varclass {
X  char *name;
X  int active;
X  char *variants[MAXVARIANTS];
X};
X
X#define MAXPREDS 32
X
Xstruct selection_rules
X{
X  char *name;
X  struct list *predlist[MAXPREDS];
X  struct selection_rules *next;
X};
X
END_OF_FILE
if test 4910 -ne `wc -c <'src/shape/shape.h'`; then
    echo shar: \"'src/shape/shape.h'\" unpacked with wrong size!
fi
# end of 'src/shape/shape.h'
fi
if test -f 'src/vc/vc_files.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/vc/vc_files.c'\"
else
echo shar: Extracting \"'src/vc/vc_files.c'\" \(4862 characters\)
sed "s/^X//" >'src/vc/vc_files.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *AFSid = "$Header: vc_files.c[1.9] Thu Feb 23 18:14:30 1989 axel@coma published $";
X#ifdef CFFLGS
Xstatic char *ConfFlg = CFFLGS;
X	/* should be defined from within Makefile */
X#endif
X#endif
X/*
X * Log for /u/shape/dist-tape/src/vc/vc_files.c[1.6]
X * 	Thu Feb 23 18:14:30 1989 axel@coma published $
X *  --- empty log message ---
X *  vc_files.c[1.7] Thu Feb 23 18:14:30 1989 axel@coma published $
X *  --- empty log message ---
X *  vc_files.c[1.8] Thu Feb 23 18:14:30 1989 axel@coma save $
X *  --- empty log message ---
X *  vc_files.c[1.9] Thu Feb 23 18:14:30 1989 axel@coma published $
X *  --- empty log message ---
X */
X
X/*
X *
X * Functions to find, check for permission, and remote files.
X * This functions are highly operation system dependend.
X *
X * Currently this function are BSD43- and Ultrix1.0-proof. 
X *
X * Exports:
X *
X *   All functions described below return 1 for success or
X *   0 on failure. If return type is not "int" then on failure
X *   "(type-cast) NULL" is returned. See also descriptions below.
X *
X *   int GroupMember (gid)     WARNING: NOT ULTRIX COMPATIBLE
X *       int gid;
X *
X *         Checks if user is member of group gid.
X *
X *   int FileExecutable (file)
X *       char *file;
X *
X *   char *FindFile (file)
X *        char *file;
X *
X *        Returns the full absolute path name of file "file", if
X *        "file" exists. NULL otherwise. Searches the directories
X *        given in environment variable PATH. If path is not set,
X *        current working directory and "/bin" are checked.
X *
X *   char *FindProgram (file)
X *        char *file;
X *
X *        Acts as function FindFile(), but file must also be
X *        executable for caller.
X *
X *   RemoveFile (file)
X *        char *file;
X *
X *   int FileExists (file)
X *       char *file;
X */
X
X#include <sys/param.h>
X#include <sys/stat.h>
X#include <sys/file.h>
X#include <stdio.h>
X#include <strings.h>
X#include <afs.h>
X#include "afsapp.h"
X#include "locks.h"
X#include "vc_sysdep.h"
X
Xextern char *malloc(), *getenv();
X
X/**/
Xint FileExecutable (file)
X     char *file;
X{
X  return access (file, (X_OK | F_OK)) == -1 ? 0 : 1;
X}
X
X/**/
Xchar *FindFile (file)
X     char *file;
X{
X  char *path;
X  char *dir, *edir;
X  char *this;
X  int flen;			/* length of "file" */
X  flen = strlen (file) + 1;	/* for the good old null byte */
X  this = NULL;
X
X  /* get path from enivronment */
X  if (!(path = getenv (PATH_ENV_NAME)))
X    path = DEFAULT_PATH;
X
X  while (1) {
X    
X    if ((dir = path) == NULL)
X      return NULL;
X
X    /* find end of dir in string */
X    if (edir = index(path, ':')) {
X      *edir = '\0';		/* make "dir" null terminated */
X      path = edir + 1;		/* path points to next dir */
X    }
X    else
X      path = NULL;		/* end of path reached */
X
X    if (this) free (this);	/* no longer needed */
X
X    if ((this = malloc ((unsigned)(strlen (dir) + flen))) == NULL) {
X      fprintf (stderr, "FindFile(): can't malloc\n");
X      exit (1);
X    }
X
X    /* file found ? */
X    (void)sprintf (this, "%s/%s", dir, file);	/* construct new filename */
X    if (FileExists (this))
X      return this;		/* found */
X  }
X}
X  
Xchar *FindProgram (program)
X     char *program;
X{
X  /*
X   * returns the full pathname of "program", iff program is found
X   * and executable (for world). Otherwise NULL.
X   */
X
X  /* if program has already a '/' in it, asume existence */
X  if (!index (program, '/'))
X    if ((program = FindFile (program)) == NULL)
X      return NULL;		/* not found */
X
X  /* prg contains the absolute file name and file exists.*/
X  if (FileExecutable (program))
X    return program;
X  else
X    return NULL;
X}
X
XRemoveFile (file)
X     char *file;
X{
X  (void)unlink (file);
X}
X
XFileExists (file)
X     char *file;
X{
X  /*
X   * Returns 1 iff file exists, 0 otherwise.
X   */
X  struct stat sbuf;
X  
X  return !stat (file, &sbuf);
X}
X
END_OF_FILE
if test 4862 -ne `wc -c <'src/vc/vc_files.c'`; then
    echo shar: \"'src/vc/vc_files.c'\" unpacked with wrong size!
fi
# end of 'src/vc/vc_files.c'
fi
if test -f 'src/vc/vc_lock.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/vc/vc_lock.c'\"
else
echo shar: Extracting \"'src/vc/vc_lock.c'\" \(4964 characters\)
sed "s/^X//" >'src/vc/vc_lock.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *AFSid = "$Header: vc_lock.c[3.7] Thu Feb 23 18:14:33 1989 axel@coma published $";
X#ifdef CFFLGS
Xstatic char *ConfFlg = CFFLGS;
X	/* should be defined from within Makefile */
X#endif
X#endif
X/*
X * Log for /u/shape/dist-tape/src/vc/vc_lock.c[3.4]
X * 	Thu Feb 23 18:14:33 1989 axel@coma published $
X *  --- empty log message ---
X *  vc_lock.c[3.5] Thu Feb 23 18:14:33 1989 axel@coma published $
X *  --- empty log message ---
X *  vc_lock.c[3.6] Thu Feb 23 18:14:33 1989 axel@coma save $
X *  --- empty log message ---
X *  vc_lock.c[3.7] Thu Feb 23 18:14:33 1989 axel@coma published $
X *  --- empty log message ---
X */
X
X/*LINTLIBRARY*/
X#define _VC_LOCK_
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <pwd.h>
X#include <strings.h>
X#include "afs.h"
X#include "afsapp.h"
X
XAf_user *vc_testlock (key, mode) Af_key *key; {
X  return af_testlock (key, mode);
X}
X
XAf_user *vc_lock (key, uid, mode) Af_key *key; Uid_t uid; {
X  Af_user alock;
X  struct passwd *pw;
X
X  pw = getpwuid ((int)uid);
X  if (pw) {
X    (void)strcpy (alock.af_username, pw->pw_name);
X    (void)gethostname (alock.af_userhost, MAXHOSTNAMELEN);
X    return af_lock (key, &alock, mode);
X  }
X  else {
X    return NULL;
X  }
X}
X
XAf_user *vc_unlock (key, mode) Af_key *key; {
X  Af_user *waslocker;
X  
X  waslocker = af_unlock (key, mode);
X  if (waslocker) {
X    if (af_rstate (key) == AF_BUSY)
X      af_sudattr (key, AF_REMOVE, INTENT);
X  }
X  return waslocker;
X}
X
Xchar *lockerid (lock) Af_user *lock; {
X  static char rst[256];
X
X  rst[0] = '\0';
X  if (lock) {
X    (void)sprintf (rst, "%s@%s", lock->af_username, lock->af_userhost);
X  }
X  return rst;
X}
X
XUid_t lockeruid (lock) Af_user *lock; {
X  char hostname[256];
X  struct passwd *pw;
X
X  if (!lock) return -1;
X  (void)gethostname (hostname, 256);
X
X  if (strcmp (hostname, lock->af_userhost) == 0) {
X    pw = getpwnam (lock->af_username);
X    if (pw)
X      return pw->pw_uid;
X    else 
X      return -1;
X  }
X  else 
X    return -1;
X}
X
Xint locked (lock) Af_user *lock; {
X  if (!lock) return 1;
X  return lock->af_username[0];
X}
X
Xchar *getintent (prompt, oldintent) char *prompt, *oldintent; {
X  char *tmpname, *mktemp(), *edname, cmd[128], *getenv(), messg[80], *malloc();
X  static char *notetxt;
X  FILE *tmpfil;
X  struct stat statbuf;
X  static int firsttime = TRUE;
X
X  if (!(isatty(fileno(stdin)))) {
X    return oldintent ? oldintent : EMPTYINTENT;
X  }
X  if ((!firsttime) && notetxt) {
X    if (ask_confirm ("Same intent as before ?", "yes")) {
X      return notetxt;
X    }
X    else {
X      free (notetxt);
X    }
X  }
X  firsttime = FALSE;
X  if (!ask_confirm (prompt, "yes"))
X    return oldintent ? oldintent : EMPTYINTENT;
X  tmpname = mktemp ("/tmp/afsXXXXXX");
X  Register (tmpname, TYPEF);
X  if (oldintent) {
X    FILE *t = fopen (tmpname, "w");
X    if (fwrite (oldintent, sizeof (char), (Size_t)strlen (oldintent), t) !=
X	strlen (oldintent)) {
X      logerr ("write failure on tmp-file");
X    }
X    (void)fclose (t);
X  }
X  if (edname = getenv ("EDITOR")) {
X    (void)sprintf (cmd, "%s %s", edname, tmpname);
X    (void)sprintf (messg, "starting up %s ...", edname);
X    logmsg (messg);
X    if (system (cmd) == NOSHELL) {
X      logerr ("couldn't execute shell");
X    }
X    else {
X      if ((tmpfil = fopen (tmpname, "r")) == NULL) {
X	logerr ("empty intent description");
X	return EMPTYINTENT;
X      }
X      else {
X	if (fstat (fileno(tmpfil), &statbuf) == -1) {
X	  perror ("couldn't stat");
X	}
X	else {
X	  notetxt = malloc ((unsigned)statbuf.st_size);
X	  if (!notetxt) {
X	    logerr ("not enough memory for intent text.");
X	  }
X	  (void)fread (notetxt, sizeof (char), 
X		       (Size_t)statbuf.st_size, tmpfil);
X	  (void)fclose (tmpfil);
X	  (void)unlink (tmpname);
X	  UnRegister (tmpname, TYPEF);
X	  return notetxt;
X	}
X      }
X    }
X  }
X  logerr 
X   ("You must set the EDITOR environment variable to write a note of intent.");
X  return EMPTYINTENT;   /* maybe we should try to read from stdin */
X}
END_OF_FILE
if test 4964 -ne `wc -c <'src/vc/vc_lock.c'`; then
    echo shar: \"'src/vc/vc_lock.c'\" unpacked with wrong size!
fi
# end of 'src/vc/vc_lock.c'
fi
echo shar: End of archive 6 \(of 33\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
