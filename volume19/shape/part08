Subject:  v19i021:  A software configuration management system, Part08/33
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Axel Mahler <unido!coma!axel>
Posting-number: Volume 19, Issue 21
Archive-name: shape/part08



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 8 (of 33)."
# Contents:  man/man1/sbmt.1 man/man1/vfind.1 src/afsit/afsit.1
#   src/vc/sighand.c src/vc/util.c src/vc/vadm_gkeys.c
# Wrapped by rsalz@papaya.bbn.com on Thu Jun  1 19:26:56 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'man/man1/sbmt.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/man1/sbmt.1'\"
else
echo shar: Extracting \"'man/man1/sbmt.1'\" \(7936 characters\)
sed "s/^X//" >'man/man1/sbmt.1' <<'END_OF_FILE'
X...
X... Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X...  and U. Pralle
X... 
X... This software is published on an as-is basis. There is ABSOLUTELY NO
X... WARRANTY for any part of this software to work correctly or as described
X... in the manuals. We do not accept any liability for any kind of damage
X... caused by use of this software, such as loss of data, time, money, or 
X... effort.
X... 
X... Permission is granted to use, copy, modify, or distribute any part of
X... this software as long as this is done without asking for charge, and
X... provided that this copyright notice is retained as part of the source
X... files. You may charge a distribution fee for the physical act of
X... transferring a copy, and you may at your option offer warranty
X... protection in exchange for a fee.
X... 
X... Direct questions to: Tech. Univ. Berlin
X... 		     Wilfried Koch
X... 		     Sekr. FR 5-6 
X... 		     Franklinstr. 28/29
X... 		     D-1000 Berlin 10, West Germany
X... 
X... 		     Tel: +49-30-314-22972
X... 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X... 
X...
X... $Header: save.1[3.1] Thu Feb 23 18:13:51 1989 axel@coma published $
X... 
X... Log for /u/shape/dist-tape/src/vc/save.1[3.0]
X... 	Thu Feb 23 18:13:51 1989 axel@coma published $
X...  --- empty log message ---
X...  save.1[3.1] Thu Feb 23 18:13:51 1989 axel@coma published $
X...  --- empty log message ---
X...
X.TH SAVE 1 save \n(dy.\n(mo.\n(yr
X.SH NAME
Xsave \- save revision of a file
X.SH SYNOPSIS
X.IP \fBsave\fR \w'\fBSave++\fR'u
X[\ \fIoptions\fR\ ]\ files \.\|.
X.IP \fBSave\fR
X[\ \fIoptions\fR\ ]\ files \.\|.
X.IP \fBsbmt\fR
X[\ \fIoptions\fR\ ]\ files \.\|.
X.IP \fIOptions:\fR \w'\fIOptions:++\fR'u
X[\ \fB\-fhqu\fR\ ]\ [\ \fB\-a\ \fIafile\fR\ ] [\ \fB\-m\ \fImessage\fR\ ]
X[\ \fB\-n\ \fIname\fR\ ] [\ \fB\-p\ \fIprojectname\fR\ ] 
X.br
X[\ \fB\-setvnum\ \fIversion\fR\ ]
X[\ \fB\-t\ \fItextfile\fR\ ]\ [\ \fB\-unlock\fR\ ]\ [\ \fB\-version\fR\ ]
X.SH DESCRIPTION
X.PP
X\fISave\fR stores the current state of the specified files into 
Xarchive files and
Xassigns a unique \fIversion number\fR to the saved version. Versions
Xin archives are inalterable.
XAn archive will be created
Xin a subdirectory named \fIAFS\fR the first time a file saved.
XThe AFS subdirectory must be present.
XWhen an archive is created, save asks for the purpose
Xof the saved document. If a subsequent version is saved, the user
Xis prompted for a comment concerning the modifications.
XThe \fBsave\fR command requires that the object history corresponding
Xto the file to be saved is either \fIlocked\fR by the user
Xissuing the command or not locked at all.
XBefore a file is saved it will be checked whether it has actually 
Xchanged. If the file hasn't changed, the user will be asked if it
Xshould be saved anyway. The command line option \fB\-f\fR overrides the query.
XA newly created object version in the archive will be assigned the
Xstate \fIsaved\fR. This status marks the lowest level of quality,
Xsuggesting that the version is just saved for possible later retrieval 
Xbut may be inconsistent. Versions that meet higher quality standards
X(or are part of a release) should be marked by appropriate status
X(see \fBvadm\fR \-promote\fR or \fBsbmt\fR).
X.PP
XIf the program is invoked as \fBSave\fR (that is with capital-S) 
Xa \fInew generation\fR of the document history is initiated \-
Xprovided the programmer issuing the command has the permission to do this.
X.PP
XIf the program is invoked as \fBsbmt\fR, a newly created version
Xwill be set to status \fIpublished\fR. If the file to be saved
Xis unchanged with respect to the last saved version, the status
Xof the last saved version will be promoted to \fIpublished\fR.
X.LP
XIn complete detail, \fBsave\fR can be invoked with the following options:
X.IP \fB\-f\fR \w'\fB\-p\ \fIproject++\fR'u
Xforces a revision deposit (i.e. without asking), even if the busy
Xversion hasn't changed since the last time it was saved.
X.IP \fB\-h\fR
Xprint short information about usage of this command.
X.IP \fB\-q\fR
Xquiet operation. No messages are printed on standard output. 
XIf the busy version is unchanged, it will not be saved unless
X\fB\-f\fR is set. The user will not be prompted for a descriptive
Xnote. If no message or note is supplied with the command line 
X(see options \fB\-m\fR and \fB\-t\fR) the log
Xwill remain empty. This option is useful for batch operation.
X.IP \fB\-u\fR
Xunlock object history upon save. This option is identical to 
X\fB\-unlock\fR (see below).
X.IP \fB\-a\ \fIafile\fR
Xassign all the attributes specified in \fIafile\fR to the evolving
Xnew versions. Attributes must be given in the form \fIname=value\fR
Xwith one attribute specification per line and no white-space.
XWhile the attribute value is optional, the \fIequal\fR symbol must
Xbe present. If the \fB\-a\fR option is omitted, \fBsave\fR searches
Xthe environment for a variable \fISVATTRS\fR. If this variable
Xis absent, no user defined attributes will be assigned to the evolving
Xversions.
X.IP \fB\-m\ \fImessage\fR
Xsets \fImessage\fR as descriptive note for all document versions 
Xthat result from the invocation of \fBsave\fR. This option is alternative
Xto \fB\-t\fR which overrides \fB\-m\fR.
X.IP \fB\-n\ \fIname\fR
Xassigns a symbolic name \fIname\fR to the saved version. In more detail,
Xan attribute \fISYMNAME\fR is set to the value specified in \fIname\fR.
XThe specified symbolic name must not be assigned to any other version
Xwithin the same object history.
X.IP \fB\-p\ \fIproject\fR
Xspecifies the name of a project to provide a \fIproject context\fR
Xin which the save operation takes place. This project context may 
Xdetermine a number of addtional parameters that affect the overall
Xbehaviour of the save command. Such parameters might be
Xa set of standard attributes that are to be assigned to evolving versions
Xcertain permissions or some general project policy.
X.br
X\fHUNIMPLEMENTED FEATURE.\fR
X.IP \fB\-setvnum\ \fI<version>\fR
Xsets the version number of the newly created revision to \fIversion\fR.
XThe \fIversion\fR must be given in the format \fI<generation>.<revision>\fR
Xwhere \fIgeneration\fR and \fIrevision\fR are integers. Example:
X.RS
X.DS
X\fCsave -setvnum 4.3 mkattr.c\fR
X.DE
XThe specified \fIversion\fR must be greater than the highest previously
Xassigned version number in a given object history. \fB\-setvnum\fR
Xis useful for keeping consistent version numbering across related, physically
Xdifferent object bases, or for converting archive formats of other
Xrevision control systems to this toolkit (see: \fBrcs2afs\fR).
X.RE
X.IP \fB\-t\ \fIfile\fR
Xsets the text contained in \fIfile\fR as descriptive note for all document
Xversions that result from the invocation of \fBsave\fR. This option is
Xalternative to \fB\-m\fR which is superseded by \fB\-t\fR.
X.IP \fB\-unlock\fR
Xgives up the lock for the object history into which the new revision
Xof a file is saved. Upon unlocking the history, the user is prompted 
Xfor a description of the applied changes with the original \fIchange 
Xintent\fR (see \fBretrv \-lock\fR and \fBvadm -lock\fR) as initial
Xcomment. This comment might be edited appropriately. The change intention
Xis cleared afterwards.
X.IP \fB\-version\fR
Xprints the version of the program itself.
X.SH FILES
XAll revisions of documents are stored in archive files in the subdirectory
XAFS.
X.SH SEE ALSO
Xretrv(1), rsrv(1), sbmt(1), shape(1), vadm(1), vl(1), 
Xaf_intro(3), af_archive(5)
X.SH BUGS
XProject support is unimplemented.
X.PP
XSupport of user-defined attributes is rudimentary. Specification of such
Xattributes must be syntactically correct.
X.PP
X\fBsave\fR neither reads the \fIShapefile\fR nor the \fIMakefile\fR and
Xconsequently sticks with the 'individual document level' rather than to
Xsupport the saving of entire systems or subsystems (higer level targets
Xin \fI{Shape,Make}file\fRs).
X.SH AUTHOR
XAxel Mahler
X.br
XTechnical University Berlin
X.sp
X\fIUUCP:\fR		axel@coma.uucp (unido!coma!axel)
X.br
X\fIBITNET:\fR	axel@db0tui62
END_OF_FILE
if test 7936 -ne `wc -c <'man/man1/sbmt.1'`; then
    echo shar: \"'man/man1/sbmt.1'\" unpacked with wrong size!
fi
# end of 'man/man1/sbmt.1'
fi
if test -f 'man/man1/vfind.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/man1/vfind.1'\"
else
echo shar: Extracting \"'man/man1/vfind.1'\" \(7070 characters\)
sed "s/^X//" >'man/man1/vfind.1' <<'END_OF_FILE'
X...
X... Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X...  and U. Pralle
X... 
X... This software is published on an as-is basis. There is ABSOLUTELY NO
X... WARRANTY for any part of this software to work correctly or as described
X... in the manuals. We do not accept any liability for any kind of damage
X... caused by use of this software, such as loss of data, time, money, or 
X... effort.
X... 
X... Permission is granted to use, copy, modify, or distribute any part of
X... this software as long as this is done without asking for charge, and
X... provided that this copyright notice is retained as part of the source
X... files. You may charge a distribution fee for the physical act of
X... transferring a copy, and you may at your option offer warranty
X... protection in exchange for a fee.
X... 
X... Direct questions to: Tech. Univ. Berlin
X... 		     Wilfried Koch
X... 		     Sekr. FR 5-6 
X... 		     Franklinstr. 28/29
X... 		     D-1000 Berlin 10, West Germany
X... 
X... 		     Tel: +49-30-314-22972
X... 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X... 
X...
X... $Header: vfind.1[1.2] Tue Feb 21 20:23:01 1989 uli@coma published $
X...
X... Log for /u/shape/dist-tape/src/vfind/vfind.1[1.2]
X...	Tue Feb 21 20:23:01 1989 uli@coma published $
X... 	* This is the manual page for vfind.
X... 
X... 
X...
X.TH VFIND 1 "vfind1[1.2] published"
X.SH NAME
Xvfind \- find attributed software objects (aso)
X.SH SYNOPSIS
X\fBvfind\fR [\ \fIoptions\fR\ ] \fIpathname-list\ expression\fR
X.PP
X.SH DESCRIPTION
X\fBVfind\fR recursively descends the directory hierarchy for each pathname
Xin the pathname-list seeking asos that match a boolean expression
Xwritten in the primaries given below. In the description, the argument
X\fIn\fR is used as a decimal integer where \fI+n\fR means more than
X\fIn\fR, \fI\-n\fR means less than \fIn\fR and \fIn\fR means exactly
X\fIn\fR.
X.PP
XThe following \fIoptions\fR are recognized:
X.IP "\fB\-version\fR"
Xprint version information about the \fBvfind\fR program itself. No
Xother action given will be performed.
X.IP "\fB\-h\fR"
Xprint brief instructions about using \fBvfind\fR.
X.IP "\fB\-bpool\fR"
Xmatch a boolean expression also for aso residing in the \fIbinary
Xpool\fR.
X.IP "\fB\-prune\fR"
Xcauses \fBvfind\fR not to descend the filesystem hierarchy.
X.IP "\fB\-force\fR"
XfBVfind\fR normally ignores saved asos iff a AFS directory is a
Xsymbolic link. If the \fB\-force\R option is given \fBvfind\fR
Xtakes also symbolic AFS directories into consideration.
X.PP
XThe following \fIprimaries\fR are recognized:
X.IP "\fB\-atime\fR n"
XTrue if the aso has been accessed in \fIn\fR days.
X.IP "\fB\-ctime\fR n"
XTrue if status of the aso has been changed in \fIn\fR days.
X.IP "\fB\-mtime\fR n"
XTrue if the aso has been modified in \fIn\fR days.
X.IP "\fB\-stime\fR n"
XTrue if the aso has been saved in \fIn\fR days.
X.IP "\fB\-ltime\fR n"
XTrue if the aso has been locked in \fIn\fR days.
X.IP "\fB\-exec\fR command"
XTrue if the executed command returns a zero value as exit status. The
Xend of the command must be punctated by an ecscaped semicolon. A
Xcommand argument `{}' is replaced by the system name of the current aso.
X.IP "\fB\-vl\fR"
XAlways true; causes the current aso to be printed together with its
Xassociated statistics. This include protection mode, \fIAFS\fR version
Xstate, user, host, size in bytes, modification time respectively
Xsaving time. The format is identical to that of ``vl -l''.
X.IP "\fB\-name\fR name"
XTrue if the name argument matches the filename component of the
Xcurrent aso. Normal Shell argument syntax may be used if escaped.
X.IP "\fB\-perm\fR onum"
XTrue if the aso permission flags exactly match the octal numer
X\fIonum\fR. If \fIonum\fR is prefixed by a minus sign, more flag bits
X(017777) become significant and the flags are compared:
X\fI(flags&onum)==onum\fR.
X.IP "\fB\-print\fR"
XAlways true; causes the system path of the current aso to be printed.
X.IP "\fB\-symbolic\fR name"
XTrue if the current aso has the symbolic name \fIname\fR. See \fBvadm(1)\fR
Xor \fBsave(1)\fR on how to attach a symbolic name to an aso.
X.IP "\fB\-state\fR state"
XTrue if the state of the current aso matches state
X\fIstate\fR, where \fIstate\fR is \fBbusy\fR, \fBsave\fR, \fBproposed\fR,
X\fBpublished\fR, \fBaccessed\fR, or \fBfrozen\fR.
X.IP "\fB\-type\fR c"
XTrue if the type of the current aso is \fIc\fR, where c is \fBb\fR, \fBc\fR,
X\fBd\fR, \fBf\fR, \fBl\fR, or \fBs\fR for block special file,
Xcharacter special file, directory, plain file, symbolic link, or socket.
X.IP "\fB\-uda\fR uda"
XTrue if the current \fBaso\fR has an user defined attribute matching
Xuda \fIuda\fR, where \fIuda\fR is of the form \fIname[=value]\fR.
X.IP "\fB\-user\fR user"
XTrue if the current aso belongs to user \fIuser\fR, where \fIuser\fR is a
Xlogin name optinally followed by a host name (e.g. uli@coma).
X.IP "\fB\-locked\fR"
XTrue if the current aso is locked.
X.IP "\fB\-locker\fR user"
XTrue if the current aso is locked bye user \fIuser\fR, where
X\fIuser\fR is a login name optionally followed by a host name.
X.IP "\fB\-eq\fR vnum"
XTrue if the version number of the current aso matches version number
X\fIvnum\fR, where \fIvnum\fR is \fIgeneration.revision\fR.
X.IP "\fB\-lt\fR vnum"
XTrue if the version number of the current aso is less than the version number
X\fIvnum\fR.
X.IP "\fB\-le\fR vnum"
XTrue if the version number of the current aso is less equal than the
Xversion number \fIvnum\fR.
X.IP "\fB\-gt\fR vnum"
XTrue if the version number of the current aso is greater than the
Xversion number \fIvnum\fR.
X.IP "\fB\-ge\fR vnum"
XTrue if the version number of the current aso is greater equal than the
Xversion number \fIvnum\fR.
X.PP
XThe primaries may be combined using the operators \fB(\fR, \fB)\fR for
Xgrouping, \fB!\fR for negation, \fB\-a\fR for concatenation (may be
Xomitted) and \fB-o\fR for alternation of primaries. Parentheses and
Xthe exclamation mark are special to the Shell and must be escaped.
X.PP
X\fBvfind\fR does not descent AFS directories, so the AFS
Xarchives are never selected.
X.SH EXAMPLES
X.PP
XTo find all asos whose state is busy and that have the symbolic
Xname "foobar":
X.IP
Xvfind / \-state busy \-symbolic foobar \-print
X.IP
X.SH SEE ALSO
Xsave(1), retrv(1), sbmt(1), vl(1), shape(1), find(1), vadm(1),
Xaf_intro(3), af_archive(5)
X.PP
XRecommended reading: A. Mahler, A. Lampen, \fI\(lqAn Integrated
XToolkit for Engineering Software Configurations\(rq\fR, Proceedings of
Xthe ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical
XSoftware Development Environments, November 1988, Boston Mass. (to
Xbe published).
X.SH INCOMPATIBILITIES
XThe following \fBfind(1)\fR primaries are not recognized or implemented:
X-link, -nouser, -group, -nogroup, -size, -inum, -ok, and -xdev.
X.SH BUGS
XCommand line parsing is done with a simple handcoded parser and is not
Xwell tested. Pattern matching is done with \fIre_comp\fR and \fIre_exec\fR.
XPlease report bugs to the author or to shape-bugs@coma.UUCP.
X.SH AUTHOR
XUli Pralle
X.br
XTechnische Universit\*at Berlin
X.sp
X\fIUUCP:\fR		uli@coma.uucp (unido!coma!uli)
X.br
X\fIBITNET:\fR		uli@db0tui62
X
END_OF_FILE
if test 7070 -ne `wc -c <'man/man1/vfind.1'`; then
    echo shar: \"'man/man1/vfind.1'\" unpacked with wrong size!
fi
# end of 'man/man1/vfind.1'
fi
if test -f 'src/afsit/afsit.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/afsit/afsit.1'\"
else
echo shar: Extracting \"'src/afsit/afsit.1'\" \(7488 characters\)
sed "s/^X//" >'src/afsit/afsit.1' <<'END_OF_FILE'
X...
X... Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X...  and U. Pralle
X... 
X... This software is published on an as-is basis. There is ABSOLUTELY NO
X... WARRANTY for any part of this software to work correctly or as described
X... in the manuals. We do not accept any liability for any kind of damage
X... caused by use of this software, such as loss of data, time, money, or 
X... effort.
X... 
X... Permission is granted to use, copy, modify, or distribute any part of
X... this software as long as this is done without asking for charge, and
X... provided that this copyright notice is retained as part of the source
X... files. You may charge a distribution fee for the physical act of
X... transferring a copy, and you may at your option offer warranty
X... protection in exchange for a fee.
X... 
X... Direct questions to: Tech. Univ. Berlin
X... 		     Wilfried Koch
X... 		     Sekr. FR 5-6 
X... 		     Franklinstr. 28/29
X... 		     D-1000 Berlin 10, West Germany
X... 
X... 		     Tel: +49-30-314-22972
X... 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X... 
X...
X... $Header: afsit.1[1.1] Thu Feb 23 19:35:40 1989 axel@coma published $
X... 
X... Log for /u/shape/dist-tape/src/afsit/afsit.1[1.0]
X... 	Thu Feb 23 19:35:40 1989 axel@coma published $
X...  This program is derived from a helpful little program written by 
X...  M. Cooper. It is used to prepare files for version control. It
X...  inserts some magic cookies into the files, in order to provide version
X...  identification for them. The original program is called rcsit
X...  and has only be trained to add Header and Log citations in AFS-style
X...  when it is called 'afsit'. There are some other nice features, that
X...  rcsit provides but are not yet adjusted to AFS. This will probably
X...  happen in a later version. This particular program is just intended
X...  as a helpful little utility.
X...  
X...  afsit.1[1.1] Thu Feb 23 19:35:40 1989 axel@coma published $
X...  --- empty log message ---
X...
X...
X... $Header: rcsit.1,v 1.7 85/11/26 16:57:21 mcooper Exp $
X... 
X... $Log:	rcsit.1,v $
X... Revision 1.7  85/11/26  16:57:21  mcooper
X... Added documentation of option -F. See logentry in rcsit.c.
X...
X... Revision 1.7  85/11/26  16:57:21  mcooper
X... Noted changes to the -t option.
X... 
X... Revision 1.6  85/11/11  21:20:17  mcooper
X... Added AUTHOR.
X... 
X... Revision 1.5  85/11/11  20:13:39  mcooper
X... Added description of new Fortran recognition.
X... 
X... Revision 1.4  85/10/27  19:18:15  mcooper
X... Cleaned up table display.
X... 
X... Revision 1.3  85/10/27  14:55:22  mcooper
X... Added description of new template feature.
X... 
X... Revision 1.2  85/09/28  14:22:52  mcooper
X... Documented new features of checkdir (symbolic
X... linking and RCSDIR).
X... 
X... Revision 1.1  85/09/19  15:44:22  mcooper
X... Initial revision
X... 
X...
X.TH AFSIT 1l
X.SH NAME
Xafsit \- A program to prepare files for version control
X.SH SYNOPSIS
Xafsit
X[
X.B \-cFhfsmM
X] [
X.B \-qad
X] [
X\-I\fIflags\fR
X] [
X\-R\fIflags\fR
X] [
X\-t\fIdirectory\fR
X]
X.B file
X[
X.B file1, file2, ...
X]
X.SH DESCRIPTION
X.I Afsit
Xis a semi-intelligent program to prepare files for 
X.I shapetools version control.
XThis
Xinvolves putting the correct type of headings at the top of the file so
Xthat 
X.I retrv
Xwill update a header and log changes in the file.
X.PP 
XBy default, 
X.I afsit
Xwill use default headers ``hard-wired'' into itself for each different file
Xtype that it ``knows'' about.  (See below for list of known file types).
X.PP
XIf the \-t\fIdirectory\fR option is specified, then
X.I afsit
Xwill use ``.template.suffix'' files
X(where ``suffix'' is a suffix that 
X.I afsit
X``knows'' about)
Xfound in 
X.I directory.
XIf a directory name is not specified on the command line, then
Xthe environment variable TEMPLATES is used.
XIf $TEMPLATES is not set, then the environment varialble, HOME is tried.
X.LP
XThe following template files are recognized:
X.sp 2
X.in 10
X.nf
X Template Name               File Type
X -------------------------------------------
X .template.c                 Standard C
X .template.h                 C Include
X .template.f                 Fortran
X .template.sh                Shell Script
X .template.make              Makefile
X .template.man               Manual
X.sp 2
X.in -10
X.fi
X.PP
X.I Afsit
Xis ``semi-intelligent'' in that it can guess the type of headers to put in
Xthe file by the type of file (C program, C include, makefile, shell script,
Xor manual).
XIt determines the file type by looking at the name of the file.
XIf the name of the file is ``Makefile'' or ``makefile'', then the
Xfile type is taken to be for 
X.I make(1).
XThe suffix after the last ``.'' in the file name is then used.
XThe following table shows the suffixes that 
X.I afsit
Xknows about:
X.nf
X.sp 2
X.in 10
XSuffix         File Type
X---------------------------------------------
Xc              C Program
XF	       C Program (with compile flags)
Xh              C Include
Xf              Fortran
Xmk             \fIMake(1)\fR file
Xsh             Shell Script
Xcsh            Shell Script
X[1-9]          Manual (digits 1 - 9)
X.fi
X.PP
XIf the environement variable ``RCSDIR'' is present, then 
X.I afsit
Xwill attempt to make a symbolic link from it to ``RCS'' in
Xthe current directory if the \-\fII\fR option is used and
Xthere is no directory called ``RCS'' already, in the current
Xdirectory.  
XIf the \-\fII\fR option is used and ``RCSDIR'' is not specified
Xin the environment, then a normal directory called ``RCS'' will be
Xcreated.
XThis feature can be overrided with the \-\fId\fR option.
X.SH OPTIONS
X.TP 10
X.B "c"
XForce file type to be ``Standard C''.
X.TP 10
X.B "F"
XForce file type to be ``Standard C''. Add a special header-line for
Xrecording of compile-time options in addition to the default header.
XThe inserted line has the form \fCstatic char *ConfFlg = CFFLGS\fR.
XCFFLGS must be a string value. As it is very inconvenient, to define
Xthe proper value of CFFLGS from the command-line, this feature is 
Xmore intended to be used from within Makefiles.
X.TP 10
X.B "h"
XForce file type to be ``C Include''.
X.TP 10
X.B "f"
XForce file type to be ``Fortran''.
X.TP 10
X.B "M"
XForce file type to be ``Manual''.
XNote: If you also specify the ``I\fIflags\fR'' option,
X.I afsit
Xwill run 
X.I rcs(1)
Xto tell rcs what kind of comment string to use for the manual file.
X.TP 10
X.B "s"
XForce file type to be ``Shell Script''.
X.TP 10
X.B "m"
XForce file type to be ``Makefile''.  Note that this does the same thing as
Xthe -s option does.  It just prints a different message.
X.TP 10
X.B "t"
XDo not use any Template files for the headers.
X.TP 10
X.B "q"
XBe quiet.  Don't print out what is going on.  Only error messages are
Xprinted.
X.TP 10
X.B "d"
XDo not attempt to make the directory ``RCS''.
XSee above for more info.
X.TP 10
X.B "a"
XTurn off auto guessing of file type.
X.TP 10
X.B "I\fIflags\fR"
XCheck In file.
XRun RCS's 
X.I ci(1)
Xon the file with ``flags'' being passed onto 
X.I ci(1) 
Xas the command line arguments.
X.TP 10
X.B "R\fIflags\fR"
XRun 
X.I rcs(1)
Xwith ``flags'' as the command line arguments.
X.SH FILES
X/tmp/afsit*	- temporary buffer
X.br
X~/.template.*   - template files to use as the header.
X.br
X.SH AUTHOR
XMichael Cooper (mcooper@usc-oberon.ARPA)
X.br
XModified for use with \fIshapetools\fR by Axel Mahler (axel@coma.uucp)
X.SH SEE ALSO
Xci(1), make(1), rcs(1), save(1), retrv(1), shape(1)
X.SH DIAGNOSTICS
XComplains about the usual stuff.  (i.e. - the specified file doesn't exist,
Xor it can't read it...just things like that.)
X.SH BUGS
XActs oddly in the presence of beautiful women.
END_OF_FILE
if test 7488 -ne `wc -c <'src/afsit/afsit.1'`; then
    echo shar: \"'src/afsit/afsit.1'\" unpacked with wrong size!
fi
# end of 'src/afsit/afsit.1'
fi
if test -f 'src/vc/sighand.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/vc/sighand.c'\"
else
echo shar: Extracting \"'src/vc/sighand.c'\" \(7865 characters\)
sed "s/^X//" >'src/vc/sighand.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *AFSid = "$Header: sighand.c[3.7] Thu Feb 23 18:13:57 1989 axel@coma published $";
X#ifdef CFFLGS
Xstatic char *ConfFlg = CFFLGS;
X	/* should be defined from within Makefile */
X#endif
X#endif
X/*
X * Log for /u/shape/dist-tape/src/vc/sighand.c[3.3]
X * 	Thu Feb 23 18:13:57 1989 axel@coma published $
X *  --- empty log message ---
X *  sighand.c[3.4] Thu Feb 23 18:13:57 1989 axel@coma published $
X *  --- empty log message ---
X *  sighand.c[3.5] Thu Feb 23 18:13:57 1989 axel@coma save $
X *  --- empty log message ---
X *  sighand.c[3.6] Thu Feb 23 18:13:57 1989 axel@coma save $
X *  --- empty log message ---
X *  sighand.c[3.7] Thu Feb 23 18:13:57 1989 axel@coma published $
X *  --- empty log message ---
X */
X
X/*LINTLIBRARY*/
X
X#include <signal.h>
X#include <strings.h>
X#include "afs.h"
X#include "afsapp.h"
X
Xextern struct Transaction ThisTransaction;
Xextern int nfnms;
X
XCatchSigs () {
X/*
X * Setup signal handlers for various signals. Previous handlers
X * are saved. On receipt of a signal, the 
X * original handler for this signal will be invoked after specified
X * action has been taken.
X */
X
Xextern Sfunc_t interrupt_action();
X
XSfunc_t    die1(), die2(), die3(), die4(), die5(), die6(), 
X       die7(), die8(), die9(), die10(),
X       die11(), die12(), die13(), die14(), die15();
X
X  (void)signal (SIGINT, die2);
X  (void)signal (SIGBUS, die10);
X  (void)signal (SIGSEGV, die11);
X  (void)signal (SIGFPE, die8);
X  (void)signal (SIGTERM, die15);
X}
X
Xextern jmp_buf here;
X
XCatchCont () {
X  Sfunc_t conthand();
X
X  (void)signal (SIGCONT, conthand);
X}
X
XUnCatchCont () {
X  (void)signal (SIGCONT, SIG_DFL);
X}
X
XSfunc_t conthand () {
X  char messg [80];
X
X  (void)sprintf (messg, "%s:", ThisTransaction.tr_fname);
X  logmsg (messg);
X  longjmp (here, 1);
X}
X    
XSfunc_t die1 () {
X}
X
XSfunc_t die2 () {
X  /* do eventual cleanup and execute previously defined action */
X  Sfunc_t interrupt_action();
X  
X  (void)sigblock (SIGINT);
X  (void)signal (SIGINT, die2);
X  af_cleanup ();
X  kill_tmpfiles ();
X  interrupt_action();
X}
X
XSfunc_t die8 () {
X  /* do eventual cleanup and execute previously defined action */
X  int mask = sigblock (SIGFPE);
X  logerr (" Oh! Oh! .... this was a floating exception -- goodbye."); 
X  af_cleanup ();
X  kill_tmpfiles ();
X  (void)sigsetmask (mask);
X  exit (1);
X}
X
XSfunc_t die10 () {
X  /* do eventual cleanup and execute previously defined action */
X  
X  (void)sigblock (SIGBUS);
X  logerr ("Oh! Oh! .... this was a buserror -- goodbye.");
X  logerr ("Dumping core.");
X  af_cleanup ();
X  kill_tmpfiles ();
X  (void)kill (getpid(), SIGQUIT);
X}
X
XSfunc_t die11 () {
X  /* do eventual cleanup and execute previously defined action */
X
X  (void)sigblock (SIGSEGV);
X  logerr ("Oh! Oh! .... this was a segmentation violation -- goodbye.");
X  logerr ("Dumping core.");
X  af_cleanup ();
X  kill_tmpfiles ();
X  (void)kill (getpid(), SIGQUIT);
X}
X
XSfunc_t die15 () {
X  /* do eventual cleanup and restore previously saved context for */
X  /* next transaction */
X  int mask = sigblock (SIGTERM);
X
X  (void)signal (SIGTERM, die15);
X  kill_tmpfiles ();
X  kill_afsets();
X  kill_afkeys();
X  kill_afattrbufs();
X  ThisTransaction.tr_rc = 1; /* indicating that something went wrong */
X  (void)sigsetmask (mask);
X  longjmp (ThisTransaction.tr_env, 1);
X}
X
X#define sm(i) (1 << (i))
X
Xabort_this (domsg) {
X  if (domsg)
X    logmsg ("...aborting");
X  (void)kill (getpid(), SIGTERM); 
X  /* abort current execution phase and restore */
X  /* a clean context for next phase */
X}
X
X/*
X *  Utilities for housekeeping with various allocated 
X *  system resources.
X */
X
Xchar tmpnames[MAXTMPF][MAXNAMLEN];
XAf_set *afsets[MAXSETS];
XAf_key *afkeys[MAXKEYS];
XAf_attrs *afattrbufs[MAXATTRBUFS];
X
XRegister (data, type) char *data; short type; {
X  register int i, ok;
X
X  if (!data) return; /* NULL pointers not registered */
X
X  switch (type) {
X  case TYPEF: /* temporary filenames */
X    ok = FALSE;
X    for (i=0; i < MAXTMPF; i++) {
X      if (tmpnames[i][0]) continue;
X      else {
X	(void)strcpy (tmpnames[i], data);
X	ok = TRUE;
X	break;                      /* I admit: UGLY! */
X      }
X    }
X    if (!ok) {
X      logerr ("internal error in resource tables");
X    }
X    break;
X  case AFSET:
X    ok = FALSE;
X    for (i = 0; i < MAXSETS; i++) {
X      if (afsets[i]) continue;
X      else {
X	afsets[i] = (Af_set *)data;
X	ok = TRUE;
X	break;
X      }
X    }
X    if (!ok) {
X      logerr ("resource table error -- Af_set table overflow");
X    }
X    break;
X  case AFKEY:
X    ok = FALSE;
X    for (i = 0; i < MAXSETS; i++) {
X      if (afkeys[i]) continue;
X      else {
X	afkeys[i] = (Af_key *)data;
X	ok = TRUE;
X	break;
X      }
X    }
X    if (!ok) {
X      logerr ("resource table error -- Af_key table overflow");
X    }
X    break;
X  case AFATTRS:
X    ok = FALSE;
X    for (i = 0; i < MAXATTRBUFS; i++) {
X      if (afattrbufs[i]) continue;
X      else {
X	afattrbufs[i] = (Af_attrs *)data;
X	ok = TRUE;
X	break;
X      }
X    }
X    if (!ok) {
X      logerr ("resource table error -- Af_attrbuf table overflow");
X    }
X    break;
X  default: /* shouldn't happen */
X    logerr ("internal error in resource tables (types)");
X  }
X}
X
XUnRegister (data, type) char *data; short type; {
X  register int i;
X
X  switch (type) {
X  case TYPEF:
X    for (i=0; i < MAXTMPF; i++) {
X      if (tmpnames[i][0]) {
X	if (!strcmp (tmpnames[i], data)) {
X	  if (i < MAXTMPF-1) {
X	    bcopy (tmpnames[i+1], tmpnames[i], MAXTMPF-(i+1));
X	    if (tmpnames[MAXTMPF-1][0]) tmpnames[MAXTMPF-1][0] = '\0';
X	  }
X	  else {
X	    tmpnames[i][0] = '\0';
X	  }
X	  break; /* bail out of for-loop */
X	}
X	else {
X	  continue;
X	}
X      }
X      else {
X	break; /* no more entries in list */
X      }
X    }
X    break;
X  case AFSET:
X    for (i = 0; i < MAXSETS; i++) {
X      if (afsets[i] == (Af_set *)data) {
X	afsets[i] = (Af_set *)NULL;
X	break;
X      }
X    }
X    break;
X  case AFKEY:      
X    for (i = 0; i < MAXKEYS; i++) {
X      if (afkeys[i] == (Af_key *)data) {
X	afkeys[i] = (Af_key *)NULL;
X	break;
X      }
X    }
X    break;
X  case AFATTRS:
X    for (i = 0; i < MAXATTRBUFS; i++) {
X      if (afattrbufs[i] == (Af_attrs *)data) {
X	afattrbufs[i] = (Af_attrs *)NULL;
X	break;
X      }
X    }
X    break;
X  default: /* shouldn't happen */
X    logerr ("internal error in resource tables (unregister)");
X  }
X}
X
Xkill_tmpfiles () { /* do this before exiting */
X  register int i;
X
X  for (i=0; i < MAXTMPF; i++) {
X    if (tmpnames[i][0])
X      (void)unlink (tmpnames[i]);
X    else break;  /* save two or three nanoseconds */
X  }
X}
X
Xkill_afsets () { 
X  register int i;
X
X  for (i = 0; i < MAXSETS; i++) {
X    if (afsets[i])
X      af_dropset (afsets[i]);
X  }
X}
X
Xkill_afkeys () { 
X  register int i;
X
X  for (i = 0; i < MAXKEYS; i++) {
X    if (afkeys[i])
X      af_dropkey (afkeys[i]);
X  }
X}
X
Xkill_afattrbufs () {
X  register int i;
X
X  for (i = 0; i < MAXATTRBUFS; i++) {
X    if (afattrbufs[i])
X      udafree (afattrbufs[i]);
X  }
X}
END_OF_FILE
if test 7865 -ne `wc -c <'src/vc/sighand.c'`; then
    echo shar: \"'src/vc/sighand.c'\" unpacked with wrong size!
fi
# end of 'src/vc/sighand.c'
fi
if test -f 'src/vc/util.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/vc/util.c'\"
else
echo shar: Extracting \"'src/vc/util.c'\" \(7817 characters\)
sed "s/^X//" >'src/vc/util.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *AFSid = "$Header: util.c[3.10] Thu Feb 23 18:14:00 1989 axel@coma published $";
X#ifdef CFFLGS
Xstatic char *ConfFlg = CFFLGS;
X	/* should be defined from within Makefile */
X#endif
X#endif
X/*
X * Log for /u/shape/dist-tape/src/vc/util.c[3.5]
X * 	Thu Feb 23 18:14:00 1989 axel@coma published $
X *  --- empty log message ---
X *  util.c[3.8] Thu Feb 23 18:14:00 1989 axel@coma published $
X *  --- empty log message ---
X *  util.c[3.9] Thu Feb 23 18:14:00 1989 axel@coma save $
X *  --- empty log message ---
X *  util.c[3.10] Thu Feb 23 18:14:00 1989 axel@coma published $
X *  --- empty log message ---
X */
X
X/*LINTLIBRARY*/
X#include <strings.h>
X#include <stdio.h>
X#include <pwd.h>
X#include "afs.h"
X#include <sys/stat.h>
X#include <sys/file.h>
X#include "afsapp.h"
X#include "project.h"
X#include "locks.h"
X
Xextern unsigned int options;
X
Xjmp_buf here;
X
Xask_confirm (s, def) char *s, *def; {
X  /*
X   *  returns true if the answer is equivalent to 'def' (assumption)
X   */
X  char strbuf[256], answer[10], *cp;
X
X  if (s == (char *)NULL) return TRUE;
X  if (!isatty (fileno (stdin))) return TRUE;
X  (void)setjmp (here);
X  CatchCont ();
X  (void)fflush (stdin);
X  printf ("%s [%s] ", s, def);
X  strbuf[0] = '\0';
X  answer[0] = '\0';
X  (void)gets (strbuf);
X  UnCatchCont ();
X  (void)sscanf (strbuf, "%s", answer);
X  if (answer[0] == '\0') return TRUE; /* assumption acknowledged */
X  cp = answer;
X  while (*cp ? (*cp++ |= ' ') : 0); /* make sure answer is lowercase */
X  return !strncmp (def, answer, min(strlen(def), strlen(answer)));
X}
X
X/*ARGSUSED*/
Xgetsyspath (path, proj, syspath, opath, name) 
X     char *path, *syspath, *opath, *name; 
X     Project *proj;
X/*
X * Normally splits path-prefix and filename-part. If the project structure
X * specifies an explicit syspath (which could be different from the 
X * actual path-prefix) it will be returned in syspath. The path-prefix
X * will be returned in opath.
X */
X{
X  char *cpt;
X
X  if (cpt = rindex (path, '/')) {
X    (void)strncpy (opath, path, cpt - path);
X    opath[cpt-path] = '\0';
X    (void)strcpy (name, cpt+1);
X  }
X  else {
X    opath[0] = '\0';
X    (void)strcpy (name, path);
X  }
X  (void)strcpy (syspath, opath); /* this is going to be more complex */
X}
X
X#define nxt(s) (s = (*(s+strlen(s)+1) != '\0') ? s+strlen(s)+1 : NULL)
X
X/*ARGSUSED*/
Xchar *getattr (attrfile, proj, type, op) 
X     char *attrfile, *type ; Project *proj; {
X       /* 
X	* in initial state, getattr parses all available attribute
X	* information, i.e. a user supplied attribute file and the
X	* common project specific attribute specifications. The information
X	* is kept in static memory. Subsequent calls to getattr with
X	* op = NEXT yields the next attribute for the specified document
X	* type. If op is REWIND, the first attribute for the given type
X	* is delivered. If no (more) attribute is found, getattr returns
X	* a NULL pointer.
X	*/
X       static int isparsed = FALSE;
X       static char *currattr, *attrbuf;
X       char messg[80], *malloc();
X       struct stat statbuf;
X       register int i;
X       FILE *atfil;
X       
X       if (isparsed) {
X	 if (op == NEXT)
X	   return (currattr) ? nxt(currattr) : currattr;
X	 else if (op == REWIND) {
X	   currattr = attrbuf;
X	   return currattr;
X	 }
X       }
X       else { /* we've to read the stuff first */
X	 if ((atfil = fopen (attrfile, "r")) == NULL) {
X	   (void)sprintf (messg, "No attribute file %s.", attrfile);
X	   logerr (messg);
X	   attrbuf = NULL;
X	 }
X	 else {
X	   if (fstat (fileno(atfil), &statbuf) < 0) {
X	     perror ("couldn't stat.");
X	     return (char *)NULL;
X	   }
X	   attrbuf = malloc ((unsigned)statbuf.st_size+1); 
X	   /* leave space for terminating nullbyte */
X	   if (!attrbuf) {
X	     logerr ("Not enough memory for attribute table");
X	   }
X	   else {
X	     (void)fread (attrbuf, sizeof (char), 
X			  (Size_t)statbuf.st_size, atfil);
X	     for (i=0; i < statbuf.st_size; i++)
X	       if (attrbuf[i] == '\n')
X		 attrbuf[i] = '\0';
X	     attrbuf[statbuf.st_size + 1] = '\0';
X	   }
X	 }
X	 currattr = attrbuf;
X	 isparsed = TRUE;
X	 return currattr;
X       }
X       return FALSE;
X     }
X
Xmylock (key, proj) Af_key *key; Project *proj; {
X  Af_user *locker;
X  Uid_t myuid;
X  char messg[80], *lockerid();
X
X  myuid = (Uid_t)getuid();
X  if (!locked(locker = vc_testlock_g(key))) {
X    if (firmlocking (proj)) {
X      (void)sprintf (messg, 
X	       "You must lock %s before saving (firm locking required).",
X	       af_rname (key));
X      logmsg (messg);
X      return FALSE;
X    }
X    else { /* no firm locking */
X      if (lockeruid (vc_lock_g(key, myuid)) != myuid) {
X	af_perror ("cannot lock archive");
X	return FALSE;
X      }
X      return TRUE;
X    }
X  }
X  else { /* there was some lock set */
X    if (lockeruid(locker) != myuid) {
X      (void)sprintf (messg, "%s already locked by %s.", af_rname (key), 
X	       lockerid (locker));
X      logmsg (messg);
X      return FALSE;
X    }
X    return TRUE;
X  }
X}
X
Xfirmlocking (proj) Project *proj; {
X  if (proj) {
X    return TRUE;
X  }
X  else {
X    return FALSE;
X  }
X}
X
X#define owner(p) (0100 * p)
X#define group(p) (010 * p)
X#define world(p) (p)
X
Xafaccess (fkey, perm) Af_key *fkey; {
X  short itisus;
X  Af_attrs thisattrs;
X  char thishost[MAXHOSTNAMELEN];
X
X  if (!fkey) return FALSE;
X
X  if (fail(af_gattrs (fkey, &thisattrs))) {
X    af_perror ("af_gattrs (access determination failed).");
X    return FALSE;
X  }
X  (void)gethostname (thishost, MAXHOSTNAMELEN);
X  if (!strcmp (thishost, thisattrs.af_owner.af_userhost)) {
X    itisus = !strcmp (getpwuid((int)getuid())->pw_name, 
X		      thisattrs.af_owner.af_username);
X  if ((thisattrs.af_state != AF_BUSY) && (perm & W_OK)) return FALSE;
X  if (itisus) {
X    return TRUE; /* there's no chmod for archived files. always grant acc. */
X  }
X  return thisattrs.af_mode & world(perm);
X  }
X  else return TRUE;
X}
X
X/*ARGSUSED*/
Xmyproject (proj) Project *proj; {
X  /*
X   * returns TRUE if we are project administrator
X   */
X  return TRUE; /* until project support is implemented ... */
X}
X
Xmkvstring (version, key) char *version; Af_key *key; {
X  int g;
X  char buf[16], *t, *n;
X
X  t = af_rtype (key);
X  (void)sprintf (version, "%s%s%s[",
X	   n=af_rname (key),
X	   t ? (t[0] ? "." : "") : "", t);
X  free (n); free (t); 
X  if ((g=af_rgen (key)) < 0) {
X    (void)strcat (version, "busy]");
X  }
X  else {
X    (void)sprintf (buf, "%d.%d]", g, af_rrev (key));
X    (void)strcat (version, buf);
X  }
X}
X
Xchar *vnum (key) Af_key *key; {
X  int _gen, _rev;
X  static char vstr[20];
X
X  _gen = af_rgen (key);
X  _rev = af_rrev (key);
X  
X  if (af_rstate (key) == AF_BUSY)
X    (void)strcpy (vstr, "busy");
X  else
X    (void)sprintf (vstr, "%d.%d", _gen, _rev);
X  return vstr;
X}
X
Xudafree (attrbuf) Af_attrs *attrbuf; {
X  register int i=0;
X
X  while (attrbuf->af_udattrs[i])
X    free (attrbuf->af_udattrs[i++]);
X}
END_OF_FILE
if test 7817 -ne `wc -c <'src/vc/util.c'`; then
    echo shar: \"'src/vc/util.c'\" unpacked with wrong size!
fi
# end of 'src/vc/util.c'
fi
if test -f 'src/vc/vadm_gkeys.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/vc/vadm_gkeys.c'\"
else
echo shar: Extracting \"'src/vc/vadm_gkeys.c'\" \(7667 characters\)
sed "s/^X//" >'src/vc/vadm_gkeys.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *AFSid = "$Header: vadm_gkeys.c[3.11] Thu Feb 23 18:14:11 1989 axel@coma published $";
X#ifdef CFFLGS
Xstatic char *ConfFlg = CFFLGS;
X	/* should be defined from within Makefile */
X#endif
X#endif
X/*
X * Log for /u/shape/dist-tape/src/vc/vadm_gkeys.c[3.6]
X * 	Thu Feb 23 18:14:11 1989 axel@coma published $
X *  --- empty log message ---
X *  vadm_gkeys.c[3.9] Thu Feb 23 18:14:11 1989 axel@coma published $
X *  --- empty log message ---
X *  vadm_gkeys.c[3.10] Thu Feb 23 18:14:11 1989 axel@coma save $
X *  --- empty log message ---
X *  vadm_gkeys.c[3.11] Thu Feb 23 18:14:11 1989 axel@coma published $
X *  --- empty log message ---
X */
X
X#include <stdio.h>
X#include <strings.h>
X#include <afs.h>
X
X#include "vadm.h"
X#include "afsapp.h"
X
Xextern char *malloc();
Xextern unsigned int options;
X
Xstatic char *variant = NULL;
X
Xint between_versions (this_gen, this_rev, from_gen, from_rev, to_gen, to_rev)
X     int this_gen, this_rev, from_gen, from_rev, to_gen, to_rev;
X{
X  if (this_gen < from_gen)
X    return 0;
X  if (this_gen > to_gen)
X    return 0;
X  if (this_rev < from_rev)
X    return 0;
X  if (this_rev > to_rev)
X    return 0;
X
X  return 1;
X}
X
XGetKeys (file, versions, set)
X     char *file;
X     struct vc_vlist *versions;
X     Af_set *set;
X{
X  Af_set tset, btset, stset;
X  Af_attrs attrbuf;
X  Af_key key;
X  
X  struct vc_vlist *tvs;
X  char *syspath, *name, *type, cstring[MAXNAMLEN], vstring[16];
X  int nhits, bnhits, i, vno;
X  
X  if (BoundVersion (file, cstring, vstring)) {
X    vno = mkvno (vstring);
X    syspath = af_afpath (cstring);
X    name = af_afname (cstring);
X    type = af_aftype (cstring);
X    if (af_getkey (syspath, name, type, gen(vno), rev(vno), AF_NONAME, 
X		   &key) < 0)
X      return NULL;
X/*    af_setaddkey (set, AF_LASTPOS, &key); *//* should look like this line */
X    af_setaddkey (set, 0, &key);
X    return 1;
X  }
X  /* subsequent stuff handles non-explicit queries.... */
X  syspath = af_afpath (file);
X  name = af_afname (file);
X  type = af_aftype (file);
X
X  af_initattrs (&attrbuf);
X  
X  if (syspath)
X    (void)strcpy (attrbuf.af_syspath, syspath);
X  
X  (void)strcpy (attrbuf.af_name, name);
X  if (type)
X    (void)strcpy (attrbuf.af_type, type);
X  
X  nhits = af_find (&attrbuf, &stset);
X  if (IsOptionSet (Vopt_binary)) {
X    bnhits = af_bpfind (&attrbuf, &btset);
X  }
X  else {
X    af_initset (&btset);
X  }
X  if (af_union (&stset, &btset, &tset) < 0) {
X    af_perror ("af_union");
X    return NULL;
X  }
X  af_dropset (&stset);
X  af_dropset (&btset);
X  nhits += bnhits;
X  if (nhits < 0) {
X    return NULL;
X  }
X  
X  if (nhits == 0) {
X    return NULL;
X  }
X  
X  for (i = 0; i < nhits; i++) {
X    if (versions) {
X      for (tvs = versions; tvs; tvs = tvs->next) {
X	if (between_versions (af_rgen (&tset.af_klist[i]),
X			      af_rrev (&tset.af_klist[i]),	    
X			      tvs->from_generation, tvs->from_revision,
X			      tvs->to_generation, tvs->to_revision)) {
X	  af_setaddkey (set, 0, &tset.af_klist[i]); 
X	  /*	af_setaddkey (set, AF_LASTPOS, &tset.af_klist[i]); */
X	  break;
X	}
X      }
X    }
X    else { /* versions == NULL */
X      af_setaddkey (set, 0, &tset.af_klist[i]); 
X    }
X  }
X  af_dropset (&tset);
X  return 1;
X}
X
X/**/
XGetKeysByName (nums, af_files, versions, set, err_files)
X     int nums;
X     char **af_files;
X     struct vc_vlist *versions;
X     Af_set *set;
X     char ***err_files;
X{
X  Af_key thiskey;
X  int i, bad, vno;
X  char **erroneous, cstring[MAXNAMLEN], vstring[16];
X  struct vc_vlist vdesc;
X
X  vdesc.from_version_set = NULL;
X  vdesc.to_version_set = NULL;
X  af_initset (set);	/* needed for the first af_union */
X
X  if ((erroneous = (char **) 
X       malloc ((unsigned)(sizeof (char *) * (nums + 1)))) == (char **)NULL)
X    vctl_abort ("GetKeysByName(): can't malloc");
X 
X  bad = 0;
X  for (i = 0; i < nums; i++) {
X    if (*af_files[i] == '\0') continue; /* skip null names */
X    if (BoundVersion (af_files[i], cstring, vstring)) {
X      vno = mkvno (vstring);
X      vdesc.from_generation = gen(vno);
X      vdesc.from_revision = rev(vno);
X      vdesc.to_generation = gen(vno);
X      vdesc.to_revision = rev(vno);
X      vdesc.next = NULL;
X      if (!GetKeys (af_files[i], &vdesc, set))
X	erroneous[bad++] = af_files[i];
X    }
X    else {
X      if (versions) {
X	if (!(versions->from_version_set) || !(versions->to_version_set)) {
X	  /* no version range given -- try find busy version */
X	  if (!fail(af_getkey (af_afpath(af_files[i]), af_afname(af_files[i]),
X			       af_aftype(af_files[i]), AF_BUSYVERS, AF_BUSYVERS,
X			       AF_NONAME, &thiskey)))
X	    af_setaddkey (set, 0, &thiskey);
X	  else erroneous[bad++] = af_files[i];
X	}
X	else
X	  if (!GetKeys (af_files[i], versions, set))
X	    erroneous[bad++] = af_files[i];
X      }
X      else
X	if (!GetKeys (af_files[i], versions, set))
X	  erroneous[bad++] = af_files[i];
X    }
X  }
X  erroneous[bad] = NULL;
X  *err_files = erroneous;
X  return bad;
X}
X
X/**/
Xint GetKeysByGenRev (ac, av, generation, revision, set, err_files)
X     int ac;
X     char **av;
X     int generation, revision;
X     Af_set *set;
X     char ***err_files;
X{
X  Af_key key;
X  char **erroneous;		/* busy version' name that has no saved vers */
X  char cfname[MAXNAMLEN], vstring[16];
X  int bad, retcode;
X  int i, vno;
X  
X  if ((erroneous = (char **) malloc ((unsigned)(sizeof (char *) * (ac + 1))))
X      == (char **)NULL) {
X    perror ("get_by_versnum: can't malloc,2");
X    exit (1);
X  }
X
X  af_initset (set);
X  
X  /* collect all Afs files and record error for later use */
X  bad = 0;
X  for (i = 0; av[i]; i++) {
X    if (BoundVersion (av[i], cfname, vstring)) {
X      vno = mkvno (vstring);
X      retcode = af_getkey (af_afpath (cfname), af_afname(cfname),
X			 af_aftype(cfname), gen(vno),
X			 rev(vno), variant, &key);
X    }
X    else {
X      switch (generation) {
X      case AF_BUSYVERS:
X	retcode = af_getkey (af_afpath (av[i]), af_afname(av[i]),
X			     af_aftype(av[i]), generation,
X			     revision, variant, &key);
X	if (!fail(retcode)) break;
X	/* we go to next label if no busyversion is there */
X      case AF_LASTVERS:
X	retcode = af_getkey (af_afpath (av[i]), af_afname(av[i]),
X			     af_aftype(av[i]), AF_LASTVERS,
X			     AF_LASTVERS, variant, &key);
X	break;
X      case AF_FIRSTVERS:
X      default: 
X	retcode = af_getkey (af_afpath (av[i]), af_afname(av[i]),
X			     af_aftype(av[i]), generation,
X			     revision, variant, &key);
X	break;
X      }
X    }
X    if (retcode == -1)
X      erroneous[bad++] = av[i];	/* must we record af_errno ? */
X    else {
X      af_setaddkey (set, 0, &key); /* should be AF_LASTPOS */
X/*      af_setaddkey (set, AF_LASTPOS, &key); */
X    }
X  }
X
X  erroneous[bad] = NULL;
X  *err_files = erroneous;
X  return bad;
X}
END_OF_FILE
if test 7667 -ne `wc -c <'src/vc/vadm_gkeys.c'`; then
    echo shar: \"'src/vc/vadm_gkeys.c'\" unpacked with wrong size!
fi
# end of 'src/vc/vadm_gkeys.c'
fi
echo shar: End of archive 8 \(of 33\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
