Subject:  v19i025:  A software configuration management system, Part12/33
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Axel Mahler <unido!coma!axel>
Posting-number: Volume 19, Issue 25
Archive-name: shape/part12



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 12 (of 33)."
# Contents:  man/man1/shapetools.1 src/afs/afsattrs.c src/vc/mkattr.c
#   src/vc/vadm_symname.c src/vc/vlopt.c
# Wrapped by rsalz@papaya.bbn.com on Thu Jun  1 19:27:01 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'man/man1/shapetools.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/man1/shapetools.1'\"
else
echo shar: Extracting \"'man/man1/shapetools.1'\" \(9634 characters\)
sed "s/^X//" >'man/man1/shapetools.1' <<'END_OF_FILE'
X...
X... Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X...  and U. Pralle
X... 
X... This software is published on an as-is basis. There is ABSOLUTELY NO
X... WARRANTY for any part of this software to work correctly or as described
X... in the manuals. We do not accept any liability for any kind of damage
X... caused by use of this software, such as loss of data, time, money, or 
X... effort.
X... 
X... Permission is granted to use, copy, modify, or distribute any part of
X... this software as long as this is done without asking for charge, and
X... provided that this copyright notice is retained as part of the source
X... files. You may charge a distribution fee for the physical act of
X... transferring a copy, and you may at your option offer warranty
X... protection in exchange for a fee.
X... 
X... Direct questions to: Tech. Univ. Berlin
X... 		     Wilfried Koch
X... 		     Sekr. FR 5-6 
X... 		     Franklinstr. 28/29
X... 		     D-1000 Berlin 10, West Germany
X... 
X... 		     Tel: +49-30-314-22972
X... 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X... 
X...
X... Copyright (C) 1988 Technische Universitaet Berlin
X... 
X... This is a pre-release !
X... 
X... This software is published on an as-is basis. There is ABSOLUTELY NO
X... WARRANTY for any part of this software to work correctly or as described
X... in the manuals. No responsibility or liability for any damage caused
X... by using this software.
X... 
X... No part of this software may be redistributed or used commercially by 
X... any means or in any form.
X... 
X... Direct questions to: Tech. Univ. Berlin
X... 			 Wilfried Koch
X... 			 Sekr. FR 5-6 
X... 			 Franklinstr. 28/29
X... 			 D-1000 Berlin 10, West Germany
X... 
X... 			 Tel: +49-30-314-22972
X... 			 E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X...
X.TH SHAPE 1 shapetools \n(dy.\n(mo.\n(yr
X.SH NAME
X\fRshapetools \- user interface for the shape toolkit
X.SH INTRODUCTION
XWe introduce hereby a user interface for the shape toolkit based on
XEMACS running preferably on alphanumeric terminals.
XThe interface supports a more comfortable use of the different commands of the 
Xshape toolkit.
XYou can use the interface on both alphanumeric terminals and
Xgraphical workstations running X. The functionality in both cases is
Xbasically the same.
X.SH GETTING STARTED
XTo start the shapetools interface enter the EMACS command
X.br
X		\fCM-x shapetools.\fR
X.br
XYou are then prompted for a directory name. This directory
Xshould be the directory you want to work in. You get then an
XEMACS buffer containing a list of all files in this directory
Xincluding the versions (if any).
X.br
XThe buffer should look like this:\fC
X.nf
X  drwxr-xr-x b shape@chaos       512 Nov  3 13:24:01 1988 .
X  drwxr-xr-x b shape@chaos      1536 Oct 30 23:01:59 1988 ..
X  drwxr-xr-x b shape@chaos      1536 Nov  5 16:53:53 1988 AFS
X  -rw-r--r-- b shape@chaos      1340 Oct 19 13:32:16 1988 Shapefile
X  -rw-r--r-- s shape@chaos      1243 Oct 31 13:31:20 1988 Shapefile[1.0]
X  -rw-r--r-- s shape@chaos      1200 Oct 31 13:32:04 1988 Shapefile[1.1]
X  -rw-r--r-- s shape@chaos      1101 Oct 31 15:56:46 1988 Shapefile[1.2]
X  -rw-r--r-- b shape@chaos       101 Oct 19 13:16:23 1988 demo1.c
X  -rw-r--r-- b shape@chaos        31 Oct 19 13:16:28 1988 demo1.h
X  -rw-r--r-- b shape@chaos       121 Oct 19 13:16:32 1988 demo2.c
X  -rw-r--r-- b shape@chaos        88 Oct 19 13:16:38 1988 demo3.c
X  -rw-r--r-- s shape@chaos       101 Oct 31 12:18:11 1988 demo3.c[1.0]
X  -rw-r--r-- b shape@chaos        89 Oct 19 13:16:42 1988 demo4.c
X  -rw-r--r-- b shape@chaos       101 Oct 19 13:16:46 1988 demo5.c
X  -rw-r--r-- b shape@chaos       100 Oct 19 13:16:49 1988 demo6.c
X  -rw-r--r-- b shape@chaos        82 Oct 19 13:16:55 1988 demo7.c
X  -rw-r--r-- s shape@chaos        82 Oct 19 13:49:35 1988 demo7.c[1.0]
X  -rw-r--r-- s shape@chaos        75 Oct 31 12:43:06 1988 demo7.c[1.1]
X  -rw-r--r-- s shape@chaos        93 Oct 31 12:46:28 1988 demo7.c[1.2]
X  -rw-r--r-- s shape@chaos        97 Oct 31 13:27:34 1988 demo7.c[1.3]
X  -rw-r--r-- b shape@chaos       101 Oct 19 13:17:00 1988 demo8.c
X  -rw-r--r-- p shape@chaos       131 Oct 19 13:29:00 1988 demo8.c[1.1]
X  -rw-r--r-- p shape@chaos       156 Oct 31 12:09:10 1988 demo8.c[1.3]
X  -rw-r--r-- p shape@chaos       176 Oct 31 13:30:27 1988 demo8.c[1.4]\fR
X.fi
X.br
XEntering \fCC-h m\fR or \fC?\fR gives you a short description of the mode.
X.SH THE INTERFACE FOR ALPHANUMERIC TERMINALS
XOn alphanumeric terminals a special EMACS mode is supplied. Several
Xkeys have a special meaning. The following is a description of
Xthe mode.
X.SH CURSOR MOVEMENT AND FOLDING
X.PP
XOn alphanumeric terminals you can move the cursor using
Xthe standard EMACS commands. Besides it is possible to 
Xmove the cursor down using the space bar. The cursor is
Xpositioned on the filename. Similarly you can
Xmove up using the backspace key.
X.PP
XDirectories with a lot of entries, especially a lot of versions
Xare not comfortable. You can reduce the number of entries
Xtyping a \fCF\fR, (stands for \fCfold\fR). You are then asked, whether
Xyou want to fold the whole directory or not. Folding means,
Xversion entries being compressed to one line, e.g.
Xafter folding demo7.c the
Xentries of demo7.c in the above example would look like\fC
X.bp
X.nf
X  -rw-r--r-- b shape@chaos        82 Oct 19 13:16:55 1988 demo7.c
X  -rw-r--r-- s shape@chaos        82 Oct 19 13:49:35 1988 demo7.c[*]\fR
X.fi
XYou can undo folding by typing the command \fCX\fR both for the
Xwhole directory and a special folded component.
X.SH EDITING AND VIEWING
X.PP
XTo \fIview\fR or to \fIedit\fR a file move the cursor to the file and type
X\fCv\fR or \fCe\fR, respectively. Note that it is not possible
Xto edit a version or a \fIfolded\fR (see below) file.
XEditing e directory or viewing a folded file
Xgives you a list of the files in that
Xdirectory or the folded file similar like the current list.
XWith the command \fCo\fR you can edit a file or a directory in another
Xwindow.
X.SH SAVING AND RETRIEVING
X.PP
XTo save a busy version of a file, move the cursor to this file and
Xtype \fCS\fR. You are then asked if you want to describe this
Xdocument or the changes. If ou answer "yes", you get another
XEMACS buffer to type in your comments. Finish editing this buffer
Xwith \fCC-c C-c.\fR
X.SH DELETING FILES AND VERSIONS
X.PP
XDeletion of files can be performed using the \fCd\fR key for marking
Xone ore more files or versions of files for deletion. The deletion
Xis then executed with the command \fCx\fR (you are asked whether
Xyou really want to delete or not). Note that you can only
Xdelete files with the
Xstate \fIbusy\fR or \fIsaved.\fR Marking for deletion can be undone
Xwith \fCu\fR or with the backspace key.
X.SH COMPARING FILES AND VERSIONS
X.PP
XWithin the Shape mode you can compare two files or versions.
XMove the cursor to the first file and type \fCC\fR, then move the
Xcursor to the second file and type \fCC\fR again. These files are marked
Xwith \fC>\fR and \fC<\fR, respectively. Comparison is done with the
Xdiff command. The output of diff is shown in a separate EMACS buffer.
X.SH COMMANDS FOR ADMINISTRATION
X.PP
XTo promote a saved version, i.e. improve the state of this version,
Xmove the cursor to this version and type \fCP\fR. Unpromoting is
Xdone by typing \fCU\fR.
X.PP
XTo change the mode of a file or a version, enter \fCM\fR. You are
Xthen asked for the mode you want to give to this file or version.
X.SH EXECUTING SHAPE
X.PP
XIf you want to run \fIshape\fR type \fCE\fR. If the cursor
Xis located on a file named \fIShapefile, shapefile, Makefile, or
Xmakefile, \fR respectively, the EMACS compile command is
Xcalled with \fCshape -k -f Shapefile\fR, etc. If the cursor
Xis positioned on a version of such a file, the compile command is
Xcalled with - for example - \fC vcat Shapefile[2.5] | shape -k -f -.\fR
XOtherwise the compile command is called with \fCshape -k.\fR
XYou can change this by editing the minibuffer.
X.SH WISHES/FLAMES/BUGS/PRAISES
X.PP
XIf you suggestions or wishes for enhancements, type faithfully \fCW;\fR
Xfor bug reports \fCB\fR. In both cases the EMACS mail is called and
Xyou get the standard mail buffer with some default values added.
XFor example, the \fCB\fR offers you a buffer like this (for the string
X\fCretrv\fR, the related tool, you are prompted):
X.nf
X	   \fCIndex: retrv
X	   To: shape-bugs@coma.UUCP
X	   Subject: 
X	   --text follows this line--
X
X	   Description:
X
X	   Repeat-By:
X
X	   Fix:
X.if\fR
X.SH THE SHAPETOOLS INTERFACE WITH EMACS AND X
XThe shapetools interface with EMACS and X provides basically the
Xsame features as the interface for alphanumeric terminals. In fact
Xthe key bindings described above are identical.
XPositioning of the cursor is now possible by moving the mouse
Xand pressing the left mouse button.
XAdditionally a pop-up menu is supplied to chose the actions.
XYou get the menu by pressing the middle mouse button and hold it down.
XThe menu consist of four sections:
X.IP "About the Shape Toolkit"
XIn this section you can get the description of the Shape mode, that is
Xwhat you get normally typing \fC?\fR, and you can mail wishes or
Xbugs. Furthermore you can view the manuals of the shape tool kit.
X.IP "Extended Commands"
XYou can execute all commands of the shape toolkit by entering the
Xparameters in the minibuffer (in the alphanumeric mode you can
Xuse \fCM-x shell-command\fR).
X.IP "Miscellaneous Commands"
XHere you can fold the directory or the versions of a file and
Xupdate the buffer (i.e. the \fCg\fR command).
X.IP "Version Control"
XThis section deals with versions: you can save or retrieve a version,
Xpromote or unpromote versions, compare versions, flag files or
Xversions for deletions and execute them.
X.RE
X
END_OF_FILE
if test 9634 -ne `wc -c <'man/man1/shapetools.1'`; then
    echo shar: \"'man/man1/shapetools.1'\" unpacked with wrong size!
fi
# end of 'man/man1/shapetools.1'
fi
if test -f 'src/afs/afsattrs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/afs/afsattrs.c'\"
else
echo shar: Extracting \"'src/afs/afsattrs.c'\" \(9878 characters\)
sed "s/^X//" >'src/afs/afsattrs.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X/*LINTLIBRARY*/
X/*
X *	Shape/AFS
X *
X *	afsattrs.c - reading and writing simple attributes
X *
X *	Author: Andreas Lampen, TU-Berlin (andy@coma.UUCP
X *					   andy@db0tui62.BITNET)
X *
X *	$Header: afsattrs.c[1.5] Wed Feb 22 16:27:54 1989 andy@coma published $
X *
X *	EXPORT:
X *	af_rname -- get name
X *	af_rtype -- get type
X *	af_rsyspath -- get system pathname
X *	af_rgen -- return generation number
X *	af_rrev -- return revision number
X *      af_rowner -- return owner
X *      af_chowner -- change owner
X *      af_rauthor -- return author
X *      af_chauthor -- return author
X *	af_chmod -- change mode
X *	af_gattrs -- get attribute buffer
X *
X *      OBSOLETE:
X *	af_rouid -- return user id of owner
X *	af_rogid -- return group id of owner
X *	af_chown -- change uid and gid of owner
X *	af_rauid -- return user id of author
X *	af_ragid -- return group id of author
X *	af_chaut -- change uid and gid of author
X */
X
X#include <stdio.h>
X#include <string.h>
X#ifdef SUNOS_4_0
X#include <strings.h>
X#endif
X
X#include "typeconv.h"
X#include "afsys.h"
X#include "afs.h"
X
Xchar *malloc();
X
X/*====================================================================
X *    af_rname -- return name
X *
X *====================================================================*/
X
XEXPORT char *af_rname (key)
X     Af_key *key;
X{
X  char *name;
X
X  if (af_keytest (key))
X    SFAIL ("rname", "", AF_EINVKEY, (char *)0);
X
X  if ((name = malloc ((unsigned) (strlen (VATTR(key).af_name) + sizeof (char)))) == (char *)0)
X    FAIL ("rname", "malloc", AF_ESYSERR, (char *)0);
X  (void) strcpy (name, VATTR(key).af_name);
X  return (name);
X}
X
X
X/*====================================================================
X *    af_rtype -- return type
X *
X *====================================================================*/
X
XEXPORT char *af_rtype (key)
X     Af_key *key;
X{
X  char *type;
X
X  if (af_keytest (key))
X    SFAIL ("rtype", "", AF_EINVKEY, (char *)0);
X  if (!VATTR(key).af_type)
X    return ((char *)0);
X
X  if ((type = malloc ((unsigned) (strlen (VATTR(key).af_type) + sizeof (char)))) == (char *)0)
X    FAIL ("rtype", "malloc", AF_ESYSERR, (char *)0);
X  (void) strcpy (type, VATTR(key).af_type);
X  return (type);
X}
X
X
X/*====================================================================
X *    af_rsyspath -- return system pathname
X *
X *====================================================================*/
X
XEXPORT char *af_rsyspath (key)
X     Af_key *key;
X{
X  char   *syspath;
X
X  if (af_keytest (key))
X    SFAIL ("rsyspath", "", AF_EINVKEY, (char *)0);
X
X  if ((syspath = malloc ((unsigned) (strlen (CATTR(key).af_syspath) + sizeof (char)))) == (char *)0)
X    FAIL ("rsyspath", "malloc", AF_ESYSERR, (char *)0);
X  (void) strcpy (syspath, CATTR(key).af_syspath);
X  return (syspath);
X}
X
X
X/*====================================================================
X *    af_rgen -- return generation number
X *
X *====================================================================*/
X
XEXPORT af_rgen (key)
X     Af_key *key;
X{
X  if (af_keytest (key))
X    SFAIL ("rgen", "", AF_EINVKEY, ERROR);
X  return (VATTR(key).af_gen);
X}
X
X
X/*====================================================================
X *    af_rrev -- return revision number
X *
X *====================================================================*/
X
XEXPORT af_rrev (key)
X     Af_key *key;
X{
X  if (af_keytest (key))
X    SFAIL ("rrev", "", AF_EINVKEY, ERROR);
X  return (VATTR(key).af_rev);
X}
X
X/*====================================================================
X *      af_rowner -- return owner
X *
X *====================================================================*/
X
XEXPORT Af_user *af_rowner (key)
X     Af_key *key;
X{
X  static Af_user owner;
X
X  if (af_keytest (key))
X    SFAIL ("rowner", "", AF_EINVKEY, (Af_user *)0);
X
X  (void) strcpy (owner.af_username, CATTR(key).af_ownname);
X  (void) strcpy (owner.af_userhost, CATTR(key).af_ownhost);
X  return (&owner);
X}
X
X/*====================================================================
X *      af_chowner -- change owner
X *
X *====================================================================*/
X
XEXPORT af_chowner (key, owner)
X     /*ARGSUSED*/
X     Af_key  *key;
X     Af_user *owner;
X{
X  /* not yet implemented (chowner) */
X  SFAIL ("chowner", "", AF_EACCES, ERROR);
X}
X
X/*====================================================================
X *      af_rauthor -- return author
X *
X *====================================================================*/
X
XEXPORT Af_user *af_rauthor (key)
X     Af_key *key;
X{
X  static Af_user author;
X
X  if (af_keytest (key))
X    SFAIL ("rauthor", "", AF_EINVKEY, (Af_user *)0);
X
X  (void) strcpy (author.af_username, VATTR(key).af_auname);
X  (void) strcpy (author.af_userhost, VATTR(key).af_auhost);
X  return (&author);
X}
X
X/*====================================================================
X *      af_chauthor -- return author
X *
X *====================================================================*/
X
XEXPORT af_chauthor (key, author)
X     Af_key  *key;
X     Af_user *author;
X{
X  Uid_t uid;
X  Gid_t gid;
X
X  if (af_keytest (key))
X    SFAIL ("chauthor", "", AF_EINVKEY, ERROR);
X  if (af_checkperm (key, AF_OWNER) == ERROR)
X    return (ERROR);
X
X  if (VATTR(key).af_state == AF_BUSY)
X    {
X      if ((uid = af_getuid (author->af_username, author->af_userhost))
X	  == (Uid_t) -1)
X	SFAIL ("chauthor", "", AF_EINVUSER, ERROR);
X      if ((gid = af_getgid (author->af_username, author->af_userhost))
X	  == (Gid_t) -1)
X	SFAIL ("chauthor", "", AF_EINVUSER, ERROR);
X      if (af_uchown (key->af_ldes->af_busyfilename, (int) uid, (int) gid) == ERROR)
X	FAIL ("chauthor", "chown", AF_ESYSERR, ERROR);
X    }
X  else
X    {
X      VATTR(key).af_auname = af_entersym (author->af_username);
X      VATTR(key).af_auhost = af_enterhost (author->af_userhost);
X    }
X  if (af_updtvers (key, AF_CHANGE) == ERROR)
X    return (ERROR);
X  return (AF_OK);
X}
X
X/*====================================================================
X *    af_chmod -- change mode
X *
X *====================================================================*/
X
XEXPORT af_chmod (key, mode)
X     Af_key *key;
X     int    mode;
X{
X  if (af_keytest (key))
X    SFAIL ("chmod", "", AF_EINVKEY, ERROR);
X
X  if (af_checkperm (key, AF_OWNER | AF_AUTHOR) == ERROR)
X    return (ERROR);
X
X  if (VATTR(key).af_state == AF_BUSY)
X    {
X      if (af_uchmod (key->af_ldes->af_busyfilename, mode) == ERROR)
X	FAIL ("chmod", "chmod", AF_ESYSERR, ERROR);
X    }
X  else
X    VATTR(key).af_mode = mode;
X 
X  if (af_updtvers (key, AF_CHANGE) == ERROR)
X	return (ERROR);
X
X  return (AF_OK);
X}
X
X
X/*====================================================================
X *    af_gattrs -- get attribute buffer
X *
X *====================================================================*/
X
XEXPORT af_gattrs (key, attrbuf)
X     Af_key   *key;
X     Af_attrs *attrbuf;
X{
X  int i=0, size;
X  char *udalist[AF_MAXUDAS], *udattrs, *valptr;
X
X  if (af_keytest (key))
X    SFAIL ("gattrs", "", AF_EINVKEY, ERROR);
X
X  (void) strcpy (attrbuf->af_host, CATTR(key).af_host);
X  (void) strcpy (attrbuf->af_name, VATTR(key).af_name);
X  (void) strcpy (attrbuf->af_type, NOTNIL(VATTR(key).af_type));
X  (void) strcpy (attrbuf->af_syspath, CATTR(key).af_syspath);
X
X  attrbuf->af_gen = VATTR(key).af_gen;
X  attrbuf->af_rev = VATTR(key).af_rev;
X  (void) strcpy (attrbuf->af_variant, NOTNIL(VATTR(key).af_variant));
X  attrbuf->af_state = (int) VATTR(key).af_state;
X  (void) strcpy (attrbuf->af_owner.af_username, CATTR(key).af_ownname);
X  (void) strcpy (attrbuf->af_owner.af_userhost, CATTR(key).af_ownhost);
X  (void) strcpy (attrbuf->af_author.af_username, VATTR(key).af_auname);
X  (void) strcpy (attrbuf->af_author.af_userhost, VATTR(key).af_auhost);
X  attrbuf->af_size = VATTR(key).af_fsize;
X  attrbuf->af_mode = VATTR(key).af_mode;
X  (void) strcpy (attrbuf->af_locker.af_username, NOTNIL(VATTR(key).af_lckname));
X  (void) strcpy (attrbuf->af_locker.af_userhost, NOTNIL(VATTR(key).af_lckhost));
X  attrbuf->af_mtime = VATTR(key).af_mtime;
X  attrbuf->af_atime = VATTR(key).af_atime;
X  attrbuf->af_ctime = VATTR(key).af_ctime;
X  attrbuf->af_stime = VATTR(key).af_stime;
X  attrbuf->af_ltime = VATTR(key).af_ltime;
X
X  /* copy user defined attributes */
X  if (VATTR(key).af_udanum > 0)
X    {
X      size = af_lhashsyms (&(VATTR(key).af_uhtab), udalist);
X      if ((udattrs = malloc ((unsigned) size)) == (char *)0)
X	FAIL ("gattrs", "malloc", AF_ESYSERR, ERROR);
X      while (udalist[i] != (char *)0)
X	{
X	  (void) strcpy (udattrs, udalist[i]);
X	  /* replace delimiters by '\n' */
X	  valptr = index (udattrs, AF_UDANAMDEL);
X	  while ((valptr = index (valptr, AF_UDAVALDEL)) != (char *)0)
X	    valptr[0] = '\n';
X	  attrbuf->af_udattrs[i] = udattrs;
X	  udattrs = udattrs + (strlen(udalist[i])+1);
X	  i++;
X	}
X      attrbuf->af_udattrs[i] = (char *)0; /* finish list */
X    }
X  else
X    attrbuf->af_udattrs[0] = (char *)0;
X
X  return (AF_OK);
X}
END_OF_FILE
if test 9878 -ne `wc -c <'src/afs/afsattrs.c'`; then
    echo shar: \"'src/afs/afsattrs.c'\" unpacked with wrong size!
fi
# end of 'src/afs/afsattrs.c'
fi
if test -f 'src/vc/mkattr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/vc/mkattr.c'\"
else
echo shar: Extracting \"'src/vc/mkattr.c'\" \(9705 characters\)
sed "s/^X//" >'src/vc/mkattr.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *AFSid = "$Header: mkattr.c[3.6] Thu Feb 23 18:13:34 1989 axel@coma published $";
X#ifdef CFFLGS
Xstatic char *ConfFlg = CFFLGS;
X	/* should be defined from within Makefile */
X#endif
X#endif
X/*
X * Log for /u/shape/dist-tape/src/vc/mkattr.c[3.2]
X * 	Thu Feb 23 18:13:34 1989 axel@coma published $
X *  --- empty log message ---
X *  mkattr.c[3.5] Thu Feb 23 18:13:34 1989 axel@coma published $
X *  --- empty log message ---
X *  mkattr.c[3.6] Thu Feb 23 18:13:34 1989 axel@coma published $
X *  --- empty log message ---
X */
X
X/*LINTLIBRARY*/
X
X#include <strings.h>
X#include "afs.h"
X#include "retrv.h"
X
X#ifdef lint
Xchar *st_table[] = {
X  "This is a fake definition. The real thing is in libutil (see 'misc')."
X  };
X#else
Xextern char *st_table[];
X#endif lint
X
Xmkvno (vstring) char *vstring; {
X  /*
X   *  converts a string of the form 'gen.rev' (e.g. 12.23) into an
X   *  integer value with the generation part stored in the hiword
X   *  and the revision part in the loword. In case 'vstring'
X   *  is a symbolic version name, which is assumed if the 'gen.rev'
X   *  pattern does not match, a value of zero is returned (0.0 = no vers).
X   */
X  char *emsg, *re_comp();
X  int genno, revno, rc;
X
X  if (emsg = re_comp("[0-9][0-9]*\\.[0-9][0-9]*")) { /* quite liberal RE */
X    logerr (emsg);
X    return 0;
X  }
X  if (fail((rc=re_exec (vstring)))) {
X    logerr ("internal error in matching RE (mkvno)");
X  }
X  if (rc) {
X    (void)sscanf (vstring, "%d.%d", &genno, &revno);
X    return (genno << 16) | (0x0000FFFF & revno);
X
X  }
X  else return 0;
X}
X
XBoundVersion (rawname, cookedname, vstring) 
X     char *rawname, *cookedname, *vstring; {
X/*
X *  This function returns nonzero if 'rawname' is of the form
X *  'foo[1.4]'. In this case 'foo' will be written into 'cookedname'
X *  and 'vstring' will become '1.4'. Otherwise, both are left unchanged
X *  and the funtion returns zero.
X */
X       char *b1, *b2;
X       int vno;
X
X       if ((b1=rindex (rawname, '[')) && (b2 = rindex (rawname, ']'))
X	   && (b1 < b2)) {
X	 *b1 = *b2 = '\0'; /* make 'em separate strings */
X	 if (mkvno (b1+1)) {
X	   (void)strcpy (cookedname, rawname);
X	   (void)strcpy (vstring, b1+1);
X	   *b1 = '['; *b2 = ']';
X	   return TRUE;
X	 }
X	 else {
X	   if (vno=Symn2Vno (rawname, b1+1)) {
X	     (void)sprintf (vstring, "%d.%d", gen(vno), rev(vno));
X	     (void)strcpy (cookedname, rawname);
X	     *b1 = '['; *b2 = ']';
X	     return TRUE;
X	   }
X	   *b1 = '['; *b2 = ']';
X	 }
X       }
X       return FALSE;
X     }
X       
Xmkgenno (gstring) char *gstring; {
X  int genno;
X
X  genno = atoi (gstring);
X  if (genno < 0)
X    return 0;
X  else 
X    return (genno < 1000) ? genno : 0;
X}
X
Xint Symn2Vno (fname, sym) char *fname, *sym; {
X  Af_attrs warrant;
X  Af_set   hits;
X  Af_key   key;
X  char symname[256], messg[80], *p;
X  int rc, vnum;
X
X  af_initattrs (&warrant);
X  (void)sprintf (symname, "%s=%s", SYMNAME, sym);
X  warrant.af_udattrs[0] = symname;
X  warrant.af_udattrs[1] = (char *)NULL;
X  (void)strcpy (warrant.af_syspath, p=af_afpath(fname)); free (p);
X  (void)strcpy (warrant.af_name, p=af_afname(fname)); free (p);
X  (void)strcpy (warrant.af_type, p=af_aftype(fname)); free (p);
X  if ((rc=af_find (&warrant, &hits)) > 1) { 
X    /* this shouldn't happen, as symbolic names are supposed to be */
X    /* within one ASO's history */
X    af_dropset (&hits);
X    (void)sprintf (messg, 
X     "%s's history inconsistent.\nSymbolic name \"%s\" multiply assigned.",
X	     fname, sym);
X    logerr (messg);
X    return FALSE;
X  }
X  else if (rc < 0) {
X    af_perror ("af_find (in SymnameInUse)");
X    return FALSE;
X  }
X  else if (rc == 0) {
X    af_dropset (&hits);
X    return FALSE;
X  }
X  else { /* rc must be 1 -- thats just fine */
X    af_setgkey (&hits, 0, &key);
X    af_dropset (&hits);
X    vnum = ((af_rgen (&key) << 16) | (0x0000FFFF & af_rrev (&key)));
X    return vnum;
X  }
X}
X
X  
Xmkstate (sstring) char *sstring; {
X  int i;
X  register char *cp;
X
X  cp = sstring;
X  while (*cp ? (*cp++ |= ' ') : 0); /* convert to lowercase */
X  for (i = AF_BUSY; i <= AF_FROZEN; i++)
X    if (!strcmp (st_table[i], sstring))
X      return i;
X  return -1;
X}
X
X#define BOTIME 70        /* Beginning Of TIME for Unix */
X#define DINYEAR 365      /* No. of days in a non-leapyear */
X#define DINMONTH 31      /* No. of days in a 'canonical' month */
X#define SINDAY 86400     /* No. of seconds in a day (24 * 60 * 60) */
X#define SINHR 3600       /* No. of seconds in an hour */
X#define SINMIN 60        /* ... guess! ... */
X
Xtime_t mktime (tstring) char *tstring; {
X  /*
X   *  converts a YY/MM/DD[/HH:MM] string into a system time representation
X   *  which by convention is the number of seconds since Jan. 1st 1970.
X   */
X  char *emsg, *re_comp();
X  int yr, mo, dy, hr = 0, mint = 0, nfyrs, ndays, nsecs;
X
X  if (emsg = re_comp((strlen (tstring) > 8) ? 
X		     "[0-9][0-9]/[01][0-9]/[0-3][0-9]/[0-5][0-9]:[0-5][0-9]" :
X		     "[0-9][0-9]/[01][0-9]/[0-3][0-9]")) {
X    logerr (emsg);
X    return 0;
X  }
X  if (re_exec (tstring)) {
X    (void)sscanf (tstring, "%d/%d/%d/%d:%d", &yr, &mo, &dy, &hr, &mint);
X    if ((chkyr (yr)) && (chkmo (yr, mo)) && (chkdy (yr, mo, dy)) && 
X	(chkhr (dy, hr)) && (chkmin (hr, mint))) {
X      nfyrs = yr - BOTIME;
X      ndays = nfyrs * DINYEAR + nlyrs (yr, BOTIME) + 
X	(mo-1)*DINMONTH - cordays (yr, mo-1) + (dy-1);
X      nsecs = ndays * SINDAY + (hr-1) * SINHR + mint * SINMIN;
X      return nsecs;       /* it ^^^^ shouldn't be hr-1 but hr - confused! */
X    }
X    else return 0;
X  }
X  else return 0;
X}
X
Xchkyr (year) {
X  struct tm *now, *localtime();
X  struct timeval t;
X  struct timezone tzone; 
X
X  (void)gettimeofday (&t, &tzone);
X  now = localtime (&t.tv_sec);
X  return ((year >= 70) && (year <= now->tm_year));
X}
X
Xchkmo (year, month) {
X  struct tm *now, *localtime();
X  struct timeval t;
X  struct timezone tzone; 
X
X  (void)gettimeofday (&t, &tzone);
X  now = localtime (&t.tv_sec);
X  if ((month <= 12) && (month >= 1))
X    return (now->tm_year == year) ? (month <= now->tm_mon+1) : TRUE;
X  else
X    return FALSE;
X}
X
Xint itstoday = FALSE;
X    
Xchkdy (year, month, day) {
X  struct tm *now, *localtime();
X  struct timeval t;
X  struct timezone tzone; 
X
X  month--; /* only here: Jan is 0, Dec is 11 -- as is in struct tm */
X  (void)gettimeofday (&t, &tzone);
X  now = localtime (&t.tv_sec);
X  itstoday = ((year == now->tm_year) && (month == now->tm_mon) &&
X	      (day == now->tm_mday));
X  if ((day <= 28) && ((year < now->tm_year) || (month < now->tm_mon)))
X    return TRUE;
X  else { /* some day in this month or a day at the end of some month */
X    switch (month) {
X    case 0:
X    case 2:
X    case 4:
X    case 6:
X    case 7:
X    case 9:
X    case 11:
X      return ((day <= 31) && 
X	      (((now->tm_year == year) && (now->tm_mon == month)) ?
X	       (day <= now->tm_mday) : TRUE));
X    case 3:
X    case 5:
X    case 8:
X    case 10:
X      return ((day <= 30) && 
X	      (((now->tm_year == year) && (now->tm_mon == month)) ?
X	       (day <= now->tm_mday) : TRUE));
X    case 1:
X      return (((isalyr (year)) ? (day <= 29) : (day <= 28)) && 
X	      (((now->tm_year == year) && (now->tm_mon == month)) ?
X	       (day <= now->tm_mday) : TRUE));
X    default:
X      logerr ("Heavens ! Our month-check doesn't work. (internal error)");
X      return FALSE;
X    }
X  }
X}
X/*ARGSUSED*/
Xchkhr (day, hour) {
X  struct tm *now, *localtime();
X  struct timeval t;
X  struct timezone tzone; 
X
X  (void)gettimeofday (&t, &tzone);
X  now = localtime (&t.tv_sec);
X  if ((hour >= 0) && (hour <= 23))
X    return (itstoday ? (hour <= now->tm_hour) : TRUE);
X  else
X    return FALSE;
X}
X
Xchkmin (hour, mint) {
X  struct tm *now, *localtime();
X  struct timeval t;
X  struct timezone tzone; 
X
X  (void)gettimeofday (&t, &tzone);
X  now = localtime (&t.tv_sec);
X  if ((mint >= 0) && (mint <= 59))
X    return ((itstoday && (hour == now->tm_hour)) ? 
X	    (mint <= now->tm_min) : TRUE);
X  else
X    return FALSE;
X}
X
Xisalyr (year) {
X  /*
X   *  assumes year to be a reasonable value
X   *  checking is done according rules asked from K. Koester
X   */
X  if ((year % 2000) == 0)
X    return FALSE;
X  if ((year % 400) == 0)
X    return TRUE;
X  if ((year % 100) == 0)
X    return FALSE;
X  else
X    return ((year % 4) == 0);
X}
X
Xnlyrs (year, since) {
X  /*
X   *  returns number of leapyears from <since> to Jan. 1st <year>
X   */
X  register int i, lyrs=0;
X
X  for (i = since; i < year; i++)
X    if (isalyr(i)) lyrs++;
X  return lyrs;
X}
X
Xint dcorlist[] = { 0, 0, 3, 3, 4, 4, 5, 5, 5, 6, 6, 7, 7 };
X
Xcordays (year, month) {
X  /*
X   *  returns number of days to substract from the sum of <month>
X   *  31-day months.
X   */
X  
X  if (isalyr (year))
X    return ((dcorlist[month]) ? (dcorlist[month] - 1) : 0);
X  else 
X    return dcorlist[month];
X}
X    
END_OF_FILE
if test 9705 -ne `wc -c <'src/vc/mkattr.c'`; then
    echo shar: \"'src/vc/mkattr.c'\" unpacked with wrong size!
fi
# end of 'src/vc/mkattr.c'
fi
if test -f 'src/vc/vadm_symname.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/vc/vadm_symname.c'\"
else
echo shar: Extracting \"'src/vc/vadm_symname.c'\" \(10086 characters\)
sed "s/^X//" >'src/vc/vadm_symname.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *AFSid = "$Header: vadm_symname.c[3.8] Thu Feb 23 18:14:21 1989 axel@coma published $";
X#ifdef CFFLGS
Xstatic char *ConfFlg = CFFLGS;
X	/* should be defined from within Makefile */
X#endif
X#endif
X/*
X * Log for /u/shape/dist-tape/src/vc/vadm_symname.c[3.2]
X * 	Thu Feb 23 18:14:22 1989 axel@coma published $
X *  --- empty log message ---
X *  vadm_symname.c[3.5] Thu Feb 23 18:14:22 1989 axel@coma published $
X *  --- empty log message ---
X *  vadm_symname.c[3.6] Thu Feb 23 18:14:22 1989 axel@coma save $
X *  --- empty log message ---
X *  vadm_symname.c[3.7] Thu Feb 23 18:14:22 1989 axel@coma save $
X *  --- empty log message ---
X *  vadm_symname.c[3.8] Thu Feb 23 18:14:22 1989 axel@coma published $
X *  --- empty log message ---
X */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X
X#include <stdio.h>
X#include <strings.h>
X#include <afs.h>
X
X#include "vadm.h"
X#include "project.h"
X#include "afsapp.h"
X
Xextern unsigned options;
Xextern int def_vnum;
Xextern struct Transaction ThisTransaction;
X/* locals */
Xstatic char buf[1024];
X
X/**/
XDoSymname (vlist, ac, av, sym)
X     struct vc_vlist *vlist;
X     int ac;
X     char **av;
X     char *sym;
X{
X  Af_set set;
X  char **erroneous;
X  int i, errs;
X  char version[2048];
X  char symname[2048];
X  
X  if (SymnameInUse (ac, av, sym)) {
X    (void)sprintf (buf, "symbolic name %s already assigned to some other version.",
X	     sym);
X    logerr (buf);
X    return 1;
X  }
X  if (IsOptionSet(Vopt_version)) {
X    errs = GetKeysByGenRev
X	(ac,av, gen(def_vnum), rev(def_vnum), &set, &erroneous);
X  }
X  else {
X    if (!vlist->from_version_set || !vlist->to_version_set) {
X      if (IsOptionSet (Vopt_binary))
X	errs = GetKeysByGenRev 
X	  (ac,av, AF_BUSYVERS, AF_BUSYVERS, &set, &erroneous);
X      else
X	errs = GetKeysByGenRev 
X	  (ac,av, AF_LASTVERS, AF_LASTVERS, &set, &erroneous);
X    }
X    else
X      errs = GetKeysByName (ac, av, vlist, &set, &erroneous);
X  }
X
X  if (errs)
X    print_erroneous (erroneous, errs);
X
X  if (!set.af_nkeys) {
X    logmsg ("Nothing appropriate found.");
X    return 1;
X  }
X
X  if (errs && !ask_confirm ("Continue ?", "yes"))
X    return 1;
X
X  (void)sprintf (symname, "%s=%s", SYMNAME, sym);
X  
X  for (i = 0; i < set.af_nkeys; i++) {
X    mkvstring (version, &set.af_klist[i]);
X    if (setjmp (ThisTransaction.tr_env)) continue; 
X    if (af_sudattr (&set.af_klist[i], AF_ADD, symname) == -1) {
X      af_perror ("DoSymname: af_sudattr");
X      return 1;
X    }
X    (void)sprintf (buf, "Symbolic name %s attached to %s.", sym, version);
X    logmsg (buf);
X  }
X  return 0;
X}
X
XDoSetCommentSymbol (ac, av, sym)
X     int ac;
X     char **av;
X     char *sym;
X{
X  Af_set set;
X  char **erroneous, c_symbol[CLEADMAXLEN];
X  int i, errs;
X  
X  errs = GetKeysByName (ac, av, (struct vc_vlist *)NULL, &set, 
X			&erroneous);
X
X  if (errs)
X    print_erroneous (erroneous, errs);
X
X  if (!set.af_nkeys) {
X    logmsg ("Nothing appropriate found.");
X    return 1;
X  }
X
X  if (errs && !ask_confirm ("Continue ?", "yes"))
X    return 1;
X
X  (void)sprintf (c_symbol, "%s=%s", CLEAD, sym);
X  
X  for (i = 0; i < set.af_nkeys; i++) {
X
X    if (setjmp (ThisTransaction.tr_env)) continue;
X    if (af_sudattr (&set.af_klist[i], AF_REPLACE, c_symbol) == -1) {
X      if (af_sudattr (&set.af_klist[i], AF_ADD, c_symbol) == -1) {
X	af_perror ("DoSetCommentSymbol: af_suadttr");
X	return 1;
X      }
X    }
X  }
X  return 0;
X}
X
XDoSetUda (vlist, ac, av)
X     struct vc_vlist *vlist;
X     int ac;
X     char **av;
X{
X  extern char *TakeFromFile, udaname[], udaval[];
X
X  Af_set set;
X  char **erroneous;
X  int i, errs, udamemlen;
X  char version[128], *hook, *udamem, *cp, messg[80], *malloc();
X  FILE *tff;
X  struct stat sbuf;
X
X  if (IsOptionSet(Vopt_version)) {
X    errs = GetKeysByGenRev
X	(ac,av, gen(def_vnum), rev(def_vnum), &set, &erroneous);
X  }
X  else {
X    if (!vlist->from_version_set || !vlist->to_version_set)
X      errs = GetKeysByGenRev 
X	(ac,av, AF_BUSYVERS, AF_BUSYVERS, &set, &erroneous);
X    else
X      errs = GetKeysByName (ac, av, vlist, &set, &erroneous);
X  }
X  if (errs)
X    print_erroneous (erroneous, errs);
X
X  if (!set.af_nkeys) {
X    logmsg ("Nothing appropriate found.");
X    return 1;
X  }
X
X  if (errs && !ask_confirm ("Continue ?", "yes"))
X    return 1;
X
X  if (TakeFromFile) {
X    if ((tff = fopen (TakeFromFile, "r")) == NULL) {
X      (void)sprintf (messg, "can't open attribute value file %s.", TakeFromFile);
X      logerr (messg);
X      return 1;
X    }
X    if (fstat (fileno (tff), &sbuf) < 0) {
X      perror ("fstat");
X      return 1;
X    }
X    udamem = 
X      malloc ((unsigned)(udamemlen=(strlen (udaname) + sbuf.st_size + 2)));
X    if (udamem == NULL) {
X      logerr ("Not enough memory to build attribute");
X      return 1;
X    }
X    (void)sprintf (udamem, "%s=", udaname);
X    cp = udamem + strlen (udamem);
X    (void)fread (cp, sizeof (char), (Size_t)sbuf.st_size, tff); 
X    (void)fclose (tff);
X    udamem[udamemlen-1] = '\0';
X  }
X  else { /* udaval not taken from file */
X    udamem = 
X      malloc ((unsigned)(udamemlen=(strlen (udaname) + strlen (udaval) + 2)));
X    if (udamem == NULL) {
X      logerr ("Not enough memory to build attribute");
X      return 1;
X    }
X    (void)sprintf (udamem, "%s=%s", udaname, udaval);
X  }  
X  for (i = 0; i < set.af_nkeys; i++) {
X    if (setjmp (ThisTransaction.tr_env)) continue;
X    mkvstring (version, &set.af_klist[i]);
X
X    if (hook=af_rudattr (&set.af_klist[i], udaname)) {
X      free (hook);
X      if (af_sudattr (&set.af_klist[i], AF_REPLACE, udamem) == -1) {
X	af_perror ("af_sudattr");
X	return 1;
X      }
X    }
X    else { /* attribute is newly introduced */
X      if (af_sudattr (&set.af_klist[i], AF_ADD, udamem) == -1) {
X	af_perror ("af_suadttr");
X	return 1;
X      }
X    }
X  }
X  free (udamem);
X  return 0;
X}
X
XDoUnsetUda (vlist, ac, av)
X     struct vc_vlist *vlist;
X     int ac;
X     char **av;
X{
X  extern char udaname[];
X
X  Af_set set;
X  char **erroneous;
X  int i, errs;
X  char version[128], *hook;
X
X  if (IsOptionSet(Vopt_version)) {
X    errs = GetKeysByGenRev
X	(ac,av, gen(def_vnum), rev(def_vnum), &set, &erroneous);
X  }
X  else {
X    if (!vlist->from_version_set || !vlist->to_version_set)
X      errs = GetKeysByGenRev 
X	(ac,av, AF_BUSYVERS, AF_BUSYVERS, &set, &erroneous);
X    else
X      errs = GetKeysByName (ac, av, vlist, &set, &erroneous);
X  }
X  if (errs)
X    print_erroneous (erroneous, errs);
X
X  if (!set.af_nkeys) {
X    logmsg ("Nothing appropriate found.");
X    return 1;
X  }
X
X  if (errs && !ask_confirm ("Continue ?", "yes"))
X    return 1;
X
X  for (i = 0; i < set.af_nkeys; i++) {
X    mkvstring (version, &set.af_klist[i]);
X    if (setjmp (ThisTransaction.tr_env)) continue; 
X    if (hook=af_rudattr (&set.af_klist[i], udaname)) {
X      free (hook);
X      if (af_sudattr (&set.af_klist[i], AF_REMOVE, udaname) == -1) {
X	af_perror ("af_sudattr");
X	return 1;
X      }
X    }
X  }
X  return 0;
X}
X
Xint DoSetAttrs (vlist, ac, av)
X     struct vc_vlist *vlist;
X     int ac;
X     char **av;
X{
X  extern char Attrfile[];
X
X  char *as, **erroneous, *getattr(), version[128];
X  Af_set set;
X  register int i;
X  int errs;
X
X  if (IsOptionSet(Vopt_version)) {
X    errs = GetKeysByGenRev
X	(ac,av, gen(def_vnum), rev(def_vnum), &set, &erroneous);
X  }
X  else {
X    if (!vlist->from_version_set || !vlist->to_version_set)
X      errs = GetKeysByGenRev 
X	(ac,av, AF_BUSYVERS, AF_BUSYVERS, &set, &erroneous);
X    else
X      errs = GetKeysByName (ac, av, vlist, &set, &erroneous);
X  }
X  if (errs)
X    print_erroneous (erroneous, errs);
X
X  if (!set.af_nkeys) {
X    logmsg ("Nothing appropriate found.");
X    return 1;
X  }
X
X  if (errs && !ask_confirm ("Continue ?", "yes"))
X    return 1;
X
X  for (i = 0; i < set.af_nkeys; i++) {
X    mkvstring (version, &set.af_klist[i]);
X    if (setjmp (ThisTransaction.tr_env)) continue; 
X    as = getattr (Attrfile, (Project *)NULL, (char *)NULL, REWIND);
X    af_sudattr (&set.af_klist[i], AF_ADD, as);
X    while (as=getattr (Attrfile, (Project *)NULL, (char *)NULL, NEXT)) {
X      af_sudattr (&set.af_klist[i], AF_ADD, as);
X    }
X  }
X  return FALSE;
X}
X
Xint SymnameInUse (ac, av, sym) int ac; char **av, *sym; {
X  /*
X   * Function yields TRUE, if any version of any object named in 'av'
X   * has the name 'sym' assigned as value of the user-defined attribute
X   * SYMNAME.
X   */
X  
X  Af_attrs warrant;
X  Af_set hits;
X  int i, rc;
X  char symname[2048], cname[MAXNAMLEN], vstring[80];
X
X  (void)sprintf (symname, "%s=%s", SYMNAME, sym);
X  af_initattrs (&warrant);
X  warrant.af_udattrs[0] = symname;
X  warrant.af_udattrs[1] = (char *)NULL;
X  for (i = 0; i < ac; i++) {
X    if (BoundVersion (av[i], cname, vstring))
X      initwarrant (&warrant, cname);
X    else
X      initwarrant (&warrant, av[i]);
X    if ((rc=af_find (&warrant, &hits) > 0)) { 
X      af_dropset (&hits);
X      return rc;
X    }
X    else if (rc < 0)
X      af_perror ("af_find (in SymnameInUse)");
X  }
X  return FALSE;
X}
X
Xinitwarrant (warrant, fname) Af_attrs *warrant; char *fname; {
X  (void)strcpy (warrant->af_syspath, af_afpath (fname));
X  (void)strcpy (warrant->af_name, af_afname (fname));
X  (void)strcpy (warrant->af_type, af_aftype (fname));
X}
X
END_OF_FILE
if test 10086 -ne `wc -c <'src/vc/vadm_symname.c'`; then
    echo shar: \"'src/vc/vadm_symname.c'\" unpacked with wrong size!
fi
# end of 'src/vc/vadm_symname.c'
fi
if test -f 'src/vc/vlopt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/vc/vlopt.c'\"
else
echo shar: Extracting \"'src/vc/vlopt.c'\" \(9708 characters\)
sed "s/^X//" >'src/vc/vlopt.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *AFSid = "$Header: vlopt.c[3.6] Thu Feb 23 18:14:54 1989 axel@coma published $";
X#ifdef CFFLGS
Xstatic char *ConfFlg = CFFLGS;
X	/* should be defined from within Makefile */
X#endif
X#endif
X/*
X * Log for /u/shape/dist-tape/src/vc/vlopt.c[3.4]
X * 	Thu Feb 23 18:14:54 1989 axel@coma published $
X *  --- empty log message ---
X *  vlopt.c[3.5] Thu Feb 23 18:14:54 1989 axel@coma published $
X *  --- empty log message ---
X *  vlopt.c[3.6] Thu Feb 23 18:14:54 1989 axel@coma published $
X *  --- empty log message ---
X */
X
X#include <stdio.h>
X#include "ParseArgs.h"
X#include "vl.h"
X
X/*
X * Global variables
X */
Xextern int version_number;
Xunsigned int options = 0;	/* where the options goes */
Xint immediate_output = 0;	/* if output should be shipped immediatly */
Xchar multicol_output_possible = 1; /* multi column output flag */
X
Xextern int handle_a_option ();
Xextern int handle_author_options ();
X#ifdef DEBUGCOL
Xextern int handle_dc_option  ();
X#endif DEBUGCOL
X
Xextern int handle_R_option  ();
Xextern int handle_b_option  ();
Xextern int handle_g_option  ();
Xextern int handle_h_option  ();
Xextern int handle_H_options ();
Xextern int handle_l_option  ();
Xextern int handle_L_option  ();
Xextern int handle_last_option ();
Xextern int handle_n_option  ();
Xextern int handle_owner_option  ();
Xextern int handle_author_options ();
Xextern int handle_q_option  ();
Xextern int handle_s_option  ();
Xextern int handle_S_option  ();
Xextern int handle_u_option  ();
Xextern int handle_ux_option ();
Xextern int handle_V_option  ();
X
XOptDesc odesc[] = {
X  { "version", OPT_IS_SWITCH,	handle_R_option },
X  { "a", OPT_IS_SWITCH,		handle_a_option },
X  { "author", OPT_HAS_OPT_ARG,	handle_author_options },
X#ifdef DEBUGCOL
X  { "dc", OPT_IS_SWITCH,	handle_dc_option },
X#endif DEBUGCOL
X  { "b", OPT_IS_SWITCH,         handle_b_option },
X  { "g", OPT_IS_SWITCH,		handle_g_option },
X  { "h", OPT_HAS_OPT_ARG, 	handle_h_option },
X  { "H", OPT_HAS_OPT_ARG,	handle_H_options },
X  { "l", OPT_IS_SWITCH, 	handle_l_option },
X  { "L", OPT_IS_SWITCH, 	handle_L_option },
X  { "y", OPT_IS_SWITCH, 	handle_last_option },
X  { "n", OPT_HAS_ARG,		handle_n_option}, 
X  { "owner", OPT_HAS_OPT_ARG, 	handle_owner_option },
X  { "q", OPT_IS_SWITCH, 	handle_q_option },
X  { "s", OPT_HAS_ARG, 		handle_s_option },
X  { "S", OPT_IS_SWITCH, 	handle_S_option },
X  { "ux", OPT_IS_SWITCH,	handle_ux_option }, 
X  { "u", OPT_HAS_OPT_ARG, 	handle_u_option },
X  { "U", OPT_HAS_OPT_ARG,	handle_u_option },
X  { "V", OPT_HAS_OPT_ARG, 	handle_V_option },
X  { (char *) NULL, NULL, NULL }
X};
X
X#define USAGE_OPT_STR "ablLhHgoqsuSUV"	/* Optstring for Usage() */
X
Xint IsOptionSet (x) unsigned long x; {
X  return (options & (x));
X};
X
X/*ARGSUSED*/
Xhandle_a_option (opt, arg) char *opt, *arg;
X{
X  options |= VL_O_LISTHIDDEN;
X  return 0;
X}
X
X/*ARGSUSED*/
Xhandle_author_options (opt, arg) char *opt, *arg;
X{
X  options |= VL_O_AUTHOR;
X  PutAuthorIdentifications (arg);
X  return 0;
X}
X
X/*ARGSUSED*/
Xhandle_b_option (opt, arg) char *opt, *arg;
X{
X  options |= VL_O_LISTBINARY;
X  return 0;
X}
X
X#ifdef DEBUGCOL
Xchar debugcol = 0;
Xhandle_dc_option (opt)
X     char *opt;
X{
X  debugcol++;
X  return 0;
X}
X#endif DEBUGCOL
X
X/*ARGSUSED*/
Xhandle_g_option  (opt, arg) char *opt, *arg;
X{
X  options |= VL_O_GROUPOUTPUT;
X  return 0;
X}
X
X/*ARGSUSED*/
Xint handle_n_option (opt, arg)
X     char *opt, *arg;
X{
X  options |= VL_O_UDAGIVEN;
X  AddHiddenUda (SYMNAME, arg);
X  return 0;
X}
X
X/*ARGSUSED*/
Xhandle_h_option  (opt, arg) char *opt, *arg;
X{
X  LongUsage();
X  exit (1);
X}
X
X/*ARGSUSED*/
Xhandle_H_options (opt, arg) char *opt, *arg;
X{
X  options |= VL_O_HISTLOG;
X  multicol_output_possible = 0;
X  immediate_output++;
X  
X  if (*arg == '+')
X    options |= VL_O_HISTLOGPLUS;
X
X  return 0;
X}
X
X/*ARGSUSED*/
Xhandle_l_option  (opt, arg) char *opt, *arg;
X{
X  options |= VL_O_LONGOUTPUT;
X  multicol_output_possible = 0;
X  return 0;
X}
X
X/*ARGSUSED*/
Xhandle_L_option  (opt, arg) char *opt, *arg;
X{
X  options |= VL_O_LOGMSG;
X  multicol_output_possible = 0;
X  immediate_output++;
X  return 0;
X}
X
X/*ARGSUSED*/
Xhandle_last_option  (opt, arg) char *opt, *arg;
X{
X  options |= VL_O_LASTVERS;
X  multicol_output_possible = 0;
X  return 0;
X}
X
X/*ARGSUSED*/
Xhandle_owner_option  (opt, arg) char *opt, *arg;
X{
X  extern void PutOwnerIdentifications();
X  options |= VL_O_OWNER;
X  PutOwnerIdentifications (arg);
X  return 0;
X}
X
X/*ARGSUSED*/
Xhandle_q_option  (opt, arg) char *opt, *arg;
X{
X  options |= VL_O_BEQUIET;
X  return 0;
X}
X
X/*ARGSUSED*/
Xhandle_s_option  (opt, arg) char *opt, *arg;
X{
X  options |= VL_O_STATEGIVEN;
X  PutVersionStates (arg);
X  ScanVersionStates ();
X  return 0;
X}
X
X/*ARGSUSED*/
Xhandle_S_option  (opt, arg) char *opt, *arg;
X{
X  options |= VL_O_VERSIONSTATE;
X  return 0;
X}
X
X/*ARGSUSED*/
Xhandle_ux_option (opt)
X     char *opt;
X{
X  options |= VL_O_LISTHIDDENUDAS;
X  return 0;
X}
X
Xhandle_u_option  (opt, arg) char *opt, *arg;
X{
X  if (!strcmp (opt, "U"))
X      options |= VL_O_LISTUDALONG;
X  
X  options |= VL_O_LISTUDA;
X  immediate_output++;
X  
X  if (*arg) {
X    options |= VL_O_UDAGIVEN;
X    /*    PutUdattrs (arg); */
X    AddUdattrs (arg);
X  }
X  multicol_output_possible = 0;
X
X  return 0;
X}
X
X/*ARGSUSED*/
Xhandle_V_option (opt, arg) char *opt, *arg;
X{
X  options |= VL_O_VERSIONNUM;
X  if (version_number = mkvno (arg)) return 0;
X  fprintf (stderr, "\"%s\" is no appropriate argument to \'-V\' option.\n",
X	   arg);
X  return 1;
X}	
X
XLongUsage ()
X
X     /*
X      * Called via option -h. Long help.
X      */
X{
X  fprintf (stderr, "vl lists the version informations of the given files.\n");
X  fprintf (stderr, "When no argument is given, the current directory is checked.\n");
X  fprintf (stderr, "Options are:\n");
X  fprintf (stderr, " -A              list all information about Afs file.\n");
X  fprintf (stderr, " -author authorspec   list Afs files matching author specifications.\n");
X  fprintf (stderr, " -owner ownerspec    list Afs files matching owner specifications.\n");
X  fprintf (stderr, "                 Author- and ownerspec can be of the form:\n");
X  fprintf (stderr, "                   'user.group' || 'user.' || '.group' || '.'\n");
X  fprintf (stderr, "                 the last form specifies any user and any group.\n");
X  fprintf (stderr, " -l              list info in long format (as ls(1)).\n");
X  fprintf (stderr, " -a              list also hidden file.\n");
X  fprintf (stderr, " -n relspec      list all Afs files that are part of a release.\n");
X  fprintf (stderr, "                 Relspec is a symbolic name given at save time.\n");
X  fprintf (stderr, "                 If no relspec is given all Afs files that are\n");
X  fprintf (stderr, "                 part of any release are printed.\n");
X  fprintf (stderr, " -g              list also group name (only effective when -l given).\n");
X  fprintf (stderr, " -s versstate    list version with specified version state set.\n");
X  fprintf (stderr, " -q              Be quiet. Set only status on exit.\n");
X  fprintf (stderr, " -S              list version state verbose.\n");
X  fprintf (stderr, " -u[:udaspec]    list user defined attributes.\n");
X  fprintf (stderr, " -U[:udaspec]    list user defined attributes and corresponding values.\n");
X  fprintf (stderr, "                 When 'udaspec' is given all Afs files matching udaspec\n");
X  fprintf (stderr, "                 are printed.\n");
X  fprintf (stderr, "                 Udaspec can be of the form:\n");
X  fprintf (stderr, "                 name[=value[ value [...]]][,value[...]]...\n");
X  fprintf (stderr, "                 For more infomation see also af_retrieve(3)\n");
X  fprintf (stderr, " -ux             list also hidden uda, iff -u or -U is given\n");
X  fprintf (stderr, " -V versspec     list Afs files with version number versspec (e.g. -V1.19).\n");
X  fprintf (stderr, "                 'Versspec' can be of the form:\n");
X  fprintf (stderr, "                  'generation.revision' || 'generation.' || '.revision' || '.'\n");
X  fprintf (stderr, "                 The last form represents all possible version numbers.\n");
X  fprintf (stderr, " -L              cat log message of Afs files. Afs file name required.\n");
X  fprintf (stderr, " -H              list history of log messages up to a specified version (-V).\n");
X  fprintf (stderr, "                 When '-H+' is given the history is listed from the specified.\n");
X  fprintf (stderr, "                 version upto the last version.\n");
X}
X
X#define STDOUT_FDESC 1
X
Xint multicol_output_is_possible ()
X{
X  return (multicol_output_possible && isatty (STDOUT_FDESC));
X}
X
XCheckProgramName (progname)
X     char *progname;
X{
X  extern char *rindex();
X  
X  if (!strcmp (progname, "vlog")) {
X    (void)handle_L_option ((char *)NULL, (char *)NULL);
X  }
X}
END_OF_FILE
if test 9708 -ne `wc -c <'src/vc/vlopt.c'`; then
    echo shar: \"'src/vc/vlopt.c'\" unpacked with wrong size!
fi
# end of 'src/vc/vlopt.c'
fi
echo shar: End of archive 12 \(of 33\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
