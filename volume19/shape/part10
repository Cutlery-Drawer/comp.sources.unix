Subject:  v19i023:  A software configuration management system, Part10/33
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Axel Mahler <unido!coma!axel>
Posting-number: Volume 19, Issue 23
Archive-name: shape/part10



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 10 (of 33)."
# Contents:  man/man1/vl.1 man/man1/vlog.1 src/afs/lcs.cdlt.c
#   src/shape/Makefile src/shape/std.c src/vc/vadm_promote.c
# Wrapped by rsalz@papaya.bbn.com on Thu Jun  1 19:26:59 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'man/man1/vl.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/man1/vl.1'\"
else
echo shar: Extracting \"'man/man1/vl.1'\" \(8434 characters\)
sed "s/^X//" >'man/man1/vl.1' <<'END_OF_FILE'
X...
X... Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X...  and U. Pralle
X... 
X... This software is published on an as-is basis. There is ABSOLUTELY NO
X... WARRANTY for any part of this software to work correctly or as described
X... in the manuals. We do not accept any liability for any kind of damage
X... caused by use of this software, such as loss of data, time, money, or 
X... effort.
X... 
X... Permission is granted to use, copy, modify, or distribute any part of
X... this software as long as this is done without asking for charge, and
X... provided that this copyright notice is retained as part of the source
X... files. You may charge a distribution fee for the physical act of
X... transferring a copy, and you may at your option offer warranty
X... protection in exchange for a fee.
X... 
X... Direct questions to: Tech. Univ. Berlin
X... 		     Wilfried Koch
X... 		     Sekr. FR 5-6 
X... 		     Franklinstr. 28/29
X... 		     D-1000 Berlin 10, West Germany
X... 
X... 		     Tel: +49-30-314-22972
X... 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X... 
X...
X... $Header: vl.1[1.3] Thu Feb 23 18:14:41 1989 axel@coma published $
X... 
X... Log for /u/shape/dist-tape/src/vc/vl.1[1.2]
X... 	Thu Feb 23 18:14:41 1989 axel@coma published $
X...  --- empty log message ---
X...  vl.1[1.3] Thu Feb 23 18:14:41 1989 axel@coma published $
X...  --- empty log message ---
X...
X.TH VL 1 vl \n(dy.\n(mo.\n(yr
X.SH NAME
Xvl \- list version information
X.SH SYNOPSIS
X.IP \fBvl\fR
X[\ \fB\-AbghHlLSuU\fR\ ]\ [\ \fB\-V\ \fI<version>\fR\ ]
X[\ \fB\-author\ \fI<userid>\fR\ ]\ [\ \fB\-owner\ \fI<userid>\fR\ ]
X.br
X[\ \fB\-u:\fI <udaspec>\fR\ ]\ [\ \fB\-version\fR\ ]\ [\ files \.\|.\ ]
X.IP \fBvlog\fR
X[\ \fB\-V\ \fI <version>\fR\ ] files \.\|.
X.SH DESCRIPTION
X.PP
X\fBVl\fR prints various informations about an AFS object base.
XWhile its main operation is to list the contents of an object base
Xin a manner similar to ls(1), \fBvl\fR knows about many options 
Xthat extract additional information about individual object histories
Xor the entire object base.
X.PP
XIf \fBvl\fR is invoked without any options or filenames, it simply 
Xprints the contents of the object base, including files (\fIbusy versions\fR)
Xand directories in the current directory. Version objects in
Xthe object base are represented as filenames with a bracketed
X\fIversion identification extension\fR. 
XGenerally, \fBvl\fR tries to give the illusion,
Xas were all the versions in the object base regular files in the current
Xdirectory. While busy versions \- which are regular files \- may be 
Xmanipulated by all commands and tools that operate on files, version
Xobjects can only be manipulated by special tools that operate 
Xon the object base. The tools that operate on the object base, however,
Xcan also access regular files because these are also part of the object base
X(see: Lampen/Mahler, \(lqAn Object Base for Attributed Software Objects\(rq, 
XProceedings of the EUUG Fall '88 Conference, Lisbon).
X.PP
XIf filenames are given as arguments to \fBvl\fR, similarly to ls(1)
Xonly information about these object histories will be printed.
XObject names may also be given in \fIbound version notation\fR,
Xi.e. a notation that identifies a particular version of an object (e.g.
X\fCmkattr.c[2.4]\fR). It is also possible to use a previously assigned
X\fIsymbolic name\fR rather than a numerical 
Xversion identification (e.g. \fCmkattr.c[tools-V4R3]\fR). Make sure
Xto escape the bracket-symbols as these usually have meaning to the
Xshell.
X.PP
XThe program \fBvlog\fR prints the log-entry for specified objects.
XLog-entries usually describe the reason for a particular change
Xto the design object that led to the creation of the specified
Xrevision(s).
X.PP
XThe following options that may be supplied to \fBvl\fR determine the
Xamount of information that will be printed about objects in the 
Xobject base.
X.IP \fB\-l\fR \w'\fB\-owner\ \fI<userid>++\fR'u
XList in long format, giving mode, version state, owner, size in bytes,
Xthe save date, and version identification. 
XFor busy versions
Xthe date field will contain the time of last modification rather than
Xthe save date. The \fIstatus\fR of a version is
Xprinted as: \fBb\fR for \fBbusy\fR, \fBs\fR for \fBsave\fR, \fBp\fR for
X\fBproposed\fR, \fBP\fR for \fBpublished\fR and \fBf\fR for \fBfrozen\fR.
XEach entry of the resulting list is printed on one line.
X.IP \fB\-g\fR
XInclude the group of the version in long output.
X.IP \fB\-a\fR
XList also hidden files (i.e. files with a name beginning with a '\.').
X.IP \fB\-b\fR
XList also objects that are stored in the binary pool.
X.IP \fB\-q\fR
XPrint no information, just set the exit status. This option is useful 
Xto test for the existence of a particular (set of) objects in the 
Xobject base.
X.IP \fB\-h\fR
XPrint brief instructions about how to use this program. 
X.IP \fB\-s\fI\ <state>\fR
XPrint only information about objects that have the specified \fIstate\fR.
XThe state is specified as a single letter (s = save, p = proposed,
XP = published, a = accessed, f = frozen). The letter denoting the state
Xmay be followed by a '+' character, specifying all objects that have
Xthe given or a higher state.
X.IP \fB\-author\fI\ <userid>\fR
XPrint only information about objects that have the specified \fIauthor\fR.
XAuthor may be any valid user id on the current host or in the local
Xnetwork. \fIUserid\fR may be specified either as \fIname\fR or 
X\fIname@host\fR. In case the host part is omitted, the local
Xhost will be assumed.
X.IP \fB\-owner\fI\ <userid>\fR
XPrint only information about objects that have the specified \fIowner\fR.
XOwner may be any valid user id on the current host or in the local
Xnetwork. \fIUserid\fR may be specified either as \fIname\fR or 
X\fIname@host\fR. In case the host part is omitted, the local
Xhost will be assumed.
X.IP \fB\-n\ \fI<sym-name>\fR
XPrint only information about objects having the specified \fIsymbolic name\fR
Xassigned to them. Assignment of symbolic names is often used to mark
Xobject revisions that are part of the same configuration. If \- for
Xexample \- all components of a configuration are marked with the symbolic
Xname \fCtoolpack_V4R3\fR (could be done by \fBshape\fR or 
Xmake(1), using \fBsave\fR or \fBvadm\fR), it will be easy to find these 
Xobjects later by issuing the command:
X.RS
X.DS
X\fCvl -n toolpack_V4R3\fR
X.DE
X.RE
X.IP \fB\-u\fR
XList user defined attributes (\fBuda\fR). Only objects that actually
Xhave user defined attributes will be printed.
X.IP \fB\-U\fR
XLike \fB\-u\fR, but print also the values of user defined attributes.
X.IP \fB\-u:udaspec\fR
XPrint only information about objects that have the specified user
Xdefined attribute(s) with the given values. The command:
X.RS
X.DS
X\fCvl -u:foo=bar,crack=uli\fR
X.DE
Xwould print only those objects, that have the attributes \(lqfoo\(rq and
X\(lqcrack\(rq with the given values.
XIf this option is given as \fB\-ux\fR, also \fIhidden attributes\fR that are
Xused by the version control system and the \fBshape\fR program are
Xprinted.
X.RE
X.IP \fB\-V\ \fI<version>\fR
XPrint only information about the objects determined by \fIversion\fR. 
X\fIVersion\fR can be of the form
X\fIgeneration.revision\fR (e.g. \fC\-V1.19\fR) or \fIgeneration.\fR (e.g.
X\fC\-V2.\fR
Xlists all versions with generation number = 2), or \fI.revision\fR (e.g. 
X\fC\-V.3\fR lists all versions with revision number = 3).
X.IP \fB\-L\fR
XPrint the \fIlogentry\fR for the specified objects. The logentry usually
Xdescibes the nature of a particular change that led to the creation
Xof a new version. See also \fBvlog\fR.
X.IP \fB\-H[\fB+\fR]
XPrint a continuous log-history for the specified objects, beginning
Xat revision 1.0. If a version number is specified by \fB\-V\fR the
Xlog-history is printed from the first revision up to the specified
Xversion. If the option letter \fB\-H\fR is immediately followed by
X\fB+\fR, the log-history is printed from the specified version (-V)
Xup to the last saved version.
X.IP \fB\-version\fR
XPrint the version identification of this program.
X.SH SEE ALSO
Xsave(1), retrv(1), rsrv(1), sbmt(1), shape(1), vadm(1), 
Xaf_intro(3), af_archive(5)
X.SH BUGS
XThe program has difficulties to handle options with optional arguments
Xproperly. Options that have optional arguments should be set at the
Xend of a command line.
X.PP
XThe \fB\-H\fR option does not work.
X.SH AUTHOR
XUli Pralle
X.br
XTechnical University Berlin
X.sp
X\fIUUCP:\fR		uli@coma.uucp (unido!coma!uli)
X.br
X\fIBITNET:\fR	uli@db0tui62
END_OF_FILE
if test 8434 -ne `wc -c <'man/man1/vl.1'`; then
    echo shar: \"'man/man1/vl.1'\" unpacked with wrong size!
fi
# end of 'man/man1/vl.1'
fi
if test -f 'man/man1/vlog.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/man1/vlog.1'\"
else
echo shar: Extracting \"'man/man1/vlog.1'\" \(8434 characters\)
sed "s/^X//" >'man/man1/vlog.1' <<'END_OF_FILE'
X...
X... Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X...  and U. Pralle
X... 
X... This software is published on an as-is basis. There is ABSOLUTELY NO
X... WARRANTY for any part of this software to work correctly or as described
X... in the manuals. We do not accept any liability for any kind of damage
X... caused by use of this software, such as loss of data, time, money, or 
X... effort.
X... 
X... Permission is granted to use, copy, modify, or distribute any part of
X... this software as long as this is done without asking for charge, and
X... provided that this copyright notice is retained as part of the source
X... files. You may charge a distribution fee for the physical act of
X... transferring a copy, and you may at your option offer warranty
X... protection in exchange for a fee.
X... 
X... Direct questions to: Tech. Univ. Berlin
X... 		     Wilfried Koch
X... 		     Sekr. FR 5-6 
X... 		     Franklinstr. 28/29
X... 		     D-1000 Berlin 10, West Germany
X... 
X... 		     Tel: +49-30-314-22972
X... 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X... 
X...
X... $Header: vl.1[1.3] Thu Feb 23 18:14:41 1989 axel@coma published $
X... 
X... Log for /u/shape/dist-tape/src/vc/vl.1[1.2]
X... 	Thu Feb 23 18:14:41 1989 axel@coma published $
X...  --- empty log message ---
X...  vl.1[1.3] Thu Feb 23 18:14:41 1989 axel@coma published $
X...  --- empty log message ---
X...
X.TH VL 1 vl \n(dy.\n(mo.\n(yr
X.SH NAME
Xvl \- list version information
X.SH SYNOPSIS
X.IP \fBvl\fR
X[\ \fB\-AbghHlLSuU\fR\ ]\ [\ \fB\-V\ \fI<version>\fR\ ]
X[\ \fB\-author\ \fI<userid>\fR\ ]\ [\ \fB\-owner\ \fI<userid>\fR\ ]
X.br
X[\ \fB\-u:\fI <udaspec>\fR\ ]\ [\ \fB\-version\fR\ ]\ [\ files \.\|.\ ]
X.IP \fBvlog\fR
X[\ \fB\-V\ \fI <version>\fR\ ] files \.\|.
X.SH DESCRIPTION
X.PP
X\fBVl\fR prints various informations about an AFS object base.
XWhile its main operation is to list the contents of an object base
Xin a manner similar to ls(1), \fBvl\fR knows about many options 
Xthat extract additional information about individual object histories
Xor the entire object base.
X.PP
XIf \fBvl\fR is invoked without any options or filenames, it simply 
Xprints the contents of the object base, including files (\fIbusy versions\fR)
Xand directories in the current directory. Version objects in
Xthe object base are represented as filenames with a bracketed
X\fIversion identification extension\fR. 
XGenerally, \fBvl\fR tries to give the illusion,
Xas were all the versions in the object base regular files in the current
Xdirectory. While busy versions \- which are regular files \- may be 
Xmanipulated by all commands and tools that operate on files, version
Xobjects can only be manipulated by special tools that operate 
Xon the object base. The tools that operate on the object base, however,
Xcan also access regular files because these are also part of the object base
X(see: Lampen/Mahler, \(lqAn Object Base for Attributed Software Objects\(rq, 
XProceedings of the EUUG Fall '88 Conference, Lisbon).
X.PP
XIf filenames are given as arguments to \fBvl\fR, similarly to ls(1)
Xonly information about these object histories will be printed.
XObject names may also be given in \fIbound version notation\fR,
Xi.e. a notation that identifies a particular version of an object (e.g.
X\fCmkattr.c[2.4]\fR). It is also possible to use a previously assigned
X\fIsymbolic name\fR rather than a numerical 
Xversion identification (e.g. \fCmkattr.c[tools-V4R3]\fR). Make sure
Xto escape the bracket-symbols as these usually have meaning to the
Xshell.
X.PP
XThe program \fBvlog\fR prints the log-entry for specified objects.
XLog-entries usually describe the reason for a particular change
Xto the design object that led to the creation of the specified
Xrevision(s).
X.PP
XThe following options that may be supplied to \fBvl\fR determine the
Xamount of information that will be printed about objects in the 
Xobject base.
X.IP \fB\-l\fR \w'\fB\-owner\ \fI<userid>++\fR'u
XList in long format, giving mode, version state, owner, size in bytes,
Xthe save date, and version identification. 
XFor busy versions
Xthe date field will contain the time of last modification rather than
Xthe save date. The \fIstatus\fR of a version is
Xprinted as: \fBb\fR for \fBbusy\fR, \fBs\fR for \fBsave\fR, \fBp\fR for
X\fBproposed\fR, \fBP\fR for \fBpublished\fR and \fBf\fR for \fBfrozen\fR.
XEach entry of the resulting list is printed on one line.
X.IP \fB\-g\fR
XInclude the group of the version in long output.
X.IP \fB\-a\fR
XList also hidden files (i.e. files with a name beginning with a '\.').
X.IP \fB\-b\fR
XList also objects that are stored in the binary pool.
X.IP \fB\-q\fR
XPrint no information, just set the exit status. This option is useful 
Xto test for the existence of a particular (set of) objects in the 
Xobject base.
X.IP \fB\-h\fR
XPrint brief instructions about how to use this program. 
X.IP \fB\-s\fI\ <state>\fR
XPrint only information about objects that have the specified \fIstate\fR.
XThe state is specified as a single letter (s = save, p = proposed,
XP = published, a = accessed, f = frozen). The letter denoting the state
Xmay be followed by a '+' character, specifying all objects that have
Xthe given or a higher state.
X.IP \fB\-author\fI\ <userid>\fR
XPrint only information about objects that have the specified \fIauthor\fR.
XAuthor may be any valid user id on the current host or in the local
Xnetwork. \fIUserid\fR may be specified either as \fIname\fR or 
X\fIname@host\fR. In case the host part is omitted, the local
Xhost will be assumed.
X.IP \fB\-owner\fI\ <userid>\fR
XPrint only information about objects that have the specified \fIowner\fR.
XOwner may be any valid user id on the current host or in the local
Xnetwork. \fIUserid\fR may be specified either as \fIname\fR or 
X\fIname@host\fR. In case the host part is omitted, the local
Xhost will be assumed.
X.IP \fB\-n\ \fI<sym-name>\fR
XPrint only information about objects having the specified \fIsymbolic name\fR
Xassigned to them. Assignment of symbolic names is often used to mark
Xobject revisions that are part of the same configuration. If \- for
Xexample \- all components of a configuration are marked with the symbolic
Xname \fCtoolpack_V4R3\fR (could be done by \fBshape\fR or 
Xmake(1), using \fBsave\fR or \fBvadm\fR), it will be easy to find these 
Xobjects later by issuing the command:
X.RS
X.DS
X\fCvl -n toolpack_V4R3\fR
X.DE
X.RE
X.IP \fB\-u\fR
XList user defined attributes (\fBuda\fR). Only objects that actually
Xhave user defined attributes will be printed.
X.IP \fB\-U\fR
XLike \fB\-u\fR, but print also the values of user defined attributes.
X.IP \fB\-u:udaspec\fR
XPrint only information about objects that have the specified user
Xdefined attribute(s) with the given values. The command:
X.RS
X.DS
X\fCvl -u:foo=bar,crack=uli\fR
X.DE
Xwould print only those objects, that have the attributes \(lqfoo\(rq and
X\(lqcrack\(rq with the given values.
XIf this option is given as \fB\-ux\fR, also \fIhidden attributes\fR that are
Xused by the version control system and the \fBshape\fR program are
Xprinted.
X.RE
X.IP \fB\-V\ \fI<version>\fR
XPrint only information about the objects determined by \fIversion\fR. 
X\fIVersion\fR can be of the form
X\fIgeneration.revision\fR (e.g. \fC\-V1.19\fR) or \fIgeneration.\fR (e.g.
X\fC\-V2.\fR
Xlists all versions with generation number = 2), or \fI.revision\fR (e.g. 
X\fC\-V.3\fR lists all versions with revision number = 3).
X.IP \fB\-L\fR
XPrint the \fIlogentry\fR for the specified objects. The logentry usually
Xdescibes the nature of a particular change that led to the creation
Xof a new version. See also \fBvlog\fR.
X.IP \fB\-H[\fB+\fR]
XPrint a continuous log-history for the specified objects, beginning
Xat revision 1.0. If a version number is specified by \fB\-V\fR the
Xlog-history is printed from the first revision up to the specified
Xversion. If the option letter \fB\-H\fR is immediately followed by
X\fB+\fR, the log-history is printed from the specified version (-V)
Xup to the last saved version.
X.IP \fB\-version\fR
XPrint the version identification of this program.
X.SH SEE ALSO
Xsave(1), retrv(1), rsrv(1), sbmt(1), shape(1), vadm(1), 
Xaf_intro(3), af_archive(5)
X.SH BUGS
XThe program has difficulties to handle options with optional arguments
Xproperly. Options that have optional arguments should be set at the
Xend of a command line.
X.PP
XThe \fB\-H\fR option does not work.
X.SH AUTHOR
XUli Pralle
X.br
XTechnical University Berlin
X.sp
X\fIUUCP:\fR		uli@coma.uucp (unido!coma!uli)
X.br
X\fIBITNET:\fR	uli@db0tui62
END_OF_FILE
if test 8434 -ne `wc -c <'man/man1/vlog.1'`; then
    echo shar: \"'man/man1/vlog.1'\" unpacked with wrong size!
fi
# end of 'man/man1/vlog.1'
fi
if test -f 'src/afs/lcs.cdlt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/afs/lcs.cdlt.c'\"
else
echo shar: Extracting \"'src/afs/lcs.cdlt.c'\" \(8724 characters\)
sed "s/^X//" >'src/afs/lcs.cdlt.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X
X/* ================================================== */
X/* ================================================== */
X/*                                                    */
X/* MODULE-NAME: cdlt        KEY : cd                  */
X/*              = compute delta                       */
X/* ORIGINAL                                           */
X/* AUTHOR : sibylle         DATE: 28/07/87            */
X/*                                                    */
X/* LAST UPDATE                                        */
X/* AUTHOR :                 DATE:                     */
X/*                                                    */
X/* VERSION: 1.9.2                                     */
X/*                                                    */
X/* ================================================== */
X/*                                                    */
X/* PURPOSE:                                           */
X/*                computation of the delta;           */
X/*                generation of a suffix tree         */
X/*                                                    */
X/* SPECIALITIES:                                      */
X/*                binary files can be handled;        */
X/*                usage of register variables;        */
X/*                hash-offset computed with           */
X/*                shift operations                    */
X/*                                                    */
X/* EXCEPTIONS, ERRORS:                                */
X/*                none                                */
X/*                                                    */
X/* ================================================== */
X/*                                                    */
X/*
X * $Header: lcs.cdlt.c[1.0] Wed Feb 22 16:14:17 1989 shape@coma save $
X */
X
X
X# include "predef.h"
X# include <stdio.h>
X# include "suffix.h"  
X
X#define HASH(STRING,OFFSET)\
X        STRING[OFFSET] +\
X        (STRING[OFFSET + 4] << 1) +\
X        (STRING[OFFSET + 7] << 2) +\
X        (STRING[OFFSET + 11] << 3) +\
X        (STRING[OFFSET + 15] << 4) +\
X        (STRING[OFFSET + 17] << 5)
X
Xextern void ge_add();
Xextern void ge_move();
Xextern void ge_init();
Xextern void ge_finit(); 
Xextern char *malloc();
Xextern char *calloc();
Xextern int bcmp();
X
XLOCAL long src_size = (long) 0;
XLOCAL long trg_size = (long) 0;
XLOCAL char *src_str = NIL;
XLOCAL char *trg_str = NIL;
XLOCAL struct suffixes *suff_array = (struct suffixes *) NIL;
X
X
XLOCAL Bool identical (str1, str2, length1, length2)
X     char *str1, *str2;
X     long length1, length2;
X{
X  if (length1 != length2)
X    return (FALSE);
X  else
X    {
X      if ((bcmp (str1, str2, (int) length1)) == 0)
X	return (TRUE);
X      else 
X	return (FALSE);
X    }
X}
X
XLOCAL Bool build_suffix_tree (string,length)
X     register char *string;
X     long length;
X{
X  register struct indices *current;
X  register int i = 0;
X  register int hash;
X
X  suff_array = (struct suffixes *) malloc(TREESIZE * sizeof (struct suffixes));
X  if (suff_array == (struct suffixes *) NIL)
X    return (FALSE);
X
X  bzero((char *)suff_array, TREESIZE * sizeof(struct suffixes));
X
X  hash =abs(HASH( string, 0));
X  if ((suff_array[hash].next  = (struct indices *) malloc( sizeof (struct indices)))== 0)
X    return (FALSE);
X
X;
X  suff_array[hash].last = suff_array[hash].next;
X  suff_array[hash].next->index = 0;
X  suff_array[hash].next->next = (struct indices *) NIL;
X
X  for (i = 1; i < (length - (MINBLENG - 1)); i++) 
X    {
X      hash = abs(HASH(string,i));
X      if (suff_array[hash].last != (struct indices *) NIL )
X	{
X	  if ((current = suff_array[hash].last->next =
X	       (struct indices *) malloc( sizeof (struct indices))) == 0)
X	    return (FALSE);
X	  current->next = (struct indices *) 0;
X	  current->index = 0;
X/*	  suff_array[hash].last->next = (struct indices * ) 0;
X	  suff_array[hash].last->index = 0; */
X	}
X      else
X	{
X	  if ((current = suff_array[hash].next =
X	  (struct indices *) malloc( sizeof (struct indices))) == 0)
X	    return(FALSE);
X	  current->next = (struct indices *) 0;
X	  current->index = 0;
X/*	  suff_array[hash].next->next = (struct indices * ) 0;
X	  suff_array[hash].next->index = 0; */
X	}
X      suff_array[hash].last = current;
X  
X      current->index = i;
X    }
X  return (TRUE);
X}
X
X
XLOCAL void find_max_bm(t_str, s_str, t_offset, s_offset, leng)
X     register char *t_str, *s_str;
X     long t_offset;
X     long *s_offset, *leng;
X{
X  register struct indices *current;
X  register int i,j;
X  register int hash;
X  int off;
X  int max;
X  
X  hash = abs(HASH(t_str, t_offset));
X  if (suff_array[hash].next == (struct indices *) NIL)
X    *leng = 0;
X  else
X    {
X      max = 0;
X      off = 0;
X      current = suff_array[hash].next;
X      while (current != (struct indices *) NIL)
X	{
X	  i = current->index;
X	  j = t_offset;
X	  while ((i < src_size) && (j < trg_size) && 
X		 (t_str[j] == s_str[i])) 
X	    {
X	      j++;
X	      i++;
X	    }
X	  if ((i - current->index > max) &&
X	      (t_str[t_offset] == s_str[current->index]) &&
X	      (t_str[t_offset + 1] == s_str[current->index + 1]))
X	    {
X	      max = i - current->index;
X	      off = current->index;
X	    }
X	  current = current->next;
X	  if (current != (struct indices *) NIL)
X	    {
X	      while (((t_offset + max) < trg_size) &&
X		     ((current->index + max) < src_size) &&
X		     (t_str[t_offset + max] !=
X		      s_str[current->index + max]) &&
X		     (current->next != (struct indices *) NIL))
X		current = current->next;
X	    }
X	}
X      *s_offset = off;
X    if(max >= MINBLENG )
X      *leng = max;
X    else
X      *leng = 0;
X    }
X  return;
X}
X
X
X
XEXPORT Bool cd_init_delta(sourcestr, targetstr, sourcesz, targetsz)
X     char *sourcestr, *targetstr;
X     long sourcesz, targetsz;
X{
X  src_size = sourcesz;
X  trg_size = targetsz;
X  src_str = sourcestr;
X  trg_str = targetstr;
X
X  return(TRUE);
X
X}
X
X
XEXPORT void cd_finit_delta()
X{
X  int i;
X  struct indices *curind;
X  struct indices *delind;
X  for(i = 0; i < TREESIZE; i++)
X    {
X      if(suff_array[i].next != (struct indices *) NIL)
X	{
X	  curind = suff_array[i].next;
X	  while(curind != suff_array[i].last)
X	    {
X	      delind = curind;
X	      curind = curind->next;
X	      free((char *)delind);
X	    }
X	  free((char *)curind);
X	}
X    }
X  free ((char *)suff_array);
X  return;
X}
X
X
XEXPORT Bool cd_comp_delta (deltafile)
X     char *deltafile;
X{
X  register long trg_index = 0;
X  long src_index, matchlength;
X  register long nomtch_trg_index = 0, nomtchlength = 0;
X
X  Bool nomatch = FALSE;
X
X  ge_init (deltafile, trg_str);
X
X  if (identical (src_str, trg_str, src_size, trg_size))
X    {
X      ge_finit();
X      return (TRUE);
X    }
X
X  if ((src_size <= MINBLENG) || (trg_size <= MINBLENG))
X    {
X      ge_add ((long)0, trg_size);
X      ge_finit();
X      return(TRUE);
X    }
X  (void) build_suffix_tree (src_str, src_size);
X  while (trg_index < (trg_size - (MINBLENG - 1)))
X    {
X      find_max_bm (trg_str, src_str, trg_index, &src_index, &matchlength);
X      if (matchlength > 0)
X	{
X	  if (nomatch)
X	    {
X	      ge_add (nomtch_trg_index, nomtchlength); 
X	      nomtch_trg_index = 0;
X	      nomtchlength = 0;
X	      nomatch = FALSE;
X	    }
X	  ge_move (src_index, matchlength);
X	  trg_index = trg_index + matchlength;
X	}
X      else
X	{
X	  if (nomatch)
X	    nomtchlength++;
X	  else
X	    {
X	      nomatch = TRUE;
X	      nomtch_trg_index = trg_index;
X	      nomtchlength = 1;
X	    }
X	  trg_index++;
X	  if (trg_index >= trg_size)
X	    ge_add (nomtch_trg_index, nomtchlength);
X	}
X    }
X  if (trg_index <= (trg_size - 1))
X    {
X      if (nomatch)
X	ge_add (nomtch_trg_index, (nomtchlength + (trg_size - trg_index)));
X      else
X	ge_add (trg_index, (trg_size - trg_index));
X    }
X  ge_finit();
X  cd_finit_delta();
X  return(TRUE);
X}
X
X
X
X		  
X
END_OF_FILE
if test 8724 -ne `wc -c <'src/afs/lcs.cdlt.c'`; then
    echo shar: \"'src/afs/lcs.cdlt.c'\" unpacked with wrong size!
fi
# end of 'src/afs/lcs.cdlt.c'
fi
if test -f 'src/shape/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/shape/Makefile'\"
else
echo shar: Extracting \"'src/shape/Makefile'\" \(9279 characters\)
sed "s/^X//" >'src/shape/Makefile' <<'END_OF_FILE'
X#
X# Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X#  and U. Pralle
X# 
X# This software is published on an as-is basis. There is ABSOLUTELY NO
X# WARRANTY for any part of this software to work correctly or as described
X# in the manuals. We do not accept any liability for any kind of damage
X# caused by use of this software, such as loss of data, time, money, or effort.
X# 
X# Permission is granted to use, copy, modify, or distribute any part of
X# this software as long as this is done without asking for charge, and
X# provided that this copyright notice is retained as part of the source
X# files. You may charge a distribution fee for the physical act of
X# transferring a copy, and you may at your option offer warranty
X# protection in exchange for a fee.
X# 
X# Direct questions to: Tech. Univ. Berlin
X# 		     Wilfried Koch
X# 		     Sekr. FR 5-6 
X# 		     Franklinstr. 28/29
X# 		     D-1000 Berlin 10, West Germany
X# 
X# 		     Tel: +49-30-314-22972
X# 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X# 
XUSERID  = `/usr/ucb/whoami`\@`hostname`   # should e.g deliver 'axel@coma'
XUSERNAME = `/usr/ucb/whoami`
XINTEGRATOR = $(USERNAME)		  # default setting
X
X#
X#  Tool definition & location part
X#  (these macros might be site and/or system-dependent)
X#
X
XSHELL = /bin/sh
XRCSPATH = /usr/local
X
XBUCKS = $$
X
XCC = cc -DCFFLGS='"$(BUCKS)Flags: <$<> $(CFLAGS) $$"'
XCI = $(RCSPATH)/ci
XCO = $(RCSPATH)/co 
XRLOG = $(RCSPATH)/newrlog
XIDENT = $(RCSPATH)/ident
XRCS = $(RCSPATH)/rcs
X
XNGFLAGS = -f -l -q -m"New System Generation" -s"Stable"
XNRFLAGS  = -q -l -m"This version is part of a release" -s"Release"
X
XNRCIDFLAGS = -u -s"Frozen"
X
XCOFLAGS = -q $(VID)
XLOGFLAGS = -h
X
XMAKE-RULES = /usr/local/lib/Make-Rules
XMAKE-CM-RULES = /usr/local/lib/Make-CM-Rules
X
XSRCDIR = /u/wolf/src/shape
XVPATH = RCS
X
XCC = cc -DCFFLGS='"$$Flags: $(CFLAGS) $$"'
X
X#
X#  Configuration definition part
X#
X
X# CFLAGS = -pg -g -DNOBPOOL -I$(AFSINC)
XCFLAGS = -g -I$(AFSINC) -DMSTATS
X# CFLAGS = -g -I$(AFSINC)
X# CFLAGS = -pg -g -DDEBUG_FILES -I$(AFSINC)
X
X#
X#  Installation specific part
X#
X
XINSTALDIR = /u/shape/bin
X
X#
X#  Product definition part
X#
X
XMAKEFILES =  Makefile.distribution Makefile.bsd43 Makefile.sunos40 Makefile.ultrix20
X
X
XCOMPONENTS = \
X	Makefile \
X	README \
X	shape.1 \
X	attr.c \
X	attr.h \
X	error.c \
X	files.c \
X	files.h \
X	hash.c \
X	hash.h \
X	inherit.c \
X	shape.l \
X	macro.c \
X	macro.h \
X	main.c \
X	shape.h \
X	misc.c \
X	produce.c \
X	rule.c \
X	rule.h \
X	select.c \
X	selrule.c \
X	selrule.h \
X	shapeopt.c \
X	sighand.c \
X	std.c \
X	std.h \
X	string.c \
X	varsec.c \
X	varsec.h \
X	vpath.c
X
X# 	version.c
X
X
XPRODUCT = shape
XPROGS = shape
X
XSHAPOBJS = main.o shape.o hash.o macro.o rule.o files.o error.o produce.o std.o selrule.o attr.o varsec.o select.o vpath.o misc.o sighand.o shapeopt.o inherit.o string.o version.o
XHFILES = shape.h macro.h hash.h rule.h selrule.h std.h varsec.h attr.h file.h
X
XVERSION = version
X
X
XAFSLIB = /u/shape/lib/libafs.a
XUTILLIB = /u/shape/lib/libutil.a
X# AFSLIB = /u/shape/lib/libafs.backup
XAFSINC = /u/shape/src/inc
X# AFSINC = /u/andy/shape/afs
XHEADER = shape.h $(AFSINC)/afs.h 
X
XCH = main.c hash.c macro.c rule.c files.c error.c produce.c std.c selrule.c attr.c varsec.c select.c vpath.c misc.c sighand.c inherit.c shapeopt.c string.c \
Xshape.c
X
Xall: shape
X
Xshape: $(SHAPOBJS) $(AFSLIB) $(UTILLIB)  # malloc.o
X	cc -g -o $@ $(SHAPOBJS) $(UTILLIB) $(AFSLIB) -ll
X
Xshapez: $(SHAPOBJS) $(AFSLIB) $(UTILLIB) malloc.o
X	cc -g -o $@ $(SHAPOBJS) malloc.o $(UTILLIB) $(AFSLIB) -ll
X
X
X$(SHAPOBJS):	$(HEADER)
Xmacro.o:	$(HEADER) macro.h
Xhash.o:		$(HEADER) hash.h
Xrule.o: 	$(HEADER) rule.h
Xselrule.o:	$(HEADER) selrule.h
Xstd.o:		$(HEADER) std.h
Xvarsec.o:	$(HEADER) varsec.h
Xattr.o:		$(HEADER) attr.h
Xfiles.o:	$(HEADER) files.h
Xversion.o:	version.c
X
XClean:
X	rm shape *.o core
X
Xsbmt:
X	sbmt -q $(MAKEFILES) $(COMPONENTS) Shapefile version.c -n $(RELNAME)
X
Xlint: $(CH)
X	lint  -I/u/shape/src/inc $(CH)
X
Xshar:
X	shar $(MAKEFILES) $(COMPONENTS) Shapefile version.c > shape.sh 
X
X
Xinstall: all
X	@-for i in $(PROGS); \
X	do \
X	echo installing $$i in $(INSTALDIR); \
X	install -c -o $(USERNAME) -g unib $$i $(INSTALDIR);\
X	done;
X
XMakefile: @Makefile
X#  Make-CM-Rules,v 4.12 88/07/26 22:03:52 axel Release $
X#
X#  These rules are all configuration management related, and serve to
X#  prepare system generations and releases. It should not be necessary
X#  to modify them for different products, as long as certain conventions
X#  are obeyed: Define the main-product name in the PRODUCT macro. List 
X#  all components' names (i.e. each revisable entity) in COMPONENTS.
X#  Names of individually produced subtargets should be listed in PROGS.
X#  The main target should be 'all'.
X#
X#  This Makefile sample is intended for 'single Makefile systems'.
X#  To apply the proposed SCM scheme to more complex systems, some 
X#  more rules and conventions have to be defined. 
X#
X
XSUBPRODUCTCIDS = `/bin/echo $(SUBPRODUCTS) | awk '{ ORS=" "; \
X	for (i=1;i<=NF;i++) print $$1 ".cid"; }'`
X
XDATDIR = /u/mach/pdat
X# holds administrative data for all projects
X
XRELNO = $(DATDIR)/rels/$(PRODUCT).rel
XGENNO = $(DATDIR)/gens/$(PRODUCT).gen
XCID = $(PRODUCT).cid
XRELEASING = $(DATDIR)/tmp/.$(PRODUCT)_rel_in_prog
XRSYMNAME = $(PRODUCT)_v`cat $(GENNO)`r`cat $(RELNO)`
X
XSAVESET = `echo * | intersect $(COMPONENTS) $(PROGS)`
XINSTVID = -r$(PRODUCT)_v`$(RLOG) -y $(PRODUCT).cid | tr '.' 'r'`
X@install:
X	@-if [ $(USERNAME) = $(INTEGRATOR) ]; \
X	then \
X	if touch foo 2> /dev/null; \
X	then rm foo; \
X	trap "" 1 2 3; \
X	mkdir .tmpdir; \
X	ln $(SAVESET) *.o Makefile .tmpdir; \
X	rm -f $(SAVESET) *.o Makefile; \
X	$(CO) $(INSTVID) Makefile; \
X	make $(MFLAGS) \
X	"SRCDIR=$(SRCDIR)" \
X	"VID=-r$(PRODUCT)_v`$(RLOG) -y $(PRODUCT).cid | tr '.' 'r'`" \
X	all; \
X	for i in $(PROGS); \
X	do \
X	echo installing $$i in $(INSTALDIR); \
X	install -o $(USERNAME) -g unib $$i $(INSTALDIR);\
X	done; \
X	$(CO) -p $(CID) > $(DATDIR)/cids/$(CID); \
X	chmod 664 $(DATDIR)/cids/$(CID); \
X	rm -f $(SAVESET) *.o Makefile; \
X	ln .tmpdir/* $(SRCDIR); \
X	rm -rf .tmpdir; \
X	else \
X	echo '>>>' You need write permission on `pwd` to install $(PRODUCT) \
X	'<<<'; \
X	fi; \
X	else \
X	echo '>>>' Install $(PRODUCT) as user $(INTEGRATOR) '<<<'; \
X	fi
X
XSAVEDATE = .$(PRODUCT).lastsaved
X
X@save: 
X	cd $(SRCDIR); \
X	make "SCOMPONENTS=`rcslocks $(COMPONENTS)`" "SFLAGS=-l" \
X	$(SAVEDATE)
X
X$(SAVEDATE): $(SCOMPONENTS)
X	@echo Saving $?; \
X	$(CI) $(SFLAGS) $?; \
X	/bin/date > $(SAVEDATE)
X
X# release rule for systems with 'own' components
Xrelease: @increl @preprel @logconf1 all @logconf2
X
X# release rule for systems without own components, just SUBPRODUCTS
X@release1: @increl @logconf1 all @logconf2
X
Xgeneration: @incgen @markcom
X
X@generation1: @incgen
X
X@logrelease: @logconf1 @logconf2
X
X@incgen: # assumes that all COMPONENTS have a busy version 
X	@incr $(GENNO)
X	@/bin/echo Declaring generation `cat $(GENNO)` for \
X	$(PRODUCT) system
X	@rm -f $(RELNO)
X
X@markcom:
X	@-(cd $(SRCDIR) ; \
X	$(CI) $(NGFLAGS) -r`cat $(GENNO)`.0 $(COMPONENTS))
X
X@increl:
X	@touch $(RELEASING); \
X	incr $(RELNO)
X
X@preprel:
X	@/bin/echo Preparing release `cat $(RELNO)` in generation \
X	`cat $(GENNO)` of $(PRODUCT)
X	@-(cd $(SRCDIR); $(CI) $(NRFLAGS) Makefile \
X	`rcslocks $(COMPONENTS)` > /dev/null 2> .diag ; \
X	for i in $(COMPONENTS) Makefile; \
X	do \
X	v=`$(RLOG) -y $$i`; \
X	echo marking $$i\[$$v\] ; \
X	$(RCS) -n"$(PRODUCT)_v`cat $(GENNO)`r`cat $(RELNO)`":$$v \
X	$$i >  /dev/null 2> /dev/null ; \
X	done ; \
X	rm -f .diag ; \
X	/bin/date > $(SAVEDATE))
X
X@logconf1:
X	@/bin/echo Conf-ID: $(PRODUCT) version `cat $(GENNO)` \
X	release `cat $(RELNO)` of `/bin/date`, > $(CID) ; \
X	/bin/echo by $(USERID) >> $(CID); \
X	/bin/echo -n '$$Header' >> $(CID); \
X	/bin/echo '$$' >> $(CID); \
X	/bin/echo 'char *$(VERSION) () { static char ConfID[] = \
X	"'`cat $(GENNO)`.`cat $(RELNO)` '('`date` by $(USERID)')"; \
X	return ConfID; }' > $(SRCDIR)/$(VERSION).c; 
X	@(cd $(SRCDIR); \
X	$(CI) $(NRFLAGS) -n"$(PRODUCT)_v`cat $(GENNO)`r`cat $(RELNO)`" \
X	$(VERSION).c > /dev/null 2> /dev/null; )
X
X# The ci - command doesn't like a '.' charakter in a symname
X
XDDOLLAR = $$
X
X@logconf2:
X	@/bin/echo Logging configuration in $(CID);\
X	$(IDENT) Makefile | awk '{ if ($$1 == "$$Header:") \
X	printf ("     Header: %s %s %s %s %s %s\n",$$2,$$3,$$4,$$5,$$6,$$7); \
X	else if (($$1 != "$(DDOLLAR)Flags:") && ($$1 != "$$Log:")) \
X	print $$0 }' >> $(CID);\
X	$(IDENT) $(PROGS) | awk '{ \
X	if ($$1 == "$$Header:") \
X	printf ("     Header: %s %s %s %s %s %s\n",$$2,$$3,$$4,$$5,$$6,$$7); \
X	else if ($$1 == "$$Flags:") { ORS = " "; print "     Flags: "; \
X	for (i=2; i<=NF-1; i++) print $$i; print "\n"; } \
X	else print $$0 }' >> $(CID);
X	@echo Identification of incorporated subproducts: >> $(CID); \
X	(cd $(SRCDIR); $(IDENT) $(SUBPRODUCTCIDS) | awk '{ \
X	if ($$1 == "$$Header:") \
X	printf ("     Header: %s %s %s %s %s %s\n",$$2,$$3,$$4,$$5,$$6,$$7); \
X	else if ($$1 == "$$Flags:") { ORS = " "; print "     Flags: "; \
X	for (i=2; i<=NF-1; i++) print $$i; print "\n"; } \
X	else print $$0 }') >> $(CID);
X	@(cd $(SRCDIR); $(RLOG) $(LOGFLAGS) Makefile $(COMPONENTS)) >> \
X	$(CID); \
X	echo; \
X	echo '***' DESCRIBE PURPOSE OR DESTINATION OF THIS RELEASE \
X	'['`cat $(GENNO)`.`cat $(RELNO)`']' '***'; \
X	echo '(terminate with ^D or single '"'.'"')'; \
X	$(CI) $(NRCIDFLAGS) -r`cat $(GENNO)`.`cat $(RELNO)` \
X	$(CID) > /dev/null 2> /dev/null; \
X	rm $(RELEASING)
X
END_OF_FILE
if test 9279 -ne `wc -c <'src/shape/Makefile'`; then
    echo shar: \"'src/shape/Makefile'\" unpacked with wrong size!
fi
# end of 'src/shape/Makefile'
fi
if test -f 'src/shape/std.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/shape/std.c'\"
else
echo shar: Extracting \"'src/shape/std.c'\" \(8603 characters\)
sed "s/^X//" >'src/shape/std.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *RCSid = "$Header: std.c,v 3.0 89/01/24 11:37:03 wolfgang Stable $";
X#endif
X#ifndef lint
Xstatic char *ConfFlg = CFFLGS;	/* should be defined from within Makefile */
X#endif
X/*
X * $Log:	std.c,v $
X * Revision 3.0  89/01/24  11:37:03  wolfgang
X * New System Generation
X * 
X * Revision 2.10  88/12/21  15:13:06  wolfgang
X * changes done for lint
X * 
X * Revision 2.9  88/11/22  18:56:06  wolfgang
X * bug fixed: missing initialization.
X * 
X * Revision 2.7  88/11/21  15:48:45  wolfgang
X * return code of all malloc's checked
X * 
X * Revision 2.6  88/10/10  17:03:38  wolfgang
X * This version is part of a release
X * 
X * Revision 2.5  88/09/19  14:41:23  wolfgang
X * little bug fixed
X * 
X * Revision 2.4  88/09/19  11:47:34  wolfgang
X * added +(CC) & +(CFLAGS) in .l.o rule.
X * 
X * Revision 2.3  88/09/14  10:52:28  wolfgang
X * undone last changes
X * 
X * Revision 2.2  88/09/13  09:55:29  wolfgang
X * It's now possible to overload implicit standard rules.
X * 
X * Revision 2.1  88/08/19  10:18:11  wolfgang
X * This version is part of a release
X * 
X */
X
X/* reearrangement of suffixes ??? */
X/* implicit predefined rules with more than one target ??? */
X
X#include "std.h"
X#include "shape.h"
Xstruct rules *stdruletab[STDRULETABSIZE];
Xint lastrule;
X
X/* char *stdsuff = ".o .c .c~ .mod .mod~ .sym .def .def~ .p .p~ .f .f~ .F .F~ .r .r~ .y .y~ .l .l~ .s .s~ .sh .sh~ .h .h~ "; */
X
X/* .x~ suffixes are not supportet */
X
Xchar *stdsuff = ".o .c .mod .sym .def .a .p .f .F .r .y .l .s .sh .h";
X
Xchar *shaperules = "%.o:%.c %.o:%.l %.o:%.y %.o:%.s %.o:%.r %.o:%.F %.o:%.f %.o:%.mod %.o:%.p %.c:%.l %.c:%.y %.sym:%.def %.a:%.c %:%.sh %:%.r %:%.F %:%.f %:%.p %:%.mod %:%.c ";
X
Xint implicit_suffs[MAXIMPLICIT] = {12, /*  0   .c.o     */ 
X				    3, /*  1   .l.o     */ 
X				    4, /*  2   .y.o     */ 
X				    5, /*  3   .s.o     */ 
X				    6, /*  4   .r.o     */ 
X				    7, /*  5   .F.o     */ 
X				    8, /*  6   .f.o     */ 
X				   10, /*  7   .mod.o   */ 
X				   11, /*  8   .p.o     */ 
X				    1, /*  9   .l.c     */ 
X				    2, /* 10   .y.c     */ 
X				    9, /* 11   .def.sym */ 
X				    0, /* 12   .c.a     */ 
X				   13, /* 13   .sh      */ 
X				   14, /* 14   .r       */ 
X				   15, /* 15   .F       */ 
X				   16, /* 16   .f       */ 
X				   17, /* 17   .p       */ 
X				   18, /* 18   .mod     */ 
X				   19, /* 19   .c       */ 
X				   -1 };
X
X
Xchar *stdrules[] = {
X
X/* ".c.a",
X"\t$(CC) -c $(CFLAGS) $(vflags) $<",
X"\tar rv $@ $*.o",
X"\trm -f $*.o", */
X
X  "%.a",  /* 0 */
X  "%.c",
X  "+(CC)",
X  "+(CFLAGS)",
X  "+(vflags)",
X  "\t$(CC) -c $(CFLAGS) $(vflags) %.c",
X  "\tar rv %.a %.o",
X  "\trm -f %.o",
X
X/* ".l.c",
X"\t$(LEX) $(LFLAGS) $<",
X"\tmv lex.yy.c $@", */
X
X  "%.c",  /* 1 */
X  "%.l",
X  "+(LEX)",
X  "+(LFLAGS)",
X  "\t$(LEX) $(LFLAGS) %.l",
X  "\tmv lex.yy.c %.c",
X
X/* ".y.c",
X"\t$(YACC) $(YFLAGS) $<",
X"\tmv y.tab.c $@", */
X
X  "%.c",  /* 2 */
X  "%.y",
X  "+(YACC)",
X  "+(YFLAGS)",
X  "\t$(YACC) $(YFLAGS) %.y",
X  "\tmv y.tab.c %.c",
X
X/* ".l.o",
X"\t$(LEX) $(LFLAGS) $<",
X"\t$(CC) $(CFLAGS) $(vflags) -c lex.yy.c",
X"\trm lex.yy.c",
X"\tmv lex.yy.o $@", */
X
X  "%.o",  /* 3 */
X  "%.l",
X  "+(LEX)",
X  "+(LFLAGS)",
X  "+(CC)",
X  "+(CFLAGS)",
X  "+(vflags)",
X  "\t$(LEX) $(LFLAGS) %.l",
X  "\t$(CC) $(CFLAGS) $(vflags) -c lex.yy.c",
X  "\trm lex.yy.c",
X  "\tmv lex.yy.o %.o",
X
X/* ".y.o",
X"\t$(YACC) $(YFLAGS) $<",
X"\t$(CC) $(CFLAGS) $(vflags) -c y.tab.c",
X"\trm y.tab.c",
X"\tmv y.tab.o $@", */
X
X  "%.o",  /* 4 */
X  "%.y",
X  "+(YACC)",
X  "+(YFLAGS)",
X  "+(CC)",
X  "+(CFLAGS)",
X  "+(vflags)",
X  "\t$(YACC) $(YFLAGS) %.y",
X  "\t$(CC) $(CFLAGS) $(vflags) -c y.tab.c",
X  "\trm y.tab.c",
X  "\tmv y.tab.o %.o",
X
X/* ".s.o",
X"\t$(AS) $(ASFLAGS) -o $@ $<", */
X
X  "%.o",  /* 5 */
X  "%.s",
X  "+(AS)",
X  "+(ASFLAGS)",
X  "\t$(AS) $(ASFLAGS) -o %.o %.s",
X
X/* ".r.o",
X"\t$(FC) $(RFLAGS) $(FFLAGS) -c $<", */
X
X  "%.o",  /* 6 */
X  "%.r",
X  "+(FC)",
X  "+(RFLAGS)",
X  "+(FFLAGS)",
X  "\t$(FC) $(RFLAGS) $(FFLAGS) -c %.r",
X
X/* ".F.o",
X"\t$(FC) $(FFLAGS) -c $<", */
X
X  "%.o",  /* 7 */
X  "%.F",
X  "+(FC)",
X  "+(FFLAGS)",
X  "\t$(FC) $(FFLAGS) -c %.F",
X
X/* ".f.o",
X"\t$(FC) $(FFLAGS) -c $<", */
X
X  "%.o",  /* 8 * */
X  "%.f",
X  "+(FC)",
X  "+(FFLAGS)",
X  "\t$(FC) $(FFLAGS) -c %.f",
X
X/* ".def.sym",
X"\t$(M2C) $(M2FLAGS) $<", */
X
X  "%.sym",  /* 9 */
X  "%.def",
X  "+(M2C)",
X  "+(M2FLAGS)",
X  "\t$(M2C) $(M2FLAGS) %.def",
X
X/* ".mod.o",
X"\t$(M2C) $(M2FLAGS) $<", */
X
X  "%.o",  /* 10 */
X  "%.mod",
X  "+(M2C)",
X  "+(M2FLAGS)",
X  "\t$(M2C) $(M2FLAGS) %.o",
X
X/* ".p.o",
X"\t$(PC) $(PFLAGS) -c $<", */
X
X  "%.o",  /* 11 */
X  "%.p",
X  "+(PC)",
X  "+(PFLAGS)",
X  "\t$(PC) $(PFLAGS) -c %.o",
X
X/* ".c.o",
X"\t$(CC) $(CFLAGS) $(vflags) -c $<", */
X
X  "%.o",  /* 12 */
X  "%.c",
X  "+(CC)",
X  "+(CFLAGS)",
X  "+(vflags)",
X  "\t$(CC) $(CFLAGS) $(vflags) -c %.c",
X
X/* ".sh",
X"\tcat $< >$@; chmod +x $@", */
X
X  "%",  /* 13 */
X  "%.sh",
X  "\tcat %.sh >%; chmod +x %",
X
X/* ".r",
X"\t$(FC) $(RFLAGS) $(FFLAGS) $(LDFLAGS) $< -o $@", */
X
X  "%",  /* 14 */
X  "%.r",
X  "+(FC)",
X  "+(RFLAGS)",
X  "+(FFLAGS)",
X  "+(LDFLAGS)",
X  "\t$(FC) $(RFLAGS) $(FFLAGS) $(LDFLAGS) %.r -o %",
X
X/* ".F",
X"\t$(FC) $(FFLAGS) $(LDFLAGS) $< -o $@", */
X
X  "%",  /* 15 */
X  "%.F",
X  "+(FC)",
X  "+(FFLAGS)",
X  "+(LDFLAGS)",
X  "\t$(FC) $(FFLAGS) $(LDFLAGS) %.F -o %",
X
X/* ".f",
X"\t$(FC) $(FFLAGS) $(LDFLAGS) $< -o $@", */
X
X  "%",  /* 16 */
X  "%.f",
X  "+(FC)",
X  "+(FFLAGS)",
X  "+(LDFLAGS)",
X  "\t$(FC) $(FFLAGS) $(LDFLAGS) %.f -o %",
X
X/* ".p",
X"\t$(PC) $(PFLAGS) $(LDFLAGS) $< -o $@", */
X
X  "%",  /* 17 */
X  "%.p",
X  "+(PC)",
X  "+(PFLAGS)",
X  "+(LDFLAGS)",
X  "\t$(PC) $(PFLAGS) $(LDFLAGS) %.p -o %",
X
X/* ".mod",
X"\t$(M2C) $(M2FLAGS) $(LDFLAGS) $< -e $@ -o $@", */
X
X  "%",  /* 18 */
X  "%.mod",
X  "+(M2C)",
X  "+(M2FLAGS)",
X  "+(LDFLAGS)",
X  "\t$(M2C) $(M2FLAGS) $(LDFLAGS) %.mod -e % -o %",
X
X/* ".c",
X"\t$(CC) $(CFLAGS) $(LDFLAGS) $< -o $@", */
X
X  "%",  /* 19 */
X  "%.c",
X  "+(CC)",
X  "+(CFLAGS)",
X  "+(LDFLAGS)",
X  "+(vflags)",
X  "\t$(CC) $(CFLAGS) $(vflags) $(LDFLAGS) %.c -o %",
X
X/* ".SUFFIXES:",
X".o",".c",".c~",".mod",".mod~",".sym",".def",".def~",".p",".p~",".f",".f~",".F",".F~",".r",".r~",".y",".y~",".l",".l~",".s",".s~",".sh",".sh~",".h",".h~",
X*/
X
X"0"
X
X};
X
X
Xadd_stdrules()
X{
X  int i = 0;
X  int j = 0;
X  int k = 0;
X  
X  struct cmds *comm;
X
X  while(strcmp(stdrules[i],"0") != 0)
X      {
X	if(stdrules[i][0] == '%')
X	  {
X	    if((stdruletab[k] = (struct rules *) malloc( sizeof(struct rules))) == (struct rules *) NIL)
X	      errexit(10,"malloc");
X	    stdruletab[k]->name = stdrules[i];
X	    i++;
X	  }
X	if(stdrules[i][0] != '\t')
X	  {
X	    j = 0;
X	    while ((stdrules[i][0] != '\t') &&
X		   (stdrules[i][0] != '+') &&
X		   (strcmp(stdrules[i],"0") != 0))
X	      {
X		stdruletab[k]->deplist[j] = stdrules[i];
X		i++;
X		j++;
X	      }
X	    stdruletab[k]->deplist[j] = NIL;
X	  }
X	if (stdrules[i][0] == '+')
X	  {
X	    j = 0;
X	    while (stdrules[i][0] == '+')
X	      {
X		stdruletab[k]->heritage[j] = stdrules[i];
X		i++;
X		j++;
X	      }
X	    stdruletab[k]->heritage[j] = NIL;
X	  }
X	else
X	  stdruletab[k]->heritage[0] = NIL;
X
X	if (stdrules[i][0] == '\t')
X	  {
X	    if ((stdruletab[k]->cmdlist = (struct cmds *) malloc( sizeof (struct cmds))) == (struct cmds *) NIL)
X	      errexit(10,"malloc");
X	    comm = stdruletab[k]->cmdlist;
X	    while (stdrules[i][0] == '\t')
X	      {
X		comm->command = stdrules[i];
X		if ((comm = comm->nextcmd = (struct cmds *) malloc( sizeof (struct cmds *))) == (struct cmds *) NIL)
X		  errexit(10,"malloc");
X		i++;
X	      }
X	    stdruletab[k]->targetlist[0] = stdruletab[k]->name;
X	    stdruletab[k]->targetlist[1] = NIL;
X	  }
X	k++;
X      }
X  stdruletab[k] = (struct rules *) NIL;
X  lastrule = k - 1;
X}
X
END_OF_FILE
if test 8603 -ne `wc -c <'src/shape/std.c'`; then
    echo shar: \"'src/shape/std.c'\" unpacked with wrong size!
fi
# end of 'src/shape/std.c'
fi
if test -f 'src/vc/vadm_promote.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/vc/vadm_promote.c'\"
else
echo shar: Extracting \"'src/vc/vadm_promote.c'\" \(9143 characters\)
sed "s/^X//" >'src/vc/vadm_promote.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *AFSid = "$Header: vadm_promote.c[3.7] Thu Feb 23 18:14:15 1989 axel@coma published $";
X#ifdef CFFLGS
Xstatic char *ConfFlg = CFFLGS;
X	/* should be defined from within Makefile */
X#endif
X#endif
X/*
X * Log for /u/shape/dist-tape/src/vc/vadm_promote.c[3.3]
X * 	Thu Feb 23 18:14:15 1989 axel@coma published $
X *  --- empty log message ---
X *  vadm_promote.c[3.5] Thu Feb 23 18:14:15 1989 axel@coma published $
X *  --- empty log message ---
X *  vadm_promote.c[3.6] Thu Feb 23 18:14:15 1989 axel@coma save $
X *  --- empty log message ---
X *  vadm_promote.c[3.7] Thu Feb 23 18:14:15 1989 axel@coma published $
X *  --- empty log message ---
X */
X
X#include <stdio.h>
X#include <afs.h>
X
X#include "afsapp.h"
X#include "vadm.h"
X#include "locks.h"
X
X/* external */
Xextern char *malloc(), *st_table[];
Xextern unsigned int options;
Xextern int def_vnum;
Xextern struct Transaction ThisTransaction;
X
X/* locals */
Xchar buf[2048];
X
X/**/
Xstatic
Xint do_promote (set)
X     Af_set *set;
X{
X  int i, oldstate;
X  int errs = 0;
X  char version[1024];
X
X  if (af_sortset (set, AF_ATTHUMAN) == -1)
X    vctl_abort ("do_promote: af_sortset()");
X      
X  for (i = 0; i < set->af_nkeys; i++) {
X    if (setjmp (ThisTransaction.tr_env)) continue;
X    mkvstring (version, &set->af_klist[i]);
X    if ((oldstate = af_rstate (&set->af_klist[i])) == -1) {
X      af_perror ("do_promote()");
X      return 1;
X    }
X
X    switch (oldstate) {
X    case AF_BUSY:
X      (void)sprintf (buf, "%s busy. Fatal", version);
X      logmsg (buf);
X      vctl_abort ("CONTACT LOCAL GURU"); /* no return */
X      break;
X    case AF_SAVED:
X      if ((lockeruid(vc_lock_v(&set->af_klist[i], (Uid_t)getuid()))) != 
X	  (Uid_t)getuid()) {
X	logerr ("can't change state -- locked");
X	return 1;
X      }
X      if (af_sstate (&set->af_klist[i], AF_PROPOSED) == -1) {
X	af_perror ("af_sstate():");
X	return 1;
X      }
X      (void)vc_unlock_v(&set->af_klist[i]);
X      (void)sprintf (buf, "%s promoted to state \"%s\".", version,
X	       st_table[AF_PROPOSED]);
X      logmsg (buf);
X      break;
X    case AF_PROPOSED:
X      if ((lockeruid(vc_lock_v(&set->af_klist[i],(Uid_t)getuid()))) != 
X	  (Uid_t)getuid()) {
X	logerr ("can't change state -- locked");
X	return 1;
X      }
X      if (af_sstate (&set->af_klist[i], AF_PUBLISHED) == -1) {
X	af_perror ("af_sstate():");
X	return 1;
X      }
X      (void)vc_unlock_v(&set->af_klist[i]);
X      (void)sprintf (buf, "%s promoted to state \"%s\".", version,
X	       st_table[AF_PUBLISHED]);
X      logmsg (buf);
X      break;
X    case AF_PUBLISHED:
X      if ((lockeruid(vc_lock_v(&set->af_klist[i], (Uid_t)getuid()))) != 
X	  (Uid_t)getuid()) {
X	logerr ("can't change state -- locked");
X	return 1;
X      }
X      if (af_sstate (&set->af_klist[i], AF_ACCESSED) == -1) {
X	af_perror ("af_sstate():");
X	return 1;
X      }
X      (void)vc_unlock_v(&set->af_klist[i]);
X      (void)sprintf (buf, "%s promoted to state \"%s\".", version,
X	       st_table[AF_ACCESSED]);
X      logmsg (buf);
X      break;
X    case AF_ACCESSED:
X      if ((lockeruid(vc_lock_v(&set->af_klist[i], (Uid_t)getuid()))) != 
X	  (Uid_t)getuid()) {
X	logerr ("can't change state -- locked");
X	return 1;
X      }
X      if (af_sstate (&set->af_klist[i], AF_FROZEN) == -1) {
X	af_perror ("af_sstate():");
X	return 1;
X      }
X      (void)vc_unlock_v(&set->af_klist[i]);
X      (void)sprintf (buf, "%s promoted to state \"%s\".", version,
X	       st_table[AF_FROZEN]);
X      logmsg (buf);
X      break;
X    case AF_FROZEN:
X      (void)sprintf (buf, "%s already frozen. --- Not promoted.", version);
X      logmsg (buf);
X      errs++;
X      break;
X    default:
X      (void)sprintf (buf, "%s has unknown version state %d.", version, oldstate);
X      logmsg (buf);
X      vctl_abort ("CONTACT LOCAL GURU.");
X    }
X  }
X  if (errs)
X    return 1;
X  else
X    return 0;
X}
X
X/**/
Xint DoPromote (vlist, ac, av)
X     struct vc_vlist *vlist;
X     int ac;
X     char **av;
X{
X  Af_set set;
X  int errs;
X  char **erroneous;
X
X  if (IsOptionSet(Vopt_version)) {
X    errs = GetKeysByGenRev
X	(ac,av, gen(def_vnum), rev(def_vnum), &set, &erroneous);
X  }
X  else {
X    if (!(vlist->from_version_set) || !(vlist->to_version_set))
X      errs = GetKeysByGenRev 
X	(ac,av, AF_LASTVERS, AF_LASTVERS, &set, &erroneous);
X    else
X      errs = GetKeysByName ( ac, av, vlist, &set, &erroneous);
X  }
X  if (errs)
X    print_erroneous (erroneous, errs);
X
X  if (!set.af_nkeys) {
X    logmsg ("Nothing appropriate found.");
X    return 1;
X  }
X
X  if (errs && !ask_confirm ("Continue ?", "yes"))
X    return 1;
X
X  return do_promote (&set);
X}
X
X/**/
Xstatic
Xint do_unpromote (set)
X     Af_set *set;
X{
X  int i, oldstate;
X  int errs = 0;
X  char version[1024];
X
X  if (af_sortset (set, AF_ATTHUMAN) == -1)
X    vctl_abort ("do_unpromote: af_sortset()");
X      
X  for (i = 0; i < set->af_nkeys; i++) {
X    mkvstring (version, &set->af_klist[i]);
X    if (setjmp (ThisTransaction.tr_env)) continue;
X    if ((oldstate = af_rstate (&set->af_klist[i])) == -1) {
X      af_perror ("do_promote()");
X      return 1;
X    }
X
X    switch (oldstate) {
X    case AF_BUSY:
X      (void)sprintf (buf, "%s busy. Fatal", version);
X      logmsg (buf);
X      vctl_abort ("CONTACT LOCAL GURU"); /* no return */
X      break;
X    case AF_SAVED:
X      (void)sprintf (buf, "%s already saved.", version);
X      logmsg (buf);
X      break;
X    case AF_PROPOSED:
X      if ((lockeruid(vc_lock_v(&set->af_klist[i], (Uid_t)getuid()))) != 
X	  (Uid_t)getuid()) {
X	logerr ("can't change state -- locked");
X	return 1;
X      }
X      if (af_sstate (&set->af_klist[i], AF_SAVED) == -1) {
X	af_perror ("af_sstate():");
X	return 1;
X      }
X      (void)vc_unlock_v(&set->af_klist[i]);
X      (void)sprintf (buf, "%s unpromoted to state \"%s\".", version, 
X	       st_table[AF_SAVED]);
X      logmsg (buf);
X      break;
X    case AF_PUBLISHED:
X      if ((lockeruid(vc_lock_v(&set->af_klist[i], (Uid_t)getuid()))) != 
X	  (Uid_t)getuid()) {
X	logerr ("can't change state -- locked");
X	return 1;
X      }
X      if (af_sstate (&set->af_klist[i], AF_PROPOSED) == -1) {
X	af_perror ("af_sstate():");
X	return 1;
X      }
X      (void)vc_unlock_v(&set->af_klist[i]);
X      (void)sprintf (buf, "%s unpromoted to state \"%s\".", version,
X	       st_table[AF_PROPOSED]);
X      logmsg (buf);
X      break;
X    case AF_ACCESSED:
X      if ((lockeruid(vc_lock_v(&set->af_klist[i], (Uid_t)getuid()))) != 
X	  (Uid_t)getuid()) {
X	logerr ("can't change state -- locked");
X	return 1;
X      }
X      if (af_sstate (&set->af_klist[i], AF_PUBLISHED) == -1) {
X	af_perror ("af_sstate():");
X	return 1;
X      }
X      (void)vc_unlock_v(&set->af_klist[i]);
X      (void)sprintf (buf, "%s unpromoted to state \"%s\".", version,
X	       st_table[AF_PUBLISHED]);
X      logmsg (buf);
X      break;
X    case AF_FROZEN:
X      if ((lockeruid(vc_lock_v(&set->af_klist[i], (Uid_t)getuid()))) != 
X	  (Uid_t)getuid()) {
X	logerr ("can't change state -- locked");
X	return 1;
X      }
X      if (af_sstate (&set->af_klist[i], AF_ACCESSED) == -1) {
X	af_perror ("af_sstate():");
X	return 1;
X      }
X      (void)vc_unlock_v(&set->af_klist[i]);
X      (void)sprintf (buf, "%s unpromoted to state \"%s\".", version,
X	       st_table[AF_ACCESSED]);
X      logmsg (buf);
X      break;
X    default:
X      (void)sprintf (buf, "%s has unknown version state %d.", version, oldstate);
X      logmsg (buf);
X      vctl_abort ("CONTACT LOCAL GURU.");
X    }
X  }
X  if (errs)
X    return 1;
X  else
X    return 0;
X}
X
X/**/
Xint DoUnpromote (vlist, ac, av)
X     struct vc_vlist *vlist;
X     int ac;
X     char **av;
X{
X  Af_set set;
X  int errs;
X  char **erroneous;
X
X  if (IsOptionSet(Vopt_version)) {
X    errs = GetKeysByGenRev
X	(ac,av, gen(def_vnum), rev(def_vnum), &set, &erroneous);
X  }
X  else {
X    if (!(vlist->from_version_set) || !(vlist->to_version_set))
X      errs = GetKeysByGenRev 
X	(ac,av, AF_LASTVERS, AF_LASTVERS, &set, &erroneous);
X    else
X      errs = GetKeysByName (ac, av, vlist, &set, &erroneous);
X  }
X  if (errs)
X    print_erroneous (erroneous, errs);
X
X  if (!set.af_nkeys) {
X    logmsg ("Nothing appropriate found.");
X    return 1;
X  }
X
X  if (errs && !ask_confirm ("Continue ?", "yes"))
X    return 1;
X
X  return do_unpromote (&set);
X}
END_OF_FILE
if test 9143 -ne `wc -c <'src/vc/vadm_promote.c'`; then
    echo shar: \"'src/vc/vadm_promote.c'\" unpacked with wrong size!
fi
# end of 'src/vc/vadm_promote.c'
fi
echo shar: End of archive 10 \(of 33\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
