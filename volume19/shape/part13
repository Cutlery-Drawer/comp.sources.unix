Subject:  v19i026:  A software configuration management system, Part13/33
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Axel Mahler <unido!coma!axel>
Posting-number: Volume 19, Issue 26
Archive-name: shape/part13



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 13 (of 33)."
# Contents:  src/afs/afcattrs.c src/afs/affiles.c src/shape/selrule.c
#   src/shape/shapeopt.c
# Wrapped by rsalz@papaya.bbn.com on Thu Jun  1 19:27:03 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src/afs/afcattrs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/afs/afcattrs.c'\"
else
echo shar: Extracting \"'src/afs/afcattrs.c'\" \(10117 characters\)
sed "s/^X//" >'src/afs/afcattrs.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X/*LINTLIBRARY*/
X/*
X *	Shape/AFS
X *
X *	afcattrs.c - read and write complex attributes
X *
X *	Author: Andreas Lampen, TU-Berlin (andy@coma.UUCP
X *					   andy@db0tui62.BITNET)
X *
X *	$Header: afcattrs.c[1.5] Wed Feb 22 16:27:20 1989 andy@coma published $
X *
X *	EXPORT:
X *	af_snote -- set note (write note text)
X *	af_rnote -- return note
X *	af_svariant -- set variant attribute
X *	af_rvariant -- return variant
X *	af_sudattr -- set or modify user defined attribute
X *	af_rudattr -- return user defined attributes
X */
X
X#include <stdio.h>
X#include <string.h>
X#ifdef SUNOS_4_0
X#include <strings.h>
X#endif
X
X#include "typeconv.h"
X#include "afsys.h"
X#include "afs.h"
X
X#ifdef MEMDEBUG
Xextern FILE *memprot;
X#endif
X
Xchar *malloc();
X
X/*====================================================================
X *    af_snote -- set note (write note text)
X *
X *====================================================================*/
X
XEXPORT af_snote (key, buf)
X     Af_key *key;
X     char   *buf;
X{
X  int  len;
X  char internalbuf[1];
X
X  internalbuf[0] = '\0';
X
X  if (af_keytest (key))
X    SFAIL ("snote", "", AF_EINVKEY, ERROR);
X  if (VATTR(key).af_state == AF_BUSY)
X    SFAIL ("snote", "", AF_EBUSY, ERROR);
X  if (VATTR(key).af_class & AF_DERIVED)
X    SFAIL ("snote", "", AF_EDERIVED, ERROR);
X  if (af_checkperm (key, AF_LOCKHOLDER | AF_AUTHOR | AF_OWNER) == ERROR)
X    SFAIL ("snote", "", AF_EACCES, ERROR);
X
X  if (af_readdata (key->af_ldes) == ERROR)
X    return (ERROR);
X
X  if (!buf) /* if buf is a nil pointer */
X    buf = internalbuf;
X
X  len = strlen(buf) + sizeof (char); /* length of string plus nullbyte */
X  if (len > VATTR(key).af_notesize)
X    {
X      if ((VATTR(key).af_note = af_malloc (key->af_ldes, (unsigned) (len * sizeof (char)))) == (char *)0)
X	FAIL ("snote", "malloc", AF_ESYSERR, ERROR);
X    }
X  /* change datasize in header */
X  key->af_ldes->af_datasize -= VATTR(key).af_notesize;
X  key->af_ldes->af_datasize += len;
X
X  (void) strncpy (VATTR(key).af_note, buf, len);
X  VATTR(key).af_notesize = len;
X
X  /* save changes */
X  if (af_updtvers (key, AF_CHANGE) == ERROR)
X    return (ERROR);
X  return (AF_OK);
X}
X
X
X
X/*====================================================================
X *    af_rnote -- get pointer to note (read only)
X *
X *====================================================================*/
X
XEXPORT char *af_rnote (key)
X     Af_key *key;
X{
X  char *note;
X
X  if (af_keytest (key))
X    SFAIL ("rnote", "", AF_EINVKEY, (char *)0);
X  if (VATTR(key).af_state == AF_BUSY)
X    SFAIL ("rnote", "", AF_EBUSY, (char *)0);
X  if (VATTR(key).af_class & AF_DERIVED)
X    SFAIL ("rnote", "", AF_EDERIVED, (char *)0);
X
X  if (af_readdata (key->af_ldes) == ERROR)
X    return ((char *)0);
X
X  if (VATTR(key).af_notesize != 0)
X    {
X      if ((note = malloc ((unsigned) VATTR(key).af_notesize)) == (char *)0)
X	FAIL ("rnote", "malloc", AF_ESYSERR, (char *)0);
X      (void) strcpy (note, VATTR(key).af_note);
X      /* replace newline by nullbyte */
X      note[VATTR(key).af_notesize-1] = '\0';
X    }
X  else
X    {
X      if ((note = malloc ((unsigned) sizeof (char))) == (char *)0)
X	FAIL ("rnote", "malloc", AF_ESYSERR, (char *)0);
X      note[0] = '\0';
X    }
X
X  return (note);
X}
X
X
X
X/*====================================================================
X *    af_svariant -- set variant attribute
X *
X *====================================================================*/
X
XEXPORT af_svariant (key, buf)
X     Af_key *key;
X     char   *buf;
X{
X  if (af_keytest (key))
X    SFAIL ("svariant", "", AF_EINVKEY, ERROR);
X  if (buf)
X    if (strlen (buf) >= MAXVARLEN)
X      SFAIL ("svariant", "", AF_ETOOLONG, ERROR);
X  if (VATTR(key).af_class & AF_DERIVED)
X    SFAIL ("svariant", "", AF_EDERIVED, ERROR);
X  if (af_checkperm (key, AF_OWNER | AF_AUTHOR) == ERROR)
X    return (ERROR);
X
X  VATTR(key).af_variant = af_entersym (buf);
X
X  /* save changes */
X  if (af_updtvers (key, AF_CHANGE) == ERROR)
X    return (ERROR);
X  return (AF_OK);
X}
X
X
X
X/*====================================================================
X *    af_rvariant -- return variant attribute
X *
X *====================================================================*/
X
XEXPORT char *af_rvariant (key)
X     Af_key *key;
X{
X  char *variant;
X
X  if (af_keytest (key))
X    SFAIL ("rvariant", "", AF_EINVKEY, (char *)0);
X  if (VATTR(key).af_class & AF_DERIVED)
X    SFAIL ("rvariant", "", AF_EDERIVED, (char *)0);
X
X  if (VATTR(key).af_variant)
X    {
X      if ((variant = malloc ((unsigned) strlen (VATTR(key).af_variant) + sizeof (char))) == (char *)0)
X	FAIL ("rvariant", "malloc", AF_ESYSERR, (char *)0);
X      (void) strcpy (variant, VATTR(key).af_variant);
X    }
X  else
X    {
X      if ((variant = malloc ((unsigned) sizeof (char))) == (char *)0)
X	FAIL ("rvariant", "malloc", AF_ESYSERR, (char *)0);
X      variant[0] = '\0';
X    }
X
X  return (variant);
X}
X
X/*====================================================================
X *    af_sudattr -- set or modify user defined attribute
X *               User defined attributes are strings of the following form:
X *                 name=value
X *               For manipulating user defined attributes you have three
X *               modes:
X *               AF_ADD -- add value to attribute if name is present or
X *                         add user defined attribute otherwise
X *               AF_REMOVE -- remove attribute
X *               AF_REPLACE -- replace attribute
X *
X *               Returns AF_OK on successful execution, otherwise ERROR
X *
X *               Caution: the string "attr" must not contain '\n' !!
X *
X *====================================================================*/
X
XEXPORT af_sudattr (key, mode, attr)
X     Af_key *key;
X     int    mode;
X     char   *attr;
X{
X  char *udaptr, *tmpuda, *valptr;
X  int  tail;
X
X  if (af_keytest (key))
X    SFAIL ("sudattr", "", AF_EINVKEY, ERROR);
X  if (VATTR(key).af_state == AF_FROZEN)
X    SFAIL ("sudattr", "", AF_EWRONGSTATE, ERROR);
X
X  /* look for delimiter character in attribute string */
X  if (!attr || (index (attr, AF_UDAVALDEL) != (char *)0))
X    SFAIL ("sudattr", "", AF_EFORMAT, ERROR);
X
X  if (af_checkperm (key, AF_WORLD) == ERROR)
X    return (ERROR);
X
X  /* search entry */
X  udaptr = af_symlookup (&(VATTR(key).af_uhtab), attr,
X			 (Af_revlist *)0, (Af_revlist **)0); 
X
X  switch (mode)
X    {
X    case AF_ADD: if (udaptr != (char *)0)
X                   {
X		     /* build new entry and replace old one */
X		     valptr = index (attr, '=') + sizeof (char);
X		     if ((tmpuda = malloc ((unsigned) ((strlen (udaptr) + strlen (valptr) +2) * sizeof (char)))) == (char *)0)
X		       FAIL ("sudattr", "malloc", AF_ESYSERR, ERROR);
X
X		     (void) strcpy (tmpuda, udaptr);
X		     tail = strlen (tmpuda);
X		     tmpuda[tail] = AF_UDAVALDEL;
X		     tmpuda[tail+1] = '\0';
X		     (void) strcat (tmpuda, valptr);
X		     (void) af_replsym (&(VATTR(key).af_uhtab), tmpuda, (Af_revlist *)0);
X		     free (tmpuda);
X 		   }    
X                 else
X		   {
X		     /* add new entry */
X		     if (VATTR(key).af_udanum == AF_MAXUDAS-1)
X		       SFAIL ("sudattr", "", AF_EUDASNUM, ERROR);
X		     (void) af_hashsym (&(VATTR(key).af_uhtab), attr,(Af_revlist *)0);
X#ifdef MEMDEBUG
X		     fprintf (memprot, "UdaCattr (%s)\n", attr);
X#endif
X		     VATTR(key).af_udanum++;
X		   }
X                 break;
X
X    case AF_REMOVE: if (udaptr == (char *)0)
X                      SFAIL ("sudattr", "", AF_ENOUDA, ERROR);
X		    (void) af_delsym (&(VATTR(key).af_uhtab), udaptr,(Af_revlist *)0);
X		    VATTR(key).af_udanum--;
X                    break;
X
X    case AF_REPLACE: if (udaptr == (char *)0)
X                       SFAIL ("sudattr", "", AF_ENOUDA, ERROR);
X                     (void) af_replsym (&(VATTR(key).af_uhtab), attr, (Af_revlist *)0);
X                     break;
X    default: SFAIL ("sudattr", "", AF_EMODE, ERROR);
X    }
X
X  /* save changes */
X  if (af_updtvers (key, AF_CHANGE) == ERROR)
X    return (ERROR);
X  return (AF_OK);
X}
X
X
X
X/*====================================================================
X *    af_rudattr -- return user defined attributes
X *
X *====================================================================*/
X
XEXPORT char *af_rudattr (key, name)
X     Af_key *key;
X     char   *name;
X{
X  char *udattr, *entry, *valptr;
X
X  if (af_keytest (key))
X    SFAIL ("rudattr", "", AF_EINVKEY, (char *)0);
X  if (!name)
X    SFAIL ("rudattr", "no attribute name given", AF_EMISC, (char *)0);
X
X  if ((entry = af_symlookup (&(VATTR(key).af_uhtab), name,
X			     (Af_revlist *)0, (Af_revlist **)0)) == (char *)0)
X    return (char *)0;
X
X  if ((valptr = index (entry, AF_UDANAMDEL)) != (char *)0)
X    {
X      if ((udattr = malloc ((unsigned) strlen(valptr) + sizeof(char))) == (char *)0)
X	FAIL ("rudattr", "malloc", AF_ESYSERR, (char *)0);
X      /* replace delimiters by '\n' */
X      (void) strcpy (udattr, valptr+1);
X      valptr = udattr;
X      while ((valptr = index (valptr, AF_UDAVALDEL)) != (char *)0)
X	valptr[0] = '\n';
X    }
X  else
X    {
X      if ((udattr = malloc ((unsigned) sizeof(char))) == (char *)0)
X	FAIL ("rudattr", "malloc", AF_ESYSERR, (char *)0);
X      udattr[0] = '\0';
X    }
X  
X  return (udattr);
X}
X
END_OF_FILE
if test 10117 -ne `wc -c <'src/afs/afcattrs.c'`; then
    echo shar: \"'src/afs/afcattrs.c'\" unpacked with wrong size!
fi
# end of 'src/afs/afcattrs.c'
fi
if test -f 'src/afs/affiles.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/afs/affiles.c'\"
else
echo shar: Extracting \"'src/afs/affiles.c'\" \(10601 characters\)
sed "s/^X//" >'src/afs/affiles.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X/*LINTLIBRARY*/
X/*
X *	Shape/AFS
X *
X *	affiles.c -- UNIX-files in AFS
X *
X *	Author: Andreas Lampen, TU-Berlin (andy@coma.UUCP)
X *					  (andy@db0tui62.BITNET)
X *
X *	$Header: affiles.c[1.6] Wed Feb 22 16:27:34 1989 andy@coma published $
X *
X *	EXPORT:
X *      af_access -- see if any version of named file exists
X *	af_crkey -- create filekey
X *	af_open -- open AFS-file
X *	af_close -- close AFS-file
X *      af_link -- create a link to a AFS-file
X *	af_rm -- remove AFS-file
X *	af_restore -- restore derived file
X */
X
X#include <stdio.h>
X#include <sys/param.h>
X#include <sys/file.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X
X#include "typeconv.h"
X#include "afsys.h"
X#include "afs.h"
X
X/*================================================================
X *	af_access -- see if any version of named file exists
X *
X *================================================================*/
X
XEXPORT af_access (path, name, type, mode)
X     char *path, *name, *type;
X     int  mode;
X{
X  char *unixname, *arnamptr, *pathname, *nameptr, *typeptr;
X  Af_revlist *list, *af_rbplist(), *af_readattrs();
X  short maxindex, i;
X  bool loaded = FALSE;
X  
X  pathname = af_uniqpath (path);
X
X  if (mode & AF_DERIVED) /* look in binary pool */
X    {
X      /* lookup in binary pool */
X      
X      if ((list = af_rbplist (pathname)) == (Af_revlist *)0)
X	return (ERROR);
X      
X      nameptr = af_entersym (name);
X      typeptr = af_entersym (type);
X      maxindex = list->af_nrevs;
X      for (i = 0; i < maxindex; i++)
X	{
X	  /* skip holes in the list */
X	  if (!(list->af_list[i].af_class & AF_VALID))
X	    {
X	      maxindex++;
X	      continue;
X	    }
X	  if ((nameptr == list->af_list[i].af_name) &&
X	      (typeptr == list->af_list[i].af_type))
X	    return (AF_OK);
X	}
X    }
X  else /* look in directory */
X    {
X      unixname = af_unixname (pathname, name, type);
X      /* if a named unix file exists */
X      if (!af_sysaccess (unixname, F_OK))
X	return (AF_OK);
X      /* look for archive */
X      arnamptr = af_garname (pathname, name, type);
X      if (!af_sysaccess (arnamptr, F_OK))
X	{
X	  /* look if there are versions in archive file */
X	  list = af_readattrs (pathname, name, type, &loaded);
X	  if (list->af_nrevs > 0)
X	    return (AF_OK);
X	}
X    }
X  return (ERROR);
X}
X
X/*================================================================
X *	af_crkey
X *
X *================================================================*/
X
XEXPORT af_crkey (path, name, type, key)
X     char *path;
X     char *name, *type;
X     Af_key *key;
X{
X  char *busyname, *uniqpath;
X  FILE *busyfile;
X  Af_revlist *af_readattrs();
X  bool loaded = FALSE;
X  Af_key *busykey, *af_gbuskey();
X  Af_user *author;
X  struct stat bibuf;
X  
X  uniqpath = af_uniqpath (path);
X  busyname = af_gbusname (uniqpath, name, type);
X  
X  /* if file does not exist -- create it */
X  if ((lstat (busyname, &bibuf)) == ERROR)
X    {
X      if ((busyfile = fopen (busyname, "w")) == (FILE *)0)
X	FAIL ("crkey", "fopen", AF_ESYSERR, ERROR);
X      (void) fclose (busyfile);
X      (void) stat (busyname, &bibuf);
X    }
X  
X  key->af_ldes = af_readattrs (uniqpath, name, type, &loaded);
X  
X  /* select busy version if present */
X  if ((busykey = af_gbuskey (key->af_ldes)) == (Af_key *)0)
X    FAIL ("crkey", "no space for busy version", AF_EINTERNAL, ERROR);
X  key->af_lpos = busykey->af_lpos;
X
X  if (af_checkperm (busykey, AF_WORLD) == ERROR)
X    return (ERROR);
X
X  /* if busy version was invalid up to now, initialize it */
X  if (!(VATTR(key).af_class & AF_VALID))
X    {
X      key->af_ldes->af_nrevs += 1;
X      VATTR(key).af_class = AF_VALID;
X      if ((author = af_getuser (bibuf.st_uid)) == (Af_user *)0)
X	{
X	  af_wng ("crkey", "invalid userID in inode of busy file");
X	  author = af_getuser (getuid());
X	}
X      VATTR(key).af_auname = af_entersym (author->af_username);
X      VATTR(key).af_auhost = af_enterhost (author->af_userhost);
X      VATTR(key).af_mode = (u_short) bibuf.st_mode;
X      VATTR(key).af_lckname = (char *)0;
X      VATTR(key).af_lckhost = (char *)0;
X      VATTR(key).af_mtime = (time_t) af_cvttime (bibuf.st_mtime);
X      VATTR(key).af_atime = (time_t) af_cvttime (bibuf.st_atime);
X      VATTR(key).af_ctime = (time_t) af_cvttime (bibuf.st_ctime);
X      VATTR(key).af_stime = AF_NOTIME;
X      VATTR(key).af_ltime = AF_NOTIME;
X      VATTR(key).af_fsize = (off_t) bibuf.st_size;
X    }
X
X  key->af_ldes->af_refcount++;
X  VATTR(key).af_nlinks++;
X
X/* possibly the date of last access is *not* set properly */
X/* instead of */
X  (void) af_updtvers (key, 0);
X/* this should be */
X/* if (af_updtvers (key, 0) == ERROR) */
X/*    return (ERROR); */
X
X  return (AF_OK);
X}
X
X/*================================================================
X *	af_open
X *
X *================================================================*/
X
XEXPORT FILE *af_open (key, mode)
X     Af_key *key;
X     char   *mode;
X{
X  FILE   *file;
X  char   *tmpname;
X  
X  if (af_keytest (key))
X    SFAIL ("open", "", AF_EINVKEY, (FILE *)0);
X  
X  /* if file is present as busy version */
X  if (VATTR(key).af_state == AF_BUSY)
X    {
X      if ((file = fopen (key->af_ldes->af_busyfilename, mode)) == (FILE *)0)
X	FAIL ("open", "fopen", AF_ESYSERR, (FILE *)0);
X      return (file);
X    }
X  
X  /* saved versions can be opened only for reading */
X  if (mode[0] != 'r')
X    SFAIL ("open", "", AF_ESAVED, (FILE *)0);
X  
X  /* see if file is readable */
X  if (af_checkread (key) == ERROR)
X    SFAIL ("open", "", AF_EACCES, (FILE *)0);
X
X  /* build name for temporary file */
X  tmpname = af_gtmpname (CATTR(key).af_syspath, VATTR(key).af_name);
X  af_regtmpfile (tmpname);
X
X  if (af_bldfile (key, tmpname) == ERROR)
X    return ((FILE *)0);
X
X  if ((file = fopen (tmpname, mode)) == (FILE *)0)
X    FAIL ("open", "fopen", AF_ESYSERR, (FILE *)0);
X
X  (void) af_unlink (tmpname); /* this causes the tmp file to be removed on closing */
X  af_unregtmpfile (tmpname);
X
X  VATTR(key).af_atime = (time_t)af_acttime ();
X/* possibly the date of last access is *not* set properly */
X/* instead of */
X  (void) af_updtvers (key, 0);
X/* this should be */
X/* if (af_updtvers (key, 0) == ERROR) */
X/*    return ((FILE *)0); */
X
X  return (file);
X}
X
X
X/*================================================================
X *	af_close
X *
X *================================================================*/
X
XEXPORT af_close (file)
X     FILE *file;
X{
X  return (fclose (file));
X}
X
X/*================================================================
X *	af_link
X *
X *================================================================*/
X
XEXPORT af_link (oldkey, newkey)
X     /*ARGSUSED*/
X     Af_key *oldkey, *newkey;
X{
X  /* not yet implemented (af_link) */
X}
X
X/*================================================================
X *	af_rm
X *
X *================================================================*/
X
XEXPORT af_rm (key)
X     Af_key *key;
X{
X  Af_user *locker;
X  if (af_keytest (key))
X    SFAIL ("rm", "", AF_EINVKEY, ERROR);
X
X  /* if object is a derived object or not locked */
X  locker = af_testlock (key, AF_VERSIONLOCK);
X  if (!((VATTR(key).af_class & AF_DERIVED) || (locker->af_username[0]=='\0')))
X    {
X      if (af_checkperm (key, AF_LOCKHOLDER) == ERROR)
X	SFAIL ("rm", "", AF_ENOTLOCKED, ERROR);
X    }
X
X  if (af_delvers (key) == ERROR)
X    return (ERROR);
X
X  if (VATTR(key).af_nlinks > 1)
X    af_wng ("af_rm", "deleted object has more than one reference");
X
X  /* decrease reference count for corresponding archive */
X  if ((key->af_ldes->af_refcount -= VATTR(key).af_nlinks) <= 0)
X    {
X      VATTR(key).af_class &= ~AF_VALID;
X      VATTR(key).af_nlinks = 0;
X      (void) af_detlist (key->af_ldes);
X    }
X  else
X    {
X      VATTR(key).af_class &= ~AF_VALID;
X      VATTR(key).af_nlinks = 0;
X    }
X  
X  return (AF_OK);
X}
X
X/*================================================================
X *	af_restore
X *
X *================================================================*/
X
XEXPORT af_restore (key, restkey)
X     Af_key *key, *restkey;
X{
X  char *busyname;
X  bool loaded = FALSE;
X  int  af_fhash ();
X  Af_revlist *list;
X
X  if (af_keytest (key))
X    SFAIL ("restore", "", AF_EINVKEY, ERROR);
X
X  if (!(VATTR(key).af_class & AF_DERIVED))
X    SFAIL ("restore", "", AF_ENOTDERIVED, ERROR);
X
X  /* see if file is readable */
X  if (af_checkread (key) == ERROR)
X    SFAIL ("restore", "", AF_EACCES, ERROR);
X
X  busyname = af_gbusname (CATTR(key).af_syspath,
X			   VATTR(key).af_name, VATTR(key).af_type);
X  if (af_bldfile (key, busyname) == ERROR)
X    return (ERROR);
X
X  /* build key for restored file */
X  if ((list = af_readattrs (CATTR(key).af_syspath, VATTR(key).af_name,
X			    VATTR(key).af_type, &loaded)) == (Af_revlist *)0)
X    FAIL ("restore", "cannot access restored file", AF_EINTERNAL, ERROR);
X  if (af_buildkey (list, AF_BUSYVERS, AF_BUSYVERS, restkey) == ERROR)
X    FAIL ("restore", "cannot access restored file", AF_EINTERNAL, ERROR);
X  restkey->af_ldes->af_refcount++;
X  VATTR(restkey).af_nlinks++;
X
X  /* if key is in use, an error message should be generated */
X
X  /* restore user defined attributes from binary pool */
X  af_hashfree (&(VATTR(restkey).af_uhtab));
X  (void) af_hashinit (&(VATTR(restkey).af_uhtab), AF_MAXUDAS, af_fhash);
X  VATTR(restkey).af_udanum = VATTR(key).af_udanum;
X  (void) af_hashcopy (&(VATTR(key).af_uhtab), &(VATTR(restkey).af_uhtab));
X
X  VATTR(key).af_atime = (time_t)af_acttime ();
X  /* possibly the date of last access is *not* set properly */
X  /* instead of */
X  (void) af_updtvers (key, 0);
X  (void) af_updtvers (restkey, 0);
X  /* this should be */
X  /* if (af_updtvers (key, 0) == ERROR) */
X  /*    return ((FILE *)0); */
X  
X  return (AF_OK);
X}
X
X
END_OF_FILE
if test 10601 -ne `wc -c <'src/afs/affiles.c'`; then
    echo shar: \"'src/afs/affiles.c'\" unpacked with wrong size!
fi
# end of 'src/afs/affiles.c'
fi
if test -f 'src/shape/selrule.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/shape/selrule.c'\"
else
echo shar: Extracting \"'src/shape/selrule.c'\" \(11309 characters\)
sed "s/^X//" >'src/shape/selrule.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *RCSid = "$Header: selrule.c,v 3.1 89/02/20 18:55:14 wolfgang Exp $";
X#endif
X#ifndef lint
Xstatic char *ConfFlg = CFFLGS;	/* should be defined from within Makefile */
X#endif
X/*
X * $Log:	selrule.c,v $
X * Revision 3.1  89/02/20  18:55:14  wolfgang
X * inititialisation of ->cont added.
X * 
X * Revision 3.0  89/01/24  11:36:48  wolfgang
X * New System Generation
X * 
X * Revision 2.12  89/01/18  13:42:05  wolfgang
X * init_selruletab() added.
X * 
X * Revision 2.11  89/01/03  13:13:27  wolfgang
X * changes done for lint
X * 
X * Revision 2.10  88/12/21  15:12:40  wolfgang
X * changes done for lint
X * 
X * Revision 2.9  88/11/21  15:48:33  wolfgang
X * return code of all malloc's checked
X * 
X * Revision 2.8  88/11/02  13:30:40  wolfgang
X * This version is part of a release
X * 
X * Revision 2.7  88/10/18  17:43:20  wolfgang
X * new variant handling
X * 
X * Revision 2.6  88/10/10  17:03:06  wolfgang
X * This version is part of a release
X * 
X * Revision 2.5  88/09/16  19:58:35  wolfgang
X * bug fixed.
X * 
X * Revision 2.4  88/09/16  19:39:24  wolfgang
X * syntactic analysis of rule section improved.
X * 
X * Revision 2.3  88/09/16  11:04:44  wolfgang
X * bug fixed.
X * 
X * Revision 2.2  88/08/23  14:40:15  wolfgang
X * Minor bug fixed. Still the syntactical analysis is a hack.
X * 
X * Revision 2.1  88/08/19  10:18:00  wolfgang
X * This version is part of a release
X * 
X */
X
X#include "shape.h"
X#include "selrule.h"
X
X  char *stdattr[]  = { "attr",
X		       "attrnot",
X		       "attrlt",
X		       "attrgt",
X		       "attrle",
X		       "attrge",
X		       "attrmin",
X		       "attrmax",
X		       "getfromcid",
X		       "attrvar",
X		       "msg",
X		       "0"
X		       };
X
X
X
Xextern int hashval();
Xextern int errexit();
Xextern struct selection_rules *currule;
X
Xstruct selection_rules *sels[SELTABSIZE];
X
Xint selruledef(string)
X     char *string;
X{
X  char rulename[MAXNAMELENGTH];
X  char pred[MAXPREDLENGTH];
X  char name[MAXNAMELENGTH];
X  char value[MAXVALLENGTH];
X  struct selection_rules *cursec;
X  struct list *curlist;
X  char *predptr;
X  int what = 0;
X  int hashr;
X  int i = 0;
X  int j = 0;
X  int l = 0;
X  int k = 0;
X  int kla = 0;
X  while (string[i] != '\n')
X    i++;
X  i++;
X  
X  while((string[i] != '#') && (string[i+1] != '%'))
X    {
X      l = 0;
X      while((string[i] == '\t') || (string[i] == ' ') || (string[i] == '\n'))
X	i++;
X
X      if ((string[i] == '#') && (string[i+1] == '%'))
X	errexit(31,NIL);
X
X      /* rule name */
X      j = 0;
X      while ((string[i] != ' ') && (string[i] != '\t') && (string[i] != ':'))
X	{
X	  if (string[i] == '\n')
X	    errexit(31,NIL);
X	  if ((string[i] == '#') && (string[i+1] == '%'))
X	    errexit(31,NIL);
X	  rulename[j] = string[i];
X	  j++;
X	  i++;
X	}
X      rulename[j] = '\0';
X#ifdef DEBUG_SELRULE
Xprintf("selrulename:###%s###\n", rulename);
X#endif DEBUG_SELRULE
X      hashr = hashval(rulename);
X      if (sels[hashr] == (struct selection_rules*) NIL)
X	{
X	  if((cursec = sels[hashr] = (struct selection_rules *) malloc( sizeof( struct selection_rules))) == (struct selection_rules *) NIL)
X	    errexit(10,"malloc");
X	}
X      else
X	{
X	  cursec = sels[hashr];
X	  while((strcmp(cursec->name, rulename) != 0) && (cursec->next != (struct selection_rules *) NIL))
X	    cursec = cursec->next;
X	  if( strcmp(cursec->name, rulename) == 0)
X	    errexit(5, rulename);
X	  else
X	    {
X	      if((cursec = cursec->next = (struct selection_rules *) malloc ( sizeof( struct selection_rules))) == (struct selection_rules *) NIL)
X		errexit(10,"malloc");
X	    }
X	}
X      if ((cursec->name = malloc((unsigned) (strlen(rulename) + 1 ))) == NIL)
X	errexit(10,"malloc");
X      (void) strcpy(cursec->name, rulename);
X
X      while((string[i] == ' ') || (string[i] == '\t') || (string[i] == '\n') || (string[i] == ':'))
X	i++;
X
X      if((string[i] == '#') && (string[i+1] == '%'))
X	errexit(31,NIL);
X
X      while((string[i] != '.'))
X	{
X	  if ((string[i] == '#') && (string[i+1] == '%'))
X	    errexit(31,NIL);
X
X	  if (string[i] == ';')
X	    {
X	      if((string[i] == '#') && (string[i+1] == '%'))
X		errexit(31,NIL);
X	      k++;
X	      i++;
X	      if((string[i] == '#') && (string[i+1] == '%'))
X		errexit(31,NIL);
X	      l = 0;
X	    }
X	  while((string[i] == '\n') || (string[i] == ' ') || (string[i] == '\t'))
X	    i++;
X
X	  if ((string[i] == '#') && (string[i+1] == '%'))
X	    errexit(31,NIL);
X
X	  while((string[i] != ';') || (kla != 0))
X	    {
X	      if ((string[i] == '#') && (string[i+1] == '%'))
X		errexit(31,NIL);
X	      if (string[i] == '.')
X		break;
X	      j = 0;
X	      while((string[i] != ',') && (string[i] != ';') && (string[i] != '('))
X		{
X		  if ((string[i] == '#') && (string[i+1] == '%'))
X		    errexit(31,NIL);
X		  if ((string[i] != ' ') && (string[i] != '\t') &&
X		      (string[i] != '\n'))
X		    {
X		      pred[j] = string[i];
X		      j++;
X		    }
X		  if (((string[i] == '-') && (string[i+1] == ')')) ||
X		      ((string[i] == '-') && (string[i+1] == '(')))
X		    {
X		      pred[j] = string[i+1];
X		      j++;
X		      i++;
X		    }
X		  if ((string[i] == '#') && (string[i+1] == '%'))
X		    errexit(31,NIL);
X		  i++;
X		  if ((string[i] == '#') && (string[i+1] == '%'))
X		    errexit(31,NIL);
X		}
X	      pred[j]='\0';
X#ifdef DEBUG_SELRULE
Xprintf("predicate found:###%s###\n", pred);
X#endif DEBUG_SELRULE
X
X	      while(string[i] == '(')
X		i++;
X
X	      if ((string[i] == '#') && (string[i+1] == '%'))
X		errexit(31,NIL);
X
X	      j  = 0;
X
X	      while((string[i] != ',') && (string[i] != ')') && (l != 0))
X		{
X		  if ((string[i] == '#') && (string[i+1] == '%'))
X		    errexit(31,NIL);
X/*		  if ((string[i] != ' ') && (string[i] != '\t')) 
X		    { */
X		      name[j] = string[i];
X		      j++;
X/*		    } */
X		  i++;
X
X		  if ((string[i] == '#') && (string[i+1] == '%'))
X		    errexit(31,NIL);
X
X		}
X	      name[j] = '\0';
X	  
X	      if (string[i] == ',')
X		i++;
X
X	      if ((string[i] == '#') && (string[i+1] == '%'))
X		errexit(31,NIL);
X	      
X	      while((string[i] == '\t') || (string[i] == ' '))
X		i++;
X
X	      if ((string[i] == '#') && (string[i+1] == '%'))
X		errexit(31,NIL);
X
X	      j = 0;
X	      while((string[i] != ')') && ( l != 0))
X		{
X		  if((string[i] == '#') && (string[i+1] == '%'))
X		    errexit(31,NIL);
X/*		  if((string[i] != ' ') && (string[i] != '\t'))
X		    { */
X		      value[j] = string[i];
X		      j++;
X/*		    } */
X		  i++;
X		}
X	      value[j] = '\0';
X
X	      while((string[i] == ')') || (string[i] == ','))
X		i++;
X
X
X	      while((string[i] == ' ') || (string[i] == '\t'))
X		i++;
X
X	      if ((string[i] == '#') && (string[i+1] == '%'))
X		errexit(31,NIL);
X	    
X#ifdef DEBUG_SELRULE
Xif (l != 0)
X  printf("name: ###%s###\nvalue: ###%s###\n", name, value);
X#endif DEBUG_SELRULE
X
X	      if (l == 0)
X		{
X		  if((curlist = cursec->predlist[k] = (struct list *) malloc( sizeof (struct list))) == (struct list *) NIL)
X		    errexit(10,"malloc");
X		  cursec->predlist[k+1] = (struct list *) NIL;
X		  curlist->selfunc = pattern;
X		  curlist->parn = NIL;
X		  curlist->cont = (struct list *) NIL;
X
X		  predptr = &pred[0];
X		  predptr = predptr + specials(predptr, &what);
X
X		  if ((curlist->parv = malloc ((unsigned) (strlen(predptr) + sizeof(char)))) == NIL)
X		    errexit(10,"malloc");
X		  (void) strcpy(curlist->parv, predptr);
X		  curlist->i = what;
X		  l++;
X		  what = 0;
X		}
X	      else
X		{
X		  j = 0;
X		  while ((strcmp(pred, stdattr[j]) != 0) && (strcmp(stdattr[j],"0")!= 0))
X		    j++;
X		  if (strcmp(pred,stdattr[j]) != 0 )
X		    errexit(6, pred);
X		  else
X		    {
X		      if((curlist = curlist->cont = (struct list *) malloc( sizeof (struct list))) == (struct list *) NIL)
X			errexit(10,"malloc");
X		      curlist->cont = (struct list *) NIL;
X		      if((curlist->parn = malloc((unsigned) (strlen(name) + 1))) == NIL)
X			errexit(10,"malloc");
X		      (void) strcpy(curlist->parn, name);
X		      if ((curlist->parv = malloc((unsigned) (strlen(value) + 1))) == NIL)
X			errexit(10,"malloc");
X		      (void) strcpy(curlist->parv, value);
X			
X		      switch (j)
X			{
X			case 0:
X			  curlist->selfunc = attr;
X			  curlist->i = 1;
X			  break;
X			case 1:
X			  curlist->selfunc = attrnot;
X			  curlist->i = 2;
X			  break;
X			case 2:
X			  curlist->selfunc = attrlt;
X			  curlist->i = 2;
X			  break;
X			case 3:
X			  curlist->selfunc = attrgt;
X			  curlist->i = 2;
X			  break;
X			case 4:
X			  curlist->selfunc = attrle;
X			  curlist->i = 2;
X			  break;
X			case 5:
X			  curlist->selfunc = attrge;
X			  curlist->i = 2;
X			  break;
X			case 6:
X			  curlist->selfunc = attrmin;
X			  curlist->i = 2;
X			  break;
X			case 7:
X			  curlist->selfunc = attrmax;
X			  curlist->i = 2;
X			  break;
X			case 8:
X			  curlist->selfunc = getfromcid;
X			  curlist->i = 1;
X			  break;
X			case 9:
X			  curlist->selfunc = attrvar;
X			  curlist->i = 0;
X			  break;
X			case 10:
X			  curlist->selfunc = msg;
X			  curlist->i = 0;
X			  break;
X			}
X		      pred[0] = '\0';
X		      j = 0;
X		    }
X		}
X	    }
X	}
X
X      while((string[i] == ' ') || (string[i+1] == '\t'))
X	i++;
X
X      if (string[i] == '.')
X	{
X	  i++;
X	  k = 0;
X	}
X      while ((string[i] == ' ') || (string[i] == '\n') || (string[i] == '\t'))
X	i++;
X    }
X}
X
X
X#ifdef DEBUG_SELRULE
Xint seldump()
X{
X  int i = 0;
X  for (i = 0; i < SELTABSIZE; i++)
X    {
X      if (sels[i] != (struct selection_rules *) NIL)
X	{
X	  printf("i = %d, name = %s\n",i, sels[i]->name);
X	}
X    }
X}
X#endif
X
X
XBool is_selrule_name(name)
X     char *name;
X{
X  int hash;
X  struct selection_rules *current;
X
X  hash = hashval(name);
X  
X  if (sels[hash] == (struct selection_rules *) NIL)
X    return (FALSE);
X  else
X    current = sels[hash];
X
X  while (current != (struct selection_rules *) NIL)
X    {
X      if ((strcmp(current->name, name)) == 0)
X	{
X	  currule = current;
X	  return(TRUE);
X	}
X      else
X	current = current->next;
X    }
X  
X  if ( current == (struct selection_rules *) NIL)
X    return(FALSE);
X
X  /*NOTREACHED*/
X  return(FALSE);
X}
X
X
Xint specials(ptr, what)
X     char *ptr;
X     int *what;
X{
X  if(*ptr == '+')
X    {
X      *what = SMILEY;
X      return(1);
X    }
X
X  if(*ptr == '-')
X    {
X      *what = GRIMMY;
X      return(1);
X    }
X
X  if (!strncmp(ptr,":-)",3))
X    {
X      *what = SMILEY;
X      return(3);
X    }
X
X  if (!strncmp(ptr,":-(",3))
X    {
X      *what = GRIMMY;
X      return(3);
X    }
X  
X  what = 0;
X  return(0);
X
X}
X  
Xinit_selruletab()
X{
X  bzero((char *) sels, SELTABSIZE * sizeof(struct rules *));
X}
END_OF_FILE
if test 11309 -ne `wc -c <'src/shape/selrule.c'`; then
    echo shar: \"'src/shape/selrule.c'\" unpacked with wrong size!
fi
# end of 'src/shape/selrule.c'
fi
if test -f 'src/shape/shapeopt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/shape/shapeopt.c'\"
else
echo shar: Extracting \"'src/shape/shapeopt.c'\" \(10193 characters\)
sed "s/^X//" >'src/shape/shapeopt.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *RCSid = "$Header: shapeopt.c,v 3.0 89/01/24 11:36:54 wolfgang Stable $";
X#endif
X#ifndef lint
Xstatic char *ConfFlg = CFFLGS;	/* should be defined from within Makefile */
X#endif
X/*
X * $Log:	shapeopt.c,v $
X * Revision 3.0  89/01/24  11:36:54  wolfgang
X * New System Generation
X * 
X * Revision 2.17  89/01/03  13:13:43  wolfgang
X * changes done for lint
X * 
X * Revision 2.16  88/12/19  13:20:51  wolfgang
X * h_force_option added.
X * 
X * Revision 2.15  88/11/24  12:08:31  wolfgang
X * Argument for -confid *must* now be a target name.
X * 
X * Revision 2.14  88/11/21  15:47:34  wolfgang
X * return code of all malloc's checked
X * 
X * Revision 2.13  88/11/08  19:26:24  wolfgang
X * -expandall & -expandnothing are not allowed at the same time
X * 
X * Revision 2.12  88/11/08  11:03:00  wolfgang
X * h_expandall_option & h_expandnothing_option added.
X * 
X * Revision 2.11  88/10/20  12:03:11  wolfgang
X * This version is part of a release
X * 
X * Revision 2.10  88/10/10  16:55:38  wolfgang
X * handling of -t option activated
X * 
X * Revision 2.9  88/10/03  12:53:54  wolfgang
X * undone last changes.
X * 
X * Revision 2.8  88/10/03  11:37:10  wolfgang
X * handling of the -R option changed: if an  unknown selection rule is
X * passed to shape, shape now stops.
X * 
X * Revision 2.7  88/09/22  10:03:18  wolfgang
X * bug fixed: -R option.
X * 
X * Revision 2.6  88/09/19  15:07:38  wolfgang
X * h_r_option changed to h_R_option.
X * 
X * Revision 2.5  88/08/23  16:36:57  wolfgang
X * To rebuild something from a confid the option -rebuild is added.
X * 
X * Revision 2.4  88/08/23  10:28:21  wolfgang
X * Changed the -Z option to -confid.
X * 
X * Revision 2.3  88/08/22  17:00:26  wolfgang
X * Initialization of confid added.
X * 
X * Revision 2.2  88/08/12  08:58:25  wolfgang
X * This version is part of a release
X * 
X */
X
X#include "shape.h"
X#include "ParseArgs.h"
Xchar *version();
Xchar *af_version();
Xchar cfname[MAXNAMLEN];
Xchar *forcelist[10];
X
Xextern int init_confid();
Xextern struct linked_list *shapefiles;
Xextern char ruleset[];
Xextern char rbtarg[];
Xextern int implicit_suffs[];
X
Xextern int h_d_option();
Xextern int h_e_option();
Xextern int h_f_option();
Xextern int h_force_option();
Xextern int h_h_option();
Xextern int h_i_option();
Xextern int h_k_option();
Xextern int h_log_option();
Xextern int h_m_option();
Xextern int h_n_option();
Xextern int h_p_option();
Xextern int h_q_option();
Xextern int h_r_option();
Xextern int h_R_option();
Xextern int h_s_option();
Xextern int h_S_option();
Xextern int h_t_option();
Xextern int h_v_option();
Xextern int h_b_option();
Xextern int h_V_option();
Xextern int h_confid_option();
Xextern int h_version_option();
Xextern int h_rebuild_option();
Xextern int h_expandall_option();
Xextern int h_expandnothing_option();
Xextern FILE *cmfopen();
X
XOptDesc odesc[] = {
X  { "d", OPT_IS_SWITCH,	h_d_option },
X  { "e", OPT_IS_SWITCH,	h_e_option },
X  { "f", OPT_HAS_ARG, h_f_option },
X  { "force", OPT_HAS_ARG, h_force_option },
X  { "h", OPT_IS_SWITCH,	h_h_option },
X  { "i", OPT_IS_SWITCH,	h_i_option },
X  { "k", OPT_IS_SWITCH,	h_k_option },
X  { "log", OPT_IS_SWITCH, h_log_option },
X  { "m", OPT_IS_SWITCH,	h_m_option },
X  { "n", OPT_IS_SWITCH,	h_n_option },
X  { "p", OPT_IS_SWITCH,	h_p_option },
X  { "q", OPT_IS_SWITCH,	h_q_option },
X  { "r", OPT_IS_SWITCH, h_r_option },
X  { "R", OPT_HAS_ARG, h_R_option },
X  { "s", OPT_IS_SWITCH,	h_s_option },
X  { "S", OPT_IS_SWITCH,	h_S_option },
X  { "t", OPT_IS_SWITCH,	h_t_option }, 
X  { "v", OPT_HAS_ARG, h_v_option },
X  { "V", OPT_HAS_ARG, h_V_option },
X  { "version", OPT_IS_SWITCH, h_version_option },
X  { "confid", OPT_HAS_ARG, h_confid_option },
X  { "rebuild", OPT_HAS_ARG, h_rebuild_option },
X  { "expandall", OPT_IS_SWITCH, h_expandall_option },
X  { "expandnothing", OPT_IS_SWITCH, h_expandnothing_option },
X  { "b", OPT_IS_SWITCH, h_b_option },
X  { (char *) NULL, NULL, NULL }
X};
X
X
Xint h_d_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X  debugflg = TRUE;
X  return(0);
X}
X
Xint h_e_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X  envflg = TRUE;
X  return(0);
X}
X
Xint h_f_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X
Xstruct linked_list *shfiles;
Xif (!strcmp(arg,""))
X  return(1);
Xfileflg = TRUE;
Xif (strcmp(arg,"-") == 0)
X  stdinflg = TRUE;
Xelse
X  {
X    if (shapefiles == (struct linked_list *) NIL)
X      {
X	if ((shapefiles = (struct linked_list *) malloc(sizeof(struct linked_list))) == (struct linked_list *) NIL)
X	  errexit(10,"malloc");
X	if ((shapefiles->string = malloc((unsigned) strlen(arg) + sizeof(char))) == NIL)
X	  errexit(10,"malloc");
X	(void) strcpy(shapefiles->string,arg);
X	shapefiles->nextstring = (struct linked_list *) NIL;
X      }
X    else
X      {
X	shfiles = shapefiles;
X	while( shfiles->nextstring != (struct linked_list *) NIL)
X	  shfiles = shfiles->nextstring;
X	
X	if((shfiles->nextstring  = (struct linked_list *) malloc(sizeof(struct linked_list))) == (struct linked_list *) NIL)
X	  errexit(10,"malloc");
X	shfiles = shfiles->nextstring;
X	if ((shfiles->string = malloc((unsigned) strlen(arg) + sizeof(char))) == NIL)
X	  errexit(10,"malloc");
X	(void) strcpy(shfiles->string, arg);
X	shfiles->nextstring = (struct linked_list *) NIL;
X      }
X  }
X  return(0);
X}
X
X
Xint h_force_option(opt,arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X  int i = 0;
X  forceflg = TRUE;
X  while(forcelist[i] != NIL)
X    {
X      if (i == 10)
X	errexit(36, NIL);
X      i++;
X    }
X  if ((forcelist[i] = malloc((unsigned) (strlen(arg) + sizeof(char)))) == NIL)
X    errexit(10,"malloc");
X  (void) strcpy(forcelist[i],arg);
X  return (0);
X}
X
Xint h_h_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X  return(1);
X}
X
Xint h_i_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X  ignoreflg = TRUE;
X  return(0);
X}
X
Xint h_k_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt; 
X     char *arg;
X{
X  goflg = TRUE;
X  return(0);
X}
X
Xint h_log_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X  logflg = TRUE;
X  return(0);
X}
X
Xint h_m_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X  /* weiss ich nich */
X  return(0);
X}
X
Xint h_n_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X  noexflg = TRUE;
X  return(0);
X}
X
Xint h_p_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X  printflg = TRUE;
X  return(0);
X}
X
Xint h_q_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X  questflg = TRUE;
X  return(0);
X}
X
Xint h_r_option(opt,arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X  implicit_suffs[0] = -1;
X  return(0);
X}
X
X
Xint h_R_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X  ruleflg = TRUE;
X  (void) strcpy(ruleset,arg);
X  return(0);
X}
X
Xint h_s_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X  silentflg = TRUE;
X  return(0);
X}
X
Xint h_S_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X  goflg = FALSE;
X  return(0);
X}
X
Xint h_t_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X  touchflg = TRUE;
X  return(0);
X}
X
Xint h_v_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X/*  variant = arg  ???? */;
X  return(0);
X}
X
Xint h_version_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X  printf("shape - Version %s\n", version());
X  printf("uses AFS: Version %s\n", af_version());
X  exit(0);
X}
X
Xint h_expandall_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X  if (noexpflg)
X    errexit(34,NIL);
X  expflg = TRUE;
X  return(0);
X}
X
Xint h_expandnothing_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X  if(expflg)
X    errexit(34,NIL);
X  noexpflg = TRUE;
X  return(0);
X}
X
X
Xint h_b_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X; /* because of compatibility; does nothing (i hope so ...) */
X  return(0);
X}
X
Xint h_V_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X  /* set generation and revision (for shapefile) */
X
X
X/*      case 'V':
X	if ((ccc = index(optarg,'.')) == 0)
X	  errexit(9, optarg);
X	else
X	  {
X	    ccc[0] = '\0';
X	    gen = atoi(optarg);
X	    *ccc++;
X	    rev = atoi(ccc);
X	  }
X	break;
X      default:
X	h[0] = c;
X	h[1] = '\0';
X	errexit( 2, h);  */
X  return(0);
X
X}
X
Xint h_confid_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
X  if (!strcmp(arg,""))
X    return(1);
X
X  confid = TRUE;
X  (void) strcpy(cfname,arg);
X  (void) strcat(cfname,".cid");
X  if ((cid = cmfopen(cfname,"w",AF_BUSYVERS, AF_BUSYVERS)) == (FILE *) NIL)
X    errexit(12, cfname);
X  init_confid(arg);
X  (void) strcpy(cfname,arg);
X  return(0);
X}
X
Xint h_rebuild_option(opt, arg)
X     /*ARGSUSED*/
X     char *opt;
X     char *arg;
X{
Xchar *p;
Xchar fname[MAXNAMLEN];
X(void) strcpy(fname,arg);
X
Xif((p = rindex(fname,'.')) == NIL)
X  {
X    (void) strcpy(rbrule,"@");
X    (void) strcat(rbrule,fname);
X    (void) strcpy(rbtarg,fname);
X    (void) strcat(fname,".cid");
X    (void) strcpy(rbfile,fname);
X  }
Xelse
X  {
X    (void) strcpy(rbfile,fname);
X    *p = '\0';
X    (void) strcpy(rbtarg,fname);
X    (void) strcpy(rbrule,"@");
X    (void) strcat(rbrule,fname);
X  }
X
Xrebuildflg = TRUE;
X
Xreturn(0);
X
X}
END_OF_FILE
if test 10193 -ne `wc -c <'src/shape/shapeopt.c'`; then
    echo shar: \"'src/shape/shapeopt.c'\" unpacked with wrong size!
fi
# end of 'src/shape/shapeopt.c'
fi
echo shar: End of archive 13 \(of 33\).
cp /dev/null ark13isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
