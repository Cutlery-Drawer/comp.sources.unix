Subject:  v19i022:  A software configuration management system, Part09/33
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Axel Mahler <unido!coma!axel>
Posting-number: Volume 19, Issue 22
Archive-name: shape/part09



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 9 (of 33)."
# Contents:  man/man1/save.1 src/inc/afs.h src/shape/inherit.c
#   src/shape/main.c src/shape/shape.l src/shape/varsec.c
# Wrapped by rsalz@papaya.bbn.com on Thu Jun  1 19:26:57 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'man/man1/save.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/man1/save.1'\"
else
echo shar: Extracting \"'man/man1/save.1'\" \(7936 characters\)
sed "s/^X//" >'man/man1/save.1' <<'END_OF_FILE'
X...
X... Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X...  and U. Pralle
X... 
X... This software is published on an as-is basis. There is ABSOLUTELY NO
X... WARRANTY for any part of this software to work correctly or as described
X... in the manuals. We do not accept any liability for any kind of damage
X... caused by use of this software, such as loss of data, time, money, or 
X... effort.
X... 
X... Permission is granted to use, copy, modify, or distribute any part of
X... this software as long as this is done without asking for charge, and
X... provided that this copyright notice is retained as part of the source
X... files. You may charge a distribution fee for the physical act of
X... transferring a copy, and you may at your option offer warranty
X... protection in exchange for a fee.
X... 
X... Direct questions to: Tech. Univ. Berlin
X... 		     Wilfried Koch
X... 		     Sekr. FR 5-6 
X... 		     Franklinstr. 28/29
X... 		     D-1000 Berlin 10, West Germany
X... 
X... 		     Tel: +49-30-314-22972
X... 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X... 
X...
X... $Header: save.1[3.1] Thu Feb 23 18:13:51 1989 axel@coma published $
X... 
X... Log for /u/shape/dist-tape/src/vc/save.1[3.0]
X... 	Thu Feb 23 18:13:51 1989 axel@coma published $
X...  --- empty log message ---
X...  save.1[3.1] Thu Feb 23 18:13:51 1989 axel@coma published $
X...  --- empty log message ---
X...
X.TH SAVE 1 save \n(dy.\n(mo.\n(yr
X.SH NAME
Xsave \- save revision of a file
X.SH SYNOPSIS
X.IP \fBsave\fR \w'\fBSave++\fR'u
X[\ \fIoptions\fR\ ]\ files \.\|.
X.IP \fBSave\fR
X[\ \fIoptions\fR\ ]\ files \.\|.
X.IP \fBsbmt\fR
X[\ \fIoptions\fR\ ]\ files \.\|.
X.IP \fIOptions:\fR \w'\fIOptions:++\fR'u
X[\ \fB\-fhqu\fR\ ]\ [\ \fB\-a\ \fIafile\fR\ ] [\ \fB\-m\ \fImessage\fR\ ]
X[\ \fB\-n\ \fIname\fR\ ] [\ \fB\-p\ \fIprojectname\fR\ ] 
X.br
X[\ \fB\-setvnum\ \fIversion\fR\ ]
X[\ \fB\-t\ \fItextfile\fR\ ]\ [\ \fB\-unlock\fR\ ]\ [\ \fB\-version\fR\ ]
X.SH DESCRIPTION
X.PP
X\fISave\fR stores the current state of the specified files into 
Xarchive files and
Xassigns a unique \fIversion number\fR to the saved version. Versions
Xin archives are inalterable.
XAn archive will be created
Xin a subdirectory named \fIAFS\fR the first time a file saved.
XThe AFS subdirectory must be present.
XWhen an archive is created, save asks for the purpose
Xof the saved document. If a subsequent version is saved, the user
Xis prompted for a comment concerning the modifications.
XThe \fBsave\fR command requires that the object history corresponding
Xto the file to be saved is either \fIlocked\fR by the user
Xissuing the command or not locked at all.
XBefore a file is saved it will be checked whether it has actually 
Xchanged. If the file hasn't changed, the user will be asked if it
Xshould be saved anyway. The command line option \fB\-f\fR overrides the query.
XA newly created object version in the archive will be assigned the
Xstate \fIsaved\fR. This status marks the lowest level of quality,
Xsuggesting that the version is just saved for possible later retrieval 
Xbut may be inconsistent. Versions that meet higher quality standards
X(or are part of a release) should be marked by appropriate status
X(see \fBvadm\fR \-promote\fR or \fBsbmt\fR).
X.PP
XIf the program is invoked as \fBSave\fR (that is with capital-S) 
Xa \fInew generation\fR of the document history is initiated \-
Xprovided the programmer issuing the command has the permission to do this.
X.PP
XIf the program is invoked as \fBsbmt\fR, a newly created version
Xwill be set to status \fIpublished\fR. If the file to be saved
Xis unchanged with respect to the last saved version, the status
Xof the last saved version will be promoted to \fIpublished\fR.
X.LP
XIn complete detail, \fBsave\fR can be invoked with the following options:
X.IP \fB\-f\fR \w'\fB\-p\ \fIproject++\fR'u
Xforces a revision deposit (i.e. without asking), even if the busy
Xversion hasn't changed since the last time it was saved.
X.IP \fB\-h\fR
Xprint short information about usage of this command.
X.IP \fB\-q\fR
Xquiet operation. No messages are printed on standard output. 
XIf the busy version is unchanged, it will not be saved unless
X\fB\-f\fR is set. The user will not be prompted for a descriptive
Xnote. If no message or note is supplied with the command line 
X(see options \fB\-m\fR and \fB\-t\fR) the log
Xwill remain empty. This option is useful for batch operation.
X.IP \fB\-u\fR
Xunlock object history upon save. This option is identical to 
X\fB\-unlock\fR (see below).
X.IP \fB\-a\ \fIafile\fR
Xassign all the attributes specified in \fIafile\fR to the evolving
Xnew versions. Attributes must be given in the form \fIname=value\fR
Xwith one attribute specification per line and no white-space.
XWhile the attribute value is optional, the \fIequal\fR symbol must
Xbe present. If the \fB\-a\fR option is omitted, \fBsave\fR searches
Xthe environment for a variable \fISVATTRS\fR. If this variable
Xis absent, no user defined attributes will be assigned to the evolving
Xversions.
X.IP \fB\-m\ \fImessage\fR
Xsets \fImessage\fR as descriptive note for all document versions 
Xthat result from the invocation of \fBsave\fR. This option is alternative
Xto \fB\-t\fR which overrides \fB\-m\fR.
X.IP \fB\-n\ \fIname\fR
Xassigns a symbolic name \fIname\fR to the saved version. In more detail,
Xan attribute \fISYMNAME\fR is set to the value specified in \fIname\fR.
XThe specified symbolic name must not be assigned to any other version
Xwithin the same object history.
X.IP \fB\-p\ \fIproject\fR
Xspecifies the name of a project to provide a \fIproject context\fR
Xin which the save operation takes place. This project context may 
Xdetermine a number of addtional parameters that affect the overall
Xbehaviour of the save command. Such parameters might be
Xa set of standard attributes that are to be assigned to evolving versions
Xcertain permissions or some general project policy.
X.br
X\fHUNIMPLEMENTED FEATURE.\fR
X.IP \fB\-setvnum\ \fI<version>\fR
Xsets the version number of the newly created revision to \fIversion\fR.
XThe \fIversion\fR must be given in the format \fI<generation>.<revision>\fR
Xwhere \fIgeneration\fR and \fIrevision\fR are integers. Example:
X.RS
X.DS
X\fCsave -setvnum 4.3 mkattr.c\fR
X.DE
XThe specified \fIversion\fR must be greater than the highest previously
Xassigned version number in a given object history. \fB\-setvnum\fR
Xis useful for keeping consistent version numbering across related, physically
Xdifferent object bases, or for converting archive formats of other
Xrevision control systems to this toolkit (see: \fBrcs2afs\fR).
X.RE
X.IP \fB\-t\ \fIfile\fR
Xsets the text contained in \fIfile\fR as descriptive note for all document
Xversions that result from the invocation of \fBsave\fR. This option is
Xalternative to \fB\-m\fR which is superseded by \fB\-t\fR.
X.IP \fB\-unlock\fR
Xgives up the lock for the object history into which the new revision
Xof a file is saved. Upon unlocking the history, the user is prompted 
Xfor a description of the applied changes with the original \fIchange 
Xintent\fR (see \fBretrv \-lock\fR and \fBvadm -lock\fR) as initial
Xcomment. This comment might be edited appropriately. The change intention
Xis cleared afterwards.
X.IP \fB\-version\fR
Xprints the version of the program itself.
X.SH FILES
XAll revisions of documents are stored in archive files in the subdirectory
XAFS.
X.SH SEE ALSO
Xretrv(1), rsrv(1), sbmt(1), shape(1), vadm(1), vl(1), 
Xaf_intro(3), af_archive(5)
X.SH BUGS
XProject support is unimplemented.
X.PP
XSupport of user-defined attributes is rudimentary. Specification of such
Xattributes must be syntactically correct.
X.PP
X\fBsave\fR neither reads the \fIShapefile\fR nor the \fIMakefile\fR and
Xconsequently sticks with the 'individual document level' rather than to
Xsupport the saving of entire systems or subsystems (higer level targets
Xin \fI{Shape,Make}file\fRs).
X.SH AUTHOR
XAxel Mahler
X.br
XTechnical University Berlin
X.sp
X\fIUUCP:\fR		axel@coma.uucp (unido!coma!axel)
X.br
X\fIBITNET:\fR	axel@db0tui62
END_OF_FILE
if test 7936 -ne `wc -c <'man/man1/save.1'`; then
    echo shar: \"'man/man1/save.1'\" unpacked with wrong size!
fi
# end of 'man/man1/save.1'
fi
if test -f 'src/inc/afs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/inc/afs.h'\"
else
echo shar: Extracting \"'src/inc/afs.h'\" \(8320 characters\)
sed "s/^X//" >'src/inc/afs.h' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X/*
X *	Shape/AFS
X *
X *	afs.h - Type and Constant-Definitions for the 
X *		Attribute-Filesystem
X *
X *	Author:	Andreas Lampen (andy@coma.UUCP
X *				andy@db0tui62.BITNET)
X *
X *	$Header: afs.h[1.4] Wed Feb 22 16:29:43 1989 andy@coma published $
X */
X
X#ifndef _AFSHDR_
X#define _AFSHDR_
X
X/*=========================================================================
X * Installation dependent constants 
X *=========================================================================*/
X
X#include <stdio.h>
X#include <sys/types.h>
X#ifndef MAXNAMLEN
X#include <sys/dir.h>
X#endif
X#include <sys/param.h>
X
X#define MAXTYPLEN      256
X#define MAXVARLEN      256
X#define MAXUSERNAMELEN 64
X
X/*=========================================================================
X * External Type Definitions
X *=========================================================================*/
X
X#include "afsys.h"
X
X/**** filekey ****/
Xtypedef struct {
X		Af_revlist *af_ldes;		/* ptr to revlist descriptor */
X		int        af_lpos;             /* position in revlist */
X	       } Af_key;
X
X/**** Set descriptor ****/
Xtypedef struct {
X		int	af_nkeys;
X		int	af_setlen;
X		Af_key	*af_klist;
X	       } Af_set;
X
X/**** User Identification ****/
Xtypedef struct {
X                char	af_username[MAXUSERNAMELEN];
X		char	af_userhost[MAXHOSTNAMELEN];
X	       } Af_user;
X
X/**** Attribute buffer ****/
Xtypedef struct {
X		char	af_host[MAXHOSTNAMELEN]; /* hostname */
X		char	af_syspath[MAXNAMLEN+1]; /* system path */
X		char	af_name[MAXNAMLEN+1];	/* filename */
X		char	af_type[MAXTYPLEN];	/* filename extension (type) */
X		int	af_gen;			/* generation number */
X		int	af_rev;			/* revision number */
X		char    af_variant[MAXVARLEN];  /* variant attribute */
X		int	af_state;		/* version state (see below) */
X		Af_user af_owner;		/* owner */
X		Af_user af_author;		/* author */
X		off_t   af_size;                /* size of file */
X		u_short af_mode;		/* protection (from inode) */
X		Af_user af_locker;              /* locker */
X		time_t	af_mtime;		/* date of last modification */
X		time_t	af_atime;		/* date of last access */
X		time_t	af_ctime;		/* date of last status change*/
X		time_t	af_stime;		/* save date */
X		time_t  af_ltime;               /* date of last lock change */
X		char	*af_udattrs[AF_MAXUDAS]; /* user def. attributes */
X	       } Af_attrs;
X
X/*=========================================================================
X * Constant Definitions
X *=========================================================================*/
X
X/**** Version states ****/
X
X#define AF_NOSTATE     -1
X#define	AF_BUSY		0
X#define AF_SAVED	1
X#define AF_PROPOSED	2
X#define AF_PUBLISHED	3
X#define AF_ACCESSED	4
X#define AF_FROZEN	5
X
X/**** Settings for Attrbuf ****/
X
X#define AF_NONAME       "\0"
X#define AF_NOTYPE       "\0"
X#define AF_NOVNUM	-1
X#define AF_NOSIZE	-1
X#define AF_NOMODE	0
X#define AF_NOTIME       -1
X
X/**** Modes ****/
X
X#define AF_ADD          1   /* user-defined attributes */
X#define AF_REMOVE       2   /* " */
X#define AF_REPLACE      3   /* " */
X
X#define AF_BUSYVERS     -2   /* version identification */
X#define AF_FIRSTVERS    -3   /* " */
X#define AF_LASTVERS     -4   /* " */
X
X#define AF_LASTPOS      -4   /* set position */
X
X/**** Object classes ****/
X
X#define AF_SOURCE       00
X#define AF_DERIVED      01
X#define AF_VALID        02
X
X/**** Locking Modes ****/
X
X#define AF_VERSIONLOCK   0
X#define AF_GLOBALLOCK    1
X
X/*=========================================================================
X * Attribute names
X *=========================================================================*/
X
X#define AF_UDANAMLEN    128       /* maximum length of uda name */
X#define AF_ATTNUM       20        /* number of attrributes in attrbuf */
X
X#define AF_ATTHOST	"af_host"
X#define AF_ATTSPATH	"af_syspath"
X#define AF_ATTNAME      "af_name"
X#define AF_ATTTYPE      "af_type"
X#define AF_ATTGEN	"af_gen"
X#define AF_ATTREV	"af_rev"
X#define AF_ATTVARIANT   "af_variant"
X#define AF_ATTVERSION	"af_version" /* compound attribute: gen.rev */
X#define AF_ATTHUMAN     "af_human"   /* compound name,type,gen,rev,variant */
X#define AF_ATTSTATE	"af_state"
X#define AF_ATTOWNER	"af_owner"
X#define AF_ATTAUTHOR	"af_author"
X#define AF_ATTSIZE      "af_size"
X#define AF_ATTMODE      "af_mode"
X#define AF_ATTLOCKER    "af_locker"
X#define AF_ATTMTIME	"af_mtime"
X#define AF_ATTATIME	"af_atime"
X#define AF_ATTCTIME	"af_ctime"
X#define AF_ATTSTIME	"af_stime"
X#define AF_ATTLTIME	"af_ltime"
X
X
X
X/*=========================================================================
X * Errorcodes
X *=========================================================================*/
X
X/* General */
X#define AF_OK		 0
X
X#define AF_ESYSERR	 -2	/* Error during execution of Syslib-command */
X#define AF_EACCES        -3     /* permission denied */
X#define AF_EARCHANGED    -4     /* archive has changed since last read */
X#define AF_EARLOCKED     -5     /* archive is locked for writing */
X#define AF_EBPFULL       -6     /* no additional place in binary pool */
X#define AF_EBUSY         -7     /* spec. revision must not be a busy version */
X#define AF_EDERIVED      -8     /* spec. revision is a derived object */
X#define AF_EFORMAT       -9     /* illegal format of var or uda string */
X#define AF_EINVKEY 	-10	/* invalid key */
X#define AF_EINVSET	-11 	/* invalid set */
X#define AF_EINVUSER     -12     /* invalid user */
X#define AF_EINVVNUM     -13     /* bad version number */
X#define AF_ELOC		-14	/* invalid location of archive */
X#define AF_EMISC        -15     /* miscellaneous errors */
X#define AF_EMODE        -16     /* invalid mode */
X#define AF_ENOAFSDIR    -17     /* no AFS subdirectory */
X#define AF_ENOKEY       -18     /* key does not exist in set */
X#define AF_ENOPOS       -19     /* invalid position in set */
X#define AF_ENOREV       -20     /* specified revision does not exist */
X#define AF_ENOTBUSY     -21     /* specified object is no busy version */
X#define AF_ENOTDERIVED  -22     /* specified object is no derived object */
X#define AF_ENOTLOCKED   -23     /* version is not locked or - by another user*/
X#define AF_ENOTREGULAR  -24     /* specified object is no regular file */
X#define AF_ENOTVERS     -25     /* specified object has no versions */
X#define AF_ENOUDA       -26     /* user defined attribute does not exist */
X#define AF_ESAVED       -27     /* saved versions cannot be modified */
X#define AF_ESTATE	-28	/* invalid state transition */
X#define AF_ETOOLONG     -29     /* string too long */
X#define AF_EUDASNUM     -30     /* too many user defined attributes */
X#define AF_EWRONGSTATE  -31     /* wrong state */
X
X/* codes for really serious errors */
X#define AF_EDELTA       -32     /* error during delta operation */
X#define AF_EINCONSIST	-33	/* Archive file inconsistent */
X#define AF_EINTERNAL	-34	/* internal error */
X#define AF_ENOAFSFILE   -35     /* no AFS file */
X
X/*=========================================================================
X * Declarations
X *=========================================================================*/
X
Xchar *af_afname(), *af_afpath(), *af_aftype(), *af_rvariant();
Xchar *af_rname(), *af_rsyspath(), *af_rtype(), *af_rnote(), *af_rudattr();
XFILE *af_open();
XAf_user *af_lock(), *af_unlock(), *af_testlock(), *af_rowner(), *af_rauthor();
XAf_user *af_getuser();
Xvoid af_perror();
X
X#endif /* __AFSHDR__ */
X
END_OF_FILE
if test 8320 -ne `wc -c <'src/inc/afs.h'`; then
    echo shar: \"'src/inc/afs.h'\" unpacked with wrong size!
fi
# end of 'src/inc/afs.h'
fi
if test -f 'src/shape/inherit.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/shape/inherit.c'\"
else
echo shar: Extracting \"'src/shape/inherit.c'\" \(8336 characters\)
sed "s/^X//" >'src/shape/inherit.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *RCSid = "$Header: inherit.c,v 3.2 89/02/15 16:24:39 wolfgang Exp $";
X#endif
X#ifndef lint
Xstatic char *ConfFlg = CFFLGS;	/* should be defined from within Makefile */
X#endif
X/*
X * $Log:	inherit.c,v $
X * Revision 3.2  89/02/15  16:24:39  wolfgang
X * bug fixed.
X * 
X * Revision 3.1  89/02/06  14:25:20  wolfgang
X * calls of forbidden() cahnged
X * 
X * Revision 3.0  89/01/24  11:35:46  wolfgang
X * New System Generation
X * 
X * Revision 1.15  89/01/03  13:10:48  wolfgang
X * changes done for lint
X * 
X * Revision 1.14  88/12/22  13:23:16  wolfgang
X * minor bug fixed.
X * 
X * Revision 1.13  88/12/21  15:03:29  wolfgang
X * changes done for lint
X * 
X * Revision 1.12  88/12/19  13:22:59  wolfgang
X * forbidden() & finddep() added.
X * 
X * Revision 1.9  88/11/21  15:51:01  wolfgang
X * return code of all malloc's checked
X * 
X * Revision 1.8  88/11/09  16:26:30  wolfgang
X * bug fixed in comapare_attrstring(). dropset was located wrong
X * 
X * Revision 1.7  88/11/08  19:28:33  wolfgang
X * expandall or expandnothing added to ATTR-string
X * 
X * Revision 1.6  88/11/08  18:07:07  wolfgang
X * inheritance changed: attributes should now be correct.
X * 
X * Revision 1.5  88/11/04  16:43:50  wolfgang
X * This version is part of a release
X * 
X * Revision 1.4  88/09/20  10:03:54  wolfgang
X * bug fixed. concatenation of vflags was not correct.
X * 
X * Revision 1.3  88/08/18  10:25:49  wolfgang
X * This version is part of a release
X * 
X * Revision 1.2  88/08/12  08:58:09  wolfgang
X * This version is part of a release
X * 
X */
X
X#include "shape.h"
X
Xextern char *expandmacro();
Xextern char *build_attrstring();
Xextern int error();
Xextern void warning();
Xextern Af_attrs buft;
Xextern char *longattrs[];
Xextern int depth;
Xextern Bool error_occ;
Xextern Bool finddep();
Xextern Bool forbidden();
Xextern struct rules *get_target();
X
Xsave_targets(rulename, srcname, objrulename,attrstr)
X     struct rules *rulename;
X     char *srcname;
X     struct rules *objrulename;
X     char *attrstr;
X{
X  Af_key busykey, savekey;
X  char *syspath;
X  char *name;
X  char *type;
X  int gen = AF_BUSYVERS;
X  int rev = AF_BUSYVERS;
X  char attr[MAXATTRLENGTH];
X  char *p;
X  int retcode;
X  char savepath[MAXNAMLEN];
X
X#ifdef NOBPOOL
X  return;
X#endif NOBPOOL
X
X  if(error_occ)
X    {
X      error_occ = FALSE;
X      return;
X    }
X
X  if(noexflg)
X    return;
X
X  if ((rindex(srcname,'/')) != NIL)
X    {
X      (void) strcpy(savepath,srcname);
X      p = rindex(savepath,'/');
X      *p = '\0';
X      p++;
X      srcname = p;
X      syspath = &savepath[0];
X    }
X  else
X    syspath = curvpath[0];
X
X  if(objrulename != (struct rules *) NIL)
X    {
X      if((name = malloc((unsigned) (strlen(objrulename->name) + 1))) == NIL)
X	errexit(10,"malloc");
X      (void) strcpy(name, objrulename->name);
X    }
X  else
X    {
X      if((name = malloc((unsigned) (strlen(srcname) + 1))) == NIL)
X	 errexit(10,"malloc");
X      (void) strcpy(name,srcname);
X    }
X
X  if (rulename->name[0] == '%')
X    {
X      if((p = rindex(name,'.')) != NIL)
X	{
X	  *p = '\0';
X	  (void) strcat(name, rulename->name+1);
X	}
X    }
X
X  if ((p = rindex(name,'.')) != NIL)
X    {
X      *p = '\0';
X      type = p+1;
X    }
X  else
X    type = NIL;
X
X
X  if ((af_getkey(syspath,name,type,gen,rev,NIL,&busykey)) == -1)
X    errexit(10, "af_getkey");
X
X  af_errno = 0; /* sollte nocht sein */
X
X  retcode = af_sudattr(&busykey,AF_REMOVE,ATTRNAME);
X
X  if ((retcode == -1) && (af_errno == AF_ENOAFSDIR))
X    {
X      af_initattrs(&buft);
X      af_dropkey(&busykey);
X      return;
X    }
X  
X  if ((retcode == -1) && (af_errno != AF_ENOUDA) &&
X      (af_errno != AF_ENOAFSDIR))
X    errexit(10,"af_sudattr");
X
X  if ((bpoolflg) || (nobpoolflg))
X    {
X      if(!forbidden(syspath,name,type))
X	{
X	  if ((af_savebinary(&busykey,&savekey)) == -1)
X	    {
X	      if(af_errno == AF_ENOAFSDIR)
X		warning(1,NIL);
X	      else
X		errexit(10, "af_savebinary");
X	    }
X	}
X    }
X
X  if(attrstr[0] == '\0')
X    (void) strcpy(attr,build_attrstring(rulename,srcname,objrulename));
X  else
X    (void) strcpy(attr,attrstr);
X
X  if ((bpoolflg) || (nobpoolflg))
X    {
X      if(!forbidden(syspath,name,type))
X	{
X	  retcode = af_sudattr(&savekey,AF_REPLACE,attr);
X	  if (retcode == -1)
X	    {
X	      retcode = af_sudattr(&savekey,AF_ADD,attr);
X	      if ((retcode == -1) && (af_errno != AF_ETOOLONG) &&
X		  (af_errno != AF_ENOAFSDIR))
X		errexit(10,"af_sudattr");
X	      if (af_errno == AF_ETOOLONG)
X		{
X		  retcode = af_errno;
X		  /* attrs are too long */
X		  if ((af_rm(&savekey)) == -1)
X		    errexit(10,"af_rm");
X		}
X	    }
X	  if (retcode != AF_ETOOLONG)
X	    {
X	      if (buft.af_gen != -1)
X		{
X		  if ((af_svnum(&savekey,buft.af_gen,buft.af_rev)) == -1)
X		    errexit(10,"af_svnum");
X		}
X	      else
X		{
X		  if ((af_svnum(&savekey,AF_BUSYVERS,AF_BUSYVERS)) == -1)
X		    errexit(10,"af_svnum");
X		}
X	    }
X	  af_dropkey(&savekey);
X	}
X    }
X
X  if ((af_sudattr(&busykey,AF_REPLACE,attr)) == -1)
X    {
X      if ((af_sudattr(&busykey,AF_ADD,attr)) == -1)
X	errexit(10,"af_sudattr");
X    }
X  af_initattrs(&buft);
X}
X 
X
Xchar *build_attrstring(rulename,srcname,objrulename)
X     struct rules *rulename;
X     /*ARGSUSED*/
X     char *srcname;
X     struct rules *objrulename;
X
X{
X  char attr[MAXATTRLENGTH];
X  int i = 0;
X  char *p;
X
X  attr[0] = '\0';
X  (void) strcpy(attr,ATTRNAME);
X  
X  if(expflg)
X    (void) strcat(attr,"expandall");
X  if(noexpflg)
X    (void) strcat(attr,"expandnothing");
X
X  for( i = 0; rulename->targetlist[i] != NIL; i++)
X    {
X      (void) strcat(attr,rulename->targetlist[i] + 1);
X    }
X  for(i = 0; rulename->heritage[i] != NIL; i++)
X    {
X      (void) strcat(attr, rulename->heritage[i]);
X      (void) strcat(attr,"=");
X      (void) strcat(attr,rulename->heritage[i]);
X      p = rindex(attr,'+');
X      *p = '$';
X      (void) strcpy(attr,expandmacro(attr));
X    }
X
X/*  if (buft.af_gen != -1)
X    {
X       (void) sprintf(attr,"%sversion=%d.%d",attr,buft.af_gen,buft.af_rev);
X    }
X    else
X    (void) sprintf(attr,"%sversion=%d.%d",attr,AF_BUSYVERS,AF_BUSYVERS); */
X  (void) strcat(attr, longattrs[depth]);
X  (void) strcpy(longattrs[depth],attr);
X  return(attr);
X}
X
X
XBool forbidden(syspath,name,type)
X     char *syspath;
X     char *name;
X     char *type;
X{
X  char fullname[MAXNAMLEN];
X  Bool bp = FALSE;
X  Bool nobp = FALSE;
X  struct rules *bpool;
X  struct rules *nobpool;
X  
X  fullname[0] = '\0';
X  if (strcmp(syspath,curvpath[0]))
X    {
X      (void) strcpy(fullname,syspath);
X      (void) strcat(fullname,"/");
X      (void) strcat(fullname,name);
X    }
X  else
X    {
X      (void) strcpy(fullname,name);
X    }
X
X  if (type != NIL)
X    {
X      (void) strcat(fullname,".");
X      (void) strcat(fullname,type);
X    }
X
X  bpool = get_target(".BPOOL");
X  nobpool = get_target(".NOBPOOL");
X
X  if (bpool != (struct rules *) NIL)
X    {
X      bp = finddep(bpool,fullname);
X    }
X  else
X    bp = TRUE;
X  
X  if (nobpool != (struct rules *) NIL)
X    {
X      nobp = finddep(nobpool,fullname);
X    }
X
X  if (bp && nobp)
X    return(TRUE);
X
X  if (bp && (!nobp))
X    return(FALSE);
X
X  if ((!bp) && nobp)
X    return(TRUE);
X  
X  if ((!bp) && (!nobp))
X    return(TRUE);
X/*NOTREACHED*/
Xreturn(FALSE);
X}
X
XBool finddep(rule,name)
X     struct rules *rule;
X     char *name;
X{
X  int i = 0;
X  while(rule->deplist[i] != NIL)
X    {
X      if (!strcmp(rule->deplist[i],name))
X	return(TRUE);
X      i++;
X    }
X  return(FALSE);
X}
END_OF_FILE
if test 8336 -ne `wc -c <'src/shape/inherit.c'`; then
    echo shar: \"'src/shape/inherit.c'\" unpacked with wrong size!
fi
# end of 'src/shape/inherit.c'
fi
if test -f 'src/shape/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/shape/main.c'\"
else
echo shar: Extracting \"'src/shape/main.c'\" \(8311 characters\)
sed "s/^X//" >'src/shape/main.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *RCSid = "$Header: main.c,v 3.1 89/02/20 16:25:58 wolfgang Exp $";
X#endif
X#ifndef lint
Xstatic char *ConfFlg = CFFLGS;	/* should be defined from within Makefile */
X#endif
X/*
X * $Log:	main.c,v $
X * Revision 3.1  89/02/20  16:25:58  wolfgang
X * NET-RELEASE
X * 
X * Revision 3.0  89/01/24  11:36:03  wolfgang
X * New System Generation
X * 
X * Revision 2.16  89/01/18  13:42:29  wolfgang
X * call of init_selruletab() added.
X * 
X * Revision 2.15  89/01/03  13:11:31  wolfgang
X * changes done for lint
X * 
X * Revision 2.14  88/12/22  13:22:33  wolfgang
X * initializarion of bpoolflg added.
X * 
X * Revision 2.13  88/12/21  15:10:52  wolfgang
X * changes done for lint
X * 
X * Revision 2.12  88/11/22  17:37:23  wolfgang
X * This version is part of a release
X * 
X * Revision 2.11  88/11/21  15:50:36  wolfgang
X * return code of all malloc's checked
X * 
X * Revision 2.10  88/10/10  14:16:58  wolfgang
X * feature for -p option added.
X * 
X * Revision 2.9  88/09/22  16:16:24  wolfgang
X * call of cleanup_links changed. call of shape_cleanup added.
X * 
X * Revision 2.8  88/09/22  10:02:17  wolfgang
X * declaration of ruleset changed.
X * 
X * Revision 2.7  88/09/07  11:21:13  wolfgang
X * changes for include mechanism: now a tmp file is produced which
X * contains all input files for shape.
X * 
X * Revision 2.6  88/08/25  15:17:19  wolfgang
X * stdmacros changed: the macros for sccs replaced by two macros
X * for shape: SHAPEFLAGS & SHAPE.
X * 
X * Revision 2.5  88/08/23  16:38:06  wolfgang
X * Rebuild feature added (to rebuild something from a confid).
X * 
X * Revision 2.4  88/08/23  10:24:28  wolfgang
X * Changed ruledump() to ruledump(fd) to be able to use it for
X * generating confid's.
X * 
X * Revision 2.3  88/08/22  17:02:12  wolfgang
X * dump() changed to dump(fd).
X * finis_confid added.
X * 
X * Revision 2.2  88/08/22  10:12:15  wolfgang
X * Changed main.c, so that it is no longer necessary to have a description
X * file. It's enaugh to have the name of a target to produce on the command
X * line
X * 
X * Revision 2.1  88/08/19  10:17:37  wolfgang
X * This version is part of a release
X * 
X */
X
X#include "shape.h"
X#include "ParseArgs.h"
X
X#include <stdio.h>
X
X#define MAXCMDTARGETS 32
X
Xextern char *getwd();
Xextern char *mktemp();
X
Xextern int hashval();
Xextern void addhash();
Xextern int adjust_stdrules();
Xextern int dump();
Xextern int ruleend();
Xextern int ruledump();
Xextern int errexit();
Xextern int init_ruletab();
Xextern int init_selruletab();
Xextern int seldump();
Xextern int selruledef();
Xextern int stdrules();
Xextern Bool is_selrule_name();
Xextern int catch_sigs();
X
Xextern int yylex();
Xextern FILE *yyin;
Xextern FILE *vmfopen();
X
Xextern int cleanup_links();
Xextern int af_cleanup();
X
Xextern struct linkreg *link_reg;
X
Xextern char *firsttarget;
Xextern char ruleset[];
Xextern char *stdsuff;
X
Xextern struct selection_rules *currule;
Xextern char *busy_rule;
Xextern char *longattrs[];
Xextern char *template;
Xextern FILE *temp;
Xchar rbfile[MAXNAMLEN];
X
Xchar *filenames[] = {"Shapefile", "shapefile", "Makefile", "makefile"};
X
X#define STDMACROS 29
X
Xchar *stdmacros[] = { "SHAPEFLAGS=","SHAPE=shape","ASFLAGS=","AS=as",
X			"RFLAGS=","FFLAGS=","FC=f77","M2FLAGS=",
X			"M2C=m2c","PFLAGS=","PC=pc","CFLAGS=",
X			"CC=cc","LDFLAGS=","LD=ld","LFLAGS=",
X			"LEX=lex","YFLAGS=","YACC=yacc","MAKE=make",
X			"$=$$","MFLAGS=-b","MAKEFLAGS=b",
X		        "@=$@", "?=$?", "<=$<", "*=$*",
X			"+=$+"};
X
Xstruct linked_list *shapefiles = (struct linked_list *) NIL;
X     /* list of names of files from
X	command line via the -f option */
Xstruct linked_list *shfiles;
X
Xchar *cmdtargets[MAXCMDTARGETS];
X     /* list of target form the	command line */
X
X
XBool synterrflg = FALSE;
XBool Oldsuffs = FALSE;
XBool Newsuffs = FALSE;
Xchar *suffs;
X#ifdef MEMDEBUG
XFILE *memprot;
X#endif
X
Xmain(argc, argv)
X     int argc;
X     char **argv;
X     
X{
Xint newac = 0;
Xchar **newav;
X
Xint i;
Xint k = 0;
Xint gen = AF_BUSYVERS;
Xint rev = AF_BUSYVERS;
Xchar macrostr[2048];
Xextern OptDesc odesc[];
X
X#ifdef MEMDEBUG
Xmemprot = fopen ("memprot", "w");
X#endif
X
Xrebuildflg = FALSE;
Xbpoolflg = TRUE;
X
Xcatch_sigs(); 
X
Xif (argc != 1)
X  {
X    if(ParseArgs (argc, argv, &newac, &newav, odesc))
X      {
X	pa_ShortUsage(argv[0], odesc, "\n\t      rtfm! (read the manual)");
X	exit(1);
X      }
X  }
X
Xif ((curvpath[0] = malloc(MAXNAMLEN)) == NIL)
X  errexit(10,"malloc");
X(void) getwd(curvpath[0]);
Xinit_ruletab();
Xinit_selruletab();
X(void) mktemp(template);
Xtemp = fopen(template,"w");
Xif(logflg)
X  {
X    logfd = fopen("SHAPE.LOGFILE","a");
X    for (i = 0; i<argc; i++)
X      fprintf(logfd,"%s ", argv[i]);
X    fprintf(logfd,"\n");
X    (void) fclose(logfd);
X  }
X
Xfor(i = 0; i < newac; i++)
X  {
X    if (index(newav[i],'=') != NIL)
X      {
X	(void) strcpy(macrostr,newav[i]);
X	macrodef(macrostr);
X      }
X  }
X
Xfor (i = 0; i < STDMACROS; i++)
X     macrodef(stdmacros[i]);
X
X
Xif  (!rebuildflg)
X  {
X
X    if (fileflg)
X      {
X	shfiles = shapefiles;
X	while(shfiles != (struct linked_list *) NIL)
X	  {
X	    if ((yyin = vmfopen(shfiles->string,"r", gen, rev)) == (FILE *)NIL)
X	      errexit(12,shfiles->string);
X	    else
X	      {
X		get_macros(yyin);
X		(void) fclose(yyin);
X	      }
X	    shfiles = shfiles->nextstring;
X	  }
X	if (stdinflg == TRUE)
X	  get_macros(stdin);
X      }
X    else
X      {
X	for ( i = 0; i <= 3; i++)
X	  {
X	    if ((yyin = vmfopen (filenames[i], "r", gen, rev)) != (FILE *)NIL) 
X	      break;
X	  }
X	if (yyin == (FILE *)NIL)
X	  nostdfile = TRUE;
X	else
X	  {
X	    nostdfile = FALSE;
X	    get_macros(yyin);
X	    (void) fclose(yyin);
X	  }
X      }
X  }
X
Xelse
X  {
X    if(( yyin = vmfopen(rbfile, "r", gen, rev)) == (FILE *) NIL)
X      errexit(12, rbfile);
X    get_macros(yyin);
X    (void) fclose(yyin);
X  }
X
X(void) fclose(temp);
X
Xfor(i = 0; i < newac; i++)
X  {
X    if (index(newav[i],'=') != NIL)
X      macrodef(newav[i]);
X    else
X      {
X	if ((cmdtargets[k] = malloc((unsigned) (strlen(newav[i]) + sizeof(char)))) == NIL)
X	  errexit(10,"malloc");
X	(void) strcpy(cmdtargets[k++],newav[i]);
X	cmdtargets[k] = NIL;
X      }
X  }
X
Xadd_stdrules();
Xfirsttarget = NIL;
X
Xif ((yyin = fopen(template,"r")) == (FILE *)NIL)
X  errexit(12,template);
Xelse
X  {
X    (void) unlink(template);
X    (void) yylex();
X    (void) fclose(yyin);
X  }
X
X
Xif (synterrflg == TRUE)
X  errexit(15,NIL);
X
Xruleend(); /* just for security ????  */
X
Xadjust_stdrules(suffs);
X
X/* add busy rule */
X
Xselruledef(busy_rule);
X(void) is_selrule_name("-STD-");
X
Xinitattrfield();
X
Xproduce();
X/*
X#ifdef DEBUG_HASH
Xdump();
X#endif DEBUG_HASH
X#ifdef DEBUG_RULE
Xruledump(stdout);
X#endif DEBUG_RULE
X#ifdef DEBUG_SELRULE
Xseldump();
X#endif DEBUG_SELRULE */
X(void) fclose(yyin);
Xif (confid)
X  {
X    finish_confid();
X    af_close(cid);
X  }
Xif (debugflg)
X  {
X    if (suffs_deleted)
X      printf("no suffix list");
X    dump(stdout);  /* dumping macros */
X    ruledump(stdout); /* dumping targets, dependents & commands, resp. */
X  }
X
Xif (printflg)
X  {
X    if (suffs_deleted)
X      printf("no suffix list");
X    dump(stdout);  /* dumping macros */
X    ruledump(stdout); /* dumping targets, dependents & commands, resp. */
X  }
X
Xcleanup_links(link_reg);
Xaf_cleanup();
Xexit(0);
X}
X
Xint initattrfield()
X{
X  int i;
X  for(i = 0; i < MAXDEPTH; i++)
X    {
X      if((longattrs[i] = malloc(MAX_ATTR)) == NIL)
X	errexit(10,"malloc");
X      (void) strcpy(longattrs[i],"");
X    }
X}
X
X	
END_OF_FILE
if test 8311 -ne `wc -c <'src/shape/main.c'`; then
    echo shar: \"'src/shape/main.c'\" unpacked with wrong size!
fi
# end of 'src/shape/main.c'
fi
if test -f 'src/shape/shape.l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/shape/shape.l'\"
else
echo shar: Extracting \"'src/shape/shape.l'\" \(8084 characters\)
sed "s/^X//" >'src/shape/shape.l' <<'END_OF_FILE'
X%a 40000
X%p 20000
X%o 10000
X
X%{
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X/*
X *	Scanner for SHAPE
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: shape.l,v 3.1 89/02/14 11:06:40 wolfgang Exp $";
X#endif
X#ifndef lint
Xstatic char *ConfFlg = CFFLGS;	/* should be defined from within Makefile */
X#endif
X/*
X * $Log:	shape.l,v $
X * Revision 3.1  89/02/14  11:06:40  wolfgang
X * YYLMAX increased to 20000
X * 
X * Revision 3.0  89/01/24  11:35:50  wolfgang
X * New System Generation
X * 
X * Revision 2.13  89/01/18  13:17:10  wolfgang
X * bug fixed. didn't recognize lines with a single TAB as layout line.
X * 
X * Revision 2.12  89/01/03  13:10:56  wolfgang
X * changes done for lint
X * 
X * Revision 2.11  88/12/21  15:03:37  wolfgang
X * changes done for lint
X * 
X * Revision 2.10  88/11/21  15:49:23  wolfgang
X * return code of all malloc's checked
X * 
X * Revision 2.9  88/11/21  12:46:12  wolfgang
X * yyless deleted
X * 
X * Revision 2.8  88/10/18  17:42:31  wolfgang
X * new variant handling
X * 
X * Revision 2.7  88/10/06  15:41:10  wolfgang
X * no more macrodefs evaluated by lex
X * 
X * Revision 2.6  88/09/07  11:20:15  wolfgang
X * any2 changed ==> no comments are allowed within rule- or variant-section!
X * 
X * Revision 2.5  88/08/23  14:05:30  wolfgang
X * YYLMAX increased to 10000 (Scheiss LEX)
X * 
X * Revision 2.4  88/08/12  09:08:00  wolfgang
X * This version is part of a release
X * 
X * Revision 2.2  88/08/12  08:58:11  wolfgang
X * This version is part of a release
X * 
X */
X
X
X#include <stdio.h>
X#include <ctype.h>
X#include "shape.h"
X
Xextern char *malloc();
X
Xextern struct hash *hashtab[];
Xextern char *sel_rule_name;
Xextern Bool synterrflg;
Xextern Bool Oldsuffs;
Xextern Bool Newsuffs;
Xextern char *shaperules;
Xextern char *stdsuff;
Xextern char *expandmacro();
X
Xextern int macrodef();
Xextern int ruledef();
Xextern int rulecont();
Xextern int ruleend();
Xextern int selruledef();
Xextern int vclassdef();
Xextern int errexit();
X#undef YYLMAX
X#define YYLMAX 20000  /* Scheiss LEX */
Xchar *ppp;
Xextern char *suffs;
Xextern char *suffs;
XBool suffs_deleted = FALSE;
X%}
X%START RULEDEF RULESEC VARSEC
XWhiteSpace	[ \t\n]
XLayout		[ \t]
XBlank		" "
XColon		":"
XPeriod		"."
XSemi		";"
XSemiperiod	[;.]
XSemicomma	[;,]
XLayoutline	{Layout}*\n
XTab		\t
XNotab		[^\t]
XAny		.\n
XAny2		[^#]
XAnybutnewline	.
XNC1		"\\\n"
XNC3		"\\\n"
XNC2		[^#\n]*
XNC4		[^\n]*
XNocomment	({NC1}*|{NC2}?)*\n?
XNocomment2	({NC3}*|{NC4}?)*\n?
XMacroname	[0-9a-zA-Z_-]
XVcl		"::=".*
XVclass		"vclass"{Layout}*{Ruledef}{Nocomment}
XMacrodef	{Macroname}+{Layout}*"="{Layout}*{Nocomment}
XRulesecstart	"#%"{Layout}*"RULE-SECTION"{Layout}*
XRulesecend	"#%"{Layout}*"END-RULE-SECTION"{Layout}*
XSelectionrule	{Rulesecstart}+{Any2}*{Rulesecend}+
XVarsecstart	"#%"{Layout}*"VARIANT-SECTION"{Layout}*
XVarsecend	"#%"{Layout}*"END-VARIANT-SECTION"{Layout}*
XDepstart	[@%0-9a-zA-Z.\-/$("{""}")_~,]
XDepcont		[@%0-9a-zA-Z.\-/\t $("{""}")_~,+]
XSuff		[a-zA-Z0-9~,]
XRuledef		{Depstart}+{Depcont}*{Colon}+{Colon}*{Depcont}*{Nocomment}
XRulecont	{Tab}+{Nocomment2}
XOthers		[^#\n]
X%%
X
X{Selectionrule}	{
X#ifdef DEBUG_LEX
X		fprintf(yyout, "\nSelection Rule: %s\n", yytext);
X#endif DEBUG_LEX
X(void) strcpy(yytext,expandmacro(yytext));
X		selruledef(yytext);
X		}
X
X{Varsecstart}	{
X#ifdef DEBUG_LEX
X		fprintf(yyout, "\nVariant Section Start: %s\n", yytext);
X#endif DEBUG_LEX
X		;
X		BEGIN VARSEC;
X		}
X
X<VARSEC>^{Tab}{Macrodef}	{
X#ifdef DEBUG_LEX
X		fprintf(yyout, "\nMacro in variant section: %s\n", yytext);
X#endif DEBUG_LEX
X		varmacrodef(yytext);
X		}
X
X<VARSEC>^{Layoutline}$	{
X#ifdef DEBUG_LEX
X		fprintf(yyout,"\n Layoutline in variant section\n");
X#endif DEBUG_LEX
X		}
X
X
X<VARSEC>^"\n"	{
X#ifdef DEBUG_LEX
X		fprintf(yyout,"\n Empty line in variant section\n");
X#endif DEBUG_LEX
X		}
X
X<VARSEC>{Ruledef}	{
X#ifdef DEBUG_LEX
X		fprintf(yyout, "\nVariant name: %s\n", yytext);
X#endif DEBUG_LEX
X		varsec_name(yytext);
X		}
X
X<VARSEC>{Varsecend}	{
X#ifdef DEBUG_LEX
X		fprintf(yyout, "\nVarsec end: %s\n", yytext);
X#endif DEBUG_LEX
X		;
X		BEGIN 0;
X		}
X
X<VARSEC>{Vclass}	{
X#ifdef DEBUG_LEX
X		fprintf(yyout, "\nvclass definition: %s\n", yytext);
X#endif DEBUG_LEX
X		vclassdef(yytext);		
X		}
X
X
X<RULEDEF>^{Macrodef}	{
X		ruleend();
X#ifdef DEBUG_LEX
X		fprintf(yyout, "\n Ruledef end found\n");
X		fprintf(yyout, "\nMacrodefinition: %s\n", yytext);
X#endif DEBUG_LEX
X		/* if (yytext[yyleng-1] == '\n')
X		  	yytext[yyleng-1] = '\0';
X		macrodef(yytext) */ ;
X		BEGIN 0;
X		}
X
X<RULEDEF>{Varsecstart}	{
X		ruleend();
X#ifdef DEBUG_LEX
X		fprintf(yyout, "\n Ruledef end found\n");
X		fprintf(yyout, "\nVarsec start: %s\n", yytext);
X#endif DEBUG_LEX
X		/* if (yytext[yyleng-1] == '\n')
X		  	yytext[yyleng-1] = '\0';
X		macrodef(yytext) */ ;
X		BEGIN VARSEC;
X		}
X
X
X^{Macrodef}	{
X#ifdef DEBUG_LEX
X		fprintf(yyout, "\nMacrodefinition: %s\n", yytext);
X#endif DEBUG_LEX
X		/* if (yytext[yyleng-1] == '\n')
X			yytext[yyleng-1] = '\0';
X		macrodef(yytext) */ ;
X		}
X
X^{Rulesecstart}	{
X#ifdef DEBUG_LEX
X		fprintf(yyout, "\nRulesec starts: %s\n", yytext);
X#endif DEBUG_LEX
X		BEGIN RULESEC;
X		}
X
X
X^{Ruledef}	{
X#ifdef DEBUG_LEX
X		fprintf(yyout, "\n Rule: %s\n", yytext);
X#endif DEBUG_LEX
X		ruleend();
X		if (yytext[yyleng-1] == '\n')
X			yytext[yyleng-1] = '\0';
X		if ((strncmp(yytext,".SUFFIXES:",10) == 0))
X			{
X			if((ppp = index(yytext,'%')) == NIL)
X			/* old style suffix list */
X				{
X			        Oldsuffs = TRUE;
X				ppp = yytext + 10;
X				if (index(ppp,'.') != NIL)
X					{
X					if ((suffs = malloc((unsigned) 
X					      (strlen(yytext) +
X					       strlen(stdsuff) + 3))) == NIL)
X					      errexit(10,"malloc");
X					suffs[0] = '\0';
X						(void) strcat(suffs,".SUFFIXES: ");
X					if (!suffs_deleted)
X						(void) strcat(suffs,stdsuff);
X						(void) strcat(suffs,ppp);
X					suffs_deleted = FALSE;
X					}
X				else
X					{
X					suffs_deleted = TRUE;
X					}
X				}
X			else
X				{
X				/* new style suffixes */
X				Newsuffs = TRUE;
X				ppp = yytext + 10;
X				if ((suffs =
X				     malloc ((unsigned) 
X				     (strlen(yytext) + strlen(shaperules)
X					    + 3))) == NIL)
X				      errexit(10,"malloc");
X				suffs[0] = '\0';
X					(void) strcat(suffs,".SUFFIXES");
X				if (!suffs_deleted)
X					(void) strcat(suffs,shaperules);
X					(void) strcat(suffs,ppp);
X				suffs_deleted = FALSE;
X				}
X#ifdef DEBUG_LEX
Xfprintf(yyout,"suffixes:%s\n", suffs);
X#endif DEBUG_LEX
X			}
X		else	
X			ruledef(yytext);		
X		BEGIN RULEDEF;
X		}
X
X<RULEDEF>^{Layoutline}$	{
X#ifdef DEBUG_LEX
X		fprintf(yyout,"\n Layoutline in ruledef\n");
X#endif DEBUG_LEX
X		}
X
X<RULEDEF>^{Rulecont}	{
X#ifdef DEBUG_LEX
X		fprintf(yyout, "\n Rulecont: %s\n", yytext);
X#endif DEBUG_LEX
X		/* strcpy(yytext,expandmacro(yytext)); */
X		rulecont(yytext);		
X		}
X
X
X
X<RULEDEF>^{Notab}	{
X#ifdef DEBUG_LEX
X		fprintf(yyout, "\n Ruledef end found\n");
X#endif DEBUG_LEX
X		ruleend();
X		yyless(yyleng-1);
X		BEGIN 0;
X		}
X^{Layoutline}$	{
X#ifdef DEBUG_LEX
X		fprintf(yyout,"\n Layoutline\n");
X#endif DEBUG_LEX
X		}
X
X^{Blank}*	{
X#ifdef DEBUG_LEX
X		fprintf(yyout,"\n Layoutline\n");
X#endif DEBUG_LEX
X		}
X
X^{Tab}*		{
X#ifdef DEBUG_LEX
X		fprintf(yyout,"\n Layoutline\n");
X#endif DEBUG_LEX
X		}	
X
X\n		{
X		;
X		}
X
X^\n		{
X		;
X		}
X
X{Others}*	{
X		synterrflg = TRUE;
X		errexit(14,yytext);
X		BEGIN 0;
X		}
X
X%%
END_OF_FILE
if test 8084 -ne `wc -c <'src/shape/shape.l'`; then
    echo shar: \"'src/shape/shape.l'\" unpacked with wrong size!
fi
# end of 'src/shape/shape.l'
fi
if test -f 'src/shape/varsec.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/shape/varsec.c'\"
else
echo shar: Extracting \"'src/shape/varsec.c'\" \(8140 characters\)
sed "s/^X//" >'src/shape/varsec.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1989, 1990 W. Koch, A. Lampen, A. Mahler, W. Obst,
X *  and U. Pralle
X * 
X * This software is published on an as-is basis. There is ABSOLUTELY NO
X * WARRANTY for any part of this software to work correctly or as described
X * in the manuals. We do not accept any liability for any kind of damage
X * caused by use of this software, such as loss of data, time, money, or 
X * effort.
X * 
X * Permission is granted to use, copy, modify, or distribute any part of
X * this software as long as this is done without asking for charge, and
X * provided that this copyright notice is retained as part of the source
X * files. You may charge a distribution fee for the physical act of
X * transferring a copy, and you may at your option offer warranty
X * protection in exchange for a fee.
X * 
X * Direct questions to: Tech. Univ. Berlin
X * 		     Wilfried Koch
X * 		     Sekr. FR 5-6 
X * 		     Franklinstr. 28/29
X * 		     D-1000 Berlin 10, West Germany
X * 
X * 		     Tel: +49-30-314-22972
X * 		     E-mail: shape@coma.uucp or shape@db0tui62.bitnet
X */
X#ifndef lint
Xstatic char *RCSid = "$Header: varsec.c,v 3.0 89/01/24 11:37:15 wolfgang Stable $";
X#endif
X#ifndef lint
Xstatic char *ConfFlg = CFFLGS;	/* should be defined from within Makefile */
X#endif
X/*
X * $Log:	varsec.c,v $
X * Revision 3.0  89/01/24  11:37:15  wolfgang
X * New System Generation
X * 
X * Revision 2.18  89/01/03  13:14:14  wolfgang
X * changes done for lint
X * 
X * Revision 2.17  88/12/21  15:13:22  wolfgang
X * changes done for lint
X * 
X * Revision 2.16  88/11/22  18:32:17  wolfgang
X * bug fixed: missing initialisation.
X * 
X * Revision 2.15  88/11/21  15:48:20  wolfgang
X * return code of all malloc's checked
X * 
X * Revision 2.14  88/11/03  17:30:22  wolfgang
X * bug fixed in is_varname().
X * 
X * Revision 2.13  88/10/27  16:37:34  wolfgang
X * bugs fixed (new variant handling).
X * 
X * Revision 2.12  88/10/26  13:13:36  wolfgang
X * changes done for new syntax of variant deps
X * 
X * Revision 2.11  88/10/24  16:21:56  wolfgang
X * another segmentation violation fixed in is_varname().
X * 
X * Revision 2.10  88/10/21  11:36:37  wolfgang
X * bug fixed in is_varname: produced a segmentation violation ($(RULE)+.
X * 
X * Revision 2.9  88/10/20  13:20:16  wolfgang
X * 
X * bug fixed in is_varname: string = "+" caused segmentation violation.
X * 
X * Revision 2.8  88/10/18  17:41:56  wolfgang
X * nearly newly written (for new variant handling)
X * 
X * Revision 2.7  88/10/14  17:15:05  wolfgang
X * varsecname() & varmacrodef() added. vardump() changed.
X * 
X * Revision 2.6  88/09/19  18:40:29  wolfgang
X * Bug fixes. Second endless loop in check_vclass. Shit!!!!
X * 
X * Revision 2.5  88/09/19  18:11:36  wolfgang
X * bug fixed (endless loop in check_vclass).
X * 
X * Revision 2.4  88/09/15  18:41:05  wolfgang
X * check_vclass & reset_vclass added.
X * 
X * Revision 2.3  88/09/15  12:42:54  wolfgang
X * bug fixed.
X * 
X * Revision 2.2  88/08/23  11:23:40  wolfgang
X * New procedure added: vardump(fd). To be used for the generation of
X * confid's. Dumps the variant section.
X * 
X * Revision 2.1  88/08/19  10:18:16  wolfgang
X * This version is part of a release
X * 
X */
X
X#include <sys/types.h>
X#include <sys/dir.h>
X
X#include "shape.h"
X#include "varsec.h"
X
Xvarsec_name(string)
X     char *string;
X{
X  char *p;
X  int k = 0;
X
X  if (( p = index(string,':')) == 0)
X    errexit(14, string);
X
X  *p = '\0';
X  while((vardefs[k] != (struct vardef *) NIL))
X    {
X      if (!strcmp(vardefs[k]->name,string))
X	errexit(33, string);
X      k++;
X    }
X  if ((vardefs[k] = (struct vardef *) malloc (sizeof (struct vardef))) == (struct vardef *) NIL)
X    errexit(10,"malloc");
X  if ((vardefs[k]->name = malloc((unsigned) (strlen(string) + sizeof(char)))) == NIL)
X    errexit(10,"malloc");
X  (void) strcpy(vardefs[k]->name, string);
X
X  lastvardef = k;
X  vardefs[k+1] = (struct vardef *) NIL;
X
X  vardefs[k]->vpath = NIL;
X  vardefs[k]->vflags = NIL;
X  
X  for(k = 0; k < MAXVMACROS; k++)
X    vardefs[lastvardef]->vmacros[k] = NIL;
X}
X
X
Xvarmacrodef(string)
X     char *string;
X{
X  char *p;
X  int k = 0;
X
X  if (string[strlen(string) - 1] == '\n')
X    string[strlen(string) - 1] = '\0';
X
X  while((*string == '\t') || (*string == ' '))
X    string++;
X
X  if(!strncmp(string,"vpath",5))
X    {
X      if ((p = index(string,'=')) == NIL)
X	errexit(7, string);
X      p++;
X      while((*p == ' ') || (*p == '\t'))
X	p++;
X      
X      if ((vardefs[lastvardef]->vpath = malloc((unsigned) (strlen(p)+sizeof(char)))) == NIL)
X	errexit(10,"malloc");
X      (void) strcpy(vardefs[lastvardef]->vpath,p);
X      return;
X    }
X
X  if(!strncmp(string,"vflags",6))
X    {
X      if ((p = index(string,'=')) == NIL)
X	errexit(7, string);
X      p++;
X      while((*p == ' ') || (*p == '\t'))
X	p++;
X      
X      if ((vardefs[lastvardef]->vflags = malloc((unsigned) (strlen(p)+sizeof(char)))) == NIL)
X	errexit(10,"malloc");
X      (void) strcpy(vardefs[lastvardef]->vflags,p);
X      return;
X    }
X
X  while(vardefs[lastvardef]->vmacros[k] != NIL)
X    k++;
X  
X  if ((vardefs[lastvardef]->vmacros[k] = malloc((unsigned) (strlen(string) + sizeof(char)))) == NIL)
X    errexit(10,"malloc");
X  (void) strcpy(vardefs[lastvardef]->vmacros[k],string);
X}
X  
X
X
Xint vardump(fd)
X     FILE *fd;
X{
Xint i = 0;
Xint k = 0;
X
Xif (vardefs[i] != (struct vardef *) NIL)
X  {
X
X    fprintf(fd,"#%% VARIANT-SECTION\n");
X
X    for(i = 0; vardefs[i] != (struct vardef *) NIL; i++)
X      {
X	fprintf(fd,"\n");
X
X	fprintf(fd,"%s:\n", vardefs[i]->name);
X
X	if(vardefs[i]->vflags != NIL)
X	  fprintf(fd,"\tvflags = %s\n", vardefs[i]->vflags);
X
X	if(vardefs[i]->vpath != NIL)
X	  fprintf(fd,"\tvpath = %s\n", vardefs[i]->vpath);
X
X	while(vardefs[i]->vmacros[k] != NIL)
X	  {
X	    fprintf(fd,"\t%s\n",vardefs[i]->vmacros[k]);
X	    k++;
X	  }
X	k = 0;
X      }
X    fprintf(fd,"\n");
X
X    fprintf(fd,"#%% END-VARIANT-SECTION\n");
X    
X    (void) fflush(fd);
X  }
X}
X
X	    
Xvclassdef(string)
X     char *string;
X{
Xchar *p;
Xchar *vname;
Xint k = 0;
Xint l = 0;
Xint j = 0;
Xchar vc[32];
X
Xif ((p = index(string,' ')) == NIL)
X  errexit(14,string);
Xelse
X  {
X    *p = '\0';
X    p++;
X    vname = p;
X    string = p;
X    if ((p = index(string,':')) == NIL)
X      errexit(14,string);
X    *p = '\0';
X    string++;
X    if ((p = index(vname,' ')) != NIL)
X      *p = '\0';
X    while(vclass[k] != (struct varclass *) NIL)
X      k++;
X    if((vclass[k] = (struct varclass *) malloc( sizeof (struct varclass))) == (struct varclass *) NIL)
X      errexit(10,"malloc");
X    if ((vclass[k]->name = malloc((unsigned) (strlen(vname) + sizeof(char)))) == NIL)
X      errexit(10,"malloc");
X    (void) strcpy(vclass[k]->name,vname);
X    vclass[k]->active = -1;
X  }
X
Xwhile(*string != '(')
X  string++;
X
Xstring++;
X
Xwhile(*string != ')')
X  {
X    while((*string == ' ') || (*string == '\t'))
X      string++;
X
X    while((*string != ',') && (*string != ')'))
X      {
X	vc[j] = *string;
X	string++;
X	j++;
X      }
X    if (*string == ',')
X      string++;
X
X    vc[j] = '\0';
X    if ((vclass[k]->variants[l] = malloc((unsigned) (strlen(vc) + sizeof(char)))) == NIL)
X      errexit(10,"malloc");
X    (void) strcpy(vclass[k]->variants[l],vc);
X    l++;
X    vclass[k]->variants[l] = NIL;
X    j = 0;
X    while((*string == ' ') || (*string == '\t'))
X      string++;
X  }
X}
X
X	
XBool check_vclass(varname)
X     char *varname;
X{
X  int i = 0;
X  int j = 0;
X  
X  while(vclass[i] != (struct varclass *) NIL)
X    {
X      j = 0;
X      while(vclass[i]->variants[j] != NIL)
X	{
X	  if(strcmp(vclass[i]->variants[j],varname) == 0)
X	    {
X	      if((vclass[i]->active != -1) && (vclass[i]->active != j))
X		return(FALSE);
X	      vclass[i]->active = j;
X	      return(TRUE);
X	    }
X	  j++;
X	}
X      i++;
X    }
X  if(vclass[i] == (struct varclass *) NIL)
X    return(TRUE);
X/*NOTREACHED*/
Xreturn(FALSE);
X}
X
Xreset_vclass()
X{
X  int i = 0;
X
X  while( vclass[i] != (struct varclass *) NIL)
X    {
X      vclass[i]->active = -1;
X      i++;
X    }
X}
X
X
X    
XBool is_varname(string)
X     char *string;
X{
X  char *p;
X  int k = 0;
X
X  if(string == NIL)
X    return(FALSE);
X
X  if(string[0] != '+')
X    return(FALSE);
X
X  p = index(string,'+');
X  p++;
X
X  while(vardefs[k] != (struct vardef *) NIL)
X    {
X      if(!strcmp(vardefs[k]->name,p))
X	return(TRUE);
X      k++;
X    }
X  return(FALSE);
X}
END_OF_FILE
if test 8140 -ne `wc -c <'src/shape/varsec.c'`; then
    echo shar: \"'src/shape/varsec.c'\" unpacked with wrong size!
fi
# end of 'src/shape/varsec.c'
fi
echo shar: End of archive 9 \(of 33\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
