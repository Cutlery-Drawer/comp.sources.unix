Subject:  v19i061:  Flex, a fast LEX replacement, Part07/07
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Vern Paxson <vern@csam.lbl.gov>
Posting-number: Volume 19, Issue 61
Archive-name: flex2/part07

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 7)."
# Contents:  flex/initscan.c
# Wrapped by rsalz@prune.bbn.com on Thu Jun 22 19:01:55 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'flex/initscan.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'flex/initscan.c'\"
else
echo shar: Extracting \"'flex/initscan.c'\" \(53057 characters\)
sed "s/^X//" >'flex/initscan.c' <<'END_OF_FILE'
X#define FLEX_COMPRESSED
X/* A lexical scanner generated by flex */
X
X/* scanner skeleton version:
X * $Header: flex.skel,v 2.0 89/06/20 15:49:46 vern Locked $
X */
X
X#include <stdio.h>
X
X#define FLEX_SCANNER
X
X/* amount of stuff to slurp up with each read */
X#ifndef YY_READ_BUF_SIZE
X#define YY_READ_BUF_SIZE 8192
X#endif
X
X#ifndef YY_BUF_SIZE
X#define YY_BUF_SIZE (YY_READ_BUF_SIZE * 2) /* size of input buffer */
X#endif
X
X/* returned upon end-of-file */
X#define YY_END_TOK 0
X
X/* copy whatever the last rule matched to the standard output */
X
X#define ECHO fputs( yytext, yyout )
X
X/* gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
X * is returned in "result".
X */
X#define YY_INPUT(buf,result,max_size) \
X	if ( (result = read( fileno(yyin), buf, max_size )) < 0 ) \
X	    YY_FATAL_ERROR( "read() in flex scanner failed" );
X#define YY_NULL 0
X#define yyterminate() return ( YY_NULL )
X
X/* report a fatal error */
X#define YY_FATAL_ERROR(msg) \
X	{ \
X	fputs( msg, stderr ); \
X	putc( '\n', stderr ); \
X	exit( 1 ); \
X	}
X
X/* default yywrap function - always treat EOF as an EOF */
X#define yywrap() 1
X
X/* enter a start condition.  This macro really ought to take a parameter,
X * but we do it the disgusting crufty way forced on us by the ()-less
X * definition of BEGIN
X */
X#define BEGIN yy_start = 1 + 2 *
X
X/* action number for EOF rule of a given start state */
X#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
X
X/* special action meaning "start processing a new file" */
X#define YY_NEW_FILE goto new_file
X
X/* default declaration of generated scanner - a define so the user can
X * easily add parameters
X */
X#ifdef __STDC__
X#define YY_DECL int yylex( void )
X#else
X#define YY_DECL int yylex()
X#endif
X
X/* code executed at the end of each rule */
X#define YY_BREAK break;
X
X#define YY_END_OF_BUFFER_CHAR 0
X
X/* done after the current pattern has been matched and before the
X * corresponding action - sets up yytext
X */
X#define YY_DO_BEFORE_ACTION \
X	yytext = yy_bp; \
X	yy_hold_char = *yy_cp; \
X	*yy_cp = '\0'; \
X	yy_c_buf_p = yy_cp;
X
X/* returns the length of the matched text */
X#define yyleng (yy_cp - yy_bp)
X
X#define EOB_ACT_RESTART_SCAN 0
X#define EOB_ACT_END_OF_FILE 1
X#define EOB_ACT_LAST_MATCH 2
X
X/* return all but the first 'n' matched characters back to the input stream */
X#define yyless(n) \
X	{ \
X	*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \
X	yy_c_buf_p = yy_cp = yy_bp + n; \
X	YY_DO_BEFORE_ACTION; /* set up yytext again */ \
X	}
X
X#define unput(c) yyunput( c, yy_bp )
X
X#define YY_USER_ACTION
X
XFILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
Xchar *yytext;
X
X#ifndef __STDC__
X#define const
X#endif
X
X# line 1 "scan.l"
X#define INITIAL 0
X/* scan.l - scanner for flex input */
X/*
X * Copyright (c) 1989 The Regents of the University of California.
X * All rights reserved.
X *
X * This code is derived from software contributed to Berkeley by
X * Vern Paxson.
X * 
X * The United States Government has rights in this work pursuant to
X * contract no. DE-AC03-76SF00098 between the United States Department of
X * Energy and the University of California.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that the above copyright notice and this paragraph are
X * duplicated in all such forms and that any documentation,
X * advertising materials, and other materials related to such
X * distribution and use acknowledge that the software was developed
X * by the University of California, Berkeley.  The name of the
X * University may not be used to endorse or promote products derived
X * from this software without specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X# line 28 "scan.l"
X#include "flexdef.h"
X#include "parse.h"
X
X#ifndef lint
Xstatic char copyright[] =
X    "@(#) Copyright (c) 1989 The Regents of the University of California.\n";
Xstatic char CR_continuation[] = "@(#) All rights reserved.\n";
X
Xstatic char rcsid[] =
X    "@(#) $Header: scan.l,v 2.1 89/06/20 17:24:13 vern Exp $ (LBL)";
X#endif
X
X#define ACTION_ECHO fprintf( temp_action_file, "%s", yytext )
X#define MARK_END_OF_PROLOG fprintf( temp_action_file, "%%%% end of prolog\n" );
X
X#undef YY_DECL
X#define YY_DECL \
X	int flexscan()
X
X#define RETURNCHAR \
X	yylval = yytext[0]; \
X	return ( CHAR );
X
X#define RETURNNAME \
X	(void) strcpy( nmstr, yytext ); \
X	return ( NAME );
X
X#define PUT_BACK_STRING(str, start) \
X	for ( i = strlen( str ) - 1; i >= start; --i ) \
X	    unput(str[i])
X
X#define CHECK_REJECT(str) \
X	if ( all_upper( str ) ) \
X	    reject = true;
X
X#define CHECK_YYMORE(str) \
X	if ( all_lower( str ) ) \
X	    yymore_used = true;
X#define SECT2 1
X#define SECT2PROLOG 2
X#define SECT3 3
X#define CODEBLOCK 4
X#define PICKUPDEF 5
X#define SC 6
X#define CARETISBOL 7
X#define NUM 8
X#define QUOTE 9
X#define FIRSTCCL 10
X#define CCL 11
X#define ACTION 12
X#define RECOVER 13
X#define BRACEERROR 14
X#define C_COMMENT 15
X#define C_COMMENT_2 16
X#define ACTION_COMMENT 17
X#define ACTION_STRING 18
X#define PERCENT_BRACE_ACTION 19
X#define USED_LIST 20
X# line 83 "scan.l"
X#define YY_END_OF_BUFFER 116
Xtypedef int yy_state_type;
Xstatic const short int yy_accept[317] =
X    {   0,
X        0,    0,    0,    0,    0,    0,  114,  114,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,  116,   16,    7,   15,   13,    1,   14,   16,
X       16,   16,   12,   58,   50,   51,   43,   58,   57,   41,
X       58,   58,   58,   50,   39,   58,   57,   42,  115,   37,
X      114,  114,   25,   26,   25,   25,   25,   25,   28,   27,
X       29,   64,  115,   60,   61,   63,   65,   79,   80,   77,
X       76,   78,   66,   68,   67,   66,   72,   71,   72,   72,
X
X       74,   74,   74,   75,   90,   95,   94,   96,   96,   91,
X       91,   91,   88,   89,  115,   30,   82,   81,   19,   21,
X       20,  104,  106,  105,   98,  100,   99,  107,  109,  110,
X      111,   86,   86,   87,   86,   86,   86,   86,   35,   32,
X       31,   35,   35,    7,   13,    1,   14,    0,    2,    0,
X        8,    4,    0,    5,    0,    3,   12,   50,   51,    0,
X        0,   46,    0,    0,    0,  112,  112,   45,   44,   45,
X        0,   50,   39,    0,    0,    0,   54,   49,    0,   37,
X       36,  114,  114,   25,   25,   25,   25,   25,   28,   27,
X       62,   63,   76,  113,  113,   69,   70,   73,   90,    0,
X
X       93,    0,   92,   91,   91,   91,    0,   30,   19,   17,
X      104,  102,   98,   97,  107,  108,   86,   86,   86,   83,
X       86,   86,   86,   35,   32,   35,   35,    0,    8,    8,
X        0,    0,    0,    0,    6,    0,   47,    0,   48,    0,
X       55,    0,  112,   45,   45,   56,   40,    0,   47,    0,
X       40,    0,   54,   25,   25,   25,   22,    0,  113,   91,
X       91,    0,   18,    0,  103,   83,   83,   86,   86,   35,
X       35,    0,   11,    8,    0,    0,    0,    0,    6,    0,
X        0,   25,   25,   91,   91,   86,   86,   35,   35,    0,
X        0,    9,    0,    0,   25,   25,   91,   91,   86,   86,
X
X       35,   35,    4,    0,    0,   23,   24,   84,   85,   84,
X       85,   33,   34,   10,   53,    0
X    } ;
X
Xstatic const char yy_ec[128] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
X        1,    4,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    5,    1,    6,    7,    8,    9,    1,   10,   11,
X       11,   12,   11,   13,   14,   11,   15,   16,   16,   16,
X       16,   16,   16,   16,   16,   16,   16,    1,    1,   17,
X        1,   18,   11,    1,   24,   23,   25,   26,   27,   28,
X       23,   23,   23,   29,   23,   23,   30,   31,   32,   23,
X       23,   33,   34,   35,   36,   23,   23,   37,   38,   23,
X       19,   20,   21,   22,   23,    1,   24,   23,   25,   26,
X
X       27,   28,   23,   23,   23,   29,   23,   23,   30,   31,
X       32,   23,   23,   33,   34,   35,   36,   23,   23,   37,
X       38,   23,   39,   40,   41,    1,    1
X    } ;
X
Xstatic const char yy_meta[42] =
X    {   0,
X        1,    2,    3,    2,    2,    4,    1,    1,    1,    5,
X        1,    6,    1,    7,    5,    7,    1,    1,    1,    8,
X        9,    1,   10,   10,   10,   10,   10,   10,   10,   10,
X       10,   10,   10,   10,   10,   10,   10,   10,    5,    1,
X       11
X    } ;
X
Xstatic const short int yy_base[375] =
X    {   0,
X        0,   41,   81,  120, 1129, 1096, 1085, 1084,  160, 1075,
X      100,  104,  201,    0, 1061, 1058,  114,  240,   91,  113,
X      131,  241,  244,  246,  281,    0, 1070, 1059,  107,  109,
X       87,  135,  140,  146,  242,  245,  256,  320,  340,    0,
X      380,  384, 1056, 1250,  152, 1250,    0,  266, 1250, 1049,
X      241, 1039,    0, 1250,  388, 1250, 1250,  322, 1250, 1026,
X     1020, 1016,  428,  468, 1250, 1020, 1009, 1250, 1015,    0,
X     1000, 1250,    0, 1250,    0,  975,  954,  944,    0,  326,
X     1250, 1250, 1250, 1250,  962,    0, 1250, 1250, 1250, 1250,
X      967, 1250, 1250, 1250, 1250,  962, 1250, 1250,  956,  947,
X
X     1250,    0,  934, 1250,    0, 1250, 1250,  126,  934,    0,
X      918,  897, 1250, 1250,  928, 1250, 1250, 1250,    0, 1250,
X      915,    0, 1250,  912,    0, 1250,  905,    0, 1250, 1250,
X        0,    0,  330, 1250,  857,    0,  870,  827,    0,  394,
X     1250,  833,  816,  398,    0,  402, 1250,  847, 1250,  844,
X      819,  788,  110, 1250,  269, 1250,    0,  476, 1250,  543,
X      578, 1250,  553,   93,  230, 1250,  563,    0, 1250,  503,
X      405,  543, 1250,  471,  326,  406,    0, 1250,  575,    0,
X     1250,  574, 1250,    0,    0,  547,  545,  583,    0,  410,
X     1250,    0,  558, 1250,  557, 1250, 1250, 1250,    0,  391,
X
X     1250,    0, 1250,    0,  543,  541,  567, 1250,    0,  566,
X        0,  565,    0, 1250,    0, 1250,    0,  422,  526,  602,
X        0,  537,  535,    0,  485,  535,  533,  559,    0,  558,
X      536,  523,  530,  553, 1250,  552, 1250,  551, 1250,  521,
X     1250,  472,  535,    0,    0, 1250, 1250,  407,  479,  481,
X     1250,  413,    0,  523,  517,    0, 1250,  540,  526,  498,
X      492,  520, 1250,  519, 1250,  618,    0,  494,  488,  491,
X      483,  511, 1250,  510,  479,  477,  483,  504, 1250,  478,
X      479,  480,  471,  478,  469,  476,  465,  472,  458,  441,
X      448, 1250,  405,  316,  360,  367,  298,  252,  238,  225,
X
X       83,   68, 1250,   65,   70,    0,    0,    0,    0,    0,
X        0,    0,    0, 1250, 1250, 1250,  656,  667,  678,  689,
X      700,  711,  722,  733,  744,  755,  766,  777,  788,  799,
X      810,  815,  825,  836,  841,  851,  862,  873,  884,  895,
X      906,  917,  922,  932,  937,  947,  958,  969,  980,  989,
X      994, 1004, 1015, 1026, 1037, 1048, 1059, 1070, 1075, 1085,
X     1096, 1107, 1118, 1129, 1139, 1150, 1161, 1172, 1183, 1194,
X     1205, 1216, 1227, 1238
X    } ;
X
Xstatic const short int yy_def[375] =
X    {   0,
X      316,  316,  317,  317,  318,  318,  319,  319,  316,    9,
X      320,  320,  316,   13,  321,  321,  322,  322,  323,  323,
X      324,  324,  325,  325,  316,   25,  326,  326,  321,  321,
X      327,  327,  328,  328,  329,  329,  330,  330,  316,   39,
X      331,  331,  316,  316,  316,  316,  332,  316,  316,  333,
X      334,  316,  335,  316,  316,  316,  316,  316,  316,  316,
X      336,  337,  316,  338,  316,  316,  316,  316,  339,  340,
X      341,  316,  342,  316,  343,  343,  343,  342,  344,  316,
X      316,  316,  316,  316,  316,  345,  316,  316,  316,  316,
X      316,  316,  316,  316,  316,  337,  316,  316,  346,  347,
X
X      316,  348,  337,  316,  349,  316,  316,  350,  316,  351,
X      351,  351,  316,  316,  352,  316,  316,  316,  353,  316,
X      316,  354,  316,  316,  355,  316,  316,  356,  316,  316,
X      357,  358,  358,  316,  358,  359,  359,  359,  360,  316,
X      316,  360,  360,  316,  332,  316,  316,  333,  316,  316,
X      361,  316,  316,  316,  362,  316,  335,  316,  316,  316,
X      363,  316,  316,  336,  336,  316,  316,  364,  316,  364,
X      338,  338,  316,  338,  338,  365,  366,  316,  339,  340,
X      316,  341,  316,  342,  343,  343,  343,  316,  344,  316,
X      316,  345,  316,  316,  316,  316,  316,  316,  349,  350,
X
X      316,  350,  316,  351,  351,  351,  352,  316,  353,  367,
X      354,  368,  355,  316,  356,  316,  358,  358,  358,  369,
X      359,  359,  359,  360,  316,  360,  360,  370,  361,  371,
X      316,  316,  316,  362,  316,  372,  316,  363,  316,  316,
X      316,  336,  316,  364,  170,  316,  316,  338,  338,  365,
X      316,  365,  366,  343,  343,  188,  316,  373,  316,  351,
X      351,  367,  316,  368,  316,  369,  374,  359,  359,  360,
X      360,  370,  316,  371,  316,  316,  316,  372,  316,  316,
X      336,  343,  343,  351,  351,  359,  359,  360,  360,  316,
X      316,  316,  316,  336,  343,  343,  351,  351,  359,  359,
X
X      360,  360,  316,  316,  316,  343,  343,  351,  351,  359,
X      359,  360,  360,  316,  316,    0,  316,  316,  316,  316,
X      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
X      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
X      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
X      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
X      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
X      316,  316,  316,  316
X    } ;
X
Xstatic const short int yy_nxt[1292] =
X    {   0,
X       44,   45,   46,   45,   45,   44,   44,   44,   44,   44,
X       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
X       44,   44,   47,   47,   47,   47,   47,   47,   47,   47,
X       47,   47,   47,   47,   47,   47,   47,   47,   44,   44,
X       44,   44,   48,   49,   48,   48,   44,   50,   44,   51,
X       44,   44,   44,   44,   44,   52,   44,   44,   44,   44,
X       44,   44,   44,   53,   53,   53,   53,   53,   53,   53,
X       53,   53,   53,   53,   53,   53,   53,   53,   53,   44,
X       44,   44,   55,   56,   55,   55,   57,  315,   58,  120,
X      314,   59,   59,   94,  313,   59,   95,   60,  121,   61,
X
X       62,   80,   81,   80,   80,   80,   81,   80,   80,  117,
X       96,  117,  165,  241,  228,   94,   89,  312,   95,   63,
X       59,   64,   65,   64,   64,   57,   90,   58,   66,   91,
X       59,   59,   96,   83,   67,  201,   60,  120,   61,   62,
X      232,   68,  123,  233,   98,  202,  121,  118,  123,  118,
X       99,  124,  100,  144,   92,  144,  144,  124,   63,   59,
X       73,   73,   74,   73,   73,   73,   73,   73,   73,   73,
X       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
X       73,   73,   75,   75,   75,   75,   75,   75,   75,   75,
X       75,   75,   76,   75,   75,   75,   75,   77,   73,   73,
X
X       73,   82,   82,   83,   82,   82,   82,   82,   82,   82,
X       82,   82,   82,   84,   82,   82,   82,   82,   85,   82,
X       82,   82,   82,   86,   86,   86,   86,   86,   86,   86,
X       86,   86,   86,   86,   86,   86,   86,   86,   86,   82,
X       82,   82,   89,   83,  126,  242,   83,  126,   83,  151,
X      164,  311,   90,  127,   98,   91,  127,  102,  129,  102,
X       99,  130,  100,  103,  104,  103,  104,  146,  147,  146,
X      146,  235,  310,  236,  152,  131,  153,  154,  309,  155,
X       92,  105,  105,  106,  105,  105,  107,  105,  105,  105,
X      108,  105,  105,  105,  105,  109,  105,  105,  105,  105,
X
X      105,  105,  105,  110,  110,  110,  110,  110,  110,  110,
X      110,  110,  110,  111,  110,  110,  110,  110,  112,  113,
X      105,  114,  129,  162,  162,  130,  162,  190,  247,  190,
X      190,  218,  308,  218,  218,  165,  241,  178,  219,  131,
X      132,  133,  134,  133,  133,  132,  132,  132,  135,  132,
X      132,  132,  132,  132,  132,  132,  132,  132,  132,  132,
X      132,  132,  136,  136,  136,  136,  136,  136,  136,  136,
X      136,  136,  137,  136,  136,  136,  136,  138,  132,  132,
X      132,  140,  141,  140,  140,  140,  141,  140,  140,  158,
X      159,  158,  158,  307,  306,  225,  160,  225,  225,  144,
X
X      201,  144,  144,  146,  147,  146,  146,  247,  251,  247,
X      202,  190,  142,  190,  190,  251,  142,  143,  316,  248,
X      252,  143,  305,  218,  238,  218,  218,  161,  168,  168,
X      219,  168,  168,  168,  168,  168,  168,  168,  168,  168,
X      168,  168,  168,  169,  168,  168,  168,  168,  168,  168,
X      170,  170,  170,  170,  170,  170,  170,  170,  170,  170,
X      170,  170,  170,  170,  170,  170,  168,  168,  168,  172,
X      173,  172,  172,  247,  304,  303,  174,  158,  159,  158,
X      158,  247,  175,  251,  160,  248,  225,  281,  225,  225,
X      302,  165,  241,  248,  294,  252,  301,  300,  165,  241,
X
X      299,  298,  297,  296,  295,  293,  279,  176,  292,  249,
X      291,  290,  273,  273,  289,  161,  245,  288,  245,  287,
X      286,  265,  263,  285,  284,  245,  245,  245,  245,  245,
X      245,  245,  245,  245,  245,  245,  245,  245,  245,  245,
X      245,  194,  257,  246,  172,  173,  172,  172,  283,  282,
X      166,  174,  280,  239,  279,  235,  277,  175,  276,  275,
X      273,  273,  271,  270,  269,  268,  220,  265,  263,  208,
X      261,  260,  259,  193,  255,  254,  183,  180,  243,  240,
X      239,  237,  176,  256,  256,  257,  256,  256,  256,  256,
X      256,  256,  256,  256,  256,  256,  256,  256,  256,  256,
X
X      256,  256,  256,  256,  256,  258,  258,  258,  258,  258,
X      258,  258,  258,  258,  258,  258,  258,  258,  258,  258,
X      258,  256,  256,  256,  267,  267,  267,  267,  267,  267,
X      267,  267,  267,  267,  267,  267,  267,  267,  267,  267,
X      267,  267,  267,  267,  267,  267,  267,  267,  267,  267,
X      267,  267,  267,  267,  267,  267,   54,   54,   54,   54,
X       54,   54,   54,   54,   54,   54,   54,   69,   69,   69,
X       69,   69,   69,   69,   69,   69,   69,   69,   71,   71,
X       71,   71,   71,   71,   71,   71,   71,   71,   71,   79,
X       79,   79,   79,   79,   79,   79,   79,   79,   79,   79,
X
X       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
X       83,   88,   88,   88,   88,   88,   88,   88,   88,   88,
X       88,   88,   93,   93,   93,   93,   93,   93,   93,   93,
X       93,   93,   93,   97,   97,   97,   97,   97,   97,   97,
X       97,   97,   97,   97,  101,  101,  101,  101,  101,  101,
X      101,  101,  101,  101,  101,  115,  115,  115,  115,  115,
X      115,  115,  115,  115,  115,  115,  119,  119,  119,  119,
X      119,  119,  119,  119,  119,  119,  119,  122,  122,  122,
X      122,  122,  122,  122,  122,  122,  122,  122,  125,  125,
X      125,  125,  125,  125,  125,  125,  125,  125,  125,  128,
X
X      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
X      139,  139,  139,  139,  139,  139,  139,  139,  139,  139,
X      139,  145,  231,  230,  145,  148,  148,  148,  148,  148,
X      148,  148,  148,  148,  148,  148,  150,  150,  150,  150,
X      150,  150,  150,  150,  150,  150,  150,  157,  228,  149,
X      157,  164,  164,  227,  164,  164,  164,  164,  164,  226,
X      164,  164,  166,  166,  223,  166,  166,  166,  166,  166,
X      166,  166,  166,  171,  171,  171,  171,  171,  171,  171,
X      171,  171,  171,  171,  179,  179,  179,  179,  179,  179,
X      179,  179,  179,  179,  179,  181,  222,  220,  181,  181,
X
X      181,  181,  181,  181,  181,  181,  182,  182,  182,  182,
X      182,  182,  182,  182,  182,  182,  182,  184,  184,  214,
X      184,  184,  184,  184,  184,  184,  212,  184,  185,  210,
X      208,  185,  189,  189,  206,  189,  189,  189,  189,  189,
X      189,  189,  189,  192,  205,  203,  192,  194,  194,  167,
X      194,  194,  194,  194,  194,  194,  194,  194,  196,  196,
X      197,  196,  196,  196,  196,  196,  196,  196,  196,  198,
X      198,  195,  198,  198,  198,  198,  198,  167,  198,  198,
X      199,  199,  193,  191,  188,  199,  199,  199,  199,  200,
X      200,  187,  200,  200,  200,  200,  200,  200,  200,  200,
X
X      204,  186,  183,  204,  207,  207,  207,  207,  207,  207,
X      207,  207,  207,  207,  207,  209,  209,  180,  209,  209,
X      178,  209,  209,  209,  209,  209,  211,  211,  177,  211,
X      211,  167,  211,  211,  211,  211,  211,  213,  213,  165,
X      213,  213,  163,  213,  213,  213,  213,  213,  215,  215,
X      156,  149,  215,  215,  215,  316,  215,  215,  215,  216,
X      216,  116,  216,  216,  216,  216,  216,  216,  216,  216,
X      217,  217,  116,  217,  217,  217,  217,  217,  217,   87,
X      217,  221,   87,   78,  221,  224,   72,   72,  224,  224,
X      224,  224,  224,  224,  224,  224,  229,  229,   70,  229,
X
X      229,  229,  229,  229,  229,  229,  229,  234,  234,  234,
X      234,  234,  234,  234,  234,  234,  234,  234,  238,  238,
X      238,  238,  238,  238,  238,  238,  238,  238,  238,  244,
X      244,   70,  244,  244,  244,  244,  244,  244,  244,  250,
X      250,  250,  250,  250,  250,  250,  250,  250,  250,  250,
X      253,  253,  316,  253,  253,  253,  253,  253,  253,  253,
X      253,  262,  262,  262,  262,  262,  262,  262,  262,  262,
X      262,  262,  264,  264,  264,  264,  264,  264,  264,  264,
X      264,  264,  264,  266,  266,  316,  266,  266,  266,  266,
X      266,  266,  266,  266,  272,  272,  272,  272,  272,  272,
X
X      272,  272,  272,  272,  272,  274,  274,  274,  274,  274,
X      274,  274,  274,  274,  274,  274,  278,  278,  278,  278,
X      278,  278,  278,  278,  278,  278,  278,  258,  258,  258,
X      258,  258,  258,  258,  258,  258,  258,  258,  267,  267,
X      316,  267,  267,  267,  267,  267,  267,  267,  267,   43,
X      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
X      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
X      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
X      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
X      316
X
X    } ;
X
Xstatic const short int yy_chk[1292] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    2,    2,    2,    2,    2,    2,    2,    2,    2,
X        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
X        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
X        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
X        2,    2,    3,    3,    3,    3,    3,  305,    3,   31,
X      304,    3,    3,   19,  302,    3,   19,    3,   31,    3,
X
X        3,   11,   11,   11,   11,   12,   12,   12,   12,   29,
X       19,   30,  164,  164,  153,   20,   17,  301,   20,    3,
X        3,    4,    4,    4,    4,    4,   17,    4,    4,   17,
X        4,    4,   20,   21,    4,  108,    4,   32,    4,    4,
X      153,    4,   33,  153,   21,  108,   32,   29,   34,   30,
X       21,   33,   21,   45,   17,   45,   45,   34,    4,    4,
X        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
X        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
X        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
X        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
X
X        9,   13,   13,   13,   13,   13,   13,   13,   13,   13,
X       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
X       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
X       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
X       13,   13,   18,   22,   35,  165,   23,   36,   24,   51,
X      165,  300,   18,   35,   22,   18,   36,   23,   37,   24,
X       22,   37,   22,   23,   23,   24,   24,   48,   48,   48,
X       48,  155,  299,  155,   51,   37,   51,   51,  298,   51,
X       18,   25,   25,   25,   25,   25,   25,   25,   25,   25,
X       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
X
X       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
X       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
X       25,   25,   38,   58,   58,   38,   58,   80,  175,   80,
X       80,  133,  297,  133,  133,  294,  294,  175,  133,   38,
X       39,   39,   39,   39,   39,   39,   39,   39,   39,   39,
X       39,   39,   39,   39,   39,   39,   39,   39,   39,   39,
X       39,   39,   39,   39,   39,   39,   39,   39,   39,   39,
X       39,   39,   39,   39,   39,   39,   39,   39,   39,   39,
X       39,   41,   41,   41,   41,   42,   42,   42,   42,   55,
X       55,   55,   55,  296,  295,  140,   55,  140,  140,  144,
X
X      200,  144,  144,  146,  146,  146,  146,  171,  176,  248,
X      200,  190,   41,  190,  190,  252,   42,   41,  248,  171,
X      176,   42,  293,  218,  252,  218,  218,   55,   63,   63,
X      218,   63,   63,   63,   63,   63,   63,   63,   63,   63,
X       63,   63,   63,   63,   63,   63,   63,   63,   63,   63,
X       63,   63,   63,   63,   63,   63,   63,   63,   63,   63,
X       63,   63,   63,   63,   63,   63,   63,   63,   63,   64,
X       64,   64,   64,  174,  291,  290,   64,  158,  158,  158,
X      158,  249,   64,  250,  158,  174,  225,  242,  225,  225,
X      289,  242,  242,  249,  281,  250,  288,  287,  281,  281,
X
X      286,  285,  284,  283,  282,  280,  278,   64,  277,  174,
X      276,  275,  274,  272,  271,  158,  170,  270,  170,  269,
X      268,  264,  262,  261,  260,  170,  170,  170,  170,  170,
X      170,  170,  170,  170,  170,  170,  170,  170,  170,  170,
X      170,  259,  258,  170,  172,  172,  172,  172,  255,  254,
X      243,  172,  240,  238,  236,  234,  233,  172,  232,  231,
X      230,  228,  227,  226,  223,  222,  219,  212,  210,  207,
X      206,  205,  195,  193,  187,  186,  182,  179,  167,  163,
X      161,  160,  172,  188,  188,  188,  188,  188,  188,  188,
X      188,  188,  188,  188,  188,  188,  188,  188,  188,  188,
X
X      188,  188,  188,  188,  188,  188,  188,  188,  188,  188,
X      188,  188,  188,  188,  188,  188,  188,  188,  188,  188,
X      188,  188,  188,  188,  220,  220,  220,  220,  220,  220,
X      220,  220,  220,  220,  220,  220,  220,  220,  220,  220,
X      266,  266,  266,  266,  266,  266,  266,  266,  266,  266,
X      266,  266,  266,  266,  266,  266,  317,  317,  317,  317,
X      317,  317,  317,  317,  317,  317,  317,  318,  318,  318,
X      318,  318,  318,  318,  318,  318,  318,  318,  319,  319,
X      319,  319,  319,  319,  319,  319,  319,  319,  319,  320,
X      320,  320,  320,  320,  320,  320,  320,  320,  320,  320,
X
X      321,  321,  321,  321,  321,  321,  321,  321,  321,  321,
X      321,  322,  322,  322,  322,  322,  322,  322,  322,  322,
X      322,  322,  323,  323,  323,  323,  323,  323,  323,  323,
X      323,  323,  323,  324,  324,  324,  324,  324,  324,  324,
X      324,  324,  324,  324,  325,  325,  325,  325,  325,  325,
X      325,  325,  325,  325,  325,  326,  326,  326,  326,  326,
X      326,  326,  326,  326,  326,  326,  327,  327,  327,  327,
X      327,  327,  327,  327,  327,  327,  327,  328,  328,  328,
X      328,  328,  328,  328,  328,  328,  328,  328,  329,  329,
X      329,  329,  329,  329,  329,  329,  329,  329,  329,  330,
X
X      330,  330,  330,  330,  330,  330,  330,  330,  330,  330,
X      331,  331,  331,  331,  331,  331,  331,  331,  331,  331,
X      331,  332,  152,  151,  332,  333,  333,  333,  333,  333,
X      333,  333,  333,  333,  333,  333,  334,  334,  334,  334,
X      334,  334,  334,  334,  334,  334,  334,  335,  150,  148,
X      335,  336,  336,  143,  336,  336,  336,  336,  336,  142,
X      336,  336,  337,  337,  138,  337,  337,  337,  337,  337,
X      337,  337,  337,  338,  338,  338,  338,  338,  338,  338,
X      338,  338,  338,  338,  339,  339,  339,  339,  339,  339,
X      339,  339,  339,  339,  339,  340,  137,  135,  340,  340,
X
X      340,  340,  340,  340,  340,  340,  341,  341,  341,  341,
X      341,  341,  341,  341,  341,  341,  341,  342,  342,  127,
X      342,  342,  342,  342,  342,  342,  124,  342,  343,  121,
X      115,  343,  344,  344,  112,  344,  344,  344,  344,  344,
X      344,  344,  344,  345,  111,  109,  345,  346,  346,  103,
X      346,  346,  346,  346,  346,  346,  346,  346,  347,  347,
X      100,  347,  347,  347,  347,  347,  347,  347,  347,  348,
X      348,   99,  348,  348,  348,  348,  348,   96,  348,  348,
X      349,  349,   91,   85,   78,  349,  349,  349,  349,  350,
X      350,   77,  350,  350,  350,  350,  350,  350,  350,  350,
X
X      351,   76,   71,  351,  352,  352,  352,  352,  352,  352,
X      352,  352,  352,  352,  352,  353,  353,   69,  353,  353,
X       67,  353,  353,  353,  353,  353,  354,  354,   66,  354,
X      354,   62,  354,  354,  354,  354,  354,  355,  355,   61,
X      355,  355,   60,  355,  355,  355,  355,  355,  356,  356,
X       52,   50,  356,  356,  356,   43,  356,  356,  356,  357,
X      357,   28,  357,  357,  357,  357,  357,  357,  357,  357,
X      358,  358,   27,  358,  358,  358,  358,  358,  358,   16,
X      358,  359,   15,   10,  359,  360,    8,    7,  360,  360,
X      360,  360,  360,  360,  360,  360,  361,  361,    6,  361,
X
X      361,  361,  361,  361,  361,  361,  361,  362,  362,  362,
X      362,  362,  362,  362,  362,  362,  362,  362,  363,  363,
X      363,  363,  363,  363,  363,  363,  363,  363,  363,  364,
X      364,    5,  364,  364,  364,  364,  364,  364,  364,  365,
X      365,  365,  365,  365,  365,  365,  365,  365,  365,  365,
X      366,  366,    0,  366,  366,  366,  366,  366,  366,  366,
X      366,  367,  367,  367,  367,  367,  367,  367,  367,  367,
X      367,  367,  368,  368,  368,  368,  368,  368,  368,  368,
X      368,  368,  368,  369,  369,    0,  369,  369,  369,  369,
X      369,  369,  369,  369,  370,  370,  370,  370,  370,  370,
X
X      370,  370,  370,  370,  370,  371,  371,  371,  371,  371,
X      371,  371,  371,  371,  371,  371,  372,  372,  372,  372,
X      372,  372,  372,  372,  372,  372,  372,  373,  373,  373,
X      373,  373,  373,  373,  373,  373,  373,  373,  374,  374,
X        0,  374,  374,  374,  374,  374,  374,  374,  374,  316,
X      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
X      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
X      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
X      316,  316,  316,  316,  316,  316,  316,  316,  316,  316,
X      316
X
X    } ;
X
X/* the intent behind this definition is that it'll catch
X * any uses of REJECT which flex missed
X */
X#define REJECT reject_used_but_not_detected
X#define yymore() yymore_used_but_not_detected
X
X/* these variables are all declared out here so that section 3 code can
X * manipulate them
X */
Xstatic char *yy_c_buf_p;	/* points to current character in buffer */
Xstatic int yy_init = 1;		/* whether we need to initialize */
Xstatic int yy_start = 0;	/* start state number */
X
X/* true when we've seen an EOF for the current input file */
Xstatic int yy_eof_has_been_seen;
X
Xstatic int yy_n_chars;		/* number of characters read into yy_ch_buf */
X
X/* yy_ch_buf has to be 2 characters longer than YY_BUF_SIZE because we need
X * to put in 2 end-of-buffer characters (this is explained where it is
X * done) at the end of yy_ch_buf
X */
Xstatic char yy_ch_buf[YY_BUF_SIZE + 2];
X
X/* yy_hold_char holds the character lost when yytext is formed */
Xstatic char yy_hold_char;
X
Xstatic yy_state_type yy_last_accepting_state;
Xstatic char *yy_last_accepting_cpos;
X
X#ifdef __STDC__
Xstatic yy_state_type yy_get_previous_state( void );
Xstatic int yy_get_next_buffer( void );
Xstatic void yyunput( int c, char *buf_ptr );
Xstatic int input( void );
Xstatic void yyrestart( FILE *input_file );
X#else
Xstatic yy_state_type yy_get_previous_state();
Xstatic int yy_get_next_buffer();
Xstatic void yyunput();
Xstatic int input();
Xstatic void yyrestart();
X#endif
X
XYY_DECL
X    {
X    register yy_state_type yy_current_state;
X    register char *yy_cp, *yy_bp;
X    register int yy_act;
X
X
X    static int bracelevel, didadef;
X    int i, indented_code, checking_used;
X    char nmdef[MAXLINE], myesc();
X
X
X    if ( yy_init )
X	{
X	if ( ! yy_start )
X	    yy_start = 1;	/* first start state */
X
X	if ( ! yyin )
X	    yyin = stdin;
X
X	if ( ! yyout )
X	    yyout = stdout;
X
Xnew_file:
X	/* this is where we enter upon encountering an end-of-file and
X	 * yywrap() indicating that we should continue processing
X	 */
X
X	/* we put in the '\n' and start reading from [1] so that an
X	 * initial match-at-newline will be true.
X	 */
X
X	yy_ch_buf[0] = '\n';
X	yy_n_chars = 1;
X
X	/* we always need two end-of-buffer characters.  The first causes
X	 * a transition to the end-of-buffer state.  The second causes
X	 * a jam in that state.
X	 */
X	yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
X	yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
X
X	yy_eof_has_been_seen = 0;
X
X	yytext = yy_c_buf_p = &yy_ch_buf[1];
X	yy_hold_char = *yy_c_buf_p;
X	yy_init = 0;
X	}
X
X    while ( 1 )		/* loops until end-of-file is reached */
X	{
X	yy_cp = yy_c_buf_p;
X
X	/* support of yytext */
X	*yy_cp = yy_hold_char;
X
X	/* yy_bp points to the position in yy_ch_buf of the start of the
X	 * current run.
X	 */
X	yy_bp = yy_cp;
X
X	yy_current_state = yy_start;
X	if ( yy_bp[-1] == '\n' )
X	    ++yy_current_state;
X	do
X	    {
X	    register char yy_c = yy_ec[*yy_cp];
X	    if ( yy_accept[yy_current_state] )
X		{
X		yy_last_accepting_state = yy_current_state;
X		yy_last_accepting_cpos = yy_cp;
X		}
X	    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X		{
X		yy_current_state = yy_def[yy_current_state];
X		if ( yy_current_state >= 317 )
X		    yy_c = yy_meta[yy_c];
X		}
X	    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X	    ++yy_cp;
X	    }
X	while ( yy_current_state != 316 );
X	yy_cp = yy_last_accepting_cpos;
X	yy_current_state = yy_last_accepting_state;
X
X	/* bogus while loop to let YY_BACK_TRACK, EOB_ACT_LAST_MATCH,
X	 * and EOF actions branch here without introducing an optimizer-
X	 * daunting goto
X	 */
X	while ( 1 )
X	    {
X	    yy_act = yy_accept[yy_current_state];
X
X	    YY_DO_BEFORE_ACTION;
X	    YY_USER_ACTION;
X
X#ifdef FLEX_DEBUG
X	    fprintf( stderr, "--accepting rule #%d (\"%s\")\n",
X		     yy_act, yytext );
X#endif
X
Xdo_action:	/* this label is used only to access EOF actions */
X	    switch ( yy_act )
X		{
X		case 0: /* must backtrack */
X		/* undo the effects of YY_DO_BEFORE_ACTION */
X		*yy_cp = yy_hold_char;
X		yy_cp = yy_last_accepting_cpos;
X		yy_current_state = yy_last_accepting_state;
X		continue; /* go to "YY_DO_BEFORE_ACTION" */
X
Xcase 1:
X# line 88 "scan.l"
Xindented_code = true; BEGIN(CODEBLOCK);
X	YY_BREAK
Xcase 2:
X# line 89 "scan.l"
X++linenum; ECHO; /* treat as a comment */
X	YY_BREAK
Xcase 3:
X# line 90 "scan.l"
XECHO; BEGIN(C_COMMENT);
X	YY_BREAK
Xcase 4:
X# line 91 "scan.l"
Xreturn ( SCDECL );
X	YY_BREAK
Xcase 5:
X# line 92 "scan.l"
Xreturn ( XSCDECL );
X	YY_BREAK
Xcase 6:
X# line 93 "scan.l"
X{
X			++linenum;
X			line_directive_out( stdout );
X			indented_code = false;
X			BEGIN(CODEBLOCK);
X			}
X	YY_BREAK
Xcase 7:
X# line 100 "scan.l"
Xreturn ( WHITESPACE );
X	YY_BREAK
Xcase 8:
X# line 102 "scan.l"
X{
X			sectnum = 2;
X			line_directive_out( stdout );
X			BEGIN(SECT2PROLOG);
X			return ( SECTEND );
X			}
X	YY_BREAK
Xcase 9:
X# line 109 "scan.l"
Xchecking_used = REALLY_USED; BEGIN(USED_LIST);
X	YY_BREAK
Xcase 10:
X# line 110 "scan.l"
Xchecking_used = REALLY_NOT_USED; BEGIN(USED_LIST);
X	YY_BREAK
Xcase 11:
X# line 113 "scan.l"
X{
X			fprintf( stderr,
X			     "old-style lex command at line %d ignored:\n\t%s",
X				 linenum, yytext );
X			++linenum;
X			}
X	YY_BREAK
Xcase 12:
X# line 120 "scan.l"
X{
X			(void) strcpy( nmstr, yytext );
X			didadef = false;
X			BEGIN(PICKUPDEF);
X			}
X	YY_BREAK
Xcase 13:
X# line 126 "scan.l"
XRETURNNAME;
X	YY_BREAK
Xcase 14:
X# line 127 "scan.l"
X++linenum; /* allows blank lines in section 1 */
X	YY_BREAK
Xcase 15:
X# line 128 "scan.l"
X++linenum; return ( '\n' );
X	YY_BREAK
Xcase 16:
X# line 129 "scan.l"
Xsynerr( "illegal character" ); BEGIN(RECOVER);
X	YY_BREAK
Xcase 17:
X# line 132 "scan.l"
XECHO; BEGIN(0);
X	YY_BREAK
Xcase 18:
X# line 133 "scan.l"
X++linenum; ECHO; BEGIN(0);
X	YY_BREAK
Xcase 19:
X# line 134 "scan.l"
XECHO;
X	YY_BREAK
Xcase 20:
X# line 135 "scan.l"
XECHO;
X	YY_BREAK
Xcase 21:
X# line 136 "scan.l"
X++linenum; ECHO;
X	YY_BREAK
Xcase 22:
X# line 139 "scan.l"
X++linenum; BEGIN(0);
X	YY_BREAK
Xcase 23:
X# line 140 "scan.l"
XECHO; CHECK_REJECT(yytext);
X	YY_BREAK
Xcase 24:
X# line 141 "scan.l"
XECHO; CHECK_YYMORE(yytext);
X	YY_BREAK
Xcase 25:
X# line 142 "scan.l"
XECHO;
X	YY_BREAK
Xcase 26:
X# line 143 "scan.l"
X{
X			++linenum;
X			ECHO;
X			if ( indented_code )
X			    BEGIN(0);
X			}
X	YY_BREAK
Xcase 27:
X# line 151 "scan.l"
X/* separates name and definition */
X	YY_BREAK
Xcase 28:
X# line 153 "scan.l"
X{
X			(void) strcpy( nmdef, yytext );
X
X			for ( i = strlen( nmdef ) - 1;
X			      i >= 0 &&
X			      nmdef[i] == ' ' || nmdef[i] == '\t';
X			      --i )
X			    ;
X
X			nmdef[i + 1] = '\0';
X
X                        ndinstal( nmstr, nmdef );
X			didadef = true;
X			}
X	YY_BREAK
Xcase 29:
X# line 168 "scan.l"
X{
X			if ( ! didadef )
X			    synerr( "incomplete name definition" );
X			BEGIN(0);
X			++linenum;
X			}
X	YY_BREAK
Xcase 30:
X# line 175 "scan.l"
X++linenum; BEGIN(0); RETURNNAME;
X	YY_BREAK
Xcase 31:
X# line 178 "scan.l"
X++linenum; BEGIN(0);
X	YY_BREAK
Xcase 32:
X# line 179 "scan.l"
X
X	YY_BREAK
Xcase 33:
X# line 180 "scan.l"
X{
X			if ( all_upper( yytext ) )
X			    reject_really_used = checking_used;
X			else
X			    synerr( "unrecognized %used/%unused construct" );
X			}
X	YY_BREAK
Xcase 34:
X# line 186 "scan.l"
X{
X			if ( all_lower( yytext ) )
X			    yymore_really_used = checking_used;
X			else
X			    synerr( "unrecognized %used/%unused construct" );
X			}
X	YY_BREAK
Xcase 35:
X# line 192 "scan.l"
Xsynerr( "unrecognized %used/%unused construct" );
X	YY_BREAK
Xcase 36:
X*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
Xyy_c_buf_p = yy_cp -= 1;
XYY_DO_BEFORE_ACTION; /* set up yytext again */
X# line 195 "scan.l"
X{
X			++linenum;
X			ACTION_ECHO;
X			MARK_END_OF_PROLOG;
X			BEGIN(SECT2);
X			}
X	YY_BREAK
Xcase 37:
X# line 202 "scan.l"
X++linenum; ACTION_ECHO;
X	YY_BREAK
Xcase YY_STATE_EOF(SECT2PROLOG):
X# line 204 "scan.l"
XMARK_END_OF_PROLOG; yyterminate();
X	YY_BREAK
Xcase 39:
X# line 206 "scan.l"
X++linenum; /* allow blank lines in section 2 */
X	YY_BREAK
X	/* this horrible mess of a rule matches indented lines which
X	 * do not contain "/*".  We need to make the distinction because
X	 * otherwise this rule will be taken instead of the rule which
X	 * matches the beginning of comments like this one
X	 */
Xcase 40:
X# line 213 "scan.l"
X{
X			synerr( "indented code found outside of action" );
X			++linenum;
X			}
X	YY_BREAK
Xcase 41:
X# line 218 "scan.l"
XBEGIN(SC); return ( '<' );
X	YY_BREAK
Xcase 42:
X# line 219 "scan.l"
Xreturn ( '^' );
X	YY_BREAK
Xcase 43:
X# line 220 "scan.l"
XBEGIN(QUOTE); return ( '"' );
X	YY_BREAK
Xcase 44:
X*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
Xyy_c_buf_p = yy_cp = yy_bp + 1;
XYY_DO_BEFORE_ACTION; /* set up yytext again */
X# line 221 "scan.l"
XBEGIN(NUM); return ( '{' );
X	YY_BREAK
Xcase 45:
X# line 222 "scan.l"
XBEGIN(BRACEERROR);
X	YY_BREAK
Xcase 46:
X*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
Xyy_c_buf_p = yy_cp = yy_bp + 1;
XYY_DO_BEFORE_ACTION; /* set up yytext again */
X# line 223 "scan.l"
Xreturn ( '$' );
X	YY_BREAK
Xcase 47:
X# line 225 "scan.l"
X{
X			bracelevel = 1;
X			BEGIN(PERCENT_BRACE_ACTION);
X			return ( '\n' );
X			}
X	YY_BREAK
Xcase 48:
X# line 230 "scan.l"
Xcontinued_action = true; ++linenum; return ( '\n' );
X	YY_BREAK
Xcase 49:
X# line 232 "scan.l"
XACTION_ECHO; BEGIN(C_COMMENT_2);
X	YY_BREAK
Xcase 50:
X# line 234 "scan.l"
X{
X			/* this rule is separate from the one below because
X			 * otherwise we get variable trailing context, so
X			 * we can't build the scanner using -{f,F}
X			 */
X			bracelevel = 0;
X			continued_action = false;
X			BEGIN(ACTION);
X			return ( '\n' );
X			}
X	YY_BREAK
Xcase 51:
X*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
Xyy_c_buf_p = yy_cp -= 1;
XYY_DO_BEFORE_ACTION; /* set up yytext again */
X# line 245 "scan.l"
X{
X			bracelevel = 0;
X			continued_action = false;
X			BEGIN(ACTION);
X			return ( '\n' );
X			}
X	YY_BREAK
Xcase 52:
X# line 252 "scan.l"
X++linenum; return ( '\n' );
X	YY_BREAK
Xcase 53:
X# line 254 "scan.l"
Xreturn ( EOF_OP );
X	YY_BREAK
Xcase 54:
X# line 256 "scan.l"
X{
X			sectnum = 3;
X			BEGIN(SECT3);
X			return ( EOF ); /* to stop the parser */
X			}
X	YY_BREAK
Xcase 55:
X# line 262 "scan.l"
X{
X			int cclval;
X
X			(void) strcpy( nmstr, yytext );
X
X			/* check to see if we've already encountered this ccl */
X			if ( (cclval = ccllookup( nmstr )) )
X			    {
X			    yylval = cclval;
X			    ++cclreuse;
X			    return ( PREVCCL );
X			    }
X			else
X			    {
X			    /* we fudge a bit.  We know that this ccl will
X			     * soon be numbered as lastccl + 1 by cclinit
X			     */
X			    cclinstal( nmstr, lastccl + 1 );
X
X			    /* push back everything but the leading bracket
X			     * so the ccl can be rescanned
X			     */
X			    PUT_BACK_STRING(nmstr, 1);
X
X			    BEGIN(FIRSTCCL);
X			    return ( '[' );
X			    }
X			}
X	YY_BREAK
Xcase 56:
X# line 291 "scan.l"
X{
X			register char *nmdefptr;
X			char *ndlookup();
X
X			(void) strcpy( nmstr, yytext );
X			nmstr[yyleng - 1] = '\0';  /* chop trailing brace */
X
X			/* lookup from "nmstr + 1" to chop leading brace */
X			if ( ! (nmdefptr = ndlookup( nmstr + 1 )) )
X			    synerr( "undefined {name}" );
X
X			else
X			    { /* push back name surrounded by ()'s */
X			    unput(')');
X			    PUT_BACK_STRING(nmdefptr, 0);
X			    unput('(');
X			    }
X			}
X	YY_BREAK
Xcase 57:
X# line 310 "scan.l"
Xreturn ( yytext[0] );
X	YY_BREAK
Xcase 58:
X# line 311 "scan.l"
XRETURNCHAR;
X	YY_BREAK
Xcase 59:
X# line 312 "scan.l"
X++linenum; return ( '\n' );
X	YY_BREAK
Xcase 60:
X# line 315 "scan.l"
Xreturn ( ',' );
X	YY_BREAK
Xcase 61:
X# line 316 "scan.l"
XBEGIN(SECT2); return ( '>' );
X	YY_BREAK
Xcase 62:
X*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
Xyy_c_buf_p = yy_cp = yy_bp + 1;
XYY_DO_BEFORE_ACTION; /* set up yytext again */
X# line 317 "scan.l"
XBEGIN(CARETISBOL); return ( '>' );
X	YY_BREAK
Xcase 63:
X# line 318 "scan.l"
XRETURNNAME;
X	YY_BREAK
Xcase 64:
X# line 319 "scan.l"
Xsynerr( "bad start condition name" );
X	YY_BREAK
Xcase 65:
X# line 321 "scan.l"
XBEGIN(SECT2); return ( '^' );
X	YY_BREAK
Xcase 66:
X# line 324 "scan.l"
XRETURNCHAR;
X	YY_BREAK
Xcase 67:
X# line 325 "scan.l"
XBEGIN(SECT2); return ( '"' );
X	YY_BREAK
Xcase 68:
X# line 327 "scan.l"
X{
X			synerr( "missing quote" );
X			BEGIN(SECT2);
X			++linenum;
X			return ( '"' );
X			}
X	YY_BREAK
Xcase 69:
X*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
Xyy_c_buf_p = yy_cp = yy_bp + 1;
XYY_DO_BEFORE_ACTION; /* set up yytext again */
X# line 335 "scan.l"
XBEGIN(CCL); return ( '^' );
X	YY_BREAK
Xcase 70:
X*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
Xyy_c_buf_p = yy_cp = yy_bp + 1;
XYY_DO_BEFORE_ACTION; /* set up yytext again */
X# line 336 "scan.l"
Xreturn ( '^' );
X	YY_BREAK
Xcase 71:
X# line 337 "scan.l"
XBEGIN(CCL); yylval = '-'; return ( CHAR );
X	YY_BREAK
Xcase 72:
X# line 338 "scan.l"
XBEGIN(CCL); RETURNCHAR;
X	YY_BREAK
Xcase 73:
X*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
Xyy_c_buf_p = yy_cp = yy_bp + 1;
XYY_DO_BEFORE_ACTION; /* set up yytext again */
X# line 340 "scan.l"
Xreturn ( '-' );
X	YY_BREAK
Xcase 74:
X# line 341 "scan.l"
XRETURNCHAR;
X	YY_BREAK
Xcase 75:
X# line 342 "scan.l"
XBEGIN(SECT2); return ( ']' );
X	YY_BREAK
Xcase 76:
X# line 345 "scan.l"
X{
X			yylval = myctoi( yytext );
X			return ( NUMBER );
X			}
X	YY_BREAK
Xcase 77:
X# line 350 "scan.l"
Xreturn ( ',' );
X	YY_BREAK
Xcase 78:
X# line 351 "scan.l"
XBEGIN(SECT2); return ( '}' );
X	YY_BREAK
Xcase 79:
X# line 353 "scan.l"
X{
X			synerr( "bad character inside {}'s" );
X			BEGIN(SECT2);
X			return ( '}' );
X			}
X	YY_BREAK
Xcase 80:
X# line 359 "scan.l"
X{
X			synerr( "missing }" );
X			BEGIN(SECT2);
X			++linenum;
X			return ( '}' );
X			}
X	YY_BREAK
Xcase 81:
X# line 367 "scan.l"
Xsynerr( "bad name in {}'s" ); BEGIN(SECT2);
X	YY_BREAK
Xcase 82:
X# line 368 "scan.l"
Xsynerr( "missing }" ); ++linenum; BEGIN(SECT2);
X	YY_BREAK
Xcase 83:
X# line 371 "scan.l"
Xbracelevel = 0;
X	YY_BREAK
Xcase 84:
X# line 372 "scan.l"
XACTION_ECHO; CHECK_REJECT(yytext);
X	YY_BREAK
Xcase 85:
X# line 373 "scan.l"
XACTION_ECHO; CHECK_YYMORE(yytext);
X	YY_BREAK
Xcase 86:
X# line 374 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase 87:
X# line 375 "scan.l"
X{
X			++linenum;
X			ACTION_ECHO;
X			if ( bracelevel == 0 )
X			    {
X			    fputs( "\tYY_BREAK\n", temp_action_file );
X			    BEGIN(SECT2);
X			    }
X			}
X	YY_BREAK
X	/* REJECT and yymore() are checked for above, in PERCENT_BRACE_ACTION */
Xcase 88:
X# line 386 "scan.l"
XACTION_ECHO; ++bracelevel;
X	YY_BREAK
Xcase 89:
X# line 387 "scan.l"
XACTION_ECHO; --bracelevel;
X	YY_BREAK
Xcase 90:
X# line 388 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase 91:
X# line 389 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase 92:
X# line 390 "scan.l"
XACTION_ECHO; BEGIN(ACTION_COMMENT);
X	YY_BREAK
Xcase 93:
X# line 391 "scan.l"
XACTION_ECHO; /* character constant */
X	YY_BREAK
Xcase 94:
X# line 392 "scan.l"
XACTION_ECHO; BEGIN(ACTION_STRING);
X	YY_BREAK
Xcase 95:
X# line 393 "scan.l"
X{
X			++linenum;
X			ACTION_ECHO;
X			if ( bracelevel == 0 )
X			    {
X			    fputs( "\tYY_BREAK\n", temp_action_file );
X			    BEGIN(SECT2);
X			    }
X			}
X	YY_BREAK
Xcase 96:
X# line 402 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase 97:
X# line 404 "scan.l"
XACTION_ECHO; BEGIN(ACTION);
X	YY_BREAK
Xcase 98:
X# line 405 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase 99:
X# line 406 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase 100:
X# line 407 "scan.l"
X++linenum; ACTION_ECHO;
X	YY_BREAK
Xcase 101:
X# line 408 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase 102:
X# line 410 "scan.l"
XACTION_ECHO; BEGIN(SECT2);
X	YY_BREAK
Xcase 103:
X# line 411 "scan.l"
X++linenum; ACTION_ECHO; BEGIN(SECT2);
X	YY_BREAK
Xcase 104:
X# line 412 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase 105:
X# line 413 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase 106:
X# line 414 "scan.l"
X++linenum; ACTION_ECHO;
X	YY_BREAK
Xcase 107:
X# line 416 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase 108:
X# line 417 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase 109:
X# line 418 "scan.l"
X++linenum; ACTION_ECHO;
X	YY_BREAK
Xcase 110:
X# line 419 "scan.l"
XACTION_ECHO; BEGIN(ACTION);
X	YY_BREAK
Xcase 111:
X# line 420 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase 112:
X# line 423 "scan.l"
X{
X			yylval = myesc( yytext );
X			return ( CHAR );
X			}
X	YY_BREAK
Xcase 113:
X# line 428 "scan.l"
X{
X			yylval = myesc( yytext );
X			BEGIN(CCL);
X			return ( CHAR );
X			}
X	YY_BREAK
Xcase 114:
X# line 435 "scan.l"
XECHO;
X	YY_BREAK
Xcase 115:
X# line 436 "scan.l"
XYY_FATAL_ERROR( "flex scanner jammed" );
X	YY_BREAK
Xcase YY_STATE_EOF(INITIAL):
Xcase YY_STATE_EOF(SECT2):
Xcase YY_STATE_EOF(SECT3):
Xcase YY_STATE_EOF(CODEBLOCK):
Xcase YY_STATE_EOF(PICKUPDEF):
Xcase YY_STATE_EOF(SC):
Xcase YY_STATE_EOF(CARETISBOL):
Xcase YY_STATE_EOF(NUM):
Xcase YY_STATE_EOF(QUOTE):
Xcase YY_STATE_EOF(FIRSTCCL):
Xcase YY_STATE_EOF(CCL):
Xcase YY_STATE_EOF(ACTION):
Xcase YY_STATE_EOF(RECOVER):
Xcase YY_STATE_EOF(BRACEERROR):
Xcase YY_STATE_EOF(C_COMMENT):
Xcase YY_STATE_EOF(C_COMMENT_2):
Xcase YY_STATE_EOF(ACTION_COMMENT):
Xcase YY_STATE_EOF(ACTION_STRING):
Xcase YY_STATE_EOF(PERCENT_BRACE_ACTION):
Xcase YY_STATE_EOF(USED_LIST):
X    yyterminate();
X
X		case YY_END_OF_BUFFER:
X		    /* undo the effects of YY_DO_BEFORE_ACTION */
X		    *yy_cp = yy_hold_char;
X
X		    yytext = yy_bp;
X
X		    switch ( yy_get_next_buffer() )
X			{
X			case EOB_ACT_END_OF_FILE:
X			    {
X			    if ( yywrap() )
X				{
X				/* note: because we've taken care in
X				 * yy_get_next_buffer() to have set up yytext,
X				 * we can now set up yy_c_buf_p so that if some
X				 * total hoser (like flex itself) wants
X				 * to call the scanner after we return the
X				 * YY_NULL, it'll still work - another YY_NULL
X				 * will get returned.
X				 */
X				yy_c_buf_p = yytext;
X
X				yy_act = YY_STATE_EOF((yy_start - 1) / 2);
X				goto do_action;
X				}
X
X			    else
X				YY_NEW_FILE;
X			    }
X			    break;
X
X			case EOB_ACT_RESTART_SCAN:
X			    yy_c_buf_p = yytext;
X			    yy_hold_char = *yy_c_buf_p;
X			    break;
X
X			case EOB_ACT_LAST_MATCH:
X			    yy_c_buf_p = &yy_ch_buf[yy_n_chars];
X
X			    yy_current_state = yy_get_previous_state();
X
X			    yy_cp = yy_c_buf_p;
X			    yy_bp = yytext;
X			    continue; /* go to "YY_DO_BEFORE_ACTION" */
X			}
X		    break;
X
X		default:
X		    printf( "action # %d\n", yy_act );
X		    YY_FATAL_ERROR( "fatal flex scanner internal error" );
X		}
X
X	    break; /* exit bogus while loop */
X	    }
X	}
X    }
X
X
X/* yy_get_next_buffer - try to read in new buffer
X *
X * synopsis
X *     int yy_get_next_buffer();
X *     
X * returns a code representing an action
X *     EOB_ACT_LAST_MATCH - 
X *     EOB_ACT_RESTART_SCAN - restart the scanner
X *     EOB_ACT_END_OF_FILE - end of file
X */
X
Xstatic int yy_get_next_buffer()
X
X    {
X    register char *dest = yy_ch_buf;
X    register char *source = yytext - 1; /* copy prev. char, too */
X    register int number_to_move, i;
X    int ret_val;
X    
X    if ( yy_c_buf_p != &yy_ch_buf[yy_n_chars + 1] )
X	{
X	YY_FATAL_ERROR( "NULL in input" );
X	/*NOTREACHED*/
X	}
X
X    /* try to read more data */
X
X    /* first move last chars to start of buffer */
X    number_to_move = yy_c_buf_p - yytext;
X
X    for ( i = 0; i < number_to_move; ++i )
X	*(dest++) = *(source++);
X
X    if ( yy_eof_has_been_seen )
X	/* don't do the read, it's not guaranteed to return an EOF,
X	 * just force an EOF
X	 */
X	yy_n_chars = 0;
X
X    else
X	{
X	int num_to_read = YY_BUF_SIZE - number_to_move - 1;
X
X	if ( num_to_read > YY_READ_BUF_SIZE )
X	    num_to_read = YY_READ_BUF_SIZE;
X
X	/* read in more data */
X	YY_INPUT( (&yy_ch_buf[number_to_move]), yy_n_chars, num_to_read );
X	}
X
X    if ( yy_n_chars == 0 )
X	{
X	if ( number_to_move == 1 )
X	    ret_val = EOB_ACT_END_OF_FILE;
X	else
X	    ret_val = EOB_ACT_LAST_MATCH;
X
X	yy_eof_has_been_seen = 1;
X	}
X
X    else
X	ret_val = EOB_ACT_RESTART_SCAN;
X
X    yy_n_chars += number_to_move;
X    yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
X    yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
X
X    /* yytext begins at the second character in
X     * yy_ch_buf; the first character is the one which
X     * preceded it before reading in the latest buffer;
X     * it needs to be kept around in case it's a
X     * newline, so yy_get_previous_state() will have
X     * with '^' rules active
X     */
X
X    yytext = &yy_ch_buf[1];
X
X    return ( ret_val );
X    }
X
X
X/* yy_get_previous_state - get the state just before the EOB char was reached
X *
X * synopsis
X *     yy_state_type yy_get_previous_state();
X */
X
Xstatic yy_state_type yy_get_previous_state()
X
X    {
X    register yy_state_type yy_current_state;
X    register char *yy_cp;
X
X    register char *yy_bp = yytext;
X
X    yy_current_state = yy_start;
X    if ( yy_bp[-1] == '\n' )
X	++yy_current_state;
X
X    for ( yy_cp = yytext; yy_cp < yy_c_buf_p; ++yy_cp )
X	{
X	register char yy_c = yy_ec[*yy_cp];
X	if ( yy_accept[yy_current_state] )
X	    {
X	    yy_last_accepting_state = yy_current_state;
X	    yy_last_accepting_cpos = yy_cp;
X	    }
X	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X	    {
X	    yy_current_state = yy_def[yy_current_state];
X	    if ( yy_current_state >= 317 )
X		yy_c = yy_meta[yy_c];
X	    }
X	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X	}
X
X    return ( yy_current_state );
X    }
X
X
X#ifdef __STDC__
Xstatic void yyunput( int c, register char *yy_bp )
X#else
Xstatic void yyunput( c, yy_bp )
Xint c;
Xregister char *yy_bp;
X#endif
X
X    {
X    register char *yy_cp = yy_c_buf_p;
X
X    *yy_cp = yy_hold_char; /* undo effects of setting up yytext */
X
X    if ( yy_cp < yy_ch_buf + 2 )
X	{ /* need to shift things up to make room */
X	register int number_to_move = yy_n_chars + 2; /* +2 for EOB chars */
X	register char *dest = &yy_ch_buf[YY_BUF_SIZE + 2];
X	register char *source = &yy_ch_buf[number_to_move];
X
X	while ( source > yy_ch_buf )
X	    *--dest = *--source;
X
X	yy_cp += dest - source;
X	yy_bp += dest - source;
X
X	if ( yy_cp < yy_ch_buf + 2 )
X	    YY_FATAL_ERROR( "flex scanner push-back overflow" );
X	}
X
X    if ( yy_cp > yy_bp && yy_cp[-1] == '\n' )
X	yy_cp[-2] = '\n';
X
X    *--yy_cp = c;
X
X    YY_DO_BEFORE_ACTION; /* set up yytext again */
X    }
X
X
Xstatic int input()
X
X    {
X    int c;
X    char *yy_cp = yy_c_buf_p;
X
X    *yy_cp = yy_hold_char;
X
X    if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
X	{ /* need more input */
X	yytext = yy_c_buf_p;
X	++yy_c_buf_p;
X
X	switch ( yy_get_next_buffer() )
X	    {
X	    /* this code, unfortunately, is somewhat redundant with
X	     * that above
X	     */
X	    case EOB_ACT_END_OF_FILE:
X		{
X		if ( yywrap() )
X		    {
X		    yy_c_buf_p = yytext;
X		    return ( EOF );
X		    }
X
X		yy_ch_buf[0] = '\n';
X		yy_n_chars = 1;
X		yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
X		yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
X		yy_eof_has_been_seen = 0;
X		yytext = yy_c_buf_p = &yy_ch_buf[1];
X		yy_hold_char = *yy_c_buf_p;
X
X		return ( input() );
X		}
X		break;
X
X	    case EOB_ACT_RESTART_SCAN:
X		yy_c_buf_p = yytext;
X		break;
X
X	    case EOB_ACT_LAST_MATCH:
X		YY_FATAL_ERROR( "unexpected last match in input()" );
X	    }
X	}
X
X    c = *yy_c_buf_p;
X    yy_hold_char = *++yy_c_buf_p;
X
X    return ( c );
X    }
X
X
X#ifdef __STDC__
Xstatic void yyrestart( FILE *input_file )
X#else
Xstatic void yyrestart( input_file )
XFILE *input_file;
X#endif
X
X    {
X    if ( yyin != stdin )
X	fclose( yyin );
X
X    yyin = input_file;
X    yy_init = 1;
X    }
X# line 436 "scan.l"
X
END_OF_FILE
if test 53057 -ne `wc -c <'flex/initscan.c'`; then
    echo shar: \"'flex/initscan.c'\" unpacked with wrong size!
fi
# end of 'flex/initscan.c'
fi
echo shar: End of archive 7 \(of 7\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
