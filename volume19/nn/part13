Subject:  v19i074:  NN, a Usenet news reader, Part13/15
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: storm@texas.dk (Kim F. Storm)
Posting-number: Volume 19, Issue 74
Archive-name: nn/part13

#!/bin/sh
# this is part 13 of a multipart archive
# do not concatenate these parts, unpack them in order with /bin/sh
# file regexp.c continued
#
CurArch=13
if test ! -r s2_seq_.tmp
then echo "Please unpack part 1 first!"
     exit 1; fi
( read Scheck
  if test "$Scheck" != $CurArch
  then echo "Please unpack part $Scheck next!"
       exit 1;
  else exit 0; fi
) < s2_seq_.tmp || exit 1
echo "x - Continuing file regexp.c"
sed 's/^X//' << 'NO_NEWS_IS_GOOD_NEWS' >> regexp.c
X */
Xstatic void regoptail(p, val)
Xchar           *p;
Xchar           *val;
X{
X    /* "Operandless" and "op != BRANCH" are synonymous in practice. */
X    if (p == NULL || p == &regdummy || OP(p) != BRANCH)
X	return;
X    regtail(OPERAND(p), val);
X}
X
X/*
X * regexec and friends
X */
X
X/*
X * Global work variables for regexec().
X */
Xstatic char    *reginput;	/* String-input pointer. */
Xstatic char    *regbol;		/* Beginning of input, for ^ check. */
Xstatic char   **regstartp;	/* Pointer to startp array. */
Xstatic char   **regendp;	/* Ditto for endp. */
X
X/*
X * Forwards.
X */
XSTATIC int      regtry();
XSTATIC int      regmatch();
XSTATIC int      regrepeat();
X
X#ifdef DEBUG
Xint             regnarrate = 0;
Xvoid            regdump();
XSTATIC char    *regprop();
X#endif
X
X/*
X - regexec - match a regexp against a string
X */
Xint regexec(prog, string)
Xregister regexp *prog;
Xregister char  *string;
X{
X    register char  *s;
X
X    /* Be paranoid... */
X    if (prog == NULL || string == NULL) {
X	regerror("NULL parameter");
X	return (0);
X    }
X    /* Check validity of program. */
X    if (UCHARAT(prog->program) != MAGIC) {
X	regerror("corrupted program");
X	return (0);
X    }
X    /* If there is a "must appear" string, look for it. */
X    if (prog->regmust != NULL) {
X	s = string;
X	while ((s = strchr(s, prog->regmust[0])) != NULL) {
X	    if (strncmp(s, prog->regmust, prog->regmlen) == 0)
X		break;		/* Found it. */
X	    s++;
X	}
X	if (s == NULL)		/* Not present. */
X	    return (0);
X    }
X    /* Mark beginning of line for ^ . */
X    regbol = string;
X
X    /* Simplest case:  anchored match need be tried only once. */
X    if (prog->reganch)
X	return (regtry(prog, string));
X
X    /* Messy cases:  unanchored match. */
X    s = string;
X    if (prog->regstart != '\0')
X	/* We know what char it must start with. */
X	while ((s = strchr(s, prog->regstart)) != NULL) {
X	    if (regtry(prog, s))
X		return (1);
X	    s++;
X	}
X    else
X	/* We don't -- general case. */
X	do {
X	    if (regtry(prog, s))
X		return (1);
X	} while (*s++ != '\0');
X
X    /* Failure. */
X    return (0);
X}
X
X/*
X - regtry - try match at specific point
X */
X#ifdef __STDC__
X
Xstatic int regtry(regexp *prog, char *string)
X
X#else
X
Xstatic int regtry(prog, string)
Xregexp         *prog;
Xchar           *string;
X
X#endif
X{
X    register int    i;
X    register char **sp;
X    register char **ep;
X
X    reginput = string;
X    regstartp = prog->startp;
X    regendp = prog->endp;
X
X    sp = prog->startp;
X    ep = prog->endp;
X    for (i = NSUBEXP; i > 0; i--) {
X	*sp++ = NULL;
X	*ep++ = NULL;
X    }
X    if (regmatch(prog->program + 1)) {
X	prog->startp[0] = string;
X	prog->endp[0] = reginput;
X	return (1);
X    } else
X	return (0);
X}
X
X/*
X - regmatch - main matching routine
X *
X * Conceptually the strategy is simple:  check to see whether the current
X * node matches, call self recursively to see whether the rest matches,
X * and then act accordingly.  In practice we make some effort to avoid
X * recursion, in particular by going through "ordinary" nodes (that don't
X * need to know whether the rest of the match failed) by a loop instead of
X * by recursion.
X */
X#ifdef __STDC__
X
Xstatic int regmatch(char *prog)
X
X#else
X
Xstatic int regmatch(prog)
Xchar           *prog;
X
X#endif
X{
X    register char  *scan;	/* Current node. */
X    char           *nxt;	/* nxt node. */
X
X    scan = prog;
X#ifdef DEBUG
X    if (scan != NULL && regnarrate)
X	fprintf(stderr, "%s(\n", regprop(scan));
X#endif
X    while (scan != NULL) {
X#ifdef DEBUG
X	if (regnarrate)
X	    fprintf(stderr, "%s...\n", regprop(scan));
X#endif
X	nxt = regnext(scan);
X
X	switch (OP(scan)) {
X	case BOL:
X	    if (reginput != regbol)
X		return (0);
X	    break;
X	case EOL:
X	    if (*reginput != '\0')
X		return (0);
X	    break;
X	case ANY:
X	    if (*reginput == '\0')
X		return (0);
X	    reginput++;
X	    break;
X	case EXACTLY:{
X		register int    len;
X		register char  *opnd;
X
X		opnd = OPERAND(scan);
X		/* Inline the first character, for speed. */
X		if (*opnd != *reginput)
X		    return (0);
X		len = strlen(opnd);
X		if (len > 1 && strncmp(opnd, reginput, len) != 0)
X		    return (0);
X		reginput += len;
X	    }
X	    break;
X	case ANYOF:
X	    if (*reginput == '\0' || strchr(OPERAND(scan), *reginput) == NULL)
X		return (0);
X	    reginput++;
X	    break;
X	case ANYBUT:
X	    if (*reginput == '\0' || strchr(OPERAND(scan), *reginput) != NULL)
X		return (0);
X	    reginput++;
X	    break;
X	case NOTHING:
X	    break;
X	case BACK:
X	    break;
X	case OPEN + 1:
X	case OPEN + 2:
X	case OPEN + 3:
X	case OPEN + 4:
X	case OPEN + 5:
X	case OPEN + 6:
X	case OPEN + 7:
X	case OPEN + 8:
X	case OPEN + 9:{
X		register int    no;
X		register char  *save;
X
X		no = OP(scan) - OPEN;
X		save = reginput;
X
X		if (regmatch(nxt)) {
X		    /*
X		     * Don't set startp if some later invocation of the same
X		     * parentheses already has. 
X		     */
X		    if (regstartp[no] == NULL)
X			regstartp[no] = save;
X		    return (1);
X		} else
X		    return (0);
X	    }
X	    break;
X	case CLOSE + 1:
X	case CLOSE + 2:
X	case CLOSE + 3:
X	case CLOSE + 4:
X	case CLOSE + 5:
X	case CLOSE + 6:
X	case CLOSE + 7:
X	case CLOSE + 8:
X	case CLOSE + 9:{
X		register int    no;
X		register char  *save;
X
X		no = OP(scan) - CLOSE;
X		save = reginput;
X
X		if (regmatch(nxt)) {
X		    /*
X		     * Don't set endp if some later invocation of the same
X		     * parentheses already has. 
X		     */
X		    if (regendp[no] == NULL)
X			regendp[no] = save;
X		    return (1);
X		} else
X		    return (0);
X	    }
X	    break;
X	case BRANCH:{
X		register char  *save;
X
X		if (OP(nxt) != BRANCH)	/* No choice. */
X		    nxt = OPERAND(scan);	/* Avoid recursion. */
X		else {
X		    do {
X			save = reginput;
X			if (regmatch(OPERAND(scan)))
X			    return (1);
X			reginput = save;
X			scan = regnext(scan);
X		    } while (scan != NULL && OP(scan) == BRANCH);
X		    return (0);
X		    /* NOTREACHED */
X		}
X	    }
X	    break;
X	case STAR:{
X		register char   nextch;
X		register int    no;
X		register char  *save;
X		register int    min;
X
X		/*
X		 * Lookahead to avoid useless match attempts when we know
X		 * what character comes next. 
X		 */
X		nextch = '\0';
X		if (OP(nxt) == EXACTLY)
X		    nextch = *OPERAND(nxt);
X		min = (OP(scan) == STAR) ? 0 : 1;
X		save = reginput;
X		no = regrepeat(OPERAND(scan));
X		while (no >= min) {
X		    /* If it could work, try it. */
X		    if (nextch == '\0' || *reginput == nextch)
X			if (regmatch(nxt))
X			    return (1);
X		    /* Couldn't or didn't -- back up. */
X		    no--;
X		    reginput = save + no;
X		}
X		return (0);
X	    }
X	    break;
X	case END:
X	    return (1);		/* Success! */
X	    break;
X	default:
X	    regerror("memory corruption");
X	    return (0);
X	    break;
X	}
X
X	scan = nxt;
X    }
X
X    /*
X     * We get here only if there's trouble -- normally "case END" is the
X     * terminating point. 
X     */
X    regerror("corrupted pointers");
X    return (0);
X}
X
X/*
X - regrepeat - repeatedly match something simple, report how many
X */
X#ifdef __STDC__
X
Xstatic int regrepeat(char *p)
X
X#else
X
Xstatic int regrepeat(p)
Xchar           *p;
X
X#endif
X{
X    register int    count = 0;
X    register char  *scan;
X    register char  *opnd;
X
X    scan = reginput;
X    opnd = OPERAND(p);
X    switch (OP(p)) {
X    case ANY:
X	count = strlen(scan);
X	scan += count;
X	break;
X    case EXACTLY:
X	while (*opnd == *scan) {
X	    count++;
X	    scan++;
X	}
X	break;
X    case ANYOF:
X	while (*scan != '\0' && strchr(opnd, *scan) != NULL) {
X	    count++;
X	    scan++;
X	}
X	break;
X    case ANYBUT:
X	while (*scan != '\0' && strchr(opnd, *scan) == NULL) {
X	    count++;
X	    scan++;
X	}
X	break;
X    default:			/* Oh dear.  Called inappropriately. */
X	regerror("internal foulup");
X	count = 0;		/* Best compromise. */
X	break;
X    }
X    reginput = scan;
X
X    return (count);
X}
X
X
X/*
X - regnext - dig the "nxt" pointer out of a node
X */
X#ifdef __STDC__
X
Xstatic char *regnext(register char *p)
X
X#else
X
Xstatic char *regnext(p)
Xregister char  *p;
X
X#endif
X{
X    register int    offset;
X
X    if (p == &regdummy)
X	return (NULL);
X
X    offset = NEXT(p);
X    if (offset == 0)
X	return (NULL);
X
X    if (OP(p) == BACK)
X	return (p - offset);
X    else
X	return (p + offset);
X}
X
X#ifdef DEBUG
X
XSTATIC char    *regprop();
X
X/*
X - regdump - dump a regexp onto stdout in vaguely comprehensible form
X */
X#ifdef __STDC__
X
Xvoid regdump(regexp *r)
X
X#else
X
Xvoid regdump(r)
Xregexp         *r;
X
X#endif
X{
X    register char  *s;
X    register char   op = EXACTLY;	/* Arbitrary non-END op. */
X    register char  *nxt;
X    extern char    *strchr();
X
X
X    s = r->program + 1;
X    while (op != END) {		/* While that wasn't END last time... */
X	op = OP(s);
X	printf("%2d%s", s - r->program, regprop(s));	/* Where, what. */
X	nxt = regnext(s);
X	if (nxt == NULL)	/* nxt ptr. */
X	    printf("(0)");
X	else
X	    printf("(%d)", (s - r->program) + (nxt - s));
X	s += 3;
X	if (op == ANYOF || op == ANYBUT || op == EXACTLY) {
X	    /* Literal string, where present. */
X	    while (*s != '\0') {
X		putchar(*s);
X		s++;
X	    }
X	    s++;
X	}
X	putchar('\n');
X    }
X
X    /* Header fields of interest. */
X    if (r->regstart != '\0')
X	printf("start `%c' ", r->regstart);
X    if (r->reganch)
X	printf("anchored ");
X    if (r->regmust != NULL)
X	printf("must have \"%s\"", r->regmust);
X    printf("\n");
X}
X
X/*
X - regprop - printable representation of opcode
X */
X#ifdef __STDC__
X
Xstatic char *regprop(char *op)
X
X#else
X
Xstatic char *regprop(op)
Xchar           *op;
X
X#endif
X{
X    register char  *p;
X    static char     buf[50];
X
X    strcpy(buf, ":");
X
X    switch (OP(op)) {
X    case BOL:
X	p = "BOL";
X	break;
X    case EOL:
X	p = "EOL";
X	break;
X    case ANY:
X	p = "ANY";
X	break;
X    case ANYOF:
X	p = "ANYOF";
X	break;
X    case ANYBUT:
X	p = "ANYBUT";
X	break;
X    case BRANCH:
X	p = "BRANCH";
X	break;
X    case EXACTLY:
X	p = "EXACTLY";
X	break;
X    case NOTHING:
X	p = "NOTHING";
X	break;
X    case BACK:
X	p = "BACK";
X	break;
X    case END:
X	p = "END";
X	break;
X    case OPEN + 1:
X    case OPEN + 2:
X    case OPEN + 3:
X    case OPEN + 4:
X    case OPEN + 5:
X    case OPEN + 6:
X    case OPEN + 7:
X    case OPEN + 8:
X    case OPEN + 9:
X	sprintf(buf + strlen(buf), "OPEN%d", OP(op) - OPEN);
X	p = NULL;
X	break;
X    case CLOSE + 1:
X    case CLOSE + 2:
X    case CLOSE + 3:
X    case CLOSE + 4:
X    case CLOSE + 5:
X    case CLOSE + 6:
X    case CLOSE + 7:
X    case CLOSE + 8:
X    case CLOSE + 9:
X	sprintf(buf + strlen(buf), "CLOSE%d", OP(op) - CLOSE);
X	p = NULL;
X	break;
X    case STAR:
X	p = "STAR";
X	break;
X    default:
X	regerror("corrupted opcode");
X	break;
X    }
X    if (p != NULL)
X	strcat(buf, p);
X    return (buf);
X}
X#endif
X
X/*
X * The following is provided for those people who do not have strcspn() in
X * their C libraries.  They should get off their butts and do something
X * about it; at least one public-domain implementation of those (highly
X * useful) string routines has been published on Usenet.
X */
X#ifdef STRCSPN
X/*
X * strcspn - find length of initial segment of s1 consisting entirely
X * of characters not from s2
X */
X
X#ifdef __STDC__
X
Xstatic int strcspn(char *s1, char *s2)
X
X#else
X
Xstatic int strcspn(s1, s2)
Xchar           *s1;
Xchar           *s2;
X
X#endif
X{
X    register char  *scan1;
X    register char  *scan2;
X    register int    count;
X
X    count = 0;
X    for (scan1 = s1; *scan1 != '\0'; scan1++) {
X	for (scan2 = s2; *scan2 != '\0';)	/* ++ moved down. */
X	    if (*scan1 == *scan2++)
X		return (count);
X	count++;
X    }
X    return (count);
X}
X#endif
X
X
X/*
X - regsub - perform substitutions after a regexp match
X */
X#ifdef __STDC__
X
Xvoid regsub(regexp *prog, char *source, char *dest)
X
X#else
X
Xvoid regsub(prog, source, dest)
Xregexp         *prog;
Xchar           *source;
Xchar           *dest;
X
X#endif
X{
X    register char  *src;
X    register char  *dst;
X    register char   c;
X    register int    no;
X    register int    len;
X    extern char    *strncpy();
X
X    if (prog == NULL || source == NULL || dest == NULL) {
X	regerror("NULL parm to regsub");
X	return;
X    }
X    if (UCHARAT(prog->program) != MAGIC) {
X	regerror("damaged regexp fed to regsub");
X	return;
X    }
X    src = source;
X    dst = dest;
X    while ((c = *src++) != '\0') {
X	if (c == '&')
X	    no = 0;
X	else if (c == '\\' && '0' <= *src && *src <= '9')
X	    no = *src++ - '0';
X	else
X	    no = -1;
X
X	if (no < 0) {		/* Ordinary character. */
X	    if (c == '\\' && (*src == '\\' || *src == '&'))
X		c = *src++;
X	    *dst++ = c;
X	} else if (prog->startp[no] != NULL && prog->endp[no] != NULL) {
X	    len = prog->endp[no] - prog->startp[no];
X	    strncpy(dst, prog->startp[no], len);
X	    dst += len;
X	    if (len != 0 && *(dst - 1) == '\0') {	/* strncpy hit NUL. */
X		regerror("damaged match string");
X		return;
X	    }
X	}
X    }
X    *dst++ = '\0';
X}
X
X
X#ifdef __STDC__
X
Xvoid regerror(char *s)
X
X#else
X
Xvoid regerror(s)
Xchar           *s;
X
X#endif
X{
X#ifdef NN
X    msg("REGEXP ERROR: %s", s);
X#else    
X    fprintf(stderr, "regexp(3): %s", s);
X    exit(1);
X#endif
X}
NO_NEWS_IS_GOOD_NEWS
echo "File regexp.c is complete"
chmod 0644 regexp.c || echo "restore of regexp.c fails"
set `wc -c regexp.c`;Sum=$1
if test "$Sum" != "30816"
then echo original size 30816, current size $Sum;fi
echo "x - extracting regexp.h (Text)"
sed 's/^X//' << 'NO_NEWS_IS_GOOD_NEWS' > regexp.h &&
X/*
X * Definitions etc. for regexp(3) routines.
X *
X * Caveat:  this is V8 regexp(3) [actually, a reimplementation thereof],
X * not the System V one.
X */
X
X#define NSUBEXP  10
Xtypedef struct regexp {
X	char *startp[NSUBEXP];
X	char *endp[NSUBEXP];
X	char regstart;		/* Internal use only. */
X	char reganch;		/* Internal use only. */
X	char *regmust;		/* Internal use only. */
X	int regmlen;		/* Internal use only. */
X	char program[1];	/* Unwarranted chumminess with compiler. */
X} regexp;
X
X
X/*
X * The first byte of the regexp internal "program" is actually this magic
X * number; the start node begins in the second byte.
X */
X#define	MAGIC	0234
X
Xextern regexp *regcomp();
Xextern int regexec();
Xextern void regsub();
Xextern void regerror();
X
NO_NEWS_IS_GOOD_NEWS
chmod 0644 regexp.h || echo "restore of regexp.h fails"
set `wc -c regexp.h`;Sum=$1
if test "$Sum" != "731"
then echo original size 731, current size $Sum;fi
echo "x - extracting reroute.c (Text)"
sed 's/^X//' << 'NO_NEWS_IS_GOOD_NEWS' > reroute.c &&
X#include "config.h"
X
X#define TRACE
X
X
X#ifdef HAVE_ROUTING
X
Xreroute(route, address)
Xchar *route, *address;
X{
X    char *name, *atpos;
X    register char *sp;
X    register c;
X    
X    if (atpos = strchr(address, '@')) {
X	name = atpos;
X	
X	while (--name >= address)
X	    if (isspace(*name) || *name == '<') { 
X		name++;
X		break;
X	    }
X	if (name < address) name++;
X	
X	for (sp = atpos; c = *sp; sp++) 
X	    if (isspace(c) || c == '>') break;
X
X	*sp = NUL;
X	strcpy(route, name);
X	*sp = c;
X    } else 
X	strcpy(route, address);
X    return 1;
X}
X
X#else
X
X#ifndef HAVE_GETHOSTNAME
X
X#ifdef HAVE_UNAME
X
X#include <sys/utsname.h>
X
Xgethostname(name, length)
Xchar *name;
Xint length;
X{
X    struct utsname utsname;
X    char *host;
X	
X    uname(&utsname);
X    strncpy(name, utsname.nodename, length);
X}
X
X
X#else
X
X#ifdef HOSTNAME
X
Xgethostname(name, length)
Xchar *name;
Xint length;
X{
X    strncpy(name, HOSTNAME, length);
X}
X
X#else
X
XYOU LOOSE ON GETHOSTNAME
X
X#endif /* HOSTNAME */
X
X#endif /* HAVE_UNAME */
X
X#endif /* HAVE_GETHOSTNAME */
X
X
X#ifdef TRACE
XFILE *route_trace = NULL;
X#endif
Xstatic char cmdc;	/* we need this for trace output */
X
Xreroute(route, address)
Xchar *route, *address;
X{
X    char *name, *site, *domain;
X    char *atpos, *dotpos;
X    register char *sp;
X    register c;
X    int found;
X    
X#ifdef TRACE
X    if (route_trace || 
X	(route_trace = open_file(relative(lib_directory, "trace"),
X				OPEN_APPEND | DONT_CREATE)))
X	fprintf(route_trace, "--orig: '%s'\n", address);
X#endif
X
X    found = 0;
X    
X    /* if a sender (or receiver!) is not provided,
X     * we first try the site from the 'Reply-To:'
X     * and 'From:' lines  who@site.domain */
X    
X    if (atpos = strchr(address, '@')) {
X	*atpos = NUL;
X	name = atpos;
X	
X	while (--name >= address)
X	    if (isspace(*name) || *name == '<') { 
X		name++;
X		break;
X	    }
X	if (name < address) name++;
X	
X	dotpos = atpos;
X	site   = atpos + 1;
X
X     next_dot:
X	*dotpos = NUL;
X	domain = dotpos + 1;
X	for (sp = domain; c = *sp; sp++) {
X	    if (isspace(c) || c == '>') break;
X	    if (c == '.') {
X		*dotpos = '.';
X		dotpos = sp;
X		goto next_dot;
X	    }
X	}
X	*sp = NUL;
X	if (site == domain)
X	    domain = NULL;
X	else
X	    *atpos = NUL;	/* overwritten when first . is found */
X
X#ifdef TRACE
X	if (route_trace)
X	    fprintf(route_trace,
X		    "   @-type: name='%s' site='%s' domain='%s'\n",
X		    name, site, domain ? domain : "");
X#endif
X	
X	found = find_route(route, name, site, domain, (char *)NULL);
X	
X	if (dotpos) { *dotpos = '.'; *sp = c; }
X	if (atpos) *atpos = '@';
X
X	goto out;
X    }
X
X    /*
X     * not domain address -- look for bang address
X     */
X
X    if (!(name = strrchr(address, '!'))) {
X	/*
X	 * neither domain nor bang -- suppose it is a local address
X	 */
X	strcpy(route, address);
X	found = 1;
X	goto out;
X    }
X    
X    *name++ = NUL;
X    if (site = strrchr(address, '!'))
X	*site++ = NUL;
X    else {
X	site = address;
X	address = NULL;
X    }
X    
X#ifdef TRACE
X    if (route_trace)
X	fprintf(route_trace,
X		"   !-type: name='%s' site='%s' bang='%s'\n",
X		name, site, address ? address : "NONE");
X#endif
X    
X    found = find_route(route, name, site, (char *)NULL, address);
X    
X    *--name = '!';
X    if (address) *--site = '!';
X
X out:
X
X#ifdef TRACE
X    if (route_trace) {
X	if (found)
X	    fprintf(route_trace, "--route='%s'\n\n", route);
X	else
X	    fprintf(route_trace, "--NO ROUTE\n\n");
X	fclose(route_trace);
X	route_trace = NULL;
X    }
X#endif    
X    return found;
X}
X
X
Xstatic char *cstreq(string, match)
Xchar *string, *match;
X{
X    register char *s1, *s2;
X    s1 = string;
X    
Xnext_part:
X    s2 = match;
X    
X    while (isspace(*s1) || *s1 == ',') s1++;
X
X    while (*s2) {
X	if (*s1 == NUL || isspace(*s1)) return NULL;
X	if (*s1 == ',') goto next_part;
X	if (toupper(*s1) != toupper(*s2)) break;
X	s1++, s2++;
X    }
X    
X    if (*s2 == NUL && (*s1 == NUL || isspace(*s1) || *s1 == ',')) {
X	if (*s1 == ',') while (*s1 && !isspace(*s1)) s1++;
X#ifdef TRACE	    
X	if (route_trace) 
X	    fprintf(route_trace, "/%c %s=%s -> %s", cmdc, string, match, s1);
X#endif	    
X	return s1;
X    }
X    
X    while (*s1 && !isspace(*s1)) {
X	if (*s1 == ',') goto next_part;
X	s1++;
X    }
X    
X    return NULL;
X}
X
X
Xstatic char *cstrcpy(s1, s2)
Xregister char *s1, *s2;
X{
X	while (*s2 && isspace(*s2)) s2++;
X	while (*s2 && !isspace(*s2) && *s2 != ',') *s1++ = *s2++;
X	*s1 = NUL;
X	return s1;
X}
X
X/*
X * lookup site,domain in routes database
X * if not found and bang is non-empty, use bang default if it exist
X */
X
Xstatic find_route(route, remote_user, remote_host, remote_domain, bang)
Xchar *route, *remote_user, *remote_host, *remote_domain, *bang;
X{
X    char line[512];		/* line from route file */
X    register char *lp;		/* current line position */
X    char *routep;	       	/* ptr into route */
X    char *pattern;		/* pattern from line */
X    int  dom_ok;		/* in right domain */
X    int  host_ok;		/* right host */
X    FILE *rf;			/* route file */
X    char local_host[100];	/* callers host name */
X    char local_domain[100];	/* this domain */
X    
X    if (bang && *bang == NUL) bang = NULL;
X    if (remote_host == NULL || *remote_host == NUL) return 0;
X    
X    if (remote_domain && *remote_domain == NUL) remote_domain = NULL;
X    
X    gethostname(local_host, 100);
X    if (routep = strchr(local_host, '.')) *routep = NUL;
X    local_domain[0] = NUL;
X    
X    rf = open_file(relative(lib_directory, "routes"), OPEN_READ);
X    if (rf == NULL) {
X#ifdef TRACE
X	if (route_trace) fprintf(route_trace, "---No routes file\n");
X#endif
X	return 0;
X    }
X    
X    dom_ok = host_ok = 1;
X    routep = route;
X    pattern = NULL;
X    
X    while (fgets(line, 512, rf) != NULL) {
X	lp = line;
X	while (*lp && isspace(*lp)) lp++;
X	if (*lp == NUL || *lp == '#') continue;
X	
X	if (*lp == '/') {
X	    lp++;
X	    cmdc = *lp++;
X	    while (*lp && isspace(*lp)) lp++;
X	    if (*lp == '#') *lp = NUL;
X	    
X	    if (cmdc == 'L') {		/* local (default) domain name(s) */
X		cstrcpy(local_domain, lp);
X
X		if (remote_domain == NULL ||
X		    cstreq(lp, remote_domain) != NULL) {
X		    dom_ok = 1;
X		    if (strcmp(local_host, remote_host) == 0) {
X			pattern = "%p%n";
X			break;
X		    }
X		}
X		continue;
X	    }
X	    
X	    if (cmdc == 'D') {		/* destination domain */
X		if (*lp == NUL)
X		    dom_ok = 1;
X		else
X		    dom_ok = (cstreq(lp, remote_domain) != NULL);
X		continue;
X	    }
X
X	    if (!dom_ok) continue;
X	       
X	    if (cmdc == 'H') {		/* local host */
X		if (*lp == NUL)
X		    host_ok = 1;
X		else
X		    host_ok = (cstreq(lp, local_host) != NULL);
X		continue;
X	    }
X	    
X	    if (!host_ok) continue;
X
X	    switch (cmdc) {
X
X	     case 'N':	/* neighbouring (uucp) sites */
X		if (cstreq(lp, remote_host) == NULL) continue;
X		pattern = "%s!%n";
X		break;
X		
X	     case 'P':
X		if (*lp == '+')
X		    routep = cstrcpy(routep, ++lp);
X		else
X		    routep = cstrcpy(route, lp);
X		continue;
X
X	     case 'G':
X		pattern = lp;
X		break;
X
X	     case 'B':
X		if (!bang) continue;
X		pattern = lp;
X		break;
X
X	     default:
X		continue;
X	    }
X
X	    break;
X	}
X	
X	if (!dom_ok) continue;
X	if (!host_ok) continue;
X
X	if ((pattern = cstreq(lp, remote_host))!=NULL) break;
X    }
X    
X    fclose(rf);
X    
X    if (pattern == NULL) return 0;
X  
X#ifdef TRACE  
X    if (route_trace) fprintf(route_trace, "   pattern='%s'\n", pattern);
X#endif
X    
X    for (; *pattern != NL && *pattern != NUL; pattern++) {
X	if (*pattern == SP || *pattern == TAB) continue;
X	if (*pattern == '%') {
X	    pattern++;
X	    switch(*pattern) {
X	     case 'n':
X		routep = cstrcpy(routep, remote_user);
X		continue;
X	     case 's':
X		routep = cstrcpy(routep, remote_host);
X		continue;
X	     case 'd':
X		routep = cstrcpy(routep, 
X				 remote_domain ? remote_domain : local_domain);
X		continue;
X	     case 'b':
X		routep = cstrcpy(routep, bang);
X		continue;
X	     case 'p':
X		routep = route;
X		continue;
X	     case '%':
X		break;
X	     default:
X		continue;
X	    }
X	}
X	*routep++ = *pattern;
X    }
X    *routep = NUL;
X    
X    return 1;
X}
X
X#endif
NO_NEWS_IS_GOOD_NEWS
chmod 0644 reroute.c || echo "restore of reroute.c fails"
set `wc -c reroute.c`;Sum=$1
if test "$Sum" != "7861"
then echo original size 7861, current size $Sum;fi
echo "x - extracting routes.sample (Text)"
sed 's/^X//' << 'NO_NEWS_IS_GOOD_NEWS' > routes.sample &&
X# This file is read from the beginning until a match for a specific
X# domain/site pair is found.  Initially all lines applies to all
X# domains and hosts.  (NOTICE: we use domain == top-level domain)
X#
X# In the following list of requests, <host name> is the name of the
X# LOCAL host, <domain> and <site> is the receivers domain and site.
X#
X#	/L <domain>	local domain name(s), implies /D <domain> command
X#	/H <local host>	following lines only applies to specified local host
X#	/H		following lines applies to all hosts
X#	/N <site>	site is neighbour to local host (+prefix)
X#	/D <domain>	following lines applies to specified domain only
X#	/D		following lines applies to all domains
X#	/P <prefix>	<prefix> is prefixed to the generated address
X#	/B <pattern>	address to use for multi-hop bang addresses
X#	/G <pattern>	default address pattern
X#	<site> <pattern> address patterns used to reach given site
X#
X# The <domain>, <host>, and <site> specifications can be a comma-separated
X# list of domain, host, or site names (without spaces).
X#
X# Address patterns are copied directly to the generated address, except
X# that the following sequences are substituted:
X#	%n	name of receiver
X#	%s	receiver's site (with top-level domain stripped off)
X#	%d	receiver's top-level domain
X#	%b	first N-1 sites from N multi-hop bang address
X#	%p	drop <preix> if one is specified
X#	%%	a % character
X#
X# Default rules:
X#	%n@local-host.local-domain -> %p%n
X#	%n@neighbour-host.remote-domain -> %s.%d!%n
X#
X# Example configuration (AmbraSoft A/S, September 1987):
X#
X# Backbone:		      dkuug.dk
X#				|
X# In-house:	olamb.dk---- ambush.dk ------ ambra.dk
X#			  /	|   \
X# Direct:          oldk1.dk oldk2.dk  olgb1.uucp(=olgb1.oliv.co.uk)
X#
X# This file can be used unchanged on all in-house systems.
X
X/L dk,uucp
X
X/H ambra,olamb
X/N ambush
X/P 		ambush!
X
X/H
X/N dkuug
X/N ambra,olamb
X/N oldk1,oldk2
X
X/L uucp
X/N olgb1
X
X/D uk
Xolgb1.oliv.co	olgb1!%n
X
X/D
X
X/P+		dkuug!
X
X/B		%b!%s!%n
X/G		%s.%d!%n
NO_NEWS_IS_GOOD_NEWS
chmod 0644 routes.sample || echo "restore of routes.sample fails"
set `wc -c routes.sample`;Sum=$1
if test "$Sum" != "1952"
then echo original size 1952, current size $Sum;fi
echo "x - extracting s-bsd4-2.h (Text)"
sed 's/^X//' << 'NO_NEWS_IS_GOOD_NEWS' > s-bsd4-2.h &&
X/*
X *	This version is for BSD 4.2 systems
X */
X
X
X/*
X *	Include haeder files containing the following definitions:
X *
X * 		off_t, time_t, struct stat
X */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X
X
X/*
X *	Define if your system has system V like ioctls
X */
X
X#undef	HAVE_TERMIO			/* */
X
X/*
X *	Define to use terminfo database.
X *	Otherwise, termcap is used
X */
X
X#undef	USE_TERMINFO			/* */
X
X/*
X *	Specify the library (or libraries) containing the termcap/terminfo
X *	routines.
X *
X *	Notice:  nn only uses the low-level terminal access routines
X *	(i.e. it does not use curses).
X */
X
X#define TERMLIB	-ltermlib
X
X/*
X *	Define HAVE_STRCHR if strchr() and strrchr() are available
X */
X
X#include <string.h>
X
X#undef HAVE_STRCHR			/* */
X
X/*
X *	Define if a signal handler has type void (see signal.h)
X */
X
X#undef	SIGNAL_HANDLERS_ARE_VOID	/* */
X
X/*
X *	Define MICRO_ALARM to timeout in 0.1 seconds if possible
X */
X
X#define MICRO_ALARM()	alarm(1)	/* could use setitimer ... */
X
X/*
X *	Define if your system has BSD like job control (SIGTSTP works)
X */
X
X#define HAVE_JOBCONTROL			/* */
X
X/*
X *	Define if your system provides the "directory(3X)" access routines
X *
X *	If true, include the header file(s) required by the package below
X *	(remember that <sys/types.h> or equivalent is included above)
X *	Also typedef Direntry to the proper struct type.
X */
X
X#define	HAVE_DIRECTORY			/* */
X
X#include <sys/dir.h>			/* BSD */
X
Xtypedef struct direct Direntry;		/* BSD */
X
X/*
X *	Define if your system has a mkdir() library routine
X */
X
X#define	HAVE_MKDIR			/* */
X
X/*
X *	Define if your system provides a BSD like gethostname routine.
X *	Otherwise, define HAVE_UNAME if uname() is avaiable.
X */
X
X#define	HAVE_GETHOSTNAME	/* BSD systems */
X
X/*
X *	Define DETATCH_TERMINAL to be a command sequence which 
X *	will detatch a process from the control terminal
X *	Also include system files needed to perform this HERE.
X *	If not possible, just define it (empty)
X */
X
X#include <sys/file.h>	/* for O_RDONLY */
X#include <sys/ioctl.h>	/* for TIOCNOTTY */
X
X#define	DETATCH_TERMINAL \
X    { int t = open("/dev/tty", O_RDONLY); \
X	  if (t >= 0) ioctl(t, TIOCNOTTY, (int *)0), close(t); }
X
X      
X/* 
X *	Specify where the Bourne Shell is.
X */
X
X#define SHELL		"/bin/sh"
X
X/*
X *	Specify the default mailer to be invoked by nnmail
X */
X
X#define	MAILX	"/usr/ucb/Mail"		/* BSD */
X
X
X/*
X *	Specify the default pager & options.
X */
X
X#define	PAGER		"more"
X
X/*
X *	Specify the default print command and options.
X */
X
X#define	PRINTER		"lpr -p -JNN-print"
X
X
X/*
X *	Define the maximum length of any pathname that may occur
X */
X
X#define	FILENAME 	256
NO_NEWS_IS_GOOD_NEWS
chmod 0644 s-bsd4-2.h || echo "restore of s-bsd4-2.h fails"
set `wc -c s-bsd4-2.h`;Sum=$1
if test "$Sum" != "2590"
then echo original size 2590, current size $Sum;fi
echo "x - extracting s-bsd4-3.h (Text)"
sed 's/^X//' << 'NO_NEWS_IS_GOOD_NEWS' > s-bsd4-3.h &&
X/*
X *	This version is for 4.3 systems
X */
X
X
X/*
X *	Include haeder files containing the following definitions:
X *
X * 		off_t, time_t, struct stat
X */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X
X
X/*
X *	Define if your system has system V like ioctls
X */
X
X#undef	HAVE_TERMIO			/* */
X
X/*
X *	Define to use terminfo database.
X *	Otherwise, termcap is used
X */
X
X#undef	USE_TERMINFO			/* */
X
X/*
X *	Specify the library (or libraries) containing the termcap/terminfo
X *	routines.
X *
X *	Notice:  nn only uses the low-level terminal access routines
X *	(i.e. it does not use curses).
X */
X
X#define TERMLIB	-ltermlib
X
X/*
X *	Define HAVE_STRCHR if strchr() and strrchr() are available
X */
X
X#include <string.h>
X
X#undef HAVE_STRCHR			/* */
X
X/*
X *	Define if a signal handler has type void (see signal.h)
X */
X
X#undef	SIGNAL_HANDLERS_ARE_VOID	/* */
X
X/*
X *	Define MICRO_ALARM to timeout in 0.1 seconds if possible
X */
X
X#define MICRO_ALARM()	ualarm(100000,0)	/* BSD 4.3 */
X
X/*
X *	Define if your system has BSD like job control (SIGTSTP works)
X */
X
X#define HAVE_JOBCONTROL			/* */
X
X/*
X *	Define if your system has a 4.3BSD like syslog library.
X */
X
X#define HAVE_SYSLOG
X
X/*
X *	Define if your system provides the "directory(3X)" access routines
X *
X *	If true, include the header file(s) required by the package below
X *	(remember that <sys/types.h> or equivalent is included above)
X *	Also typedef Direntry to the proper struct type.
X */
X
X#define	HAVE_DIRECTORY			/* */
X
X#include <sys/dir.h>			/* BSD */
X
Xtypedef struct direct Direntry;		/* BSD */
X
X/*
X *	Define if your system has a mkdir() library routine
X */
X
X#define	HAVE_MKDIR			/* */
X
X/*
X *	Define if your system provides a BSD like gethostname routine.
X *	Otherwise, define HAVE_UNAME if uname() is avaiable.
X */
X
X#define	HAVE_GETHOSTNAME	/* BSD systems */
X
X/*
X *	Define DETATCH_TERMINAL to be a command sequence which 
X *	will detatch a process from the control terminal
X *	Also include system files needed to perform this HERE.
X *	If not possible, just define it (empty)
X */
X
X#include <sys/file.h>	/* for O_RDONLY */
X#include <sys/ioctl.h>	/* for TIOCNOTTY */
X
X#define	DETATCH_TERMINAL \
X    { int t = open("/dev/tty", O_RDONLY); \
X	  if (t >= 0) ioctl(t, TIOCNOTTY, (int *)0), close(t); }
X
X      
X/* 
X *	Specify where the Bourne Shell is.
X */
X
X#define SHELL		"/bin/sh"
X
X/*
X *	Specify the default mailer to be invoked by nnmail
X */
X
X#define	MAILX	"/usr/ucb/Mail"		/* BSD */
X
X
X/*
X *	Specify the default pager & options.
X */
X
X#define	PAGER		"more"
X
X/*
X *	Specify the default print command and options.
X */
X
X#define	PRINTER		"lpr -p -JNN-print"
X
X
X/*
X *	Define the maximum length of any pathname that may occur
X */
X
X#define	FILENAME 	256
NO_NEWS_IS_GOOD_NEWS
chmod 0644 s-bsd4-3.h || echo "restore of s-bsd4-3.h fails"
set `wc -c s-bsd4-3.h`;Sum=$1
if test "$Sum" != "2666"
then echo original size 2666, current size $Sum;fi
echo "x - extracting s-hpux.h (Text)"
sed 's/^X//' << 'NO_NEWS_IS_GOOD_NEWS' > s-hpux.h &&
X/*
X *	This version is for Hewlett-Packard HP-UX
X */
X
X
X/*
X *	Include header files containing the following definitions:
X *
X * 		off_t, time_t, struct stat
X */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X
X/*
X *	Define if your system has system V like ioctls
X */
X
X#define	HAVE_TERMIO			/* */
X
X/*
X *	Define to use terminfo database.
X *	Otherwise, termcap is used
X */
X
X#define	USE_TERMINFO			/* */
X
X/*
X *	Specify the library containing the termcap/terminfo access routines.
X *	Notice:  nn does not use curses.
X *	Notice:  You must also specify whether termcap or terminfo is
X *		 used when you edit config.h (see below).
X */
X
X#define	TERMLIB -lcurses
X
X/*
X *	Define HAVE_STRCHR if strchr() and strrchr() are available
X */
X
X#define HAVE_STRCHR			/* */
X
X/*
X *	Define if a signal handler has type void (see signal.h)
X */
X
X/* #define	SIGNAL_HANDLERS_ARE_VOID	/* */
X
X/*
X *	Define if signals must be set again after they are caught
X */
X
X#define	RESET_SIGNAL_WHEN_CAUGHT	/* */
X
X/*
X *	Define MICRO_ALARM to timeout in 0.1 seconds if possible
X */
X
X#define MICRO_ALARM()	alarm(1)	/* System V */
X
X/*
X *	Define if your system has BSD like job control (SIGTSTP works)
X */
X
X/* #define HAVE_JOBCONTROL			/* */
X
X/*
X *	Define if your system provides the "directory(3X)" access routines
X *
X *	If true, include the header file(s) required by the package below
X *	(remember that <sys/types.h> or equivalent is included above)
X *	Also typedef Direntry to the proper struct type.
X */
X
X#define	HAVE_DIRECTORY			/* */
X
X#include <ndir.h>			/* HP-UX */
X
Xtypedef struct direct Direntry;		/* HP-UX */
X
X/*
X *	Define if your system has a mkdir() library routine
X */
X
X#define	HAVE_MKDIR			/* */
X
X/*
X *	Define HAVE_GETHOSTNAME if your system provides a BSD like 
X *	gethostname routine.
X *	Otherwise, define HAVE_UNAME if uname() is avaiable.
X *	As a final resort, define HOSTNAME to the name of your system.
X */
X
X#define	HAVE_UNAME			/* System V */
X
X/*
X *	Define DETATCH_TERMINAL to be a command sequence which 
X *	will detatch a process from the control terminal
X *	Also include files needed to perform this HERE.
X *	If not possible, just define it (empty)
X */
X
X#define	DETATCH_TERMINAL setpgrp();	/* System V */
X
X/* 
X *	Specify where the Bourne Shell is.
X */
X
X#define SHELL		"/bin/sh"
X
X/*
X *	Specify the default mailer to be invoked by nnmail
X */
X
X#define	MAILX		"/usr/bin/mailx"	/* SV */
X
X/*
X *	Specify the default pager & options.
X */
X
X#define	PAGER		"less"
X
X/*
X *	Specify the default print command and options.
X */
X
X#define	PRINTER		"lp -s"
X
X
X/*
X *	Define the maximum length of any pathname that may occur
X */
X
X#define	FILENAME 	128
NO_NEWS_IS_GOOD_NEWS
chmod 0644 s-hpux.h || echo "restore of s-hpux.h fails"
set `wc -c s-hpux.h`;Sum=$1
if test "$Sum" != "2603"
then echo original size 2603, current size $Sum;fi
echo "x - extracting s-hpux2-1.h (Text)"
sed 's/^X//' << 'NO_NEWS_IS_GOOD_NEWS' > s-hpux2-1.h &&
X/*
X *    This version is for HP-UX 2.1 (on HP9000 Series 800)
X */
X 
X 
X/*
X *    Include header files containing the following definitions:
X *
X *         off_t, time_t, struct stat
X */
X 
X#include <sys/types.h>
X#include <sys/stat.h>
X 
X 
X/*
X *    Define if your system has system V like ioctls
X */
X 
X#define    HAVE_TERMIO            /* */
X 
X/*
X *    Define to use terminfo database.
X *    Otherwise, termcap is used
X */
X 
X#define    USE_TERMINFO            /* */
X 
X/*
X *    Specify the library (or libraries) containing the termcap/terminfo
X *    routines.
X *
X *    Notice:  nn only uses the low-level terminal access routines
X *    (i.e. it does not use curses).
X */
X 
X#define TERMLIB    -lcurses
X 
X/*
X *    Define HAVE_STRCHR if strchr() and strrchr() are available
X */
X 
X#define HAVE_STRCHR            /* */
X 
X/*
X *    Define if a signal handler has type void (see signal.h)
X */
X 
X#undef    SIGNAL_HANDLERS_ARE_VOID    /* */
X 
X/*
X *    Define if signals must be set again after they are caught
X */
X 
X#define    RESET_SIGNAL_WHEN_CAUGHT    /* */
X 
X/*
X *    Define MICRO_ALARM to timeout in 0.1 seconds if possible
X */
X 
X#define MICRO_ALARM()    not_needed(0.1)  /* only used #ifndef HAVE_TERMIO */
X 
X/*
X *    Define if your system has BSD like job control (SIGTSTP works)
X */
X 
X#define HAVE_JOBCONTROL            /* */
X 
X 
X/*
X *    Define if your system has a 4.3BSD like syslog library.
X */
X 
X#define HAVE_SYSLOG
X 
X/*
X *    Define if your system provides the "directory(3X)" access routines
X *
X *    If true, include the header file(s) required by the package below
X *    (remember that <sys/types.h> or equivalent is included above)
X *    Also typedef Direntry to the proper struct type.
X */
X 
X#define    HAVE_DIRECTORY            /* */
X 
X#include <ndir.h>
X 
Xtypedef struct direct Direntry;
X 
X/*
X *    Define if your system has a mkdir() library routine
X */
X 
X#define    HAVE_MKDIR            /* */
X 
X 
X/*
X *    Define HAVE_GETHOSTNAME if your system provides a BSD like
X *    gethostname routine.
X *    Otherwise, define HAVE_UNAME if uname() is avaiable.
X *    As a final resort, define HOSTNAME to the name of your system
X *    (in config.h).
X */
X 
X#define    HAVE_GETHOSTNAME
X 
X/*
X *    Define DETATCH_TERMINAL to be a command sequence which
X *    will detatch a process from the control terminal
X *    Also include system files needed to perform this HERE.
X *    If not possible, just define it (empty)
X */
X 
X/* #include "...." */
X 
X#define    DETATCH_TERMINAL /* setpgrp(); */
X 
X 
X/*
X *    Specify where the Bourne Shell is.
X */
X 
X#define SHELL        "/bin/sh"
X 
X/*
X *    Specify the default mailer to be invoked by nnmail
X */
X 
X#define    MAILX        "/usr/bin/mailx"    /* SV */
X 
X 
X/*
X *    Specify the default pager & options.
X */
X 
X#define    PAGER        "/usr/local/bin/less"
X 
X/*
X *    Specify the default print command and options.
X */
X 
X#define    PRINTER        "/usr/bin/lp -s"
X 
X 
X/*
X *    Define the maximum length of any pathname that may occur
X */
X 
X#define    FILENAME     1024
X 
X 
X/*
X *    Define standard compiler flags here:
X */
X 
X#define COMPILER_FLAGS -O -z
NO_NEWS_IS_GOOD_NEWS
chmod 0644 s-hpux2-1.h || echo "restore of s-hpux2-1.h fails"
set `wc -c s-hpux2-1.h`;Sum=$1
if test "$Sum" != "3089"
then echo original size 3089, current size $Sum;fi
echo "x - extracting s-sunos3.h (Text)"
sed 's/^X//' << 'NO_NEWS_IS_GOOD_NEWS' > s-sunos3.h &&
X/*
X *	This version is for SunOS 3.x systems (tested on 3.5)
X */
X
X
X/*
X *	Include header files containing the following definitions:
X *
X * 		off_t, time_t, struct stat
X */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X
X
X/*
X *	Define if your system has system V like ioctls
X */
X
X#undef	HAVE_TERMIO			/* */
X
X/*
X *	Define to use terminfo database.
X *	Otherwise, termcap is used
X */
X
X#undef	USE_TERMINFO			/* */
X
X/*
X *	Specify the library (or libraries) containing the termcap/terminfo
X *	routines.
X *
X *	Notice:  nn only uses the low-level terminal access routines
X *	(i.e. it does not use curses).
X */
X
X#define TERMLIB	-ltermlib
X
X/*
X *	Define HAVE_STRCHR if strchr() and strrchr() are available
X */
X
X#include <strings.h>
X
X#define HAVE_STRCHR			/* */
X
X/*
X *	Define if a signal handler has type void (see signal.h)
X */
X
X#undef	SIGNAL_HANDLERS_ARE_VOID	/* */
X
X/*
X *	Define MICRO_ALARM to timeout after 0.1 seconds if possible
X */
X
X#define MICRO_ALARM()	ualarm(100000,0)	/* BSD 4.3 */
X
X/*
X *	Define if your system has BSD like job control (SIGTSTP works)
X */
X
X#define HAVE_JOBCONTROL			/* */
X
X
X/*
X *	Define if your system has a 4.3BSD like syslog library.
X */
X
X#undef HAVE_SYSLOG
X
X/*
X *	Define if your system provides the "directory(3X)" access routines
X *
X *	If true, include the header file(s) required by the package below
X *	(remember that <sys/types.h> or equivalent is included above)
X *	Also typedef Direntry to the proper struct type.
X */
X
X#define	HAVE_DIRECTORY			/* */
X
X#include <sys/dir.h>			/* BSD */
X
Xtypedef struct direct Direntry;		/* BSD */
X
X/*
X *	Define if your system has a mkdir() library routine
X */
X
X#define	HAVE_MKDIR			/* */
X
X/*
X *	Define if your system provides a BSD like gethostname routine.
X *	Otherwise, define HAVE_UNAME if uname() is avaiable.
X */
X
X#define	HAVE_GETHOSTNAME	/* BSD systems */
X
X/*
X *	Define DETATCH_TERMINAL to be a command sequence which 
X *	will detatch a process from the control terminal
X *	Also include system files needed to perform this HERE.
X *	If not possible, just define it (empty)
X */
X
X#include <sys/file.h>	/* for O_RDONLY */
X#include <sys/ioctl.h>	/* for TIOCNOTTY */
X
X#define	DETATCH_TERMINAL \
X    { int t = open("/dev/tty", O_RDONLY); \
X	  if (t >= 0) ioctl(t, TIOCNOTTY, (int *)0), close(t); }
X
X      
X/* 
X *	Specify where the Bourne Shell is.
X */
X
X#define SHELL		"/bin/sh"
X
X/*
X *	Specify the default mailer to be invoked by nnmail
X */
X
X#define	MAILX	"/usr/ucb/Mail"		/* BSD */
X
X
X/*
X *	Specify the default pager & options.
X */
X
X#define	PAGER	"more"
X
X/*
X *	Specify the default print command and options.
X */
X
X#define	PRINTER		"lpr -s"
X
X/*
X *	Define the maximum length of any pathname that may occur
X */
X
X#define	FILENAME 	256
NO_NEWS_IS_GOOD_NEWS
chmod 0644 s-sunos3.h || echo "restore of s-sunos3.h fails"
set `wc -c s-sunos3.h`;Sum=$1
if test "$Sum" != "2680"
then echo original size 2680, current size $Sum;fi
echo "x - extracting s-sunos4-0.h (Text)"
sed 's/^X//' << 'NO_NEWS_IS_GOOD_NEWS' > s-sunos4-0.h &&
X/*
X *	This version is for BSD 4.2 and 4.3 systems
X */
X
X
X/*
X *	Include haeder files containing the following definitions:
X *
X * 		off_t, time_t, struct stat
X */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X
X
X/*
X *	Define if your system has system V like ioctls
X */
X
X#undef	HAVE_TERMIO			/* */
X
X/*
X *	Define to use terminfo database.
X *	Otherwise, termcap is used
X */
X
X#undef	USE_TERMINFO			/* */
X
X/*
X *	Specify the library (or libraries) containing the termcap/terminfo
X *	routines.
X *
X *	Notice:  nn only uses the low-level terminal access routines
X *	(i.e. it does not use curses).
X */
X
X#define TERMLIB	-ltermlib
X
X/*
X *	Define HAVE_STRCHR if strchr() and strrchr() are available
X */
X
X#include <strings.h>
X
X#define HAVE_STRCHR			/* */
X
X/*
X *	Define if a signal handler has type void (see signal.h)
X */
X
X#define	SIGNAL_HANDLERS_ARE_VOID	/* */
X
X/*
X *	Define MICRO_ALARM to timeout after 0.1 seconds if possible
X */
X
X#define MICRO_ALARM()	ualarm(100000,0)	/* BSD 4.3 */
X
X/*
X *	Define if your system has BSD like job control (SIGTSTP works)
X */
X
X#define HAVE_JOBCONTROL			/* */
X
X
X/*
X *	Define if your system has a 4.3BSD like syslog library.
X */
X
X#define HAVE_SYSLOG
X
X/*
X *	Define if your system provides the "directory(3X)" access routines
X *
X *	If true, include the header file(s) required by the package below
X *	(remember that <sys/types.h> or equivalent is included above)
X *	Also typedef Direntry to the proper struct type.
X */
X
X#define	HAVE_DIRECTORY			/* */
X
X#include <sys/dir.h>			/* BSD */
X
Xtypedef struct direct Direntry;		/* BSD */
X
X/*
X *	Define if your system has a mkdir() library routine
X */
X
X#define	HAVE_MKDIR			/* */
X
X/*
X *	Define if your system provides a BSD like gethostname routine.
X *	Otherwise, define HAVE_UNAME if uname() is avaiable.
X */
X
X#define	HAVE_GETHOSTNAME	/* BSD systems */
X
X/*
X *	Define DETATCH_TERMINAL to be a command sequence which 
X *	will detatch a process from the control terminal
X *	Also include system files needed to perform this HERE.
X *	If not possible, just define it (empty)
X */
X
X#include <sys/file.h>	/* for O_RDONLY */
X#include <sys/ioctl.h>	/* for TIOCNOTTY */
X
X#define	DETATCH_TERMINAL \
X    { int t = open("/dev/tty", O_RDONLY); \
X	  if (t >= 0) ioctl(t, TIOCNOTTY, (int *)0), close(t); }
X
X      
X/* 
X *	Specify where the Bourne Shell is.
X */
X
X#define SHELL		"/usr/bin/sh"
X
X/*
X *	Specify the default mailer to be invoked by nnmail
X */
X
X#define	MAILX	"/usr/ucb/Mail"		/* BSD */
X
X
X/*
X *	Specify the default pager & options.
X */
X
X#define	PAGER	"more"
X
X/*
X *	Specify the default print command and options.
X */
X
X#define	PRINTER		"lpr -p -JNN-print"
X
X
X/*
X *	Define the maximum length of any pathname that may occur
X */
X
X#define	FILENAME 	256
NO_NEWS_IS_GOOD_NEWS
chmod 0644 s-sunos4-0.h || echo "restore of s-sunos4-0.h fails"
set `wc -c s-sunos4-0.h`;Sum=$1
if test "$Sum" != "2688"
then echo original size 2688, current size $Sum;fi
echo "x - extracting s-template.h (Text)"
sed 's/^X//' << 'NO_NEWS_IS_GOOD_NEWS' > s-template.h &&
X/*
X *	Use this file as a template for new s- files
X */
X
X
X/*
X *	Include header files containing the following definitions:
X *
X * 		off_t, time_t, struct stat
X */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X
X
X/*
X *	Define if your system has system V like ioctls
X */
X
X#define	HAVE_TERMIO			/* */
X
X/*
X *	Define to use terminfo database.
X *	Otherwise, termcap is used
X */
X
X#define	USE_TERMINFO			/* */
X
X/*
X *	Specify the library (or libraries) containing the termcap/terminfo
X *	routines.
X *
X *	Notice:  nn only uses the low-level terminal access routines
X *	(i.e. it does not use curses).
X */
X
X#define TERMLIB	-ltermlib
X
X/*
X *	Define HAVE_STRCHR if strchr() and strrchr() are available
X */
X
X#define HAVE_STRCHR			/* */
X
X/*
X *	Define if a signal handler has type void (see signal.h)
X */
X
X#define	SIGNAL_HANDLERS_ARE_VOID	/* */
X
X/*
X *	Define if signals must be set again after they are caught
X */
X
X#define	RESET_SIGNAL_WHEN_CAUGHT	/* */
X
X/*
X *	Define MICRO_ALARM to timeout in 0.1 seconds if possible
X */
X
X#define MICRO_ALARM()	alarm(1)	/* System V */
X/*#define MICRO_ALARM()	ualarm(100000,0)	/* BSD 4.3 */
X 
X/*
X *	Define if your system has BSD like job control (SIGTSTP works)
X */
X
X/* #define HAVE_JOBCONTROL			/* */
X
X
X/*
X *	Define if your system has a 4.3BSD like syslog library.
X */
X
X#undef HAVE_SYSLOG
X
X/*
X *	Define if your system provides the "directory(3X)" access routines
X *
X *	If true, include the header file(s) required by the package below
X *	(remember that <sys/types.h> or equivalent is included above)
X *	Also typedef Direntry to the proper struct type.
X */
X
X#define	HAVE_DIRECTORY			/* */
X
X#include <dirent.h>			/* System V */
X/* #include <sys/dir.h>				/* BSD */
X
Xtypedef struct dirent Direntry;		/* System V */
X/* typedef struct direct Direntry;		/* BSD */
X
X/*
X *	Define if your system has a mkdir() library routine
X */
X
X#define	HAVE_MKDIR			/* */
X
X
X/*
X *	Define HAVE_GETHOSTNAME if your system provides a BSD like 
X *	gethostname routine.
X *	Otherwise, define HAVE_UNAME if uname() is avaiable.
X *	As a final resort, define HOSTNAME to the name of your system 
X *	(in config.h).
X */
X
X/* #define	HAVE_GETHOSTNAME	/* BSD systems */
X
X#define	HAVE_UNAME			/* System V */
X
X/*
X *	Define DETATCH_TERMINAL to be a command sequence which 
X *	will detatch a process from the control terminal
X *	Also include system files needed to perform this HERE.
X *	If not possible, just define it (empty)
X */
X
X/* #include "...." */
X
X#define	DETATCH_TERMINAL /* setpgrp(); */
X
X
X/* 
X *	Specify where the Bourne Shell is.
X */
X
X#define SHELL		"/bin/sh"
X
X/*
X *	Specify the default mailer to be invoked by nnmail
X */
X
X#define	MAILX		"/usr/bin/mailx"	/* SV */
X/* #define	MAILX	"/usr/ucb/Mail"		/* BSD */
X
X
X/*
X *	Specify the default pager & options.
X */
X
X#define	PAGER		"/usr/bin/pg -n -s"
X
X/*
X *	Specify the default print command and options.
X */
X
X#define	PRINTER		"/usr/bin/lp -s"
X
X
X/*
X *	Define the maximum length of any pathname that may occur
X */
X
X#define	FILENAME 	128
X
X
X/*
X *	Define standard compiler flags here:
X */
X
X#define COMPILER_FLAGS
X
X/*
X *	If your system requires other libraries when linking nn
X *	specify them here:
X */
X
X#define EXTRA_LIB
NO_NEWS_IS_GOOD_NEWS
chmod 0644 s-template.h || echo "restore of s-template.h fails"
set `wc -c s-template.h`;Sum=$1
if test "$Sum" != "3141"
then echo original size 3141, current size $Sum;fi
echo "x - extracting s-tower32.h (Text)"
sed 's/^X//' << 'NO_NEWS_IS_GOOD_NEWS' > s-tower32.h &&
X/*
X *	This version is for Tower-32 machines.
X */
X
X
X/*
X *	Include header files containing the following definitions:
X *
X * 		off_t, time_t, struct stat
X */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X
X/*
X *	Define if your system has system V like ioctls
X */
X
X#define	HAVE_TERMIO			/* */
X
X/*
X *	Define to use terminfo database.
X *	Otherwise, termcap is used
X */
X
X#define	USE_TERMINFO			/* */
X
X/*
X *	Specify the library containing the termcap/terminfo access routines.
X *	Notice:  nn does not use curses.
X *	Notice:  You must also specify whether termcap or terminfo is
X *		 used when you edit config.h (see below).
X */
X
X#define	TERMLIB -lcurses
X
X/*
X *	Define HAVE_STRCHR if strchr() and strrchr() are available
X */
X
X#define HAVE_STRCHR			/* */
X
X/*
X *	Define if a signal handler has type void (see signal.h)
X */
X
X/* #define	SIGNAL_HANDLERS_ARE_VOID	/* */
X
X/*
X *	Define if signals must be set again after they are caught
X */
X
X#define	RESET_SIGNAL_WHEN_CAUGHT	/* */
X
X/*
X *	Define MICRO_ALARM to timeout in 0.1 seconds if possible
X */
X
X#define MICRO_ALARM()	alarm(1)	/* System V */
X
X/*
X *	Define if your system has BSD like job control (SIGTSTP works)
X */
X
X/* #define HAVE_JOBCONTROL			/* */
X
X/*
X *	Define if your system provides the "directory(3X)" access routines
X *
X *	If true, include the header file(s) required by the package below
X *	(remember that <sys/types.h> or equivalent is included above)
X *	Also typedef Direntry to the proper struct type.
X */
X
X/* #define	HAVE_DIRECTORY			/* */
X
X/* #include <dirent.h>			/* System V */
X
X/* typedef struct dirent Direntry;		/* System V */
X
X/*
X *	Define if your system has a mkdir() library routine
NO_NEWS_IS_GOOD_NEWS
echo "End of part 13"
echo "File s-tower32.h is continued in part 14"
echo "14" > s2_seq_.tmp
exit 0
---
Kim F. Storm        storm@texas.dk        Tel +45 429 174 00
Texas Instruments, Marielundvej 46E, DK-2730 Herlev, Denmark
	  No news is good news, but nn is better!

