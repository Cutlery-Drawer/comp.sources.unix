Path: uunet!rs
From: rs@uunet.UU.NET (Rich Salz)
Newsgroups: comp.sources.unix
Subject: v10i052:  Ease translator repost, Part02/04
Message-ID: <620@uunet.UU.NET>
Date: 10 Jul 87 11:22:46 GMT
Organization: UUNET Communications Services, Arlington, VA
Lines: 2107
Approved: rs@uunet.UU.NET

Submitted-by: Wombat <rsk@j.cc.purdue.edu>
Posting-number: Volume 10, Issue 52
Archive-name: ease/Part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 4)."
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'config-files/FINIS/pucc-j.mc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config-files/FINIS/pucc-j.mc'\"
else
echo shar: Extracting \"'config-files/FINIS/pucc-j.mc'\" \(3004 characters\)
sed "s/^X//" >'config-files/FINIS/pucc-j.mc' <<'END_OF_FILE'
X/***********************************************************
X ***********************************************************
X ****
X ****	SENDMAIL CONFIGURATION FILE
X ****
X ****	For PUCC-J
X ****
X ****	$Id: pucc-j.mc,v 1.2 86/04/04 14:20:57 kcs Exp $
X ****
X ***********************************************************
X ***********************************************************/
X
X
X
X/***********************************************************
X **	local info
X ***********************************************************/
X
Xmacro
X	m_sitename = "j.cc.purdue.edu"; 	/* internet hostname */
X	arpa_name  = "asc";			/* our arpanet name */
X
Xclass
X	m_sitename = { "j.cc.purdue.edu", pucc-j, puccj, j, pucc, purdue-asc, 
X		        purdue-205-gw, purdue-asc-tn, asc, "asc.purdue.edu", 
X		       "asc.cc.purdue.edu", 205-gw, asc-tn };
X
X	arpa_name = { "asc.purdue.edu", "asc.cc.purdue.edu", asc, purdue-asc,
X		       purdue-205-gw };
X
X#include "phonenethosts.cpp"
X
X#include "puccbase.cpp"
X
X#include "zerobase.cpp"
X
X/**********************************************
X **  Machine dependent part of ruleset zero  **
X **********************************************/
X
X	/* send berknet names through relay */
X
X	if ( < @berkhost > : path )
X		resolve ( mailer ( pcl ),
X			  host ( $relay_host ),
X			  user ( $2<@$1> ) );		/* @berkhost: ... */
X
X	if ( anypath < @anypath berkhost > anypath )
X		resolve ( mailer ( pcl ),
X			  host ( $relay_host ),
X			  user ( $1<@$2$3>$4 ) );	/* user@berknethost */
X
X	/* resolve campus names */
X
X	if ( anypath < @anypath campushost > anypath )
X		resolve ( mailer ( pcl ),
X			  host ( $3 ),
X			  user ( $1<@$2$3>$4 ) );	/* user@campushost */
X
X	/* send csnet names through relay */
X
X	if ( anypath < @phonehost > anypath )
X		resolve ( mailer ( tcp ),
X			  host ( "CSNet-Relay" ),
X			  user ( $1%$2<@"CSNet-Relay">$3 ) );
X
X	if ( anypath < @phonehost ".ARPA" > anypath )
X		resolve ( mailer ( tcp ),
X			  host ( "CSNet-Relay" ),
X			  user ( $1%$2<@"CSNet-Relay">$3 ) );
X
X	if ( anypath < @path ".CSNET" > anypath )
X		resolve ( mailer ( tcp ),
X			  host ( "CSNet-Relay" ),
X			  user ( $1%$2<@"CSNet-Relay">$3 ) );
X
X	/* we don't do uucp */
X
X	if ( anypath < @anypath ".UUCP" > anypath )
X		resolve ( mailer ( error ),
X			  user ( "Non-Local UUCP Mail Unavailable" ) );
X
X	/* we don't do bitnet (yet) */
X
X	if ( anypath < @anypath ".BITNET" > anypath )
X			resolve ( mailer ( error ),
X				  user ( "Bitnet Mail Unavailable At This Time" ) );
X
X	/* other non-local names to the arpanet */
X
X	if ( anypath < @anypath > anypath )
X		resolve ( mailer ( tcp ),
X			  host ( $2 ),
X			  user ( $1<@$2>$3 ) );		/* user@arpahost */
X
X	/* remaining names must be local */
X
X	if ( path )
X		resolve ( mailer ( local ),
X			  user ( $1 ) );		/* everything else */
X
X/**************************************
X **  Host dependent address cleanup  **
X **************************************/
X
Xruleset HOSTDEP_RW {
X
X	if ( anypath uucphost!usr@hostpath )
X		retry ( $3@$4 );			/* drop uucp forward */
X
X}
X
X#include "pclm.cpp"
X#include "tcpm.cpp"
END_OF_FILE
if test 3004 -ne `wc -c <'config-files/FINIS/pucc-j.mc'`; then
    echo shar: \"'config-files/FINIS/pucc-j.mc'\" unpacked with wrong size!
fi
# end of 'config-files/FINIS/pucc-j.mc'
fi
if test -f 'maketd/Manual/maketd.1l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'maketd/Manual/maketd.1l'\"
else
echo shar: Extracting \"'maketd/Manual/maketd.1l'\" \(4509 characters\)
sed "s/^X//" >'maketd/Manual/maketd.1l' <<'END_OF_FILE'
X.TH MAKETD 1L "11 November 1985"
X.if n \{.de Q
X"\\$1"\\$2
X.\}
X.if t \{.de Q
X``\\$1''\\$2
X.\}
X..
X.SH NAME
Xmaketd \- make transitive dependencies
X.SH SYNOPSIS
X.B maketd
X[
X.I option(s)
X] 
X.I file(s)
X.SH DESCRIPTION
X.I Maketd
Xcomputes dependencies for makefiles from sources introduced through
Xinclude files.
XIt generates lines like
X.Q "xx.o: e.h struct.h ../h/const.h ..." .
XIt makes xx.o not only dependent on all files it includes,
Xbut also recursively on all files other files include.
XThis is achieved by passing the source through the C preprocessor.
X.PP
XThe directories used in the search for include files
Xare identical to the ones used by the C compiler, because the
XC preprocessor is used.
XThis also means that `#define's, `#ifdef's, etc. are evaluated.
XIt may therefore be necessary to recompute the dependencies if
Xany source has been changed, including the associated Makefile.
X.PP
XA typical application in a Makefile goes as follows:
X.nf
X
X	INCL= \-I../include  \-I../h
X	CFLAGS= \-DPUCC \-DBSD4_2 ${INCL}
X	SRC= a.c b.c c.c
X
X	maketd: ${SRC}
X		maketd \-a ${CFLAGS} ${SRC}
X
X	# DO NOT DELETE THIS LINE \- make depend DEPENDS ON IT
X
X.fi
XThe generated dependencies will be inserted after the `# DO NOT DELETE...'
Xline.
XEverything after this line will go away through the editing
Xprocess of the Makefile.
XIf no such line exists, a line of the expected form will be emitted,
Xfollowed by the dependencies.
XThe default filename for the Makefile is `makefile'.
XIf `makefile' does not exist, `Makefile' is used.
XThe \-m and \-d options override this default action.
XBefore it is edited, the Makefile will be saved in `Makefile.bak',
Xoverwritting any existing `Makefile.bak'.
X.PP
XSeveral options apply.
XIf an option takes any arguments, all arguments follow the option
Xdirectly, with no spaces.
XIf spaces are required inside an argument to an option, then
Xquotes must be used to prevent the shell from breaking up the
Xargument.
X.TP
X.BI \-a
XNormally, dependencies on files in `/usr/include' are
Xnot included \- this option also includes dependencies on those files.
X.TP
X.BI \-b
XGenerate dependencies for binaries rather than object files.
XThis is equivelent to specifying a null suffix.
XThe `.o' is stripped from the filename.
X.TP
X.BI \-d
XInstead of editing the Makefile, dependencies are written to standard
Xoutput.
XThe standard header and trailer, `# DO NOT...' are not emitted.
X.TP
X.BI \-f
XForce printing of header and trailer.
XNormally, these are suppresed when the output file is the standard
Xoutput.
X.TP
X.BI \-h
XPrint a set of oneline descriptions to the terminal and exit.
X.TP
X.BI \-m file
XInstead of editing `makefile' or `Makefile', the file named
X.I file
Xis edited.
X.TP
X.BI \-nonlocalo
XGenerate dependency paths that match the source paths given.
X.TP
X.BI \-o directory
XNormally dependencies are of the form
X.Q "a.o: ....." .
XThis option generates dependencies of the form
X.Q "\fIdirectory\fP/a.o:...." ,
Xwhich is useful for Makefiles which store the objects in
Xa separate subdirectory.
XThe name of the directory must not be empty.
X.TP
X.BI \-r
XCauses the dependencies for a single source file to be generated and
Xreplaced in the edited Makefile.
X.TP
X.BI \-s suffix
XSupply a suffix for the target.
XThe suffix should start with a `.'.
XThe target file name should have a suffix of some sort that
Xis delimited by a `.' that is replaced by this suffix.
X.TP
X.BI \-t target
XSupply a new basename for the target.
X.TP
X.BI \-x
XDon't shorten include files.
XThe default action is to replace various strings with abbreviations.
XThe Makefile is scanned to see which single letter uppercase
Xvariables are set.
XThese definitions are remembered.
XThe pathnames `/usr/include' and `/usr/include/sys', along with any
Xpathnames specified with \-I options are also used in abbreviations.
XUnused uppercase single letters are defined, printed to the Makefile,
Xand used.
X.TP
X.BI \-v
XBe verbose.
XExtra output is directed to
X.I stderr.
X.TP
X.BI \-I...
XSpecify a directory to search for include files.
XThis option is passed to /lib/cpp, and thus behaves identically to
Xthe same option to `cc'.
X.TP
X.BI \-D...
XSpecify a definition.
XThis option is passed to /lib/cpp, and thus behaves identically to
Xthe same option to `cc'.
X.TP
X.BI \-U....
XSpecify that a variable that should not be defined.
XThis option is passed to /lib/cpp, and thus behaves identically to
Xthe same option to `cc'.
X.IR cc (1).
X.SH "AUTHOR"
XStephan v. Bechtolsheim (the shell script) (Purdue CS)
X.br
XStephen Uitti (the C version) (PUCC)
X.SH "SEE ALSO"
Xmake(1), cc(1)
END_OF_FILE
if test 4509 -ne `wc -c <'maketd/Manual/maketd.1l'`; then
    echo shar: \"'maketd/Manual/maketd.1l'\" unpacked with wrong size!
fi
# end of 'maketd/Manual/maketd.1l'
fi
if test -f 'maketd/Manual/nshpopen.3l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'maketd/Manual/nshpopen.3l'\"
else
echo shar: Extracting \"'maketd/Manual/nshpopen.3l'\" \(2367 characters\)
sed "s/^X//" >'maketd/Manual/nshpopen.3l' <<'END_OF_FILE'
X.TH NSHPOPEN 3 "local"
X.SH NAME
Xnshpopen, nshpclose \- initiate I/O to/from a process
X.SH SYNOPSIS
X.B #include <stdio.h>
X.PP
X.SM
X.B FILE
X.B *nshpopen(command, type)
X.br
X.B char *command, *type;
X.PP
X.B nshpclose(stream)
X.br
X.SM
X.B FILE
X.B *stream;
X.SH DESCRIPTION
XThe arguments to 
X.I nshpopen
Xare pointers to null-terminated strings containing respectively
Xa shell command line and an I/O mode, either "r" for reading or
X"w" for writing.
XIt creates a pipe between the calling process and the command
Xto be executed.
XThe value returned is a stream pointer that can be used (as
Xappropriate) to write to the standard input of the command or
Xread from its standard output.
X.PP
XA stream opened by
X.I nshpopen
Xshould be closed by
X.IR nshpclose ,
Xwhich waits for the associated process to terminate
Xand returns the exit status of the command.
X.PP
XBecause open files are shared, a type "r" command may be used
Xas an input filter, and a type "w" as an output filter.
X.PP
X.I Nshpopen
Xbreaks up the
X.I command
Xargument string at spaces and tabs for the child process.
XHowever, it does not invoke a shell, and does not
Xattempt any shell shell meta character parsing.
XIn particular, quoted white space will still cause argument seperation.
XBy avoiding calling a shell, pipe creation is a great deal quicker.
XAlso, by avoiding the (rather complicated) shell meta character
Xparsing, some types of bugs may be avoided.
XThis is important where the security of setuid programs is involved.
X.SH "SEE ALSO"
Xpipe(2),
Xpopen(3),
Xfopen(3S),
Xfclose(3S),
Xsystem(3),
Xwait(2),
Xsh(1)
X.SH DIAGNOSTICS
X.I Nshpopen
Xreturns a null pointer if files or processes cannot be created,
Xor the shell cannot be accessed.
X.PP
X.I Nshpclose
Xreturns \-1 if
X.I stream
Xis not associated with an `nshpopened' command.
X.SH BUGS
XBuffered reading before opening an input filter
Xmay leave the standard input of that filter mispositioned.
XSimilar problems with an output filter may be
Xforestalled by careful buffer flushing, for instance, with
X.I fflush,
Xsee
X.IR fclose (3).
X.LP
X.I Nshpopen
Xdoes not call a shell to do it's work.
XIt does not attempt to process shell meta characters.
XThus, it does not treat quotes, I/O redirects, or file
Xname wildcard characters specially.
XThis is it's incompatibility with
X.I popen(3).
X.LP
XThis type of function should have been included with
X.I popen(3)
Xin the standard I/O library.
END_OF_FILE
if test 2367 -ne `wc -c <'maketd/Manual/nshpopen.3l'`; then
    echo shar: \"'maketd/Manual/nshpopen.3l'\" unpacked with wrong size!
fi
# end of 'maketd/Manual/nshpopen.3l'
fi
if test -f 'maketd/Manual/srtunq.3l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'maketd/Manual/srtunq.3l'\"
else
echo shar: Extracting \"'maketd/Manual/srtunq.3l'\" \(3745 characters\)
sed "s/^X//" >'maketd/Manual/srtunq.3l' <<'END_OF_FILE'
X.TH SRTUNQ 1L PUCC
X.SH NAME
Xsrtinit, srtin, srtgti, srtgets, srtfree, srtdtree
X.SH SYNOPSIS
X.B #include <stdio.h>
X.br
X.B #include <local/srtunq.h>
X.sp
Xcc file.c
X.B \-lsrtunq
X.SH DESCRIPTION
X.I Libsrtunq.a
Xis a set of sorting routines for a particular purpose.
XIt's use is extracting unique items from a possibly long list,
Xwhere items are likely to be replicated numerously.
XThe list of unique items will be small enough to
Xfit in main memory.
XHigh speed is desired.
X.PP
XThe caller has control over the database through the use of a
X.I struct srtent
Xvariable.
XThe subroutines provide for data entry and retrieval,
Xmemory allocation and deallocation.
X.SH ROUTINES
X.TP
X.ft B
Xvoid srtinit(ent) struct srtent *ent;
X.ft
XThis subroutine must be called before the first time
Xany data is entered or retrieved
Xfrom a database tree whose tag is pointed to by
X.B ent.
XIt assumes that the database tag has not been used
Xto store a tree, and therefore does not attempt to free
Xany such data.
X.TP
X.ft B
Xchar *srtin(ent, string, compar) struct srtent *ent; char *string; int (*compar)();
X.ft
XThe existing data tree is searched.
XIf the string is found in the tree then nothing is done.
XOtherwise, space is allocated for the string and pointer structure via
X.I malloc(3).
XThe string is copied to this new space.
XThe structure is linked into the tree.
XIf space cannot be obtained, the operation is aborted, and
Xa pointer to an error string is returned.
XThe data structure remains consistent, but the string is not placed in it.
XIf the operation is successful, NULL is returned.
XThe strings are compared and sorted with the subroutine pointed to by
X.I compar.
XThis subroutine takes two string pointers as arguments.
XIt returns zero if the strings are the same,
Xless than zero if the first string should precede the second, and
Xgreater than zero if the second string should precede the first.
XIf the subroutine pointer is NULL, then a simple string compare is used, which
Xsorts in ascending ASCII order, and strings of different length comparing
Xas unequal.
X.TP
X.ft B
Xvoid srtgti(ent); struct srtent *ent;
X.ft
XThis subroutine initializes the database tag pointed to by
X.B ent
Xso that a tree transversal can be made via
X.I srtgets.
X.TP
X.ft B
Xchar *srtgets(ent); struct srtent *ent;
X.ft
XThis routine extracts the next string from the data structure.
XThe strings are returned in increasing order.
XWhen the list is exhausted, NULL is returned.
X.TP
X.ft B
Xvoid srtfree(ent) struct srtent *ent;
X.ft
XThis subroutine deletes a database, and re-initializes the
Xdatabase tag.
XIt assumes that the database tag was initialized at one time via
X.I srtinit
X(other routines will probably also have been called).
XThe space formally occupied by string data and pointer structures is
Xdeallocated via
X.I free(3).
X.TP
X.ft B
Xvoid srtdtree(ent, tbl) struct srtent *ent; struct srtbl *tbl;
X.ft
XThis subroutine recursively deletes a database subtree.
XThe space formally occupied by the string data and pointer structures is
Xdeallocated via
X.I free(3).
XThis routine is most likely only of use internally.
X.SH EXAMPLE
X.nf
Xmain()
X{
X    char buf[80], *p;
X    struct srtent d;
X    srtinit(&d);
X    while (fgets(buf, stdin, 79) != NULL)
X        if ((p = srtin(&d, "foo")) != NULL)
X            printf("test: %s\n", p);  /* warning message */
X    srtgti(&d);
X    while ((p = srtgets(&d)) != NULL)
X        puts(p);
X    srtfree(&d);
X}
X.fi
X.SH DIAGNOSTICS
XThere are no messages printed by these routines.
XCatchable errors are returned as strings.
XCompiled in errors such as the use of strings that
Xare not null terminated tend to result in core files.
X.SH FILES
X/usr/local/lib/libsrtunq.a
X.br
X/usr/include/local/srtunq.h
X.SH SEE ALSO
Xmalloc(3), qsort(3)
X.SH AUTHOR
XStephen Uitti, PUCC
X.SH BUGS
XLikely.
END_OF_FILE
if test 3745 -ne `wc -c <'maketd/Manual/srtunq.3l'`; then
    echo shar: \"'maketd/Manual/srtunq.3l'\" unpacked with wrong size!
fi
# end of 'maketd/Manual/srtunq.3l'
fi
if test -f 'maketd/breakargs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'maketd/breakargs.c'\"
else
echo shar: Extracting \"'maketd/breakargs.c'\" \(2529 characters\)
sed "s/^X//" >'maketd/breakargs.c' <<'END_OF_FILE'
X/* breakargs - break a string into a string vector for execv.
X * Returns NULL if can't malloc space for vector, else vector.
X * Note, when done with the vector, mearly "free" the vector.
X * Written by Stephen Uitti, PUCC, Nov '85 for the new version
X * of "popen" - "nshpopen", that doesn't use a shell.
X * (used here for the as filters, a newer option).
X *
X * breakargs is copyright (C) Purdue University, 1985
X *
X * put in a fix for cmds lines with "string string" in them
X * Mon Aug 25 13:34:27 EST 1986 (ksb)
X *
X * Permission is hereby given for its free reproduction and
X * modification for non-commercial purposes, provided that this
X * notice and all embedded copyright notices be retained.
X * Commercial organisations may give away copies as part of their
X * systems provided that they do so without charge, and that they
X * acknowledge the source of the software.
X */
X#ifdef BSD2_9
X#include <sys/types.h>
X#endif
X#include <stdio.h>			/* for nothing, really */
X#define SPC '\040'			/* ascii space */
X
Xchar *
Xmynext(pch)
Xregister char *pch;
X{
X	register int fQuote;
X
X	for (fQuote = 0; (*pch != '\000' && *pch != SPC && *pch != '\t')||fQuote; ++pch) {
X		if ('\\' == *pch) {
X			continue;
X		}
X		switch (fQuote) {
X		default:
X		case 0:
X			if ('"' == *pch) {
X				fQuote = 1;
X			} else if ('\'' == *pch) {
X				fQuote = 2;
X			}
X			break;
X		case 1:
X			if ('"' == *pch)
X				fQuote = 0;
X			break;
X		case 2:
X			if ('\'' == *pch)
X				fQuote = 0;
X			break;
X		}
X	}
X	return pch;
X}
X
Xchar **
Xbreakargs(cmd)
Xchar *cmd;
X{
X	register char *p;		/* tmp				*/
X	register char **v;		/* vector of commands returned	*/
X	register unsigned sum;		/* bytes for malloc		*/
X	register int i;			/* number of args		*/
X	register char *s;		/* save old position		*/
X	char *malloc(), *strcpy();
X
X	p = cmd;
X	while (*p == SPC || *p == '\t')
X		p++;
X	cmd = p;			/* no leading spaces		*/
X	sum = sizeof(char *);
X	i = 0;
X	while (*p != '\0') {		/* space for argv[];		*/
X		++i;
X		s = p;
X		p = mynext(p);
X		sum += sizeof(char *) + 1 + (unsigned)(p - s);
X		while (*p == SPC || *p == '\t')
X			p++;
X	}
X	++i;
X	/* vector starts at v, copy of string follows NULL pointer */
X	v = (char **)malloc(sum+1);
X	if (v == NULL)
X		return (char **)NULL;
X	p = (char *)v + i * sizeof(char *); /* after NULL pointer */
X	i = 0;				/* word count, vector index */
X	while (*cmd != '\0') {
X		v[i++] = p;
X		s = cmd;
X		cmd = mynext(cmd);
X		if (*cmd != '\0')
X			*cmd++ = '\0';
X		strcpy(p, s);
X		p += strlen(p);
X		++p;
X		while (*cmd == SPC || *cmd == '\t')
X			++cmd;
X	}
X	v[i] = (char *)NULL;
X	return v;
X}
END_OF_FILE
if test 2529 -ne `wc -c <'maketd/breakargs.c'`; then
    echo shar: \"'maketd/breakargs.c'\" unpacked with wrong size!
fi
# end of 'maketd/breakargs.c'
fi
if test -f 'maketd/maketd.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'maketd/maketd.sh'\"
else
echo shar: Extracting \"'maketd/maketd.sh'\" \(2941 characters\)
sed "s/^X//" >'maketd/maketd.sh' <<'END_OF_FILE'
X#! /bin/sh
X#
X# maketd - generates file dependencies for makefiles using cc -M
X#
XPATH=/usr/local/bin:/bin:/usr/bin:/usr/ucb
Xexport PATH
X
Xprogname=`basename $0`
X
X# Name of the Makefile which will be edited to add the dependencies
Xif [ $# = 0 ] ; then
X    cat << EOF
Xusage: $progname [-a] [-d] [-m<file>] [-o<directory>] [-D...] [-I...] [-U...]
X	      [<file> ...] [-T <file> ...]
XEOF
X    exit
Xfi
X
XDEPFILE=/tmp/mtd3$$.tmp
Xtouch $DEPFILE
XEDDFILE=/tmp/mtd4$$.tmp
X
Xtrap 'rm -f $DEPFILE $EDDFILE ; exit ' 1 2 3 15
X
X# Default values for -a, -d, -m and -o options
XAOPTION="-e /\/usr\/include/d"
XDOPTION=0
XMAKEFILE=Makefile
XOBJDIR=
X
X# Collect in OPTIONS all options you want to pass on to the C preprocessor.
X# 	  in SOURCES all files you want to create dependencies for
Xwhile [ -n "$1" ] ; do
X    case $1 in
X
X	-a)
X	    AOPTION=
X	;;
X
X	-d)
X	    DOPTION=1
X	;;
X
X	-m*)
X	    MAKEFILE=`expr $1 : '-m\(.*\)'`
X	;;
X
X	-nonlocalo)
X	    echo "$progname: -nonlocalo option obsolete"
X	    exit 1
X	;;
X
X	-o*)
X	    if [ "$1" = "-o" ] ; then
X		echo    "$progname: -o option requires directory name"
X		exit 1
X	    fi
X	    OBJDIR=`expr $1 : '-o\(.*\)'`
X	    if [ ! -d $OBJDIR ] ; then
X		echo    "$progname: -o option: \"$OBJDIR\" is not a directory"
X		exit 1
X	    fi
X	    OBJDIR="$OBJDIR/"
X	;;
X
X	-[D,I,U]*)
X	    OPTIONS="$OPTIONS $1"
X	;;
X
X	-T)
X	    shift
X	    TSOURCES="$*"
X	    set ""
X	;;
X
X	-*)
X	    echo        "$progname: option \"$1\" unknown; ignored"
X	;;
X
X	*)
X	    SOURCES="$SOURCES $1"
X	;;
X    esac
X    shift
Xdone
X
X#       Run everything through the preprocessor (using cc), sort this
X#	output and remove duplictate lines.  If there is no '-a' option
X#	remove all dependencies of the form '/usr/include/<file>'. Cc
X#	will exit quietly if there are no source files.
X/bin/cc -M $OPTIONS $SOURCES | sort | uniq | \
X    sed $AOPTION \
X	-e "s, \./, ,g" \
X	-e "s,\.\./[a-zA-Z0-9]*/\.\.,\.\.,g" \
X	-e "s,^,$OBJDIR," >> $DEPFILE
X
X/bin/cc -M $OPTIONS $TSOURCES | sort | uniq | \
X    sed $AOPTION \
X	-e "s,\.o:,:," \
X	-e "s, \./, ,g" \
X	-e "s,\.\./[a-zA-Z0-9]*/\.\.,\.\.,g" \
X	-e "s,^,$OBJDIR," >> $DEPFILE
X
X# If DOPTION then cat file and exit, otherwise edit Makefile
Xif [ $DOPTION -eq 1 ] ; then
X    cat $DEPFILE
X    rm -f $DEPFILE $EDDFILE
X    exit
Xfi
X
X# Now start editing the Makefile
Xif [ ! -w $MAKEFILE ] ; then
X    echo        "$progname: can't edit $MAKEFILE"
X    rm -f $DEPFILE $EDDFILE
X    exit 1
Xfi
X
X
X# Make sure we have the "DO NOT DELETE" line in the Makefile
Xcat << EOF >> $MAKEFILE
X
X# DO NOT DELETE THIS LINE - maketd DEPENDS ON IT
XEOF
X
X# Build the editor script to edit the Makefile later.
Xcat << EOF > $EDDFILE
X/# DO NOT DELETE THIS LINE/,\$d
X\$a
X# DO NOT DELETE THIS LINE - maketd DEPENDS ON IT
X# Dependencies generated at: `date`
X
XEOF
Xcat $DEPFILE >> $EDDFILE
Xcat << EOF >> $EDDFILE
X
X# DO NOT ADD ANYTHING HERE - WILL GO AWAY
X.
Xw
Xq
XEOF
X
X# Editor scipt done, edit makefile now.
Xcp $MAKEFILE $MAKEFILE.bak
Xed - $MAKEFILE < $EDDFILE
X
Xrm -f $DEPFILE $EDDFILE
END_OF_FILE
if test 2941 -ne `wc -c <'maketd/maketd.sh'`; then
    echo shar: \"'maketd/maketd.sh'\" unpacked with wrong size!
fi
# end of 'maketd/maketd.sh'
fi
if test -f 'maketd/misc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'maketd/misc.c'\"
else
echo shar: Extracting \"'maketd/misc.c'\" \(3572 characters\)
sed "s/^X//" >'maketd/misc.c' <<'END_OF_FILE'
X/* Written & hacked by Stephen Uitti, PUCC staff, ach@pucc-j, 1985
X * maketd is copyright (C) Purdue University, 1985
X *
X * Permission is hereby given for its free reproduction and
X * modification for non-commercial purposes, provided that this
X * notice and all embedded copyright notices be retained.
X * Commercial organisations may give away copies as part of their
X * systems provided that they do so without charge, and that they
X * acknowledge the source of the software.
X */
X
X#ifdef BSD2_9
X#include <sys/types.h>
X#include <signal.h>
X#endif
X#ifdef BSD4_2
X#include <sys/signal.h>
X#endif
X#include <stdio.h>
X
X#include "maketd.h"
X
X/* VARARGS */
X/* print and error and exit */
Xvoid
Xerr(a, b, c, d)
Xchar *a;				/* the format string, as printf */
Xchar *b, *c, *d;			/* arguments, as printf */
X{
X    fprintf(stderr, "%s: ", prgnm);
X    fprintf(stderr, a, b, c, d);
X    fprintf(stderr, "\n");
X    errrec();				/* clean up backup file, if any */
X    exit(1);
X}
X
X/* errrec - error recovery: recover temp file */
Xstatic void
Xerrrec()
X{
X    if (backedup) {
X	backedup = FALSE;		/* prevent infinite error recursion */
X	unlink(makename);		/* may or may not exist */
X	if (link(backupfn, makename))
X	    err("can't link %s to %s during recovery", makename, backupfn);
X	if (unlink(backupfn))
X	    err("can't delete %s during recovery", backupfn);
X	err("edit of '%s' aborted - file unchanged.", makename);
X    }
X    exit(1);
X}
X
X/* signal trap routines, one for each */
Xstatic void
Xerrhup()
X{
X    fprintf(stderr, "%s: SIGHUP recieved\n", prgnm);
X    errrec();
X}
X
Xstatic void
Xerrint()
X{
X    fprintf(stderr, "%s: SIGINT recieved\n", prgnm);
X    errrec();
X}
X
Xstatic void
Xerrill()
X{
X    fprintf(stderr, "%s: SIGILL recieved\n", prgnm);
X    errrec();
X}
X
Xstatic void
Xerrtrap()
X{
X    fprintf(stderr, "%s: SIGTRAP recieved\n", prgnm);
X    errrec();
X}
X
Xstatic void
Xerriot()
X{
X    fprintf(stderr, "%s: SIGIOT recieved\n", prgnm);
X    errrec();
X}
X
Xstatic void
Xerremt()
X{
X    fprintf(stderr, "%s: SIGEMT recieved\n", prgnm);
X    errrec();
X}
X
Xstatic void
Xerrfpe()
X{
X    fprintf(stderr, "%s: SIGFPE recieved\n", prgnm);
X    errrec();
X}
X
Xstatic void
Xerrbus()
X{
X    fprintf(stderr, "%s: SIGBUS recieved\n", prgnm);
X    errrec();
X}
X
Xstatic void
Xerrsegv()
X{
X    fprintf(stderr, "%s: SIGSEGV recieved\n", prgnm);
X    errrec();
X}
X
Xstatic void
Xerrsys()
X{
X    fprintf(stderr, "%s: SIGSYS recieved\n", prgnm);
X    errrec();
X}
X
Xstatic void
Xerrpipe()
X{
X    fprintf(stderr, "%s: SIGPIPE recieved\n", prgnm);
X    errrec();
X}
X
Xstatic void
Xerralrm()
X{
X    fprintf(stderr, "%s: SIGALRM recieved\n", prgnm);
X    errrec();
X}
X
Xstatic void
Xerrterm()
X{
X    fprintf(stderr, "%s: SIGTERM recieved\n", prgnm);
X    errrec();
X}
X
X/* catchsig - init signal traps */
Xcatchsig()
X{
X    signal(SIGHUP, errhup);
X    signal(SIGINT, errint);
X    signal(SIGILL, errill);
X    signal(SIGTRAP, errtrap);
X    signal(SIGIOT, erriot);
X    signal(SIGEMT, erremt);
X    signal(SIGFPE, errfpe);
X    signal(SIGBUS, errbus);
X    signal(SIGSEGV, errsegv);
X    signal(SIGSYS, errsys);
X    signal(SIGPIPE, errpipe);
X    signal(SIGALRM, erralrm);
X    signal(SIGTERM, errterm);
X/* Stock 2.9BSD has all the above, but not as many as 4.2BSD:
X * Want SIGQUIT to drop core.
X * Not worrying about:	SIGXCPU, SIGXFSZ, SIGVTALRM, SIGPROF
X * cannot be caught: SIGKILL, SIGSTOP
X * Leaving alone: SIGURG, SIGTSTP, SIGCONT, SIGCHLD, SIGTTIN, SIGTTOU, SIGIO
X */
X}
X
X/* lastlnch - return last char before newline or NULL in string */
Xchar
Xlastlnch(p)
Xregister char *p;
X{
X    register char *q;
X
X    q = p;
X    while (*p != '\0' && *p != '\n')
X	q = p++;
X    return *q;
X}
END_OF_FILE
if test 3572 -ne `wc -c <'maketd/misc.c'`; then
    echo shar: \"'maketd/misc.c'\" unpacked with wrong size!
fi
# end of 'maketd/misc.c'
fi
if test -f 'maketd/srtunq.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'maketd/srtunq.c'\"
else
echo shar: Extracting \"'maketd/srtunq.c'\" \(4678 characters\)
sed "s/^X//" >'maketd/srtunq.c' <<'END_OF_FILE'
X/* Sorting function that inserts strings one at a time into memory.
X * Strings are null terminated.
X * Only uniq strings are stored (no count is kept of how many)
X * Any memory used is freed on init (or re-init).
X *
X * Author: Stephen Uitti, PUCC, 1985
X * libsrtunq is copyright (C) Purdue University, 1985
X *
X * Permission is hereby given for its free reproduction and
X * modification for non-commercial purposes, provided that this
X * notice and all embedded copyright notices be retained.
X * Commercial organisations may give away copies as part of their
X * systems provided that they do so without charge, and that they
X * acknowledge the source of the software.
X */
X
X#ifndef lint
Xstatic char *rcsid =
X    "$Id: srtunq.c,v 1.4 86/08/30 21:35:36 ksb Exp Locker: ksb $";
X#endif
X
X#ifdef BSD2_9
X#include <sys/types.h>
X#endif
X#ifdef notdef			/* a comment that allows comments. */
X * use:
X * #include <local/srtunq.h>			/* defines, etc */
X * struct srtent d;				/* data structure foothold */
X * char *p;					/* temp */
X * srtinit(&d);					/* init the structure */
X * if ((p = srtin(&d, "foo", NULL)) != NULL) err(p);	/* add the data */
X *	...
X * srtgti(&d);					/* init for get */
X * p = srtgets(&d);				/* get next entry */
X *	...
X * srtfree(&d);					/* delete the structure */
X#endif
X
X#include <stdio.h>			/* for null */
X#include <sys/types.h>			/* for void, in V7 */
X#include "srtunq.h"			/* for srtunq structs & functions */
X/* #include <local/srtunq.h>		/* for srtunq structs & functions */
X
X/* libc functions */
Xchar   *malloc();			/* need more memory */
Xchar   *strcpy();			/* copy string */
X
X/* srtgti - init get string function */
Xvoid
Xsrtgti(ent)
Xstruct srtent *ent;
X{
X    ent->srt_next = ent->srt_top;
X    if (ent->srt_next == NULL)
X	return;
X    while (ent->srt_next->srt_less != NULL)
X	ent->srt_next = ent->srt_next->srt_less;
X}
X
X/* srtgets - get next string from sorted list, NULL if none more. */
X/* The least shall be first... and the greatest shall be last */
Xchar *
Xsrtgets(ent)
Xstruct srtent *ent;
X{
X    register struct srtbl *s;		/* tmp */
X    register char *p;			/* ret val */
X
X    if ((s = ent->srt_next) == NULL)
X	return NULL;
X    p = s->srt_str;			/* ret val */
X    if (s->srt_more != NULL) {
X	s = s->srt_more;		/* go one more */
X	while (s->srt_less != NULL)	/* then all the way less */
X	    s = s->srt_less;
X	ent->srt_next = s;
X	return p;
X    }
X    while (s != ent->srt_top && s->srt_prev->srt_more == s)
X	s = s->srt_prev;		/* back down any more's */
X    if (s == ent->srt_top)
X	s = NULL;			/* no more */
X    else
X	s = s->srt_prev;
X    ent->srt_next = s;
X    return p;
X}
X
X/* srtinit - init the database tag */
Xvoid
Xsrtinit(ent)
Xstruct srtent *ent;
X{
X    ent->srt_top = NULL;		/* erase any knowledge of it */
X    ent->srt_next = NULL;		/* extractions at the begining */
X}
X
X/* srtfree - delete all the data, init the tag */
Xvoid
Xsrtfree(ent)
Xstruct srtent *ent;
X{
X    if (ent->srt_top == NULL)		/* is the structure empty? */
X	return;				/* yes - exit */
X    srtdtree(ent->srt_top);
X    free((char *)ent->srt_top);		/* clean up last struct */
X    srtinit(ent);			/* init the tag */
X}
X
X/* srtdtree - recursive tree delete
X * frees all less & more entries pointed to by the srt struct */
Xvoid
Xsrtdtree(srt)
Xregister struct srtbl *srt;
X{
X    if (srt->srt_less != NULL) {
X	srtdtree(srt->srt_less);
X	free((char *)srt->srt_less);
X	srt->srt_less = NULL;		/* for consistency */
X    }
X    if (srt->srt_more != NULL) {
X	srtdtree(srt->srt_more);
X	free((char *)srt->srt_more);
X	srt->srt_more = NULL;
X    }
X}
X
X/* srtin - insert string sorted & unique.
X * returns NULL if good, else error message string. */
Xchar *
Xsrtin(ent, str, compar)
Xstruct srtent *ent;
Xchar *str;
Xint (*compar)();			/* if NULL: use strcmp */
X{
X    register char *p;			/* temp string pointer */
X    register i;				/* string compare result */
X    register struct srtbl *s;		/* temp */
X    register struct srtbl *srtold;	/* old temp */
X
X    s = srtold = ent->srt_top;
X    while (s != NULL) {
X    	if ((i = (compar == NULL ?
X		strcmp(str, s->srt_str) : (*compar)(str, s->srt_str))) == 0)
X	    return NULL;		/* found: do nothing - "good" */
X	srtold = s;
X	if (i > 0)
X	    s = s->srt_more;
X	else
X	    s = s->srt_less;
X    }
X    if ((p = malloc((unsigned)(strlen(str) + sizeof(struct srtbl)))) == NULL)
X	return "srtin: warning - out of memory"; /* soft error - caller \n */
X    s = (struct srtbl *)p;
X    if (srtold == NULL) {		/* empty list */
X	ent->srt_top = s;
X	srtold = ent->srt_top;
X    } else {
X	if (i > 0)
X	    srtold->srt_more = s;
X	else
X	    srtold->srt_less = s;
X    }
X    s->srt_prev = srtold;
X    s->srt_less = NULL;
X    s->srt_more = NULL;
X    (void) strcpy(s->srt_str, str);
X    return NULL;
X}
END_OF_FILE
if test 4678 -ne `wc -c <'maketd/srtunq.c'`; then
    echo shar: \"'maketd/srtunq.c'\" unpacked with wrong size!
fi
# end of 'maketd/srtunq.c'
fi
if test -f 'src/errors.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/errors.c'\"
else
echo shar: Extracting \"'src/errors.c'\" \(2340 characters\)
sed "s/^X//" >'src/errors.c' <<'END_OF_FILE'
X/*	$Header: /usr/src/local/etc/ease/RCS/errors.c,v 1.2 85/10/29 23:40:20 jss Exp $	*/
X
X/*
X *  	errors.c   -- Contains error initialization and reporting routines.
X *
X *  	author     -- James S. Schoner, Purdue University Computing Center,
X *				        West Lafayette, Indiana  47907
X *
X *  	date       -- July 9, 1985
X *
X *	Copyright (c) 1985 by Purdue Research Foundation
X *
X *	All rights reserved.
X *
X */
X
X#include <stdio.h>
X
Xextern int  ErrorCount;	 /* error count	               */
Xextern char FNbuf[];	 /* input file name   	       */
Xextern int  Lcount;	 /* line count	     	       */
XFILE *DIAGf = {stderr};  /* file for diagnostic output */
X
X
X/*
X *	ErrorReport () -- Prints source file name (FNbuf), line number (Lcount),
X *			  and error message (sbErr) for each invokation.
X *
X */
Xvoid
XErrorReport (sbErr)
Xchar *sbErr;
X{
X	fprintf (DIAGf, "%s, line %d: %s", FNbuf, Lcount, sbErr);
X	ErrorCount++;
X}
X
X
X/*
X *	FatalError () -- Translator fatal error routine which prints 
X *			 error message (sbErr) and an argument (sbArg).
X *
X */
Xvoid
XFatalError (sbErr, sbArg)
Xchar *sbErr,
X     *sbArg;
X{
X	fprintf (DIAGf, "%s, line %d: Fatal Error In Translator: %s %s\n", 
X		 FNbuf, Lcount, sbErr, sbArg);
X	exit (1);
X}
X
X
X/*
X *	yyerror () -- Prints source file name (FNbuf), line number (Lcount),
X *		      and error message (sbErr) for each invokation.
X *
X */
Xvoid
Xyyerror (sbErr)
Xchar *sbErr;
X{
X	fprintf (DIAGf, "%s, line %d: %s\n", FNbuf, Lcount, sbErr);
X	ErrorCount++;
X}
X
X
X/*
X *	PrintError () -- Prints source file name (FNbuf), line number
X *			 (cline), error message (sbErr), and argument
X *			 (sbArg) for each invokation.
X *
X */
Xvoid
XPrintError (sbErr, sbArg)
Xchar *sbErr;
Xchar *sbArg;
X{
X	fprintf (DIAGf, "%s, line %d: %s %s.\n", FNbuf, Lcount, sbErr, sbArg);
X	ErrorCount++;
X}
X
X
X/*
X *	PrintWarning () -- Prints a warning message with source file
X *			   name (FNbuf), line number (Lcount), warning
X *			   (sbWarn), and a possible identifier (sbID).
X *
X */
Xvoid
XPrintWarning (sbWarn, sbID)
Xchar *sbWarn;
Xchar *sbID;
X{
X	fprintf (DIAGf, "%s, line %d: Warning: ", FNbuf, Lcount);
X	if (sbID != NULL)
X		fprintf (DIAGf, sbWarn, sbID);
X	else
X		fprintf (DIAGf, sbWarn);
X}
X
X
X/*
X *	InitError () -- Initialize line count (Lcount) to one and error count
X *		        (ErrorCount) to zero.
X *
X */
Xvoid
XInitError ()
X{
X	Lcount     = 1;
X	ErrorCount = 0;
X}
END_OF_FILE
if test 2340 -ne `wc -c <'src/errors.c'`; then
    echo shar: \"'src/errors.c'\" unpacked with wrong size!
fi
# end of 'src/errors.c'
fi
if test -f 'src/idman.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/idman.c'\"
else
echo shar: Extracting \"'src/idman.c'\" \(5550 characters\)
sed "s/^X//" >'src/idman.c' <<'END_OF_FILE'
X/*	$Header: /usr/src/local/etc/ease/RCS/idman.c,v 1.2 85/10/29 23:41:38 jss Exp $	*/
X
X/*
X *  	idman.c	-- Contains routines for manipulating identifiers and their
X *		   symbolic associations.
X *
X *  	author	-- James S. Schoner, Purdue University Computing Center,
X *				     West Lafayette, Indiana  47907
X *
X *  	date	-- July 9, 1985
X *
X *	Copyright (c) 1985 by Purdue Research Foundation
X *
X *	All rights reserved.
X *
X */
X
X#include <stdio.h>
X#include "symtab.h"
X
Xextern struct he *LookupSymbol ();
Xextern void	  FatalError (),
X		  ErrorReport (),
X		  PrintWarning (),
X		  PrintError ();
X
Xshort Uchar = 'A';			/* for unique macro names */
X
X
X/*
X *	UniqMac () -- Assigns and returns a unique one-character macro
X *		      name (upper-case) for an Ease macro name.
X *
X */
Xchar
XUniqMac (phe)
Xstruct he *phe;		/* symbol table entry for Ease macro */
X{
X	if ((phe->idval.idc = Uchar++) > 'Z')
X		FatalError ("Too many macro names (26 max)", (char *) NULL);
X	return (phe->idval.idc);
X}
X
X
X/*
X *	BindID () -- Binds either a ruleset or precedence identifier (phe) to
X * 		     an integer (vid).  The id type distinction is passed in
X *		     the parameter idt.
X *
X */
Xvoid
XBindID (phe, vid, idt)
Xregister struct he *phe;	/* symbol table entry for an identifier    */
Xint vid;			/* value of the identifier		   */
Xunsigned idt;			/* identifier type (ruleset or precedence) */
X{
X	if (ISTYPED(phe->idtype)) {	/* should be undefined */
X		PrintWarning ("Redeclaration of %s.\n", phe->psb);
X		phe->idtype = ID_UNTYPED;
X	}
X	phe->idtype |= idt;		/* make defined	       */
X	if (ISRULESET(phe->idtype)) {
X		if (vid > VALRSNMAX) {
X			ErrorReport ("Ruleset number too large.\n");
X			return;
X		} else if (vid < 0) {
X			ErrorReport ("Ruleset number must be non-negative.\n");
X			return;
X		}
X		sprintf (phe->idval.rsn, "%d", vid);
X	} else 
X		phe->idval.prec = vid;
X}
X
X
X/*
X *	CheckRS () -- Checks validity of a ruleset identifier (phe) and 
X *		      returns the ruleset string to which the identifier
X *		      is bound.  If the ruleset identifier is invalid, the
X *		      null string is returned.
X *
X */
Xchar *
XCheckRS (phe)
Xstruct he *phe;		/* symbol table entry for ruleset identifier */
X{
X	if (!ISRULESET(phe->idtype)) {
X		if (!ISTYPED(phe->idtype))
X			PrintError ("Ruleset identifier not bound to a number:", phe->psb);
X		else
X			PrintError ("Identifier not of ruleset type:", phe->psb);
X		return (NULL);
X	} else
X		return (phe->idval.rsn);
X}
X
X
X/*
X *	MakeMac () -- Declare a macro name (pmac) as a class and/or macro type 
X *		      (targtype) and return the unique cf character assigned 
X *		      to it.
X *
X */
Xchar
XMakeMac (pmac, targtype)
Xregister struct he *pmac;	/* symbol table entry for macro identifier */
Xunsigned targtype;		/* target declaration type for the macro   */
X{
X	/*
X	 *	An Ease macro may be declared as both a singular macro and
X	 *	a class macro.
X	 *
X	 */
X	if (ISMACRO(pmac->idtype) || ISCLASS(pmac->idtype)) {
X		pmac->idtype |= targtype;
X		return (pmac->idval.idc);
X	}
X	if (ISTYPED(pmac->idtype)) {	/* not a macro or class id */
X		PrintError ("Redeclaring or using as macro or class:", pmac->psb);
X		return ('\0');
X	}
X	pmac->idtype |= targtype;	/* previously untyped; declare here */
X	return (UniqMac (pmac));
X}
X	
X
X/*
X *	GetField () -- Returns a field type string given a field 
X *		       identifier (fid).
X *
X */
Xchar *
XGetField (fid)
Xregister struct he *fid;	/* field identifier */
X{
X	if (!ISFIELD(fid->idtype)) {
X		PrintError ("Field type not defined for", fid->psb);
X		return (NULL);
X	} else 
X		return (fid->idval.fstring);
X}
X
X
X/*
X *	CheckMailer () -- Declares a mailer identifier (mid) as type mailer,
X *			  checking that the identifier was not previously 
X *			  declared a different type. 
X *
X */
Xchar *
XCheckMailer (mid)
Xregister struct he *mid;
X{
X	if (ISTYPED (mid->idtype) && !ISMAILER (mid->idtype)) {
X		PrintError ("Redeclaration as mailer:", mid->psb);
X		return (NULL);
X	}
X	mid->idtype |= ID_MAILER;
X	return (mid->psb);
X}
X
X
X/*
X *	AssignType () -- Assigns to each field identifier in fidlist the
X *			 type (in string form) fidtype.  This is accomplished
X *			 by making each field identifier symbol table entry
X *			 "point" to the type found in fidtype.
X *
X */
Xvoid
XAssignType (fidlist, fidtype)
Xregister char *fidlist;		/* field identifier list, blank separated */
Xchar *fidtype;			/* field identifier type string		  */
X{
X	register struct he *fid;	/* pointer to a field identifier  */
X	char *fres;			/* field type result string	  */
X	register char *srch;		/* fidlist search pointer	  */
X	char  sep;			/* fidlist separator character    */
X
X	fres = (char *) malloc (strlen (fidtype) + 1);
X	if (fres == NULL)
X		FatalError ("System out of string space in AssignType ()", (char *) NULL);
X	strcpy (fres, fidtype);		/* make clean copy of string type */
X
X	/*
X	 *	Search for all field identifiers and make the type assignment. 
X 	 *
X	 */
X	srch = fidlist;
X	while (*srch != '\0') {
X		while ((*++srch != ' ') && (*srch != '\0'))
X			/* null */ ;
X		if (*fidlist != '\0') {		        /* found a field id       */
X			sep = *srch;
X			*srch = '\0';
X			fid = LookupSymbol (fidlist);	/* get symbol table entry */
X			if (ISFIELD(fid->idtype)) {
X				if (strcmp (fid->idval.fstring, fres))
X					PrintWarning ("Redefinition of field type for %s.\n", fid->psb);
X			} else if (ISTYPED(fid->idtype)) {
X				PrintError ("Redeclaration of identifier as a field:", fid->psb);
X				return;
X			}
X			fid->idtype |= ID_FIELD;	/* type the identifier    */
X			fid->idval.fstring = fres;	/* type the field	  */
X			if ((*srch = sep) != '\0')
X				fidlist = ++srch;
X		}
X	}
X}
END_OF_FILE
if test 5550 -ne `wc -c <'src/idman.c'`; then
    echo shar: \"'src/idman.c'\" unpacked with wrong size!
fi
# end of 'src/idman.c'
fi
if test -f 'src/lexan.l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lexan.l'\"
else
echo shar: Extracting \"'src/lexan.l'\" \(5031 characters\)
sed "s/^X//" >'src/lexan.l' <<'END_OF_FILE'
X%{
X/*	$Header: /usr/src/local/etc/ease/RCS/lexan.l,v 1.2 85/10/29 23:42:40 jss Exp $	*/
X
X/*
X *	lexan.l -- Lexical Analyzer for EASE.
X *
X *		   Contains code for lex(1) which generates a lexical
X *		   analyzer (lex.yy.c) for Ease, a high-level specification 
X *		   format for sendmail configuration files.
X *
X *	author -- James S. Schoner, Purdue University Computing Center,
X *				    West Lafayette, Indiana  47907
X *
X *	date   -- July 1, 1985
X *
X *	Copyright (c) 1985 by Purdue Research Foundation
X *
X *	All rights reserved.
X *
X */
X
X#include "symtab.h"
X#include "lexdefs.h"
X
X#define  LEXnewline '\n'
X#define	 LEXeof	    '\0'
X#define  MaxFN	    200			/* maximum file name length */
X
Xextern struct he *LookupSymbol ();
Xextern void	  ErrorReport ();
X
Xint  Lcount;				/* line counter		    */
Xchar FNbuf[MaxFN];			/* file name buffer	    */
Xshort RMatch  = FALSE;			/* ruleset match flag  	    */
X
X%}
X
X/* lex-specific extensions */
X%e 1100
X%p 3700
X%n 500
X
X%%
X	int INch;			/* any input character */
X
X[ \t\f]+			; 	/* discard whitepsace  */
X[\n]				Lcount++;
X^\#[ \t]*[0-9]+[ \t]*\".*\"[ \t]*$	{
X			        sscanf (yytext, "%*c%d%s", &Lcount, FNbuf);
X			        INch = input ();
X			        }
Xmatch				return (MATCH);
Xin				return (IN);
Xbind				return (BIND);
Xdefine				return (DEFINE);
Xmacro				return (MACRO);
Xclass				return (CLASS);
Xoptions				return (OPTIONS);
Xprecedence			return (PRECEDENCE);
Xtrusted				return (TRUSTED);
Xheader				return (HEADER);
Xruleset				return (RULESET);
Xmailer				return (MAILER);
Xhost				return (HOST);
Xuser				return (USER);
Xhostnum				return (HOSTNUM);
Xif				return (IF);
Xretry				return (RETRY);
Xnext				return (NEXT);
Xreturn				return (RETURN);
Xresolve				return (RESOLVE);
Xfor				return (FOR);
Xfield				return (FIELD);
Xconcat				return (CONCAT);
Xifset				return (IFSET);
Xcanon				return (CANON);
Xreadclass			return (READCLASS);
XPath				return (MPATH);
XFlags				return (MFLAGS);
XSender				return (MSENDER);
XRecipient			return (MRECIPIENT);
XArgv				return (MARGV);
XEol				return (MEOL);
XMaxsize				return (MMAXSIZE);
Xo_alias				return (AAOPT);
Xo_ewait				return (AOPT);
Xo_bsub				return (BBOPT);
Xo_qwait				return (COPT);
Xo_delivery			return (DOPT);
Xd_interactive			return (DOPTI);
Xd_background			return (DOPTB);
Xd_queue				return (DOPTQ);
Xo_rebuild			return (DDOPT);
Xo_handling			return (EOPT);
Xh_print				return (EOPTP);
Xh_exit				return (EOPTE);
Xh_mail				return (EOPTM);
Xh_write				return (EOPTW);
Xh_mailz				return (EOPTZ);
Xo_tmode				return (FFOPT);
Xo_usave				return (FOPT);
Xo_gid				return (GOPT);
Xo_fsmtp				return (HHOPT);
Xo_skipd				return (IOPT);
Xo_slog				return (LLOPT);
Xo_rsend				return (MOPT);
Xo_dnet				return (NNOPT);
Xo_hformat			return (OOPT);
Xo_qdir				return (QQOPT);
Xo_tread				return (ROPT);
Xo_flog				return (SSOPT);
Xo_safe				return (SOPT);
Xo_qtimeout			return (TTOPT);
Xo_timezone			return (TOPT);
Xo_dmuid				return (UOPT);
Xo_verbose			return (VOPT);
Xo_wizpass			return (WWOPT);
Xo_loadq				return (XOPT);
Xo_loadnc			return (XXOPT);
Xf_ffrom				return (FFLAG);
Xf_rfrom				return (RFLAG);
Xf_noreset			return (SSFLAG);
Xf_noufrom			return (NFLAG);
Xf_locm				return (LFLAG);
Xf_strip				return (SFLAG);
Xf_mult				return (MFLAG);
Xf_from				return (FFFLAG);
Xf_date				return (DDFLAG);
Xf_mesg				return (MMFLAG);
Xf_full				return (XFLAG);
Xf_return			return (PPFLAG);
Xf_upperu			return (UFLAG);
Xf_upperh			return (HFLAG);
Xf_arpa				return (AAFLAG);
Xf_ufrom				return (UUFLAG);
Xf_expensive			return (EFLAG);
Xf_dot				return (XXFLAG);
Xf_llimit			return (LLFLAG);
Xf_retsmtp			return (PFLAG);
Xf_smtp				return (IIFLAG);
Xf_addrw				return (CCFLAG);
X[A-Za-z][A-Za-z0-9_-]*		{
X				/* store identifiers in symbol table */
X				yylval.phe = LookupSymbol (yytext);
X				return (IDENT);
X				}
X["]((\\\n)|(\\\")|[^"\n])*	{
X				if ((INch = input()) == LEXnewline) {
X					ErrorReport ("End of line in string.\n");
X					unput (INch);
X				}
X				yylval.psb = (char *) malloc (strlen (yytext) + 1);
X				strcpy (yylval.psb, yytext + 1);
X				return (SCONST);
X				}
X[0][0-7]*			{
X				sscanf (yytext, "%o", &yylval.ival);  /* octal constant */
X				return (ICONST);
X				}
X[-]?[1-9][0-9]*			{
X				yylval.ival = atoi (yytext);
X				return (ICONST);
X				}
X"="				return (ASGN);
X","				return (COMMA);
X"{"				return (LBRACE);
X"}"				return (RBRACE);
X"("				return (LPAREN);
X")"				return (RPAREN);
X";"				return (SEMI);
X"$"				return (DOLLAR);
X":"				return (COLON);
X"*"				return (STAR);
X"/*"				{
X				/* eat C comments */
X				INch = input ();
X				while ((INch != '*') || 
X				      ((INch = input ()) != '/')) {
X					if (INch == LEXnewline)
X						Lcount++;
X					else
X						if (INch == LEXeof) {
X							ErrorReport ("End of file in comment.\n");
X							break;
X						}
X					if (INch != '*')
X						INch = input ();
X				}
X				}
X[\\]?.				{
X				if (RMatch) {	/* in rulesets, return literal character */
X					yylval.ival = (yytext[0] == '\\') ? yytext[1] : yytext[0];
X					return (SEPCHAR);
X				} else {
X					ErrorReport ("Illegal delimiter character");
X					printf (": (octal code) \\%03o\n", *yytext);
X				}
X				}
X%%
END_OF_FILE
if test 5031 -ne `wc -c <'src/lexan.l'`; then
    echo shar: \"'src/lexan.l'\" unpacked with wrong size!
fi
# end of 'src/lexan.l'
fi
if test -f 'src/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/main.c'\"
else
echo shar: Extracting \"'src/main.c'\" \(3915 characters\)
sed "s/^X//" >'src/main.c' <<'END_OF_FILE'
X/*	$Header: /usr/src/local/etc/ease/RCS/main.c,v 1.2 85/10/29 23:43:38 jss Exp $	*/
X
X/*
X *  	main.c     -- Main procedure for Ease Translator.
X *
X *  	author     -- James S. Schoner, Purdue University Computing Center
X *				        West Lafayette, Indiana  47907
X *
X *  	date       -- July 9, 1985
X *
X *	Copyright (c) 1985 by Purdue Research Foundation
X *
X *	All rights reserved.
X *
X */
X
X#include <stdio.h>
X
Xextern FILE *DIAGf;			/* diagnostic file */
Xextern void InitError (), 
X	    InitSymbolTable (),
X	    DefScan (),
X	    FatalError (),
X            PreLoad ();
X
Xint ErrorCount;				/* translation error count */
Xvoid GetArgs ();			/* gets arguments to "et"  */
X
X/*
X *	main () -- Main procedure for the Ease Translator et.  If no files are 
X *	       	   given as arguments to et, stdin is translated and written to 
X *	           stdout.  If one file is given, it is translated and written 
X *	           to stdout.  If two files are given, the first is translated
X *	           and written to the second.  If the first filename is "-",
X *	           standard input is assumed.  A translation is performed on 
X *	           valid Ease input only, producing a regular sendmail 
X *		   configuration file. 
X *
X */
Xvoid
Xmain (argc, argv)
Xint argc;		/* argument count for "et"  */
Xchar *argv[];		/* argument vector for "et" */
X{
X	InitError ();			/* initialize error conditions */
X	InitSymbolTable ();		/* initialize the symbol table */
X	PreLoad ();			/* preload special identifiers */
X	GetArgs (argc, argv);		/* set up argument files       */
X	(void) yyparse ();		/* perform translation	       */
X	if (fflush (stdout) == EOF)
X		FatalError ("Cannot flush output stream/file", (char *) NULL);
X	DefScan ();		        /* warn about undefined idents */
X	if (ErrorCount)
X		fprintf (DIAGf, "\n\n*** %d error(s) detected.\n", ErrorCount);
X	exit (ErrorCount);
X}
X
X
X/*
X *	GetArgs () -- Processes arguments to the Ease translator "et".  The
X *		      arguments are files (margv) which may replace either/both
X *		      of the files standard input and standard output.  The 
X *		      following cases are possible:
X *			
X *		      -- et f.e f.cf
X *				Translate Ease file f.e and write result
X *				to f.cf.
X *
X *		      -- et f.e
X *				Translate Ease file f.e and write result to
X *				standard output.
X *
X *		      -- et - f.cf
X *				Translate standard input and write result to
X *				f.cf.
X *
X *		      -- et
X *				Translate standard input and write result to
X *				standard output.
X *
X *		      Finally, a message indicating the volatility of the 
X *		      Ease output is written.
X *
X */
Xvoid
XGetArgs (margc, margv)
Xregister int   margc;		/* argument count  */
Xregister char *margv[];		/* argument vector */
X{
X	switch (margc) {
X		case 1 : break;
X		case 2 :
X		case 3 : if (strcmp (margv[1], "-") && (freopen (margv[1], "r", stdin) == NULL))
X				FatalError ("Cannot open input stream/file:", margv[1]);
X			 if ((margc == 3) && (freopen (margv[2], "w", stdout) == NULL))
X				FatalError ("Cannot open output file:", margv[2]);
X			 break;
X		default: FatalError ("Usage: et [infile [outfile]]", (char *) NULL);
X			 break;
X	}
X	printf ("###################################################\n");
X	printf ("##                                               ##\n");
X	printf ("##  WARNING: THIS FILE IS TO BE MODIFIED BY      ##\n");
X	printf ("##           THE EASE TRANSLATOR (ET) ONLY.      ##\n");
X	printf ("##                                               ##\n");
X	printf ("##           ALL OTHER MODIFICATIONS WILL        ##\n");
X	printf ("##           DISAPPEAR THE NEXT TIME ET IS RUN.  ##\n");
X	printf ("##                                               ##\n");
X	printf ("##           MAKE MODIFICATIONS TO THE EASE      ##\n");
X	printf ("##           SOURCE ONLY.                        ##\n");
X	printf ("##                                               ##\n");
X	printf ("###################################################\n");
X}
END_OF_FILE
if test 3915 -ne `wc -c <'src/main.c'`; then
    echo shar: \"'src/main.c'\" unpacked with wrong size!
fi
# end of 'src/main.c'
fi
if test -f 'src/symtab.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/symtab.c'\"
else
echo shar: Extracting \"'src/symtab.c'\" \(5288 characters\)
sed "s/^X//" >'src/symtab.c' <<'END_OF_FILE'
X/*	$Header: /usr/src/local/etc/ease/RCS/symtab.c,v 1.2 85/10/29 23:46:48 jss Exp $	*/
X
X/*
X *  	symtab.c   -- Contains Ease Translator symbol table routines.
X *
X *  	author     -- James S. Schoner, Purdue University Computing Center,
X *				        West Lafayette, Indiana  47907
X *
X *  	date       -- July 9, 1985
X *
X *	Copyright (c) 1985 by Purdue Research Foundation
X *
X *	All rights reserved.
X *
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include "symtab.h"
X
X#define ERRORMAILER "error"		/* predefined error mailer name */
X
Xextern void FatalError (),
X	    PrintWarning ();
X
Xstruct he *LookupSymbol ();
X
Xstruct Defmac {				/* predefined macro struct def  */
X	char *macname;
X	char  macrep;
X};
X
Xstruct he *SymTab[SST];			/* hash table base array        */
Xstatic struct Defmac MacDefs[] = {	/* predefined macros	        */
X			{"m_smtp",	'e'},
X			{"m_oname",	'j'},
X			{"m_ufrom",	'l'},
X			{"m_daemon",	'n'},
X			{"m_addrops",	'o'},
X			{"m_defaddr",	'q'},
X			{"m_sitename",	'w'},
X			{"m_odate",	'a'},
X			{"m_adate",	'b'},
X			{"m_hops",	'c'},
X			{"m_udate",	'd'},
X			{"m_saddr",	'f'},
X			{"m_sreladdr",	'g'},
X			{"m_rhost",	'h'},
X			{"m_qid",	'i'},
X			{"m_pid",	'p'},
X			{"m_protocol",	'r'},
X			{"m_shostname", 's'},
X			{"m_ctime",	't'},
X			{"m_ruser",	'u'},
X			{"m_version",	'v'},
X			{"m_sname",	'x'},
X			{"m_stty",	'y'},
X			{"m_rhdir",	'z'},
X			{"sentinel",	'\0'}
X};
X
X
X/*
X *	DefScan () -- Scan symbol table to find macros, classes, mailers, 
X *		      and rulesets which have been referenced or declared, but
X *		      not defined.  A warning is printed for each such 
X *		      occurence.  This routine is usually called at the end
X *		      of a successful Ease translation.
X *
X */
Xvoid
XDefScan ()
X{
X	register int stindex;		/* symbol table hash index   */
X	register struct he *hcsearch;	/* hash chain search pointer */
X
X	for (stindex = 0; stindex < SST; stindex++) {
X		if ((hcsearch = SymTab[stindex]) != NULL)
X			while (hcsearch != NULL) {
X				if ((ISMACRO(hcsearch->idtype) && 
X				     isupper(hcsearch->idval.idc)) &&
X				     !ISMACRO(hcsearch->idd))
X					PrintWarning ("Macro not defined: %s\n", hcsearch->psb);
X				if (ISCLASS(hcsearch->idtype) && !ISCLASS(hcsearch->idd))
X					PrintWarning ("Class not defined: %s\n", hcsearch->psb);
X				if (ISMAILER(hcsearch->idtype) && !ISMAILER(hcsearch->idd))
X					PrintWarning ("Mailer not defined: %s\n", hcsearch->psb);
X				if (ISRULESET(hcsearch->idtype) && !ISRULESET(hcsearch->idd))
X					PrintWarning ("Ruleset not defined: %s\n", hcsearch->psb);
X				hcsearch = hcsearch->phe;
X			}
X	}
X}
X				     
X
X/*
X *	InitSymbolTable () -- Invoked by main () to initialize the symbol table.
X *
X */
Xvoid
XInitSymbolTable ()
X{
X	int i;
X
X	for (i = 0; i < SST; i++)		/* initialize base array */
X		SymTab[i] = NULL;
X}
X
X
X/*
X *	PreLoad () -- Invoked by main () to preload special macro names 
X *		      and mailer declarations.
X *
X */
Xvoid
XPreLoad ()
X{
X	struct Defmac *macptr;
X	struct he     *symptr;
X
X	/* preload special (lower-case) macros */
X	for (macptr = &MacDefs[0]; (*macptr).macrep != '\0'; macptr++) {
X		symptr = LookupSymbol ((*macptr).macname);
X		symptr->idtype |= ID_MACRO;
X		symptr->idval.idc = (*macptr).macrep;
X	}
X
X	/* preload error mailer declaration */
X	symptr = LookupSymbol (ERRORMAILER);
X	symptr->idtype |= ID_MAILER;
X	symptr->idd |= ID_MAILER;
X}
X	
X
X/*
X *	LookupSymbol () -- Returns a pointer to the hash entry already 
X *			   existing, or newly created, which corresponds 
X *			   to string sb.
X *
X */
Xstruct he *
XLookupSymbol (sb)
Xchar sb[];			/* string buffer containing identifier */
X{
X	struct he *phe;		/* hash entry search pointer  */
X	int	  hc;		/* hash code of sb identifier */
X
X	phe = SymTab[hc = HashCode (sb)];
X	while (phe != NULL)			/* find hash entry for sb */
X		if (!strcmp (phe->psb, sb))
X			return (phe);
X		else
X			phe = phe->phe;
X	/* make new symbol table entry */
X	if ((phe = (struct he *) malloc (sizeof (struct he))) == NULL)
X		FatalError ("System out of space in LookupSymbol ()", (char *) NULL);
X	if ((phe->psb = (char *) malloc (strlen (sb) + 1)) == NULL)
X		FatalError ("System out of space in LookupSymbol ()", (char *) NULL);
X	strcpy (phe->psb, sb);
X	phe->idval.idc = '\0';
X	phe->idtype = ID_UNTYPED;
X	phe->idd = ID_UNTYPED;
X	phe->phe = SymTab[hc];
X	return (SymTab[hc] = phe);
X}
X
X
X/*
X *	RemoveSymbol () -- Removes the symbol table entry phe from the 
X *			   symbol table.
X *
X */
Xvoid
XRemoveSymbol (phe)
Xstruct he *phe;	   /* pointer to hash entry to be removed from symbol table */
X{
X	int hc;	   		/* hash code of entry phe       */
X	struct he *sphe;	/* search pointer for entry phe */
X
X	if (phe == NULL)
X		return;
X	else {			/* search and remove entry phe  */
X		sphe = SymTab[hc = HashCode (phe->psb)];
X		free (phe->psb);
X		if (sphe == phe)
X			SymTab[hc] = phe->phe;
X		else
X			while (sphe != NULL)
X				if (sphe->phe == phe) {
X					sphe->phe = phe->phe;
X					return;
X				} else
X					sphe = sphe->phe;
X	}
X}
X
X
X/*
X *	HashCode () -- Returns the hash code of the string in sb by adding 
X *		       the character values and applying mod by the hash 
X *		       table size.
X *
X */
Xint
XHashCode (sb)
Xchar sb[];
X{
X	int ccSum = 0;			/* sum of char values in string sb */
X	int i;
X
X	for (i = 0; sb[i]; i++)		/* add char codes for sb chars     */
X		ccSum += sb[i];
X	return (ccSum % SST);		/* return sum mod table size	   */
X}
END_OF_FILE
if test 5288 -ne `wc -c <'src/symtab.c'`; then
    echo shar: \"'src/symtab.c'\" unpacked with wrong size!
fi
# end of 'src/symtab.c'
fi
echo shar: End of archive 2 \(of 4\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 

Rich $alz			"Anger is an energy"
Cronus Project, BBN Labs	rsalz@bbn.com
Moderator, comp.sources.unix	sources@uunet.uu.net
