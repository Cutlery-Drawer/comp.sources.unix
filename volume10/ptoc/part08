Path: uunet!rs
From: rs@uunet.UU.NET (Rich Salz)
Newsgroups: comp.sources.unix
Subject: v10i072:  Pascal to C translator, Part08/12
Message-ID: <723@uunet.UU.NET>
Date: 28 Jul 87 19:36:06 GMT
Organization: UUNET Communications Services, Arlington, VA
Lines: 1047
Approved: rs@uunet.UU.NET

Submitted-by: Per Bergsten <mcvax!enea!chalmers!holtec!perb>
Posting-number: Volume 10, Issue 72
Archive-name: ptoc/Part08


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 8 (of 12)."
# Contents:  ptc.c.6
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'ptc.c.6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ptc.c.6'\"
else
echo shar: Extracting \"'ptc.c.6'\" \(44980 characters\)
sed "s/^X//" >'ptc.c.6' <<'END_OF_FILE'
Xe(dput)) {
X		(void)fprintf(output.fp, "/*\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "**	Definitions for i/o\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "*/\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%s<stdio.h>\n", C24_include), Putl(output, 1);
X	}
X	if (use(dinput) || use(doutput) || use(dtext)) {
X		etextdef();
X		if (use(dinput)) {
X			if (tp->U.V13.tsubid == (struct S61 *)NIL)
X				(void)fprintf(output.fp, "%s", xtern), Putl(output, 0);
X			(void)fprintf(output.fp, "text%c", tab1), Putl(output, 0);
X			printid(defnams.A[(int)(dinput)]->U.V6.lid);
X			if (tp->U.V13.tsubid != (struct S61 *)NIL)
X				(void)fprintf(output.fp, " = { stdin, 0, 0 }"), Putl(output, 0);
X			Putchr(';', output),Putchr('\n', output);
X		}
X		if (use(doutput)) {
X			if (tp->U.V13.tsubid == (struct S61 *)NIL)
X				(void)fprintf(output.fp, "%s", xtern), Putl(output, 0);
X			(void)fprintf(output.fp, "text%c", tab1), Putl(output, 0);
X			printid(defnams.A[(int)(doutput)]->U.V6.lid);
X			if (tp->U.V13.tsubid != (struct S61 *)NIL)
X				(void)fprintf(output.fp, " = { stdout, 0, 0 }"), Putl(output, 0);
X			Putchr(';', output),Putchr('\n', output);
X		}
X	}
X	if (use(dinput) || use(dget) || use(dread) || use(dreadln) || use(deof) || use(deoln) || use(dreset) || use(drewrite)) {
X		(void)fprintf(output.fp, "%sFread(x, f) fread((char *)&x, sizeof(x), 1, f)\n", C4_define), Putl(output, 1);
X		(void)fprintf(output.fp, "%sGet(f) Fread((f).buf, (f).fp)\n", C4_define), Putl(output, 1);
X		(void)fprintf(output.fp, "%sGetx(f) (f).init = 1, (f).eoln = (((f).buf = fgetc((f).fp)) == %s) ? (((f).buf = %s), 1) : 0\n", C4_define, nlchr, spchr), Putl(output, 1);
X		(void)fprintf(output.fp, "%sGetchr(f) (f).buf, Getx(f)\n", C4_define), Putl(output, 1);
X	}
X	if (use(dread) || use(dreadln)) {
X		(void)fprintf(output.fp, "%sFILE%c*Tmpfil;\n", C50_static, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%slong%cTmplng;\n", C50_static, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sdouble%cTmpdbl;\n", C50_static, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sFscan(f) (f).init ? ungetc((f).buf, (f).fp) : 0, Tmpfil = (f).fp\n", C4_define), Putl(output, 1);
X		(void)fprintf(output.fp, "%sScan(p, a) Scanck(fscanf(Tmpfil, p, a))\n", C4_define), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%cScanck();\n", voidtyp, tab1), Putl(output, 1);
X		if (use(dreadln))
X			(void)fprintf(output.fp, "%s%cGetl();\n", voidtyp, tab1), Putl(output, 1);
X	}
X	if (use(deoln))
X		(void)fprintf(output.fp, "%sEoln(f) ((f).eoln ? true : false)\n", C4_define), Putl(output, 1);
X	if (use(deof))
X		(void)fprintf(output.fp, "%sEof(f) ((((f).init == 0) ? (Get(f)) : 0, ((f).eof ? 1 : feof((f).fp))) ? true : false)\n", C4_define), Putl(output, 1);
X	if (use(doutput) || use(dput) || use(dwrite) || use(dwriteln) || use(dreset) || use(drewrite) || use(dclose)) {
X		(void)fprintf(output.fp, "%sFwrite(x, f) fwrite((char *)&x, sizeof(x), 1, f)\n", C4_define), Putl(output, 1);
X		(void)fprintf(output.fp, "%sPut(f) Fwrite((f).buf, (f).fp)\n", C4_define), Putl(output, 1);
X		(void)fprintf(output.fp, "%sPutx(f) (f).eoln = ((f).buf == %s), %sfputc((f).buf, (f).fp)\n", C4_define, nlchr, voidcast), Putl(output, 1);
X		(void)fprintf(output.fp, "%sPutchr(c, f) (f).buf = (c), Putx(f)\n", C4_define), Putl(output, 1);
X		(void)fprintf(output.fp, "%sPutl(f, v) (f).eoln = v\n", C4_define), Putl(output, 1);
X	}
X	if (use(dreset) || use(drewrite) || use(dclose))
X		(void)fprintf(output.fp, "%sFinish(f) ((f).out && !(f).eoln) ? (Putchr(%s, f), 0) : 0, rewind((f).fp)\n", C4_define, nlchr), Putl(output, 1);
X	if (use(dclose)) {
X		(void)fprintf(output.fp, "%sClose(f) (f).init = ((f).init ? (fclose((f).fp), 0) : 0), (f).fp = NULL\n", C4_define), Putl(output, 1);
X		(void)fprintf(output.fp, "%sClosex(f) (f).init = ((f).init ? (Finish(f), fclose((f).fp), 0) : 0), (f).fp = NULL\n", C4_define), Putl(output, 1);
X	}
X	if (use(dreset)) {
X		(void)fprintf(output.fp, "%sREADONLY\n", ifdef), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%s%cRmode[] = \"r\";\n", C50_static, chartyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s\n", elsif), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%s%cRmode[] = \"r+\";\n", C50_static, chartyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s\n", endif), Putl(output, 1);
X		(void)fprintf(output.fp, "%sReset(f, n) (f).init = (f).init ? rewind((f).fp) : (((f).fp = Fopen(n, Rmode)), 1), (f).eof = (f).out = 0, Get(f)\n", C4_define), Putl(output, 1);
X		(void)fprintf(output.fp, "%sResetx(f, n) (f).init = (f).init ? (Finish(f)) : (((f).fp = Fopen(n, Rmode)), 1), (f).eof = (f).out = 0, Getx(f)\n", C4_define), Putl(output, 1);
X		usefopn = true;
X	}
X	if (use(drewrite)) {
X		(void)fprintf(output.fp, "%sWRITEONLY\n", ifdef), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%s%cWmode[] = \"w\";\n", C50_static, chartyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s\n", elsif), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%s%cWmode[] = \"w+\";\n", C50_static, chartyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s\n", endif), Putl(output, 1);
X		(void)fprintf(output.fp, "%sRewrite(f, n) (f).init = (f).init ? rewind((f).fp) : (((f).fp = Fopen(n, Wmode)), 1), (f).out = (f).eof = 1\n", C4_define), Putl(output, 1);
X		(void)fprintf(output.fp, "%sRewritex(f, n) (f).init = (f).init ? (Finish(f)) : (((f).fp = Fopen(n, Wmode)), 1), (f).out = (f).eof = (f).eoln = 1\n", C4_define), Putl(output, 1);
X		usefopn = true;
X	}
X	if (usefopn) {
X		(void)fprintf(output.fp, "FILE	*Fopen();\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%sMAXFILENAME 256\n", C4_define), Putl(output, 1);
X	}
X	if (usecase || usejmps) {
X		(void)fprintf(output.fp, "/*\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "**	Definitions for case-statements\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "**	and for non-local gotos\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "*/\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%sLine __LINE__\n", C4_define), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%cCaseerror();\n", voidtyp, tab1), Putl(output, 1);
X	}
X	if (usejmps) {
X		(void)fprintf(output.fp, "%s<setjmp.h>\n", C24_include), Putl(output, 1);
X		(void)fprintf(output.fp, "%sstruct Jb { jmp_buf%cjb; } J[%1d];\n", C50_static, tab1, (maxlevel + 1)), Putl(output, 1);
X	}
X	if (use(dinteger) || use(dmaxint) || use(dboolean) || use(dfalse) || use(dtrue) || use(deof) || use(deoln) || use(dexp) || use(dln) || use(dsqr) || use(dsin) || use(dcos) || use(dtan) || use(darctan) || use(dsqrt) || use(dreal)) {
X		(void)fprintf(output.fp, "/*\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "**	Definitions for standard types\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "*/\n"), Putl(output, 1);
X	}
X	if (usecomp) {
X		(void)fprintf(output.fp, "%s%s strncmp();\n", xtern, inttyp), Putl(output, 1);
X		(void)fprintf(output.fp, "%sCmpstr(x, y) strncmp((x), (y), sizeof(x))\n", C4_define), Putl(output, 1);
X	}
X	if (use(dboolean) || use(dfalse) || use(dtrue) || use(deof) || use(deoln) || usesets) {
X		capital(defnams.A[(int)(dboolean)]);
X		(void)fprintf(output.fp, "%s%s%c", typdef, chartyp, tab1), Putl(output, 0);
X		printid(defnams.A[(int)(dboolean)]->U.V6.lid);
X		Putchr(';', output),Putchr('\n', output);
X		capital(defnams.A[(int)(dfalse)]);
X		(void)fprintf(output.fp, "%s", C4_define), Putl(output, 0);
X		printid(defnams.A[(int)(dfalse)]->U.V6.lid);
X		(void)fprintf(output.fp, " ("), Putl(output, 0);
X		printid(defnams.A[(int)(dboolean)]->U.V6.lid);
X		(void)fprintf(output.fp, ")0\n"), Putl(output, 1);
X		capital(defnams.A[(int)(dtrue)]);
X		(void)fprintf(output.fp, "%s", C4_define), Putl(output, 0);
X		printid(defnams.A[(int)(dtrue)]->U.V6.lid);
X		(void)fprintf(output.fp, " ("), Putl(output, 0);
X		printid(defnams.A[(int)(dboolean)]->U.V6.lid);
X		(void)fprintf(output.fp, ")1\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%s%c*Bools[];\n", xtern, chartyp, tab1), Putl(output, 1);
X	}
X	capital(defnams.A[(int)(dinteger)]);
X	if (use(dinteger)) {
X		(void)fprintf(output.fp, "%s%s%c", typdef, inttyp, tab1), Putl(output, 0);
X		printid(defnams.A[(int)(dinteger)]->U.V6.lid);
X		Putchr(';', output),Putchr('\n', output);
X	}
X	if (use(dmaxint))
X		(void)fprintf(output.fp, "%smaxint%c%1d\n", C4_define, tab1, maxint), Putl(output, 1);
X	capital(defnams.A[(int)(dreal)]);
X	if (use(dreal)) {
X		(void)fprintf(output.fp, "%s%s%c", typdef, realtyp, tab1), Putl(output, 0);
X		printid(defnams.A[(int)(dreal)]->U.V6.lid);
X		Putchr(';', output),Putchr('\n', output);
X	}
X	if (use(dexp))
X		(void)fprintf(output.fp, "%s%s exp();\n", xtern, doubletyp), Putl(output, 1);
X	if (use(dln))
X		(void)fprintf(output.fp, "%s%s log();\n", xtern, doubletyp), Putl(output, 1);
X	if (use(dsqr))
X		(void)fprintf(output.fp, "%s%s pow();\n", xtern, doubletyp), Putl(output, 1);
X	if (use(dsin))
X		(void)fprintf(output.fp, "%s%s sin();\n", xtern, doubletyp), Putl(output, 1);
X	if (use(dcos))
X		(void)fprintf(output.fp, "%s%s cos();\n", xtern, doubletyp), Putl(output, 1);
X	if (use(dtan))
X		(void)fprintf(output.fp, "%s%s tan();\n", xtern, doubletyp), Putl(output, 1);
X	if (use(darctan))
X		(void)fprintf(output.fp, "%s%s atan();\n", xtern, doubletyp), Putl(output, 1);
X	if (use(dsqrt))
X		(void)fprintf(output.fp, "%s%s sqrt();\n", xtern, doubletyp), Putl(output, 1);
X	if (use(dabs) && use(dreal))
X		(void)fprintf(output.fp, "%s%s fabs();\n", xtern, doubletyp), Putl(output, 1);
X	if (use(dhalt))
X		(void)fprintf(output.fp, "%s%s abort();\n", xtern, voidtyp), Putl(output, 1);
X	if (use(dnew) || usenilp) {
X		(void)fprintf(output.fp, "/*\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "**	Definitions for pointers\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "*/\n"), Putl(output, 1);
X	}
X	if (use(dnew)) {
X		(void)fprintf(output.fp, "%sUnionoffs\n", ifndef), Putl(output, 1);
X		(void)fprintf(output.fp, "%sUnionoffs(p, m) (((long)(&(p)->m))-((long)(p)))\n", C4_define), Putl(output, 1);
X		(void)fprintf(output.fp, "%s\n", endif), Putl(output, 1);
X	}
X	if (usenilp)
X		(void)fprintf(output.fp, "%sNIL 0\n", C4_define), Putl(output, 1);
X	if (use(dnew))
X		(void)fprintf(output.fp, "%s%s *malloc();\n", xtern, chartyp), Putl(output, 1);
X	if (use(ddispose))
X		(void)fprintf(output.fp, "%s%s free();\n", xtern, voidtyp), Putl(output, 1);
X	if (usesets) {
X		(void)fprintf(output.fp, "/*\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "**	Definitions for set-operations\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "*/\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%sClaimset() %sCurrset(0, (%s)0)\n", C4_define, voidcast, setptyp), Putl(output, 1);
X		(void)fprintf(output.fp, "%sNewset() Currset(1, (%s)0)\n", C4_define, setptyp), Putl(output, 1);
X		(void)fprintf(output.fp, "%sSaveset(s) Currset(2, s)\n", C4_define), Putl(output, 1);
X		(void)fprintf(output.fp, "%ssetbits %1d\n", C4_define, C37_setbits), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%s%c%s;\n", typdef, wordtype, tab1, setwtyp), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%s *%c%s;\n", typdef, setwtyp, tab1, setptyp), Putl(output, 1);
X		printid(defnams.A[(int)(dboolean)]->U.V6.lid);
X		(void)fprintf(output.fp, "%cMember(), Le(), Ge(), Eq(), Ne();\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%cUnion(), Diff();\n", setptyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%cInsmem(), Mksubr();\n", setptyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%cCurrset(), Inter();\n", setptyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%s%cTmpset;\n", C50_static, setptyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%s%cConset[];\n", xtern, setptyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%cSetncpy();\n", voidtyp, tab1), Putl(output, 1);
X	}
X	(void)fprintf(output.fp, "%s%s *strncpy();\n", xtern, chartyp), Putl(output, 1);
X	if (use(dargc) || use(dargv)) {
X		(void)fprintf(output.fp, "/*\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "**	Definitions for argv-operations\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "*/\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%cargc;\n", inttyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%c**argv;\n", chartyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, " void\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "Argvgt(n, cp, l)\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%cn;\n", inttyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%s%cl;\n", registr, inttyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%s%c*cp;\n", registr, chartyp, tab1), Putl(output, 1);
X		Putchr('{', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "%c%s%s%c*sp;\n", tab1, registr, chartyp, tab1), Putl(output, 1);
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%cfor (sp = argv[n]; l > 0 && *sp; l--)\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s*cp++ = *sp++;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%cwhile (l-- > 0)\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s*cp++ = %s;\n", tab2, spchr), Putl(output, 1);
X		Putchr('}', output),Putchr('\n', output);
X	}
X	if ((tp->U.V13.tsubconst != (struct S61 *)NIL) || (tp->U.V13.tsubtype != (struct S61 *)NIL) || (tp->U.V13.tsubvar != (struct S61 *)NIL) || (tp->U.V13.tsubsub != (struct S61 *)NIL)) {
X		(void)fprintf(output.fp, "/*\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "**	Start of program definitions\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "*/\n"), Putl(output, 1);
X	}
X	econst(tp->U.V13.tsubconst);
X	etype(tp->U.V13.tsubtype);
X	evar(tp->U.V13.tsubvar);
X	if (tp->U.V13.tsubsub != (struct S61 *)NIL)
X		Putchr('\n', output);
X	esubr(tp->U.V13.tsubsub);
X	if (tp->U.V13.tsubid != (struct S61 *)NIL) {
X		(void)fprintf(output.fp, "/*\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "**	Start of program code\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "*/\n"), Putl(output, 1);
X		if (use(dargc) || use(dargv)) {
X			(void)fprintf(output.fp, "main(_ac, _av)\n"), Putl(output, 1);
X			(void)fprintf(output.fp, "%s%c_ac;\n", inttyp, tab1), Putl(output, 1);
X			(void)fprintf(output.fp, "%s%c*_av[];\n", chartyp, tab1), Putl(output, 1);
X			Putchr('{', output),Putchr('\n', output);
X			Putchr('\n', output);
X			(void)fprintf(output.fp, "%cargc = _ac;\n", tab1), Putl(output, 1);
X			(void)fprintf(output.fp, "%cargv = _av;\n", tab1), Putl(output, 1);
X		} else {
X			(void)fprintf(output.fp, "main()\n"), Putl(output, 1);
X			Putchr('{', output),Putchr('\n', output);
X		}
X		increment();
X		elabel(tp);
X		estmt(tp->U.V13.tsubstmt);
X		indent();
X		(void)fprintf(output.fp, "exit(0);\n"), Putl(output, 1);
X		decrement();
X		Putchr('}', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "/*\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "**	End of program code\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "*/\n"), Putl(output, 1);
X	}
X}
X
Xvoid econset();
X
X integer
Xsize(tp)
X	treeptr	tp;
X{
X	register integer	R175;
X	integer	r, x;
X
X	r = 0;
X	while (tp != (struct S61 *)NIL) {
X		if (tp->tt == nrange)
X			x = cvalof(tp->U.V41.texpr);
X		else
X			if (tp->tt == nempty)
X				x = 0;
X			else
X				x = cvalof(tp);
X		if (x > r)
X			r = x;
X		tp = tp->tnext;
X	}
X	R175 = csetwords(r + 1);
X	return R175;
X}
X
Xvoid ebits();
X
X void
Xeword(s)
X	bitset	s;
X{
X# define bitshex 4
X	integer	n;
X	register integer	i;
X	unsigned char	x;
X
X	n = 0;
X	while (n <= C37_setbits)
X		n = n + bitshex;
X	n = n - bitshex;
X	while (n >= 0) {
X		x = 0;
X		{
X			integer	B57 = 0,
X				B58 = bitshex - 1;
X
X			if (B57 <= B58)
X				for (i = B57; ; i++) {
X					if (Member((unsigned)((n + i)), s.S))
X						switch (i) {
X						  case 0:
X							x = x + 1;
X							break ;
X						  case 1:
X							x = x + 2;
X							break ;
X						  case 2:
X							x = x + 4;
X							break ;
X						  case 3:
X							x = x + 8;
X							break ;
X						  default:
X							Caseerror(Line);
X						}
X					if (i == B58) break;
X				}
X		}
X		Putchr(hexdig.A[x], output);
X		n = n - bitshex;
X	}
X}
X
X void
Xebits(tp)
X	treeptr	tp;
X{
X	typedef struct { bitset	A[maxsetrange + 1]; }	T74;
X	T74	sets;
X	integer	s;
X	register integer	m;
X	register integer	n;
X
X	s = size(tp);
X	{
X		integer	B59 = 0,
X			B60 = s - 1;
X
X		if (B59 <= B60)
X			for (n = B59; ; n++) {
X				Setncpy(sets.A[n].S, Conset[161], sizeof(sets.A[n].S));
X				if (n == B60) break;
X			}
X	}
X	while (tp != (struct S61 *)NIL) {
X		if (tp->tt == nrange)
X			{
X				integer	B61 = cvalof(tp->U.V41.texpl),
X					B62 = cvalof(tp->U.V41.texpr);
X
X				if (B61 <= B62)
X					for (m = B61; ; m++) {
X						n = m / (C37_setbits + 1);
X						Setncpy(sets.A[n].S, Union(sets.A[n].S, Saveset((Tmpset = Newset(), (void)Insmem((unsigned)(m % (C37_setbits + 1)), Tmpset), Tmpset))), sizeof(sets.A[n].S));
X						Claimset();
X						if (m == B62) break;
X					}
X			}
X		else
X			if (tp->tt != nempty) {
X				m = cvalof(tp);
X				n = m / (C37_setbits + 1);
X				Setncpy(sets.A[n].S, Union(sets.A[n].S, Saveset((Tmpset = Newset(), (void)Insmem((unsigned)(m % (C37_setbits + 1)), Tmpset), Tmpset))), sizeof(sets.A[n].S));
X				Claimset();
X			}
X		tp = tp->tnext;
X	}
X	(void)fprintf(output.fp, "%c%1d", tab1, s), Putl(output, 0);
X	{
X		integer	B63 = 0,
X			B64 = s - 1;
X
X		if (B63 <= B64)
X			for (n = B63; ; n++) {
X				Putchr(',', output);
X				if (n % 6 == 0)
X					Putchr('\n', output);
X				(void)fprintf(output.fp, "%c0x", tab1), Putl(output, 0);
X				eword(sets.A[n]);
X				if (n == B64) break;
X			}
X	}
X	Putchr('\n', output);
X}
X
X void
Xeconset(tp, len)
X	treeptr	tp;
X	integer	len;
X{
X	register integer	i;
X
X	i = 0;
X	while (tp != (struct S61 *)NIL) {
X		(void)fprintf(output.fp, "%s%s%cQ%1d[] = {\n", C50_static, setwtyp, tab1, i), Putl(output, 1);
X		ebits(tp->U.V42.texps);
X		(void)fprintf(output.fp, "};\n"), Putl(output, 1);
X		i = i + 1;
X		tp = tp->tnext;
X	}
X	(void)fprintf(output.fp, "%s%s%c*Conset[] = {\n", C50_static, setwtyp, tab1), Putl(output, 1);
X	{
X		integer	B65 = len - 1,
X			B66 = 1;
X
X		if (B65 >= B66)
X			for (i = B65; ; i--) {
X				(void)fprintf(output.fp, "%cQ%1d,", tab1, i), Putl(output, 0);
X				if (i % 6 == 5)
X					Putchr('\n', output);
X				if (i == B66) break;
X			}
X	}
X	(void)fprintf(output.fp, "%cQ0\n", tab1), Putl(output, 1);
X	(void)fprintf(output.fp, "};\n"), Putl(output, 1);
X}
X
X void
Xemit()
X{
X	static char	usigned[]	= "unsigned ";
X	boolean	conflag, setused, dropset, donearr;
X	integer	doarrow, indnt;
X	boolean	*F195;
X	boolean	*F197;
X	boolean	*F199;
X	boolean	*F201;
X	integer	*F203;
X	integer	*F205;
X
X	F205 = G204_indnt;
X	G204_indnt = &indnt;
X	F203 = G202_doarrow;
X	G202_doarrow = &doarrow;
X	F201 = G200_donearr;
X	G200_donearr = &donearr;
X	F199 = G198_dropset;
X	G198_dropset = &dropset;
X	F197 = G196_setused;
X	G196_setused = &setused;
X	F195 = G194_conflag;
X	G194_conflag = &conflag;
X	(*G204_indnt) = 0;
X	varno = 0;
X	(*G194_conflag) = false;
X	(*G196_setused) = false;
X	(*G198_dropset) = false;
X	(*G202_doarrow) = 0;
X	eprogram(top);
X	if (usebool)
X		(void)fprintf(output.fp, "%s%c*Bools[] = { \"false\", \"true\" };\n", chartyp, tab1), Putl(output, 1);
X	if (usescan) {
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%s%s\n", C50_static, voidtyp), Putl(output, 1);
X		(void)fprintf(output.fp, "Scanck(n)\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%cn;\n", inttyp, tab1), Putl(output, 1);
X		Putchr('{', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "%cif (n != 1) {\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%sfprintf(stderr, \"Bad input\\n\");\n", tab2, voidcast), Putl(output, 1);
X		(void)fprintf(output.fp, "%sexit(1);\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c}\n", tab1), Putl(output, 1);
X		Putchr('}', output),Putchr('\n', output);
X	}
X	if (usegetl) {
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%s%s\n", C50_static, voidtyp), Putl(output, 1);
X		(void)fprintf(output.fp, "Getl(f)\n"), Putl(output, 1);
X		(void)fprintf(output.fp, " text%c*f;\n", tab1), Putl(output, 1);
X		Putchr('{', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "%cwhile (f->eoln == 0)\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sGetx(*f);\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%cGetx(*f);\n", tab1), Putl(output, 1);
X		Putchr('}', output),Putchr('\n', output);
X	}
X	if (usefopn) {
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%sFILE *\n", C50_static), Putl(output, 1);
X		(void)fprintf(output.fp, "Fopen(n, m)\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%c*n, *m;\n", chartyp, tab1), Putl(output, 1);
X		Putchr('{', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "%cFILE%s*f;\n", tab1, tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%c*s;\n", tab1, registr, chartyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%cch = %cA%c;\n", tab1, C50_static, chartyp, tab1, quote, quote), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%ctmp[MAXFILENAME];\n", tab1, C50_static, chartyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%cunlink();\n", tab1, xtern, inttyp, tab1), Putl(output, 1);
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%cif (n == NULL)\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%ssprintf(tmp, %sch++);\n", tab2, tmpfilename), Putl(output, 1);
X		(void)fprintf(output.fp, "%celse {\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sstrncpy(tmp, n, sizeof(tmp));\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%sfor (s = &tmp[sizeof(tmp)-1]; *s == %s || *s == %s; )\n", tab2, spchr, nulchr), Putl(output, 1);
X		(void)fprintf(output.fp, "%s*s-- = %s;\n", tab3, nulchr), Putl(output, 1);
X		(void)fprintf(output.fp, "%sif (tmp[sizeof(tmp)-1]) {\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%sfprintf(stderr, \"Too long filename %c%%s%c\\n\", n);\n", tab3, voidcast, quote, quote), Putl(output, 1);
X		(void)fprintf(output.fp, "%sexit(1);\n", tab3), Putl(output, 1);
X		(void)fprintf(output.fp, "%s}\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c}\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cs = tmp;\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cif ((f = fopen(s, m)) == NULL) {\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%sfprintf(stderr, \"Cannot open: %%s\\n\", s);\n", tab2, voidcast), Putl(output, 1);
X		(void)fprintf(output.fp, "%sexit(1);\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c}\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cif (n == NULL)\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sunlink(tmp);\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%creturn (f);\n", tab1), Putl(output, 1);
X		Putchr('}', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "%s%s%crewind();\n", xtern, inttyp, tab1), Putl(output, 1);
X	}
X	if (setcnt > 0)
X		econset(setlst, setcnt);
X	if (useunion) {
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%s%s\n", C50_static, setptyp), Putl(output, 1);
X		(void)fprintf(output.fp, "Union(p1, p2)\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%cp1, p2;\n", tab1, registr, setptyp, tab1), Putl(output, 1);
X		Putchr('{', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "%c%s%s%si, j, k;\n", tab1, registr, inttyp, tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%ssp = Newset(),\n", tab1, registr, setptyp, tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%sp3 = sp;\n", tab4), Putl(output, 1);
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%cj = *p1;\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%c*p3 = j;\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cif (j > *p2)\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sj = *p2;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%celse\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s*p3 = *p2;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%ck = *p1 - *p2;\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cp1++, p2++, p3++;\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cfor (i = 0; i < j; i++)\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s*p3++ = (*p1++ | *p2++);\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%cwhile (k > 0) {\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s*p3++ = *p1++;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%sk--;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c}\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cwhile (k < 0) {\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s*p3++ = *p2++;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%sk++;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c}\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%creturn (Saveset(sp));\n", tab1), Putl(output, 1);
X		Putchr('}', output),Putchr('\n', output);
X	}
X	if (usediff) {
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%s%s\n", C50_static, setptyp), Putl(output, 1);
X		(void)fprintf(output.fp, "Diff(p1, p2)\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%cp1, p2;\n", tab1, registr, setptyp, tab1), Putl(output, 1);
X		Putchr('{', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "%c%s%s%si, j, k;\n", tab1, registr, inttyp, tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%ssp = Newset(),\n", tab1, registr, setptyp, tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%sp3 = sp;\n", tab4), Putl(output, 1);
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%cj = *p1;\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%c*p3 = j;\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cif (j > *p2)\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sj = *p2;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%ck = *p1 - *p2;\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cp1++, p2++, p3++;\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cfor (i = 0; i < j; i++)\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s*p3++ = (*p1++ & ~ (*p2++));\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%cwhile (k > 0) {\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s*p3++ = *p1++;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%sk--;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c}\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%creturn (Saveset(sp));\n", tab1), Putl(output, 1);
X		Putchr('}', output),Putchr('\n', output);
X	}
X	if (useintr) {
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%s%s\n", C50_static, setptyp), Putl(output, 1);
X		(void)fprintf(output.fp, "Inter(p1, p2)\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%cp1, p2;\n", tab1, registr, setptyp, tab1), Putl(output, 1);
X		Putchr('{', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "%c%s%s%si, j, k;\n", tab1, registr, inttyp, tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%ssp = Newset(),\n", tab1, registr, setptyp, tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%sp3 = sp;\n", tab4), Putl(output, 1);
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%cif ((j = *p1) > *p2)\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sj = *p2;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c*p3 = j;\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cp1++, p2++, p3++;\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cfor (i = 0; i < j; i++)\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s*p3++ = (*p1++ & *p2++);\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%creturn (Saveset(sp));\n", tab1), Putl(output, 1);
X		Putchr('}', output),Putchr('\n', output);
X	}
X	if (usememb) {
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%s", C50_static), Putl(output, 0);
X		printid(defnams.A[(int)(dboolean)]->U.V6.lid);
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "Member(m, sp)\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%s%cm;\n", tab1, registr, usigned, inttyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%csp;\n", tab1, registr, setptyp, tab1), Putl(output, 1);
X		Putchr('{', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "%c%s%s%s%ci = m / (setbits+1) + 1;\n", tab1, registr, usigned, inttyp, tab1), Putl(output, 1);
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%cif ((i <= *sp) && (sp[i] & (1 << (m %% (setbits+1)))))\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sreturn (", tab2), Putl(output, 0);
X		printid(defnams.A[(int)(dtrue)]->U.V6.lid);
X		(void)fprintf(output.fp, ");\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%creturn (", tab1), Putl(output, 0);
X		printid(defnams.A[(int)(dfalse)]->U.V6.lid);
X		(void)fprintf(output.fp, ");\n"), Putl(output, 1);
X		Putchr('}', output),Putchr('\n', output);
X	}
X	if (useseq || usesne) {
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%s", C50_static), Putl(output, 0);
X		printid(defnams.A[(int)(dboolean)]->U.V6.lid);
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "Eq(p1, p2)\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%cp1, p2;\n", tab1, registr, setptyp, tab1), Putl(output, 1);
X		Putchr('{', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "%c%s%s%ci, j;\n", tab1, registr, inttyp, tab1), Putl(output, 1);
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%ci = *p1++;\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cj = *p2++;\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cwhile (i != 0 && j != 0) {\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sif (*p1++ != *p2++)\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%sreturn (", tab3), Putl(output, 0);
X		printid(defnams.A[(int)(dfalse)]->U.V6.lid);
X		(void)fprintf(output.fp, ");\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%si--, j--;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c}\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cwhile (i != 0) {\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sif (*p1++ != 0)\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%sreturn (", tab3), Putl(output, 0);
X		printid(defnams.A[(int)(dfalse)]->U.V6.lid);
X		(void)fprintf(output.fp, ");\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%si--;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c}\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cwhile (j != 0) {\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sif (*p2++ != 0)\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%sreturn (", tab3), Putl(output, 0);
X		printid(defnams.A[(int)(dfalse)]->U.V6.lid);
X		(void)fprintf(output.fp, ");\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%sj--;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c}\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%creturn (", tab1), Putl(output, 0);
X		printid(defnams.A[(int)(dtrue)]->U.V6.lid);
X		(void)fprintf(output.fp, ");\n"), Putl(output, 1);
X		Putchr('}', output),Putchr('\n', output);
X	}
X	if (usesne) {
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%s", C50_static), Putl(output, 0);
X		printid(defnams.A[(int)(dboolean)]->U.V6.lid);
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "Ne(p1, p2)\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%cp1, p2;\n", tab1, registr, setptyp, tab1), Putl(output, 1);
X		Putchr('{', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "%creturn (!Eq(p1, p2));", tab1), Putl(output, 0);
X		Putchr('}', output),Putchr('\n', output);
X	}
X	if (usesle) {
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%s", C50_static), Putl(output, 0);
X		printid(defnams.A[(int)(dboolean)]->U.V6.lid);
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "Le(p1, p2)\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%cp1, p2;\n", tab1, registr, setptyp, tab1), Putl(output, 1);
X		Putchr('{', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "%c%s%s%ci, j;\n", tab1, registr, inttyp, tab1), Putl(output, 1);
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%ci = *p1++;\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cj = *p2++;\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cwhile (i != 0 && j != 0) {\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sif ((*p1++ & ~ *p2++) != 0)\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%sreturn (", tab3), Putl(output, 0);
X		printid(defnams.A[(int)(dfalse)]->U.V6.lid);
X		(void)fprintf(output.fp, ");\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%si--, j--;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c}\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cwhile (i != 0) {\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sif (*p1++ != 0)\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%sreturn (", tab3), Putl(output, 0);
X		printid(defnams.A[(int)(dfalse)]->U.V6.lid);
X		(void)fprintf(output.fp, ");\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%si--;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c}\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%creturn (", tab1), Putl(output, 0);
X		printid(defnams.A[(int)(dtrue)]->U.V6.lid);
X		(void)fprintf(output.fp, ");\n"), Putl(output, 1);
X		Putchr('}', output),Putchr('\n', output);
X	}
X	if (usesge) {
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%s", C50_static), Putl(output, 0);
X		printid(defnams.A[(int)(dboolean)]->U.V6.lid);
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "Ge(p1, p2)\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%cp1, p2;\n", tab1, registr, setptyp, tab1), Putl(output, 1);
X		Putchr('{', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "%c%s%s%ci, j;\n", tab1, registr, inttyp, tab1), Putl(output, 1);
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%ci = *p1++;\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cj = *p2++;\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cwhile (i != 0 && j != 0) {\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sif ((*p2++ & ~ *p1++) != 0)\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%sreturn (false);\n", tab3), Putl(output, 1);
X		(void)fprintf(output.fp, "%si--, j--;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c}\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cwhile (j != 0) {\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sif (*p2++ != 0)\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%sreturn (", tab3), Putl(output, 0);
X		printid(defnams.A[(int)(dfalse)]->U.V6.lid);
X		(void)fprintf(output.fp, ");\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%sj--;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c}\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%creturn (", tab1), Putl(output, 0);
X		printid(defnams.A[(int)(dtrue)]->U.V6.lid);
X		(void)fprintf(output.fp, ");\n"), Putl(output, 1);
X		Putchr('}', output),Putchr('\n', output);
X	}
X	if (usemksub) {
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%s%s\n", C50_static, setptyp), Putl(output, 1);
X		(void)fprintf(output.fp, "Mksubr(lo, hi, sp)\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%s%clo, hi;\n", tab1, registr, usigned, inttyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%csp;\n", tab1, registr, setptyp, tab1), Putl(output, 1);
X		Putchr('{', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "%c%s%s%ci, k;\n", tab1, registr, inttyp, tab1), Putl(output, 1);
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%cif (hi < lo)\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sreturn (sp);\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%ci = hi / (setbits+1) + 1;\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cfor (k = *sp + 1; k <= i; k++)\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%ssp[k] = 0;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%cif (*sp < i)\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s*sp = i;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%cfor (k = lo; k <= hi; k++)\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%ssp[k / (setbits+1) + 1] |= (1 << (k %% (setbits+1)));\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%creturn (sp);\n", tab1), Putl(output, 1);
X		Putchr('}', output),Putchr('\n', output);
X	}
X	if (useins) {
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%s%s\n", C50_static, setptyp), Putl(output, 1);
X		(void)fprintf(output.fp, "Insmem(m, sp)\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%s%cm;\n", tab1, registr, usigned, inttyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%csp;\n", tab1, registr, setptyp, tab1), Putl(output, 1);
X		Putchr('{', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "%c%s%s%ci,\n", tab1, registr, inttyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%cj = m / (setbits+1) + 1;\n", tab3, tab1), Putl(output, 1);
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%cif (*sp < j)\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sfor (i = *sp + 1, *sp = j; i <= *sp; i++)\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%ssp[i] = 0;\n", tab3), Putl(output, 1);
X		(void)fprintf(output.fp, "%csp[j] |= (1 << (m %% (setbits+1)));\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%creturn (sp);\n", tab1), Putl(output, 1);
X		Putchr('}', output),Putchr('\n', output);
X	}
X	if (usesets) {
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%sSETSPACE\n", ifndef), Putl(output, 1);
X		(void)fprintf(output.fp, "%sSETSPACE 256\n", C4_define), Putl(output, 1);
X		(void)fprintf(output.fp, "%s\n", endif), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%s\n", C50_static, setptyp), Putl(output, 1);
X		(void)fprintf(output.fp, "Currset(n,sp)\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%cn;\n", tab1, inttyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%csp;\n", tab1, setptyp, tab1), Putl(output, 1);
X		Putchr('{', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "%c%s%s%cSpace[SETSPACE];\n", tab1, C50_static, setwtyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%cTop = Space;\n", tab1, C50_static, setptyp, tab1), Putl(output, 1);
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%cswitch (n) {\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%c  case 0:\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sTop = Space;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%sreturn (0);\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c  case 1:\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sif (&Space[SETSPACE] - Top <= %1d) {\n", tab2, maxsetrange), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%sfprintf(stderr, \"Set-space exhausted\\n\");\n", tab3, voidcast), Putl(output, 1);
X		(void)fprintf(output.fp, "%sexit(1);\n", tab3), Putl(output, 1);
X		(void)fprintf(output.fp, "%s}\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%s*Top = 0;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%sreturn (Top);\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c  case 2:\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sif (Top <= &sp[*sp])\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%sTop = &sp[*sp + 1];\n", tab3), Putl(output, 1);
X		(void)fprintf(output.fp, "%sreturn (sp);\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c}\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%c/* NOTREACHED */\n", tab1), Putl(output, 1);
X		Putchr('}', output),Putchr('\n', output);
X	}
X	if (usescpy) {
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%s%s\n", C50_static, voidtyp), Putl(output, 1);
X		(void)fprintf(output.fp, "Setncpy(S1, S2, N)\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%cS1, S2;\n", tab1, registr, setptyp, tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%s%s%cN;\n", tab1, registr, usigned, inttyp, tab1), Putl(output, 1);
X		Putchr('{', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "%c%s%s%s%cm;\n", tab1, registr, usigned, inttyp, tab1), Putl(output, 1);
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%cN /= sizeof(%s);\n", tab1, setwtyp), Putl(output, 1);
X		(void)fprintf(output.fp, "%c*S1++ = --N;\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cm = *S2++;\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cwhile (m != 0 && N != 0) {\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s*S1++ = *S2++;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%s--N;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%s--m;\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%c}\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%cwhile (N-- != 0)\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%s*S1++ = 0;\n", tab2), Putl(output, 1);
X		Putchr('}', output),Putchr('\n', output);
X	}
X	if (usecase) {
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%s%s\n", C50_static, voidtyp), Putl(output, 1);
X		(void)fprintf(output.fp, "Caseerror(n)\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%cn;\n", tab1, inttyp, tab1), Putl(output, 1);
X		Putchr('{', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "%c%sfprintf(stderr, \"Missing case limb: line %%d\\n\", n);\n", tab1, voidcast), Putl(output, 1);
X		(void)fprintf(output.fp, "%cexit(1);\n", tab1), Putl(output, 1);
X		Putchr('}', output),Putchr('\n', output);
X	}
X	if (usemax) {
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "%s%s\n", C50_static, inttyp), Putl(output, 1);
X		(void)fprintf(output.fp, "Max(m, n)\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%c%s%cm, n;\n", tab1, inttyp, tab1), Putl(output, 1);
X		Putchr('{', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "%cif (m > n)\n", tab1), Putl(output, 1);
X		(void)fprintf(output.fp, "%sreturn (m);\n", tab2), Putl(output, 1);
X		(void)fprintf(output.fp, "%creturn (n);\n", tab1), Putl(output, 1);
X		Putchr('}', output),Putchr('\n', output);
X	}
X	if (use(dtrunc)) {
X		(void)fprintf(output.fp, "%s%s\n", C50_static, inttyp), Putl(output, 1);
X		(void)fprintf(output.fp, "Trunc(f)\n"), Putl(output, 1);
X		printid(defnams.A[(int)(dreal)]->U.V6.lid);
X		(void)fprintf(output.fp, "%cf;\n", tab1), Putl(output, 1);
X		Putchr('{', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "%creturn f;\n", tab1), Putl(output, 1);
X		Putchr('}', output),Putchr('\n', output);
X	}
X	if (use(dround)) {
X		(void)fprintf(output.fp, "%s%s\n", C50_static, inttyp), Putl(output, 1);
X		(void)fprintf(output.fp, "Round(f)\n"), Putl(output, 1);
X		printid(defnams.A[(int)(dreal)]->U.V6.lid);
X		(void)fprintf(output.fp, "%cf;\n", tab1), Putl(output, 1);
X		Putchr('{', output),Putchr('\n', output);
X		(void)fprintf(output.fp, "%c%s%s floor();\n", tab1, xtern, doubletyp), Putl(output, 1);
X		(void)fprintf(output.fp, "%creturn floor(%s(0.5+f));\n", tab1, dblcast), Putl(output, 1);
X		Putchr('}', output),Putchr('\n', output);
X	}
X	G194_conflag = F195;
X	G196_setused = F197;
X	G198_dropset = F199;
X	G200_donearr = F201;
X	G202_doarrow = F203;
X	G204_indnt = F205;
X}
X
Xvoid initialize();
X
X void
Xdefname(cn, str)
X	cnames	cn;
X	keyword	str;
X{
X	toknbuf	w;
X	register toknidx	i;
X
X	{   register int	_j, _i = 1 - 1;
X	    for (_j = 0; _j < 10; )
X		w.A[_i++] = str.A[_j++];
X	}
X	{
X		toknidx	B67 = 1,
X			B68 = keywordlen;
X
X		if (B67 <= B68)
X			for (i = B67; ; i++) {
X				if (w.A[i - 1] == space) {
X					w.A[i - 1] = null;
X					goto L999;
X				}
X				if (i == B68) break;
X			}
X	}
X	w.A[keywordlen + 1 - 1] = null;
XL999:
X	ctable.A[(int)(cn)] = saveid(&w);
X}
X
X void
Xdefid(nt, did, str)
X	treetyp	nt;
X	predefs	did;
X	keyword	str;
X{
X	toknbuf	w;
X	register toknidx	i;
X	treeptr	tp, tq, tv;
X
X	{
X		toknidx	B69 = 1,
X			B70 = keywordlen;
X
X		if (B69 <= B70)
X			for (i = B69; ; i++) {
X				if (str.A[i - 1] == space) {
X					w.A[i - 1] = null;
X					goto L999;
X				} else
X					w.A[i - 1] = str.A[i - 1];
X				if (i == B70) break;
X			}
X	}
X	w.A[keywordlen + 1 - 1] = null;
XL999:
X	tp = newid(saveid(&w));
X	defnams.A[(int)(did)] = tp->U.V43.tsym;
X	if (Member((unsigned)(nt), Conset[162])) {
X		tv = mknode(npredef);
X		tv->U.V12.tdef = did;
X		tv->U.V12.tobtyp = tnone;
X	} else
X		tv = (struct S61 *)NIL;
X	switch (nt) {
X	  case nscalar:
X		tv = mknode(nscalar);
X		tv->U.V17.tscalid = (struct S61 *)NIL;
X		tq = mknode(ntype);
X		tq->U.V14.tbind = tv;
X		tq->U.V14.tidl = tp;
X		tp = tq;
X		break ;
X	  case nconst:  case ntype:  case nfield:  case nvar:
X		tq = mknode(nt);
X		tq->U.V14.tbind = tv;
X		tq->U.V14.tidl = tp;
X		tq->U.V14.tattr = anone;
X		tp = tq;
X		break ;
X	  case nfunc:  case nproc:
X		tq = mknode(nt);
X		tq->U.V13.tsubid = tp;
X		tq->U.V13.tsubstmt = tv;
X		tq->U.V13.tfuntyp = (struct S61 *)NIL;
X		tq->U.V13.tsubpar = (struct S61 *)NIL;
X		tq->U.V13.tsublab = (struct S61 *)NIL;
X		tq->U.V13.tsubconst = (struct S61 *)NIL;
X		tq->U.V13.tsubtype = (struct S61 *)NIL;
X		tq->U.V13.tsubvar = (struct S61 *)NIL;
X		tq->U.V13.tsubsub = (struct S61 *)NIL;
X		tq->U.V13.tscope = (struct S60 *)NIL;
X		tq->U.V13.tstat = 0;
X		tp = tq;
X		break ;
X	  case nid:
X		break ;
X	  default:
X		Caseerror(Line);
X	}
X	deftab.A[(int)(did)] = tp;
X}
X
X void
Xdefkey(s, w)
X	symtyp	s;
X	keyword	w;
X{
X	register unsigned char	i;
X
X	{
X		unsigned char	B71 = 1,
X			B72 = keywordlen;
X
X		if (B71 <= B72)
X			for (i = B71; ; i++) {
X				if (w.A[i - 1] == space)
X					w.A[i - 1] = null;
X				if (i == B72) break;
X			}
X	}
X	{
X		register struct S206 *W73 = &keytab.A[(unsigned)(s)];
X
X		W73->wrd = w;
X		W73->sym = s;
X	}
X}
X
X void
Xfixinit(i)
X	strindx	i;
X{
X	toknbuf	t;
X
X	gettokn(i, &t);
X	t.A[1 - 1] = 'i';
X	puttokn(i, &t);
X}
X
END_OF_FILE
if test 44980 -ne `wc -c <'ptc.c.6'`; then
    echo shar: \"'ptc.c.6'\" unpacked with wrong size!
fi
# end of 'ptc.c.6'
fi
echo shar: End of archive 8 \(of 12\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 12 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 

Rich $alz			"Anger is an energy"
Cronus Project, BBN Labs	rsalz@bbn.com
Moderator, comp.sources.unix	sources@uunet.uu.net
